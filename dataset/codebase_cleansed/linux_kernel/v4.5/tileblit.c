static void tile_bmove(struct vc_data *vc, struct fb_info *info, int sy,\r\nint sx, int dy, int dx, int height, int width)\r\n{\r\nstruct fb_tilearea area;\r\narea.sx = sx;\r\narea.sy = sy;\r\narea.dx = dx;\r\narea.dy = dy;\r\narea.height = height;\r\narea.width = width;\r\ninfo->tileops->fb_tilecopy(info, &area);\r\n}\r\nstatic void tile_clear(struct vc_data *vc, struct fb_info *info, int sy,\r\nint sx, int height, int width)\r\n{\r\nstruct fb_tilerect rect;\r\nint bgshift = (vc->vc_hi_font_mask) ? 13 : 12;\r\nint fgshift = (vc->vc_hi_font_mask) ? 9 : 8;\r\nrect.index = vc->vc_video_erase_char &\r\n((vc->vc_hi_font_mask) ? 0x1ff : 0xff);\r\nrect.fg = attr_fgcol_ec(fgshift, vc, info);\r\nrect.bg = attr_bgcol_ec(bgshift, vc, info);\r\nrect.sx = sx;\r\nrect.sy = sy;\r\nrect.width = width;\r\nrect.height = height;\r\nrect.rop = ROP_COPY;\r\ninfo->tileops->fb_tilefill(info, &rect);\r\n}\r\nstatic void tile_putcs(struct vc_data *vc, struct fb_info *info,\r\nconst unsigned short *s, int count, int yy, int xx,\r\nint fg, int bg)\r\n{\r\nstruct fb_tileblit blit;\r\nunsigned short charmask = vc->vc_hi_font_mask ? 0x1ff : 0xff;\r\nint size = sizeof(u32) * count, i;\r\nblit.sx = xx;\r\nblit.sy = yy;\r\nblit.width = count;\r\nblit.height = 1;\r\nblit.fg = fg;\r\nblit.bg = bg;\r\nblit.length = count;\r\nblit.indices = (u32 *) fb_get_buffer_offset(info, &info->pixmap, size);\r\nfor (i = 0; i < count; i++)\r\nblit.indices[i] = (u32)(scr_readw(s++) & charmask);\r\ninfo->tileops->fb_tileblit(info, &blit);\r\n}\r\nstatic void tile_clear_margins(struct vc_data *vc, struct fb_info *info,\r\nint bottom_only)\r\n{\r\nreturn;\r\n}\r\nstatic void tile_cursor(struct vc_data *vc, struct fb_info *info, int mode,\r\nint softback_lines, int fg, int bg)\r\n{\r\nstruct fb_tilecursor cursor;\r\nint use_sw = (vc->vc_cursor_type & 0x10);\r\ncursor.sx = vc->vc_x;\r\ncursor.sy = vc->vc_y;\r\ncursor.mode = (mode == CM_ERASE || use_sw) ? 0 : 1;\r\ncursor.fg = fg;\r\ncursor.bg = bg;\r\nswitch (vc->vc_cursor_type & 0x0f) {\r\ncase CUR_NONE:\r\ncursor.shape = FB_TILE_CURSOR_NONE;\r\nbreak;\r\ncase CUR_UNDERLINE:\r\ncursor.shape = FB_TILE_CURSOR_UNDERLINE;\r\nbreak;\r\ncase CUR_LOWER_THIRD:\r\ncursor.shape = FB_TILE_CURSOR_LOWER_THIRD;\r\nbreak;\r\ncase CUR_LOWER_HALF:\r\ncursor.shape = FB_TILE_CURSOR_LOWER_HALF;\r\nbreak;\r\ncase CUR_TWO_THIRDS:\r\ncursor.shape = FB_TILE_CURSOR_TWO_THIRDS;\r\nbreak;\r\ncase CUR_BLOCK:\r\ndefault:\r\ncursor.shape = FB_TILE_CURSOR_BLOCK;\r\nbreak;\r\n}\r\ninfo->tileops->fb_tilecursor(info, &cursor);\r\n}\r\nstatic int tile_update_start(struct fb_info *info)\r\n{\r\nstruct fbcon_ops *ops = info->fbcon_par;\r\nint err;\r\nerr = fb_pan_display(info, &ops->var);\r\nops->var.xoffset = info->var.xoffset;\r\nops->var.yoffset = info->var.yoffset;\r\nops->var.vmode = info->var.vmode;\r\nreturn err;\r\n}\r\nvoid fbcon_set_tileops(struct vc_data *vc, struct fb_info *info)\r\n{\r\nstruct fb_tilemap map;\r\nstruct fbcon_ops *ops = info->fbcon_par;\r\nops->bmove = tile_bmove;\r\nops->clear = tile_clear;\r\nops->putcs = tile_putcs;\r\nops->clear_margins = tile_clear_margins;\r\nops->cursor = tile_cursor;\r\nops->update_start = tile_update_start;\r\nif (ops->p) {\r\nmap.width = vc->vc_font.width;\r\nmap.height = vc->vc_font.height;\r\nmap.depth = 1;\r\nmap.length = (ops->p->userfont) ?\r\nFNTCHARCNT(ops->p->fontdata) : 256;\r\nmap.data = ops->p->fontdata;\r\ninfo->tileops->fb_settile(info, &map);\r\n}\r\n}
