static int jz4740_wdt_ping(struct watchdog_device *wdt_dev)\r\n{\r\nstruct jz4740_wdt_drvdata *drvdata = watchdog_get_drvdata(wdt_dev);\r\nwritew(0x0, drvdata->base + JZ_REG_WDT_TIMER_COUNTER);\r\nreturn 0;\r\n}\r\nstatic int jz4740_wdt_set_timeout(struct watchdog_device *wdt_dev,\r\nunsigned int new_timeout)\r\n{\r\nstruct jz4740_wdt_drvdata *drvdata = watchdog_get_drvdata(wdt_dev);\r\nunsigned int rtc_clk_rate;\r\nunsigned int timeout_value;\r\nunsigned short clock_div = JZ_WDT_CLOCK_DIV_1;\r\nrtc_clk_rate = clk_get_rate(drvdata->rtc_clk);\r\ntimeout_value = rtc_clk_rate * new_timeout;\r\nwhile (timeout_value > 0xffff) {\r\nif (clock_div == JZ_WDT_CLOCK_DIV_1024) {\r\ntimeout_value = 0xffff;\r\nbreak;\r\n}\r\ntimeout_value >>= 2;\r\nclock_div += (1 << JZ_WDT_CLOCK_DIV_SHIFT);\r\n}\r\nwriteb(0x0, drvdata->base + JZ_REG_WDT_COUNTER_ENABLE);\r\nwritew(clock_div, drvdata->base + JZ_REG_WDT_TIMER_CONTROL);\r\nwritew((u16)timeout_value, drvdata->base + JZ_REG_WDT_TIMER_DATA);\r\nwritew(0x0, drvdata->base + JZ_REG_WDT_TIMER_COUNTER);\r\nwritew(clock_div | JZ_WDT_CLOCK_RTC,\r\ndrvdata->base + JZ_REG_WDT_TIMER_CONTROL);\r\nwriteb(0x1, drvdata->base + JZ_REG_WDT_COUNTER_ENABLE);\r\nwdt_dev->timeout = new_timeout;\r\nreturn 0;\r\n}\r\nstatic int jz4740_wdt_start(struct watchdog_device *wdt_dev)\r\n{\r\njz4740_timer_enable_watchdog();\r\njz4740_wdt_set_timeout(wdt_dev, wdt_dev->timeout);\r\nreturn 0;\r\n}\r\nstatic int jz4740_wdt_stop(struct watchdog_device *wdt_dev)\r\n{\r\nstruct jz4740_wdt_drvdata *drvdata = watchdog_get_drvdata(wdt_dev);\r\njz4740_timer_disable_watchdog();\r\nwriteb(0x0, drvdata->base + JZ_REG_WDT_COUNTER_ENABLE);\r\nreturn 0;\r\n}\r\nstatic int jz4740_wdt_probe(struct platform_device *pdev)\r\n{\r\nstruct jz4740_wdt_drvdata *drvdata;\r\nstruct watchdog_device *jz4740_wdt;\r\nstruct resource *res;\r\nint ret;\r\ndrvdata = devm_kzalloc(&pdev->dev, sizeof(struct jz4740_wdt_drvdata),\r\nGFP_KERNEL);\r\nif (!drvdata) {\r\ndev_err(&pdev->dev, "Unable to alloacate watchdog device\n");\r\nreturn -ENOMEM;\r\n}\r\nif (heartbeat < 1 || heartbeat > MAX_HEARTBEAT)\r\nheartbeat = DEFAULT_HEARTBEAT;\r\njz4740_wdt = &drvdata->wdt;\r\njz4740_wdt->info = &jz4740_wdt_info;\r\njz4740_wdt->ops = &jz4740_wdt_ops;\r\njz4740_wdt->timeout = heartbeat;\r\njz4740_wdt->min_timeout = 1;\r\njz4740_wdt->max_timeout = MAX_HEARTBEAT;\r\njz4740_wdt->parent = &pdev->dev;\r\nwatchdog_set_nowayout(jz4740_wdt, nowayout);\r\nwatchdog_set_drvdata(jz4740_wdt, drvdata);\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\ndrvdata->base = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(drvdata->base)) {\r\nret = PTR_ERR(drvdata->base);\r\ngoto err_out;\r\n}\r\ndrvdata->rtc_clk = clk_get(&pdev->dev, "rtc");\r\nif (IS_ERR(drvdata->rtc_clk)) {\r\ndev_err(&pdev->dev, "cannot find RTC clock\n");\r\nret = PTR_ERR(drvdata->rtc_clk);\r\ngoto err_out;\r\n}\r\nret = watchdog_register_device(&drvdata->wdt);\r\nif (ret < 0)\r\ngoto err_disable_clk;\r\nplatform_set_drvdata(pdev, drvdata);\r\nreturn 0;\r\nerr_disable_clk:\r\nclk_put(drvdata->rtc_clk);\r\nerr_out:\r\nreturn ret;\r\n}\r\nstatic int jz4740_wdt_remove(struct platform_device *pdev)\r\n{\r\nstruct jz4740_wdt_drvdata *drvdata = platform_get_drvdata(pdev);\r\njz4740_wdt_stop(&drvdata->wdt);\r\nwatchdog_unregister_device(&drvdata->wdt);\r\nclk_put(drvdata->rtc_clk);\r\nreturn 0;\r\n}
