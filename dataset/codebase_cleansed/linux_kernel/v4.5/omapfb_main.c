static void omapdss_release(struct device *dev)\r\n{\r\n}\r\nstatic void omapfb_rqueue_lock(struct omapfb_device *fbdev)\r\n{\r\nmutex_lock(&fbdev->rqueue_mutex);\r\n}\r\nstatic void omapfb_rqueue_unlock(struct omapfb_device *fbdev)\r\n{\r\nmutex_unlock(&fbdev->rqueue_mutex);\r\n}\r\nstatic int ctrl_init(struct omapfb_device *fbdev)\r\n{\r\nint r;\r\nint i;\r\nif (def_vram_cnt) {\r\nfor (i = 0; i < def_vram_cnt; i++)\r\nfbdev->mem_desc.region[i].size =\r\nPAGE_ALIGN(def_vram[i]);\r\nfbdev->mem_desc.region_cnt = i;\r\n}\r\nif (!fbdev->mem_desc.region_cnt) {\r\nstruct lcd_panel *panel = fbdev->panel;\r\nint def_size;\r\nint bpp = panel->bpp;\r\nif (bpp == 12)\r\nbpp = 16;\r\ndef_size = def_vxres * def_vyres * bpp / 8;\r\nfbdev->mem_desc.region_cnt = 1;\r\nfbdev->mem_desc.region[0].size = PAGE_ALIGN(def_size);\r\n}\r\nr = fbdev->ctrl->init(fbdev, 0, &fbdev->mem_desc);\r\nif (r < 0) {\r\ndev_err(fbdev->dev, "controller initialization failed (%d)\n",\r\nr);\r\nreturn r;\r\n}\r\n#ifdef DEBUG\r\nfor (i = 0; i < fbdev->mem_desc.region_cnt; i++) {\r\ndev_dbg(fbdev->dev, "region%d phys %08x virt %p size=%lu\n",\r\ni,\r\nfbdev->mem_desc.region[i].paddr,\r\nfbdev->mem_desc.region[i].vaddr,\r\nfbdev->mem_desc.region[i].size);\r\n}\r\n#endif\r\nreturn 0;\r\n}\r\nstatic void ctrl_cleanup(struct omapfb_device *fbdev)\r\n{\r\nfbdev->ctrl->cleanup();\r\n}\r\nstatic int ctrl_change_mode(struct fb_info *fbi)\r\n{\r\nint r;\r\nunsigned long offset;\r\nstruct omapfb_plane_struct *plane = fbi->par;\r\nstruct omapfb_device *fbdev = plane->fbdev;\r\nstruct fb_var_screeninfo *var = &fbi->var;\r\noffset = var->yoffset * fbi->fix.line_length +\r\nvar->xoffset * var->bits_per_pixel / 8;\r\nif (fbdev->ctrl->sync)\r\nfbdev->ctrl->sync();\r\nr = fbdev->ctrl->setup_plane(plane->idx, plane->info.channel_out,\r\noffset, var->xres_virtual,\r\nplane->info.pos_x, plane->info.pos_y,\r\nvar->xres, var->yres, plane->color_mode);\r\nif (r < 0)\r\nreturn r;\r\nif (fbdev->ctrl->set_rotate != NULL) {\r\nr = fbdev->ctrl->set_rotate(var->rotate);\r\nif (r < 0)\r\nreturn r;\r\n}\r\nif (fbdev->ctrl->set_scale != NULL)\r\nr = fbdev->ctrl->set_scale(plane->idx,\r\nvar->xres, var->yres,\r\nplane->info.out_width,\r\nplane->info.out_height);\r\nreturn r;\r\n}\r\nstatic int omapfb_open(struct fb_info *info, int user)\r\n{\r\nreturn 0;\r\n}\r\nstatic int omapfb_release(struct fb_info *info, int user)\r\n{\r\nomapfb_sync(info);\r\nreturn 0;\r\n}\r\nstatic int _setcolreg(struct fb_info *info, u_int regno, u_int red, u_int green,\r\nu_int blue, u_int transp, int update_hw_pal)\r\n{\r\nstruct omapfb_plane_struct *plane = info->par;\r\nstruct omapfb_device *fbdev = plane->fbdev;\r\nstruct fb_var_screeninfo *var = &info->var;\r\nint r = 0;\r\nswitch (plane->color_mode) {\r\ncase OMAPFB_COLOR_YUV422:\r\ncase OMAPFB_COLOR_YUV420:\r\ncase OMAPFB_COLOR_YUY422:\r\nr = -EINVAL;\r\nbreak;\r\ncase OMAPFB_COLOR_CLUT_8BPP:\r\ncase OMAPFB_COLOR_CLUT_4BPP:\r\ncase OMAPFB_COLOR_CLUT_2BPP:\r\ncase OMAPFB_COLOR_CLUT_1BPP:\r\nif (fbdev->ctrl->setcolreg)\r\nr = fbdev->ctrl->setcolreg(regno, red, green, blue,\r\ntransp, update_hw_pal);\r\ncase OMAPFB_COLOR_RGB565:\r\ncase OMAPFB_COLOR_RGB444:\r\nif (r != 0)\r\nbreak;\r\nif (regno < 16) {\r\nu16 pal;\r\npal = ((red >> (16 - var->red.length)) <<\r\nvar->red.offset) |\r\n((green >> (16 - var->green.length)) <<\r\nvar->green.offset) |\r\n(blue >> (16 - var->blue.length));\r\n((u32 *)(info->pseudo_palette))[regno] = pal;\r\n}\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\nreturn r;\r\n}\r\nstatic int omapfb_setcolreg(u_int regno, u_int red, u_int green, u_int blue,\r\nu_int transp, struct fb_info *info)\r\n{\r\nreturn _setcolreg(info, regno, red, green, blue, transp, 1);\r\n}\r\nstatic int omapfb_setcmap(struct fb_cmap *cmap, struct fb_info *info)\r\n{\r\nint count, index, r;\r\nu16 *red, *green, *blue, *transp;\r\nu16 trans = 0xffff;\r\nred = cmap->red;\r\ngreen = cmap->green;\r\nblue = cmap->blue;\r\ntransp = cmap->transp;\r\nindex = cmap->start;\r\nfor (count = 0; count < cmap->len; count++) {\r\nif (transp)\r\ntrans = *transp++;\r\nr = _setcolreg(info, index++, *red++, *green++, *blue++, trans,\r\ncount == cmap->len - 1);\r\nif (r != 0)\r\nreturn r;\r\n}\r\nreturn 0;\r\n}\r\nstatic int omapfb_blank(int blank, struct fb_info *fbi)\r\n{\r\nstruct omapfb_plane_struct *plane = fbi->par;\r\nstruct omapfb_device *fbdev = plane->fbdev;\r\nint do_update = 0;\r\nint r = 0;\r\nomapfb_rqueue_lock(fbdev);\r\nswitch (blank) {\r\ncase FB_BLANK_UNBLANK:\r\nif (fbdev->state == OMAPFB_SUSPENDED) {\r\nif (fbdev->ctrl->resume)\r\nfbdev->ctrl->resume();\r\nfbdev->panel->enable(fbdev->panel);\r\nfbdev->state = OMAPFB_ACTIVE;\r\nif (fbdev->ctrl->get_update_mode() ==\r\nOMAPFB_MANUAL_UPDATE)\r\ndo_update = 1;\r\n}\r\nbreak;\r\ncase FB_BLANK_POWERDOWN:\r\nif (fbdev->state == OMAPFB_ACTIVE) {\r\nfbdev->panel->disable(fbdev->panel);\r\nif (fbdev->ctrl->suspend)\r\nfbdev->ctrl->suspend();\r\nfbdev->state = OMAPFB_SUSPENDED;\r\n}\r\nbreak;\r\ndefault:\r\nr = -EINVAL;\r\n}\r\nomapfb_rqueue_unlock(fbdev);\r\nif (r == 0 && do_update)\r\nr = omapfb_update_full_screen(fbi);\r\nreturn r;\r\n}\r\nstatic void omapfb_sync(struct fb_info *fbi)\r\n{\r\nstruct omapfb_plane_struct *plane = fbi->par;\r\nstruct omapfb_device *fbdev = plane->fbdev;\r\nomapfb_rqueue_lock(fbdev);\r\nif (fbdev->ctrl->sync)\r\nfbdev->ctrl->sync();\r\nomapfb_rqueue_unlock(fbdev);\r\n}\r\nstatic void set_fb_fix(struct fb_info *fbi, int from_init)\r\n{\r\nstruct fb_fix_screeninfo *fix = &fbi->fix;\r\nstruct fb_var_screeninfo *var = &fbi->var;\r\nstruct omapfb_plane_struct *plane = fbi->par;\r\nstruct omapfb_mem_region *rg;\r\nint bpp;\r\nrg = &plane->fbdev->mem_desc.region[plane->idx];\r\nfbi->screen_base = rg->vaddr;\r\nif (!from_init) {\r\nmutex_lock(&fbi->mm_lock);\r\nfix->smem_start = rg->paddr;\r\nfix->smem_len = rg->size;\r\nmutex_unlock(&fbi->mm_lock);\r\n} else {\r\nfix->smem_start = rg->paddr;\r\nfix->smem_len = rg->size;\r\n}\r\nfix->type = FB_TYPE_PACKED_PIXELS;\r\nbpp = var->bits_per_pixel;\r\nif (var->nonstd)\r\nfix->visual = FB_VISUAL_PSEUDOCOLOR;\r\nelse switch (var->bits_per_pixel) {\r\ncase 16:\r\ncase 12:\r\nfix->visual = FB_VISUAL_TRUECOLOR;\r\nbpp = 16;\r\nbreak;\r\ncase 1:\r\ncase 2:\r\ncase 4:\r\ncase 8:\r\nfix->visual = FB_VISUAL_PSEUDOCOLOR;\r\nbreak;\r\n}\r\nfix->accel = FB_ACCEL_OMAP1610;\r\nfix->line_length = var->xres_virtual * bpp / 8;\r\n}\r\nstatic int set_color_mode(struct omapfb_plane_struct *plane,\r\nstruct fb_var_screeninfo *var)\r\n{\r\nswitch (var->nonstd) {\r\ncase 0:\r\nbreak;\r\ncase OMAPFB_COLOR_YUV422:\r\nvar->bits_per_pixel = 16;\r\nplane->color_mode = var->nonstd;\r\nreturn 0;\r\ncase OMAPFB_COLOR_YUV420:\r\nvar->bits_per_pixel = 12;\r\nplane->color_mode = var->nonstd;\r\nreturn 0;\r\ncase OMAPFB_COLOR_YUY422:\r\nvar->bits_per_pixel = 16;\r\nplane->color_mode = var->nonstd;\r\nreturn 0;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (var->bits_per_pixel) {\r\ncase 1:\r\nplane->color_mode = OMAPFB_COLOR_CLUT_1BPP;\r\nreturn 0;\r\ncase 2:\r\nplane->color_mode = OMAPFB_COLOR_CLUT_2BPP;\r\nreturn 0;\r\ncase 4:\r\nplane->color_mode = OMAPFB_COLOR_CLUT_4BPP;\r\nreturn 0;\r\ncase 8:\r\nplane->color_mode = OMAPFB_COLOR_CLUT_8BPP;\r\nreturn 0;\r\ncase 12:\r\nvar->bits_per_pixel = 16;\r\ncase 16:\r\nif (plane->fbdev->panel->bpp == 12)\r\nplane->color_mode = OMAPFB_COLOR_RGB444;\r\nelse\r\nplane->color_mode = OMAPFB_COLOR_RGB565;\r\nreturn 0;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic int set_fb_var(struct fb_info *fbi,\r\nstruct fb_var_screeninfo *var)\r\n{\r\nint bpp;\r\nunsigned long max_frame_size;\r\nunsigned long line_size;\r\nint xres_min, xres_max;\r\nint yres_min, yres_max;\r\nstruct omapfb_plane_struct *plane = fbi->par;\r\nstruct omapfb_device *fbdev = plane->fbdev;\r\nstruct lcd_panel *panel = fbdev->panel;\r\nif (set_color_mode(plane, var) < 0)\r\nreturn -EINVAL;\r\nbpp = var->bits_per_pixel;\r\nif (plane->color_mode == OMAPFB_COLOR_RGB444)\r\nbpp = 16;\r\nswitch (var->rotate) {\r\ncase 0:\r\ncase 180:\r\nxres_min = OMAPFB_PLANE_XRES_MIN;\r\nxres_max = panel->x_res;\r\nyres_min = OMAPFB_PLANE_YRES_MIN;\r\nyres_max = panel->y_res;\r\nif (cpu_is_omap15xx()) {\r\nvar->xres = panel->x_res;\r\nvar->yres = panel->y_res;\r\n}\r\nbreak;\r\ncase 90:\r\ncase 270:\r\nxres_min = OMAPFB_PLANE_YRES_MIN;\r\nxres_max = panel->y_res;\r\nyres_min = OMAPFB_PLANE_XRES_MIN;\r\nyres_max = panel->x_res;\r\nif (cpu_is_omap15xx()) {\r\nvar->xres = panel->y_res;\r\nvar->yres = panel->x_res;\r\n}\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (var->xres < xres_min)\r\nvar->xres = xres_min;\r\nif (var->yres < yres_min)\r\nvar->yres = yres_min;\r\nif (var->xres > xres_max)\r\nvar->xres = xres_max;\r\nif (var->yres > yres_max)\r\nvar->yres = yres_max;\r\nif (var->xres_virtual < var->xres)\r\nvar->xres_virtual = var->xres;\r\nif (var->yres_virtual < var->yres)\r\nvar->yres_virtual = var->yres;\r\nmax_frame_size = fbdev->mem_desc.region[plane->idx].size;\r\nline_size = var->xres_virtual * bpp / 8;\r\nif (line_size * var->yres_virtual > max_frame_size) {\r\nline_size = max_frame_size / var->yres_virtual;\r\nvar->xres_virtual = line_size * 8 / bpp;\r\nif (var->xres_virtual < var->xres) {\r\nvar->xres_virtual = var->xres;\r\nline_size = var->xres * bpp / 8;\r\nvar->yres_virtual = max_frame_size / line_size;\r\n}\r\nif (var->xres_virtual < var->xres)\r\nvar->xres = var->xres_virtual;\r\nif (var->yres_virtual < var->yres)\r\nvar->yres = var->yres_virtual;\r\nif (var->xres < xres_min || var->yres < yres_min)\r\nreturn -EINVAL;\r\n}\r\nif (var->xres + var->xoffset > var->xres_virtual)\r\nvar->xoffset = var->xres_virtual - var->xres;\r\nif (var->yres + var->yoffset > var->yres_virtual)\r\nvar->yoffset = var->yres_virtual - var->yres;\r\nif (plane->color_mode == OMAPFB_COLOR_RGB444) {\r\nvar->red.offset = 8; var->red.length = 4;\r\nvar->red.msb_right = 0;\r\nvar->green.offset = 4; var->green.length = 4;\r\nvar->green.msb_right = 0;\r\nvar->blue.offset = 0; var->blue.length = 4;\r\nvar->blue.msb_right = 0;\r\n} else {\r\nvar->red.offset = 11; var->red.length = 5;\r\nvar->red.msb_right = 0;\r\nvar->green.offset = 5; var->green.length = 6;\r\nvar->green.msb_right = 0;\r\nvar->blue.offset = 0; var->blue.length = 5;\r\nvar->blue.msb_right = 0;\r\n}\r\nvar->height = -1;\r\nvar->width = -1;\r\nvar->grayscale = 0;\r\nvar->pixclock = 10000000 / (panel->pixel_clock / 100);\r\nvar->left_margin = panel->hfp;\r\nvar->right_margin = panel->hbp;\r\nvar->upper_margin = panel->vfp;\r\nvar->lower_margin = panel->vbp;\r\nvar->hsync_len = panel->hsw;\r\nvar->vsync_len = panel->vsw;\r\nvar->vmode = FB_VMODE_NONINTERLACED;\r\nvar->sync = 0;\r\nreturn 0;\r\n}\r\nstatic void omapfb_rotate(struct fb_info *fbi, int rotate)\r\n{\r\nstruct omapfb_plane_struct *plane = fbi->par;\r\nstruct omapfb_device *fbdev = plane->fbdev;\r\nomapfb_rqueue_lock(fbdev);\r\nif (rotate != fbi->var.rotate) {\r\nstruct fb_var_screeninfo *new_var = &fbdev->new_var;\r\nmemcpy(new_var, &fbi->var, sizeof(*new_var));\r\nnew_var->rotate = rotate;\r\nif (set_fb_var(fbi, new_var) == 0 &&\r\nmemcmp(new_var, &fbi->var, sizeof(*new_var))) {\r\nmemcpy(&fbi->var, new_var, sizeof(*new_var));\r\nctrl_change_mode(fbi);\r\n}\r\n}\r\nomapfb_rqueue_unlock(fbdev);\r\n}\r\nstatic int omapfb_pan_display(struct fb_var_screeninfo *var,\r\nstruct fb_info *fbi)\r\n{\r\nstruct omapfb_plane_struct *plane = fbi->par;\r\nstruct omapfb_device *fbdev = plane->fbdev;\r\nint r = 0;\r\nomapfb_rqueue_lock(fbdev);\r\nif (var->xoffset != fbi->var.xoffset ||\r\nvar->yoffset != fbi->var.yoffset) {\r\nstruct fb_var_screeninfo *new_var = &fbdev->new_var;\r\nmemcpy(new_var, &fbi->var, sizeof(*new_var));\r\nnew_var->xoffset = var->xoffset;\r\nnew_var->yoffset = var->yoffset;\r\nif (set_fb_var(fbi, new_var))\r\nr = -EINVAL;\r\nelse {\r\nmemcpy(&fbi->var, new_var, sizeof(*new_var));\r\nctrl_change_mode(fbi);\r\n}\r\n}\r\nomapfb_rqueue_unlock(fbdev);\r\nreturn r;\r\n}\r\nstatic int omapfb_mirror(struct fb_info *fbi, int mirror)\r\n{\r\nstruct omapfb_plane_struct *plane = fbi->par;\r\nstruct omapfb_device *fbdev = plane->fbdev;\r\nint r = 0;\r\nomapfb_rqueue_lock(fbdev);\r\nmirror = mirror ? 1 : 0;\r\nif (cpu_is_omap15xx())\r\nr = -EINVAL;\r\nelse if (mirror != plane->info.mirror) {\r\nplane->info.mirror = mirror;\r\nr = ctrl_change_mode(fbi);\r\n}\r\nomapfb_rqueue_unlock(fbdev);\r\nreturn r;\r\n}\r\nstatic int omapfb_check_var(struct fb_var_screeninfo *var, struct fb_info *fbi)\r\n{\r\nstruct omapfb_plane_struct *plane = fbi->par;\r\nstruct omapfb_device *fbdev = plane->fbdev;\r\nint r;\r\nomapfb_rqueue_lock(fbdev);\r\nif (fbdev->ctrl->sync != NULL)\r\nfbdev->ctrl->sync();\r\nr = set_fb_var(fbi, var);\r\nomapfb_rqueue_unlock(fbdev);\r\nreturn r;\r\n}\r\nstatic int omapfb_set_par(struct fb_info *fbi)\r\n{\r\nstruct omapfb_plane_struct *plane = fbi->par;\r\nstruct omapfb_device *fbdev = plane->fbdev;\r\nint r = 0;\r\nomapfb_rqueue_lock(fbdev);\r\nset_fb_fix(fbi, 0);\r\nr = ctrl_change_mode(fbi);\r\nomapfb_rqueue_unlock(fbdev);\r\nreturn r;\r\n}\r\nint omapfb_update_window_async(struct fb_info *fbi,\r\nstruct omapfb_update_window *win,\r\nvoid (*callback)(void *),\r\nvoid *callback_data)\r\n{\r\nint xres, yres;\r\nstruct omapfb_plane_struct *plane = fbi->par;\r\nstruct omapfb_device *fbdev = plane->fbdev;\r\nstruct fb_var_screeninfo *var = &fbi->var;\r\nswitch (var->rotate) {\r\ncase 0:\r\ncase 180:\r\nxres = fbdev->panel->x_res;\r\nyres = fbdev->panel->y_res;\r\nbreak;\r\ncase 90:\r\ncase 270:\r\nxres = fbdev->panel->y_res;\r\nyres = fbdev->panel->x_res;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (win->x >= xres || win->y >= yres ||\r\nwin->out_x > xres || win->out_y > yres)\r\nreturn -EINVAL;\r\nif (!fbdev->ctrl->update_window ||\r\nfbdev->ctrl->get_update_mode() != OMAPFB_MANUAL_UPDATE)\r\nreturn -ENODEV;\r\nif (win->x + win->width > xres)\r\nwin->width = xres - win->x;\r\nif (win->y + win->height > yres)\r\nwin->height = yres - win->y;\r\nif (win->out_x + win->out_width > xres)\r\nwin->out_width = xres - win->out_x;\r\nif (win->out_y + win->out_height > yres)\r\nwin->out_height = yres - win->out_y;\r\nif (!win->width || !win->height || !win->out_width || !win->out_height)\r\nreturn 0;\r\nreturn fbdev->ctrl->update_window(fbi, win, callback, callback_data);\r\n}\r\nstatic int omapfb_update_win(struct fb_info *fbi,\r\nstruct omapfb_update_window *win)\r\n{\r\nstruct omapfb_plane_struct *plane = fbi->par;\r\nint ret;\r\nomapfb_rqueue_lock(plane->fbdev);\r\nret = omapfb_update_window_async(fbi, win, NULL, NULL);\r\nomapfb_rqueue_unlock(plane->fbdev);\r\nreturn ret;\r\n}\r\nstatic int omapfb_update_full_screen(struct fb_info *fbi)\r\n{\r\nstruct omapfb_plane_struct *plane = fbi->par;\r\nstruct omapfb_device *fbdev = plane->fbdev;\r\nstruct omapfb_update_window win;\r\nint r;\r\nif (!fbdev->ctrl->update_window ||\r\nfbdev->ctrl->get_update_mode() != OMAPFB_MANUAL_UPDATE)\r\nreturn -ENODEV;\r\nwin.x = 0;\r\nwin.y = 0;\r\nwin.width = fbi->var.xres;\r\nwin.height = fbi->var.yres;\r\nwin.out_x = 0;\r\nwin.out_y = 0;\r\nwin.out_width = fbi->var.xres;\r\nwin.out_height = fbi->var.yres;\r\nwin.format = 0;\r\nomapfb_rqueue_lock(fbdev);\r\nr = fbdev->ctrl->update_window(fbi, &win, NULL, NULL);\r\nomapfb_rqueue_unlock(fbdev);\r\nreturn r;\r\n}\r\nstatic int omapfb_setup_plane(struct fb_info *fbi, struct omapfb_plane_info *pi)\r\n{\r\nstruct omapfb_plane_struct *plane = fbi->par;\r\nstruct omapfb_device *fbdev = plane->fbdev;\r\nstruct lcd_panel *panel = fbdev->panel;\r\nstruct omapfb_plane_info old_info;\r\nint r = 0;\r\nif (pi->pos_x + pi->out_width > panel->x_res ||\r\npi->pos_y + pi->out_height > panel->y_res)\r\nreturn -EINVAL;\r\nomapfb_rqueue_lock(fbdev);\r\nif (pi->enabled && !fbdev->mem_desc.region[plane->idx].size) {\r\nr = -EINVAL;\r\ngoto out;\r\n}\r\nold_info = plane->info;\r\nplane->info = *pi;\r\nif (pi->enabled) {\r\nr = ctrl_change_mode(fbi);\r\nif (r < 0) {\r\nplane->info = old_info;\r\ngoto out;\r\n}\r\n}\r\nr = fbdev->ctrl->enable_plane(plane->idx, pi->enabled);\r\nif (r < 0) {\r\nplane->info = old_info;\r\ngoto out;\r\n}\r\nout:\r\nomapfb_rqueue_unlock(fbdev);\r\nreturn r;\r\n}\r\nstatic int omapfb_query_plane(struct fb_info *fbi, struct omapfb_plane_info *pi)\r\n{\r\nstruct omapfb_plane_struct *plane = fbi->par;\r\n*pi = plane->info;\r\nreturn 0;\r\n}\r\nstatic int omapfb_setup_mem(struct fb_info *fbi, struct omapfb_mem_info *mi)\r\n{\r\nstruct omapfb_plane_struct *plane = fbi->par;\r\nstruct omapfb_device *fbdev = plane->fbdev;\r\nstruct omapfb_mem_region *rg = &fbdev->mem_desc.region[plane->idx];\r\nsize_t size;\r\nint r = 0;\r\nif (fbdev->ctrl->setup_mem == NULL)\r\nreturn -ENODEV;\r\nif (mi->type != OMAPFB_MEMTYPE_SDRAM)\r\nreturn -EINVAL;\r\nsize = PAGE_ALIGN(mi->size);\r\nomapfb_rqueue_lock(fbdev);\r\nif (plane->info.enabled) {\r\nr = -EBUSY;\r\ngoto out;\r\n}\r\nif (rg->size != size || rg->type != mi->type) {\r\nstruct fb_var_screeninfo *new_var = &fbdev->new_var;\r\nunsigned long old_size = rg->size;\r\nu8 old_type = rg->type;\r\nunsigned long paddr;\r\nrg->size = size;\r\nrg->type = mi->type;\r\nif (old_size != size && size) {\r\nif (size) {\r\nmemcpy(new_var, &fbi->var, sizeof(*new_var));\r\nr = set_fb_var(fbi, new_var);\r\nif (r < 0)\r\ngoto out;\r\n}\r\n}\r\nif (fbdev->ctrl->sync)\r\nfbdev->ctrl->sync();\r\nr = fbdev->ctrl->setup_mem(plane->idx, size, mi->type, &paddr);\r\nif (r < 0) {\r\nrg->size = old_size;\r\nrg->type = old_type;\r\ngoto out;\r\n}\r\nrg->paddr = paddr;\r\nif (old_size != size) {\r\nif (size) {\r\nmemcpy(&fbi->var, new_var, sizeof(fbi->var));\r\nset_fb_fix(fbi, 0);\r\n} else {\r\nmutex_lock(&fbi->mm_lock);\r\nfbi->fix.smem_start = 0;\r\nfbi->fix.smem_len = 0;\r\nmutex_unlock(&fbi->mm_lock);\r\n}\r\n}\r\n}\r\nout:\r\nomapfb_rqueue_unlock(fbdev);\r\nreturn r;\r\n}\r\nstatic int omapfb_query_mem(struct fb_info *fbi, struct omapfb_mem_info *mi)\r\n{\r\nstruct omapfb_plane_struct *plane = fbi->par;\r\nstruct omapfb_device *fbdev = plane->fbdev;\r\nstruct omapfb_mem_region *rg;\r\nrg = &fbdev->mem_desc.region[plane->idx];\r\nmemset(mi, 0, sizeof(*mi));\r\nmi->size = rg->size;\r\nmi->type = rg->type;\r\nreturn 0;\r\n}\r\nstatic int omapfb_set_color_key(struct omapfb_device *fbdev,\r\nstruct omapfb_color_key *ck)\r\n{\r\nint r;\r\nif (!fbdev->ctrl->set_color_key)\r\nreturn -ENODEV;\r\nomapfb_rqueue_lock(fbdev);\r\nr = fbdev->ctrl->set_color_key(ck);\r\nomapfb_rqueue_unlock(fbdev);\r\nreturn r;\r\n}\r\nstatic int omapfb_get_color_key(struct omapfb_device *fbdev,\r\nstruct omapfb_color_key *ck)\r\n{\r\nint r;\r\nif (!fbdev->ctrl->get_color_key)\r\nreturn -ENODEV;\r\nomapfb_rqueue_lock(fbdev);\r\nr = fbdev->ctrl->get_color_key(ck);\r\nomapfb_rqueue_unlock(fbdev);\r\nreturn r;\r\n}\r\nstatic void omapfb_init_notifier(void)\r\n{\r\nint i;\r\nfor (i = 0; i < OMAPFB_PLANE_NUM; i++)\r\nBLOCKING_INIT_NOTIFIER_HEAD(&omapfb_client_list[i]);\r\n}\r\nint omapfb_register_client(struct omapfb_notifier_block *omapfb_nb,\r\nomapfb_notifier_callback_t callback,\r\nvoid *callback_data)\r\n{\r\nint r;\r\nif ((unsigned)omapfb_nb->plane_idx > OMAPFB_PLANE_NUM)\r\nreturn -EINVAL;\r\nif (!notifier_inited) {\r\nomapfb_init_notifier();\r\nnotifier_inited = 1;\r\n}\r\nomapfb_nb->nb.notifier_call = (int (*)(struct notifier_block *,\r\nunsigned long, void *))callback;\r\nomapfb_nb->data = callback_data;\r\nr = blocking_notifier_chain_register(\r\n&omapfb_client_list[omapfb_nb->plane_idx],\r\n&omapfb_nb->nb);\r\nif (r)\r\nreturn r;\r\nif (omapfb_dev != NULL &&\r\nomapfb_dev->ctrl && omapfb_dev->ctrl->bind_client) {\r\nomapfb_dev->ctrl->bind_client(omapfb_nb);\r\n}\r\nreturn 0;\r\n}\r\nint omapfb_unregister_client(struct omapfb_notifier_block *omapfb_nb)\r\n{\r\nreturn blocking_notifier_chain_unregister(\r\n&omapfb_client_list[omapfb_nb->plane_idx], &omapfb_nb->nb);\r\n}\r\nvoid omapfb_notify_clients(struct omapfb_device *fbdev, unsigned long event)\r\n{\r\nint i;\r\nif (!notifier_inited)\r\nreturn;\r\nfor (i = 0; i < OMAPFB_PLANE_NUM; i++)\r\nblocking_notifier_call_chain(&omapfb_client_list[i], event,\r\nfbdev->fb_info[i]);\r\n}\r\nstatic int omapfb_set_update_mode(struct omapfb_device *fbdev,\r\nenum omapfb_update_mode mode)\r\n{\r\nint r;\r\nomapfb_rqueue_lock(fbdev);\r\nr = fbdev->ctrl->set_update_mode(mode);\r\nomapfb_rqueue_unlock(fbdev);\r\nreturn r;\r\n}\r\nstatic enum omapfb_update_mode omapfb_get_update_mode(struct omapfb_device *fbdev)\r\n{\r\nint r;\r\nomapfb_rqueue_lock(fbdev);\r\nr = fbdev->ctrl->get_update_mode();\r\nomapfb_rqueue_unlock(fbdev);\r\nreturn r;\r\n}\r\nstatic void omapfb_get_caps(struct omapfb_device *fbdev, int plane,\r\nstruct omapfb_caps *caps)\r\n{\r\nmemset(caps, 0, sizeof(*caps));\r\nfbdev->ctrl->get_caps(plane, caps);\r\ncaps->ctrl |= fbdev->panel->get_caps(fbdev->panel);\r\n}\r\nvoid omapfb_write_first_pixel(struct omapfb_device *fbdev, u16 pixval)\r\n{\r\nomapfb_rqueue_lock(fbdev);\r\n*(u16 *)fbdev->mem_desc.region[0].vaddr = pixval;\r\nif (fbdev->ctrl->get_update_mode() == OMAPFB_MANUAL_UPDATE) {\r\nstruct omapfb_update_window win;\r\nmemset(&win, 0, sizeof(win));\r\nwin.width = 2;\r\nwin.height = 2;\r\nwin.out_width = 2;\r\nwin.out_height = 2;\r\nfbdev->ctrl->update_window(fbdev->fb_info[0], &win, NULL, NULL);\r\n}\r\nomapfb_rqueue_unlock(fbdev);\r\n}\r\nstatic int omapfb_ioctl(struct fb_info *fbi, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\nstruct omapfb_plane_struct *plane = fbi->par;\r\nstruct omapfb_device *fbdev = plane->fbdev;\r\nstruct fb_ops *ops = fbi->fbops;\r\nunion {\r\nstruct omapfb_update_window update_window;\r\nstruct omapfb_plane_info plane_info;\r\nstruct omapfb_mem_info mem_info;\r\nstruct omapfb_color_key color_key;\r\nenum omapfb_update_mode update_mode;\r\nstruct omapfb_caps caps;\r\nunsigned int mirror;\r\nint plane_out;\r\nint enable_plane;\r\n} p;\r\nint r = 0;\r\nBUG_ON(!ops);\r\nswitch (cmd) {\r\ncase OMAPFB_MIRROR:\r\nif (get_user(p.mirror, (int __user *)arg))\r\nr = -EFAULT;\r\nelse\r\nomapfb_mirror(fbi, p.mirror);\r\nbreak;\r\ncase OMAPFB_SYNC_GFX:\r\nomapfb_sync(fbi);\r\nbreak;\r\ncase OMAPFB_VSYNC:\r\nbreak;\r\ncase OMAPFB_SET_UPDATE_MODE:\r\nif (get_user(p.update_mode, (int __user *)arg))\r\nr = -EFAULT;\r\nelse\r\nr = omapfb_set_update_mode(fbdev, p.update_mode);\r\nbreak;\r\ncase OMAPFB_GET_UPDATE_MODE:\r\np.update_mode = omapfb_get_update_mode(fbdev);\r\nif (put_user(p.update_mode,\r\n(enum omapfb_update_mode __user *)arg))\r\nr = -EFAULT;\r\nbreak;\r\ncase OMAPFB_UPDATE_WINDOW_OLD:\r\nif (copy_from_user(&p.update_window, (void __user *)arg,\r\nsizeof(struct omapfb_update_window_old)))\r\nr = -EFAULT;\r\nelse {\r\nstruct omapfb_update_window *u = &p.update_window;\r\nu->out_x = u->x;\r\nu->out_y = u->y;\r\nu->out_width = u->width;\r\nu->out_height = u->height;\r\nmemset(u->reserved, 0, sizeof(u->reserved));\r\nr = omapfb_update_win(fbi, u);\r\n}\r\nbreak;\r\ncase OMAPFB_UPDATE_WINDOW:\r\nif (copy_from_user(&p.update_window, (void __user *)arg,\r\nsizeof(p.update_window)))\r\nr = -EFAULT;\r\nelse\r\nr = omapfb_update_win(fbi, &p.update_window);\r\nbreak;\r\ncase OMAPFB_SETUP_PLANE:\r\nif (copy_from_user(&p.plane_info, (void __user *)arg,\r\nsizeof(p.plane_info)))\r\nr = -EFAULT;\r\nelse\r\nr = omapfb_setup_plane(fbi, &p.plane_info);\r\nbreak;\r\ncase OMAPFB_QUERY_PLANE:\r\nif ((r = omapfb_query_plane(fbi, &p.plane_info)) < 0)\r\nbreak;\r\nif (copy_to_user((void __user *)arg, &p.plane_info,\r\nsizeof(p.plane_info)))\r\nr = -EFAULT;\r\nbreak;\r\ncase OMAPFB_SETUP_MEM:\r\nif (copy_from_user(&p.mem_info, (void __user *)arg,\r\nsizeof(p.mem_info)))\r\nr = -EFAULT;\r\nelse\r\nr = omapfb_setup_mem(fbi, &p.mem_info);\r\nbreak;\r\ncase OMAPFB_QUERY_MEM:\r\nif ((r = omapfb_query_mem(fbi, &p.mem_info)) < 0)\r\nbreak;\r\nif (copy_to_user((void __user *)arg, &p.mem_info,\r\nsizeof(p.mem_info)))\r\nr = -EFAULT;\r\nbreak;\r\ncase OMAPFB_SET_COLOR_KEY:\r\nif (copy_from_user(&p.color_key, (void __user *)arg,\r\nsizeof(p.color_key)))\r\nr = -EFAULT;\r\nelse\r\nr = omapfb_set_color_key(fbdev, &p.color_key);\r\nbreak;\r\ncase OMAPFB_GET_COLOR_KEY:\r\nif ((r = omapfb_get_color_key(fbdev, &p.color_key)) < 0)\r\nbreak;\r\nif (copy_to_user((void __user *)arg, &p.color_key,\r\nsizeof(p.color_key)))\r\nr = -EFAULT;\r\nbreak;\r\ncase OMAPFB_GET_CAPS:\r\nomapfb_get_caps(fbdev, plane->idx, &p.caps);\r\nif (copy_to_user((void __user *)arg, &p.caps, sizeof(p.caps)))\r\nr = -EFAULT;\r\nbreak;\r\ncase OMAPFB_LCD_TEST:\r\n{\r\nint test_num;\r\nif (get_user(test_num, (int __user *)arg)) {\r\nr = -EFAULT;\r\nbreak;\r\n}\r\nif (!fbdev->panel->run_test) {\r\nr = -EINVAL;\r\nbreak;\r\n}\r\nr = fbdev->panel->run_test(fbdev->panel, test_num);\r\nbreak;\r\n}\r\ncase OMAPFB_CTRL_TEST:\r\n{\r\nint test_num;\r\nif (get_user(test_num, (int __user *)arg)) {\r\nr = -EFAULT;\r\nbreak;\r\n}\r\nif (!fbdev->ctrl->run_test) {\r\nr = -EINVAL;\r\nbreak;\r\n}\r\nr = fbdev->ctrl->run_test(test_num);\r\nbreak;\r\n}\r\ndefault:\r\nr = -EINVAL;\r\n}\r\nreturn r;\r\n}\r\nstatic int omapfb_mmap(struct fb_info *info, struct vm_area_struct *vma)\r\n{\r\nstruct omapfb_plane_struct *plane = info->par;\r\nstruct omapfb_device *fbdev = plane->fbdev;\r\nint r;\r\nomapfb_rqueue_lock(fbdev);\r\nr = fbdev->ctrl->mmap(info, vma);\r\nomapfb_rqueue_unlock(fbdev);\r\nreturn r;\r\n}\r\nstatic ssize_t omapfb_show_caps_num(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct omapfb_device *fbdev = dev_get_drvdata(dev);\r\nint plane;\r\nsize_t size;\r\nstruct omapfb_caps caps;\r\nplane = 0;\r\nsize = 0;\r\nwhile (size < PAGE_SIZE && plane < OMAPFB_PLANE_NUM) {\r\nomapfb_get_caps(fbdev, plane, &caps);\r\nsize += snprintf(&buf[size], PAGE_SIZE - size,\r\n"plane#%d %#010x %#010x %#010x\n",\r\nplane, caps.ctrl, caps.plane_color, caps.wnd_color);\r\nplane++;\r\n}\r\nreturn size;\r\n}\r\nstatic ssize_t omapfb_show_caps_text(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct omapfb_device *fbdev = dev_get_drvdata(dev);\r\nint i;\r\nstruct omapfb_caps caps;\r\nint plane;\r\nsize_t size;\r\nplane = 0;\r\nsize = 0;\r\nwhile (size < PAGE_SIZE && plane < OMAPFB_PLANE_NUM) {\r\nomapfb_get_caps(fbdev, plane, &caps);\r\nsize += snprintf(&buf[size], PAGE_SIZE - size,\r\n"plane#%d:\n", plane);\r\nfor (i = 0; i < ARRAY_SIZE(ctrl_caps) &&\r\nsize < PAGE_SIZE; i++) {\r\nif (ctrl_caps[i].flag & caps.ctrl)\r\nsize += snprintf(&buf[size], PAGE_SIZE - size,\r\n" %s\n", ctrl_caps[i].name);\r\n}\r\nsize += snprintf(&buf[size], PAGE_SIZE - size,\r\n" plane colors:\n");\r\nfor (i = 0; i < ARRAY_SIZE(color_caps) &&\r\nsize < PAGE_SIZE; i++) {\r\nif (color_caps[i].flag & caps.plane_color)\r\nsize += snprintf(&buf[size], PAGE_SIZE - size,\r\n" %s\n", color_caps[i].name);\r\n}\r\nsize += snprintf(&buf[size], PAGE_SIZE - size,\r\n" window colors:\n");\r\nfor (i = 0; i < ARRAY_SIZE(color_caps) &&\r\nsize < PAGE_SIZE; i++) {\r\nif (color_caps[i].flag & caps.wnd_color)\r\nsize += snprintf(&buf[size], PAGE_SIZE - size,\r\n" %s\n", color_caps[i].name);\r\n}\r\nplane++;\r\n}\r\nreturn size;\r\n}\r\nstatic ssize_t omapfb_show_panel_name(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct omapfb_device *fbdev = dev_get_drvdata(dev);\r\nreturn snprintf(buf, PAGE_SIZE, "%s\n", fbdev->panel->name);\r\n}\r\nstatic ssize_t omapfb_show_bklight_level(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct omapfb_device *fbdev = dev_get_drvdata(dev);\r\nint r;\r\nif (fbdev->panel->get_bklight_level) {\r\nr = snprintf(buf, PAGE_SIZE, "%d\n",\r\nfbdev->panel->get_bklight_level(fbdev->panel));\r\n} else\r\nr = -ENODEV;\r\nreturn r;\r\n}\r\nstatic ssize_t omapfb_store_bklight_level(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t size)\r\n{\r\nstruct omapfb_device *fbdev = dev_get_drvdata(dev);\r\nint r;\r\nif (fbdev->panel->set_bklight_level) {\r\nunsigned int level;\r\nif (sscanf(buf, "%10d", &level) == 1) {\r\nr = fbdev->panel->set_bklight_level(fbdev->panel,\r\nlevel);\r\n} else\r\nr = -EINVAL;\r\n} else\r\nr = -ENODEV;\r\nreturn r ? r : size;\r\n}\r\nstatic ssize_t omapfb_show_bklight_max(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct omapfb_device *fbdev = dev_get_drvdata(dev);\r\nint r;\r\nif (fbdev->panel->get_bklight_level) {\r\nr = snprintf(buf, PAGE_SIZE, "%d\n",\r\nfbdev->panel->get_bklight_max(fbdev->panel));\r\n} else\r\nr = -ENODEV;\r\nreturn r;\r\n}\r\nstatic ssize_t omapfb_show_ctrl_name(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct omapfb_device *fbdev = dev_get_drvdata(dev);\r\nreturn snprintf(buf, PAGE_SIZE, "%s\n", fbdev->ctrl->name);\r\n}\r\nstatic int omapfb_register_sysfs(struct omapfb_device *fbdev)\r\n{\r\nint r;\r\nif ((r = device_create_file(fbdev->dev, &dev_attr_caps_num)))\r\ngoto fail0;\r\nif ((r = device_create_file(fbdev->dev, &dev_attr_caps_text)))\r\ngoto fail1;\r\nif ((r = sysfs_create_group(&fbdev->dev->kobj, &panel_attr_grp)))\r\ngoto fail2;\r\nif ((r = sysfs_create_group(&fbdev->dev->kobj, &ctrl_attr_grp)))\r\ngoto fail3;\r\nreturn 0;\r\nfail3:\r\nsysfs_remove_group(&fbdev->dev->kobj, &panel_attr_grp);\r\nfail2:\r\ndevice_remove_file(fbdev->dev, &dev_attr_caps_text);\r\nfail1:\r\ndevice_remove_file(fbdev->dev, &dev_attr_caps_num);\r\nfail0:\r\ndev_err(fbdev->dev, "unable to register sysfs interface\n");\r\nreturn r;\r\n}\r\nstatic void omapfb_unregister_sysfs(struct omapfb_device *fbdev)\r\n{\r\nsysfs_remove_group(&fbdev->dev->kobj, &ctrl_attr_grp);\r\nsysfs_remove_group(&fbdev->dev->kobj, &panel_attr_grp);\r\ndevice_remove_file(fbdev->dev, &dev_attr_caps_num);\r\ndevice_remove_file(fbdev->dev, &dev_attr_caps_text);\r\n}\r\nstatic int fbinfo_init(struct omapfb_device *fbdev, struct fb_info *info)\r\n{\r\nstruct fb_var_screeninfo *var = &info->var;\r\nstruct fb_fix_screeninfo *fix = &info->fix;\r\nint r = 0;\r\ninfo->fbops = &omapfb_ops;\r\ninfo->flags = FBINFO_FLAG_DEFAULT;\r\nstrncpy(fix->id, MODULE_NAME, sizeof(fix->id));\r\ninfo->pseudo_palette = fbdev->pseudo_palette;\r\nvar->accel_flags = def_accel ? FB_ACCELF_TEXT : 0;\r\nvar->xres = def_vxres;\r\nvar->yres = def_vyres;\r\nvar->xres_virtual = def_vxres;\r\nvar->yres_virtual = def_vyres;\r\nvar->rotate = def_rotate;\r\nvar->bits_per_pixel = fbdev->panel->bpp;\r\nset_fb_var(info, var);\r\nset_fb_fix(info, 1);\r\nr = fb_alloc_cmap(&info->cmap, 16, 0);\r\nif (r != 0)\r\ndev_err(fbdev->dev, "unable to allocate color map memory\n");\r\nreturn r;\r\n}\r\nstatic void fbinfo_cleanup(struct omapfb_device *fbdev, struct fb_info *fbi)\r\n{\r\nfb_dealloc_cmap(&fbi->cmap);\r\n}\r\nstatic void planes_cleanup(struct omapfb_device *fbdev)\r\n{\r\nint i;\r\nfor (i = 0; i < fbdev->mem_desc.region_cnt; i++) {\r\nif (fbdev->fb_info[i] == NULL)\r\nbreak;\r\nfbinfo_cleanup(fbdev, fbdev->fb_info[i]);\r\nframebuffer_release(fbdev->fb_info[i]);\r\n}\r\n}\r\nstatic int planes_init(struct omapfb_device *fbdev)\r\n{\r\nstruct fb_info *fbi;\r\nint i;\r\nint r;\r\nfor (i = 0; i < fbdev->mem_desc.region_cnt; i++) {\r\nstruct omapfb_plane_struct *plane;\r\nfbi = framebuffer_alloc(sizeof(struct omapfb_plane_struct),\r\nfbdev->dev);\r\nif (fbi == NULL) {\r\ndev_err(fbdev->dev,\r\n"unable to allocate memory for plane info\n");\r\nplanes_cleanup(fbdev);\r\nreturn -ENOMEM;\r\n}\r\nplane = fbi->par;\r\nplane->idx = i;\r\nplane->fbdev = fbdev;\r\nplane->info.mirror = def_mirror;\r\nfbdev->fb_info[i] = fbi;\r\nif ((r = fbinfo_init(fbdev, fbi)) < 0) {\r\nframebuffer_release(fbi);\r\nplanes_cleanup(fbdev);\r\nreturn r;\r\n}\r\nplane->info.out_width = fbi->var.xres;\r\nplane->info.out_height = fbi->var.yres;\r\n}\r\nreturn 0;\r\n}\r\nstatic void omapfb_free_resources(struct omapfb_device *fbdev, int state)\r\n{\r\nint i;\r\nswitch (state) {\r\ncase OMAPFB_ACTIVE:\r\nfor (i = 0; i < fbdev->mem_desc.region_cnt; i++)\r\nunregister_framebuffer(fbdev->fb_info[i]);\r\ncase 7:\r\nomapfb_unregister_sysfs(fbdev);\r\ncase 6:\r\nfbdev->panel->disable(fbdev->panel);\r\ncase 5:\r\nomapfb_set_update_mode(fbdev, OMAPFB_UPDATE_DISABLED);\r\ncase 4:\r\nplanes_cleanup(fbdev);\r\ncase 3:\r\nctrl_cleanup(fbdev);\r\ncase 2:\r\nfbdev->panel->cleanup(fbdev->panel);\r\ncase 1:\r\ndev_set_drvdata(fbdev->dev, NULL);\r\nkfree(fbdev);\r\ncase 0:\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\n}\r\nstatic int omapfb_find_ctrl(struct omapfb_device *fbdev)\r\n{\r\nstruct omapfb_platform_data *conf;\r\nchar name[17];\r\nint i;\r\nconf = dev_get_platdata(fbdev->dev);\r\nfbdev->ctrl = NULL;\r\nstrncpy(name, conf->lcd.ctrl_name, sizeof(name) - 1);\r\nname[sizeof(name) - 1] = '\0';\r\nif (strcmp(name, "internal") == 0) {\r\nfbdev->ctrl = fbdev->int_ctrl;\r\nreturn 0;\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(ctrls); i++) {\r\ndev_dbg(fbdev->dev, "ctrl %s\n", ctrls[i]->name);\r\nif (strcmp(ctrls[i]->name, name) == 0) {\r\nfbdev->ctrl = ctrls[i];\r\nbreak;\r\n}\r\n}\r\nif (fbdev->ctrl == NULL) {\r\ndev_dbg(fbdev->dev, "ctrl %s not supported\n", name);\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic void check_required_callbacks(struct omapfb_device *fbdev)\r\n{\r\n#define _C(x) (fbdev->ctrl->x != NULL)\r\n#define _P(x) (fbdev->panel->x != NULL)\r\nBUG_ON(fbdev->ctrl == NULL || fbdev->panel == NULL);\r\nBUG_ON(!(_C(init) && _C(cleanup) && _C(get_caps) &&\r\n_C(set_update_mode) && _C(setup_plane) && _C(enable_plane) &&\r\n_P(init) && _P(cleanup) && _P(enable) && _P(disable) &&\r\n_P(get_caps)));\r\n#undef _P\r\n#undef _C\r\n}\r\nstatic int omapfb_do_probe(struct platform_device *pdev,\r\nstruct lcd_panel *panel)\r\n{\r\nstruct omapfb_device *fbdev = NULL;\r\nint init_state;\r\nunsigned long phz, hhz, vhz;\r\nunsigned long vram;\r\nint i;\r\nint r = 0;\r\ninit_state = 0;\r\nif (pdev->num_resources != 0) {\r\ndev_err(&pdev->dev, "probed for an unknown device\n");\r\nr = -ENODEV;\r\ngoto cleanup;\r\n}\r\nif (dev_get_platdata(&pdev->dev) == NULL) {\r\ndev_err(&pdev->dev, "missing platform data\n");\r\nr = -ENOENT;\r\ngoto cleanup;\r\n}\r\nfbdev = kzalloc(sizeof(struct omapfb_device), GFP_KERNEL);\r\nif (fbdev == NULL) {\r\ndev_err(&pdev->dev,\r\n"unable to allocate memory for device info\n");\r\nr = -ENOMEM;\r\ngoto cleanup;\r\n}\r\ninit_state++;\r\nfbdev->dev = &pdev->dev;\r\nfbdev->panel = panel;\r\nfbdev->dssdev = &omapdss_device;\r\nplatform_set_drvdata(pdev, fbdev);\r\nmutex_init(&fbdev->rqueue_mutex);\r\nfbdev->int_ctrl = &omap1_int_ctrl;\r\n#ifdef CONFIG_FB_OMAP_LCDC_EXTERNAL\r\nfbdev->ext_if = &omap1_ext_if;\r\n#endif\r\nif (omapfb_find_ctrl(fbdev) < 0) {\r\ndev_err(fbdev->dev,\r\n"LCD controller not found, board not supported\n");\r\nr = -ENODEV;\r\ngoto cleanup;\r\n}\r\nr = fbdev->panel->init(fbdev->panel, fbdev);\r\nif (r)\r\ngoto cleanup;\r\npr_info("omapfb: configured for panel %s\n", fbdev->panel->name);\r\ndef_vxres = def_vxres ? def_vxres : fbdev->panel->x_res;\r\ndef_vyres = def_vyres ? def_vyres : fbdev->panel->y_res;\r\ninit_state++;\r\nr = ctrl_init(fbdev);\r\nif (r)\r\ngoto cleanup;\r\nif (fbdev->ctrl->mmap != NULL)\r\nomapfb_ops.fb_mmap = omapfb_mmap;\r\ninit_state++;\r\ncheck_required_callbacks(fbdev);\r\nr = planes_init(fbdev);\r\nif (r)\r\ngoto cleanup;\r\ninit_state++;\r\n#ifdef CONFIG_FB_OMAP_DMA_TUNE\r\nomap_set_dma_priority(0, OMAP_DMA_PORT_EMIFF, 15);\r\n#endif\r\nr = ctrl_change_mode(fbdev->fb_info[0]);\r\nif (r) {\r\ndev_err(fbdev->dev, "mode setting failed\n");\r\ngoto cleanup;\r\n}\r\nr = fbdev->ctrl->enable_plane(OMAPFB_PLANE_GFX, 1);\r\nif (r)\r\ngoto cleanup;\r\nomapfb_set_update_mode(fbdev, manual_update ?\r\nOMAPFB_MANUAL_UPDATE : OMAPFB_AUTO_UPDATE);\r\ninit_state++;\r\nr = fbdev->panel->enable(fbdev->panel);\r\nif (r)\r\ngoto cleanup;\r\ninit_state++;\r\nr = omapfb_register_sysfs(fbdev);\r\nif (r)\r\ngoto cleanup;\r\ninit_state++;\r\nvram = 0;\r\nfor (i = 0; i < fbdev->mem_desc.region_cnt; i++) {\r\nr = register_framebuffer(fbdev->fb_info[i]);\r\nif (r != 0) {\r\ndev_err(fbdev->dev,\r\n"registering framebuffer %d failed\n", i);\r\ngoto cleanup;\r\n}\r\nvram += fbdev->mem_desc.region[i].size;\r\n}\r\nfbdev->state = OMAPFB_ACTIVE;\r\npanel = fbdev->panel;\r\nphz = panel->pixel_clock * 1000;\r\nhhz = phz * 10 / (panel->hfp + panel->x_res + panel->hbp + panel->hsw);\r\nvhz = hhz / (panel->vfp + panel->y_res + panel->vbp + panel->vsw);\r\nomapfb_dev = fbdev;\r\npr_info("omapfb: Framebuffer initialized. Total vram %lu planes %d\n",\r\nvram, fbdev->mem_desc.region_cnt);\r\npr_info("omapfb: Pixclock %lu kHz hfreq %lu.%lu kHz "\r\n"vfreq %lu.%lu Hz\n",\r\nphz / 1000, hhz / 10000, hhz % 10, vhz / 10, vhz % 10);\r\nreturn 0;\r\ncleanup:\r\nomapfb_free_resources(fbdev, init_state);\r\nreturn r;\r\n}\r\nstatic int omapfb_probe(struct platform_device *pdev)\r\n{\r\nint r;\r\nBUG_ON(fbdev_pdev != NULL);\r\nr = platform_device_register(&omapdss_device);\r\nif (r) {\r\ndev_err(&pdev->dev, "can't register omapdss device\n");\r\nreturn r;\r\n}\r\nfbdev_pdev = pdev;\r\nif (fbdev_panel != NULL)\r\nomapfb_do_probe(fbdev_pdev, fbdev_panel);\r\nreturn 0;\r\n}\r\nvoid omapfb_register_panel(struct lcd_panel *panel)\r\n{\r\nBUG_ON(fbdev_panel != NULL);\r\nfbdev_panel = panel;\r\nif (fbdev_pdev != NULL)\r\nomapfb_do_probe(fbdev_pdev, fbdev_panel);\r\n}\r\nstatic int omapfb_remove(struct platform_device *pdev)\r\n{\r\nstruct omapfb_device *fbdev = platform_get_drvdata(pdev);\r\nenum omapfb_state saved_state = fbdev->state;\r\nfbdev->state = OMAPFB_DISABLED;\r\nomapfb_free_resources(fbdev, saved_state);\r\nplatform_device_unregister(&omapdss_device);\r\nfbdev->dssdev = NULL;\r\nreturn 0;\r\n}\r\nstatic int omapfb_suspend(struct platform_device *pdev, pm_message_t mesg)\r\n{\r\nstruct omapfb_device *fbdev = platform_get_drvdata(pdev);\r\nif (fbdev != NULL)\r\nomapfb_blank(FB_BLANK_POWERDOWN, fbdev->fb_info[0]);\r\nreturn 0;\r\n}\r\nstatic int omapfb_resume(struct platform_device *pdev)\r\n{\r\nstruct omapfb_device *fbdev = platform_get_drvdata(pdev);\r\nif (fbdev != NULL)\r\nomapfb_blank(FB_BLANK_UNBLANK, fbdev->fb_info[0]);\r\nreturn 0;\r\n}\r\nstatic int __init omapfb_setup(char *options)\r\n{\r\nchar *this_opt = NULL;\r\nint r = 0;\r\npr_debug("omapfb: options %s\n", options);\r\nif (!options || !*options)\r\nreturn 0;\r\nwhile (!r && (this_opt = strsep(&options, ",")) != NULL) {\r\nif (!strncmp(this_opt, "accel", 5))\r\ndef_accel = 1;\r\nelse if (!strncmp(this_opt, "vram:", 5)) {\r\nchar *suffix;\r\nunsigned long vram;\r\nvram = (simple_strtoul(this_opt + 5, &suffix, 0));\r\nswitch (suffix[0]) {\r\ncase '\0':\r\nbreak;\r\ncase 'm':\r\ncase 'M':\r\nvram *= 1024;\r\ncase 'k':\r\ncase 'K':\r\nvram *= 1024;\r\nbreak;\r\ndefault:\r\npr_debug("omapfb: invalid vram suffix %c\n",\r\nsuffix[0]);\r\nr = -1;\r\n}\r\ndef_vram[def_vram_cnt++] = vram;\r\n}\r\nelse if (!strncmp(this_opt, "vxres:", 6))\r\ndef_vxres = simple_strtoul(this_opt + 6, NULL, 0);\r\nelse if (!strncmp(this_opt, "vyres:", 6))\r\ndef_vyres = simple_strtoul(this_opt + 6, NULL, 0);\r\nelse if (!strncmp(this_opt, "rotate:", 7))\r\ndef_rotate = (simple_strtoul(this_opt + 7, NULL, 0));\r\nelse if (!strncmp(this_opt, "mirror:", 7))\r\ndef_mirror = (simple_strtoul(this_opt + 7, NULL, 0));\r\nelse if (!strncmp(this_opt, "manual_update", 13))\r\nmanual_update = 1;\r\nelse {\r\npr_debug("omapfb: invalid option\n");\r\nr = -1;\r\n}\r\n}\r\nreturn r;\r\n}\r\nstatic int __init omapfb_init(void)\r\n{\r\n#ifndef MODULE\r\nchar *option;\r\nif (fb_get_options("omapfb", &option))\r\nreturn -ENODEV;\r\nomapfb_setup(option);\r\n#endif\r\nif (platform_driver_register(&omapfb_driver)) {\r\npr_debug("failed to register omapfb driver\n");\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\n}\r\nstatic void __exit omapfb_cleanup(void)\r\n{\r\nplatform_driver_unregister(&omapfb_driver);\r\n}
