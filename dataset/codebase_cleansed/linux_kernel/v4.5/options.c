u64 dccp_decode_value_var(const u8 *bf, const u8 len)\r\n{\r\nu64 value = 0;\r\nif (len >= DCCP_OPTVAL_MAXLEN)\r\nvalue += ((u64)*bf++) << 40;\r\nif (len > 4)\r\nvalue += ((u64)*bf++) << 32;\r\nif (len > 3)\r\nvalue += ((u64)*bf++) << 24;\r\nif (len > 2)\r\nvalue += ((u64)*bf++) << 16;\r\nif (len > 1)\r\nvalue += ((u64)*bf++) << 8;\r\nif (len > 0)\r\nvalue += *bf;\r\nreturn value;\r\n}\r\nint dccp_parse_options(struct sock *sk, struct dccp_request_sock *dreq,\r\nstruct sk_buff *skb)\r\n{\r\nstruct dccp_sock *dp = dccp_sk(sk);\r\nconst struct dccp_hdr *dh = dccp_hdr(skb);\r\nconst u8 pkt_type = DCCP_SKB_CB(skb)->dccpd_type;\r\nunsigned char *options = (unsigned char *)dh + dccp_hdr_len(skb);\r\nunsigned char *opt_ptr = options;\r\nconst unsigned char *opt_end = (unsigned char *)dh +\r\n(dh->dccph_doff * 4);\r\nstruct dccp_options_received *opt_recv = &dp->dccps_options_received;\r\nunsigned char opt, len;\r\nunsigned char *uninitialized_var(value);\r\nu32 elapsed_time;\r\n__be32 opt_val;\r\nint rc;\r\nint mandatory = 0;\r\nmemset(opt_recv, 0, sizeof(*opt_recv));\r\nopt = len = 0;\r\nwhile (opt_ptr != opt_end) {\r\nopt = *opt_ptr++;\r\nlen = 0;\r\nvalue = NULL;\r\nif (opt > DCCPO_MAX_RESERVED) {\r\nif (opt_ptr == opt_end)\r\ngoto out_nonsensical_length;\r\nlen = *opt_ptr++;\r\nif (len < 2)\r\ngoto out_nonsensical_length;\r\nlen -= 2;\r\nvalue = opt_ptr;\r\nopt_ptr += len;\r\nif (opt_ptr > opt_end)\r\ngoto out_nonsensical_length;\r\n}\r\nif (dreq != NULL && (opt >= DCCPO_MIN_RX_CCID_SPECIFIC ||\r\nopt == DCCPO_ACK_VECTOR_0 || opt == DCCPO_ACK_VECTOR_1))\r\ngoto ignore_option;\r\nswitch (opt) {\r\ncase DCCPO_PADDING:\r\nbreak;\r\ncase DCCPO_MANDATORY:\r\nif (mandatory)\r\ngoto out_invalid_option;\r\nif (pkt_type != DCCP_PKT_DATA)\r\nmandatory = 1;\r\nbreak;\r\ncase DCCPO_NDP_COUNT:\r\nif (len > 6)\r\ngoto out_invalid_option;\r\nopt_recv->dccpor_ndp = dccp_decode_value_var(value, len);\r\ndccp_pr_debug("%s opt: NDP count=%llu\n", dccp_role(sk),\r\n(unsigned long long)opt_recv->dccpor_ndp);\r\nbreak;\r\ncase DCCPO_CHANGE_L ... DCCPO_CONFIRM_R:\r\nif (pkt_type == DCCP_PKT_DATA)\r\nbreak;\r\nif (len == 0)\r\ngoto out_invalid_option;\r\nrc = dccp_feat_parse_options(sk, dreq, mandatory, opt,\r\n*value, value + 1, len - 1);\r\nif (rc)\r\ngoto out_featneg_failed;\r\nbreak;\r\ncase DCCPO_TIMESTAMP:\r\nif (len != 4)\r\ngoto out_invalid_option;\r\nopt_val = get_unaligned((__be32 *)value);\r\nif (unlikely(opt_val == 0)) {\r\nDCCP_WARN("Timestamp with zero value\n");\r\nbreak;\r\n}\r\nif (dreq != NULL) {\r\ndreq->dreq_timestamp_echo = ntohl(opt_val);\r\ndreq->dreq_timestamp_time = dccp_timestamp();\r\n} else {\r\nopt_recv->dccpor_timestamp =\r\ndp->dccps_timestamp_echo = ntohl(opt_val);\r\ndp->dccps_timestamp_time = dccp_timestamp();\r\n}\r\ndccp_pr_debug("%s rx opt: TIMESTAMP=%u, ackno=%llu\n",\r\ndccp_role(sk), ntohl(opt_val),\r\n(unsigned long long)\r\nDCCP_SKB_CB(skb)->dccpd_ack_seq);\r\ninet_csk_schedule_ack(sk);\r\nbreak;\r\ncase DCCPO_TIMESTAMP_ECHO:\r\nif (len != 4 && len != 6 && len != 8)\r\ngoto out_invalid_option;\r\nopt_val = get_unaligned((__be32 *)value);\r\nopt_recv->dccpor_timestamp_echo = ntohl(opt_val);\r\ndccp_pr_debug("%s rx opt: TIMESTAMP_ECHO=%u, len=%d, "\r\n"ackno=%llu", dccp_role(sk),\r\nopt_recv->dccpor_timestamp_echo,\r\nlen + 2,\r\n(unsigned long long)\r\nDCCP_SKB_CB(skb)->dccpd_ack_seq);\r\nvalue += 4;\r\nif (len == 4) {\r\ndccp_pr_debug_cat("\n");\r\nbreak;\r\n}\r\nif (len == 6) {\r\n__be16 opt_val2 = get_unaligned((__be16 *)value);\r\nelapsed_time = ntohs(opt_val2);\r\n} else {\r\nopt_val = get_unaligned((__be32 *)value);\r\nelapsed_time = ntohl(opt_val);\r\n}\r\ndccp_pr_debug_cat(", ELAPSED_TIME=%u\n", elapsed_time);\r\nif (elapsed_time > opt_recv->dccpor_elapsed_time)\r\nopt_recv->dccpor_elapsed_time = elapsed_time;\r\nbreak;\r\ncase DCCPO_ELAPSED_TIME:\r\nif (dccp_packet_without_ack(skb))\r\nbreak;\r\nif (len == 2) {\r\n__be16 opt_val2 = get_unaligned((__be16 *)value);\r\nelapsed_time = ntohs(opt_val2);\r\n} else if (len == 4) {\r\nopt_val = get_unaligned((__be32 *)value);\r\nelapsed_time = ntohl(opt_val);\r\n} else {\r\ngoto out_invalid_option;\r\n}\r\nif (elapsed_time > opt_recv->dccpor_elapsed_time)\r\nopt_recv->dccpor_elapsed_time = elapsed_time;\r\ndccp_pr_debug("%s rx opt: ELAPSED_TIME=%d\n",\r\ndccp_role(sk), elapsed_time);\r\nbreak;\r\ncase DCCPO_MIN_RX_CCID_SPECIFIC ... DCCPO_MAX_RX_CCID_SPECIFIC:\r\nif (ccid_hc_rx_parse_options(dp->dccps_hc_rx_ccid, sk,\r\npkt_type, opt, value, len))\r\ngoto out_invalid_option;\r\nbreak;\r\ncase DCCPO_ACK_VECTOR_0:\r\ncase DCCPO_ACK_VECTOR_1:\r\nif (dccp_packet_without_ack(skb))\r\nbreak;\r\ncase DCCPO_MIN_TX_CCID_SPECIFIC ... DCCPO_MAX_TX_CCID_SPECIFIC:\r\nif (ccid_hc_tx_parse_options(dp->dccps_hc_tx_ccid, sk,\r\npkt_type, opt, value, len))\r\ngoto out_invalid_option;\r\nbreak;\r\ndefault:\r\nDCCP_CRIT("DCCP(%p): option %d(len=%d) not "\r\n"implemented, ignoring", sk, opt, len);\r\nbreak;\r\n}\r\nignore_option:\r\nif (opt != DCCPO_MANDATORY)\r\nmandatory = 0;\r\n}\r\nif (mandatory)\r\ngoto out_invalid_option;\r\nout_nonsensical_length:\r\nreturn 0;\r\nout_invalid_option:\r\nDCCP_INC_STATS_BH(DCCP_MIB_INVALIDOPT);\r\nrc = DCCP_RESET_CODE_OPTION_ERROR;\r\nout_featneg_failed:\r\nDCCP_WARN("DCCP(%p): Option %d (len=%d) error=%u\n", sk, opt, len, rc);\r\nDCCP_SKB_CB(skb)->dccpd_reset_code = rc;\r\nDCCP_SKB_CB(skb)->dccpd_reset_data[0] = opt;\r\nDCCP_SKB_CB(skb)->dccpd_reset_data[1] = len > 0 ? value[0] : 0;\r\nDCCP_SKB_CB(skb)->dccpd_reset_data[2] = len > 1 ? value[1] : 0;\r\nreturn -1;\r\n}\r\nvoid dccp_encode_value_var(const u64 value, u8 *to, const u8 len)\r\n{\r\nif (len >= DCCP_OPTVAL_MAXLEN)\r\n*to++ = (value & 0xFF0000000000ull) >> 40;\r\nif (len > 4)\r\n*to++ = (value & 0xFF00000000ull) >> 32;\r\nif (len > 3)\r\n*to++ = (value & 0xFF000000) >> 24;\r\nif (len > 2)\r\n*to++ = (value & 0xFF0000) >> 16;\r\nif (len > 1)\r\n*to++ = (value & 0xFF00) >> 8;\r\nif (len > 0)\r\n*to++ = (value & 0xFF);\r\n}\r\nstatic inline u8 dccp_ndp_len(const u64 ndp)\r\n{\r\nif (likely(ndp <= 0xFF))\r\nreturn 1;\r\nreturn likely(ndp <= USHRT_MAX) ? 2 : (ndp <= UINT_MAX ? 4 : 6);\r\n}\r\nint dccp_insert_option(struct sk_buff *skb, const unsigned char option,\r\nconst void *value, const unsigned char len)\r\n{\r\nunsigned char *to;\r\nif (DCCP_SKB_CB(skb)->dccpd_opt_len + len + 2 > DCCP_MAX_OPT_LEN)\r\nreturn -1;\r\nDCCP_SKB_CB(skb)->dccpd_opt_len += len + 2;\r\nto = skb_push(skb, len + 2);\r\n*to++ = option;\r\n*to++ = len + 2;\r\nmemcpy(to, value, len);\r\nreturn 0;\r\n}\r\nstatic int dccp_insert_option_ndp(struct sock *sk, struct sk_buff *skb)\r\n{\r\nstruct dccp_sock *dp = dccp_sk(sk);\r\nu64 ndp = dp->dccps_ndp_count;\r\nif (dccp_non_data_packet(skb))\r\n++dp->dccps_ndp_count;\r\nelse\r\ndp->dccps_ndp_count = 0;\r\nif (ndp > 0) {\r\nunsigned char *ptr;\r\nconst int ndp_len = dccp_ndp_len(ndp);\r\nconst int len = ndp_len + 2;\r\nif (DCCP_SKB_CB(skb)->dccpd_opt_len + len > DCCP_MAX_OPT_LEN)\r\nreturn -1;\r\nDCCP_SKB_CB(skb)->dccpd_opt_len += len;\r\nptr = skb_push(skb, len);\r\n*ptr++ = DCCPO_NDP_COUNT;\r\n*ptr++ = len;\r\ndccp_encode_value_var(ndp, ptr, ndp_len);\r\n}\r\nreturn 0;\r\n}\r\nstatic inline int dccp_elapsed_time_len(const u32 elapsed_time)\r\n{\r\nreturn elapsed_time == 0 ? 0 : elapsed_time <= 0xFFFF ? 2 : 4;\r\n}\r\nstatic int dccp_insert_option_timestamp(struct sk_buff *skb)\r\n{\r\n__be32 now = htonl(dccp_timestamp());\r\nreturn dccp_insert_option(skb, DCCPO_TIMESTAMP, &now, sizeof(now));\r\n}\r\nstatic int dccp_insert_option_timestamp_echo(struct dccp_sock *dp,\r\nstruct dccp_request_sock *dreq,\r\nstruct sk_buff *skb)\r\n{\r\n__be32 tstamp_echo;\r\nunsigned char *to;\r\nu32 elapsed_time, elapsed_time_len, len;\r\nif (dreq != NULL) {\r\nelapsed_time = dccp_timestamp() - dreq->dreq_timestamp_time;\r\ntstamp_echo = htonl(dreq->dreq_timestamp_echo);\r\ndreq->dreq_timestamp_echo = 0;\r\n} else {\r\nelapsed_time = dccp_timestamp() - dp->dccps_timestamp_time;\r\ntstamp_echo = htonl(dp->dccps_timestamp_echo);\r\ndp->dccps_timestamp_echo = 0;\r\n}\r\nelapsed_time_len = dccp_elapsed_time_len(elapsed_time);\r\nlen = 6 + elapsed_time_len;\r\nif (DCCP_SKB_CB(skb)->dccpd_opt_len + len > DCCP_MAX_OPT_LEN)\r\nreturn -1;\r\nDCCP_SKB_CB(skb)->dccpd_opt_len += len;\r\nto = skb_push(skb, len);\r\n*to++ = DCCPO_TIMESTAMP_ECHO;\r\n*to++ = len;\r\nmemcpy(to, &tstamp_echo, 4);\r\nto += 4;\r\nif (elapsed_time_len == 2) {\r\nconst __be16 var16 = htons((u16)elapsed_time);\r\nmemcpy(to, &var16, 2);\r\n} else if (elapsed_time_len == 4) {\r\nconst __be32 var32 = htonl(elapsed_time);\r\nmemcpy(to, &var32, 4);\r\n}\r\nreturn 0;\r\n}\r\nstatic int dccp_insert_option_ackvec(struct sock *sk, struct sk_buff *skb)\r\n{\r\nstruct dccp_sock *dp = dccp_sk(sk);\r\nstruct dccp_ackvec *av = dp->dccps_hc_rx_ackvec;\r\nstruct dccp_skb_cb *dcb = DCCP_SKB_CB(skb);\r\nconst u16 buflen = dccp_ackvec_buflen(av);\r\nconst u8 nr_opts = DIV_ROUND_UP(buflen, DCCP_SINGLE_OPT_MAXLEN);\r\nu16 len = buflen + 2 * nr_opts;\r\nu8 i, nonce = 0;\r\nconst unsigned char *tail, *from;\r\nunsigned char *to;\r\nif (dcb->dccpd_opt_len + len > DCCP_MAX_OPT_LEN) {\r\nDCCP_WARN("Lacking space for %u bytes on %s packet\n", len,\r\ndccp_packet_name(dcb->dccpd_type));\r\nreturn -1;\r\n}\r\nif (len > DCCPAV_MIN_OPTLEN &&\r\nlen + dcb->dccpd_opt_len + skb->len > dp->dccps_mss_cache) {\r\nDCCP_WARN("No space left for Ack Vector (%u) on skb (%u+%u), "\r\n"MPS=%u ==> reduce payload size?\n", len, skb->len,\r\ndcb->dccpd_opt_len, dp->dccps_mss_cache);\r\ndp->dccps_sync_scheduled = 1;\r\nreturn 0;\r\n}\r\ndcb->dccpd_opt_len += len;\r\nto = skb_push(skb, len);\r\nlen = buflen;\r\nfrom = av->av_buf + av->av_buf_head;\r\ntail = av->av_buf + DCCPAV_MAX_ACKVEC_LEN;\r\nfor (i = 0; i < nr_opts; ++i) {\r\nint copylen = len;\r\nif (len > DCCP_SINGLE_OPT_MAXLEN)\r\ncopylen = DCCP_SINGLE_OPT_MAXLEN;\r\nnonce ^= av->av_buf_nonce[i];\r\n*to++ = DCCPO_ACK_VECTOR_0 + av->av_buf_nonce[i];\r\n*to++ = copylen + 2;\r\nif (from + copylen > tail) {\r\nconst u16 tailsize = tail - from;\r\nmemcpy(to, from, tailsize);\r\nto += tailsize;\r\nlen -= tailsize;\r\ncopylen -= tailsize;\r\nfrom = av->av_buf;\r\n}\r\nmemcpy(to, from, copylen);\r\nfrom += copylen;\r\nto += copylen;\r\nlen -= copylen;\r\n}\r\nif (dccp_ackvec_update_records(av, dcb->dccpd_seq, nonce))\r\nreturn -ENOBUFS;\r\nreturn 0;\r\n}\r\nint dccp_insert_option_mandatory(struct sk_buff *skb)\r\n{\r\nif (DCCP_SKB_CB(skb)->dccpd_opt_len >= DCCP_MAX_OPT_LEN)\r\nreturn -1;\r\nDCCP_SKB_CB(skb)->dccpd_opt_len++;\r\n*skb_push(skb, 1) = DCCPO_MANDATORY;\r\nreturn 0;\r\n}\r\nint dccp_insert_fn_opt(struct sk_buff *skb, u8 type, u8 feat,\r\nu8 *val, u8 len, bool repeat_first)\r\n{\r\nu8 tot_len, *to;\r\nif (len > (DCCP_SINGLE_OPT_MAXLEN - 2)) {\r\nDCCP_WARN("length %u for feature %u too large\n", len, feat);\r\nreturn -1;\r\n}\r\nif (unlikely(val == NULL || len == 0))\r\nlen = repeat_first = false;\r\ntot_len = 3 + repeat_first + len;\r\nif (DCCP_SKB_CB(skb)->dccpd_opt_len + tot_len > DCCP_MAX_OPT_LEN) {\r\nDCCP_WARN("packet too small for feature %d option!\n", feat);\r\nreturn -1;\r\n}\r\nDCCP_SKB_CB(skb)->dccpd_opt_len += tot_len;\r\nto = skb_push(skb, tot_len);\r\n*to++ = type;\r\n*to++ = tot_len;\r\n*to++ = feat;\r\nif (repeat_first)\r\n*to++ = *val;\r\nif (len)\r\nmemcpy(to, val, len);\r\nreturn 0;\r\n}\r\nstatic void dccp_insert_option_padding(struct sk_buff *skb)\r\n{\r\nint padding = DCCP_SKB_CB(skb)->dccpd_opt_len % 4;\r\nif (padding != 0) {\r\npadding = 4 - padding;\r\nmemset(skb_push(skb, padding), 0, padding);\r\nDCCP_SKB_CB(skb)->dccpd_opt_len += padding;\r\n}\r\n}\r\nint dccp_insert_options(struct sock *sk, struct sk_buff *skb)\r\n{\r\nstruct dccp_sock *dp = dccp_sk(sk);\r\nDCCP_SKB_CB(skb)->dccpd_opt_len = 0;\r\nif (dp->dccps_send_ndp_count && dccp_insert_option_ndp(sk, skb))\r\nreturn -1;\r\nif (DCCP_SKB_CB(skb)->dccpd_type != DCCP_PKT_DATA) {\r\nif (dccp_feat_insert_opts(dp, NULL, skb))\r\nreturn -1;\r\nif (DCCP_SKB_CB(skb)->dccpd_type == DCCP_PKT_REQUEST) {\r\nif (dccp_insert_option_timestamp(skb))\r\nreturn -1;\r\n} else if (dccp_ackvec_pending(sk) &&\r\ndccp_insert_option_ackvec(sk, skb)) {\r\nreturn -1;\r\n}\r\n}\r\nif (dp->dccps_hc_rx_insert_options) {\r\nif (ccid_hc_rx_insert_options(dp->dccps_hc_rx_ccid, sk, skb))\r\nreturn -1;\r\ndp->dccps_hc_rx_insert_options = 0;\r\n}\r\nif (dp->dccps_timestamp_echo != 0 &&\r\ndccp_insert_option_timestamp_echo(dp, NULL, skb))\r\nreturn -1;\r\ndccp_insert_option_padding(skb);\r\nreturn 0;\r\n}\r\nint dccp_insert_options_rsk(struct dccp_request_sock *dreq, struct sk_buff *skb)\r\n{\r\nDCCP_SKB_CB(skb)->dccpd_opt_len = 0;\r\nif (dccp_feat_insert_opts(NULL, dreq, skb))\r\nreturn -1;\r\nif (dccp_insert_option_timestamp(skb))\r\nreturn -1;\r\nif (dreq->dreq_timestamp_echo != 0 &&\r\ndccp_insert_option_timestamp_echo(NULL, dreq, skb))\r\nreturn -1;\r\ndccp_insert_option_padding(skb);\r\nreturn 0;\r\n}
