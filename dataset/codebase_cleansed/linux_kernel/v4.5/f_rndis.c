static inline struct f_rndis *func_to_rndis(struct usb_function *f)\r\n{\r\nreturn container_of(f, struct f_rndis, port.func);\r\n}\r\nstatic unsigned int bitrate(struct usb_gadget *g)\r\n{\r\nif (gadget_is_superspeed(g) && g->speed == USB_SPEED_SUPER)\r\nreturn 13 * 1024 * 8 * 1000 * 8;\r\nelse if (gadget_is_dualspeed(g) && g->speed == USB_SPEED_HIGH)\r\nreturn 13 * 512 * 8 * 1000 * 8;\r\nelse\r\nreturn 19 * 64 * 1 * 1000 * 8;\r\n}\r\nstatic struct sk_buff *rndis_add_header(struct gether *port,\r\nstruct sk_buff *skb)\r\n{\r\nstruct sk_buff *skb2;\r\nskb2 = skb_realloc_headroom(skb, sizeof(struct rndis_packet_msg_type));\r\nrndis_add_hdr(skb2);\r\ndev_kfree_skb(skb);\r\nreturn skb2;\r\n}\r\nstatic void rndis_response_available(void *_rndis)\r\n{\r\nstruct f_rndis *rndis = _rndis;\r\nstruct usb_request *req = rndis->notify_req;\r\nstruct usb_composite_dev *cdev = rndis->port.func.config->cdev;\r\n__le32 *data = req->buf;\r\nint status;\r\nif (atomic_inc_return(&rndis->notify_count) != 1)\r\nreturn;\r\ndata[0] = cpu_to_le32(1);\r\ndata[1] = cpu_to_le32(0);\r\nstatus = usb_ep_queue(rndis->notify, req, GFP_ATOMIC);\r\nif (status) {\r\natomic_dec(&rndis->notify_count);\r\nDBG(cdev, "notify/0 --> %d\n", status);\r\n}\r\n}\r\nstatic void rndis_response_complete(struct usb_ep *ep, struct usb_request *req)\r\n{\r\nstruct f_rndis *rndis = req->context;\r\nstruct usb_composite_dev *cdev = rndis->port.func.config->cdev;\r\nint status = req->status;\r\nswitch (status) {\r\ncase -ECONNRESET:\r\ncase -ESHUTDOWN:\r\natomic_set(&rndis->notify_count, 0);\r\nbreak;\r\ndefault:\r\nDBG(cdev, "RNDIS %s response error %d, %d/%d\n",\r\nep->name, status,\r\nreq->actual, req->length);\r\ncase 0:\r\nif (ep != rndis->notify)\r\nbreak;\r\nif (atomic_dec_and_test(&rndis->notify_count))\r\nbreak;\r\nstatus = usb_ep_queue(rndis->notify, req, GFP_ATOMIC);\r\nif (status) {\r\natomic_dec(&rndis->notify_count);\r\nDBG(cdev, "notify/1 --> %d\n", status);\r\n}\r\nbreak;\r\n}\r\n}\r\nstatic void rndis_command_complete(struct usb_ep *ep, struct usb_request *req)\r\n{\r\nstruct f_rndis *rndis = req->context;\r\nint status;\r\nstatus = rndis_msg_parser(rndis->params, (u8 *) req->buf);\r\nif (status < 0)\r\npr_err("RNDIS command error %d, %d/%d\n",\r\nstatus, req->actual, req->length);\r\n}\r\nstatic int\r\nrndis_setup(struct usb_function *f, const struct usb_ctrlrequest *ctrl)\r\n{\r\nstruct f_rndis *rndis = func_to_rndis(f);\r\nstruct usb_composite_dev *cdev = f->config->cdev;\r\nstruct usb_request *req = cdev->req;\r\nint value = -EOPNOTSUPP;\r\nu16 w_index = le16_to_cpu(ctrl->wIndex);\r\nu16 w_value = le16_to_cpu(ctrl->wValue);\r\nu16 w_length = le16_to_cpu(ctrl->wLength);\r\nswitch ((ctrl->bRequestType << 8) | ctrl->bRequest) {\r\ncase ((USB_DIR_OUT | USB_TYPE_CLASS | USB_RECIP_INTERFACE) << 8)\r\n| USB_CDC_SEND_ENCAPSULATED_COMMAND:\r\nif (w_value || w_index != rndis->ctrl_id)\r\ngoto invalid;\r\nvalue = w_length;\r\nreq->complete = rndis_command_complete;\r\nreq->context = rndis;\r\nbreak;\r\ncase ((USB_DIR_IN | USB_TYPE_CLASS | USB_RECIP_INTERFACE) << 8)\r\n| USB_CDC_GET_ENCAPSULATED_RESPONSE:\r\nif (w_value || w_index != rndis->ctrl_id)\r\ngoto invalid;\r\nelse {\r\nu8 *buf;\r\nu32 n;\r\nbuf = rndis_get_next_response(rndis->params, &n);\r\nif (buf) {\r\nmemcpy(req->buf, buf, n);\r\nreq->complete = rndis_response_complete;\r\nreq->context = rndis;\r\nrndis_free_response(rndis->params, buf);\r\nvalue = n;\r\n}\r\n}\r\nbreak;\r\ndefault:\r\ninvalid:\r\nVDBG(cdev, "invalid control req%02x.%02x v%04x i%04x l%d\n",\r\nctrl->bRequestType, ctrl->bRequest,\r\nw_value, w_index, w_length);\r\n}\r\nif (value >= 0) {\r\nDBG(cdev, "rndis req%02x.%02x v%04x i%04x l%d\n",\r\nctrl->bRequestType, ctrl->bRequest,\r\nw_value, w_index, w_length);\r\nreq->zero = (value < w_length);\r\nreq->length = value;\r\nvalue = usb_ep_queue(cdev->gadget->ep0, req, GFP_ATOMIC);\r\nif (value < 0)\r\nERROR(cdev, "rndis response on err %d\n", value);\r\n}\r\nreturn value;\r\n}\r\nstatic int rndis_set_alt(struct usb_function *f, unsigned intf, unsigned alt)\r\n{\r\nstruct f_rndis *rndis = func_to_rndis(f);\r\nstruct usb_composite_dev *cdev = f->config->cdev;\r\nif (intf == rndis->ctrl_id) {\r\nVDBG(cdev, "reset rndis control %d\n", intf);\r\nusb_ep_disable(rndis->notify);\r\nif (!rndis->notify->desc) {\r\nVDBG(cdev, "init rndis ctrl %d\n", intf);\r\nif (config_ep_by_speed(cdev->gadget, f, rndis->notify))\r\ngoto fail;\r\n}\r\nusb_ep_enable(rndis->notify);\r\n} else if (intf == rndis->data_id) {\r\nstruct net_device *net;\r\nif (rndis->port.in_ep->enabled) {\r\nDBG(cdev, "reset rndis\n");\r\ngether_disconnect(&rndis->port);\r\n}\r\nif (!rndis->port.in_ep->desc || !rndis->port.out_ep->desc) {\r\nDBG(cdev, "init rndis\n");\r\nif (config_ep_by_speed(cdev->gadget, f,\r\nrndis->port.in_ep) ||\r\nconfig_ep_by_speed(cdev->gadget, f,\r\nrndis->port.out_ep)) {\r\nrndis->port.in_ep->desc = NULL;\r\nrndis->port.out_ep->desc = NULL;\r\ngoto fail;\r\n}\r\n}\r\nrndis->port.is_zlp_ok = false;\r\nrndis->port.cdc_filter = 0;\r\nDBG(cdev, "RNDIS RX/TX early activation ... \n");\r\nnet = gether_connect(&rndis->port);\r\nif (IS_ERR(net))\r\nreturn PTR_ERR(net);\r\nrndis_set_param_dev(rndis->params, net,\r\n&rndis->port.cdc_filter);\r\n} else\r\ngoto fail;\r\nreturn 0;\r\nfail:\r\nreturn -EINVAL;\r\n}\r\nstatic void rndis_disable(struct usb_function *f)\r\n{\r\nstruct f_rndis *rndis = func_to_rndis(f);\r\nstruct usb_composite_dev *cdev = f->config->cdev;\r\nif (!rndis->notify->enabled)\r\nreturn;\r\nDBG(cdev, "rndis deactivated\n");\r\nrndis_uninit(rndis->params);\r\ngether_disconnect(&rndis->port);\r\nusb_ep_disable(rndis->notify);\r\n}\r\nstatic void rndis_open(struct gether *geth)\r\n{\r\nstruct f_rndis *rndis = func_to_rndis(&geth->func);\r\nstruct usb_composite_dev *cdev = geth->func.config->cdev;\r\nDBG(cdev, "%s\n", __func__);\r\nrndis_set_param_medium(rndis->params, RNDIS_MEDIUM_802_3,\r\nbitrate(cdev->gadget) / 100);\r\nrndis_signal_connect(rndis->params);\r\n}\r\nstatic void rndis_close(struct gether *geth)\r\n{\r\nstruct f_rndis *rndis = func_to_rndis(&geth->func);\r\nDBG(geth->func.config->cdev, "%s\n", __func__);\r\nrndis_set_param_medium(rndis->params, RNDIS_MEDIUM_802_3, 0);\r\nrndis_signal_disconnect(rndis->params);\r\n}\r\nstatic inline bool can_support_rndis(struct usb_configuration *c)\r\n{\r\nreturn true;\r\n}\r\nstatic int\r\nrndis_bind(struct usb_configuration *c, struct usb_function *f)\r\n{\r\nstruct usb_composite_dev *cdev = c->cdev;\r\nstruct f_rndis *rndis = func_to_rndis(f);\r\nstruct usb_string *us;\r\nint status;\r\nstruct usb_ep *ep;\r\nstruct f_rndis_opts *rndis_opts;\r\nif (!can_support_rndis(c))\r\nreturn -EINVAL;\r\nrndis_opts = container_of(f->fi, struct f_rndis_opts, func_inst);\r\nif (cdev->use_os_string) {\r\nf->os_desc_table = kzalloc(sizeof(*f->os_desc_table),\r\nGFP_KERNEL);\r\nif (!f->os_desc_table)\r\nreturn -ENOMEM;\r\nf->os_desc_n = 1;\r\nf->os_desc_table[0].os_desc = &rndis_opts->rndis_os_desc;\r\n}\r\nif (!rndis_opts->bound) {\r\ngether_set_gadget(rndis_opts->net, cdev->gadget);\r\nstatus = gether_register_netdev(rndis_opts->net);\r\nif (status)\r\ngoto fail;\r\nrndis_opts->bound = true;\r\n}\r\nus = usb_gstrings_attach(cdev, rndis_strings,\r\nARRAY_SIZE(rndis_string_defs));\r\nif (IS_ERR(us)) {\r\nstatus = PTR_ERR(us);\r\ngoto fail;\r\n}\r\nrndis_control_intf.iInterface = us[0].id;\r\nrndis_data_intf.iInterface = us[1].id;\r\nrndis_iad_descriptor.iFunction = us[2].id;\r\nstatus = usb_interface_id(c, f);\r\nif (status < 0)\r\ngoto fail;\r\nrndis->ctrl_id = status;\r\nrndis_iad_descriptor.bFirstInterface = status;\r\nrndis_control_intf.bInterfaceNumber = status;\r\nrndis_union_desc.bMasterInterface0 = status;\r\nif (cdev->use_os_string)\r\nf->os_desc_table[0].if_id =\r\nrndis_iad_descriptor.bFirstInterface;\r\nstatus = usb_interface_id(c, f);\r\nif (status < 0)\r\ngoto fail;\r\nrndis->data_id = status;\r\nrndis_data_intf.bInterfaceNumber = status;\r\nrndis_union_desc.bSlaveInterface0 = status;\r\nstatus = -ENODEV;\r\nep = usb_ep_autoconfig(cdev->gadget, &fs_in_desc);\r\nif (!ep)\r\ngoto fail;\r\nrndis->port.in_ep = ep;\r\nep = usb_ep_autoconfig(cdev->gadget, &fs_out_desc);\r\nif (!ep)\r\ngoto fail;\r\nrndis->port.out_ep = ep;\r\nep = usb_ep_autoconfig(cdev->gadget, &fs_notify_desc);\r\nif (!ep)\r\ngoto fail;\r\nrndis->notify = ep;\r\nstatus = -ENOMEM;\r\nrndis->notify_req = usb_ep_alloc_request(ep, GFP_KERNEL);\r\nif (!rndis->notify_req)\r\ngoto fail;\r\nrndis->notify_req->buf = kmalloc(STATUS_BYTECOUNT, GFP_KERNEL);\r\nif (!rndis->notify_req->buf)\r\ngoto fail;\r\nrndis->notify_req->length = STATUS_BYTECOUNT;\r\nrndis->notify_req->context = rndis;\r\nrndis->notify_req->complete = rndis_response_complete;\r\nhs_in_desc.bEndpointAddress = fs_in_desc.bEndpointAddress;\r\nhs_out_desc.bEndpointAddress = fs_out_desc.bEndpointAddress;\r\nhs_notify_desc.bEndpointAddress = fs_notify_desc.bEndpointAddress;\r\nss_in_desc.bEndpointAddress = fs_in_desc.bEndpointAddress;\r\nss_out_desc.bEndpointAddress = fs_out_desc.bEndpointAddress;\r\nss_notify_desc.bEndpointAddress = fs_notify_desc.bEndpointAddress;\r\nstatus = usb_assign_descriptors(f, eth_fs_function, eth_hs_function,\r\neth_ss_function);\r\nif (status)\r\ngoto fail;\r\nrndis->port.open = rndis_open;\r\nrndis->port.close = rndis_close;\r\nrndis_set_param_medium(rndis->params, RNDIS_MEDIUM_802_3, 0);\r\nrndis_set_host_mac(rndis->params, rndis->ethaddr);\r\nif (rndis->manufacturer && rndis->vendorID &&\r\nrndis_set_param_vendor(rndis->params, rndis->vendorID,\r\nrndis->manufacturer)) {\r\nstatus = -EINVAL;\r\ngoto fail_free_descs;\r\n}\r\nDBG(cdev, "RNDIS: %s speed IN/%s OUT/%s NOTIFY/%s\n",\r\ngadget_is_superspeed(c->cdev->gadget) ? "super" :\r\ngadget_is_dualspeed(c->cdev->gadget) ? "dual" : "full",\r\nrndis->port.in_ep->name, rndis->port.out_ep->name,\r\nrndis->notify->name);\r\nreturn 0;\r\nfail_free_descs:\r\nusb_free_all_descriptors(f);\r\nfail:\r\nkfree(f->os_desc_table);\r\nf->os_desc_n = 0;\r\nif (rndis->notify_req) {\r\nkfree(rndis->notify_req->buf);\r\nusb_ep_free_request(rndis->notify, rndis->notify_req);\r\n}\r\nERROR(cdev, "%s: can't bind, err %d\n", f->name, status);\r\nreturn status;\r\n}\r\nvoid rndis_borrow_net(struct usb_function_instance *f, struct net_device *net)\r\n{\r\nstruct f_rndis_opts *opts;\r\nopts = container_of(f, struct f_rndis_opts, func_inst);\r\nif (opts->bound)\r\ngether_cleanup(netdev_priv(opts->net));\r\nelse\r\nfree_netdev(opts->net);\r\nopts->borrowed_net = opts->bound = true;\r\nopts->net = net;\r\n}\r\nstatic inline struct f_rndis_opts *to_f_rndis_opts(struct config_item *item)\r\n{\r\nreturn container_of(to_config_group(item), struct f_rndis_opts,\r\nfunc_inst.group);\r\n}\r\nstatic void rndis_free_inst(struct usb_function_instance *f)\r\n{\r\nstruct f_rndis_opts *opts;\r\nopts = container_of(f, struct f_rndis_opts, func_inst);\r\nif (!opts->borrowed_net) {\r\nif (opts->bound)\r\ngether_cleanup(netdev_priv(opts->net));\r\nelse\r\nfree_netdev(opts->net);\r\n}\r\nkfree(opts->rndis_os_desc.group.default_groups);\r\nkfree(opts);\r\n}\r\nstatic struct usb_function_instance *rndis_alloc_inst(void)\r\n{\r\nstruct f_rndis_opts *opts;\r\nstruct usb_os_desc *descs[1];\r\nchar *names[1];\r\nopts = kzalloc(sizeof(*opts), GFP_KERNEL);\r\nif (!opts)\r\nreturn ERR_PTR(-ENOMEM);\r\nopts->rndis_os_desc.ext_compat_id = opts->rndis_ext_compat_id;\r\nmutex_init(&opts->lock);\r\nopts->func_inst.free_func_inst = rndis_free_inst;\r\nopts->net = gether_setup_default();\r\nif (IS_ERR(opts->net)) {\r\nstruct net_device *net = opts->net;\r\nkfree(opts);\r\nreturn ERR_CAST(net);\r\n}\r\nINIT_LIST_HEAD(&opts->rndis_os_desc.ext_prop);\r\ndescs[0] = &opts->rndis_os_desc;\r\nnames[0] = "rndis";\r\nusb_os_desc_prepare_interf_dir(&opts->func_inst.group, 1, descs,\r\nnames, THIS_MODULE);\r\nconfig_group_init_type_name(&opts->func_inst.group, "",\r\n&rndis_func_type);\r\nreturn &opts->func_inst;\r\n}\r\nstatic void rndis_free(struct usb_function *f)\r\n{\r\nstruct f_rndis *rndis;\r\nstruct f_rndis_opts *opts;\r\nrndis = func_to_rndis(f);\r\nrndis_deregister(rndis->params);\r\nopts = container_of(f->fi, struct f_rndis_opts, func_inst);\r\nkfree(rndis);\r\nmutex_lock(&opts->lock);\r\nopts->refcnt--;\r\nmutex_unlock(&opts->lock);\r\n}\r\nstatic void rndis_unbind(struct usb_configuration *c, struct usb_function *f)\r\n{\r\nstruct f_rndis *rndis = func_to_rndis(f);\r\nkfree(f->os_desc_table);\r\nf->os_desc_n = 0;\r\nusb_free_all_descriptors(f);\r\nkfree(rndis->notify_req->buf);\r\nusb_ep_free_request(rndis->notify, rndis->notify_req);\r\n}\r\nstatic struct usb_function *rndis_alloc(struct usb_function_instance *fi)\r\n{\r\nstruct f_rndis *rndis;\r\nstruct f_rndis_opts *opts;\r\nstruct rndis_params *params;\r\nrndis = kzalloc(sizeof(*rndis), GFP_KERNEL);\r\nif (!rndis)\r\nreturn ERR_PTR(-ENOMEM);\r\nopts = container_of(fi, struct f_rndis_opts, func_inst);\r\nmutex_lock(&opts->lock);\r\nopts->refcnt++;\r\ngether_get_host_addr_u8(opts->net, rndis->ethaddr);\r\nrndis->vendorID = opts->vendor_id;\r\nrndis->manufacturer = opts->manufacturer;\r\nrndis->port.ioport = netdev_priv(opts->net);\r\nmutex_unlock(&opts->lock);\r\nrndis->port.cdc_filter = 0;\r\nrndis->port.header_len = sizeof(struct rndis_packet_msg_type);\r\nrndis->port.wrap = rndis_add_header;\r\nrndis->port.unwrap = rndis_rm_hdr;\r\nrndis->port.func.name = "rndis";\r\nrndis->port.func.bind = rndis_bind;\r\nrndis->port.func.unbind = rndis_unbind;\r\nrndis->port.func.set_alt = rndis_set_alt;\r\nrndis->port.func.setup = rndis_setup;\r\nrndis->port.func.disable = rndis_disable;\r\nrndis->port.func.free_func = rndis_free;\r\nparams = rndis_register(rndis_response_available, rndis);\r\nif (IS_ERR(params)) {\r\nkfree(rndis);\r\nreturn ERR_CAST(params);\r\n}\r\nrndis->params = params;\r\nreturn &rndis->port.func;\r\n}
