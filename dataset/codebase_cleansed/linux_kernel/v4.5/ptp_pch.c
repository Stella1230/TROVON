static inline void pch_eth_enable_set(struct pch_dev *chip)\r\n{\r\nu32 val;\r\nval = ioread32(&chip->regs->ts_sel) | (PCH_ECS_ETH);\r\niowrite32(val, (&chip->regs->ts_sel));\r\n}\r\nstatic u64 pch_systime_read(struct pch_ts_regs __iomem *regs)\r\n{\r\nu64 ns;\r\nu32 lo, hi;\r\nlo = ioread32(&regs->systime_lo);\r\nhi = ioread32(&regs->systime_hi);\r\nns = ((u64) hi) << 32;\r\nns |= lo;\r\nns <<= TICKS_NS_SHIFT;\r\nreturn ns;\r\n}\r\nstatic void pch_systime_write(struct pch_ts_regs __iomem *regs, u64 ns)\r\n{\r\nu32 hi, lo;\r\nns >>= TICKS_NS_SHIFT;\r\nhi = ns >> 32;\r\nlo = ns & 0xffffffff;\r\niowrite32(lo, &regs->systime_lo);\r\niowrite32(hi, &regs->systime_hi);\r\n}\r\nstatic inline void pch_block_reset(struct pch_dev *chip)\r\n{\r\nu32 val;\r\nval = ioread32(&chip->regs->control) | PCH_TSC_RESET;\r\niowrite32(val, (&chip->regs->control));\r\nval = val & ~PCH_TSC_RESET;\r\niowrite32(val, (&chip->regs->control));\r\n}\r\nu32 pch_ch_control_read(struct pci_dev *pdev)\r\n{\r\nstruct pch_dev *chip = pci_get_drvdata(pdev);\r\nu32 val;\r\nval = ioread32(&chip->regs->ch_control);\r\nreturn val;\r\n}\r\nvoid pch_ch_control_write(struct pci_dev *pdev, u32 val)\r\n{\r\nstruct pch_dev *chip = pci_get_drvdata(pdev);\r\niowrite32(val, (&chip->regs->ch_control));\r\n}\r\nu32 pch_ch_event_read(struct pci_dev *pdev)\r\n{\r\nstruct pch_dev *chip = pci_get_drvdata(pdev);\r\nu32 val;\r\nval = ioread32(&chip->regs->ch_event);\r\nreturn val;\r\n}\r\nvoid pch_ch_event_write(struct pci_dev *pdev, u32 val)\r\n{\r\nstruct pch_dev *chip = pci_get_drvdata(pdev);\r\niowrite32(val, (&chip->regs->ch_event));\r\n}\r\nu32 pch_src_uuid_lo_read(struct pci_dev *pdev)\r\n{\r\nstruct pch_dev *chip = pci_get_drvdata(pdev);\r\nu32 val;\r\nval = ioread32(&chip->regs->src_uuid_lo);\r\nreturn val;\r\n}\r\nu32 pch_src_uuid_hi_read(struct pci_dev *pdev)\r\n{\r\nstruct pch_dev *chip = pci_get_drvdata(pdev);\r\nu32 val;\r\nval = ioread32(&chip->regs->src_uuid_hi);\r\nreturn val;\r\n}\r\nu64 pch_rx_snap_read(struct pci_dev *pdev)\r\n{\r\nstruct pch_dev *chip = pci_get_drvdata(pdev);\r\nu64 ns;\r\nu32 lo, hi;\r\nlo = ioread32(&chip->regs->rx_snap_lo);\r\nhi = ioread32(&chip->regs->rx_snap_hi);\r\nns = ((u64) hi) << 32;\r\nns |= lo;\r\nns <<= TICKS_NS_SHIFT;\r\nreturn ns;\r\n}\r\nu64 pch_tx_snap_read(struct pci_dev *pdev)\r\n{\r\nstruct pch_dev *chip = pci_get_drvdata(pdev);\r\nu64 ns;\r\nu32 lo, hi;\r\nlo = ioread32(&chip->regs->tx_snap_lo);\r\nhi = ioread32(&chip->regs->tx_snap_hi);\r\nns = ((u64) hi) << 32;\r\nns |= lo;\r\nns <<= TICKS_NS_SHIFT;\r\nreturn ns;\r\n}\r\nstatic void pch_set_system_time_count(struct pch_dev *chip)\r\n{\r\niowrite32(0x01, &chip->regs->stl_max_set_en);\r\niowrite32(0xFFFFFFFF, &chip->regs->stl_max_set);\r\niowrite32(0x00, &chip->regs->stl_max_set_en);\r\n}\r\nstatic void pch_reset(struct pch_dev *chip)\r\n{\r\npch_block_reset(chip);\r\npch_set_system_time_count(chip);\r\n}\r\nint pch_set_station_address(u8 *addr, struct pci_dev *pdev)\r\n{\r\ns32 i;\r\nstruct pch_dev *chip = pci_get_drvdata(pdev);\r\nif ((chip->regs == NULL) || addr == (u8 *)NULL) {\r\ndev_err(&pdev->dev,\r\n"invalid params returning PCH_INVALIDPARAM\n");\r\nreturn PCH_INVALIDPARAM;\r\n}\r\nfor (i = 0; i < PCH_STATION_BYTES; i++) {\r\nu32 val;\r\ns32 tmp;\r\ntmp = hex_to_bin(addr[i * 3]);\r\nif (tmp < 0) {\r\ndev_err(&pdev->dev,\r\n"invalid params returning PCH_INVALIDPARAM\n");\r\nreturn PCH_INVALIDPARAM;\r\n}\r\nval = tmp * 16;\r\ntmp = hex_to_bin(addr[(i * 3) + 1]);\r\nif (tmp < 0) {\r\ndev_err(&pdev->dev,\r\n"invalid params returning PCH_INVALIDPARAM\n");\r\nreturn PCH_INVALIDPARAM;\r\n}\r\nval += tmp;\r\nif ((i < 5) && (addr[(i * 3) + 2] != ':')) {\r\ndev_err(&pdev->dev,\r\n"invalid params returning PCH_INVALIDPARAM\n");\r\nreturn PCH_INVALIDPARAM;\r\n}\r\ndev_dbg(&pdev->dev, "invoking pch_station_set\n");\r\niowrite32(val, &chip->regs->ts_st[i]);\r\n}\r\nreturn 0;\r\n}\r\nstatic irqreturn_t isr(int irq, void *priv)\r\n{\r\nstruct pch_dev *pch_dev = priv;\r\nstruct pch_ts_regs __iomem *regs = pch_dev->regs;\r\nstruct ptp_clock_event event;\r\nu32 ack = 0, lo, hi, val;\r\nval = ioread32(&regs->event);\r\nif (val & PCH_TSE_SNS) {\r\nack |= PCH_TSE_SNS;\r\nif (pch_dev->exts0_enabled) {\r\nhi = ioread32(&regs->asms_hi);\r\nlo = ioread32(&regs->asms_lo);\r\nevent.type = PTP_CLOCK_EXTTS;\r\nevent.index = 0;\r\nevent.timestamp = ((u64) hi) << 32;\r\nevent.timestamp |= lo;\r\nevent.timestamp <<= TICKS_NS_SHIFT;\r\nptp_clock_event(pch_dev->ptp_clock, &event);\r\n}\r\n}\r\nif (val & PCH_TSE_SNM) {\r\nack |= PCH_TSE_SNM;\r\nif (pch_dev->exts1_enabled) {\r\nhi = ioread32(&regs->amms_hi);\r\nlo = ioread32(&regs->amms_lo);\r\nevent.type = PTP_CLOCK_EXTTS;\r\nevent.index = 1;\r\nevent.timestamp = ((u64) hi) << 32;\r\nevent.timestamp |= lo;\r\nevent.timestamp <<= TICKS_NS_SHIFT;\r\nptp_clock_event(pch_dev->ptp_clock, &event);\r\n}\r\n}\r\nif (val & PCH_TSE_TTIPEND)\r\nack |= PCH_TSE_TTIPEND;\r\nif (ack) {\r\niowrite32(ack, &regs->event);\r\nreturn IRQ_HANDLED;\r\n} else\r\nreturn IRQ_NONE;\r\n}\r\nstatic int ptp_pch_adjfreq(struct ptp_clock_info *ptp, s32 ppb)\r\n{\r\nu64 adj;\r\nu32 diff, addend;\r\nint neg_adj = 0;\r\nstruct pch_dev *pch_dev = container_of(ptp, struct pch_dev, caps);\r\nstruct pch_ts_regs __iomem *regs = pch_dev->regs;\r\nif (ppb < 0) {\r\nneg_adj = 1;\r\nppb = -ppb;\r\n}\r\naddend = DEFAULT_ADDEND;\r\nadj = addend;\r\nadj *= ppb;\r\ndiff = div_u64(adj, 1000000000ULL);\r\naddend = neg_adj ? addend - diff : addend + diff;\r\niowrite32(addend, &regs->addend);\r\nreturn 0;\r\n}\r\nstatic int ptp_pch_adjtime(struct ptp_clock_info *ptp, s64 delta)\r\n{\r\ns64 now;\r\nunsigned long flags;\r\nstruct pch_dev *pch_dev = container_of(ptp, struct pch_dev, caps);\r\nstruct pch_ts_regs __iomem *regs = pch_dev->regs;\r\nspin_lock_irqsave(&pch_dev->register_lock, flags);\r\nnow = pch_systime_read(regs);\r\nnow += delta;\r\npch_systime_write(regs, now);\r\nspin_unlock_irqrestore(&pch_dev->register_lock, flags);\r\nreturn 0;\r\n}\r\nstatic int ptp_pch_gettime(struct ptp_clock_info *ptp, struct timespec64 *ts)\r\n{\r\nu64 ns;\r\nu32 remainder;\r\nunsigned long flags;\r\nstruct pch_dev *pch_dev = container_of(ptp, struct pch_dev, caps);\r\nstruct pch_ts_regs __iomem *regs = pch_dev->regs;\r\nspin_lock_irqsave(&pch_dev->register_lock, flags);\r\nns = pch_systime_read(regs);\r\nspin_unlock_irqrestore(&pch_dev->register_lock, flags);\r\nts->tv_sec = div_u64_rem(ns, 1000000000, &remainder);\r\nts->tv_nsec = remainder;\r\nreturn 0;\r\n}\r\nstatic int ptp_pch_settime(struct ptp_clock_info *ptp,\r\nconst struct timespec64 *ts)\r\n{\r\nu64 ns;\r\nunsigned long flags;\r\nstruct pch_dev *pch_dev = container_of(ptp, struct pch_dev, caps);\r\nstruct pch_ts_regs __iomem *regs = pch_dev->regs;\r\nns = ts->tv_sec * 1000000000ULL;\r\nns += ts->tv_nsec;\r\nspin_lock_irqsave(&pch_dev->register_lock, flags);\r\npch_systime_write(regs, ns);\r\nspin_unlock_irqrestore(&pch_dev->register_lock, flags);\r\nreturn 0;\r\n}\r\nstatic int ptp_pch_enable(struct ptp_clock_info *ptp,\r\nstruct ptp_clock_request *rq, int on)\r\n{\r\nstruct pch_dev *pch_dev = container_of(ptp, struct pch_dev, caps);\r\nswitch (rq->type) {\r\ncase PTP_CLK_REQ_EXTTS:\r\nswitch (rq->extts.index) {\r\ncase 0:\r\npch_dev->exts0_enabled = on ? 1 : 0;\r\nbreak;\r\ncase 1:\r\npch_dev->exts1_enabled = on ? 1 : 0;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\ndefault:\r\nbreak;\r\n}\r\nreturn -EOPNOTSUPP;\r\n}\r\nstatic s32 pch_suspend(struct pci_dev *pdev, pm_message_t state)\r\n{\r\npci_disable_device(pdev);\r\npci_enable_wake(pdev, PCI_D3hot, 0);\r\nif (pci_save_state(pdev) != 0) {\r\ndev_err(&pdev->dev, "could not save PCI config state\n");\r\nreturn -ENOMEM;\r\n}\r\npci_set_power_state(pdev, pci_choose_state(pdev, state));\r\nreturn 0;\r\n}\r\nstatic s32 pch_resume(struct pci_dev *pdev)\r\n{\r\ns32 ret;\r\npci_set_power_state(pdev, PCI_D0);\r\npci_restore_state(pdev);\r\nret = pci_enable_device(pdev);\r\nif (ret) {\r\ndev_err(&pdev->dev, "pci_enable_device failed\n");\r\nreturn ret;\r\n}\r\npci_enable_wake(pdev, PCI_D3hot, 0);\r\nreturn 0;\r\n}\r\nstatic void pch_remove(struct pci_dev *pdev)\r\n{\r\nstruct pch_dev *chip = pci_get_drvdata(pdev);\r\nptp_clock_unregister(chip->ptp_clock);\r\nif (pdev->irq != 0)\r\nfree_irq(pdev->irq, chip);\r\nif (chip->regs != NULL) {\r\niounmap(chip->regs);\r\nchip->regs = NULL;\r\n}\r\nif (chip->mem_base != 0) {\r\nrelease_mem_region(chip->mem_base, chip->mem_size);\r\nchip->mem_base = 0;\r\n}\r\npci_disable_device(pdev);\r\nkfree(chip);\r\ndev_info(&pdev->dev, "complete\n");\r\n}\r\nstatic s32\r\npch_probe(struct pci_dev *pdev, const struct pci_device_id *id)\r\n{\r\ns32 ret;\r\nunsigned long flags;\r\nstruct pch_dev *chip;\r\nchip = kzalloc(sizeof(struct pch_dev), GFP_KERNEL);\r\nif (chip == NULL)\r\nreturn -ENOMEM;\r\nret = pci_enable_device(pdev);\r\nif (ret != 0) {\r\ndev_err(&pdev->dev, "could not enable the pci device\n");\r\ngoto err_pci_en;\r\n}\r\nchip->mem_base = pci_resource_start(pdev, IO_MEM_BAR);\r\nif (!chip->mem_base) {\r\ndev_err(&pdev->dev, "could not locate IO memory address\n");\r\nret = -ENODEV;\r\ngoto err_pci_start;\r\n}\r\nchip->mem_size = pci_resource_len(pdev, IO_MEM_BAR);\r\nif (!request_mem_region(chip->mem_base, chip->mem_size, "1588_regs")) {\r\ndev_err(&pdev->dev,\r\n"could not allocate register memory space\n");\r\nret = -EBUSY;\r\ngoto err_req_mem_region;\r\n}\r\nchip->regs = ioremap(chip->mem_base, chip->mem_size);\r\nif (!chip->regs) {\r\ndev_err(&pdev->dev, "Could not get virtual address\n");\r\nret = -ENOMEM;\r\ngoto err_ioremap;\r\n}\r\nchip->caps = ptp_pch_caps;\r\nchip->ptp_clock = ptp_clock_register(&chip->caps, &pdev->dev);\r\nif (IS_ERR(chip->ptp_clock)) {\r\nret = PTR_ERR(chip->ptp_clock);\r\ngoto err_ptp_clock_reg;\r\n}\r\nspin_lock_init(&chip->register_lock);\r\nret = request_irq(pdev->irq, &isr, IRQF_SHARED, KBUILD_MODNAME, chip);\r\nif (ret != 0) {\r\ndev_err(&pdev->dev, "failed to get irq %d\n", pdev->irq);\r\ngoto err_req_irq;\r\n}\r\nchip->irq = pdev->irq;\r\nchip->pdev = pdev;\r\npci_set_drvdata(pdev, chip);\r\nspin_lock_irqsave(&chip->register_lock, flags);\r\npch_reset(chip);\r\niowrite32(DEFAULT_ADDEND, &chip->regs->addend);\r\niowrite32(1, &chip->regs->trgt_lo);\r\niowrite32(0, &chip->regs->trgt_hi);\r\niowrite32(PCH_TSE_TTIPEND, &chip->regs->event);\r\npch_eth_enable_set(chip);\r\nif (strcmp(pch_param.station, "00:00:00:00:00:00") != 0) {\r\nif (pch_set_station_address(pch_param.station, pdev) != 0) {\r\ndev_err(&pdev->dev,\r\n"Invalid station address parameter\n"\r\n"Module loaded but station address not set correctly\n"\r\n);\r\n}\r\n}\r\nspin_unlock_irqrestore(&chip->register_lock, flags);\r\nreturn 0;\r\nerr_req_irq:\r\nptp_clock_unregister(chip->ptp_clock);\r\nerr_ptp_clock_reg:\r\niounmap(chip->regs);\r\nchip->regs = NULL;\r\nerr_ioremap:\r\nrelease_mem_region(chip->mem_base, chip->mem_size);\r\nerr_req_mem_region:\r\nchip->mem_base = 0;\r\nerr_pci_start:\r\npci_disable_device(pdev);\r\nerr_pci_en:\r\nkfree(chip);\r\ndev_err(&pdev->dev, "probe failed(ret=0x%x)\n", ret);\r\nreturn ret;\r\n}\r\nstatic void __exit ptp_pch_exit(void)\r\n{\r\npci_unregister_driver(&pch_driver);\r\n}\r\nstatic s32 __init ptp_pch_init(void)\r\n{\r\ns32 ret;\r\nret = pci_register_driver(&pch_driver);\r\nreturn ret;\r\n}
