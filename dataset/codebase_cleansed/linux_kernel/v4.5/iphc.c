static inline void iphc_uncompress_eui64_lladdr(struct in6_addr *ipaddr,\r\nconst void *lladdr)\r\n{\r\nipaddr->s6_addr[0] = 0xFE;\r\nipaddr->s6_addr[1] = 0x80;\r\nmemcpy(&ipaddr->s6_addr[8], lladdr, EUI64_ADDR_LEN);\r\nipaddr->s6_addr[8] ^= 0x02;\r\n}\r\nstatic inline void iphc_uncompress_802154_lladdr(struct in6_addr *ipaddr,\r\nconst void *lladdr)\r\n{\r\nconst struct ieee802154_addr *addr = lladdr;\r\nu8 eui64[EUI64_ADDR_LEN] = { };\r\nswitch (addr->mode) {\r\ncase IEEE802154_ADDR_LONG:\r\nieee802154_le64_to_be64(eui64, &addr->extended_addr);\r\niphc_uncompress_eui64_lladdr(ipaddr, eui64);\r\nbreak;\r\ncase IEEE802154_ADDR_SHORT:\r\nipaddr->s6_addr[0] = 0xFE;\r\nipaddr->s6_addr[1] = 0x80;\r\nipaddr->s6_addr[11] = 0xFF;\r\nipaddr->s6_addr[12] = 0xFE;\r\nieee802154_le16_to_be16(&ipaddr->s6_addr16[7],\r\n&addr->short_addr);\r\nbreak;\r\ndefault:\r\nWARN_ON_ONCE(1);\r\nbreak;\r\n}\r\n}\r\nstatic int uncompress_addr(struct sk_buff *skb, const struct net_device *dev,\r\nstruct in6_addr *ipaddr, u8 address_mode,\r\nconst void *lladdr)\r\n{\r\nbool fail;\r\nswitch (address_mode) {\r\ncase LOWPAN_IPHC_DAM_00:\r\nfail = lowpan_fetch_skb(skb, ipaddr->s6_addr, 16);\r\nbreak;\r\ncase LOWPAN_IPHC_SAM_01:\r\ncase LOWPAN_IPHC_DAM_01:\r\nipaddr->s6_addr[0] = 0xFE;\r\nipaddr->s6_addr[1] = 0x80;\r\nfail = lowpan_fetch_skb(skb, &ipaddr->s6_addr[8], 8);\r\nbreak;\r\ncase LOWPAN_IPHC_SAM_10:\r\ncase LOWPAN_IPHC_DAM_10:\r\nipaddr->s6_addr[0] = 0xFE;\r\nipaddr->s6_addr[1] = 0x80;\r\nipaddr->s6_addr[11] = 0xFF;\r\nipaddr->s6_addr[12] = 0xFE;\r\nfail = lowpan_fetch_skb(skb, &ipaddr->s6_addr[14], 2);\r\nbreak;\r\ncase LOWPAN_IPHC_SAM_11:\r\ncase LOWPAN_IPHC_DAM_11:\r\nfail = false;\r\nswitch (lowpan_priv(dev)->lltype) {\r\ncase LOWPAN_LLTYPE_IEEE802154:\r\niphc_uncompress_802154_lladdr(ipaddr, lladdr);\r\nbreak;\r\ndefault:\r\niphc_uncompress_eui64_lladdr(ipaddr, lladdr);\r\nbreak;\r\n}\r\nbreak;\r\ndefault:\r\npr_debug("Invalid address mode value: 0x%x\n", address_mode);\r\nreturn -EINVAL;\r\n}\r\nif (fail) {\r\npr_debug("Failed to fetch skb data\n");\r\nreturn -EIO;\r\n}\r\nraw_dump_inline(NULL, "Reconstructed ipv6 addr is",\r\nipaddr->s6_addr, 16);\r\nreturn 0;\r\n}\r\nstatic int uncompress_context_based_src_addr(struct sk_buff *skb,\r\nstruct in6_addr *ipaddr,\r\nu8 address_mode)\r\n{\r\nswitch (address_mode) {\r\ncase LOWPAN_IPHC_SAM_00:\r\nbreak;\r\ncase LOWPAN_IPHC_SAM_01:\r\ncase LOWPAN_IPHC_SAM_10:\r\ncase LOWPAN_IPHC_SAM_11:\r\nnetdev_warn(skb->dev, "SAM value 0x%x not supported\n",\r\naddress_mode);\r\nreturn -EINVAL;\r\ndefault:\r\npr_debug("Invalid sam value: 0x%x\n", address_mode);\r\nreturn -EINVAL;\r\n}\r\nraw_dump_inline(NULL,\r\n"Reconstructed context based ipv6 src addr is",\r\nipaddr->s6_addr, 16);\r\nreturn 0;\r\n}\r\nstatic int lowpan_uncompress_multicast_daddr(struct sk_buff *skb,\r\nstruct in6_addr *ipaddr,\r\nu8 address_mode)\r\n{\r\nbool fail;\r\nswitch (address_mode) {\r\ncase LOWPAN_IPHC_DAM_00:\r\nfail = lowpan_fetch_skb(skb, ipaddr->s6_addr, 16);\r\nbreak;\r\ncase LOWPAN_IPHC_DAM_01:\r\nipaddr->s6_addr[0] = 0xFF;\r\nfail = lowpan_fetch_skb(skb, &ipaddr->s6_addr[1], 1);\r\nfail |= lowpan_fetch_skb(skb, &ipaddr->s6_addr[11], 5);\r\nbreak;\r\ncase LOWPAN_IPHC_DAM_10:\r\nipaddr->s6_addr[0] = 0xFF;\r\nfail = lowpan_fetch_skb(skb, &ipaddr->s6_addr[1], 1);\r\nfail |= lowpan_fetch_skb(skb, &ipaddr->s6_addr[13], 3);\r\nbreak;\r\ncase LOWPAN_IPHC_DAM_11:\r\nipaddr->s6_addr[0] = 0xFF;\r\nipaddr->s6_addr[1] = 0x02;\r\nfail = lowpan_fetch_skb(skb, &ipaddr->s6_addr[15], 1);\r\nbreak;\r\ndefault:\r\npr_debug("DAM value has a wrong value: 0x%x\n", address_mode);\r\nreturn -EINVAL;\r\n}\r\nif (fail) {\r\npr_debug("Failed to fetch skb data\n");\r\nreturn -EIO;\r\n}\r\nraw_dump_inline(NULL, "Reconstructed ipv6 multicast addr is",\r\nipaddr->s6_addr, 16);\r\nreturn 0;\r\n}\r\nstatic inline void lowpan_iphc_tf_set_ecn(struct ipv6hdr *hdr, const u8 *tf)\r\n{\r\nu8 ecn = tf[0] & 0xc0;\r\nhdr->flow_lbl[0] |= (ecn >> 2);\r\n}\r\nstatic inline void lowpan_iphc_tf_set_dscp(struct ipv6hdr *hdr, const u8 *tf)\r\n{\r\nu8 dscp = tf[0] & 0x3f;\r\nhdr->priority |= ((dscp & 0x3c) >> 2);\r\nhdr->flow_lbl[0] |= ((dscp & 0x03) << 6);\r\n}\r\nstatic inline void lowpan_iphc_tf_set_lbl(struct ipv6hdr *hdr, const u8 *lbl)\r\n{\r\nhdr->flow_lbl[0] |= lbl[0] & 0x0f;\r\nmemcpy(&hdr->flow_lbl[1], &lbl[1], 2);\r\n}\r\nstatic int lowpan_iphc_tf_decompress(struct sk_buff *skb, struct ipv6hdr *hdr,\r\nu8 val)\r\n{\r\nu8 tf[4];\r\nswitch (val) {\r\ncase LOWPAN_IPHC_TF_00:\r\nif (lowpan_fetch_skb(skb, tf, 4))\r\nreturn -EINVAL;\r\nlowpan_iphc_tf_set_ecn(hdr, tf);\r\nlowpan_iphc_tf_set_dscp(hdr, tf);\r\nlowpan_iphc_tf_set_lbl(hdr, &tf[1]);\r\nbreak;\r\ncase LOWPAN_IPHC_TF_01:\r\nif (lowpan_fetch_skb(skb, tf, 3))\r\nreturn -EINVAL;\r\nlowpan_iphc_tf_set_ecn(hdr, tf);\r\nlowpan_iphc_tf_set_lbl(hdr, &tf[0]);\r\nbreak;\r\ncase LOWPAN_IPHC_TF_10:\r\nif (lowpan_fetch_skb(skb, tf, 1))\r\nreturn -EINVAL;\r\nlowpan_iphc_tf_set_ecn(hdr, tf);\r\nlowpan_iphc_tf_set_dscp(hdr, tf);\r\nbreak;\r\ncase LOWPAN_IPHC_TF_11:\r\nbreak;\r\ndefault:\r\nWARN_ON_ONCE(1);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nint lowpan_header_decompress(struct sk_buff *skb, const struct net_device *dev,\r\nconst void *daddr, const void *saddr)\r\n{\r\nstruct ipv6hdr hdr = {};\r\nu8 iphc0, iphc1;\r\nint err;\r\nraw_dump_table(__func__, "raw skb data dump uncompressed",\r\nskb->data, skb->len);\r\nif (lowpan_fetch_skb(skb, &iphc0, sizeof(iphc0)) ||\r\nlowpan_fetch_skb(skb, &iphc1, sizeof(iphc1)))\r\nreturn -EINVAL;\r\nif (iphc1 & LOWPAN_IPHC_CID)\r\nreturn -ENOTSUPP;\r\nhdr.version = 6;\r\nerr = lowpan_iphc_tf_decompress(skb, &hdr,\r\niphc0 & LOWPAN_IPHC_TF_MASK);\r\nif (err < 0)\r\nreturn err;\r\nif (!(iphc0 & LOWPAN_IPHC_NH)) {\r\nif (lowpan_fetch_skb(skb, &hdr.nexthdr, sizeof(hdr.nexthdr)))\r\nreturn -EINVAL;\r\npr_debug("NH flag is set, next header carried inline: %02x\n",\r\nhdr.nexthdr);\r\n}\r\nif ((iphc0 & LOWPAN_IPHC_HLIM_MASK) != LOWPAN_IPHC_HLIM_00) {\r\nhdr.hop_limit = lowpan_ttl_values[iphc0 & LOWPAN_IPHC_HLIM_MASK];\r\n} else {\r\nif (lowpan_fetch_skb(skb, &hdr.hop_limit,\r\nsizeof(hdr.hop_limit)))\r\nreturn -EINVAL;\r\n}\r\nif (iphc1 & LOWPAN_IPHC_SAC) {\r\npr_debug("SAC bit is set. Handle context based source address.\n");\r\nerr = uncompress_context_based_src_addr(skb, &hdr.saddr,\r\niphc1 & LOWPAN_IPHC_SAM_MASK);\r\n} else {\r\npr_debug("source address stateless compression\n");\r\nerr = uncompress_addr(skb, dev, &hdr.saddr,\r\niphc1 & LOWPAN_IPHC_SAM_MASK, saddr);\r\n}\r\nif (err)\r\nreturn -EINVAL;\r\nif (iphc1 & LOWPAN_IPHC_M) {\r\nif (iphc1 & LOWPAN_IPHC_DAC) {\r\npr_debug("dest: context-based mcast compression\n");\r\n} else {\r\nerr = lowpan_uncompress_multicast_daddr(skb, &hdr.daddr,\r\niphc1 & LOWPAN_IPHC_DAM_MASK);\r\nif (err)\r\nreturn -EINVAL;\r\n}\r\n} else {\r\nerr = uncompress_addr(skb, dev, &hdr.daddr,\r\niphc1 & LOWPAN_IPHC_DAM_MASK, daddr);\r\npr_debug("dest: stateless compression mode %d dest %pI6c\n",\r\niphc1 & LOWPAN_IPHC_DAM_MASK, &hdr.daddr);\r\nif (err)\r\nreturn -EINVAL;\r\n}\r\nif (iphc0 & LOWPAN_IPHC_NH) {\r\nerr = lowpan_nhc_do_uncompression(skb, dev, &hdr);\r\nif (err < 0)\r\nreturn err;\r\n} else {\r\nerr = skb_cow(skb, sizeof(hdr));\r\nif (unlikely(err))\r\nreturn err;\r\n}\r\nswitch (lowpan_priv(dev)->lltype) {\r\ncase LOWPAN_LLTYPE_IEEE802154:\r\nif (lowpan_802154_cb(skb)->d_size)\r\nhdr.payload_len = htons(lowpan_802154_cb(skb)->d_size -\r\nsizeof(struct ipv6hdr));\r\nelse\r\nhdr.payload_len = htons(skb->len);\r\nbreak;\r\ndefault:\r\nhdr.payload_len = htons(skb->len);\r\nbreak;\r\n}\r\npr_debug("skb headroom size = %d, data length = %d\n",\r\nskb_headroom(skb), skb->len);\r\npr_debug("IPv6 header dump:\n\tversion = %d\n\tlength = %d\n\t"\r\n"nexthdr = 0x%02x\n\thop_lim = %d\n\tdest = %pI6c\n",\r\nhdr.version, ntohs(hdr.payload_len), hdr.nexthdr,\r\nhdr.hop_limit, &hdr.daddr);\r\nskb_push(skb, sizeof(hdr));\r\nskb_reset_network_header(skb);\r\nskb_copy_to_linear_data(skb, &hdr, sizeof(hdr));\r\nraw_dump_table(__func__, "raw header dump", (u8 *)&hdr, sizeof(hdr));\r\nreturn 0;\r\n}\r\nstatic u8 lowpan_compress_addr_64(u8 **hc_ptr, const struct in6_addr *ipaddr,\r\nconst unsigned char *lladdr, bool sam)\r\n{\r\nu8 dam = LOWPAN_IPHC_DAM_00;\r\nif (is_addr_mac_addr_based(ipaddr, lladdr)) {\r\ndam = LOWPAN_IPHC_DAM_11;\r\npr_debug("address compression 0 bits\n");\r\n} else if (lowpan_is_iid_16_bit_compressable(ipaddr)) {\r\nlowpan_push_hc_data(hc_ptr, &ipaddr->s6_addr16[7], 2);\r\ndam = LOWPAN_IPHC_DAM_10;\r\nraw_dump_inline(NULL, "Compressed ipv6 addr is (16 bits)",\r\n*hc_ptr - 2, 2);\r\n} else {\r\nlowpan_push_hc_data(hc_ptr, &ipaddr->s6_addr16[4], 8);\r\ndam = LOWPAN_IPHC_DAM_01;\r\nraw_dump_inline(NULL, "Compressed ipv6 addr is (64 bits)",\r\n*hc_ptr - 8, 8);\r\n}\r\nif (sam)\r\nreturn lowpan_iphc_dam_to_sam_value[dam];\r\nelse\r\nreturn dam;\r\n}\r\nstatic inline u8 lowpan_iphc_get_tc(const struct ipv6hdr *hdr)\r\n{\r\nu8 dscp, ecn;\r\ndscp = (hdr->priority << 2) | ((hdr->flow_lbl[0] & 0xc0) >> 6);\r\necn = (hdr->flow_lbl[0] & 0x30);\r\npr_debug("ecn 0x%02x dscp 0x%02x\n", ecn >> 4, dscp);\r\nreturn (ecn << 2) | dscp;\r\n}\r\nstatic inline bool lowpan_iphc_is_flow_lbl_zero(const struct ipv6hdr *hdr)\r\n{\r\nreturn ((!(hdr->flow_lbl[0] & 0x0f)) &&\r\n!hdr->flow_lbl[1] && !hdr->flow_lbl[2]);\r\n}\r\nstatic u8 lowpan_iphc_tf_compress(u8 **hc_ptr, const struct ipv6hdr *hdr)\r\n{\r\nu8 tc = lowpan_iphc_get_tc(hdr), tf[4], val;\r\npr_debug("tc 0x%02x\n", tc);\r\nif (lowpan_iphc_is_flow_lbl_zero(hdr)) {\r\nif (!tc) {\r\nval = LOWPAN_IPHC_TF_11;\r\n} else {\r\nlowpan_push_hc_data(hc_ptr, &tc, sizeof(tc));\r\nval = LOWPAN_IPHC_TF_10;\r\n}\r\n} else {\r\nif (!(tc & 0x3f)) {\r\nmemcpy(&tf[0], &hdr->flow_lbl[0], 3);\r\ntf[0] &= ~0xf0;\r\ntf[0] |= (tc & 0xc0);\r\nlowpan_push_hc_data(hc_ptr, tf, 3);\r\nval = LOWPAN_IPHC_TF_01;\r\n} else {\r\nmemcpy(&tf[0], &tc, sizeof(tc));\r\nmemcpy(&tf[1], &hdr->flow_lbl[0], 3);\r\ntf[1] &= ~0xf0;\r\nlowpan_push_hc_data(hc_ptr, tf, 4);\r\nval = LOWPAN_IPHC_TF_00;\r\n}\r\n}\r\nreturn val;\r\n}\r\nstatic u8 lowpan_iphc_mcast_addr_compress(u8 **hc_ptr,\r\nconst struct in6_addr *ipaddr)\r\n{\r\nu8 val;\r\nif (lowpan_is_mcast_addr_compressable8(ipaddr)) {\r\npr_debug("compressed to 1 octet\n");\r\nlowpan_push_hc_data(hc_ptr, &ipaddr->s6_addr[15], 1);\r\nval = LOWPAN_IPHC_DAM_11;\r\n} else if (lowpan_is_mcast_addr_compressable32(ipaddr)) {\r\npr_debug("compressed to 4 octets\n");\r\nlowpan_push_hc_data(hc_ptr, &ipaddr->s6_addr[1], 1);\r\nlowpan_push_hc_data(hc_ptr, &ipaddr->s6_addr[13], 3);\r\nval = LOWPAN_IPHC_DAM_10;\r\n} else if (lowpan_is_mcast_addr_compressable48(ipaddr)) {\r\npr_debug("compressed to 6 octets\n");\r\nlowpan_push_hc_data(hc_ptr, &ipaddr->s6_addr[1], 1);\r\nlowpan_push_hc_data(hc_ptr, &ipaddr->s6_addr[11], 5);\r\nval = LOWPAN_IPHC_DAM_01;\r\n} else {\r\npr_debug("using full address\n");\r\nlowpan_push_hc_data(hc_ptr, ipaddr->s6_addr, 16);\r\nval = LOWPAN_IPHC_DAM_00;\r\n}\r\nreturn val;\r\n}\r\nint lowpan_header_compress(struct sk_buff *skb, const struct net_device *dev,\r\nconst void *daddr, const void *saddr)\r\n{\r\nu8 iphc0, iphc1, *hc_ptr;\r\nstruct ipv6hdr *hdr;\r\nu8 head[LOWPAN_IPHC_MAX_HC_BUF_LEN] = {};\r\nint ret, addr_type;\r\nif (skb->protocol != htons(ETH_P_IPV6))\r\nreturn -EINVAL;\r\nhdr = ipv6_hdr(skb);\r\nhc_ptr = head + 2;\r\npr_debug("IPv6 header dump:\n\tversion = %d\n\tlength = %d\n"\r\n"\tnexthdr = 0x%02x\n\thop_lim = %d\n\tdest = %pI6c\n",\r\nhdr->version, ntohs(hdr->payload_len), hdr->nexthdr,\r\nhdr->hop_limit, &hdr->daddr);\r\nraw_dump_table(__func__, "raw skb network header dump",\r\nskb_network_header(skb), sizeof(struct ipv6hdr));\r\niphc0 = LOWPAN_DISPATCH_IPHC;\r\niphc1 = 0;\r\nraw_dump_inline(__func__, "saddr", saddr, EUI64_ADDR_LEN);\r\nraw_dump_inline(__func__, "daddr", daddr, EUI64_ADDR_LEN);\r\nraw_dump_table(__func__, "sending raw skb network uncompressed packet",\r\nskb->data, skb->len);\r\niphc0 |= lowpan_iphc_tf_compress(&hc_ptr, hdr);\r\nret = lowpan_nhc_check_compression(skb, hdr, &hc_ptr);\r\nif (ret == -ENOENT)\r\nlowpan_push_hc_data(&hc_ptr, &hdr->nexthdr,\r\nsizeof(hdr->nexthdr));\r\nelse\r\niphc0 |= LOWPAN_IPHC_NH;\r\nswitch (hdr->hop_limit) {\r\ncase 1:\r\niphc0 |= LOWPAN_IPHC_HLIM_01;\r\nbreak;\r\ncase 64:\r\niphc0 |= LOWPAN_IPHC_HLIM_10;\r\nbreak;\r\ncase 255:\r\niphc0 |= LOWPAN_IPHC_HLIM_11;\r\nbreak;\r\ndefault:\r\nlowpan_push_hc_data(&hc_ptr, &hdr->hop_limit,\r\nsizeof(hdr->hop_limit));\r\n}\r\naddr_type = ipv6_addr_type(&hdr->saddr);\r\nif (addr_type == IPV6_ADDR_ANY) {\r\npr_debug("source address is unspecified, setting SAC\n");\r\niphc1 |= LOWPAN_IPHC_SAC;\r\n} else {\r\nif (addr_type & IPV6_ADDR_LINKLOCAL) {\r\niphc1 |= lowpan_compress_addr_64(&hc_ptr, &hdr->saddr,\r\nsaddr, true);\r\npr_debug("source address unicast link-local %pI6c iphc1 0x%02x\n",\r\n&hdr->saddr, iphc1);\r\n} else {\r\npr_debug("send the full source address\n");\r\nlowpan_push_hc_data(&hc_ptr, hdr->saddr.s6_addr, 16);\r\n}\r\n}\r\naddr_type = ipv6_addr_type(&hdr->daddr);\r\nif (addr_type & IPV6_ADDR_MULTICAST) {\r\npr_debug("destination address is multicast: ");\r\niphc1 |= LOWPAN_IPHC_M;\r\niphc1 |= lowpan_iphc_mcast_addr_compress(&hc_ptr, &hdr->daddr);\r\n} else {\r\nif (addr_type & IPV6_ADDR_LINKLOCAL) {\r\niphc1 |= lowpan_compress_addr_64(&hc_ptr, &hdr->daddr,\r\ndaddr, false);\r\npr_debug("dest address unicast link-local %pI6c "\r\n"iphc1 0x%02x\n", &hdr->daddr, iphc1);\r\n} else {\r\npr_debug("dest address unicast %pI6c\n", &hdr->daddr);\r\nlowpan_push_hc_data(&hc_ptr, hdr->daddr.s6_addr, 16);\r\n}\r\n}\r\nif (iphc0 & LOWPAN_IPHC_NH) {\r\nret = lowpan_nhc_do_compression(skb, hdr, &hc_ptr);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nhead[0] = iphc0;\r\nhead[1] = iphc1;\r\nskb_pull(skb, sizeof(struct ipv6hdr));\r\nskb_reset_transport_header(skb);\r\nmemcpy(skb_push(skb, hc_ptr - head), head, hc_ptr - head);\r\nskb_reset_network_header(skb);\r\npr_debug("header len %d skb %u\n", (int)(hc_ptr - head), skb->len);\r\nraw_dump_table(__func__, "raw skb data dump compressed",\r\nskb->data, skb->len);\r\nreturn 0;\r\n}
