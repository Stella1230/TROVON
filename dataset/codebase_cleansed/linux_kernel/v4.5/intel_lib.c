static inline bool cpu_signatures_match(unsigned int s1, unsigned int p1,\r\nunsigned int s2, unsigned int p2)\r\n{\r\nif (s1 != s2)\r\nreturn false;\r\nif (!p1 && !p2)\r\nreturn true;\r\nreturn p1 & p2;\r\n}\r\nint microcode_sanity_check(void *mc, int print_err)\r\n{\r\nunsigned long total_size, data_size, ext_table_size;\r\nstruct microcode_header_intel *mc_header = mc;\r\nstruct extended_sigtable *ext_header = NULL;\r\nint sum, orig_sum, ext_sigcount = 0, i;\r\nstruct extended_signature *ext_sig;\r\ntotal_size = get_totalsize(mc_header);\r\ndata_size = get_datasize(mc_header);\r\nif (data_size + MC_HEADER_SIZE > total_size) {\r\nif (print_err)\r\npr_err("error! Bad data size in microcode data file\n");\r\nreturn -EINVAL;\r\n}\r\nif (mc_header->ldrver != 1 || mc_header->hdrver != 1) {\r\nif (print_err)\r\npr_err("error! Unknown microcode update format\n");\r\nreturn -EINVAL;\r\n}\r\next_table_size = total_size - (MC_HEADER_SIZE + data_size);\r\nif (ext_table_size) {\r\nif ((ext_table_size < EXT_HEADER_SIZE)\r\n|| ((ext_table_size - EXT_HEADER_SIZE) % EXT_SIGNATURE_SIZE)) {\r\nif (print_err)\r\npr_err("error! Small exttable size in microcode data file\n");\r\nreturn -EINVAL;\r\n}\r\next_header = mc + MC_HEADER_SIZE + data_size;\r\nif (ext_table_size != exttable_size(ext_header)) {\r\nif (print_err)\r\npr_err("error! Bad exttable size in microcode data file\n");\r\nreturn -EFAULT;\r\n}\r\next_sigcount = ext_header->count;\r\n}\r\nif (ext_table_size) {\r\nint ext_table_sum = 0;\r\nint *ext_tablep = (int *)ext_header;\r\ni = ext_table_size / DWSIZE;\r\nwhile (i--)\r\next_table_sum += ext_tablep[i];\r\nif (ext_table_sum) {\r\nif (print_err)\r\npr_warn("aborting, bad extended signature table checksum\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\norig_sum = 0;\r\ni = (MC_HEADER_SIZE + data_size) / DWSIZE;\r\nwhile (i--)\r\norig_sum += ((int *)mc)[i];\r\nif (orig_sum) {\r\nif (print_err)\r\npr_err("aborting, bad checksum\n");\r\nreturn -EINVAL;\r\n}\r\nif (!ext_table_size)\r\nreturn 0;\r\nfor (i = 0; i < ext_sigcount; i++) {\r\next_sig = (void *)ext_header + EXT_HEADER_SIZE +\r\nEXT_SIGNATURE_SIZE * i;\r\nsum = orig_sum\r\n- (mc_header->sig + mc_header->pf + mc_header->cksum)\r\n+ (ext_sig->sig + ext_sig->pf + ext_sig->cksum);\r\nif (sum) {\r\nif (print_err)\r\npr_err("aborting, bad checksum\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nint find_matching_signature(void *mc, unsigned int csig, int cpf)\r\n{\r\nstruct microcode_header_intel *mc_hdr = mc;\r\nstruct extended_sigtable *ext_hdr;\r\nstruct extended_signature *ext_sig;\r\nint i;\r\nif (cpu_signatures_match(csig, cpf, mc_hdr->sig, mc_hdr->pf))\r\nreturn 1;\r\nif (get_totalsize(mc_hdr) <= get_datasize(mc_hdr) + MC_HEADER_SIZE)\r\nreturn 0;\r\next_hdr = mc + get_datasize(mc_hdr) + MC_HEADER_SIZE;\r\next_sig = (void *)ext_hdr + EXT_HEADER_SIZE;\r\nfor (i = 0; i < ext_hdr->count; i++) {\r\nif (cpu_signatures_match(csig, cpf, ext_sig->sig, ext_sig->pf))\r\nreturn 1;\r\next_sig++;\r\n}\r\nreturn 0;\r\n}\r\nint has_newer_microcode(void *mc, unsigned int csig, int cpf, int new_rev)\r\n{\r\nstruct microcode_header_intel *mc_hdr = mc;\r\nif (mc_hdr->rev <= new_rev)\r\nreturn 0;\r\nreturn find_matching_signature(mc, csig, cpf);\r\n}
