static inline void bictcp_reset(struct bictcp *ca)\r\n{\r\nca->cnt = 0;\r\nca->last_max_cwnd = 0;\r\nca->last_cwnd = 0;\r\nca->last_time = 0;\r\nca->epoch_start = 0;\r\nca->delayed_ack = 2 << ACK_RATIO_SHIFT;\r\n}\r\nstatic void bictcp_init(struct sock *sk)\r\n{\r\nstruct bictcp *ca = inet_csk_ca(sk);\r\nbictcp_reset(ca);\r\nca->loss_cwnd = 0;\r\nif (initial_ssthresh)\r\ntcp_sk(sk)->snd_ssthresh = initial_ssthresh;\r\n}\r\nstatic inline void bictcp_update(struct bictcp *ca, u32 cwnd)\r\n{\r\nif (ca->last_cwnd == cwnd &&\r\n(s32)(tcp_time_stamp - ca->last_time) <= HZ / 32)\r\nreturn;\r\nca->last_cwnd = cwnd;\r\nca->last_time = tcp_time_stamp;\r\nif (ca->epoch_start == 0)\r\nca->epoch_start = tcp_time_stamp;\r\nif (cwnd <= low_window) {\r\nca->cnt = cwnd;\r\nreturn;\r\n}\r\nif (cwnd < ca->last_max_cwnd) {\r\n__u32 dist = (ca->last_max_cwnd - cwnd)\r\n/ BICTCP_B;\r\nif (dist > max_increment)\r\nca->cnt = cwnd / max_increment;\r\nelse if (dist <= 1U)\r\nca->cnt = (cwnd * smooth_part) / BICTCP_B;\r\nelse\r\nca->cnt = cwnd / dist;\r\n} else {\r\nif (cwnd < ca->last_max_cwnd + BICTCP_B)\r\nca->cnt = (cwnd * smooth_part) / BICTCP_B;\r\nelse if (cwnd < ca->last_max_cwnd + max_increment*(BICTCP_B-1))\r\nca->cnt = (cwnd * (BICTCP_B-1))\r\n/ (cwnd - ca->last_max_cwnd);\r\nelse\r\nca->cnt = cwnd / max_increment;\r\n}\r\nif (ca->last_max_cwnd == 0) {\r\nif (ca->cnt > 20)\r\nca->cnt = 20;\r\n}\r\nca->cnt = (ca->cnt << ACK_RATIO_SHIFT) / ca->delayed_ack;\r\nif (ca->cnt == 0)\r\nca->cnt = 1;\r\n}\r\nstatic void bictcp_cong_avoid(struct sock *sk, u32 ack, u32 acked)\r\n{\r\nstruct tcp_sock *tp = tcp_sk(sk);\r\nstruct bictcp *ca = inet_csk_ca(sk);\r\nif (!tcp_is_cwnd_limited(sk))\r\nreturn;\r\nif (tcp_in_slow_start(tp))\r\ntcp_slow_start(tp, acked);\r\nelse {\r\nbictcp_update(ca, tp->snd_cwnd);\r\ntcp_cong_avoid_ai(tp, ca->cnt, 1);\r\n}\r\n}\r\nstatic u32 bictcp_recalc_ssthresh(struct sock *sk)\r\n{\r\nconst struct tcp_sock *tp = tcp_sk(sk);\r\nstruct bictcp *ca = inet_csk_ca(sk);\r\nca->epoch_start = 0;\r\nif (tp->snd_cwnd < ca->last_max_cwnd && fast_convergence)\r\nca->last_max_cwnd = (tp->snd_cwnd * (BICTCP_BETA_SCALE + beta))\r\n/ (2 * BICTCP_BETA_SCALE);\r\nelse\r\nca->last_max_cwnd = tp->snd_cwnd;\r\nca->loss_cwnd = tp->snd_cwnd;\r\nif (tp->snd_cwnd <= low_window)\r\nreturn max(tp->snd_cwnd >> 1U, 2U);\r\nelse\r\nreturn max((tp->snd_cwnd * beta) / BICTCP_BETA_SCALE, 2U);\r\n}\r\nstatic u32 bictcp_undo_cwnd(struct sock *sk)\r\n{\r\nconst struct tcp_sock *tp = tcp_sk(sk);\r\nconst struct bictcp *ca = inet_csk_ca(sk);\r\nreturn max(tp->snd_cwnd, ca->loss_cwnd);\r\n}\r\nstatic void bictcp_state(struct sock *sk, u8 new_state)\r\n{\r\nif (new_state == TCP_CA_Loss)\r\nbictcp_reset(inet_csk_ca(sk));\r\n}\r\nstatic void bictcp_acked(struct sock *sk, u32 cnt, s32 rtt)\r\n{\r\nconst struct inet_connection_sock *icsk = inet_csk(sk);\r\nif (icsk->icsk_ca_state == TCP_CA_Open) {\r\nstruct bictcp *ca = inet_csk_ca(sk);\r\ncnt -= ca->delayed_ack >> ACK_RATIO_SHIFT;\r\nca->delayed_ack += cnt;\r\n}\r\n}\r\nstatic int __init bictcp_register(void)\r\n{\r\nBUILD_BUG_ON(sizeof(struct bictcp) > ICSK_CA_PRIV_SIZE);\r\nreturn tcp_register_congestion_control(&bictcp);\r\n}\r\nstatic void __exit bictcp_unregister(void)\r\n{\r\ntcp_unregister_congestion_control(&bictcp);\r\n}
