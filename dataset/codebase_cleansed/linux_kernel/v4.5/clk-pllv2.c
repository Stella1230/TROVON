static unsigned long __clk_pllv2_recalc_rate(unsigned long parent_rate,\r\nu32 dp_ctl, u32 dp_op, u32 dp_mfd, u32 dp_mfn)\r\n{\r\nlong mfi, mfn, mfd, pdf, ref_clk;\r\nunsigned long dbl;\r\nu64 temp;\r\ndbl = dp_ctl & MXC_PLL_DP_CTL_DPDCK0_2_EN;\r\npdf = dp_op & MXC_PLL_DP_OP_PDF_MASK;\r\nmfi = (dp_op & MXC_PLL_DP_OP_MFI_MASK) >> MXC_PLL_DP_OP_MFI_OFFSET;\r\nmfi = (mfi <= 5) ? 5 : mfi;\r\nmfd = dp_mfd & MXC_PLL_DP_MFD_MASK;\r\nmfn = dp_mfn & MXC_PLL_DP_MFN_MASK;\r\nmfn = sign_extend32(mfn, 26);\r\nref_clk = 2 * parent_rate;\r\nif (dbl != 0)\r\nref_clk *= 2;\r\nref_clk /= (pdf + 1);\r\ntemp = (u64) ref_clk * abs(mfn);\r\ndo_div(temp, mfd + 1);\r\nif (mfn < 0)\r\ntemp = (ref_clk * mfi) - temp;\r\nelse\r\ntemp = (ref_clk * mfi) + temp;\r\nreturn temp;\r\n}\r\nstatic unsigned long clk_pllv2_recalc_rate(struct clk_hw *hw,\r\nunsigned long parent_rate)\r\n{\r\nu32 dp_op, dp_mfd, dp_mfn, dp_ctl;\r\nvoid __iomem *pllbase;\r\nstruct clk_pllv2 *pll = to_clk_pllv2(hw);\r\npllbase = pll->base;\r\ndp_ctl = __raw_readl(pllbase + MXC_PLL_DP_CTL);\r\ndp_op = __raw_readl(pllbase + MXC_PLL_DP_OP);\r\ndp_mfd = __raw_readl(pllbase + MXC_PLL_DP_MFD);\r\ndp_mfn = __raw_readl(pllbase + MXC_PLL_DP_MFN);\r\nreturn __clk_pllv2_recalc_rate(parent_rate, dp_ctl, dp_op, dp_mfd, dp_mfn);\r\n}\r\nstatic int __clk_pllv2_set_rate(unsigned long rate, unsigned long parent_rate,\r\nu32 *dp_op, u32 *dp_mfd, u32 *dp_mfn)\r\n{\r\nu32 reg;\r\nlong mfi, pdf, mfn, mfd = 999999;\r\nu64 temp64;\r\nunsigned long quad_parent_rate;\r\nquad_parent_rate = 4 * parent_rate;\r\npdf = mfi = -1;\r\nwhile (++pdf < 16 && mfi < 5)\r\nmfi = rate * (pdf+1) / quad_parent_rate;\r\nif (mfi > 15)\r\nreturn -EINVAL;\r\npdf--;\r\ntemp64 = rate * (pdf + 1) - quad_parent_rate * mfi;\r\ndo_div(temp64, quad_parent_rate / 1000000);\r\nmfn = (long)temp64;\r\nreg = mfi << 4 | pdf;\r\n*dp_op = reg;\r\n*dp_mfd = mfd;\r\n*dp_mfn = mfn;\r\nreturn 0;\r\n}\r\nstatic int clk_pllv2_set_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long parent_rate)\r\n{\r\nstruct clk_pllv2 *pll = to_clk_pllv2(hw);\r\nvoid __iomem *pllbase;\r\nu32 dp_ctl, dp_op, dp_mfd, dp_mfn;\r\nint ret;\r\npllbase = pll->base;\r\nret = __clk_pllv2_set_rate(rate, parent_rate, &dp_op, &dp_mfd, &dp_mfn);\r\nif (ret)\r\nreturn ret;\r\ndp_ctl = __raw_readl(pllbase + MXC_PLL_DP_CTL);\r\n__raw_writel(dp_ctl | 0x1000L, pllbase + MXC_PLL_DP_CTL);\r\n__raw_writel(dp_op, pllbase + MXC_PLL_DP_OP);\r\n__raw_writel(dp_mfd, pllbase + MXC_PLL_DP_MFD);\r\n__raw_writel(dp_mfn, pllbase + MXC_PLL_DP_MFN);\r\nreturn 0;\r\n}\r\nstatic long clk_pllv2_round_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long *prate)\r\n{\r\nu32 dp_op, dp_mfd, dp_mfn;\r\n__clk_pllv2_set_rate(rate, *prate, &dp_op, &dp_mfd, &dp_mfn);\r\nreturn __clk_pllv2_recalc_rate(*prate, MXC_PLL_DP_CTL_DPDCK0_2_EN,\r\ndp_op, dp_mfd, dp_mfn);\r\n}\r\nstatic int clk_pllv2_prepare(struct clk_hw *hw)\r\n{\r\nstruct clk_pllv2 *pll = to_clk_pllv2(hw);\r\nu32 reg;\r\nvoid __iomem *pllbase;\r\nint i = 0;\r\npllbase = pll->base;\r\nreg = __raw_readl(pllbase + MXC_PLL_DP_CTL) | MXC_PLL_DP_CTL_UPEN;\r\n__raw_writel(reg, pllbase + MXC_PLL_DP_CTL);\r\ndo {\r\nreg = __raw_readl(pllbase + MXC_PLL_DP_CTL);\r\nif (reg & MXC_PLL_DP_CTL_LRF)\r\nbreak;\r\nudelay(1);\r\n} while (++i < MAX_DPLL_WAIT_TRIES);\r\nif (i == MAX_DPLL_WAIT_TRIES) {\r\npr_err("MX5: pll locking failed\n");\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic void clk_pllv2_unprepare(struct clk_hw *hw)\r\n{\r\nstruct clk_pllv2 *pll = to_clk_pllv2(hw);\r\nu32 reg;\r\nvoid __iomem *pllbase;\r\npllbase = pll->base;\r\nreg = __raw_readl(pllbase + MXC_PLL_DP_CTL) & ~MXC_PLL_DP_CTL_UPEN;\r\n__raw_writel(reg, pllbase + MXC_PLL_DP_CTL);\r\n}\r\nstruct clk *imx_clk_pllv2(const char *name, const char *parent,\r\nvoid __iomem *base)\r\n{\r\nstruct clk_pllv2 *pll;\r\nstruct clk *clk;\r\nstruct clk_init_data init;\r\npll = kzalloc(sizeof(*pll), GFP_KERNEL);\r\nif (!pll)\r\nreturn ERR_PTR(-ENOMEM);\r\npll->base = base;\r\ninit.name = name;\r\ninit.ops = &clk_pllv2_ops;\r\ninit.flags = 0;\r\ninit.parent_names = &parent;\r\ninit.num_parents = 1;\r\npll->hw.init = &init;\r\nclk = clk_register(NULL, &pll->hw);\r\nif (IS_ERR(clk))\r\nkfree(pll);\r\nreturn clk;\r\n}
