static inline\r\nvoid null_encode_sec_part(struct lustre_msg *msg, enum lustre_sec_part sp)\r\n{\r\nmsg->lm_secflvr |= (((__u32) sp) & 0xFF) << 24;\r\n}\r\nstatic inline\r\nenum lustre_sec_part null_decode_sec_part(struct lustre_msg *msg)\r\n{\r\nreturn (msg->lm_secflvr >> 24) & 0xFF;\r\n}\r\nstatic int null_ctx_refresh(struct ptlrpc_cli_ctx *ctx)\r\n{\r\nLBUG();\r\nreturn 0;\r\n}\r\nstatic\r\nint null_ctx_sign(struct ptlrpc_cli_ctx *ctx, struct ptlrpc_request *req)\r\n{\r\nreq->rq_reqbuf->lm_secflvr = SPTLRPC_FLVR_NULL;\r\nif (!req->rq_import->imp_dlm_fake) {\r\nstruct obd_device *obd = req->rq_import->imp_obd;\r\nnull_encode_sec_part(req->rq_reqbuf,\r\nobd->u.cli.cl_sp_me);\r\n}\r\nreq->rq_reqdata_len = req->rq_reqlen;\r\nreturn 0;\r\n}\r\nstatic\r\nint null_ctx_verify(struct ptlrpc_cli_ctx *ctx, struct ptlrpc_request *req)\r\n{\r\n__u32 cksums, cksumc;\r\nLASSERT(req->rq_repdata);\r\nreq->rq_repmsg = req->rq_repdata;\r\nreq->rq_replen = req->rq_repdata_len;\r\nif (req->rq_early) {\r\ncksums = lustre_msg_get_cksum(req->rq_repdata);\r\ncksumc = lustre_msg_calc_cksum(req->rq_repmsg);\r\nif (cksumc != cksums) {\r\nCDEBUG(D_SEC,\r\n"early reply checksum mismatch: %08x != %08x\n",\r\ncksumc, cksums);\r\nreturn -EINVAL;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic\r\nstruct ptlrpc_sec *null_create_sec(struct obd_import *imp,\r\nstruct ptlrpc_svc_ctx *svc_ctx,\r\nstruct sptlrpc_flavor *sf)\r\n{\r\nLASSERT(SPTLRPC_FLVR_POLICY(sf->sf_rpc) == SPTLRPC_POLICY_NULL);\r\nsptlrpc_policy_put(&null_policy);\r\nreturn &null_sec;\r\n}\r\nstatic\r\nvoid null_destroy_sec(struct ptlrpc_sec *sec)\r\n{\r\nLASSERT(sec == &null_sec);\r\n}\r\nstatic\r\nstruct ptlrpc_cli_ctx *null_lookup_ctx(struct ptlrpc_sec *sec,\r\nstruct vfs_cred *vcred,\r\nint create, int remove_dead)\r\n{\r\natomic_inc(&null_cli_ctx.cc_refcount);\r\nreturn &null_cli_ctx;\r\n}\r\nstatic\r\nint null_flush_ctx_cache(struct ptlrpc_sec *sec,\r\nuid_t uid,\r\nint grace, int force)\r\n{\r\nreturn 0;\r\n}\r\nstatic\r\nint null_alloc_reqbuf(struct ptlrpc_sec *sec,\r\nstruct ptlrpc_request *req,\r\nint msgsize)\r\n{\r\nif (!req->rq_reqbuf) {\r\nint alloc_size = size_roundup_power2(msgsize);\r\nLASSERT(!req->rq_pool);\r\nreq->rq_reqbuf = libcfs_kvzalloc(alloc_size, GFP_NOFS);\r\nif (!req->rq_reqbuf)\r\nreturn -ENOMEM;\r\nreq->rq_reqbuf_len = alloc_size;\r\n} else {\r\nLASSERT(req->rq_pool);\r\nLASSERT(req->rq_reqbuf_len >= msgsize);\r\nmemset(req->rq_reqbuf, 0, msgsize);\r\n}\r\nreq->rq_reqmsg = req->rq_reqbuf;\r\nreturn 0;\r\n}\r\nstatic\r\nvoid null_free_reqbuf(struct ptlrpc_sec *sec,\r\nstruct ptlrpc_request *req)\r\n{\r\nif (!req->rq_pool) {\r\nLASSERTF(req->rq_reqmsg == req->rq_reqbuf,\r\n"req %p: reqmsg %p is not reqbuf %p in null sec\n",\r\nreq, req->rq_reqmsg, req->rq_reqbuf);\r\nLASSERTF(req->rq_reqbuf_len >= req->rq_reqlen,\r\n"req %p: reqlen %d should smaller than buflen %d\n",\r\nreq, req->rq_reqlen, req->rq_reqbuf_len);\r\nkvfree(req->rq_reqbuf);\r\nreq->rq_reqbuf = NULL;\r\nreq->rq_reqbuf_len = 0;\r\n}\r\n}\r\nstatic\r\nint null_alloc_repbuf(struct ptlrpc_sec *sec,\r\nstruct ptlrpc_request *req,\r\nint msgsize)\r\n{\r\nmsgsize += lustre_msg_early_size();\r\nmsgsize = size_roundup_power2(msgsize);\r\nreq->rq_repbuf = libcfs_kvzalloc(msgsize, GFP_NOFS);\r\nif (!req->rq_repbuf)\r\nreturn -ENOMEM;\r\nreq->rq_repbuf_len = msgsize;\r\nreturn 0;\r\n}\r\nstatic\r\nvoid null_free_repbuf(struct ptlrpc_sec *sec,\r\nstruct ptlrpc_request *req)\r\n{\r\nLASSERT(req->rq_repbuf);\r\nkvfree(req->rq_repbuf);\r\nreq->rq_repbuf = NULL;\r\nreq->rq_repbuf_len = 0;\r\n}\r\nstatic\r\nint null_enlarge_reqbuf(struct ptlrpc_sec *sec,\r\nstruct ptlrpc_request *req,\r\nint segment, int newsize)\r\n{\r\nstruct lustre_msg *newbuf;\r\nstruct lustre_msg *oldbuf = req->rq_reqmsg;\r\nint oldsize, newmsg_size, alloc_size;\r\nLASSERT(req->rq_reqbuf);\r\nLASSERT(req->rq_reqbuf == req->rq_reqmsg);\r\nLASSERT(req->rq_reqbuf_len >= req->rq_reqlen);\r\nLASSERT(req->rq_reqlen == lustre_packed_msg_size(oldbuf));\r\noldsize = req->rq_reqbuf->lm_buflens[segment];\r\nreq->rq_reqbuf->lm_buflens[segment] = newsize;\r\nnewmsg_size = lustre_packed_msg_size(oldbuf);\r\nreq->rq_reqbuf->lm_buflens[segment] = oldsize;\r\nLASSERT(!req->rq_pool || req->rq_reqbuf_len >= newmsg_size);\r\nif (req->rq_reqbuf_len < newmsg_size) {\r\nalloc_size = size_roundup_power2(newmsg_size);\r\nnewbuf = libcfs_kvzalloc(alloc_size, GFP_NOFS);\r\nif (newbuf == NULL)\r\nreturn -ENOMEM;\r\nif (req->rq_import)\r\nspin_lock(&req->rq_import->imp_lock);\r\nmemcpy(newbuf, req->rq_reqbuf, req->rq_reqlen);\r\nkvfree(req->rq_reqbuf);\r\nreq->rq_reqbuf = req->rq_reqmsg = newbuf;\r\nreq->rq_reqbuf_len = alloc_size;\r\nif (req->rq_import)\r\nspin_unlock(&req->rq_import->imp_lock);\r\n}\r\n_sptlrpc_enlarge_msg_inplace(req->rq_reqmsg, segment, newsize);\r\nreq->rq_reqlen = newmsg_size;\r\nreturn 0;\r\n}\r\nstatic\r\nint null_accept(struct ptlrpc_request *req)\r\n{\r\nLASSERT(SPTLRPC_FLVR_POLICY(req->rq_flvr.sf_rpc) ==\r\nSPTLRPC_POLICY_NULL);\r\nif (req->rq_flvr.sf_rpc != SPTLRPC_FLVR_NULL) {\r\nCERROR("Invalid rpc flavor 0x%x\n", req->rq_flvr.sf_rpc);\r\nreturn SECSVC_DROP;\r\n}\r\nreq->rq_sp_from = null_decode_sec_part(req->rq_reqbuf);\r\nreq->rq_reqmsg = req->rq_reqbuf;\r\nreq->rq_reqlen = req->rq_reqdata_len;\r\nreq->rq_svc_ctx = &null_svc_ctx;\r\natomic_inc(&req->rq_svc_ctx->sc_refcount);\r\nreturn SECSVC_OK;\r\n}\r\nstatic\r\nint null_alloc_rs(struct ptlrpc_request *req, int msgsize)\r\n{\r\nstruct ptlrpc_reply_state *rs;\r\nint rs_size = sizeof(*rs) + msgsize;\r\nLASSERT(msgsize % 8 == 0);\r\nrs = req->rq_reply_state;\r\nif (rs) {\r\nLASSERT(rs->rs_size >= rs_size);\r\n} else {\r\nrs = libcfs_kvzalloc(rs_size, GFP_NOFS);\r\nif (rs == NULL)\r\nreturn -ENOMEM;\r\nrs->rs_size = rs_size;\r\n}\r\nrs->rs_svc_ctx = req->rq_svc_ctx;\r\natomic_inc(&req->rq_svc_ctx->sc_refcount);\r\nrs->rs_repbuf = (struct lustre_msg *) (rs + 1);\r\nrs->rs_repbuf_len = rs_size - sizeof(*rs);\r\nrs->rs_msg = rs->rs_repbuf;\r\nreq->rq_reply_state = rs;\r\nreturn 0;\r\n}\r\nstatic\r\nvoid null_free_rs(struct ptlrpc_reply_state *rs)\r\n{\r\nLASSERT_ATOMIC_GT(&rs->rs_svc_ctx->sc_refcount, 1);\r\natomic_dec(&rs->rs_svc_ctx->sc_refcount);\r\nif (!rs->rs_prealloc)\r\nkvfree(rs);\r\n}\r\nstatic\r\nint null_authorize(struct ptlrpc_request *req)\r\n{\r\nstruct ptlrpc_reply_state *rs = req->rq_reply_state;\r\nLASSERT(rs);\r\nrs->rs_repbuf->lm_secflvr = SPTLRPC_FLVR_NULL;\r\nrs->rs_repdata_len = req->rq_replen;\r\nif (likely(req->rq_packed_final)) {\r\nif (lustre_msghdr_get_flags(req->rq_reqmsg) & MSGHDR_AT_SUPPORT)\r\nreq->rq_reply_off = lustre_msg_early_size();\r\nelse\r\nreq->rq_reply_off = 0;\r\n} else {\r\n__u32 cksum;\r\ncksum = lustre_msg_calc_cksum(rs->rs_repbuf);\r\nlustre_msg_set_cksum(rs->rs_repbuf, cksum);\r\nreq->rq_reply_off = 0;\r\n}\r\nreturn 0;\r\n}\r\nstatic void null_init_internal(void)\r\n{\r\nstatic HLIST_HEAD(__list);\r\nnull_sec.ps_policy = &null_policy;\r\natomic_set(&null_sec.ps_refcount, 1);\r\nnull_sec.ps_id = -1;\r\nnull_sec.ps_import = NULL;\r\nnull_sec.ps_flvr.sf_rpc = SPTLRPC_FLVR_NULL;\r\nnull_sec.ps_flvr.sf_flags = 0;\r\nnull_sec.ps_part = LUSTRE_SP_ANY;\r\nnull_sec.ps_dying = 0;\r\nspin_lock_init(&null_sec.ps_lock);\r\natomic_set(&null_sec.ps_nctx, 1);\r\nINIT_LIST_HEAD(&null_sec.ps_gc_list);\r\nnull_sec.ps_gc_interval = 0;\r\nnull_sec.ps_gc_next = 0;\r\nhlist_add_head(&null_cli_ctx.cc_cache, &__list);\r\natomic_set(&null_cli_ctx.cc_refcount, 1);\r\nnull_cli_ctx.cc_sec = &null_sec;\r\nnull_cli_ctx.cc_ops = &null_ctx_ops;\r\nnull_cli_ctx.cc_expire = 0;\r\nnull_cli_ctx.cc_flags = PTLRPC_CTX_CACHED | PTLRPC_CTX_ETERNAL |\r\nPTLRPC_CTX_UPTODATE;\r\nnull_cli_ctx.cc_vcred.vc_uid = 0;\r\nspin_lock_init(&null_cli_ctx.cc_lock);\r\nINIT_LIST_HEAD(&null_cli_ctx.cc_req_list);\r\nINIT_LIST_HEAD(&null_cli_ctx.cc_gc_chain);\r\n}\r\nint sptlrpc_null_init(void)\r\n{\r\nint rc;\r\nnull_init_internal();\r\nrc = sptlrpc_register_policy(&null_policy);\r\nif (rc)\r\nCERROR("failed to register %s: %d\n", null_policy.sp_name, rc);\r\nreturn rc;\r\n}\r\nvoid sptlrpc_null_fini(void)\r\n{\r\nint rc;\r\nrc = sptlrpc_unregister_policy(&null_policy);\r\nif (rc)\r\nCERROR("failed to unregister %s: %d\n",\r\nnull_policy.sp_name, rc);\r\n}
