static void mptsas_print_phy_data(MPT_ADAPTER *ioc,\r\nMPI_SAS_IO_UNIT0_PHY_DATA *phy_data)\r\n{\r\ndsasprintk(ioc, printk(MYIOC_s_DEBUG_FMT\r\n"---- IO UNIT PAGE 0 ------------\n", ioc->name));\r\ndsasprintk(ioc, printk(MYIOC_s_DEBUG_FMT "Handle=0x%X\n",\r\nioc->name, le16_to_cpu(phy_data->AttachedDeviceHandle)));\r\ndsasprintk(ioc, printk(MYIOC_s_DEBUG_FMT "Controller Handle=0x%X\n",\r\nioc->name, le16_to_cpu(phy_data->ControllerDevHandle)));\r\ndsasprintk(ioc, printk(MYIOC_s_DEBUG_FMT "Port=0x%X\n",\r\nioc->name, phy_data->Port));\r\ndsasprintk(ioc, printk(MYIOC_s_DEBUG_FMT "Port Flags=0x%X\n",\r\nioc->name, phy_data->PortFlags));\r\ndsasprintk(ioc, printk(MYIOC_s_DEBUG_FMT "PHY Flags=0x%X\n",\r\nioc->name, phy_data->PhyFlags));\r\ndsasprintk(ioc, printk(MYIOC_s_DEBUG_FMT "Negotiated Link Rate=0x%X\n",\r\nioc->name, phy_data->NegotiatedLinkRate));\r\ndsasprintk(ioc, printk(MYIOC_s_DEBUG_FMT\r\n"Controller PHY Device Info=0x%X\n", ioc->name,\r\nle32_to_cpu(phy_data->ControllerPhyDeviceInfo)));\r\ndsasprintk(ioc, printk(MYIOC_s_DEBUG_FMT "DiscoveryStatus=0x%X\n\n",\r\nioc->name, le32_to_cpu(phy_data->DiscoveryStatus)));\r\n}\r\nstatic void mptsas_print_phy_pg0(MPT_ADAPTER *ioc, SasPhyPage0_t *pg0)\r\n{\r\n__le64 sas_address;\r\nmemcpy(&sas_address, &pg0->SASAddress, sizeof(__le64));\r\ndsasprintk(ioc, printk(MYIOC_s_DEBUG_FMT\r\n"---- SAS PHY PAGE 0 ------------\n", ioc->name));\r\ndsasprintk(ioc, printk(MYIOC_s_DEBUG_FMT\r\n"Attached Device Handle=0x%X\n", ioc->name,\r\nle16_to_cpu(pg0->AttachedDevHandle)));\r\ndsasprintk(ioc, printk(MYIOC_s_DEBUG_FMT "SAS Address=0x%llX\n",\r\nioc->name, (unsigned long long)le64_to_cpu(sas_address)));\r\ndsasprintk(ioc, printk(MYIOC_s_DEBUG_FMT\r\n"Attached PHY Identifier=0x%X\n", ioc->name,\r\npg0->AttachedPhyIdentifier));\r\ndsasprintk(ioc, printk(MYIOC_s_DEBUG_FMT "Attached Device Info=0x%X\n",\r\nioc->name, le32_to_cpu(pg0->AttachedDeviceInfo)));\r\ndsasprintk(ioc, printk(MYIOC_s_DEBUG_FMT "Programmed Link Rate=0x%X\n",\r\nioc->name, pg0->ProgrammedLinkRate));\r\ndsasprintk(ioc, printk(MYIOC_s_DEBUG_FMT "Change Count=0x%X\n",\r\nioc->name, pg0->ChangeCount));\r\ndsasprintk(ioc, printk(MYIOC_s_DEBUG_FMT "PHY Info=0x%X\n\n",\r\nioc->name, le32_to_cpu(pg0->PhyInfo)));\r\n}\r\nstatic void mptsas_print_phy_pg1(MPT_ADAPTER *ioc, SasPhyPage1_t *pg1)\r\n{\r\ndsasprintk(ioc, printk(MYIOC_s_DEBUG_FMT\r\n"---- SAS PHY PAGE 1 ------------\n", ioc->name));\r\ndsasprintk(ioc, printk(MYIOC_s_DEBUG_FMT "Invalid Dword Count=0x%x\n",\r\nioc->name, pg1->InvalidDwordCount));\r\ndsasprintk(ioc, printk(MYIOC_s_DEBUG_FMT\r\n"Running Disparity Error Count=0x%x\n", ioc->name,\r\npg1->RunningDisparityErrorCount));\r\ndsasprintk(ioc, printk(MYIOC_s_DEBUG_FMT\r\n"Loss Dword Synch Count=0x%x\n", ioc->name,\r\npg1->LossDwordSynchCount));\r\ndsasprintk(ioc, printk(MYIOC_s_DEBUG_FMT\r\n"PHY Reset Problem Count=0x%x\n\n", ioc->name,\r\npg1->PhyResetProblemCount));\r\n}\r\nstatic void mptsas_print_device_pg0(MPT_ADAPTER *ioc, SasDevicePage0_t *pg0)\r\n{\r\n__le64 sas_address;\r\nmemcpy(&sas_address, &pg0->SASAddress, sizeof(__le64));\r\ndsasprintk(ioc, printk(MYIOC_s_DEBUG_FMT\r\n"---- SAS DEVICE PAGE 0 ---------\n", ioc->name));\r\ndsasprintk(ioc, printk(MYIOC_s_DEBUG_FMT "Handle=0x%X\n",\r\nioc->name, le16_to_cpu(pg0->DevHandle)));\r\ndsasprintk(ioc, printk(MYIOC_s_DEBUG_FMT "Parent Handle=0x%X\n",\r\nioc->name, le16_to_cpu(pg0->ParentDevHandle)));\r\ndsasprintk(ioc, printk(MYIOC_s_DEBUG_FMT "Enclosure Handle=0x%X\n",\r\nioc->name, le16_to_cpu(pg0->EnclosureHandle)));\r\ndsasprintk(ioc, printk(MYIOC_s_DEBUG_FMT "Slot=0x%X\n",\r\nioc->name, le16_to_cpu(pg0->Slot)));\r\ndsasprintk(ioc, printk(MYIOC_s_DEBUG_FMT "SAS Address=0x%llX\n",\r\nioc->name, (unsigned long long)le64_to_cpu(sas_address)));\r\ndsasprintk(ioc, printk(MYIOC_s_DEBUG_FMT "Target ID=0x%X\n",\r\nioc->name, pg0->TargetID));\r\ndsasprintk(ioc, printk(MYIOC_s_DEBUG_FMT "Bus=0x%X\n",\r\nioc->name, pg0->Bus));\r\ndsasprintk(ioc, printk(MYIOC_s_DEBUG_FMT "Parent Phy Num=0x%X\n",\r\nioc->name, pg0->PhyNum));\r\ndsasprintk(ioc, printk(MYIOC_s_DEBUG_FMT "Access Status=0x%X\n",\r\nioc->name, le16_to_cpu(pg0->AccessStatus)));\r\ndsasprintk(ioc, printk(MYIOC_s_DEBUG_FMT "Device Info=0x%X\n",\r\nioc->name, le32_to_cpu(pg0->DeviceInfo)));\r\ndsasprintk(ioc, printk(MYIOC_s_DEBUG_FMT "Flags=0x%X\n",\r\nioc->name, le16_to_cpu(pg0->Flags)));\r\ndsasprintk(ioc, printk(MYIOC_s_DEBUG_FMT "Physical Port=0x%X\n\n",\r\nioc->name, pg0->PhysicalPort));\r\n}\r\nstatic void mptsas_print_expander_pg1(MPT_ADAPTER *ioc, SasExpanderPage1_t *pg1)\r\n{\r\ndsasprintk(ioc, printk(MYIOC_s_DEBUG_FMT\r\n"---- SAS EXPANDER PAGE 1 ------------\n", ioc->name));\r\ndsasprintk(ioc, printk(MYIOC_s_DEBUG_FMT "Physical Port=0x%X\n",\r\nioc->name, pg1->PhysicalPort));\r\ndsasprintk(ioc, printk(MYIOC_s_DEBUG_FMT "PHY Identifier=0x%X\n",\r\nioc->name, pg1->PhyIdentifier));\r\ndsasprintk(ioc, printk(MYIOC_s_DEBUG_FMT "Negotiated Link Rate=0x%X\n",\r\nioc->name, pg1->NegotiatedLinkRate));\r\ndsasprintk(ioc, printk(MYIOC_s_DEBUG_FMT "Programmed Link Rate=0x%X\n",\r\nioc->name, pg1->ProgrammedLinkRate));\r\ndsasprintk(ioc, printk(MYIOC_s_DEBUG_FMT "Hardware Link Rate=0x%X\n",\r\nioc->name, pg1->HwLinkRate));\r\ndsasprintk(ioc, printk(MYIOC_s_DEBUG_FMT "Owner Device Handle=0x%X\n",\r\nioc->name, le16_to_cpu(pg1->OwnerDevHandle)));\r\ndsasprintk(ioc, printk(MYIOC_s_DEBUG_FMT\r\n"Attached Device Handle=0x%X\n\n", ioc->name,\r\nle16_to_cpu(pg1->AttachedDevHandle)));\r\n}\r\nstatic void\r\nmptsas_fw_event_off(MPT_ADAPTER *ioc)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&ioc->fw_event_lock, flags);\r\nioc->fw_events_off = 1;\r\nioc->sas_discovery_quiesce_io = 0;\r\nspin_unlock_irqrestore(&ioc->fw_event_lock, flags);\r\n}\r\nstatic void\r\nmptsas_fw_event_on(MPT_ADAPTER *ioc)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&ioc->fw_event_lock, flags);\r\nioc->fw_events_off = 0;\r\nspin_unlock_irqrestore(&ioc->fw_event_lock, flags);\r\n}\r\nstatic void\r\nmptsas_add_fw_event(MPT_ADAPTER *ioc, struct fw_event_work *fw_event,\r\nunsigned long delay)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&ioc->fw_event_lock, flags);\r\nlist_add_tail(&fw_event->list, &ioc->fw_event_list);\r\nINIT_DELAYED_WORK(&fw_event->work, mptsas_firmware_event_work);\r\ndevtprintk(ioc, printk(MYIOC_s_DEBUG_FMT "%s: add (fw_event=0x%p)"\r\n"on cpuid %d\n", ioc->name, __func__,\r\nfw_event, smp_processor_id()));\r\nqueue_delayed_work_on(smp_processor_id(), ioc->fw_event_q,\r\n&fw_event->work, delay);\r\nspin_unlock_irqrestore(&ioc->fw_event_lock, flags);\r\n}\r\nstatic void\r\nmptsas_requeue_fw_event(MPT_ADAPTER *ioc, struct fw_event_work *fw_event,\r\nunsigned long delay)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&ioc->fw_event_lock, flags);\r\ndevtprintk(ioc, printk(MYIOC_s_DEBUG_FMT "%s: reschedule task "\r\n"(fw_event=0x%p)on cpuid %d\n", ioc->name, __func__,\r\nfw_event, smp_processor_id()));\r\nfw_event->retries++;\r\nqueue_delayed_work_on(smp_processor_id(), ioc->fw_event_q,\r\n&fw_event->work, msecs_to_jiffies(delay));\r\nspin_unlock_irqrestore(&ioc->fw_event_lock, flags);\r\n}\r\nstatic void\r\nmptsas_free_fw_event(MPT_ADAPTER *ioc, struct fw_event_work *fw_event)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&ioc->fw_event_lock, flags);\r\ndevtprintk(ioc, printk(MYIOC_s_DEBUG_FMT "%s: kfree (fw_event=0x%p)\n",\r\nioc->name, __func__, fw_event));\r\nlist_del(&fw_event->list);\r\nkfree(fw_event);\r\nspin_unlock_irqrestore(&ioc->fw_event_lock, flags);\r\n}\r\nstatic void\r\nmptsas_cleanup_fw_event_q(MPT_ADAPTER *ioc)\r\n{\r\nstruct fw_event_work *fw_event, *next;\r\nstruct mptsas_target_reset_event *target_reset_list, *n;\r\nMPT_SCSI_HOST *hd = shost_priv(ioc->sh);\r\nif (!list_empty(&hd->target_reset_list)) {\r\nlist_for_each_entry_safe(target_reset_list, n,\r\n&hd->target_reset_list, list) {\r\ndtmprintk(ioc, printk(MYIOC_s_DEBUG_FMT\r\n"%s: removing target reset for id=%d\n",\r\nioc->name, __func__,\r\ntarget_reset_list->sas_event_data.TargetID));\r\nlist_del(&target_reset_list->list);\r\nkfree(target_reset_list);\r\n}\r\n}\r\nif (list_empty(&ioc->fw_event_list) ||\r\n!ioc->fw_event_q || in_interrupt())\r\nreturn;\r\nlist_for_each_entry_safe(fw_event, next, &ioc->fw_event_list, list) {\r\nif (cancel_delayed_work(&fw_event->work))\r\nmptsas_free_fw_event(ioc, fw_event);\r\n}\r\n}\r\nstatic inline MPT_ADAPTER *phy_to_ioc(struct sas_phy *phy)\r\n{\r\nstruct Scsi_Host *shost = dev_to_shost(phy->dev.parent);\r\nreturn ((MPT_SCSI_HOST *)shost->hostdata)->ioc;\r\n}\r\nstatic inline MPT_ADAPTER *rphy_to_ioc(struct sas_rphy *rphy)\r\n{\r\nstruct Scsi_Host *shost = dev_to_shost(rphy->dev.parent->parent);\r\nreturn ((MPT_SCSI_HOST *)shost->hostdata)->ioc;\r\n}\r\nstatic struct mptsas_portinfo *\r\nmptsas_find_portinfo_by_handle(MPT_ADAPTER *ioc, u16 handle)\r\n{\r\nstruct mptsas_portinfo *port_info, *rc=NULL;\r\nint i;\r\nlist_for_each_entry(port_info, &ioc->sas_topology, list)\r\nfor (i = 0; i < port_info->num_phys; i++)\r\nif (port_info->phy_info[i].identify.handle == handle) {\r\nrc = port_info;\r\ngoto out;\r\n}\r\nout:\r\nreturn rc;\r\n}\r\nstatic struct mptsas_portinfo *\r\nmptsas_find_portinfo_by_sas_address(MPT_ADAPTER *ioc, u64 sas_address)\r\n{\r\nstruct mptsas_portinfo *port_info, *rc = NULL;\r\nint i;\r\nif (sas_address >= ioc->hba_port_sas_addr &&\r\nsas_address < (ioc->hba_port_sas_addr +\r\nioc->hba_port_num_phy))\r\nreturn ioc->hba_port_info;\r\nmutex_lock(&ioc->sas_topology_mutex);\r\nlist_for_each_entry(port_info, &ioc->sas_topology, list)\r\nfor (i = 0; i < port_info->num_phys; i++)\r\nif (port_info->phy_info[i].identify.sas_address ==\r\nsas_address) {\r\nrc = port_info;\r\ngoto out;\r\n}\r\nout:\r\nmutex_unlock(&ioc->sas_topology_mutex);\r\nreturn rc;\r\n}\r\nstatic inline int\r\nmptsas_is_end_device(struct mptsas_devinfo * attached)\r\n{\r\nif ((attached->sas_address) &&\r\n(attached->device_info &\r\nMPI_SAS_DEVICE_INFO_END_DEVICE) &&\r\n((attached->device_info &\r\nMPI_SAS_DEVICE_INFO_SSP_TARGET) |\r\n(attached->device_info &\r\nMPI_SAS_DEVICE_INFO_STP_TARGET) |\r\n(attached->device_info &\r\nMPI_SAS_DEVICE_INFO_SATA_DEVICE)))\r\nreturn 1;\r\nelse\r\nreturn 0;\r\n}\r\nstatic void\r\nmptsas_port_delete(MPT_ADAPTER *ioc, struct mptsas_portinfo_details * port_details)\r\n{\r\nstruct mptsas_portinfo *port_info;\r\nstruct mptsas_phyinfo *phy_info;\r\nu8 i;\r\nif (!port_details)\r\nreturn;\r\nport_info = port_details->port_info;\r\nphy_info = port_info->phy_info;\r\ndsaswideprintk(ioc, printk(MYIOC_s_DEBUG_FMT "%s: [%p]: num_phys=%02d "\r\n"bitmask=0x%016llX\n", ioc->name, __func__, port_details,\r\nport_details->num_phys, (unsigned long long)\r\nport_details->phy_bitmask));\r\nfor (i = 0; i < port_info->num_phys; i++, phy_info++) {\r\nif(phy_info->port_details != port_details)\r\ncontinue;\r\nmemset(&phy_info->attached, 0, sizeof(struct mptsas_devinfo));\r\nmptsas_set_rphy(ioc, phy_info, NULL);\r\nphy_info->port_details = NULL;\r\n}\r\nkfree(port_details);\r\n}\r\nstatic inline struct sas_rphy *\r\nmptsas_get_rphy(struct mptsas_phyinfo *phy_info)\r\n{\r\nif (phy_info->port_details)\r\nreturn phy_info->port_details->rphy;\r\nelse\r\nreturn NULL;\r\n}\r\nstatic inline void\r\nmptsas_set_rphy(MPT_ADAPTER *ioc, struct mptsas_phyinfo *phy_info, struct sas_rphy *rphy)\r\n{\r\nif (phy_info->port_details) {\r\nphy_info->port_details->rphy = rphy;\r\ndsaswideprintk(ioc, printk(MYIOC_s_DEBUG_FMT "sas_rphy_add: rphy=%p\n",\r\nioc->name, rphy));\r\n}\r\nif (rphy) {\r\ndsaswideprintk(ioc, dev_printk(KERN_DEBUG,\r\n&rphy->dev, MYIOC_s_FMT "add:", ioc->name));\r\ndsaswideprintk(ioc, printk(MYIOC_s_DEBUG_FMT "rphy=%p release=%p\n",\r\nioc->name, rphy, rphy->dev.release));\r\n}\r\n}\r\nstatic inline struct sas_port *\r\nmptsas_get_port(struct mptsas_phyinfo *phy_info)\r\n{\r\nif (phy_info->port_details)\r\nreturn phy_info->port_details->port;\r\nelse\r\nreturn NULL;\r\n}\r\nstatic inline void\r\nmptsas_set_port(MPT_ADAPTER *ioc, struct mptsas_phyinfo *phy_info, struct sas_port *port)\r\n{\r\nif (phy_info->port_details)\r\nphy_info->port_details->port = port;\r\nif (port) {\r\ndsaswideprintk(ioc, dev_printk(KERN_DEBUG,\r\n&port->dev, MYIOC_s_FMT "add:", ioc->name));\r\ndsaswideprintk(ioc, printk(MYIOC_s_DEBUG_FMT "port=%p release=%p\n",\r\nioc->name, port, port->dev.release));\r\n}\r\n}\r\nstatic inline struct scsi_target *\r\nmptsas_get_starget(struct mptsas_phyinfo *phy_info)\r\n{\r\nif (phy_info->port_details)\r\nreturn phy_info->port_details->starget;\r\nelse\r\nreturn NULL;\r\n}\r\nstatic inline void\r\nmptsas_set_starget(struct mptsas_phyinfo *phy_info, struct scsi_target *\r\nstarget)\r\n{\r\nif (phy_info->port_details)\r\nphy_info->port_details->starget = starget;\r\n}\r\nstatic void\r\nmptsas_add_device_component(MPT_ADAPTER *ioc, u8 channel, u8 id,\r\nu64 sas_address, u32 device_info, u16 slot, u64 enclosure_logical_id)\r\n{\r\nstruct mptsas_device_info *sas_info, *next;\r\nstruct scsi_device *sdev;\r\nstruct scsi_target *starget;\r\nstruct sas_rphy *rphy;\r\nmutex_lock(&ioc->sas_device_info_mutex);\r\nlist_for_each_entry_safe(sas_info, next, &ioc->sas_device_info_list,\r\nlist) {\r\nif (!sas_info->is_logical_volume &&\r\n(sas_info->sas_address == sas_address ||\r\n(sas_info->fw.channel == channel &&\r\nsas_info->fw.id == id))) {\r\nlist_del(&sas_info->list);\r\nkfree(sas_info);\r\n}\r\n}\r\nsas_info = kzalloc(sizeof(struct mptsas_device_info), GFP_KERNEL);\r\nif (!sas_info)\r\ngoto out;\r\nsas_info->fw.id = id;\r\nsas_info->fw.channel = channel;\r\nsas_info->sas_address = sas_address;\r\nsas_info->device_info = device_info;\r\nsas_info->slot = slot;\r\nsas_info->enclosure_logical_id = enclosure_logical_id;\r\nINIT_LIST_HEAD(&sas_info->list);\r\nlist_add_tail(&sas_info->list, &ioc->sas_device_info_list);\r\nshost_for_each_device(sdev, ioc->sh) {\r\nstarget = scsi_target(sdev);\r\nrphy = dev_to_rphy(starget->dev.parent);\r\nif (rphy->identify.sas_address == sas_address) {\r\nsas_info->os.id = starget->id;\r\nsas_info->os.channel = starget->channel;\r\n}\r\n}\r\nout:\r\nmutex_unlock(&ioc->sas_device_info_mutex);\r\nreturn;\r\n}\r\nstatic void\r\nmptsas_add_device_component_by_fw(MPT_ADAPTER *ioc, u8 channel, u8 id)\r\n{\r\nstruct mptsas_devinfo sas_device;\r\nstruct mptsas_enclosure enclosure_info;\r\nint rc;\r\nrc = mptsas_sas_device_pg0(ioc, &sas_device,\r\n(MPI_SAS_DEVICE_PGAD_FORM_BUS_TARGET_ID <<\r\nMPI_SAS_DEVICE_PGAD_FORM_SHIFT),\r\n(channel << 8) + id);\r\nif (rc)\r\nreturn;\r\nmemset(&enclosure_info, 0, sizeof(struct mptsas_enclosure));\r\nmptsas_sas_enclosure_pg0(ioc, &enclosure_info,\r\n(MPI_SAS_ENCLOS_PGAD_FORM_HANDLE <<\r\nMPI_SAS_ENCLOS_PGAD_FORM_SHIFT),\r\nsas_device.handle_enclosure);\r\nmptsas_add_device_component(ioc, sas_device.channel,\r\nsas_device.id, sas_device.sas_address, sas_device.device_info,\r\nsas_device.slot, enclosure_info.enclosure_logical_id);\r\n}\r\nstatic void\r\nmptsas_add_device_component_starget_ir(MPT_ADAPTER *ioc,\r\nstruct scsi_target *starget)\r\n{\r\nCONFIGPARMS cfg;\r\nConfigPageHeader_t hdr;\r\ndma_addr_t dma_handle;\r\npRaidVolumePage0_t buffer = NULL;\r\nint i;\r\nRaidPhysDiskPage0_t phys_disk;\r\nstruct mptsas_device_info *sas_info, *next;\r\nmemset(&cfg, 0 , sizeof(CONFIGPARMS));\r\nmemset(&hdr, 0 , sizeof(ConfigPageHeader_t));\r\nhdr.PageType = MPI_CONFIG_PAGETYPE_RAID_VOLUME;\r\ncfg.pageAddr = starget->id;\r\ncfg.cfghdr.hdr = &hdr;\r\ncfg.action = MPI_CONFIG_ACTION_PAGE_HEADER;\r\ncfg.timeout = SAS_CONFIG_PAGE_TIMEOUT;\r\nif (mpt_config(ioc, &cfg) != 0)\r\ngoto out;\r\nif (!hdr.PageLength)\r\ngoto out;\r\nbuffer = pci_alloc_consistent(ioc->pcidev, hdr.PageLength * 4,\r\n&dma_handle);\r\nif (!buffer)\r\ngoto out;\r\ncfg.physAddr = dma_handle;\r\ncfg.action = MPI_CONFIG_ACTION_PAGE_READ_CURRENT;\r\nif (mpt_config(ioc, &cfg) != 0)\r\ngoto out;\r\nif (!buffer->NumPhysDisks)\r\ngoto out;\r\nfor (i = 0; i < buffer->NumPhysDisks; i++) {\r\nif (mpt_raid_phys_disk_pg0(ioc,\r\nbuffer->PhysDisk[i].PhysDiskNum, &phys_disk) != 0)\r\ncontinue;\r\nmptsas_add_device_component_by_fw(ioc, phys_disk.PhysDiskBus,\r\nphys_disk.PhysDiskID);\r\nmutex_lock(&ioc->sas_device_info_mutex);\r\nlist_for_each_entry(sas_info, &ioc->sas_device_info_list,\r\nlist) {\r\nif (!sas_info->is_logical_volume &&\r\n(sas_info->fw.channel == phys_disk.PhysDiskBus &&\r\nsas_info->fw.id == phys_disk.PhysDiskID)) {\r\nsas_info->is_hidden_raid_component = 1;\r\nsas_info->volume_id = starget->id;\r\n}\r\n}\r\nmutex_unlock(&ioc->sas_device_info_mutex);\r\n}\r\nmutex_lock(&ioc->sas_device_info_mutex);\r\nlist_for_each_entry_safe(sas_info, next, &ioc->sas_device_info_list,\r\nlist) {\r\nif (sas_info->is_logical_volume && sas_info->fw.id ==\r\nstarget->id) {\r\nlist_del(&sas_info->list);\r\nkfree(sas_info);\r\n}\r\n}\r\nsas_info = kzalloc(sizeof(struct mptsas_device_info), GFP_KERNEL);\r\nif (sas_info) {\r\nsas_info->fw.id = starget->id;\r\nsas_info->os.id = starget->id;\r\nsas_info->os.channel = starget->channel;\r\nsas_info->is_logical_volume = 1;\r\nINIT_LIST_HEAD(&sas_info->list);\r\nlist_add_tail(&sas_info->list, &ioc->sas_device_info_list);\r\n}\r\nmutex_unlock(&ioc->sas_device_info_mutex);\r\nout:\r\nif (buffer)\r\npci_free_consistent(ioc->pcidev, hdr.PageLength * 4, buffer,\r\ndma_handle);\r\n}\r\nstatic void\r\nmptsas_add_device_component_starget(MPT_ADAPTER *ioc,\r\nstruct scsi_target *starget)\r\n{\r\nVirtTarget *vtarget;\r\nstruct sas_rphy *rphy;\r\nstruct mptsas_phyinfo *phy_info = NULL;\r\nstruct mptsas_enclosure enclosure_info;\r\nrphy = dev_to_rphy(starget->dev.parent);\r\nvtarget = starget->hostdata;\r\nphy_info = mptsas_find_phyinfo_by_sas_address(ioc,\r\nrphy->identify.sas_address);\r\nif (!phy_info)\r\nreturn;\r\nmemset(&enclosure_info, 0, sizeof(struct mptsas_enclosure));\r\nmptsas_sas_enclosure_pg0(ioc, &enclosure_info,\r\n(MPI_SAS_ENCLOS_PGAD_FORM_HANDLE <<\r\nMPI_SAS_ENCLOS_PGAD_FORM_SHIFT),\r\nphy_info->attached.handle_enclosure);\r\nmptsas_add_device_component(ioc, phy_info->attached.channel,\r\nphy_info->attached.id, phy_info->attached.sas_address,\r\nphy_info->attached.device_info,\r\nphy_info->attached.slot, enclosure_info.enclosure_logical_id);\r\n}\r\nstatic void\r\nmptsas_del_device_component_by_os(MPT_ADAPTER *ioc, u8 channel, u8 id)\r\n{\r\nstruct mptsas_device_info *sas_info, *next;\r\nlist_for_each_entry_safe(sas_info, next, &ioc->sas_device_info_list,\r\nlist) {\r\nif (sas_info->os.channel == channel && sas_info->os.id == id)\r\nsas_info->is_cached = 1;\r\n}\r\n}\r\nstatic void\r\nmptsas_del_device_components(MPT_ADAPTER *ioc)\r\n{\r\nstruct mptsas_device_info *sas_info, *next;\r\nmutex_lock(&ioc->sas_device_info_mutex);\r\nlist_for_each_entry_safe(sas_info, next, &ioc->sas_device_info_list,\r\nlist) {\r\nlist_del(&sas_info->list);\r\nkfree(sas_info);\r\n}\r\nmutex_unlock(&ioc->sas_device_info_mutex);\r\n}\r\nstatic void\r\nmptsas_setup_wide_ports(MPT_ADAPTER *ioc, struct mptsas_portinfo *port_info)\r\n{\r\nstruct mptsas_portinfo_details * port_details;\r\nstruct mptsas_phyinfo *phy_info, *phy_info_cmp;\r\nu64 sas_address;\r\nint i, j;\r\nmutex_lock(&ioc->sas_topology_mutex);\r\nphy_info = port_info->phy_info;\r\nfor (i = 0 ; i < port_info->num_phys ; i++, phy_info++) {\r\nif (phy_info->attached.handle)\r\ncontinue;\r\nport_details = phy_info->port_details;\r\nif (!port_details)\r\ncontinue;\r\nif (port_details->num_phys < 2)\r\ncontinue;\r\ndsaswideprintk(ioc, printk(MYIOC_s_DEBUG_FMT\r\n"%s: [%p]: deleting phy = %d\n",\r\nioc->name, __func__, port_details, i));\r\nport_details->num_phys--;\r\nport_details->phy_bitmask &= ~ (1 << phy_info->phy_id);\r\nmemset(&phy_info->attached, 0, sizeof(struct mptsas_devinfo));\r\nif (phy_info->phy) {\r\ndevtprintk(ioc, dev_printk(KERN_DEBUG,\r\n&phy_info->phy->dev, MYIOC_s_FMT\r\n"delete phy %d, phy-obj (0x%p)\n", ioc->name,\r\nphy_info->phy_id, phy_info->phy));\r\nsas_port_delete_phy(port_details->port, phy_info->phy);\r\n}\r\nphy_info->port_details = NULL;\r\n}\r\nphy_info = port_info->phy_info;\r\nfor (i = 0 ; i < port_info->num_phys ; i++, phy_info++) {\r\nsas_address = phy_info->attached.sas_address;\r\ndsaswideprintk(ioc, printk(MYIOC_s_DEBUG_FMT "phy_id=%d sas_address=0x%018llX\n",\r\nioc->name, i, (unsigned long long)sas_address));\r\nif (!sas_address)\r\ncontinue;\r\nport_details = phy_info->port_details;\r\nif (!port_details) {\r\nport_details = kzalloc(sizeof(struct\r\nmptsas_portinfo_details), GFP_KERNEL);\r\nif (!port_details)\r\ngoto out;\r\nport_details->num_phys = 1;\r\nport_details->port_info = port_info;\r\nif (phy_info->phy_id < 64 )\r\nport_details->phy_bitmask |=\r\n(1 << phy_info->phy_id);\r\nphy_info->sas_port_add_phy=1;\r\ndsaswideprintk(ioc, printk(MYIOC_s_DEBUG_FMT "\t\tForming port\n\t\t"\r\n"phy_id=%d sas_address=0x%018llX\n",\r\nioc->name, i, (unsigned long long)sas_address));\r\nphy_info->port_details = port_details;\r\n}\r\nif (i == port_info->num_phys - 1)\r\ncontinue;\r\nphy_info_cmp = &port_info->phy_info[i + 1];\r\nfor (j = i + 1 ; j < port_info->num_phys ; j++,\r\nphy_info_cmp++) {\r\nif (!phy_info_cmp->attached.sas_address)\r\ncontinue;\r\nif (sas_address != phy_info_cmp->attached.sas_address)\r\ncontinue;\r\nif (phy_info_cmp->port_details == port_details )\r\ncontinue;\r\ndsaswideprintk(ioc, printk(MYIOC_s_DEBUG_FMT\r\n"\t\tphy_id=%d sas_address=0x%018llX\n",\r\nioc->name, j, (unsigned long long)\r\nphy_info_cmp->attached.sas_address));\r\nif (phy_info_cmp->port_details) {\r\nport_details->rphy =\r\nmptsas_get_rphy(phy_info_cmp);\r\nport_details->port =\r\nmptsas_get_port(phy_info_cmp);\r\nport_details->starget =\r\nmptsas_get_starget(phy_info_cmp);\r\nport_details->num_phys =\r\nphy_info_cmp->port_details->num_phys;\r\nif (!phy_info_cmp->port_details->num_phys)\r\nkfree(phy_info_cmp->port_details);\r\n} else\r\nphy_info_cmp->sas_port_add_phy=1;\r\nphy_info_cmp->port_details = port_details;\r\nif (phy_info_cmp->phy_id < 64 )\r\nport_details->phy_bitmask |=\r\n(1 << phy_info_cmp->phy_id);\r\nport_details->num_phys++;\r\n}\r\n}\r\nout:\r\nfor (i = 0; i < port_info->num_phys; i++) {\r\nport_details = port_info->phy_info[i].port_details;\r\nif (!port_details)\r\ncontinue;\r\ndsaswideprintk(ioc, printk(MYIOC_s_DEBUG_FMT\r\n"%s: [%p]: phy_id=%02d num_phys=%02d "\r\n"bitmask=0x%016llX\n", ioc->name, __func__,\r\nport_details, i, port_details->num_phys,\r\n(unsigned long long)port_details->phy_bitmask));\r\ndsaswideprintk(ioc, printk(MYIOC_s_DEBUG_FMT "\t\tport = %p rphy=%p\n",\r\nioc->name, port_details->port, port_details->rphy));\r\n}\r\ndsaswideprintk(ioc, printk("\n"));\r\nmutex_unlock(&ioc->sas_topology_mutex);\r\n}\r\nstatic VirtTarget *\r\nmptsas_find_vtarget(MPT_ADAPTER *ioc, u8 channel, u8 id)\r\n{\r\nstruct scsi_device *sdev;\r\nVirtDevice *vdevice;\r\nVirtTarget *vtarget = NULL;\r\nshost_for_each_device(sdev, ioc->sh) {\r\nvdevice = sdev->hostdata;\r\nif ((vdevice == NULL) ||\r\n(vdevice->vtarget == NULL))\r\ncontinue;\r\nif ((vdevice->vtarget->tflags &\r\nMPT_TARGET_FLAGS_RAID_COMPONENT ||\r\nvdevice->vtarget->raidVolume))\r\ncontinue;\r\nif (vdevice->vtarget->id == id &&\r\nvdevice->vtarget->channel == channel)\r\nvtarget = vdevice->vtarget;\r\n}\r\nreturn vtarget;\r\n}\r\nstatic void\r\nmptsas_queue_device_delete(MPT_ADAPTER *ioc,\r\nMpiEventDataSasDeviceStatusChange_t *sas_event_data)\r\n{\r\nstruct fw_event_work *fw_event;\r\nfw_event = kzalloc(sizeof(*fw_event) +\r\nsizeof(MpiEventDataSasDeviceStatusChange_t),\r\nGFP_ATOMIC);\r\nif (!fw_event) {\r\nprintk(MYIOC_s_WARN_FMT "%s: failed at (line=%d)\n",\r\nioc->name, __func__, __LINE__);\r\nreturn;\r\n}\r\nmemcpy(fw_event->event_data, sas_event_data,\r\nsizeof(MpiEventDataSasDeviceStatusChange_t));\r\nfw_event->event = MPI_EVENT_SAS_DEVICE_STATUS_CHANGE;\r\nfw_event->ioc = ioc;\r\nmptsas_add_fw_event(ioc, fw_event, msecs_to_jiffies(1));\r\n}\r\nstatic void\r\nmptsas_queue_rescan(MPT_ADAPTER *ioc)\r\n{\r\nstruct fw_event_work *fw_event;\r\nfw_event = kzalloc(sizeof(*fw_event), GFP_ATOMIC);\r\nif (!fw_event) {\r\nprintk(MYIOC_s_WARN_FMT "%s: failed at (line=%d)\n",\r\nioc->name, __func__, __LINE__);\r\nreturn;\r\n}\r\nfw_event->event = -1;\r\nfw_event->ioc = ioc;\r\nmptsas_add_fw_event(ioc, fw_event, msecs_to_jiffies(1));\r\n}\r\nstatic int\r\nmptsas_target_reset(MPT_ADAPTER *ioc, u8 channel, u8 id)\r\n{\r\nMPT_FRAME_HDR *mf;\r\nSCSITaskMgmt_t *pScsiTm;\r\nif (mpt_set_taskmgmt_in_progress_flag(ioc) != 0)\r\nreturn 0;\r\nmf = mpt_get_msg_frame(mptsasDeviceResetCtx, ioc);\r\nif (mf == NULL) {\r\ndfailprintk(ioc, printk(MYIOC_s_WARN_FMT\r\n"%s, no msg frames @%d!!\n", ioc->name,\r\n__func__, __LINE__));\r\ngoto out_fail;\r\n}\r\ndtmprintk(ioc, printk(MYIOC_s_DEBUG_FMT "TaskMgmt request (mf=%p)\n",\r\nioc->name, mf));\r\npScsiTm = (SCSITaskMgmt_t *) mf;\r\nmemset (pScsiTm, 0, sizeof(SCSITaskMgmt_t));\r\npScsiTm->TargetID = id;\r\npScsiTm->Bus = channel;\r\npScsiTm->Function = MPI_FUNCTION_SCSI_TASK_MGMT;\r\npScsiTm->TaskType = MPI_SCSITASKMGMT_TASKTYPE_TARGET_RESET;\r\npScsiTm->MsgFlags = MPI_SCSITASKMGMT_MSGFLAGS_LIPRESET_RESET_OPTION;\r\nDBG_DUMP_TM_REQUEST_FRAME(ioc, (u32 *)mf);\r\ndtmprintk(ioc, printk(MYIOC_s_DEBUG_FMT\r\n"TaskMgmt type=%d (sas device delete) fw_channel = %d fw_id = %d)\n",\r\nioc->name, MPI_SCSITASKMGMT_TASKTYPE_TARGET_RESET, channel, id));\r\nmpt_put_msg_frame_hi_pri(mptsasDeviceResetCtx, ioc, mf);\r\nreturn 1;\r\nout_fail:\r\nmpt_clear_taskmgmt_in_progress_flag(ioc);\r\nreturn 0;\r\n}\r\nstatic void\r\nmptsas_block_io_sdev(struct scsi_device *sdev, void *data)\r\n{\r\nscsi_device_set_state(sdev, SDEV_BLOCK);\r\n}\r\nstatic void\r\nmptsas_block_io_starget(struct scsi_target *starget)\r\n{\r\nif (starget)\r\nstarget_for_each_device(starget, NULL, mptsas_block_io_sdev);\r\n}\r\nstatic void\r\nmptsas_target_reset_queue(MPT_ADAPTER *ioc,\r\nEVENT_DATA_SAS_DEVICE_STATUS_CHANGE *sas_event_data)\r\n{\r\nMPT_SCSI_HOST *hd = shost_priv(ioc->sh);\r\nVirtTarget *vtarget = NULL;\r\nstruct mptsas_target_reset_event *target_reset_list;\r\nu8 id, channel;\r\nid = sas_event_data->TargetID;\r\nchannel = sas_event_data->Bus;\r\nvtarget = mptsas_find_vtarget(ioc, channel, id);\r\nif (vtarget) {\r\nmptsas_block_io_starget(vtarget->starget);\r\nvtarget->deleted = 1;\r\n}\r\ntarget_reset_list = kzalloc(sizeof(struct mptsas_target_reset_event),\r\nGFP_ATOMIC);\r\nif (!target_reset_list) {\r\ndfailprintk(ioc, printk(MYIOC_s_WARN_FMT\r\n"%s, failed to allocate mem @%d..!!\n",\r\nioc->name, __func__, __LINE__));\r\nreturn;\r\n}\r\nmemcpy(&target_reset_list->sas_event_data, sas_event_data,\r\nsizeof(*sas_event_data));\r\nlist_add_tail(&target_reset_list->list, &hd->target_reset_list);\r\ntarget_reset_list->time_count = jiffies;\r\nif (mptsas_target_reset(ioc, channel, id)) {\r\ntarget_reset_list->target_reset_issued = 1;\r\n}\r\n}\r\nvoid\r\nmptsas_schedule_target_reset(void *iocp)\r\n{\r\nMPT_ADAPTER *ioc = (MPT_ADAPTER *)(iocp);\r\nMPT_SCSI_HOST *hd = shost_priv(ioc->sh);\r\nstruct list_head *head = &hd->target_reset_list;\r\nstruct mptsas_target_reset_event *target_reset_list;\r\nu8 id, channel;\r\nhead = &hd->target_reset_list;\r\nif (list_empty(head))\r\nreturn;\r\ntarget_reset_list = list_entry(head->next,\r\nstruct mptsas_target_reset_event, list);\r\nid = target_reset_list->sas_event_data.TargetID;\r\nchannel = target_reset_list->sas_event_data.Bus;\r\ntarget_reset_list->time_count = jiffies;\r\nif (mptsas_target_reset(ioc, channel, id))\r\ntarget_reset_list->target_reset_issued = 1;\r\nreturn;\r\n}\r\nstatic int\r\nmptsas_taskmgmt_complete(MPT_ADAPTER *ioc, MPT_FRAME_HDR *mf, MPT_FRAME_HDR *mr)\r\n{\r\nMPT_SCSI_HOST *hd = shost_priv(ioc->sh);\r\nstruct list_head *head = &hd->target_reset_list;\r\nu8 id, channel;\r\nstruct mptsas_target_reset_event *target_reset_list;\r\nSCSITaskMgmtReply_t *pScsiTmReply;\r\ndtmprintk(ioc, printk(MYIOC_s_DEBUG_FMT "TaskMgmt completed: "\r\n"(mf = %p, mr = %p)\n", ioc->name, mf, mr));\r\npScsiTmReply = (SCSITaskMgmtReply_t *)mr;\r\nif (!pScsiTmReply)\r\nreturn 0;\r\ndtmprintk(ioc, printk(MYIOC_s_DEBUG_FMT\r\n"\tTaskMgmt completed: fw_channel = %d, fw_id = %d,\n"\r\n"\ttask_type = 0x%02X, iocstatus = 0x%04X "\r\n"loginfo = 0x%08X,\n\tresponse_code = 0x%02X, "\r\n"term_cmnds = %d\n", ioc->name,\r\npScsiTmReply->Bus, pScsiTmReply->TargetID,\r\npScsiTmReply->TaskType,\r\nle16_to_cpu(pScsiTmReply->IOCStatus),\r\nle32_to_cpu(pScsiTmReply->IOCLogInfo),\r\npScsiTmReply->ResponseCode,\r\nle32_to_cpu(pScsiTmReply->TerminationCount)));\r\nif (pScsiTmReply->ResponseCode)\r\nmptscsih_taskmgmt_response_code(ioc,\r\npScsiTmReply->ResponseCode);\r\nif (pScsiTmReply->TaskType ==\r\nMPI_SCSITASKMGMT_TASKTYPE_QUERY_TASK || pScsiTmReply->TaskType ==\r\nMPI_SCSITASKMGMT_TASKTYPE_ABRT_TASK_SET) {\r\nioc->taskmgmt_cmds.status |= MPT_MGMT_STATUS_COMMAND_GOOD;\r\nioc->taskmgmt_cmds.status |= MPT_MGMT_STATUS_RF_VALID;\r\nmemcpy(ioc->taskmgmt_cmds.reply, mr,\r\nmin(MPT_DEFAULT_FRAME_SIZE, 4 * mr->u.reply.MsgLength));\r\nif (ioc->taskmgmt_cmds.status & MPT_MGMT_STATUS_PENDING) {\r\nioc->taskmgmt_cmds.status &= ~MPT_MGMT_STATUS_PENDING;\r\ncomplete(&ioc->taskmgmt_cmds.done);\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nmpt_clear_taskmgmt_in_progress_flag(ioc);\r\nif (list_empty(head))\r\nreturn 1;\r\ntarget_reset_list = list_entry(head->next,\r\nstruct mptsas_target_reset_event, list);\r\ndtmprintk(ioc, printk(MYIOC_s_DEBUG_FMT\r\n"TaskMgmt: completed (%d seconds)\n",\r\nioc->name, jiffies_to_msecs(jiffies -\r\ntarget_reset_list->time_count)/1000));\r\nid = pScsiTmReply->TargetID;\r\nchannel = pScsiTmReply->Bus;\r\ntarget_reset_list->time_count = jiffies;\r\nif (!target_reset_list->target_reset_issued) {\r\nif (mptsas_target_reset(ioc, channel, id))\r\ntarget_reset_list->target_reset_issued = 1;\r\nreturn 1;\r\n}\r\nlist_del(&target_reset_list->list);\r\nif (!ioc->fw_events_off)\r\nmptsas_queue_device_delete(ioc,\r\n&target_reset_list->sas_event_data);\r\nioc->schedule_target_reset(ioc);\r\nreturn 1;\r\n}\r\nstatic int\r\nmptsas_ioc_reset(MPT_ADAPTER *ioc, int reset_phase)\r\n{\r\nMPT_SCSI_HOST *hd;\r\nint rc;\r\nrc = mptscsih_ioc_reset(ioc, reset_phase);\r\nif ((ioc->bus_type != SAS) || (!rc))\r\nreturn rc;\r\nhd = shost_priv(ioc->sh);\r\nif (!hd->ioc)\r\ngoto out;\r\nswitch (reset_phase) {\r\ncase MPT_IOC_SETUP_RESET:\r\ndtmprintk(ioc, printk(MYIOC_s_DEBUG_FMT\r\n"%s: MPT_IOC_SETUP_RESET\n", ioc->name, __func__));\r\nmptsas_fw_event_off(ioc);\r\nbreak;\r\ncase MPT_IOC_PRE_RESET:\r\ndtmprintk(ioc, printk(MYIOC_s_DEBUG_FMT\r\n"%s: MPT_IOC_PRE_RESET\n", ioc->name, __func__));\r\nbreak;\r\ncase MPT_IOC_POST_RESET:\r\ndtmprintk(ioc, printk(MYIOC_s_DEBUG_FMT\r\n"%s: MPT_IOC_POST_RESET\n", ioc->name, __func__));\r\nif (ioc->sas_mgmt.status & MPT_MGMT_STATUS_PENDING) {\r\nioc->sas_mgmt.status |= MPT_MGMT_STATUS_DID_IOCRESET;\r\ncomplete(&ioc->sas_mgmt.done);\r\n}\r\nmptsas_cleanup_fw_event_q(ioc);\r\nmptsas_queue_rescan(ioc);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nout:\r\nreturn rc;\r\n}\r\nstatic int\r\nmptsas_sas_enclosure_pg0(MPT_ADAPTER *ioc, struct mptsas_enclosure *enclosure,\r\nu32 form, u32 form_specific)\r\n{\r\nConfigExtendedPageHeader_t hdr;\r\nCONFIGPARMS cfg;\r\nSasEnclosurePage0_t *buffer;\r\ndma_addr_t dma_handle;\r\nint error;\r\n__le64 le_identifier;\r\nmemset(&hdr, 0, sizeof(hdr));\r\nhdr.PageVersion = MPI_SASENCLOSURE0_PAGEVERSION;\r\nhdr.PageNumber = 0;\r\nhdr.PageType = MPI_CONFIG_PAGETYPE_EXTENDED;\r\nhdr.ExtPageType = MPI_CONFIG_EXTPAGETYPE_ENCLOSURE;\r\ncfg.cfghdr.ehdr = &hdr;\r\ncfg.physAddr = -1;\r\ncfg.pageAddr = form + form_specific;\r\ncfg.action = MPI_CONFIG_ACTION_PAGE_HEADER;\r\ncfg.dir = 0;\r\ncfg.timeout = SAS_CONFIG_PAGE_TIMEOUT;\r\nerror = mpt_config(ioc, &cfg);\r\nif (error)\r\ngoto out;\r\nif (!hdr.ExtPageLength) {\r\nerror = -ENXIO;\r\ngoto out;\r\n}\r\nbuffer = pci_alloc_consistent(ioc->pcidev, hdr.ExtPageLength * 4,\r\n&dma_handle);\r\nif (!buffer) {\r\nerror = -ENOMEM;\r\ngoto out;\r\n}\r\ncfg.physAddr = dma_handle;\r\ncfg.action = MPI_CONFIG_ACTION_PAGE_READ_CURRENT;\r\nerror = mpt_config(ioc, &cfg);\r\nif (error)\r\ngoto out_free_consistent;\r\nmemcpy(&le_identifier, &buffer->EnclosureLogicalID, sizeof(__le64));\r\nenclosure->enclosure_logical_id = le64_to_cpu(le_identifier);\r\nenclosure->enclosure_handle = le16_to_cpu(buffer->EnclosureHandle);\r\nenclosure->flags = le16_to_cpu(buffer->Flags);\r\nenclosure->num_slot = le16_to_cpu(buffer->NumSlots);\r\nenclosure->start_slot = le16_to_cpu(buffer->StartSlot);\r\nenclosure->start_id = buffer->StartTargetID;\r\nenclosure->start_channel = buffer->StartBus;\r\nenclosure->sep_id = buffer->SEPTargetID;\r\nenclosure->sep_channel = buffer->SEPBus;\r\nout_free_consistent:\r\npci_free_consistent(ioc->pcidev, hdr.ExtPageLength * 4,\r\nbuffer, dma_handle);\r\nout:\r\nreturn error;\r\n}\r\nstatic int\r\nmptsas_add_end_device(MPT_ADAPTER *ioc, struct mptsas_phyinfo *phy_info)\r\n{\r\nstruct sas_rphy *rphy;\r\nstruct sas_port *port;\r\nstruct sas_identify identify;\r\nchar *ds = NULL;\r\nu8 fw_id;\r\nif (!phy_info) {\r\ndfailprintk(ioc, printk(MYIOC_s_ERR_FMT\r\n"%s: exit at line=%d\n", ioc->name,\r\n__func__, __LINE__));\r\nreturn 1;\r\n}\r\nfw_id = phy_info->attached.id;\r\nif (mptsas_get_rphy(phy_info)) {\r\ndfailprintk(ioc, printk(MYIOC_s_ERR_FMT\r\n"%s: fw_id=%d exit at line=%d\n", ioc->name,\r\n__func__, fw_id, __LINE__));\r\nreturn 2;\r\n}\r\nport = mptsas_get_port(phy_info);\r\nif (!port) {\r\ndfailprintk(ioc, printk(MYIOC_s_ERR_FMT\r\n"%s: fw_id=%d exit at line=%d\n", ioc->name,\r\n__func__, fw_id, __LINE__));\r\nreturn 3;\r\n}\r\nif (phy_info->attached.device_info &\r\nMPI_SAS_DEVICE_INFO_SSP_TARGET)\r\nds = "ssp";\r\nif (phy_info->attached.device_info &\r\nMPI_SAS_DEVICE_INFO_STP_TARGET)\r\nds = "stp";\r\nif (phy_info->attached.device_info &\r\nMPI_SAS_DEVICE_INFO_SATA_DEVICE)\r\nds = "sata";\r\nprintk(MYIOC_s_INFO_FMT "attaching %s device: fw_channel %d, fw_id %d,"\r\n" phy %d, sas_addr 0x%llx\n", ioc->name, ds,\r\nphy_info->attached.channel, phy_info->attached.id,\r\nphy_info->attached.phy_id, (unsigned long long)\r\nphy_info->attached.sas_address);\r\nmptsas_parse_device_info(&identify, &phy_info->attached);\r\nrphy = sas_end_device_alloc(port);\r\nif (!rphy) {\r\ndfailprintk(ioc, printk(MYIOC_s_ERR_FMT\r\n"%s: fw_id=%d exit at line=%d\n", ioc->name,\r\n__func__, fw_id, __LINE__));\r\nreturn 5;\r\n}\r\nrphy->identify = identify;\r\nif (sas_rphy_add(rphy)) {\r\ndfailprintk(ioc, printk(MYIOC_s_ERR_FMT\r\n"%s: fw_id=%d exit at line=%d\n", ioc->name,\r\n__func__, fw_id, __LINE__));\r\nsas_rphy_free(rphy);\r\nreturn 6;\r\n}\r\nmptsas_set_rphy(ioc, phy_info, rphy);\r\nreturn 0;\r\n}\r\nstatic void\r\nmptsas_del_end_device(MPT_ADAPTER *ioc, struct mptsas_phyinfo *phy_info)\r\n{\r\nstruct sas_rphy *rphy;\r\nstruct sas_port *port;\r\nstruct mptsas_portinfo *port_info;\r\nstruct mptsas_phyinfo *phy_info_parent;\r\nint i;\r\nchar *ds = NULL;\r\nu8 fw_id;\r\nu64 sas_address;\r\nif (!phy_info)\r\nreturn;\r\nfw_id = phy_info->attached.id;\r\nsas_address = phy_info->attached.sas_address;\r\nif (!phy_info->port_details) {\r\ndfailprintk(ioc, printk(MYIOC_s_ERR_FMT\r\n"%s: fw_id=%d exit at line=%d\n", ioc->name,\r\n__func__, fw_id, __LINE__));\r\nreturn;\r\n}\r\nrphy = mptsas_get_rphy(phy_info);\r\nif (!rphy) {\r\ndfailprintk(ioc, printk(MYIOC_s_ERR_FMT\r\n"%s: fw_id=%d exit at line=%d\n", ioc->name,\r\n__func__, fw_id, __LINE__));\r\nreturn;\r\n}\r\nif (phy_info->attached.device_info & MPI_SAS_DEVICE_INFO_SSP_INITIATOR\r\n|| phy_info->attached.device_info\r\n& MPI_SAS_DEVICE_INFO_SMP_INITIATOR\r\n|| phy_info->attached.device_info\r\n& MPI_SAS_DEVICE_INFO_STP_INITIATOR)\r\nds = "initiator";\r\nif (phy_info->attached.device_info &\r\nMPI_SAS_DEVICE_INFO_SSP_TARGET)\r\nds = "ssp";\r\nif (phy_info->attached.device_info &\r\nMPI_SAS_DEVICE_INFO_STP_TARGET)\r\nds = "stp";\r\nif (phy_info->attached.device_info &\r\nMPI_SAS_DEVICE_INFO_SATA_DEVICE)\r\nds = "sata";\r\ndev_printk(KERN_DEBUG, &rphy->dev, MYIOC_s_FMT\r\n"removing %s device: fw_channel %d, fw_id %d, phy %d,"\r\n"sas_addr 0x%llx\n", ioc->name, ds, phy_info->attached.channel,\r\nphy_info->attached.id, phy_info->attached.phy_id,\r\n(unsigned long long) sas_address);\r\nport = mptsas_get_port(phy_info);\r\nif (!port) {\r\ndfailprintk(ioc, printk(MYIOC_s_ERR_FMT\r\n"%s: fw_id=%d exit at line=%d\n", ioc->name,\r\n__func__, fw_id, __LINE__));\r\nreturn;\r\n}\r\nport_info = phy_info->portinfo;\r\nphy_info_parent = port_info->phy_info;\r\nfor (i = 0; i < port_info->num_phys; i++, phy_info_parent++) {\r\nif (!phy_info_parent->phy)\r\ncontinue;\r\nif (phy_info_parent->attached.sas_address !=\r\nsas_address)\r\ncontinue;\r\ndev_printk(KERN_DEBUG, &phy_info_parent->phy->dev,\r\nMYIOC_s_FMT "delete phy %d, phy-obj (0x%p)\n",\r\nioc->name, phy_info_parent->phy_id,\r\nphy_info_parent->phy);\r\nsas_port_delete_phy(port, phy_info_parent->phy);\r\n}\r\ndev_printk(KERN_DEBUG, &port->dev, MYIOC_s_FMT\r\n"delete port %d, sas_addr (0x%llx)\n", ioc->name,\r\nport->port_identifier, (unsigned long long)sas_address);\r\nsas_port_delete(port);\r\nmptsas_set_port(ioc, phy_info, NULL);\r\nmptsas_port_delete(ioc, phy_info->port_details);\r\n}\r\nstatic struct mptsas_phyinfo *\r\nmptsas_refreshing_device_handles(MPT_ADAPTER *ioc,\r\nstruct mptsas_devinfo *sas_device)\r\n{\r\nstruct mptsas_phyinfo *phy_info;\r\nstruct mptsas_portinfo *port_info;\r\nint i;\r\nphy_info = mptsas_find_phyinfo_by_sas_address(ioc,\r\nsas_device->sas_address);\r\nif (!phy_info)\r\ngoto out;\r\nport_info = phy_info->portinfo;\r\nif (!port_info)\r\ngoto out;\r\nmutex_lock(&ioc->sas_topology_mutex);\r\nfor (i = 0; i < port_info->num_phys; i++) {\r\nif (port_info->phy_info[i].attached.sas_address !=\r\nsas_device->sas_address)\r\ncontinue;\r\nport_info->phy_info[i].attached.channel = sas_device->channel;\r\nport_info->phy_info[i].attached.id = sas_device->id;\r\nport_info->phy_info[i].attached.sas_address =\r\nsas_device->sas_address;\r\nport_info->phy_info[i].attached.handle = sas_device->handle;\r\nport_info->phy_info[i].attached.handle_parent =\r\nsas_device->handle_parent;\r\nport_info->phy_info[i].attached.handle_enclosure =\r\nsas_device->handle_enclosure;\r\n}\r\nmutex_unlock(&ioc->sas_topology_mutex);\r\nout:\r\nreturn phy_info;\r\n}\r\nstatic void\r\nmptsas_firmware_event_work(struct work_struct *work)\r\n{\r\nstruct fw_event_work *fw_event =\r\ncontainer_of(work, struct fw_event_work, work.work);\r\nMPT_ADAPTER *ioc = fw_event->ioc;\r\nif (fw_event->event == -1) {\r\nif (ioc->in_rescan) {\r\ndevtprintk(ioc, printk(MYIOC_s_DEBUG_FMT\r\n"%s: rescan ignored as it is in progress\n",\r\nioc->name, __func__));\r\nreturn;\r\n}\r\ndevtprintk(ioc, printk(MYIOC_s_DEBUG_FMT "%s: rescan after "\r\n"reset\n", ioc->name, __func__));\r\nioc->in_rescan = 1;\r\nmptsas_not_responding_devices(ioc);\r\nmptsas_scan_sas_topology(ioc);\r\nioc->in_rescan = 0;\r\nmptsas_free_fw_event(ioc, fw_event);\r\nmptsas_fw_event_on(ioc);\r\nreturn;\r\n}\r\nif (ioc->fw_events_off) {\r\nmptsas_free_fw_event(ioc, fw_event);\r\nreturn;\r\n}\r\ndevtprintk(ioc, printk(MYIOC_s_DEBUG_FMT "%s: fw_event=(0x%p), "\r\n"event = (0x%02x)\n", ioc->name, __func__, fw_event,\r\n(fw_event->event & 0xFF)));\r\nswitch (fw_event->event) {\r\ncase MPI_EVENT_SAS_DEVICE_STATUS_CHANGE:\r\nmptsas_send_sas_event(fw_event);\r\nbreak;\r\ncase MPI_EVENT_INTEGRATED_RAID:\r\nmptsas_send_raid_event(fw_event);\r\nbreak;\r\ncase MPI_EVENT_IR2:\r\nmptsas_send_ir2_event(fw_event);\r\nbreak;\r\ncase MPI_EVENT_PERSISTENT_TABLE_FULL:\r\nmptbase_sas_persist_operation(ioc,\r\nMPI_SAS_OP_CLEAR_NOT_PRESENT);\r\nmptsas_free_fw_event(ioc, fw_event);\r\nbreak;\r\ncase MPI_EVENT_SAS_BROADCAST_PRIMITIVE:\r\nmptsas_broadcast_primative_work(fw_event);\r\nbreak;\r\ncase MPI_EVENT_SAS_EXPANDER_STATUS_CHANGE:\r\nmptsas_send_expander_event(fw_event);\r\nbreak;\r\ncase MPI_EVENT_SAS_PHY_LINK_STATUS:\r\nmptsas_send_link_status_event(fw_event);\r\nbreak;\r\ncase MPI_EVENT_QUEUE_FULL:\r\nmptsas_handle_queue_full_event(fw_event);\r\nbreak;\r\n}\r\n}\r\nstatic int\r\nmptsas_slave_configure(struct scsi_device *sdev)\r\n{\r\nstruct Scsi_Host *host = sdev->host;\r\nMPT_SCSI_HOST *hd = shost_priv(host);\r\nMPT_ADAPTER *ioc = hd->ioc;\r\nVirtDevice *vdevice = sdev->hostdata;\r\nif (vdevice->vtarget->deleted) {\r\nsdev_printk(KERN_INFO, sdev, "clearing deleted flag\n");\r\nvdevice->vtarget->deleted = 0;\r\n}\r\nif (sdev->channel == MPTSAS_RAID_CHANNEL) {\r\nmptsas_add_device_component_starget_ir(ioc, scsi_target(sdev));\r\ngoto out;\r\n}\r\nsas_read_port_mode_page(sdev);\r\nmptsas_add_device_component_starget(ioc, scsi_target(sdev));\r\nout:\r\nreturn mptscsih_slave_configure(sdev);\r\n}\r\nstatic int\r\nmptsas_target_alloc(struct scsi_target *starget)\r\n{\r\nstruct Scsi_Host *host = dev_to_shost(&starget->dev);\r\nMPT_SCSI_HOST *hd = shost_priv(host);\r\nVirtTarget *vtarget;\r\nu8 id, channel;\r\nstruct sas_rphy *rphy;\r\nstruct mptsas_portinfo *p;\r\nint i;\r\nMPT_ADAPTER *ioc = hd->ioc;\r\nvtarget = kzalloc(sizeof(VirtTarget), GFP_KERNEL);\r\nif (!vtarget)\r\nreturn -ENOMEM;\r\nvtarget->starget = starget;\r\nvtarget->ioc_id = ioc->id;\r\nvtarget->tflags = MPT_TARGET_FLAGS_Q_YES;\r\nid = starget->id;\r\nchannel = 0;\r\nif (starget->channel == MPTSAS_RAID_CHANNEL) {\r\nif (!ioc->raid_data.pIocPg2) {\r\nkfree(vtarget);\r\nreturn -ENXIO;\r\n}\r\nfor (i = 0; i < ioc->raid_data.pIocPg2->NumActiveVolumes; i++) {\r\nif (id == ioc->raid_data.pIocPg2->\r\nRaidVolume[i].VolumeID) {\r\nchannel = ioc->raid_data.pIocPg2->\r\nRaidVolume[i].VolumeBus;\r\n}\r\n}\r\nvtarget->raidVolume = 1;\r\ngoto out;\r\n}\r\nrphy = dev_to_rphy(starget->dev.parent);\r\nmutex_lock(&ioc->sas_topology_mutex);\r\nlist_for_each_entry(p, &ioc->sas_topology, list) {\r\nfor (i = 0; i < p->num_phys; i++) {\r\nif (p->phy_info[i].attached.sas_address !=\r\nrphy->identify.sas_address)\r\ncontinue;\r\nid = p->phy_info[i].attached.id;\r\nchannel = p->phy_info[i].attached.channel;\r\nmptsas_set_starget(&p->phy_info[i], starget);\r\nif (mptscsih_is_phys_disk(ioc, channel, id)) {\r\nid = mptscsih_raid_id_to_num(ioc,\r\nchannel, id);\r\nvtarget->tflags |=\r\nMPT_TARGET_FLAGS_RAID_COMPONENT;\r\np->phy_info[i].attached.phys_disk_num = id;\r\n}\r\nmutex_unlock(&ioc->sas_topology_mutex);\r\ngoto out;\r\n}\r\n}\r\nmutex_unlock(&ioc->sas_topology_mutex);\r\nkfree(vtarget);\r\nreturn -ENXIO;\r\nout:\r\nvtarget->id = id;\r\nvtarget->channel = channel;\r\nstarget->hostdata = vtarget;\r\nreturn 0;\r\n}\r\nstatic void\r\nmptsas_target_destroy(struct scsi_target *starget)\r\n{\r\nstruct Scsi_Host *host = dev_to_shost(&starget->dev);\r\nMPT_SCSI_HOST *hd = shost_priv(host);\r\nstruct sas_rphy *rphy;\r\nstruct mptsas_portinfo *p;\r\nint i;\r\nMPT_ADAPTER *ioc = hd->ioc;\r\nVirtTarget *vtarget;\r\nif (!starget->hostdata)\r\nreturn;\r\nvtarget = starget->hostdata;\r\nmptsas_del_device_component_by_os(ioc, starget->channel,\r\nstarget->id);\r\nif (starget->channel == MPTSAS_RAID_CHANNEL)\r\ngoto out;\r\nrphy = dev_to_rphy(starget->dev.parent);\r\nlist_for_each_entry(p, &ioc->sas_topology, list) {\r\nfor (i = 0; i < p->num_phys; i++) {\r\nif (p->phy_info[i].attached.sas_address !=\r\nrphy->identify.sas_address)\r\ncontinue;\r\nstarget_printk(KERN_INFO, starget, MYIOC_s_FMT\r\n"delete device: fw_channel %d, fw_id %d, phy %d, "\r\n"sas_addr 0x%llx\n", ioc->name,\r\np->phy_info[i].attached.channel,\r\np->phy_info[i].attached.id,\r\np->phy_info[i].attached.phy_id, (unsigned long long)\r\np->phy_info[i].attached.sas_address);\r\nmptsas_set_starget(&p->phy_info[i], NULL);\r\n}\r\n}\r\nout:\r\nvtarget->starget = NULL;\r\nkfree(starget->hostdata);\r\nstarget->hostdata = NULL;\r\n}\r\nstatic int\r\nmptsas_slave_alloc(struct scsi_device *sdev)\r\n{\r\nstruct Scsi_Host *host = sdev->host;\r\nMPT_SCSI_HOST *hd = shost_priv(host);\r\nstruct sas_rphy *rphy;\r\nstruct mptsas_portinfo *p;\r\nVirtDevice *vdevice;\r\nstruct scsi_target *starget;\r\nint i;\r\nMPT_ADAPTER *ioc = hd->ioc;\r\nvdevice = kzalloc(sizeof(VirtDevice), GFP_KERNEL);\r\nif (!vdevice) {\r\nprintk(MYIOC_s_ERR_FMT "slave_alloc kzalloc(%zd) FAILED!\n",\r\nioc->name, sizeof(VirtDevice));\r\nreturn -ENOMEM;\r\n}\r\nstarget = scsi_target(sdev);\r\nvdevice->vtarget = starget->hostdata;\r\nif (sdev->channel == MPTSAS_RAID_CHANNEL)\r\ngoto out;\r\nrphy = dev_to_rphy(sdev->sdev_target->dev.parent);\r\nmutex_lock(&ioc->sas_topology_mutex);\r\nlist_for_each_entry(p, &ioc->sas_topology, list) {\r\nfor (i = 0; i < p->num_phys; i++) {\r\nif (p->phy_info[i].attached.sas_address !=\r\nrphy->identify.sas_address)\r\ncontinue;\r\nvdevice->lun = sdev->lun;\r\nif (mptscsih_is_phys_disk(ioc,\r\np->phy_info[i].attached.channel,\r\np->phy_info[i].attached.id))\r\nsdev->no_uld_attach = 1;\r\nmutex_unlock(&ioc->sas_topology_mutex);\r\ngoto out;\r\n}\r\n}\r\nmutex_unlock(&ioc->sas_topology_mutex);\r\nkfree(vdevice);\r\nreturn -ENXIO;\r\nout:\r\nvdevice->vtarget->num_luns++;\r\nsdev->hostdata = vdevice;\r\nreturn 0;\r\n}\r\nstatic int\r\nmptsas_qcmd(struct Scsi_Host *shost, struct scsi_cmnd *SCpnt)\r\n{\r\nMPT_SCSI_HOST *hd;\r\nMPT_ADAPTER *ioc;\r\nVirtDevice *vdevice = SCpnt->device->hostdata;\r\nif (!vdevice || !vdevice->vtarget || vdevice->vtarget->deleted) {\r\nSCpnt->result = DID_NO_CONNECT << 16;\r\nSCpnt->scsi_done(SCpnt);\r\nreturn 0;\r\n}\r\nhd = shost_priv(shost);\r\nioc = hd->ioc;\r\nif (ioc->sas_discovery_quiesce_io)\r\nreturn SCSI_MLQUEUE_HOST_BUSY;\r\nif (ioc->debug_level & MPT_DEBUG_SCSI)\r\nscsi_print_command(SCpnt);\r\nreturn mptscsih_qcmd(SCpnt);\r\n}\r\nstatic enum blk_eh_timer_return mptsas_eh_timed_out(struct scsi_cmnd *sc)\r\n{\r\nMPT_SCSI_HOST *hd;\r\nMPT_ADAPTER *ioc;\r\nVirtDevice *vdevice;\r\nenum blk_eh_timer_return rc = BLK_EH_NOT_HANDLED;\r\nhd = shost_priv(sc->device->host);\r\nif (hd == NULL) {\r\nprintk(KERN_ERR MYNAM ": %s: Can't locate host! (sc=%p)\n",\r\n__func__, sc);\r\ngoto done;\r\n}\r\nioc = hd->ioc;\r\nif (ioc->bus_type != SAS) {\r\nprintk(KERN_ERR MYNAM ": %s: Wrong bus type (sc=%p)\n",\r\n__func__, sc);\r\ngoto done;\r\n}\r\nif (ioc->ioc_reset_in_progress) {\r\ndtmprintk(ioc, printk(MYIOC_s_WARN_FMT ": %s: ioc is in reset,"\r\n"SML need to reset the timer (sc=%p)\n",\r\nioc->name, __func__, sc));\r\nrc = BLK_EH_RESET_TIMER;\r\n}\r\nvdevice = sc->device->hostdata;\r\nif (vdevice && vdevice->vtarget && (vdevice->vtarget->inDMD\r\n|| vdevice->vtarget->deleted)) {\r\ndtmprintk(ioc, printk(MYIOC_s_WARN_FMT ": %s: target removed "\r\n"or in device removal delay (sc=%p)\n",\r\nioc->name, __func__, sc));\r\nrc = BLK_EH_RESET_TIMER;\r\ngoto done;\r\n}\r\ndone:\r\nreturn rc;\r\n}\r\nstatic int mptsas_get_linkerrors(struct sas_phy *phy)\r\n{\r\nMPT_ADAPTER *ioc = phy_to_ioc(phy);\r\nConfigExtendedPageHeader_t hdr;\r\nCONFIGPARMS cfg;\r\nSasPhyPage1_t *buffer;\r\ndma_addr_t dma_handle;\r\nint error;\r\nif (!scsi_is_sas_phy_local(phy))\r\nreturn -EINVAL;\r\nhdr.PageVersion = MPI_SASPHY1_PAGEVERSION;\r\nhdr.ExtPageLength = 0;\r\nhdr.PageNumber = 1 ;\r\nhdr.Reserved1 = 0;\r\nhdr.Reserved2 = 0;\r\nhdr.PageType = MPI_CONFIG_PAGETYPE_EXTENDED;\r\nhdr.ExtPageType = MPI_CONFIG_EXTPAGETYPE_SAS_PHY;\r\ncfg.cfghdr.ehdr = &hdr;\r\ncfg.physAddr = -1;\r\ncfg.pageAddr = phy->identify.phy_identifier;\r\ncfg.action = MPI_CONFIG_ACTION_PAGE_HEADER;\r\ncfg.dir = 0;\r\ncfg.timeout = SAS_CONFIG_PAGE_TIMEOUT;\r\nerror = mpt_config(ioc, &cfg);\r\nif (error)\r\nreturn error;\r\nif (!hdr.ExtPageLength)\r\nreturn -ENXIO;\r\nbuffer = pci_alloc_consistent(ioc->pcidev, hdr.ExtPageLength * 4,\r\n&dma_handle);\r\nif (!buffer)\r\nreturn -ENOMEM;\r\ncfg.physAddr = dma_handle;\r\ncfg.action = MPI_CONFIG_ACTION_PAGE_READ_CURRENT;\r\nerror = mpt_config(ioc, &cfg);\r\nif (error)\r\ngoto out_free_consistent;\r\nmptsas_print_phy_pg1(ioc, buffer);\r\nphy->invalid_dword_count = le32_to_cpu(buffer->InvalidDwordCount);\r\nphy->running_disparity_error_count =\r\nle32_to_cpu(buffer->RunningDisparityErrorCount);\r\nphy->loss_of_dword_sync_count =\r\nle32_to_cpu(buffer->LossDwordSynchCount);\r\nphy->phy_reset_problem_count =\r\nle32_to_cpu(buffer->PhyResetProblemCount);\r\nout_free_consistent:\r\npci_free_consistent(ioc->pcidev, hdr.ExtPageLength * 4,\r\nbuffer, dma_handle);\r\nreturn error;\r\n}\r\nstatic int mptsas_mgmt_done(MPT_ADAPTER *ioc, MPT_FRAME_HDR *req,\r\nMPT_FRAME_HDR *reply)\r\n{\r\nioc->sas_mgmt.status |= MPT_MGMT_STATUS_COMMAND_GOOD;\r\nif (reply != NULL) {\r\nioc->sas_mgmt.status |= MPT_MGMT_STATUS_RF_VALID;\r\nmemcpy(ioc->sas_mgmt.reply, reply,\r\nmin(ioc->reply_sz, 4 * reply->u.reply.MsgLength));\r\n}\r\nif (ioc->sas_mgmt.status & MPT_MGMT_STATUS_PENDING) {\r\nioc->sas_mgmt.status &= ~MPT_MGMT_STATUS_PENDING;\r\ncomplete(&ioc->sas_mgmt.done);\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int mptsas_phy_reset(struct sas_phy *phy, int hard_reset)\r\n{\r\nMPT_ADAPTER *ioc = phy_to_ioc(phy);\r\nSasIoUnitControlRequest_t *req;\r\nSasIoUnitControlReply_t *reply;\r\nMPT_FRAME_HDR *mf;\r\nMPIHeader_t *hdr;\r\nunsigned long timeleft;\r\nint error = -ERESTARTSYS;\r\nif (!scsi_is_sas_phy_local(phy))\r\nreturn -EINVAL;\r\nif (phy->identify.target_port_protocols & SAS_PROTOCOL_SMP)\r\nreturn -ENXIO;\r\nif (mutex_lock_interruptible(&ioc->sas_mgmt.mutex))\r\ngoto out;\r\nmf = mpt_get_msg_frame(mptsasMgmtCtx, ioc);\r\nif (!mf) {\r\nerror = -ENOMEM;\r\ngoto out_unlock;\r\n}\r\nhdr = (MPIHeader_t *) mf;\r\nreq = (SasIoUnitControlRequest_t *)mf;\r\nmemset(req, 0, sizeof(SasIoUnitControlRequest_t));\r\nreq->Function = MPI_FUNCTION_SAS_IO_UNIT_CONTROL;\r\nreq->MsgContext = hdr->MsgContext;\r\nreq->Operation = hard_reset ?\r\nMPI_SAS_OP_PHY_HARD_RESET : MPI_SAS_OP_PHY_LINK_RESET;\r\nreq->PhyNum = phy->identify.phy_identifier;\r\nINITIALIZE_MGMT_STATUS(ioc->sas_mgmt.status)\r\nmpt_put_msg_frame(mptsasMgmtCtx, ioc, mf);\r\ntimeleft = wait_for_completion_timeout(&ioc->sas_mgmt.done,\r\n10 * HZ);\r\nif (!(ioc->sas_mgmt.status & MPT_MGMT_STATUS_COMMAND_GOOD)) {\r\nerror = -ETIME;\r\nmpt_free_msg_frame(ioc, mf);\r\nif (ioc->sas_mgmt.status & MPT_MGMT_STATUS_DID_IOCRESET)\r\ngoto out_unlock;\r\nif (!timeleft)\r\nmpt_Soft_Hard_ResetHandler(ioc, CAN_SLEEP);\r\ngoto out_unlock;\r\n}\r\nif ((ioc->sas_mgmt.status &\r\nMPT_MGMT_STATUS_RF_VALID) == 0) {\r\nerror = -ENXIO;\r\ngoto out_unlock;\r\n}\r\nreply = (SasIoUnitControlReply_t *)ioc->sas_mgmt.reply;\r\nif (reply->IOCStatus != MPI_IOCSTATUS_SUCCESS) {\r\nprintk(MYIOC_s_INFO_FMT "%s: IOCStatus=0x%X IOCLogInfo=0x%X\n",\r\nioc->name, __func__, reply->IOCStatus, reply->IOCLogInfo);\r\nerror = -ENXIO;\r\ngoto out_unlock;\r\n}\r\nerror = 0;\r\nout_unlock:\r\nCLEAR_MGMT_STATUS(ioc->sas_mgmt.status)\r\nmutex_unlock(&ioc->sas_mgmt.mutex);\r\nout:\r\nreturn error;\r\n}\r\nstatic int\r\nmptsas_get_enclosure_identifier(struct sas_rphy *rphy, u64 *identifier)\r\n{\r\nMPT_ADAPTER *ioc = rphy_to_ioc(rphy);\r\nint i, error;\r\nstruct mptsas_portinfo *p;\r\nstruct mptsas_enclosure enclosure_info;\r\nu64 enclosure_handle;\r\nmutex_lock(&ioc->sas_topology_mutex);\r\nlist_for_each_entry(p, &ioc->sas_topology, list) {\r\nfor (i = 0; i < p->num_phys; i++) {\r\nif (p->phy_info[i].attached.sas_address ==\r\nrphy->identify.sas_address) {\r\nenclosure_handle = p->phy_info[i].\r\nattached.handle_enclosure;\r\ngoto found_info;\r\n}\r\n}\r\n}\r\nmutex_unlock(&ioc->sas_topology_mutex);\r\nreturn -ENXIO;\r\nfound_info:\r\nmutex_unlock(&ioc->sas_topology_mutex);\r\nmemset(&enclosure_info, 0, sizeof(struct mptsas_enclosure));\r\nerror = mptsas_sas_enclosure_pg0(ioc, &enclosure_info,\r\n(MPI_SAS_ENCLOS_PGAD_FORM_HANDLE <<\r\nMPI_SAS_ENCLOS_PGAD_FORM_SHIFT), enclosure_handle);\r\nif (!error)\r\n*identifier = enclosure_info.enclosure_logical_id;\r\nreturn error;\r\n}\r\nstatic int\r\nmptsas_get_bay_identifier(struct sas_rphy *rphy)\r\n{\r\nMPT_ADAPTER *ioc = rphy_to_ioc(rphy);\r\nstruct mptsas_portinfo *p;\r\nint i, rc;\r\nmutex_lock(&ioc->sas_topology_mutex);\r\nlist_for_each_entry(p, &ioc->sas_topology, list) {\r\nfor (i = 0; i < p->num_phys; i++) {\r\nif (p->phy_info[i].attached.sas_address ==\r\nrphy->identify.sas_address) {\r\nrc = p->phy_info[i].attached.slot;\r\ngoto out;\r\n}\r\n}\r\n}\r\nrc = -ENXIO;\r\nout:\r\nmutex_unlock(&ioc->sas_topology_mutex);\r\nreturn rc;\r\n}\r\nstatic int mptsas_smp_handler(struct Scsi_Host *shost, struct sas_rphy *rphy,\r\nstruct request *req)\r\n{\r\nMPT_ADAPTER *ioc = ((MPT_SCSI_HOST *) shost->hostdata)->ioc;\r\nMPT_FRAME_HDR *mf;\r\nSmpPassthroughRequest_t *smpreq;\r\nstruct request *rsp = req->next_rq;\r\nint ret;\r\nint flagsLength;\r\nunsigned long timeleft;\r\nchar *psge;\r\ndma_addr_t dma_addr_in = 0;\r\ndma_addr_t dma_addr_out = 0;\r\nu64 sas_address = 0;\r\nif (!rsp) {\r\nprintk(MYIOC_s_ERR_FMT "%s: the smp response space is missing\n",\r\nioc->name, __func__);\r\nreturn -EINVAL;\r\n}\r\nif (bio_multiple_segments(req->bio) ||\r\nbio_multiple_segments(rsp->bio)) {\r\nprintk(MYIOC_s_ERR_FMT "%s: multiple segments req %u, rsp %u\n",\r\nioc->name, __func__, blk_rq_bytes(req), blk_rq_bytes(rsp));\r\nreturn -EINVAL;\r\n}\r\nret = mutex_lock_interruptible(&ioc->sas_mgmt.mutex);\r\nif (ret)\r\ngoto out;\r\nmf = mpt_get_msg_frame(mptsasMgmtCtx, ioc);\r\nif (!mf) {\r\nret = -ENOMEM;\r\ngoto out_unlock;\r\n}\r\nsmpreq = (SmpPassthroughRequest_t *)mf;\r\nmemset(smpreq, 0, sizeof(*smpreq));\r\nsmpreq->RequestDataLength = cpu_to_le16(blk_rq_bytes(req) - 4);\r\nsmpreq->Function = MPI_FUNCTION_SMP_PASSTHROUGH;\r\nif (rphy)\r\nsas_address = rphy->identify.sas_address;\r\nelse {\r\nstruct mptsas_portinfo *port_info;\r\nmutex_lock(&ioc->sas_topology_mutex);\r\nport_info = ioc->hba_port_info;\r\nif (port_info && port_info->phy_info)\r\nsas_address =\r\nport_info->phy_info[0].phy->identify.sas_address;\r\nmutex_unlock(&ioc->sas_topology_mutex);\r\n}\r\n*((u64 *)&smpreq->SASAddress) = cpu_to_le64(sas_address);\r\npsge = (char *)\r\n(((int *) mf) + (offsetof(SmpPassthroughRequest_t, SGL) / 4));\r\nflagsLength = (MPI_SGE_FLAGS_SIMPLE_ELEMENT |\r\nMPI_SGE_FLAGS_END_OF_BUFFER |\r\nMPI_SGE_FLAGS_DIRECTION)\r\n<< MPI_SGE_FLAGS_SHIFT;\r\nflagsLength |= (blk_rq_bytes(req) - 4);\r\ndma_addr_out = pci_map_single(ioc->pcidev, bio_data(req->bio),\r\nblk_rq_bytes(req), PCI_DMA_BIDIRECTIONAL);\r\nif (!dma_addr_out)\r\ngoto put_mf;\r\nioc->add_sge(psge, flagsLength, dma_addr_out);\r\npsge += ioc->SGE_size;\r\nflagsLength = MPI_SGE_FLAGS_SIMPLE_ELEMENT |\r\nMPI_SGE_FLAGS_SYSTEM_ADDRESS |\r\nMPI_SGE_FLAGS_IOC_TO_HOST |\r\nMPI_SGE_FLAGS_END_OF_BUFFER;\r\nflagsLength = flagsLength << MPI_SGE_FLAGS_SHIFT;\r\nflagsLength |= blk_rq_bytes(rsp) + 4;\r\ndma_addr_in = pci_map_single(ioc->pcidev, bio_data(rsp->bio),\r\nblk_rq_bytes(rsp), PCI_DMA_BIDIRECTIONAL);\r\nif (!dma_addr_in)\r\ngoto unmap;\r\nioc->add_sge(psge, flagsLength, dma_addr_in);\r\nINITIALIZE_MGMT_STATUS(ioc->sas_mgmt.status)\r\nmpt_put_msg_frame(mptsasMgmtCtx, ioc, mf);\r\ntimeleft = wait_for_completion_timeout(&ioc->sas_mgmt.done, 10 * HZ);\r\nif (!(ioc->sas_mgmt.status & MPT_MGMT_STATUS_COMMAND_GOOD)) {\r\nret = -ETIME;\r\nmpt_free_msg_frame(ioc, mf);\r\nmf = NULL;\r\nif (ioc->sas_mgmt.status & MPT_MGMT_STATUS_DID_IOCRESET)\r\ngoto unmap;\r\nif (!timeleft)\r\nmpt_Soft_Hard_ResetHandler(ioc, CAN_SLEEP);\r\ngoto unmap;\r\n}\r\nmf = NULL;\r\nif (ioc->sas_mgmt.status & MPT_MGMT_STATUS_RF_VALID) {\r\nSmpPassthroughReply_t *smprep;\r\nsmprep = (SmpPassthroughReply_t *)ioc->sas_mgmt.reply;\r\nmemcpy(req->sense, smprep, sizeof(*smprep));\r\nreq->sense_len = sizeof(*smprep);\r\nreq->resid_len = 0;\r\nrsp->resid_len -= smprep->ResponseDataLength;\r\n} else {\r\nprintk(MYIOC_s_ERR_FMT\r\n"%s: smp passthru reply failed to be returned\n",\r\nioc->name, __func__);\r\nret = -ENXIO;\r\n}\r\nunmap:\r\nif (dma_addr_out)\r\npci_unmap_single(ioc->pcidev, dma_addr_out, blk_rq_bytes(req),\r\nPCI_DMA_BIDIRECTIONAL);\r\nif (dma_addr_in)\r\npci_unmap_single(ioc->pcidev, dma_addr_in, blk_rq_bytes(rsp),\r\nPCI_DMA_BIDIRECTIONAL);\r\nput_mf:\r\nif (mf)\r\nmpt_free_msg_frame(ioc, mf);\r\nout_unlock:\r\nCLEAR_MGMT_STATUS(ioc->sas_mgmt.status)\r\nmutex_unlock(&ioc->sas_mgmt.mutex);\r\nout:\r\nreturn ret;\r\n}\r\nstatic int\r\nmptsas_sas_io_unit_pg0(MPT_ADAPTER *ioc, struct mptsas_portinfo *port_info)\r\n{\r\nConfigExtendedPageHeader_t hdr;\r\nCONFIGPARMS cfg;\r\nSasIOUnitPage0_t *buffer;\r\ndma_addr_t dma_handle;\r\nint error, i;\r\nhdr.PageVersion = MPI_SASIOUNITPAGE0_PAGEVERSION;\r\nhdr.ExtPageLength = 0;\r\nhdr.PageNumber = 0;\r\nhdr.Reserved1 = 0;\r\nhdr.Reserved2 = 0;\r\nhdr.PageType = MPI_CONFIG_PAGETYPE_EXTENDED;\r\nhdr.ExtPageType = MPI_CONFIG_EXTPAGETYPE_SAS_IO_UNIT;\r\ncfg.cfghdr.ehdr = &hdr;\r\ncfg.physAddr = -1;\r\ncfg.pageAddr = 0;\r\ncfg.action = MPI_CONFIG_ACTION_PAGE_HEADER;\r\ncfg.dir = 0;\r\ncfg.timeout = SAS_CONFIG_PAGE_TIMEOUT;\r\nerror = mpt_config(ioc, &cfg);\r\nif (error)\r\ngoto out;\r\nif (!hdr.ExtPageLength) {\r\nerror = -ENXIO;\r\ngoto out;\r\n}\r\nbuffer = pci_alloc_consistent(ioc->pcidev, hdr.ExtPageLength * 4,\r\n&dma_handle);\r\nif (!buffer) {\r\nerror = -ENOMEM;\r\ngoto out;\r\n}\r\ncfg.physAddr = dma_handle;\r\ncfg.action = MPI_CONFIG_ACTION_PAGE_READ_CURRENT;\r\nerror = mpt_config(ioc, &cfg);\r\nif (error)\r\ngoto out_free_consistent;\r\nport_info->num_phys = buffer->NumPhys;\r\nport_info->phy_info = kcalloc(port_info->num_phys,\r\nsizeof(struct mptsas_phyinfo), GFP_KERNEL);\r\nif (!port_info->phy_info) {\r\nerror = -ENOMEM;\r\ngoto out_free_consistent;\r\n}\r\nioc->nvdata_version_persistent =\r\nle16_to_cpu(buffer->NvdataVersionPersistent);\r\nioc->nvdata_version_default =\r\nle16_to_cpu(buffer->NvdataVersionDefault);\r\nfor (i = 0; i < port_info->num_phys; i++) {\r\nmptsas_print_phy_data(ioc, &buffer->PhyData[i]);\r\nport_info->phy_info[i].phy_id = i;\r\nport_info->phy_info[i].port_id =\r\nbuffer->PhyData[i].Port;\r\nport_info->phy_info[i].negotiated_link_rate =\r\nbuffer->PhyData[i].NegotiatedLinkRate;\r\nport_info->phy_info[i].portinfo = port_info;\r\nport_info->phy_info[i].handle =\r\nle16_to_cpu(buffer->PhyData[i].ControllerDevHandle);\r\n}\r\nout_free_consistent:\r\npci_free_consistent(ioc->pcidev, hdr.ExtPageLength * 4,\r\nbuffer, dma_handle);\r\nout:\r\nreturn error;\r\n}\r\nstatic int\r\nmptsas_sas_io_unit_pg1(MPT_ADAPTER *ioc)\r\n{\r\nConfigExtendedPageHeader_t hdr;\r\nCONFIGPARMS cfg;\r\nSasIOUnitPage1_t *buffer;\r\ndma_addr_t dma_handle;\r\nint error;\r\nu8 device_missing_delay;\r\nmemset(&hdr, 0, sizeof(ConfigExtendedPageHeader_t));\r\nmemset(&cfg, 0, sizeof(CONFIGPARMS));\r\ncfg.cfghdr.ehdr = &hdr;\r\ncfg.action = MPI_CONFIG_ACTION_PAGE_HEADER;\r\ncfg.timeout = SAS_CONFIG_PAGE_TIMEOUT;\r\ncfg.cfghdr.ehdr->PageType = MPI_CONFIG_PAGETYPE_EXTENDED;\r\ncfg.cfghdr.ehdr->ExtPageType = MPI_CONFIG_EXTPAGETYPE_SAS_IO_UNIT;\r\ncfg.cfghdr.ehdr->PageVersion = MPI_SASIOUNITPAGE1_PAGEVERSION;\r\ncfg.cfghdr.ehdr->PageNumber = 1;\r\nerror = mpt_config(ioc, &cfg);\r\nif (error)\r\ngoto out;\r\nif (!hdr.ExtPageLength) {\r\nerror = -ENXIO;\r\ngoto out;\r\n}\r\nbuffer = pci_alloc_consistent(ioc->pcidev, hdr.ExtPageLength * 4,\r\n&dma_handle);\r\nif (!buffer) {\r\nerror = -ENOMEM;\r\ngoto out;\r\n}\r\ncfg.physAddr = dma_handle;\r\ncfg.action = MPI_CONFIG_ACTION_PAGE_READ_CURRENT;\r\nerror = mpt_config(ioc, &cfg);\r\nif (error)\r\ngoto out_free_consistent;\r\nioc->io_missing_delay =\r\nle16_to_cpu(buffer->IODeviceMissingDelay);\r\ndevice_missing_delay = buffer->ReportDeviceMissingDelay;\r\nioc->device_missing_delay = (device_missing_delay & MPI_SAS_IOUNIT1_REPORT_MISSING_UNIT_16) ?\r\n(device_missing_delay & MPI_SAS_IOUNIT1_REPORT_MISSING_TIMEOUT_MASK) * 16 :\r\ndevice_missing_delay & MPI_SAS_IOUNIT1_REPORT_MISSING_TIMEOUT_MASK;\r\nout_free_consistent:\r\npci_free_consistent(ioc->pcidev, hdr.ExtPageLength * 4,\r\nbuffer, dma_handle);\r\nout:\r\nreturn error;\r\n}\r\nstatic int\r\nmptsas_sas_phy_pg0(MPT_ADAPTER *ioc, struct mptsas_phyinfo *phy_info,\r\nu32 form, u32 form_specific)\r\n{\r\nConfigExtendedPageHeader_t hdr;\r\nCONFIGPARMS cfg;\r\nSasPhyPage0_t *buffer;\r\ndma_addr_t dma_handle;\r\nint error;\r\nhdr.PageVersion = MPI_SASPHY0_PAGEVERSION;\r\nhdr.ExtPageLength = 0;\r\nhdr.PageNumber = 0;\r\nhdr.Reserved1 = 0;\r\nhdr.Reserved2 = 0;\r\nhdr.PageType = MPI_CONFIG_PAGETYPE_EXTENDED;\r\nhdr.ExtPageType = MPI_CONFIG_EXTPAGETYPE_SAS_PHY;\r\ncfg.cfghdr.ehdr = &hdr;\r\ncfg.dir = 0;\r\ncfg.timeout = SAS_CONFIG_PAGE_TIMEOUT;\r\ncfg.physAddr = -1;\r\ncfg.pageAddr = form + form_specific;\r\ncfg.action = MPI_CONFIG_ACTION_PAGE_HEADER;\r\nerror = mpt_config(ioc, &cfg);\r\nif (error)\r\ngoto out;\r\nif (!hdr.ExtPageLength) {\r\nerror = -ENXIO;\r\ngoto out;\r\n}\r\nbuffer = pci_alloc_consistent(ioc->pcidev, hdr.ExtPageLength * 4,\r\n&dma_handle);\r\nif (!buffer) {\r\nerror = -ENOMEM;\r\ngoto out;\r\n}\r\ncfg.physAddr = dma_handle;\r\ncfg.action = MPI_CONFIG_ACTION_PAGE_READ_CURRENT;\r\nerror = mpt_config(ioc, &cfg);\r\nif (error)\r\ngoto out_free_consistent;\r\nmptsas_print_phy_pg0(ioc, buffer);\r\nphy_info->hw_link_rate = buffer->HwLinkRate;\r\nphy_info->programmed_link_rate = buffer->ProgrammedLinkRate;\r\nphy_info->identify.handle = le16_to_cpu(buffer->OwnerDevHandle);\r\nphy_info->attached.handle = le16_to_cpu(buffer->AttachedDevHandle);\r\nout_free_consistent:\r\npci_free_consistent(ioc->pcidev, hdr.ExtPageLength * 4,\r\nbuffer, dma_handle);\r\nout:\r\nreturn error;\r\n}\r\nstatic int\r\nmptsas_sas_device_pg0(MPT_ADAPTER *ioc, struct mptsas_devinfo *device_info,\r\nu32 form, u32 form_specific)\r\n{\r\nConfigExtendedPageHeader_t hdr;\r\nCONFIGPARMS cfg;\r\nSasDevicePage0_t *buffer;\r\ndma_addr_t dma_handle;\r\n__le64 sas_address;\r\nint error=0;\r\nhdr.PageVersion = MPI_SASDEVICE0_PAGEVERSION;\r\nhdr.ExtPageLength = 0;\r\nhdr.PageNumber = 0;\r\nhdr.Reserved1 = 0;\r\nhdr.Reserved2 = 0;\r\nhdr.PageType = MPI_CONFIG_PAGETYPE_EXTENDED;\r\nhdr.ExtPageType = MPI_CONFIG_EXTPAGETYPE_SAS_DEVICE;\r\ncfg.cfghdr.ehdr = &hdr;\r\ncfg.pageAddr = form + form_specific;\r\ncfg.physAddr = -1;\r\ncfg.action = MPI_CONFIG_ACTION_PAGE_HEADER;\r\ncfg.dir = 0;\r\ncfg.timeout = SAS_CONFIG_PAGE_TIMEOUT;\r\nmemset(device_info, 0, sizeof(struct mptsas_devinfo));\r\nerror = mpt_config(ioc, &cfg);\r\nif (error)\r\ngoto out;\r\nif (!hdr.ExtPageLength) {\r\nerror = -ENXIO;\r\ngoto out;\r\n}\r\nbuffer = pci_alloc_consistent(ioc->pcidev, hdr.ExtPageLength * 4,\r\n&dma_handle);\r\nif (!buffer) {\r\nerror = -ENOMEM;\r\ngoto out;\r\n}\r\ncfg.physAddr = dma_handle;\r\ncfg.action = MPI_CONFIG_ACTION_PAGE_READ_CURRENT;\r\nerror = mpt_config(ioc, &cfg);\r\nif (error == MPI_IOCSTATUS_CONFIG_INVALID_PAGE) {\r\nerror = -ENODEV;\r\ngoto out_free_consistent;\r\n}\r\nif (error)\r\ngoto out_free_consistent;\r\nmptsas_print_device_pg0(ioc, buffer);\r\nmemset(device_info, 0, sizeof(struct mptsas_devinfo));\r\ndevice_info->handle = le16_to_cpu(buffer->DevHandle);\r\ndevice_info->handle_parent = le16_to_cpu(buffer->ParentDevHandle);\r\ndevice_info->handle_enclosure =\r\nle16_to_cpu(buffer->EnclosureHandle);\r\ndevice_info->slot = le16_to_cpu(buffer->Slot);\r\ndevice_info->phy_id = buffer->PhyNum;\r\ndevice_info->port_id = buffer->PhysicalPort;\r\ndevice_info->id = buffer->TargetID;\r\ndevice_info->phys_disk_num = ~0;\r\ndevice_info->channel = buffer->Bus;\r\nmemcpy(&sas_address, &buffer->SASAddress, sizeof(__le64));\r\ndevice_info->sas_address = le64_to_cpu(sas_address);\r\ndevice_info->device_info =\r\nle32_to_cpu(buffer->DeviceInfo);\r\ndevice_info->flags = le16_to_cpu(buffer->Flags);\r\nout_free_consistent:\r\npci_free_consistent(ioc->pcidev, hdr.ExtPageLength * 4,\r\nbuffer, dma_handle);\r\nout:\r\nreturn error;\r\n}\r\nstatic int\r\nmptsas_sas_expander_pg0(MPT_ADAPTER *ioc, struct mptsas_portinfo *port_info,\r\nu32 form, u32 form_specific)\r\n{\r\nConfigExtendedPageHeader_t hdr;\r\nCONFIGPARMS cfg;\r\nSasExpanderPage0_t *buffer;\r\ndma_addr_t dma_handle;\r\nint i, error;\r\n__le64 sas_address;\r\nmemset(port_info, 0, sizeof(struct mptsas_portinfo));\r\nhdr.PageVersion = MPI_SASEXPANDER0_PAGEVERSION;\r\nhdr.ExtPageLength = 0;\r\nhdr.PageNumber = 0;\r\nhdr.Reserved1 = 0;\r\nhdr.Reserved2 = 0;\r\nhdr.PageType = MPI_CONFIG_PAGETYPE_EXTENDED;\r\nhdr.ExtPageType = MPI_CONFIG_EXTPAGETYPE_SAS_EXPANDER;\r\ncfg.cfghdr.ehdr = &hdr;\r\ncfg.physAddr = -1;\r\ncfg.pageAddr = form + form_specific;\r\ncfg.action = MPI_CONFIG_ACTION_PAGE_HEADER;\r\ncfg.dir = 0;\r\ncfg.timeout = SAS_CONFIG_PAGE_TIMEOUT;\r\nmemset(port_info, 0, sizeof(struct mptsas_portinfo));\r\nerror = mpt_config(ioc, &cfg);\r\nif (error)\r\ngoto out;\r\nif (!hdr.ExtPageLength) {\r\nerror = -ENXIO;\r\ngoto out;\r\n}\r\nbuffer = pci_alloc_consistent(ioc->pcidev, hdr.ExtPageLength * 4,\r\n&dma_handle);\r\nif (!buffer) {\r\nerror = -ENOMEM;\r\ngoto out;\r\n}\r\ncfg.physAddr = dma_handle;\r\ncfg.action = MPI_CONFIG_ACTION_PAGE_READ_CURRENT;\r\nerror = mpt_config(ioc, &cfg);\r\nif (error == MPI_IOCSTATUS_CONFIG_INVALID_PAGE) {\r\nerror = -ENODEV;\r\ngoto out_free_consistent;\r\n}\r\nif (error)\r\ngoto out_free_consistent;\r\nport_info->num_phys = (buffer->NumPhys) ? buffer->NumPhys : 1;\r\nport_info->phy_info = kcalloc(port_info->num_phys,\r\nsizeof(struct mptsas_phyinfo), GFP_KERNEL);\r\nif (!port_info->phy_info) {\r\nerror = -ENOMEM;\r\ngoto out_free_consistent;\r\n}\r\nmemcpy(&sas_address, &buffer->SASAddress, sizeof(__le64));\r\nfor (i = 0; i < port_info->num_phys; i++) {\r\nport_info->phy_info[i].portinfo = port_info;\r\nport_info->phy_info[i].handle =\r\nle16_to_cpu(buffer->DevHandle);\r\nport_info->phy_info[i].identify.sas_address =\r\nle64_to_cpu(sas_address);\r\nport_info->phy_info[i].identify.handle_parent =\r\nle16_to_cpu(buffer->ParentDevHandle);\r\n}\r\nout_free_consistent:\r\npci_free_consistent(ioc->pcidev, hdr.ExtPageLength * 4,\r\nbuffer, dma_handle);\r\nout:\r\nreturn error;\r\n}\r\nstatic int\r\nmptsas_sas_expander_pg1(MPT_ADAPTER *ioc, struct mptsas_phyinfo *phy_info,\r\nu32 form, u32 form_specific)\r\n{\r\nConfigExtendedPageHeader_t hdr;\r\nCONFIGPARMS cfg;\r\nSasExpanderPage1_t *buffer;\r\ndma_addr_t dma_handle;\r\nint error=0;\r\nhdr.PageVersion = MPI_SASEXPANDER1_PAGEVERSION;\r\nhdr.ExtPageLength = 0;\r\nhdr.PageNumber = 1;\r\nhdr.Reserved1 = 0;\r\nhdr.Reserved2 = 0;\r\nhdr.PageType = MPI_CONFIG_PAGETYPE_EXTENDED;\r\nhdr.ExtPageType = MPI_CONFIG_EXTPAGETYPE_SAS_EXPANDER;\r\ncfg.cfghdr.ehdr = &hdr;\r\ncfg.physAddr = -1;\r\ncfg.pageAddr = form + form_specific;\r\ncfg.action = MPI_CONFIG_ACTION_PAGE_HEADER;\r\ncfg.dir = 0;\r\ncfg.timeout = SAS_CONFIG_PAGE_TIMEOUT;\r\nerror = mpt_config(ioc, &cfg);\r\nif (error)\r\ngoto out;\r\nif (!hdr.ExtPageLength) {\r\nerror = -ENXIO;\r\ngoto out;\r\n}\r\nbuffer = pci_alloc_consistent(ioc->pcidev, hdr.ExtPageLength * 4,\r\n&dma_handle);\r\nif (!buffer) {\r\nerror = -ENOMEM;\r\ngoto out;\r\n}\r\ncfg.physAddr = dma_handle;\r\ncfg.action = MPI_CONFIG_ACTION_PAGE_READ_CURRENT;\r\nerror = mpt_config(ioc, &cfg);\r\nif (error == MPI_IOCSTATUS_CONFIG_INVALID_PAGE) {\r\nerror = -ENODEV;\r\ngoto out_free_consistent;\r\n}\r\nif (error)\r\ngoto out_free_consistent;\r\nmptsas_print_expander_pg1(ioc, buffer);\r\nphy_info->phy_id = buffer->PhyIdentifier;\r\nphy_info->port_id = buffer->PhysicalPort;\r\nphy_info->negotiated_link_rate = buffer->NegotiatedLinkRate;\r\nphy_info->programmed_link_rate = buffer->ProgrammedLinkRate;\r\nphy_info->hw_link_rate = buffer->HwLinkRate;\r\nphy_info->identify.handle = le16_to_cpu(buffer->OwnerDevHandle);\r\nphy_info->attached.handle = le16_to_cpu(buffer->AttachedDevHandle);\r\nout_free_consistent:\r\npci_free_consistent(ioc->pcidev, hdr.ExtPageLength * 4,\r\nbuffer, dma_handle);\r\nout:\r\nreturn error;\r\n}\r\nstatic int\r\nmptsas_exp_repmanufacture_info(MPT_ADAPTER *ioc,\r\nu64 sas_address, struct sas_expander_device *edev)\r\n{\r\nMPT_FRAME_HDR *mf;\r\nSmpPassthroughRequest_t *smpreq;\r\nSmpPassthroughReply_t *smprep;\r\nstruct rep_manu_reply *manufacture_reply;\r\nstruct rep_manu_request *manufacture_request;\r\nint ret;\r\nint flagsLength;\r\nunsigned long timeleft;\r\nchar *psge;\r\nunsigned long flags;\r\nvoid *data_out = NULL;\r\ndma_addr_t data_out_dma = 0;\r\nu32 sz;\r\nspin_lock_irqsave(&ioc->taskmgmt_lock, flags);\r\nif (ioc->ioc_reset_in_progress) {\r\nspin_unlock_irqrestore(&ioc->taskmgmt_lock, flags);\r\nprintk(MYIOC_s_INFO_FMT "%s: host reset in progress!\n",\r\n__func__, ioc->name);\r\nreturn -EFAULT;\r\n}\r\nspin_unlock_irqrestore(&ioc->taskmgmt_lock, flags);\r\nret = mutex_lock_interruptible(&ioc->sas_mgmt.mutex);\r\nif (ret)\r\ngoto out;\r\nmf = mpt_get_msg_frame(mptsasMgmtCtx, ioc);\r\nif (!mf) {\r\nret = -ENOMEM;\r\ngoto out_unlock;\r\n}\r\nsmpreq = (SmpPassthroughRequest_t *)mf;\r\nmemset(smpreq, 0, sizeof(*smpreq));\r\nsz = sizeof(struct rep_manu_request) + sizeof(struct rep_manu_reply);\r\ndata_out = pci_alloc_consistent(ioc->pcidev, sz, &data_out_dma);\r\nif (!data_out) {\r\nprintk(KERN_ERR "Memory allocation failure at %s:%d/%s()!\n",\r\n__FILE__, __LINE__, __func__);\r\nret = -ENOMEM;\r\ngoto put_mf;\r\n}\r\nmanufacture_request = data_out;\r\nmanufacture_request->smp_frame_type = 0x40;\r\nmanufacture_request->function = 1;\r\nmanufacture_request->reserved = 0;\r\nmanufacture_request->request_length = 0;\r\nsmpreq->Function = MPI_FUNCTION_SMP_PASSTHROUGH;\r\nsmpreq->PhysicalPort = 0xFF;\r\n*((u64 *)&smpreq->SASAddress) = cpu_to_le64(sas_address);\r\nsmpreq->RequestDataLength = sizeof(struct rep_manu_request);\r\npsge = (char *)\r\n(((int *) mf) + (offsetof(SmpPassthroughRequest_t, SGL) / 4));\r\nflagsLength = MPI_SGE_FLAGS_SIMPLE_ELEMENT |\r\nMPI_SGE_FLAGS_SYSTEM_ADDRESS |\r\nMPI_SGE_FLAGS_HOST_TO_IOC |\r\nMPI_SGE_FLAGS_END_OF_BUFFER;\r\nflagsLength = flagsLength << MPI_SGE_FLAGS_SHIFT;\r\nflagsLength |= sizeof(struct rep_manu_request);\r\nioc->add_sge(psge, flagsLength, data_out_dma);\r\npsge += ioc->SGE_size;\r\nflagsLength = MPI_SGE_FLAGS_SIMPLE_ELEMENT |\r\nMPI_SGE_FLAGS_SYSTEM_ADDRESS |\r\nMPI_SGE_FLAGS_IOC_TO_HOST |\r\nMPI_SGE_FLAGS_END_OF_BUFFER;\r\nflagsLength = flagsLength << MPI_SGE_FLAGS_SHIFT;\r\nflagsLength |= sizeof(struct rep_manu_reply);\r\nioc->add_sge(psge, flagsLength, data_out_dma +\r\nsizeof(struct rep_manu_request));\r\nINITIALIZE_MGMT_STATUS(ioc->sas_mgmt.status)\r\nmpt_put_msg_frame(mptsasMgmtCtx, ioc, mf);\r\ntimeleft = wait_for_completion_timeout(&ioc->sas_mgmt.done, 10 * HZ);\r\nif (!(ioc->sas_mgmt.status & MPT_MGMT_STATUS_COMMAND_GOOD)) {\r\nret = -ETIME;\r\nmpt_free_msg_frame(ioc, mf);\r\nmf = NULL;\r\nif (ioc->sas_mgmt.status & MPT_MGMT_STATUS_DID_IOCRESET)\r\ngoto out_free;\r\nif (!timeleft)\r\nmpt_Soft_Hard_ResetHandler(ioc, CAN_SLEEP);\r\ngoto out_free;\r\n}\r\nmf = NULL;\r\nif (ioc->sas_mgmt.status & MPT_MGMT_STATUS_RF_VALID) {\r\nu8 *tmp;\r\nsmprep = (SmpPassthroughReply_t *)ioc->sas_mgmt.reply;\r\nif (le16_to_cpu(smprep->ResponseDataLength) !=\r\nsizeof(struct rep_manu_reply))\r\ngoto out_free;\r\nmanufacture_reply = data_out + sizeof(struct rep_manu_request);\r\nstrncpy(edev->vendor_id, manufacture_reply->vendor_id,\r\nSAS_EXPANDER_VENDOR_ID_LEN);\r\nstrncpy(edev->product_id, manufacture_reply->product_id,\r\nSAS_EXPANDER_PRODUCT_ID_LEN);\r\nstrncpy(edev->product_rev, manufacture_reply->product_rev,\r\nSAS_EXPANDER_PRODUCT_REV_LEN);\r\nedev->level = manufacture_reply->sas_format;\r\nif (manufacture_reply->sas_format) {\r\nstrncpy(edev->component_vendor_id,\r\nmanufacture_reply->component_vendor_id,\r\nSAS_EXPANDER_COMPONENT_VENDOR_ID_LEN);\r\ntmp = (u8 *)&manufacture_reply->component_id;\r\nedev->component_id = tmp[0] << 8 | tmp[1];\r\nedev->component_revision_id =\r\nmanufacture_reply->component_revision_id;\r\n}\r\n} else {\r\nprintk(MYIOC_s_ERR_FMT\r\n"%s: smp passthru reply failed to be returned\n",\r\nioc->name, __func__);\r\nret = -ENXIO;\r\n}\r\nout_free:\r\nif (data_out_dma)\r\npci_free_consistent(ioc->pcidev, sz, data_out, data_out_dma);\r\nput_mf:\r\nif (mf)\r\nmpt_free_msg_frame(ioc, mf);\r\nout_unlock:\r\nCLEAR_MGMT_STATUS(ioc->sas_mgmt.status)\r\nmutex_unlock(&ioc->sas_mgmt.mutex);\r\nout:\r\nreturn ret;\r\n}\r\nstatic void\r\nmptsas_parse_device_info(struct sas_identify *identify,\r\nstruct mptsas_devinfo *device_info)\r\n{\r\nu16 protocols;\r\nidentify->sas_address = device_info->sas_address;\r\nidentify->phy_identifier = device_info->phy_id;\r\nprotocols = device_info->device_info & 0x78;\r\nidentify->initiator_port_protocols = 0;\r\nif (protocols & MPI_SAS_DEVICE_INFO_SSP_INITIATOR)\r\nidentify->initiator_port_protocols |= SAS_PROTOCOL_SSP;\r\nif (protocols & MPI_SAS_DEVICE_INFO_STP_INITIATOR)\r\nidentify->initiator_port_protocols |= SAS_PROTOCOL_STP;\r\nif (protocols & MPI_SAS_DEVICE_INFO_SMP_INITIATOR)\r\nidentify->initiator_port_protocols |= SAS_PROTOCOL_SMP;\r\nif (protocols & MPI_SAS_DEVICE_INFO_SATA_HOST)\r\nidentify->initiator_port_protocols |= SAS_PROTOCOL_SATA;\r\nprotocols = device_info->device_info & 0x780;\r\nidentify->target_port_protocols = 0;\r\nif (protocols & MPI_SAS_DEVICE_INFO_SSP_TARGET)\r\nidentify->target_port_protocols |= SAS_PROTOCOL_SSP;\r\nif (protocols & MPI_SAS_DEVICE_INFO_STP_TARGET)\r\nidentify->target_port_protocols |= SAS_PROTOCOL_STP;\r\nif (protocols & MPI_SAS_DEVICE_INFO_SMP_TARGET)\r\nidentify->target_port_protocols |= SAS_PROTOCOL_SMP;\r\nif (protocols & MPI_SAS_DEVICE_INFO_SATA_DEVICE)\r\nidentify->target_port_protocols |= SAS_PROTOCOL_SATA;\r\nswitch (device_info->device_info &\r\nMPI_SAS_DEVICE_INFO_MASK_DEVICE_TYPE) {\r\ncase MPI_SAS_DEVICE_INFO_NO_DEVICE:\r\nidentify->device_type = SAS_PHY_UNUSED;\r\nbreak;\r\ncase MPI_SAS_DEVICE_INFO_END_DEVICE:\r\nidentify->device_type = SAS_END_DEVICE;\r\nbreak;\r\ncase MPI_SAS_DEVICE_INFO_EDGE_EXPANDER:\r\nidentify->device_type = SAS_EDGE_EXPANDER_DEVICE;\r\nbreak;\r\ncase MPI_SAS_DEVICE_INFO_FANOUT_EXPANDER:\r\nidentify->device_type = SAS_FANOUT_EXPANDER_DEVICE;\r\nbreak;\r\n}\r\n}\r\nstatic int mptsas_probe_one_phy(struct device *dev,\r\nstruct mptsas_phyinfo *phy_info, int index, int local)\r\n{\r\nMPT_ADAPTER *ioc;\r\nstruct sas_phy *phy;\r\nstruct sas_port *port;\r\nint error = 0;\r\nVirtTarget *vtarget;\r\nif (!dev) {\r\nerror = -ENODEV;\r\ngoto out;\r\n}\r\nif (!phy_info->phy) {\r\nphy = sas_phy_alloc(dev, index);\r\nif (!phy) {\r\nerror = -ENOMEM;\r\ngoto out;\r\n}\r\n} else\r\nphy = phy_info->phy;\r\nmptsas_parse_device_info(&phy->identify, &phy_info->identify);\r\nswitch (phy_info->negotiated_link_rate) {\r\ncase MPI_SAS_IOUNIT0_RATE_PHY_DISABLED:\r\nphy->negotiated_linkrate = SAS_PHY_DISABLED;\r\nbreak;\r\ncase MPI_SAS_IOUNIT0_RATE_FAILED_SPEED_NEGOTIATION:\r\nphy->negotiated_linkrate = SAS_LINK_RATE_FAILED;\r\nbreak;\r\ncase MPI_SAS_IOUNIT0_RATE_1_5:\r\nphy->negotiated_linkrate = SAS_LINK_RATE_1_5_GBPS;\r\nbreak;\r\ncase MPI_SAS_IOUNIT0_RATE_3_0:\r\nphy->negotiated_linkrate = SAS_LINK_RATE_3_0_GBPS;\r\nbreak;\r\ncase MPI_SAS_IOUNIT0_RATE_6_0:\r\nphy->negotiated_linkrate = SAS_LINK_RATE_6_0_GBPS;\r\nbreak;\r\ncase MPI_SAS_IOUNIT0_RATE_SATA_OOB_COMPLETE:\r\ncase MPI_SAS_IOUNIT0_RATE_UNKNOWN:\r\ndefault:\r\nphy->negotiated_linkrate = SAS_LINK_RATE_UNKNOWN;\r\nbreak;\r\n}\r\nswitch (phy_info->hw_link_rate & MPI_SAS_PHY0_PRATE_MAX_RATE_MASK) {\r\ncase MPI_SAS_PHY0_HWRATE_MAX_RATE_1_5:\r\nphy->maximum_linkrate_hw = SAS_LINK_RATE_1_5_GBPS;\r\nbreak;\r\ncase MPI_SAS_PHY0_PRATE_MAX_RATE_3_0:\r\nphy->maximum_linkrate_hw = SAS_LINK_RATE_3_0_GBPS;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nswitch (phy_info->programmed_link_rate &\r\nMPI_SAS_PHY0_PRATE_MAX_RATE_MASK) {\r\ncase MPI_SAS_PHY0_PRATE_MAX_RATE_1_5:\r\nphy->maximum_linkrate = SAS_LINK_RATE_1_5_GBPS;\r\nbreak;\r\ncase MPI_SAS_PHY0_PRATE_MAX_RATE_3_0:\r\nphy->maximum_linkrate = SAS_LINK_RATE_3_0_GBPS;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nswitch (phy_info->hw_link_rate & MPI_SAS_PHY0_HWRATE_MIN_RATE_MASK) {\r\ncase MPI_SAS_PHY0_HWRATE_MIN_RATE_1_5:\r\nphy->minimum_linkrate_hw = SAS_LINK_RATE_1_5_GBPS;\r\nbreak;\r\ncase MPI_SAS_PHY0_PRATE_MIN_RATE_3_0:\r\nphy->minimum_linkrate_hw = SAS_LINK_RATE_3_0_GBPS;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nswitch (phy_info->programmed_link_rate &\r\nMPI_SAS_PHY0_PRATE_MIN_RATE_MASK) {\r\ncase MPI_SAS_PHY0_PRATE_MIN_RATE_1_5:\r\nphy->minimum_linkrate = SAS_LINK_RATE_1_5_GBPS;\r\nbreak;\r\ncase MPI_SAS_PHY0_PRATE_MIN_RATE_3_0:\r\nphy->minimum_linkrate = SAS_LINK_RATE_3_0_GBPS;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif (!phy_info->phy) {\r\nerror = sas_phy_add(phy);\r\nif (error) {\r\nsas_phy_free(phy);\r\ngoto out;\r\n}\r\nphy_info->phy = phy;\r\n}\r\nif (!phy_info->attached.handle ||\r\n!phy_info->port_details)\r\ngoto out;\r\nport = mptsas_get_port(phy_info);\r\nioc = phy_to_ioc(phy_info->phy);\r\nif (phy_info->sas_port_add_phy) {\r\nif (!port) {\r\nport = sas_port_alloc_num(dev);\r\nif (!port) {\r\nerror = -ENOMEM;\r\ngoto out;\r\n}\r\nerror = sas_port_add(port);\r\nif (error) {\r\ndfailprintk(ioc, printk(MYIOC_s_ERR_FMT\r\n"%s: exit at line=%d\n", ioc->name,\r\n__func__, __LINE__));\r\ngoto out;\r\n}\r\nmptsas_set_port(ioc, phy_info, port);\r\ndevtprintk(ioc, dev_printk(KERN_DEBUG, &port->dev,\r\nMYIOC_s_FMT "add port %d, sas_addr (0x%llx)\n",\r\nioc->name, port->port_identifier,\r\n(unsigned long long)phy_info->\r\nattached.sas_address));\r\n}\r\ndsaswideprintk(ioc, printk(MYIOC_s_DEBUG_FMT\r\n"sas_port_add_phy: phy_id=%d\n",\r\nioc->name, phy_info->phy_id));\r\nsas_port_add_phy(port, phy_info->phy);\r\nphy_info->sas_port_add_phy = 0;\r\ndevtprintk(ioc, dev_printk(KERN_DEBUG, &phy_info->phy->dev,\r\nMYIOC_s_FMT "add phy %d, phy-obj (0x%p)\n", ioc->name,\r\nphy_info->phy_id, phy_info->phy));\r\n}\r\nif (!mptsas_get_rphy(phy_info) && port && !port->rphy) {\r\nstruct sas_rphy *rphy;\r\nstruct device *parent;\r\nstruct sas_identify identify;\r\nparent = dev->parent->parent;\r\nif (mptsas_is_end_device(&phy_info->attached) &&\r\nphy_info->attached.handle_parent) {\r\ngoto out;\r\n}\r\nmptsas_parse_device_info(&identify, &phy_info->attached);\r\nif (scsi_is_host_device(parent)) {\r\nstruct mptsas_portinfo *port_info;\r\nint i;\r\nport_info = ioc->hba_port_info;\r\nfor (i = 0; i < port_info->num_phys; i++)\r\nif (port_info->phy_info[i].identify.sas_address ==\r\nidentify.sas_address) {\r\nsas_port_mark_backlink(port);\r\ngoto out;\r\n}\r\n} else if (scsi_is_sas_rphy(parent)) {\r\nstruct sas_rphy *parent_rphy = dev_to_rphy(parent);\r\nif (identify.sas_address ==\r\nparent_rphy->identify.sas_address) {\r\nsas_port_mark_backlink(port);\r\ngoto out;\r\n}\r\n}\r\nswitch (identify.device_type) {\r\ncase SAS_END_DEVICE:\r\nrphy = sas_end_device_alloc(port);\r\nbreak;\r\ncase SAS_EDGE_EXPANDER_DEVICE:\r\ncase SAS_FANOUT_EXPANDER_DEVICE:\r\nrphy = sas_expander_alloc(port, identify.device_type);\r\nbreak;\r\ndefault:\r\nrphy = NULL;\r\nbreak;\r\n}\r\nif (!rphy) {\r\ndfailprintk(ioc, printk(MYIOC_s_ERR_FMT\r\n"%s: exit at line=%d\n", ioc->name,\r\n__func__, __LINE__));\r\ngoto out;\r\n}\r\nrphy->identify = identify;\r\nerror = sas_rphy_add(rphy);\r\nif (error) {\r\ndfailprintk(ioc, printk(MYIOC_s_ERR_FMT\r\n"%s: exit at line=%d\n", ioc->name,\r\n__func__, __LINE__));\r\nsas_rphy_free(rphy);\r\ngoto out;\r\n}\r\nmptsas_set_rphy(ioc, phy_info, rphy);\r\nif (identify.device_type == SAS_EDGE_EXPANDER_DEVICE ||\r\nidentify.device_type == SAS_FANOUT_EXPANDER_DEVICE)\r\nmptsas_exp_repmanufacture_info(ioc,\r\nidentify.sas_address,\r\nrphy_to_expander_device(rphy));\r\n}\r\nvtarget = mptsas_find_vtarget(ioc,\r\nphy_info->attached.channel,\r\nphy_info->attached.id);\r\nif (vtarget && vtarget->inDMD) {\r\nprintk(KERN_INFO "Device returned, unsetting inDMD\n");\r\nvtarget->inDMD = 0;\r\n}\r\nout:\r\nreturn error;\r\n}\r\nstatic int\r\nmptsas_probe_hba_phys(MPT_ADAPTER *ioc)\r\n{\r\nstruct mptsas_portinfo *port_info, *hba;\r\nint error = -ENOMEM, i;\r\nhba = kzalloc(sizeof(struct mptsas_portinfo), GFP_KERNEL);\r\nif (! hba)\r\ngoto out;\r\nerror = mptsas_sas_io_unit_pg0(ioc, hba);\r\nif (error)\r\ngoto out_free_port_info;\r\nmptsas_sas_io_unit_pg1(ioc);\r\nmutex_lock(&ioc->sas_topology_mutex);\r\nport_info = ioc->hba_port_info;\r\nif (!port_info) {\r\nioc->hba_port_info = port_info = hba;\r\nioc->hba_port_num_phy = port_info->num_phys;\r\nlist_add_tail(&port_info->list, &ioc->sas_topology);\r\n} else {\r\nfor (i = 0; i < hba->num_phys; i++) {\r\nport_info->phy_info[i].negotiated_link_rate =\r\nhba->phy_info[i].negotiated_link_rate;\r\nport_info->phy_info[i].handle =\r\nhba->phy_info[i].handle;\r\nport_info->phy_info[i].port_id =\r\nhba->phy_info[i].port_id;\r\n}\r\nkfree(hba->phy_info);\r\nkfree(hba);\r\nhba = NULL;\r\n}\r\nmutex_unlock(&ioc->sas_topology_mutex);\r\n#if defined(CPQ_CIM)\r\nioc->num_ports = port_info->num_phys;\r\n#endif\r\nfor (i = 0; i < port_info->num_phys; i++) {\r\nmptsas_sas_phy_pg0(ioc, &port_info->phy_info[i],\r\n(MPI_SAS_PHY_PGAD_FORM_PHY_NUMBER <<\r\nMPI_SAS_PHY_PGAD_FORM_SHIFT), i);\r\nport_info->phy_info[i].identify.handle =\r\nport_info->phy_info[i].handle;\r\nmptsas_sas_device_pg0(ioc, &port_info->phy_info[i].identify,\r\n(MPI_SAS_DEVICE_PGAD_FORM_HANDLE <<\r\nMPI_SAS_DEVICE_PGAD_FORM_SHIFT),\r\nport_info->phy_info[i].identify.handle);\r\nif (!ioc->hba_port_sas_addr)\r\nioc->hba_port_sas_addr =\r\nport_info->phy_info[i].identify.sas_address;\r\nport_info->phy_info[i].identify.phy_id =\r\nport_info->phy_info[i].phy_id = i;\r\nif (port_info->phy_info[i].attached.handle)\r\nmptsas_sas_device_pg0(ioc,\r\n&port_info->phy_info[i].attached,\r\n(MPI_SAS_DEVICE_PGAD_FORM_HANDLE <<\r\nMPI_SAS_DEVICE_PGAD_FORM_SHIFT),\r\nport_info->phy_info[i].attached.handle);\r\n}\r\nmptsas_setup_wide_ports(ioc, port_info);\r\nfor (i = 0; i < port_info->num_phys; i++, ioc->sas_index++)\r\nmptsas_probe_one_phy(&ioc->sh->shost_gendev,\r\n&port_info->phy_info[i], ioc->sas_index, 1);\r\nreturn 0;\r\nout_free_port_info:\r\nkfree(hba);\r\nout:\r\nreturn error;\r\n}\r\nstatic void\r\nmptsas_expander_refresh(MPT_ADAPTER *ioc, struct mptsas_portinfo *port_info)\r\n{\r\nstruct mptsas_portinfo *parent;\r\nstruct device *parent_dev;\r\nstruct sas_rphy *rphy;\r\nint i;\r\nu64 sas_address;\r\nu32 handle;\r\nhandle = port_info->phy_info[0].handle;\r\nsas_address = port_info->phy_info[0].identify.sas_address;\r\nfor (i = 0; i < port_info->num_phys; i++) {\r\nmptsas_sas_expander_pg1(ioc, &port_info->phy_info[i],\r\n(MPI_SAS_EXPAND_PGAD_FORM_HANDLE_PHY_NUM <<\r\nMPI_SAS_EXPAND_PGAD_FORM_SHIFT), (i << 16) + handle);\r\nmptsas_sas_device_pg0(ioc,\r\n&port_info->phy_info[i].identify,\r\n(MPI_SAS_DEVICE_PGAD_FORM_HANDLE <<\r\nMPI_SAS_DEVICE_PGAD_FORM_SHIFT),\r\nport_info->phy_info[i].identify.handle);\r\nport_info->phy_info[i].identify.phy_id =\r\nport_info->phy_info[i].phy_id;\r\nif (port_info->phy_info[i].attached.handle) {\r\nmptsas_sas_device_pg0(ioc,\r\n&port_info->phy_info[i].attached,\r\n(MPI_SAS_DEVICE_PGAD_FORM_HANDLE <<\r\nMPI_SAS_DEVICE_PGAD_FORM_SHIFT),\r\nport_info->phy_info[i].attached.handle);\r\nport_info->phy_info[i].attached.phy_id =\r\nport_info->phy_info[i].phy_id;\r\n}\r\n}\r\nmutex_lock(&ioc->sas_topology_mutex);\r\nparent = mptsas_find_portinfo_by_handle(ioc,\r\nport_info->phy_info[0].identify.handle_parent);\r\nif (!parent) {\r\nmutex_unlock(&ioc->sas_topology_mutex);\r\nreturn;\r\n}\r\nfor (i = 0, parent_dev = NULL; i < parent->num_phys && !parent_dev;\r\ni++) {\r\nif (parent->phy_info[i].attached.sas_address == sas_address) {\r\nrphy = mptsas_get_rphy(&parent->phy_info[i]);\r\nparent_dev = &rphy->dev;\r\n}\r\n}\r\nmutex_unlock(&ioc->sas_topology_mutex);\r\nmptsas_setup_wide_ports(ioc, port_info);\r\nfor (i = 0; i < port_info->num_phys; i++, ioc->sas_index++)\r\nmptsas_probe_one_phy(parent_dev, &port_info->phy_info[i],\r\nioc->sas_index, 0);\r\n}\r\nstatic void\r\nmptsas_expander_event_add(MPT_ADAPTER *ioc,\r\nMpiEventDataSasExpanderStatusChange_t *expander_data)\r\n{\r\nstruct mptsas_portinfo *port_info;\r\nint i;\r\n__le64 sas_address;\r\nport_info = kzalloc(sizeof(struct mptsas_portinfo), GFP_KERNEL);\r\nif (!port_info)\r\nBUG();\r\nport_info->num_phys = (expander_data->NumPhys) ?\r\nexpander_data->NumPhys : 1;\r\nport_info->phy_info = kcalloc(port_info->num_phys,\r\nsizeof(struct mptsas_phyinfo), GFP_KERNEL);\r\nif (!port_info->phy_info)\r\nBUG();\r\nmemcpy(&sas_address, &expander_data->SASAddress, sizeof(__le64));\r\nfor (i = 0; i < port_info->num_phys; i++) {\r\nport_info->phy_info[i].portinfo = port_info;\r\nport_info->phy_info[i].handle =\r\nle16_to_cpu(expander_data->DevHandle);\r\nport_info->phy_info[i].identify.sas_address =\r\nle64_to_cpu(sas_address);\r\nport_info->phy_info[i].identify.handle_parent =\r\nle16_to_cpu(expander_data->ParentDevHandle);\r\n}\r\nmutex_lock(&ioc->sas_topology_mutex);\r\nlist_add_tail(&port_info->list, &ioc->sas_topology);\r\nmutex_unlock(&ioc->sas_topology_mutex);\r\nprintk(MYIOC_s_INFO_FMT "add expander: num_phys %d, "\r\n"sas_addr (0x%llx)\n", ioc->name, port_info->num_phys,\r\n(unsigned long long)sas_address);\r\nmptsas_expander_refresh(ioc, port_info);\r\n}\r\nstatic void\r\nmptsas_delete_expander_siblings(MPT_ADAPTER *ioc, struct mptsas_portinfo\r\n*parent, struct mptsas_portinfo *expander)\r\n{\r\nstruct mptsas_phyinfo *phy_info;\r\nstruct mptsas_portinfo *port_info;\r\nstruct sas_rphy *rphy;\r\nint i;\r\nphy_info = expander->phy_info;\r\nfor (i = 0; i < expander->num_phys; i++, phy_info++) {\r\nrphy = mptsas_get_rphy(phy_info);\r\nif (!rphy)\r\ncontinue;\r\nif (rphy->identify.device_type == SAS_END_DEVICE)\r\nmptsas_del_end_device(ioc, phy_info);\r\n}\r\nphy_info = expander->phy_info;\r\nfor (i = 0; i < expander->num_phys; i++, phy_info++) {\r\nrphy = mptsas_get_rphy(phy_info);\r\nif (!rphy)\r\ncontinue;\r\nif (rphy->identify.device_type ==\r\nMPI_SAS_DEVICE_INFO_EDGE_EXPANDER ||\r\nrphy->identify.device_type ==\r\nMPI_SAS_DEVICE_INFO_FANOUT_EXPANDER) {\r\nport_info = mptsas_find_portinfo_by_sas_address(ioc,\r\nrphy->identify.sas_address);\r\nif (!port_info)\r\ncontinue;\r\nif (port_info == parent)\r\ncontinue;\r\nmptsas_expander_delete(ioc, port_info, 1);\r\n}\r\n}\r\n}\r\nstatic void mptsas_expander_delete(MPT_ADAPTER *ioc,\r\nstruct mptsas_portinfo *port_info, u8 force)\r\n{\r\nstruct mptsas_portinfo *parent;\r\nint i;\r\nu64 expander_sas_address;\r\nstruct mptsas_phyinfo *phy_info;\r\nstruct mptsas_portinfo buffer;\r\nstruct mptsas_portinfo_details *port_details;\r\nstruct sas_port *port;\r\nif (!port_info)\r\nreturn;\r\nmptsas_sas_expander_pg0(ioc, &buffer,\r\n(MPI_SAS_EXPAND_PGAD_FORM_HANDLE <<\r\nMPI_SAS_EXPAND_PGAD_FORM_SHIFT),\r\nport_info->phy_info[0].identify.handle);\r\nif (buffer.num_phys) {\r\nkfree(buffer.phy_info);\r\nif (!force)\r\nreturn;\r\n}\r\nport_details = NULL;\r\nexpander_sas_address =\r\nport_info->phy_info[0].identify.sas_address;\r\nparent = mptsas_find_portinfo_by_handle(ioc,\r\nport_info->phy_info[0].identify.handle_parent);\r\nmptsas_delete_expander_siblings(ioc, parent, port_info);\r\nif (!parent)\r\ngoto out;\r\nphy_info = parent->phy_info;\r\nport = NULL;\r\nfor (i = 0; i < parent->num_phys; i++, phy_info++) {\r\nif (!phy_info->phy)\r\ncontinue;\r\nif (phy_info->attached.sas_address !=\r\nexpander_sas_address)\r\ncontinue;\r\nif (!port) {\r\nport = mptsas_get_port(phy_info);\r\nport_details = phy_info->port_details;\r\n}\r\ndev_printk(KERN_DEBUG, &phy_info->phy->dev,\r\nMYIOC_s_FMT "delete phy %d, phy-obj (0x%p)\n", ioc->name,\r\nphy_info->phy_id, phy_info->phy);\r\nsas_port_delete_phy(port, phy_info->phy);\r\n}\r\nif (port) {\r\ndev_printk(KERN_DEBUG, &port->dev,\r\nMYIOC_s_FMT "delete port %d, sas_addr (0x%llx)\n",\r\nioc->name, port->port_identifier,\r\n(unsigned long long)expander_sas_address);\r\nsas_port_delete(port);\r\nmptsas_port_delete(ioc, port_details);\r\n}\r\nout:\r\nprintk(MYIOC_s_INFO_FMT "delete expander: num_phys %d, "\r\n"sas_addr (0x%llx)\n", ioc->name, port_info->num_phys,\r\n(unsigned long long)expander_sas_address);\r\nlist_del(&port_info->list);\r\nkfree(port_info->phy_info);\r\nkfree(port_info);\r\n}\r\nstatic void\r\nmptsas_send_expander_event(struct fw_event_work *fw_event)\r\n{\r\nMPT_ADAPTER *ioc;\r\nMpiEventDataSasExpanderStatusChange_t *expander_data;\r\nstruct mptsas_portinfo *port_info;\r\n__le64 sas_address;\r\nint i;\r\nioc = fw_event->ioc;\r\nexpander_data = (MpiEventDataSasExpanderStatusChange_t *)\r\nfw_event->event_data;\r\nmemcpy(&sas_address, &expander_data->SASAddress, sizeof(__le64));\r\nsas_address = le64_to_cpu(sas_address);\r\nport_info = mptsas_find_portinfo_by_sas_address(ioc, sas_address);\r\nif (expander_data->ReasonCode == MPI_EVENT_SAS_EXP_RC_ADDED) {\r\nif (port_info) {\r\nfor (i = 0; i < port_info->num_phys; i++) {\r\nport_info->phy_info[i].portinfo = port_info;\r\nport_info->phy_info[i].handle =\r\nle16_to_cpu(expander_data->DevHandle);\r\nport_info->phy_info[i].identify.sas_address =\r\nle64_to_cpu(sas_address);\r\nport_info->phy_info[i].identify.handle_parent =\r\nle16_to_cpu(expander_data->ParentDevHandle);\r\n}\r\nmptsas_expander_refresh(ioc, port_info);\r\n} else if (!port_info && expander_data->NumPhys)\r\nmptsas_expander_event_add(ioc, expander_data);\r\n} else if (expander_data->ReasonCode ==\r\nMPI_EVENT_SAS_EXP_RC_NOT_RESPONDING)\r\nmptsas_expander_delete(ioc, port_info, 0);\r\nmptsas_free_fw_event(ioc, fw_event);\r\n}\r\nstatic struct mptsas_portinfo *\r\nmptsas_expander_add(MPT_ADAPTER *ioc, u16 handle)\r\n{\r\nstruct mptsas_portinfo buffer, *port_info;\r\nint i;\r\nif ((mptsas_sas_expander_pg0(ioc, &buffer,\r\n(MPI_SAS_EXPAND_PGAD_FORM_HANDLE <<\r\nMPI_SAS_EXPAND_PGAD_FORM_SHIFT), handle)))\r\nreturn NULL;\r\nport_info = kzalloc(sizeof(struct mptsas_portinfo), GFP_ATOMIC);\r\nif (!port_info) {\r\ndfailprintk(ioc, printk(MYIOC_s_ERR_FMT\r\n"%s: exit at line=%d\n", ioc->name,\r\n__func__, __LINE__));\r\nreturn NULL;\r\n}\r\nport_info->num_phys = buffer.num_phys;\r\nport_info->phy_info = buffer.phy_info;\r\nfor (i = 0; i < port_info->num_phys; i++)\r\nport_info->phy_info[i].portinfo = port_info;\r\nmutex_lock(&ioc->sas_topology_mutex);\r\nlist_add_tail(&port_info->list, &ioc->sas_topology);\r\nmutex_unlock(&ioc->sas_topology_mutex);\r\nprintk(MYIOC_s_INFO_FMT "add expander: num_phys %d, "\r\n"sas_addr (0x%llx)\n", ioc->name, port_info->num_phys,\r\n(unsigned long long)buffer.phy_info[0].identify.sas_address);\r\nmptsas_expander_refresh(ioc, port_info);\r\nreturn port_info;\r\n}\r\nstatic void\r\nmptsas_send_link_status_event(struct fw_event_work *fw_event)\r\n{\r\nMPT_ADAPTER *ioc;\r\nMpiEventDataSasPhyLinkStatus_t *link_data;\r\nstruct mptsas_portinfo *port_info;\r\nstruct mptsas_phyinfo *phy_info = NULL;\r\n__le64 sas_address;\r\nu8 phy_num;\r\nu8 link_rate;\r\nioc = fw_event->ioc;\r\nlink_data = (MpiEventDataSasPhyLinkStatus_t *)fw_event->event_data;\r\nmemcpy(&sas_address, &link_data->SASAddress, sizeof(__le64));\r\nsas_address = le64_to_cpu(sas_address);\r\nlink_rate = link_data->LinkRates >> 4;\r\nphy_num = link_data->PhyNum;\r\nport_info = mptsas_find_portinfo_by_sas_address(ioc, sas_address);\r\nif (port_info) {\r\nphy_info = &port_info->phy_info[phy_num];\r\nif (phy_info)\r\nphy_info->negotiated_link_rate = link_rate;\r\n}\r\nif (link_rate == MPI_SAS_IOUNIT0_RATE_1_5 ||\r\nlink_rate == MPI_SAS_IOUNIT0_RATE_3_0 ||\r\nlink_rate == MPI_SAS_IOUNIT0_RATE_6_0) {\r\nif (!port_info) {\r\nif (ioc->old_sas_discovery_protocal) {\r\nport_info = mptsas_expander_add(ioc,\r\nle16_to_cpu(link_data->DevHandle));\r\nif (port_info)\r\ngoto out;\r\n}\r\ngoto out;\r\n}\r\nif (port_info == ioc->hba_port_info)\r\nmptsas_probe_hba_phys(ioc);\r\nelse\r\nmptsas_expander_refresh(ioc, port_info);\r\n} else if (phy_info && phy_info->phy) {\r\nif (link_rate == MPI_SAS_IOUNIT0_RATE_PHY_DISABLED)\r\nphy_info->phy->negotiated_linkrate =\r\nSAS_PHY_DISABLED;\r\nelse if (link_rate ==\r\nMPI_SAS_IOUNIT0_RATE_FAILED_SPEED_NEGOTIATION)\r\nphy_info->phy->negotiated_linkrate =\r\nSAS_LINK_RATE_FAILED;\r\nelse {\r\nphy_info->phy->negotiated_linkrate =\r\nSAS_LINK_RATE_UNKNOWN;\r\nif (ioc->device_missing_delay &&\r\nmptsas_is_end_device(&phy_info->attached)) {\r\nstruct scsi_device *sdev;\r\nVirtDevice *vdevice;\r\nu8 channel, id;\r\nid = phy_info->attached.id;\r\nchannel = phy_info->attached.channel;\r\ndevtprintk(ioc, printk(MYIOC_s_DEBUG_FMT\r\n"Link down for fw_id %d:fw_channel %d\n",\r\nioc->name, phy_info->attached.id,\r\nphy_info->attached.channel));\r\nshost_for_each_device(sdev, ioc->sh) {\r\nvdevice = sdev->hostdata;\r\nif ((vdevice == NULL) ||\r\n(vdevice->vtarget == NULL))\r\ncontinue;\r\nif ((vdevice->vtarget->tflags &\r\nMPT_TARGET_FLAGS_RAID_COMPONENT ||\r\nvdevice->vtarget->raidVolume))\r\ncontinue;\r\nif (vdevice->vtarget->id == id &&\r\nvdevice->vtarget->channel ==\r\nchannel)\r\ndevtprintk(ioc,\r\nprintk(MYIOC_s_DEBUG_FMT\r\n"SDEV OUTSTANDING CMDS"\r\n"%d\n", ioc->name,\r\natomic_read(&sdev->device_busy)));\r\n}\r\n}\r\n}\r\n}\r\nout:\r\nmptsas_free_fw_event(ioc, fw_event);\r\n}\r\nstatic void\r\nmptsas_not_responding_devices(MPT_ADAPTER *ioc)\r\n{\r\nstruct mptsas_portinfo buffer, *port_info;\r\nstruct mptsas_device_info *sas_info;\r\nstruct mptsas_devinfo sas_device;\r\nu32 handle;\r\nVirtTarget *vtarget = NULL;\r\nstruct mptsas_phyinfo *phy_info;\r\nu8 found_expander;\r\nint retval, retry_count;\r\nunsigned long flags;\r\nmpt_findImVolumes(ioc);\r\nspin_lock_irqsave(&ioc->taskmgmt_lock, flags);\r\nif (ioc->ioc_reset_in_progress) {\r\ndfailprintk(ioc, printk(MYIOC_s_DEBUG_FMT\r\n"%s: exiting due to a parallel reset \n", ioc->name,\r\n__func__));\r\nspin_unlock_irqrestore(&ioc->taskmgmt_lock, flags);\r\nreturn;\r\n}\r\nspin_unlock_irqrestore(&ioc->taskmgmt_lock, flags);\r\nmutex_lock(&ioc->sas_device_info_mutex);\r\nredo_device_scan:\r\nlist_for_each_entry(sas_info, &ioc->sas_device_info_list, list) {\r\nif (sas_info->is_cached)\r\ncontinue;\r\nif (!sas_info->is_logical_volume) {\r\nsas_device.handle = 0;\r\nretry_count = 0;\r\nretry_page:\r\nretval = mptsas_sas_device_pg0(ioc, &sas_device,\r\n(MPI_SAS_DEVICE_PGAD_FORM_BUS_TARGET_ID\r\n<< MPI_SAS_DEVICE_PGAD_FORM_SHIFT),\r\n(sas_info->fw.channel << 8) +\r\nsas_info->fw.id);\r\nif (sas_device.handle)\r\ncontinue;\r\nif (retval == -EBUSY) {\r\nspin_lock_irqsave(&ioc->taskmgmt_lock, flags);\r\nif (ioc->ioc_reset_in_progress) {\r\ndfailprintk(ioc,\r\nprintk(MYIOC_s_DEBUG_FMT\r\n"%s: exiting due to reset\n",\r\nioc->name, __func__));\r\nspin_unlock_irqrestore\r\n(&ioc->taskmgmt_lock, flags);\r\nmutex_unlock(&ioc->\r\nsas_device_info_mutex);\r\nreturn;\r\n}\r\nspin_unlock_irqrestore(&ioc->taskmgmt_lock,\r\nflags);\r\n}\r\nif (retval && (retval != -ENODEV)) {\r\nif (retry_count < 10) {\r\nretry_count++;\r\ngoto retry_page;\r\n} else {\r\ndevtprintk(ioc, printk(MYIOC_s_DEBUG_FMT\r\n"%s: Config page retry exceeded retry "\r\n"count deleting device 0x%llx\n",\r\nioc->name, __func__,\r\nsas_info->sas_address));\r\n}\r\n}\r\nvtarget = mptsas_find_vtarget(ioc,\r\nsas_info->fw.channel, sas_info->fw.id);\r\nif (vtarget)\r\nvtarget->deleted = 1;\r\nphy_info = mptsas_find_phyinfo_by_sas_address(ioc,\r\nsas_info->sas_address);\r\nmptsas_del_end_device(ioc, phy_info);\r\ngoto redo_device_scan;\r\n} else\r\nmptsas_volume_delete(ioc, sas_info->fw.id);\r\n}\r\nmutex_unlock(&ioc->sas_device_info_mutex);\r\nmutex_lock(&ioc->sas_topology_mutex);\r\nredo_expander_scan:\r\nlist_for_each_entry(port_info, &ioc->sas_topology, list) {\r\nif (!(port_info->phy_info[0].identify.device_info &\r\nMPI_SAS_DEVICE_INFO_SMP_TARGET))\r\ncontinue;\r\nfound_expander = 0;\r\nhandle = 0xFFFF;\r\nwhile (!mptsas_sas_expander_pg0(ioc, &buffer,\r\n(MPI_SAS_EXPAND_PGAD_FORM_GET_NEXT_HANDLE <<\r\nMPI_SAS_EXPAND_PGAD_FORM_SHIFT), handle) &&\r\n!found_expander) {\r\nhandle = buffer.phy_info[0].handle;\r\nif (buffer.phy_info[0].identify.sas_address ==\r\nport_info->phy_info[0].identify.sas_address) {\r\nfound_expander = 1;\r\n}\r\nkfree(buffer.phy_info);\r\n}\r\nif (!found_expander) {\r\nmptsas_expander_delete(ioc, port_info, 0);\r\ngoto redo_expander_scan;\r\n}\r\n}\r\nmutex_unlock(&ioc->sas_topology_mutex);\r\n}\r\nstatic void\r\nmptsas_probe_expanders(MPT_ADAPTER *ioc)\r\n{\r\nstruct mptsas_portinfo buffer, *port_info;\r\nu32 handle;\r\nint i;\r\nhandle = 0xFFFF;\r\nwhile (!mptsas_sas_expander_pg0(ioc, &buffer,\r\n(MPI_SAS_EXPAND_PGAD_FORM_GET_NEXT_HANDLE <<\r\nMPI_SAS_EXPAND_PGAD_FORM_SHIFT), handle)) {\r\nhandle = buffer.phy_info[0].handle;\r\nport_info = mptsas_find_portinfo_by_sas_address(ioc,\r\nbuffer.phy_info[0].identify.sas_address);\r\nif (port_info) {\r\nfor (i = 0; i < buffer.num_phys; i++) {\r\nport_info->phy_info[i].handle = handle;\r\nport_info->phy_info[i].identify.handle_parent =\r\nbuffer.phy_info[0].identify.handle_parent;\r\n}\r\nmptsas_expander_refresh(ioc, port_info);\r\nkfree(buffer.phy_info);\r\ncontinue;\r\n}\r\nport_info = kzalloc(sizeof(struct mptsas_portinfo), GFP_KERNEL);\r\nif (!port_info) {\r\ndfailprintk(ioc, printk(MYIOC_s_ERR_FMT\r\n"%s: exit at line=%d\n", ioc->name,\r\n__func__, __LINE__));\r\nreturn;\r\n}\r\nport_info->num_phys = buffer.num_phys;\r\nport_info->phy_info = buffer.phy_info;\r\nfor (i = 0; i < port_info->num_phys; i++)\r\nport_info->phy_info[i].portinfo = port_info;\r\nmutex_lock(&ioc->sas_topology_mutex);\r\nlist_add_tail(&port_info->list, &ioc->sas_topology);\r\nmutex_unlock(&ioc->sas_topology_mutex);\r\nprintk(MYIOC_s_INFO_FMT "add expander: num_phys %d, "\r\n"sas_addr (0x%llx)\n", ioc->name, port_info->num_phys,\r\n(unsigned long long)buffer.phy_info[0].identify.sas_address);\r\nmptsas_expander_refresh(ioc, port_info);\r\n}\r\n}\r\nstatic void\r\nmptsas_probe_devices(MPT_ADAPTER *ioc)\r\n{\r\nu16 handle;\r\nstruct mptsas_devinfo sas_device;\r\nstruct mptsas_phyinfo *phy_info;\r\nhandle = 0xFFFF;\r\nwhile (!(mptsas_sas_device_pg0(ioc, &sas_device,\r\nMPI_SAS_DEVICE_PGAD_FORM_GET_NEXT_HANDLE, handle))) {\r\nhandle = sas_device.handle;\r\nif ((sas_device.device_info &\r\n(MPI_SAS_DEVICE_INFO_SSP_TARGET |\r\nMPI_SAS_DEVICE_INFO_STP_TARGET |\r\nMPI_SAS_DEVICE_INFO_SATA_DEVICE)) == 0)\r\ncontinue;\r\nif (!(sas_device.flags & MPI_SAS_DEVICE0_FLAGS_DEVICE_PRESENT)\r\n|| !(sas_device.flags &\r\nMPI_SAS_DEVICE0_FLAGS_DEVICE_MAPPED))\r\ncontinue;\r\nphy_info = mptsas_refreshing_device_handles(ioc, &sas_device);\r\nif (!phy_info)\r\ncontinue;\r\nif (mptsas_get_rphy(phy_info))\r\ncontinue;\r\nmptsas_add_end_device(ioc, phy_info);\r\n}\r\n}\r\nstatic void\r\nmptsas_scan_sas_topology(MPT_ADAPTER *ioc)\r\n{\r\nstruct scsi_device *sdev;\r\nint i;\r\nmptsas_probe_hba_phys(ioc);\r\nmptsas_probe_expanders(ioc);\r\nmptsas_probe_devices(ioc);\r\nif (!ioc->ir_firmware || !ioc->raid_data.pIocPg2 ||\r\n!ioc->raid_data.pIocPg2->NumActiveVolumes)\r\nreturn;\r\nfor (i = 0; i < ioc->raid_data.pIocPg2->NumActiveVolumes; i++) {\r\nsdev = scsi_device_lookup(ioc->sh, MPTSAS_RAID_CHANNEL,\r\nioc->raid_data.pIocPg2->RaidVolume[i].VolumeID, 0);\r\nif (sdev) {\r\nscsi_device_put(sdev);\r\ncontinue;\r\n}\r\nprintk(MYIOC_s_INFO_FMT "attaching raid volume, channel %d, "\r\n"id %d\n", ioc->name, MPTSAS_RAID_CHANNEL,\r\nioc->raid_data.pIocPg2->RaidVolume[i].VolumeID);\r\nscsi_add_device(ioc->sh, MPTSAS_RAID_CHANNEL,\r\nioc->raid_data.pIocPg2->RaidVolume[i].VolumeID, 0);\r\n}\r\n}\r\nstatic void\r\nmptsas_handle_queue_full_event(struct fw_event_work *fw_event)\r\n{\r\nMPT_ADAPTER *ioc;\r\nEventDataQueueFull_t *qfull_data;\r\nstruct mptsas_device_info *sas_info;\r\nstruct scsi_device *sdev;\r\nint depth;\r\nint id = -1;\r\nint channel = -1;\r\nint fw_id, fw_channel;\r\nu16 current_depth;\r\nioc = fw_event->ioc;\r\nqfull_data = (EventDataQueueFull_t *)fw_event->event_data;\r\nfw_id = qfull_data->TargetID;\r\nfw_channel = qfull_data->Bus;\r\ncurrent_depth = le16_to_cpu(qfull_data->CurrentDepth);\r\nmutex_lock(&ioc->sas_device_info_mutex);\r\nif (mptscsih_is_phys_disk(ioc, fw_channel, fw_id)) {\r\nlist_for_each_entry(sas_info, &ioc->sas_device_info_list,\r\nlist) {\r\nif (sas_info->is_cached ||\r\nsas_info->is_logical_volume)\r\ncontinue;\r\nif (sas_info->is_hidden_raid_component &&\r\n(sas_info->fw.channel == fw_channel &&\r\nsas_info->fw.id == fw_id)) {\r\nid = sas_info->volume_id;\r\nchannel = MPTSAS_RAID_CHANNEL;\r\ngoto out;\r\n}\r\n}\r\n} else {\r\nlist_for_each_entry(sas_info, &ioc->sas_device_info_list,\r\nlist) {\r\nif (sas_info->is_cached ||\r\nsas_info->is_hidden_raid_component ||\r\nsas_info->is_logical_volume)\r\ncontinue;\r\nif (sas_info->fw.channel == fw_channel &&\r\nsas_info->fw.id == fw_id) {\r\nid = sas_info->os.id;\r\nchannel = sas_info->os.channel;\r\ngoto out;\r\n}\r\n}\r\n}\r\nout:\r\nmutex_unlock(&ioc->sas_device_info_mutex);\r\nif (id != -1) {\r\nshost_for_each_device(sdev, ioc->sh) {\r\nif (sdev->id == id && sdev->channel == channel) {\r\nif (current_depth > sdev->queue_depth) {\r\nsdev_printk(KERN_INFO, sdev,\r\n"strange observation, the queue "\r\n"depth is (%d) meanwhile fw queue "\r\n"depth (%d)\n", sdev->queue_depth,\r\ncurrent_depth);\r\ncontinue;\r\n}\r\ndepth = scsi_track_queue_full(sdev,\r\nsdev->queue_depth - 1);\r\nif (depth > 0)\r\nsdev_printk(KERN_INFO, sdev,\r\n"Queue depth reduced to (%d)\n",\r\ndepth);\r\nelse if (depth < 0)\r\nsdev_printk(KERN_INFO, sdev,\r\n"Tagged Command Queueing is being "\r\n"disabled\n");\r\nelse if (depth == 0)\r\nsdev_printk(KERN_DEBUG, sdev,\r\n"Queue depth not changed yet\n");\r\n}\r\n}\r\n}\r\nmptsas_free_fw_event(ioc, fw_event);\r\n}\r\nstatic struct mptsas_phyinfo *\r\nmptsas_find_phyinfo_by_sas_address(MPT_ADAPTER *ioc, u64 sas_address)\r\n{\r\nstruct mptsas_portinfo *port_info;\r\nstruct mptsas_phyinfo *phy_info = NULL;\r\nint i;\r\nmutex_lock(&ioc->sas_topology_mutex);\r\nlist_for_each_entry(port_info, &ioc->sas_topology, list) {\r\nfor (i = 0; i < port_info->num_phys; i++) {\r\nif (!mptsas_is_end_device(\r\n&port_info->phy_info[i].attached))\r\ncontinue;\r\nif (port_info->phy_info[i].attached.sas_address\r\n!= sas_address)\r\ncontinue;\r\nphy_info = &port_info->phy_info[i];\r\nbreak;\r\n}\r\n}\r\nmutex_unlock(&ioc->sas_topology_mutex);\r\nreturn phy_info;\r\n}\r\nstatic struct mptsas_phyinfo *\r\nmptsas_find_phyinfo_by_phys_disk_num(MPT_ADAPTER *ioc, u8 phys_disk_num,\r\nu8 channel, u8 id)\r\n{\r\nstruct mptsas_phyinfo *phy_info = NULL;\r\nstruct mptsas_portinfo *port_info;\r\nRaidPhysDiskPage1_t *phys_disk = NULL;\r\nint num_paths;\r\nu64 sas_address = 0;\r\nint i;\r\nphy_info = NULL;\r\nif (!ioc->raid_data.pIocPg3)\r\nreturn NULL;\r\nnum_paths = mpt_raid_phys_disk_get_num_paths(ioc, phys_disk_num);\r\nif (!num_paths)\r\ngoto out;\r\nphys_disk = kzalloc(offsetof(RaidPhysDiskPage1_t, Path) +\r\n(num_paths * sizeof(RAID_PHYS_DISK1_PATH)), GFP_KERNEL);\r\nif (!phys_disk)\r\ngoto out;\r\nmpt_raid_phys_disk_pg1(ioc, phys_disk_num, phys_disk);\r\nfor (i = 0; i < num_paths; i++) {\r\nif ((phys_disk->Path[i].Flags & 1) != 0)\r\ncontinue;\r\nif ((id == phys_disk->Path[i].PhysDiskID) &&\r\n(channel == phys_disk->Path[i].PhysDiskBus)) {\r\nmemcpy(&sas_address, &phys_disk->Path[i].WWID,\r\nsizeof(u64));\r\nphy_info = mptsas_find_phyinfo_by_sas_address(ioc,\r\nsas_address);\r\ngoto out;\r\n}\r\n}\r\nout:\r\nkfree(phys_disk);\r\nif (phy_info)\r\nreturn phy_info;\r\nmutex_lock(&ioc->sas_topology_mutex);\r\nlist_for_each_entry(port_info, &ioc->sas_topology, list) {\r\nfor (i = 0; i < port_info->num_phys && !phy_info; i++) {\r\nif (!mptsas_is_end_device(\r\n&port_info->phy_info[i].attached))\r\ncontinue;\r\nif (port_info->phy_info[i].attached.phys_disk_num == ~0)\r\ncontinue;\r\nif ((port_info->phy_info[i].attached.phys_disk_num ==\r\nphys_disk_num) &&\r\n(port_info->phy_info[i].attached.id == id) &&\r\n(port_info->phy_info[i].attached.channel ==\r\nchannel))\r\nphy_info = &port_info->phy_info[i];\r\n}\r\n}\r\nmutex_unlock(&ioc->sas_topology_mutex);\r\nreturn phy_info;\r\n}\r\nstatic void\r\nmptsas_reprobe_lun(struct scsi_device *sdev, void *data)\r\n{\r\nint rc;\r\nsdev->no_uld_attach = data ? 1 : 0;\r\nrc = scsi_device_reprobe(sdev);\r\n}\r\nstatic void\r\nmptsas_reprobe_target(struct scsi_target *starget, int uld_attach)\r\n{\r\nstarget_for_each_device(starget, uld_attach ? (void *)1 : NULL,\r\nmptsas_reprobe_lun);\r\n}\r\nstatic void\r\nmptsas_adding_inactive_raid_components(MPT_ADAPTER *ioc, u8 channel, u8 id)\r\n{\r\nCONFIGPARMS cfg;\r\nConfigPageHeader_t hdr;\r\ndma_addr_t dma_handle;\r\npRaidVolumePage0_t buffer = NULL;\r\nRaidPhysDiskPage0_t phys_disk;\r\nint i;\r\nstruct mptsas_phyinfo *phy_info;\r\nstruct mptsas_devinfo sas_device;\r\nmemset(&cfg, 0 , sizeof(CONFIGPARMS));\r\nmemset(&hdr, 0 , sizeof(ConfigPageHeader_t));\r\nhdr.PageType = MPI_CONFIG_PAGETYPE_RAID_VOLUME;\r\ncfg.pageAddr = (channel << 8) + id;\r\ncfg.cfghdr.hdr = &hdr;\r\ncfg.action = MPI_CONFIG_ACTION_PAGE_HEADER;\r\ncfg.timeout = SAS_CONFIG_PAGE_TIMEOUT;\r\nif (mpt_config(ioc, &cfg) != 0)\r\ngoto out;\r\nif (!hdr.PageLength)\r\ngoto out;\r\nbuffer = pci_alloc_consistent(ioc->pcidev, hdr.PageLength * 4,\r\n&dma_handle);\r\nif (!buffer)\r\ngoto out;\r\ncfg.physAddr = dma_handle;\r\ncfg.action = MPI_CONFIG_ACTION_PAGE_READ_CURRENT;\r\nif (mpt_config(ioc, &cfg) != 0)\r\ngoto out;\r\nif (!(buffer->VolumeStatus.Flags &\r\nMPI_RAIDVOL0_STATUS_FLAG_VOLUME_INACTIVE))\r\ngoto out;\r\nif (!buffer->NumPhysDisks)\r\ngoto out;\r\nfor (i = 0; i < buffer->NumPhysDisks; i++) {\r\nif (mpt_raid_phys_disk_pg0(ioc,\r\nbuffer->PhysDisk[i].PhysDiskNum, &phys_disk) != 0)\r\ncontinue;\r\nif (mptsas_sas_device_pg0(ioc, &sas_device,\r\n(MPI_SAS_DEVICE_PGAD_FORM_BUS_TARGET_ID <<\r\nMPI_SAS_DEVICE_PGAD_FORM_SHIFT),\r\n(phys_disk.PhysDiskBus << 8) +\r\nphys_disk.PhysDiskID))\r\ncontinue;\r\nif (!(sas_device.flags & MPI_SAS_DEVICE0_FLAGS_DEVICE_PRESENT)\r\n|| !(sas_device.flags &\r\nMPI_SAS_DEVICE0_FLAGS_DEVICE_MAPPED))\r\ncontinue;\r\nphy_info = mptsas_find_phyinfo_by_sas_address(ioc,\r\nsas_device.sas_address);\r\nmptsas_add_end_device(ioc, phy_info);\r\n}\r\nout:\r\nif (buffer)\r\npci_free_consistent(ioc->pcidev, hdr.PageLength * 4, buffer,\r\ndma_handle);\r\n}\r\nstatic void\r\nmptsas_hotplug_work(MPT_ADAPTER *ioc, struct fw_event_work *fw_event,\r\nstruct mptsas_hotplug_event *hot_plug_info)\r\n{\r\nstruct mptsas_phyinfo *phy_info;\r\nstruct scsi_target * starget;\r\nstruct mptsas_devinfo sas_device;\r\nVirtTarget *vtarget;\r\nint i;\r\nstruct mptsas_portinfo *port_info;\r\nswitch (hot_plug_info->event_type) {\r\ncase MPTSAS_ADD_PHYSDISK:\r\nif (!ioc->raid_data.pIocPg2)\r\nbreak;\r\nfor (i = 0; i < ioc->raid_data.pIocPg2->NumActiveVolumes; i++) {\r\nif (ioc->raid_data.pIocPg2->RaidVolume[i].VolumeID ==\r\nhot_plug_info->id) {\r\nprintk(MYIOC_s_WARN_FMT "firmware bug: unable "\r\n"to add hidden disk - target_id matchs "\r\n"volume_id\n", ioc->name);\r\nmptsas_free_fw_event(ioc, fw_event);\r\nreturn;\r\n}\r\n}\r\nmpt_findImVolumes(ioc);\r\ncase MPTSAS_ADD_DEVICE:\r\nmemset(&sas_device, 0, sizeof(struct mptsas_devinfo));\r\nmptsas_sas_device_pg0(ioc, &sas_device,\r\n(MPI_SAS_DEVICE_PGAD_FORM_BUS_TARGET_ID <<\r\nMPI_SAS_DEVICE_PGAD_FORM_SHIFT),\r\n(hot_plug_info->channel << 8) +\r\nhot_plug_info->id);\r\nif (!(sas_device.flags & MPI_SAS_DEVICE0_FLAGS_DEVICE_PRESENT)\r\n|| !(sas_device.flags &\r\nMPI_SAS_DEVICE0_FLAGS_DEVICE_MAPPED))\r\nbreak;\r\nif (!sas_device.handle)\r\nreturn;\r\nphy_info = mptsas_refreshing_device_handles(ioc, &sas_device);\r\nif (!phy_info && (sas_device.device_info &\r\nMPI_SAS_DEVICE_INFO_SATA_DEVICE)) {\r\ndevtprintk(ioc, printk(MYIOC_s_DEBUG_FMT\r\n"%s %d SATA HOT PLUG: "\r\n"parent handle of device %x\n", ioc->name,\r\n__func__, __LINE__, sas_device.handle_parent));\r\nport_info = mptsas_find_portinfo_by_handle(ioc,\r\nsas_device.handle_parent);\r\nif (port_info == ioc->hba_port_info)\r\nmptsas_probe_hba_phys(ioc);\r\nelse if (port_info)\r\nmptsas_expander_refresh(ioc, port_info);\r\nelse {\r\ndfailprintk(ioc, printk(MYIOC_s_ERR_FMT\r\n"%s %d port info is NULL\n",\r\nioc->name, __func__, __LINE__));\r\nbreak;\r\n}\r\nphy_info = mptsas_refreshing_device_handles\r\n(ioc, &sas_device);\r\n}\r\nif (!phy_info) {\r\ndfailprintk(ioc, printk(MYIOC_s_ERR_FMT\r\n"%s %d phy info is NULL\n",\r\nioc->name, __func__, __LINE__));\r\nbreak;\r\n}\r\nif (mptsas_get_rphy(phy_info))\r\nbreak;\r\nmptsas_add_end_device(ioc, phy_info);\r\nbreak;\r\ncase MPTSAS_DEL_DEVICE:\r\nphy_info = mptsas_find_phyinfo_by_sas_address(ioc,\r\nhot_plug_info->sas_address);\r\nmptsas_del_end_device(ioc, phy_info);\r\nbreak;\r\ncase MPTSAS_DEL_PHYSDISK:\r\nmpt_findImVolumes(ioc);\r\nphy_info = mptsas_find_phyinfo_by_phys_disk_num(\r\nioc, hot_plug_info->phys_disk_num,\r\nhot_plug_info->channel,\r\nhot_plug_info->id);\r\nmptsas_del_end_device(ioc, phy_info);\r\nbreak;\r\ncase MPTSAS_ADD_PHYSDISK_REPROBE:\r\nif (mptsas_sas_device_pg0(ioc, &sas_device,\r\n(MPI_SAS_DEVICE_PGAD_FORM_BUS_TARGET_ID <<\r\nMPI_SAS_DEVICE_PGAD_FORM_SHIFT),\r\n(hot_plug_info->channel << 8) + hot_plug_info->id)) {\r\ndfailprintk(ioc, printk(MYIOC_s_ERR_FMT\r\n"%s: fw_id=%d exit at line=%d\n", ioc->name,\r\n__func__, hot_plug_info->id, __LINE__));\r\nbreak;\r\n}\r\nif (!(sas_device.flags & MPI_SAS_DEVICE0_FLAGS_DEVICE_PRESENT)\r\n|| !(sas_device.flags &\r\nMPI_SAS_DEVICE0_FLAGS_DEVICE_MAPPED))\r\nbreak;\r\nphy_info = mptsas_find_phyinfo_by_sas_address(\r\nioc, sas_device.sas_address);\r\nif (!phy_info) {\r\ndfailprintk(ioc, printk(MYIOC_s_ERR_FMT\r\n"%s: fw_id=%d exit at line=%d\n", ioc->name,\r\n__func__, hot_plug_info->id, __LINE__));\r\nbreak;\r\n}\r\nstarget = mptsas_get_starget(phy_info);\r\nif (!starget) {\r\ndfailprintk(ioc, printk(MYIOC_s_ERR_FMT\r\n"%s: fw_id=%d exit at line=%d\n", ioc->name,\r\n__func__, hot_plug_info->id, __LINE__));\r\nbreak;\r\n}\r\nvtarget = starget->hostdata;\r\nif (!vtarget) {\r\ndfailprintk(ioc, printk(MYIOC_s_ERR_FMT\r\n"%s: fw_id=%d exit at line=%d\n", ioc->name,\r\n__func__, hot_plug_info->id, __LINE__));\r\nbreak;\r\n}\r\nmpt_findImVolumes(ioc);\r\nstarget_printk(KERN_INFO, starget, MYIOC_s_FMT "RAID Hidding: "\r\n"fw_channel=%d, fw_id=%d, physdsk %d, sas_addr 0x%llx\n",\r\nioc->name, hot_plug_info->channel, hot_plug_info->id,\r\nhot_plug_info->phys_disk_num, (unsigned long long)\r\nsas_device.sas_address);\r\nvtarget->id = hot_plug_info->phys_disk_num;\r\nvtarget->tflags |= MPT_TARGET_FLAGS_RAID_COMPONENT;\r\nphy_info->attached.phys_disk_num = hot_plug_info->phys_disk_num;\r\nmptsas_reprobe_target(starget, 1);\r\nbreak;\r\ncase MPTSAS_DEL_PHYSDISK_REPROBE:\r\nif (mptsas_sas_device_pg0(ioc, &sas_device,\r\n(MPI_SAS_DEVICE_PGAD_FORM_BUS_TARGET_ID <<\r\nMPI_SAS_DEVICE_PGAD_FORM_SHIFT),\r\n(hot_plug_info->channel << 8) + hot_plug_info->id)) {\r\ndfailprintk(ioc, printk(MYIOC_s_ERR_FMT\r\n"%s: fw_id=%d exit at line=%d\n",\r\nioc->name, __func__,\r\nhot_plug_info->id, __LINE__));\r\nbreak;\r\n}\r\nif (!(sas_device.flags & MPI_SAS_DEVICE0_FLAGS_DEVICE_PRESENT)\r\n|| !(sas_device.flags &\r\nMPI_SAS_DEVICE0_FLAGS_DEVICE_MAPPED))\r\nbreak;\r\nphy_info = mptsas_find_phyinfo_by_sas_address(ioc,\r\nsas_device.sas_address);\r\nif (!phy_info) {\r\ndfailprintk(ioc, printk(MYIOC_s_ERR_FMT\r\n"%s: fw_id=%d exit at line=%d\n", ioc->name,\r\n__func__, hot_plug_info->id, __LINE__));\r\nbreak;\r\n}\r\nstarget = mptsas_get_starget(phy_info);\r\nif (!starget) {\r\ndfailprintk(ioc, printk(MYIOC_s_ERR_FMT\r\n"%s: fw_id=%d exit at line=%d\n", ioc->name,\r\n__func__, hot_plug_info->id, __LINE__));\r\nbreak;\r\n}\r\nvtarget = starget->hostdata;\r\nif (!vtarget) {\r\ndfailprintk(ioc, printk(MYIOC_s_ERR_FMT\r\n"%s: fw_id=%d exit at line=%d\n", ioc->name,\r\n__func__, hot_plug_info->id, __LINE__));\r\nbreak;\r\n}\r\nif (!(vtarget->tflags & MPT_TARGET_FLAGS_RAID_COMPONENT)) {\r\ndfailprintk(ioc, printk(MYIOC_s_ERR_FMT\r\n"%s: fw_id=%d exit at line=%d\n", ioc->name,\r\n__func__, hot_plug_info->id, __LINE__));\r\nbreak;\r\n}\r\nmpt_findImVolumes(ioc);\r\nstarget_printk(KERN_INFO, starget, MYIOC_s_FMT "RAID Exposing:"\r\n" fw_channel=%d, fw_id=%d, physdsk %d, sas_addr 0x%llx\n",\r\nioc->name, hot_plug_info->channel, hot_plug_info->id,\r\nhot_plug_info->phys_disk_num, (unsigned long long)\r\nsas_device.sas_address);\r\nvtarget->tflags &= ~MPT_TARGET_FLAGS_RAID_COMPONENT;\r\nvtarget->id = hot_plug_info->id;\r\nphy_info->attached.phys_disk_num = ~0;\r\nmptsas_reprobe_target(starget, 0);\r\nmptsas_add_device_component_by_fw(ioc,\r\nhot_plug_info->channel, hot_plug_info->id);\r\nbreak;\r\ncase MPTSAS_ADD_RAID:\r\nmpt_findImVolumes(ioc);\r\nprintk(MYIOC_s_INFO_FMT "attaching raid volume, channel %d, "\r\n"id %d\n", ioc->name, MPTSAS_RAID_CHANNEL,\r\nhot_plug_info->id);\r\nscsi_add_device(ioc->sh, MPTSAS_RAID_CHANNEL,\r\nhot_plug_info->id, 0);\r\nbreak;\r\ncase MPTSAS_DEL_RAID:\r\nmpt_findImVolumes(ioc);\r\nprintk(MYIOC_s_INFO_FMT "removing raid volume, channel %d, "\r\n"id %d\n", ioc->name, MPTSAS_RAID_CHANNEL,\r\nhot_plug_info->id);\r\nscsi_remove_device(hot_plug_info->sdev);\r\nscsi_device_put(hot_plug_info->sdev);\r\nbreak;\r\ncase MPTSAS_ADD_INACTIVE_VOLUME:\r\nmpt_findImVolumes(ioc);\r\nmptsas_adding_inactive_raid_components(ioc,\r\nhot_plug_info->channel, hot_plug_info->id);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nmptsas_free_fw_event(ioc, fw_event);\r\n}\r\nstatic void\r\nmptsas_send_sas_event(struct fw_event_work *fw_event)\r\n{\r\nMPT_ADAPTER *ioc;\r\nstruct mptsas_hotplug_event hot_plug_info;\r\nEVENT_DATA_SAS_DEVICE_STATUS_CHANGE *sas_event_data;\r\nu32 device_info;\r\nu64 sas_address;\r\nioc = fw_event->ioc;\r\nsas_event_data = (EVENT_DATA_SAS_DEVICE_STATUS_CHANGE *)\r\nfw_event->event_data;\r\ndevice_info = le32_to_cpu(sas_event_data->DeviceInfo);\r\nif ((device_info &\r\n(MPI_SAS_DEVICE_INFO_SSP_TARGET |\r\nMPI_SAS_DEVICE_INFO_STP_TARGET |\r\nMPI_SAS_DEVICE_INFO_SATA_DEVICE)) == 0) {\r\nmptsas_free_fw_event(ioc, fw_event);\r\nreturn;\r\n}\r\nif (sas_event_data->ReasonCode ==\r\nMPI_EVENT_SAS_DEV_STAT_RC_NO_PERSIST_ADDED) {\r\nmptbase_sas_persist_operation(ioc,\r\nMPI_SAS_OP_CLEAR_NOT_PRESENT);\r\nmptsas_free_fw_event(ioc, fw_event);\r\nreturn;\r\n}\r\nswitch (sas_event_data->ReasonCode) {\r\ncase MPI_EVENT_SAS_DEV_STAT_RC_NOT_RESPONDING:\r\ncase MPI_EVENT_SAS_DEV_STAT_RC_ADDED:\r\nmemset(&hot_plug_info, 0, sizeof(struct mptsas_hotplug_event));\r\nhot_plug_info.handle = le16_to_cpu(sas_event_data->DevHandle);\r\nhot_plug_info.channel = sas_event_data->Bus;\r\nhot_plug_info.id = sas_event_data->TargetID;\r\nhot_plug_info.phy_id = sas_event_data->PhyNum;\r\nmemcpy(&sas_address, &sas_event_data->SASAddress,\r\nsizeof(u64));\r\nhot_plug_info.sas_address = le64_to_cpu(sas_address);\r\nhot_plug_info.device_info = device_info;\r\nif (sas_event_data->ReasonCode &\r\nMPI_EVENT_SAS_DEV_STAT_RC_ADDED)\r\nhot_plug_info.event_type = MPTSAS_ADD_DEVICE;\r\nelse\r\nhot_plug_info.event_type = MPTSAS_DEL_DEVICE;\r\nmptsas_hotplug_work(ioc, fw_event, &hot_plug_info);\r\nbreak;\r\ncase MPI_EVENT_SAS_DEV_STAT_RC_NO_PERSIST_ADDED:\r\nmptbase_sas_persist_operation(ioc,\r\nMPI_SAS_OP_CLEAR_NOT_PRESENT);\r\nmptsas_free_fw_event(ioc, fw_event);\r\nbreak;\r\ncase MPI_EVENT_SAS_DEV_STAT_RC_SMART_DATA:\r\ncase MPI_EVENT_SAS_DEV_STAT_RC_INTERNAL_DEVICE_RESET:\r\ndefault:\r\nmptsas_free_fw_event(ioc, fw_event);\r\nbreak;\r\n}\r\n}\r\nstatic void\r\nmptsas_send_raid_event(struct fw_event_work *fw_event)\r\n{\r\nMPT_ADAPTER *ioc;\r\nEVENT_DATA_RAID *raid_event_data;\r\nstruct mptsas_hotplug_event hot_plug_info;\r\nint status;\r\nint state;\r\nstruct scsi_device *sdev = NULL;\r\nVirtDevice *vdevice = NULL;\r\nRaidPhysDiskPage0_t phys_disk;\r\nioc = fw_event->ioc;\r\nraid_event_data = (EVENT_DATA_RAID *)fw_event->event_data;\r\nstatus = le32_to_cpu(raid_event_data->SettingsStatus);\r\nstate = (status >> 8) & 0xff;\r\nmemset(&hot_plug_info, 0, sizeof(struct mptsas_hotplug_event));\r\nhot_plug_info.id = raid_event_data->VolumeID;\r\nhot_plug_info.channel = raid_event_data->VolumeBus;\r\nhot_plug_info.phys_disk_num = raid_event_data->PhysDiskNum;\r\nif (raid_event_data->ReasonCode == MPI_EVENT_RAID_RC_VOLUME_DELETED ||\r\nraid_event_data->ReasonCode == MPI_EVENT_RAID_RC_VOLUME_CREATED ||\r\nraid_event_data->ReasonCode ==\r\nMPI_EVENT_RAID_RC_VOLUME_STATUS_CHANGED) {\r\nsdev = scsi_device_lookup(ioc->sh, MPTSAS_RAID_CHANNEL,\r\nhot_plug_info.id, 0);\r\nhot_plug_info.sdev = sdev;\r\nif (sdev)\r\nvdevice = sdev->hostdata;\r\n}\r\ndevtprintk(ioc, printk(MYIOC_s_DEBUG_FMT "Entering %s: "\r\n"ReasonCode=%02x\n", ioc->name, __func__,\r\nraid_event_data->ReasonCode));\r\nswitch (raid_event_data->ReasonCode) {\r\ncase MPI_EVENT_RAID_RC_PHYSDISK_DELETED:\r\nhot_plug_info.event_type = MPTSAS_DEL_PHYSDISK_REPROBE;\r\nbreak;\r\ncase MPI_EVENT_RAID_RC_PHYSDISK_CREATED:\r\nhot_plug_info.event_type = MPTSAS_ADD_PHYSDISK_REPROBE;\r\nbreak;\r\ncase MPI_EVENT_RAID_RC_PHYSDISK_STATUS_CHANGED:\r\nswitch (state) {\r\ncase MPI_PD_STATE_ONLINE:\r\ncase MPI_PD_STATE_NOT_COMPATIBLE:\r\nmpt_raid_phys_disk_pg0(ioc,\r\nraid_event_data->PhysDiskNum, &phys_disk);\r\nhot_plug_info.id = phys_disk.PhysDiskID;\r\nhot_plug_info.channel = phys_disk.PhysDiskBus;\r\nhot_plug_info.event_type = MPTSAS_ADD_PHYSDISK;\r\nbreak;\r\ncase MPI_PD_STATE_FAILED:\r\ncase MPI_PD_STATE_MISSING:\r\ncase MPI_PD_STATE_OFFLINE_AT_HOST_REQUEST:\r\ncase MPI_PD_STATE_FAILED_AT_HOST_REQUEST:\r\ncase MPI_PD_STATE_OFFLINE_FOR_ANOTHER_REASON:\r\nhot_plug_info.event_type = MPTSAS_DEL_PHYSDISK;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nbreak;\r\ncase MPI_EVENT_RAID_RC_VOLUME_DELETED:\r\nif (!sdev)\r\nbreak;\r\nvdevice->vtarget->deleted = 1;\r\nhot_plug_info.event_type = MPTSAS_DEL_RAID;\r\nbreak;\r\ncase MPI_EVENT_RAID_RC_VOLUME_CREATED:\r\nif (sdev) {\r\nscsi_device_put(sdev);\r\nbreak;\r\n}\r\nhot_plug_info.event_type = MPTSAS_ADD_RAID;\r\nbreak;\r\ncase MPI_EVENT_RAID_RC_VOLUME_STATUS_CHANGED:\r\nif (!(status & MPI_RAIDVOL0_STATUS_FLAG_ENABLED)) {\r\nif (!sdev)\r\nbreak;\r\nvdevice->vtarget->deleted = 1;\r\nhot_plug_info.event_type = MPTSAS_DEL_RAID;\r\nbreak;\r\n}\r\nswitch (state) {\r\ncase MPI_RAIDVOL0_STATUS_STATE_FAILED:\r\ncase MPI_RAIDVOL0_STATUS_STATE_MISSING:\r\nif (!sdev)\r\nbreak;\r\nvdevice->vtarget->deleted = 1;\r\nhot_plug_info.event_type = MPTSAS_DEL_RAID;\r\nbreak;\r\ncase MPI_RAIDVOL0_STATUS_STATE_OPTIMAL:\r\ncase MPI_RAIDVOL0_STATUS_STATE_DEGRADED:\r\nif (sdev) {\r\nscsi_device_put(sdev);\r\nbreak;\r\n}\r\nhot_plug_info.event_type = MPTSAS_ADD_RAID;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif (hot_plug_info.event_type != MPTSAS_IGNORE_EVENT)\r\nmptsas_hotplug_work(ioc, fw_event, &hot_plug_info);\r\nelse\r\nmptsas_free_fw_event(ioc, fw_event);\r\n}\r\nstatic int\r\nmptsas_issue_tm(MPT_ADAPTER *ioc, u8 type, u8 channel, u8 id, u64 lun,\r\nint task_context, ulong timeout, u8 *issue_reset)\r\n{\r\nMPT_FRAME_HDR *mf;\r\nSCSITaskMgmt_t *pScsiTm;\r\nint retval;\r\nunsigned long timeleft;\r\n*issue_reset = 0;\r\nmf = mpt_get_msg_frame(mptsasDeviceResetCtx, ioc);\r\nif (mf == NULL) {\r\nretval = -1;\r\ndtmprintk(ioc, printk(MYIOC_s_WARN_FMT "TaskMgmt request: no "\r\n"msg frames!!\n", ioc->name));\r\ngoto out;\r\n}\r\ndtmprintk(ioc, printk(MYIOC_s_DEBUG_FMT "TaskMgmt request: mr = %p, "\r\n"task_type = 0x%02X,\n\t timeout = %ld, fw_channel = %d, "\r\n"fw_id = %d, lun = %lld,\n\t task_context = 0x%x\n", ioc->name, mf,\r\ntype, timeout, channel, id, (unsigned long long)lun,\r\ntask_context));\r\npScsiTm = (SCSITaskMgmt_t *) mf;\r\nmemset(pScsiTm, 0, sizeof(SCSITaskMgmt_t));\r\npScsiTm->Function = MPI_FUNCTION_SCSI_TASK_MGMT;\r\npScsiTm->TaskType = type;\r\npScsiTm->MsgFlags = 0;\r\npScsiTm->TargetID = id;\r\npScsiTm->Bus = channel;\r\npScsiTm->ChainOffset = 0;\r\npScsiTm->Reserved = 0;\r\npScsiTm->Reserved1 = 0;\r\npScsiTm->TaskMsgContext = task_context;\r\nint_to_scsilun(lun, (struct scsi_lun *)pScsiTm->LUN);\r\nINITIALIZE_MGMT_STATUS(ioc->taskmgmt_cmds.status)\r\nCLEAR_MGMT_STATUS(ioc->internal_cmds.status)\r\nretval = 0;\r\nmpt_put_msg_frame_hi_pri(mptsasDeviceResetCtx, ioc, mf);\r\ntimeleft = wait_for_completion_timeout(&ioc->taskmgmt_cmds.done,\r\ntimeout*HZ);\r\nif (!(ioc->taskmgmt_cmds.status & MPT_MGMT_STATUS_COMMAND_GOOD)) {\r\nretval = -1;\r\ndtmprintk(ioc, printk(MYIOC_s_ERR_FMT\r\n"TaskMgmt request: TIMED OUT!(mr=%p)\n", ioc->name, mf));\r\nmpt_free_msg_frame(ioc, mf);\r\nif (ioc->taskmgmt_cmds.status & MPT_MGMT_STATUS_DID_IOCRESET)\r\ngoto out;\r\n*issue_reset = 1;\r\ngoto out;\r\n}\r\nif (!(ioc->taskmgmt_cmds.status & MPT_MGMT_STATUS_RF_VALID)) {\r\nretval = -1;\r\ndtmprintk(ioc, printk(MYIOC_s_DEBUG_FMT\r\n"TaskMgmt request: failed with no reply\n", ioc->name));\r\ngoto out;\r\n}\r\nout:\r\nCLEAR_MGMT_STATUS(ioc->taskmgmt_cmds.status)\r\nreturn retval;\r\n}\r\nstatic void\r\nmptsas_broadcast_primative_work(struct fw_event_work *fw_event)\r\n{\r\nMPT_ADAPTER *ioc = fw_event->ioc;\r\nMPT_FRAME_HDR *mf;\r\nVirtDevice *vdevice;\r\nint ii;\r\nstruct scsi_cmnd *sc;\r\nSCSITaskMgmtReply_t *pScsiTmReply;\r\nu8 issue_reset;\r\nint task_context;\r\nu8 channel, id;\r\nint lun;\r\nu32 termination_count;\r\nu32 query_count;\r\ndtmprintk(ioc, printk(MYIOC_s_DEBUG_FMT\r\n"%s - enter\n", ioc->name, __func__));\r\nmutex_lock(&ioc->taskmgmt_cmds.mutex);\r\nif (mpt_set_taskmgmt_in_progress_flag(ioc) != 0) {\r\nmutex_unlock(&ioc->taskmgmt_cmds.mutex);\r\nmptsas_requeue_fw_event(ioc, fw_event, 1000);\r\nreturn;\r\n}\r\nissue_reset = 0;\r\ntermination_count = 0;\r\nquery_count = 0;\r\nmpt_findImVolumes(ioc);\r\npScsiTmReply = (SCSITaskMgmtReply_t *) ioc->taskmgmt_cmds.reply;\r\nfor (ii = 0; ii < ioc->req_depth; ii++) {\r\nif (ioc->fw_events_off)\r\ngoto out;\r\nsc = mptscsih_get_scsi_lookup(ioc, ii);\r\nif (!sc)\r\ncontinue;\r\nmf = MPT_INDEX_2_MFPTR(ioc, ii);\r\nif (!mf)\r\ncontinue;\r\ntask_context = mf->u.frame.hwhdr.msgctxu.MsgContext;\r\nvdevice = sc->device->hostdata;\r\nif (!vdevice || !vdevice->vtarget)\r\ncontinue;\r\nif (vdevice->vtarget->tflags & MPT_TARGET_FLAGS_RAID_COMPONENT)\r\ncontinue;\r\nif (vdevice->vtarget->raidVolume)\r\ncontinue;\r\nchannel = vdevice->vtarget->channel;\r\nid = vdevice->vtarget->id;\r\nlun = vdevice->lun;\r\nif (mptsas_issue_tm(ioc, MPI_SCSITASKMGMT_TASKTYPE_QUERY_TASK,\r\nchannel, id, (u64)lun, task_context, 30, &issue_reset))\r\ngoto out;\r\nquery_count++;\r\ntermination_count +=\r\nle32_to_cpu(pScsiTmReply->TerminationCount);\r\nif ((pScsiTmReply->IOCStatus == MPI_IOCSTATUS_SUCCESS) &&\r\n(pScsiTmReply->ResponseCode ==\r\nMPI_SCSITASKMGMT_RSP_TM_SUCCEEDED ||\r\npScsiTmReply->ResponseCode ==\r\nMPI_SCSITASKMGMT_RSP_IO_QUEUED_ON_IOC))\r\ncontinue;\r\nif (mptsas_issue_tm(ioc,\r\nMPI_SCSITASKMGMT_TASKTYPE_ABRT_TASK_SET,\r\nchannel, id, (u64)lun, 0, 30, &issue_reset))\r\ngoto out;\r\ntermination_count +=\r\nle32_to_cpu(pScsiTmReply->TerminationCount);\r\n}\r\nout:\r\ndtmprintk(ioc, printk(MYIOC_s_DEBUG_FMT\r\n"%s - exit, query_count = %d termination_count = %d\n",\r\nioc->name, __func__, query_count, termination_count));\r\nioc->broadcast_aen_busy = 0;\r\nmpt_clear_taskmgmt_in_progress_flag(ioc);\r\nmutex_unlock(&ioc->taskmgmt_cmds.mutex);\r\nif (issue_reset) {\r\nprintk(MYIOC_s_WARN_FMT\r\n"Issuing Reset from %s!! doorbell=0x%08x\n",\r\nioc->name, __func__, mpt_GetIocState(ioc, 0));\r\nmpt_Soft_Hard_ResetHandler(ioc, CAN_SLEEP);\r\n}\r\nmptsas_free_fw_event(ioc, fw_event);\r\n}\r\nstatic void\r\nmptsas_send_ir2_event(struct fw_event_work *fw_event)\r\n{\r\nMPT_ADAPTER *ioc;\r\nstruct mptsas_hotplug_event hot_plug_info;\r\nMPI_EVENT_DATA_IR2 *ir2_data;\r\nu8 reasonCode;\r\nRaidPhysDiskPage0_t phys_disk;\r\nioc = fw_event->ioc;\r\nir2_data = (MPI_EVENT_DATA_IR2 *)fw_event->event_data;\r\nreasonCode = ir2_data->ReasonCode;\r\ndevtprintk(ioc, printk(MYIOC_s_DEBUG_FMT "Entering %s: "\r\n"ReasonCode=%02x\n", ioc->name, __func__, reasonCode));\r\nmemset(&hot_plug_info, 0, sizeof(struct mptsas_hotplug_event));\r\nhot_plug_info.id = ir2_data->TargetID;\r\nhot_plug_info.channel = ir2_data->Bus;\r\nswitch (reasonCode) {\r\ncase MPI_EVENT_IR2_RC_FOREIGN_CFG_DETECTED:\r\nhot_plug_info.event_type = MPTSAS_ADD_INACTIVE_VOLUME;\r\nbreak;\r\ncase MPI_EVENT_IR2_RC_DUAL_PORT_REMOVED:\r\nhot_plug_info.phys_disk_num = ir2_data->PhysDiskNum;\r\nhot_plug_info.event_type = MPTSAS_DEL_PHYSDISK;\r\nbreak;\r\ncase MPI_EVENT_IR2_RC_DUAL_PORT_ADDED:\r\nhot_plug_info.phys_disk_num = ir2_data->PhysDiskNum;\r\nmpt_raid_phys_disk_pg0(ioc,\r\nir2_data->PhysDiskNum, &phys_disk);\r\nhot_plug_info.id = phys_disk.PhysDiskID;\r\nhot_plug_info.event_type = MPTSAS_ADD_PHYSDISK;\r\nbreak;\r\ndefault:\r\nmptsas_free_fw_event(ioc, fw_event);\r\nreturn;\r\n}\r\nmptsas_hotplug_work(ioc, fw_event, &hot_plug_info);\r\n}\r\nstatic int\r\nmptsas_event_process(MPT_ADAPTER *ioc, EventNotificationReply_t *reply)\r\n{\r\nu32 event = le32_to_cpu(reply->Event);\r\nint event_data_sz;\r\nstruct fw_event_work *fw_event;\r\nunsigned long delay;\r\nif (ioc->bus_type != SAS)\r\nreturn 0;\r\nif (ioc->fw_events_off)\r\nreturn 0;\r\ndelay = msecs_to_jiffies(1);\r\nswitch (event) {\r\ncase MPI_EVENT_SAS_BROADCAST_PRIMITIVE:\r\n{\r\nEVENT_DATA_SAS_BROADCAST_PRIMITIVE *broadcast_event_data =\r\n(EVENT_DATA_SAS_BROADCAST_PRIMITIVE *)reply->Data;\r\nif (broadcast_event_data->Primitive !=\r\nMPI_EVENT_PRIMITIVE_ASYNCHRONOUS_EVENT)\r\nreturn 0;\r\nif (ioc->broadcast_aen_busy)\r\nreturn 0;\r\nioc->broadcast_aen_busy = 1;\r\nbreak;\r\n}\r\ncase MPI_EVENT_SAS_DEVICE_STATUS_CHANGE:\r\n{\r\nEVENT_DATA_SAS_DEVICE_STATUS_CHANGE *sas_event_data =\r\n(EVENT_DATA_SAS_DEVICE_STATUS_CHANGE *)reply->Data;\r\nu16 ioc_stat;\r\nioc_stat = le16_to_cpu(reply->IOCStatus);\r\nif (sas_event_data->ReasonCode ==\r\nMPI_EVENT_SAS_DEV_STAT_RC_NOT_RESPONDING) {\r\nmptsas_target_reset_queue(ioc, sas_event_data);\r\nreturn 0;\r\n}\r\nif (sas_event_data->ReasonCode ==\r\nMPI_EVENT_SAS_DEV_STAT_RC_INTERNAL_DEVICE_RESET &&\r\nioc->device_missing_delay &&\r\n(ioc_stat & MPI_IOCSTATUS_FLAG_LOG_INFO_AVAILABLE)) {\r\nVirtTarget *vtarget = NULL;\r\nu8 id, channel;\r\nid = sas_event_data->TargetID;\r\nchannel = sas_event_data->Bus;\r\nvtarget = mptsas_find_vtarget(ioc, channel, id);\r\nif (vtarget) {\r\ndevtprintk(ioc, printk(MYIOC_s_DEBUG_FMT\r\n"LogInfo (0x%x) available for "\r\n"INTERNAL_DEVICE_RESET"\r\n"fw_id %d fw_channel %d\n", ioc->name,\r\nle32_to_cpu(reply->IOCLogInfo),\r\nid, channel));\r\nif (vtarget->raidVolume) {\r\ndevtprintk(ioc, printk(MYIOC_s_DEBUG_FMT\r\n"Skipping Raid Volume for inDMD\n",\r\nioc->name));\r\n} else {\r\ndevtprintk(ioc, printk(MYIOC_s_DEBUG_FMT\r\n"Setting device flag inDMD\n",\r\nioc->name));\r\nvtarget->inDMD = 1;\r\n}\r\n}\r\n}\r\nbreak;\r\n}\r\ncase MPI_EVENT_SAS_EXPANDER_STATUS_CHANGE:\r\n{\r\nMpiEventDataSasExpanderStatusChange_t *expander_data =\r\n(MpiEventDataSasExpanderStatusChange_t *)reply->Data;\r\nif (ioc->old_sas_discovery_protocal)\r\nreturn 0;\r\nif (expander_data->ReasonCode ==\r\nMPI_EVENT_SAS_EXP_RC_NOT_RESPONDING &&\r\nioc->device_missing_delay)\r\ndelay = HZ * ioc->device_missing_delay;\r\nbreak;\r\n}\r\ncase MPI_EVENT_SAS_DISCOVERY:\r\n{\r\nu32 discovery_status;\r\nEventDataSasDiscovery_t *discovery_data =\r\n(EventDataSasDiscovery_t *)reply->Data;\r\ndiscovery_status = le32_to_cpu(discovery_data->DiscoveryStatus);\r\nioc->sas_discovery_quiesce_io = discovery_status ? 1 : 0;\r\nif (ioc->old_sas_discovery_protocal && !discovery_status)\r\nmptsas_queue_rescan(ioc);\r\nreturn 0;\r\n}\r\ncase MPI_EVENT_INTEGRATED_RAID:\r\ncase MPI_EVENT_PERSISTENT_TABLE_FULL:\r\ncase MPI_EVENT_IR2:\r\ncase MPI_EVENT_SAS_PHY_LINK_STATUS:\r\ncase MPI_EVENT_QUEUE_FULL:\r\nbreak;\r\ndefault:\r\nreturn 0;\r\n}\r\nevent_data_sz = ((reply->MsgLength * 4) -\r\noffsetof(EventNotificationReply_t, Data));\r\nfw_event = kzalloc(sizeof(*fw_event) + event_data_sz, GFP_ATOMIC);\r\nif (!fw_event) {\r\nprintk(MYIOC_s_WARN_FMT "%s: failed at (line=%d)\n", ioc->name,\r\n__func__, __LINE__);\r\nreturn 0;\r\n}\r\nmemcpy(fw_event->event_data, reply->Data, event_data_sz);\r\nfw_event->event = event;\r\nfw_event->ioc = ioc;\r\nmptsas_add_fw_event(ioc, fw_event, delay);\r\nreturn 0;\r\n}\r\nstatic void mptsas_volume_delete(MPT_ADAPTER *ioc, u8 id)\r\n{\r\nstruct scsi_device *sdev;\r\nint i;\r\nsdev = scsi_device_lookup(ioc->sh, MPTSAS_RAID_CHANNEL, id, 0);\r\nif (!sdev)\r\nreturn;\r\nif (!ioc->raid_data.pIocPg2)\r\ngoto out;\r\nif (!ioc->raid_data.pIocPg2->NumActiveVolumes)\r\ngoto out;\r\nfor (i = 0; i < ioc->raid_data.pIocPg2->NumActiveVolumes; i++)\r\nif (ioc->raid_data.pIocPg2->RaidVolume[i].VolumeID == id)\r\ngoto release_sdev;\r\nout:\r\nprintk(MYIOC_s_INFO_FMT "removing raid volume, channel %d, "\r\n"id %d\n", ioc->name, MPTSAS_RAID_CHANNEL, id);\r\nscsi_remove_device(sdev);\r\nrelease_sdev:\r\nscsi_device_put(sdev);\r\n}\r\nstatic int\r\nmptsas_probe(struct pci_dev *pdev, const struct pci_device_id *id)\r\n{\r\nstruct Scsi_Host *sh;\r\nMPT_SCSI_HOST *hd;\r\nMPT_ADAPTER *ioc;\r\nunsigned long flags;\r\nint ii;\r\nint numSGE = 0;\r\nint scale;\r\nint ioc_cap;\r\nint error=0;\r\nint r;\r\nr = mpt_attach(pdev,id);\r\nif (r)\r\nreturn r;\r\nioc = pci_get_drvdata(pdev);\r\nmptsas_fw_event_off(ioc);\r\nioc->DoneCtx = mptsasDoneCtx;\r\nioc->TaskCtx = mptsasTaskCtx;\r\nioc->InternalCtx = mptsasInternalCtx;\r\nioc->schedule_target_reset = &mptsas_schedule_target_reset;\r\nioc->schedule_dead_ioc_flush_running_cmds =\r\n&mptscsih_flush_running_cmds;\r\nif (ioc->last_state != MPI_IOC_STATE_OPERATIONAL) {\r\nprintk(MYIOC_s_WARN_FMT\r\n"Skipping because it's not operational!\n",\r\nioc->name);\r\nerror = -ENODEV;\r\ngoto out_mptsas_probe;\r\n}\r\nif (!ioc->active) {\r\nprintk(MYIOC_s_WARN_FMT "Skipping because it's disabled!\n",\r\nioc->name);\r\nerror = -ENODEV;\r\ngoto out_mptsas_probe;\r\n}\r\nioc_cap = 0;\r\nfor (ii = 0; ii < ioc->facts.NumberOfPorts; ii++) {\r\nif (ioc->pfacts[ii].ProtocolFlags &\r\nMPI_PORTFACTS_PROTOCOL_INITIATOR)\r\nioc_cap++;\r\n}\r\nif (!ioc_cap) {\r\nprintk(MYIOC_s_WARN_FMT\r\n"Skipping ioc=%p because SCSI Initiator mode "\r\n"is NOT enabled!\n", ioc->name, ioc);\r\nreturn 0;\r\n}\r\nsh = scsi_host_alloc(&mptsas_driver_template, sizeof(MPT_SCSI_HOST));\r\nif (!sh) {\r\nprintk(MYIOC_s_WARN_FMT\r\n"Unable to register controller with SCSI subsystem\n",\r\nioc->name);\r\nerror = -1;\r\ngoto out_mptsas_probe;\r\n}\r\nspin_lock_irqsave(&ioc->FreeQlock, flags);\r\nioc->sh = sh;\r\nsh->io_port = 0;\r\nsh->n_io_port = 0;\r\nsh->irq = 0;\r\nsh->max_cmd_len = 16;\r\nsh->can_queue = min_t(int, ioc->req_depth - 10, sh->can_queue);\r\nsh->max_id = -1;\r\nsh->max_lun = max_lun;\r\nsh->transportt = mptsas_transport_template;\r\nsh->unique_id = ioc->id;\r\nINIT_LIST_HEAD(&ioc->sas_topology);\r\nmutex_init(&ioc->sas_topology_mutex);\r\nmutex_init(&ioc->sas_discovery_mutex);\r\nmutex_init(&ioc->sas_mgmt.mutex);\r\ninit_completion(&ioc->sas_mgmt.done);\r\nscale = ioc->req_sz/ioc->SGE_size;\r\nif (ioc->sg_addr_size == sizeof(u64)) {\r\nnumSGE = (scale - 1) *\r\n(ioc->facts.MaxChainDepth-1) + scale +\r\n(ioc->req_sz - 60) / ioc->SGE_size;\r\n} else {\r\nnumSGE = 1 + (scale - 1) *\r\n(ioc->facts.MaxChainDepth-1) + scale +\r\n(ioc->req_sz - 64) / ioc->SGE_size;\r\n}\r\nif (numSGE < sh->sg_tablesize) {\r\ndprintk(ioc, printk(MYIOC_s_DEBUG_FMT\r\n"Resetting sg_tablesize to %d from %d\n",\r\nioc->name, numSGE, sh->sg_tablesize));\r\nsh->sg_tablesize = numSGE;\r\n}\r\nif (mpt_loadtime_max_sectors) {\r\nif (mpt_loadtime_max_sectors < 64 ||\r\nmpt_loadtime_max_sectors > 8192) {\r\nprintk(MYIOC_s_INFO_FMT "Invalid value passed for"\r\n"mpt_loadtime_max_sectors %d."\r\n"Range from 64 to 8192\n", ioc->name,\r\nmpt_loadtime_max_sectors);\r\n}\r\nmpt_loadtime_max_sectors &= 0xFFFFFFFE;\r\ndprintk(ioc, printk(MYIOC_s_DEBUG_FMT\r\n"Resetting max sector to %d from %d\n",\r\nioc->name, mpt_loadtime_max_sectors, sh->max_sectors));\r\nsh->max_sectors = mpt_loadtime_max_sectors;\r\n}\r\nhd = shost_priv(sh);\r\nhd->ioc = ioc;\r\nioc->ScsiLookup = kcalloc(ioc->req_depth, sizeof(void *), GFP_ATOMIC);\r\nif (!ioc->ScsiLookup) {\r\nerror = -ENOMEM;\r\nspin_unlock_irqrestore(&ioc->FreeQlock, flags);\r\ngoto out_mptsas_probe;\r\n}\r\nspin_lock_init(&ioc->scsi_lookup_lock);\r\ndprintk(ioc, printk(MYIOC_s_DEBUG_FMT "ScsiLookup @ %p\n",\r\nioc->name, ioc->ScsiLookup));\r\nioc->sas_data.ptClear = mpt_pt_clear;\r\nhd->last_queue_full = 0;\r\nINIT_LIST_HEAD(&hd->target_reset_list);\r\nINIT_LIST_HEAD(&ioc->sas_device_info_list);\r\nmutex_init(&ioc->sas_device_info_mutex);\r\nspin_unlock_irqrestore(&ioc->FreeQlock, flags);\r\nif (ioc->sas_data.ptClear==1) {\r\nmptbase_sas_persist_operation(\r\nioc, MPI_SAS_OP_CLEAR_ALL_PERSISTENT);\r\n}\r\nerror = scsi_add_host(sh, &ioc->pcidev->dev);\r\nif (error) {\r\ndprintk(ioc, printk(MYIOC_s_ERR_FMT\r\n"scsi_add_host failed\n", ioc->name));\r\ngoto out_mptsas_probe;\r\n}\r\nif ((ioc->facts.HeaderVersion >> 8) < 0xE)\r\nioc->old_sas_discovery_protocal = 1;\r\nmptsas_scan_sas_topology(ioc);\r\nmptsas_fw_event_on(ioc);\r\nreturn 0;\r\nout_mptsas_probe:\r\nmptscsih_remove(pdev);\r\nreturn error;\r\n}\r\nstatic void\r\nmptsas_shutdown(struct pci_dev *pdev)\r\n{\r\nMPT_ADAPTER *ioc = pci_get_drvdata(pdev);\r\nmptsas_fw_event_off(ioc);\r\nmptsas_cleanup_fw_event_q(ioc);\r\n}\r\nstatic void mptsas_remove(struct pci_dev *pdev)\r\n{\r\nMPT_ADAPTER *ioc = pci_get_drvdata(pdev);\r\nstruct mptsas_portinfo *p, *n;\r\nint i;\r\nif (!ioc->sh) {\r\nprintk(MYIOC_s_INFO_FMT "IOC is in Target mode\n", ioc->name);\r\nmpt_detach(pdev);\r\nreturn;\r\n}\r\nmptsas_shutdown(pdev);\r\nmptsas_del_device_components(ioc);\r\nioc->sas_discovery_ignore_events = 1;\r\nsas_remove_host(ioc->sh);\r\nmutex_lock(&ioc->sas_topology_mutex);\r\nlist_for_each_entry_safe(p, n, &ioc->sas_topology, list) {\r\nlist_del(&p->list);\r\nfor (i = 0 ; i < p->num_phys ; i++)\r\nmptsas_port_delete(ioc, p->phy_info[i].port_details);\r\nkfree(p->phy_info);\r\nkfree(p);\r\n}\r\nmutex_unlock(&ioc->sas_topology_mutex);\r\nioc->hba_port_info = NULL;\r\nmptscsih_remove(pdev);\r\n}\r\nstatic int __init\r\nmptsas_init(void)\r\n{\r\nint error;\r\nshow_mptmod_ver(my_NAME, my_VERSION);\r\nmptsas_transport_template =\r\nsas_attach_transport(&mptsas_transport_functions);\r\nif (!mptsas_transport_template)\r\nreturn -ENODEV;\r\nmptsas_transport_template->eh_timed_out = mptsas_eh_timed_out;\r\nmptsasDoneCtx = mpt_register(mptscsih_io_done, MPTSAS_DRIVER,\r\n"mptscsih_io_done");\r\nmptsasTaskCtx = mpt_register(mptscsih_taskmgmt_complete, MPTSAS_DRIVER,\r\n"mptscsih_taskmgmt_complete");\r\nmptsasInternalCtx =\r\nmpt_register(mptscsih_scandv_complete, MPTSAS_DRIVER,\r\n"mptscsih_scandv_complete");\r\nmptsasMgmtCtx = mpt_register(mptsas_mgmt_done, MPTSAS_DRIVER,\r\n"mptsas_mgmt_done");\r\nmptsasDeviceResetCtx =\r\nmpt_register(mptsas_taskmgmt_complete, MPTSAS_DRIVER,\r\n"mptsas_taskmgmt_complete");\r\nmpt_event_register(mptsasDoneCtx, mptsas_event_process);\r\nmpt_reset_register(mptsasDoneCtx, mptsas_ioc_reset);\r\nerror = pci_register_driver(&mptsas_driver);\r\nif (error)\r\nsas_release_transport(mptsas_transport_template);\r\nreturn error;\r\n}\r\nstatic void __exit\r\nmptsas_exit(void)\r\n{\r\npci_unregister_driver(&mptsas_driver);\r\nsas_release_transport(mptsas_transport_template);\r\nmpt_reset_deregister(mptsasDoneCtx);\r\nmpt_event_deregister(mptsasDoneCtx);\r\nmpt_deregister(mptsasMgmtCtx);\r\nmpt_deregister(mptsasInternalCtx);\r\nmpt_deregister(mptsasTaskCtx);\r\nmpt_deregister(mptsasDoneCtx);\r\nmpt_deregister(mptsasDeviceResetCtx);\r\n}
