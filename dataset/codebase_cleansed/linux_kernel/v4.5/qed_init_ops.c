void qed_init_iro_array(struct qed_dev *cdev)\r\n{\r\ncdev->iro_arr = iro_arr;\r\n}\r\nvoid qed_init_clear_rt_data(struct qed_hwfn *p_hwfn)\r\n{\r\nint i;\r\nfor (i = 0; i < RUNTIME_ARRAY_SIZE; i++)\r\np_hwfn->rt_data[i].b_valid = false;\r\n}\r\nvoid qed_init_store_rt_reg(struct qed_hwfn *p_hwfn,\r\nu32 rt_offset,\r\nu32 val)\r\n{\r\np_hwfn->rt_data[rt_offset].init_val = val;\r\np_hwfn->rt_data[rt_offset].b_valid = true;\r\n}\r\nvoid qed_init_store_rt_agg(struct qed_hwfn *p_hwfn,\r\nu32 rt_offset,\r\nu32 *val,\r\nsize_t size)\r\n{\r\nsize_t i;\r\nfor (i = 0; i < size / sizeof(u32); i++) {\r\np_hwfn->rt_data[rt_offset + i].init_val = val[i];\r\np_hwfn->rt_data[rt_offset + i].b_valid = true;\r\n}\r\n}\r\nstatic void qed_init_rt(struct qed_hwfn *p_hwfn,\r\nstruct qed_ptt *p_ptt,\r\nu32 addr,\r\nu32 rt_offset,\r\nu32 size)\r\n{\r\nstruct qed_rt_data *rt_data = p_hwfn->rt_data + rt_offset;\r\nu32 i;\r\nfor (i = 0; i < size; i++) {\r\nif (!rt_data[i].b_valid)\r\ncontinue;\r\nqed_wr(p_hwfn, p_ptt, addr + (i << 2), rt_data[i].init_val);\r\n}\r\n}\r\nint qed_init_alloc(struct qed_hwfn *p_hwfn)\r\n{\r\nstruct qed_rt_data *rt_data;\r\nrt_data = kzalloc(sizeof(*rt_data) * RUNTIME_ARRAY_SIZE, GFP_ATOMIC);\r\nif (!rt_data)\r\nreturn -ENOMEM;\r\np_hwfn->rt_data = rt_data;\r\nreturn 0;\r\n}\r\nvoid qed_init_free(struct qed_hwfn *p_hwfn)\r\n{\r\nkfree(p_hwfn->rt_data);\r\np_hwfn->rt_data = NULL;\r\n}\r\nstatic int qed_init_array_dmae(struct qed_hwfn *p_hwfn,\r\nstruct qed_ptt *p_ptt,\r\nu32 addr,\r\nu32 dmae_data_offset,\r\nu32 size,\r\nconst u32 *buf,\r\nbool b_must_dmae,\r\nbool b_can_dmae)\r\n{\r\nint rc = 0;\r\nif (!b_can_dmae || (!b_must_dmae && (size < 16))) {\r\nconst u32 *data = buf + dmae_data_offset;\r\nu32 i;\r\nfor (i = 0; i < size; i++)\r\nqed_wr(p_hwfn, p_ptt, addr + (i << 2), data[i]);\r\n} else {\r\nrc = qed_dmae_host2grc(p_hwfn, p_ptt,\r\n(uintptr_t)(buf + dmae_data_offset),\r\naddr, size, 0);\r\n}\r\nreturn rc;\r\n}\r\nstatic int qed_init_fill_dmae(struct qed_hwfn *p_hwfn,\r\nstruct qed_ptt *p_ptt,\r\nu32 addr,\r\nu32 fill,\r\nu32 fill_count)\r\n{\r\nstatic u32 zero_buffer[DMAE_MAX_RW_SIZE];\r\nmemset(zero_buffer, 0, sizeof(u32) * DMAE_MAX_RW_SIZE);\r\nreturn qed_dmae_host2grc(p_hwfn, p_ptt,\r\n(uintptr_t)(&zero_buffer[0]),\r\naddr, fill_count,\r\nQED_DMAE_FLAG_RW_REPL_SRC);\r\n}\r\nstatic void qed_init_fill(struct qed_hwfn *p_hwfn,\r\nstruct qed_ptt *p_ptt,\r\nu32 addr,\r\nu32 fill,\r\nu32 fill_count)\r\n{\r\nu32 i;\r\nfor (i = 0; i < fill_count; i++, addr += sizeof(u32))\r\nqed_wr(p_hwfn, p_ptt, addr, fill);\r\n}\r\nstatic int qed_init_cmd_array(struct qed_hwfn *p_hwfn,\r\nstruct qed_ptt *p_ptt,\r\nstruct init_write_op *cmd,\r\nbool b_must_dmae,\r\nbool b_can_dmae)\r\n{\r\nu32 data = le32_to_cpu(cmd->data);\r\nu32 addr = GET_FIELD(data, INIT_WRITE_OP_ADDRESS) << 2;\r\nu32 dmae_array_offset = le32_to_cpu(cmd->args.array_offset);\r\nu32 offset, output_len, input_len, max_size;\r\nstruct qed_dev *cdev = p_hwfn->cdev;\r\nunion init_array_hdr *hdr;\r\nconst u32 *array_data;\r\nint rc = 0;\r\nu32 size;\r\narray_data = cdev->fw_data->arr_data;\r\nhdr = (union init_array_hdr *)(array_data +\r\ndmae_array_offset);\r\ndata = le32_to_cpu(hdr->raw.data);\r\nswitch (GET_FIELD(data, INIT_ARRAY_RAW_HDR_TYPE)) {\r\ncase INIT_ARR_ZIPPED:\r\noffset = dmae_array_offset + 1;\r\ninput_len = GET_FIELD(data,\r\nINIT_ARRAY_ZIPPED_HDR_ZIPPED_SIZE);\r\nmax_size = MAX_ZIPPED_SIZE * 4;\r\nmemset(p_hwfn->unzip_buf, 0, max_size);\r\noutput_len = qed_unzip_data(p_hwfn, input_len,\r\n(u8 *)&array_data[offset],\r\nmax_size, (u8 *)p_hwfn->unzip_buf);\r\nif (output_len) {\r\nrc = qed_init_array_dmae(p_hwfn, p_ptt, addr, 0,\r\noutput_len,\r\np_hwfn->unzip_buf,\r\nb_must_dmae, b_can_dmae);\r\n} else {\r\nDP_NOTICE(p_hwfn, "Failed to unzip dmae data\n");\r\nrc = -EINVAL;\r\n}\r\nbreak;\r\ncase INIT_ARR_PATTERN:\r\n{\r\nu32 repeats = GET_FIELD(data,\r\nINIT_ARRAY_PATTERN_HDR_REPETITIONS);\r\nu32 i;\r\nsize = GET_FIELD(data, INIT_ARRAY_PATTERN_HDR_PATTERN_SIZE);\r\nfor (i = 0; i < repeats; i++, addr += size << 2) {\r\nrc = qed_init_array_dmae(p_hwfn, p_ptt, addr,\r\ndmae_array_offset + 1,\r\nsize, array_data,\r\nb_must_dmae, b_can_dmae);\r\nif (rc)\r\nbreak;\r\n}\r\nbreak;\r\n}\r\ncase INIT_ARR_STANDARD:\r\nsize = GET_FIELD(data, INIT_ARRAY_STANDARD_HDR_SIZE);\r\nrc = qed_init_array_dmae(p_hwfn, p_ptt, addr,\r\ndmae_array_offset + 1,\r\nsize, array_data,\r\nb_must_dmae, b_can_dmae);\r\nbreak;\r\n}\r\nreturn rc;\r\n}\r\nstatic int qed_init_cmd_wr(struct qed_hwfn *p_hwfn,\r\nstruct qed_ptt *p_ptt,\r\nstruct init_write_op *cmd,\r\nbool b_can_dmae)\r\n{\r\nu32 data = le32_to_cpu(cmd->data);\r\nu32 addr = GET_FIELD(data, INIT_WRITE_OP_ADDRESS) << 2;\r\nbool b_must_dmae = GET_FIELD(data, INIT_WRITE_OP_WIDE_BUS);\r\nunion init_write_args *arg = &cmd->args;\r\nint rc = 0;\r\nif (b_must_dmae && !b_can_dmae) {\r\nDP_NOTICE(p_hwfn,\r\n"Need to write to %08x for Wide-bus but DMAE isn't allowed\n",\r\naddr);\r\nreturn -EINVAL;\r\n}\r\nswitch (GET_FIELD(data, INIT_WRITE_OP_SOURCE)) {\r\ncase INIT_SRC_INLINE:\r\nqed_wr(p_hwfn, p_ptt, addr,\r\nle32_to_cpu(arg->inline_val));\r\nbreak;\r\ncase INIT_SRC_ZEROS:\r\nif (b_must_dmae ||\r\n(b_can_dmae && (le32_to_cpu(arg->zeros_count) >= 64)))\r\nrc = qed_init_fill_dmae(p_hwfn, p_ptt, addr, 0,\r\nle32_to_cpu(arg->zeros_count));\r\nelse\r\nqed_init_fill(p_hwfn, p_ptt, addr, 0,\r\nle32_to_cpu(arg->zeros_count));\r\nbreak;\r\ncase INIT_SRC_ARRAY:\r\nrc = qed_init_cmd_array(p_hwfn, p_ptt, cmd,\r\nb_must_dmae, b_can_dmae);\r\nbreak;\r\ncase INIT_SRC_RUNTIME:\r\nqed_init_rt(p_hwfn, p_ptt, addr,\r\nle16_to_cpu(arg->runtime.offset),\r\nle16_to_cpu(arg->runtime.size));\r\nbreak;\r\n}\r\nreturn rc;\r\n}\r\nstatic inline bool comp_eq(u32 val, u32 expected_val)\r\n{\r\nreturn val == expected_val;\r\n}\r\nstatic inline bool comp_and(u32 val, u32 expected_val)\r\n{\r\nreturn (val & expected_val) == expected_val;\r\n}\r\nstatic inline bool comp_or(u32 val, u32 expected_val)\r\n{\r\nreturn (val | expected_val) > 0;\r\n}\r\nstatic void qed_init_cmd_rd(struct qed_hwfn *p_hwfn,\r\nstruct qed_ptt *p_ptt,\r\nstruct init_read_op *cmd)\r\n{\r\nu32 data = le32_to_cpu(cmd->op_data);\r\nu32 addr = GET_FIELD(data, INIT_READ_OP_ADDRESS) << 2;\r\nbool (*comp_check)(u32 val,\r\nu32 expected_val);\r\nu32 delay = QED_INIT_POLL_PERIOD_US, val;\r\nval = qed_rd(p_hwfn, p_ptt, addr);\r\ndata = le32_to_cpu(cmd->op_data);\r\nif (GET_FIELD(data, INIT_READ_OP_POLL)) {\r\nint i;\r\nswitch (GET_FIELD(data, INIT_READ_OP_POLL_COMP)) {\r\ncase INIT_COMPARISON_EQ:\r\ncomp_check = comp_eq;\r\nbreak;\r\ncase INIT_COMPARISON_OR:\r\ncomp_check = comp_or;\r\nbreak;\r\ncase INIT_COMPARISON_AND:\r\ncomp_check = comp_and;\r\nbreak;\r\ndefault:\r\ncomp_check = NULL;\r\nDP_ERR(p_hwfn, "Invalid poll comparison type %08x\n",\r\ndata);\r\nreturn;\r\n}\r\nfor (i = 0;\r\ni < QED_INIT_MAX_POLL_COUNT &&\r\n!comp_check(val, le32_to_cpu(cmd->expected_val));\r\ni++) {\r\nudelay(delay);\r\nval = qed_rd(p_hwfn, p_ptt, addr);\r\n}\r\nif (i == QED_INIT_MAX_POLL_COUNT)\r\nDP_ERR(p_hwfn,\r\n"Timeout when polling reg: 0x%08x [ Waiting-for: %08x Got: %08x (comparsion %08x)]\n",\r\naddr, le32_to_cpu(cmd->expected_val),\r\nval, data);\r\n}\r\n}\r\nstatic void qed_init_cmd_cb(struct qed_hwfn *p_hwfn,\r\nstruct qed_ptt *p_ptt,\r\nstruct init_callback_op *p_cmd)\r\n{\r\nDP_NOTICE(p_hwfn, "Currently init values have no need of callbacks\n");\r\n}\r\nstatic u8 qed_init_cmd_mode_match(struct qed_hwfn *p_hwfn,\r\nu16 *offset,\r\nint modes)\r\n{\r\nstruct qed_dev *cdev = p_hwfn->cdev;\r\nconst u8 *modes_tree_buf;\r\nu8 arg1, arg2, tree_val;\r\nmodes_tree_buf = cdev->fw_data->modes_tree_buf;\r\ntree_val = modes_tree_buf[(*offset)++];\r\nswitch (tree_val) {\r\ncase INIT_MODE_OP_NOT:\r\nreturn qed_init_cmd_mode_match(p_hwfn, offset, modes) ^ 1;\r\ncase INIT_MODE_OP_OR:\r\narg1 = qed_init_cmd_mode_match(p_hwfn, offset, modes);\r\narg2 = qed_init_cmd_mode_match(p_hwfn, offset, modes);\r\nreturn arg1 | arg2;\r\ncase INIT_MODE_OP_AND:\r\narg1 = qed_init_cmd_mode_match(p_hwfn, offset, modes);\r\narg2 = qed_init_cmd_mode_match(p_hwfn, offset, modes);\r\nreturn arg1 & arg2;\r\ndefault:\r\ntree_val -= MAX_INIT_MODE_OPS;\r\nreturn (modes & (1 << tree_val)) ? 1 : 0;\r\n}\r\n}\r\nstatic u32 qed_init_cmd_mode(struct qed_hwfn *p_hwfn,\r\nstruct init_if_mode_op *p_cmd,\r\nint modes)\r\n{\r\nu16 offset = le16_to_cpu(p_cmd->modes_buf_offset);\r\nif (qed_init_cmd_mode_match(p_hwfn, &offset, modes))\r\nreturn 0;\r\nelse\r\nreturn GET_FIELD(le32_to_cpu(p_cmd->op_data),\r\nINIT_IF_MODE_OP_CMD_OFFSET);\r\n}\r\nstatic u32 qed_init_cmd_phase(struct qed_hwfn *p_hwfn,\r\nstruct init_if_phase_op *p_cmd,\r\nu32 phase,\r\nu32 phase_id)\r\n{\r\nu32 data = le32_to_cpu(p_cmd->phase_data);\r\nu32 op_data = le32_to_cpu(p_cmd->op_data);\r\nif (!(GET_FIELD(data, INIT_IF_PHASE_OP_PHASE) == phase &&\r\n(GET_FIELD(data, INIT_IF_PHASE_OP_PHASE_ID) == ANY_PHASE_ID ||\r\nGET_FIELD(data, INIT_IF_PHASE_OP_PHASE_ID) == phase_id)))\r\nreturn GET_FIELD(op_data, INIT_IF_PHASE_OP_CMD_OFFSET);\r\nelse\r\nreturn 0;\r\n}\r\nint qed_init_run(struct qed_hwfn *p_hwfn,\r\nstruct qed_ptt *p_ptt,\r\nint phase,\r\nint phase_id,\r\nint modes)\r\n{\r\nstruct qed_dev *cdev = p_hwfn->cdev;\r\nu32 cmd_num, num_init_ops;\r\nunion init_op *init_ops;\r\nbool b_dmae = false;\r\nint rc = 0;\r\nnum_init_ops = cdev->fw_data->init_ops_size;\r\ninit_ops = cdev->fw_data->init_ops;\r\np_hwfn->unzip_buf = kzalloc(MAX_ZIPPED_SIZE * 4, GFP_ATOMIC);\r\nif (!p_hwfn->unzip_buf) {\r\nDP_NOTICE(p_hwfn, "Failed to allocate unzip buffer\n");\r\nreturn -ENOMEM;\r\n}\r\nfor (cmd_num = 0; cmd_num < num_init_ops; cmd_num++) {\r\nunion init_op *cmd = &init_ops[cmd_num];\r\nu32 data = le32_to_cpu(cmd->raw.op_data);\r\nswitch (GET_FIELD(data, INIT_CALLBACK_OP_OP)) {\r\ncase INIT_OP_WRITE:\r\nrc = qed_init_cmd_wr(p_hwfn, p_ptt, &cmd->write,\r\nb_dmae);\r\nbreak;\r\ncase INIT_OP_READ:\r\nqed_init_cmd_rd(p_hwfn, p_ptt, &cmd->read);\r\nbreak;\r\ncase INIT_OP_IF_MODE:\r\ncmd_num += qed_init_cmd_mode(p_hwfn, &cmd->if_mode,\r\nmodes);\r\nbreak;\r\ncase INIT_OP_IF_PHASE:\r\ncmd_num += qed_init_cmd_phase(p_hwfn, &cmd->if_phase,\r\nphase, phase_id);\r\nb_dmae = GET_FIELD(data, INIT_IF_PHASE_OP_DMAE_ENABLE);\r\nbreak;\r\ncase INIT_OP_DELAY:\r\nudelay(le32_to_cpu(cmd->delay.delay));\r\nbreak;\r\ncase INIT_OP_CALLBACK:\r\nqed_init_cmd_cb(p_hwfn, p_ptt, &cmd->callback);\r\nbreak;\r\n}\r\nif (rc)\r\nbreak;\r\n}\r\nkfree(p_hwfn->unzip_buf);\r\nreturn rc;\r\n}\r\nvoid qed_gtt_init(struct qed_hwfn *p_hwfn)\r\n{\r\nu32 gtt_base;\r\nu32 i;\r\ngtt_base = PXP_PF_WINDOW_ADMIN_START + PXP_PF_WINDOW_ADMIN_GLOBAL_START;\r\nfor (i = 0; i < ARRAY_SIZE(pxp_global_win); i++)\r\nif (pxp_global_win[i])\r\nREG_WR(p_hwfn, gtt_base + i * PXP_GLOBAL_ENTRY_SIZE,\r\npxp_global_win[i]);\r\n}\r\nint qed_init_fw_data(struct qed_dev *cdev,\r\nconst u8 *data)\r\n{\r\nstruct qed_fw_data *fw = cdev->fw_data;\r\nstruct bin_buffer_hdr *buf_hdr;\r\nu32 offset, len;\r\nif (!data) {\r\nDP_NOTICE(cdev, "Invalid fw data\n");\r\nreturn -EINVAL;\r\n}\r\nbuf_hdr = (struct bin_buffer_hdr *)data;\r\noffset = buf_hdr[BIN_BUF_INIT_CMD].offset;\r\nfw->init_ops = (union init_op *)(data + offset);\r\noffset = buf_hdr[BIN_BUF_INIT_VAL].offset;\r\nfw->arr_data = (u32 *)(data + offset);\r\noffset = buf_hdr[BIN_BUF_INIT_MODE_TREE].offset;\r\nfw->modes_tree_buf = (u8 *)(data + offset);\r\nlen = buf_hdr[BIN_BUF_INIT_CMD].length;\r\nfw->init_ops_size = len / sizeof(struct init_raw_op);\r\nreturn 0;\r\n}
