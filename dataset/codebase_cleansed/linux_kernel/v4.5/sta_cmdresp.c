static void\r\nmwifiex_process_cmdresp_error(struct mwifiex_private *priv,\r\nstruct host_cmd_ds_command *resp)\r\n{\r\nstruct cmd_ctrl_node *cmd_node = NULL, *tmp_node;\r\nstruct mwifiex_adapter *adapter = priv->adapter;\r\nstruct host_cmd_ds_802_11_ps_mode_enh *pm;\r\nunsigned long flags;\r\nmwifiex_dbg(adapter, ERROR,\r\n"CMD_RESP: cmd %#x error, result=%#x\n",\r\nresp->command, resp->result);\r\nif (adapter->curr_cmd->wait_q_enabled)\r\nadapter->cmd_wait_q.status = -1;\r\nswitch (le16_to_cpu(resp->command)) {\r\ncase HostCmd_CMD_802_11_PS_MODE_ENH:\r\npm = &resp->params.psmode_enh;\r\nmwifiex_dbg(adapter, ERROR,\r\n"PS_MODE_ENH cmd failed: result=0x%x action=0x%X\n",\r\nresp->result, le16_to_cpu(pm->action));\r\nif (le16_to_cpu(pm->action) == EN_AUTO_PS &&\r\n(le16_to_cpu(pm->params.ps_bitmap) & BITMAP_STA_PS) &&\r\npriv->bss_mode == NL80211_IFTYPE_ADHOC)\r\nadapter->ps_mode = MWIFIEX_802_11_POWER_MODE_CAM;\r\nbreak;\r\ncase HostCmd_CMD_802_11_SCAN:\r\ncase HostCmd_CMD_802_11_SCAN_EXT:\r\nspin_lock_irqsave(&adapter->scan_pending_q_lock, flags);\r\nlist_for_each_entry_safe(cmd_node, tmp_node,\r\n&adapter->scan_pending_q, list) {\r\nlist_del(&cmd_node->list);\r\nspin_unlock_irqrestore(&adapter->scan_pending_q_lock,\r\nflags);\r\nmwifiex_insert_cmd_to_free_q(adapter, cmd_node);\r\nspin_lock_irqsave(&adapter->scan_pending_q_lock, flags);\r\n}\r\nspin_unlock_irqrestore(&adapter->scan_pending_q_lock, flags);\r\nspin_lock_irqsave(&adapter->mwifiex_cmd_lock, flags);\r\nadapter->scan_processing = false;\r\nspin_unlock_irqrestore(&adapter->mwifiex_cmd_lock, flags);\r\nbreak;\r\ncase HostCmd_CMD_MAC_CONTROL:\r\nbreak;\r\ncase HostCmd_CMD_SDIO_SP_RX_AGGR_CFG:\r\nmwifiex_dbg(adapter, MSG,\r\n"SDIO RX single-port aggregation Not support\n");\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nmwifiex_recycle_cmd_node(adapter, adapter->curr_cmd);\r\nspin_lock_irqsave(&adapter->mwifiex_cmd_lock, flags);\r\nadapter->curr_cmd = NULL;\r\nspin_unlock_irqrestore(&adapter->mwifiex_cmd_lock, flags);\r\n}\r\nstatic int mwifiex_ret_802_11_rssi_info(struct mwifiex_private *priv,\r\nstruct host_cmd_ds_command *resp)\r\n{\r\nstruct host_cmd_ds_802_11_rssi_info_rsp *rssi_info_rsp =\r\n&resp->params.rssi_info_rsp;\r\nstruct mwifiex_ds_misc_subsc_evt *subsc_evt =\r\n&priv->async_subsc_evt_storage;\r\npriv->data_rssi_last = le16_to_cpu(rssi_info_rsp->data_rssi_last);\r\npriv->data_nf_last = le16_to_cpu(rssi_info_rsp->data_nf_last);\r\npriv->data_rssi_avg = le16_to_cpu(rssi_info_rsp->data_rssi_avg);\r\npriv->data_nf_avg = le16_to_cpu(rssi_info_rsp->data_nf_avg);\r\npriv->bcn_rssi_last = le16_to_cpu(rssi_info_rsp->bcn_rssi_last);\r\npriv->bcn_nf_last = le16_to_cpu(rssi_info_rsp->bcn_nf_last);\r\npriv->bcn_rssi_avg = le16_to_cpu(rssi_info_rsp->bcn_rssi_avg);\r\npriv->bcn_nf_avg = le16_to_cpu(rssi_info_rsp->bcn_nf_avg);\r\nif (priv->subsc_evt_rssi_state == EVENT_HANDLED)\r\nreturn 0;\r\nmemset(subsc_evt, 0x00, sizeof(struct mwifiex_ds_misc_subsc_evt));\r\nsubsc_evt->events = BITMASK_BCN_RSSI_LOW | BITMASK_BCN_RSSI_HIGH;\r\nsubsc_evt->action = HostCmd_ACT_BITWISE_SET;\r\nif (priv->subsc_evt_rssi_state == RSSI_LOW_RECVD) {\r\nsubsc_evt->bcn_l_rssi_cfg.abs_value = abs(priv->bcn_rssi_avg -\r\npriv->cqm_rssi_hyst);\r\nsubsc_evt->bcn_h_rssi_cfg.abs_value = abs(priv->cqm_rssi_thold);\r\n} else if (priv->subsc_evt_rssi_state == RSSI_HIGH_RECVD) {\r\nsubsc_evt->bcn_l_rssi_cfg.abs_value = abs(priv->cqm_rssi_thold);\r\nsubsc_evt->bcn_h_rssi_cfg.abs_value = abs(priv->bcn_rssi_avg +\r\npriv->cqm_rssi_hyst);\r\n}\r\nsubsc_evt->bcn_l_rssi_cfg.evt_freq = 1;\r\nsubsc_evt->bcn_h_rssi_cfg.evt_freq = 1;\r\npriv->subsc_evt_rssi_state = EVENT_HANDLED;\r\nmwifiex_send_cmd(priv, HostCmd_CMD_802_11_SUBSCRIBE_EVENT,\r\n0, 0, subsc_evt, false);\r\nreturn 0;\r\n}\r\nstatic int mwifiex_ret_802_11_snmp_mib(struct mwifiex_private *priv,\r\nstruct host_cmd_ds_command *resp,\r\nu32 *data_buf)\r\n{\r\nstruct host_cmd_ds_802_11_snmp_mib *smib = &resp->params.smib;\r\nu16 oid = le16_to_cpu(smib->oid);\r\nu16 query_type = le16_to_cpu(smib->query_type);\r\nu32 ul_temp;\r\nmwifiex_dbg(priv->adapter, INFO,\r\n"info: SNMP_RESP: oid value = %#x,\t"\r\n"query_type = %#x, buf size = %#x\n",\r\noid, query_type, le16_to_cpu(smib->buf_size));\r\nif (query_type == HostCmd_ACT_GEN_GET) {\r\nul_temp = le16_to_cpu(*((__le16 *) (smib->value)));\r\nif (data_buf)\r\n*data_buf = ul_temp;\r\nswitch (oid) {\r\ncase FRAG_THRESH_I:\r\nmwifiex_dbg(priv->adapter, INFO,\r\n"info: SNMP_RESP: FragThsd =%u\n",\r\nul_temp);\r\nbreak;\r\ncase RTS_THRESH_I:\r\nmwifiex_dbg(priv->adapter, INFO,\r\n"info: SNMP_RESP: RTSThsd =%u\n",\r\nul_temp);\r\nbreak;\r\ncase SHORT_RETRY_LIM_I:\r\nmwifiex_dbg(priv->adapter, INFO,\r\n"info: SNMP_RESP: TxRetryCount=%u\n",\r\nul_temp);\r\nbreak;\r\ncase DTIM_PERIOD_I:\r\nmwifiex_dbg(priv->adapter, INFO,\r\n"info: SNMP_RESP: DTIM period=%u\n",\r\nul_temp);\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int mwifiex_ret_get_log(struct mwifiex_private *priv,\r\nstruct host_cmd_ds_command *resp,\r\nstruct mwifiex_ds_get_stats *stats)\r\n{\r\nstruct host_cmd_ds_802_11_get_log *get_log =\r\n&resp->params.get_log;\r\nif (stats) {\r\nstats->mcast_tx_frame = le32_to_cpu(get_log->mcast_tx_frame);\r\nstats->failed = le32_to_cpu(get_log->failed);\r\nstats->retry = le32_to_cpu(get_log->retry);\r\nstats->multi_retry = le32_to_cpu(get_log->multi_retry);\r\nstats->frame_dup = le32_to_cpu(get_log->frame_dup);\r\nstats->rts_success = le32_to_cpu(get_log->rts_success);\r\nstats->rts_failure = le32_to_cpu(get_log->rts_failure);\r\nstats->ack_failure = le32_to_cpu(get_log->ack_failure);\r\nstats->rx_frag = le32_to_cpu(get_log->rx_frag);\r\nstats->mcast_rx_frame = le32_to_cpu(get_log->mcast_rx_frame);\r\nstats->fcs_error = le32_to_cpu(get_log->fcs_error);\r\nstats->tx_frame = le32_to_cpu(get_log->tx_frame);\r\nstats->wep_icv_error[0] =\r\nle32_to_cpu(get_log->wep_icv_err_cnt[0]);\r\nstats->wep_icv_error[1] =\r\nle32_to_cpu(get_log->wep_icv_err_cnt[1]);\r\nstats->wep_icv_error[2] =\r\nle32_to_cpu(get_log->wep_icv_err_cnt[2]);\r\nstats->wep_icv_error[3] =\r\nle32_to_cpu(get_log->wep_icv_err_cnt[3]);\r\nstats->bcn_rcv_cnt = le32_to_cpu(get_log->bcn_rcv_cnt);\r\nstats->bcn_miss_cnt = le32_to_cpu(get_log->bcn_miss_cnt);\r\n}\r\nreturn 0;\r\n}\r\nstatic int mwifiex_ret_tx_rate_cfg(struct mwifiex_private *priv,\r\nstruct host_cmd_ds_command *resp)\r\n{\r\nstruct host_cmd_ds_tx_rate_cfg *rate_cfg = &resp->params.tx_rate_cfg;\r\nstruct mwifiex_rate_scope *rate_scope;\r\nstruct mwifiex_ie_types_header *head;\r\nu16 tlv, tlv_buf_len, tlv_buf_left;\r\nu8 *tlv_buf;\r\nu32 i;\r\ntlv_buf = ((u8 *)rate_cfg) + sizeof(struct host_cmd_ds_tx_rate_cfg);\r\ntlv_buf_left = le16_to_cpu(resp->size) - S_DS_GEN - sizeof(*rate_cfg);\r\nwhile (tlv_buf_left >= sizeof(*head)) {\r\nhead = (struct mwifiex_ie_types_header *)tlv_buf;\r\ntlv = le16_to_cpu(head->type);\r\ntlv_buf_len = le16_to_cpu(head->len);\r\nif (tlv_buf_left < (sizeof(*head) + tlv_buf_len))\r\nbreak;\r\nswitch (tlv) {\r\ncase TLV_TYPE_RATE_SCOPE:\r\nrate_scope = (struct mwifiex_rate_scope *) tlv_buf;\r\npriv->bitmap_rates[0] =\r\nle16_to_cpu(rate_scope->hr_dsss_rate_bitmap);\r\npriv->bitmap_rates[1] =\r\nle16_to_cpu(rate_scope->ofdm_rate_bitmap);\r\nfor (i = 0;\r\ni <\r\nsizeof(rate_scope->ht_mcs_rate_bitmap) /\r\nsizeof(u16); i++)\r\npriv->bitmap_rates[2 + i] =\r\nle16_to_cpu(rate_scope->\r\nht_mcs_rate_bitmap[i]);\r\nif (priv->adapter->fw_api_ver == MWIFIEX_FW_V15) {\r\nfor (i = 0; i < ARRAY_SIZE(rate_scope->\r\nvht_mcs_rate_bitmap);\r\ni++)\r\npriv->bitmap_rates[10 + i] =\r\nle16_to_cpu(rate_scope->\r\nvht_mcs_rate_bitmap[i]);\r\n}\r\nbreak;\r\n}\r\ntlv_buf += (sizeof(*head) + tlv_buf_len);\r\ntlv_buf_left -= (sizeof(*head) + tlv_buf_len);\r\n}\r\npriv->is_data_rate_auto = mwifiex_is_rate_auto(priv);\r\nif (priv->is_data_rate_auto)\r\npriv->data_rate = 0;\r\nelse\r\nreturn mwifiex_send_cmd(priv, HostCmd_CMD_802_11_TX_RATE_QUERY,\r\nHostCmd_ACT_GEN_GET, 0, NULL, false);\r\nreturn 0;\r\n}\r\nstatic int mwifiex_get_power_level(struct mwifiex_private *priv, void *data_buf)\r\n{\r\nint length, max_power = -1, min_power = -1;\r\nstruct mwifiex_types_power_group *pg_tlv_hdr;\r\nstruct mwifiex_power_group *pg;\r\nif (!data_buf)\r\nreturn -1;\r\npg_tlv_hdr = (struct mwifiex_types_power_group *)((u8 *)data_buf);\r\npg = (struct mwifiex_power_group *)\r\n((u8 *) pg_tlv_hdr + sizeof(struct mwifiex_types_power_group));\r\nlength = le16_to_cpu(pg_tlv_hdr->length);\r\nif (length < sizeof(struct mwifiex_power_group))\r\nreturn 0;\r\nmax_power = pg->power_max;\r\nmin_power = pg->power_min;\r\nlength -= sizeof(struct mwifiex_power_group);\r\nwhile (length >= sizeof(struct mwifiex_power_group)) {\r\npg++;\r\nif (max_power < pg->power_max)\r\nmax_power = pg->power_max;\r\nif (min_power > pg->power_min)\r\nmin_power = pg->power_min;\r\nlength -= sizeof(struct mwifiex_power_group);\r\n}\r\npriv->min_tx_power_level = (u8) min_power;\r\npriv->max_tx_power_level = (u8) max_power;\r\nreturn 0;\r\n}\r\nstatic int mwifiex_ret_tx_power_cfg(struct mwifiex_private *priv,\r\nstruct host_cmd_ds_command *resp)\r\n{\r\nstruct mwifiex_adapter *adapter = priv->adapter;\r\nstruct host_cmd_ds_txpwr_cfg *txp_cfg = &resp->params.txp_cfg;\r\nstruct mwifiex_types_power_group *pg_tlv_hdr;\r\nstruct mwifiex_power_group *pg;\r\nu16 action = le16_to_cpu(txp_cfg->action);\r\nu16 tlv_buf_left;\r\npg_tlv_hdr = (struct mwifiex_types_power_group *)\r\n((u8 *)txp_cfg +\r\nsizeof(struct host_cmd_ds_txpwr_cfg));\r\npg = (struct mwifiex_power_group *)\r\n((u8 *)pg_tlv_hdr +\r\nsizeof(struct mwifiex_types_power_group));\r\ntlv_buf_left = le16_to_cpu(resp->size) - S_DS_GEN - sizeof(*txp_cfg);\r\nif (tlv_buf_left <\r\nle16_to_cpu(pg_tlv_hdr->length) + sizeof(*pg_tlv_hdr))\r\nreturn 0;\r\nswitch (action) {\r\ncase HostCmd_ACT_GEN_GET:\r\nif (adapter->hw_status == MWIFIEX_HW_STATUS_INITIALIZING)\r\nmwifiex_get_power_level(priv, pg_tlv_hdr);\r\npriv->tx_power_level = (u16) pg->power_min;\r\nbreak;\r\ncase HostCmd_ACT_GEN_SET:\r\nif (!le32_to_cpu(txp_cfg->mode))\r\nbreak;\r\nif (pg->power_max == pg->power_min)\r\npriv->tx_power_level = (u16) pg->power_min;\r\nbreak;\r\ndefault:\r\nmwifiex_dbg(adapter, ERROR,\r\n"CMD_RESP: unknown cmd action %d\n",\r\naction);\r\nreturn 0;\r\n}\r\nmwifiex_dbg(adapter, INFO,\r\n"info: Current TxPower Level = %d, Max Power=%d, Min Power=%d\n",\r\npriv->tx_power_level, priv->max_tx_power_level,\r\npriv->min_tx_power_level);\r\nreturn 0;\r\n}\r\nstatic int mwifiex_ret_rf_tx_power(struct mwifiex_private *priv,\r\nstruct host_cmd_ds_command *resp)\r\n{\r\nstruct host_cmd_ds_rf_tx_pwr *txp = &resp->params.txp;\r\nu16 action = le16_to_cpu(txp->action);\r\npriv->tx_power_level = le16_to_cpu(txp->cur_level);\r\nif (action == HostCmd_ACT_GEN_GET) {\r\npriv->max_tx_power_level = txp->max_power;\r\npriv->min_tx_power_level = txp->min_power;\r\n}\r\nmwifiex_dbg(priv->adapter, INFO,\r\n"Current TxPower Level=%d, Max Power=%d, Min Power=%d\n",\r\npriv->tx_power_level, priv->max_tx_power_level,\r\npriv->min_tx_power_level);\r\nreturn 0;\r\n}\r\nstatic int mwifiex_ret_rf_antenna(struct mwifiex_private *priv,\r\nstruct host_cmd_ds_command *resp)\r\n{\r\nstruct host_cmd_ds_rf_ant_mimo *ant_mimo = &resp->params.ant_mimo;\r\nstruct host_cmd_ds_rf_ant_siso *ant_siso = &resp->params.ant_siso;\r\nstruct mwifiex_adapter *adapter = priv->adapter;\r\nif (adapter->hw_dev_mcs_support == HT_STREAM_2X2)\r\nmwifiex_dbg(adapter, INFO,\r\n"RF_ANT_RESP: Tx action = 0x%x, Tx Mode = 0x%04x\t"\r\n"Rx action = 0x%x, Rx Mode = 0x%04x\n",\r\nle16_to_cpu(ant_mimo->action_tx),\r\nle16_to_cpu(ant_mimo->tx_ant_mode),\r\nle16_to_cpu(ant_mimo->action_rx),\r\nle16_to_cpu(ant_mimo->rx_ant_mode));\r\nelse\r\nmwifiex_dbg(adapter, INFO,\r\n"RF_ANT_RESP: action = 0x%x, Mode = 0x%04x\n",\r\nle16_to_cpu(ant_siso->action),\r\nle16_to_cpu(ant_siso->ant_mode));\r\nreturn 0;\r\n}\r\nstatic int mwifiex_ret_802_11_mac_address(struct mwifiex_private *priv,\r\nstruct host_cmd_ds_command *resp)\r\n{\r\nstruct host_cmd_ds_802_11_mac_address *cmd_mac_addr =\r\n&resp->params.mac_addr;\r\nmemcpy(priv->curr_addr, cmd_mac_addr->mac_addr, ETH_ALEN);\r\nmwifiex_dbg(priv->adapter, INFO,\r\n"info: set mac address: %pM\n", priv->curr_addr);\r\nreturn 0;\r\n}\r\nstatic int mwifiex_ret_mac_multicast_adr(struct mwifiex_private *priv,\r\nstruct host_cmd_ds_command *resp)\r\n{\r\nreturn 0;\r\n}\r\nstatic int mwifiex_ret_802_11_tx_rate_query(struct mwifiex_private *priv,\r\nstruct host_cmd_ds_command *resp)\r\n{\r\npriv->tx_rate = resp->params.tx_rate.tx_rate;\r\npriv->tx_htinfo = resp->params.tx_rate.ht_info;\r\nif (!priv->is_data_rate_auto)\r\npriv->data_rate =\r\nmwifiex_index_to_data_rate(priv, priv->tx_rate,\r\npriv->tx_htinfo);\r\nreturn 0;\r\n}\r\nstatic int mwifiex_ret_802_11_deauthenticate(struct mwifiex_private *priv,\r\nstruct host_cmd_ds_command *resp)\r\n{\r\nstruct mwifiex_adapter *adapter = priv->adapter;\r\nadapter->dbg.num_cmd_deauth++;\r\nif (!memcmp(resp->params.deauth.mac_addr,\r\n&priv->curr_bss_params.bss_descriptor.mac_address,\r\nsizeof(resp->params.deauth.mac_addr)))\r\nmwifiex_reset_connect_state(priv, WLAN_REASON_DEAUTH_LEAVING);\r\nreturn 0;\r\n}\r\nstatic int mwifiex_ret_802_11_ad_hoc_stop(struct mwifiex_private *priv,\r\nstruct host_cmd_ds_command *resp)\r\n{\r\nmwifiex_reset_connect_state(priv, WLAN_REASON_DEAUTH_LEAVING);\r\nreturn 0;\r\n}\r\nstatic int mwifiex_ret_802_11_key_material_v1(struct mwifiex_private *priv,\r\nstruct host_cmd_ds_command *resp)\r\n{\r\nstruct host_cmd_ds_802_11_key_material *key =\r\n&resp->params.key_material;\r\nif (le16_to_cpu(key->action) == HostCmd_ACT_GEN_SET) {\r\nif ((le16_to_cpu(key->key_param_set.key_info) & KEY_MCAST)) {\r\nmwifiex_dbg(priv->adapter, INFO,\r\n"info: key: GTK is set\n");\r\npriv->wpa_is_gtk_set = true;\r\npriv->scan_block = false;\r\npriv->port_open = true;\r\n}\r\n}\r\nmemset(priv->aes_key.key_param_set.key, 0,\r\nsizeof(key->key_param_set.key));\r\npriv->aes_key.key_param_set.key_len = key->key_param_set.key_len;\r\nmemcpy(priv->aes_key.key_param_set.key, key->key_param_set.key,\r\nle16_to_cpu(priv->aes_key.key_param_set.key_len));\r\nreturn 0;\r\n}\r\nstatic int mwifiex_ret_802_11_key_material_v2(struct mwifiex_private *priv,\r\nstruct host_cmd_ds_command *resp)\r\n{\r\nstruct host_cmd_ds_802_11_key_material_v2 *key_v2;\r\n__le16 len;\r\nkey_v2 = &resp->params.key_material_v2;\r\nif (le16_to_cpu(key_v2->action) == HostCmd_ACT_GEN_SET) {\r\nif ((le16_to_cpu(key_v2->key_param_set.key_info) & KEY_MCAST)) {\r\nmwifiex_dbg(priv->adapter, INFO, "info: key: GTK is set\n");\r\npriv->wpa_is_gtk_set = true;\r\npriv->scan_block = false;\r\npriv->port_open = true;\r\n}\r\n}\r\nif (key_v2->key_param_set.key_type != KEY_TYPE_ID_AES)\r\nreturn 0;\r\nmemset(priv->aes_key_v2.key_param_set.key_params.aes.key, 0,\r\nWLAN_KEY_LEN_CCMP);\r\npriv->aes_key_v2.key_param_set.key_params.aes.key_len =\r\nkey_v2->key_param_set.key_params.aes.key_len;\r\nlen = priv->aes_key_v2.key_param_set.key_params.aes.key_len;\r\nmemcpy(priv->aes_key_v2.key_param_set.key_params.aes.key,\r\nkey_v2->key_param_set.key_params.aes.key, le16_to_cpu(len));\r\nreturn 0;\r\n}\r\nstatic int mwifiex_ret_802_11_key_material(struct mwifiex_private *priv,\r\nstruct host_cmd_ds_command *resp)\r\n{\r\nif (priv->adapter->key_api_major_ver == KEY_API_VER_MAJOR_V2)\r\nreturn mwifiex_ret_802_11_key_material_v2(priv, resp);\r\nelse\r\nreturn mwifiex_ret_802_11_key_material_v1(priv, resp);\r\n}\r\nstatic int mwifiex_ret_802_11d_domain_info(struct mwifiex_private *priv,\r\nstruct host_cmd_ds_command *resp)\r\n{\r\nstruct host_cmd_ds_802_11d_domain_info_rsp *domain_info =\r\n&resp->params.domain_info_resp;\r\nstruct mwifiex_ietypes_domain_param_set *domain = &domain_info->domain;\r\nu16 action = le16_to_cpu(domain_info->action);\r\nu8 no_of_triplet;\r\nno_of_triplet = (u8) ((le16_to_cpu(domain->header.len)\r\n- IEEE80211_COUNTRY_STRING_LEN)\r\n/ sizeof(struct ieee80211_country_ie_triplet));\r\nmwifiex_dbg(priv->adapter, INFO,\r\n"info: 11D Domain Info Resp: no_of_triplet=%d\n",\r\nno_of_triplet);\r\nif (no_of_triplet > MWIFIEX_MAX_TRIPLET_802_11D) {\r\nmwifiex_dbg(priv->adapter, FATAL,\r\n"11D: invalid number of triplets %d returned\n",\r\nno_of_triplet);\r\nreturn -1;\r\n}\r\nswitch (action) {\r\ncase HostCmd_ACT_GEN_SET:\r\nbreak;\r\ncase HostCmd_ACT_GEN_GET:\r\nbreak;\r\ndefault:\r\nmwifiex_dbg(priv->adapter, ERROR,\r\n"11D: invalid action:%d\n", domain_info->action);\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int mwifiex_ret_ver_ext(struct mwifiex_private *priv,\r\nstruct host_cmd_ds_command *resp,\r\nstruct host_cmd_ds_version_ext *version_ext)\r\n{\r\nstruct host_cmd_ds_version_ext *ver_ext = &resp->params.verext;\r\nif (version_ext) {\r\nversion_ext->version_str_sel = ver_ext->version_str_sel;\r\nmemcpy(version_ext->version_str, ver_ext->version_str,\r\nsizeof(char) * 128);\r\nmemcpy(priv->version_str, ver_ext->version_str, 128);\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nmwifiex_ret_remain_on_chan(struct mwifiex_private *priv,\r\nstruct host_cmd_ds_command *resp,\r\nstruct host_cmd_ds_remain_on_chan *roc_cfg)\r\n{\r\nstruct host_cmd_ds_remain_on_chan *resp_cfg = &resp->params.roc_cfg;\r\nif (roc_cfg)\r\nmemcpy(roc_cfg, resp_cfg, sizeof(*roc_cfg));\r\nreturn 0;\r\n}\r\nstatic int\r\nmwifiex_ret_p2p_mode_cfg(struct mwifiex_private *priv,\r\nstruct host_cmd_ds_command *resp,\r\nvoid *data_buf)\r\n{\r\nstruct host_cmd_ds_p2p_mode_cfg *mode_cfg = &resp->params.mode_cfg;\r\nif (data_buf)\r\n*((u16 *)data_buf) = le16_to_cpu(mode_cfg->mode);\r\nreturn 0;\r\n}\r\nstatic int\r\nmwifiex_ret_mem_access(struct mwifiex_private *priv,\r\nstruct host_cmd_ds_command *resp, void *pioctl_buf)\r\n{\r\nstruct host_cmd_ds_mem_access *mem = (void *)&resp->params.mem;\r\npriv->mem_rw.addr = le32_to_cpu(mem->addr);\r\npriv->mem_rw.value = le32_to_cpu(mem->value);\r\nreturn 0;\r\n}\r\nstatic int mwifiex_ret_reg_access(u16 type, struct host_cmd_ds_command *resp,\r\nvoid *data_buf)\r\n{\r\nstruct mwifiex_ds_reg_rw *reg_rw;\r\nstruct mwifiex_ds_read_eeprom *eeprom;\r\nunion reg {\r\nstruct host_cmd_ds_mac_reg_access *mac;\r\nstruct host_cmd_ds_bbp_reg_access *bbp;\r\nstruct host_cmd_ds_rf_reg_access *rf;\r\nstruct host_cmd_ds_pmic_reg_access *pmic;\r\nstruct host_cmd_ds_802_11_eeprom_access *eeprom;\r\n} r;\r\nif (!data_buf)\r\nreturn 0;\r\nreg_rw = data_buf;\r\neeprom = data_buf;\r\nswitch (type) {\r\ncase HostCmd_CMD_MAC_REG_ACCESS:\r\nr.mac = &resp->params.mac_reg;\r\nreg_rw->offset = cpu_to_le32((u32) le16_to_cpu(r.mac->offset));\r\nreg_rw->value = r.mac->value;\r\nbreak;\r\ncase HostCmd_CMD_BBP_REG_ACCESS:\r\nr.bbp = &resp->params.bbp_reg;\r\nreg_rw->offset = cpu_to_le32((u32) le16_to_cpu(r.bbp->offset));\r\nreg_rw->value = cpu_to_le32((u32) r.bbp->value);\r\nbreak;\r\ncase HostCmd_CMD_RF_REG_ACCESS:\r\nr.rf = &resp->params.rf_reg;\r\nreg_rw->offset = cpu_to_le32((u32) le16_to_cpu(r.rf->offset));\r\nreg_rw->value = cpu_to_le32((u32) r.bbp->value);\r\nbreak;\r\ncase HostCmd_CMD_PMIC_REG_ACCESS:\r\nr.pmic = &resp->params.pmic_reg;\r\nreg_rw->offset = cpu_to_le32((u32) le16_to_cpu(r.pmic->offset));\r\nreg_rw->value = cpu_to_le32((u32) r.pmic->value);\r\nbreak;\r\ncase HostCmd_CMD_CAU_REG_ACCESS:\r\nr.rf = &resp->params.rf_reg;\r\nreg_rw->offset = cpu_to_le32((u32) le16_to_cpu(r.rf->offset));\r\nreg_rw->value = cpu_to_le32((u32) r.rf->value);\r\nbreak;\r\ncase HostCmd_CMD_802_11_EEPROM_ACCESS:\r\nr.eeprom = &resp->params.eeprom;\r\npr_debug("info: EEPROM read len=%x\n", r.eeprom->byte_count);\r\nif (le16_to_cpu(eeprom->byte_count) <\r\nle16_to_cpu(r.eeprom->byte_count)) {\r\neeprom->byte_count = cpu_to_le16(0);\r\npr_debug("info: EEPROM read length is too big\n");\r\nreturn -1;\r\n}\r\neeprom->offset = r.eeprom->offset;\r\neeprom->byte_count = r.eeprom->byte_count;\r\nif (le16_to_cpu(eeprom->byte_count) > 0)\r\nmemcpy(&eeprom->value, &r.eeprom->value,\r\nle16_to_cpu(r.eeprom->byte_count));\r\nbreak;\r\ndefault:\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int mwifiex_ret_ibss_coalescing_status(struct mwifiex_private *priv,\r\nstruct host_cmd_ds_command *resp)\r\n{\r\nstruct host_cmd_ds_802_11_ibss_status *ibss_coal_resp =\r\n&(resp->params.ibss_coalescing);\r\nif (le16_to_cpu(ibss_coal_resp->action) == HostCmd_ACT_GEN_SET)\r\nreturn 0;\r\nmwifiex_dbg(priv->adapter, INFO,\r\n"info: new BSSID %pM\n", ibss_coal_resp->bssid);\r\nif (is_zero_ether_addr(ibss_coal_resp->bssid)) {\r\nmwifiex_dbg(priv->adapter, FATAL, "new BSSID is NULL\n");\r\nreturn 0;\r\n}\r\nif (!ether_addr_equal(priv->curr_bss_params.bss_descriptor.mac_address, ibss_coal_resp->bssid)) {\r\nmemcpy(priv->curr_bss_params.bss_descriptor.mac_address,\r\nibss_coal_resp->bssid, ETH_ALEN);\r\npriv->curr_bss_params.bss_descriptor.beacon_period\r\n= le16_to_cpu(ibss_coal_resp->beacon_interval);\r\npriv->curr_bss_params.bss_descriptor.erp_flags =\r\n(u8) le16_to_cpu(ibss_coal_resp->use_g_rate_protect);\r\npriv->adhoc_state = ADHOC_COALESCED;\r\n}\r\nreturn 0;\r\n}\r\nstatic int mwifiex_ret_tdls_oper(struct mwifiex_private *priv,\r\nstruct host_cmd_ds_command *resp)\r\n{\r\nstruct host_cmd_ds_tdls_oper *cmd_tdls_oper = &resp->params.tdls_oper;\r\nu16 reason = le16_to_cpu(cmd_tdls_oper->reason);\r\nu16 action = le16_to_cpu(cmd_tdls_oper->tdls_action);\r\nstruct mwifiex_sta_node *node =\r\nmwifiex_get_sta_entry(priv, cmd_tdls_oper->peer_mac);\r\nswitch (action) {\r\ncase ACT_TDLS_DELETE:\r\nif (reason) {\r\nif (!node || reason == TDLS_ERR_LINK_NONEXISTENT)\r\nmwifiex_dbg(priv->adapter, MSG,\r\n"TDLS link delete for %pM failed: reason %d\n",\r\ncmd_tdls_oper->peer_mac, reason);\r\nelse\r\nmwifiex_dbg(priv->adapter, ERROR,\r\n"TDLS link delete for %pM failed: reason %d\n",\r\ncmd_tdls_oper->peer_mac, reason);\r\n} else {\r\nmwifiex_dbg(priv->adapter, MSG,\r\n"TDLS link delete for %pM successful\n",\r\ncmd_tdls_oper->peer_mac);\r\n}\r\nbreak;\r\ncase ACT_TDLS_CREATE:\r\nif (reason) {\r\nmwifiex_dbg(priv->adapter, ERROR,\r\n"TDLS link creation for %pM failed: reason %d",\r\ncmd_tdls_oper->peer_mac, reason);\r\nif (node && reason != TDLS_ERR_LINK_EXISTS)\r\nnode->tdls_status = TDLS_SETUP_FAILURE;\r\n} else {\r\nmwifiex_dbg(priv->adapter, MSG,\r\n"TDLS link creation for %pM successful",\r\ncmd_tdls_oper->peer_mac);\r\n}\r\nbreak;\r\ncase ACT_TDLS_CONFIG:\r\nif (reason) {\r\nmwifiex_dbg(priv->adapter, ERROR,\r\n"TDLS link config for %pM failed, reason %d\n",\r\ncmd_tdls_oper->peer_mac, reason);\r\nif (node)\r\nnode->tdls_status = TDLS_SETUP_FAILURE;\r\n} else {\r\nmwifiex_dbg(priv->adapter, MSG,\r\n"TDLS link config for %pM successful\n",\r\ncmd_tdls_oper->peer_mac);\r\n}\r\nbreak;\r\ndefault:\r\nmwifiex_dbg(priv->adapter, ERROR,\r\n"Unknown TDLS command action response %d", action);\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int mwifiex_ret_subsc_evt(struct mwifiex_private *priv,\r\nstruct host_cmd_ds_command *resp)\r\n{\r\nstruct host_cmd_ds_802_11_subsc_evt *cmd_sub_event =\r\n&resp->params.subsc_evt;\r\nmwifiex_dbg(priv->adapter, EVENT,\r\n"Bitmap of currently subscribed events: %16x\n",\r\nle16_to_cpu(cmd_sub_event->events));\r\nreturn 0;\r\n}\r\nstatic int mwifiex_ret_uap_sta_list(struct mwifiex_private *priv,\r\nstruct host_cmd_ds_command *resp)\r\n{\r\nstruct host_cmd_ds_sta_list *sta_list =\r\n&resp->params.sta_list;\r\nstruct mwifiex_ie_types_sta_info *sta_info = (void *)&sta_list->tlv;\r\nint i;\r\nstruct mwifiex_sta_node *sta_node;\r\nfor (i = 0; i < sta_list->sta_count; i++) {\r\nsta_node = mwifiex_get_sta_entry(priv, sta_info->mac);\r\nif (unlikely(!sta_node))\r\ncontinue;\r\nsta_node->stats.rssi = sta_info->rssi;\r\nsta_info++;\r\n}\r\nreturn 0;\r\n}\r\nstatic int mwifiex_ret_cfg_data(struct mwifiex_private *priv,\r\nstruct host_cmd_ds_command *resp)\r\n{\r\nif (resp->result != HostCmd_RESULT_OK) {\r\nmwifiex_dbg(priv->adapter, ERROR, "Cal data cmd resp failed\n");\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int mwifiex_ret_sdio_rx_aggr_cfg(struct mwifiex_private *priv,\r\nstruct host_cmd_ds_command *resp)\r\n{\r\nstruct mwifiex_adapter *adapter = priv->adapter;\r\nstruct host_cmd_sdio_sp_rx_aggr_cfg *cfg =\r\n&resp->params.sdio_rx_aggr_cfg;\r\nadapter->sdio_rx_aggr_enable = cfg->enable;\r\nadapter->sdio_rx_block_size = le16_to_cpu(cfg->block_size);\r\nreturn 0;\r\n}\r\nstatic int mwifiex_ret_robust_coex(struct mwifiex_private *priv,\r\nstruct host_cmd_ds_command *resp,\r\nbool *is_timeshare)\r\n{\r\nstruct host_cmd_ds_robust_coex *coex = &resp->params.coex;\r\nstruct mwifiex_ie_types_robust_coex *coex_tlv;\r\nu16 action = le16_to_cpu(coex->action);\r\nu32 mode;\r\ncoex_tlv = (struct mwifiex_ie_types_robust_coex\r\n*)((u8 *)coex + sizeof(struct host_cmd_ds_robust_coex));\r\nif (action == HostCmd_ACT_GEN_GET) {\r\nmode = le32_to_cpu(coex_tlv->mode);\r\nif (mode == MWIFIEX_COEX_MODE_TIMESHARE)\r\n*is_timeshare = true;\r\nelse\r\n*is_timeshare = false;\r\n}\r\nreturn 0;\r\n}\r\nint mwifiex_process_sta_cmdresp(struct mwifiex_private *priv, u16 cmdresp_no,\r\nstruct host_cmd_ds_command *resp)\r\n{\r\nint ret = 0;\r\nstruct mwifiex_adapter *adapter = priv->adapter;\r\nvoid *data_buf = adapter->curr_cmd->data_buf;\r\nif (resp->result != HostCmd_RESULT_OK) {\r\nmwifiex_process_cmdresp_error(priv, resp);\r\nreturn -1;\r\n}\r\nswitch (cmdresp_no) {\r\ncase HostCmd_CMD_GET_HW_SPEC:\r\nret = mwifiex_ret_get_hw_spec(priv, resp);\r\nbreak;\r\ncase HostCmd_CMD_CFG_DATA:\r\nret = mwifiex_ret_cfg_data(priv, resp);\r\nbreak;\r\ncase HostCmd_CMD_MAC_CONTROL:\r\nbreak;\r\ncase HostCmd_CMD_802_11_MAC_ADDRESS:\r\nret = mwifiex_ret_802_11_mac_address(priv, resp);\r\nbreak;\r\ncase HostCmd_CMD_MAC_MULTICAST_ADR:\r\nret = mwifiex_ret_mac_multicast_adr(priv, resp);\r\nbreak;\r\ncase HostCmd_CMD_TX_RATE_CFG:\r\nret = mwifiex_ret_tx_rate_cfg(priv, resp);\r\nbreak;\r\ncase HostCmd_CMD_802_11_SCAN:\r\nret = mwifiex_ret_802_11_scan(priv, resp);\r\nadapter->curr_cmd->wait_q_enabled = false;\r\nbreak;\r\ncase HostCmd_CMD_802_11_SCAN_EXT:\r\nret = mwifiex_ret_802_11_scan_ext(priv, resp);\r\nadapter->curr_cmd->wait_q_enabled = false;\r\nbreak;\r\ncase HostCmd_CMD_802_11_BG_SCAN_QUERY:\r\nret = mwifiex_ret_802_11_scan(priv, resp);\r\nmwifiex_dbg(adapter, CMD,\r\n"info: CMD_RESP: BG_SCAN result is ready!\n");\r\nbreak;\r\ncase HostCmd_CMD_TXPWR_CFG:\r\nret = mwifiex_ret_tx_power_cfg(priv, resp);\r\nbreak;\r\ncase HostCmd_CMD_RF_TX_PWR:\r\nret = mwifiex_ret_rf_tx_power(priv, resp);\r\nbreak;\r\ncase HostCmd_CMD_RF_ANTENNA:\r\nret = mwifiex_ret_rf_antenna(priv, resp);\r\nbreak;\r\ncase HostCmd_CMD_802_11_PS_MODE_ENH:\r\nret = mwifiex_ret_enh_power_mode(priv, resp, data_buf);\r\nbreak;\r\ncase HostCmd_CMD_802_11_HS_CFG_ENH:\r\nret = mwifiex_ret_802_11_hs_cfg(priv, resp);\r\nbreak;\r\ncase HostCmd_CMD_802_11_ASSOCIATE:\r\nret = mwifiex_ret_802_11_associate(priv, resp);\r\nbreak;\r\ncase HostCmd_CMD_802_11_DEAUTHENTICATE:\r\nret = mwifiex_ret_802_11_deauthenticate(priv, resp);\r\nbreak;\r\ncase HostCmd_CMD_802_11_AD_HOC_START:\r\ncase HostCmd_CMD_802_11_AD_HOC_JOIN:\r\nret = mwifiex_ret_802_11_ad_hoc(priv, resp);\r\nbreak;\r\ncase HostCmd_CMD_802_11_AD_HOC_STOP:\r\nret = mwifiex_ret_802_11_ad_hoc_stop(priv, resp);\r\nbreak;\r\ncase HostCmd_CMD_802_11_GET_LOG:\r\nret = mwifiex_ret_get_log(priv, resp, data_buf);\r\nbreak;\r\ncase HostCmd_CMD_RSSI_INFO:\r\nret = mwifiex_ret_802_11_rssi_info(priv, resp);\r\nbreak;\r\ncase HostCmd_CMD_802_11_SNMP_MIB:\r\nret = mwifiex_ret_802_11_snmp_mib(priv, resp, data_buf);\r\nbreak;\r\ncase HostCmd_CMD_802_11_TX_RATE_QUERY:\r\nret = mwifiex_ret_802_11_tx_rate_query(priv, resp);\r\nbreak;\r\ncase HostCmd_CMD_VERSION_EXT:\r\nret = mwifiex_ret_ver_ext(priv, resp, data_buf);\r\nbreak;\r\ncase HostCmd_CMD_REMAIN_ON_CHAN:\r\nret = mwifiex_ret_remain_on_chan(priv, resp, data_buf);\r\nbreak;\r\ncase HostCmd_CMD_11AC_CFG:\r\nbreak;\r\ncase HostCmd_CMD_P2P_MODE_CFG:\r\nret = mwifiex_ret_p2p_mode_cfg(priv, resp, data_buf);\r\nbreak;\r\ncase HostCmd_CMD_MGMT_FRAME_REG:\r\ncase HostCmd_CMD_FUNC_INIT:\r\ncase HostCmd_CMD_FUNC_SHUTDOWN:\r\nbreak;\r\ncase HostCmd_CMD_802_11_KEY_MATERIAL:\r\nret = mwifiex_ret_802_11_key_material(priv, resp);\r\nbreak;\r\ncase HostCmd_CMD_802_11D_DOMAIN_INFO:\r\nret = mwifiex_ret_802_11d_domain_info(priv, resp);\r\nbreak;\r\ncase HostCmd_CMD_11N_ADDBA_REQ:\r\nret = mwifiex_ret_11n_addba_req(priv, resp);\r\nbreak;\r\ncase HostCmd_CMD_11N_DELBA:\r\nret = mwifiex_ret_11n_delba(priv, resp);\r\nbreak;\r\ncase HostCmd_CMD_11N_ADDBA_RSP:\r\nret = mwifiex_ret_11n_addba_resp(priv, resp);\r\nbreak;\r\ncase HostCmd_CMD_RECONFIGURE_TX_BUFF:\r\nif (0xffff == (u16)le16_to_cpu(resp->params.tx_buf.buff_size)) {\r\nif (adapter->iface_type == MWIFIEX_USB &&\r\nadapter->usb_mc_setup) {\r\nif (adapter->if_ops.multi_port_resync)\r\nadapter->if_ops.\r\nmulti_port_resync(adapter);\r\nadapter->usb_mc_setup = false;\r\nadapter->tx_lock_flag = false;\r\n}\r\nbreak;\r\n}\r\nadapter->tx_buf_size = (u16) le16_to_cpu(resp->params.\r\ntx_buf.buff_size);\r\nadapter->tx_buf_size = (adapter->tx_buf_size\r\n/ MWIFIEX_SDIO_BLOCK_SIZE)\r\n* MWIFIEX_SDIO_BLOCK_SIZE;\r\nadapter->curr_tx_buf_size = adapter->tx_buf_size;\r\nmwifiex_dbg(adapter, CMD, "cmd: curr_tx_buf_size=%d\n",\r\nadapter->curr_tx_buf_size);\r\nif (adapter->if_ops.update_mp_end_port)\r\nadapter->if_ops.update_mp_end_port(adapter,\r\nle16_to_cpu(resp->params.tx_buf.mp_end_port));\r\nbreak;\r\ncase HostCmd_CMD_AMSDU_AGGR_CTRL:\r\nbreak;\r\ncase HostCmd_CMD_WMM_GET_STATUS:\r\nret = mwifiex_ret_wmm_get_status(priv, resp);\r\nbreak;\r\ncase HostCmd_CMD_802_11_IBSS_COALESCING_STATUS:\r\nret = mwifiex_ret_ibss_coalescing_status(priv, resp);\r\nbreak;\r\ncase HostCmd_CMD_MEM_ACCESS:\r\nret = mwifiex_ret_mem_access(priv, resp, data_buf);\r\nbreak;\r\ncase HostCmd_CMD_MAC_REG_ACCESS:\r\ncase HostCmd_CMD_BBP_REG_ACCESS:\r\ncase HostCmd_CMD_RF_REG_ACCESS:\r\ncase HostCmd_CMD_PMIC_REG_ACCESS:\r\ncase HostCmd_CMD_CAU_REG_ACCESS:\r\ncase HostCmd_CMD_802_11_EEPROM_ACCESS:\r\nret = mwifiex_ret_reg_access(cmdresp_no, resp, data_buf);\r\nbreak;\r\ncase HostCmd_CMD_SET_BSS_MODE:\r\nbreak;\r\ncase HostCmd_CMD_11N_CFG:\r\nbreak;\r\ncase HostCmd_CMD_PCIE_DESC_DETAILS:\r\nbreak;\r\ncase HostCmd_CMD_802_11_SUBSCRIBE_EVENT:\r\nret = mwifiex_ret_subsc_evt(priv, resp);\r\nbreak;\r\ncase HostCmd_CMD_UAP_SYS_CONFIG:\r\nbreak;\r\ncase HOST_CMD_APCMD_STA_LIST:\r\nret = mwifiex_ret_uap_sta_list(priv, resp);\r\nbreak;\r\ncase HostCmd_CMD_UAP_BSS_START:\r\nadapter->tx_lock_flag = false;\r\nadapter->pps_uapsd_mode = false;\r\nadapter->delay_null_pkt = false;\r\npriv->bss_started = 1;\r\nbreak;\r\ncase HostCmd_CMD_UAP_BSS_STOP:\r\npriv->bss_started = 0;\r\nbreak;\r\ncase HostCmd_CMD_UAP_STA_DEAUTH:\r\nbreak;\r\ncase HOST_CMD_APCMD_SYS_RESET:\r\nbreak;\r\ncase HostCmd_CMD_MEF_CFG:\r\nbreak;\r\ncase HostCmd_CMD_COALESCE_CFG:\r\nbreak;\r\ncase HostCmd_CMD_TDLS_OPER:\r\nret = mwifiex_ret_tdls_oper(priv, resp);\r\ncase HostCmd_CMD_MC_POLICY:\r\nbreak;\r\ncase HostCmd_CMD_CHAN_REPORT_REQUEST:\r\nbreak;\r\ncase HostCmd_CMD_SDIO_SP_RX_AGGR_CFG:\r\nret = mwifiex_ret_sdio_rx_aggr_cfg(priv, resp);\r\nbreak;\r\ncase HostCmd_CMD_TDLS_CONFIG:\r\nbreak;\r\ncase HostCmd_CMD_ROBUST_COEX:\r\nret = mwifiex_ret_robust_coex(priv, resp, data_buf);\r\nbreak;\r\ndefault:\r\nmwifiex_dbg(adapter, ERROR,\r\n"CMD_RESP: unknown cmd response %#x\n",\r\nresp->command);\r\nbreak;\r\n}\r\nreturn ret;\r\n}
