static inline void slic_reg32_write(void __iomem *reg, u32 value, bool flush)\r\n{\r\nwritel(value, reg);\r\nif (flush)\r\nmb();\r\n}\r\nstatic inline void slic_reg64_write(struct adapter *adapter, void __iomem *reg,\r\nu32 value, void __iomem *regh, u32 paddrh,\r\nbool flush)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&adapter->bit64reglock, flags);\r\nwritel(paddrh, regh);\r\nwritel(value, reg);\r\nif (flush)\r\nmb();\r\nspin_unlock_irqrestore(&adapter->bit64reglock, flags);\r\n}\r\nstatic void slic_mcast_set_bit(struct adapter *adapter, char *address)\r\n{\r\nunsigned char crcpoly;\r\ncrcpoly = ether_crc(ETH_ALEN, address) >> 23;\r\ncrcpoly &= 0x3F;\r\nadapter->mcastmask |= (u64)1 << crcpoly;\r\n}\r\nstatic void slic_mcast_set_mask(struct adapter *adapter)\r\n{\r\n__iomem struct slic_regs *slic_regs = adapter->slic_regs;\r\nif (adapter->macopts & (MAC_ALLMCAST | MAC_PROMISC)) {\r\nslic_reg32_write(&slic_regs->slic_mcastlow, 0xFFFFFFFF, FLUSH);\r\nslic_reg32_write(&slic_regs->slic_mcasthigh, 0xFFFFFFFF,\r\nFLUSH);\r\n} else {\r\nslic_reg32_write(&slic_regs->slic_mcastlow,\r\n(u32)(adapter->mcastmask & 0xFFFFFFFF), FLUSH);\r\nslic_reg32_write(&slic_regs->slic_mcasthigh,\r\n(u32)((adapter->mcastmask >> 32) & 0xFFFFFFFF), FLUSH);\r\n}\r\n}\r\nstatic void slic_timer_ping(ulong dev)\r\n{\r\nstruct adapter *adapter;\r\nstruct sliccard *card;\r\nadapter = netdev_priv((struct net_device *)dev);\r\ncard = adapter->card;\r\nadapter->pingtimer.expires = jiffies + (PING_TIMER_INTERVAL * HZ);\r\nadd_timer(&adapter->pingtimer);\r\n}\r\nstatic void slic_unmap_mmio_space(struct adapter *adapter)\r\n{\r\nif (adapter->slic_regs)\r\niounmap(adapter->slic_regs);\r\nadapter->slic_regs = NULL;\r\n}\r\nstatic void slic_link_config(struct adapter *adapter,\r\nu32 linkspeed, u32 linkduplex)\r\n{\r\nu32 __iomem *wphy;\r\nu32 speed;\r\nu32 duplex;\r\nu32 phy_config;\r\nu32 phy_advreg;\r\nu32 phy_gctlreg;\r\nif (adapter->state != ADAPT_UP)\r\nreturn;\r\nif (linkspeed > LINK_1000MB)\r\nlinkspeed = LINK_AUTOSPEED;\r\nif (linkduplex > LINK_AUTOD)\r\nlinkduplex = LINK_AUTOD;\r\nwphy = &adapter->slic_regs->slic_wphy;\r\nif ((linkspeed == LINK_AUTOSPEED) || (linkspeed == LINK_1000MB)) {\r\nif (adapter->flags & ADAPT_FLAGS_FIBERMEDIA) {\r\nphy_advreg = (MIICR_REG_4 | (PAR_ADV1000XFD));\r\nphy_advreg |= PAR_ASYMPAUSE_FIBER;\r\nslic_reg32_write(wphy, phy_advreg, FLUSH);\r\nif (linkspeed == LINK_AUTOSPEED) {\r\nphy_config =\r\n(MIICR_REG_PCR |\r\n(PCR_RESET | PCR_AUTONEG |\r\nPCR_AUTONEG_RST));\r\nslic_reg32_write(wphy, phy_config, FLUSH);\r\n} else {\r\nphy_config = (MIICR_REG_PCR | PCR_POWERDOWN);\r\nslic_reg32_write(wphy, phy_config, FLUSH);\r\nmdelay(10);\r\nphy_config =\r\n(MIICR_REG_PCR |\r\n(PCR_RESET | PCR_SPEED_1000 |\r\nPCR_DUPLEX_FULL));\r\nslic_reg32_write(wphy, phy_config, FLUSH);\r\n}\r\n} else {\r\nif (linkspeed == LINK_AUTOSPEED) {\r\nphy_advreg =\r\n(MIICR_REG_4 |\r\n(PAR_ADV100FD | PAR_ADV100HD | PAR_ADV10FD\r\n| PAR_ADV10HD));\r\n} else {\r\nphy_advreg = MIICR_REG_4;\r\n}\r\nphy_advreg |= PAR_ASYMPAUSE;\r\nphy_advreg |= PAR_802_3;\r\nslic_reg32_write(wphy, phy_advreg, FLUSH);\r\nphy_gctlreg = (MIICR_REG_9 | (PGC_ADV1000FD));\r\nslic_reg32_write(wphy, phy_gctlreg, FLUSH);\r\nif (adapter->subsysid != SLIC_1GB_CICADA_SUBSYS_ID) {\r\nphy_config =\r\n(MIICR_REG_16 | (MRV_REG16_XOVERON));\r\nslic_reg32_write(wphy, phy_config, FLUSH);\r\nphy_config =\r\n(MIICR_REG_PCR |\r\n(PCR_RESET | PCR_AUTONEG |\r\nPCR_AUTONEG_RST));\r\nslic_reg32_write(wphy, phy_config, FLUSH);\r\n} else {\r\nphy_config =\r\n(MIICR_REG_PCR |\r\n(PCR_AUTONEG | PCR_AUTONEG_RST));\r\nslic_reg32_write(wphy, phy_config, FLUSH);\r\n}\r\n}\r\n} else {\r\nif (linkspeed == LINK_10MB)\r\nspeed = 0;\r\nelse\r\nspeed = PCR_SPEED_100;\r\nif (linkduplex == LINK_HALFD)\r\nduplex = 0;\r\nelse\r\nduplex = PCR_DUPLEX_FULL;\r\nif (adapter->subsysid != SLIC_1GB_CICADA_SUBSYS_ID) {\r\nphy_config = (MIICR_REG_16 | (MRV_REG16_XOVEROFF));\r\nslic_reg32_write(wphy, phy_config, FLUSH);\r\n}\r\nphy_config = (MIICR_REG_PCR | (PCR_POWERDOWN | speed | duplex));\r\nslic_reg32_write(wphy, phy_config, FLUSH);\r\nmdelay(10);\r\nif (adapter->subsysid != SLIC_1GB_CICADA_SUBSYS_ID) {\r\nphy_config =\r\n(MIICR_REG_PCR | (PCR_RESET | speed | duplex));\r\nslic_reg32_write(wphy, phy_config, FLUSH);\r\n} else {\r\nphy_config = (MIICR_REG_PCR | (speed | duplex));\r\nslic_reg32_write(wphy, phy_config, FLUSH);\r\n}\r\n}\r\n}\r\nstatic int slic_card_download_gbrcv(struct adapter *adapter)\r\n{\r\nconst struct firmware *fw;\r\nconst char *file = "";\r\nint ret;\r\n__iomem struct slic_regs *slic_regs = adapter->slic_regs;\r\nu32 codeaddr;\r\nu32 instruction;\r\nint index = 0;\r\nu32 rcvucodelen = 0;\r\nswitch (adapter->devid) {\r\ncase SLIC_2GB_DEVICE_ID:\r\nfile = "slicoss/oasisrcvucode.sys";\r\nbreak;\r\ncase SLIC_1GB_DEVICE_ID:\r\nfile = "slicoss/gbrcvucode.sys";\r\nbreak;\r\ndefault:\r\nreturn -ENOENT;\r\n}\r\nret = request_firmware(&fw, file, &adapter->pcidev->dev);\r\nif (ret) {\r\ndev_err(&adapter->pcidev->dev,\r\n"Failed to load firmware %s\n", file);\r\nreturn ret;\r\n}\r\nrcvucodelen = *(u32 *)(fw->data + index);\r\nindex += 4;\r\nswitch (adapter->devid) {\r\ncase SLIC_2GB_DEVICE_ID:\r\nif (rcvucodelen != OasisRcvUCodeLen) {\r\nrelease_firmware(fw);\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ncase SLIC_1GB_DEVICE_ID:\r\nif (rcvucodelen != GBRcvUCodeLen) {\r\nrelease_firmware(fw);\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\n}\r\nslic_reg32_write(&slic_regs->slic_rcv_wcs, SLIC_RCVWCS_BEGIN, FLUSH);\r\nfor (codeaddr = 0; codeaddr < rcvucodelen; codeaddr++) {\r\nslic_reg32_write(&slic_regs->slic_rcv_wcs, codeaddr, FLUSH);\r\ninstruction = *(u32 *)(fw->data + index);\r\nindex += 4;\r\nslic_reg32_write(&slic_regs->slic_rcv_wcs, instruction, FLUSH);\r\ninstruction = *(u8 *)(fw->data + index);\r\nindex++;\r\nslic_reg32_write(&slic_regs->slic_rcv_wcs, (u8)instruction,\r\nFLUSH);\r\n}\r\nrelease_firmware(fw);\r\nslic_reg32_write(&slic_regs->slic_rcv_wcs, SLIC_RCVWCS_FINISH, FLUSH);\r\nreturn 0;\r\n}\r\nstatic int slic_card_download(struct adapter *adapter)\r\n{\r\nconst struct firmware *fw;\r\nconst char *file = "";\r\nint ret;\r\nu32 section;\r\nint thissectionsize;\r\nint codeaddr;\r\n__iomem struct slic_regs *slic_regs = adapter->slic_regs;\r\nu32 instruction;\r\nu32 baseaddress;\r\nu32 i;\r\nu32 numsects = 0;\r\nu32 sectsize[3];\r\nu32 sectstart[3];\r\nint ucode_start, index = 0;\r\nswitch (adapter->devid) {\r\ncase SLIC_2GB_DEVICE_ID:\r\nfile = "slicoss/oasisdownload.sys";\r\nbreak;\r\ncase SLIC_1GB_DEVICE_ID:\r\nfile = "slicoss/gbdownload.sys";\r\nbreak;\r\ndefault:\r\nreturn -ENOENT;\r\n}\r\nret = request_firmware(&fw, file, &adapter->pcidev->dev);\r\nif (ret) {\r\ndev_err(&adapter->pcidev->dev,\r\n"Failed to load firmware %s\n", file);\r\nreturn ret;\r\n}\r\nnumsects = *(u32 *)(fw->data + index);\r\nindex += 4;\r\nfor (i = 0; i < numsects; i++) {\r\nsectsize[i] = *(u32 *)(fw->data + index);\r\nindex += 4;\r\n}\r\nfor (i = 0; i < numsects; i++) {\r\nsectstart[i] = *(u32 *)(fw->data + index);\r\nindex += 4;\r\n}\r\nucode_start = index;\r\ninstruction = *(u32 *)(fw->data + index);\r\nindex += 4;\r\nfor (section = 0; section < numsects; section++) {\r\nbaseaddress = sectstart[section];\r\nthissectionsize = sectsize[section] >> 3;\r\nfor (codeaddr = 0; codeaddr < thissectionsize; codeaddr++) {\r\nslic_reg32_write(&slic_regs->slic_wcs,\r\nbaseaddress + codeaddr, FLUSH);\r\nslic_reg32_write(&slic_regs->slic_wcs,\r\ninstruction, FLUSH);\r\ninstruction = *(u32 *)(fw->data + index);\r\nindex += 4;\r\nslic_reg32_write(&slic_regs->slic_wcs,\r\ninstruction, FLUSH);\r\ninstruction = *(u32 *)(fw->data + index);\r\nindex += 4;\r\n}\r\n}\r\nindex = ucode_start;\r\nfor (section = 0; section < numsects; section++) {\r\ninstruction = *(u32 *)(fw->data + index);\r\nbaseaddress = sectstart[section];\r\nif (baseaddress < 0x8000)\r\ncontinue;\r\nthissectionsize = sectsize[section] >> 3;\r\nfor (codeaddr = 0; codeaddr < thissectionsize; codeaddr++) {\r\nslic_reg32_write(&slic_regs->slic_wcs,\r\nSLIC_WCS_COMPARE | (baseaddress + codeaddr),\r\nFLUSH);\r\nslic_reg32_write(&slic_regs->slic_wcs, instruction,\r\nFLUSH);\r\ninstruction = *(u32 *)(fw->data + index);\r\nindex += 4;\r\nslic_reg32_write(&slic_regs->slic_wcs, instruction,\r\nFLUSH);\r\ninstruction = *(u32 *)(fw->data + index);\r\nindex += 4;\r\n}\r\n}\r\nrelease_firmware(fw);\r\nmdelay(10);\r\nslic_reg32_write(&slic_regs->slic_wcs, SLIC_WCS_START, FLUSH);\r\nmdelay(20);\r\nreturn 0;\r\n}\r\nstatic void slic_adapter_set_hwaddr(struct adapter *adapter)\r\n{\r\nstruct sliccard *card = adapter->card;\r\nif ((adapter->card) && (card->config_set)) {\r\nmemcpy(adapter->macaddr,\r\ncard->config.MacInfo[adapter->functionnumber].macaddrA,\r\nsizeof(struct slic_config_mac));\r\nif (is_zero_ether_addr(adapter->currmacaddr))\r\nmemcpy(adapter->currmacaddr, adapter->macaddr,\r\nETH_ALEN);\r\nif (adapter->netdev)\r\nmemcpy(adapter->netdev->dev_addr, adapter->currmacaddr,\r\nETH_ALEN);\r\n}\r\n}\r\nstatic void slic_intagg_set(struct adapter *adapter, u32 value)\r\n{\r\nslic_reg32_write(&adapter->slic_regs->slic_intagg, value, FLUSH);\r\nadapter->card->loadlevel_current = value;\r\n}\r\nstatic void slic_soft_reset(struct adapter *adapter)\r\n{\r\nif (adapter->card->state == CARD_UP) {\r\nslic_reg32_write(&adapter->slic_regs->slic_quiesce, 0, FLUSH);\r\nmdelay(1);\r\n}\r\nslic_reg32_write(&adapter->slic_regs->slic_reset, SLIC_RESET_MAGIC,\r\nFLUSH);\r\nmdelay(1);\r\n}\r\nstatic void slic_mac_address_config(struct adapter *adapter)\r\n{\r\nu32 value;\r\nu32 value2;\r\n__iomem struct slic_regs *slic_regs = adapter->slic_regs;\r\nvalue = ntohl(*(__be32 *)&adapter->currmacaddr[2]);\r\nslic_reg32_write(&slic_regs->slic_wraddral, value, FLUSH);\r\nslic_reg32_write(&slic_regs->slic_wraddrbl, value, FLUSH);\r\nvalue2 = (u32)((adapter->currmacaddr[0] << 8 |\r\nadapter->currmacaddr[1]) & 0xFFFF);\r\nslic_reg32_write(&slic_regs->slic_wraddrah, value2, FLUSH);\r\nslic_reg32_write(&slic_regs->slic_wraddrbh, value2, FLUSH);\r\nslic_mcast_set_mask(adapter);\r\n}\r\nstatic void slic_mac_config(struct adapter *adapter)\r\n{\r\nu32 value;\r\n__iomem struct slic_regs *slic_regs = adapter->slic_regs;\r\nif (adapter->linkspeed == LINK_1000MB) {\r\nvalue = ((GMCR_GAPBB_1000 << GMCR_GAPBB_SHIFT) |\r\n(GMCR_GAPR1_1000 << GMCR_GAPR1_SHIFT) |\r\n(GMCR_GAPR2_1000 << GMCR_GAPR2_SHIFT));\r\n} else {\r\nvalue = ((GMCR_GAPBB_100 << GMCR_GAPBB_SHIFT) |\r\n(GMCR_GAPR1_100 << GMCR_GAPR1_SHIFT) |\r\n(GMCR_GAPR2_100 << GMCR_GAPR2_SHIFT));\r\n}\r\nif (adapter->linkspeed == LINK_1000MB)\r\nvalue |= GMCR_GBIT;\r\nif ((adapter->linkduplex == LINK_FULLD)\r\n|| (adapter->macopts & MAC_LOOPBACK)) {\r\nvalue |= GMCR_FULLD;\r\n}\r\nslic_reg32_write(&slic_regs->slic_wmcfg, value, FLUSH);\r\nslic_mac_address_config(adapter);\r\n}\r\nstatic void slic_config_set(struct adapter *adapter, bool linkchange)\r\n{\r\nu32 value;\r\nu32 RcrReset;\r\n__iomem struct slic_regs *slic_regs = adapter->slic_regs;\r\nif (linkchange) {\r\nslic_mac_config(adapter);\r\nRcrReset = GRCR_RESET;\r\n} else {\r\nslic_mac_address_config(adapter);\r\nRcrReset = 0;\r\n}\r\nif (adapter->linkduplex == LINK_FULLD) {\r\nvalue = (GXCR_RESET |\r\nGXCR_XMTEN |\r\nGXCR_PAUSEEN);\r\nslic_reg32_write(&slic_regs->slic_wxcfg, value, FLUSH);\r\nvalue = (RcrReset |\r\nGRCR_CTLEN |\r\nGRCR_ADDRAEN |\r\nGRCR_RCVBAD |\r\n(GRCR_HASHSIZE << GRCR_HASHSIZE_SHIFT));\r\n} else {\r\nvalue = (GXCR_RESET |\r\nGXCR_XMTEN);\r\nslic_reg32_write(&slic_regs->slic_wxcfg, value, FLUSH);\r\nvalue = (RcrReset |\r\nGRCR_ADDRAEN |\r\nGRCR_RCVBAD |\r\n(GRCR_HASHSIZE << GRCR_HASHSIZE_SHIFT));\r\n}\r\nif (adapter->state != ADAPT_DOWN) {\r\nvalue |= GRCR_RCVEN;\r\n}\r\nif (adapter->macopts & MAC_PROMISC)\r\nvalue |= GRCR_RCVALL;\r\nslic_reg32_write(&slic_regs->slic_wrcfg, value, FLUSH);\r\n}\r\nstatic void slic_config_clear(struct adapter *adapter)\r\n{\r\nu32 value;\r\nu32 phy_config;\r\n__iomem struct slic_regs *slic_regs = adapter->slic_regs;\r\nvalue = (GXCR_RESET |\r\nGXCR_PAUSEEN);\r\nslic_reg32_write(&slic_regs->slic_wxcfg, value, FLUSH);\r\nvalue = (GRCR_RESET |\r\nGRCR_CTLEN |\r\nGRCR_ADDRAEN |\r\n(GRCR_HASHSIZE << GRCR_HASHSIZE_SHIFT));\r\nslic_reg32_write(&slic_regs->slic_wrcfg, value, FLUSH);\r\nphy_config = (MIICR_REG_PCR | (PCR_POWERDOWN));\r\nslic_reg32_write(&slic_regs->slic_wphy, phy_config, FLUSH);\r\n}\r\nstatic bool slic_mac_filter(struct adapter *adapter,\r\nstruct ether_header *ether_frame)\r\n{\r\nstruct net_device *netdev = adapter->netdev;\r\nu32 opts = adapter->macopts;\r\nif (opts & MAC_PROMISC)\r\nreturn true;\r\nif (is_broadcast_ether_addr(ether_frame->ether_dhost)) {\r\nif (opts & MAC_BCAST) {\r\nadapter->rcv_broadcasts++;\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nif (is_multicast_ether_addr(ether_frame->ether_dhost)) {\r\nif (opts & MAC_ALLMCAST) {\r\nadapter->rcv_multicasts++;\r\nnetdev->stats.multicast++;\r\nreturn true;\r\n}\r\nif (opts & MAC_MCAST) {\r\nstruct mcast_address *mcaddr = adapter->mcastaddrs;\r\nwhile (mcaddr) {\r\nif (ether_addr_equal(mcaddr->address,\r\nether_frame->ether_dhost)) {\r\nadapter->rcv_multicasts++;\r\nnetdev->stats.multicast++;\r\nreturn true;\r\n}\r\nmcaddr = mcaddr->next;\r\n}\r\nreturn false;\r\n}\r\nreturn false;\r\n}\r\nif (opts & MAC_DIRECTED) {\r\nadapter->rcv_unicasts++;\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic int slic_mac_set_address(struct net_device *dev, void *ptr)\r\n{\r\nstruct adapter *adapter = netdev_priv(dev);\r\nstruct sockaddr *addr = ptr;\r\nif (netif_running(dev))\r\nreturn -EBUSY;\r\nif (!adapter)\r\nreturn -EBUSY;\r\nif (!is_valid_ether_addr(addr->sa_data))\r\nreturn -EINVAL;\r\nmemcpy(dev->dev_addr, addr->sa_data, dev->addr_len);\r\nmemcpy(adapter->currmacaddr, addr->sa_data, dev->addr_len);\r\nslic_config_set(adapter, true);\r\nreturn 0;\r\n}\r\nstatic void slic_timer_load_check(ulong cardaddr)\r\n{\r\nstruct sliccard *card = (struct sliccard *)cardaddr;\r\nstruct adapter *adapter = card->master;\r\nu32 __iomem *intagg;\r\nu32 load = card->events;\r\nu32 level = 0;\r\nif ((adapter) && (adapter->state == ADAPT_UP) &&\r\n(card->state == CARD_UP) && (slic_global.dynamic_intagg)) {\r\nintagg = &adapter->slic_regs->slic_intagg;\r\nif (adapter->devid == SLIC_1GB_DEVICE_ID) {\r\nif (adapter->linkspeed == LINK_1000MB)\r\nlevel = 100;\r\nelse {\r\nif (load > SLIC_LOAD_5)\r\nlevel = SLIC_INTAGG_5;\r\nelse if (load > SLIC_LOAD_4)\r\nlevel = SLIC_INTAGG_4;\r\nelse if (load > SLIC_LOAD_3)\r\nlevel = SLIC_INTAGG_3;\r\nelse if (load > SLIC_LOAD_2)\r\nlevel = SLIC_INTAGG_2;\r\nelse if (load > SLIC_LOAD_1)\r\nlevel = SLIC_INTAGG_1;\r\nelse\r\nlevel = SLIC_INTAGG_0;\r\n}\r\nif (card->loadlevel_current != level) {\r\ncard->loadlevel_current = level;\r\nslic_reg32_write(intagg, level, FLUSH);\r\n}\r\n} else {\r\nif (load > SLIC_LOAD_5)\r\nlevel = SLIC_INTAGG_5;\r\nelse if (load > SLIC_LOAD_4)\r\nlevel = SLIC_INTAGG_4;\r\nelse if (load > SLIC_LOAD_3)\r\nlevel = SLIC_INTAGG_3;\r\nelse if (load > SLIC_LOAD_2)\r\nlevel = SLIC_INTAGG_2;\r\nelse if (load > SLIC_LOAD_1)\r\nlevel = SLIC_INTAGG_1;\r\nelse\r\nlevel = SLIC_INTAGG_0;\r\nif (card->loadlevel_current != level) {\r\ncard->loadlevel_current = level;\r\nslic_reg32_write(intagg, level, FLUSH);\r\n}\r\n}\r\n}\r\ncard->events = 0;\r\ncard->loadtimer.expires = jiffies + (SLIC_LOADTIMER_PERIOD * HZ);\r\nadd_timer(&card->loadtimer);\r\n}\r\nstatic int slic_upr_queue_request(struct adapter *adapter,\r\nu32 upr_request,\r\nu32 upr_data,\r\nu32 upr_data_h,\r\nu32 upr_buffer, u32 upr_buffer_h)\r\n{\r\nstruct slic_upr *upr;\r\nstruct slic_upr *uprqueue;\r\nupr = kmalloc(sizeof(struct slic_upr), GFP_ATOMIC);\r\nif (!upr)\r\nreturn -ENOMEM;\r\nupr->adapter = adapter->port;\r\nupr->upr_request = upr_request;\r\nupr->upr_data = upr_data;\r\nupr->upr_buffer = upr_buffer;\r\nupr->upr_data_h = upr_data_h;\r\nupr->upr_buffer_h = upr_buffer_h;\r\nupr->next = NULL;\r\nif (adapter->upr_list) {\r\nuprqueue = adapter->upr_list;\r\nwhile (uprqueue->next)\r\nuprqueue = uprqueue->next;\r\nuprqueue->next = upr;\r\n} else {\r\nadapter->upr_list = upr;\r\n}\r\nreturn 0;\r\n}\r\nstatic void slic_upr_start(struct adapter *adapter)\r\n{\r\nstruct slic_upr *upr;\r\n__iomem struct slic_regs *slic_regs = adapter->slic_regs;\r\nupr = adapter->upr_list;\r\nif (!upr)\r\nreturn;\r\nif (adapter->upr_busy)\r\nreturn;\r\nadapter->upr_busy = 1;\r\nswitch (upr->upr_request) {\r\ncase SLIC_UPR_STATS:\r\nif (upr->upr_data_h == 0) {\r\nslic_reg32_write(&slic_regs->slic_stats, upr->upr_data,\r\nFLUSH);\r\n} else {\r\nslic_reg64_write(adapter, &slic_regs->slic_stats64,\r\nupr->upr_data,\r\n&slic_regs->slic_addr_upper,\r\nupr->upr_data_h, FLUSH);\r\n}\r\nbreak;\r\ncase SLIC_UPR_RLSR:\r\nslic_reg64_write(adapter, &slic_regs->slic_rlsr, upr->upr_data,\r\n&slic_regs->slic_addr_upper, upr->upr_data_h,\r\nFLUSH);\r\nbreak;\r\ncase SLIC_UPR_RCONFIG:\r\nslic_reg64_write(adapter, &slic_regs->slic_rconfig,\r\nupr->upr_data, &slic_regs->slic_addr_upper,\r\nupr->upr_data_h, FLUSH);\r\nbreak;\r\ncase SLIC_UPR_PING:\r\nslic_reg32_write(&slic_regs->slic_ping, 1, FLUSH);\r\nbreak;\r\n}\r\n}\r\nstatic int slic_upr_request(struct adapter *adapter,\r\nu32 upr_request,\r\nu32 upr_data,\r\nu32 upr_data_h,\r\nu32 upr_buffer, u32 upr_buffer_h)\r\n{\r\nunsigned long flags;\r\nint rc;\r\nspin_lock_irqsave(&adapter->upr_lock, flags);\r\nrc = slic_upr_queue_request(adapter,\r\nupr_request,\r\nupr_data,\r\nupr_data_h, upr_buffer, upr_buffer_h);\r\nif (rc)\r\ngoto err_unlock_irq;\r\nslic_upr_start(adapter);\r\nerr_unlock_irq:\r\nspin_unlock_irqrestore(&adapter->upr_lock, flags);\r\nreturn rc;\r\n}\r\nstatic void slic_link_upr_complete(struct adapter *adapter, u32 isr)\r\n{\r\nu32 linkstatus = adapter->pshmem->linkstatus;\r\nuint linkup;\r\nunsigned char linkspeed;\r\nunsigned char linkduplex;\r\nif ((isr & ISR_UPCERR) || (isr & ISR_UPCBSY)) {\r\nstruct slic_shmem *pshmem;\r\npshmem = (struct slic_shmem *)(unsigned long)\r\nadapter->phys_shmem;\r\n#if BITS_PER_LONG == 64\r\nslic_upr_queue_request(adapter,\r\nSLIC_UPR_RLSR,\r\nSLIC_GET_ADDR_LOW(&pshmem->linkstatus),\r\nSLIC_GET_ADDR_HIGH(&pshmem->linkstatus),\r\n0, 0);\r\n#else\r\nslic_upr_queue_request(adapter,\r\nSLIC_UPR_RLSR,\r\n(u32)&pshmem->linkstatus,\r\nSLIC_GET_ADDR_HIGH(pshmem), 0, 0);\r\n#endif\r\nreturn;\r\n}\r\nif (adapter->state != ADAPT_UP)\r\nreturn;\r\nlinkup = linkstatus & GIG_LINKUP ? LINK_UP : LINK_DOWN;\r\nif (linkstatus & GIG_SPEED_1000)\r\nlinkspeed = LINK_1000MB;\r\nelse if (linkstatus & GIG_SPEED_100)\r\nlinkspeed = LINK_100MB;\r\nelse\r\nlinkspeed = LINK_10MB;\r\nif (linkstatus & GIG_FULLDUPLEX)\r\nlinkduplex = LINK_FULLD;\r\nelse\r\nlinkduplex = LINK_HALFD;\r\nif ((adapter->linkstate == LINK_DOWN) && (linkup == LINK_DOWN))\r\nreturn;\r\nif ((adapter->linkstate == LINK_UP) &&\r\n(linkup == LINK_UP) &&\r\n(adapter->linkspeed == linkspeed) &&\r\n(adapter->linkduplex == linkduplex))\r\nreturn;\r\nif (linkup == LINK_DOWN) {\r\nadapter->linkstate = LINK_DOWN;\r\nreturn;\r\n}\r\nadapter->linkspeed = linkspeed;\r\nadapter->linkduplex = linkduplex;\r\nif (adapter->linkstate != LINK_UP) {\r\nslic_config_set(adapter, true);\r\nadapter->linkstate = LINK_UP;\r\nnetif_start_queue(adapter->netdev);\r\n}\r\n}\r\nstatic void slic_upr_request_complete(struct adapter *adapter, u32 isr)\r\n{\r\nstruct sliccard *card = adapter->card;\r\nstruct slic_upr *upr;\r\nunsigned long flags;\r\nspin_lock_irqsave(&adapter->upr_lock, flags);\r\nupr = adapter->upr_list;\r\nif (!upr) {\r\nspin_unlock_irqrestore(&adapter->upr_lock, flags);\r\nreturn;\r\n}\r\nadapter->upr_list = upr->next;\r\nupr->next = NULL;\r\nadapter->upr_busy = 0;\r\nswitch (upr->upr_request) {\r\ncase SLIC_UPR_STATS:\r\n{\r\nstruct slic_stats *slicstats =\r\n(struct slic_stats *)&adapter->pshmem->inicstats;\r\nstruct slic_stats *newstats = slicstats;\r\nstruct slic_stats *old = &adapter->inicstats_prev;\r\nstruct slicnet_stats *stst = &adapter->slic_stats;\r\nif (isr & ISR_UPCERR) {\r\ndev_err(&adapter->netdev->dev,\r\n"SLIC_UPR_STATS command failed isr[%x]\n",\r\nisr);\r\nbreak;\r\n}\r\nUPDATE_STATS_GB(stst->tcp.xmit_tcp_segs,\r\nnewstats->xmit_tcp_segs_gb,\r\nold->xmit_tcp_segs_gb);\r\nUPDATE_STATS_GB(stst->tcp.xmit_tcp_bytes,\r\nnewstats->xmit_tcp_bytes_gb,\r\nold->xmit_tcp_bytes_gb);\r\nUPDATE_STATS_GB(stst->tcp.rcv_tcp_segs,\r\nnewstats->rcv_tcp_segs_gb,\r\nold->rcv_tcp_segs_gb);\r\nUPDATE_STATS_GB(stst->tcp.rcv_tcp_bytes,\r\nnewstats->rcv_tcp_bytes_gb,\r\nold->rcv_tcp_bytes_gb);\r\nUPDATE_STATS_GB(stst->iface.xmt_bytes,\r\nnewstats->xmit_bytes_gb,\r\nold->xmit_bytes_gb);\r\nUPDATE_STATS_GB(stst->iface.xmt_ucast,\r\nnewstats->xmit_unicasts_gb,\r\nold->xmit_unicasts_gb);\r\nUPDATE_STATS_GB(stst->iface.rcv_bytes,\r\nnewstats->rcv_bytes_gb,\r\nold->rcv_bytes_gb);\r\nUPDATE_STATS_GB(stst->iface.rcv_ucast,\r\nnewstats->rcv_unicasts_gb,\r\nold->rcv_unicasts_gb);\r\nUPDATE_STATS_GB(stst->iface.xmt_errors,\r\nnewstats->xmit_collisions_gb,\r\nold->xmit_collisions_gb);\r\nUPDATE_STATS_GB(stst->iface.xmt_errors,\r\nnewstats->xmit_excess_collisions_gb,\r\nold->xmit_excess_collisions_gb);\r\nUPDATE_STATS_GB(stst->iface.xmt_errors,\r\nnewstats->xmit_other_error_gb,\r\nold->xmit_other_error_gb);\r\nUPDATE_STATS_GB(stst->iface.rcv_errors,\r\nnewstats->rcv_other_error_gb,\r\nold->rcv_other_error_gb);\r\nUPDATE_STATS_GB(stst->iface.rcv_discards,\r\nnewstats->rcv_drops_gb,\r\nold->rcv_drops_gb);\r\nif (newstats->rcv_drops_gb > old->rcv_drops_gb) {\r\nadapter->rcv_drops +=\r\n(newstats->rcv_drops_gb -\r\nold->rcv_drops_gb);\r\n}\r\nmemcpy(old, newstats, sizeof(struct slic_stats));\r\nbreak;\r\n}\r\ncase SLIC_UPR_RLSR:\r\nslic_link_upr_complete(adapter, isr);\r\nbreak;\r\ncase SLIC_UPR_RCONFIG:\r\nbreak;\r\ncase SLIC_UPR_PING:\r\ncard->pingstatus |= (isr & ISR_PINGDSMASK);\r\nbreak;\r\n}\r\nkfree(upr);\r\nslic_upr_start(adapter);\r\nspin_unlock_irqrestore(&adapter->upr_lock, flags);\r\n}\r\nstatic int slic_config_get(struct adapter *adapter, u32 config, u32 config_h)\r\n{\r\nreturn slic_upr_request(adapter, SLIC_UPR_RCONFIG, config, config_h,\r\n0, 0);\r\n}\r\nstatic u16 slic_eeprom_cksum(void *eeprom, unsigned len)\r\n{\r\nu16 *wp = eeprom;\r\nu32 checksum = 0;\r\nwhile (len > 1) {\r\nchecksum += *(wp++);\r\nlen -= 2;\r\n}\r\nif (len > 0)\r\nchecksum += *(u8 *)wp;\r\nwhile (checksum >> 16)\r\nchecksum = (checksum & 0xFFFF) + ((checksum >> 16) & 0xFFFF);\r\nreturn ~checksum;\r\n}\r\nstatic void slic_rspqueue_free(struct adapter *adapter)\r\n{\r\nint i;\r\nstruct slic_rspqueue *rspq = &adapter->rspqueue;\r\nfor (i = 0; i < rspq->num_pages; i++) {\r\nif (rspq->vaddr[i]) {\r\npci_free_consistent(adapter->pcidev, PAGE_SIZE,\r\nrspq->vaddr[i], rspq->paddr[i]);\r\n}\r\nrspq->vaddr[i] = NULL;\r\nrspq->paddr[i] = 0;\r\n}\r\nrspq->offset = 0;\r\nrspq->pageindex = 0;\r\nrspq->rspbuf = NULL;\r\n}\r\nstatic int slic_rspqueue_init(struct adapter *adapter)\r\n{\r\nint i;\r\nstruct slic_rspqueue *rspq = &adapter->rspqueue;\r\n__iomem struct slic_regs *slic_regs = adapter->slic_regs;\r\nu32 paddrh = 0;\r\nmemset(rspq, 0, sizeof(struct slic_rspqueue));\r\nrspq->num_pages = SLIC_RSPQ_PAGES_GB;\r\nfor (i = 0; i < rspq->num_pages; i++) {\r\nrspq->vaddr[i] = pci_zalloc_consistent(adapter->pcidev,\r\nPAGE_SIZE,\r\n&rspq->paddr[i]);\r\nif (!rspq->vaddr[i]) {\r\ndev_err(&adapter->pcidev->dev,\r\n"pci_alloc_consistent failed\n");\r\nslic_rspqueue_free(adapter);\r\nreturn -ENOMEM;\r\n}\r\nif (paddrh == 0) {\r\nslic_reg32_write(&slic_regs->slic_rbar,\r\n(rspq->paddr[i] | SLIC_RSPQ_BUFSINPAGE),\r\nDONT_FLUSH);\r\n} else {\r\nslic_reg64_write(adapter, &slic_regs->slic_rbar64,\r\n(rspq->paddr[i] | SLIC_RSPQ_BUFSINPAGE),\r\n&slic_regs->slic_addr_upper,\r\npaddrh, DONT_FLUSH);\r\n}\r\n}\r\nrspq->offset = 0;\r\nrspq->pageindex = 0;\r\nrspq->rspbuf = (struct slic_rspbuf *)rspq->vaddr[0];\r\nreturn 0;\r\n}\r\nstatic struct slic_rspbuf *slic_rspqueue_getnext(struct adapter *adapter)\r\n{\r\nstruct slic_rspqueue *rspq = &adapter->rspqueue;\r\nstruct slic_rspbuf *buf;\r\nif (!(rspq->rspbuf->status))\r\nreturn NULL;\r\nbuf = rspq->rspbuf;\r\nif (++rspq->offset < SLIC_RSPQ_BUFSINPAGE) {\r\nrspq->rspbuf++;\r\n} else {\r\nslic_reg64_write(adapter, &adapter->slic_regs->slic_rbar64,\r\n(rspq->paddr[rspq->pageindex] | SLIC_RSPQ_BUFSINPAGE),\r\n&adapter->slic_regs->slic_addr_upper, 0, DONT_FLUSH);\r\nrspq->pageindex = (rspq->pageindex + 1) % rspq->num_pages;\r\nrspq->offset = 0;\r\nrspq->rspbuf = (struct slic_rspbuf *)\r\nrspq->vaddr[rspq->pageindex];\r\n}\r\nreturn buf;\r\n}\r\nstatic void slic_cmdqmem_free(struct adapter *adapter)\r\n{\r\nstruct slic_cmdqmem *cmdqmem = &adapter->cmdqmem;\r\nint i;\r\nfor (i = 0; i < SLIC_CMDQ_MAXPAGES; i++) {\r\nif (cmdqmem->pages[i]) {\r\npci_free_consistent(adapter->pcidev,\r\nPAGE_SIZE,\r\n(void *)cmdqmem->pages[i],\r\ncmdqmem->dma_pages[i]);\r\n}\r\n}\r\nmemset(cmdqmem, 0, sizeof(struct slic_cmdqmem));\r\n}\r\nstatic u32 *slic_cmdqmem_addpage(struct adapter *adapter)\r\n{\r\nstruct slic_cmdqmem *cmdqmem = &adapter->cmdqmem;\r\nu32 *pageaddr;\r\nif (cmdqmem->pagecnt >= SLIC_CMDQ_MAXPAGES)\r\nreturn NULL;\r\npageaddr = pci_alloc_consistent(adapter->pcidev,\r\nPAGE_SIZE,\r\n&cmdqmem->dma_pages[cmdqmem->pagecnt]);\r\nif (!pageaddr)\r\nreturn NULL;\r\ncmdqmem->pages[cmdqmem->pagecnt] = pageaddr;\r\ncmdqmem->pagecnt++;\r\nreturn pageaddr;\r\n}\r\nstatic void slic_cmdq_free(struct adapter *adapter)\r\n{\r\nstruct slic_hostcmd *cmd;\r\ncmd = adapter->cmdq_all.head;\r\nwhile (cmd) {\r\nif (cmd->busy) {\r\nstruct sk_buff *tempskb;\r\ntempskb = cmd->skb;\r\nif (tempskb) {\r\ncmd->skb = NULL;\r\ndev_kfree_skb_irq(tempskb);\r\n}\r\n}\r\ncmd = cmd->next_all;\r\n}\r\nmemset(&adapter->cmdq_all, 0, sizeof(struct slic_cmdqueue));\r\nmemset(&adapter->cmdq_free, 0, sizeof(struct slic_cmdqueue));\r\nmemset(&adapter->cmdq_done, 0, sizeof(struct slic_cmdqueue));\r\nslic_cmdqmem_free(adapter);\r\n}\r\nstatic void slic_cmdq_addcmdpage(struct adapter *adapter, u32 *page)\r\n{\r\nstruct slic_hostcmd *cmd;\r\nstruct slic_hostcmd *prev;\r\nstruct slic_hostcmd *tail;\r\nstruct slic_cmdqueue *cmdq;\r\nint cmdcnt;\r\nvoid *cmdaddr;\r\nulong phys_addr;\r\nu32 phys_addrl;\r\nu32 phys_addrh;\r\nstruct slic_handle *pslic_handle;\r\nunsigned long flags;\r\ncmdaddr = page;\r\ncmd = cmdaddr;\r\ncmdcnt = 0;\r\nphys_addr = virt_to_bus((void *)page);\r\nphys_addrl = SLIC_GET_ADDR_LOW(phys_addr);\r\nphys_addrh = SLIC_GET_ADDR_HIGH(phys_addr);\r\nprev = NULL;\r\ntail = cmd;\r\nwhile ((cmdcnt < SLIC_CMDQ_CMDSINPAGE) &&\r\n(adapter->slic_handle_ix < 256)) {\r\nspin_lock_irqsave(&adapter->handle_lock, flags);\r\npslic_handle = adapter->pfree_slic_handles;\r\nadapter->pfree_slic_handles = pslic_handle->next;\r\nspin_unlock_irqrestore(&adapter->handle_lock, flags);\r\npslic_handle->type = SLIC_HANDLE_CMD;\r\npslic_handle->address = (void *)cmd;\r\npslic_handle->offset = (ushort)adapter->slic_handle_ix++;\r\npslic_handle->other_handle = NULL;\r\npslic_handle->next = NULL;\r\ncmd->pslic_handle = pslic_handle;\r\ncmd->cmd64.hosthandle = pslic_handle->token.handle_token;\r\ncmd->busy = false;\r\ncmd->paddrl = phys_addrl;\r\ncmd->paddrh = phys_addrh;\r\ncmd->next_all = prev;\r\ncmd->next = prev;\r\nprev = cmd;\r\nphys_addrl += SLIC_HOSTCMD_SIZE;\r\ncmdaddr += SLIC_HOSTCMD_SIZE;\r\ncmd = cmdaddr;\r\ncmdcnt++;\r\n}\r\ncmdq = &adapter->cmdq_all;\r\ncmdq->count += cmdcnt;\r\ntail->next_all = cmdq->head;\r\ncmdq->head = prev;\r\ncmdq = &adapter->cmdq_free;\r\nspin_lock_irqsave(&cmdq->lock, flags);\r\ncmdq->count += cmdcnt;\r\ntail->next = cmdq->head;\r\ncmdq->head = prev;\r\nspin_unlock_irqrestore(&cmdq->lock, flags);\r\n}\r\nstatic int slic_cmdq_init(struct adapter *adapter)\r\n{\r\nint i;\r\nu32 *pageaddr;\r\nmemset(&adapter->cmdq_all, 0, sizeof(struct slic_cmdqueue));\r\nmemset(&adapter->cmdq_free, 0, sizeof(struct slic_cmdqueue));\r\nmemset(&adapter->cmdq_done, 0, sizeof(struct slic_cmdqueue));\r\nspin_lock_init(&adapter->cmdq_all.lock);\r\nspin_lock_init(&adapter->cmdq_free.lock);\r\nspin_lock_init(&adapter->cmdq_done.lock);\r\nmemset(&adapter->cmdqmem, 0, sizeof(struct slic_cmdqmem));\r\nadapter->slic_handle_ix = 1;\r\nfor (i = 0; i < SLIC_CMDQ_INITPAGES; i++) {\r\npageaddr = slic_cmdqmem_addpage(adapter);\r\nif (!pageaddr) {\r\nslic_cmdq_free(adapter);\r\nreturn -ENOMEM;\r\n}\r\nslic_cmdq_addcmdpage(adapter, pageaddr);\r\n}\r\nadapter->slic_handle_ix = 1;\r\nreturn 0;\r\n}\r\nstatic void slic_cmdq_reset(struct adapter *adapter)\r\n{\r\nstruct slic_hostcmd *hcmd;\r\nstruct sk_buff *skb;\r\nu32 outstanding;\r\nunsigned long flags;\r\nspin_lock_irqsave(&adapter->cmdq_free.lock, flags);\r\nspin_lock(&adapter->cmdq_done.lock);\r\noutstanding = adapter->cmdq_all.count - adapter->cmdq_done.count;\r\noutstanding -= adapter->cmdq_free.count;\r\nhcmd = adapter->cmdq_all.head;\r\nwhile (hcmd) {\r\nif (hcmd->busy) {\r\nskb = hcmd->skb;\r\nhcmd->busy = 0;\r\nhcmd->skb = NULL;\r\ndev_kfree_skb_irq(skb);\r\n}\r\nhcmd = hcmd->next_all;\r\n}\r\nadapter->cmdq_free.count = 0;\r\nadapter->cmdq_free.head = NULL;\r\nadapter->cmdq_free.tail = NULL;\r\nadapter->cmdq_done.count = 0;\r\nadapter->cmdq_done.head = NULL;\r\nadapter->cmdq_done.tail = NULL;\r\nadapter->cmdq_free.head = adapter->cmdq_all.head;\r\nhcmd = adapter->cmdq_all.head;\r\nwhile (hcmd) {\r\nadapter->cmdq_free.count++;\r\nhcmd->next = hcmd->next_all;\r\nhcmd = hcmd->next_all;\r\n}\r\nif (adapter->cmdq_free.count != adapter->cmdq_all.count) {\r\ndev_err(&adapter->netdev->dev,\r\n"free_count %d != all count %d\n",\r\nadapter->cmdq_free.count, adapter->cmdq_all.count);\r\n}\r\nspin_unlock(&adapter->cmdq_done.lock);\r\nspin_unlock_irqrestore(&adapter->cmdq_free.lock, flags);\r\n}\r\nstatic void slic_cmdq_getdone(struct adapter *adapter)\r\n{\r\nstruct slic_cmdqueue *done_cmdq = &adapter->cmdq_done;\r\nstruct slic_cmdqueue *free_cmdq = &adapter->cmdq_free;\r\nunsigned long flags;\r\nspin_lock_irqsave(&done_cmdq->lock, flags);\r\nfree_cmdq->head = done_cmdq->head;\r\nfree_cmdq->count = done_cmdq->count;\r\ndone_cmdq->head = NULL;\r\ndone_cmdq->tail = NULL;\r\ndone_cmdq->count = 0;\r\nspin_unlock_irqrestore(&done_cmdq->lock, flags);\r\n}\r\nstatic struct slic_hostcmd *slic_cmdq_getfree(struct adapter *adapter)\r\n{\r\nstruct slic_cmdqueue *cmdq = &adapter->cmdq_free;\r\nstruct slic_hostcmd *cmd = NULL;\r\nunsigned long flags;\r\nlock_and_retry:\r\nspin_lock_irqsave(&cmdq->lock, flags);\r\nretry:\r\ncmd = cmdq->head;\r\nif (cmd) {\r\ncmdq->head = cmd->next;\r\ncmdq->count--;\r\nspin_unlock_irqrestore(&cmdq->lock, flags);\r\n} else {\r\nslic_cmdq_getdone(adapter);\r\ncmd = cmdq->head;\r\nif (cmd) {\r\ngoto retry;\r\n} else {\r\nu32 *pageaddr;\r\nspin_unlock_irqrestore(&cmdq->lock, flags);\r\npageaddr = slic_cmdqmem_addpage(adapter);\r\nif (pageaddr) {\r\nslic_cmdq_addcmdpage(adapter, pageaddr);\r\ngoto lock_and_retry;\r\n}\r\n}\r\n}\r\nreturn cmd;\r\n}\r\nstatic void slic_cmdq_putdone_irq(struct adapter *adapter,\r\nstruct slic_hostcmd *cmd)\r\n{\r\nstruct slic_cmdqueue *cmdq = &adapter->cmdq_done;\r\nspin_lock(&cmdq->lock);\r\ncmd->busy = 0;\r\ncmd->next = cmdq->head;\r\ncmdq->head = cmd;\r\ncmdq->count++;\r\nif ((adapter->xmitq_full) && (cmdq->count > 10))\r\nnetif_wake_queue(adapter->netdev);\r\nspin_unlock(&cmdq->lock);\r\n}\r\nstatic int slic_rcvqueue_fill(struct adapter *adapter)\r\n{\r\nvoid *paddr;\r\nu32 paddrl;\r\nu32 paddrh;\r\nstruct slic_rcvqueue *rcvq = &adapter->rcvqueue;\r\nint i = 0;\r\nstruct device *dev = &adapter->netdev->dev;\r\nwhile (i < SLIC_RCVQ_FILLENTRIES) {\r\nstruct slic_rcvbuf *rcvbuf;\r\nstruct sk_buff *skb;\r\n#ifdef KLUDGE_FOR_4GB_BOUNDARY\r\nretry_rcvqfill:\r\n#endif\r\nskb = alloc_skb(SLIC_RCVQ_RCVBUFSIZE, GFP_ATOMIC);\r\nif (skb) {\r\npaddr = (void *)(unsigned long)\r\npci_map_single(adapter->pcidev,\r\nskb->data,\r\nSLIC_RCVQ_RCVBUFSIZE,\r\nPCI_DMA_FROMDEVICE);\r\npaddrl = SLIC_GET_ADDR_LOW(paddr);\r\npaddrh = SLIC_GET_ADDR_HIGH(paddr);\r\nskb->len = SLIC_RCVBUF_HEADSIZE;\r\nrcvbuf = (struct slic_rcvbuf *)skb->head;\r\nrcvbuf->status = 0;\r\nskb->next = NULL;\r\n#ifdef KLUDGE_FOR_4GB_BOUNDARY\r\nif (paddrl == 0) {\r\ndev_err(dev, "%s: LOW 32bits PHYSICAL ADDRESS == 0\n",\r\n__func__);\r\ndev_err(dev, "skb[%p] PROBLEM\n", skb);\r\ndev_err(dev, " skbdata[%p]\n",\r\nskb->data);\r\ndev_err(dev, " skblen[%x]\n", skb->len);\r\ndev_err(dev, " paddr[%p]\n", paddr);\r\ndev_err(dev, " paddrl[%x]\n", paddrl);\r\ndev_err(dev, " paddrh[%x]\n", paddrh);\r\ndev_err(dev, " rcvq->head[%p]\n",\r\nrcvq->head);\r\ndev_err(dev, " rcvq->tail[%p]\n",\r\nrcvq->tail);\r\ndev_err(dev, " rcvq->count[%x]\n",\r\nrcvq->count);\r\ndev_err(dev, "SKIP THIS SKB!!!!!!!!\n");\r\ngoto retry_rcvqfill;\r\n}\r\n#else\r\nif (paddrl == 0) {\r\ndev_err(dev, "%s: LOW 32bits PHYSICAL ADDRESS == 0\n",\r\n__func__);\r\ndev_err(dev, "skb[%p] PROBLEM\n", skb);\r\ndev_err(dev, " skbdata[%p]\n",\r\nskb->data);\r\ndev_err(dev, " skblen[%x]\n", skb->len);\r\ndev_err(dev, " paddr[%p]\n", paddr);\r\ndev_err(dev, " paddrl[%x]\n", paddrl);\r\ndev_err(dev, " paddrh[%x]\n", paddrh);\r\ndev_err(dev, " rcvq->head[%p]\n",\r\nrcvq->head);\r\ndev_err(dev, " rcvq->tail[%p]\n",\r\nrcvq->tail);\r\ndev_err(dev, " rcvq->count[%x]\n",\r\nrcvq->count);\r\ndev_err(dev, "GIVE TO CARD ANYWAY\n");\r\n}\r\n#endif\r\nif (paddrh == 0) {\r\nslic_reg32_write(&adapter->slic_regs->slic_hbar,\r\n(u32)paddrl, DONT_FLUSH);\r\n} else {\r\nslic_reg64_write(adapter,\r\n&adapter->slic_regs->slic_hbar64,\r\npaddrl,\r\n&adapter->slic_regs->slic_addr_upper,\r\npaddrh, DONT_FLUSH);\r\n}\r\nif (rcvq->head)\r\nrcvq->tail->next = skb;\r\nelse\r\nrcvq->head = skb;\r\nrcvq->tail = skb;\r\nrcvq->count++;\r\ni++;\r\n} else {\r\ndev_err(&adapter->netdev->dev,\r\n"slic_rcvqueue_fill could only get [%d] skbuffs\n",\r\ni);\r\nbreak;\r\n}\r\n}\r\nreturn i;\r\n}\r\nstatic void slic_rcvqueue_free(struct adapter *adapter)\r\n{\r\nstruct slic_rcvqueue *rcvq = &adapter->rcvqueue;\r\nstruct sk_buff *skb;\r\nwhile (rcvq->head) {\r\nskb = rcvq->head;\r\nrcvq->head = rcvq->head->next;\r\ndev_kfree_skb(skb);\r\n}\r\nrcvq->tail = NULL;\r\nrcvq->head = NULL;\r\nrcvq->count = 0;\r\n}\r\nstatic int slic_rcvqueue_init(struct adapter *adapter)\r\n{\r\nint i, count;\r\nstruct slic_rcvqueue *rcvq = &adapter->rcvqueue;\r\nrcvq->tail = NULL;\r\nrcvq->head = NULL;\r\nrcvq->size = SLIC_RCVQ_ENTRIES;\r\nrcvq->errors = 0;\r\nrcvq->count = 0;\r\ni = SLIC_RCVQ_ENTRIES / SLIC_RCVQ_FILLENTRIES;\r\ncount = 0;\r\nwhile (i) {\r\ncount += slic_rcvqueue_fill(adapter);\r\ni--;\r\n}\r\nif (rcvq->count < SLIC_RCVQ_MINENTRIES) {\r\nslic_rcvqueue_free(adapter);\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}\r\nstatic struct sk_buff *slic_rcvqueue_getnext(struct adapter *adapter)\r\n{\r\nstruct slic_rcvqueue *rcvq = &adapter->rcvqueue;\r\nstruct sk_buff *skb;\r\nstruct slic_rcvbuf *rcvbuf;\r\nint count;\r\nif (rcvq->count) {\r\nskb = rcvq->head;\r\nrcvbuf = (struct slic_rcvbuf *)skb->head;\r\nif (rcvbuf->status & IRHDDR_SVALID) {\r\nrcvq->head = rcvq->head->next;\r\nskb->next = NULL;\r\nrcvq->count--;\r\n} else {\r\nskb = NULL;\r\n}\r\n} else {\r\ndev_err(&adapter->netdev->dev,\r\n"RcvQ Empty!! rcvq[%p] count[%x]\n", rcvq, rcvq->count);\r\nskb = NULL;\r\n}\r\nwhile (rcvq->count < SLIC_RCVQ_FILLTHRESH) {\r\ncount = slic_rcvqueue_fill(adapter);\r\nif (!count)\r\nbreak;\r\n}\r\nif (skb)\r\nrcvq->errors = 0;\r\nreturn skb;\r\n}\r\nstatic u32 slic_rcvqueue_reinsert(struct adapter *adapter, struct sk_buff *skb)\r\n{\r\nstruct slic_rcvqueue *rcvq = &adapter->rcvqueue;\r\nvoid *paddr;\r\nu32 paddrl;\r\nu32 paddrh;\r\nstruct slic_rcvbuf *rcvbuf = (struct slic_rcvbuf *)skb->head;\r\nstruct device *dev;\r\npaddr = (void *)(unsigned long)\r\npci_map_single(adapter->pcidev, skb->head,\r\nSLIC_RCVQ_RCVBUFSIZE, PCI_DMA_FROMDEVICE);\r\nrcvbuf->status = 0;\r\nskb->next = NULL;\r\npaddrl = SLIC_GET_ADDR_LOW(paddr);\r\npaddrh = SLIC_GET_ADDR_HIGH(paddr);\r\nif (paddrl == 0) {\r\ndev = &adapter->netdev->dev;\r\ndev_err(dev, "%s: LOW 32bits PHYSICAL ADDRESS == 0\n",\r\n__func__);\r\ndev_err(dev, "skb[%p] PROBLEM\n", skb);\r\ndev_err(dev, " skbdata[%p]\n", skb->data);\r\ndev_err(dev, " skblen[%x]\n", skb->len);\r\ndev_err(dev, " paddr[%p]\n", paddr);\r\ndev_err(dev, " paddrl[%x]\n", paddrl);\r\ndev_err(dev, " paddrh[%x]\n", paddrh);\r\ndev_err(dev, " rcvq->head[%p]\n", rcvq->head);\r\ndev_err(dev, " rcvq->tail[%p]\n", rcvq->tail);\r\ndev_err(dev, " rcvq->count[%x]\n", rcvq->count);\r\n}\r\nif (paddrh == 0) {\r\nslic_reg32_write(&adapter->slic_regs->slic_hbar, (u32)paddrl,\r\nDONT_FLUSH);\r\n} else {\r\nslic_reg64_write(adapter, &adapter->slic_regs->slic_hbar64,\r\npaddrl, &adapter->slic_regs->slic_addr_upper,\r\npaddrh, DONT_FLUSH);\r\n}\r\nif (rcvq->head)\r\nrcvq->tail->next = skb;\r\nelse\r\nrcvq->head = skb;\r\nrcvq->tail = skb;\r\nrcvq->count++;\r\nreturn rcvq->count;\r\n}\r\nstatic int slic_link_event_handler(struct adapter *adapter)\r\n{\r\nint status;\r\nstruct slic_shmem *pshmem;\r\nif (adapter->state != ADAPT_UP) {\r\nreturn -ENODEV;\r\n}\r\npshmem = (struct slic_shmem *)(unsigned long)adapter->phys_shmem;\r\n#if BITS_PER_LONG == 64\r\nstatus = slic_upr_request(adapter,\r\nSLIC_UPR_RLSR,\r\nSLIC_GET_ADDR_LOW(&pshmem->linkstatus),\r\nSLIC_GET_ADDR_HIGH(&pshmem->linkstatus),\r\n0, 0);\r\n#else\r\nstatus = slic_upr_request(adapter, SLIC_UPR_RLSR,\r\n(u32)&pshmem->linkstatus,\r\n0, 0, 0);\r\n#endif\r\nreturn status;\r\n}\r\nstatic void slic_init_cleanup(struct adapter *adapter)\r\n{\r\nif (adapter->intrregistered) {\r\nadapter->intrregistered = 0;\r\nfree_irq(adapter->netdev->irq, adapter->netdev);\r\n}\r\nif (adapter->pshmem) {\r\npci_free_consistent(adapter->pcidev,\r\nsizeof(struct slic_shmem),\r\nadapter->pshmem, adapter->phys_shmem);\r\nadapter->pshmem = NULL;\r\nadapter->phys_shmem = (dma_addr_t)(unsigned long)NULL;\r\n}\r\nif (adapter->pingtimerset) {\r\nadapter->pingtimerset = 0;\r\ndel_timer(&adapter->pingtimer);\r\n}\r\nslic_rspqueue_free(adapter);\r\nslic_cmdq_free(adapter);\r\nslic_rcvqueue_free(adapter);\r\n}\r\nstatic int slic_mcast_add_list(struct adapter *adapter, char *address)\r\n{\r\nstruct mcast_address *mcaddr, *mlist;\r\nmlist = adapter->mcastaddrs;\r\nwhile (mlist) {\r\nif (ether_addr_equal(mlist->address, address))\r\nreturn 0;\r\nmlist = mlist->next;\r\n}\r\nmcaddr = kmalloc(sizeof(struct mcast_address), GFP_ATOMIC);\r\nif (mcaddr == NULL)\r\nreturn 1;\r\nether_addr_copy(mcaddr->address, address);\r\nmcaddr->next = adapter->mcastaddrs;\r\nadapter->mcastaddrs = mcaddr;\r\nreturn 0;\r\n}\r\nstatic void slic_mcast_set_list(struct net_device *dev)\r\n{\r\nstruct adapter *adapter = netdev_priv(dev);\r\nint status = 0;\r\nchar *addresses;\r\nstruct netdev_hw_addr *ha;\r\nnetdev_for_each_mc_addr(ha, dev) {\r\naddresses = (char *)&ha->addr;\r\nstatus = slic_mcast_add_list(adapter, addresses);\r\nif (status != 0)\r\nbreak;\r\nslic_mcast_set_bit(adapter, addresses);\r\n}\r\nif (adapter->devflags_prev != dev->flags) {\r\nadapter->macopts = MAC_DIRECTED;\r\nif (dev->flags) {\r\nif (dev->flags & IFF_BROADCAST)\r\nadapter->macopts |= MAC_BCAST;\r\nif (dev->flags & IFF_PROMISC)\r\nadapter->macopts |= MAC_PROMISC;\r\nif (dev->flags & IFF_ALLMULTI)\r\nadapter->macopts |= MAC_ALLMCAST;\r\nif (dev->flags & IFF_MULTICAST)\r\nadapter->macopts |= MAC_MCAST;\r\n}\r\nadapter->devflags_prev = dev->flags;\r\nslic_config_set(adapter, true);\r\n} else {\r\nif (status == 0)\r\nslic_mcast_set_mask(adapter);\r\n}\r\n}\r\nstatic void slic_xmit_build_request(struct adapter *adapter,\r\nstruct slic_hostcmd *hcmd, struct sk_buff *skb)\r\n{\r\nstruct slic_host64_cmd *ihcmd;\r\nulong phys_addr;\r\nihcmd = &hcmd->cmd64;\r\nihcmd->flags = adapter->port << IHFLG_IFSHFT;\r\nihcmd->command = IHCMD_XMT_REQ;\r\nihcmd->u.slic_buffers.totlen = skb->len;\r\nphys_addr = pci_map_single(adapter->pcidev, skb->data, skb->len,\r\nPCI_DMA_TODEVICE);\r\nihcmd->u.slic_buffers.bufs[0].paddrl = SLIC_GET_ADDR_LOW(phys_addr);\r\nihcmd->u.slic_buffers.bufs[0].paddrh = SLIC_GET_ADDR_HIGH(phys_addr);\r\nihcmd->u.slic_buffers.bufs[0].length = skb->len;\r\n#if BITS_PER_LONG == 64\r\nhcmd->cmdsize = (u32)((((u64)&ihcmd->u.slic_buffers.bufs[1] -\r\n(u64)hcmd) + 31) >> 5);\r\n#else\r\nhcmd->cmdsize = (((u32)&ihcmd->u.slic_buffers.bufs[1] -\r\n(u32)hcmd) + 31) >> 5;\r\n#endif\r\n}\r\nstatic void slic_xmit_fail(struct adapter *adapter,\r\nstruct sk_buff *skb,\r\nvoid *cmd, u32 skbtype, u32 status)\r\n{\r\nif (adapter->xmitq_full)\r\nnetif_stop_queue(adapter->netdev);\r\nif ((cmd == NULL) && (status <= XMIT_FAIL_HOSTCMD_FAIL)) {\r\nswitch (status) {\r\ncase XMIT_FAIL_LINK_STATE:\r\ndev_err(&adapter->netdev->dev,\r\n"reject xmit skb[%p: %x] linkstate[%s] adapter[%s:%d] card[%s:%d]\n",\r\nskb, skb->pkt_type,\r\nSLIC_LINKSTATE(adapter->linkstate),\r\nSLIC_ADAPTER_STATE(adapter->state),\r\nadapter->state,\r\nSLIC_CARD_STATE(adapter->card->state),\r\nadapter->card->state);\r\nbreak;\r\ncase XMIT_FAIL_ZERO_LENGTH:\r\ndev_err(&adapter->netdev->dev,\r\n"xmit_start skb->len == 0 skb[%p] type[%x]\n",\r\nskb, skb->pkt_type);\r\nbreak;\r\ncase XMIT_FAIL_HOSTCMD_FAIL:\r\ndev_err(&adapter->netdev->dev,\r\n"xmit_start skb[%p] type[%x] No host commands available\n",\r\nskb, skb->pkt_type);\r\nbreak;\r\n}\r\n}\r\ndev_kfree_skb(skb);\r\nadapter->netdev->stats.tx_dropped++;\r\n}\r\nstatic void slic_rcv_handle_error(struct adapter *adapter,\r\nstruct slic_rcvbuf *rcvbuf)\r\n{\r\nstruct slic_hddr_wds *hdr = (struct slic_hddr_wds *)rcvbuf->data;\r\nstruct net_device *netdev = adapter->netdev;\r\nif (adapter->devid != SLIC_1GB_DEVICE_ID) {\r\nif (hdr->frame_status14 & VRHSTAT_802OE)\r\nadapter->if_events.oflow802++;\r\nif (hdr->frame_status14 & VRHSTAT_TPOFLO)\r\nadapter->if_events.Tprtoflow++;\r\nif (hdr->frame_status_b14 & VRHSTATB_802UE)\r\nadapter->if_events.uflow802++;\r\nif (hdr->frame_status_b14 & VRHSTATB_RCVE) {\r\nadapter->if_events.rcvearly++;\r\nnetdev->stats.rx_fifo_errors++;\r\n}\r\nif (hdr->frame_status_b14 & VRHSTATB_BUFF) {\r\nadapter->if_events.Bufov++;\r\nnetdev->stats.rx_over_errors++;\r\n}\r\nif (hdr->frame_status_b14 & VRHSTATB_CARRE) {\r\nadapter->if_events.Carre++;\r\nnetdev->stats.tx_carrier_errors++;\r\n}\r\nif (hdr->frame_status_b14 & VRHSTATB_LONGE)\r\nadapter->if_events.Longe++;\r\nif (hdr->frame_status_b14 & VRHSTATB_PREA)\r\nadapter->if_events.Invp++;\r\nif (hdr->frame_status_b14 & VRHSTATB_CRC) {\r\nadapter->if_events.Crc++;\r\nnetdev->stats.rx_crc_errors++;\r\n}\r\nif (hdr->frame_status_b14 & VRHSTATB_DRBL)\r\nadapter->if_events.Drbl++;\r\nif (hdr->frame_status_b14 & VRHSTATB_CODE)\r\nadapter->if_events.Code++;\r\nif (hdr->frame_status_b14 & VRHSTATB_TPCSUM)\r\nadapter->if_events.TpCsum++;\r\nif (hdr->frame_status_b14 & VRHSTATB_TPHLEN)\r\nadapter->if_events.TpHlen++;\r\nif (hdr->frame_status_b14 & VRHSTATB_IPCSUM)\r\nadapter->if_events.IpCsum++;\r\nif (hdr->frame_status_b14 & VRHSTATB_IPLERR)\r\nadapter->if_events.IpLen++;\r\nif (hdr->frame_status_b14 & VRHSTATB_IPHERR)\r\nadapter->if_events.IpHlen++;\r\n} else {\r\nif (hdr->frame_statusGB & VGBSTAT_XPERR) {\r\nu32 xerr = hdr->frame_statusGB >> VGBSTAT_XERRSHFT;\r\nif (xerr == VGBSTAT_XCSERR)\r\nadapter->if_events.TpCsum++;\r\nif (xerr == VGBSTAT_XUFLOW)\r\nadapter->if_events.Tprtoflow++;\r\nif (xerr == VGBSTAT_XHLEN)\r\nadapter->if_events.TpHlen++;\r\n}\r\nif (hdr->frame_statusGB & VGBSTAT_NETERR) {\r\nu32 nerr =\r\n(hdr->\r\nframe_statusGB >> VGBSTAT_NERRSHFT) &\r\nVGBSTAT_NERRMSK;\r\nif (nerr == VGBSTAT_NCSERR)\r\nadapter->if_events.IpCsum++;\r\nif (nerr == VGBSTAT_NUFLOW)\r\nadapter->if_events.IpLen++;\r\nif (nerr == VGBSTAT_NHLEN)\r\nadapter->if_events.IpHlen++;\r\n}\r\nif (hdr->frame_statusGB & VGBSTAT_LNKERR) {\r\nu32 lerr = hdr->frame_statusGB & VGBSTAT_LERRMSK;\r\nif (lerr == VGBSTAT_LDEARLY)\r\nadapter->if_events.rcvearly++;\r\nif (lerr == VGBSTAT_LBOFLO)\r\nadapter->if_events.Bufov++;\r\nif (lerr == VGBSTAT_LCODERR)\r\nadapter->if_events.Code++;\r\nif (lerr == VGBSTAT_LDBLNBL)\r\nadapter->if_events.Drbl++;\r\nif (lerr == VGBSTAT_LCRCERR)\r\nadapter->if_events.Crc++;\r\nif (lerr == VGBSTAT_LOFLO)\r\nadapter->if_events.oflow802++;\r\nif (lerr == VGBSTAT_LUFLO)\r\nadapter->if_events.uflow802++;\r\n}\r\n}\r\n}\r\nstatic void slic_rcv_handler(struct adapter *adapter)\r\n{\r\nstruct net_device *netdev = adapter->netdev;\r\nstruct sk_buff *skb;\r\nstruct slic_rcvbuf *rcvbuf;\r\nu32 frames = 0;\r\nwhile ((skb = slic_rcvqueue_getnext(adapter))) {\r\nu32 rx_bytes;\r\nrcvbuf = (struct slic_rcvbuf *)skb->head;\r\nadapter->card->events++;\r\nif (rcvbuf->status & IRHDDR_ERR) {\r\nadapter->rx_errors++;\r\nslic_rcv_handle_error(adapter, rcvbuf);\r\nslic_rcvqueue_reinsert(adapter, skb);\r\ncontinue;\r\n}\r\nif (!slic_mac_filter(adapter, (struct ether_header *)\r\nrcvbuf->data)) {\r\nslic_rcvqueue_reinsert(adapter, skb);\r\ncontinue;\r\n}\r\nskb_pull(skb, SLIC_RCVBUF_HEADSIZE);\r\nrx_bytes = (rcvbuf->length & IRHDDR_FLEN_MSK);\r\nskb_put(skb, rx_bytes);\r\nnetdev->stats.rx_packets++;\r\nnetdev->stats.rx_bytes += rx_bytes;\r\n#if SLIC_OFFLOAD_IP_CHECKSUM\r\nskb->ip_summed = CHECKSUM_UNNECESSARY;\r\n#endif\r\nskb->dev = adapter->netdev;\r\nskb->protocol = eth_type_trans(skb, skb->dev);\r\nnetif_rx(skb);\r\n++frames;\r\n#if SLIC_INTERRUPT_PROCESS_LIMIT\r\nif (frames >= SLIC_RCVQ_MAX_PROCESS_ISR) {\r\nadapter->rcv_interrupt_yields++;\r\nbreak;\r\n}\r\n#endif\r\n}\r\nadapter->max_isr_rcvs = max(adapter->max_isr_rcvs, frames);\r\n}\r\nstatic void slic_xmit_complete(struct adapter *adapter)\r\n{\r\nstruct slic_hostcmd *hcmd;\r\nstruct slic_rspbuf *rspbuf;\r\nu32 frames = 0;\r\nstruct slic_handle_word slic_handle_word;\r\ndo {\r\nrspbuf = slic_rspqueue_getnext(adapter);\r\nif (!rspbuf)\r\nbreak;\r\nadapter->xmit_completes++;\r\nadapter->card->events++;\r\nslic_handle_word.handle_token = rspbuf->hosthandle;\r\nhcmd =\r\nadapter->slic_handles[slic_handle_word.handle_index].\r\naddress;\r\nif (hcmd->type == SLIC_CMD_DUMB) {\r\nif (hcmd->skb)\r\ndev_kfree_skb_irq(hcmd->skb);\r\nslic_cmdq_putdone_irq(adapter, hcmd);\r\n}\r\nrspbuf->status = 0;\r\nrspbuf->hosthandle = 0;\r\nframes++;\r\n} while (1);\r\nadapter->max_isr_xmits = max(adapter->max_isr_xmits, frames);\r\n}\r\nstatic void slic_interrupt_card_up(u32 isr, struct adapter *adapter,\r\nstruct net_device *dev)\r\n{\r\nif (isr & ~ISR_IO) {\r\nif (isr & ISR_ERR) {\r\nadapter->error_interrupts++;\r\nif (isr & ISR_RMISS) {\r\nint count;\r\nint pre_count;\r\nint errors;\r\nstruct slic_rcvqueue *rcvq =\r\n&adapter->rcvqueue;\r\nadapter->error_rmiss_interrupts++;\r\nif (!rcvq->errors)\r\nrcv_count = rcvq->count;\r\npre_count = rcvq->count;\r\nerrors = rcvq->errors;\r\nwhile (rcvq->count < SLIC_RCVQ_FILLTHRESH) {\r\ncount = slic_rcvqueue_fill(adapter);\r\nif (!count)\r\nbreak;\r\n}\r\n} else if (isr & ISR_XDROP) {\r\ndev_err(&dev->dev,\r\n"isr & ISR_ERR [%x] ISR_XDROP\n",\r\nisr);\r\n} else {\r\ndev_err(&dev->dev,\r\n"isr & ISR_ERR [%x]\n",\r\nisr);\r\n}\r\n}\r\nif (isr & ISR_LEVENT) {\r\nadapter->linkevent_interrupts++;\r\nif (slic_link_event_handler(adapter))\r\nadapter->linkevent_interrupts--;\r\n}\r\nif ((isr & ISR_UPC) || (isr & ISR_UPCERR) ||\r\n(isr & ISR_UPCBSY)) {\r\nadapter->upr_interrupts++;\r\nslic_upr_request_complete(adapter, isr);\r\n}\r\n}\r\nif (isr & ISR_RCV) {\r\nadapter->rcv_interrupts++;\r\nslic_rcv_handler(adapter);\r\n}\r\nif (isr & ISR_CMD) {\r\nadapter->xmit_interrupts++;\r\nslic_xmit_complete(adapter);\r\n}\r\n}\r\nstatic irqreturn_t slic_interrupt(int irq, void *dev_id)\r\n{\r\nstruct net_device *dev = dev_id;\r\nstruct adapter *adapter = netdev_priv(dev);\r\nu32 isr;\r\nif ((adapter->pshmem) && (adapter->pshmem->isr)) {\r\nslic_reg32_write(&adapter->slic_regs->slic_icr,\r\nICR_INT_MASK, FLUSH);\r\nisr = adapter->isrcopy = adapter->pshmem->isr;\r\nadapter->pshmem->isr = 0;\r\nadapter->num_isrs++;\r\nswitch (adapter->card->state) {\r\ncase CARD_UP:\r\nslic_interrupt_card_up(isr, adapter, dev);\r\nbreak;\r\ncase CARD_DOWN:\r\nif ((isr & ISR_UPC) ||\r\n(isr & ISR_UPCERR) || (isr & ISR_UPCBSY)) {\r\nadapter->upr_interrupts++;\r\nslic_upr_request_complete(adapter, isr);\r\n}\r\nbreak;\r\n}\r\nadapter->isrcopy = 0;\r\nadapter->all_reg_writes += 2;\r\nadapter->isr_reg_writes++;\r\nslic_reg32_write(&adapter->slic_regs->slic_isr, 0, FLUSH);\r\n} else {\r\nadapter->false_interrupts++;\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic netdev_tx_t slic_xmit_start(struct sk_buff *skb, struct net_device *dev)\r\n{\r\nstruct sliccard *card;\r\nstruct adapter *adapter = netdev_priv(dev);\r\nstruct slic_hostcmd *hcmd = NULL;\r\nu32 status = 0;\r\nvoid *offloadcmd = NULL;\r\ncard = adapter->card;\r\nif ((adapter->linkstate != LINK_UP) ||\r\n(adapter->state != ADAPT_UP) || (card->state != CARD_UP)) {\r\nstatus = XMIT_FAIL_LINK_STATE;\r\ngoto xmit_fail;\r\n} else if (skb->len == 0) {\r\nstatus = XMIT_FAIL_ZERO_LENGTH;\r\ngoto xmit_fail;\r\n}\r\nhcmd = slic_cmdq_getfree(adapter);\r\nif (!hcmd) {\r\nadapter->xmitq_full = 1;\r\nstatus = XMIT_FAIL_HOSTCMD_FAIL;\r\ngoto xmit_fail;\r\n}\r\nhcmd->skb = skb;\r\nhcmd->busy = 1;\r\nhcmd->type = SLIC_CMD_DUMB;\r\nslic_xmit_build_request(adapter, hcmd, skb);\r\ndev->stats.tx_packets++;\r\ndev->stats.tx_bytes += skb->len;\r\n#ifdef DEBUG_DUMP\r\nif (adapter->kill_card) {\r\nstruct slic_host64_cmd ihcmd;\r\nihcmd = &hcmd->cmd64;\r\nihcmd->flags |= 0x40;\r\nadapter->kill_card = 0;\r\n}\r\n#endif\r\nif (hcmd->paddrh == 0) {\r\nslic_reg32_write(&adapter->slic_regs->slic_cbar,\r\n(hcmd->paddrl | hcmd->cmdsize), DONT_FLUSH);\r\n} else {\r\nslic_reg64_write(adapter, &adapter->slic_regs->slic_cbar64,\r\n(hcmd->paddrl | hcmd->cmdsize),\r\n&adapter->slic_regs->slic_addr_upper,\r\nhcmd->paddrh, DONT_FLUSH);\r\n}\r\nxmit_done:\r\nreturn NETDEV_TX_OK;\r\nxmit_fail:\r\nslic_xmit_fail(adapter, skb, offloadcmd, NORMAL_ETHFRAME, status);\r\ngoto xmit_done;\r\n}\r\nstatic void slic_adapter_freeresources(struct adapter *adapter)\r\n{\r\nslic_init_cleanup(adapter);\r\nadapter->error_interrupts = 0;\r\nadapter->rcv_interrupts = 0;\r\nadapter->xmit_interrupts = 0;\r\nadapter->linkevent_interrupts = 0;\r\nadapter->upr_interrupts = 0;\r\nadapter->num_isrs = 0;\r\nadapter->xmit_completes = 0;\r\nadapter->rcv_broadcasts = 0;\r\nadapter->rcv_multicasts = 0;\r\nadapter->rcv_unicasts = 0;\r\n}\r\nstatic int slic_adapter_allocresources(struct adapter *adapter,\r\nunsigned long *flags)\r\n{\r\nif (!adapter->intrregistered) {\r\nint retval;\r\nspin_unlock_irqrestore(&slic_global.driver_lock, *flags);\r\nretval = request_irq(adapter->netdev->irq,\r\n&slic_interrupt,\r\nIRQF_SHARED,\r\nadapter->netdev->name, adapter->netdev);\r\nspin_lock_irqsave(&slic_global.driver_lock, *flags);\r\nif (retval) {\r\ndev_err(&adapter->netdev->dev,\r\n"request_irq (%s) FAILED [%x]\n",\r\nadapter->netdev->name, retval);\r\nreturn retval;\r\n}\r\nadapter->intrregistered = 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int slic_if_init(struct adapter *adapter, unsigned long *flags)\r\n{\r\nstruct sliccard *card = adapter->card;\r\nstruct net_device *dev = adapter->netdev;\r\n__iomem struct slic_regs *slic_regs = adapter->slic_regs;\r\nstruct slic_shmem *pshmem;\r\nint rc;\r\nif (adapter->state != ADAPT_DOWN) {\r\ndev_err(&dev->dev, "%s: adapter->state != ADAPT_DOWN\n",\r\n__func__);\r\nrc = -EIO;\r\ngoto err;\r\n}\r\nadapter->devflags_prev = dev->flags;\r\nadapter->macopts = MAC_DIRECTED;\r\nif (dev->flags) {\r\nif (dev->flags & IFF_BROADCAST)\r\nadapter->macopts |= MAC_BCAST;\r\nif (dev->flags & IFF_PROMISC)\r\nadapter->macopts |= MAC_PROMISC;\r\nif (dev->flags & IFF_ALLMULTI)\r\nadapter->macopts |= MAC_ALLMCAST;\r\nif (dev->flags & IFF_MULTICAST)\r\nadapter->macopts |= MAC_MCAST;\r\n}\r\nrc = slic_adapter_allocresources(adapter, flags);\r\nif (rc) {\r\ndev_err(&dev->dev, "slic_adapter_allocresources FAILED %x\n",\r\nrc);\r\nslic_adapter_freeresources(adapter);\r\ngoto err;\r\n}\r\nif (!adapter->queues_initialized) {\r\nrc = slic_rspqueue_init(adapter);\r\nif (rc)\r\ngoto err;\r\nrc = slic_cmdq_init(adapter);\r\nif (rc)\r\ngoto err;\r\nrc = slic_rcvqueue_init(adapter);\r\nif (rc)\r\ngoto err;\r\nadapter->queues_initialized = 1;\r\n}\r\nslic_reg32_write(&slic_regs->slic_icr, ICR_INT_OFF, FLUSH);\r\nmdelay(1);\r\nif (!adapter->isp_initialized) {\r\nunsigned long flags;\r\npshmem = (struct slic_shmem *)(unsigned long)\r\nadapter->phys_shmem;\r\nspin_lock_irqsave(&adapter->bit64reglock, flags);\r\n#if BITS_PER_LONG == 64\r\nslic_reg32_write(&slic_regs->slic_addr_upper,\r\nSLIC_GET_ADDR_HIGH(&pshmem->isr), DONT_FLUSH);\r\nslic_reg32_write(&slic_regs->slic_isp,\r\nSLIC_GET_ADDR_LOW(&pshmem->isr), FLUSH);\r\n#else\r\nslic_reg32_write(&slic_regs->slic_addr_upper, 0, DONT_FLUSH);\r\nslic_reg32_write(&slic_regs->slic_isp, (u32)&pshmem->isr,\r\nFLUSH);\r\n#endif\r\nspin_unlock_irqrestore(&adapter->bit64reglock, flags);\r\nadapter->isp_initialized = 1;\r\n}\r\nadapter->state = ADAPT_UP;\r\nif (!card->loadtimerset) {\r\nsetup_timer(&card->loadtimer, &slic_timer_load_check,\r\n(ulong)card);\r\ncard->loadtimer.expires =\r\njiffies + (SLIC_LOADTIMER_PERIOD * HZ);\r\nadd_timer(&card->loadtimer);\r\ncard->loadtimerset = 1;\r\n}\r\nif (!adapter->pingtimerset) {\r\nsetup_timer(&adapter->pingtimer, &slic_timer_ping, (ulong)dev);\r\nadapter->pingtimer.expires =\r\njiffies + (PING_TIMER_INTERVAL * HZ);\r\nadd_timer(&adapter->pingtimer);\r\nadapter->pingtimerset = 1;\r\nadapter->card->pingstatus = ISR_PINGMASK;\r\n}\r\nadapter->isrcopy = 0;\r\nadapter->pshmem->isr = 0;\r\nslic_reg32_write(&slic_regs->slic_isr, 0, FLUSH);\r\nslic_reg32_write(&slic_regs->slic_icr, ICR_INT_ON, FLUSH);\r\nslic_link_config(adapter, LINK_AUTOSPEED, LINK_AUTOD);\r\nrc = slic_link_event_handler(adapter);\r\nif (rc) {\r\nslic_reg32_write(&slic_regs->slic_icr, ICR_INT_OFF, FLUSH);\r\nslic_reg32_write(&slic_regs->slic_isr, 0, FLUSH);\r\nif (adapter->pingtimerset) {\r\ndel_timer(&adapter->pingtimer);\r\nadapter->pingtimerset = 0;\r\n}\r\nif (card->loadtimerset) {\r\ndel_timer(&card->loadtimer);\r\ncard->loadtimerset = 0;\r\n}\r\nadapter->state = ADAPT_DOWN;\r\nslic_adapter_freeresources(adapter);\r\n}\r\nerr:\r\nreturn rc;\r\n}\r\nstatic int slic_entry_open(struct net_device *dev)\r\n{\r\nstruct adapter *adapter = netdev_priv(dev);\r\nstruct sliccard *card = adapter->card;\r\nunsigned long flags;\r\nint status;\r\nnetif_stop_queue(adapter->netdev);\r\nspin_lock_irqsave(&slic_global.driver_lock, flags);\r\nif (!adapter->activated) {\r\ncard->adapters_activated++;\r\nslic_global.num_slic_ports_active++;\r\nadapter->activated = 1;\r\n}\r\nstatus = slic_if_init(adapter, &flags);\r\nif (status != 0) {\r\nif (adapter->activated) {\r\ncard->adapters_activated--;\r\nslic_global.num_slic_ports_active--;\r\nadapter->activated = 0;\r\n}\r\ngoto spin_unlock;\r\n}\r\nif (!card->master)\r\ncard->master = adapter;\r\nspin_unlock:\r\nspin_unlock_irqrestore(&slic_global.driver_lock, flags);\r\nreturn status;\r\n}\r\nstatic void slic_card_cleanup(struct sliccard *card)\r\n{\r\nif (card->loadtimerset) {\r\ncard->loadtimerset = 0;\r\ndel_timer_sync(&card->loadtimer);\r\n}\r\nkfree(card);\r\n}\r\nstatic void slic_entry_remove(struct pci_dev *pcidev)\r\n{\r\nstruct net_device *dev = pci_get_drvdata(pcidev);\r\nstruct adapter *adapter = netdev_priv(dev);\r\nstruct sliccard *card;\r\nstruct mcast_address *mcaddr, *mlist;\r\nunregister_netdev(dev);\r\nslic_adapter_freeresources(adapter);\r\nslic_unmap_mmio_space(adapter);\r\nmlist = adapter->mcastaddrs;\r\nwhile (mlist) {\r\nmcaddr = mlist;\r\nmlist = mlist->next;\r\nkfree(mcaddr);\r\n}\r\ncard = adapter->card;\r\ncard->adapters_allocated--;\r\nadapter->allocated = 0;\r\nif (!card->adapters_allocated) {\r\nstruct sliccard *curr_card = slic_global.slic_card;\r\nif (curr_card == card) {\r\nslic_global.slic_card = card->next;\r\n} else {\r\nwhile (curr_card->next != card)\r\ncurr_card = curr_card->next;\r\ncurr_card->next = card->next;\r\n}\r\nslic_global.num_slic_cards--;\r\nslic_card_cleanup(card);\r\n}\r\nfree_netdev(dev);\r\npci_release_regions(pcidev);\r\npci_disable_device(pcidev);\r\n}\r\nstatic int slic_entry_halt(struct net_device *dev)\r\n{\r\nstruct adapter *adapter = netdev_priv(dev);\r\nstruct sliccard *card = adapter->card;\r\n__iomem struct slic_regs *slic_regs = adapter->slic_regs;\r\nunsigned long flags;\r\nspin_lock_irqsave(&slic_global.driver_lock, flags);\r\nnetif_stop_queue(adapter->netdev);\r\nadapter->state = ADAPT_DOWN;\r\nadapter->linkstate = LINK_DOWN;\r\nadapter->upr_list = NULL;\r\nadapter->upr_busy = 0;\r\nadapter->devflags_prev = 0;\r\nslic_reg32_write(&slic_regs->slic_icr, ICR_INT_OFF, FLUSH);\r\nadapter->all_reg_writes++;\r\nadapter->icr_reg_writes++;\r\nslic_config_clear(adapter);\r\nif (adapter->activated) {\r\ncard->adapters_activated--;\r\nslic_global.num_slic_ports_active--;\r\nadapter->activated = 0;\r\n}\r\n#ifdef AUTOMATIC_RESET\r\nslic_reg32_write(&slic_regs->slic_reset_iface, 0, FLUSH);\r\n#endif\r\nslic_cmdq_reset(adapter);\r\n#ifdef AUTOMATIC_RESET\r\nif (!card->adapters_activated)\r\nslic_card_init(card, adapter);\r\n#endif\r\nspin_unlock_irqrestore(&slic_global.driver_lock, flags);\r\nreturn 0;\r\n}\r\nstatic struct net_device_stats *slic_get_stats(struct net_device *dev)\r\n{\r\nstruct adapter *adapter = netdev_priv(dev);\r\ndev->stats.collisions = adapter->slic_stats.iface.xmit_collisions;\r\ndev->stats.rx_errors = adapter->slic_stats.iface.rcv_errors;\r\ndev->stats.tx_errors = adapter->slic_stats.iface.xmt_errors;\r\ndev->stats.rx_missed_errors = adapter->slic_stats.iface.rcv_discards;\r\ndev->stats.tx_heartbeat_errors = 0;\r\ndev->stats.tx_aborted_errors = 0;\r\ndev->stats.tx_window_errors = 0;\r\ndev->stats.tx_fifo_errors = 0;\r\ndev->stats.rx_frame_errors = 0;\r\ndev->stats.rx_length_errors = 0;\r\nreturn &dev->stats;\r\n}\r\nstatic int slic_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)\r\n{\r\nstruct adapter *adapter = netdev_priv(dev);\r\nstruct ethtool_cmd edata;\r\nstruct ethtool_cmd ecmd;\r\nu32 data[7];\r\nu32 intagg;\r\nswitch (cmd) {\r\ncase SIOCSLICSETINTAGG:\r\nif (copy_from_user(data, rq->ifr_data, 28))\r\nreturn -EFAULT;\r\nintagg = data[0];\r\ndev_err(&dev->dev, "set interrupt aggregation to %d\n",\r\nintagg);\r\nslic_intagg_set(adapter, intagg);\r\nreturn 0;\r\ncase SIOCETHTOOL:\r\nif (copy_from_user(&ecmd, rq->ifr_data, sizeof(ecmd)))\r\nreturn -EFAULT;\r\nif (ecmd.cmd == ETHTOOL_GSET) {\r\nmemset(&edata, 0, sizeof(edata));\r\nedata.supported = (SUPPORTED_10baseT_Half |\r\nSUPPORTED_10baseT_Full |\r\nSUPPORTED_100baseT_Half |\r\nSUPPORTED_100baseT_Full |\r\nSUPPORTED_Autoneg | SUPPORTED_MII);\r\nedata.port = PORT_MII;\r\nedata.transceiver = XCVR_INTERNAL;\r\nedata.phy_address = 0;\r\nif (adapter->linkspeed == LINK_100MB)\r\nedata.speed = SPEED_100;\r\nelse if (adapter->linkspeed == LINK_10MB)\r\nedata.speed = SPEED_10;\r\nelse\r\nedata.speed = 0;\r\nif (adapter->linkduplex == LINK_FULLD)\r\nedata.duplex = DUPLEX_FULL;\r\nelse\r\nedata.duplex = DUPLEX_HALF;\r\nedata.autoneg = AUTONEG_ENABLE;\r\nedata.maxtxpkt = 1;\r\nedata.maxrxpkt = 1;\r\nif (copy_to_user(rq->ifr_data, &edata, sizeof(edata)))\r\nreturn -EFAULT;\r\n} else if (ecmd.cmd == ETHTOOL_SSET) {\r\nif (!capable(CAP_NET_ADMIN))\r\nreturn -EPERM;\r\nif (adapter->linkspeed == LINK_100MB)\r\nedata.speed = SPEED_100;\r\nelse if (adapter->linkspeed == LINK_10MB)\r\nedata.speed = SPEED_10;\r\nelse\r\nedata.speed = 0;\r\nif (adapter->linkduplex == LINK_FULLD)\r\nedata.duplex = DUPLEX_FULL;\r\nelse\r\nedata.duplex = DUPLEX_HALF;\r\nedata.autoneg = AUTONEG_ENABLE;\r\nedata.maxtxpkt = 1;\r\nedata.maxrxpkt = 1;\r\nif ((ecmd.speed != edata.speed) ||\r\n(ecmd.duplex != edata.duplex)) {\r\nu32 speed;\r\nu32 duplex;\r\nif (ecmd.speed == SPEED_10)\r\nspeed = 0;\r\nelse\r\nspeed = PCR_SPEED_100;\r\nif (ecmd.duplex == DUPLEX_FULL)\r\nduplex = PCR_DUPLEX_FULL;\r\nelse\r\nduplex = 0;\r\nslic_link_config(adapter, speed, duplex);\r\nif (slic_link_event_handler(adapter))\r\nreturn -EFAULT;\r\n}\r\n}\r\nreturn 0;\r\ndefault:\r\nreturn -EOPNOTSUPP;\r\n}\r\n}\r\nstatic void slic_config_pci(struct pci_dev *pcidev)\r\n{\r\nu16 pci_command;\r\nu16 new_command;\r\npci_read_config_word(pcidev, PCI_COMMAND, &pci_command);\r\nnew_command = pci_command | PCI_COMMAND_MASTER\r\n| PCI_COMMAND_MEMORY\r\n| PCI_COMMAND_INVALIDATE\r\n| PCI_COMMAND_PARITY | PCI_COMMAND_SERR | PCI_COMMAND_FAST_BACK;\r\nif (pci_command != new_command)\r\npci_write_config_word(pcidev, PCI_COMMAND, new_command);\r\n}\r\nstatic int slic_card_init(struct sliccard *card, struct adapter *adapter)\r\n{\r\n__iomem struct slic_regs *slic_regs = adapter->slic_regs;\r\nstruct slic_eeprom *peeprom;\r\nstruct oslic_eeprom *pOeeprom;\r\ndma_addr_t phys_config;\r\nu32 phys_configh;\r\nu32 phys_configl;\r\nu32 i = 0;\r\nstruct slic_shmem *pshmem;\r\nint status;\r\nuint macaddrs = card->card_size;\r\nushort eecodesize;\r\nushort dramsize;\r\nushort ee_chksum;\r\nushort calc_chksum;\r\nstruct slic_config_mac *pmac;\r\nunsigned char fruformat;\r\nunsigned char oemfruformat;\r\nstruct atk_fru *patkfru;\r\nunion oemfru *poemfru;\r\nunsigned long flags;\r\nslic_soft_reset(adapter);\r\nstatus = slic_card_download(adapter);\r\nif (status)\r\nreturn status;\r\nif (!card->config_set) {\r\npeeprom = pci_alloc_consistent(adapter->pcidev,\r\nsizeof(struct slic_eeprom),\r\n&phys_config);\r\nphys_configl = SLIC_GET_ADDR_LOW(phys_config);\r\nphys_configh = SLIC_GET_ADDR_HIGH(phys_config);\r\nif (!peeprom) {\r\ndev_err(&adapter->pcidev->dev,\r\n"Failed to allocate DMA memory for EEPROM.\n");\r\nreturn -ENOMEM;\r\n}\r\nmemset(peeprom, 0, sizeof(struct slic_eeprom));\r\nslic_reg32_write(&slic_regs->slic_icr, ICR_INT_OFF, FLUSH);\r\nmdelay(1);\r\npshmem = (struct slic_shmem *)(unsigned long)\r\nadapter->phys_shmem;\r\nspin_lock_irqsave(&adapter->bit64reglock, flags);\r\nslic_reg32_write(&slic_regs->slic_addr_upper,\r\nSLIC_GET_ADDR_HIGH(&pshmem->isr), DONT_FLUSH);\r\nslic_reg32_write(&slic_regs->slic_isp,\r\nSLIC_GET_ADDR_LOW(&pshmem->isr), FLUSH);\r\nspin_unlock_irqrestore(&adapter->bit64reglock, flags);\r\nstatus = slic_config_get(adapter, phys_configl, phys_configh);\r\nif (status) {\r\ndev_err(&adapter->pcidev->dev,\r\n"Failed to fetch config data from device.\n");\r\ngoto card_init_err;\r\n}\r\nfor (;;) {\r\nif (adapter->pshmem->isr) {\r\nif (adapter->pshmem->isr & ISR_UPC) {\r\nadapter->pshmem->isr = 0;\r\nslic_reg64_write(adapter,\r\n&slic_regs->slic_isp, 0,\r\n&slic_regs->slic_addr_upper,\r\n0, FLUSH);\r\nslic_reg32_write(&slic_regs->slic_isr,\r\n0, FLUSH);\r\nslic_upr_request_complete(adapter, 0);\r\nbreak;\r\n}\r\nadapter->pshmem->isr = 0;\r\nslic_reg32_write(&slic_regs->slic_isr,\r\n0, FLUSH);\r\n} else {\r\nmdelay(1);\r\ni++;\r\nif (i > 5000) {\r\ndev_err(&adapter->pcidev->dev,\r\n"Fetch of config data timed out.\n");\r\nslic_reg64_write(adapter,\r\n&slic_regs->slic_isp, 0,\r\n&slic_regs->slic_addr_upper,\r\n0, FLUSH);\r\nstatus = -EINVAL;\r\ngoto card_init_err;\r\n}\r\n}\r\n}\r\nswitch (adapter->devid) {\r\ncase SLIC_2GB_DEVICE_ID:\r\npOeeprom = (struct oslic_eeprom *)peeprom;\r\neecodesize = pOeeprom->EecodeSize;\r\ndramsize = pOeeprom->DramSize;\r\npmac = pOeeprom->MacInfo;\r\nfruformat = pOeeprom->FruFormat;\r\npatkfru = &pOeeprom->AtkFru;\r\noemfruformat = pOeeprom->OemFruFormat;\r\npoemfru = &pOeeprom->OemFru;\r\nmacaddrs = 2;\r\nbreak;\r\ndefault:\r\neecodesize = peeprom->EecodeSize;\r\ndramsize = peeprom->DramSize;\r\npmac = peeprom->u2.mac.MacInfo;\r\nfruformat = peeprom->FruFormat;\r\npatkfru = &peeprom->AtkFru;\r\noemfruformat = peeprom->OemFruFormat;\r\npoemfru = &peeprom->OemFru;\r\nbreak;\r\n}\r\ncard->config.EepromValid = false;\r\nif ((eecodesize <= MAX_EECODE_SIZE) &&\r\n(eecodesize >= MIN_EECODE_SIZE)) {\r\nee_chksum =\r\n*(u16 *)((char *)peeprom + (eecodesize - 2));\r\ncalc_chksum = slic_eeprom_cksum(peeprom,\r\neecodesize - 2);\r\nif (ee_chksum == calc_chksum)\r\ncard->config.EepromValid = true;\r\n}\r\ncard->config.DramSize = dramsize;\r\nfor (i = 0; i < macaddrs; i++) {\r\nmemcpy(&card->config.MacInfo[i],\r\n&pmac[i], sizeof(struct slic_config_mac));\r\n}\r\ncard->config.FruFormat = fruformat;\r\nmemcpy(&card->config.AtkFru, patkfru,\r\nsizeof(struct atk_fru));\r\npci_free_consistent(adapter->pcidev,\r\nsizeof(struct slic_eeprom),\r\npeeprom, phys_config);\r\nif (!card->config.EepromValid) {\r\nslic_reg64_write(adapter, &slic_regs->slic_isp, 0,\r\n&slic_regs->slic_addr_upper,\r\n0, FLUSH);\r\ndev_err(&adapter->pcidev->dev, "EEPROM invalid.\n");\r\nreturn -EINVAL;\r\n}\r\ncard->config_set = 1;\r\n}\r\nstatus = slic_card_download_gbrcv(adapter);\r\nif (status)\r\nreturn status;\r\nif (slic_global.dynamic_intagg)\r\nslic_intagg_set(adapter, 0);\r\nelse\r\nslic_intagg_set(adapter, intagg_delay);\r\ncard->pingstatus = ISR_PINGMASK;\r\ncard->state = CARD_UP;\r\ncard->reset_in_progress = 0;\r\nreturn 0;\r\ncard_init_err:\r\npci_free_consistent(adapter->pcidev, sizeof(struct slic_eeprom),\r\npeeprom, phys_config);\r\nreturn status;\r\n}\r\nstatic void slic_init_driver(void)\r\n{\r\nif (slic_first_init) {\r\nslic_first_init = 0;\r\nspin_lock_init(&slic_global.driver_lock);\r\n}\r\n}\r\nstatic void slic_init_adapter(struct net_device *netdev,\r\nstruct pci_dev *pcidev,\r\nconst struct pci_device_id *pci_tbl_entry,\r\nvoid __iomem *memaddr, int chip_idx)\r\n{\r\nushort index;\r\nstruct slic_handle *pslic_handle;\r\nstruct adapter *adapter = netdev_priv(netdev);\r\nadapter->vendid = pci_tbl_entry->vendor;\r\nadapter->devid = pci_tbl_entry->device;\r\nadapter->subsysid = pci_tbl_entry->subdevice;\r\nadapter->busnumber = pcidev->bus->number;\r\nadapter->slotnumber = ((pcidev->devfn >> 3) & 0x1F);\r\nadapter->functionnumber = (pcidev->devfn & 0x7);\r\nadapter->slic_regs = memaddr;\r\nadapter->irq = pcidev->irq;\r\nadapter->chipid = chip_idx;\r\nadapter->port = 0;\r\nadapter->cardindex = adapter->port;\r\nspin_lock_init(&adapter->upr_lock);\r\nspin_lock_init(&adapter->bit64reglock);\r\nspin_lock_init(&adapter->adapter_lock);\r\nspin_lock_init(&adapter->reset_lock);\r\nspin_lock_init(&adapter->handle_lock);\r\nadapter->card_size = 1;\r\nfor (index = 1, pslic_handle = &adapter->slic_handles[1];\r\nindex < SLIC_CMDQ_MAXCMDS; index++, pslic_handle++) {\r\npslic_handle->token.handle_index = index;\r\npslic_handle->type = SLIC_HANDLE_FREE;\r\npslic_handle->next = adapter->pfree_slic_handles;\r\nadapter->pfree_slic_handles = pslic_handle;\r\n}\r\nadapter->pshmem = (struct slic_shmem *)\r\npci_alloc_consistent(adapter->pcidev,\r\nsizeof(struct slic_shmem),\r\n&adapter->\r\nphys_shmem);\r\nif (adapter->pshmem)\r\nmemset(adapter->pshmem, 0, sizeof(struct slic_shmem));\r\n}\r\nstatic u32 slic_card_locate(struct adapter *adapter)\r\n{\r\nstruct sliccard *card = slic_global.slic_card;\r\nstruct physcard *physcard = slic_global.phys_card;\r\nushort card_hostid;\r\nu16 __iomem *hostid_reg;\r\nuint i;\r\nuint rdhostid_offset = 0;\r\nswitch (adapter->devid) {\r\ncase SLIC_2GB_DEVICE_ID:\r\nrdhostid_offset = SLIC_RDHOSTID_2GB;\r\nbreak;\r\ncase SLIC_1GB_DEVICE_ID:\r\nrdhostid_offset = SLIC_RDHOSTID_1GB;\r\nbreak;\r\ndefault:\r\nreturn -ENODEV;\r\n}\r\nhostid_reg =\r\n(u16 __iomem *)(((u8 __iomem *)(adapter->slic_regs)) +\r\nrdhostid_offset);\r\ncard_hostid = (ushort)readw(hostid_reg);\r\nif (card_hostid == SLIC_HOSTID_DEFAULT) {\r\ncard = kzalloc(sizeof(struct sliccard), GFP_KERNEL);\r\nif (card == NULL)\r\nreturn -ENOMEM;\r\ncard->next = slic_global.slic_card;\r\nslic_global.slic_card = card;\r\ncard->busnumber = adapter->busnumber;\r\ncard->slotnumber = adapter->slotnumber;\r\nfor (i = 0; i < SLIC_MAX_CARDS; i++) {\r\nif (slic_global.cardnuminuse[i] == 0) {\r\nslic_global.cardnuminuse[i] = 1;\r\ncard->cardnum = i;\r\nbreak;\r\n}\r\n}\r\nslic_global.num_slic_cards++;\r\n} else {\r\nwhile (card) {\r\nif (card->cardnum == card_hostid)\r\nbreak;\r\ncard = card->next;\r\n}\r\n}\r\nif (!card)\r\nreturn -ENXIO;\r\nif (!card->adapter[adapter->port]) {\r\ncard->adapter[adapter->port] = adapter;\r\nadapter->card = card;\r\n}\r\ncard->card_size = 1;\r\nwhile (physcard) {\r\nfor (i = 0; i < SLIC_MAX_PORTS; i++) {\r\nif (physcard->adapter[i])\r\nbreak;\r\n}\r\nif (i == SLIC_MAX_PORTS)\r\nbreak;\r\nif (physcard->adapter[i]->slotnumber == adapter->slotnumber)\r\nbreak;\r\nphyscard = physcard->next;\r\n}\r\nif (!physcard) {\r\nphyscard = kzalloc(sizeof(struct physcard), GFP_ATOMIC);\r\nif (!physcard) {\r\nif (card_hostid == SLIC_HOSTID_DEFAULT)\r\nkfree(card);\r\nreturn -ENOMEM;\r\n}\r\nphyscard->next = slic_global.phys_card;\r\nslic_global.phys_card = physcard;\r\nphyscard->adapters_allocd = 1;\r\n} else {\r\nphyscard->adapters_allocd++;\r\n}\r\nadapter->physport = physcard->adapters_allocd - 1;\r\nphyscard->adapter[adapter->physport] = adapter;\r\nadapter->physcard = physcard;\r\nreturn 0;\r\n}\r\nstatic int slic_entry_probe(struct pci_dev *pcidev,\r\nconst struct pci_device_id *pci_tbl_entry)\r\n{\r\nstatic int cards_found;\r\nstatic int did_version;\r\nint err = -ENODEV;\r\nstruct net_device *netdev;\r\nstruct adapter *adapter;\r\nvoid __iomem *memmapped_ioaddr = NULL;\r\nulong mmio_start = 0;\r\nulong mmio_len = 0;\r\nstruct sliccard *card = NULL;\r\nint pci_using_dac = 0;\r\nslic_global.dynamic_intagg = dynamic_intagg;\r\nerr = pci_enable_device(pcidev);\r\nif (err)\r\nreturn err;\r\nif (did_version++ == 0) {\r\ndev_info(&pcidev->dev, "%s\n", slic_banner);\r\ndev_info(&pcidev->dev, "%s\n", slic_proc_version);\r\n}\r\nif (!pci_set_dma_mask(pcidev, DMA_BIT_MASK(64))) {\r\npci_using_dac = 1;\r\nerr = pci_set_consistent_dma_mask(pcidev, DMA_BIT_MASK(64));\r\nif (err) {\r\ndev_err(&pcidev->dev, "unable to obtain 64-bit DMA for consistent allocations\n");\r\ngoto err_out_disable_pci;\r\n}\r\n} else {\r\nerr = pci_set_dma_mask(pcidev, DMA_BIT_MASK(32));\r\nif (err) {\r\ndev_err(&pcidev->dev, "no usable DMA configuration\n");\r\ngoto err_out_disable_pci;\r\n}\r\npci_using_dac = 0;\r\npci_set_consistent_dma_mask(pcidev, DMA_BIT_MASK(32));\r\n}\r\nerr = pci_request_regions(pcidev, DRV_NAME);\r\nif (err) {\r\ndev_err(&pcidev->dev, "can't obtain PCI resources\n");\r\ngoto err_out_disable_pci;\r\n}\r\npci_set_master(pcidev);\r\nnetdev = alloc_etherdev(sizeof(struct adapter));\r\nif (!netdev) {\r\nerr = -ENOMEM;\r\ngoto err_out_exit_slic_probe;\r\n}\r\nSET_NETDEV_DEV(netdev, &pcidev->dev);\r\npci_set_drvdata(pcidev, netdev);\r\nadapter = netdev_priv(netdev);\r\nadapter->netdev = netdev;\r\nadapter->pcidev = pcidev;\r\nif (pci_using_dac)\r\nnetdev->features |= NETIF_F_HIGHDMA;\r\nmmio_start = pci_resource_start(pcidev, 0);\r\nmmio_len = pci_resource_len(pcidev, 0);\r\nmemmapped_ioaddr = ioremap(mmio_start, mmio_len);\r\nif (!memmapped_ioaddr) {\r\ndev_err(&pcidev->dev, "cannot remap MMIO region %lx @ %lx\n",\r\nmmio_len, mmio_start);\r\nerr = -ENOMEM;\r\ngoto err_out_free_netdev;\r\n}\r\nslic_config_pci(pcidev);\r\nslic_init_driver();\r\nslic_init_adapter(netdev,\r\npcidev, pci_tbl_entry, memmapped_ioaddr, cards_found);\r\nerr = slic_card_locate(adapter);\r\nif (err) {\r\ndev_err(&pcidev->dev, "cannot locate card\n");\r\ngoto err_out_unmap;\r\n}\r\ncard = adapter->card;\r\nif (!adapter->allocated) {\r\ncard->adapters_allocated++;\r\nadapter->allocated = 1;\r\n}\r\nerr = slic_card_init(card, adapter);\r\nif (err)\r\ngoto err_out_unmap;\r\nslic_adapter_set_hwaddr(adapter);\r\nnetdev->base_addr = (unsigned long)memmapped_ioaddr;\r\nnetdev->irq = adapter->irq;\r\nnetdev->netdev_ops = &slic_netdev_ops;\r\nstrcpy(netdev->name, "eth%d");\r\nerr = register_netdev(netdev);\r\nif (err) {\r\ndev_err(&pcidev->dev, "Cannot register net device, aborting.\n");\r\ngoto err_out_unmap;\r\n}\r\ncards_found++;\r\nreturn 0;\r\nerr_out_unmap:\r\niounmap(memmapped_ioaddr);\r\nerr_out_free_netdev:\r\nfree_netdev(netdev);\r\nerr_out_exit_slic_probe:\r\npci_release_regions(pcidev);\r\nerr_out_disable_pci:\r\npci_disable_device(pcidev);\r\nreturn err;\r\n}\r\nstatic int __init slic_module_init(void)\r\n{\r\nslic_init_driver();\r\nreturn pci_register_driver(&slic_driver);\r\n}\r\nstatic void __exit slic_module_cleanup(void)\r\n{\r\npci_unregister_driver(&slic_driver);\r\n}
