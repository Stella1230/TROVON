static void rtl8187_iowrite_async_cb(struct urb *urb)\r\n{\r\nkfree(urb->context);\r\n}\r\nstatic void rtl8187_iowrite_async(struct rtl8187_priv *priv, __le16 addr,\r\nvoid *data, u16 len)\r\n{\r\nstruct usb_ctrlrequest *dr;\r\nstruct urb *urb;\r\nstruct rtl8187_async_write_data {\r\nu8 data[4];\r\nstruct usb_ctrlrequest dr;\r\n} *buf;\r\nint rc;\r\nbuf = kmalloc(sizeof(*buf), GFP_ATOMIC);\r\nif (!buf)\r\nreturn;\r\nurb = usb_alloc_urb(0, GFP_ATOMIC);\r\nif (!urb) {\r\nkfree(buf);\r\nreturn;\r\n}\r\ndr = &buf->dr;\r\ndr->bRequestType = RTL8187_REQT_WRITE;\r\ndr->bRequest = RTL8187_REQ_SET_REG;\r\ndr->wValue = addr;\r\ndr->wIndex = 0;\r\ndr->wLength = cpu_to_le16(len);\r\nmemcpy(buf, data, len);\r\nusb_fill_control_urb(urb, priv->udev, usb_sndctrlpipe(priv->udev, 0),\r\n(unsigned char *)dr, buf, len,\r\nrtl8187_iowrite_async_cb, buf);\r\nusb_anchor_urb(urb, &priv->anchored);\r\nrc = usb_submit_urb(urb, GFP_ATOMIC);\r\nif (rc < 0) {\r\nkfree(buf);\r\nusb_unanchor_urb(urb);\r\n}\r\nusb_free_urb(urb);\r\n}\r\nstatic inline void rtl818x_iowrite32_async(struct rtl8187_priv *priv,\r\n__le32 *addr, u32 val)\r\n{\r\n__le32 buf = cpu_to_le32(val);\r\nrtl8187_iowrite_async(priv, cpu_to_le16((unsigned long)addr),\r\n&buf, sizeof(buf));\r\n}\r\nvoid rtl8187_write_phy(struct ieee80211_hw *dev, u8 addr, u32 data)\r\n{\r\nstruct rtl8187_priv *priv = dev->priv;\r\ndata <<= 8;\r\ndata |= addr | 0x80;\r\nrtl818x_iowrite8(priv, &priv->map->PHY[3], (data >> 24) & 0xFF);\r\nrtl818x_iowrite8(priv, &priv->map->PHY[2], (data >> 16) & 0xFF);\r\nrtl818x_iowrite8(priv, &priv->map->PHY[1], (data >> 8) & 0xFF);\r\nrtl818x_iowrite8(priv, &priv->map->PHY[0], data & 0xFF);\r\n}\r\nstatic void rtl8187_tx_cb(struct urb *urb)\r\n{\r\nstruct sk_buff *skb = (struct sk_buff *)urb->context;\r\nstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\r\nstruct ieee80211_hw *hw = info->rate_driver_data[0];\r\nstruct rtl8187_priv *priv = hw->priv;\r\nskb_pull(skb, priv->is_rtl8187b ? sizeof(struct rtl8187b_tx_hdr) :\r\nsizeof(struct rtl8187_tx_hdr));\r\nieee80211_tx_info_clear_status(info);\r\nif (!(urb->status) && !(info->flags & IEEE80211_TX_CTL_NO_ACK)) {\r\nif (priv->is_rtl8187b) {\r\nskb_queue_tail(&priv->b_tx_status.queue, skb);\r\nwhile (skb_queue_len(&priv->b_tx_status.queue) > 5) {\r\nstruct sk_buff *old_skb;\r\ndev_dbg(&priv->udev->dev,\r\n"transmit status queue full\n");\r\nold_skb = skb_dequeue(&priv->b_tx_status.queue);\r\nieee80211_tx_status_irqsafe(hw, old_skb);\r\n}\r\nreturn;\r\n} else {\r\ninfo->flags |= IEEE80211_TX_STAT_ACK;\r\n}\r\n}\r\nif (priv->is_rtl8187b)\r\nieee80211_tx_status_irqsafe(hw, skb);\r\nelse {\r\nskb_queue_tail(&priv->b_tx_status.queue, skb);\r\nieee80211_queue_delayed_work(hw, &priv->work, 0);\r\n}\r\n}\r\nstatic void rtl8187_tx(struct ieee80211_hw *dev,\r\nstruct ieee80211_tx_control *control,\r\nstruct sk_buff *skb)\r\n{\r\nstruct rtl8187_priv *priv = dev->priv;\r\nstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\r\nstruct ieee80211_hdr *tx_hdr = (struct ieee80211_hdr *)(skb->data);\r\nunsigned int ep;\r\nvoid *buf;\r\nstruct urb *urb;\r\n__le16 rts_dur = 0;\r\nu32 flags;\r\nint rc;\r\nurb = usb_alloc_urb(0, GFP_ATOMIC);\r\nif (!urb) {\r\nkfree_skb(skb);\r\nreturn;\r\n}\r\nflags = skb->len;\r\nflags |= RTL818X_TX_DESC_FLAG_NO_ENC;\r\nflags |= ieee80211_get_tx_rate(dev, info)->hw_value << 24;\r\nif (ieee80211_has_morefrags(tx_hdr->frame_control))\r\nflags |= RTL818X_TX_DESC_FLAG_MOREFRAG;\r\nif (info->control.rates[0].flags & IEEE80211_TX_RC_USE_RTS_CTS) {\r\nflags |= RTL818X_TX_DESC_FLAG_RTS;\r\nflags |= ieee80211_get_rts_cts_rate(dev, info)->hw_value << 19;\r\nrts_dur = ieee80211_rts_duration(dev, priv->vif,\r\nskb->len, info);\r\n} else if (info->control.rates[0].flags & IEEE80211_TX_RC_USE_CTS_PROTECT) {\r\nflags |= RTL818X_TX_DESC_FLAG_RTS | RTL818X_TX_DESC_FLAG_CTS;\r\nflags |= ieee80211_get_rts_cts_rate(dev, info)->hw_value << 19;\r\nrts_dur = ieee80211_ctstoself_duration(dev, priv->vif,\r\nskb->len, info);\r\n}\r\nif (info->flags & IEEE80211_TX_CTL_ASSIGN_SEQ) {\r\nif (info->flags & IEEE80211_TX_CTL_FIRST_FRAGMENT)\r\npriv->seqno += 0x10;\r\ntx_hdr->seq_ctrl &= cpu_to_le16(IEEE80211_SCTL_FRAG);\r\ntx_hdr->seq_ctrl |= cpu_to_le16(priv->seqno);\r\n}\r\nif (!priv->is_rtl8187b) {\r\nstruct rtl8187_tx_hdr *hdr =\r\n(struct rtl8187_tx_hdr *)skb_push(skb, sizeof(*hdr));\r\nhdr->flags = cpu_to_le32(flags);\r\nhdr->len = 0;\r\nhdr->rts_duration = rts_dur;\r\nhdr->retry = cpu_to_le32((info->control.rates[0].count - 1) << 8);\r\nbuf = hdr;\r\nep = 2;\r\n} else {\r\nunsigned int epmap[4] = { 6, 7, 5, 4 };\r\nu16 fc = le16_to_cpu(tx_hdr->frame_control);\r\nstruct rtl8187b_tx_hdr *hdr =\r\n(struct rtl8187b_tx_hdr *)skb_push(skb, sizeof(*hdr));\r\nstruct ieee80211_rate *txrate =\r\nieee80211_get_tx_rate(dev, info);\r\nmemset(hdr, 0, sizeof(*hdr));\r\nhdr->flags = cpu_to_le32(flags);\r\nhdr->rts_duration = rts_dur;\r\nhdr->retry = cpu_to_le32((info->control.rates[0].count - 1) << 8);\r\nhdr->tx_duration =\r\nieee80211_generic_frame_duration(dev, priv->vif,\r\ninfo->band,\r\nskb->len, txrate);\r\nbuf = hdr;\r\nif ((fc & IEEE80211_FCTL_FTYPE) == IEEE80211_FTYPE_MGMT)\r\nep = 12;\r\nelse\r\nep = epmap[skb_get_queue_mapping(skb)];\r\n}\r\ninfo->rate_driver_data[0] = dev;\r\ninfo->rate_driver_data[1] = urb;\r\nusb_fill_bulk_urb(urb, priv->udev, usb_sndbulkpipe(priv->udev, ep),\r\nbuf, skb->len, rtl8187_tx_cb, skb);\r\nurb->transfer_flags |= URB_ZERO_PACKET;\r\nusb_anchor_urb(urb, &priv->anchored);\r\nrc = usb_submit_urb(urb, GFP_ATOMIC);\r\nif (rc < 0) {\r\nusb_unanchor_urb(urb);\r\nkfree_skb(skb);\r\n}\r\nusb_free_urb(urb);\r\n}\r\nstatic void rtl8187_rx_cb(struct urb *urb)\r\n{\r\nstruct sk_buff *skb = (struct sk_buff *)urb->context;\r\nstruct rtl8187_rx_info *info = (struct rtl8187_rx_info *)skb->cb;\r\nstruct ieee80211_hw *dev = info->dev;\r\nstruct rtl8187_priv *priv = dev->priv;\r\nstruct ieee80211_rx_status rx_status = { 0 };\r\nint rate, signal;\r\nu32 flags;\r\nunsigned long f;\r\nspin_lock_irqsave(&priv->rx_queue.lock, f);\r\n__skb_unlink(skb, &priv->rx_queue);\r\nspin_unlock_irqrestore(&priv->rx_queue.lock, f);\r\nskb_put(skb, urb->actual_length);\r\nif (unlikely(urb->status)) {\r\ndev_kfree_skb_irq(skb);\r\nreturn;\r\n}\r\nif (!priv->is_rtl8187b) {\r\nstruct rtl8187_rx_hdr *hdr =\r\n(typeof(hdr))(skb_tail_pointer(skb) - sizeof(*hdr));\r\nflags = le32_to_cpu(hdr->flags);\r\nsignal = -4 - ((27 * hdr->agc) >> 6);\r\nrx_status.antenna = (hdr->signal >> 7) & 1;\r\nrx_status.mactime = le64_to_cpu(hdr->mac_time);\r\n} else {\r\nstruct rtl8187b_rx_hdr *hdr =\r\n(typeof(hdr))(skb_tail_pointer(skb) - sizeof(*hdr));\r\nflags = le32_to_cpu(hdr->flags);\r\nsignal = 14 - hdr->agc / 2;\r\nrx_status.antenna = (hdr->rssi >> 7) & 1;\r\nrx_status.mactime = le64_to_cpu(hdr->mac_time);\r\n}\r\nrx_status.signal = signal;\r\npriv->signal = signal;\r\nrate = (flags >> 20) & 0xF;\r\nskb_trim(skb, flags & 0x0FFF);\r\nrx_status.rate_idx = rate;\r\nrx_status.freq = dev->conf.chandef.chan->center_freq;\r\nrx_status.band = dev->conf.chandef.chan->band;\r\nrx_status.flag |= RX_FLAG_MACTIME_START;\r\nif (flags & RTL818X_RX_DESC_FLAG_SPLCP)\r\nrx_status.flag |= RX_FLAG_SHORTPRE;\r\nif (flags & RTL818X_RX_DESC_FLAG_CRC32_ERR)\r\nrx_status.flag |= RX_FLAG_FAILED_FCS_CRC;\r\nmemcpy(IEEE80211_SKB_RXCB(skb), &rx_status, sizeof(rx_status));\r\nieee80211_rx_irqsafe(dev, skb);\r\nskb = dev_alloc_skb(RTL8187_MAX_RX);\r\nif (unlikely(!skb)) {\r\nreturn;\r\n}\r\ninfo = (struct rtl8187_rx_info *)skb->cb;\r\ninfo->urb = urb;\r\ninfo->dev = dev;\r\nurb->transfer_buffer = skb_tail_pointer(skb);\r\nurb->context = skb;\r\nskb_queue_tail(&priv->rx_queue, skb);\r\nusb_anchor_urb(urb, &priv->anchored);\r\nif (usb_submit_urb(urb, GFP_ATOMIC)) {\r\nusb_unanchor_urb(urb);\r\nskb_unlink(skb, &priv->rx_queue);\r\ndev_kfree_skb_irq(skb);\r\n}\r\n}\r\nstatic int rtl8187_init_urbs(struct ieee80211_hw *dev)\r\n{\r\nstruct rtl8187_priv *priv = dev->priv;\r\nstruct urb *entry = NULL;\r\nstruct sk_buff *skb;\r\nstruct rtl8187_rx_info *info;\r\nint ret = 0;\r\nwhile (skb_queue_len(&priv->rx_queue) < 32) {\r\nskb = __dev_alloc_skb(RTL8187_MAX_RX, GFP_KERNEL);\r\nif (!skb) {\r\nret = -ENOMEM;\r\ngoto err;\r\n}\r\nentry = usb_alloc_urb(0, GFP_KERNEL);\r\nif (!entry) {\r\nret = -ENOMEM;\r\ngoto err;\r\n}\r\nusb_fill_bulk_urb(entry, priv->udev,\r\nusb_rcvbulkpipe(priv->udev,\r\npriv->is_rtl8187b ? 3 : 1),\r\nskb_tail_pointer(skb),\r\nRTL8187_MAX_RX, rtl8187_rx_cb, skb);\r\ninfo = (struct rtl8187_rx_info *)skb->cb;\r\ninfo->urb = entry;\r\ninfo->dev = dev;\r\nskb_queue_tail(&priv->rx_queue, skb);\r\nusb_anchor_urb(entry, &priv->anchored);\r\nret = usb_submit_urb(entry, GFP_KERNEL);\r\nusb_put_urb(entry);\r\nif (ret) {\r\nskb_unlink(skb, &priv->rx_queue);\r\nusb_unanchor_urb(entry);\r\ngoto err;\r\n}\r\n}\r\nreturn ret;\r\nerr:\r\nkfree_skb(skb);\r\nusb_kill_anchored_urbs(&priv->anchored);\r\nreturn ret;\r\n}\r\nstatic void rtl8187b_status_cb(struct urb *urb)\r\n{\r\nstruct ieee80211_hw *hw = (struct ieee80211_hw *)urb->context;\r\nstruct rtl8187_priv *priv = hw->priv;\r\nu64 val;\r\nunsigned int cmd_type;\r\nif (unlikely(urb->status))\r\nreturn;\r\nval = le64_to_cpu(priv->b_tx_status.buf);\r\ncmd_type = (val >> 30) & 0x3;\r\nif (cmd_type == 1) {\r\nunsigned int pkt_rc, seq_no;\r\nbool tok;\r\nstruct sk_buff *skb;\r\nstruct ieee80211_hdr *ieee80211hdr;\r\nunsigned long flags;\r\npkt_rc = val & 0xFF;\r\ntok = val & (1 << 15);\r\nseq_no = (val >> 16) & 0xFFF;\r\nspin_lock_irqsave(&priv->b_tx_status.queue.lock, flags);\r\nskb_queue_reverse_walk(&priv->b_tx_status.queue, skb) {\r\nieee80211hdr = (struct ieee80211_hdr *)skb->data;\r\nif ((le16_to_cpu(ieee80211hdr->seq_ctrl)\r\n& 0xFFF) == seq_no)\r\nbreak;\r\n}\r\nif (skb != (struct sk_buff *) &priv->b_tx_status.queue) {\r\nstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\r\n__skb_unlink(skb, &priv->b_tx_status.queue);\r\nif (tok)\r\ninfo->flags |= IEEE80211_TX_STAT_ACK;\r\ninfo->status.rates[0].count = pkt_rc + 1;\r\nieee80211_tx_status_irqsafe(hw, skb);\r\n}\r\nspin_unlock_irqrestore(&priv->b_tx_status.queue.lock, flags);\r\n}\r\nusb_anchor_urb(urb, &priv->anchored);\r\nif (usb_submit_urb(urb, GFP_ATOMIC))\r\nusb_unanchor_urb(urb);\r\n}\r\nstatic int rtl8187b_init_status_urb(struct ieee80211_hw *dev)\r\n{\r\nstruct rtl8187_priv *priv = dev->priv;\r\nstruct urb *entry;\r\nint ret = 0;\r\nentry = usb_alloc_urb(0, GFP_KERNEL);\r\nif (!entry)\r\nreturn -ENOMEM;\r\nusb_fill_bulk_urb(entry, priv->udev, usb_rcvbulkpipe(priv->udev, 9),\r\n&priv->b_tx_status.buf, sizeof(priv->b_tx_status.buf),\r\nrtl8187b_status_cb, dev);\r\nusb_anchor_urb(entry, &priv->anchored);\r\nret = usb_submit_urb(entry, GFP_KERNEL);\r\nif (ret)\r\nusb_unanchor_urb(entry);\r\nusb_free_urb(entry);\r\nreturn ret;\r\n}\r\nstatic void rtl8187_set_anaparam(struct rtl8187_priv *priv, bool rfon)\r\n{\r\nu32 anaparam, anaparam2;\r\nu8 anaparam3, reg;\r\nif (!priv->is_rtl8187b) {\r\nif (rfon) {\r\nanaparam = RTL8187_RTL8225_ANAPARAM_ON;\r\nanaparam2 = RTL8187_RTL8225_ANAPARAM2_ON;\r\n} else {\r\nanaparam = RTL8187_RTL8225_ANAPARAM_OFF;\r\nanaparam2 = RTL8187_RTL8225_ANAPARAM2_OFF;\r\n}\r\n} else {\r\nif (rfon) {\r\nanaparam = RTL8187B_RTL8225_ANAPARAM_ON;\r\nanaparam2 = RTL8187B_RTL8225_ANAPARAM2_ON;\r\nanaparam3 = RTL8187B_RTL8225_ANAPARAM3_ON;\r\n} else {\r\nanaparam = RTL8187B_RTL8225_ANAPARAM_OFF;\r\nanaparam2 = RTL8187B_RTL8225_ANAPARAM2_OFF;\r\nanaparam3 = RTL8187B_RTL8225_ANAPARAM3_OFF;\r\n}\r\n}\r\nrtl818x_iowrite8(priv, &priv->map->EEPROM_CMD,\r\nRTL818X_EEPROM_CMD_CONFIG);\r\nreg = rtl818x_ioread8(priv, &priv->map->CONFIG3);\r\nreg |= RTL818X_CONFIG3_ANAPARAM_WRITE;\r\nrtl818x_iowrite8(priv, &priv->map->CONFIG3, reg);\r\nrtl818x_iowrite32(priv, &priv->map->ANAPARAM, anaparam);\r\nrtl818x_iowrite32(priv, &priv->map->ANAPARAM2, anaparam2);\r\nif (priv->is_rtl8187b)\r\nrtl818x_iowrite8(priv, &priv->map->ANAPARAM3A, anaparam3);\r\nreg &= ~RTL818X_CONFIG3_ANAPARAM_WRITE;\r\nrtl818x_iowrite8(priv, &priv->map->CONFIG3, reg);\r\nrtl818x_iowrite8(priv, &priv->map->EEPROM_CMD,\r\nRTL818X_EEPROM_CMD_NORMAL);\r\n}\r\nstatic int rtl8187_cmd_reset(struct ieee80211_hw *dev)\r\n{\r\nstruct rtl8187_priv *priv = dev->priv;\r\nu8 reg;\r\nint i;\r\nreg = rtl818x_ioread8(priv, &priv->map->CMD);\r\nreg &= (1 << 1);\r\nreg |= RTL818X_CMD_RESET;\r\nrtl818x_iowrite8(priv, &priv->map->CMD, reg);\r\ni = 10;\r\ndo {\r\nmsleep(2);\r\nif (!(rtl818x_ioread8(priv, &priv->map->CMD) &\r\nRTL818X_CMD_RESET))\r\nbreak;\r\n} while (--i);\r\nif (!i) {\r\nwiphy_err(dev->wiphy, "Reset timeout!\n");\r\nreturn -ETIMEDOUT;\r\n}\r\nrtl818x_iowrite8(priv, &priv->map->EEPROM_CMD, RTL818X_EEPROM_CMD_LOAD);\r\ni = 10;\r\ndo {\r\nmsleep(4);\r\nif (!(rtl818x_ioread8(priv, &priv->map->EEPROM_CMD) &\r\nRTL818X_EEPROM_CMD_CONFIG))\r\nbreak;\r\n} while (--i);\r\nif (!i) {\r\nwiphy_err(dev->wiphy, "eeprom reset timeout!\n");\r\nreturn -ETIMEDOUT;\r\n}\r\nreturn 0;\r\n}\r\nstatic int rtl8187_init_hw(struct ieee80211_hw *dev)\r\n{\r\nstruct rtl8187_priv *priv = dev->priv;\r\nu8 reg;\r\nint res;\r\nrtl8187_set_anaparam(priv, true);\r\nrtl818x_iowrite16(priv, &priv->map->INT_MASK, 0);\r\nmsleep(200);\r\nrtl818x_iowrite8(priv, (u8 *)0xFE18, 0x10);\r\nrtl818x_iowrite8(priv, (u8 *)0xFE18, 0x11);\r\nrtl818x_iowrite8(priv, (u8 *)0xFE18, 0x00);\r\nmsleep(200);\r\nres = rtl8187_cmd_reset(dev);\r\nif (res)\r\nreturn res;\r\nrtl8187_set_anaparam(priv, true);\r\nrtl818x_iowrite16(priv, &priv->map->RFPinsSelect, 0);\r\nrtl818x_iowrite8(priv, &priv->map->GPIO0, 0);\r\nrtl818x_iowrite16(priv, &priv->map->RFPinsSelect, (4 << 8));\r\nrtl818x_iowrite8(priv, &priv->map->GPIO0, 1);\r\nrtl818x_iowrite8(priv, &priv->map->GP_ENABLE, 0);\r\nrtl818x_iowrite8(priv, &priv->map->EEPROM_CMD, RTL818X_EEPROM_CMD_CONFIG);\r\nrtl818x_iowrite16(priv, (__le16 *)0xFFF4, 0xFFFF);\r\nreg = rtl818x_ioread8(priv, &priv->map->CONFIG1);\r\nreg &= 0x3F;\r\nreg |= 0x80;\r\nrtl818x_iowrite8(priv, &priv->map->CONFIG1, reg);\r\nrtl818x_iowrite8(priv, &priv->map->EEPROM_CMD, RTL818X_EEPROM_CMD_NORMAL);\r\nrtl818x_iowrite32(priv, &priv->map->INT_TIMEOUT, 0);\r\nrtl818x_iowrite8(priv, &priv->map->WPA_CONF, 0);\r\nrtl818x_iowrite8(priv, &priv->map->RATE_FALLBACK, 0);\r\nrtl818x_iowrite8(priv, &priv->map->RESP_RATE, (8 << 4) | 0);\r\nrtl818x_iowrite16(priv, &priv->map->BRSR, 0x01F3);\r\nrtl818x_iowrite16(priv, &priv->map->RFPinsSelect, 0);\r\nrtl818x_iowrite8(priv, &priv->map->GPIO0, 0);\r\nreg = rtl818x_ioread8(priv, (u8 *)0xFE53);\r\nrtl818x_iowrite8(priv, (u8 *)0xFE53, reg | (1 << 7));\r\nrtl818x_iowrite16(priv, &priv->map->RFPinsSelect, (4 << 8));\r\nrtl818x_iowrite8(priv, &priv->map->GPIO0, 0x20);\r\nrtl818x_iowrite8(priv, &priv->map->GP_ENABLE, 0);\r\nrtl818x_iowrite16(priv, &priv->map->RFPinsOutput, 0x80);\r\nrtl818x_iowrite16(priv, &priv->map->RFPinsSelect, 0x80);\r\nrtl818x_iowrite16(priv, &priv->map->RFPinsEnable, 0x80);\r\nmsleep(100);\r\nrtl818x_iowrite32(priv, &priv->map->RF_TIMING, 0x000a8008);\r\nrtl818x_iowrite16(priv, &priv->map->BRSR, 0xFFFF);\r\nrtl818x_iowrite32(priv, &priv->map->RF_PARA, 0x00100044);\r\nrtl818x_iowrite8(priv, &priv->map->EEPROM_CMD,\r\nRTL818X_EEPROM_CMD_CONFIG);\r\nrtl818x_iowrite8(priv, &priv->map->CONFIG3, 0x44);\r\nrtl818x_iowrite8(priv, &priv->map->EEPROM_CMD,\r\nRTL818X_EEPROM_CMD_NORMAL);\r\nrtl818x_iowrite16(priv, &priv->map->RFPinsEnable, 0x1FF7);\r\nmsleep(100);\r\npriv->rf->init(dev);\r\nrtl818x_iowrite16(priv, &priv->map->BRSR, 0x01F3);\r\nreg = rtl818x_ioread8(priv, &priv->map->PGSELECT) & ~1;\r\nrtl818x_iowrite8(priv, &priv->map->PGSELECT, reg | 1);\r\nrtl818x_iowrite16(priv, (__le16 *)0xFFFE, 0x10);\r\nrtl818x_iowrite8(priv, &priv->map->TALLY_SEL, 0x80);\r\nrtl818x_iowrite8(priv, (u8 *)0xFFFF, 0x60);\r\nrtl818x_iowrite8(priv, &priv->map->PGSELECT, reg);\r\nreturn 0;\r\n}\r\nstatic int rtl8187b_init_hw(struct ieee80211_hw *dev)\r\n{\r\nstruct rtl8187_priv *priv = dev->priv;\r\nint res, i;\r\nu8 reg;\r\nrtl8187_set_anaparam(priv, true);\r\nrtl818x_iowrite8(priv, (u8 *)0xFF61, 0x10);\r\nreg = rtl818x_ioread8(priv, (u8 *)0xFF62);\r\nrtl818x_iowrite8(priv, (u8 *)0xFF62, reg & ~(1 << 5));\r\nrtl818x_iowrite8(priv, (u8 *)0xFF62, reg | (1 << 5));\r\nres = rtl8187_cmd_reset(dev);\r\nif (res)\r\nreturn res;\r\nrtl8187_set_anaparam(priv, true);\r\nrtl818x_iowrite16(priv, (__le16 *)0xFF34, 0x0FFF);\r\nreg = rtl818x_ioread8(priv, &priv->map->CW_CONF);\r\nreg |= RTL818X_CW_CONF_PERPACKET_RETRY;\r\nrtl818x_iowrite8(priv, &priv->map->CW_CONF, reg);\r\nrtl818x_iowrite16_idx(priv, (__le16 *)0xFFE0, 0x0FFF, 1);\r\nrtl818x_iowrite8_idx(priv, (u8 *)0xFFE2, 0x00, 1);\r\nrtl818x_iowrite16_idx(priv, (__le16 *)0xFFD4, 0xFFFF, 1);\r\nrtl818x_iowrite8(priv, &priv->map->EEPROM_CMD,\r\nRTL818X_EEPROM_CMD_CONFIG);\r\nreg = rtl818x_ioread8(priv, &priv->map->CONFIG1);\r\nrtl818x_iowrite8(priv, &priv->map->CONFIG1, (reg & 0x3F) | 0x80);\r\nrtl818x_iowrite8(priv, &priv->map->EEPROM_CMD,\r\nRTL818X_EEPROM_CMD_NORMAL);\r\nrtl818x_iowrite8(priv, &priv->map->WPA_CONF, 0);\r\nfor (i = 0; i < ARRAY_SIZE(rtl8187b_reg_table); i++) {\r\nrtl818x_iowrite8_idx(priv,\r\n(u8 *)(uintptr_t)\r\n(rtl8187b_reg_table[i][0] | 0xFF00),\r\nrtl8187b_reg_table[i][1],\r\nrtl8187b_reg_table[i][2]);\r\n}\r\nrtl818x_iowrite16(priv, &priv->map->TID_AC_MAP, 0xFA50);\r\nrtl818x_iowrite16(priv, &priv->map->INT_MIG, 0);\r\nrtl818x_iowrite32_idx(priv, (__le32 *)0xFFF0, 0, 1);\r\nrtl818x_iowrite32_idx(priv, (__le32 *)0xFFF4, 0, 1);\r\nrtl818x_iowrite8_idx(priv, (u8 *)0xFFF8, 0, 1);\r\nrtl818x_iowrite32(priv, &priv->map->RF_TIMING, 0x00004001);\r\nrtl818x_iowrite16_idx(priv, (__le16 *)0xFF72, 0x569A, 2);\r\nrtl818x_iowrite16(priv, &priv->map->RFPinsOutput, 0x0480);\r\nrtl818x_iowrite16(priv, &priv->map->RFPinsSelect, 0x2488);\r\nrtl818x_iowrite16(priv, &priv->map->RFPinsEnable, 0x1FFF);\r\nmsleep(100);\r\npriv->rf->init(dev);\r\nreg = RTL818X_CMD_TX_ENABLE | RTL818X_CMD_RX_ENABLE;\r\nrtl818x_iowrite8(priv, &priv->map->CMD, reg);\r\nrtl818x_iowrite16(priv, &priv->map->INT_MASK, 0xFFFF);\r\nrtl818x_iowrite8(priv, (u8 *)0xFE41, 0xF4);\r\nrtl818x_iowrite8(priv, (u8 *)0xFE40, 0x00);\r\nrtl818x_iowrite8(priv, (u8 *)0xFE42, 0x00);\r\nrtl818x_iowrite8(priv, (u8 *)0xFE42, 0x01);\r\nrtl818x_iowrite8(priv, (u8 *)0xFE40, 0x0F);\r\nrtl818x_iowrite8(priv, (u8 *)0xFE42, 0x00);\r\nrtl818x_iowrite8(priv, (u8 *)0xFE42, 0x01);\r\nreg = rtl818x_ioread8(priv, (u8 *)0xFFDB);\r\nrtl818x_iowrite8(priv, (u8 *)0xFFDB, reg | (1 << 2));\r\nrtl818x_iowrite16_idx(priv, (__le16 *)0xFF72, 0x59FA, 3);\r\nrtl818x_iowrite16_idx(priv, (__le16 *)0xFF74, 0x59D2, 3);\r\nrtl818x_iowrite16_idx(priv, (__le16 *)0xFF76, 0x59D2, 3);\r\nrtl818x_iowrite16_idx(priv, (__le16 *)0xFF78, 0x19FA, 3);\r\nrtl818x_iowrite16_idx(priv, (__le16 *)0xFF7A, 0x19FA, 3);\r\nrtl818x_iowrite16_idx(priv, (__le16 *)0xFF7C, 0x00D0, 3);\r\nrtl818x_iowrite8(priv, (u8 *)0xFF61, 0);\r\nrtl818x_iowrite8_idx(priv, (u8 *)0xFF80, 0x0F, 1);\r\nrtl818x_iowrite8_idx(priv, (u8 *)0xFF83, 0x03, 1);\r\nrtl818x_iowrite8(priv, (u8 *)0xFFDA, 0x10);\r\nrtl818x_iowrite8_idx(priv, (u8 *)0xFF4D, 0x08, 2);\r\nrtl818x_iowrite32(priv, &priv->map->HSSI_PARA, 0x0600321B);\r\nrtl818x_iowrite16_idx(priv, (__le16 *)0xFFEC, 0x0800, 1);\r\npriv->slot_time = 0x9;\r\npriv->aifsn[0] = 2;\r\npriv->aifsn[1] = 2;\r\npriv->aifsn[2] = 7;\r\npriv->aifsn[3] = 3;\r\nrtl818x_iowrite8(priv, &priv->map->ACM_CONTROL, 0);\r\nrtl818x_iowrite8(priv, &priv->map->MSR, RTL818X_MSR_ENEDCA);\r\nreturn 0;\r\n}\r\nstatic void rtl8187_work(struct work_struct *work)\r\n{\r\nstruct rtl8187_priv *priv = container_of(work, struct rtl8187_priv,\r\nwork.work);\r\nstruct ieee80211_tx_info *info;\r\nstruct ieee80211_hw *dev = priv->dev;\r\nstatic u16 retry;\r\nu16 tmp;\r\nu16 avg_retry;\r\nint length;\r\nmutex_lock(&priv->conf_mutex);\r\ntmp = rtl818x_ioread16(priv, (__le16 *)0xFFFA);\r\nlength = skb_queue_len(&priv->b_tx_status.queue);\r\nif (unlikely(!length))\r\nlength = 1;\r\nif (unlikely(tmp < retry))\r\ntmp = retry;\r\navg_retry = (tmp - retry) / length;\r\nwhile (skb_queue_len(&priv->b_tx_status.queue) > 0) {\r\nstruct sk_buff *old_skb;\r\nold_skb = skb_dequeue(&priv->b_tx_status.queue);\r\ninfo = IEEE80211_SKB_CB(old_skb);\r\ninfo->status.rates[0].count = avg_retry + 1;\r\nif (info->status.rates[0].count > RETRY_COUNT)\r\ninfo->flags &= ~IEEE80211_TX_STAT_ACK;\r\nieee80211_tx_status_irqsafe(dev, old_skb);\r\n}\r\nretry = tmp;\r\nmutex_unlock(&priv->conf_mutex);\r\n}\r\nstatic int rtl8187_start(struct ieee80211_hw *dev)\r\n{\r\nstruct rtl8187_priv *priv = dev->priv;\r\nu32 reg;\r\nint ret;\r\nmutex_lock(&priv->conf_mutex);\r\nret = (!priv->is_rtl8187b) ? rtl8187_init_hw(dev) :\r\nrtl8187b_init_hw(dev);\r\nif (ret)\r\ngoto rtl8187_start_exit;\r\ninit_usb_anchor(&priv->anchored);\r\npriv->dev = dev;\r\nif (priv->is_rtl8187b) {\r\nreg = RTL818X_RX_CONF_MGMT |\r\nRTL818X_RX_CONF_DATA |\r\nRTL818X_RX_CONF_BROADCAST |\r\nRTL818X_RX_CONF_NICMAC |\r\nRTL818X_RX_CONF_BSSID |\r\n(7 << 13 ) |\r\n(7 << 10 ) |\r\nRTL818X_RX_CONF_RX_AUTORESETPHY |\r\nRTL818X_RX_CONF_ONLYERLPKT |\r\nRTL818X_RX_CONF_MULTICAST;\r\npriv->rx_conf = reg;\r\nrtl818x_iowrite32(priv, &priv->map->RX_CONF, reg);\r\nreg = rtl818x_ioread8(priv, &priv->map->TX_AGC_CTL);\r\nreg &= ~RTL818X_TX_AGC_CTL_PERPACKET_GAIN;\r\nreg &= ~RTL818X_TX_AGC_CTL_PERPACKET_ANTSEL;\r\nreg &= ~RTL818X_TX_AGC_CTL_FEEDBACK_ANT;\r\nrtl818x_iowrite8(priv, &priv->map->TX_AGC_CTL, reg);\r\nrtl818x_iowrite32(priv, &priv->map->TX_CONF,\r\nRTL818X_TX_CONF_HW_SEQNUM |\r\nRTL818X_TX_CONF_DISREQQSIZE |\r\n(RETRY_COUNT << 8 ) |\r\n(RETRY_COUNT << 0 ) |\r\n(7 << 21 ));\r\nret = rtl8187_init_urbs(dev);\r\nif (ret)\r\ngoto rtl8187_start_exit;\r\nret = rtl8187b_init_status_urb(dev);\r\nif (ret)\r\nusb_kill_anchored_urbs(&priv->anchored);\r\ngoto rtl8187_start_exit;\r\n}\r\nrtl818x_iowrite16(priv, &priv->map->INT_MASK, 0xFFFF);\r\nrtl818x_iowrite32(priv, &priv->map->MAR[0], ~0);\r\nrtl818x_iowrite32(priv, &priv->map->MAR[1], ~0);\r\nret = rtl8187_init_urbs(dev);\r\nif (ret)\r\ngoto rtl8187_start_exit;\r\nreg = RTL818X_RX_CONF_ONLYERLPKT |\r\nRTL818X_RX_CONF_RX_AUTORESETPHY |\r\nRTL818X_RX_CONF_BSSID |\r\nRTL818X_RX_CONF_MGMT |\r\nRTL818X_RX_CONF_DATA |\r\n(7 << 13 ) |\r\n(7 << 10 ) |\r\nRTL818X_RX_CONF_BROADCAST |\r\nRTL818X_RX_CONF_NICMAC;\r\npriv->rx_conf = reg;\r\nrtl818x_iowrite32(priv, &priv->map->RX_CONF, reg);\r\nreg = rtl818x_ioread8(priv, &priv->map->CW_CONF);\r\nreg &= ~RTL818X_CW_CONF_PERPACKET_CW;\r\nreg |= RTL818X_CW_CONF_PERPACKET_RETRY;\r\nrtl818x_iowrite8(priv, &priv->map->CW_CONF, reg);\r\nreg = rtl818x_ioread8(priv, &priv->map->TX_AGC_CTL);\r\nreg &= ~RTL818X_TX_AGC_CTL_PERPACKET_GAIN;\r\nreg &= ~RTL818X_TX_AGC_CTL_PERPACKET_ANTSEL;\r\nreg &= ~RTL818X_TX_AGC_CTL_FEEDBACK_ANT;\r\nrtl818x_iowrite8(priv, &priv->map->TX_AGC_CTL, reg);\r\nreg = RTL818X_TX_CONF_CW_MIN |\r\n(7 << 21 ) |\r\nRTL818X_TX_CONF_NO_ICV;\r\nrtl818x_iowrite32(priv, &priv->map->TX_CONF, reg);\r\nreg = rtl818x_ioread8(priv, &priv->map->CMD);\r\nreg |= RTL818X_CMD_TX_ENABLE;\r\nreg |= RTL818X_CMD_RX_ENABLE;\r\nrtl818x_iowrite8(priv, &priv->map->CMD, reg);\r\nINIT_DELAYED_WORK(&priv->work, rtl8187_work);\r\nrtl8187_start_exit:\r\nmutex_unlock(&priv->conf_mutex);\r\nreturn ret;\r\n}\r\nstatic void rtl8187_stop(struct ieee80211_hw *dev)\r\n{\r\nstruct rtl8187_priv *priv = dev->priv;\r\nstruct sk_buff *skb;\r\nu32 reg;\r\nmutex_lock(&priv->conf_mutex);\r\nrtl818x_iowrite16(priv, &priv->map->INT_MASK, 0);\r\nreg = rtl818x_ioread8(priv, &priv->map->CMD);\r\nreg &= ~RTL818X_CMD_TX_ENABLE;\r\nreg &= ~RTL818X_CMD_RX_ENABLE;\r\nrtl818x_iowrite8(priv, &priv->map->CMD, reg);\r\npriv->rf->stop(dev);\r\nrtl8187_set_anaparam(priv, false);\r\nrtl818x_iowrite8(priv, &priv->map->EEPROM_CMD, RTL818X_EEPROM_CMD_CONFIG);\r\nreg = rtl818x_ioread8(priv, &priv->map->CONFIG4);\r\nrtl818x_iowrite8(priv, &priv->map->CONFIG4, reg | RTL818X_CONFIG4_VCOOFF);\r\nrtl818x_iowrite8(priv, &priv->map->EEPROM_CMD, RTL818X_EEPROM_CMD_NORMAL);\r\nwhile ((skb = skb_dequeue(&priv->b_tx_status.queue)))\r\ndev_kfree_skb_any(skb);\r\nusb_kill_anchored_urbs(&priv->anchored);\r\nmutex_unlock(&priv->conf_mutex);\r\nif (!priv->is_rtl8187b)\r\ncancel_delayed_work_sync(&priv->work);\r\n}\r\nstatic u64 rtl8187_get_tsf(struct ieee80211_hw *dev, struct ieee80211_vif *vif)\r\n{\r\nstruct rtl8187_priv *priv = dev->priv;\r\nreturn rtl818x_ioread32(priv, &priv->map->TSFT[0]) |\r\n(u64)(rtl818x_ioread32(priv, &priv->map->TSFT[1])) << 32;\r\n}\r\nstatic void rtl8187_beacon_work(struct work_struct *work)\r\n{\r\nstruct rtl8187_vif *vif_priv =\r\ncontainer_of(work, struct rtl8187_vif, beacon_work.work);\r\nstruct ieee80211_vif *vif =\r\ncontainer_of((void *)vif_priv, struct ieee80211_vif, drv_priv);\r\nstruct ieee80211_hw *dev = vif_priv->dev;\r\nstruct ieee80211_mgmt *mgmt;\r\nstruct sk_buff *skb;\r\nif (ieee80211_queue_stopped(dev, 0))\r\ngoto resched;\r\nskb = ieee80211_beacon_get(dev, vif);\r\nif (!skb)\r\ngoto resched;\r\nmgmt = (struct ieee80211_mgmt *)skb->data;\r\nmgmt->u.beacon.timestamp = cpu_to_le64(rtl8187_get_tsf(dev, vif));\r\nskb_set_queue_mapping(skb, 0);\r\nrtl8187_tx(dev, NULL, skb);\r\nresched:\r\nschedule_delayed_work(&vif_priv->beacon_work,\r\nusecs_to_jiffies(1024 * vif->bss_conf.beacon_int));\r\n}\r\nstatic int rtl8187_add_interface(struct ieee80211_hw *dev,\r\nstruct ieee80211_vif *vif)\r\n{\r\nstruct rtl8187_priv *priv = dev->priv;\r\nstruct rtl8187_vif *vif_priv;\r\nint i;\r\nint ret = -EOPNOTSUPP;\r\nmutex_lock(&priv->conf_mutex);\r\nif (priv->vif)\r\ngoto exit;\r\nswitch (vif->type) {\r\ncase NL80211_IFTYPE_STATION:\r\ncase NL80211_IFTYPE_ADHOC:\r\nbreak;\r\ndefault:\r\ngoto exit;\r\n}\r\nret = 0;\r\npriv->vif = vif;\r\nvif_priv = (struct rtl8187_vif *)&vif->drv_priv;\r\nvif_priv->dev = dev;\r\nINIT_DELAYED_WORK(&vif_priv->beacon_work, rtl8187_beacon_work);\r\nvif_priv->enable_beacon = false;\r\nrtl818x_iowrite8(priv, &priv->map->EEPROM_CMD, RTL818X_EEPROM_CMD_CONFIG);\r\nfor (i = 0; i < ETH_ALEN; i++)\r\nrtl818x_iowrite8(priv, &priv->map->MAC[i],\r\n((u8 *)vif->addr)[i]);\r\nrtl818x_iowrite8(priv, &priv->map->EEPROM_CMD, RTL818X_EEPROM_CMD_NORMAL);\r\nexit:\r\nmutex_unlock(&priv->conf_mutex);\r\nreturn ret;\r\n}\r\nstatic void rtl8187_remove_interface(struct ieee80211_hw *dev,\r\nstruct ieee80211_vif *vif)\r\n{\r\nstruct rtl8187_priv *priv = dev->priv;\r\nmutex_lock(&priv->conf_mutex);\r\npriv->vif = NULL;\r\nmutex_unlock(&priv->conf_mutex);\r\n}\r\nstatic int rtl8187_config(struct ieee80211_hw *dev, u32 changed)\r\n{\r\nstruct rtl8187_priv *priv = dev->priv;\r\nstruct ieee80211_conf *conf = &dev->conf;\r\nu32 reg;\r\nmutex_lock(&priv->conf_mutex);\r\nreg = rtl818x_ioread32(priv, &priv->map->TX_CONF);\r\nrtl818x_iowrite32(priv, &priv->map->TX_CONF,\r\nreg | RTL818X_TX_CONF_LOOPBACK_MAC);\r\npriv->rf->set_chan(dev, conf);\r\nmsleep(10);\r\nrtl818x_iowrite32(priv, &priv->map->TX_CONF, reg);\r\nrtl818x_iowrite16(priv, &priv->map->ATIM_WND, 2);\r\nrtl818x_iowrite16(priv, &priv->map->ATIMTR_INTERVAL, 100);\r\nrtl818x_iowrite16(priv, &priv->map->BEACON_INTERVAL, 100);\r\nrtl818x_iowrite16(priv, &priv->map->BEACON_INTERVAL_TIME, 100);\r\nmutex_unlock(&priv->conf_mutex);\r\nreturn 0;\r\n}\r\nstatic void rtl8187_conf_erp(struct rtl8187_priv *priv, bool use_short_slot,\r\nbool use_short_preamble)\r\n{\r\nif (priv->is_rtl8187b) {\r\nu8 difs, eifs;\r\nu16 ack_timeout;\r\nint queue;\r\nif (use_short_slot) {\r\npriv->slot_time = 0x9;\r\ndifs = 0x1c;\r\neifs = 0x53;\r\n} else {\r\npriv->slot_time = 0x14;\r\ndifs = 0x32;\r\neifs = 0x5b;\r\n}\r\nrtl818x_iowrite8(priv, &priv->map->SIFS, 0x22);\r\nrtl818x_iowrite8(priv, &priv->map->SLOT, priv->slot_time);\r\nrtl818x_iowrite8(priv, &priv->map->DIFS, difs);\r\nrtl818x_iowrite8(priv, (u8 *)&priv->map->BRSR + 1, eifs);\r\nack_timeout = 112 + 48 + difs;\r\nif (use_short_preamble)\r\nack_timeout += 72;\r\nelse\r\nack_timeout += 144;\r\nrtl818x_iowrite8(priv, &priv->map->CARRIER_SENSE_COUNTER,\r\nDIV_ROUND_UP(ack_timeout, 4));\r\nfor (queue = 0; queue < 4; queue++)\r\nrtl818x_iowrite8(priv, (u8 *) rtl8187b_ac_addr[queue],\r\npriv->aifsn[queue] * priv->slot_time +\r\nSIFS_TIME);\r\n} else {\r\nrtl818x_iowrite8(priv, &priv->map->SIFS, 0x22);\r\nif (use_short_slot) {\r\nrtl818x_iowrite8(priv, &priv->map->SLOT, 0x9);\r\nrtl818x_iowrite8(priv, &priv->map->DIFS, 0x14);\r\nrtl818x_iowrite8(priv, &priv->map->EIFS, 91 - 0x14);\r\n} else {\r\nrtl818x_iowrite8(priv, &priv->map->SLOT, 0x14);\r\nrtl818x_iowrite8(priv, &priv->map->DIFS, 0x24);\r\nrtl818x_iowrite8(priv, &priv->map->EIFS, 91 - 0x24);\r\n}\r\n}\r\n}\r\nstatic void rtl8187_bss_info_changed(struct ieee80211_hw *dev,\r\nstruct ieee80211_vif *vif,\r\nstruct ieee80211_bss_conf *info,\r\nu32 changed)\r\n{\r\nstruct rtl8187_priv *priv = dev->priv;\r\nstruct rtl8187_vif *vif_priv;\r\nint i;\r\nu8 reg;\r\nvif_priv = (struct rtl8187_vif *)&vif->drv_priv;\r\nif (changed & BSS_CHANGED_BSSID) {\r\nmutex_lock(&priv->conf_mutex);\r\nfor (i = 0; i < ETH_ALEN; i++)\r\nrtl818x_iowrite8(priv, &priv->map->BSSID[i],\r\ninfo->bssid[i]);\r\nif (priv->is_rtl8187b)\r\nreg = RTL818X_MSR_ENEDCA;\r\nelse\r\nreg = 0;\r\nif (is_valid_ether_addr(info->bssid)) {\r\nif (vif->type == NL80211_IFTYPE_ADHOC)\r\nreg |= RTL818X_MSR_ADHOC;\r\nelse\r\nreg |= RTL818X_MSR_INFRA;\r\n}\r\nelse\r\nreg |= RTL818X_MSR_NO_LINK;\r\nrtl818x_iowrite8(priv, &priv->map->MSR, reg);\r\nmutex_unlock(&priv->conf_mutex);\r\n}\r\nif (changed & (BSS_CHANGED_ERP_SLOT | BSS_CHANGED_ERP_PREAMBLE))\r\nrtl8187_conf_erp(priv, info->use_short_slot,\r\ninfo->use_short_preamble);\r\nif (changed & BSS_CHANGED_BEACON_ENABLED)\r\nvif_priv->enable_beacon = info->enable_beacon;\r\nif (changed & (BSS_CHANGED_BEACON_ENABLED | BSS_CHANGED_BEACON)) {\r\ncancel_delayed_work_sync(&vif_priv->beacon_work);\r\nif (vif_priv->enable_beacon)\r\nschedule_work(&vif_priv->beacon_work.work);\r\n}\r\n}\r\nstatic u64 rtl8187_prepare_multicast(struct ieee80211_hw *dev,\r\nstruct netdev_hw_addr_list *mc_list)\r\n{\r\nreturn netdev_hw_addr_list_count(mc_list);\r\n}\r\nstatic void rtl8187_configure_filter(struct ieee80211_hw *dev,\r\nunsigned int changed_flags,\r\nunsigned int *total_flags,\r\nu64 multicast)\r\n{\r\nstruct rtl8187_priv *priv = dev->priv;\r\nif (changed_flags & FIF_FCSFAIL)\r\npriv->rx_conf ^= RTL818X_RX_CONF_FCS;\r\nif (changed_flags & FIF_CONTROL)\r\npriv->rx_conf ^= RTL818X_RX_CONF_CTRL;\r\nif (changed_flags & FIF_OTHER_BSS)\r\npriv->rx_conf ^= RTL818X_RX_CONF_MONITOR;\r\nif (*total_flags & FIF_ALLMULTI || multicast > 0)\r\npriv->rx_conf |= RTL818X_RX_CONF_MULTICAST;\r\nelse\r\npriv->rx_conf &= ~RTL818X_RX_CONF_MULTICAST;\r\n*total_flags = 0;\r\nif (priv->rx_conf & RTL818X_RX_CONF_FCS)\r\n*total_flags |= FIF_FCSFAIL;\r\nif (priv->rx_conf & RTL818X_RX_CONF_CTRL)\r\n*total_flags |= FIF_CONTROL;\r\nif (priv->rx_conf & RTL818X_RX_CONF_MONITOR)\r\n*total_flags |= FIF_OTHER_BSS;\r\nif (priv->rx_conf & RTL818X_RX_CONF_MULTICAST)\r\n*total_flags |= FIF_ALLMULTI;\r\nrtl818x_iowrite32_async(priv, &priv->map->RX_CONF, priv->rx_conf);\r\n}\r\nstatic int rtl8187_conf_tx(struct ieee80211_hw *dev,\r\nstruct ieee80211_vif *vif, u16 queue,\r\nconst struct ieee80211_tx_queue_params *params)\r\n{\r\nstruct rtl8187_priv *priv = dev->priv;\r\nu8 cw_min, cw_max;\r\nif (queue > 3)\r\nreturn -EINVAL;\r\ncw_min = fls(params->cw_min);\r\ncw_max = fls(params->cw_max);\r\nif (priv->is_rtl8187b) {\r\npriv->aifsn[queue] = params->aifs;\r\nrtl818x_iowrite32(priv, rtl8187b_ac_addr[queue],\r\n(params->txop << 16) | (cw_max << 12) |\r\n(cw_min << 8) | (params->aifs *\r\npriv->slot_time + SIFS_TIME));\r\n} else {\r\nif (queue != 0)\r\nreturn -EINVAL;\r\nrtl818x_iowrite8(priv, &priv->map->CW_VAL,\r\ncw_min | (cw_max << 4));\r\n}\r\nreturn 0;\r\n}\r\nstatic void rtl8187_eeprom_register_read(struct eeprom_93cx6 *eeprom)\r\n{\r\nstruct ieee80211_hw *dev = eeprom->data;\r\nstruct rtl8187_priv *priv = dev->priv;\r\nu8 reg = rtl818x_ioread8(priv, &priv->map->EEPROM_CMD);\r\neeprom->reg_data_in = reg & RTL818X_EEPROM_CMD_WRITE;\r\neeprom->reg_data_out = reg & RTL818X_EEPROM_CMD_READ;\r\neeprom->reg_data_clock = reg & RTL818X_EEPROM_CMD_CK;\r\neeprom->reg_chip_select = reg & RTL818X_EEPROM_CMD_CS;\r\n}\r\nstatic void rtl8187_eeprom_register_write(struct eeprom_93cx6 *eeprom)\r\n{\r\nstruct ieee80211_hw *dev = eeprom->data;\r\nstruct rtl8187_priv *priv = dev->priv;\r\nu8 reg = RTL818X_EEPROM_CMD_PROGRAM;\r\nif (eeprom->reg_data_in)\r\nreg |= RTL818X_EEPROM_CMD_WRITE;\r\nif (eeprom->reg_data_out)\r\nreg |= RTL818X_EEPROM_CMD_READ;\r\nif (eeprom->reg_data_clock)\r\nreg |= RTL818X_EEPROM_CMD_CK;\r\nif (eeprom->reg_chip_select)\r\nreg |= RTL818X_EEPROM_CMD_CS;\r\nrtl818x_iowrite8(priv, &priv->map->EEPROM_CMD, reg);\r\nudelay(10);\r\n}\r\nstatic int rtl8187_probe(struct usb_interface *intf,\r\nconst struct usb_device_id *id)\r\n{\r\nstruct usb_device *udev = interface_to_usbdev(intf);\r\nstruct ieee80211_hw *dev;\r\nstruct rtl8187_priv *priv;\r\nstruct eeprom_93cx6 eeprom;\r\nstruct ieee80211_channel *channel;\r\nconst char *chip_name;\r\nu16 txpwr, reg;\r\nu16 product_id = le16_to_cpu(udev->descriptor.idProduct);\r\nint err, i;\r\nu8 mac_addr[ETH_ALEN];\r\ndev = ieee80211_alloc_hw(sizeof(*priv), &rtl8187_ops);\r\nif (!dev) {\r\nprintk(KERN_ERR "rtl8187: ieee80211 alloc failed\n");\r\nreturn -ENOMEM;\r\n}\r\npriv = dev->priv;\r\npriv->is_rtl8187b = (id->driver_info == DEVICE_RTL8187B);\r\npriv->io_dmabuf = kmalloc(sizeof(*priv->io_dmabuf), GFP_KERNEL);\r\nif (!priv->io_dmabuf) {\r\nerr = -ENOMEM;\r\ngoto err_free_dev;\r\n}\r\nmutex_init(&priv->io_mutex);\r\nSET_IEEE80211_DEV(dev, &intf->dev);\r\nusb_set_intfdata(intf, dev);\r\npriv->udev = udev;\r\nusb_get_dev(udev);\r\nskb_queue_head_init(&priv->rx_queue);\r\nBUILD_BUG_ON(sizeof(priv->channels) != sizeof(rtl818x_channels));\r\nBUILD_BUG_ON(sizeof(priv->rates) != sizeof(rtl818x_rates));\r\nmemcpy(priv->channels, rtl818x_channels, sizeof(rtl818x_channels));\r\nmemcpy(priv->rates, rtl818x_rates, sizeof(rtl818x_rates));\r\npriv->map = (struct rtl818x_csr *)0xFF00;\r\npriv->band.band = IEEE80211_BAND_2GHZ;\r\npriv->band.channels = priv->channels;\r\npriv->band.n_channels = ARRAY_SIZE(rtl818x_channels);\r\npriv->band.bitrates = priv->rates;\r\npriv->band.n_bitrates = ARRAY_SIZE(rtl818x_rates);\r\ndev->wiphy->bands[IEEE80211_BAND_2GHZ] = &priv->band;\r\nieee80211_hw_set(dev, RX_INCLUDES_FCS);\r\nieee80211_hw_set(dev, HOST_BROADCAST_PS_BUFFERING);\r\nieee80211_hw_set(dev, SIGNAL_DBM);\r\ndev->max_rates = 1;\r\ndev->max_rate_tries = RETRY_COUNT;\r\neeprom.data = dev;\r\neeprom.register_read = rtl8187_eeprom_register_read;\r\neeprom.register_write = rtl8187_eeprom_register_write;\r\nif (rtl818x_ioread32(priv, &priv->map->RX_CONF) & (1 << 6))\r\neeprom.width = PCI_EEPROM_WIDTH_93C66;\r\nelse\r\neeprom.width = PCI_EEPROM_WIDTH_93C46;\r\nrtl818x_iowrite8(priv, &priv->map->EEPROM_CMD, RTL818X_EEPROM_CMD_CONFIG);\r\nudelay(10);\r\neeprom_93cx6_multiread(&eeprom, RTL8187_EEPROM_MAC_ADDR,\r\n(__le16 __force *)mac_addr, 3);\r\nif (!is_valid_ether_addr(mac_addr)) {\r\nprintk(KERN_WARNING "rtl8187: Invalid hwaddr! Using randomly "\r\n"generated MAC address\n");\r\neth_random_addr(mac_addr);\r\n}\r\nSET_IEEE80211_PERM_ADDR(dev, mac_addr);\r\nchannel = priv->channels;\r\nfor (i = 0; i < 3; i++) {\r\neeprom_93cx6_read(&eeprom, RTL8187_EEPROM_TXPWR_CHAN_1 + i,\r\n&txpwr);\r\n(*channel++).hw_value = txpwr & 0xFF;\r\n(*channel++).hw_value = txpwr >> 8;\r\n}\r\nfor (i = 0; i < 2; i++) {\r\neeprom_93cx6_read(&eeprom, RTL8187_EEPROM_TXPWR_CHAN_4 + i,\r\n&txpwr);\r\n(*channel++).hw_value = txpwr & 0xFF;\r\n(*channel++).hw_value = txpwr >> 8;\r\n}\r\neeprom_93cx6_read(&eeprom, RTL8187_EEPROM_TXPWR_BASE,\r\n&priv->txpwr_base);\r\nreg = rtl818x_ioread8(priv, &priv->map->PGSELECT) & ~1;\r\nrtl818x_iowrite8(priv, &priv->map->PGSELECT, reg | 1);\r\npriv->asic_rev = rtl818x_ioread8(priv, (u8 *)0xFFFE) & 0x3;\r\nrtl818x_iowrite8(priv, &priv->map->PGSELECT, reg);\r\nrtl818x_iowrite8(priv, &priv->map->EEPROM_CMD, RTL818X_EEPROM_CMD_NORMAL);\r\nif (!priv->is_rtl8187b) {\r\nu32 reg32;\r\nreg32 = rtl818x_ioread32(priv, &priv->map->TX_CONF);\r\nreg32 &= RTL818X_TX_CONF_HWVER_MASK;\r\nswitch (reg32) {\r\ncase RTL818X_TX_CONF_R8187vD_B:\r\nchip_name = "RTL8187BvB(early)";\r\npriv->is_rtl8187b = 1;\r\npriv->hw_rev = RTL8187BvB;\r\nbreak;\r\ncase RTL818X_TX_CONF_R8187vD:\r\nchip_name = "RTL8187vD";\r\nbreak;\r\ndefault:\r\nchip_name = "RTL8187vB (default)";\r\n}\r\n} else {\r\nswitch (rtl818x_ioread8(priv, (u8 *)0xFFE1)) {\r\ncase RTL818X_R8187B_B:\r\nchip_name = "RTL8187BvB";\r\npriv->hw_rev = RTL8187BvB;\r\nbreak;\r\ncase RTL818X_R8187B_D:\r\nchip_name = "RTL8187BvD";\r\npriv->hw_rev = RTL8187BvD;\r\nbreak;\r\ncase RTL818X_R8187B_E:\r\nchip_name = "RTL8187BvE";\r\npriv->hw_rev = RTL8187BvE;\r\nbreak;\r\ndefault:\r\nchip_name = "RTL8187BvB (default)";\r\npriv->hw_rev = RTL8187BvB;\r\n}\r\n}\r\nif (!priv->is_rtl8187b) {\r\nfor (i = 0; i < 2; i++) {\r\neeprom_93cx6_read(&eeprom,\r\nRTL8187_EEPROM_TXPWR_CHAN_6 + i,\r\n&txpwr);\r\n(*channel++).hw_value = txpwr & 0xFF;\r\n(*channel++).hw_value = txpwr >> 8;\r\n}\r\n} else {\r\neeprom_93cx6_read(&eeprom, RTL8187_EEPROM_TXPWR_CHAN_6,\r\n&txpwr);\r\n(*channel++).hw_value = txpwr & 0xFF;\r\neeprom_93cx6_read(&eeprom, 0x0A, &txpwr);\r\n(*channel++).hw_value = txpwr & 0xFF;\r\neeprom_93cx6_read(&eeprom, 0x1C, &txpwr);\r\n(*channel++).hw_value = txpwr & 0xFF;\r\n(*channel++).hw_value = txpwr >> 8;\r\n}\r\npriv->rfkill_mask = RFKILL_MASK_8187_89_97;\r\nif (product_id == 0x8197 || product_id == 0x8198) {\r\neeprom_93cx6_read(&eeprom, RTL8187_EEPROM_SELECT_GPIO, &reg);\r\nif (reg & 0xFF00)\r\npriv->rfkill_mask = RFKILL_MASK_8198;\r\n}\r\ndev->vif_data_size = sizeof(struct rtl8187_vif);\r\ndev->wiphy->interface_modes = BIT(NL80211_IFTYPE_STATION) |\r\nBIT(NL80211_IFTYPE_ADHOC) ;\r\nif ((id->driver_info == DEVICE_RTL8187) && priv->is_rtl8187b)\r\nprintk(KERN_INFO "rtl8187: inconsistency between id with OEM"\r\n" info!\n");\r\npriv->rf = rtl8187_detect_rf(dev);\r\ndev->extra_tx_headroom = (!priv->is_rtl8187b) ?\r\nsizeof(struct rtl8187_tx_hdr) :\r\nsizeof(struct rtl8187b_tx_hdr);\r\nif (!priv->is_rtl8187b)\r\ndev->queues = 1;\r\nelse\r\ndev->queues = 4;\r\nerr = ieee80211_register_hw(dev);\r\nif (err) {\r\nprintk(KERN_ERR "rtl8187: Cannot register device\n");\r\ngoto err_free_dmabuf;\r\n}\r\nmutex_init(&priv->conf_mutex);\r\nskb_queue_head_init(&priv->b_tx_status.queue);\r\nwiphy_info(dev->wiphy, "hwaddr %pM, %s V%d + %s, rfkill mask %d\n",\r\nmac_addr, chip_name, priv->asic_rev, priv->rf->name,\r\npriv->rfkill_mask);\r\n#ifdef CONFIG_RTL8187_LEDS\r\neeprom_93cx6_read(&eeprom, 0x3F, &reg);\r\nreg &= 0xFF;\r\nrtl8187_leds_init(dev, reg);\r\n#endif\r\nrtl8187_rfkill_init(dev);\r\nreturn 0;\r\nerr_free_dmabuf:\r\nkfree(priv->io_dmabuf);\r\nusb_set_intfdata(intf, NULL);\r\nusb_put_dev(udev);\r\nerr_free_dev:\r\nieee80211_free_hw(dev);\r\nreturn err;\r\n}\r\nstatic void rtl8187_disconnect(struct usb_interface *intf)\r\n{\r\nstruct ieee80211_hw *dev = usb_get_intfdata(intf);\r\nstruct rtl8187_priv *priv;\r\nif (!dev)\r\nreturn;\r\n#ifdef CONFIG_RTL8187_LEDS\r\nrtl8187_leds_exit(dev);\r\n#endif\r\nrtl8187_rfkill_exit(dev);\r\nieee80211_unregister_hw(dev);\r\npriv = dev->priv;\r\nusb_reset_device(priv->udev);\r\nusb_put_dev(interface_to_usbdev(intf));\r\nkfree(priv->io_dmabuf);\r\nieee80211_free_hw(dev);\r\n}
