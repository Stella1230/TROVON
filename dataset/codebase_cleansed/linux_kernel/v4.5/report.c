static const void *find_first_bad_addr(const void *addr, size_t size)\r\n{\r\nu8 shadow_val = *(u8 *)kasan_mem_to_shadow(addr);\r\nconst void *first_bad_addr = addr;\r\nwhile (!shadow_val && first_bad_addr < addr + size) {\r\nfirst_bad_addr += KASAN_SHADOW_SCALE_SIZE;\r\nshadow_val = *(u8 *)kasan_mem_to_shadow(first_bad_addr);\r\n}\r\nreturn first_bad_addr;\r\n}\r\nstatic void print_error_description(struct kasan_access_info *info)\r\n{\r\nconst char *bug_type = "unknown-crash";\r\nu8 *shadow_addr;\r\ninfo->first_bad_addr = find_first_bad_addr(info->access_addr,\r\ninfo->access_size);\r\nshadow_addr = (u8 *)kasan_mem_to_shadow(info->first_bad_addr);\r\nif (*shadow_addr > 0 && *shadow_addr <= KASAN_SHADOW_SCALE_SIZE - 1)\r\nshadow_addr++;\r\nswitch (*shadow_addr) {\r\ncase 0 ... KASAN_SHADOW_SCALE_SIZE - 1:\r\nbug_type = "out-of-bounds";\r\nbreak;\r\ncase KASAN_PAGE_REDZONE:\r\ncase KASAN_KMALLOC_REDZONE:\r\nbug_type = "slab-out-of-bounds";\r\nbreak;\r\ncase KASAN_GLOBAL_REDZONE:\r\nbug_type = "global-out-of-bounds";\r\nbreak;\r\ncase KASAN_STACK_LEFT:\r\ncase KASAN_STACK_MID:\r\ncase KASAN_STACK_RIGHT:\r\ncase KASAN_STACK_PARTIAL:\r\nbug_type = "stack-out-of-bounds";\r\nbreak;\r\ncase KASAN_FREE_PAGE:\r\ncase KASAN_KMALLOC_FREE:\r\nbug_type = "use-after-free";\r\nbreak;\r\n}\r\npr_err("BUG: KASAN: %s in %pS at addr %p\n",\r\nbug_type, (void *)info->ip,\r\ninfo->access_addr);\r\npr_err("%s of size %zu by task %s/%d\n",\r\ninfo->is_write ? "Write" : "Read",\r\ninfo->access_size, current->comm, task_pid_nr(current));\r\n}\r\nstatic inline bool kernel_or_module_addr(const void *addr)\r\n{\r\nif (addr >= (void *)_stext && addr < (void *)_end)\r\nreturn true;\r\nif (is_module_address((unsigned long)addr))\r\nreturn true;\r\nreturn false;\r\n}\r\nstatic inline bool init_task_stack_addr(const void *addr)\r\n{\r\nreturn addr >= (void *)&init_thread_union.stack &&\r\n(addr <= (void *)&init_thread_union.stack +\r\nsizeof(init_thread_union.stack));\r\n}\r\nstatic void print_address_description(struct kasan_access_info *info)\r\n{\r\nconst void *addr = info->access_addr;\r\nif ((addr >= (void *)PAGE_OFFSET) &&\r\n(addr < high_memory)) {\r\nstruct page *page = virt_to_head_page(addr);\r\nif (PageSlab(page)) {\r\nvoid *object;\r\nstruct kmem_cache *cache = page->slab_cache;\r\nvoid *last_object;\r\nobject = virt_to_obj(cache, page_address(page), addr);\r\nlast_object = page_address(page) +\r\npage->objects * cache->size;\r\nif (unlikely(object > last_object))\r\nobject = last_object;\r\nobject_err(cache, page, object,\r\n"kasan: bad access detected");\r\nreturn;\r\n}\r\ndump_page(page, "kasan: bad access detected");\r\n}\r\nif (kernel_or_module_addr(addr)) {\r\nif (!init_task_stack_addr(addr))\r\npr_err("Address belongs to variable %pS\n", addr);\r\n}\r\ndump_stack();\r\n}\r\nstatic bool row_is_guilty(const void *row, const void *guilty)\r\n{\r\nreturn (row <= guilty) && (guilty < row + SHADOW_BYTES_PER_ROW);\r\n}\r\nstatic int shadow_pointer_offset(const void *row, const void *shadow)\r\n{\r\nreturn 3 + (BITS_PER_LONG/8)*2 + (shadow - row)*2 +\r\n(shadow - row) / SHADOW_BYTES_PER_BLOCK + 1;\r\n}\r\nstatic void print_shadow_for_address(const void *addr)\r\n{\r\nint i;\r\nconst void *shadow = kasan_mem_to_shadow(addr);\r\nconst void *shadow_row;\r\nshadow_row = (void *)round_down((unsigned long)shadow,\r\nSHADOW_BYTES_PER_ROW)\r\n- SHADOW_ROWS_AROUND_ADDR * SHADOW_BYTES_PER_ROW;\r\npr_err("Memory state around the buggy address:\n");\r\nfor (i = -SHADOW_ROWS_AROUND_ADDR; i <= SHADOW_ROWS_AROUND_ADDR; i++) {\r\nconst void *kaddr = kasan_shadow_to_mem(shadow_row);\r\nchar buffer[4 + (BITS_PER_LONG/8)*2];\r\nchar shadow_buf[SHADOW_BYTES_PER_ROW];\r\nsnprintf(buffer, sizeof(buffer),\r\n(i == 0) ? ">%p: " : " %p: ", kaddr);\r\nmemcpy(shadow_buf, shadow_row, SHADOW_BYTES_PER_ROW);\r\nprint_hex_dump(KERN_ERR, buffer,\r\nDUMP_PREFIX_NONE, SHADOW_BYTES_PER_ROW, 1,\r\nshadow_buf, SHADOW_BYTES_PER_ROW, 0);\r\nif (row_is_guilty(shadow_row, shadow))\r\npr_err("%*c\n",\r\nshadow_pointer_offset(shadow_row, shadow),\r\n'^');\r\nshadow_row += SHADOW_BYTES_PER_ROW;\r\n}\r\n}\r\nstatic void kasan_report_error(struct kasan_access_info *info)\r\n{\r\nunsigned long flags;\r\nconst char *bug_type;\r\nkasan_disable_current();\r\nspin_lock_irqsave(&report_lock, flags);\r\npr_err("================================="\r\n"=================================\n");\r\nif (info->access_addr <\r\nkasan_shadow_to_mem((void *)KASAN_SHADOW_START)) {\r\nif ((unsigned long)info->access_addr < PAGE_SIZE)\r\nbug_type = "null-ptr-deref";\r\nelse if ((unsigned long)info->access_addr < TASK_SIZE)\r\nbug_type = "user-memory-access";\r\nelse\r\nbug_type = "wild-memory-access";\r\npr_err("BUG: KASAN: %s on address %p\n",\r\nbug_type, info->access_addr);\r\npr_err("%s of size %zu by task %s/%d\n",\r\ninfo->is_write ? "Write" : "Read",\r\ninfo->access_size, current->comm,\r\ntask_pid_nr(current));\r\ndump_stack();\r\n} else {\r\nprint_error_description(info);\r\nprint_address_description(info);\r\nprint_shadow_for_address(info->first_bad_addr);\r\n}\r\npr_err("================================="\r\n"=================================\n");\r\nadd_taint(TAINT_BAD_PAGE, LOCKDEP_NOW_UNRELIABLE);\r\nspin_unlock_irqrestore(&report_lock, flags);\r\nkasan_enable_current();\r\n}\r\nvoid kasan_report(unsigned long addr, size_t size,\r\nbool is_write, unsigned long ip)\r\n{\r\nstruct kasan_access_info info;\r\nif (likely(!kasan_report_enabled()))\r\nreturn;\r\ninfo.access_addr = (void *)addr;\r\ninfo.access_size = size;\r\ninfo.is_write = is_write;\r\ninfo.ip = ip;\r\nkasan_report_error(&info);\r\n}\r\nvoid __asan_report_load_n_noabort(unsigned long addr, size_t size)\r\n{\r\nkasan_report(addr, size, false, _RET_IP_);\r\n}\r\nvoid __asan_report_store_n_noabort(unsigned long addr, size_t size)\r\n{\r\nkasan_report(addr, size, true, _RET_IP_);\r\n}
