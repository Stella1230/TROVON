static void sample_cpy(u8 *dst, const u8 *src, u32 len, bool is_s32)\r\n{\r\nstatic const unsigned map[8] = { 0, 1, 5, 4, 2, 3, 6, 7 };\r\nunsigned idx = 0;\r\nwhile (len >= (is_s32 ? 4 : 2)) {\r\nunsigned offset = map[idx] * 4;\r\nu32 val = src[offset + 1] + (src[offset + 2] << 8) +\r\n(src[offset + 3] << 16);\r\nif (is_s32) {\r\n*dst++ = 0;\r\n*dst++ = val & 0xff;\r\n}\r\n*dst++ = (val >> 8) & 0xff;\r\n*dst++ = (val >> 16) & 0xff;\r\nlen -= is_s32 ? 4 : 2;\r\nidx++;\r\n}\r\n}\r\nstatic void cobalt_alsa_announce_pcm_data(struct snd_cobalt_card *cobsc,\r\nu8 *pcm_data,\r\nsize_t skip,\r\nsize_t samples)\r\n{\r\nstruct snd_pcm_substream *substream;\r\nstruct snd_pcm_runtime *runtime;\r\nunsigned long flags;\r\nunsigned int oldptr;\r\nunsigned int stride;\r\nint length = samples;\r\nint period_elapsed = 0;\r\nbool is_s32;\r\ndprintk("cobalt alsa announce ptr=%p data=%p num_bytes=%zd\n", cobsc,\r\npcm_data, samples);\r\nsubstream = cobsc->capture_pcm_substream;\r\nif (substream == NULL) {\r\ndprintk("substream was NULL\n");\r\nreturn;\r\n}\r\nruntime = substream->runtime;\r\nif (runtime == NULL) {\r\ndprintk("runtime was NULL\n");\r\nreturn;\r\n}\r\nis_s32 = runtime->format == SNDRV_PCM_FORMAT_S32_LE;\r\nstride = runtime->frame_bits >> 3;\r\nif (stride == 0) {\r\ndprintk("stride is zero\n");\r\nreturn;\r\n}\r\nif (length == 0) {\r\ndprintk("%s: length was zero\n", __func__);\r\nreturn;\r\n}\r\nif (runtime->dma_area == NULL) {\r\ndprintk("dma area was NULL - ignoring\n");\r\nreturn;\r\n}\r\noldptr = cobsc->hwptr_done_capture;\r\nif (oldptr + length >= runtime->buffer_size) {\r\nunsigned int cnt = runtime->buffer_size - oldptr;\r\nunsigned i;\r\nfor (i = 0; i < cnt; i++)\r\nsample_cpy(runtime->dma_area + (oldptr + i) * stride,\r\npcm_data + i * skip,\r\nstride, is_s32);\r\nfor (i = cnt; i < length; i++)\r\nsample_cpy(runtime->dma_area + (i - cnt) * stride,\r\npcm_data + i * skip, stride, is_s32);\r\n} else {\r\nunsigned i;\r\nfor (i = 0; i < length; i++)\r\nsample_cpy(runtime->dma_area + (oldptr + i) * stride,\r\npcm_data + i * skip,\r\nstride, is_s32);\r\n}\r\nsnd_pcm_stream_lock_irqsave(substream, flags);\r\ncobsc->hwptr_done_capture += length;\r\nif (cobsc->hwptr_done_capture >=\r\nruntime->buffer_size)\r\ncobsc->hwptr_done_capture -=\r\nruntime->buffer_size;\r\ncobsc->capture_transfer_done += length;\r\nif (cobsc->capture_transfer_done >=\r\nruntime->period_size) {\r\ncobsc->capture_transfer_done -=\r\nruntime->period_size;\r\nperiod_elapsed = 1;\r\n}\r\nsnd_pcm_stream_unlock_irqrestore(substream, flags);\r\nif (period_elapsed)\r\nsnd_pcm_period_elapsed(substream);\r\n}\r\nstatic int alsa_fnc(struct vb2_buffer *vb, void *priv)\r\n{\r\nstruct cobalt_stream *s = priv;\r\nunsigned char *p = vb2_plane_vaddr(vb, 0);\r\nint i;\r\nif (pcm_debug) {\r\npr_info("alsa: ");\r\nfor (i = 0; i < 8 * 4; i++) {\r\nif (!(i & 3))\r\npr_cont(" ");\r\npr_cont("%02x", p[i]);\r\n}\r\npr_cont("\n");\r\n}\r\ncobalt_alsa_announce_pcm_data(s->alsa,\r\nvb2_plane_vaddr(vb, 0),\r\n8 * 4,\r\nvb2_get_plane_payload(vb, 0) / (8 * 4));\r\nreturn 0;\r\n}\r\nstatic int snd_cobalt_pcm_capture_open(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct snd_cobalt_card *cobsc = snd_pcm_substream_chip(substream);\r\nstruct cobalt_stream *s = cobsc->s;\r\nruntime->hw = snd_cobalt_hdmi_capture;\r\nsnd_pcm_hw_constraint_integer(runtime, SNDRV_PCM_HW_PARAM_PERIODS);\r\ncobsc->capture_pcm_substream = substream;\r\nruntime->private_data = s;\r\ncobsc->alsa_record_cnt++;\r\nif (cobsc->alsa_record_cnt == 1) {\r\nint rc;\r\nrc = vb2_thread_start(&s->q, alsa_fnc, s, s->vdev.name);\r\nif (rc) {\r\ncobsc->alsa_record_cnt--;\r\nreturn rc;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_cobalt_pcm_capture_close(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_cobalt_card *cobsc = snd_pcm_substream_chip(substream);\r\nstruct cobalt_stream *s = cobsc->s;\r\ncobsc->alsa_record_cnt--;\r\nif (cobsc->alsa_record_cnt == 0)\r\nvb2_thread_stop(&s->q);\r\nreturn 0;\r\n}\r\nstatic int snd_cobalt_pcm_ioctl(struct snd_pcm_substream *substream,\r\nunsigned int cmd, void *arg)\r\n{\r\nreturn snd_pcm_lib_ioctl(substream, cmd, arg);\r\n}\r\nstatic int snd_pcm_alloc_vmalloc_buffer(struct snd_pcm_substream *subs,\r\nsize_t size)\r\n{\r\nstruct snd_pcm_runtime *runtime = subs->runtime;\r\ndprintk("Allocating vbuffer\n");\r\nif (runtime->dma_area) {\r\nif (runtime->dma_bytes > size)\r\nreturn 0;\r\nvfree(runtime->dma_area);\r\n}\r\nruntime->dma_area = vmalloc(size);\r\nif (!runtime->dma_area)\r\nreturn -ENOMEM;\r\nruntime->dma_bytes = size;\r\nreturn 0;\r\n}\r\nstatic int snd_cobalt_pcm_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params)\r\n{\r\ndprintk("%s called\n", __func__);\r\nreturn snd_pcm_alloc_vmalloc_buffer(substream,\r\nparams_buffer_bytes(params));\r\n}\r\nstatic int snd_cobalt_pcm_hw_free(struct snd_pcm_substream *substream)\r\n{\r\nif (substream->runtime->dma_area) {\r\ndprintk("freeing pcm capture region\n");\r\nvfree(substream->runtime->dma_area);\r\nsubstream->runtime->dma_area = NULL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_cobalt_pcm_prepare(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_cobalt_card *cobsc = snd_pcm_substream_chip(substream);\r\ncobsc->hwptr_done_capture = 0;\r\ncobsc->capture_transfer_done = 0;\r\nreturn 0;\r\n}\r\nstatic int snd_cobalt_pcm_trigger(struct snd_pcm_substream *substream, int cmd)\r\n{\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\nreturn 0;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic\r\nsnd_pcm_uframes_t snd_cobalt_pcm_pointer(struct snd_pcm_substream *substream)\r\n{\r\nsnd_pcm_uframes_t hwptr_done;\r\nstruct snd_cobalt_card *cobsc = snd_pcm_substream_chip(substream);\r\nhwptr_done = cobsc->hwptr_done_capture;\r\nreturn hwptr_done;\r\n}\r\nstatic void pb_sample_cpy(u8 *dst, const u8 *src, u32 len, bool is_s32)\r\n{\r\nstatic const unsigned map[8] = { 0, 1, 5, 4, 2, 3, 6, 7 };\r\nunsigned idx = 0;\r\nwhile (len >= (is_s32 ? 4 : 2)) {\r\nunsigned offset = map[idx] * 4;\r\nu8 *out = dst + offset;\r\n*out++ = 0;\r\nif (is_s32) {\r\nsrc++;\r\n*out++ = *src++;\r\n} else {\r\n*out++ = 0;\r\n}\r\n*out++ = *src++;\r\n*out = *src++;\r\nlen -= is_s32 ? 4 : 2;\r\nidx++;\r\n}\r\n}\r\nstatic void cobalt_alsa_pb_pcm_data(struct snd_cobalt_card *cobsc,\r\nu8 *pcm_data,\r\nsize_t skip,\r\nsize_t samples)\r\n{\r\nstruct snd_pcm_substream *substream;\r\nstruct snd_pcm_runtime *runtime;\r\nunsigned long flags;\r\nunsigned int pos;\r\nunsigned int stride;\r\nbool is_s32;\r\nunsigned i;\r\ndprintk("cobalt alsa pb ptr=%p data=%p samples=%zd\n", cobsc,\r\npcm_data, samples);\r\nsubstream = cobsc->playback_pcm_substream;\r\nif (substream == NULL) {\r\ndprintk("substream was NULL\n");\r\nreturn;\r\n}\r\nruntime = substream->runtime;\r\nif (runtime == NULL) {\r\ndprintk("runtime was NULL\n");\r\nreturn;\r\n}\r\nis_s32 = runtime->format == SNDRV_PCM_FORMAT_S32_LE;\r\nstride = runtime->frame_bits >> 3;\r\nif (stride == 0) {\r\ndprintk("stride is zero\n");\r\nreturn;\r\n}\r\nif (samples == 0) {\r\ndprintk("%s: samples was zero\n", __func__);\r\nreturn;\r\n}\r\nif (runtime->dma_area == NULL) {\r\ndprintk("dma area was NULL - ignoring\n");\r\nreturn;\r\n}\r\npos = cobsc->pb_pos % cobsc->pb_size;\r\nfor (i = 0; i < cobsc->pb_count / (8 * 4); i++)\r\npb_sample_cpy(pcm_data + i * skip,\r\nruntime->dma_area + pos + i * stride,\r\nstride, is_s32);\r\nsnd_pcm_stream_lock_irqsave(substream, flags);\r\ncobsc->pb_pos += i * stride;\r\nsnd_pcm_stream_unlock_irqrestore(substream, flags);\r\nif (cobsc->pb_pos % cobsc->pb_count == 0)\r\nsnd_pcm_period_elapsed(substream);\r\n}\r\nstatic int alsa_pb_fnc(struct vb2_buffer *vb, void *priv)\r\n{\r\nstruct cobalt_stream *s = priv;\r\nif (s->alsa->alsa_pb_channel)\r\ncobalt_alsa_pb_pcm_data(s->alsa,\r\nvb2_plane_vaddr(vb, 0),\r\n8 * 4,\r\nvb2_get_plane_payload(vb, 0) / (8 * 4));\r\nreturn 0;\r\n}\r\nstatic int snd_cobalt_pcm_playback_open(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_cobalt_card *cobsc = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct cobalt_stream *s = cobsc->s;\r\nruntime->hw = snd_cobalt_playback;\r\nsnd_pcm_hw_constraint_integer(runtime, SNDRV_PCM_HW_PARAM_PERIODS);\r\ncobsc->playback_pcm_substream = substream;\r\nruntime->private_data = s;\r\ncobsc->alsa_playback_cnt++;\r\nif (cobsc->alsa_playback_cnt == 1) {\r\nint rc;\r\nrc = vb2_thread_start(&s->q, alsa_pb_fnc, s, s->vdev.name);\r\nif (rc) {\r\ncobsc->alsa_playback_cnt--;\r\nreturn rc;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_cobalt_pcm_playback_close(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_cobalt_card *cobsc = snd_pcm_substream_chip(substream);\r\nstruct cobalt_stream *s = cobsc->s;\r\ncobsc->alsa_playback_cnt--;\r\nif (cobsc->alsa_playback_cnt == 0)\r\nvb2_thread_stop(&s->q);\r\nreturn 0;\r\n}\r\nstatic int snd_cobalt_pcm_pb_prepare(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_cobalt_card *cobsc = snd_pcm_substream_chip(substream);\r\ncobsc->pb_size = snd_pcm_lib_buffer_bytes(substream);\r\ncobsc->pb_count = snd_pcm_lib_period_bytes(substream);\r\ncobsc->pb_pos = 0;\r\nreturn 0;\r\n}\r\nstatic int snd_cobalt_pcm_pb_trigger(struct snd_pcm_substream *substream,\r\nint cmd)\r\n{\r\nstruct snd_cobalt_card *cobsc = snd_pcm_substream_chip(substream);\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\nif (cobsc->alsa_pb_channel)\r\nreturn -EBUSY;\r\ncobsc->alsa_pb_channel = true;\r\nreturn 0;\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\ncobsc->alsa_pb_channel = false;\r\nreturn 0;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic\r\nsnd_pcm_uframes_t snd_cobalt_pcm_pb_pointer(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_cobalt_card *cobsc = snd_pcm_substream_chip(substream);\r\nsize_t ptr;\r\nptr = cobsc->pb_pos;\r\nreturn bytes_to_frames(substream->runtime, ptr) %\r\nsubstream->runtime->buffer_size;\r\n}\r\nstatic struct page *snd_pcm_get_vmalloc_page(struct snd_pcm_substream *subs,\r\nunsigned long offset)\r\n{\r\nvoid *pageptr = subs->runtime->dma_area + offset;\r\nreturn vmalloc_to_page(pageptr);\r\n}\r\nint snd_cobalt_pcm_create(struct snd_cobalt_card *cobsc)\r\n{\r\nstruct snd_pcm *sp;\r\nstruct snd_card *sc = cobsc->sc;\r\nstruct cobalt_stream *s = cobsc->s;\r\nstruct cobalt *cobalt = s->cobalt;\r\nint ret;\r\ns->q.gfp_flags |= __GFP_ZERO;\r\nif (!s->is_output) {\r\ncobalt_s_bit_sysctrl(cobalt,\r\nCOBALT_SYS_CTRL_AUDIO_IPP_RESETN_BIT(s->video_channel),\r\n0);\r\nmdelay(2);\r\ncobalt_s_bit_sysctrl(cobalt,\r\nCOBALT_SYS_CTRL_AUDIO_IPP_RESETN_BIT(s->video_channel),\r\n1);\r\nmdelay(1);\r\nret = snd_pcm_new(sc, "Cobalt PCM-In HDMI",\r\n0,\r\n0,\r\n1,\r\n&sp);\r\nif (ret) {\r\ncobalt_err("snd_cobalt_pcm_create() failed for input with err %d\n",\r\nret);\r\ngoto err_exit;\r\n}\r\nsnd_pcm_set_ops(sp, SNDRV_PCM_STREAM_CAPTURE,\r\n&snd_cobalt_pcm_capture_ops);\r\nsp->info_flags = 0;\r\nsp->private_data = cobsc;\r\nstrlcpy(sp->name, "cobalt", sizeof(sp->name));\r\n} else {\r\ncobalt_s_bit_sysctrl(cobalt,\r\nCOBALT_SYS_CTRL_AUDIO_OPP_RESETN_BIT, 0);\r\nmdelay(2);\r\ncobalt_s_bit_sysctrl(cobalt,\r\nCOBALT_SYS_CTRL_AUDIO_OPP_RESETN_BIT, 1);\r\nmdelay(1);\r\nret = snd_pcm_new(sc, "Cobalt PCM-Out HDMI",\r\n0,\r\n1,\r\n0,\r\n&sp);\r\nif (ret) {\r\ncobalt_err("snd_cobalt_pcm_create() failed for output with err %d\n",\r\nret);\r\ngoto err_exit;\r\n}\r\nsnd_pcm_set_ops(sp, SNDRV_PCM_STREAM_PLAYBACK,\r\n&snd_cobalt_pcm_playback_ops);\r\nsp->info_flags = 0;\r\nsp->private_data = cobsc;\r\nstrlcpy(sp->name, "cobalt", sizeof(sp->name));\r\n}\r\nreturn 0;\r\nerr_exit:\r\nreturn ret;\r\n}
