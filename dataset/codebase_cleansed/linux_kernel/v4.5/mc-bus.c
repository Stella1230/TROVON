static int fsl_mc_bus_match(struct device *dev, struct device_driver *drv)\r\n{\r\nconst struct fsl_mc_device_match_id *id;\r\nstruct fsl_mc_device *mc_dev = to_fsl_mc_device(dev);\r\nstruct fsl_mc_driver *mc_drv = to_fsl_mc_driver(drv);\r\nbool found = false;\r\nbool major_version_mismatch = false;\r\nbool minor_version_mismatch = false;\r\nif (WARN_ON(!fsl_mc_bus_exists()))\r\ngoto out;\r\nif (!mc_drv->match_id_table)\r\ngoto out;\r\nif ((mc_dev->obj_desc.state & DPRC_OBJ_STATE_PLUGGED) == 0 &&\r\n!fsl_mc_is_root_dprc(&mc_dev->dev))\r\ngoto out;\r\nfor (id = mc_drv->match_id_table; id->vendor != 0x0; id++) {\r\nif (id->vendor == mc_dev->obj_desc.vendor &&\r\nstrcmp(id->obj_type, mc_dev->obj_desc.type) == 0) {\r\nif (id->ver_major == mc_dev->obj_desc.ver_major) {\r\nfound = true;\r\nif (id->ver_minor != mc_dev->obj_desc.ver_minor)\r\nminor_version_mismatch = true;\r\n} else {\r\nmajor_version_mismatch = true;\r\n}\r\nbreak;\r\n}\r\n}\r\nif (major_version_mismatch) {\r\ndev_warn(dev,\r\n"Major version mismatch: driver version %u.%u, MC object version %u.%u\n",\r\nid->ver_major, id->ver_minor,\r\nmc_dev->obj_desc.ver_major,\r\nmc_dev->obj_desc.ver_minor);\r\n} else if (minor_version_mismatch) {\r\ndev_warn(dev,\r\n"Minor version mismatch: driver version %u.%u, MC object version %u.%u\n",\r\nid->ver_major, id->ver_minor,\r\nmc_dev->obj_desc.ver_major,\r\nmc_dev->obj_desc.ver_minor);\r\n}\r\nout:\r\ndev_dbg(dev, "%smatched\n", found ? "" : "not ");\r\nreturn found;\r\n}\r\nstatic int fsl_mc_bus_uevent(struct device *dev, struct kobj_uevent_env *env)\r\n{\r\npr_debug("%s invoked\n", __func__);\r\nreturn 0;\r\n}\r\nstatic int fsl_mc_driver_probe(struct device *dev)\r\n{\r\nstruct fsl_mc_driver *mc_drv;\r\nstruct fsl_mc_device *mc_dev = to_fsl_mc_device(dev);\r\nint error;\r\nif (WARN_ON(!dev->driver))\r\nreturn -EINVAL;\r\nmc_drv = to_fsl_mc_driver(dev->driver);\r\nif (WARN_ON(!mc_drv->probe))\r\nreturn -EINVAL;\r\nerror = mc_drv->probe(mc_dev);\r\nif (error < 0) {\r\ndev_err(dev, "MC object device probe callback failed: %d\n",\r\nerror);\r\nreturn error;\r\n}\r\nreturn 0;\r\n}\r\nstatic int fsl_mc_driver_remove(struct device *dev)\r\n{\r\nstruct fsl_mc_driver *mc_drv = to_fsl_mc_driver(dev->driver);\r\nstruct fsl_mc_device *mc_dev = to_fsl_mc_device(dev);\r\nint error;\r\nif (WARN_ON(!dev->driver))\r\nreturn -EINVAL;\r\nerror = mc_drv->remove(mc_dev);\r\nif (error < 0) {\r\ndev_err(dev,\r\n"MC object device remove callback failed: %d\n",\r\nerror);\r\nreturn error;\r\n}\r\nreturn 0;\r\n}\r\nstatic void fsl_mc_driver_shutdown(struct device *dev)\r\n{\r\nstruct fsl_mc_driver *mc_drv = to_fsl_mc_driver(dev->driver);\r\nstruct fsl_mc_device *mc_dev = to_fsl_mc_device(dev);\r\nmc_drv->shutdown(mc_dev);\r\n}\r\nint __fsl_mc_driver_register(struct fsl_mc_driver *mc_driver,\r\nstruct module *owner)\r\n{\r\nint error;\r\nmc_driver->driver.owner = owner;\r\nmc_driver->driver.bus = &fsl_mc_bus_type;\r\nif (mc_driver->probe)\r\nmc_driver->driver.probe = fsl_mc_driver_probe;\r\nif (mc_driver->remove)\r\nmc_driver->driver.remove = fsl_mc_driver_remove;\r\nif (mc_driver->shutdown)\r\nmc_driver->driver.shutdown = fsl_mc_driver_shutdown;\r\nerror = driver_register(&mc_driver->driver);\r\nif (error < 0) {\r\npr_err("driver_register() failed for %s: %d\n",\r\nmc_driver->driver.name, error);\r\nreturn error;\r\n}\r\npr_info("MC object device driver %s registered\n",\r\nmc_driver->driver.name);\r\nreturn 0;\r\n}\r\nvoid fsl_mc_driver_unregister(struct fsl_mc_driver *mc_driver)\r\n{\r\ndriver_unregister(&mc_driver->driver);\r\n}\r\nbool fsl_mc_bus_exists(void)\r\n{\r\nreturn atomic_read(&root_dprc_count) > 0;\r\n}\r\nstatic void fsl_mc_get_root_dprc(struct device *dev,\r\nstruct device **root_dprc_dev)\r\n{\r\nif (WARN_ON(!dev)) {\r\n*root_dprc_dev = NULL;\r\n} else if (WARN_ON(dev->bus != &fsl_mc_bus_type)) {\r\n*root_dprc_dev = NULL;\r\n} else {\r\n*root_dprc_dev = dev;\r\nwhile ((*root_dprc_dev)->parent->bus == &fsl_mc_bus_type)\r\n*root_dprc_dev = (*root_dprc_dev)->parent;\r\n}\r\n}\r\nstatic bool fsl_mc_is_root_dprc(struct device *dev)\r\n{\r\nstruct device *root_dprc_dev;\r\nfsl_mc_get_root_dprc(dev, &root_dprc_dev);\r\nif (!root_dprc_dev)\r\nreturn false;\r\nelse\r\nreturn dev == root_dprc_dev;\r\n}\r\nstatic int get_dprc_icid(struct fsl_mc_io *mc_io,\r\nint container_id, u16 *icid)\r\n{\r\nu16 dprc_handle;\r\nstruct dprc_attributes attr;\r\nint error;\r\nerror = dprc_open(mc_io, 0, container_id, &dprc_handle);\r\nif (error < 0) {\r\npr_err("dprc_open() failed: %d\n", error);\r\nreturn error;\r\n}\r\nmemset(&attr, 0, sizeof(attr));\r\nerror = dprc_get_attributes(mc_io, 0, dprc_handle, &attr);\r\nif (error < 0) {\r\npr_err("dprc_get_attributes() failed: %d\n", error);\r\ngoto common_cleanup;\r\n}\r\n*icid = attr.icid;\r\nerror = 0;\r\ncommon_cleanup:\r\n(void)dprc_close(mc_io, 0, dprc_handle);\r\nreturn error;\r\n}\r\nstatic int translate_mc_addr(struct fsl_mc_device *mc_dev,\r\nenum dprc_region_type mc_region_type,\r\nu64 mc_offset, phys_addr_t *phys_addr)\r\n{\r\nint i;\r\nstruct device *root_dprc_dev;\r\nstruct fsl_mc *mc;\r\nfsl_mc_get_root_dprc(&mc_dev->dev, &root_dprc_dev);\r\nif (WARN_ON(!root_dprc_dev))\r\nreturn -EINVAL;\r\nmc = dev_get_drvdata(root_dprc_dev->parent);\r\nif (mc->num_translation_ranges == 0) {\r\n*phys_addr = mc_offset;\r\nreturn 0;\r\n}\r\nfor (i = 0; i < mc->num_translation_ranges; i++) {\r\nstruct fsl_mc_addr_translation_range *range =\r\n&mc->translation_ranges[i];\r\nif (mc_region_type == range->mc_region_type &&\r\nmc_offset >= range->start_mc_offset &&\r\nmc_offset < range->end_mc_offset) {\r\n*phys_addr = range->start_phys_addr +\r\n(mc_offset - range->start_mc_offset);\r\nreturn 0;\r\n}\r\n}\r\nreturn -EFAULT;\r\n}\r\nstatic int fsl_mc_device_get_mmio_regions(struct fsl_mc_device *mc_dev,\r\nstruct fsl_mc_device *mc_bus_dev)\r\n{\r\nint i;\r\nint error;\r\nstruct resource *regions;\r\nstruct dprc_obj_desc *obj_desc = &mc_dev->obj_desc;\r\nstruct device *parent_dev = mc_dev->dev.parent;\r\nenum dprc_region_type mc_region_type;\r\nif (strcmp(obj_desc->type, "dprc") == 0 ||\r\nstrcmp(obj_desc->type, "dpmcp") == 0) {\r\nmc_region_type = DPRC_REGION_TYPE_MC_PORTAL;\r\n} else if (strcmp(obj_desc->type, "dpio") == 0) {\r\nmc_region_type = DPRC_REGION_TYPE_QBMAN_PORTAL;\r\n} else {\r\nWARN_ON(true);\r\nreturn -EINVAL;\r\n}\r\nregions = kmalloc_array(obj_desc->region_count,\r\nsizeof(regions[0]), GFP_KERNEL);\r\nif (!regions)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < obj_desc->region_count; i++) {\r\nstruct dprc_region_desc region_desc;\r\nerror = dprc_get_obj_region(mc_bus_dev->mc_io,\r\n0,\r\nmc_bus_dev->mc_handle,\r\nobj_desc->type,\r\nobj_desc->id, i, &region_desc);\r\nif (error < 0) {\r\ndev_err(parent_dev,\r\n"dprc_get_obj_region() failed: %d\n", error);\r\ngoto error_cleanup_regions;\r\n}\r\nWARN_ON(region_desc.size == 0);\r\nerror = translate_mc_addr(mc_dev, mc_region_type,\r\nregion_desc.base_offset,\r\n&regions[i].start);\r\nif (error < 0) {\r\ndev_err(parent_dev,\r\n"Invalid MC offset: %#x (for %s.%d\'s region %d)\n",\r\nregion_desc.base_offset,\r\nobj_desc->type, obj_desc->id, i);\r\ngoto error_cleanup_regions;\r\n}\r\nregions[i].end = regions[i].start + region_desc.size - 1;\r\nregions[i].name = "fsl-mc object MMIO region";\r\nregions[i].flags = IORESOURCE_IO;\r\n}\r\nmc_dev->regions = regions;\r\nreturn 0;\r\nerror_cleanup_regions:\r\nkfree(regions);\r\nreturn error;\r\n}\r\nint fsl_mc_device_add(struct dprc_obj_desc *obj_desc,\r\nstruct fsl_mc_io *mc_io,\r\nstruct device *parent_dev,\r\nstruct fsl_mc_device **new_mc_dev)\r\n{\r\nint error;\r\nstruct fsl_mc_device *mc_dev = NULL;\r\nstruct fsl_mc_bus *mc_bus = NULL;\r\nstruct fsl_mc_device *parent_mc_dev;\r\nif (parent_dev->bus == &fsl_mc_bus_type)\r\nparent_mc_dev = to_fsl_mc_device(parent_dev);\r\nelse\r\nparent_mc_dev = NULL;\r\nif (strcmp(obj_desc->type, "dprc") == 0) {\r\nmc_bus = devm_kzalloc(parent_dev, sizeof(*mc_bus), GFP_KERNEL);\r\nif (!mc_bus)\r\nreturn -ENOMEM;\r\nmc_dev = &mc_bus->mc_dev;\r\n} else {\r\nmc_dev = kmem_cache_zalloc(mc_dev_cache, GFP_KERNEL);\r\nif (!mc_dev)\r\nreturn -ENOMEM;\r\n}\r\nmc_dev->obj_desc = *obj_desc;\r\nmc_dev->mc_io = mc_io;\r\ndevice_initialize(&mc_dev->dev);\r\nmc_dev->dev.parent = parent_dev;\r\nmc_dev->dev.bus = &fsl_mc_bus_type;\r\ndev_set_name(&mc_dev->dev, "%s.%d", obj_desc->type, obj_desc->id);\r\nif (strcmp(obj_desc->type, "dprc") == 0) {\r\nstruct fsl_mc_io *mc_io2;\r\nmc_dev->flags |= FSL_MC_IS_DPRC;\r\nif (parent_mc_dev) {\r\nmc_io2 = parent_mc_dev->mc_io;\r\n} else {\r\nif (WARN_ON(!mc_io)) {\r\nerror = -EINVAL;\r\ngoto error_cleanup_dev;\r\n}\r\nmc_io2 = mc_io;\r\natomic_inc(&root_dprc_count);\r\n}\r\nerror = get_dprc_icid(mc_io2, obj_desc->id, &mc_dev->icid);\r\nif (error < 0)\r\ngoto error_cleanup_dev;\r\n} else {\r\nmc_dev->icid = parent_mc_dev->icid;\r\nmc_dev->dma_mask = FSL_MC_DEFAULT_DMA_MASK;\r\nmc_dev->dev.dma_mask = &mc_dev->dma_mask;\r\n}\r\nif (parent_mc_dev && obj_desc->region_count != 0) {\r\nerror = fsl_mc_device_get_mmio_regions(mc_dev,\r\nparent_mc_dev);\r\nif (error < 0)\r\ngoto error_cleanup_dev;\r\n}\r\nerror = device_add(&mc_dev->dev);\r\nif (error < 0) {\r\ndev_err(parent_dev,\r\n"device_add() failed for device %s: %d\n",\r\ndev_name(&mc_dev->dev), error);\r\ngoto error_cleanup_dev;\r\n}\r\n(void)get_device(&mc_dev->dev);\r\ndev_dbg(parent_dev, "Added MC object device %s\n",\r\ndev_name(&mc_dev->dev));\r\n*new_mc_dev = mc_dev;\r\nreturn 0;\r\nerror_cleanup_dev:\r\nkfree(mc_dev->regions);\r\nif (mc_bus)\r\ndevm_kfree(parent_dev, mc_bus);\r\nelse\r\nkmem_cache_free(mc_dev_cache, mc_dev);\r\nreturn error;\r\n}\r\nvoid fsl_mc_device_remove(struct fsl_mc_device *mc_dev)\r\n{\r\nstruct fsl_mc_bus *mc_bus = NULL;\r\nkfree(mc_dev->regions);\r\ndevice_del(&mc_dev->dev);\r\nput_device(&mc_dev->dev);\r\nif (strcmp(mc_dev->obj_desc.type, "dprc") == 0) {\r\nmc_bus = to_fsl_mc_bus(mc_dev);\r\nif (mc_dev->mc_io) {\r\nfsl_destroy_mc_io(mc_dev->mc_io);\r\nmc_dev->mc_io = NULL;\r\n}\r\nif (fsl_mc_is_root_dprc(&mc_dev->dev)) {\r\nif (atomic_read(&root_dprc_count) > 0)\r\natomic_dec(&root_dprc_count);\r\nelse\r\nWARN_ON(1);\r\n}\r\n}\r\nif (mc_bus)\r\ndevm_kfree(mc_dev->dev.parent, mc_bus);\r\nelse\r\nkmem_cache_free(mc_dev_cache, mc_dev);\r\n}\r\nstatic int parse_mc_ranges(struct device *dev,\r\nint *paddr_cells,\r\nint *mc_addr_cells,\r\nint *mc_size_cells,\r\nconst __be32 **ranges_start,\r\nu8 *num_ranges)\r\n{\r\nconst __be32 *prop;\r\nint range_tuple_cell_count;\r\nint ranges_len;\r\nint tuple_len;\r\nstruct device_node *mc_node = dev->of_node;\r\n*ranges_start = of_get_property(mc_node, "ranges", &ranges_len);\r\nif (!(*ranges_start) || !ranges_len) {\r\ndev_warn(dev,\r\n"missing or empty ranges property for device tree node '%s'\n",\r\nmc_node->name);\r\n*num_ranges = 0;\r\nreturn 0;\r\n}\r\n*paddr_cells = of_n_addr_cells(mc_node);\r\nprop = of_get_property(mc_node, "#address-cells", NULL);\r\nif (prop)\r\n*mc_addr_cells = be32_to_cpup(prop);\r\nelse\r\n*mc_addr_cells = *paddr_cells;\r\nprop = of_get_property(mc_node, "#size-cells", NULL);\r\nif (prop)\r\n*mc_size_cells = be32_to_cpup(prop);\r\nelse\r\n*mc_size_cells = of_n_size_cells(mc_node);\r\nrange_tuple_cell_count = *paddr_cells + *mc_addr_cells +\r\n*mc_size_cells;\r\ntuple_len = range_tuple_cell_count * sizeof(__be32);\r\nif (ranges_len % tuple_len != 0) {\r\ndev_err(dev, "malformed ranges property '%s'\n", mc_node->name);\r\nreturn -EINVAL;\r\n}\r\n*num_ranges = ranges_len / tuple_len;\r\nreturn 0;\r\n}\r\nstatic int get_mc_addr_translation_ranges(struct device *dev,\r\nstruct fsl_mc_addr_translation_range\r\n**ranges,\r\nu8 *num_ranges)\r\n{\r\nint error;\r\nint paddr_cells;\r\nint mc_addr_cells;\r\nint mc_size_cells;\r\nint i;\r\nconst __be32 *ranges_start;\r\nconst __be32 *cell;\r\nerror = parse_mc_ranges(dev,\r\n&paddr_cells,\r\n&mc_addr_cells,\r\n&mc_size_cells,\r\n&ranges_start,\r\nnum_ranges);\r\nif (error < 0)\r\nreturn error;\r\nif (!(*num_ranges)) {\r\n*ranges = NULL;\r\nreturn 0;\r\n}\r\n*ranges = devm_kcalloc(dev, *num_ranges,\r\nsizeof(struct fsl_mc_addr_translation_range),\r\nGFP_KERNEL);\r\nif (!(*ranges))\r\nreturn -ENOMEM;\r\ncell = ranges_start;\r\nfor (i = 0; i < *num_ranges; ++i) {\r\nstruct fsl_mc_addr_translation_range *range = &(*ranges)[i];\r\nrange->mc_region_type = of_read_number(cell, 1);\r\nrange->start_mc_offset = of_read_number(cell + 1,\r\nmc_addr_cells - 1);\r\ncell += mc_addr_cells;\r\nrange->start_phys_addr = of_read_number(cell, paddr_cells);\r\ncell += paddr_cells;\r\nrange->end_mc_offset = range->start_mc_offset +\r\nof_read_number(cell, mc_size_cells);\r\ncell += mc_size_cells;\r\n}\r\nreturn 0;\r\n}\r\nstatic int fsl_mc_bus_probe(struct platform_device *pdev)\r\n{\r\nstruct dprc_obj_desc obj_desc;\r\nint error;\r\nstruct fsl_mc *mc;\r\nstruct fsl_mc_device *mc_bus_dev = NULL;\r\nstruct fsl_mc_io *mc_io = NULL;\r\nint container_id;\r\nphys_addr_t mc_portal_phys_addr;\r\nu32 mc_portal_size;\r\nstruct mc_version mc_version;\r\nstruct resource res;\r\ndev_info(&pdev->dev, "Root MC bus device probed");\r\nmc = devm_kzalloc(&pdev->dev, sizeof(*mc), GFP_KERNEL);\r\nif (!mc)\r\nreturn -ENOMEM;\r\nplatform_set_drvdata(pdev, mc);\r\nerror = of_address_to_resource(pdev->dev.of_node, 0, &res);\r\nif (error < 0) {\r\ndev_err(&pdev->dev,\r\n"of_address_to_resource() failed for %s\n",\r\npdev->dev.of_node->full_name);\r\nreturn error;\r\n}\r\nmc_portal_phys_addr = res.start;\r\nmc_portal_size = resource_size(&res);\r\nerror = fsl_create_mc_io(&pdev->dev, mc_portal_phys_addr,\r\nmc_portal_size, NULL, 0, &mc_io);\r\nif (error < 0)\r\nreturn error;\r\nerror = mc_get_version(mc_io, 0, &mc_version);\r\nif (error != 0) {\r\ndev_err(&pdev->dev,\r\n"mc_get_version() failed with error %d\n", error);\r\ngoto error_cleanup_mc_io;\r\n}\r\ndev_info(&pdev->dev,\r\n"Freescale Management Complex Firmware version: %u.%u.%u\n",\r\nmc_version.major, mc_version.minor, mc_version.revision);\r\nif (mc_version.major < MC_VER_MAJOR) {\r\ndev_err(&pdev->dev,\r\n"ERROR: MC firmware version not supported by driver (driver version: %u.%u)\n",\r\nMC_VER_MAJOR, MC_VER_MINOR);\r\nerror = -ENOTSUPP;\r\ngoto error_cleanup_mc_io;\r\n}\r\nif (mc_version.major > MC_VER_MAJOR) {\r\ndev_warn(&pdev->dev,\r\n"WARNING: driver may not support newer MC firmware features (driver version: %u.%u)\n",\r\nMC_VER_MAJOR, MC_VER_MINOR);\r\n}\r\nerror = get_mc_addr_translation_ranges(&pdev->dev,\r\n&mc->translation_ranges,\r\n&mc->num_translation_ranges);\r\nif (error < 0)\r\ngoto error_cleanup_mc_io;\r\nerror = dpmng_get_container_id(mc_io, 0, &container_id);\r\nif (error < 0) {\r\ndev_err(&pdev->dev,\r\n"dpmng_get_container_id() failed: %d\n", error);\r\ngoto error_cleanup_mc_io;\r\n}\r\nobj_desc.vendor = FSL_MC_VENDOR_FREESCALE;\r\nstrcpy(obj_desc.type, "dprc");\r\nobj_desc.id = container_id;\r\nobj_desc.ver_major = DPRC_VER_MAJOR;\r\nobj_desc.ver_minor = DPRC_VER_MINOR;\r\nobj_desc.irq_count = 1;\r\nobj_desc.region_count = 0;\r\nerror = fsl_mc_device_add(&obj_desc, mc_io, &pdev->dev, &mc_bus_dev);\r\nif (error < 0)\r\ngoto error_cleanup_mc_io;\r\nmc->root_mc_bus_dev = mc_bus_dev;\r\nreturn 0;\r\nerror_cleanup_mc_io:\r\nfsl_destroy_mc_io(mc_io);\r\nreturn error;\r\n}\r\nstatic int fsl_mc_bus_remove(struct platform_device *pdev)\r\n{\r\nstruct fsl_mc *mc = platform_get_drvdata(pdev);\r\nif (WARN_ON(!fsl_mc_is_root_dprc(&mc->root_mc_bus_dev->dev)))\r\nreturn -EINVAL;\r\nfsl_mc_device_remove(mc->root_mc_bus_dev);\r\ndev_info(&pdev->dev, "Root MC bus device removed");\r\nreturn 0;\r\n}\r\nstatic int __init fsl_mc_bus_driver_init(void)\r\n{\r\nint error;\r\nmc_dev_cache = kmem_cache_create("fsl_mc_device",\r\nsizeof(struct fsl_mc_device), 0, 0,\r\nNULL);\r\nif (!mc_dev_cache) {\r\npr_err("Could not create fsl_mc_device cache\n");\r\nreturn -ENOMEM;\r\n}\r\nerror = bus_register(&fsl_mc_bus_type);\r\nif (error < 0) {\r\npr_err("fsl-mc bus type registration failed: %d\n", error);\r\ngoto error_cleanup_cache;\r\n}\r\npr_info("fsl-mc bus type registered\n");\r\nerror = platform_driver_register(&fsl_mc_bus_driver);\r\nif (error < 0) {\r\npr_err("platform_driver_register() failed: %d\n", error);\r\ngoto error_cleanup_bus;\r\n}\r\nerror = dprc_driver_init();\r\nif (error < 0)\r\ngoto error_cleanup_driver;\r\nerror = fsl_mc_allocator_driver_init();\r\nif (error < 0)\r\ngoto error_cleanup_dprc_driver;\r\nreturn 0;\r\nerror_cleanup_dprc_driver:\r\ndprc_driver_exit();\r\nerror_cleanup_driver:\r\nplatform_driver_unregister(&fsl_mc_bus_driver);\r\nerror_cleanup_bus:\r\nbus_unregister(&fsl_mc_bus_type);\r\nerror_cleanup_cache:\r\nkmem_cache_destroy(mc_dev_cache);\r\nreturn error;\r\n}\r\nstatic void __exit fsl_mc_bus_driver_exit(void)\r\n{\r\nif (WARN_ON(!mc_dev_cache))\r\nreturn;\r\nfsl_mc_allocator_driver_exit();\r\ndprc_driver_exit();\r\nplatform_driver_unregister(&fsl_mc_bus_driver);\r\nbus_unregister(&fsl_mc_bus_type);\r\nkmem_cache_destroy(mc_dev_cache);\r\npr_info("MC bus unregistered\n");\r\n}
