int comedi_set_hw_dev(struct comedi_device *dev, struct device *hw_dev)\r\n{\r\nif (hw_dev == dev->hw_dev)\r\nreturn 0;\r\nif (dev->hw_dev)\r\nreturn -EEXIST;\r\ndev->hw_dev = get_device(hw_dev);\r\nreturn 0;\r\n}\r\nstatic void comedi_clear_hw_dev(struct comedi_device *dev)\r\n{\r\nput_device(dev->hw_dev);\r\ndev->hw_dev = NULL;\r\n}\r\nvoid *comedi_alloc_devpriv(struct comedi_device *dev, size_t size)\r\n{\r\ndev->private = kzalloc(size, GFP_KERNEL);\r\nreturn dev->private;\r\n}\r\nint comedi_alloc_subdevices(struct comedi_device *dev, int num_subdevices)\r\n{\r\nstruct comedi_subdevice *s;\r\nint i;\r\nif (num_subdevices < 1)\r\nreturn -EINVAL;\r\ns = kcalloc(num_subdevices, sizeof(*s), GFP_KERNEL);\r\nif (!s)\r\nreturn -ENOMEM;\r\ndev->subdevices = s;\r\ndev->n_subdevices = num_subdevices;\r\nfor (i = 0; i < num_subdevices; ++i) {\r\ns = &dev->subdevices[i];\r\ns->device = dev;\r\ns->index = i;\r\ns->async_dma_dir = DMA_NONE;\r\nspin_lock_init(&s->spin_lock);\r\ns->minor = -1;\r\n}\r\nreturn 0;\r\n}\r\nint comedi_alloc_subdev_readback(struct comedi_subdevice *s)\r\n{\r\nif (!s->n_chan)\r\nreturn -EINVAL;\r\ns->readback = kcalloc(s->n_chan, sizeof(*s->readback), GFP_KERNEL);\r\nif (!s->readback)\r\nreturn -ENOMEM;\r\nif (!s->insn_read)\r\ns->insn_read = comedi_readback_insn_read;\r\nreturn 0;\r\n}\r\nstatic void comedi_device_detach_cleanup(struct comedi_device *dev)\r\n{\r\nint i;\r\nstruct comedi_subdevice *s;\r\nif (dev->subdevices) {\r\nfor (i = 0; i < dev->n_subdevices; i++) {\r\ns = &dev->subdevices[i];\r\nif (comedi_can_auto_free_spriv(s))\r\nkfree(s->private);\r\ncomedi_free_subdevice_minor(s);\r\nif (s->async) {\r\ncomedi_buf_alloc(dev, s, 0);\r\nkfree(s->async);\r\n}\r\nkfree(s->readback);\r\n}\r\nkfree(dev->subdevices);\r\ndev->subdevices = NULL;\r\ndev->n_subdevices = 0;\r\n}\r\nkfree(dev->private);\r\nkfree(dev->pacer);\r\ndev->private = NULL;\r\ndev->pacer = NULL;\r\ndev->driver = NULL;\r\ndev->board_name = NULL;\r\ndev->board_ptr = NULL;\r\ndev->mmio = NULL;\r\ndev->iobase = 0;\r\ndev->iolen = 0;\r\ndev->ioenabled = false;\r\ndev->irq = 0;\r\ndev->read_subdev = NULL;\r\ndev->write_subdev = NULL;\r\ndev->open = NULL;\r\ndev->close = NULL;\r\ncomedi_clear_hw_dev(dev);\r\n}\r\nvoid comedi_device_detach(struct comedi_device *dev)\r\n{\r\ncomedi_device_cancel_all(dev);\r\ndown_write(&dev->attach_lock);\r\ndev->attached = false;\r\ndev->detach_count++;\r\nif (dev->driver)\r\ndev->driver->detach(dev);\r\ncomedi_device_detach_cleanup(dev);\r\nup_write(&dev->attach_lock);\r\n}\r\nstatic int poll_invalid(struct comedi_device *dev, struct comedi_subdevice *s)\r\n{\r\nreturn -EINVAL;\r\n}\r\nint insn_inval(struct comedi_device *dev, struct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nreturn -EINVAL;\r\n}\r\nint comedi_readback_insn_read(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nunsigned int chan = CR_CHAN(insn->chanspec);\r\nint i;\r\nif (!s->readback)\r\nreturn -EINVAL;\r\nfor (i = 0; i < insn->n; i++)\r\ndata[i] = s->readback[chan];\r\nreturn insn->n;\r\n}\r\nint comedi_timeout(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nint (*cb)(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned long context),\r\nunsigned long context)\r\n{\r\nunsigned long timeout = jiffies + msecs_to_jiffies(COMEDI_TIMEOUT_MS);\r\nint ret;\r\nwhile (time_before(jiffies, timeout)) {\r\nret = cb(dev, s, insn, context);\r\nif (ret != -EBUSY)\r\nreturn ret;\r\ncpu_relax();\r\n}\r\nreturn -ETIMEDOUT;\r\n}\r\nint comedi_dio_insn_config(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data,\r\nunsigned int mask)\r\n{\r\nunsigned int chan_mask = 1 << CR_CHAN(insn->chanspec);\r\nif (!mask)\r\nmask = chan_mask;\r\nswitch (data[0]) {\r\ncase INSN_CONFIG_DIO_INPUT:\r\ns->io_bits &= ~mask;\r\nbreak;\r\ncase INSN_CONFIG_DIO_OUTPUT:\r\ns->io_bits |= mask;\r\nbreak;\r\ncase INSN_CONFIG_DIO_QUERY:\r\ndata[1] = (s->io_bits & mask) ? COMEDI_OUTPUT : COMEDI_INPUT;\r\nreturn insn->n;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nunsigned int comedi_dio_update_state(struct comedi_subdevice *s,\r\nunsigned int *data)\r\n{\r\nunsigned int chanmask = (s->n_chan < 32) ? ((1 << s->n_chan) - 1)\r\n: 0xffffffff;\r\nunsigned int mask = data[0] & chanmask;\r\nunsigned int bits = data[1];\r\nif (mask) {\r\ns->state &= ~mask;\r\ns->state |= (bits & mask);\r\n}\r\nreturn mask;\r\n}\r\nunsigned int comedi_bytes_per_scan(struct comedi_subdevice *s)\r\n{\r\nstruct comedi_cmd *cmd = &s->async->cmd;\r\nunsigned int num_samples;\r\nunsigned int bits_per_sample;\r\nswitch (s->type) {\r\ncase COMEDI_SUBD_DI:\r\ncase COMEDI_SUBD_DO:\r\ncase COMEDI_SUBD_DIO:\r\nbits_per_sample = 8 * comedi_bytes_per_sample(s);\r\nnum_samples = DIV_ROUND_UP(cmd->scan_end_arg, bits_per_sample);\r\nbreak;\r\ndefault:\r\nnum_samples = cmd->scan_end_arg;\r\nbreak;\r\n}\r\nreturn comedi_samples_to_bytes(s, num_samples);\r\n}\r\nstatic unsigned int __comedi_nscans_left(struct comedi_subdevice *s,\r\nunsigned int nscans)\r\n{\r\nstruct comedi_async *async = s->async;\r\nstruct comedi_cmd *cmd = &async->cmd;\r\nif (cmd->stop_src == TRIG_COUNT) {\r\nunsigned int scans_left = 0;\r\nif (async->scans_done < cmd->stop_arg)\r\nscans_left = cmd->stop_arg - async->scans_done;\r\nif (nscans > scans_left)\r\nnscans = scans_left;\r\n}\r\nreturn nscans;\r\n}\r\nunsigned int comedi_nscans_left(struct comedi_subdevice *s,\r\nunsigned int nscans)\r\n{\r\nif (nscans == 0) {\r\nunsigned int nbytes = comedi_buf_read_n_available(s);\r\nnscans = nbytes / comedi_bytes_per_scan(s);\r\n}\r\nreturn __comedi_nscans_left(s, nscans);\r\n}\r\nunsigned int comedi_nsamples_left(struct comedi_subdevice *s,\r\nunsigned int nsamples)\r\n{\r\nstruct comedi_async *async = s->async;\r\nstruct comedi_cmd *cmd = &async->cmd;\r\nif (cmd->stop_src == TRIG_COUNT) {\r\nunsigned int nscans = nsamples / cmd->scan_end_arg;\r\nunsigned int scans_left = __comedi_nscans_left(s, nscans);\r\nunsigned int scan_pos =\r\ncomedi_bytes_to_samples(s, async->scan_progress);\r\nunsigned long long samples_left = 0;\r\nif (scans_left) {\r\nsamples_left = ((unsigned long long)scans_left *\r\ncmd->scan_end_arg) - scan_pos;\r\n}\r\nif (samples_left < nsamples)\r\nnsamples = samples_left;\r\n}\r\nreturn nsamples;\r\n}\r\nvoid comedi_inc_scan_progress(struct comedi_subdevice *s,\r\nunsigned int num_bytes)\r\n{\r\nstruct comedi_async *async = s->async;\r\nstruct comedi_cmd *cmd = &async->cmd;\r\nunsigned int scan_length = comedi_bytes_per_scan(s);\r\nif (!(s->subdev_flags & SDF_PACKED)) {\r\nasync->cur_chan += comedi_bytes_to_samples(s, num_bytes);\r\nasync->cur_chan %= cmd->chanlist_len;\r\n}\r\nasync->scan_progress += num_bytes;\r\nif (async->scan_progress >= scan_length) {\r\nunsigned int nscans = async->scan_progress / scan_length;\r\nif (async->scans_done < (UINT_MAX - nscans))\r\nasync->scans_done += nscans;\r\nelse\r\nasync->scans_done = UINT_MAX;\r\nasync->scan_progress %= scan_length;\r\nasync->events |= COMEDI_CB_EOS;\r\n}\r\n}\r\nunsigned int comedi_handle_events(struct comedi_device *dev,\r\nstruct comedi_subdevice *s)\r\n{\r\nunsigned int events = s->async->events;\r\nif (events == 0)\r\nreturn events;\r\nif (events & COMEDI_CB_CANCEL_MASK)\r\ns->cancel(dev, s);\r\ncomedi_event(dev, s);\r\nreturn events;\r\n}\r\nstatic int insn_rw_emulate_bits(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nstruct comedi_insn new_insn;\r\nint ret;\r\nstatic const unsigned channels_per_bitfield = 32;\r\nunsigned chan = CR_CHAN(insn->chanspec);\r\nconst unsigned base_bitfield_channel =\r\n(chan < channels_per_bitfield) ? 0 : chan;\r\nunsigned int new_data[2];\r\nmemset(new_data, 0, sizeof(new_data));\r\nmemset(&new_insn, 0, sizeof(new_insn));\r\nnew_insn.insn = INSN_BITS;\r\nnew_insn.chanspec = base_bitfield_channel;\r\nnew_insn.n = 2;\r\nnew_insn.subdev = insn->subdev;\r\nif (insn->insn == INSN_WRITE) {\r\nif (!(s->subdev_flags & SDF_WRITABLE))\r\nreturn -EINVAL;\r\nnew_data[0] = 1 << (chan - base_bitfield_channel);\r\nnew_data[1] = data[0] ? (1 << (chan - base_bitfield_channel))\r\n: 0;\r\n}\r\nret = s->insn_bits(dev, s, &new_insn, new_data);\r\nif (ret < 0)\r\nreturn ret;\r\nif (insn->insn == INSN_READ)\r\ndata[0] = (new_data[1] >> (chan - base_bitfield_channel)) & 1;\r\nreturn 1;\r\n}\r\nstatic int __comedi_device_postconfig_async(struct comedi_device *dev,\r\nstruct comedi_subdevice *s)\r\n{\r\nstruct comedi_async *async;\r\nunsigned int buf_size;\r\nint ret;\r\nif ((s->subdev_flags & (SDF_CMD_READ | SDF_CMD_WRITE)) == 0) {\r\ndev_warn(dev->class_dev,\r\n"async subdevices must support SDF_CMD_READ or SDF_CMD_WRITE\n");\r\nreturn -EINVAL;\r\n}\r\nif (!s->do_cmdtest) {\r\ndev_warn(dev->class_dev,\r\n"async subdevices must have a do_cmdtest() function\n");\r\nreturn -EINVAL;\r\n}\r\nasync = kzalloc(sizeof(*async), GFP_KERNEL);\r\nif (!async)\r\nreturn -ENOMEM;\r\ninit_waitqueue_head(&async->wait_head);\r\ns->async = async;\r\nasync->max_bufsize = comedi_default_buf_maxsize_kb * 1024;\r\nbuf_size = comedi_default_buf_size_kb * 1024;\r\nif (buf_size > async->max_bufsize)\r\nbuf_size = async->max_bufsize;\r\nif (comedi_buf_alloc(dev, s, buf_size) < 0) {\r\ndev_warn(dev->class_dev, "Buffer allocation failed\n");\r\nreturn -ENOMEM;\r\n}\r\nif (s->buf_change) {\r\nret = s->buf_change(dev, s);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\ncomedi_alloc_subdevice_minor(s);\r\nreturn 0;\r\n}\r\nstatic int __comedi_device_postconfig(struct comedi_device *dev)\r\n{\r\nstruct comedi_subdevice *s;\r\nint ret;\r\nint i;\r\nfor (i = 0; i < dev->n_subdevices; i++) {\r\ns = &dev->subdevices[i];\r\nif (s->type == COMEDI_SUBD_UNUSED)\r\ncontinue;\r\nif (s->type == COMEDI_SUBD_DO) {\r\nif (s->n_chan < 32)\r\ns->io_bits = (1 << s->n_chan) - 1;\r\nelse\r\ns->io_bits = 0xffffffff;\r\n}\r\nif (s->len_chanlist == 0)\r\ns->len_chanlist = 1;\r\nif (s->do_cmd) {\r\nret = __comedi_device_postconfig_async(dev, s);\r\nif (ret)\r\nreturn ret;\r\n}\r\nif (!s->range_table && !s->range_table_list)\r\ns->range_table = &range_unknown;\r\nif (!s->insn_read && s->insn_bits)\r\ns->insn_read = insn_rw_emulate_bits;\r\nif (!s->insn_write && s->insn_bits)\r\ns->insn_write = insn_rw_emulate_bits;\r\nif (!s->insn_read)\r\ns->insn_read = insn_inval;\r\nif (!s->insn_write)\r\ns->insn_write = insn_inval;\r\nif (!s->insn_bits)\r\ns->insn_bits = insn_inval;\r\nif (!s->insn_config)\r\ns->insn_config = insn_inval;\r\nif (!s->poll)\r\ns->poll = poll_invalid;\r\n}\r\nreturn 0;\r\n}\r\nstatic int comedi_device_postconfig(struct comedi_device *dev)\r\n{\r\nint ret;\r\nret = __comedi_device_postconfig(dev);\r\nif (ret < 0)\r\nreturn ret;\r\ndown_write(&dev->attach_lock);\r\ndev->attached = true;\r\nup_write(&dev->attach_lock);\r\nreturn 0;\r\n}\r\nstatic void *comedi_recognize(struct comedi_driver *driv, const char *name)\r\n{\r\nchar **name_ptr = (char **)driv->board_name;\r\nint i;\r\nfor (i = 0; i < driv->num_names; i++) {\r\nif (strcmp(*name_ptr, name) == 0)\r\nreturn name_ptr;\r\nname_ptr = (void *)name_ptr + driv->offset;\r\n}\r\nreturn NULL;\r\n}\r\nstatic void comedi_report_boards(struct comedi_driver *driv)\r\n{\r\nunsigned int i;\r\nconst char *const *name_ptr;\r\npr_info("comedi: valid board names for %s driver are:\n",\r\ndriv->driver_name);\r\nname_ptr = driv->board_name;\r\nfor (i = 0; i < driv->num_names; i++) {\r\npr_info(" %s\n", *name_ptr);\r\nname_ptr = (const char **)((char *)name_ptr + driv->offset);\r\n}\r\nif (driv->num_names == 0)\r\npr_info(" %s\n", driv->driver_name);\r\n}\r\nint comedi_load_firmware(struct comedi_device *dev,\r\nstruct device *device,\r\nconst char *name,\r\nint (*cb)(struct comedi_device *dev,\r\nconst u8 *data, size_t size,\r\nunsigned long context),\r\nunsigned long context)\r\n{\r\nconst struct firmware *fw;\r\nint ret;\r\nif (!cb)\r\nreturn -EINVAL;\r\nret = request_firmware(&fw, name, device);\r\nif (ret == 0) {\r\nret = cb(dev, fw->data, fw->size, context);\r\nrelease_firmware(fw);\r\n}\r\nreturn ret < 0 ? ret : 0;\r\n}\r\nint __comedi_request_region(struct comedi_device *dev,\r\nunsigned long start, unsigned long len)\r\n{\r\nif (!start) {\r\ndev_warn(dev->class_dev,\r\n"%s: a I/O base address must be specified\n",\r\ndev->board_name);\r\nreturn -EINVAL;\r\n}\r\nif (!request_region(start, len, dev->board_name)) {\r\ndev_warn(dev->class_dev, "%s: I/O port conflict (%#lx,%lu)\n",\r\ndev->board_name, start, len);\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nint comedi_request_region(struct comedi_device *dev,\r\nunsigned long start, unsigned long len)\r\n{\r\nint ret;\r\nret = __comedi_request_region(dev, start, len);\r\nif (ret == 0) {\r\ndev->iobase = start;\r\ndev->iolen = len;\r\n}\r\nreturn ret;\r\n}\r\nvoid comedi_legacy_detach(struct comedi_device *dev)\r\n{\r\nif (dev->irq) {\r\nfree_irq(dev->irq, dev);\r\ndev->irq = 0;\r\n}\r\nif (dev->iobase && dev->iolen) {\r\nrelease_region(dev->iobase, dev->iolen);\r\ndev->iobase = 0;\r\ndev->iolen = 0;\r\n}\r\n}\r\nint comedi_device_attach(struct comedi_device *dev, struct comedi_devconfig *it)\r\n{\r\nstruct comedi_driver *driv;\r\nint ret;\r\nif (dev->attached)\r\nreturn -EBUSY;\r\nmutex_lock(&comedi_drivers_list_lock);\r\nfor (driv = comedi_drivers; driv; driv = driv->next) {\r\nif (!try_module_get(driv->module))\r\ncontinue;\r\nif (driv->num_names) {\r\ndev->board_ptr = comedi_recognize(driv, it->board_name);\r\nif (dev->board_ptr)\r\nbreak;\r\n} else if (strcmp(driv->driver_name, it->board_name) == 0) {\r\nbreak;\r\n}\r\nmodule_put(driv->module);\r\n}\r\nif (!driv) {\r\nfor (driv = comedi_drivers; driv; driv = driv->next) {\r\nif (!try_module_get(driv->module))\r\ncontinue;\r\ncomedi_report_boards(driv);\r\nmodule_put(driv->module);\r\n}\r\nret = -EIO;\r\ngoto out;\r\n}\r\nif (!driv->attach) {\r\ndev_warn(dev->class_dev,\r\n"driver '%s' does not support attach using comedi_config\n",\r\ndriv->driver_name);\r\nmodule_put(driv->module);\r\nret = -EIO;\r\ngoto out;\r\n}\r\ndev->driver = driv;\r\ndev->board_name = dev->board_ptr ? *(const char **)dev->board_ptr\r\n: dev->driver->driver_name;\r\nret = driv->attach(dev, it);\r\nif (ret >= 0)\r\nret = comedi_device_postconfig(dev);\r\nif (ret < 0) {\r\ncomedi_device_detach(dev);\r\nmodule_put(driv->module);\r\n}\r\nout:\r\nmutex_unlock(&comedi_drivers_list_lock);\r\nreturn ret;\r\n}\r\nint comedi_auto_config(struct device *hardware_device,\r\nstruct comedi_driver *driver, unsigned long context)\r\n{\r\nstruct comedi_device *dev;\r\nint ret;\r\nif (!hardware_device) {\r\npr_warn("BUG! comedi_auto_config called with NULL hardware_device\n");\r\nreturn -EINVAL;\r\n}\r\nif (!driver) {\r\ndev_warn(hardware_device,\r\n"BUG! comedi_auto_config called with NULL comedi driver\n");\r\nreturn -EINVAL;\r\n}\r\nif (!driver->auto_attach) {\r\ndev_warn(hardware_device,\r\n"BUG! comedi driver '%s' has no auto_attach handler\n",\r\ndriver->driver_name);\r\nreturn -EINVAL;\r\n}\r\ndev = comedi_alloc_board_minor(hardware_device);\r\nif (IS_ERR(dev)) {\r\ndev_warn(hardware_device,\r\n"driver '%s' could not create device.\n",\r\ndriver->driver_name);\r\nreturn PTR_ERR(dev);\r\n}\r\ndev->driver = driver;\r\ndev->board_name = dev->driver->driver_name;\r\nret = driver->auto_attach(dev, context);\r\nif (ret >= 0)\r\nret = comedi_device_postconfig(dev);\r\nmutex_unlock(&dev->mutex);\r\nif (ret < 0) {\r\ndev_warn(hardware_device,\r\n"driver '%s' failed to auto-configure device.\n",\r\ndriver->driver_name);\r\ncomedi_release_hardware_device(hardware_device);\r\n} else {\r\ndev_info(dev->class_dev,\r\n"driver '%s' has successfully auto-configured '%s'.\n",\r\ndriver->driver_name, dev->board_name);\r\n}\r\nreturn ret;\r\n}\r\nvoid comedi_auto_unconfig(struct device *hardware_device)\r\n{\r\nif (!hardware_device)\r\nreturn;\r\ncomedi_release_hardware_device(hardware_device);\r\n}\r\nint comedi_driver_register(struct comedi_driver *driver)\r\n{\r\nmutex_lock(&comedi_drivers_list_lock);\r\ndriver->next = comedi_drivers;\r\ncomedi_drivers = driver;\r\nmutex_unlock(&comedi_drivers_list_lock);\r\nreturn 0;\r\n}\r\nvoid comedi_driver_unregister(struct comedi_driver *driver)\r\n{\r\nstruct comedi_driver *prev;\r\nint i;\r\nmutex_lock(&comedi_drivers_list_lock);\r\nif (comedi_drivers == driver) {\r\ncomedi_drivers = driver->next;\r\n} else {\r\nfor (prev = comedi_drivers; prev->next; prev = prev->next) {\r\nif (prev->next == driver) {\r\nprev->next = driver->next;\r\nbreak;\r\n}\r\n}\r\n}\r\nmutex_unlock(&comedi_drivers_list_lock);\r\nfor (i = 0; i < COMEDI_NUM_BOARD_MINORS; i++) {\r\nstruct comedi_device *dev = comedi_dev_get_from_minor(i);\r\nif (!dev)\r\ncontinue;\r\nmutex_lock(&dev->mutex);\r\nif (dev->attached && dev->driver == driver) {\r\nif (dev->use_count)\r\ndev_warn(dev->class_dev,\r\n"BUG! detaching device with use_count=%d\n",\r\ndev->use_count);\r\ncomedi_device_detach(dev);\r\n}\r\nmutex_unlock(&dev->mutex);\r\ncomedi_dev_put(dev);\r\n}\r\n}
