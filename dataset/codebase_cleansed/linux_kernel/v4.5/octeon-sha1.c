static void octeon_sha1_store_hash(struct sha1_state *sctx)\r\n{\r\nu64 *hash = (u64 *)sctx->state;\r\nunion {\r\nu32 word[2];\r\nu64 dword;\r\n} hash_tail = { { sctx->state[4], } };\r\nwrite_octeon_64bit_hash_dword(hash[0], 0);\r\nwrite_octeon_64bit_hash_dword(hash[1], 1);\r\nwrite_octeon_64bit_hash_dword(hash_tail.dword, 2);\r\nmemzero_explicit(&hash_tail.word[0], sizeof(hash_tail.word[0]));\r\n}\r\nstatic void octeon_sha1_read_hash(struct sha1_state *sctx)\r\n{\r\nu64 *hash = (u64 *)sctx->state;\r\nunion {\r\nu32 word[2];\r\nu64 dword;\r\n} hash_tail;\r\nhash[0] = read_octeon_64bit_hash_dword(0);\r\nhash[1] = read_octeon_64bit_hash_dword(1);\r\nhash_tail.dword = read_octeon_64bit_hash_dword(2);\r\nsctx->state[4] = hash_tail.word[0];\r\nmemzero_explicit(&hash_tail.dword, sizeof(hash_tail.dword));\r\n}\r\nstatic void octeon_sha1_transform(const void *_block)\r\n{\r\nconst u64 *block = _block;\r\nwrite_octeon_64bit_block_dword(block[0], 0);\r\nwrite_octeon_64bit_block_dword(block[1], 1);\r\nwrite_octeon_64bit_block_dword(block[2], 2);\r\nwrite_octeon_64bit_block_dword(block[3], 3);\r\nwrite_octeon_64bit_block_dword(block[4], 4);\r\nwrite_octeon_64bit_block_dword(block[5], 5);\r\nwrite_octeon_64bit_block_dword(block[6], 6);\r\nocteon_sha1_start(block[7]);\r\n}\r\nstatic int octeon_sha1_init(struct shash_desc *desc)\r\n{\r\nstruct sha1_state *sctx = shash_desc_ctx(desc);\r\nsctx->state[0] = SHA1_H0;\r\nsctx->state[1] = SHA1_H1;\r\nsctx->state[2] = SHA1_H2;\r\nsctx->state[3] = SHA1_H3;\r\nsctx->state[4] = SHA1_H4;\r\nsctx->count = 0;\r\nreturn 0;\r\n}\r\nstatic void __octeon_sha1_update(struct sha1_state *sctx, const u8 *data,\r\nunsigned int len)\r\n{\r\nunsigned int partial;\r\nunsigned int done;\r\nconst u8 *src;\r\npartial = sctx->count % SHA1_BLOCK_SIZE;\r\nsctx->count += len;\r\ndone = 0;\r\nsrc = data;\r\nif ((partial + len) >= SHA1_BLOCK_SIZE) {\r\nif (partial) {\r\ndone = -partial;\r\nmemcpy(sctx->buffer + partial, data,\r\ndone + SHA1_BLOCK_SIZE);\r\nsrc = sctx->buffer;\r\n}\r\ndo {\r\nocteon_sha1_transform(src);\r\ndone += SHA1_BLOCK_SIZE;\r\nsrc = data + done;\r\n} while (done + SHA1_BLOCK_SIZE <= len);\r\npartial = 0;\r\n}\r\nmemcpy(sctx->buffer + partial, src, len - done);\r\n}\r\nstatic int octeon_sha1_update(struct shash_desc *desc, const u8 *data,\r\nunsigned int len)\r\n{\r\nstruct sha1_state *sctx = shash_desc_ctx(desc);\r\nstruct octeon_cop2_state state;\r\nunsigned long flags;\r\nif ((sctx->count % SHA1_BLOCK_SIZE) + len < SHA1_BLOCK_SIZE)\r\nreturn crypto_sha1_update(desc, data, len);\r\nflags = octeon_crypto_enable(&state);\r\nocteon_sha1_store_hash(sctx);\r\n__octeon_sha1_update(sctx, data, len);\r\nocteon_sha1_read_hash(sctx);\r\nocteon_crypto_disable(&state, flags);\r\nreturn 0;\r\n}\r\nstatic int octeon_sha1_final(struct shash_desc *desc, u8 *out)\r\n{\r\nstruct sha1_state *sctx = shash_desc_ctx(desc);\r\nstatic const u8 padding[64] = { 0x80, };\r\nstruct octeon_cop2_state state;\r\n__be32 *dst = (__be32 *)out;\r\nunsigned int pad_len;\r\nunsigned long flags;\r\nunsigned int index;\r\n__be64 bits;\r\nint i;\r\nbits = cpu_to_be64(sctx->count << 3);\r\nindex = sctx->count & 0x3f;\r\npad_len = (index < 56) ? (56 - index) : ((64+56) - index);\r\nflags = octeon_crypto_enable(&state);\r\nocteon_sha1_store_hash(sctx);\r\n__octeon_sha1_update(sctx, padding, pad_len);\r\n__octeon_sha1_update(sctx, (const u8 *)&bits, sizeof(bits));\r\nocteon_sha1_read_hash(sctx);\r\nocteon_crypto_disable(&state, flags);\r\nfor (i = 0; i < 5; i++)\r\ndst[i] = cpu_to_be32(sctx->state[i]);\r\nmemset(sctx, 0, sizeof(*sctx));\r\nreturn 0;\r\n}\r\nstatic int octeon_sha1_export(struct shash_desc *desc, void *out)\r\n{\r\nstruct sha1_state *sctx = shash_desc_ctx(desc);\r\nmemcpy(out, sctx, sizeof(*sctx));\r\nreturn 0;\r\n}\r\nstatic int octeon_sha1_import(struct shash_desc *desc, const void *in)\r\n{\r\nstruct sha1_state *sctx = shash_desc_ctx(desc);\r\nmemcpy(sctx, in, sizeof(*sctx));\r\nreturn 0;\r\n}\r\nstatic int __init octeon_sha1_mod_init(void)\r\n{\r\nif (!octeon_has_crypto())\r\nreturn -ENOTSUPP;\r\nreturn crypto_register_shash(&octeon_sha1_alg);\r\n}\r\nstatic void __exit octeon_sha1_mod_fini(void)\r\n{\r\ncrypto_unregister_shash(&octeon_sha1_alg);\r\n}
