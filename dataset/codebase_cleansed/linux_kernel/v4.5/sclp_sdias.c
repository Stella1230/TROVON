static void sclp_sdias_receiver_fn(struct evbuf_header *evbuf)\r\n{\r\nmemcpy(&sdias_evbuf, evbuf,\r\nmin_t(unsigned long, sizeof(sdias_evbuf), evbuf->length));\r\ncomplete(&evbuf_done);\r\nTRACE("sclp_sdias_receiver_fn done\n");\r\n}\r\nstatic void sdias_callback(struct sclp_req *request, void *data)\r\n{\r\ncomplete(&evbuf_accepted);\r\nTRACE("callback done\n");\r\n}\r\nstatic int sdias_sclp_send(struct sclp_req *req)\r\n{\r\nint retries;\r\nint rc;\r\nfor (retries = SDIAS_RETRIES; retries; retries--) {\r\nTRACE("add request\n");\r\nrc = sclp_add_request(req);\r\nif (rc) {\r\nset_current_state(TASK_INTERRUPTIBLE);\r\nTRACE("add request failed: rc = %i\n",rc);\r\nschedule_timeout(msecs_to_jiffies(500));\r\ncontinue;\r\n}\r\nwait_for_completion(&evbuf_accepted);\r\nif (req->status == SCLP_REQ_FAILED) {\r\nTRACE("sclp request failed\n");\r\ncontinue;\r\n}\r\nif (!(sccb.evbuf.hdr.flags & 0x80)) {\r\nTRACE("sclp request failed: flags=%x\n",\r\nsccb.evbuf.hdr.flags);\r\ncontinue;\r\n}\r\nif (!sclp_sdias_register.receiver_fn) {\r\nmemcpy(&sdias_evbuf, &sccb.evbuf, sizeof(sdias_evbuf));\r\nTRACE("sync request done\n");\r\nreturn 0;\r\n}\r\nwait_for_completion(&evbuf_done);\r\nTRACE("request done\n");\r\nreturn 0;\r\n}\r\nreturn -EIO;\r\n}\r\nint sclp_sdias_blk_count(void)\r\n{\r\nstruct sclp_req request;\r\nint rc;\r\nmutex_lock(&sdias_mutex);\r\nmemset(&sccb, 0, sizeof(sccb));\r\nmemset(&request, 0, sizeof(request));\r\nsccb.hdr.length = sizeof(sccb);\r\nsccb.evbuf.hdr.length = sizeof(struct sdias_evbuf);\r\nsccb.evbuf.hdr.type = EVTYP_SDIAS;\r\nsccb.evbuf.event_qual = SDIAS_EQ_SIZE;\r\nsccb.evbuf.data_id = SDIAS_DI_FCP_DUMP;\r\nsccb.evbuf.event_id = 4712;\r\nsccb.evbuf.dbs = 1;\r\nrequest.sccb = &sccb;\r\nrequest.command = SCLP_CMDW_WRITE_EVENT_DATA;\r\nrequest.status = SCLP_REQ_FILLED;\r\nrequest.callback = sdias_callback;\r\nrc = sdias_sclp_send(&request);\r\nif (rc) {\r\npr_err("sclp_send failed for get_nr_blocks\n");\r\ngoto out;\r\n}\r\nif (sccb.hdr.response_code != 0x0020) {\r\nTRACE("send failed: %x\n", sccb.hdr.response_code);\r\nrc = -EIO;\r\ngoto out;\r\n}\r\nswitch (sdias_evbuf.event_status) {\r\ncase 0:\r\nrc = sdias_evbuf.blk_cnt;\r\nbreak;\r\ndefault:\r\npr_err("SCLP error: %x\n", sdias_evbuf.event_status);\r\nrc = -EIO;\r\ngoto out;\r\n}\r\nTRACE("%i blocks\n", rc);\r\nout:\r\nmutex_unlock(&sdias_mutex);\r\nreturn rc;\r\n}\r\nint sclp_sdias_copy(void *dest, int start_blk, int nr_blks)\r\n{\r\nstruct sclp_req request;\r\nint rc;\r\nmutex_lock(&sdias_mutex);\r\nmemset(&sccb, 0, sizeof(sccb));\r\nmemset(&request, 0, sizeof(request));\r\nsccb.hdr.length = sizeof(sccb);\r\nsccb.evbuf.hdr.length = sizeof(struct sdias_evbuf);\r\nsccb.evbuf.hdr.type = EVTYP_SDIAS;\r\nsccb.evbuf.hdr.flags = 0;\r\nsccb.evbuf.event_qual = SDIAS_EQ_STORE_DATA;\r\nsccb.evbuf.data_id = SDIAS_DI_FCP_DUMP;\r\nsccb.evbuf.event_id = 4712;\r\nsccb.evbuf.asa_size = SDIAS_ASA_SIZE_64;\r\nsccb.evbuf.event_status = 0;\r\nsccb.evbuf.blk_cnt = nr_blks;\r\nsccb.evbuf.asa = (unsigned long)dest;\r\nsccb.evbuf.fbn = start_blk;\r\nsccb.evbuf.lbn = 0;\r\nsccb.evbuf.dbs = 1;\r\nrequest.sccb = &sccb;\r\nrequest.command = SCLP_CMDW_WRITE_EVENT_DATA;\r\nrequest.status = SCLP_REQ_FILLED;\r\nrequest.callback = sdias_callback;\r\nrc = sdias_sclp_send(&request);\r\nif (rc) {\r\npr_err("sclp_send failed: %x\n", rc);\r\ngoto out;\r\n}\r\nif (sccb.hdr.response_code != 0x0020) {\r\nTRACE("copy failed: %x\n", sccb.hdr.response_code);\r\nrc = -EIO;\r\ngoto out;\r\n}\r\nswitch (sdias_evbuf.event_status) {\r\ncase SDIAS_EVSTATE_ALL_STORED:\r\nTRACE("all stored\n");\r\nbreak;\r\ncase SDIAS_EVSTATE_PART_STORED:\r\nTRACE("part stored: %i\n", sdias_evbuf.blk_cnt);\r\nbreak;\r\ncase SDIAS_EVSTATE_NO_DATA:\r\nTRACE("no data\n");\r\ndefault:\r\npr_err("Error from SCLP while copying hsa. Event status = %x\n",\r\nsdias_evbuf.event_status);\r\nrc = -EIO;\r\n}\r\nout:\r\nmutex_unlock(&sdias_mutex);\r\nreturn rc;\r\n}\r\nstatic int __init sclp_sdias_register_check(void)\r\n{\r\nint rc;\r\nrc = sclp_register(&sclp_sdias_register);\r\nif (rc)\r\nreturn rc;\r\nif (sclp_sdias_blk_count() == 0) {\r\nsclp_unregister(&sclp_sdias_register);\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init sclp_sdias_init_sync(void)\r\n{\r\nTRACE("Try synchronous mode\n");\r\nsclp_sdias_register.receive_mask = 0;\r\nsclp_sdias_register.receiver_fn = NULL;\r\nreturn sclp_sdias_register_check();\r\n}\r\nstatic int __init sclp_sdias_init_async(void)\r\n{\r\nTRACE("Try asynchronous mode\n");\r\nsclp_sdias_register.receive_mask = EVTYP_SDIAS_MASK;\r\nsclp_sdias_register.receiver_fn = sclp_sdias_receiver_fn;\r\nreturn sclp_sdias_register_check();\r\n}\r\nint __init sclp_sdias_init(void)\r\n{\r\nif (ipl_info.type != IPL_TYPE_FCP_DUMP)\r\nreturn 0;\r\nsdias_dbf = debug_register("dump_sdias", 4, 1, 4 * sizeof(long));\r\ndebug_register_view(sdias_dbf, &debug_sprintf_view);\r\ndebug_set_level(sdias_dbf, 6);\r\nif (sclp_sdias_init_sync() == 0)\r\ngoto out;\r\nif (sclp_sdias_init_async() == 0)\r\ngoto out;\r\nTRACE("init failed\n");\r\nreturn -ENODEV;\r\nout:\r\nTRACE("init done\n");\r\nreturn 0;\r\n}\r\nvoid __exit sclp_sdias_exit(void)\r\n{\r\ndebug_unregister(sdias_dbf);\r\nsclp_unregister(&sclp_sdias_register);\r\n}
