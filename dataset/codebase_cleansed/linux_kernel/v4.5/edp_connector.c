static enum drm_connector_status edp_connector_detect(\r\nstruct drm_connector *connector, bool force)\r\n{\r\nstruct edp_connector *edp_connector = to_edp_connector(connector);\r\nstruct msm_edp *edp = edp_connector->edp;\r\nDBG("");\r\nreturn msm_edp_ctrl_panel_connected(edp->ctrl) ?\r\nconnector_status_connected : connector_status_disconnected;\r\n}\r\nstatic void edp_connector_destroy(struct drm_connector *connector)\r\n{\r\nstruct edp_connector *edp_connector = to_edp_connector(connector);\r\nDBG("");\r\ndrm_connector_unregister(connector);\r\ndrm_connector_cleanup(connector);\r\nkfree(edp_connector);\r\n}\r\nstatic int edp_connector_get_modes(struct drm_connector *connector)\r\n{\r\nstruct edp_connector *edp_connector = to_edp_connector(connector);\r\nstruct msm_edp *edp = edp_connector->edp;\r\nstruct edid *drm_edid = NULL;\r\nint ret = 0;\r\nDBG("");\r\nret = msm_edp_ctrl_get_panel_info(edp->ctrl, connector, &drm_edid);\r\nif (ret)\r\nreturn ret;\r\ndrm_mode_connector_update_edid_property(connector, drm_edid);\r\nif (drm_edid)\r\nret = drm_add_edid_modes(connector, drm_edid);\r\nreturn ret;\r\n}\r\nstatic int edp_connector_mode_valid(struct drm_connector *connector,\r\nstruct drm_display_mode *mode)\r\n{\r\nstruct edp_connector *edp_connector = to_edp_connector(connector);\r\nstruct msm_edp *edp = edp_connector->edp;\r\nstruct msm_drm_private *priv = connector->dev->dev_private;\r\nstruct msm_kms *kms = priv->kms;\r\nlong actual, requested;\r\nrequested = 1000 * mode->clock;\r\nactual = kms->funcs->round_pixclk(kms,\r\nrequested, edp_connector->edp->encoder);\r\nDBG("requested=%ld, actual=%ld", requested, actual);\r\nif (actual != requested)\r\nreturn MODE_CLOCK_RANGE;\r\nif (!msm_edp_ctrl_pixel_clock_valid(\r\nedp->ctrl, mode->clock, NULL, NULL))\r\nreturn MODE_CLOCK_RANGE;\r\nif (connector->display_info.bpc > 8)\r\nreturn MODE_BAD;\r\nreturn MODE_OK;\r\n}\r\nstatic struct drm_encoder *\r\nedp_connector_best_encoder(struct drm_connector *connector)\r\n{\r\nstruct edp_connector *edp_connector = to_edp_connector(connector);\r\nDBG("");\r\nreturn edp_connector->edp->encoder;\r\n}\r\nstruct drm_connector *msm_edp_connector_init(struct msm_edp *edp)\r\n{\r\nstruct drm_connector *connector = NULL;\r\nstruct edp_connector *edp_connector;\r\nint ret;\r\nedp_connector = kzalloc(sizeof(*edp_connector), GFP_KERNEL);\r\nif (!edp_connector) {\r\nret = -ENOMEM;\r\ngoto fail;\r\n}\r\nedp_connector->edp = edp;\r\nconnector = &edp_connector->base;\r\nret = drm_connector_init(edp->dev, connector, &edp_connector_funcs,\r\nDRM_MODE_CONNECTOR_eDP);\r\nif (ret)\r\ngoto fail;\r\ndrm_connector_helper_add(connector, &edp_connector_helper_funcs);\r\nconnector->polled = DRM_CONNECTOR_POLL_CONNECT;\r\nconnector->interlace_allowed = false;\r\nconnector->doublescan_allowed = false;\r\nret = drm_connector_register(connector);\r\nif (ret)\r\ngoto fail;\r\ndrm_mode_connector_attach_encoder(connector, edp->encoder);\r\nreturn connector;\r\nfail:\r\nif (connector)\r\nedp_connector_destroy(connector);\r\nreturn ERR_PTR(ret);\r\n}
