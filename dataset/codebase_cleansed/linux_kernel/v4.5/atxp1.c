static struct atxp1_data *atxp1_update_device(struct device *dev)\r\n{\r\nstruct atxp1_data *data = dev_get_drvdata(dev);\r\nstruct i2c_client *client = data->client;\r\nmutex_lock(&data->update_lock);\r\nif (time_after(jiffies, data->last_updated + HZ) || !data->valid) {\r\ndata->reg.vid = i2c_smbus_read_byte_data(client, ATXP1_VID);\r\ndata->reg.cpu_vid = i2c_smbus_read_byte_data(client,\r\nATXP1_CVID);\r\ndata->reg.gpio1 = i2c_smbus_read_byte_data(client, ATXP1_GPIO1);\r\ndata->reg.gpio2 = i2c_smbus_read_byte_data(client, ATXP1_GPIO2);\r\ndata->valid = 1;\r\n}\r\nmutex_unlock(&data->update_lock);\r\nreturn data;\r\n}\r\nstatic ssize_t atxp1_showvcore(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nint size;\r\nstruct atxp1_data *data;\r\ndata = atxp1_update_device(dev);\r\nsize = sprintf(buf, "%d\n", vid_from_reg(data->reg.vid & ATXP1_VIDMASK,\r\ndata->vrm));\r\nreturn size;\r\n}\r\nstatic ssize_t atxp1_storevcore(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct atxp1_data *data = atxp1_update_device(dev);\r\nstruct i2c_client *client = data->client;\r\nint vid, cvid;\r\nunsigned long vcore;\r\nint err;\r\nerr = kstrtoul(buf, 10, &vcore);\r\nif (err)\r\nreturn err;\r\nvcore /= 25;\r\nvcore *= 25;\r\nvid = vid_to_reg(vcore, data->vrm);\r\nif (vid < 0) {\r\ndev_err(dev, "VID calculation failed.\n");\r\nreturn vid;\r\n}\r\nif (data->reg.vid & ATXP1_VIDENA)\r\ncvid = data->reg.vid & ATXP1_VIDMASK;\r\nelse\r\ncvid = data->reg.cpu_vid;\r\nif (vid == cvid)\r\nreturn count;\r\ndev_dbg(dev, "Setting VCore to %d mV (0x%02x)\n", (int)vcore, vid);\r\nif (cvid > vid) {\r\nfor (; cvid >= vid; cvid--)\r\ni2c_smbus_write_byte_data(client,\r\nATXP1_VID, cvid | ATXP1_VIDENA);\r\n} else {\r\nfor (; cvid <= vid; cvid++)\r\ni2c_smbus_write_byte_data(client,\r\nATXP1_VID, cvid | ATXP1_VIDENA);\r\n}\r\ndata->valid = 0;\r\nreturn count;\r\n}\r\nstatic ssize_t atxp1_showgpio1(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nint size;\r\nstruct atxp1_data *data;\r\ndata = atxp1_update_device(dev);\r\nsize = sprintf(buf, "0x%02x\n", data->reg.gpio1 & ATXP1_GPIO1MASK);\r\nreturn size;\r\n}\r\nstatic ssize_t atxp1_storegpio1(struct device *dev,\r\nstruct device_attribute *attr, const char *buf,\r\nsize_t count)\r\n{\r\nstruct atxp1_data *data = atxp1_update_device(dev);\r\nstruct i2c_client *client = data->client;\r\nunsigned long value;\r\nint err;\r\nerr = kstrtoul(buf, 16, &value);\r\nif (err)\r\nreturn err;\r\nvalue &= ATXP1_GPIO1MASK;\r\nif (value != (data->reg.gpio1 & ATXP1_GPIO1MASK)) {\r\ndev_info(dev, "Writing 0x%x to GPIO1.\n", (unsigned int)value);\r\ni2c_smbus_write_byte_data(client, ATXP1_GPIO1, value);\r\ndata->valid = 0;\r\n}\r\nreturn count;\r\n}\r\nstatic ssize_t atxp1_showgpio2(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nint size;\r\nstruct atxp1_data *data;\r\ndata = atxp1_update_device(dev);\r\nsize = sprintf(buf, "0x%02x\n", data->reg.gpio2);\r\nreturn size;\r\n}\r\nstatic ssize_t atxp1_storegpio2(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct atxp1_data *data = atxp1_update_device(dev);\r\nstruct i2c_client *client = data->client;\r\nunsigned long value;\r\nint err;\r\nerr = kstrtoul(buf, 16, &value);\r\nif (err)\r\nreturn err;\r\nvalue &= 0xff;\r\nif (value != data->reg.gpio2) {\r\ndev_info(dev, "Writing 0x%x to GPIO1.\n", (unsigned int)value);\r\ni2c_smbus_write_byte_data(client, ATXP1_GPIO2, value);\r\ndata->valid = 0;\r\n}\r\nreturn count;\r\n}\r\nstatic int atxp1_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct device *dev = &client->dev;\r\nstruct atxp1_data *data;\r\nstruct device *hwmon_dev;\r\ndata = devm_kzalloc(dev, sizeof(struct atxp1_data), GFP_KERNEL);\r\nif (!data)\r\nreturn -ENOMEM;\r\ndata->vrm = vid_which_vrm();\r\nif (data->vrm != 90 && data->vrm != 91) {\r\ndev_err(dev, "atxp1: Not supporting VRM %d.%d\n",\r\ndata->vrm / 10, data->vrm % 10);\r\nreturn -ENODEV;\r\n}\r\ndata->client = client;\r\nmutex_init(&data->update_lock);\r\nhwmon_dev = devm_hwmon_device_register_with_groups(dev, client->name,\r\ndata,\r\natxp1_groups);\r\nif (IS_ERR(hwmon_dev))\r\nreturn PTR_ERR(hwmon_dev);\r\ndev_info(dev, "Using VRM: %d.%d\n", data->vrm / 10, data->vrm % 10);\r\nreturn 0;\r\n}
