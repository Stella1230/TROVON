static inline u32 bcm2835_rd(struct bcm2835_spi *bs, unsigned reg)\r\n{\r\nreturn readl(bs->regs + reg);\r\n}\r\nstatic inline void bcm2835_wr(struct bcm2835_spi *bs, unsigned reg, u32 val)\r\n{\r\nwritel(val, bs->regs + reg);\r\n}\r\nstatic inline void bcm2835_rd_fifo(struct bcm2835_spi *bs)\r\n{\r\nu8 byte;\r\nwhile ((bs->rx_len) &&\r\n(bcm2835_rd(bs, BCM2835_SPI_CS) & BCM2835_SPI_CS_RXD)) {\r\nbyte = bcm2835_rd(bs, BCM2835_SPI_FIFO);\r\nif (bs->rx_buf)\r\n*bs->rx_buf++ = byte;\r\nbs->rx_len--;\r\n}\r\n}\r\nstatic inline void bcm2835_wr_fifo(struct bcm2835_spi *bs)\r\n{\r\nu8 byte;\r\nwhile ((bs->tx_len) &&\r\n(bcm2835_rd(bs, BCM2835_SPI_CS) & BCM2835_SPI_CS_TXD)) {\r\nbyte = bs->tx_buf ? *bs->tx_buf++ : 0;\r\nbcm2835_wr(bs, BCM2835_SPI_FIFO, byte);\r\nbs->tx_len--;\r\n}\r\n}\r\nstatic void bcm2835_spi_reset_hw(struct spi_master *master)\r\n{\r\nstruct bcm2835_spi *bs = spi_master_get_devdata(master);\r\nu32 cs = bcm2835_rd(bs, BCM2835_SPI_CS);\r\ncs &= ~(BCM2835_SPI_CS_INTR |\r\nBCM2835_SPI_CS_INTD |\r\nBCM2835_SPI_CS_DMAEN |\r\nBCM2835_SPI_CS_TA);\r\ncs |= BCM2835_SPI_CS_CLEAR_RX | BCM2835_SPI_CS_CLEAR_TX;\r\nbcm2835_wr(bs, BCM2835_SPI_CS, cs);\r\nbcm2835_wr(bs, BCM2835_SPI_DLEN, 0);\r\n}\r\nstatic irqreturn_t bcm2835_spi_interrupt(int irq, void *dev_id)\r\n{\r\nstruct spi_master *master = dev_id;\r\nstruct bcm2835_spi *bs = spi_master_get_devdata(master);\r\nbcm2835_rd_fifo(bs);\r\nbcm2835_wr_fifo(bs);\r\nif (bcm2835_rd(bs, BCM2835_SPI_CS) & BCM2835_SPI_CS_DONE) {\r\nbcm2835_spi_reset_hw(master);\r\ncomplete(&master->xfer_completion);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int bcm2835_spi_transfer_one_irq(struct spi_master *master,\r\nstruct spi_device *spi,\r\nstruct spi_transfer *tfr,\r\nu32 cs)\r\n{\r\nstruct bcm2835_spi *bs = spi_master_get_devdata(master);\r\nif (gpio_is_valid(spi->cs_gpio)) {\r\nbcm2835_wr(bs, BCM2835_SPI_CS,\r\ncs | BCM2835_SPI_CS_TA);\r\nbcm2835_wr_fifo(bs);\r\n}\r\ncs |= BCM2835_SPI_CS_INTR | BCM2835_SPI_CS_INTD | BCM2835_SPI_CS_TA;\r\nbcm2835_wr(bs, BCM2835_SPI_CS, cs);\r\nreturn 1;\r\n}\r\nstatic void bcm2835_spi_dma_done(void *data)\r\n{\r\nstruct spi_master *master = data;\r\nstruct bcm2835_spi *bs = spi_master_get_devdata(master);\r\nbcm2835_spi_reset_hw(master);\r\ndmaengine_terminate_all(master->dma_tx);\r\nbs->dma_pending = 0;\r\n;\r\ncomplete(&master->xfer_completion);\r\n}\r\nstatic int bcm2835_spi_prepare_sg(struct spi_master *master,\r\nstruct spi_transfer *tfr,\r\nbool is_tx)\r\n{\r\nstruct dma_chan *chan;\r\nstruct scatterlist *sgl;\r\nunsigned int nents;\r\nenum dma_transfer_direction dir;\r\nunsigned long flags;\r\nstruct dma_async_tx_descriptor *desc;\r\ndma_cookie_t cookie;\r\nif (is_tx) {\r\ndir = DMA_MEM_TO_DEV;\r\nchan = master->dma_tx;\r\nnents = tfr->tx_sg.nents;\r\nsgl = tfr->tx_sg.sgl;\r\nflags = 0 ;\r\n} else {\r\ndir = DMA_DEV_TO_MEM;\r\nchan = master->dma_rx;\r\nnents = tfr->rx_sg.nents;\r\nsgl = tfr->rx_sg.sgl;\r\nflags = DMA_PREP_INTERRUPT;\r\n}\r\ndesc = dmaengine_prep_slave_sg(chan, sgl, nents, dir, flags);\r\nif (!desc)\r\nreturn -EINVAL;\r\nif (!is_tx) {\r\ndesc->callback = bcm2835_spi_dma_done;\r\ndesc->callback_param = master;\r\n}\r\ncookie = dmaengine_submit(desc);\r\nreturn dma_submit_error(cookie);\r\n}\r\nstatic inline int bcm2835_check_sg_length(struct sg_table *sgt)\r\n{\r\nint i;\r\nstruct scatterlist *sgl;\r\nfor_each_sg(sgt->sgl, sgl, (int)sgt->nents - 1, i) {\r\nif (sg_dma_len(sgl) % 4)\r\nreturn -EFAULT;\r\n}\r\nreturn 0;\r\n}\r\nstatic int bcm2835_spi_transfer_one_dma(struct spi_master *master,\r\nstruct spi_device *spi,\r\nstruct spi_transfer *tfr,\r\nu32 cs)\r\n{\r\nstruct bcm2835_spi *bs = spi_master_get_devdata(master);\r\nint ret;\r\nif (bcm2835_check_sg_length(&tfr->tx_sg) ||\r\nbcm2835_check_sg_length(&tfr->rx_sg)) {\r\ndev_warn_once(&spi->dev,\r\n"scatter gather segment length is not a multiple of 4 - falling back to interrupt mode\n");\r\nreturn bcm2835_spi_transfer_one_irq(master, spi, tfr, cs);\r\n}\r\nret = bcm2835_spi_prepare_sg(master, tfr, true);\r\nif (ret)\r\nreturn ret;\r\ndma_async_issue_pending(master->dma_tx);\r\nbs->dma_pending = 1;\r\nbcm2835_wr(bs, BCM2835_SPI_DLEN, tfr->len);\r\nbcm2835_wr(bs, BCM2835_SPI_CS,\r\ncs | BCM2835_SPI_CS_TA | BCM2835_SPI_CS_DMAEN);\r\nret = bcm2835_spi_prepare_sg(master, tfr, false);\r\nif (ret) {\r\ndmaengine_terminate_all(master->dma_tx);\r\nbcm2835_spi_reset_hw(master);\r\nreturn ret;\r\n}\r\ndma_async_issue_pending(master->dma_rx);\r\nreturn 1;\r\n}\r\nstatic bool bcm2835_spi_can_dma(struct spi_master *master,\r\nstruct spi_device *spi,\r\nstruct spi_transfer *tfr)\r\n{\r\nif (!gpio_is_valid(spi->cs_gpio))\r\nreturn false;\r\nif (tfr->len < BCM2835_SPI_DMA_MIN_LENGTH)\r\nreturn false;\r\nif (tfr->len > 65535) {\r\ndev_warn_once(&spi->dev,\r\n"transfer size of %d too big for dma-transfer\n",\r\ntfr->len);\r\nreturn false;\r\n}\r\nif ((((size_t)tfr->rx_buf & 3) == 0) &&\r\n(((size_t)tfr->tx_buf & 3) == 0))\r\nreturn true;\r\nif (((size_t)tfr->tx_buf & (PAGE_SIZE - 1)) + tfr->len > PAGE_SIZE) {\r\ndev_warn_once(&spi->dev,\r\n"Unaligned spi tx-transfer bridging page\n");\r\nreturn false;\r\n}\r\nif (((size_t)tfr->rx_buf & (PAGE_SIZE - 1)) + tfr->len > PAGE_SIZE) {\r\ndev_warn_once(&spi->dev,\r\n"Unaligned spi rx-transfer bridging page\n");\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\nstatic void bcm2835_dma_release(struct spi_master *master)\r\n{\r\nif (master->dma_tx) {\r\ndmaengine_terminate_all(master->dma_tx);\r\ndma_release_channel(master->dma_tx);\r\nmaster->dma_tx = NULL;\r\n}\r\nif (master->dma_rx) {\r\ndmaengine_terminate_all(master->dma_rx);\r\ndma_release_channel(master->dma_rx);\r\nmaster->dma_rx = NULL;\r\n}\r\n}\r\nstatic void bcm2835_dma_init(struct spi_master *master, struct device *dev)\r\n{\r\nstruct dma_slave_config slave_config;\r\nconst __be32 *addr;\r\ndma_addr_t dma_reg_base;\r\nint ret;\r\naddr = of_get_address(master->dev.of_node, 0, NULL, NULL);\r\nif (!addr) {\r\ndev_err(dev, "could not get DMA-register address - not using dma mode\n");\r\ngoto err;\r\n}\r\ndma_reg_base = be32_to_cpup(addr);\r\nmaster->dma_tx = dma_request_slave_channel(dev, "tx");\r\nif (!master->dma_tx) {\r\ndev_err(dev, "no tx-dma configuration found - not using dma mode\n");\r\ngoto err;\r\n}\r\nmaster->dma_rx = dma_request_slave_channel(dev, "rx");\r\nif (!master->dma_rx) {\r\ndev_err(dev, "no rx-dma configuration found - not using dma mode\n");\r\ngoto err_release;\r\n}\r\nslave_config.direction = DMA_MEM_TO_DEV;\r\nslave_config.dst_addr = (u32)(dma_reg_base + BCM2835_SPI_FIFO);\r\nslave_config.dst_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;\r\nret = dmaengine_slave_config(master->dma_tx, &slave_config);\r\nif (ret)\r\ngoto err_config;\r\nslave_config.direction = DMA_DEV_TO_MEM;\r\nslave_config.src_addr = (u32)(dma_reg_base + BCM2835_SPI_FIFO);\r\nslave_config.src_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;\r\nret = dmaengine_slave_config(master->dma_rx, &slave_config);\r\nif (ret)\r\ngoto err_config;\r\nmaster->can_dma = bcm2835_spi_can_dma;\r\nmaster->max_dma_len = 65535;\r\nmaster->flags = SPI_MASTER_MUST_RX | SPI_MASTER_MUST_TX;\r\nreturn;\r\nerr_config:\r\ndev_err(dev, "issue configuring dma: %d - not using DMA mode\n",\r\nret);\r\nerr_release:\r\nbcm2835_dma_release(master);\r\nerr:\r\nreturn;\r\n}\r\nstatic int bcm2835_spi_transfer_one_poll(struct spi_master *master,\r\nstruct spi_device *spi,\r\nstruct spi_transfer *tfr,\r\nu32 cs,\r\nunsigned long long xfer_time_us)\r\n{\r\nstruct bcm2835_spi *bs = spi_master_get_devdata(master);\r\nunsigned long timeout;\r\nbcm2835_wr(bs, BCM2835_SPI_CS, cs | BCM2835_SPI_CS_TA);\r\nbcm2835_wr_fifo(bs);\r\ntimeout = jiffies + BCM2835_SPI_POLLING_JIFFIES;\r\nwhile (bs->rx_len) {\r\nbcm2835_wr_fifo(bs);\r\nbcm2835_rd_fifo(bs);\r\nif (bs->rx_len && time_after(jiffies, timeout)) {\r\ndev_dbg_ratelimited(&spi->dev,\r\n"timeout period reached: jiffies: %lu remaining tx/rx: %d/%d - falling back to interrupt mode\n",\r\njiffies - timeout,\r\nbs->tx_len, bs->rx_len);\r\nreturn bcm2835_spi_transfer_one_irq(master, spi,\r\ntfr, cs);\r\n}\r\n}\r\nbcm2835_spi_reset_hw(master);\r\nreturn 0;\r\n}\r\nstatic int bcm2835_spi_transfer_one(struct spi_master *master,\r\nstruct spi_device *spi,\r\nstruct spi_transfer *tfr)\r\n{\r\nstruct bcm2835_spi *bs = spi_master_get_devdata(master);\r\nunsigned long spi_hz, clk_hz, cdiv;\r\nunsigned long spi_used_hz;\r\nunsigned long long xfer_time_us;\r\nu32 cs = bcm2835_rd(bs, BCM2835_SPI_CS);\r\nspi_hz = tfr->speed_hz;\r\nclk_hz = clk_get_rate(bs->clk);\r\nif (spi_hz >= clk_hz / 2) {\r\ncdiv = 2;\r\n} else if (spi_hz) {\r\ncdiv = DIV_ROUND_UP(clk_hz, spi_hz);\r\ncdiv += (cdiv % 2);\r\nif (cdiv >= 65536)\r\ncdiv = 0;\r\n} else {\r\ncdiv = 0;\r\n}\r\nspi_used_hz = cdiv ? (clk_hz / cdiv) : (clk_hz / 65536);\r\nbcm2835_wr(bs, BCM2835_SPI_CLK, cdiv);\r\nif ((spi->mode & SPI_3WIRE) && (tfr->rx_buf))\r\ncs |= BCM2835_SPI_CS_REN;\r\nelse\r\ncs &= ~BCM2835_SPI_CS_REN;\r\nif (gpio_is_valid(spi->cs_gpio) || (spi->mode & SPI_NO_CS))\r\ncs |= BCM2835_SPI_CS_CS_10 | BCM2835_SPI_CS_CS_01;\r\nbs->tx_buf = tfr->tx_buf;\r\nbs->rx_buf = tfr->rx_buf;\r\nbs->tx_len = tfr->len;\r\nbs->rx_len = tfr->len;\r\nxfer_time_us = (unsigned long long)tfr->len\r\n* 9\r\n* 1000000;\r\ndo_div(xfer_time_us, spi_used_hz);\r\nif (xfer_time_us <= BCM2835_SPI_POLLING_LIMIT_US)\r\nreturn bcm2835_spi_transfer_one_poll(master, spi, tfr,\r\ncs, xfer_time_us);\r\nif (master->can_dma && bcm2835_spi_can_dma(master, spi, tfr))\r\nreturn bcm2835_spi_transfer_one_dma(master, spi, tfr, cs);\r\nreturn bcm2835_spi_transfer_one_irq(master, spi, tfr, cs);\r\n}\r\nstatic int bcm2835_spi_prepare_message(struct spi_master *master,\r\nstruct spi_message *msg)\r\n{\r\nstruct spi_device *spi = msg->spi;\r\nstruct bcm2835_spi *bs = spi_master_get_devdata(master);\r\nu32 cs = bcm2835_rd(bs, BCM2835_SPI_CS);\r\ncs &= ~(BCM2835_SPI_CS_CPOL | BCM2835_SPI_CS_CPHA);\r\nif (spi->mode & SPI_CPOL)\r\ncs |= BCM2835_SPI_CS_CPOL;\r\nif (spi->mode & SPI_CPHA)\r\ncs |= BCM2835_SPI_CS_CPHA;\r\nbcm2835_wr(bs, BCM2835_SPI_CS, cs);\r\nreturn 0;\r\n}\r\nstatic void bcm2835_spi_handle_err(struct spi_master *master,\r\nstruct spi_message *msg)\r\n{\r\nstruct bcm2835_spi *bs = spi_master_get_devdata(master);\r\nif (bs->dma_pending) {\r\ndmaengine_terminate_all(master->dma_tx);\r\ndmaengine_terminate_all(master->dma_rx);\r\nbs->dma_pending = 0;\r\n}\r\nbcm2835_spi_reset_hw(master);\r\n}\r\nstatic void bcm2835_spi_set_cs(struct spi_device *spi, bool gpio_level)\r\n{\r\nstruct spi_master *master = spi->master;\r\nstruct bcm2835_spi *bs = spi_master_get_devdata(master);\r\nu32 cs = bcm2835_rd(bs, BCM2835_SPI_CS);\r\nbool enable;\r\nenable = (spi->mode & SPI_CS_HIGH) ? gpio_level : !gpio_level;\r\nif (spi->mode & SPI_CS_HIGH) {\r\ncs |= BCM2835_SPI_CS_CSPOL;\r\ncs |= BCM2835_SPI_CS_CSPOL0 << spi->chip_select;\r\n} else {\r\ncs &= ~BCM2835_SPI_CS_CSPOL;\r\ncs &= ~(BCM2835_SPI_CS_CSPOL0 << spi->chip_select);\r\n}\r\nif (enable) {\r\nif (spi->mode & SPI_NO_CS) {\r\ncs |= BCM2835_SPI_CS_CS_10 | BCM2835_SPI_CS_CS_01;\r\n} else {\r\ncs &= ~(BCM2835_SPI_CS_CS_10 | BCM2835_SPI_CS_CS_01);\r\ncs |= spi->chip_select;\r\n}\r\n} else {\r\ncs &= ~BCM2835_SPI_CS_CSPOL;\r\ncs |= BCM2835_SPI_CS_CS_10 | BCM2835_SPI_CS_CS_01;\r\n}\r\nbcm2835_wr(bs, BCM2835_SPI_CS, cs);\r\n}\r\nstatic int chip_match_name(struct gpio_chip *chip, void *data)\r\n{\r\nreturn !strcmp(chip->label, data);\r\n}\r\nstatic int bcm2835_spi_setup(struct spi_device *spi)\r\n{\r\nint err;\r\nstruct gpio_chip *chip;\r\nif (spi->mode & SPI_NO_CS)\r\nreturn 0;\r\nif (gpio_is_valid(spi->cs_gpio))\r\nreturn 0;\r\nif (spi->chip_select > 1) {\r\ndev_err(&spi->dev,\r\n"setup: only two native chip-selects are supported\n");\r\nreturn -EINVAL;\r\n}\r\nchip = gpiochip_find("pinctrl-bcm2835", chip_match_name);\r\nif (!chip)\r\nreturn 0;\r\nspi->cs_gpio = chip->base + 8 - spi->chip_select;\r\ndev_info(&spi->dev, "setting up native-CS%i as GPIO %i\n",\r\nspi->chip_select, spi->cs_gpio);\r\nerr = gpio_direction_output(spi->cs_gpio,\r\n(spi->mode & SPI_CS_HIGH) ? 0 : 1);\r\nif (err) {\r\ndev_err(&spi->dev,\r\n"could not set CS%i gpio %i as output: %i",\r\nspi->chip_select, spi->cs_gpio, err);\r\nreturn err;\r\n}\r\ngpio_set_value(spi->cs_gpio, (spi->mode & SPI_CS_HIGH) ? 0 : 1);\r\nreturn 0;\r\n}\r\nstatic int bcm2835_spi_probe(struct platform_device *pdev)\r\n{\r\nstruct spi_master *master;\r\nstruct bcm2835_spi *bs;\r\nstruct resource *res;\r\nint err;\r\nmaster = spi_alloc_master(&pdev->dev, sizeof(*bs));\r\nif (!master) {\r\ndev_err(&pdev->dev, "spi_alloc_master() failed\n");\r\nreturn -ENOMEM;\r\n}\r\nplatform_set_drvdata(pdev, master);\r\nmaster->mode_bits = BCM2835_SPI_MODE_BITS;\r\nmaster->bits_per_word_mask = SPI_BPW_MASK(8);\r\nmaster->num_chipselect = 3;\r\nmaster->setup = bcm2835_spi_setup;\r\nmaster->set_cs = bcm2835_spi_set_cs;\r\nmaster->transfer_one = bcm2835_spi_transfer_one;\r\nmaster->handle_err = bcm2835_spi_handle_err;\r\nmaster->prepare_message = bcm2835_spi_prepare_message;\r\nmaster->dev.of_node = pdev->dev.of_node;\r\nbs = spi_master_get_devdata(master);\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nbs->regs = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(bs->regs)) {\r\nerr = PTR_ERR(bs->regs);\r\ngoto out_master_put;\r\n}\r\nbs->clk = devm_clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(bs->clk)) {\r\nerr = PTR_ERR(bs->clk);\r\ndev_err(&pdev->dev, "could not get clk: %d\n", err);\r\ngoto out_master_put;\r\n}\r\nbs->irq = platform_get_irq(pdev, 0);\r\nif (bs->irq <= 0) {\r\ndev_err(&pdev->dev, "could not get IRQ: %d\n", bs->irq);\r\nerr = bs->irq ? bs->irq : -ENODEV;\r\ngoto out_master_put;\r\n}\r\nclk_prepare_enable(bs->clk);\r\nbcm2835_dma_init(master, &pdev->dev);\r\nbcm2835_wr(bs, BCM2835_SPI_CS,\r\nBCM2835_SPI_CS_CLEAR_RX | BCM2835_SPI_CS_CLEAR_TX);\r\nerr = devm_request_irq(&pdev->dev, bs->irq, bcm2835_spi_interrupt, 0,\r\ndev_name(&pdev->dev), master);\r\nif (err) {\r\ndev_err(&pdev->dev, "could not request IRQ: %d\n", err);\r\ngoto out_clk_disable;\r\n}\r\nerr = devm_spi_register_master(&pdev->dev, master);\r\nif (err) {\r\ndev_err(&pdev->dev, "could not register SPI master: %d\n", err);\r\ngoto out_clk_disable;\r\n}\r\nreturn 0;\r\nout_clk_disable:\r\nclk_disable_unprepare(bs->clk);\r\nout_master_put:\r\nspi_master_put(master);\r\nreturn err;\r\n}\r\nstatic int bcm2835_spi_remove(struct platform_device *pdev)\r\n{\r\nstruct spi_master *master = platform_get_drvdata(pdev);\r\nstruct bcm2835_spi *bs = spi_master_get_devdata(master);\r\nbcm2835_wr(bs, BCM2835_SPI_CS,\r\nBCM2835_SPI_CS_CLEAR_RX | BCM2835_SPI_CS_CLEAR_TX);\r\nclk_disable_unprepare(bs->clk);\r\nbcm2835_dma_release(master);\r\nreturn 0;\r\n}
