static void update_range(struct sw_flow_match *match,\r\nsize_t offset, size_t size, bool is_mask)\r\n{\r\nstruct sw_flow_key_range *range;\r\nsize_t start = rounddown(offset, sizeof(long));\r\nsize_t end = roundup(offset + size, sizeof(long));\r\nif (!is_mask)\r\nrange = &match->range;\r\nelse\r\nrange = &match->mask->range;\r\nif (range->start == range->end) {\r\nrange->start = start;\r\nrange->end = end;\r\nreturn;\r\n}\r\nif (range->start > start)\r\nrange->start = start;\r\nif (range->end < end)\r\nrange->end = end;\r\n}\r\nstatic bool match_validate(const struct sw_flow_match *match,\r\nu64 key_attrs, u64 mask_attrs, bool log)\r\n{\r\nu64 key_expected = 1 << OVS_KEY_ATTR_ETHERNET;\r\nu64 mask_allowed = key_attrs;\r\nmask_allowed &= ~((1 << OVS_KEY_ATTR_IPV4)\r\n| (1 << OVS_KEY_ATTR_IPV6)\r\n| (1 << OVS_KEY_ATTR_TCP)\r\n| (1 << OVS_KEY_ATTR_TCP_FLAGS)\r\n| (1 << OVS_KEY_ATTR_UDP)\r\n| (1 << OVS_KEY_ATTR_SCTP)\r\n| (1 << OVS_KEY_ATTR_ICMP)\r\n| (1 << OVS_KEY_ATTR_ICMPV6)\r\n| (1 << OVS_KEY_ATTR_ARP)\r\n| (1 << OVS_KEY_ATTR_ND)\r\n| (1 << OVS_KEY_ATTR_MPLS));\r\nmask_allowed |= ((1 << OVS_KEY_ATTR_TUNNEL)\r\n| (1 << OVS_KEY_ATTR_IN_PORT)\r\n| (1 << OVS_KEY_ATTR_ETHERTYPE));\r\nif (match->key->eth.type == htons(ETH_P_ARP)\r\n|| match->key->eth.type == htons(ETH_P_RARP)) {\r\nkey_expected |= 1 << OVS_KEY_ATTR_ARP;\r\nif (match->mask && (match->mask->key.eth.type == htons(0xffff)))\r\nmask_allowed |= 1 << OVS_KEY_ATTR_ARP;\r\n}\r\nif (eth_p_mpls(match->key->eth.type)) {\r\nkey_expected |= 1 << OVS_KEY_ATTR_MPLS;\r\nif (match->mask && (match->mask->key.eth.type == htons(0xffff)))\r\nmask_allowed |= 1 << OVS_KEY_ATTR_MPLS;\r\n}\r\nif (match->key->eth.type == htons(ETH_P_IP)) {\r\nkey_expected |= 1 << OVS_KEY_ATTR_IPV4;\r\nif (match->mask && (match->mask->key.eth.type == htons(0xffff)))\r\nmask_allowed |= 1 << OVS_KEY_ATTR_IPV4;\r\nif (match->key->ip.frag != OVS_FRAG_TYPE_LATER) {\r\nif (match->key->ip.proto == IPPROTO_UDP) {\r\nkey_expected |= 1 << OVS_KEY_ATTR_UDP;\r\nif (match->mask && (match->mask->key.ip.proto == 0xff))\r\nmask_allowed |= 1 << OVS_KEY_ATTR_UDP;\r\n}\r\nif (match->key->ip.proto == IPPROTO_SCTP) {\r\nkey_expected |= 1 << OVS_KEY_ATTR_SCTP;\r\nif (match->mask && (match->mask->key.ip.proto == 0xff))\r\nmask_allowed |= 1 << OVS_KEY_ATTR_SCTP;\r\n}\r\nif (match->key->ip.proto == IPPROTO_TCP) {\r\nkey_expected |= 1 << OVS_KEY_ATTR_TCP;\r\nkey_expected |= 1 << OVS_KEY_ATTR_TCP_FLAGS;\r\nif (match->mask && (match->mask->key.ip.proto == 0xff)) {\r\nmask_allowed |= 1 << OVS_KEY_ATTR_TCP;\r\nmask_allowed |= 1 << OVS_KEY_ATTR_TCP_FLAGS;\r\n}\r\n}\r\nif (match->key->ip.proto == IPPROTO_ICMP) {\r\nkey_expected |= 1 << OVS_KEY_ATTR_ICMP;\r\nif (match->mask && (match->mask->key.ip.proto == 0xff))\r\nmask_allowed |= 1 << OVS_KEY_ATTR_ICMP;\r\n}\r\n}\r\n}\r\nif (match->key->eth.type == htons(ETH_P_IPV6)) {\r\nkey_expected |= 1 << OVS_KEY_ATTR_IPV6;\r\nif (match->mask && (match->mask->key.eth.type == htons(0xffff)))\r\nmask_allowed |= 1 << OVS_KEY_ATTR_IPV6;\r\nif (match->key->ip.frag != OVS_FRAG_TYPE_LATER) {\r\nif (match->key->ip.proto == IPPROTO_UDP) {\r\nkey_expected |= 1 << OVS_KEY_ATTR_UDP;\r\nif (match->mask && (match->mask->key.ip.proto == 0xff))\r\nmask_allowed |= 1 << OVS_KEY_ATTR_UDP;\r\n}\r\nif (match->key->ip.proto == IPPROTO_SCTP) {\r\nkey_expected |= 1 << OVS_KEY_ATTR_SCTP;\r\nif (match->mask && (match->mask->key.ip.proto == 0xff))\r\nmask_allowed |= 1 << OVS_KEY_ATTR_SCTP;\r\n}\r\nif (match->key->ip.proto == IPPROTO_TCP) {\r\nkey_expected |= 1 << OVS_KEY_ATTR_TCP;\r\nkey_expected |= 1 << OVS_KEY_ATTR_TCP_FLAGS;\r\nif (match->mask && (match->mask->key.ip.proto == 0xff)) {\r\nmask_allowed |= 1 << OVS_KEY_ATTR_TCP;\r\nmask_allowed |= 1 << OVS_KEY_ATTR_TCP_FLAGS;\r\n}\r\n}\r\nif (match->key->ip.proto == IPPROTO_ICMPV6) {\r\nkey_expected |= 1 << OVS_KEY_ATTR_ICMPV6;\r\nif (match->mask && (match->mask->key.ip.proto == 0xff))\r\nmask_allowed |= 1 << OVS_KEY_ATTR_ICMPV6;\r\nif (match->key->tp.src ==\r\nhtons(NDISC_NEIGHBOUR_SOLICITATION) ||\r\nmatch->key->tp.src == htons(NDISC_NEIGHBOUR_ADVERTISEMENT)) {\r\nkey_expected |= 1 << OVS_KEY_ATTR_ND;\r\nif (match->mask && (match->mask->key.tp.src == htons(0xff)))\r\nmask_allowed |= 1 << OVS_KEY_ATTR_ND;\r\n}\r\n}\r\n}\r\n}\r\nif ((key_attrs & key_expected) != key_expected) {\r\nOVS_NLERR(log, "Missing key (keys=%llx, expected=%llx)",\r\n(unsigned long long)key_attrs,\r\n(unsigned long long)key_expected);\r\nreturn false;\r\n}\r\nif ((mask_attrs & mask_allowed) != mask_attrs) {\r\nOVS_NLERR(log, "Unexpected mask (mask=%llx, allowed=%llx)",\r\n(unsigned long long)mask_attrs,\r\n(unsigned long long)mask_allowed);\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\nsize_t ovs_tun_key_attr_size(void)\r\n{\r\nreturn nla_total_size(8)\r\n+ nla_total_size(16)\r\n+ nla_total_size(16)\r\n+ nla_total_size(1)\r\n+ nla_total_size(1)\r\n+ nla_total_size(0)\r\n+ nla_total_size(0)\r\n+ nla_total_size(0)\r\n+ nla_total_size(256)\r\n+ nla_total_size(2)\r\n+ nla_total_size(2);\r\n}\r\nsize_t ovs_key_attr_size(void)\r\n{\r\nBUILD_BUG_ON(OVS_KEY_ATTR_TUNNEL_INFO != 26);\r\nreturn nla_total_size(4)\r\n+ nla_total_size(0)\r\n+ ovs_tun_key_attr_size()\r\n+ nla_total_size(4)\r\n+ nla_total_size(4)\r\n+ nla_total_size(4)\r\n+ nla_total_size(4)\r\n+ nla_total_size(4)\r\n+ nla_total_size(2)\r\n+ nla_total_size(4)\r\n+ nla_total_size(16)\r\n+ nla_total_size(12)\r\n+ nla_total_size(2)\r\n+ nla_total_size(4)\r\n+ nla_total_size(0)\r\n+ nla_total_size(2)\r\n+ nla_total_size(40)\r\n+ nla_total_size(2)\r\n+ nla_total_size(28);\r\n}\r\nstatic bool check_attr_len(unsigned int attr_len, unsigned int expected_len)\r\n{\r\nreturn expected_len == attr_len ||\r\nexpected_len == OVS_ATTR_NESTED ||\r\nexpected_len == OVS_ATTR_VARIABLE;\r\n}\r\nstatic bool is_all_zero(const u8 *fp, size_t size)\r\n{\r\nint i;\r\nif (!fp)\r\nreturn false;\r\nfor (i = 0; i < size; i++)\r\nif (fp[i])\r\nreturn false;\r\nreturn true;\r\n}\r\nstatic int __parse_flow_nlattrs(const struct nlattr *attr,\r\nconst struct nlattr *a[],\r\nu64 *attrsp, bool log, bool nz)\r\n{\r\nconst struct nlattr *nla;\r\nu64 attrs;\r\nint rem;\r\nattrs = *attrsp;\r\nnla_for_each_nested(nla, attr, rem) {\r\nu16 type = nla_type(nla);\r\nint expected_len;\r\nif (type > OVS_KEY_ATTR_MAX) {\r\nOVS_NLERR(log, "Key type %d is out of range max %d",\r\ntype, OVS_KEY_ATTR_MAX);\r\nreturn -EINVAL;\r\n}\r\nif (attrs & (1 << type)) {\r\nOVS_NLERR(log, "Duplicate key (type %d).", type);\r\nreturn -EINVAL;\r\n}\r\nexpected_len = ovs_key_lens[type].len;\r\nif (!check_attr_len(nla_len(nla), expected_len)) {\r\nOVS_NLERR(log, "Key %d has unexpected len %d expected %d",\r\ntype, nla_len(nla), expected_len);\r\nreturn -EINVAL;\r\n}\r\nif (!nz || !is_all_zero(nla_data(nla), expected_len)) {\r\nattrs |= 1 << type;\r\na[type] = nla;\r\n}\r\n}\r\nif (rem) {\r\nOVS_NLERR(log, "Message has %d unknown bytes.", rem);\r\nreturn -EINVAL;\r\n}\r\n*attrsp = attrs;\r\nreturn 0;\r\n}\r\nstatic int parse_flow_mask_nlattrs(const struct nlattr *attr,\r\nconst struct nlattr *a[], u64 *attrsp,\r\nbool log)\r\n{\r\nreturn __parse_flow_nlattrs(attr, a, attrsp, log, true);\r\n}\r\nstatic int parse_flow_nlattrs(const struct nlattr *attr,\r\nconst struct nlattr *a[], u64 *attrsp,\r\nbool log)\r\n{\r\nreturn __parse_flow_nlattrs(attr, a, attrsp, log, false);\r\n}\r\nstatic int genev_tun_opt_from_nlattr(const struct nlattr *a,\r\nstruct sw_flow_match *match, bool is_mask,\r\nbool log)\r\n{\r\nunsigned long opt_key_offset;\r\nif (nla_len(a) > sizeof(match->key->tun_opts)) {\r\nOVS_NLERR(log, "Geneve option length err (len %d, max %zu).",\r\nnla_len(a), sizeof(match->key->tun_opts));\r\nreturn -EINVAL;\r\n}\r\nif (nla_len(a) % 4 != 0) {\r\nOVS_NLERR(log, "Geneve opt len %d is not a multiple of 4.",\r\nnla_len(a));\r\nreturn -EINVAL;\r\n}\r\nif (!is_mask) {\r\nSW_FLOW_KEY_PUT(match, tun_opts_len, nla_len(a),\r\nfalse);\r\n} else {\r\nif (match->key->tun_opts_len != nla_len(a)) {\r\nOVS_NLERR(log, "Geneve option len %d != mask len %d",\r\nmatch->key->tun_opts_len, nla_len(a));\r\nreturn -EINVAL;\r\n}\r\nSW_FLOW_KEY_PUT(match, tun_opts_len, 0xff, true);\r\n}\r\nopt_key_offset = TUN_METADATA_OFFSET(nla_len(a));\r\nSW_FLOW_KEY_MEMCPY_OFFSET(match, opt_key_offset, nla_data(a),\r\nnla_len(a), is_mask);\r\nreturn 0;\r\n}\r\nstatic int vxlan_tun_opt_from_nlattr(const struct nlattr *attr,\r\nstruct sw_flow_match *match, bool is_mask,\r\nbool log)\r\n{\r\nstruct nlattr *a;\r\nint rem;\r\nunsigned long opt_key_offset;\r\nstruct vxlan_metadata opts;\r\nBUILD_BUG_ON(sizeof(opts) > sizeof(match->key->tun_opts));\r\nmemset(&opts, 0, sizeof(opts));\r\nnla_for_each_nested(a, attr, rem) {\r\nint type = nla_type(a);\r\nif (type > OVS_VXLAN_EXT_MAX) {\r\nOVS_NLERR(log, "VXLAN extension %d out of range max %d",\r\ntype, OVS_VXLAN_EXT_MAX);\r\nreturn -EINVAL;\r\n}\r\nif (!check_attr_len(nla_len(a),\r\novs_vxlan_ext_key_lens[type].len)) {\r\nOVS_NLERR(log, "VXLAN extension %d has unexpected len %d expected %d",\r\ntype, nla_len(a),\r\novs_vxlan_ext_key_lens[type].len);\r\nreturn -EINVAL;\r\n}\r\nswitch (type) {\r\ncase OVS_VXLAN_EXT_GBP:\r\nopts.gbp = nla_get_u32(a);\r\nbreak;\r\ndefault:\r\nOVS_NLERR(log, "Unknown VXLAN extension attribute %d",\r\ntype);\r\nreturn -EINVAL;\r\n}\r\n}\r\nif (rem) {\r\nOVS_NLERR(log, "VXLAN extension message has %d unknown bytes.",\r\nrem);\r\nreturn -EINVAL;\r\n}\r\nif (!is_mask)\r\nSW_FLOW_KEY_PUT(match, tun_opts_len, sizeof(opts), false);\r\nelse\r\nSW_FLOW_KEY_PUT(match, tun_opts_len, 0xff, true);\r\nopt_key_offset = TUN_METADATA_OFFSET(sizeof(opts));\r\nSW_FLOW_KEY_MEMCPY_OFFSET(match, opt_key_offset, &opts, sizeof(opts),\r\nis_mask);\r\nreturn 0;\r\n}\r\nstatic int ip_tun_from_nlattr(const struct nlattr *attr,\r\nstruct sw_flow_match *match, bool is_mask,\r\nbool log)\r\n{\r\nbool ttl = false, ipv4 = false, ipv6 = false;\r\n__be16 tun_flags = 0;\r\nint opts_type = 0;\r\nstruct nlattr *a;\r\nint rem;\r\nnla_for_each_nested(a, attr, rem) {\r\nint type = nla_type(a);\r\nint err;\r\nif (type > OVS_TUNNEL_KEY_ATTR_MAX) {\r\nOVS_NLERR(log, "Tunnel attr %d out of range max %d",\r\ntype, OVS_TUNNEL_KEY_ATTR_MAX);\r\nreturn -EINVAL;\r\n}\r\nif (!check_attr_len(nla_len(a),\r\novs_tunnel_key_lens[type].len)) {\r\nOVS_NLERR(log, "Tunnel attr %d has unexpected len %d expected %d",\r\ntype, nla_len(a), ovs_tunnel_key_lens[type].len);\r\nreturn -EINVAL;\r\n}\r\nswitch (type) {\r\ncase OVS_TUNNEL_KEY_ATTR_ID:\r\nSW_FLOW_KEY_PUT(match, tun_key.tun_id,\r\nnla_get_be64(a), is_mask);\r\ntun_flags |= TUNNEL_KEY;\r\nbreak;\r\ncase OVS_TUNNEL_KEY_ATTR_IPV4_SRC:\r\nSW_FLOW_KEY_PUT(match, tun_key.u.ipv4.src,\r\nnla_get_in_addr(a), is_mask);\r\nipv4 = true;\r\nbreak;\r\ncase OVS_TUNNEL_KEY_ATTR_IPV4_DST:\r\nSW_FLOW_KEY_PUT(match, tun_key.u.ipv4.dst,\r\nnla_get_in_addr(a), is_mask);\r\nipv4 = true;\r\nbreak;\r\ncase OVS_TUNNEL_KEY_ATTR_IPV6_SRC:\r\nSW_FLOW_KEY_PUT(match, tun_key.u.ipv6.dst,\r\nnla_get_in6_addr(a), is_mask);\r\nipv6 = true;\r\nbreak;\r\ncase OVS_TUNNEL_KEY_ATTR_IPV6_DST:\r\nSW_FLOW_KEY_PUT(match, tun_key.u.ipv6.dst,\r\nnla_get_in6_addr(a), is_mask);\r\nipv6 = true;\r\nbreak;\r\ncase OVS_TUNNEL_KEY_ATTR_TOS:\r\nSW_FLOW_KEY_PUT(match, tun_key.tos,\r\nnla_get_u8(a), is_mask);\r\nbreak;\r\ncase OVS_TUNNEL_KEY_ATTR_TTL:\r\nSW_FLOW_KEY_PUT(match, tun_key.ttl,\r\nnla_get_u8(a), is_mask);\r\nttl = true;\r\nbreak;\r\ncase OVS_TUNNEL_KEY_ATTR_DONT_FRAGMENT:\r\ntun_flags |= TUNNEL_DONT_FRAGMENT;\r\nbreak;\r\ncase OVS_TUNNEL_KEY_ATTR_CSUM:\r\ntun_flags |= TUNNEL_CSUM;\r\nbreak;\r\ncase OVS_TUNNEL_KEY_ATTR_TP_SRC:\r\nSW_FLOW_KEY_PUT(match, tun_key.tp_src,\r\nnla_get_be16(a), is_mask);\r\nbreak;\r\ncase OVS_TUNNEL_KEY_ATTR_TP_DST:\r\nSW_FLOW_KEY_PUT(match, tun_key.tp_dst,\r\nnla_get_be16(a), is_mask);\r\nbreak;\r\ncase OVS_TUNNEL_KEY_ATTR_OAM:\r\ntun_flags |= TUNNEL_OAM;\r\nbreak;\r\ncase OVS_TUNNEL_KEY_ATTR_GENEVE_OPTS:\r\nif (opts_type) {\r\nOVS_NLERR(log, "Multiple metadata blocks provided");\r\nreturn -EINVAL;\r\n}\r\nerr = genev_tun_opt_from_nlattr(a, match, is_mask, log);\r\nif (err)\r\nreturn err;\r\ntun_flags |= TUNNEL_GENEVE_OPT;\r\nopts_type = type;\r\nbreak;\r\ncase OVS_TUNNEL_KEY_ATTR_VXLAN_OPTS:\r\nif (opts_type) {\r\nOVS_NLERR(log, "Multiple metadata blocks provided");\r\nreturn -EINVAL;\r\n}\r\nerr = vxlan_tun_opt_from_nlattr(a, match, is_mask, log);\r\nif (err)\r\nreturn err;\r\ntun_flags |= TUNNEL_VXLAN_OPT;\r\nopts_type = type;\r\nbreak;\r\ndefault:\r\nOVS_NLERR(log, "Unknown IP tunnel attribute %d",\r\ntype);\r\nreturn -EINVAL;\r\n}\r\n}\r\nSW_FLOW_KEY_PUT(match, tun_key.tun_flags, tun_flags, is_mask);\r\nif (is_mask)\r\nSW_FLOW_KEY_MEMSET_FIELD(match, tun_proto, 0xff, true);\r\nelse\r\nSW_FLOW_KEY_PUT(match, tun_proto, ipv6 ? AF_INET6 : AF_INET,\r\nfalse);\r\nif (rem > 0) {\r\nOVS_NLERR(log, "IP tunnel attribute has %d unknown bytes.",\r\nrem);\r\nreturn -EINVAL;\r\n}\r\nif (ipv4 && ipv6) {\r\nOVS_NLERR(log, "Mixed IPv4 and IPv6 tunnel attributes");\r\nreturn -EINVAL;\r\n}\r\nif (!is_mask) {\r\nif (!ipv4 && !ipv6) {\r\nOVS_NLERR(log, "IP tunnel dst address not specified");\r\nreturn -EINVAL;\r\n}\r\nif (ipv4 && !match->key->tun_key.u.ipv4.dst) {\r\nOVS_NLERR(log, "IPv4 tunnel dst address is zero");\r\nreturn -EINVAL;\r\n}\r\nif (ipv6 && ipv6_addr_any(&match->key->tun_key.u.ipv6.dst)) {\r\nOVS_NLERR(log, "IPv6 tunnel dst address is zero");\r\nreturn -EINVAL;\r\n}\r\nif (!ttl) {\r\nOVS_NLERR(log, "IP tunnel TTL not specified.");\r\nreturn -EINVAL;\r\n}\r\n}\r\nreturn opts_type;\r\n}\r\nstatic int vxlan_opt_to_nlattr(struct sk_buff *skb,\r\nconst void *tun_opts, int swkey_tun_opts_len)\r\n{\r\nconst struct vxlan_metadata *opts = tun_opts;\r\nstruct nlattr *nla;\r\nnla = nla_nest_start(skb, OVS_TUNNEL_KEY_ATTR_VXLAN_OPTS);\r\nif (!nla)\r\nreturn -EMSGSIZE;\r\nif (nla_put_u32(skb, OVS_VXLAN_EXT_GBP, opts->gbp) < 0)\r\nreturn -EMSGSIZE;\r\nnla_nest_end(skb, nla);\r\nreturn 0;\r\n}\r\nstatic int __ip_tun_to_nlattr(struct sk_buff *skb,\r\nconst struct ip_tunnel_key *output,\r\nconst void *tun_opts, int swkey_tun_opts_len,\r\nunsigned short tun_proto)\r\n{\r\nif (output->tun_flags & TUNNEL_KEY &&\r\nnla_put_be64(skb, OVS_TUNNEL_KEY_ATTR_ID, output->tun_id))\r\nreturn -EMSGSIZE;\r\nswitch (tun_proto) {\r\ncase AF_INET:\r\nif (output->u.ipv4.src &&\r\nnla_put_in_addr(skb, OVS_TUNNEL_KEY_ATTR_IPV4_SRC,\r\noutput->u.ipv4.src))\r\nreturn -EMSGSIZE;\r\nif (output->u.ipv4.dst &&\r\nnla_put_in_addr(skb, OVS_TUNNEL_KEY_ATTR_IPV4_DST,\r\noutput->u.ipv4.dst))\r\nreturn -EMSGSIZE;\r\nbreak;\r\ncase AF_INET6:\r\nif (!ipv6_addr_any(&output->u.ipv6.src) &&\r\nnla_put_in6_addr(skb, OVS_TUNNEL_KEY_ATTR_IPV6_SRC,\r\n&output->u.ipv6.src))\r\nreturn -EMSGSIZE;\r\nif (!ipv6_addr_any(&output->u.ipv6.dst) &&\r\nnla_put_in6_addr(skb, OVS_TUNNEL_KEY_ATTR_IPV6_DST,\r\n&output->u.ipv6.dst))\r\nreturn -EMSGSIZE;\r\nbreak;\r\n}\r\nif (output->tos &&\r\nnla_put_u8(skb, OVS_TUNNEL_KEY_ATTR_TOS, output->tos))\r\nreturn -EMSGSIZE;\r\nif (nla_put_u8(skb, OVS_TUNNEL_KEY_ATTR_TTL, output->ttl))\r\nreturn -EMSGSIZE;\r\nif ((output->tun_flags & TUNNEL_DONT_FRAGMENT) &&\r\nnla_put_flag(skb, OVS_TUNNEL_KEY_ATTR_DONT_FRAGMENT))\r\nreturn -EMSGSIZE;\r\nif ((output->tun_flags & TUNNEL_CSUM) &&\r\nnla_put_flag(skb, OVS_TUNNEL_KEY_ATTR_CSUM))\r\nreturn -EMSGSIZE;\r\nif (output->tp_src &&\r\nnla_put_be16(skb, OVS_TUNNEL_KEY_ATTR_TP_SRC, output->tp_src))\r\nreturn -EMSGSIZE;\r\nif (output->tp_dst &&\r\nnla_put_be16(skb, OVS_TUNNEL_KEY_ATTR_TP_DST, output->tp_dst))\r\nreturn -EMSGSIZE;\r\nif ((output->tun_flags & TUNNEL_OAM) &&\r\nnla_put_flag(skb, OVS_TUNNEL_KEY_ATTR_OAM))\r\nreturn -EMSGSIZE;\r\nif (swkey_tun_opts_len) {\r\nif (output->tun_flags & TUNNEL_GENEVE_OPT &&\r\nnla_put(skb, OVS_TUNNEL_KEY_ATTR_GENEVE_OPTS,\r\nswkey_tun_opts_len, tun_opts))\r\nreturn -EMSGSIZE;\r\nelse if (output->tun_flags & TUNNEL_VXLAN_OPT &&\r\nvxlan_opt_to_nlattr(skb, tun_opts, swkey_tun_opts_len))\r\nreturn -EMSGSIZE;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ip_tun_to_nlattr(struct sk_buff *skb,\r\nconst struct ip_tunnel_key *output,\r\nconst void *tun_opts, int swkey_tun_opts_len,\r\nunsigned short tun_proto)\r\n{\r\nstruct nlattr *nla;\r\nint err;\r\nnla = nla_nest_start(skb, OVS_KEY_ATTR_TUNNEL);\r\nif (!nla)\r\nreturn -EMSGSIZE;\r\nerr = __ip_tun_to_nlattr(skb, output, tun_opts, swkey_tun_opts_len,\r\ntun_proto);\r\nif (err)\r\nreturn err;\r\nnla_nest_end(skb, nla);\r\nreturn 0;\r\n}\r\nint ovs_nla_put_tunnel_info(struct sk_buff *skb,\r\nstruct ip_tunnel_info *tun_info)\r\n{\r\nreturn __ip_tun_to_nlattr(skb, &tun_info->key,\r\nip_tunnel_info_opts(tun_info),\r\ntun_info->options_len,\r\nip_tunnel_info_af(tun_info));\r\n}\r\nstatic int metadata_from_nlattrs(struct net *net, struct sw_flow_match *match,\r\nu64 *attrs, const struct nlattr **a,\r\nbool is_mask, bool log)\r\n{\r\nif (*attrs & (1 << OVS_KEY_ATTR_DP_HASH)) {\r\nu32 hash_val = nla_get_u32(a[OVS_KEY_ATTR_DP_HASH]);\r\nSW_FLOW_KEY_PUT(match, ovs_flow_hash, hash_val, is_mask);\r\n*attrs &= ~(1 << OVS_KEY_ATTR_DP_HASH);\r\n}\r\nif (*attrs & (1 << OVS_KEY_ATTR_RECIRC_ID)) {\r\nu32 recirc_id = nla_get_u32(a[OVS_KEY_ATTR_RECIRC_ID]);\r\nSW_FLOW_KEY_PUT(match, recirc_id, recirc_id, is_mask);\r\n*attrs &= ~(1 << OVS_KEY_ATTR_RECIRC_ID);\r\n}\r\nif (*attrs & (1 << OVS_KEY_ATTR_PRIORITY)) {\r\nSW_FLOW_KEY_PUT(match, phy.priority,\r\nnla_get_u32(a[OVS_KEY_ATTR_PRIORITY]), is_mask);\r\n*attrs &= ~(1 << OVS_KEY_ATTR_PRIORITY);\r\n}\r\nif (*attrs & (1 << OVS_KEY_ATTR_IN_PORT)) {\r\nu32 in_port = nla_get_u32(a[OVS_KEY_ATTR_IN_PORT]);\r\nif (is_mask) {\r\nin_port = 0xffffffff;\r\n} else if (in_port >= DP_MAX_PORTS) {\r\nOVS_NLERR(log, "Port %d exceeds max allowable %d",\r\nin_port, DP_MAX_PORTS);\r\nreturn -EINVAL;\r\n}\r\nSW_FLOW_KEY_PUT(match, phy.in_port, in_port, is_mask);\r\n*attrs &= ~(1 << OVS_KEY_ATTR_IN_PORT);\r\n} else if (!is_mask) {\r\nSW_FLOW_KEY_PUT(match, phy.in_port, DP_MAX_PORTS, is_mask);\r\n}\r\nif (*attrs & (1 << OVS_KEY_ATTR_SKB_MARK)) {\r\nuint32_t mark = nla_get_u32(a[OVS_KEY_ATTR_SKB_MARK]);\r\nSW_FLOW_KEY_PUT(match, phy.skb_mark, mark, is_mask);\r\n*attrs &= ~(1 << OVS_KEY_ATTR_SKB_MARK);\r\n}\r\nif (*attrs & (1 << OVS_KEY_ATTR_TUNNEL)) {\r\nif (ip_tun_from_nlattr(a[OVS_KEY_ATTR_TUNNEL], match,\r\nis_mask, log) < 0)\r\nreturn -EINVAL;\r\n*attrs &= ~(1 << OVS_KEY_ATTR_TUNNEL);\r\n}\r\nif (*attrs & (1 << OVS_KEY_ATTR_CT_STATE) &&\r\novs_ct_verify(net, OVS_KEY_ATTR_CT_STATE)) {\r\nu32 ct_state = nla_get_u32(a[OVS_KEY_ATTR_CT_STATE]);\r\nif (ct_state & ~CT_SUPPORTED_MASK) {\r\nOVS_NLERR(log, "ct_state flags %08x unsupported",\r\nct_state);\r\nreturn -EINVAL;\r\n}\r\nSW_FLOW_KEY_PUT(match, ct.state, ct_state, is_mask);\r\n*attrs &= ~(1ULL << OVS_KEY_ATTR_CT_STATE);\r\n}\r\nif (*attrs & (1 << OVS_KEY_ATTR_CT_ZONE) &&\r\novs_ct_verify(net, OVS_KEY_ATTR_CT_ZONE)) {\r\nu16 ct_zone = nla_get_u16(a[OVS_KEY_ATTR_CT_ZONE]);\r\nSW_FLOW_KEY_PUT(match, ct.zone, ct_zone, is_mask);\r\n*attrs &= ~(1ULL << OVS_KEY_ATTR_CT_ZONE);\r\n}\r\nif (*attrs & (1 << OVS_KEY_ATTR_CT_MARK) &&\r\novs_ct_verify(net, OVS_KEY_ATTR_CT_MARK)) {\r\nu32 mark = nla_get_u32(a[OVS_KEY_ATTR_CT_MARK]);\r\nSW_FLOW_KEY_PUT(match, ct.mark, mark, is_mask);\r\n*attrs &= ~(1ULL << OVS_KEY_ATTR_CT_MARK);\r\n}\r\nif (*attrs & (1 << OVS_KEY_ATTR_CT_LABELS) &&\r\novs_ct_verify(net, OVS_KEY_ATTR_CT_LABELS)) {\r\nconst struct ovs_key_ct_labels *cl;\r\ncl = nla_data(a[OVS_KEY_ATTR_CT_LABELS]);\r\nSW_FLOW_KEY_MEMCPY(match, ct.labels, cl->ct_labels,\r\nsizeof(*cl), is_mask);\r\n*attrs &= ~(1ULL << OVS_KEY_ATTR_CT_LABELS);\r\n}\r\nreturn 0;\r\n}\r\nstatic int ovs_key_from_nlattrs(struct net *net, struct sw_flow_match *match,\r\nu64 attrs, const struct nlattr **a,\r\nbool is_mask, bool log)\r\n{\r\nint err;\r\nerr = metadata_from_nlattrs(net, match, &attrs, a, is_mask, log);\r\nif (err)\r\nreturn err;\r\nif (attrs & (1 << OVS_KEY_ATTR_ETHERNET)) {\r\nconst struct ovs_key_ethernet *eth_key;\r\neth_key = nla_data(a[OVS_KEY_ATTR_ETHERNET]);\r\nSW_FLOW_KEY_MEMCPY(match, eth.src,\r\neth_key->eth_src, ETH_ALEN, is_mask);\r\nSW_FLOW_KEY_MEMCPY(match, eth.dst,\r\neth_key->eth_dst, ETH_ALEN, is_mask);\r\nattrs &= ~(1 << OVS_KEY_ATTR_ETHERNET);\r\n}\r\nif (attrs & (1 << OVS_KEY_ATTR_VLAN)) {\r\n__be16 tci;\r\ntci = nla_get_be16(a[OVS_KEY_ATTR_VLAN]);\r\nif (!(tci & htons(VLAN_TAG_PRESENT))) {\r\nif (is_mask)\r\nOVS_NLERR(log, "VLAN TCI mask does not have exact match for VLAN_TAG_PRESENT bit.");\r\nelse\r\nOVS_NLERR(log, "VLAN TCI does not have VLAN_TAG_PRESENT bit set.");\r\nreturn -EINVAL;\r\n}\r\nSW_FLOW_KEY_PUT(match, eth.tci, tci, is_mask);\r\nattrs &= ~(1 << OVS_KEY_ATTR_VLAN);\r\n}\r\nif (attrs & (1 << OVS_KEY_ATTR_ETHERTYPE)) {\r\n__be16 eth_type;\r\neth_type = nla_get_be16(a[OVS_KEY_ATTR_ETHERTYPE]);\r\nif (is_mask) {\r\neth_type = htons(0xffff);\r\n} else if (!eth_proto_is_802_3(eth_type)) {\r\nOVS_NLERR(log, "EtherType %x is less than min %x",\r\nntohs(eth_type), ETH_P_802_3_MIN);\r\nreturn -EINVAL;\r\n}\r\nSW_FLOW_KEY_PUT(match, eth.type, eth_type, is_mask);\r\nattrs &= ~(1 << OVS_KEY_ATTR_ETHERTYPE);\r\n} else if (!is_mask) {\r\nSW_FLOW_KEY_PUT(match, eth.type, htons(ETH_P_802_2), is_mask);\r\n}\r\nif (attrs & (1 << OVS_KEY_ATTR_IPV4)) {\r\nconst struct ovs_key_ipv4 *ipv4_key;\r\nipv4_key = nla_data(a[OVS_KEY_ATTR_IPV4]);\r\nif (!is_mask && ipv4_key->ipv4_frag > OVS_FRAG_TYPE_MAX) {\r\nOVS_NLERR(log, "IPv4 frag type %d is out of range max %d",\r\nipv4_key->ipv4_frag, OVS_FRAG_TYPE_MAX);\r\nreturn -EINVAL;\r\n}\r\nSW_FLOW_KEY_PUT(match, ip.proto,\r\nipv4_key->ipv4_proto, is_mask);\r\nSW_FLOW_KEY_PUT(match, ip.tos,\r\nipv4_key->ipv4_tos, is_mask);\r\nSW_FLOW_KEY_PUT(match, ip.ttl,\r\nipv4_key->ipv4_ttl, is_mask);\r\nSW_FLOW_KEY_PUT(match, ip.frag,\r\nipv4_key->ipv4_frag, is_mask);\r\nSW_FLOW_KEY_PUT(match, ipv4.addr.src,\r\nipv4_key->ipv4_src, is_mask);\r\nSW_FLOW_KEY_PUT(match, ipv4.addr.dst,\r\nipv4_key->ipv4_dst, is_mask);\r\nattrs &= ~(1 << OVS_KEY_ATTR_IPV4);\r\n}\r\nif (attrs & (1 << OVS_KEY_ATTR_IPV6)) {\r\nconst struct ovs_key_ipv6 *ipv6_key;\r\nipv6_key = nla_data(a[OVS_KEY_ATTR_IPV6]);\r\nif (!is_mask && ipv6_key->ipv6_frag > OVS_FRAG_TYPE_MAX) {\r\nOVS_NLERR(log, "IPv6 frag type %d is out of range max %d",\r\nipv6_key->ipv6_frag, OVS_FRAG_TYPE_MAX);\r\nreturn -EINVAL;\r\n}\r\nif (!is_mask && ipv6_key->ipv6_label & htonl(0xFFF00000)) {\r\nOVS_NLERR(log, "IPv6 flow label %x is out of range (max=%x).\n",\r\nntohl(ipv6_key->ipv6_label), (1 << 20) - 1);\r\nreturn -EINVAL;\r\n}\r\nSW_FLOW_KEY_PUT(match, ipv6.label,\r\nipv6_key->ipv6_label, is_mask);\r\nSW_FLOW_KEY_PUT(match, ip.proto,\r\nipv6_key->ipv6_proto, is_mask);\r\nSW_FLOW_KEY_PUT(match, ip.tos,\r\nipv6_key->ipv6_tclass, is_mask);\r\nSW_FLOW_KEY_PUT(match, ip.ttl,\r\nipv6_key->ipv6_hlimit, is_mask);\r\nSW_FLOW_KEY_PUT(match, ip.frag,\r\nipv6_key->ipv6_frag, is_mask);\r\nSW_FLOW_KEY_MEMCPY(match, ipv6.addr.src,\r\nipv6_key->ipv6_src,\r\nsizeof(match->key->ipv6.addr.src),\r\nis_mask);\r\nSW_FLOW_KEY_MEMCPY(match, ipv6.addr.dst,\r\nipv6_key->ipv6_dst,\r\nsizeof(match->key->ipv6.addr.dst),\r\nis_mask);\r\nattrs &= ~(1 << OVS_KEY_ATTR_IPV6);\r\n}\r\nif (attrs & (1 << OVS_KEY_ATTR_ARP)) {\r\nconst struct ovs_key_arp *arp_key;\r\narp_key = nla_data(a[OVS_KEY_ATTR_ARP]);\r\nif (!is_mask && (arp_key->arp_op & htons(0xff00))) {\r\nOVS_NLERR(log, "Unknown ARP opcode (opcode=%d).",\r\narp_key->arp_op);\r\nreturn -EINVAL;\r\n}\r\nSW_FLOW_KEY_PUT(match, ipv4.addr.src,\r\narp_key->arp_sip, is_mask);\r\nSW_FLOW_KEY_PUT(match, ipv4.addr.dst,\r\narp_key->arp_tip, is_mask);\r\nSW_FLOW_KEY_PUT(match, ip.proto,\r\nntohs(arp_key->arp_op), is_mask);\r\nSW_FLOW_KEY_MEMCPY(match, ipv4.arp.sha,\r\narp_key->arp_sha, ETH_ALEN, is_mask);\r\nSW_FLOW_KEY_MEMCPY(match, ipv4.arp.tha,\r\narp_key->arp_tha, ETH_ALEN, is_mask);\r\nattrs &= ~(1 << OVS_KEY_ATTR_ARP);\r\n}\r\nif (attrs & (1 << OVS_KEY_ATTR_MPLS)) {\r\nconst struct ovs_key_mpls *mpls_key;\r\nmpls_key = nla_data(a[OVS_KEY_ATTR_MPLS]);\r\nSW_FLOW_KEY_PUT(match, mpls.top_lse,\r\nmpls_key->mpls_lse, is_mask);\r\nattrs &= ~(1 << OVS_KEY_ATTR_MPLS);\r\n}\r\nif (attrs & (1 << OVS_KEY_ATTR_TCP)) {\r\nconst struct ovs_key_tcp *tcp_key;\r\ntcp_key = nla_data(a[OVS_KEY_ATTR_TCP]);\r\nSW_FLOW_KEY_PUT(match, tp.src, tcp_key->tcp_src, is_mask);\r\nSW_FLOW_KEY_PUT(match, tp.dst, tcp_key->tcp_dst, is_mask);\r\nattrs &= ~(1 << OVS_KEY_ATTR_TCP);\r\n}\r\nif (attrs & (1 << OVS_KEY_ATTR_TCP_FLAGS)) {\r\nSW_FLOW_KEY_PUT(match, tp.flags,\r\nnla_get_be16(a[OVS_KEY_ATTR_TCP_FLAGS]),\r\nis_mask);\r\nattrs &= ~(1 << OVS_KEY_ATTR_TCP_FLAGS);\r\n}\r\nif (attrs & (1 << OVS_KEY_ATTR_UDP)) {\r\nconst struct ovs_key_udp *udp_key;\r\nudp_key = nla_data(a[OVS_KEY_ATTR_UDP]);\r\nSW_FLOW_KEY_PUT(match, tp.src, udp_key->udp_src, is_mask);\r\nSW_FLOW_KEY_PUT(match, tp.dst, udp_key->udp_dst, is_mask);\r\nattrs &= ~(1 << OVS_KEY_ATTR_UDP);\r\n}\r\nif (attrs & (1 << OVS_KEY_ATTR_SCTP)) {\r\nconst struct ovs_key_sctp *sctp_key;\r\nsctp_key = nla_data(a[OVS_KEY_ATTR_SCTP]);\r\nSW_FLOW_KEY_PUT(match, tp.src, sctp_key->sctp_src, is_mask);\r\nSW_FLOW_KEY_PUT(match, tp.dst, sctp_key->sctp_dst, is_mask);\r\nattrs &= ~(1 << OVS_KEY_ATTR_SCTP);\r\n}\r\nif (attrs & (1 << OVS_KEY_ATTR_ICMP)) {\r\nconst struct ovs_key_icmp *icmp_key;\r\nicmp_key = nla_data(a[OVS_KEY_ATTR_ICMP]);\r\nSW_FLOW_KEY_PUT(match, tp.src,\r\nhtons(icmp_key->icmp_type), is_mask);\r\nSW_FLOW_KEY_PUT(match, tp.dst,\r\nhtons(icmp_key->icmp_code), is_mask);\r\nattrs &= ~(1 << OVS_KEY_ATTR_ICMP);\r\n}\r\nif (attrs & (1 << OVS_KEY_ATTR_ICMPV6)) {\r\nconst struct ovs_key_icmpv6 *icmpv6_key;\r\nicmpv6_key = nla_data(a[OVS_KEY_ATTR_ICMPV6]);\r\nSW_FLOW_KEY_PUT(match, tp.src,\r\nhtons(icmpv6_key->icmpv6_type), is_mask);\r\nSW_FLOW_KEY_PUT(match, tp.dst,\r\nhtons(icmpv6_key->icmpv6_code), is_mask);\r\nattrs &= ~(1 << OVS_KEY_ATTR_ICMPV6);\r\n}\r\nif (attrs & (1 << OVS_KEY_ATTR_ND)) {\r\nconst struct ovs_key_nd *nd_key;\r\nnd_key = nla_data(a[OVS_KEY_ATTR_ND]);\r\nSW_FLOW_KEY_MEMCPY(match, ipv6.nd.target,\r\nnd_key->nd_target,\r\nsizeof(match->key->ipv6.nd.target),\r\nis_mask);\r\nSW_FLOW_KEY_MEMCPY(match, ipv6.nd.sll,\r\nnd_key->nd_sll, ETH_ALEN, is_mask);\r\nSW_FLOW_KEY_MEMCPY(match, ipv6.nd.tll,\r\nnd_key->nd_tll, ETH_ALEN, is_mask);\r\nattrs &= ~(1 << OVS_KEY_ATTR_ND);\r\n}\r\nif (attrs != 0) {\r\nOVS_NLERR(log, "Unknown key attributes %llx",\r\n(unsigned long long)attrs);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic void nlattr_set(struct nlattr *attr, u8 val,\r\nconst struct ovs_len_tbl *tbl)\r\n{\r\nstruct nlattr *nla;\r\nint rem;\r\nnla_for_each_nested(nla, attr, rem) {\r\nif (tbl[nla_type(nla)].len == OVS_ATTR_NESTED) {\r\nif (tbl[nla_type(nla)].next)\r\ntbl = tbl[nla_type(nla)].next;\r\nnlattr_set(nla, val, tbl);\r\n} else {\r\nmemset(nla_data(nla), val, nla_len(nla));\r\n}\r\nif (nla_type(nla) == OVS_KEY_ATTR_CT_STATE)\r\n*(u32 *)nla_data(nla) &= CT_SUPPORTED_MASK;\r\n}\r\n}\r\nstatic void mask_set_nlattr(struct nlattr *attr, u8 val)\r\n{\r\nnlattr_set(attr, val, ovs_key_lens);\r\n}\r\nint ovs_nla_get_match(struct net *net, struct sw_flow_match *match,\r\nconst struct nlattr *nla_key,\r\nconst struct nlattr *nla_mask,\r\nbool log)\r\n{\r\nconst struct nlattr *a[OVS_KEY_ATTR_MAX + 1];\r\nconst struct nlattr *encap;\r\nstruct nlattr *newmask = NULL;\r\nu64 key_attrs = 0;\r\nu64 mask_attrs = 0;\r\nbool encap_valid = false;\r\nint err;\r\nerr = parse_flow_nlattrs(nla_key, a, &key_attrs, log);\r\nif (err)\r\nreturn err;\r\nif ((key_attrs & (1 << OVS_KEY_ATTR_ETHERNET)) &&\r\n(key_attrs & (1 << OVS_KEY_ATTR_ETHERTYPE)) &&\r\n(nla_get_be16(a[OVS_KEY_ATTR_ETHERTYPE]) == htons(ETH_P_8021Q))) {\r\n__be16 tci;\r\nif (!((key_attrs & (1 << OVS_KEY_ATTR_VLAN)) &&\r\n(key_attrs & (1 << OVS_KEY_ATTR_ENCAP)))) {\r\nOVS_NLERR(log, "Invalid Vlan frame.");\r\nreturn -EINVAL;\r\n}\r\nkey_attrs &= ~(1 << OVS_KEY_ATTR_ETHERTYPE);\r\ntci = nla_get_be16(a[OVS_KEY_ATTR_VLAN]);\r\nencap = a[OVS_KEY_ATTR_ENCAP];\r\nkey_attrs &= ~(1 << OVS_KEY_ATTR_ENCAP);\r\nencap_valid = true;\r\nif (tci & htons(VLAN_TAG_PRESENT)) {\r\nerr = parse_flow_nlattrs(encap, a, &key_attrs, log);\r\nif (err)\r\nreturn err;\r\n} else if (!tci) {\r\nif (nla_len(encap)) {\r\nOVS_NLERR(log, "Truncated 802.1Q header has non-zero encap attribute.");\r\nreturn -EINVAL;\r\n}\r\n} else {\r\nOVS_NLERR(log, "Encap attr is set for non-VLAN frame");\r\nreturn -EINVAL;\r\n}\r\n}\r\nerr = ovs_key_from_nlattrs(net, match, key_attrs, a, false, log);\r\nif (err)\r\nreturn err;\r\nif (match->mask) {\r\nif (!nla_mask) {\r\nnewmask = kmemdup(nla_key,\r\nnla_total_size(nla_len(nla_key)),\r\nGFP_KERNEL);\r\nif (!newmask)\r\nreturn -ENOMEM;\r\nmask_set_nlattr(newmask, 0xff);\r\nif (match->key->tun_proto)\r\nSW_FLOW_KEY_MEMSET_FIELD(match, tun_key,\r\n0xff, true);\r\nnla_mask = newmask;\r\n}\r\nerr = parse_flow_mask_nlattrs(nla_mask, a, &mask_attrs, log);\r\nif (err)\r\ngoto free_newmask;\r\nSW_FLOW_KEY_PUT(match, eth.tci, htons(0xffff), true);\r\nif (mask_attrs & 1 << OVS_KEY_ATTR_ENCAP) {\r\n__be16 eth_type = 0;\r\n__be16 tci = 0;\r\nif (!encap_valid) {\r\nOVS_NLERR(log, "Encap mask attribute is set for non-VLAN frame.");\r\nerr = -EINVAL;\r\ngoto free_newmask;\r\n}\r\nmask_attrs &= ~(1 << OVS_KEY_ATTR_ENCAP);\r\nif (a[OVS_KEY_ATTR_ETHERTYPE])\r\neth_type = nla_get_be16(a[OVS_KEY_ATTR_ETHERTYPE]);\r\nif (eth_type == htons(0xffff)) {\r\nmask_attrs &= ~(1 << OVS_KEY_ATTR_ETHERTYPE);\r\nencap = a[OVS_KEY_ATTR_ENCAP];\r\nerr = parse_flow_mask_nlattrs(encap, a,\r\n&mask_attrs, log);\r\nif (err)\r\ngoto free_newmask;\r\n} else {\r\nOVS_NLERR(log, "VLAN frames must have an exact match on the TPID (mask=%x).",\r\nntohs(eth_type));\r\nerr = -EINVAL;\r\ngoto free_newmask;\r\n}\r\nif (a[OVS_KEY_ATTR_VLAN])\r\ntci = nla_get_be16(a[OVS_KEY_ATTR_VLAN]);\r\nif (!(tci & htons(VLAN_TAG_PRESENT))) {\r\nOVS_NLERR(log, "VLAN tag present bit must have an exact match (tci_mask=%x).",\r\nntohs(tci));\r\nerr = -EINVAL;\r\ngoto free_newmask;\r\n}\r\n}\r\nerr = ovs_key_from_nlattrs(net, match, mask_attrs, a, true,\r\nlog);\r\nif (err)\r\ngoto free_newmask;\r\n}\r\nif (!match_validate(match, key_attrs, mask_attrs, log))\r\nerr = -EINVAL;\r\nfree_newmask:\r\nkfree(newmask);\r\nreturn err;\r\n}\r\nstatic size_t get_ufid_len(const struct nlattr *attr, bool log)\r\n{\r\nsize_t len;\r\nif (!attr)\r\nreturn 0;\r\nlen = nla_len(attr);\r\nif (len < 1 || len > MAX_UFID_LENGTH) {\r\nOVS_NLERR(log, "ufid size %u bytes exceeds the range (1, %d)",\r\nnla_len(attr), MAX_UFID_LENGTH);\r\nreturn 0;\r\n}\r\nreturn len;\r\n}\r\nbool ovs_nla_get_ufid(struct sw_flow_id *sfid, const struct nlattr *attr,\r\nbool log)\r\n{\r\nsfid->ufid_len = get_ufid_len(attr, log);\r\nif (sfid->ufid_len)\r\nmemcpy(sfid->ufid, nla_data(attr), sfid->ufid_len);\r\nreturn sfid->ufid_len;\r\n}\r\nint ovs_nla_get_identifier(struct sw_flow_id *sfid, const struct nlattr *ufid,\r\nconst struct sw_flow_key *key, bool log)\r\n{\r\nstruct sw_flow_key *new_key;\r\nif (ovs_nla_get_ufid(sfid, ufid, log))\r\nreturn 0;\r\nnew_key = kmalloc(sizeof(*new_key), GFP_KERNEL);\r\nif (!new_key)\r\nreturn -ENOMEM;\r\nmemcpy(new_key, key, sizeof(*key));\r\nsfid->unmasked_key = new_key;\r\nreturn 0;\r\n}\r\nu32 ovs_nla_get_ufid_flags(const struct nlattr *attr)\r\n{\r\nreturn attr ? nla_get_u32(attr) : 0;\r\n}\r\nint ovs_nla_get_flow_metadata(struct net *net, const struct nlattr *attr,\r\nstruct sw_flow_key *key,\r\nbool log)\r\n{\r\nconst struct nlattr *a[OVS_KEY_ATTR_MAX + 1];\r\nstruct sw_flow_match match;\r\nu64 attrs = 0;\r\nint err;\r\nerr = parse_flow_nlattrs(attr, a, &attrs, log);\r\nif (err)\r\nreturn -EINVAL;\r\nmemset(&match, 0, sizeof(match));\r\nmatch.key = key;\r\nmemset(&key->ct, 0, sizeof(key->ct));\r\nkey->phy.in_port = DP_MAX_PORTS;\r\nreturn metadata_from_nlattrs(net, &match, &attrs, a, false, log);\r\n}\r\nstatic int __ovs_nla_put_key(const struct sw_flow_key *swkey,\r\nconst struct sw_flow_key *output, bool is_mask,\r\nstruct sk_buff *skb)\r\n{\r\nstruct ovs_key_ethernet *eth_key;\r\nstruct nlattr *nla, *encap;\r\nif (nla_put_u32(skb, OVS_KEY_ATTR_RECIRC_ID, output->recirc_id))\r\ngoto nla_put_failure;\r\nif (nla_put_u32(skb, OVS_KEY_ATTR_DP_HASH, output->ovs_flow_hash))\r\ngoto nla_put_failure;\r\nif (nla_put_u32(skb, OVS_KEY_ATTR_PRIORITY, output->phy.priority))\r\ngoto nla_put_failure;\r\nif ((swkey->tun_proto || is_mask)) {\r\nconst void *opts = NULL;\r\nif (output->tun_key.tun_flags & TUNNEL_OPTIONS_PRESENT)\r\nopts = TUN_METADATA_OPTS(output, swkey->tun_opts_len);\r\nif (ip_tun_to_nlattr(skb, &output->tun_key, opts,\r\nswkey->tun_opts_len, swkey->tun_proto))\r\ngoto nla_put_failure;\r\n}\r\nif (swkey->phy.in_port == DP_MAX_PORTS) {\r\nif (is_mask && (output->phy.in_port == 0xffff))\r\nif (nla_put_u32(skb, OVS_KEY_ATTR_IN_PORT, 0xffffffff))\r\ngoto nla_put_failure;\r\n} else {\r\nu16 upper_u16;\r\nupper_u16 = !is_mask ? 0 : 0xffff;\r\nif (nla_put_u32(skb, OVS_KEY_ATTR_IN_PORT,\r\n(upper_u16 << 16) | output->phy.in_port))\r\ngoto nla_put_failure;\r\n}\r\nif (nla_put_u32(skb, OVS_KEY_ATTR_SKB_MARK, output->phy.skb_mark))\r\ngoto nla_put_failure;\r\nif (ovs_ct_put_key(output, skb))\r\ngoto nla_put_failure;\r\nnla = nla_reserve(skb, OVS_KEY_ATTR_ETHERNET, sizeof(*eth_key));\r\nif (!nla)\r\ngoto nla_put_failure;\r\neth_key = nla_data(nla);\r\nether_addr_copy(eth_key->eth_src, output->eth.src);\r\nether_addr_copy(eth_key->eth_dst, output->eth.dst);\r\nif (swkey->eth.tci || swkey->eth.type == htons(ETH_P_8021Q)) {\r\n__be16 eth_type;\r\neth_type = !is_mask ? htons(ETH_P_8021Q) : htons(0xffff);\r\nif (nla_put_be16(skb, OVS_KEY_ATTR_ETHERTYPE, eth_type) ||\r\nnla_put_be16(skb, OVS_KEY_ATTR_VLAN, output->eth.tci))\r\ngoto nla_put_failure;\r\nencap = nla_nest_start(skb, OVS_KEY_ATTR_ENCAP);\r\nif (!swkey->eth.tci)\r\ngoto unencap;\r\n} else\r\nencap = NULL;\r\nif (swkey->eth.type == htons(ETH_P_802_2)) {\r\nif (is_mask && output->eth.type)\r\nif (nla_put_be16(skb, OVS_KEY_ATTR_ETHERTYPE,\r\noutput->eth.type))\r\ngoto nla_put_failure;\r\ngoto unencap;\r\n}\r\nif (nla_put_be16(skb, OVS_KEY_ATTR_ETHERTYPE, output->eth.type))\r\ngoto nla_put_failure;\r\nif (swkey->eth.type == htons(ETH_P_IP)) {\r\nstruct ovs_key_ipv4 *ipv4_key;\r\nnla = nla_reserve(skb, OVS_KEY_ATTR_IPV4, sizeof(*ipv4_key));\r\nif (!nla)\r\ngoto nla_put_failure;\r\nipv4_key = nla_data(nla);\r\nipv4_key->ipv4_src = output->ipv4.addr.src;\r\nipv4_key->ipv4_dst = output->ipv4.addr.dst;\r\nipv4_key->ipv4_proto = output->ip.proto;\r\nipv4_key->ipv4_tos = output->ip.tos;\r\nipv4_key->ipv4_ttl = output->ip.ttl;\r\nipv4_key->ipv4_frag = output->ip.frag;\r\n} else if (swkey->eth.type == htons(ETH_P_IPV6)) {\r\nstruct ovs_key_ipv6 *ipv6_key;\r\nnla = nla_reserve(skb, OVS_KEY_ATTR_IPV6, sizeof(*ipv6_key));\r\nif (!nla)\r\ngoto nla_put_failure;\r\nipv6_key = nla_data(nla);\r\nmemcpy(ipv6_key->ipv6_src, &output->ipv6.addr.src,\r\nsizeof(ipv6_key->ipv6_src));\r\nmemcpy(ipv6_key->ipv6_dst, &output->ipv6.addr.dst,\r\nsizeof(ipv6_key->ipv6_dst));\r\nipv6_key->ipv6_label = output->ipv6.label;\r\nipv6_key->ipv6_proto = output->ip.proto;\r\nipv6_key->ipv6_tclass = output->ip.tos;\r\nipv6_key->ipv6_hlimit = output->ip.ttl;\r\nipv6_key->ipv6_frag = output->ip.frag;\r\n} else if (swkey->eth.type == htons(ETH_P_ARP) ||\r\nswkey->eth.type == htons(ETH_P_RARP)) {\r\nstruct ovs_key_arp *arp_key;\r\nnla = nla_reserve(skb, OVS_KEY_ATTR_ARP, sizeof(*arp_key));\r\nif (!nla)\r\ngoto nla_put_failure;\r\narp_key = nla_data(nla);\r\nmemset(arp_key, 0, sizeof(struct ovs_key_arp));\r\narp_key->arp_sip = output->ipv4.addr.src;\r\narp_key->arp_tip = output->ipv4.addr.dst;\r\narp_key->arp_op = htons(output->ip.proto);\r\nether_addr_copy(arp_key->arp_sha, output->ipv4.arp.sha);\r\nether_addr_copy(arp_key->arp_tha, output->ipv4.arp.tha);\r\n} else if (eth_p_mpls(swkey->eth.type)) {\r\nstruct ovs_key_mpls *mpls_key;\r\nnla = nla_reserve(skb, OVS_KEY_ATTR_MPLS, sizeof(*mpls_key));\r\nif (!nla)\r\ngoto nla_put_failure;\r\nmpls_key = nla_data(nla);\r\nmpls_key->mpls_lse = output->mpls.top_lse;\r\n}\r\nif ((swkey->eth.type == htons(ETH_P_IP) ||\r\nswkey->eth.type == htons(ETH_P_IPV6)) &&\r\nswkey->ip.frag != OVS_FRAG_TYPE_LATER) {\r\nif (swkey->ip.proto == IPPROTO_TCP) {\r\nstruct ovs_key_tcp *tcp_key;\r\nnla = nla_reserve(skb, OVS_KEY_ATTR_TCP, sizeof(*tcp_key));\r\nif (!nla)\r\ngoto nla_put_failure;\r\ntcp_key = nla_data(nla);\r\ntcp_key->tcp_src = output->tp.src;\r\ntcp_key->tcp_dst = output->tp.dst;\r\nif (nla_put_be16(skb, OVS_KEY_ATTR_TCP_FLAGS,\r\noutput->tp.flags))\r\ngoto nla_put_failure;\r\n} else if (swkey->ip.proto == IPPROTO_UDP) {\r\nstruct ovs_key_udp *udp_key;\r\nnla = nla_reserve(skb, OVS_KEY_ATTR_UDP, sizeof(*udp_key));\r\nif (!nla)\r\ngoto nla_put_failure;\r\nudp_key = nla_data(nla);\r\nudp_key->udp_src = output->tp.src;\r\nudp_key->udp_dst = output->tp.dst;\r\n} else if (swkey->ip.proto == IPPROTO_SCTP) {\r\nstruct ovs_key_sctp *sctp_key;\r\nnla = nla_reserve(skb, OVS_KEY_ATTR_SCTP, sizeof(*sctp_key));\r\nif (!nla)\r\ngoto nla_put_failure;\r\nsctp_key = nla_data(nla);\r\nsctp_key->sctp_src = output->tp.src;\r\nsctp_key->sctp_dst = output->tp.dst;\r\n} else if (swkey->eth.type == htons(ETH_P_IP) &&\r\nswkey->ip.proto == IPPROTO_ICMP) {\r\nstruct ovs_key_icmp *icmp_key;\r\nnla = nla_reserve(skb, OVS_KEY_ATTR_ICMP, sizeof(*icmp_key));\r\nif (!nla)\r\ngoto nla_put_failure;\r\nicmp_key = nla_data(nla);\r\nicmp_key->icmp_type = ntohs(output->tp.src);\r\nicmp_key->icmp_code = ntohs(output->tp.dst);\r\n} else if (swkey->eth.type == htons(ETH_P_IPV6) &&\r\nswkey->ip.proto == IPPROTO_ICMPV6) {\r\nstruct ovs_key_icmpv6 *icmpv6_key;\r\nnla = nla_reserve(skb, OVS_KEY_ATTR_ICMPV6,\r\nsizeof(*icmpv6_key));\r\nif (!nla)\r\ngoto nla_put_failure;\r\nicmpv6_key = nla_data(nla);\r\nicmpv6_key->icmpv6_type = ntohs(output->tp.src);\r\nicmpv6_key->icmpv6_code = ntohs(output->tp.dst);\r\nif (icmpv6_key->icmpv6_type == NDISC_NEIGHBOUR_SOLICITATION ||\r\nicmpv6_key->icmpv6_type == NDISC_NEIGHBOUR_ADVERTISEMENT) {\r\nstruct ovs_key_nd *nd_key;\r\nnla = nla_reserve(skb, OVS_KEY_ATTR_ND, sizeof(*nd_key));\r\nif (!nla)\r\ngoto nla_put_failure;\r\nnd_key = nla_data(nla);\r\nmemcpy(nd_key->nd_target, &output->ipv6.nd.target,\r\nsizeof(nd_key->nd_target));\r\nether_addr_copy(nd_key->nd_sll, output->ipv6.nd.sll);\r\nether_addr_copy(nd_key->nd_tll, output->ipv6.nd.tll);\r\n}\r\n}\r\n}\r\nunencap:\r\nif (encap)\r\nnla_nest_end(skb, encap);\r\nreturn 0;\r\nnla_put_failure:\r\nreturn -EMSGSIZE;\r\n}\r\nint ovs_nla_put_key(const struct sw_flow_key *swkey,\r\nconst struct sw_flow_key *output, int attr, bool is_mask,\r\nstruct sk_buff *skb)\r\n{\r\nint err;\r\nstruct nlattr *nla;\r\nnla = nla_nest_start(skb, attr);\r\nif (!nla)\r\nreturn -EMSGSIZE;\r\nerr = __ovs_nla_put_key(swkey, output, is_mask, skb);\r\nif (err)\r\nreturn err;\r\nnla_nest_end(skb, nla);\r\nreturn 0;\r\n}\r\nint ovs_nla_put_identifier(const struct sw_flow *flow, struct sk_buff *skb)\r\n{\r\nif (ovs_identifier_is_ufid(&flow->id))\r\nreturn nla_put(skb, OVS_FLOW_ATTR_UFID, flow->id.ufid_len,\r\nflow->id.ufid);\r\nreturn ovs_nla_put_key(flow->id.unmasked_key, flow->id.unmasked_key,\r\nOVS_FLOW_ATTR_KEY, false, skb);\r\n}\r\nint ovs_nla_put_masked_key(const struct sw_flow *flow, struct sk_buff *skb)\r\n{\r\nreturn ovs_nla_put_key(&flow->key, &flow->key,\r\nOVS_FLOW_ATTR_KEY, false, skb);\r\n}\r\nint ovs_nla_put_mask(const struct sw_flow *flow, struct sk_buff *skb)\r\n{\r\nreturn ovs_nla_put_key(&flow->key, &flow->mask->key,\r\nOVS_FLOW_ATTR_MASK, true, skb);\r\n}\r\nstatic struct sw_flow_actions *nla_alloc_flow_actions(int size, bool log)\r\n{\r\nstruct sw_flow_actions *sfa;\r\nif (size > MAX_ACTIONS_BUFSIZE) {\r\nOVS_NLERR(log, "Flow action size %u bytes exceeds max", size);\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nsfa = kmalloc(sizeof(*sfa) + size, GFP_KERNEL);\r\nif (!sfa)\r\nreturn ERR_PTR(-ENOMEM);\r\nsfa->actions_len = 0;\r\nreturn sfa;\r\n}\r\nstatic void ovs_nla_free_set_action(const struct nlattr *a)\r\n{\r\nconst struct nlattr *ovs_key = nla_data(a);\r\nstruct ovs_tunnel_info *ovs_tun;\r\nswitch (nla_type(ovs_key)) {\r\ncase OVS_KEY_ATTR_TUNNEL_INFO:\r\novs_tun = nla_data(ovs_key);\r\ndst_release((struct dst_entry *)ovs_tun->tun_dst);\r\nbreak;\r\n}\r\n}\r\nvoid ovs_nla_free_flow_actions(struct sw_flow_actions *sf_acts)\r\n{\r\nconst struct nlattr *a;\r\nint rem;\r\nif (!sf_acts)\r\nreturn;\r\nnla_for_each_attr(a, sf_acts->actions, sf_acts->actions_len, rem) {\r\nswitch (nla_type(a)) {\r\ncase OVS_ACTION_ATTR_SET:\r\novs_nla_free_set_action(a);\r\nbreak;\r\ncase OVS_ACTION_ATTR_CT:\r\novs_ct_free_action(a);\r\nbreak;\r\n}\r\n}\r\nkfree(sf_acts);\r\n}\r\nstatic void __ovs_nla_free_flow_actions(struct rcu_head *head)\r\n{\r\novs_nla_free_flow_actions(container_of(head, struct sw_flow_actions, rcu));\r\n}\r\nvoid ovs_nla_free_flow_actions_rcu(struct sw_flow_actions *sf_acts)\r\n{\r\ncall_rcu(&sf_acts->rcu, __ovs_nla_free_flow_actions);\r\n}\r\nstatic struct nlattr *reserve_sfa_size(struct sw_flow_actions **sfa,\r\nint attr_len, bool log)\r\n{\r\nstruct sw_flow_actions *acts;\r\nint new_acts_size;\r\nint req_size = NLA_ALIGN(attr_len);\r\nint next_offset = offsetof(struct sw_flow_actions, actions) +\r\n(*sfa)->actions_len;\r\nif (req_size <= (ksize(*sfa) - next_offset))\r\ngoto out;\r\nnew_acts_size = ksize(*sfa) * 2;\r\nif (new_acts_size > MAX_ACTIONS_BUFSIZE) {\r\nif ((MAX_ACTIONS_BUFSIZE - next_offset) < req_size)\r\nreturn ERR_PTR(-EMSGSIZE);\r\nnew_acts_size = MAX_ACTIONS_BUFSIZE;\r\n}\r\nacts = nla_alloc_flow_actions(new_acts_size, log);\r\nif (IS_ERR(acts))\r\nreturn (void *)acts;\r\nmemcpy(acts->actions, (*sfa)->actions, (*sfa)->actions_len);\r\nacts->actions_len = (*sfa)->actions_len;\r\nacts->orig_len = (*sfa)->orig_len;\r\nkfree(*sfa);\r\n*sfa = acts;\r\nout:\r\n(*sfa)->actions_len += req_size;\r\nreturn (struct nlattr *) ((unsigned char *)(*sfa) + next_offset);\r\n}\r\nstatic struct nlattr *__add_action(struct sw_flow_actions **sfa,\r\nint attrtype, void *data, int len, bool log)\r\n{\r\nstruct nlattr *a;\r\na = reserve_sfa_size(sfa, nla_attr_size(len), log);\r\nif (IS_ERR(a))\r\nreturn a;\r\na->nla_type = attrtype;\r\na->nla_len = nla_attr_size(len);\r\nif (data)\r\nmemcpy(nla_data(a), data, len);\r\nmemset((unsigned char *) a + a->nla_len, 0, nla_padlen(len));\r\nreturn a;\r\n}\r\nint ovs_nla_add_action(struct sw_flow_actions **sfa, int attrtype, void *data,\r\nint len, bool log)\r\n{\r\nstruct nlattr *a;\r\na = __add_action(sfa, attrtype, data, len, log);\r\nreturn PTR_ERR_OR_ZERO(a);\r\n}\r\nstatic inline int add_nested_action_start(struct sw_flow_actions **sfa,\r\nint attrtype, bool log)\r\n{\r\nint used = (*sfa)->actions_len;\r\nint err;\r\nerr = ovs_nla_add_action(sfa, attrtype, NULL, 0, log);\r\nif (err)\r\nreturn err;\r\nreturn used;\r\n}\r\nstatic inline void add_nested_action_end(struct sw_flow_actions *sfa,\r\nint st_offset)\r\n{\r\nstruct nlattr *a = (struct nlattr *) ((unsigned char *)sfa->actions +\r\nst_offset);\r\na->nla_len = sfa->actions_len - st_offset;\r\n}\r\nstatic int validate_and_copy_sample(struct net *net, const struct nlattr *attr,\r\nconst struct sw_flow_key *key, int depth,\r\nstruct sw_flow_actions **sfa,\r\n__be16 eth_type, __be16 vlan_tci, bool log)\r\n{\r\nconst struct nlattr *attrs[OVS_SAMPLE_ATTR_MAX + 1];\r\nconst struct nlattr *probability, *actions;\r\nconst struct nlattr *a;\r\nint rem, start, err, st_acts;\r\nmemset(attrs, 0, sizeof(attrs));\r\nnla_for_each_nested(a, attr, rem) {\r\nint type = nla_type(a);\r\nif (!type || type > OVS_SAMPLE_ATTR_MAX || attrs[type])\r\nreturn -EINVAL;\r\nattrs[type] = a;\r\n}\r\nif (rem)\r\nreturn -EINVAL;\r\nprobability = attrs[OVS_SAMPLE_ATTR_PROBABILITY];\r\nif (!probability || nla_len(probability) != sizeof(u32))\r\nreturn -EINVAL;\r\nactions = attrs[OVS_SAMPLE_ATTR_ACTIONS];\r\nif (!actions || (nla_len(actions) && nla_len(actions) < NLA_HDRLEN))\r\nreturn -EINVAL;\r\nstart = add_nested_action_start(sfa, OVS_ACTION_ATTR_SAMPLE, log);\r\nif (start < 0)\r\nreturn start;\r\nerr = ovs_nla_add_action(sfa, OVS_SAMPLE_ATTR_PROBABILITY,\r\nnla_data(probability), sizeof(u32), log);\r\nif (err)\r\nreturn err;\r\nst_acts = add_nested_action_start(sfa, OVS_SAMPLE_ATTR_ACTIONS, log);\r\nif (st_acts < 0)\r\nreturn st_acts;\r\nerr = __ovs_nla_copy_actions(net, actions, key, depth + 1, sfa,\r\neth_type, vlan_tci, log);\r\nif (err)\r\nreturn err;\r\nadd_nested_action_end(*sfa, st_acts);\r\nadd_nested_action_end(*sfa, start);\r\nreturn 0;\r\n}\r\nvoid ovs_match_init(struct sw_flow_match *match,\r\nstruct sw_flow_key *key,\r\nstruct sw_flow_mask *mask)\r\n{\r\nmemset(match, 0, sizeof(*match));\r\nmatch->key = key;\r\nmatch->mask = mask;\r\nmemset(key, 0, sizeof(*key));\r\nif (mask) {\r\nmemset(&mask->key, 0, sizeof(mask->key));\r\nmask->range.start = mask->range.end = 0;\r\n}\r\n}\r\nstatic int validate_geneve_opts(struct sw_flow_key *key)\r\n{\r\nstruct geneve_opt *option;\r\nint opts_len = key->tun_opts_len;\r\nbool crit_opt = false;\r\noption = (struct geneve_opt *)TUN_METADATA_OPTS(key, key->tun_opts_len);\r\nwhile (opts_len > 0) {\r\nint len;\r\nif (opts_len < sizeof(*option))\r\nreturn -EINVAL;\r\nlen = sizeof(*option) + option->length * 4;\r\nif (len > opts_len)\r\nreturn -EINVAL;\r\ncrit_opt |= !!(option->type & GENEVE_CRIT_OPT_TYPE);\r\noption = (struct geneve_opt *)((u8 *)option + len);\r\nopts_len -= len;\r\n};\r\nkey->tun_key.tun_flags |= crit_opt ? TUNNEL_CRIT_OPT : 0;\r\nreturn 0;\r\n}\r\nstatic int validate_and_copy_set_tun(const struct nlattr *attr,\r\nstruct sw_flow_actions **sfa, bool log)\r\n{\r\nstruct sw_flow_match match;\r\nstruct sw_flow_key key;\r\nstruct metadata_dst *tun_dst;\r\nstruct ip_tunnel_info *tun_info;\r\nstruct ovs_tunnel_info *ovs_tun;\r\nstruct nlattr *a;\r\nint err = 0, start, opts_type;\r\novs_match_init(&match, &key, NULL);\r\nopts_type = ip_tun_from_nlattr(nla_data(attr), &match, false, log);\r\nif (opts_type < 0)\r\nreturn opts_type;\r\nif (key.tun_opts_len) {\r\nswitch (opts_type) {\r\ncase OVS_TUNNEL_KEY_ATTR_GENEVE_OPTS:\r\nerr = validate_geneve_opts(&key);\r\nif (err < 0)\r\nreturn err;\r\nbreak;\r\ncase OVS_TUNNEL_KEY_ATTR_VXLAN_OPTS:\r\nbreak;\r\n}\r\n};\r\nstart = add_nested_action_start(sfa, OVS_ACTION_ATTR_SET, log);\r\nif (start < 0)\r\nreturn start;\r\ntun_dst = metadata_dst_alloc(key.tun_opts_len, GFP_KERNEL);\r\nif (!tun_dst)\r\nreturn -ENOMEM;\r\na = __add_action(sfa, OVS_KEY_ATTR_TUNNEL_INFO, NULL,\r\nsizeof(*ovs_tun), log);\r\nif (IS_ERR(a)) {\r\ndst_release((struct dst_entry *)tun_dst);\r\nreturn PTR_ERR(a);\r\n}\r\novs_tun = nla_data(a);\r\novs_tun->tun_dst = tun_dst;\r\ntun_info = &tun_dst->u.tun_info;\r\ntun_info->mode = IP_TUNNEL_INFO_TX;\r\nif (key.tun_proto == AF_INET6)\r\ntun_info->mode |= IP_TUNNEL_INFO_IPV6;\r\ntun_info->key = key.tun_key;\r\nip_tunnel_info_opts_set(tun_info,\r\nTUN_METADATA_OPTS(&key, key.tun_opts_len),\r\nkey.tun_opts_len);\r\nadd_nested_action_end(*sfa, start);\r\nreturn err;\r\n}\r\nstatic bool validate_masked(u8 *data, int len)\r\n{\r\nu8 *mask = data + len;\r\nwhile (len--)\r\nif (*data++ & ~*mask++)\r\nreturn false;\r\nreturn true;\r\n}\r\nstatic int validate_set(const struct nlattr *a,\r\nconst struct sw_flow_key *flow_key,\r\nstruct sw_flow_actions **sfa,\r\nbool *skip_copy, __be16 eth_type, bool masked, bool log)\r\n{\r\nconst struct nlattr *ovs_key = nla_data(a);\r\nint key_type = nla_type(ovs_key);\r\nsize_t key_len;\r\nif (nla_total_size(nla_len(ovs_key)) != nla_len(a))\r\nreturn -EINVAL;\r\nkey_len = nla_len(ovs_key);\r\nif (masked)\r\nkey_len /= 2;\r\nif (key_type > OVS_KEY_ATTR_MAX ||\r\n!check_attr_len(key_len, ovs_key_lens[key_type].len))\r\nreturn -EINVAL;\r\nif (masked && !validate_masked(nla_data(ovs_key), key_len))\r\nreturn -EINVAL;\r\nswitch (key_type) {\r\nconst struct ovs_key_ipv4 *ipv4_key;\r\nconst struct ovs_key_ipv6 *ipv6_key;\r\nint err;\r\ncase OVS_KEY_ATTR_PRIORITY:\r\ncase OVS_KEY_ATTR_SKB_MARK:\r\ncase OVS_KEY_ATTR_CT_MARK:\r\ncase OVS_KEY_ATTR_CT_LABELS:\r\ncase OVS_KEY_ATTR_ETHERNET:\r\nbreak;\r\ncase OVS_KEY_ATTR_TUNNEL:\r\nif (eth_p_mpls(eth_type))\r\nreturn -EINVAL;\r\nif (masked)\r\nreturn -EINVAL;\r\n*skip_copy = true;\r\nerr = validate_and_copy_set_tun(a, sfa, log);\r\nif (err)\r\nreturn err;\r\nbreak;\r\ncase OVS_KEY_ATTR_IPV4:\r\nif (eth_type != htons(ETH_P_IP))\r\nreturn -EINVAL;\r\nipv4_key = nla_data(ovs_key);\r\nif (masked) {\r\nconst struct ovs_key_ipv4 *mask = ipv4_key + 1;\r\nif (mask->ipv4_proto || mask->ipv4_frag)\r\nreturn -EINVAL;\r\n} else {\r\nif (ipv4_key->ipv4_proto != flow_key->ip.proto)\r\nreturn -EINVAL;\r\nif (ipv4_key->ipv4_frag != flow_key->ip.frag)\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ncase OVS_KEY_ATTR_IPV6:\r\nif (eth_type != htons(ETH_P_IPV6))\r\nreturn -EINVAL;\r\nipv6_key = nla_data(ovs_key);\r\nif (masked) {\r\nconst struct ovs_key_ipv6 *mask = ipv6_key + 1;\r\nif (mask->ipv6_proto || mask->ipv6_frag)\r\nreturn -EINVAL;\r\nif (ntohl(mask->ipv6_label) & 0xFFF00000)\r\nreturn -EINVAL;\r\n} else {\r\nif (ipv6_key->ipv6_proto != flow_key->ip.proto)\r\nreturn -EINVAL;\r\nif (ipv6_key->ipv6_frag != flow_key->ip.frag)\r\nreturn -EINVAL;\r\n}\r\nif (ntohl(ipv6_key->ipv6_label) & 0xFFF00000)\r\nreturn -EINVAL;\r\nbreak;\r\ncase OVS_KEY_ATTR_TCP:\r\nif ((eth_type != htons(ETH_P_IP) &&\r\neth_type != htons(ETH_P_IPV6)) ||\r\nflow_key->ip.proto != IPPROTO_TCP)\r\nreturn -EINVAL;\r\nbreak;\r\ncase OVS_KEY_ATTR_UDP:\r\nif ((eth_type != htons(ETH_P_IP) &&\r\neth_type != htons(ETH_P_IPV6)) ||\r\nflow_key->ip.proto != IPPROTO_UDP)\r\nreturn -EINVAL;\r\nbreak;\r\ncase OVS_KEY_ATTR_MPLS:\r\nif (!eth_p_mpls(eth_type))\r\nreturn -EINVAL;\r\nbreak;\r\ncase OVS_KEY_ATTR_SCTP:\r\nif ((eth_type != htons(ETH_P_IP) &&\r\neth_type != htons(ETH_P_IPV6)) ||\r\nflow_key->ip.proto != IPPROTO_SCTP)\r\nreturn -EINVAL;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (!masked && key_type != OVS_KEY_ATTR_TUNNEL) {\r\nint start, len = key_len * 2;\r\nstruct nlattr *at;\r\n*skip_copy = true;\r\nstart = add_nested_action_start(sfa,\r\nOVS_ACTION_ATTR_SET_TO_MASKED,\r\nlog);\r\nif (start < 0)\r\nreturn start;\r\nat = __add_action(sfa, key_type, NULL, len, log);\r\nif (IS_ERR(at))\r\nreturn PTR_ERR(at);\r\nmemcpy(nla_data(at), nla_data(ovs_key), key_len);\r\nmemset(nla_data(at) + key_len, 0xff, key_len);\r\nif (key_type == OVS_KEY_ATTR_IPV6) {\r\nstruct ovs_key_ipv6 *mask = nla_data(at) + key_len;\r\nmask->ipv6_label &= htonl(0x000FFFFF);\r\n}\r\nadd_nested_action_end(*sfa, start);\r\n}\r\nreturn 0;\r\n}\r\nstatic int validate_userspace(const struct nlattr *attr)\r\n{\r\nstatic const struct nla_policy userspace_policy[OVS_USERSPACE_ATTR_MAX + 1] = {\r\n[OVS_USERSPACE_ATTR_PID] = {.type = NLA_U32 },\r\n[OVS_USERSPACE_ATTR_USERDATA] = {.type = NLA_UNSPEC },\r\n[OVS_USERSPACE_ATTR_EGRESS_TUN_PORT] = {.type = NLA_U32 },\r\n};\r\nstruct nlattr *a[OVS_USERSPACE_ATTR_MAX + 1];\r\nint error;\r\nerror = nla_parse_nested(a, OVS_USERSPACE_ATTR_MAX,\r\nattr, userspace_policy);\r\nif (error)\r\nreturn error;\r\nif (!a[OVS_USERSPACE_ATTR_PID] ||\r\n!nla_get_u32(a[OVS_USERSPACE_ATTR_PID]))\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int copy_action(const struct nlattr *from,\r\nstruct sw_flow_actions **sfa, bool log)\r\n{\r\nint totlen = NLA_ALIGN(from->nla_len);\r\nstruct nlattr *to;\r\nto = reserve_sfa_size(sfa, from->nla_len, log);\r\nif (IS_ERR(to))\r\nreturn PTR_ERR(to);\r\nmemcpy(to, from, totlen);\r\nreturn 0;\r\n}\r\nstatic int __ovs_nla_copy_actions(struct net *net, const struct nlattr *attr,\r\nconst struct sw_flow_key *key,\r\nint depth, struct sw_flow_actions **sfa,\r\n__be16 eth_type, __be16 vlan_tci, bool log)\r\n{\r\nconst struct nlattr *a;\r\nint rem, err;\r\nif (depth >= SAMPLE_ACTION_DEPTH)\r\nreturn -EOVERFLOW;\r\nnla_for_each_nested(a, attr, rem) {\r\nstatic const u32 action_lens[OVS_ACTION_ATTR_MAX + 1] = {\r\n[OVS_ACTION_ATTR_OUTPUT] = sizeof(u32),\r\n[OVS_ACTION_ATTR_RECIRC] = sizeof(u32),\r\n[OVS_ACTION_ATTR_USERSPACE] = (u32)-1,\r\n[OVS_ACTION_ATTR_PUSH_MPLS] = sizeof(struct ovs_action_push_mpls),\r\n[OVS_ACTION_ATTR_POP_MPLS] = sizeof(__be16),\r\n[OVS_ACTION_ATTR_PUSH_VLAN] = sizeof(struct ovs_action_push_vlan),\r\n[OVS_ACTION_ATTR_POP_VLAN] = 0,\r\n[OVS_ACTION_ATTR_SET] = (u32)-1,\r\n[OVS_ACTION_ATTR_SET_MASKED] = (u32)-1,\r\n[OVS_ACTION_ATTR_SAMPLE] = (u32)-1,\r\n[OVS_ACTION_ATTR_HASH] = sizeof(struct ovs_action_hash),\r\n[OVS_ACTION_ATTR_CT] = (u32)-1,\r\n};\r\nconst struct ovs_action_push_vlan *vlan;\r\nint type = nla_type(a);\r\nbool skip_copy;\r\nif (type > OVS_ACTION_ATTR_MAX ||\r\n(action_lens[type] != nla_len(a) &&\r\naction_lens[type] != (u32)-1))\r\nreturn -EINVAL;\r\nskip_copy = false;\r\nswitch (type) {\r\ncase OVS_ACTION_ATTR_UNSPEC:\r\nreturn -EINVAL;\r\ncase OVS_ACTION_ATTR_USERSPACE:\r\nerr = validate_userspace(a);\r\nif (err)\r\nreturn err;\r\nbreak;\r\ncase OVS_ACTION_ATTR_OUTPUT:\r\nif (nla_get_u32(a) >= DP_MAX_PORTS)\r\nreturn -EINVAL;\r\nbreak;\r\ncase OVS_ACTION_ATTR_HASH: {\r\nconst struct ovs_action_hash *act_hash = nla_data(a);\r\nswitch (act_hash->hash_alg) {\r\ncase OVS_HASH_ALG_L4:\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\n}\r\ncase OVS_ACTION_ATTR_POP_VLAN:\r\nvlan_tci = htons(0);\r\nbreak;\r\ncase OVS_ACTION_ATTR_PUSH_VLAN:\r\nvlan = nla_data(a);\r\nif (vlan->vlan_tpid != htons(ETH_P_8021Q))\r\nreturn -EINVAL;\r\nif (!(vlan->vlan_tci & htons(VLAN_TAG_PRESENT)))\r\nreturn -EINVAL;\r\nvlan_tci = vlan->vlan_tci;\r\nbreak;\r\ncase OVS_ACTION_ATTR_RECIRC:\r\nbreak;\r\ncase OVS_ACTION_ATTR_PUSH_MPLS: {\r\nconst struct ovs_action_push_mpls *mpls = nla_data(a);\r\nif (!eth_p_mpls(mpls->mpls_ethertype))\r\nreturn -EINVAL;\r\nif (vlan_tci & htons(VLAN_TAG_PRESENT) ||\r\n(eth_type != htons(ETH_P_IP) &&\r\neth_type != htons(ETH_P_IPV6) &&\r\neth_type != htons(ETH_P_ARP) &&\r\neth_type != htons(ETH_P_RARP) &&\r\n!eth_p_mpls(eth_type)))\r\nreturn -EINVAL;\r\neth_type = mpls->mpls_ethertype;\r\nbreak;\r\n}\r\ncase OVS_ACTION_ATTR_POP_MPLS:\r\nif (vlan_tci & htons(VLAN_TAG_PRESENT) ||\r\n!eth_p_mpls(eth_type))\r\nreturn -EINVAL;\r\neth_type = htons(0);\r\nbreak;\r\ncase OVS_ACTION_ATTR_SET:\r\nerr = validate_set(a, key, sfa,\r\n&skip_copy, eth_type, false, log);\r\nif (err)\r\nreturn err;\r\nbreak;\r\ncase OVS_ACTION_ATTR_SET_MASKED:\r\nerr = validate_set(a, key, sfa,\r\n&skip_copy, eth_type, true, log);\r\nif (err)\r\nreturn err;\r\nbreak;\r\ncase OVS_ACTION_ATTR_SAMPLE:\r\nerr = validate_and_copy_sample(net, a, key, depth, sfa,\r\neth_type, vlan_tci, log);\r\nif (err)\r\nreturn err;\r\nskip_copy = true;\r\nbreak;\r\ncase OVS_ACTION_ATTR_CT:\r\nerr = ovs_ct_copy_action(net, a, key, sfa, log);\r\nif (err)\r\nreturn err;\r\nskip_copy = true;\r\nbreak;\r\ndefault:\r\nOVS_NLERR(log, "Unknown Action type %d", type);\r\nreturn -EINVAL;\r\n}\r\nif (!skip_copy) {\r\nerr = copy_action(a, sfa, log);\r\nif (err)\r\nreturn err;\r\n}\r\n}\r\nif (rem > 0)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nint ovs_nla_copy_actions(struct net *net, const struct nlattr *attr,\r\nconst struct sw_flow_key *key,\r\nstruct sw_flow_actions **sfa, bool log)\r\n{\r\nint err;\r\n*sfa = nla_alloc_flow_actions(nla_len(attr), log);\r\nif (IS_ERR(*sfa))\r\nreturn PTR_ERR(*sfa);\r\n(*sfa)->orig_len = nla_len(attr);\r\nerr = __ovs_nla_copy_actions(net, attr, key, 0, sfa, key->eth.type,\r\nkey->eth.tci, log);\r\nif (err)\r\novs_nla_free_flow_actions(*sfa);\r\nreturn err;\r\n}\r\nstatic int sample_action_to_attr(const struct nlattr *attr, struct sk_buff *skb)\r\n{\r\nconst struct nlattr *a;\r\nstruct nlattr *start;\r\nint err = 0, rem;\r\nstart = nla_nest_start(skb, OVS_ACTION_ATTR_SAMPLE);\r\nif (!start)\r\nreturn -EMSGSIZE;\r\nnla_for_each_nested(a, attr, rem) {\r\nint type = nla_type(a);\r\nstruct nlattr *st_sample;\r\nswitch (type) {\r\ncase OVS_SAMPLE_ATTR_PROBABILITY:\r\nif (nla_put(skb, OVS_SAMPLE_ATTR_PROBABILITY,\r\nsizeof(u32), nla_data(a)))\r\nreturn -EMSGSIZE;\r\nbreak;\r\ncase OVS_SAMPLE_ATTR_ACTIONS:\r\nst_sample = nla_nest_start(skb, OVS_SAMPLE_ATTR_ACTIONS);\r\nif (!st_sample)\r\nreturn -EMSGSIZE;\r\nerr = ovs_nla_put_actions(nla_data(a), nla_len(a), skb);\r\nif (err)\r\nreturn err;\r\nnla_nest_end(skb, st_sample);\r\nbreak;\r\n}\r\n}\r\nnla_nest_end(skb, start);\r\nreturn err;\r\n}\r\nstatic int set_action_to_attr(const struct nlattr *a, struct sk_buff *skb)\r\n{\r\nconst struct nlattr *ovs_key = nla_data(a);\r\nint key_type = nla_type(ovs_key);\r\nstruct nlattr *start;\r\nint err;\r\nswitch (key_type) {\r\ncase OVS_KEY_ATTR_TUNNEL_INFO: {\r\nstruct ovs_tunnel_info *ovs_tun = nla_data(ovs_key);\r\nstruct ip_tunnel_info *tun_info = &ovs_tun->tun_dst->u.tun_info;\r\nstart = nla_nest_start(skb, OVS_ACTION_ATTR_SET);\r\nif (!start)\r\nreturn -EMSGSIZE;\r\nerr = ip_tun_to_nlattr(skb, &tun_info->key,\r\nip_tunnel_info_opts(tun_info),\r\ntun_info->options_len,\r\nip_tunnel_info_af(tun_info));\r\nif (err)\r\nreturn err;\r\nnla_nest_end(skb, start);\r\nbreak;\r\n}\r\ndefault:\r\nif (nla_put(skb, OVS_ACTION_ATTR_SET, nla_len(a), ovs_key))\r\nreturn -EMSGSIZE;\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int masked_set_action_to_set_action_attr(const struct nlattr *a,\r\nstruct sk_buff *skb)\r\n{\r\nconst struct nlattr *ovs_key = nla_data(a);\r\nstruct nlattr *nla;\r\nsize_t key_len = nla_len(ovs_key) / 2;\r\nnla = nla_nest_start(skb, OVS_ACTION_ATTR_SET);\r\nif (!nla)\r\nreturn -EMSGSIZE;\r\nif (nla_put(skb, nla_type(ovs_key), key_len, nla_data(ovs_key)))\r\nreturn -EMSGSIZE;\r\nnla_nest_end(skb, nla);\r\nreturn 0;\r\n}\r\nint ovs_nla_put_actions(const struct nlattr *attr, int len, struct sk_buff *skb)\r\n{\r\nconst struct nlattr *a;\r\nint rem, err;\r\nnla_for_each_attr(a, attr, len, rem) {\r\nint type = nla_type(a);\r\nswitch (type) {\r\ncase OVS_ACTION_ATTR_SET:\r\nerr = set_action_to_attr(a, skb);\r\nif (err)\r\nreturn err;\r\nbreak;\r\ncase OVS_ACTION_ATTR_SET_TO_MASKED:\r\nerr = masked_set_action_to_set_action_attr(a, skb);\r\nif (err)\r\nreturn err;\r\nbreak;\r\ncase OVS_ACTION_ATTR_SAMPLE:\r\nerr = sample_action_to_attr(a, skb);\r\nif (err)\r\nreturn err;\r\nbreak;\r\ncase OVS_ACTION_ATTR_CT:\r\nerr = ovs_ct_action_to_attr(nla_data(a), skb);\r\nif (err)\r\nreturn err;\r\nbreak;\r\ndefault:\r\nif (nla_put(skb, type, nla_len(a), nla_data(a)))\r\nreturn -EMSGSIZE;\r\nbreak;\r\n}\r\n}\r\nreturn 0;\r\n}
