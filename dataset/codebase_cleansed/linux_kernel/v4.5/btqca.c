static int rome_patch_ver_req(struct hci_dev *hdev, u32 *rome_version)\r\n{\r\nstruct sk_buff *skb;\r\nstruct edl_event_hdr *edl;\r\nstruct rome_version *ver;\r\nchar cmd;\r\nint err = 0;\r\nBT_DBG("%s: ROME Patch Version Request", hdev->name);\r\ncmd = EDL_PATCH_VER_REQ_CMD;\r\nskb = __hci_cmd_sync_ev(hdev, EDL_PATCH_CMD_OPCODE, EDL_PATCH_CMD_LEN,\r\n&cmd, HCI_VENDOR_PKT, HCI_INIT_TIMEOUT);\r\nif (IS_ERR(skb)) {\r\nerr = PTR_ERR(skb);\r\nBT_ERR("%s: Failed to read version of ROME (%d)", hdev->name,\r\nerr);\r\nreturn err;\r\n}\r\nif (skb->len != sizeof(*edl) + sizeof(*ver)) {\r\nBT_ERR("%s: Version size mismatch len %d", hdev->name,\r\nskb->len);\r\nerr = -EILSEQ;\r\ngoto out;\r\n}\r\nedl = (struct edl_event_hdr *)(skb->data);\r\nif (!edl || !edl->data) {\r\nBT_ERR("%s: TLV with no header or no data", hdev->name);\r\nerr = -EILSEQ;\r\ngoto out;\r\n}\r\nif (edl->cresp != EDL_CMD_REQ_RES_EVT ||\r\nedl->rtype != EDL_APP_VER_RES_EVT) {\r\nBT_ERR("%s: Wrong packet received %d %d", hdev->name,\r\nedl->cresp, edl->rtype);\r\nerr = -EIO;\r\ngoto out;\r\n}\r\nver = (struct rome_version *)(edl->data);\r\nBT_DBG("%s: Product:0x%08x", hdev->name, le32_to_cpu(ver->product_id));\r\nBT_DBG("%s: Patch :0x%08x", hdev->name, le16_to_cpu(ver->patch_ver));\r\nBT_DBG("%s: ROM :0x%08x", hdev->name, le16_to_cpu(ver->rome_ver));\r\nBT_DBG("%s: SOC :0x%08x", hdev->name, le32_to_cpu(ver->soc_id));\r\n*rome_version = (le32_to_cpu(ver->soc_id) << 16) |\r\n(le16_to_cpu(ver->rome_ver) & 0x0000ffff);\r\nout:\r\nkfree_skb(skb);\r\nreturn err;\r\n}\r\nstatic int rome_reset(struct hci_dev *hdev)\r\n{\r\nstruct sk_buff *skb;\r\nint err;\r\nBT_DBG("%s: ROME HCI_RESET", hdev->name);\r\nskb = __hci_cmd_sync(hdev, HCI_OP_RESET, 0, NULL, HCI_INIT_TIMEOUT);\r\nif (IS_ERR(skb)) {\r\nerr = PTR_ERR(skb);\r\nBT_ERR("%s: Reset failed (%d)", hdev->name, err);\r\nreturn err;\r\n}\r\nkfree_skb(skb);\r\nreturn 0;\r\n}\r\nstatic void rome_tlv_check_data(struct rome_config *config,\r\nconst struct firmware *fw)\r\n{\r\nconst u8 *data;\r\nu32 type_len;\r\nu16 tag_id, tag_len;\r\nint idx, length;\r\nstruct tlv_type_hdr *tlv;\r\nstruct tlv_type_patch *tlv_patch;\r\nstruct tlv_type_nvm *tlv_nvm;\r\ntlv = (struct tlv_type_hdr *)fw->data;\r\ntype_len = le32_to_cpu(tlv->type_len);\r\nlength = (type_len >> 8) & 0x00ffffff;\r\nBT_DBG("TLV Type\t\t : 0x%x", type_len & 0x000000ff);\r\nBT_DBG("Length\t\t : %d bytes", length);\r\nswitch (config->type) {\r\ncase TLV_TYPE_PATCH:\r\ntlv_patch = (struct tlv_type_patch *)tlv->data;\r\nBT_DBG("Total Length\t\t : %d bytes",\r\nle32_to_cpu(tlv_patch->total_size));\r\nBT_DBG("Patch Data Length\t : %d bytes",\r\nle32_to_cpu(tlv_patch->data_length));\r\nBT_DBG("Signing Format Version : 0x%x",\r\ntlv_patch->format_version);\r\nBT_DBG("Signature Algorithm\t : 0x%x",\r\ntlv_patch->signature);\r\nBT_DBG("Reserved\t\t : 0x%x",\r\nle16_to_cpu(tlv_patch->reserved1));\r\nBT_DBG("Product ID\t\t : 0x%04x",\r\nle16_to_cpu(tlv_patch->product_id));\r\nBT_DBG("Rom Build Version\t : 0x%04x",\r\nle16_to_cpu(tlv_patch->rom_build));\r\nBT_DBG("Patch Version\t\t : 0x%04x",\r\nle16_to_cpu(tlv_patch->patch_version));\r\nBT_DBG("Reserved\t\t : 0x%x",\r\nle16_to_cpu(tlv_patch->reserved2));\r\nBT_DBG("Patch Entry Address\t : 0x%x",\r\nle32_to_cpu(tlv_patch->entry));\r\nbreak;\r\ncase TLV_TYPE_NVM:\r\nidx = 0;\r\ndata = tlv->data;\r\nwhile (idx < length) {\r\ntlv_nvm = (struct tlv_type_nvm *)(data + idx);\r\ntag_id = le16_to_cpu(tlv_nvm->tag_id);\r\ntag_len = le16_to_cpu(tlv_nvm->tag_len);\r\nswitch (tag_id) {\r\ncase EDL_TAG_ID_HCI:\r\ntlv_nvm->data[0] |= 0x80;\r\ntlv_nvm->data[2] = config->user_baud_rate;\r\nbreak;\r\ncase EDL_TAG_ID_DEEP_SLEEP:\r\ntlv_nvm->data[0] |= 0x01;\r\nbreak;\r\n}\r\nidx += (sizeof(u16) + sizeof(u16) + 8 + tag_len);\r\n}\r\nbreak;\r\ndefault:\r\nBT_ERR("Unknown TLV type %d", config->type);\r\nbreak;\r\n}\r\n}\r\nstatic int rome_tlv_send_segment(struct hci_dev *hdev, int idx, int seg_size,\r\nconst u8 *data)\r\n{\r\nstruct sk_buff *skb;\r\nstruct edl_event_hdr *edl;\r\nstruct tlv_seg_resp *tlv_resp;\r\nu8 cmd[MAX_SIZE_PER_TLV_SEGMENT + 2];\r\nint err = 0;\r\nBT_DBG("%s: Download segment #%d size %d", hdev->name, idx, seg_size);\r\ncmd[0] = EDL_PATCH_TLV_REQ_CMD;\r\ncmd[1] = seg_size;\r\nmemcpy(cmd + 2, data, seg_size);\r\nskb = __hci_cmd_sync_ev(hdev, EDL_PATCH_CMD_OPCODE, seg_size + 2, cmd,\r\nHCI_VENDOR_PKT, HCI_INIT_TIMEOUT);\r\nif (IS_ERR(skb)) {\r\nerr = PTR_ERR(skb);\r\nBT_ERR("%s: Failed to send TLV segment (%d)", hdev->name, err);\r\nreturn err;\r\n}\r\nif (skb->len != sizeof(*edl) + sizeof(*tlv_resp)) {\r\nBT_ERR("%s: TLV response size mismatch", hdev->name);\r\nerr = -EILSEQ;\r\ngoto out;\r\n}\r\nedl = (struct edl_event_hdr *)(skb->data);\r\nif (!edl || !edl->data) {\r\nBT_ERR("%s: TLV with no header or no data", hdev->name);\r\nerr = -EILSEQ;\r\ngoto out;\r\n}\r\ntlv_resp = (struct tlv_seg_resp *)(edl->data);\r\nif (edl->cresp != EDL_CMD_REQ_RES_EVT ||\r\nedl->rtype != EDL_TVL_DNLD_RES_EVT || tlv_resp->result != 0x00) {\r\nBT_ERR("%s: TLV with error stat 0x%x rtype 0x%x (0x%x)",\r\nhdev->name, edl->cresp, edl->rtype, tlv_resp->result);\r\nerr = -EIO;\r\n}\r\nout:\r\nkfree_skb(skb);\r\nreturn err;\r\n}\r\nstatic int rome_tlv_download_request(struct hci_dev *hdev,\r\nconst struct firmware *fw)\r\n{\r\nconst u8 *buffer, *data;\r\nint total_segment, remain_size;\r\nint ret, i;\r\nif (!fw || !fw->data)\r\nreturn -EINVAL;\r\ntotal_segment = fw->size / MAX_SIZE_PER_TLV_SEGMENT;\r\nremain_size = fw->size % MAX_SIZE_PER_TLV_SEGMENT;\r\nBT_DBG("%s: Total segment num %d remain size %d total size %zu",\r\nhdev->name, total_segment, remain_size, fw->size);\r\ndata = fw->data;\r\nfor (i = 0; i < total_segment; i++) {\r\nbuffer = data + i * MAX_SIZE_PER_TLV_SEGMENT;\r\nret = rome_tlv_send_segment(hdev, i, MAX_SIZE_PER_TLV_SEGMENT,\r\nbuffer);\r\nif (ret < 0)\r\nreturn -EIO;\r\n}\r\nif (remain_size) {\r\nbuffer = data + total_segment * MAX_SIZE_PER_TLV_SEGMENT;\r\nret = rome_tlv_send_segment(hdev, total_segment, remain_size,\r\nbuffer);\r\nif (ret < 0)\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic int rome_download_firmware(struct hci_dev *hdev,\r\nstruct rome_config *config)\r\n{\r\nconst struct firmware *fw;\r\nint ret;\r\nBT_INFO("%s: ROME Downloading %s", hdev->name, config->fwname);\r\nret = request_firmware(&fw, config->fwname, &hdev->dev);\r\nif (ret) {\r\nBT_ERR("%s: Failed to request file: %s (%d)", hdev->name,\r\nconfig->fwname, ret);\r\nreturn ret;\r\n}\r\nrome_tlv_check_data(config, fw);\r\nret = rome_tlv_download_request(hdev, fw);\r\nif (ret) {\r\nBT_ERR("%s: Failed to download file: %s (%d)", hdev->name,\r\nconfig->fwname, ret);\r\n}\r\nrelease_firmware(fw);\r\nreturn ret;\r\n}\r\nint qca_set_bdaddr_rome(struct hci_dev *hdev, const bdaddr_t *bdaddr)\r\n{\r\nstruct sk_buff *skb;\r\nu8 cmd[9];\r\nint err;\r\ncmd[0] = EDL_NVM_ACCESS_SET_REQ_CMD;\r\ncmd[1] = 0x02;\r\ncmd[2] = sizeof(bdaddr_t);\r\nmemcpy(cmd + 3, bdaddr, sizeof(bdaddr_t));\r\nskb = __hci_cmd_sync_ev(hdev, EDL_NVM_ACCESS_OPCODE, sizeof(cmd), cmd,\r\nHCI_VENDOR_PKT, HCI_INIT_TIMEOUT);\r\nif (IS_ERR(skb)) {\r\nerr = PTR_ERR(skb);\r\nBT_ERR("%s: Change address command failed (%d)",\r\nhdev->name, err);\r\nreturn err;\r\n}\r\nkfree_skb(skb);\r\nreturn 0;\r\n}\r\nint qca_uart_setup_rome(struct hci_dev *hdev, uint8_t baudrate)\r\n{\r\nu32 rome_ver = 0;\r\nstruct rome_config config;\r\nint err;\r\nBT_DBG("%s: ROME setup on UART", hdev->name);\r\nconfig.user_baud_rate = baudrate;\r\nerr = rome_patch_ver_req(hdev, &rome_ver);\r\nif (err < 0 || rome_ver == 0) {\r\nBT_ERR("%s: Failed to get version 0x%x", hdev->name, err);\r\nreturn err;\r\n}\r\nBT_INFO("%s: ROME controller version 0x%08x", hdev->name, rome_ver);\r\nconfig.type = TLV_TYPE_PATCH;\r\nsnprintf(config.fwname, sizeof(config.fwname), "qca/rampatch_%08x.bin",\r\nrome_ver);\r\nerr = rome_download_firmware(hdev, &config);\r\nif (err < 0) {\r\nBT_ERR("%s: Failed to download patch (%d)", hdev->name, err);\r\nreturn err;\r\n}\r\nconfig.type = TLV_TYPE_NVM;\r\nsnprintf(config.fwname, sizeof(config.fwname), "qca/nvm_%08x.bin",\r\nrome_ver);\r\nerr = rome_download_firmware(hdev, &config);\r\nif (err < 0) {\r\nBT_ERR("%s: Failed to download NVM (%d)", hdev->name, err);\r\nreturn err;\r\n}\r\nerr = rome_reset(hdev);\r\nif (err < 0) {\r\nBT_ERR("%s: Failed to run HCI_RESET (%d)", hdev->name, err);\r\nreturn err;\r\n}\r\nBT_INFO("%s: ROME setup on UART is completed", hdev->name);\r\nreturn 0;\r\n}
