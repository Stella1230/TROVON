static int tsys01_read_temperature(struct iio_dev *indio_dev,\r\ns32 *temperature)\r\n{\r\nint ret, i;\r\nu32 adc;\r\ns64 temp = 0;\r\nstruct tsys01_dev *dev_data = iio_priv(indio_dev);\r\nmutex_lock(&dev_data->lock);\r\nret = dev_data->convert_and_read(dev_data->client,\r\nTSYS01_CONVERSION_START,\r\nTSYS01_ADC_READ, 9000, &adc);\r\nmutex_unlock(&dev_data->lock);\r\nif (ret)\r\nreturn ret;\r\nadc >>= 8;\r\nfor (i = 4; i > 0; i--) {\r\ntemp += coeff_mul[i] *\r\n(s64)dev_data->prom[5 - i];\r\ntemp *= (s64)adc;\r\ntemp = div64_s64(temp, 100000);\r\n}\r\ntemp *= 10;\r\ntemp += coeff_mul[0] * (s64)dev_data->prom[5];\r\ntemp = div64_s64(temp, 100000);\r\n*temperature = temp;\r\nreturn 0;\r\n}\r\nstatic int tsys01_read_raw(struct iio_dev *indio_dev,\r\nstruct iio_chan_spec const *channel, int *val,\r\nint *val2, long mask)\r\n{\r\nint ret;\r\ns32 temperature;\r\nswitch (mask) {\r\ncase IIO_CHAN_INFO_PROCESSED:\r\nswitch (channel->type) {\r\ncase IIO_TEMP:\r\nret = tsys01_read_temperature(indio_dev, &temperature);\r\nif (ret)\r\nreturn ret;\r\n*val = temperature;\r\nreturn IIO_VAL_INT;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic bool tsys01_crc_valid(u16 *n_prom)\r\n{\r\nu8 cnt;\r\nu8 sum = 0;\r\nfor (cnt = 0; cnt < TSYS01_PROM_WORDS_NB; cnt++)\r\nsum += ((n_prom[0] >> 8) + (n_prom[0] & 0xFF));\r\nreturn (sum == 0);\r\n}\r\nstatic int tsys01_read_prom(struct iio_dev *indio_dev)\r\n{\r\nint i, ret;\r\nstruct tsys01_dev *dev_data = iio_priv(indio_dev);\r\nchar buf[7 * TSYS01_PROM_WORDS_NB + 1];\r\nchar *ptr = buf;\r\nfor (i = 0; i < TSYS01_PROM_WORDS_NB; i++) {\r\nret = dev_data->read_prom_word(dev_data->client,\r\nTSYS01_PROM_READ + (i << 1),\r\n&dev_data->prom[i]);\r\nif (ret)\r\nreturn ret;\r\nret = sprintf(ptr, "0x%04x ", dev_data->prom[i]);\r\nptr += ret;\r\n}\r\nif (!tsys01_crc_valid(dev_data->prom)) {\r\ndev_err(&indio_dev->dev, "prom crc check error\n");\r\nreturn -ENODEV;\r\n}\r\n*ptr = 0;\r\ndev_info(&indio_dev->dev, "PROM coefficients : %s\n", buf);\r\nreturn 0;\r\n}\r\nstatic int tsys01_probe(struct iio_dev *indio_dev, struct device *dev)\r\n{\r\nint ret;\r\nstruct tsys01_dev *dev_data = iio_priv(indio_dev);\r\nmutex_init(&dev_data->lock);\r\nindio_dev->info = &tsys01_info;\r\nindio_dev->name = dev->driver->name;\r\nindio_dev->dev.parent = dev;\r\nindio_dev->modes = INDIO_DIRECT_MODE;\r\nindio_dev->channels = tsys01_channels;\r\nindio_dev->num_channels = ARRAY_SIZE(tsys01_channels);\r\nret = dev_data->reset(dev_data->client, TSYS01_RESET, 3000);\r\nif (ret)\r\nreturn ret;\r\nret = tsys01_read_prom(indio_dev);\r\nif (ret)\r\nreturn ret;\r\nreturn devm_iio_device_register(dev, indio_dev);\r\n}\r\nstatic int tsys01_i2c_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct tsys01_dev *dev_data;\r\nstruct iio_dev *indio_dev;\r\nif (!i2c_check_functionality(client->adapter,\r\nI2C_FUNC_SMBUS_WORD_DATA |\r\nI2C_FUNC_SMBUS_WRITE_BYTE |\r\nI2C_FUNC_SMBUS_READ_I2C_BLOCK)) {\r\ndev_err(&client->dev,\r\n"Adapter does not support some i2c transaction\n");\r\nreturn -ENODEV;\r\n}\r\nindio_dev = devm_iio_device_alloc(&client->dev, sizeof(*dev_data));\r\nif (!indio_dev)\r\nreturn -ENOMEM;\r\ndev_data = iio_priv(indio_dev);\r\ndev_data->client = client;\r\ndev_data->reset = ms_sensors_reset;\r\ndev_data->read_prom_word = ms_sensors_read_prom_word;\r\ndev_data->convert_and_read = ms_sensors_convert_and_read;\r\ni2c_set_clientdata(client, indio_dev);\r\nreturn tsys01_probe(indio_dev, &client->dev);\r\n}
