void rcu_sync_lockdep_assert(struct rcu_sync *rsp)\r\n{\r\nRCU_LOCKDEP_WARN(!gp_ops[rsp->gp_type].held(),\r\n"suspicious rcu_sync_is_idle() usage");\r\n}\r\nvoid rcu_sync_init(struct rcu_sync *rsp, enum rcu_sync_type type)\r\n{\r\nmemset(rsp, 0, sizeof(*rsp));\r\ninit_waitqueue_head(&rsp->gp_wait);\r\nrsp->gp_type = type;\r\n}\r\nvoid rcu_sync_enter(struct rcu_sync *rsp)\r\n{\r\nbool need_wait, need_sync;\r\nspin_lock_irq(&rsp->rss_lock);\r\nneed_wait = rsp->gp_count++;\r\nneed_sync = rsp->gp_state == GP_IDLE;\r\nif (need_sync)\r\nrsp->gp_state = GP_PENDING;\r\nspin_unlock_irq(&rsp->rss_lock);\r\nBUG_ON(need_wait && need_sync);\r\nif (need_sync) {\r\ngp_ops[rsp->gp_type].sync();\r\nrsp->gp_state = GP_PASSED;\r\nwake_up_all(&rsp->gp_wait);\r\n} else if (need_wait) {\r\nwait_event(rsp->gp_wait, rsp->gp_state == GP_PASSED);\r\n} else {\r\nBUG_ON(rsp->gp_state != GP_PASSED);\r\n}\r\n}\r\nstatic void rcu_sync_func(struct rcu_head *rcu)\r\n{\r\nstruct rcu_sync *rsp = container_of(rcu, struct rcu_sync, cb_head);\r\nunsigned long flags;\r\nBUG_ON(rsp->gp_state != GP_PASSED);\r\nBUG_ON(rsp->cb_state == CB_IDLE);\r\nspin_lock_irqsave(&rsp->rss_lock, flags);\r\nif (rsp->gp_count) {\r\nrsp->cb_state = CB_IDLE;\r\n} else if (rsp->cb_state == CB_REPLAY) {\r\nrsp->cb_state = CB_PENDING;\r\ngp_ops[rsp->gp_type].call(&rsp->cb_head, rcu_sync_func);\r\n} else {\r\nrsp->cb_state = CB_IDLE;\r\nrsp->gp_state = GP_IDLE;\r\n}\r\nspin_unlock_irqrestore(&rsp->rss_lock, flags);\r\n}\r\nvoid rcu_sync_exit(struct rcu_sync *rsp)\r\n{\r\nspin_lock_irq(&rsp->rss_lock);\r\nif (!--rsp->gp_count) {\r\nif (rsp->cb_state == CB_IDLE) {\r\nrsp->cb_state = CB_PENDING;\r\ngp_ops[rsp->gp_type].call(&rsp->cb_head, rcu_sync_func);\r\n} else if (rsp->cb_state == CB_PENDING) {\r\nrsp->cb_state = CB_REPLAY;\r\n}\r\n}\r\nspin_unlock_irq(&rsp->rss_lock);\r\n}\r\nvoid rcu_sync_dtor(struct rcu_sync *rsp)\r\n{\r\nint cb_state;\r\nBUG_ON(rsp->gp_count);\r\nspin_lock_irq(&rsp->rss_lock);\r\nif (rsp->cb_state == CB_REPLAY)\r\nrsp->cb_state = CB_PENDING;\r\ncb_state = rsp->cb_state;\r\nspin_unlock_irq(&rsp->rss_lock);\r\nif (cb_state != CB_IDLE) {\r\ngp_ops[rsp->gp_type].wait();\r\nBUG_ON(rsp->cb_state != CB_IDLE);\r\n}\r\n}
