static irqreturn_t mhu_rx_interrupt(int irq, void *p)\r\n{\r\nstruct mbox_chan *chan = p;\r\nstruct mhu_link *mlink = chan->con_priv;\r\nu32 val;\r\nval = readl_relaxed(mlink->rx_reg + INTR_STAT_OFS);\r\nif (!val)\r\nreturn IRQ_NONE;\r\nmbox_chan_received_data(chan, (void *)&val);\r\nwritel_relaxed(val, mlink->rx_reg + INTR_CLR_OFS);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic bool mhu_last_tx_done(struct mbox_chan *chan)\r\n{\r\nstruct mhu_link *mlink = chan->con_priv;\r\nu32 val = readl_relaxed(mlink->tx_reg + INTR_STAT_OFS);\r\nreturn (val == 0);\r\n}\r\nstatic int mhu_send_data(struct mbox_chan *chan, void *data)\r\n{\r\nstruct mhu_link *mlink = chan->con_priv;\r\nu32 *arg = data;\r\nwritel_relaxed(*arg, mlink->tx_reg + INTR_SET_OFS);\r\nreturn 0;\r\n}\r\nstatic int mhu_startup(struct mbox_chan *chan)\r\n{\r\nstruct mhu_link *mlink = chan->con_priv;\r\nu32 val;\r\nint ret;\r\nval = readl_relaxed(mlink->tx_reg + INTR_STAT_OFS);\r\nwritel_relaxed(val, mlink->tx_reg + INTR_CLR_OFS);\r\nret = request_irq(mlink->irq, mhu_rx_interrupt,\r\nIRQF_SHARED, "mhu_link", chan);\r\nif (ret) {\r\ndev_err(chan->mbox->dev,\r\n"Unable to acquire IRQ %d\n", mlink->irq);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic void mhu_shutdown(struct mbox_chan *chan)\r\n{\r\nstruct mhu_link *mlink = chan->con_priv;\r\nfree_irq(mlink->irq, chan);\r\n}\r\nstatic int mhu_probe(struct amba_device *adev, const struct amba_id *id)\r\n{\r\nint i, err;\r\nstruct arm_mhu *mhu;\r\nstruct device *dev = &adev->dev;\r\nint mhu_reg[MHU_CHANS] = {MHU_LP_OFFSET, MHU_HP_OFFSET, MHU_SEC_OFFSET};\r\nmhu = devm_kzalloc(dev, sizeof(*mhu), GFP_KERNEL);\r\nif (!mhu)\r\nreturn -ENOMEM;\r\nmhu->base = devm_ioremap_resource(dev, &adev->res);\r\nif (IS_ERR(mhu->base)) {\r\ndev_err(dev, "ioremap failed\n");\r\nreturn PTR_ERR(mhu->base);\r\n}\r\nfor (i = 0; i < MHU_CHANS; i++) {\r\nmhu->chan[i].con_priv = &mhu->mlink[i];\r\nmhu->mlink[i].irq = adev->irq[i];\r\nmhu->mlink[i].rx_reg = mhu->base + mhu_reg[i];\r\nmhu->mlink[i].tx_reg = mhu->mlink[i].rx_reg + TX_REG_OFFSET;\r\n}\r\nmhu->mbox.dev = dev;\r\nmhu->mbox.chans = &mhu->chan[0];\r\nmhu->mbox.num_chans = MHU_CHANS;\r\nmhu->mbox.ops = &mhu_ops;\r\nmhu->mbox.txdone_irq = false;\r\nmhu->mbox.txdone_poll = true;\r\nmhu->mbox.txpoll_period = 1;\r\namba_set_drvdata(adev, mhu);\r\nerr = mbox_controller_register(&mhu->mbox);\r\nif (err) {\r\ndev_err(dev, "Failed to register mailboxes %d\n", err);\r\nreturn err;\r\n}\r\ndev_info(dev, "ARM MHU Mailbox registered\n");\r\nreturn 0;\r\n}\r\nstatic int mhu_remove(struct amba_device *adev)\r\n{\r\nstruct arm_mhu *mhu = amba_get_drvdata(adev);\r\nmbox_controller_unregister(&mhu->mbox);\r\nreturn 0;\r\n}
