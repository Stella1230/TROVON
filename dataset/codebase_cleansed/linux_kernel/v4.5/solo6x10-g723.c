static void solo_g723_config(struct solo_dev *solo_dev)\r\n{\r\nint clk_div;\r\nclk_div = (solo_dev->clock_mhz * 1000000)\r\n/ (SAMPLERATE * (BITRATE * 2) * 2);\r\nsolo_reg_write(solo_dev, SOLO_AUDIO_SAMPLE,\r\nSOLO_AUDIO_BITRATE(BITRATE)\r\n| SOLO_AUDIO_CLK_DIV(clk_div));\r\nsolo_reg_write(solo_dev, SOLO_AUDIO_FDMA_INTR,\r\nSOLO_AUDIO_FDMA_INTERVAL(1)\r\n| SOLO_AUDIO_INTR_ORDER(G723_INTR_ORDER)\r\n| SOLO_AUDIO_FDMA_BASE(SOLO_G723_EXT_ADDR(solo_dev) >> 16));\r\nsolo_reg_write(solo_dev, SOLO_AUDIO_CONTROL,\r\nSOLO_AUDIO_ENABLE\r\n| SOLO_AUDIO_I2S_MODE\r\n| SOLO_AUDIO_I2S_MULTI(3)\r\n| SOLO_AUDIO_MODE(OUTMODE_MASK));\r\n}\r\nvoid solo_g723_isr(struct solo_dev *solo_dev)\r\n{\r\nstruct snd_pcm_str *pstr =\r\n&solo_dev->snd_pcm->streams[SNDRV_PCM_STREAM_CAPTURE];\r\nstruct snd_pcm_substream *ss;\r\nstruct solo_snd_pcm *solo_pcm;\r\nfor (ss = pstr->substream; ss != NULL; ss = ss->next) {\r\nif (snd_pcm_substream_chip(ss) == NULL)\r\ncontinue;\r\nif (snd_pcm_substream_chip(ss) == solo_dev)\r\ncontinue;\r\nsolo_pcm = snd_pcm_substream_chip(ss);\r\nif (!solo_pcm->on)\r\ncontinue;\r\nsnd_pcm_period_elapsed(ss);\r\n}\r\n}\r\nstatic int snd_solo_hw_params(struct snd_pcm_substream *ss,\r\nstruct snd_pcm_hw_params *hw_params)\r\n{\r\nreturn snd_pcm_lib_malloc_pages(ss, params_buffer_bytes(hw_params));\r\n}\r\nstatic int snd_solo_hw_free(struct snd_pcm_substream *ss)\r\n{\r\nreturn snd_pcm_lib_free_pages(ss);\r\n}\r\nstatic int snd_solo_pcm_open(struct snd_pcm_substream *ss)\r\n{\r\nstruct solo_dev *solo_dev = snd_pcm_substream_chip(ss);\r\nstruct solo_snd_pcm *solo_pcm;\r\nsolo_pcm = kzalloc(sizeof(*solo_pcm), GFP_KERNEL);\r\nif (solo_pcm == NULL)\r\ngoto oom;\r\nsolo_pcm->g723_buf = pci_alloc_consistent(solo_dev->pdev,\r\nG723_PERIOD_BYTES,\r\n&solo_pcm->g723_dma);\r\nif (solo_pcm->g723_buf == NULL)\r\ngoto oom;\r\nspin_lock_init(&solo_pcm->lock);\r\nsolo_pcm->solo_dev = solo_dev;\r\nss->runtime->hw = snd_solo_pcm_hw;\r\nsnd_pcm_substream_chip(ss) = solo_pcm;\r\nreturn 0;\r\noom:\r\nkfree(solo_pcm);\r\nreturn -ENOMEM;\r\n}\r\nstatic int snd_solo_pcm_close(struct snd_pcm_substream *ss)\r\n{\r\nstruct solo_snd_pcm *solo_pcm = snd_pcm_substream_chip(ss);\r\nsnd_pcm_substream_chip(ss) = solo_pcm->solo_dev;\r\npci_free_consistent(solo_pcm->solo_dev->pdev, G723_PERIOD_BYTES,\r\nsolo_pcm->g723_buf, solo_pcm->g723_dma);\r\nkfree(solo_pcm);\r\nreturn 0;\r\n}\r\nstatic int snd_solo_pcm_trigger(struct snd_pcm_substream *ss, int cmd)\r\n{\r\nstruct solo_snd_pcm *solo_pcm = snd_pcm_substream_chip(ss);\r\nstruct solo_dev *solo_dev = solo_pcm->solo_dev;\r\nint ret = 0;\r\nspin_lock(&solo_pcm->lock);\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\nif (solo_pcm->on == 0) {\r\nif (atomic_inc_return(&solo_dev->snd_users) == 1)\r\nsolo_irq_on(solo_dev, SOLO_IRQ_G723);\r\nsolo_pcm->on = 1;\r\n}\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\nif (solo_pcm->on) {\r\nif (atomic_dec_return(&solo_dev->snd_users) == 0)\r\nsolo_irq_off(solo_dev, SOLO_IRQ_G723);\r\nsolo_pcm->on = 0;\r\n}\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\n}\r\nspin_unlock(&solo_pcm->lock);\r\nreturn ret;\r\n}\r\nstatic int snd_solo_pcm_prepare(struct snd_pcm_substream *ss)\r\n{\r\nreturn 0;\r\n}\r\nstatic snd_pcm_uframes_t snd_solo_pcm_pointer(struct snd_pcm_substream *ss)\r\n{\r\nstruct solo_snd_pcm *solo_pcm = snd_pcm_substream_chip(ss);\r\nstruct solo_dev *solo_dev = solo_pcm->solo_dev;\r\nsnd_pcm_uframes_t idx = solo_reg_read(solo_dev, SOLO_AUDIO_STA) & 0x1f;\r\nreturn idx * G723_FRAMES_PER_PAGE;\r\n}\r\nstatic int snd_solo_pcm_copy(struct snd_pcm_substream *ss, int channel,\r\nsnd_pcm_uframes_t pos, void __user *dst,\r\nsnd_pcm_uframes_t count)\r\n{\r\nstruct solo_snd_pcm *solo_pcm = snd_pcm_substream_chip(ss);\r\nstruct solo_dev *solo_dev = solo_pcm->solo_dev;\r\nint err, i;\r\nfor (i = 0; i < (count / G723_FRAMES_PER_PAGE); i++) {\r\nint page = (pos / G723_FRAMES_PER_PAGE) + i;\r\nerr = solo_p2m_dma_t(solo_dev, 0, solo_pcm->g723_dma,\r\nSOLO_G723_EXT_ADDR(solo_dev) +\r\n(page * G723_PERIOD_BLOCK) +\r\n(ss->number * G723_PERIOD_BYTES),\r\nG723_PERIOD_BYTES, 0, 0);\r\nif (err)\r\nreturn err;\r\nerr = copy_to_user(dst + (i * G723_PERIOD_BYTES),\r\nsolo_pcm->g723_buf, G723_PERIOD_BYTES);\r\nif (err)\r\nreturn -EFAULT;\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_solo_capture_volume_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *info)\r\n{\r\ninfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\r\ninfo->count = 1;\r\ninfo->value.integer.min = 0;\r\ninfo->value.integer.max = 15;\r\ninfo->value.integer.step = 1;\r\nreturn 0;\r\n}\r\nstatic int snd_solo_capture_volume_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *value)\r\n{\r\nstruct solo_dev *solo_dev = snd_kcontrol_chip(kcontrol);\r\nu8 ch = value->id.numid - 1;\r\nvalue->value.integer.value[0] = tw28_get_audio_gain(solo_dev, ch);\r\nreturn 0;\r\n}\r\nstatic int snd_solo_capture_volume_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *value)\r\n{\r\nstruct solo_dev *solo_dev = snd_kcontrol_chip(kcontrol);\r\nu8 ch = value->id.numid - 1;\r\nu8 old_val;\r\nold_val = tw28_get_audio_gain(solo_dev, ch);\r\nif (old_val == value->value.integer.value[0])\r\nreturn 0;\r\ntw28_set_audio_gain(solo_dev, ch, value->value.integer.value[0]);\r\nreturn 1;\r\n}\r\nstatic int solo_snd_pcm_init(struct solo_dev *solo_dev)\r\n{\r\nstruct snd_card *card = solo_dev->snd_card;\r\nstruct snd_pcm *pcm;\r\nstruct snd_pcm_substream *ss;\r\nint ret;\r\nint i;\r\nret = snd_pcm_new(card, card->driver, 0, 0, solo_dev->nr_chans,\r\n&pcm);\r\nif (ret < 0)\r\nreturn ret;\r\nsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE,\r\n&snd_solo_pcm_ops);\r\nsnd_pcm_chip(pcm) = solo_dev;\r\npcm->info_flags = 0;\r\nstrcpy(pcm->name, card->shortname);\r\nfor (i = 0, ss = pcm->streams[SNDRV_PCM_STREAM_CAPTURE].substream;\r\nss; ss = ss->next, i++)\r\nsprintf(ss->name, "Camera #%d Audio", i);\r\nret = snd_pcm_lib_preallocate_pages_for_all(pcm,\r\nSNDRV_DMA_TYPE_CONTINUOUS,\r\nsnd_dma_continuous_data(GFP_KERNEL),\r\nG723_PERIOD_BYTES * PERIODS,\r\nG723_PERIOD_BYTES * PERIODS);\r\nif (ret < 0)\r\nreturn ret;\r\nsolo_dev->snd_pcm = pcm;\r\nreturn 0;\r\n}\r\nint solo_g723_init(struct solo_dev *solo_dev)\r\n{\r\nstatic struct snd_device_ops ops = { NULL };\r\nstruct snd_card *card;\r\nstruct snd_kcontrol_new kctl;\r\nchar name[32];\r\nint ret;\r\natomic_set(&solo_dev->snd_users, 0);\r\nsprintf(name, "Softlogic%d", solo_dev->vfd->num);\r\nret = snd_card_new(&solo_dev->pdev->dev,\r\nSNDRV_DEFAULT_IDX1, name, THIS_MODULE, 0,\r\n&solo_dev->snd_card);\r\nif (ret < 0)\r\nreturn ret;\r\ncard = solo_dev->snd_card;\r\nstrcpy(card->driver, SOLO6X10_NAME);\r\nstrcpy(card->shortname, "SOLO-6x10 Audio");\r\nsprintf(card->longname, "%s on %s IRQ %d", card->shortname,\r\npci_name(solo_dev->pdev), solo_dev->pdev->irq);\r\nret = snd_device_new(card, SNDRV_DEV_LOWLEVEL, solo_dev, &ops);\r\nif (ret < 0)\r\ngoto snd_error;\r\nstrcpy(card->mixername, "SOLO-6x10");\r\nkctl = snd_solo_capture_volume;\r\nkctl.count = solo_dev->nr_chans;\r\nret = snd_ctl_add(card, snd_ctl_new1(&kctl, solo_dev));\r\nif (ret < 0)\r\nreturn ret;\r\nret = solo_snd_pcm_init(solo_dev);\r\nif (ret < 0)\r\ngoto snd_error;\r\nret = snd_card_register(card);\r\nif (ret < 0)\r\ngoto snd_error;\r\nsolo_g723_config(solo_dev);\r\ndev_info(&solo_dev->pdev->dev, "Alsa sound card as %s\n", name);\r\nreturn 0;\r\nsnd_error:\r\nsnd_card_free(card);\r\nreturn ret;\r\n}\r\nvoid solo_g723_exit(struct solo_dev *solo_dev)\r\n{\r\nif (!solo_dev->snd_card)\r\nreturn;\r\nsolo_reg_write(solo_dev, SOLO_AUDIO_CONTROL, 0);\r\nsolo_irq_off(solo_dev, SOLO_IRQ_G723);\r\nsnd_card_free(solo_dev->snd_card);\r\nsolo_dev->snd_card = NULL;\r\n}
