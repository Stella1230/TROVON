static inline void aha1542_intr_reset(u16 base)\r\n{\r\noutb(IRST, CONTROL(base));\r\n}\r\nstatic inline bool wait_mask(u16 port, u8 mask, u8 allof, u8 noneof, int timeout)\r\n{\r\nbool delayed = true;\r\nif (timeout == 0) {\r\ntimeout = 3000000;\r\ndelayed = false;\r\n}\r\nwhile (1) {\r\nu8 bits = inb(port) & mask;\r\nif ((bits & allof) == allof && ((bits & noneof) == 0))\r\nbreak;\r\nif (delayed)\r\nmdelay(1);\r\nif (--timeout == 0)\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\nstatic int aha1542_outb(unsigned int base, u8 val)\r\n{\r\nif (!wait_mask(STATUS(base), CDF, 0, CDF, 0))\r\nreturn 1;\r\noutb(val, DATA(base));\r\nreturn 0;\r\n}\r\nstatic int aha1542_out(unsigned int base, u8 *buf, int len)\r\n{\r\nwhile (len--) {\r\nif (!wait_mask(STATUS(base), CDF, 0, CDF, 0))\r\nreturn 1;\r\noutb(*buf++, DATA(base));\r\n}\r\nif (!wait_mask(INTRFLAGS(base), INTRMASK, HACC, 0, 0))\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic int aha1542_in(unsigned int base, u8 *buf, int len, int timeout)\r\n{\r\nwhile (len--) {\r\nif (!wait_mask(STATUS(base), DF, DF, 0, timeout))\r\nreturn 1;\r\n*buf++ = inb(DATA(base));\r\n}\r\nreturn 0;\r\n}\r\nstatic int makecode(unsigned hosterr, unsigned scsierr)\r\n{\r\nswitch (hosterr) {\r\ncase 0x0:\r\ncase 0xa:\r\ncase 0xb:\r\nhosterr = 0;\r\nbreak;\r\ncase 0x11:\r\nhosterr = DID_TIME_OUT;\r\nbreak;\r\ncase 0x12:\r\ncase 0x13:\r\ncase 0x15:\r\ncase 0x16:\r\ncase 0x17:\r\ncase 0x18:\r\ncase 0x19:\r\ncase 0x1a:\r\n#ifdef DEBUG\r\nprintk("Aha1542: %x %x\n", hosterr, scsierr);\r\n#endif\r\nhosterr = DID_ERROR;\r\nbreak;\r\ncase 0x14:\r\nhosterr = DID_RESET;\r\nbreak;\r\ndefault:\r\nprintk(KERN_ERR "aha1542: makecode: unknown hoststatus %x\n", hosterr);\r\nbreak;\r\n}\r\nreturn scsierr | (hosterr << 16);\r\n}\r\nstatic int aha1542_test_port(struct Scsi_Host *sh)\r\n{\r\nu8 inquiry_result[4];\r\nint i;\r\nif (inb(STATUS(sh->io_port)) == 0xff)\r\nreturn 0;\r\naha1542_intr_reset(sh->io_port);\r\noutb(SRST | IRST , CONTROL(sh->io_port));\r\nmdelay(20);\r\nif (!wait_mask(STATUS(sh->io_port), STATMASK, INIT | IDLE, STST | DIAGF | INVDCMD | DF | CDF, 0))\r\nreturn 0;\r\nif (inb(INTRFLAGS(sh->io_port)) & INTRMASK)\r\nreturn 0;\r\naha1542_outb(sh->io_port, CMD_INQUIRY);\r\nfor (i = 0; i < 4; i++) {\r\nif (!wait_mask(STATUS(sh->io_port), DF, DF, 0, 0))\r\nreturn 0;\r\ninquiry_result[i] = inb(DATA(sh->io_port));\r\n}\r\nif (inb(STATUS(sh->io_port)) & DF)\r\nreturn 0;\r\nif (!wait_mask(INTRFLAGS(sh->io_port), HACC, HACC, 0, 0))\r\nreturn 0;\r\noutb(IRST, CONTROL(sh->io_port));\r\nreturn 1;\r\n}\r\nstatic irqreturn_t aha1542_interrupt(int irq, void *dev_id)\r\n{\r\nstruct Scsi_Host *sh = dev_id;\r\nstruct aha1542_hostdata *aha1542 = shost_priv(sh);\r\nvoid (*my_done)(struct scsi_cmnd *) = NULL;\r\nint errstatus, mbi, mbo, mbistatus;\r\nint number_serviced;\r\nunsigned long flags;\r\nstruct scsi_cmnd *tmp_cmd;\r\nint flag;\r\nstruct mailbox *mb = aha1542->mb;\r\nstruct ccb *ccb = aha1542->ccb;\r\n#ifdef DEBUG\r\n{\r\nflag = inb(INTRFLAGS(sh->io_port));\r\nshost_printk(KERN_DEBUG, sh, "aha1542_intr_handle: ");\r\nif (!(flag & ANYINTR))\r\nprintk("no interrupt?");\r\nif (flag & MBIF)\r\nprintk("MBIF ");\r\nif (flag & MBOA)\r\nprintk("MBOF ");\r\nif (flag & HACC)\r\nprintk("HACC ");\r\nif (flag & SCRD)\r\nprintk("SCRD ");\r\nprintk("status %02x\n", inb(STATUS(sh->io_port)));\r\n};\r\n#endif\r\nnumber_serviced = 0;\r\nspin_lock_irqsave(sh->host_lock, flags);\r\nwhile (1) {\r\nflag = inb(INTRFLAGS(sh->io_port));\r\nif (flag & ~MBIF) {\r\nif (flag & MBOA)\r\nprintk("MBOF ");\r\nif (flag & HACC)\r\nprintk("HACC ");\r\nif (flag & SCRD)\r\nprintk("SCRD ");\r\n}\r\naha1542_intr_reset(sh->io_port);\r\nmbi = aha1542->aha1542_last_mbi_used + 1;\r\nif (mbi >= 2 * AHA1542_MAILBOXES)\r\nmbi = AHA1542_MAILBOXES;\r\ndo {\r\nif (mb[mbi].status != 0)\r\nbreak;\r\nmbi++;\r\nif (mbi >= 2 * AHA1542_MAILBOXES)\r\nmbi = AHA1542_MAILBOXES;\r\n} while (mbi != aha1542->aha1542_last_mbi_used);\r\nif (mb[mbi].status == 0) {\r\nspin_unlock_irqrestore(sh->host_lock, flags);\r\nif (!number_serviced)\r\nshost_printk(KERN_WARNING, sh, "interrupt received, but no mail.\n");\r\nreturn IRQ_HANDLED;\r\n};\r\nmbo = (scsi2int(mb[mbi].ccbptr) - (isa_virt_to_bus(&ccb[0]))) / sizeof(struct ccb);\r\nmbistatus = mb[mbi].status;\r\nmb[mbi].status = 0;\r\naha1542->aha1542_last_mbi_used = mbi;\r\n#ifdef DEBUG\r\nif (ccb[mbo].tarstat | ccb[mbo].hastat)\r\nshost_printk(KERN_DEBUG, sh, "aha1542_command: returning %x (status %d)\n",\r\nccb[mbo].tarstat + ((int) ccb[mbo].hastat << 16), mb[mbi].status);\r\n#endif\r\nif (mbistatus == 3)\r\ncontinue;\r\n#ifdef DEBUG\r\nshost_printk(KERN_DEBUG, sh, "...done %d %d\n", mbo, mbi);\r\n#endif\r\ntmp_cmd = aha1542->int_cmds[mbo];\r\nif (!tmp_cmd || !tmp_cmd->scsi_done) {\r\nspin_unlock_irqrestore(sh->host_lock, flags);\r\nshost_printk(KERN_WARNING, sh, "Unexpected interrupt\n");\r\nshost_printk(KERN_WARNING, sh, "tarstat=%x, hastat=%x idlun=%x ccb#=%d\n", ccb[mbo].tarstat,\r\nccb[mbo].hastat, ccb[mbo].idlun, mbo);\r\nreturn IRQ_HANDLED;\r\n}\r\nmy_done = tmp_cmd->scsi_done;\r\nkfree(tmp_cmd->host_scribble);\r\ntmp_cmd->host_scribble = NULL;\r\nif (ccb[mbo].tarstat == 2)\r\nmemcpy(tmp_cmd->sense_buffer, &ccb[mbo].cdb[ccb[mbo].cdblen],\r\nSCSI_SENSE_BUFFERSIZE);\r\nif (mbistatus != 1)\r\nerrstatus = makecode(ccb[mbo].hastat, ccb[mbo].tarstat);\r\nelse\r\nerrstatus = 0;\r\n#ifdef DEBUG\r\nif (errstatus)\r\nshost_printk(KERN_DEBUG, sh, "(aha1542 error:%x %x %x) ", errstatus,\r\nccb[mbo].hastat, ccb[mbo].tarstat);\r\nif (ccb[mbo].tarstat == 2)\r\nprint_hex_dump_bytes("sense: ", DUMP_PREFIX_NONE, &ccb[mbo].cdb[ccb[mbo].cdblen], 12);\r\nif (errstatus)\r\nprintk("aha1542_intr_handle: returning %6x\n", errstatus);\r\n#endif\r\ntmp_cmd->result = errstatus;\r\naha1542->int_cmds[mbo] = NULL;\r\nmy_done(tmp_cmd);\r\nnumber_serviced++;\r\n};\r\n}\r\nstatic int aha1542_queuecommand(struct Scsi_Host *sh, struct scsi_cmnd *cmd)\r\n{\r\nstruct aha1542_hostdata *aha1542 = shost_priv(sh);\r\nu8 direction;\r\nu8 target = cmd->device->id;\r\nu8 lun = cmd->device->lun;\r\nunsigned long flags;\r\nint bufflen = scsi_bufflen(cmd);\r\nint mbo, sg_count;\r\nstruct mailbox *mb = aha1542->mb;\r\nstruct ccb *ccb = aha1542->ccb;\r\nstruct chain *cptr;\r\nif (*cmd->cmnd == REQUEST_SENSE) {\r\ncmd->result = 0;\r\ncmd->scsi_done(cmd);\r\nreturn 0;\r\n}\r\n#ifdef DEBUG\r\n{\r\nint i = -1;\r\nif (*cmd->cmnd == READ_10 || *cmd->cmnd == WRITE_10)\r\ni = xscsi2int(cmd->cmnd + 2);\r\nelse if (*cmd->cmnd == READ_6 || *cmd->cmnd == WRITE_6)\r\ni = scsi2int(cmd->cmnd + 2);\r\nshost_printk(KERN_DEBUG, sh, "aha1542_queuecommand: dev %d cmd %02x pos %d len %d",\r\ntarget, *cmd->cmnd, i, bufflen);\r\nprint_hex_dump_bytes("command: ", DUMP_PREFIX_NONE, cmd->cmnd, cmd->cmd_len);\r\n}\r\n#endif\r\nif (bufflen) {\r\nsg_count = scsi_sg_count(cmd);\r\ncptr = kmalloc(sizeof(*cptr) * sg_count, GFP_KERNEL | GFP_DMA);\r\nif (!cptr)\r\nreturn SCSI_MLQUEUE_HOST_BUSY;\r\n}\r\nspin_lock_irqsave(sh->host_lock, flags);\r\nmbo = aha1542->aha1542_last_mbo_used + 1;\r\nif (mbo >= AHA1542_MAILBOXES)\r\nmbo = 0;\r\ndo {\r\nif (mb[mbo].status == 0 && aha1542->int_cmds[mbo] == NULL)\r\nbreak;\r\nmbo++;\r\nif (mbo >= AHA1542_MAILBOXES)\r\nmbo = 0;\r\n} while (mbo != aha1542->aha1542_last_mbo_used);\r\nif (mb[mbo].status || aha1542->int_cmds[mbo])\r\npanic("Unable to find empty mailbox for aha1542.\n");\r\naha1542->int_cmds[mbo] = cmd;\r\naha1542->aha1542_last_mbo_used = mbo;\r\n#ifdef DEBUG\r\nshost_printk(KERN_DEBUG, sh, "Sending command (%d %p)...", mbo, cmd->scsi_done);\r\n#endif\r\nany2scsi(mb[mbo].ccbptr, isa_virt_to_bus(&ccb[mbo]));\r\nmemset(&ccb[mbo], 0, sizeof(struct ccb));\r\nccb[mbo].cdblen = cmd->cmd_len;\r\ndirection = 0;\r\nif (*cmd->cmnd == READ_10 || *cmd->cmnd == READ_6)\r\ndirection = 8;\r\nelse if (*cmd->cmnd == WRITE_10 || *cmd->cmnd == WRITE_6)\r\ndirection = 16;\r\nmemcpy(ccb[mbo].cdb, cmd->cmnd, ccb[mbo].cdblen);\r\nif (bufflen) {\r\nstruct scatterlist *sg;\r\nint i;\r\nccb[mbo].op = 2;\r\ncmd->host_scribble = (void *)cptr;\r\nscsi_for_each_sg(cmd, sg, sg_count, i) {\r\nany2scsi(cptr[i].dataptr, isa_page_to_bus(sg_page(sg))\r\n+ sg->offset);\r\nany2scsi(cptr[i].datalen, sg->length);\r\n};\r\nany2scsi(ccb[mbo].datalen, sg_count * sizeof(struct chain));\r\nany2scsi(ccb[mbo].dataptr, isa_virt_to_bus(cptr));\r\n#ifdef DEBUG\r\nshost_printk(KERN_DEBUG, sh, "cptr %p: ", cptr);\r\nprint_hex_dump_bytes("cptr: ", DUMP_PREFIX_NONE, cptr, 18);\r\n#endif\r\n} else {\r\nccb[mbo].op = 0;\r\ncmd->host_scribble = NULL;\r\nany2scsi(ccb[mbo].datalen, 0);\r\nany2scsi(ccb[mbo].dataptr, 0);\r\n};\r\nccb[mbo].idlun = (target & 7) << 5 | direction | (lun & 7);\r\nccb[mbo].rsalen = 16;\r\nccb[mbo].linkptr[0] = ccb[mbo].linkptr[1] = ccb[mbo].linkptr[2] = 0;\r\nccb[mbo].commlinkid = 0;\r\n#ifdef DEBUG\r\nprint_hex_dump_bytes("sending: ", DUMP_PREFIX_NONE, &ccb[mbo], sizeof(ccb[mbo]) - 10);\r\nprintk("aha1542_queuecommand: now waiting for interrupt ");\r\n#endif\r\nmb[mbo].status = 1;\r\naha1542_outb(cmd->device->host->io_port, CMD_START_SCSI);\r\nspin_unlock_irqrestore(sh->host_lock, flags);\r\nreturn 0;\r\n}\r\nstatic void setup_mailboxes(struct Scsi_Host *sh)\r\n{\r\nstruct aha1542_hostdata *aha1542 = shost_priv(sh);\r\nint i;\r\nstruct mailbox *mb = aha1542->mb;\r\nstruct ccb *ccb = aha1542->ccb;\r\nu8 mb_cmd[5] = { CMD_MBINIT, AHA1542_MAILBOXES, 0, 0, 0};\r\nfor (i = 0; i < AHA1542_MAILBOXES; i++) {\r\nmb[i].status = mb[AHA1542_MAILBOXES + i].status = 0;\r\nany2scsi(mb[i].ccbptr, isa_virt_to_bus(&ccb[i]));\r\n};\r\naha1542_intr_reset(sh->io_port);\r\nany2scsi((mb_cmd + 2), isa_virt_to_bus(mb));\r\nif (aha1542_out(sh->io_port, mb_cmd, 5))\r\nshost_printk(KERN_ERR, sh, "failed setting up mailboxes\n");\r\naha1542_intr_reset(sh->io_port);\r\n}\r\nstatic int aha1542_getconfig(struct Scsi_Host *sh)\r\n{\r\nu8 inquiry_result[3];\r\nint i;\r\ni = inb(STATUS(sh->io_port));\r\nif (i & DF) {\r\ni = inb(DATA(sh->io_port));\r\n};\r\naha1542_outb(sh->io_port, CMD_RETCONF);\r\naha1542_in(sh->io_port, inquiry_result, 3, 0);\r\nif (!wait_mask(INTRFLAGS(sh->io_port), INTRMASK, HACC, 0, 0))\r\nshost_printk(KERN_ERR, sh, "error querying board settings\n");\r\naha1542_intr_reset(sh->io_port);\r\nswitch (inquiry_result[0]) {\r\ncase 0x80:\r\nsh->dma_channel = 7;\r\nbreak;\r\ncase 0x40:\r\nsh->dma_channel = 6;\r\nbreak;\r\ncase 0x20:\r\nsh->dma_channel = 5;\r\nbreak;\r\ncase 0x01:\r\nsh->dma_channel = 0;\r\nbreak;\r\ncase 0:\r\nsh->dma_channel = 0xFF;\r\nbreak;\r\ndefault:\r\nshost_printk(KERN_ERR, sh, "Unable to determine DMA channel.\n");\r\nreturn -1;\r\n};\r\nswitch (inquiry_result[1]) {\r\ncase 0x40:\r\nsh->irq = 15;\r\nbreak;\r\ncase 0x20:\r\nsh->irq = 14;\r\nbreak;\r\ncase 0x8:\r\nsh->irq = 12;\r\nbreak;\r\ncase 0x4:\r\nsh->irq = 11;\r\nbreak;\r\ncase 0x2:\r\nsh->irq = 10;\r\nbreak;\r\ncase 0x1:\r\nsh->irq = 9;\r\nbreak;\r\ndefault:\r\nshost_printk(KERN_ERR, sh, "Unable to determine IRQ level.\n");\r\nreturn -1;\r\n};\r\nsh->this_id = inquiry_result[2] & 7;\r\nreturn 0;\r\n}\r\nstatic int aha1542_mbenable(struct Scsi_Host *sh)\r\n{\r\nstatic u8 mbenable_cmd[3];\r\nstatic u8 mbenable_result[2];\r\nint retval;\r\nretval = BIOS_TRANSLATION_6432;\r\naha1542_outb(sh->io_port, CMD_EXTBIOS);\r\nif (aha1542_in(sh->io_port, mbenable_result, 2, 100))\r\nreturn retval;\r\nif (!wait_mask(INTRFLAGS(sh->io_port), INTRMASK, HACC, 0, 100))\r\ngoto fail;\r\naha1542_intr_reset(sh->io_port);\r\nif ((mbenable_result[0] & 0x08) || mbenable_result[1]) {\r\nmbenable_cmd[0] = CMD_MBENABLE;\r\nmbenable_cmd[1] = 0;\r\nmbenable_cmd[2] = mbenable_result[1];\r\nif ((mbenable_result[0] & 0x08) && (mbenable_result[1] & 0x03))\r\nretval = BIOS_TRANSLATION_25563;\r\nif (aha1542_out(sh->io_port, mbenable_cmd, 3))\r\ngoto fail;\r\n};\r\nwhile (0) {\r\nfail:\r\nshost_printk(KERN_ERR, sh, "Mailbox init failed\n");\r\n}\r\naha1542_intr_reset(sh->io_port);\r\nreturn retval;\r\n}\r\nstatic int aha1542_query(struct Scsi_Host *sh)\r\n{\r\nstruct aha1542_hostdata *aha1542 = shost_priv(sh);\r\nu8 inquiry_result[4];\r\nint i;\r\ni = inb(STATUS(sh->io_port));\r\nif (i & DF) {\r\ni = inb(DATA(sh->io_port));\r\n};\r\naha1542_outb(sh->io_port, CMD_INQUIRY);\r\naha1542_in(sh->io_port, inquiry_result, 4, 0);\r\nif (!wait_mask(INTRFLAGS(sh->io_port), INTRMASK, HACC, 0, 0))\r\nshost_printk(KERN_ERR, sh, "error querying card type\n");\r\naha1542_intr_reset(sh->io_port);\r\naha1542->bios_translation = BIOS_TRANSLATION_6432;\r\nif (inquiry_result[0] == 0x43) {\r\nshost_printk(KERN_INFO, sh, "Emulation mode not supported for AHA-1740 hardware, use aha1740 driver instead.\n");\r\nreturn 1;\r\n};\r\naha1542->bios_translation = aha1542_mbenable(sh);\r\nreturn 0;\r\n}\r\nstatic u8 dma_speed_hw(int dma_speed)\r\n{\r\nswitch (dma_speed) {\r\ncase 5:\r\nreturn 0x00;\r\ncase 6:\r\nreturn 0x04;\r\ncase 7:\r\nreturn 0x01;\r\ncase 8:\r\nreturn 0x02;\r\ncase 10:\r\nreturn 0x03;\r\n}\r\nreturn 0xff;\r\n}\r\nstatic void aha1542_set_bus_times(struct Scsi_Host *sh, int bus_on, int bus_off, int dma_speed)\r\n{\r\nif (bus_on > 0) {\r\nu8 oncmd[] = { CMD_BUSON_TIME, clamp(bus_on, 2, 15) };\r\naha1542_intr_reset(sh->io_port);\r\nif (aha1542_out(sh->io_port, oncmd, 2))\r\ngoto fail;\r\n}\r\nif (bus_off > 0) {\r\nu8 offcmd[] = { CMD_BUSOFF_TIME, clamp(bus_off, 1, 64) };\r\naha1542_intr_reset(sh->io_port);\r\nif (aha1542_out(sh->io_port, offcmd, 2))\r\ngoto fail;\r\n}\r\nif (dma_speed_hw(dma_speed) != 0xff) {\r\nu8 dmacmd[] = { CMD_DMASPEED, dma_speed_hw(dma_speed) };\r\naha1542_intr_reset(sh->io_port);\r\nif (aha1542_out(sh->io_port, dmacmd, 2))\r\ngoto fail;\r\n}\r\naha1542_intr_reset(sh->io_port);\r\nreturn;\r\nfail:\r\nshost_printk(KERN_ERR, sh, "setting bus on/off-time failed\n");\r\naha1542_intr_reset(sh->io_port);\r\n}\r\nstatic struct Scsi_Host *aha1542_hw_init(struct scsi_host_template *tpnt, struct device *pdev, int indx)\r\n{\r\nunsigned int base_io = io[indx];\r\nstruct Scsi_Host *sh;\r\nstruct aha1542_hostdata *aha1542;\r\nchar dma_info[] = "no DMA";\r\nif (base_io == 0)\r\nreturn NULL;\r\nif (!request_region(base_io, AHA1542_REGION_SIZE, "aha1542"))\r\nreturn NULL;\r\nsh = scsi_host_alloc(tpnt, sizeof(struct aha1542_hostdata));\r\nif (!sh)\r\ngoto release;\r\naha1542 = shost_priv(sh);\r\nsh->unique_id = base_io;\r\nsh->io_port = base_io;\r\nsh->n_io_port = AHA1542_REGION_SIZE;\r\naha1542->aha1542_last_mbi_used = 2 * AHA1542_MAILBOXES - 1;\r\naha1542->aha1542_last_mbo_used = AHA1542_MAILBOXES - 1;\r\nif (!aha1542_test_port(sh))\r\ngoto unregister;\r\naha1542_set_bus_times(sh, bus_on[indx], bus_off[indx], dma_speed[indx]);\r\nif (aha1542_query(sh))\r\ngoto unregister;\r\nif (aha1542_getconfig(sh) == -1)\r\ngoto unregister;\r\nif (sh->dma_channel != 0xFF)\r\nsnprintf(dma_info, sizeof(dma_info), "DMA %d", sh->dma_channel);\r\nshost_printk(KERN_INFO, sh, "Adaptec AHA-1542 (SCSI-ID %d) at IO 0x%x, IRQ %d, %s\n",\r\nsh->this_id, base_io, sh->irq, dma_info);\r\nif (aha1542->bios_translation == BIOS_TRANSLATION_25563)\r\nshost_printk(KERN_INFO, sh, "Using extended bios translation\n");\r\nsetup_mailboxes(sh);\r\nif (request_irq(sh->irq, aha1542_interrupt, 0, "aha1542", sh)) {\r\nshost_printk(KERN_ERR, sh, "Unable to allocate IRQ.\n");\r\ngoto unregister;\r\n}\r\nif (sh->dma_channel != 0xFF) {\r\nif (request_dma(sh->dma_channel, "aha1542")) {\r\nshost_printk(KERN_ERR, sh, "Unable to allocate DMA channel.\n");\r\ngoto free_irq;\r\n}\r\nif (sh->dma_channel == 0 || sh->dma_channel >= 5) {\r\nset_dma_mode(sh->dma_channel, DMA_MODE_CASCADE);\r\nenable_dma(sh->dma_channel);\r\n}\r\n}\r\nif (scsi_add_host(sh, pdev))\r\ngoto free_dma;\r\nscsi_scan_host(sh);\r\nreturn sh;\r\nfree_dma:\r\nif (sh->dma_channel != 0xff)\r\nfree_dma(sh->dma_channel);\r\nfree_irq:\r\nfree_irq(sh->irq, sh);\r\nunregister:\r\nscsi_host_put(sh);\r\nrelease:\r\nrelease_region(base_io, AHA1542_REGION_SIZE);\r\nreturn NULL;\r\n}\r\nstatic int aha1542_release(struct Scsi_Host *sh)\r\n{\r\nscsi_remove_host(sh);\r\nif (sh->dma_channel != 0xff)\r\nfree_dma(sh->dma_channel);\r\nif (sh->irq)\r\nfree_irq(sh->irq, sh);\r\nif (sh->io_port && sh->n_io_port)\r\nrelease_region(sh->io_port, sh->n_io_port);\r\nscsi_host_put(sh);\r\nreturn 0;\r\n}\r\nstatic int aha1542_dev_reset(struct scsi_cmnd *cmd)\r\n{\r\nstruct Scsi_Host *sh = cmd->device->host;\r\nstruct aha1542_hostdata *aha1542 = shost_priv(sh);\r\nunsigned long flags;\r\nstruct mailbox *mb = aha1542->mb;\r\nu8 target = cmd->device->id;\r\nu8 lun = cmd->device->lun;\r\nint mbo;\r\nstruct ccb *ccb = aha1542->ccb;\r\nspin_lock_irqsave(sh->host_lock, flags);\r\nmbo = aha1542->aha1542_last_mbo_used + 1;\r\nif (mbo >= AHA1542_MAILBOXES)\r\nmbo = 0;\r\ndo {\r\nif (mb[mbo].status == 0 && aha1542->int_cmds[mbo] == NULL)\r\nbreak;\r\nmbo++;\r\nif (mbo >= AHA1542_MAILBOXES)\r\nmbo = 0;\r\n} while (mbo != aha1542->aha1542_last_mbo_used);\r\nif (mb[mbo].status || aha1542->int_cmds[mbo])\r\npanic("Unable to find empty mailbox for aha1542.\n");\r\naha1542->int_cmds[mbo] = cmd;\r\naha1542->aha1542_last_mbo_used = mbo;\r\nany2scsi(mb[mbo].ccbptr, isa_virt_to_bus(&ccb[mbo]));\r\nmemset(&ccb[mbo], 0, sizeof(struct ccb));\r\nccb[mbo].op = 0x81;\r\nccb[mbo].idlun = (target & 7) << 5 | (lun & 7);\r\nccb[mbo].linkptr[0] = ccb[mbo].linkptr[1] = ccb[mbo].linkptr[2] = 0;\r\nccb[mbo].commlinkid = 0;\r\naha1542_outb(sh->io_port, CMD_START_SCSI);\r\nspin_unlock_irqrestore(sh->host_lock, flags);\r\nscmd_printk(KERN_WARNING, cmd,\r\n"Trying device reset for target\n");\r\nreturn SUCCESS;\r\n}\r\nstatic int aha1542_reset(struct scsi_cmnd *cmd, u8 reset_cmd)\r\n{\r\nstruct Scsi_Host *sh = cmd->device->host;\r\nstruct aha1542_hostdata *aha1542 = shost_priv(sh);\r\nunsigned long flags;\r\nint i;\r\nspin_lock_irqsave(sh->host_lock, flags);\r\noutb(reset_cmd, CONTROL(cmd->device->host->io_port));\r\nif (!wait_mask(STATUS(cmd->device->host->io_port),\r\nSTATMASK, IDLE, STST | DIAGF | INVDCMD | DF | CDF, 0)) {\r\nspin_unlock_irqrestore(sh->host_lock, flags);\r\nreturn FAILED;\r\n}\r\nif (reset_cmd & HRST)\r\nsetup_mailboxes(cmd->device->host);\r\nshost_printk(KERN_WARNING, cmd->device->host, "Sent BUS RESET to scsi host %d\n", cmd->device->host->host_no);\r\nfor (i = 0; i < AHA1542_MAILBOXES; i++) {\r\nif (aha1542->int_cmds[i] != NULL) {\r\nstruct scsi_cmnd *tmp_cmd;\r\ntmp_cmd = aha1542->int_cmds[i];\r\nif (tmp_cmd->device->soft_reset) {\r\ncontinue;\r\n}\r\nkfree(tmp_cmd->host_scribble);\r\ntmp_cmd->host_scribble = NULL;\r\naha1542->int_cmds[i] = NULL;\r\naha1542->mb[i].status = 0;\r\n}\r\n}\r\nspin_unlock_irqrestore(sh->host_lock, flags);\r\nreturn SUCCESS;\r\n}\r\nstatic int aha1542_bus_reset(struct scsi_cmnd *cmd)\r\n{\r\nreturn aha1542_reset(cmd, SCRST);\r\n}\r\nstatic int aha1542_host_reset(struct scsi_cmnd *cmd)\r\n{\r\nreturn aha1542_reset(cmd, HRST | SCRST);\r\n}\r\nstatic int aha1542_biosparam(struct scsi_device *sdev,\r\nstruct block_device *bdev, sector_t capacity, int geom[])\r\n{\r\nstruct aha1542_hostdata *aha1542 = shost_priv(sdev->host);\r\nif (capacity >= 0x200000 &&\r\naha1542->bios_translation == BIOS_TRANSLATION_25563) {\r\ngeom[0] = 255;\r\ngeom[1] = 63;\r\n} else {\r\ngeom[0] = 64;\r\ngeom[1] = 32;\r\n}\r\ngeom[2] = sector_div(capacity, geom[0] * geom[1]);\r\nreturn 0;\r\n}\r\nstatic int aha1542_isa_match(struct device *pdev, unsigned int ndev)\r\n{\r\nstruct Scsi_Host *sh = aha1542_hw_init(&driver_template, pdev, ndev);\r\nif (!sh)\r\nreturn 0;\r\ndev_set_drvdata(pdev, sh);\r\nreturn 1;\r\n}\r\nstatic int aha1542_isa_remove(struct device *pdev,\r\nunsigned int ndev)\r\n{\r\naha1542_release(dev_get_drvdata(pdev));\r\ndev_set_drvdata(pdev, NULL);\r\nreturn 0;\r\n}\r\nstatic int aha1542_pnp_probe(struct pnp_dev *pdev, const struct pnp_device_id *id)\r\n{\r\nint indx;\r\nstruct Scsi_Host *sh;\r\nfor (indx = 0; indx < ARRAY_SIZE(io); indx++) {\r\nif (io[indx])\r\ncontinue;\r\nif (pnp_activate_dev(pdev) < 0)\r\ncontinue;\r\nio[indx] = pnp_port_start(pdev, 0);\r\ndev_info(&pdev->dev, "ISAPnP found an AHA1535 at I/O 0x%03X", io[indx]);\r\n}\r\nsh = aha1542_hw_init(&driver_template, &pdev->dev, indx);\r\nif (!sh)\r\nreturn -ENODEV;\r\npnp_set_drvdata(pdev, sh);\r\nreturn 0;\r\n}\r\nstatic void aha1542_pnp_remove(struct pnp_dev *pdev)\r\n{\r\naha1542_release(pnp_get_drvdata(pdev));\r\npnp_set_drvdata(pdev, NULL);\r\n}\r\nstatic int __init aha1542_init(void)\r\n{\r\nint ret = 0;\r\n#ifdef CONFIG_PNP\r\nif (isapnp) {\r\nret = pnp_register_driver(&aha1542_pnp_driver);\r\nif (!ret)\r\npnp_registered = 1;\r\n}\r\n#endif\r\nret = isa_register_driver(&aha1542_isa_driver, MAXBOARDS);\r\nif (!ret)\r\nisa_registered = 1;\r\n#ifdef CONFIG_PNP\r\nif (pnp_registered)\r\nret = 0;\r\n#endif\r\nif (isa_registered)\r\nret = 0;\r\nreturn ret;\r\n}\r\nstatic void __exit aha1542_exit(void)\r\n{\r\n#ifdef CONFIG_PNP\r\nif (pnp_registered)\r\npnp_unregister_driver(&aha1542_pnp_driver);\r\n#endif\r\nif (isa_registered)\r\nisa_unregister_driver(&aha1542_isa_driver);\r\n}
