static ssize_t\r\nat25_ee_read(\r\nstruct at25_data *at25,\r\nchar *buf,\r\nunsigned offset,\r\nsize_t count\r\n)\r\n{\r\nu8 command[EE_MAXADDRLEN + 1];\r\nu8 *cp;\r\nssize_t status;\r\nstruct spi_transfer t[2];\r\nstruct spi_message m;\r\nu8 instr;\r\nif (unlikely(offset >= at25->bin.size))\r\nreturn 0;\r\nif ((offset + count) > at25->bin.size)\r\ncount = at25->bin.size - offset;\r\nif (unlikely(!count))\r\nreturn count;\r\ncp = command;\r\ninstr = AT25_READ;\r\nif (at25->chip.flags & EE_INSTR_BIT3_IS_ADDR)\r\nif (offset >= (1U << (at25->addrlen * 8)))\r\ninstr |= AT25_INSTR_BIT3;\r\n*cp++ = instr;\r\nswitch (at25->addrlen) {\r\ndefault:\r\n*cp++ = offset >> 16;\r\ncase 2:\r\n*cp++ = offset >> 8;\r\ncase 1:\r\ncase 0:\r\n*cp++ = offset >> 0;\r\n}\r\nspi_message_init(&m);\r\nmemset(t, 0, sizeof t);\r\nt[0].tx_buf = command;\r\nt[0].len = at25->addrlen + 1;\r\nspi_message_add_tail(&t[0], &m);\r\nt[1].rx_buf = buf;\r\nt[1].len = count;\r\nspi_message_add_tail(&t[1], &m);\r\nmutex_lock(&at25->lock);\r\nstatus = spi_sync(at25->spi, &m);\r\ndev_dbg(&at25->spi->dev,\r\n"read %Zd bytes at %d --> %d\n",\r\ncount, offset, (int) status);\r\nmutex_unlock(&at25->lock);\r\nreturn status ? status : count;\r\n}\r\nstatic ssize_t\r\nat25_bin_read(struct file *filp, struct kobject *kobj,\r\nstruct bin_attribute *bin_attr,\r\nchar *buf, loff_t off, size_t count)\r\n{\r\nstruct device *dev;\r\nstruct at25_data *at25;\r\ndev = container_of(kobj, struct device, kobj);\r\nat25 = dev_get_drvdata(dev);\r\nreturn at25_ee_read(at25, buf, off, count);\r\n}\r\nstatic ssize_t\r\nat25_ee_write(struct at25_data *at25, const char *buf, loff_t off,\r\nsize_t count)\r\n{\r\nssize_t status = 0;\r\nunsigned written = 0;\r\nunsigned buf_size;\r\nu8 *bounce;\r\nif (unlikely(off >= at25->bin.size))\r\nreturn -EFBIG;\r\nif ((off + count) > at25->bin.size)\r\ncount = at25->bin.size - off;\r\nif (unlikely(!count))\r\nreturn count;\r\nbuf_size = at25->chip.page_size;\r\nif (buf_size > io_limit)\r\nbuf_size = io_limit;\r\nbounce = kmalloc(buf_size + at25->addrlen + 1, GFP_KERNEL);\r\nif (!bounce)\r\nreturn -ENOMEM;\r\nmutex_lock(&at25->lock);\r\ndo {\r\nunsigned long timeout, retries;\r\nunsigned segment;\r\nunsigned offset = (unsigned) off;\r\nu8 *cp = bounce;\r\nint sr;\r\nu8 instr;\r\n*cp = AT25_WREN;\r\nstatus = spi_write(at25->spi, cp, 1);\r\nif (status < 0) {\r\ndev_dbg(&at25->spi->dev, "WREN --> %d\n",\r\n(int) status);\r\nbreak;\r\n}\r\ninstr = AT25_WRITE;\r\nif (at25->chip.flags & EE_INSTR_BIT3_IS_ADDR)\r\nif (offset >= (1U << (at25->addrlen * 8)))\r\ninstr |= AT25_INSTR_BIT3;\r\n*cp++ = instr;\r\nswitch (at25->addrlen) {\r\ndefault:\r\n*cp++ = offset >> 16;\r\ncase 2:\r\n*cp++ = offset >> 8;\r\ncase 1:\r\ncase 0:\r\n*cp++ = offset >> 0;\r\n}\r\nsegment = buf_size - (offset % buf_size);\r\nif (segment > count)\r\nsegment = count;\r\nmemcpy(cp, buf, segment);\r\nstatus = spi_write(at25->spi, bounce,\r\nsegment + at25->addrlen + 1);\r\ndev_dbg(&at25->spi->dev,\r\n"write %u bytes at %u --> %d\n",\r\nsegment, offset, (int) status);\r\nif (status < 0)\r\nbreak;\r\ntimeout = jiffies + msecs_to_jiffies(EE_TIMEOUT);\r\nretries = 0;\r\ndo {\r\nsr = spi_w8r8(at25->spi, AT25_RDSR);\r\nif (sr < 0 || (sr & AT25_SR_nRDY)) {\r\ndev_dbg(&at25->spi->dev,\r\n"rdsr --> %d (%02x)\n", sr, sr);\r\nmsleep(1);\r\ncontinue;\r\n}\r\nif (!(sr & AT25_SR_nRDY))\r\nbreak;\r\n} while (retries++ < 3 || time_before_eq(jiffies, timeout));\r\nif ((sr < 0) || (sr & AT25_SR_nRDY)) {\r\ndev_err(&at25->spi->dev,\r\n"write %d bytes offset %d, "\r\n"timeout after %u msecs\n",\r\nsegment, offset,\r\njiffies_to_msecs(jiffies -\r\n(timeout - EE_TIMEOUT)));\r\nstatus = -ETIMEDOUT;\r\nbreak;\r\n}\r\noff += segment;\r\nbuf += segment;\r\ncount -= segment;\r\nwritten += segment;\r\n} while (count > 0);\r\nmutex_unlock(&at25->lock);\r\nkfree(bounce);\r\nreturn written ? written : status;\r\n}\r\nstatic ssize_t\r\nat25_bin_write(struct file *filp, struct kobject *kobj,\r\nstruct bin_attribute *bin_attr,\r\nchar *buf, loff_t off, size_t count)\r\n{\r\nstruct device *dev;\r\nstruct at25_data *at25;\r\ndev = container_of(kobj, struct device, kobj);\r\nat25 = dev_get_drvdata(dev);\r\nreturn at25_ee_write(at25, buf, off, count);\r\n}\r\nstatic ssize_t at25_mem_read(struct memory_accessor *mem, char *buf,\r\noff_t offset, size_t count)\r\n{\r\nstruct at25_data *at25 = container_of(mem, struct at25_data, mem);\r\nreturn at25_ee_read(at25, buf, offset, count);\r\n}\r\nstatic ssize_t at25_mem_write(struct memory_accessor *mem, const char *buf,\r\noff_t offset, size_t count)\r\n{\r\nstruct at25_data *at25 = container_of(mem, struct at25_data, mem);\r\nreturn at25_ee_write(at25, buf, offset, count);\r\n}\r\nstatic int at25_np_to_chip(struct device *dev,\r\nstruct device_node *np,\r\nstruct spi_eeprom *chip)\r\n{\r\nu32 val;\r\nmemset(chip, 0, sizeof(*chip));\r\nstrncpy(chip->name, np->name, sizeof(chip->name));\r\nif (of_property_read_u32(np, "size", &val) == 0 ||\r\nof_property_read_u32(np, "at25,byte-len", &val) == 0) {\r\nchip->byte_len = val;\r\n} else {\r\ndev_err(dev, "Error: missing \"size\" property\n");\r\nreturn -ENODEV;\r\n}\r\nif (of_property_read_u32(np, "pagesize", &val) == 0 ||\r\nof_property_read_u32(np, "at25,page-size", &val) == 0) {\r\nchip->page_size = (u16)val;\r\n} else {\r\ndev_err(dev, "Error: missing \"pagesize\" property\n");\r\nreturn -ENODEV;\r\n}\r\nif (of_property_read_u32(np, "at25,addr-mode", &val) == 0) {\r\nchip->flags = (u16)val;\r\n} else {\r\nif (of_property_read_u32(np, "address-width", &val)) {\r\ndev_err(dev,\r\n"Error: missing \"address-width\" property\n");\r\nreturn -ENODEV;\r\n}\r\nswitch (val) {\r\ncase 8:\r\nchip->flags |= EE_ADDR1;\r\nbreak;\r\ncase 16:\r\nchip->flags |= EE_ADDR2;\r\nbreak;\r\ncase 24:\r\nchip->flags |= EE_ADDR3;\r\nbreak;\r\ndefault:\r\ndev_err(dev,\r\n"Error: bad \"address-width\" property: %u\n",\r\nval);\r\nreturn -ENODEV;\r\n}\r\nif (of_find_property(np, "read-only", NULL))\r\nchip->flags |= EE_READONLY;\r\n}\r\nreturn 0;\r\n}\r\nstatic int at25_probe(struct spi_device *spi)\r\n{\r\nstruct at25_data *at25 = NULL;\r\nstruct spi_eeprom chip;\r\nstruct device_node *np = spi->dev.of_node;\r\nint err;\r\nint sr;\r\nint addrlen;\r\nif (!spi->dev.platform_data) {\r\nif (np) {\r\nerr = at25_np_to_chip(&spi->dev, np, &chip);\r\nif (err)\r\ngoto fail;\r\n} else {\r\ndev_err(&spi->dev, "Error: no chip description\n");\r\nerr = -ENODEV;\r\ngoto fail;\r\n}\r\n} else\r\nchip = *(struct spi_eeprom *)spi->dev.platform_data;\r\nif (chip.flags & EE_ADDR1)\r\naddrlen = 1;\r\nelse if (chip.flags & EE_ADDR2)\r\naddrlen = 2;\r\nelse if (chip.flags & EE_ADDR3)\r\naddrlen = 3;\r\nelse {\r\ndev_dbg(&spi->dev, "unsupported address type\n");\r\nerr = -EINVAL;\r\ngoto fail;\r\n}\r\nsr = spi_w8r8(spi, AT25_RDSR);\r\nif (sr < 0 || sr & AT25_SR_nRDY) {\r\ndev_dbg(&spi->dev, "rdsr --> %d (%02x)\n", sr, sr);\r\nerr = -ENXIO;\r\ngoto fail;\r\n}\r\nif (!(at25 = kzalloc(sizeof *at25, GFP_KERNEL))) {\r\nerr = -ENOMEM;\r\ngoto fail;\r\n}\r\nmutex_init(&at25->lock);\r\nat25->chip = chip;\r\nat25->spi = spi_dev_get(spi);\r\ndev_set_drvdata(&spi->dev, at25);\r\nat25->addrlen = addrlen;\r\nsysfs_bin_attr_init(&at25->bin);\r\nat25->bin.attr.name = "eeprom";\r\nat25->bin.attr.mode = S_IRUSR;\r\nat25->bin.read = at25_bin_read;\r\nat25->mem.read = at25_mem_read;\r\nat25->bin.size = at25->chip.byte_len;\r\nif (!(chip.flags & EE_READONLY)) {\r\nat25->bin.write = at25_bin_write;\r\nat25->bin.attr.mode |= S_IWUSR;\r\nat25->mem.write = at25_mem_write;\r\n}\r\nerr = sysfs_create_bin_file(&spi->dev.kobj, &at25->bin);\r\nif (err)\r\ngoto fail;\r\nif (chip.setup)\r\nchip.setup(&at25->mem, chip.context);\r\ndev_info(&spi->dev, "%Zd %s %s eeprom%s, pagesize %u\n",\r\n(at25->bin.size < 1024)\r\n? at25->bin.size\r\n: (at25->bin.size / 1024),\r\n(at25->bin.size < 1024) ? "Byte" : "KByte",\r\nat25->chip.name,\r\n(chip.flags & EE_READONLY) ? " (readonly)" : "",\r\nat25->chip.page_size);\r\nreturn 0;\r\nfail:\r\ndev_dbg(&spi->dev, "probe err %d\n", err);\r\nkfree(at25);\r\nreturn err;\r\n}\r\nstatic int at25_remove(struct spi_device *spi)\r\n{\r\nstruct at25_data *at25;\r\nat25 = dev_get_drvdata(&spi->dev);\r\nsysfs_remove_bin_file(&spi->dev.kobj, &at25->bin);\r\nkfree(at25);\r\nreturn 0;\r\n}
