static int radeon_process_aux_ch(struct radeon_i2c_chan *chan,\r\nu8 *send, int send_bytes,\r\nu8 *recv, int recv_size,\r\nu8 delay, u8 *ack)\r\n{\r\nstruct drm_device *dev = chan->dev;\r\nstruct radeon_device *rdev = dev->dev_private;\r\nunion aux_channel_transaction args;\r\nint index = GetIndexIntoMasterTable(COMMAND, ProcessAuxChannelTransaction);\r\nunsigned char *base;\r\nint recv_bytes;\r\nmemset(&args, 0, sizeof(args));\r\nbase = (unsigned char *)(rdev->mode_info.atom_context->scratch + 1);\r\nmemcpy(base, send, send_bytes);\r\nargs.v1.lpAuxRequest = 0 + 4;\r\nargs.v1.lpDataOut = 16 + 4;\r\nargs.v1.ucDataOutLen = 0;\r\nargs.v1.ucChannelID = chan->rec.i2c_id;\r\nargs.v1.ucDelay = delay / 10;\r\nif (ASIC_IS_DCE4(rdev))\r\nargs.v2.ucHPD_ID = chan->rec.hpd;\r\natom_execute_table(rdev->mode_info.atom_context, index, (uint32_t *)&args);\r\n*ack = args.v1.ucReplyStatus;\r\nif (args.v1.ucReplyStatus == 1) {\r\nDRM_DEBUG_KMS("dp_aux_ch timeout\n");\r\nreturn -ETIMEDOUT;\r\n}\r\nif (args.v1.ucReplyStatus == 2) {\r\nDRM_DEBUG_KMS("dp_aux_ch flags not zero\n");\r\nreturn -EBUSY;\r\n}\r\nif (args.v1.ucReplyStatus == 3) {\r\nDRM_DEBUG_KMS("dp_aux_ch error\n");\r\nreturn -EIO;\r\n}\r\nrecv_bytes = args.v1.ucDataOutLen;\r\nif (recv_bytes > recv_size)\r\nrecv_bytes = recv_size;\r\nif (recv && recv_size)\r\nmemcpy(recv, base + 16, recv_bytes);\r\nreturn recv_bytes;\r\n}\r\nstatic int radeon_dp_aux_native_write(struct radeon_connector *radeon_connector,\r\nu16 address, u8 *send, u8 send_bytes, u8 delay)\r\n{\r\nstruct radeon_connector_atom_dig *dig_connector = radeon_connector->con_priv;\r\nint ret;\r\nu8 msg[20];\r\nint msg_bytes = send_bytes + 4;\r\nu8 ack;\r\nunsigned retry;\r\nif (send_bytes > 16)\r\nreturn -1;\r\nmsg[0] = address;\r\nmsg[1] = address >> 8;\r\nmsg[2] = AUX_NATIVE_WRITE << 4;\r\nmsg[3] = (msg_bytes << 4) | (send_bytes - 1);\r\nmemcpy(&msg[4], send, send_bytes);\r\nfor (retry = 0; retry < 4; retry++) {\r\nret = radeon_process_aux_ch(dig_connector->dp_i2c_bus,\r\nmsg, msg_bytes, NULL, 0, delay, &ack);\r\nif (ret == -EBUSY)\r\ncontinue;\r\nelse if (ret < 0)\r\nreturn ret;\r\nif ((ack & AUX_NATIVE_REPLY_MASK) == AUX_NATIVE_REPLY_ACK)\r\nreturn send_bytes;\r\nelse if ((ack & AUX_NATIVE_REPLY_MASK) == AUX_NATIVE_REPLY_DEFER)\r\nudelay(400);\r\nelse\r\nreturn -EIO;\r\n}\r\nreturn -EIO;\r\n}\r\nstatic int radeon_dp_aux_native_read(struct radeon_connector *radeon_connector,\r\nu16 address, u8 *recv, int recv_bytes, u8 delay)\r\n{\r\nstruct radeon_connector_atom_dig *dig_connector = radeon_connector->con_priv;\r\nu8 msg[4];\r\nint msg_bytes = 4;\r\nu8 ack;\r\nint ret;\r\nunsigned retry;\r\nmsg[0] = address;\r\nmsg[1] = address >> 8;\r\nmsg[2] = AUX_NATIVE_READ << 4;\r\nmsg[3] = (msg_bytes << 4) | (recv_bytes - 1);\r\nfor (retry = 0; retry < 4; retry++) {\r\nret = radeon_process_aux_ch(dig_connector->dp_i2c_bus,\r\nmsg, msg_bytes, recv, recv_bytes, delay, &ack);\r\nif (ret == -EBUSY)\r\ncontinue;\r\nelse if (ret < 0)\r\nreturn ret;\r\nif ((ack & AUX_NATIVE_REPLY_MASK) == AUX_NATIVE_REPLY_ACK)\r\nreturn ret;\r\nelse if ((ack & AUX_NATIVE_REPLY_MASK) == AUX_NATIVE_REPLY_DEFER)\r\nudelay(400);\r\nelse if (ret == 0)\r\nreturn -EPROTO;\r\nelse\r\nreturn -EIO;\r\n}\r\nreturn -EIO;\r\n}\r\nstatic void radeon_write_dpcd_reg(struct radeon_connector *radeon_connector,\r\nu16 reg, u8 val)\r\n{\r\nradeon_dp_aux_native_write(radeon_connector, reg, &val, 1, 0);\r\n}\r\nstatic u8 radeon_read_dpcd_reg(struct radeon_connector *radeon_connector,\r\nu16 reg)\r\n{\r\nu8 val = 0;\r\nradeon_dp_aux_native_read(radeon_connector, reg, &val, 1, 0);\r\nreturn val;\r\n}\r\nint radeon_dp_i2c_aux_ch(struct i2c_adapter *adapter, int mode,\r\nu8 write_byte, u8 *read_byte)\r\n{\r\nstruct i2c_algo_dp_aux_data *algo_data = adapter->algo_data;\r\nstruct radeon_i2c_chan *auxch = (struct radeon_i2c_chan *)adapter;\r\nu16 address = algo_data->address;\r\nu8 msg[5];\r\nu8 reply[2];\r\nunsigned retry;\r\nint msg_bytes;\r\nint reply_bytes = 1;\r\nint ret;\r\nu8 ack;\r\nif (mode & MODE_I2C_READ)\r\nmsg[2] = AUX_I2C_READ << 4;\r\nelse\r\nmsg[2] = AUX_I2C_WRITE << 4;\r\nif (!(mode & MODE_I2C_STOP))\r\nmsg[2] |= AUX_I2C_MOT << 4;\r\nmsg[0] = address;\r\nmsg[1] = address >> 8;\r\nswitch (mode) {\r\ncase MODE_I2C_WRITE:\r\nmsg_bytes = 5;\r\nmsg[3] = msg_bytes << 4;\r\nmsg[4] = write_byte;\r\nbreak;\r\ncase MODE_I2C_READ:\r\nmsg_bytes = 4;\r\nmsg[3] = msg_bytes << 4;\r\nbreak;\r\ndefault:\r\nmsg_bytes = 4;\r\nmsg[3] = 3 << 4;\r\nbreak;\r\n}\r\nfor (retry = 0; retry < 4; retry++) {\r\nret = radeon_process_aux_ch(auxch,\r\nmsg, msg_bytes, reply, reply_bytes, 0, &ack);\r\nif (ret == -EBUSY)\r\ncontinue;\r\nelse if (ret < 0) {\r\nDRM_DEBUG_KMS("aux_ch failed %d\n", ret);\r\nreturn ret;\r\n}\r\nswitch (ack & AUX_NATIVE_REPLY_MASK) {\r\ncase AUX_NATIVE_REPLY_ACK:\r\nbreak;\r\ncase AUX_NATIVE_REPLY_NACK:\r\nDRM_DEBUG_KMS("aux_ch native nack\n");\r\nreturn -EREMOTEIO;\r\ncase AUX_NATIVE_REPLY_DEFER:\r\nDRM_DEBUG_KMS("aux_ch native defer\n");\r\nudelay(400);\r\ncontinue;\r\ndefault:\r\nDRM_ERROR("aux_ch invalid native reply 0x%02x\n", ack);\r\nreturn -EREMOTEIO;\r\n}\r\nswitch (ack & AUX_I2C_REPLY_MASK) {\r\ncase AUX_I2C_REPLY_ACK:\r\nif (mode == MODE_I2C_READ)\r\n*read_byte = reply[0];\r\nreturn ret;\r\ncase AUX_I2C_REPLY_NACK:\r\nDRM_DEBUG_KMS("aux_i2c nack\n");\r\nreturn -EREMOTEIO;\r\ncase AUX_I2C_REPLY_DEFER:\r\nDRM_DEBUG_KMS("aux_i2c defer\n");\r\nudelay(400);\r\nbreak;\r\ndefault:\r\nDRM_ERROR("aux_i2c invalid reply 0x%02x\n", ack);\r\nreturn -EREMOTEIO;\r\n}\r\n}\r\nDRM_DEBUG_KMS("aux i2c too many retries, giving up\n");\r\nreturn -EREMOTEIO;\r\n}\r\nstatic void dp_get_adjust_train(u8 link_status[DP_LINK_STATUS_SIZE],\r\nint lane_count,\r\nu8 train_set[4])\r\n{\r\nu8 v = 0;\r\nu8 p = 0;\r\nint lane;\r\nfor (lane = 0; lane < lane_count; lane++) {\r\nu8 this_v = drm_dp_get_adjust_request_voltage(link_status, lane);\r\nu8 this_p = drm_dp_get_adjust_request_pre_emphasis(link_status, lane);\r\nDRM_DEBUG_KMS("requested signal parameters: lane %d voltage %s pre_emph %s\n",\r\nlane,\r\nvoltage_names[this_v >> DP_TRAIN_VOLTAGE_SWING_SHIFT],\r\npre_emph_names[this_p >> DP_TRAIN_PRE_EMPHASIS_SHIFT]);\r\nif (this_v > v)\r\nv = this_v;\r\nif (this_p > p)\r\np = this_p;\r\n}\r\nif (v >= DP_VOLTAGE_MAX)\r\nv |= DP_TRAIN_MAX_SWING_REACHED;\r\nif (p >= DP_PRE_EMPHASIS_MAX)\r\np |= DP_TRAIN_MAX_PRE_EMPHASIS_REACHED;\r\nDRM_DEBUG_KMS("using signal parameters: voltage %s pre_emph %s\n",\r\nvoltage_names[(v & DP_TRAIN_VOLTAGE_SWING_MASK) >> DP_TRAIN_VOLTAGE_SWING_SHIFT],\r\npre_emph_names[(p & DP_TRAIN_PRE_EMPHASIS_MASK) >> DP_TRAIN_PRE_EMPHASIS_SHIFT]);\r\nfor (lane = 0; lane < 4; lane++)\r\ntrain_set[lane] = v | p;\r\n}\r\nstatic int convert_bpc_to_bpp(int bpc)\r\n{\r\nif (bpc == 0)\r\nreturn 24;\r\nelse\r\nreturn bpc * 3;\r\n}\r\nstatic int dp_get_max_dp_pix_clock(int link_rate,\r\nint lane_num,\r\nint bpp)\r\n{\r\nreturn (link_rate * lane_num * 8) / bpp;\r\n}\r\nstatic int radeon_dp_get_dp_lane_number(struct drm_connector *connector,\r\nu8 dpcd[DP_DPCD_SIZE],\r\nint pix_clock)\r\n{\r\nint bpp = convert_bpc_to_bpp(radeon_get_monitor_bpc(connector));\r\nint max_link_rate = drm_dp_max_link_rate(dpcd);\r\nint max_lane_num = drm_dp_max_lane_count(dpcd);\r\nint lane_num;\r\nint max_dp_pix_clock;\r\nfor (lane_num = 1; lane_num < max_lane_num; lane_num <<= 1) {\r\nmax_dp_pix_clock = dp_get_max_dp_pix_clock(max_link_rate, lane_num, bpp);\r\nif (pix_clock <= max_dp_pix_clock)\r\nbreak;\r\n}\r\nreturn lane_num;\r\n}\r\nstatic int radeon_dp_get_dp_link_clock(struct drm_connector *connector,\r\nu8 dpcd[DP_DPCD_SIZE],\r\nint pix_clock)\r\n{\r\nint bpp = convert_bpc_to_bpp(radeon_get_monitor_bpc(connector));\r\nint lane_num, max_pix_clock;\r\nif (radeon_connector_encoder_get_dp_bridge_encoder_id(connector) ==\r\nENCODER_OBJECT_ID_NUTMEG)\r\nreturn 270000;\r\nlane_num = radeon_dp_get_dp_lane_number(connector, dpcd, pix_clock);\r\nmax_pix_clock = dp_get_max_dp_pix_clock(162000, lane_num, bpp);\r\nif (pix_clock <= max_pix_clock)\r\nreturn 162000;\r\nmax_pix_clock = dp_get_max_dp_pix_clock(270000, lane_num, bpp);\r\nif (pix_clock <= max_pix_clock)\r\nreturn 270000;\r\nif (radeon_connector_is_dp12_capable(connector)) {\r\nmax_pix_clock = dp_get_max_dp_pix_clock(540000, lane_num, bpp);\r\nif (pix_clock <= max_pix_clock)\r\nreturn 540000;\r\n}\r\nreturn drm_dp_max_link_rate(dpcd);\r\n}\r\nstatic u8 radeon_dp_encoder_service(struct radeon_device *rdev,\r\nint action, int dp_clock,\r\nu8 ucconfig, u8 lane_num)\r\n{\r\nDP_ENCODER_SERVICE_PARAMETERS args;\r\nint index = GetIndexIntoMasterTable(COMMAND, DPEncoderService);\r\nmemset(&args, 0, sizeof(args));\r\nargs.ucLinkClock = dp_clock / 10;\r\nargs.ucConfig = ucconfig;\r\nargs.ucAction = action;\r\nargs.ucLaneNum = lane_num;\r\nargs.ucStatus = 0;\r\natom_execute_table(rdev->mode_info.atom_context, index, (uint32_t *)&args);\r\nreturn args.ucStatus;\r\n}\r\nu8 radeon_dp_getsinktype(struct radeon_connector *radeon_connector)\r\n{\r\nstruct radeon_connector_atom_dig *dig_connector = radeon_connector->con_priv;\r\nstruct drm_device *dev = radeon_connector->base.dev;\r\nstruct radeon_device *rdev = dev->dev_private;\r\nreturn radeon_dp_encoder_service(rdev, ATOM_DP_ACTION_GET_SINK_TYPE, 0,\r\ndig_connector->dp_i2c_bus->rec.i2c_id, 0);\r\n}\r\nstatic void radeon_dp_probe_oui(struct radeon_connector *radeon_connector)\r\n{\r\nstruct radeon_connector_atom_dig *dig_connector = radeon_connector->con_priv;\r\nu8 buf[3];\r\nif (!(dig_connector->dpcd[DP_DOWN_STREAM_PORT_COUNT] & DP_OUI_SUPPORT))\r\nreturn;\r\nif (radeon_dp_aux_native_read(radeon_connector, DP_SINK_OUI, buf, 3, 0))\r\nDRM_DEBUG_KMS("Sink OUI: %02hx%02hx%02hx\n",\r\nbuf[0], buf[1], buf[2]);\r\nif (radeon_dp_aux_native_read(radeon_connector, DP_BRANCH_OUI, buf, 3, 0))\r\nDRM_DEBUG_KMS("Branch OUI: %02hx%02hx%02hx\n",\r\nbuf[0], buf[1], buf[2]);\r\n}\r\nbool radeon_dp_getdpcd(struct radeon_connector *radeon_connector)\r\n{\r\nstruct radeon_connector_atom_dig *dig_connector = radeon_connector->con_priv;\r\nu8 msg[DP_DPCD_SIZE];\r\nint ret, i;\r\nret = radeon_dp_aux_native_read(radeon_connector, DP_DPCD_REV, msg,\r\nDP_DPCD_SIZE, 0);\r\nif (ret > 0) {\r\nmemcpy(dig_connector->dpcd, msg, DP_DPCD_SIZE);\r\nDRM_DEBUG_KMS("DPCD: ");\r\nfor (i = 0; i < DP_DPCD_SIZE; i++)\r\nDRM_DEBUG_KMS("%02x ", msg[i]);\r\nDRM_DEBUG_KMS("\n");\r\nradeon_dp_probe_oui(radeon_connector);\r\nreturn true;\r\n}\r\ndig_connector->dpcd[0] = 0;\r\nreturn false;\r\n}\r\nint radeon_dp_get_panel_mode(struct drm_encoder *encoder,\r\nstruct drm_connector *connector)\r\n{\r\nstruct drm_device *dev = encoder->dev;\r\nstruct radeon_device *rdev = dev->dev_private;\r\nstruct radeon_connector *radeon_connector = to_radeon_connector(connector);\r\nint panel_mode = DP_PANEL_MODE_EXTERNAL_DP_MODE;\r\nu16 dp_bridge = radeon_connector_encoder_get_dp_bridge_encoder_id(connector);\r\nu8 tmp;\r\nif (!ASIC_IS_DCE4(rdev))\r\nreturn panel_mode;\r\nif (dp_bridge != ENCODER_OBJECT_ID_NONE) {\r\ntmp = radeon_read_dpcd_reg(radeon_connector, DP_EDP_CONFIGURATION_CAP);\r\nif (tmp & 1)\r\npanel_mode = DP_PANEL_MODE_INTERNAL_DP2_MODE;\r\nelse if ((dp_bridge == ENCODER_OBJECT_ID_NUTMEG) ||\r\n(dp_bridge == ENCODER_OBJECT_ID_TRAVIS))\r\npanel_mode = DP_PANEL_MODE_INTERNAL_DP1_MODE;\r\nelse\r\npanel_mode = DP_PANEL_MODE_EXTERNAL_DP_MODE;\r\n} else if (connector->connector_type == DRM_MODE_CONNECTOR_eDP) {\r\ntmp = radeon_read_dpcd_reg(radeon_connector, DP_EDP_CONFIGURATION_CAP);\r\nif (tmp & 1)\r\npanel_mode = DP_PANEL_MODE_INTERNAL_DP2_MODE;\r\n}\r\nreturn panel_mode;\r\n}\r\nvoid radeon_dp_set_link_config(struct drm_connector *connector,\r\nconst struct drm_display_mode *mode)\r\n{\r\nstruct radeon_connector *radeon_connector = to_radeon_connector(connector);\r\nstruct radeon_connector_atom_dig *dig_connector;\r\nif (!radeon_connector->con_priv)\r\nreturn;\r\ndig_connector = radeon_connector->con_priv;\r\nif ((dig_connector->dp_sink_type == CONNECTOR_OBJECT_ID_DISPLAYPORT) ||\r\n(dig_connector->dp_sink_type == CONNECTOR_OBJECT_ID_eDP)) {\r\ndig_connector->dp_clock =\r\nradeon_dp_get_dp_link_clock(connector, dig_connector->dpcd, mode->clock);\r\ndig_connector->dp_lane_count =\r\nradeon_dp_get_dp_lane_number(connector, dig_connector->dpcd, mode->clock);\r\n}\r\n}\r\nint radeon_dp_mode_valid_helper(struct drm_connector *connector,\r\nstruct drm_display_mode *mode)\r\n{\r\nstruct radeon_connector *radeon_connector = to_radeon_connector(connector);\r\nstruct radeon_connector_atom_dig *dig_connector;\r\nint dp_clock;\r\nif (!radeon_connector->con_priv)\r\nreturn MODE_CLOCK_HIGH;\r\ndig_connector = radeon_connector->con_priv;\r\ndp_clock =\r\nradeon_dp_get_dp_link_clock(connector, dig_connector->dpcd, mode->clock);\r\nif ((dp_clock == 540000) &&\r\n(!radeon_connector_is_dp12_capable(connector)))\r\nreturn MODE_CLOCK_HIGH;\r\nreturn MODE_OK;\r\n}\r\nstatic bool radeon_dp_get_link_status(struct radeon_connector *radeon_connector,\r\nu8 link_status[DP_LINK_STATUS_SIZE])\r\n{\r\nint ret;\r\nret = radeon_dp_aux_native_read(radeon_connector, DP_LANE0_1_STATUS,\r\nlink_status, DP_LINK_STATUS_SIZE, 100);\r\nif (ret <= 0) {\r\nreturn false;\r\n}\r\nDRM_DEBUG_KMS("link status %*ph\n", 6, link_status);\r\nreturn true;\r\n}\r\nbool radeon_dp_needs_link_train(struct radeon_connector *radeon_connector)\r\n{\r\nu8 link_status[DP_LINK_STATUS_SIZE];\r\nstruct radeon_connector_atom_dig *dig = radeon_connector->con_priv;\r\nif (!radeon_dp_get_link_status(radeon_connector, link_status))\r\nreturn false;\r\nif (drm_dp_channel_eq_ok(link_status, dig->dp_lane_count))\r\nreturn false;\r\nreturn true;\r\n}\r\nstatic void radeon_dp_update_vs_emph(struct radeon_dp_link_train_info *dp_info)\r\n{\r\natombios_dig_transmitter_setup(dp_info->encoder,\r\nATOM_TRANSMITTER_ACTION_SETUP_VSEMPH,\r\n0, dp_info->train_set[0]);\r\nradeon_dp_aux_native_write(dp_info->radeon_connector, DP_TRAINING_LANE0_SET,\r\ndp_info->train_set, dp_info->dp_lane_count, 0);\r\n}\r\nstatic void radeon_dp_set_tp(struct radeon_dp_link_train_info *dp_info, int tp)\r\n{\r\nint rtp = 0;\r\nif (ASIC_IS_DCE4(dp_info->rdev) || !dp_info->use_dpencoder) {\r\nswitch (tp) {\r\ncase DP_TRAINING_PATTERN_1:\r\nrtp = ATOM_ENCODER_CMD_DP_LINK_TRAINING_PATTERN1;\r\nbreak;\r\ncase DP_TRAINING_PATTERN_2:\r\nrtp = ATOM_ENCODER_CMD_DP_LINK_TRAINING_PATTERN2;\r\nbreak;\r\ncase DP_TRAINING_PATTERN_3:\r\nrtp = ATOM_ENCODER_CMD_DP_LINK_TRAINING_PATTERN3;\r\nbreak;\r\n}\r\natombios_dig_encoder_setup(dp_info->encoder, rtp, 0);\r\n} else {\r\nswitch (tp) {\r\ncase DP_TRAINING_PATTERN_1:\r\nrtp = 0;\r\nbreak;\r\ncase DP_TRAINING_PATTERN_2:\r\nrtp = 1;\r\nbreak;\r\n}\r\nradeon_dp_encoder_service(dp_info->rdev, ATOM_DP_ACTION_TRAINING_PATTERN_SEL,\r\ndp_info->dp_clock, dp_info->enc_id, rtp);\r\n}\r\nradeon_write_dpcd_reg(dp_info->radeon_connector, DP_TRAINING_PATTERN_SET, tp);\r\n}\r\nstatic int radeon_dp_link_train_init(struct radeon_dp_link_train_info *dp_info)\r\n{\r\nstruct radeon_encoder *radeon_encoder = to_radeon_encoder(dp_info->encoder);\r\nstruct radeon_encoder_atom_dig *dig = radeon_encoder->enc_priv;\r\nu8 tmp;\r\nif (dp_info->dpcd[0] >= 0x11)\r\nradeon_write_dpcd_reg(dp_info->radeon_connector,\r\nDP_SET_POWER, DP_SET_POWER_D0);\r\nif (dp_info->dpcd[3] & 0x1)\r\nradeon_write_dpcd_reg(dp_info->radeon_connector,\r\nDP_DOWNSPREAD_CTRL, DP_SPREAD_AMP_0_5);\r\nelse\r\nradeon_write_dpcd_reg(dp_info->radeon_connector,\r\nDP_DOWNSPREAD_CTRL, 0);\r\nif ((dp_info->connector->connector_type == DRM_MODE_CONNECTOR_eDP) &&\r\n(dig->panel_mode == DP_PANEL_MODE_INTERNAL_DP2_MODE)) {\r\nradeon_write_dpcd_reg(dp_info->radeon_connector, DP_EDP_CONFIGURATION_SET, 1);\r\n}\r\ntmp = dp_info->dp_lane_count;\r\nif (dp_info->dpcd[DP_DPCD_REV] >= 0x11 &&\r\ndp_info->dpcd[DP_MAX_LANE_COUNT] & DP_ENHANCED_FRAME_CAP)\r\ntmp |= DP_LANE_COUNT_ENHANCED_FRAME_EN;\r\nradeon_write_dpcd_reg(dp_info->radeon_connector, DP_LANE_COUNT_SET, tmp);\r\ntmp = drm_dp_link_rate_to_bw_code(dp_info->dp_clock);\r\nradeon_write_dpcd_reg(dp_info->radeon_connector, DP_LINK_BW_SET, tmp);\r\nif (ASIC_IS_DCE4(dp_info->rdev) || !dp_info->use_dpencoder)\r\natombios_dig_encoder_setup(dp_info->encoder,\r\nATOM_ENCODER_CMD_DP_LINK_TRAINING_START, 0);\r\nelse\r\nradeon_dp_encoder_service(dp_info->rdev, ATOM_DP_ACTION_TRAINING_START,\r\ndp_info->dp_clock, dp_info->enc_id, 0);\r\nradeon_write_dpcd_reg(dp_info->radeon_connector,\r\nDP_TRAINING_PATTERN_SET,\r\nDP_TRAINING_PATTERN_DISABLE);\r\nreturn 0;\r\n}\r\nstatic int radeon_dp_link_train_finish(struct radeon_dp_link_train_info *dp_info)\r\n{\r\nudelay(400);\r\nradeon_write_dpcd_reg(dp_info->radeon_connector,\r\nDP_TRAINING_PATTERN_SET,\r\nDP_TRAINING_PATTERN_DISABLE);\r\nif (ASIC_IS_DCE4(dp_info->rdev) || !dp_info->use_dpencoder)\r\natombios_dig_encoder_setup(dp_info->encoder,\r\nATOM_ENCODER_CMD_DP_LINK_TRAINING_COMPLETE, 0);\r\nelse\r\nradeon_dp_encoder_service(dp_info->rdev, ATOM_DP_ACTION_TRAINING_COMPLETE,\r\ndp_info->dp_clock, dp_info->enc_id, 0);\r\nreturn 0;\r\n}\r\nstatic int radeon_dp_link_train_cr(struct radeon_dp_link_train_info *dp_info)\r\n{\r\nbool clock_recovery;\r\nu8 voltage;\r\nint i;\r\nradeon_dp_set_tp(dp_info, DP_TRAINING_PATTERN_1);\r\nmemset(dp_info->train_set, 0, 4);\r\nradeon_dp_update_vs_emph(dp_info);\r\nudelay(400);\r\nclock_recovery = false;\r\ndp_info->tries = 0;\r\nvoltage = 0xff;\r\nwhile (1) {\r\ndrm_dp_link_train_clock_recovery_delay(dp_info->dpcd);\r\nif (!radeon_dp_get_link_status(dp_info->radeon_connector, dp_info->link_status)) {\r\nDRM_ERROR("displayport link status failed\n");\r\nbreak;\r\n}\r\nif (drm_dp_clock_recovery_ok(dp_info->link_status, dp_info->dp_lane_count)) {\r\nclock_recovery = true;\r\nbreak;\r\n}\r\nfor (i = 0; i < dp_info->dp_lane_count; i++) {\r\nif ((dp_info->train_set[i] & DP_TRAIN_MAX_SWING_REACHED) == 0)\r\nbreak;\r\n}\r\nif (i == dp_info->dp_lane_count) {\r\nDRM_ERROR("clock recovery reached max voltage\n");\r\nbreak;\r\n}\r\nif ((dp_info->train_set[0] & DP_TRAIN_VOLTAGE_SWING_MASK) == voltage) {\r\n++dp_info->tries;\r\nif (dp_info->tries == 5) {\r\nDRM_ERROR("clock recovery tried 5 times\n");\r\nbreak;\r\n}\r\n} else\r\ndp_info->tries = 0;\r\nvoltage = dp_info->train_set[0] & DP_TRAIN_VOLTAGE_SWING_MASK;\r\ndp_get_adjust_train(dp_info->link_status, dp_info->dp_lane_count, dp_info->train_set);\r\nradeon_dp_update_vs_emph(dp_info);\r\n}\r\nif (!clock_recovery) {\r\nDRM_ERROR("clock recovery failed\n");\r\nreturn -1;\r\n} else {\r\nDRM_DEBUG_KMS("clock recovery at voltage %d pre-emphasis %d\n",\r\ndp_info->train_set[0] & DP_TRAIN_VOLTAGE_SWING_MASK,\r\n(dp_info->train_set[0] & DP_TRAIN_PRE_EMPHASIS_MASK) >>\r\nDP_TRAIN_PRE_EMPHASIS_SHIFT);\r\nreturn 0;\r\n}\r\n}\r\nstatic int radeon_dp_link_train_ce(struct radeon_dp_link_train_info *dp_info)\r\n{\r\nbool channel_eq;\r\nif (dp_info->tp3_supported)\r\nradeon_dp_set_tp(dp_info, DP_TRAINING_PATTERN_3);\r\nelse\r\nradeon_dp_set_tp(dp_info, DP_TRAINING_PATTERN_2);\r\ndp_info->tries = 0;\r\nchannel_eq = false;\r\nwhile (1) {\r\ndrm_dp_link_train_channel_eq_delay(dp_info->dpcd);\r\nif (!radeon_dp_get_link_status(dp_info->radeon_connector, dp_info->link_status)) {\r\nDRM_ERROR("displayport link status failed\n");\r\nbreak;\r\n}\r\nif (drm_dp_channel_eq_ok(dp_info->link_status, dp_info->dp_lane_count)) {\r\nchannel_eq = true;\r\nbreak;\r\n}\r\nif (dp_info->tries > 5) {\r\nDRM_ERROR("channel eq failed: 5 tries\n");\r\nbreak;\r\n}\r\ndp_get_adjust_train(dp_info->link_status, dp_info->dp_lane_count, dp_info->train_set);\r\nradeon_dp_update_vs_emph(dp_info);\r\ndp_info->tries++;\r\n}\r\nif (!channel_eq) {\r\nDRM_ERROR("channel eq failed\n");\r\nreturn -1;\r\n} else {\r\nDRM_DEBUG_KMS("channel eq at voltage %d pre-emphasis %d\n",\r\ndp_info->train_set[0] & DP_TRAIN_VOLTAGE_SWING_MASK,\r\n(dp_info->train_set[0] & DP_TRAIN_PRE_EMPHASIS_MASK)\r\n>> DP_TRAIN_PRE_EMPHASIS_SHIFT);\r\nreturn 0;\r\n}\r\n}\r\nvoid radeon_dp_link_train(struct drm_encoder *encoder,\r\nstruct drm_connector *connector)\r\n{\r\nstruct drm_device *dev = encoder->dev;\r\nstruct radeon_device *rdev = dev->dev_private;\r\nstruct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);\r\nstruct radeon_encoder_atom_dig *dig;\r\nstruct radeon_connector *radeon_connector;\r\nstruct radeon_connector_atom_dig *dig_connector;\r\nstruct radeon_dp_link_train_info dp_info;\r\nint index;\r\nu8 tmp, frev, crev;\r\nif (!radeon_encoder->enc_priv)\r\nreturn;\r\ndig = radeon_encoder->enc_priv;\r\nradeon_connector = to_radeon_connector(connector);\r\nif (!radeon_connector->con_priv)\r\nreturn;\r\ndig_connector = radeon_connector->con_priv;\r\nif ((dig_connector->dp_sink_type != CONNECTOR_OBJECT_ID_DISPLAYPORT) &&\r\n(dig_connector->dp_sink_type != CONNECTOR_OBJECT_ID_eDP))\r\nreturn;\r\ndp_info.use_dpencoder = true;\r\nindex = GetIndexIntoMasterTable(COMMAND, DPEncoderService);\r\nif (atom_parse_cmd_header(rdev->mode_info.atom_context, index, &frev, &crev)) {\r\nif (crev > 1) {\r\ndp_info.use_dpencoder = false;\r\n}\r\n}\r\ndp_info.enc_id = 0;\r\nif (dig->dig_encoder)\r\ndp_info.enc_id |= ATOM_DP_CONFIG_DIG2_ENCODER;\r\nelse\r\ndp_info.enc_id |= ATOM_DP_CONFIG_DIG1_ENCODER;\r\nif (dig->linkb)\r\ndp_info.enc_id |= ATOM_DP_CONFIG_LINK_B;\r\nelse\r\ndp_info.enc_id |= ATOM_DP_CONFIG_LINK_A;\r\ntmp = radeon_read_dpcd_reg(radeon_connector, DP_MAX_LANE_COUNT);\r\nif (ASIC_IS_DCE5(rdev) && (tmp & DP_TPS3_SUPPORTED))\r\ndp_info.tp3_supported = true;\r\nelse\r\ndp_info.tp3_supported = false;\r\nmemcpy(dp_info.dpcd, dig_connector->dpcd, DP_RECEIVER_CAP_SIZE);\r\ndp_info.rdev = rdev;\r\ndp_info.encoder = encoder;\r\ndp_info.connector = connector;\r\ndp_info.radeon_connector = radeon_connector;\r\ndp_info.dp_lane_count = dig_connector->dp_lane_count;\r\ndp_info.dp_clock = dig_connector->dp_clock;\r\nif (radeon_dp_link_train_init(&dp_info))\r\ngoto done;\r\nif (radeon_dp_link_train_cr(&dp_info))\r\ngoto done;\r\nif (radeon_dp_link_train_ce(&dp_info))\r\ngoto done;\r\ndone:\r\nif (radeon_dp_link_train_finish(&dp_info))\r\nreturn;\r\n}
