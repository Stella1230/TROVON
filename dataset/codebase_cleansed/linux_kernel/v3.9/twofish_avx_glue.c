static inline void twofish_enc_blk_3way(struct twofish_ctx *ctx, u8 *dst,\r\nconst u8 *src)\r\n{\r\n__twofish_enc_blk_3way(ctx, dst, src, false);\r\n}\r\nstatic int ecb_encrypt(struct blkcipher_desc *desc, struct scatterlist *dst,\r\nstruct scatterlist *src, unsigned int nbytes)\r\n{\r\nreturn glue_ecb_crypt_128bit(&twofish_enc, desc, dst, src, nbytes);\r\n}\r\nstatic int ecb_decrypt(struct blkcipher_desc *desc, struct scatterlist *dst,\r\nstruct scatterlist *src, unsigned int nbytes)\r\n{\r\nreturn glue_ecb_crypt_128bit(&twofish_dec, desc, dst, src, nbytes);\r\n}\r\nstatic int cbc_encrypt(struct blkcipher_desc *desc, struct scatterlist *dst,\r\nstruct scatterlist *src, unsigned int nbytes)\r\n{\r\nreturn glue_cbc_encrypt_128bit(GLUE_FUNC_CAST(twofish_enc_blk), desc,\r\ndst, src, nbytes);\r\n}\r\nstatic int cbc_decrypt(struct blkcipher_desc *desc, struct scatterlist *dst,\r\nstruct scatterlist *src, unsigned int nbytes)\r\n{\r\nreturn glue_cbc_decrypt_128bit(&twofish_dec_cbc, desc, dst, src,\r\nnbytes);\r\n}\r\nstatic int ctr_crypt(struct blkcipher_desc *desc, struct scatterlist *dst,\r\nstruct scatterlist *src, unsigned int nbytes)\r\n{\r\nreturn glue_ctr_crypt_128bit(&twofish_ctr, desc, dst, src, nbytes);\r\n}\r\nstatic inline bool twofish_fpu_begin(bool fpu_enabled, unsigned int nbytes)\r\n{\r\nreturn glue_fpu_begin(TF_BLOCK_SIZE, TWOFISH_PARALLEL_BLOCKS, NULL,\r\nfpu_enabled, nbytes);\r\n}\r\nstatic inline void twofish_fpu_end(bool fpu_enabled)\r\n{\r\nglue_fpu_end(fpu_enabled);\r\n}\r\nstatic void encrypt_callback(void *priv, u8 *srcdst, unsigned int nbytes)\r\n{\r\nconst unsigned int bsize = TF_BLOCK_SIZE;\r\nstruct crypt_priv *ctx = priv;\r\nint i;\r\nctx->fpu_enabled = twofish_fpu_begin(ctx->fpu_enabled, nbytes);\r\nif (nbytes == bsize * TWOFISH_PARALLEL_BLOCKS) {\r\ntwofish_ecb_enc_8way(ctx->ctx, srcdst, srcdst);\r\nreturn;\r\n}\r\nfor (i = 0; i < nbytes / (bsize * 3); i++, srcdst += bsize * 3)\r\ntwofish_enc_blk_3way(ctx->ctx, srcdst, srcdst);\r\nnbytes %= bsize * 3;\r\nfor (i = 0; i < nbytes / bsize; i++, srcdst += bsize)\r\ntwofish_enc_blk(ctx->ctx, srcdst, srcdst);\r\n}\r\nstatic void decrypt_callback(void *priv, u8 *srcdst, unsigned int nbytes)\r\n{\r\nconst unsigned int bsize = TF_BLOCK_SIZE;\r\nstruct crypt_priv *ctx = priv;\r\nint i;\r\nctx->fpu_enabled = twofish_fpu_begin(ctx->fpu_enabled, nbytes);\r\nif (nbytes == bsize * TWOFISH_PARALLEL_BLOCKS) {\r\ntwofish_ecb_dec_8way(ctx->ctx, srcdst, srcdst);\r\nreturn;\r\n}\r\nfor (i = 0; i < nbytes / (bsize * 3); i++, srcdst += bsize * 3)\r\ntwofish_dec_blk_3way(ctx->ctx, srcdst, srcdst);\r\nnbytes %= bsize * 3;\r\nfor (i = 0; i < nbytes / bsize; i++, srcdst += bsize)\r\ntwofish_dec_blk(ctx->ctx, srcdst, srcdst);\r\n}\r\nstatic int lrw_encrypt(struct blkcipher_desc *desc, struct scatterlist *dst,\r\nstruct scatterlist *src, unsigned int nbytes)\r\n{\r\nstruct twofish_lrw_ctx *ctx = crypto_blkcipher_ctx(desc->tfm);\r\nbe128 buf[TWOFISH_PARALLEL_BLOCKS];\r\nstruct crypt_priv crypt_ctx = {\r\n.ctx = &ctx->twofish_ctx,\r\n.fpu_enabled = false,\r\n};\r\nstruct lrw_crypt_req req = {\r\n.tbuf = buf,\r\n.tbuflen = sizeof(buf),\r\n.table_ctx = &ctx->lrw_table,\r\n.crypt_ctx = &crypt_ctx,\r\n.crypt_fn = encrypt_callback,\r\n};\r\nint ret;\r\ndesc->flags &= ~CRYPTO_TFM_REQ_MAY_SLEEP;\r\nret = lrw_crypt(desc, dst, src, nbytes, &req);\r\ntwofish_fpu_end(crypt_ctx.fpu_enabled);\r\nreturn ret;\r\n}\r\nstatic int lrw_decrypt(struct blkcipher_desc *desc, struct scatterlist *dst,\r\nstruct scatterlist *src, unsigned int nbytes)\r\n{\r\nstruct twofish_lrw_ctx *ctx = crypto_blkcipher_ctx(desc->tfm);\r\nbe128 buf[TWOFISH_PARALLEL_BLOCKS];\r\nstruct crypt_priv crypt_ctx = {\r\n.ctx = &ctx->twofish_ctx,\r\n.fpu_enabled = false,\r\n};\r\nstruct lrw_crypt_req req = {\r\n.tbuf = buf,\r\n.tbuflen = sizeof(buf),\r\n.table_ctx = &ctx->lrw_table,\r\n.crypt_ctx = &crypt_ctx,\r\n.crypt_fn = decrypt_callback,\r\n};\r\nint ret;\r\ndesc->flags &= ~CRYPTO_TFM_REQ_MAY_SLEEP;\r\nret = lrw_crypt(desc, dst, src, nbytes, &req);\r\ntwofish_fpu_end(crypt_ctx.fpu_enabled);\r\nreturn ret;\r\n}\r\nstatic int xts_encrypt(struct blkcipher_desc *desc, struct scatterlist *dst,\r\nstruct scatterlist *src, unsigned int nbytes)\r\n{\r\nstruct twofish_xts_ctx *ctx = crypto_blkcipher_ctx(desc->tfm);\r\nbe128 buf[TWOFISH_PARALLEL_BLOCKS];\r\nstruct crypt_priv crypt_ctx = {\r\n.ctx = &ctx->crypt_ctx,\r\n.fpu_enabled = false,\r\n};\r\nstruct xts_crypt_req req = {\r\n.tbuf = buf,\r\n.tbuflen = sizeof(buf),\r\n.tweak_ctx = &ctx->tweak_ctx,\r\n.tweak_fn = XTS_TWEAK_CAST(twofish_enc_blk),\r\n.crypt_ctx = &crypt_ctx,\r\n.crypt_fn = encrypt_callback,\r\n};\r\nint ret;\r\ndesc->flags &= ~CRYPTO_TFM_REQ_MAY_SLEEP;\r\nret = xts_crypt(desc, dst, src, nbytes, &req);\r\ntwofish_fpu_end(crypt_ctx.fpu_enabled);\r\nreturn ret;\r\n}\r\nstatic int xts_decrypt(struct blkcipher_desc *desc, struct scatterlist *dst,\r\nstruct scatterlist *src, unsigned int nbytes)\r\n{\r\nstruct twofish_xts_ctx *ctx = crypto_blkcipher_ctx(desc->tfm);\r\nbe128 buf[TWOFISH_PARALLEL_BLOCKS];\r\nstruct crypt_priv crypt_ctx = {\r\n.ctx = &ctx->crypt_ctx,\r\n.fpu_enabled = false,\r\n};\r\nstruct xts_crypt_req req = {\r\n.tbuf = buf,\r\n.tbuflen = sizeof(buf),\r\n.tweak_ctx = &ctx->tweak_ctx,\r\n.tweak_fn = XTS_TWEAK_CAST(twofish_enc_blk),\r\n.crypt_ctx = &crypt_ctx,\r\n.crypt_fn = decrypt_callback,\r\n};\r\nint ret;\r\ndesc->flags &= ~CRYPTO_TFM_REQ_MAY_SLEEP;\r\nret = xts_crypt(desc, dst, src, nbytes, &req);\r\ntwofish_fpu_end(crypt_ctx.fpu_enabled);\r\nreturn ret;\r\n}\r\nstatic int __init twofish_init(void)\r\n{\r\nu64 xcr0;\r\nif (!cpu_has_avx || !cpu_has_osxsave) {\r\nprintk(KERN_INFO "AVX instructions are not detected.\n");\r\nreturn -ENODEV;\r\n}\r\nxcr0 = xgetbv(XCR_XFEATURE_ENABLED_MASK);\r\nif ((xcr0 & (XSTATE_SSE | XSTATE_YMM)) != (XSTATE_SSE | XSTATE_YMM)) {\r\nprintk(KERN_INFO "AVX detected but unusable.\n");\r\nreturn -ENODEV;\r\n}\r\nreturn crypto_register_algs(twofish_algs, ARRAY_SIZE(twofish_algs));\r\n}\r\nstatic void __exit twofish_exit(void)\r\n{\r\ncrypto_unregister_algs(twofish_algs, ARRAY_SIZE(twofish_algs));\r\n}
