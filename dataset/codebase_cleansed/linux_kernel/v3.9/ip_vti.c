static struct rtnl_link_stats64 *vti_get_stats64(struct net_device *dev,\r\nstruct rtnl_link_stats64 *tot)\r\n{\r\nint i;\r\nfor_each_possible_cpu(i) {\r\nconst struct pcpu_tstats *tstats = per_cpu_ptr(dev->tstats, i);\r\nu64 rx_packets, rx_bytes, tx_packets, tx_bytes;\r\nunsigned int start;\r\ndo {\r\nstart = u64_stats_fetch_begin_bh(&tstats->syncp);\r\nrx_packets = tstats->rx_packets;\r\ntx_packets = tstats->tx_packets;\r\nrx_bytes = tstats->rx_bytes;\r\ntx_bytes = tstats->tx_bytes;\r\n} while (u64_stats_fetch_retry_bh(&tstats->syncp, start));\r\ntot->rx_packets += rx_packets;\r\ntot->tx_packets += tx_packets;\r\ntot->rx_bytes += rx_bytes;\r\ntot->tx_bytes += tx_bytes;\r\n}\r\ntot->multicast = dev->stats.multicast;\r\ntot->rx_crc_errors = dev->stats.rx_crc_errors;\r\ntot->rx_fifo_errors = dev->stats.rx_fifo_errors;\r\ntot->rx_length_errors = dev->stats.rx_length_errors;\r\ntot->rx_errors = dev->stats.rx_errors;\r\ntot->tx_fifo_errors = dev->stats.tx_fifo_errors;\r\ntot->tx_carrier_errors = dev->stats.tx_carrier_errors;\r\ntot->tx_dropped = dev->stats.tx_dropped;\r\ntot->tx_aborted_errors = dev->stats.tx_aborted_errors;\r\ntot->tx_errors = dev->stats.tx_errors;\r\nreturn tot;\r\n}\r\nstatic struct ip_tunnel *vti_tunnel_lookup(struct net *net,\r\n__be32 remote, __be32 local)\r\n{\r\nunsigned h0 = HASH(remote);\r\nunsigned h1 = HASH(local);\r\nstruct ip_tunnel *t;\r\nstruct vti_net *ipn = net_generic(net, vti_net_id);\r\nfor_each_ip_tunnel_rcu(t, ipn->tunnels_r_l[h0 ^ h1])\r\nif (local == t->parms.iph.saddr &&\r\nremote == t->parms.iph.daddr && (t->dev->flags&IFF_UP))\r\nreturn t;\r\nfor_each_ip_tunnel_rcu(t, ipn->tunnels_r[h0])\r\nif (remote == t->parms.iph.daddr && (t->dev->flags&IFF_UP))\r\nreturn t;\r\nfor_each_ip_tunnel_rcu(t, ipn->tunnels_l[h1])\r\nif (local == t->parms.iph.saddr && (t->dev->flags&IFF_UP))\r\nreturn t;\r\nfor_each_ip_tunnel_rcu(t, ipn->tunnels_wc[0])\r\nif (t && (t->dev->flags&IFF_UP))\r\nreturn t;\r\nreturn NULL;\r\n}\r\nstatic struct ip_tunnel __rcu **__vti_bucket(struct vti_net *ipn,\r\nstruct ip_tunnel_parm *parms)\r\n{\r\n__be32 remote = parms->iph.daddr;\r\n__be32 local = parms->iph.saddr;\r\nunsigned h = 0;\r\nint prio = 0;\r\nif (remote) {\r\nprio |= 2;\r\nh ^= HASH(remote);\r\n}\r\nif (local) {\r\nprio |= 1;\r\nh ^= HASH(local);\r\n}\r\nreturn &ipn->tunnels[prio][h];\r\n}\r\nstatic inline struct ip_tunnel __rcu **vti_bucket(struct vti_net *ipn,\r\nstruct ip_tunnel *t)\r\n{\r\nreturn __vti_bucket(ipn, &t->parms);\r\n}\r\nstatic void vti_tunnel_unlink(struct vti_net *ipn, struct ip_tunnel *t)\r\n{\r\nstruct ip_tunnel __rcu **tp;\r\nstruct ip_tunnel *iter;\r\nfor (tp = vti_bucket(ipn, t);\r\n(iter = rtnl_dereference(*tp)) != NULL;\r\ntp = &iter->next) {\r\nif (t == iter) {\r\nrcu_assign_pointer(*tp, t->next);\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic void vti_tunnel_link(struct vti_net *ipn, struct ip_tunnel *t)\r\n{\r\nstruct ip_tunnel __rcu **tp = vti_bucket(ipn, t);\r\nrcu_assign_pointer(t->next, rtnl_dereference(*tp));\r\nrcu_assign_pointer(*tp, t);\r\n}\r\nstatic struct ip_tunnel *vti_tunnel_locate(struct net *net,\r\nstruct ip_tunnel_parm *parms,\r\nint create)\r\n{\r\n__be32 remote = parms->iph.daddr;\r\n__be32 local = parms->iph.saddr;\r\nstruct ip_tunnel *t, *nt;\r\nstruct ip_tunnel __rcu **tp;\r\nstruct net_device *dev;\r\nchar name[IFNAMSIZ];\r\nstruct vti_net *ipn = net_generic(net, vti_net_id);\r\nfor (tp = __vti_bucket(ipn, parms);\r\n(t = rtnl_dereference(*tp)) != NULL;\r\ntp = &t->next) {\r\nif (local == t->parms.iph.saddr && remote == t->parms.iph.daddr)\r\nreturn t;\r\n}\r\nif (!create)\r\nreturn NULL;\r\nif (parms->name[0])\r\nstrlcpy(name, parms->name, IFNAMSIZ);\r\nelse\r\nstrcpy(name, "vti%d");\r\ndev = alloc_netdev(sizeof(*t), name, vti_tunnel_setup);\r\nif (dev == NULL)\r\nreturn NULL;\r\ndev_net_set(dev, net);\r\nnt = netdev_priv(dev);\r\nnt->parms = *parms;\r\ndev->rtnl_link_ops = &vti_link_ops;\r\nvti_tunnel_bind_dev(dev);\r\nif (register_netdevice(dev) < 0)\r\ngoto failed_free;\r\ndev_hold(dev);\r\nvti_tunnel_link(ipn, nt);\r\nreturn nt;\r\nfailed_free:\r\nfree_netdev(dev);\r\nreturn NULL;\r\n}\r\nstatic void vti_tunnel_uninit(struct net_device *dev)\r\n{\r\nstruct net *net = dev_net(dev);\r\nstruct vti_net *ipn = net_generic(net, vti_net_id);\r\nvti_tunnel_unlink(ipn, netdev_priv(dev));\r\ndev_put(dev);\r\n}\r\nstatic int vti_err(struct sk_buff *skb, u32 info)\r\n{\r\nstruct iphdr *iph = (struct iphdr *)skb->data;\r\nconst int type = icmp_hdr(skb)->type;\r\nconst int code = icmp_hdr(skb)->code;\r\nstruct ip_tunnel *t;\r\nint err;\r\nswitch (type) {\r\ndefault:\r\ncase ICMP_PARAMETERPROB:\r\nreturn 0;\r\ncase ICMP_DEST_UNREACH:\r\nswitch (code) {\r\ncase ICMP_SR_FAILED:\r\ncase ICMP_PORT_UNREACH:\r\nreturn 0;\r\ndefault:\r\nbreak;\r\n}\r\nbreak;\r\ncase ICMP_TIME_EXCEEDED:\r\nif (code != ICMP_EXC_TTL)\r\nreturn 0;\r\nbreak;\r\n}\r\nerr = -ENOENT;\r\nt = vti_tunnel_lookup(dev_net(skb->dev), iph->daddr, iph->saddr);\r\nif (t == NULL)\r\ngoto out;\r\nif (type == ICMP_DEST_UNREACH && code == ICMP_FRAG_NEEDED) {\r\nipv4_update_pmtu(skb, dev_net(skb->dev), info,\r\nt->parms.link, 0, IPPROTO_IPIP, 0);\r\nerr = 0;\r\ngoto out;\r\n}\r\nerr = 0;\r\nif (t->parms.iph.ttl == 0 && type == ICMP_TIME_EXCEEDED)\r\ngoto out;\r\nif (time_before(jiffies, t->err_time + IPTUNNEL_ERR_TIMEO))\r\nt->err_count++;\r\nelse\r\nt->err_count = 1;\r\nt->err_time = jiffies;\r\nout:\r\nreturn err;\r\n}\r\nstatic int vti_rcv(struct sk_buff *skb)\r\n{\r\nstruct ip_tunnel *tunnel;\r\nconst struct iphdr *iph = ip_hdr(skb);\r\ntunnel = vti_tunnel_lookup(dev_net(skb->dev), iph->saddr, iph->daddr);\r\nif (tunnel != NULL) {\r\nstruct pcpu_tstats *tstats;\r\nif (!xfrm4_policy_check(NULL, XFRM_POLICY_IN, skb))\r\nreturn -1;\r\ntstats = this_cpu_ptr(tunnel->dev->tstats);\r\nu64_stats_update_begin(&tstats->syncp);\r\ntstats->rx_packets++;\r\ntstats->rx_bytes += skb->len;\r\nu64_stats_update_end(&tstats->syncp);\r\nskb->mark = 0;\r\nsecpath_reset(skb);\r\nskb->dev = tunnel->dev;\r\nreturn 1;\r\n}\r\nreturn -1;\r\n}\r\nstatic netdev_tx_t vti_tunnel_xmit(struct sk_buff *skb, struct net_device *dev)\r\n{\r\nstruct ip_tunnel *tunnel = netdev_priv(dev);\r\nstruct pcpu_tstats *tstats;\r\nstruct iphdr *tiph = &tunnel->parms.iph;\r\nu8 tos;\r\nstruct rtable *rt;\r\nstruct net_device *tdev;\r\nstruct iphdr *old_iph = ip_hdr(skb);\r\n__be32 dst = tiph->daddr;\r\nstruct flowi4 fl4;\r\nif (skb->protocol != htons(ETH_P_IP))\r\ngoto tx_error;\r\ntos = old_iph->tos;\r\nmemset(&fl4, 0, sizeof(fl4));\r\nflowi4_init_output(&fl4, tunnel->parms.link,\r\nbe32_to_cpu(tunnel->parms.i_key), RT_TOS(tos),\r\nRT_SCOPE_UNIVERSE,\r\nIPPROTO_IPIP, 0,\r\ndst, tiph->saddr, 0, 0);\r\nrt = ip_route_output_key(dev_net(dev), &fl4);\r\nif (IS_ERR(rt)) {\r\ndev->stats.tx_carrier_errors++;\r\ngoto tx_error_icmp;\r\n}\r\nif (!rt->dst.xfrm ||\r\nrt->dst.xfrm->props.mode != XFRM_MODE_TUNNEL) {\r\ndev->stats.tx_carrier_errors++;\r\ngoto tx_error_icmp;\r\n}\r\ntdev = rt->dst.dev;\r\nif (tdev == dev) {\r\nip_rt_put(rt);\r\ndev->stats.collisions++;\r\ngoto tx_error;\r\n}\r\nif (tunnel->err_count > 0) {\r\nif (time_before(jiffies,\r\ntunnel->err_time + IPTUNNEL_ERR_TIMEO)) {\r\ntunnel->err_count--;\r\ndst_link_failure(skb);\r\n} else\r\ntunnel->err_count = 0;\r\n}\r\nIPCB(skb)->flags &= ~(IPSKB_XFRM_TUNNEL_SIZE | IPSKB_XFRM_TRANSFORMED |\r\nIPSKB_REROUTED);\r\nskb_dst_drop(skb);\r\nskb_dst_set(skb, &rt->dst);\r\nnf_reset(skb);\r\nskb->dev = skb_dst(skb)->dev;\r\ntstats = this_cpu_ptr(dev->tstats);\r\nVTI_XMIT(tstats, &dev->stats);\r\nreturn NETDEV_TX_OK;\r\ntx_error_icmp:\r\ndst_link_failure(skb);\r\ntx_error:\r\ndev->stats.tx_errors++;\r\ndev_kfree_skb(skb);\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic int vti_tunnel_bind_dev(struct net_device *dev)\r\n{\r\nstruct net_device *tdev = NULL;\r\nstruct ip_tunnel *tunnel;\r\nstruct iphdr *iph;\r\ntunnel = netdev_priv(dev);\r\niph = &tunnel->parms.iph;\r\nif (iph->daddr) {\r\nstruct rtable *rt;\r\nstruct flowi4 fl4;\r\nmemset(&fl4, 0, sizeof(fl4));\r\nflowi4_init_output(&fl4, tunnel->parms.link,\r\nbe32_to_cpu(tunnel->parms.i_key),\r\nRT_TOS(iph->tos), RT_SCOPE_UNIVERSE,\r\nIPPROTO_IPIP, 0,\r\niph->daddr, iph->saddr, 0, 0);\r\nrt = ip_route_output_key(dev_net(dev), &fl4);\r\nif (!IS_ERR(rt)) {\r\ntdev = rt->dst.dev;\r\nip_rt_put(rt);\r\n}\r\ndev->flags |= IFF_POINTOPOINT;\r\n}\r\nif (!tdev && tunnel->parms.link)\r\ntdev = __dev_get_by_index(dev_net(dev), tunnel->parms.link);\r\nif (tdev) {\r\ndev->hard_header_len = tdev->hard_header_len +\r\nsizeof(struct iphdr);\r\ndev->mtu = tdev->mtu;\r\n}\r\ndev->iflink = tunnel->parms.link;\r\nreturn dev->mtu;\r\n}\r\nstatic int\r\nvti_tunnel_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)\r\n{\r\nint err = 0;\r\nstruct ip_tunnel_parm p;\r\nstruct ip_tunnel *t;\r\nstruct net *net = dev_net(dev);\r\nstruct vti_net *ipn = net_generic(net, vti_net_id);\r\nswitch (cmd) {\r\ncase SIOCGETTUNNEL:\r\nt = NULL;\r\nif (dev == ipn->fb_tunnel_dev) {\r\nif (copy_from_user(&p, ifr->ifr_ifru.ifru_data,\r\nsizeof(p))) {\r\nerr = -EFAULT;\r\nbreak;\r\n}\r\nt = vti_tunnel_locate(net, &p, 0);\r\n}\r\nif (t == NULL)\r\nt = netdev_priv(dev);\r\nmemcpy(&p, &t->parms, sizeof(p));\r\np.i_flags |= GRE_KEY | VTI_ISVTI;\r\np.o_flags |= GRE_KEY;\r\nif (copy_to_user(ifr->ifr_ifru.ifru_data, &p, sizeof(p)))\r\nerr = -EFAULT;\r\nbreak;\r\ncase SIOCADDTUNNEL:\r\ncase SIOCCHGTUNNEL:\r\nerr = -EPERM;\r\nif (!ns_capable(net->user_ns, CAP_NET_ADMIN))\r\ngoto done;\r\nerr = -EFAULT;\r\nif (copy_from_user(&p, ifr->ifr_ifru.ifru_data, sizeof(p)))\r\ngoto done;\r\nerr = -EINVAL;\r\nif (p.iph.version != 4 || p.iph.protocol != IPPROTO_IPIP ||\r\np.iph.ihl != 5)\r\ngoto done;\r\nt = vti_tunnel_locate(net, &p, cmd == SIOCADDTUNNEL);\r\nif (dev != ipn->fb_tunnel_dev && cmd == SIOCCHGTUNNEL) {\r\nif (t != NULL) {\r\nif (t->dev != dev) {\r\nerr = -EEXIST;\r\nbreak;\r\n}\r\n} else {\r\nif (((dev->flags&IFF_POINTOPOINT) &&\r\n!p.iph.daddr) ||\r\n(!(dev->flags&IFF_POINTOPOINT) &&\r\np.iph.daddr)) {\r\nerr = -EINVAL;\r\nbreak;\r\n}\r\nt = netdev_priv(dev);\r\nvti_tunnel_unlink(ipn, t);\r\nsynchronize_net();\r\nt->parms.iph.saddr = p.iph.saddr;\r\nt->parms.iph.daddr = p.iph.daddr;\r\nt->parms.i_key = p.i_key;\r\nt->parms.o_key = p.o_key;\r\nt->parms.iph.protocol = IPPROTO_IPIP;\r\nmemcpy(dev->dev_addr, &p.iph.saddr, 4);\r\nmemcpy(dev->broadcast, &p.iph.daddr, 4);\r\nvti_tunnel_link(ipn, t);\r\nnetdev_state_change(dev);\r\n}\r\n}\r\nif (t) {\r\nerr = 0;\r\nif (cmd == SIOCCHGTUNNEL) {\r\nt->parms.i_key = p.i_key;\r\nt->parms.o_key = p.o_key;\r\nif (t->parms.link != p.link) {\r\nt->parms.link = p.link;\r\nvti_tunnel_bind_dev(dev);\r\nnetdev_state_change(dev);\r\n}\r\n}\r\np.i_flags |= GRE_KEY | VTI_ISVTI;\r\np.o_flags |= GRE_KEY;\r\nif (copy_to_user(ifr->ifr_ifru.ifru_data, &t->parms,\r\nsizeof(p)))\r\nerr = -EFAULT;\r\n} else\r\nerr = (cmd == SIOCADDTUNNEL ? -ENOBUFS : -ENOENT);\r\nbreak;\r\ncase SIOCDELTUNNEL:\r\nerr = -EPERM;\r\nif (!ns_capable(net->user_ns, CAP_NET_ADMIN))\r\ngoto done;\r\nif (dev == ipn->fb_tunnel_dev) {\r\nerr = -EFAULT;\r\nif (copy_from_user(&p, ifr->ifr_ifru.ifru_data,\r\nsizeof(p)))\r\ngoto done;\r\nerr = -ENOENT;\r\nt = vti_tunnel_locate(net, &p, 0);\r\nif (t == NULL)\r\ngoto done;\r\nerr = -EPERM;\r\nif (t->dev == ipn->fb_tunnel_dev)\r\ngoto done;\r\ndev = t->dev;\r\n}\r\nunregister_netdevice(dev);\r\nerr = 0;\r\nbreak;\r\ndefault:\r\nerr = -EINVAL;\r\n}\r\ndone:\r\nreturn err;\r\n}\r\nstatic int vti_tunnel_change_mtu(struct net_device *dev, int new_mtu)\r\n{\r\nif (new_mtu < 68 || new_mtu > 0xFFF8)\r\nreturn -EINVAL;\r\ndev->mtu = new_mtu;\r\nreturn 0;\r\n}\r\nstatic void vti_dev_free(struct net_device *dev)\r\n{\r\nfree_percpu(dev->tstats);\r\nfree_netdev(dev);\r\n}\r\nstatic void vti_tunnel_setup(struct net_device *dev)\r\n{\r\ndev->netdev_ops = &vti_netdev_ops;\r\ndev->destructor = vti_dev_free;\r\ndev->type = ARPHRD_TUNNEL;\r\ndev->hard_header_len = LL_MAX_HEADER + sizeof(struct iphdr);\r\ndev->mtu = ETH_DATA_LEN;\r\ndev->flags = IFF_NOARP;\r\ndev->iflink = 0;\r\ndev->addr_len = 4;\r\ndev->features |= NETIF_F_NETNS_LOCAL;\r\ndev->features |= NETIF_F_LLTX;\r\ndev->priv_flags &= ~IFF_XMIT_DST_RELEASE;\r\n}\r\nstatic int vti_tunnel_init(struct net_device *dev)\r\n{\r\nstruct ip_tunnel *tunnel = netdev_priv(dev);\r\ntunnel->dev = dev;\r\nstrcpy(tunnel->parms.name, dev->name);\r\nmemcpy(dev->dev_addr, &tunnel->parms.iph.saddr, 4);\r\nmemcpy(dev->broadcast, &tunnel->parms.iph.daddr, 4);\r\ndev->tstats = alloc_percpu(struct pcpu_tstats);\r\nif (!dev->tstats)\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nstatic int __net_init vti_fb_tunnel_init(struct net_device *dev)\r\n{\r\nstruct ip_tunnel *tunnel = netdev_priv(dev);\r\nstruct iphdr *iph = &tunnel->parms.iph;\r\nstruct vti_net *ipn = net_generic(dev_net(dev), vti_net_id);\r\ntunnel->dev = dev;\r\nstrcpy(tunnel->parms.name, dev->name);\r\niph->version = 4;\r\niph->protocol = IPPROTO_IPIP;\r\niph->ihl = 5;\r\ndev->tstats = alloc_percpu(struct pcpu_tstats);\r\nif (!dev->tstats)\r\nreturn -ENOMEM;\r\ndev_hold(dev);\r\nrcu_assign_pointer(ipn->tunnels_wc[0], tunnel);\r\nreturn 0;\r\n}\r\nstatic void vti_destroy_tunnels(struct vti_net *ipn, struct list_head *head)\r\n{\r\nint prio;\r\nfor (prio = 1; prio < 4; prio++) {\r\nint h;\r\nfor (h = 0; h < HASH_SIZE; h++) {\r\nstruct ip_tunnel *t;\r\nt = rtnl_dereference(ipn->tunnels[prio][h]);\r\nwhile (t != NULL) {\r\nunregister_netdevice_queue(t->dev, head);\r\nt = rtnl_dereference(t->next);\r\n}\r\n}\r\n}\r\n}\r\nstatic int __net_init vti_init_net(struct net *net)\r\n{\r\nint err;\r\nstruct vti_net *ipn = net_generic(net, vti_net_id);\r\nipn->tunnels[0] = ipn->tunnels_wc;\r\nipn->tunnels[1] = ipn->tunnels_l;\r\nipn->tunnels[2] = ipn->tunnels_r;\r\nipn->tunnels[3] = ipn->tunnels_r_l;\r\nipn->fb_tunnel_dev = alloc_netdev(sizeof(struct ip_tunnel),\r\n"ip_vti0",\r\nvti_tunnel_setup);\r\nif (!ipn->fb_tunnel_dev) {\r\nerr = -ENOMEM;\r\ngoto err_alloc_dev;\r\n}\r\ndev_net_set(ipn->fb_tunnel_dev, net);\r\nerr = vti_fb_tunnel_init(ipn->fb_tunnel_dev);\r\nif (err)\r\ngoto err_reg_dev;\r\nipn->fb_tunnel_dev->rtnl_link_ops = &vti_link_ops;\r\nerr = register_netdev(ipn->fb_tunnel_dev);\r\nif (err)\r\ngoto err_reg_dev;\r\nreturn 0;\r\nerr_reg_dev:\r\nvti_dev_free(ipn->fb_tunnel_dev);\r\nerr_alloc_dev:\r\nreturn err;\r\n}\r\nstatic void __net_exit vti_exit_net(struct net *net)\r\n{\r\nstruct vti_net *ipn = net_generic(net, vti_net_id);\r\nLIST_HEAD(list);\r\nrtnl_lock();\r\nvti_destroy_tunnels(ipn, &list);\r\nunregister_netdevice_many(&list);\r\nrtnl_unlock();\r\n}\r\nstatic int vti_tunnel_validate(struct nlattr *tb[], struct nlattr *data[])\r\n{\r\nreturn 0;\r\n}\r\nstatic void vti_netlink_parms(struct nlattr *data[],\r\nstruct ip_tunnel_parm *parms)\r\n{\r\nmemset(parms, 0, sizeof(*parms));\r\nparms->iph.protocol = IPPROTO_IPIP;\r\nif (!data)\r\nreturn;\r\nif (data[IFLA_VTI_LINK])\r\nparms->link = nla_get_u32(data[IFLA_VTI_LINK]);\r\nif (data[IFLA_VTI_IKEY])\r\nparms->i_key = nla_get_be32(data[IFLA_VTI_IKEY]);\r\nif (data[IFLA_VTI_OKEY])\r\nparms->o_key = nla_get_be32(data[IFLA_VTI_OKEY]);\r\nif (data[IFLA_VTI_LOCAL])\r\nparms->iph.saddr = nla_get_be32(data[IFLA_VTI_LOCAL]);\r\nif (data[IFLA_VTI_REMOTE])\r\nparms->iph.daddr = nla_get_be32(data[IFLA_VTI_REMOTE]);\r\n}\r\nstatic int vti_newlink(struct net *src_net, struct net_device *dev,\r\nstruct nlattr *tb[], struct nlattr *data[])\r\n{\r\nstruct ip_tunnel *nt;\r\nstruct net *net = dev_net(dev);\r\nstruct vti_net *ipn = net_generic(net, vti_net_id);\r\nint mtu;\r\nint err;\r\nnt = netdev_priv(dev);\r\nvti_netlink_parms(data, &nt->parms);\r\nif (vti_tunnel_locate(net, &nt->parms, 0))\r\nreturn -EEXIST;\r\nmtu = vti_tunnel_bind_dev(dev);\r\nif (!tb[IFLA_MTU])\r\ndev->mtu = mtu;\r\nerr = register_netdevice(dev);\r\nif (err)\r\ngoto out;\r\ndev_hold(dev);\r\nvti_tunnel_link(ipn, nt);\r\nout:\r\nreturn err;\r\n}\r\nstatic int vti_changelink(struct net_device *dev, struct nlattr *tb[],\r\nstruct nlattr *data[])\r\n{\r\nstruct ip_tunnel *t, *nt;\r\nstruct net *net = dev_net(dev);\r\nstruct vti_net *ipn = net_generic(net, vti_net_id);\r\nstruct ip_tunnel_parm p;\r\nint mtu;\r\nif (dev == ipn->fb_tunnel_dev)\r\nreturn -EINVAL;\r\nnt = netdev_priv(dev);\r\nvti_netlink_parms(data, &p);\r\nt = vti_tunnel_locate(net, &p, 0);\r\nif (t) {\r\nif (t->dev != dev)\r\nreturn -EEXIST;\r\n} else {\r\nt = nt;\r\nvti_tunnel_unlink(ipn, t);\r\nt->parms.iph.saddr = p.iph.saddr;\r\nt->parms.iph.daddr = p.iph.daddr;\r\nt->parms.i_key = p.i_key;\r\nt->parms.o_key = p.o_key;\r\nif (dev->type != ARPHRD_ETHER) {\r\nmemcpy(dev->dev_addr, &p.iph.saddr, 4);\r\nmemcpy(dev->broadcast, &p.iph.daddr, 4);\r\n}\r\nvti_tunnel_link(ipn, t);\r\nnetdev_state_change(dev);\r\n}\r\nif (t->parms.link != p.link) {\r\nt->parms.link = p.link;\r\nmtu = vti_tunnel_bind_dev(dev);\r\nif (!tb[IFLA_MTU])\r\ndev->mtu = mtu;\r\nnetdev_state_change(dev);\r\n}\r\nreturn 0;\r\n}\r\nstatic size_t vti_get_size(const struct net_device *dev)\r\n{\r\nreturn\r\nnla_total_size(4) +\r\nnla_total_size(4) +\r\nnla_total_size(4) +\r\nnla_total_size(4) +\r\nnla_total_size(4) +\r\n0;\r\n}\r\nstatic int vti_fill_info(struct sk_buff *skb, const struct net_device *dev)\r\n{\r\nstruct ip_tunnel *t = netdev_priv(dev);\r\nstruct ip_tunnel_parm *p = &t->parms;\r\nnla_put_u32(skb, IFLA_VTI_LINK, p->link);\r\nnla_put_be32(skb, IFLA_VTI_IKEY, p->i_key);\r\nnla_put_be32(skb, IFLA_VTI_OKEY, p->o_key);\r\nnla_put_be32(skb, IFLA_VTI_LOCAL, p->iph.saddr);\r\nnla_put_be32(skb, IFLA_VTI_REMOTE, p->iph.daddr);\r\nreturn 0;\r\n}\r\nstatic int __init vti_init(void)\r\n{\r\nint err;\r\npr_info("IPv4 over IPSec tunneling driver\n");\r\nerr = register_pernet_device(&vti_net_ops);\r\nif (err < 0)\r\nreturn err;\r\nerr = xfrm4_mode_tunnel_input_register(&vti_handler);\r\nif (err < 0) {\r\nunregister_pernet_device(&vti_net_ops);\r\npr_info(KERN_INFO "vti init: can't register tunnel\n");\r\n}\r\nerr = rtnl_link_register(&vti_link_ops);\r\nif (err < 0)\r\ngoto rtnl_link_failed;\r\nreturn err;\r\nrtnl_link_failed:\r\nxfrm4_mode_tunnel_input_deregister(&vti_handler);\r\nunregister_pernet_device(&vti_net_ops);\r\nreturn err;\r\n}\r\nstatic void __exit vti_fini(void)\r\n{\r\nrtnl_link_unregister(&vti_link_ops);\r\nif (xfrm4_mode_tunnel_input_deregister(&vti_handler))\r\npr_info("vti close: can't deregister tunnel\n");\r\nunregister_pernet_device(&vti_net_ops);\r\n}
