static void __init mvebu_clk_core_setup(struct device_node *np,\r\nstruct core_clocks *coreclk)\r\n{\r\nconst char *tclk_name = "tclk";\r\nconst char *cpuclk_name = "cpuclk";\r\nvoid __iomem *base;\r\nunsigned long rate;\r\nint n;\r\nbase = of_iomap(np, 0);\r\nif (WARN_ON(!base))\r\nreturn;\r\nclk_data.clk_num = 2 + coreclk->num_ratios;\r\nclk_data.clks = kzalloc(clk_data.clk_num * sizeof(struct clk *),\r\nGFP_KERNEL);\r\nif (WARN_ON(!clk_data.clks))\r\nreturn;\r\nof_property_read_string_index(np, "clock-output-names", 0,\r\n&tclk_name);\r\nrate = coreclk->get_tclk_freq(base);\r\nclk_data.clks[0] = clk_register_fixed_rate(NULL, tclk_name, NULL,\r\nCLK_IS_ROOT, rate);\r\nWARN_ON(IS_ERR(clk_data.clks[0]));\r\nof_property_read_string_index(np, "clock-output-names", 1,\r\n&cpuclk_name);\r\nrate = coreclk->get_cpu_freq(base);\r\nclk_data.clks[1] = clk_register_fixed_rate(NULL, cpuclk_name, NULL,\r\nCLK_IS_ROOT, rate);\r\nWARN_ON(IS_ERR(clk_data.clks[1]));\r\nfor (n = 0; n < coreclk->num_ratios; n++) {\r\nconst char *rclk_name = coreclk->ratios[n].name;\r\nint mult, div;\r\nof_property_read_string_index(np, "clock-output-names",\r\n2+n, &rclk_name);\r\ncoreclk->get_clk_ratio(base, coreclk->ratios[n].id,\r\n&mult, &div);\r\nclk_data.clks[2+n] = clk_register_fixed_factor(NULL, rclk_name,\r\ncpuclk_name, 0, mult, div);\r\nWARN_ON(IS_ERR(clk_data.clks[2+n]));\r\n};\r\niounmap(base);\r\nof_clk_add_provider(np, of_clk_src_onecell_get, &clk_data);\r\n}\r\nstatic u32 __init armada_370_get_tclk_freq(void __iomem *sar)\r\n{\r\nu8 tclk_freq_select = 0;\r\ntclk_freq_select = ((readl(sar) >> SARL_A370_TCLK_FREQ_OPT) &\r\nSARL_A370_TCLK_FREQ_OPT_MASK);\r\nreturn armada_370_tclk_frequencies[tclk_freq_select];\r\n}\r\nstatic u32 __init armada_370_get_cpu_freq(void __iomem *sar)\r\n{\r\nu32 cpu_freq;\r\nu8 cpu_freq_select = 0;\r\ncpu_freq_select = ((readl(sar) >> SARL_A370_PCLK_FREQ_OPT) &\r\nSARL_A370_PCLK_FREQ_OPT_MASK);\r\nif (cpu_freq_select > ARRAY_SIZE(armada_370_cpu_frequencies)) {\r\npr_err("CPU freq select unsuported %d\n", cpu_freq_select);\r\ncpu_freq = 0;\r\n} else\r\ncpu_freq = armada_370_cpu_frequencies[cpu_freq_select];\r\nreturn cpu_freq;\r\n}\r\nstatic void __init armada_370_xp_get_clk_ratio(u32 opt,\r\nvoid __iomem *sar, int id, int *mult, int *div)\r\n{\r\nswitch (id) {\r\ncase A370_XP_NBCLK:\r\n*mult = armada_370_xp_nbclk_ratios[opt][0];\r\n*div = armada_370_xp_nbclk_ratios[opt][1];\r\nbreak;\r\ncase A370_XP_HCLK:\r\n*mult = armada_370_xp_hclk_ratios[opt][0];\r\n*div = armada_370_xp_hclk_ratios[opt][1];\r\nbreak;\r\ncase A370_XP_DRAMCLK:\r\n*mult = armada_370_xp_dramclk_ratios[opt][0];\r\n*div = armada_370_xp_dramclk_ratios[opt][1];\r\nbreak;\r\n}\r\n}\r\nstatic void __init armada_370_get_clk_ratio(\r\nvoid __iomem *sar, int id, int *mult, int *div)\r\n{\r\nu32 opt = ((readl(sar) >> SARL_A370_FAB_FREQ_OPT) &\r\nSARL_A370_FAB_FREQ_OPT_MASK);\r\narmada_370_xp_get_clk_ratio(opt, sar, id, mult, div);\r\n}\r\nstatic u32 __init armada_xp_get_tclk_freq(void __iomem *sar)\r\n{\r\nreturn 250 * 1000 * 1000;\r\n}\r\nstatic u32 __init armada_xp_get_cpu_freq(void __iomem *sar)\r\n{\r\nu32 cpu_freq;\r\nu8 cpu_freq_select = 0;\r\ncpu_freq_select = ((readl(sar) >> SARL_AXP_PCLK_FREQ_OPT) &\r\nSARL_AXP_PCLK_FREQ_OPT_MASK);\r\ncpu_freq_select |= (((readl(sar+4) >> SARH_AXP_PCLK_FREQ_OPT) &\r\nSARH_AXP_PCLK_FREQ_OPT_MASK)\r\n<< SARH_AXP_PCLK_FREQ_OPT_SHIFT);\r\nif (cpu_freq_select > ARRAY_SIZE(armada_xp_cpu_frequencies)) {\r\npr_err("CPU freq select unsuported: %d\n", cpu_freq_select);\r\ncpu_freq = 0;\r\n} else\r\ncpu_freq = armada_xp_cpu_frequencies[cpu_freq_select];\r\nreturn cpu_freq;\r\n}\r\nstatic void __init armada_xp_get_clk_ratio(\r\nvoid __iomem *sar, int id, int *mult, int *div)\r\n{\r\nu32 opt = ((readl(sar) >> SARL_AXP_FAB_FREQ_OPT) &\r\nSARL_AXP_FAB_FREQ_OPT_MASK);\r\nopt |= (((readl(sar+4) >> SARH_AXP_FAB_FREQ_OPT) &\r\nSARH_AXP_FAB_FREQ_OPT_MASK)\r\n<< SARH_AXP_FAB_FREQ_OPT_SHIFT);\r\narmada_370_xp_get_clk_ratio(opt, sar, id, mult, div);\r\n}\r\nstatic u32 __init dove_get_tclk_freq(void __iomem *sar)\r\n{\r\nu32 opt = (readl(sar) >> SAR_DOVE_TCLK_FREQ) &\r\nSAR_DOVE_TCLK_FREQ_MASK;\r\nreturn dove_tclk_frequencies[opt];\r\n}\r\nstatic u32 __init dove_get_cpu_freq(void __iomem *sar)\r\n{\r\nu32 opt = (readl(sar) >> SAR_DOVE_CPU_FREQ) &\r\nSAR_DOVE_CPU_FREQ_MASK;\r\nreturn dove_cpu_frequencies[opt];\r\n}\r\nstatic void __init dove_get_clk_ratio(\r\nvoid __iomem *sar, int id, int *mult, int *div)\r\n{\r\nswitch (id) {\r\ncase DOVE_CPU_TO_L2:\r\n{\r\nu32 opt = (readl(sar) >> SAR_DOVE_L2_RATIO) &\r\nSAR_DOVE_L2_RATIO_MASK;\r\n*mult = dove_cpu_l2_ratios[opt][0];\r\n*div = dove_cpu_l2_ratios[opt][1];\r\nbreak;\r\n}\r\ncase DOVE_CPU_TO_DDR:\r\n{\r\nu32 opt = (readl(sar) >> SAR_DOVE_DDR_RATIO) &\r\nSAR_DOVE_DDR_RATIO_MASK;\r\n*mult = dove_cpu_ddr_ratios[opt][0];\r\n*div = dove_cpu_ddr_ratios[opt][1];\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic u32 __init kirkwood_get_tclk_freq(void __iomem *sar)\r\n{\r\nu32 opt = (readl(sar) >> SAR_KIRKWOOD_TCLK_FREQ) &\r\nSAR_KIRKWOOD_TCLK_FREQ_MASK;\r\nreturn (opt) ? 166666667 : 200000000;\r\n}\r\nstatic u32 __init kirkwood_get_cpu_freq(void __iomem *sar)\r\n{\r\nu32 opt = SAR_KIRKWOOD_CPU_FREQ(readl(sar));\r\nreturn kirkwood_cpu_frequencies[opt];\r\n}\r\nstatic void __init kirkwood_get_clk_ratio(\r\nvoid __iomem *sar, int id, int *mult, int *div)\r\n{\r\nswitch (id) {\r\ncase KIRKWOOD_CPU_TO_L2:\r\n{\r\nu32 opt = SAR_KIRKWOOD_L2_RATIO(readl(sar));\r\n*mult = kirkwood_cpu_l2_ratios[opt][0];\r\n*div = kirkwood_cpu_l2_ratios[opt][1];\r\nbreak;\r\n}\r\ncase KIRKWOOD_CPU_TO_DDR:\r\n{\r\nu32 opt = (readl(sar) >> SAR_KIRKWOOD_DDR_RATIO) &\r\nSAR_KIRKWOOD_DDR_RATIO_MASK;\r\n*mult = kirkwood_cpu_ddr_ratios[opt][0];\r\n*div = kirkwood_cpu_ddr_ratios[opt][1];\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic u32 __init mv88f6180_get_cpu_freq(void __iomem *sar)\r\n{\r\nu32 opt = (readl(sar) >> SAR_MV88F6180_CLK) & SAR_MV88F6180_CLK_MASK;\r\nreturn mv88f6180_cpu_frequencies[opt];\r\n}\r\nstatic void __init mv88f6180_get_clk_ratio(\r\nvoid __iomem *sar, int id, int *mult, int *div)\r\n{\r\nswitch (id) {\r\ncase KIRKWOOD_CPU_TO_L2:\r\n{\r\n*mult = 1;\r\n*div = 2;\r\nbreak;\r\n}\r\ncase KIRKWOOD_CPU_TO_DDR:\r\n{\r\nu32 opt = (readl(sar) >> SAR_MV88F6180_CLK) &\r\nSAR_MV88F6180_CLK_MASK;\r\n*mult = mv88f6180_cpu_ddr_ratios[opt][0];\r\n*div = mv88f6180_cpu_ddr_ratios[opt][1];\r\nbreak;\r\n}\r\n}\r\n}\r\nvoid __init mvebu_core_clk_init(void)\r\n{\r\nstruct device_node *np;\r\nfor_each_matching_node(np, clk_core_match) {\r\nconst struct of_device_id *match =\r\nof_match_node(clk_core_match, np);\r\nmvebu_clk_core_setup(np, (struct core_clocks *)match->data);\r\n}\r\n}
