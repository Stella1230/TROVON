static inline int is_live(void)\r\n{\r\nreturn !(list_empty(&dcookie_users));\r\n}\r\nstatic inline unsigned long dcookie_value(struct dcookie_struct * dcs)\r\n{\r\nreturn (unsigned long)dcs->path.dentry;\r\n}\r\nstatic size_t dcookie_hash(unsigned long dcookie)\r\n{\r\nreturn (dcookie >> L1_CACHE_SHIFT) & (hash_size - 1);\r\n}\r\nstatic struct dcookie_struct * find_dcookie(unsigned long dcookie)\r\n{\r\nstruct dcookie_struct *found = NULL;\r\nstruct dcookie_struct * dcs;\r\nstruct list_head * pos;\r\nstruct list_head * list;\r\nlist = dcookie_hashtable + dcookie_hash(dcookie);\r\nlist_for_each(pos, list) {\r\ndcs = list_entry(pos, struct dcookie_struct, hash_list);\r\nif (dcookie_value(dcs) == dcookie) {\r\nfound = dcs;\r\nbreak;\r\n}\r\n}\r\nreturn found;\r\n}\r\nstatic void hash_dcookie(struct dcookie_struct * dcs)\r\n{\r\nstruct list_head * list = dcookie_hashtable + dcookie_hash(dcookie_value(dcs));\r\nlist_add(&dcs->hash_list, list);\r\n}\r\nstatic struct dcookie_struct *alloc_dcookie(struct path *path)\r\n{\r\nstruct dcookie_struct *dcs = kmem_cache_alloc(dcookie_cache,\r\nGFP_KERNEL);\r\nstruct dentry *d;\r\nif (!dcs)\r\nreturn NULL;\r\nd = path->dentry;\r\nspin_lock(&d->d_lock);\r\nd->d_flags |= DCACHE_COOKIE;\r\nspin_unlock(&d->d_lock);\r\ndcs->path = *path;\r\npath_get(path);\r\nhash_dcookie(dcs);\r\nreturn dcs;\r\n}\r\nint get_dcookie(struct path *path, unsigned long *cookie)\r\n{\r\nint err = 0;\r\nstruct dcookie_struct * dcs;\r\nmutex_lock(&dcookie_mutex);\r\nif (!is_live()) {\r\nerr = -EINVAL;\r\ngoto out;\r\n}\r\nif (path->dentry->d_flags & DCACHE_COOKIE) {\r\ndcs = find_dcookie((unsigned long)path->dentry);\r\n} else {\r\ndcs = alloc_dcookie(path);\r\nif (!dcs) {\r\nerr = -ENOMEM;\r\ngoto out;\r\n}\r\n}\r\n*cookie = dcookie_value(dcs);\r\nout:\r\nmutex_unlock(&dcookie_mutex);\r\nreturn err;\r\n}\r\nSYSCALL_DEFINE(lookup_dcookie)(u64 cookie64, char __user * buf, size_t len)\r\n{\r\nunsigned long cookie = (unsigned long)cookie64;\r\nint err = -EINVAL;\r\nchar * kbuf;\r\nchar * path;\r\nsize_t pathlen;\r\nstruct dcookie_struct * dcs;\r\nif (!capable(CAP_SYS_ADMIN))\r\nreturn -EPERM;\r\nmutex_lock(&dcookie_mutex);\r\nif (!is_live()) {\r\nerr = -EINVAL;\r\ngoto out;\r\n}\r\nif (!(dcs = find_dcookie(cookie)))\r\ngoto out;\r\nerr = -ENOMEM;\r\nkbuf = kmalloc(PAGE_SIZE, GFP_KERNEL);\r\nif (!kbuf)\r\ngoto out;\r\npath = d_path(&dcs->path, kbuf, PAGE_SIZE);\r\nmutex_unlock(&dcookie_mutex);\r\nif (IS_ERR(path)) {\r\nerr = PTR_ERR(path);\r\ngoto out_free;\r\n}\r\nerr = -ERANGE;\r\npathlen = kbuf + PAGE_SIZE - path;\r\nif (pathlen <= len) {\r\nerr = pathlen;\r\nif (copy_to_user(buf, path, pathlen))\r\nerr = -EFAULT;\r\n}\r\nout_free:\r\nkfree(kbuf);\r\nreturn err;\r\nout:\r\nmutex_unlock(&dcookie_mutex);\r\nreturn err;\r\n}\r\nasmlinkage long SyS_lookup_dcookie(u64 cookie64, long buf, long len)\r\n{\r\nreturn SYSC_lookup_dcookie(cookie64, (char __user *) buf, (size_t) len);\r\n}\r\nstatic int dcookie_init(void)\r\n{\r\nstruct list_head * d;\r\nunsigned int i, hash_bits;\r\nint err = -ENOMEM;\r\ndcookie_cache = kmem_cache_create("dcookie_cache",\r\nsizeof(struct dcookie_struct),\r\n0, 0, NULL);\r\nif (!dcookie_cache)\r\ngoto out;\r\ndcookie_hashtable = kmalloc(PAGE_SIZE, GFP_KERNEL);\r\nif (!dcookie_hashtable)\r\ngoto out_kmem;\r\nerr = 0;\r\nhash_size = PAGE_SIZE / sizeof(struct list_head);\r\nhash_bits = 0;\r\ndo {\r\nhash_bits++;\r\n} while ((hash_size >> hash_bits) != 0);\r\nhash_bits--;\r\nhash_size = 1UL << hash_bits;\r\nd = dcookie_hashtable;\r\ni = hash_size;\r\ndo {\r\nINIT_LIST_HEAD(d);\r\nd++;\r\ni--;\r\n} while (i);\r\nout:\r\nreturn err;\r\nout_kmem:\r\nkmem_cache_destroy(dcookie_cache);\r\ngoto out;\r\n}\r\nstatic void free_dcookie(struct dcookie_struct * dcs)\r\n{\r\nstruct dentry *d = dcs->path.dentry;\r\nspin_lock(&d->d_lock);\r\nd->d_flags &= ~DCACHE_COOKIE;\r\nspin_unlock(&d->d_lock);\r\npath_put(&dcs->path);\r\nkmem_cache_free(dcookie_cache, dcs);\r\n}\r\nstatic void dcookie_exit(void)\r\n{\r\nstruct list_head * list;\r\nstruct list_head * pos;\r\nstruct list_head * pos2;\r\nstruct dcookie_struct * dcs;\r\nsize_t i;\r\nfor (i = 0; i < hash_size; ++i) {\r\nlist = dcookie_hashtable + i;\r\nlist_for_each_safe(pos, pos2, list) {\r\ndcs = list_entry(pos, struct dcookie_struct, hash_list);\r\nlist_del(&dcs->hash_list);\r\nfree_dcookie(dcs);\r\n}\r\n}\r\nkfree(dcookie_hashtable);\r\nkmem_cache_destroy(dcookie_cache);\r\n}\r\nstruct dcookie_user * dcookie_register(void)\r\n{\r\nstruct dcookie_user * user;\r\nmutex_lock(&dcookie_mutex);\r\nuser = kmalloc(sizeof(struct dcookie_user), GFP_KERNEL);\r\nif (!user)\r\ngoto out;\r\nif (!is_live() && dcookie_init())\r\ngoto out_free;\r\nlist_add(&user->next, &dcookie_users);\r\nout:\r\nmutex_unlock(&dcookie_mutex);\r\nreturn user;\r\nout_free:\r\nkfree(user);\r\nuser = NULL;\r\ngoto out;\r\n}\r\nvoid dcookie_unregister(struct dcookie_user * user)\r\n{\r\nmutex_lock(&dcookie_mutex);\r\nlist_del(&user->next);\r\nkfree(user);\r\nif (!is_live())\r\ndcookie_exit();\r\nmutex_unlock(&dcookie_mutex);\r\n}
