void iscsit_create_conn_recovery_datain_values(\r\nstruct iscsi_cmd *cmd,\r\n__be32 exp_data_sn)\r\n{\r\nu32 data_sn = 0;\r\nstruct iscsi_conn *conn = cmd->conn;\r\ncmd->next_burst_len = 0;\r\ncmd->read_data_done = 0;\r\nwhile (be32_to_cpu(exp_data_sn) > data_sn) {\r\nif ((cmd->next_burst_len +\r\nconn->conn_ops->MaxRecvDataSegmentLength) <\r\nconn->sess->sess_ops->MaxBurstLength) {\r\ncmd->read_data_done +=\r\nconn->conn_ops->MaxRecvDataSegmentLength;\r\ncmd->next_burst_len +=\r\nconn->conn_ops->MaxRecvDataSegmentLength;\r\n} else {\r\ncmd->read_data_done +=\r\n(conn->sess->sess_ops->MaxBurstLength -\r\ncmd->next_burst_len);\r\ncmd->next_burst_len = 0;\r\n}\r\ndata_sn++;\r\n}\r\n}\r\nvoid iscsit_create_conn_recovery_dataout_values(\r\nstruct iscsi_cmd *cmd)\r\n{\r\nu32 write_data_done = 0;\r\nstruct iscsi_conn *conn = cmd->conn;\r\ncmd->data_sn = 0;\r\ncmd->next_burst_len = 0;\r\nwhile (cmd->write_data_done > write_data_done) {\r\nif ((write_data_done + conn->sess->sess_ops->MaxBurstLength) <=\r\ncmd->write_data_done)\r\nwrite_data_done += conn->sess->sess_ops->MaxBurstLength;\r\nelse\r\nbreak;\r\n}\r\ncmd->write_data_done = write_data_done;\r\n}\r\nstatic int iscsit_attach_active_connection_recovery_entry(\r\nstruct iscsi_session *sess,\r\nstruct iscsi_conn_recovery *cr)\r\n{\r\nspin_lock(&sess->cr_a_lock);\r\nlist_add_tail(&cr->cr_list, &sess->cr_active_list);\r\nspin_unlock(&sess->cr_a_lock);\r\nreturn 0;\r\n}\r\nstatic int iscsit_attach_inactive_connection_recovery_entry(\r\nstruct iscsi_session *sess,\r\nstruct iscsi_conn_recovery *cr)\r\n{\r\nspin_lock(&sess->cr_i_lock);\r\nlist_add_tail(&cr->cr_list, &sess->cr_inactive_list);\r\nsess->conn_recovery_count++;\r\npr_debug("Incremented connection recovery count to %u for"\r\n" SID: %u\n", sess->conn_recovery_count, sess->sid);\r\nspin_unlock(&sess->cr_i_lock);\r\nreturn 0;\r\n}\r\nstruct iscsi_conn_recovery *iscsit_get_inactive_connection_recovery_entry(\r\nstruct iscsi_session *sess,\r\nu16 cid)\r\n{\r\nstruct iscsi_conn_recovery *cr;\r\nspin_lock(&sess->cr_i_lock);\r\nlist_for_each_entry(cr, &sess->cr_inactive_list, cr_list) {\r\nif (cr->cid == cid) {\r\nspin_unlock(&sess->cr_i_lock);\r\nreturn cr;\r\n}\r\n}\r\nspin_unlock(&sess->cr_i_lock);\r\nreturn NULL;\r\n}\r\nvoid iscsit_free_connection_recovery_entires(struct iscsi_session *sess)\r\n{\r\nstruct iscsi_cmd *cmd, *cmd_tmp;\r\nstruct iscsi_conn_recovery *cr, *cr_tmp;\r\nspin_lock(&sess->cr_a_lock);\r\nlist_for_each_entry_safe(cr, cr_tmp, &sess->cr_active_list, cr_list) {\r\nlist_del(&cr->cr_list);\r\nspin_unlock(&sess->cr_a_lock);\r\nspin_lock(&cr->conn_recovery_cmd_lock);\r\nlist_for_each_entry_safe(cmd, cmd_tmp,\r\n&cr->conn_recovery_cmd_list, i_conn_node) {\r\nlist_del(&cmd->i_conn_node);\r\ncmd->conn = NULL;\r\nspin_unlock(&cr->conn_recovery_cmd_lock);\r\niscsit_free_cmd(cmd);\r\nspin_lock(&cr->conn_recovery_cmd_lock);\r\n}\r\nspin_unlock(&cr->conn_recovery_cmd_lock);\r\nspin_lock(&sess->cr_a_lock);\r\nkfree(cr);\r\n}\r\nspin_unlock(&sess->cr_a_lock);\r\nspin_lock(&sess->cr_i_lock);\r\nlist_for_each_entry_safe(cr, cr_tmp, &sess->cr_inactive_list, cr_list) {\r\nlist_del(&cr->cr_list);\r\nspin_unlock(&sess->cr_i_lock);\r\nspin_lock(&cr->conn_recovery_cmd_lock);\r\nlist_for_each_entry_safe(cmd, cmd_tmp,\r\n&cr->conn_recovery_cmd_list, i_conn_node) {\r\nlist_del(&cmd->i_conn_node);\r\ncmd->conn = NULL;\r\nspin_unlock(&cr->conn_recovery_cmd_lock);\r\niscsit_free_cmd(cmd);\r\nspin_lock(&cr->conn_recovery_cmd_lock);\r\n}\r\nspin_unlock(&cr->conn_recovery_cmd_lock);\r\nspin_lock(&sess->cr_i_lock);\r\nkfree(cr);\r\n}\r\nspin_unlock(&sess->cr_i_lock);\r\n}\r\nint iscsit_remove_active_connection_recovery_entry(\r\nstruct iscsi_conn_recovery *cr,\r\nstruct iscsi_session *sess)\r\n{\r\nspin_lock(&sess->cr_a_lock);\r\nlist_del(&cr->cr_list);\r\nsess->conn_recovery_count--;\r\npr_debug("Decremented connection recovery count to %u for"\r\n" SID: %u\n", sess->conn_recovery_count, sess->sid);\r\nspin_unlock(&sess->cr_a_lock);\r\nkfree(cr);\r\nreturn 0;\r\n}\r\nstatic void iscsit_remove_inactive_connection_recovery_entry(\r\nstruct iscsi_conn_recovery *cr,\r\nstruct iscsi_session *sess)\r\n{\r\nspin_lock(&sess->cr_i_lock);\r\nlist_del(&cr->cr_list);\r\nspin_unlock(&sess->cr_i_lock);\r\n}\r\nint iscsit_remove_cmd_from_connection_recovery(\r\nstruct iscsi_cmd *cmd,\r\nstruct iscsi_session *sess)\r\n{\r\nstruct iscsi_conn_recovery *cr;\r\nif (!cmd->cr) {\r\npr_err("struct iscsi_conn_recovery pointer for ITT: 0x%08x"\r\n" is NULL!\n", cmd->init_task_tag);\r\nBUG();\r\n}\r\ncr = cmd->cr;\r\nlist_del(&cmd->i_conn_node);\r\nreturn --cr->cmd_count;\r\n}\r\nvoid iscsit_discard_cr_cmds_by_expstatsn(\r\nstruct iscsi_conn_recovery *cr,\r\nu32 exp_statsn)\r\n{\r\nu32 dropped_count = 0;\r\nstruct iscsi_cmd *cmd, *cmd_tmp;\r\nstruct iscsi_session *sess = cr->sess;\r\nspin_lock(&cr->conn_recovery_cmd_lock);\r\nlist_for_each_entry_safe(cmd, cmd_tmp,\r\n&cr->conn_recovery_cmd_list, i_conn_node) {\r\nif (((cmd->deferred_i_state != ISTATE_SENT_STATUS) &&\r\n(cmd->deferred_i_state != ISTATE_REMOVE)) ||\r\n(cmd->stat_sn >= exp_statsn)) {\r\ncontinue;\r\n}\r\ndropped_count++;\r\npr_debug("Dropping Acknowledged ITT: 0x%08x, StatSN:"\r\n" 0x%08x, CID: %hu.\n", cmd->init_task_tag,\r\ncmd->stat_sn, cr->cid);\r\niscsit_remove_cmd_from_connection_recovery(cmd, sess);\r\nspin_unlock(&cr->conn_recovery_cmd_lock);\r\niscsit_free_cmd(cmd);\r\nspin_lock(&cr->conn_recovery_cmd_lock);\r\n}\r\nspin_unlock(&cr->conn_recovery_cmd_lock);\r\npr_debug("Dropped %u total acknowledged commands on"\r\n" CID: %hu less than old ExpStatSN: 0x%08x\n",\r\ndropped_count, cr->cid, exp_statsn);\r\nif (!cr->cmd_count) {\r\npr_debug("No commands to be reassigned for failed"\r\n" connection CID: %hu on SID: %u\n",\r\ncr->cid, sess->sid);\r\niscsit_remove_inactive_connection_recovery_entry(cr, sess);\r\niscsit_attach_active_connection_recovery_entry(sess, cr);\r\npr_debug("iSCSI connection recovery successful for CID:"\r\n" %hu on SID: %u\n", cr->cid, sess->sid);\r\niscsit_remove_active_connection_recovery_entry(cr, sess);\r\n} else {\r\niscsit_remove_inactive_connection_recovery_entry(cr, sess);\r\niscsit_attach_active_connection_recovery_entry(sess, cr);\r\n}\r\n}\r\nint iscsit_discard_unacknowledged_ooo_cmdsns_for_conn(struct iscsi_conn *conn)\r\n{\r\nu32 dropped_count = 0;\r\nstruct iscsi_cmd *cmd, *cmd_tmp;\r\nstruct iscsi_ooo_cmdsn *ooo_cmdsn, *ooo_cmdsn_tmp;\r\nstruct iscsi_session *sess = conn->sess;\r\nmutex_lock(&sess->cmdsn_mutex);\r\nlist_for_each_entry_safe(ooo_cmdsn, ooo_cmdsn_tmp,\r\n&sess->sess_ooo_cmdsn_list, ooo_list) {\r\nif (ooo_cmdsn->cid != conn->cid)\r\ncontinue;\r\ndropped_count++;\r\npr_debug("Dropping unacknowledged CmdSN:"\r\n" 0x%08x during connection recovery on CID: %hu\n",\r\nooo_cmdsn->cmdsn, conn->cid);\r\niscsit_remove_ooo_cmdsn(sess, ooo_cmdsn);\r\n}\r\nmutex_unlock(&sess->cmdsn_mutex);\r\nspin_lock_bh(&conn->cmd_lock);\r\nlist_for_each_entry_safe(cmd, cmd_tmp, &conn->conn_cmd_list, i_conn_node) {\r\nif (!(cmd->cmd_flags & ICF_OOO_CMDSN))\r\ncontinue;\r\nlist_del(&cmd->i_conn_node);\r\nspin_unlock_bh(&conn->cmd_lock);\r\niscsit_free_cmd(cmd);\r\nspin_lock_bh(&conn->cmd_lock);\r\n}\r\nspin_unlock_bh(&conn->cmd_lock);\r\npr_debug("Dropped %u total unacknowledged commands on CID:"\r\n" %hu for ExpCmdSN: 0x%08x.\n", dropped_count, conn->cid,\r\nsess->exp_cmd_sn);\r\nreturn 0;\r\n}\r\nint iscsit_prepare_cmds_for_realligance(struct iscsi_conn *conn)\r\n{\r\nu32 cmd_count = 0;\r\nstruct iscsi_cmd *cmd, *cmd_tmp;\r\nstruct iscsi_conn_recovery *cr;\r\ncr = kzalloc(sizeof(struct iscsi_conn_recovery), GFP_KERNEL);\r\nif (!cr) {\r\npr_err("Unable to allocate memory for"\r\n" struct iscsi_conn_recovery.\n");\r\nreturn -1;\r\n}\r\nINIT_LIST_HEAD(&cr->cr_list);\r\nINIT_LIST_HEAD(&cr->conn_recovery_cmd_list);\r\nspin_lock_init(&cr->conn_recovery_cmd_lock);\r\nspin_lock_bh(&conn->cmd_lock);\r\nlist_for_each_entry_safe(cmd, cmd_tmp, &conn->conn_cmd_list, i_conn_node) {\r\nif ((cmd->iscsi_opcode != ISCSI_OP_SCSI_CMD) &&\r\n(cmd->iscsi_opcode != ISCSI_OP_NOOP_OUT)) {\r\npr_debug("Not performing realligence on"\r\n" Opcode: 0x%02x, ITT: 0x%08x, CmdSN: 0x%08x,"\r\n" CID: %hu\n", cmd->iscsi_opcode,\r\ncmd->init_task_tag, cmd->cmd_sn, conn->cid);\r\nlist_del(&cmd->i_conn_node);\r\nspin_unlock_bh(&conn->cmd_lock);\r\niscsit_free_cmd(cmd);\r\nspin_lock_bh(&conn->cmd_lock);\r\ncontinue;\r\n}\r\nif (!(cmd->cmd_flags & ICF_OOO_CMDSN) && !cmd->immediate_cmd &&\r\niscsi_sna_gte(cmd->cmd_sn, conn->sess->exp_cmd_sn)) {\r\nlist_del(&cmd->i_conn_node);\r\nspin_unlock_bh(&conn->cmd_lock);\r\niscsit_free_cmd(cmd);\r\nspin_lock_bh(&conn->cmd_lock);\r\ncontinue;\r\n}\r\ncmd_count++;\r\npr_debug("Preparing Opcode: 0x%02x, ITT: 0x%08x,"\r\n" CmdSN: 0x%08x, StatSN: 0x%08x, CID: %hu for"\r\n" realligence.\n", cmd->iscsi_opcode,\r\ncmd->init_task_tag, cmd->cmd_sn, cmd->stat_sn,\r\nconn->cid);\r\ncmd->deferred_i_state = cmd->i_state;\r\ncmd->i_state = ISTATE_IN_CONNECTION_RECOVERY;\r\nif (cmd->data_direction == DMA_TO_DEVICE)\r\niscsit_stop_dataout_timer(cmd);\r\ncmd->sess = conn->sess;\r\nlist_del(&cmd->i_conn_node);\r\nspin_unlock_bh(&conn->cmd_lock);\r\niscsit_free_all_datain_reqs(cmd);\r\ntransport_wait_for_tasks(&cmd->se_cmd);\r\nspin_lock(&cr->conn_recovery_cmd_lock);\r\nlist_add_tail(&cmd->i_conn_node, &cr->conn_recovery_cmd_list);\r\nspin_unlock(&cr->conn_recovery_cmd_lock);\r\nspin_lock_bh(&conn->cmd_lock);\r\ncmd->cr = cr;\r\ncmd->conn = NULL;\r\n}\r\nspin_unlock_bh(&conn->cmd_lock);\r\ncr->cid = conn->cid;\r\ncr->cmd_count = cmd_count;\r\ncr->maxrecvdatasegmentlength = conn->conn_ops->MaxRecvDataSegmentLength;\r\ncr->maxxmitdatasegmentlength = conn->conn_ops->MaxXmitDataSegmentLength;\r\ncr->sess = conn->sess;\r\niscsit_attach_inactive_connection_recovery_entry(conn->sess, cr);\r\nreturn 0;\r\n}\r\nint iscsit_connection_recovery_transport_reset(struct iscsi_conn *conn)\r\n{\r\natomic_set(&conn->connection_recovery, 1);\r\nif (iscsit_close_connection(conn) < 0)\r\nreturn -1;\r\nreturn 0;\r\n}
