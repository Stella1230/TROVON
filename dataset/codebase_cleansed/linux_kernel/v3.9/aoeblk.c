static ssize_t aoedisk_show_state(struct device *dev,\r\nstruct device_attribute *attr, char *page)\r\n{\r\nstruct gendisk *disk = dev_to_disk(dev);\r\nstruct aoedev *d = disk->private_data;\r\nreturn snprintf(page, PAGE_SIZE,\r\n"%s%s\n",\r\n(d->flags & DEVFL_UP) ? "up" : "down",\r\n(d->flags & DEVFL_KICKME) ? ",kickme" :\r\n(d->nopen && !(d->flags & DEVFL_UP)) ? ",closewait" : "");\r\n}\r\nstatic ssize_t aoedisk_show_mac(struct device *dev,\r\nstruct device_attribute *attr, char *page)\r\n{\r\nstruct gendisk *disk = dev_to_disk(dev);\r\nstruct aoedev *d = disk->private_data;\r\nstruct aoetgt *t = d->targets[0];\r\nif (t == NULL)\r\nreturn snprintf(page, PAGE_SIZE, "none\n");\r\nreturn snprintf(page, PAGE_SIZE, "%pm\n", t->addr);\r\n}\r\nstatic ssize_t aoedisk_show_netif(struct device *dev,\r\nstruct device_attribute *attr, char *page)\r\n{\r\nstruct gendisk *disk = dev_to_disk(dev);\r\nstruct aoedev *d = disk->private_data;\r\nstruct net_device *nds[8], **nd, **nnd, **ne;\r\nstruct aoetgt **t, **te;\r\nstruct aoeif *ifp, *e;\r\nchar *p;\r\nmemset(nds, 0, sizeof nds);\r\nnd = nds;\r\nne = nd + ARRAY_SIZE(nds);\r\nt = d->targets;\r\nte = t + d->ntargets;\r\nfor (; t < te && *t; t++) {\r\nifp = (*t)->ifs;\r\ne = ifp + NAOEIFS;\r\nfor (; ifp < e && ifp->nd; ifp++) {\r\nfor (nnd = nds; nnd < nd; nnd++)\r\nif (*nnd == ifp->nd)\r\nbreak;\r\nif (nnd == nd && nd != ne)\r\n*nd++ = ifp->nd;\r\n}\r\n}\r\nne = nd;\r\nnd = nds;\r\nif (*nd == NULL)\r\nreturn snprintf(page, PAGE_SIZE, "none\n");\r\nfor (p = page; nd < ne; nd++)\r\np += snprintf(p, PAGE_SIZE - (p-page), "%s%s",\r\np == page ? "" : ",", (*nd)->name);\r\np += snprintf(p, PAGE_SIZE - (p-page), "\n");\r\nreturn p-page;\r\n}\r\nstatic ssize_t aoedisk_show_fwver(struct device *dev,\r\nstruct device_attribute *attr, char *page)\r\n{\r\nstruct gendisk *disk = dev_to_disk(dev);\r\nstruct aoedev *d = disk->private_data;\r\nreturn snprintf(page, PAGE_SIZE, "0x%04x\n", (unsigned int) d->fw_ver);\r\n}\r\nstatic ssize_t aoedisk_show_payload(struct device *dev,\r\nstruct device_attribute *attr, char *page)\r\n{\r\nstruct gendisk *disk = dev_to_disk(dev);\r\nstruct aoedev *d = disk->private_data;\r\nreturn snprintf(page, PAGE_SIZE, "%lu\n", d->maxbcnt);\r\n}\r\nstatic int\r\naoedisk_add_sysfs(struct aoedev *d)\r\n{\r\nreturn sysfs_create_group(&disk_to_dev(d->gd)->kobj, &attr_group);\r\n}\r\nvoid\r\naoedisk_rm_sysfs(struct aoedev *d)\r\n{\r\nsysfs_remove_group(&disk_to_dev(d->gd)->kobj, &attr_group);\r\n}\r\nstatic int\r\naoeblk_open(struct block_device *bdev, fmode_t mode)\r\n{\r\nstruct aoedev *d = bdev->bd_disk->private_data;\r\nulong flags;\r\nif (!virt_addr_valid(d)) {\r\npr_crit("aoe: invalid device pointer in %s\n",\r\n__func__);\r\nWARN_ON(1);\r\nreturn -ENODEV;\r\n}\r\nif (!(d->flags & DEVFL_UP) || d->flags & DEVFL_TKILL)\r\nreturn -ENODEV;\r\nmutex_lock(&aoeblk_mutex);\r\nspin_lock_irqsave(&d->lock, flags);\r\nif (d->flags & DEVFL_UP && !(d->flags & DEVFL_TKILL)) {\r\nd->nopen++;\r\nspin_unlock_irqrestore(&d->lock, flags);\r\nmutex_unlock(&aoeblk_mutex);\r\nreturn 0;\r\n}\r\nspin_unlock_irqrestore(&d->lock, flags);\r\nmutex_unlock(&aoeblk_mutex);\r\nreturn -ENODEV;\r\n}\r\nstatic int\r\naoeblk_release(struct gendisk *disk, fmode_t mode)\r\n{\r\nstruct aoedev *d = disk->private_data;\r\nulong flags;\r\nspin_lock_irqsave(&d->lock, flags);\r\nif (--d->nopen == 0) {\r\nspin_unlock_irqrestore(&d->lock, flags);\r\naoecmd_cfg(d->aoemajor, d->aoeminor);\r\nreturn 0;\r\n}\r\nspin_unlock_irqrestore(&d->lock, flags);\r\nreturn 0;\r\n}\r\nstatic void\r\naoeblk_request(struct request_queue *q)\r\n{\r\nstruct aoedev *d;\r\nstruct request *rq;\r\nd = q->queuedata;\r\nif ((d->flags & DEVFL_UP) == 0) {\r\npr_info_ratelimited("aoe: device %ld.%d is not up\n",\r\nd->aoemajor, d->aoeminor);\r\nwhile ((rq = blk_peek_request(q))) {\r\nblk_start_request(rq);\r\naoe_end_request(d, rq, 1);\r\n}\r\nreturn;\r\n}\r\naoecmd_work(d);\r\n}\r\nstatic int\r\naoeblk_getgeo(struct block_device *bdev, struct hd_geometry *geo)\r\n{\r\nstruct aoedev *d = bdev->bd_disk->private_data;\r\nif ((d->flags & DEVFL_UP) == 0) {\r\nprintk(KERN_ERR "aoe: disk not up\n");\r\nreturn -ENODEV;\r\n}\r\ngeo->cylinders = d->geo.cylinders;\r\ngeo->heads = d->geo.heads;\r\ngeo->sectors = d->geo.sectors;\r\nreturn 0;\r\n}\r\nstatic int\r\naoeblk_ioctl(struct block_device *bdev, fmode_t mode, uint cmd, ulong arg)\r\n{\r\nstruct aoedev *d;\r\nif (!arg)\r\nreturn -EINVAL;\r\nd = bdev->bd_disk->private_data;\r\nif ((d->flags & DEVFL_UP) == 0) {\r\npr_err("aoe: disk not up\n");\r\nreturn -ENODEV;\r\n}\r\nif (cmd == HDIO_GET_IDENTITY) {\r\nif (!copy_to_user((void __user *) arg, &d->ident,\r\nsizeof(d->ident)))\r\nreturn 0;\r\nreturn -EFAULT;\r\n}\r\nif (cmd != SG_IO)\r\npr_info("aoe: unknown ioctl 0x%x\n", cmd);\r\nreturn -ENOTTY;\r\n}\r\nvoid\r\naoeblk_gdalloc(void *vp)\r\n{\r\nstruct aoedev *d = vp;\r\nstruct gendisk *gd;\r\nmempool_t *mp;\r\nstruct request_queue *q;\r\nenum { KB = 1024, MB = KB * KB, READ_AHEAD = 2 * MB, };\r\nulong flags;\r\nint late = 0;\r\nspin_lock_irqsave(&d->lock, flags);\r\nif (d->flags & DEVFL_GDALLOC\r\n&& !(d->flags & DEVFL_TKILL)\r\n&& !(d->flags & DEVFL_GD_NOW))\r\nd->flags |= DEVFL_GD_NOW;\r\nelse\r\nlate = 1;\r\nspin_unlock_irqrestore(&d->lock, flags);\r\nif (late)\r\nreturn;\r\ngd = alloc_disk(AOE_PARTITIONS);\r\nif (gd == NULL) {\r\npr_err("aoe: cannot allocate disk structure for %ld.%d\n",\r\nd->aoemajor, d->aoeminor);\r\ngoto err;\r\n}\r\nmp = mempool_create(MIN_BUFS, mempool_alloc_slab, mempool_free_slab,\r\nbuf_pool_cache);\r\nif (mp == NULL) {\r\nprintk(KERN_ERR "aoe: cannot allocate bufpool for %ld.%d\n",\r\nd->aoemajor, d->aoeminor);\r\ngoto err_disk;\r\n}\r\nq = blk_init_queue(aoeblk_request, &d->lock);\r\nif (q == NULL) {\r\npr_err("aoe: cannot allocate block queue for %ld.%d\n",\r\nd->aoemajor, d->aoeminor);\r\ngoto err_mempool;\r\n}\r\nspin_lock_irqsave(&d->lock, flags);\r\nWARN_ON(!(d->flags & DEVFL_GD_NOW));\r\nWARN_ON(!(d->flags & DEVFL_GDALLOC));\r\nWARN_ON(d->flags & DEVFL_TKILL);\r\nWARN_ON(d->gd);\r\nWARN_ON(d->flags & DEVFL_UP);\r\nblk_queue_max_hw_sectors(q, BLK_DEF_MAX_SECTORS);\r\nq->backing_dev_info.name = "aoe";\r\nq->backing_dev_info.ra_pages = READ_AHEAD / PAGE_CACHE_SIZE;\r\nd->bufpool = mp;\r\nd->blkq = gd->queue = q;\r\nq->queuedata = d;\r\nd->gd = gd;\r\nif (aoe_maxsectors)\r\nblk_queue_max_hw_sectors(q, aoe_maxsectors);\r\ngd->major = AOE_MAJOR;\r\ngd->first_minor = d->sysminor;\r\ngd->fops = &aoe_bdops;\r\ngd->private_data = d;\r\nset_capacity(gd, d->ssize);\r\nsnprintf(gd->disk_name, sizeof gd->disk_name, "etherd/e%ld.%d",\r\nd->aoemajor, d->aoeminor);\r\nd->flags &= ~DEVFL_GDALLOC;\r\nd->flags |= DEVFL_UP;\r\nspin_unlock_irqrestore(&d->lock, flags);\r\nadd_disk(gd);\r\naoedisk_add_sysfs(d);\r\nspin_lock_irqsave(&d->lock, flags);\r\nWARN_ON(!(d->flags & DEVFL_GD_NOW));\r\nd->flags &= ~DEVFL_GD_NOW;\r\nspin_unlock_irqrestore(&d->lock, flags);\r\nreturn;\r\nerr_mempool:\r\nmempool_destroy(mp);\r\nerr_disk:\r\nput_disk(gd);\r\nerr:\r\nspin_lock_irqsave(&d->lock, flags);\r\nd->flags &= ~DEVFL_GD_NOW;\r\nschedule_work(&d->work);\r\nspin_unlock_irqrestore(&d->lock, flags);\r\n}\r\nvoid\r\naoeblk_exit(void)\r\n{\r\nkmem_cache_destroy(buf_pool_cache);\r\n}\r\nint __init\r\naoeblk_init(void)\r\n{\r\nbuf_pool_cache = kmem_cache_create("aoe_bufs",\r\nsizeof(struct buf),\r\n0, 0, NULL);\r\nif (buf_pool_cache == NULL)\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}
