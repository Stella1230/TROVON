static inline int is_imx1_fb(struct imxfb_info *fbi)\r\n{\r\nreturn fbi->devtype == IMX1_FB;\r\n}\r\nstatic inline u_int chan_to_field(u_int chan, struct fb_bitfield *bf)\r\n{\r\nchan &= 0xffff;\r\nchan >>= 16 - bf->length;\r\nreturn chan << bf->offset;\r\n}\r\nstatic int imxfb_setpalettereg(u_int regno, u_int red, u_int green, u_int blue,\r\nu_int trans, struct fb_info *info)\r\n{\r\nstruct imxfb_info *fbi = info->par;\r\nu_int val, ret = 1;\r\n#define CNVT_TOHW(val,width) ((((val)<<(width))+0x7FFF-(val))>>16)\r\nif (regno < fbi->palette_size) {\r\nval = (CNVT_TOHW(red, 4) << 8) |\r\n(CNVT_TOHW(green,4) << 4) |\r\nCNVT_TOHW(blue, 4);\r\nwritel(val, fbi->regs + 0x800 + (regno << 2));\r\nret = 0;\r\n}\r\nreturn ret;\r\n}\r\nstatic int imxfb_setcolreg(u_int regno, u_int red, u_int green, u_int blue,\r\nu_int trans, struct fb_info *info)\r\n{\r\nstruct imxfb_info *fbi = info->par;\r\nunsigned int val;\r\nint ret = 1;\r\nif (fbi->cmap_inverse) {\r\nred = 0xffff - red;\r\ngreen = 0xffff - green;\r\nblue = 0xffff - blue;\r\n}\r\nif (info->var.grayscale)\r\nred = green = blue = (19595 * red + 38470 * green +\r\n7471 * blue) >> 16;\r\nswitch (info->fix.visual) {\r\ncase FB_VISUAL_TRUECOLOR:\r\nif (regno < 16) {\r\nu32 *pal = info->pseudo_palette;\r\nval = chan_to_field(red, &info->var.red);\r\nval |= chan_to_field(green, &info->var.green);\r\nval |= chan_to_field(blue, &info->var.blue);\r\npal[regno] = val;\r\nret = 0;\r\n}\r\nbreak;\r\ncase FB_VISUAL_STATIC_PSEUDOCOLOR:\r\ncase FB_VISUAL_PSEUDOCOLOR:\r\nret = imxfb_setpalettereg(regno, red, green, blue, trans, info);\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic const struct imx_fb_videomode *imxfb_find_mode(struct imxfb_info *fbi)\r\n{\r\nstruct imx_fb_videomode *m;\r\nint i;\r\nfor (i = 0, m = &fbi->mode[0]; i < fbi->num_modes; i++, m++) {\r\nif (!strcmp(m->mode.name, fb_mode))\r\nreturn m;\r\n}\r\nreturn NULL;\r\n}\r\nstatic int imxfb_check_var(struct fb_var_screeninfo *var, struct fb_info *info)\r\n{\r\nstruct imxfb_info *fbi = info->par;\r\nstruct imxfb_rgb *rgb;\r\nconst struct imx_fb_videomode *imxfb_mode;\r\nunsigned long lcd_clk;\r\nunsigned long long tmp;\r\nu32 pcr = 0;\r\nif (var->xres < MIN_XRES)\r\nvar->xres = MIN_XRES;\r\nif (var->yres < MIN_YRES)\r\nvar->yres = MIN_YRES;\r\nimxfb_mode = imxfb_find_mode(fbi);\r\nif (!imxfb_mode)\r\nreturn -EINVAL;\r\nvar->xres = imxfb_mode->mode.xres;\r\nvar->yres = imxfb_mode->mode.yres;\r\nvar->bits_per_pixel = imxfb_mode->bpp;\r\nvar->pixclock = imxfb_mode->mode.pixclock;\r\nvar->hsync_len = imxfb_mode->mode.hsync_len;\r\nvar->left_margin = imxfb_mode->mode.left_margin;\r\nvar->right_margin = imxfb_mode->mode.right_margin;\r\nvar->vsync_len = imxfb_mode->mode.vsync_len;\r\nvar->upper_margin = imxfb_mode->mode.upper_margin;\r\nvar->lower_margin = imxfb_mode->mode.lower_margin;\r\nvar->sync = imxfb_mode->mode.sync;\r\nvar->xres_virtual = max(var->xres_virtual, var->xres);\r\nvar->yres_virtual = max(var->yres_virtual, var->yres);\r\npr_debug("var->bits_per_pixel=%d\n", var->bits_per_pixel);\r\nlcd_clk = clk_get_rate(fbi->clk_per);\r\ntmp = var->pixclock * (unsigned long long)lcd_clk;\r\ndo_div(tmp, 1000000);\r\nif (do_div(tmp, 1000000) > 500000)\r\ntmp++;\r\npcr = (unsigned int)tmp;\r\nif (--pcr > 0x3F) {\r\npcr = 0x3F;\r\nprintk(KERN_WARNING "Must limit pixel clock to %luHz\n",\r\nlcd_clk / pcr);\r\n}\r\nswitch (var->bits_per_pixel) {\r\ncase 32:\r\npcr |= PCR_BPIX_18;\r\nrgb = &def_rgb_18;\r\nbreak;\r\ncase 16:\r\ndefault:\r\nif (is_imx1_fb(fbi))\r\npcr |= PCR_BPIX_12;\r\nelse\r\npcr |= PCR_BPIX_16;\r\nif (imxfb_mode->pcr & PCR_TFT)\r\nrgb = &def_rgb_16_tft;\r\nelse\r\nrgb = &def_rgb_16_stn;\r\nbreak;\r\ncase 8:\r\npcr |= PCR_BPIX_8;\r\nrgb = &def_rgb_8;\r\nbreak;\r\n}\r\npcr |= imxfb_mode->pcr & ~(0x3f | (7 << 25));\r\nfbi->pcr = pcr;\r\nvar->red = rgb->red;\r\nvar->green = rgb->green;\r\nvar->blue = rgb->blue;\r\nvar->transp = rgb->transp;\r\npr_debug("RGBT length = %d:%d:%d:%d\n",\r\nvar->red.length, var->green.length, var->blue.length,\r\nvar->transp.length);\r\npr_debug("RGBT offset = %d:%d:%d:%d\n",\r\nvar->red.offset, var->green.offset, var->blue.offset,\r\nvar->transp.offset);\r\nreturn 0;\r\n}\r\nstatic int imxfb_set_par(struct fb_info *info)\r\n{\r\nstruct imxfb_info *fbi = info->par;\r\nstruct fb_var_screeninfo *var = &info->var;\r\nif (var->bits_per_pixel == 16 || var->bits_per_pixel == 32)\r\ninfo->fix.visual = FB_VISUAL_TRUECOLOR;\r\nelse if (!fbi->cmap_static)\r\ninfo->fix.visual = FB_VISUAL_PSEUDOCOLOR;\r\nelse {\r\ninfo->fix.visual = FB_VISUAL_STATIC_PSEUDOCOLOR;\r\n}\r\ninfo->fix.line_length = var->xres_virtual * var->bits_per_pixel / 8;\r\nfbi->palette_size = var->bits_per_pixel == 8 ? 256 : 16;\r\nimxfb_activate_var(var, info);\r\nreturn 0;\r\n}\r\nstatic int imxfb_bl_get_brightness(struct backlight_device *bl)\r\n{\r\nstruct imxfb_info *fbi = bl_get_data(bl);\r\nreturn readl(fbi->regs + LCDC_PWMR) & 0xFF;\r\n}\r\nstatic int imxfb_bl_update_status(struct backlight_device *bl)\r\n{\r\nstruct imxfb_info *fbi = bl_get_data(bl);\r\nint brightness = bl->props.brightness;\r\nif (bl->props.power != FB_BLANK_UNBLANK)\r\nbrightness = 0;\r\nif (bl->props.fb_blank != FB_BLANK_UNBLANK)\r\nbrightness = 0;\r\nfbi->pwmr = (fbi->pwmr & ~0xFF) | brightness;\r\nif (bl->props.fb_blank != FB_BLANK_UNBLANK) {\r\nclk_prepare_enable(fbi->clk_ipg);\r\nclk_prepare_enable(fbi->clk_ahb);\r\nclk_prepare_enable(fbi->clk_per);\r\n}\r\nwritel(fbi->pwmr, fbi->regs + LCDC_PWMR);\r\nif (bl->props.fb_blank != FB_BLANK_UNBLANK) {\r\nclk_disable_unprepare(fbi->clk_per);\r\nclk_disable_unprepare(fbi->clk_ahb);\r\nclk_disable_unprepare(fbi->clk_ipg);\r\n}\r\nreturn 0;\r\n}\r\nstatic void imxfb_init_backlight(struct imxfb_info *fbi)\r\n{\r\nstruct backlight_properties props;\r\nstruct backlight_device *bl;\r\nif (fbi->bl)\r\nreturn;\r\nmemset(&props, 0, sizeof(struct backlight_properties));\r\nprops.max_brightness = 0xff;\r\nprops.type = BACKLIGHT_RAW;\r\nwritel(fbi->pwmr, fbi->regs + LCDC_PWMR);\r\nbl = backlight_device_register("imxfb-bl", &fbi->pdev->dev, fbi,\r\n&imxfb_lcdc_bl_ops, &props);\r\nif (IS_ERR(bl)) {\r\ndev_err(&fbi->pdev->dev, "error %ld on backlight register\n",\r\nPTR_ERR(bl));\r\nreturn;\r\n}\r\nfbi->bl = bl;\r\nbl->props.power = FB_BLANK_UNBLANK;\r\nbl->props.fb_blank = FB_BLANK_UNBLANK;\r\nbl->props.brightness = imxfb_bl_get_brightness(bl);\r\n}\r\nstatic void imxfb_exit_backlight(struct imxfb_info *fbi)\r\n{\r\nif (fbi->bl)\r\nbacklight_device_unregister(fbi->bl);\r\n}\r\nstatic void imxfb_enable_controller(struct imxfb_info *fbi)\r\n{\r\nif (fbi->enabled)\r\nreturn;\r\npr_debug("Enabling LCD controller\n");\r\nwritel(fbi->screen_dma, fbi->regs + LCDC_SSA);\r\nwritel(0x00000000, fbi->regs + LCDC_POS);\r\nwritel(readl(fbi->regs + LCDC_CPOS) & ~(CPOS_CC0 | CPOS_CC1),\r\nfbi->regs + LCDC_CPOS);\r\nwritel(RMCR_LCDC_EN_MX1, fbi->regs + LCDC_RMCR);\r\nclk_prepare_enable(fbi->clk_ipg);\r\nclk_prepare_enable(fbi->clk_ahb);\r\nclk_prepare_enable(fbi->clk_per);\r\nfbi->enabled = true;\r\nif (fbi->backlight_power)\r\nfbi->backlight_power(1);\r\nif (fbi->lcd_power)\r\nfbi->lcd_power(1);\r\n}\r\nstatic void imxfb_disable_controller(struct imxfb_info *fbi)\r\n{\r\nif (!fbi->enabled)\r\nreturn;\r\npr_debug("Disabling LCD controller\n");\r\nif (fbi->backlight_power)\r\nfbi->backlight_power(0);\r\nif (fbi->lcd_power)\r\nfbi->lcd_power(0);\r\nclk_disable_unprepare(fbi->clk_per);\r\nclk_disable_unprepare(fbi->clk_ipg);\r\nclk_disable_unprepare(fbi->clk_ahb);\r\nfbi->enabled = false;\r\nwritel(0, fbi->regs + LCDC_RMCR);\r\n}\r\nstatic int imxfb_blank(int blank, struct fb_info *info)\r\n{\r\nstruct imxfb_info *fbi = info->par;\r\npr_debug("imxfb_blank: blank=%d\n", blank);\r\nswitch (blank) {\r\ncase FB_BLANK_POWERDOWN:\r\ncase FB_BLANK_VSYNC_SUSPEND:\r\ncase FB_BLANK_HSYNC_SUSPEND:\r\ncase FB_BLANK_NORMAL:\r\nimxfb_disable_controller(fbi);\r\nbreak;\r\ncase FB_BLANK_UNBLANK:\r\nimxfb_enable_controller(fbi);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int imxfb_activate_var(struct fb_var_screeninfo *var, struct fb_info *info)\r\n{\r\nstruct imxfb_info *fbi = info->par;\r\nu32 ymax_mask = is_imx1_fb(fbi) ? YMAX_MASK_IMX1 : YMAX_MASK_IMX21;\r\npr_debug("var: xres=%d hslen=%d lm=%d rm=%d\n",\r\nvar->xres, var->hsync_len,\r\nvar->left_margin, var->right_margin);\r\npr_debug("var: yres=%d vslen=%d um=%d bm=%d\n",\r\nvar->yres, var->vsync_len,\r\nvar->upper_margin, var->lower_margin);\r\n#if DEBUG_VAR\r\nif (var->xres < 16 || var->xres > 1024)\r\nprintk(KERN_ERR "%s: invalid xres %d\n",\r\ninfo->fix.id, var->xres);\r\nif (var->hsync_len < 1 || var->hsync_len > 64)\r\nprintk(KERN_ERR "%s: invalid hsync_len %d\n",\r\ninfo->fix.id, var->hsync_len);\r\nif (var->left_margin > 255)\r\nprintk(KERN_ERR "%s: invalid left_margin %d\n",\r\ninfo->fix.id, var->left_margin);\r\nif (var->right_margin > 255)\r\nprintk(KERN_ERR "%s: invalid right_margin %d\n",\r\ninfo->fix.id, var->right_margin);\r\nif (var->yres < 1 || var->yres > ymax_mask)\r\nprintk(KERN_ERR "%s: invalid yres %d\n",\r\ninfo->fix.id, var->yres);\r\nif (var->vsync_len > 100)\r\nprintk(KERN_ERR "%s: invalid vsync_len %d\n",\r\ninfo->fix.id, var->vsync_len);\r\nif (var->upper_margin > 63)\r\nprintk(KERN_ERR "%s: invalid upper_margin %d\n",\r\ninfo->fix.id, var->upper_margin);\r\nif (var->lower_margin > 255)\r\nprintk(KERN_ERR "%s: invalid lower_margin %d\n",\r\ninfo->fix.id, var->lower_margin);\r\n#endif\r\nwritel(VPW_VPW(var->xres * var->bits_per_pixel / 8 / 4),\r\nfbi->regs + LCDC_VPW);\r\nwritel(HCR_H_WIDTH(var->hsync_len - 1) |\r\nHCR_H_WAIT_1(var->right_margin - 1) |\r\nHCR_H_WAIT_2(var->left_margin - 3),\r\nfbi->regs + LCDC_HCR);\r\nwritel(VCR_V_WIDTH(var->vsync_len) |\r\nVCR_V_WAIT_1(var->lower_margin) |\r\nVCR_V_WAIT_2(var->upper_margin),\r\nfbi->regs + LCDC_VCR);\r\nwritel(SIZE_XMAX(var->xres) | (var->yres & ymax_mask),\r\nfbi->regs + LCDC_SIZE);\r\nwritel(fbi->pcr, fbi->regs + LCDC_PCR);\r\n#ifndef PWMR_BACKLIGHT_AVAILABLE\r\nwritel(fbi->pwmr, fbi->regs + LCDC_PWMR);\r\n#endif\r\nwritel(fbi->lscr1, fbi->regs + LCDC_LSCR1);\r\nwritel(fbi->dmacr, fbi->regs + LCDC_DMACR);\r\nreturn 0;\r\n}\r\nstatic int imxfb_suspend(struct platform_device *dev, pm_message_t state)\r\n{\r\nstruct fb_info *info = platform_get_drvdata(dev);\r\nstruct imxfb_info *fbi = info->par;\r\npr_debug("%s\n", __func__);\r\nimxfb_disable_controller(fbi);\r\nreturn 0;\r\n}\r\nstatic int imxfb_resume(struct platform_device *dev)\r\n{\r\nstruct fb_info *info = platform_get_drvdata(dev);\r\nstruct imxfb_info *fbi = info->par;\r\npr_debug("%s\n", __func__);\r\nimxfb_enable_controller(fbi);\r\nreturn 0;\r\n}\r\nstatic int __init imxfb_init_fbinfo(struct platform_device *pdev)\r\n{\r\nstruct imx_fb_platform_data *pdata = pdev->dev.platform_data;\r\nstruct fb_info *info = dev_get_drvdata(&pdev->dev);\r\nstruct imxfb_info *fbi = info->par;\r\nstruct imx_fb_videomode *m;\r\nint i;\r\npr_debug("%s\n",__func__);\r\ninfo->pseudo_palette = kmalloc(sizeof(u32) * 16, GFP_KERNEL);\r\nif (!info->pseudo_palette)\r\nreturn -ENOMEM;\r\nmemset(fbi, 0, sizeof(struct imxfb_info));\r\nfbi->devtype = pdev->id_entry->driver_data;\r\nstrlcpy(info->fix.id, IMX_NAME, sizeof(info->fix.id));\r\ninfo->fix.type = FB_TYPE_PACKED_PIXELS;\r\ninfo->fix.type_aux = 0;\r\ninfo->fix.xpanstep = 0;\r\ninfo->fix.ypanstep = 0;\r\ninfo->fix.ywrapstep = 0;\r\ninfo->fix.accel = FB_ACCEL_NONE;\r\ninfo->var.nonstd = 0;\r\ninfo->var.activate = FB_ACTIVATE_NOW;\r\ninfo->var.height = -1;\r\ninfo->var.width = -1;\r\ninfo->var.accel_flags = 0;\r\ninfo->var.vmode = FB_VMODE_NONINTERLACED;\r\ninfo->fbops = &imxfb_ops;\r\ninfo->flags = FBINFO_FLAG_DEFAULT |\r\nFBINFO_READS_FAST;\r\ninfo->var.grayscale = pdata->cmap_greyscale;\r\nfbi->cmap_inverse = pdata->cmap_inverse;\r\nfbi->cmap_static = pdata->cmap_static;\r\nfbi->lscr1 = pdata->lscr1;\r\nfbi->dmacr = pdata->dmacr;\r\nfbi->pwmr = pdata->pwmr;\r\nfbi->lcd_power = pdata->lcd_power;\r\nfbi->backlight_power = pdata->backlight_power;\r\nfor (i = 0, m = &pdata->mode[0]; i < pdata->num_modes; i++, m++)\r\ninfo->fix.smem_len = max_t(size_t, info->fix.smem_len,\r\nm->mode.xres * m->mode.yres * m->bpp / 8);\r\nreturn 0;\r\n}\r\nstatic int __init imxfb_probe(struct platform_device *pdev)\r\n{\r\nstruct imxfb_info *fbi;\r\nstruct fb_info *info;\r\nstruct imx_fb_platform_data *pdata;\r\nstruct resource *res;\r\nint ret, i;\r\ndev_info(&pdev->dev, "i.MX Framebuffer driver\n");\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!res)\r\nreturn -ENODEV;\r\npdata = pdev->dev.platform_data;\r\nif (!pdata) {\r\ndev_err(&pdev->dev,"No platform_data available\n");\r\nreturn -ENOMEM;\r\n}\r\ninfo = framebuffer_alloc(sizeof(struct imxfb_info), &pdev->dev);\r\nif (!info)\r\nreturn -ENOMEM;\r\nfbi = info->par;\r\nif (!fb_mode)\r\nfb_mode = pdata->mode[0].mode.name;\r\nplatform_set_drvdata(pdev, info);\r\nret = imxfb_init_fbinfo(pdev);\r\nif (ret < 0)\r\ngoto failed_init;\r\nres = request_mem_region(res->start, resource_size(res),\r\nDRIVER_NAME);\r\nif (!res) {\r\nret = -EBUSY;\r\ngoto failed_req;\r\n}\r\nfbi->clk_ipg = devm_clk_get(&pdev->dev, "ipg");\r\nif (IS_ERR(fbi->clk_ipg)) {\r\nret = PTR_ERR(fbi->clk_ipg);\r\ngoto failed_getclock;\r\n}\r\nfbi->clk_ahb = devm_clk_get(&pdev->dev, "ahb");\r\nif (IS_ERR(fbi->clk_ahb)) {\r\nret = PTR_ERR(fbi->clk_ahb);\r\ngoto failed_getclock;\r\n}\r\nfbi->clk_per = devm_clk_get(&pdev->dev, "per");\r\nif (IS_ERR(fbi->clk_per)) {\r\nret = PTR_ERR(fbi->clk_per);\r\ngoto failed_getclock;\r\n}\r\nfbi->regs = ioremap(res->start, resource_size(res));\r\nif (fbi->regs == NULL) {\r\ndev_err(&pdev->dev, "Cannot map frame buffer registers\n");\r\nret = -ENOMEM;\r\ngoto failed_ioremap;\r\n}\r\nif (!pdata->fixed_screen_cpu) {\r\nfbi->map_size = PAGE_ALIGN(info->fix.smem_len);\r\nfbi->map_cpu = dma_alloc_writecombine(&pdev->dev,\r\nfbi->map_size, &fbi->map_dma, GFP_KERNEL);\r\nif (!fbi->map_cpu) {\r\ndev_err(&pdev->dev, "Failed to allocate video RAM: %d\n", ret);\r\nret = -ENOMEM;\r\ngoto failed_map;\r\n}\r\ninfo->screen_base = fbi->map_cpu;\r\nfbi->screen_cpu = fbi->map_cpu;\r\nfbi->screen_dma = fbi->map_dma;\r\ninfo->fix.smem_start = fbi->screen_dma;\r\n} else {\r\nfbi->map_cpu = pdata->fixed_screen_cpu;\r\nfbi->map_dma = pdata->fixed_screen_dma;\r\ninfo->screen_base = fbi->map_cpu;\r\nfbi->screen_cpu = fbi->map_cpu;\r\nfbi->screen_dma = fbi->map_dma;\r\ninfo->fix.smem_start = fbi->screen_dma;\r\n}\r\nif (pdata->init) {\r\nret = pdata->init(fbi->pdev);\r\nif (ret)\r\ngoto failed_platform_init;\r\n}\r\nfbi->mode = pdata->mode;\r\nfbi->num_modes = pdata->num_modes;\r\nINIT_LIST_HEAD(&info->modelist);\r\nfor (i = 0; i < pdata->num_modes; i++)\r\nfb_add_videomode(&pdata->mode[i].mode, &info->modelist);\r\nimxfb_check_var(&info->var, info);\r\nret = fb_alloc_cmap(&info->cmap, 1 << info->var.bits_per_pixel, 0);\r\nif (ret < 0)\r\ngoto failed_cmap;\r\nimxfb_set_par(info);\r\nret = register_framebuffer(info);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "failed to register framebuffer\n");\r\ngoto failed_register;\r\n}\r\nimxfb_enable_controller(fbi);\r\nfbi->pdev = pdev;\r\n#ifdef PWMR_BACKLIGHT_AVAILABLE\r\nimxfb_init_backlight(fbi);\r\n#endif\r\nreturn 0;\r\nfailed_register:\r\nfb_dealloc_cmap(&info->cmap);\r\nfailed_cmap:\r\nif (pdata->exit)\r\npdata->exit(fbi->pdev);\r\nfailed_platform_init:\r\nif (!pdata->fixed_screen_cpu)\r\ndma_free_writecombine(&pdev->dev,fbi->map_size,fbi->map_cpu,\r\nfbi->map_dma);\r\nfailed_map:\r\niounmap(fbi->regs);\r\nfailed_ioremap:\r\nfailed_getclock:\r\nrelease_mem_region(res->start, resource_size(res));\r\nfailed_req:\r\nkfree(info->pseudo_palette);\r\nfailed_init:\r\nplatform_set_drvdata(pdev, NULL);\r\nframebuffer_release(info);\r\nreturn ret;\r\n}\r\nstatic int imxfb_remove(struct platform_device *pdev)\r\n{\r\nstruct imx_fb_platform_data *pdata;\r\nstruct fb_info *info = platform_get_drvdata(pdev);\r\nstruct imxfb_info *fbi = info->par;\r\nstruct resource *res;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nimxfb_disable_controller(fbi);\r\n#ifdef PWMR_BACKLIGHT_AVAILABLE\r\nimxfb_exit_backlight(fbi);\r\n#endif\r\nunregister_framebuffer(info);\r\npdata = pdev->dev.platform_data;\r\nif (pdata->exit)\r\npdata->exit(fbi->pdev);\r\nfb_dealloc_cmap(&info->cmap);\r\nkfree(info->pseudo_palette);\r\nframebuffer_release(info);\r\niounmap(fbi->regs);\r\nrelease_mem_region(res->start, resource_size(res));\r\nplatform_set_drvdata(pdev, NULL);\r\nreturn 0;\r\n}\r\nvoid imxfb_shutdown(struct platform_device * dev)\r\n{\r\nstruct fb_info *info = platform_get_drvdata(dev);\r\nstruct imxfb_info *fbi = info->par;\r\nimxfb_disable_controller(fbi);\r\n}\r\nstatic int imxfb_setup(void)\r\n{\r\n#ifndef MODULE\r\nchar *opt, *options = NULL;\r\nif (fb_get_options("imxfb", &options))\r\nreturn -ENODEV;\r\nif (!options || !*options)\r\nreturn 0;\r\nwhile ((opt = strsep(&options, ",")) != NULL) {\r\nif (!*opt)\r\ncontinue;\r\nelse\r\nfb_mode = opt;\r\n}\r\n#endif\r\nreturn 0;\r\n}\r\nint __init imxfb_init(void)\r\n{\r\nint ret = imxfb_setup();\r\nif (ret < 0)\r\nreturn ret;\r\nreturn platform_driver_probe(&imxfb_driver, imxfb_probe);\r\n}\r\nstatic void __exit imxfb_cleanup(void)\r\n{\r\nplatform_driver_unregister(&imxfb_driver);\r\n}
