static int pdc_port_start(struct ata_port *ap)\r\n{\r\nstruct device *dev = ap->host->dev;\r\nstruct pdc_port_priv *pp;\r\npp = devm_kzalloc(dev, sizeof(*pp), GFP_KERNEL);\r\nif (!pp)\r\nreturn -ENOMEM;\r\npp->pkt = dmam_alloc_coherent(dev, 128, &pp->pkt_dma, GFP_KERNEL);\r\nif (!pp->pkt)\r\nreturn -ENOMEM;\r\nap->private_data = pp;\r\nreturn 0;\r\n}\r\nstatic inline void pdc20621_ata_sg(u8 *buf, unsigned int portno,\r\nunsigned int total_len)\r\n{\r\nu32 addr;\r\nunsigned int dw = PDC_DIMM_APKT_PRD >> 2;\r\n__le32 *buf32 = (__le32 *) buf;\r\naddr = PDC_20621_DIMM_BASE + PDC_20621_DIMM_DATA +\r\n(PDC_DIMM_DATA_STEP * portno);\r\nVPRINTK("ATA sg addr 0x%x, %d\n", addr, addr);\r\nbuf32[dw] = cpu_to_le32(addr);\r\nbuf32[dw + 1] = cpu_to_le32(total_len | ATA_PRD_EOT);\r\nVPRINTK("ATA PSG @ %x == (0x%x, 0x%x)\n",\r\nPDC_20621_DIMM_BASE +\r\n(PDC_DIMM_WINDOW_STEP * portno) +\r\nPDC_DIMM_APKT_PRD,\r\nbuf32[dw], buf32[dw + 1]);\r\n}\r\nstatic inline void pdc20621_host_sg(u8 *buf, unsigned int portno,\r\nunsigned int total_len)\r\n{\r\nu32 addr;\r\nunsigned int dw = PDC_DIMM_HPKT_PRD >> 2;\r\n__le32 *buf32 = (__le32 *) buf;\r\naddr = PDC_20621_DIMM_BASE + PDC_20621_DIMM_DATA +\r\n(PDC_DIMM_DATA_STEP * portno);\r\nbuf32[dw] = cpu_to_le32(addr);\r\nbuf32[dw + 1] = cpu_to_le32(total_len | ATA_PRD_EOT);\r\nVPRINTK("HOST PSG @ %x == (0x%x, 0x%x)\n",\r\nPDC_20621_DIMM_BASE +\r\n(PDC_DIMM_WINDOW_STEP * portno) +\r\nPDC_DIMM_HPKT_PRD,\r\nbuf32[dw], buf32[dw + 1]);\r\n}\r\nstatic inline unsigned int pdc20621_ata_pkt(struct ata_taskfile *tf,\r\nunsigned int devno, u8 *buf,\r\nunsigned int portno)\r\n{\r\nunsigned int i, dw;\r\n__le32 *buf32 = (__le32 *) buf;\r\nu8 dev_reg;\r\nunsigned int dimm_sg = PDC_20621_DIMM_BASE +\r\n(PDC_DIMM_WINDOW_STEP * portno) +\r\nPDC_DIMM_APKT_PRD;\r\nVPRINTK("ENTER, dimm_sg == 0x%x, %d\n", dimm_sg, dimm_sg);\r\ni = PDC_DIMM_ATA_PKT;\r\nif ((tf->protocol == ATA_PROT_DMA) && (!(tf->flags & ATA_TFLAG_WRITE)))\r\nbuf[i++] = PDC_PKT_READ;\r\nelse if (tf->protocol == ATA_PROT_NODATA)\r\nbuf[i++] = PDC_PKT_NODATA;\r\nelse\r\nbuf[i++] = 0;\r\nbuf[i++] = 0;\r\nbuf[i++] = portno + 1;\r\nbuf[i++] = 0xff;\r\ndw = i >> 2;\r\nif (tf->protocol == ATA_PROT_NODATA)\r\nbuf32[dw] = 0;\r\nelse\r\nbuf32[dw] = cpu_to_le32(dimm_sg);\r\nbuf32[dw + 1] = 0;\r\ni += 8;\r\nif (devno == 0)\r\ndev_reg = ATA_DEVICE_OBS;\r\nelse\r\ndev_reg = ATA_DEVICE_OBS | ATA_DEV1;\r\nbuf[i++] = (1 << 5) | PDC_PKT_CLEAR_BSY | ATA_REG_DEVICE;\r\nbuf[i++] = dev_reg;\r\nbuf[i++] = (1 << 5) | PDC_REG_DEVCTL;\r\nbuf[i++] = tf->ctl;\r\nreturn i;\r\n}\r\nstatic inline void pdc20621_host_pkt(struct ata_taskfile *tf, u8 *buf,\r\nunsigned int portno)\r\n{\r\nunsigned int dw;\r\nu32 tmp;\r\n__le32 *buf32 = (__le32 *) buf;\r\nunsigned int host_sg = PDC_20621_DIMM_BASE +\r\n(PDC_DIMM_WINDOW_STEP * portno) +\r\nPDC_DIMM_HOST_PRD;\r\nunsigned int dimm_sg = PDC_20621_DIMM_BASE +\r\n(PDC_DIMM_WINDOW_STEP * portno) +\r\nPDC_DIMM_HPKT_PRD;\r\nVPRINTK("ENTER, dimm_sg == 0x%x, %d\n", dimm_sg, dimm_sg);\r\nVPRINTK("host_sg == 0x%x, %d\n", host_sg, host_sg);\r\ndw = PDC_DIMM_HOST_PKT >> 2;\r\nif ((tf->protocol == ATA_PROT_DMA) && (!(tf->flags & ATA_TFLAG_WRITE)))\r\ntmp = PDC_PKT_READ;\r\nelse\r\ntmp = 0;\r\ntmp |= ((portno + 1 + 4) << 16);\r\ntmp |= (0xff << 24);\r\nbuf32[dw + 0] = cpu_to_le32(tmp);\r\nbuf32[dw + 1] = cpu_to_le32(host_sg);\r\nbuf32[dw + 2] = cpu_to_le32(dimm_sg);\r\nbuf32[dw + 3] = 0;\r\nVPRINTK("HOST PKT @ %x == (0x%x 0x%x 0x%x 0x%x)\n",\r\nPDC_20621_DIMM_BASE + (PDC_DIMM_WINDOW_STEP * portno) +\r\nPDC_DIMM_HOST_PKT,\r\nbuf32[dw + 0],\r\nbuf32[dw + 1],\r\nbuf32[dw + 2],\r\nbuf32[dw + 3]);\r\n}\r\nstatic void pdc20621_dma_prep(struct ata_queued_cmd *qc)\r\n{\r\nstruct scatterlist *sg;\r\nstruct ata_port *ap = qc->ap;\r\nstruct pdc_port_priv *pp = ap->private_data;\r\nvoid __iomem *mmio = ap->host->iomap[PDC_MMIO_BAR];\r\nvoid __iomem *dimm_mmio = ap->host->iomap[PDC_DIMM_BAR];\r\nunsigned int portno = ap->port_no;\r\nunsigned int i, si, idx, total_len = 0, sgt_len;\r\n__le32 *buf = (__le32 *) &pp->dimm_buf[PDC_DIMM_HEADER_SZ];\r\nWARN_ON(!(qc->flags & ATA_QCFLAG_DMAMAP));\r\nVPRINTK("ata%u: ENTER\n", ap->print_id);\r\nmmio += PDC_CHIP0_OFS;\r\nidx = 0;\r\nfor_each_sg(qc->sg, sg, qc->n_elem, si) {\r\nbuf[idx++] = cpu_to_le32(sg_dma_address(sg));\r\nbuf[idx++] = cpu_to_le32(sg_dma_len(sg));\r\ntotal_len += sg_dma_len(sg);\r\n}\r\nbuf[idx - 1] |= cpu_to_le32(ATA_PRD_EOT);\r\nsgt_len = idx * 4;\r\npdc20621_host_sg(&pp->dimm_buf[0], portno, total_len);\r\npdc20621_host_pkt(&qc->tf, &pp->dimm_buf[0], portno);\r\npdc20621_ata_sg(&pp->dimm_buf[0], portno, total_len);\r\ni = pdc20621_ata_pkt(&qc->tf, qc->dev->devno, &pp->dimm_buf[0], portno);\r\nif (qc->tf.flags & ATA_TFLAG_LBA48)\r\ni = pdc_prep_lba48(&qc->tf, &pp->dimm_buf[0], i);\r\nelse\r\ni = pdc_prep_lba28(&qc->tf, &pp->dimm_buf[0], i);\r\npdc_pkt_footer(&qc->tf, &pp->dimm_buf[0], i);\r\nmemcpy_toio(dimm_mmio + (portno * PDC_DIMM_WINDOW_STEP),\r\n&pp->dimm_buf, PDC_DIMM_HEADER_SZ);\r\nmemcpy_toio(dimm_mmio + (portno * PDC_DIMM_WINDOW_STEP) +\r\nPDC_DIMM_HOST_PRD,\r\n&pp->dimm_buf[PDC_DIMM_HEADER_SZ], sgt_len);\r\nwritel(0x00000001, mmio + PDC_20621_GENERAL_CTL);\r\nreadl(dimm_mmio);\r\nVPRINTK("ata pkt buf ofs %u, prd size %u, mmio copied\n", i, sgt_len);\r\n}\r\nstatic void pdc20621_nodata_prep(struct ata_queued_cmd *qc)\r\n{\r\nstruct ata_port *ap = qc->ap;\r\nstruct pdc_port_priv *pp = ap->private_data;\r\nvoid __iomem *mmio = ap->host->iomap[PDC_MMIO_BAR];\r\nvoid __iomem *dimm_mmio = ap->host->iomap[PDC_DIMM_BAR];\r\nunsigned int portno = ap->port_no;\r\nunsigned int i;\r\nVPRINTK("ata%u: ENTER\n", ap->print_id);\r\nmmio += PDC_CHIP0_OFS;\r\ni = pdc20621_ata_pkt(&qc->tf, qc->dev->devno, &pp->dimm_buf[0], portno);\r\nif (qc->tf.flags & ATA_TFLAG_LBA48)\r\ni = pdc_prep_lba48(&qc->tf, &pp->dimm_buf[0], i);\r\nelse\r\ni = pdc_prep_lba28(&qc->tf, &pp->dimm_buf[0], i);\r\npdc_pkt_footer(&qc->tf, &pp->dimm_buf[0], i);\r\nmemcpy_toio(dimm_mmio + (portno * PDC_DIMM_WINDOW_STEP),\r\n&pp->dimm_buf, PDC_DIMM_HEADER_SZ);\r\nwritel(0x00000001, mmio + PDC_20621_GENERAL_CTL);\r\nreadl(dimm_mmio);\r\nVPRINTK("ata pkt buf ofs %u, mmio copied\n", i);\r\n}\r\nstatic void pdc20621_qc_prep(struct ata_queued_cmd *qc)\r\n{\r\nswitch (qc->tf.protocol) {\r\ncase ATA_PROT_DMA:\r\npdc20621_dma_prep(qc);\r\nbreak;\r\ncase ATA_PROT_NODATA:\r\npdc20621_nodata_prep(qc);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic void __pdc20621_push_hdma(struct ata_queued_cmd *qc,\r\nunsigned int seq,\r\nu32 pkt_ofs)\r\n{\r\nstruct ata_port *ap = qc->ap;\r\nstruct ata_host *host = ap->host;\r\nvoid __iomem *mmio = host->iomap[PDC_MMIO_BAR];\r\nmmio += PDC_CHIP0_OFS;\r\nwritel(0x00000001, mmio + PDC_20621_SEQCTL + (seq * 4));\r\nreadl(mmio + PDC_20621_SEQCTL + (seq * 4));\r\nwritel(pkt_ofs, mmio + PDC_HDMA_PKT_SUBMIT);\r\nreadl(mmio + PDC_HDMA_PKT_SUBMIT);\r\n}\r\nstatic void pdc20621_push_hdma(struct ata_queued_cmd *qc,\r\nunsigned int seq,\r\nu32 pkt_ofs)\r\n{\r\nstruct ata_port *ap = qc->ap;\r\nstruct pdc_host_priv *pp = ap->host->private_data;\r\nunsigned int idx = pp->hdma_prod & PDC_HDMA_Q_MASK;\r\nif (!pp->doing_hdma) {\r\n__pdc20621_push_hdma(qc, seq, pkt_ofs);\r\npp->doing_hdma = 1;\r\nreturn;\r\n}\r\npp->hdma[idx].qc = qc;\r\npp->hdma[idx].seq = seq;\r\npp->hdma[idx].pkt_ofs = pkt_ofs;\r\npp->hdma_prod++;\r\n}\r\nstatic void pdc20621_pop_hdma(struct ata_queued_cmd *qc)\r\n{\r\nstruct ata_port *ap = qc->ap;\r\nstruct pdc_host_priv *pp = ap->host->private_data;\r\nunsigned int idx = pp->hdma_cons & PDC_HDMA_Q_MASK;\r\nif (pp->hdma_prod == pp->hdma_cons) {\r\npp->doing_hdma = 0;\r\nreturn;\r\n}\r\n__pdc20621_push_hdma(pp->hdma[idx].qc, pp->hdma[idx].seq,\r\npp->hdma[idx].pkt_ofs);\r\npp->hdma_cons++;\r\n}\r\nstatic void pdc20621_dump_hdma(struct ata_queued_cmd *qc)\r\n{\r\nstruct ata_port *ap = qc->ap;\r\nunsigned int port_no = ap->port_no;\r\nvoid __iomem *dimm_mmio = ap->host->iomap[PDC_DIMM_BAR];\r\ndimm_mmio += (port_no * PDC_DIMM_WINDOW_STEP);\r\ndimm_mmio += PDC_DIMM_HOST_PKT;\r\nprintk(KERN_ERR "HDMA[0] == 0x%08X\n", readl(dimm_mmio));\r\nprintk(KERN_ERR "HDMA[1] == 0x%08X\n", readl(dimm_mmio + 4));\r\nprintk(KERN_ERR "HDMA[2] == 0x%08X\n", readl(dimm_mmio + 8));\r\nprintk(KERN_ERR "HDMA[3] == 0x%08X\n", readl(dimm_mmio + 12));\r\n}\r\nstatic inline void pdc20621_dump_hdma(struct ata_queued_cmd *qc) { }\r\nstatic void pdc20621_packet_start(struct ata_queued_cmd *qc)\r\n{\r\nstruct ata_port *ap = qc->ap;\r\nstruct ata_host *host = ap->host;\r\nunsigned int port_no = ap->port_no;\r\nvoid __iomem *mmio = host->iomap[PDC_MMIO_BAR];\r\nunsigned int rw = (qc->tf.flags & ATA_TFLAG_WRITE);\r\nu8 seq = (u8) (port_no + 1);\r\nunsigned int port_ofs;\r\nmmio += PDC_CHIP0_OFS;\r\nVPRINTK("ata%u: ENTER\n", ap->print_id);\r\nwmb();\r\nport_ofs = PDC_20621_DIMM_BASE + (PDC_DIMM_WINDOW_STEP * port_no);\r\nif (rw && qc->tf.protocol == ATA_PROT_DMA) {\r\nseq += 4;\r\npdc20621_dump_hdma(qc);\r\npdc20621_push_hdma(qc, seq, port_ofs + PDC_DIMM_HOST_PKT);\r\nVPRINTK("queued ofs 0x%x (%u), seq %u\n",\r\nport_ofs + PDC_DIMM_HOST_PKT,\r\nport_ofs + PDC_DIMM_HOST_PKT,\r\nseq);\r\n} else {\r\nwritel(0x00000001, mmio + PDC_20621_SEQCTL + (seq * 4));\r\nreadl(mmio + PDC_20621_SEQCTL + (seq * 4));\r\nwritel(port_ofs + PDC_DIMM_ATA_PKT,\r\nap->ioaddr.cmd_addr + PDC_PKT_SUBMIT);\r\nreadl(ap->ioaddr.cmd_addr + PDC_PKT_SUBMIT);\r\nVPRINTK("submitted ofs 0x%x (%u), seq %u\n",\r\nport_ofs + PDC_DIMM_ATA_PKT,\r\nport_ofs + PDC_DIMM_ATA_PKT,\r\nseq);\r\n}\r\n}\r\nstatic unsigned int pdc20621_qc_issue(struct ata_queued_cmd *qc)\r\n{\r\nswitch (qc->tf.protocol) {\r\ncase ATA_PROT_NODATA:\r\nif (qc->tf.flags & ATA_TFLAG_POLLING)\r\nbreak;\r\ncase ATA_PROT_DMA:\r\npdc20621_packet_start(qc);\r\nreturn 0;\r\ncase ATAPI_PROT_DMA:\r\nBUG();\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn ata_sff_qc_issue(qc);\r\n}\r\nstatic inline unsigned int pdc20621_host_intr(struct ata_port *ap,\r\nstruct ata_queued_cmd *qc,\r\nunsigned int doing_hdma,\r\nvoid __iomem *mmio)\r\n{\r\nunsigned int port_no = ap->port_no;\r\nunsigned int port_ofs =\r\nPDC_20621_DIMM_BASE + (PDC_DIMM_WINDOW_STEP * port_no);\r\nu8 status;\r\nunsigned int handled = 0;\r\nVPRINTK("ENTER\n");\r\nif ((qc->tf.protocol == ATA_PROT_DMA) &&\r\n(!(qc->tf.flags & ATA_TFLAG_WRITE))) {\r\nif (doing_hdma) {\r\nVPRINTK("ata%u: read hdma, 0x%x 0x%x\n", ap->print_id,\r\nreadl(mmio + 0x104), readl(mmio + PDC_HDMA_CTLSTAT));\r\nqc->err_mask |= ac_err_mask(ata_wait_idle(ap));\r\nata_qc_complete(qc);\r\npdc20621_pop_hdma(qc);\r\n}\r\nelse {\r\nu8 seq = (u8) (port_no + 1 + 4);\r\nVPRINTK("ata%u: read ata, 0x%x 0x%x\n", ap->print_id,\r\nreadl(mmio + 0x104), readl(mmio + PDC_HDMA_CTLSTAT));\r\npdc20621_dump_hdma(qc);\r\npdc20621_push_hdma(qc, seq,\r\nport_ofs + PDC_DIMM_HOST_PKT);\r\n}\r\nhandled = 1;\r\n} else if (qc->tf.protocol == ATA_PROT_DMA) {\r\nif (doing_hdma) {\r\nu8 seq = (u8) (port_no + 1);\r\nVPRINTK("ata%u: write hdma, 0x%x 0x%x\n", ap->print_id,\r\nreadl(mmio + 0x104), readl(mmio + PDC_HDMA_CTLSTAT));\r\nwritel(0x00000001, mmio + PDC_20621_SEQCTL + (seq * 4));\r\nreadl(mmio + PDC_20621_SEQCTL + (seq * 4));\r\nwritel(port_ofs + PDC_DIMM_ATA_PKT,\r\nap->ioaddr.cmd_addr + PDC_PKT_SUBMIT);\r\nreadl(ap->ioaddr.cmd_addr + PDC_PKT_SUBMIT);\r\n}\r\nelse {\r\nVPRINTK("ata%u: write ata, 0x%x 0x%x\n", ap->print_id,\r\nreadl(mmio + 0x104), readl(mmio + PDC_HDMA_CTLSTAT));\r\nqc->err_mask |= ac_err_mask(ata_wait_idle(ap));\r\nata_qc_complete(qc);\r\npdc20621_pop_hdma(qc);\r\n}\r\nhandled = 1;\r\n} else if (qc->tf.protocol == ATA_PROT_NODATA) {\r\nstatus = ata_sff_busy_wait(ap, ATA_BUSY | ATA_DRQ, 1000);\r\nDPRINTK("BUS_NODATA (drv_stat 0x%X)\n", status);\r\nqc->err_mask |= ac_err_mask(status);\r\nata_qc_complete(qc);\r\nhandled = 1;\r\n} else {\r\nap->stats.idle_irq++;\r\n}\r\nreturn handled;\r\n}\r\nstatic void pdc20621_irq_clear(struct ata_port *ap)\r\n{\r\nioread8(ap->ioaddr.status_addr);\r\n}\r\nstatic irqreturn_t pdc20621_interrupt(int irq, void *dev_instance)\r\n{\r\nstruct ata_host *host = dev_instance;\r\nstruct ata_port *ap;\r\nu32 mask = 0;\r\nunsigned int i, tmp, port_no;\r\nunsigned int handled = 0;\r\nvoid __iomem *mmio_base;\r\nVPRINTK("ENTER\n");\r\nif (!host || !host->iomap[PDC_MMIO_BAR]) {\r\nVPRINTK("QUICK EXIT\n");\r\nreturn IRQ_NONE;\r\n}\r\nmmio_base = host->iomap[PDC_MMIO_BAR];\r\nmmio_base += PDC_CHIP0_OFS;\r\nmask = readl(mmio_base + PDC_20621_SEQMASK);\r\nVPRINTK("mask == 0x%x\n", mask);\r\nif (mask == 0xffffffff) {\r\nVPRINTK("QUICK EXIT 2\n");\r\nreturn IRQ_NONE;\r\n}\r\nmask &= 0xffff;\r\nif (!mask) {\r\nVPRINTK("QUICK EXIT 3\n");\r\nreturn IRQ_NONE;\r\n}\r\nspin_lock(&host->lock);\r\nfor (i = 1; i < 9; i++) {\r\nport_no = i - 1;\r\nif (port_no > 3)\r\nport_no -= 4;\r\nif (port_no >= host->n_ports)\r\nap = NULL;\r\nelse\r\nap = host->ports[port_no];\r\ntmp = mask & (1 << i);\r\nVPRINTK("seq %u, port_no %u, ap %p, tmp %x\n", i, port_no, ap, tmp);\r\nif (tmp && ap) {\r\nstruct ata_queued_cmd *qc;\r\nqc = ata_qc_from_tag(ap, ap->link.active_tag);\r\nif (qc && (!(qc->tf.flags & ATA_TFLAG_POLLING)))\r\nhandled += pdc20621_host_intr(ap, qc, (i > 4),\r\nmmio_base);\r\n}\r\n}\r\nspin_unlock(&host->lock);\r\nVPRINTK("mask == 0x%x\n", mask);\r\nVPRINTK("EXIT\n");\r\nreturn IRQ_RETVAL(handled);\r\n}\r\nstatic void pdc_freeze(struct ata_port *ap)\r\n{\r\nvoid __iomem *mmio = ap->ioaddr.cmd_addr;\r\nu32 tmp;\r\ntmp = readl(mmio + PDC_CTLSTAT);\r\ntmp |= PDC_MASK_INT;\r\ntmp &= ~PDC_DMA_ENABLE;\r\nwritel(tmp, mmio + PDC_CTLSTAT);\r\nreadl(mmio + PDC_CTLSTAT);\r\n}\r\nstatic void pdc_thaw(struct ata_port *ap)\r\n{\r\nvoid __iomem *mmio = ap->ioaddr.cmd_addr;\r\nu32 tmp;\r\nioread8(ap->ioaddr.status_addr);\r\ntmp = readl(mmio + PDC_CTLSTAT);\r\ntmp &= ~PDC_MASK_INT;\r\nwritel(tmp, mmio + PDC_CTLSTAT);\r\nreadl(mmio + PDC_CTLSTAT);\r\n}\r\nstatic void pdc_reset_port(struct ata_port *ap)\r\n{\r\nvoid __iomem *mmio = ap->ioaddr.cmd_addr + PDC_CTLSTAT;\r\nunsigned int i;\r\nu32 tmp;\r\nfor (i = 11; i > 0; i--) {\r\ntmp = readl(mmio);\r\nif (tmp & PDC_RESET)\r\nbreak;\r\nudelay(100);\r\ntmp |= PDC_RESET;\r\nwritel(tmp, mmio);\r\n}\r\ntmp &= ~PDC_RESET;\r\nwritel(tmp, mmio);\r\nreadl(mmio);\r\n}\r\nstatic int pdc_softreset(struct ata_link *link, unsigned int *class,\r\nunsigned long deadline)\r\n{\r\npdc_reset_port(link->ap);\r\nreturn ata_sff_softreset(link, class, deadline);\r\n}\r\nstatic void pdc_error_handler(struct ata_port *ap)\r\n{\r\nif (!(ap->pflags & ATA_PFLAG_FROZEN))\r\npdc_reset_port(ap);\r\nata_sff_error_handler(ap);\r\n}\r\nstatic void pdc_post_internal_cmd(struct ata_queued_cmd *qc)\r\n{\r\nstruct ata_port *ap = qc->ap;\r\nif (qc->flags & ATA_QCFLAG_FAILED)\r\npdc_reset_port(ap);\r\n}\r\nstatic int pdc_check_atapi_dma(struct ata_queued_cmd *qc)\r\n{\r\nu8 *scsicmd = qc->scsicmd->cmnd;\r\nint pio = 1;\r\nswitch (scsicmd[0]) {\r\ncase WRITE_12:\r\ncase WRITE_10:\r\ncase WRITE_6:\r\ncase READ_12:\r\ncase READ_10:\r\ncase READ_6:\r\ncase 0xad:\r\ncase 0xbe:\r\npio = 0;\r\n}\r\nif (scsicmd[0] == WRITE_10) {\r\nunsigned int lba =\r\n(scsicmd[2] << 24) |\r\n(scsicmd[3] << 16) |\r\n(scsicmd[4] << 8) |\r\nscsicmd[5];\r\nif (lba >= 0xFFFF4FA2)\r\npio = 1;\r\n}\r\nreturn pio;\r\n}\r\nstatic void pdc_tf_load_mmio(struct ata_port *ap, const struct ata_taskfile *tf)\r\n{\r\nWARN_ON(tf->protocol == ATA_PROT_DMA ||\r\ntf->protocol == ATAPI_PROT_DMA);\r\nata_sff_tf_load(ap, tf);\r\n}\r\nstatic void pdc_exec_command_mmio(struct ata_port *ap, const struct ata_taskfile *tf)\r\n{\r\nWARN_ON(tf->protocol == ATA_PROT_DMA ||\r\ntf->protocol == ATAPI_PROT_DMA);\r\nata_sff_exec_command(ap, tf);\r\n}\r\nstatic void pdc_sata_setup_port(struct ata_ioports *port, void __iomem *base)\r\n{\r\nport->cmd_addr = base;\r\nport->data_addr = base;\r\nport->feature_addr =\r\nport->error_addr = base + 0x4;\r\nport->nsect_addr = base + 0x8;\r\nport->lbal_addr = base + 0xc;\r\nport->lbam_addr = base + 0x10;\r\nport->lbah_addr = base + 0x14;\r\nport->device_addr = base + 0x18;\r\nport->command_addr =\r\nport->status_addr = base + 0x1c;\r\nport->altstatus_addr =\r\nport->ctl_addr = base + 0x38;\r\n}\r\nstatic void pdc20621_get_from_dimm(struct ata_host *host, void *psource,\r\nu32 offset, u32 size)\r\n{\r\nu32 window_size;\r\nu16 idx;\r\nu8 page_mask;\r\nlong dist;\r\nvoid __iomem *mmio = host->iomap[PDC_MMIO_BAR];\r\nvoid __iomem *dimm_mmio = host->iomap[PDC_DIMM_BAR];\r\nmmio += PDC_CHIP0_OFS;\r\npage_mask = 0x00;\r\nwindow_size = 0x2000 * 4;\r\nidx = (u16) (offset / window_size);\r\nwritel(0x01, mmio + PDC_GENERAL_CTLR);\r\nreadl(mmio + PDC_GENERAL_CTLR);\r\nwritel(((idx) << page_mask), mmio + PDC_DIMM_WINDOW_CTLR);\r\nreadl(mmio + PDC_DIMM_WINDOW_CTLR);\r\noffset -= (idx * window_size);\r\nidx++;\r\ndist = ((long) (window_size - (offset + size))) >= 0 ? size :\r\n(long) (window_size - offset);\r\nmemcpy_fromio((char *) psource, (char *) (dimm_mmio + offset / 4),\r\ndist);\r\npsource += dist;\r\nsize -= dist;\r\nfor (; (long) size >= (long) window_size ;) {\r\nwritel(0x01, mmio + PDC_GENERAL_CTLR);\r\nreadl(mmio + PDC_GENERAL_CTLR);\r\nwritel(((idx) << page_mask), mmio + PDC_DIMM_WINDOW_CTLR);\r\nreadl(mmio + PDC_DIMM_WINDOW_CTLR);\r\nmemcpy_fromio((char *) psource, (char *) (dimm_mmio),\r\nwindow_size / 4);\r\npsource += window_size;\r\nsize -= window_size;\r\nidx++;\r\n}\r\nif (size) {\r\nwritel(0x01, mmio + PDC_GENERAL_CTLR);\r\nreadl(mmio + PDC_GENERAL_CTLR);\r\nwritel(((idx) << page_mask), mmio + PDC_DIMM_WINDOW_CTLR);\r\nreadl(mmio + PDC_DIMM_WINDOW_CTLR);\r\nmemcpy_fromio((char *) psource, (char *) (dimm_mmio),\r\nsize / 4);\r\n}\r\n}\r\nstatic void pdc20621_put_to_dimm(struct ata_host *host, void *psource,\r\nu32 offset, u32 size)\r\n{\r\nu32 window_size;\r\nu16 idx;\r\nu8 page_mask;\r\nlong dist;\r\nvoid __iomem *mmio = host->iomap[PDC_MMIO_BAR];\r\nvoid __iomem *dimm_mmio = host->iomap[PDC_DIMM_BAR];\r\nmmio += PDC_CHIP0_OFS;\r\npage_mask = 0x00;\r\nwindow_size = 0x2000 * 4;\r\nidx = (u16) (offset / window_size);\r\nwritel(((idx) << page_mask), mmio + PDC_DIMM_WINDOW_CTLR);\r\nreadl(mmio + PDC_DIMM_WINDOW_CTLR);\r\noffset -= (idx * window_size);\r\nidx++;\r\ndist = ((long)(s32)(window_size - (offset + size))) >= 0 ? size :\r\n(long) (window_size - offset);\r\nmemcpy_toio(dimm_mmio + offset / 4, psource, dist);\r\nwritel(0x01, mmio + PDC_GENERAL_CTLR);\r\nreadl(mmio + PDC_GENERAL_CTLR);\r\npsource += dist;\r\nsize -= dist;\r\nfor (; (long) size >= (long) window_size ;) {\r\nwritel(((idx) << page_mask), mmio + PDC_DIMM_WINDOW_CTLR);\r\nreadl(mmio + PDC_DIMM_WINDOW_CTLR);\r\nmemcpy_toio(dimm_mmio, psource, window_size / 4);\r\nwritel(0x01, mmio + PDC_GENERAL_CTLR);\r\nreadl(mmio + PDC_GENERAL_CTLR);\r\npsource += window_size;\r\nsize -= window_size;\r\nidx++;\r\n}\r\nif (size) {\r\nwritel(((idx) << page_mask), mmio + PDC_DIMM_WINDOW_CTLR);\r\nreadl(mmio + PDC_DIMM_WINDOW_CTLR);\r\nmemcpy_toio(dimm_mmio, psource, size / 4);\r\nwritel(0x01, mmio + PDC_GENERAL_CTLR);\r\nreadl(mmio + PDC_GENERAL_CTLR);\r\n}\r\n}\r\nstatic unsigned int pdc20621_i2c_read(struct ata_host *host, u32 device,\r\nu32 subaddr, u32 *pdata)\r\n{\r\nvoid __iomem *mmio = host->iomap[PDC_MMIO_BAR];\r\nu32 i2creg = 0;\r\nu32 status;\r\nu32 count = 0;\r\nmmio += PDC_CHIP0_OFS;\r\ni2creg |= device << 24;\r\ni2creg |= subaddr << 16;\r\nwritel(i2creg, mmio + PDC_I2C_ADDR_DATA);\r\nreadl(mmio + PDC_I2C_ADDR_DATA);\r\nwritel(PDC_I2C_READ | PDC_I2C_START | PDC_I2C_MASK_INT,\r\nmmio + PDC_I2C_CONTROL);\r\nfor (count = 0; count <= 1000; count ++) {\r\nstatus = readl(mmio + PDC_I2C_CONTROL);\r\nif (status & PDC_I2C_COMPLETE) {\r\nstatus = readl(mmio + PDC_I2C_ADDR_DATA);\r\nbreak;\r\n} else if (count == 1000)\r\nreturn 0;\r\n}\r\n*pdata = (status >> 8) & 0x000000ff;\r\nreturn 1;\r\n}\r\nstatic int pdc20621_detect_dimm(struct ata_host *host)\r\n{\r\nu32 data = 0;\r\nif (pdc20621_i2c_read(host, PDC_DIMM0_SPD_DEV_ADDRESS,\r\nPDC_DIMM_SPD_SYSTEM_FREQ, &data)) {\r\nif (data == 100)\r\nreturn 100;\r\n} else\r\nreturn 0;\r\nif (pdc20621_i2c_read(host, PDC_DIMM0_SPD_DEV_ADDRESS, 9, &data)) {\r\nif (data <= 0x75)\r\nreturn 133;\r\n} else\r\nreturn 0;\r\nreturn 0;\r\n}\r\nstatic int pdc20621_prog_dimm0(struct ata_host *host)\r\n{\r\nu32 spd0[50];\r\nu32 data = 0;\r\nint size, i;\r\nu8 bdimmsize;\r\nvoid __iomem *mmio = host->iomap[PDC_MMIO_BAR];\r\nstatic const struct {\r\nunsigned int reg;\r\nunsigned int ofs;\r\n} pdc_i2c_read_data [] = {\r\n{ PDC_DIMM_SPD_TYPE, 11 },\r\n{ PDC_DIMM_SPD_FRESH_RATE, 12 },\r\n{ PDC_DIMM_SPD_COLUMN_NUM, 4 },\r\n{ PDC_DIMM_SPD_ATTRIBUTE, 21 },\r\n{ PDC_DIMM_SPD_ROW_NUM, 3 },\r\n{ PDC_DIMM_SPD_BANK_NUM, 17 },\r\n{ PDC_DIMM_SPD_MODULE_ROW, 5 },\r\n{ PDC_DIMM_SPD_ROW_PRE_CHARGE, 27 },\r\n{ PDC_DIMM_SPD_ROW_ACTIVE_DELAY, 28 },\r\n{ PDC_DIMM_SPD_RAS_CAS_DELAY, 29 },\r\n{ PDC_DIMM_SPD_ACTIVE_PRECHARGE, 30 },\r\n{ PDC_DIMM_SPD_CAS_LATENCY, 18 },\r\n};\r\nmmio += PDC_CHIP0_OFS;\r\nfor (i = 0; i < ARRAY_SIZE(pdc_i2c_read_data); i++)\r\npdc20621_i2c_read(host, PDC_DIMM0_SPD_DEV_ADDRESS,\r\npdc_i2c_read_data[i].reg,\r\n&spd0[pdc_i2c_read_data[i].ofs]);\r\ndata |= (spd0[4] - 8) | ((spd0[21] != 0) << 3) | ((spd0[3]-11) << 4);\r\ndata |= ((spd0[17] / 4) << 6) | ((spd0[5] / 2) << 7) |\r\n((((spd0[27] + 9) / 10) - 1) << 8) ;\r\ndata |= (((((spd0[29] > spd0[28])\r\n? spd0[29] : spd0[28]) + 9) / 10) - 1) << 10;\r\ndata |= ((spd0[30] - spd0[29] + 9) / 10 - 2) << 12;\r\nif (spd0[18] & 0x08)\r\ndata |= ((0x03) << 14);\r\nelse if (spd0[18] & 0x04)\r\ndata |= ((0x02) << 14);\r\nelse if (spd0[18] & 0x01)\r\ndata |= ((0x01) << 14);\r\nelse\r\ndata |= (0 << 14);\r\nbdimmsize = spd0[4] + (spd0[5] / 2) + spd0[3] + (spd0[17] / 2) + 3;\r\nsize = (1 << bdimmsize) >> 20;\r\ndata |= (((size / 16) - 1) << 16);\r\ndata |= (0 << 23);\r\ndata |= 8;\r\nwritel(data, mmio + PDC_DIMM0_CONTROL);\r\nreadl(mmio + PDC_DIMM0_CONTROL);\r\nreturn size;\r\n}\r\nstatic unsigned int pdc20621_prog_dimm_global(struct ata_host *host)\r\n{\r\nu32 data, spd0;\r\nint error, i;\r\nvoid __iomem *mmio = host->iomap[PDC_MMIO_BAR];\r\nmmio += PDC_CHIP0_OFS;\r\ndata = 0x022259F1;\r\nwritel(data, mmio + PDC_SDRAM_CONTROL);\r\nreadl(mmio + PDC_SDRAM_CONTROL);\r\npdc20621_i2c_read(host, PDC_DIMM0_SPD_DEV_ADDRESS,\r\nPDC_DIMM_SPD_TYPE, &spd0);\r\nif (spd0 == 0x02) {\r\ndata |= (0x01 << 16);\r\nwritel(data, mmio + PDC_SDRAM_CONTROL);\r\nreadl(mmio + PDC_SDRAM_CONTROL);\r\nprintk(KERN_ERR "Local DIMM ECC Enabled\n");\r\n}\r\ndata &= (~(1<<18));\r\ndata |= (1<<19);\r\nwritel(data, mmio + PDC_SDRAM_CONTROL);\r\nerror = 1;\r\nfor (i = 1; i <= 10; i++) {\r\ndata = readl(mmio + PDC_SDRAM_CONTROL);\r\nif (!(data & (1<<19))) {\r\nerror = 0;\r\nbreak;\r\n}\r\nmsleep(i*100);\r\n}\r\nreturn error;\r\n}\r\nstatic unsigned int pdc20621_dimm_init(struct ata_host *host)\r\n{\r\nint speed, size, length;\r\nu32 addr, spd0, pci_status;\r\nu32 time_period = 0;\r\nu32 tcount = 0;\r\nu32 ticks = 0;\r\nu32 clock = 0;\r\nu32 fparam = 0;\r\nvoid __iomem *mmio = host->iomap[PDC_MMIO_BAR];\r\nmmio += PDC_CHIP0_OFS;\r\nwritel(0xffffffff, mmio + PDC_TIME_PERIOD);\r\ntime_period = readl(mmio + PDC_TIME_PERIOD);\r\nVPRINTK("Time Period Register (0x40): 0x%x\n", time_period);\r\nwritel(PDC_TIMER_DEFAULT, mmio + PDC_TIME_CONTROL);\r\nreadl(mmio + PDC_TIME_CONTROL);\r\nmsleep(3000);\r\ntcount = readl(mmio + PDC_TIME_COUNTER);\r\nVPRINTK("Time Counter Register (0x44): 0x%x\n", tcount);\r\nif (tcount >= PCI_X_TCOUNT) {\r\nticks = (time_period - tcount);\r\nVPRINTK("Num counters 0x%x (%d)\n", ticks, ticks);\r\nclock = (ticks / 300000);\r\nVPRINTK("10 * Internal clk = 0x%x (%d)\n", clock, clock);\r\nclock = (clock * 33);\r\nVPRINTK("10 * Internal clk * 33 = 0x%x (%d)\n", clock, clock);\r\nfparam = (1400000 / clock) - 2;\r\nVPRINTK("PLL F Param: 0x%x (%d)\n", fparam, fparam);\r\npci_status = (0x8a001824 | (fparam << 16));\r\n} else\r\npci_status = PCI_PLL_INIT;\r\nVPRINTK("pci_status: 0x%x\n", pci_status);\r\nwritel(pci_status, mmio + PDC_CTL_STATUS);\r\nreadl(mmio + PDC_CTL_STATUS);\r\nif (!(speed = pdc20621_detect_dimm(host))) {\r\nprintk(KERN_ERR "Detect Local DIMM Fail\n");\r\nreturn 1;\r\n}\r\nVPRINTK("Local DIMM Speed = %d\n", speed);\r\nsize = pdc20621_prog_dimm0(host);\r\nVPRINTK("Local DIMM Size = %dMB\n", size);\r\nif (pdc20621_prog_dimm_global(host)) {\r\nprintk(KERN_ERR "Programming DIMM Module Global Control Register Fail\n");\r\nreturn 1;\r\n}\r\n#ifdef ATA_VERBOSE_DEBUG\r\n{\r\nu8 test_parttern1[40] =\r\n{0x55,0xAA,'P','r','o','m','i','s','e',' ',\r\n'N','o','t',' ','Y','e','t',' ',\r\n'D','e','f','i','n','e','d',' ',\r\n'1','.','1','0',\r\n'9','8','0','3','1','6','1','2',0,0};\r\nu8 test_parttern2[40] = {0};\r\npdc20621_put_to_dimm(host, test_parttern2, 0x10040, 40);\r\npdc20621_put_to_dimm(host, test_parttern2, 0x40, 40);\r\npdc20621_put_to_dimm(host, test_parttern1, 0x10040, 40);\r\npdc20621_get_from_dimm(host, test_parttern2, 0x40, 40);\r\nprintk(KERN_ERR "%x, %x, %s\n", test_parttern2[0],\r\ntest_parttern2[1], &(test_parttern2[2]));\r\npdc20621_get_from_dimm(host, test_parttern2, 0x10040,\r\n40);\r\nprintk(KERN_ERR "%x, %x, %s\n", test_parttern2[0],\r\ntest_parttern2[1], &(test_parttern2[2]));\r\npdc20621_put_to_dimm(host, test_parttern1, 0x40, 40);\r\npdc20621_get_from_dimm(host, test_parttern2, 0x40, 40);\r\nprintk(KERN_ERR "%x, %x, %s\n", test_parttern2[0],\r\ntest_parttern2[1], &(test_parttern2[2]));\r\n}\r\n#endif\r\npdc20621_i2c_read(host, PDC_DIMM0_SPD_DEV_ADDRESS,\r\nPDC_DIMM_SPD_TYPE, &spd0);\r\nif (spd0 == 0x02) {\r\nvoid *buf;\r\nVPRINTK("Start ECC initialization\n");\r\naddr = 0;\r\nlength = size * 1024 * 1024;\r\nbuf = kzalloc(ECC_ERASE_BUF_SZ, GFP_KERNEL);\r\nwhile (addr < length) {\r\npdc20621_put_to_dimm(host, buf, addr,\r\nECC_ERASE_BUF_SZ);\r\naddr += ECC_ERASE_BUF_SZ;\r\n}\r\nkfree(buf);\r\nVPRINTK("Finish ECC initialization\n");\r\n}\r\nreturn 0;\r\n}\r\nstatic void pdc_20621_init(struct ata_host *host)\r\n{\r\nu32 tmp;\r\nvoid __iomem *mmio = host->iomap[PDC_MMIO_BAR];\r\nmmio += PDC_CHIP0_OFS;\r\ntmp = readl(mmio + PDC_20621_DIMM_WINDOW) & 0xffff0000;\r\ntmp |= PDC_PAGE_WINDOW;\r\nwritel(tmp, mmio + PDC_20621_DIMM_WINDOW);\r\ntmp = readl(mmio + PDC_HDMA_CTLSTAT);\r\ntmp |= PDC_RESET;\r\nwritel(tmp, mmio + PDC_HDMA_CTLSTAT);\r\nreadl(mmio + PDC_HDMA_CTLSTAT);\r\nudelay(10);\r\ntmp = readl(mmio + PDC_HDMA_CTLSTAT);\r\ntmp &= ~PDC_RESET;\r\nwritel(tmp, mmio + PDC_HDMA_CTLSTAT);\r\nreadl(mmio + PDC_HDMA_CTLSTAT);\r\n}\r\nstatic int pdc_sata_init_one(struct pci_dev *pdev,\r\nconst struct pci_device_id *ent)\r\n{\r\nconst struct ata_port_info *ppi[] =\r\n{ &pdc_port_info[ent->driver_data], NULL };\r\nstruct ata_host *host;\r\nstruct pdc_host_priv *hpriv;\r\nint i, rc;\r\nata_print_version_once(&pdev->dev, DRV_VERSION);\r\nhost = ata_host_alloc_pinfo(&pdev->dev, ppi, 4);\r\nhpriv = devm_kzalloc(&pdev->dev, sizeof(*hpriv), GFP_KERNEL);\r\nif (!host || !hpriv)\r\nreturn -ENOMEM;\r\nhost->private_data = hpriv;\r\nrc = pcim_enable_device(pdev);\r\nif (rc)\r\nreturn rc;\r\nrc = pcim_iomap_regions(pdev, (1 << PDC_MMIO_BAR) | (1 << PDC_DIMM_BAR),\r\nDRV_NAME);\r\nif (rc == -EBUSY)\r\npcim_pin_device(pdev);\r\nif (rc)\r\nreturn rc;\r\nhost->iomap = pcim_iomap_table(pdev);\r\nfor (i = 0; i < 4; i++) {\r\nstruct ata_port *ap = host->ports[i];\r\nvoid __iomem *base = host->iomap[PDC_MMIO_BAR] + PDC_CHIP0_OFS;\r\nunsigned int offset = 0x200 + i * 0x80;\r\npdc_sata_setup_port(&ap->ioaddr, base + offset);\r\nata_port_pbar_desc(ap, PDC_MMIO_BAR, -1, "mmio");\r\nata_port_pbar_desc(ap, PDC_DIMM_BAR, -1, "dimm");\r\nata_port_pbar_desc(ap, PDC_MMIO_BAR, offset, "port");\r\n}\r\nrc = pci_set_dma_mask(pdev, ATA_DMA_MASK);\r\nif (rc)\r\nreturn rc;\r\nrc = pci_set_consistent_dma_mask(pdev, ATA_DMA_MASK);\r\nif (rc)\r\nreturn rc;\r\nif (pdc20621_dimm_init(host))\r\nreturn -ENOMEM;\r\npdc_20621_init(host);\r\npci_set_master(pdev);\r\nreturn ata_host_activate(host, pdev->irq, pdc20621_interrupt,\r\nIRQF_SHARED, &pdc_sata_sht);\r\n}
