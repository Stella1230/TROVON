static void reg_w_i(struct gspca_dev *gspca_dev, u16 reg, u8 val)\r\n{\r\nstruct usb_device *udev = gspca_dev->dev;\r\nint ret;\r\nif (gspca_dev->usb_err < 0)\r\nreturn;\r\ngspca_dev->usb_buf[0] = val;\r\nret = usb_control_msg(udev,\r\nusb_sndctrlpipe(udev, 0),\r\n0x01,\r\nUSB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\r\n0x00, reg, gspca_dev->usb_buf, 1, CTRL_TIMEOUT);\r\nif (ret < 0) {\r\npr_err("reg_w failed %d\n", ret);\r\ngspca_dev->usb_err = ret;\r\n}\r\n}\r\nstatic void reg_w(struct gspca_dev *gspca_dev, u16 reg, u8 val)\r\n{\r\nPDEBUG(D_USBO, "reg_w [%04x] = %02x", reg, val);\r\nreg_w_i(gspca_dev, reg, val);\r\n}\r\nstatic u8 reg_r(struct gspca_dev *gspca_dev, u16 reg)\r\n{\r\nstruct usb_device *udev = gspca_dev->dev;\r\nint ret;\r\nif (gspca_dev->usb_err < 0)\r\nreturn 0;\r\nret = usb_control_msg(udev,\r\nusb_rcvctrlpipe(udev, 0),\r\n0x01,\r\nUSB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\r\n0x00, reg, gspca_dev->usb_buf, 1, CTRL_TIMEOUT);\r\nPDEBUG(D_USBI, "reg_r [%04x] -> %02x", reg, gspca_dev->usb_buf[0]);\r\nif (ret < 0) {\r\npr_err("reg_r err %d\n", ret);\r\ngspca_dev->usb_err = ret;\r\n}\r\nreturn gspca_dev->usb_buf[0];\r\n}\r\nstatic int sccb_check_status(struct gspca_dev *gspca_dev)\r\n{\r\nu8 data;\r\nint i;\r\nfor (i = 0; i < 5; i++) {\r\nmsleep(10);\r\ndata = reg_r(gspca_dev, OV534_REG_STATUS);\r\nswitch (data) {\r\ncase 0x00:\r\nreturn 1;\r\ncase 0x04:\r\nreturn 0;\r\ncase 0x03:\r\nbreak;\r\ndefault:\r\nPDEBUG(D_USBI|D_USBO,\r\n"sccb status 0x%02x, attempt %d/5",\r\ndata, i + 1);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void sccb_write(struct gspca_dev *gspca_dev, u8 reg, u8 val)\r\n{\r\nPDEBUG(D_USBO, "sccb_write [%02x] = %02x", reg, val);\r\nreg_w_i(gspca_dev, OV534_REG_SUBADDR, reg);\r\nreg_w_i(gspca_dev, OV534_REG_WRITE, val);\r\nreg_w_i(gspca_dev, OV534_REG_OPERATION, OV534_OP_WRITE_3);\r\nif (!sccb_check_status(gspca_dev))\r\npr_err("sccb_write failed\n");\r\n}\r\nstatic u8 sccb_read(struct gspca_dev *gspca_dev, u16 reg)\r\n{\r\nreg_w(gspca_dev, OV534_REG_SUBADDR, reg);\r\nreg_w(gspca_dev, OV534_REG_OPERATION, OV534_OP_WRITE_2);\r\nif (!sccb_check_status(gspca_dev))\r\npr_err("sccb_read failed 1\n");\r\nreg_w(gspca_dev, OV534_REG_OPERATION, OV534_OP_READ_2);\r\nif (!sccb_check_status(gspca_dev))\r\npr_err("sccb_read failed 2\n");\r\nreturn reg_r(gspca_dev, OV534_REG_READ);\r\n}\r\nstatic void set_led(struct gspca_dev *gspca_dev, int status)\r\n{\r\nu8 data;\r\nPDEBUG(D_CONF, "led status: %d", status);\r\ndata = reg_r(gspca_dev, 0x21);\r\ndata |= 0x80;\r\nreg_w(gspca_dev, 0x21, data);\r\ndata = reg_r(gspca_dev, 0x23);\r\nif (status)\r\ndata |= 0x80;\r\nelse\r\ndata &= ~0x80;\r\nreg_w(gspca_dev, 0x23, data);\r\nif (!status) {\r\ndata = reg_r(gspca_dev, 0x21);\r\ndata &= ~0x80;\r\nreg_w(gspca_dev, 0x21, data);\r\n}\r\n}\r\nstatic void setbrightness(struct gspca_dev *gspca_dev, s32 brightness)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nu8 val;\r\ns8 sval;\r\nif (sd->sensor == SENSOR_OV562x) {\r\nsval = brightness;\r\nval = 0x76;\r\nval += sval;\r\nsccb_write(gspca_dev, 0x24, val);\r\nval = 0x6a;\r\nval += sval;\r\nsccb_write(gspca_dev, 0x25, val);\r\nif (sval < -40)\r\nval = 0x71;\r\nelse if (sval < 20)\r\nval = 0x94;\r\nelse\r\nval = 0xe6;\r\nsccb_write(gspca_dev, 0x26, val);\r\n} else {\r\nval = brightness;\r\nif (val < 8)\r\nval = 15 - val;\r\nelse\r\nval = val - 8;\r\nsccb_write(gspca_dev, 0x55,\r\n0x0f | (val << 4));\r\n}\r\n}\r\nstatic void setcontrast(struct gspca_dev *gspca_dev, s32 val)\r\n{\r\nsccb_write(gspca_dev, 0x56,\r\nval << 4);\r\n}\r\nstatic void setautogain(struct gspca_dev *gspca_dev, s32 autogain)\r\n{\r\nu8 val;\r\nval = sccb_read(gspca_dev, 0x13);\r\nsccb_write(gspca_dev, 0xff, 0x00);\r\nif (autogain)\r\nval |= 0x05;\r\nelse\r\nval &= 0xfa;\r\nsccb_write(gspca_dev, 0x13, val);\r\n}\r\nstatic void setexposure(struct gspca_dev *gspca_dev, s32 exposure)\r\n{\r\nstatic const u8 expo[4] = {0x00, 0x25, 0x38, 0x5e};\r\nu8 val;\r\nsccb_write(gspca_dev, 0x10, expo[exposure]);\r\nval = sccb_read(gspca_dev, 0x13);\r\nsccb_write(gspca_dev, 0xff, 0x00);\r\nsccb_write(gspca_dev, 0x13, val);\r\nval = sccb_read(gspca_dev, 0xa1);\r\nsccb_write(gspca_dev, 0xff, 0x00);\r\nsccb_write(gspca_dev, 0xa1, val & 0xe0);\r\n}\r\nstatic void setsharpness(struct gspca_dev *gspca_dev, s32 val)\r\n{\r\nif (val < 0) {\r\nval = sccb_read(gspca_dev, 0x42);\r\nsccb_write(gspca_dev, 0xff, 0x00);\r\nsccb_write(gspca_dev, 0x42, val | 0x40);\r\nreturn;\r\n}\r\nif (val != 0)\r\nval = 1 << (val - 1);\r\nsccb_write(gspca_dev, 0x3f,\r\nval);\r\nval = sccb_read(gspca_dev, 0x42);\r\nsccb_write(gspca_dev, 0xff, 0x00);\r\nsccb_write(gspca_dev, 0x42, val & 0xbf);\r\n}\r\nstatic void setsatur(struct gspca_dev *gspca_dev, s32 val)\r\n{\r\nu8 val1, val2, val3;\r\nstatic const u8 matrix[5][2] = {\r\n{0x14, 0x38},\r\n{0x1e, 0x54},\r\n{0x28, 0x70},\r\n{0x32, 0x8c},\r\n{0x48, 0x90}\r\n};\r\nval1 = matrix[val][0];\r\nval2 = matrix[val][1];\r\nval3 = val1 + val2;\r\nsccb_write(gspca_dev, 0x4f, val3);\r\nsccb_write(gspca_dev, 0x50, val3);\r\nsccb_write(gspca_dev, 0x51, 0x00);\r\nsccb_write(gspca_dev, 0x52, val1);\r\nsccb_write(gspca_dev, 0x53, val2);\r\nsccb_write(gspca_dev, 0x54, val3);\r\nsccb_write(gspca_dev, 0x58, 0x1a);\r\nval1 = sccb_read(gspca_dev, 0x41);\r\nsccb_write(gspca_dev, 0xff, 0x00);\r\nsccb_write(gspca_dev, 0x41, val1);\r\n}\r\nstatic void setlightfreq(struct gspca_dev *gspca_dev, s32 freq)\r\n{\r\nu8 val;\r\nval = sccb_read(gspca_dev, 0x13);\r\nsccb_write(gspca_dev, 0xff, 0x00);\r\nif (freq == 0) {\r\nsccb_write(gspca_dev, 0x13, val & 0xdf);\r\nreturn;\r\n}\r\nsccb_write(gspca_dev, 0x13, val | 0x20);\r\nval = sccb_read(gspca_dev, 0x42);\r\nsccb_write(gspca_dev, 0xff, 0x00);\r\nif (freq == 1)\r\nval |= 0x01;\r\nelse\r\nval &= 0xfe;\r\nsccb_write(gspca_dev, 0x42, val);\r\n}\r\nstatic int sd_config(struct gspca_dev *gspca_dev,\r\nconst struct usb_device_id *id)\r\n{\r\nreturn 0;\r\n}\r\nstatic int sd_init(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nu16 sensor_id;\r\nreg_w(gspca_dev, 0xe7, 0x3a);\r\nreg_w(gspca_dev, 0xe0, 0x08);\r\nmsleep(100);\r\nreg_w(gspca_dev, OV534_REG_ADDRESS, 0x60);\r\nsccb_write(gspca_dev, 0x12, 0x80);\r\nmsleep(10);\r\nsccb_read(gspca_dev, 0x0a);\r\nsensor_id = sccb_read(gspca_dev, 0x0a) << 8;\r\nsccb_read(gspca_dev, 0x0b);\r\nsensor_id |= sccb_read(gspca_dev, 0x0b);\r\nPDEBUG(D_PROBE, "Sensor ID: %04x", sensor_id);\r\nif ((sensor_id & 0xfff0) == 0x9650) {\r\nsd->sensor = SENSOR_OV965x;\r\ngspca_dev->cam.cam_mode = ov965x_mode;\r\ngspca_dev->cam.nmodes = ARRAY_SIZE(ov965x_mode);\r\nreg_w_array(gspca_dev, bridge_init,\r\nARRAY_SIZE(bridge_init));\r\nsccb_w_array(gspca_dev, ov965x_init,\r\nARRAY_SIZE(ov965x_init));\r\nreg_w_array(gspca_dev, bridge_init_2,\r\nARRAY_SIZE(bridge_init_2));\r\nsccb_w_array(gspca_dev, ov965x_init_2,\r\nARRAY_SIZE(ov965x_init_2));\r\nreg_w(gspca_dev, 0xe0, 0x00);\r\nreg_w(gspca_dev, 0xe0, 0x01);\r\nset_led(gspca_dev, 0);\r\nreg_w(gspca_dev, 0xe0, 0x00);\r\n} else if ((sensor_id & 0xfff0) == 0x9710) {\r\nconst char *p;\r\nint l;\r\nsd->sensor = SENSOR_OV971x;\r\ngspca_dev->cam.cam_mode = ov971x_mode;\r\ngspca_dev->cam.nmodes = ARRAY_SIZE(ov971x_mode);\r\ngspca_dev->cam.bulk = 1;\r\ngspca_dev->cam.bulk_size = 16384;\r\ngspca_dev->cam.bulk_nurbs = 2;\r\nsccb_w_array(gspca_dev, ov971x_init,\r\nARRAY_SIZE(ov971x_init));\r\nreg_w(gspca_dev, 0x1c, 0x00);\r\nreg_w(gspca_dev, 0x1d, 0x00);\r\np = video_device_node_name(&gspca_dev->vdev);\r\nl = strlen(p) - 1;\r\nif (p[l] == '0')\r\nreg_w(gspca_dev, 0x56, 0x1f);\r\nelse\r\nreg_w(gspca_dev, 0x56, 0x17);\r\n} else if ((sensor_id & 0xfff0) == 0x5620) {\r\nsd->sensor = SENSOR_OV562x;\r\ngspca_dev->cam.cam_mode = ov562x_mode;\r\ngspca_dev->cam.nmodes = ARRAY_SIZE(ov562x_mode);\r\nreg_w_array(gspca_dev, ov562x_init,\r\nARRAY_SIZE(ov562x_init));\r\nsccb_w_array(gspca_dev, ov562x_init_2,\r\nARRAY_SIZE(ov562x_init_2));\r\nreg_w(gspca_dev, 0xe0, 0x00);\r\n} else {\r\npr_err("Unknown sensor %04x", sensor_id);\r\nreturn -EINVAL;\r\n}\r\nreturn gspca_dev->usb_err;\r\n}\r\nstatic int sd_start(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nif (sd->sensor == SENSOR_OV971x)\r\nreturn gspca_dev->usb_err;\r\nif (sd->sensor == SENSOR_OV562x)\r\nreturn gspca_dev->usb_err;\r\nswitch (gspca_dev->curr_mode) {\r\ncase QVGA_MODE:\r\nsccb_w_array(gspca_dev, ov965x_start_1_vga,\r\nARRAY_SIZE(ov965x_start_1_vga));\r\nreg_w_array(gspca_dev, bridge_start_qvga,\r\nARRAY_SIZE(bridge_start_qvga));\r\nsccb_w_array(gspca_dev, ov965x_start_2_qvga,\r\nARRAY_SIZE(ov965x_start_2_qvga));\r\nbreak;\r\ncase VGA_MODE:\r\nsccb_w_array(gspca_dev, ov965x_start_1_vga,\r\nARRAY_SIZE(ov965x_start_1_vga));\r\nreg_w_array(gspca_dev, bridge_start_vga,\r\nARRAY_SIZE(bridge_start_vga));\r\nsccb_w_array(gspca_dev, ov965x_start_2_vga,\r\nARRAY_SIZE(ov965x_start_2_vga));\r\nbreak;\r\ncase SVGA_MODE:\r\nsccb_w_array(gspca_dev, ov965x_start_1_svga,\r\nARRAY_SIZE(ov965x_start_1_svga));\r\nreg_w_array(gspca_dev, bridge_start_svga,\r\nARRAY_SIZE(bridge_start_svga));\r\nsccb_w_array(gspca_dev, ov965x_start_2_svga,\r\nARRAY_SIZE(ov965x_start_2_svga));\r\nbreak;\r\ncase XGA_MODE:\r\nsccb_w_array(gspca_dev, ov965x_start_1_xga,\r\nARRAY_SIZE(ov965x_start_1_xga));\r\nreg_w_array(gspca_dev, bridge_start_xga,\r\nARRAY_SIZE(bridge_start_xga));\r\nsccb_w_array(gspca_dev, ov965x_start_2_svga,\r\nARRAY_SIZE(ov965x_start_2_svga));\r\nbreak;\r\ndefault:\r\nsccb_w_array(gspca_dev, ov965x_start_1_sxga,\r\nARRAY_SIZE(ov965x_start_1_sxga));\r\nreg_w_array(gspca_dev, bridge_start_sxga,\r\nARRAY_SIZE(bridge_start_sxga));\r\nsccb_w_array(gspca_dev, ov965x_start_2_sxga,\r\nARRAY_SIZE(ov965x_start_2_sxga));\r\nbreak;\r\n}\r\nreg_w(gspca_dev, 0xe0, 0x00);\r\nreg_w(gspca_dev, 0xe0, 0x00);\r\nset_led(gspca_dev, 1);\r\nreturn gspca_dev->usb_err;\r\n}\r\nstatic void sd_stopN(struct gspca_dev *gspca_dev)\r\n{\r\nreg_w(gspca_dev, 0xe0, 0x01);\r\nset_led(gspca_dev, 0);\r\nreg_w(gspca_dev, 0xe0, 0x00);\r\n}\r\nstatic void sd_pkt_scan(struct gspca_dev *gspca_dev,\r\nu8 *data, int len)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\n__u32 this_pts;\r\nu8 this_fid;\r\nint remaining_len = len;\r\nint payload_len;\r\npayload_len = gspca_dev->cam.bulk ? 2048 : 2040;\r\ndo {\r\nlen = min(remaining_len, payload_len);\r\nif (data[0] != 12 || len < 12) {\r\nPDEBUG(D_PACK, "bad header");\r\ngoto discard;\r\n}\r\nif (data[1] & UVC_STREAM_ERR) {\r\nPDEBUG(D_PACK, "payload error");\r\ngoto discard;\r\n}\r\nif (!(data[1] & UVC_STREAM_PTS)) {\r\nPDEBUG(D_PACK, "PTS not present");\r\ngoto discard;\r\n}\r\nthis_pts = (data[5] << 24) | (data[4] << 16)\r\n| (data[3] << 8) | data[2];\r\nthis_fid = data[1] & UVC_STREAM_FID;\r\nif (this_pts != sd->last_pts || this_fid != sd->last_fid) {\r\nif (gspca_dev->last_packet_type == INTER_PACKET)\r\ngspca_frame_add(gspca_dev, LAST_PACKET,\r\nNULL, 0);\r\nsd->last_pts = this_pts;\r\nsd->last_fid = this_fid;\r\ngspca_frame_add(gspca_dev, FIRST_PACKET,\r\ndata + 12, len - 12);\r\n} else if (data[1] & UVC_STREAM_EOF) {\r\nsd->last_pts = 0;\r\ngspca_frame_add(gspca_dev, LAST_PACKET,\r\ndata + 12, len - 12);\r\n} else {\r\ngspca_frame_add(gspca_dev, INTER_PACKET,\r\ndata + 12, len - 12);\r\n}\r\ngoto scan_next;\r\ndiscard:\r\ngspca_dev->last_packet_type = DISCARD_PACKET;\r\nscan_next:\r\nremaining_len -= len;\r\ndata += len;\r\n} while (remaining_len > 0);\r\n}\r\nstatic int sd_s_ctrl(struct v4l2_ctrl *ctrl)\r\n{\r\nstruct gspca_dev *gspca_dev =\r\ncontainer_of(ctrl->handler, struct gspca_dev, ctrl_handler);\r\ngspca_dev->usb_err = 0;\r\nif (!gspca_dev->streaming)\r\nreturn 0;\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_BRIGHTNESS:\r\nsetbrightness(gspca_dev, ctrl->val);\r\nbreak;\r\ncase V4L2_CID_CONTRAST:\r\nsetcontrast(gspca_dev, ctrl->val);\r\nbreak;\r\ncase V4L2_CID_SATURATION:\r\nsetsatur(gspca_dev, ctrl->val);\r\nbreak;\r\ncase V4L2_CID_POWER_LINE_FREQUENCY:\r\nsetlightfreq(gspca_dev, ctrl->val);\r\nbreak;\r\ncase V4L2_CID_SHARPNESS:\r\nsetsharpness(gspca_dev, ctrl->val);\r\nbreak;\r\ncase V4L2_CID_AUTOGAIN:\r\nif (ctrl->is_new)\r\nsetautogain(gspca_dev, ctrl->val);\r\nif (!ctrl->val && gspca_dev->exposure->is_new)\r\nsetexposure(gspca_dev, gspca_dev->exposure->val);\r\nbreak;\r\n}\r\nreturn gspca_dev->usb_err;\r\n}\r\nstatic int sd_init_controls(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *)gspca_dev;\r\nstruct v4l2_ctrl_handler *hdl = &gspca_dev->ctrl_handler;\r\nif (sd->sensor == SENSOR_OV971x)\r\nreturn 0;\r\ngspca_dev->vdev.ctrl_handler = hdl;\r\nv4l2_ctrl_handler_init(hdl, 7);\r\nif (sd->sensor == SENSOR_OV562x) {\r\nv4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\r\nV4L2_CID_BRIGHTNESS, -90, 90, 1, 0);\r\n} else {\r\nv4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\r\nV4L2_CID_BRIGHTNESS, 0, 15, 1, 7);\r\nv4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\r\nV4L2_CID_CONTRAST, 0, 15, 1, 3);\r\nv4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\r\nV4L2_CID_SATURATION, 0, 4, 1, 2);\r\nv4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\r\nV4L2_CID_SHARPNESS, -1, 4, 1, -1);\r\ngspca_dev->autogain = v4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\r\nV4L2_CID_AUTOGAIN, 0, 1, 1, 1);\r\ngspca_dev->exposure = v4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\r\nV4L2_CID_EXPOSURE, 0, 3, 1, 0);\r\nv4l2_ctrl_new_std_menu(hdl, &sd_ctrl_ops,\r\nV4L2_CID_POWER_LINE_FREQUENCY,\r\nV4L2_CID_POWER_LINE_FREQUENCY_60HZ, 0, 0);\r\nv4l2_ctrl_auto_cluster(3, &gspca_dev->autogain, 0, false);\r\n}\r\nif (hdl->error) {\r\npr_err("Could not initialize controls\n");\r\nreturn hdl->error;\r\n}\r\nreturn 0;\r\n}\r\nstatic int sd_probe(struct usb_interface *intf, const struct usb_device_id *id)\r\n{\r\nreturn gspca_dev_probe(intf, id, &sd_desc, sizeof(struct sd),\r\nTHIS_MODULE);\r\n}
