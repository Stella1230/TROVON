static u8 sp_read_reg8(const struct sja1000_priv *priv, int reg)\r\n{\r\nreturn ioread8(priv->reg_base + reg);\r\n}\r\nstatic void sp_write_reg8(const struct sja1000_priv *priv, int reg, u8 val)\r\n{\r\niowrite8(val, priv->reg_base + reg);\r\n}\r\nstatic u8 sp_read_reg16(const struct sja1000_priv *priv, int reg)\r\n{\r\nreturn ioread8(priv->reg_base + reg * 2);\r\n}\r\nstatic void sp_write_reg16(const struct sja1000_priv *priv, int reg, u8 val)\r\n{\r\niowrite8(val, priv->reg_base + reg * 2);\r\n}\r\nstatic u8 sp_read_reg32(const struct sja1000_priv *priv, int reg)\r\n{\r\nreturn ioread8(priv->reg_base + reg * 4);\r\n}\r\nstatic void sp_write_reg32(const struct sja1000_priv *priv, int reg, u8 val)\r\n{\r\niowrite8(val, priv->reg_base + reg * 4);\r\n}\r\nstatic int sp_probe(struct platform_device *pdev)\r\n{\r\nint err;\r\nvoid __iomem *addr;\r\nstruct net_device *dev;\r\nstruct sja1000_priv *priv;\r\nstruct resource *res_mem, *res_irq;\r\nstruct sja1000_platform_data *pdata;\r\npdata = pdev->dev.platform_data;\r\nif (!pdata) {\r\ndev_err(&pdev->dev, "No platform data provided!\n");\r\nerr = -ENODEV;\r\ngoto exit;\r\n}\r\nres_mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nres_irq = platform_get_resource(pdev, IORESOURCE_IRQ, 0);\r\nif (!res_mem || !res_irq) {\r\nerr = -ENODEV;\r\ngoto exit;\r\n}\r\nif (!request_mem_region(res_mem->start, resource_size(res_mem),\r\nDRV_NAME)) {\r\nerr = -EBUSY;\r\ngoto exit;\r\n}\r\naddr = ioremap_nocache(res_mem->start, resource_size(res_mem));\r\nif (!addr) {\r\nerr = -ENOMEM;\r\ngoto exit_release;\r\n}\r\ndev = alloc_sja1000dev(0);\r\nif (!dev) {\r\nerr = -ENOMEM;\r\ngoto exit_iounmap;\r\n}\r\npriv = netdev_priv(dev);\r\ndev->irq = res_irq->start;\r\npriv->irq_flags = res_irq->flags & IRQF_TRIGGER_MASK;\r\nif (res_irq->flags & IORESOURCE_IRQ_SHAREABLE)\r\npriv->irq_flags |= IRQF_SHARED;\r\npriv->reg_base = addr;\r\npriv->can.clock.freq = pdata->osc_freq / 2;\r\npriv->ocr = pdata->ocr;\r\npriv->cdr = pdata->cdr;\r\nswitch (res_mem->flags & IORESOURCE_MEM_TYPE_MASK) {\r\ncase IORESOURCE_MEM_32BIT:\r\npriv->read_reg = sp_read_reg32;\r\npriv->write_reg = sp_write_reg32;\r\nbreak;\r\ncase IORESOURCE_MEM_16BIT:\r\npriv->read_reg = sp_read_reg16;\r\npriv->write_reg = sp_write_reg16;\r\nbreak;\r\ncase IORESOURCE_MEM_8BIT:\r\ndefault:\r\npriv->read_reg = sp_read_reg8;\r\npriv->write_reg = sp_write_reg8;\r\nbreak;\r\n}\r\ndev_set_drvdata(&pdev->dev, dev);\r\nSET_NETDEV_DEV(dev, &pdev->dev);\r\nerr = register_sja1000dev(dev);\r\nif (err) {\r\ndev_err(&pdev->dev, "registering %s failed (err=%d)\n",\r\nDRV_NAME, err);\r\ngoto exit_free;\r\n}\r\ndev_info(&pdev->dev, "%s device registered (reg_base=%p, irq=%d)\n",\r\nDRV_NAME, priv->reg_base, dev->irq);\r\nreturn 0;\r\nexit_free:\r\nfree_sja1000dev(dev);\r\nexit_iounmap:\r\niounmap(addr);\r\nexit_release:\r\nrelease_mem_region(res_mem->start, resource_size(res_mem));\r\nexit:\r\nreturn err;\r\n}\r\nstatic int sp_remove(struct platform_device *pdev)\r\n{\r\nstruct net_device *dev = dev_get_drvdata(&pdev->dev);\r\nstruct sja1000_priv *priv = netdev_priv(dev);\r\nstruct resource *res;\r\nunregister_sja1000dev(dev);\r\ndev_set_drvdata(&pdev->dev, NULL);\r\nif (priv->reg_base)\r\niounmap(priv->reg_base);\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nrelease_mem_region(res->start, resource_size(res));\r\nfree_sja1000dev(dev);\r\nreturn 0;\r\n}
