static void aer_error_init(struct aer_error *err, u16 domain,\r\nunsigned int bus, unsigned int devfn,\r\nint pos_cap_err)\r\n{\r\nINIT_LIST_HEAD(&err->list);\r\nerr->domain = domain;\r\nerr->bus = bus;\r\nerr->devfn = devfn;\r\nerr->pos_cap_err = pos_cap_err;\r\n}\r\nstatic struct aer_error *__find_aer_error(u16 domain, unsigned int bus,\r\nunsigned int devfn)\r\n{\r\nstruct aer_error *err;\r\nlist_for_each_entry(err, &einjected, list) {\r\nif (domain == err->domain &&\r\nbus == err->bus &&\r\ndevfn == err->devfn)\r\nreturn err;\r\n}\r\nreturn NULL;\r\n}\r\nstatic struct aer_error *__find_aer_error_by_dev(struct pci_dev *dev)\r\n{\r\nint domain = pci_domain_nr(dev->bus);\r\nif (domain < 0)\r\nreturn NULL;\r\nreturn __find_aer_error((u16)domain, dev->bus->number, dev->devfn);\r\n}\r\nstatic struct pci_ops *__find_pci_bus_ops(struct pci_bus *bus)\r\n{\r\nstruct pci_bus_ops *bus_ops;\r\nlist_for_each_entry(bus_ops, &pci_bus_ops_list, list) {\r\nif (bus_ops->bus == bus)\r\nreturn bus_ops->ops;\r\n}\r\nreturn NULL;\r\n}\r\nstatic struct pci_bus_ops *pci_bus_ops_pop(void)\r\n{\r\nunsigned long flags;\r\nstruct pci_bus_ops *bus_ops = NULL;\r\nspin_lock_irqsave(&inject_lock, flags);\r\nif (list_empty(&pci_bus_ops_list))\r\nbus_ops = NULL;\r\nelse {\r\nstruct list_head *lh = pci_bus_ops_list.next;\r\nlist_del(lh);\r\nbus_ops = list_entry(lh, struct pci_bus_ops, list);\r\n}\r\nspin_unlock_irqrestore(&inject_lock, flags);\r\nreturn bus_ops;\r\n}\r\nstatic u32 *find_pci_config_dword(struct aer_error *err, int where,\r\nint *prw1cs)\r\n{\r\nint rw1cs = 0;\r\nu32 *target = NULL;\r\nif (err->pos_cap_err == -1)\r\nreturn NULL;\r\nswitch (where - err->pos_cap_err) {\r\ncase PCI_ERR_UNCOR_STATUS:\r\ntarget = &err->uncor_status;\r\nrw1cs = 1;\r\nbreak;\r\ncase PCI_ERR_COR_STATUS:\r\ntarget = &err->cor_status;\r\nrw1cs = 1;\r\nbreak;\r\ncase PCI_ERR_HEADER_LOG:\r\ntarget = &err->header_log0;\r\nbreak;\r\ncase PCI_ERR_HEADER_LOG+4:\r\ntarget = &err->header_log1;\r\nbreak;\r\ncase PCI_ERR_HEADER_LOG+8:\r\ntarget = &err->header_log2;\r\nbreak;\r\ncase PCI_ERR_HEADER_LOG+12:\r\ntarget = &err->header_log3;\r\nbreak;\r\ncase PCI_ERR_ROOT_STATUS:\r\ntarget = &err->root_status;\r\nrw1cs = 1;\r\nbreak;\r\ncase PCI_ERR_ROOT_ERR_SRC:\r\ntarget = &err->source_id;\r\nbreak;\r\n}\r\nif (prw1cs)\r\n*prw1cs = rw1cs;\r\nreturn target;\r\n}\r\nstatic int pci_read_aer(struct pci_bus *bus, unsigned int devfn, int where,\r\nint size, u32 *val)\r\n{\r\nu32 *sim;\r\nstruct aer_error *err;\r\nunsigned long flags;\r\nstruct pci_ops *ops;\r\nint domain;\r\nspin_lock_irqsave(&inject_lock, flags);\r\nif (size != sizeof(u32))\r\ngoto out;\r\ndomain = pci_domain_nr(bus);\r\nif (domain < 0)\r\ngoto out;\r\nerr = __find_aer_error((u16)domain, bus->number, devfn);\r\nif (!err)\r\ngoto out;\r\nsim = find_pci_config_dword(err, where, NULL);\r\nif (sim) {\r\n*val = *sim;\r\nspin_unlock_irqrestore(&inject_lock, flags);\r\nreturn 0;\r\n}\r\nout:\r\nops = __find_pci_bus_ops(bus);\r\nspin_unlock_irqrestore(&inject_lock, flags);\r\nreturn ops->read(bus, devfn, where, size, val);\r\n}\r\nint pci_write_aer(struct pci_bus *bus, unsigned int devfn, int where, int size,\r\nu32 val)\r\n{\r\nu32 *sim;\r\nstruct aer_error *err;\r\nunsigned long flags;\r\nint rw1cs;\r\nstruct pci_ops *ops;\r\nint domain;\r\nspin_lock_irqsave(&inject_lock, flags);\r\nif (size != sizeof(u32))\r\ngoto out;\r\ndomain = pci_domain_nr(bus);\r\nif (domain < 0)\r\ngoto out;\r\nerr = __find_aer_error((u16)domain, bus->number, devfn);\r\nif (!err)\r\ngoto out;\r\nsim = find_pci_config_dword(err, where, &rw1cs);\r\nif (sim) {\r\nif (rw1cs)\r\n*sim ^= val;\r\nelse\r\n*sim = val;\r\nspin_unlock_irqrestore(&inject_lock, flags);\r\nreturn 0;\r\n}\r\nout:\r\nops = __find_pci_bus_ops(bus);\r\nspin_unlock_irqrestore(&inject_lock, flags);\r\nreturn ops->write(bus, devfn, where, size, val);\r\n}\r\nstatic void pci_bus_ops_init(struct pci_bus_ops *bus_ops,\r\nstruct pci_bus *bus,\r\nstruct pci_ops *ops)\r\n{\r\nINIT_LIST_HEAD(&bus_ops->list);\r\nbus_ops->bus = bus;\r\nbus_ops->ops = ops;\r\n}\r\nstatic int pci_bus_set_aer_ops(struct pci_bus *bus)\r\n{\r\nstruct pci_ops *ops;\r\nstruct pci_bus_ops *bus_ops;\r\nunsigned long flags;\r\nbus_ops = kmalloc(sizeof(*bus_ops), GFP_KERNEL);\r\nif (!bus_ops)\r\nreturn -ENOMEM;\r\nops = pci_bus_set_ops(bus, &pci_ops_aer);\r\nspin_lock_irqsave(&inject_lock, flags);\r\nif (ops == &pci_ops_aer)\r\ngoto out;\r\npci_bus_ops_init(bus_ops, bus, ops);\r\nlist_add(&bus_ops->list, &pci_bus_ops_list);\r\nbus_ops = NULL;\r\nout:\r\nspin_unlock_irqrestore(&inject_lock, flags);\r\nkfree(bus_ops);\r\nreturn 0;\r\n}\r\nstatic struct pci_dev *pcie_find_root_port(struct pci_dev *dev)\r\n{\r\nwhile (1) {\r\nif (!pci_is_pcie(dev))\r\nbreak;\r\nif (pci_pcie_type(dev) == PCI_EXP_TYPE_ROOT_PORT)\r\nreturn dev;\r\nif (!dev->bus->self)\r\nbreak;\r\ndev = dev->bus->self;\r\n}\r\nreturn NULL;\r\n}\r\nstatic int find_aer_device_iter(struct device *device, void *data)\r\n{\r\nstruct pcie_device **result = data;\r\nstruct pcie_device *pcie_dev;\r\nif (device->bus == &pcie_port_bus_type) {\r\npcie_dev = to_pcie_device(device);\r\nif (pcie_dev->service & PCIE_PORT_SERVICE_AER) {\r\n*result = pcie_dev;\r\nreturn 1;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int find_aer_device(struct pci_dev *dev, struct pcie_device **result)\r\n{\r\nreturn device_for_each_child(&dev->dev, result, find_aer_device_iter);\r\n}\r\nstatic int aer_inject(struct aer_error_inj *einj)\r\n{\r\nstruct aer_error *err, *rperr;\r\nstruct aer_error *err_alloc = NULL, *rperr_alloc = NULL;\r\nstruct pci_dev *dev, *rpdev;\r\nstruct pcie_device *edev;\r\nunsigned long flags;\r\nunsigned int devfn = PCI_DEVFN(einj->dev, einj->fn);\r\nint pos_cap_err, rp_pos_cap_err;\r\nu32 sever, cor_mask, uncor_mask, cor_mask_orig = 0, uncor_mask_orig = 0;\r\nint ret = 0;\r\ndev = pci_get_domain_bus_and_slot((int)einj->domain, einj->bus, devfn);\r\nif (!dev)\r\nreturn -ENODEV;\r\nrpdev = pcie_find_root_port(dev);\r\nif (!rpdev) {\r\nret = -ENOTTY;\r\ngoto out_put;\r\n}\r\npos_cap_err = pci_find_ext_capability(dev, PCI_EXT_CAP_ID_ERR);\r\nif (!pos_cap_err) {\r\nret = -ENOTTY;\r\ngoto out_put;\r\n}\r\npci_read_config_dword(dev, pos_cap_err + PCI_ERR_UNCOR_SEVER, &sever);\r\npci_read_config_dword(dev, pos_cap_err + PCI_ERR_COR_MASK, &cor_mask);\r\npci_read_config_dword(dev, pos_cap_err + PCI_ERR_UNCOR_MASK,\r\n&uncor_mask);\r\nrp_pos_cap_err = pci_find_ext_capability(rpdev, PCI_EXT_CAP_ID_ERR);\r\nif (!rp_pos_cap_err) {\r\nret = -ENOTTY;\r\ngoto out_put;\r\n}\r\nerr_alloc = kzalloc(sizeof(struct aer_error), GFP_KERNEL);\r\nif (!err_alloc) {\r\nret = -ENOMEM;\r\ngoto out_put;\r\n}\r\nrperr_alloc = kzalloc(sizeof(struct aer_error), GFP_KERNEL);\r\nif (!rperr_alloc) {\r\nret = -ENOMEM;\r\ngoto out_put;\r\n}\r\nif (aer_mask_override) {\r\ncor_mask_orig = cor_mask;\r\ncor_mask &= !(einj->cor_status);\r\npci_write_config_dword(dev, pos_cap_err + PCI_ERR_COR_MASK,\r\ncor_mask);\r\nuncor_mask_orig = uncor_mask;\r\nuncor_mask &= !(einj->uncor_status);\r\npci_write_config_dword(dev, pos_cap_err + PCI_ERR_UNCOR_MASK,\r\nuncor_mask);\r\n}\r\nspin_lock_irqsave(&inject_lock, flags);\r\nerr = __find_aer_error_by_dev(dev);\r\nif (!err) {\r\nerr = err_alloc;\r\nerr_alloc = NULL;\r\naer_error_init(err, einj->domain, einj->bus, devfn,\r\npos_cap_err);\r\nlist_add(&err->list, &einjected);\r\n}\r\nerr->uncor_status |= einj->uncor_status;\r\nerr->cor_status |= einj->cor_status;\r\nerr->header_log0 = einj->header_log0;\r\nerr->header_log1 = einj->header_log1;\r\nerr->header_log2 = einj->header_log2;\r\nerr->header_log3 = einj->header_log3;\r\nif (!aer_mask_override && einj->cor_status &&\r\n!(einj->cor_status & ~cor_mask)) {\r\nret = -EINVAL;\r\nprintk(KERN_WARNING "The correctable error(s) is masked "\r\n"by device\n");\r\nspin_unlock_irqrestore(&inject_lock, flags);\r\ngoto out_put;\r\n}\r\nif (!aer_mask_override && einj->uncor_status &&\r\n!(einj->uncor_status & ~uncor_mask)) {\r\nret = -EINVAL;\r\nprintk(KERN_WARNING "The uncorrectable error(s) is masked "\r\n"by device\n");\r\nspin_unlock_irqrestore(&inject_lock, flags);\r\ngoto out_put;\r\n}\r\nrperr = __find_aer_error_by_dev(rpdev);\r\nif (!rperr) {\r\nrperr = rperr_alloc;\r\nrperr_alloc = NULL;\r\naer_error_init(rperr, pci_domain_nr(rpdev->bus),\r\nrpdev->bus->number, rpdev->devfn,\r\nrp_pos_cap_err);\r\nlist_add(&rperr->list, &einjected);\r\n}\r\nif (einj->cor_status) {\r\nif (rperr->root_status & PCI_ERR_ROOT_COR_RCV)\r\nrperr->root_status |= PCI_ERR_ROOT_MULTI_COR_RCV;\r\nelse\r\nrperr->root_status |= PCI_ERR_ROOT_COR_RCV;\r\nrperr->source_id &= 0xffff0000;\r\nrperr->source_id |= (einj->bus << 8) | devfn;\r\n}\r\nif (einj->uncor_status) {\r\nif (rperr->root_status & PCI_ERR_ROOT_UNCOR_RCV)\r\nrperr->root_status |= PCI_ERR_ROOT_MULTI_UNCOR_RCV;\r\nif (sever & einj->uncor_status) {\r\nrperr->root_status |= PCI_ERR_ROOT_FATAL_RCV;\r\nif (!(rperr->root_status & PCI_ERR_ROOT_UNCOR_RCV))\r\nrperr->root_status |= PCI_ERR_ROOT_FIRST_FATAL;\r\n} else\r\nrperr->root_status |= PCI_ERR_ROOT_NONFATAL_RCV;\r\nrperr->root_status |= PCI_ERR_ROOT_UNCOR_RCV;\r\nrperr->source_id &= 0x0000ffff;\r\nrperr->source_id |= ((einj->bus << 8) | devfn) << 16;\r\n}\r\nspin_unlock_irqrestore(&inject_lock, flags);\r\nif (aer_mask_override) {\r\npci_write_config_dword(dev, pos_cap_err + PCI_ERR_COR_MASK,\r\ncor_mask_orig);\r\npci_write_config_dword(dev, pos_cap_err + PCI_ERR_UNCOR_MASK,\r\nuncor_mask_orig);\r\n}\r\nret = pci_bus_set_aer_ops(dev->bus);\r\nif (ret)\r\ngoto out_put;\r\nret = pci_bus_set_aer_ops(rpdev->bus);\r\nif (ret)\r\ngoto out_put;\r\nif (find_aer_device(rpdev, &edev)) {\r\nif (!get_service_data(edev)) {\r\nprintk(KERN_WARNING "AER service is not initialized\n");\r\nret = -EINVAL;\r\ngoto out_put;\r\n}\r\naer_irq(-1, edev);\r\n}\r\nelse\r\nret = -EINVAL;\r\nout_put:\r\nkfree(err_alloc);\r\nkfree(rperr_alloc);\r\npci_dev_put(dev);\r\nreturn ret;\r\n}\r\nstatic ssize_t aer_inject_write(struct file *filp, const char __user *ubuf,\r\nsize_t usize, loff_t *off)\r\n{\r\nstruct aer_error_inj einj;\r\nint ret;\r\nif (!capable(CAP_SYS_ADMIN))\r\nreturn -EPERM;\r\nif (usize < offsetof(struct aer_error_inj, domain) ||\r\nusize > sizeof(einj))\r\nreturn -EINVAL;\r\nmemset(&einj, 0, sizeof(einj));\r\nif (copy_from_user(&einj, ubuf, usize))\r\nreturn -EFAULT;\r\nret = aer_inject(&einj);\r\nreturn ret ? ret : usize;\r\n}\r\nstatic int __init aer_inject_init(void)\r\n{\r\nreturn misc_register(&aer_inject_device);\r\n}\r\nstatic void __exit aer_inject_exit(void)\r\n{\r\nstruct aer_error *err, *err_next;\r\nunsigned long flags;\r\nstruct pci_bus_ops *bus_ops;\r\nmisc_deregister(&aer_inject_device);\r\nwhile ((bus_ops = pci_bus_ops_pop())) {\r\npci_bus_set_ops(bus_ops->bus, bus_ops->ops);\r\nkfree(bus_ops);\r\n}\r\nspin_lock_irqsave(&inject_lock, flags);\r\nlist_for_each_entry_safe(err, err_next, &einjected, list) {\r\nlist_del(&err->list);\r\nkfree(err);\r\n}\r\nspin_unlock_irqrestore(&inject_lock, flags);\r\n}
