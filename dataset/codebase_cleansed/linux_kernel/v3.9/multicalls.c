void xen_mc_flush(void)\r\n{\r\nstruct mc_buffer *b = &__get_cpu_var(mc_buffer);\r\nstruct multicall_entry *mc;\r\nint ret = 0;\r\nunsigned long flags;\r\nint i;\r\nBUG_ON(preemptible());\r\nlocal_irq_save(flags);\r\ntrace_xen_mc_flush(b->mcidx, b->argidx, b->cbidx);\r\nswitch (b->mcidx) {\r\ncase 0:\r\nBUG_ON(b->argidx != 0);\r\nbreak;\r\ncase 1:\r\nmc = &b->entries[0];\r\nmc->result = privcmd_call(mc->op,\r\nmc->args[0], mc->args[1], mc->args[2],\r\nmc->args[3], mc->args[4]);\r\nret = mc->result < 0;\r\nbreak;\r\ndefault:\r\n#if MC_DEBUG\r\nmemcpy(b->debug, b->entries,\r\nb->mcidx * sizeof(struct multicall_entry));\r\n#endif\r\nif (HYPERVISOR_multicall(b->entries, b->mcidx) != 0)\r\nBUG();\r\nfor (i = 0; i < b->mcidx; i++)\r\nif (b->entries[i].result < 0)\r\nret++;\r\n#if MC_DEBUG\r\nif (ret) {\r\nprintk(KERN_ERR "%d multicall(s) failed: cpu %d\n",\r\nret, smp_processor_id());\r\ndump_stack();\r\nfor (i = 0; i < b->mcidx; i++) {\r\nprintk(KERN_DEBUG " call %2d/%d: op=%lu arg=[%lx] result=%ld\t%pF\n",\r\ni+1, b->mcidx,\r\nb->debug[i].op,\r\nb->debug[i].args[0],\r\nb->entries[i].result,\r\nb->caller[i]);\r\n}\r\n}\r\n#endif\r\n}\r\nb->mcidx = 0;\r\nb->argidx = 0;\r\nfor (i = 0; i < b->cbidx; i++) {\r\nstruct callback *cb = &b->callbacks[i];\r\n(*cb->fn)(cb->data);\r\n}\r\nb->cbidx = 0;\r\nlocal_irq_restore(flags);\r\nWARN_ON(ret);\r\n}\r\nstruct multicall_space __xen_mc_entry(size_t args)\r\n{\r\nstruct mc_buffer *b = &__get_cpu_var(mc_buffer);\r\nstruct multicall_space ret;\r\nunsigned argidx = roundup(b->argidx, sizeof(u64));\r\ntrace_xen_mc_entry_alloc(args);\r\nBUG_ON(preemptible());\r\nBUG_ON(b->argidx >= MC_ARGS);\r\nif (unlikely(b->mcidx == MC_BATCH ||\r\n(argidx + args) >= MC_ARGS)) {\r\ntrace_xen_mc_flush_reason((b->mcidx == MC_BATCH) ?\r\nXEN_MC_FL_BATCH : XEN_MC_FL_ARGS);\r\nxen_mc_flush();\r\nargidx = roundup(b->argidx, sizeof(u64));\r\n}\r\nret.mc = &b->entries[b->mcidx];\r\n#if MC_DEBUG\r\nb->caller[b->mcidx] = __builtin_return_address(0);\r\n#endif\r\nb->mcidx++;\r\nret.args = &b->args[argidx];\r\nb->argidx = argidx + args;\r\nBUG_ON(b->argidx >= MC_ARGS);\r\nreturn ret;\r\n}\r\nstruct multicall_space xen_mc_extend_args(unsigned long op, size_t size)\r\n{\r\nstruct mc_buffer *b = &__get_cpu_var(mc_buffer);\r\nstruct multicall_space ret = { NULL, NULL };\r\nBUG_ON(preemptible());\r\nBUG_ON(b->argidx >= MC_ARGS);\r\nif (unlikely(b->mcidx == 0 ||\r\nb->entries[b->mcidx - 1].op != op)) {\r\ntrace_xen_mc_extend_args(op, size, XEN_MC_XE_BAD_OP);\r\ngoto out;\r\n}\r\nif (unlikely((b->argidx + size) >= MC_ARGS)) {\r\ntrace_xen_mc_extend_args(op, size, XEN_MC_XE_NO_SPACE);\r\ngoto out;\r\n}\r\nret.mc = &b->entries[b->mcidx - 1];\r\nret.args = &b->args[b->argidx];\r\nb->argidx += size;\r\nBUG_ON(b->argidx >= MC_ARGS);\r\ntrace_xen_mc_extend_args(op, size, XEN_MC_XE_OK);\r\nout:\r\nreturn ret;\r\n}\r\nvoid xen_mc_callback(void (*fn)(void *), void *data)\r\n{\r\nstruct mc_buffer *b = &__get_cpu_var(mc_buffer);\r\nstruct callback *cb;\r\nif (b->cbidx == MC_BATCH) {\r\ntrace_xen_mc_flush_reason(XEN_MC_FL_CALLBACK);\r\nxen_mc_flush();\r\n}\r\ntrace_xen_mc_callback(fn, data);\r\ncb = &b->callbacks[b->cbidx++];\r\ncb->fn = fn;\r\ncb->data = data;\r\n}
