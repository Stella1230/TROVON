static int netlbl_mgmt_add_common(struct genl_info *info,\r\nstruct netlbl_audit *audit_info)\r\n{\r\nint ret_val = -EINVAL;\r\nstruct netlbl_dom_map *entry = NULL;\r\nstruct netlbl_domaddr_map *addrmap = NULL;\r\nstruct cipso_v4_doi *cipsov4 = NULL;\r\nu32 tmp_val;\r\nentry = kzalloc(sizeof(*entry), GFP_KERNEL);\r\nif (entry == NULL) {\r\nret_val = -ENOMEM;\r\ngoto add_failure;\r\n}\r\nentry->type = nla_get_u32(info->attrs[NLBL_MGMT_A_PROTOCOL]);\r\nif (info->attrs[NLBL_MGMT_A_DOMAIN]) {\r\nsize_t tmp_size = nla_len(info->attrs[NLBL_MGMT_A_DOMAIN]);\r\nentry->domain = kmalloc(tmp_size, GFP_KERNEL);\r\nif (entry->domain == NULL) {\r\nret_val = -ENOMEM;\r\ngoto add_failure;\r\n}\r\nnla_strlcpy(entry->domain,\r\ninfo->attrs[NLBL_MGMT_A_DOMAIN], tmp_size);\r\n}\r\nswitch (entry->type) {\r\ncase NETLBL_NLTYPE_UNLABELED:\r\nbreak;\r\ncase NETLBL_NLTYPE_CIPSOV4:\r\nif (!info->attrs[NLBL_MGMT_A_CV4DOI])\r\ngoto add_failure;\r\ntmp_val = nla_get_u32(info->attrs[NLBL_MGMT_A_CV4DOI]);\r\ncipsov4 = cipso_v4_doi_getdef(tmp_val);\r\nif (cipsov4 == NULL)\r\ngoto add_failure;\r\nentry->type_def.cipsov4 = cipsov4;\r\nbreak;\r\ndefault:\r\ngoto add_failure;\r\n}\r\nif (info->attrs[NLBL_MGMT_A_IPV4ADDR]) {\r\nstruct in_addr *addr;\r\nstruct in_addr *mask;\r\nstruct netlbl_domaddr4_map *map;\r\naddrmap = kzalloc(sizeof(*addrmap), GFP_KERNEL);\r\nif (addrmap == NULL) {\r\nret_val = -ENOMEM;\r\ngoto add_failure;\r\n}\r\nINIT_LIST_HEAD(&addrmap->list4);\r\nINIT_LIST_HEAD(&addrmap->list6);\r\nif (nla_len(info->attrs[NLBL_MGMT_A_IPV4ADDR]) !=\r\nsizeof(struct in_addr)) {\r\nret_val = -EINVAL;\r\ngoto add_failure;\r\n}\r\nif (nla_len(info->attrs[NLBL_MGMT_A_IPV4MASK]) !=\r\nsizeof(struct in_addr)) {\r\nret_val = -EINVAL;\r\ngoto add_failure;\r\n}\r\naddr = nla_data(info->attrs[NLBL_MGMT_A_IPV4ADDR]);\r\nmask = nla_data(info->attrs[NLBL_MGMT_A_IPV4MASK]);\r\nmap = kzalloc(sizeof(*map), GFP_KERNEL);\r\nif (map == NULL) {\r\nret_val = -ENOMEM;\r\ngoto add_failure;\r\n}\r\nmap->list.addr = addr->s_addr & mask->s_addr;\r\nmap->list.mask = mask->s_addr;\r\nmap->list.valid = 1;\r\nmap->type = entry->type;\r\nif (cipsov4)\r\nmap->type_def.cipsov4 = cipsov4;\r\nret_val = netlbl_af4list_add(&map->list, &addrmap->list4);\r\nif (ret_val != 0) {\r\nkfree(map);\r\ngoto add_failure;\r\n}\r\nentry->type = NETLBL_NLTYPE_ADDRSELECT;\r\nentry->type_def.addrsel = addrmap;\r\n#if IS_ENABLED(CONFIG_IPV6)\r\n} else if (info->attrs[NLBL_MGMT_A_IPV6ADDR]) {\r\nstruct in6_addr *addr;\r\nstruct in6_addr *mask;\r\nstruct netlbl_domaddr6_map *map;\r\naddrmap = kzalloc(sizeof(*addrmap), GFP_KERNEL);\r\nif (addrmap == NULL) {\r\nret_val = -ENOMEM;\r\ngoto add_failure;\r\n}\r\nINIT_LIST_HEAD(&addrmap->list4);\r\nINIT_LIST_HEAD(&addrmap->list6);\r\nif (nla_len(info->attrs[NLBL_MGMT_A_IPV6ADDR]) !=\r\nsizeof(struct in6_addr)) {\r\nret_val = -EINVAL;\r\ngoto add_failure;\r\n}\r\nif (nla_len(info->attrs[NLBL_MGMT_A_IPV6MASK]) !=\r\nsizeof(struct in6_addr)) {\r\nret_val = -EINVAL;\r\ngoto add_failure;\r\n}\r\naddr = nla_data(info->attrs[NLBL_MGMT_A_IPV6ADDR]);\r\nmask = nla_data(info->attrs[NLBL_MGMT_A_IPV6MASK]);\r\nmap = kzalloc(sizeof(*map), GFP_KERNEL);\r\nif (map == NULL) {\r\nret_val = -ENOMEM;\r\ngoto add_failure;\r\n}\r\nmap->list.addr = *addr;\r\nmap->list.addr.s6_addr32[0] &= mask->s6_addr32[0];\r\nmap->list.addr.s6_addr32[1] &= mask->s6_addr32[1];\r\nmap->list.addr.s6_addr32[2] &= mask->s6_addr32[2];\r\nmap->list.addr.s6_addr32[3] &= mask->s6_addr32[3];\r\nmap->list.mask = *mask;\r\nmap->list.valid = 1;\r\nmap->type = entry->type;\r\nret_val = netlbl_af6list_add(&map->list, &addrmap->list6);\r\nif (ret_val != 0) {\r\nkfree(map);\r\ngoto add_failure;\r\n}\r\nentry->type = NETLBL_NLTYPE_ADDRSELECT;\r\nentry->type_def.addrsel = addrmap;\r\n#endif\r\n}\r\nret_val = netlbl_domhsh_add(entry, audit_info);\r\nif (ret_val != 0)\r\ngoto add_failure;\r\nreturn 0;\r\nadd_failure:\r\nif (cipsov4)\r\ncipso_v4_doi_putdef(cipsov4);\r\nif (entry)\r\nkfree(entry->domain);\r\nkfree(addrmap);\r\nkfree(entry);\r\nreturn ret_val;\r\n}\r\nstatic int netlbl_mgmt_listentry(struct sk_buff *skb,\r\nstruct netlbl_dom_map *entry)\r\n{\r\nint ret_val = 0;\r\nstruct nlattr *nla_a;\r\nstruct nlattr *nla_b;\r\nstruct netlbl_af4list *iter4;\r\n#if IS_ENABLED(CONFIG_IPV6)\r\nstruct netlbl_af6list *iter6;\r\n#endif\r\nif (entry->domain != NULL) {\r\nret_val = nla_put_string(skb,\r\nNLBL_MGMT_A_DOMAIN, entry->domain);\r\nif (ret_val != 0)\r\nreturn ret_val;\r\n}\r\nswitch (entry->type) {\r\ncase NETLBL_NLTYPE_ADDRSELECT:\r\nnla_a = nla_nest_start(skb, NLBL_MGMT_A_SELECTORLIST);\r\nif (nla_a == NULL)\r\nreturn -ENOMEM;\r\nnetlbl_af4list_foreach_rcu(iter4,\r\n&entry->type_def.addrsel->list4) {\r\nstruct netlbl_domaddr4_map *map4;\r\nstruct in_addr addr_struct;\r\nnla_b = nla_nest_start(skb, NLBL_MGMT_A_ADDRSELECTOR);\r\nif (nla_b == NULL)\r\nreturn -ENOMEM;\r\naddr_struct.s_addr = iter4->addr;\r\nret_val = nla_put(skb, NLBL_MGMT_A_IPV4ADDR,\r\nsizeof(struct in_addr),\r\n&addr_struct);\r\nif (ret_val != 0)\r\nreturn ret_val;\r\naddr_struct.s_addr = iter4->mask;\r\nret_val = nla_put(skb, NLBL_MGMT_A_IPV4MASK,\r\nsizeof(struct in_addr),\r\n&addr_struct);\r\nif (ret_val != 0)\r\nreturn ret_val;\r\nmap4 = netlbl_domhsh_addr4_entry(iter4);\r\nret_val = nla_put_u32(skb, NLBL_MGMT_A_PROTOCOL,\r\nmap4->type);\r\nif (ret_val != 0)\r\nreturn ret_val;\r\nswitch (map4->type) {\r\ncase NETLBL_NLTYPE_CIPSOV4:\r\nret_val = nla_put_u32(skb, NLBL_MGMT_A_CV4DOI,\r\nmap4->type_def.cipsov4->doi);\r\nif (ret_val != 0)\r\nreturn ret_val;\r\nbreak;\r\n}\r\nnla_nest_end(skb, nla_b);\r\n}\r\n#if IS_ENABLED(CONFIG_IPV6)\r\nnetlbl_af6list_foreach_rcu(iter6,\r\n&entry->type_def.addrsel->list6) {\r\nstruct netlbl_domaddr6_map *map6;\r\nnla_b = nla_nest_start(skb, NLBL_MGMT_A_ADDRSELECTOR);\r\nif (nla_b == NULL)\r\nreturn -ENOMEM;\r\nret_val = nla_put(skb, NLBL_MGMT_A_IPV6ADDR,\r\nsizeof(struct in6_addr),\r\n&iter6->addr);\r\nif (ret_val != 0)\r\nreturn ret_val;\r\nret_val = nla_put(skb, NLBL_MGMT_A_IPV6MASK,\r\nsizeof(struct in6_addr),\r\n&iter6->mask);\r\nif (ret_val != 0)\r\nreturn ret_val;\r\nmap6 = netlbl_domhsh_addr6_entry(iter6);\r\nret_val = nla_put_u32(skb, NLBL_MGMT_A_PROTOCOL,\r\nmap6->type);\r\nif (ret_val != 0)\r\nreturn ret_val;\r\nnla_nest_end(skb, nla_b);\r\n}\r\n#endif\r\nnla_nest_end(skb, nla_a);\r\nbreak;\r\ncase NETLBL_NLTYPE_UNLABELED:\r\nret_val = nla_put_u32(skb, NLBL_MGMT_A_PROTOCOL, entry->type);\r\nbreak;\r\ncase NETLBL_NLTYPE_CIPSOV4:\r\nret_val = nla_put_u32(skb, NLBL_MGMT_A_PROTOCOL, entry->type);\r\nif (ret_val != 0)\r\nreturn ret_val;\r\nret_val = nla_put_u32(skb, NLBL_MGMT_A_CV4DOI,\r\nentry->type_def.cipsov4->doi);\r\nbreak;\r\n}\r\nreturn ret_val;\r\n}\r\nstatic int netlbl_mgmt_add(struct sk_buff *skb, struct genl_info *info)\r\n{\r\nstruct netlbl_audit audit_info;\r\nif ((!info->attrs[NLBL_MGMT_A_DOMAIN]) ||\r\n(!info->attrs[NLBL_MGMT_A_PROTOCOL]) ||\r\n(info->attrs[NLBL_MGMT_A_IPV4ADDR] &&\r\ninfo->attrs[NLBL_MGMT_A_IPV6ADDR]) ||\r\n(info->attrs[NLBL_MGMT_A_IPV4MASK] &&\r\ninfo->attrs[NLBL_MGMT_A_IPV6MASK]) ||\r\n((info->attrs[NLBL_MGMT_A_IPV4ADDR] != NULL) ^\r\n(info->attrs[NLBL_MGMT_A_IPV4MASK] != NULL)) ||\r\n((info->attrs[NLBL_MGMT_A_IPV6ADDR] != NULL) ^\r\n(info->attrs[NLBL_MGMT_A_IPV6MASK] != NULL)))\r\nreturn -EINVAL;\r\nnetlbl_netlink_auditinfo(skb, &audit_info);\r\nreturn netlbl_mgmt_add_common(info, &audit_info);\r\n}\r\nstatic int netlbl_mgmt_remove(struct sk_buff *skb, struct genl_info *info)\r\n{\r\nchar *domain;\r\nstruct netlbl_audit audit_info;\r\nif (!info->attrs[NLBL_MGMT_A_DOMAIN])\r\nreturn -EINVAL;\r\nnetlbl_netlink_auditinfo(skb, &audit_info);\r\ndomain = nla_data(info->attrs[NLBL_MGMT_A_DOMAIN]);\r\nreturn netlbl_domhsh_remove(domain, &audit_info);\r\n}\r\nstatic int netlbl_mgmt_listall_cb(struct netlbl_dom_map *entry, void *arg)\r\n{\r\nint ret_val = -ENOMEM;\r\nstruct netlbl_domhsh_walk_arg *cb_arg = arg;\r\nvoid *data;\r\ndata = genlmsg_put(cb_arg->skb, NETLINK_CB(cb_arg->nl_cb->skb).portid,\r\ncb_arg->seq, &netlbl_mgmt_gnl_family,\r\nNLM_F_MULTI, NLBL_MGMT_C_LISTALL);\r\nif (data == NULL)\r\ngoto listall_cb_failure;\r\nret_val = netlbl_mgmt_listentry(cb_arg->skb, entry);\r\nif (ret_val != 0)\r\ngoto listall_cb_failure;\r\ncb_arg->seq++;\r\nreturn genlmsg_end(cb_arg->skb, data);\r\nlistall_cb_failure:\r\ngenlmsg_cancel(cb_arg->skb, data);\r\nreturn ret_val;\r\n}\r\nstatic int netlbl_mgmt_listall(struct sk_buff *skb,\r\nstruct netlink_callback *cb)\r\n{\r\nstruct netlbl_domhsh_walk_arg cb_arg;\r\nu32 skip_bkt = cb->args[0];\r\nu32 skip_chain = cb->args[1];\r\ncb_arg.nl_cb = cb;\r\ncb_arg.skb = skb;\r\ncb_arg.seq = cb->nlh->nlmsg_seq;\r\nnetlbl_domhsh_walk(&skip_bkt,\r\n&skip_chain,\r\nnetlbl_mgmt_listall_cb,\r\n&cb_arg);\r\ncb->args[0] = skip_bkt;\r\ncb->args[1] = skip_chain;\r\nreturn skb->len;\r\n}\r\nstatic int netlbl_mgmt_adddef(struct sk_buff *skb, struct genl_info *info)\r\n{\r\nstruct netlbl_audit audit_info;\r\nif ((!info->attrs[NLBL_MGMT_A_PROTOCOL]) ||\r\n(info->attrs[NLBL_MGMT_A_IPV4ADDR] &&\r\ninfo->attrs[NLBL_MGMT_A_IPV6ADDR]) ||\r\n(info->attrs[NLBL_MGMT_A_IPV4MASK] &&\r\ninfo->attrs[NLBL_MGMT_A_IPV6MASK]) ||\r\n((info->attrs[NLBL_MGMT_A_IPV4ADDR] != NULL) ^\r\n(info->attrs[NLBL_MGMT_A_IPV4MASK] != NULL)) ||\r\n((info->attrs[NLBL_MGMT_A_IPV6ADDR] != NULL) ^\r\n(info->attrs[NLBL_MGMT_A_IPV6MASK] != NULL)))\r\nreturn -EINVAL;\r\nnetlbl_netlink_auditinfo(skb, &audit_info);\r\nreturn netlbl_mgmt_add_common(info, &audit_info);\r\n}\r\nstatic int netlbl_mgmt_removedef(struct sk_buff *skb, struct genl_info *info)\r\n{\r\nstruct netlbl_audit audit_info;\r\nnetlbl_netlink_auditinfo(skb, &audit_info);\r\nreturn netlbl_domhsh_remove_default(&audit_info);\r\n}\r\nstatic int netlbl_mgmt_listdef(struct sk_buff *skb, struct genl_info *info)\r\n{\r\nint ret_val = -ENOMEM;\r\nstruct sk_buff *ans_skb = NULL;\r\nvoid *data;\r\nstruct netlbl_dom_map *entry;\r\nans_skb = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\r\nif (ans_skb == NULL)\r\nreturn -ENOMEM;\r\ndata = genlmsg_put_reply(ans_skb, info, &netlbl_mgmt_gnl_family,\r\n0, NLBL_MGMT_C_LISTDEF);\r\nif (data == NULL)\r\ngoto listdef_failure;\r\nrcu_read_lock();\r\nentry = netlbl_domhsh_getentry(NULL);\r\nif (entry == NULL) {\r\nret_val = -ENOENT;\r\ngoto listdef_failure_lock;\r\n}\r\nret_val = netlbl_mgmt_listentry(ans_skb, entry);\r\nrcu_read_unlock();\r\nif (ret_val != 0)\r\ngoto listdef_failure;\r\ngenlmsg_end(ans_skb, data);\r\nreturn genlmsg_reply(ans_skb, info);\r\nlistdef_failure_lock:\r\nrcu_read_unlock();\r\nlistdef_failure:\r\nkfree_skb(ans_skb);\r\nreturn ret_val;\r\n}\r\nstatic int netlbl_mgmt_protocols_cb(struct sk_buff *skb,\r\nstruct netlink_callback *cb,\r\nu32 protocol)\r\n{\r\nint ret_val = -ENOMEM;\r\nvoid *data;\r\ndata = genlmsg_put(skb, NETLINK_CB(cb->skb).portid, cb->nlh->nlmsg_seq,\r\n&netlbl_mgmt_gnl_family, NLM_F_MULTI,\r\nNLBL_MGMT_C_PROTOCOLS);\r\nif (data == NULL)\r\ngoto protocols_cb_failure;\r\nret_val = nla_put_u32(skb, NLBL_MGMT_A_PROTOCOL, protocol);\r\nif (ret_val != 0)\r\ngoto protocols_cb_failure;\r\nreturn genlmsg_end(skb, data);\r\nprotocols_cb_failure:\r\ngenlmsg_cancel(skb, data);\r\nreturn ret_val;\r\n}\r\nstatic int netlbl_mgmt_protocols(struct sk_buff *skb,\r\nstruct netlink_callback *cb)\r\n{\r\nu32 protos_sent = cb->args[0];\r\nif (protos_sent == 0) {\r\nif (netlbl_mgmt_protocols_cb(skb,\r\ncb,\r\nNETLBL_NLTYPE_UNLABELED) < 0)\r\ngoto protocols_return;\r\nprotos_sent++;\r\n}\r\nif (protos_sent == 1) {\r\nif (netlbl_mgmt_protocols_cb(skb,\r\ncb,\r\nNETLBL_NLTYPE_CIPSOV4) < 0)\r\ngoto protocols_return;\r\nprotos_sent++;\r\n}\r\nprotocols_return:\r\ncb->args[0] = protos_sent;\r\nreturn skb->len;\r\n}\r\nstatic int netlbl_mgmt_version(struct sk_buff *skb, struct genl_info *info)\r\n{\r\nint ret_val = -ENOMEM;\r\nstruct sk_buff *ans_skb = NULL;\r\nvoid *data;\r\nans_skb = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\r\nif (ans_skb == NULL)\r\nreturn -ENOMEM;\r\ndata = genlmsg_put_reply(ans_skb, info, &netlbl_mgmt_gnl_family,\r\n0, NLBL_MGMT_C_VERSION);\r\nif (data == NULL)\r\ngoto version_failure;\r\nret_val = nla_put_u32(ans_skb,\r\nNLBL_MGMT_A_VERSION,\r\nNETLBL_PROTO_VERSION);\r\nif (ret_val != 0)\r\ngoto version_failure;\r\ngenlmsg_end(ans_skb, data);\r\nreturn genlmsg_reply(ans_skb, info);\r\nversion_failure:\r\nkfree_skb(ans_skb);\r\nreturn ret_val;\r\n}\r\nint __init netlbl_mgmt_genl_init(void)\r\n{\r\nreturn genl_register_family_with_ops(&netlbl_mgmt_gnl_family,\r\nnetlbl_mgmt_genl_ops, ARRAY_SIZE(netlbl_mgmt_genl_ops));\r\n}
