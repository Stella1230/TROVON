static ssize_t iio_sysfs_trig_add(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf,\r\nsize_t len)\r\n{\r\nint ret;\r\nunsigned long input;\r\nret = strict_strtoul(buf, 10, &input);\r\nif (ret)\r\nreturn ret;\r\nret = iio_sysfs_trigger_probe(input);\r\nif (ret)\r\nreturn ret;\r\nreturn len;\r\n}\r\nstatic ssize_t iio_sysfs_trig_remove(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf,\r\nsize_t len)\r\n{\r\nint ret;\r\nunsigned long input;\r\nret = strict_strtoul(buf, 10, &input);\r\nif (ret)\r\nreturn ret;\r\nret = iio_sysfs_trigger_remove(input);\r\nif (ret)\r\nreturn ret;\r\nreturn len;\r\n}\r\nstatic void iio_trigger_sysfs_release(struct device *dev)\r\n{\r\n}\r\nstatic void iio_sysfs_trigger_work(struct irq_work *work)\r\n{\r\nstruct iio_sysfs_trig *trig = container_of(work, struct iio_sysfs_trig,\r\nwork);\r\niio_trigger_poll(trig->trig, 0);\r\n}\r\nstatic ssize_t iio_sysfs_trigger_poll(struct device *dev,\r\nstruct device_attribute *attr, const char *buf, size_t count)\r\n{\r\nstruct iio_trigger *trig = to_iio_trigger(dev);\r\nstruct iio_sysfs_trig *sysfs_trig = trig->private_data;\r\nirq_work_queue(&sysfs_trig->work);\r\nreturn count;\r\n}\r\nstatic int iio_sysfs_trigger_probe(int id)\r\n{\r\nstruct iio_sysfs_trig *t;\r\nint ret;\r\nbool foundit = false;\r\nmutex_lock(&iio_syfs_trig_list_mut);\r\nlist_for_each_entry(t, &iio_sysfs_trig_list, l)\r\nif (id == t->id) {\r\nfoundit = true;\r\nbreak;\r\n}\r\nif (foundit) {\r\nret = -EINVAL;\r\ngoto out1;\r\n}\r\nt = kmalloc(sizeof(*t), GFP_KERNEL);\r\nif (t == NULL) {\r\nret = -ENOMEM;\r\ngoto out1;\r\n}\r\nt->id = id;\r\nt->trig = iio_trigger_alloc("sysfstrig%d", id);\r\nif (!t->trig) {\r\nret = -ENOMEM;\r\ngoto free_t;\r\n}\r\nt->trig->dev.groups = iio_sysfs_trigger_attr_groups;\r\nt->trig->ops = &iio_sysfs_trigger_ops;\r\nt->trig->dev.parent = &iio_sysfs_trig_dev;\r\nt->trig->private_data = t;\r\ninit_irq_work(&t->work, iio_sysfs_trigger_work);\r\nret = iio_trigger_register(t->trig);\r\nif (ret)\r\ngoto out2;\r\nlist_add(&t->l, &iio_sysfs_trig_list);\r\n__module_get(THIS_MODULE);\r\nmutex_unlock(&iio_syfs_trig_list_mut);\r\nreturn 0;\r\nout2:\r\niio_trigger_put(t->trig);\r\nfree_t:\r\nkfree(t);\r\nout1:\r\nmutex_unlock(&iio_syfs_trig_list_mut);\r\nreturn ret;\r\n}\r\nstatic int iio_sysfs_trigger_remove(int id)\r\n{\r\nbool foundit = false;\r\nstruct iio_sysfs_trig *t;\r\nmutex_lock(&iio_syfs_trig_list_mut);\r\nlist_for_each_entry(t, &iio_sysfs_trig_list, l)\r\nif (id == t->id) {\r\nfoundit = true;\r\nbreak;\r\n}\r\nif (!foundit) {\r\nmutex_unlock(&iio_syfs_trig_list_mut);\r\nreturn -EINVAL;\r\n}\r\niio_trigger_unregister(t->trig);\r\niio_trigger_free(t->trig);\r\nlist_del(&t->l);\r\nkfree(t);\r\nmodule_put(THIS_MODULE);\r\nmutex_unlock(&iio_syfs_trig_list_mut);\r\nreturn 0;\r\n}\r\nstatic int __init iio_sysfs_trig_init(void)\r\n{\r\ndevice_initialize(&iio_sysfs_trig_dev);\r\ndev_set_name(&iio_sysfs_trig_dev, "iio_sysfs_trigger");\r\nreturn device_add(&iio_sysfs_trig_dev);\r\n}\r\nstatic void __exit iio_sysfs_trig_exit(void)\r\n{\r\ndevice_unregister(&iio_sysfs_trig_dev);\r\n}
