static inline struct dsi_data *dsi_get_dsidrv_data(struct platform_device *dsidev)\r\n{\r\nreturn dev_get_drvdata(&dsidev->dev);\r\n}\r\nstatic inline struct platform_device *dsi_get_dsidev_from_dssdev(struct omap_dss_device *dssdev)\r\n{\r\nreturn dssdev->output->pdev;\r\n}\r\nstruct platform_device *dsi_get_dsidev_from_id(int module)\r\n{\r\nstruct omap_dss_output *out;\r\nenum omap_dss_output_id id;\r\nswitch (module) {\r\ncase 0:\r\nid = OMAP_DSS_OUTPUT_DSI1;\r\nbreak;\r\ncase 1:\r\nid = OMAP_DSS_OUTPUT_DSI2;\r\nbreak;\r\ndefault:\r\nreturn NULL;\r\n}\r\nout = omap_dss_get_output(id);\r\nreturn out ? out->pdev : NULL;\r\n}\r\nstatic inline void dsi_write_reg(struct platform_device *dsidev,\r\nconst struct dsi_reg idx, u32 val)\r\n{\r\nstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\r\n__raw_writel(val, dsi->base + idx.idx);\r\n}\r\nstatic inline u32 dsi_read_reg(struct platform_device *dsidev,\r\nconst struct dsi_reg idx)\r\n{\r\nstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\r\nreturn __raw_readl(dsi->base + idx.idx);\r\n}\r\nvoid dsi_bus_lock(struct omap_dss_device *dssdev)\r\n{\r\nstruct platform_device *dsidev = dsi_get_dsidev_from_dssdev(dssdev);\r\nstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\r\ndown(&dsi->bus_lock);\r\n}\r\nvoid dsi_bus_unlock(struct omap_dss_device *dssdev)\r\n{\r\nstruct platform_device *dsidev = dsi_get_dsidev_from_dssdev(dssdev);\r\nstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\r\nup(&dsi->bus_lock);\r\n}\r\nstatic bool dsi_bus_is_locked(struct platform_device *dsidev)\r\n{\r\nstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\r\nreturn dsi->bus_lock.count == 0;\r\n}\r\nstatic void dsi_completion_handler(void *data, u32 mask)\r\n{\r\ncomplete((struct completion *)data);\r\n}\r\nstatic inline int wait_for_bit_change(struct platform_device *dsidev,\r\nconst struct dsi_reg idx, int bitnum, int value)\r\n{\r\nunsigned long timeout;\r\nktime_t wait;\r\nint t;\r\nt = 100;\r\nwhile (t-- > 0) {\r\nif (REG_GET(dsidev, idx, bitnum, bitnum) == value)\r\nreturn value;\r\n}\r\ntimeout = jiffies + msecs_to_jiffies(500);\r\nwhile (time_before(jiffies, timeout)) {\r\nif (REG_GET(dsidev, idx, bitnum, bitnum) == value)\r\nreturn value;\r\nwait = ns_to_ktime(1000 * 1000);\r\nset_current_state(TASK_UNINTERRUPTIBLE);\r\nschedule_hrtimeout(&wait, HRTIMER_MODE_REL);\r\n}\r\nreturn !value;\r\n}\r\nu8 dsi_get_pixel_size(enum omap_dss_dsi_pixel_format fmt)\r\n{\r\nswitch (fmt) {\r\ncase OMAP_DSS_DSI_FMT_RGB888:\r\ncase OMAP_DSS_DSI_FMT_RGB666:\r\nreturn 24;\r\ncase OMAP_DSS_DSI_FMT_RGB666_PACKED:\r\nreturn 18;\r\ncase OMAP_DSS_DSI_FMT_RGB565:\r\nreturn 16;\r\ndefault:\r\nBUG();\r\nreturn 0;\r\n}\r\n}\r\nstatic void dsi_perf_mark_setup(struct platform_device *dsidev)\r\n{\r\nstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\r\ndsi->perf_setup_time = ktime_get();\r\n}\r\nstatic void dsi_perf_mark_start(struct platform_device *dsidev)\r\n{\r\nstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\r\ndsi->perf_start_time = ktime_get();\r\n}\r\nstatic void dsi_perf_show(struct platform_device *dsidev, const char *name)\r\n{\r\nstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\r\nktime_t t, setup_time, trans_time;\r\nu32 total_bytes;\r\nu32 setup_us, trans_us, total_us;\r\nif (!dsi_perf)\r\nreturn;\r\nt = ktime_get();\r\nsetup_time = ktime_sub(dsi->perf_start_time, dsi->perf_setup_time);\r\nsetup_us = (u32)ktime_to_us(setup_time);\r\nif (setup_us == 0)\r\nsetup_us = 1;\r\ntrans_time = ktime_sub(t, dsi->perf_start_time);\r\ntrans_us = (u32)ktime_to_us(trans_time);\r\nif (trans_us == 0)\r\ntrans_us = 1;\r\ntotal_us = setup_us + trans_us;\r\ntotal_bytes = dsi->update_bytes;\r\nprintk(KERN_INFO "DSI(%s): %u us + %u us = %u us (%uHz), "\r\n"%u bytes, %u kbytes/sec\n",\r\nname,\r\nsetup_us,\r\ntrans_us,\r\ntotal_us,\r\n1000*1000 / total_us,\r\ntotal_bytes,\r\ntotal_bytes * 1000 / total_us);\r\n}\r\nstatic inline void dsi_perf_mark_setup(struct platform_device *dsidev)\r\n{\r\n}\r\nstatic inline void dsi_perf_mark_start(struct platform_device *dsidev)\r\n{\r\n}\r\nstatic inline void dsi_perf_show(struct platform_device *dsidev,\r\nconst char *name)\r\n{\r\n}\r\nstatic void print_irq_status(u32 status)\r\n{\r\nif (status == 0)\r\nreturn;\r\nif (!verbose_irq && (status & ~DSI_IRQ_CHANNEL_MASK) == 0)\r\nreturn;\r\n#define PIS(x) (status & DSI_IRQ_##x) ? (#x " ") : ""\r\npr_debug("DSI IRQ: 0x%x: %s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s\n",\r\nstatus,\r\nverbose_irq ? PIS(VC0) : "",\r\nverbose_irq ? PIS(VC1) : "",\r\nverbose_irq ? PIS(VC2) : "",\r\nverbose_irq ? PIS(VC3) : "",\r\nPIS(WAKEUP),\r\nPIS(RESYNC),\r\nPIS(PLL_LOCK),\r\nPIS(PLL_UNLOCK),\r\nPIS(PLL_RECALL),\r\nPIS(COMPLEXIO_ERR),\r\nPIS(HS_TX_TIMEOUT),\r\nPIS(LP_RX_TIMEOUT),\r\nPIS(TE_TRIGGER),\r\nPIS(ACK_TRIGGER),\r\nPIS(SYNC_LOST),\r\nPIS(LDO_POWER_GOOD),\r\nPIS(TA_TIMEOUT));\r\n#undef PIS\r\n}\r\nstatic void print_irq_status_vc(int channel, u32 status)\r\n{\r\nif (status == 0)\r\nreturn;\r\nif (!verbose_irq && (status & ~DSI_VC_IRQ_PACKET_SENT) == 0)\r\nreturn;\r\n#define PIS(x) (status & DSI_VC_IRQ_##x) ? (#x " ") : ""\r\npr_debug("DSI VC(%d) IRQ 0x%x: %s%s%s%s%s%s%s%s%s\n",\r\nchannel,\r\nstatus,\r\nPIS(CS),\r\nPIS(ECC_CORR),\r\nPIS(ECC_NO_CORR),\r\nverbose_irq ? PIS(PACKET_SENT) : "",\r\nPIS(BTA),\r\nPIS(FIFO_TX_OVF),\r\nPIS(FIFO_RX_OVF),\r\nPIS(FIFO_TX_UDF),\r\nPIS(PP_BUSY_CHANGE));\r\n#undef PIS\r\n}\r\nstatic void print_irq_status_cio(u32 status)\r\n{\r\nif (status == 0)\r\nreturn;\r\n#define PIS(x) (status & DSI_CIO_IRQ_##x) ? (#x " ") : ""\r\npr_debug("DSI CIO IRQ 0x%x: %s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s\n",\r\nstatus,\r\nPIS(ERRSYNCESC1),\r\nPIS(ERRSYNCESC2),\r\nPIS(ERRSYNCESC3),\r\nPIS(ERRESC1),\r\nPIS(ERRESC2),\r\nPIS(ERRESC3),\r\nPIS(ERRCONTROL1),\r\nPIS(ERRCONTROL2),\r\nPIS(ERRCONTROL3),\r\nPIS(STATEULPS1),\r\nPIS(STATEULPS2),\r\nPIS(STATEULPS3),\r\nPIS(ERRCONTENTIONLP0_1),\r\nPIS(ERRCONTENTIONLP1_1),\r\nPIS(ERRCONTENTIONLP0_2),\r\nPIS(ERRCONTENTIONLP1_2),\r\nPIS(ERRCONTENTIONLP0_3),\r\nPIS(ERRCONTENTIONLP1_3),\r\nPIS(ULPSACTIVENOT_ALL0),\r\nPIS(ULPSACTIVENOT_ALL1));\r\n#undef PIS\r\n}\r\nstatic void dsi_collect_irq_stats(struct platform_device *dsidev, u32 irqstatus,\r\nu32 *vcstatus, u32 ciostatus)\r\n{\r\nstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\r\nint i;\r\nspin_lock(&dsi->irq_stats_lock);\r\ndsi->irq_stats.irq_count++;\r\ndss_collect_irq_stats(irqstatus, dsi->irq_stats.dsi_irqs);\r\nfor (i = 0; i < 4; ++i)\r\ndss_collect_irq_stats(vcstatus[i], dsi->irq_stats.vc_irqs[i]);\r\ndss_collect_irq_stats(ciostatus, dsi->irq_stats.cio_irqs);\r\nspin_unlock(&dsi->irq_stats_lock);\r\n}\r\nstatic void dsi_handle_irq_errors(struct platform_device *dsidev, u32 irqstatus,\r\nu32 *vcstatus, u32 ciostatus)\r\n{\r\nstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\r\nint i;\r\nif (irqstatus & DSI_IRQ_ERROR_MASK) {\r\nDSSERR("DSI error, irqstatus %x\n", irqstatus);\r\nprint_irq_status(irqstatus);\r\nspin_lock(&dsi->errors_lock);\r\ndsi->errors |= irqstatus & DSI_IRQ_ERROR_MASK;\r\nspin_unlock(&dsi->errors_lock);\r\n} else if (debug_irq) {\r\nprint_irq_status(irqstatus);\r\n}\r\nfor (i = 0; i < 4; ++i) {\r\nif (vcstatus[i] & DSI_VC_IRQ_ERROR_MASK) {\r\nDSSERR("DSI VC(%d) error, vc irqstatus %x\n",\r\ni, vcstatus[i]);\r\nprint_irq_status_vc(i, vcstatus[i]);\r\n} else if (debug_irq) {\r\nprint_irq_status_vc(i, vcstatus[i]);\r\n}\r\n}\r\nif (ciostatus & DSI_CIO_IRQ_ERROR_MASK) {\r\nDSSERR("DSI CIO error, cio irqstatus %x\n", ciostatus);\r\nprint_irq_status_cio(ciostatus);\r\n} else if (debug_irq) {\r\nprint_irq_status_cio(ciostatus);\r\n}\r\n}\r\nstatic void dsi_call_isrs(struct dsi_isr_data *isr_array,\r\nunsigned isr_array_size, u32 irqstatus)\r\n{\r\nstruct dsi_isr_data *isr_data;\r\nint i;\r\nfor (i = 0; i < isr_array_size; i++) {\r\nisr_data = &isr_array[i];\r\nif (isr_data->isr && isr_data->mask & irqstatus)\r\nisr_data->isr(isr_data->arg, irqstatus);\r\n}\r\n}\r\nstatic void dsi_handle_isrs(struct dsi_isr_tables *isr_tables,\r\nu32 irqstatus, u32 *vcstatus, u32 ciostatus)\r\n{\r\nint i;\r\ndsi_call_isrs(isr_tables->isr_table,\r\nARRAY_SIZE(isr_tables->isr_table),\r\nirqstatus);\r\nfor (i = 0; i < 4; ++i) {\r\nif (vcstatus[i] == 0)\r\ncontinue;\r\ndsi_call_isrs(isr_tables->isr_table_vc[i],\r\nARRAY_SIZE(isr_tables->isr_table_vc[i]),\r\nvcstatus[i]);\r\n}\r\nif (ciostatus != 0)\r\ndsi_call_isrs(isr_tables->isr_table_cio,\r\nARRAY_SIZE(isr_tables->isr_table_cio),\r\nciostatus);\r\n}\r\nstatic irqreturn_t omap_dsi_irq_handler(int irq, void *arg)\r\n{\r\nstruct platform_device *dsidev;\r\nstruct dsi_data *dsi;\r\nu32 irqstatus, vcstatus[4], ciostatus;\r\nint i;\r\ndsidev = (struct platform_device *) arg;\r\ndsi = dsi_get_dsidrv_data(dsidev);\r\nspin_lock(&dsi->irq_lock);\r\nirqstatus = dsi_read_reg(dsidev, DSI_IRQSTATUS);\r\nif (!irqstatus) {\r\nspin_unlock(&dsi->irq_lock);\r\nreturn IRQ_NONE;\r\n}\r\ndsi_write_reg(dsidev, DSI_IRQSTATUS, irqstatus & ~DSI_IRQ_CHANNEL_MASK);\r\ndsi_read_reg(dsidev, DSI_IRQSTATUS);\r\nfor (i = 0; i < 4; ++i) {\r\nif ((irqstatus & (1 << i)) == 0) {\r\nvcstatus[i] = 0;\r\ncontinue;\r\n}\r\nvcstatus[i] = dsi_read_reg(dsidev, DSI_VC_IRQSTATUS(i));\r\ndsi_write_reg(dsidev, DSI_VC_IRQSTATUS(i), vcstatus[i]);\r\ndsi_read_reg(dsidev, DSI_VC_IRQSTATUS(i));\r\n}\r\nif (irqstatus & DSI_IRQ_COMPLEXIO_ERR) {\r\nciostatus = dsi_read_reg(dsidev, DSI_COMPLEXIO_IRQ_STATUS);\r\ndsi_write_reg(dsidev, DSI_COMPLEXIO_IRQ_STATUS, ciostatus);\r\ndsi_read_reg(dsidev, DSI_COMPLEXIO_IRQ_STATUS);\r\n} else {\r\nciostatus = 0;\r\n}\r\n#ifdef DSI_CATCH_MISSING_TE\r\nif (irqstatus & DSI_IRQ_TE_TRIGGER)\r\ndel_timer(&dsi->te_timer);\r\n#endif\r\nmemcpy(&dsi->isr_tables_copy, &dsi->isr_tables,\r\nsizeof(dsi->isr_tables));\r\nspin_unlock(&dsi->irq_lock);\r\ndsi_handle_isrs(&dsi->isr_tables_copy, irqstatus, vcstatus, ciostatus);\r\ndsi_handle_irq_errors(dsidev, irqstatus, vcstatus, ciostatus);\r\ndsi_collect_irq_stats(dsidev, irqstatus, vcstatus, ciostatus);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void _omap_dsi_configure_irqs(struct platform_device *dsidev,\r\nstruct dsi_isr_data *isr_array,\r\nunsigned isr_array_size, u32 default_mask,\r\nconst struct dsi_reg enable_reg,\r\nconst struct dsi_reg status_reg)\r\n{\r\nstruct dsi_isr_data *isr_data;\r\nu32 mask;\r\nu32 old_mask;\r\nint i;\r\nmask = default_mask;\r\nfor (i = 0; i < isr_array_size; i++) {\r\nisr_data = &isr_array[i];\r\nif (isr_data->isr == NULL)\r\ncontinue;\r\nmask |= isr_data->mask;\r\n}\r\nold_mask = dsi_read_reg(dsidev, enable_reg);\r\ndsi_write_reg(dsidev, status_reg, (mask ^ old_mask) & mask);\r\ndsi_write_reg(dsidev, enable_reg, mask);\r\ndsi_read_reg(dsidev, enable_reg);\r\ndsi_read_reg(dsidev, status_reg);\r\n}\r\nstatic void _omap_dsi_set_irqs(struct platform_device *dsidev)\r\n{\r\nstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\r\nu32 mask = DSI_IRQ_ERROR_MASK;\r\n#ifdef DSI_CATCH_MISSING_TE\r\nmask |= DSI_IRQ_TE_TRIGGER;\r\n#endif\r\n_omap_dsi_configure_irqs(dsidev, dsi->isr_tables.isr_table,\r\nARRAY_SIZE(dsi->isr_tables.isr_table), mask,\r\nDSI_IRQENABLE, DSI_IRQSTATUS);\r\n}\r\nstatic void _omap_dsi_set_irqs_vc(struct platform_device *dsidev, int vc)\r\n{\r\nstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\r\n_omap_dsi_configure_irqs(dsidev, dsi->isr_tables.isr_table_vc[vc],\r\nARRAY_SIZE(dsi->isr_tables.isr_table_vc[vc]),\r\nDSI_VC_IRQ_ERROR_MASK,\r\nDSI_VC_IRQENABLE(vc), DSI_VC_IRQSTATUS(vc));\r\n}\r\nstatic void _omap_dsi_set_irqs_cio(struct platform_device *dsidev)\r\n{\r\nstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\r\n_omap_dsi_configure_irqs(dsidev, dsi->isr_tables.isr_table_cio,\r\nARRAY_SIZE(dsi->isr_tables.isr_table_cio),\r\nDSI_CIO_IRQ_ERROR_MASK,\r\nDSI_COMPLEXIO_IRQ_ENABLE, DSI_COMPLEXIO_IRQ_STATUS);\r\n}\r\nstatic void _dsi_initialize_irq(struct platform_device *dsidev)\r\n{\r\nstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\r\nunsigned long flags;\r\nint vc;\r\nspin_lock_irqsave(&dsi->irq_lock, flags);\r\nmemset(&dsi->isr_tables, 0, sizeof(dsi->isr_tables));\r\n_omap_dsi_set_irqs(dsidev);\r\nfor (vc = 0; vc < 4; ++vc)\r\n_omap_dsi_set_irqs_vc(dsidev, vc);\r\n_omap_dsi_set_irqs_cio(dsidev);\r\nspin_unlock_irqrestore(&dsi->irq_lock, flags);\r\n}\r\nstatic int _dsi_register_isr(omap_dsi_isr_t isr, void *arg, u32 mask,\r\nstruct dsi_isr_data *isr_array, unsigned isr_array_size)\r\n{\r\nstruct dsi_isr_data *isr_data;\r\nint free_idx;\r\nint i;\r\nBUG_ON(isr == NULL);\r\nfree_idx = -1;\r\nfor (i = 0; i < isr_array_size; i++) {\r\nisr_data = &isr_array[i];\r\nif (isr_data->isr == isr && isr_data->arg == arg &&\r\nisr_data->mask == mask) {\r\nreturn -EINVAL;\r\n}\r\nif (isr_data->isr == NULL && free_idx == -1)\r\nfree_idx = i;\r\n}\r\nif (free_idx == -1)\r\nreturn -EBUSY;\r\nisr_data = &isr_array[free_idx];\r\nisr_data->isr = isr;\r\nisr_data->arg = arg;\r\nisr_data->mask = mask;\r\nreturn 0;\r\n}\r\nstatic int _dsi_unregister_isr(omap_dsi_isr_t isr, void *arg, u32 mask,\r\nstruct dsi_isr_data *isr_array, unsigned isr_array_size)\r\n{\r\nstruct dsi_isr_data *isr_data;\r\nint i;\r\nfor (i = 0; i < isr_array_size; i++) {\r\nisr_data = &isr_array[i];\r\nif (isr_data->isr != isr || isr_data->arg != arg ||\r\nisr_data->mask != mask)\r\ncontinue;\r\nisr_data->isr = NULL;\r\nisr_data->arg = NULL;\r\nisr_data->mask = 0;\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int dsi_register_isr(struct platform_device *dsidev, omap_dsi_isr_t isr,\r\nvoid *arg, u32 mask)\r\n{\r\nstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\r\nunsigned long flags;\r\nint r;\r\nspin_lock_irqsave(&dsi->irq_lock, flags);\r\nr = _dsi_register_isr(isr, arg, mask, dsi->isr_tables.isr_table,\r\nARRAY_SIZE(dsi->isr_tables.isr_table));\r\nif (r == 0)\r\n_omap_dsi_set_irqs(dsidev);\r\nspin_unlock_irqrestore(&dsi->irq_lock, flags);\r\nreturn r;\r\n}\r\nstatic int dsi_unregister_isr(struct platform_device *dsidev,\r\nomap_dsi_isr_t isr, void *arg, u32 mask)\r\n{\r\nstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\r\nunsigned long flags;\r\nint r;\r\nspin_lock_irqsave(&dsi->irq_lock, flags);\r\nr = _dsi_unregister_isr(isr, arg, mask, dsi->isr_tables.isr_table,\r\nARRAY_SIZE(dsi->isr_tables.isr_table));\r\nif (r == 0)\r\n_omap_dsi_set_irqs(dsidev);\r\nspin_unlock_irqrestore(&dsi->irq_lock, flags);\r\nreturn r;\r\n}\r\nstatic int dsi_register_isr_vc(struct platform_device *dsidev, int channel,\r\nomap_dsi_isr_t isr, void *arg, u32 mask)\r\n{\r\nstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\r\nunsigned long flags;\r\nint r;\r\nspin_lock_irqsave(&dsi->irq_lock, flags);\r\nr = _dsi_register_isr(isr, arg, mask,\r\ndsi->isr_tables.isr_table_vc[channel],\r\nARRAY_SIZE(dsi->isr_tables.isr_table_vc[channel]));\r\nif (r == 0)\r\n_omap_dsi_set_irqs_vc(dsidev, channel);\r\nspin_unlock_irqrestore(&dsi->irq_lock, flags);\r\nreturn r;\r\n}\r\nstatic int dsi_unregister_isr_vc(struct platform_device *dsidev, int channel,\r\nomap_dsi_isr_t isr, void *arg, u32 mask)\r\n{\r\nstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\r\nunsigned long flags;\r\nint r;\r\nspin_lock_irqsave(&dsi->irq_lock, flags);\r\nr = _dsi_unregister_isr(isr, arg, mask,\r\ndsi->isr_tables.isr_table_vc[channel],\r\nARRAY_SIZE(dsi->isr_tables.isr_table_vc[channel]));\r\nif (r == 0)\r\n_omap_dsi_set_irqs_vc(dsidev, channel);\r\nspin_unlock_irqrestore(&dsi->irq_lock, flags);\r\nreturn r;\r\n}\r\nstatic int dsi_register_isr_cio(struct platform_device *dsidev,\r\nomap_dsi_isr_t isr, void *arg, u32 mask)\r\n{\r\nstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\r\nunsigned long flags;\r\nint r;\r\nspin_lock_irqsave(&dsi->irq_lock, flags);\r\nr = _dsi_register_isr(isr, arg, mask, dsi->isr_tables.isr_table_cio,\r\nARRAY_SIZE(dsi->isr_tables.isr_table_cio));\r\nif (r == 0)\r\n_omap_dsi_set_irqs_cio(dsidev);\r\nspin_unlock_irqrestore(&dsi->irq_lock, flags);\r\nreturn r;\r\n}\r\nstatic int dsi_unregister_isr_cio(struct platform_device *dsidev,\r\nomap_dsi_isr_t isr, void *arg, u32 mask)\r\n{\r\nstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\r\nunsigned long flags;\r\nint r;\r\nspin_lock_irqsave(&dsi->irq_lock, flags);\r\nr = _dsi_unregister_isr(isr, arg, mask, dsi->isr_tables.isr_table_cio,\r\nARRAY_SIZE(dsi->isr_tables.isr_table_cio));\r\nif (r == 0)\r\n_omap_dsi_set_irqs_cio(dsidev);\r\nspin_unlock_irqrestore(&dsi->irq_lock, flags);\r\nreturn r;\r\n}\r\nstatic u32 dsi_get_errors(struct platform_device *dsidev)\r\n{\r\nstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\r\nunsigned long flags;\r\nu32 e;\r\nspin_lock_irqsave(&dsi->errors_lock, flags);\r\ne = dsi->errors;\r\ndsi->errors = 0;\r\nspin_unlock_irqrestore(&dsi->errors_lock, flags);\r\nreturn e;\r\n}\r\nint dsi_runtime_get(struct platform_device *dsidev)\r\n{\r\nint r;\r\nstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\r\nDSSDBG("dsi_runtime_get\n");\r\nr = pm_runtime_get_sync(&dsi->pdev->dev);\r\nWARN_ON(r < 0);\r\nreturn r < 0 ? r : 0;\r\n}\r\nvoid dsi_runtime_put(struct platform_device *dsidev)\r\n{\r\nstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\r\nint r;\r\nDSSDBG("dsi_runtime_put\n");\r\nr = pm_runtime_put_sync(&dsi->pdev->dev);\r\nWARN_ON(r < 0 && r != -ENOSYS);\r\n}\r\nstatic inline void dsi_enable_pll_clock(struct platform_device *dsidev,\r\nbool enable)\r\n{\r\nstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\r\nif (enable)\r\nclk_prepare_enable(dsi->sys_clk);\r\nelse\r\nclk_disable_unprepare(dsi->sys_clk);\r\nif (enable && dsi->pll_locked) {\r\nif (wait_for_bit_change(dsidev, DSI_PLL_STATUS, 1, 1) != 1)\r\nDSSERR("cannot lock PLL when enabling clocks\n");\r\n}\r\n}\r\nstatic void _dsi_print_reset_status(struct platform_device *dsidev)\r\n{\r\nu32 l;\r\nint b0, b1, b2;\r\nl = dsi_read_reg(dsidev, DSI_DSIPHY_CFG5);\r\nif (dss_has_feature(FEAT_DSI_REVERSE_TXCLKESC)) {\r\nb0 = 28;\r\nb1 = 27;\r\nb2 = 26;\r\n} else {\r\nb0 = 24;\r\nb1 = 25;\r\nb2 = 26;\r\n}\r\n#define DSI_FLD_GET(fld, start, end)\\r\nFLD_GET(dsi_read_reg(dsidev, DSI_##fld), start, end)\r\npr_debug("DSI resets: PLL (%d) CIO (%d) PHY (%x%x%x, %d, %d, %d)\n",\r\nDSI_FLD_GET(PLL_STATUS, 0, 0),\r\nDSI_FLD_GET(COMPLEXIO_CFG1, 29, 29),\r\nDSI_FLD_GET(DSIPHY_CFG5, b0, b0),\r\nDSI_FLD_GET(DSIPHY_CFG5, b1, b1),\r\nDSI_FLD_GET(DSIPHY_CFG5, b2, b2),\r\nDSI_FLD_GET(DSIPHY_CFG5, 29, 29),\r\nDSI_FLD_GET(DSIPHY_CFG5, 30, 30),\r\nDSI_FLD_GET(DSIPHY_CFG5, 31, 31));\r\n#undef DSI_FLD_GET\r\n}\r\nstatic inline int dsi_if_enable(struct platform_device *dsidev, bool enable)\r\n{\r\nDSSDBG("dsi_if_enable(%d)\n", enable);\r\nenable = enable ? 1 : 0;\r\nREG_FLD_MOD(dsidev, DSI_CTRL, enable, 0, 0);\r\nif (wait_for_bit_change(dsidev, DSI_CTRL, 0, enable) != enable) {\r\nDSSERR("Failed to set dsi_if_enable to %d\n", enable);\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nunsigned long dsi_get_pll_hsdiv_dispc_rate(struct platform_device *dsidev)\r\n{\r\nstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\r\nreturn dsi->current_cinfo.dsi_pll_hsdiv_dispc_clk;\r\n}\r\nstatic unsigned long dsi_get_pll_hsdiv_dsi_rate(struct platform_device *dsidev)\r\n{\r\nstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\r\nreturn dsi->current_cinfo.dsi_pll_hsdiv_dsi_clk;\r\n}\r\nstatic unsigned long dsi_get_txbyteclkhs(struct platform_device *dsidev)\r\n{\r\nstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\r\nreturn dsi->current_cinfo.clkin4ddr / 16;\r\n}\r\nstatic unsigned long dsi_fclk_rate(struct platform_device *dsidev)\r\n{\r\nunsigned long r;\r\nstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\r\nif (dss_get_dsi_clk_source(dsi->module_id) == OMAP_DSS_CLK_SRC_FCK) {\r\nr = clk_get_rate(dsi->dss_clk);\r\n} else {\r\nr = dsi_get_pll_hsdiv_dsi_rate(dsidev);\r\n}\r\nreturn r;\r\n}\r\nstatic int dsi_set_lp_clk_divisor(struct omap_dss_device *dssdev)\r\n{\r\nstruct platform_device *dsidev = dsi_get_dsidev_from_dssdev(dssdev);\r\nstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\r\nunsigned long dsi_fclk;\r\nunsigned lp_clk_div;\r\nunsigned long lp_clk;\r\nlp_clk_div = dssdev->clocks.dsi.lp_clk_div;\r\nif (lp_clk_div == 0 || lp_clk_div > dsi->lpdiv_max)\r\nreturn -EINVAL;\r\ndsi_fclk = dsi_fclk_rate(dsidev);\r\nlp_clk = dsi_fclk / 2 / lp_clk_div;\r\nDSSDBG("LP_CLK_DIV %u, LP_CLK %lu\n", lp_clk_div, lp_clk);\r\ndsi->current_cinfo.lp_clk = lp_clk;\r\ndsi->current_cinfo.lp_clk_div = lp_clk_div;\r\nREG_FLD_MOD(dsidev, DSI_CLK_CTRL, lp_clk_div, 12, 0);\r\nREG_FLD_MOD(dsidev, DSI_CLK_CTRL, dsi_fclk > 30000000 ? 1 : 0, 21, 21);\r\nreturn 0;\r\n}\r\nstatic void dsi_enable_scp_clk(struct platform_device *dsidev)\r\n{\r\nstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\r\nif (dsi->scp_clk_refcount++ == 0)\r\nREG_FLD_MOD(dsidev, DSI_CLK_CTRL, 1, 14, 14);\r\n}\r\nstatic void dsi_disable_scp_clk(struct platform_device *dsidev)\r\n{\r\nstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\r\nWARN_ON(dsi->scp_clk_refcount == 0);\r\nif (--dsi->scp_clk_refcount == 0)\r\nREG_FLD_MOD(dsidev, DSI_CLK_CTRL, 0, 14, 14);\r\n}\r\nstatic int dsi_pll_power(struct platform_device *dsidev,\r\nenum dsi_pll_power_state state)\r\n{\r\nint t = 0;\r\nif (dss_has_feature(FEAT_DSI_PLL_PWR_BUG) &&\r\nstate == DSI_PLL_POWER_ON_DIV)\r\nstate = DSI_PLL_POWER_ON_ALL;\r\nREG_FLD_MOD(dsidev, DSI_CLK_CTRL, state, 31, 30);\r\nwhile (FLD_GET(dsi_read_reg(dsidev, DSI_CLK_CTRL), 29, 28) != state) {\r\nif (++t > 1000) {\r\nDSSERR("Failed to set DSI PLL power mode to %d\n",\r\nstate);\r\nreturn -ENODEV;\r\n}\r\nudelay(1);\r\n}\r\nreturn 0;\r\n}\r\nstatic int dsi_calc_clock_rates(struct platform_device *dsidev,\r\nstruct dsi_clock_info *cinfo)\r\n{\r\nstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\r\nif (cinfo->regn == 0 || cinfo->regn > dsi->regn_max)\r\nreturn -EINVAL;\r\nif (cinfo->regm == 0 || cinfo->regm > dsi->regm_max)\r\nreturn -EINVAL;\r\nif (cinfo->regm_dispc > dsi->regm_dispc_max)\r\nreturn -EINVAL;\r\nif (cinfo->regm_dsi > dsi->regm_dsi_max)\r\nreturn -EINVAL;\r\ncinfo->clkin = clk_get_rate(dsi->sys_clk);\r\ncinfo->fint = cinfo->clkin / cinfo->regn;\r\nif (cinfo->fint > dsi->fint_max || cinfo->fint < dsi->fint_min)\r\nreturn -EINVAL;\r\ncinfo->clkin4ddr = 2 * cinfo->regm * cinfo->fint;\r\nif (cinfo->clkin4ddr > 1800 * 1000 * 1000)\r\nreturn -EINVAL;\r\nif (cinfo->regm_dispc > 0)\r\ncinfo->dsi_pll_hsdiv_dispc_clk =\r\ncinfo->clkin4ddr / cinfo->regm_dispc;\r\nelse\r\ncinfo->dsi_pll_hsdiv_dispc_clk = 0;\r\nif (cinfo->regm_dsi > 0)\r\ncinfo->dsi_pll_hsdiv_dsi_clk =\r\ncinfo->clkin4ddr / cinfo->regm_dsi;\r\nelse\r\ncinfo->dsi_pll_hsdiv_dsi_clk = 0;\r\nreturn 0;\r\n}\r\nint dsi_pll_calc_clock_div_pck(struct platform_device *dsidev,\r\nunsigned long req_pck, struct dsi_clock_info *dsi_cinfo,\r\nstruct dispc_clock_info *dispc_cinfo)\r\n{\r\nstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\r\nstruct dsi_clock_info cur, best;\r\nstruct dispc_clock_info best_dispc;\r\nint min_fck_per_pck;\r\nint match = 0;\r\nunsigned long dss_sys_clk, max_dss_fck;\r\ndss_sys_clk = clk_get_rate(dsi->sys_clk);\r\nmax_dss_fck = dss_feat_get_param_max(FEAT_PARAM_DSS_FCK);\r\nif (req_pck == dsi->cache_req_pck &&\r\ndsi->cache_cinfo.clkin == dss_sys_clk) {\r\nDSSDBG("DSI clock info found from cache\n");\r\n*dsi_cinfo = dsi->cache_cinfo;\r\ndispc_find_clk_divs(req_pck, dsi_cinfo->dsi_pll_hsdiv_dispc_clk,\r\ndispc_cinfo);\r\nreturn 0;\r\n}\r\nmin_fck_per_pck = CONFIG_OMAP2_DSS_MIN_FCK_PER_PCK;\r\nif (min_fck_per_pck &&\r\nreq_pck * min_fck_per_pck > max_dss_fck) {\r\nDSSERR("Requested pixel clock not possible with the current "\r\n"OMAP2_DSS_MIN_FCK_PER_PCK setting. Turning "\r\n"the constraint off.\n");\r\nmin_fck_per_pck = 0;\r\n}\r\nDSSDBG("dsi_pll_calc\n");\r\nretry:\r\nmemset(&best, 0, sizeof(best));\r\nmemset(&best_dispc, 0, sizeof(best_dispc));\r\nmemset(&cur, 0, sizeof(cur));\r\ncur.clkin = dss_sys_clk;\r\nfor (cur.regn = 1; cur.regn < dsi->regn_max; ++cur.regn) {\r\ncur.fint = cur.clkin / cur.regn;\r\nif (cur.fint > dsi->fint_max || cur.fint < dsi->fint_min)\r\ncontinue;\r\nfor (cur.regm = 1; cur.regm < dsi->regm_max; ++cur.regm) {\r\nunsigned long a, b;\r\na = 2 * cur.regm * (cur.clkin/1000);\r\nb = cur.regn;\r\ncur.clkin4ddr = a / b * 1000;\r\nif (cur.clkin4ddr > 1800 * 1000 * 1000)\r\nbreak;\r\nfor (cur.regm_dispc = 1; cur.regm_dispc <\r\ndsi->regm_dispc_max; ++cur.regm_dispc) {\r\nstruct dispc_clock_info cur_dispc;\r\ncur.dsi_pll_hsdiv_dispc_clk =\r\ncur.clkin4ddr / cur.regm_dispc;\r\nif (cur.regm_dispc > 1 &&\r\ncur.regm_dispc % 2 != 0 &&\r\nreq_pck >= 1000000)\r\ncontinue;\r\nif (cur.dsi_pll_hsdiv_dispc_clk < req_pck)\r\nbreak;\r\nif (cur.dsi_pll_hsdiv_dispc_clk > max_dss_fck)\r\ncontinue;\r\nif (min_fck_per_pck &&\r\ncur.dsi_pll_hsdiv_dispc_clk <\r\nreq_pck * min_fck_per_pck)\r\ncontinue;\r\nmatch = 1;\r\ndispc_find_clk_divs(req_pck,\r\ncur.dsi_pll_hsdiv_dispc_clk,\r\n&cur_dispc);\r\nif (abs(cur_dispc.pck - req_pck) <\r\nabs(best_dispc.pck - req_pck)) {\r\nbest = cur;\r\nbest_dispc = cur_dispc;\r\nif (cur_dispc.pck == req_pck)\r\ngoto found;\r\n}\r\n}\r\n}\r\n}\r\nfound:\r\nif (!match) {\r\nif (min_fck_per_pck) {\r\nDSSERR("Could not find suitable clock settings.\n"\r\n"Turning FCK/PCK constraint off and"\r\n"trying again.\n");\r\nmin_fck_per_pck = 0;\r\ngoto retry;\r\n}\r\nDSSERR("Could not find suitable clock settings.\n");\r\nreturn -EINVAL;\r\n}\r\nbest.regm_dsi = 0;\r\nbest.dsi_pll_hsdiv_dsi_clk = 0;\r\nif (dsi_cinfo)\r\n*dsi_cinfo = best;\r\nif (dispc_cinfo)\r\n*dispc_cinfo = best_dispc;\r\ndsi->cache_req_pck = req_pck;\r\ndsi->cache_clk_freq = 0;\r\ndsi->cache_cinfo = best;\r\nreturn 0;\r\n}\r\nstatic int dsi_pll_calc_ddrfreq(struct platform_device *dsidev,\r\nunsigned long req_clkin4ddr, struct dsi_clock_info *cinfo)\r\n{\r\nstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\r\nstruct dsi_clock_info cur, best;\r\nDSSDBG("dsi_pll_calc_ddrfreq\n");\r\nmemset(&best, 0, sizeof(best));\r\nmemset(&cur, 0, sizeof(cur));\r\ncur.clkin = clk_get_rate(dsi->sys_clk);\r\nfor (cur.regn = 1; cur.regn < dsi->regn_max; ++cur.regn) {\r\ncur.fint = cur.clkin / cur.regn;\r\nif (cur.fint > dsi->fint_max || cur.fint < dsi->fint_min)\r\ncontinue;\r\nfor (cur.regm = 1; cur.regm < dsi->regm_max; ++cur.regm) {\r\nunsigned long a, b;\r\na = 2 * cur.regm * (cur.clkin/1000);\r\nb = cur.regn;\r\ncur.clkin4ddr = a / b * 1000;\r\nif (cur.clkin4ddr > 1800 * 1000 * 1000)\r\nbreak;\r\nif (abs(cur.clkin4ddr - req_clkin4ddr) <\r\nabs(best.clkin4ddr - req_clkin4ddr)) {\r\nbest = cur;\r\nDSSDBG("best %ld\n", best.clkin4ddr);\r\n}\r\nif (cur.clkin4ddr == req_clkin4ddr)\r\ngoto found;\r\n}\r\n}\r\nfound:\r\nif (cinfo)\r\n*cinfo = best;\r\nreturn 0;\r\n}\r\nstatic void dsi_pll_calc_dsi_fck(struct platform_device *dsidev,\r\nstruct dsi_clock_info *cinfo)\r\n{\r\nunsigned long max_dsi_fck;\r\nmax_dsi_fck = dss_feat_get_param_max(FEAT_PARAM_DSI_FCK);\r\ncinfo->regm_dsi = DIV_ROUND_UP(cinfo->clkin4ddr, max_dsi_fck);\r\ncinfo->dsi_pll_hsdiv_dsi_clk = cinfo->clkin4ddr / cinfo->regm_dsi;\r\n}\r\nstatic int dsi_pll_calc_dispc_fck(struct platform_device *dsidev,\r\nunsigned long req_pck, struct dsi_clock_info *cinfo,\r\nstruct dispc_clock_info *dispc_cinfo)\r\n{\r\nstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\r\nunsigned regm_dispc, best_regm_dispc;\r\nunsigned long dispc_clk, best_dispc_clk;\r\nint min_fck_per_pck;\r\nunsigned long max_dss_fck;\r\nstruct dispc_clock_info best_dispc;\r\nbool match;\r\nmax_dss_fck = dss_feat_get_param_max(FEAT_PARAM_DSS_FCK);\r\nmin_fck_per_pck = CONFIG_OMAP2_DSS_MIN_FCK_PER_PCK;\r\nif (min_fck_per_pck &&\r\nreq_pck * min_fck_per_pck > max_dss_fck) {\r\nDSSERR("Requested pixel clock not possible with the current "\r\n"OMAP2_DSS_MIN_FCK_PER_PCK setting. Turning "\r\n"the constraint off.\n");\r\nmin_fck_per_pck = 0;\r\n}\r\nretry:\r\nbest_regm_dispc = 0;\r\nbest_dispc_clk = 0;\r\nmemset(&best_dispc, 0, sizeof(best_dispc));\r\nmatch = false;\r\nfor (regm_dispc = 1; regm_dispc < dsi->regm_dispc_max; ++regm_dispc) {\r\nstruct dispc_clock_info cur_dispc;\r\ndispc_clk = cinfo->clkin4ddr / regm_dispc;\r\nif (dispc_clk < req_pck)\r\nbreak;\r\nif (dispc_clk > max_dss_fck)\r\ncontinue;\r\nif (min_fck_per_pck && dispc_clk < req_pck * min_fck_per_pck)\r\ncontinue;\r\nmatch = true;\r\ndispc_find_clk_divs(req_pck, dispc_clk, &cur_dispc);\r\nif (abs(cur_dispc.pck - req_pck) <\r\nabs(best_dispc.pck - req_pck)) {\r\nbest_regm_dispc = regm_dispc;\r\nbest_dispc_clk = dispc_clk;\r\nbest_dispc = cur_dispc;\r\nif (cur_dispc.pck == req_pck)\r\ngoto found;\r\n}\r\n}\r\nif (!match) {\r\nif (min_fck_per_pck) {\r\nDSSERR("Could not find suitable clock settings.\n"\r\n"Turning FCK/PCK constraint off and"\r\n"trying again.\n");\r\nmin_fck_per_pck = 0;\r\ngoto retry;\r\n}\r\nDSSERR("Could not find suitable clock settings.\n");\r\nreturn -EINVAL;\r\n}\r\nfound:\r\ncinfo->regm_dispc = best_regm_dispc;\r\ncinfo->dsi_pll_hsdiv_dispc_clk = best_dispc_clk;\r\n*dispc_cinfo = best_dispc;\r\nreturn 0;\r\n}\r\nint dsi_pll_set_clock_div(struct platform_device *dsidev,\r\nstruct dsi_clock_info *cinfo)\r\n{\r\nstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\r\nint r = 0;\r\nu32 l;\r\nint f = 0;\r\nu8 regn_start, regn_end, regm_start, regm_end;\r\nu8 regm_dispc_start, regm_dispc_end, regm_dsi_start, regm_dsi_end;\r\nDSSDBG("DSI PLL clock config starts");\r\ndsi->current_cinfo.clkin = cinfo->clkin;\r\ndsi->current_cinfo.fint = cinfo->fint;\r\ndsi->current_cinfo.clkin4ddr = cinfo->clkin4ddr;\r\ndsi->current_cinfo.dsi_pll_hsdiv_dispc_clk =\r\ncinfo->dsi_pll_hsdiv_dispc_clk;\r\ndsi->current_cinfo.dsi_pll_hsdiv_dsi_clk =\r\ncinfo->dsi_pll_hsdiv_dsi_clk;\r\ndsi->current_cinfo.regn = cinfo->regn;\r\ndsi->current_cinfo.regm = cinfo->regm;\r\ndsi->current_cinfo.regm_dispc = cinfo->regm_dispc;\r\ndsi->current_cinfo.regm_dsi = cinfo->regm_dsi;\r\nDSSDBG("DSI Fint %ld\n", cinfo->fint);\r\nDSSDBG("clkin rate %ld\n", cinfo->clkin);\r\nDSSDBG("CLKIN4DDR = 2 * %d / %d * %lu = %lu\n",\r\ncinfo->regm,\r\ncinfo->regn,\r\ncinfo->clkin,\r\ncinfo->clkin4ddr);\r\nDSSDBG("Data rate on 1 DSI lane %ld Mbps\n",\r\ncinfo->clkin4ddr / 1000 / 1000 / 2);\r\nDSSDBG("Clock lane freq %ld Hz\n", cinfo->clkin4ddr / 4);\r\nDSSDBG("regm_dispc = %d, %s (%s) = %lu\n", cinfo->regm_dispc,\r\ndss_get_generic_clk_source_name(OMAP_DSS_CLK_SRC_DSI_PLL_HSDIV_DISPC),\r\ndss_feat_get_clk_source_name(OMAP_DSS_CLK_SRC_DSI_PLL_HSDIV_DISPC),\r\ncinfo->dsi_pll_hsdiv_dispc_clk);\r\nDSSDBG("regm_dsi = %d, %s (%s) = %lu\n", cinfo->regm_dsi,\r\ndss_get_generic_clk_source_name(OMAP_DSS_CLK_SRC_DSI_PLL_HSDIV_DSI),\r\ndss_feat_get_clk_source_name(OMAP_DSS_CLK_SRC_DSI_PLL_HSDIV_DSI),\r\ncinfo->dsi_pll_hsdiv_dsi_clk);\r\ndss_feat_get_reg_field(FEAT_REG_DSIPLL_REGN, &regn_start, &regn_end);\r\ndss_feat_get_reg_field(FEAT_REG_DSIPLL_REGM, &regm_start, &regm_end);\r\ndss_feat_get_reg_field(FEAT_REG_DSIPLL_REGM_DISPC, &regm_dispc_start,\r\n&regm_dispc_end);\r\ndss_feat_get_reg_field(FEAT_REG_DSIPLL_REGM_DSI, &regm_dsi_start,\r\n&regm_dsi_end);\r\nREG_FLD_MOD(dsidev, DSI_PLL_CONTROL, 0, 0, 0);\r\nl = dsi_read_reg(dsidev, DSI_PLL_CONFIGURATION1);\r\nl = FLD_MOD(l, 1, 0, 0);\r\nl = FLD_MOD(l, cinfo->regn - 1, regn_start, regn_end);\r\nl = FLD_MOD(l, cinfo->regm, regm_start, regm_end);\r\nl = FLD_MOD(l, cinfo->regm_dispc > 0 ? cinfo->regm_dispc - 1 : 0,\r\nregm_dispc_start, regm_dispc_end);\r\nl = FLD_MOD(l, cinfo->regm_dsi > 0 ? cinfo->regm_dsi - 1 : 0,\r\nregm_dsi_start, regm_dsi_end);\r\ndsi_write_reg(dsidev, DSI_PLL_CONFIGURATION1, l);\r\nBUG_ON(cinfo->fint < dsi->fint_min || cinfo->fint > dsi->fint_max);\r\nl = dsi_read_reg(dsidev, DSI_PLL_CONFIGURATION2);\r\nif (dss_has_feature(FEAT_DSI_PLL_FREQSEL)) {\r\nf = cinfo->fint < 1000000 ? 0x3 :\r\ncinfo->fint < 1250000 ? 0x4 :\r\ncinfo->fint < 1500000 ? 0x5 :\r\ncinfo->fint < 1750000 ? 0x6 :\r\n0x7;\r\nl = FLD_MOD(l, f, 4, 1);\r\n} else if (dss_has_feature(FEAT_DSI_PLL_SELFREQDCO)) {\r\nf = cinfo->clkin4ddr < 1000000000 ? 0x2 : 0x4;\r\nl = FLD_MOD(l, f, 4, 1);\r\n}\r\nl = FLD_MOD(l, 1, 13, 13);\r\nl = FLD_MOD(l, 0, 14, 14);\r\nl = FLD_MOD(l, 1, 20, 20);\r\nif (dss_has_feature(FEAT_DSI_PLL_REFSEL))\r\nl = FLD_MOD(l, 3, 22, 21);\r\ndsi_write_reg(dsidev, DSI_PLL_CONFIGURATION2, l);\r\nREG_FLD_MOD(dsidev, DSI_PLL_GO, 1, 0, 0);\r\nif (wait_for_bit_change(dsidev, DSI_PLL_GO, 0, 0) != 0) {\r\nDSSERR("dsi pll go bit not going down.\n");\r\nr = -EIO;\r\ngoto err;\r\n}\r\nif (wait_for_bit_change(dsidev, DSI_PLL_STATUS, 1, 1) != 1) {\r\nDSSERR("cannot lock PLL\n");\r\nr = -EIO;\r\ngoto err;\r\n}\r\ndsi->pll_locked = 1;\r\nl = dsi_read_reg(dsidev, DSI_PLL_CONFIGURATION2);\r\nl = FLD_MOD(l, 0, 0, 0);\r\nl = FLD_MOD(l, 0, 5, 5);\r\nl = FLD_MOD(l, 0, 6, 6);\r\nl = FLD_MOD(l, 0, 7, 7);\r\nl = FLD_MOD(l, 0, 8, 8);\r\nl = FLD_MOD(l, 0, 10, 9);\r\nl = FLD_MOD(l, 1, 13, 13);\r\nl = FLD_MOD(l, 1, 14, 14);\r\nl = FLD_MOD(l, 0, 15, 15);\r\nl = FLD_MOD(l, 1, 16, 16);\r\nl = FLD_MOD(l, 0, 17, 17);\r\nl = FLD_MOD(l, 1, 18, 18);\r\nl = FLD_MOD(l, 0, 19, 19);\r\nl = FLD_MOD(l, 0, 20, 20);\r\ndsi_write_reg(dsidev, DSI_PLL_CONFIGURATION2, l);\r\nDSSDBG("PLL config done\n");\r\nerr:\r\nreturn r;\r\n}\r\nint dsi_pll_init(struct platform_device *dsidev, bool enable_hsclk,\r\nbool enable_hsdiv)\r\n{\r\nstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\r\nint r = 0;\r\nenum dsi_pll_power_state pwstate;\r\nDSSDBG("PLL init\n");\r\nenable_hsclk = enable_hsdiv = true;\r\nif (dsi->vdds_dsi_reg == NULL) {\r\nstruct regulator *vdds_dsi;\r\nvdds_dsi = regulator_get(&dsi->pdev->dev, "vdds_dsi");\r\nif (IS_ERR(vdds_dsi))\r\nvdds_dsi = regulator_get(&dsi->pdev->dev, "VCXIO");\r\nif (IS_ERR(vdds_dsi)) {\r\nDSSERR("can't get VDDS_DSI regulator\n");\r\nreturn PTR_ERR(vdds_dsi);\r\n}\r\ndsi->vdds_dsi_reg = vdds_dsi;\r\n}\r\ndsi_enable_pll_clock(dsidev, 1);\r\ndsi_enable_scp_clk(dsidev);\r\nif (!dsi->vdds_dsi_enabled) {\r\nr = regulator_enable(dsi->vdds_dsi_reg);\r\nif (r)\r\ngoto err0;\r\ndsi->vdds_dsi_enabled = true;\r\n}\r\ndispc_pck_free_enable(1);\r\nif (wait_for_bit_change(dsidev, DSI_PLL_STATUS, 0, 1) != 1) {\r\nDSSERR("PLL not coming out of reset.\n");\r\nr = -ENODEV;\r\ndispc_pck_free_enable(0);\r\ngoto err1;\r\n}\r\ndispc_pck_free_enable(0);\r\nif (enable_hsclk && enable_hsdiv)\r\npwstate = DSI_PLL_POWER_ON_ALL;\r\nelse if (enable_hsclk)\r\npwstate = DSI_PLL_POWER_ON_HSCLK;\r\nelse if (enable_hsdiv)\r\npwstate = DSI_PLL_POWER_ON_DIV;\r\nelse\r\npwstate = DSI_PLL_POWER_OFF;\r\nr = dsi_pll_power(dsidev, pwstate);\r\nif (r)\r\ngoto err1;\r\nDSSDBG("PLL init done\n");\r\nreturn 0;\r\nerr1:\r\nif (dsi->vdds_dsi_enabled) {\r\nregulator_disable(dsi->vdds_dsi_reg);\r\ndsi->vdds_dsi_enabled = false;\r\n}\r\nerr0:\r\ndsi_disable_scp_clk(dsidev);\r\ndsi_enable_pll_clock(dsidev, 0);\r\nreturn r;\r\n}\r\nvoid dsi_pll_uninit(struct platform_device *dsidev, bool disconnect_lanes)\r\n{\r\nstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\r\ndsi->pll_locked = 0;\r\ndsi_pll_power(dsidev, DSI_PLL_POWER_OFF);\r\nif (disconnect_lanes) {\r\nWARN_ON(!dsi->vdds_dsi_enabled);\r\nregulator_disable(dsi->vdds_dsi_reg);\r\ndsi->vdds_dsi_enabled = false;\r\n}\r\ndsi_disable_scp_clk(dsidev);\r\ndsi_enable_pll_clock(dsidev, 0);\r\nDSSDBG("PLL uninit done\n");\r\n}\r\nstatic void dsi_dump_dsidev_clocks(struct platform_device *dsidev,\r\nstruct seq_file *s)\r\n{\r\nstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\r\nstruct dsi_clock_info *cinfo = &dsi->current_cinfo;\r\nenum omap_dss_clk_source dispc_clk_src, dsi_clk_src;\r\nint dsi_module = dsi->module_id;\r\ndispc_clk_src = dss_get_dispc_clk_source();\r\ndsi_clk_src = dss_get_dsi_clk_source(dsi_module);\r\nif (dsi_runtime_get(dsidev))\r\nreturn;\r\nseq_printf(s, "- DSI%d PLL -\n", dsi_module + 1);\r\nseq_printf(s, "dsi pll clkin\t%lu\n", cinfo->clkin);\r\nseq_printf(s, "Fint\t\t%-16luregn %u\n", cinfo->fint, cinfo->regn);\r\nseq_printf(s, "CLKIN4DDR\t%-16luregm %u\n",\r\ncinfo->clkin4ddr, cinfo->regm);\r\nseq_printf(s, "DSI_PLL_HSDIV_DISPC (%s)\t%-16luregm_dispc %u\t(%s)\n",\r\ndss_feat_get_clk_source_name(dsi_module == 0 ?\r\nOMAP_DSS_CLK_SRC_DSI_PLL_HSDIV_DISPC :\r\nOMAP_DSS_CLK_SRC_DSI2_PLL_HSDIV_DISPC),\r\ncinfo->dsi_pll_hsdiv_dispc_clk,\r\ncinfo->regm_dispc,\r\ndispc_clk_src == OMAP_DSS_CLK_SRC_FCK ?\r\n"off" : "on");\r\nseq_printf(s, "DSI_PLL_HSDIV_DSI (%s)\t%-16luregm_dsi %u\t(%s)\n",\r\ndss_feat_get_clk_source_name(dsi_module == 0 ?\r\nOMAP_DSS_CLK_SRC_DSI_PLL_HSDIV_DSI :\r\nOMAP_DSS_CLK_SRC_DSI2_PLL_HSDIV_DSI),\r\ncinfo->dsi_pll_hsdiv_dsi_clk,\r\ncinfo->regm_dsi,\r\ndsi_clk_src == OMAP_DSS_CLK_SRC_FCK ?\r\n"off" : "on");\r\nseq_printf(s, "- DSI%d -\n", dsi_module + 1);\r\nseq_printf(s, "dsi fclk source = %s (%s)\n",\r\ndss_get_generic_clk_source_name(dsi_clk_src),\r\ndss_feat_get_clk_source_name(dsi_clk_src));\r\nseq_printf(s, "DSI_FCLK\t%lu\n", dsi_fclk_rate(dsidev));\r\nseq_printf(s, "DDR_CLK\t\t%lu\n",\r\ncinfo->clkin4ddr / 4);\r\nseq_printf(s, "TxByteClkHS\t%lu\n", dsi_get_txbyteclkhs(dsidev));\r\nseq_printf(s, "LP_CLK\t\t%lu\n", cinfo->lp_clk);\r\ndsi_runtime_put(dsidev);\r\n}\r\nvoid dsi_dump_clocks(struct seq_file *s)\r\n{\r\nstruct platform_device *dsidev;\r\nint i;\r\nfor (i = 0; i < MAX_NUM_DSI; i++) {\r\ndsidev = dsi_get_dsidev_from_id(i);\r\nif (dsidev)\r\ndsi_dump_dsidev_clocks(dsidev, s);\r\n}\r\n}\r\nstatic void dsi_dump_dsidev_irqs(struct platform_device *dsidev,\r\nstruct seq_file *s)\r\n{\r\nstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\r\nunsigned long flags;\r\nstruct dsi_irq_stats stats;\r\nspin_lock_irqsave(&dsi->irq_stats_lock, flags);\r\nstats = dsi->irq_stats;\r\nmemset(&dsi->irq_stats, 0, sizeof(dsi->irq_stats));\r\ndsi->irq_stats.last_reset = jiffies;\r\nspin_unlock_irqrestore(&dsi->irq_stats_lock, flags);\r\nseq_printf(s, "period %u ms\n",\r\njiffies_to_msecs(jiffies - stats.last_reset));\r\nseq_printf(s, "irqs %d\n", stats.irq_count);\r\n#define PIS(x) \\r\nseq_printf(s, "%-20s %10d\n", #x, stats.dsi_irqs[ffs(DSI_IRQ_##x)-1]);\r\nseq_printf(s, "-- DSI%d interrupts --\n", dsi->module_id + 1);\r\nPIS(VC0);\r\nPIS(VC1);\r\nPIS(VC2);\r\nPIS(VC3);\r\nPIS(WAKEUP);\r\nPIS(RESYNC);\r\nPIS(PLL_LOCK);\r\nPIS(PLL_UNLOCK);\r\nPIS(PLL_RECALL);\r\nPIS(COMPLEXIO_ERR);\r\nPIS(HS_TX_TIMEOUT);\r\nPIS(LP_RX_TIMEOUT);\r\nPIS(TE_TRIGGER);\r\nPIS(ACK_TRIGGER);\r\nPIS(SYNC_LOST);\r\nPIS(LDO_POWER_GOOD);\r\nPIS(TA_TIMEOUT);\r\n#undef PIS\r\n#define PIS(x) \\r\nseq_printf(s, "%-20s %10d %10d %10d %10d\n", #x, \\r\nstats.vc_irqs[0][ffs(DSI_VC_IRQ_##x)-1], \\r\nstats.vc_irqs[1][ffs(DSI_VC_IRQ_##x)-1], \\r\nstats.vc_irqs[2][ffs(DSI_VC_IRQ_##x)-1], \\r\nstats.vc_irqs[3][ffs(DSI_VC_IRQ_##x)-1]);\r\nseq_printf(s, "-- VC interrupts --\n");\r\nPIS(CS);\r\nPIS(ECC_CORR);\r\nPIS(PACKET_SENT);\r\nPIS(FIFO_TX_OVF);\r\nPIS(FIFO_RX_OVF);\r\nPIS(BTA);\r\nPIS(ECC_NO_CORR);\r\nPIS(FIFO_TX_UDF);\r\nPIS(PP_BUSY_CHANGE);\r\n#undef PIS\r\n#define PIS(x) \\r\nseq_printf(s, "%-20s %10d\n", #x, \\r\nstats.cio_irqs[ffs(DSI_CIO_IRQ_##x)-1]);\r\nseq_printf(s, "-- CIO interrupts --\n");\r\nPIS(ERRSYNCESC1);\r\nPIS(ERRSYNCESC2);\r\nPIS(ERRSYNCESC3);\r\nPIS(ERRESC1);\r\nPIS(ERRESC2);\r\nPIS(ERRESC3);\r\nPIS(ERRCONTROL1);\r\nPIS(ERRCONTROL2);\r\nPIS(ERRCONTROL3);\r\nPIS(STATEULPS1);\r\nPIS(STATEULPS2);\r\nPIS(STATEULPS3);\r\nPIS(ERRCONTENTIONLP0_1);\r\nPIS(ERRCONTENTIONLP1_1);\r\nPIS(ERRCONTENTIONLP0_2);\r\nPIS(ERRCONTENTIONLP1_2);\r\nPIS(ERRCONTENTIONLP0_3);\r\nPIS(ERRCONTENTIONLP1_3);\r\nPIS(ULPSACTIVENOT_ALL0);\r\nPIS(ULPSACTIVENOT_ALL1);\r\n#undef PIS\r\n}\r\nstatic void dsi1_dump_irqs(struct seq_file *s)\r\n{\r\nstruct platform_device *dsidev = dsi_get_dsidev_from_id(0);\r\ndsi_dump_dsidev_irqs(dsidev, s);\r\n}\r\nstatic void dsi2_dump_irqs(struct seq_file *s)\r\n{\r\nstruct platform_device *dsidev = dsi_get_dsidev_from_id(1);\r\ndsi_dump_dsidev_irqs(dsidev, s);\r\n}\r\nstatic void dsi_dump_dsidev_regs(struct platform_device *dsidev,\r\nstruct seq_file *s)\r\n{\r\n#define DUMPREG(r) seq_printf(s, "%-35s %08x\n", #r, dsi_read_reg(dsidev, r))\r\nif (dsi_runtime_get(dsidev))\r\nreturn;\r\ndsi_enable_scp_clk(dsidev);\r\nDUMPREG(DSI_REVISION);\r\nDUMPREG(DSI_SYSCONFIG);\r\nDUMPREG(DSI_SYSSTATUS);\r\nDUMPREG(DSI_IRQSTATUS);\r\nDUMPREG(DSI_IRQENABLE);\r\nDUMPREG(DSI_CTRL);\r\nDUMPREG(DSI_COMPLEXIO_CFG1);\r\nDUMPREG(DSI_COMPLEXIO_IRQ_STATUS);\r\nDUMPREG(DSI_COMPLEXIO_IRQ_ENABLE);\r\nDUMPREG(DSI_CLK_CTRL);\r\nDUMPREG(DSI_TIMING1);\r\nDUMPREG(DSI_TIMING2);\r\nDUMPREG(DSI_VM_TIMING1);\r\nDUMPREG(DSI_VM_TIMING2);\r\nDUMPREG(DSI_VM_TIMING3);\r\nDUMPREG(DSI_CLK_TIMING);\r\nDUMPREG(DSI_TX_FIFO_VC_SIZE);\r\nDUMPREG(DSI_RX_FIFO_VC_SIZE);\r\nDUMPREG(DSI_COMPLEXIO_CFG2);\r\nDUMPREG(DSI_RX_FIFO_VC_FULLNESS);\r\nDUMPREG(DSI_VM_TIMING4);\r\nDUMPREG(DSI_TX_FIFO_VC_EMPTINESS);\r\nDUMPREG(DSI_VM_TIMING5);\r\nDUMPREG(DSI_VM_TIMING6);\r\nDUMPREG(DSI_VM_TIMING7);\r\nDUMPREG(DSI_STOPCLK_TIMING);\r\nDUMPREG(DSI_VC_CTRL(0));\r\nDUMPREG(DSI_VC_TE(0));\r\nDUMPREG(DSI_VC_LONG_PACKET_HEADER(0));\r\nDUMPREG(DSI_VC_LONG_PACKET_PAYLOAD(0));\r\nDUMPREG(DSI_VC_SHORT_PACKET_HEADER(0));\r\nDUMPREG(DSI_VC_IRQSTATUS(0));\r\nDUMPREG(DSI_VC_IRQENABLE(0));\r\nDUMPREG(DSI_VC_CTRL(1));\r\nDUMPREG(DSI_VC_TE(1));\r\nDUMPREG(DSI_VC_LONG_PACKET_HEADER(1));\r\nDUMPREG(DSI_VC_LONG_PACKET_PAYLOAD(1));\r\nDUMPREG(DSI_VC_SHORT_PACKET_HEADER(1));\r\nDUMPREG(DSI_VC_IRQSTATUS(1));\r\nDUMPREG(DSI_VC_IRQENABLE(1));\r\nDUMPREG(DSI_VC_CTRL(2));\r\nDUMPREG(DSI_VC_TE(2));\r\nDUMPREG(DSI_VC_LONG_PACKET_HEADER(2));\r\nDUMPREG(DSI_VC_LONG_PACKET_PAYLOAD(2));\r\nDUMPREG(DSI_VC_SHORT_PACKET_HEADER(2));\r\nDUMPREG(DSI_VC_IRQSTATUS(2));\r\nDUMPREG(DSI_VC_IRQENABLE(2));\r\nDUMPREG(DSI_VC_CTRL(3));\r\nDUMPREG(DSI_VC_TE(3));\r\nDUMPREG(DSI_VC_LONG_PACKET_HEADER(3));\r\nDUMPREG(DSI_VC_LONG_PACKET_PAYLOAD(3));\r\nDUMPREG(DSI_VC_SHORT_PACKET_HEADER(3));\r\nDUMPREG(DSI_VC_IRQSTATUS(3));\r\nDUMPREG(DSI_VC_IRQENABLE(3));\r\nDUMPREG(DSI_DSIPHY_CFG0);\r\nDUMPREG(DSI_DSIPHY_CFG1);\r\nDUMPREG(DSI_DSIPHY_CFG2);\r\nDUMPREG(DSI_DSIPHY_CFG5);\r\nDUMPREG(DSI_PLL_CONTROL);\r\nDUMPREG(DSI_PLL_STATUS);\r\nDUMPREG(DSI_PLL_GO);\r\nDUMPREG(DSI_PLL_CONFIGURATION1);\r\nDUMPREG(DSI_PLL_CONFIGURATION2);\r\ndsi_disable_scp_clk(dsidev);\r\ndsi_runtime_put(dsidev);\r\n#undef DUMPREG\r\n}\r\nstatic void dsi1_dump_regs(struct seq_file *s)\r\n{\r\nstruct platform_device *dsidev = dsi_get_dsidev_from_id(0);\r\ndsi_dump_dsidev_regs(dsidev, s);\r\n}\r\nstatic void dsi2_dump_regs(struct seq_file *s)\r\n{\r\nstruct platform_device *dsidev = dsi_get_dsidev_from_id(1);\r\ndsi_dump_dsidev_regs(dsidev, s);\r\n}\r\nstatic int dsi_cio_power(struct platform_device *dsidev,\r\nenum dsi_cio_power_state state)\r\n{\r\nint t = 0;\r\nREG_FLD_MOD(dsidev, DSI_COMPLEXIO_CFG1, state, 28, 27);\r\nwhile (FLD_GET(dsi_read_reg(dsidev, DSI_COMPLEXIO_CFG1),\r\n26, 25) != state) {\r\nif (++t > 1000) {\r\nDSSERR("failed to set complexio power state to "\r\n"%d\n", state);\r\nreturn -ENODEV;\r\n}\r\nudelay(1);\r\n}\r\nreturn 0;\r\n}\r\nstatic unsigned dsi_get_line_buf_size(struct platform_device *dsidev)\r\n{\r\nint val;\r\nif (!dss_has_feature(FEAT_DSI_GNQ))\r\nreturn 1023 * 3;\r\nval = REG_GET(dsidev, DSI_GNQ, 14, 12);\r\nswitch (val) {\r\ncase 1:\r\nreturn 512 * 3;\r\ncase 2:\r\nreturn 682 * 3;\r\ncase 3:\r\nreturn 853 * 3;\r\ncase 4:\r\nreturn 1024 * 3;\r\ncase 5:\r\nreturn 1194 * 3;\r\ncase 6:\r\nreturn 1365 * 3;\r\ncase 7:\r\nreturn 1920 * 3;\r\ndefault:\r\nBUG();\r\nreturn 0;\r\n}\r\n}\r\nstatic int dsi_set_lane_config(struct platform_device *dsidev)\r\n{\r\nstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\r\nstatic const u8 offsets[] = { 0, 4, 8, 12, 16 };\r\nstatic const enum dsi_lane_function functions[] = {\r\nDSI_LANE_CLK,\r\nDSI_LANE_DATA1,\r\nDSI_LANE_DATA2,\r\nDSI_LANE_DATA3,\r\nDSI_LANE_DATA4,\r\n};\r\nu32 r;\r\nint i;\r\nr = dsi_read_reg(dsidev, DSI_COMPLEXIO_CFG1);\r\nfor (i = 0; i < dsi->num_lanes_used; ++i) {\r\nunsigned offset = offsets[i];\r\nunsigned polarity, lane_number;\r\nunsigned t;\r\nfor (t = 0; t < dsi->num_lanes_supported; ++t)\r\nif (dsi->lanes[t].function == functions[i])\r\nbreak;\r\nif (t == dsi->num_lanes_supported)\r\nreturn -EINVAL;\r\nlane_number = t;\r\npolarity = dsi->lanes[t].polarity;\r\nr = FLD_MOD(r, lane_number + 1, offset + 2, offset);\r\nr = FLD_MOD(r, polarity, offset + 3, offset + 3);\r\n}\r\nfor (; i < dsi->num_lanes_supported; ++i) {\r\nunsigned offset = offsets[i];\r\nr = FLD_MOD(r, 0, offset + 2, offset);\r\nr = FLD_MOD(r, 0, offset + 3, offset + 3);\r\n}\r\ndsi_write_reg(dsidev, DSI_COMPLEXIO_CFG1, r);\r\nreturn 0;\r\n}\r\nstatic inline unsigned ns2ddr(struct platform_device *dsidev, unsigned ns)\r\n{\r\nstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\r\nunsigned long ddr_clk = dsi->current_cinfo.clkin4ddr / 4;\r\nreturn (ns * (ddr_clk / 1000 / 1000) + 999) / 1000;\r\n}\r\nstatic inline unsigned ddr2ns(struct platform_device *dsidev, unsigned ddr)\r\n{\r\nstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\r\nunsigned long ddr_clk = dsi->current_cinfo.clkin4ddr / 4;\r\nreturn ddr * 1000 * 1000 / (ddr_clk / 1000);\r\n}\r\nstatic void dsi_cio_timings(struct platform_device *dsidev)\r\n{\r\nu32 r;\r\nu32 ths_prepare, ths_prepare_ths_zero, ths_trail, ths_exit;\r\nu32 tlpx_half, tclk_trail, tclk_zero;\r\nu32 tclk_prepare;\r\nths_prepare = ns2ddr(dsidev, 70) + 2;\r\nths_prepare_ths_zero = ns2ddr(dsidev, 175) + 2;\r\nths_trail = ns2ddr(dsidev, 60) + 5;\r\nths_exit = ns2ddr(dsidev, 145);\r\ntlpx_half = ns2ddr(dsidev, 25);\r\ntclk_trail = ns2ddr(dsidev, 60) + 2;\r\ntclk_prepare = ns2ddr(dsidev, 65);\r\ntclk_zero = ns2ddr(dsidev, 260);\r\nDSSDBG("ths_prepare %u (%uns), ths_prepare_ths_zero %u (%uns)\n",\r\nths_prepare, ddr2ns(dsidev, ths_prepare),\r\nths_prepare_ths_zero, ddr2ns(dsidev, ths_prepare_ths_zero));\r\nDSSDBG("ths_trail %u (%uns), ths_exit %u (%uns)\n",\r\nths_trail, ddr2ns(dsidev, ths_trail),\r\nths_exit, ddr2ns(dsidev, ths_exit));\r\nDSSDBG("tlpx_half %u (%uns), tclk_trail %u (%uns), "\r\n"tclk_zero %u (%uns)\n",\r\ntlpx_half, ddr2ns(dsidev, tlpx_half),\r\ntclk_trail, ddr2ns(dsidev, tclk_trail),\r\ntclk_zero, ddr2ns(dsidev, tclk_zero));\r\nDSSDBG("tclk_prepare %u (%uns)\n",\r\ntclk_prepare, ddr2ns(dsidev, tclk_prepare));\r\nr = dsi_read_reg(dsidev, DSI_DSIPHY_CFG0);\r\nr = FLD_MOD(r, ths_prepare, 31, 24);\r\nr = FLD_MOD(r, ths_prepare_ths_zero, 23, 16);\r\nr = FLD_MOD(r, ths_trail, 15, 8);\r\nr = FLD_MOD(r, ths_exit, 7, 0);\r\ndsi_write_reg(dsidev, DSI_DSIPHY_CFG0, r);\r\nr = dsi_read_reg(dsidev, DSI_DSIPHY_CFG1);\r\nr = FLD_MOD(r, tlpx_half, 20, 16);\r\nr = FLD_MOD(r, tclk_trail, 15, 8);\r\nr = FLD_MOD(r, tclk_zero, 7, 0);\r\nif (dss_has_feature(FEAT_DSI_PHY_DCC)) {\r\nr = FLD_MOD(r, 0, 21, 21);\r\nr = FLD_MOD(r, 1, 22, 22);\r\nr = FLD_MOD(r, 1, 23, 23);\r\n}\r\ndsi_write_reg(dsidev, DSI_DSIPHY_CFG1, r);\r\nr = dsi_read_reg(dsidev, DSI_DSIPHY_CFG2);\r\nr = FLD_MOD(r, tclk_prepare, 7, 0);\r\ndsi_write_reg(dsidev, DSI_DSIPHY_CFG2, r);\r\n}\r\nstatic void dsi_cio_enable_lane_override(struct platform_device *dsidev,\r\nunsigned mask_p, unsigned mask_n)\r\n{\r\nstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\r\nint i;\r\nu32 l;\r\nu8 lptxscp_start = dsi->num_lanes_supported == 3 ? 22 : 26;\r\nl = 0;\r\nfor (i = 0; i < dsi->num_lanes_supported; ++i) {\r\nunsigned p = dsi->lanes[i].polarity;\r\nif (mask_p & (1 << i))\r\nl |= 1 << (i * 2 + (p ? 0 : 1));\r\nif (mask_n & (1 << i))\r\nl |= 1 << (i * 2 + (p ? 1 : 0));\r\n}\r\nREG_FLD_MOD(dsidev, DSI_DSIPHY_CFG10, l, lptxscp_start, 17);\r\nREG_FLD_MOD(dsidev, DSI_DSIPHY_CFG10, 1, 27, 27);\r\n}\r\nstatic void dsi_cio_disable_lane_override(struct platform_device *dsidev)\r\n{\r\nREG_FLD_MOD(dsidev, DSI_DSIPHY_CFG10, 0, 27, 27);\r\nREG_FLD_MOD(dsidev, DSI_DSIPHY_CFG10, 0, 22, 17);\r\n}\r\nstatic int dsi_cio_wait_tx_clk_esc_reset(struct platform_device *dsidev)\r\n{\r\nstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\r\nint t, i;\r\nbool in_use[DSI_MAX_NR_LANES];\r\nstatic const u8 offsets_old[] = { 28, 27, 26 };\r\nstatic const u8 offsets_new[] = { 24, 25, 26, 27, 28 };\r\nconst u8 *offsets;\r\nif (dss_has_feature(FEAT_DSI_REVERSE_TXCLKESC))\r\noffsets = offsets_old;\r\nelse\r\noffsets = offsets_new;\r\nfor (i = 0; i < dsi->num_lanes_supported; ++i)\r\nin_use[i] = dsi->lanes[i].function != DSI_LANE_UNUSED;\r\nt = 100000;\r\nwhile (true) {\r\nu32 l;\r\nint ok;\r\nl = dsi_read_reg(dsidev, DSI_DSIPHY_CFG5);\r\nok = 0;\r\nfor (i = 0; i < dsi->num_lanes_supported; ++i) {\r\nif (!in_use[i] || (l & (1 << offsets[i])))\r\nok++;\r\n}\r\nif (ok == dsi->num_lanes_supported)\r\nbreak;\r\nif (--t == 0) {\r\nfor (i = 0; i < dsi->num_lanes_supported; ++i) {\r\nif (!in_use[i] || (l & (1 << offsets[i])))\r\ncontinue;\r\nDSSERR("CIO TXCLKESC%d domain not coming " \\r\n"out of reset\n", i);\r\n}\r\nreturn -EIO;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic unsigned dsi_get_lane_mask(struct platform_device *dsidev)\r\n{\r\nstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\r\nunsigned mask = 0;\r\nint i;\r\nfor (i = 0; i < dsi->num_lanes_supported; ++i) {\r\nif (dsi->lanes[i].function != DSI_LANE_UNUSED)\r\nmask |= 1 << i;\r\n}\r\nreturn mask;\r\n}\r\nstatic int dsi_cio_init(struct platform_device *dsidev)\r\n{\r\nstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\r\nint r;\r\nu32 l;\r\nDSSDBG("DSI CIO init starts");\r\nr = dss_dsi_enable_pads(dsi->module_id, dsi_get_lane_mask(dsidev));\r\nif (r)\r\nreturn r;\r\ndsi_enable_scp_clk(dsidev);\r\ndsi_read_reg(dsidev, DSI_DSIPHY_CFG5);\r\nif (wait_for_bit_change(dsidev, DSI_DSIPHY_CFG5, 30, 1) != 1) {\r\nDSSERR("CIO SCP Clock domain not coming out of reset.\n");\r\nr = -EIO;\r\ngoto err_scp_clk_dom;\r\n}\r\nr = dsi_set_lane_config(dsidev);\r\nif (r)\r\ngoto err_scp_clk_dom;\r\nl = dsi_read_reg(dsidev, DSI_TIMING1);\r\nl = FLD_MOD(l, 1, 15, 15);\r\nl = FLD_MOD(l, 1, 14, 14);\r\nl = FLD_MOD(l, 1, 13, 13);\r\nl = FLD_MOD(l, 0x1fff, 12, 0);\r\ndsi_write_reg(dsidev, DSI_TIMING1, l);\r\nif (dsi->ulps_enabled) {\r\nunsigned mask_p;\r\nint i;\r\nDSSDBG("manual ulps exit\n");\r\nmask_p = 0;\r\nfor (i = 0; i < dsi->num_lanes_supported; ++i) {\r\nif (dsi->lanes[i].function == DSI_LANE_UNUSED)\r\ncontinue;\r\nmask_p |= 1 << i;\r\n}\r\ndsi_cio_enable_lane_override(dsidev, mask_p, 0);\r\n}\r\nr = dsi_cio_power(dsidev, DSI_COMPLEXIO_POWER_ON);\r\nif (r)\r\ngoto err_cio_pwr;\r\nif (wait_for_bit_change(dsidev, DSI_COMPLEXIO_CFG1, 29, 1) != 1) {\r\nDSSERR("CIO PWR clock domain not coming out of reset.\n");\r\nr = -ENODEV;\r\ngoto err_cio_pwr_dom;\r\n}\r\ndsi_if_enable(dsidev, true);\r\ndsi_if_enable(dsidev, false);\r\nREG_FLD_MOD(dsidev, DSI_CLK_CTRL, 1, 20, 20);\r\nr = dsi_cio_wait_tx_clk_esc_reset(dsidev);\r\nif (r)\r\ngoto err_tx_clk_esc_rst;\r\nif (dsi->ulps_enabled) {\r\nktime_t wait = ns_to_ktime(1000 * 1000);\r\nset_current_state(TASK_UNINTERRUPTIBLE);\r\nschedule_hrtimeout(&wait, HRTIMER_MODE_REL);\r\ndsi_cio_disable_lane_override(dsidev);\r\n}\r\nREG_FLD_MOD(dsidev, DSI_TIMING1, 0, 15, 15);\r\ndsi_cio_timings(dsidev);\r\nif (dsi->mode == OMAP_DSS_DSI_VIDEO_MODE) {\r\nREG_FLD_MOD(dsidev, DSI_CLK_CTRL,\r\ndsi->vm_timings.ddr_clk_always_on, 13, 13);\r\n}\r\ndsi->ulps_enabled = false;\r\nDSSDBG("CIO init done\n");\r\nreturn 0;\r\nerr_tx_clk_esc_rst:\r\nREG_FLD_MOD(dsidev, DSI_CLK_CTRL, 0, 20, 20);\r\nerr_cio_pwr_dom:\r\ndsi_cio_power(dsidev, DSI_COMPLEXIO_POWER_OFF);\r\nerr_cio_pwr:\r\nif (dsi->ulps_enabled)\r\ndsi_cio_disable_lane_override(dsidev);\r\nerr_scp_clk_dom:\r\ndsi_disable_scp_clk(dsidev);\r\ndss_dsi_disable_pads(dsi->module_id, dsi_get_lane_mask(dsidev));\r\nreturn r;\r\n}\r\nstatic void dsi_cio_uninit(struct platform_device *dsidev)\r\n{\r\nstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\r\nREG_FLD_MOD(dsidev, DSI_CLK_CTRL, 0, 13, 13);\r\ndsi_cio_power(dsidev, DSI_COMPLEXIO_POWER_OFF);\r\ndsi_disable_scp_clk(dsidev);\r\ndss_dsi_disable_pads(dsi->module_id, dsi_get_lane_mask(dsidev));\r\n}\r\nstatic void dsi_config_tx_fifo(struct platform_device *dsidev,\r\nenum fifo_size size1, enum fifo_size size2,\r\nenum fifo_size size3, enum fifo_size size4)\r\n{\r\nstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\r\nu32 r = 0;\r\nint add = 0;\r\nint i;\r\ndsi->vc[0].fifo_size = size1;\r\ndsi->vc[1].fifo_size = size2;\r\ndsi->vc[2].fifo_size = size3;\r\ndsi->vc[3].fifo_size = size4;\r\nfor (i = 0; i < 4; i++) {\r\nu8 v;\r\nint size = dsi->vc[i].fifo_size;\r\nif (add + size > 4) {\r\nDSSERR("Illegal FIFO configuration\n");\r\nBUG();\r\nreturn;\r\n}\r\nv = FLD_VAL(add, 2, 0) | FLD_VAL(size, 7, 4);\r\nr |= v << (8 * i);\r\nadd += size;\r\n}\r\ndsi_write_reg(dsidev, DSI_TX_FIFO_VC_SIZE, r);\r\n}\r\nstatic void dsi_config_rx_fifo(struct platform_device *dsidev,\r\nenum fifo_size size1, enum fifo_size size2,\r\nenum fifo_size size3, enum fifo_size size4)\r\n{\r\nstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\r\nu32 r = 0;\r\nint add = 0;\r\nint i;\r\ndsi->vc[0].fifo_size = size1;\r\ndsi->vc[1].fifo_size = size2;\r\ndsi->vc[2].fifo_size = size3;\r\ndsi->vc[3].fifo_size = size4;\r\nfor (i = 0; i < 4; i++) {\r\nu8 v;\r\nint size = dsi->vc[i].fifo_size;\r\nif (add + size > 4) {\r\nDSSERR("Illegal FIFO configuration\n");\r\nBUG();\r\nreturn;\r\n}\r\nv = FLD_VAL(add, 2, 0) | FLD_VAL(size, 7, 4);\r\nr |= v << (8 * i);\r\nadd += size;\r\n}\r\ndsi_write_reg(dsidev, DSI_RX_FIFO_VC_SIZE, r);\r\n}\r\nstatic int dsi_force_tx_stop_mode_io(struct platform_device *dsidev)\r\n{\r\nu32 r;\r\nr = dsi_read_reg(dsidev, DSI_TIMING1);\r\nr = FLD_MOD(r, 1, 15, 15);\r\ndsi_write_reg(dsidev, DSI_TIMING1, r);\r\nif (wait_for_bit_change(dsidev, DSI_TIMING1, 15, 0) != 0) {\r\nDSSERR("TX_STOP bit not going down\n");\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic bool dsi_vc_is_enabled(struct platform_device *dsidev, int channel)\r\n{\r\nreturn REG_GET(dsidev, DSI_VC_CTRL(channel), 0, 0);\r\n}\r\nstatic void dsi_packet_sent_handler_vp(void *data, u32 mask)\r\n{\r\nstruct dsi_packet_sent_handler_data *vp_data =\r\n(struct dsi_packet_sent_handler_data *) data;\r\nstruct dsi_data *dsi = dsi_get_dsidrv_data(vp_data->dsidev);\r\nconst int channel = dsi->update_channel;\r\nu8 bit = dsi->te_enabled ? 30 : 31;\r\nif (REG_GET(vp_data->dsidev, DSI_VC_TE(channel), bit, bit) == 0)\r\ncomplete(vp_data->completion);\r\n}\r\nstatic int dsi_sync_vc_vp(struct platform_device *dsidev, int channel)\r\n{\r\nstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\r\nDECLARE_COMPLETION_ONSTACK(completion);\r\nstruct dsi_packet_sent_handler_data vp_data = { dsidev, &completion };\r\nint r = 0;\r\nu8 bit;\r\nbit = dsi->te_enabled ? 30 : 31;\r\nr = dsi_register_isr_vc(dsidev, channel, dsi_packet_sent_handler_vp,\r\n&vp_data, DSI_VC_IRQ_PACKET_SENT);\r\nif (r)\r\ngoto err0;\r\nif (REG_GET(dsidev, DSI_VC_TE(channel), bit, bit)) {\r\nif (wait_for_completion_timeout(&completion,\r\nmsecs_to_jiffies(10)) == 0) {\r\nDSSERR("Failed to complete previous frame transfer\n");\r\nr = -EIO;\r\ngoto err1;\r\n}\r\n}\r\ndsi_unregister_isr_vc(dsidev, channel, dsi_packet_sent_handler_vp,\r\n&vp_data, DSI_VC_IRQ_PACKET_SENT);\r\nreturn 0;\r\nerr1:\r\ndsi_unregister_isr_vc(dsidev, channel, dsi_packet_sent_handler_vp,\r\n&vp_data, DSI_VC_IRQ_PACKET_SENT);\r\nerr0:\r\nreturn r;\r\n}\r\nstatic void dsi_packet_sent_handler_l4(void *data, u32 mask)\r\n{\r\nstruct dsi_packet_sent_handler_data *l4_data =\r\n(struct dsi_packet_sent_handler_data *) data;\r\nstruct dsi_data *dsi = dsi_get_dsidrv_data(l4_data->dsidev);\r\nconst int channel = dsi->update_channel;\r\nif (REG_GET(l4_data->dsidev, DSI_VC_CTRL(channel), 5, 5) == 0)\r\ncomplete(l4_data->completion);\r\n}\r\nstatic int dsi_sync_vc_l4(struct platform_device *dsidev, int channel)\r\n{\r\nDECLARE_COMPLETION_ONSTACK(completion);\r\nstruct dsi_packet_sent_handler_data l4_data = { dsidev, &completion };\r\nint r = 0;\r\nr = dsi_register_isr_vc(dsidev, channel, dsi_packet_sent_handler_l4,\r\n&l4_data, DSI_VC_IRQ_PACKET_SENT);\r\nif (r)\r\ngoto err0;\r\nif (REG_GET(dsidev, DSI_VC_CTRL(channel), 5, 5)) {\r\nif (wait_for_completion_timeout(&completion,\r\nmsecs_to_jiffies(10)) == 0) {\r\nDSSERR("Failed to complete previous l4 transfer\n");\r\nr = -EIO;\r\ngoto err1;\r\n}\r\n}\r\ndsi_unregister_isr_vc(dsidev, channel, dsi_packet_sent_handler_l4,\r\n&l4_data, DSI_VC_IRQ_PACKET_SENT);\r\nreturn 0;\r\nerr1:\r\ndsi_unregister_isr_vc(dsidev, channel, dsi_packet_sent_handler_l4,\r\n&l4_data, DSI_VC_IRQ_PACKET_SENT);\r\nerr0:\r\nreturn r;\r\n}\r\nstatic int dsi_sync_vc(struct platform_device *dsidev, int channel)\r\n{\r\nstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\r\nWARN_ON(!dsi_bus_is_locked(dsidev));\r\nWARN_ON(in_interrupt());\r\nif (!dsi_vc_is_enabled(dsidev, channel))\r\nreturn 0;\r\nswitch (dsi->vc[channel].source) {\r\ncase DSI_VC_SOURCE_VP:\r\nreturn dsi_sync_vc_vp(dsidev, channel);\r\ncase DSI_VC_SOURCE_L4:\r\nreturn dsi_sync_vc_l4(dsidev, channel);\r\ndefault:\r\nBUG();\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic int dsi_vc_enable(struct platform_device *dsidev, int channel,\r\nbool enable)\r\n{\r\nDSSDBG("dsi_vc_enable channel %d, enable %d\n",\r\nchannel, enable);\r\nenable = enable ? 1 : 0;\r\nREG_FLD_MOD(dsidev, DSI_VC_CTRL(channel), enable, 0, 0);\r\nif (wait_for_bit_change(dsidev, DSI_VC_CTRL(channel),\r\n0, enable) != enable) {\r\nDSSERR("Failed to set dsi_vc_enable to %d\n", enable);\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic void dsi_vc_initial_config(struct platform_device *dsidev, int channel)\r\n{\r\nu32 r;\r\nDSSDBG("Initial config of virtual channel %d", channel);\r\nr = dsi_read_reg(dsidev, DSI_VC_CTRL(channel));\r\nif (FLD_GET(r, 15, 15))\r\nDSSERR("VC(%d) busy when trying to configure it!\n",\r\nchannel);\r\nr = FLD_MOD(r, 0, 1, 1);\r\nr = FLD_MOD(r, 0, 2, 2);\r\nr = FLD_MOD(r, 0, 3, 3);\r\nr = FLD_MOD(r, 0, 4, 4);\r\nr = FLD_MOD(r, 1, 7, 7);\r\nr = FLD_MOD(r, 1, 8, 8);\r\nr = FLD_MOD(r, 0, 9, 9);\r\nif (dss_has_feature(FEAT_DSI_VC_OCP_WIDTH))\r\nr = FLD_MOD(r, 3, 11, 10);\r\nr = FLD_MOD(r, 4, 29, 27);\r\nr = FLD_MOD(r, 4, 23, 21);\r\ndsi_write_reg(dsidev, DSI_VC_CTRL(channel), r);\r\n}\r\nstatic int dsi_vc_config_source(struct platform_device *dsidev, int channel,\r\nenum dsi_vc_source source)\r\n{\r\nstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\r\nif (dsi->vc[channel].source == source)\r\nreturn 0;\r\nDSSDBG("Source config of virtual channel %d", channel);\r\ndsi_sync_vc(dsidev, channel);\r\ndsi_vc_enable(dsidev, channel, 0);\r\nif (wait_for_bit_change(dsidev, DSI_VC_CTRL(channel), 15, 0) != 0) {\r\nDSSERR("vc(%d) busy when trying to config for VP\n", channel);\r\nreturn -EIO;\r\n}\r\nREG_FLD_MOD(dsidev, DSI_VC_CTRL(channel), source, 1, 1);\r\nif (dss_has_feature(FEAT_DSI_DCS_CMD_CONFIG_VC)) {\r\nbool enable = source == DSI_VC_SOURCE_VP;\r\nREG_FLD_MOD(dsidev, DSI_VC_CTRL(channel), enable, 30, 30);\r\n}\r\ndsi_vc_enable(dsidev, channel, 1);\r\ndsi->vc[channel].source = source;\r\nreturn 0;\r\n}\r\nvoid omapdss_dsi_vc_enable_hs(struct omap_dss_device *dssdev, int channel,\r\nbool enable)\r\n{\r\nstruct platform_device *dsidev = dsi_get_dsidev_from_dssdev(dssdev);\r\nstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\r\nDSSDBG("dsi_vc_enable_hs(%d, %d)\n", channel, enable);\r\nWARN_ON(!dsi_bus_is_locked(dsidev));\r\ndsi_vc_enable(dsidev, channel, 0);\r\ndsi_if_enable(dsidev, 0);\r\nREG_FLD_MOD(dsidev, DSI_VC_CTRL(channel), enable, 9, 9);\r\ndsi_vc_enable(dsidev, channel, 1);\r\ndsi_if_enable(dsidev, 1);\r\ndsi_force_tx_stop_mode_io(dsidev);\r\nif (dsi->vm_timings.ddr_clk_always_on && enable)\r\ndsi_vc_send_null(dssdev, channel);\r\n}\r\nstatic void dsi_vc_flush_long_data(struct platform_device *dsidev, int channel)\r\n{\r\nwhile (REG_GET(dsidev, DSI_VC_CTRL(channel), 20, 20)) {\r\nu32 val;\r\nval = dsi_read_reg(dsidev, DSI_VC_SHORT_PACKET_HEADER(channel));\r\nDSSDBG("\t\tb1 %#02x b2 %#02x b3 %#02x b4 %#02x\n",\r\n(val >> 0) & 0xff,\r\n(val >> 8) & 0xff,\r\n(val >> 16) & 0xff,\r\n(val >> 24) & 0xff);\r\n}\r\n}\r\nstatic void dsi_show_rx_ack_with_err(u16 err)\r\n{\r\nDSSERR("\tACK with ERROR (%#x):\n", err);\r\nif (err & (1 << 0))\r\nDSSERR("\t\tSoT Error\n");\r\nif (err & (1 << 1))\r\nDSSERR("\t\tSoT Sync Error\n");\r\nif (err & (1 << 2))\r\nDSSERR("\t\tEoT Sync Error\n");\r\nif (err & (1 << 3))\r\nDSSERR("\t\tEscape Mode Entry Command Error\n");\r\nif (err & (1 << 4))\r\nDSSERR("\t\tLP Transmit Sync Error\n");\r\nif (err & (1 << 5))\r\nDSSERR("\t\tHS Receive Timeout Error\n");\r\nif (err & (1 << 6))\r\nDSSERR("\t\tFalse Control Error\n");\r\nif (err & (1 << 7))\r\nDSSERR("\t\t(reserved7)\n");\r\nif (err & (1 << 8))\r\nDSSERR("\t\tECC Error, single-bit (corrected)\n");\r\nif (err & (1 << 9))\r\nDSSERR("\t\tECC Error, multi-bit (not corrected)\n");\r\nif (err & (1 << 10))\r\nDSSERR("\t\tChecksum Error\n");\r\nif (err & (1 << 11))\r\nDSSERR("\t\tData type not recognized\n");\r\nif (err & (1 << 12))\r\nDSSERR("\t\tInvalid VC ID\n");\r\nif (err & (1 << 13))\r\nDSSERR("\t\tInvalid Transmission Length\n");\r\nif (err & (1 << 14))\r\nDSSERR("\t\t(reserved14)\n");\r\nif (err & (1 << 15))\r\nDSSERR("\t\tDSI Protocol Violation\n");\r\n}\r\nstatic u16 dsi_vc_flush_receive_data(struct platform_device *dsidev,\r\nint channel)\r\n{\r\nwhile (REG_GET(dsidev, DSI_VC_CTRL(channel), 20, 20)) {\r\nu32 val;\r\nu8 dt;\r\nval = dsi_read_reg(dsidev, DSI_VC_SHORT_PACKET_HEADER(channel));\r\nDSSERR("\trawval %#08x\n", val);\r\ndt = FLD_GET(val, 5, 0);\r\nif (dt == MIPI_DSI_RX_ACKNOWLEDGE_AND_ERROR_REPORT) {\r\nu16 err = FLD_GET(val, 23, 8);\r\ndsi_show_rx_ack_with_err(err);\r\n} else if (dt == MIPI_DSI_RX_DCS_SHORT_READ_RESPONSE_1BYTE) {\r\nDSSERR("\tDCS short response, 1 byte: %#x\n",\r\nFLD_GET(val, 23, 8));\r\n} else if (dt == MIPI_DSI_RX_DCS_SHORT_READ_RESPONSE_2BYTE) {\r\nDSSERR("\tDCS short response, 2 byte: %#x\n",\r\nFLD_GET(val, 23, 8));\r\n} else if (dt == MIPI_DSI_RX_DCS_LONG_READ_RESPONSE) {\r\nDSSERR("\tDCS long response, len %d\n",\r\nFLD_GET(val, 23, 8));\r\ndsi_vc_flush_long_data(dsidev, channel);\r\n} else {\r\nDSSERR("\tunknown datatype 0x%02x\n", dt);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int dsi_vc_send_bta(struct platform_device *dsidev, int channel)\r\n{\r\nstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\r\nif (dsi->debug_write || dsi->debug_read)\r\nDSSDBG("dsi_vc_send_bta %d\n", channel);\r\nWARN_ON(!dsi_bus_is_locked(dsidev));\r\nif (REG_GET(dsidev, DSI_VC_CTRL(channel), 20, 20)) {\r\nDSSERR("rx fifo not empty when sending BTA, dumping data:\n");\r\ndsi_vc_flush_receive_data(dsidev, channel);\r\n}\r\nREG_FLD_MOD(dsidev, DSI_VC_CTRL(channel), 1, 6, 6);\r\ndsi_read_reg(dsidev, DSI_VC_CTRL(channel));\r\nreturn 0;\r\n}\r\nint dsi_vc_send_bta_sync(struct omap_dss_device *dssdev, int channel)\r\n{\r\nstruct platform_device *dsidev = dsi_get_dsidev_from_dssdev(dssdev);\r\nDECLARE_COMPLETION_ONSTACK(completion);\r\nint r = 0;\r\nu32 err;\r\nr = dsi_register_isr_vc(dsidev, channel, dsi_completion_handler,\r\n&completion, DSI_VC_IRQ_BTA);\r\nif (r)\r\ngoto err0;\r\nr = dsi_register_isr(dsidev, dsi_completion_handler, &completion,\r\nDSI_IRQ_ERROR_MASK);\r\nif (r)\r\ngoto err1;\r\nr = dsi_vc_send_bta(dsidev, channel);\r\nif (r)\r\ngoto err2;\r\nif (wait_for_completion_timeout(&completion,\r\nmsecs_to_jiffies(500)) == 0) {\r\nDSSERR("Failed to receive BTA\n");\r\nr = -EIO;\r\ngoto err2;\r\n}\r\nerr = dsi_get_errors(dsidev);\r\nif (err) {\r\nDSSERR("Error while sending BTA: %x\n", err);\r\nr = -EIO;\r\ngoto err2;\r\n}\r\nerr2:\r\ndsi_unregister_isr(dsidev, dsi_completion_handler, &completion,\r\nDSI_IRQ_ERROR_MASK);\r\nerr1:\r\ndsi_unregister_isr_vc(dsidev, channel, dsi_completion_handler,\r\n&completion, DSI_VC_IRQ_BTA);\r\nerr0:\r\nreturn r;\r\n}\r\nstatic inline void dsi_vc_write_long_header(struct platform_device *dsidev,\r\nint channel, u8 data_type, u16 len, u8 ecc)\r\n{\r\nstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\r\nu32 val;\r\nu8 data_id;\r\nWARN_ON(!dsi_bus_is_locked(dsidev));\r\ndata_id = data_type | dsi->vc[channel].vc_id << 6;\r\nval = FLD_VAL(data_id, 7, 0) | FLD_VAL(len, 23, 8) |\r\nFLD_VAL(ecc, 31, 24);\r\ndsi_write_reg(dsidev, DSI_VC_LONG_PACKET_HEADER(channel), val);\r\n}\r\nstatic inline void dsi_vc_write_long_payload(struct platform_device *dsidev,\r\nint channel, u8 b1, u8 b2, u8 b3, u8 b4)\r\n{\r\nu32 val;\r\nval = b4 << 24 | b3 << 16 | b2 << 8 | b1 << 0;\r\ndsi_write_reg(dsidev, DSI_VC_LONG_PACKET_PAYLOAD(channel), val);\r\n}\r\nstatic int dsi_vc_send_long(struct platform_device *dsidev, int channel,\r\nu8 data_type, u8 *data, u16 len, u8 ecc)\r\n{\r\nstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\r\nint i;\r\nu8 *p;\r\nint r = 0;\r\nu8 b1, b2, b3, b4;\r\nif (dsi->debug_write)\r\nDSSDBG("dsi_vc_send_long, %d bytes\n", len);\r\nif (dsi->vc[channel].fifo_size * 32 * 4 < len + 4) {\r\nDSSERR("unable to send long packet: packet too long.\n");\r\nreturn -EINVAL;\r\n}\r\ndsi_vc_config_source(dsidev, channel, DSI_VC_SOURCE_L4);\r\ndsi_vc_write_long_header(dsidev, channel, data_type, len, ecc);\r\np = data;\r\nfor (i = 0; i < len >> 2; i++) {\r\nif (dsi->debug_write)\r\nDSSDBG("\tsending full packet %d\n", i);\r\nb1 = *p++;\r\nb2 = *p++;\r\nb3 = *p++;\r\nb4 = *p++;\r\ndsi_vc_write_long_payload(dsidev, channel, b1, b2, b3, b4);\r\n}\r\ni = len % 4;\r\nif (i) {\r\nb1 = 0; b2 = 0; b3 = 0;\r\nif (dsi->debug_write)\r\nDSSDBG("\tsending remainder bytes %d\n", i);\r\nswitch (i) {\r\ncase 3:\r\nb1 = *p++;\r\nb2 = *p++;\r\nb3 = *p++;\r\nbreak;\r\ncase 2:\r\nb1 = *p++;\r\nb2 = *p++;\r\nbreak;\r\ncase 1:\r\nb1 = *p++;\r\nbreak;\r\n}\r\ndsi_vc_write_long_payload(dsidev, channel, b1, b2, b3, 0);\r\n}\r\nreturn r;\r\n}\r\nstatic int dsi_vc_send_short(struct platform_device *dsidev, int channel,\r\nu8 data_type, u16 data, u8 ecc)\r\n{\r\nstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\r\nu32 r;\r\nu8 data_id;\r\nWARN_ON(!dsi_bus_is_locked(dsidev));\r\nif (dsi->debug_write)\r\nDSSDBG("dsi_vc_send_short(ch%d, dt %#x, b1 %#x, b2 %#x)\n",\r\nchannel,\r\ndata_type, data & 0xff, (data >> 8) & 0xff);\r\ndsi_vc_config_source(dsidev, channel, DSI_VC_SOURCE_L4);\r\nif (FLD_GET(dsi_read_reg(dsidev, DSI_VC_CTRL(channel)), 16, 16)) {\r\nDSSERR("ERROR FIFO FULL, aborting transfer\n");\r\nreturn -EINVAL;\r\n}\r\ndata_id = data_type | dsi->vc[channel].vc_id << 6;\r\nr = (data_id << 0) | (data << 8) | (ecc << 24);\r\ndsi_write_reg(dsidev, DSI_VC_SHORT_PACKET_HEADER(channel), r);\r\nreturn 0;\r\n}\r\nint dsi_vc_send_null(struct omap_dss_device *dssdev, int channel)\r\n{\r\nstruct platform_device *dsidev = dsi_get_dsidev_from_dssdev(dssdev);\r\nreturn dsi_vc_send_long(dsidev, channel, MIPI_DSI_NULL_PACKET, NULL,\r\n0, 0);\r\n}\r\nstatic int dsi_vc_write_nosync_common(struct platform_device *dsidev,\r\nint channel, u8 *data, int len, enum dss_dsi_content_type type)\r\n{\r\nint r;\r\nif (len == 0) {\r\nBUG_ON(type == DSS_DSI_CONTENT_DCS);\r\nr = dsi_vc_send_short(dsidev, channel,\r\nMIPI_DSI_GENERIC_SHORT_WRITE_0_PARAM, 0, 0);\r\n} else if (len == 1) {\r\nr = dsi_vc_send_short(dsidev, channel,\r\ntype == DSS_DSI_CONTENT_GENERIC ?\r\nMIPI_DSI_GENERIC_SHORT_WRITE_1_PARAM :\r\nMIPI_DSI_DCS_SHORT_WRITE, data[0], 0);\r\n} else if (len == 2) {\r\nr = dsi_vc_send_short(dsidev, channel,\r\ntype == DSS_DSI_CONTENT_GENERIC ?\r\nMIPI_DSI_GENERIC_SHORT_WRITE_2_PARAM :\r\nMIPI_DSI_DCS_SHORT_WRITE_PARAM,\r\ndata[0] | (data[1] << 8), 0);\r\n} else {\r\nr = dsi_vc_send_long(dsidev, channel,\r\ntype == DSS_DSI_CONTENT_GENERIC ?\r\nMIPI_DSI_GENERIC_LONG_WRITE :\r\nMIPI_DSI_DCS_LONG_WRITE, data, len, 0);\r\n}\r\nreturn r;\r\n}\r\nint dsi_vc_dcs_write_nosync(struct omap_dss_device *dssdev, int channel,\r\nu8 *data, int len)\r\n{\r\nstruct platform_device *dsidev = dsi_get_dsidev_from_dssdev(dssdev);\r\nreturn dsi_vc_write_nosync_common(dsidev, channel, data, len,\r\nDSS_DSI_CONTENT_DCS);\r\n}\r\nint dsi_vc_generic_write_nosync(struct omap_dss_device *dssdev, int channel,\r\nu8 *data, int len)\r\n{\r\nstruct platform_device *dsidev = dsi_get_dsidev_from_dssdev(dssdev);\r\nreturn dsi_vc_write_nosync_common(dsidev, channel, data, len,\r\nDSS_DSI_CONTENT_GENERIC);\r\n}\r\nstatic int dsi_vc_write_common(struct omap_dss_device *dssdev, int channel,\r\nu8 *data, int len, enum dss_dsi_content_type type)\r\n{\r\nstruct platform_device *dsidev = dsi_get_dsidev_from_dssdev(dssdev);\r\nint r;\r\nr = dsi_vc_write_nosync_common(dsidev, channel, data, len, type);\r\nif (r)\r\ngoto err;\r\nr = dsi_vc_send_bta_sync(dssdev, channel);\r\nif (r)\r\ngoto err;\r\nif (REG_GET(dsidev, DSI_VC_CTRL(channel), 20, 20)) {\r\nDSSERR("rx fifo not empty after write, dumping data:\n");\r\ndsi_vc_flush_receive_data(dsidev, channel);\r\nr = -EIO;\r\ngoto err;\r\n}\r\nreturn 0;\r\nerr:\r\nDSSERR("dsi_vc_write_common(ch %d, cmd 0x%02x, len %d) failed\n",\r\nchannel, data[0], len);\r\nreturn r;\r\n}\r\nint dsi_vc_dcs_write(struct omap_dss_device *dssdev, int channel, u8 *data,\r\nint len)\r\n{\r\nreturn dsi_vc_write_common(dssdev, channel, data, len,\r\nDSS_DSI_CONTENT_DCS);\r\n}\r\nint dsi_vc_generic_write(struct omap_dss_device *dssdev, int channel, u8 *data,\r\nint len)\r\n{\r\nreturn dsi_vc_write_common(dssdev, channel, data, len,\r\nDSS_DSI_CONTENT_GENERIC);\r\n}\r\nint dsi_vc_dcs_write_0(struct omap_dss_device *dssdev, int channel, u8 dcs_cmd)\r\n{\r\nreturn dsi_vc_dcs_write(dssdev, channel, &dcs_cmd, 1);\r\n}\r\nint dsi_vc_generic_write_0(struct omap_dss_device *dssdev, int channel)\r\n{\r\nreturn dsi_vc_generic_write(dssdev, channel, NULL, 0);\r\n}\r\nint dsi_vc_dcs_write_1(struct omap_dss_device *dssdev, int channel, u8 dcs_cmd,\r\nu8 param)\r\n{\r\nu8 buf[2];\r\nbuf[0] = dcs_cmd;\r\nbuf[1] = param;\r\nreturn dsi_vc_dcs_write(dssdev, channel, buf, 2);\r\n}\r\nint dsi_vc_generic_write_1(struct omap_dss_device *dssdev, int channel,\r\nu8 param)\r\n{\r\nreturn dsi_vc_generic_write(dssdev, channel, &param, 1);\r\n}\r\nint dsi_vc_generic_write_2(struct omap_dss_device *dssdev, int channel,\r\nu8 param1, u8 param2)\r\n{\r\nu8 buf[2];\r\nbuf[0] = param1;\r\nbuf[1] = param2;\r\nreturn dsi_vc_generic_write(dssdev, channel, buf, 2);\r\n}\r\nstatic int dsi_vc_dcs_send_read_request(struct platform_device *dsidev,\r\nint channel, u8 dcs_cmd)\r\n{\r\nstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\r\nint r;\r\nif (dsi->debug_read)\r\nDSSDBG("dsi_vc_dcs_send_read_request(ch%d, dcs_cmd %x)\n",\r\nchannel, dcs_cmd);\r\nr = dsi_vc_send_short(dsidev, channel, MIPI_DSI_DCS_READ, dcs_cmd, 0);\r\nif (r) {\r\nDSSERR("dsi_vc_dcs_send_read_request(ch %d, cmd 0x%02x)"\r\n" failed\n", channel, dcs_cmd);\r\nreturn r;\r\n}\r\nreturn 0;\r\n}\r\nstatic int dsi_vc_generic_send_read_request(struct platform_device *dsidev,\r\nint channel, u8 *reqdata, int reqlen)\r\n{\r\nstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\r\nu16 data;\r\nu8 data_type;\r\nint r;\r\nif (dsi->debug_read)\r\nDSSDBG("dsi_vc_generic_send_read_request(ch %d, reqlen %d)\n",\r\nchannel, reqlen);\r\nif (reqlen == 0) {\r\ndata_type = MIPI_DSI_GENERIC_READ_REQUEST_0_PARAM;\r\ndata = 0;\r\n} else if (reqlen == 1) {\r\ndata_type = MIPI_DSI_GENERIC_READ_REQUEST_1_PARAM;\r\ndata = reqdata[0];\r\n} else if (reqlen == 2) {\r\ndata_type = MIPI_DSI_GENERIC_READ_REQUEST_2_PARAM;\r\ndata = reqdata[0] | (reqdata[1] << 8);\r\n} else {\r\nBUG();\r\nreturn -EINVAL;\r\n}\r\nr = dsi_vc_send_short(dsidev, channel, data_type, data, 0);\r\nif (r) {\r\nDSSERR("dsi_vc_generic_send_read_request(ch %d, reqlen %d)"\r\n" failed\n", channel, reqlen);\r\nreturn r;\r\n}\r\nreturn 0;\r\n}\r\nstatic int dsi_vc_read_rx_fifo(struct platform_device *dsidev, int channel,\r\nu8 *buf, int buflen, enum dss_dsi_content_type type)\r\n{\r\nstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\r\nu32 val;\r\nu8 dt;\r\nint r;\r\nif (REG_GET(dsidev, DSI_VC_CTRL(channel), 20, 20) == 0) {\r\nDSSERR("RX fifo empty when trying to read.\n");\r\nr = -EIO;\r\ngoto err;\r\n}\r\nval = dsi_read_reg(dsidev, DSI_VC_SHORT_PACKET_HEADER(channel));\r\nif (dsi->debug_read)\r\nDSSDBG("\theader: %08x\n", val);\r\ndt = FLD_GET(val, 5, 0);\r\nif (dt == MIPI_DSI_RX_ACKNOWLEDGE_AND_ERROR_REPORT) {\r\nu16 err = FLD_GET(val, 23, 8);\r\ndsi_show_rx_ack_with_err(err);\r\nr = -EIO;\r\ngoto err;\r\n} else if (dt == (type == DSS_DSI_CONTENT_GENERIC ?\r\nMIPI_DSI_RX_GENERIC_SHORT_READ_RESPONSE_1BYTE :\r\nMIPI_DSI_RX_DCS_SHORT_READ_RESPONSE_1BYTE)) {\r\nu8 data = FLD_GET(val, 15, 8);\r\nif (dsi->debug_read)\r\nDSSDBG("\t%s short response, 1 byte: %02x\n",\r\ntype == DSS_DSI_CONTENT_GENERIC ? "GENERIC" :\r\n"DCS", data);\r\nif (buflen < 1) {\r\nr = -EIO;\r\ngoto err;\r\n}\r\nbuf[0] = data;\r\nreturn 1;\r\n} else if (dt == (type == DSS_DSI_CONTENT_GENERIC ?\r\nMIPI_DSI_RX_GENERIC_SHORT_READ_RESPONSE_2BYTE :\r\nMIPI_DSI_RX_DCS_SHORT_READ_RESPONSE_2BYTE)) {\r\nu16 data = FLD_GET(val, 23, 8);\r\nif (dsi->debug_read)\r\nDSSDBG("\t%s short response, 2 byte: %04x\n",\r\ntype == DSS_DSI_CONTENT_GENERIC ? "GENERIC" :\r\n"DCS", data);\r\nif (buflen < 2) {\r\nr = -EIO;\r\ngoto err;\r\n}\r\nbuf[0] = data & 0xff;\r\nbuf[1] = (data >> 8) & 0xff;\r\nreturn 2;\r\n} else if (dt == (type == DSS_DSI_CONTENT_GENERIC ?\r\nMIPI_DSI_RX_GENERIC_LONG_READ_RESPONSE :\r\nMIPI_DSI_RX_DCS_LONG_READ_RESPONSE)) {\r\nint w;\r\nint len = FLD_GET(val, 23, 8);\r\nif (dsi->debug_read)\r\nDSSDBG("\t%s long response, len %d\n",\r\ntype == DSS_DSI_CONTENT_GENERIC ? "GENERIC" :\r\n"DCS", len);\r\nif (len > buflen) {\r\nr = -EIO;\r\ngoto err;\r\n}\r\nfor (w = 0; w < len + 2;) {\r\nint b;\r\nval = dsi_read_reg(dsidev,\r\nDSI_VC_SHORT_PACKET_HEADER(channel));\r\nif (dsi->debug_read)\r\nDSSDBG("\t\t%02x %02x %02x %02x\n",\r\n(val >> 0) & 0xff,\r\n(val >> 8) & 0xff,\r\n(val >> 16) & 0xff,\r\n(val >> 24) & 0xff);\r\nfor (b = 0; b < 4; ++b) {\r\nif (w < len)\r\nbuf[w] = (val >> (b * 8)) & 0xff;\r\n++w;\r\n}\r\n}\r\nreturn len;\r\n} else {\r\nDSSERR("\tunknown datatype 0x%02x\n", dt);\r\nr = -EIO;\r\ngoto err;\r\n}\r\nerr:\r\nDSSERR("dsi_vc_read_rx_fifo(ch %d type %s) failed\n", channel,\r\ntype == DSS_DSI_CONTENT_GENERIC ? "GENERIC" : "DCS");\r\nreturn r;\r\n}\r\nint dsi_vc_dcs_read(struct omap_dss_device *dssdev, int channel, u8 dcs_cmd,\r\nu8 *buf, int buflen)\r\n{\r\nstruct platform_device *dsidev = dsi_get_dsidev_from_dssdev(dssdev);\r\nint r;\r\nr = dsi_vc_dcs_send_read_request(dsidev, channel, dcs_cmd);\r\nif (r)\r\ngoto err;\r\nr = dsi_vc_send_bta_sync(dssdev, channel);\r\nif (r)\r\ngoto err;\r\nr = dsi_vc_read_rx_fifo(dsidev, channel, buf, buflen,\r\nDSS_DSI_CONTENT_DCS);\r\nif (r < 0)\r\ngoto err;\r\nif (r != buflen) {\r\nr = -EIO;\r\ngoto err;\r\n}\r\nreturn 0;\r\nerr:\r\nDSSERR("dsi_vc_dcs_read(ch %d, cmd 0x%02x) failed\n", channel, dcs_cmd);\r\nreturn r;\r\n}\r\nstatic int dsi_vc_generic_read(struct omap_dss_device *dssdev, int channel,\r\nu8 *reqdata, int reqlen, u8 *buf, int buflen)\r\n{\r\nstruct platform_device *dsidev = dsi_get_dsidev_from_dssdev(dssdev);\r\nint r;\r\nr = dsi_vc_generic_send_read_request(dsidev, channel, reqdata, reqlen);\r\nif (r)\r\nreturn r;\r\nr = dsi_vc_send_bta_sync(dssdev, channel);\r\nif (r)\r\nreturn r;\r\nr = dsi_vc_read_rx_fifo(dsidev, channel, buf, buflen,\r\nDSS_DSI_CONTENT_GENERIC);\r\nif (r < 0)\r\nreturn r;\r\nif (r != buflen) {\r\nr = -EIO;\r\nreturn r;\r\n}\r\nreturn 0;\r\n}\r\nint dsi_vc_generic_read_0(struct omap_dss_device *dssdev, int channel, u8 *buf,\r\nint buflen)\r\n{\r\nint r;\r\nr = dsi_vc_generic_read(dssdev, channel, NULL, 0, buf, buflen);\r\nif (r) {\r\nDSSERR("dsi_vc_generic_read_0(ch %d) failed\n", channel);\r\nreturn r;\r\n}\r\nreturn 0;\r\n}\r\nint dsi_vc_generic_read_1(struct omap_dss_device *dssdev, int channel, u8 param,\r\nu8 *buf, int buflen)\r\n{\r\nint r;\r\nr = dsi_vc_generic_read(dssdev, channel, &param, 1, buf, buflen);\r\nif (r) {\r\nDSSERR("dsi_vc_generic_read_1(ch %d) failed\n", channel);\r\nreturn r;\r\n}\r\nreturn 0;\r\n}\r\nint dsi_vc_generic_read_2(struct omap_dss_device *dssdev, int channel,\r\nu8 param1, u8 param2, u8 *buf, int buflen)\r\n{\r\nint r;\r\nu8 reqdata[2];\r\nreqdata[0] = param1;\r\nreqdata[1] = param2;\r\nr = dsi_vc_generic_read(dssdev, channel, reqdata, 2, buf, buflen);\r\nif (r) {\r\nDSSERR("dsi_vc_generic_read_2(ch %d) failed\n", channel);\r\nreturn r;\r\n}\r\nreturn 0;\r\n}\r\nint dsi_vc_set_max_rx_packet_size(struct omap_dss_device *dssdev, int channel,\r\nu16 len)\r\n{\r\nstruct platform_device *dsidev = dsi_get_dsidev_from_dssdev(dssdev);\r\nreturn dsi_vc_send_short(dsidev, channel,\r\nMIPI_DSI_SET_MAXIMUM_RETURN_PACKET_SIZE, len, 0);\r\n}\r\nstatic int dsi_enter_ulps(struct platform_device *dsidev)\r\n{\r\nstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\r\nDECLARE_COMPLETION_ONSTACK(completion);\r\nint r, i;\r\nunsigned mask;\r\nDSSDBG("Entering ULPS");\r\nWARN_ON(!dsi_bus_is_locked(dsidev));\r\nWARN_ON(dsi->ulps_enabled);\r\nif (dsi->ulps_enabled)\r\nreturn 0;\r\nif (REG_GET(dsidev, DSI_CLK_CTRL, 13, 13)) {\r\ndsi_if_enable(dsidev, 0);\r\nREG_FLD_MOD(dsidev, DSI_CLK_CTRL, 0, 13, 13);\r\ndsi_if_enable(dsidev, 1);\r\n}\r\ndsi_sync_vc(dsidev, 0);\r\ndsi_sync_vc(dsidev, 1);\r\ndsi_sync_vc(dsidev, 2);\r\ndsi_sync_vc(dsidev, 3);\r\ndsi_force_tx_stop_mode_io(dsidev);\r\ndsi_vc_enable(dsidev, 0, false);\r\ndsi_vc_enable(dsidev, 1, false);\r\ndsi_vc_enable(dsidev, 2, false);\r\ndsi_vc_enable(dsidev, 3, false);\r\nif (REG_GET(dsidev, DSI_COMPLEXIO_CFG2, 16, 16)) {\r\nDSSERR("HS busy when enabling ULPS\n");\r\nreturn -EIO;\r\n}\r\nif (REG_GET(dsidev, DSI_COMPLEXIO_CFG2, 17, 17)) {\r\nDSSERR("LP busy when enabling ULPS\n");\r\nreturn -EIO;\r\n}\r\nr = dsi_register_isr_cio(dsidev, dsi_completion_handler, &completion,\r\nDSI_CIO_IRQ_ULPSACTIVENOT_ALL0);\r\nif (r)\r\nreturn r;\r\nmask = 0;\r\nfor (i = 0; i < dsi->num_lanes_supported; ++i) {\r\nif (dsi->lanes[i].function == DSI_LANE_UNUSED)\r\ncontinue;\r\nmask |= 1 << i;\r\n}\r\nREG_FLD_MOD(dsidev, DSI_COMPLEXIO_CFG2, mask, 9, 5);\r\ndsi_read_reg(dsidev, DSI_COMPLEXIO_CFG2);\r\nif (wait_for_completion_timeout(&completion,\r\nmsecs_to_jiffies(1000)) == 0) {\r\nDSSERR("ULPS enable timeout\n");\r\nr = -EIO;\r\ngoto err;\r\n}\r\ndsi_unregister_isr_cio(dsidev, dsi_completion_handler, &completion,\r\nDSI_CIO_IRQ_ULPSACTIVENOT_ALL0);\r\nREG_FLD_MOD(dsidev, DSI_COMPLEXIO_CFG2, 0, 9, 5);\r\ndsi_read_reg(dsidev, DSI_COMPLEXIO_CFG2);\r\ndsi_cio_power(dsidev, DSI_COMPLEXIO_POWER_ULPS);\r\ndsi_if_enable(dsidev, false);\r\ndsi->ulps_enabled = true;\r\nreturn 0;\r\nerr:\r\ndsi_unregister_isr_cio(dsidev, dsi_completion_handler, &completion,\r\nDSI_CIO_IRQ_ULPSACTIVENOT_ALL0);\r\nreturn r;\r\n}\r\nstatic void dsi_set_lp_rx_timeout(struct platform_device *dsidev,\r\nunsigned ticks, bool x4, bool x16)\r\n{\r\nunsigned long fck;\r\nunsigned long total_ticks;\r\nu32 r;\r\nBUG_ON(ticks > 0x1fff);\r\nfck = dsi_fclk_rate(dsidev);\r\nr = dsi_read_reg(dsidev, DSI_TIMING2);\r\nr = FLD_MOD(r, 1, 15, 15);\r\nr = FLD_MOD(r, x16 ? 1 : 0, 14, 14);\r\nr = FLD_MOD(r, x4 ? 1 : 0, 13, 13);\r\nr = FLD_MOD(r, ticks, 12, 0);\r\ndsi_write_reg(dsidev, DSI_TIMING2, r);\r\ntotal_ticks = ticks * (x16 ? 16 : 1) * (x4 ? 4 : 1);\r\nDSSDBG("LP_RX_TO %lu ticks (%#x%s%s) = %lu ns\n",\r\ntotal_ticks,\r\nticks, x4 ? " x4" : "", x16 ? " x16" : "",\r\n(total_ticks * 1000) / (fck / 1000 / 1000));\r\n}\r\nstatic void dsi_set_ta_timeout(struct platform_device *dsidev, unsigned ticks,\r\nbool x8, bool x16)\r\n{\r\nunsigned long fck;\r\nunsigned long total_ticks;\r\nu32 r;\r\nBUG_ON(ticks > 0x1fff);\r\nfck = dsi_fclk_rate(dsidev);\r\nr = dsi_read_reg(dsidev, DSI_TIMING1);\r\nr = FLD_MOD(r, 1, 31, 31);\r\nr = FLD_MOD(r, x16 ? 1 : 0, 30, 30);\r\nr = FLD_MOD(r, x8 ? 1 : 0, 29, 29);\r\nr = FLD_MOD(r, ticks, 28, 16);\r\ndsi_write_reg(dsidev, DSI_TIMING1, r);\r\ntotal_ticks = ticks * (x16 ? 16 : 1) * (x8 ? 8 : 1);\r\nDSSDBG("TA_TO %lu ticks (%#x%s%s) = %lu ns\n",\r\ntotal_ticks,\r\nticks, x8 ? " x8" : "", x16 ? " x16" : "",\r\n(total_ticks * 1000) / (fck / 1000 / 1000));\r\n}\r\nstatic void dsi_set_stop_state_counter(struct platform_device *dsidev,\r\nunsigned ticks, bool x4, bool x16)\r\n{\r\nunsigned long fck;\r\nunsigned long total_ticks;\r\nu32 r;\r\nBUG_ON(ticks > 0x1fff);\r\nfck = dsi_fclk_rate(dsidev);\r\nr = dsi_read_reg(dsidev, DSI_TIMING1);\r\nr = FLD_MOD(r, 1, 15, 15);\r\nr = FLD_MOD(r, x16 ? 1 : 0, 14, 14);\r\nr = FLD_MOD(r, x4 ? 1 : 0, 13, 13);\r\nr = FLD_MOD(r, ticks, 12, 0);\r\ndsi_write_reg(dsidev, DSI_TIMING1, r);\r\ntotal_ticks = ticks * (x16 ? 16 : 1) * (x4 ? 4 : 1);\r\nDSSDBG("STOP_STATE_COUNTER %lu ticks (%#x%s%s) = %lu ns\n",\r\ntotal_ticks,\r\nticks, x4 ? " x4" : "", x16 ? " x16" : "",\r\n(total_ticks * 1000) / (fck / 1000 / 1000));\r\n}\r\nstatic void dsi_set_hs_tx_timeout(struct platform_device *dsidev,\r\nunsigned ticks, bool x4, bool x16)\r\n{\r\nunsigned long fck;\r\nunsigned long total_ticks;\r\nu32 r;\r\nBUG_ON(ticks > 0x1fff);\r\nfck = dsi_get_txbyteclkhs(dsidev);\r\nr = dsi_read_reg(dsidev, DSI_TIMING2);\r\nr = FLD_MOD(r, 1, 31, 31);\r\nr = FLD_MOD(r, x16 ? 1 : 0, 30, 30);\r\nr = FLD_MOD(r, x4 ? 1 : 0, 29, 29);\r\nr = FLD_MOD(r, ticks, 28, 16);\r\ndsi_write_reg(dsidev, DSI_TIMING2, r);\r\ntotal_ticks = ticks * (x16 ? 16 : 1) * (x4 ? 4 : 1);\r\nDSSDBG("HS_TX_TO %lu ticks (%#x%s%s) = %lu ns\n",\r\ntotal_ticks,\r\nticks, x4 ? " x4" : "", x16 ? " x16" : "",\r\n(total_ticks * 1000) / (fck / 1000 / 1000));\r\n}\r\nstatic void dsi_config_vp_num_line_buffers(struct platform_device *dsidev)\r\n{\r\nstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\r\nint num_line_buffers;\r\nif (dsi->mode == OMAP_DSS_DSI_VIDEO_MODE) {\r\nint bpp = dsi_get_pixel_size(dsi->pix_fmt);\r\nunsigned line_buf_size = dsi_get_line_buf_size(dsidev);\r\nstruct omap_video_timings *timings = &dsi->timings;\r\nif (line_buf_size <= timings->x_res * bpp / 8)\r\nnum_line_buffers = 0;\r\nelse\r\nnum_line_buffers = 2;\r\n} else {\r\nnum_line_buffers = 2;\r\n}\r\nREG_FLD_MOD(dsidev, DSI_CTRL, num_line_buffers, 13, 12);\r\n}\r\nstatic void dsi_config_vp_sync_events(struct platform_device *dsidev)\r\n{\r\nstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\r\nbool vsync_end = dsi->vm_timings.vp_vsync_end;\r\nbool hsync_end = dsi->vm_timings.vp_hsync_end;\r\nu32 r;\r\nr = dsi_read_reg(dsidev, DSI_CTRL);\r\nr = FLD_MOD(r, 1, 9, 9);\r\nr = FLD_MOD(r, 1, 10, 10);\r\nr = FLD_MOD(r, 1, 11, 11);\r\nr = FLD_MOD(r, 1, 15, 15);\r\nr = FLD_MOD(r, vsync_end, 16, 16);\r\nr = FLD_MOD(r, 1, 17, 17);\r\nr = FLD_MOD(r, hsync_end, 18, 18);\r\ndsi_write_reg(dsidev, DSI_CTRL, r);\r\n}\r\nstatic void dsi_config_blanking_modes(struct platform_device *dsidev)\r\n{\r\nstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\r\nint blanking_mode = dsi->vm_timings.blanking_mode;\r\nint hfp_blanking_mode = dsi->vm_timings.hfp_blanking_mode;\r\nint hbp_blanking_mode = dsi->vm_timings.hbp_blanking_mode;\r\nint hsa_blanking_mode = dsi->vm_timings.hsa_blanking_mode;\r\nu32 r;\r\nr = dsi_read_reg(dsidev, DSI_CTRL);\r\nr = FLD_MOD(r, blanking_mode, 20, 20);\r\nr = FLD_MOD(r, hfp_blanking_mode, 21, 21);\r\nr = FLD_MOD(r, hbp_blanking_mode, 22, 22);\r\nr = FLD_MOD(r, hsa_blanking_mode, 23, 23);\r\ndsi_write_reg(dsidev, DSI_CTRL, r);\r\n}\r\nstatic int dsi_compute_interleave_hs(int blank, bool ddr_alwon, int enter_hs,\r\nint exit_hs, int exiths_clk, int ddr_pre, int ddr_post)\r\n{\r\nint transition;\r\nif (ddr_alwon) {\r\ntransition = enter_hs + exit_hs + max(enter_hs, 2) + 1;\r\n} else {\r\nint trans1, trans2;\r\ntrans1 = ddr_pre + enter_hs + exit_hs + max(enter_hs, 2) + 1;\r\ntrans2 = ddr_pre + enter_hs + exiths_clk + ddr_post + ddr_pre +\r\nenter_hs + 1;\r\ntransition = max(trans1, trans2);\r\n}\r\nreturn blank > transition ? blank - transition : 0;\r\n}\r\nstatic int dsi_compute_interleave_lp(int blank, int enter_hs, int exit_hs,\r\nint lp_clk_div, int tdsi_fclk)\r\n{\r\nint trans_lp;\r\nint tlp_avail;\r\nint ttxclkesc;\r\nint thsbyte_clk = 16;\r\nint lp_inter;\r\ntrans_lp = exit_hs + max(enter_hs, 2) + 1;\r\ntlp_avail = thsbyte_clk * (blank - trans_lp);\r\nttxclkesc = tdsi_fclk * lp_clk_div;\r\nlp_inter = ((tlp_avail - 8 * thsbyte_clk - 5 * tdsi_fclk) / ttxclkesc -\r\n26) / 16;\r\nreturn max(lp_inter, 0);\r\n}\r\nstatic void dsi_config_cmd_mode_interleaving(struct omap_dss_device *dssdev)\r\n{\r\nstruct platform_device *dsidev = dsi_get_dsidev_from_dssdev(dssdev);\r\nstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\r\nint blanking_mode;\r\nint hfp_blanking_mode, hbp_blanking_mode, hsa_blanking_mode;\r\nint hsa, hfp, hbp, width_bytes, bllp, lp_clk_div;\r\nint ddr_clk_pre, ddr_clk_post, enter_hs_mode_lat, exit_hs_mode_lat;\r\nint tclk_trail, ths_exit, exiths_clk;\r\nbool ddr_alwon;\r\nstruct omap_video_timings *timings = &dsi->timings;\r\nint bpp = dsi_get_pixel_size(dsi->pix_fmt);\r\nint ndl = dsi->num_lanes_used - 1;\r\nint dsi_fclk_hsdiv = dssdev->clocks.dsi.regm_dsi + 1;\r\nint hsa_interleave_hs = 0, hsa_interleave_lp = 0;\r\nint hfp_interleave_hs = 0, hfp_interleave_lp = 0;\r\nint hbp_interleave_hs = 0, hbp_interleave_lp = 0;\r\nint bl_interleave_hs = 0, bl_interleave_lp = 0;\r\nu32 r;\r\nr = dsi_read_reg(dsidev, DSI_CTRL);\r\nblanking_mode = FLD_GET(r, 20, 20);\r\nhfp_blanking_mode = FLD_GET(r, 21, 21);\r\nhbp_blanking_mode = FLD_GET(r, 22, 22);\r\nhsa_blanking_mode = FLD_GET(r, 23, 23);\r\nr = dsi_read_reg(dsidev, DSI_VM_TIMING1);\r\nhbp = FLD_GET(r, 11, 0);\r\nhfp = FLD_GET(r, 23, 12);\r\nhsa = FLD_GET(r, 31, 24);\r\nr = dsi_read_reg(dsidev, DSI_CLK_TIMING);\r\nddr_clk_post = FLD_GET(r, 7, 0);\r\nddr_clk_pre = FLD_GET(r, 15, 8);\r\nr = dsi_read_reg(dsidev, DSI_VM_TIMING7);\r\nexit_hs_mode_lat = FLD_GET(r, 15, 0);\r\nenter_hs_mode_lat = FLD_GET(r, 31, 16);\r\nr = dsi_read_reg(dsidev, DSI_CLK_CTRL);\r\nlp_clk_div = FLD_GET(r, 12, 0);\r\nddr_alwon = FLD_GET(r, 13, 13);\r\nr = dsi_read_reg(dsidev, DSI_DSIPHY_CFG0);\r\nths_exit = FLD_GET(r, 7, 0);\r\nr = dsi_read_reg(dsidev, DSI_DSIPHY_CFG1);\r\ntclk_trail = FLD_GET(r, 15, 8);\r\nexiths_clk = ths_exit + tclk_trail;\r\nwidth_bytes = DIV_ROUND_UP(timings->x_res * bpp, 8);\r\nbllp = hbp + hfp + hsa + DIV_ROUND_UP(width_bytes + 6, ndl);\r\nif (!hsa_blanking_mode) {\r\nhsa_interleave_hs = dsi_compute_interleave_hs(hsa, ddr_alwon,\r\nenter_hs_mode_lat, exit_hs_mode_lat,\r\nexiths_clk, ddr_clk_pre, ddr_clk_post);\r\nhsa_interleave_lp = dsi_compute_interleave_lp(hsa,\r\nenter_hs_mode_lat, exit_hs_mode_lat,\r\nlp_clk_div, dsi_fclk_hsdiv);\r\n}\r\nif (!hfp_blanking_mode) {\r\nhfp_interleave_hs = dsi_compute_interleave_hs(hfp, ddr_alwon,\r\nenter_hs_mode_lat, exit_hs_mode_lat,\r\nexiths_clk, ddr_clk_pre, ddr_clk_post);\r\nhfp_interleave_lp = dsi_compute_interleave_lp(hfp,\r\nenter_hs_mode_lat, exit_hs_mode_lat,\r\nlp_clk_div, dsi_fclk_hsdiv);\r\n}\r\nif (!hbp_blanking_mode) {\r\nhbp_interleave_hs = dsi_compute_interleave_hs(hbp, ddr_alwon,\r\nenter_hs_mode_lat, exit_hs_mode_lat,\r\nexiths_clk, ddr_clk_pre, ddr_clk_post);\r\nhbp_interleave_lp = dsi_compute_interleave_lp(hbp,\r\nenter_hs_mode_lat, exit_hs_mode_lat,\r\nlp_clk_div, dsi_fclk_hsdiv);\r\n}\r\nif (!blanking_mode) {\r\nbl_interleave_hs = dsi_compute_interleave_hs(bllp, ddr_alwon,\r\nenter_hs_mode_lat, exit_hs_mode_lat,\r\nexiths_clk, ddr_clk_pre, ddr_clk_post);\r\nbl_interleave_lp = dsi_compute_interleave_lp(bllp,\r\nenter_hs_mode_lat, exit_hs_mode_lat,\r\nlp_clk_div, dsi_fclk_hsdiv);\r\n}\r\nDSSDBG("DSI HS interleaving(TXBYTECLKHS) HSA %d, HFP %d, HBP %d, BLLP %d\n",\r\nhsa_interleave_hs, hfp_interleave_hs, hbp_interleave_hs,\r\nbl_interleave_hs);\r\nDSSDBG("DSI LP interleaving(bytes) HSA %d, HFP %d, HBP %d, BLLP %d\n",\r\nhsa_interleave_lp, hfp_interleave_lp, hbp_interleave_lp,\r\nbl_interleave_lp);\r\nr = dsi_read_reg(dsidev, DSI_VM_TIMING4);\r\nr = FLD_MOD(r, hsa_interleave_hs, 23, 16);\r\nr = FLD_MOD(r, hfp_interleave_hs, 15, 8);\r\nr = FLD_MOD(r, hbp_interleave_hs, 7, 0);\r\ndsi_write_reg(dsidev, DSI_VM_TIMING4, r);\r\nr = dsi_read_reg(dsidev, DSI_VM_TIMING5);\r\nr = FLD_MOD(r, hsa_interleave_lp, 23, 16);\r\nr = FLD_MOD(r, hfp_interleave_lp, 15, 8);\r\nr = FLD_MOD(r, hbp_interleave_lp, 7, 0);\r\ndsi_write_reg(dsidev, DSI_VM_TIMING5, r);\r\nr = dsi_read_reg(dsidev, DSI_VM_TIMING6);\r\nr = FLD_MOD(r, bl_interleave_hs, 31, 15);\r\nr = FLD_MOD(r, bl_interleave_lp, 16, 0);\r\ndsi_write_reg(dsidev, DSI_VM_TIMING6, r);\r\n}\r\nstatic int dsi_proto_config(struct omap_dss_device *dssdev)\r\n{\r\nstruct platform_device *dsidev = dsi_get_dsidev_from_dssdev(dssdev);\r\nstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\r\nu32 r;\r\nint buswidth = 0;\r\ndsi_config_tx_fifo(dsidev, DSI_FIFO_SIZE_32,\r\nDSI_FIFO_SIZE_32,\r\nDSI_FIFO_SIZE_32,\r\nDSI_FIFO_SIZE_32);\r\ndsi_config_rx_fifo(dsidev, DSI_FIFO_SIZE_32,\r\nDSI_FIFO_SIZE_32,\r\nDSI_FIFO_SIZE_32,\r\nDSI_FIFO_SIZE_32);\r\ndsi_set_stop_state_counter(dsidev, 0x1000, false, false);\r\ndsi_set_ta_timeout(dsidev, 0x1fff, true, true);\r\ndsi_set_lp_rx_timeout(dsidev, 0x1fff, true, true);\r\ndsi_set_hs_tx_timeout(dsidev, 0x1fff, true, true);\r\nswitch (dsi_get_pixel_size(dsi->pix_fmt)) {\r\ncase 16:\r\nbuswidth = 0;\r\nbreak;\r\ncase 18:\r\nbuswidth = 1;\r\nbreak;\r\ncase 24:\r\nbuswidth = 2;\r\nbreak;\r\ndefault:\r\nBUG();\r\nreturn -EINVAL;\r\n}\r\nr = dsi_read_reg(dsidev, DSI_CTRL);\r\nr = FLD_MOD(r, 1, 1, 1);\r\nr = FLD_MOD(r, 1, 2, 2);\r\nr = FLD_MOD(r, 1, 3, 3);\r\nr = FLD_MOD(r, 1, 4, 4);\r\nr = FLD_MOD(r, buswidth, 7, 6);\r\nr = FLD_MOD(r, 0, 8, 8);\r\nr = FLD_MOD(r, 1, 14, 14);\r\nr = FLD_MOD(r, 1, 19, 19);\r\nif (!dss_has_feature(FEAT_DSI_DCS_CMD_CONFIG_VC)) {\r\nr = FLD_MOD(r, 1, 24, 24);\r\nr = FLD_MOD(r, 0, 25, 25);\r\n}\r\ndsi_write_reg(dsidev, DSI_CTRL, r);\r\ndsi_config_vp_num_line_buffers(dsidev);\r\nif (dsi->mode == OMAP_DSS_DSI_VIDEO_MODE) {\r\ndsi_config_vp_sync_events(dsidev);\r\ndsi_config_blanking_modes(dsidev);\r\ndsi_config_cmd_mode_interleaving(dssdev);\r\n}\r\ndsi_vc_initial_config(dsidev, 0);\r\ndsi_vc_initial_config(dsidev, 1);\r\ndsi_vc_initial_config(dsidev, 2);\r\ndsi_vc_initial_config(dsidev, 3);\r\nreturn 0;\r\n}\r\nstatic void dsi_proto_timings(struct platform_device *dsidev)\r\n{\r\nstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\r\nunsigned tlpx, tclk_zero, tclk_prepare, tclk_trail;\r\nunsigned tclk_pre, tclk_post;\r\nunsigned ths_prepare, ths_prepare_ths_zero, ths_zero;\r\nunsigned ths_trail, ths_exit;\r\nunsigned ddr_clk_pre, ddr_clk_post;\r\nunsigned enter_hs_mode_lat, exit_hs_mode_lat;\r\nunsigned ths_eot;\r\nint ndl = dsi->num_lanes_used - 1;\r\nu32 r;\r\nr = dsi_read_reg(dsidev, DSI_DSIPHY_CFG0);\r\nths_prepare = FLD_GET(r, 31, 24);\r\nths_prepare_ths_zero = FLD_GET(r, 23, 16);\r\nths_zero = ths_prepare_ths_zero - ths_prepare;\r\nths_trail = FLD_GET(r, 15, 8);\r\nths_exit = FLD_GET(r, 7, 0);\r\nr = dsi_read_reg(dsidev, DSI_DSIPHY_CFG1);\r\ntlpx = FLD_GET(r, 20, 16) * 2;\r\ntclk_trail = FLD_GET(r, 15, 8);\r\ntclk_zero = FLD_GET(r, 7, 0);\r\nr = dsi_read_reg(dsidev, DSI_DSIPHY_CFG2);\r\ntclk_prepare = FLD_GET(r, 7, 0);\r\ntclk_pre = 20;\r\ntclk_post = ns2ddr(dsidev, 60) + 26;\r\nths_eot = DIV_ROUND_UP(4, ndl);\r\nddr_clk_pre = DIV_ROUND_UP(tclk_pre + tlpx + tclk_zero + tclk_prepare,\r\n4);\r\nddr_clk_post = DIV_ROUND_UP(tclk_post + ths_trail, 4) + ths_eot;\r\nBUG_ON(ddr_clk_pre == 0 || ddr_clk_pre > 255);\r\nBUG_ON(ddr_clk_post == 0 || ddr_clk_post > 255);\r\nr = dsi_read_reg(dsidev, DSI_CLK_TIMING);\r\nr = FLD_MOD(r, ddr_clk_pre, 15, 8);\r\nr = FLD_MOD(r, ddr_clk_post, 7, 0);\r\ndsi_write_reg(dsidev, DSI_CLK_TIMING, r);\r\nDSSDBG("ddr_clk_pre %u, ddr_clk_post %u\n",\r\nddr_clk_pre,\r\nddr_clk_post);\r\nenter_hs_mode_lat = 1 + DIV_ROUND_UP(tlpx, 4) +\r\nDIV_ROUND_UP(ths_prepare, 4) +\r\nDIV_ROUND_UP(ths_zero + 3, 4);\r\nexit_hs_mode_lat = DIV_ROUND_UP(ths_trail + ths_exit, 4) + 1 + ths_eot;\r\nr = FLD_VAL(enter_hs_mode_lat, 31, 16) |\r\nFLD_VAL(exit_hs_mode_lat, 15, 0);\r\ndsi_write_reg(dsidev, DSI_VM_TIMING7, r);\r\nDSSDBG("enter_hs_mode_lat %u, exit_hs_mode_lat %u\n",\r\nenter_hs_mode_lat, exit_hs_mode_lat);\r\nif (dsi->mode == OMAP_DSS_DSI_VIDEO_MODE) {\r\nint hsa = dsi->vm_timings.hsa;\r\nint hfp = dsi->vm_timings.hfp;\r\nint hbp = dsi->vm_timings.hbp;\r\nint vsa = dsi->vm_timings.vsa;\r\nint vfp = dsi->vm_timings.vfp;\r\nint vbp = dsi->vm_timings.vbp;\r\nint window_sync = dsi->vm_timings.window_sync;\r\nbool hsync_end = dsi->vm_timings.vp_hsync_end;\r\nstruct omap_video_timings *timings = &dsi->timings;\r\nint bpp = dsi_get_pixel_size(dsi->pix_fmt);\r\nint tl, t_he, width_bytes;\r\nt_he = hsync_end ?\r\n((hsa == 0 && ndl == 3) ? 1 : DIV_ROUND_UP(4, ndl)) : 0;\r\nwidth_bytes = DIV_ROUND_UP(timings->x_res * bpp, 8);\r\ntl = DIV_ROUND_UP(4, ndl) + (hsync_end ? hsa : 0) + t_he + hfp +\r\nDIV_ROUND_UP(width_bytes + 6, ndl) + hbp;\r\nDSSDBG("HBP: %d, HFP: %d, HSA: %d, TL: %d TXBYTECLKHS\n", hbp,\r\nhfp, hsync_end ? hsa : 0, tl);\r\nDSSDBG("VBP: %d, VFP: %d, VSA: %d, VACT: %d lines\n", vbp, vfp,\r\nvsa, timings->y_res);\r\nr = dsi_read_reg(dsidev, DSI_VM_TIMING1);\r\nr = FLD_MOD(r, hbp, 11, 0);\r\nr = FLD_MOD(r, hfp, 23, 12);\r\nr = FLD_MOD(r, hsync_end ? hsa : 0, 31, 24);\r\ndsi_write_reg(dsidev, DSI_VM_TIMING1, r);\r\nr = dsi_read_reg(dsidev, DSI_VM_TIMING2);\r\nr = FLD_MOD(r, vbp, 7, 0);\r\nr = FLD_MOD(r, vfp, 15, 8);\r\nr = FLD_MOD(r, vsa, 23, 16);\r\nr = FLD_MOD(r, window_sync, 27, 24);\r\ndsi_write_reg(dsidev, DSI_VM_TIMING2, r);\r\nr = dsi_read_reg(dsidev, DSI_VM_TIMING3);\r\nr = FLD_MOD(r, timings->y_res, 14, 0);\r\nr = FLD_MOD(r, tl, 31, 16);\r\ndsi_write_reg(dsidev, DSI_VM_TIMING3, r);\r\n}\r\n}\r\nint omapdss_dsi_configure_pins(struct omap_dss_device *dssdev,\r\nconst struct omap_dsi_pin_config *pin_cfg)\r\n{\r\nstruct platform_device *dsidev = dsi_get_dsidev_from_dssdev(dssdev);\r\nstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\r\nint num_pins;\r\nconst int *pins;\r\nstruct dsi_lane_config lanes[DSI_MAX_NR_LANES];\r\nint num_lanes;\r\nint i;\r\nstatic const enum dsi_lane_function functions[] = {\r\nDSI_LANE_CLK,\r\nDSI_LANE_DATA1,\r\nDSI_LANE_DATA2,\r\nDSI_LANE_DATA3,\r\nDSI_LANE_DATA4,\r\n};\r\nnum_pins = pin_cfg->num_pins;\r\npins = pin_cfg->pins;\r\nif (num_pins < 4 || num_pins > dsi->num_lanes_supported * 2\r\n|| num_pins % 2 != 0)\r\nreturn -EINVAL;\r\nfor (i = 0; i < DSI_MAX_NR_LANES; ++i)\r\nlanes[i].function = DSI_LANE_UNUSED;\r\nnum_lanes = 0;\r\nfor (i = 0; i < num_pins; i += 2) {\r\nu8 lane, pol;\r\nint dx, dy;\r\ndx = pins[i];\r\ndy = pins[i + 1];\r\nif (dx < 0 || dx >= dsi->num_lanes_supported * 2)\r\nreturn -EINVAL;\r\nif (dy < 0 || dy >= dsi->num_lanes_supported * 2)\r\nreturn -EINVAL;\r\nif (dx & 1) {\r\nif (dy != dx - 1)\r\nreturn -EINVAL;\r\npol = 1;\r\n} else {\r\nif (dy != dx + 1)\r\nreturn -EINVAL;\r\npol = 0;\r\n}\r\nlane = dx / 2;\r\nlanes[lane].function = functions[i / 2];\r\nlanes[lane].polarity = pol;\r\nnum_lanes++;\r\n}\r\nmemcpy(dsi->lanes, lanes, sizeof(dsi->lanes));\r\ndsi->num_lanes_used = num_lanes;\r\nreturn 0;\r\n}\r\nint omapdss_dsi_set_clocks(struct omap_dss_device *dssdev,\r\nunsigned long ddr_clk, unsigned long lp_clk)\r\n{\r\nstruct platform_device *dsidev = dsi_get_dsidev_from_dssdev(dssdev);\r\nstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\r\nstruct dsi_clock_info cinfo;\r\nstruct dispc_clock_info dispc_cinfo;\r\nunsigned lp_clk_div;\r\nunsigned long dsi_fclk;\r\nint bpp = dsi_get_pixel_size(dssdev->panel.dsi_pix_fmt);\r\nunsigned long pck;\r\nint r;\r\nDSSDBG("Setting DSI clocks: ddr_clk %lu, lp_clk %lu", ddr_clk, lp_clk);\r\nmutex_lock(&dsi->lock);\r\nr = dsi_pll_calc_ddrfreq(dsidev, ddr_clk * 4, &cinfo);\r\nif (r)\r\ngoto err;\r\ndsi_pll_calc_dsi_fck(dsidev, &cinfo);\r\npck = cinfo.clkin4ddr / 16 * (dsi->num_lanes_used - 1) * 8 / bpp;\r\nDSSDBG("finding dispc dividers for pck %lu\n", pck);\r\nr = dsi_pll_calc_dispc_fck(dsidev, pck, &cinfo, &dispc_cinfo);\r\nif (r)\r\ngoto err;\r\ndsi_fclk = cinfo.dsi_pll_hsdiv_dsi_clk;\r\nlp_clk_div = DIV_ROUND_UP(dsi_fclk, lp_clk * 2);\r\ndssdev->clocks.dsi.regn = cinfo.regn;\r\ndssdev->clocks.dsi.regm = cinfo.regm;\r\ndssdev->clocks.dsi.regm_dispc = cinfo.regm_dispc;\r\ndssdev->clocks.dsi.regm_dsi = cinfo.regm_dsi;\r\ndssdev->clocks.dsi.lp_clk_div = lp_clk_div;\r\ndssdev->clocks.dispc.channel.lck_div = dispc_cinfo.lck_div;\r\ndssdev->clocks.dispc.channel.pck_div = dispc_cinfo.pck_div;\r\ndssdev->clocks.dispc.dispc_fclk_src = OMAP_DSS_CLK_SRC_FCK;\r\ndssdev->clocks.dispc.channel.lcd_clk_src =\r\ndsi->module_id == 0 ?\r\nOMAP_DSS_CLK_SRC_DSI_PLL_HSDIV_DISPC :\r\nOMAP_DSS_CLK_SRC_DSI2_PLL_HSDIV_DISPC;\r\ndssdev->clocks.dsi.dsi_fclk_src =\r\ndsi->module_id == 0 ?\r\nOMAP_DSS_CLK_SRC_DSI_PLL_HSDIV_DSI :\r\nOMAP_DSS_CLK_SRC_DSI2_PLL_HSDIV_DSI;\r\nmutex_unlock(&dsi->lock);\r\nreturn 0;\r\nerr:\r\nmutex_unlock(&dsi->lock);\r\nreturn r;\r\n}\r\nint dsi_enable_video_output(struct omap_dss_device *dssdev, int channel)\r\n{\r\nstruct platform_device *dsidev = dsi_get_dsidev_from_dssdev(dssdev);\r\nstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\r\nstruct omap_overlay_manager *mgr = dssdev->output->manager;\r\nint bpp = dsi_get_pixel_size(dsi->pix_fmt);\r\nu8 data_type;\r\nu16 word_count;\r\nint r;\r\nif (dsi->mode == OMAP_DSS_DSI_VIDEO_MODE) {\r\nswitch (dsi->pix_fmt) {\r\ncase OMAP_DSS_DSI_FMT_RGB888:\r\ndata_type = MIPI_DSI_PACKED_PIXEL_STREAM_24;\r\nbreak;\r\ncase OMAP_DSS_DSI_FMT_RGB666:\r\ndata_type = MIPI_DSI_PIXEL_STREAM_3BYTE_18;\r\nbreak;\r\ncase OMAP_DSS_DSI_FMT_RGB666_PACKED:\r\ndata_type = MIPI_DSI_PACKED_PIXEL_STREAM_18;\r\nbreak;\r\ncase OMAP_DSS_DSI_FMT_RGB565:\r\ndata_type = MIPI_DSI_PACKED_PIXEL_STREAM_16;\r\nbreak;\r\ndefault:\r\nBUG();\r\nreturn -EINVAL;\r\n};\r\ndsi_if_enable(dsidev, false);\r\ndsi_vc_enable(dsidev, channel, false);\r\nREG_FLD_MOD(dsidev, DSI_VC_CTRL(channel), 1, 4, 4);\r\nword_count = DIV_ROUND_UP(dsi->timings.x_res * bpp, 8);\r\ndsi_vc_write_long_header(dsidev, channel, data_type,\r\nword_count, 0);\r\ndsi_vc_enable(dsidev, channel, true);\r\ndsi_if_enable(dsidev, true);\r\n}\r\nr = dss_mgr_enable(mgr);\r\nif (r) {\r\nif (dsi->mode == OMAP_DSS_DSI_VIDEO_MODE) {\r\ndsi_if_enable(dsidev, false);\r\ndsi_vc_enable(dsidev, channel, false);\r\n}\r\nreturn r;\r\n}\r\nreturn 0;\r\n}\r\nvoid dsi_disable_video_output(struct omap_dss_device *dssdev, int channel)\r\n{\r\nstruct platform_device *dsidev = dsi_get_dsidev_from_dssdev(dssdev);\r\nstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\r\nstruct omap_overlay_manager *mgr = dssdev->output->manager;\r\nif (dsi->mode == OMAP_DSS_DSI_VIDEO_MODE) {\r\ndsi_if_enable(dsidev, false);\r\ndsi_vc_enable(dsidev, channel, false);\r\nREG_FLD_MOD(dsidev, DSI_VC_CTRL(channel), 0, 4, 4);\r\ndsi_vc_enable(dsidev, channel, true);\r\ndsi_if_enable(dsidev, true);\r\n}\r\ndss_mgr_disable(mgr);\r\n}\r\nstatic void dsi_update_screen_dispc(struct omap_dss_device *dssdev)\r\n{\r\nstruct platform_device *dsidev = dsi_get_dsidev_from_dssdev(dssdev);\r\nstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\r\nstruct omap_overlay_manager *mgr = dssdev->output->manager;\r\nunsigned bytespp;\r\nunsigned bytespl;\r\nunsigned bytespf;\r\nunsigned total_len;\r\nunsigned packet_payload;\r\nunsigned packet_len;\r\nu32 l;\r\nint r;\r\nconst unsigned channel = dsi->update_channel;\r\nconst unsigned line_buf_size = dsi_get_line_buf_size(dsidev);\r\nu16 w = dsi->timings.x_res;\r\nu16 h = dsi->timings.y_res;\r\nDSSDBG("dsi_update_screen_dispc(%dx%d)\n", w, h);\r\ndsi_vc_config_source(dsidev, channel, DSI_VC_SOURCE_VP);\r\nbytespp = dsi_get_pixel_size(dsi->pix_fmt) / 8;\r\nbytespl = w * bytespp;\r\nbytespf = bytespl * h;\r\nif (bytespf < line_buf_size)\r\npacket_payload = bytespf;\r\nelse\r\npacket_payload = (line_buf_size) / bytespl * bytespl;\r\npacket_len = packet_payload + 1;\r\ntotal_len = (bytespf / packet_payload) * packet_len;\r\nif (bytespf % packet_payload)\r\ntotal_len += (bytespf % packet_payload) + 1;\r\nl = FLD_VAL(total_len, 23, 0);\r\ndsi_write_reg(dsidev, DSI_VC_TE(channel), l);\r\ndsi_vc_write_long_header(dsidev, channel, MIPI_DSI_DCS_LONG_WRITE,\r\npacket_len, 0);\r\nif (dsi->te_enabled)\r\nl = FLD_MOD(l, 1, 30, 30);\r\nelse\r\nl = FLD_MOD(l, 1, 31, 31);\r\ndsi_write_reg(dsidev, DSI_VC_TE(channel), l);\r\ndispc_disable_sidle();\r\ndsi_perf_mark_start(dsidev);\r\nr = schedule_delayed_work(&dsi->framedone_timeout_work,\r\nmsecs_to_jiffies(250));\r\nBUG_ON(r == 0);\r\ndss_mgr_set_timings(mgr, &dsi->timings);\r\ndss_mgr_start_update(mgr);\r\nif (dsi->te_enabled) {\r\nREG_FLD_MOD(dsidev, DSI_TIMING2, 0, 15, 15);\r\ndsi_vc_send_bta(dsidev, channel);\r\n#ifdef DSI_CATCH_MISSING_TE\r\nmod_timer(&dsi->te_timer, jiffies + msecs_to_jiffies(250));\r\n#endif\r\n}\r\n}\r\nstatic void dsi_te_timeout(unsigned long arg)\r\n{\r\nDSSERR("TE not received for 250ms!\n");\r\n}\r\nstatic void dsi_handle_framedone(struct platform_device *dsidev, int error)\r\n{\r\nstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\r\ndispc_enable_sidle();\r\nif (dsi->te_enabled) {\r\nREG_FLD_MOD(dsidev, DSI_TIMING2, 1, 15, 15);\r\n}\r\ndsi->framedone_callback(error, dsi->framedone_data);\r\nif (!error)\r\ndsi_perf_show(dsidev, "DISPC");\r\n}\r\nstatic void dsi_framedone_timeout_work_callback(struct work_struct *work)\r\n{\r\nstruct dsi_data *dsi = container_of(work, struct dsi_data,\r\nframedone_timeout_work.work);\r\nDSSERR("Framedone not received for 250ms!\n");\r\ndsi_handle_framedone(dsi->pdev, -ETIMEDOUT);\r\n}\r\nstatic void dsi_framedone_irq_callback(void *data)\r\n{\r\nstruct platform_device *dsidev = (struct platform_device *) data;\r\nstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\r\ncancel_delayed_work(&dsi->framedone_timeout_work);\r\ndsi_handle_framedone(dsidev, 0);\r\n}\r\nint omap_dsi_update(struct omap_dss_device *dssdev, int channel,\r\nvoid (*callback)(int, void *), void *data)\r\n{\r\nstruct platform_device *dsidev = dsi_get_dsidev_from_dssdev(dssdev);\r\nstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\r\nu16 dw, dh;\r\ndsi_perf_mark_setup(dsidev);\r\ndsi->update_channel = channel;\r\ndsi->framedone_callback = callback;\r\ndsi->framedone_data = data;\r\ndw = dsi->timings.x_res;\r\ndh = dsi->timings.y_res;\r\n#ifdef DEBUG\r\ndsi->update_bytes = dw * dh *\r\ndsi_get_pixel_size(dsi->pix_fmt) / 8;\r\n#endif\r\ndsi_update_screen_dispc(dssdev);\r\nreturn 0;\r\n}\r\nstatic int dsi_configure_dispc_clocks(struct omap_dss_device *dssdev)\r\n{\r\nstruct platform_device *dsidev = dsi_get_dsidev_from_dssdev(dssdev);\r\nstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\r\nstruct dispc_clock_info dispc_cinfo;\r\nint r;\r\nunsigned long long fck;\r\nfck = dsi_get_pll_hsdiv_dispc_rate(dsidev);\r\ndispc_cinfo.lck_div = dssdev->clocks.dispc.channel.lck_div;\r\ndispc_cinfo.pck_div = dssdev->clocks.dispc.channel.pck_div;\r\nr = dispc_calc_clock_rates(fck, &dispc_cinfo);\r\nif (r) {\r\nDSSERR("Failed to calc dispc clocks\n");\r\nreturn r;\r\n}\r\ndsi->mgr_config.clock_info = dispc_cinfo;\r\nreturn 0;\r\n}\r\nstatic int dsi_display_init_dispc(struct omap_dss_device *dssdev)\r\n{\r\nstruct platform_device *dsidev = dsi_get_dsidev_from_dssdev(dssdev);\r\nstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\r\nstruct omap_overlay_manager *mgr = dssdev->output->manager;\r\nint r;\r\nif (dsi->mode == OMAP_DSS_DSI_CMD_MODE) {\r\ndsi->timings.hsw = 1;\r\ndsi->timings.hfp = 1;\r\ndsi->timings.hbp = 1;\r\ndsi->timings.vsw = 1;\r\ndsi->timings.vfp = 0;\r\ndsi->timings.vbp = 0;\r\nr = dss_mgr_register_framedone_handler(mgr,\r\ndsi_framedone_irq_callback, dsidev);\r\nif (r) {\r\nDSSERR("can't register FRAMEDONE handler\n");\r\ngoto err;\r\n}\r\ndsi->mgr_config.stallmode = true;\r\ndsi->mgr_config.fifohandcheck = true;\r\n} else {\r\ndsi->mgr_config.stallmode = false;\r\ndsi->mgr_config.fifohandcheck = false;\r\n}\r\ndsi->timings.interlace = false;\r\ndsi->timings.hsync_level = OMAPDSS_SIG_ACTIVE_HIGH;\r\ndsi->timings.vsync_level = OMAPDSS_SIG_ACTIVE_HIGH;\r\ndsi->timings.data_pclk_edge = OMAPDSS_DRIVE_SIG_RISING_EDGE;\r\ndsi->timings.de_level = OMAPDSS_SIG_ACTIVE_HIGH;\r\ndsi->timings.sync_pclk_edge = OMAPDSS_DRIVE_SIG_OPPOSITE_EDGES;\r\ndss_mgr_set_timings(mgr, &dsi->timings);\r\nr = dsi_configure_dispc_clocks(dssdev);\r\nif (r)\r\ngoto err1;\r\ndsi->mgr_config.io_pad_mode = DSS_IO_PAD_MODE_BYPASS;\r\ndsi->mgr_config.video_port_width =\r\ndsi_get_pixel_size(dsi->pix_fmt);\r\ndsi->mgr_config.lcden_sig_polarity = 0;\r\ndss_mgr_set_lcd_config(mgr, &dsi->mgr_config);\r\nreturn 0;\r\nerr1:\r\nif (dsi->mode == OMAP_DSS_DSI_CMD_MODE)\r\ndss_mgr_unregister_framedone_handler(mgr,\r\ndsi_framedone_irq_callback, dsidev);\r\nerr:\r\nreturn r;\r\n}\r\nstatic void dsi_display_uninit_dispc(struct omap_dss_device *dssdev)\r\n{\r\nstruct platform_device *dsidev = dsi_get_dsidev_from_dssdev(dssdev);\r\nstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\r\nstruct omap_overlay_manager *mgr = dssdev->output->manager;\r\nif (dsi->mode == OMAP_DSS_DSI_CMD_MODE)\r\ndss_mgr_unregister_framedone_handler(mgr,\r\ndsi_framedone_irq_callback, dsidev);\r\n}\r\nstatic int dsi_configure_dsi_clocks(struct omap_dss_device *dssdev)\r\n{\r\nstruct platform_device *dsidev = dsi_get_dsidev_from_dssdev(dssdev);\r\nstruct dsi_clock_info cinfo;\r\nint r;\r\ncinfo.regn = dssdev->clocks.dsi.regn;\r\ncinfo.regm = dssdev->clocks.dsi.regm;\r\ncinfo.regm_dispc = dssdev->clocks.dsi.regm_dispc;\r\ncinfo.regm_dsi = dssdev->clocks.dsi.regm_dsi;\r\nr = dsi_calc_clock_rates(dsidev, &cinfo);\r\nif (r) {\r\nDSSERR("Failed to calc dsi clocks\n");\r\nreturn r;\r\n}\r\nr = dsi_pll_set_clock_div(dsidev, &cinfo);\r\nif (r) {\r\nDSSERR("Failed to set dsi clocks\n");\r\nreturn r;\r\n}\r\nreturn 0;\r\n}\r\nstatic int dsi_display_init_dsi(struct omap_dss_device *dssdev)\r\n{\r\nstruct platform_device *dsidev = dsi_get_dsidev_from_dssdev(dssdev);\r\nstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\r\nstruct omap_overlay_manager *mgr = dssdev->output->manager;\r\nint r;\r\nr = dsi_pll_init(dsidev, true, true);\r\nif (r)\r\ngoto err0;\r\nr = dsi_configure_dsi_clocks(dssdev);\r\nif (r)\r\ngoto err1;\r\ndss_select_dsi_clk_source(dsi->module_id, dssdev->clocks.dsi.dsi_fclk_src);\r\ndss_select_lcd_clk_source(mgr->id,\r\ndssdev->clocks.dispc.channel.lcd_clk_src);\r\nDSSDBG("PLL OK\n");\r\nr = dsi_cio_init(dsidev);\r\nif (r)\r\ngoto err2;\r\n_dsi_print_reset_status(dsidev);\r\ndsi_proto_timings(dsidev);\r\ndsi_set_lp_clk_divisor(dssdev);\r\nif (1)\r\n_dsi_print_reset_status(dsidev);\r\nr = dsi_proto_config(dssdev);\r\nif (r)\r\ngoto err3;\r\ndsi_vc_enable(dsidev, 0, 1);\r\ndsi_vc_enable(dsidev, 1, 1);\r\ndsi_vc_enable(dsidev, 2, 1);\r\ndsi_vc_enable(dsidev, 3, 1);\r\ndsi_if_enable(dsidev, 1);\r\ndsi_force_tx_stop_mode_io(dsidev);\r\nreturn 0;\r\nerr3:\r\ndsi_cio_uninit(dsidev);\r\nerr2:\r\ndss_select_dsi_clk_source(dsi->module_id, OMAP_DSS_CLK_SRC_FCK);\r\ndss_select_lcd_clk_source(mgr->id, OMAP_DSS_CLK_SRC_FCK);\r\nerr1:\r\ndsi_pll_uninit(dsidev, true);\r\nerr0:\r\nreturn r;\r\n}\r\nstatic void dsi_display_uninit_dsi(struct omap_dss_device *dssdev,\r\nbool disconnect_lanes, bool enter_ulps)\r\n{\r\nstruct platform_device *dsidev = dsi_get_dsidev_from_dssdev(dssdev);\r\nstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\r\nstruct omap_overlay_manager *mgr = dssdev->output->manager;\r\nif (enter_ulps && !dsi->ulps_enabled)\r\ndsi_enter_ulps(dsidev);\r\ndsi_if_enable(dsidev, 0);\r\ndsi_vc_enable(dsidev, 0, 0);\r\ndsi_vc_enable(dsidev, 1, 0);\r\ndsi_vc_enable(dsidev, 2, 0);\r\ndsi_vc_enable(dsidev, 3, 0);\r\ndss_select_dsi_clk_source(dsi->module_id, OMAP_DSS_CLK_SRC_FCK);\r\ndss_select_lcd_clk_source(mgr->id, OMAP_DSS_CLK_SRC_FCK);\r\ndsi_cio_uninit(dsidev);\r\ndsi_pll_uninit(dsidev, disconnect_lanes);\r\n}\r\nint omapdss_dsi_display_enable(struct omap_dss_device *dssdev)\r\n{\r\nstruct platform_device *dsidev = dsi_get_dsidev_from_dssdev(dssdev);\r\nstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\r\nstruct omap_dss_output *out = dssdev->output;\r\nint r = 0;\r\nDSSDBG("dsi_display_enable\n");\r\nWARN_ON(!dsi_bus_is_locked(dsidev));\r\nmutex_lock(&dsi->lock);\r\nif (out == NULL || out->manager == NULL) {\r\nDSSERR("failed to enable display: no output/manager\n");\r\nr = -ENODEV;\r\ngoto err_start_dev;\r\n}\r\nr = omap_dss_start_device(dssdev);\r\nif (r) {\r\nDSSERR("failed to start device\n");\r\ngoto err_start_dev;\r\n}\r\nr = dsi_runtime_get(dsidev);\r\nif (r)\r\ngoto err_get_dsi;\r\ndsi_enable_pll_clock(dsidev, 1);\r\n_dsi_initialize_irq(dsidev);\r\nr = dsi_display_init_dispc(dssdev);\r\nif (r)\r\ngoto err_init_dispc;\r\nr = dsi_display_init_dsi(dssdev);\r\nif (r)\r\ngoto err_init_dsi;\r\nmutex_unlock(&dsi->lock);\r\nreturn 0;\r\nerr_init_dsi:\r\ndsi_display_uninit_dispc(dssdev);\r\nerr_init_dispc:\r\ndsi_enable_pll_clock(dsidev, 0);\r\ndsi_runtime_put(dsidev);\r\nerr_get_dsi:\r\nomap_dss_stop_device(dssdev);\r\nerr_start_dev:\r\nmutex_unlock(&dsi->lock);\r\nDSSDBG("dsi_display_enable FAILED\n");\r\nreturn r;\r\n}\r\nvoid omapdss_dsi_display_disable(struct omap_dss_device *dssdev,\r\nbool disconnect_lanes, bool enter_ulps)\r\n{\r\nstruct platform_device *dsidev = dsi_get_dsidev_from_dssdev(dssdev);\r\nstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\r\nDSSDBG("dsi_display_disable\n");\r\nWARN_ON(!dsi_bus_is_locked(dsidev));\r\nmutex_lock(&dsi->lock);\r\ndsi_sync_vc(dsidev, 0);\r\ndsi_sync_vc(dsidev, 1);\r\ndsi_sync_vc(dsidev, 2);\r\ndsi_sync_vc(dsidev, 3);\r\ndsi_display_uninit_dispc(dssdev);\r\ndsi_display_uninit_dsi(dssdev, disconnect_lanes, enter_ulps);\r\ndsi_runtime_put(dsidev);\r\ndsi_enable_pll_clock(dsidev, 0);\r\nomap_dss_stop_device(dssdev);\r\nmutex_unlock(&dsi->lock);\r\n}\r\nint omapdss_dsi_enable_te(struct omap_dss_device *dssdev, bool enable)\r\n{\r\nstruct platform_device *dsidev = dsi_get_dsidev_from_dssdev(dssdev);\r\nstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\r\ndsi->te_enabled = enable;\r\nreturn 0;\r\n}\r\nvoid omapdss_dsi_set_timings(struct omap_dss_device *dssdev,\r\nstruct omap_video_timings *timings)\r\n{\r\nstruct platform_device *dsidev = dsi_get_dsidev_from_dssdev(dssdev);\r\nstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\r\nmutex_lock(&dsi->lock);\r\ndsi->timings = *timings;\r\nmutex_unlock(&dsi->lock);\r\n}\r\nvoid omapdss_dsi_set_size(struct omap_dss_device *dssdev, u16 w, u16 h)\r\n{\r\nstruct platform_device *dsidev = dsi_get_dsidev_from_dssdev(dssdev);\r\nstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\r\nmutex_lock(&dsi->lock);\r\ndsi->timings.x_res = w;\r\ndsi->timings.y_res = h;\r\nmutex_unlock(&dsi->lock);\r\n}\r\nvoid omapdss_dsi_set_pixel_format(struct omap_dss_device *dssdev,\r\nenum omap_dss_dsi_pixel_format fmt)\r\n{\r\nstruct platform_device *dsidev = dsi_get_dsidev_from_dssdev(dssdev);\r\nstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\r\nmutex_lock(&dsi->lock);\r\ndsi->pix_fmt = fmt;\r\nmutex_unlock(&dsi->lock);\r\n}\r\nvoid omapdss_dsi_set_operation_mode(struct omap_dss_device *dssdev,\r\nenum omap_dss_dsi_mode mode)\r\n{\r\nstruct platform_device *dsidev = dsi_get_dsidev_from_dssdev(dssdev);\r\nstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\r\nmutex_lock(&dsi->lock);\r\ndsi->mode = mode;\r\nmutex_unlock(&dsi->lock);\r\n}\r\nvoid omapdss_dsi_set_videomode_timings(struct omap_dss_device *dssdev,\r\nstruct omap_dss_dsi_videomode_timings *timings)\r\n{\r\nstruct platform_device *dsidev = dsi_get_dsidev_from_dssdev(dssdev);\r\nstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\r\nmutex_lock(&dsi->lock);\r\ndsi->vm_timings = *timings;\r\nmutex_unlock(&dsi->lock);\r\n}\r\nstatic int __init dsi_init_display(struct omap_dss_device *dssdev)\r\n{\r\nstruct platform_device *dsidev =\r\ndsi_get_dsidev_from_id(dssdev->phy.dsi.module);\r\nstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\r\nDSSDBG("DSI init\n");\r\nif (dsi->vdds_dsi_reg == NULL) {\r\nstruct regulator *vdds_dsi;\r\nvdds_dsi = regulator_get(&dsi->pdev->dev, "vdds_dsi");\r\nif (IS_ERR(vdds_dsi))\r\nvdds_dsi = regulator_get(&dsi->pdev->dev, "VCXIO");\r\nif (IS_ERR(vdds_dsi)) {\r\nDSSERR("can't get VDDS_DSI regulator\n");\r\nreturn PTR_ERR(vdds_dsi);\r\n}\r\ndsi->vdds_dsi_reg = vdds_dsi;\r\n}\r\nreturn 0;\r\n}\r\nint omap_dsi_request_vc(struct omap_dss_device *dssdev, int *channel)\r\n{\r\nstruct platform_device *dsidev = dsi_get_dsidev_from_dssdev(dssdev);\r\nstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(dsi->vc); i++) {\r\nif (!dsi->vc[i].dssdev) {\r\ndsi->vc[i].dssdev = dssdev;\r\n*channel = i;\r\nreturn 0;\r\n}\r\n}\r\nDSSERR("cannot get VC for display %s", dssdev->name);\r\nreturn -ENOSPC;\r\n}\r\nint omap_dsi_set_vc_id(struct omap_dss_device *dssdev, int channel, int vc_id)\r\n{\r\nstruct platform_device *dsidev = dsi_get_dsidev_from_dssdev(dssdev);\r\nstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\r\nif (vc_id < 0 || vc_id > 3) {\r\nDSSERR("VC ID out of range\n");\r\nreturn -EINVAL;\r\n}\r\nif (channel < 0 || channel > 3) {\r\nDSSERR("Virtual Channel out of range\n");\r\nreturn -EINVAL;\r\n}\r\nif (dsi->vc[channel].dssdev != dssdev) {\r\nDSSERR("Virtual Channel not allocated to display %s\n",\r\ndssdev->name);\r\nreturn -EINVAL;\r\n}\r\ndsi->vc[channel].vc_id = vc_id;\r\nreturn 0;\r\n}\r\nvoid omap_dsi_release_vc(struct omap_dss_device *dssdev, int channel)\r\n{\r\nstruct platform_device *dsidev = dsi_get_dsidev_from_dssdev(dssdev);\r\nstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\r\nif ((channel >= 0 && channel <= 3) &&\r\ndsi->vc[channel].dssdev == dssdev) {\r\ndsi->vc[channel].dssdev = NULL;\r\ndsi->vc[channel].vc_id = 0;\r\n}\r\n}\r\nvoid dsi_wait_pll_hsdiv_dispc_active(struct platform_device *dsidev)\r\n{\r\nif (wait_for_bit_change(dsidev, DSI_PLL_STATUS, 7, 1) != 1)\r\nDSSERR("%s (%s) not active\n",\r\ndss_get_generic_clk_source_name(OMAP_DSS_CLK_SRC_DSI_PLL_HSDIV_DISPC),\r\ndss_feat_get_clk_source_name(OMAP_DSS_CLK_SRC_DSI_PLL_HSDIV_DISPC));\r\n}\r\nvoid dsi_wait_pll_hsdiv_dsi_active(struct platform_device *dsidev)\r\n{\r\nif (wait_for_bit_change(dsidev, DSI_PLL_STATUS, 8, 1) != 1)\r\nDSSERR("%s (%s) not active\n",\r\ndss_get_generic_clk_source_name(OMAP_DSS_CLK_SRC_DSI_PLL_HSDIV_DSI),\r\ndss_feat_get_clk_source_name(OMAP_DSS_CLK_SRC_DSI_PLL_HSDIV_DSI));\r\n}\r\nstatic void dsi_calc_clock_param_ranges(struct platform_device *dsidev)\r\n{\r\nstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\r\ndsi->regn_max = dss_feat_get_param_max(FEAT_PARAM_DSIPLL_REGN);\r\ndsi->regm_max = dss_feat_get_param_max(FEAT_PARAM_DSIPLL_REGM);\r\ndsi->regm_dispc_max =\r\ndss_feat_get_param_max(FEAT_PARAM_DSIPLL_REGM_DISPC);\r\ndsi->regm_dsi_max = dss_feat_get_param_max(FEAT_PARAM_DSIPLL_REGM_DSI);\r\ndsi->fint_min = dss_feat_get_param_min(FEAT_PARAM_DSIPLL_FINT);\r\ndsi->fint_max = dss_feat_get_param_max(FEAT_PARAM_DSIPLL_FINT);\r\ndsi->lpdiv_max = dss_feat_get_param_max(FEAT_PARAM_DSIPLL_LPDIV);\r\n}\r\nstatic int dsi_get_clocks(struct platform_device *dsidev)\r\n{\r\nstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\r\nstruct clk *clk;\r\nclk = clk_get(&dsidev->dev, "fck");\r\nif (IS_ERR(clk)) {\r\nDSSERR("can't get fck\n");\r\nreturn PTR_ERR(clk);\r\n}\r\ndsi->dss_clk = clk;\r\nclk = clk_get(&dsidev->dev, "sys_clk");\r\nif (IS_ERR(clk)) {\r\nDSSERR("can't get sys_clk\n");\r\nclk_put(dsi->dss_clk);\r\ndsi->dss_clk = NULL;\r\nreturn PTR_ERR(clk);\r\n}\r\ndsi->sys_clk = clk;\r\nreturn 0;\r\n}\r\nstatic void dsi_put_clocks(struct platform_device *dsidev)\r\n{\r\nstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\r\nif (dsi->dss_clk)\r\nclk_put(dsi->dss_clk);\r\nif (dsi->sys_clk)\r\nclk_put(dsi->sys_clk);\r\n}\r\nstatic struct omap_dss_device * __init dsi_find_dssdev(struct platform_device *pdev)\r\n{\r\nstruct omap_dss_board_info *pdata = pdev->dev.platform_data;\r\nstruct dsi_data *dsi = dsi_get_dsidrv_data(pdev);\r\nconst char *def_disp_name = omapdss_get_default_display_name();\r\nstruct omap_dss_device *def_dssdev;\r\nint i;\r\ndef_dssdev = NULL;\r\nfor (i = 0; i < pdata->num_devices; ++i) {\r\nstruct omap_dss_device *dssdev = pdata->devices[i];\r\nif (dssdev->type != OMAP_DISPLAY_TYPE_DSI)\r\ncontinue;\r\nif (dssdev->phy.dsi.module != dsi->module_id)\r\ncontinue;\r\nif (def_dssdev == NULL)\r\ndef_dssdev = dssdev;\r\nif (def_disp_name != NULL &&\r\nstrcmp(dssdev->name, def_disp_name) == 0) {\r\ndef_dssdev = dssdev;\r\nbreak;\r\n}\r\n}\r\nreturn def_dssdev;\r\n}\r\nstatic void __init dsi_probe_pdata(struct platform_device *dsidev)\r\n{\r\nstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\r\nstruct omap_dss_device *plat_dssdev;\r\nstruct omap_dss_device *dssdev;\r\nint r;\r\nplat_dssdev = dsi_find_dssdev(dsidev);\r\nif (!plat_dssdev)\r\nreturn;\r\ndssdev = dss_alloc_and_init_device(&dsidev->dev);\r\nif (!dssdev)\r\nreturn;\r\ndss_copy_device_pdata(dssdev, plat_dssdev);\r\nr = dsi_init_display(dssdev);\r\nif (r) {\r\nDSSERR("device %s init failed: %d\n", dssdev->name, r);\r\ndss_put_device(dssdev);\r\nreturn;\r\n}\r\nr = omapdss_output_set_device(&dsi->output, dssdev);\r\nif (r) {\r\nDSSERR("failed to connect output to new device: %s\n",\r\ndssdev->name);\r\ndss_put_device(dssdev);\r\nreturn;\r\n}\r\nr = dss_add_device(dssdev);\r\nif (r) {\r\nDSSERR("device %s register failed: %d\n", dssdev->name, r);\r\nomapdss_output_unset_device(&dsi->output);\r\ndss_put_device(dssdev);\r\nreturn;\r\n}\r\n}\r\nstatic void __init dsi_init_output(struct platform_device *dsidev)\r\n{\r\nstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\r\nstruct omap_dss_output *out = &dsi->output;\r\nout->pdev = dsidev;\r\nout->id = dsi->module_id == 0 ?\r\nOMAP_DSS_OUTPUT_DSI1 : OMAP_DSS_OUTPUT_DSI2;\r\nout->type = OMAP_DISPLAY_TYPE_DSI;\r\ndss_register_output(out);\r\n}\r\nstatic void __exit dsi_uninit_output(struct platform_device *dsidev)\r\n{\r\nstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\r\nstruct omap_dss_output *out = &dsi->output;\r\ndss_unregister_output(out);\r\n}\r\nstatic int __init omap_dsihw_probe(struct platform_device *dsidev)\r\n{\r\nu32 rev;\r\nint r, i;\r\nstruct resource *dsi_mem;\r\nstruct dsi_data *dsi;\r\ndsi = devm_kzalloc(&dsidev->dev, sizeof(*dsi), GFP_KERNEL);\r\nif (!dsi)\r\nreturn -ENOMEM;\r\ndsi->module_id = dsidev->id;\r\ndsi->pdev = dsidev;\r\ndev_set_drvdata(&dsidev->dev, dsi);\r\nspin_lock_init(&dsi->irq_lock);\r\nspin_lock_init(&dsi->errors_lock);\r\ndsi->errors = 0;\r\n#ifdef CONFIG_OMAP2_DSS_COLLECT_IRQ_STATS\r\nspin_lock_init(&dsi->irq_stats_lock);\r\ndsi->irq_stats.last_reset = jiffies;\r\n#endif\r\nmutex_init(&dsi->lock);\r\nsema_init(&dsi->bus_lock, 1);\r\nINIT_DEFERRABLE_WORK(&dsi->framedone_timeout_work,\r\ndsi_framedone_timeout_work_callback);\r\n#ifdef DSI_CATCH_MISSING_TE\r\ninit_timer(&dsi->te_timer);\r\ndsi->te_timer.function = dsi_te_timeout;\r\ndsi->te_timer.data = 0;\r\n#endif\r\ndsi_mem = platform_get_resource(dsi->pdev, IORESOURCE_MEM, 0);\r\nif (!dsi_mem) {\r\nDSSERR("can't get IORESOURCE_MEM DSI\n");\r\nreturn -EINVAL;\r\n}\r\ndsi->base = devm_ioremap(&dsidev->dev, dsi_mem->start,\r\nresource_size(dsi_mem));\r\nif (!dsi->base) {\r\nDSSERR("can't ioremap DSI\n");\r\nreturn -ENOMEM;\r\n}\r\ndsi->irq = platform_get_irq(dsi->pdev, 0);\r\nif (dsi->irq < 0) {\r\nDSSERR("platform_get_irq failed\n");\r\nreturn -ENODEV;\r\n}\r\nr = devm_request_irq(&dsidev->dev, dsi->irq, omap_dsi_irq_handler,\r\nIRQF_SHARED, dev_name(&dsidev->dev), dsi->pdev);\r\nif (r < 0) {\r\nDSSERR("request_irq failed\n");\r\nreturn r;\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(dsi->vc); i++) {\r\ndsi->vc[i].source = DSI_VC_SOURCE_L4;\r\ndsi->vc[i].dssdev = NULL;\r\ndsi->vc[i].vc_id = 0;\r\n}\r\ndsi_calc_clock_param_ranges(dsidev);\r\nr = dsi_get_clocks(dsidev);\r\nif (r)\r\nreturn r;\r\npm_runtime_enable(&dsidev->dev);\r\nr = dsi_runtime_get(dsidev);\r\nif (r)\r\ngoto err_runtime_get;\r\nrev = dsi_read_reg(dsidev, DSI_REVISION);\r\ndev_dbg(&dsidev->dev, "OMAP DSI rev %d.%d\n",\r\nFLD_GET(rev, 7, 4), FLD_GET(rev, 3, 0));\r\nif (dss_has_feature(FEAT_DSI_GNQ))\r\ndsi->num_lanes_supported = 1 + REG_GET(dsidev, DSI_GNQ, 11, 9);\r\nelse\r\ndsi->num_lanes_supported = 3;\r\ndsi_init_output(dsidev);\r\ndsi_probe_pdata(dsidev);\r\ndsi_runtime_put(dsidev);\r\nif (dsi->module_id == 0)\r\ndss_debugfs_create_file("dsi1_regs", dsi1_dump_regs);\r\nelse if (dsi->module_id == 1)\r\ndss_debugfs_create_file("dsi2_regs", dsi2_dump_regs);\r\n#ifdef CONFIG_OMAP2_DSS_COLLECT_IRQ_STATS\r\nif (dsi->module_id == 0)\r\ndss_debugfs_create_file("dsi1_irqs", dsi1_dump_irqs);\r\nelse if (dsi->module_id == 1)\r\ndss_debugfs_create_file("dsi2_irqs", dsi2_dump_irqs);\r\n#endif\r\nreturn 0;\r\nerr_runtime_get:\r\npm_runtime_disable(&dsidev->dev);\r\ndsi_put_clocks(dsidev);\r\nreturn r;\r\n}\r\nstatic int __exit omap_dsihw_remove(struct platform_device *dsidev)\r\n{\r\nstruct dsi_data *dsi = dsi_get_dsidrv_data(dsidev);\r\nWARN_ON(dsi->scp_clk_refcount > 0);\r\ndss_unregister_child_devices(&dsidev->dev);\r\ndsi_uninit_output(dsidev);\r\npm_runtime_disable(&dsidev->dev);\r\ndsi_put_clocks(dsidev);\r\nif (dsi->vdds_dsi_reg != NULL) {\r\nif (dsi->vdds_dsi_enabled) {\r\nregulator_disable(dsi->vdds_dsi_reg);\r\ndsi->vdds_dsi_enabled = false;\r\n}\r\nregulator_put(dsi->vdds_dsi_reg);\r\ndsi->vdds_dsi_reg = NULL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int dsi_runtime_suspend(struct device *dev)\r\n{\r\ndispc_runtime_put();\r\nreturn 0;\r\n}\r\nstatic int dsi_runtime_resume(struct device *dev)\r\n{\r\nint r;\r\nr = dispc_runtime_get();\r\nif (r)\r\nreturn r;\r\nreturn 0;\r\n}\r\nint __init dsi_init_platform_driver(void)\r\n{\r\nreturn platform_driver_probe(&omap_dsihw_driver, omap_dsihw_probe);\r\n}\r\nvoid __exit dsi_uninit_platform_driver(void)\r\n{\r\nplatform_driver_unregister(&omap_dsihw_driver);\r\n}
