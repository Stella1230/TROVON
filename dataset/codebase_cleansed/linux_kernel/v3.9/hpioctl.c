static void hpi_send_recv_f(struct hpi_message *phm, struct hpi_response *phr,\r\nstruct file *file)\r\n{\r\nif ((phm->adapter_index >= HPI_MAX_ADAPTERS)\r\n&& (phm->object != HPI_OBJ_SUBSYSTEM))\r\nphr->error = HPI_ERROR_INVALID_OBJ_INDEX;\r\nelse\r\nhpi_send_recv_ex(phm, phr, file);\r\n}\r\nvoid hpi_send_recv(struct hpi_message *phm, struct hpi_response *phr)\r\n{\r\nhpi_send_recv_f(phm, phr, HOWNER_KERNEL);\r\n}\r\nint asihpi_hpi_release(struct file *file)\r\n{\r\nstruct hpi_message hm;\r\nstruct hpi_response hr;\r\nhpi_init_message_response(&hm, &hr, HPI_OBJ_SUBSYSTEM,\r\nHPI_SUBSYS_CLOSE);\r\nhpi_send_recv_ex(&hm, &hr, file);\r\nreturn 0;\r\n}\r\nlong asihpi_hpi_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\r\n{\r\nstruct hpi_ioctl_linux __user *phpi_ioctl_data;\r\nvoid __user *puhm;\r\nvoid __user *puhr;\r\nunion hpi_message_buffer_v1 *hm;\r\nunion hpi_response_buffer_v1 *hr;\r\nu16 res_max_size;\r\nu32 uncopied_bytes;\r\nint err = 0;\r\nif (cmd != HPI_IOCTL_LINUX)\r\nreturn -EINVAL;\r\nhm = kmalloc(sizeof(*hm), GFP_KERNEL);\r\nhr = kmalloc(sizeof(*hr), GFP_KERNEL);\r\nif (!hm || !hr) {\r\nerr = -ENOMEM;\r\ngoto out;\r\n}\r\nphpi_ioctl_data = (struct hpi_ioctl_linux __user *)arg;\r\nif (get_user(puhm, &phpi_ioctl_data->phm)\r\n|| get_user(puhr, &phpi_ioctl_data->phr)) {\r\nerr = -EFAULT;\r\ngoto out;\r\n}\r\nif (get_user(hm->h.size, (u16 __user *)puhm)) {\r\nerr = -EFAULT;\r\ngoto out;\r\n}\r\nif (hm->h.size > sizeof(*hm))\r\nhm->h.size = sizeof(*hm);\r\nuncopied_bytes = copy_from_user(hm, puhm, hm->h.size);\r\nif (uncopied_bytes) {\r\nHPI_DEBUG_LOG(ERROR, "uncopied bytes %d\n", uncopied_bytes);\r\nerr = -EFAULT;\r\ngoto out;\r\n}\r\nif (get_user(res_max_size, (u16 __user *)puhr)) {\r\nerr = -EFAULT;\r\ngoto out;\r\n}\r\nif (res_max_size < sizeof(struct hpi_response_header)) {\r\nHPI_DEBUG_LOG(WARNING, "small res size %d\n", res_max_size);\r\nerr = -EFAULT;\r\ngoto out;\r\n}\r\nswitch (hm->h.function) {\r\ncase HPI_SUBSYS_CREATE_ADAPTER:\r\ncase HPI_ADAPTER_DELETE:\r\nhr->h.size = sizeof(hr->h);\r\nhr->h.error = HPI_ERROR_INVALID_OPERATION;\r\nhr->h.function = hm->h.function;\r\nuncopied_bytes = copy_to_user(puhr, hr, hr->h.size);\r\nif (uncopied_bytes)\r\nerr = -EFAULT;\r\nelse\r\nerr = 0;\r\ngoto out;\r\n}\r\nhr->h.size = res_max_size;\r\nif (hm->h.object == HPI_OBJ_SUBSYSTEM) {\r\nhpi_send_recv_f(&hm->m0, &hr->r0, file);\r\n} else {\r\nu16 __user *ptr = NULL;\r\nu32 size = 0;\r\nint wrflag = -1;\r\nstruct hpi_adapter *pa = NULL;\r\nif (hm->h.adapter_index < ARRAY_SIZE(adapters))\r\npa = &adapters[hm->h.adapter_index];\r\nif (!pa || !pa->adapter || !pa->adapter->type) {\r\nhpi_init_response(&hr->r0, hm->h.object,\r\nhm->h.function, HPI_ERROR_BAD_ADAPTER_NUMBER);\r\nuncopied_bytes =\r\ncopy_to_user(puhr, hr, sizeof(hr->h));\r\nif (uncopied_bytes)\r\nerr = -EFAULT;\r\nelse\r\nerr = 0;\r\ngoto out;\r\n}\r\nif (mutex_lock_interruptible(&pa->mutex)) {\r\nerr = -EINTR;\r\ngoto out;\r\n}\r\nswitch (hm->h.function) {\r\ncase HPI_OSTREAM_WRITE:\r\ncase HPI_ISTREAM_READ:{\r\nptr = (u16 __user *)hm->m0.u.d.u.data.pb_data;\r\nsize = hm->m0.u.d.u.data.data_size;\r\nif (pa->buffer_size < size) {\r\nHPI_DEBUG_LOG(DEBUG,\r\n"Realloc adapter %d stream "\r\n"buffer from %zd to %d\n",\r\nhm->h.adapter_index,\r\npa->buffer_size, size);\r\nif (pa->p_buffer) {\r\npa->buffer_size = 0;\r\nvfree(pa->p_buffer);\r\n}\r\npa->p_buffer = vmalloc(size);\r\nif (pa->p_buffer)\r\npa->buffer_size = size;\r\nelse {\r\nHPI_DEBUG_LOG(ERROR,\r\n"HPI could not allocate "\r\n"stream buffer size %d\n",\r\nsize);\r\nmutex_unlock(&pa->mutex);\r\nerr = -EINVAL;\r\ngoto out;\r\n}\r\n}\r\nhm->m0.u.d.u.data.pb_data = pa->p_buffer;\r\nif (hm->h.function == HPI_ISTREAM_READ)\r\nwrflag = 1;\r\nelse\r\nwrflag = 0;\r\nbreak;\r\n}\r\ndefault:\r\nsize = 0;\r\nbreak;\r\n}\r\nif (size && (wrflag == 0)) {\r\nuncopied_bytes =\r\ncopy_from_user(pa->p_buffer, ptr, size);\r\nif (uncopied_bytes)\r\nHPI_DEBUG_LOG(WARNING,\r\n"Missed %d of %d "\r\n"bytes from user\n", uncopied_bytes,\r\nsize);\r\n}\r\nhpi_send_recv_f(&hm->m0, &hr->r0, file);\r\nif (size && (wrflag == 1)) {\r\nuncopied_bytes =\r\ncopy_to_user(ptr, pa->p_buffer, size);\r\nif (uncopied_bytes)\r\nHPI_DEBUG_LOG(WARNING,\r\n"Missed %d of %d " "bytes to user\n",\r\nuncopied_bytes, size);\r\n}\r\nmutex_unlock(&pa->mutex);\r\n}\r\nif (!hr->h.size) {\r\nHPI_DEBUG_LOG(ERROR, "response zero size\n");\r\nerr = -EFAULT;\r\ngoto out;\r\n}\r\nif (hr->h.size > res_max_size) {\r\nHPI_DEBUG_LOG(ERROR, "response too big %d %d\n", hr->h.size,\r\nres_max_size);\r\nhr->h.error = HPI_ERROR_RESPONSE_BUFFER_TOO_SMALL;\r\nhr->h.specific_error = hr->h.size;\r\nhr->h.size = sizeof(hr->h);\r\n}\r\nuncopied_bytes = copy_to_user(puhr, hr, hr->h.size);\r\nif (uncopied_bytes) {\r\nHPI_DEBUG_LOG(ERROR, "uncopied bytes %d\n", uncopied_bytes);\r\nerr = -EFAULT;\r\ngoto out;\r\n}\r\nout:\r\nkfree(hm);\r\nkfree(hr);\r\nreturn err;\r\n}\r\nint asihpi_adapter_probe(struct pci_dev *pci_dev,\r\nconst struct pci_device_id *pci_id)\r\n{\r\nint idx, nm;\r\nint adapter_index;\r\nunsigned int memlen;\r\nstruct hpi_message hm;\r\nstruct hpi_response hr;\r\nstruct hpi_adapter adapter;\r\nstruct hpi_pci pci;\r\nmemset(&adapter, 0, sizeof(adapter));\r\ndev_printk(KERN_DEBUG, &pci_dev->dev,\r\n"probe %04x:%04x,%04x:%04x,%04x\n", pci_dev->vendor,\r\npci_dev->device, pci_dev->subsystem_vendor,\r\npci_dev->subsystem_device, pci_dev->devfn);\r\nif (pci_enable_device(pci_dev) < 0) {\r\ndev_err(&pci_dev->dev,\r\n"pci_enable_device failed, disabling device\n");\r\nreturn -EIO;\r\n}\r\npci_set_master(pci_dev);\r\nhpi_init_message_response(&hm, &hr, HPI_OBJ_SUBSYSTEM,\r\nHPI_SUBSYS_CREATE_ADAPTER);\r\nhpi_init_response(&hr, HPI_OBJ_SUBSYSTEM, HPI_SUBSYS_CREATE_ADAPTER,\r\nHPI_ERROR_PROCESSING_MESSAGE);\r\nhm.adapter_index = HPI_ADAPTER_INDEX_INVALID;\r\nnm = HPI_MAX_ADAPTER_MEM_SPACES;\r\nfor (idx = 0; idx < nm; idx++) {\r\nHPI_DEBUG_LOG(INFO, "resource %d %pR\n", idx,\r\n&pci_dev->resource[idx]);\r\nif (pci_resource_flags(pci_dev, idx) & IORESOURCE_MEM) {\r\nmemlen = pci_resource_len(pci_dev, idx);\r\npci.ap_mem_base[idx] =\r\nioremap(pci_resource_start(pci_dev, idx),\r\nmemlen);\r\nif (!pci.ap_mem_base[idx]) {\r\nHPI_DEBUG_LOG(ERROR,\r\n"ioremap failed, aborting\n");\r\ngoto err;\r\n}\r\n}\r\n}\r\npci.pci_dev = pci_dev;\r\nhm.u.s.resource.bus_type = HPI_BUS_PCI;\r\nhm.u.s.resource.r.pci = &pci;\r\nhpi_send_recv_ex(&hm, &hr, HOWNER_KERNEL);\r\nif (hr.error)\r\ngoto err;\r\nadapter_index = hr.u.s.adapter_index;\r\nadapter.adapter = hpi_find_adapter(adapter_index);\r\nif (prealloc_stream_buf) {\r\nadapter.p_buffer = vmalloc(prealloc_stream_buf);\r\nif (!adapter.p_buffer) {\r\nHPI_DEBUG_LOG(ERROR,\r\n"HPI could not allocate "\r\n"kernel buffer size %d\n",\r\nprealloc_stream_buf);\r\ngoto err;\r\n}\r\n}\r\nhpi_init_message_response(&hm, &hr, HPI_OBJ_ADAPTER,\r\nHPI_ADAPTER_OPEN);\r\nhm.adapter_index = adapter.adapter->index;\r\nhpi_send_recv_ex(&hm, &hr, HOWNER_KERNEL);\r\nif (hr.error)\r\ngoto err;\r\nadapters[adapter_index] = adapter;\r\nmutex_init(&adapters[adapter_index].mutex);\r\npci_set_drvdata(pci_dev, &adapters[adapter_index]);\r\ndev_info(&pci_dev->dev, "probe succeeded for ASI%04X HPI index %d\n",\r\nadapter.adapter->type, adapter_index);\r\nreturn 0;\r\nerr:\r\nfor (idx = 0; idx < HPI_MAX_ADAPTER_MEM_SPACES; idx++) {\r\nif (pci.ap_mem_base[idx]) {\r\niounmap(pci.ap_mem_base[idx]);\r\npci.ap_mem_base[idx] = NULL;\r\n}\r\n}\r\nif (adapter.p_buffer) {\r\nadapter.buffer_size = 0;\r\nvfree(adapter.p_buffer);\r\n}\r\nHPI_DEBUG_LOG(ERROR, "adapter_probe failed\n");\r\nreturn -ENODEV;\r\n}\r\nvoid asihpi_adapter_remove(struct pci_dev *pci_dev)\r\n{\r\nint idx;\r\nstruct hpi_message hm;\r\nstruct hpi_response hr;\r\nstruct hpi_adapter *pa;\r\nstruct hpi_pci pci;\r\npa = pci_get_drvdata(pci_dev);\r\npci = pa->adapter->pci;\r\nhpi_init_message_response(&hm, &hr, HPI_OBJ_ADAPTER,\r\nHPI_ADAPTER_DELETE);\r\nhm.adapter_index = pa->adapter->index;\r\nhpi_send_recv_ex(&hm, &hr, HOWNER_KERNEL);\r\nfor (idx = 0; idx < HPI_MAX_ADAPTER_MEM_SPACES; idx++) {\r\nif (pci.ap_mem_base[idx])\r\niounmap(pci.ap_mem_base[idx]);\r\n}\r\nif (pa->p_buffer)\r\nvfree(pa->p_buffer);\r\npci_set_drvdata(pci_dev, NULL);\r\nif (1)\r\ndev_info(&pci_dev->dev,\r\n"remove %04x:%04x,%04x:%04x,%04x, HPI index %d\n",\r\npci_dev->vendor, pci_dev->device,\r\npci_dev->subsystem_vendor, pci_dev->subsystem_device,\r\npci_dev->devfn, pa->adapter->index);\r\nmemset(pa, 0, sizeof(*pa));\r\n}\r\nvoid __init asihpi_init(void)\r\n{\r\nstruct hpi_message hm;\r\nstruct hpi_response hr;\r\nmemset(adapters, 0, sizeof(adapters));\r\nprintk(KERN_INFO "ASIHPI driver " HPI_VER_STRING "\n");\r\nhpi_init_message_response(&hm, &hr, HPI_OBJ_SUBSYSTEM,\r\nHPI_SUBSYS_DRIVER_LOAD);\r\nhpi_send_recv_ex(&hm, &hr, HOWNER_KERNEL);\r\n}\r\nvoid asihpi_exit(void)\r\n{\r\nstruct hpi_message hm;\r\nstruct hpi_response hr;\r\nhpi_init_message_response(&hm, &hr, HPI_OBJ_SUBSYSTEM,\r\nHPI_SUBSYS_DRIVER_UNLOAD);\r\nhpi_send_recv_ex(&hm, &hr, HOWNER_KERNEL);\r\n}
