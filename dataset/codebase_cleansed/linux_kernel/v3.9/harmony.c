static inline unsigned long\r\nharmony_read(struct snd_harmony *h, unsigned r)\r\n{\r\nreturn __raw_readl(h->iobase + r);\r\n}\r\nstatic inline void\r\nharmony_write(struct snd_harmony *h, unsigned r, unsigned long v)\r\n{\r\n__raw_writel(v, h->iobase + r);\r\n}\r\nstatic inline void\r\nharmony_wait_for_control(struct snd_harmony *h)\r\n{\r\nwhile (harmony_read(h, HARMONY_CNTL) & HARMONY_CNTL_C) ;\r\n}\r\nstatic inline void\r\nharmony_reset(struct snd_harmony *h)\r\n{\r\nharmony_write(h, HARMONY_RESET, 1);\r\nmdelay(50);\r\nharmony_write(h, HARMONY_RESET, 0);\r\n}\r\nstatic void\r\nharmony_disable_interrupts(struct snd_harmony *h)\r\n{\r\nu32 dstatus;\r\nharmony_wait_for_control(h);\r\ndstatus = harmony_read(h, HARMONY_DSTATUS);\r\ndstatus &= ~HARMONY_DSTATUS_IE;\r\nharmony_write(h, HARMONY_DSTATUS, dstatus);\r\n}\r\nstatic void\r\nharmony_enable_interrupts(struct snd_harmony *h)\r\n{\r\nu32 dstatus;\r\nharmony_wait_for_control(h);\r\ndstatus = harmony_read(h, HARMONY_DSTATUS);\r\ndstatus |= HARMONY_DSTATUS_IE;\r\nharmony_write(h, HARMONY_DSTATUS, dstatus);\r\n}\r\nstatic void\r\nharmony_mute(struct snd_harmony *h)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&h->mixer_lock, flags);\r\nharmony_wait_for_control(h);\r\nharmony_write(h, HARMONY_GAINCTL, HARMONY_GAIN_SILENCE);\r\nspin_unlock_irqrestore(&h->mixer_lock, flags);\r\n}\r\nstatic void\r\nharmony_unmute(struct snd_harmony *h)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&h->mixer_lock, flags);\r\nharmony_wait_for_control(h);\r\nharmony_write(h, HARMONY_GAINCTL, h->st.gain);\r\nspin_unlock_irqrestore(&h->mixer_lock, flags);\r\n}\r\nstatic void\r\nharmony_set_control(struct snd_harmony *h)\r\n{\r\nu32 ctrl;\r\nunsigned long flags;\r\nspin_lock_irqsave(&h->lock, flags);\r\nctrl = (HARMONY_CNTL_C |\r\n(h->st.format << 6) |\r\n(h->st.stereo << 5) |\r\n(h->st.rate));\r\nharmony_wait_for_control(h);\r\nharmony_write(h, HARMONY_CNTL, ctrl);\r\nspin_unlock_irqrestore(&h->lock, flags);\r\n}\r\nstatic irqreturn_t\r\nsnd_harmony_interrupt(int irq, void *dev)\r\n{\r\nu32 dstatus;\r\nstruct snd_harmony *h = dev;\r\nspin_lock(&h->lock);\r\nharmony_disable_interrupts(h);\r\nharmony_wait_for_control(h);\r\ndstatus = harmony_read(h, HARMONY_DSTATUS);\r\nspin_unlock(&h->lock);\r\nif (dstatus & HARMONY_DSTATUS_PN) {\r\nif (h->psubs && h->st.playing) {\r\nspin_lock(&h->lock);\r\nh->pbuf.buf += h->pbuf.count;\r\nh->pbuf.buf %= h->pbuf.size;\r\nharmony_write(h, HARMONY_PNXTADD,\r\nh->pbuf.addr + h->pbuf.buf);\r\nh->stats.play_intr++;\r\nspin_unlock(&h->lock);\r\nsnd_pcm_period_elapsed(h->psubs);\r\n} else {\r\nspin_lock(&h->lock);\r\nharmony_write(h, HARMONY_PNXTADD, h->sdma.addr);\r\nh->stats.silence_intr++;\r\nspin_unlock(&h->lock);\r\n}\r\n}\r\nif (dstatus & HARMONY_DSTATUS_RN) {\r\nif (h->csubs && h->st.capturing) {\r\nspin_lock(&h->lock);\r\nh->cbuf.buf += h->cbuf.count;\r\nh->cbuf.buf %= h->cbuf.size;\r\nharmony_write(h, HARMONY_RNXTADD,\r\nh->cbuf.addr + h->cbuf.buf);\r\nh->stats.rec_intr++;\r\nspin_unlock(&h->lock);\r\nsnd_pcm_period_elapsed(h->csubs);\r\n} else {\r\nspin_lock(&h->lock);\r\nharmony_write(h, HARMONY_RNXTADD, h->gdma.addr);\r\nh->stats.graveyard_intr++;\r\nspin_unlock(&h->lock);\r\n}\r\n}\r\nspin_lock(&h->lock);\r\nharmony_enable_interrupts(h);\r\nspin_unlock(&h->lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic unsigned int\r\nsnd_harmony_rate_bits(int rate)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < ARRAY_SIZE(snd_harmony_rates); i++)\r\nif (snd_harmony_rates[i] == rate)\r\nreturn rate_bits[i];\r\nreturn HARMONY_SR_44KHZ;\r\n}\r\nstatic int\r\nsnd_harmony_playback_trigger(struct snd_pcm_substream *ss, int cmd)\r\n{\r\nstruct snd_harmony *h = snd_pcm_substream_chip(ss);\r\nif (h->st.capturing)\r\nreturn -EBUSY;\r\nspin_lock(&h->lock);\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\nh->st.playing = 1;\r\nharmony_write(h, HARMONY_PNXTADD, h->pbuf.addr);\r\nharmony_write(h, HARMONY_RNXTADD, h->gdma.addr);\r\nharmony_unmute(h);\r\nharmony_enable_interrupts(h);\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\nh->st.playing = 0;\r\nharmony_mute(h);\r\nharmony_write(h, HARMONY_PNXTADD, h->sdma.addr);\r\nharmony_disable_interrupts(h);\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\r\ncase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\r\ncase SNDRV_PCM_TRIGGER_SUSPEND:\r\ndefault:\r\nspin_unlock(&h->lock);\r\nsnd_BUG();\r\nreturn -EINVAL;\r\n}\r\nspin_unlock(&h->lock);\r\nreturn 0;\r\n}\r\nstatic int\r\nsnd_harmony_capture_trigger(struct snd_pcm_substream *ss, int cmd)\r\n{\r\nstruct snd_harmony *h = snd_pcm_substream_chip(ss);\r\nif (h->st.playing)\r\nreturn -EBUSY;\r\nspin_lock(&h->lock);\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\nh->st.capturing = 1;\r\nharmony_write(h, HARMONY_PNXTADD, h->sdma.addr);\r\nharmony_write(h, HARMONY_RNXTADD, h->cbuf.addr);\r\nharmony_unmute(h);\r\nharmony_enable_interrupts(h);\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\nh->st.capturing = 0;\r\nharmony_mute(h);\r\nharmony_write(h, HARMONY_RNXTADD, h->gdma.addr);\r\nharmony_disable_interrupts(h);\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\r\ncase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\r\ncase SNDRV_PCM_TRIGGER_SUSPEND:\r\ndefault:\r\nspin_unlock(&h->lock);\r\nsnd_BUG();\r\nreturn -EINVAL;\r\n}\r\nspin_unlock(&h->lock);\r\nreturn 0;\r\n}\r\nstatic int\r\nsnd_harmony_set_data_format(struct snd_harmony *h, int fmt, int force)\r\n{\r\nint o = h->st.format;\r\nint n;\r\nswitch(fmt) {\r\ncase SNDRV_PCM_FORMAT_S16_BE:\r\nn = HARMONY_DF_16BIT_LINEAR;\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_A_LAW:\r\nn = HARMONY_DF_8BIT_ALAW;\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_MU_LAW:\r\nn = HARMONY_DF_8BIT_ULAW;\r\nbreak;\r\ndefault:\r\nn = HARMONY_DF_16BIT_LINEAR;\r\nbreak;\r\n}\r\nif (force || o != n) {\r\nsnd_pcm_format_set_silence(fmt, h->sdma.area, SILENCE_BUFSZ /\r\n(snd_pcm_format_physical_width(fmt)\r\n/ 8));\r\n}\r\nreturn n;\r\n}\r\nstatic int\r\nsnd_harmony_playback_prepare(struct snd_pcm_substream *ss)\r\n{\r\nstruct snd_harmony *h = snd_pcm_substream_chip(ss);\r\nstruct snd_pcm_runtime *rt = ss->runtime;\r\nif (h->st.capturing)\r\nreturn -EBUSY;\r\nh->pbuf.size = snd_pcm_lib_buffer_bytes(ss);\r\nh->pbuf.count = snd_pcm_lib_period_bytes(ss);\r\nif (h->pbuf.buf >= h->pbuf.size)\r\nh->pbuf.buf = 0;\r\nh->st.playing = 0;\r\nh->st.rate = snd_harmony_rate_bits(rt->rate);\r\nh->st.format = snd_harmony_set_data_format(h, rt->format, 0);\r\nif (rt->channels == 2)\r\nh->st.stereo = HARMONY_SS_STEREO;\r\nelse\r\nh->st.stereo = HARMONY_SS_MONO;\r\nharmony_set_control(h);\r\nh->pbuf.addr = rt->dma_addr;\r\nreturn 0;\r\n}\r\nstatic int\r\nsnd_harmony_capture_prepare(struct snd_pcm_substream *ss)\r\n{\r\nstruct snd_harmony *h = snd_pcm_substream_chip(ss);\r\nstruct snd_pcm_runtime *rt = ss->runtime;\r\nif (h->st.playing)\r\nreturn -EBUSY;\r\nh->cbuf.size = snd_pcm_lib_buffer_bytes(ss);\r\nh->cbuf.count = snd_pcm_lib_period_bytes(ss);\r\nif (h->cbuf.buf >= h->cbuf.size)\r\nh->cbuf.buf = 0;\r\nh->st.capturing = 0;\r\nh->st.rate = snd_harmony_rate_bits(rt->rate);\r\nh->st.format = snd_harmony_set_data_format(h, rt->format, 0);\r\nif (rt->channels == 2)\r\nh->st.stereo = HARMONY_SS_STEREO;\r\nelse\r\nh->st.stereo = HARMONY_SS_MONO;\r\nharmony_set_control(h);\r\nh->cbuf.addr = rt->dma_addr;\r\nreturn 0;\r\n}\r\nstatic snd_pcm_uframes_t\r\nsnd_harmony_playback_pointer(struct snd_pcm_substream *ss)\r\n{\r\nstruct snd_pcm_runtime *rt = ss->runtime;\r\nstruct snd_harmony *h = snd_pcm_substream_chip(ss);\r\nunsigned long pcuradd;\r\nunsigned long played;\r\nif (!(h->st.playing) || (h->psubs == NULL))\r\nreturn 0;\r\nif ((h->pbuf.addr == 0) || (h->pbuf.size == 0))\r\nreturn 0;\r\npcuradd = harmony_read(h, HARMONY_PCURADD);\r\nplayed = pcuradd - h->pbuf.addr;\r\n#ifdef HARMONY_DEBUG\r\nprintk(KERN_DEBUG PFX "playback_pointer is 0x%lx-0x%lx = %d bytes\n",\r\npcuradd, h->pbuf.addr, played);\r\n#endif\r\nif (pcuradd > h->pbuf.addr + h->pbuf.size) {\r\nreturn 0;\r\n}\r\nreturn bytes_to_frames(rt, played);\r\n}\r\nstatic snd_pcm_uframes_t\r\nsnd_harmony_capture_pointer(struct snd_pcm_substream *ss)\r\n{\r\nstruct snd_pcm_runtime *rt = ss->runtime;\r\nstruct snd_harmony *h = snd_pcm_substream_chip(ss);\r\nunsigned long rcuradd;\r\nunsigned long caught;\r\nif (!(h->st.capturing) || (h->csubs == NULL))\r\nreturn 0;\r\nif ((h->cbuf.addr == 0) || (h->cbuf.size == 0))\r\nreturn 0;\r\nrcuradd = harmony_read(h, HARMONY_RCURADD);\r\ncaught = rcuradd - h->cbuf.addr;\r\n#ifdef HARMONY_DEBUG\r\nprintk(KERN_DEBUG PFX "capture_pointer is 0x%lx-0x%lx = %d bytes\n",\r\nrcuradd, h->cbuf.addr, caught);\r\n#endif\r\nif (rcuradd > h->cbuf.addr + h->cbuf.size) {\r\nreturn 0;\r\n}\r\nreturn bytes_to_frames(rt, caught);\r\n}\r\nstatic int\r\nsnd_harmony_playback_open(struct snd_pcm_substream *ss)\r\n{\r\nstruct snd_harmony *h = snd_pcm_substream_chip(ss);\r\nstruct snd_pcm_runtime *rt = ss->runtime;\r\nint err;\r\nh->psubs = ss;\r\nrt->hw = snd_harmony_playback;\r\nsnd_pcm_hw_constraint_list(rt, 0, SNDRV_PCM_HW_PARAM_RATE,\r\n&hw_constraint_rates);\r\nerr = snd_pcm_hw_constraint_integer(rt, SNDRV_PCM_HW_PARAM_PERIODS);\r\nif (err < 0)\r\nreturn err;\r\nreturn 0;\r\n}\r\nstatic int\r\nsnd_harmony_capture_open(struct snd_pcm_substream *ss)\r\n{\r\nstruct snd_harmony *h = snd_pcm_substream_chip(ss);\r\nstruct snd_pcm_runtime *rt = ss->runtime;\r\nint err;\r\nh->csubs = ss;\r\nrt->hw = snd_harmony_capture;\r\nsnd_pcm_hw_constraint_list(rt, 0, SNDRV_PCM_HW_PARAM_RATE,\r\n&hw_constraint_rates);\r\nerr = snd_pcm_hw_constraint_integer(rt, SNDRV_PCM_HW_PARAM_PERIODS);\r\nif (err < 0)\r\nreturn err;\r\nreturn 0;\r\n}\r\nstatic int\r\nsnd_harmony_playback_close(struct snd_pcm_substream *ss)\r\n{\r\nstruct snd_harmony *h = snd_pcm_substream_chip(ss);\r\nh->psubs = NULL;\r\nreturn 0;\r\n}\r\nstatic int\r\nsnd_harmony_capture_close(struct snd_pcm_substream *ss)\r\n{\r\nstruct snd_harmony *h = snd_pcm_substream_chip(ss);\r\nh->csubs = NULL;\r\nreturn 0;\r\n}\r\nstatic int\r\nsnd_harmony_hw_params(struct snd_pcm_substream *ss,\r\nstruct snd_pcm_hw_params *hw)\r\n{\r\nint err;\r\nstruct snd_harmony *h = snd_pcm_substream_chip(ss);\r\nerr = snd_pcm_lib_malloc_pages(ss, params_buffer_bytes(hw));\r\nif (err > 0 && h->dma.type == SNDRV_DMA_TYPE_CONTINUOUS)\r\nss->runtime->dma_addr = __pa(ss->runtime->dma_area);\r\nreturn err;\r\n}\r\nstatic int\r\nsnd_harmony_hw_free(struct snd_pcm_substream *ss)\r\n{\r\nreturn snd_pcm_lib_free_pages(ss);\r\n}\r\nstatic int\r\nsnd_harmony_pcm_init(struct snd_harmony *h)\r\n{\r\nstruct snd_pcm *pcm;\r\nint err;\r\nif (snd_BUG_ON(!h))\r\nreturn -EINVAL;\r\nharmony_disable_interrupts(h);\r\nerr = snd_pcm_new(h->card, "harmony", 0, 1, 1, &pcm);\r\nif (err < 0)\r\nreturn err;\r\nsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK,\r\n&snd_harmony_playback_ops);\r\nsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE,\r\n&snd_harmony_capture_ops);\r\npcm->private_data = h;\r\npcm->info_flags = 0;\r\nstrcpy(pcm->name, "harmony");\r\nh->pcm = pcm;\r\nh->psubs = NULL;\r\nh->csubs = NULL;\r\nh->dma.type = SNDRV_DMA_TYPE_DEV;\r\nh->dma.dev = &h->dev->dev;\r\nerr = snd_dma_alloc_pages(h->dma.type,\r\nh->dma.dev,\r\nBUF_SIZE*GRAVEYARD_BUFS,\r\n&h->gdma);\r\nif (err < 0) {\r\nprintk(KERN_ERR PFX "cannot allocate graveyard buffer!\n");\r\nreturn err;\r\n}\r\nerr = snd_dma_alloc_pages(h->dma.type,\r\nh->dma.dev,\r\nBUF_SIZE*SILENCE_BUFS,\r\n&h->sdma);\r\nif (err < 0) {\r\nprintk(KERN_ERR PFX "cannot allocate silence buffer!\n");\r\nreturn err;\r\n}\r\nerr = snd_pcm_lib_preallocate_pages_for_all(pcm, h->dma.type,\r\nh->dma.dev,\r\nMAX_BUF_SIZE,\r\nMAX_BUF_SIZE);\r\nif (err < 0) {\r\nprintk(KERN_ERR PFX "buffer allocation error: %d\n", err);\r\nreturn err;\r\n}\r\nh->st.format = snd_harmony_set_data_format(h,\r\nSNDRV_PCM_FORMAT_S16_BE, 1);\r\nreturn 0;\r\n}\r\nstatic void\r\nsnd_harmony_set_new_gain(struct snd_harmony *h)\r\n{\r\nharmony_wait_for_control(h);\r\nharmony_write(h, HARMONY_GAINCTL, h->st.gain);\r\n}\r\nstatic int\r\nsnd_harmony_mixercontrol_info(struct snd_kcontrol *kc,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nint mask = (kc->private_value >> 16) & 0xff;\r\nint left_shift = (kc->private_value) & 0xff;\r\nint right_shift = (kc->private_value >> 8) & 0xff;\r\nuinfo->type = mask == 1 ? SNDRV_CTL_ELEM_TYPE_BOOLEAN :\r\nSNDRV_CTL_ELEM_TYPE_INTEGER;\r\nuinfo->count = left_shift == right_shift ? 1 : 2;\r\nuinfo->value.integer.min = 0;\r\nuinfo->value.integer.max = mask;\r\nreturn 0;\r\n}\r\nstatic int\r\nsnd_harmony_volume_get(struct snd_kcontrol *kc,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_harmony *h = snd_kcontrol_chip(kc);\r\nint shift_left = (kc->private_value) & 0xff;\r\nint shift_right = (kc->private_value >> 8) & 0xff;\r\nint mask = (kc->private_value >> 16) & 0xff;\r\nint invert = (kc->private_value >> 24) & 0xff;\r\nint left, right;\r\nspin_lock_irq(&h->mixer_lock);\r\nleft = (h->st.gain >> shift_left) & mask;\r\nright = (h->st.gain >> shift_right) & mask;\r\nif (invert) {\r\nleft = mask - left;\r\nright = mask - right;\r\n}\r\nucontrol->value.integer.value[0] = left;\r\nif (shift_left != shift_right)\r\nucontrol->value.integer.value[1] = right;\r\nspin_unlock_irq(&h->mixer_lock);\r\nreturn 0;\r\n}\r\nstatic int\r\nsnd_harmony_volume_put(struct snd_kcontrol *kc,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_harmony *h = snd_kcontrol_chip(kc);\r\nint shift_left = (kc->private_value) & 0xff;\r\nint shift_right = (kc->private_value >> 8) & 0xff;\r\nint mask = (kc->private_value >> 16) & 0xff;\r\nint invert = (kc->private_value >> 24) & 0xff;\r\nint left, right;\r\nint old_gain = h->st.gain;\r\nspin_lock_irq(&h->mixer_lock);\r\nleft = ucontrol->value.integer.value[0] & mask;\r\nif (invert)\r\nleft = mask - left;\r\nh->st.gain &= ~( (mask << shift_left ) );\r\nh->st.gain |= (left << shift_left);\r\nif (shift_left != shift_right) {\r\nright = ucontrol->value.integer.value[1] & mask;\r\nif (invert)\r\nright = mask - right;\r\nh->st.gain &= ~( (mask << shift_right) );\r\nh->st.gain |= (right << shift_right);\r\n}\r\nsnd_harmony_set_new_gain(h);\r\nspin_unlock_irq(&h->mixer_lock);\r\nreturn h->st.gain != old_gain;\r\n}\r\nstatic int\r\nsnd_harmony_captureroute_info(struct snd_kcontrol *kc,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nstatic char *texts[2] = { "Line", "Mic" };\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;\r\nuinfo->count = 1;\r\nuinfo->value.enumerated.items = 2;\r\nif (uinfo->value.enumerated.item > 1)\r\nuinfo->value.enumerated.item = 1;\r\nstrcpy(uinfo->value.enumerated.name,\r\ntexts[uinfo->value.enumerated.item]);\r\nreturn 0;\r\n}\r\nstatic int\r\nsnd_harmony_captureroute_get(struct snd_kcontrol *kc,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_harmony *h = snd_kcontrol_chip(kc);\r\nint value;\r\nspin_lock_irq(&h->mixer_lock);\r\nvalue = (h->st.gain >> HARMONY_GAIN_IS_SHIFT) & 1;\r\nucontrol->value.enumerated.item[0] = value;\r\nspin_unlock_irq(&h->mixer_lock);\r\nreturn 0;\r\n}\r\nstatic int\r\nsnd_harmony_captureroute_put(struct snd_kcontrol *kc,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_harmony *h = snd_kcontrol_chip(kc);\r\nint value;\r\nint old_gain = h->st.gain;\r\nspin_lock_irq(&h->mixer_lock);\r\nvalue = ucontrol->value.enumerated.item[0] & 1;\r\nh->st.gain &= ~HARMONY_GAIN_IS_MASK;\r\nh->st.gain |= value << HARMONY_GAIN_IS_SHIFT;\r\nsnd_harmony_set_new_gain(h);\r\nspin_unlock_irq(&h->mixer_lock);\r\nreturn h->st.gain != old_gain;\r\n}\r\nstatic void\r\nsnd_harmony_mixer_reset(struct snd_harmony *h)\r\n{\r\nharmony_mute(h);\r\nharmony_reset(h);\r\nh->st.gain = HARMONY_GAIN_DEFAULT;\r\nharmony_unmute(h);\r\n}\r\nstatic int\r\nsnd_harmony_mixer_init(struct snd_harmony *h)\r\n{\r\nstruct snd_card *card;\r\nint idx, err;\r\nif (snd_BUG_ON(!h))\r\nreturn -EINVAL;\r\ncard = h->card;\r\nstrcpy(card->mixername, "Harmony Gain control interface");\r\nfor (idx = 0; idx < HARMONY_CONTROLS; idx++) {\r\nerr = snd_ctl_add(card,\r\nsnd_ctl_new1(&snd_harmony_controls[idx], h));\r\nif (err < 0)\r\nreturn err;\r\n}\r\nsnd_harmony_mixer_reset(h);\r\nreturn 0;\r\n}\r\nstatic int\r\nsnd_harmony_free(struct snd_harmony *h)\r\n{\r\nif (h->gdma.addr)\r\nsnd_dma_free_pages(&h->gdma);\r\nif (h->sdma.addr)\r\nsnd_dma_free_pages(&h->sdma);\r\nif (h->irq >= 0)\r\nfree_irq(h->irq, h);\r\nif (h->iobase)\r\niounmap(h->iobase);\r\nparisc_set_drvdata(h->dev, NULL);\r\nkfree(h);\r\nreturn 0;\r\n}\r\nstatic int\r\nsnd_harmony_dev_free(struct snd_device *dev)\r\n{\r\nstruct snd_harmony *h = dev->device_data;\r\nreturn snd_harmony_free(h);\r\n}\r\nstatic int\r\nsnd_harmony_create(struct snd_card *card,\r\nstruct parisc_device *padev,\r\nstruct snd_harmony **rchip)\r\n{\r\nint err;\r\nstruct snd_harmony *h;\r\nstatic struct snd_device_ops ops = {\r\n.dev_free = snd_harmony_dev_free,\r\n};\r\n*rchip = NULL;\r\nh = kzalloc(sizeof(*h), GFP_KERNEL);\r\nif (h == NULL)\r\nreturn -ENOMEM;\r\nh->hpa = padev->hpa.start;\r\nh->card = card;\r\nh->dev = padev;\r\nh->irq = -1;\r\nh->iobase = ioremap_nocache(padev->hpa.start, HARMONY_SIZE);\r\nif (h->iobase == NULL) {\r\nprintk(KERN_ERR PFX "unable to remap hpa 0x%lx\n",\r\n(unsigned long)padev->hpa.start);\r\nerr = -EBUSY;\r\ngoto free_and_ret;\r\n}\r\nerr = request_irq(padev->irq, snd_harmony_interrupt, 0,\r\n"harmony", h);\r\nif (err) {\r\nprintk(KERN_ERR PFX "could not obtain interrupt %d",\r\npadev->irq);\r\ngoto free_and_ret;\r\n}\r\nh->irq = padev->irq;\r\nspin_lock_init(&h->mixer_lock);\r\nspin_lock_init(&h->lock);\r\nif ((err = snd_device_new(card, SNDRV_DEV_LOWLEVEL,\r\nh, &ops)) < 0) {\r\ngoto free_and_ret;\r\n}\r\nsnd_card_set_dev(card, &padev->dev);\r\n*rchip = h;\r\nreturn 0;\r\nfree_and_ret:\r\nsnd_harmony_free(h);\r\nreturn err;\r\n}\r\nstatic int\r\nsnd_harmony_probe(struct parisc_device *padev)\r\n{\r\nint err;\r\nstruct snd_card *card;\r\nstruct snd_harmony *h;\r\nerr = snd_card_create(index, id, THIS_MODULE, 0, &card);\r\nif (err < 0)\r\nreturn err;\r\nerr = snd_harmony_create(card, padev, &h);\r\nif (err < 0)\r\ngoto free_and_ret;\r\nerr = snd_harmony_pcm_init(h);\r\nif (err < 0)\r\ngoto free_and_ret;\r\nerr = snd_harmony_mixer_init(h);\r\nif (err < 0)\r\ngoto free_and_ret;\r\nstrcpy(card->driver, "harmony");\r\nstrcpy(card->shortname, "Harmony");\r\nsprintf(card->longname, "%s at 0x%lx, irq %i",\r\ncard->shortname, h->hpa, h->irq);\r\nerr = snd_card_register(card);\r\nif (err < 0)\r\ngoto free_and_ret;\r\nparisc_set_drvdata(padev, card);\r\nreturn 0;\r\nfree_and_ret:\r\nsnd_card_free(card);\r\nreturn err;\r\n}\r\nstatic int\r\nsnd_harmony_remove(struct parisc_device *padev)\r\n{\r\nsnd_card_free(parisc_get_drvdata(padev));\r\nparisc_set_drvdata(padev, NULL);\r\nreturn 0;\r\n}\r\nstatic int __init\r\nalsa_harmony_init(void)\r\n{\r\nreturn register_parisc_driver(&snd_harmony_driver);\r\n}\r\nstatic void __exit\r\nalsa_harmony_fini(void)\r\n{\r\nunregister_parisc_driver(&snd_harmony_driver);\r\n}
