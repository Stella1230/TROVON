static inline void snd_sonicvibes_setdmaa(struct sonicvibes * sonic,\r\nunsigned int addr,\r\nunsigned int count)\r\n{\r\ncount--;\r\noutl(addr, sonic->dmaa_port + SV_DMA_ADDR0);\r\noutl(count, sonic->dmaa_port + SV_DMA_COUNT0);\r\noutb(0x18, sonic->dmaa_port + SV_DMA_MODE);\r\n#if 0\r\nprintk(KERN_DEBUG "program dmaa: addr = 0x%x, paddr = 0x%x\n",\r\naddr, inl(sonic->dmaa_port + SV_DMA_ADDR0));\r\n#endif\r\n}\r\nstatic inline void snd_sonicvibes_setdmac(struct sonicvibes * sonic,\r\nunsigned int addr,\r\nunsigned int count)\r\n{\r\ncount >>= 1;\r\ncount--;\r\noutl(addr, sonic->dmac_port + SV_DMA_ADDR0);\r\noutl(count, sonic->dmac_port + SV_DMA_COUNT0);\r\noutb(0x14, sonic->dmac_port + SV_DMA_MODE);\r\n#if 0\r\nprintk(KERN_DEBUG "program dmac: addr = 0x%x, paddr = 0x%x\n",\r\naddr, inl(sonic->dmac_port + SV_DMA_ADDR0));\r\n#endif\r\n}\r\nstatic inline unsigned int snd_sonicvibes_getdmaa(struct sonicvibes * sonic)\r\n{\r\nreturn (inl(sonic->dmaa_port + SV_DMA_COUNT0) & 0xffffff) + 1;\r\n}\r\nstatic inline unsigned int snd_sonicvibes_getdmac(struct sonicvibes * sonic)\r\n{\r\nreturn ((inl(sonic->dmac_port + SV_DMA_COUNT0) & 0xffffff) + 1) << 1;\r\n}\r\nstatic void snd_sonicvibes_out1(struct sonicvibes * sonic,\r\nunsigned char reg,\r\nunsigned char value)\r\n{\r\noutb(reg, SV_REG(sonic, INDEX));\r\nudelay(10);\r\noutb(value, SV_REG(sonic, DATA));\r\nudelay(10);\r\n}\r\nstatic void snd_sonicvibes_out(struct sonicvibes * sonic,\r\nunsigned char reg,\r\nunsigned char value)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&sonic->reg_lock, flags);\r\noutb(reg, SV_REG(sonic, INDEX));\r\nudelay(10);\r\noutb(value, SV_REG(sonic, DATA));\r\nudelay(10);\r\nspin_unlock_irqrestore(&sonic->reg_lock, flags);\r\n}\r\nstatic unsigned char snd_sonicvibes_in1(struct sonicvibes * sonic, unsigned char reg)\r\n{\r\nunsigned char value;\r\noutb(reg, SV_REG(sonic, INDEX));\r\nudelay(10);\r\nvalue = inb(SV_REG(sonic, DATA));\r\nudelay(10);\r\nreturn value;\r\n}\r\nstatic unsigned char snd_sonicvibes_in(struct sonicvibes * sonic, unsigned char reg)\r\n{\r\nunsigned long flags;\r\nunsigned char value;\r\nspin_lock_irqsave(&sonic->reg_lock, flags);\r\noutb(reg, SV_REG(sonic, INDEX));\r\nudelay(10);\r\nvalue = inb(SV_REG(sonic, DATA));\r\nudelay(10);\r\nspin_unlock_irqrestore(&sonic->reg_lock, flags);\r\nreturn value;\r\n}\r\nstatic void snd_sonicvibes_setfmt(struct sonicvibes * sonic,\r\nunsigned char mask,\r\nunsigned char value)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&sonic->reg_lock, flags);\r\noutb(SV_MCE | SV_IREG_DMA_DATA_FMT, SV_REG(sonic, INDEX));\r\nif (mask) {\r\nsonic->format = inb(SV_REG(sonic, DATA));\r\nudelay(10);\r\n}\r\nsonic->format = (sonic->format & mask) | value;\r\noutb(sonic->format, SV_REG(sonic, DATA));\r\nudelay(10);\r\noutb(0, SV_REG(sonic, INDEX));\r\nudelay(10);\r\nspin_unlock_irqrestore(&sonic->reg_lock, flags);\r\n}\r\nstatic void snd_sonicvibes_pll(unsigned int rate,\r\nunsigned int *res_r,\r\nunsigned int *res_m,\r\nunsigned int *res_n)\r\n{\r\nunsigned int r, m = 0, n = 0;\r\nunsigned int xm, xn, xr, xd, metric = ~0U;\r\nif (rate < 625000 / SV_ADCMULT)\r\nrate = 625000 / SV_ADCMULT;\r\nif (rate > 150000000 / SV_ADCMULT)\r\nrate = 150000000 / SV_ADCMULT;\r\nfor (r = 0; rate < 75000000 / SV_ADCMULT; r += 0x20, rate <<= 1);\r\nfor (xn = 3; xn < 33; xn++)\r\nfor (xm = 3; xm < 257; xm++) {\r\nxr = ((SV_REFFREQUENCY / SV_ADCMULT) * xm) / xn;\r\nif (xr >= rate)\r\nxd = xr - rate;\r\nelse\r\nxd = rate - xr;\r\nif (xd < metric) {\r\nmetric = xd;\r\nm = xm - 2;\r\nn = xn - 2;\r\n}\r\n}\r\n*res_r = r;\r\n*res_m = m;\r\n*res_n = n;\r\n#if 0\r\nprintk(KERN_DEBUG "metric = %i, xm = %i, xn = %i\n", metric, xm, xn);\r\nprintk(KERN_DEBUG "pll: m = 0x%x, r = 0x%x, n = 0x%x\n", reg, m, r, n);\r\n#endif\r\n}\r\nstatic void snd_sonicvibes_setpll(struct sonicvibes * sonic,\r\nunsigned char reg,\r\nunsigned int rate)\r\n{\r\nunsigned long flags;\r\nunsigned int r, m, n;\r\nsnd_sonicvibes_pll(rate, &r, &m, &n);\r\nif (sonic != NULL) {\r\nspin_lock_irqsave(&sonic->reg_lock, flags);\r\nsnd_sonicvibes_out1(sonic, reg, m);\r\nsnd_sonicvibes_out1(sonic, reg + 1, r | n);\r\nspin_unlock_irqrestore(&sonic->reg_lock, flags);\r\n}\r\n}\r\nstatic void snd_sonicvibes_set_adc_rate(struct sonicvibes * sonic, unsigned int rate)\r\n{\r\nunsigned long flags;\r\nunsigned int div;\r\nunsigned char clock;\r\ndiv = 48000 / rate;\r\nif (div > 8)\r\ndiv = 8;\r\nif ((48000 / div) == rate) {\r\nclock = 0x10;\r\n} else {\r\nclock = 0x00;\r\nsnd_sonicvibes_setpll(sonic, SV_IREG_ADC_PLL, rate);\r\n}\r\nspin_lock_irqsave(&sonic->reg_lock, flags);\r\nsnd_sonicvibes_out1(sonic, SV_IREG_ADC_ALT_RATE, (div - 1) << 4);\r\nsnd_sonicvibes_out1(sonic, SV_IREG_ADC_CLOCK, clock);\r\nspin_unlock_irqrestore(&sonic->reg_lock, flags);\r\n}\r\nstatic int snd_sonicvibes_hw_constraint_dac_rate(struct snd_pcm_hw_params *params,\r\nstruct snd_pcm_hw_rule *rule)\r\n{\r\nunsigned int rate, div, r, m, n;\r\nif (hw_param_interval(params, SNDRV_PCM_HW_PARAM_RATE)->min ==\r\nhw_param_interval(params, SNDRV_PCM_HW_PARAM_RATE)->max) {\r\nrate = hw_param_interval(params, SNDRV_PCM_HW_PARAM_RATE)->min;\r\ndiv = 48000 / rate;\r\nif (div > 8)\r\ndiv = 8;\r\nif ((48000 / div) == rate) {\r\nparams->rate_num = rate;\r\nparams->rate_den = 1;\r\n} else {\r\nsnd_sonicvibes_pll(rate, &r, &m, &n);\r\nsnd_BUG_ON(SV_REFFREQUENCY % 16);\r\nsnd_BUG_ON(SV_ADCMULT % 512);\r\nparams->rate_num = (SV_REFFREQUENCY/16) * (n+2) * r;\r\nparams->rate_den = (SV_ADCMULT/512) * (m+2);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void snd_sonicvibes_set_dac_rate(struct sonicvibes * sonic, unsigned int rate)\r\n{\r\nunsigned int div;\r\nunsigned long flags;\r\ndiv = (rate * 65536 + SV_FULLRATE / 2) / SV_FULLRATE;\r\nif (div > 65535)\r\ndiv = 65535;\r\nspin_lock_irqsave(&sonic->reg_lock, flags);\r\nsnd_sonicvibes_out1(sonic, SV_IREG_PCM_RATE_HIGH, div >> 8);\r\nsnd_sonicvibes_out1(sonic, SV_IREG_PCM_RATE_LOW, div);\r\nspin_unlock_irqrestore(&sonic->reg_lock, flags);\r\n}\r\nstatic int snd_sonicvibes_trigger(struct sonicvibes * sonic, int what, int cmd)\r\n{\r\nint result = 0;\r\nspin_lock(&sonic->reg_lock);\r\nif (cmd == SNDRV_PCM_TRIGGER_START) {\r\nif (!(sonic->enable & what)) {\r\nsonic->enable |= what;\r\nsnd_sonicvibes_out1(sonic, SV_IREG_PC_ENABLE, sonic->enable);\r\n}\r\n} else if (cmd == SNDRV_PCM_TRIGGER_STOP) {\r\nif (sonic->enable & what) {\r\nsonic->enable &= ~what;\r\nsnd_sonicvibes_out1(sonic, SV_IREG_PC_ENABLE, sonic->enable);\r\n}\r\n} else {\r\nresult = -EINVAL;\r\n}\r\nspin_unlock(&sonic->reg_lock);\r\nreturn result;\r\n}\r\nstatic irqreturn_t snd_sonicvibes_interrupt(int irq, void *dev_id)\r\n{\r\nstruct sonicvibes *sonic = dev_id;\r\nunsigned char status;\r\nstatus = inb(SV_REG(sonic, STATUS));\r\nif (!(status & (SV_DMAA_IRQ | SV_DMAC_IRQ | SV_MIDI_IRQ)))\r\nreturn IRQ_NONE;\r\nif (status == 0xff) {\r\noutb(sonic->irqmask = ~0, SV_REG(sonic, IRQMASK));\r\nsnd_printk(KERN_ERR "IRQ failure - interrupts disabled!!\n");\r\nreturn IRQ_HANDLED;\r\n}\r\nif (sonic->pcm) {\r\nif (status & SV_DMAA_IRQ)\r\nsnd_pcm_period_elapsed(sonic->playback_substream);\r\nif (status & SV_DMAC_IRQ)\r\nsnd_pcm_period_elapsed(sonic->capture_substream);\r\n}\r\nif (sonic->rmidi) {\r\nif (status & SV_MIDI_IRQ)\r\nsnd_mpu401_uart_interrupt(irq, sonic->rmidi->private_data);\r\n}\r\nif (status & SV_UD_IRQ) {\r\nunsigned char udreg;\r\nint vol, oleft, oright, mleft, mright;\r\nspin_lock(&sonic->reg_lock);\r\nudreg = snd_sonicvibes_in1(sonic, SV_IREG_UD_BUTTON);\r\nvol = udreg & 0x3f;\r\nif (!(udreg & 0x40))\r\nvol = -vol;\r\noleft = mleft = snd_sonicvibes_in1(sonic, SV_IREG_LEFT_ANALOG);\r\noright = mright = snd_sonicvibes_in1(sonic, SV_IREG_RIGHT_ANALOG);\r\noleft &= 0x1f;\r\noright &= 0x1f;\r\noleft += vol;\r\nif (oleft < 0)\r\noleft = 0;\r\nif (oleft > 0x1f)\r\noleft = 0x1f;\r\noright += vol;\r\nif (oright < 0)\r\noright = 0;\r\nif (oright > 0x1f)\r\noright = 0x1f;\r\nif (udreg & 0x80) {\r\nmleft ^= 0x80;\r\nmright ^= 0x80;\r\n}\r\noleft |= mleft & 0x80;\r\noright |= mright & 0x80;\r\nsnd_sonicvibes_out1(sonic, SV_IREG_LEFT_ANALOG, oleft);\r\nsnd_sonicvibes_out1(sonic, SV_IREG_RIGHT_ANALOG, oright);\r\nspin_unlock(&sonic->reg_lock);\r\nsnd_ctl_notify(sonic->card, SNDRV_CTL_EVENT_MASK_VALUE, &sonic->master_mute->id);\r\nsnd_ctl_notify(sonic->card, SNDRV_CTL_EVENT_MASK_VALUE, &sonic->master_volume->id);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int snd_sonicvibes_playback_trigger(struct snd_pcm_substream *substream,\r\nint cmd)\r\n{\r\nstruct sonicvibes *sonic = snd_pcm_substream_chip(substream);\r\nreturn snd_sonicvibes_trigger(sonic, 1, cmd);\r\n}\r\nstatic int snd_sonicvibes_capture_trigger(struct snd_pcm_substream *substream,\r\nint cmd)\r\n{\r\nstruct sonicvibes *sonic = snd_pcm_substream_chip(substream);\r\nreturn snd_sonicvibes_trigger(sonic, 2, cmd);\r\n}\r\nstatic int snd_sonicvibes_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *hw_params)\r\n{\r\nreturn snd_pcm_lib_malloc_pages(substream, params_buffer_bytes(hw_params));\r\n}\r\nstatic int snd_sonicvibes_hw_free(struct snd_pcm_substream *substream)\r\n{\r\nreturn snd_pcm_lib_free_pages(substream);\r\n}\r\nstatic int snd_sonicvibes_playback_prepare(struct snd_pcm_substream *substream)\r\n{\r\nstruct sonicvibes *sonic = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nunsigned char fmt = 0;\r\nunsigned int size = snd_pcm_lib_buffer_bytes(substream);\r\nunsigned int count = snd_pcm_lib_period_bytes(substream);\r\nsonic->p_dma_size = size;\r\ncount--;\r\nif (runtime->channels > 1)\r\nfmt |= 1;\r\nif (snd_pcm_format_width(runtime->format) == 16)\r\nfmt |= 2;\r\nsnd_sonicvibes_setfmt(sonic, ~3, fmt);\r\nsnd_sonicvibes_set_dac_rate(sonic, runtime->rate);\r\nspin_lock_irq(&sonic->reg_lock);\r\nsnd_sonicvibes_setdmaa(sonic, runtime->dma_addr, size);\r\nsnd_sonicvibes_out1(sonic, SV_IREG_DMA_A_UPPER, count >> 8);\r\nsnd_sonicvibes_out1(sonic, SV_IREG_DMA_A_LOWER, count);\r\nspin_unlock_irq(&sonic->reg_lock);\r\nreturn 0;\r\n}\r\nstatic int snd_sonicvibes_capture_prepare(struct snd_pcm_substream *substream)\r\n{\r\nstruct sonicvibes *sonic = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nunsigned char fmt = 0;\r\nunsigned int size = snd_pcm_lib_buffer_bytes(substream);\r\nunsigned int count = snd_pcm_lib_period_bytes(substream);\r\nsonic->c_dma_size = size;\r\ncount >>= 1;\r\ncount--;\r\nif (runtime->channels > 1)\r\nfmt |= 0x10;\r\nif (snd_pcm_format_width(runtime->format) == 16)\r\nfmt |= 0x20;\r\nsnd_sonicvibes_setfmt(sonic, ~0x30, fmt);\r\nsnd_sonicvibes_set_adc_rate(sonic, runtime->rate);\r\nspin_lock_irq(&sonic->reg_lock);\r\nsnd_sonicvibes_setdmac(sonic, runtime->dma_addr, size);\r\nsnd_sonicvibes_out1(sonic, SV_IREG_DMA_C_UPPER, count >> 8);\r\nsnd_sonicvibes_out1(sonic, SV_IREG_DMA_C_LOWER, count);\r\nspin_unlock_irq(&sonic->reg_lock);\r\nreturn 0;\r\n}\r\nstatic snd_pcm_uframes_t snd_sonicvibes_playback_pointer(struct snd_pcm_substream *substream)\r\n{\r\nstruct sonicvibes *sonic = snd_pcm_substream_chip(substream);\r\nsize_t ptr;\r\nif (!(sonic->enable & 1))\r\nreturn 0;\r\nptr = sonic->p_dma_size - snd_sonicvibes_getdmaa(sonic);\r\nreturn bytes_to_frames(substream->runtime, ptr);\r\n}\r\nstatic snd_pcm_uframes_t snd_sonicvibes_capture_pointer(struct snd_pcm_substream *substream)\r\n{\r\nstruct sonicvibes *sonic = snd_pcm_substream_chip(substream);\r\nsize_t ptr;\r\nif (!(sonic->enable & 2))\r\nreturn 0;\r\nptr = sonic->c_dma_size - snd_sonicvibes_getdmac(sonic);\r\nreturn bytes_to_frames(substream->runtime, ptr);\r\n}\r\nstatic int snd_sonicvibes_playback_open(struct snd_pcm_substream *substream)\r\n{\r\nstruct sonicvibes *sonic = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nsonic->mode |= SV_MODE_PLAY;\r\nsonic->playback_substream = substream;\r\nruntime->hw = snd_sonicvibes_playback;\r\nsnd_pcm_hw_rule_add(runtime, 0, SNDRV_PCM_HW_PARAM_RATE, snd_sonicvibes_hw_constraint_dac_rate, NULL, SNDRV_PCM_HW_PARAM_RATE, -1);\r\nreturn 0;\r\n}\r\nstatic int snd_sonicvibes_capture_open(struct snd_pcm_substream *substream)\r\n{\r\nstruct sonicvibes *sonic = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nsonic->mode |= SV_MODE_CAPTURE;\r\nsonic->capture_substream = substream;\r\nruntime->hw = snd_sonicvibes_capture;\r\nsnd_pcm_hw_constraint_ratdens(runtime, 0, SNDRV_PCM_HW_PARAM_RATE,\r\n&snd_sonicvibes_hw_constraints_adc_clock);\r\nreturn 0;\r\n}\r\nstatic int snd_sonicvibes_playback_close(struct snd_pcm_substream *substream)\r\n{\r\nstruct sonicvibes *sonic = snd_pcm_substream_chip(substream);\r\nsonic->playback_substream = NULL;\r\nsonic->mode &= ~SV_MODE_PLAY;\r\nreturn 0;\r\n}\r\nstatic int snd_sonicvibes_capture_close(struct snd_pcm_substream *substream)\r\n{\r\nstruct sonicvibes *sonic = snd_pcm_substream_chip(substream);\r\nsonic->capture_substream = NULL;\r\nsonic->mode &= ~SV_MODE_CAPTURE;\r\nreturn 0;\r\n}\r\nstatic int snd_sonicvibes_pcm(struct sonicvibes *sonic, int device,\r\nstruct snd_pcm **rpcm)\r\n{\r\nstruct snd_pcm *pcm;\r\nint err;\r\nif ((err = snd_pcm_new(sonic->card, "s3_86c617", device, 1, 1, &pcm)) < 0)\r\nreturn err;\r\nif (snd_BUG_ON(!pcm))\r\nreturn -EINVAL;\r\nsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &snd_sonicvibes_playback_ops);\r\nsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &snd_sonicvibes_capture_ops);\r\npcm->private_data = sonic;\r\npcm->info_flags = 0;\r\nstrcpy(pcm->name, "S3 SonicVibes");\r\nsonic->pcm = pcm;\r\nsnd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_DEV,\r\nsnd_dma_pci_data(sonic->pci), 64*1024, 128*1024);\r\nif (rpcm)\r\n*rpcm = pcm;\r\nreturn 0;\r\n}\r\nstatic int snd_sonicvibes_info_mux(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\r\n{\r\nstatic char *texts[7] = {\r\n"CD", "PCM", "Aux1", "Line", "Aux0", "Mic", "Mix"\r\n};\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;\r\nuinfo->count = 2;\r\nuinfo->value.enumerated.items = 7;\r\nif (uinfo->value.enumerated.item >= 7)\r\nuinfo->value.enumerated.item = 6;\r\nstrcpy(uinfo->value.enumerated.name, texts[uinfo->value.enumerated.item]);\r\nreturn 0;\r\n}\r\nstatic int snd_sonicvibes_get_mux(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct sonicvibes *sonic = snd_kcontrol_chip(kcontrol);\r\nspin_lock_irq(&sonic->reg_lock);\r\nucontrol->value.enumerated.item[0] = ((snd_sonicvibes_in1(sonic, SV_IREG_LEFT_ADC) & SV_RECSRC_OUT) >> 5) - 1;\r\nucontrol->value.enumerated.item[1] = ((snd_sonicvibes_in1(sonic, SV_IREG_RIGHT_ADC) & SV_RECSRC_OUT) >> 5) - 1;\r\nspin_unlock_irq(&sonic->reg_lock);\r\nreturn 0;\r\n}\r\nstatic int snd_sonicvibes_put_mux(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct sonicvibes *sonic = snd_kcontrol_chip(kcontrol);\r\nunsigned short left, right, oval1, oval2;\r\nint change;\r\nif (ucontrol->value.enumerated.item[0] >= 7 ||\r\nucontrol->value.enumerated.item[1] >= 7)\r\nreturn -EINVAL;\r\nleft = (ucontrol->value.enumerated.item[0] + 1) << 5;\r\nright = (ucontrol->value.enumerated.item[1] + 1) << 5;\r\nspin_lock_irq(&sonic->reg_lock);\r\noval1 = snd_sonicvibes_in1(sonic, SV_IREG_LEFT_ADC);\r\noval2 = snd_sonicvibes_in1(sonic, SV_IREG_RIGHT_ADC);\r\nleft = (oval1 & ~SV_RECSRC_OUT) | left;\r\nright = (oval2 & ~SV_RECSRC_OUT) | right;\r\nchange = left != oval1 || right != oval2;\r\nsnd_sonicvibes_out1(sonic, SV_IREG_LEFT_ADC, left);\r\nsnd_sonicvibes_out1(sonic, SV_IREG_RIGHT_ADC, right);\r\nspin_unlock_irq(&sonic->reg_lock);\r\nreturn change;\r\n}\r\nstatic int snd_sonicvibes_info_single(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\r\n{\r\nint mask = (kcontrol->private_value >> 16) & 0xff;\r\nuinfo->type = mask == 1 ? SNDRV_CTL_ELEM_TYPE_BOOLEAN : SNDRV_CTL_ELEM_TYPE_INTEGER;\r\nuinfo->count = 1;\r\nuinfo->value.integer.min = 0;\r\nuinfo->value.integer.max = mask;\r\nreturn 0;\r\n}\r\nstatic int snd_sonicvibes_get_single(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct sonicvibes *sonic = snd_kcontrol_chip(kcontrol);\r\nint reg = kcontrol->private_value & 0xff;\r\nint shift = (kcontrol->private_value >> 8) & 0xff;\r\nint mask = (kcontrol->private_value >> 16) & 0xff;\r\nint invert = (kcontrol->private_value >> 24) & 0xff;\r\nspin_lock_irq(&sonic->reg_lock);\r\nucontrol->value.integer.value[0] = (snd_sonicvibes_in1(sonic, reg)>> shift) & mask;\r\nspin_unlock_irq(&sonic->reg_lock);\r\nif (invert)\r\nucontrol->value.integer.value[0] = mask - ucontrol->value.integer.value[0];\r\nreturn 0;\r\n}\r\nstatic int snd_sonicvibes_put_single(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct sonicvibes *sonic = snd_kcontrol_chip(kcontrol);\r\nint reg = kcontrol->private_value & 0xff;\r\nint shift = (kcontrol->private_value >> 8) & 0xff;\r\nint mask = (kcontrol->private_value >> 16) & 0xff;\r\nint invert = (kcontrol->private_value >> 24) & 0xff;\r\nint change;\r\nunsigned short val, oval;\r\nval = (ucontrol->value.integer.value[0] & mask);\r\nif (invert)\r\nval = mask - val;\r\nval <<= shift;\r\nspin_lock_irq(&sonic->reg_lock);\r\noval = snd_sonicvibes_in1(sonic, reg);\r\nval = (oval & ~(mask << shift)) | val;\r\nchange = val != oval;\r\nsnd_sonicvibes_out1(sonic, reg, val);\r\nspin_unlock_irq(&sonic->reg_lock);\r\nreturn change;\r\n}\r\nstatic int snd_sonicvibes_info_double(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\r\n{\r\nint mask = (kcontrol->private_value >> 24) & 0xff;\r\nuinfo->type = mask == 1 ? SNDRV_CTL_ELEM_TYPE_BOOLEAN : SNDRV_CTL_ELEM_TYPE_INTEGER;\r\nuinfo->count = 2;\r\nuinfo->value.integer.min = 0;\r\nuinfo->value.integer.max = mask;\r\nreturn 0;\r\n}\r\nstatic int snd_sonicvibes_get_double(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct sonicvibes *sonic = snd_kcontrol_chip(kcontrol);\r\nint left_reg = kcontrol->private_value & 0xff;\r\nint right_reg = (kcontrol->private_value >> 8) & 0xff;\r\nint shift_left = (kcontrol->private_value >> 16) & 0x07;\r\nint shift_right = (kcontrol->private_value >> 19) & 0x07;\r\nint mask = (kcontrol->private_value >> 24) & 0xff;\r\nint invert = (kcontrol->private_value >> 22) & 1;\r\nspin_lock_irq(&sonic->reg_lock);\r\nucontrol->value.integer.value[0] = (snd_sonicvibes_in1(sonic, left_reg) >> shift_left) & mask;\r\nucontrol->value.integer.value[1] = (snd_sonicvibes_in1(sonic, right_reg) >> shift_right) & mask;\r\nspin_unlock_irq(&sonic->reg_lock);\r\nif (invert) {\r\nucontrol->value.integer.value[0] = mask - ucontrol->value.integer.value[0];\r\nucontrol->value.integer.value[1] = mask - ucontrol->value.integer.value[1];\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_sonicvibes_put_double(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct sonicvibes *sonic = snd_kcontrol_chip(kcontrol);\r\nint left_reg = kcontrol->private_value & 0xff;\r\nint right_reg = (kcontrol->private_value >> 8) & 0xff;\r\nint shift_left = (kcontrol->private_value >> 16) & 0x07;\r\nint shift_right = (kcontrol->private_value >> 19) & 0x07;\r\nint mask = (kcontrol->private_value >> 24) & 0xff;\r\nint invert = (kcontrol->private_value >> 22) & 1;\r\nint change;\r\nunsigned short val1, val2, oval1, oval2;\r\nval1 = ucontrol->value.integer.value[0] & mask;\r\nval2 = ucontrol->value.integer.value[1] & mask;\r\nif (invert) {\r\nval1 = mask - val1;\r\nval2 = mask - val2;\r\n}\r\nval1 <<= shift_left;\r\nval2 <<= shift_right;\r\nspin_lock_irq(&sonic->reg_lock);\r\noval1 = snd_sonicvibes_in1(sonic, left_reg);\r\noval2 = snd_sonicvibes_in1(sonic, right_reg);\r\nval1 = (oval1 & ~(mask << shift_left)) | val1;\r\nval2 = (oval2 & ~(mask << shift_right)) | val2;\r\nchange = val1 != oval1 || val2 != oval2;\r\nsnd_sonicvibes_out1(sonic, left_reg, val1);\r\nsnd_sonicvibes_out1(sonic, right_reg, val2);\r\nspin_unlock_irq(&sonic->reg_lock);\r\nreturn change;\r\n}\r\nstatic void snd_sonicvibes_master_free(struct snd_kcontrol *kcontrol)\r\n{\r\nstruct sonicvibes *sonic = snd_kcontrol_chip(kcontrol);\r\nsonic->master_mute = NULL;\r\nsonic->master_volume = NULL;\r\n}\r\nstatic int snd_sonicvibes_mixer(struct sonicvibes *sonic)\r\n{\r\nstruct snd_card *card;\r\nstruct snd_kcontrol *kctl;\r\nunsigned int idx;\r\nint err;\r\nif (snd_BUG_ON(!sonic || !sonic->card))\r\nreturn -EINVAL;\r\ncard = sonic->card;\r\nstrcpy(card->mixername, "S3 SonicVibes");\r\nfor (idx = 0; idx < ARRAY_SIZE(snd_sonicvibes_controls); idx++) {\r\nif ((err = snd_ctl_add(card, kctl = snd_ctl_new1(&snd_sonicvibes_controls[idx], sonic))) < 0)\r\nreturn err;\r\nswitch (idx) {\r\ncase 0:\r\ncase 1: kctl->private_free = snd_sonicvibes_master_free; break;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void snd_sonicvibes_proc_read(struct snd_info_entry *entry,\r\nstruct snd_info_buffer *buffer)\r\n{\r\nstruct sonicvibes *sonic = entry->private_data;\r\nunsigned char tmp;\r\ntmp = sonic->srs_space & 0x0f;\r\nsnd_iprintf(buffer, "SRS 3D : %s\n",\r\nsonic->srs_space & 0x80 ? "off" : "on");\r\nsnd_iprintf(buffer, "SRS Space : %s\n",\r\ntmp == 0x00 ? "100%" :\r\ntmp == 0x01 ? "75%" :\r\ntmp == 0x02 ? "50%" :\r\ntmp == 0x03 ? "25%" : "0%");\r\ntmp = sonic->srs_center & 0x0f;\r\nsnd_iprintf(buffer, "SRS Center : %s\n",\r\ntmp == 0x00 ? "100%" :\r\ntmp == 0x01 ? "75%" :\r\ntmp == 0x02 ? "50%" :\r\ntmp == 0x03 ? "25%" : "0%");\r\ntmp = sonic->wave_source & 0x03;\r\nsnd_iprintf(buffer, "WaveTable Source : %s\n",\r\ntmp == 0x00 ? "on-board ROM" :\r\ntmp == 0x01 ? "PCI bus" : "on-board ROM + PCI bus");\r\ntmp = sonic->mpu_switch;\r\nsnd_iprintf(buffer, "Onboard synth : %s\n", tmp & 0x01 ? "on" : "off");\r\nsnd_iprintf(buffer, "Ext. Rx to synth : %s\n", tmp & 0x02 ? "on" : "off");\r\nsnd_iprintf(buffer, "MIDI to ext. Tx : %s\n", tmp & 0x04 ? "on" : "off");\r\n}\r\nstatic void snd_sonicvibes_proc_init(struct sonicvibes *sonic)\r\n{\r\nstruct snd_info_entry *entry;\r\nif (! snd_card_proc_new(sonic->card, "sonicvibes", &entry))\r\nsnd_info_set_text_ops(entry, sonic, snd_sonicvibes_proc_read);\r\n}\r\nstatic int snd_sonicvibes_create_gameport(struct sonicvibes *sonic)\r\n{\r\nstruct gameport *gp;\r\nsonic->gameport = gp = gameport_allocate_port();\r\nif (!gp) {\r\nprintk(KERN_ERR "sonicvibes: cannot allocate memory for gameport\n");\r\nreturn -ENOMEM;\r\n}\r\ngameport_set_name(gp, "SonicVibes Gameport");\r\ngameport_set_phys(gp, "pci%s/gameport0", pci_name(sonic->pci));\r\ngameport_set_dev_parent(gp, &sonic->pci->dev);\r\ngp->io = sonic->game_port;\r\ngameport_register_port(gp);\r\nsnd_ctl_add(sonic->card, snd_ctl_new1(&snd_sonicvibes_game_control, sonic));\r\nreturn 0;\r\n}\r\nstatic void snd_sonicvibes_free_gameport(struct sonicvibes *sonic)\r\n{\r\nif (sonic->gameport) {\r\ngameport_unregister_port(sonic->gameport);\r\nsonic->gameport = NULL;\r\n}\r\n}\r\nstatic inline int snd_sonicvibes_create_gameport(struct sonicvibes *sonic) { return -ENOSYS; }\r\nstatic inline void snd_sonicvibes_free_gameport(struct sonicvibes *sonic) { }\r\nstatic int snd_sonicvibes_free(struct sonicvibes *sonic)\r\n{\r\nsnd_sonicvibes_free_gameport(sonic);\r\npci_write_config_dword(sonic->pci, 0x40, sonic->dmaa_port);\r\npci_write_config_dword(sonic->pci, 0x48, sonic->dmac_port);\r\nif (sonic->irq >= 0)\r\nfree_irq(sonic->irq, sonic);\r\nrelease_and_free_resource(sonic->res_dmaa);\r\nrelease_and_free_resource(sonic->res_dmac);\r\npci_release_regions(sonic->pci);\r\npci_disable_device(sonic->pci);\r\nkfree(sonic);\r\nreturn 0;\r\n}\r\nstatic int snd_sonicvibes_dev_free(struct snd_device *device)\r\n{\r\nstruct sonicvibes *sonic = device->device_data;\r\nreturn snd_sonicvibes_free(sonic);\r\n}\r\nstatic int snd_sonicvibes_create(struct snd_card *card,\r\nstruct pci_dev *pci,\r\nint reverb,\r\nint mge,\r\nstruct sonicvibes **rsonic)\r\n{\r\nstruct sonicvibes *sonic;\r\nunsigned int dmaa, dmac;\r\nint err;\r\nstatic struct snd_device_ops ops = {\r\n.dev_free = snd_sonicvibes_dev_free,\r\n};\r\n*rsonic = NULL;\r\nif ((err = pci_enable_device(pci)) < 0)\r\nreturn err;\r\nif (pci_set_dma_mask(pci, DMA_BIT_MASK(24)) < 0 ||\r\npci_set_consistent_dma_mask(pci, DMA_BIT_MASK(24)) < 0) {\r\nsnd_printk(KERN_ERR "architecture does not support 24bit PCI busmaster DMA\n");\r\npci_disable_device(pci);\r\nreturn -ENXIO;\r\n}\r\nsonic = kzalloc(sizeof(*sonic), GFP_KERNEL);\r\nif (sonic == NULL) {\r\npci_disable_device(pci);\r\nreturn -ENOMEM;\r\n}\r\nspin_lock_init(&sonic->reg_lock);\r\nsonic->card = card;\r\nsonic->pci = pci;\r\nsonic->irq = -1;\r\nif ((err = pci_request_regions(pci, "S3 SonicVibes")) < 0) {\r\nkfree(sonic);\r\npci_disable_device(pci);\r\nreturn err;\r\n}\r\nsonic->sb_port = pci_resource_start(pci, 0);\r\nsonic->enh_port = pci_resource_start(pci, 1);\r\nsonic->synth_port = pci_resource_start(pci, 2);\r\nsonic->midi_port = pci_resource_start(pci, 3);\r\nsonic->game_port = pci_resource_start(pci, 4);\r\nif (request_irq(pci->irq, snd_sonicvibes_interrupt, IRQF_SHARED,\r\nKBUILD_MODNAME, sonic)) {\r\nsnd_printk(KERN_ERR "unable to grab IRQ %d\n", pci->irq);\r\nsnd_sonicvibes_free(sonic);\r\nreturn -EBUSY;\r\n}\r\nsonic->irq = pci->irq;\r\npci_read_config_dword(pci, 0x40, &dmaa);\r\npci_read_config_dword(pci, 0x48, &dmac);\r\ndmaio &= ~0x0f;\r\ndmaa &= ~0x0f;\r\ndmac &= ~0x0f;\r\nif (!dmaa) {\r\ndmaa = dmaio;\r\ndmaio += 0x10;\r\nsnd_printk(KERN_INFO "BIOS did not allocate DDMA channel A i/o, allocated at 0x%x\n", dmaa);\r\n}\r\nif (!dmac) {\r\ndmac = dmaio;\r\ndmaio += 0x10;\r\nsnd_printk(KERN_INFO "BIOS did not allocate DDMA channel C i/o, allocated at 0x%x\n", dmac);\r\n}\r\npci_write_config_dword(pci, 0x40, dmaa);\r\npci_write_config_dword(pci, 0x48, dmac);\r\nif ((sonic->res_dmaa = request_region(dmaa, 0x10, "S3 SonicVibes DDMA-A")) == NULL) {\r\nsnd_sonicvibes_free(sonic);\r\nsnd_printk(KERN_ERR "unable to grab DDMA-A port at 0x%x-0x%x\n", dmaa, dmaa + 0x10 - 1);\r\nreturn -EBUSY;\r\n}\r\nif ((sonic->res_dmac = request_region(dmac, 0x10, "S3 SonicVibes DDMA-C")) == NULL) {\r\nsnd_sonicvibes_free(sonic);\r\nsnd_printk(KERN_ERR "unable to grab DDMA-C port at 0x%x-0x%x\n", dmac, dmac + 0x10 - 1);\r\nreturn -EBUSY;\r\n}\r\npci_read_config_dword(pci, 0x40, &sonic->dmaa_port);\r\npci_read_config_dword(pci, 0x48, &sonic->dmac_port);\r\nsonic->dmaa_port &= ~0x0f;\r\nsonic->dmac_port &= ~0x0f;\r\npci_write_config_dword(pci, 0x40, sonic->dmaa_port | 9);\r\npci_write_config_dword(pci, 0x48, sonic->dmac_port | 9);\r\noutb(SV_RESET, SV_REG(sonic, CONTROL));\r\nudelay(100);\r\noutb(0, SV_REG(sonic, CONTROL));\r\nudelay(100);\r\noutb(SV_ENHANCED | SV_INTA | (reverb ? SV_REVERB : 0), SV_REG(sonic, CONTROL));\r\ninb(SV_REG(sonic, STATUS));\r\n#if 1\r\nsnd_sonicvibes_out(sonic, SV_IREG_DRIVE_CTRL, 0);\r\n#else\r\nsnd_sonicvibes_out(sonic, SV_IREG_DRIVE_CTRL, 0x40);\r\n#endif\r\nsnd_sonicvibes_out(sonic, SV_IREG_PC_ENABLE, sonic->enable = 0);\r\noutb(sonic->irqmask = ~(SV_DMAA_MASK | SV_DMAC_MASK | SV_UD_MASK), SV_REG(sonic, IRQMASK));\r\ninb(SV_REG(sonic, STATUS));\r\nsnd_sonicvibes_out(sonic, SV_IREG_ADC_CLOCK, 0);\r\nsnd_sonicvibes_out(sonic, SV_IREG_ANALOG_POWER, 0);\r\nsnd_sonicvibes_out(sonic, SV_IREG_DIGITAL_POWER, 0);\r\nsnd_sonicvibes_setpll(sonic, SV_IREG_ADC_PLL, 8000);\r\nsnd_sonicvibes_out(sonic, SV_IREG_SRS_SPACE, sonic->srs_space = 0x80);\r\nsnd_sonicvibes_out(sonic, SV_IREG_SRS_CENTER, sonic->srs_center = 0x00);\r\nsnd_sonicvibes_out(sonic, SV_IREG_MPU401, sonic->mpu_switch = 0x05);\r\nsnd_sonicvibes_out(sonic, SV_IREG_WAVE_SOURCE, sonic->wave_source = 0x00);\r\nsnd_sonicvibes_out(sonic, SV_IREG_PCM_RATE_LOW, (8000 * 65536 / SV_FULLRATE) & 0xff);\r\nsnd_sonicvibes_out(sonic, SV_IREG_PCM_RATE_HIGH, ((8000 * 65536 / SV_FULLRATE) >> 8) & 0xff);\r\nsnd_sonicvibes_out(sonic, SV_IREG_LEFT_ADC, mge ? 0xd0 : 0xc0);\r\nsnd_sonicvibes_out(sonic, SV_IREG_RIGHT_ADC, 0xc0);\r\nsnd_sonicvibes_out(sonic, SV_IREG_LEFT_AUX1, 0x9f);\r\nsnd_sonicvibes_out(sonic, SV_IREG_RIGHT_AUX1, 0x9f);\r\nsnd_sonicvibes_out(sonic, SV_IREG_LEFT_CD, 0x9f);\r\nsnd_sonicvibes_out(sonic, SV_IREG_RIGHT_CD, 0x9f);\r\nsnd_sonicvibes_out(sonic, SV_IREG_LEFT_LINE, 0x9f);\r\nsnd_sonicvibes_out(sonic, SV_IREG_RIGHT_LINE, 0x9f);\r\nsnd_sonicvibes_out(sonic, SV_IREG_MIC, 0x8f);\r\nsnd_sonicvibes_out(sonic, SV_IREG_LEFT_SYNTH, 0x9f);\r\nsnd_sonicvibes_out(sonic, SV_IREG_RIGHT_SYNTH, 0x9f);\r\nsnd_sonicvibes_out(sonic, SV_IREG_LEFT_AUX2, 0x9f);\r\nsnd_sonicvibes_out(sonic, SV_IREG_RIGHT_AUX2, 0x9f);\r\nsnd_sonicvibes_out(sonic, SV_IREG_LEFT_ANALOG, 0x9f);\r\nsnd_sonicvibes_out(sonic, SV_IREG_RIGHT_ANALOG, 0x9f);\r\nsnd_sonicvibes_out(sonic, SV_IREG_LEFT_PCM, 0xbf);\r\nsnd_sonicvibes_out(sonic, SV_IREG_RIGHT_PCM, 0xbf);\r\nsnd_sonicvibes_out(sonic, SV_IREG_ADC_OUTPUT_CTRL, 0xfc);\r\n#if 0\r\nsnd_sonicvibes_debug(sonic);\r\n#endif\r\nsonic->revision = snd_sonicvibes_in(sonic, SV_IREG_REVISION);\r\nif ((err = snd_device_new(card, SNDRV_DEV_LOWLEVEL, sonic, &ops)) < 0) {\r\nsnd_sonicvibes_free(sonic);\r\nreturn err;\r\n}\r\nsnd_sonicvibes_proc_init(sonic);\r\nsnd_card_set_dev(card, &pci->dev);\r\n*rsonic = sonic;\r\nreturn 0;\r\n}\r\nstatic int snd_sonicvibes_midi_input_open(struct snd_mpu401 * mpu)\r\n{\r\nstruct sonicvibes *sonic = mpu->private_data;\r\noutb(sonic->irqmask &= ~SV_MIDI_MASK, SV_REG(sonic, IRQMASK));\r\nreturn 0;\r\n}\r\nstatic void snd_sonicvibes_midi_input_close(struct snd_mpu401 * mpu)\r\n{\r\nstruct sonicvibes *sonic = mpu->private_data;\r\noutb(sonic->irqmask |= SV_MIDI_MASK, SV_REG(sonic, IRQMASK));\r\n}\r\nstatic int snd_sonicvibes_midi(struct sonicvibes *sonic,\r\nstruct snd_rawmidi *rmidi)\r\n{\r\nstruct snd_mpu401 * mpu = rmidi->private_data;\r\nstruct snd_card *card = sonic->card;\r\nstruct snd_rawmidi_str *dir;\r\nunsigned int idx;\r\nint err;\r\nmpu->private_data = sonic;\r\nmpu->open_input = snd_sonicvibes_midi_input_open;\r\nmpu->close_input = snd_sonicvibes_midi_input_close;\r\ndir = &rmidi->streams[SNDRV_RAWMIDI_STREAM_OUTPUT];\r\nfor (idx = 0; idx < ARRAY_SIZE(snd_sonicvibes_midi_controls); idx++)\r\nif ((err = snd_ctl_add(card, snd_ctl_new1(&snd_sonicvibes_midi_controls[idx], sonic))) < 0)\r\nreturn err;\r\nreturn 0;\r\n}\r\nstatic int snd_sonic_probe(struct pci_dev *pci,\r\nconst struct pci_device_id *pci_id)\r\n{\r\nstatic int dev;\r\nstruct snd_card *card;\r\nstruct sonicvibes *sonic;\r\nstruct snd_rawmidi *midi_uart;\r\nstruct snd_opl3 *opl3;\r\nint idx, err;\r\nif (dev >= SNDRV_CARDS)\r\nreturn -ENODEV;\r\nif (!enable[dev]) {\r\ndev++;\r\nreturn -ENOENT;\r\n}\r\nerr = snd_card_create(index[dev], id[dev], THIS_MODULE, 0, &card);\r\nif (err < 0)\r\nreturn err;\r\nfor (idx = 0; idx < 5; idx++) {\r\nif (pci_resource_start(pci, idx) == 0 ||\r\n!(pci_resource_flags(pci, idx) & IORESOURCE_IO)) {\r\nsnd_card_free(card);\r\nreturn -ENODEV;\r\n}\r\n}\r\nif ((err = snd_sonicvibes_create(card, pci,\r\nreverb[dev] ? 1 : 0,\r\nmge[dev] ? 1 : 0,\r\n&sonic)) < 0) {\r\nsnd_card_free(card);\r\nreturn err;\r\n}\r\nstrcpy(card->driver, "SonicVibes");\r\nstrcpy(card->shortname, "S3 SonicVibes");\r\nsprintf(card->longname, "%s rev %i at 0x%llx, irq %i",\r\ncard->shortname,\r\nsonic->revision,\r\n(unsigned long long)pci_resource_start(pci, 1),\r\nsonic->irq);\r\nif ((err = snd_sonicvibes_pcm(sonic, 0, NULL)) < 0) {\r\nsnd_card_free(card);\r\nreturn err;\r\n}\r\nif ((err = snd_sonicvibes_mixer(sonic)) < 0) {\r\nsnd_card_free(card);\r\nreturn err;\r\n}\r\nif ((err = snd_mpu401_uart_new(card, 0, MPU401_HW_SONICVIBES,\r\nsonic->midi_port,\r\nMPU401_INFO_INTEGRATED |\r\nMPU401_INFO_IRQ_HOOK,\r\n-1, &midi_uart)) < 0) {\r\nsnd_card_free(card);\r\nreturn err;\r\n}\r\nsnd_sonicvibes_midi(sonic, midi_uart);\r\nif ((err = snd_opl3_create(card, sonic->synth_port,\r\nsonic->synth_port + 2,\r\nOPL3_HW_OPL3_SV, 1, &opl3)) < 0) {\r\nsnd_card_free(card);\r\nreturn err;\r\n}\r\nif ((err = snd_opl3_hwdep_new(opl3, 0, 1, NULL)) < 0) {\r\nsnd_card_free(card);\r\nreturn err;\r\n}\r\nsnd_sonicvibes_create_gameport(sonic);\r\nif ((err = snd_card_register(card)) < 0) {\r\nsnd_card_free(card);\r\nreturn err;\r\n}\r\npci_set_drvdata(pci, card);\r\ndev++;\r\nreturn 0;\r\n}\r\nstatic void snd_sonic_remove(struct pci_dev *pci)\r\n{\r\nsnd_card_free(pci_get_drvdata(pci));\r\npci_set_drvdata(pci, NULL);\r\n}
