static int\r\nnv50_instobj_ctor(struct nouveau_object *parent, struct nouveau_object *engine,\r\nstruct nouveau_oclass *oclass, void *data, u32 size,\r\nstruct nouveau_object **pobject)\r\n{\r\nstruct nouveau_fb *pfb = nouveau_fb(parent);\r\nstruct nv50_instobj_priv *node;\r\nu32 align = (unsigned long)data;\r\nint ret;\r\nsize = max((size + 4095) & ~4095, (u32)4096);\r\nalign = max((align + 4095) & ~4095, (u32)4096);\r\nret = nouveau_instobj_create(parent, engine, oclass, &node);\r\n*pobject = nv_object(node);\r\nif (ret)\r\nreturn ret;\r\nret = pfb->ram.get(pfb, size, align, 0, 0x800, &node->mem);\r\nif (ret)\r\nreturn ret;\r\nnode->base.addr = node->mem->offset;\r\nnode->base.size = node->mem->size << 12;\r\nnode->mem->page_shift = 12;\r\nreturn 0;\r\n}\r\nstatic void\r\nnv50_instobj_dtor(struct nouveau_object *object)\r\n{\r\nstruct nv50_instobj_priv *node = (void *)object;\r\nstruct nouveau_fb *pfb = nouveau_fb(object);\r\npfb->ram.put(pfb, &node->mem);\r\nnouveau_instobj_destroy(&node->base);\r\n}\r\nstatic u32\r\nnv50_instobj_rd32(struct nouveau_object *object, u64 offset)\r\n{\r\nstruct nv50_instmem_priv *priv = (void *)object->engine;\r\nstruct nv50_instobj_priv *node = (void *)object;\r\nunsigned long flags;\r\nu64 base = (node->mem->offset + offset) & 0xffffff00000ULL;\r\nu64 addr = (node->mem->offset + offset) & 0x000000fffffULL;\r\nu32 data;\r\nspin_lock_irqsave(&priv->lock, flags);\r\nif (unlikely(priv->addr != base)) {\r\nnv_wr32(priv, 0x001700, base >> 16);\r\npriv->addr = base;\r\n}\r\ndata = nv_rd32(priv, 0x700000 + addr);\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\nreturn data;\r\n}\r\nstatic void\r\nnv50_instobj_wr32(struct nouveau_object *object, u64 offset, u32 data)\r\n{\r\nstruct nv50_instmem_priv *priv = (void *)object->engine;\r\nstruct nv50_instobj_priv *node = (void *)object;\r\nunsigned long flags;\r\nu64 base = (node->mem->offset + offset) & 0xffffff00000ULL;\r\nu64 addr = (node->mem->offset + offset) & 0x000000fffffULL;\r\nspin_lock_irqsave(&priv->lock, flags);\r\nif (unlikely(priv->addr != base)) {\r\nnv_wr32(priv, 0x001700, base >> 16);\r\npriv->addr = base;\r\n}\r\nnv_wr32(priv, 0x700000 + addr, data);\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\n}\r\nstatic int\r\nnv50_instmem_alloc(struct nouveau_instmem *imem, struct nouveau_object *parent,\r\nu32 size, u32 align, struct nouveau_object **pobject)\r\n{\r\nstruct nouveau_object *engine = nv_object(imem);\r\nreturn nouveau_object_ctor(parent, engine, &nv50_instobj_oclass,\r\n(void *)(unsigned long)align, size, pobject);\r\n}\r\nstatic int\r\nnv50_instmem_ctor(struct nouveau_object *parent, struct nouveau_object *engine,\r\nstruct nouveau_oclass *oclass, void *data, u32 size,\r\nstruct nouveau_object **pobject)\r\n{\r\nstruct nv50_instmem_priv *priv;\r\nint ret;\r\nret = nouveau_instmem_create(parent, engine, oclass, &priv);\r\n*pobject = nv_object(priv);\r\nif (ret)\r\nreturn ret;\r\nspin_lock_init(&priv->lock);\r\npriv->base.alloc = nv50_instmem_alloc;\r\nreturn 0;\r\n}\r\nstatic int\r\nnv50_instmem_fini(struct nouveau_object *object, bool suspend)\r\n{\r\nstruct nv50_instmem_priv *priv = (void *)object;\r\npriv->addr = ~0ULL;\r\nreturn nouveau_instmem_fini(&priv->base, suspend);\r\n}
