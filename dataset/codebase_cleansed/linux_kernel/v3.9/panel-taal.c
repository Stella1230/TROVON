static void hw_guard_start(struct taal_data *td, int guard_msec)\r\n{\r\ntd->hw_guard_wait = msecs_to_jiffies(guard_msec);\r\ntd->hw_guard_end = jiffies + td->hw_guard_wait;\r\n}\r\nstatic void hw_guard_wait(struct taal_data *td)\r\n{\r\nunsigned long wait = td->hw_guard_end - jiffies;\r\nif ((long)wait > 0 && wait <= td->hw_guard_wait) {\r\nset_current_state(TASK_UNINTERRUPTIBLE);\r\nschedule_timeout(wait);\r\n}\r\n}\r\nstatic int taal_dcs_read_1(struct taal_data *td, u8 dcs_cmd, u8 *data)\r\n{\r\nint r;\r\nu8 buf[1];\r\nr = dsi_vc_dcs_read(td->dssdev, td->channel, dcs_cmd, buf, 1);\r\nif (r < 0)\r\nreturn r;\r\n*data = buf[0];\r\nreturn 0;\r\n}\r\nstatic int taal_dcs_write_0(struct taal_data *td, u8 dcs_cmd)\r\n{\r\nreturn dsi_vc_dcs_write(td->dssdev, td->channel, &dcs_cmd, 1);\r\n}\r\nstatic int taal_dcs_write_1(struct taal_data *td, u8 dcs_cmd, u8 param)\r\n{\r\nu8 buf[2];\r\nbuf[0] = dcs_cmd;\r\nbuf[1] = param;\r\nreturn dsi_vc_dcs_write(td->dssdev, td->channel, buf, 2);\r\n}\r\nstatic int taal_sleep_in(struct taal_data *td)\r\n{\r\nu8 cmd;\r\nint r;\r\nhw_guard_wait(td);\r\ncmd = MIPI_DCS_ENTER_SLEEP_MODE;\r\nr = dsi_vc_dcs_write_nosync(td->dssdev, td->channel, &cmd, 1);\r\nif (r)\r\nreturn r;\r\nhw_guard_start(td, 120);\r\nif (td->panel_config->sleep.sleep_in)\r\nmsleep(td->panel_config->sleep.sleep_in);\r\nreturn 0;\r\n}\r\nstatic int taal_sleep_out(struct taal_data *td)\r\n{\r\nint r;\r\nhw_guard_wait(td);\r\nr = taal_dcs_write_0(td, MIPI_DCS_EXIT_SLEEP_MODE);\r\nif (r)\r\nreturn r;\r\nhw_guard_start(td, 120);\r\nif (td->panel_config->sleep.sleep_out)\r\nmsleep(td->panel_config->sleep.sleep_out);\r\nreturn 0;\r\n}\r\nstatic int taal_get_id(struct taal_data *td, u8 *id1, u8 *id2, u8 *id3)\r\n{\r\nint r;\r\nr = taal_dcs_read_1(td, DCS_GET_ID1, id1);\r\nif (r)\r\nreturn r;\r\nr = taal_dcs_read_1(td, DCS_GET_ID2, id2);\r\nif (r)\r\nreturn r;\r\nr = taal_dcs_read_1(td, DCS_GET_ID3, id3);\r\nif (r)\r\nreturn r;\r\nreturn 0;\r\n}\r\nstatic int taal_set_addr_mode(struct taal_data *td, u8 rotate, bool mirror)\r\n{\r\nint r;\r\nu8 mode;\r\nint b5, b6, b7;\r\nr = taal_dcs_read_1(td, MIPI_DCS_GET_ADDRESS_MODE, &mode);\r\nif (r)\r\nreturn r;\r\nswitch (rotate) {\r\ndefault:\r\ncase 0:\r\nb7 = 0;\r\nb6 = 0;\r\nb5 = 0;\r\nbreak;\r\ncase 1:\r\nb7 = 0;\r\nb6 = 1;\r\nb5 = 1;\r\nbreak;\r\ncase 2:\r\nb7 = 1;\r\nb6 = 1;\r\nb5 = 0;\r\nbreak;\r\ncase 3:\r\nb7 = 1;\r\nb6 = 0;\r\nb5 = 1;\r\nbreak;\r\n}\r\nif (mirror)\r\nb6 = !b6;\r\nmode &= ~((1<<7) | (1<<6) | (1<<5));\r\nmode |= (b7 << 7) | (b6 << 6) | (b5 << 5);\r\nreturn taal_dcs_write_1(td, MIPI_DCS_SET_ADDRESS_MODE, mode);\r\n}\r\nstatic int taal_set_update_window(struct taal_data *td,\r\nu16 x, u16 y, u16 w, u16 h)\r\n{\r\nint r;\r\nu16 x1 = x;\r\nu16 x2 = x + w - 1;\r\nu16 y1 = y;\r\nu16 y2 = y + h - 1;\r\nu8 buf[5];\r\nbuf[0] = MIPI_DCS_SET_COLUMN_ADDRESS;\r\nbuf[1] = (x1 >> 8) & 0xff;\r\nbuf[2] = (x1 >> 0) & 0xff;\r\nbuf[3] = (x2 >> 8) & 0xff;\r\nbuf[4] = (x2 >> 0) & 0xff;\r\nr = dsi_vc_dcs_write_nosync(td->dssdev, td->channel, buf, sizeof(buf));\r\nif (r)\r\nreturn r;\r\nbuf[0] = MIPI_DCS_SET_PAGE_ADDRESS;\r\nbuf[1] = (y1 >> 8) & 0xff;\r\nbuf[2] = (y1 >> 0) & 0xff;\r\nbuf[3] = (y2 >> 8) & 0xff;\r\nbuf[4] = (y2 >> 0) & 0xff;\r\nr = dsi_vc_dcs_write_nosync(td->dssdev, td->channel, buf, sizeof(buf));\r\nif (r)\r\nreturn r;\r\ndsi_vc_send_bta_sync(td->dssdev, td->channel);\r\nreturn r;\r\n}\r\nstatic void taal_queue_esd_work(struct omap_dss_device *dssdev)\r\n{\r\nstruct taal_data *td = dev_get_drvdata(&dssdev->dev);\r\nif (td->esd_interval > 0)\r\nqueue_delayed_work(td->workqueue, &td->esd_work,\r\nmsecs_to_jiffies(td->esd_interval));\r\n}\r\nstatic void taal_cancel_esd_work(struct omap_dss_device *dssdev)\r\n{\r\nstruct taal_data *td = dev_get_drvdata(&dssdev->dev);\r\ncancel_delayed_work(&td->esd_work);\r\n}\r\nstatic void taal_queue_ulps_work(struct omap_dss_device *dssdev)\r\n{\r\nstruct taal_data *td = dev_get_drvdata(&dssdev->dev);\r\nif (td->ulps_timeout > 0)\r\nqueue_delayed_work(td->workqueue, &td->ulps_work,\r\nmsecs_to_jiffies(td->ulps_timeout));\r\n}\r\nstatic void taal_cancel_ulps_work(struct omap_dss_device *dssdev)\r\n{\r\nstruct taal_data *td = dev_get_drvdata(&dssdev->dev);\r\ncancel_delayed_work(&td->ulps_work);\r\n}\r\nstatic int taal_enter_ulps(struct omap_dss_device *dssdev)\r\n{\r\nstruct taal_data *td = dev_get_drvdata(&dssdev->dev);\r\nint r;\r\nif (td->ulps_enabled)\r\nreturn 0;\r\ntaal_cancel_ulps_work(dssdev);\r\nr = _taal_enable_te(dssdev, false);\r\nif (r)\r\ngoto err;\r\nif (gpio_is_valid(td->ext_te_gpio))\r\ndisable_irq(gpio_to_irq(td->ext_te_gpio));\r\nomapdss_dsi_display_disable(dssdev, false, true);\r\ntd->ulps_enabled = true;\r\nreturn 0;\r\nerr:\r\ndev_err(&dssdev->dev, "enter ULPS failed");\r\ntaal_panel_reset(dssdev);\r\ntd->ulps_enabled = false;\r\ntaal_queue_ulps_work(dssdev);\r\nreturn r;\r\n}\r\nstatic int taal_exit_ulps(struct omap_dss_device *dssdev)\r\n{\r\nstruct taal_data *td = dev_get_drvdata(&dssdev->dev);\r\nint r;\r\nif (!td->ulps_enabled)\r\nreturn 0;\r\nr = omapdss_dsi_display_enable(dssdev);\r\nif (r) {\r\ndev_err(&dssdev->dev, "failed to enable DSI\n");\r\ngoto err1;\r\n}\r\nomapdss_dsi_vc_enable_hs(dssdev, td->channel, true);\r\nr = _taal_enable_te(dssdev, true);\r\nif (r) {\r\ndev_err(&dssdev->dev, "failed to re-enable TE");\r\ngoto err2;\r\n}\r\nif (gpio_is_valid(td->ext_te_gpio))\r\nenable_irq(gpio_to_irq(td->ext_te_gpio));\r\ntaal_queue_ulps_work(dssdev);\r\ntd->ulps_enabled = false;\r\nreturn 0;\r\nerr2:\r\ndev_err(&dssdev->dev, "failed to exit ULPS");\r\nr = taal_panel_reset(dssdev);\r\nif (!r) {\r\nif (gpio_is_valid(td->ext_te_gpio))\r\nenable_irq(gpio_to_irq(td->ext_te_gpio));\r\ntd->ulps_enabled = false;\r\n}\r\nerr1:\r\ntaal_queue_ulps_work(dssdev);\r\nreturn r;\r\n}\r\nstatic int taal_wake_up(struct omap_dss_device *dssdev)\r\n{\r\nstruct taal_data *td = dev_get_drvdata(&dssdev->dev);\r\nif (td->ulps_enabled)\r\nreturn taal_exit_ulps(dssdev);\r\ntaal_cancel_ulps_work(dssdev);\r\ntaal_queue_ulps_work(dssdev);\r\nreturn 0;\r\n}\r\nstatic int taal_bl_update_status(struct backlight_device *dev)\r\n{\r\nstruct omap_dss_device *dssdev = dev_get_drvdata(&dev->dev);\r\nstruct taal_data *td = dev_get_drvdata(&dssdev->dev);\r\nint r;\r\nint level;\r\nif (dev->props.fb_blank == FB_BLANK_UNBLANK &&\r\ndev->props.power == FB_BLANK_UNBLANK)\r\nlevel = dev->props.brightness;\r\nelse\r\nlevel = 0;\r\ndev_dbg(&dssdev->dev, "update brightness to %d\n", level);\r\nmutex_lock(&td->lock);\r\nif (td->enabled) {\r\ndsi_bus_lock(dssdev);\r\nr = taal_wake_up(dssdev);\r\nif (!r)\r\nr = taal_dcs_write_1(td, DCS_BRIGHTNESS, level);\r\ndsi_bus_unlock(dssdev);\r\n} else {\r\nr = 0;\r\n}\r\nmutex_unlock(&td->lock);\r\nreturn r;\r\n}\r\nstatic int taal_bl_get_intensity(struct backlight_device *dev)\r\n{\r\nif (dev->props.fb_blank == FB_BLANK_UNBLANK &&\r\ndev->props.power == FB_BLANK_UNBLANK)\r\nreturn dev->props.brightness;\r\nreturn 0;\r\n}\r\nstatic void taal_get_resolution(struct omap_dss_device *dssdev,\r\nu16 *xres, u16 *yres)\r\n{\r\nstruct taal_data *td = dev_get_drvdata(&dssdev->dev);\r\nif (td->rotate == 0 || td->rotate == 2) {\r\n*xres = dssdev->panel.timings.x_res;\r\n*yres = dssdev->panel.timings.y_res;\r\n} else {\r\n*yres = dssdev->panel.timings.x_res;\r\n*xres = dssdev->panel.timings.y_res;\r\n}\r\n}\r\nstatic ssize_t taal_num_errors_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct omap_dss_device *dssdev = to_dss_device(dev);\r\nstruct taal_data *td = dev_get_drvdata(&dssdev->dev);\r\nu8 errors = 0;\r\nint r;\r\nmutex_lock(&td->lock);\r\nif (td->enabled) {\r\ndsi_bus_lock(dssdev);\r\nr = taal_wake_up(dssdev);\r\nif (!r)\r\nr = taal_dcs_read_1(td, DCS_READ_NUM_ERRORS, &errors);\r\ndsi_bus_unlock(dssdev);\r\n} else {\r\nr = -ENODEV;\r\n}\r\nmutex_unlock(&td->lock);\r\nif (r)\r\nreturn r;\r\nreturn snprintf(buf, PAGE_SIZE, "%d\n", errors);\r\n}\r\nstatic ssize_t taal_hw_revision_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct omap_dss_device *dssdev = to_dss_device(dev);\r\nstruct taal_data *td = dev_get_drvdata(&dssdev->dev);\r\nu8 id1, id2, id3;\r\nint r;\r\nmutex_lock(&td->lock);\r\nif (td->enabled) {\r\ndsi_bus_lock(dssdev);\r\nr = taal_wake_up(dssdev);\r\nif (!r)\r\nr = taal_get_id(td, &id1, &id2, &id3);\r\ndsi_bus_unlock(dssdev);\r\n} else {\r\nr = -ENODEV;\r\n}\r\nmutex_unlock(&td->lock);\r\nif (r)\r\nreturn r;\r\nreturn snprintf(buf, PAGE_SIZE, "%02x.%02x.%02x\n", id1, id2, id3);\r\n}\r\nstatic ssize_t show_cabc_mode(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct omap_dss_device *dssdev = to_dss_device(dev);\r\nstruct taal_data *td = dev_get_drvdata(&dssdev->dev);\r\nconst char *mode_str;\r\nint mode;\r\nint len;\r\nmode = td->cabc_mode;\r\nmode_str = "unknown";\r\nif (mode >= 0 && mode < ARRAY_SIZE(cabc_modes))\r\nmode_str = cabc_modes[mode];\r\nlen = snprintf(buf, PAGE_SIZE, "%s\n", mode_str);\r\nreturn len < PAGE_SIZE - 1 ? len : PAGE_SIZE - 1;\r\n}\r\nstatic ssize_t store_cabc_mode(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct omap_dss_device *dssdev = to_dss_device(dev);\r\nstruct taal_data *td = dev_get_drvdata(&dssdev->dev);\r\nint i;\r\nint r;\r\nfor (i = 0; i < ARRAY_SIZE(cabc_modes); i++) {\r\nif (sysfs_streq(cabc_modes[i], buf))\r\nbreak;\r\n}\r\nif (i == ARRAY_SIZE(cabc_modes))\r\nreturn -EINVAL;\r\nmutex_lock(&td->lock);\r\nif (td->enabled) {\r\ndsi_bus_lock(dssdev);\r\nif (!td->cabc_broken) {\r\nr = taal_wake_up(dssdev);\r\nif (r)\r\ngoto err;\r\nr = taal_dcs_write_1(td, DCS_WRITE_CABC, i);\r\nif (r)\r\ngoto err;\r\n}\r\ndsi_bus_unlock(dssdev);\r\n}\r\ntd->cabc_mode = i;\r\nmutex_unlock(&td->lock);\r\nreturn count;\r\nerr:\r\ndsi_bus_unlock(dssdev);\r\nmutex_unlock(&td->lock);\r\nreturn r;\r\n}\r\nstatic ssize_t show_cabc_available_modes(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nint len;\r\nint i;\r\nfor (i = 0, len = 0;\r\nlen < PAGE_SIZE && i < ARRAY_SIZE(cabc_modes); i++)\r\nlen += snprintf(&buf[len], PAGE_SIZE - len, "%s%s%s",\r\ni ? " " : "", cabc_modes[i],\r\ni == ARRAY_SIZE(cabc_modes) - 1 ? "\n" : "");\r\nreturn len < PAGE_SIZE ? len : PAGE_SIZE - 1;\r\n}\r\nstatic ssize_t taal_store_esd_interval(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct omap_dss_device *dssdev = to_dss_device(dev);\r\nstruct taal_data *td = dev_get_drvdata(&dssdev->dev);\r\nunsigned long t;\r\nint r;\r\nr = strict_strtoul(buf, 10, &t);\r\nif (r)\r\nreturn r;\r\nmutex_lock(&td->lock);\r\ntaal_cancel_esd_work(dssdev);\r\ntd->esd_interval = t;\r\nif (td->enabled)\r\ntaal_queue_esd_work(dssdev);\r\nmutex_unlock(&td->lock);\r\nreturn count;\r\n}\r\nstatic ssize_t taal_show_esd_interval(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct omap_dss_device *dssdev = to_dss_device(dev);\r\nstruct taal_data *td = dev_get_drvdata(&dssdev->dev);\r\nunsigned t;\r\nmutex_lock(&td->lock);\r\nt = td->esd_interval;\r\nmutex_unlock(&td->lock);\r\nreturn snprintf(buf, PAGE_SIZE, "%u\n", t);\r\n}\r\nstatic ssize_t taal_store_ulps(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct omap_dss_device *dssdev = to_dss_device(dev);\r\nstruct taal_data *td = dev_get_drvdata(&dssdev->dev);\r\nunsigned long t;\r\nint r;\r\nr = strict_strtoul(buf, 10, &t);\r\nif (r)\r\nreturn r;\r\nmutex_lock(&td->lock);\r\nif (td->enabled) {\r\ndsi_bus_lock(dssdev);\r\nif (t)\r\nr = taal_enter_ulps(dssdev);\r\nelse\r\nr = taal_wake_up(dssdev);\r\ndsi_bus_unlock(dssdev);\r\n}\r\nmutex_unlock(&td->lock);\r\nif (r)\r\nreturn r;\r\nreturn count;\r\n}\r\nstatic ssize_t taal_show_ulps(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct omap_dss_device *dssdev = to_dss_device(dev);\r\nstruct taal_data *td = dev_get_drvdata(&dssdev->dev);\r\nunsigned t;\r\nmutex_lock(&td->lock);\r\nt = td->ulps_enabled;\r\nmutex_unlock(&td->lock);\r\nreturn snprintf(buf, PAGE_SIZE, "%u\n", t);\r\n}\r\nstatic ssize_t taal_store_ulps_timeout(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct omap_dss_device *dssdev = to_dss_device(dev);\r\nstruct taal_data *td = dev_get_drvdata(&dssdev->dev);\r\nunsigned long t;\r\nint r;\r\nr = strict_strtoul(buf, 10, &t);\r\nif (r)\r\nreturn r;\r\nmutex_lock(&td->lock);\r\ntd->ulps_timeout = t;\r\nif (td->enabled) {\r\ndsi_bus_lock(dssdev);\r\nr = taal_wake_up(dssdev);\r\ndsi_bus_unlock(dssdev);\r\n}\r\nmutex_unlock(&td->lock);\r\nif (r)\r\nreturn r;\r\nreturn count;\r\n}\r\nstatic ssize_t taal_show_ulps_timeout(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct omap_dss_device *dssdev = to_dss_device(dev);\r\nstruct taal_data *td = dev_get_drvdata(&dssdev->dev);\r\nunsigned t;\r\nmutex_lock(&td->lock);\r\nt = td->ulps_timeout;\r\nmutex_unlock(&td->lock);\r\nreturn snprintf(buf, PAGE_SIZE, "%u\n", t);\r\n}\r\nstatic void taal_hw_reset(struct omap_dss_device *dssdev)\r\n{\r\nstruct taal_data *td = dev_get_drvdata(&dssdev->dev);\r\nif (!gpio_is_valid(td->reset_gpio))\r\nreturn;\r\ngpio_set_value(td->reset_gpio, 1);\r\nif (td->panel_config->reset_sequence.high)\r\nudelay(td->panel_config->reset_sequence.high);\r\ngpio_set_value(td->reset_gpio, 0);\r\nif (td->panel_config->reset_sequence.low)\r\nudelay(td->panel_config->reset_sequence.low);\r\ngpio_set_value(td->reset_gpio, 1);\r\nif (td->panel_config->sleep.hw_reset)\r\nmsleep(td->panel_config->sleep.hw_reset);\r\n}\r\nstatic void taal_probe_pdata(struct taal_data *td,\r\nconst struct nokia_dsi_panel_data *pdata)\r\n{\r\ntd->reset_gpio = pdata->reset_gpio;\r\nif (pdata->use_ext_te)\r\ntd->ext_te_gpio = pdata->ext_te_gpio;\r\nelse\r\ntd->ext_te_gpio = -1;\r\ntd->esd_interval = pdata->esd_interval;\r\ntd->ulps_timeout = pdata->ulps_timeout;\r\ntd->use_dsi_backlight = pdata->use_dsi_backlight;\r\ntd->pin_config = pdata->pin_config;\r\n}\r\nstatic int taal_probe(struct omap_dss_device *dssdev)\r\n{\r\nstruct backlight_properties props;\r\nstruct taal_data *td;\r\nstruct backlight_device *bldev = NULL;\r\nint r, i;\r\nconst char *panel_name;\r\ndev_dbg(&dssdev->dev, "probe\n");\r\ntd = devm_kzalloc(&dssdev->dev, sizeof(*td), GFP_KERNEL);\r\nif (!td)\r\nreturn -ENOMEM;\r\ndev_set_drvdata(&dssdev->dev, td);\r\ntd->dssdev = dssdev;\r\nif (dssdev->data) {\r\nconst struct nokia_dsi_panel_data *pdata = dssdev->data;\r\ntaal_probe_pdata(td, pdata);\r\npanel_name = pdata->name;\r\n} else {\r\nreturn -ENODEV;\r\n}\r\nif (panel_name == NULL)\r\nreturn -EINVAL;\r\nfor (i = 0; i < ARRAY_SIZE(panel_configs); i++) {\r\nif (strcmp(panel_name, panel_configs[i].name) == 0) {\r\ntd->panel_config = &panel_configs[i];\r\nbreak;\r\n}\r\n}\r\nif (!td->panel_config)\r\nreturn -EINVAL;\r\ndssdev->panel.timings = td->panel_config->timings;\r\ndssdev->panel.dsi_pix_fmt = OMAP_DSS_DSI_FMT_RGB888;\r\ndssdev->caps = OMAP_DSS_DISPLAY_CAP_MANUAL_UPDATE |\r\nOMAP_DSS_DISPLAY_CAP_TEAR_ELIM;\r\nmutex_init(&td->lock);\r\natomic_set(&td->do_update, 0);\r\nif (gpio_is_valid(td->reset_gpio)) {\r\nr = devm_gpio_request_one(&dssdev->dev, td->reset_gpio,\r\nGPIOF_OUT_INIT_LOW, "taal rst");\r\nif (r) {\r\ndev_err(&dssdev->dev, "failed to request reset gpio\n");\r\nreturn r;\r\n}\r\n}\r\nif (gpio_is_valid(td->ext_te_gpio)) {\r\nr = devm_gpio_request_one(&dssdev->dev, td->ext_te_gpio,\r\nGPIOF_IN, "taal irq");\r\nif (r) {\r\ndev_err(&dssdev->dev, "GPIO request failed\n");\r\nreturn r;\r\n}\r\nr = devm_request_irq(&dssdev->dev, gpio_to_irq(td->ext_te_gpio),\r\ntaal_te_isr,\r\nIRQF_TRIGGER_RISING,\r\n"taal vsync", dssdev);\r\nif (r) {\r\ndev_err(&dssdev->dev, "IRQ request failed\n");\r\nreturn r;\r\n}\r\nINIT_DEFERRABLE_WORK(&td->te_timeout_work,\r\ntaal_te_timeout_work_callback);\r\ndev_dbg(&dssdev->dev, "Using GPIO TE\n");\r\n}\r\ntd->workqueue = create_singlethread_workqueue("taal_esd");\r\nif (td->workqueue == NULL) {\r\ndev_err(&dssdev->dev, "can't create ESD workqueue\n");\r\nreturn -ENOMEM;\r\n}\r\nINIT_DEFERRABLE_WORK(&td->esd_work, taal_esd_work);\r\nINIT_DELAYED_WORK(&td->ulps_work, taal_ulps_work);\r\ntaal_hw_reset(dssdev);\r\nif (td->use_dsi_backlight) {\r\nmemset(&props, 0, sizeof(struct backlight_properties));\r\nprops.max_brightness = 255;\r\nprops.type = BACKLIGHT_RAW;\r\nbldev = backlight_device_register(dev_name(&dssdev->dev),\r\n&dssdev->dev, dssdev, &taal_bl_ops, &props);\r\nif (IS_ERR(bldev)) {\r\nr = PTR_ERR(bldev);\r\ngoto err_bl;\r\n}\r\ntd->bldev = bldev;\r\nbldev->props.fb_blank = FB_BLANK_UNBLANK;\r\nbldev->props.power = FB_BLANK_UNBLANK;\r\nbldev->props.brightness = 255;\r\ntaal_bl_update_status(bldev);\r\n}\r\nr = omap_dsi_request_vc(dssdev, &td->channel);\r\nif (r) {\r\ndev_err(&dssdev->dev, "failed to get virtual channel\n");\r\ngoto err_req_vc;\r\n}\r\nr = omap_dsi_set_vc_id(dssdev, td->channel, TCH);\r\nif (r) {\r\ndev_err(&dssdev->dev, "failed to set VC_ID\n");\r\ngoto err_vc_id;\r\n}\r\nr = sysfs_create_group(&dssdev->dev.kobj, &taal_attr_group);\r\nif (r) {\r\ndev_err(&dssdev->dev, "failed to create sysfs files\n");\r\ngoto err_vc_id;\r\n}\r\nreturn 0;\r\nerr_vc_id:\r\nomap_dsi_release_vc(dssdev, td->channel);\r\nerr_req_vc:\r\nif (bldev != NULL)\r\nbacklight_device_unregister(bldev);\r\nerr_bl:\r\ndestroy_workqueue(td->workqueue);\r\nreturn r;\r\n}\r\nstatic void __exit taal_remove(struct omap_dss_device *dssdev)\r\n{\r\nstruct taal_data *td = dev_get_drvdata(&dssdev->dev);\r\nstruct backlight_device *bldev;\r\ndev_dbg(&dssdev->dev, "remove\n");\r\nsysfs_remove_group(&dssdev->dev.kobj, &taal_attr_group);\r\nomap_dsi_release_vc(dssdev, td->channel);\r\nbldev = td->bldev;\r\nif (bldev != NULL) {\r\nbldev->props.power = FB_BLANK_POWERDOWN;\r\ntaal_bl_update_status(bldev);\r\nbacklight_device_unregister(bldev);\r\n}\r\ntaal_cancel_ulps_work(dssdev);\r\ntaal_cancel_esd_work(dssdev);\r\ndestroy_workqueue(td->workqueue);\r\ntaal_hw_reset(dssdev);\r\n}\r\nstatic int taal_power_on(struct omap_dss_device *dssdev)\r\n{\r\nstruct taal_data *td = dev_get_drvdata(&dssdev->dev);\r\nu8 id1, id2, id3;\r\nint r;\r\nr = omapdss_dsi_configure_pins(dssdev, &td->pin_config);\r\nif (r) {\r\ndev_err(&dssdev->dev, "failed to configure DSI pins\n");\r\ngoto err0;\r\n};\r\nomapdss_dsi_set_size(dssdev, dssdev->panel.timings.x_res,\r\ndssdev->panel.timings.y_res);\r\nomapdss_dsi_set_pixel_format(dssdev, OMAP_DSS_DSI_FMT_RGB888);\r\nomapdss_dsi_set_operation_mode(dssdev, OMAP_DSS_DSI_CMD_MODE);\r\nr = omapdss_dsi_set_clocks(dssdev, 216000000, 10000000);\r\nif (r) {\r\ndev_err(&dssdev->dev, "failed to set HS and LP clocks\n");\r\ngoto err0;\r\n}\r\nr = omapdss_dsi_display_enable(dssdev);\r\nif (r) {\r\ndev_err(&dssdev->dev, "failed to enable DSI\n");\r\ngoto err0;\r\n}\r\ntaal_hw_reset(dssdev);\r\nomapdss_dsi_vc_enable_hs(dssdev, td->channel, false);\r\nr = taal_sleep_out(td);\r\nif (r)\r\ngoto err;\r\nr = taal_get_id(td, &id1, &id2, &id3);\r\nif (r)\r\ngoto err;\r\nif (td->panel_config->type == PANEL_TAAL &&\r\n(id2 == 0x00 || id2 == 0xff || id2 == 0x81))\r\ntd->cabc_broken = true;\r\nr = taal_dcs_write_1(td, DCS_BRIGHTNESS, 0xff);\r\nif (r)\r\ngoto err;\r\nr = taal_dcs_write_1(td, DCS_CTRL_DISPLAY,\r\n(1<<2) | (1<<5));\r\nif (r)\r\ngoto err;\r\nr = taal_dcs_write_1(td, MIPI_DCS_SET_PIXEL_FORMAT,\r\nMIPI_DCS_PIXEL_FMT_24BIT);\r\nif (r)\r\ngoto err;\r\nr = taal_set_addr_mode(td, td->rotate, td->mirror);\r\nif (r)\r\ngoto err;\r\nif (!td->cabc_broken) {\r\nr = taal_dcs_write_1(td, DCS_WRITE_CABC, td->cabc_mode);\r\nif (r)\r\ngoto err;\r\n}\r\nr = taal_dcs_write_0(td, MIPI_DCS_SET_DISPLAY_ON);\r\nif (r)\r\ngoto err;\r\nr = _taal_enable_te(dssdev, td->te_enabled);\r\nif (r)\r\ngoto err;\r\nr = dsi_enable_video_output(dssdev, td->channel);\r\nif (r)\r\ngoto err;\r\ntd->enabled = 1;\r\nif (!td->intro_printed) {\r\ndev_info(&dssdev->dev, "%s panel revision %02x.%02x.%02x\n",\r\ntd->panel_config->name, id1, id2, id3);\r\nif (td->cabc_broken)\r\ndev_info(&dssdev->dev,\r\n"old Taal version, CABC disabled\n");\r\ntd->intro_printed = true;\r\n}\r\nomapdss_dsi_vc_enable_hs(dssdev, td->channel, true);\r\nreturn 0;\r\nerr:\r\ndev_err(&dssdev->dev, "error while enabling panel, issuing HW reset\n");\r\ntaal_hw_reset(dssdev);\r\nomapdss_dsi_display_disable(dssdev, true, false);\r\nerr0:\r\nreturn r;\r\n}\r\nstatic void taal_power_off(struct omap_dss_device *dssdev)\r\n{\r\nstruct taal_data *td = dev_get_drvdata(&dssdev->dev);\r\nint r;\r\ndsi_disable_video_output(dssdev, td->channel);\r\nr = taal_dcs_write_0(td, MIPI_DCS_SET_DISPLAY_OFF);\r\nif (!r)\r\nr = taal_sleep_in(td);\r\nif (r) {\r\ndev_err(&dssdev->dev,\r\n"error disabling panel, issuing HW reset\n");\r\ntaal_hw_reset(dssdev);\r\n}\r\nomapdss_dsi_display_disable(dssdev, true, false);\r\ntd->enabled = 0;\r\n}\r\nstatic int taal_panel_reset(struct omap_dss_device *dssdev)\r\n{\r\ndev_err(&dssdev->dev, "performing LCD reset\n");\r\ntaal_power_off(dssdev);\r\ntaal_hw_reset(dssdev);\r\nreturn taal_power_on(dssdev);\r\n}\r\nstatic int taal_enable(struct omap_dss_device *dssdev)\r\n{\r\nstruct taal_data *td = dev_get_drvdata(&dssdev->dev);\r\nint r;\r\ndev_dbg(&dssdev->dev, "enable\n");\r\nmutex_lock(&td->lock);\r\nif (dssdev->state != OMAP_DSS_DISPLAY_DISABLED) {\r\nr = -EINVAL;\r\ngoto err;\r\n}\r\ndsi_bus_lock(dssdev);\r\nr = taal_power_on(dssdev);\r\ndsi_bus_unlock(dssdev);\r\nif (r)\r\ngoto err;\r\ntaal_queue_esd_work(dssdev);\r\ndssdev->state = OMAP_DSS_DISPLAY_ACTIVE;\r\nmutex_unlock(&td->lock);\r\nreturn 0;\r\nerr:\r\ndev_dbg(&dssdev->dev, "enable failed\n");\r\nmutex_unlock(&td->lock);\r\nreturn r;\r\n}\r\nstatic void taal_disable(struct omap_dss_device *dssdev)\r\n{\r\nstruct taal_data *td = dev_get_drvdata(&dssdev->dev);\r\ndev_dbg(&dssdev->dev, "disable\n");\r\nmutex_lock(&td->lock);\r\ntaal_cancel_ulps_work(dssdev);\r\ntaal_cancel_esd_work(dssdev);\r\ndsi_bus_lock(dssdev);\r\nif (dssdev->state == OMAP_DSS_DISPLAY_ACTIVE) {\r\nint r;\r\nr = taal_wake_up(dssdev);\r\nif (!r)\r\ntaal_power_off(dssdev);\r\n}\r\ndsi_bus_unlock(dssdev);\r\ndssdev->state = OMAP_DSS_DISPLAY_DISABLED;\r\nmutex_unlock(&td->lock);\r\n}\r\nstatic void taal_framedone_cb(int err, void *data)\r\n{\r\nstruct omap_dss_device *dssdev = data;\r\ndev_dbg(&dssdev->dev, "framedone, err %d\n", err);\r\ndsi_bus_unlock(dssdev);\r\n}\r\nstatic irqreturn_t taal_te_isr(int irq, void *data)\r\n{\r\nstruct omap_dss_device *dssdev = data;\r\nstruct taal_data *td = dev_get_drvdata(&dssdev->dev);\r\nint old;\r\nint r;\r\nold = atomic_cmpxchg(&td->do_update, 1, 0);\r\nif (old) {\r\ncancel_delayed_work(&td->te_timeout_work);\r\nr = omap_dsi_update(dssdev, td->channel, taal_framedone_cb,\r\ndssdev);\r\nif (r)\r\ngoto err;\r\n}\r\nreturn IRQ_HANDLED;\r\nerr:\r\ndev_err(&dssdev->dev, "start update failed\n");\r\ndsi_bus_unlock(dssdev);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void taal_te_timeout_work_callback(struct work_struct *work)\r\n{\r\nstruct taal_data *td = container_of(work, struct taal_data,\r\nte_timeout_work.work);\r\nstruct omap_dss_device *dssdev = td->dssdev;\r\ndev_err(&dssdev->dev, "TE not received for 250ms!\n");\r\natomic_set(&td->do_update, 0);\r\ndsi_bus_unlock(dssdev);\r\n}\r\nstatic int taal_update(struct omap_dss_device *dssdev,\r\nu16 x, u16 y, u16 w, u16 h)\r\n{\r\nstruct taal_data *td = dev_get_drvdata(&dssdev->dev);\r\nint r;\r\ndev_dbg(&dssdev->dev, "update %d, %d, %d x %d\n", x, y, w, h);\r\nmutex_lock(&td->lock);\r\ndsi_bus_lock(dssdev);\r\nr = taal_wake_up(dssdev);\r\nif (r)\r\ngoto err;\r\nif (!td->enabled) {\r\nr = 0;\r\ngoto err;\r\n}\r\nr = taal_set_update_window(td, 0, 0,\r\ntd->panel_config->timings.x_res,\r\ntd->panel_config->timings.y_res);\r\nif (r)\r\ngoto err;\r\nif (td->te_enabled && gpio_is_valid(td->ext_te_gpio)) {\r\nschedule_delayed_work(&td->te_timeout_work,\r\nmsecs_to_jiffies(250));\r\natomic_set(&td->do_update, 1);\r\n} else {\r\nr = omap_dsi_update(dssdev, td->channel, taal_framedone_cb,\r\ndssdev);\r\nif (r)\r\ngoto err;\r\n}\r\nmutex_unlock(&td->lock);\r\nreturn 0;\r\nerr:\r\ndsi_bus_unlock(dssdev);\r\nmutex_unlock(&td->lock);\r\nreturn r;\r\n}\r\nstatic int taal_sync(struct omap_dss_device *dssdev)\r\n{\r\nstruct taal_data *td = dev_get_drvdata(&dssdev->dev);\r\ndev_dbg(&dssdev->dev, "sync\n");\r\nmutex_lock(&td->lock);\r\ndsi_bus_lock(dssdev);\r\ndsi_bus_unlock(dssdev);\r\nmutex_unlock(&td->lock);\r\ndev_dbg(&dssdev->dev, "sync done\n");\r\nreturn 0;\r\n}\r\nstatic int _taal_enable_te(struct omap_dss_device *dssdev, bool enable)\r\n{\r\nstruct taal_data *td = dev_get_drvdata(&dssdev->dev);\r\nint r;\r\nif (enable)\r\nr = taal_dcs_write_1(td, MIPI_DCS_SET_TEAR_ON, 0);\r\nelse\r\nr = taal_dcs_write_0(td, MIPI_DCS_SET_TEAR_OFF);\r\nif (!gpio_is_valid(td->ext_te_gpio))\r\nomapdss_dsi_enable_te(dssdev, enable);\r\nif (td->panel_config->sleep.enable_te)\r\nmsleep(td->panel_config->sleep.enable_te);\r\nreturn r;\r\n}\r\nstatic int taal_enable_te(struct omap_dss_device *dssdev, bool enable)\r\n{\r\nstruct taal_data *td = dev_get_drvdata(&dssdev->dev);\r\nint r;\r\nmutex_lock(&td->lock);\r\nif (td->te_enabled == enable)\r\ngoto end;\r\ndsi_bus_lock(dssdev);\r\nif (td->enabled) {\r\nr = taal_wake_up(dssdev);\r\nif (r)\r\ngoto err;\r\nr = _taal_enable_te(dssdev, enable);\r\nif (r)\r\ngoto err;\r\n}\r\ntd->te_enabled = enable;\r\ndsi_bus_unlock(dssdev);\r\nend:\r\nmutex_unlock(&td->lock);\r\nreturn 0;\r\nerr:\r\ndsi_bus_unlock(dssdev);\r\nmutex_unlock(&td->lock);\r\nreturn r;\r\n}\r\nstatic int taal_get_te(struct omap_dss_device *dssdev)\r\n{\r\nstruct taal_data *td = dev_get_drvdata(&dssdev->dev);\r\nint r;\r\nmutex_lock(&td->lock);\r\nr = td->te_enabled;\r\nmutex_unlock(&td->lock);\r\nreturn r;\r\n}\r\nstatic int taal_rotate(struct omap_dss_device *dssdev, u8 rotate)\r\n{\r\nstruct taal_data *td = dev_get_drvdata(&dssdev->dev);\r\nu16 dw, dh;\r\nint r;\r\ndev_dbg(&dssdev->dev, "rotate %d\n", rotate);\r\nmutex_lock(&td->lock);\r\nif (td->rotate == rotate)\r\ngoto end;\r\ndsi_bus_lock(dssdev);\r\nif (td->enabled) {\r\nr = taal_wake_up(dssdev);\r\nif (r)\r\ngoto err;\r\nr = taal_set_addr_mode(td, rotate, td->mirror);\r\nif (r)\r\ngoto err;\r\n}\r\nif (rotate == 0 || rotate == 2) {\r\ndw = dssdev->panel.timings.x_res;\r\ndh = dssdev->panel.timings.y_res;\r\n} else {\r\ndw = dssdev->panel.timings.y_res;\r\ndh = dssdev->panel.timings.x_res;\r\n}\r\nomapdss_dsi_set_size(dssdev, dw, dh);\r\ntd->rotate = rotate;\r\ndsi_bus_unlock(dssdev);\r\nend:\r\nmutex_unlock(&td->lock);\r\nreturn 0;\r\nerr:\r\ndsi_bus_unlock(dssdev);\r\nmutex_unlock(&td->lock);\r\nreturn r;\r\n}\r\nstatic u8 taal_get_rotate(struct omap_dss_device *dssdev)\r\n{\r\nstruct taal_data *td = dev_get_drvdata(&dssdev->dev);\r\nint r;\r\nmutex_lock(&td->lock);\r\nr = td->rotate;\r\nmutex_unlock(&td->lock);\r\nreturn r;\r\n}\r\nstatic int taal_mirror(struct omap_dss_device *dssdev, bool enable)\r\n{\r\nstruct taal_data *td = dev_get_drvdata(&dssdev->dev);\r\nint r;\r\ndev_dbg(&dssdev->dev, "mirror %d\n", enable);\r\nmutex_lock(&td->lock);\r\nif (td->mirror == enable)\r\ngoto end;\r\ndsi_bus_lock(dssdev);\r\nif (td->enabled) {\r\nr = taal_wake_up(dssdev);\r\nif (r)\r\ngoto err;\r\nr = taal_set_addr_mode(td, td->rotate, enable);\r\nif (r)\r\ngoto err;\r\n}\r\ntd->mirror = enable;\r\ndsi_bus_unlock(dssdev);\r\nend:\r\nmutex_unlock(&td->lock);\r\nreturn 0;\r\nerr:\r\ndsi_bus_unlock(dssdev);\r\nmutex_unlock(&td->lock);\r\nreturn r;\r\n}\r\nstatic bool taal_get_mirror(struct omap_dss_device *dssdev)\r\n{\r\nstruct taal_data *td = dev_get_drvdata(&dssdev->dev);\r\nint r;\r\nmutex_lock(&td->lock);\r\nr = td->mirror;\r\nmutex_unlock(&td->lock);\r\nreturn r;\r\n}\r\nstatic int taal_run_test(struct omap_dss_device *dssdev, int test_num)\r\n{\r\nstruct taal_data *td = dev_get_drvdata(&dssdev->dev);\r\nu8 id1, id2, id3;\r\nint r;\r\nmutex_lock(&td->lock);\r\nif (!td->enabled) {\r\nr = -ENODEV;\r\ngoto err1;\r\n}\r\ndsi_bus_lock(dssdev);\r\nr = taal_wake_up(dssdev);\r\nif (r)\r\ngoto err2;\r\nr = taal_dcs_read_1(td, DCS_GET_ID1, &id1);\r\nif (r)\r\ngoto err2;\r\nr = taal_dcs_read_1(td, DCS_GET_ID2, &id2);\r\nif (r)\r\ngoto err2;\r\nr = taal_dcs_read_1(td, DCS_GET_ID3, &id3);\r\nif (r)\r\ngoto err2;\r\ndsi_bus_unlock(dssdev);\r\nmutex_unlock(&td->lock);\r\nreturn 0;\r\nerr2:\r\ndsi_bus_unlock(dssdev);\r\nerr1:\r\nmutex_unlock(&td->lock);\r\nreturn r;\r\n}\r\nstatic int taal_memory_read(struct omap_dss_device *dssdev,\r\nvoid *buf, size_t size,\r\nu16 x, u16 y, u16 w, u16 h)\r\n{\r\nint r;\r\nint first = 1;\r\nint plen;\r\nunsigned buf_used = 0;\r\nstruct taal_data *td = dev_get_drvdata(&dssdev->dev);\r\nif (size < w * h * 3)\r\nreturn -ENOMEM;\r\nmutex_lock(&td->lock);\r\nif (!td->enabled) {\r\nr = -ENODEV;\r\ngoto err1;\r\n}\r\nsize = min(w * h * 3,\r\ndssdev->panel.timings.x_res *\r\ndssdev->panel.timings.y_res * 3);\r\ndsi_bus_lock(dssdev);\r\nr = taal_wake_up(dssdev);\r\nif (r)\r\ngoto err2;\r\nif (size % 2)\r\nplen = 1;\r\nelse\r\nplen = 2;\r\ntaal_set_update_window(td, x, y, w, h);\r\nr = dsi_vc_set_max_rx_packet_size(dssdev, td->channel, plen);\r\nif (r)\r\ngoto err2;\r\nwhile (buf_used < size) {\r\nu8 dcs_cmd = first ? 0x2e : 0x3e;\r\nfirst = 0;\r\nr = dsi_vc_dcs_read(dssdev, td->channel, dcs_cmd,\r\nbuf + buf_used, size - buf_used);\r\nif (r < 0) {\r\ndev_err(&dssdev->dev, "read error\n");\r\ngoto err3;\r\n}\r\nbuf_used += r;\r\nif (r < plen) {\r\ndev_err(&dssdev->dev, "short read\n");\r\nbreak;\r\n}\r\nif (signal_pending(current)) {\r\ndev_err(&dssdev->dev, "signal pending, "\r\n"aborting memory read\n");\r\nr = -ERESTARTSYS;\r\ngoto err3;\r\n}\r\n}\r\nr = buf_used;\r\nerr3:\r\ndsi_vc_set_max_rx_packet_size(dssdev, td->channel, 1);\r\nerr2:\r\ndsi_bus_unlock(dssdev);\r\nerr1:\r\nmutex_unlock(&td->lock);\r\nreturn r;\r\n}\r\nstatic void taal_ulps_work(struct work_struct *work)\r\n{\r\nstruct taal_data *td = container_of(work, struct taal_data,\r\nulps_work.work);\r\nstruct omap_dss_device *dssdev = td->dssdev;\r\nmutex_lock(&td->lock);\r\nif (dssdev->state != OMAP_DSS_DISPLAY_ACTIVE || !td->enabled) {\r\nmutex_unlock(&td->lock);\r\nreturn;\r\n}\r\ndsi_bus_lock(dssdev);\r\ntaal_enter_ulps(dssdev);\r\ndsi_bus_unlock(dssdev);\r\nmutex_unlock(&td->lock);\r\n}\r\nstatic void taal_esd_work(struct work_struct *work)\r\n{\r\nstruct taal_data *td = container_of(work, struct taal_data,\r\nesd_work.work);\r\nstruct omap_dss_device *dssdev = td->dssdev;\r\nu8 state1, state2;\r\nint r;\r\nmutex_lock(&td->lock);\r\nif (!td->enabled) {\r\nmutex_unlock(&td->lock);\r\nreturn;\r\n}\r\ndsi_bus_lock(dssdev);\r\nr = taal_wake_up(dssdev);\r\nif (r) {\r\ndev_err(&dssdev->dev, "failed to exit ULPS\n");\r\ngoto err;\r\n}\r\nr = taal_dcs_read_1(td, MIPI_DCS_GET_DIAGNOSTIC_RESULT, &state1);\r\nif (r) {\r\ndev_err(&dssdev->dev, "failed to read Taal status\n");\r\ngoto err;\r\n}\r\nr = taal_sleep_out(td);\r\nif (r) {\r\ndev_err(&dssdev->dev, "failed to run Taal self-diagnostics\n");\r\ngoto err;\r\n}\r\nr = taal_dcs_read_1(td, MIPI_DCS_GET_DIAGNOSTIC_RESULT, &state2);\r\nif (r) {\r\ndev_err(&dssdev->dev, "failed to read Taal status\n");\r\ngoto err;\r\n}\r\nif (!((state1 ^ state2) & (1 << 6))) {\r\ndev_err(&dssdev->dev, "LCD self diagnostics failed\n");\r\ngoto err;\r\n}\r\nif (td->te_enabled && gpio_is_valid(td->ext_te_gpio)) {\r\nr = taal_dcs_write_1(td, MIPI_DCS_SET_TEAR_ON, 0);\r\nif (r)\r\ngoto err;\r\n}\r\ndsi_bus_unlock(dssdev);\r\ntaal_queue_esd_work(dssdev);\r\nmutex_unlock(&td->lock);\r\nreturn;\r\nerr:\r\ndev_err(&dssdev->dev, "performing LCD reset\n");\r\ntaal_panel_reset(dssdev);\r\ndsi_bus_unlock(dssdev);\r\ntaal_queue_esd_work(dssdev);\r\nmutex_unlock(&td->lock);\r\n}\r\nstatic int __init taal_init(void)\r\n{\r\nomap_dss_register_driver(&taal_driver);\r\nreturn 0;\r\n}\r\nstatic void __exit taal_exit(void)\r\n{\r\nomap_dss_unregister_driver(&taal_driver);\r\n}
