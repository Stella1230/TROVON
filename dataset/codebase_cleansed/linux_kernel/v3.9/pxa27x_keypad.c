static void pxa27x_keypad_build_keycode(struct pxa27x_keypad *keypad)\r\n{\r\nstruct pxa27x_keypad_platform_data *pdata = keypad->pdata;\r\nstruct input_dev *input_dev = keypad->input_dev;\r\nunsigned short keycode;\r\nint i;\r\nfor (i = 0; i < pdata->matrix_key_map_size; i++) {\r\nunsigned int key = pdata->matrix_key_map[i];\r\nunsigned int row = KEY_ROW(key);\r\nunsigned int col = KEY_COL(key);\r\nunsigned int scancode = MATRIX_SCAN_CODE(row, col,\r\nMATRIX_ROW_SHIFT);\r\nkeycode = KEY_VAL(key);\r\nkeypad->keycodes[scancode] = keycode;\r\n__set_bit(keycode, input_dev->keybit);\r\n}\r\nfor (i = 0; i < pdata->direct_key_num; i++) {\r\nkeycode = pdata->direct_key_map[i];\r\nkeypad->keycodes[MAX_MATRIX_KEY_NUM + i] = keycode;\r\n__set_bit(keycode, input_dev->keybit);\r\n}\r\nif (pdata->enable_rotary0) {\r\nif (pdata->rotary0_up_key && pdata->rotary0_down_key) {\r\nkeycode = pdata->rotary0_up_key;\r\nkeypad->keycodes[MAX_MATRIX_KEY_NUM + 0] = keycode;\r\n__set_bit(keycode, input_dev->keybit);\r\nkeycode = pdata->rotary0_down_key;\r\nkeypad->keycodes[MAX_MATRIX_KEY_NUM + 1] = keycode;\r\n__set_bit(keycode, input_dev->keybit);\r\nkeypad->rotary_rel_code[0] = -1;\r\n} else {\r\nkeypad->rotary_rel_code[0] = pdata->rotary0_rel_code;\r\n__set_bit(pdata->rotary0_rel_code, input_dev->relbit);\r\n}\r\n}\r\nif (pdata->enable_rotary1) {\r\nif (pdata->rotary1_up_key && pdata->rotary1_down_key) {\r\nkeycode = pdata->rotary1_up_key;\r\nkeypad->keycodes[MAX_MATRIX_KEY_NUM + 2] = keycode;\r\n__set_bit(keycode, input_dev->keybit);\r\nkeycode = pdata->rotary1_down_key;\r\nkeypad->keycodes[MAX_MATRIX_KEY_NUM + 3] = keycode;\r\n__set_bit(keycode, input_dev->keybit);\r\nkeypad->rotary_rel_code[1] = -1;\r\n} else {\r\nkeypad->rotary_rel_code[1] = pdata->rotary1_rel_code;\r\n__set_bit(pdata->rotary1_rel_code, input_dev->relbit);\r\n}\r\n}\r\n__clear_bit(KEY_RESERVED, input_dev->keybit);\r\n}\r\nstatic void pxa27x_keypad_scan_matrix(struct pxa27x_keypad *keypad)\r\n{\r\nstruct pxa27x_keypad_platform_data *pdata = keypad->pdata;\r\nstruct input_dev *input_dev = keypad->input_dev;\r\nint row, col, num_keys_pressed = 0;\r\nuint32_t new_state[MAX_MATRIX_KEY_COLS];\r\nuint32_t kpas = keypad_readl(KPAS);\r\nnum_keys_pressed = KPAS_MUKP(kpas);\r\nmemset(new_state, 0, sizeof(new_state));\r\nif (num_keys_pressed == 0)\r\ngoto scan;\r\nif (num_keys_pressed == 1) {\r\ncol = KPAS_CP(kpas);\r\nrow = KPAS_RP(kpas);\r\nif (col >= pdata->matrix_key_cols ||\r\nrow >= pdata->matrix_key_rows)\r\ngoto scan;\r\nnew_state[col] = (1 << row);\r\ngoto scan;\r\n}\r\nif (num_keys_pressed > 1) {\r\nuint32_t kpasmkp0 = keypad_readl(KPASMKP0);\r\nuint32_t kpasmkp1 = keypad_readl(KPASMKP1);\r\nuint32_t kpasmkp2 = keypad_readl(KPASMKP2);\r\nuint32_t kpasmkp3 = keypad_readl(KPASMKP3);\r\nnew_state[0] = kpasmkp0 & KPASMKP_MKC_MASK;\r\nnew_state[1] = (kpasmkp0 >> 16) & KPASMKP_MKC_MASK;\r\nnew_state[2] = kpasmkp1 & KPASMKP_MKC_MASK;\r\nnew_state[3] = (kpasmkp1 >> 16) & KPASMKP_MKC_MASK;\r\nnew_state[4] = kpasmkp2 & KPASMKP_MKC_MASK;\r\nnew_state[5] = (kpasmkp2 >> 16) & KPASMKP_MKC_MASK;\r\nnew_state[6] = kpasmkp3 & KPASMKP_MKC_MASK;\r\nnew_state[7] = (kpasmkp3 >> 16) & KPASMKP_MKC_MASK;\r\n}\r\nscan:\r\nfor (col = 0; col < pdata->matrix_key_cols; col++) {\r\nuint32_t bits_changed;\r\nint code;\r\nbits_changed = keypad->matrix_key_state[col] ^ new_state[col];\r\nif (bits_changed == 0)\r\ncontinue;\r\nfor (row = 0; row < pdata->matrix_key_rows; row++) {\r\nif ((bits_changed & (1 << row)) == 0)\r\ncontinue;\r\ncode = MATRIX_SCAN_CODE(row, col, MATRIX_ROW_SHIFT);\r\ninput_event(input_dev, EV_MSC, MSC_SCAN, code);\r\ninput_report_key(input_dev, keypad->keycodes[code],\r\nnew_state[col] & (1 << row));\r\n}\r\n}\r\ninput_sync(input_dev);\r\nmemcpy(keypad->matrix_key_state, new_state, sizeof(new_state));\r\n}\r\nstatic inline int rotary_delta(uint32_t kprec)\r\n{\r\nif (kprec & KPREC_OF0)\r\nreturn (kprec & 0xff) + 0x7f;\r\nelse if (kprec & KPREC_UF0)\r\nreturn (kprec & 0xff) - 0x7f - 0xff;\r\nelse\r\nreturn (kprec & 0xff) - 0x7f;\r\n}\r\nstatic void report_rotary_event(struct pxa27x_keypad *keypad, int r, int delta)\r\n{\r\nstruct input_dev *dev = keypad->input_dev;\r\nif (delta == 0)\r\nreturn;\r\nif (keypad->rotary_rel_code[r] == -1) {\r\nint code = MAX_MATRIX_KEY_NUM + 2 * r + (delta > 0 ? 0 : 1);\r\nunsigned char keycode = keypad->keycodes[code];\r\ninput_event(dev, EV_MSC, MSC_SCAN, code);\r\ninput_report_key(dev, keycode, 1);\r\ninput_sync(dev);\r\ninput_event(dev, EV_MSC, MSC_SCAN, code);\r\ninput_report_key(dev, keycode, 0);\r\ninput_sync(dev);\r\n} else {\r\ninput_report_rel(dev, keypad->rotary_rel_code[r], delta);\r\ninput_sync(dev);\r\n}\r\n}\r\nstatic void pxa27x_keypad_scan_rotary(struct pxa27x_keypad *keypad)\r\n{\r\nstruct pxa27x_keypad_platform_data *pdata = keypad->pdata;\r\nuint32_t kprec;\r\nkprec = keypad_readl(KPREC);\r\nkeypad_writel(KPREC, DEFAULT_KPREC);\r\nif (pdata->enable_rotary0)\r\nreport_rotary_event(keypad, 0, rotary_delta(kprec));\r\nif (pdata->enable_rotary1)\r\nreport_rotary_event(keypad, 1, rotary_delta(kprec >> 16));\r\n}\r\nstatic void pxa27x_keypad_scan_direct(struct pxa27x_keypad *keypad)\r\n{\r\nstruct pxa27x_keypad_platform_data *pdata = keypad->pdata;\r\nstruct input_dev *input_dev = keypad->input_dev;\r\nunsigned int new_state;\r\nuint32_t kpdk, bits_changed;\r\nint i;\r\nkpdk = keypad_readl(KPDK);\r\nif (pdata->enable_rotary0 || pdata->enable_rotary1)\r\npxa27x_keypad_scan_rotary(keypad);\r\nif (pdata->direct_key_low_active)\r\nnew_state = ~KPDK_DK(kpdk) & keypad->direct_key_mask;\r\nelse\r\nnew_state = KPDK_DK(kpdk) & keypad->direct_key_mask;\r\nbits_changed = keypad->direct_key_state ^ new_state;\r\nif (bits_changed == 0)\r\nreturn;\r\nfor (i = 0; i < pdata->direct_key_num; i++) {\r\nif (bits_changed & (1 << i)) {\r\nint code = MAX_MATRIX_KEY_NUM + i;\r\ninput_event(input_dev, EV_MSC, MSC_SCAN, code);\r\ninput_report_key(input_dev, keypad->keycodes[code],\r\nnew_state & (1 << i));\r\n}\r\n}\r\ninput_sync(input_dev);\r\nkeypad->direct_key_state = new_state;\r\n}\r\nstatic void clear_wakeup_event(struct pxa27x_keypad *keypad)\r\n{\r\nstruct pxa27x_keypad_platform_data *pdata = keypad->pdata;\r\nif (pdata->clear_wakeup_event)\r\n(pdata->clear_wakeup_event)();\r\n}\r\nstatic irqreturn_t pxa27x_keypad_irq_handler(int irq, void *dev_id)\r\n{\r\nstruct pxa27x_keypad *keypad = dev_id;\r\nunsigned long kpc = keypad_readl(KPC);\r\nclear_wakeup_event(keypad);\r\nif (kpc & KPC_DI)\r\npxa27x_keypad_scan_direct(keypad);\r\nif (kpc & KPC_MI)\r\npxa27x_keypad_scan_matrix(keypad);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void pxa27x_keypad_config(struct pxa27x_keypad *keypad)\r\n{\r\nstruct pxa27x_keypad_platform_data *pdata = keypad->pdata;\r\nunsigned int mask = 0, direct_key_num = 0;\r\nunsigned long kpc = 0;\r\nkeypad_readl(KPC);\r\nif (pdata->matrix_key_rows && pdata->matrix_key_cols) {\r\nkpc |= KPC_ASACT | KPC_MIE | KPC_ME | KPC_MS_ALL;\r\nkpc |= KPC_MKRN(pdata->matrix_key_rows) |\r\nKPC_MKCN(pdata->matrix_key_cols);\r\n}\r\nif (pdata->enable_rotary0) {\r\nmask |= 0x03;\r\ndirect_key_num = 2;\r\nkpc |= KPC_REE0;\r\n}\r\nif (pdata->enable_rotary1) {\r\nmask |= 0x0c;\r\ndirect_key_num = 4;\r\nkpc |= KPC_REE1;\r\n}\r\nif (pdata->direct_key_num > direct_key_num)\r\ndirect_key_num = pdata->direct_key_num;\r\nif (pdata->direct_key_mask)\r\nkeypad->direct_key_mask = pdata->direct_key_mask;\r\nelse\r\nkeypad->direct_key_mask = ((1 << direct_key_num) - 1) & ~mask;\r\nif (direct_key_num)\r\nkpc |= KPC_DE | KPC_DIE | KPC_DKN(direct_key_num);\r\nkeypad_writel(KPC, kpc | KPC_RE_ZERO_DEB);\r\nkeypad_writel(KPREC, DEFAULT_KPREC);\r\nkeypad_writel(KPKDI, pdata->debounce_interval);\r\n}\r\nstatic int pxa27x_keypad_open(struct input_dev *dev)\r\n{\r\nstruct pxa27x_keypad *keypad = input_get_drvdata(dev);\r\nclk_prepare_enable(keypad->clk);\r\npxa27x_keypad_config(keypad);\r\nreturn 0;\r\n}\r\nstatic void pxa27x_keypad_close(struct input_dev *dev)\r\n{\r\nstruct pxa27x_keypad *keypad = input_get_drvdata(dev);\r\nclk_disable_unprepare(keypad->clk);\r\n}\r\nstatic int pxa27x_keypad_suspend(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct pxa27x_keypad *keypad = platform_get_drvdata(pdev);\r\nif (device_may_wakeup(&pdev->dev))\r\nenable_irq_wake(keypad->irq);\r\nelse\r\nclk_disable_unprepare(keypad->clk);\r\nreturn 0;\r\n}\r\nstatic int pxa27x_keypad_resume(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct pxa27x_keypad *keypad = platform_get_drvdata(pdev);\r\nstruct input_dev *input_dev = keypad->input_dev;\r\nif (device_may_wakeup(&pdev->dev)) {\r\ndisable_irq_wake(keypad->irq);\r\n} else {\r\nmutex_lock(&input_dev->mutex);\r\nif (input_dev->users) {\r\nclk_prepare_enable(keypad->clk);\r\npxa27x_keypad_config(keypad);\r\n}\r\nmutex_unlock(&input_dev->mutex);\r\n}\r\nreturn 0;\r\n}\r\nstatic int pxa27x_keypad_probe(struct platform_device *pdev)\r\n{\r\nstruct pxa27x_keypad_platform_data *pdata = pdev->dev.platform_data;\r\nstruct pxa27x_keypad *keypad;\r\nstruct input_dev *input_dev;\r\nstruct resource *res;\r\nint irq, error;\r\nif (pdata == NULL) {\r\ndev_err(&pdev->dev, "no platform data defined\n");\r\nreturn -EINVAL;\r\n}\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq < 0) {\r\ndev_err(&pdev->dev, "failed to get keypad irq\n");\r\nreturn -ENXIO;\r\n}\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (res == NULL) {\r\ndev_err(&pdev->dev, "failed to get I/O memory\n");\r\nreturn -ENXIO;\r\n}\r\nkeypad = kzalloc(sizeof(struct pxa27x_keypad), GFP_KERNEL);\r\ninput_dev = input_allocate_device();\r\nif (!keypad || !input_dev) {\r\ndev_err(&pdev->dev, "failed to allocate memory\n");\r\nerror = -ENOMEM;\r\ngoto failed_free;\r\n}\r\nkeypad->pdata = pdata;\r\nkeypad->input_dev = input_dev;\r\nkeypad->irq = irq;\r\nres = request_mem_region(res->start, resource_size(res), pdev->name);\r\nif (res == NULL) {\r\ndev_err(&pdev->dev, "failed to request I/O memory\n");\r\nerror = -EBUSY;\r\ngoto failed_free;\r\n}\r\nkeypad->mmio_base = ioremap(res->start, resource_size(res));\r\nif (keypad->mmio_base == NULL) {\r\ndev_err(&pdev->dev, "failed to remap I/O memory\n");\r\nerror = -ENXIO;\r\ngoto failed_free_mem;\r\n}\r\nkeypad->clk = clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(keypad->clk)) {\r\ndev_err(&pdev->dev, "failed to get keypad clock\n");\r\nerror = PTR_ERR(keypad->clk);\r\ngoto failed_free_io;\r\n}\r\ninput_dev->name = pdev->name;\r\ninput_dev->id.bustype = BUS_HOST;\r\ninput_dev->open = pxa27x_keypad_open;\r\ninput_dev->close = pxa27x_keypad_close;\r\ninput_dev->dev.parent = &pdev->dev;\r\ninput_dev->keycode = keypad->keycodes;\r\ninput_dev->keycodesize = sizeof(keypad->keycodes[0]);\r\ninput_dev->keycodemax = ARRAY_SIZE(keypad->keycodes);\r\ninput_set_drvdata(input_dev, keypad);\r\ninput_dev->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_REP);\r\ninput_set_capability(input_dev, EV_MSC, MSC_SCAN);\r\npxa27x_keypad_build_keycode(keypad);\r\nif ((pdata->enable_rotary0 && keypad->rotary_rel_code[0] != -1) ||\r\n(pdata->enable_rotary1 && keypad->rotary_rel_code[1] != -1)) {\r\ninput_dev->evbit[0] |= BIT_MASK(EV_REL);\r\n}\r\nerror = request_irq(irq, pxa27x_keypad_irq_handler, 0,\r\npdev->name, keypad);\r\nif (error) {\r\ndev_err(&pdev->dev, "failed to request IRQ\n");\r\ngoto failed_put_clk;\r\n}\r\nerror = input_register_device(input_dev);\r\nif (error) {\r\ndev_err(&pdev->dev, "failed to register input device\n");\r\ngoto failed_free_irq;\r\n}\r\nplatform_set_drvdata(pdev, keypad);\r\ndevice_init_wakeup(&pdev->dev, 1);\r\nreturn 0;\r\nfailed_free_irq:\r\nfree_irq(irq, pdev);\r\nfailed_put_clk:\r\nclk_put(keypad->clk);\r\nfailed_free_io:\r\niounmap(keypad->mmio_base);\r\nfailed_free_mem:\r\nrelease_mem_region(res->start, resource_size(res));\r\nfailed_free:\r\ninput_free_device(input_dev);\r\nkfree(keypad);\r\nreturn error;\r\n}\r\nstatic int pxa27x_keypad_remove(struct platform_device *pdev)\r\n{\r\nstruct pxa27x_keypad *keypad = platform_get_drvdata(pdev);\r\nstruct resource *res;\r\nfree_irq(keypad->irq, pdev);\r\nclk_put(keypad->clk);\r\ninput_unregister_device(keypad->input_dev);\r\niounmap(keypad->mmio_base);\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nrelease_mem_region(res->start, resource_size(res));\r\nplatform_set_drvdata(pdev, NULL);\r\nkfree(keypad);\r\nreturn 0;\r\n}
