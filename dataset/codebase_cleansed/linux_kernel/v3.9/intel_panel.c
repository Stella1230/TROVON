void\r\nintel_fixed_panel_mode(struct drm_display_mode *fixed_mode,\r\nstruct drm_display_mode *adjusted_mode)\r\n{\r\nadjusted_mode->hdisplay = fixed_mode->hdisplay;\r\nadjusted_mode->hsync_start = fixed_mode->hsync_start;\r\nadjusted_mode->hsync_end = fixed_mode->hsync_end;\r\nadjusted_mode->htotal = fixed_mode->htotal;\r\nadjusted_mode->vdisplay = fixed_mode->vdisplay;\r\nadjusted_mode->vsync_start = fixed_mode->vsync_start;\r\nadjusted_mode->vsync_end = fixed_mode->vsync_end;\r\nadjusted_mode->vtotal = fixed_mode->vtotal;\r\nadjusted_mode->clock = fixed_mode->clock;\r\n}\r\nvoid\r\nintel_pch_panel_fitting(struct drm_device *dev,\r\nint fitting_mode,\r\nconst struct drm_display_mode *mode,\r\nstruct drm_display_mode *adjusted_mode)\r\n{\r\nstruct drm_i915_private *dev_priv = dev->dev_private;\r\nint x, y, width, height;\r\nx = y = width = height = 0;\r\nif (adjusted_mode->hdisplay == mode->hdisplay &&\r\nadjusted_mode->vdisplay == mode->vdisplay)\r\ngoto done;\r\nswitch (fitting_mode) {\r\ncase DRM_MODE_SCALE_CENTER:\r\nwidth = mode->hdisplay;\r\nheight = mode->vdisplay;\r\nx = (adjusted_mode->hdisplay - width + 1)/2;\r\ny = (adjusted_mode->vdisplay - height + 1)/2;\r\nbreak;\r\ncase DRM_MODE_SCALE_ASPECT:\r\n{\r\nu32 scaled_width = adjusted_mode->hdisplay * mode->vdisplay;\r\nu32 scaled_height = mode->hdisplay * adjusted_mode->vdisplay;\r\nif (scaled_width > scaled_height) {\r\nwidth = scaled_height / mode->vdisplay;\r\nif (width & 1)\r\nwidth++;\r\nx = (adjusted_mode->hdisplay - width + 1) / 2;\r\ny = 0;\r\nheight = adjusted_mode->vdisplay;\r\n} else if (scaled_width < scaled_height) {\r\nheight = scaled_width / mode->hdisplay;\r\nif (height & 1)\r\nheight++;\r\ny = (adjusted_mode->vdisplay - height + 1) / 2;\r\nx = 0;\r\nwidth = adjusted_mode->hdisplay;\r\n} else {\r\nx = y = 0;\r\nwidth = adjusted_mode->hdisplay;\r\nheight = adjusted_mode->vdisplay;\r\n}\r\n}\r\nbreak;\r\ndefault:\r\ncase DRM_MODE_SCALE_FULLSCREEN:\r\nx = y = 0;\r\nwidth = adjusted_mode->hdisplay;\r\nheight = adjusted_mode->vdisplay;\r\nbreak;\r\n}\r\ndone:\r\ndev_priv->pch_pf_pos = (x << 16) | y;\r\ndev_priv->pch_pf_size = (width << 16) | height;\r\n}\r\nstatic int is_backlight_combination_mode(struct drm_device *dev)\r\n{\r\nstruct drm_i915_private *dev_priv = dev->dev_private;\r\nif (INTEL_INFO(dev)->gen >= 4)\r\nreturn I915_READ(BLC_PWM_CTL2) & BLM_COMBINATION_MODE;\r\nif (IS_GEN2(dev))\r\nreturn I915_READ(BLC_PWM_CTL) & BLM_LEGACY_MODE;\r\nreturn 0;\r\n}\r\nstatic u32 i915_read_blc_pwm_ctl(struct drm_device *dev)\r\n{\r\nstruct drm_i915_private *dev_priv = dev->dev_private;\r\nu32 val;\r\nif (HAS_PCH_SPLIT(dev_priv->dev)) {\r\nval = I915_READ(BLC_PWM_PCH_CTL2);\r\nif (dev_priv->regfile.saveBLC_PWM_CTL2 == 0) {\r\ndev_priv->regfile.saveBLC_PWM_CTL2 = val;\r\n} else if (val == 0) {\r\nval = dev_priv->regfile.saveBLC_PWM_CTL2;\r\nI915_WRITE(BLC_PWM_PCH_CTL2, val);\r\n}\r\n} else {\r\nval = I915_READ(BLC_PWM_CTL);\r\nif (dev_priv->regfile.saveBLC_PWM_CTL == 0) {\r\ndev_priv->regfile.saveBLC_PWM_CTL = val;\r\nif (INTEL_INFO(dev)->gen >= 4)\r\ndev_priv->regfile.saveBLC_PWM_CTL2 =\r\nI915_READ(BLC_PWM_CTL2);\r\n} else if (val == 0) {\r\nval = dev_priv->regfile.saveBLC_PWM_CTL;\r\nI915_WRITE(BLC_PWM_CTL, val);\r\nif (INTEL_INFO(dev)->gen >= 4)\r\nI915_WRITE(BLC_PWM_CTL2,\r\ndev_priv->regfile.saveBLC_PWM_CTL2);\r\n}\r\n}\r\nreturn val;\r\n}\r\nstatic u32 _intel_panel_get_max_backlight(struct drm_device *dev)\r\n{\r\nu32 max;\r\nmax = i915_read_blc_pwm_ctl(dev);\r\nif (HAS_PCH_SPLIT(dev)) {\r\nmax >>= 16;\r\n} else {\r\nif (INTEL_INFO(dev)->gen < 4)\r\nmax >>= 17;\r\nelse\r\nmax >>= 16;\r\nif (is_backlight_combination_mode(dev))\r\nmax *= 0xff;\r\n}\r\nreturn max;\r\n}\r\nu32 intel_panel_get_max_backlight(struct drm_device *dev)\r\n{\r\nu32 max;\r\nmax = _intel_panel_get_max_backlight(dev);\r\nif (max == 0) {\r\npr_warn_once("fixme: max PWM is zero\n");\r\nreturn 1;\r\n}\r\nDRM_DEBUG_DRIVER("max backlight PWM = %d\n", max);\r\nreturn max;\r\n}\r\nstatic u32 intel_panel_compute_brightness(struct drm_device *dev, u32 val)\r\n{\r\nstruct drm_i915_private *dev_priv = dev->dev_private;\r\nif (i915_panel_invert_brightness < 0)\r\nreturn val;\r\nif (i915_panel_invert_brightness > 0 ||\r\ndev_priv->quirks & QUIRK_INVERT_BRIGHTNESS)\r\nreturn intel_panel_get_max_backlight(dev) - val;\r\nreturn val;\r\n}\r\nstatic u32 intel_panel_get_backlight(struct drm_device *dev)\r\n{\r\nstruct drm_i915_private *dev_priv = dev->dev_private;\r\nu32 val;\r\nif (HAS_PCH_SPLIT(dev)) {\r\nval = I915_READ(BLC_PWM_CPU_CTL) & BACKLIGHT_DUTY_CYCLE_MASK;\r\n} else {\r\nval = I915_READ(BLC_PWM_CTL) & BACKLIGHT_DUTY_CYCLE_MASK;\r\nif (INTEL_INFO(dev)->gen < 4)\r\nval >>= 1;\r\nif (is_backlight_combination_mode(dev)) {\r\nu8 lbpc;\r\npci_read_config_byte(dev->pdev, PCI_LBPC, &lbpc);\r\nval *= lbpc;\r\n}\r\n}\r\nval = intel_panel_compute_brightness(dev, val);\r\nDRM_DEBUG_DRIVER("get backlight PWM = %d\n", val);\r\nreturn val;\r\n}\r\nstatic void intel_pch_panel_set_backlight(struct drm_device *dev, u32 level)\r\n{\r\nstruct drm_i915_private *dev_priv = dev->dev_private;\r\nu32 val = I915_READ(BLC_PWM_CPU_CTL) & ~BACKLIGHT_DUTY_CYCLE_MASK;\r\nI915_WRITE(BLC_PWM_CPU_CTL, val | level);\r\n}\r\nstatic void intel_panel_actually_set_backlight(struct drm_device *dev, u32 level)\r\n{\r\nstruct drm_i915_private *dev_priv = dev->dev_private;\r\nu32 tmp;\r\nDRM_DEBUG_DRIVER("set backlight PWM = %d\n", level);\r\nlevel = intel_panel_compute_brightness(dev, level);\r\nif (HAS_PCH_SPLIT(dev))\r\nreturn intel_pch_panel_set_backlight(dev, level);\r\nif (is_backlight_combination_mode(dev)) {\r\nu32 max = intel_panel_get_max_backlight(dev);\r\nu8 lbpc;\r\nlbpc = level * 0xfe / max + 1;\r\nlevel /= lbpc;\r\npci_write_config_byte(dev->pdev, PCI_LBPC, lbpc);\r\n}\r\ntmp = I915_READ(BLC_PWM_CTL);\r\nif (INTEL_INFO(dev)->gen < 4)\r\nlevel <<= 1;\r\ntmp &= ~BACKLIGHT_DUTY_CYCLE_MASK;\r\nI915_WRITE(BLC_PWM_CTL, tmp | level);\r\n}\r\nvoid intel_panel_set_backlight(struct drm_device *dev, u32 level)\r\n{\r\nstruct drm_i915_private *dev_priv = dev->dev_private;\r\ndev_priv->backlight_level = level;\r\nif (dev_priv->backlight_enabled)\r\nintel_panel_actually_set_backlight(dev, level);\r\n}\r\nvoid intel_panel_disable_backlight(struct drm_device *dev)\r\n{\r\nstruct drm_i915_private *dev_priv = dev->dev_private;\r\ndev_priv->backlight_enabled = false;\r\nintel_panel_actually_set_backlight(dev, 0);\r\nif (INTEL_INFO(dev)->gen >= 4) {\r\nuint32_t reg, tmp;\r\nreg = HAS_PCH_SPLIT(dev) ? BLC_PWM_CPU_CTL2 : BLC_PWM_CTL2;\r\nI915_WRITE(reg, I915_READ(reg) & ~BLM_PWM_ENABLE);\r\nif (HAS_PCH_SPLIT(dev)) {\r\ntmp = I915_READ(BLC_PWM_PCH_CTL1);\r\ntmp &= ~BLM_PCH_PWM_ENABLE;\r\nI915_WRITE(BLC_PWM_PCH_CTL1, tmp);\r\n}\r\n}\r\n}\r\nvoid intel_panel_enable_backlight(struct drm_device *dev,\r\nenum pipe pipe)\r\n{\r\nstruct drm_i915_private *dev_priv = dev->dev_private;\r\nif (dev_priv->backlight_level == 0)\r\ndev_priv->backlight_level = intel_panel_get_max_backlight(dev);\r\nif (INTEL_INFO(dev)->gen >= 4) {\r\nuint32_t reg, tmp;\r\nreg = HAS_PCH_SPLIT(dev) ? BLC_PWM_CPU_CTL2 : BLC_PWM_CTL2;\r\ntmp = I915_READ(reg);\r\nif (tmp & BLM_PWM_ENABLE)\r\ngoto set_level;\r\nif (dev_priv->num_pipe == 3)\r\ntmp &= ~BLM_PIPE_SELECT_IVB;\r\nelse\r\ntmp &= ~BLM_PIPE_SELECT;\r\ntmp |= BLM_PIPE(pipe);\r\ntmp &= ~BLM_PWM_ENABLE;\r\nI915_WRITE(reg, tmp);\r\nPOSTING_READ(reg);\r\nI915_WRITE(reg, tmp | BLM_PWM_ENABLE);\r\nif (HAS_PCH_SPLIT(dev)) {\r\ntmp = I915_READ(BLC_PWM_PCH_CTL1);\r\ntmp |= BLM_PCH_PWM_ENABLE;\r\ntmp &= ~BLM_PCH_OVERRIDE_ENABLE;\r\nI915_WRITE(BLC_PWM_PCH_CTL1, tmp);\r\n}\r\n}\r\nset_level:\r\ndev_priv->backlight_enabled = true;\r\nintel_panel_actually_set_backlight(dev, dev_priv->backlight_level);\r\n}\r\nstatic void intel_panel_init_backlight(struct drm_device *dev)\r\n{\r\nstruct drm_i915_private *dev_priv = dev->dev_private;\r\ndev_priv->backlight_level = intel_panel_get_backlight(dev);\r\ndev_priv->backlight_enabled = dev_priv->backlight_level != 0;\r\n}\r\nenum drm_connector_status\r\nintel_panel_detect(struct drm_device *dev)\r\n{\r\nstruct drm_i915_private *dev_priv = dev->dev_private;\r\nif (!i915_panel_ignore_lid && dev_priv->opregion.lid_state) {\r\nreturn ioread32(dev_priv->opregion.lid_state) & 0x1 ?\r\nconnector_status_connected :\r\nconnector_status_disconnected;\r\n}\r\nswitch (i915_panel_ignore_lid) {\r\ncase -2:\r\nreturn connector_status_connected;\r\ncase -1:\r\nreturn connector_status_disconnected;\r\ndefault:\r\nreturn connector_status_unknown;\r\n}\r\n}\r\nstatic int intel_panel_update_status(struct backlight_device *bd)\r\n{\r\nstruct drm_device *dev = bl_get_data(bd);\r\nintel_panel_set_backlight(dev, bd->props.brightness);\r\nreturn 0;\r\n}\r\nstatic int intel_panel_get_brightness(struct backlight_device *bd)\r\n{\r\nstruct drm_device *dev = bl_get_data(bd);\r\nstruct drm_i915_private *dev_priv = dev->dev_private;\r\nreturn dev_priv->backlight_level;\r\n}\r\nint intel_panel_setup_backlight(struct drm_connector *connector)\r\n{\r\nstruct drm_device *dev = connector->dev;\r\nstruct drm_i915_private *dev_priv = dev->dev_private;\r\nstruct backlight_properties props;\r\nintel_panel_init_backlight(dev);\r\nmemset(&props, 0, sizeof(props));\r\nprops.type = BACKLIGHT_RAW;\r\nprops.max_brightness = _intel_panel_get_max_backlight(dev);\r\nif (props.max_brightness == 0) {\r\nDRM_DEBUG_DRIVER("Failed to get maximum backlight value\n");\r\nreturn -ENODEV;\r\n}\r\ndev_priv->backlight =\r\nbacklight_device_register("intel_backlight",\r\n&connector->kdev, dev,\r\n&intel_panel_bl_ops, &props);\r\nif (IS_ERR(dev_priv->backlight)) {\r\nDRM_ERROR("Failed to register backlight: %ld\n",\r\nPTR_ERR(dev_priv->backlight));\r\ndev_priv->backlight = NULL;\r\nreturn -ENODEV;\r\n}\r\ndev_priv->backlight->props.brightness = intel_panel_get_backlight(dev);\r\nreturn 0;\r\n}\r\nvoid intel_panel_destroy_backlight(struct drm_device *dev)\r\n{\r\nstruct drm_i915_private *dev_priv = dev->dev_private;\r\nif (dev_priv->backlight)\r\nbacklight_device_unregister(dev_priv->backlight);\r\n}\r\nint intel_panel_setup_backlight(struct drm_connector *connector)\r\n{\r\nintel_panel_init_backlight(connector->dev);\r\nreturn 0;\r\n}\r\nvoid intel_panel_destroy_backlight(struct drm_device *dev)\r\n{\r\nreturn;\r\n}\r\nint intel_panel_init(struct intel_panel *panel,\r\nstruct drm_display_mode *fixed_mode)\r\n{\r\npanel->fixed_mode = fixed_mode;\r\nreturn 0;\r\n}\r\nvoid intel_panel_fini(struct intel_panel *panel)\r\n{\r\nstruct intel_connector *intel_connector =\r\ncontainer_of(panel, struct intel_connector, panel);\r\nif (panel->fixed_mode)\r\ndrm_mode_destroy(intel_connector->base.dev, panel->fixed_mode);\r\n}
