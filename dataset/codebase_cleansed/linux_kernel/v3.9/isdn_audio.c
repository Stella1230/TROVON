static inline void\r\nisdn_audio_tlookup(const u_char *table, u_char *buff, unsigned long n)\r\n{\r\n#ifdef __i386__\r\nunsigned long d0, d1, d2, d3;\r\n__asm__ __volatile__(\r\n"cld\n"\r\n"1:\tlodsb\n\t"\r\n"xlatb\n\t"\r\n"stosb\n\t"\r\n"loop 1b\n\t"\r\n: "=&b"(d0), "=&c"(d1), "=&D"(d2), "=&S"(d3)\r\n: "0"((long) table), "1"(n), "2"((long) buff), "3"((long) buff)\r\n: "memory", "ax");\r\n#else\r\nwhile (n--)\r\n*buff = table[*(unsigned char *)buff], buff++;\r\n#endif\r\n}\r\nvoid\r\nisdn_audio_ulaw2alaw(unsigned char *buff, unsigned long len)\r\n{\r\nisdn_audio_tlookup(isdn_audio_ulaw_to_alaw, buff, len);\r\n}\r\nvoid\r\nisdn_audio_alaw2ulaw(unsigned char *buff, unsigned long len)\r\n{\r\nisdn_audio_tlookup(isdn_audio_alaw_to_ulaw, buff, len);\r\n}\r\nstatic unsigned char\r\nisdn_audio_linear2ulaw(int sample)\r\n{\r\nstatic int exp_lut[256] =\r\n{\r\n0, 0, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3,\r\n4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\r\n5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\r\n5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\r\n6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\r\n6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\r\n6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\r\n6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\r\n7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,\r\n7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,\r\n7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,\r\n7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,\r\n7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,\r\n7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,\r\n7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,\r\n7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7\r\n};\r\nint sign,\r\nexponent,\r\nmantissa;\r\nunsigned char ulawbyte;\r\nsign = (sample >> 8) & 0x80;\r\nif (sign != 0)\r\nsample = -sample;\r\nif (sample > CLIP)\r\nsample = CLIP;\r\nsample = sample + BIAS;\r\nexponent = exp_lut[(sample >> 7) & 0xFF];\r\nmantissa = (sample >> (exponent + 3)) & 0x0F;\r\nulawbyte = ~(sign | (exponent << 4) | mantissa);\r\n#ifdef ZEROTRAP\r\nif (ulawbyte == 0)\r\nulawbyte = 0x02;\r\n#endif\r\nreturn (ulawbyte);\r\n}\r\nstatic int\r\nisdn_audio_get_bits(adpcm_state *s, unsigned char **in, int *len)\r\n{\r\nwhile (s->nleft < s->nbits) {\r\nint d = *((*in)++);\r\n(*len)--;\r\ns->word = (s->word << 8) | d;\r\ns->nleft += 8;\r\n}\r\ns->nleft -= s->nbits;\r\nreturn (s->word >> s->nleft) & bitmask[s->nbits];\r\n}\r\nstatic void\r\nisdn_audio_put_bits(int data, int nbits, adpcm_state *s,\r\nunsigned char **out, int *len)\r\n{\r\ns->word = (s->word << nbits) | (data & bitmask[nbits]);\r\ns->nleft += nbits;\r\nwhile (s->nleft >= 8) {\r\nint d = (s->word >> (s->nleft - 8));\r\n*(out[0]++) = d & 255;\r\n(*len)++;\r\ns->nleft -= 8;\r\n}\r\n}\r\nadpcm_state *\r\nisdn_audio_adpcm_init(adpcm_state *s, int nbits)\r\n{\r\nif (!s)\r\ns = kmalloc(sizeof(adpcm_state), GFP_ATOMIC);\r\nif (s) {\r\ns->a = 0;\r\ns->d = 5;\r\ns->word = 0;\r\ns->nleft = 0;\r\ns->nbits = nbits;\r\n}\r\nreturn s;\r\n}\r\ndtmf_state *\r\nisdn_audio_dtmf_init(dtmf_state *s)\r\n{\r\nif (!s)\r\ns = kmalloc(sizeof(dtmf_state), GFP_ATOMIC);\r\nif (s) {\r\ns->idx = 0;\r\ns->last = ' ';\r\n}\r\nreturn s;\r\n}\r\nint\r\nisdn_audio_adpcm2xlaw(adpcm_state *s, int fmt, unsigned char *in,\r\nunsigned char *out, int len)\r\n{\r\nint a = s->a;\r\nint d = s->d;\r\nint nbits = s->nbits;\r\nint olen = 0;\r\nwhile (len) {\r\nint e = isdn_audio_get_bits(s, &in, &len);\r\nint sign;\r\nif (nbits == 4 && e == 0)\r\nd = 4;\r\nsign = (e >> (nbits - 1)) ? -1 : 1;\r\ne &= bitmask[nbits - 1];\r\na += sign * ((e << 1) + 1) * d >> 1;\r\nif (d & 1)\r\na++;\r\nif (fmt)\r\n*out++ = isdn_audio_ulaw_to_alaw[\r\nisdn_audio_linear2ulaw(a << 2)];\r\nelse\r\n*out++ = isdn_audio_linear2ulaw(a << 2);\r\nolen++;\r\nd = (d * Mx[nbits - 2][e] + 0x2000) >> 14;\r\nif (d < 5)\r\nd = 5;\r\n}\r\ns->a = a;\r\ns->d = d;\r\nreturn olen;\r\n}\r\nint\r\nisdn_audio_xlaw2adpcm(adpcm_state *s, int fmt, unsigned char *in,\r\nunsigned char *out, int len)\r\n{\r\nint a = s->a;\r\nint d = s->d;\r\nint nbits = s->nbits;\r\nint olen = 0;\r\nwhile (len--) {\r\nint e = 0,\r\nnmax = 1 << (nbits - 1);\r\nint sign,\r\ndelta;\r\nif (fmt)\r\ndelta = (isdn_audio_alaw_to_s16[*in++] >> 2) - a;\r\nelse\r\ndelta = (isdn_audio_ulaw_to_s16[*in++] >> 2) - a;\r\nif (delta < 0) {\r\ne = nmax;\r\ndelta = -delta;\r\n}\r\nwhile (--nmax && delta > d) {\r\ndelta -= d;\r\ne++;\r\n}\r\nif (nbits == 4 && ((e & 0x0f) == 0))\r\ne = 8;\r\nisdn_audio_put_bits(e, nbits, s, &out, &olen);\r\nsign = (e >> (nbits - 1)) ? -1 : 1;\r\ne &= bitmask[nbits - 1];\r\na += sign * ((e << 1) + 1) * d >> 1;\r\nif (d & 1)\r\na++;\r\nd = (d * Mx[nbits - 2][e] + 0x2000) >> 14;\r\nif (d < 5)\r\nd = 5;\r\n}\r\ns->a = a;\r\ns->d = d;\r\nreturn olen;\r\n}\r\nstatic void\r\nisdn_audio_goertzel(int *sample, modem_info *info)\r\n{\r\nint sk,\r\nsk1,\r\nsk2;\r\nint k,\r\nn;\r\nstruct sk_buff *skb;\r\nint *result;\r\nskb = dev_alloc_skb(sizeof(int) * NCOEFF);\r\nif (!skb) {\r\nprintk(KERN_WARNING\r\n"isdn_audio: Could not alloc DTMF result for ttyI%d\n",\r\ninfo->line);\r\nreturn;\r\n}\r\nresult = (int *) skb_put(skb, sizeof(int) * NCOEFF);\r\nfor (k = 0; k < NCOEFF; k++) {\r\nsk = sk1 = sk2 = 0;\r\nfor (n = 0; n < DTMF_NPOINTS; n++) {\r\nsk = sample[n] + ((cos2pik[k] * sk1) >> 15) - sk2;\r\nsk2 = sk1;\r\nsk1 = sk;\r\n}\r\nsk >>= 1;\r\nsk2 >>= 1;\r\nif (sk < -32768 || sk > 32767)\r\nprintk(KERN_DEBUG\r\n"isdn_audio: dtmf goertzel overflow, sk=%d\n", sk);\r\nif (sk2 < -32768 || sk2 > 32767)\r\nprintk(KERN_DEBUG\r\n"isdn_audio: dtmf goertzel overflow, sk2=%d\n", sk2);\r\nresult[k] =\r\n((sk * sk) >> AMP_BITS) -\r\n((((cos2pik[k] * sk) >> 15) * sk2) >> AMP_BITS) +\r\n((sk2 * sk2) >> AMP_BITS);\r\n}\r\nskb_queue_tail(&info->dtmf_queue, skb);\r\nisdn_timer_ctrl(ISDN_TIMER_MODEMREAD, 1);\r\n}\r\nvoid\r\nisdn_audio_eval_dtmf(modem_info *info)\r\n{\r\nstruct sk_buff *skb;\r\nint *result;\r\ndtmf_state *s;\r\nint silence;\r\nint i;\r\nint di;\r\nint ch;\r\nint grp[2];\r\nchar what;\r\nchar *p;\r\nint thresh;\r\nwhile ((skb = skb_dequeue(&info->dtmf_queue))) {\r\nresult = (int *) skb->data;\r\ns = info->dtmf_state;\r\ngrp[LOGRP] = grp[HIGRP] = -1;\r\nsilence = 0;\r\nthresh = 0;\r\nfor (i = 0; i < NCOEFF; i++) {\r\nif (result[i] > DTMF_TRESH) {\r\nif (result[i] > thresh)\r\nthresh = result[i];\r\n}\r\nelse if (result[i] < SILENCE_TRESH)\r\nsilence++;\r\n}\r\nif (silence == NCOEFF)\r\nwhat = ' ';\r\nelse {\r\nif (thresh > 0) {\r\nthresh = thresh >> 4;\r\nfor (i = 0; i < NCOEFF; i++) {\r\nif (result[i] < thresh)\r\ncontinue;\r\nif (i < NCOEFF / 2) {\r\nif (grp[LOGRP] >= 0) {\r\ngrp[LOGRP] = -1;\r\nbreak;\r\n}\r\nelse\r\ngrp[LOGRP] = i;\r\n}\r\nelse {\r\nif (grp[HIGRP] >= 0) {\r\ngrp[HIGRP] = -1;\r\nbreak;\r\n}\r\nelse\r\ngrp[HIGRP] = i - NCOEFF/2;\r\n}\r\n}\r\nif ((grp[LOGRP] >= 0) && (grp[HIGRP] >= 0)) {\r\nwhat = dtmf_matrix[grp[LOGRP]][grp[HIGRP]];\r\nif (s->last != ' ' && s->last != '.')\r\ns->last = what;\r\n} else\r\nwhat = '.';\r\n}\r\nelse\r\nwhat = '.';\r\n}\r\nif ((what != s->last) && (what != ' ') && (what != '.')) {\r\nprintk(KERN_DEBUG "dtmf: tt='%c'\n", what);\r\np = skb->data;\r\n*p++ = 0x10;\r\n*p = what;\r\nskb_trim(skb, 2);\r\nISDN_AUDIO_SKB_DLECOUNT(skb) = 0;\r\nISDN_AUDIO_SKB_LOCK(skb) = 0;\r\ndi = info->isdn_driver;\r\nch = info->isdn_channel;\r\n__skb_queue_tail(&dev->drv[di]->rpqueue[ch], skb);\r\ndev->drv[di]->rcvcount[ch] += 2;\r\nif ((dev->modempoll) && (info->rcvsched))\r\nisdn_timer_ctrl(ISDN_TIMER_MODEMREAD, 1);\r\nwake_up_interruptible(&dev->drv[di]->rcv_waitq[ch]);\r\n} else\r\nkfree_skb(skb);\r\ns->last = what;\r\n}\r\n}\r\nvoid\r\nisdn_audio_calc_dtmf(modem_info *info, unsigned char *buf, int len, int fmt)\r\n{\r\ndtmf_state *s = info->dtmf_state;\r\nint i;\r\nint c;\r\nwhile (len) {\r\nc = DTMF_NPOINTS - s->idx;\r\nif (c > len)\r\nc = len;\r\nif (c <= 0)\r\nbreak;\r\nfor (i = 0; i < c; i++) {\r\nif (fmt)\r\ns->buf[s->idx++] =\r\nisdn_audio_alaw_to_s16[*buf++] >> (15 - AMP_BITS);\r\nelse\r\ns->buf[s->idx++] =\r\nisdn_audio_ulaw_to_s16[*buf++] >> (15 - AMP_BITS);\r\n}\r\nif (s->idx == DTMF_NPOINTS) {\r\nisdn_audio_goertzel(s->buf, info);\r\ns->idx = 0;\r\n}\r\nlen -= c;\r\n}\r\n}\r\nsilence_state *\r\nisdn_audio_silence_init(silence_state *s)\r\n{\r\nif (!s)\r\ns = kmalloc(sizeof(silence_state), GFP_ATOMIC);\r\nif (s) {\r\ns->idx = 0;\r\ns->state = 0;\r\n}\r\nreturn s;\r\n}\r\nvoid\r\nisdn_audio_calc_silence(modem_info *info, unsigned char *buf, int len, int fmt)\r\n{\r\nsilence_state *s = info->silence_state;\r\nint i;\r\nsigned char c;\r\nif (!info->emu.vpar[1]) return;\r\nfor (i = 0; i < len; i++) {\r\nif (fmt)\r\nc = isdn_audio_alaw_to_ulaw[*buf++];\r\nelse\r\nc = *buf++;\r\nif (c > 0) c -= 128;\r\nc = abs(c);\r\nif (c > (info->emu.vpar[1] * 4)) {\r\ns->idx = 0;\r\ns->state = 1;\r\n} else {\r\nif (s->idx < 210000) s->idx++;\r\n}\r\n}\r\n}\r\nvoid\r\nisdn_audio_put_dle_code(modem_info *info, u_char code)\r\n{\r\nstruct sk_buff *skb;\r\nint di;\r\nint ch;\r\nchar *p;\r\nskb = dev_alloc_skb(2);\r\nif (!skb) {\r\nprintk(KERN_WARNING\r\n"isdn_audio: Could not alloc skb for ttyI%d\n",\r\ninfo->line);\r\nreturn;\r\n}\r\np = (char *) skb_put(skb, 2);\r\np[0] = 0x10;\r\np[1] = code;\r\nISDN_AUDIO_SKB_DLECOUNT(skb) = 0;\r\nISDN_AUDIO_SKB_LOCK(skb) = 0;\r\ndi = info->isdn_driver;\r\nch = info->isdn_channel;\r\n__skb_queue_tail(&dev->drv[di]->rpqueue[ch], skb);\r\ndev->drv[di]->rcvcount[ch] += 2;\r\nif ((dev->modempoll) && (info->rcvsched))\r\nisdn_timer_ctrl(ISDN_TIMER_MODEMREAD, 1);\r\nwake_up_interruptible(&dev->drv[di]->rcv_waitq[ch]);\r\n}\r\nvoid\r\nisdn_audio_eval_silence(modem_info *info)\r\n{\r\nsilence_state *s = info->silence_state;\r\nchar what;\r\nwhat = ' ';\r\nif (s->idx > (info->emu.vpar[2] * 800)) {\r\ns->idx = 0;\r\nif (!s->state) {\r\nwhat = 's';\r\n} else {\r\nwhat = 'q';\r\n}\r\n}\r\nif ((what == 's') || (what == 'q')) {\r\nprintk(KERN_DEBUG "ttyI%d: %s\n", info->line,\r\n(what == 's') ? "silence" : "quiet");\r\nisdn_audio_put_dle_code(info, what);\r\n}\r\n}
