static int pmcraid_slave_alloc(struct scsi_device *scsi_dev)\r\n{\r\nstruct pmcraid_resource_entry *temp, *res = NULL;\r\nstruct pmcraid_instance *pinstance;\r\nu8 target, bus, lun;\r\nunsigned long lock_flags;\r\nint rc = -ENXIO;\r\nu16 fw_version;\r\npinstance = shost_priv(scsi_dev->host);\r\nfw_version = be16_to_cpu(pinstance->inq_data->fw_version);\r\nspin_lock_irqsave(&pinstance->resource_lock, lock_flags);\r\nlist_for_each_entry(temp, &pinstance->used_res_q, queue) {\r\nif (RES_IS_VSET(temp->cfg_entry)) {\r\nif (fw_version <= PMCRAID_FW_VERSION_1)\r\ntarget = temp->cfg_entry.unique_flags1;\r\nelse\r\ntarget = temp->cfg_entry.array_id & 0xFF;\r\nif (target > PMCRAID_MAX_VSET_TARGETS)\r\ncontinue;\r\nbus = PMCRAID_VSET_BUS_ID;\r\nlun = 0;\r\n} else if (RES_IS_GSCSI(temp->cfg_entry)) {\r\ntarget = RES_TARGET(temp->cfg_entry.resource_address);\r\nbus = PMCRAID_PHYS_BUS_ID;\r\nlun = RES_LUN(temp->cfg_entry.resource_address);\r\n} else {\r\ncontinue;\r\n}\r\nif (bus == scsi_dev->channel &&\r\ntarget == scsi_dev->id &&\r\nlun == scsi_dev->lun) {\r\nres = temp;\r\nbreak;\r\n}\r\n}\r\nif (res) {\r\nres->scsi_dev = scsi_dev;\r\nscsi_dev->hostdata = res;\r\nres->change_detected = 0;\r\natomic_set(&res->read_failures, 0);\r\natomic_set(&res->write_failures, 0);\r\nrc = 0;\r\n}\r\nspin_unlock_irqrestore(&pinstance->resource_lock, lock_flags);\r\nreturn rc;\r\n}\r\nstatic int pmcraid_slave_configure(struct scsi_device *scsi_dev)\r\n{\r\nstruct pmcraid_resource_entry *res = scsi_dev->hostdata;\r\nif (!res)\r\nreturn 0;\r\nif (RES_IS_GSCSI(res->cfg_entry) &&\r\nscsi_dev->type != TYPE_ENCLOSURE)\r\nreturn -ENXIO;\r\npmcraid_info("configuring %x:%x:%x:%x\n",\r\nscsi_dev->host->unique_id,\r\nscsi_dev->channel,\r\nscsi_dev->id,\r\nscsi_dev->lun);\r\nif (RES_IS_GSCSI(res->cfg_entry)) {\r\nscsi_dev->allow_restart = 1;\r\n} else if (RES_IS_VSET(res->cfg_entry)) {\r\nscsi_dev->allow_restart = 1;\r\nblk_queue_rq_timeout(scsi_dev->request_queue,\r\nPMCRAID_VSET_IO_TIMEOUT);\r\nblk_queue_max_hw_sectors(scsi_dev->request_queue,\r\nPMCRAID_VSET_MAX_SECTORS);\r\n}\r\nif (scsi_dev->tagged_supported &&\r\n(RES_IS_GSCSI(res->cfg_entry) || RES_IS_VSET(res->cfg_entry))) {\r\nscsi_activate_tcq(scsi_dev, scsi_dev->queue_depth);\r\nscsi_adjust_queue_depth(scsi_dev, MSG_SIMPLE_TAG,\r\nscsi_dev->host->cmd_per_lun);\r\n} else {\r\nscsi_adjust_queue_depth(scsi_dev, 0,\r\nscsi_dev->host->cmd_per_lun);\r\n}\r\nreturn 0;\r\n}\r\nstatic void pmcraid_slave_destroy(struct scsi_device *scsi_dev)\r\n{\r\nstruct pmcraid_resource_entry *res;\r\nres = (struct pmcraid_resource_entry *)scsi_dev->hostdata;\r\nif (res)\r\nres->scsi_dev = NULL;\r\nscsi_dev->hostdata = NULL;\r\n}\r\nstatic int pmcraid_change_queue_depth(struct scsi_device *scsi_dev, int depth,\r\nint reason)\r\n{\r\nif (reason != SCSI_QDEPTH_DEFAULT)\r\nreturn -EOPNOTSUPP;\r\nif (depth > PMCRAID_MAX_CMD_PER_LUN)\r\ndepth = PMCRAID_MAX_CMD_PER_LUN;\r\nscsi_adjust_queue_depth(scsi_dev, scsi_get_tag_type(scsi_dev), depth);\r\nreturn scsi_dev->queue_depth;\r\n}\r\nstatic int pmcraid_change_queue_type(struct scsi_device *scsi_dev, int tag)\r\n{\r\nstruct pmcraid_resource_entry *res;\r\nres = (struct pmcraid_resource_entry *)scsi_dev->hostdata;\r\nif ((res) && scsi_dev->tagged_supported &&\r\n(RES_IS_GSCSI(res->cfg_entry) || RES_IS_VSET(res->cfg_entry))) {\r\nscsi_set_tag_type(scsi_dev, tag);\r\nif (tag)\r\nscsi_activate_tcq(scsi_dev, scsi_dev->queue_depth);\r\nelse\r\nscsi_deactivate_tcq(scsi_dev, scsi_dev->queue_depth);\r\n} else\r\ntag = 0;\r\nreturn tag;\r\n}\r\nvoid pmcraid_init_cmdblk(struct pmcraid_cmd *cmd, int index)\r\n{\r\nstruct pmcraid_ioarcb *ioarcb = &(cmd->ioa_cb->ioarcb);\r\ndma_addr_t dma_addr = cmd->ioa_cb_bus_addr;\r\nif (index >= 0) {\r\nu32 ioasa_offset =\r\noffsetof(struct pmcraid_control_block, ioasa);\r\ncmd->index = index;\r\nioarcb->response_handle = cpu_to_le32(index << 2);\r\nioarcb->ioarcb_bus_addr = cpu_to_le64(dma_addr);\r\nioarcb->ioasa_bus_addr = cpu_to_le64(dma_addr + ioasa_offset);\r\nioarcb->ioasa_len = cpu_to_le16(sizeof(struct pmcraid_ioasa));\r\n} else {\r\nmemset(&cmd->ioa_cb->ioarcb.cdb, 0, PMCRAID_MAX_CDB_LEN);\r\nioarcb->hrrq_id = 0;\r\nioarcb->request_flags0 = 0;\r\nioarcb->request_flags1 = 0;\r\nioarcb->cmd_timeout = 0;\r\nioarcb->ioarcb_bus_addr &= (~0x1FULL);\r\nioarcb->ioadl_bus_addr = 0;\r\nioarcb->ioadl_length = 0;\r\nioarcb->data_transfer_length = 0;\r\nioarcb->add_cmd_param_length = 0;\r\nioarcb->add_cmd_param_offset = 0;\r\ncmd->ioa_cb->ioasa.ioasc = 0;\r\ncmd->ioa_cb->ioasa.residual_data_length = 0;\r\ncmd->time_left = 0;\r\n}\r\ncmd->cmd_done = NULL;\r\ncmd->scsi_cmd = NULL;\r\ncmd->release = 0;\r\ncmd->completion_req = 0;\r\ncmd->sense_buffer = 0;\r\ncmd->sense_buffer_dma = 0;\r\ncmd->dma_handle = 0;\r\ninit_timer(&cmd->timer);\r\n}\r\nstatic void pmcraid_reinit_cmdblk(struct pmcraid_cmd *cmd)\r\n{\r\npmcraid_init_cmdblk(cmd, -1);\r\n}\r\nstatic struct pmcraid_cmd *pmcraid_get_free_cmd(\r\nstruct pmcraid_instance *pinstance\r\n)\r\n{\r\nstruct pmcraid_cmd *cmd = NULL;\r\nunsigned long lock_flags;\r\nspin_lock_irqsave(&pinstance->free_pool_lock, lock_flags);\r\nif (!list_empty(&pinstance->free_cmd_pool)) {\r\ncmd = list_entry(pinstance->free_cmd_pool.next,\r\nstruct pmcraid_cmd, free_list);\r\nlist_del(&cmd->free_list);\r\n}\r\nspin_unlock_irqrestore(&pinstance->free_pool_lock, lock_flags);\r\nif (cmd != NULL)\r\npmcraid_reinit_cmdblk(cmd);\r\nreturn cmd;\r\n}\r\nvoid pmcraid_return_cmd(struct pmcraid_cmd *cmd)\r\n{\r\nstruct pmcraid_instance *pinstance = cmd->drv_inst;\r\nunsigned long lock_flags;\r\nspin_lock_irqsave(&pinstance->free_pool_lock, lock_flags);\r\nlist_add_tail(&cmd->free_list, &pinstance->free_cmd_pool);\r\nspin_unlock_irqrestore(&pinstance->free_pool_lock, lock_flags);\r\n}\r\nstatic u32 pmcraid_read_interrupts(struct pmcraid_instance *pinstance)\r\n{\r\nreturn (pinstance->interrupt_mode) ?\r\nioread32(pinstance->int_regs.ioa_host_msix_interrupt_reg) :\r\nioread32(pinstance->int_regs.ioa_host_interrupt_reg);\r\n}\r\nstatic void pmcraid_disable_interrupts(\r\nstruct pmcraid_instance *pinstance,\r\nu32 intrs\r\n)\r\n{\r\nu32 gmask = ioread32(pinstance->int_regs.global_interrupt_mask_reg);\r\nu32 nmask = gmask | GLOBAL_INTERRUPT_MASK;\r\niowrite32(intrs, pinstance->int_regs.ioa_host_interrupt_clr_reg);\r\niowrite32(nmask, pinstance->int_regs.global_interrupt_mask_reg);\r\nioread32(pinstance->int_regs.global_interrupt_mask_reg);\r\nif (!pinstance->interrupt_mode) {\r\niowrite32(intrs,\r\npinstance->int_regs.ioa_host_interrupt_mask_reg);\r\nioread32(pinstance->int_regs.ioa_host_interrupt_mask_reg);\r\n}\r\n}\r\nstatic void pmcraid_enable_interrupts(\r\nstruct pmcraid_instance *pinstance,\r\nu32 intrs\r\n)\r\n{\r\nu32 gmask = ioread32(pinstance->int_regs.global_interrupt_mask_reg);\r\nu32 nmask = gmask & (~GLOBAL_INTERRUPT_MASK);\r\niowrite32(nmask, pinstance->int_regs.global_interrupt_mask_reg);\r\nif (!pinstance->interrupt_mode) {\r\niowrite32(~intrs,\r\npinstance->int_regs.ioa_host_interrupt_mask_reg);\r\nioread32(pinstance->int_regs.ioa_host_interrupt_mask_reg);\r\n}\r\npmcraid_info("enabled interrupts global mask = %x intr_mask = %x\n",\r\nioread32(pinstance->int_regs.global_interrupt_mask_reg),\r\nioread32(pinstance->int_regs.ioa_host_interrupt_mask_reg));\r\n}\r\nstatic void pmcraid_clr_trans_op(\r\nstruct pmcraid_instance *pinstance\r\n)\r\n{\r\nunsigned long lock_flags;\r\nif (!pinstance->interrupt_mode) {\r\niowrite32(INTRS_TRANSITION_TO_OPERATIONAL,\r\npinstance->int_regs.ioa_host_interrupt_mask_reg);\r\nioread32(pinstance->int_regs.ioa_host_interrupt_mask_reg);\r\niowrite32(INTRS_TRANSITION_TO_OPERATIONAL,\r\npinstance->int_regs.ioa_host_interrupt_clr_reg);\r\nioread32(pinstance->int_regs.ioa_host_interrupt_clr_reg);\r\n}\r\nif (pinstance->reset_cmd != NULL) {\r\ndel_timer(&pinstance->reset_cmd->timer);\r\nspin_lock_irqsave(\r\npinstance->host->host_lock, lock_flags);\r\npinstance->reset_cmd->cmd_done(pinstance->reset_cmd);\r\nspin_unlock_irqrestore(\r\npinstance->host->host_lock, lock_flags);\r\n}\r\n}\r\nstatic void pmcraid_reset_type(struct pmcraid_instance *pinstance)\r\n{\r\nu32 mask;\r\nu32 intrs;\r\nu32 alerts;\r\nmask = ioread32(pinstance->int_regs.ioa_host_interrupt_mask_reg);\r\nintrs = ioread32(pinstance->int_regs.ioa_host_interrupt_reg);\r\nalerts = ioread32(pinstance->int_regs.host_ioa_interrupt_reg);\r\nif ((mask & INTRS_HRRQ_VALID) == 0 ||\r\n(alerts & DOORBELL_IOA_RESET_ALERT) ||\r\n(intrs & PMCRAID_ERROR_INTERRUPTS)) {\r\npmcraid_info("IOA requires hard reset\n");\r\npinstance->ioa_hard_reset = 1;\r\n}\r\nif (intrs & INTRS_IOA_UNIT_CHECK)\r\npinstance->ioa_unit_check = 1;\r\n}\r\nstatic void pmcraid_bist_done(struct pmcraid_cmd *cmd)\r\n{\r\nstruct pmcraid_instance *pinstance = cmd->drv_inst;\r\nunsigned long lock_flags;\r\nint rc;\r\nu16 pci_reg;\r\nrc = pci_read_config_word(pinstance->pdev, PCI_COMMAND, &pci_reg);\r\nif ((rc != PCIBIOS_SUCCESSFUL || (!(pci_reg & PCI_COMMAND_MEMORY))) &&\r\ncmd->time_left > 0) {\r\npmcraid_info("BIST not complete, waiting another 2 secs\n");\r\ncmd->timer.expires = jiffies + cmd->time_left;\r\ncmd->time_left = 0;\r\ncmd->timer.data = (unsigned long)cmd;\r\ncmd->timer.function =\r\n(void (*)(unsigned long))pmcraid_bist_done;\r\nadd_timer(&cmd->timer);\r\n} else {\r\ncmd->time_left = 0;\r\npmcraid_info("BIST is complete, proceeding with reset\n");\r\nspin_lock_irqsave(pinstance->host->host_lock, lock_flags);\r\npmcraid_ioa_reset(cmd);\r\nspin_unlock_irqrestore(pinstance->host->host_lock, lock_flags);\r\n}\r\n}\r\nstatic void pmcraid_start_bist(struct pmcraid_cmd *cmd)\r\n{\r\nstruct pmcraid_instance *pinstance = cmd->drv_inst;\r\nu32 doorbells, intrs;\r\niowrite32(DOORBELL_IOA_START_BIST,\r\npinstance->int_regs.host_ioa_interrupt_reg);\r\ndoorbells = ioread32(pinstance->int_regs.host_ioa_interrupt_reg);\r\nintrs = ioread32(pinstance->int_regs.ioa_host_interrupt_reg);\r\npmcraid_info("doorbells after start bist: %x intrs: %x\n",\r\ndoorbells, intrs);\r\ncmd->time_left = msecs_to_jiffies(PMCRAID_BIST_TIMEOUT);\r\ncmd->timer.data = (unsigned long)cmd;\r\ncmd->timer.expires = jiffies + msecs_to_jiffies(PMCRAID_BIST_TIMEOUT);\r\ncmd->timer.function = (void (*)(unsigned long))pmcraid_bist_done;\r\nadd_timer(&cmd->timer);\r\n}\r\nstatic void pmcraid_reset_alert_done(struct pmcraid_cmd *cmd)\r\n{\r\nstruct pmcraid_instance *pinstance = cmd->drv_inst;\r\nu32 status = ioread32(pinstance->ioa_status);\r\nunsigned long lock_flags;\r\nif (((status & INTRS_CRITICAL_OP_IN_PROGRESS) == 0) ||\r\ncmd->time_left <= 0) {\r\npmcraid_info("critical op is reset proceeding with reset\n");\r\nspin_lock_irqsave(pinstance->host->host_lock, lock_flags);\r\npmcraid_ioa_reset(cmd);\r\nspin_unlock_irqrestore(pinstance->host->host_lock, lock_flags);\r\n} else {\r\npmcraid_info("critical op is not yet reset waiting again\n");\r\ncmd->time_left -= PMCRAID_CHECK_FOR_RESET_TIMEOUT;\r\ncmd->timer.data = (unsigned long)cmd;\r\ncmd->timer.expires = jiffies + PMCRAID_CHECK_FOR_RESET_TIMEOUT;\r\ncmd->timer.function =\r\n(void (*)(unsigned long))pmcraid_reset_alert_done;\r\nadd_timer(&cmd->timer);\r\n}\r\n}\r\nstatic void pmcraid_reset_alert(struct pmcraid_cmd *cmd)\r\n{\r\nstruct pmcraid_instance *pinstance = cmd->drv_inst;\r\nu32 doorbells;\r\nint rc;\r\nu16 pci_reg;\r\nrc = pci_read_config_word(pinstance->pdev, PCI_COMMAND, &pci_reg);\r\nif ((rc == PCIBIOS_SUCCESSFUL) && (pci_reg & PCI_COMMAND_MEMORY)) {\r\ncmd->time_left = PMCRAID_RESET_TIMEOUT;\r\ncmd->timer.data = (unsigned long)cmd;\r\ncmd->timer.expires = jiffies + PMCRAID_CHECK_FOR_RESET_TIMEOUT;\r\ncmd->timer.function =\r\n(void (*)(unsigned long))pmcraid_reset_alert_done;\r\nadd_timer(&cmd->timer);\r\niowrite32(DOORBELL_IOA_RESET_ALERT,\r\npinstance->int_regs.host_ioa_interrupt_reg);\r\ndoorbells =\r\nioread32(pinstance->int_regs.host_ioa_interrupt_reg);\r\npmcraid_info("doorbells after reset alert: %x\n", doorbells);\r\n} else {\r\npmcraid_info("PCI config is not accessible starting BIST\n");\r\npinstance->ioa_state = IOA_STATE_IN_HARD_RESET;\r\npmcraid_start_bist(cmd);\r\n}\r\n}\r\nstatic void pmcraid_timeout_handler(struct pmcraid_cmd *cmd)\r\n{\r\nstruct pmcraid_instance *pinstance = cmd->drv_inst;\r\nunsigned long lock_flags;\r\ndev_info(&pinstance->pdev->dev,\r\n"Adapter being reset due to cmd(CDB[0] = %x) timeout\n",\r\ncmd->ioa_cb->ioarcb.cdb[0]);\r\nspin_lock_irqsave(pinstance->host->host_lock, lock_flags);\r\nif (!pinstance->ioa_reset_in_progress) {\r\npinstance->ioa_reset_attempts = 0;\r\ncmd = pmcraid_get_free_cmd(pinstance);\r\nif (cmd == NULL) {\r\nspin_unlock_irqrestore(pinstance->host->host_lock,\r\nlock_flags);\r\npmcraid_err("no free cmnd block for timeout handler\n");\r\nreturn;\r\n}\r\npinstance->reset_cmd = cmd;\r\npinstance->ioa_reset_in_progress = 1;\r\n} else {\r\npmcraid_info("reset is already in progress\n");\r\nif (pinstance->reset_cmd != cmd) {\r\npmcraid_err("cmd is pending but reset in progress\n");\r\n}\r\nif (cmd == pinstance->reset_cmd)\r\ncmd->cmd_done = pmcraid_ioa_reset;\r\n}\r\nif (pinstance->scn.ioa_state != PMC_DEVICE_EVENT_RESET_START &&\r\npinstance->scn.ioa_state != PMC_DEVICE_EVENT_SHUTDOWN_START)\r\npmcraid_notify_ioastate(pinstance,\r\nPMC_DEVICE_EVENT_RESET_START);\r\npinstance->ioa_state = IOA_STATE_IN_RESET_ALERT;\r\nscsi_block_requests(pinstance->host);\r\npmcraid_reset_alert(cmd);\r\nspin_unlock_irqrestore(pinstance->host->host_lock, lock_flags);\r\n}\r\nstatic void pmcraid_internal_done(struct pmcraid_cmd *cmd)\r\n{\r\npmcraid_info("response internal cmd CDB[0] = %x ioasc = %x\n",\r\ncmd->ioa_cb->ioarcb.cdb[0],\r\nle32_to_cpu(cmd->ioa_cb->ioasa.ioasc));\r\nif (cmd->completion_req) {\r\ncmd->completion_req = 0;\r\ncomplete(&cmd->wait_for_completion);\r\n}\r\nif (cmd->release) {\r\ncmd->release = 0;\r\npmcraid_return_cmd(cmd);\r\n}\r\n}\r\nstatic void pmcraid_reinit_cfgtable_done(struct pmcraid_cmd *cmd)\r\n{\r\npmcraid_info("response internal cmd CDB[0] = %x ioasc = %x\n",\r\ncmd->ioa_cb->ioarcb.cdb[0],\r\nle32_to_cpu(cmd->ioa_cb->ioasa.ioasc));\r\nif (cmd->release) {\r\ncmd->release = 0;\r\npmcraid_return_cmd(cmd);\r\n}\r\npmcraid_info("scheduling worker for config table reinitialization\n");\r\nschedule_work(&cmd->drv_inst->worker_q);\r\n}\r\nstatic void pmcraid_erp_done(struct pmcraid_cmd *cmd)\r\n{\r\nstruct scsi_cmnd *scsi_cmd = cmd->scsi_cmd;\r\nstruct pmcraid_instance *pinstance = cmd->drv_inst;\r\nu32 ioasc = le32_to_cpu(cmd->ioa_cb->ioasa.ioasc);\r\nif (PMCRAID_IOASC_SENSE_KEY(ioasc) > 0) {\r\nscsi_cmd->result |= (DID_ERROR << 16);\r\nscmd_printk(KERN_INFO, scsi_cmd,\r\n"command CDB[0] = %x failed with IOASC: 0x%08X\n",\r\ncmd->ioa_cb->ioarcb.cdb[0], ioasc);\r\n}\r\nif (cmd->sense_buffer != NULL) {\r\nmemcpy(scsi_cmd->sense_buffer,\r\ncmd->sense_buffer,\r\nSCSI_SENSE_BUFFERSIZE);\r\npci_free_consistent(pinstance->pdev,\r\nSCSI_SENSE_BUFFERSIZE,\r\ncmd->sense_buffer, cmd->sense_buffer_dma);\r\ncmd->sense_buffer = NULL;\r\ncmd->sense_buffer_dma = 0;\r\n}\r\nscsi_dma_unmap(scsi_cmd);\r\npmcraid_return_cmd(cmd);\r\nscsi_cmd->scsi_done(scsi_cmd);\r\n}\r\nstatic void _pmcraid_fire_command(struct pmcraid_cmd *cmd)\r\n{\r\nstruct pmcraid_instance *pinstance = cmd->drv_inst;\r\nunsigned long lock_flags;\r\nspin_lock_irqsave(&pinstance->pending_pool_lock, lock_flags);\r\nlist_add_tail(&cmd->free_list, &pinstance->pending_cmd_pool);\r\nspin_unlock_irqrestore(&pinstance->pending_pool_lock, lock_flags);\r\natomic_inc(&pinstance->outstanding_cmds);\r\nmb();\r\niowrite32(le32_to_cpu(cmd->ioa_cb->ioarcb.ioarcb_bus_addr),\r\npinstance->ioarrin);\r\n}\r\nstatic void pmcraid_send_cmd(\r\nstruct pmcraid_cmd *cmd,\r\nvoid (*cmd_done) (struct pmcraid_cmd *),\r\nunsigned long timeout,\r\nvoid (*timeout_func) (struct pmcraid_cmd *)\r\n)\r\n{\r\ncmd->cmd_done = cmd_done;\r\nif (timeout_func) {\r\ncmd->timer.data = (unsigned long)cmd;\r\ncmd->timer.expires = jiffies + timeout;\r\ncmd->timer.function = (void (*)(unsigned long))timeout_func;\r\nadd_timer(&cmd->timer);\r\n}\r\n_pmcraid_fire_command(cmd);\r\n}\r\nstatic void pmcraid_ioa_shutdown_done(struct pmcraid_cmd *cmd)\r\n{\r\nstruct pmcraid_instance *pinstance = cmd->drv_inst;\r\nunsigned long lock_flags;\r\nspin_lock_irqsave(pinstance->host->host_lock, lock_flags);\r\npmcraid_ioa_reset(cmd);\r\nspin_unlock_irqrestore(pinstance->host->host_lock, lock_flags);\r\n}\r\nstatic void pmcraid_ioa_shutdown(struct pmcraid_cmd *cmd)\r\n{\r\npmcraid_info("response for Cancel CCN CDB[0] = %x ioasc = %x\n",\r\ncmd->ioa_cb->ioarcb.cdb[0],\r\nle32_to_cpu(cmd->ioa_cb->ioasa.ioasc));\r\npmcraid_reinit_cmdblk(cmd);\r\ncmd->ioa_cb->ioarcb.request_type = REQ_TYPE_IOACMD;\r\ncmd->ioa_cb->ioarcb.resource_handle =\r\ncpu_to_le32(PMCRAID_IOA_RES_HANDLE);\r\ncmd->ioa_cb->ioarcb.cdb[0] = PMCRAID_IOA_SHUTDOWN;\r\ncmd->ioa_cb->ioarcb.cdb[1] = PMCRAID_SHUTDOWN_NORMAL;\r\npmcraid_info("firing normal shutdown command (%d) to IOA\n",\r\nle32_to_cpu(cmd->ioa_cb->ioarcb.response_handle));\r\npmcraid_notify_ioastate(cmd->drv_inst, PMC_DEVICE_EVENT_SHUTDOWN_START);\r\npmcraid_send_cmd(cmd, pmcraid_ioa_shutdown_done,\r\nPMCRAID_SHUTDOWN_TIMEOUT,\r\npmcraid_timeout_handler);\r\n}\r\nstatic void pmcraid_get_fwversion_done(struct pmcraid_cmd *cmd)\r\n{\r\nstruct pmcraid_instance *pinstance = cmd->drv_inst;\r\nu32 ioasc = le32_to_cpu(cmd->ioa_cb->ioasa.ioasc);\r\nunsigned long lock_flags;\r\nif (ioasc) {\r\npmcraid_err("IOA Inquiry failed with %x\n", ioasc);\r\nspin_lock_irqsave(pinstance->host->host_lock, lock_flags);\r\npinstance->ioa_state = IOA_STATE_IN_RESET_ALERT;\r\npmcraid_reset_alert(cmd);\r\nspin_unlock_irqrestore(pinstance->host->host_lock, lock_flags);\r\n} else {\r\npmcraid_querycfg(cmd);\r\n}\r\n}\r\nstatic void pmcraid_get_fwversion(struct pmcraid_cmd *cmd)\r\n{\r\nstruct pmcraid_ioarcb *ioarcb = &cmd->ioa_cb->ioarcb;\r\nstruct pmcraid_ioadl_desc *ioadl = ioarcb->add_data.u.ioadl;\r\nstruct pmcraid_instance *pinstance = cmd->drv_inst;\r\nu16 data_size = sizeof(struct pmcraid_inquiry_data);\r\npmcraid_reinit_cmdblk(cmd);\r\nioarcb->request_type = REQ_TYPE_SCSI;\r\nioarcb->resource_handle = cpu_to_le32(PMCRAID_IOA_RES_HANDLE);\r\nioarcb->cdb[0] = INQUIRY;\r\nioarcb->cdb[1] = 1;\r\nioarcb->cdb[2] = 0xD0;\r\nioarcb->cdb[3] = (data_size >> 8) & 0xFF;\r\nioarcb->cdb[4] = data_size & 0xFF;\r\nioarcb->ioadl_bus_addr = cpu_to_le64((cmd->ioa_cb_bus_addr) +\r\noffsetof(struct pmcraid_ioarcb,\r\nadd_data.u.ioadl[0]));\r\nioarcb->ioadl_length = cpu_to_le32(sizeof(struct pmcraid_ioadl_desc));\r\nioarcb->ioarcb_bus_addr &= ~(0x1FULL);\r\nioarcb->request_flags0 |= NO_LINK_DESCS;\r\nioarcb->data_transfer_length = cpu_to_le32(data_size);\r\nioadl = &(ioarcb->add_data.u.ioadl[0]);\r\nioadl->flags = IOADL_FLAGS_LAST_DESC;\r\nioadl->address = cpu_to_le64(pinstance->inq_data_baddr);\r\nioadl->data_len = cpu_to_le32(data_size);\r\npmcraid_send_cmd(cmd, pmcraid_get_fwversion_done,\r\nPMCRAID_INTERNAL_TIMEOUT, pmcraid_timeout_handler);\r\n}\r\nstatic void pmcraid_identify_hrrq(struct pmcraid_cmd *cmd)\r\n{\r\nstruct pmcraid_instance *pinstance = cmd->drv_inst;\r\nstruct pmcraid_ioarcb *ioarcb = &cmd->ioa_cb->ioarcb;\r\nint index = cmd->hrrq_index;\r\n__be64 hrrq_addr = cpu_to_be64(pinstance->hrrq_start_bus_addr[index]);\r\nu32 hrrq_size = cpu_to_be32(sizeof(u32) * PMCRAID_MAX_CMD);\r\nvoid (*done_function)(struct pmcraid_cmd *);\r\npmcraid_reinit_cmdblk(cmd);\r\ncmd->hrrq_index = index + 1;\r\nif (cmd->hrrq_index < pinstance->num_hrrq) {\r\ndone_function = pmcraid_identify_hrrq;\r\n} else {\r\ncmd->hrrq_index = 0;\r\ndone_function = pmcraid_get_fwversion;\r\n}\r\nioarcb->request_type = REQ_TYPE_IOACMD;\r\nioarcb->resource_handle = cpu_to_le32(PMCRAID_IOA_RES_HANDLE);\r\nioarcb->hrrq_id = index;\r\nioarcb->cdb[0] = PMCRAID_IDENTIFY_HRRQ;\r\nioarcb->cdb[1] = index;\r\npmcraid_info("HRRQ_IDENTIFY with hrrq:ioarcb:index => %llx:%llx:%x\n",\r\nhrrq_addr, ioarcb->ioarcb_bus_addr, index);\r\nmemcpy(&(ioarcb->cdb[2]), &hrrq_addr, sizeof(hrrq_addr));\r\nmemcpy(&(ioarcb->cdb[10]), &hrrq_size, sizeof(hrrq_size));\r\npmcraid_send_cmd(cmd, done_function,\r\nPMCRAID_INTERNAL_TIMEOUT,\r\npmcraid_timeout_handler);\r\n}\r\nstatic void pmcraid_send_hcam_cmd(struct pmcraid_cmd *cmd)\r\n{\r\nif (cmd->ioa_cb->ioarcb.cdb[1] == PMCRAID_HCAM_CODE_CONFIG_CHANGE)\r\natomic_set(&(cmd->drv_inst->ccn.ignore), 0);\r\nelse\r\natomic_set(&(cmd->drv_inst->ldn.ignore), 0);\r\npmcraid_send_cmd(cmd, cmd->cmd_done, 0, NULL);\r\n}\r\nstatic struct pmcraid_cmd *pmcraid_init_hcam\r\n(\r\nstruct pmcraid_instance *pinstance,\r\nu8 type\r\n)\r\n{\r\nstruct pmcraid_cmd *cmd;\r\nstruct pmcraid_ioarcb *ioarcb;\r\nstruct pmcraid_ioadl_desc *ioadl;\r\nstruct pmcraid_hostrcb *hcam;\r\nvoid (*cmd_done) (struct pmcraid_cmd *);\r\ndma_addr_t dma;\r\nint rcb_size;\r\ncmd = pmcraid_get_free_cmd(pinstance);\r\nif (!cmd) {\r\npmcraid_err("no free command blocks for hcam\n");\r\nreturn cmd;\r\n}\r\nif (type == PMCRAID_HCAM_CODE_CONFIG_CHANGE) {\r\nrcb_size = sizeof(struct pmcraid_hcam_ccn_ext);\r\ncmd_done = pmcraid_process_ccn;\r\ndma = pinstance->ccn.baddr + PMCRAID_AEN_HDR_SIZE;\r\nhcam = &pinstance->ccn;\r\n} else {\r\nrcb_size = sizeof(struct pmcraid_hcam_ldn);\r\ncmd_done = pmcraid_process_ldn;\r\ndma = pinstance->ldn.baddr + PMCRAID_AEN_HDR_SIZE;\r\nhcam = &pinstance->ldn;\r\n}\r\nhcam->cmd = cmd;\r\nioarcb = &cmd->ioa_cb->ioarcb;\r\nioarcb->ioadl_bus_addr = cpu_to_le64((cmd->ioa_cb_bus_addr) +\r\noffsetof(struct pmcraid_ioarcb,\r\nadd_data.u.ioadl[0]));\r\nioarcb->ioadl_length = cpu_to_le32(sizeof(struct pmcraid_ioadl_desc));\r\nioadl = ioarcb->add_data.u.ioadl;\r\nioarcb->request_type = REQ_TYPE_HCAM;\r\nioarcb->resource_handle = cpu_to_le32(PMCRAID_IOA_RES_HANDLE);\r\nioarcb->cdb[0] = PMCRAID_HOST_CONTROLLED_ASYNC;\r\nioarcb->cdb[1] = type;\r\nioarcb->cdb[7] = (rcb_size >> 8) & 0xFF;\r\nioarcb->cdb[8] = (rcb_size) & 0xFF;\r\nioarcb->data_transfer_length = cpu_to_le32(rcb_size);\r\nioadl[0].flags |= IOADL_FLAGS_READ_LAST;\r\nioadl[0].data_len = cpu_to_le32(rcb_size);\r\nioadl[0].address = cpu_to_le32(dma);\r\ncmd->cmd_done = cmd_done;\r\nreturn cmd;\r\n}\r\nstatic void pmcraid_send_hcam(struct pmcraid_instance *pinstance, u8 type)\r\n{\r\nstruct pmcraid_cmd *cmd = pmcraid_init_hcam(pinstance, type);\r\npmcraid_send_hcam_cmd(cmd);\r\n}\r\nstatic void pmcraid_prepare_cancel_cmd(\r\nstruct pmcraid_cmd *cmd,\r\nstruct pmcraid_cmd *cmd_to_cancel\r\n)\r\n{\r\nstruct pmcraid_ioarcb *ioarcb = &cmd->ioa_cb->ioarcb;\r\n__be64 ioarcb_addr = cmd_to_cancel->ioa_cb->ioarcb.ioarcb_bus_addr;\r\nioarcb->resource_handle = cmd_to_cancel->ioa_cb->ioarcb.resource_handle;\r\nioarcb->request_type = REQ_TYPE_IOACMD;\r\nmemset(ioarcb->cdb, 0, PMCRAID_MAX_CDB_LEN);\r\nioarcb->cdb[0] = PMCRAID_ABORT_CMD;\r\nioarcb_addr = cpu_to_be64(ioarcb_addr);\r\nmemcpy(&(ioarcb->cdb[2]), &ioarcb_addr, sizeof(ioarcb_addr));\r\n}\r\nstatic void pmcraid_cancel_hcam(\r\nstruct pmcraid_cmd *cmd,\r\nu8 type,\r\nvoid (*cmd_done) (struct pmcraid_cmd *)\r\n)\r\n{\r\nstruct pmcraid_instance *pinstance;\r\nstruct pmcraid_hostrcb *hcam;\r\npinstance = cmd->drv_inst;\r\nhcam = (type == PMCRAID_HCAM_CODE_LOG_DATA) ?\r\n&pinstance->ldn : &pinstance->ccn;\r\nif (hcam->cmd == NULL)\r\nreturn;\r\npmcraid_prepare_cancel_cmd(cmd, hcam->cmd);\r\npmcraid_send_cmd(cmd, cmd_done,\r\nPMCRAID_INTERNAL_TIMEOUT,\r\npmcraid_timeout_handler);\r\n}\r\nstatic void pmcraid_cancel_ccn(struct pmcraid_cmd *cmd)\r\n{\r\npmcraid_info("response for Cancel LDN CDB[0] = %x ioasc = %x\n",\r\ncmd->ioa_cb->ioarcb.cdb[0],\r\nle32_to_cpu(cmd->ioa_cb->ioasa.ioasc));\r\npmcraid_reinit_cmdblk(cmd);\r\npmcraid_cancel_hcam(cmd,\r\nPMCRAID_HCAM_CODE_CONFIG_CHANGE,\r\npmcraid_ioa_shutdown);\r\n}\r\nstatic void pmcraid_cancel_ldn(struct pmcraid_cmd *cmd)\r\n{\r\npmcraid_cancel_hcam(cmd,\r\nPMCRAID_HCAM_CODE_LOG_DATA,\r\npmcraid_cancel_ccn);\r\n}\r\nstatic int pmcraid_expose_resource(u16 fw_version,\r\nstruct pmcraid_config_table_entry *cfgte)\r\n{\r\nint retval = 0;\r\nif (cfgte->resource_type == RES_TYPE_VSET) {\r\nif (fw_version <= PMCRAID_FW_VERSION_1)\r\nretval = ((cfgte->unique_flags1 & 0x80) == 0);\r\nelse\r\nretval = ((cfgte->unique_flags0 & 0x80) == 0 &&\r\n(cfgte->unique_flags1 & 0x80) == 0);\r\n} else if (cfgte->resource_type == RES_TYPE_GSCSI)\r\nretval = (RES_BUS(cfgte->resource_address) !=\r\nPMCRAID_VIRTUAL_ENCL_BUS_ID);\r\nreturn retval;\r\n}\r\nstatic int pmcraid_netlink_init(void)\r\n{\r\nint result;\r\nresult = genl_register_family(&pmcraid_event_family);\r\nif (result)\r\nreturn result;\r\npmcraid_info("registered NETLINK GENERIC group: %d\n",\r\npmcraid_event_family.id);\r\nreturn result;\r\n}\r\nstatic void pmcraid_netlink_release(void)\r\n{\r\ngenl_unregister_family(&pmcraid_event_family);\r\n}\r\nstatic int pmcraid_notify_aen(\r\nstruct pmcraid_instance *pinstance,\r\nstruct pmcraid_aen_msg *aen_msg,\r\nu32 data_size\r\n)\r\n{\r\nstruct sk_buff *skb;\r\nvoid *msg_header;\r\nu32 total_size, nla_genl_hdr_total_size;\r\nint result;\r\naen_msg->hostno = (pinstance->host->unique_id << 16 |\r\nMINOR(pinstance->cdev.dev));\r\naen_msg->length = data_size;\r\ndata_size += sizeof(*aen_msg);\r\ntotal_size = nla_total_size(data_size);\r\nnla_genl_hdr_total_size =\r\n(total_size + (GENL_HDRLEN +\r\n((struct genl_family *)&pmcraid_event_family)->hdrsize)\r\n+ NLMSG_HDRLEN);\r\nskb = genlmsg_new(nla_genl_hdr_total_size, GFP_ATOMIC);\r\nif (!skb) {\r\npmcraid_err("Failed to allocate aen data SKB of size: %x\n",\r\ntotal_size);\r\nreturn -ENOMEM;\r\n}\r\nmsg_header = genlmsg_put(skb, 0, 0,\r\n&pmcraid_event_family, 0,\r\nPMCRAID_AEN_CMD_EVENT);\r\nif (!msg_header) {\r\npmcraid_err("failed to copy command details\n");\r\nnlmsg_free(skb);\r\nreturn -ENOMEM;\r\n}\r\nresult = nla_put(skb, PMCRAID_AEN_ATTR_EVENT, data_size, aen_msg);\r\nif (result) {\r\npmcraid_err("failed to copy AEN attribute data\n");\r\nnlmsg_free(skb);\r\nreturn -EINVAL;\r\n}\r\nresult = genlmsg_end(skb, msg_header);\r\nif (result < 0) {\r\npmcraid_err("genlmsg_end failed\n");\r\nnlmsg_free(skb);\r\nreturn result;\r\n}\r\nresult =\r\ngenlmsg_multicast(skb, 0, pmcraid_event_family.id, GFP_ATOMIC);\r\nif (result)\r\npmcraid_info("error (%x) sending aen event message\n", result);\r\nreturn result;\r\n}\r\nstatic int pmcraid_notify_ccn(struct pmcraid_instance *pinstance)\r\n{\r\nreturn pmcraid_notify_aen(pinstance,\r\npinstance->ccn.msg,\r\npinstance->ccn.hcam->data_len +\r\nsizeof(struct pmcraid_hcam_hdr));\r\n}\r\nstatic int pmcraid_notify_ldn(struct pmcraid_instance *pinstance)\r\n{\r\nreturn pmcraid_notify_aen(pinstance,\r\npinstance->ldn.msg,\r\npinstance->ldn.hcam->data_len +\r\nsizeof(struct pmcraid_hcam_hdr));\r\n}\r\nstatic void pmcraid_notify_ioastate(struct pmcraid_instance *pinstance, u32 evt)\r\n{\r\npinstance->scn.ioa_state = evt;\r\npmcraid_notify_aen(pinstance,\r\n&pinstance->scn.msg,\r\nsizeof(u32));\r\n}\r\nstatic void pmcraid_handle_config_change(struct pmcraid_instance *pinstance)\r\n{\r\nstruct pmcraid_config_table_entry *cfg_entry;\r\nstruct pmcraid_hcam_ccn *ccn_hcam;\r\nstruct pmcraid_cmd *cmd;\r\nstruct pmcraid_cmd *cfgcmd;\r\nstruct pmcraid_resource_entry *res = NULL;\r\nunsigned long lock_flags;\r\nunsigned long host_lock_flags;\r\nu32 new_entry = 1;\r\nu32 hidden_entry = 0;\r\nu16 fw_version;\r\nint rc;\r\nccn_hcam = (struct pmcraid_hcam_ccn *)pinstance->ccn.hcam;\r\ncfg_entry = &ccn_hcam->cfg_entry;\r\nfw_version = be16_to_cpu(pinstance->inq_data->fw_version);\r\npmcraid_info("CCN(%x): %x timestamp: %llx type: %x lost: %x flags: %x \\r\nres: %x:%x:%x:%x\n",\r\npinstance->ccn.hcam->ilid,\r\npinstance->ccn.hcam->op_code,\r\n((pinstance->ccn.hcam->timestamp1) |\r\n((pinstance->ccn.hcam->timestamp2 & 0xffffffffLL) << 32)),\r\npinstance->ccn.hcam->notification_type,\r\npinstance->ccn.hcam->notification_lost,\r\npinstance->ccn.hcam->flags,\r\npinstance->host->unique_id,\r\nRES_IS_VSET(*cfg_entry) ? PMCRAID_VSET_BUS_ID :\r\n(RES_IS_GSCSI(*cfg_entry) ? PMCRAID_PHYS_BUS_ID :\r\nRES_BUS(cfg_entry->resource_address)),\r\nRES_IS_VSET(*cfg_entry) ?\r\n(fw_version <= PMCRAID_FW_VERSION_1 ?\r\ncfg_entry->unique_flags1 :\r\ncfg_entry->array_id & 0xFF) :\r\nRES_TARGET(cfg_entry->resource_address),\r\nRES_LUN(cfg_entry->resource_address));\r\nif (pinstance->ccn.hcam->notification_lost) {\r\ncfgcmd = pmcraid_get_free_cmd(pinstance);\r\nif (cfgcmd) {\r\npmcraid_info("lost CCN, reading config table\b");\r\npinstance->reinit_cfg_table = 1;\r\npmcraid_querycfg(cfgcmd);\r\n} else {\r\npmcraid_err("lost CCN, no free cmd for querycfg\n");\r\n}\r\ngoto out_notify_apps;\r\n}\r\nif (pinstance->ccn.hcam->notification_type ==\r\nNOTIFICATION_TYPE_ENTRY_CHANGED &&\r\ncfg_entry->resource_type == RES_TYPE_VSET) {\r\nif (fw_version <= PMCRAID_FW_VERSION_1)\r\nhidden_entry = (cfg_entry->unique_flags1 & 0x80) != 0;\r\nelse\r\nhidden_entry = (cfg_entry->unique_flags1 & 0x80) != 0;\r\n} else if (!pmcraid_expose_resource(fw_version, cfg_entry)) {\r\ngoto out_notify_apps;\r\n}\r\nspin_lock_irqsave(&pinstance->resource_lock, lock_flags);\r\nlist_for_each_entry(res, &pinstance->used_res_q, queue) {\r\nrc = memcmp(&res->cfg_entry.resource_address,\r\n&cfg_entry->resource_address,\r\nsizeof(cfg_entry->resource_address));\r\nif (!rc) {\r\nnew_entry = 0;\r\nbreak;\r\n}\r\n}\r\nif (new_entry) {\r\nif (hidden_entry) {\r\nspin_unlock_irqrestore(&pinstance->resource_lock,\r\nlock_flags);\r\ngoto out_notify_apps;\r\n}\r\nif (list_empty(&pinstance->free_res_q)) {\r\nspin_unlock_irqrestore(&pinstance->resource_lock,\r\nlock_flags);\r\npmcraid_err("too many resources attached\n");\r\nspin_lock_irqsave(pinstance->host->host_lock,\r\nhost_lock_flags);\r\npmcraid_send_hcam(pinstance,\r\nPMCRAID_HCAM_CODE_CONFIG_CHANGE);\r\nspin_unlock_irqrestore(pinstance->host->host_lock,\r\nhost_lock_flags);\r\nreturn;\r\n}\r\nres = list_entry(pinstance->free_res_q.next,\r\nstruct pmcraid_resource_entry, queue);\r\nlist_del(&res->queue);\r\nres->scsi_dev = NULL;\r\nres->reset_progress = 0;\r\nlist_add_tail(&res->queue, &pinstance->used_res_q);\r\n}\r\nmemcpy(&res->cfg_entry, cfg_entry, pinstance->config_table_entry_size);\r\nif (pinstance->ccn.hcam->notification_type ==\r\nNOTIFICATION_TYPE_ENTRY_DELETED || hidden_entry) {\r\nif (res->scsi_dev) {\r\nif (fw_version <= PMCRAID_FW_VERSION_1)\r\nres->cfg_entry.unique_flags1 &= 0x7F;\r\nelse\r\nres->cfg_entry.array_id &= 0xFF;\r\nres->change_detected = RES_CHANGE_DEL;\r\nres->cfg_entry.resource_handle =\r\nPMCRAID_INVALID_RES_HANDLE;\r\nschedule_work(&pinstance->worker_q);\r\n} else {\r\nlist_move_tail(&res->queue, &pinstance->free_res_q);\r\n}\r\n} else if (!res->scsi_dev) {\r\nres->change_detected = RES_CHANGE_ADD;\r\nschedule_work(&pinstance->worker_q);\r\n}\r\nspin_unlock_irqrestore(&pinstance->resource_lock, lock_flags);\r\nout_notify_apps:\r\nif (!pmcraid_disable_aen)\r\npmcraid_notify_ccn(pinstance);\r\ncmd = pmcraid_init_hcam(pinstance, PMCRAID_HCAM_CODE_CONFIG_CHANGE);\r\nif (cmd)\r\npmcraid_send_hcam_cmd(cmd);\r\n}\r\nstatic struct pmcraid_ioasc_error *pmcraid_get_error_info(u32 ioasc)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(pmcraid_ioasc_error_table); i++) {\r\nif (pmcraid_ioasc_error_table[i].ioasc_code == ioasc)\r\nreturn &pmcraid_ioasc_error_table[i];\r\n}\r\nreturn NULL;\r\n}\r\nvoid pmcraid_ioasc_logger(u32 ioasc, struct pmcraid_cmd *cmd)\r\n{\r\nstruct pmcraid_ioasc_error *error_info = pmcraid_get_error_info(ioasc);\r\nif (error_info == NULL ||\r\ncmd->drv_inst->current_log_level < error_info->log_level)\r\nreturn;\r\npmcraid_err("cmd [%x] for resource %x failed with %x(%s)\n",\r\ncmd->ioa_cb->ioarcb.cdb[0],\r\ncmd->ioa_cb->ioarcb.resource_handle,\r\nle32_to_cpu(ioasc), error_info->error_string);\r\n}\r\nstatic void pmcraid_handle_error_log(struct pmcraid_instance *pinstance)\r\n{\r\nstruct pmcraid_hcam_ldn *hcam_ldn;\r\nu32 ioasc;\r\nhcam_ldn = (struct pmcraid_hcam_ldn *)pinstance->ldn.hcam;\r\npmcraid_info\r\n("LDN(%x): %x type: %x lost: %x flags: %x overlay id: %x\n",\r\npinstance->ldn.hcam->ilid,\r\npinstance->ldn.hcam->op_code,\r\npinstance->ldn.hcam->notification_type,\r\npinstance->ldn.hcam->notification_lost,\r\npinstance->ldn.hcam->flags,\r\npinstance->ldn.hcam->overlay_id);\r\nif (pinstance->ldn.hcam->notification_type !=\r\nNOTIFICATION_TYPE_ERROR_LOG)\r\nreturn;\r\nif (pinstance->ldn.hcam->notification_lost ==\r\nHOSTRCB_NOTIFICATIONS_LOST)\r\ndev_info(&pinstance->pdev->dev, "Error notifications lost\n");\r\nioasc = le32_to_cpu(hcam_ldn->error_log.fd_ioasc);\r\nif (ioasc == PMCRAID_IOASC_UA_BUS_WAS_RESET ||\r\nioasc == PMCRAID_IOASC_UA_BUS_WAS_RESET_BY_OTHER) {\r\ndev_info(&pinstance->pdev->dev,\r\n"UnitAttention due to IOA Bus Reset\n");\r\nscsi_report_bus_reset(\r\npinstance->host,\r\nRES_BUS(hcam_ldn->error_log.fd_ra));\r\n}\r\nreturn;\r\n}\r\nstatic void pmcraid_process_ccn(struct pmcraid_cmd *cmd)\r\n{\r\nstruct pmcraid_instance *pinstance = cmd->drv_inst;\r\nu32 ioasc = le32_to_cpu(cmd->ioa_cb->ioasa.ioasc);\r\nunsigned long lock_flags;\r\npinstance->ccn.cmd = NULL;\r\npmcraid_return_cmd(cmd);\r\nif (ioasc == PMCRAID_IOASC_IOA_WAS_RESET ||\r\natomic_read(&pinstance->ccn.ignore) == 1) {\r\nreturn;\r\n} else if (ioasc) {\r\ndev_info(&pinstance->pdev->dev,\r\n"Host RCB (CCN) failed with IOASC: 0x%08X\n", ioasc);\r\nspin_lock_irqsave(pinstance->host->host_lock, lock_flags);\r\npmcraid_send_hcam(pinstance, PMCRAID_HCAM_CODE_CONFIG_CHANGE);\r\nspin_unlock_irqrestore(pinstance->host->host_lock, lock_flags);\r\n} else {\r\npmcraid_handle_config_change(pinstance);\r\n}\r\n}\r\nstatic void pmcraid_process_ldn(struct pmcraid_cmd *cmd)\r\n{\r\nstruct pmcraid_instance *pinstance = cmd->drv_inst;\r\nstruct pmcraid_hcam_ldn *ldn_hcam =\r\n(struct pmcraid_hcam_ldn *)pinstance->ldn.hcam;\r\nu32 ioasc = le32_to_cpu(cmd->ioa_cb->ioasa.ioasc);\r\nu32 fd_ioasc = le32_to_cpu(ldn_hcam->error_log.fd_ioasc);\r\nunsigned long lock_flags;\r\npinstance->ldn.cmd = NULL;\r\npmcraid_return_cmd(cmd);\r\nif (ioasc == PMCRAID_IOASC_IOA_WAS_RESET ||\r\natomic_read(&pinstance->ccn.ignore) == 1) {\r\nreturn;\r\n} else if (!ioasc) {\r\npmcraid_handle_error_log(pinstance);\r\nif (fd_ioasc == PMCRAID_IOASC_NR_IOA_RESET_REQUIRED) {\r\nspin_lock_irqsave(pinstance->host->host_lock,\r\nlock_flags);\r\npmcraid_initiate_reset(pinstance);\r\nspin_unlock_irqrestore(pinstance->host->host_lock,\r\nlock_flags);\r\nreturn;\r\n}\r\nif (fd_ioasc == PMCRAID_IOASC_TIME_STAMP_OUT_OF_SYNC) {\r\npinstance->timestamp_error = 1;\r\npmcraid_set_timestamp(cmd);\r\n}\r\n} else {\r\ndev_info(&pinstance->pdev->dev,\r\n"Host RCB(LDN) failed with IOASC: 0x%08X\n", ioasc);\r\n}\r\nif (!pmcraid_disable_aen)\r\npmcraid_notify_ldn(pinstance);\r\ncmd = pmcraid_init_hcam(pinstance, PMCRAID_HCAM_CODE_LOG_DATA);\r\nif (cmd)\r\npmcraid_send_hcam_cmd(cmd);\r\n}\r\nstatic void pmcraid_register_hcams(struct pmcraid_instance *pinstance)\r\n{\r\npmcraid_send_hcam(pinstance, PMCRAID_HCAM_CODE_CONFIG_CHANGE);\r\npmcraid_send_hcam(pinstance, PMCRAID_HCAM_CODE_LOG_DATA);\r\n}\r\nstatic void pmcraid_unregister_hcams(struct pmcraid_cmd *cmd)\r\n{\r\nstruct pmcraid_instance *pinstance = cmd->drv_inst;\r\natomic_set(&pinstance->ccn.ignore, 1);\r\natomic_set(&pinstance->ldn.ignore, 1);\r\nif ((pinstance->force_ioa_reset && !pinstance->ioa_bringdown) ||\r\npinstance->ioa_unit_check) {\r\npinstance->force_ioa_reset = 0;\r\npinstance->ioa_unit_check = 0;\r\npinstance->ioa_state = IOA_STATE_IN_RESET_ALERT;\r\npmcraid_reset_alert(cmd);\r\nreturn;\r\n}\r\npmcraid_cancel_ldn(cmd);\r\n}\r\nstatic int pmcraid_reset_enable_ioa(struct pmcraid_instance *pinstance)\r\n{\r\nu32 intrs;\r\npmcraid_reinit_buffers(pinstance);\r\nintrs = pmcraid_read_interrupts(pinstance);\r\npmcraid_enable_interrupts(pinstance, PMCRAID_PCI_INTERRUPTS);\r\nif (intrs & INTRS_TRANSITION_TO_OPERATIONAL) {\r\nif (!pinstance->interrupt_mode) {\r\niowrite32(INTRS_TRANSITION_TO_OPERATIONAL,\r\npinstance->int_regs.\r\nioa_host_interrupt_mask_reg);\r\niowrite32(INTRS_TRANSITION_TO_OPERATIONAL,\r\npinstance->int_regs.ioa_host_interrupt_clr_reg);\r\n}\r\nreturn 1;\r\n} else {\r\nreturn 0;\r\n}\r\n}\r\nstatic void pmcraid_soft_reset(struct pmcraid_cmd *cmd)\r\n{\r\nstruct pmcraid_instance *pinstance = cmd->drv_inst;\r\nu32 int_reg;\r\nu32 doorbell;\r\ncmd->cmd_done = pmcraid_ioa_reset;\r\ncmd->timer.data = (unsigned long)cmd;\r\ncmd->timer.expires = jiffies +\r\nmsecs_to_jiffies(PMCRAID_TRANSOP_TIMEOUT);\r\ncmd->timer.function = (void (*)(unsigned long))pmcraid_timeout_handler;\r\nif (!timer_pending(&cmd->timer))\r\nadd_timer(&cmd->timer);\r\ndoorbell = DOORBELL_RUNTIME_RESET |\r\nDOORBELL_ENABLE_DESTRUCTIVE_DIAGS;\r\nif (pinstance->interrupt_mode) {\r\niowrite32(DOORBELL_INTR_MODE_MSIX,\r\npinstance->int_regs.host_ioa_interrupt_reg);\r\nioread32(pinstance->int_regs.host_ioa_interrupt_reg);\r\n}\r\niowrite32(doorbell, pinstance->int_regs.host_ioa_interrupt_reg);\r\nioread32(pinstance->int_regs.host_ioa_interrupt_reg),\r\nint_reg = ioread32(pinstance->int_regs.ioa_host_interrupt_reg);\r\npmcraid_info("Waiting for IOA to become operational %x:%x\n",\r\nioread32(pinstance->int_regs.host_ioa_interrupt_reg),\r\nint_reg);\r\n}\r\nstatic void pmcraid_get_dump(struct pmcraid_instance *pinstance)\r\n{\r\npmcraid_info("%s is not yet implemented\n", __func__);\r\n}\r\nstatic void pmcraid_fail_outstanding_cmds(struct pmcraid_instance *pinstance)\r\n{\r\nstruct pmcraid_cmd *cmd, *temp;\r\nunsigned long lock_flags;\r\nspin_lock_irqsave(&pinstance->pending_pool_lock, lock_flags);\r\nlist_for_each_entry_safe(cmd, temp, &pinstance->pending_cmd_pool,\r\nfree_list) {\r\nlist_del(&cmd->free_list);\r\nspin_unlock_irqrestore(&pinstance->pending_pool_lock,\r\nlock_flags);\r\ncmd->ioa_cb->ioasa.ioasc =\r\ncpu_to_le32(PMCRAID_IOASC_IOA_WAS_RESET);\r\ncmd->ioa_cb->ioasa.ilid =\r\ncpu_to_be32(PMCRAID_DRIVER_ILID);\r\ndel_timer(&cmd->timer);\r\nif (cmd->scsi_cmd) {\r\nstruct scsi_cmnd *scsi_cmd = cmd->scsi_cmd;\r\n__le32 resp = cmd->ioa_cb->ioarcb.response_handle;\r\nscsi_cmd->result |= DID_ERROR << 16;\r\nscsi_dma_unmap(scsi_cmd);\r\npmcraid_return_cmd(cmd);\r\npmcraid_info("failing(%d) CDB[0] = %x result: %x\n",\r\nle32_to_cpu(resp) >> 2,\r\ncmd->ioa_cb->ioarcb.cdb[0],\r\nscsi_cmd->result);\r\nscsi_cmd->scsi_done(scsi_cmd);\r\n} else if (cmd->cmd_done == pmcraid_internal_done ||\r\ncmd->cmd_done == pmcraid_erp_done) {\r\ncmd->cmd_done(cmd);\r\n} else if (cmd->cmd_done != pmcraid_ioa_reset &&\r\ncmd->cmd_done != pmcraid_ioa_shutdown_done) {\r\npmcraid_return_cmd(cmd);\r\n}\r\natomic_dec(&pinstance->outstanding_cmds);\r\nspin_lock_irqsave(&pinstance->pending_pool_lock, lock_flags);\r\n}\r\nspin_unlock_irqrestore(&pinstance->pending_pool_lock, lock_flags);\r\n}\r\nstatic void pmcraid_ioa_reset(struct pmcraid_cmd *cmd)\r\n{\r\nstruct pmcraid_instance *pinstance = cmd->drv_inst;\r\nu8 reset_complete = 0;\r\npinstance->ioa_reset_in_progress = 1;\r\nif (pinstance->reset_cmd != cmd) {\r\npmcraid_err("reset is called with different command block\n");\r\npinstance->reset_cmd = cmd;\r\n}\r\npmcraid_info("reset_engine: state = %d, command = %p\n",\r\npinstance->ioa_state, cmd);\r\nswitch (pinstance->ioa_state) {\r\ncase IOA_STATE_DEAD:\r\npmcraid_err("IOA is offline no reset is possible\n");\r\nreset_complete = 1;\r\nbreak;\r\ncase IOA_STATE_IN_BRINGDOWN:\r\npmcraid_disable_interrupts(pinstance, ~0);\r\npinstance->ioa_state = IOA_STATE_IN_RESET_ALERT;\r\npmcraid_reset_alert(cmd);\r\nbreak;\r\ncase IOA_STATE_UNKNOWN:\r\nscsi_block_requests(pinstance->host);\r\nif (pinstance->ioa_hard_reset == 0) {\r\nif (ioread32(pinstance->ioa_status) &\r\nINTRS_TRANSITION_TO_OPERATIONAL) {\r\npmcraid_info("sticky bit set, bring-up\n");\r\npinstance->ioa_state = IOA_STATE_IN_BRINGUP;\r\npmcraid_reinit_cmdblk(cmd);\r\npmcraid_identify_hrrq(cmd);\r\n} else {\r\npinstance->ioa_state = IOA_STATE_IN_SOFT_RESET;\r\npmcraid_soft_reset(cmd);\r\n}\r\n} else {\r\npinstance->ioa_state = IOA_STATE_IN_RESET_ALERT;\r\npmcraid_reset_alert(cmd);\r\n}\r\nbreak;\r\ncase IOA_STATE_IN_RESET_ALERT:\r\npinstance->ioa_state = IOA_STATE_IN_HARD_RESET;\r\npmcraid_start_bist(cmd);\r\nbreak;\r\ncase IOA_STATE_IN_HARD_RESET:\r\npinstance->ioa_reset_attempts++;\r\nif (pinstance->ioa_reset_attempts > PMCRAID_RESET_ATTEMPTS) {\r\npinstance->ioa_reset_attempts = 0;\r\npmcraid_err("IOA didn't respond marking it as dead\n");\r\npinstance->ioa_state = IOA_STATE_DEAD;\r\nif (pinstance->ioa_bringdown)\r\npmcraid_notify_ioastate(pinstance,\r\nPMC_DEVICE_EVENT_SHUTDOWN_FAILED);\r\nelse\r\npmcraid_notify_ioastate(pinstance,\r\nPMC_DEVICE_EVENT_RESET_FAILED);\r\nreset_complete = 1;\r\nbreak;\r\n}\r\npci_restore_state(pinstance->pdev);\r\npmcraid_fail_outstanding_cmds(pinstance);\r\nif (pinstance->ioa_unit_check) {\r\npmcraid_info("unit check is active\n");\r\npinstance->ioa_unit_check = 0;\r\npmcraid_get_dump(pinstance);\r\npinstance->ioa_reset_attempts--;\r\npinstance->ioa_state = IOA_STATE_IN_RESET_ALERT;\r\npmcraid_reset_alert(cmd);\r\nbreak;\r\n}\r\nif (pinstance->ioa_bringdown) {\r\npmcraid_info("bringing down the adapter\n");\r\npinstance->ioa_shutdown_type = SHUTDOWN_NONE;\r\npinstance->ioa_bringdown = 0;\r\npinstance->ioa_state = IOA_STATE_UNKNOWN;\r\npmcraid_notify_ioastate(pinstance,\r\nPMC_DEVICE_EVENT_SHUTDOWN_SUCCESS);\r\nreset_complete = 1;\r\n} else {\r\nif (pmcraid_reset_enable_ioa(pinstance)) {\r\npinstance->ioa_state = IOA_STATE_IN_BRINGUP;\r\npmcraid_info("bringing up the adapter\n");\r\npmcraid_reinit_cmdblk(cmd);\r\npmcraid_identify_hrrq(cmd);\r\n} else {\r\npinstance->ioa_state = IOA_STATE_IN_SOFT_RESET;\r\npmcraid_soft_reset(cmd);\r\n}\r\n}\r\nbreak;\r\ncase IOA_STATE_IN_SOFT_RESET:\r\npmcraid_info("In softreset proceeding with bring-up\n");\r\npinstance->ioa_state = IOA_STATE_IN_BRINGUP;\r\npmcraid_identify_hrrq(cmd);\r\nbreak;\r\ncase IOA_STATE_IN_BRINGUP:\r\npinstance->ioa_state = IOA_STATE_OPERATIONAL;\r\nreset_complete = 1;\r\nbreak;\r\ncase IOA_STATE_OPERATIONAL:\r\ndefault:\r\nif (pinstance->ioa_shutdown_type == SHUTDOWN_NONE &&\r\npinstance->force_ioa_reset == 0) {\r\npmcraid_notify_ioastate(pinstance,\r\nPMC_DEVICE_EVENT_RESET_SUCCESS);\r\nreset_complete = 1;\r\n} else {\r\nif (pinstance->ioa_shutdown_type != SHUTDOWN_NONE)\r\npinstance->ioa_state = IOA_STATE_IN_BRINGDOWN;\r\npmcraid_reinit_cmdblk(cmd);\r\npmcraid_unregister_hcams(cmd);\r\n}\r\nbreak;\r\n}\r\nif (reset_complete) {\r\npinstance->ioa_reset_in_progress = 0;\r\npinstance->ioa_reset_attempts = 0;\r\npinstance->reset_cmd = NULL;\r\npinstance->ioa_shutdown_type = SHUTDOWN_NONE;\r\npinstance->ioa_bringdown = 0;\r\npmcraid_return_cmd(cmd);\r\nif (pinstance->ioa_state == IOA_STATE_OPERATIONAL)\r\npmcraid_register_hcams(pinstance);\r\nwake_up_all(&pinstance->reset_wait_q);\r\n}\r\nreturn;\r\n}\r\nstatic void pmcraid_initiate_reset(struct pmcraid_instance *pinstance)\r\n{\r\nstruct pmcraid_cmd *cmd;\r\nif (!pinstance->ioa_reset_in_progress) {\r\nscsi_block_requests(pinstance->host);\r\ncmd = pmcraid_get_free_cmd(pinstance);\r\nif (cmd == NULL) {\r\npmcraid_err("no cmnd blocks for initiate_reset\n");\r\nreturn;\r\n}\r\npinstance->ioa_shutdown_type = SHUTDOWN_NONE;\r\npinstance->reset_cmd = cmd;\r\npinstance->force_ioa_reset = 1;\r\npmcraid_notify_ioastate(pinstance,\r\nPMC_DEVICE_EVENT_RESET_START);\r\npmcraid_ioa_reset(cmd);\r\n}\r\n}\r\nstatic int pmcraid_reset_reload(\r\nstruct pmcraid_instance *pinstance,\r\nu8 shutdown_type,\r\nu8 target_state\r\n)\r\n{\r\nstruct pmcraid_cmd *reset_cmd = NULL;\r\nunsigned long lock_flags;\r\nint reset = 1;\r\nspin_lock_irqsave(pinstance->host->host_lock, lock_flags);\r\nif (pinstance->ioa_reset_in_progress) {\r\npmcraid_info("reset_reload: reset is already in progress\n");\r\nspin_unlock_irqrestore(pinstance->host->host_lock, lock_flags);\r\nwait_event(pinstance->reset_wait_q,\r\n!pinstance->ioa_reset_in_progress);\r\nspin_lock_irqsave(pinstance->host->host_lock, lock_flags);\r\nif (pinstance->ioa_state == IOA_STATE_DEAD) {\r\nspin_unlock_irqrestore(pinstance->host->host_lock,\r\nlock_flags);\r\npmcraid_info("reset_reload: IOA is dead\n");\r\nreturn reset;\r\n} else if (pinstance->ioa_state == target_state) {\r\nreset = 0;\r\n}\r\n}\r\nif (reset) {\r\npmcraid_info("reset_reload: proceeding with reset\n");\r\nscsi_block_requests(pinstance->host);\r\nreset_cmd = pmcraid_get_free_cmd(pinstance);\r\nif (reset_cmd == NULL) {\r\npmcraid_err("no free cmnd for reset_reload\n");\r\nspin_unlock_irqrestore(pinstance->host->host_lock,\r\nlock_flags);\r\nreturn reset;\r\n}\r\nif (shutdown_type == SHUTDOWN_NORMAL)\r\npinstance->ioa_bringdown = 1;\r\npinstance->ioa_shutdown_type = shutdown_type;\r\npinstance->reset_cmd = reset_cmd;\r\npinstance->force_ioa_reset = reset;\r\npmcraid_info("reset_reload: initiating reset\n");\r\npmcraid_ioa_reset(reset_cmd);\r\nspin_unlock_irqrestore(pinstance->host->host_lock, lock_flags);\r\npmcraid_info("reset_reload: waiting for reset to complete\n");\r\nwait_event(pinstance->reset_wait_q,\r\n!pinstance->ioa_reset_in_progress);\r\npmcraid_info("reset_reload: reset is complete !!\n");\r\nscsi_unblock_requests(pinstance->host);\r\nif (pinstance->ioa_state == target_state)\r\nreset = 0;\r\n}\r\nreturn reset;\r\n}\r\nstatic int pmcraid_reset_bringdown(struct pmcraid_instance *pinstance)\r\n{\r\nreturn pmcraid_reset_reload(pinstance,\r\nSHUTDOWN_NORMAL,\r\nIOA_STATE_UNKNOWN);\r\n}\r\nstatic int pmcraid_reset_bringup(struct pmcraid_instance *pinstance)\r\n{\r\npmcraid_notify_ioastate(pinstance, PMC_DEVICE_EVENT_RESET_START);\r\nreturn pmcraid_reset_reload(pinstance,\r\nSHUTDOWN_NONE,\r\nIOA_STATE_OPERATIONAL);\r\n}\r\nstatic void pmcraid_request_sense(struct pmcraid_cmd *cmd)\r\n{\r\nstruct pmcraid_ioarcb *ioarcb = &cmd->ioa_cb->ioarcb;\r\nstruct pmcraid_ioadl_desc *ioadl = ioarcb->add_data.u.ioadl;\r\ncmd->sense_buffer = pci_alloc_consistent(cmd->drv_inst->pdev,\r\nSCSI_SENSE_BUFFERSIZE,\r\n&cmd->sense_buffer_dma);\r\nif (cmd->sense_buffer == NULL) {\r\npmcraid_err\r\n("couldn't allocate sense buffer for request sense\n");\r\npmcraid_erp_done(cmd);\r\nreturn;\r\n}\r\nmemset(&cmd->ioa_cb->ioasa, 0, sizeof(struct pmcraid_ioasa));\r\nmemset(ioarcb->cdb, 0, PMCRAID_MAX_CDB_LEN);\r\nioarcb->request_flags0 = (SYNC_COMPLETE |\r\nNO_LINK_DESCS |\r\nINHIBIT_UL_CHECK);\r\nioarcb->request_type = REQ_TYPE_SCSI;\r\nioarcb->cdb[0] = REQUEST_SENSE;\r\nioarcb->cdb[4] = SCSI_SENSE_BUFFERSIZE;\r\nioarcb->ioadl_bus_addr = cpu_to_le64((cmd->ioa_cb_bus_addr) +\r\noffsetof(struct pmcraid_ioarcb,\r\nadd_data.u.ioadl[0]));\r\nioarcb->ioadl_length = cpu_to_le32(sizeof(struct pmcraid_ioadl_desc));\r\nioarcb->data_transfer_length = cpu_to_le32(SCSI_SENSE_BUFFERSIZE);\r\nioadl->address = cpu_to_le64(cmd->sense_buffer_dma);\r\nioadl->data_len = cpu_to_le32(SCSI_SENSE_BUFFERSIZE);\r\nioadl->flags = IOADL_FLAGS_LAST_DESC;\r\npmcraid_send_cmd(cmd, pmcraid_erp_done,\r\nPMCRAID_REQUEST_SENSE_TIMEOUT,\r\npmcraid_timeout_handler);\r\n}\r\nstatic void pmcraid_cancel_all(struct pmcraid_cmd *cmd, u32 sense)\r\n{\r\nstruct scsi_cmnd *scsi_cmd = cmd->scsi_cmd;\r\nstruct pmcraid_ioarcb *ioarcb = &cmd->ioa_cb->ioarcb;\r\nstruct pmcraid_resource_entry *res = scsi_cmd->device->hostdata;\r\nvoid (*cmd_done) (struct pmcraid_cmd *) = sense ? pmcraid_erp_done\r\n: pmcraid_request_sense;\r\nmemset(ioarcb->cdb, 0, PMCRAID_MAX_CDB_LEN);\r\nioarcb->request_flags0 = SYNC_OVERRIDE;\r\nioarcb->request_type = REQ_TYPE_IOACMD;\r\nioarcb->cdb[0] = PMCRAID_CANCEL_ALL_REQUESTS;\r\nif (RES_IS_GSCSI(res->cfg_entry))\r\nioarcb->cdb[1] = PMCRAID_SYNC_COMPLETE_AFTER_CANCEL;\r\nioarcb->ioadl_bus_addr = 0;\r\nioarcb->ioadl_length = 0;\r\nioarcb->data_transfer_length = 0;\r\nioarcb->ioarcb_bus_addr &= (~0x1FULL);\r\npmcraid_send_cmd(cmd, cmd_done,\r\nPMCRAID_REQUEST_SENSE_TIMEOUT,\r\npmcraid_timeout_handler);\r\n}\r\nstatic void pmcraid_frame_auto_sense(struct pmcraid_cmd *cmd)\r\n{\r\nu8 *sense_buf = cmd->scsi_cmd->sense_buffer;\r\nstruct pmcraid_resource_entry *res = cmd->scsi_cmd->device->hostdata;\r\nstruct pmcraid_ioasa *ioasa = &cmd->ioa_cb->ioasa;\r\nu32 ioasc = le32_to_cpu(ioasa->ioasc);\r\nu32 failing_lba = 0;\r\nmemset(sense_buf, 0, SCSI_SENSE_BUFFERSIZE);\r\ncmd->scsi_cmd->result = SAM_STAT_CHECK_CONDITION;\r\nif (RES_IS_VSET(res->cfg_entry) &&\r\nioasc == PMCRAID_IOASC_ME_READ_ERROR_NO_REALLOC &&\r\nioasa->u.vset.failing_lba_hi != 0) {\r\nsense_buf[0] = 0x72;\r\nsense_buf[1] = PMCRAID_IOASC_SENSE_KEY(ioasc);\r\nsense_buf[2] = PMCRAID_IOASC_SENSE_CODE(ioasc);\r\nsense_buf[3] = PMCRAID_IOASC_SENSE_QUAL(ioasc);\r\nsense_buf[7] = 12;\r\nsense_buf[8] = 0;\r\nsense_buf[9] = 0x0A;\r\nsense_buf[10] = 0x80;\r\nfailing_lba = le32_to_cpu(ioasa->u.vset.failing_lba_hi);\r\nsense_buf[12] = (failing_lba & 0xff000000) >> 24;\r\nsense_buf[13] = (failing_lba & 0x00ff0000) >> 16;\r\nsense_buf[14] = (failing_lba & 0x0000ff00) >> 8;\r\nsense_buf[15] = failing_lba & 0x000000ff;\r\nfailing_lba = le32_to_cpu(ioasa->u.vset.failing_lba_lo);\r\nsense_buf[16] = (failing_lba & 0xff000000) >> 24;\r\nsense_buf[17] = (failing_lba & 0x00ff0000) >> 16;\r\nsense_buf[18] = (failing_lba & 0x0000ff00) >> 8;\r\nsense_buf[19] = failing_lba & 0x000000ff;\r\n} else {\r\nsense_buf[0] = 0x70;\r\nsense_buf[2] = PMCRAID_IOASC_SENSE_KEY(ioasc);\r\nsense_buf[12] = PMCRAID_IOASC_SENSE_CODE(ioasc);\r\nsense_buf[13] = PMCRAID_IOASC_SENSE_QUAL(ioasc);\r\nif (ioasc == PMCRAID_IOASC_ME_READ_ERROR_NO_REALLOC) {\r\nif (RES_IS_VSET(res->cfg_entry))\r\nfailing_lba =\r\nle32_to_cpu(ioasa->u.\r\nvset.failing_lba_lo);\r\nsense_buf[0] |= 0x80;\r\nsense_buf[3] = (failing_lba >> 24) & 0xff;\r\nsense_buf[4] = (failing_lba >> 16) & 0xff;\r\nsense_buf[5] = (failing_lba >> 8) & 0xff;\r\nsense_buf[6] = failing_lba & 0xff;\r\n}\r\nsense_buf[7] = 6;\r\n}\r\n}\r\nstatic int pmcraid_error_handler(struct pmcraid_cmd *cmd)\r\n{\r\nstruct scsi_cmnd *scsi_cmd = cmd->scsi_cmd;\r\nstruct pmcraid_resource_entry *res = scsi_cmd->device->hostdata;\r\nstruct pmcraid_instance *pinstance = cmd->drv_inst;\r\nstruct pmcraid_ioasa *ioasa = &cmd->ioa_cb->ioasa;\r\nu32 ioasc = le32_to_cpu(ioasa->ioasc);\r\nu32 masked_ioasc = ioasc & PMCRAID_IOASC_SENSE_MASK;\r\nu32 sense_copied = 0;\r\nif (!res) {\r\npmcraid_info("resource pointer is NULL\n");\r\nreturn 0;\r\n}\r\nif (SCSI_CMD_TYPE(scsi_cmd->cmnd[0]) == SCSI_READ_CMD)\r\natomic_inc(&res->read_failures);\r\nelse if (SCSI_CMD_TYPE(scsi_cmd->cmnd[0]) == SCSI_WRITE_CMD)\r\natomic_inc(&res->write_failures);\r\nif (!RES_IS_GSCSI(res->cfg_entry) &&\r\nmasked_ioasc != PMCRAID_IOASC_HW_DEVICE_BUS_STATUS_ERROR) {\r\npmcraid_frame_auto_sense(cmd);\r\n}\r\npmcraid_ioasc_logger(ioasc, cmd);\r\nswitch (masked_ioasc) {\r\ncase PMCRAID_IOASC_AC_TERMINATED_BY_HOST:\r\nscsi_cmd->result |= (DID_ABORT << 16);\r\nbreak;\r\ncase PMCRAID_IOASC_IR_INVALID_RESOURCE_HANDLE:\r\ncase PMCRAID_IOASC_HW_CANNOT_COMMUNICATE:\r\nscsi_cmd->result |= (DID_NO_CONNECT << 16);\r\nbreak;\r\ncase PMCRAID_IOASC_NR_SYNC_REQUIRED:\r\nres->sync_reqd = 1;\r\nscsi_cmd->result |= (DID_IMM_RETRY << 16);\r\nbreak;\r\ncase PMCRAID_IOASC_ME_READ_ERROR_NO_REALLOC:\r\nscsi_cmd->result |= (DID_PASSTHROUGH << 16);\r\nbreak;\r\ncase PMCRAID_IOASC_UA_BUS_WAS_RESET:\r\ncase PMCRAID_IOASC_UA_BUS_WAS_RESET_BY_OTHER:\r\nif (!res->reset_progress)\r\nscsi_report_bus_reset(pinstance->host,\r\nscsi_cmd->device->channel);\r\nscsi_cmd->result |= (DID_ERROR << 16);\r\nbreak;\r\ncase PMCRAID_IOASC_HW_DEVICE_BUS_STATUS_ERROR:\r\nscsi_cmd->result |= PMCRAID_IOASC_SENSE_STATUS(ioasc);\r\nres->sync_reqd = 1;\r\nif (PMCRAID_IOASC_SENSE_STATUS(ioasc) !=\r\nSAM_STAT_CHECK_CONDITION &&\r\nPMCRAID_IOASC_SENSE_STATUS(ioasc) != SAM_STAT_ACA_ACTIVE)\r\nreturn 0;\r\nif (ioasa->auto_sense_length != 0) {\r\nshort sense_len = ioasa->auto_sense_length;\r\nint data_size = min_t(u16, le16_to_cpu(sense_len),\r\nSCSI_SENSE_BUFFERSIZE);\r\nmemcpy(scsi_cmd->sense_buffer,\r\nioasa->sense_data,\r\ndata_size);\r\nsense_copied = 1;\r\n}\r\nif (RES_IS_GSCSI(res->cfg_entry))\r\npmcraid_cancel_all(cmd, sense_copied);\r\nelse if (sense_copied)\r\npmcraid_erp_done(cmd);\r\nelse\r\npmcraid_request_sense(cmd);\r\nreturn 1;\r\ncase PMCRAID_IOASC_NR_INIT_CMD_REQUIRED:\r\nbreak;\r\ndefault:\r\nif (PMCRAID_IOASC_SENSE_KEY(ioasc) > RECOVERED_ERROR)\r\nscsi_cmd->result |= (DID_ERROR << 16);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int pmcraid_reset_device(\r\nstruct scsi_cmnd *scsi_cmd,\r\nunsigned long timeout,\r\nu8 modifier\r\n)\r\n{\r\nstruct pmcraid_cmd *cmd;\r\nstruct pmcraid_instance *pinstance;\r\nstruct pmcraid_resource_entry *res;\r\nstruct pmcraid_ioarcb *ioarcb;\r\nunsigned long lock_flags;\r\nu32 ioasc;\r\npinstance =\r\n(struct pmcraid_instance *)scsi_cmd->device->host->hostdata;\r\nres = scsi_cmd->device->hostdata;\r\nif (!res) {\r\nsdev_printk(KERN_ERR, scsi_cmd->device,\r\n"reset_device: NULL resource pointer\n");\r\nreturn FAILED;\r\n}\r\nspin_lock_irqsave(pinstance->host->host_lock, lock_flags);\r\nif (pinstance->ioa_reset_in_progress ||\r\npinstance->ioa_state == IOA_STATE_DEAD) {\r\nspin_unlock_irqrestore(pinstance->host->host_lock, lock_flags);\r\nreturn FAILED;\r\n}\r\nres->reset_progress = 1;\r\npmcraid_info("Resetting %s resource with addr %x\n",\r\n((modifier & RESET_DEVICE_LUN) ? "LUN" :\r\n((modifier & RESET_DEVICE_TARGET) ? "TARGET" : "BUS")),\r\nle32_to_cpu(res->cfg_entry.resource_address));\r\ncmd = pmcraid_get_free_cmd(pinstance);\r\nif (cmd == NULL) {\r\nspin_unlock_irqrestore(pinstance->host->host_lock, lock_flags);\r\npmcraid_err("%s: no cmd blocks are available\n", __func__);\r\nreturn FAILED;\r\n}\r\nioarcb = &cmd->ioa_cb->ioarcb;\r\nioarcb->resource_handle = res->cfg_entry.resource_handle;\r\nioarcb->request_type = REQ_TYPE_IOACMD;\r\nioarcb->cdb[0] = PMCRAID_RESET_DEVICE;\r\nif (modifier)\r\nmodifier = ENABLE_RESET_MODIFIER | modifier;\r\nioarcb->cdb[1] = modifier;\r\ninit_completion(&cmd->wait_for_completion);\r\ncmd->completion_req = 1;\r\npmcraid_info("cmd(CDB[0] = %x) for %x with index = %d\n",\r\ncmd->ioa_cb->ioarcb.cdb[0],\r\nle32_to_cpu(cmd->ioa_cb->ioarcb.resource_handle),\r\nle32_to_cpu(cmd->ioa_cb->ioarcb.response_handle) >> 2);\r\npmcraid_send_cmd(cmd,\r\npmcraid_internal_done,\r\ntimeout,\r\npmcraid_timeout_handler);\r\nspin_unlock_irqrestore(pinstance->host->host_lock, lock_flags);\r\nwait_for_completion(&cmd->wait_for_completion);\r\npmcraid_return_cmd(cmd);\r\nres->reset_progress = 0;\r\nioasc = le32_to_cpu(cmd->ioa_cb->ioasa.ioasc);\r\nreturn PMCRAID_IOASC_SENSE_KEY(ioasc) ? FAILED : SUCCESS;\r\n}\r\nstatic int _pmcraid_io_done(struct pmcraid_cmd *cmd, int reslen, int ioasc)\r\n{\r\nstruct scsi_cmnd *scsi_cmd = cmd->scsi_cmd;\r\nint rc = 0;\r\nscsi_set_resid(scsi_cmd, reslen);\r\npmcraid_info("response(%d) CDB[0] = %x ioasc:result: %x:%x\n",\r\nle32_to_cpu(cmd->ioa_cb->ioarcb.response_handle) >> 2,\r\ncmd->ioa_cb->ioarcb.cdb[0],\r\nioasc, scsi_cmd->result);\r\nif (PMCRAID_IOASC_SENSE_KEY(ioasc) != 0)\r\nrc = pmcraid_error_handler(cmd);\r\nif (rc == 0) {\r\nscsi_dma_unmap(scsi_cmd);\r\nscsi_cmd->scsi_done(scsi_cmd);\r\n}\r\nreturn rc;\r\n}\r\nstatic void pmcraid_io_done(struct pmcraid_cmd *cmd)\r\n{\r\nu32 ioasc = le32_to_cpu(cmd->ioa_cb->ioasa.ioasc);\r\nu32 reslen = le32_to_cpu(cmd->ioa_cb->ioasa.residual_data_length);\r\nif (_pmcraid_io_done(cmd, reslen, ioasc) == 0)\r\npmcraid_return_cmd(cmd);\r\n}\r\nstatic struct pmcraid_cmd *pmcraid_abort_cmd(struct pmcraid_cmd *cmd)\r\n{\r\nstruct pmcraid_cmd *cancel_cmd;\r\nstruct pmcraid_instance *pinstance;\r\nstruct pmcraid_resource_entry *res;\r\npinstance = (struct pmcraid_instance *)cmd->drv_inst;\r\nres = cmd->scsi_cmd->device->hostdata;\r\ncancel_cmd = pmcraid_get_free_cmd(pinstance);\r\nif (cancel_cmd == NULL) {\r\npmcraid_err("%s: no cmd blocks are available\n", __func__);\r\nreturn NULL;\r\n}\r\npmcraid_prepare_cancel_cmd(cancel_cmd, cmd);\r\npmcraid_info("aborting command CDB[0]= %x with index = %d\n",\r\ncmd->ioa_cb->ioarcb.cdb[0],\r\ncmd->ioa_cb->ioarcb.response_handle >> 2);\r\ninit_completion(&cancel_cmd->wait_for_completion);\r\ncancel_cmd->completion_req = 1;\r\npmcraid_info("command (%d) CDB[0] = %x for %x\n",\r\nle32_to_cpu(cancel_cmd->ioa_cb->ioarcb.response_handle) >> 2,\r\ncancel_cmd->ioa_cb->ioarcb.cdb[0],\r\nle32_to_cpu(cancel_cmd->ioa_cb->ioarcb.resource_handle));\r\npmcraid_send_cmd(cancel_cmd,\r\npmcraid_internal_done,\r\nPMCRAID_INTERNAL_TIMEOUT,\r\npmcraid_timeout_handler);\r\nreturn cancel_cmd;\r\n}\r\nstatic int pmcraid_abort_complete(struct pmcraid_cmd *cancel_cmd)\r\n{\r\nstruct pmcraid_resource_entry *res;\r\nu32 ioasc;\r\nwait_for_completion(&cancel_cmd->wait_for_completion);\r\nres = cancel_cmd->res;\r\ncancel_cmd->res = NULL;\r\nioasc = le32_to_cpu(cancel_cmd->ioa_cb->ioasa.ioasc);\r\nif (ioasc == PMCRAID_IOASC_UA_BUS_WAS_RESET ||\r\nioasc == PMCRAID_IOASC_NR_SYNC_REQUIRED) {\r\nif (ioasc == PMCRAID_IOASC_NR_SYNC_REQUIRED)\r\nres->sync_reqd = 1;\r\nioasc = 0;\r\n}\r\npmcraid_return_cmd(cancel_cmd);\r\nreturn PMCRAID_IOASC_SENSE_KEY(ioasc) ? FAILED : SUCCESS;\r\n}\r\nstatic int pmcraid_eh_abort_handler(struct scsi_cmnd *scsi_cmd)\r\n{\r\nstruct pmcraid_instance *pinstance;\r\nstruct pmcraid_cmd *cmd;\r\nstruct pmcraid_resource_entry *res;\r\nunsigned long host_lock_flags;\r\nunsigned long pending_lock_flags;\r\nstruct pmcraid_cmd *cancel_cmd = NULL;\r\nint cmd_found = 0;\r\nint rc = FAILED;\r\npinstance =\r\n(struct pmcraid_instance *)scsi_cmd->device->host->hostdata;\r\nscmd_printk(KERN_INFO, scsi_cmd,\r\n"I/O command timed out, aborting it.\n");\r\nres = scsi_cmd->device->hostdata;\r\nif (res == NULL)\r\nreturn rc;\r\nspin_lock_irqsave(pinstance->host->host_lock, host_lock_flags);\r\nif (pinstance->ioa_reset_in_progress ||\r\npinstance->ioa_state == IOA_STATE_DEAD) {\r\nspin_unlock_irqrestore(pinstance->host->host_lock,\r\nhost_lock_flags);\r\nreturn rc;\r\n}\r\nspin_lock_irqsave(&pinstance->pending_pool_lock, pending_lock_flags);\r\nlist_for_each_entry(cmd, &pinstance->pending_cmd_pool, free_list) {\r\nif (cmd->scsi_cmd == scsi_cmd) {\r\ncmd_found = 1;\r\nbreak;\r\n}\r\n}\r\nspin_unlock_irqrestore(&pinstance->pending_pool_lock,\r\npending_lock_flags);\r\nif (cmd_found)\r\ncancel_cmd = pmcraid_abort_cmd(cmd);\r\nspin_unlock_irqrestore(pinstance->host->host_lock,\r\nhost_lock_flags);\r\nif (cancel_cmd) {\r\ncancel_cmd->res = cmd->scsi_cmd->device->hostdata;\r\nrc = pmcraid_abort_complete(cancel_cmd);\r\n}\r\nreturn cmd_found ? rc : SUCCESS;\r\n}\r\nstatic int pmcraid_eh_device_reset_handler(struct scsi_cmnd *scmd)\r\n{\r\nscmd_printk(KERN_INFO, scmd,\r\n"resetting device due to an I/O command timeout.\n");\r\nreturn pmcraid_reset_device(scmd,\r\nPMCRAID_INTERNAL_TIMEOUT,\r\nRESET_DEVICE_LUN);\r\n}\r\nstatic int pmcraid_eh_bus_reset_handler(struct scsi_cmnd *scmd)\r\n{\r\nscmd_printk(KERN_INFO, scmd,\r\n"Doing bus reset due to an I/O command timeout.\n");\r\nreturn pmcraid_reset_device(scmd,\r\nPMCRAID_RESET_BUS_TIMEOUT,\r\nRESET_DEVICE_BUS);\r\n}\r\nstatic int pmcraid_eh_target_reset_handler(struct scsi_cmnd *scmd)\r\n{\r\nscmd_printk(KERN_INFO, scmd,\r\n"Doing target reset due to an I/O command timeout.\n");\r\nreturn pmcraid_reset_device(scmd,\r\nPMCRAID_INTERNAL_TIMEOUT,\r\nRESET_DEVICE_TARGET);\r\n}\r\nstatic int pmcraid_eh_host_reset_handler(struct scsi_cmnd *scmd)\r\n{\r\nunsigned long interval = 10000;\r\nint waits = jiffies_to_msecs(PMCRAID_RESET_HOST_TIMEOUT) / interval;\r\nstruct pmcraid_instance *pinstance =\r\n(struct pmcraid_instance *)(scmd->device->host->hostdata);\r\nwhile (waits--) {\r\nif (atomic_read(&pinstance->outstanding_cmds) <=\r\nPMCRAID_MAX_HCAM_CMD)\r\nreturn SUCCESS;\r\nmsleep(interval);\r\n}\r\ndev_err(&pinstance->pdev->dev,\r\n"Adapter being reset due to an I/O command timeout.\n");\r\nreturn pmcraid_reset_bringup(pinstance) == 0 ? SUCCESS : FAILED;\r\n}\r\nstatic u8 pmcraid_task_attributes(struct scsi_cmnd *scsi_cmd)\r\n{\r\nchar tag[2];\r\nu8 rc = 0;\r\nif (scsi_populate_tag_msg(scsi_cmd, tag)) {\r\nswitch (tag[0]) {\r\ncase MSG_SIMPLE_TAG:\r\nrc = TASK_TAG_SIMPLE;\r\nbreak;\r\ncase MSG_HEAD_TAG:\r\nrc = TASK_TAG_QUEUE_HEAD;\r\nbreak;\r\ncase MSG_ORDERED_TAG:\r\nrc = TASK_TAG_ORDERED;\r\nbreak;\r\n};\r\n}\r\nreturn rc;\r\n}\r\nstruct pmcraid_ioadl_desc *\r\npmcraid_init_ioadls(struct pmcraid_cmd *cmd, int sgcount)\r\n{\r\nstruct pmcraid_ioadl_desc *ioadl;\r\nstruct pmcraid_ioarcb *ioarcb = &cmd->ioa_cb->ioarcb;\r\nint ioadl_count = 0;\r\nif (ioarcb->add_cmd_param_length)\r\nioadl_count = DIV_ROUND_UP(ioarcb->add_cmd_param_length, 16);\r\nioarcb->ioadl_length =\r\nsizeof(struct pmcraid_ioadl_desc) * sgcount;\r\nif ((sgcount + ioadl_count) > (ARRAY_SIZE(ioarcb->add_data.u.ioadl))) {\r\nioarcb->ioarcb_bus_addr &= ~(0x1FULL);\r\nioarcb->ioadl_bus_addr =\r\ncpu_to_le64((cmd->ioa_cb_bus_addr) +\r\noffsetof(struct pmcraid_ioarcb,\r\nadd_data.u.ioadl[3]));\r\nioadl = &ioarcb->add_data.u.ioadl[3];\r\n} else {\r\nioarcb->ioadl_bus_addr =\r\ncpu_to_le64((cmd->ioa_cb_bus_addr) +\r\noffsetof(struct pmcraid_ioarcb,\r\nadd_data.u.ioadl[ioadl_count]));\r\nioadl = &ioarcb->add_data.u.ioadl[ioadl_count];\r\nioarcb->ioarcb_bus_addr |=\r\nDIV_ROUND_CLOSEST(sgcount + ioadl_count, 8);\r\n}\r\nreturn ioadl;\r\n}\r\nstatic int pmcraid_build_ioadl(\r\nstruct pmcraid_instance *pinstance,\r\nstruct pmcraid_cmd *cmd\r\n)\r\n{\r\nint i, nseg;\r\nstruct scatterlist *sglist;\r\nstruct scsi_cmnd *scsi_cmd = cmd->scsi_cmd;\r\nstruct pmcraid_ioarcb *ioarcb = &(cmd->ioa_cb->ioarcb);\r\nstruct pmcraid_ioadl_desc *ioadl = ioarcb->add_data.u.ioadl;\r\nu32 length = scsi_bufflen(scsi_cmd);\r\nif (!length)\r\nreturn 0;\r\nnseg = scsi_dma_map(scsi_cmd);\r\nif (nseg < 0) {\r\nscmd_printk(KERN_ERR, scsi_cmd, "scsi_map_dma failed!\n");\r\nreturn -1;\r\n} else if (nseg > PMCRAID_MAX_IOADLS) {\r\nscsi_dma_unmap(scsi_cmd);\r\nscmd_printk(KERN_ERR, scsi_cmd,\r\n"sg count is (%d) more than allowed!\n", nseg);\r\nreturn -1;\r\n}\r\nif (scsi_cmd->sc_data_direction == DMA_TO_DEVICE)\r\nioarcb->request_flags0 |= TRANSFER_DIR_WRITE;\r\nioarcb->request_flags0 |= NO_LINK_DESCS;\r\nioarcb->data_transfer_length = cpu_to_le32(length);\r\nioadl = pmcraid_init_ioadls(cmd, nseg);\r\nscsi_for_each_sg(scsi_cmd, sglist, nseg, i) {\r\nioadl[i].data_len = cpu_to_le32(sg_dma_len(sglist));\r\nioadl[i].address = cpu_to_le64(sg_dma_address(sglist));\r\nioadl[i].flags = 0;\r\n}\r\nioadl[i - 1].flags = IOADL_FLAGS_LAST_DESC;\r\nreturn 0;\r\n}\r\nstatic void pmcraid_free_sglist(struct pmcraid_sglist *sglist)\r\n{\r\nint i;\r\nfor (i = 0; i < sglist->num_sg; i++)\r\n__free_pages(sg_page(&(sglist->scatterlist[i])),\r\nsglist->order);\r\nkfree(sglist);\r\n}\r\nstatic struct pmcraid_sglist *pmcraid_alloc_sglist(int buflen)\r\n{\r\nstruct pmcraid_sglist *sglist;\r\nstruct scatterlist *scatterlist;\r\nstruct page *page;\r\nint num_elem, i, j;\r\nint sg_size;\r\nint order;\r\nint bsize_elem;\r\nsg_size = buflen / (PMCRAID_MAX_IOADLS - 1);\r\norder = (sg_size > 0) ? get_order(sg_size) : 0;\r\nbsize_elem = PAGE_SIZE * (1 << order);\r\nif (buflen % bsize_elem)\r\nnum_elem = (buflen / bsize_elem) + 1;\r\nelse\r\nnum_elem = buflen / bsize_elem;\r\nsglist = kzalloc(sizeof(struct pmcraid_sglist) +\r\n(sizeof(struct scatterlist) * (num_elem - 1)),\r\nGFP_KERNEL);\r\nif (sglist == NULL)\r\nreturn NULL;\r\nscatterlist = sglist->scatterlist;\r\nsg_init_table(scatterlist, num_elem);\r\nsglist->order = order;\r\nsglist->num_sg = num_elem;\r\nsg_size = buflen;\r\nfor (i = 0; i < num_elem; i++) {\r\npage = alloc_pages(GFP_KERNEL|GFP_DMA|__GFP_ZERO, order);\r\nif (!page) {\r\nfor (j = i - 1; j >= 0; j--)\r\n__free_pages(sg_page(&scatterlist[j]), order);\r\nkfree(sglist);\r\nreturn NULL;\r\n}\r\nsg_set_page(&scatterlist[i], page,\r\nsg_size < bsize_elem ? sg_size : bsize_elem, 0);\r\nsg_size -= bsize_elem;\r\n}\r\nreturn sglist;\r\n}\r\nstatic int pmcraid_copy_sglist(\r\nstruct pmcraid_sglist *sglist,\r\nunsigned long buffer,\r\nu32 len,\r\nint direction\r\n)\r\n{\r\nstruct scatterlist *scatterlist;\r\nvoid *kaddr;\r\nint bsize_elem;\r\nint i;\r\nint rc = 0;\r\nbsize_elem = PAGE_SIZE * (1 << sglist->order);\r\nscatterlist = sglist->scatterlist;\r\nfor (i = 0; i < (len / bsize_elem); i++, buffer += bsize_elem) {\r\nstruct page *page = sg_page(&scatterlist[i]);\r\nkaddr = kmap(page);\r\nif (direction == DMA_TO_DEVICE)\r\nrc = __copy_from_user(kaddr,\r\n(void *)buffer,\r\nbsize_elem);\r\nelse\r\nrc = __copy_to_user((void *)buffer, kaddr, bsize_elem);\r\nkunmap(page);\r\nif (rc) {\r\npmcraid_err("failed to copy user data into sg list\n");\r\nreturn -EFAULT;\r\n}\r\nscatterlist[i].length = bsize_elem;\r\n}\r\nif (len % bsize_elem) {\r\nstruct page *page = sg_page(&scatterlist[i]);\r\nkaddr = kmap(page);\r\nif (direction == DMA_TO_DEVICE)\r\nrc = __copy_from_user(kaddr,\r\n(void *)buffer,\r\nlen % bsize_elem);\r\nelse\r\nrc = __copy_to_user((void *)buffer,\r\nkaddr,\r\nlen % bsize_elem);\r\nkunmap(page);\r\nscatterlist[i].length = len % bsize_elem;\r\n}\r\nif (rc) {\r\npmcraid_err("failed to copy user data into sg list\n");\r\nrc = -EFAULT;\r\n}\r\nreturn rc;\r\n}\r\nstatic int pmcraid_queuecommand_lck(\r\nstruct scsi_cmnd *scsi_cmd,\r\nvoid (*done) (struct scsi_cmnd *)\r\n)\r\n{\r\nstruct pmcraid_instance *pinstance;\r\nstruct pmcraid_resource_entry *res;\r\nstruct pmcraid_ioarcb *ioarcb;\r\nstruct pmcraid_cmd *cmd;\r\nu32 fw_version;\r\nint rc = 0;\r\npinstance =\r\n(struct pmcraid_instance *)scsi_cmd->device->host->hostdata;\r\nfw_version = be16_to_cpu(pinstance->inq_data->fw_version);\r\nscsi_cmd->scsi_done = done;\r\nres = scsi_cmd->device->hostdata;\r\nscsi_cmd->result = (DID_OK << 16);\r\nif (pinstance->ioa_state == IOA_STATE_DEAD) {\r\npmcraid_info("IOA is dead, but queuecommand is scheduled\n");\r\nscsi_cmd->result = (DID_NO_CONNECT << 16);\r\nscsi_cmd->scsi_done(scsi_cmd);\r\nreturn 0;\r\n}\r\nif (pinstance->ioa_reset_in_progress)\r\nreturn SCSI_MLQUEUE_HOST_BUSY;\r\nif (scsi_cmd->cmnd[0] == SYNCHRONIZE_CACHE) {\r\npmcraid_info("SYNC_CACHE(0x35), completing in driver itself\n");\r\nscsi_cmd->scsi_done(scsi_cmd);\r\nreturn 0;\r\n}\r\ncmd = pmcraid_get_free_cmd(pinstance);\r\nif (cmd == NULL) {\r\npmcraid_err("free command block is not available\n");\r\nreturn SCSI_MLQUEUE_HOST_BUSY;\r\n}\r\ncmd->scsi_cmd = scsi_cmd;\r\nioarcb = &(cmd->ioa_cb->ioarcb);\r\nmemcpy(ioarcb->cdb, scsi_cmd->cmnd, scsi_cmd->cmd_len);\r\nioarcb->resource_handle = res->cfg_entry.resource_handle;\r\nioarcb->request_type = REQ_TYPE_SCSI;\r\nioarcb->hrrq_id = atomic_add_return(1, &(pinstance->last_message_id)) %\r\npinstance->num_hrrq;\r\ncmd->cmd_done = pmcraid_io_done;\r\nif (RES_IS_GSCSI(res->cfg_entry) || RES_IS_VSET(res->cfg_entry)) {\r\nif (scsi_cmd->underflow == 0)\r\nioarcb->request_flags0 |= INHIBIT_UL_CHECK;\r\nif (res->sync_reqd) {\r\nioarcb->request_flags0 |= SYNC_COMPLETE;\r\nres->sync_reqd = 0;\r\n}\r\nioarcb->request_flags0 |= NO_LINK_DESCS;\r\nioarcb->request_flags1 |= pmcraid_task_attributes(scsi_cmd);\r\nif (RES_IS_GSCSI(res->cfg_entry))\r\nioarcb->request_flags1 |= DELAY_AFTER_RESET;\r\n}\r\nrc = pmcraid_build_ioadl(pinstance, cmd);\r\npmcraid_info("command (%d) CDB[0] = %x for %x:%x:%x:%x\n",\r\nle32_to_cpu(ioarcb->response_handle) >> 2,\r\nscsi_cmd->cmnd[0], pinstance->host->unique_id,\r\nRES_IS_VSET(res->cfg_entry) ? PMCRAID_VSET_BUS_ID :\r\nPMCRAID_PHYS_BUS_ID,\r\nRES_IS_VSET(res->cfg_entry) ?\r\n(fw_version <= PMCRAID_FW_VERSION_1 ?\r\nres->cfg_entry.unique_flags1 :\r\nres->cfg_entry.array_id & 0xFF) :\r\nRES_TARGET(res->cfg_entry.resource_address),\r\nRES_LUN(res->cfg_entry.resource_address));\r\nif (likely(rc == 0)) {\r\n_pmcraid_fire_command(cmd);\r\n} else {\r\npmcraid_err("queuecommand could not build ioadl\n");\r\npmcraid_return_cmd(cmd);\r\nrc = SCSI_MLQUEUE_HOST_BUSY;\r\n}\r\nreturn rc;\r\n}\r\nint pmcraid_chr_release(struct inode *inode, struct file *filep)\r\n{\r\nstruct pmcraid_instance *pinstance = filep->private_data;\r\nfilep->private_data = NULL;\r\nfasync_helper(-1, filep, 0, &pinstance->aen_queue);\r\nreturn 0;\r\n}\r\nstatic int pmcraid_chr_fasync(int fd, struct file *filep, int mode)\r\n{\r\nstruct pmcraid_instance *pinstance;\r\nint rc;\r\npinstance = filep->private_data;\r\nmutex_lock(&pinstance->aen_queue_lock);\r\nrc = fasync_helper(fd, filep, mode, &pinstance->aen_queue);\r\nmutex_unlock(&pinstance->aen_queue_lock);\r\nreturn rc;\r\n}\r\nstatic int pmcraid_build_passthrough_ioadls(\r\nstruct pmcraid_cmd *cmd,\r\nint buflen,\r\nint direction\r\n)\r\n{\r\nstruct pmcraid_sglist *sglist = NULL;\r\nstruct scatterlist *sg = NULL;\r\nstruct pmcraid_ioarcb *ioarcb = &cmd->ioa_cb->ioarcb;\r\nstruct pmcraid_ioadl_desc *ioadl;\r\nint i;\r\nsglist = pmcraid_alloc_sglist(buflen);\r\nif (!sglist) {\r\npmcraid_err("can't allocate memory for passthrough SGls\n");\r\nreturn -ENOMEM;\r\n}\r\nsglist->num_dma_sg = pci_map_sg(cmd->drv_inst->pdev,\r\nsglist->scatterlist,\r\nsglist->num_sg, direction);\r\nif (!sglist->num_dma_sg || sglist->num_dma_sg > PMCRAID_MAX_IOADLS) {\r\ndev_err(&cmd->drv_inst->pdev->dev,\r\n"Failed to map passthrough buffer!\n");\r\npmcraid_free_sglist(sglist);\r\nreturn -EIO;\r\n}\r\ncmd->sglist = sglist;\r\nioarcb->request_flags0 |= NO_LINK_DESCS;\r\nioadl = pmcraid_init_ioadls(cmd, sglist->num_dma_sg);\r\nfor_each_sg(sglist->scatterlist, sg, sglist->num_dma_sg, i) {\r\nioadl[i].data_len = cpu_to_le32(sg_dma_len(sg));\r\nioadl[i].address = cpu_to_le64(sg_dma_address(sg));\r\nioadl[i].flags = 0;\r\n}\r\nioadl[i - 1].flags = IOADL_FLAGS_LAST_DESC;\r\nreturn 0;\r\n}\r\nstatic void pmcraid_release_passthrough_ioadls(\r\nstruct pmcraid_cmd *cmd,\r\nint buflen,\r\nint direction\r\n)\r\n{\r\nstruct pmcraid_sglist *sglist = cmd->sglist;\r\nif (buflen > 0) {\r\npci_unmap_sg(cmd->drv_inst->pdev,\r\nsglist->scatterlist,\r\nsglist->num_sg,\r\ndirection);\r\npmcraid_free_sglist(sglist);\r\ncmd->sglist = NULL;\r\n}\r\n}\r\nstatic long pmcraid_ioctl_passthrough(\r\nstruct pmcraid_instance *pinstance,\r\nunsigned int ioctl_cmd,\r\nunsigned int buflen,\r\nunsigned long arg\r\n)\r\n{\r\nstruct pmcraid_passthrough_ioctl_buffer *buffer;\r\nstruct pmcraid_ioarcb *ioarcb;\r\nstruct pmcraid_cmd *cmd;\r\nstruct pmcraid_cmd *cancel_cmd;\r\nunsigned long request_buffer;\r\nunsigned long request_offset;\r\nunsigned long lock_flags;\r\nvoid *ioasa;\r\nu32 ioasc;\r\nint request_size;\r\nint buffer_size;\r\nu8 access, direction;\r\nint rc = 0;\r\nif (pinstance->ioa_reset_in_progress) {\r\nrc = wait_event_interruptible_timeout(\r\npinstance->reset_wait_q,\r\n!pinstance->ioa_reset_in_progress,\r\nmsecs_to_jiffies(10000));\r\nif (!rc)\r\nreturn -ETIMEDOUT;\r\nelse if (rc < 0)\r\nreturn -ERESTARTSYS;\r\n}\r\nif (pinstance->ioa_state != IOA_STATE_OPERATIONAL) {\r\npmcraid_err("IOA is not operational\n");\r\nreturn -ENOTTY;\r\n}\r\nbuffer_size = sizeof(struct pmcraid_passthrough_ioctl_buffer);\r\nbuffer = kmalloc(buffer_size, GFP_KERNEL);\r\nif (!buffer) {\r\npmcraid_err("no memory for passthrough buffer\n");\r\nreturn -ENOMEM;\r\n}\r\nrequest_offset =\r\noffsetof(struct pmcraid_passthrough_ioctl_buffer, request_buffer);\r\nrequest_buffer = arg + request_offset;\r\nrc = __copy_from_user(buffer,\r\n(struct pmcraid_passthrough_ioctl_buffer *) arg,\r\nsizeof(struct pmcraid_passthrough_ioctl_buffer));\r\nioasa =\r\n(void *)(arg +\r\noffsetof(struct pmcraid_passthrough_ioctl_buffer, ioasa));\r\nif (rc) {\r\npmcraid_err("ioctl: can't copy passthrough buffer\n");\r\nrc = -EFAULT;\r\ngoto out_free_buffer;\r\n}\r\nrequest_size = buffer->ioarcb.data_transfer_length;\r\nif (buffer->ioarcb.request_flags0 & TRANSFER_DIR_WRITE) {\r\naccess = VERIFY_READ;\r\ndirection = DMA_TO_DEVICE;\r\n} else {\r\naccess = VERIFY_WRITE;\r\ndirection = DMA_FROM_DEVICE;\r\n}\r\nif (request_size > 0) {\r\nrc = access_ok(access, arg, request_offset + request_size);\r\nif (!rc) {\r\nrc = -EFAULT;\r\ngoto out_free_buffer;\r\n}\r\n} else if (request_size < 0) {\r\nrc = -EINVAL;\r\ngoto out_free_buffer;\r\n}\r\nif (buffer->ioarcb.add_cmd_param_length > PMCRAID_ADD_CMD_PARAM_LEN) {\r\nrc = -EINVAL;\r\ngoto out_free_buffer;\r\n}\r\ncmd = pmcraid_get_free_cmd(pinstance);\r\nif (!cmd) {\r\npmcraid_err("free command block is not available\n");\r\nrc = -ENOMEM;\r\ngoto out_free_buffer;\r\n}\r\ncmd->scsi_cmd = NULL;\r\nioarcb = &(cmd->ioa_cb->ioarcb);\r\nioarcb->resource_handle = buffer->ioarcb.resource_handle;\r\nioarcb->data_transfer_length = buffer->ioarcb.data_transfer_length;\r\nioarcb->cmd_timeout = buffer->ioarcb.cmd_timeout;\r\nioarcb->request_type = buffer->ioarcb.request_type;\r\nioarcb->request_flags0 = buffer->ioarcb.request_flags0;\r\nioarcb->request_flags1 = buffer->ioarcb.request_flags1;\r\nmemcpy(ioarcb->cdb, buffer->ioarcb.cdb, PMCRAID_MAX_CDB_LEN);\r\nif (buffer->ioarcb.add_cmd_param_length) {\r\nioarcb->add_cmd_param_length =\r\nbuffer->ioarcb.add_cmd_param_length;\r\nioarcb->add_cmd_param_offset =\r\nbuffer->ioarcb.add_cmd_param_offset;\r\nmemcpy(ioarcb->add_data.u.add_cmd_params,\r\nbuffer->ioarcb.add_data.u.add_cmd_params,\r\nbuffer->ioarcb.add_cmd_param_length);\r\n}\r\nioarcb->hrrq_id = atomic_add_return(1, &(pinstance->last_message_id)) %\r\npinstance->num_hrrq;\r\nif (request_size) {\r\nrc = pmcraid_build_passthrough_ioadls(cmd,\r\nrequest_size,\r\ndirection);\r\nif (rc) {\r\npmcraid_err("couldn't build passthrough ioadls\n");\r\ngoto out_free_buffer;\r\n}\r\n} else if (request_size < 0) {\r\nrc = -EINVAL;\r\ngoto out_free_buffer;\r\n}\r\nif (direction == DMA_TO_DEVICE && request_size > 0) {\r\nrc = pmcraid_copy_sglist(cmd->sglist,\r\nrequest_buffer,\r\nrequest_size,\r\ndirection);\r\nif (rc) {\r\npmcraid_err("failed to copy user buffer\n");\r\ngoto out_free_sglist;\r\n}\r\n}\r\ncmd->cmd_done = pmcraid_internal_done;\r\ninit_completion(&cmd->wait_for_completion);\r\ncmd->completion_req = 1;\r\npmcraid_info("command(%d) (CDB[0] = %x) for %x\n",\r\nle32_to_cpu(cmd->ioa_cb->ioarcb.response_handle) >> 2,\r\ncmd->ioa_cb->ioarcb.cdb[0],\r\nle32_to_cpu(cmd->ioa_cb->ioarcb.resource_handle));\r\nspin_lock_irqsave(pinstance->host->host_lock, lock_flags);\r\n_pmcraid_fire_command(cmd);\r\nspin_unlock_irqrestore(pinstance->host->host_lock, lock_flags);\r\nbuffer->ioarcb.cmd_timeout = 0;\r\nif (buffer->ioarcb.cmd_timeout == 0) {\r\nwait_for_completion(&cmd->wait_for_completion);\r\n} else if (!wait_for_completion_timeout(\r\n&cmd->wait_for_completion,\r\nmsecs_to_jiffies(buffer->ioarcb.cmd_timeout * 1000))) {\r\npmcraid_info("aborting cmd %d (CDB[0] = %x) due to timeout\n",\r\nle32_to_cpu(cmd->ioa_cb->ioarcb.response_handle >> 2),\r\ncmd->ioa_cb->ioarcb.cdb[0]);\r\nspin_lock_irqsave(pinstance->host->host_lock, lock_flags);\r\ncancel_cmd = pmcraid_abort_cmd(cmd);\r\nspin_unlock_irqrestore(pinstance->host->host_lock, lock_flags);\r\nif (cancel_cmd) {\r\nwait_for_completion(&cancel_cmd->wait_for_completion);\r\nioasc = cancel_cmd->ioa_cb->ioasa.ioasc;\r\npmcraid_return_cmd(cancel_cmd);\r\nif (ioasc == PMCRAID_IOASC_IOA_WAS_RESET ||\r\nPMCRAID_IOASC_SENSE_KEY(ioasc) == 0x00) {\r\nif (ioasc != PMCRAID_IOASC_GC_IOARCB_NOTFOUND)\r\nrc = -ETIMEDOUT;\r\ngoto out_handle_response;\r\n}\r\n}\r\nif (!wait_for_completion_timeout(\r\n&cmd->wait_for_completion,\r\nmsecs_to_jiffies(150 * 1000))) {\r\npmcraid_reset_bringup(cmd->drv_inst);\r\nrc = -ETIMEDOUT;\r\n}\r\n}\r\nout_handle_response:\r\nif (copy_to_user(ioasa, &cmd->ioa_cb->ioasa,\r\nsizeof(struct pmcraid_ioasa))) {\r\npmcraid_err("failed to copy ioasa buffer to user\n");\r\nrc = -EFAULT;\r\n}\r\nelse if (direction == DMA_FROM_DEVICE && request_size > 0) {\r\nrc = pmcraid_copy_sglist(cmd->sglist,\r\nrequest_buffer,\r\nrequest_size,\r\ndirection);\r\nif (rc) {\r\npmcraid_err("failed to copy user buffer\n");\r\nrc = -EFAULT;\r\n}\r\n}\r\nout_free_sglist:\r\npmcraid_release_passthrough_ioadls(cmd, request_size, direction);\r\npmcraid_return_cmd(cmd);\r\nout_free_buffer:\r\nkfree(buffer);\r\nreturn rc;\r\n}\r\nstatic long pmcraid_ioctl_driver(\r\nstruct pmcraid_instance *pinstance,\r\nunsigned int cmd,\r\nunsigned int buflen,\r\nvoid __user *user_buffer\r\n)\r\n{\r\nint rc = -ENOSYS;\r\nif (!access_ok(VERIFY_READ, user_buffer, _IOC_SIZE(cmd))) {\r\npmcraid_err("ioctl_driver: access fault in request buffer\n");\r\nreturn -EFAULT;\r\n}\r\nswitch (cmd) {\r\ncase PMCRAID_IOCTL_RESET_ADAPTER:\r\npmcraid_reset_bringup(pinstance);\r\nrc = 0;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn rc;\r\n}\r\nstatic int pmcraid_check_ioctl_buffer(\r\nint cmd,\r\nvoid __user *arg,\r\nstruct pmcraid_ioctl_header *hdr\r\n)\r\n{\r\nint rc = 0;\r\nint access = VERIFY_READ;\r\nif (copy_from_user(hdr, arg, sizeof(struct pmcraid_ioctl_header))) {\r\npmcraid_err("couldn't copy ioctl header from user buffer\n");\r\nreturn -EFAULT;\r\n}\r\nrc = memcmp(hdr->signature,\r\nPMCRAID_IOCTL_SIGNATURE,\r\nsizeof(hdr->signature));\r\nif (rc) {\r\npmcraid_err("signature verification failed\n");\r\nreturn -EINVAL;\r\n}\r\nif ((_IOC_DIR(cmd) & _IOC_READ) == _IOC_READ)\r\naccess = VERIFY_WRITE;\r\nrc = access_ok(access,\r\n(arg + sizeof(struct pmcraid_ioctl_header)),\r\nhdr->buffer_length);\r\nif (!rc) {\r\npmcraid_err("access failed for user buffer of size %d\n",\r\nhdr->buffer_length);\r\nreturn -EFAULT;\r\n}\r\nreturn 0;\r\n}\r\nstatic long pmcraid_chr_ioctl(\r\nstruct file *filep,\r\nunsigned int cmd,\r\nunsigned long arg\r\n)\r\n{\r\nstruct pmcraid_instance *pinstance = NULL;\r\nstruct pmcraid_ioctl_header *hdr = NULL;\r\nint retval = -ENOTTY;\r\nhdr = kmalloc(sizeof(struct pmcraid_ioctl_header), GFP_KERNEL);\r\nif (!hdr) {\r\npmcraid_err("failed to allocate memory for ioctl header\n");\r\nreturn -ENOMEM;\r\n}\r\nretval = pmcraid_check_ioctl_buffer(cmd, (void *)arg, hdr);\r\nif (retval) {\r\npmcraid_info("chr_ioctl: header check failed\n");\r\nkfree(hdr);\r\nreturn retval;\r\n}\r\npinstance = filep->private_data;\r\nif (!pinstance) {\r\npmcraid_info("adapter instance is not found\n");\r\nkfree(hdr);\r\nreturn -ENOTTY;\r\n}\r\nswitch (_IOC_TYPE(cmd)) {\r\ncase PMCRAID_PASSTHROUGH_IOCTL:\r\nif (cmd == PMCRAID_IOCTL_DOWNLOAD_MICROCODE)\r\nscsi_block_requests(pinstance->host);\r\nretval = pmcraid_ioctl_passthrough(pinstance,\r\ncmd,\r\nhdr->buffer_length,\r\narg);\r\nif (cmd == PMCRAID_IOCTL_DOWNLOAD_MICROCODE)\r\nscsi_unblock_requests(pinstance->host);\r\nbreak;\r\ncase PMCRAID_DRIVER_IOCTL:\r\narg += sizeof(struct pmcraid_ioctl_header);\r\nretval = pmcraid_ioctl_driver(pinstance,\r\ncmd,\r\nhdr->buffer_length,\r\n(void __user *)arg);\r\nbreak;\r\ndefault:\r\nretval = -ENOTTY;\r\nbreak;\r\n}\r\nkfree(hdr);\r\nreturn retval;\r\n}\r\nstatic ssize_t pmcraid_show_log_level(\r\nstruct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct Scsi_Host *shost = class_to_shost(dev);\r\nstruct pmcraid_instance *pinstance =\r\n(struct pmcraid_instance *)shost->hostdata;\r\nreturn snprintf(buf, PAGE_SIZE, "%d\n", pinstance->current_log_level);\r\n}\r\nstatic ssize_t pmcraid_store_log_level(\r\nstruct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf,\r\nsize_t count\r\n)\r\n{\r\nstruct Scsi_Host *shost;\r\nstruct pmcraid_instance *pinstance;\r\nunsigned long val;\r\nif (strict_strtoul(buf, 10, &val))\r\nreturn -EINVAL;\r\nif (val > 2)\r\nreturn -EINVAL;\r\nshost = class_to_shost(dev);\r\npinstance = (struct pmcraid_instance *)shost->hostdata;\r\npinstance->current_log_level = val;\r\nreturn strlen(buf);\r\n}\r\nstatic ssize_t pmcraid_show_drv_version(\r\nstruct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf\r\n)\r\n{\r\nreturn snprintf(buf, PAGE_SIZE, "version: %s\n",\r\nPMCRAID_DRIVER_VERSION);\r\n}\r\nstatic ssize_t pmcraid_show_adapter_id(\r\nstruct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf\r\n)\r\n{\r\nstruct Scsi_Host *shost = class_to_shost(dev);\r\nstruct pmcraid_instance *pinstance =\r\n(struct pmcraid_instance *)shost->hostdata;\r\nu32 adapter_id = (pinstance->pdev->bus->number << 8) |\r\npinstance->pdev->devfn;\r\nu32 aen_group = pmcraid_event_family.id;\r\nreturn snprintf(buf, PAGE_SIZE,\r\n"adapter id: %d\nminor: %d\naen group: %d\n",\r\nadapter_id, MINOR(pinstance->cdev.dev), aen_group);\r\n}\r\nstatic irqreturn_t pmcraid_isr_msix(int irq, void *dev_id)\r\n{\r\nstruct pmcraid_isr_param *hrrq_vector;\r\nstruct pmcraid_instance *pinstance;\r\nunsigned long lock_flags;\r\nu32 intrs_val;\r\nint hrrq_id;\r\nhrrq_vector = (struct pmcraid_isr_param *)dev_id;\r\nhrrq_id = hrrq_vector->hrrq_id;\r\npinstance = hrrq_vector->drv_inst;\r\nif (!hrrq_id) {\r\nintrs_val = pmcraid_read_interrupts(pinstance);\r\nif (intrs_val &&\r\n((ioread32(pinstance->int_regs.host_ioa_interrupt_reg)\r\n& DOORBELL_INTR_MSIX_CLR) == 0)) {\r\nif (intrs_val & PMCRAID_ERROR_INTERRUPTS) {\r\nif (intrs_val & INTRS_IOA_UNIT_CHECK)\r\npinstance->ioa_unit_check = 1;\r\npmcraid_err("ISR: error interrupts: %x \\r\ninitiating reset\n", intrs_val);\r\nspin_lock_irqsave(pinstance->host->host_lock,\r\nlock_flags);\r\npmcraid_initiate_reset(pinstance);\r\nspin_unlock_irqrestore(\r\npinstance->host->host_lock,\r\nlock_flags);\r\n}\r\nif (intrs_val & INTRS_TRANSITION_TO_OPERATIONAL)\r\npmcraid_clr_trans_op(pinstance);\r\niowrite32(DOORBELL_INTR_MSIX_CLR,\r\npinstance->int_regs.host_ioa_interrupt_reg);\r\nioread32(pinstance->int_regs.host_ioa_interrupt_reg);\r\n}\r\n}\r\ntasklet_schedule(&(pinstance->isr_tasklet[hrrq_id]));\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t pmcraid_isr(int irq, void *dev_id)\r\n{\r\nstruct pmcraid_isr_param *hrrq_vector;\r\nstruct pmcraid_instance *pinstance;\r\nu32 intrs;\r\nunsigned long lock_flags;\r\nint hrrq_id = 0;\r\nif (!dev_id) {\r\nprintk(KERN_INFO "%s(): NULL host pointer\n", __func__);\r\nreturn IRQ_NONE;\r\n}\r\nhrrq_vector = (struct pmcraid_isr_param *)dev_id;\r\npinstance = hrrq_vector->drv_inst;\r\nintrs = pmcraid_read_interrupts(pinstance);\r\nif (unlikely((intrs & PMCRAID_PCI_INTERRUPTS) == 0))\r\nreturn IRQ_NONE;\r\nif (intrs & PMCRAID_ERROR_INTERRUPTS) {\r\nif (intrs & INTRS_IOA_UNIT_CHECK)\r\npinstance->ioa_unit_check = 1;\r\niowrite32(intrs,\r\npinstance->int_regs.ioa_host_interrupt_clr_reg);\r\npmcraid_err("ISR: error interrupts: %x initiating reset\n",\r\nintrs);\r\nintrs = ioread32(\r\npinstance->int_regs.ioa_host_interrupt_clr_reg);\r\nspin_lock_irqsave(pinstance->host->host_lock, lock_flags);\r\npmcraid_initiate_reset(pinstance);\r\nspin_unlock_irqrestore(pinstance->host->host_lock, lock_flags);\r\n} else {\r\nif (intrs & INTRS_TRANSITION_TO_OPERATIONAL) {\r\npmcraid_clr_trans_op(pinstance);\r\n} else {\r\niowrite32(intrs,\r\npinstance->int_regs.ioa_host_interrupt_clr_reg);\r\nioread32(\r\npinstance->int_regs.ioa_host_interrupt_clr_reg);\r\ntasklet_schedule(\r\n&(pinstance->isr_tasklet[hrrq_id]));\r\n}\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void pmcraid_worker_function(struct work_struct *workp)\r\n{\r\nstruct pmcraid_instance *pinstance;\r\nstruct pmcraid_resource_entry *res;\r\nstruct pmcraid_resource_entry *temp;\r\nstruct scsi_device *sdev;\r\nunsigned long lock_flags;\r\nunsigned long host_lock_flags;\r\nu16 fw_version;\r\nu8 bus, target, lun;\r\npinstance = container_of(workp, struct pmcraid_instance, worker_q);\r\nif (!atomic_read(&pinstance->expose_resources))\r\nreturn;\r\nfw_version = be16_to_cpu(pinstance->inq_data->fw_version);\r\nspin_lock_irqsave(&pinstance->resource_lock, lock_flags);\r\nlist_for_each_entry_safe(res, temp, &pinstance->used_res_q, queue) {\r\nif (res->change_detected == RES_CHANGE_DEL && res->scsi_dev) {\r\nsdev = res->scsi_dev;\r\nspin_lock_irqsave(pinstance->host->host_lock,\r\nhost_lock_flags);\r\nif (!scsi_device_get(sdev)) {\r\nspin_unlock_irqrestore(\r\npinstance->host->host_lock,\r\nhost_lock_flags);\r\npmcraid_info("deleting %x from midlayer\n",\r\nres->cfg_entry.resource_address);\r\nlist_move_tail(&res->queue,\r\n&pinstance->free_res_q);\r\nspin_unlock_irqrestore(\r\n&pinstance->resource_lock,\r\nlock_flags);\r\nscsi_remove_device(sdev);\r\nscsi_device_put(sdev);\r\nspin_lock_irqsave(&pinstance->resource_lock,\r\nlock_flags);\r\nres->change_detected = 0;\r\n} else {\r\nspin_unlock_irqrestore(\r\npinstance->host->host_lock,\r\nhost_lock_flags);\r\n}\r\n}\r\n}\r\nlist_for_each_entry(res, &pinstance->used_res_q, queue) {\r\nif (res->change_detected == RES_CHANGE_ADD) {\r\nif (!pmcraid_expose_resource(fw_version,\r\n&res->cfg_entry))\r\ncontinue;\r\nif (RES_IS_VSET(res->cfg_entry)) {\r\nbus = PMCRAID_VSET_BUS_ID;\r\nif (fw_version <= PMCRAID_FW_VERSION_1)\r\ntarget = res->cfg_entry.unique_flags1;\r\nelse\r\ntarget = res->cfg_entry.array_id & 0xFF;\r\nlun = PMCRAID_VSET_LUN_ID;\r\n} else {\r\nbus = PMCRAID_PHYS_BUS_ID;\r\ntarget =\r\nRES_TARGET(\r\nres->cfg_entry.resource_address);\r\nlun = RES_LUN(res->cfg_entry.resource_address);\r\n}\r\nres->change_detected = 0;\r\nspin_unlock_irqrestore(&pinstance->resource_lock,\r\nlock_flags);\r\nscsi_add_device(pinstance->host, bus, target, lun);\r\nspin_lock_irqsave(&pinstance->resource_lock,\r\nlock_flags);\r\n}\r\n}\r\nspin_unlock_irqrestore(&pinstance->resource_lock, lock_flags);\r\n}\r\nstatic void pmcraid_tasklet_function(unsigned long instance)\r\n{\r\nstruct pmcraid_isr_param *hrrq_vector;\r\nstruct pmcraid_instance *pinstance;\r\nunsigned long hrrq_lock_flags;\r\nunsigned long pending_lock_flags;\r\nunsigned long host_lock_flags;\r\nspinlock_t *lockp;\r\nint id;\r\n__le32 resp;\r\nhrrq_vector = (struct pmcraid_isr_param *)instance;\r\npinstance = hrrq_vector->drv_inst;\r\nid = hrrq_vector->hrrq_id;\r\nlockp = &(pinstance->hrrq_lock[id]);\r\nspin_lock_irqsave(lockp, hrrq_lock_flags);\r\nresp = le32_to_cpu(*(pinstance->hrrq_curr[id]));\r\nwhile ((resp & HRRQ_TOGGLE_BIT) ==\r\npinstance->host_toggle_bit[id]) {\r\nint cmd_index = resp >> 2;\r\nstruct pmcraid_cmd *cmd = NULL;\r\nif (pinstance->hrrq_curr[id] < pinstance->hrrq_end[id]) {\r\npinstance->hrrq_curr[id]++;\r\n} else {\r\npinstance->hrrq_curr[id] = pinstance->hrrq_start[id];\r\npinstance->host_toggle_bit[id] ^= 1u;\r\n}\r\nif (cmd_index >= PMCRAID_MAX_CMD) {\r\npmcraid_err("Invalid response handle %d\n", cmd_index);\r\nresp = le32_to_cpu(*(pinstance->hrrq_curr[id]));\r\ncontinue;\r\n}\r\ncmd = pinstance->cmd_list[cmd_index];\r\nspin_unlock_irqrestore(lockp, hrrq_lock_flags);\r\nspin_lock_irqsave(&pinstance->pending_pool_lock,\r\npending_lock_flags);\r\nlist_del(&cmd->free_list);\r\nspin_unlock_irqrestore(&pinstance->pending_pool_lock,\r\npending_lock_flags);\r\ndel_timer(&cmd->timer);\r\natomic_dec(&pinstance->outstanding_cmds);\r\nif (cmd->cmd_done == pmcraid_ioa_reset) {\r\nspin_lock_irqsave(pinstance->host->host_lock,\r\nhost_lock_flags);\r\ncmd->cmd_done(cmd);\r\nspin_unlock_irqrestore(pinstance->host->host_lock,\r\nhost_lock_flags);\r\n} else if (cmd->cmd_done != NULL) {\r\ncmd->cmd_done(cmd);\r\n}\r\nspin_lock_irqsave(lockp, hrrq_lock_flags);\r\nresp = le32_to_cpu(*(pinstance->hrrq_curr[id]));\r\n}\r\nspin_unlock_irqrestore(lockp, hrrq_lock_flags);\r\n}\r\nstatic\r\nvoid pmcraid_unregister_interrupt_handler(struct pmcraid_instance *pinstance)\r\n{\r\nint i;\r\nfor (i = 0; i < pinstance->num_hrrq; i++)\r\nfree_irq(pinstance->hrrq_vector[i].vector,\r\n&(pinstance->hrrq_vector[i]));\r\nif (pinstance->interrupt_mode) {\r\npci_disable_msix(pinstance->pdev);\r\npinstance->interrupt_mode = 0;\r\n}\r\n}\r\nstatic int\r\npmcraid_register_interrupt_handler(struct pmcraid_instance *pinstance)\r\n{\r\nint rc;\r\nstruct pci_dev *pdev = pinstance->pdev;\r\nif ((pmcraid_enable_msix) &&\r\n(pci_find_capability(pdev, PCI_CAP_ID_MSIX))) {\r\nint num_hrrq = PMCRAID_NUM_MSIX_VECTORS;\r\nstruct msix_entry entries[PMCRAID_NUM_MSIX_VECTORS];\r\nint i;\r\nfor (i = 0; i < PMCRAID_NUM_MSIX_VECTORS; i++)\r\nentries[i].entry = i;\r\nrc = pci_enable_msix(pdev, entries, num_hrrq);\r\nif (rc < 0)\r\ngoto pmcraid_isr_legacy;\r\nif (rc > 0) {\r\nnum_hrrq = rc;\r\nif (pci_enable_msix(pdev, entries, num_hrrq))\r\ngoto pmcraid_isr_legacy;\r\n}\r\nfor (i = 0; i < num_hrrq; i++) {\r\npinstance->hrrq_vector[i].hrrq_id = i;\r\npinstance->hrrq_vector[i].drv_inst = pinstance;\r\npinstance->hrrq_vector[i].vector = entries[i].vector;\r\nrc = request_irq(pinstance->hrrq_vector[i].vector,\r\npmcraid_isr_msix, 0,\r\nPMCRAID_DRIVER_NAME,\r\n&(pinstance->hrrq_vector[i]));\r\nif (rc) {\r\nint j;\r\nfor (j = 0; j < i; j++)\r\nfree_irq(entries[j].vector,\r\n&(pinstance->hrrq_vector[j]));\r\npci_disable_msix(pdev);\r\ngoto pmcraid_isr_legacy;\r\n}\r\n}\r\npinstance->num_hrrq = num_hrrq;\r\npinstance->interrupt_mode = 1;\r\niowrite32(DOORBELL_INTR_MODE_MSIX,\r\npinstance->int_regs.host_ioa_interrupt_reg);\r\nioread32(pinstance->int_regs.host_ioa_interrupt_reg);\r\ngoto pmcraid_isr_out;\r\n}\r\npmcraid_isr_legacy:\r\npinstance->hrrq_vector[0].hrrq_id = 0;\r\npinstance->hrrq_vector[0].drv_inst = pinstance;\r\npinstance->hrrq_vector[0].vector = pdev->irq;\r\npinstance->num_hrrq = 1;\r\nrc = 0;\r\nrc = request_irq(pdev->irq, pmcraid_isr, IRQF_SHARED,\r\nPMCRAID_DRIVER_NAME, &pinstance->hrrq_vector[0]);\r\npmcraid_isr_out:\r\nreturn rc;\r\n}\r\nstatic void\r\npmcraid_release_cmd_blocks(struct pmcraid_instance *pinstance, int max_index)\r\n{\r\nint i;\r\nfor (i = 0; i < max_index; i++) {\r\nkmem_cache_free(pinstance->cmd_cachep, pinstance->cmd_list[i]);\r\npinstance->cmd_list[i] = NULL;\r\n}\r\nkmem_cache_destroy(pinstance->cmd_cachep);\r\npinstance->cmd_cachep = NULL;\r\n}\r\nstatic void\r\npmcraid_release_control_blocks(\r\nstruct pmcraid_instance *pinstance,\r\nint max_index\r\n)\r\n{\r\nint i;\r\nif (pinstance->control_pool == NULL)\r\nreturn;\r\nfor (i = 0; i < max_index; i++) {\r\npci_pool_free(pinstance->control_pool,\r\npinstance->cmd_list[i]->ioa_cb,\r\npinstance->cmd_list[i]->ioa_cb_bus_addr);\r\npinstance->cmd_list[i]->ioa_cb = NULL;\r\npinstance->cmd_list[i]->ioa_cb_bus_addr = 0;\r\n}\r\npci_pool_destroy(pinstance->control_pool);\r\npinstance->control_pool = NULL;\r\n}\r\nstatic int pmcraid_allocate_cmd_blocks(struct pmcraid_instance *pinstance)\r\n{\r\nint i;\r\nsprintf(pinstance->cmd_pool_name, "pmcraid_cmd_pool_%d",\r\npinstance->host->unique_id);\r\npinstance->cmd_cachep = kmem_cache_create(\r\npinstance->cmd_pool_name,\r\nsizeof(struct pmcraid_cmd), 0,\r\nSLAB_HWCACHE_ALIGN, NULL);\r\nif (!pinstance->cmd_cachep)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < PMCRAID_MAX_CMD; i++) {\r\npinstance->cmd_list[i] =\r\nkmem_cache_alloc(pinstance->cmd_cachep, GFP_KERNEL);\r\nif (!pinstance->cmd_list[i]) {\r\npmcraid_release_cmd_blocks(pinstance, i);\r\nreturn -ENOMEM;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int pmcraid_allocate_control_blocks(struct pmcraid_instance *pinstance)\r\n{\r\nint i;\r\nsprintf(pinstance->ctl_pool_name, "pmcraid_control_pool_%d",\r\npinstance->host->unique_id);\r\npinstance->control_pool =\r\npci_pool_create(pinstance->ctl_pool_name,\r\npinstance->pdev,\r\nsizeof(struct pmcraid_control_block),\r\nPMCRAID_IOARCB_ALIGNMENT, 0);\r\nif (!pinstance->control_pool)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < PMCRAID_MAX_CMD; i++) {\r\npinstance->cmd_list[i]->ioa_cb =\r\npci_pool_alloc(\r\npinstance->control_pool,\r\nGFP_KERNEL,\r\n&(pinstance->cmd_list[i]->ioa_cb_bus_addr));\r\nif (!pinstance->cmd_list[i]->ioa_cb) {\r\npmcraid_release_control_blocks(pinstance, i);\r\nreturn -ENOMEM;\r\n}\r\nmemset(pinstance->cmd_list[i]->ioa_cb, 0,\r\nsizeof(struct pmcraid_control_block));\r\n}\r\nreturn 0;\r\n}\r\nstatic void\r\npmcraid_release_host_rrqs(struct pmcraid_instance *pinstance, int maxindex)\r\n{\r\nint i;\r\nfor (i = 0; i < maxindex; i++) {\r\npci_free_consistent(pinstance->pdev,\r\nHRRQ_ENTRY_SIZE * PMCRAID_MAX_CMD,\r\npinstance->hrrq_start[i],\r\npinstance->hrrq_start_bus_addr[i]);\r\npinstance->hrrq_start[i] = NULL;\r\npinstance->hrrq_start_bus_addr[i] = 0;\r\npinstance->host_toggle_bit[i] = 0;\r\n}\r\n}\r\nstatic int pmcraid_allocate_host_rrqs(struct pmcraid_instance *pinstance)\r\n{\r\nint i, buffer_size;\r\nbuffer_size = HRRQ_ENTRY_SIZE * PMCRAID_MAX_CMD;\r\nfor (i = 0; i < pinstance->num_hrrq; i++) {\r\npinstance->hrrq_start[i] =\r\npci_alloc_consistent(\r\npinstance->pdev,\r\nbuffer_size,\r\n&(pinstance->hrrq_start_bus_addr[i]));\r\nif (pinstance->hrrq_start[i] == 0) {\r\npmcraid_err("pci_alloc failed for hrrq vector : %d\n",\r\ni);\r\npmcraid_release_host_rrqs(pinstance, i);\r\nreturn -ENOMEM;\r\n}\r\nmemset(pinstance->hrrq_start[i], 0, buffer_size);\r\npinstance->hrrq_curr[i] = pinstance->hrrq_start[i];\r\npinstance->hrrq_end[i] =\r\npinstance->hrrq_start[i] + PMCRAID_MAX_CMD - 1;\r\npinstance->host_toggle_bit[i] = 1;\r\nspin_lock_init(&pinstance->hrrq_lock[i]);\r\n}\r\nreturn 0;\r\n}\r\nstatic void pmcraid_release_hcams(struct pmcraid_instance *pinstance)\r\n{\r\nif (pinstance->ccn.msg != NULL) {\r\npci_free_consistent(pinstance->pdev,\r\nPMCRAID_AEN_HDR_SIZE +\r\nsizeof(struct pmcraid_hcam_ccn_ext),\r\npinstance->ccn.msg,\r\npinstance->ccn.baddr);\r\npinstance->ccn.msg = NULL;\r\npinstance->ccn.hcam = NULL;\r\npinstance->ccn.baddr = 0;\r\n}\r\nif (pinstance->ldn.msg != NULL) {\r\npci_free_consistent(pinstance->pdev,\r\nPMCRAID_AEN_HDR_SIZE +\r\nsizeof(struct pmcraid_hcam_ldn),\r\npinstance->ldn.msg,\r\npinstance->ldn.baddr);\r\npinstance->ldn.msg = NULL;\r\npinstance->ldn.hcam = NULL;\r\npinstance->ldn.baddr = 0;\r\n}\r\n}\r\nstatic int pmcraid_allocate_hcams(struct pmcraid_instance *pinstance)\r\n{\r\npinstance->ccn.msg = pci_alloc_consistent(\r\npinstance->pdev,\r\nPMCRAID_AEN_HDR_SIZE +\r\nsizeof(struct pmcraid_hcam_ccn_ext),\r\n&(pinstance->ccn.baddr));\r\npinstance->ldn.msg = pci_alloc_consistent(\r\npinstance->pdev,\r\nPMCRAID_AEN_HDR_SIZE +\r\nsizeof(struct pmcraid_hcam_ldn),\r\n&(pinstance->ldn.baddr));\r\nif (pinstance->ldn.msg == NULL || pinstance->ccn.msg == NULL) {\r\npmcraid_release_hcams(pinstance);\r\n} else {\r\npinstance->ccn.hcam =\r\n(void *)pinstance->ccn.msg + PMCRAID_AEN_HDR_SIZE;\r\npinstance->ldn.hcam =\r\n(void *)pinstance->ldn.msg + PMCRAID_AEN_HDR_SIZE;\r\natomic_set(&pinstance->ccn.ignore, 0);\r\natomic_set(&pinstance->ldn.ignore, 0);\r\n}\r\nreturn (pinstance->ldn.msg == NULL) ? -ENOMEM : 0;\r\n}\r\nstatic void pmcraid_release_config_buffers(struct pmcraid_instance *pinstance)\r\n{\r\nif (pinstance->cfg_table != NULL &&\r\npinstance->cfg_table_bus_addr != 0) {\r\npci_free_consistent(pinstance->pdev,\r\nsizeof(struct pmcraid_config_table),\r\npinstance->cfg_table,\r\npinstance->cfg_table_bus_addr);\r\npinstance->cfg_table = NULL;\r\npinstance->cfg_table_bus_addr = 0;\r\n}\r\nif (pinstance->res_entries != NULL) {\r\nint i;\r\nfor (i = 0; i < PMCRAID_MAX_RESOURCES; i++)\r\nlist_del(&pinstance->res_entries[i].queue);\r\nkfree(pinstance->res_entries);\r\npinstance->res_entries = NULL;\r\n}\r\npmcraid_release_hcams(pinstance);\r\n}\r\nstatic int pmcraid_allocate_config_buffers(struct pmcraid_instance *pinstance)\r\n{\r\nint i;\r\npinstance->res_entries =\r\nkzalloc(sizeof(struct pmcraid_resource_entry) *\r\nPMCRAID_MAX_RESOURCES, GFP_KERNEL);\r\nif (NULL == pinstance->res_entries) {\r\npmcraid_err("failed to allocate memory for resource table\n");\r\nreturn -ENOMEM;\r\n}\r\nfor (i = 0; i < PMCRAID_MAX_RESOURCES; i++)\r\nlist_add_tail(&pinstance->res_entries[i].queue,\r\n&pinstance->free_res_q);\r\npinstance->cfg_table =\r\npci_alloc_consistent(pinstance->pdev,\r\nsizeof(struct pmcraid_config_table),\r\n&pinstance->cfg_table_bus_addr);\r\nif (NULL == pinstance->cfg_table) {\r\npmcraid_err("couldn't alloc DMA memory for config table\n");\r\npmcraid_release_config_buffers(pinstance);\r\nreturn -ENOMEM;\r\n}\r\nif (pmcraid_allocate_hcams(pinstance)) {\r\npmcraid_err("could not alloc DMA memory for HCAMS\n");\r\npmcraid_release_config_buffers(pinstance);\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}\r\nstatic void pmcraid_init_tasklets(struct pmcraid_instance *pinstance)\r\n{\r\nint i;\r\nfor (i = 0; i < pinstance->num_hrrq; i++)\r\ntasklet_init(&pinstance->isr_tasklet[i],\r\npmcraid_tasklet_function,\r\n(unsigned long)&pinstance->hrrq_vector[i]);\r\n}\r\nstatic void pmcraid_kill_tasklets(struct pmcraid_instance *pinstance)\r\n{\r\nint i;\r\nfor (i = 0; i < pinstance->num_hrrq; i++)\r\ntasklet_kill(&pinstance->isr_tasklet[i]);\r\n}\r\nstatic void pmcraid_release_buffers(struct pmcraid_instance *pinstance)\r\n{\r\npmcraid_release_config_buffers(pinstance);\r\npmcraid_release_control_blocks(pinstance, PMCRAID_MAX_CMD);\r\npmcraid_release_cmd_blocks(pinstance, PMCRAID_MAX_CMD);\r\npmcraid_release_host_rrqs(pinstance, pinstance->num_hrrq);\r\nif (pinstance->inq_data != NULL) {\r\npci_free_consistent(pinstance->pdev,\r\nsizeof(struct pmcraid_inquiry_data),\r\npinstance->inq_data,\r\npinstance->inq_data_baddr);\r\npinstance->inq_data = NULL;\r\npinstance->inq_data_baddr = 0;\r\n}\r\nif (pinstance->timestamp_data != NULL) {\r\npci_free_consistent(pinstance->pdev,\r\nsizeof(struct pmcraid_timestamp_data),\r\npinstance->timestamp_data,\r\npinstance->timestamp_data_baddr);\r\npinstance->timestamp_data = NULL;\r\npinstance->timestamp_data_baddr = 0;\r\n}\r\n}\r\nstatic int pmcraid_init_buffers(struct pmcraid_instance *pinstance)\r\n{\r\nint i;\r\nif (pmcraid_allocate_host_rrqs(pinstance)) {\r\npmcraid_err("couldn't allocate memory for %d host rrqs\n",\r\npinstance->num_hrrq);\r\nreturn -ENOMEM;\r\n}\r\nif (pmcraid_allocate_config_buffers(pinstance)) {\r\npmcraid_err("couldn't allocate memory for config buffers\n");\r\npmcraid_release_host_rrqs(pinstance, pinstance->num_hrrq);\r\nreturn -ENOMEM;\r\n}\r\nif (pmcraid_allocate_cmd_blocks(pinstance)) {\r\npmcraid_err("couldn't allocate memory for cmd blocks\n");\r\npmcraid_release_config_buffers(pinstance);\r\npmcraid_release_host_rrqs(pinstance, pinstance->num_hrrq);\r\nreturn -ENOMEM;\r\n}\r\nif (pmcraid_allocate_control_blocks(pinstance)) {\r\npmcraid_err("couldn't allocate memory control blocks\n");\r\npmcraid_release_config_buffers(pinstance);\r\npmcraid_release_cmd_blocks(pinstance, PMCRAID_MAX_CMD);\r\npmcraid_release_host_rrqs(pinstance, pinstance->num_hrrq);\r\nreturn -ENOMEM;\r\n}\r\npinstance->inq_data = pci_alloc_consistent(\r\npinstance->pdev,\r\nsizeof(struct pmcraid_inquiry_data),\r\n&pinstance->inq_data_baddr);\r\nif (pinstance->inq_data == NULL) {\r\npmcraid_err("couldn't allocate DMA memory for INQUIRY\n");\r\npmcraid_release_buffers(pinstance);\r\nreturn -ENOMEM;\r\n}\r\npinstance->timestamp_data = pci_alloc_consistent(\r\npinstance->pdev,\r\nsizeof(struct pmcraid_timestamp_data),\r\n&pinstance->timestamp_data_baddr);\r\nif (pinstance->timestamp_data == NULL) {\r\npmcraid_err("couldn't allocate DMA memory for \\r\nset time_stamp \n");\r\npmcraid_release_buffers(pinstance);\r\nreturn -ENOMEM;\r\n}\r\nfor (i = 0; i < PMCRAID_MAX_CMD; i++) {\r\nstruct pmcraid_cmd *cmdp = pinstance->cmd_list[i];\r\npmcraid_init_cmdblk(cmdp, i);\r\ncmdp->drv_inst = pinstance;\r\nlist_add_tail(&cmdp->free_list, &pinstance->free_cmd_pool);\r\n}\r\nreturn 0;\r\n}\r\nstatic void pmcraid_reinit_buffers(struct pmcraid_instance *pinstance)\r\n{\r\nint i;\r\nint buffer_size = HRRQ_ENTRY_SIZE * PMCRAID_MAX_CMD;\r\nfor (i = 0; i < pinstance->num_hrrq; i++) {\r\nmemset(pinstance->hrrq_start[i], 0, buffer_size);\r\npinstance->hrrq_curr[i] = pinstance->hrrq_start[i];\r\npinstance->hrrq_end[i] =\r\npinstance->hrrq_start[i] + PMCRAID_MAX_CMD - 1;\r\npinstance->host_toggle_bit[i] = 1;\r\n}\r\n}\r\nstatic int pmcraid_init_instance(struct pci_dev *pdev, struct Scsi_Host *host,\r\nvoid __iomem *mapped_pci_addr)\r\n{\r\nstruct pmcraid_instance *pinstance =\r\n(struct pmcraid_instance *)host->hostdata;\r\npinstance->host = host;\r\npinstance->pdev = pdev;\r\npinstance->mapped_dma_addr = mapped_pci_addr;\r\n{\r\nstruct pmcraid_chip_details *chip_cfg = pinstance->chip_cfg;\r\nstruct pmcraid_interrupts *pint_regs = &pinstance->int_regs;\r\npinstance->ioarrin = mapped_pci_addr + chip_cfg->ioarrin;\r\npint_regs->ioa_host_interrupt_reg =\r\nmapped_pci_addr + chip_cfg->ioa_host_intr;\r\npint_regs->ioa_host_interrupt_clr_reg =\r\nmapped_pci_addr + chip_cfg->ioa_host_intr_clr;\r\npint_regs->ioa_host_msix_interrupt_reg =\r\nmapped_pci_addr + chip_cfg->ioa_host_msix_intr;\r\npint_regs->host_ioa_interrupt_reg =\r\nmapped_pci_addr + chip_cfg->host_ioa_intr;\r\npint_regs->host_ioa_interrupt_clr_reg =\r\nmapped_pci_addr + chip_cfg->host_ioa_intr_clr;\r\npinstance->mailbox = mapped_pci_addr + chip_cfg->mailbox;\r\npinstance->ioa_status = mapped_pci_addr + chip_cfg->ioastatus;\r\npint_regs->ioa_host_interrupt_mask_reg =\r\nmapped_pci_addr + chip_cfg->ioa_host_mask;\r\npint_regs->ioa_host_interrupt_mask_clr_reg =\r\nmapped_pci_addr + chip_cfg->ioa_host_mask_clr;\r\npint_regs->global_interrupt_mask_reg =\r\nmapped_pci_addr + chip_cfg->global_intr_mask;\r\n};\r\npinstance->ioa_reset_attempts = 0;\r\ninit_waitqueue_head(&pinstance->reset_wait_q);\r\natomic_set(&pinstance->outstanding_cmds, 0);\r\natomic_set(&pinstance->last_message_id, 0);\r\natomic_set(&pinstance->expose_resources, 0);\r\nINIT_LIST_HEAD(&pinstance->free_res_q);\r\nINIT_LIST_HEAD(&pinstance->used_res_q);\r\nINIT_LIST_HEAD(&pinstance->free_cmd_pool);\r\nINIT_LIST_HEAD(&pinstance->pending_cmd_pool);\r\nspin_lock_init(&pinstance->free_pool_lock);\r\nspin_lock_init(&pinstance->pending_pool_lock);\r\nspin_lock_init(&pinstance->resource_lock);\r\nmutex_init(&pinstance->aen_queue_lock);\r\nINIT_WORK(&pinstance->worker_q, pmcraid_worker_function);\r\npinstance->current_log_level = pmcraid_log_level;\r\npinstance->ioa_state = IOA_STATE_UNKNOWN;\r\npinstance->reset_cmd = NULL;\r\nreturn 0;\r\n}\r\nstatic void pmcraid_shutdown(struct pci_dev *pdev)\r\n{\r\nstruct pmcraid_instance *pinstance = pci_get_drvdata(pdev);\r\npmcraid_reset_bringdown(pinstance);\r\n}\r\nstatic unsigned short pmcraid_get_minor(void)\r\n{\r\nint minor;\r\nminor = find_first_zero_bit(pmcraid_minor, sizeof(pmcraid_minor));\r\n__set_bit(minor, pmcraid_minor);\r\nreturn minor;\r\n}\r\nstatic void pmcraid_release_minor(unsigned short minor)\r\n{\r\n__clear_bit(minor, pmcraid_minor);\r\n}\r\nstatic int pmcraid_setup_chrdev(struct pmcraid_instance *pinstance)\r\n{\r\nint minor;\r\nint error;\r\nminor = pmcraid_get_minor();\r\ncdev_init(&pinstance->cdev, &pmcraid_fops);\r\npinstance->cdev.owner = THIS_MODULE;\r\nerror = cdev_add(&pinstance->cdev, MKDEV(pmcraid_major, minor), 1);\r\nif (error)\r\npmcraid_release_minor(minor);\r\nelse\r\ndevice_create(pmcraid_class, NULL, MKDEV(pmcraid_major, minor),\r\nNULL, "%s%u", PMCRAID_DEVFILE, minor);\r\nreturn error;\r\n}\r\nstatic void pmcraid_release_chrdev(struct pmcraid_instance *pinstance)\r\n{\r\npmcraid_release_minor(MINOR(pinstance->cdev.dev));\r\ndevice_destroy(pmcraid_class,\r\nMKDEV(pmcraid_major, MINOR(pinstance->cdev.dev)));\r\ncdev_del(&pinstance->cdev);\r\n}\r\nstatic void pmcraid_remove(struct pci_dev *pdev)\r\n{\r\nstruct pmcraid_instance *pinstance = pci_get_drvdata(pdev);\r\npmcraid_release_chrdev(pinstance);\r\nscsi_remove_host(pinstance->host);\r\nscsi_block_requests(pinstance->host);\r\npmcraid_shutdown(pdev);\r\npmcraid_disable_interrupts(pinstance, ~0);\r\nflush_work(&pinstance->worker_q);\r\npmcraid_kill_tasklets(pinstance);\r\npmcraid_unregister_interrupt_handler(pinstance);\r\npmcraid_release_buffers(pinstance);\r\niounmap(pinstance->mapped_dma_addr);\r\npci_release_regions(pdev);\r\nscsi_host_put(pinstance->host);\r\npci_disable_device(pdev);\r\nreturn;\r\n}\r\nstatic int pmcraid_suspend(struct pci_dev *pdev, pm_message_t state)\r\n{\r\nstruct pmcraid_instance *pinstance = pci_get_drvdata(pdev);\r\npmcraid_shutdown(pdev);\r\npmcraid_disable_interrupts(pinstance, ~0);\r\npmcraid_kill_tasklets(pinstance);\r\npci_set_drvdata(pinstance->pdev, pinstance);\r\npmcraid_unregister_interrupt_handler(pinstance);\r\npci_save_state(pdev);\r\npci_disable_device(pdev);\r\npci_set_power_state(pdev, pci_choose_state(pdev, state));\r\nreturn 0;\r\n}\r\nstatic int pmcraid_resume(struct pci_dev *pdev)\r\n{\r\nstruct pmcraid_instance *pinstance = pci_get_drvdata(pdev);\r\nstruct Scsi_Host *host = pinstance->host;\r\nint rc;\r\npci_set_power_state(pdev, PCI_D0);\r\npci_enable_wake(pdev, PCI_D0, 0);\r\npci_restore_state(pdev);\r\nrc = pci_enable_device(pdev);\r\nif (rc) {\r\ndev_err(&pdev->dev, "resume: Enable device failed\n");\r\nreturn rc;\r\n}\r\npci_set_master(pdev);\r\nif ((sizeof(dma_addr_t) == 4) ||\r\npci_set_dma_mask(pdev, DMA_BIT_MASK(64)))\r\nrc = pci_set_dma_mask(pdev, DMA_BIT_MASK(32));\r\nif (rc == 0)\r\nrc = pci_set_consistent_dma_mask(pdev, DMA_BIT_MASK(32));\r\nif (rc != 0) {\r\ndev_err(&pdev->dev, "resume: Failed to set PCI DMA mask\n");\r\ngoto disable_device;\r\n}\r\npmcraid_disable_interrupts(pinstance, ~0);\r\natomic_set(&pinstance->outstanding_cmds, 0);\r\nrc = pmcraid_register_interrupt_handler(pinstance);\r\nif (rc) {\r\ndev_err(&pdev->dev,\r\n"resume: couldn't register interrupt handlers\n");\r\nrc = -ENODEV;\r\ngoto release_host;\r\n}\r\npmcraid_init_tasklets(pinstance);\r\npmcraid_enable_interrupts(pinstance, PMCRAID_PCI_INTERRUPTS);\r\npinstance->ioa_hard_reset = 1;\r\nif (pmcraid_reset_bringup(pinstance)) {\r\ndev_err(&pdev->dev, "couldn't initialize IOA\n");\r\nrc = -ENODEV;\r\ngoto release_tasklets;\r\n}\r\nreturn 0;\r\nrelease_tasklets:\r\npmcraid_disable_interrupts(pinstance, ~0);\r\npmcraid_kill_tasklets(pinstance);\r\npmcraid_unregister_interrupt_handler(pinstance);\r\nrelease_host:\r\nscsi_host_put(host);\r\ndisable_device:\r\npci_disable_device(pdev);\r\nreturn rc;\r\n}\r\nstatic void pmcraid_complete_ioa_reset(struct pmcraid_cmd *cmd)\r\n{\r\nstruct pmcraid_instance *pinstance = cmd->drv_inst;\r\nunsigned long flags;\r\nspin_lock_irqsave(pinstance->host->host_lock, flags);\r\npmcraid_ioa_reset(cmd);\r\nspin_unlock_irqrestore(pinstance->host->host_lock, flags);\r\nscsi_unblock_requests(pinstance->host);\r\nschedule_work(&pinstance->worker_q);\r\n}\r\nstatic void pmcraid_set_supported_devs(struct pmcraid_cmd *cmd)\r\n{\r\nstruct pmcraid_ioarcb *ioarcb = &cmd->ioa_cb->ioarcb;\r\nvoid (*cmd_done) (struct pmcraid_cmd *) = pmcraid_complete_ioa_reset;\r\npmcraid_reinit_cmdblk(cmd);\r\nioarcb->resource_handle = cpu_to_le32(PMCRAID_IOA_RES_HANDLE);\r\nioarcb->request_type = REQ_TYPE_IOACMD;\r\nioarcb->cdb[0] = PMCRAID_SET_SUPPORTED_DEVICES;\r\nioarcb->cdb[1] = ALL_DEVICES_SUPPORTED;\r\nif (cmd->drv_inst->reinit_cfg_table) {\r\ncmd->drv_inst->reinit_cfg_table = 0;\r\ncmd->release = 1;\r\ncmd_done = pmcraid_reinit_cfgtable_done;\r\n}\r\npmcraid_send_cmd(cmd,\r\ncmd_done,\r\nPMCRAID_SET_SUP_DEV_TIMEOUT,\r\npmcraid_timeout_handler);\r\nreturn;\r\n}\r\nstatic void pmcraid_set_timestamp(struct pmcraid_cmd *cmd)\r\n{\r\nstruct pmcraid_instance *pinstance = cmd->drv_inst;\r\nstruct pmcraid_ioarcb *ioarcb = &cmd->ioa_cb->ioarcb;\r\n__be32 time_stamp_len = cpu_to_be32(PMCRAID_TIMESTAMP_LEN);\r\nstruct pmcraid_ioadl_desc *ioadl = ioarcb->add_data.u.ioadl;\r\nstruct timeval tv;\r\n__le64 timestamp;\r\ndo_gettimeofday(&tv);\r\ntimestamp = tv.tv_sec * 1000;\r\npinstance->timestamp_data->timestamp[0] = (__u8)(timestamp);\r\npinstance->timestamp_data->timestamp[1] = (__u8)((timestamp) >> 8);\r\npinstance->timestamp_data->timestamp[2] = (__u8)((timestamp) >> 16);\r\npinstance->timestamp_data->timestamp[3] = (__u8)((timestamp) >> 24);\r\npinstance->timestamp_data->timestamp[4] = (__u8)((timestamp) >> 32);\r\npinstance->timestamp_data->timestamp[5] = (__u8)((timestamp) >> 40);\r\npmcraid_reinit_cmdblk(cmd);\r\nioarcb->request_type = REQ_TYPE_SCSI;\r\nioarcb->resource_handle = cpu_to_le32(PMCRAID_IOA_RES_HANDLE);\r\nioarcb->cdb[0] = PMCRAID_SCSI_SET_TIMESTAMP;\r\nioarcb->cdb[1] = PMCRAID_SCSI_SERVICE_ACTION;\r\nmemcpy(&(ioarcb->cdb[6]), &time_stamp_len, sizeof(time_stamp_len));\r\nioarcb->ioadl_bus_addr = cpu_to_le64((cmd->ioa_cb_bus_addr) +\r\noffsetof(struct pmcraid_ioarcb,\r\nadd_data.u.ioadl[0]));\r\nioarcb->ioadl_length = cpu_to_le32(sizeof(struct pmcraid_ioadl_desc));\r\nioarcb->ioarcb_bus_addr &= ~(0x1FULL);\r\nioarcb->request_flags0 |= NO_LINK_DESCS;\r\nioarcb->request_flags0 |= TRANSFER_DIR_WRITE;\r\nioarcb->data_transfer_length =\r\ncpu_to_le32(sizeof(struct pmcraid_timestamp_data));\r\nioadl = &(ioarcb->add_data.u.ioadl[0]);\r\nioadl->flags = IOADL_FLAGS_LAST_DESC;\r\nioadl->address = cpu_to_le64(pinstance->timestamp_data_baddr);\r\nioadl->data_len = cpu_to_le32(sizeof(struct pmcraid_timestamp_data));\r\nif (!pinstance->timestamp_error) {\r\npinstance->timestamp_error = 0;\r\npmcraid_send_cmd(cmd, pmcraid_set_supported_devs,\r\nPMCRAID_INTERNAL_TIMEOUT, pmcraid_timeout_handler);\r\n} else {\r\npmcraid_send_cmd(cmd, pmcraid_return_cmd,\r\nPMCRAID_INTERNAL_TIMEOUT, pmcraid_timeout_handler);\r\nreturn;\r\n}\r\n}\r\nstatic void pmcraid_init_res_table(struct pmcraid_cmd *cmd)\r\n{\r\nstruct pmcraid_instance *pinstance = cmd->drv_inst;\r\nstruct pmcraid_resource_entry *res, *temp;\r\nstruct pmcraid_config_table_entry *cfgte;\r\nunsigned long lock_flags;\r\nint found, rc, i;\r\nu16 fw_version;\r\nLIST_HEAD(old_res);\r\nif (pinstance->cfg_table->flags & MICROCODE_UPDATE_REQUIRED)\r\npmcraid_err("IOA requires microcode download\n");\r\nfw_version = be16_to_cpu(pinstance->inq_data->fw_version);\r\nspin_lock_irqsave(&pinstance->resource_lock, lock_flags);\r\nlist_for_each_entry_safe(res, temp, &pinstance->used_res_q, queue)\r\nlist_move_tail(&res->queue, &old_res);\r\nfor (i = 0; i < pinstance->cfg_table->num_entries; i++) {\r\nif (be16_to_cpu(pinstance->inq_data->fw_version) <=\r\nPMCRAID_FW_VERSION_1)\r\ncfgte = &pinstance->cfg_table->entries[i];\r\nelse\r\ncfgte = (struct pmcraid_config_table_entry *)\r\n&pinstance->cfg_table->entries_ext[i];\r\nif (!pmcraid_expose_resource(fw_version, cfgte))\r\ncontinue;\r\nfound = 0;\r\nlist_for_each_entry_safe(res, temp, &old_res, queue) {\r\nrc = memcmp(&res->cfg_entry.resource_address,\r\n&cfgte->resource_address,\r\nsizeof(cfgte->resource_address));\r\nif (!rc) {\r\nlist_move_tail(&res->queue,\r\n&pinstance->used_res_q);\r\nfound = 1;\r\nbreak;\r\n}\r\n}\r\nif (!found) {\r\nif (list_empty(&pinstance->free_res_q)) {\r\npmcraid_err("Too many devices attached\n");\r\nbreak;\r\n}\r\nfound = 1;\r\nres = list_entry(pinstance->free_res_q.next,\r\nstruct pmcraid_resource_entry, queue);\r\nres->scsi_dev = NULL;\r\nres->change_detected = RES_CHANGE_ADD;\r\nres->reset_progress = 0;\r\nlist_move_tail(&res->queue, &pinstance->used_res_q);\r\n}\r\nif (found) {\r\nmemcpy(&res->cfg_entry, cfgte,\r\npinstance->config_table_entry_size);\r\npmcraid_info("New res type:%x, vset:%x, addr:%x:\n",\r\nres->cfg_entry.resource_type,\r\n(fw_version <= PMCRAID_FW_VERSION_1 ?\r\nres->cfg_entry.unique_flags1 :\r\nres->cfg_entry.array_id & 0xFF),\r\nle32_to_cpu(res->cfg_entry.resource_address));\r\n}\r\n}\r\nlist_for_each_entry_safe(res, temp, &old_res, queue) {\r\nif (res->scsi_dev) {\r\nres->change_detected = RES_CHANGE_DEL;\r\nres->cfg_entry.resource_handle =\r\nPMCRAID_INVALID_RES_HANDLE;\r\nlist_move_tail(&res->queue, &pinstance->used_res_q);\r\n} else {\r\nlist_move_tail(&res->queue, &pinstance->free_res_q);\r\n}\r\n}\r\nspin_unlock_irqrestore(&pinstance->resource_lock, lock_flags);\r\npmcraid_set_timestamp(cmd);\r\n}\r\nstatic void pmcraid_querycfg(struct pmcraid_cmd *cmd)\r\n{\r\nstruct pmcraid_ioarcb *ioarcb = &cmd->ioa_cb->ioarcb;\r\nstruct pmcraid_ioadl_desc *ioadl = ioarcb->add_data.u.ioadl;\r\nstruct pmcraid_instance *pinstance = cmd->drv_inst;\r\nint cfg_table_size = cpu_to_be32(sizeof(struct pmcraid_config_table));\r\nif (be16_to_cpu(pinstance->inq_data->fw_version) <=\r\nPMCRAID_FW_VERSION_1)\r\npinstance->config_table_entry_size =\r\nsizeof(struct pmcraid_config_table_entry);\r\nelse\r\npinstance->config_table_entry_size =\r\nsizeof(struct pmcraid_config_table_entry_ext);\r\nioarcb->request_type = REQ_TYPE_IOACMD;\r\nioarcb->resource_handle = cpu_to_le32(PMCRAID_IOA_RES_HANDLE);\r\nioarcb->cdb[0] = PMCRAID_QUERY_IOA_CONFIG;\r\nmemcpy(&(ioarcb->cdb[10]), &cfg_table_size, sizeof(cfg_table_size));\r\nioarcb->ioadl_bus_addr = cpu_to_le64((cmd->ioa_cb_bus_addr) +\r\noffsetof(struct pmcraid_ioarcb,\r\nadd_data.u.ioadl[0]));\r\nioarcb->ioadl_length = cpu_to_le32(sizeof(struct pmcraid_ioadl_desc));\r\nioarcb->ioarcb_bus_addr &= ~(0x1FULL);\r\nioarcb->request_flags0 |= NO_LINK_DESCS;\r\nioarcb->data_transfer_length =\r\ncpu_to_le32(sizeof(struct pmcraid_config_table));\r\nioadl = &(ioarcb->add_data.u.ioadl[0]);\r\nioadl->flags = IOADL_FLAGS_LAST_DESC;\r\nioadl->address = cpu_to_le64(pinstance->cfg_table_bus_addr);\r\nioadl->data_len = cpu_to_le32(sizeof(struct pmcraid_config_table));\r\npmcraid_send_cmd(cmd, pmcraid_init_res_table,\r\nPMCRAID_INTERNAL_TIMEOUT, pmcraid_timeout_handler);\r\n}\r\nstatic int pmcraid_probe(struct pci_dev *pdev,\r\nconst struct pci_device_id *dev_id)\r\n{\r\nstruct pmcraid_instance *pinstance;\r\nstruct Scsi_Host *host;\r\nvoid __iomem *mapped_pci_addr;\r\nint rc = PCIBIOS_SUCCESSFUL;\r\nif (atomic_read(&pmcraid_adapter_count) >= PMCRAID_MAX_ADAPTERS) {\r\npmcraid_err\r\n("maximum number(%d) of supported adapters reached\n",\r\natomic_read(&pmcraid_adapter_count));\r\nreturn -ENOMEM;\r\n}\r\natomic_inc(&pmcraid_adapter_count);\r\nrc = pci_enable_device(pdev);\r\nif (rc) {\r\ndev_err(&pdev->dev, "Cannot enable adapter\n");\r\natomic_dec(&pmcraid_adapter_count);\r\nreturn rc;\r\n}\r\ndev_info(&pdev->dev,\r\n"Found new IOA(%x:%x), Total IOA count: %d\n",\r\npdev->vendor, pdev->device,\r\natomic_read(&pmcraid_adapter_count));\r\nrc = pci_request_regions(pdev, PMCRAID_DRIVER_NAME);\r\nif (rc < 0) {\r\ndev_err(&pdev->dev,\r\n"Couldn't register memory range of registers\n");\r\ngoto out_disable_device;\r\n}\r\nmapped_pci_addr = pci_iomap(pdev, 0, 0);\r\nif (!mapped_pci_addr) {\r\ndev_err(&pdev->dev, "Couldn't map PCI registers memory\n");\r\nrc = -ENOMEM;\r\ngoto out_release_regions;\r\n}\r\npci_set_master(pdev);\r\nif ((sizeof(dma_addr_t) == 4) ||\r\npci_set_dma_mask(pdev, DMA_BIT_MASK(64)))\r\nrc = pci_set_dma_mask(pdev, DMA_BIT_MASK(32));\r\nif (rc == 0)\r\nrc = pci_set_consistent_dma_mask(pdev, DMA_BIT_MASK(32));\r\nif (rc != 0) {\r\ndev_err(&pdev->dev, "Failed to set PCI DMA mask\n");\r\ngoto cleanup_nomem;\r\n}\r\nhost = scsi_host_alloc(&pmcraid_host_template,\r\nsizeof(struct pmcraid_instance));\r\nif (!host) {\r\ndev_err(&pdev->dev, "scsi_host_alloc failed!\n");\r\nrc = -ENOMEM;\r\ngoto cleanup_nomem;\r\n}\r\nhost->max_id = PMCRAID_MAX_NUM_TARGETS_PER_BUS;\r\nhost->max_lun = PMCRAID_MAX_NUM_LUNS_PER_TARGET;\r\nhost->unique_id = host->host_no;\r\nhost->max_channel = PMCRAID_MAX_BUS_TO_SCAN;\r\nhost->max_cmd_len = PMCRAID_MAX_CDB_LEN;\r\npinstance = (struct pmcraid_instance *)host->hostdata;\r\nmemset(pinstance, 0, sizeof(*pinstance));\r\npinstance->chip_cfg =\r\n(struct pmcraid_chip_details *)(dev_id->driver_data);\r\nrc = pmcraid_init_instance(pdev, host, mapped_pci_addr);\r\nif (rc < 0) {\r\ndev_err(&pdev->dev, "failed to initialize adapter instance\n");\r\ngoto out_scsi_host_put;\r\n}\r\npci_set_drvdata(pdev, pinstance);\r\nrc = pci_save_state(pinstance->pdev);\r\nif (rc != 0) {\r\ndev_err(&pdev->dev, "Failed to save PCI config space\n");\r\ngoto out_scsi_host_put;\r\n}\r\npmcraid_disable_interrupts(pinstance, ~0);\r\nrc = pmcraid_register_interrupt_handler(pinstance);\r\nif (rc) {\r\ndev_err(&pdev->dev, "couldn't register interrupt handler\n");\r\ngoto out_scsi_host_put;\r\n}\r\npmcraid_init_tasklets(pinstance);\r\nrc = pmcraid_init_buffers(pinstance);\r\nif (rc) {\r\npmcraid_err("couldn't allocate memory blocks\n");\r\ngoto out_unregister_isr;\r\n}\r\npmcraid_reset_type(pinstance);\r\npmcraid_enable_interrupts(pinstance, PMCRAID_PCI_INTERRUPTS);\r\npmcraid_info("starting IOA initialization sequence\n");\r\nif (pmcraid_reset_bringup(pinstance)) {\r\ndev_err(&pdev->dev, "couldn't initialize IOA\n");\r\nrc = 1;\r\ngoto out_release_bufs;\r\n}\r\nrc = scsi_add_host(pinstance->host, &pdev->dev);\r\nif (rc != 0) {\r\npmcraid_err("couldn't add host into mid-layer: %d\n", rc);\r\ngoto out_release_bufs;\r\n}\r\nscsi_scan_host(pinstance->host);\r\nrc = pmcraid_setup_chrdev(pinstance);\r\nif (rc != 0) {\r\npmcraid_err("couldn't create mgmt interface, error: %x\n",\r\nrc);\r\ngoto out_remove_host;\r\n}\r\natomic_set(&pinstance->expose_resources, 1);\r\nschedule_work(&pinstance->worker_q);\r\nreturn rc;\r\nout_remove_host:\r\nscsi_remove_host(host);\r\nout_release_bufs:\r\npmcraid_release_buffers(pinstance);\r\nout_unregister_isr:\r\npmcraid_kill_tasklets(pinstance);\r\npmcraid_unregister_interrupt_handler(pinstance);\r\nout_scsi_host_put:\r\nscsi_host_put(host);\r\ncleanup_nomem:\r\niounmap(mapped_pci_addr);\r\nout_release_regions:\r\npci_release_regions(pdev);\r\nout_disable_device:\r\natomic_dec(&pmcraid_adapter_count);\r\npci_set_drvdata(pdev, NULL);\r\npci_disable_device(pdev);\r\nreturn -ENODEV;\r\n}\r\nstatic int __init pmcraid_init(void)\r\n{\r\ndev_t dev;\r\nint error;\r\npmcraid_info("%s Device Driver version: %s\n",\r\nPMCRAID_DRIVER_NAME, PMCRAID_DRIVER_VERSION);\r\nerror = alloc_chrdev_region(&dev, 0,\r\nPMCRAID_MAX_ADAPTERS,\r\nPMCRAID_DEVFILE);\r\nif (error) {\r\npmcraid_err("failed to get a major number for adapters\n");\r\ngoto out_init;\r\n}\r\npmcraid_major = MAJOR(dev);\r\npmcraid_class = class_create(THIS_MODULE, PMCRAID_DEVFILE);\r\nif (IS_ERR(pmcraid_class)) {\r\nerror = PTR_ERR(pmcraid_class);\r\npmcraid_err("failed to register with with sysfs, error = %x\n",\r\nerror);\r\ngoto out_unreg_chrdev;\r\n}\r\nerror = pmcraid_netlink_init();\r\nif (error)\r\ngoto out_unreg_chrdev;\r\nerror = pci_register_driver(&pmcraid_driver);\r\nif (error == 0)\r\ngoto out_init;\r\npmcraid_err("failed to register pmcraid driver, error = %x\n",\r\nerror);\r\nclass_destroy(pmcraid_class);\r\npmcraid_netlink_release();\r\nout_unreg_chrdev:\r\nunregister_chrdev_region(MKDEV(pmcraid_major, 0), PMCRAID_MAX_ADAPTERS);\r\nout_init:\r\nreturn error;\r\n}\r\nstatic void __exit pmcraid_exit(void)\r\n{\r\npmcraid_netlink_release();\r\nunregister_chrdev_region(MKDEV(pmcraid_major, 0),\r\nPMCRAID_MAX_ADAPTERS);\r\npci_unregister_driver(&pmcraid_driver);\r\nclass_destroy(pmcraid_class);\r\n}
