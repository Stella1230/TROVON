static int xgmac_wait_until_free(struct device *dev,\r\nstruct tgec_mdio_controller __iomem *regs)\r\n{\r\nuint32_t status;\r\nstatus = spin_event_timeout(\r\n!((in_be32(&regs->mdio_stat)) & MDIO_STAT_BSY), TIMEOUT, 0);\r\nif (!status) {\r\ndev_err(dev, "timeout waiting for bus to be free\n");\r\nreturn -ETIMEDOUT;\r\n}\r\nreturn 0;\r\n}\r\nstatic int xgmac_wait_until_done(struct device *dev,\r\nstruct tgec_mdio_controller __iomem *regs)\r\n{\r\nuint32_t status;\r\nstatus = spin_event_timeout(\r\n!((in_be32(&regs->mdio_data)) & MDIO_DATA_BSY), TIMEOUT, 0);\r\nif (!status) {\r\ndev_err(dev, "timeout waiting for operation to complete\n");\r\nreturn -ETIMEDOUT;\r\n}\r\nreturn 0;\r\n}\r\nstatic int xgmac_mdio_write(struct mii_bus *bus, int phy_id, int regnum, u16 value)\r\n{\r\nstruct tgec_mdio_controller __iomem *regs = bus->priv;\r\nuint16_t dev_addr = regnum >> 16;\r\nint ret;\r\nout_be32(&regs->mdio_stat, MDIO_STAT_CLKDIV(100));\r\nret = xgmac_wait_until_free(&bus->dev, regs);\r\nif (ret)\r\nreturn ret;\r\nout_be32(&regs->mdio_ctl,\r\nMDIO_CTL_PORT_ADDR(phy_id) | MDIO_CTL_DEV_ADDR(dev_addr));\r\nout_be32(&regs->mdio_addr, regnum & 0xffff);\r\nret = xgmac_wait_until_free(&bus->dev, regs);\r\nif (ret)\r\nreturn ret;\r\nout_be32(&regs->mdio_data, MDIO_DATA(value));\r\nret = xgmac_wait_until_done(&bus->dev, regs);\r\nif (ret)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nstatic int xgmac_mdio_read(struct mii_bus *bus, int phy_id, int regnum)\r\n{\r\nstruct tgec_mdio_controller __iomem *regs = bus->priv;\r\nuint16_t dev_addr = regnum >> 16;\r\nuint32_t mdio_ctl;\r\nuint16_t value;\r\nint ret;\r\nout_be32(&regs->mdio_stat, MDIO_STAT_CLKDIV(100));\r\nret = xgmac_wait_until_free(&bus->dev, regs);\r\nif (ret)\r\nreturn ret;\r\nmdio_ctl = MDIO_CTL_PORT_ADDR(phy_id) | MDIO_CTL_DEV_ADDR(dev_addr);\r\nout_be32(&regs->mdio_ctl, mdio_ctl);\r\nout_be32(&regs->mdio_addr, regnum & 0xffff);\r\nret = xgmac_wait_until_free(&bus->dev, regs);\r\nif (ret)\r\nreturn ret;\r\nout_be32(&regs->mdio_ctl, mdio_ctl | MDIO_CTL_READ);\r\nret = xgmac_wait_until_done(&bus->dev, regs);\r\nif (ret)\r\nreturn ret;\r\nif (in_be32(&regs->mdio_stat) & MDIO_STAT_RD_ER) {\r\ndev_err(&bus->dev, "MDIO read error\n");\r\nreturn 0xffff;\r\n}\r\nvalue = in_be32(&regs->mdio_data) & 0xffff;\r\ndev_dbg(&bus->dev, "read %04x\n", value);\r\nreturn value;\r\n}\r\nstatic int xgmac_mdio_reset(struct mii_bus *bus)\r\n{\r\nstruct tgec_mdio_controller __iomem *regs = bus->priv;\r\nint ret;\r\nmutex_lock(&bus->mdio_lock);\r\nout_be32(&regs->mdio_stat, MDIO_STAT_CLKDIV(100));\r\nret = xgmac_wait_until_free(&bus->dev, regs);\r\nmutex_unlock(&bus->mdio_lock);\r\nreturn ret;\r\n}\r\nstatic int xgmac_mdio_probe(struct platform_device *pdev)\r\n{\r\nstruct device_node *np = pdev->dev.of_node;\r\nstruct mii_bus *bus;\r\nstruct resource res;\r\nint ret;\r\nret = of_address_to_resource(np, 0, &res);\r\nif (ret) {\r\ndev_err(&pdev->dev, "could not obtain address\n");\r\nreturn ret;\r\n}\r\nbus = mdiobus_alloc_size(PHY_MAX_ADDR * sizeof(int));\r\nif (!bus)\r\nreturn -ENOMEM;\r\nbus->name = "Freescale XGMAC MDIO Bus";\r\nbus->read = xgmac_mdio_read;\r\nbus->write = xgmac_mdio_write;\r\nbus->reset = xgmac_mdio_reset;\r\nbus->irq = bus->priv;\r\nbus->parent = &pdev->dev;\r\nsnprintf(bus->id, MII_BUS_ID_SIZE, "%llx", (unsigned long long)res.start);\r\nbus->priv = of_iomap(np, 0);\r\nif (!bus->priv) {\r\nret = -ENOMEM;\r\ngoto err_ioremap;\r\n}\r\nret = of_mdiobus_register(bus, np);\r\nif (ret) {\r\ndev_err(&pdev->dev, "cannot register MDIO bus\n");\r\ngoto err_registration;\r\n}\r\ndev_set_drvdata(&pdev->dev, bus);\r\nreturn 0;\r\nerr_registration:\r\niounmap(bus->priv);\r\nerr_ioremap:\r\nmdiobus_free(bus);\r\nreturn ret;\r\n}\r\nstatic int xgmac_mdio_remove(struct platform_device *pdev)\r\n{\r\nstruct mii_bus *bus = dev_get_drvdata(&pdev->dev);\r\nmdiobus_unregister(bus);\r\niounmap(bus->priv);\r\nmdiobus_free(bus);\r\nreturn 0;\r\n}
