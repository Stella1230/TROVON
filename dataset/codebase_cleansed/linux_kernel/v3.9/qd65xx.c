static void qd65xx_dev_select(ide_drive_t *drive)\r\n{\r\nu8 index = (( (QD_TIMREG(drive)) & 0x80 ) >> 7) |\r\n(QD_TIMREG(drive) & 0x02);\r\nif (timings[index] != QD_TIMING(drive))\r\noutb(timings[index] = QD_TIMING(drive), QD_TIMREG(drive));\r\noutb(drive->select | ATA_DEVICE_OBS, drive->hwif->io_ports.device_addr);\r\n}\r\nstatic u8 qd6500_compute_timing (ide_hwif_t *hwif, int active_time, int recovery_time)\r\n{\r\nint clk = ide_vlb_clk ? ide_vlb_clk : 50;\r\nu8 act_cyc, rec_cyc;\r\nif (clk <= 33) {\r\nact_cyc = 9 - IDE_IN(active_time * clk / 1000 + 1, 2, 9);\r\nrec_cyc = 15 - IDE_IN(recovery_time * clk / 1000 + 1, 0, 15);\r\n} else {\r\nact_cyc = 8 - IDE_IN(active_time * clk / 1000 + 1, 1, 8);\r\nrec_cyc = 18 - IDE_IN(recovery_time * clk / 1000 + 1, 3, 18);\r\n}\r\nreturn (rec_cyc << 4) | 0x08 | act_cyc;\r\n}\r\nstatic u8 qd6580_compute_timing (int active_time, int recovery_time)\r\n{\r\nint clk = ide_vlb_clk ? ide_vlb_clk : 50;\r\nu8 act_cyc, rec_cyc;\r\nact_cyc = 17 - IDE_IN(active_time * clk / 1000 + 1, 2, 17);\r\nrec_cyc = 15 - IDE_IN(recovery_time * clk / 1000 + 1, 2, 15);\r\nreturn (rec_cyc << 4) | act_cyc;\r\n}\r\nstatic int qd_find_disk_type (ide_drive_t *drive,\r\nint *active_time, int *recovery_time)\r\n{\r\nstruct qd65xx_timing_s *p;\r\nchar *m = (char *)&drive->id[ATA_ID_PROD];\r\nchar model[ATA_ID_PROD_LEN];\r\nif (*m == 0)\r\nreturn 0;\r\nstrncpy(model, m, ATA_ID_PROD_LEN);\r\nide_fixstring(model, ATA_ID_PROD_LEN, 1);\r\nfor (p = qd65xx_timing ; p->offset != -1 ; p++) {\r\nif (!strncmp(p->model, model+p->offset, 4)) {\r\nprintk(KERN_DEBUG "%s: listed !\n", drive->name);\r\n*active_time = p->active;\r\n*recovery_time = p->recovery;\r\nreturn 1;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void qd_set_timing (ide_drive_t *drive, u8 timing)\r\n{\r\nunsigned long data = (unsigned long)ide_get_drivedata(drive);\r\ndata &= 0xff00;\r\ndata |= timing;\r\nide_set_drivedata(drive, (void *)data);\r\nprintk(KERN_DEBUG "%s: %#x\n", drive->name, timing);\r\n}\r\nstatic void qd6500_set_pio_mode(ide_hwif_t *hwif, ide_drive_t *drive)\r\n{\r\nu16 *id = drive->id;\r\nint active_time = 175;\r\nint recovery_time = 415;\r\nif (!qd_find_disk_type(drive, &active_time, &recovery_time) &&\r\n(id[ATA_ID_OLD_PIO_MODES] & 0xff) && (id[ATA_ID_FIELD_VALID] & 2) &&\r\nid[ATA_ID_EIDE_PIO] >= 240) {\r\nprintk(KERN_INFO "%s: PIO mode%d\n", drive->name,\r\nid[ATA_ID_OLD_PIO_MODES] & 0xff);\r\nactive_time = 110;\r\nrecovery_time = drive->id[ATA_ID_EIDE_PIO] - 120;\r\n}\r\nqd_set_timing(drive, qd6500_compute_timing(drive->hwif,\r\nactive_time, recovery_time));\r\n}\r\nstatic void qd6580_set_pio_mode(ide_hwif_t *hwif, ide_drive_t *drive)\r\n{\r\nconst u8 pio = drive->pio_mode - XFER_PIO_0;\r\nstruct ide_timing *t = ide_timing_find_mode(XFER_PIO_0 + pio);\r\nunsigned int cycle_time;\r\nint active_time = 175;\r\nint recovery_time = 415;\r\nu8 base = (hwif->config_data & 0xff00) >> 8;\r\nif (drive->id && !qd_find_disk_type(drive, &active_time, &recovery_time)) {\r\ncycle_time = ide_pio_cycle_time(drive, pio);\r\nswitch (pio) {\r\ncase 0: break;\r\ncase 3:\r\nif (cycle_time >= 110) {\r\nactive_time = 86;\r\nrecovery_time = cycle_time - 102;\r\n} else\r\nprintk(KERN_WARNING "%s: Strange recovery time !\n",drive->name);\r\nbreak;\r\ncase 4:\r\nif (cycle_time >= 69) {\r\nactive_time = 70;\r\nrecovery_time = cycle_time - 61;\r\n} else\r\nprintk(KERN_WARNING "%s: Strange recovery time !\n",drive->name);\r\nbreak;\r\ndefault:\r\nif (cycle_time >= 180) {\r\nactive_time = 110;\r\nrecovery_time = cycle_time - 120;\r\n} else {\r\nactive_time = t->active;\r\nrecovery_time = cycle_time - active_time;\r\n}\r\n}\r\nprintk(KERN_INFO "%s: PIO mode%d\n", drive->name,pio);\r\n}\r\nif (!hwif->channel && drive->media != ide_disk) {\r\noutb(0x5f, QD_CONTROL_PORT);\r\nprintk(KERN_WARNING "%s: ATAPI: disabled read-ahead FIFO "\r\n"and post-write buffer on %s.\n",\r\ndrive->name, hwif->name);\r\n}\r\nqd_set_timing(drive, qd6580_compute_timing(active_time, recovery_time));\r\n}\r\nstatic int __init qd_testreg(int port)\r\n{\r\nunsigned long flags;\r\nu8 savereg, readreg;\r\nlocal_irq_save(flags);\r\nsavereg = inb_p(port);\r\noutb_p(QD_TESTVAL, port);\r\nreadreg = inb_p(port);\r\noutb(savereg, port);\r\nlocal_irq_restore(flags);\r\nif (savereg == QD_TESTVAL) {\r\nprintk(KERN_ERR "Outch ! the probe for qd65xx isn't reliable !\n");\r\nprintk(KERN_ERR "Please contact maintainers to tell about your hardware\n");\r\nprintk(KERN_ERR "Assuming qd65xx is not present.\n");\r\nreturn 1;\r\n}\r\nreturn (readreg != QD_TESTVAL);\r\n}\r\nstatic void __init qd6500_init_dev(ide_drive_t *drive)\r\n{\r\nide_hwif_t *hwif = drive->hwif;\r\nu8 base = (hwif->config_data & 0xff00) >> 8;\r\nu8 config = QD_CONFIG(hwif);\r\nide_set_drivedata(drive, (void *)QD6500_DEF_DATA);\r\n}\r\nstatic void __init qd6580_init_dev(ide_drive_t *drive)\r\n{\r\nide_hwif_t *hwif = drive->hwif;\r\nu16 t1, t2;\r\nu8 base = (hwif->config_data & 0xff00) >> 8;\r\nu8 config = QD_CONFIG(hwif);\r\nif (hwif->host_flags & IDE_HFLAG_SINGLE) {\r\nt1 = QD6580_DEF_DATA;\r\nt2 = QD6580_DEF_DATA2;\r\n} else\r\nt2 = t1 = hwif->channel ? QD6580_DEF_DATA2 : QD6580_DEF_DATA;\r\nide_set_drivedata(drive, (void *)((drive->dn & 1) ? t2 : t1));\r\n}\r\nstatic int __init qd_probe(int base)\r\n{\r\nint rc;\r\nu8 config, unit, control;\r\nstruct ide_port_info d = qd65xx_port_info;\r\nconfig = inb(QD_CONFIG_PORT);\r\nif (! ((config & QD_CONFIG_BASEPORT) >> 1 == (base == 0xb0)) )\r\nreturn -ENODEV;\r\nunit = ! (config & QD_CONFIG_IDE_BASEPORT);\r\nif (unit)\r\nd.host_flags |= IDE_HFLAG_QD_2ND_PORT;\r\nswitch (config & 0xf0) {\r\ncase QD_CONFIG_QD6500:\r\nif (qd_testreg(base))\r\nreturn -ENODEV;\r\nif (config & QD_CONFIG_DISABLED) {\r\nprintk(KERN_WARNING "qd6500 is disabled !\n");\r\nreturn -ENODEV;\r\n}\r\nprintk(KERN_NOTICE "qd6500 at %#x\n", base);\r\nprintk(KERN_DEBUG "qd6500: config=%#x, ID3=%u\n",\r\nconfig, QD_ID3);\r\nd.port_ops = &qd6500_port_ops;\r\nd.host_flags |= IDE_HFLAG_SINGLE;\r\nbreak;\r\ncase QD_CONFIG_QD6580_A:\r\ncase QD_CONFIG_QD6580_B:\r\nif (qd_testreg(base) || qd_testreg(base + 0x02))\r\nreturn -ENODEV;\r\ncontrol = inb(QD_CONTROL_PORT);\r\nprintk(KERN_NOTICE "qd6580 at %#x\n", base);\r\nprintk(KERN_DEBUG "qd6580: config=%#x, control=%#x, ID3=%u\n",\r\nconfig, control, QD_ID3);\r\noutb(QD_DEF_CONTR, QD_CONTROL_PORT);\r\nd.port_ops = &qd6580_port_ops;\r\nif (control & QD_CONTR_SEC_DISABLED)\r\nd.host_flags |= IDE_HFLAG_SINGLE;\r\nprintk(KERN_INFO "qd6580: %s IDE board\n",\r\n(control & QD_CONTR_SEC_DISABLED) ? "single" : "dual");\r\nbreak;\r\ndefault:\r\nreturn -ENODEV;\r\n}\r\nrc = ide_legacy_device_add(&d, (base << 8) | config);\r\nif (d.host_flags & IDE_HFLAG_SINGLE)\r\nreturn (rc == 0) ? 1 : rc;\r\nreturn rc;\r\n}\r\nstatic int __init qd65xx_init(void)\r\n{\r\nint rc1, rc2 = -ENODEV;\r\nif (probe_qd65xx == 0)\r\nreturn -ENODEV;\r\nrc1 = qd_probe(0x30);\r\nif (rc1)\r\nrc2 = qd_probe(0xb0);\r\nif (rc1 < 0 && rc2 < 0)\r\nreturn -ENODEV;\r\nreturn 0;\r\n}
