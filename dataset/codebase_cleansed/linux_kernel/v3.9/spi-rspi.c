static void rspi_write8(struct rspi_data *rspi, u8 data, u16 offset)\r\n{\r\niowrite8(data, rspi->addr + offset);\r\n}\r\nstatic void rspi_write16(struct rspi_data *rspi, u16 data, u16 offset)\r\n{\r\niowrite16(data, rspi->addr + offset);\r\n}\r\nstatic u8 rspi_read8(struct rspi_data *rspi, u16 offset)\r\n{\r\nreturn ioread8(rspi->addr + offset);\r\n}\r\nstatic u16 rspi_read16(struct rspi_data *rspi, u16 offset)\r\n{\r\nreturn ioread16(rspi->addr + offset);\r\n}\r\nstatic unsigned char rspi_calc_spbr(struct rspi_data *rspi)\r\n{\r\nint tmp;\r\nunsigned char spbr;\r\ntmp = clk_get_rate(rspi->clk) / (2 * rspi->max_speed_hz) - 1;\r\nspbr = clamp(tmp, 0, 255);\r\nreturn spbr;\r\n}\r\nstatic void rspi_enable_irq(struct rspi_data *rspi, u8 enable)\r\n{\r\nrspi_write8(rspi, rspi_read8(rspi, RSPI_SPCR) | enable, RSPI_SPCR);\r\n}\r\nstatic void rspi_disable_irq(struct rspi_data *rspi, u8 disable)\r\n{\r\nrspi_write8(rspi, rspi_read8(rspi, RSPI_SPCR) & ~disable, RSPI_SPCR);\r\n}\r\nstatic int rspi_wait_for_interrupt(struct rspi_data *rspi, u8 wait_mask,\r\nu8 enable_bit)\r\n{\r\nint ret;\r\nrspi->spsr = rspi_read8(rspi, RSPI_SPSR);\r\nrspi_enable_irq(rspi, enable_bit);\r\nret = wait_event_timeout(rspi->wait, rspi->spsr & wait_mask, HZ);\r\nif (ret == 0 && !(rspi->spsr & wait_mask))\r\nreturn -ETIMEDOUT;\r\nreturn 0;\r\n}\r\nstatic void rspi_assert_ssl(struct rspi_data *rspi)\r\n{\r\nrspi_write8(rspi, rspi_read8(rspi, RSPI_SPCR) | SPCR_SPE, RSPI_SPCR);\r\n}\r\nstatic void rspi_negate_ssl(struct rspi_data *rspi)\r\n{\r\nrspi_write8(rspi, rspi_read8(rspi, RSPI_SPCR) & ~SPCR_SPE, RSPI_SPCR);\r\n}\r\nstatic int rspi_set_config_register(struct rspi_data *rspi, int access_size)\r\n{\r\nrspi_write8(rspi, 0x00, RSPI_SPPCR);\r\nrspi_write8(rspi, rspi_calc_spbr(rspi), RSPI_SPBR);\r\nrspi_write8(rspi, 0x00, RSPI_SPDCR);\r\nrspi_write8(rspi, 0x00, RSPI_SPCKD);\r\nrspi_write8(rspi, 0x00, RSPI_SSLND);\r\nrspi_write8(rspi, 0x00, RSPI_SPND);\r\nrspi_write8(rspi, 0x00, RSPI_SPCR2);\r\nrspi_write16(rspi, SPCMD_SPB_8_TO_16(access_size) | SPCMD_SSLKP,\r\nRSPI_SPCMD0);\r\nrspi_write8(rspi, SPCR_MSTR, RSPI_SPCR);\r\nreturn 0;\r\n}\r\nstatic int rspi_send_pio(struct rspi_data *rspi, struct spi_message *mesg,\r\nstruct spi_transfer *t)\r\n{\r\nint remain = t->len;\r\nu8 *data;\r\ndata = (u8 *)t->tx_buf;\r\nwhile (remain > 0) {\r\nrspi_write8(rspi, rspi_read8(rspi, RSPI_SPCR) | SPCR_TXMD,\r\nRSPI_SPCR);\r\nif (rspi_wait_for_interrupt(rspi, SPSR_SPTEF, SPCR_SPTIE) < 0) {\r\ndev_err(&rspi->master->dev,\r\n"%s: tx empty timeout\n", __func__);\r\nreturn -ETIMEDOUT;\r\n}\r\nrspi_write16(rspi, *data, RSPI_SPDR);\r\ndata++;\r\nremain--;\r\n}\r\nrspi_wait_for_interrupt(rspi, SPSR_SPTEF, SPCR_SPTIE);\r\nreturn 0;\r\n}\r\nstatic void rspi_dma_complete(void *arg)\r\n{\r\nstruct rspi_data *rspi = arg;\r\nrspi->dma_callbacked = 1;\r\nwake_up_interruptible(&rspi->wait);\r\n}\r\nstatic int rspi_dma_map_sg(struct scatterlist *sg, void *buf, unsigned len,\r\nstruct dma_chan *chan,\r\nenum dma_transfer_direction dir)\r\n{\r\nsg_init_table(sg, 1);\r\nsg_set_buf(sg, buf, len);\r\nsg_dma_len(sg) = len;\r\nreturn dma_map_sg(chan->device->dev, sg, 1, dir);\r\n}\r\nstatic void rspi_dma_unmap_sg(struct scatterlist *sg, struct dma_chan *chan,\r\nenum dma_transfer_direction dir)\r\n{\r\ndma_unmap_sg(chan->device->dev, sg, 1, dir);\r\n}\r\nstatic void rspi_memory_to_8bit(void *buf, const void *data, unsigned len)\r\n{\r\nu16 *dst = buf;\r\nconst u8 *src = data;\r\nwhile (len) {\r\n*dst++ = (u16)(*src++);\r\nlen--;\r\n}\r\n}\r\nstatic void rspi_memory_from_8bit(void *buf, const void *data, unsigned len)\r\n{\r\nu8 *dst = buf;\r\nconst u16 *src = data;\r\nwhile (len) {\r\n*dst++ = (u8)*src++;\r\nlen--;\r\n}\r\n}\r\nstatic int rspi_send_dma(struct rspi_data *rspi, struct spi_transfer *t)\r\n{\r\nstruct scatterlist sg;\r\nvoid *buf = NULL;\r\nstruct dma_async_tx_descriptor *desc;\r\nunsigned len;\r\nint ret = 0;\r\nif (rspi->dma_width_16bit) {\r\nlen = t->len * 2;\r\nbuf = kmalloc(len, GFP_KERNEL);\r\nif (!buf)\r\nreturn -ENOMEM;\r\nrspi_memory_to_8bit(buf, t->tx_buf, t->len);\r\n} else {\r\nlen = t->len;\r\nbuf = (void *)t->tx_buf;\r\n}\r\nif (!rspi_dma_map_sg(&sg, buf, len, rspi->chan_tx, DMA_TO_DEVICE)) {\r\nret = -EFAULT;\r\ngoto end_nomap;\r\n}\r\ndesc = dmaengine_prep_slave_sg(rspi->chan_tx, &sg, 1, DMA_TO_DEVICE,\r\nDMA_PREP_INTERRUPT | DMA_CTRL_ACK);\r\nif (!desc) {\r\nret = -EIO;\r\ngoto end;\r\n}\r\ndisable_irq(rspi->irq);\r\nrspi_write8(rspi, rspi_read8(rspi, RSPI_SPCR) | SPCR_TXMD, RSPI_SPCR);\r\nrspi_enable_irq(rspi, SPCR_SPTIE);\r\nrspi->dma_callbacked = 0;\r\ndesc->callback = rspi_dma_complete;\r\ndesc->callback_param = rspi;\r\ndmaengine_submit(desc);\r\ndma_async_issue_pending(rspi->chan_tx);\r\nret = wait_event_interruptible_timeout(rspi->wait,\r\nrspi->dma_callbacked, HZ);\r\nif (ret > 0 && rspi->dma_callbacked)\r\nret = 0;\r\nelse if (!ret)\r\nret = -ETIMEDOUT;\r\nrspi_disable_irq(rspi, SPCR_SPTIE);\r\nenable_irq(rspi->irq);\r\nend:\r\nrspi_dma_unmap_sg(&sg, rspi->chan_tx, DMA_TO_DEVICE);\r\nend_nomap:\r\nif (rspi->dma_width_16bit)\r\nkfree(buf);\r\nreturn ret;\r\n}\r\nstatic void rspi_receive_init(struct rspi_data *rspi)\r\n{\r\nunsigned char spsr;\r\nspsr = rspi_read8(rspi, RSPI_SPSR);\r\nif (spsr & SPSR_SPRF)\r\nrspi_read16(rspi, RSPI_SPDR);\r\nif (spsr & SPSR_OVRF)\r\nrspi_write8(rspi, rspi_read8(rspi, RSPI_SPSR) & ~SPSR_OVRF,\r\nRSPI_SPCR);\r\n}\r\nstatic int rspi_receive_pio(struct rspi_data *rspi, struct spi_message *mesg,\r\nstruct spi_transfer *t)\r\n{\r\nint remain = t->len;\r\nu8 *data;\r\nrspi_receive_init(rspi);\r\ndata = (u8 *)t->rx_buf;\r\nwhile (remain > 0) {\r\nrspi_write8(rspi, rspi_read8(rspi, RSPI_SPCR) & ~SPCR_TXMD,\r\nRSPI_SPCR);\r\nif (rspi_wait_for_interrupt(rspi, SPSR_SPTEF, SPCR_SPTIE) < 0) {\r\ndev_err(&rspi->master->dev,\r\n"%s: tx empty timeout\n", __func__);\r\nreturn -ETIMEDOUT;\r\n}\r\nrspi_write16(rspi, 0x00, RSPI_SPDR);\r\nif (rspi_wait_for_interrupt(rspi, SPSR_SPRF, SPCR_SPRIE) < 0) {\r\ndev_err(&rspi->master->dev,\r\n"%s: receive timeout\n", __func__);\r\nreturn -ETIMEDOUT;\r\n}\r\n*data = (u8)rspi_read16(rspi, RSPI_SPDR);\r\ndata++;\r\nremain--;\r\n}\r\nreturn 0;\r\n}\r\nstatic int rspi_receive_dma(struct rspi_data *rspi, struct spi_transfer *t)\r\n{\r\nstruct scatterlist sg, sg_dummy;\r\nvoid *dummy = NULL, *rx_buf = NULL;\r\nstruct dma_async_tx_descriptor *desc, *desc_dummy;\r\nunsigned len;\r\nint ret = 0;\r\nif (rspi->dma_width_16bit) {\r\nlen = t->len * 2;\r\nrx_buf = kmalloc(len, GFP_KERNEL);\r\nif (!rx_buf)\r\nreturn -ENOMEM;\r\n} else {\r\nlen = t->len;\r\nrx_buf = t->rx_buf;\r\n}\r\ndummy = kzalloc(len, GFP_KERNEL);\r\nif (!dummy) {\r\nret = -ENOMEM;\r\ngoto end_nomap;\r\n}\r\nif (!rspi_dma_map_sg(&sg_dummy, dummy, len, rspi->chan_tx,\r\nDMA_TO_DEVICE)) {\r\nret = -EFAULT;\r\ngoto end_nomap;\r\n}\r\ndesc_dummy = dmaengine_prep_slave_sg(rspi->chan_tx, &sg_dummy, 1,\r\nDMA_TO_DEVICE, DMA_PREP_INTERRUPT | DMA_CTRL_ACK);\r\nif (!desc_dummy) {\r\nret = -EIO;\r\ngoto end_dummy_mapped;\r\n}\r\nif (!rspi_dma_map_sg(&sg, rx_buf, len, rspi->chan_rx,\r\nDMA_FROM_DEVICE)) {\r\nret = -EFAULT;\r\ngoto end_dummy_mapped;\r\n}\r\ndesc = dmaengine_prep_slave_sg(rspi->chan_rx, &sg, 1, DMA_FROM_DEVICE,\r\nDMA_PREP_INTERRUPT | DMA_CTRL_ACK);\r\nif (!desc) {\r\nret = -EIO;\r\ngoto end;\r\n}\r\nrspi_receive_init(rspi);\r\ndisable_irq(rspi->irq);\r\nrspi_write8(rspi, rspi_read8(rspi, RSPI_SPCR) & ~SPCR_TXMD, RSPI_SPCR);\r\nrspi_enable_irq(rspi, SPCR_SPTIE | SPCR_SPRIE);\r\nrspi->dma_callbacked = 0;\r\ndesc->callback = rspi_dma_complete;\r\ndesc->callback_param = rspi;\r\ndmaengine_submit(desc);\r\ndma_async_issue_pending(rspi->chan_rx);\r\ndesc_dummy->callback = NULL;\r\ndmaengine_submit(desc_dummy);\r\ndma_async_issue_pending(rspi->chan_tx);\r\nret = wait_event_interruptible_timeout(rspi->wait,\r\nrspi->dma_callbacked, HZ);\r\nif (ret > 0 && rspi->dma_callbacked)\r\nret = 0;\r\nelse if (!ret)\r\nret = -ETIMEDOUT;\r\nrspi_disable_irq(rspi, SPCR_SPTIE | SPCR_SPRIE);\r\nenable_irq(rspi->irq);\r\nend:\r\nrspi_dma_unmap_sg(&sg, rspi->chan_rx, DMA_FROM_DEVICE);\r\nend_dummy_mapped:\r\nrspi_dma_unmap_sg(&sg_dummy, rspi->chan_tx, DMA_TO_DEVICE);\r\nend_nomap:\r\nif (rspi->dma_width_16bit) {\r\nif (!ret)\r\nrspi_memory_from_8bit(t->rx_buf, rx_buf, t->len);\r\nkfree(rx_buf);\r\n}\r\nkfree(dummy);\r\nreturn ret;\r\n}\r\nstatic int rspi_is_dma(struct rspi_data *rspi, struct spi_transfer *t)\r\n{\r\nif (t->tx_buf && rspi->chan_tx)\r\nreturn 1;\r\nif (t->rx_buf && rspi->chan_tx && rspi->chan_rx)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic void rspi_work(struct work_struct *work)\r\n{\r\nstruct rspi_data *rspi = container_of(work, struct rspi_data, ws);\r\nstruct spi_message *mesg;\r\nstruct spi_transfer *t;\r\nunsigned long flags;\r\nint ret;\r\nspin_lock_irqsave(&rspi->lock, flags);\r\nwhile (!list_empty(&rspi->queue)) {\r\nmesg = list_entry(rspi->queue.next, struct spi_message, queue);\r\nlist_del_init(&mesg->queue);\r\nspin_unlock_irqrestore(&rspi->lock, flags);\r\nrspi_assert_ssl(rspi);\r\nlist_for_each_entry(t, &mesg->transfers, transfer_list) {\r\nif (t->tx_buf) {\r\nif (rspi_is_dma(rspi, t))\r\nret = rspi_send_dma(rspi, t);\r\nelse\r\nret = rspi_send_pio(rspi, mesg, t);\r\nif (ret < 0)\r\ngoto error;\r\n}\r\nif (t->rx_buf) {\r\nif (rspi_is_dma(rspi, t))\r\nret = rspi_receive_dma(rspi, t);\r\nelse\r\nret = rspi_receive_pio(rspi, mesg, t);\r\nif (ret < 0)\r\ngoto error;\r\n}\r\nmesg->actual_length += t->len;\r\n}\r\nrspi_negate_ssl(rspi);\r\nmesg->status = 0;\r\nmesg->complete(mesg->context);\r\nspin_lock_irqsave(&rspi->lock, flags);\r\n}\r\nreturn;\r\nerror:\r\nmesg->status = ret;\r\nmesg->complete(mesg->context);\r\n}\r\nstatic int rspi_setup(struct spi_device *spi)\r\n{\r\nstruct rspi_data *rspi = spi_master_get_devdata(spi->master);\r\nif (!spi->bits_per_word)\r\nspi->bits_per_word = 8;\r\nrspi->max_speed_hz = spi->max_speed_hz;\r\nrspi_set_config_register(rspi, 8);\r\nreturn 0;\r\n}\r\nstatic int rspi_transfer(struct spi_device *spi, struct spi_message *mesg)\r\n{\r\nstruct rspi_data *rspi = spi_master_get_devdata(spi->master);\r\nunsigned long flags;\r\nmesg->actual_length = 0;\r\nmesg->status = -EINPROGRESS;\r\nspin_lock_irqsave(&rspi->lock, flags);\r\nlist_add_tail(&mesg->queue, &rspi->queue);\r\nschedule_work(&rspi->ws);\r\nspin_unlock_irqrestore(&rspi->lock, flags);\r\nreturn 0;\r\n}\r\nstatic void rspi_cleanup(struct spi_device *spi)\r\n{\r\n}\r\nstatic irqreturn_t rspi_irq(int irq, void *_sr)\r\n{\r\nstruct rspi_data *rspi = (struct rspi_data *)_sr;\r\nunsigned long spsr;\r\nirqreturn_t ret = IRQ_NONE;\r\nunsigned char disable_irq = 0;\r\nrspi->spsr = spsr = rspi_read8(rspi, RSPI_SPSR);\r\nif (spsr & SPSR_SPRF)\r\ndisable_irq |= SPCR_SPRIE;\r\nif (spsr & SPSR_SPTEF)\r\ndisable_irq |= SPCR_SPTIE;\r\nif (disable_irq) {\r\nret = IRQ_HANDLED;\r\nrspi_disable_irq(rspi, disable_irq);\r\nwake_up(&rspi->wait);\r\n}\r\nreturn ret;\r\n}\r\nstatic int rspi_request_dma(struct rspi_data *rspi,\r\nstruct platform_device *pdev)\r\n{\r\nstruct rspi_plat_data *rspi_pd = pdev->dev.platform_data;\r\ndma_cap_mask_t mask;\r\nstruct dma_slave_config cfg;\r\nint ret;\r\nif (!rspi_pd)\r\nreturn 0;\r\nrspi->dma_width_16bit = rspi_pd->dma_width_16bit;\r\nif (rspi_pd->dma_rx_id && rspi_pd->dma_tx_id) {\r\ndma_cap_zero(mask);\r\ndma_cap_set(DMA_SLAVE, mask);\r\nrspi->chan_rx = dma_request_channel(mask, shdma_chan_filter,\r\n(void *)rspi_pd->dma_rx_id);\r\nif (rspi->chan_rx) {\r\ncfg.slave_id = rspi_pd->dma_rx_id;\r\ncfg.direction = DMA_DEV_TO_MEM;\r\nret = dmaengine_slave_config(rspi->chan_rx, &cfg);\r\nif (!ret)\r\ndev_info(&pdev->dev, "Use DMA when rx.\n");\r\nelse\r\nreturn ret;\r\n}\r\n}\r\nif (rspi_pd->dma_tx_id) {\r\ndma_cap_zero(mask);\r\ndma_cap_set(DMA_SLAVE, mask);\r\nrspi->chan_tx = dma_request_channel(mask, shdma_chan_filter,\r\n(void *)rspi_pd->dma_tx_id);\r\nif (rspi->chan_tx) {\r\ncfg.slave_id = rspi_pd->dma_tx_id;\r\ncfg.direction = DMA_MEM_TO_DEV;\r\nret = dmaengine_slave_config(rspi->chan_tx, &cfg);\r\nif (!ret)\r\ndev_info(&pdev->dev, "Use DMA when tx\n");\r\nelse\r\nreturn ret;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void rspi_release_dma(struct rspi_data *rspi)\r\n{\r\nif (rspi->chan_tx)\r\ndma_release_channel(rspi->chan_tx);\r\nif (rspi->chan_rx)\r\ndma_release_channel(rspi->chan_rx);\r\n}\r\nstatic int rspi_remove(struct platform_device *pdev)\r\n{\r\nstruct rspi_data *rspi = dev_get_drvdata(&pdev->dev);\r\nspi_unregister_master(rspi->master);\r\nrspi_release_dma(rspi);\r\nfree_irq(platform_get_irq(pdev, 0), rspi);\r\nclk_put(rspi->clk);\r\niounmap(rspi->addr);\r\nspi_master_put(rspi->master);\r\nreturn 0;\r\n}\r\nstatic int rspi_probe(struct platform_device *pdev)\r\n{\r\nstruct resource *res;\r\nstruct spi_master *master;\r\nstruct rspi_data *rspi;\r\nint ret, irq;\r\nchar clk_name[16];\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (unlikely(res == NULL)) {\r\ndev_err(&pdev->dev, "invalid resource\n");\r\nreturn -EINVAL;\r\n}\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq < 0) {\r\ndev_err(&pdev->dev, "platform_get_irq error\n");\r\nreturn -ENODEV;\r\n}\r\nmaster = spi_alloc_master(&pdev->dev, sizeof(struct rspi_data));\r\nif (master == NULL) {\r\ndev_err(&pdev->dev, "spi_alloc_master error.\n");\r\nreturn -ENOMEM;\r\n}\r\nrspi = spi_master_get_devdata(master);\r\ndev_set_drvdata(&pdev->dev, rspi);\r\nrspi->master = master;\r\nrspi->addr = ioremap(res->start, resource_size(res));\r\nif (rspi->addr == NULL) {\r\ndev_err(&pdev->dev, "ioremap error.\n");\r\nret = -ENOMEM;\r\ngoto error1;\r\n}\r\nsnprintf(clk_name, sizeof(clk_name), "rspi%d", pdev->id);\r\nrspi->clk = clk_get(&pdev->dev, clk_name);\r\nif (IS_ERR(rspi->clk)) {\r\ndev_err(&pdev->dev, "cannot get clock\n");\r\nret = PTR_ERR(rspi->clk);\r\ngoto error2;\r\n}\r\nclk_enable(rspi->clk);\r\nINIT_LIST_HEAD(&rspi->queue);\r\nspin_lock_init(&rspi->lock);\r\nINIT_WORK(&rspi->ws, rspi_work);\r\ninit_waitqueue_head(&rspi->wait);\r\nmaster->num_chipselect = 2;\r\nmaster->bus_num = pdev->id;\r\nmaster->setup = rspi_setup;\r\nmaster->transfer = rspi_transfer;\r\nmaster->cleanup = rspi_cleanup;\r\nret = request_irq(irq, rspi_irq, 0, dev_name(&pdev->dev), rspi);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "request_irq error\n");\r\ngoto error3;\r\n}\r\nrspi->irq = irq;\r\nret = rspi_request_dma(rspi, pdev);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "rspi_request_dma failed.\n");\r\ngoto error4;\r\n}\r\nret = spi_register_master(master);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "spi_register_master error.\n");\r\ngoto error4;\r\n}\r\ndev_info(&pdev->dev, "probed\n");\r\nreturn 0;\r\nerror4:\r\nrspi_release_dma(rspi);\r\nfree_irq(irq, rspi);\r\nerror3:\r\nclk_put(rspi->clk);\r\nerror2:\r\niounmap(rspi->addr);\r\nerror1:\r\nspi_master_put(master);\r\nreturn ret;\r\n}
