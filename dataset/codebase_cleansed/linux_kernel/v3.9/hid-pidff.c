static int pidff_rescale(int i, int max, struct hid_field *field)\r\n{\r\nreturn i * (field->logical_maximum - field->logical_minimum) / max +\r\nfield->logical_minimum;\r\n}\r\nstatic int pidff_rescale_signed(int i, struct hid_field *field)\r\n{\r\nreturn i == 0 ? 0 : i >\r\n0 ? i * field->logical_maximum / 0x7fff : i *\r\nfield->logical_minimum / -0x8000;\r\n}\r\nstatic void pidff_set(struct pidff_usage *usage, u16 value)\r\n{\r\nusage->value[0] = pidff_rescale(value, 0xffff, usage->field);\r\npr_debug("calculated from %d to %d\n", value, usage->value[0]);\r\n}\r\nstatic void pidff_set_signed(struct pidff_usage *usage, s16 value)\r\n{\r\nif (usage->field->logical_minimum < 0)\r\nusage->value[0] = pidff_rescale_signed(value, usage->field);\r\nelse {\r\nif (value < 0)\r\nusage->value[0] =\r\npidff_rescale(-value, 0x8000, usage->field);\r\nelse\r\nusage->value[0] =\r\npidff_rescale(value, 0x7fff, usage->field);\r\n}\r\npr_debug("calculated from %d to %d\n", value, usage->value[0]);\r\n}\r\nstatic void pidff_set_envelope_report(struct pidff_device *pidff,\r\nstruct ff_envelope *envelope)\r\n{\r\npidff->set_envelope[PID_EFFECT_BLOCK_INDEX].value[0] =\r\npidff->block_load[PID_EFFECT_BLOCK_INDEX].value[0];\r\npidff->set_envelope[PID_ATTACK_LEVEL].value[0] =\r\npidff_rescale(envelope->attack_level >\r\n0x7fff ? 0x7fff : envelope->attack_level, 0x7fff,\r\npidff->set_envelope[PID_ATTACK_LEVEL].field);\r\npidff->set_envelope[PID_FADE_LEVEL].value[0] =\r\npidff_rescale(envelope->fade_level >\r\n0x7fff ? 0x7fff : envelope->fade_level, 0x7fff,\r\npidff->set_envelope[PID_FADE_LEVEL].field);\r\npidff->set_envelope[PID_ATTACK_TIME].value[0] = envelope->attack_length;\r\npidff->set_envelope[PID_FADE_TIME].value[0] = envelope->fade_length;\r\nhid_dbg(pidff->hid, "attack %u => %d\n",\r\nenvelope->attack_level,\r\npidff->set_envelope[PID_ATTACK_LEVEL].value[0]);\r\nusbhid_submit_report(pidff->hid, pidff->reports[PID_SET_ENVELOPE],\r\nUSB_DIR_OUT);\r\n}\r\nstatic int pidff_needs_set_envelope(struct ff_envelope *envelope,\r\nstruct ff_envelope *old)\r\n{\r\nreturn envelope->attack_level != old->attack_level ||\r\nenvelope->fade_level != old->fade_level ||\r\nenvelope->attack_length != old->attack_length ||\r\nenvelope->fade_length != old->fade_length;\r\n}\r\nstatic void pidff_set_constant_force_report(struct pidff_device *pidff,\r\nstruct ff_effect *effect)\r\n{\r\npidff->set_constant[PID_EFFECT_BLOCK_INDEX].value[0] =\r\npidff->block_load[PID_EFFECT_BLOCK_INDEX].value[0];\r\npidff_set_signed(&pidff->set_constant[PID_MAGNITUDE],\r\neffect->u.constant.level);\r\nusbhid_submit_report(pidff->hid, pidff->reports[PID_SET_CONSTANT],\r\nUSB_DIR_OUT);\r\n}\r\nstatic int pidff_needs_set_constant(struct ff_effect *effect,\r\nstruct ff_effect *old)\r\n{\r\nreturn effect->u.constant.level != old->u.constant.level;\r\n}\r\nstatic void pidff_set_effect_report(struct pidff_device *pidff,\r\nstruct ff_effect *effect)\r\n{\r\npidff->set_effect[PID_EFFECT_BLOCK_INDEX].value[0] =\r\npidff->block_load[PID_EFFECT_BLOCK_INDEX].value[0];\r\npidff->set_effect_type->value[0] =\r\npidff->create_new_effect_type->value[0];\r\npidff->set_effect[PID_DURATION].value[0] = effect->replay.length;\r\npidff->set_effect[PID_TRIGGER_BUTTON].value[0] = effect->trigger.button;\r\npidff->set_effect[PID_TRIGGER_REPEAT_INT].value[0] =\r\neffect->trigger.interval;\r\npidff->set_effect[PID_GAIN].value[0] =\r\npidff->set_effect[PID_GAIN].field->logical_maximum;\r\npidff->set_effect[PID_DIRECTION_ENABLE].value[0] = 1;\r\npidff->effect_direction->value[0] =\r\npidff_rescale(effect->direction, 0xffff,\r\npidff->effect_direction);\r\npidff->set_effect[PID_START_DELAY].value[0] = effect->replay.delay;\r\nusbhid_submit_report(pidff->hid, pidff->reports[PID_SET_EFFECT],\r\nUSB_DIR_OUT);\r\n}\r\nstatic int pidff_needs_set_effect(struct ff_effect *effect,\r\nstruct ff_effect *old)\r\n{\r\nreturn effect->replay.length != old->replay.length ||\r\neffect->trigger.interval != old->trigger.interval ||\r\neffect->trigger.button != old->trigger.button ||\r\neffect->direction != old->direction ||\r\neffect->replay.delay != old->replay.delay;\r\n}\r\nstatic void pidff_set_periodic_report(struct pidff_device *pidff,\r\nstruct ff_effect *effect)\r\n{\r\npidff->set_periodic[PID_EFFECT_BLOCK_INDEX].value[0] =\r\npidff->block_load[PID_EFFECT_BLOCK_INDEX].value[0];\r\npidff_set_signed(&pidff->set_periodic[PID_MAGNITUDE],\r\neffect->u.periodic.magnitude);\r\npidff_set_signed(&pidff->set_periodic[PID_OFFSET],\r\neffect->u.periodic.offset);\r\npidff_set(&pidff->set_periodic[PID_PHASE], effect->u.periodic.phase);\r\npidff->set_periodic[PID_PERIOD].value[0] = effect->u.periodic.period;\r\nusbhid_submit_report(pidff->hid, pidff->reports[PID_SET_PERIODIC],\r\nUSB_DIR_OUT);\r\n}\r\nstatic int pidff_needs_set_periodic(struct ff_effect *effect,\r\nstruct ff_effect *old)\r\n{\r\nreturn effect->u.periodic.magnitude != old->u.periodic.magnitude ||\r\neffect->u.periodic.offset != old->u.periodic.offset ||\r\neffect->u.periodic.phase != old->u.periodic.phase ||\r\neffect->u.periodic.period != old->u.periodic.period;\r\n}\r\nstatic void pidff_set_condition_report(struct pidff_device *pidff,\r\nstruct ff_effect *effect)\r\n{\r\nint i;\r\npidff->set_condition[PID_EFFECT_BLOCK_INDEX].value[0] =\r\npidff->block_load[PID_EFFECT_BLOCK_INDEX].value[0];\r\nfor (i = 0; i < 2; i++) {\r\npidff->set_condition[PID_PARAM_BLOCK_OFFSET].value[0] = i;\r\npidff_set_signed(&pidff->set_condition[PID_CP_OFFSET],\r\neffect->u.condition[i].center);\r\npidff_set_signed(&pidff->set_condition[PID_POS_COEFFICIENT],\r\neffect->u.condition[i].right_coeff);\r\npidff_set_signed(&pidff->set_condition[PID_NEG_COEFFICIENT],\r\neffect->u.condition[i].left_coeff);\r\npidff_set(&pidff->set_condition[PID_POS_SATURATION],\r\neffect->u.condition[i].right_saturation);\r\npidff_set(&pidff->set_condition[PID_NEG_SATURATION],\r\neffect->u.condition[i].left_saturation);\r\npidff_set(&pidff->set_condition[PID_DEAD_BAND],\r\neffect->u.condition[i].deadband);\r\nusbhid_submit_report(pidff->hid, pidff->reports[PID_SET_CONDITION],\r\nUSB_DIR_OUT);\r\n}\r\n}\r\nstatic int pidff_needs_set_condition(struct ff_effect *effect,\r\nstruct ff_effect *old)\r\n{\r\nint i;\r\nint ret = 0;\r\nfor (i = 0; i < 2; i++) {\r\nstruct ff_condition_effect *cond = &effect->u.condition[i];\r\nstruct ff_condition_effect *old_cond = &old->u.condition[i];\r\nret |= cond->center != old_cond->center ||\r\ncond->right_coeff != old_cond->right_coeff ||\r\ncond->left_coeff != old_cond->left_coeff ||\r\ncond->right_saturation != old_cond->right_saturation ||\r\ncond->left_saturation != old_cond->left_saturation ||\r\ncond->deadband != old_cond->deadband;\r\n}\r\nreturn ret;\r\n}\r\nstatic void pidff_set_ramp_force_report(struct pidff_device *pidff,\r\nstruct ff_effect *effect)\r\n{\r\npidff->set_ramp[PID_EFFECT_BLOCK_INDEX].value[0] =\r\npidff->block_load[PID_EFFECT_BLOCK_INDEX].value[0];\r\npidff_set_signed(&pidff->set_ramp[PID_RAMP_START],\r\neffect->u.ramp.start_level);\r\npidff_set_signed(&pidff->set_ramp[PID_RAMP_END],\r\neffect->u.ramp.end_level);\r\nusbhid_submit_report(pidff->hid, pidff->reports[PID_SET_RAMP],\r\nUSB_DIR_OUT);\r\n}\r\nstatic int pidff_needs_set_ramp(struct ff_effect *effect, struct ff_effect *old)\r\n{\r\nreturn effect->u.ramp.start_level != old->u.ramp.start_level ||\r\neffect->u.ramp.end_level != old->u.ramp.end_level;\r\n}\r\nstatic int pidff_request_effect_upload(struct pidff_device *pidff, int efnum)\r\n{\r\nint j;\r\npidff->create_new_effect_type->value[0] = efnum;\r\nusbhid_submit_report(pidff->hid, pidff->reports[PID_CREATE_NEW_EFFECT],\r\nUSB_DIR_OUT);\r\nhid_dbg(pidff->hid, "create_new_effect sent, type: %d\n", efnum);\r\npidff->block_load[PID_EFFECT_BLOCK_INDEX].value[0] = 0;\r\npidff->block_load_status->value[0] = 0;\r\nusbhid_wait_io(pidff->hid);\r\nfor (j = 0; j < 60; j++) {\r\nhid_dbg(pidff->hid, "pid_block_load requested\n");\r\nusbhid_submit_report(pidff->hid, pidff->reports[PID_BLOCK_LOAD],\r\nUSB_DIR_IN);\r\nusbhid_wait_io(pidff->hid);\r\nif (pidff->block_load_status->value[0] ==\r\npidff->status_id[PID_BLOCK_LOAD_SUCCESS]) {\r\nhid_dbg(pidff->hid, "device reported free memory: %d bytes\n",\r\npidff->block_load[PID_RAM_POOL_AVAILABLE].value ?\r\npidff->block_load[PID_RAM_POOL_AVAILABLE].value[0] : -1);\r\nreturn 0;\r\n}\r\nif (pidff->block_load_status->value[0] ==\r\npidff->status_id[PID_BLOCK_LOAD_FULL]) {\r\nhid_dbg(pidff->hid, "not enough memory free: %d bytes\n",\r\npidff->block_load[PID_RAM_POOL_AVAILABLE].value ?\r\npidff->block_load[PID_RAM_POOL_AVAILABLE].value[0] : -1);\r\nreturn -ENOSPC;\r\n}\r\n}\r\nhid_err(pidff->hid, "pid_block_load failed 60 times\n");\r\nreturn -EIO;\r\n}\r\nstatic void pidff_playback_pid(struct pidff_device *pidff, int pid_id, int n)\r\n{\r\npidff->effect_operation[PID_EFFECT_BLOCK_INDEX].value[0] = pid_id;\r\nif (n == 0) {\r\npidff->effect_operation_status->value[0] =\r\npidff->operation_id[PID_EFFECT_STOP];\r\n} else {\r\npidff->effect_operation_status->value[0] =\r\npidff->operation_id[PID_EFFECT_START];\r\npidff->effect_operation[PID_LOOP_COUNT].value[0] = n;\r\n}\r\nusbhid_submit_report(pidff->hid, pidff->reports[PID_EFFECT_OPERATION],\r\nUSB_DIR_OUT);\r\n}\r\nstatic int pidff_playback(struct input_dev *dev, int effect_id, int value)\r\n{\r\nstruct pidff_device *pidff = dev->ff->private;\r\npidff_playback_pid(pidff, pidff->pid_id[effect_id], value);\r\nreturn 0;\r\n}\r\nstatic void pidff_erase_pid(struct pidff_device *pidff, int pid_id)\r\n{\r\npidff->block_free[PID_EFFECT_BLOCK_INDEX].value[0] = pid_id;\r\nusbhid_submit_report(pidff->hid, pidff->reports[PID_BLOCK_FREE],\r\nUSB_DIR_OUT);\r\n}\r\nstatic int pidff_erase_effect(struct input_dev *dev, int effect_id)\r\n{\r\nstruct pidff_device *pidff = dev->ff->private;\r\nint pid_id = pidff->pid_id[effect_id];\r\nhid_dbg(pidff->hid, "starting to erase %d/%d\n",\r\neffect_id, pidff->pid_id[effect_id]);\r\nusbhid_wait_io(pidff->hid);\r\npidff_playback_pid(pidff, pid_id, 0);\r\npidff_erase_pid(pidff, pid_id);\r\nreturn 0;\r\n}\r\nstatic int pidff_upload_effect(struct input_dev *dev, struct ff_effect *effect,\r\nstruct ff_effect *old)\r\n{\r\nstruct pidff_device *pidff = dev->ff->private;\r\nint type_id;\r\nint error;\r\nswitch (effect->type) {\r\ncase FF_CONSTANT:\r\nif (!old) {\r\nerror = pidff_request_effect_upload(pidff,\r\npidff->type_id[PID_CONSTANT]);\r\nif (error)\r\nreturn error;\r\n}\r\nif (!old || pidff_needs_set_effect(effect, old))\r\npidff_set_effect_report(pidff, effect);\r\nif (!old || pidff_needs_set_constant(effect, old))\r\npidff_set_constant_force_report(pidff, effect);\r\nif (!old ||\r\npidff_needs_set_envelope(&effect->u.constant.envelope,\r\n&old->u.constant.envelope))\r\npidff_set_envelope_report(pidff,\r\n&effect->u.constant.envelope);\r\nbreak;\r\ncase FF_PERIODIC:\r\nif (!old) {\r\nswitch (effect->u.periodic.waveform) {\r\ncase FF_SQUARE:\r\ntype_id = PID_SQUARE;\r\nbreak;\r\ncase FF_TRIANGLE:\r\ntype_id = PID_TRIANGLE;\r\nbreak;\r\ncase FF_SINE:\r\ntype_id = PID_SINE;\r\nbreak;\r\ncase FF_SAW_UP:\r\ntype_id = PID_SAW_UP;\r\nbreak;\r\ncase FF_SAW_DOWN:\r\ntype_id = PID_SAW_DOWN;\r\nbreak;\r\ndefault:\r\nhid_err(pidff->hid, "invalid waveform\n");\r\nreturn -EINVAL;\r\n}\r\nerror = pidff_request_effect_upload(pidff,\r\npidff->type_id[type_id]);\r\nif (error)\r\nreturn error;\r\n}\r\nif (!old || pidff_needs_set_effect(effect, old))\r\npidff_set_effect_report(pidff, effect);\r\nif (!old || pidff_needs_set_periodic(effect, old))\r\npidff_set_periodic_report(pidff, effect);\r\nif (!old ||\r\npidff_needs_set_envelope(&effect->u.periodic.envelope,\r\n&old->u.periodic.envelope))\r\npidff_set_envelope_report(pidff,\r\n&effect->u.periodic.envelope);\r\nbreak;\r\ncase FF_RAMP:\r\nif (!old) {\r\nerror = pidff_request_effect_upload(pidff,\r\npidff->type_id[PID_RAMP]);\r\nif (error)\r\nreturn error;\r\n}\r\nif (!old || pidff_needs_set_effect(effect, old))\r\npidff_set_effect_report(pidff, effect);\r\nif (!old || pidff_needs_set_ramp(effect, old))\r\npidff_set_ramp_force_report(pidff, effect);\r\nif (!old ||\r\npidff_needs_set_envelope(&effect->u.ramp.envelope,\r\n&old->u.ramp.envelope))\r\npidff_set_envelope_report(pidff,\r\n&effect->u.ramp.envelope);\r\nbreak;\r\ncase FF_SPRING:\r\nif (!old) {\r\nerror = pidff_request_effect_upload(pidff,\r\npidff->type_id[PID_SPRING]);\r\nif (error)\r\nreturn error;\r\n}\r\nif (!old || pidff_needs_set_effect(effect, old))\r\npidff_set_effect_report(pidff, effect);\r\nif (!old || pidff_needs_set_condition(effect, old))\r\npidff_set_condition_report(pidff, effect);\r\nbreak;\r\ncase FF_FRICTION:\r\nif (!old) {\r\nerror = pidff_request_effect_upload(pidff,\r\npidff->type_id[PID_FRICTION]);\r\nif (error)\r\nreturn error;\r\n}\r\nif (!old || pidff_needs_set_effect(effect, old))\r\npidff_set_effect_report(pidff, effect);\r\nif (!old || pidff_needs_set_condition(effect, old))\r\npidff_set_condition_report(pidff, effect);\r\nbreak;\r\ncase FF_DAMPER:\r\nif (!old) {\r\nerror = pidff_request_effect_upload(pidff,\r\npidff->type_id[PID_DAMPER]);\r\nif (error)\r\nreturn error;\r\n}\r\nif (!old || pidff_needs_set_effect(effect, old))\r\npidff_set_effect_report(pidff, effect);\r\nif (!old || pidff_needs_set_condition(effect, old))\r\npidff_set_condition_report(pidff, effect);\r\nbreak;\r\ncase FF_INERTIA:\r\nif (!old) {\r\nerror = pidff_request_effect_upload(pidff,\r\npidff->type_id[PID_INERTIA]);\r\nif (error)\r\nreturn error;\r\n}\r\nif (!old || pidff_needs_set_effect(effect, old))\r\npidff_set_effect_report(pidff, effect);\r\nif (!old || pidff_needs_set_condition(effect, old))\r\npidff_set_condition_report(pidff, effect);\r\nbreak;\r\ndefault:\r\nhid_err(pidff->hid, "invalid type\n");\r\nreturn -EINVAL;\r\n}\r\nif (!old)\r\npidff->pid_id[effect->id] =\r\npidff->block_load[PID_EFFECT_BLOCK_INDEX].value[0];\r\nhid_dbg(pidff->hid, "uploaded\n");\r\nreturn 0;\r\n}\r\nstatic void pidff_set_gain(struct input_dev *dev, u16 gain)\r\n{\r\nstruct pidff_device *pidff = dev->ff->private;\r\npidff_set(&pidff->device_gain[PID_DEVICE_GAIN_FIELD], gain);\r\nusbhid_submit_report(pidff->hid, pidff->reports[PID_DEVICE_GAIN],\r\nUSB_DIR_OUT);\r\n}\r\nstatic void pidff_autocenter(struct pidff_device *pidff, u16 magnitude)\r\n{\r\nstruct hid_field *field =\r\npidff->block_load[PID_EFFECT_BLOCK_INDEX].field;\r\nif (!magnitude) {\r\npidff_playback_pid(pidff, field->logical_minimum, 0);\r\nreturn;\r\n}\r\npidff_playback_pid(pidff, field->logical_minimum, 1);\r\npidff->set_effect[PID_EFFECT_BLOCK_INDEX].value[0] =\r\npidff->block_load[PID_EFFECT_BLOCK_INDEX].field->logical_minimum;\r\npidff->set_effect_type->value[0] = pidff->type_id[PID_SPRING];\r\npidff->set_effect[PID_DURATION].value[0] = 0;\r\npidff->set_effect[PID_TRIGGER_BUTTON].value[0] = 0;\r\npidff->set_effect[PID_TRIGGER_REPEAT_INT].value[0] = 0;\r\npidff_set(&pidff->set_effect[PID_GAIN], magnitude);\r\npidff->set_effect[PID_DIRECTION_ENABLE].value[0] = 1;\r\npidff->set_effect[PID_START_DELAY].value[0] = 0;\r\nusbhid_submit_report(pidff->hid, pidff->reports[PID_SET_EFFECT],\r\nUSB_DIR_OUT);\r\n}\r\nstatic void pidff_set_autocenter(struct input_dev *dev, u16 magnitude)\r\n{\r\nstruct pidff_device *pidff = dev->ff->private;\r\npidff_autocenter(pidff, magnitude);\r\n}\r\nstatic int pidff_find_fields(struct pidff_usage *usage, const u8 *table,\r\nstruct hid_report *report, int count, int strict)\r\n{\r\nint i, j, k, found;\r\nfor (k = 0; k < count; k++) {\r\nfound = 0;\r\nfor (i = 0; i < report->maxfield; i++) {\r\nif (report->field[i]->maxusage !=\r\nreport->field[i]->report_count) {\r\npr_debug("maxusage and report_count do not match, skipping\n");\r\ncontinue;\r\n}\r\nfor (j = 0; j < report->field[i]->maxusage; j++) {\r\nif (report->field[i]->usage[j].hid ==\r\n(HID_UP_PID | table[k])) {\r\npr_debug("found %d at %d->%d\n",\r\nk, i, j);\r\nusage[k].field = report->field[i];\r\nusage[k].value =\r\n&report->field[i]->value[j];\r\nfound = 1;\r\nbreak;\r\n}\r\n}\r\nif (found)\r\nbreak;\r\n}\r\nif (!found && strict) {\r\npr_debug("failed to locate %d\n", k);\r\nreturn -1;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int pidff_check_usage(int usage)\r\n{\r\nint i;\r\nfor (i = 0; i < sizeof(pidff_reports); i++)\r\nif (usage == (HID_UP_PID | pidff_reports[i]))\r\nreturn i;\r\nreturn -1;\r\n}\r\nstatic void pidff_find_reports(struct hid_device *hid, int report_type,\r\nstruct pidff_device *pidff)\r\n{\r\nstruct hid_report *report;\r\nint i, ret;\r\nlist_for_each_entry(report,\r\n&hid->report_enum[report_type].report_list, list) {\r\nif (report->maxfield < 1)\r\ncontinue;\r\nret = pidff_check_usage(report->field[0]->logical);\r\nif (ret != -1) {\r\nhid_dbg(hid, "found usage 0x%02x from field->logical\n",\r\npidff_reports[ret]);\r\npidff->reports[ret] = report;\r\ncontinue;\r\n}\r\ni = report->field[0]->usage[0].collection_index;\r\nif (i <= 0 ||\r\nhid->collection[i - 1].type != HID_COLLECTION_LOGICAL)\r\ncontinue;\r\nret = pidff_check_usage(hid->collection[i - 1].usage);\r\nif (ret != -1 && !pidff->reports[ret]) {\r\nhid_dbg(hid,\r\n"found usage 0x%02x from collection array\n",\r\npidff_reports[ret]);\r\npidff->reports[ret] = report;\r\n}\r\n}\r\n}\r\nstatic int pidff_reports_ok(struct pidff_device *pidff)\r\n{\r\nint i;\r\nfor (i = 0; i <= PID_REQUIRED_REPORTS; i++) {\r\nif (!pidff->reports[i]) {\r\nhid_dbg(pidff->hid, "%d missing\n", i);\r\nreturn 0;\r\n}\r\n}\r\nreturn 1;\r\n}\r\nstatic struct hid_field *pidff_find_special_field(struct hid_report *report,\r\nint usage, int enforce_min)\r\n{\r\nint i;\r\nfor (i = 0; i < report->maxfield; i++) {\r\nif (report->field[i]->logical == (HID_UP_PID | usage) &&\r\nreport->field[i]->report_count > 0) {\r\nif (!enforce_min ||\r\nreport->field[i]->logical_minimum == 1)\r\nreturn report->field[i];\r\nelse {\r\npr_err("logical_minimum is not 1 as it should be\n");\r\nreturn NULL;\r\n}\r\n}\r\n}\r\nreturn NULL;\r\n}\r\nstatic int pidff_find_special_keys(int *keys, struct hid_field *fld,\r\nconst u8 *usagetable, int count)\r\n{\r\nint i, j;\r\nint found = 0;\r\nfor (i = 0; i < count; i++) {\r\nfor (j = 0; j < fld->maxusage; j++) {\r\nif (fld->usage[j].hid == (HID_UP_PID | usagetable[i])) {\r\nkeys[i] = j + 1;\r\nfound++;\r\nbreak;\r\n}\r\n}\r\n}\r\nreturn found;\r\n}\r\nstatic int pidff_find_special_fields(struct pidff_device *pidff)\r\n{\r\nhid_dbg(pidff->hid, "finding special fields\n");\r\npidff->create_new_effect_type =\r\npidff_find_special_field(pidff->reports[PID_CREATE_NEW_EFFECT],\r\n0x25, 1);\r\npidff->set_effect_type =\r\npidff_find_special_field(pidff->reports[PID_SET_EFFECT],\r\n0x25, 1);\r\npidff->effect_direction =\r\npidff_find_special_field(pidff->reports[PID_SET_EFFECT],\r\n0x57, 0);\r\npidff->device_control =\r\npidff_find_special_field(pidff->reports[PID_DEVICE_CONTROL],\r\n0x96, 1);\r\npidff->block_load_status =\r\npidff_find_special_field(pidff->reports[PID_BLOCK_LOAD],\r\n0x8b, 1);\r\npidff->effect_operation_status =\r\npidff_find_special_field(pidff->reports[PID_EFFECT_OPERATION],\r\n0x78, 1);\r\nhid_dbg(pidff->hid, "search done\n");\r\nif (!pidff->create_new_effect_type || !pidff->set_effect_type) {\r\nhid_err(pidff->hid, "effect lists not found\n");\r\nreturn -1;\r\n}\r\nif (!pidff->effect_direction) {\r\nhid_err(pidff->hid, "direction field not found\n");\r\nreturn -1;\r\n}\r\nif (!pidff->device_control) {\r\nhid_err(pidff->hid, "device control field not found\n");\r\nreturn -1;\r\n}\r\nif (!pidff->block_load_status) {\r\nhid_err(pidff->hid, "block load status field not found\n");\r\nreturn -1;\r\n}\r\nif (!pidff->effect_operation_status) {\r\nhid_err(pidff->hid, "effect operation field not found\n");\r\nreturn -1;\r\n}\r\npidff_find_special_keys(pidff->control_id, pidff->device_control,\r\npidff_device_control,\r\nsizeof(pidff_device_control));\r\nPIDFF_FIND_SPECIAL_KEYS(control_id, device_control, device_control);\r\nif (!PIDFF_FIND_SPECIAL_KEYS(type_id, create_new_effect_type,\r\neffect_types)) {\r\nhid_err(pidff->hid, "no effect types found\n");\r\nreturn -1;\r\n}\r\nif (PIDFF_FIND_SPECIAL_KEYS(status_id, block_load_status,\r\nblock_load_status) !=\r\nsizeof(pidff_block_load_status)) {\r\nhid_err(pidff->hid,\r\n"block load status identifiers not found\n");\r\nreturn -1;\r\n}\r\nif (PIDFF_FIND_SPECIAL_KEYS(operation_id, effect_operation_status,\r\neffect_operation_status) !=\r\nsizeof(pidff_effect_operation_status)) {\r\nhid_err(pidff->hid, "effect operation identifiers not found\n");\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int pidff_find_effects(struct pidff_device *pidff,\r\nstruct input_dev *dev)\r\n{\r\nint i;\r\nfor (i = 0; i < sizeof(pidff_effect_types); i++) {\r\nint pidff_type = pidff->type_id[i];\r\nif (pidff->set_effect_type->usage[pidff_type].hid !=\r\npidff->create_new_effect_type->usage[pidff_type].hid) {\r\nhid_err(pidff->hid,\r\n"effect type number %d is invalid\n", i);\r\nreturn -1;\r\n}\r\n}\r\nif (pidff->type_id[PID_CONSTANT])\r\nset_bit(FF_CONSTANT, dev->ffbit);\r\nif (pidff->type_id[PID_RAMP])\r\nset_bit(FF_RAMP, dev->ffbit);\r\nif (pidff->type_id[PID_SQUARE]) {\r\nset_bit(FF_SQUARE, dev->ffbit);\r\nset_bit(FF_PERIODIC, dev->ffbit);\r\n}\r\nif (pidff->type_id[PID_SINE]) {\r\nset_bit(FF_SINE, dev->ffbit);\r\nset_bit(FF_PERIODIC, dev->ffbit);\r\n}\r\nif (pidff->type_id[PID_TRIANGLE]) {\r\nset_bit(FF_TRIANGLE, dev->ffbit);\r\nset_bit(FF_PERIODIC, dev->ffbit);\r\n}\r\nif (pidff->type_id[PID_SAW_UP]) {\r\nset_bit(FF_SAW_UP, dev->ffbit);\r\nset_bit(FF_PERIODIC, dev->ffbit);\r\n}\r\nif (pidff->type_id[PID_SAW_DOWN]) {\r\nset_bit(FF_SAW_DOWN, dev->ffbit);\r\nset_bit(FF_PERIODIC, dev->ffbit);\r\n}\r\nif (pidff->type_id[PID_SPRING])\r\nset_bit(FF_SPRING, dev->ffbit);\r\nif (pidff->type_id[PID_DAMPER])\r\nset_bit(FF_DAMPER, dev->ffbit);\r\nif (pidff->type_id[PID_INERTIA])\r\nset_bit(FF_INERTIA, dev->ffbit);\r\nif (pidff->type_id[PID_FRICTION])\r\nset_bit(FF_FRICTION, dev->ffbit);\r\nreturn 0;\r\n}\r\nstatic int pidff_init_fields(struct pidff_device *pidff, struct input_dev *dev)\r\n{\r\nint envelope_ok = 0;\r\nif (PIDFF_FIND_FIELDS(set_effect, PID_SET_EFFECT, 1)) {\r\nhid_err(pidff->hid, "unknown set_effect report layout\n");\r\nreturn -ENODEV;\r\n}\r\nPIDFF_FIND_FIELDS(block_load, PID_BLOCK_LOAD, 0);\r\nif (!pidff->block_load[PID_EFFECT_BLOCK_INDEX].value) {\r\nhid_err(pidff->hid, "unknown pid_block_load report layout\n");\r\nreturn -ENODEV;\r\n}\r\nif (PIDFF_FIND_FIELDS(effect_operation, PID_EFFECT_OPERATION, 1)) {\r\nhid_err(pidff->hid, "unknown effect_operation report layout\n");\r\nreturn -ENODEV;\r\n}\r\nif (PIDFF_FIND_FIELDS(block_free, PID_BLOCK_FREE, 1)) {\r\nhid_err(pidff->hid, "unknown pid_block_free report layout\n");\r\nreturn -ENODEV;\r\n}\r\nif (!PIDFF_FIND_FIELDS(set_envelope, PID_SET_ENVELOPE, 1))\r\nenvelope_ok = 1;\r\nif (pidff_find_special_fields(pidff) || pidff_find_effects(pidff, dev))\r\nreturn -ENODEV;\r\nif (!envelope_ok) {\r\nif (test_and_clear_bit(FF_CONSTANT, dev->ffbit))\r\nhid_warn(pidff->hid,\r\n"has constant effect but no envelope\n");\r\nif (test_and_clear_bit(FF_RAMP, dev->ffbit))\r\nhid_warn(pidff->hid,\r\n"has ramp effect but no envelope\n");\r\nif (test_and_clear_bit(FF_PERIODIC, dev->ffbit))\r\nhid_warn(pidff->hid,\r\n"has periodic effect but no envelope\n");\r\n}\r\nif (test_bit(FF_CONSTANT, dev->ffbit) &&\r\nPIDFF_FIND_FIELDS(set_constant, PID_SET_CONSTANT, 1)) {\r\nhid_warn(pidff->hid, "unknown constant effect layout\n");\r\nclear_bit(FF_CONSTANT, dev->ffbit);\r\n}\r\nif (test_bit(FF_RAMP, dev->ffbit) &&\r\nPIDFF_FIND_FIELDS(set_ramp, PID_SET_RAMP, 1)) {\r\nhid_warn(pidff->hid, "unknown ramp effect layout\n");\r\nclear_bit(FF_RAMP, dev->ffbit);\r\n}\r\nif ((test_bit(FF_SPRING, dev->ffbit) ||\r\ntest_bit(FF_DAMPER, dev->ffbit) ||\r\ntest_bit(FF_FRICTION, dev->ffbit) ||\r\ntest_bit(FF_INERTIA, dev->ffbit)) &&\r\nPIDFF_FIND_FIELDS(set_condition, PID_SET_CONDITION, 1)) {\r\nhid_warn(pidff->hid, "unknown condition effect layout\n");\r\nclear_bit(FF_SPRING, dev->ffbit);\r\nclear_bit(FF_DAMPER, dev->ffbit);\r\nclear_bit(FF_FRICTION, dev->ffbit);\r\nclear_bit(FF_INERTIA, dev->ffbit);\r\n}\r\nif (test_bit(FF_PERIODIC, dev->ffbit) &&\r\nPIDFF_FIND_FIELDS(set_periodic, PID_SET_PERIODIC, 1)) {\r\nhid_warn(pidff->hid, "unknown periodic effect layout\n");\r\nclear_bit(FF_PERIODIC, dev->ffbit);\r\n}\r\nPIDFF_FIND_FIELDS(pool, PID_POOL, 0);\r\nif (!PIDFF_FIND_FIELDS(device_gain, PID_DEVICE_GAIN, 1))\r\nset_bit(FF_GAIN, dev->ffbit);\r\nreturn 0;\r\n}\r\nstatic void pidff_reset(struct pidff_device *pidff)\r\n{\r\nstruct hid_device *hid = pidff->hid;\r\nint i = 0;\r\npidff->device_control->value[0] = pidff->control_id[PID_RESET];\r\nusbhid_submit_report(hid, pidff->reports[PID_DEVICE_CONTROL], USB_DIR_OUT);\r\nusbhid_wait_io(hid);\r\nusbhid_submit_report(hid, pidff->reports[PID_DEVICE_CONTROL], USB_DIR_OUT);\r\nusbhid_wait_io(hid);\r\npidff->device_control->value[0] =\r\npidff->control_id[PID_ENABLE_ACTUATORS];\r\nusbhid_submit_report(hid, pidff->reports[PID_DEVICE_CONTROL], USB_DIR_OUT);\r\nusbhid_wait_io(hid);\r\nusbhid_submit_report(hid, pidff->reports[PID_POOL], USB_DIR_IN);\r\nusbhid_wait_io(hid);\r\nif (pidff->pool[PID_SIMULTANEOUS_MAX].value) {\r\nwhile (pidff->pool[PID_SIMULTANEOUS_MAX].value[0] < 2) {\r\nif (i++ > 20) {\r\nhid_warn(pidff->hid,\r\n"device reports %d simultaneous effects\n",\r\npidff->pool[PID_SIMULTANEOUS_MAX].value[0]);\r\nbreak;\r\n}\r\nhid_dbg(pidff->hid, "pid_pool requested again\n");\r\nusbhid_submit_report(hid, pidff->reports[PID_POOL],\r\nUSB_DIR_IN);\r\nusbhid_wait_io(hid);\r\n}\r\n}\r\n}\r\nstatic int pidff_check_autocenter(struct pidff_device *pidff,\r\nstruct input_dev *dev)\r\n{\r\nint error;\r\nerror = pidff_request_effect_upload(pidff, 1);\r\nif (error) {\r\nhid_err(pidff->hid, "upload request failed\n");\r\nreturn error;\r\n}\r\nif (pidff->block_load[PID_EFFECT_BLOCK_INDEX].value[0] ==\r\npidff->block_load[PID_EFFECT_BLOCK_INDEX].field->logical_minimum + 1) {\r\npidff_autocenter(pidff, 0xffff);\r\nset_bit(FF_AUTOCENTER, dev->ffbit);\r\n} else {\r\nhid_notice(pidff->hid,\r\n"device has unknown autocenter control method\n");\r\n}\r\npidff_erase_pid(pidff,\r\npidff->block_load[PID_EFFECT_BLOCK_INDEX].value[0]);\r\nreturn 0;\r\n}\r\nint hid_pidff_init(struct hid_device *hid)\r\n{\r\nstruct pidff_device *pidff;\r\nstruct hid_input *hidinput = list_entry(hid->inputs.next,\r\nstruct hid_input, list);\r\nstruct input_dev *dev = hidinput->input;\r\nstruct ff_device *ff;\r\nint max_effects;\r\nint error;\r\nhid_dbg(hid, "starting pid init\n");\r\nif (list_empty(&hid->report_enum[HID_OUTPUT_REPORT].report_list)) {\r\nhid_dbg(hid, "not a PID device, no output report\n");\r\nreturn -ENODEV;\r\n}\r\npidff = kzalloc(sizeof(*pidff), GFP_KERNEL);\r\nif (!pidff)\r\nreturn -ENOMEM;\r\npidff->hid = hid;\r\npidff_find_reports(hid, HID_OUTPUT_REPORT, pidff);\r\npidff_find_reports(hid, HID_FEATURE_REPORT, pidff);\r\nif (!pidff_reports_ok(pidff)) {\r\nhid_dbg(hid, "reports not ok, aborting\n");\r\nerror = -ENODEV;\r\ngoto fail;\r\n}\r\nerror = pidff_init_fields(pidff, dev);\r\nif (error)\r\ngoto fail;\r\npidff_reset(pidff);\r\nif (test_bit(FF_GAIN, dev->ffbit)) {\r\npidff_set(&pidff->device_gain[PID_DEVICE_GAIN_FIELD], 0xffff);\r\nusbhid_submit_report(hid, pidff->reports[PID_DEVICE_GAIN],\r\nUSB_DIR_OUT);\r\n}\r\nerror = pidff_check_autocenter(pidff, dev);\r\nif (error)\r\ngoto fail;\r\nmax_effects =\r\npidff->block_load[PID_EFFECT_BLOCK_INDEX].field->logical_maximum -\r\npidff->block_load[PID_EFFECT_BLOCK_INDEX].field->logical_minimum +\r\n1;\r\nhid_dbg(hid, "max effects is %d\n", max_effects);\r\nif (max_effects > PID_EFFECTS_MAX)\r\nmax_effects = PID_EFFECTS_MAX;\r\nif (pidff->pool[PID_SIMULTANEOUS_MAX].value)\r\nhid_dbg(hid, "max simultaneous effects is %d\n",\r\npidff->pool[PID_SIMULTANEOUS_MAX].value[0]);\r\nif (pidff->pool[PID_RAM_POOL_SIZE].value)\r\nhid_dbg(hid, "device memory size is %d bytes\n",\r\npidff->pool[PID_RAM_POOL_SIZE].value[0]);\r\nif (pidff->pool[PID_DEVICE_MANAGED_POOL].value &&\r\npidff->pool[PID_DEVICE_MANAGED_POOL].value[0] == 0) {\r\nhid_notice(hid,\r\n"device does not support device managed pool\n");\r\ngoto fail;\r\n}\r\nerror = input_ff_create(dev, max_effects);\r\nif (error)\r\ngoto fail;\r\nff = dev->ff;\r\nff->private = pidff;\r\nff->upload = pidff_upload_effect;\r\nff->erase = pidff_erase_effect;\r\nff->set_gain = pidff_set_gain;\r\nff->set_autocenter = pidff_set_autocenter;\r\nff->playback = pidff_playback;\r\nhid_info(dev, "Force feedback for USB HID PID devices by Anssi Hannula <anssi.hannula@gmail.com>\n");\r\nreturn 0;\r\nfail:\r\nkfree(pidff);\r\nreturn error;\r\n}
