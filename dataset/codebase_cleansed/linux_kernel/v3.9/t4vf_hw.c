int t4vf_wait_dev_ready(struct adapter *adapter)\r\n{\r\nconst u32 whoami = T4VF_PL_BASE_ADDR + PL_VF_WHOAMI;\r\nconst u32 notready1 = 0xffffffff;\r\nconst u32 notready2 = 0xeeeeeeee;\r\nu32 val;\r\nval = t4_read_reg(adapter, whoami);\r\nif (val != notready1 && val != notready2)\r\nreturn 0;\r\nmsleep(500);\r\nval = t4_read_reg(adapter, whoami);\r\nif (val != notready1 && val != notready2)\r\nreturn 0;\r\nelse\r\nreturn -EIO;\r\n}\r\nstatic void get_mbox_rpl(struct adapter *adapter, __be64 *rpl, int size,\r\nu32 mbox_data)\r\n{\r\nfor ( ; size; size -= 8, mbox_data += 8)\r\n*rpl++ = cpu_to_be64(t4_read_reg64(adapter, mbox_data));\r\n}\r\nstatic void dump_mbox(struct adapter *adapter, const char *tag, u32 mbox_data)\r\n{\r\ndev_err(adapter->pdev_dev,\r\n"mbox %s: %llx %llx %llx %llx %llx %llx %llx %llx\n", tag,\r\n(unsigned long long)t4_read_reg64(adapter, mbox_data + 0),\r\n(unsigned long long)t4_read_reg64(adapter, mbox_data + 8),\r\n(unsigned long long)t4_read_reg64(adapter, mbox_data + 16),\r\n(unsigned long long)t4_read_reg64(adapter, mbox_data + 24),\r\n(unsigned long long)t4_read_reg64(adapter, mbox_data + 32),\r\n(unsigned long long)t4_read_reg64(adapter, mbox_data + 40),\r\n(unsigned long long)t4_read_reg64(adapter, mbox_data + 48),\r\n(unsigned long long)t4_read_reg64(adapter, mbox_data + 56));\r\n}\r\nint t4vf_wr_mbox_core(struct adapter *adapter, const void *cmd, int size,\r\nvoid *rpl, bool sleep_ok)\r\n{\r\nstatic const int delay[] = {\r\n1, 1, 3, 5, 10, 10, 20, 50, 100\r\n};\r\nu32 v;\r\nint i, ms, delay_idx;\r\nconst __be64 *p;\r\nu32 mbox_data = T4VF_MBDATA_BASE_ADDR;\r\nu32 mbox_ctl = T4VF_CIM_BASE_ADDR + CIM_VF_EXT_MAILBOX_CTRL;\r\nif ((size % 16) != 0 ||\r\nsize > NUM_CIM_VF_MAILBOX_DATA_INSTANCES * 4)\r\nreturn -EINVAL;\r\nv = MBOWNER_GET(t4_read_reg(adapter, mbox_ctl));\r\nfor (i = 0; v == MBOX_OWNER_NONE && i < 3; i++)\r\nv = MBOWNER_GET(t4_read_reg(adapter, mbox_ctl));\r\nif (v != MBOX_OWNER_DRV)\r\nreturn v == MBOX_OWNER_FW ? -EBUSY : -ETIMEDOUT;\r\nfor (i = 0, p = cmd; i < size; i += 8)\r\nt4_write_reg64(adapter, mbox_data + i, be64_to_cpu(*p++));\r\nt4_read_reg(adapter, mbox_data);\r\nt4_write_reg(adapter, mbox_ctl,\r\nMBMSGVALID | MBOWNER(MBOX_OWNER_FW));\r\nt4_read_reg(adapter, mbox_ctl);\r\ndelay_idx = 0;\r\nms = delay[0];\r\nfor (i = 0; i < FW_CMD_MAX_TIMEOUT; i += ms) {\r\nif (sleep_ok) {\r\nms = delay[delay_idx];\r\nif (delay_idx < ARRAY_SIZE(delay) - 1)\r\ndelay_idx++;\r\nmsleep(ms);\r\n} else\r\nmdelay(ms);\r\nv = t4_read_reg(adapter, mbox_ctl);\r\nif (MBOWNER_GET(v) == MBOX_OWNER_DRV) {\r\nif ((v & MBMSGVALID) == 0) {\r\nt4_write_reg(adapter, mbox_ctl,\r\nMBOWNER(MBOX_OWNER_NONE));\r\ncontinue;\r\n}\r\nv = t4_read_reg(adapter, mbox_data);\r\nif (FW_CMD_RETVAL_GET(v))\r\ndump_mbox(adapter, "FW Error", mbox_data);\r\nif (rpl) {\r\nWARN_ON((be32_to_cpu(*(const u32 *)cmd)\r\n& FW_CMD_REQUEST) == 0);\r\nget_mbox_rpl(adapter, rpl, size, mbox_data);\r\nWARN_ON((be32_to_cpu(*(u32 *)rpl)\r\n& FW_CMD_REQUEST) != 0);\r\n}\r\nt4_write_reg(adapter, mbox_ctl,\r\nMBOWNER(MBOX_OWNER_NONE));\r\nreturn -FW_CMD_RETVAL_GET(v);\r\n}\r\n}\r\ndump_mbox(adapter, "FW Timeout", mbox_data);\r\nreturn -ETIMEDOUT;\r\n}\r\nstatic int hash_mac_addr(const u8 *addr)\r\n{\r\nu32 a = ((u32)addr[0] << 16) | ((u32)addr[1] << 8) | addr[2];\r\nu32 b = ((u32)addr[3] << 16) | ((u32)addr[4] << 8) | addr[5];\r\na ^= b;\r\na ^= (a >> 12);\r\na ^= (a >> 6);\r\nreturn a & 0x3f;\r\n}\r\nstatic void init_link_config(struct link_config *lc, unsigned int caps)\r\n{\r\nlc->supported = caps;\r\nlc->requested_speed = 0;\r\nlc->speed = 0;\r\nlc->requested_fc = lc->fc = PAUSE_RX | PAUSE_TX;\r\nif (lc->supported & SUPPORTED_Autoneg) {\r\nlc->advertising = lc->supported;\r\nlc->autoneg = AUTONEG_ENABLE;\r\nlc->requested_fc |= PAUSE_AUTONEG;\r\n} else {\r\nlc->advertising = 0;\r\nlc->autoneg = AUTONEG_DISABLE;\r\n}\r\n}\r\nint t4vf_port_init(struct adapter *adapter, int pidx)\r\n{\r\nstruct port_info *pi = adap2pinfo(adapter, pidx);\r\nstruct fw_vi_cmd vi_cmd, vi_rpl;\r\nstruct fw_port_cmd port_cmd, port_rpl;\r\nint v;\r\nu32 word;\r\nmemset(&vi_cmd, 0, sizeof(vi_cmd));\r\nvi_cmd.op_to_vfn = cpu_to_be32(FW_CMD_OP(FW_VI_CMD) |\r\nFW_CMD_REQUEST |\r\nFW_CMD_READ);\r\nvi_cmd.alloc_to_len16 = cpu_to_be32(FW_LEN16(vi_cmd));\r\nvi_cmd.type_viid = cpu_to_be16(FW_VI_CMD_VIID(pi->viid));\r\nv = t4vf_wr_mbox(adapter, &vi_cmd, sizeof(vi_cmd), &vi_rpl);\r\nif (v)\r\nreturn v;\r\nBUG_ON(pi->port_id != FW_VI_CMD_PORTID_GET(vi_rpl.portid_pkd));\r\npi->rss_size = FW_VI_CMD_RSSSIZE_GET(be16_to_cpu(vi_rpl.rsssize_pkd));\r\nt4_os_set_hw_addr(adapter, pidx, vi_rpl.mac);\r\nif (!(adapter->params.vfres.r_caps & FW_CMD_CAP_PORT))\r\nreturn 0;\r\nmemset(&port_cmd, 0, sizeof(port_cmd));\r\nport_cmd.op_to_portid = cpu_to_be32(FW_CMD_OP(FW_PORT_CMD) |\r\nFW_CMD_REQUEST |\r\nFW_CMD_READ |\r\nFW_PORT_CMD_PORTID(pi->port_id));\r\nport_cmd.action_to_len16 =\r\ncpu_to_be32(FW_PORT_CMD_ACTION(FW_PORT_ACTION_GET_PORT_INFO) |\r\nFW_LEN16(port_cmd));\r\nv = t4vf_wr_mbox(adapter, &port_cmd, sizeof(port_cmd), &port_rpl);\r\nif (v)\r\nreturn v;\r\nv = 0;\r\nword = be16_to_cpu(port_rpl.u.info.pcap);\r\nif (word & FW_PORT_CAP_SPEED_100M)\r\nv |= SUPPORTED_100baseT_Full;\r\nif (word & FW_PORT_CAP_SPEED_1G)\r\nv |= SUPPORTED_1000baseT_Full;\r\nif (word & FW_PORT_CAP_SPEED_10G)\r\nv |= SUPPORTED_10000baseT_Full;\r\nif (word & FW_PORT_CAP_ANEG)\r\nv |= SUPPORTED_Autoneg;\r\ninit_link_config(&pi->link_cfg, v);\r\nreturn 0;\r\n}\r\nint t4vf_fw_reset(struct adapter *adapter)\r\n{\r\nstruct fw_reset_cmd cmd;\r\nmemset(&cmd, 0, sizeof(cmd));\r\ncmd.op_to_write = cpu_to_be32(FW_CMD_OP(FW_RESET_CMD) |\r\nFW_CMD_WRITE);\r\ncmd.retval_len16 = cpu_to_be32(FW_LEN16(cmd));\r\nreturn t4vf_wr_mbox(adapter, &cmd, sizeof(cmd), NULL);\r\n}\r\nint t4vf_query_params(struct adapter *adapter, unsigned int nparams,\r\nconst u32 *params, u32 *vals)\r\n{\r\nint i, ret;\r\nstruct fw_params_cmd cmd, rpl;\r\nstruct fw_params_param *p;\r\nsize_t len16;\r\nif (nparams > 7)\r\nreturn -EINVAL;\r\nmemset(&cmd, 0, sizeof(cmd));\r\ncmd.op_to_vfn = cpu_to_be32(FW_CMD_OP(FW_PARAMS_CMD) |\r\nFW_CMD_REQUEST |\r\nFW_CMD_READ);\r\nlen16 = DIV_ROUND_UP(offsetof(struct fw_params_cmd,\r\nparam[nparams].mnem), 16);\r\ncmd.retval_len16 = cpu_to_be32(FW_CMD_LEN16(len16));\r\nfor (i = 0, p = &cmd.param[0]; i < nparams; i++, p++)\r\np->mnem = htonl(*params++);\r\nret = t4vf_wr_mbox(adapter, &cmd, sizeof(cmd), &rpl);\r\nif (ret == 0)\r\nfor (i = 0, p = &rpl.param[0]; i < nparams; i++, p++)\r\n*vals++ = be32_to_cpu(p->val);\r\nreturn ret;\r\n}\r\nint t4vf_set_params(struct adapter *adapter, unsigned int nparams,\r\nconst u32 *params, const u32 *vals)\r\n{\r\nint i;\r\nstruct fw_params_cmd cmd;\r\nstruct fw_params_param *p;\r\nsize_t len16;\r\nif (nparams > 7)\r\nreturn -EINVAL;\r\nmemset(&cmd, 0, sizeof(cmd));\r\ncmd.op_to_vfn = cpu_to_be32(FW_CMD_OP(FW_PARAMS_CMD) |\r\nFW_CMD_REQUEST |\r\nFW_CMD_WRITE);\r\nlen16 = DIV_ROUND_UP(offsetof(struct fw_params_cmd,\r\nparam[nparams]), 16);\r\ncmd.retval_len16 = cpu_to_be32(FW_CMD_LEN16(len16));\r\nfor (i = 0, p = &cmd.param[0]; i < nparams; i++, p++) {\r\np->mnem = cpu_to_be32(*params++);\r\np->val = cpu_to_be32(*vals++);\r\n}\r\nreturn t4vf_wr_mbox(adapter, &cmd, sizeof(cmd), NULL);\r\n}\r\nint t4vf_get_sge_params(struct adapter *adapter)\r\n{\r\nstruct sge_params *sge_params = &adapter->params.sge;\r\nu32 params[7], vals[7];\r\nint v;\r\nparams[0] = (FW_PARAMS_MNEM(FW_PARAMS_MNEM_REG) |\r\nFW_PARAMS_PARAM_XYZ(SGE_CONTROL));\r\nparams[1] = (FW_PARAMS_MNEM(FW_PARAMS_MNEM_REG) |\r\nFW_PARAMS_PARAM_XYZ(SGE_HOST_PAGE_SIZE));\r\nparams[2] = (FW_PARAMS_MNEM(FW_PARAMS_MNEM_REG) |\r\nFW_PARAMS_PARAM_XYZ(SGE_FL_BUFFER_SIZE0));\r\nparams[3] = (FW_PARAMS_MNEM(FW_PARAMS_MNEM_REG) |\r\nFW_PARAMS_PARAM_XYZ(SGE_FL_BUFFER_SIZE1));\r\nparams[4] = (FW_PARAMS_MNEM(FW_PARAMS_MNEM_REG) |\r\nFW_PARAMS_PARAM_XYZ(SGE_TIMER_VALUE_0_AND_1));\r\nparams[5] = (FW_PARAMS_MNEM(FW_PARAMS_MNEM_REG) |\r\nFW_PARAMS_PARAM_XYZ(SGE_TIMER_VALUE_2_AND_3));\r\nparams[6] = (FW_PARAMS_MNEM(FW_PARAMS_MNEM_REG) |\r\nFW_PARAMS_PARAM_XYZ(SGE_TIMER_VALUE_4_AND_5));\r\nv = t4vf_query_params(adapter, 7, params, vals);\r\nif (v)\r\nreturn v;\r\nsge_params->sge_control = vals[0];\r\nsge_params->sge_host_page_size = vals[1];\r\nsge_params->sge_fl_buffer_size[0] = vals[2];\r\nsge_params->sge_fl_buffer_size[1] = vals[3];\r\nsge_params->sge_timer_value_0_and_1 = vals[4];\r\nsge_params->sge_timer_value_2_and_3 = vals[5];\r\nsge_params->sge_timer_value_4_and_5 = vals[6];\r\nparams[0] = (FW_PARAMS_MNEM(FW_PARAMS_MNEM_REG) |\r\nFW_PARAMS_PARAM_XYZ(SGE_INGRESS_RX_THRESHOLD));\r\nv = t4vf_query_params(adapter, 1, params, vals);\r\nif (v)\r\nreturn v;\r\nsge_params->sge_ingress_rx_threshold = vals[0];\r\nreturn 0;\r\n}\r\nint t4vf_get_vpd_params(struct adapter *adapter)\r\n{\r\nstruct vpd_params *vpd_params = &adapter->params.vpd;\r\nu32 params[7], vals[7];\r\nint v;\r\nparams[0] = (FW_PARAMS_MNEM(FW_PARAMS_MNEM_DEV) |\r\nFW_PARAMS_PARAM_X(FW_PARAMS_PARAM_DEV_CCLK));\r\nv = t4vf_query_params(adapter, 1, params, vals);\r\nif (v)\r\nreturn v;\r\nvpd_params->cclk = vals[0];\r\nreturn 0;\r\n}\r\nint t4vf_get_dev_params(struct adapter *adapter)\r\n{\r\nstruct dev_params *dev_params = &adapter->params.dev;\r\nu32 params[7], vals[7];\r\nint v;\r\nparams[0] = (FW_PARAMS_MNEM(FW_PARAMS_MNEM_DEV) |\r\nFW_PARAMS_PARAM_X(FW_PARAMS_PARAM_DEV_FWREV));\r\nparams[1] = (FW_PARAMS_MNEM(FW_PARAMS_MNEM_DEV) |\r\nFW_PARAMS_PARAM_X(FW_PARAMS_PARAM_DEV_TPREV));\r\nv = t4vf_query_params(adapter, 2, params, vals);\r\nif (v)\r\nreturn v;\r\ndev_params->fwrev = vals[0];\r\ndev_params->tprev = vals[1];\r\nreturn 0;\r\n}\r\nint t4vf_get_rss_glb_config(struct adapter *adapter)\r\n{\r\nstruct rss_params *rss = &adapter->params.rss;\r\nstruct fw_rss_glb_config_cmd cmd, rpl;\r\nint v;\r\nmemset(&cmd, 0, sizeof(cmd));\r\ncmd.op_to_write = cpu_to_be32(FW_CMD_OP(FW_RSS_GLB_CONFIG_CMD) |\r\nFW_CMD_REQUEST |\r\nFW_CMD_READ);\r\ncmd.retval_len16 = cpu_to_be32(FW_LEN16(cmd));\r\nv = t4vf_wr_mbox(adapter, &cmd, sizeof(cmd), &rpl);\r\nif (v)\r\nreturn v;\r\nrss->mode = FW_RSS_GLB_CONFIG_CMD_MODE_GET(\r\nbe32_to_cpu(rpl.u.manual.mode_pkd));\r\nswitch (rss->mode) {\r\ncase FW_RSS_GLB_CONFIG_CMD_MODE_BASICVIRTUAL: {\r\nu32 word = be32_to_cpu(\r\nrpl.u.basicvirtual.synmapen_to_hashtoeplitz);\r\nrss->u.basicvirtual.synmapen =\r\n((word & FW_RSS_GLB_CONFIG_CMD_SYNMAPEN) != 0);\r\nrss->u.basicvirtual.syn4tupenipv6 =\r\n((word & FW_RSS_GLB_CONFIG_CMD_SYN4TUPENIPV6) != 0);\r\nrss->u.basicvirtual.syn2tupenipv6 =\r\n((word & FW_RSS_GLB_CONFIG_CMD_SYN2TUPENIPV6) != 0);\r\nrss->u.basicvirtual.syn4tupenipv4 =\r\n((word & FW_RSS_GLB_CONFIG_CMD_SYN4TUPENIPV4) != 0);\r\nrss->u.basicvirtual.syn2tupenipv4 =\r\n((word & FW_RSS_GLB_CONFIG_CMD_SYN2TUPENIPV4) != 0);\r\nrss->u.basicvirtual.ofdmapen =\r\n((word & FW_RSS_GLB_CONFIG_CMD_OFDMAPEN) != 0);\r\nrss->u.basicvirtual.tnlmapen =\r\n((word & FW_RSS_GLB_CONFIG_CMD_TNLMAPEN) != 0);\r\nrss->u.basicvirtual.tnlalllookup =\r\n((word & FW_RSS_GLB_CONFIG_CMD_TNLALLLKP) != 0);\r\nrss->u.basicvirtual.hashtoeplitz =\r\n((word & FW_RSS_GLB_CONFIG_CMD_HASHTOEPLITZ) != 0);\r\nif (!rss->u.basicvirtual.tnlmapen)\r\nreturn -EINVAL;\r\nbreak;\r\n}\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nint t4vf_get_vfres(struct adapter *adapter)\r\n{\r\nstruct vf_resources *vfres = &adapter->params.vfres;\r\nstruct fw_pfvf_cmd cmd, rpl;\r\nint v;\r\nu32 word;\r\nmemset(&cmd, 0, sizeof(cmd));\r\ncmd.op_to_vfn = cpu_to_be32(FW_CMD_OP(FW_PFVF_CMD) |\r\nFW_CMD_REQUEST |\r\nFW_CMD_READ);\r\ncmd.retval_len16 = cpu_to_be32(FW_LEN16(cmd));\r\nv = t4vf_wr_mbox(adapter, &cmd, sizeof(cmd), &rpl);\r\nif (v)\r\nreturn v;\r\nword = be32_to_cpu(rpl.niqflint_niq);\r\nvfres->niqflint = FW_PFVF_CMD_NIQFLINT_GET(word);\r\nvfres->niq = FW_PFVF_CMD_NIQ_GET(word);\r\nword = be32_to_cpu(rpl.type_to_neq);\r\nvfres->neq = FW_PFVF_CMD_NEQ_GET(word);\r\nvfres->pmask = FW_PFVF_CMD_PMASK_GET(word);\r\nword = be32_to_cpu(rpl.tc_to_nexactf);\r\nvfres->tc = FW_PFVF_CMD_TC_GET(word);\r\nvfres->nvi = FW_PFVF_CMD_NVI_GET(word);\r\nvfres->nexactf = FW_PFVF_CMD_NEXACTF_GET(word);\r\nword = be32_to_cpu(rpl.r_caps_to_nethctrl);\r\nvfres->r_caps = FW_PFVF_CMD_R_CAPS_GET(word);\r\nvfres->wx_caps = FW_PFVF_CMD_WX_CAPS_GET(word);\r\nvfres->nethctrl = FW_PFVF_CMD_NETHCTRL_GET(word);\r\nreturn 0;\r\n}\r\nint t4vf_read_rss_vi_config(struct adapter *adapter, unsigned int viid,\r\nunion rss_vi_config *config)\r\n{\r\nstruct fw_rss_vi_config_cmd cmd, rpl;\r\nint v;\r\nmemset(&cmd, 0, sizeof(cmd));\r\ncmd.op_to_viid = cpu_to_be32(FW_CMD_OP(FW_RSS_VI_CONFIG_CMD) |\r\nFW_CMD_REQUEST |\r\nFW_CMD_READ |\r\nFW_RSS_VI_CONFIG_CMD_VIID(viid));\r\ncmd.retval_len16 = cpu_to_be32(FW_LEN16(cmd));\r\nv = t4vf_wr_mbox(adapter, &cmd, sizeof(cmd), &rpl);\r\nif (v)\r\nreturn v;\r\nswitch (adapter->params.rss.mode) {\r\ncase FW_RSS_GLB_CONFIG_CMD_MODE_BASICVIRTUAL: {\r\nu32 word = be32_to_cpu(rpl.u.basicvirtual.defaultq_to_udpen);\r\nconfig->basicvirtual.ip6fourtupen =\r\n((word & FW_RSS_VI_CONFIG_CMD_IP6FOURTUPEN) != 0);\r\nconfig->basicvirtual.ip6twotupen =\r\n((word & FW_RSS_VI_CONFIG_CMD_IP6TWOTUPEN) != 0);\r\nconfig->basicvirtual.ip4fourtupen =\r\n((word & FW_RSS_VI_CONFIG_CMD_IP4FOURTUPEN) != 0);\r\nconfig->basicvirtual.ip4twotupen =\r\n((word & FW_RSS_VI_CONFIG_CMD_IP4TWOTUPEN) != 0);\r\nconfig->basicvirtual.udpen =\r\n((word & FW_RSS_VI_CONFIG_CMD_UDPEN) != 0);\r\nconfig->basicvirtual.defaultq =\r\nFW_RSS_VI_CONFIG_CMD_DEFAULTQ_GET(word);\r\nbreak;\r\n}\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nint t4vf_write_rss_vi_config(struct adapter *adapter, unsigned int viid,\r\nunion rss_vi_config *config)\r\n{\r\nstruct fw_rss_vi_config_cmd cmd, rpl;\r\nmemset(&cmd, 0, sizeof(cmd));\r\ncmd.op_to_viid = cpu_to_be32(FW_CMD_OP(FW_RSS_VI_CONFIG_CMD) |\r\nFW_CMD_REQUEST |\r\nFW_CMD_WRITE |\r\nFW_RSS_VI_CONFIG_CMD_VIID(viid));\r\ncmd.retval_len16 = cpu_to_be32(FW_LEN16(cmd));\r\nswitch (adapter->params.rss.mode) {\r\ncase FW_RSS_GLB_CONFIG_CMD_MODE_BASICVIRTUAL: {\r\nu32 word = 0;\r\nif (config->basicvirtual.ip6fourtupen)\r\nword |= FW_RSS_VI_CONFIG_CMD_IP6FOURTUPEN;\r\nif (config->basicvirtual.ip6twotupen)\r\nword |= FW_RSS_VI_CONFIG_CMD_IP6TWOTUPEN;\r\nif (config->basicvirtual.ip4fourtupen)\r\nword |= FW_RSS_VI_CONFIG_CMD_IP4FOURTUPEN;\r\nif (config->basicvirtual.ip4twotupen)\r\nword |= FW_RSS_VI_CONFIG_CMD_IP4TWOTUPEN;\r\nif (config->basicvirtual.udpen)\r\nword |= FW_RSS_VI_CONFIG_CMD_UDPEN;\r\nword |= FW_RSS_VI_CONFIG_CMD_DEFAULTQ(\r\nconfig->basicvirtual.defaultq);\r\ncmd.u.basicvirtual.defaultq_to_udpen = cpu_to_be32(word);\r\nbreak;\r\n}\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn t4vf_wr_mbox(adapter, &cmd, sizeof(cmd), &rpl);\r\n}\r\nint t4vf_config_rss_range(struct adapter *adapter, unsigned int viid,\r\nint start, int n, const u16 *rspq, int nrspq)\r\n{\r\nconst u16 *rsp = rspq;\r\nconst u16 *rsp_end = rspq+nrspq;\r\nstruct fw_rss_ind_tbl_cmd cmd;\r\nmemset(&cmd, 0, sizeof(cmd));\r\ncmd.op_to_viid = cpu_to_be32(FW_CMD_OP(FW_RSS_IND_TBL_CMD) |\r\nFW_CMD_REQUEST |\r\nFW_CMD_WRITE |\r\nFW_RSS_IND_TBL_CMD_VIID(viid));\r\ncmd.retval_len16 = cpu_to_be32(FW_LEN16(cmd));\r\nwhile (n > 0) {\r\n__be32 *qp = &cmd.iq0_to_iq2;\r\nint nq = min(n, 32);\r\nint ret;\r\ncmd.niqid = cpu_to_be16(nq);\r\ncmd.startidx = cpu_to_be16(start);\r\nstart += nq;\r\nn -= nq;\r\nwhile (nq > 0) {\r\nu16 qbuf[3];\r\nu16 *qbp = qbuf;\r\nint nqbuf = min(3, nq);\r\nnq -= nqbuf;\r\nqbuf[0] = qbuf[1] = qbuf[2] = 0;\r\nwhile (nqbuf) {\r\nnqbuf--;\r\n*qbp++ = *rsp++;\r\nif (rsp >= rsp_end)\r\nrsp = rspq;\r\n}\r\n*qp++ = cpu_to_be32(FW_RSS_IND_TBL_CMD_IQ0(qbuf[0]) |\r\nFW_RSS_IND_TBL_CMD_IQ1(qbuf[1]) |\r\nFW_RSS_IND_TBL_CMD_IQ2(qbuf[2]));\r\n}\r\nret = t4vf_wr_mbox(adapter, &cmd, sizeof(cmd), NULL);\r\nif (ret)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nint t4vf_alloc_vi(struct adapter *adapter, int port_id)\r\n{\r\nstruct fw_vi_cmd cmd, rpl;\r\nint v;\r\nmemset(&cmd, 0, sizeof(cmd));\r\ncmd.op_to_vfn = cpu_to_be32(FW_CMD_OP(FW_VI_CMD) |\r\nFW_CMD_REQUEST |\r\nFW_CMD_WRITE |\r\nFW_CMD_EXEC);\r\ncmd.alloc_to_len16 = cpu_to_be32(FW_LEN16(cmd) |\r\nFW_VI_CMD_ALLOC);\r\ncmd.portid_pkd = FW_VI_CMD_PORTID(port_id);\r\nv = t4vf_wr_mbox(adapter, &cmd, sizeof(cmd), &rpl);\r\nif (v)\r\nreturn v;\r\nreturn FW_VI_CMD_VIID_GET(be16_to_cpu(rpl.type_viid));\r\n}\r\nint t4vf_free_vi(struct adapter *adapter, int viid)\r\n{\r\nstruct fw_vi_cmd cmd;\r\nmemset(&cmd, 0, sizeof(cmd));\r\ncmd.op_to_vfn = cpu_to_be32(FW_CMD_OP(FW_VI_CMD) |\r\nFW_CMD_REQUEST |\r\nFW_CMD_EXEC);\r\ncmd.alloc_to_len16 = cpu_to_be32(FW_LEN16(cmd) |\r\nFW_VI_CMD_FREE);\r\ncmd.type_viid = cpu_to_be16(FW_VI_CMD_VIID(viid));\r\nreturn t4vf_wr_mbox(adapter, &cmd, sizeof(cmd), NULL);\r\n}\r\nint t4vf_enable_vi(struct adapter *adapter, unsigned int viid,\r\nbool rx_en, bool tx_en)\r\n{\r\nstruct fw_vi_enable_cmd cmd;\r\nmemset(&cmd, 0, sizeof(cmd));\r\ncmd.op_to_viid = cpu_to_be32(FW_CMD_OP(FW_VI_ENABLE_CMD) |\r\nFW_CMD_REQUEST |\r\nFW_CMD_EXEC |\r\nFW_VI_ENABLE_CMD_VIID(viid));\r\ncmd.ien_to_len16 = cpu_to_be32(FW_VI_ENABLE_CMD_IEN(rx_en) |\r\nFW_VI_ENABLE_CMD_EEN(tx_en) |\r\nFW_LEN16(cmd));\r\nreturn t4vf_wr_mbox(adapter, &cmd, sizeof(cmd), NULL);\r\n}\r\nint t4vf_identify_port(struct adapter *adapter, unsigned int viid,\r\nunsigned int nblinks)\r\n{\r\nstruct fw_vi_enable_cmd cmd;\r\nmemset(&cmd, 0, sizeof(cmd));\r\ncmd.op_to_viid = cpu_to_be32(FW_CMD_OP(FW_VI_ENABLE_CMD) |\r\nFW_CMD_REQUEST |\r\nFW_CMD_EXEC |\r\nFW_VI_ENABLE_CMD_VIID(viid));\r\ncmd.ien_to_len16 = cpu_to_be32(FW_VI_ENABLE_CMD_LED |\r\nFW_LEN16(cmd));\r\ncmd.blinkdur = cpu_to_be16(nblinks);\r\nreturn t4vf_wr_mbox(adapter, &cmd, sizeof(cmd), NULL);\r\n}\r\nint t4vf_set_rxmode(struct adapter *adapter, unsigned int viid,\r\nint mtu, int promisc, int all_multi, int bcast, int vlanex,\r\nbool sleep_ok)\r\n{\r\nstruct fw_vi_rxmode_cmd cmd;\r\nif (mtu < 0)\r\nmtu = FW_VI_RXMODE_CMD_MTU_MASK;\r\nif (promisc < 0)\r\npromisc = FW_VI_RXMODE_CMD_PROMISCEN_MASK;\r\nif (all_multi < 0)\r\nall_multi = FW_VI_RXMODE_CMD_ALLMULTIEN_MASK;\r\nif (bcast < 0)\r\nbcast = FW_VI_RXMODE_CMD_BROADCASTEN_MASK;\r\nif (vlanex < 0)\r\nvlanex = FW_VI_RXMODE_CMD_VLANEXEN_MASK;\r\nmemset(&cmd, 0, sizeof(cmd));\r\ncmd.op_to_viid = cpu_to_be32(FW_CMD_OP(FW_VI_RXMODE_CMD) |\r\nFW_CMD_REQUEST |\r\nFW_CMD_WRITE |\r\nFW_VI_RXMODE_CMD_VIID(viid));\r\ncmd.retval_len16 = cpu_to_be32(FW_LEN16(cmd));\r\ncmd.mtu_to_vlanexen =\r\ncpu_to_be32(FW_VI_RXMODE_CMD_MTU(mtu) |\r\nFW_VI_RXMODE_CMD_PROMISCEN(promisc) |\r\nFW_VI_RXMODE_CMD_ALLMULTIEN(all_multi) |\r\nFW_VI_RXMODE_CMD_BROADCASTEN(bcast) |\r\nFW_VI_RXMODE_CMD_VLANEXEN(vlanex));\r\nreturn t4vf_wr_mbox_core(adapter, &cmd, sizeof(cmd), NULL, sleep_ok);\r\n}\r\nint t4vf_alloc_mac_filt(struct adapter *adapter, unsigned int viid, bool free,\r\nunsigned int naddr, const u8 **addr, u16 *idx,\r\nu64 *hash, bool sleep_ok)\r\n{\r\nint offset, ret = 0;\r\nunsigned nfilters = 0;\r\nunsigned int rem = naddr;\r\nstruct fw_vi_mac_cmd cmd, rpl;\r\nif (naddr > FW_CLS_TCAM_NUM_ENTRIES)\r\nreturn -EINVAL;\r\nfor (offset = 0; offset < naddr; ) {\r\nunsigned int fw_naddr = (rem < ARRAY_SIZE(cmd.u.exact)\r\n? rem\r\n: ARRAY_SIZE(cmd.u.exact));\r\nsize_t len16 = DIV_ROUND_UP(offsetof(struct fw_vi_mac_cmd,\r\nu.exact[fw_naddr]), 16);\r\nstruct fw_vi_mac_exact *p;\r\nint i;\r\nmemset(&cmd, 0, sizeof(cmd));\r\ncmd.op_to_viid = cpu_to_be32(FW_CMD_OP(FW_VI_MAC_CMD) |\r\nFW_CMD_REQUEST |\r\nFW_CMD_WRITE |\r\n(free ? FW_CMD_EXEC : 0) |\r\nFW_VI_MAC_CMD_VIID(viid));\r\ncmd.freemacs_to_len16 =\r\ncpu_to_be32(FW_VI_MAC_CMD_FREEMACS(free) |\r\nFW_CMD_LEN16(len16));\r\nfor (i = 0, p = cmd.u.exact; i < fw_naddr; i++, p++) {\r\np->valid_to_idx = cpu_to_be16(\r\nFW_VI_MAC_CMD_VALID |\r\nFW_VI_MAC_CMD_IDX(FW_VI_MAC_ADD_MAC));\r\nmemcpy(p->macaddr, addr[offset+i], sizeof(p->macaddr));\r\n}\r\nret = t4vf_wr_mbox_core(adapter, &cmd, sizeof(cmd), &rpl,\r\nsleep_ok);\r\nif (ret && ret != -ENOMEM)\r\nbreak;\r\nfor (i = 0, p = rpl.u.exact; i < fw_naddr; i++, p++) {\r\nu16 index = FW_VI_MAC_CMD_IDX_GET(\r\nbe16_to_cpu(p->valid_to_idx));\r\nif (idx)\r\nidx[offset+i] =\r\n(index >= FW_CLS_TCAM_NUM_ENTRIES\r\n? 0xffff\r\n: index);\r\nif (index < FW_CLS_TCAM_NUM_ENTRIES)\r\nnfilters++;\r\nelse if (hash)\r\n*hash |= (1ULL << hash_mac_addr(addr[offset+i]));\r\n}\r\nfree = false;\r\noffset += fw_naddr;\r\nrem -= fw_naddr;\r\n}\r\nif (ret == 0 || ret == -ENOMEM)\r\nret = nfilters;\r\nreturn ret;\r\n}\r\nint t4vf_change_mac(struct adapter *adapter, unsigned int viid,\r\nint idx, const u8 *addr, bool persist)\r\n{\r\nint ret;\r\nstruct fw_vi_mac_cmd cmd, rpl;\r\nstruct fw_vi_mac_exact *p = &cmd.u.exact[0];\r\nsize_t len16 = DIV_ROUND_UP(offsetof(struct fw_vi_mac_cmd,\r\nu.exact[1]), 16);\r\nif (idx < 0)\r\nidx = persist ? FW_VI_MAC_ADD_PERSIST_MAC : FW_VI_MAC_ADD_MAC;\r\nmemset(&cmd, 0, sizeof(cmd));\r\ncmd.op_to_viid = cpu_to_be32(FW_CMD_OP(FW_VI_MAC_CMD) |\r\nFW_CMD_REQUEST |\r\nFW_CMD_WRITE |\r\nFW_VI_MAC_CMD_VIID(viid));\r\ncmd.freemacs_to_len16 = cpu_to_be32(FW_CMD_LEN16(len16));\r\np->valid_to_idx = cpu_to_be16(FW_VI_MAC_CMD_VALID |\r\nFW_VI_MAC_CMD_IDX(idx));\r\nmemcpy(p->macaddr, addr, sizeof(p->macaddr));\r\nret = t4vf_wr_mbox(adapter, &cmd, sizeof(cmd), &rpl);\r\nif (ret == 0) {\r\np = &rpl.u.exact[0];\r\nret = FW_VI_MAC_CMD_IDX_GET(be16_to_cpu(p->valid_to_idx));\r\nif (ret >= FW_CLS_TCAM_NUM_ENTRIES)\r\nret = -ENOMEM;\r\n}\r\nreturn ret;\r\n}\r\nint t4vf_set_addr_hash(struct adapter *adapter, unsigned int viid,\r\nbool ucast, u64 vec, bool sleep_ok)\r\n{\r\nstruct fw_vi_mac_cmd cmd;\r\nsize_t len16 = DIV_ROUND_UP(offsetof(struct fw_vi_mac_cmd,\r\nu.exact[0]), 16);\r\nmemset(&cmd, 0, sizeof(cmd));\r\ncmd.op_to_viid = cpu_to_be32(FW_CMD_OP(FW_VI_MAC_CMD) |\r\nFW_CMD_REQUEST |\r\nFW_CMD_WRITE |\r\nFW_VI_ENABLE_CMD_VIID(viid));\r\ncmd.freemacs_to_len16 = cpu_to_be32(FW_VI_MAC_CMD_HASHVECEN |\r\nFW_VI_MAC_CMD_HASHUNIEN(ucast) |\r\nFW_CMD_LEN16(len16));\r\ncmd.u.hash.hashvec = cpu_to_be64(vec);\r\nreturn t4vf_wr_mbox_core(adapter, &cmd, sizeof(cmd), NULL, sleep_ok);\r\n}\r\nint t4vf_get_port_stats(struct adapter *adapter, int pidx,\r\nstruct t4vf_port_stats *s)\r\n{\r\nstruct port_info *pi = adap2pinfo(adapter, pidx);\r\nstruct fw_vi_stats_vf fwstats;\r\nunsigned int rem = VI_VF_NUM_STATS;\r\n__be64 *fwsp = (__be64 *)&fwstats;\r\nwhile (rem) {\r\nunsigned int ix = VI_VF_NUM_STATS - rem;\r\nunsigned int nstats = min(6U, rem);\r\nstruct fw_vi_stats_cmd cmd, rpl;\r\nsize_t len = (offsetof(struct fw_vi_stats_cmd, u) +\r\nsizeof(struct fw_vi_stats_ctl));\r\nsize_t len16 = DIV_ROUND_UP(len, 16);\r\nint ret;\r\nmemset(&cmd, 0, sizeof(cmd));\r\ncmd.op_to_viid = cpu_to_be32(FW_CMD_OP(FW_VI_STATS_CMD) |\r\nFW_VI_STATS_CMD_VIID(pi->viid) |\r\nFW_CMD_REQUEST |\r\nFW_CMD_READ);\r\ncmd.retval_len16 = cpu_to_be32(FW_CMD_LEN16(len16));\r\ncmd.u.ctl.nstats_ix =\r\ncpu_to_be16(FW_VI_STATS_CMD_IX(ix) |\r\nFW_VI_STATS_CMD_NSTATS(nstats));\r\nret = t4vf_wr_mbox_ns(adapter, &cmd, len, &rpl);\r\nif (ret)\r\nreturn ret;\r\nmemcpy(fwsp, &rpl.u.ctl.stat0, sizeof(__be64) * nstats);\r\nrem -= nstats;\r\nfwsp += nstats;\r\n}\r\ns->tx_bcast_bytes = be64_to_cpu(fwstats.tx_bcast_bytes);\r\ns->tx_bcast_frames = be64_to_cpu(fwstats.tx_bcast_frames);\r\ns->tx_mcast_bytes = be64_to_cpu(fwstats.tx_mcast_bytes);\r\ns->tx_mcast_frames = be64_to_cpu(fwstats.tx_mcast_frames);\r\ns->tx_ucast_bytes = be64_to_cpu(fwstats.tx_ucast_bytes);\r\ns->tx_ucast_frames = be64_to_cpu(fwstats.tx_ucast_frames);\r\ns->tx_drop_frames = be64_to_cpu(fwstats.tx_drop_frames);\r\ns->tx_offload_bytes = be64_to_cpu(fwstats.tx_offload_bytes);\r\ns->tx_offload_frames = be64_to_cpu(fwstats.tx_offload_frames);\r\ns->rx_bcast_bytes = be64_to_cpu(fwstats.rx_bcast_bytes);\r\ns->rx_bcast_frames = be64_to_cpu(fwstats.rx_bcast_frames);\r\ns->rx_mcast_bytes = be64_to_cpu(fwstats.rx_mcast_bytes);\r\ns->rx_mcast_frames = be64_to_cpu(fwstats.rx_mcast_frames);\r\ns->rx_ucast_bytes = be64_to_cpu(fwstats.rx_ucast_bytes);\r\ns->rx_ucast_frames = be64_to_cpu(fwstats.rx_ucast_frames);\r\ns->rx_err_frames = be64_to_cpu(fwstats.rx_err_frames);\r\nreturn 0;\r\n}\r\nint t4vf_iq_free(struct adapter *adapter, unsigned int iqtype,\r\nunsigned int iqid, unsigned int fl0id, unsigned int fl1id)\r\n{\r\nstruct fw_iq_cmd cmd;\r\nmemset(&cmd, 0, sizeof(cmd));\r\ncmd.op_to_vfn = cpu_to_be32(FW_CMD_OP(FW_IQ_CMD) |\r\nFW_CMD_REQUEST |\r\nFW_CMD_EXEC);\r\ncmd.alloc_to_len16 = cpu_to_be32(FW_IQ_CMD_FREE |\r\nFW_LEN16(cmd));\r\ncmd.type_to_iqandstindex =\r\ncpu_to_be32(FW_IQ_CMD_TYPE(iqtype));\r\ncmd.iqid = cpu_to_be16(iqid);\r\ncmd.fl0id = cpu_to_be16(fl0id);\r\ncmd.fl1id = cpu_to_be16(fl1id);\r\nreturn t4vf_wr_mbox(adapter, &cmd, sizeof(cmd), NULL);\r\n}\r\nint t4vf_eth_eq_free(struct adapter *adapter, unsigned int eqid)\r\n{\r\nstruct fw_eq_eth_cmd cmd;\r\nmemset(&cmd, 0, sizeof(cmd));\r\ncmd.op_to_vfn = cpu_to_be32(FW_CMD_OP(FW_EQ_ETH_CMD) |\r\nFW_CMD_REQUEST |\r\nFW_CMD_EXEC);\r\ncmd.alloc_to_len16 = cpu_to_be32(FW_EQ_ETH_CMD_FREE |\r\nFW_LEN16(cmd));\r\ncmd.eqid_pkd = cpu_to_be32(FW_EQ_ETH_CMD_EQID(eqid));\r\nreturn t4vf_wr_mbox(adapter, &cmd, sizeof(cmd), NULL);\r\n}\r\nint t4vf_handle_fw_rpl(struct adapter *adapter, const __be64 *rpl)\r\n{\r\nconst struct fw_cmd_hdr *cmd_hdr = (const struct fw_cmd_hdr *)rpl;\r\nu8 opcode = FW_CMD_OP_GET(be32_to_cpu(cmd_hdr->hi));\r\nswitch (opcode) {\r\ncase FW_PORT_CMD: {\r\nconst struct fw_port_cmd *port_cmd =\r\n(const struct fw_port_cmd *)rpl;\r\nu32 word;\r\nint action, port_id, link_ok, speed, fc, pidx;\r\naction = FW_PORT_CMD_ACTION_GET(\r\nbe32_to_cpu(port_cmd->action_to_len16));\r\nif (action != FW_PORT_ACTION_GET_PORT_INFO) {\r\ndev_err(adapter->pdev_dev,\r\n"Unknown firmware PORT reply action %x\n",\r\naction);\r\nbreak;\r\n}\r\nport_id = FW_PORT_CMD_PORTID_GET(\r\nbe32_to_cpu(port_cmd->op_to_portid));\r\nword = be32_to_cpu(port_cmd->u.info.lstatus_to_modtype);\r\nlink_ok = (word & FW_PORT_CMD_LSTATUS) != 0;\r\nspeed = 0;\r\nfc = 0;\r\nif (word & FW_PORT_CMD_RXPAUSE)\r\nfc |= PAUSE_RX;\r\nif (word & FW_PORT_CMD_TXPAUSE)\r\nfc |= PAUSE_TX;\r\nif (word & FW_PORT_CMD_LSPEED(FW_PORT_CAP_SPEED_100M))\r\nspeed = SPEED_100;\r\nelse if (word & FW_PORT_CMD_LSPEED(FW_PORT_CAP_SPEED_1G))\r\nspeed = SPEED_1000;\r\nelse if (word & FW_PORT_CMD_LSPEED(FW_PORT_CAP_SPEED_10G))\r\nspeed = SPEED_10000;\r\nfor_each_port(adapter, pidx) {\r\nstruct port_info *pi = adap2pinfo(adapter, pidx);\r\nstruct link_config *lc;\r\nif (pi->port_id != port_id)\r\ncontinue;\r\nlc = &pi->link_cfg;\r\nif (link_ok != lc->link_ok || speed != lc->speed ||\r\nfc != lc->fc) {\r\nlc->link_ok = link_ok;\r\nlc->speed = speed;\r\nlc->fc = fc;\r\nt4vf_os_link_changed(adapter, pidx, link_ok);\r\n}\r\n}\r\nbreak;\r\n}\r\ndefault:\r\ndev_err(adapter->pdev_dev, "Unknown firmware reply %X\n",\r\nopcode);\r\n}\r\nreturn 0;\r\n}
