static inline short munge_sample(short data)\r\n{\r\nreturn (data >> 4) & 0xfff;\r\n}\r\nstatic void munge_sample_array(short *array, unsigned int num_elements)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < num_elements; i++)\r\narray[i] = munge_sample(array[i]);\r\n}\r\nstatic int das16m1_cmd_test(struct comedi_device *dev,\r\nstruct comedi_subdevice *s, struct comedi_cmd *cmd)\r\n{\r\nstruct das16m1_private_struct *devpriv = dev->private;\r\nunsigned int err = 0, tmp, i;\r\nerr |= cfc_check_trigger_src(&cmd->start_src, TRIG_NOW | TRIG_EXT);\r\nerr |= cfc_check_trigger_src(&cmd->scan_begin_src, TRIG_FOLLOW);\r\nerr |= cfc_check_trigger_src(&cmd->convert_src, TRIG_TIMER | TRIG_EXT);\r\nerr |= cfc_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);\r\nerr |= cfc_check_trigger_src(&cmd->stop_src, TRIG_COUNT | TRIG_NONE);\r\nif (err)\r\nreturn 1;\r\nerr |= cfc_check_trigger_is_unique(cmd->start_src);\r\nerr |= cfc_check_trigger_is_unique(cmd->convert_src);\r\nerr |= cfc_check_trigger_is_unique(cmd->stop_src);\r\nif (err)\r\nreturn 2;\r\nerr |= cfc_check_trigger_arg_is(&cmd->start_arg, 0);\r\nif (cmd->scan_begin_src == TRIG_FOLLOW)\r\nerr |= cfc_check_trigger_arg_is(&cmd->scan_begin_arg, 0);\r\nif (cmd->convert_src == TRIG_TIMER)\r\nerr |= cfc_check_trigger_arg_min(&cmd->convert_arg, 1000);\r\nerr |= cfc_check_trigger_arg_is(&cmd->scan_end_arg, cmd->chanlist_len);\r\nif (cmd->stop_src == TRIG_COUNT) {\r\n} else {\r\nerr |= cfc_check_trigger_arg_is(&cmd->stop_arg, 0);\r\n}\r\nif (err)\r\nreturn 3;\r\nif (cmd->convert_src == TRIG_TIMER) {\r\ntmp = cmd->convert_arg;\r\ni8253_cascade_ns_to_timer_2div(DAS16M1_XTAL,\r\n&(devpriv->divisor1),\r\n&(devpriv->divisor2),\r\n&(cmd->convert_arg),\r\ncmd->flags & TRIG_ROUND_MASK);\r\nif (tmp != cmd->convert_arg)\r\nerr++;\r\n}\r\nif (err)\r\nreturn 4;\r\nif (cmd->chanlist && cmd->chanlist_len > 1) {\r\nfor (i = 0; i < cmd->chanlist_len; i++) {\r\nif ((i % 2) != (CR_CHAN(cmd->chanlist[i]) % 2)) {\r\ncomedi_error(dev, "bad chanlist:\n"\r\n" even/odd channels must go have even/odd chanlist indices");\r\nerr++;\r\n}\r\n}\r\nif ((cmd->chanlist_len % 2) != 0) {\r\ncomedi_error(dev,\r\n"chanlist must be of even length or length 1");\r\nerr++;\r\n}\r\n}\r\nif (err)\r\nreturn 5;\r\nreturn 0;\r\n}\r\nstatic unsigned int das16m1_set_pacer(struct comedi_device *dev,\r\nunsigned int ns, int rounding_flags)\r\n{\r\nstruct das16m1_private_struct *devpriv = dev->private;\r\ni8253_cascade_ns_to_timer_2div(DAS16M1_XTAL, &(devpriv->divisor1),\r\n&(devpriv->divisor2), &ns,\r\nrounding_flags & TRIG_ROUND_MASK);\r\ni8254_load(dev->iobase + DAS16M1_8254_SECOND, 0, 1, devpriv->divisor1,\r\n2);\r\ni8254_load(dev->iobase + DAS16M1_8254_SECOND, 0, 2, devpriv->divisor2,\r\n2);\r\nreturn ns;\r\n}\r\nstatic int das16m1_cmd_exec(struct comedi_device *dev,\r\nstruct comedi_subdevice *s)\r\n{\r\nstruct das16m1_private_struct *devpriv = dev->private;\r\nstruct comedi_async *async = s->async;\r\nstruct comedi_cmd *cmd = &async->cmd;\r\nunsigned int byte, i;\r\nif (dev->irq == 0) {\r\ncomedi_error(dev, "irq required to execute comedi_cmd");\r\nreturn -1;\r\n}\r\ndevpriv->control_state &= ~INTE & ~PACER_MASK;\r\noutb(devpriv->control_state, dev->iobase + DAS16M1_INTR_CONTROL);\r\ndevpriv->adc_count = 0;\r\ni8254_load(dev->iobase + DAS16M1_8254_FIRST, 0, 1, 0, 2);\r\ndevpriv->initial_hw_count =\r\ni8254_read(dev->iobase + DAS16M1_8254_FIRST, 0, 1);\r\nfor (i = 0; i < cmd->chanlist_len; i++) {\r\noutb(i, dev->iobase + DAS16M1_QUEUE_ADDR);\r\nbyte =\r\nQ_CHAN(CR_CHAN(cmd->chanlist[i])) |\r\nQ_RANGE(CR_RANGE(cmd->chanlist[i]));\r\noutb(byte, dev->iobase + DAS16M1_QUEUE_DATA);\r\n}\r\ncmd->convert_arg =\r\ndas16m1_set_pacer(dev, cmd->convert_arg,\r\ncmd->flags & TRIG_ROUND_MASK);\r\nbyte = 0;\r\nif (cmd->start_src == TRIG_EXT && cmd->convert_src != TRIG_EXT)\r\nbyte |= EXT_TRIG_BIT;\r\noutb(byte, dev->iobase + DAS16M1_CS);\r\noutb(0, dev->iobase + DAS16M1_CLEAR_INTR);\r\ndevpriv->control_state &= ~PACER_MASK;\r\nif (cmd->convert_src == TRIG_TIMER)\r\ndevpriv->control_state |= INT_PACER;\r\nelse\r\ndevpriv->control_state |= EXT_PACER;\r\ndevpriv->control_state |= INTE;\r\noutb(devpriv->control_state, dev->iobase + DAS16M1_INTR_CONTROL);\r\nreturn 0;\r\n}\r\nstatic int das16m1_cancel(struct comedi_device *dev, struct comedi_subdevice *s)\r\n{\r\nstruct das16m1_private_struct *devpriv = dev->private;\r\ndevpriv->control_state &= ~INTE & ~PACER_MASK;\r\noutb(devpriv->control_state, dev->iobase + DAS16M1_INTR_CONTROL);\r\nreturn 0;\r\n}\r\nstatic int das16m1_ai_rinsn(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nstruct das16m1_private_struct *devpriv = dev->private;\r\nint i, n;\r\nint byte;\r\nconst int timeout = 1000;\r\ndevpriv->control_state &= ~INTE & ~PACER_MASK;\r\noutb(devpriv->control_state, dev->iobase + DAS16M1_INTR_CONTROL);\r\noutb(0, dev->iobase + DAS16M1_QUEUE_ADDR);\r\nbyte =\r\nQ_CHAN(CR_CHAN(insn->chanspec)) | Q_RANGE(CR_RANGE(insn->chanspec));\r\noutb(byte, dev->iobase + DAS16M1_QUEUE_DATA);\r\nfor (n = 0; n < insn->n; n++) {\r\noutb(0, dev->iobase + DAS16M1_CLEAR_INTR);\r\noutb(0, dev->iobase);\r\nfor (i = 0; i < timeout; i++) {\r\nif (inb(dev->iobase + DAS16M1_CS) & IRQDATA)\r\nbreak;\r\n}\r\nif (i == timeout) {\r\ncomedi_error(dev, "timeout");\r\nreturn -ETIME;\r\n}\r\ndata[n] = munge_sample(inw(dev->iobase));\r\n}\r\nreturn n;\r\n}\r\nstatic int das16m1_di_rbits(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nunsigned int bits;\r\nbits = inb(dev->iobase + DAS16M1_DIO) & 0xf;\r\ndata[1] = bits;\r\ndata[0] = 0;\r\nreturn insn->n;\r\n}\r\nstatic int das16m1_do_wbits(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nstruct das16m1_private_struct *devpriv = dev->private;\r\nunsigned int wbits;\r\ndata[0] &= 0xf;\r\nwbits = devpriv->do_bits;\r\nwbits &= ~data[0];\r\nwbits |= data[0] & data[1];\r\ndevpriv->do_bits = wbits;\r\ndata[1] = wbits;\r\noutb(devpriv->do_bits, dev->iobase + DAS16M1_DIO);\r\nreturn insn->n;\r\n}\r\nstatic void das16m1_handler(struct comedi_device *dev, unsigned int status)\r\n{\r\nstruct das16m1_private_struct *devpriv = dev->private;\r\nstruct comedi_subdevice *s;\r\nstruct comedi_async *async;\r\nstruct comedi_cmd *cmd;\r\nu16 num_samples;\r\nu16 hw_counter;\r\ns = dev->read_subdev;\r\nasync = s->async;\r\nasync->events = 0;\r\ncmd = &async->cmd;\r\nhw_counter = i8254_read(dev->iobase + DAS16M1_8254_FIRST, 0, 1);\r\nif (devpriv->adc_count == 0 && hw_counter == devpriv->initial_hw_count) {\r\nnum_samples = 0;\r\n} else {\r\nnum_samples = -hw_counter - devpriv->adc_count;\r\n}\r\nif (cmd->stop_src == TRIG_COUNT) {\r\nif (num_samples > cmd->stop_arg * cmd->chanlist_len)\r\nnum_samples = cmd->stop_arg * cmd->chanlist_len;\r\n}\r\nif (num_samples > FIFO_SIZE)\r\nnum_samples = FIFO_SIZE;\r\ninsw(dev->iobase, devpriv->ai_buffer, num_samples);\r\nmunge_sample_array(devpriv->ai_buffer, num_samples);\r\ncfc_write_array_to_buffer(s, devpriv->ai_buffer,\r\nnum_samples * sizeof(short));\r\ndevpriv->adc_count += num_samples;\r\nif (cmd->stop_src == TRIG_COUNT) {\r\nif (devpriv->adc_count >= cmd->stop_arg * cmd->chanlist_len) {\r\ndas16m1_cancel(dev, s);\r\nasync->events |= COMEDI_CB_EOA;\r\n}\r\n}\r\nif (status & OVRUN) {\r\ndas16m1_cancel(dev, s);\r\nasync->events |= COMEDI_CB_EOA | COMEDI_CB_ERROR;\r\ncomedi_error(dev, "fifo overflow");\r\n}\r\ncomedi_event(dev, s);\r\n}\r\nstatic int das16m1_poll(struct comedi_device *dev, struct comedi_subdevice *s)\r\n{\r\nunsigned long flags;\r\nunsigned int status;\r\nspin_lock_irqsave(&dev->spinlock, flags);\r\nstatus = inb(dev->iobase + DAS16M1_CS);\r\ndas16m1_handler(dev, status);\r\nspin_unlock_irqrestore(&dev->spinlock, flags);\r\nreturn s->async->buf_write_count - s->async->buf_read_count;\r\n}\r\nstatic irqreturn_t das16m1_interrupt(int irq, void *d)\r\n{\r\nint status;\r\nstruct comedi_device *dev = d;\r\nif (dev->attached == 0) {\r\ncomedi_error(dev, "premature interrupt");\r\nreturn IRQ_HANDLED;\r\n}\r\nspin_lock(&dev->spinlock);\r\nstatus = inb(dev->iobase + DAS16M1_CS);\r\nif ((status & (IRQDATA | OVRUN)) == 0) {\r\ncomedi_error(dev, "spurious interrupt");\r\nspin_unlock(&dev->spinlock);\r\nreturn IRQ_NONE;\r\n}\r\ndas16m1_handler(dev, status);\r\noutb(0, dev->iobase + DAS16M1_CLEAR_INTR);\r\nspin_unlock(&dev->spinlock);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int das16m1_irq_bits(unsigned int irq)\r\n{\r\nint ret;\r\nswitch (irq) {\r\ncase 10:\r\nret = 0x0;\r\nbreak;\r\ncase 11:\r\nret = 0x1;\r\nbreak;\r\ncase 12:\r\nret = 0x2;\r\nbreak;\r\ncase 15:\r\nret = 0x3;\r\nbreak;\r\ncase 2:\r\nret = 0x4;\r\nbreak;\r\ncase 3:\r\nret = 0x5;\r\nbreak;\r\ncase 5:\r\nret = 0x6;\r\nbreak;\r\ncase 7:\r\nret = 0x7;\r\nbreak;\r\ndefault:\r\nreturn -1;\r\nbreak;\r\n}\r\nreturn ret << 4;\r\n}\r\nstatic int das16m1_attach(struct comedi_device *dev,\r\nstruct comedi_devconfig *it)\r\n{\r\nstruct das16m1_private_struct *devpriv;\r\nstruct comedi_subdevice *s;\r\nint ret;\r\nunsigned int irq;\r\nunsigned long iobase;\r\ndev->board_name = dev->driver->driver_name;\r\niobase = it->options[0];\r\ndevpriv = kzalloc(sizeof(*devpriv), GFP_KERNEL);\r\nif (!devpriv)\r\nreturn -ENOMEM;\r\ndev->private = devpriv;\r\nif (!request_region(iobase, DAS16M1_SIZE, dev->board_name)) {\r\ncomedi_error(dev, "I/O port conflict\n");\r\nreturn -EIO;\r\n}\r\nif (!request_region(iobase + DAS16M1_82C55, DAS16M1_SIZE2,\r\ndev->board_name)) {\r\nrelease_region(iobase, DAS16M1_SIZE);\r\ncomedi_error(dev, "I/O port conflict\n");\r\nreturn -EIO;\r\n}\r\ndev->iobase = iobase;\r\nirq = it->options[1];\r\nif (das16m1_irq_bits(irq) >= 0) {\r\nret = request_irq(irq, das16m1_interrupt, 0,\r\ndev->driver->driver_name, dev);\r\nif (ret < 0)\r\nreturn ret;\r\ndev->irq = irq;\r\nprintk\r\n("irq %u\n", irq);\r\n} else if (irq == 0) {\r\nprintk\r\n(", no irq\n");\r\n} else {\r\ncomedi_error(dev, "invalid irq\n"\r\n" valid irqs are 2, 3, 5, 7, 10, 11, 12, or 15\n");\r\nreturn -EINVAL;\r\n}\r\nret = comedi_alloc_subdevices(dev, 4);\r\nif (ret)\r\nreturn ret;\r\ns = &dev->subdevices[0];\r\ndev->read_subdev = s;\r\ns->type = COMEDI_SUBD_AI;\r\ns->subdev_flags = SDF_READABLE | SDF_CMD_READ;\r\ns->n_chan = 8;\r\ns->subdev_flags = SDF_DIFF;\r\ns->len_chanlist = 256;\r\ns->maxdata = (1 << 12) - 1;\r\ns->range_table = &range_das16m1;\r\ns->insn_read = das16m1_ai_rinsn;\r\ns->do_cmdtest = das16m1_cmd_test;\r\ns->do_cmd = das16m1_cmd_exec;\r\ns->cancel = das16m1_cancel;\r\ns->poll = das16m1_poll;\r\ns = &dev->subdevices[1];\r\ns->type = COMEDI_SUBD_DI;\r\ns->subdev_flags = SDF_READABLE;\r\ns->n_chan = 4;\r\ns->maxdata = 1;\r\ns->range_table = &range_digital;\r\ns->insn_bits = das16m1_di_rbits;\r\ns = &dev->subdevices[2];\r\ns->type = COMEDI_SUBD_DO;\r\ns->subdev_flags = SDF_WRITABLE | SDF_READABLE;\r\ns->n_chan = 4;\r\ns->maxdata = 1;\r\ns->range_table = &range_digital;\r\ns->insn_bits = das16m1_do_wbits;\r\ns = &dev->subdevices[3];\r\nsubdev_8255_init(dev, s, NULL, dev->iobase + DAS16M1_82C55);\r\noutb(TOTAL_CLEAR, dev->iobase + DAS16M1_8254_FIRST_CNTRL);\r\noutb(devpriv->do_bits, dev->iobase + DAS16M1_DIO);\r\nif (dev->irq)\r\ndevpriv->control_state = das16m1_irq_bits(dev->irq);\r\nelse\r\ndevpriv->control_state = 0;\r\noutb(devpriv->control_state, dev->iobase + DAS16M1_INTR_CONTROL);\r\nreturn 0;\r\n}\r\nstatic void das16m1_detach(struct comedi_device *dev)\r\n{\r\nif (dev->subdevices)\r\nsubdev_8255_cleanup(dev, &dev->subdevices[3]);\r\nif (dev->irq)\r\nfree_irq(dev->irq, dev);\r\nif (dev->iobase) {\r\nrelease_region(dev->iobase, DAS16M1_SIZE);\r\nrelease_region(dev->iobase + DAS16M1_82C55, DAS16M1_SIZE2);\r\n}\r\n}
