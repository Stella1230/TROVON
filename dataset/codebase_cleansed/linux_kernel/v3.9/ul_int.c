void\r\nul_init_clients(unifi_priv_t *priv)\r\n{\r\nint id;\r\nul_client_t *ul_clients;\r\nsema_init(&priv->udi_logging_mutex, 1);\r\npriv->logging_client = NULL;\r\nul_clients = priv->ul_clients;\r\nfor (id = 0; id < MAX_UDI_CLIENTS; id++) {\r\nmemset(&ul_clients[id], 0, sizeof(ul_client_t));\r\nul_clients[id].client_id = id;\r\nul_clients[id].sender_id = UDI_SENDER_ID_BASE + (id << UDI_SENDER_ID_SHIFT);\r\nul_clients[id].instance = -1;\r\nul_clients[id].event_hook = NULL;\r\nINIT_LIST_HEAD(&ul_clients[id].udi_log);\r\ninit_waitqueue_head(&ul_clients[id].udi_wq);\r\nsema_init(&ul_clients[id].udi_sem, 1);\r\nul_clients[id].wake_up_wq_id = 0;\r\nul_clients[id].seq_no = 0;\r\nul_clients[id].wake_seq_no = 0;\r\nul_clients[id].snap_filter.count = 0;\r\n}\r\n}\r\nul_client_t *\r\nul_register_client(unifi_priv_t *priv, unsigned int configuration,\r\nudi_event_t udi_event_clbk)\r\n{\r\nunsigned char id, ref;\r\nul_client_t *ul_clients;\r\nul_clients = priv->ul_clients;\r\nfor (id = 0; id < MAX_UDI_CLIENTS; id++) {\r\nif (ul_clients[id].udi_enabled == 0) {\r\nul_clients[id].instance = priv->instance;\r\nul_clients[id].udi_enabled = 1;\r\nul_clients[id].configuration = configuration;\r\nul_clients[id].reply_signal = kmalloc(sizeof(CSR_SIGNAL), GFP_KERNEL);\r\nif (ul_clients[id].reply_signal == NULL) {\r\nunifi_error(priv, "Failed to allocate reply signal for client.\n");\r\nreturn NULL;\r\n}\r\nfor (ref = 0; ref < UNIFI_MAX_DATA_REFERENCES; ref ++) {\r\nul_clients[id].reply_bulkdata[ref] = kmalloc(sizeof(bulk_data_t), GFP_KERNEL);\r\nif (ul_clients[id].reply_bulkdata[ref] == NULL) {\r\nfor (; ref > 0; ref --) {\r\nkfree(ul_clients[id].reply_bulkdata[ref - 1]);\r\n}\r\nkfree(ul_clients[id].reply_signal);\r\nunifi_error(priv, "Failed to allocate bulk data buffers for client.\n");\r\nreturn NULL;\r\n}\r\n}\r\nul_clients[id].event_hook = udi_event_clbk;\r\nunifi_trace(priv, UDBG2, "UDI %d (0x%x) registered. configuration = 0x%x\n",\r\nid, &ul_clients[id], configuration);\r\nreturn &ul_clients[id];\r\n}\r\n}\r\nreturn NULL;\r\n}\r\nint\r\nul_deregister_client(ul_client_t *ul_client)\r\n{\r\nstruct list_head *pos, *n;\r\nudi_log_t *logptr;\r\nunifi_priv_t *priv = uf_find_instance(ul_client->instance);\r\nint ref;\r\nul_client->instance = -1;\r\nul_client->event_hook = NULL;\r\nul_client->udi_enabled = 0;\r\nunifi_trace(priv, UDBG5, "UDI (0x%x) deregistered.\n", ul_client);\r\nkfree(ul_client->reply_signal);\r\nfor (ref = 0; ref < UNIFI_MAX_DATA_REFERENCES; ref ++) {\r\nkfree(ul_client->reply_bulkdata[ref]);\r\n}\r\nif (ul_client->snap_filter.count) {\r\nul_client->snap_filter.count = 0;\r\nkfree(ul_client->snap_filter.protocols);\r\n}\r\ndown(&ul_client->udi_sem);\r\nlist_for_each_safe(pos, n, &ul_client->udi_log)\r\n{\r\nlogptr = list_entry(pos, udi_log_t, q);\r\nlist_del(pos);\r\nkfree(logptr);\r\n}\r\nup(&ul_client->udi_sem);\r\nreturn 0;\r\n}\r\nvoid\r\nlogging_handler(void *ospriv,\r\nu8 *sigdata, u32 signal_len,\r\nconst bulk_data_param_t *bulkdata,\r\nenum udi_log_direction direction)\r\n{\r\nunifi_priv_t *priv = (unifi_priv_t*)ospriv;\r\nul_client_t *client;\r\nint dir;\r\ndir = (direction == UDI_LOG_FROM_HOST) ? UDI_FROM_HOST : UDI_TO_HOST;\r\ndown(&priv->udi_logging_mutex);\r\nclient = priv->logging_client;\r\nif (client != NULL) {\r\nclient->event_hook(client, sigdata, signal_len,\r\nbulkdata, dir);\r\n}\r\nup(&priv->udi_logging_mutex);\r\n}\r\nvoid\r\nul_log_config_ind(unifi_priv_t *priv, u8 *conf_param, int len)\r\n{\r\n#ifdef CSR_SUPPORT_SME\r\nif (priv->smepriv == NULL)\r\n{\r\nreturn;\r\n}\r\nif ((CONFIG_IND_ERROR == (*conf_param)) && (priv->wifi_on_state == wifi_on_in_progress)) {\r\nunifi_notice(priv, "ul_log_config_ind: wifi on in progress, suppress error\n");\r\n} else {\r\nCsrWifiRouterCtrlWifiOffIndSend(priv->CSR_WIFI_SME_IFACEQUEUE,0, (CsrWifiRouterCtrlControlIndication)(*conf_param));\r\n}\r\n#ifdef CSR_WIFI_HIP_DEBUG_OFFLINE\r\nunifi_debug_buf_dump();\r\n#endif\r\n#else\r\nbulk_data_param_t bulkdata;\r\nif (!priv) {\r\nunifi_notice(NULL, "uf_sme_event_ind: NULL priv\n");\r\nreturn;\r\n}\r\nbulkdata.d[0].data_length = 0;\r\nbulkdata.d[1].data_length = 0;\r\nsme_native_log_event(priv->sme_cli, conf_param, sizeof(u8),\r\n&bulkdata, UDI_CONFIG_IND);\r\n#endif\r\n}\r\nstatic void\r\nfree_bulkdata_buffers(unifi_priv_t *priv, bulk_data_param_t *bulkdata)\r\n{\r\nint i;\r\nif (bulkdata) {\r\nfor (i = 0; i < UNIFI_MAX_DATA_REFERENCES; ++i) {\r\nif (bulkdata->d[i].data_length != 0) {\r\nunifi_net_data_free(priv, (bulk_data_desc_t *)(&bulkdata->d[i]));\r\n}\r\n}\r\n}\r\n}\r\nstatic int\r\n_align_bulk_data_buffers(unifi_priv_t *priv, u8 *signal,\r\nbulk_data_param_t *bulkdata)\r\n{\r\nunsigned int i;\r\nif ((bulkdata == NULL) || (CSR_WIFI_ALIGN_BYTES == 0)) {\r\nreturn 0;\r\n}\r\nfor (i = 0; i < UNIFI_MAX_DATA_REFERENCES; i++)\r\n{\r\nstruct sk_buff *skb;\r\nu32 align_offset = (u32)(long)(bulkdata->d[i].os_data_ptr) & (CSR_WIFI_ALIGN_BYTES-1);\r\nif (align_offset)\r\n{\r\nskb = (struct sk_buff*)bulkdata->d[i].os_net_buf_ptr;\r\nif (skb == NULL) {\r\nunifi_warning(priv,\r\n"_align_bulk_data_buffers: Align offset found (%d) but skb is NULL!\n",\r\nalign_offset);\r\nreturn -EINVAL;\r\n}\r\nif (bulkdata->d[i].data_length == 0) {\r\nunifi_warning(priv,\r\n"_align_bulk_data_buffers: Align offset found (%d) but length is zero\n",\r\nalign_offset);\r\nreturn CSR_RESULT_SUCCESS;\r\n}\r\nunifi_trace(priv, UDBG5,\r\n"Align f-h buffer (0x%p) by %d bytes (skb->data: 0x%p)\n",\r\nbulkdata->d[i].os_data_ptr, align_offset, skb->data);\r\nif (unlikely(skb_headroom(skb) < align_offset))\r\n{\r\nstruct sk_buff *tmp = skb;\r\nunifi_trace(priv, UDBG5, "Headroom not enough - realloc it\n");\r\nskb = skb_realloc_headroom(skb, align_offset);\r\nif (skb == NULL) {\r\nunifi_error(priv,\r\n"_align_bulk_data_buffers: skb_realloc_headroom failed - signal is dropped\n");\r\nreturn -EFAULT;\r\n}\r\nkfree_skb(tmp);\r\nbulkdata->d[i].os_net_buf_ptr = (const unsigned char*)skb;\r\nbulkdata->d[i].os_data_ptr = (const void*)skb->data;\r\n}\r\nskb_push(skb, align_offset);\r\n}\r\nsignal[SIZEOF_SIGNAL_HEADER + (i * SIZEOF_DATAREF) + 1] = align_offset;\r\n}\r\nreturn 0;\r\n}\r\nint\r\nul_send_signal_unpacked(unifi_priv_t *priv, CSR_SIGNAL *sigptr,\r\nbulk_data_param_t *bulkdata)\r\n{\r\nu8 sigbuf[UNIFI_PACKED_SIGBUF_SIZE];\r\nu16 packed_siglen;\r\nCsrResult csrResult;\r\nunsigned long lock_flags;\r\nint r;\r\ncsrResult = write_pack(sigptr, sigbuf, &packed_siglen);\r\nif (csrResult != CSR_RESULT_SUCCESS) {\r\nunifi_error(priv, "Malformed HIP signal in ul_send_signal_unpacked()\n");\r\nreturn CsrHipResultToStatus(csrResult);\r\n}\r\nr = _align_bulk_data_buffers(priv, sigbuf, (bulk_data_param_t*)bulkdata);\r\nif (r) {\r\nreturn r;\r\n}\r\nspin_lock_irqsave(&priv->send_signal_lock, lock_flags);\r\ncsrResult = unifi_send_signal(priv->card, sigbuf, packed_siglen, bulkdata);\r\nif (csrResult != CSR_RESULT_SUCCESS) {\r\nspin_unlock_irqrestore(&priv->send_signal_lock, lock_flags);\r\nreturn CsrHipResultToStatus(csrResult);\r\n}\r\nspin_unlock_irqrestore(&priv->send_signal_lock, lock_flags);\r\nreturn 0;\r\n}\r\nstatic void\r\nreset_driver_status(unifi_priv_t *priv)\r\n{\r\npriv->sta_wmm_capabilities = 0;\r\n#ifdef CSR_NATIVE_LINUX\r\n#ifdef CSR_SUPPORT_WEXT\r\npriv->wext_conf.flag_associated = 0;\r\npriv->wext_conf.block_controlled_port = CSR_WIFI_ROUTER_PORT_ACTION_8021X_PORT_OPEN;\r\npriv->wext_conf.bss_wmm_capabilities = 0;\r\npriv->wext_conf.disable_join_on_ssid_set = 0;\r\n#endif\r\n#endif\r\n}\r\nint\r\nul_send_signal_raw(unifi_priv_t *priv, unsigned char *sigptr, int siglen,\r\nbulk_data_param_t *bulkdata)\r\n{\r\nCsrResult csrResult;\r\nunsigned long lock_flags;\r\nint r;\r\nr = _align_bulk_data_buffers(priv, (u8*)sigptr, bulkdata);\r\nif (r) {\r\nreturn r;\r\n}\r\nspin_lock_irqsave(&priv->send_signal_lock, lock_flags);\r\ncsrResult = unifi_send_signal(priv->card, sigptr, siglen, bulkdata);\r\nif (csrResult != CSR_RESULT_SUCCESS) {\r\nfree_bulkdata_buffers(priv, bulkdata);\r\nspin_unlock_irqrestore(&priv->send_signal_lock, lock_flags);\r\nreturn CsrHipResultToStatus(csrResult);\r\n}\r\nspin_unlock_irqrestore(&priv->send_signal_lock, lock_flags);\r\nif (GET_SIGNAL_ID(sigptr) == CSR_MLME_RESET_REQUEST_ID) {\r\nreset_driver_status(priv);\r\n}\r\nreturn 0;\r\n}
