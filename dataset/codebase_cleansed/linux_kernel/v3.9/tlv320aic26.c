static unsigned int aic26_reg_read(struct snd_soc_codec *codec,\r\nunsigned int reg)\r\n{\r\nstruct aic26 *aic26 = snd_soc_codec_get_drvdata(codec);\r\nu16 *cache = codec->reg_cache;\r\nu16 cmd, value;\r\nu8 buffer[2];\r\nint rc;\r\nif (reg >= AIC26_NUM_REGS) {\r\nWARN_ON_ONCE(1);\r\nreturn 0;\r\n}\r\ncmd = AIC26_READ_COMMAND_WORD(reg);\r\nbuffer[0] = (cmd >> 8) & 0xff;\r\nbuffer[1] = cmd & 0xff;\r\nrc = spi_write_then_read(aic26->spi, buffer, 2, buffer, 2);\r\nif (rc) {\r\ndev_err(&aic26->spi->dev, "AIC26 reg read error\n");\r\nreturn -EIO;\r\n}\r\nvalue = (buffer[0] << 8) | buffer[1];\r\ncache[reg] = value;\r\nreturn value;\r\n}\r\nstatic unsigned int aic26_reg_read_cache(struct snd_soc_codec *codec,\r\nunsigned int reg)\r\n{\r\nu16 *cache = codec->reg_cache;\r\nif (reg >= AIC26_NUM_REGS) {\r\nWARN_ON_ONCE(1);\r\nreturn 0;\r\n}\r\nreturn cache[reg];\r\n}\r\nstatic int aic26_reg_write(struct snd_soc_codec *codec, unsigned int reg,\r\nunsigned int value)\r\n{\r\nstruct aic26 *aic26 = snd_soc_codec_get_drvdata(codec);\r\nu16 *cache = codec->reg_cache;\r\nu16 cmd;\r\nu8 buffer[4];\r\nint rc;\r\nif (reg >= AIC26_NUM_REGS) {\r\nWARN_ON_ONCE(1);\r\nreturn -EINVAL;\r\n}\r\ncmd = AIC26_WRITE_COMMAND_WORD(reg);\r\nbuffer[0] = (cmd >> 8) & 0xff;\r\nbuffer[1] = cmd & 0xff;\r\nbuffer[2] = value >> 8;\r\nbuffer[3] = value;\r\nrc = spi_write(aic26->spi, buffer, 4);\r\nif (rc) {\r\ndev_err(&aic26->spi->dev, "AIC26 reg read error\n");\r\nreturn -EIO;\r\n}\r\ncache[reg] = value;\r\nreturn 0;\r\n}\r\nstatic int aic26_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nstruct aic26 *aic26 = snd_soc_codec_get_drvdata(codec);\r\nint fsref, divisor, wlen, pval, jval, dval, qval;\r\nu16 reg;\r\ndev_dbg(&aic26->spi->dev, "aic26_hw_params(substream=%p, params=%p)\n",\r\nsubstream, params);\r\ndev_dbg(&aic26->spi->dev, "rate=%i format=%i\n", params_rate(params),\r\nparams_format(params));\r\nswitch (params_rate(params)) {\r\ncase 8000: fsref = 48000; divisor = AIC26_DIV_6; break;\r\ncase 11025: fsref = 44100; divisor = AIC26_DIV_4; break;\r\ncase 12000: fsref = 48000; divisor = AIC26_DIV_4; break;\r\ncase 16000: fsref = 48000; divisor = AIC26_DIV_3; break;\r\ncase 22050: fsref = 44100; divisor = AIC26_DIV_2; break;\r\ncase 24000: fsref = 48000; divisor = AIC26_DIV_2; break;\r\ncase 32000: fsref = 48000; divisor = AIC26_DIV_1_5; break;\r\ncase 44100: fsref = 44100; divisor = AIC26_DIV_1; break;\r\ncase 48000: fsref = 48000; divisor = AIC26_DIV_1; break;\r\ndefault:\r\ndev_dbg(&aic26->spi->dev, "bad rate\n"); return -EINVAL;\r\n}\r\nswitch (params_format(params)) {\r\ncase SNDRV_PCM_FORMAT_S8: wlen = AIC26_WLEN_16; break;\r\ncase SNDRV_PCM_FORMAT_S16_BE: wlen = AIC26_WLEN_16; break;\r\ncase SNDRV_PCM_FORMAT_S24_BE: wlen = AIC26_WLEN_24; break;\r\ncase SNDRV_PCM_FORMAT_S32_BE: wlen = AIC26_WLEN_32; break;\r\ndefault:\r\ndev_dbg(&aic26->spi->dev, "bad format\n"); return -EINVAL;\r\n}\r\npval = 1;\r\njval = fsref / (aic26->mclk / 2048);\r\ndval = fsref - (jval * (aic26->mclk / 2048));\r\ndval = (10000 * dval) / (aic26->mclk / 2048);\r\ndev_dbg(&aic26->spi->dev, "Setting PLLM to %d.%04d\n", jval, dval);\r\nqval = 0;\r\nreg = 0x8000 | qval << 11 | pval << 8 | jval << 2;\r\naic26_reg_write(codec, AIC26_REG_PLL_PROG1, reg);\r\nreg = dval << 2;\r\naic26_reg_write(codec, AIC26_REG_PLL_PROG2, reg);\r\nreg = aic26_reg_read_cache(codec, AIC26_REG_AUDIO_CTRL3);\r\nreg &= ~0xf800;\r\nif (aic26->master)\r\nreg |= 0x0800;\r\nif (fsref == 48000)\r\nreg |= 0x2000;\r\naic26_reg_write(codec, AIC26_REG_AUDIO_CTRL3, reg);\r\nreg = aic26_reg_read_cache(codec, AIC26_REG_AUDIO_CTRL1);\r\nreg &= ~0x0fff;\r\nreg |= wlen | aic26->datfm | (divisor << 3) | divisor;\r\naic26_reg_write(codec, AIC26_REG_AUDIO_CTRL1, reg);\r\nreturn 0;\r\n}\r\nstatic int aic26_mute(struct snd_soc_dai *dai, int mute)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nstruct aic26 *aic26 = snd_soc_codec_get_drvdata(codec);\r\nu16 reg = aic26_reg_read_cache(codec, AIC26_REG_DAC_GAIN);\r\ndev_dbg(&aic26->spi->dev, "aic26_mute(dai=%p, mute=%i)\n",\r\ndai, mute);\r\nif (mute)\r\nreg |= 0x8080;\r\nelse\r\nreg &= ~0x8080;\r\naic26_reg_write(codec, AIC26_REG_DAC_GAIN, reg);\r\nreturn 0;\r\n}\r\nstatic int aic26_set_sysclk(struct snd_soc_dai *codec_dai,\r\nint clk_id, unsigned int freq, int dir)\r\n{\r\nstruct snd_soc_codec *codec = codec_dai->codec;\r\nstruct aic26 *aic26 = snd_soc_codec_get_drvdata(codec);\r\ndev_dbg(&aic26->spi->dev, "aic26_set_sysclk(dai=%p, clk_id==%i,"\r\n" freq=%i, dir=%i)\n",\r\ncodec_dai, clk_id, freq, dir);\r\nif ((freq < 2000000) || (freq > 50000000))\r\nreturn -EINVAL;\r\naic26->mclk = freq;\r\nreturn 0;\r\n}\r\nstatic int aic26_set_fmt(struct snd_soc_dai *codec_dai, unsigned int fmt)\r\n{\r\nstruct snd_soc_codec *codec = codec_dai->codec;\r\nstruct aic26 *aic26 = snd_soc_codec_get_drvdata(codec);\r\ndev_dbg(&aic26->spi->dev, "aic26_set_fmt(dai=%p, fmt==%i)\n",\r\ncodec_dai, fmt);\r\nswitch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {\r\ncase SND_SOC_DAIFMT_CBM_CFM: aic26->master = 1; break;\r\ncase SND_SOC_DAIFMT_CBS_CFS: aic26->master = 0; break;\r\ndefault:\r\ndev_dbg(&aic26->spi->dev, "bad master\n"); return -EINVAL;\r\n}\r\nswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\r\ncase SND_SOC_DAIFMT_I2S: aic26->datfm = AIC26_DATFM_I2S; break;\r\ncase SND_SOC_DAIFMT_DSP_A: aic26->datfm = AIC26_DATFM_DSP; break;\r\ncase SND_SOC_DAIFMT_RIGHT_J: aic26->datfm = AIC26_DATFM_RIGHTJ; break;\r\ncase SND_SOC_DAIFMT_LEFT_J: aic26->datfm = AIC26_DATFM_LEFTJ; break;\r\ndefault:\r\ndev_dbg(&aic26->spi->dev, "bad format\n"); return -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic ssize_t aic26_keyclick_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct aic26 *aic26 = dev_get_drvdata(dev);\r\nint val, amp, freq, len;\r\nval = aic26_reg_read_cache(&aic26->codec, AIC26_REG_AUDIO_CTRL2);\r\namp = (val >> 12) & 0x7;\r\nfreq = (125 << ((val >> 8) & 0x7)) >> 1;\r\nlen = 2 * (1 + ((val >> 4) & 0xf));\r\nreturn sprintf(buf, "amp=%x freq=%iHz len=%iclks\n", amp, freq, len);\r\n}\r\nstatic ssize_t aic26_keyclick_set(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct aic26 *aic26 = dev_get_drvdata(dev);\r\nint val;\r\nval = aic26_reg_read_cache(&aic26->codec, AIC26_REG_AUDIO_CTRL2);\r\nval |= 0x8000;\r\naic26_reg_write(&aic26->codec, AIC26_REG_AUDIO_CTRL2, val);\r\nreturn count;\r\n}\r\nstatic int aic26_probe(struct snd_soc_codec *codec)\r\n{\r\nint ret, err, i, reg;\r\ndev_info(codec->dev, "Probing AIC26 SoC CODEC driver\n");\r\naic26_reg_write(codec, AIC26_REG_RESET, 0xBB00);\r\naic26_reg_write(codec, AIC26_REG_POWER_CTRL, 0);\r\nreg = aic26_reg_read(codec, AIC26_REG_AUDIO_CTRL3);\r\nreg &= ~0xf800;\r\nreg |= 0x0800;\r\naic26_reg_write(codec, AIC26_REG_AUDIO_CTRL3, reg);\r\nfor (i = 0; i < codec->driver->reg_cache_size; i++)\r\naic26_reg_read(codec, i);\r\nret = device_create_file(codec->dev, &dev_attr_keyclick);\r\nif (ret)\r\ndev_info(codec->dev, "error creating sysfs files\n");\r\ndev_dbg(codec->dev, "Registering controls\n");\r\nerr = snd_soc_add_codec_controls(codec, aic26_snd_controls,\r\nARRAY_SIZE(aic26_snd_controls));\r\nWARN_ON(err < 0);\r\nreturn 0;\r\n}\r\nstatic int aic26_spi_probe(struct spi_device *spi)\r\n{\r\nstruct aic26 *aic26;\r\nint ret;\r\ndev_dbg(&spi->dev, "probing tlv320aic26 spi device\n");\r\naic26 = devm_kzalloc(&spi->dev, sizeof *aic26, GFP_KERNEL);\r\nif (!aic26)\r\nreturn -ENOMEM;\r\naic26->spi = spi;\r\ndev_set_drvdata(&spi->dev, aic26);\r\naic26->master = 1;\r\nret = snd_soc_register_codec(&spi->dev,\r\n&aic26_soc_codec_dev, &aic26_dai, 1);\r\nreturn ret;\r\n}\r\nstatic int aic26_spi_remove(struct spi_device *spi)\r\n{\r\nsnd_soc_unregister_codec(&spi->dev);\r\nreturn 0;\r\n}
