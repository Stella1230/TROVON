static __u32 reverse_bytes(__u32 b, int len)\r\n{\r\nswitch (len) {\r\ncase 32:\r\nb = ((b & 0xffff0000) >> 16) | ((b & 0x0000ffff) << 16);\r\ncase 16:\r\nb = ((b & 0xff00ff00) >> 8) | ((b & 0x00ff00ff) << 8);\r\ncase 8:\r\nb = ((b & 0xf0f0f0f0) >> 4) | ((b & 0x0f0f0f0f) << 4);\r\ncase 4:\r\nb = ((b & 0xcccccccc) >> 2) | ((b & 0x33333333) << 2);\r\ncase 2:\r\nb = ((b & 0xaaaaaaaa) >> 1) | ((b & 0x55555555) << 1);\r\ncase 1:\r\ncase 0:\r\nbreak;\r\ndefault:\r\nprintk(KERN_ERR "DBRI reverse_bytes: unsupported length\n");\r\n}\r\nreturn b;\r\n}\r\nstatic void dbri_cmdwait(struct snd_dbri *dbri)\r\n{\r\nint maxloops = MAXLOOPS;\r\nunsigned long flags;\r\nspin_lock_irqsave(&dbri->lock, flags);\r\nwhile ((--maxloops) > 0 && (sbus_readl(dbri->regs + REG0) & D_P)) {\r\nspin_unlock_irqrestore(&dbri->lock, flags);\r\nmsleep_interruptible(1);\r\nspin_lock_irqsave(&dbri->lock, flags);\r\n}\r\nspin_unlock_irqrestore(&dbri->lock, flags);\r\nif (maxloops == 0)\r\nprintk(KERN_ERR "DBRI: Chip never completed command buffer\n");\r\nelse\r\ndprintk(D_CMD, "Chip completed command buffer (%d)\n",\r\nMAXLOOPS - maxloops - 1);\r\n}\r\nstatic s32 *dbri_cmdlock(struct snd_dbri *dbri, int len)\r\n{\r\nlen += 2;\r\nspin_lock(&dbri->cmdlock);\r\nif (dbri->cmdptr - dbri->dma->cmd + len < DBRI_NO_CMDS - 2)\r\nreturn dbri->cmdptr + 2;\r\nelse if (len < sbus_readl(dbri->regs + REG8) - dbri->dma_dvma)\r\nreturn dbri->dma->cmd;\r\nelse\r\nprintk(KERN_ERR "DBRI: no space for commands.");\r\nreturn NULL;\r\n}\r\nstatic void dbri_cmdsend(struct snd_dbri *dbri, s32 *cmd, int len)\r\n{\r\ns32 tmp, addr;\r\nstatic int wait_id = 0;\r\nwait_id++;\r\nwait_id &= 0xffff;\r\n*(cmd) = DBRI_CMD(D_WAIT, 1, wait_id);\r\n*(cmd+1) = DBRI_CMD(D_WAIT, 1, wait_id);\r\naddr = dbri->dma_dvma + (cmd - len - dbri->dma->cmd) * sizeof(s32);\r\n*(dbri->cmdptr+1) = addr;\r\n*(dbri->cmdptr) = DBRI_CMD(D_JUMP, 0, 0);\r\n#ifdef DBRI_DEBUG\r\nif (cmd > dbri->cmdptr) {\r\ns32 *ptr;\r\nfor (ptr = dbri->cmdptr; ptr < cmd+2; ptr++)\r\ndprintk(D_CMD, "cmd: %lx:%08x\n",\r\n(unsigned long)ptr, *ptr);\r\n} else {\r\ns32 *ptr = dbri->cmdptr;\r\ndprintk(D_CMD, "cmd: %lx:%08x\n", (unsigned long)ptr, *ptr);\r\nptr++;\r\ndprintk(D_CMD, "cmd: %lx:%08x\n", (unsigned long)ptr, *ptr);\r\nfor (ptr = dbri->dma->cmd; ptr < cmd+2; ptr++)\r\ndprintk(D_CMD, "cmd: %lx:%08x\n",\r\n(unsigned long)ptr, *ptr);\r\n}\r\n#endif\r\ntmp = sbus_readl(dbri->regs + REG0);\r\ntmp |= D_P;\r\nsbus_writel(tmp, dbri->regs + REG0);\r\ndbri->cmdptr = cmd;\r\nspin_unlock(&dbri->cmdlock);\r\n}\r\nstatic void dbri_reset(struct snd_dbri *dbri)\r\n{\r\nint i;\r\nu32 tmp;\r\ndprintk(D_GEN, "reset 0:%x 2:%x 8:%x 9:%x\n",\r\nsbus_readl(dbri->regs + REG0),\r\nsbus_readl(dbri->regs + REG2),\r\nsbus_readl(dbri->regs + REG8), sbus_readl(dbri->regs + REG9));\r\nsbus_writel(D_R, dbri->regs + REG0);\r\nfor (i = 0; (sbus_readl(dbri->regs + REG0) & D_R) && i < 64; i++)\r\nudelay(10);\r\ntmp = sbus_readl(dbri->regs + REG0);\r\ntmp |= D_G | D_E;\r\ntmp &= ~D_S;\r\nsbus_writel(tmp, dbri->regs + REG0);\r\n}\r\nstatic void dbri_initialize(struct snd_dbri *dbri)\r\n{\r\ns32 *cmd;\r\nu32 dma_addr;\r\nunsigned long flags;\r\nint n;\r\nspin_lock_irqsave(&dbri->lock, flags);\r\ndbri_reset(dbri);\r\nfor (n = 0; n < DBRI_NO_PIPES; n++)\r\ndbri->pipes[n].desc = dbri->pipes[n].first_desc = -1;\r\nspin_lock_init(&dbri->cmdlock);\r\ndma_addr = dbri->dma_dvma + dbri_dma_off(intr, 0);\r\ndbri->dma->intr[0] = dma_addr;\r\ndbri->dbri_irqp = 1;\r\nspin_lock(&dbri->cmdlock);\r\ncmd = dbri->cmdptr = dbri->dma->cmd;\r\n*(cmd++) = DBRI_CMD(D_IIQ, 0, 0);\r\n*(cmd++) = dma_addr;\r\n*(cmd++) = DBRI_CMD(D_PAUSE, 0, 0);\r\ndbri->cmdptr = cmd;\r\n*(cmd++) = DBRI_CMD(D_WAIT, 1, 0);\r\n*(cmd++) = DBRI_CMD(D_WAIT, 1, 0);\r\ndma_addr = dbri->dma_dvma + dbri_dma_off(cmd, 0);\r\nsbus_writel(dma_addr, dbri->regs + REG8);\r\nspin_unlock(&dbri->cmdlock);\r\nspin_unlock_irqrestore(&dbri->lock, flags);\r\ndbri_cmdwait(dbri);\r\n}\r\nstatic inline int pipe_active(struct snd_dbri *dbri, int pipe)\r\n{\r\nreturn ((pipe >= 0) && (dbri->pipes[pipe].desc != -1));\r\n}\r\nstatic void reset_pipe(struct snd_dbri *dbri, int pipe)\r\n{\r\nint sdp;\r\nint desc;\r\ns32 *cmd;\r\nif (pipe < 0 || pipe > DBRI_MAX_PIPE) {\r\nprintk(KERN_ERR "DBRI: reset_pipe called with "\r\n"illegal pipe number\n");\r\nreturn;\r\n}\r\nsdp = dbri->pipes[pipe].sdp;\r\nif (sdp == 0) {\r\nprintk(KERN_ERR "DBRI: reset_pipe called "\r\n"on uninitialized pipe\n");\r\nreturn;\r\n}\r\ncmd = dbri_cmdlock(dbri, 3);\r\n*(cmd++) = DBRI_CMD(D_SDP, 0, sdp | D_SDP_C | D_SDP_P);\r\n*(cmd++) = 0;\r\n*(cmd++) = DBRI_CMD(D_PAUSE, 0, 0);\r\ndbri_cmdsend(dbri, cmd, 3);\r\ndesc = dbri->pipes[pipe].first_desc;\r\nif (desc >= 0)\r\ndo {\r\ndbri->dma->desc[desc].ba = 0;\r\ndbri->dma->desc[desc].nda = 0;\r\ndesc = dbri->next_desc[desc];\r\n} while (desc != -1 && desc != dbri->pipes[pipe].first_desc);\r\ndbri->pipes[pipe].desc = -1;\r\ndbri->pipes[pipe].first_desc = -1;\r\n}\r\nstatic void setup_pipe(struct snd_dbri *dbri, int pipe, int sdp)\r\n{\r\nif (pipe < 0 || pipe > DBRI_MAX_PIPE) {\r\nprintk(KERN_ERR "DBRI: setup_pipe called "\r\n"with illegal pipe number\n");\r\nreturn;\r\n}\r\nif ((sdp & 0xf800) != sdp) {\r\nprintk(KERN_ERR "DBRI: setup_pipe called "\r\n"with strange SDP value\n");\r\n}\r\nif (D_SDP_MODE(sdp) == D_SDP_FIXED && !(sdp & D_SDP_TO_SER))\r\nsdp |= D_SDP_CHANGE;\r\nsdp |= D_PIPE(pipe);\r\ndbri->pipes[pipe].sdp = sdp;\r\ndbri->pipes[pipe].desc = -1;\r\ndbri->pipes[pipe].first_desc = -1;\r\nreset_pipe(dbri, pipe);\r\n}\r\nstatic void link_time_slot(struct snd_dbri *dbri, int pipe,\r\nint prevpipe, int nextpipe,\r\nint length, int cycle)\r\n{\r\ns32 *cmd;\r\nint val;\r\nif (pipe < 0 || pipe > DBRI_MAX_PIPE\r\n|| prevpipe < 0 || prevpipe > DBRI_MAX_PIPE\r\n|| nextpipe < 0 || nextpipe > DBRI_MAX_PIPE) {\r\nprintk(KERN_ERR\r\n"DBRI: link_time_slot called with illegal pipe number\n");\r\nreturn;\r\n}\r\nif (dbri->pipes[pipe].sdp == 0\r\n|| dbri->pipes[prevpipe].sdp == 0\r\n|| dbri->pipes[nextpipe].sdp == 0) {\r\nprintk(KERN_ERR "DBRI: link_time_slot called "\r\n"on uninitialized pipe\n");\r\nreturn;\r\n}\r\ndbri->pipes[prevpipe].nextpipe = pipe;\r\ndbri->pipes[pipe].nextpipe = nextpipe;\r\ndbri->pipes[pipe].length = length;\r\ncmd = dbri_cmdlock(dbri, 4);\r\nif (dbri->pipes[pipe].sdp & D_SDP_TO_SER) {\r\nif (prevpipe == 16 && cycle == 0)\r\ncycle = dbri->chi_bpf;\r\nval = D_DTS_VO | D_DTS_INS | D_DTS_PRVOUT(prevpipe) | pipe;\r\n*(cmd++) = DBRI_CMD(D_DTS, 0, val);\r\n*(cmd++) = 0;\r\n*(cmd++) =\r\nD_TS_LEN(length) | D_TS_CYCLE(cycle) | D_TS_NEXT(nextpipe);\r\n} else {\r\nval = D_DTS_VI | D_DTS_INS | D_DTS_PRVIN(prevpipe) | pipe;\r\n*(cmd++) = DBRI_CMD(D_DTS, 0, val);\r\n*(cmd++) =\r\nD_TS_LEN(length) | D_TS_CYCLE(cycle) | D_TS_NEXT(nextpipe);\r\n*(cmd++) = 0;\r\n}\r\n*(cmd++) = DBRI_CMD(D_PAUSE, 0, 0);\r\ndbri_cmdsend(dbri, cmd, 4);\r\n}\r\nstatic void xmit_fixed(struct snd_dbri *dbri, int pipe, unsigned int data)\r\n{\r\ns32 *cmd;\r\nunsigned long flags;\r\nif (pipe < 16 || pipe > DBRI_MAX_PIPE) {\r\nprintk(KERN_ERR "DBRI: xmit_fixed: Illegal pipe number\n");\r\nreturn;\r\n}\r\nif (D_SDP_MODE(dbri->pipes[pipe].sdp) == 0) {\r\nprintk(KERN_ERR "DBRI: xmit_fixed: "\r\n"Uninitialized pipe %d\n", pipe);\r\nreturn;\r\n}\r\nif (D_SDP_MODE(dbri->pipes[pipe].sdp) != D_SDP_FIXED) {\r\nprintk(KERN_ERR "DBRI: xmit_fixed: Non-fixed pipe %d\n", pipe);\r\nreturn;\r\n}\r\nif (!(dbri->pipes[pipe].sdp & D_SDP_TO_SER)) {\r\nprintk(KERN_ERR "DBRI: xmit_fixed: Called on receive pipe %d\n",\r\npipe);\r\nreturn;\r\n}\r\nif (dbri->pipes[pipe].sdp & D_SDP_MSB)\r\ndata = reverse_bytes(data, dbri->pipes[pipe].length);\r\ncmd = dbri_cmdlock(dbri, 3);\r\n*(cmd++) = DBRI_CMD(D_SSP, 0, pipe);\r\n*(cmd++) = data;\r\n*(cmd++) = DBRI_CMD(D_PAUSE, 0, 0);\r\nspin_lock_irqsave(&dbri->lock, flags);\r\ndbri_cmdsend(dbri, cmd, 3);\r\nspin_unlock_irqrestore(&dbri->lock, flags);\r\ndbri_cmdwait(dbri);\r\n}\r\nstatic void recv_fixed(struct snd_dbri *dbri, int pipe, volatile __u32 *ptr)\r\n{\r\nif (pipe < 16 || pipe > DBRI_MAX_PIPE) {\r\nprintk(KERN_ERR "DBRI: recv_fixed called with "\r\n"illegal pipe number\n");\r\nreturn;\r\n}\r\nif (D_SDP_MODE(dbri->pipes[pipe].sdp) != D_SDP_FIXED) {\r\nprintk(KERN_ERR "DBRI: recv_fixed called on "\r\n"non-fixed pipe %d\n", pipe);\r\nreturn;\r\n}\r\nif (dbri->pipes[pipe].sdp & D_SDP_TO_SER) {\r\nprintk(KERN_ERR "DBRI: recv_fixed called on "\r\n"transmit pipe %d\n", pipe);\r\nreturn;\r\n}\r\ndbri->pipes[pipe].recv_fixed_ptr = ptr;\r\n}\r\nstatic int setup_descs(struct snd_dbri *dbri, int streamno, unsigned int period)\r\n{\r\nstruct dbri_streaminfo *info = &dbri->stream_info[streamno];\r\n__u32 dvma_buffer;\r\nint desc;\r\nint len;\r\nint first_desc = -1;\r\nint last_desc = -1;\r\nif (info->pipe < 0 || info->pipe > 15) {\r\nprintk(KERN_ERR "DBRI: setup_descs: Illegal pipe number\n");\r\nreturn -2;\r\n}\r\nif (dbri->pipes[info->pipe].sdp == 0) {\r\nprintk(KERN_ERR "DBRI: setup_descs: Uninitialized pipe %d\n",\r\ninfo->pipe);\r\nreturn -2;\r\n}\r\ndvma_buffer = info->dvma_buffer;\r\nlen = info->size;\r\nif (streamno == DBRI_PLAY) {\r\nif (!(dbri->pipes[info->pipe].sdp & D_SDP_TO_SER)) {\r\nprintk(KERN_ERR "DBRI: setup_descs: "\r\n"Called on receive pipe %d\n", info->pipe);\r\nreturn -2;\r\n}\r\n} else {\r\nif (dbri->pipes[info->pipe].sdp & D_SDP_TO_SER) {\r\nprintk(KERN_ERR\r\n"DBRI: setup_descs: Called on transmit pipe %d\n",\r\ninfo->pipe);\r\nreturn -2;\r\n}\r\nif (pipe_active(dbri, info->pipe)) {\r\nprintk(KERN_ERR "DBRI: recv_on_pipe: "\r\n"Called on active pipe %d\n", info->pipe);\r\nreturn -2;\r\n}\r\nlen &= ~3;\r\n}\r\ndesc = dbri->pipes[info->pipe].first_desc;\r\nif (desc >= 0)\r\ndo {\r\ndbri->dma->desc[desc].ba = 0;\r\ndbri->dma->desc[desc].nda = 0;\r\ndesc = dbri->next_desc[desc];\r\n} while (desc != -1 &&\r\ndesc != dbri->pipes[info->pipe].first_desc);\r\ndbri->pipes[info->pipe].desc = -1;\r\ndbri->pipes[info->pipe].first_desc = -1;\r\ndesc = 0;\r\nwhile (len > 0) {\r\nint mylen;\r\nfor (; desc < DBRI_NO_DESCS; desc++) {\r\nif (!dbri->dma->desc[desc].ba)\r\nbreak;\r\n}\r\nif (desc == DBRI_NO_DESCS) {\r\nprintk(KERN_ERR "DBRI: setup_descs: No descriptors\n");\r\nreturn -1;\r\n}\r\nif (len > DBRI_TD_MAXCNT)\r\nmylen = DBRI_TD_MAXCNT;\r\nelse\r\nmylen = len;\r\nif (mylen > period)\r\nmylen = period;\r\ndbri->next_desc[desc] = -1;\r\ndbri->dma->desc[desc].ba = dvma_buffer;\r\ndbri->dma->desc[desc].nda = 0;\r\nif (streamno == DBRI_PLAY) {\r\ndbri->dma->desc[desc].word1 = DBRI_TD_CNT(mylen);\r\ndbri->dma->desc[desc].word4 = 0;\r\ndbri->dma->desc[desc].word1 |= DBRI_TD_F | DBRI_TD_B;\r\n} else {\r\ndbri->dma->desc[desc].word1 = 0;\r\ndbri->dma->desc[desc].word4 =\r\nDBRI_RD_B | DBRI_RD_BCNT(mylen);\r\n}\r\nif (first_desc == -1)\r\nfirst_desc = desc;\r\nelse {\r\ndbri->next_desc[last_desc] = desc;\r\ndbri->dma->desc[last_desc].nda =\r\ndbri->dma_dvma + dbri_dma_off(desc, desc);\r\n}\r\nlast_desc = desc;\r\ndvma_buffer += mylen;\r\nlen -= mylen;\r\n}\r\nif (first_desc == -1 || last_desc == -1) {\r\nprintk(KERN_ERR "DBRI: setup_descs: "\r\n" Not enough descriptors available\n");\r\nreturn -1;\r\n}\r\ndbri->dma->desc[last_desc].nda =\r\ndbri->dma_dvma + dbri_dma_off(desc, first_desc);\r\ndbri->next_desc[last_desc] = first_desc;\r\ndbri->pipes[info->pipe].first_desc = first_desc;\r\ndbri->pipes[info->pipe].desc = first_desc;\r\n#ifdef DBRI_DEBUG\r\nfor (desc = first_desc; desc != -1;) {\r\ndprintk(D_DESC, "DESC %d: %08x %08x %08x %08x\n",\r\ndesc,\r\ndbri->dma->desc[desc].word1,\r\ndbri->dma->desc[desc].ba,\r\ndbri->dma->desc[desc].nda, dbri->dma->desc[desc].word4);\r\ndesc = dbri->next_desc[desc];\r\nif (desc == first_desc)\r\nbreak;\r\n}\r\n#endif\r\nreturn 0;\r\n}\r\nstatic void reset_chi(struct snd_dbri *dbri,\r\nenum master_or_slave master_or_slave,\r\nint bits_per_frame)\r\n{\r\ns32 *cmd;\r\nint val;\r\ncmd = dbri_cmdlock(dbri, 4);\r\nval = D_DTS_VO | D_DTS_VI | D_DTS_INS\r\n| D_DTS_PRVIN(16) | D_PIPE(16) | D_DTS_PRVOUT(16);\r\n*(cmd++) = DBRI_CMD(D_DTS, 0, val);\r\n*(cmd++) = D_TS_ANCHOR | D_TS_NEXT(16);\r\n*(cmd++) = D_TS_ANCHOR | D_TS_NEXT(16);\r\n*(cmd++) = DBRI_CMD(D_PAUSE, 0, 0);\r\ndbri_cmdsend(dbri, cmd, 4);\r\ndbri->pipes[16].sdp = 1;\r\ndbri->pipes[16].nextpipe = 16;\r\ncmd = dbri_cmdlock(dbri, 4);\r\nif (master_or_slave == CHIslave) {\r\n*(cmd++) = DBRI_CMD(D_CHI, 0, D_CHI_CHICM(0));\r\n} else {\r\nint clockrate = bits_per_frame * 8;\r\nint divisor = 12288 / clockrate;\r\nif (divisor > 255 || divisor * clockrate != 12288)\r\nprintk(KERN_ERR "DBRI: illegal bits_per_frame "\r\n"in setup_chi\n");\r\n*(cmd++) = DBRI_CMD(D_CHI, 0, D_CHI_CHICM(divisor) | D_CHI_FD\r\n| D_CHI_BPF(bits_per_frame));\r\n}\r\ndbri->chi_bpf = bits_per_frame;\r\n*(cmd++) = DBRI_CMD(D_PAUSE, 0, 0);\r\n*(cmd++) = DBRI_CMD(D_CDM, 0, D_CDM_XCE | D_CDM_XEN | D_CDM_REN);\r\n*(cmd++) = DBRI_CMD(D_PAUSE, 0, 0);\r\ndbri_cmdsend(dbri, cmd, 4);\r\n}\r\nstatic void cs4215_setup_pipes(struct snd_dbri *dbri)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&dbri->lock, flags);\r\nsetup_pipe(dbri, 4, D_SDP_MEM | D_SDP_TO_SER | D_SDP_MSB);\r\nsetup_pipe(dbri, 20, D_SDP_FIXED | D_SDP_TO_SER | D_SDP_MSB);\r\nsetup_pipe(dbri, 6, D_SDP_MEM | D_SDP_FROM_SER | D_SDP_MSB);\r\nsetup_pipe(dbri, 21, D_SDP_FIXED | D_SDP_FROM_SER | D_SDP_MSB);\r\nsetup_pipe(dbri, 17, D_SDP_FIXED | D_SDP_TO_SER | D_SDP_MSB);\r\nsetup_pipe(dbri, 18, D_SDP_FIXED | D_SDP_FROM_SER | D_SDP_MSB);\r\nsetup_pipe(dbri, 19, D_SDP_FIXED | D_SDP_FROM_SER | D_SDP_MSB);\r\nspin_unlock_irqrestore(&dbri->lock, flags);\r\ndbri_cmdwait(dbri);\r\n}\r\nstatic int cs4215_init_data(struct cs4215 *mm)\r\n{\r\nmm->data[0] = CS4215_LO(0x20) | CS4215_HE | CS4215_LE;\r\nmm->data[1] = CS4215_RO(0x20) | CS4215_SE;\r\nmm->data[2] = CS4215_LG(0x8) | CS4215_IS | CS4215_PIO0 | CS4215_PIO1;\r\nmm->data[3] = CS4215_RG(0x8) | CS4215_MA(0xf);\r\nmm->ctrl[0] = CS4215_RSRVD_1 | CS4215_MLB;\r\nmm->ctrl[1] = CS4215_DFR_ULAW | CS4215_FREQ[0].csval;\r\nmm->ctrl[2] = CS4215_XCLK | CS4215_BSEL_128 | CS4215_FREQ[0].xtal;\r\nmm->ctrl[3] = 0;\r\nmm->status = 0;\r\nmm->version = 0xff;\r\nmm->precision = 8;\r\nmm->channels = 1;\r\nreturn 0;\r\n}\r\nstatic void cs4215_setdata(struct snd_dbri *dbri, int muted)\r\n{\r\nif (muted) {\r\ndbri->mm.data[0] |= 63;\r\ndbri->mm.data[1] |= 63;\r\ndbri->mm.data[2] &= ~15;\r\ndbri->mm.data[3] &= ~15;\r\n} else {\r\nstruct dbri_streaminfo *info = &dbri->stream_info[DBRI_PLAY];\r\nint left_gain = info->left_gain & 0x3f;\r\nint right_gain = info->right_gain & 0x3f;\r\ndbri->mm.data[0] &= ~0x3f;\r\ndbri->mm.data[1] &= ~0x3f;\r\ndbri->mm.data[0] |= (DBRI_MAX_VOLUME - left_gain);\r\ndbri->mm.data[1] |= (DBRI_MAX_VOLUME - right_gain);\r\ninfo = &dbri->stream_info[DBRI_REC];\r\nleft_gain = info->left_gain & 0xf;\r\nright_gain = info->right_gain & 0xf;\r\ndbri->mm.data[2] |= CS4215_LG(left_gain);\r\ndbri->mm.data[3] |= CS4215_RG(right_gain);\r\n}\r\nxmit_fixed(dbri, 20, *(int *)dbri->mm.data);\r\n}\r\nstatic void cs4215_open(struct snd_dbri *dbri)\r\n{\r\nint data_width;\r\nu32 tmp;\r\nunsigned long flags;\r\ndprintk(D_MM, "cs4215_open: %d channels, %d bits\n",\r\ndbri->mm.channels, dbri->mm.precision);\r\ncs4215_setdata(dbri, 1);\r\nudelay(125);\r\nspin_lock_irqsave(&dbri->lock, flags);\r\ntmp = sbus_readl(dbri->regs + REG0);\r\ntmp &= ~(D_C);\r\nsbus_writel(tmp, dbri->regs + REG0);\r\nsbus_writel(D_ENPIO | D_PIO1 | D_PIO3 |\r\n(dbri->mm.onboard ? D_PIO0 : D_PIO2), dbri->regs + REG2);\r\nreset_chi(dbri, CHIslave, 128);\r\ndata_width = dbri->mm.channels * dbri->mm.precision;\r\nlink_time_slot(dbri, 4, 16, 16, data_width, dbri->mm.offset);\r\nlink_time_slot(dbri, 20, 4, 16, 32, dbri->mm.offset + 32);\r\nlink_time_slot(dbri, 6, 16, 16, data_width, dbri->mm.offset);\r\nlink_time_slot(dbri, 21, 6, 16, 16, dbri->mm.offset + 40);\r\ntmp = sbus_readl(dbri->regs + REG0);\r\ntmp |= D_C;\r\nsbus_writel(tmp, dbri->regs + REG0);\r\nspin_unlock_irqrestore(&dbri->lock, flags);\r\ncs4215_setdata(dbri, 0);\r\n}\r\nstatic int cs4215_setctrl(struct snd_dbri *dbri)\r\n{\r\nint i, val;\r\nu32 tmp;\r\nunsigned long flags;\r\ncs4215_setdata(dbri, 1);\r\nudelay(125);\r\nval = D_ENPIO | D_PIO1 | (dbri->mm.onboard ? D_PIO0 : D_PIO2);\r\nsbus_writel(val, dbri->regs + REG2);\r\ndprintk(D_MM, "cs4215_setctrl: reg2=0x%x\n", val);\r\nudelay(34);\r\nspin_lock_irqsave(&dbri->lock, flags);\r\ntmp = sbus_readl(dbri->regs + REG0);\r\ntmp &= ~D_C;\r\nsbus_writel(tmp, dbri->regs + REG0);\r\nreset_chi(dbri, CHImaster, 128);\r\nlink_time_slot(dbri, 17, 16, 16, 32, dbri->mm.offset);\r\nlink_time_slot(dbri, 18, 16, 16, 8, dbri->mm.offset);\r\nlink_time_slot(dbri, 19, 18, 16, 8, dbri->mm.offset + 48);\r\nspin_unlock_irqrestore(&dbri->lock, flags);\r\ndbri->mm.ctrl[0] &= ~CS4215_CLB;\r\nxmit_fixed(dbri, 17, *(int *)dbri->mm.ctrl);\r\nspin_lock_irqsave(&dbri->lock, flags);\r\ntmp = sbus_readl(dbri->regs + REG0);\r\ntmp |= D_C;\r\nsbus_writel(tmp, dbri->regs + REG0);\r\nspin_unlock_irqrestore(&dbri->lock, flags);\r\nfor (i = 10; ((dbri->mm.status & 0xe4) != 0x20); --i)\r\nmsleep_interruptible(1);\r\nif (i == 0) {\r\ndprintk(D_MM, "CS4215 didn't respond to CLB (0x%02x)\n",\r\ndbri->mm.status);\r\nreturn -1;\r\n}\r\nrecv_fixed(dbri, 19, NULL);\r\ndbri->mm.ctrl[0] |= CS4215_CLB;\r\nxmit_fixed(dbri, 17, *(int *)dbri->mm.ctrl);\r\nudelay(250);\r\ncs4215_setdata(dbri, 0);\r\nreturn 0;\r\n}\r\nstatic int cs4215_prepare(struct snd_dbri *dbri, unsigned int rate,\r\nsnd_pcm_format_t format, unsigned int channels)\r\n{\r\nint freq_idx;\r\nint ret = 0;\r\nfor (freq_idx = 0; CS4215_FREQ[freq_idx].freq != 0; freq_idx++) {\r\nif (CS4215_FREQ[freq_idx].freq == rate)\r\nbreak;\r\n}\r\nif (CS4215_FREQ[freq_idx].freq != rate) {\r\nprintk(KERN_WARNING "DBRI: Unsupported rate %d Hz\n", rate);\r\nreturn -1;\r\n}\r\nswitch (format) {\r\ncase SNDRV_PCM_FORMAT_MU_LAW:\r\ndbri->mm.ctrl[1] = CS4215_DFR_ULAW;\r\ndbri->mm.precision = 8;\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_A_LAW:\r\ndbri->mm.ctrl[1] = CS4215_DFR_ALAW;\r\ndbri->mm.precision = 8;\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_U8:\r\ndbri->mm.ctrl[1] = CS4215_DFR_LINEAR8;\r\ndbri->mm.precision = 8;\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S16_BE:\r\ndbri->mm.ctrl[1] = CS4215_DFR_LINEAR16;\r\ndbri->mm.precision = 16;\r\nbreak;\r\ndefault:\r\nprintk(KERN_WARNING "DBRI: Unsupported format %d\n", format);\r\nreturn -1;\r\n}\r\ndbri->mm.ctrl[1] |= CS4215_FREQ[freq_idx].csval;\r\ndbri->mm.ctrl[2] = CS4215_XCLK |\r\nCS4215_BSEL_128 | CS4215_FREQ[freq_idx].xtal;\r\ndbri->mm.channels = channels;\r\nif (channels == 2)\r\ndbri->mm.ctrl[1] |= CS4215_DFR_STEREO;\r\nret = cs4215_setctrl(dbri);\r\nif (ret == 0)\r\ncs4215_open(dbri);\r\nreturn ret;\r\n}\r\nstatic int cs4215_init(struct snd_dbri *dbri)\r\n{\r\nu32 reg2 = sbus_readl(dbri->regs + REG2);\r\ndprintk(D_MM, "cs4215_init: reg2=0x%x\n", reg2);\r\nif (reg2 & D_PIO2) {\r\ndprintk(D_MM, "Onboard CS4215 detected\n");\r\ndbri->mm.onboard = 1;\r\n}\r\nif (reg2 & D_PIO0) {\r\ndprintk(D_MM, "Speakerbox detected\n");\r\ndbri->mm.onboard = 0;\r\nif (reg2 & D_PIO2) {\r\nprintk(KERN_INFO "DBRI: Using speakerbox / "\r\n"ignoring onboard mmcodec.\n");\r\nsbus_writel(D_ENPIO2, dbri->regs + REG2);\r\n}\r\n}\r\nif (!(reg2 & (D_PIO0 | D_PIO2))) {\r\nprintk(KERN_ERR "DBRI: no mmcodec found.\n");\r\nreturn -EIO;\r\n}\r\ncs4215_setup_pipes(dbri);\r\ncs4215_init_data(&dbri->mm);\r\nrecv_fixed(dbri, 18, &dbri->mm.status);\r\nrecv_fixed(dbri, 19, &dbri->mm.version);\r\ndbri->mm.offset = dbri->mm.onboard ? 0 : 8;\r\nif (cs4215_setctrl(dbri) == -1 || dbri->mm.version == 0xff) {\r\ndprintk(D_MM, "CS4215 failed probe at offset %d\n",\r\ndbri->mm.offset);\r\nreturn -EIO;\r\n}\r\ndprintk(D_MM, "Found CS4215 at offset %d\n", dbri->mm.offset);\r\nreturn 0;\r\n}\r\nstatic void xmit_descs(struct snd_dbri *dbri)\r\n{\r\nstruct dbri_streaminfo *info;\r\ns32 *cmd;\r\nunsigned long flags;\r\nint first_td;\r\nif (dbri == NULL)\r\nreturn;\r\ninfo = &dbri->stream_info[DBRI_REC];\r\nspin_lock_irqsave(&dbri->lock, flags);\r\nif (info->pipe >= 0) {\r\nfirst_td = dbri->pipes[info->pipe].first_desc;\r\ndprintk(D_DESC, "xmit_descs rec @ TD %d\n", first_td);\r\nif (first_td >= 0) {\r\ncmd = dbri_cmdlock(dbri, 2);\r\n*(cmd++) = DBRI_CMD(D_SDP, 0,\r\ndbri->pipes[info->pipe].sdp\r\n| D_SDP_P | D_SDP_EVERY | D_SDP_C);\r\n*(cmd++) = dbri->dma_dvma +\r\ndbri_dma_off(desc, first_td);\r\ndbri_cmdsend(dbri, cmd, 2);\r\ndbri->pipes[info->pipe].desc = first_td;\r\n}\r\n}\r\ninfo = &dbri->stream_info[DBRI_PLAY];\r\nif (info->pipe >= 0) {\r\nfirst_td = dbri->pipes[info->pipe].first_desc;\r\ndprintk(D_DESC, "xmit_descs play @ TD %d\n", first_td);\r\nif (first_td >= 0) {\r\ncmd = dbri_cmdlock(dbri, 2);\r\n*(cmd++) = DBRI_CMD(D_SDP, 0,\r\ndbri->pipes[info->pipe].sdp\r\n| D_SDP_P | D_SDP_EVERY | D_SDP_C);\r\n*(cmd++) = dbri->dma_dvma +\r\ndbri_dma_off(desc, first_td);\r\ndbri_cmdsend(dbri, cmd, 2);\r\ndbri->pipes[info->pipe].desc = first_td;\r\n}\r\n}\r\nspin_unlock_irqrestore(&dbri->lock, flags);\r\n}\r\nstatic void transmission_complete_intr(struct snd_dbri *dbri, int pipe)\r\n{\r\nstruct dbri_streaminfo *info = &dbri->stream_info[DBRI_PLAY];\r\nint td = dbri->pipes[pipe].desc;\r\nint status;\r\nwhile (td >= 0) {\r\nif (td >= DBRI_NO_DESCS) {\r\nprintk(KERN_ERR "DBRI: invalid td on pipe %d\n", pipe);\r\nreturn;\r\n}\r\nstatus = DBRI_TD_STATUS(dbri->dma->desc[td].word4);\r\nif (!(status & DBRI_TD_TBC))\r\nbreak;\r\ndprintk(D_INT, "TD %d, status 0x%02x\n", td, status);\r\ndbri->dma->desc[td].word4 = 0;\r\ninfo->offset += DBRI_RD_CNT(dbri->dma->desc[td].word1);\r\ntd = dbri->next_desc[td];\r\ndbri->pipes[pipe].desc = td;\r\n}\r\nspin_unlock(&dbri->lock);\r\nsnd_pcm_period_elapsed(info->substream);\r\nspin_lock(&dbri->lock);\r\n}\r\nstatic void reception_complete_intr(struct snd_dbri *dbri, int pipe)\r\n{\r\nstruct dbri_streaminfo *info;\r\nint rd = dbri->pipes[pipe].desc;\r\ns32 status;\r\nif (rd < 0 || rd >= DBRI_NO_DESCS) {\r\nprintk(KERN_ERR "DBRI: invalid rd on pipe %d\n", pipe);\r\nreturn;\r\n}\r\ndbri->pipes[pipe].desc = dbri->next_desc[rd];\r\nstatus = dbri->dma->desc[rd].word1;\r\ndbri->dma->desc[rd].word1 = 0;\r\ninfo = &dbri->stream_info[DBRI_REC];\r\ninfo->offset += DBRI_RD_CNT(status);\r\ndprintk(D_INT, "Recv RD %d, status 0x%02x, len %d\n",\r\nrd, DBRI_RD_STATUS(status), DBRI_RD_CNT(status));\r\nspin_unlock(&dbri->lock);\r\nsnd_pcm_period_elapsed(info->substream);\r\nspin_lock(&dbri->lock);\r\n}\r\nstatic void dbri_process_one_interrupt(struct snd_dbri *dbri, int x)\r\n{\r\nint val = D_INTR_GETVAL(x);\r\nint channel = D_INTR_GETCHAN(x);\r\nint command = D_INTR_GETCMD(x);\r\nint code = D_INTR_GETCODE(x);\r\n#ifdef DBRI_DEBUG\r\nint rval = D_INTR_GETRVAL(x);\r\n#endif\r\nif (channel == D_INTR_CMD) {\r\ndprintk(D_CMD, "INTR: Command: %-5s Value:%d\n",\r\ncmds[command], val);\r\n} else {\r\ndprintk(D_INT, "INTR: Chan:%d Code:%d Val:%#x\n",\r\nchannel, code, rval);\r\n}\r\nswitch (code) {\r\ncase D_INTR_CMDI:\r\nif (command != D_WAIT)\r\nprintk(KERN_ERR "DBRI: Command read interrupt\n");\r\nbreak;\r\ncase D_INTR_BRDY:\r\nreception_complete_intr(dbri, channel);\r\nbreak;\r\ncase D_INTR_XCMP:\r\ncase D_INTR_MINT:\r\ntransmission_complete_intr(dbri, channel);\r\nbreak;\r\ncase D_INTR_UNDR:\r\n{\r\nprintk(KERN_ERR "DBRI: Underrun error\n");\r\n#if 0\r\ns32 *cmd;\r\nint pipe = channel;\r\nint td = dbri->pipes[pipe].desc;\r\ndbri->dma->desc[td].word4 = 0;\r\ncmd = dbri_cmdlock(dbri, NoGetLock);\r\n*(cmd++) = DBRI_CMD(D_SDP, 0,\r\ndbri->pipes[pipe].sdp\r\n| D_SDP_P | D_SDP_C | D_SDP_2SAME);\r\n*(cmd++) = dbri->dma_dvma + dbri_dma_off(desc, td);\r\ndbri_cmdsend(dbri, cmd);\r\n#endif\r\n}\r\nbreak;\r\ncase D_INTR_FXDT:\r\nif (dbri->pipes[channel].sdp & D_SDP_MSB)\r\nval = reverse_bytes(val, dbri->pipes[channel].length);\r\nif (dbri->pipes[channel].recv_fixed_ptr)\r\n*(dbri->pipes[channel].recv_fixed_ptr) = val;\r\nbreak;\r\ndefault:\r\nif (channel != D_INTR_CMD)\r\nprintk(KERN_WARNING\r\n"DBRI: Ignored Interrupt: %d (0x%x)\n", code, x);\r\n}\r\n}\r\nstatic void dbri_process_interrupt_buffer(struct snd_dbri *dbri)\r\n{\r\ns32 x;\r\nwhile ((x = dbri->dma->intr[dbri->dbri_irqp]) != 0) {\r\ndbri->dma->intr[dbri->dbri_irqp] = 0;\r\ndbri->dbri_irqp++;\r\nif (dbri->dbri_irqp == DBRI_INT_BLK)\r\ndbri->dbri_irqp = 1;\r\ndbri_process_one_interrupt(dbri, x);\r\n}\r\n}\r\nstatic irqreturn_t snd_dbri_interrupt(int irq, void *dev_id)\r\n{\r\nstruct snd_dbri *dbri = dev_id;\r\nstatic int errcnt = 0;\r\nint x;\r\nif (dbri == NULL)\r\nreturn IRQ_NONE;\r\nspin_lock(&dbri->lock);\r\nx = sbus_readl(dbri->regs + REG1);\r\nif (x & (D_MRR | D_MLE | D_LBG | D_MBE)) {\r\nu32 tmp;\r\nif (x & D_MRR)\r\nprintk(KERN_ERR\r\n"DBRI: Multiple Error Ack on SBus reg1=0x%x\n",\r\nx);\r\nif (x & D_MLE)\r\nprintk(KERN_ERR\r\n"DBRI: Multiple Late Error on SBus reg1=0x%x\n",\r\nx);\r\nif (x & D_LBG)\r\nprintk(KERN_ERR\r\n"DBRI: Lost Bus Grant on SBus reg1=0x%x\n", x);\r\nif (x & D_MBE)\r\nprintk(KERN_ERR\r\n"DBRI: Burst Error on SBus reg1=0x%x\n", x);\r\nif ((++errcnt) % 10 == 0) {\r\ndprintk(D_INT, "Interrupt errors exceeded.\n");\r\ndbri_reset(dbri);\r\n} else {\r\ntmp = sbus_readl(dbri->regs + REG0);\r\ntmp &= ~(D_D);\r\nsbus_writel(tmp, dbri->regs + REG0);\r\n}\r\n}\r\ndbri_process_interrupt_buffer(dbri);\r\nspin_unlock(&dbri->lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int snd_hw_rule_format(struct snd_pcm_hw_params *params,\r\nstruct snd_pcm_hw_rule *rule)\r\n{\r\nstruct snd_interval *c = hw_param_interval(params,\r\nSNDRV_PCM_HW_PARAM_CHANNELS);\r\nstruct snd_mask *f = hw_param_mask(params, SNDRV_PCM_HW_PARAM_FORMAT);\r\nstruct snd_mask fmt;\r\nsnd_mask_any(&fmt);\r\nif (c->min > 1) {\r\nfmt.bits[0] &= SNDRV_PCM_FMTBIT_S16_BE;\r\nreturn snd_mask_refine(f, &fmt);\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_hw_rule_channels(struct snd_pcm_hw_params *params,\r\nstruct snd_pcm_hw_rule *rule)\r\n{\r\nstruct snd_interval *c = hw_param_interval(params,\r\nSNDRV_PCM_HW_PARAM_CHANNELS);\r\nstruct snd_mask *f = hw_param_mask(params, SNDRV_PCM_HW_PARAM_FORMAT);\r\nstruct snd_interval ch;\r\nsnd_interval_any(&ch);\r\nif (!(f->bits[0] & SNDRV_PCM_FMTBIT_S16_BE)) {\r\nch.min = 1;\r\nch.max = 1;\r\nch.integer = 1;\r\nreturn snd_interval_refine(c, &ch);\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_dbri_open(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_dbri *dbri = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct dbri_streaminfo *info = DBRI_STREAM(dbri, substream);\r\nunsigned long flags;\r\ndprintk(D_USR, "open audio output.\n");\r\nruntime->hw = snd_dbri_pcm_hw;\r\nspin_lock_irqsave(&dbri->lock, flags);\r\ninfo->substream = substream;\r\ninfo->offset = 0;\r\ninfo->dvma_buffer = 0;\r\ninfo->pipe = -1;\r\nspin_unlock_irqrestore(&dbri->lock, flags);\r\nsnd_pcm_hw_rule_add(runtime, 0, SNDRV_PCM_HW_PARAM_CHANNELS,\r\nsnd_hw_rule_format, NULL, SNDRV_PCM_HW_PARAM_FORMAT,\r\n-1);\r\nsnd_pcm_hw_rule_add(runtime, 0, SNDRV_PCM_HW_PARAM_FORMAT,\r\nsnd_hw_rule_channels, NULL,\r\nSNDRV_PCM_HW_PARAM_CHANNELS,\r\n-1);\r\ncs4215_open(dbri);\r\nreturn 0;\r\n}\r\nstatic int snd_dbri_close(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_dbri *dbri = snd_pcm_substream_chip(substream);\r\nstruct dbri_streaminfo *info = DBRI_STREAM(dbri, substream);\r\ndprintk(D_USR, "close audio output.\n");\r\ninfo->substream = NULL;\r\ninfo->offset = 0;\r\nreturn 0;\r\n}\r\nstatic int snd_dbri_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *hw_params)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct snd_dbri *dbri = snd_pcm_substream_chip(substream);\r\nstruct dbri_streaminfo *info = DBRI_STREAM(dbri, substream);\r\nint direction;\r\nint ret;\r\nret = cs4215_prepare(dbri, params_rate(hw_params),\r\nparams_format(hw_params),\r\nparams_channels(hw_params));\r\nif (ret != 0)\r\nreturn ret;\r\nif ((ret = snd_pcm_lib_malloc_pages(substream,\r\nparams_buffer_bytes(hw_params))) < 0) {\r\nprintk(KERN_ERR "malloc_pages failed with %d\n", ret);\r\nreturn ret;\r\n}\r\nif (info->dvma_buffer == 0) {\r\nif (DBRI_STREAMNO(substream) == DBRI_PLAY)\r\ndirection = DMA_TO_DEVICE;\r\nelse\r\ndirection = DMA_FROM_DEVICE;\r\ninfo->dvma_buffer =\r\ndma_map_single(&dbri->op->dev,\r\nruntime->dma_area,\r\nparams_buffer_bytes(hw_params),\r\ndirection);\r\n}\r\ndirection = params_buffer_bytes(hw_params);\r\ndprintk(D_USR, "hw_params: %d bytes, dvma=%x\n",\r\ndirection, info->dvma_buffer);\r\nreturn 0;\r\n}\r\nstatic int snd_dbri_hw_free(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_dbri *dbri = snd_pcm_substream_chip(substream);\r\nstruct dbri_streaminfo *info = DBRI_STREAM(dbri, substream);\r\nint direction;\r\ndprintk(D_USR, "hw_free.\n");\r\nif (info->dvma_buffer) {\r\nif (DBRI_STREAMNO(substream) == DBRI_PLAY)\r\ndirection = DMA_TO_DEVICE;\r\nelse\r\ndirection = DMA_FROM_DEVICE;\r\ndma_unmap_single(&dbri->op->dev, info->dvma_buffer,\r\nsubstream->runtime->buffer_size, direction);\r\ninfo->dvma_buffer = 0;\r\n}\r\nif (info->pipe != -1) {\r\nreset_pipe(dbri, info->pipe);\r\ninfo->pipe = -1;\r\n}\r\nreturn snd_pcm_lib_free_pages(substream);\r\n}\r\nstatic int snd_dbri_prepare(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_dbri *dbri = snd_pcm_substream_chip(substream);\r\nstruct dbri_streaminfo *info = DBRI_STREAM(dbri, substream);\r\nint ret;\r\ninfo->size = snd_pcm_lib_buffer_bytes(substream);\r\nif (DBRI_STREAMNO(substream) == DBRI_PLAY)\r\ninfo->pipe = 4;\r\nelse\r\ninfo->pipe = 6;\r\nspin_lock_irq(&dbri->lock);\r\ninfo->offset = 0;\r\nret = setup_descs(dbri, DBRI_STREAMNO(substream),\r\nsnd_pcm_lib_period_bytes(substream));\r\nspin_unlock_irq(&dbri->lock);\r\ndprintk(D_USR, "prepare audio output. %d bytes\n", info->size);\r\nreturn ret;\r\n}\r\nstatic int snd_dbri_trigger(struct snd_pcm_substream *substream, int cmd)\r\n{\r\nstruct snd_dbri *dbri = snd_pcm_substream_chip(substream);\r\nstruct dbri_streaminfo *info = DBRI_STREAM(dbri, substream);\r\nint ret = 0;\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\ndprintk(D_USR, "start audio, period is %d bytes\n",\r\n(int)snd_pcm_lib_period_bytes(substream));\r\nxmit_descs(dbri);\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\ndprintk(D_USR, "stop audio.\n");\r\nreset_pipe(dbri, info->pipe);\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\n}\r\nreturn ret;\r\n}\r\nstatic snd_pcm_uframes_t snd_dbri_pointer(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_dbri *dbri = snd_pcm_substream_chip(substream);\r\nstruct dbri_streaminfo *info = DBRI_STREAM(dbri, substream);\r\nsnd_pcm_uframes_t ret;\r\nret = bytes_to_frames(substream->runtime, info->offset)\r\n% substream->runtime->buffer_size;\r\ndprintk(D_USR, "I/O pointer: %ld frames of %ld.\n",\r\nret, substream->runtime->buffer_size);\r\nreturn ret;\r\n}\r\nstatic int snd_dbri_pcm(struct snd_card *card)\r\n{\r\nstruct snd_pcm *pcm;\r\nint err;\r\nif ((err = snd_pcm_new(card,\r\n"sun_dbri",\r\n0,\r\n1,\r\n1, &pcm)) < 0)\r\nreturn err;\r\nsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &snd_dbri_ops);\r\nsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &snd_dbri_ops);\r\npcm->private_data = card->private_data;\r\npcm->info_flags = 0;\r\nstrcpy(pcm->name, card->shortname);\r\nif ((err = snd_pcm_lib_preallocate_pages_for_all(pcm,\r\nSNDRV_DMA_TYPE_CONTINUOUS,\r\nsnd_dma_continuous_data(GFP_KERNEL),\r\n64 * 1024, 64 * 1024)) < 0)\r\nreturn err;\r\nreturn 0;\r\n}\r\nstatic int snd_cs4215_info_volume(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\r\nuinfo->count = 2;\r\nuinfo->value.integer.min = 0;\r\nif (kcontrol->private_value == DBRI_PLAY)\r\nuinfo->value.integer.max = DBRI_MAX_VOLUME;\r\nelse\r\nuinfo->value.integer.max = DBRI_MAX_GAIN;\r\nreturn 0;\r\n}\r\nstatic int snd_cs4215_get_volume(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_dbri *dbri = snd_kcontrol_chip(kcontrol);\r\nstruct dbri_streaminfo *info;\r\nif (snd_BUG_ON(!dbri))\r\nreturn -EINVAL;\r\ninfo = &dbri->stream_info[kcontrol->private_value];\r\nucontrol->value.integer.value[0] = info->left_gain;\r\nucontrol->value.integer.value[1] = info->right_gain;\r\nreturn 0;\r\n}\r\nstatic int snd_cs4215_put_volume(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_dbri *dbri = snd_kcontrol_chip(kcontrol);\r\nstruct dbri_streaminfo *info =\r\n&dbri->stream_info[kcontrol->private_value];\r\nunsigned int vol[2];\r\nint changed = 0;\r\nvol[0] = ucontrol->value.integer.value[0];\r\nvol[1] = ucontrol->value.integer.value[1];\r\nif (kcontrol->private_value == DBRI_PLAY) {\r\nif (vol[0] > DBRI_MAX_VOLUME || vol[1] > DBRI_MAX_VOLUME)\r\nreturn -EINVAL;\r\n} else {\r\nif (vol[0] > DBRI_MAX_GAIN || vol[1] > DBRI_MAX_GAIN)\r\nreturn -EINVAL;\r\n}\r\nif (info->left_gain != vol[0]) {\r\ninfo->left_gain = vol[0];\r\nchanged = 1;\r\n}\r\nif (info->right_gain != vol[1]) {\r\ninfo->right_gain = vol[1];\r\nchanged = 1;\r\n}\r\nif (changed) {\r\ncs4215_setdata(dbri, 1);\r\nudelay(125);\r\ncs4215_setdata(dbri, 0);\r\n}\r\nreturn changed;\r\n}\r\nstatic int snd_cs4215_info_single(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nint mask = (kcontrol->private_value >> 16) & 0xff;\r\nuinfo->type = (mask == 1) ?\r\nSNDRV_CTL_ELEM_TYPE_BOOLEAN : SNDRV_CTL_ELEM_TYPE_INTEGER;\r\nuinfo->count = 1;\r\nuinfo->value.integer.min = 0;\r\nuinfo->value.integer.max = mask;\r\nreturn 0;\r\n}\r\nstatic int snd_cs4215_get_single(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_dbri *dbri = snd_kcontrol_chip(kcontrol);\r\nint elem = kcontrol->private_value & 0xff;\r\nint shift = (kcontrol->private_value >> 8) & 0xff;\r\nint mask = (kcontrol->private_value >> 16) & 0xff;\r\nint invert = (kcontrol->private_value >> 24) & 1;\r\nif (snd_BUG_ON(!dbri))\r\nreturn -EINVAL;\r\nif (elem < 4)\r\nucontrol->value.integer.value[0] =\r\n(dbri->mm.data[elem] >> shift) & mask;\r\nelse\r\nucontrol->value.integer.value[0] =\r\n(dbri->mm.ctrl[elem - 4] >> shift) & mask;\r\nif (invert == 1)\r\nucontrol->value.integer.value[0] =\r\nmask - ucontrol->value.integer.value[0];\r\nreturn 0;\r\n}\r\nstatic int snd_cs4215_put_single(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_dbri *dbri = snd_kcontrol_chip(kcontrol);\r\nint elem = kcontrol->private_value & 0xff;\r\nint shift = (kcontrol->private_value >> 8) & 0xff;\r\nint mask = (kcontrol->private_value >> 16) & 0xff;\r\nint invert = (kcontrol->private_value >> 24) & 1;\r\nint changed = 0;\r\nunsigned short val;\r\nif (snd_BUG_ON(!dbri))\r\nreturn -EINVAL;\r\nval = (ucontrol->value.integer.value[0] & mask);\r\nif (invert == 1)\r\nval = mask - val;\r\nval <<= shift;\r\nif (elem < 4) {\r\ndbri->mm.data[elem] = (dbri->mm.data[elem] &\r\n~(mask << shift)) | val;\r\nchanged = (val != dbri->mm.data[elem]);\r\n} else {\r\ndbri->mm.ctrl[elem - 4] = (dbri->mm.ctrl[elem - 4] &\r\n~(mask << shift)) | val;\r\nchanged = (val != dbri->mm.ctrl[elem - 4]);\r\n}\r\ndprintk(D_GEN, "put_single: mask=0x%x, changed=%d, "\r\n"mixer-value=%ld, mm-value=0x%x\n",\r\nmask, changed, ucontrol->value.integer.value[0],\r\ndbri->mm.data[elem & 3]);\r\nif (changed) {\r\ncs4215_setdata(dbri, 1);\r\nudelay(125);\r\ncs4215_setdata(dbri, 0);\r\n}\r\nreturn changed;\r\n}\r\nstatic int snd_dbri_mixer(struct snd_card *card)\r\n{\r\nint idx, err;\r\nstruct snd_dbri *dbri;\r\nif (snd_BUG_ON(!card || !card->private_data))\r\nreturn -EINVAL;\r\ndbri = card->private_data;\r\nstrcpy(card->mixername, card->shortname);\r\nfor (idx = 0; idx < ARRAY_SIZE(dbri_controls); idx++) {\r\nerr = snd_ctl_add(card,\r\nsnd_ctl_new1(&dbri_controls[idx], dbri));\r\nif (err < 0)\r\nreturn err;\r\n}\r\nfor (idx = DBRI_REC; idx < DBRI_NO_STREAMS; idx++) {\r\ndbri->stream_info[idx].left_gain = 0;\r\ndbri->stream_info[idx].right_gain = 0;\r\n}\r\nreturn 0;\r\n}\r\nstatic void dbri_regs_read(struct snd_info_entry *entry,\r\nstruct snd_info_buffer *buffer)\r\n{\r\nstruct snd_dbri *dbri = entry->private_data;\r\nsnd_iprintf(buffer, "REG0: 0x%x\n", sbus_readl(dbri->regs + REG0));\r\nsnd_iprintf(buffer, "REG2: 0x%x\n", sbus_readl(dbri->regs + REG2));\r\nsnd_iprintf(buffer, "REG8: 0x%x\n", sbus_readl(dbri->regs + REG8));\r\nsnd_iprintf(buffer, "REG9: 0x%x\n", sbus_readl(dbri->regs + REG9));\r\n}\r\nstatic void dbri_debug_read(struct snd_info_entry *entry,\r\nstruct snd_info_buffer *buffer)\r\n{\r\nstruct snd_dbri *dbri = entry->private_data;\r\nint pipe;\r\nsnd_iprintf(buffer, "debug=%d\n", dbri_debug);\r\nfor (pipe = 0; pipe < 32; pipe++) {\r\nif (pipe_active(dbri, pipe)) {\r\nstruct dbri_pipe *pptr = &dbri->pipes[pipe];\r\nsnd_iprintf(buffer,\r\n"Pipe %d: %s SDP=0x%x desc=%d, "\r\n"len=%d next %d\n",\r\npipe,\r\n(pptr->sdp & D_SDP_TO_SER) ? "output" :\r\n"input",\r\npptr->sdp, pptr->desc,\r\npptr->length, pptr->nextpipe);\r\n}\r\n}\r\n}\r\nstatic void snd_dbri_proc(struct snd_card *card)\r\n{\r\nstruct snd_dbri *dbri = card->private_data;\r\nstruct snd_info_entry *entry;\r\nif (!snd_card_proc_new(card, "regs", &entry))\r\nsnd_info_set_text_ops(entry, dbri, dbri_regs_read);\r\n#ifdef DBRI_DEBUG\r\nif (!snd_card_proc_new(card, "debug", &entry)) {\r\nsnd_info_set_text_ops(entry, dbri, dbri_debug_read);\r\nentry->mode = S_IFREG | S_IRUGO;\r\n}\r\n#endif\r\n}\r\nstatic int snd_dbri_create(struct snd_card *card,\r\nstruct platform_device *op,\r\nint irq, int dev)\r\n{\r\nstruct snd_dbri *dbri = card->private_data;\r\nint err;\r\nspin_lock_init(&dbri->lock);\r\ndbri->op = op;\r\ndbri->irq = irq;\r\ndbri->dma = dma_alloc_coherent(&op->dev,\r\nsizeof(struct dbri_dma),\r\n&dbri->dma_dvma, GFP_ATOMIC);\r\nif (!dbri->dma)\r\nreturn -ENOMEM;\r\nmemset((void *)dbri->dma, 0, sizeof(struct dbri_dma));\r\ndprintk(D_GEN, "DMA Cmd Block 0x%p (0x%08x)\n",\r\ndbri->dma, dbri->dma_dvma);\r\ndbri->regs_size = resource_size(&op->resource[0]);\r\ndbri->regs = of_ioremap(&op->resource[0], 0,\r\ndbri->regs_size, "DBRI Registers");\r\nif (!dbri->regs) {\r\nprintk(KERN_ERR "DBRI: could not allocate registers\n");\r\ndma_free_coherent(&op->dev, sizeof(struct dbri_dma),\r\n(void *)dbri->dma, dbri->dma_dvma);\r\nreturn -EIO;\r\n}\r\nerr = request_irq(dbri->irq, snd_dbri_interrupt, IRQF_SHARED,\r\n"DBRI audio", dbri);\r\nif (err) {\r\nprintk(KERN_ERR "DBRI: Can't get irq %d\n", dbri->irq);\r\nof_iounmap(&op->resource[0], dbri->regs, dbri->regs_size);\r\ndma_free_coherent(&op->dev, sizeof(struct dbri_dma),\r\n(void *)dbri->dma, dbri->dma_dvma);\r\nreturn err;\r\n}\r\ndbri_initialize(dbri);\r\nerr = cs4215_init(dbri);\r\nif (err) {\r\nsnd_dbri_free(dbri);\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic void snd_dbri_free(struct snd_dbri *dbri)\r\n{\r\ndprintk(D_GEN, "snd_dbri_free\n");\r\ndbri_reset(dbri);\r\nif (dbri->irq)\r\nfree_irq(dbri->irq, dbri);\r\nif (dbri->regs)\r\nof_iounmap(&dbri->op->resource[0], dbri->regs, dbri->regs_size);\r\nif (dbri->dma)\r\ndma_free_coherent(&dbri->op->dev,\r\nsizeof(struct dbri_dma),\r\n(void *)dbri->dma, dbri->dma_dvma);\r\n}\r\nstatic int dbri_probe(struct platform_device *op)\r\n{\r\nstruct snd_dbri *dbri;\r\nstruct resource *rp;\r\nstruct snd_card *card;\r\nstatic int dev = 0;\r\nint irq;\r\nint err;\r\nif (dev >= SNDRV_CARDS)\r\nreturn -ENODEV;\r\nif (!enable[dev]) {\r\ndev++;\r\nreturn -ENOENT;\r\n}\r\nirq = op->archdata.irqs[0];\r\nif (irq <= 0) {\r\nprintk(KERN_ERR "DBRI-%d: No IRQ.\n", dev);\r\nreturn -ENODEV;\r\n}\r\nerr = snd_card_create(index[dev], id[dev], THIS_MODULE,\r\nsizeof(struct snd_dbri), &card);\r\nif (err < 0)\r\nreturn err;\r\nstrcpy(card->driver, "DBRI");\r\nstrcpy(card->shortname, "Sun DBRI");\r\nrp = &op->resource[0];\r\nsprintf(card->longname, "%s at 0x%02lx:0x%016Lx, irq %d",\r\ncard->shortname,\r\nrp->flags & 0xffL, (unsigned long long)rp->start, irq);\r\nerr = snd_dbri_create(card, op, irq, dev);\r\nif (err < 0) {\r\nsnd_card_free(card);\r\nreturn err;\r\n}\r\ndbri = card->private_data;\r\nerr = snd_dbri_pcm(card);\r\nif (err < 0)\r\ngoto _err;\r\nerr = snd_dbri_mixer(card);\r\nif (err < 0)\r\ngoto _err;\r\nsnd_dbri_proc(card);\r\ndev_set_drvdata(&op->dev, card);\r\nerr = snd_card_register(card);\r\nif (err < 0)\r\ngoto _err;\r\nprintk(KERN_INFO "audio%d at %p (irq %d) is DBRI(%c)+CS4215(%d)\n",\r\ndev, dbri->regs,\r\ndbri->irq, op->dev.of_node->name[9], dbri->mm.version);\r\ndev++;\r\nreturn 0;\r\n_err:\r\nsnd_dbri_free(dbri);\r\nsnd_card_free(card);\r\nreturn err;\r\n}\r\nstatic int dbri_remove(struct platform_device *op)\r\n{\r\nstruct snd_card *card = dev_get_drvdata(&op->dev);\r\nsnd_dbri_free(card->private_data);\r\nsnd_card_free(card);\r\ndev_set_drvdata(&op->dev, NULL);\r\nreturn 0;\r\n}
