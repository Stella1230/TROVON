static int atbm8830_write_reg(struct atbm_state *priv, u16 reg, u8 data)\r\n{\r\nint ret = 0;\r\nu8 dev_addr;\r\nu8 buf1[] = { reg >> 8, reg & 0xFF };\r\nu8 buf2[] = { data };\r\nstruct i2c_msg msg1 = { .flags = 0, .buf = buf1, .len = 2 };\r\nstruct i2c_msg msg2 = { .flags = 0, .buf = buf2, .len = 1 };\r\ndev_addr = priv->config->demod_address;\r\nmsg1.addr = dev_addr;\r\nmsg2.addr = dev_addr;\r\nif (debug >= 2)\r\ndprintk("%s: reg=0x%04X, data=0x%02X\n", __func__, reg, data);\r\nret = i2c_transfer(priv->i2c, &msg1, 1);\r\nif (ret != 1)\r\nreturn -EIO;\r\nret = i2c_transfer(priv->i2c, &msg2, 1);\r\nreturn (ret != 1) ? -EIO : 0;\r\n}\r\nstatic int atbm8830_read_reg(struct atbm_state *priv, u16 reg, u8 *p_data)\r\n{\r\nint ret;\r\nu8 dev_addr;\r\nu8 buf1[] = { reg >> 8, reg & 0xFF };\r\nu8 buf2[] = { 0 };\r\nstruct i2c_msg msg1 = { .flags = 0, .buf = buf1, .len = 2 };\r\nstruct i2c_msg msg2 = { .flags = I2C_M_RD, .buf = buf2, .len = 1 };\r\ndev_addr = priv->config->demod_address;\r\nmsg1.addr = dev_addr;\r\nmsg2.addr = dev_addr;\r\nret = i2c_transfer(priv->i2c, &msg1, 1);\r\nif (ret != 1) {\r\ndprintk("%s: error reg=0x%04x, ret=%i\n", __func__, reg, ret);\r\nreturn -EIO;\r\n}\r\nret = i2c_transfer(priv->i2c, &msg2, 1);\r\nif (ret != 1)\r\nreturn -EIO;\r\n*p_data = buf2[0];\r\nif (debug >= 2)\r\ndprintk("%s: reg=0x%04X, data=0x%02X\n",\r\n__func__, reg, buf2[0]);\r\nreturn 0;\r\n}\r\nstatic inline int atbm8830_reglatch_lock(struct atbm_state *priv, int lock)\r\n{\r\nreturn atbm8830_write_reg(priv, REG_READ_LATCH, lock ? 1 : 0);\r\n}\r\nstatic int set_osc_freq(struct atbm_state *priv, u32 freq )\r\n{\r\nu32 val;\r\nu64 t;\r\nt = (u64)0x100000 * freq;\r\ndo_div(t, 30400);\r\nval = t;\r\natbm8830_write_reg(priv, REG_OSC_CLK, val);\r\natbm8830_write_reg(priv, REG_OSC_CLK + 1, val >> 8);\r\natbm8830_write_reg(priv, REG_OSC_CLK + 2, val >> 16);\r\nreturn 0;\r\n}\r\nstatic int set_if_freq(struct atbm_state *priv, u32 freq )\r\n{\r\nu32 fs = priv->config->osc_clk_freq;\r\nu64 t;\r\nu32 val;\r\nu8 dat;\r\nif (freq != 0) {\r\nt = (u64) 2 * 31416 * (freq - fs);\r\nt <<= 22;\r\ndo_div(t, fs);\r\ndo_div(t, 1000);\r\nval = t;\r\natbm8830_write_reg(priv, REG_TUNER_BASEBAND, 1);\r\natbm8830_write_reg(priv, REG_IF_FREQ, val);\r\natbm8830_write_reg(priv, REG_IF_FREQ+1, val >> 8);\r\natbm8830_write_reg(priv, REG_IF_FREQ+2, val >> 16);\r\natbm8830_read_reg(priv, REG_ADC_CONFIG, &dat);\r\ndat &= 0xFC;\r\natbm8830_write_reg(priv, REG_ADC_CONFIG, dat);\r\n} else {\r\natbm8830_write_reg(priv, REG_TUNER_BASEBAND, 0);\r\natbm8830_read_reg(priv, REG_ADC_CONFIG, &dat);\r\ndat &= 0xFC;\r\ndat |= 0x02;\r\natbm8830_write_reg(priv, REG_ADC_CONFIG, dat);\r\nif (priv->config->zif_swap_iq)\r\natbm8830_write_reg(priv, REG_SWAP_I_Q, 0x03);\r\nelse\r\natbm8830_write_reg(priv, REG_SWAP_I_Q, 0x01);\r\n}\r\nreturn 0;\r\n}\r\nstatic int is_locked(struct atbm_state *priv, u8 *locked)\r\n{\r\nu8 status;\r\natbm8830_read_reg(priv, REG_LOCK_STATUS, &status);\r\nif (locked != NULL)\r\n*locked = (status == 1);\r\nreturn 0;\r\n}\r\nstatic int set_agc_config(struct atbm_state *priv,\r\nu8 min, u8 max, u8 hold_loop)\r\n{\r\nif (!min && !max)\r\nreturn 0;\r\natbm8830_write_reg(priv, REG_AGC_MIN, min);\r\natbm8830_write_reg(priv, REG_AGC_MAX, max);\r\natbm8830_write_reg(priv, REG_AGC_HOLD_LOOP, hold_loop);\r\nreturn 0;\r\n}\r\nstatic int set_static_channel_mode(struct atbm_state *priv)\r\n{\r\nint i;\r\nfor (i = 0; i < 5; i++)\r\natbm8830_write_reg(priv, 0x099B + i, 0x08);\r\natbm8830_write_reg(priv, 0x095B, 0x7F);\r\natbm8830_write_reg(priv, 0x09CB, 0x01);\r\natbm8830_write_reg(priv, 0x09CC, 0x7F);\r\natbm8830_write_reg(priv, 0x09CD, 0x7F);\r\natbm8830_write_reg(priv, 0x0E01, 0x20);\r\natbm8830_write_reg(priv, 0x0B03, 0x0A);\r\natbm8830_write_reg(priv, 0x0935, 0x10);\r\natbm8830_write_reg(priv, 0x0936, 0x08);\r\natbm8830_write_reg(priv, 0x093E, 0x08);\r\natbm8830_write_reg(priv, 0x096E, 0x06);\r\natbm8830_write_reg(priv, 0x0B09, 0x00);\r\natbm8830_write_reg(priv, 0x0B0A, 0x08);\r\nreturn 0;\r\n}\r\nstatic int set_ts_config(struct atbm_state *priv)\r\n{\r\nconst struct atbm8830_config *cfg = priv->config;\r\natbm8830_write_reg(priv, REG_TS_SERIAL, cfg->serial_ts ? 1 : 0);\r\natbm8830_write_reg(priv, REG_TS_CLK_MODE, cfg->serial_ts ? 1 : 0);\r\natbm8830_write_reg(priv, REG_TS_SAMPLE_EDGE,\r\ncfg->ts_sampling_edge ? 1 : 0);\r\natbm8830_write_reg(priv, REG_TS_CLK_FREERUN,\r\ncfg->ts_clk_gated ? 0 : 1);\r\nreturn 0;\r\n}\r\nstatic int atbm8830_init(struct dvb_frontend *fe)\r\n{\r\nstruct atbm_state *priv = fe->demodulator_priv;\r\nconst struct atbm8830_config *cfg = priv->config;\r\nset_osc_freq(priv, cfg->osc_clk_freq);\r\nset_if_freq(priv, cfg->if_freq);\r\nset_agc_config(priv, cfg->agc_min, cfg->agc_max,\r\ncfg->agc_hold_loop);\r\nset_static_channel_mode(priv);\r\nset_ts_config(priv);\r\natbm8830_write_reg(priv, 0x000A, 0);\r\natbm8830_write_reg(priv, 0x020C, 11);\r\natbm8830_write_reg(priv, REG_DEMOD_RUN, 1);\r\nreturn 0;\r\n}\r\nstatic void atbm8830_release(struct dvb_frontend *fe)\r\n{\r\nstruct atbm_state *state = fe->demodulator_priv;\r\ndprintk("%s\n", __func__);\r\nkfree(state);\r\n}\r\nstatic int atbm8830_set_fe(struct dvb_frontend *fe)\r\n{\r\nstruct atbm_state *priv = fe->demodulator_priv;\r\nint i;\r\nu8 locked = 0;\r\ndprintk("%s\n", __func__);\r\nif (fe->ops.tuner_ops.set_params) {\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 1);\r\nfe->ops.tuner_ops.set_params(fe);\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 0);\r\n}\r\nfor (i = 0; i < 10; i++) {\r\nmdelay(100);\r\ndprintk("Try %d\n", i);\r\nis_locked(priv, &locked);\r\nif (locked != 0) {\r\ndprintk("ATBM8830 locked!\n");\r\nbreak;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int atbm8830_get_fe(struct dvb_frontend *fe)\r\n{\r\nstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\r\ndprintk("%s\n", __func__);\r\nc->inversion = INVERSION_OFF;\r\nc->bandwidth_hz = 8000000;\r\nc->code_rate_HP = FEC_AUTO;\r\nc->code_rate_LP = FEC_AUTO;\r\nc->modulation = QAM_AUTO;\r\nc->transmission_mode = TRANSMISSION_MODE_AUTO;\r\nc->guard_interval = GUARD_INTERVAL_AUTO;\r\nc->hierarchy = HIERARCHY_NONE;\r\nreturn 0;\r\n}\r\nstatic int atbm8830_get_tune_settings(struct dvb_frontend *fe,\r\nstruct dvb_frontend_tune_settings *fesettings)\r\n{\r\nfesettings->min_delay_ms = 0;\r\nfesettings->step_size = 0;\r\nfesettings->max_drift = 0;\r\nreturn 0;\r\n}\r\nstatic int atbm8830_read_status(struct dvb_frontend *fe, fe_status_t *fe_status)\r\n{\r\nstruct atbm_state *priv = fe->demodulator_priv;\r\nu8 locked = 0;\r\nu8 agc_locked = 0;\r\ndprintk("%s\n", __func__);\r\n*fe_status = 0;\r\nis_locked(priv, &locked);\r\nif (locked) {\r\n*fe_status |= FE_HAS_SIGNAL | FE_HAS_CARRIER |\r\nFE_HAS_VITERBI | FE_HAS_SYNC | FE_HAS_LOCK;\r\n}\r\ndprintk("%s: fe_status=0x%x\n", __func__, *fe_status);\r\natbm8830_read_reg(priv, REG_AGC_LOCK, &agc_locked);\r\ndprintk("AGC Lock: %d\n", agc_locked);\r\nreturn 0;\r\n}\r\nstatic int atbm8830_read_ber(struct dvb_frontend *fe, u32 *ber)\r\n{\r\nstruct atbm_state *priv = fe->demodulator_priv;\r\nu32 frame_err;\r\nu8 t;\r\ndprintk("%s\n", __func__);\r\natbm8830_reglatch_lock(priv, 1);\r\natbm8830_read_reg(priv, REG_FRAME_ERR_CNT + 1, &t);\r\nframe_err = t & 0x7F;\r\nframe_err <<= 8;\r\natbm8830_read_reg(priv, REG_FRAME_ERR_CNT, &t);\r\nframe_err |= t;\r\natbm8830_reglatch_lock(priv, 0);\r\n*ber = frame_err * 100 / 32767;\r\ndprintk("%s: ber=0x%x\n", __func__, *ber);\r\nreturn 0;\r\n}\r\nstatic int atbm8830_read_signal_strength(struct dvb_frontend *fe, u16 *signal)\r\n{\r\nstruct atbm_state *priv = fe->demodulator_priv;\r\nu32 pwm;\r\nu8 t;\r\ndprintk("%s\n", __func__);\r\natbm8830_reglatch_lock(priv, 1);\r\natbm8830_read_reg(priv, REG_AGC_PWM_VAL + 1, &t);\r\npwm = t & 0x03;\r\npwm <<= 8;\r\natbm8830_read_reg(priv, REG_AGC_PWM_VAL, &t);\r\npwm |= t;\r\natbm8830_reglatch_lock(priv, 0);\r\ndprintk("AGC PWM = 0x%02X\n", pwm);\r\npwm = 0x400 - pwm;\r\n*signal = pwm * 0x10000 / 0x400;\r\nreturn 0;\r\n}\r\nstatic int atbm8830_read_snr(struct dvb_frontend *fe, u16 *snr)\r\n{\r\ndprintk("%s\n", __func__);\r\n*snr = 0;\r\nreturn 0;\r\n}\r\nstatic int atbm8830_read_ucblocks(struct dvb_frontend *fe, u32 *ucblocks)\r\n{\r\ndprintk("%s\n", __func__);\r\n*ucblocks = 0;\r\nreturn 0;\r\n}\r\nstatic int atbm8830_i2c_gate_ctrl(struct dvb_frontend *fe, int enable)\r\n{\r\nstruct atbm_state *priv = fe->demodulator_priv;\r\nreturn atbm8830_write_reg(priv, REG_I2C_GATE, enable ? 1 : 0);\r\n}\r\nstruct dvb_frontend *atbm8830_attach(const struct atbm8830_config *config,\r\nstruct i2c_adapter *i2c)\r\n{\r\nstruct atbm_state *priv = NULL;\r\nu8 data = 0;\r\ndprintk("%s()\n", __func__);\r\nif (config == NULL || i2c == NULL)\r\nreturn NULL;\r\npriv = kzalloc(sizeof(struct atbm_state), GFP_KERNEL);\r\nif (priv == NULL)\r\ngoto error_out;\r\npriv->config = config;\r\npriv->i2c = i2c;\r\nif (atbm8830_read_reg(priv, REG_CHIP_ID, &data) != 0) {\r\ndprintk("%s atbm8830/8831 not found at i2c addr 0x%02X\n",\r\n__func__, priv->config->demod_address);\r\ngoto error_out;\r\n}\r\ndprintk("atbm8830 chip id: 0x%02X\n", data);\r\nmemcpy(&priv->frontend.ops, &atbm8830_ops,\r\nsizeof(struct dvb_frontend_ops));\r\npriv->frontend.demodulator_priv = priv;\r\natbm8830_init(&priv->frontend);\r\natbm8830_i2c_gate_ctrl(&priv->frontend, 1);\r\nreturn &priv->frontend;\r\nerror_out:\r\ndprintk("%s() error_out\n", __func__);\r\nkfree(priv);\r\nreturn NULL;\r\n}
