static inline struct pluto *feed_to_pluto(struct dvb_demux_feed *feed)\r\n{\r\nreturn container_of(feed->demux, struct pluto, demux);\r\n}\r\nstatic inline struct pluto *frontend_to_pluto(struct dvb_frontend *fe)\r\n{\r\nreturn container_of(fe->dvb, struct pluto, dvb_adapter);\r\n}\r\nstatic inline u32 pluto_readreg(struct pluto *pluto, u32 reg)\r\n{\r\nreturn readl(&pluto->io_mem[reg]);\r\n}\r\nstatic inline void pluto_writereg(struct pluto *pluto, u32 reg, u32 val)\r\n{\r\nwritel(val, &pluto->io_mem[reg]);\r\n}\r\nstatic inline void pluto_rw(struct pluto *pluto, u32 reg, u32 mask, u32 bits)\r\n{\r\nu32 val = readl(&pluto->io_mem[reg]);\r\nval &= ~mask;\r\nval |= bits;\r\nwritel(val, &pluto->io_mem[reg]);\r\n}\r\nstatic void pluto_write_tscr(struct pluto *pluto, u32 val)\r\n{\r\nval &= ~TSCR_ADEF;\r\nval |= TS_DMA_PACKETS / 2;\r\npluto_writereg(pluto, REG_TSCR, val);\r\n}\r\nstatic void pluto_setsda(void *data, int state)\r\n{\r\nstruct pluto *pluto = data;\r\nif (state)\r\npluto_rw(pluto, REG_SLCS, SLCS_SDA, SLCS_SDA);\r\nelse\r\npluto_rw(pluto, REG_SLCS, SLCS_SDA, 0);\r\n}\r\nstatic void pluto_setscl(void *data, int state)\r\n{\r\nstruct pluto *pluto = data;\r\nif (state)\r\npluto_rw(pluto, REG_SLCS, SLCS_SCL, SLCS_SCL);\r\nelse\r\npluto_rw(pluto, REG_SLCS, SLCS_SCL, 0);\r\nif ((state) && (pluto->i2cbug == 0)) {\r\npluto->i2cbug = 1;\r\n} else {\r\nif ((!state) && (pluto->i2cbug == 1))\r\npluto_setsda(pluto, 1);\r\npluto->i2cbug = 0;\r\n}\r\n}\r\nstatic int pluto_getsda(void *data)\r\n{\r\nstruct pluto *pluto = data;\r\nreturn pluto_readreg(pluto, REG_SLCS) & SLCS_SDA;\r\n}\r\nstatic int pluto_getscl(void *data)\r\n{\r\nstruct pluto *pluto = data;\r\nreturn pluto_readreg(pluto, REG_SLCS) & SLCS_SCL;\r\n}\r\nstatic void pluto_reset_frontend(struct pluto *pluto, int reenable)\r\n{\r\nu32 val = pluto_readreg(pluto, REG_MISC);\r\nif (val & MISC_FRST) {\r\nval &= ~MISC_FRST;\r\npluto_writereg(pluto, REG_MISC, val);\r\n}\r\nif (reenable) {\r\nval |= MISC_FRST;\r\npluto_writereg(pluto, REG_MISC, val);\r\n}\r\n}\r\nstatic void pluto_reset_ts(struct pluto *pluto, int reenable)\r\n{\r\nu32 val = pluto_readreg(pluto, REG_TSCR);\r\nif (val & TSCR_RSTN) {\r\nval &= ~TSCR_RSTN;\r\npluto_write_tscr(pluto, val);\r\n}\r\nif (reenable) {\r\nval |= TSCR_RSTN;\r\npluto_write_tscr(pluto, val);\r\n}\r\n}\r\nstatic void pluto_set_dma_addr(struct pluto *pluto)\r\n{\r\npluto_writereg(pluto, REG_PCAR, pluto->dma_addr);\r\n}\r\nstatic int pluto_dma_map(struct pluto *pluto)\r\n{\r\npluto->dma_addr = pci_map_single(pluto->pdev, pluto->dma_buf,\r\nTS_DMA_BYTES, PCI_DMA_FROMDEVICE);\r\nreturn pci_dma_mapping_error(pluto->pdev, pluto->dma_addr);\r\n}\r\nstatic void pluto_dma_unmap(struct pluto *pluto)\r\n{\r\npci_unmap_single(pluto->pdev, pluto->dma_addr,\r\nTS_DMA_BYTES, PCI_DMA_FROMDEVICE);\r\n}\r\nstatic int pluto_start_feed(struct dvb_demux_feed *f)\r\n{\r\nstruct pluto *pluto = feed_to_pluto(f);\r\nif (pluto->users++ == 0)\r\npluto_rw(pluto, REG_PIDn(0), PID0_AFIL | PID0_NOFIL, 0);\r\nif ((f->pid < 0x2000) && (f->index < NHWFILTERS))\r\npluto_rw(pluto, REG_PIDn(f->index), PIDn_ENP | PIDn_PID, PIDn_ENP | f->pid);\r\nelse if (pluto->full_ts_users++ == 0)\r\npluto_rw(pluto, REG_PIDn(0), PID0_NOFIL, PID0_NOFIL);\r\nreturn 0;\r\n}\r\nstatic int pluto_stop_feed(struct dvb_demux_feed *f)\r\n{\r\nstruct pluto *pluto = feed_to_pluto(f);\r\nif (--pluto->users == 0)\r\npluto_rw(pluto, REG_PIDn(0), PID0_AFIL, PID0_AFIL);\r\nif ((f->pid < 0x2000) && (f->index < NHWFILTERS))\r\npluto_rw(pluto, REG_PIDn(f->index), PIDn_ENP | PIDn_PID, 0x1fff);\r\nelse if (--pluto->full_ts_users == 0)\r\npluto_rw(pluto, REG_PIDn(0), PID0_NOFIL, 0);\r\nreturn 0;\r\n}\r\nstatic void pluto_dma_end(struct pluto *pluto, unsigned int nbpackets)\r\n{\r\npci_dma_sync_single_for_cpu(pluto->pdev, pluto->dma_addr,\r\nTS_DMA_BYTES, PCI_DMA_FROMDEVICE);\r\nif ((nbpackets == 0) || (nbpackets > TS_DMA_PACKETS)) {\r\nunsigned int i = 0;\r\nwhile (pluto->dma_buf[i] == 0x47)\r\ni += 188;\r\nnbpackets = i / 188;\r\nif (i == 0) {\r\npluto_reset_ts(pluto, 1);\r\ndev_printk(KERN_DEBUG, &pluto->pdev->dev, "resetting TS because of invalid packet counter\n");\r\n}\r\n}\r\ndvb_dmx_swfilter_packets(&pluto->demux, pluto->dma_buf, nbpackets);\r\nmemset(pluto->dma_buf, 0, nbpackets * 188);\r\npluto_set_dma_addr(pluto);\r\npci_dma_sync_single_for_device(pluto->pdev, pluto->dma_addr,\r\nTS_DMA_BYTES, PCI_DMA_FROMDEVICE);\r\n}\r\nstatic irqreturn_t pluto_irq(int irq, void *dev_id)\r\n{\r\nstruct pluto *pluto = dev_id;\r\nu32 tscr;\r\ntscr = pluto_readreg(pluto, REG_TSCR);\r\nif (!(tscr & (TSCR_DE | TSCR_OVR)))\r\nreturn IRQ_NONE;\r\nif (tscr == 0xffffffff) {\r\nif (pluto->dead == 0)\r\ndev_err(&pluto->pdev->dev, "card has hung or been ejected.\n");\r\npluto->dead = 1;\r\nreturn IRQ_HANDLED;\r\n}\r\nif (tscr & TSCR_DE) {\r\npluto_dma_end(pluto, (tscr & TSCR_NBPACKETS) >> 24);\r\nif (tscr & TSCR_OVR)\r\npluto->overflow++;\r\nif (pluto->overflow) {\r\ndev_err(&pluto->pdev->dev, "overflow irq (%d)\n",\r\npluto->overflow);\r\npluto_reset_ts(pluto, 1);\r\npluto->overflow = 0;\r\n}\r\n} else if (tscr & TSCR_OVR) {\r\npluto->overflow++;\r\n}\r\npluto_write_tscr(pluto, tscr | TSCR_IACK);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void pluto_enable_irqs(struct pluto *pluto)\r\n{\r\nu32 val = pluto_readreg(pluto, REG_TSCR);\r\nval |= (TSCR_MSKA | TSCR_MSKL);\r\nval &= ~(TSCR_DEM | TSCR_MSKO);\r\nval |= TSCR_IACK;\r\npluto_write_tscr(pluto, val);\r\n}\r\nstatic void pluto_disable_irqs(struct pluto *pluto)\r\n{\r\nu32 val = pluto_readreg(pluto, REG_TSCR);\r\nval |= (TSCR_DEM | TSCR_MSKO | TSCR_MSKA | TSCR_MSKL);\r\nval |= TSCR_IACK;\r\npluto_write_tscr(pluto, val);\r\n}\r\nstatic int pluto_hw_init(struct pluto *pluto)\r\n{\r\npluto_reset_frontend(pluto, 1);\r\npluto_rw(pluto, REG_MISC, MISC_ALED, MISC_ALED);\r\n#ifdef __LITTLE_ENDIAN\r\npluto_rw(pluto, REG_PIDn(0), PID0_END, PID0_END);\r\n#else\r\npluto_rw(pluto, REG_PIDn(0), PID0_END, 0);\r\n#endif\r\npluto_dma_map(pluto);\r\npluto_set_dma_addr(pluto);\r\npluto_enable_irqs(pluto);\r\npluto_reset_ts(pluto, 1);\r\nreturn 0;\r\n}\r\nstatic void pluto_hw_exit(struct pluto *pluto)\r\n{\r\npluto_disable_irqs(pluto);\r\npluto_reset_ts(pluto, 0);\r\npluto_rw(pluto, REG_MISC, MISC_ALED | MISC_LED1 | MISC_LED0, MISC_LED1);\r\npluto_dma_unmap(pluto);\r\npluto_reset_frontend(pluto, 0);\r\n}\r\nstatic inline u32 divide(u32 numerator, u32 denominator)\r\n{\r\nif (denominator == 0)\r\nreturn ~0;\r\nreturn DIV_ROUND_CLOSEST(numerator, denominator);\r\n}\r\nstatic int lg_tdtpe001p_tuner_set_params(struct dvb_frontend *fe)\r\n{\r\nstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\r\nstruct pluto *pluto = frontend_to_pluto(fe);\r\nstruct i2c_msg msg;\r\nint ret;\r\nu8 buf[4];\r\nu32 div;\r\ndiv = divide(p->frequency * 3, 500000) + 217;\r\nbuf[0] = (div >> 8) & 0x7f;\r\nbuf[1] = (div >> 0) & 0xff;\r\nif (p->frequency < 611000000)\r\nbuf[2] = 0xb4;\r\nelse if (p->frequency < 811000000)\r\nbuf[2] = 0xbc;\r\nelse\r\nbuf[2] = 0xf4;\r\nif (p->frequency < 350000000)\r\nbuf[3] = 0x02;\r\nelse\r\nbuf[3] = 0x04;\r\nif (p->bandwidth_hz == 8000000)\r\nbuf[3] |= 0x08;\r\nmsg.addr = I2C_ADDR_TUA6034 >> 1;\r\nmsg.flags = 0;\r\nmsg.buf = buf;\r\nmsg.len = sizeof(buf);\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 1);\r\nret = i2c_transfer(&pluto->i2c_adap, &msg, 1);\r\nif (ret < 0)\r\nreturn ret;\r\nelse if (ret == 0)\r\nreturn -EREMOTEIO;\r\nreturn 0;\r\n}\r\nstatic int pluto2_request_firmware(struct dvb_frontend *fe,\r\nconst struct firmware **fw, char *name)\r\n{\r\nstruct pluto *pluto = frontend_to_pluto(fe);\r\nreturn request_firmware(fw, name, &pluto->pdev->dev);\r\n}\r\nstatic int frontend_init(struct pluto *pluto)\r\n{\r\nint ret;\r\npluto->fe = tda10046_attach(&pluto2_fe_config, &pluto->i2c_adap);\r\nif (!pluto->fe) {\r\ndev_err(&pluto->pdev->dev, "could not attach frontend\n");\r\nreturn -ENODEV;\r\n}\r\npluto->fe->ops.tuner_ops.set_params = lg_tdtpe001p_tuner_set_params;\r\nret = dvb_register_frontend(&pluto->dvb_adapter, pluto->fe);\r\nif (ret < 0) {\r\nif (pluto->fe->ops.release)\r\npluto->fe->ops.release(pluto->fe);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic void pluto_read_rev(struct pluto *pluto)\r\n{\r\nu32 val = pluto_readreg(pluto, REG_MISC) & MISC_DVR;\r\ndev_info(&pluto->pdev->dev, "board revision %d.%d\n",\r\n(val >> 12) & 0x0f, (val >> 4) & 0xff);\r\n}\r\nstatic void pluto_read_mac(struct pluto *pluto, u8 *mac)\r\n{\r\nu32 val = pluto_readreg(pluto, REG_MMAC);\r\nmac[0] = (val >> 8) & 0xff;\r\nmac[1] = (val >> 0) & 0xff;\r\nval = pluto_readreg(pluto, REG_IMAC);\r\nmac[2] = (val >> 8) & 0xff;\r\nmac[3] = (val >> 0) & 0xff;\r\nval = pluto_readreg(pluto, REG_LMAC);\r\nmac[4] = (val >> 8) & 0xff;\r\nmac[5] = (val >> 0) & 0xff;\r\ndev_info(&pluto->pdev->dev, "MAC %pM\n", mac);\r\n}\r\nstatic int pluto_read_serial(struct pluto *pluto)\r\n{\r\nstruct pci_dev *pdev = pluto->pdev;\r\nunsigned int i, j;\r\nu8 __iomem *cis;\r\ncis = pci_iomap(pdev, 1, 0);\r\nif (!cis)\r\nreturn -EIO;\r\ndev_info(&pdev->dev, "S/N ");\r\nfor (i = 0xe0; i < 0x100; i += 4) {\r\nu32 val = readl(&cis[i]);\r\nfor (j = 0; j < 32; j += 8) {\r\nif ((val & 0xff) == 0xff)\r\ngoto out;\r\nprintk("%c", val & 0xff);\r\nval >>= 8;\r\n}\r\n}\r\nout:\r\nprintk("\n");\r\npci_iounmap(pdev, cis);\r\nreturn 0;\r\n}\r\nstatic int pluto2_probe(struct pci_dev *pdev, const struct pci_device_id *ent)\r\n{\r\nstruct pluto *pluto;\r\nstruct dvb_adapter *dvb_adapter;\r\nstruct dvb_demux *dvbdemux;\r\nstruct dmx_demux *dmx;\r\nint ret = -ENOMEM;\r\npluto = kzalloc(sizeof(struct pluto), GFP_KERNEL);\r\nif (!pluto)\r\ngoto out;\r\npluto->pdev = pdev;\r\nret = pci_enable_device(pdev);\r\nif (ret < 0)\r\ngoto err_kfree;\r\npci_write_config_dword(pdev, 0x6c, 0x8000);\r\nret = pci_set_dma_mask(pdev, DMA_BIT_MASK(32));\r\nif (ret < 0)\r\ngoto err_pci_disable_device;\r\npci_set_master(pdev);\r\nret = pci_request_regions(pdev, DRIVER_NAME);\r\nif (ret < 0)\r\ngoto err_pci_disable_device;\r\npluto->io_mem = pci_iomap(pdev, 0, 0x40);\r\nif (!pluto->io_mem) {\r\nret = -EIO;\r\ngoto err_pci_release_regions;\r\n}\r\npci_set_drvdata(pdev, pluto);\r\nret = request_irq(pdev->irq, pluto_irq, IRQF_SHARED, DRIVER_NAME, pluto);\r\nif (ret < 0)\r\ngoto err_pci_iounmap;\r\nret = pluto_hw_init(pluto);\r\nif (ret < 0)\r\ngoto err_free_irq;\r\ni2c_set_adapdata(&pluto->i2c_adap, pluto);\r\nstrcpy(pluto->i2c_adap.name, DRIVER_NAME);\r\npluto->i2c_adap.owner = THIS_MODULE;\r\npluto->i2c_adap.dev.parent = &pdev->dev;\r\npluto->i2c_adap.algo_data = &pluto->i2c_bit;\r\npluto->i2c_bit.data = pluto;\r\npluto->i2c_bit.setsda = pluto_setsda;\r\npluto->i2c_bit.setscl = pluto_setscl;\r\npluto->i2c_bit.getsda = pluto_getsda;\r\npluto->i2c_bit.getscl = pluto_getscl;\r\npluto->i2c_bit.udelay = 10;\r\npluto->i2c_bit.timeout = 10;\r\npluto_setsda(pluto, 1);\r\npluto_setscl(pluto, 1);\r\nret = i2c_bit_add_bus(&pluto->i2c_adap);\r\nif (ret < 0)\r\ngoto err_pluto_hw_exit;\r\nret = dvb_register_adapter(&pluto->dvb_adapter, DRIVER_NAME,\r\nTHIS_MODULE, &pdev->dev, adapter_nr);\r\nif (ret < 0)\r\ngoto err_i2c_del_adapter;\r\ndvb_adapter = &pluto->dvb_adapter;\r\npluto_read_rev(pluto);\r\npluto_read_serial(pluto);\r\npluto_read_mac(pluto, dvb_adapter->proposed_mac);\r\ndvbdemux = &pluto->demux;\r\ndvbdemux->filternum = 256;\r\ndvbdemux->feednum = 256;\r\ndvbdemux->start_feed = pluto_start_feed;\r\ndvbdemux->stop_feed = pluto_stop_feed;\r\ndvbdemux->dmx.capabilities = (DMX_TS_FILTERING |\r\nDMX_SECTION_FILTERING | DMX_MEMORY_BASED_FILTERING);\r\nret = dvb_dmx_init(dvbdemux);\r\nif (ret < 0)\r\ngoto err_dvb_unregister_adapter;\r\ndmx = &dvbdemux->dmx;\r\npluto->hw_frontend.source = DMX_FRONTEND_0;\r\npluto->mem_frontend.source = DMX_MEMORY_FE;\r\npluto->dmxdev.filternum = NHWFILTERS;\r\npluto->dmxdev.demux = dmx;\r\nret = dvb_dmxdev_init(&pluto->dmxdev, dvb_adapter);\r\nif (ret < 0)\r\ngoto err_dvb_dmx_release;\r\nret = dmx->add_frontend(dmx, &pluto->hw_frontend);\r\nif (ret < 0)\r\ngoto err_dvb_dmxdev_release;\r\nret = dmx->add_frontend(dmx, &pluto->mem_frontend);\r\nif (ret < 0)\r\ngoto err_remove_hw_frontend;\r\nret = dmx->connect_frontend(dmx, &pluto->hw_frontend);\r\nif (ret < 0)\r\ngoto err_remove_mem_frontend;\r\nret = frontend_init(pluto);\r\nif (ret < 0)\r\ngoto err_disconnect_frontend;\r\ndvb_net_init(dvb_adapter, &pluto->dvbnet, dmx);\r\nout:\r\nreturn ret;\r\nerr_disconnect_frontend:\r\ndmx->disconnect_frontend(dmx);\r\nerr_remove_mem_frontend:\r\ndmx->remove_frontend(dmx, &pluto->mem_frontend);\r\nerr_remove_hw_frontend:\r\ndmx->remove_frontend(dmx, &pluto->hw_frontend);\r\nerr_dvb_dmxdev_release:\r\ndvb_dmxdev_release(&pluto->dmxdev);\r\nerr_dvb_dmx_release:\r\ndvb_dmx_release(dvbdemux);\r\nerr_dvb_unregister_adapter:\r\ndvb_unregister_adapter(dvb_adapter);\r\nerr_i2c_del_adapter:\r\ni2c_del_adapter(&pluto->i2c_adap);\r\nerr_pluto_hw_exit:\r\npluto_hw_exit(pluto);\r\nerr_free_irq:\r\nfree_irq(pdev->irq, pluto);\r\nerr_pci_iounmap:\r\npci_iounmap(pdev, pluto->io_mem);\r\nerr_pci_release_regions:\r\npci_release_regions(pdev);\r\nerr_pci_disable_device:\r\npci_disable_device(pdev);\r\nerr_kfree:\r\npci_set_drvdata(pdev, NULL);\r\nkfree(pluto);\r\ngoto out;\r\n}\r\nstatic void pluto2_remove(struct pci_dev *pdev)\r\n{\r\nstruct pluto *pluto = pci_get_drvdata(pdev);\r\nstruct dvb_adapter *dvb_adapter = &pluto->dvb_adapter;\r\nstruct dvb_demux *dvbdemux = &pluto->demux;\r\nstruct dmx_demux *dmx = &dvbdemux->dmx;\r\ndmx->close(dmx);\r\ndvb_net_release(&pluto->dvbnet);\r\nif (pluto->fe)\r\ndvb_unregister_frontend(pluto->fe);\r\ndmx->disconnect_frontend(dmx);\r\ndmx->remove_frontend(dmx, &pluto->mem_frontend);\r\ndmx->remove_frontend(dmx, &pluto->hw_frontend);\r\ndvb_dmxdev_release(&pluto->dmxdev);\r\ndvb_dmx_release(dvbdemux);\r\ndvb_unregister_adapter(dvb_adapter);\r\ni2c_del_adapter(&pluto->i2c_adap);\r\npluto_hw_exit(pluto);\r\nfree_irq(pdev->irq, pluto);\r\npci_iounmap(pdev, pluto->io_mem);\r\npci_release_regions(pdev);\r\npci_disable_device(pdev);\r\npci_set_drvdata(pdev, NULL);\r\nkfree(pluto);\r\n}\r\nstatic int __init pluto2_init(void)\r\n{\r\nreturn pci_register_driver(&pluto2_driver);\r\n}\r\nstatic void __exit pluto2_exit(void)\r\n{\r\npci_unregister_driver(&pluto2_driver);\r\n}
