static void if_usb_write_bulk_callback(struct urb *urb)\r\n{\r\nstruct if_usb_card *cardp = (struct if_usb_card *) urb->context;\r\nif (urb->status == 0) {\r\nstruct lbs_private *priv = cardp->priv;\r\nlbs_deb_usb2(&urb->dev->dev, "URB status is successful\n");\r\nlbs_deb_usb2(&urb->dev->dev, "Actual length transmitted %d\n",\r\nurb->actual_length);\r\nif (priv && priv->dnld_sent != DNLD_BOOTCMD_SENT)\r\nlbs_host_to_card_done(priv);\r\n} else {\r\npr_info("URB in failure status: %d\n", urb->status);\r\n}\r\n}\r\nstatic void if_usb_free(struct if_usb_card *cardp)\r\n{\r\nlbs_deb_enter(LBS_DEB_USB);\r\nusb_kill_urb(cardp->tx_urb);\r\nusb_kill_urb(cardp->rx_urb);\r\nusb_free_urb(cardp->tx_urb);\r\ncardp->tx_urb = NULL;\r\nusb_free_urb(cardp->rx_urb);\r\ncardp->rx_urb = NULL;\r\nkfree(cardp->ep_out_buf);\r\ncardp->ep_out_buf = NULL;\r\nlbs_deb_leave(LBS_DEB_USB);\r\n}\r\nstatic void if_usb_setup_firmware(struct lbs_private *priv)\r\n{\r\nstruct if_usb_card *cardp = priv->card;\r\nstruct cmd_ds_set_boot2_ver b2_cmd;\r\nstruct cmd_ds_802_11_fw_wake_method wake_method;\r\nb2_cmd.hdr.size = cpu_to_le16(sizeof(b2_cmd));\r\nb2_cmd.action = 0;\r\nb2_cmd.version = cardp->boot2_version;\r\nif (lbs_cmd_with_response(priv, CMD_SET_BOOT2_VER, &b2_cmd))\r\nlbs_deb_usb("Setting boot2 version failed\n");\r\npriv->wol_gpio = 2;\r\npriv->wol_gap = 20;\r\nlbs_host_sleep_cfg(priv, EHS_WAKE_ON_UNICAST_DATA,\r\n(struct wol_config *) NULL);\r\nwake_method.hdr.size = cpu_to_le16(sizeof(wake_method));\r\nwake_method.action = cpu_to_le16(CMD_ACT_GET);\r\nif (lbs_cmd_with_response(priv, CMD_802_11_FW_WAKE_METHOD, &wake_method)) {\r\nnetdev_info(priv->dev, "Firmware does not seem to support PS mode\n");\r\npriv->fwcapinfo &= ~FW_CAPINFO_PS;\r\n} else {\r\nif (le16_to_cpu(wake_method.method) == CMD_WAKE_METHOD_COMMAND_INT) {\r\nlbs_deb_usb("Firmware seems to support PS with wake-via-command\n");\r\n} else {\r\npriv->fwcapinfo &= ~FW_CAPINFO_PS;\r\nnetdev_info(priv->dev,\r\n"Firmware doesn't wake via command interrupt; disabling PS mode\n");\r\n}\r\n}\r\n}\r\nstatic void if_usb_fw_timeo(unsigned long priv)\r\n{\r\nstruct if_usb_card *cardp = (void *)priv;\r\nif (cardp->fwdnldover) {\r\nlbs_deb_usb("Download complete, no event. Assuming success\n");\r\n} else {\r\npr_err("Download timed out\n");\r\ncardp->surprise_removed = 1;\r\n}\r\nwake_up(&cardp->fw_wq);\r\n}\r\nstatic void if_usb_reset_olpc_card(struct lbs_private *priv)\r\n{\r\nprintk(KERN_CRIT "Resetting OLPC wireless via EC...\n");\r\nolpc_ec_cmd(0x25, NULL, 0, NULL, 0);\r\n}\r\nstatic int if_usb_probe(struct usb_interface *intf,\r\nconst struct usb_device_id *id)\r\n{\r\nstruct usb_device *udev;\r\nstruct usb_host_interface *iface_desc;\r\nstruct usb_endpoint_descriptor *endpoint;\r\nstruct lbs_private *priv;\r\nstruct if_usb_card *cardp;\r\nint r = -ENOMEM;\r\nint i;\r\nudev = interface_to_usbdev(intf);\r\ncardp = kzalloc(sizeof(struct if_usb_card), GFP_KERNEL);\r\nif (!cardp)\r\ngoto error;\r\nsetup_timer(&cardp->fw_timeout, if_usb_fw_timeo, (unsigned long)cardp);\r\ninit_waitqueue_head(&cardp->fw_wq);\r\ncardp->udev = udev;\r\ncardp->model = (uint32_t) id->driver_info;\r\niface_desc = intf->cur_altsetting;\r\nlbs_deb_usbd(&udev->dev, "bcdUSB = 0x%X bDeviceClass = 0x%X"\r\n" bDeviceSubClass = 0x%X, bDeviceProtocol = 0x%X\n",\r\nle16_to_cpu(udev->descriptor.bcdUSB),\r\nudev->descriptor.bDeviceClass,\r\nudev->descriptor.bDeviceSubClass,\r\nudev->descriptor.bDeviceProtocol);\r\nfor (i = 0; i < iface_desc->desc.bNumEndpoints; ++i) {\r\nendpoint = &iface_desc->endpoint[i].desc;\r\nif (usb_endpoint_is_bulk_in(endpoint)) {\r\ncardp->ep_in_size = le16_to_cpu(endpoint->wMaxPacketSize);\r\ncardp->ep_in = usb_endpoint_num(endpoint);\r\nlbs_deb_usbd(&udev->dev, "in_endpoint = %d\n", cardp->ep_in);\r\nlbs_deb_usbd(&udev->dev, "Bulk in size is %d\n", cardp->ep_in_size);\r\n} else if (usb_endpoint_is_bulk_out(endpoint)) {\r\ncardp->ep_out_size = le16_to_cpu(endpoint->wMaxPacketSize);\r\ncardp->ep_out = usb_endpoint_num(endpoint);\r\nlbs_deb_usbd(&udev->dev, "out_endpoint = %d\n", cardp->ep_out);\r\nlbs_deb_usbd(&udev->dev, "Bulk out size is %d\n", cardp->ep_out_size);\r\n}\r\n}\r\nif (!cardp->ep_out_size || !cardp->ep_in_size) {\r\nlbs_deb_usbd(&udev->dev, "Endpoints not found\n");\r\ngoto dealloc;\r\n}\r\nif (!(cardp->rx_urb = usb_alloc_urb(0, GFP_KERNEL))) {\r\nlbs_deb_usbd(&udev->dev, "Rx URB allocation failed\n");\r\ngoto dealloc;\r\n}\r\nif (!(cardp->tx_urb = usb_alloc_urb(0, GFP_KERNEL))) {\r\nlbs_deb_usbd(&udev->dev, "Tx URB allocation failed\n");\r\ngoto dealloc;\r\n}\r\ncardp->ep_out_buf = kmalloc(MRVDRV_ETH_TX_PACKET_BUFFER_SIZE, GFP_KERNEL);\r\nif (!cardp->ep_out_buf) {\r\nlbs_deb_usbd(&udev->dev, "Could not allocate buffer\n");\r\ngoto dealloc;\r\n}\r\nif (!(priv = lbs_add_card(cardp, &intf->dev)))\r\ngoto err_add_card;\r\ncardp->priv = priv;\r\npriv->hw_host_to_card = if_usb_host_to_card;\r\npriv->enter_deep_sleep = NULL;\r\npriv->exit_deep_sleep = NULL;\r\npriv->reset_deep_sleep_wakeup = NULL;\r\n#ifdef CONFIG_OLPC\r\nif (machine_is_olpc())\r\npriv->reset_card = if_usb_reset_olpc_card;\r\n#endif\r\ncardp->boot2_version = udev->descriptor.bcdDevice;\r\nusb_get_dev(udev);\r\nusb_set_intfdata(intf, cardp);\r\nr = lbs_get_firmware_async(priv, &udev->dev, cardp->model,\r\nfw_table, if_usb_prog_firmware);\r\nif (r)\r\ngoto err_get_fw;\r\nreturn 0;\r\nerr_get_fw:\r\nlbs_remove_card(priv);\r\nerr_add_card:\r\nif_usb_reset_device(cardp);\r\ndealloc:\r\nif_usb_free(cardp);\r\nerror:\r\nreturn r;\r\n}\r\nstatic void if_usb_disconnect(struct usb_interface *intf)\r\n{\r\nstruct if_usb_card *cardp = usb_get_intfdata(intf);\r\nstruct lbs_private *priv = cardp->priv;\r\nlbs_deb_enter(LBS_DEB_MAIN);\r\ncardp->surprise_removed = 1;\r\nif (priv) {\r\nlbs_stop_card(priv);\r\nlbs_remove_card(priv);\r\n}\r\nif_usb_free(cardp);\r\nusb_set_intfdata(intf, NULL);\r\nusb_put_dev(interface_to_usbdev(intf));\r\nlbs_deb_leave(LBS_DEB_MAIN);\r\n}\r\nstatic int if_usb_send_fw_pkt(struct if_usb_card *cardp)\r\n{\r\nstruct fwdata *fwdata = cardp->ep_out_buf;\r\nconst uint8_t *firmware = cardp->fw->data;\r\nif (!cardp->CRC_OK) {\r\ncardp->totalbytes = cardp->fwlastblksent;\r\ncardp->fwseqnum--;\r\n}\r\nlbs_deb_usb2(&cardp->udev->dev, "totalbytes = %d\n",\r\ncardp->totalbytes);\r\nmemcpy(&fwdata->hdr, &firmware[cardp->totalbytes],\r\nsizeof(struct fwheader));\r\ncardp->fwlastblksent = cardp->totalbytes;\r\ncardp->totalbytes += sizeof(struct fwheader);\r\nmemcpy(fwdata->data, &firmware[cardp->totalbytes],\r\nle32_to_cpu(fwdata->hdr.datalength));\r\nlbs_deb_usb2(&cardp->udev->dev, "Data length = %d\n",\r\nle32_to_cpu(fwdata->hdr.datalength));\r\nfwdata->seqnum = cpu_to_le32(++cardp->fwseqnum);\r\ncardp->totalbytes += le32_to_cpu(fwdata->hdr.datalength);\r\nusb_tx_block(cardp, cardp->ep_out_buf, sizeof(struct fwdata) +\r\nle32_to_cpu(fwdata->hdr.datalength));\r\nif (fwdata->hdr.dnldcmd == cpu_to_le32(FW_HAS_DATA_TO_RECV)) {\r\nlbs_deb_usb2(&cardp->udev->dev, "There are data to follow\n");\r\nlbs_deb_usb2(&cardp->udev->dev, "seqnum = %d totalbytes = %d\n",\r\ncardp->fwseqnum, cardp->totalbytes);\r\n} else if (fwdata->hdr.dnldcmd == cpu_to_le32(FW_HAS_LAST_BLOCK)) {\r\nlbs_deb_usb2(&cardp->udev->dev, "Host has finished FW downloading\n");\r\nlbs_deb_usb2(&cardp->udev->dev, "Donwloading FW JUMP BLOCK\n");\r\ncardp->fwfinalblk = 1;\r\n}\r\nlbs_deb_usb2(&cardp->udev->dev, "Firmware download done; size %d\n",\r\ncardp->totalbytes);\r\nreturn 0;\r\n}\r\nstatic int if_usb_reset_device(struct if_usb_card *cardp)\r\n{\r\nstruct cmd_header *cmd = cardp->ep_out_buf + 4;\r\nint ret;\r\nlbs_deb_enter(LBS_DEB_USB);\r\n*(__le32 *)cardp->ep_out_buf = cpu_to_le32(CMD_TYPE_REQUEST);\r\ncmd->command = cpu_to_le16(CMD_802_11_RESET);\r\ncmd->size = cpu_to_le16(sizeof(cmd));\r\ncmd->result = cpu_to_le16(0);\r\ncmd->seqnum = cpu_to_le16(0x5a5a);\r\nusb_tx_block(cardp, cardp->ep_out_buf, 4 + sizeof(struct cmd_header));\r\nmsleep(100);\r\nret = usb_reset_device(cardp->udev);\r\nmsleep(100);\r\n#ifdef CONFIG_OLPC\r\nif (ret && machine_is_olpc())\r\nif_usb_reset_olpc_card(NULL);\r\n#endif\r\nlbs_deb_leave_args(LBS_DEB_USB, "ret %d", ret);\r\nreturn ret;\r\n}\r\nstatic int usb_tx_block(struct if_usb_card *cardp, uint8_t *payload, uint16_t nb)\r\n{\r\nint ret;\r\nif (cardp->surprise_removed) {\r\nlbs_deb_usbd(&cardp->udev->dev, "Device removed\n");\r\nret = -ENODEV;\r\ngoto tx_ret;\r\n}\r\nusb_fill_bulk_urb(cardp->tx_urb, cardp->udev,\r\nusb_sndbulkpipe(cardp->udev,\r\ncardp->ep_out),\r\npayload, nb, if_usb_write_bulk_callback, cardp);\r\ncardp->tx_urb->transfer_flags |= URB_ZERO_PACKET;\r\nif ((ret = usb_submit_urb(cardp->tx_urb, GFP_ATOMIC))) {\r\nlbs_deb_usbd(&cardp->udev->dev, "usb_submit_urb failed: %d\n", ret);\r\n} else {\r\nlbs_deb_usb2(&cardp->udev->dev, "usb_submit_urb success\n");\r\nret = 0;\r\n}\r\ntx_ret:\r\nreturn ret;\r\n}\r\nstatic int __if_usb_submit_rx_urb(struct if_usb_card *cardp,\r\nvoid (*callbackfn)(struct urb *urb))\r\n{\r\nstruct sk_buff *skb;\r\nint ret = -1;\r\nif (!(skb = dev_alloc_skb(MRVDRV_ETH_RX_PACKET_BUFFER_SIZE))) {\r\npr_err("No free skb\n");\r\ngoto rx_ret;\r\n}\r\ncardp->rx_skb = skb;\r\nusb_fill_bulk_urb(cardp->rx_urb, cardp->udev,\r\nusb_rcvbulkpipe(cardp->udev, cardp->ep_in),\r\nskb->data + IPFIELD_ALIGN_OFFSET,\r\nMRVDRV_ETH_RX_PACKET_BUFFER_SIZE, callbackfn,\r\ncardp);\r\ncardp->rx_urb->transfer_flags |= URB_ZERO_PACKET;\r\nlbs_deb_usb2(&cardp->udev->dev, "Pointer for rx_urb %p\n", cardp->rx_urb);\r\nif ((ret = usb_submit_urb(cardp->rx_urb, GFP_ATOMIC))) {\r\nlbs_deb_usbd(&cardp->udev->dev, "Submit Rx URB failed: %d\n", ret);\r\nkfree_skb(skb);\r\ncardp->rx_skb = NULL;\r\nret = -1;\r\n} else {\r\nlbs_deb_usb2(&cardp->udev->dev, "Submit Rx URB success\n");\r\nret = 0;\r\n}\r\nrx_ret:\r\nreturn ret;\r\n}\r\nstatic int if_usb_submit_rx_urb_fwload(struct if_usb_card *cardp)\r\n{\r\nreturn __if_usb_submit_rx_urb(cardp, &if_usb_receive_fwload);\r\n}\r\nstatic int if_usb_submit_rx_urb(struct if_usb_card *cardp)\r\n{\r\nreturn __if_usb_submit_rx_urb(cardp, &if_usb_receive);\r\n}\r\nstatic void if_usb_receive_fwload(struct urb *urb)\r\n{\r\nstruct if_usb_card *cardp = urb->context;\r\nstruct sk_buff *skb = cardp->rx_skb;\r\nstruct fwsyncheader *syncfwheader;\r\nstruct bootcmdresp bootcmdresp;\r\nif (urb->status) {\r\nlbs_deb_usbd(&cardp->udev->dev,\r\n"URB status is failed during fw load\n");\r\nkfree_skb(skb);\r\nreturn;\r\n}\r\nif (cardp->fwdnldover) {\r\n__le32 *tmp = (__le32 *)(skb->data + IPFIELD_ALIGN_OFFSET);\r\nif (tmp[0] == cpu_to_le32(CMD_TYPE_INDICATION) &&\r\ntmp[1] == cpu_to_le32(MACREG_INT_CODE_FIRMWARE_READY)) {\r\npr_info("Firmware ready event received\n");\r\nwake_up(&cardp->fw_wq);\r\n} else {\r\nlbs_deb_usb("Waiting for confirmation; got %x %x\n",\r\nle32_to_cpu(tmp[0]), le32_to_cpu(tmp[1]));\r\nif_usb_submit_rx_urb_fwload(cardp);\r\n}\r\nkfree_skb(skb);\r\nreturn;\r\n}\r\nif (cardp->bootcmdresp <= 0) {\r\nmemcpy (&bootcmdresp, skb->data + IPFIELD_ALIGN_OFFSET,\r\nsizeof(bootcmdresp));\r\nif (le16_to_cpu(cardp->udev->descriptor.bcdDevice) < 0x3106) {\r\nkfree_skb(skb);\r\nif_usb_submit_rx_urb_fwload(cardp);\r\ncardp->bootcmdresp = BOOT_CMD_RESP_OK;\r\nlbs_deb_usbd(&cardp->udev->dev,\r\n"Received valid boot command response\n");\r\nreturn;\r\n}\r\nif (bootcmdresp.magic != cpu_to_le32(BOOT_CMD_MAGIC_NUMBER)) {\r\nif (bootcmdresp.magic == cpu_to_le32(CMD_TYPE_REQUEST) ||\r\nbootcmdresp.magic == cpu_to_le32(CMD_TYPE_DATA) ||\r\nbootcmdresp.magic == cpu_to_le32(CMD_TYPE_INDICATION)) {\r\nif (!cardp->bootcmdresp)\r\npr_info("Firmware already seems alive; resetting\n");\r\ncardp->bootcmdresp = -1;\r\n} else {\r\npr_info("boot cmd response wrong magic number (0x%x)\n",\r\nle32_to_cpu(bootcmdresp.magic));\r\n}\r\n} else if ((bootcmdresp.cmd != BOOT_CMD_FW_BY_USB) &&\r\n(bootcmdresp.cmd != BOOT_CMD_UPDATE_FW) &&\r\n(bootcmdresp.cmd != BOOT_CMD_UPDATE_BOOT2)) {\r\npr_info("boot cmd response cmd_tag error (%d)\n",\r\nbootcmdresp.cmd);\r\n} else if (bootcmdresp.result != BOOT_CMD_RESP_OK) {\r\npr_info("boot cmd response result error (%d)\n",\r\nbootcmdresp.result);\r\n} else {\r\ncardp->bootcmdresp = 1;\r\nlbs_deb_usbd(&cardp->udev->dev,\r\n"Received valid boot command response\n");\r\n}\r\nkfree_skb(skb);\r\nif_usb_submit_rx_urb_fwload(cardp);\r\nreturn;\r\n}\r\nsyncfwheader = kmemdup(skb->data + IPFIELD_ALIGN_OFFSET,\r\nsizeof(struct fwsyncheader), GFP_ATOMIC);\r\nif (!syncfwheader) {\r\nlbs_deb_usbd(&cardp->udev->dev, "Failure to allocate syncfwheader\n");\r\nkfree_skb(skb);\r\nreturn;\r\n}\r\nif (!syncfwheader->cmd) {\r\nlbs_deb_usb2(&cardp->udev->dev, "FW received Blk with correct CRC\n");\r\nlbs_deb_usb2(&cardp->udev->dev, "FW received Blk seqnum = %d\n",\r\nle32_to_cpu(syncfwheader->seqnum));\r\ncardp->CRC_OK = 1;\r\n} else {\r\nlbs_deb_usbd(&cardp->udev->dev, "FW received Blk with CRC error\n");\r\ncardp->CRC_OK = 0;\r\n}\r\nkfree_skb(skb);\r\nmod_timer(&cardp->fw_timeout, jiffies + (HZ*5));\r\nif (cardp->fwfinalblk) {\r\ncardp->fwdnldover = 1;\r\ngoto exit;\r\n}\r\nif_usb_send_fw_pkt(cardp);\r\nexit:\r\nif_usb_submit_rx_urb_fwload(cardp);\r\nkfree(syncfwheader);\r\n}\r\nstatic inline void process_cmdtypedata(int recvlength, struct sk_buff *skb,\r\nstruct if_usb_card *cardp,\r\nstruct lbs_private *priv)\r\n{\r\nif (recvlength > MRVDRV_ETH_RX_PACKET_BUFFER_SIZE + MESSAGE_HEADER_LEN\r\n|| recvlength < MRVDRV_MIN_PKT_LEN) {\r\nlbs_deb_usbd(&cardp->udev->dev, "Packet length is Invalid\n");\r\nkfree_skb(skb);\r\nreturn;\r\n}\r\nskb_reserve(skb, IPFIELD_ALIGN_OFFSET);\r\nskb_put(skb, recvlength);\r\nskb_pull(skb, MESSAGE_HEADER_LEN);\r\nlbs_process_rxed_packet(priv, skb);\r\n}\r\nstatic inline void process_cmdrequest(int recvlength, uint8_t *recvbuff,\r\nstruct sk_buff *skb,\r\nstruct if_usb_card *cardp,\r\nstruct lbs_private *priv)\r\n{\r\nu8 i;\r\nif (recvlength > LBS_CMD_BUFFER_SIZE) {\r\nlbs_deb_usbd(&cardp->udev->dev,\r\n"The receive buffer is too large\n");\r\nkfree_skb(skb);\r\nreturn;\r\n}\r\nBUG_ON(!in_interrupt());\r\nspin_lock(&priv->driver_lock);\r\ni = (priv->resp_idx == 0) ? 1 : 0;\r\nBUG_ON(priv->resp_len[i]);\r\npriv->resp_len[i] = (recvlength - MESSAGE_HEADER_LEN);\r\nmemcpy(priv->resp_buf[i], recvbuff + MESSAGE_HEADER_LEN,\r\npriv->resp_len[i]);\r\nkfree_skb(skb);\r\nlbs_notify_command_response(priv, i);\r\nspin_unlock(&priv->driver_lock);\r\nlbs_deb_usbd(&cardp->udev->dev,\r\n"Wake up main thread to handle cmd response\n");\r\n}\r\nstatic void if_usb_receive(struct urb *urb)\r\n{\r\nstruct if_usb_card *cardp = urb->context;\r\nstruct sk_buff *skb = cardp->rx_skb;\r\nstruct lbs_private *priv = cardp->priv;\r\nint recvlength = urb->actual_length;\r\nuint8_t *recvbuff = NULL;\r\nuint32_t recvtype = 0;\r\n__le32 *pkt = (__le32 *)(skb->data + IPFIELD_ALIGN_OFFSET);\r\nuint32_t event;\r\nlbs_deb_enter(LBS_DEB_USB);\r\nif (recvlength) {\r\nif (urb->status) {\r\nlbs_deb_usbd(&cardp->udev->dev, "RX URB failed: %d\n",\r\nurb->status);\r\nkfree_skb(skb);\r\ngoto setup_for_next;\r\n}\r\nrecvbuff = skb->data + IPFIELD_ALIGN_OFFSET;\r\nrecvtype = le32_to_cpu(pkt[0]);\r\nlbs_deb_usbd(&cardp->udev->dev,\r\n"Recv length = 0x%x, Recv type = 0x%X\n",\r\nrecvlength, recvtype);\r\n} else if (urb->status) {\r\nkfree_skb(skb);\r\ngoto rx_exit;\r\n}\r\nswitch (recvtype) {\r\ncase CMD_TYPE_DATA:\r\nprocess_cmdtypedata(recvlength, skb, cardp, priv);\r\nbreak;\r\ncase CMD_TYPE_REQUEST:\r\nprocess_cmdrequest(recvlength, recvbuff, skb, cardp, priv);\r\nbreak;\r\ncase CMD_TYPE_INDICATION:\r\nevent = le32_to_cpu(pkt[1]);\r\nlbs_deb_usbd(&cardp->udev->dev, "**EVENT** 0x%X\n", event);\r\nkfree_skb(skb);\r\nif (event & 0xffff0000) {\r\nu32 trycount = (event & 0xffff0000) >> 16;\r\nlbs_send_tx_feedback(priv, trycount);\r\n} else\r\nlbs_queue_event(priv, event & 0xFF);\r\nbreak;\r\ndefault:\r\nlbs_deb_usbd(&cardp->udev->dev, "Unknown command type 0x%X\n",\r\nrecvtype);\r\nkfree_skb(skb);\r\nbreak;\r\n}\r\nsetup_for_next:\r\nif_usb_submit_rx_urb(cardp);\r\nrx_exit:\r\nlbs_deb_leave(LBS_DEB_USB);\r\n}\r\nstatic int if_usb_host_to_card(struct lbs_private *priv, uint8_t type,\r\nuint8_t *payload, uint16_t nb)\r\n{\r\nstruct if_usb_card *cardp = priv->card;\r\nlbs_deb_usbd(&cardp->udev->dev,"*** type = %u\n", type);\r\nlbs_deb_usbd(&cardp->udev->dev,"size after = %d\n", nb);\r\nif (type == MVMS_CMD) {\r\n*(__le32 *)cardp->ep_out_buf = cpu_to_le32(CMD_TYPE_REQUEST);\r\npriv->dnld_sent = DNLD_CMD_SENT;\r\n} else {\r\n*(__le32 *)cardp->ep_out_buf = cpu_to_le32(CMD_TYPE_DATA);\r\npriv->dnld_sent = DNLD_DATA_SENT;\r\n}\r\nmemcpy((cardp->ep_out_buf + MESSAGE_HEADER_LEN), payload, nb);\r\nreturn usb_tx_block(cardp, cardp->ep_out_buf, nb + MESSAGE_HEADER_LEN);\r\n}\r\nstatic int if_usb_issue_boot_command(struct if_usb_card *cardp, int ivalue)\r\n{\r\nstruct bootcmd *bootcmd = cardp->ep_out_buf;\r\nbootcmd->magic = cpu_to_le32(BOOT_CMD_MAGIC_NUMBER);\r\nbootcmd->cmd = ivalue;\r\nmemset(bootcmd->pad, 0, sizeof(bootcmd->pad));\r\nusb_tx_block(cardp, cardp->ep_out_buf, sizeof(*bootcmd));\r\nreturn 0;\r\n}\r\nstatic int check_fwfile_format(const uint8_t *data, uint32_t totlen)\r\n{\r\nuint32_t bincmd, exit;\r\nuint32_t blksize, offset, len;\r\nint ret;\r\nret = 1;\r\nexit = len = 0;\r\ndo {\r\nstruct fwheader *fwh = (void *)data;\r\nbincmd = le32_to_cpu(fwh->dnldcmd);\r\nblksize = le32_to_cpu(fwh->datalength);\r\nswitch (bincmd) {\r\ncase FW_HAS_DATA_TO_RECV:\r\noffset = sizeof(struct fwheader) + blksize;\r\ndata += offset;\r\nlen += offset;\r\nif (len >= totlen)\r\nexit = 1;\r\nbreak;\r\ncase FW_HAS_LAST_BLOCK:\r\nexit = 1;\r\nret = 0;\r\nbreak;\r\ndefault:\r\nexit = 1;\r\nbreak;\r\n}\r\n} while (!exit);\r\nif (ret)\r\npr_err("firmware file format check FAIL\n");\r\nelse\r\nlbs_deb_fw("firmware file format check PASS\n");\r\nreturn ret;\r\n}\r\nstatic void if_usb_prog_firmware(struct lbs_private *priv, int ret,\r\nconst struct firmware *fw,\r\nconst struct firmware *unused)\r\n{\r\nstruct if_usb_card *cardp = priv->card;\r\nint i = 0;\r\nstatic int reset_count = 10;\r\nlbs_deb_enter(LBS_DEB_USB);\r\nif (ret) {\r\npr_err("failed to find firmware (%d)\n", ret);\r\ngoto done;\r\n}\r\ncardp->fw = fw;\r\nif (check_fwfile_format(cardp->fw->data, cardp->fw->size)) {\r\nret = -EINVAL;\r\ngoto release_fw;\r\n}\r\nusb_kill_urb(cardp->rx_urb);\r\nusb_kill_urb(cardp->tx_urb);\r\ncardp->fwlastblksent = 0;\r\ncardp->fwdnldover = 0;\r\ncardp->totalbytes = 0;\r\ncardp->fwfinalblk = 0;\r\ncardp->bootcmdresp = 0;\r\nrestart:\r\nif (if_usb_submit_rx_urb_fwload(cardp) < 0) {\r\nlbs_deb_usbd(&cardp->udev->dev, "URB submission is failed\n");\r\nret = -EIO;\r\ngoto release_fw;\r\n}\r\ncardp->bootcmdresp = 0;\r\ndo {\r\nint j = 0;\r\ni++;\r\nif_usb_issue_boot_command(cardp, BOOT_CMD_FW_BY_USB);\r\ndo {\r\nj++;\r\nmsleep_interruptible(100);\r\n} while (cardp->bootcmdresp == 0 && j < 10);\r\n} while (cardp->bootcmdresp == 0 && i < 5);\r\nif (cardp->bootcmdresp == BOOT_CMD_RESP_NOT_SUPPORTED) {\r\nret = -EOPNOTSUPP;\r\nusb_kill_urb(cardp->rx_urb);\r\nusb_kill_urb(cardp->tx_urb);\r\nif (if_usb_submit_rx_urb(cardp) < 0)\r\nret = -EIO;\r\ngoto release_fw;\r\n} else if (cardp->bootcmdresp <= 0) {\r\nif (--reset_count >= 0) {\r\nif_usb_reset_device(cardp);\r\ngoto restart;\r\n}\r\nret = -EIO;\r\ngoto release_fw;\r\n}\r\ni = 0;\r\ncardp->totalbytes = 0;\r\ncardp->fwlastblksent = 0;\r\ncardp->CRC_OK = 1;\r\ncardp->fwdnldover = 0;\r\ncardp->fwseqnum = -1;\r\ncardp->totalbytes = 0;\r\ncardp->fwfinalblk = 0;\r\nif_usb_send_fw_pkt(cardp);\r\nwait_event_interruptible(cardp->fw_wq, cardp->surprise_removed || cardp->fwdnldover);\r\ndel_timer_sync(&cardp->fw_timeout);\r\nusb_kill_urb(cardp->rx_urb);\r\nif (!cardp->fwdnldover) {\r\npr_info("failed to load fw, resetting device!\n");\r\nif (--reset_count >= 0) {\r\nif_usb_reset_device(cardp);\r\ngoto restart;\r\n}\r\npr_info("FW download failure, time = %d ms\n", i * 100);\r\nret = -EIO;\r\ngoto release_fw;\r\n}\r\ncardp->priv->fw_ready = 1;\r\nif_usb_submit_rx_urb(cardp);\r\nif (lbs_start_card(priv))\r\ngoto release_fw;\r\nif_usb_setup_firmware(priv);\r\npriv->wol_criteria = EHS_REMOVE_WAKEUP;\r\nif (lbs_host_sleep_cfg(priv, priv->wol_criteria, NULL))\r\npriv->ehs_remove_supported = false;\r\nrelease_fw:\r\nrelease_firmware(cardp->fw);\r\ncardp->fw = NULL;\r\ndone:\r\nlbs_deb_leave(LBS_DEB_USB);\r\n}\r\nstatic int if_usb_suspend(struct usb_interface *intf, pm_message_t message)\r\n{\r\nstruct if_usb_card *cardp = usb_get_intfdata(intf);\r\nstruct lbs_private *priv = cardp->priv;\r\nint ret;\r\nlbs_deb_enter(LBS_DEB_USB);\r\nif (priv->psstate != PS_STATE_FULL_POWER) {\r\nret = -1;\r\ngoto out;\r\n}\r\n#ifdef CONFIG_OLPC\r\nif (machine_is_olpc()) {\r\nif (priv->wol_criteria == EHS_REMOVE_WAKEUP)\r\nolpc_ec_wakeup_clear(EC_SCI_SRC_WLAN);\r\nelse\r\nolpc_ec_wakeup_set(EC_SCI_SRC_WLAN);\r\n}\r\n#endif\r\nret = lbs_suspend(priv);\r\nif (ret)\r\ngoto out;\r\nusb_kill_urb(cardp->tx_urb);\r\nusb_kill_urb(cardp->rx_urb);\r\nout:\r\nlbs_deb_leave(LBS_DEB_USB);\r\nreturn ret;\r\n}\r\nstatic int if_usb_resume(struct usb_interface *intf)\r\n{\r\nstruct if_usb_card *cardp = usb_get_intfdata(intf);\r\nstruct lbs_private *priv = cardp->priv;\r\nlbs_deb_enter(LBS_DEB_USB);\r\nif_usb_submit_rx_urb(cardp);\r\nlbs_resume(priv);\r\nlbs_deb_leave(LBS_DEB_USB);\r\nreturn 0;\r\n}
