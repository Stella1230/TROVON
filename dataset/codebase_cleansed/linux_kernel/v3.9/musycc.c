STATIC int\r\nmusycc_dump_rxbuffer_ring(mch_t * ch, int lockit)\r\n{\r\nstruct mdesc *m;\r\nunsigned long flags = 0;\r\nu_int32_t status;\r\nint n;\r\nif (lockit)\r\nspin_lock_irqsave(&ch->ch_rxlock, flags);\r\nif (ch->rxd_num == 0)\r\npr_info(" ZERO receive buffers allocated for this channel.");\r\nelse {\r\nFLUSH_MEM_READ();\r\nm = &ch->mdr[ch->rxix_irq_srv];\r\nfor (n = ch->rxd_num; n; n--) {\r\nstatus = le32_to_cpu(m->status);\r\n{\r\npr_info("%c %08lx[%2d]: sts %08x (%c%c%c%c:%d.) Data [%08x] Next [%08x]\n",\r\n(m == &ch->mdr[ch->rxix_irq_srv]) ? 'F' : ' ',\r\n(unsigned long) m, n,\r\nstatus,\r\nm->data ? (status & HOST_RX_OWNED ? 'H' : 'M') : '-',\r\nstatus & POLL_DISABLED ? 'P' : '-',\r\nstatus & EOBIRQ_ENABLE ? 'b' : '-',\r\nstatus & EOMIRQ_ENABLE ? 'm' : '-',\r\nstatus & LENGTH_MASK,\r\nle32_to_cpu(m->data), le32_to_cpu(m->next));\r\n#ifdef RLD_DUMP_BUFDATA\r\n{\r\nu_int32_t *dp;\r\nint len = status & LENGTH_MASK;\r\n#if 1\r\nif (m->data && (status & HOST_RX_OWNED))\r\n#else\r\nif (m->data)\r\n#endif\r\n{\r\ndp = (u_int32_t *) OS_phystov((void *) (le32_to_cpu(m->data)));\r\nif (len >= 0x10)\r\npr_info(" %x[%x]: %08X %08X %08X %08x\n", (u_int32_t) dp, len,\r\n*dp, *(dp + 1), *(dp + 2), *(dp + 3));\r\nelse if (len >= 0x08)\r\npr_info(" %x[%x]: %08X %08X\n", (u_int32_t) dp, len,\r\n*dp, *(dp + 1));\r\nelse\r\npr_info(" %x[%x]: %08X\n", (u_int32_t) dp, len, *dp);\r\n}\r\n}\r\n#endif\r\n}\r\nm = m->snext;\r\n}\r\n}\r\npr_info("\n");\r\nif (lockit)\r\nspin_unlock_irqrestore(&ch->ch_rxlock, flags);\r\nreturn 0;\r\n}\r\nSTATIC int\r\nmusycc_dump_txbuffer_ring(mch_t * ch, int lockit)\r\n{\r\nstruct mdesc *m;\r\nunsigned long flags = 0;\r\nu_int32_t status;\r\nint n;\r\nif (lockit)\r\nspin_lock_irqsave(&ch->ch_txlock, flags);\r\nif (ch->txd_num == 0)\r\npr_info(" ZERO transmit buffers allocated for this channel.");\r\nelse {\r\nFLUSH_MEM_READ();\r\nm = ch->txd_irq_srv;\r\nfor (n = ch->txd_num; n; n--) {\r\nstatus = le32_to_cpu(m->status);\r\n{\r\npr_info("%c%c %08lx[%2d]: sts %08x (%c%c%c%c:%d.) Data [%08x] Next [%08x]\n",\r\n(m == ch->txd_usr_add) ? 'F' : ' ',\r\n(m == ch->txd_irq_srv) ? 'L' : ' ',\r\n(unsigned long) m, n,\r\nstatus,\r\nm->data ? (status & MUSYCC_TX_OWNED ? 'M' : 'H') : '-',\r\nstatus & POLL_DISABLED ? 'P' : '-',\r\nstatus & EOBIRQ_ENABLE ? 'b' : '-',\r\nstatus & EOMIRQ_ENABLE ? 'm' : '-',\r\nstatus & LENGTH_MASK,\r\nle32_to_cpu(m->data), le32_to_cpu(m->next));\r\n#ifdef RLD_DUMP_BUFDATA\r\n{\r\nu_int32_t *dp;\r\nint len = status & LENGTH_MASK;\r\nif (m->data) {\r\ndp = (u_int32_t *) OS_phystov((void *) (le32_to_cpu(m->data)));\r\nif (len >= 0x10)\r\npr_info(" %x[%x]: %08X %08X %08X %08x\n", (u_int32_t) dp, len,\r\n*dp, *(dp + 1), *(dp + 2), *(dp + 3));\r\nelse if (len >= 0x08)\r\npr_info(" %x[%x]: %08X %08X\n", (u_int32_t) dp, len,\r\n*dp, *(dp + 1));\r\nelse\r\npr_info(" %x[%x]: %08X\n", (u_int32_t) dp, len, *dp);\r\n}\r\n}\r\n#endif\r\n}\r\nm = m->snext;\r\n}\r\n}\r\npr_info("\n");\r\nif (lockit)\r\nspin_unlock_irqrestore(&ch->ch_txlock, flags);\r\nreturn 0;\r\n}\r\nstatus_t\r\nmusycc_dump_ring(ci_t * ci, unsigned int chan)\r\n{\r\nmch_t *ch;\r\nif (chan >= MAX_CHANS_USED)\r\nreturn SBE_DRVR_FAIL;\r\n{\r\nint bh;\r\nbh = atomic_read(&ci->bh_pending);\r\npr_info(">> bh_pend %d [%d] ihead %d itail %d [%d] th_cnt %d bh_cnt %d wdcnt %d note %d\n",\r\nbh, max_bh, ci->iqp_headx, ci->iqp_tailx, max_intcnt,\r\nci->intlog.drvr_intr_thcount,\r\nci->intlog.drvr_intr_bhcount,\r\nci->wdcount, ci->wd_notify);\r\nmax_bh = 0;\r\nmax_intcnt = 0;\r\n}\r\nif (!(ch = sd_find_chan(dummy, chan))) {\r\npr_info(">> musycc_dump_ring: channel %d not up.\n", chan);\r\nreturn ENOENT;\r\n}\r\npr_info(">> CI %p CHANNEL %3d @ %p: state %x status/p %x/%x\n", ci, chan, ch, ch->state,\r\nch->status, ch->p.status);\r\npr_info("--------------------------------\nTX Buffer Ring - Channel %d, txd_num %d. (bd/ch pend %d %d), TXD required %d, txpkt %lu\n",\r\nchan, ch->txd_num,\r\n(u_int32_t) atomic_read(&ci->tx_pending), (u_int32_t) atomic_read(&ch->tx_pending), ch->txd_required, ch->s.tx_packets);\r\npr_info("++ User 0x%p IRQ_SRV 0x%p USR_ADD 0x%p QStopped %x, start_tx %x tx_full %d txd_free %d mode %x\n",\r\nch->user, ch->txd_irq_srv, ch->txd_usr_add,\r\nsd_queue_stopped(ch->user),\r\nch->ch_start_tx, ch->tx_full, ch->txd_free, ch->p.chan_mode);\r\nmusycc_dump_txbuffer_ring(ch, 1);\r\npr_info("RX Buffer Ring - Channel %d, rxd_num %d. IRQ_SRV[%d] 0x%p, start_rx %x rxpkt %lu\n",\r\nchan, ch->rxd_num, ch->rxix_irq_srv,\r\n&ch->mdr[ch->rxix_irq_srv], ch->ch_start_rx, ch->s.rx_packets);\r\nmusycc_dump_rxbuffer_ring(ch, 1);\r\nreturn SBE_DRVR_SUCCESS;\r\n}\r\nstatus_t\r\nmusycc_dump_rings(ci_t * ci, unsigned int start_chan)\r\n{\r\nunsigned int chan;\r\nfor (chan = start_chan; chan < (start_chan + 5); chan++)\r\nmusycc_dump_ring(ci, chan);\r\nreturn SBE_DRVR_SUCCESS;\r\n}\r\nvoid\r\nmusycc_init_mdt(mpi_t * pi)\r\n{\r\nu_int32_t *addr, cfg;\r\nint i;\r\naddr = (u_int32_t *) ((u_long) pi->reg + MUSYCC_MDT_BASE03_ADDR);\r\ncfg = CFG_CH_FLAG_7E << IDLE_CODE;\r\nfor (i = 0; i < 32; addr++, i++)\r\npci_write_32(addr, cfg);\r\n}\r\nvoid\r\nmusycc_update_tx_thp(mch_t * ch)\r\n{\r\nstruct mdesc *md;\r\nunsigned long flags;\r\nspin_lock_irqsave(&ch->ch_txlock, flags);\r\nwhile (1) {\r\nmd = ch->txd_irq_srv;\r\nFLUSH_MEM_READ();\r\nif (!md->data) {\r\nspin_unlock_irqrestore(&ch->ch_txlock, flags);\r\nreturn;\r\n}\r\nif ((le32_to_cpu(md->status)) & MUSYCC_TX_OWNED) {\r\nbreak;\r\n}\r\nmusycc_bh_tx_eom(ch->up, ch->gchan);\r\n}\r\nmd = ch->txd_irq_srv;\r\nch->up->regram->thp[ch->gchan] = cpu_to_le32(OS_vtophys(md));\r\nFLUSH_MEM_WRITE();\r\nif (ch->tx_full) {\r\nch->tx_full = 0;\r\nch->txd_required = 0;\r\nsd_enable_xmit(ch->user);\r\n}\r\nspin_unlock_irqrestore(&ch->ch_txlock, flags);\r\n#ifdef RLD_TRANS_DEBUG\r\npr_info("++ musycc_update_tx_thp[%d]: setting thp = %p, sts %x\n", ch->channum, md, md->status);\r\n#endif\r\n}\r\nvoid\r\nmusycc_wq_chan_restart(void *arg)\r\n{\r\nmch_t *ch;\r\nmpi_t *pi;\r\nstruct mdesc *md;\r\n#if 0\r\nunsigned long flags;\r\n#endif\r\nch = container_of(arg, struct c4_chan_info, ch_work);\r\npi = ch->up;\r\n#ifdef RLD_TRANS_DEBUG\r\npr_info("wq_chan_restart[%d]: start_RT[%d/%d] status %x\n",\r\nch->channum, ch->ch_start_rx, ch->ch_start_tx, ch->status);\r\n#endif\r\nif ((ch->ch_start_rx) && (ch->status & RX_ENABLED)) {\r\nch->ch_start_rx = 0;\r\n#if defined(RLD_TRANS_DEBUG) || defined(RLD_RXACT_DEBUG)\r\n{\r\nstatic int hereb4 = 7;\r\nif (hereb4) {\r\nhereb4--;\r\n#ifdef RLD_TRANS_DEBUG\r\nmd = &ch->mdr[ch->rxix_irq_srv];\r\npr_info("++ musycc_wq_chan_restart[%d] CHAN RX ACTIVATE: rxix_irq_srv %d, md %p sts %x, rxpkt %lu\n",\r\nch->channum, ch->rxix_irq_srv, md, le32_to_cpu(md->status),\r\nch->s.rx_packets);\r\n#elif defined(RLD_RXACT_DEBUG)\r\nmd = &ch->mdr[ch->rxix_irq_srv];\r\npr_info("++ musycc_wq_chan_restart[%d] CHAN RX ACTIVATE: rxix_irq_srv %d, md %p sts %x, rxpkt %lu\n",\r\nch->channum, ch->rxix_irq_srv, md, le32_to_cpu(md->status),\r\nch->s.rx_packets);\r\nmusycc_dump_rxbuffer_ring(ch, 1);\r\n#endif\r\n}\r\n}\r\n#endif\r\nmusycc_serv_req(pi, SR_CHANNEL_ACTIVATE | SR_RX_DIRECTION | ch->gchan);\r\n}\r\nif ((ch->ch_start_tx) && (ch->status & TX_ENABLED)) {\r\nmusycc_update_tx_thp(ch);\r\n#if 0\r\nspin_lock_irqsave(&ch->ch_txlock, flags);\r\n#endif\r\nmd = ch->txd_irq_srv;\r\nif (!md) {\r\n#ifdef RLD_TRANS_DEBUG\r\npr_info("-- musycc_wq_chan_restart[%d]: WARNING, starting NULL md\n", ch->channum);\r\n#endif\r\n#if 0\r\nspin_unlock_irqrestore(&ch->ch_txlock, flags);\r\n#endif\r\n} else if (md->data && ((le32_to_cpu(md->status)) & MUSYCC_TX_OWNED)) {\r\nch->ch_start_tx = 0;\r\n#if 0\r\nspin_unlock_irqrestore(&ch->ch_txlock, flags);\r\n#endif\r\n#ifdef RLD_TRANS_DEBUG\r\npr_info("++ musycc_wq_chan_restart() CHAN TX ACTIVATE: chan %d txd_irq_srv %p = sts %x, txpkt %lu\n",\r\nch->channum, ch->txd_irq_srv, ch->txd_irq_srv->status, ch->s.tx_packets);\r\n#endif\r\nmusycc_serv_req(pi, SR_CHANNEL_ACTIVATE | SR_TX_DIRECTION | ch->gchan);\r\n}\r\n#ifdef RLD_RESTART_DEBUG\r\nelse {\r\npr_info("-- musycc_wq_chan_restart[%d]: DELAYED due to md %p sts %x data %x, start_tx %x\n",\r\nch->channum, md,\r\nle32_to_cpu(md->status),\r\nle32_to_cpu(md->data), ch->ch_start_tx);\r\nmusycc_dump_txbuffer_ring(ch, 0);\r\n#if 0\r\nspin_unlock_irqrestore(&ch->ch_txlock, flags);\r\n#endif\r\n}\r\n#endif\r\n}\r\n}\r\nvoid\r\nmusycc_chan_restart(mch_t * ch)\r\n{\r\n#ifdef RLD_RESTART_DEBUG\r\npr_info("++ musycc_chan_restart[%d]: txd_irq_srv @ %p = sts %x\n",\r\nch->channum, ch->txd_irq_srv, ch->txd_irq_srv->status);\r\n#endif\r\n#ifdef RLD_RESTART_DEBUG\r\npr_info(">> musycc_chan_restart: scheduling Chan %x workQ @ %p\n", ch->channum, &ch->ch_work);\r\n#endif\r\nc4_wk_chan_restart(ch);\r\n}\r\nvoid\r\nrld_put_led(mpi_t * pi, u_int32_t ledval)\r\n{\r\nstatic u_int32_t led = 0;\r\nif (ledval == 0)\r\nled = 0;\r\nelse\r\nled |= ledval;\r\npci_write_32((u_int32_t *) &pi->up->cpldbase->leds, led);\r\n}\r\nvoid\r\nmusycc_serv_req(mpi_t * pi, u_int32_t req)\r\n{\r\nvolatile u_int32_t r;\r\nint rcnt;\r\nSD_SEM_TAKE(&pi->sr_sem_busy, "serv");\r\nif (pi->sr_last == req) {\r\n#ifdef RLD_TRANS_DEBUG\r\npr_info(">> same SR, Port %d Req %x\n", pi->portnum, req);\r\n#endif\r\nr = (pi->sr_last & ~SR_GCHANNEL_MASK);\r\nif ((r == (SR_CHANNEL_ACTIVATE | SR_TX_DIRECTION)) ||\r\n(r == (SR_CHANNEL_ACTIVATE | SR_RX_DIRECTION))) {\r\n#ifdef RLD_TRANS_DEBUG\r\npr_info(">> same CHAN ACT SR, Port %d Req %x => issue SR_NOOP CMD\n", pi->portnum, req);\r\n#endif\r\nSD_SEM_GIVE(&pi->sr_sem_busy);\r\nmusycc_serv_req(pi, SR_NOOP);\r\nSD_SEM_TAKE(&pi->sr_sem_busy, "serv");\r\n} else if (req == SR_NOOP) {\r\n#ifdef RLD_TRANS_DEBUG\r\npr_info(">> same Port SR_NOOP skipped, Port %d\n", pi->portnum);\r\n#endif\r\nSD_SEM_GIVE(&pi->sr_sem_busy);\r\nreturn;\r\n}\r\n}\r\nrcnt = 0;\r\npi->sr_last = req;\r\nrewrite:\r\npci_write_32((u_int32_t *) &pi->reg->srd, req);\r\nFLUSH_MEM_WRITE();\r\nr = pci_read_32((u_int32_t *) &pi->reg->srd);\r\nif ((r != req) && (req != SR_CHIP_RESET) && (++rcnt <= MUSYCC_SR_RETRY_CNT)) {\r\nif (cxt1e1_log_level >= LOG_MONITOR)\r\npr_info("%s: %d - reissue srv req/last %x/%x (hdw reads %x), Chan %d.\n",\r\npi->up->devname, rcnt, req, pi->sr_last, r,\r\n(pi->portnum * MUSYCC_NCHANS) + (req & 0x1f));\r\nOS_uwait_dummy();\r\ngoto rewrite;\r\n}\r\nif (rcnt > MUSYCC_SR_RETRY_CNT) {\r\npr_warning("%s: failed service request (#%d)= %x, group %d.\n",\r\npi->up->devname, MUSYCC_SR_RETRY_CNT, req, pi->portnum);\r\nSD_SEM_GIVE(&pi->sr_sem_busy);\r\nreturn;\r\n}\r\nif (req == SR_CHIP_RESET) {\r\nOS_uwait(100000, "icard");\r\n} else {\r\nFLUSH_MEM_READ();\r\nSD_SEM_TAKE(&pi->sr_sem_wait, "sakack");\r\n}\r\nSD_SEM_GIVE(&pi->sr_sem_busy);\r\n}\r\nvoid\r\nmusycc_update_timeslots(mpi_t * pi)\r\n{\r\nint i, ch;\r\nchar e1mode = IS_FRAME_ANY_E1(pi->p.port_mode);\r\nfor (i = 0; i < 32; i++) {\r\nint usedby = 0, last = 0, ts, j, bits[8];\r\nu_int8_t lastval = 0;\r\nif (((i == 0) && e1mode) ||\r\n((i == 16) && ((pi->p.port_mode == CFG_FRAME_E1CRC_CAS) || (pi->p.port_mode == CFG_FRAME_E1CRC_CAS_AMI)))\r\n|| ((i > 23) && (!e1mode)))\r\npi->tsm[i] = 0xff;\r\nelse\r\npi->tsm[i] = 0x00;\r\nfor (j = 0; j < 8; j++)\r\nbits[j] = -1;\r\nfor (ch = 0; ch < MUSYCC_NCHANS; ch++) {\r\nif ((pi->chan[ch]->state == UP) && (pi->chan[ch]->p.bitmask[i])) {\r\nusedby++;\r\nlast = ch;\r\nlastval = pi->chan[ch]->p.bitmask[i];\r\nfor (j = 0; j < 8; j++)\r\nif (lastval & (1 << j))\r\nbits[j] = ch;\r\npi->tsm[i] |= lastval;\r\n}\r\n}\r\nif (!usedby)\r\nts = 0;\r\nelse if ((usedby == 1) && (lastval == 0xff))\r\nts = (4 << 5) | last;\r\nelse if ((usedby == 1) && (lastval == 0x7f))\r\nts = (5 << 5) | last;\r\nelse {\r\nint idx;\r\nif (bits[0] < 0)\r\nts = (6 << 5) | (idx = last);\r\nelse\r\nts = (7 << 5) | (idx = bits[0]);\r\nfor (j = 1; j < 8; j++) {\r\npi->regram->rscm[idx * 8 + j] = (bits[j] < 0) ? 0 : (0x80 | bits[j]);\r\npi->regram->tscm[idx * 8 + j] = (bits[j] < 0) ? 0 : (0x80 | bits[j]);\r\n}\r\n}\r\npi->regram->rtsm[i] = ts;\r\npi->regram->ttsm[i] = ts;\r\n}\r\nFLUSH_MEM_WRITE();\r\nmusycc_serv_req(pi, SR_TIMESLOT_MAP | SR_RX_DIRECTION);\r\nmusycc_serv_req(pi, SR_TIMESLOT_MAP | SR_TX_DIRECTION);\r\nmusycc_serv_req(pi, SR_SUBCHANNEL_MAP | SR_RX_DIRECTION);\r\nmusycc_serv_req(pi, SR_SUBCHANNEL_MAP | SR_TX_DIRECTION);\r\n}\r\nvoid\r\nmusycc_update_timeslots(mpi_t * pi)\r\n{\r\nmch_t *ch;\r\nu_int8_t ts, hmask, tsen;\r\nint gchan;\r\nint i;\r\n#ifdef SBE_PMCC4_ENABLE\r\nhmask = (0x1f << pi->up->p.hypersize) & 0x1f;\r\n#endif\r\n#ifdef SBE_WAN256T3_ENABLE\r\nhmask = (0x1f << hyperdummy) & 0x1f;\r\n#endif\r\nfor (i = 0; i < 128; i++) {\r\ngchan = ((pi->portnum * MUSYCC_NCHANS) + (i & hmask)) % MUSYCC_NCHANS;\r\nch = pi->chan[gchan];\r\nif (ch->p.mode_56k)\r\ntsen = MODE_56KBPS;\r\nelse\r\ntsen = MODE_64KBPS;\r\nts = ((pi->portnum % 4) == (i / 32)) ? (tsen << 5) | (i & hmask) : 0;\r\npi->regram->rtsm[i] = ts;\r\npi->regram->ttsm[i] = ts;\r\n}\r\nFLUSH_MEM_WRITE();\r\nmusycc_serv_req(pi, SR_TIMESLOT_MAP | SR_RX_DIRECTION);\r\nmusycc_serv_req(pi, SR_TIMESLOT_MAP | SR_TX_DIRECTION);\r\n}\r\nu_int32_t\r\nmusycc_chan_proto(int proto)\r\n{\r\nint reg;\r\nswitch (proto) {\r\ncase CFG_CH_PROTO_TRANS:\r\nreg = MUSYCC_CCD_TRANS;\r\nbreak;\r\ncase CFG_CH_PROTO_SS7:\r\nreg = MUSYCC_CCD_SS7;\r\nbreak;\r\ndefault:\r\ncase CFG_CH_PROTO_ISLP_MODE:\r\ncase CFG_CH_PROTO_HDLC_FCS16:\r\nreg = MUSYCC_CCD_HDLC_FCS16;\r\nbreak;\r\ncase CFG_CH_PROTO_HDLC_FCS32:\r\nreg = MUSYCC_CCD_HDLC_FCS32;\r\nbreak;\r\n}\r\nreturn reg;\r\n}\r\nSTATIC void __init\r\nmusycc_init_port(mpi_t * pi)\r\n{\r\npci_write_32((u_int32_t *) &pi->reg->gbp, OS_vtophys(pi->regram));\r\npi->regram->grcd =\r\n__constant_cpu_to_le32(MUSYCC_GRCD_RX_ENABLE |\r\nMUSYCC_GRCD_TX_ENABLE |\r\nMUSYCC_GRCD_SF_ALIGN |\r\nMUSYCC_GRCD_SUBCHAN_DISABLE |\r\nMUSYCC_GRCD_OOFMP_DISABLE |\r\nMUSYCC_GRCD_COFAIRQ_DISABLE |\r\nMUSYCC_GRCD_MC_ENABLE |\r\n(MUSYCC_GRCD_POLLTH_32 << MUSYCC_GRCD_POLLTH_SHIFT));\r\npi->regram->pcd =\r\n__constant_cpu_to_le32(MUSYCC_PCD_E1X4_MODE |\r\nMUSYCC_PCD_TXDATA_RISING |\r\nMUSYCC_PCD_TX_DRIVEN);\r\npi->regram->mld = __constant_cpu_to_le32(cxt1e1_max_mru | (cxt1e1_max_mru << 16));\r\nFLUSH_MEM_WRITE();\r\nmusycc_serv_req(pi, SR_GROUP_INIT | SR_RX_DIRECTION);\r\nmusycc_serv_req(pi, SR_GROUP_INIT | SR_TX_DIRECTION);\r\nmusycc_init_mdt(pi);\r\nmusycc_update_timeslots(pi);\r\n}\r\nstatus_t __init\r\nmusycc_init(ci_t * ci)\r\n{\r\nchar *regaddr;\r\nint i, gchan;\r\nOS_sem_init(&ci->sem_wdbusy, SEM_AVAILABLE);\r\n#define INT_QUEUE_BOUNDARY 4\r\nregaddr = OS_kmalloc((INT_QUEUE_SIZE + 1) * sizeof(u_int32_t));\r\nif (regaddr == 0)\r\nreturn ENOMEM;\r\nci->iqd_p_saved = regaddr;\r\nci->iqd_p = (u_int32_t *) ((unsigned long) (regaddr + INT_QUEUE_BOUNDARY - 1) &\r\n(~(INT_QUEUE_BOUNDARY - 1)));\r\nfor (i = 0; i < INT_QUEUE_SIZE; i++)\r\nci->iqd_p[i] = __constant_cpu_to_le32(INT_EMPTY_ENTRY);\r\nfor (i = 0; i < ci->max_port; i++) {\r\nmpi_t *pi = &ci->port[i];\r\n#define GROUP_BOUNDARY 0x800\r\nregaddr = OS_kmalloc(sizeof(struct musycc_groupr) + GROUP_BOUNDARY);\r\nif (regaddr == 0) {\r\nfor (gchan = 0; gchan < i; gchan++) {\r\npi = &ci->port[gchan];\r\nOS_kfree(pi->reg);\r\npi->reg = 0;\r\n}\r\nreturn ENOMEM;\r\n}\r\npi->regram_saved = regaddr;\r\npi->regram = (struct musycc_groupr *) ((unsigned long) (regaddr + GROUP_BOUNDARY - 1) &\r\n(~(GROUP_BOUNDARY - 1)));\r\n}\r\nci->regram = ci->port[0].regram;\r\nmusycc_serv_req(&ci->port[0], SR_CHIP_RESET);\r\npci_write_32((u_int32_t *) &ci->reg->gbp, OS_vtophys(ci->regram));\r\npci_flush_write(ci);\r\n#ifdef CONFIG_SBE_PMCC4_NCOMM\r\nci->regram->__glcd = __constant_cpu_to_le32(GCD_MAGIC);\r\n#else\r\nci->regram->__glcd = __constant_cpu_to_le32(GCD_MAGIC | MUSYCC_GCD_INTB_DISABLE);\r\n#endif\r\nci->regram->__iqp = cpu_to_le32(OS_vtophys(&ci->iqd_p[0]));\r\nci->regram->__iql = __constant_cpu_to_le32(INT_QUEUE_SIZE - 1);\r\npci_write_32((u_int32_t *) &ci->reg->dacbp, 0);\r\nFLUSH_MEM_WRITE();\r\nci->state = C_RUNNING;\r\nmusycc_serv_req(&ci->port[0], SR_GLOBAL_INIT);\r\nif (cxt1e1_max_mru > 0xffe) {\r\npr_warning("Maximum allowed MRU exceeded, resetting %d to %d.\n",\r\ncxt1e1_max_mru, 0xffe);\r\ncxt1e1_max_mru = 0xffe;\r\n}\r\nif (cxt1e1_max_mtu > 0xffe) {\r\npr_warning("Maximum allowed MTU exceeded, resetting %d to %d.\n",\r\ncxt1e1_max_mtu, 0xffe);\r\ncxt1e1_max_mtu = 0xffe;\r\n}\r\n#ifdef SBE_WAN256T3_ENABLE\r\nfor (i = 0; i < MUSYCC_NPORTS; i++)\r\nmusycc_init_port(&ci->port[i]);\r\n#endif\r\nreturn SBE_DRVR_SUCCESS;\r\n}\r\nvoid\r\nmusycc_bh_tx_eom(mpi_t * pi, int gchan)\r\n{\r\nmch_t *ch;\r\nstruct mdesc *md;\r\n#if 0\r\n#ifndef SBE_ISR_INLINE\r\nunsigned long flags;\r\n#endif\r\n#endif\r\nvolatile u_int32_t status;\r\nch = pi->chan[gchan];\r\nif (ch == 0 || ch->state != UP) {\r\nif (cxt1e1_log_level >= LOG_ERROR)\r\npr_info("%s: intr: xmit EOM on uninitialized channel %d\n",\r\npi->up->devname, gchan);\r\n}\r\nif (ch == 0 || ch->mdt == 0)\r\nreturn;\r\n#if 0\r\n#ifdef SBE_ISR_INLINE\r\nspin_lock_irq(&ch->ch_txlock);\r\n#else\r\nspin_lock_irqsave(&ch->ch_txlock, flags);\r\n#endif\r\n#endif\r\ndo {\r\nFLUSH_MEM_READ();\r\nmd = ch->txd_irq_srv;\r\nstatus = le32_to_cpu(md->status);\r\nif (status & MUSYCC_TX_OWNED) {\r\nint readCount, loopCount;\r\nreadCount = 0;\r\nwhile (status & MUSYCC_TX_OWNED) {\r\nfor (loopCount = 0; loopCount < 0x30; loopCount++)\r\nOS_uwait_dummy();\r\nFLUSH_MEM_READ();\r\nstatus = le32_to_cpu(md->status);\r\nif (readCount++ > 40)\r\nbreak;\r\n}\r\nif (status & MUSYCC_TX_OWNED) {\r\nif (cxt1e1_log_level >= LOG_MONITOR) {\r\npr_info("%s: Port %d Chan %2d - unexpected TX msg ownership intr (md %p sts %x)\n",\r\npi->up->devname, pi->portnum, ch->channum,\r\nmd, status);\r\npr_info("++ User 0x%p IRQ_SRV 0x%p USR_ADD 0x%p QStopped %x, start_tx %x tx_full %d txd_free %d mode %x\n",\r\nch->user, ch->txd_irq_srv, ch->txd_usr_add,\r\nsd_queue_stopped(ch->user),\r\nch->ch_start_tx, ch->tx_full, ch->txd_free, ch->p.chan_mode);\r\nmusycc_dump_txbuffer_ring(ch, 0);\r\n}\r\nbreak;\r\n} else {\r\nif (cxt1e1_log_level >= LOG_MONITOR)\r\npr_info("%s: Port %d Chan %2d - recovered TX msg ownership [%d] (md %p sts %x)\n",\r\npi->up->devname, pi->portnum, ch->channum, readCount, md, status);\r\n}\r\n}\r\nch->txd_irq_srv = md->snext;\r\nmd->data = 0;\r\nif (md->mem_token != 0) {\r\natomic_sub(OS_mem_token_tlen(md->mem_token), &ch->tx_pending);\r\natomic_sub(OS_mem_token_tlen(md->mem_token), &pi->up->tx_pending);\r\n#ifdef SBE_WAN256T3_ENABLE\r\nif (!atomic_read(&pi->up->tx_pending))\r\nwan256t3_led(pi->up, LED_TX, 0);\r\n#endif\r\n#ifdef CONFIG_SBE_WAN256T3_NCOMM\r\n{\r\nint hdlcnum = (pi->portnum * 32 + gchan);\r\nif (hdlcnum >= 228) {\r\nif (nciProcess_TX_complete)\r\n(*nciProcess_TX_complete) (hdlcnum,\r\ngetuserbychan(gchan));\r\n}\r\n}\r\n#endif\r\nOS_mem_token_free_irq(md->mem_token);\r\nmd->mem_token = 0;\r\n}\r\nmd->status = 0;\r\n#ifdef RLD_TXFULL_DEBUG\r\nif (cxt1e1_log_level >= LOG_MONITOR2)\r\npr_info("~~ tx_eom: tx_full %x txd_free %d -> %d\n",\r\nch->tx_full, ch->txd_free, ch->txd_free + 1);\r\n#endif\r\n++ch->txd_free;\r\nFLUSH_MEM_WRITE();\r\nif ((ch->p.chan_mode != CFG_CH_PROTO_TRANS) && (status & EOBIRQ_ENABLE)) {\r\nif (cxt1e1_log_level >= LOG_MONITOR)\r\npr_info("%s: Mode (%x) incorrect EOB status (%x)\n",\r\npi->up->devname, ch->p.chan_mode, status);\r\nif ((status & EOMIRQ_ENABLE) == 0)\r\nbreak;\r\n}\r\n} while ((ch->p.chan_mode != CFG_CH_PROTO_TRANS) && ((status & EOMIRQ_ENABLE) == 0));\r\nFLUSH_MEM_READ();\r\nif (ch->tx_full && (ch->txd_free >= (ch->txd_num / 2))) {\r\nif (ch->txd_free >= ch->txd_required) {\r\n#ifdef RLD_TXFULL_DEBUG\r\nif (cxt1e1_log_level >= LOG_MONITOR2)\r\npr_info("tx_eom[%d]: enable xmit tx_full no more, txd_free %d txd_num/2 %d\n",\r\nch->channum,\r\nch->txd_free, ch->txd_num / 2);\r\n#endif\r\nch->tx_full = 0;\r\nch->txd_required = 0;\r\nsd_enable_xmit(ch->user);\r\n}\r\n}\r\n#ifdef RLD_TXFULL_DEBUG\r\nelse if (ch->tx_full) {\r\nif (cxt1e1_log_level >= LOG_MONITOR2)\r\npr_info("tx_eom[%d]: bypass TX enable though room available? (txd_free %d txd_num/2 %d)\n",\r\nch->channum,\r\nch->txd_free, ch->txd_num / 2);\r\n}\r\n#endif\r\nFLUSH_MEM_WRITE();\r\n#if 0\r\n#ifdef SBE_ISR_INLINE\r\nspin_unlock_irq(&ch->ch_txlock);\r\n#else\r\nspin_unlock_irqrestore(&ch->ch_txlock, flags);\r\n#endif\r\n#endif\r\n}\r\nSTATIC void\r\nmusycc_bh_rx_eom(mpi_t * pi, int gchan)\r\n{\r\nmch_t *ch;\r\nvoid *m, *m2;\r\nstruct mdesc *md;\r\nvolatile u_int32_t status;\r\nu_int32_t error;\r\nch = pi->chan[gchan];\r\nif (ch == 0 || ch->state != UP) {\r\nif (cxt1e1_log_level > LOG_ERROR)\r\npr_info("%s: intr: receive EOM on uninitialized channel %d\n",\r\npi->up->devname, gchan);\r\nreturn;\r\n}\r\nif (ch->mdr == 0)\r\nreturn;\r\nfor (;;) {\r\nFLUSH_MEM_READ();\r\nmd = &ch->mdr[ch->rxix_irq_srv];\r\nstatus = le32_to_cpu(md->status);\r\nif (!(status & HOST_RX_OWNED))\r\nbreak;\r\nm = md->mem_token;\r\nerror = (status >> 16) & 0xf;\r\nif (error == 0) {\r\n#ifdef CONFIG_SBE_WAN256T3_NCOMM\r\nint hdlcnum = (pi->portnum * 32 + gchan);\r\nif (hdlcnum >= 228) {\r\nif (nciProcess_RX_packet)\r\n(*nciProcess_RX_packet) (hdlcnum, status & 0x3fff, m, ch->user);\r\n} else\r\n#endif\r\n{\r\nif ((m2 = OS_mem_token_alloc(cxt1e1_max_mru))) {\r\nmd->mem_token = m2;\r\nmd->data = cpu_to_le32(OS_vtophys(OS_mem_token_data(m2)));\r\nsd_recv_consume(m, status & LENGTH_MASK, ch->user);\r\nch->s.rx_packets++;\r\nch->s.rx_bytes += status & LENGTH_MASK;\r\n} else\r\nch->s.rx_dropped++;\r\n}\r\n} else if (error == ERR_FCS)\r\nch->s.rx_crc_errors++;\r\nelse if (error == ERR_ALIGN)\r\nch->s.rx_missed_errors++;\r\nelse if (error == ERR_ABT)\r\nch->s.rx_missed_errors++;\r\nelse if (error == ERR_LNG)\r\nch->s.rx_length_errors++;\r\nelse if (error == ERR_SHT)\r\nch->s.rx_length_errors++;\r\nFLUSH_MEM_WRITE();\r\nstatus = cxt1e1_max_mru;\r\nif (ch->p.chan_mode == CFG_CH_PROTO_TRANS)\r\nstatus |= EOBIRQ_ENABLE;\r\nmd->status = cpu_to_le32(status);\r\nif (++ch->rxix_irq_srv >= ch->rxd_num)\r\nch->rxix_irq_srv = 0;\r\nFLUSH_MEM_WRITE();\r\n}\r\n}\r\nirqreturn_t\r\nmusycc_intr_th_handler(void *devp)\r\n{\r\nci_t *ci = (ci_t *) devp;\r\nvolatile u_int32_t status, currInt = 0;\r\nu_int32_t nextInt, intCnt;\r\nif (ci->state == C_INIT)\r\nreturn IRQ_NONE;\r\nif (ci->state == C_IDLE) {\r\nstatus = pci_read_32((u_int32_t *) &ci->reg->isd);\r\npci_write_32((u_int32_t *) &ci->reg->isd, status);\r\nreturn IRQ_HANDLED;\r\n}\r\nFLUSH_PCI_READ();\r\nFLUSH_MEM_READ();\r\nstatus = pci_read_32((u_int32_t *) &ci->reg->isd);\r\nnextInt = INTRPTS_NEXTINT(status);\r\nintCnt = INTRPTS_INTCNT(status);\r\nci->intlog.drvr_intr_thcount++;\r\nif (nextInt != INTRPTS_NEXTINT(ci->intlog.this_status_new)) {\r\nif (cxt1e1_log_level >= LOG_MONITOR) {\r\npr_info("%s: note - updated ISD from %08x to %08x\n",\r\nci->devname, status,\r\n(status & (~INTRPTS_NEXTINT_M)) | ci->intlog.this_status_new);\r\n}\r\nstatus = (status & (~INTRPTS_NEXTINT_M)) | (ci->intlog.this_status_new);\r\nnextInt = INTRPTS_NEXTINT(status);\r\n}\r\nif (intCnt == INT_QUEUE_SIZE)\r\ncurrInt = ((intCnt - 1) + nextInt) & (INT_QUEUE_SIZE - 1);\r\nelse\r\nif (intCnt)\r\ncurrInt = (intCnt + nextInt) & (INT_QUEUE_SIZE - 1);\r\nelse {\r\n#if 0\r\npr_info(">> %s: intCnt NULL, sts %x, possibly a chained interrupt!\n",\r\nci->devname, status);\r\n#endif\r\nreturn IRQ_NONE;\r\n}\r\nci->iqp_tailx = currInt;\r\ncurrInt <<= INTRPTS_NEXTINT_S;\r\nci->intlog.last_status_new = ci->intlog.this_status_new;\r\nci->intlog.this_status_new = currInt;\r\nif ((cxt1e1_log_level >= LOG_WARN) && (status & INTRPTS_INTFULL_M))\r\npr_info("%s: Interrupt queue full condition occurred\n", ci->devname);\r\nif (cxt1e1_log_level >= LOG_DEBUG)\r\npr_info("%s: interrupts pending, isd @ 0x%p: %x curr %d cnt %d NEXT %d\n",\r\nci->devname, &ci->reg->isd,\r\nstatus, nextInt, intCnt, (intCnt + nextInt) & (INT_QUEUE_SIZE - 1));\r\nFLUSH_MEM_WRITE();\r\n#if defined(SBE_ISR_TASKLET)\r\npci_write_32((u_int32_t *) &ci->reg->isd, currInt);\r\natomic_inc(&ci->bh_pending);\r\ntasklet_schedule(&ci->ci_musycc_isr_tasklet);\r\n#elif defined(SBE_ISR_IMMEDIATE)\r\npci_write_32((u_int32_t *) &ci->reg->isd, currInt);\r\natomic_inc(&ci->bh_pending);\r\nqueue_task(&ci->ci_musycc_isr_tq, &tq_immediate);\r\nmark_bh(IMMEDIATE_BH);\r\n#elif defined(SBE_ISR_INLINE)\r\n(void) musycc_intr_bh_tasklet(ci);\r\npci_write_32((u_int32_t *) &ci->reg->isd, currInt);\r\n#endif\r\nreturn IRQ_HANDLED;\r\n}\r\nunsigned long\r\n#else\r\nvoid\r\n#endif\r\nmusycc_intr_bh_tasklet(ci_t * ci)\r\n{\r\nmpi_t *pi;\r\nmch_t *ch;\r\nunsigned int intCnt;\r\nvolatile u_int32_t currInt = 0;\r\nvolatile unsigned int headx, tailx;\r\nint readCount, loopCount;\r\nint group, gchan, event, err, tx;\r\nu_int32_t badInt = INT_EMPTY_ENTRY;\r\nu_int32_t badInt2 = INT_EMPTY_ENTRY2;\r\nif ((drvr_state != SBE_DRVR_AVAILABLE) || (ci->state == C_INIT)) {\r\n#if defined(SBE_ISR_IMMEDIATE)\r\nreturn 0L;\r\n#else\r\nreturn;\r\n#endif\r\n}\r\n#if defined(SBE_ISR_TASKLET) || defined(SBE_ISR_IMMEDIATE)\r\nif (drvr_state != SBE_DRVR_AVAILABLE) {\r\n#if defined(SBE_ISR_TASKLET)\r\nreturn;\r\n#elif defined(SBE_ISR_IMMEDIATE)\r\nreturn 0L;\r\n#endif\r\n}\r\n#elif defined(SBE_ISR_INLINE)\r\n#endif\r\nci->intlog.drvr_intr_bhcount++;\r\nFLUSH_MEM_READ();\r\n{\r\nunsigned int bh = atomic_read(&ci->bh_pending);\r\nmax_bh = max(bh, max_bh);\r\n}\r\natomic_set(&ci->bh_pending, 0);\r\nwhile ((headx = ci->iqp_headx) != (tailx = ci->iqp_tailx)) {\r\nintCnt = (tailx >= headx) ? (tailx - headx) : (tailx - headx + INT_QUEUE_SIZE);\r\ncurrInt = le32_to_cpu(ci->iqd_p[headx]);\r\nmax_intcnt = max(intCnt, max_intcnt);\r\nreadCount = 0;\r\nif ((currInt == badInt) || (currInt == badInt2))\r\nci->intlog.drvr_int_failure++;\r\nwhile ((currInt == badInt) || (currInt == badInt2)) {\r\nfor (loopCount = 0; loopCount < 0x30; loopCount++)\r\nOS_uwait_dummy();\r\nFLUSH_MEM_READ();\r\ncurrInt = le32_to_cpu(ci->iqd_p[headx]);\r\nif (readCount++ > 20)\r\nbreak;\r\n}\r\nif ((currInt == badInt) || (currInt == badInt2)) {\r\nif (cxt1e1_log_level >= LOG_WARN)\r\npr_info("%s: Illegal Interrupt Detected @ 0x%p, mod %d.)\n",\r\nci->devname, &ci->iqd_p[headx], headx);\r\nif (currInt == badInt)\r\nci->iqd_p[headx] = __constant_cpu_to_le32(INT_EMPTY_ENTRY2);\r\nelse\r\nci->iqd_p[headx] = __constant_cpu_to_le32(INT_EMPTY_ENTRY);\r\nci->iqp_headx = (headx + 1) & (INT_QUEUE_SIZE - 1);\r\nFLUSH_MEM_WRITE();\r\nFLUSH_MEM_READ();\r\ncontinue;\r\n}\r\ngroup = INTRPT_GRP(currInt);\r\ngchan = INTRPT_CH(currInt);\r\nevent = INTRPT_EVENT(currInt);\r\nerr = INTRPT_ERROR(currInt);\r\ntx = currInt & INTRPT_DIR_M;\r\nci->iqd_p[headx] = __constant_cpu_to_le32(INT_EMPTY_ENTRY);\r\nFLUSH_MEM_WRITE();\r\nif (cxt1e1_log_level >= LOG_DEBUG) {\r\nif (err != 0)\r\npr_info(" %08x -> err: %2d,", currInt, err);\r\npr_info("+ interrupt event: %d, grp: %d, chan: %2d, side: %cX\n",\r\nevent, group, gchan, tx ? 'T' : 'R');\r\n}\r\npi = &ci->port[group];\r\nch = pi->chan[gchan];\r\nswitch (event) {\r\ncase EVE_SACK:\r\nif (cxt1e1_log_level >= LOG_DEBUG) {\r\nvolatile u_int32_t r;\r\nr = pci_read_32((u_int32_t *) &pi->reg->srd);\r\npr_info("- SACK cmd: %08x (hdw= %08x)\n", pi->sr_last, r);\r\n}\r\nSD_SEM_GIVE(&pi->sr_sem_wait);\r\nbreak;\r\ncase EVE_CHABT:\r\ncase EVE_CHIC:\r\nbreak;\r\ncase EVE_EOM:\r\ncase EVE_EOB:\r\nif (tx)\r\nmusycc_bh_tx_eom(pi, gchan);\r\nelse\r\nmusycc_bh_rx_eom(pi, gchan);\r\n#if 0\r\nbreak;\r\n#else\r\n#endif\r\ncase EVE_NONE:\r\nif (err == ERR_SHT)\r\nch->s.rx_length_errors++;\r\nbreak;\r\ndefault:\r\nif (cxt1e1_log_level >= LOG_WARN)\r\npr_info("%s: unexpected interrupt event: %d, iqd[%d]: %08x, port: %d\n", ci->devname,\r\nevent, headx, currInt, group);\r\nbreak;\r\n}\r\nswitch (err) {\r\ncase ERR_ONR:\r\nif (tx) {\r\nch->ch_start_tx = CH_START_TX_ONR;\r\n{\r\n#ifdef RLD_TRANS_DEBUG\r\nif (1 || cxt1e1_log_level >= LOG_MONITOR)\r\n#else\r\nif (cxt1e1_log_level >= LOG_MONITOR)\r\n#endif\r\n{\r\npr_info("%s: TX buffer underflow [ONR] on channel %d, mode %x QStopped %x free %d\n",\r\nci->devname, ch->channum, ch->p.chan_mode, sd_queue_stopped(ch->user), ch->txd_free);\r\n#ifdef RLD_DEBUG\r\nif (ch->p.chan_mode == 2) {\r\npr_info("++ Failed Last %x Next %x QStopped %x, start_tx %x tx_full %d txd_free %d mode %x\n",\r\n(u_int32_t) ch->txd_irq_srv, (u_int32_t) ch->txd_usr_add,\r\nsd_queue_stopped(ch->user),\r\nch->ch_start_tx, ch->tx_full, ch->txd_free, ch->p.chan_mode);\r\nmusycc_dump_txbuffer_ring(ch, 0);\r\n}\r\n#endif\r\n}\r\n}\r\n} else {\r\nch->s.rx_over_errors++;\r\nch->ch_start_rx = CH_START_RX_ONR;\r\nif (cxt1e1_log_level >= LOG_WARN) {\r\npr_info("%s: RX buffer overflow [ONR] on channel %d, mode %x\n",\r\nci->devname, ch->channum, ch->p.chan_mode);\r\n}\r\n}\r\nmusycc_chan_restart(ch);\r\nbreak;\r\ncase ERR_BUF:\r\nif (tx) {\r\nch->s.tx_fifo_errors++;\r\nch->ch_start_tx = CH_START_TX_BUF;\r\nif (cxt1e1_log_level >= LOG_MONITOR)\r\npr_info("%s: TX buffer underrun [BUFF] on channel %d, mode %x\n",\r\nci->devname, ch->channum, ch->p.chan_mode);\r\n} else {\r\nch->s.rx_over_errors++;\r\nif (cxt1e1_log_level >= LOG_WARN)\r\npr_info("%s: RX buffer overrun [BUFF] on channel %d, mode %x\n",\r\nci->devname, ch->channum, ch->p.chan_mode);\r\nif (ch->p.chan_mode == CFG_CH_PROTO_TRANS)\r\nch->ch_start_rx = CH_START_RX_BUF;\r\n}\r\nif (tx || (ch->p.chan_mode == CFG_CH_PROTO_TRANS))\r\nmusycc_chan_restart(ch);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif ((currInt & INTRPT_ILOST_M) && (cxt1e1_log_level >= LOG_ERROR))\r\npr_info("%s: Interrupt queue overflow - ILOST asserted\n",\r\nci->devname);\r\nci->iqp_headx = (headx + 1) & (INT_QUEUE_SIZE - 1);\r\nFLUSH_MEM_WRITE();\r\nFLUSH_MEM_READ();\r\n}\r\nif ((cxt1e1_log_level >= LOG_MONITOR2) && (ci->iqp_headx != ci->iqp_tailx)) {\r\nint bh;\r\nbh = atomic_read(&CI->bh_pending);\r\npr_info("_bh_: late arrivals, head %d != tail %d, pending %d\n",\r\nci->iqp_headx, ci->iqp_tailx, bh);\r\n}\r\n#if defined(SBE_ISR_IMMEDIATE)\r\nreturn 0L;\r\n#endif\r\n}\r\nstatus_t\r\nmusycc_chan_down(ci_t * dummy, int channum)\r\n{\r\nmpi_t *pi;\r\nmch_t *ch;\r\nint i, gchan;\r\nif (!(ch = sd_find_chan(dummy, channum)))\r\nreturn EINVAL;\r\npi = ch->up;\r\ngchan = ch->gchan;\r\nmusycc_serv_req(pi, SR_CHANNEL_DEACTIVATE | SR_RX_DIRECTION | gchan);\r\nch->ch_start_rx = 0;\r\nmusycc_serv_req(pi, SR_CHANNEL_DEACTIVATE | SR_TX_DIRECTION | gchan);\r\nch->ch_start_tx = 0;\r\nif (ch->state == DOWN)\r\nreturn 0;\r\nch->state = DOWN;\r\npi->regram->thp[gchan] = 0;\r\npi->regram->tmp[gchan] = 0;\r\npi->regram->rhp[gchan] = 0;\r\npi->regram->rmp[gchan] = 0;\r\nFLUSH_MEM_WRITE();\r\nfor (i = 0; i < ch->txd_num; i++)\r\nif (ch->mdt[i].mem_token != 0)\r\nOS_mem_token_free(ch->mdt[i].mem_token);\r\nfor (i = 0; i < ch->rxd_num; i++)\r\nif (ch->mdr[i].mem_token != 0)\r\nOS_mem_token_free(ch->mdr[i].mem_token);\r\nOS_kfree(ch->mdr);\r\nch->mdr = 0;\r\nch->rxd_num = 0;\r\nOS_kfree(ch->mdt);\r\nch->mdt = 0;\r\nch->txd_num = 0;\r\nmusycc_update_timeslots(pi);\r\nc4_fifo_free(pi, ch->gchan);\r\npi->openchans--;\r\nreturn 0;\r\n}\r\nint\r\nmusycc_del_chan(ci_t * ci, int channum)\r\n{\r\nmch_t *ch;\r\nif ((channum < 0) || (channum >= (MUSYCC_NPORTS * MUSYCC_NCHANS)))\r\nreturn ECHRNG;\r\nif (!(ch = sd_find_chan(ci, channum)))\r\nreturn ENOENT;\r\nif (ch->state == UP)\r\nmusycc_chan_down(ci, channum);\r\nch->state = UNASSIGNED;\r\nreturn 0;\r\n}\r\nint\r\nmusycc_del_chan_stats(ci_t * ci, int channum)\r\n{\r\nmch_t *ch;\r\nif (channum < 0 || channum >= (MUSYCC_NPORTS * MUSYCC_NCHANS))\r\nreturn ECHRNG;\r\nif (!(ch = sd_find_chan(ci, channum)))\r\nreturn ENOENT;\r\nmemset(&ch->s, 0, sizeof(struct sbecom_chan_stats));\r\nreturn 0;\r\n}\r\nint\r\nmusycc_start_xmit(ci_t * ci, int channum, void *mem_token)\r\n{\r\nmch_t *ch;\r\nstruct mdesc *md;\r\nvoid *m2;\r\n#if 0\r\nunsigned long flags;\r\n#endif\r\nint txd_need_cnt;\r\nu_int32_t len;\r\nif (!(ch = sd_find_chan(ci, channum)))\r\nreturn -ENOENT;\r\nif (ci->state != C_RUNNING)\r\nreturn -EINVAL;\r\nif (ch->state != UP)\r\nreturn -EINVAL;\r\nif (!(ch->status & TX_ENABLED))\r\nreturn -EROFS;\r\n#ifdef RLD_TRANS_DEBUGx\r\nif (1 || cxt1e1_log_level >= LOG_MONITOR2)\r\n#else\r\nif (cxt1e1_log_level >= LOG_MONITOR2)\r\n#endif\r\n{\r\npr_info("++ start_xmt[%d]: state %x start %x full %d free %d required %d stopped %x\n",\r\nchannum, ch->state, ch->ch_start_tx, ch->tx_full,\r\nch->txd_free, ch->txd_required, sd_queue_stopped(ch->user));\r\n}\r\nm2 = mem_token;\r\ntxd_need_cnt = 0;\r\nfor (len = OS_mem_token_tlen(m2); len > 0;\r\nm2 = (void *) OS_mem_token_next(m2)) {\r\nif (!OS_mem_token_len(m2))\r\ncontinue;\r\ntxd_need_cnt++;\r\nlen -= OS_mem_token_len(m2);\r\n}\r\nif (txd_need_cnt == 0) {\r\nif (cxt1e1_log_level >= LOG_MONITOR2)\r\npr_info("%s channel %d: no TX data in User buffer\n", ci->devname, channum);\r\nOS_mem_token_free(mem_token);\r\nreturn 0;\r\n}\r\nif (txd_need_cnt > ch->txd_num) {\r\nif (cxt1e1_log_level >= LOG_DEBUG)\r\npr_info("start_xmit: discarding buffer, insufficient descriptor cnt %d, need %d.\n",\r\nch->txd_num, txd_need_cnt + 1);\r\nch->s.tx_dropped++;\r\nOS_mem_token_free(mem_token);\r\nreturn 0;\r\n}\r\n#if 0\r\nspin_lock_irqsave(&ch->ch_txlock, flags);\r\n#endif\r\nif (txd_need_cnt > ch->txd_free) {\r\nif (cxt1e1_log_level >= LOG_MONITOR2)\r\npr_info("start_xmit[%d]: EBUSY - need more descriptors, have %d of %d need %d\n",\r\nchannum, ch->txd_free, ch->txd_num, txd_need_cnt);\r\nch->tx_full = 1;\r\nch->txd_required = txd_need_cnt;\r\nsd_disable_xmit(ch->user);\r\n#if 0\r\nspin_unlock_irqrestore(&ch->ch_txlock, flags);\r\n#endif\r\nreturn -EBUSY;\r\n}\r\nm2 = mem_token;\r\nmd = ch->txd_usr_add;\r\nfor (len = OS_mem_token_tlen(m2); len > 0; m2 = OS_mem_token_next(m2)) {\r\nint u = OS_mem_token_len(m2);\r\nif (!u)\r\ncontinue;\r\nlen -= u;\r\nif (md != ch->txd_usr_add)\r\nu |= MUSYCC_TX_OWNED;\r\nif (len)\r\nu |= EOBIRQ_ENABLE;\r\nelse if (ch->p.chan_mode == CFG_CH_PROTO_TRANS) {\r\nu |= EOBIRQ_ENABLE;\r\n} else\r\nu |= EOMIRQ_ENABLE;\r\nu |= (ch->p.idlecode << IDLE_CODE);\r\nif (ch->p.pad_fill_count) {\r\n#if 0\r\nif (ch->p.pad_fill_count > EXTRA_FLAGS_MASK)\r\nch->p.pad_fill_count = EXTRA_FLAGS_MASK;\r\n#endif\r\nu |= (PADFILL_ENABLE | (ch->p.pad_fill_count << EXTRA_FLAGS));\r\n}\r\nmd->mem_token = len ? 0 : mem_token;\r\nmd->data = cpu_to_le32(OS_vtophys(OS_mem_token_data(m2)));\r\nFLUSH_MEM_WRITE();\r\nmd->status = cpu_to_le32(u);\r\n--ch->txd_free;\r\nmd = md->snext;\r\n}\r\nFLUSH_MEM_WRITE();\r\nch->txd_usr_add->status |= __constant_cpu_to_le32(MUSYCC_TX_OWNED);\r\nFLUSH_MEM_WRITE();\r\nch->txd_usr_add = md;\r\nlen = OS_mem_token_tlen(mem_token);\r\natomic_add(len, &ch->tx_pending);\r\natomic_add(len, &ci->tx_pending);\r\nch->s.tx_packets++;\r\nch->s.tx_bytes += len;\r\nif (ch->ch_start_tx)\r\nmusycc_chan_restart(ch);\r\n#ifdef SBE_WAN256T3_ENABLE\r\nwan256t3_led(ci, LED_TX, LEDV_G);\r\n#endif\r\nreturn 0;\r\n}
