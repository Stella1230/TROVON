static int msg_thread_exits(struct fsg_common *common)\r\n{\r\nmsg_cleanup();\r\nreturn 0;\r\n}\r\nstatic int __init msg_do_config(struct usb_configuration *c)\r\n{\r\nstatic const struct fsg_operations ops = {\r\n.thread_exits = msg_thread_exits,\r\n};\r\nstatic struct fsg_common common;\r\nstruct fsg_common *retp;\r\nstruct fsg_config config;\r\nint ret;\r\nif (gadget_is_otg(c->cdev->gadget)) {\r\nc->descriptors = otg_desc;\r\nc->bmAttributes |= USB_CONFIG_ATT_WAKEUP;\r\n}\r\nfsg_config_from_params(&config, &mod_data);\r\nconfig.ops = &ops;\r\nretp = fsg_common_init(&common, c->cdev, &config);\r\nif (IS_ERR(retp))\r\nreturn PTR_ERR(retp);\r\nret = fsg_bind_config(c->cdev, c, &common);\r\nfsg_common_put(&common);\r\nreturn ret;\r\n}\r\nstatic int __init msg_bind(struct usb_composite_dev *cdev)\r\n{\r\nint status;\r\nstatus = usb_string_ids_tab(cdev, strings_dev);\r\nif (status < 0)\r\nreturn status;\r\nmsg_device_desc.iProduct = strings_dev[USB_GADGET_PRODUCT_IDX].id;\r\nstatus = usb_add_config(cdev, &msg_config_driver, msg_do_config);\r\nif (status < 0)\r\nreturn status;\r\nusb_composite_overwrite_options(cdev, &coverwrite);\r\ndev_info(&cdev->gadget->dev,\r\nDRIVER_DESC ", version: " DRIVER_VERSION "\n");\r\nset_bit(0, &msg_registered);\r\nreturn 0;\r\n}\r\nstatic int __init msg_init(void)\r\n{\r\nreturn usb_composite_probe(&msg_driver);\r\n}\r\nstatic void msg_cleanup(void)\r\n{\r\nif (test_and_clear_bit(0, &msg_registered))\r\nusb_composite_unregister(&msg_driver);\r\n}
