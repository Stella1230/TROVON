static inline unsigned long vx2_reg_addr(struct vx_core *_chip, int reg)\r\n{\r\nstruct snd_vx222 *chip = (struct snd_vx222 *)_chip;\r\nreturn chip->port[vx2_reg_index[reg]] + vx2_reg_offset[reg];\r\n}\r\nstatic unsigned char vx2_inb(struct vx_core *chip, int offset)\r\n{\r\nreturn inb(vx2_reg_addr(chip, offset));\r\n}\r\nstatic void vx2_outb(struct vx_core *chip, int offset, unsigned char val)\r\n{\r\noutb(val, vx2_reg_addr(chip, offset));\r\n}\r\nstatic unsigned int vx2_inl(struct vx_core *chip, int offset)\r\n{\r\nreturn inl(vx2_reg_addr(chip, offset));\r\n}\r\nstatic void vx2_outl(struct vx_core *chip, int offset, unsigned int val)\r\n{\r\noutl(val, vx2_reg_addr(chip, offset));\r\n}\r\nstatic void vx2_reset_dsp(struct vx_core *_chip)\r\n{\r\nstruct snd_vx222 *chip = (struct snd_vx222 *)_chip;\r\nvx_outl(chip, CDSP, chip->regCDSP & ~VX_CDSP_DSP_RESET_MASK);\r\nmdelay(XX_DSP_RESET_WAIT_TIME);\r\nchip->regCDSP |= VX_CDSP_DSP_RESET_MASK;\r\nvx_outl(chip, CDSP, chip->regCDSP);\r\n}\r\nstatic int vx2_test_xilinx(struct vx_core *_chip)\r\n{\r\nstruct snd_vx222 *chip = (struct snd_vx222 *)_chip;\r\nunsigned int data;\r\nsnd_printdd("testing xilinx...\n");\r\nvx_outl(chip, CDSP, chip->regCDSP | VX_CDSP_TEST0_MASK);\r\nvx_inl(chip, ISR);\r\ndata = vx_inl(chip, STATUS);\r\nif ((data & VX_STATUS_VAL_TEST0_MASK) == VX_STATUS_VAL_TEST0_MASK) {\r\nsnd_printdd("bad!\n");\r\nreturn -ENODEV;\r\n}\r\nvx_outl(chip, CDSP, chip->regCDSP & ~VX_CDSP_TEST0_MASK);\r\nvx_inl(chip, ISR);\r\ndata = vx_inl(chip, STATUS);\r\nif (! (data & VX_STATUS_VAL_TEST0_MASK)) {\r\nsnd_printdd("bad! #2\n");\r\nreturn -ENODEV;\r\n}\r\nif (_chip->type == VX_TYPE_BOARD) {\r\nvx_outl(chip, CDSP, chip->regCDSP | VX_CDSP_TEST1_MASK);\r\nvx_inl(chip, ISR);\r\ndata = vx_inl(chip, STATUS);\r\nif ((data & VX_STATUS_VAL_TEST1_MASK) == VX_STATUS_VAL_TEST1_MASK) {\r\nsnd_printdd("bad! #3\n");\r\nreturn -ENODEV;\r\n}\r\nvx_outl(chip, CDSP, chip->regCDSP & ~VX_CDSP_TEST1_MASK);\r\nvx_inl(chip, ISR);\r\ndata = vx_inl(chip, STATUS);\r\nif (! (data & VX_STATUS_VAL_TEST1_MASK)) {\r\nsnd_printdd("bad! #4\n");\r\nreturn -ENODEV;\r\n}\r\n}\r\nsnd_printdd("ok, xilinx fine.\n");\r\nreturn 0;\r\n}\r\nstatic void vx2_setup_pseudo_dma(struct vx_core *chip, int do_write)\r\n{\r\nvx_outl(chip, ICR, do_write ? ICR_TREQ : ICR_RREQ);\r\nvx_outl(chip, RESET_DMA, 0);\r\n}\r\nstatic inline void vx2_release_pseudo_dma(struct vx_core *chip)\r\n{\r\nvx_outl(chip, ICR, 0);\r\n}\r\nstatic void vx2_dma_write(struct vx_core *chip, struct snd_pcm_runtime *runtime,\r\nstruct vx_pipe *pipe, int count)\r\n{\r\nunsigned long port = vx2_reg_addr(chip, VX_DMA);\r\nint offset = pipe->hw_ptr;\r\nu32 *addr = (u32 *)(runtime->dma_area + offset);\r\nif (snd_BUG_ON(count % 4))\r\nreturn;\r\nvx2_setup_pseudo_dma(chip, 1);\r\nif (offset + count > pipe->buffer_bytes) {\r\nint length = pipe->buffer_bytes - offset;\r\ncount -= length;\r\nlength >>= 2;\r\nwhile (length-- > 0) {\r\noutl(cpu_to_le32(*addr), port);\r\naddr++;\r\n}\r\naddr = (u32 *)runtime->dma_area;\r\npipe->hw_ptr = 0;\r\n}\r\npipe->hw_ptr += count;\r\ncount >>= 2;\r\nwhile (count-- > 0) {\r\noutl(cpu_to_le32(*addr), port);\r\naddr++;\r\n}\r\nvx2_release_pseudo_dma(chip);\r\n}\r\nstatic void vx2_dma_read(struct vx_core *chip, struct snd_pcm_runtime *runtime,\r\nstruct vx_pipe *pipe, int count)\r\n{\r\nint offset = pipe->hw_ptr;\r\nu32 *addr = (u32 *)(runtime->dma_area + offset);\r\nunsigned long port = vx2_reg_addr(chip, VX_DMA);\r\nif (snd_BUG_ON(count % 4))\r\nreturn;\r\nvx2_setup_pseudo_dma(chip, 0);\r\nif (offset + count > pipe->buffer_bytes) {\r\nint length = pipe->buffer_bytes - offset;\r\ncount -= length;\r\nlength >>= 2;\r\nwhile (length-- > 0)\r\n*addr++ = le32_to_cpu(inl(port));\r\naddr = (u32 *)runtime->dma_area;\r\npipe->hw_ptr = 0;\r\n}\r\npipe->hw_ptr += count;\r\ncount >>= 2;\r\nwhile (count-- > 0)\r\n*addr++ = le32_to_cpu(inl(port));\r\nvx2_release_pseudo_dma(chip);\r\n}\r\nstatic int put_xilinx_data(struct vx_core *chip, unsigned int port, unsigned int counts, unsigned char data)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < counts; i++) {\r\nunsigned int val;\r\nval = VX_CNTRL_REGISTER_VALUE & ~VX_USERBIT0_MASK;\r\nvx2_outl(chip, port, val);\r\nvx2_inl(chip, port);\r\nudelay(1);\r\nif (data & (1 << i))\r\nval |= VX_USERBIT1_MASK;\r\nelse\r\nval &= ~VX_USERBIT1_MASK;\r\nvx2_outl(chip, port, val);\r\nvx2_inl(chip, port);\r\nval |= VX_USERBIT0_MASK;\r\nvx2_outl(chip, port, val);\r\nvx2_inl(chip, port);\r\nudelay(1);\r\n}\r\nreturn 0;\r\n}\r\nstatic int vx2_load_xilinx_binary(struct vx_core *chip, const struct firmware *xilinx)\r\n{\r\nunsigned int i;\r\nunsigned int port;\r\nconst unsigned char *image;\r\nvx_outl(chip, CNTRL, VX_CNTRL_REGISTER_VALUE | VX_XILINX_RESET_MASK);\r\nvx_inl(chip, CNTRL);\r\nmsleep(10);\r\nvx_outl(chip, CNTRL, VX_CNTRL_REGISTER_VALUE);\r\nvx_inl(chip, CNTRL);\r\nmsleep(10);\r\nif (chip->type == VX_TYPE_BOARD)\r\nport = VX_CNTRL;\r\nelse\r\nport = VX_GPIOC;\r\nimage = xilinx->data;\r\nfor (i = 0; i < xilinx->size; i++, image++) {\r\nif (put_xilinx_data(chip, port, 8, *image) < 0)\r\nreturn -EINVAL;\r\ncond_resched();\r\n}\r\nput_xilinx_data(chip, port, 4, 0xff);\r\nmsleep(200);\r\nif (chip->type != VX_TYPE_BOARD) {\r\ni = vx_inl(chip, GPIOC);\r\nif (i & 0x0100)\r\nreturn 0;\r\nsnd_printk(KERN_ERR "vx222: xilinx test failed after load, GPIOC=0x%x\n", i);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int vx2_load_dsp(struct vx_core *vx, int index, const struct firmware *dsp)\r\n{\r\nint err;\r\nswitch (index) {\r\ncase 1:\r\nif ((err = vx2_load_xilinx_binary(vx, dsp)) < 0)\r\nreturn err;\r\nif ((err = vx2_test_xilinx(vx)) < 0)\r\nreturn err;\r\nreturn 0;\r\ncase 2:\r\nreturn snd_vx_dsp_boot(vx, dsp);\r\ncase 3:\r\nreturn snd_vx_dsp_load(vx, dsp);\r\ndefault:\r\nsnd_BUG();\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic int vx2_test_and_ack(struct vx_core *chip)\r\n{\r\nif (! (chip->chip_status & VX_STAT_XILINX_LOADED))\r\nreturn -ENXIO;\r\nif (! (vx_inl(chip, STATUS) & VX_STATUS_MEMIRQ_MASK))\r\nreturn -EIO;\r\nvx_outl(chip, STATUS, 0);\r\nvx_inl(chip, STATUS);\r\nvx_outl(chip, STATUS, VX_STATUS_MEMIRQ_MASK);\r\nvx_inl(chip, STATUS);\r\nvx_outl(chip, STATUS, 0);\r\nreturn 0;\r\n}\r\nstatic void vx2_validate_irq(struct vx_core *_chip, int enable)\r\n{\r\nstruct snd_vx222 *chip = (struct snd_vx222 *)_chip;\r\nif (enable) {\r\nvx_outl(chip, INTCSR, VX_INTCSR_VALUE|VX_PCI_INTERRUPT_MASK);\r\nchip->regCDSP |= VX_CDSP_VALID_IRQ_MASK;\r\n} else {\r\nvx_outl(chip, INTCSR, VX_INTCSR_VALUE&~VX_PCI_INTERRUPT_MASK);\r\nchip->regCDSP &= ~VX_CDSP_VALID_IRQ_MASK;\r\n}\r\nvx_outl(chip, CDSP, chip->regCDSP);\r\n}\r\nstatic void vx2_write_codec_reg(struct vx_core *chip, unsigned int data)\r\n{\r\nunsigned int i;\r\nvx_inl(chip, HIFREQ);\r\nfor (i = 0; i < 24; i++, data <<= 1)\r\nvx_outl(chip, DATA, ((data & 0x800000) ? VX_DATA_CODEC_MASK : 0));\r\nvx_inl(chip, RUER);\r\n}\r\nstatic void vx2_write_akm(struct vx_core *chip, int reg, unsigned int data)\r\n{\r\nunsigned int val;\r\nif (reg == XX_CODEC_DAC_CONTROL_REGISTER) {\r\nvx2_write_codec_reg(chip, data ? AKM_CODEC_MUTE_CMD : AKM_CODEC_UNMUTE_CMD);\r\nreturn;\r\n}\r\nif (snd_BUG_ON(data >= sizeof(vx2_akm_gains_lut)))\r\nreturn;\r\nswitch (reg) {\r\ncase XX_CODEC_LEVEL_LEFT_REGISTER:\r\nval = AKM_CODEC_LEFT_LEVEL_CMD;\r\nbreak;\r\ncase XX_CODEC_LEVEL_RIGHT_REGISTER:\r\nval = AKM_CODEC_RIGHT_LEVEL_CMD;\r\nbreak;\r\ndefault:\r\nsnd_BUG();\r\nreturn;\r\n}\r\nval |= vx2_akm_gains_lut[data];\r\nvx2_write_codec_reg(chip, val);\r\n}\r\nstatic void vx2_old_write_codec_bit(struct vx_core *chip, int codec, unsigned int data)\r\n{\r\nint i;\r\nvx_inl(chip, HIFREQ);\r\nfor (i = 0; i < 24; i++, data <<= 1)\r\nvx_outl(chip, DATA, ((data & 0x800000) ? VX_DATA_CODEC_MASK : 0));\r\nvx_inl(chip, RUER);\r\n}\r\nstatic void vx2_reset_codec(struct vx_core *_chip)\r\n{\r\nstruct snd_vx222 *chip = (struct snd_vx222 *)_chip;\r\nvx_outl(chip, CDSP, chip->regCDSP &~ VX_CDSP_CODEC_RESET_MASK);\r\nvx_inl(chip, CDSP);\r\nmsleep(10);\r\nchip->regCDSP |= VX_CDSP_CODEC_RESET_MASK;\r\nvx_outl(chip, CDSP, chip->regCDSP);\r\nvx_inl(chip, CDSP);\r\nif (_chip->type == VX_TYPE_BOARD) {\r\nmsleep(1);\r\nreturn;\r\n}\r\nmsleep(5);\r\nvx2_write_codec_reg(_chip, AKM_CODEC_POWER_CONTROL_CMD);\r\nvx2_write_codec_reg(_chip, AKM_CODEC_CLOCK_FORMAT_CMD);\r\nvx2_write_codec_reg(_chip, AKM_CODEC_MUTE_CMD);\r\nvx2_write_codec_reg(_chip, AKM_CODEC_RESET_OFF_CMD);\r\nif (_chip->type == VX_TYPE_MIC) {\r\nchip->regSELMIC = MICRO_SELECT_INPUT_NORM |\r\nMICRO_SELECT_PREAMPLI_G_0 |\r\nMICRO_SELECT_NOISE_T_52DB;\r\nchip->regSELMIC &= ~MICRO_SELECT_PHANTOM_ALIM;\r\nvx_outl(_chip, SELMIC, chip->regSELMIC);\r\n}\r\n}\r\nstatic void vx2_change_audio_source(struct vx_core *_chip, int src)\r\n{\r\nstruct snd_vx222 *chip = (struct snd_vx222 *)_chip;\r\nswitch (src) {\r\ncase VX_AUDIO_SRC_DIGITAL:\r\nchip->regCFG |= VX_CFG_DATAIN_SEL_MASK;\r\nbreak;\r\ndefault:\r\nchip->regCFG &= ~VX_CFG_DATAIN_SEL_MASK;\r\nbreak;\r\n}\r\nvx_outl(chip, CFG, chip->regCFG);\r\n}\r\nstatic void vx2_set_clock_source(struct vx_core *_chip, int source)\r\n{\r\nstruct snd_vx222 *chip = (struct snd_vx222 *)_chip;\r\nif (source == INTERNAL_QUARTZ)\r\nchip->regCFG &= ~VX_CFG_CLOCKIN_SEL_MASK;\r\nelse\r\nchip->regCFG |= VX_CFG_CLOCKIN_SEL_MASK;\r\nvx_outl(chip, CFG, chip->regCFG);\r\n}\r\nstatic void vx2_reset_board(struct vx_core *_chip, int cold_reset)\r\n{\r\nstruct snd_vx222 *chip = (struct snd_vx222 *)_chip;\r\nchip->regCDSP = VX_CDSP_CODEC_RESET_MASK | VX_CDSP_DSP_RESET_MASK ;\r\nchip->regCFG = 0;\r\n}\r\nstatic void vx2_set_input_level(struct snd_vx222 *chip)\r\n{\r\nint i, miclevel, preamp;\r\nunsigned int data;\r\nmiclevel = chip->mic_level;\r\nmiclevel += V2_MICRO_LEVEL_RANGE;\r\npreamp = 0;\r\nwhile (miclevel > 210) {\r\npreamp++;\r\nmiclevel -= (18 * 2);\r\n}\r\nif (snd_BUG_ON(preamp >= 4))\r\nreturn;\r\nchip->regSELMIC &= ~MICRO_SELECT_PREAMPLI_MASK;\r\nchip->regSELMIC |= (preamp << MICRO_SELECT_PREAMPLI_OFFSET) & MICRO_SELECT_PREAMPLI_MASK;\r\nvx_outl(chip, SELMIC, chip->regSELMIC);\r\ndata = (unsigned int)miclevel << 16 |\r\n(unsigned int)chip->input_level[1] << 8 |\r\n(unsigned int)chip->input_level[0];\r\nvx_inl(chip, DATA);\r\nfor (i = 0; i < 32; i++, data <<= 1)\r\nvx_outl(chip, DATA, ((data & 0x80000000) ? VX_DATA_CODEC_MASK : 0));\r\nvx_inl(chip, RUER);\r\n}\r\nstatic int vx_input_level_info(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\r\n{\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\r\nuinfo->count = 2;\r\nuinfo->value.integer.min = 0;\r\nuinfo->value.integer.max = MIC_LEVEL_MAX;\r\nreturn 0;\r\n}\r\nstatic int vx_input_level_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct vx_core *_chip = snd_kcontrol_chip(kcontrol);\r\nstruct snd_vx222 *chip = (struct snd_vx222 *)_chip;\r\nmutex_lock(&_chip->mixer_mutex);\r\nucontrol->value.integer.value[0] = chip->input_level[0];\r\nucontrol->value.integer.value[1] = chip->input_level[1];\r\nmutex_unlock(&_chip->mixer_mutex);\r\nreturn 0;\r\n}\r\nstatic int vx_input_level_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct vx_core *_chip = snd_kcontrol_chip(kcontrol);\r\nstruct snd_vx222 *chip = (struct snd_vx222 *)_chip;\r\nif (ucontrol->value.integer.value[0] < 0 ||\r\nucontrol->value.integer.value[0] > MIC_LEVEL_MAX)\r\nreturn -EINVAL;\r\nif (ucontrol->value.integer.value[1] < 0 ||\r\nucontrol->value.integer.value[1] > MIC_LEVEL_MAX)\r\nreturn -EINVAL;\r\nmutex_lock(&_chip->mixer_mutex);\r\nif (chip->input_level[0] != ucontrol->value.integer.value[0] ||\r\nchip->input_level[1] != ucontrol->value.integer.value[1]) {\r\nchip->input_level[0] = ucontrol->value.integer.value[0];\r\nchip->input_level[1] = ucontrol->value.integer.value[1];\r\nvx2_set_input_level(chip);\r\nmutex_unlock(&_chip->mixer_mutex);\r\nreturn 1;\r\n}\r\nmutex_unlock(&_chip->mixer_mutex);\r\nreturn 0;\r\n}\r\nstatic int vx_mic_level_info(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\r\n{\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\r\nuinfo->count = 1;\r\nuinfo->value.integer.min = 0;\r\nuinfo->value.integer.max = MIC_LEVEL_MAX;\r\nreturn 0;\r\n}\r\nstatic int vx_mic_level_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct vx_core *_chip = snd_kcontrol_chip(kcontrol);\r\nstruct snd_vx222 *chip = (struct snd_vx222 *)_chip;\r\nucontrol->value.integer.value[0] = chip->mic_level;\r\nreturn 0;\r\n}\r\nstatic int vx_mic_level_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct vx_core *_chip = snd_kcontrol_chip(kcontrol);\r\nstruct snd_vx222 *chip = (struct snd_vx222 *)_chip;\r\nif (ucontrol->value.integer.value[0] < 0 ||\r\nucontrol->value.integer.value[0] > MIC_LEVEL_MAX)\r\nreturn -EINVAL;\r\nmutex_lock(&_chip->mixer_mutex);\r\nif (chip->mic_level != ucontrol->value.integer.value[0]) {\r\nchip->mic_level = ucontrol->value.integer.value[0];\r\nvx2_set_input_level(chip);\r\nmutex_unlock(&_chip->mixer_mutex);\r\nreturn 1;\r\n}\r\nmutex_unlock(&_chip->mixer_mutex);\r\nreturn 0;\r\n}\r\nstatic int vx2_add_mic_controls(struct vx_core *_chip)\r\n{\r\nstruct snd_vx222 *chip = (struct snd_vx222 *)_chip;\r\nint err;\r\nif (_chip->type != VX_TYPE_MIC)\r\nreturn 0;\r\nchip->input_level[0] = chip->input_level[1] = 0;\r\nchip->mic_level = 0;\r\nvx2_set_input_level(chip);\r\nif ((err = snd_ctl_add(_chip->card, snd_ctl_new1(&vx_control_input_level, chip))) < 0)\r\nreturn err;\r\nif ((err = snd_ctl_add(_chip->card, snd_ctl_new1(&vx_control_mic_level, chip))) < 0)\r\nreturn err;\r\nreturn 0;\r\n}
