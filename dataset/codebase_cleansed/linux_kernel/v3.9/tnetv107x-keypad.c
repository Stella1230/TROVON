static irqreturn_t keypad_irq(int irq, void *data)\r\n{\r\nstruct keypad_data *kp = data;\r\nint i, bit, val, row, col, code;\r\nunsigned long flags;\r\nu32 curr_keys[3];\r\nu32 change;\r\nspin_lock_irqsave(&kp->lock, flags);\r\nmemset(curr_keys, 0, sizeof(curr_keys));\r\nif (irq == kp->irq_press)\r\nfor (i = 0; i < 3; i++)\r\ncurr_keys[i] = keypad_read(kp, pres[i]);\r\nfor (i = 0; i < 3; i++) {\r\nchange = curr_keys[i] ^ kp->prev_keys[i];\r\nwhile (change) {\r\nbit = fls(change) - 1;\r\nchange ^= BIT(bit);\r\nval = curr_keys[i] & BIT(bit);\r\nbit += i * 32;\r\nrow = bit / KEYPAD_COLS;\r\ncol = bit % KEYPAD_COLS;\r\ncode = MATRIX_SCAN_CODE(row, col, kp->row_shift);\r\ninput_event(kp->input_dev, EV_MSC, MSC_SCAN, code);\r\ninput_report_key(kp->input_dev, kp->keycodes[code],\r\nval);\r\n}\r\n}\r\ninput_sync(kp->input_dev);\r\nmemcpy(kp->prev_keys, curr_keys, sizeof(curr_keys));\r\nif (irq == kp->irq_press)\r\nkeypad_write(kp, lock, 0);\r\nspin_unlock_irqrestore(&kp->lock, flags);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int keypad_start(struct input_dev *dev)\r\n{\r\nstruct keypad_data *kp = input_get_drvdata(dev);\r\nunsigned long mask, debounce, clk_rate_khz;\r\nunsigned long flags;\r\nclk_enable(kp->clk);\r\nclk_rate_khz = clk_get_rate(kp->clk) / 1000;\r\nspin_lock_irqsave(&kp->lock, flags);\r\nkeypad_write(kp, mode, 0);\r\nmask = BITS(kp->rows) << KEYPAD_COLS;\r\nmask |= BITS(kp->cols);\r\nkeypad_write(kp, mask, ~mask);\r\nkeypad_write(kp, pol, kp->active_low ? 0 : 0x3ffff);\r\nkeypad_write(kp, stable_cnt, 3);\r\ndebounce = kp->debounce_ms * clk_rate_khz;\r\ndebounce = clamp(debounce, DEBOUNCE_MIN, DEBOUNCE_MAX);\r\nkeypad_write(kp, dclock, debounce);\r\nkeypad_write(kp, rclock, 4 * debounce);\r\nkeypad_write(kp, in_en, 1);\r\nspin_unlock_irqrestore(&kp->lock, flags);\r\nreturn 0;\r\n}\r\nstatic void keypad_stop(struct input_dev *dev)\r\n{\r\nstruct keypad_data *kp = input_get_drvdata(dev);\r\nsynchronize_irq(kp->irq_press);\r\nsynchronize_irq(kp->irq_release);\r\nclk_disable(kp->clk);\r\n}\r\nstatic int keypad_probe(struct platform_device *pdev)\r\n{\r\nconst struct matrix_keypad_platform_data *pdata;\r\nconst struct matrix_keymap_data *keymap_data;\r\nstruct device *dev = &pdev->dev;\r\nstruct keypad_data *kp;\r\nint error = 0, sz, row_shift;\r\nu32 rev = 0;\r\npdata = pdev->dev.platform_data;\r\nif (!pdata) {\r\ndev_err(dev, "cannot find device data\n");\r\nreturn -EINVAL;\r\n}\r\nkeymap_data = pdata->keymap_data;\r\nif (!keymap_data) {\r\ndev_err(dev, "cannot find keymap data\n");\r\nreturn -EINVAL;\r\n}\r\nrow_shift = get_count_order(pdata->num_col_gpios);\r\nsz = offsetof(struct keypad_data, keycodes);\r\nsz += (pdata->num_row_gpios << row_shift) * sizeof(kp->keycodes[0]);\r\nkp = kzalloc(sz, GFP_KERNEL);\r\nif (!kp) {\r\ndev_err(dev, "cannot allocate device info\n");\r\nreturn -ENOMEM;\r\n}\r\nkp->dev = dev;\r\nkp->rows = pdata->num_row_gpios;\r\nkp->cols = pdata->num_col_gpios;\r\nkp->row_shift = row_shift;\r\nplatform_set_drvdata(pdev, kp);\r\nspin_lock_init(&kp->lock);\r\nkp->irq_press = platform_get_irq_byname(pdev, "press");\r\nkp->irq_release = platform_get_irq_byname(pdev, "release");\r\nif (kp->irq_press < 0 || kp->irq_release < 0) {\r\ndev_err(dev, "cannot determine device interrupts\n");\r\nerror = -ENODEV;\r\ngoto error_res;\r\n}\r\nkp->res = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!kp->res) {\r\ndev_err(dev, "cannot determine register area\n");\r\nerror = -ENODEV;\r\ngoto error_res;\r\n}\r\nif (!request_mem_region(kp->res->start, resource_size(kp->res),\r\npdev->name)) {\r\ndev_err(dev, "cannot claim register memory\n");\r\nkp->res = NULL;\r\nerror = -EINVAL;\r\ngoto error_res;\r\n}\r\nkp->regs = ioremap(kp->res->start, resource_size(kp->res));\r\nif (!kp->regs) {\r\ndev_err(dev, "cannot map register memory\n");\r\nerror = -ENOMEM;\r\ngoto error_map;\r\n}\r\nkp->clk = clk_get(dev, NULL);\r\nif (IS_ERR(kp->clk)) {\r\ndev_err(dev, "cannot claim device clock\n");\r\nerror = PTR_ERR(kp->clk);\r\ngoto error_clk;\r\n}\r\nerror = request_threaded_irq(kp->irq_press, NULL, keypad_irq,\r\nIRQF_ONESHOT, dev_name(dev), kp);\r\nif (error < 0) {\r\ndev_err(kp->dev, "Could not allocate keypad press key irq\n");\r\ngoto error_irq_press;\r\n}\r\nerror = request_threaded_irq(kp->irq_release, NULL, keypad_irq,\r\nIRQF_ONESHOT, dev_name(dev), kp);\r\nif (error < 0) {\r\ndev_err(kp->dev, "Could not allocate keypad release key irq\n");\r\ngoto error_irq_release;\r\n}\r\nkp->input_dev = input_allocate_device();\r\nif (!kp->input_dev) {\r\ndev_err(dev, "cannot allocate input device\n");\r\nerror = -ENOMEM;\r\ngoto error_input;\r\n}\r\nkp->input_dev->name = pdev->name;\r\nkp->input_dev->dev.parent = &pdev->dev;\r\nkp->input_dev->open = keypad_start;\r\nkp->input_dev->close = keypad_stop;\r\nclk_enable(kp->clk);\r\nrev = keypad_read(kp, rev);\r\nkp->input_dev->id.bustype = BUS_HOST;\r\nkp->input_dev->id.product = ((rev >> 8) & 0x07);\r\nkp->input_dev->id.version = ((rev >> 16) & 0xfff);\r\nclk_disable(kp->clk);\r\nerror = matrix_keypad_build_keymap(keymap_data, NULL,\r\nkp->rows, kp->cols,\r\nkp->keycodes, kp->input_dev);\r\nif (error) {\r\ndev_err(dev, "Failed to build keymap\n");\r\ngoto error_reg;\r\n}\r\nif (!pdata->no_autorepeat)\r\nkp->input_dev->evbit[0] |= BIT_MASK(EV_REP);\r\ninput_set_capability(kp->input_dev, EV_MSC, MSC_SCAN);\r\ninput_set_drvdata(kp->input_dev, kp);\r\nerror = input_register_device(kp->input_dev);\r\nif (error < 0) {\r\ndev_err(dev, "Could not register input device\n");\r\ngoto error_reg;\r\n}\r\nreturn 0;\r\nerror_reg:\r\ninput_free_device(kp->input_dev);\r\nerror_input:\r\nfree_irq(kp->irq_release, kp);\r\nerror_irq_release:\r\nfree_irq(kp->irq_press, kp);\r\nerror_irq_press:\r\nclk_put(kp->clk);\r\nerror_clk:\r\niounmap(kp->regs);\r\nerror_map:\r\nrelease_mem_region(kp->res->start, resource_size(kp->res));\r\nerror_res:\r\nplatform_set_drvdata(pdev, NULL);\r\nkfree(kp);\r\nreturn error;\r\n}\r\nstatic int keypad_remove(struct platform_device *pdev)\r\n{\r\nstruct keypad_data *kp = platform_get_drvdata(pdev);\r\nfree_irq(kp->irq_press, kp);\r\nfree_irq(kp->irq_release, kp);\r\ninput_unregister_device(kp->input_dev);\r\nclk_put(kp->clk);\r\niounmap(kp->regs);\r\nrelease_mem_region(kp->res->start, resource_size(kp->res));\r\nplatform_set_drvdata(pdev, NULL);\r\nkfree(kp);\r\nreturn 0;\r\n}
