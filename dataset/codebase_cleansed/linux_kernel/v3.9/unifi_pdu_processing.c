static void _update_buffered_pkt_params_after_alignment(unifi_priv_t *priv, bulk_data_param_t *bulkdata,\r\ntx_buffered_packets_t* buffered_pkt)\r\n{\r\nstruct sk_buff *skb ;\r\nu32 align_offset;\r\nif (priv == NULL || bulkdata == NULL || buffered_pkt == NULL){\r\nreturn;\r\n}\r\nskb = (struct sk_buff*)bulkdata->d[0].os_net_buf_ptr;\r\nalign_offset = (u32)(long)(bulkdata->d[0].os_data_ptr) & (CSR_WIFI_ALIGN_BYTES-1);\r\nif(align_offset){\r\nskb_pull(skb,align_offset);\r\n}\r\nbuffered_pkt->bulkdata.os_data_ptr = bulkdata->d[0].os_data_ptr;\r\nbuffered_pkt->bulkdata.data_length = bulkdata->d[0].data_length;\r\nbuffered_pkt->bulkdata.os_net_buf_ptr = bulkdata->d[0].os_net_buf_ptr;\r\nbuffered_pkt->bulkdata.net_buf_length = bulkdata->d[0].net_buf_length;\r\n}\r\nvoid\r\nunifi_frame_ma_packet_req(unifi_priv_t *priv, CSR_PRIORITY priority,\r\nCSR_RATE TransmitRate, CSR_CLIENT_TAG hostTag,\r\nu16 interfaceTag, CSR_TRANSMISSION_CONTROL transmissionControl,\r\nCSR_PROCESS_ID leSenderProcessId, u8 *peerMacAddress,\r\nCSR_SIGNAL *signal)\r\n{\r\nCSR_MA_PACKET_REQUEST *req = &signal->u.MaPacketRequest;\r\nnetInterface_priv_t *interfacePriv;\r\nu8 ba_session_idx = 0;\r\nba_session_tx_struct *ba_session = NULL;\r\nu8 *ba_addr = NULL;\r\ninterfacePriv = priv->interfacePriv[interfaceTag];\r\nunifi_trace(priv, UDBG5,\r\n"In unifi_frame_ma_packet_req, Frame for Peer: %pMF\n",\r\npeerMacAddress);\r\nsignal->SignalPrimitiveHeader.SignalId = CSR_MA_PACKET_REQUEST_ID;\r\nsignal->SignalPrimitiveHeader.ReceiverProcessId = 0;\r\nsignal->SignalPrimitiveHeader.SenderProcessId = leSenderProcessId;\r\nreq->Priority = priority;\r\nunifi_trace(priv, UDBG3, "Tx Frame with Priority: 0x%x\n", req->Priority);\r\nreq->TransmitRate = TransmitRate;\r\nreq->TransmissionControl = transmissionControl;\r\nreq->VirtualInterfaceIdentifier =\r\nuf_get_vif_identifier(interfacePriv->interfaceMode,interfaceTag);\r\nmemcpy(req->Ra.x, peerMacAddress, ETH_ALEN);\r\nif (hostTag == 0xffffffff) {\r\nreq->HostTag = interfacePriv->tag++;\r\nreq->HostTag |= 0x40000000;\r\nunifi_trace(priv, UDBG3, "new host tag assigned = 0x%x\n", req->HostTag);\r\ninterfacePriv->tag &= 0x0fffffff;\r\n} else {\r\nreq->HostTag = hostTag;\r\nunifi_trace(priv, UDBG3, "host tag got from SME = 0x%x\n", req->HostTag);\r\n}\r\nif(interfacePriv->interfaceMode == CSR_WIFI_ROUTER_CTRL_MODE_AP ||\r\ninterfacePriv->interfaceMode == CSR_WIFI_ROUTER_CTRL_MODE_P2PGO){\r\nba_addr = peerMacAddress;\r\n}else{\r\nba_addr = interfacePriv->bssid.a;\r\n}\r\nfor (ba_session_idx=0; ba_session_idx < MAX_SUPPORTED_BA_SESSIONS_TX; ba_session_idx++){\r\nba_session = interfacePriv->ba_session_tx[ba_session_idx];\r\nif (ba_session){\r\nif ((!memcmp(ba_session->macAddress.a, ba_addr, ETH_ALEN)) && (ba_session->tID == priority)){\r\nreq->TransmissionControl |= CSR_ALLOW_BA;\r\nbreak;\r\n}\r\n}\r\n}\r\nunifi_trace(priv, UDBG5, "leaving unifi_frame_ma_packet_req\n");\r\n}\r\nstatic\r\nint frame_and_send_queued_pdu(unifi_priv_t* priv,tx_buffered_packets_t* buffered_pkt,\r\nCsrWifiRouterCtrlStaInfo_t *staRecord,u8 moreData , u8 eosp)\r\n{\r\nCSR_SIGNAL signal;\r\nbulk_data_param_t bulkdata;\r\nint result;\r\nu8 toDs, fromDs, macHeaderLengthInBytes = MAC_HEADER_SIZE;\r\nu8 *qc;\r\nu16 *fc = (u16*)(buffered_pkt->bulkdata.os_data_ptr);\r\nunsigned long lock_flags;\r\nunifi_trace(priv, UDBG3, "frame_and_send_queued_pdu with moreData: %d , EOSP: %d\n",moreData,eosp);\r\nunifi_frame_ma_packet_req(priv, buffered_pkt->priority, buffered_pkt->rate, buffered_pkt->hostTag,\r\nbuffered_pkt->interfaceTag, buffered_pkt->transmissionControl,\r\nbuffered_pkt->leSenderProcessId, buffered_pkt->peerMacAddress.a, &signal);\r\nbulkdata.d[0].os_data_ptr = buffered_pkt->bulkdata.os_data_ptr;\r\nbulkdata.d[0].data_length = buffered_pkt->bulkdata.data_length;\r\nbulkdata.d[0].os_net_buf_ptr = buffered_pkt->bulkdata.os_net_buf_ptr;\r\nbulkdata.d[0].net_buf_length = buffered_pkt->bulkdata.net_buf_length;\r\nbulkdata.d[1].os_data_ptr = NULL;\r\nbulkdata.d[1].data_length = 0;\r\nbulkdata.d[1].os_net_buf_ptr =0;\r\nbulkdata.d[1].net_buf_length =0;\r\nif(moreData) {\r\n*fc |= cpu_to_le16(IEEE802_11_FC_MOREDATA_MASK);\r\n} else {\r\n*fc &= cpu_to_le16(~IEEE802_11_FC_MOREDATA_MASK);\r\n}\r\nif((staRecord != NULL)&& (staRecord->wmmOrQosEnabled == TRUE))\r\n{\r\nunifi_trace(priv, UDBG3, "frame_and_send_queued_pdu WMM Enabled: %d \n",staRecord->wmmOrQosEnabled);\r\ntoDs = (*fc & cpu_to_le16(IEEE802_11_FC_TO_DS_MASK))?1 : 0;\r\nfromDs = (*fc & cpu_to_le16(IEEE802_11_FC_FROM_DS_MASK))? 1: 0;\r\nswitch(le16_to_cpu(*fc) & IEEE80211_FC_SUBTYPE_MASK)\r\n{\r\ncase IEEE802_11_FC_TYPE_QOS_DATA & IEEE80211_FC_SUBTYPE_MASK:\r\ncase IEEE802_11_FC_TYPE_QOS_NULL & IEEE80211_FC_SUBTYPE_MASK:\r\nif (fromDs && toDs) {\r\nmacHeaderLengthInBytes += (QOS_CONTROL_HEADER_SIZE + 6);\r\n} else {\r\nmacHeaderLengthInBytes += QOS_CONTROL_HEADER_SIZE;\r\n}\r\nif (*fc & cpu_to_le16(IEEE80211_FC_ORDER_MASK)) {\r\nmacHeaderLengthInBytes += HT_CONTROL_HEADER_SIZE;\r\nqc = (u8*)(buffered_pkt->bulkdata.os_data_ptr + (macHeaderLengthInBytes-6));\r\n} else {\r\nqc = (u8*)(buffered_pkt->bulkdata.os_data_ptr + (macHeaderLengthInBytes-2));\r\n}\r\n*qc = eosp ? *qc | (1 << 4) : *qc & (~(1 << 4));\r\nbreak;\r\ndefault:\r\nif (fromDs && toDs)\r\nmacHeaderLengthInBytes += 6;\r\n}\r\n}\r\nresult = ul_send_signal_unpacked(priv, &signal, &bulkdata);\r\nif(result){\r\n_update_buffered_pkt_params_after_alignment(priv, &bulkdata,buffered_pkt);\r\n}\r\nif (result != -ENOSPC) {\r\nif (!priv->noOfPktQueuedInDriver) {\r\nunifi_error(priv, "packets queued in driver 0 still decrementing\n");\r\n} else {\r\nspin_lock_irqsave(&priv->tx_q_lock,lock_flags);\r\npriv->noOfPktQueuedInDriver--;\r\nspin_unlock_irqrestore(&priv->tx_q_lock,lock_flags);\r\n}\r\nif (staRecord) {\r\nspin_lock_irqsave(&priv->staRecord_lock,lock_flags);\r\nif (!staRecord->noOfPktQueued) {\r\nunifi_error(priv, "packets queued in driver per station is 0 still decrementing\n");\r\n} else {\r\nstaRecord->noOfPktQueued--;\r\n}\r\nif (result){\r\nif (staRecord->nullDataHostTag == buffered_pkt->hostTag){\r\nstaRecord->nullDataHostTag = INVALID_HOST_TAG;\r\n}\r\n}\r\nspin_unlock_irqrestore(&priv->staRecord_lock,lock_flags);\r\n}\r\n}\r\nreturn result;\r\n}\r\nstatic\r\nvoid set_eosp_transmit_ctrl(unifi_priv_t *priv, struct list_head *txList)\r\n{\r\ntx_buffered_packets_t *tx_q_item = NULL;\r\nstruct list_head *listHead;\r\nstruct list_head *placeHolder;\r\nunsigned long lock_flags;\r\nunifi_trace(priv, UDBG5, "entering set_eosp_transmit_ctrl\n");\r\nif (list_empty(txList)) {\r\nunifi_warning(priv, "In set_eosp_transmit_ctrl, the list is empty\n");\r\nreturn;\r\n}\r\nspin_lock_irqsave(&priv->tx_q_lock,lock_flags);\r\nlist_for_each_prev_safe(listHead, placeHolder, txList) {\r\ntx_q_item = list_entry(listHead, tx_buffered_packets_t, q);\r\ntx_q_item->transmissionControl |= TRANSMISSION_CONTROL_EOSP_MASK;\r\ntx_q_item->transmissionControl = (tx_q_item->transmissionControl & ~(CSR_NO_CONFIRM_REQUIRED));\r\nunifi_trace(priv, UDBG1,\r\n"set_eosp_transmit_ctrl Transmission Control = 0x%x hostTag = 0x%x \n",tx_q_item->transmissionControl,tx_q_item->hostTag);\r\nunifi_trace(priv,UDBG3,"in set_eosp_transmit_ctrl no.of buffered frames %d\n",priv->noOfPktQueuedInDriver);\r\nbreak;\r\n}\r\nspin_unlock_irqrestore(&priv->tx_q_lock,lock_flags);\r\nunifi_trace(priv, UDBG1,"List Empty %d\n",list_empty(txList));\r\nunifi_trace(priv, UDBG5, "leaving set_eosp_transmit_ctrl\n");\r\nreturn;\r\n}\r\nstatic\r\nvoid send_vif_availibility_rsp(unifi_priv_t *priv,CSR_VIF_IDENTIFIER vif,CSR_RESULT_CODE resultCode)\r\n{\r\nCSR_SIGNAL signal;\r\nCSR_MA_VIF_AVAILABILITY_RESPONSE *rsp;\r\nbulk_data_param_t *bulkdata = NULL;\r\nint r;\r\nunifi_trace(priv, UDBG3, "send_vif_availibility_rsp : invoked with resultCode = %d \n", resultCode);\r\nmemset(&signal,0,sizeof(CSR_SIGNAL));\r\nrsp = &signal.u.MaVifAvailabilityResponse;\r\nrsp->VirtualInterfaceIdentifier = vif;\r\nrsp->ResultCode = resultCode;\r\nsignal.SignalPrimitiveHeader.SignalId = CSR_MA_VIF_AVAILABILITY_RESPONSE_ID;\r\nsignal.SignalPrimitiveHeader.ReceiverProcessId = 0;\r\nsignal.SignalPrimitiveHeader.SenderProcessId = priv->netdev_client->sender_id;\r\nr = ul_send_signal_unpacked(priv, &signal, bulkdata);\r\nif(r) {\r\nunifi_error(priv,"Availibility response sending failed %x status %d\n",vif,r);\r\n}\r\nelse {\r\nunifi_trace(priv, UDBG3, "send_vif_availibility_rsp : status = %d \n", r);\r\n}\r\n}\r\nstatic\r\nvoid verify_and_accomodate_tx_packet(unifi_priv_t *priv)\r\n{\r\ntx_buffered_packets_t *tx_q_item;\r\nunsigned long lock_flags;\r\nstruct list_head *listHead, *list;\r\nstruct list_head *placeHolder;\r\nu8 i, j,eospFramedeleted=0;\r\nu8 thresholdExcedeDueToBroadcast = TRUE;\r\nnetInterface_priv_t *interfacePriv = priv->interfacePriv[0];\r\nCsrWifiRouterCtrlStaInfo_t *staInfo = NULL;\r\nunifi_trace(priv, UDBG3, "entering verify_and_accomodate_tx_packet\n");\r\nfor(i = 0; i < UNIFI_MAX_CONNECTIONS; i++) {\r\nstaInfo = interfacePriv->staInfo[i];\r\nif (staInfo && (staInfo->noOfPktQueued >= CSR_WIFI_DRIVER_MAX_PKT_QUEUING_THRESHOLD_PER_PEER)) {\r\nunifi_trace(priv,UDBG3,"number of station pkts queued= %d for sta id = %d\n", staInfo->noOfPktQueued, staInfo->aid);\r\nfor(j = 0; j < MAX_ACCESS_CATOGORY; j++) {\r\nlist = &staInfo->dataPdu[j];\r\nspin_lock_irqsave(&priv->tx_q_lock,lock_flags);\r\nlist_for_each_safe(listHead, placeHolder, list) {\r\ntx_q_item = list_entry(listHead, tx_buffered_packets_t, q);\r\nlist_del(listHead);\r\nthresholdExcedeDueToBroadcast = FALSE;\r\nunifi_net_data_free(priv, &tx_q_item->bulkdata);\r\nkfree(tx_q_item);\r\ntx_q_item = NULL;\r\nif (!priv->noOfPktQueuedInDriver) {\r\nunifi_error(priv, "packets queued in driver 0 still decrementing in %s\n", __FUNCTION__);\r\n} else {\r\npriv->noOfPktQueuedInDriver--;\r\n}\r\nif (!staInfo->noOfPktQueued) {\r\nunifi_error(priv, "packets queued in driver per station is 0 still decrementing in %s\n", __FUNCTION__);\r\n} else {\r\nspin_lock(&priv->staRecord_lock);\r\nstaInfo->noOfPktQueued--;\r\nspin_unlock(&priv->staRecord_lock);\r\n}\r\nbreak;\r\n}\r\nspin_unlock_irqrestore(&priv->tx_q_lock,lock_flags);\r\n}\r\n}\r\n}\r\nif (thresholdExcedeDueToBroadcast && interfacePriv->noOfbroadcastPktQueued > CSR_WIFI_DRIVER_MINIMUM_BROADCAST_PKT_THRESHOLD ) {\r\nspin_lock_irqsave(&priv->tx_q_lock,lock_flags);\r\nlist_for_each_safe(listHead, placeHolder, &interfacePriv->genericMulticastOrBroadCastFrames) {\r\ntx_q_item = list_entry(listHead, tx_buffered_packets_t, q);\r\nif(eospFramedeleted){\r\ntx_q_item->transmissionControl |= TRANSMISSION_CONTROL_EOSP_MASK;\r\ntx_q_item->transmissionControl = (tx_q_item->transmissionControl & ~(CSR_NO_CONFIRM_REQUIRED));\r\nunifi_trace(priv, UDBG1,"updating eosp for next packet hostTag:= 0x%x ",tx_q_item->hostTag);\r\neospFramedeleted =0;\r\nbreak;\r\n}\r\nif(tx_q_item->transmissionControl & TRANSMISSION_CONTROL_EOSP_MASK ){\r\neospFramedeleted = 1;\r\n}\r\nunifi_trace(priv,UDBG1, "freeing of multicast packets ToC = 0x%x hostTag = 0x%x \n",tx_q_item->transmissionControl,tx_q_item->hostTag);\r\nlist_del(listHead);\r\nunifi_net_data_free(priv, &tx_q_item->bulkdata);\r\nkfree(tx_q_item);\r\npriv->noOfPktQueuedInDriver--;\r\nspin_lock(&priv->staRecord_lock);\r\ninterfacePriv->noOfbroadcastPktQueued--;\r\nspin_unlock(&priv->staRecord_lock);\r\nif(!eospFramedeleted){\r\nbreak;\r\n}\r\n}\r\nspin_unlock_irqrestore(&priv->tx_q_lock,lock_flags);\r\n}\r\nunifi_trace(priv, UDBG3, "leaving verify_and_accomodate_tx_packet\n");\r\n}\r\nstatic\r\nCsrResult enque_tx_data_pdu(unifi_priv_t *priv, bulk_data_param_t *bulkdata,\r\nstruct list_head *list, CSR_SIGNAL *signal,\r\nu8 requeueOnSamePos)\r\n{\r\nCSR_MA_PACKET_REQUEST *req = &signal->u.MaPacketRequest;\r\ntx_buffered_packets_t *tx_q_item;\r\nunsigned long lock_flags;\r\nunifi_trace(priv, UDBG5, "entering enque_tx_data_pdu\n");\r\nif(!list) {\r\nunifi_error(priv,"List is not specified\n");\r\nreturn CSR_RESULT_FAILURE;\r\n}\r\nif (priv->noOfPktQueuedInDriver >= CSR_WIFI_DRIVER_SUPPORT_FOR_MAX_PKT_QUEUEING) {\r\nunifi_trace(priv,UDBG3,"number of pkts queued= %d \n", priv->noOfPktQueuedInDriver);\r\nverify_and_accomodate_tx_packet(priv);\r\n}\r\ntx_q_item = (tx_buffered_packets_t *)kmalloc(sizeof(tx_buffered_packets_t), GFP_ATOMIC);\r\nif (tx_q_item == NULL) {\r\nunifi_error(priv,\r\n"Failed to allocate %d bytes for tx packet record\n",\r\nsizeof(tx_buffered_packets_t));\r\nreturn CSR_RESULT_FAILURE;\r\n}\r\nspin_lock_irqsave(&priv->tx_q_lock,lock_flags);\r\nINIT_LIST_HEAD(&tx_q_item->q);\r\ntx_q_item->bulkdata.os_data_ptr = bulkdata->d[0].os_data_ptr;\r\ntx_q_item->bulkdata.data_length = bulkdata->d[0].data_length;\r\ntx_q_item->bulkdata.os_net_buf_ptr = bulkdata->d[0].os_net_buf_ptr;\r\ntx_q_item->bulkdata.net_buf_length = bulkdata->d[0].net_buf_length;\r\ntx_q_item->interfaceTag = req->VirtualInterfaceIdentifier & 0xff;\r\ntx_q_item->hostTag = req->HostTag;\r\ntx_q_item->leSenderProcessId = signal->SignalPrimitiveHeader.SenderProcessId;\r\ntx_q_item->transmissionControl = req->TransmissionControl;\r\ntx_q_item->priority = req->Priority;\r\ntx_q_item->rate = req->TransmitRate;\r\nmemcpy(tx_q_item->peerMacAddress.a, req->Ra.x, ETH_ALEN);\r\nif (requeueOnSamePos) {\r\nlist_add(&tx_q_item->q, list);\r\n} else {\r\nlist_add_tail(&tx_q_item->q, list);\r\n}\r\npriv->noOfPktQueuedInDriver++;\r\nspin_unlock_irqrestore(&priv->tx_q_lock,lock_flags);\r\nunifi_trace(priv, UDBG5, "leaving enque_tx_data_pdu\n");\r\nreturn CSR_RESULT_SUCCESS;\r\n}\r\nCsrResult unifi_reque_ma_packet_request (void *ospriv, u32 host_tag,\r\nu16 txStatus, bulk_data_desc_t *bulkDataDesc)\r\n{\r\nCsrResult status = CSR_RESULT_SUCCESS;\r\nunifi_priv_t *priv = (unifi_priv_t*)ospriv;\r\nnetInterface_priv_t *interfacePriv;\r\nstruct list_head *list = NULL;\r\nCsrWifiRouterCtrlStaInfo_t *staRecord = NULL;\r\nbulk_data_param_t bulkData;\r\nCSR_SIGNAL signal;\r\nCSR_PRIORITY priority = 0;\r\nu16 interfaceTag = 0;\r\nunifi_TrafficQueue priority_q;\r\nu16 frameControl = 0, frameType = 0;\r\nunsigned long lock_flags;\r\ninterfacePriv = priv->interfacePriv[interfaceTag];\r\nif(!((interfacePriv->interfaceMode == CSR_WIFI_ROUTER_CTRL_MODE_AP) ||\r\n(interfacePriv->interfaceMode == CSR_WIFI_ROUTER_CTRL_MODE_P2PGO))) {\r\nreturn CSR_RESULT_FAILURE;\r\n}\r\nunifi_trace(priv, UDBG6, "unifi_reque_ma_packet_request: host_tag = 0x%x\n", host_tag);\r\nstaRecord = CsrWifiRouterCtrlGetStationRecordFromPeerMacAddress(priv,\r\n(((u8 *) bulkDataDesc->os_data_ptr) + 4),\r\ninterfaceTag);\r\nif (NULL == staRecord) {\r\nunifi_trace(priv, UDBG5, "unifi_reque_ma_packet_request: Invalid STA record \n");\r\nreturn CSR_RESULT_FAILURE;\r\n}\r\nif (CSR_TX_RETRY_LIMIT == txStatus || CSR_TX_NO_BSS == txStatus) {\r\nif (staRecord->timSet == CSR_WIFI_TIM_RESET || staRecord->timSet == CSR_WIFI_TIM_RESETTING)\r\n{\r\nunifi_trace(priv, UDBG2, "unifi_reque_ma_packet_request: CFM failed with Retry Limit or No BSS-->update TIM\n");\r\nif (!staRecord->timRequestPendingFlag) {\r\nupdate_tim(priv, staRecord->aid, 1, interfaceTag, staRecord->assignedHandle);\r\n}\r\nelse {\r\nstaRecord->updateTimReqQueued = 1;\r\nunifi_trace(priv, UDBG6, "unifi_reque_ma_packet_request: One more UpdateTim Request(:%d)Queued for AID %x\n",\r\nstaRecord->updateTimReqQueued, staRecord->aid);\r\n}\r\n}\r\nreturn CSR_RESULT_FAILURE;\r\n}\r\nelse if ((CSR_TX_LIFETIME == txStatus) || (CSR_TX_BLOCK_ACK_TIMEOUT == txStatus) ||\r\n(CSR_TX_FAIL_TRANSMISSION_VIF_INTERRUPTED == txStatus) ||\r\n(CSR_TX_REJECTED_PEER_STATION_SLEEPING == txStatus) ||\r\n(CSR_TX_REJECTED_DTIM_STARTED == txStatus)) {\r\nframeControl = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(bulkDataDesc->os_data_ptr);\r\nframeType = ((frameControl & IEEE80211_FC_TYPE_MASK) >> FRAME_CONTROL_TYPE_FIELD_OFFSET);\r\nif (IEEE802_11_FRAMETYPE_MANAGEMENT == frameType) {\r\nreturn CSR_RESULT_FAILURE;\r\n}\r\nelse if (IEEE802_11_FRAMETYPE_DATA == frameType) {\r\nif ((((frameControl & IEEE80211_FC_SUBTYPE_MASK) >> FRAME_CONTROL_SUBTYPE_FIELD_OFFSET) == QOS_DATA_NULL) ||\r\n(((frameControl & IEEE80211_FC_SUBTYPE_MASK) >> FRAME_CONTROL_SUBTYPE_FIELD_OFFSET)== DATA_NULL )) {\r\nreturn CSR_RESULT_FAILURE;\r\n}\r\n}\r\nif (TRUE == staRecord->wmmOrQosEnabled) {\r\nu16 qosControl = 0;\r\nu8 dataFrameType = 0;\r\ndataFrameType =((frameControl & IEEE80211_FC_SUBTYPE_MASK) >> 4);\r\nif (dataFrameType == QOS_DATA) {\r\nif((frameControl & IEEE802_11_FC_TO_DS_MASK) && (frameControl & IEEE802_11_FC_FROM_DS_MASK)) {\r\nqosControl= CSR_GET_UINT16_FROM_LITTLE_ENDIAN(bulkDataDesc->os_data_ptr + 30);\r\n}\r\nelse {\r\nqosControl = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(bulkDataDesc->os_data_ptr + 24);\r\n}\r\n}\r\npriority = (CSR_PRIORITY)(qosControl & IEEE802_11_QC_TID_MASK);\r\nif (priority < CSR_QOS_UP0 || priority > CSR_QOS_UP7) {\r\nunifi_trace(priv, UDBG5, "unifi_reque_ma_packet_request: Invalid priority:%x \n", priority);\r\nreturn CSR_RESULT_FAILURE;\r\n}\r\n}\r\nelse {\r\npriority = CSR_CONTENTION;\r\n}\r\nbulkData.d[0].os_data_ptr = bulkDataDesc->os_data_ptr;\r\nbulkData.d[0].data_length = bulkDataDesc->data_length;\r\nbulkData.d[0].os_net_buf_ptr = bulkDataDesc->os_net_buf_ptr;\r\nbulkData.d[0].net_buf_length = bulkDataDesc->net_buf_length;\r\nbulkData.d[1].os_data_ptr = NULL;\r\nbulkData.d[1].os_net_buf_ptr = NULL;\r\nbulkData.d[1].data_length = bulkData.d[1].net_buf_length = 0;\r\nmemset(&signal, 0, sizeof(CSR_SIGNAL));\r\nunifi_frame_ma_packet_req(priv, priority, 0, host_tag,\r\ninterfaceTag, CSR_NO_CONFIRM_REQUIRED,\r\npriv->netdev_client->sender_id,\r\nstaRecord->peerMacAddress.a, &signal);\r\npriority_q = unifi_frame_priority_to_queue(priority);\r\nlist = &staRecord->dataPdu[priority_q];\r\nstatus = enque_tx_data_pdu(priv, &bulkData, list, &signal, TRUE);\r\nif (!status) {\r\nspin_lock_irqsave(&priv->staRecord_lock, lock_flags);\r\nstaRecord->noOfPktQueued++;\r\nspin_unlock_irqrestore(&priv->staRecord_lock, lock_flags);\r\n}\r\n}\r\nelse {\r\nreturn CSR_RESULT_FAILURE;\r\n}\r\nreturn status;\r\n}\r\nstatic void is_all_ac_deliver_enabled_and_moredata(CsrWifiRouterCtrlStaInfo_t *staRecord, u8 *allDeliveryEnabled, u8 *dataAvailable)\r\n{\r\nu8 i;\r\n*allDeliveryEnabled = TRUE;\r\nfor (i = 0 ;i < MAX_ACCESS_CATOGORY; i++) {\r\nif (!IS_DELIVERY_ENABLED(staRecord->powersaveMode[i])) {\r\n*allDeliveryEnabled = FALSE;\r\nbreak;\r\n}\r\n}\r\nif (*allDeliveryEnabled) {\r\n*dataAvailable = (!list_empty(&staRecord->dataPdu[0]) || !list_empty(&staRecord->dataPdu[1])\r\n||!list_empty(&staRecord->dataPdu[2]) ||!list_empty(&staRecord->dataPdu[3])\r\n||!list_empty(&staRecord->mgtFrames));\r\n}\r\n}\r\nvoid uf_handle_tim_cfm(unifi_priv_t *priv, CSR_MLME_SET_TIM_CONFIRM *cfm, u16 receiverProcessId)\r\n{\r\nu8 handle = CSR_WIFI_GET_STATION_HANDLE_FROM_RECEIVER_ID(receiverProcessId);\r\nu8 timSetStatus = CSR_WIFI_GET_TIMSET_STATE_FROM_RECEIVER_ID(receiverProcessId);\r\nu16 interfaceTag = (cfm->VirtualInterfaceIdentifier & 0xff);\r\nnetInterface_priv_t *interfacePriv = priv->interfacePriv[interfaceTag];\r\nCsrWifiRouterCtrlStaInfo_t *staRecord = NULL;\r\nu16 timSetValue = 0;\r\nstatic u8 retryCount = 0;\r\nunsigned long lock_flags;\r\nunifi_trace(priv, UDBG3, "entering %s, handle = %x, timSetStatus = %x\n", __FUNCTION__, handle, timSetStatus);\r\nif (interfaceTag >= CSR_WIFI_NUM_INTERFACES) {\r\nunifi_warning(priv, "bad interfaceTag = %x\n", interfaceTag);\r\nreturn;\r\n}\r\nif ((handle != CSR_WIFI_BROADCAST_OR_MULTICAST_HANDLE) && (handle >= UNIFI_MAX_CONNECTIONS)) {\r\nunifi_warning(priv, "bad station Handle = %x\n", handle);\r\nreturn;\r\n}\r\nif (handle != CSR_WIFI_BROADCAST_OR_MULTICAST_HANDLE) {\r\nspin_lock_irqsave(&priv->staRecord_lock,lock_flags);\r\nif ((staRecord = ((CsrWifiRouterCtrlStaInfo_t *) (interfacePriv->staInfo[handle]))) == NULL) {\r\nspin_unlock_irqrestore(&priv->staRecord_lock,lock_flags);\r\nunifi_warning(priv, "uf_handle_tim_cfm: station record is NULL handle = %x\n", handle);\r\nreturn;\r\n}\r\nspin_unlock_irqrestore(&priv->staRecord_lock,lock_flags);\r\n}\r\nswitch(timSetStatus)\r\n{\r\ncase CSR_WIFI_TIM_SETTING:\r\ntimSetValue = CSR_WIFI_TIM_SET;\r\nbreak;\r\ncase CSR_WIFI_TIM_RESETTING:\r\ntimSetValue = CSR_WIFI_TIM_RESET;\r\nbreak;\r\ndefault:\r\nunifi_warning(priv, "timSet state is %x: Debug\n", timSetStatus);\r\nreturn;\r\n}\r\nswitch(cfm->ResultCode)\r\n{\r\ncase CSR_RC_SUCCESS:\r\nif (handle != CSR_WIFI_BROADCAST_OR_MULTICAST_HANDLE) {\r\nif (timSetStatus == staRecord->timSet) {\r\nstaRecord->timSet = timSetValue;\r\nretryCount = 0;\r\nunifi_trace(priv, UDBG2, "tim (%s) successfully in firmware\n", (timSetValue)?"SET":"RESET");\r\n} else {\r\nunifi_trace(priv, UDBG3, "receiver processID = %x, success: request & confirm states are not matching in TIM cfm: Debug status = %x, staRecord->timSet = %x, handle = %x\n",\r\nreceiverProcessId, timSetStatus, staRecord->timSet, handle);\r\n}\r\nstaRecord->timRequestPendingFlag = FALSE;\r\nif (0xFF != staRecord->updateTimReqQueued)\r\n{\r\nif (staRecord->timSet != staRecord->updateTimReqQueued)\r\n{\r\nunifi_trace(priv, UDBG2, "uf_handle_tim_cfm : Processing Queued UpdateTimReq \n");\r\nupdate_tim(priv, staRecord->aid, staRecord->updateTimReqQueued, interfaceTag, handle);\r\nstaRecord->updateTimReqQueued = 0xFF;\r\n}\r\n}\r\n} else {\r\ninterfacePriv->bcTimSet = timSetValue;\r\nretryCount = 0;\r\nunifi_trace(priv, UDBG3, "tim (%s) successfully for broadcast frame in firmware\n", (timSetValue)?"SET":"RESET");\r\ninterfacePriv->bcTimSetReqPendingFlag = FALSE;\r\nif (0xFF != interfacePriv->bcTimSetReqQueued)\r\n{\r\nif (interfacePriv->bcTimSet != interfacePriv->bcTimSetReqQueued)\r\n{\r\nunifi_trace(priv, UDBG2, "uf_handle_tim_cfm : Processing Queued UpdateDTimReq \n");\r\nupdate_tim(priv, 0, interfacePriv->bcTimSetReqQueued, interfaceTag, 0xFFFFFFFF);\r\ninterfacePriv->bcTimSetReqQueued = 0xFF;\r\n}\r\n}\r\n}\r\nbreak;\r\ncase CSR_RC_INVALID_PARAMETERS:\r\ncase CSR_RC_INSUFFICIENT_RESOURCE:\r\nif (retryCount > UNIFI_MAX_RETRY_LIMIT) {\r\nu8 moreData = FALSE;\r\nretryCount = 0;\r\nif(staRecord) {\r\nif(!staRecord->wmmOrQosEnabled) {\r\nmoreData = (!list_empty(&staRecord->dataPdu[UNIFI_TRAFFIC_Q_CONTENTION]) ||\r\n!list_empty(&staRecord->dataPdu[UNIFI_TRAFFIC_Q_VO]) ||\r\n!list_empty(&staRecord->mgtFrames));\r\n} else {\r\nu8 allDeliveryEnabled = 0, dataAvailable = 0;\r\nis_all_ac_deliver_enabled_and_moredata(staRecord, &allDeliveryEnabled, &dataAvailable);\r\nmoreData = (uf_is_more_data_for_non_delivery_ac(staRecord) || (allDeliveryEnabled && dataAvailable));\r\n}\r\nif (moreData) {\r\nstaRecord->timSet = CSR_WIFI_TIM_RESET;\r\n} else {\r\nstaRecord->timSet = CSR_WIFI_TIM_SET;\r\n}\r\n} else {\r\nmoreData = (!list_empty(&interfacePriv->genericMulticastOrBroadCastMgtFrames) ||\r\n!list_empty(&interfacePriv->genericMulticastOrBroadCastFrames));\r\nif (moreData) {\r\nupdate_tim(priv, 0, CSR_WIFI_TIM_SET, interfaceTag, 0xFFFFFFFF);\r\n} else {\r\nupdate_tim(priv, 0, CSR_WIFI_TIM_RESET, interfaceTag, 0xFFFFFFFF);\r\n}\r\n}\r\nunifi_error(priv, "no of error's for TIM setting crossed the Limit: verify\n");\r\nreturn;\r\n}\r\nretryCount++;\r\nif (handle != CSR_WIFI_BROADCAST_OR_MULTICAST_HANDLE) {\r\nif (timSetStatus == staRecord->timSet) {\r\nunifi_warning(priv, "tim request failed, retry for AID = %x\n", staRecord->aid);\r\nupdate_tim(priv, staRecord->aid, timSetValue, interfaceTag, handle);\r\n} else {\r\nunifi_trace(priv, UDBG1, "failure: request & confirm states are not matching in TIM cfm: Debug status = %x, staRecord->timSet = %x\n",\r\ntimSetStatus, staRecord->timSet);\r\n}\r\n} else {\r\nunifi_warning(priv, "tim request failed, retry for broadcast frames\n");\r\nupdate_tim(priv, 0, timSetValue, interfaceTag, 0xFFFFFFFF);\r\n}\r\nbreak;\r\ndefault:\r\nunifi_warning(priv, "tim update request failed resultcode = %x\n", cfm->ResultCode);\r\n}\r\nunifi_trace(priv, UDBG2, "leaving %s\n", __FUNCTION__);\r\n}\r\nvoid update_tim(unifi_priv_t * priv, u16 aid, u8 setTim, u16 interfaceTag, u32 handle)\r\n{\r\nCSR_SIGNAL signal;\r\ns32 r;\r\nCSR_MLME_SET_TIM_REQUEST *req = &signal.u.MlmeSetTimRequest;\r\nbulk_data_param_t *bulkdata = NULL;\r\nnetInterface_priv_t *interfacePriv = priv->interfacePriv[interfaceTag];\r\nu8 senderIdLsb = 0;\r\nCsrWifiRouterCtrlStaInfo_t *staRecord = NULL;\r\nu32 oldTimSetStatus = 0, timSetStatus = 0;\r\nunifi_trace(priv, UDBG5, "entering the update_tim routine\n");\r\nif (handle == 0xFFFFFFFF) {\r\nhandle &= CSR_WIFI_BROADCAST_OR_MULTICAST_HANDLE;\r\nif (setTim == interfacePriv->bcTimSet)\r\n{\r\nunifi_trace(priv, UDBG3, "update_tim, Drop:Hdl=%x, timval=%d, globalTim=%d\n", handle, setTim, interfacePriv->bcTimSet);\r\nreturn;\r\n}\r\n} else if ((handle != 0xFFFFFFFF) && (handle >= UNIFI_MAX_CONNECTIONS)) {\r\nunifi_warning(priv, "bad station Handle = %x\n", handle);\r\nreturn;\r\n}\r\nif (setTim) {\r\ntimSetStatus = CSR_WIFI_TIM_SETTING;\r\n} else {\r\ntimSetStatus = CSR_WIFI_TIM_RESETTING;\r\n}\r\nif (handle != CSR_WIFI_BROADCAST_OR_MULTICAST_HANDLE) {\r\nif ((staRecord = ((CsrWifiRouterCtrlStaInfo_t *) (interfacePriv->staInfo[handle]))) == NULL) {\r\nunifi_warning(priv, "station record is NULL in update_tim: handle = %x :debug\n", handle);\r\nreturn;\r\n}\r\noldTimSetStatus = staRecord->timSet;\r\nstaRecord->timSet = timSetStatus;\r\n}\r\nsenderIdLsb = CSR_WIFI_PACK_SENDER_ID_LSB_FOR_TIM_REQ(handle, timSetStatus);\r\nmemset(&signal, 0, sizeof(CSR_SIGNAL));\r\nsignal.SignalPrimitiveHeader.SignalId = CSR_MLME_SET_TIM_REQUEST_ID;\r\nsignal.SignalPrimitiveHeader.ReceiverProcessId = 0;\r\nCSR_COPY_UINT16_TO_LITTLE_ENDIAN(((priv->netdev_client->sender_id & 0xff00) | senderIdLsb),\r\n(u8*)&signal.SignalPrimitiveHeader.SenderProcessId);\r\nreq->VirtualInterfaceIdentifier = uf_get_vif_identifier(interfacePriv->interfaceMode,interfaceTag);\r\nreq->AssociationId = aid;\r\nreq->TimValue = setTim;\r\nunifi_trace(priv, UDBG2, "update_tim:AID %x,senderIdLsb = 0x%x, handle = 0x%x, timSetStatus = %x, sender proceesID = %x \n",\r\naid,senderIdLsb, handle, timSetStatus, signal.SignalPrimitiveHeader.SenderProcessId);\r\nr = ul_send_signal_unpacked(priv, &signal, bulkdata);\r\nif (r) {\r\nunifi_error(priv, "Error queueing CSR_MLME_SET_TIM_REQUEST signal\n");\r\nif (staRecord) {\r\nstaRecord->timSet = oldTimSetStatus ;\r\n}\r\nelse\r\n{\r\ninterfacePriv->bcTimSet = !setTim;\r\n}\r\n}\r\nelse {\r\nif (staRecord) {\r\nstaRecord->timRequestPendingFlag = TRUE;\r\n}\r\nelse\r\n{\r\ninterfacePriv->bcTimSetReqPendingFlag = TRUE;\r\n}\r\n}\r\nunifi_trace(priv, UDBG5, "leaving the update_tim routine\n");\r\n}\r\nstatic\r\nvoid process_peer_active_transition(unifi_priv_t * priv,\r\nCsrWifiRouterCtrlStaInfo_t *staRecord,\r\nu16 interfaceTag)\r\n{\r\nint r,i;\r\nu8 spaceAvail[4] = {TRUE,TRUE,TRUE,TRUE};\r\ntx_buffered_packets_t * buffered_pkt = NULL;\r\nunsigned long lock_flags;\r\nnetInterface_priv_t *interfacePriv = priv->interfacePriv[interfaceTag];\r\nunifi_trace(priv, UDBG5, "entering process_peer_active_transition\n");\r\nif(IS_DTIM_ACTIVE(interfacePriv->dtimActive,interfacePriv->multicastPduHostTag)) {\r\nunifi_trace(priv,UDBG2, "Multicast transmission is going on so resume unicast transmission after DTIM over\n");\r\nif (!staRecord->timRequestPendingFlag){\r\nif((staRecord->timSet == CSR_WIFI_TIM_SET) || (staRecord->timSet == CSR_WIFI_TIM_SETTING)){\r\nupdate_tim(priv, staRecord->aid, 0, interfaceTag, staRecord->assignedHandle);\r\n}\r\n}\r\nelse\r\n{\r\nstaRecord->updateTimReqQueued = 0;\r\nunifi_trace(priv, UDBG6, "update_tim : One more UpdateTim Request (Tim value:%d) Queued for AID %x\n", staRecord->updateTimReqQueued,\r\nstaRecord->aid);\r\n}\r\nreturn;\r\n}\r\nwhile((buffered_pkt=dequeue_tx_data_pdu(priv, &staRecord->mgtFrames))) {\r\nbuffered_pkt->transmissionControl &=\r\n~(TRANSMISSION_CONTROL_TRIGGER_MASK|TRANSMISSION_CONTROL_EOSP_MASK);\r\nif((r=frame_and_send_queued_pdu(priv,buffered_pkt,staRecord,0,FALSE)) == -ENOSPC) {\r\nunifi_trace(priv, UDBG2, "p_p_a_t:(ENOSPC) Mgt Frame queueing \n");\r\nspin_lock_irqsave(&priv->tx_q_lock,lock_flags);\r\nlist_add(&buffered_pkt->q, &staRecord->mgtFrames);\r\nspin_unlock_irqrestore(&priv->tx_q_lock,lock_flags);\r\npriv->pausedStaHandle[3]=(u8)(staRecord->assignedHandle);\r\nspaceAvail[3] = FALSE;\r\nbreak;\r\n} else {\r\nif(r){\r\nunifi_trace (priv, UDBG1, " HIP validation failure : PDU sending failed \n");\r\nunifi_net_data_free(priv, &buffered_pkt->bulkdata);\r\n}\r\nkfree(buffered_pkt);\r\n}\r\n}\r\nif (!staRecord->timRequestPendingFlag) {\r\nif (staRecord->txSuspend) {\r\nif(staRecord->timSet == CSR_WIFI_TIM_SET) {\r\nupdate_tim(priv,staRecord->aid,0,interfaceTag, staRecord->assignedHandle);\r\n}\r\nreturn;\r\n}\r\n}\r\nelse\r\n{\r\nstaRecord->updateTimReqQueued = 0;\r\nunifi_trace(priv, UDBG6, "update_tim : One more UpdateTim Request (Tim value:%d) Queued for AID %x\n", staRecord->updateTimReqQueued,\r\nstaRecord->aid);\r\n}\r\nfor(i=3;i>=0;i--) {\r\nif(!spaceAvail[i])\r\ncontinue;\r\nunifi_trace(priv, UDBG6, "p_p_a_t:data pkt sending for AC %d \n",i);\r\nwhile((buffered_pkt=dequeue_tx_data_pdu(priv, &staRecord->dataPdu[i]))) {\r\nbuffered_pkt->transmissionControl &=\r\n~(TRANSMISSION_CONTROL_TRIGGER_MASK|TRANSMISSION_CONTROL_EOSP_MASK);\r\nif((r=frame_and_send_queued_pdu(priv,buffered_pkt,staRecord,0,FALSE)) == -ENOSPC) {\r\nspin_lock_irqsave(&priv->tx_q_lock,lock_flags);\r\nlist_add(&buffered_pkt->q, &staRecord->dataPdu[i]);\r\nspin_unlock_irqrestore(&priv->tx_q_lock,lock_flags);\r\npriv->pausedStaHandle[i]=(u8)(staRecord->assignedHandle);\r\nbreak;\r\n} else {\r\nif(r){\r\nunifi_trace (priv, UDBG1, " HIP validation failure : PDU sending failed \n");\r\nunifi_net_data_free(priv, &buffered_pkt->bulkdata);\r\n}\r\nkfree(buffered_pkt);\r\n}\r\n}\r\n}\r\nif (!staRecord->timRequestPendingFlag){\r\nif((staRecord->timSet == CSR_WIFI_TIM_SET) || (staRecord->timSet == CSR_WIFI_TIM_SETTING)) {\r\nunifi_trace(priv, UDBG3, "p_p_a_t:resetting tim .....\n");\r\nupdate_tim(priv,staRecord->aid,0,interfaceTag, staRecord->assignedHandle);\r\n}\r\n}\r\nelse\r\n{\r\nstaRecord->updateTimReqQueued = 0;\r\nunifi_trace(priv, UDBG6, "update_tim : One more UpdateTim Request (Tim value:%d) Queued for AID %x\n", staRecord->updateTimReqQueued,\r\nstaRecord->aid);\r\n}\r\nunifi_trace(priv, UDBG5, "leaving process_peer_active_transition\n");\r\n}\r\nvoid uf_process_ma_pkt_cfm_for_ap(unifi_priv_t *priv,u16 interfaceTag, const CSR_MA_PACKET_CONFIRM *pkt_cfm)\r\n{\r\nnetInterface_priv_t *interfacePriv;\r\nu8 i;\r\nCsrWifiRouterCtrlStaInfo_t *staRecord = NULL;\r\ninterfacePriv = priv->interfacePriv[interfaceTag];\r\nif(pkt_cfm->HostTag == interfacePriv->multicastPduHostTag) {\r\nunifi_trace(priv,UDBG2,"CFM for marked Multicast Tag = %x\n",interfacePriv->multicastPduHostTag);\r\ninterfacePriv->multicastPduHostTag = 0xffffffff;\r\nresume_suspended_uapsd(priv,interfaceTag);\r\nresume_unicast_buffered_frames(priv,interfaceTag);\r\nif(list_empty(&interfacePriv->genericMulticastOrBroadCastMgtFrames) &&\r\nlist_empty(&interfacePriv->genericMulticastOrBroadCastFrames)) {\r\nunifi_trace(priv,UDBG1,"Resetting multicastTIM");\r\nif (!interfacePriv->bcTimSetReqPendingFlag)\r\n{\r\nupdate_tim(priv,0,CSR_WIFI_TIM_RESET,interfaceTag, 0xFFFFFFFF);\r\n}\r\nelse\r\n{\r\ninterfacePriv->bcTimSetReqQueued = CSR_WIFI_TIM_RESET;\r\nunifi_trace(priv, UDBG2, "uf_process_ma_pkt_cfm_for_ap : One more UpdateDTim Request(%d) Queued \n",\r\ninterfacePriv->bcTimSetReqQueued);\r\n}\r\n}\r\nreturn;\r\n}\r\nfor(i =0; i < UNIFI_MAX_CONNECTIONS; i++) {\r\nstaRecord = (CsrWifiRouterCtrlStaInfo_t *) (interfacePriv->staInfo[i]);\r\nif (staRecord && (staRecord->nullDataHostTag == pkt_cfm->HostTag)) {\r\nunifi_trace(priv, UDBG1, "CFM for Inactive probe Null frame (tag = %x, status = %d)\n",\r\npkt_cfm->HostTag,\r\npkt_cfm->TransmissionStatus\r\n);\r\nstaRecord->nullDataHostTag = INVALID_HOST_TAG;\r\nif(pkt_cfm->TransmissionStatus == CSR_TX_RETRY_LIMIT){\r\nu32 now;\r\nu32 inactive_time;\r\nunifi_trace(priv, UDBG1, "Nulldata to probe STA ALIVE Failed with retry limit\n");\r\nif (staRecord->activity_flag){\r\nreturn;\r\n}\r\nnow = CsrTimeGet(NULL);\r\nif (staRecord->lastActivity > now)\r\n{\r\ninactive_time = CsrTimeAdd((u32)CsrTimeSub(CSR_SCHED_TIME_MAX, staRecord->lastActivity),\r\nnow);\r\n}\r\nelse\r\n{\r\ninactive_time = (u32)CsrTimeSub(now, staRecord->lastActivity);\r\n}\r\nif (inactive_time >= STA_INACTIVE_TIMEOUT_VAL)\r\n{\r\nstruct list_head send_cfm_list;\r\nu8 j;\r\nINIT_LIST_HEAD(&send_cfm_list);\r\nuf_prepare_send_cfm_list_for_queued_pkts(priv,\r\n&send_cfm_list,\r\n&(staRecord->mgtFrames));\r\nuf_flush_list(priv, &(staRecord->mgtFrames));\r\nfor(j = 0; j < MAX_ACCESS_CATOGORY; j++){\r\nuf_prepare_send_cfm_list_for_queued_pkts(priv,\r\n&send_cfm_list,\r\n&(staRecord->dataPdu[j]));\r\nuf_flush_list(priv,&(staRecord->dataPdu[j]));\r\n}\r\nsend_auto_ma_packet_confirm(priv, staRecord->interfacePriv, &send_cfm_list);\r\nunifi_warning(priv, "uf_process_ma_pkt_cfm_for_ap: Router Disconnected IND Peer (%x-%x-%x-%x-%x-%x)\n",\r\nstaRecord->peerMacAddress.a[0],\r\nstaRecord->peerMacAddress.a[1],\r\nstaRecord->peerMacAddress.a[2],\r\nstaRecord->peerMacAddress.a[3],\r\nstaRecord->peerMacAddress.a[4],\r\nstaRecord->peerMacAddress.a[5]);\r\nCsrWifiRouterCtrlConnectedIndSend(priv->CSR_WIFI_SME_IFACEQUEUE,\r\n0,\r\nstaRecord->interfacePriv->InterfaceTag,\r\nstaRecord->peerMacAddress,\r\nCSR_WIFI_ROUTER_CTRL_PEER_DISCONNECTED);\r\n}\r\n}\r\nelse if (pkt_cfm->TransmissionStatus == CSR_TX_SUCCESSFUL)\r\n{\r\nstaRecord->activity_flag = TRUE;\r\n}\r\n}\r\n}\r\n}\r\nu16 uf_get_vif_identifier (CsrWifiRouterCtrlMode mode, u16 tag)\r\n{\r\nswitch(mode)\r\n{\r\ncase CSR_WIFI_ROUTER_CTRL_MODE_STA:\r\ncase CSR_WIFI_ROUTER_CTRL_MODE_P2PCLI:\r\nreturn (0x02<<8|tag);\r\ncase CSR_WIFI_ROUTER_CTRL_MODE_AP:\r\ncase CSR_WIFI_ROUTER_CTRL_MODE_P2PGO:\r\nreturn (0x03<<8|tag);\r\ncase CSR_WIFI_ROUTER_CTRL_MODE_IBSS:\r\nreturn (0x01<<8|tag);\r\ncase CSR_WIFI_ROUTER_CTRL_MODE_MONITOR:\r\nreturn (0x04<<8|tag);\r\ncase CSR_WIFI_ROUTER_CTRL_MODE_AMP:\r\nreturn (0x05<<8|tag);\r\ndefault:\r\nreturn tag;\r\n}\r\n}\r\nstatic int update_macheader(unifi_priv_t *priv, struct sk_buff *skb,\r\nstruct sk_buff *newSkb, CSR_PRIORITY *priority,\r\nbulk_data_param_t *bulkdata, u16 interfaceTag,\r\nu8 macHeaderLengthInBytes,\r\nu8 qosDestination)\r\n{\r\nu16 *fc = NULL;\r\nu8 direction = 0, toDs, fromDs;\r\nu8 *bufPtr = NULL;\r\nu8 sa[ETH_ALEN], da[ETH_ALEN];\r\nnetInterface_priv_t *interfacePriv = priv->interfacePriv[interfaceTag];\r\nint headroom;\r\nu8 macHeaderBuf[IEEE802_11_DATA_FRAME_MAC_HEADER_SIZE] = {0};\r\nunifi_trace(priv, UDBG5, "entering the update_macheader function\n");\r\nmemcpy(macHeaderBuf, skb->data, macHeaderLengthInBytes);\r\nskb_pull(skb, macHeaderLengthInBytes);\r\nheadroom = skb_headroom(skb);\r\nfc = (u16*) macHeaderBuf;\r\ntoDs = (*fc & cpu_to_le16(IEEE802_11_FC_TO_DS_MASK))?1 : 0;\r\nfromDs = (*fc & cpu_to_le16(IEEE802_11_FC_FROM_DS_MASK))? 1: 0;\r\nunifi_trace(priv, UDBG5, "In update_macheader function, fromDs = %x, toDs = %x\n", fromDs, toDs);\r\ndirection = ((fromDs | (toDs << 1)) & 0x3);\r\nmemcpy(da, macHeaderBuf+4+toDs*12, ETH_ALEN);\r\nmemcpy(sa, macHeaderBuf+10+fromDs*(6+toDs*8), ETH_ALEN);\r\nunifi_trace(priv, UDBG3, "update_macheader:direction = %x\n", direction);\r\nswitch(direction)\r\n{\r\ncase 2:\r\n*fc &= cpu_to_le16(~IEEE802_11_FC_TO_DS_MASK);\r\n*fc |= cpu_to_le16(IEEE802_11_FC_FROM_DS_MASK);\r\nmemcpy(macHeaderBuf + 4, da, ETH_ALEN);\r\nmemcpy(macHeaderBuf + 10, &interfacePriv->bssid, ETH_ALEN);\r\nmemcpy(macHeaderBuf + 16, sa, ETH_ALEN);\r\nbreak;\r\ncase 3:\r\nunifi_trace(priv, UDBG3, "when both the toDs & fromDS set, NOT SUPPORTED\n");\r\nbreak;\r\ndefault:\r\nunifi_trace(priv, UDBG3, "problem in decoding packet in update_macheader \n");\r\nreturn -1;\r\n}\r\nswitch(le16_to_cpu(*fc) & IEEE80211_FC_SUBTYPE_MASK)\r\n{\r\ncase IEEE802_11_FC_TYPE_QOS_DATA & IEEE80211_FC_SUBTYPE_MASK:\r\nif (!qosDestination) {\r\nif (*fc & cpu_to_le16(IEEE80211_FC_ORDER_MASK)) {\r\nmacHeaderLengthInBytes -= 6;\r\n} else {\r\nmacHeaderLengthInBytes -= 2;\r\n}\r\n*fc &= cpu_to_le16(~IEEE80211_FC_SUBTYPE_MASK);\r\n*fc |= cpu_to_le16(IEEE802_11_FC_TYPE_DATA);\r\nif (headroom < macHeaderLengthInBytes) {\r\nunifi_trace(priv, UDBG1, " sufficient headroom not there to push updated mac header \n");\r\nreturn -1;\r\n}\r\nbufPtr = (u8 *) skb_push(skb, macHeaderLengthInBytes);\r\nbulkdata->d[0].os_data_ptr = skb->data;\r\nbulkdata->d[0].os_net_buf_ptr = (unsigned char*)skb;\r\nbulkdata->d[0].data_length = skb->len;\r\n} else {\r\nu8 qc;\r\nif (*fc & cpu_to_le16(IEEE80211_FC_ORDER_MASK)) {\r\nqc = *((u8*)(macHeaderBuf + (macHeaderLengthInBytes - 4 - 2)));\r\n} else {\r\nqc = *((u8*)(macHeaderBuf + (macHeaderLengthInBytes - 2)));\r\n}\r\nif ((qc & IEEE802_11_QC_TID_MASK) > 7) {\r\n*priority = 7;\r\n} else {\r\n*priority = qc & IEEE802_11_QC_TID_MASK;\r\n}\r\nunifi_trace(priv, UDBG1, "Incoming packet priority from QSTA is %x\n", *priority);\r\nif (headroom < macHeaderLengthInBytes) {\r\nunifi_trace(priv, UDBG3, " sufficient headroom not there to push updated mac header \n");\r\nreturn -1;\r\n}\r\nbufPtr = (u8 *) skb_push(skb, macHeaderLengthInBytes);\r\n}\r\nbreak;\r\ndefault:\r\n{\r\nbulk_data_param_t data_ptrs;\r\nCsrResult csrResult;\r\nunifi_trace(priv, UDBG5, "normal Data packet, NO QOS \n");\r\nif (qosDestination) {\r\nu8 qc = 0;\r\nunifi_trace(priv, UDBG3, "destination is QOS station \n");\r\n*priority = CSR_QOS_UP0;\r\nqc |= CSR_QOS_UP0;\r\nif (da[0] & 0x1) {\r\nqc |= 1 << 5;\r\n}\r\nmacHeaderLengthInBytes += 2;\r\n*fc &= cpu_to_le16(~IEEE80211_FC_SUBTYPE_MASK);\r\n*fc |= cpu_to_le16(IEEE802_11_FC_TYPE_QOS_DATA);\r\nmacHeaderBuf[macHeaderLengthInBytes - 2] = qc;\r\nmacHeaderBuf[macHeaderLengthInBytes - 1] = 0;\r\nif (headroom < macHeaderLengthInBytes) {\r\ncsrResult = unifi_net_data_malloc(priv, &data_ptrs.d[0], skb->len + macHeaderLengthInBytes);\r\nif (csrResult != CSR_RESULT_SUCCESS) {\r\nunifi_error(priv, " failed to allocate request_data. in update_macheader func\n");\r\nreturn -1;\r\n}\r\nnewSkb = (struct sk_buff *)(data_ptrs.d[0].os_net_buf_ptr);\r\nnewSkb->len = skb->len + macHeaderLengthInBytes;\r\nmemcpy((void*)data_ptrs.d[0].os_data_ptr + macHeaderLengthInBytes,\r\nskb->data, skb->len);\r\nbulkdata->d[0].os_data_ptr = newSkb->data;\r\nbulkdata->d[0].os_net_buf_ptr = (unsigned char*)newSkb;\r\nbulkdata->d[0].data_length = newSkb->len;\r\nbufPtr = (u8*)data_ptrs.d[0].os_data_ptr;\r\nkfree_skb(skb);\r\n} else {\r\nbufPtr = (u8*)skb_push(skb, macHeaderLengthInBytes);\r\nbulkdata->d[0].os_data_ptr = skb->data;\r\nbulkdata->d[0].os_net_buf_ptr = (unsigned char*)skb;\r\nbulkdata->d[0].data_length = skb->len;\r\n}\r\n} else {\r\nunifi_trace(priv, UDBG3, "destination is not a QSTA\n");\r\nif (headroom < macHeaderLengthInBytes) {\r\ncsrResult = unifi_net_data_malloc(priv, &data_ptrs.d[0], skb->len + macHeaderLengthInBytes);\r\nif (csrResult != CSR_RESULT_SUCCESS) {\r\nunifi_error(priv, " failed to allocate request_data. in update_macheader func\n");\r\nreturn -1;\r\n}\r\nnewSkb = (struct sk_buff *)(data_ptrs.d[0].os_net_buf_ptr);\r\nnewSkb->len = skb->len + macHeaderLengthInBytes;\r\nmemcpy((void*)data_ptrs.d[0].os_data_ptr + macHeaderLengthInBytes,\r\nskb->data, skb->len);\r\nbulkdata->d[0].os_data_ptr = newSkb->data;\r\nbulkdata->d[0].os_net_buf_ptr = (unsigned char*)newSkb;\r\nbulkdata->d[0].data_length = newSkb->len;\r\nbufPtr = (u8*)data_ptrs.d[0].os_data_ptr;\r\nkfree_skb(skb);\r\n} else {\r\nbufPtr = (u8*)skb_push(skb, macHeaderLengthInBytes);\r\nbulkdata->d[0].os_data_ptr = skb->data;\r\nbulkdata->d[0].os_net_buf_ptr = (unsigned char*)skb;\r\nbulkdata->d[0].data_length = skb->len;\r\n}\r\n}\r\n}\r\n}\r\nunifi_trace(priv, UDBG5, "updated Mac Header: %d \n",macHeaderLengthInBytes);\r\nmemcpy(bufPtr, macHeaderBuf, macHeaderLengthInBytes);\r\nunifi_trace(priv, UDBG5, "leaving the update_macheader function\n");\r\nreturn 0;\r\n}\r\nint\r\nuf_ap_process_data_pdu(unifi_priv_t *priv, struct sk_buff *skb,\r\nstruct ethhdr *ehdr, CsrWifiRouterCtrlStaInfo_t * srcStaInfo,\r\nconst CSR_SIGNAL *signal,\r\nbulk_data_param_t *bulkdata,\r\nu8 macHeaderLengthInBytes)\r\n{\r\nconst CSR_MA_PACKET_INDICATION *ind = &(signal->u.MaPacketIndication);\r\nu16 interfaceTag = (ind->VirtualInterfaceIdentifier & 0x00ff);\r\nstruct sk_buff *newSkb = NULL;\r\nstruct sk_buff *skbPtr = skb;\r\nu8 sendToNetdev = FALSE;\r\nu8 qosDestination = FALSE;\r\nCSR_PRIORITY priority = CSR_CONTENTION;\r\nCsrWifiRouterCtrlStaInfo_t *dstStaInfo = NULL;\r\nnetInterface_priv_t *interfacePriv;\r\nunifi_trace(priv, UDBG5, "entering uf_ap_process_data_pdu %d\n",macHeaderLengthInBytes);\r\nif (interfaceTag >= CSR_WIFI_NUM_INTERFACES) {\r\nunifi_trace(priv, UDBG1, "Interface Tag is Invalid in uf_ap_process_data_pdu\n");\r\nunifi_net_data_free(priv, &bulkdata->d[0]);\r\nreturn 0;\r\n}\r\ninterfacePriv = priv->interfacePriv[interfaceTag];\r\nif((interfacePriv->interfaceMode == CSR_WIFI_ROUTER_CTRL_MODE_P2PGO) &&\r\n(interfacePriv->intraBssEnabled == FALSE)) {\r\nunifi_trace(priv, UDBG2, "uf_ap_process_data_pdu:P2P GO intrabssEnabled?= %d\n", interfacePriv->intraBssEnabled);\r\ndstStaInfo = CsrWifiRouterCtrlGetStationRecordFromPeerMacAddress(priv, ehdr->h_dest, interfaceTag);\r\nif (dstStaInfo) {\r\nunifi_net_data_free(priv, &bulkdata->d[0]);\r\nreturn 0;\r\n}\r\nreturn -1;\r\n}\r\nif(!memcmp(ehdr->h_dest, interfacePriv->bssid.a, ETH_ALEN)) {\r\nunifi_trace(priv, UDBG4, "destination address is csr_ap\n");\r\nreturn -1;\r\n}\r\ndstStaInfo = CsrWifiRouterCtrlGetStationRecordFromPeerMacAddress(priv, ehdr->h_dest, interfaceTag);\r\nif(!dstStaInfo) {\r\nif (!(ehdr->h_dest[0] & 0x1)) {\r\nunifi_trace(priv, UDBG3, "unicast frame & destination record not exist, send to netdev proto = %x\n", htons(skb->protocol));\r\nreturn -1;\r\n} else {\r\nunifi_trace(priv, UDBG5, "skb_copy, in uf_ap_process_data_pdu, protocol = %x\n", htons(skb->protocol));\r\nskbPtr = skb_copy(skb, GFP_KERNEL);\r\nif(skbPtr == NULL) {\r\nunifi_notice(priv, "broacast/multicast frame can't be sent in BSS No memeory: proto = %x\n", htons(skb->protocol));\r\nreturn -1;\r\n}\r\nsendToNetdev = TRUE;\r\n}\r\n} else {\r\nif (uf_process_station_records_for_sending_data(priv, interfaceTag, srcStaInfo, dstStaInfo)) {\r\nunifi_notice(priv, "uf_ap_process_data_pdu: station record validation failed \n");\r\ninterfacePriv->stats.rx_errors++;\r\nunifi_net_data_free(priv, &bulkdata->d[0]);\r\nreturn 0;\r\n}\r\n}\r\nif(sendToNetdev) {\r\nqosDestination = FALSE;\r\n} else if(dstStaInfo && (dstStaInfo->wmmOrQosEnabled == TRUE)) {\r\nqosDestination = TRUE;\r\n}\r\nunifi_trace(priv, UDBG3, "uf_ap_process_data_pdu QoS destination = %s\n", (qosDestination)? "TRUE": "FALSE");\r\nif (update_macheader(priv, skbPtr, newSkb, &priority, bulkdata, interfaceTag, macHeaderLengthInBytes, qosDestination)) {\r\ninterfacePriv->stats.rx_errors++;\r\nunifi_notice(priv, "(Packet Drop) failed to update the Mac header in uf_ap_process_data_pdu\n");\r\nif (sendToNetdev) {\r\nbulkdata->d[0].os_data_ptr = skbPtr->data;\r\nbulkdata->d[0].os_net_buf_ptr = (unsigned char*)skbPtr;\r\nbulkdata->d[0].data_length = skbPtr->len;\r\nunifi_net_data_free(priv, &bulkdata->d[0]);\r\n}\r\nreturn -1;\r\n}\r\nunifi_trace(priv, UDBG3, "Mac Header updated...calling uf_process_ma_packet_req \n");\r\nif (uf_process_ma_packet_req(priv, ehdr->h_dest, 0xffffffff, interfaceTag, CSR_NO_CONFIRM_REQUIRED, (CSR_RATE)0,priority, priv->netdev_client->sender_id, bulkdata)) {\r\nif (sendToNetdev) {\r\nunifi_trace(priv, UDBG1, "In uf_ap_process_data_pdu, (Packet Drop) uf_process_ma_packet_req failed. freeing skb_copy data (original data sent to Netdev)\n");\r\nbulkdata->d[0].os_data_ptr = skbPtr->data;\r\nbulkdata->d[0].os_net_buf_ptr = (unsigned char*)skbPtr;\r\nbulkdata->d[0].data_length = skbPtr->len;\r\nunifi_net_data_free(priv, &bulkdata->d[0]);\r\n} else {\r\nunifi_trace(priv, UDBG1, "In uf_ap_process_data_pdu, (Packet Drop). Unicast data so freeing original skb \n");\r\nunifi_net_data_free(priv, &bulkdata->d[0]);\r\n}\r\n}\r\nunifi_trace(priv, UDBG5, "leaving uf_ap_process_data_pdu\n");\r\nif (sendToNetdev) {\r\nunifi_trace(priv, UDBG4, "Packet will be routed to NetDev\n");\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nCsrResult uf_process_ma_packet_req(unifi_priv_t *priv,\r\nu8 *peerMacAddress,\r\nCSR_CLIENT_TAG hostTag,\r\nu16 interfaceTag,\r\nCSR_TRANSMISSION_CONTROL transmissionControl,\r\nCSR_RATE TransmitRate,\r\nCSR_PRIORITY priority,\r\nCSR_PROCESS_ID leSenderProcessId,\r\nbulk_data_param_t *bulkdata)\r\n{\r\nCsrResult status = CSR_RESULT_SUCCESS;\r\nCSR_SIGNAL signal;\r\nint result;\r\n#ifdef CSR_SUPPORT_SME\r\nCsrWifiRouterCtrlStaInfo_t *staRecord = NULL;\r\nconst u8 *macHdrLocation = bulkdata->d[0].os_data_ptr;\r\nCsrWifiPacketType pktType;\r\nint frameType = 0;\r\nu8 queuePacketDozing = FALSE;\r\nu32 priority_q;\r\nu16 frmCtrl;\r\nstruct list_head * list = NULL;\r\nu8 setBcTim=FALSE;\r\nnetInterface_priv_t *interfacePriv;\r\nu8 requeueOnSamePos = FALSE;\r\nu32 handle = 0xFFFFFFFF;\r\nunsigned long lock_flags;\r\nunifi_trace(priv, UDBG5,\r\n"entering uf_process_ma_packet_req, peer: %pMF\n",\r\npeerMacAddress);\r\nif (interfaceTag >= CSR_WIFI_NUM_INTERFACES) {\r\nunifi_error(priv, "interfaceTag >= CSR_WIFI_NUM_INTERFACES, interfacetag = %d\n", interfaceTag);\r\nreturn CSR_RESULT_FAILURE;\r\n}\r\ninterfacePriv = priv->interfacePriv[interfaceTag];\r\nif ((staRecord = CsrWifiRouterCtrlGetStationRecordFromPeerMacAddress(priv, peerMacAddress, interfaceTag))) {\r\nhandle = staRecord->assignedHandle;\r\n}\r\nunifi_frame_ma_packet_req(priv, priority, TransmitRate, hostTag,\r\ninterfaceTag, transmissionControl, leSenderProcessId,\r\npeerMacAddress, &signal);\r\nswitch(interfacePriv->interfaceMode)\r\n{\r\ncase CSR_WIFI_ROUTER_CTRL_MODE_AP:\r\ncase CSR_WIFI_ROUTER_CTRL_MODE_P2PGO:\r\nbreak;\r\ndefault:\r\nunifi_trace(priv, UDBG5, "In %s, interface mode is %x \n", __FUNCTION__, interfacePriv->interfaceMode);\r\nif (interfacePriv->interfaceMode == CSR_WIFI_ROUTER_CTRL_MODE_NONE) {\r\nunifi_warning(priv, "In %s, interface mode NONE \n", __FUNCTION__);\r\n}\r\nif ((result = ul_send_signal_unpacked(priv, &signal, bulkdata))) {\r\nstatus = CSR_RESULT_FAILURE;\r\n}\r\nreturn status;\r\n}\r\npriority_q = unifi_frame_priority_to_queue((CSR_PRIORITY) priority);\r\nif (staRecord && (staRecord->currentPeerState ==\r\nCSR_WIFI_ROUTER_CTRL_PEER_CONNECTED_POWER_SAVE)) {\r\nqueuePacketDozing = TRUE;\r\n}\r\nif (*peerMacAddress & 0x1) {\r\npktType = CSR_WIFI_MULTICAST_PDU;\r\n} else {\r\npktType = CSR_WIFI_UNICAST_PDU;\r\n}\r\nfrmCtrl = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(macHdrLocation);\r\nframeType = ((frmCtrl & 0x000c) >> FRAME_CONTROL_TYPE_FIELD_OFFSET);\r\nswitch(frameType)\r\n{\r\ncase IEEE802_11_FRAMETYPE_MANAGEMENT:\r\nswitch(pktType)\r\n{\r\ncase CSR_WIFI_UNICAST_PDU:\r\nunifi_trace(priv, UDBG5, "management unicast PDU in uf_process_ma_packet_req \n");\r\nif (!staRecord) {\r\nif (list_empty(&interfacePriv->genericMgtFrames)) {\r\n#ifdef CSR_SUPPORT_SME\r\nif(!(IS_DTIM_ACTIVE(interfacePriv->dtimActive,interfacePriv->multicastPduHostTag))) {\r\n#endif\r\nunifi_trace(priv, UDBG3, "genericMgtFrames list is empty uf_process_ma_packet_req \n");\r\nresult = ul_send_signal_unpacked(priv, &signal, bulkdata);\r\nif(result == -ENOSPC) {\r\nunifi_trace(priv, UDBG1, "(ENOSPC) Sending genericMgtFrames Failed so buffering\n");\r\nlist = &interfacePriv->genericMgtFrames;\r\nrequeueOnSamePos = TRUE;\r\n}\r\n#ifdef CSR_SUPPORT_SME\r\n}else{\r\nlist = &interfacePriv->genericMgtFrames;\r\nunifi_trace(priv, UDBG3, "genericMgtFrames queue empty and dtim started\n hosttag is 0x%x,\n",signal.u.MaPacketRequest.HostTag);\r\nupdate_eosp_to_head_of_broadcast_list_head(priv,interfaceTag);\r\n}\r\n#endif\r\n} else {\r\nlist = &interfacePriv->genericMgtFrames;\r\nunifi_trace(priv, UDBG2, "genericMgtFrames queue not empty\n");\r\n}\r\n} else {\r\nif (queuePacketDozing || !list_empty(&staRecord->mgtFrames) || IS_DTIM_ACTIVE(interfacePriv->dtimActive,interfacePriv->multicastPduHostTag)) {\r\nlist = &staRecord->mgtFrames;\r\nunifi_trace(priv, UDBG1, "staRecord->MgtFrames list empty? = %s, handle = %d, queuePacketDozing = %d\n",\r\n(list_empty(&staRecord->mgtFrames))? "YES": "NO", staRecord->assignedHandle, queuePacketDozing);\r\nif(IS_DTIM_ACTIVE(interfacePriv->dtimActive,interfacePriv->multicastPduHostTag)){\r\nupdate_eosp_to_head_of_broadcast_list_head(priv,interfaceTag);\r\n}\r\n} else {\r\nunifi_trace(priv, UDBG5, "staRecord->mgtFrames list is empty uf_process_ma_packet_req \n");\r\nresult = ul_send_signal_unpacked(priv, &signal, bulkdata);\r\nif(result == -ENOSPC) {\r\nlist = &staRecord->mgtFrames;\r\nrequeueOnSamePos = TRUE;\r\nunifi_trace(priv, UDBG1, "(ENOSPC) Sending MgtFrames Failed handle = %d so buffering\n",staRecord->assignedHandle);\r\npriv->pausedStaHandle[0]=(u8)(staRecord->assignedHandle);\r\n} else if (result) {\r\nstatus = CSR_RESULT_FAILURE;\r\n}\r\n}\r\n}\r\nbreak;\r\ncase CSR_WIFI_MULTICAST_PDU:\r\nunifi_trace(priv, UDBG5, "management multicast/broadcast PDU in uf_process_ma_packet_req 'QUEUE it' \n");\r\nlist = &interfacePriv->genericMulticastOrBroadCastMgtFrames;\r\nif((interfacePriv->interfaceMode != CSR_WIFI_ROUTER_CTRL_MODE_IBSS) &&\r\n(list_empty(&interfacePriv->genericMulticastOrBroadCastMgtFrames))) {\r\nsetBcTim=TRUE;\r\n}\r\nbreak;\r\ndefault:\r\nunifi_error(priv, "condition never meets: packet type unrecognized\n");\r\n}\r\nbreak;\r\ncase IEEE802_11_FRAMETYPE_DATA:\r\nswitch(pktType)\r\n{\r\ncase CSR_WIFI_UNICAST_PDU:\r\nunifi_trace(priv, UDBG5, "data unicast PDU in uf_process_ma_packet_req \n");\r\nif(!staRecord) {\r\nunifi_error(priv, "In %s unicast but staRecord = NULL\n", __FUNCTION__);\r\nreturn CSR_RESULT_FAILURE;\r\n} else if (queuePacketDozing || isRouterBufferEnabled(priv,priority_q)|| !list_empty(&staRecord->dataPdu[priority_q]) || IS_DTIM_ACTIVE(interfacePriv->dtimActive,interfacePriv->multicastPduHostTag)) {\r\nunifi_trace(priv, UDBG2, "Enqueued to staRecord->dataPdu[%d] queuePacketDozing=%d,\\r\nBuffering enabled = %d \n", priority_q,queuePacketDozing,isRouterBufferEnabled(priv,priority_q));\r\nlist = &staRecord->dataPdu[priority_q];\r\n} else {\r\nunifi_trace(priv, UDBG5, "staRecord->dataPdu[%d] list is empty uf_process_ma_packet_req \n", priority_q);\r\nresult = ul_send_signal_unpacked(priv, &signal, bulkdata);\r\nif(result == -ENOSPC) {\r\nunifi_trace(priv, UDBG1, "(ENOSPC) Sending Unicast DataPDU to queue %d Failed so buffering\n",priority_q);\r\nrequeueOnSamePos = TRUE;\r\nlist = &staRecord->dataPdu[priority_q];\r\npriv->pausedStaHandle[priority_q]=(u8)(staRecord->assignedHandle);\r\nif(!isRouterBufferEnabled(priv,priority_q)) {\r\nunifi_error(priv,"Buffering Not enabled for queue %d \n",priority_q);\r\n}\r\n} else if (result) {\r\nstatus = CSR_RESULT_FAILURE;\r\n}\r\n}\r\nbreak;\r\ncase CSR_WIFI_MULTICAST_PDU:\r\nunifi_trace(priv, UDBG5, "data multicast/broadcast PDU in uf_process_ma_packet_req \n");\r\nlist = &interfacePriv->genericMulticastOrBroadCastFrames;\r\nif(list_empty(&interfacePriv->genericMulticastOrBroadCastFrames)) {\r\nsetBcTim = TRUE;\r\n}\r\nbreak;\r\ndefault:\r\nunifi_error(priv, "condition never meets: packet type un recognized\n");\r\n}\r\nbreak;\r\ndefault:\r\nunifi_error(priv, "unrecognized frame type\n");\r\n}\r\nif(list) {\r\nstatus = enque_tx_data_pdu(priv, bulkdata,list, &signal,requeueOnSamePos);\r\nif (staRecord && (pktType == CSR_WIFI_UNICAST_PDU) && (!status)) {\r\nspin_lock_irqsave(&priv->staRecord_lock,lock_flags);\r\nstaRecord->noOfPktQueued++;\r\nspin_unlock_irqrestore(&priv->staRecord_lock,lock_flags);\r\n}\r\nelse if ((pktType == CSR_WIFI_MULTICAST_PDU) && (!status))\r\n{\r\nspin_lock_irqsave(&priv->staRecord_lock,lock_flags);\r\ninterfacePriv->noOfbroadcastPktQueued++;\r\nspin_unlock_irqrestore(&priv->staRecord_lock,lock_flags);\r\n}\r\n}\r\nif(setBcTim && !status) {\r\nunifi_trace(priv, UDBG3, "tim set due to broadcast pkt\n");\r\nif (!interfacePriv->bcTimSetReqPendingFlag)\r\n{\r\nupdate_tim(priv,0,CSR_WIFI_TIM_SET,interfaceTag, handle);\r\n}\r\nelse\r\n{\r\ninterfacePriv->bcTimSetReqQueued = CSR_WIFI_TIM_SET;\r\nunifi_trace(priv, UDBG2, "uf_process_ma_packet_req : One more UpdateDTim Request(:%d) Queued \n",\r\ninterfacePriv->bcTimSetReqQueued);\r\n}\r\n} else if(staRecord && staRecord->currentPeerState ==\r\nCSR_WIFI_ROUTER_CTRL_PEER_CONNECTED_POWER_SAVE) {\r\nif(staRecord->timSet == CSR_WIFI_TIM_RESET || staRecord->timSet == CSR_WIFI_TIM_RESETTING) {\r\nif(!staRecord->wmmOrQosEnabled) {\r\nif(!list_empty(&staRecord->mgtFrames) ||\r\n!list_empty(&staRecord->dataPdu[3]) ||\r\n!list_empty(&staRecord->dataPdu[UNIFI_TRAFFIC_Q_CONTENTION])) {\r\nunifi_trace(priv, UDBG3, "tim set due to unicast pkt & peer in powersave\n");\r\nif (!staRecord->timRequestPendingFlag){\r\nupdate_tim(priv,staRecord->aid,1,interfaceTag, handle);\r\n}\r\nelse\r\n{\r\nstaRecord->updateTimReqQueued = 1;\r\nunifi_trace(priv, UDBG6, "update_tim : One more UpdateTim Request (Tim value:%d) Queued for AID %x\n", staRecord->updateTimReqQueued,\r\nstaRecord->aid);\r\n}\r\n}\r\n} else {\r\nu8 allDeliveryEnabled = 0, dataAvailable = 0;\r\nis_all_ac_deliver_enabled_and_moredata(staRecord, &allDeliveryEnabled, &dataAvailable);\r\nif (uf_is_more_data_for_non_delivery_ac(staRecord) || (allDeliveryEnabled && dataAvailable)\r\n|| (!list_empty(&staRecord->mgtFrames))) {\r\nif (!staRecord->timRequestPendingFlag) {\r\nupdate_tim(priv,staRecord->aid,1,interfaceTag, handle);\r\n}\r\nelse\r\n{\r\nstaRecord->updateTimReqQueued = 1;\r\nunifi_trace(priv, UDBG6, "update_tim : One more UpdateTim Request (Tim value:%d) Queued for AID %x\n", staRecord->updateTimReqQueued,\r\nstaRecord->aid);\r\n}\r\n}\r\n}\r\n}\r\n}\r\nif((list) && (pktType == CSR_WIFI_UNICAST_PDU && !queuePacketDozing) && !(isRouterBufferEnabled(priv,priority_q)) && !(IS_DTIM_ACTIVE(interfacePriv->dtimActive,interfacePriv->multicastPduHostTag))) {\r\nunifi_trace(priv, UDBG2, "buffering cleared for queue = %d So resending buffered frames\n",priority_q);\r\nuf_send_buffered_frames(priv, priority_q);\r\n}\r\nunifi_trace(priv, UDBG5, "leaving uf_process_ma_packet_req \n");\r\nreturn status;\r\n#else\r\n#ifdef CSR_NATIVE_LINUX\r\nif (interfaceTag >= CSR_WIFI_NUM_INTERFACES) {\r\nunifi_error(priv, "interfaceTag >= CSR_WIFI_NUM_INTERFACES, interfacetag = %d\n", interfaceTag);\r\nreturn CSR_RESULT_FAILURE;\r\n}\r\nunifi_frame_ma_packet_req(priv, priority, TransmitRate, hostTag, interfaceTag,\r\ntransmissionControl, leSenderProcessId,\r\npeerMacAddress, &signal);\r\nresult = ul_send_signal_unpacked(priv, &signal, bulkdata);\r\nif (result) {\r\nreturn CSR_RESULT_FAILURE;\r\n}\r\n#endif\r\nreturn status;\r\n#endif\r\n}\r\ns8 uf_get_protection_bit_from_interfacemode(unifi_priv_t *priv, u16 interfaceTag, const u8 *daddr)\r\n{\r\ns8 protection = 0;\r\nnetInterface_priv_t *interfacePriv = priv->interfacePriv[interfaceTag];\r\nswitch(interfacePriv->interfaceMode)\r\n{\r\ncase CSR_WIFI_ROUTER_CTRL_MODE_STA:\r\ncase CSR_WIFI_ROUTER_CTRL_MODE_P2PCLI:\r\ncase CSR_WIFI_ROUTER_CTRL_MODE_AMP:\r\ncase CSR_WIFI_ROUTER_CTRL_MODE_IBSS:\r\nprotection = interfacePriv->protect;\r\nbreak;\r\ncase CSR_WIFI_ROUTER_CTRL_MODE_AP:\r\ncase CSR_WIFI_ROUTER_CTRL_MODE_P2PGO:\r\n{\r\nCsrWifiRouterCtrlStaInfo_t *dstStaInfo = NULL;\r\nif (daddr[0] & 0x1) {\r\nunifi_trace(priv, UDBG3, "broadcast/multicast packet in send_ma_pkt_request\n");\r\nprotection = interfacePriv->protect;\r\n} else {\r\ndstStaInfo = CsrWifiRouterCtrlGetStationRecordFromPeerMacAddress(priv, daddr, interfaceTag);\r\nif (!dstStaInfo) {\r\nunifi_trace(priv, UDBG3, "peer not found in station record in send_ma_pkt_request\n");\r\nreturn -1;\r\n}\r\nprotection = dstStaInfo->protection;\r\n}\r\n}\r\nbreak;\r\ndefault:\r\nunifi_trace(priv, UDBG2, "mode unknown in send_ma_pkt_request\n");\r\n}\r\nreturn protection;\r\n}\r\nu8 send_multicast_frames(unifi_priv_t *priv, u16 interfaceTag)\r\n{\r\nint r;\r\ntx_buffered_packets_t * buffered_pkt = NULL;\r\nu8 moreData = FALSE;\r\nu8 pduSent =0;\r\nunsigned long lock_flags;\r\nnetInterface_priv_t *interfacePriv = priv->interfacePriv[interfaceTag];\r\nu32 hostTag = 0xffffffff;\r\nif(!isRouterBufferEnabled(priv,UNIFI_TRAFFIC_Q_VO)) {\r\nwhile((interfacePriv->dtimActive)&& (buffered_pkt=dequeue_tx_data_pdu(priv,&interfacePriv->genericMulticastOrBroadCastMgtFrames))) {\r\nbuffered_pkt->transmissionControl |= (TRANSMISSION_CONTROL_TRIGGER_MASK);\r\nmoreData = (buffered_pkt->transmissionControl & TRANSMISSION_CONTROL_EOSP_MASK)?FALSE:TRUE;\r\nunifi_trace(priv,UDBG2,"DTIM Occurred for interface:sending Mgt packet %d\n",interfaceTag);\r\nif((r=frame_and_send_queued_pdu(priv,buffered_pkt,NULL,moreData,FALSE)) == -ENOSPC) {\r\nunifi_trace(priv,UDBG1,"frame_and_send_queued_pdu failed with ENOSPC for host tag = %x\n", buffered_pkt->hostTag);\r\nspin_lock_irqsave(&priv->tx_q_lock,lock_flags);\r\nlist_add(&buffered_pkt->q, &interfacePriv->genericMulticastOrBroadCastMgtFrames);\r\nspin_unlock_irqrestore(&priv->tx_q_lock,lock_flags);\r\nbreak;\r\n} else {\r\nunifi_trace(priv,UDBG1,"send_multicast_frames: Send genericMulticastOrBroadCastMgtFrames (%x, %x)\n",\r\nbuffered_pkt->hostTag,\r\nr);\r\nif(r) {\r\nunifi_net_data_free(priv, &buffered_pkt->bulkdata);\r\n}\r\nif(!moreData) {\r\ninterfacePriv->dtimActive = FALSE;\r\nif(!r) {\r\nhostTag = buffered_pkt->hostTag;\r\npduSent++;\r\n} else {\r\nsend_vif_availibility_rsp(priv,uf_get_vif_identifier(interfacePriv->interfaceMode,interfaceTag),CSR_RC_UNSPECIFIED_FAILURE);\r\n}\r\n}\r\nspin_lock_irqsave(&priv->staRecord_lock,lock_flags);\r\ninterfacePriv->noOfbroadcastPktQueued--;\r\nspin_unlock_irqrestore(&priv->staRecord_lock,lock_flags);\r\nkfree(buffered_pkt);\r\n}\r\n}\r\n}\r\nif(!isRouterBufferEnabled(priv,UNIFI_TRAFFIC_Q_CONTENTION)) {\r\nwhile((interfacePriv->dtimActive)&& (buffered_pkt=dequeue_tx_data_pdu(priv,&interfacePriv->genericMulticastOrBroadCastFrames))) {\r\nbuffered_pkt->transmissionControl |= TRANSMISSION_CONTROL_TRIGGER_MASK;\r\nmoreData = (buffered_pkt->transmissionControl & TRANSMISSION_CONTROL_EOSP_MASK)?FALSE:TRUE;\r\nif((r=frame_and_send_queued_pdu(priv,buffered_pkt,NULL,moreData,FALSE)) == -ENOSPC) {\r\nbuffered_pkt->transmissionControl &= ~(TRANSMISSION_CONTROL_TRIGGER_MASK);\r\nspin_lock_irqsave(&priv->tx_q_lock,lock_flags);\r\nlist_add(&buffered_pkt->q, &interfacePriv->genericMulticastOrBroadCastFrames);\r\nspin_unlock_irqrestore(&priv->tx_q_lock,lock_flags);\r\nbreak;\r\n} else {\r\nif(r) {\r\nunifi_trace(priv,UDBG1,"send_multicast_frames: Send genericMulticastOrBroadCastFrame failed (%x, %x)\n",\r\nbuffered_pkt->hostTag,\r\nr);\r\nunifi_net_data_free(priv, &buffered_pkt->bulkdata);\r\n}\r\nif(!moreData) {\r\ninterfacePriv->dtimActive = FALSE;\r\nif(!r) {\r\npduSent ++;\r\nhostTag = buffered_pkt->hostTag;\r\n} else {\r\nsend_vif_availibility_rsp(priv,uf_get_vif_identifier(interfacePriv->interfaceMode,interfaceTag),CSR_RC_UNSPECIFIED_FAILURE);\r\n}\r\n}\r\nspin_lock_irqsave(&priv->staRecord_lock,lock_flags);\r\ninterfacePriv->noOfbroadcastPktQueued--;\r\nspin_unlock_irqrestore(&priv->staRecord_lock,lock_flags);\r\nkfree(buffered_pkt);\r\n}\r\n}\r\n}\r\nif((interfacePriv->dtimActive == FALSE)) {\r\nunifi_trace(priv,UDBG2,"send_multicast_frames: Recorded hostTag of EOSP packet: = 0x%x\n",hostTag);\r\ninterfacePriv->multicastPduHostTag = hostTag;\r\n}\r\nreturn pduSent;\r\n}\r\nvoid uf_process_ma_vif_availibility_ind(unifi_priv_t *priv,u8 *sigdata,\r\nu32 siglen)\r\n{\r\n#ifdef CSR_SUPPORT_SME\r\nCSR_SIGNAL signal;\r\nCSR_MA_VIF_AVAILABILITY_INDICATION *ind;\r\nint r;\r\nu16 interfaceTag;\r\nu8 pduSent =0;\r\nCSR_RESULT_CODE resultCode = CSR_RC_SUCCESS;\r\nnetInterface_priv_t *interfacePriv;\r\nunifi_trace(priv, UDBG3,\r\n"uf_process_ma_vif_availibility_ind: Process signal 0x%.4X\n",\r\n*((u16*)sigdata));\r\nr = read_unpack_signal(sigdata, &signal);\r\nif (r) {\r\nunifi_error(priv,\r\n"uf_process_ma_vif_availibility_ind: Received unknown signal 0x%.4X.\n",\r\nCSR_GET_UINT16_FROM_LITTLE_ENDIAN(sigdata));\r\nreturn;\r\n}\r\nind = &signal.u.MaVifAvailabilityIndication;\r\ninterfaceTag=ind->VirtualInterfaceIdentifier & 0xff;\r\nif (interfaceTag >= CSR_WIFI_NUM_INTERFACES) {\r\nunifi_error(priv, "in vif_availability_ind interfaceTag is wrong\n");\r\nreturn;\r\n}\r\ninterfacePriv = priv->interfacePriv[interfaceTag];\r\nif(ind->Multicast) {\r\nif(list_empty(&interfacePriv->genericMulticastOrBroadCastFrames) &&\r\nlist_empty(&interfacePriv->genericMulticastOrBroadCastMgtFrames)) {\r\nunifi_notice(priv,"ma_vif_availibility_ind recevied for multicast but queues are empty%d\n",interfaceTag);\r\nsend_vif_availibility_rsp(priv,ind->VirtualInterfaceIdentifier,CSR_RC_NO_BUFFERED_BROADCAST_MULTICAST_FRAMES);\r\ninterfacePriv->dtimActive = FALSE;\r\nif(interfacePriv->multicastPduHostTag == 0xffffffff) {\r\nunifi_notice(priv,"ma_vif_availibility_ind recevied for multicast but queues are empty%d\n",interfaceTag);\r\nif (!interfacePriv->bcTimSetReqPendingFlag)\r\n{\r\nupdate_tim(priv,0,CSR_WIFI_TIM_RESET,interfaceTag, 0xFFFFFFFF);\r\n}\r\nelse\r\n{\r\ninterfacePriv->bcTimSetReqQueued = CSR_WIFI_TIM_RESET;\r\nunifi_trace(priv, UDBG2, "uf_process_ma_vif_availibility_ind : One more UpdateDTim Request(%d) Queued \n",\r\ninterfacePriv->bcTimSetReqQueued);\r\n}\r\n}\r\nreturn;\r\n}\r\nif(interfacePriv->dtimActive) {\r\nunifi_trace(priv,UDBG2,"DTIM Occurred for already active DTIM interface %d\n",interfaceTag);\r\nreturn;\r\n} else {\r\nunifi_trace(priv,UDBG2,"DTIM Occurred for interface %d\n",interfaceTag);\r\nif(list_empty(&interfacePriv->genericMulticastOrBroadCastFrames)) {\r\nset_eosp_transmit_ctrl(priv,&interfacePriv->genericMulticastOrBroadCastMgtFrames);\r\n} else {\r\nset_eosp_transmit_ctrl(priv,&interfacePriv->genericMulticastOrBroadCastFrames);\r\n}\r\n}\r\ninterfacePriv->dtimActive = TRUE;\r\npduSent = send_multicast_frames(priv,interfaceTag);\r\n}\r\nelse {\r\nunifi_error(priv,"Interface switching is not supported %d\n",interfaceTag);\r\nresultCode = CSR_RC_NOT_SUPPORTED;\r\nsend_vif_availibility_rsp(priv,ind->VirtualInterfaceIdentifier,CSR_RC_NOT_SUPPORTED);\r\n}\r\n#endif\r\n}\r\nstatic u8 uf_is_more_data_for_delivery_ac(unifi_priv_t *priv, CsrWifiRouterCtrlStaInfo_t *staRecord)\r\n{\r\ns8 i;\r\nfor(i=UNIFI_TRAFFIC_Q_VO; i >= UNIFI_TRAFFIC_Q_BK; i--)\r\n{\r\nif(((staRecord->powersaveMode[i]==CSR_WIFI_AC_DELIVERY_ONLY_ENABLE)\r\n||(staRecord->powersaveMode[i]==CSR_WIFI_AC_TRIGGER_AND_DELIVERY_ENABLED))\r\n&&(!list_empty(&staRecord->dataPdu[i]))) {\r\nunifi_trace(priv,UDBG2,"uf_is_more_data_for_delivery_ac: Data Available AC = %d\n", i);\r\nreturn TRUE;\r\n}\r\n}\r\nunifi_trace(priv,UDBG2,"uf_is_more_data_for_delivery_ac: Data NOT Available \n");\r\nreturn FALSE;\r\n}\r\nstatic u8 uf_is_more_data_for_usp_delivery(unifi_priv_t *priv, CsrWifiRouterCtrlStaInfo_t *staRecord, unifi_TrafficQueue queue)\r\n{\r\ns8 i;\r\nfor(i = queue; i >= UNIFI_TRAFFIC_Q_BK; i--)\r\n{\r\nif(((staRecord->powersaveMode[i]==CSR_WIFI_AC_DELIVERY_ONLY_ENABLE)\r\n||(staRecord->powersaveMode[i]==CSR_WIFI_AC_TRIGGER_AND_DELIVERY_ENABLED))\r\n&&(!list_empty(&staRecord->dataPdu[i]))) {\r\nunifi_trace(priv,UDBG2,"uf_is_more_data_for_usp_delivery: Data Available AC = %d\n", i);\r\nreturn TRUE;\r\n}\r\n}\r\nunifi_trace(priv,UDBG2,"uf_is_more_data_for_usp_delivery: Data NOT Available \n");\r\nreturn FALSE;\r\n}\r\nvoid uf_send_buffered_data_from_delivery_ac(unifi_priv_t *priv,\r\nCsrWifiRouterCtrlStaInfo_t * staInfo,\r\nu8 queue,\r\nstruct list_head *txList)\r\n{\r\nu16 interfaceTag = GET_ACTIVE_INTERFACE_TAG(priv);\r\ntx_buffered_packets_t * buffered_pkt = NULL;\r\nunsigned long lock_flags;\r\nu8 eosp=FALSE;\r\ns8 r =0;\r\nu8 moreData = FALSE;\r\nnetInterface_priv_t *interfacePriv = priv->interfacePriv[interfaceTag];\r\nunifi_trace(priv, UDBG2, "++uf_send_buffered_data_from_delivery_ac, active=%x\n", staInfo->uapsdActive);\r\nif (queue > UNIFI_TRAFFIC_Q_VO)\r\n{\r\nreturn;\r\n}\r\nwhile((buffered_pkt=dequeue_tx_data_pdu(priv, txList))) {\r\nif((IS_DTIM_ACTIVE(interfacePriv->dtimActive,interfacePriv->multicastPduHostTag))) {\r\nunifi_trace(priv, UDBG2, "uf_send_buffered_data_from_delivery_ac: DTIM Active, suspend UAPSD, staId: 0x%x\n",\r\nstaInfo->aid);\r\nspin_lock_irqsave(&priv->staRecord_lock,lock_flags);\r\nstaInfo->uspSuspend = TRUE;\r\nspin_unlock_irqrestore(&priv->staRecord_lock,lock_flags);\r\nspin_lock_irqsave(&priv->tx_q_lock,lock_flags);\r\nlist_add(&buffered_pkt->q,txList);\r\nspin_unlock_irqrestore(&priv->tx_q_lock,lock_flags);\r\nbreak;\r\n}\r\nbuffered_pkt->transmissionControl &=\r\n~(TRANSMISSION_CONTROL_TRIGGER_MASK | TRANSMISSION_CONTROL_EOSP_MASK);\r\nif((staInfo->wmmOrQosEnabled == TRUE)&&(staInfo->uapsdActive == TRUE)) {\r\nbuffered_pkt->transmissionControl = TRANSMISSION_CONTROL_TRIGGER_MASK;\r\nmoreData = (!list_empty(txList) || uf_is_more_data_for_usp_delivery(priv, staInfo, queue));\r\nif(staInfo->noOfSpFramesSent == (staInfo->maxSpLength - 1)) {\r\nmoreData = FALSE;\r\n}\r\nif(moreData == FALSE) {\r\neosp = TRUE;\r\nbuffered_pkt->transmissionControl =\r\n(TRANSMISSION_CONTROL_TRIGGER_MASK | TRANSMISSION_CONTROL_EOSP_MASK);\r\n}\r\n} else {\r\nunifi_warning(priv, "uf_send_buffered_data_from_delivery_ac: non U-APSD !!! \n");\r\n}\r\nunifi_trace(priv,UDBG2,"uf_send_buffered_data_from_delivery_ac : MoreData:%d, EOSP:%d\n",moreData,eosp);\r\nif((r=frame_and_send_queued_pdu(priv,buffered_pkt,staInfo,moreData,eosp)) == -ENOSPC) {\r\nunifi_trace(priv, UDBG2, "uf_send_buffered_data_from_delivery_ac: UASPD suspended, ENOSPC in hipQ=%x\n", queue);\r\nspin_lock_irqsave(&priv->staRecord_lock,lock_flags);\r\nstaInfo->uspSuspend = TRUE;\r\nspin_unlock_irqrestore(&priv->staRecord_lock,lock_flags);\r\nspin_lock_irqsave(&priv->tx_q_lock,lock_flags);\r\nlist_add(&buffered_pkt->q,txList);\r\nspin_unlock_irqrestore(&priv->tx_q_lock,lock_flags);\r\npriv->pausedStaHandle[queue]=(u8)(staInfo->assignedHandle);\r\nbreak;\r\n} else {\r\nif(r){\r\nunifi_net_data_free(priv, &buffered_pkt->bulkdata);\r\n}\r\nkfree(buffered_pkt);\r\nspin_lock_irqsave(&priv->staRecord_lock,lock_flags);\r\nstaInfo->noOfSpFramesSent++;\r\nif((!moreData) || (staInfo->noOfSpFramesSent == staInfo->maxSpLength)) {\r\nunifi_trace(priv, UDBG2, "uf_send_buffered_data_from_delivery_ac: Terminating USP\n");\r\nstaInfo->uapsdActive = FALSE;\r\nstaInfo->uspSuspend = FALSE;\r\nstaInfo->noOfSpFramesSent = 0;\r\nspin_unlock_irqrestore(&priv->staRecord_lock,lock_flags);\r\nbreak;\r\n}\r\nspin_unlock_irqrestore(&priv->staRecord_lock,lock_flags);\r\n}\r\n}\r\nunifi_trace(priv, UDBG2, "--uf_send_buffered_data_from_delivery_ac, active=%x\n", staInfo->uapsdActive);\r\n}\r\nvoid uf_send_buffered_data_from_ac(unifi_priv_t *priv,\r\nCsrWifiRouterCtrlStaInfo_t * staInfo,\r\nu8 queue,\r\nstruct list_head *txList)\r\n{\r\ntx_buffered_packets_t * buffered_pkt = NULL;\r\nunsigned long lock_flags;\r\nu8 eosp=FALSE;\r\nu8 moreData = FALSE;\r\ns8 r =0;\r\nunifi_trace(priv,UDBG2,"uf_send_buffered_data_from_ac :\n");\r\nwhile(!isRouterBufferEnabled(priv,queue) &&\r\n((buffered_pkt=dequeue_tx_data_pdu(priv, txList))!=NULL)){\r\nbuffered_pkt->transmissionControl &=\r\n~(TRANSMISSION_CONTROL_TRIGGER_MASK|TRANSMISSION_CONTROL_EOSP_MASK);\r\nunifi_trace(priv,UDBG3,"uf_send_buffered_data_from_ac : MoreData:%d, EOSP:%d\n",moreData,eosp);\r\nif((r=frame_and_send_queued_pdu(priv,buffered_pkt,staInfo,moreData,eosp)) == -ENOSPC) {\r\nspin_lock_irqsave(&priv->tx_q_lock,lock_flags);\r\nlist_add(&buffered_pkt->q,txList);\r\nspin_unlock_irqrestore(&priv->tx_q_lock,lock_flags);\r\nif(staInfo != NULL){\r\npriv->pausedStaHandle[queue]=(u8)(staInfo->assignedHandle);\r\n}\r\nunifi_trace(priv,UDBG3," uf_send_buffered_data_from_ac: PDU sending failed .. no space for queue %d \n",queue);\r\n} else {\r\nif(r){\r\nunifi_net_data_free(priv, &buffered_pkt->bulkdata);\r\n}\r\nkfree(buffered_pkt);\r\n}\r\n}\r\n}\r\nvoid uf_send_buffered_frames(unifi_priv_t *priv,unifi_TrafficQueue q)\r\n{\r\nu16 interfaceTag = GET_ACTIVE_INTERFACE_TAG(priv);\r\nu32 startIndex=0,endIndex=0;\r\nCsrWifiRouterCtrlStaInfo_t * staInfo = NULL;\r\nu8 queue;\r\nu8 moreData = FALSE;\r\nnetInterface_priv_t *interfacePriv = priv->interfacePriv[interfaceTag];\r\nif(!((interfacePriv->interfaceMode == CSR_WIFI_ROUTER_CTRL_MODE_AP) ||\r\n(interfacePriv->interfaceMode == CSR_WIFI_ROUTER_CTRL_MODE_P2PGO)))\r\nreturn;\r\nqueue = (q<=3)?q:0;\r\nif(interfacePriv->dtimActive) {\r\nsend_multicast_frames(priv,interfaceTag);\r\nif(!interfacePriv->dtimActive) {\r\nmoreData = (!list_empty(&interfacePriv->genericMulticastOrBroadCastMgtFrames) ||\r\n!list_empty(&interfacePriv->genericMulticastOrBroadCastFrames));\r\nif(!moreData) {\r\nif (!interfacePriv->bcTimSetReqPendingFlag)\r\n{\r\nupdate_tim(priv,0,CSR_WIFI_TIM_RESET,interfaceTag, 0XFFFFFFFF);\r\n}\r\nelse\r\n{\r\ninterfacePriv->bcTimSetReqQueued = CSR_WIFI_TIM_RESET;\r\nunifi_trace(priv, UDBG2, "uf_send_buffered_frames : One more UpdateDTim Request(%d) Queued \n",\r\ninterfacePriv->bcTimSetReqQueued);\r\n}\r\n}\r\n} else {\r\nmoreData = (!list_empty(&interfacePriv->genericMulticastOrBroadCastMgtFrames) ||\r\n!list_empty(&interfacePriv->genericMulticastOrBroadCastFrames));\r\nif(!moreData) {\r\nunifi_error(priv,"ERROR: No More Data but DTIM is active sending Response\n");\r\nsend_vif_availibility_rsp(priv,uf_get_vif_identifier(interfacePriv->interfaceMode,interfaceTag),CSR_RC_NO_BUFFERED_BROADCAST_MULTICAST_FRAMES);\r\ninterfacePriv->dtimActive = FALSE;\r\n}\r\n}\r\nreturn;\r\n}\r\nif(priv->pausedStaHandle[queue] > 7) {\r\npriv->pausedStaHandle[queue] = 0;\r\n}\r\nif(queue == UNIFI_TRAFFIC_Q_VO) {\r\nunifi_trace(priv,UDBG2,"uf_send_buffered_frames : trying mgt from queue=%d\n",queue);\r\nfor(startIndex= 0; startIndex < UNIFI_MAX_CONNECTIONS;startIndex++) {\r\nstaInfo = CsrWifiRouterCtrlGetStationRecordFromHandle(priv,startIndex,interfaceTag);\r\nif(!staInfo ) {\r\ncontinue;\r\n} else if((staInfo->currentPeerState == CSR_WIFI_ROUTER_CTRL_PEER_CONNECTED_POWER_SAVE)\r\n&&(staInfo->uapsdActive == FALSE) ) {\r\ncontinue;\r\n}\r\nif((staInfo != NULL)&&(staInfo->currentPeerState == CSR_WIFI_ROUTER_CTRL_PEER_CONNECTED_ACTIVE)\r\n&&(staInfo->uapsdActive == FALSE)){\r\nif(!list_empty(&staInfo->mgtFrames)){\r\nuf_send_buffered_data_from_ac(priv,staInfo, UNIFI_TRAFFIC_Q_VO, &staInfo->mgtFrames);\r\n}\r\n}\r\nif(isRouterBufferEnabled(priv,queue)) {\r\nunifi_notice(priv,"uf_send_buffered_frames : No space Left for queue = %d\n",queue);\r\nbreak;\r\n}\r\n}\r\nif(!list_empty(&interfacePriv->genericMgtFrames)) {\r\nunifi_trace(priv,UDBG2,"uf_send_buffered_frames : trying generic mgt from queue=%d\n",queue);\r\nuf_send_buffered_data_from_ac(priv,staInfo, UNIFI_TRAFFIC_Q_VO, &interfacePriv->genericMgtFrames);\r\n}\r\n}\r\nunifi_trace(priv,UDBG2,"uf_send_buffered_frames : Resume called for Queue=%d\n",queue);\r\nunifi_trace(priv,UDBG2,"uf_send_buffered_frames : start=%d end=%d\n",startIndex,endIndex);\r\nstartIndex = priv->pausedStaHandle[queue];\r\nendIndex = (startIndex + UNIFI_MAX_CONNECTIONS -1) % UNIFI_MAX_CONNECTIONS;\r\nwhile(startIndex != endIndex) {\r\nstaInfo = CsrWifiRouterCtrlGetStationRecordFromHandle(priv,startIndex,interfaceTag);\r\nif(!staInfo) {\r\nstartIndex ++;\r\nif(startIndex >= UNIFI_MAX_CONNECTIONS) {\r\nstartIndex = 0;\r\n}\r\ncontinue;\r\n} else if((staInfo->currentPeerState == CSR_WIFI_ROUTER_CTRL_PEER_CONNECTED_POWER_SAVE)\r\n&&(staInfo->uapsdActive == FALSE)) {\r\nstartIndex ++;\r\nif(startIndex >= UNIFI_MAX_CONNECTIONS) {\r\nstartIndex = 0;\r\n}\r\ncontinue;\r\n}\r\nunifi_trace(priv,UDBG2,"uf_send_buffered_frames : trying data from queue=%d\n",queue);\r\nif((staInfo != NULL)&&(staInfo->currentPeerState == CSR_WIFI_ROUTER_CTRL_PEER_CONNECTED_ACTIVE)\r\n&&(staInfo->uapsdActive == FALSE)) {\r\nif(!list_empty(&staInfo->dataPdu[queue])) {\r\nuf_send_buffered_data_from_ac(priv, staInfo, queue, (&staInfo->dataPdu[queue]));\r\n}\r\n}\r\nstartIndex ++;\r\nif(startIndex >= UNIFI_MAX_CONNECTIONS) {\r\nstartIndex = 0;\r\n}\r\n}\r\nif(isRouterBufferEnabled(priv,queue)) {\r\npriv->pausedStaHandle[queue] = endIndex;\r\n} else {\r\npriv->pausedStaHandle[queue] = 0;\r\n}\r\nunifi_trace(priv, UDBG4, "csrWifiHipSendBufferedFrames: UAPSD Resume Q=%x\n", queue);\r\nresume_suspended_uapsd(priv, interfaceTag);\r\n}\r\nu8 uf_is_more_data_for_non_delivery_ac(CsrWifiRouterCtrlStaInfo_t *staRecord)\r\n{\r\nu8 i;\r\nfor(i=0;i<=3;i++)\r\n{\r\nif(((staRecord->powersaveMode[i]==CSR_WIFI_AC_TRIGGER_ONLY_ENABLED)\r\n||(staRecord->powersaveMode[i]==CSR_WIFI_AC_LEGACY_POWER_SAVE))\r\n&&(!list_empty(&staRecord->dataPdu[i]))){\r\nreturn TRUE;\r\n}\r\n}\r\nif(((staRecord->powersaveMode[UNIFI_TRAFFIC_Q_VO]==CSR_WIFI_AC_TRIGGER_ONLY_ENABLED)\r\n||(staRecord->powersaveMode[UNIFI_TRAFFIC_Q_VO]==CSR_WIFI_AC_LEGACY_POWER_SAVE))\r\n&&(!list_empty(&staRecord->mgtFrames))){\r\nreturn TRUE;\r\n}\r\nreturn FALSE;\r\n}\r\nint uf_process_station_records_for_sending_data(unifi_priv_t *priv,u16 interfaceTag,\r\nCsrWifiRouterCtrlStaInfo_t *srcStaInfo,\r\nCsrWifiRouterCtrlStaInfo_t *dstStaInfo)\r\n{\r\nnetInterface_priv_t *interfacePriv = priv->interfacePriv[interfaceTag];\r\nunifi_trace(priv, UDBG5, "entering uf_process_station_records_for_sending_data\n");\r\nif (srcStaInfo->currentPeerState == CSR_WIFI_ROUTER_CTRL_PEER_DISCONNECTED) {\r\nunifi_error(priv, "Peer State not connected AID = %x, handle = %x, control port state = %x\n",\r\nsrcStaInfo->aid, srcStaInfo->assignedHandle, srcStaInfo->peerControlledPort->port_action);\r\nreturn -1;\r\n}\r\nswitch (interfacePriv->interfaceMode)\r\n{\r\ncase CSR_WIFI_ROUTER_CTRL_MODE_P2PGO:\r\ncase CSR_WIFI_ROUTER_CTRL_MODE_AP:\r\nunifi_trace(priv, UDBG5, "mode is AP/P2PGO\n");\r\nbreak;\r\ndefault:\r\nunifi_warning(priv, "mode is nor AP neither P2PGO, packet cant be xmit\n");\r\nreturn -1;\r\n}\r\nswitch(dstStaInfo->peerControlledPort->port_action)\r\n{\r\ncase CSR_WIFI_ROUTER_CTRL_PORT_ACTION_8021X_PORT_CLOSED_DISCARD:\r\ncase CSR_WIFI_ROUTER_CTRL_PORT_ACTION_8021X_PORT_CLOSED_BLOCK:\r\nunifi_trace(priv, UDBG5, "destination port is closed/blocked, discarding the packet\n");\r\nreturn -1;\r\ndefault:\r\nunifi_trace(priv, UDBG5, "destination port state is open\n");\r\n}\r\nunifi_trace(priv, UDBG5, "leaving uf_process_station_records_for_sending_data\n");\r\nreturn 0;\r\n}\r\nstatic void uf_handle_uspframes_delivery(unifi_priv_t * priv, CsrWifiRouterCtrlStaInfo_t *staInfo, u16 interfaceTag)\r\n{\r\ns8 i;\r\nu8 allDeliveryEnabled = 0, dataAvailable = 0;\r\nnetInterface_priv_t *interfacePriv = priv->interfacePriv[interfaceTag];\r\nunsigned long lock_flags;\r\nunifi_trace(priv, UDBG2, " ++ uf_handle_uspframes_delivery, uapsd active=%x, suspended?=%x\n",\r\nstaInfo->uapsdActive, staInfo->uspSuspend);\r\nif (!staInfo->uspSuspend && staInfo->uapsdActive)\r\n{\r\nunifi_notice(priv, "uf_handle_uspframes_delivery: U-APSD already active! STA=%x:%x:%x:%x:%x:%x\n",\r\nstaInfo->peerMacAddress.a[0], staInfo->peerMacAddress.a[1],\r\nstaInfo->peerMacAddress.a[2], staInfo->peerMacAddress.a[3],\r\nstaInfo->peerMacAddress.a[4], staInfo->peerMacAddress.a[5]);\r\nreturn;\r\n}\r\nspin_lock_irqsave(&priv->staRecord_lock,lock_flags);\r\nstaInfo->uapsdActive = TRUE;\r\nstaInfo->uspSuspend = FALSE;\r\nspin_unlock_irqrestore(&priv->staRecord_lock,lock_flags);\r\nif(((staInfo->powersaveMode[UNIFI_TRAFFIC_Q_VO]==CSR_WIFI_AC_TRIGGER_AND_DELIVERY_ENABLED)||\r\n(staInfo->powersaveMode[UNIFI_TRAFFIC_Q_VO]==CSR_WIFI_AC_DELIVERY_ONLY_ENABLE))\r\n&& (!list_empty(&staInfo->mgtFrames))) {\r\nunifi_trace(priv, UDBG4, "uf_handle_uspframes_delivery: Sending buffered management frames\n");\r\nuf_send_buffered_data_from_delivery_ac(priv, staInfo, UNIFI_TRAFFIC_Q_VO, &staInfo->mgtFrames);\r\n}\r\nif (!uf_is_more_data_for_delivery_ac(priv, staInfo)) {\r\nif (!staInfo->uspSuspend) {\r\nspin_lock_irqsave(&priv->staRecord_lock,lock_flags);\r\nstaInfo->uapsdActive = FALSE;\r\nspin_unlock_irqrestore(&priv->staRecord_lock,lock_flags);\r\nunifi_trace(priv, UDBG2, "uf_handle_uspframes_delivery: sending QNull for trigger\n");\r\nuf_send_qos_null(priv, interfaceTag, staInfo->peerMacAddress.a, (CSR_PRIORITY) staInfo->triggerFramePriority, staInfo);\r\nstaInfo->triggerFramePriority = CSR_QOS_UP0;\r\n} else {\r\nunifi_trace(priv, UDBG2, "uf_handle_uspframes_delivery: MgtQ xfer suspended\n");\r\n}\r\n} else {\r\nfor(i = UNIFI_TRAFFIC_Q_VO; i >= UNIFI_TRAFFIC_Q_BK; i--) {\r\nif(((staInfo->powersaveMode[i]==CSR_WIFI_AC_DELIVERY_ONLY_ENABLE)\r\n||(staInfo->powersaveMode[i]==CSR_WIFI_AC_TRIGGER_AND_DELIVERY_ENABLED))\r\n&& (!list_empty(&staInfo->dataPdu[i]))) {\r\nunifi_trace(priv, UDBG4, "uf_handle_uspframes_delivery: Buffered data frames from Queue (%d) for USP\n", i);\r\nuf_send_buffered_data_from_delivery_ac(priv, staInfo, i, &staInfo->dataPdu[i]);\r\n}\r\nif ((!staInfo->uapsdActive) ||\r\n(staInfo->uspSuspend && IS_DTIM_ACTIVE(interfacePriv->dtimActive,interfacePriv->multicastPduHostTag))) {\r\nunifi_trace(priv, UDBG2, "uf_handle_uspframes_delivery: suspend=%x, DTIM=%x, USP terminated=%s\n",\r\nstaInfo->uspSuspend, IS_DTIM_ACTIVE(interfacePriv->dtimActive,interfacePriv->multicastPduHostTag),\r\nstaInfo->uapsdActive?"NO":"YES");\r\nbreak;\r\n}\r\n}\r\n}\r\nis_all_ac_deliver_enabled_and_moredata(staInfo, &allDeliveryEnabled, &dataAvailable);\r\nif ((allDeliveryEnabled && !dataAvailable)) {\r\nif ((staInfo->timSet != CSR_WIFI_TIM_RESET) || (staInfo->timSet != CSR_WIFI_TIM_RESETTING)) {\r\nstaInfo->updateTimReqQueued = (u8) CSR_WIFI_TIM_RESET;\r\nunifi_trace(priv, UDBG4, " --uf_handle_uspframes_delivery, UAPSD timset\n");\r\nif (!staInfo->timRequestPendingFlag) {\r\nupdate_tim(priv, staInfo->aid, 0, interfaceTag, staInfo->assignedHandle);\r\n}\r\n}\r\n}\r\nunifi_trace(priv, UDBG2, " --uf_handle_uspframes_delivery, uapsd active=%x, suspend?=%x\n",\r\nstaInfo->uapsdActive, staInfo->uspSuspend);\r\n}\r\nvoid uf_process_wmm_deliver_ac_uapsd(unifi_priv_t * priv,\r\nCsrWifiRouterCtrlStaInfo_t * srcStaInfo,\r\nu16 qosControl,\r\nu16 interfaceTag)\r\n{\r\nCSR_PRIORITY priority;\r\nunifi_TrafficQueue priority_q;\r\nunsigned long lock_flags;\r\nunifi_trace(priv, UDBG2, "++uf_process_wmm_deliver_ac_uapsd: uapsdactive?=%x\n", srcStaInfo->uapsdActive);\r\npriority = (CSR_PRIORITY)(qosControl & IEEE802_11_QC_TID_MASK);\r\npriority_q = unifi_frame_priority_to_queue((CSR_PRIORITY) priority);\r\nif((srcStaInfo->powersaveMode[priority_q]==CSR_WIFI_AC_TRIGGER_ONLY_ENABLED)\r\n||(srcStaInfo->powersaveMode[priority_q]==CSR_WIFI_AC_TRIGGER_AND_DELIVERY_ENABLED)) {\r\nspin_lock_irqsave(&priv->staRecord_lock,lock_flags);\r\nsrcStaInfo->triggerFramePriority = priority;\r\nspin_unlock_irqrestore(&priv->staRecord_lock,lock_flags);\r\nunifi_trace(priv, UDBG2, "uf_process_wmm_deliver_ac_uapsd: trigger frame, Begin U-APSD, triggerQ=%x\n", priority_q);\r\nuf_handle_uspframes_delivery(priv, srcStaInfo, interfaceTag);\r\n}\r\nunifi_trace(priv, UDBG2, "--uf_process_wmm_deliver_ac_uapsd: uapsdactive?=%x\n", srcStaInfo->uapsdActive);\r\n}\r\nvoid uf_send_qos_null(unifi_priv_t * priv,u16 interfaceTag, const u8 *da,CSR_PRIORITY priority,CsrWifiRouterCtrlStaInfo_t * srcStaInfo)\r\n{\r\nbulk_data_param_t bulkdata;\r\nCsrResult csrResult;\r\nstruct sk_buff *skb, *newSkb = NULL;\r\nCsrWifiMacAddress peerAddress;\r\nnetInterface_priv_t *interfacePriv = priv->interfacePriv[interfaceTag];\r\nCSR_TRANSMISSION_CONTROL transmissionControl = (TRANSMISSION_CONTROL_EOSP_MASK | TRANSMISSION_CONTROL_TRIGGER_MASK);\r\nint r;\r\nCSR_SIGNAL signal;\r\nu32 priority_q;\r\nCSR_RATE transmitRate = 0;\r\ncsrResult = unifi_net_data_malloc(priv, &bulkdata.d[0], MAC_HEADER_SIZE + QOS_CONTROL_HEADER_SIZE);\r\nif (csrResult != CSR_RESULT_SUCCESS) {\r\nunifi_error(priv, " failed to allocate request_data. in uf_send_qos_null func\n");\r\nreturn ;\r\n}\r\nskb = (struct sk_buff *)(bulkdata.d[0].os_net_buf_ptr);\r\nskb->len = 0;\r\nbulkdata.d[0].os_data_ptr = skb->data;\r\nbulkdata.d[0].os_net_buf_ptr = (unsigned char*)skb;\r\nbulkdata.d[0].net_buf_length = bulkdata.d[0].data_length = skb->len;\r\nbulkdata.d[1].os_data_ptr = NULL;\r\nbulkdata.d[1].os_net_buf_ptr = NULL;\r\nbulkdata.d[1].net_buf_length = bulkdata.d[1].data_length = 0;\r\nif (prepare_and_add_macheader(priv, skb, newSkb, priority, &bulkdata, interfaceTag, da, interfacePriv->bssid.a, 0)) {\r\nunifi_error(priv, "failed to create MAC header\n");\r\nunifi_net_data_free(priv, &bulkdata.d[0]);\r\nreturn;\r\n}\r\nmemcpy(peerAddress.a, ((u8 *) bulkdata.d[0].os_data_ptr) + 4, ETH_ALEN);\r\npriority_q = unifi_frame_priority_to_queue((CSR_PRIORITY) priority);\r\nswitch (interfacePriv->interfaceMode)\r\n{\r\ncase CSR_WIFI_ROUTER_CTRL_MODE_AP:\r\ntransmitRate = 2;\r\nbreak;\r\ncase CSR_WIFI_ROUTER_CTRL_MODE_P2PGO:\r\ntransmitRate = 12;\r\nbreak;\r\ndefault:\r\ntransmitRate = 0;\r\n}\r\nunifi_frame_ma_packet_req(priv, priority, transmitRate, 0xffffffff, interfaceTag,\r\ntransmissionControl, priv->netdev_client->sender_id,\r\npeerAddress.a, &signal);\r\nr = ul_send_signal_unpacked(priv, &signal, &bulkdata);\r\nif(r) {\r\nunifi_error(priv, "failed to send QOS data null packet result: %d\n",r);\r\nunifi_net_data_free(priv, &bulkdata.d[0]);\r\n}\r\nreturn;\r\n}\r\nvoid uf_send_nulldata(unifi_priv_t * priv,u16 interfaceTag, const u8 *da,CSR_PRIORITY priority,CsrWifiRouterCtrlStaInfo_t * srcStaInfo)\r\n{\r\nbulk_data_param_t bulkdata;\r\nCsrResult csrResult;\r\nstruct sk_buff *skb, *newSkb = NULL;\r\nCsrWifiMacAddress peerAddress;\r\nnetInterface_priv_t *interfacePriv = priv->interfacePriv[interfaceTag];\r\nCSR_TRANSMISSION_CONTROL transmissionControl = 0;\r\nint r;\r\nCSR_SIGNAL signal;\r\nu32 priority_q;\r\nCSR_RATE transmitRate = 0;\r\nCSR_MA_PACKET_REQUEST *req = &signal.u.MaPacketRequest;\r\nunsigned long lock_flags;\r\ncsrResult = unifi_net_data_malloc(priv, &bulkdata.d[0], MAC_HEADER_SIZE);\r\nif (csrResult != CSR_RESULT_SUCCESS) {\r\nunifi_error(priv, "uf_send_nulldata: Failed to allocate memory for NULL frame\n");\r\nreturn ;\r\n}\r\nskb = (struct sk_buff *)(bulkdata.d[0].os_net_buf_ptr);\r\nskb->len = 0;\r\nbulkdata.d[0].os_data_ptr = skb->data;\r\nbulkdata.d[0].os_net_buf_ptr = (unsigned char*)skb;\r\nbulkdata.d[0].net_buf_length = bulkdata.d[0].data_length = skb->len;\r\nbulkdata.d[1].os_data_ptr = NULL;\r\nbulkdata.d[1].os_net_buf_ptr = NULL;\r\nbulkdata.d[1].net_buf_length = bulkdata.d[1].data_length = 0;\r\nif (prepare_and_add_macheader(priv, skb, newSkb, priority, &bulkdata, interfaceTag, da, interfacePriv->bssid.a, 0)) {\r\nunifi_error(priv, "uf_send_nulldata: Failed to create MAC header\n");\r\nunifi_net_data_free(priv, &bulkdata.d[0]);\r\nreturn;\r\n}\r\nmemcpy(peerAddress.a, ((u8 *) bulkdata.d[0].os_data_ptr) + 4, ETH_ALEN);\r\npriority_q = unifi_frame_priority_to_queue((CSR_PRIORITY) priority);\r\ntransmissionControl &= ~(CSR_NO_CONFIRM_REQUIRED);\r\nswitch (interfacePriv->interfaceMode)\r\n{\r\ncase CSR_WIFI_ROUTER_CTRL_MODE_AP:\r\ntransmitRate = 2;\r\nbreak;\r\ncase CSR_WIFI_ROUTER_CTRL_MODE_P2PGO:\r\ntransmitRate = 12;\r\nbreak;\r\ndefault:\r\ntransmitRate = 0;\r\n}\r\nunifi_frame_ma_packet_req(priv, priority, transmitRate, INVALID_HOST_TAG, interfaceTag,\r\ntransmissionControl, priv->netdev_client->sender_id,\r\npeerAddress.a, &signal);\r\nsrcStaInfo->nullDataHostTag = req->HostTag;\r\nunifi_trace(priv, UDBG1, "uf_send_nulldata: STA AID = %d hostTag = %x\n", srcStaInfo->aid, req->HostTag);\r\nr = ul_send_signal_unpacked(priv, &signal, &bulkdata);\r\nif(r == -ENOSPC) {\r\nunifi_trace(priv, UDBG1, "uf_send_nulldata: ENOSPC Requeue the Null frame\n");\r\nenque_tx_data_pdu(priv, &bulkdata, &srcStaInfo->dataPdu[priority_q], &signal, 1);\r\nspin_lock_irqsave(&priv->staRecord_lock,lock_flags);\r\nsrcStaInfo->noOfPktQueued++;\r\nspin_unlock_irqrestore(&priv->staRecord_lock,lock_flags);\r\n}\r\nif(r && r != -ENOSPC){\r\nunifi_error(priv, "uf_send_nulldata: Failed to send Null frame Error = %d\n",r);\r\nunifi_net_data_free(priv, &bulkdata.d[0]);\r\nsrcStaInfo->nullDataHostTag = INVALID_HOST_TAG;\r\n}\r\nreturn;\r\n}\r\nu8 uf_check_broadcast_bssid(unifi_priv_t *priv, const bulk_data_param_t *bulkdata)\r\n{\r\nu8 *bssid = NULL;\r\nstatic const CsrWifiMacAddress broadcast_address = {{0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF}};\r\nu8 toDs, fromDs;\r\ntoDs = (((bulkdata->d[0].os_data_ptr)[1]) & 0x01) ? 1 : 0;\r\nfromDs =(((bulkdata->d[0].os_data_ptr)[1]) & 0x02) ? 1 : 0;\r\nif (toDs && fromDs)\r\n{\r\nunifi_trace(priv, UDBG6, "Address 4 present, Don't try to find BSSID\n");\r\nbssid = NULL;\r\n}\r\nelse if((toDs == 0) && (fromDs ==0))\r\n{\r\nbssid = (u8 *) (bulkdata->d[0].os_data_ptr + 4 + (2 * ETH_ALEN));\r\n}\r\nelse if(toDs)\r\n{\r\nbssid = (u8 *) (bulkdata->d[0].os_data_ptr + 4);\r\n}\r\nelse if(fromDs)\r\n{\r\nbssid = (u8 *) (bulkdata->d[0].os_data_ptr + 4 + ETH_ALEN);\r\n}\r\nif (memcmp(broadcast_address.a, bssid, ETH_ALEN)== 0)\r\n{\r\nreturn TRUE;\r\n}\r\nelse\r\n{\r\nreturn FALSE;\r\n}\r\n}\r\nu8 uf_process_pm_bit_for_peer(unifi_priv_t * priv, CsrWifiRouterCtrlStaInfo_t * srcStaInfo,\r\nu8 pmBit,u16 interfaceTag)\r\n{\r\nu8 moreData = FALSE;\r\nu8 powerSaveChanged = FALSE;\r\nunsigned long lock_flags;\r\nunifi_trace(priv, UDBG3, "entering uf_process_pm_bit_for_peer\n");\r\nif (pmBit) {\r\npriv->allPeerDozing |= (0x01 << (srcStaInfo->assignedHandle));\r\n} else {\r\npriv->allPeerDozing &= ~(0x01 << (srcStaInfo->assignedHandle));\r\n}\r\nif(pmBit) {\r\nif(srcStaInfo->currentPeerState == CSR_WIFI_ROUTER_CTRL_PEER_CONNECTED_ACTIVE) {\r\nspin_lock_irqsave(&priv->staRecord_lock,lock_flags);\r\nsrcStaInfo->currentPeerState =CSR_WIFI_ROUTER_CTRL_PEER_CONNECTED_POWER_SAVE;\r\npowerSaveChanged = TRUE;\r\nspin_unlock_irqrestore(&priv->staRecord_lock,lock_flags);\r\n} else {\r\nreturn powerSaveChanged;\r\n}\r\n} else {\r\nif(srcStaInfo->currentPeerState == CSR_WIFI_ROUTER_CTRL_PEER_CONNECTED_POWER_SAVE) {\r\nspin_lock_irqsave(&priv->staRecord_lock,lock_flags);\r\nsrcStaInfo->currentPeerState = CSR_WIFI_ROUTER_CTRL_PEER_CONNECTED_ACTIVE;\r\npowerSaveChanged = TRUE;\r\nspin_unlock_irqrestore(&priv->staRecord_lock,lock_flags);\r\n}else {\r\nreturn powerSaveChanged;\r\n}\r\n}\r\nif(srcStaInfo->currentPeerState == CSR_WIFI_ROUTER_CTRL_PEER_CONNECTED_ACTIVE) {\r\nunifi_trace(priv,UDBG3, "Peer with AID = %d is active now\n",srcStaInfo->aid);\r\nprocess_peer_active_transition(priv,srcStaInfo,interfaceTag);\r\n} else {\r\nunifi_trace(priv,UDBG3, "Peer with AID = %d is in PS Now\n",srcStaInfo->aid);\r\nif(!srcStaInfo->wmmOrQosEnabled) {\r\nmoreData = (!list_empty(&srcStaInfo->mgtFrames) ||\r\n!list_empty(&srcStaInfo->dataPdu[UNIFI_TRAFFIC_Q_VO])||\r\n!list_empty(&srcStaInfo->dataPdu[UNIFI_TRAFFIC_Q_CONTENTION]));\r\nif(moreData && (srcStaInfo->timSet == CSR_WIFI_TIM_RESET)) {\r\nunifi_trace(priv, UDBG3, "This condition should not occur\n");\r\nif (!srcStaInfo->timRequestPendingFlag){\r\nupdate_tim(priv,srcStaInfo->aid,1,interfaceTag, srcStaInfo->assignedHandle);\r\n}\r\nelse\r\n{\r\nsrcStaInfo->updateTimReqQueued = 1;\r\nunifi_trace(priv, UDBG6, "update_tim : One more UpdateTim Request (Tim value:%d) Queued for AID %x\n", srcStaInfo->updateTimReqQueued,\r\nsrcStaInfo->aid);\r\n}\r\n}\r\n} else {\r\nu8 allDeliveryEnabled = 0, dataAvailable = 0;\r\nunifi_trace(priv, UDBG5, "Qos in AP Mode\n");\r\nis_all_ac_deliver_enabled_and_moredata(srcStaInfo, &allDeliveryEnabled, &dataAvailable);\r\nmoreData = (uf_is_more_data_for_non_delivery_ac(srcStaInfo) || (allDeliveryEnabled && dataAvailable));\r\nif(moreData && (srcStaInfo->timSet == CSR_WIFI_TIM_RESET)) {\r\nif (!srcStaInfo->timRequestPendingFlag){\r\nupdate_tim(priv,srcStaInfo->aid,1,interfaceTag, srcStaInfo->assignedHandle);\r\n}\r\nelse\r\n{\r\nsrcStaInfo->updateTimReqQueued = 1;\r\nunifi_trace(priv, UDBG6, "update_tim : One more UpdateTim Request (Tim value:%d) Queued for AID %x\n", srcStaInfo->updateTimReqQueued,\r\nsrcStaInfo->aid);\r\n}\r\n}\r\n}\r\n}\r\nunifi_trace(priv, UDBG3, "leaving uf_process_pm_bit_for_peer\n");\r\nreturn powerSaveChanged;\r\n}\r\nvoid uf_process_ps_poll(unifi_priv_t *priv,u8* sa,u8* da,u8 pmBit,u16 interfaceTag)\r\n{\r\nCsrWifiRouterCtrlStaInfo_t *staRecord =\r\nCsrWifiRouterCtrlGetStationRecordFromPeerMacAddress(priv, sa, interfaceTag);\r\ntx_buffered_packets_t * buffered_pkt = NULL;\r\nCsrWifiMacAddress peerMacAddress;\r\nunsigned long lock_flags;\r\ns8 r =0;\r\nu8 moreData = FALSE;\r\nnetInterface_priv_t *interfacePriv = priv->interfacePriv[interfaceTag];\r\nunifi_trace(priv, UDBG3, "entering uf_process_ps_poll\n");\r\nif(!staRecord) {\r\nmemcpy(peerMacAddress.a,sa,ETH_ALEN);\r\nunifi_trace(priv, UDBG3, "In uf_process_ps_poll, sta record not found:unexpected frame addr = %x:%x:%x:%x:%x:%x\n",\r\nsa[0], sa[1],sa[2], sa[3], sa[4],sa[5]);\r\nCsrWifiRouterCtrlUnexpectedFrameIndSend(priv->CSR_WIFI_SME_IFACEQUEUE,0,interfaceTag,peerMacAddress);\r\nreturn;\r\n}\r\nuf_process_pm_bit_for_peer(priv,staRecord,pmBit,interfaceTag);\r\nstaRecord->activity_flag = TRUE;\r\nif(!pmBit) {\r\nunifi_notice (priv," PM bit reset in PS-POLL\n");\r\nreturn;\r\n}\r\nif(IS_DTIM_ACTIVE(interfacePriv->dtimActive,interfacePriv->multicastPduHostTag)) {\r\nunifi_notice (priv," multicast transmission is going on so don't take action on PS-POLL\n");\r\nreturn;\r\n}\r\nif(!staRecord->wmmOrQosEnabled) {\r\nif((buffered_pkt=dequeue_tx_data_pdu(priv, &staRecord->mgtFrames))) {\r\nbuffered_pkt->transmissionControl |= TRANSMISSION_CONTROL_TRIGGER_MASK;\r\nmoreData = (!list_empty(&staRecord->dataPdu[UNIFI_TRAFFIC_Q_CONTENTION]) ||\r\n!list_empty(&staRecord->dataPdu[UNIFI_TRAFFIC_Q_VO]) ||\r\n!list_empty(&staRecord->mgtFrames));\r\nbuffered_pkt->transmissionControl |= (TRANSMISSION_CONTROL_TRIGGER_MASK | TRANSMISSION_CONTROL_EOSP_MASK);\r\nif((r=frame_and_send_queued_pdu(priv,buffered_pkt,staRecord,moreData,FALSE)) == -ENOSPC) {\r\nbuffered_pkt->transmissionControl &= ~(TRANSMISSION_CONTROL_TRIGGER_MASK | TRANSMISSION_CONTROL_EOSP_MASK);\r\nspin_lock_irqsave(&priv->tx_q_lock,lock_flags);\r\nlist_add(&buffered_pkt->q, &staRecord->mgtFrames);\r\nspin_unlock_irqrestore(&priv->tx_q_lock,lock_flags);\r\nunifi_trace(priv, UDBG1, "(ENOSPC) PS-POLL received : PDU sending failed \n");\r\npriv->pausedStaHandle[3]=(u8)(staRecord->assignedHandle);\r\n} else {\r\nif(r){\r\nunifi_trace (priv, UDBG1, " HIP validation failure : PDU sending failed \n");\r\nunifi_net_data_free(priv, &buffered_pkt->bulkdata);\r\n}\r\nkfree(buffered_pkt);\r\n}\r\n} else if((buffered_pkt=dequeue_tx_data_pdu(priv, &staRecord->dataPdu[UNIFI_TRAFFIC_Q_VO]))) {\r\nbuffered_pkt->transmissionControl |= TRANSMISSION_CONTROL_TRIGGER_MASK;\r\nmoreData = (!list_empty(&staRecord->dataPdu[UNIFI_TRAFFIC_Q_CONTENTION]) ||\r\n!list_empty(&staRecord->dataPdu[UNIFI_TRAFFIC_Q_VO]));\r\nbuffered_pkt->transmissionControl |= (TRANSMISSION_CONTROL_TRIGGER_MASK | TRANSMISSION_CONTROL_EOSP_MASK);\r\nif((r=frame_and_send_queued_pdu(priv,buffered_pkt,staRecord,moreData,FALSE)) == -ENOSPC) {\r\nbuffered_pkt->transmissionControl &= ~(TRANSMISSION_CONTROL_TRIGGER_MASK | TRANSMISSION_CONTROL_EOSP_MASK);\r\nspin_lock_irqsave(&priv->tx_q_lock,lock_flags);\r\nlist_add(&buffered_pkt->q, &staRecord->dataPdu[UNIFI_TRAFFIC_Q_VO]);\r\nspin_unlock_irqrestore(&priv->tx_q_lock,lock_flags);\r\npriv->pausedStaHandle[3]=(u8)(staRecord->assignedHandle);\r\nunifi_trace(priv, UDBG1, "(ENOSPC) PS-POLL received : PDU sending failed \n");\r\n} else {\r\nif(r){\r\nunifi_trace (priv, UDBG1, " HIP validation failure : PDU sending failed \n");\r\nunifi_net_data_free(priv, &buffered_pkt->bulkdata);\r\n}\r\nkfree(buffered_pkt);\r\n}\r\n} else if((buffered_pkt=dequeue_tx_data_pdu(priv, &staRecord->dataPdu[UNIFI_TRAFFIC_Q_CONTENTION]))) {\r\nbuffered_pkt->transmissionControl |= TRANSMISSION_CONTROL_TRIGGER_MASK;\r\nmoreData = !list_empty(&staRecord->dataPdu[UNIFI_TRAFFIC_Q_CONTENTION]);\r\nbuffered_pkt->transmissionControl |= (TRANSMISSION_CONTROL_TRIGGER_MASK | TRANSMISSION_CONTROL_EOSP_MASK);\r\nif((r=frame_and_send_queued_pdu(priv,buffered_pkt,staRecord,moreData,FALSE)) == -ENOSPC) {\r\nbuffered_pkt->transmissionControl &= ~(TRANSMISSION_CONTROL_TRIGGER_MASK | TRANSMISSION_CONTROL_EOSP_MASK);\r\nspin_lock_irqsave(&priv->tx_q_lock,lock_flags);\r\nlist_add(&buffered_pkt->q, &staRecord->dataPdu[UNIFI_TRAFFIC_Q_CONTENTION]);\r\nspin_unlock_irqrestore(&priv->tx_q_lock,lock_flags);\r\npriv->pausedStaHandle[0]=(u8)(staRecord->assignedHandle);\r\nunifi_trace(priv, UDBG1, "(ENOSPC) PS-POLL received : PDU sending failed \n");\r\n} else {\r\nif(r){\r\nunifi_trace (priv, UDBG1, " HIP validation failure : PDU sending failed \n");\r\nunifi_net_data_free(priv, &buffered_pkt->bulkdata);\r\n}\r\nkfree(buffered_pkt);\r\n}\r\n} else {\r\n}\r\nmoreData = (!list_empty(&staRecord->dataPdu[UNIFI_TRAFFIC_Q_VO]) ||\r\n!list_empty(&staRecord->dataPdu[UNIFI_TRAFFIC_Q_CONTENTION]) ||\r\n!list_empty(&staRecord->mgtFrames));\r\nif(!moreData && (staRecord->timSet == CSR_WIFI_TIM_SET)) {\r\nunifi_trace(priv, UDBG3, "more data = NULL, set tim to 0 in uf_process_ps_poll\n");\r\nif (!staRecord->timRequestPendingFlag){\r\nupdate_tim(priv,staRecord->aid,0,interfaceTag, staRecord->assignedHandle);\r\n}\r\nelse\r\n{\r\nstaRecord->updateTimReqQueued = 0;\r\nunifi_trace(priv, UDBG6, "update_tim : One more UpdateTim Request (Tim value:%d) Queued for AID %x\n", staRecord->updateTimReqQueued,\r\nstaRecord->aid);\r\n}\r\n}\r\n} else {\r\nu8 allDeliveryEnabled = 0, dataAvailable = 0;\r\nunifi_trace(priv, UDBG3,"Qos Support station.Processing PS-Poll\n");\r\nis_all_ac_deliver_enabled_and_moredata(staRecord, &allDeliveryEnabled, &dataAvailable);\r\nif (allDeliveryEnabled) {\r\nunifi_trace(priv, UDBG3, "uf_process_ps_poll: All ACs are delivery enable so Sending QOS Null in response of Ps-poll\n");\r\nuf_send_qos_null(priv,interfaceTag,sa,CSR_QOS_UP0,staRecord);\r\nreturn;\r\n}\r\nif (!list_empty(&staRecord->mgtFrames)) {\r\nif ((buffered_pkt=dequeue_tx_data_pdu(priv, &staRecord->mgtFrames))) {\r\nmoreData = uf_is_more_data_for_non_delivery_ac(staRecord);\r\nbuffered_pkt->transmissionControl |= (TRANSMISSION_CONTROL_TRIGGER_MASK | TRANSMISSION_CONTROL_EOSP_MASK);\r\nif((r=frame_and_send_queued_pdu(priv,buffered_pkt,staRecord,moreData,FALSE)) == -ENOSPC) {\r\nbuffered_pkt->transmissionControl &= ~(TRANSMISSION_CONTROL_TRIGGER_MASK | TRANSMISSION_CONTROL_EOSP_MASK);\r\nspin_lock_irqsave(&priv->tx_q_lock,lock_flags);\r\nlist_add(&buffered_pkt->q, &staRecord->mgtFrames);\r\nspin_unlock_irqrestore(&priv->tx_q_lock,lock_flags);\r\npriv->pausedStaHandle[0]=(u8)(staRecord->assignedHandle);\r\nunifi_trace(priv, UDBG1, "(ENOSPC) PS-POLL received : PDU sending failed \n");\r\n} else {\r\nif(r){\r\nunifi_trace (priv, UDBG1, " HIP validation failure : PDU sending failed \n");\r\nunifi_net_data_free(priv, &buffered_pkt->bulkdata);\r\n}\r\nkfree(buffered_pkt);\r\n}\r\n} else {\r\nunifi_error(priv, "uf_process_ps_poll: Mgt frame list empty!! \n");\r\n}\r\n} else {\r\ns8 i;\r\nfor(i= 3; i>=0; i--) {\r\nif (!IS_DELIVERY_ENABLED(staRecord->powersaveMode[i])) {\r\nif((buffered_pkt=dequeue_tx_data_pdu(priv, &staRecord->dataPdu[i]))) {\r\nmoreData = uf_is_more_data_for_non_delivery_ac(staRecord);\r\nbuffered_pkt->transmissionControl |= (TRANSMISSION_CONTROL_TRIGGER_MASK | TRANSMISSION_CONTROL_EOSP_MASK);\r\nif((r=frame_and_send_queued_pdu(priv,buffered_pkt,staRecord,moreData,FALSE)) == -ENOSPC) {\r\nbuffered_pkt->transmissionControl &= ~(TRANSMISSION_CONTROL_TRIGGER_MASK | TRANSMISSION_CONTROL_EOSP_MASK);\r\nspin_lock_irqsave(&priv->tx_q_lock,lock_flags);\r\nlist_add(&buffered_pkt->q, &staRecord->dataPdu[i]);\r\nspin_unlock_irqrestore(&priv->tx_q_lock,lock_flags);\r\npriv->pausedStaHandle[0]=(u8)(staRecord->assignedHandle);\r\nunifi_trace(priv, UDBG1, "(ENOSPC) PS-POLL received : PDU sending failed \n");\r\n} else {\r\nif(r) {\r\nunifi_trace (priv, UDBG1, " HIP validation failure : PDU sending failed \n");\r\nunifi_net_data_free(priv, &buffered_pkt->bulkdata);\r\n}\r\nkfree(buffered_pkt);\r\n}\r\nbreak;\r\n}\r\n}\r\n}\r\n}\r\nis_all_ac_deliver_enabled_and_moredata(staRecord, &allDeliveryEnabled, &dataAvailable);\r\nmoreData = (uf_is_more_data_for_non_delivery_ac(staRecord) || (allDeliveryEnabled && dataAvailable));\r\nif(!moreData && (staRecord->timSet == CSR_WIFI_TIM_SET)) {\r\nunifi_trace(priv, UDBG3, "more data = NULL, set tim to 0 in uf_process_ps_poll\n");\r\nif (!staRecord->timRequestPendingFlag){\r\nupdate_tim(priv,staRecord->aid,0,interfaceTag, staRecord->assignedHandle);\r\n}\r\nelse\r\n{\r\nstaRecord->updateTimReqQueued = 0;\r\nunifi_trace(priv, UDBG6, "update_tim : One more UpdateTim Request (Tim value:%d) Queued for AID %x\n", staRecord->updateTimReqQueued,\r\nstaRecord->aid);\r\n}\r\n}\r\n}\r\nunifi_trace(priv, UDBG3, "leaving uf_process_ps_poll\n");\r\n}\r\nvoid add_to_send_cfm_list(unifi_priv_t * priv,\r\ntx_buffered_packets_t *tx_q_item,\r\nstruct list_head *frames_need_cfm_list)\r\n{\r\ntx_buffered_packets_t *send_cfm_list_item = NULL;\r\nsend_cfm_list_item = (tx_buffered_packets_t *) kmalloc(sizeof(tx_buffered_packets_t), GFP_ATOMIC);\r\nif(send_cfm_list_item == NULL){\r\nunifi_warning(priv, "%s: Failed to allocate memory for new list item \n");\r\nreturn;\r\n}\r\nINIT_LIST_HEAD(&send_cfm_list_item->q);\r\nsend_cfm_list_item->hostTag = tx_q_item->hostTag;\r\nsend_cfm_list_item->interfaceTag = tx_q_item->interfaceTag;\r\nsend_cfm_list_item->transmissionControl = tx_q_item->transmissionControl;\r\nsend_cfm_list_item->leSenderProcessId = tx_q_item->leSenderProcessId;\r\nsend_cfm_list_item->rate = tx_q_item->rate;\r\nmemcpy(send_cfm_list_item->peerMacAddress.a, tx_q_item->peerMacAddress.a, ETH_ALEN);\r\nsend_cfm_list_item->priority = tx_q_item->priority;\r\nlist_add_tail(&send_cfm_list_item->q, frames_need_cfm_list);\r\n}\r\nvoid uf_prepare_send_cfm_list_for_queued_pkts(unifi_priv_t * priv,\r\nstruct list_head *frames_need_cfm_list,\r\nstruct list_head * list)\r\n{\r\ntx_buffered_packets_t *tx_q_item = NULL;\r\nstruct list_head *listHead;\r\nstruct list_head *placeHolder;\r\nunsigned long lock_flags;\r\nspin_lock_irqsave(&priv->tx_q_lock,lock_flags);\r\nlist_for_each_safe(listHead, placeHolder, list) {\r\ntx_q_item = list_entry(listHead, tx_buffered_packets_t, q);\r\nif(!tx_q_item) {\r\nunifi_error(priv, "Entry should exist, otherwise it is a (BUG)\n");\r\ncontinue;\r\n}\r\nif (!(tx_q_item->transmissionControl & CSR_NO_CONFIRM_REQUIRED) &&\r\n(tx_q_item->leSenderProcessId != priv->netdev_client->sender_id)){\r\nunifi_trace(priv, UDBG1, "%s: SenderProcessID=%x host tag=%x transmission control=%x\n",\r\n__FUNCTION__,\r\ntx_q_item->leSenderProcessId,\r\ntx_q_item->hostTag,\r\ntx_q_item->transmissionControl);\r\nadd_to_send_cfm_list(priv, tx_q_item, frames_need_cfm_list);\r\n}\r\n}\r\nspin_unlock_irqrestore(&priv->tx_q_lock,lock_flags);\r\n}\r\nvoid uf_flush_list(unifi_priv_t * priv, struct list_head * list)\r\n{\r\ntx_buffered_packets_t *tx_q_item;\r\nstruct list_head *listHead;\r\nstruct list_head *placeHolder;\r\nunsigned long lock_flags;\r\nunifi_trace(priv, UDBG5, "entering the uf_flush_list \n");\r\nspin_lock_irqsave(&priv->tx_q_lock,lock_flags);\r\nlist_for_each_safe(listHead, placeHolder, list) {\r\ntx_q_item = list_entry(listHead, tx_buffered_packets_t, q);\r\nif(!tx_q_item) {\r\nunifi_error(priv, "entry should exists, otherwise crashes (bug)\n");\r\n}\r\nunifi_trace(priv, UDBG5,\r\n"proccess_tx: in uf_flush_list peerMacAddress=%02X%02X%02X%02X%02X%02X senderProcessId=%x\n",\r\ntx_q_item->peerMacAddress.a[0], tx_q_item->peerMacAddress.a[1],\r\ntx_q_item->peerMacAddress.a[2], tx_q_item->peerMacAddress.a[3],\r\ntx_q_item->peerMacAddress.a[4], tx_q_item->peerMacAddress.a[5],\r\ntx_q_item->leSenderProcessId);\r\nlist_del(listHead);\r\nunifi_net_data_free(priv, &tx_q_item->bulkdata);\r\nkfree(tx_q_item);\r\ntx_q_item = NULL;\r\nif (!priv->noOfPktQueuedInDriver) {\r\nunifi_error(priv, "packets queued in driver 0 still decrementing in %s\n", __FUNCTION__);\r\n} else {\r\npriv->noOfPktQueuedInDriver--;\r\n}\r\n}\r\nspin_unlock_irqrestore(&priv->tx_q_lock,lock_flags);\r\n}\r\ntx_buffered_packets_t *dequeue_tx_data_pdu(unifi_priv_t *priv, struct list_head *txList)\r\n{\r\ntx_buffered_packets_t *tx_q_item = NULL;\r\nstruct list_head *listHead;\r\nstruct list_head *placeHolder;\r\nunsigned long lock_flags;\r\nunifi_trace(priv, UDBG5, "entering dequeue_tx_data_pdu\n");\r\nif (list_empty(txList)) {\r\nunifi_trace(priv, UDBG5, "In dequeue_tx_data_pdu, the list is empty\n");\r\nreturn NULL;\r\n}\r\nif (priv->noOfPktQueuedInDriver == 0xFFFF) {\r\nunifi_warning(priv, "no packet available in queue: debug");\r\nreturn NULL;\r\n}\r\nspin_lock_irqsave(&priv->tx_q_lock,lock_flags);\r\nlist_for_each_safe(listHead, placeHolder, txList) {\r\ntx_q_item = list_entry(listHead, tx_buffered_packets_t, q);\r\nlist_del(listHead);\r\nbreak;\r\n}\r\nspin_unlock_irqrestore(&priv->tx_q_lock,lock_flags);\r\nif (tx_q_item) {\r\nunifi_trace(priv, UDBG5,\r\n"proccess_tx: In dequeue_tx_data_pdu peerMacAddress=%02X%02X%02X%02X%02X%02X senderProcessId=%x\n",\r\ntx_q_item->peerMacAddress.a[0], tx_q_item->peerMacAddress.a[1],\r\ntx_q_item->peerMacAddress.a[2], tx_q_item->peerMacAddress.a[3],\r\ntx_q_item->peerMacAddress.a[4], tx_q_item->peerMacAddress.a[5],\r\ntx_q_item->leSenderProcessId);\r\n}\r\nunifi_trace(priv, UDBG5, "leaving dequeue_tx_data_pdu\n");\r\nreturn tx_q_item;\r\n}\r\nCsrWifiRouterCtrlStaInfo_t *CsrWifiRouterCtrlGetStationRecordFromPeerMacAddress(unifi_priv_t *priv,\r\nconst u8 *peerMacAddress,\r\nu16 interfaceTag)\r\n{\r\nu8 i;\r\nnetInterface_priv_t *interfacePriv;\r\nunsigned long lock_flags;\r\nif (interfaceTag >= CSR_WIFI_NUM_INTERFACES) {\r\nunifi_error(priv, "interfaceTag is not proper, interfaceTag = %d\n", interfaceTag);\r\nreturn NULL;\r\n}\r\ninterfacePriv = priv->interfacePriv[interfaceTag];\r\nspin_lock_irqsave(&priv->staRecord_lock,lock_flags);\r\nfor (i = 0; i < UNIFI_MAX_CONNECTIONS; i++) {\r\nif (interfacePriv->staInfo[i]!= NULL) {\r\nif (!memcmp(((CsrWifiRouterCtrlStaInfo_t *) (interfacePriv->staInfo[i]))->peerMacAddress.a, peerMacAddress, ETH_ALEN)) {\r\nspin_unlock_irqrestore(&priv->staRecord_lock,lock_flags);\r\nunifi_trace(priv, UDBG5, "peer entry found in station record\n");\r\nreturn ((CsrWifiRouterCtrlStaInfo_t *) (interfacePriv->staInfo[i]));\r\n}\r\n}\r\n}\r\nspin_unlock_irqrestore(&priv->staRecord_lock,lock_flags);\r\nunifi_trace(priv, UDBG5, "peer entry not found in station record\n");\r\nreturn NULL;\r\n}\r\nCsrWifiRouterCtrlStaInfo_t * CsrWifiRouterCtrlGetStationRecordFromHandle(unifi_priv_t *priv,\r\nu32 handle,\r\nu16 interfaceTag)\r\n{\r\nnetInterface_priv_t *interfacePriv;\r\nif ((handle >= UNIFI_MAX_CONNECTIONS) || (interfaceTag >= CSR_WIFI_NUM_INTERFACES)) {\r\nunifi_error(priv, "handle/interfaceTag is not proper, handle = %d, interfaceTag = %d\n", handle, interfaceTag);\r\nreturn NULL;\r\n}\r\ninterfacePriv = priv->interfacePriv[interfaceTag];\r\nreturn ((CsrWifiRouterCtrlStaInfo_t *) (interfacePriv->staInfo[handle]));\r\n}\r\nvoid uf_check_inactivity(unifi_priv_t *priv, u16 interfaceTag, u32 currentTime)\r\n{\r\nu32 i;\r\nCsrWifiRouterCtrlStaInfo_t *staInfo;\r\nu32 elapsedTime;\r\nnetInterface_priv_t *interfacePriv = priv->interfacePriv[interfaceTag];\r\nCsrWifiMacAddress peerMacAddress;\r\nunsigned long lock_flags;\r\nif (interfacePriv == NULL) {\r\nunifi_trace(priv, UDBG3, "uf_check_inactivity: Interface priv is NULL \n");\r\nreturn;\r\n}\r\nspin_lock_irqsave(&priv->staRecord_lock,lock_flags);\r\nfor(i = 0; i < UNIFI_MAX_CONNECTIONS; i++) {\r\nstaInfo = CsrWifiRouterCtrlGetStationRecordFromHandle(priv, i, interfaceTag);\r\nif(!staInfo ) {\r\ncontinue;\r\n}\r\nunifi_trace(priv, UDBG3, "Running Inactivity handler Time %xus station's last activity %xus\n",\r\ncurrentTime, staInfo->lastActivity);\r\nelapsedTime = (currentTime >= staInfo->lastActivity)?\r\n(currentTime - staInfo->lastActivity):\r\n(~((u32)0) - staInfo->lastActivity + currentTime);\r\nspin_unlock_irqrestore(&priv->staRecord_lock,lock_flags);\r\nif (elapsedTime > MAX_INACTIVITY_INTERVAL) {\r\nmemcpy((u8*)&peerMacAddress, (u8*)&staInfo->peerMacAddress, sizeof(CsrWifiMacAddress));\r\nunifi_trace(priv, UDBG3, "Station %x:%x:%x:%x:%x:%x inactive since %xus\n sending Inactive Ind\n",\r\npeerMacAddress.a[0], peerMacAddress.a[1],\r\npeerMacAddress.a[2], peerMacAddress.a[3],\r\npeerMacAddress.a[4], peerMacAddress.a[5],\r\nelapsedTime);\r\nCsrWifiRouterCtrlStaInactiveIndSend(priv->CSR_WIFI_SME_IFACEQUEUE, 0, interfaceTag, peerMacAddress);\r\n}\r\n}\r\ninterfacePriv->last_inactivity_check = currentTime;\r\n}\r\nvoid uf_update_sta_activity(unifi_priv_t *priv, u16 interfaceTag, const u8 *peerMacAddress)\r\n{\r\nu32 elapsedTime, currentTime;\r\nu32 timeHi;\r\nCsrWifiRouterCtrlStaInfo_t *staInfo;\r\nnetInterface_priv_t *interfacePriv = priv->interfacePriv[interfaceTag];\r\nunsigned long lock_flags;\r\nif (interfacePriv == NULL) {\r\nunifi_trace(priv, UDBG3, "uf_check_inactivity: Interface priv is NULL \n");\r\nreturn;\r\n}\r\ncurrentTime = CsrTimeGet(&timeHi);\r\nstaInfo = CsrWifiRouterCtrlGetStationRecordFromPeerMacAddress(priv, peerMacAddress, interfaceTag);\r\nif (staInfo == NULL) {\r\nunifi_trace(priv, UDBG4, "Sta does not exist yet");\r\nreturn;\r\n}\r\nspin_lock_irqsave(&priv->staRecord_lock,lock_flags);\r\nstaInfo->lastActivity = currentTime;\r\nelapsedTime = (currentTime >= interfacePriv->last_inactivity_check)?\r\n(currentTime - interfacePriv->last_inactivity_check):\r\n(~((u32)0) - interfacePriv->last_inactivity_check + currentTime);\r\nspin_unlock_irqrestore(&priv->staRecord_lock,lock_flags);\r\nif (elapsedTime > INACTIVITY_CHECK_INTERVAL) {\r\nuf_check_inactivity(priv, interfaceTag, currentTime);\r\n}\r\n}\r\nvoid resume_unicast_buffered_frames(unifi_priv_t *priv, u16 interfaceTag)\r\n{\r\nnetInterface_priv_t *interfacePriv = priv->interfacePriv[interfaceTag];\r\nu8 i;\r\nint j;\r\ntx_buffered_packets_t * buffered_pkt = NULL;\r\nu8 hipslotFree[4] = {TRUE,TRUE,TRUE,TRUE};\r\nint r;\r\nunsigned long lock_flags;\r\nwhile(!isRouterBufferEnabled(priv,3) &&\r\n((buffered_pkt=dequeue_tx_data_pdu(priv,&interfacePriv->genericMgtFrames))!=NULL)) {\r\nbuffered_pkt->transmissionControl &=\r\n~(TRANSMISSION_CONTROL_TRIGGER_MASK|TRANSMISSION_CONTROL_EOSP_MASK);\r\nif((r=frame_and_send_queued_pdu(priv,buffered_pkt,NULL,0,FALSE)) == -ENOSPC) {\r\nspin_lock_irqsave(&priv->tx_q_lock,lock_flags);\r\nlist_add(&buffered_pkt->q, &interfacePriv->genericMgtFrames);\r\nspin_unlock_irqrestore(&priv->tx_q_lock,lock_flags);\r\nhipslotFree[3]=FALSE;\r\nbreak;\r\n}else {\r\nif(r){\r\nunifi_trace (priv, UDBG1, " HIP validation failure : PDU sending failed \n");\r\nunifi_net_data_free(priv, &buffered_pkt->bulkdata);\r\n}\r\nkfree(buffered_pkt);\r\n}\r\n}\r\nfor(i = 0; i < UNIFI_MAX_CONNECTIONS; i++) {\r\nCsrWifiRouterCtrlStaInfo_t *staInfo = interfacePriv->staInfo[i];\r\nif(!hipslotFree[0] && !hipslotFree[1] && !hipslotFree[2] && !hipslotFree[3]) {\r\nunifi_trace(priv, UDBG3, "(ENOSPC) in resume_unicast_buffered_frames:: hip slots are full \n");\r\nbreak;\r\n}\r\nif (staInfo && (staInfo->currentPeerState == CSR_WIFI_ROUTER_CTRL_PEER_CONNECTED_ACTIVE)) {\r\nwhile((( TRUE == hipslotFree[3] ) && (buffered_pkt=dequeue_tx_data_pdu(priv, &staInfo->mgtFrames)))) {\r\nbuffered_pkt->transmissionControl &=\r\n~(TRANSMISSION_CONTROL_TRIGGER_MASK|TRANSMISSION_CONTROL_EOSP_MASK);\r\nif((r=frame_and_send_queued_pdu(priv,buffered_pkt,staInfo,0,FALSE)) == -ENOSPC) {\r\nunifi_trace(priv, UDBG3, "(ENOSPC) in resume_unicast_buffered_frames:: hip slots are full for voice queue\n");\r\nspin_lock_irqsave(&priv->tx_q_lock,lock_flags);\r\nlist_add(&buffered_pkt->q, &staInfo->mgtFrames);\r\nspin_unlock_irqrestore(&priv->tx_q_lock,lock_flags);\r\npriv->pausedStaHandle[3]=(u8)(staInfo->assignedHandle);\r\nhipslotFree[3] = FALSE;\r\nbreak;\r\n} else {\r\nif(r){\r\nunifi_trace (priv, UDBG1, " HIP validation failure : PDU sending failed \n");\r\nunifi_net_data_free(priv, &buffered_pkt->bulkdata);\r\n}\r\nkfree(buffered_pkt);\r\n}\r\n}\r\nfor(j=3;j>=0;j--) {\r\nif(!hipslotFree[j])\r\ncontinue;\r\nwhile((buffered_pkt=dequeue_tx_data_pdu(priv, &staInfo->dataPdu[j]))) {\r\nbuffered_pkt->transmissionControl &=\r\n~(TRANSMISSION_CONTROL_TRIGGER_MASK|TRANSMISSION_CONTROL_EOSP_MASK);\r\nif((r=frame_and_send_queued_pdu(priv,buffered_pkt,staInfo,0,FALSE)) == -ENOSPC) {\r\nspin_lock_irqsave(&priv->tx_q_lock,lock_flags);\r\nlist_add(&buffered_pkt->q, &staInfo->dataPdu[j]);\r\nspin_unlock_irqrestore(&priv->tx_q_lock,lock_flags);\r\npriv->pausedStaHandle[j]=(u8)(staInfo->assignedHandle);\r\nhipslotFree[j]=FALSE;\r\nbreak;\r\n} else {\r\nif(r){\r\nunifi_trace (priv, UDBG1, " HIP validation failure : PDU sending failed \n");\r\nunifi_net_data_free(priv, &buffered_pkt->bulkdata);\r\n}\r\nkfree(buffered_pkt);\r\n}\r\n}\r\n}\r\n}\r\n}\r\n}\r\nvoid update_eosp_to_head_of_broadcast_list_head(unifi_priv_t *priv,u16 interfaceTag)\r\n{\r\nnetInterface_priv_t *interfacePriv = priv->interfacePriv[interfaceTag];\r\nunsigned long lock_flags;\r\nstruct list_head *listHead;\r\nstruct list_head *placeHolder;\r\ntx_buffered_packets_t *tx_q_item;\r\nif (interfacePriv->noOfbroadcastPktQueued) {\r\nspin_lock_irqsave(&priv->tx_q_lock,lock_flags);\r\nlist_for_each_safe(listHead, placeHolder, &interfacePriv->genericMulticastOrBroadCastFrames) {\r\ntx_q_item = list_entry(listHead, tx_buffered_packets_t, q);\r\ntx_q_item->transmissionControl |= TRANSMISSION_CONTROL_EOSP_MASK;\r\ntx_q_item->transmissionControl = (tx_q_item->transmissionControl & ~(CSR_NO_CONFIRM_REQUIRED));\r\nunifi_trace(priv, UDBG1,"updating eosp for list Head hostTag:= 0x%x ",tx_q_item->hostTag);\r\nbreak;\r\n}\r\nspin_unlock_irqrestore(&priv->tx_q_lock,lock_flags);\r\n}\r\n}\r\nvoid resume_suspended_uapsd(unifi_priv_t* priv,u16 interfaceTag)\r\n{\r\nu8 startIndex;\r\nCsrWifiRouterCtrlStaInfo_t * staInfo = NULL;\r\nunsigned long lock_flags;\r\nunifi_trace(priv, UDBG2, "++resume_suspended_uapsd: \n");\r\nfor(startIndex= 0; startIndex < UNIFI_MAX_CONNECTIONS;startIndex++) {\r\nstaInfo = CsrWifiRouterCtrlGetStationRecordFromHandle(priv,startIndex,interfaceTag);\r\nif(!staInfo || !staInfo->wmmOrQosEnabled) {\r\ncontinue;\r\n} else if((staInfo->currentPeerState == CSR_WIFI_ROUTER_CTRL_PEER_CONNECTED_POWER_SAVE)\r\n&&staInfo->uapsdActive && staInfo->uspSuspend) {\r\nuf_handle_uspframes_delivery(priv, staInfo, interfaceTag);\r\n} else {\r\nunifi_trace(priv, UDBG2, "resume_suspended_uapsd: PS state=%x, uapsdActive?=%x, suspend?=%x\n",\r\nstaInfo->currentPeerState, staInfo->uapsdActive, staInfo->uspSuspend);\r\nif (staInfo->currentPeerState == CSR_WIFI_ROUTER_CTRL_PEER_CONNECTED_ACTIVE)\r\n{\r\nspin_lock_irqsave(&priv->staRecord_lock,lock_flags);\r\nstaInfo->uapsdActive = FALSE;\r\nstaInfo->uspSuspend = FALSE;\r\nspin_unlock_irqrestore(&priv->staRecord_lock,lock_flags);\r\n}\r\n}\r\n}\r\nunifi_trace(priv, UDBG2, "--resume_suspended_uapsd:\n");\r\n}
