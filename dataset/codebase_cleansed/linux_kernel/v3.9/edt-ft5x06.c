static int edt_ft5x06_ts_readwrite(struct i2c_client *client,\r\nu16 wr_len, u8 *wr_buf,\r\nu16 rd_len, u8 *rd_buf)\r\n{\r\nstruct i2c_msg wrmsg[2];\r\nint i = 0;\r\nint ret;\r\nif (wr_len) {\r\nwrmsg[i].addr = client->addr;\r\nwrmsg[i].flags = 0;\r\nwrmsg[i].len = wr_len;\r\nwrmsg[i].buf = wr_buf;\r\ni++;\r\n}\r\nif (rd_len) {\r\nwrmsg[i].addr = client->addr;\r\nwrmsg[i].flags = I2C_M_RD;\r\nwrmsg[i].len = rd_len;\r\nwrmsg[i].buf = rd_buf;\r\ni++;\r\n}\r\nret = i2c_transfer(client->adapter, wrmsg, i);\r\nif (ret < 0)\r\nreturn ret;\r\nif (ret != i)\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nstatic bool edt_ft5x06_ts_check_crc(struct edt_ft5x06_ts_data *tsdata,\r\nu8 *buf, int buflen)\r\n{\r\nint i;\r\nu8 crc = 0;\r\nfor (i = 0; i < buflen - 1; i++)\r\ncrc ^= buf[i];\r\nif (crc != buf[buflen-1]) {\r\ndev_err_ratelimited(&tsdata->client->dev,\r\n"crc error: 0x%02x expected, got 0x%02x\n",\r\ncrc, buf[buflen-1]);\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\nstatic irqreturn_t edt_ft5x06_ts_isr(int irq, void *dev_id)\r\n{\r\nstruct edt_ft5x06_ts_data *tsdata = dev_id;\r\nstruct device *dev = &tsdata->client->dev;\r\nu8 cmd = 0xf9;\r\nu8 rdbuf[26];\r\nint i, type, x, y, id;\r\nint error;\r\nmemset(rdbuf, 0, sizeof(rdbuf));\r\nerror = edt_ft5x06_ts_readwrite(tsdata->client,\r\nsizeof(cmd), &cmd,\r\nsizeof(rdbuf), rdbuf);\r\nif (error) {\r\ndev_err_ratelimited(dev, "Unable to fetch data, error: %d\n",\r\nerror);\r\ngoto out;\r\n}\r\nif (rdbuf[0] != 0xaa || rdbuf[1] != 0xaa || rdbuf[2] != 26) {\r\ndev_err_ratelimited(dev, "Unexpected header: %02x%02x%02x!\n",\r\nrdbuf[0], rdbuf[1], rdbuf[2]);\r\ngoto out;\r\n}\r\nif (!edt_ft5x06_ts_check_crc(tsdata, rdbuf, 26))\r\ngoto out;\r\nfor (i = 0; i < MAX_SUPPORT_POINTS; i++) {\r\nu8 *buf = &rdbuf[i * 4 + 5];\r\nbool down;\r\ntype = buf[0] >> 6;\r\nif (type == TOUCH_EVENT_RESERVED)\r\ncontinue;\r\nx = ((buf[0] << 8) | buf[1]) & 0x0fff;\r\ny = ((buf[2] << 8) | buf[3]) & 0x0fff;\r\nid = (buf[2] >> 4) & 0x0f;\r\ndown = (type != TOUCH_EVENT_UP);\r\ninput_mt_slot(tsdata->input, id);\r\ninput_mt_report_slot_state(tsdata->input, MT_TOOL_FINGER, down);\r\nif (!down)\r\ncontinue;\r\ninput_report_abs(tsdata->input, ABS_MT_POSITION_X, x);\r\ninput_report_abs(tsdata->input, ABS_MT_POSITION_Y, y);\r\n}\r\ninput_mt_report_pointer_emulation(tsdata->input, true);\r\ninput_sync(tsdata->input);\r\nout:\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int edt_ft5x06_register_write(struct edt_ft5x06_ts_data *tsdata,\r\nu8 addr, u8 value)\r\n{\r\nu8 wrbuf[4];\r\nwrbuf[0] = tsdata->factory_mode ? 0xf3 : 0xfc;\r\nwrbuf[1] = tsdata->factory_mode ? addr & 0x7f : addr & 0x3f;\r\nwrbuf[2] = value;\r\nwrbuf[3] = wrbuf[0] ^ wrbuf[1] ^ wrbuf[2];\r\nreturn edt_ft5x06_ts_readwrite(tsdata->client, 4, wrbuf, 0, NULL);\r\n}\r\nstatic int edt_ft5x06_register_read(struct edt_ft5x06_ts_data *tsdata,\r\nu8 addr)\r\n{\r\nu8 wrbuf[2], rdbuf[2];\r\nint error;\r\nwrbuf[0] = tsdata->factory_mode ? 0xf3 : 0xfc;\r\nwrbuf[1] = tsdata->factory_mode ? addr & 0x7f : addr & 0x3f;\r\nwrbuf[1] |= tsdata->factory_mode ? 0x80 : 0x40;\r\nerror = edt_ft5x06_ts_readwrite(tsdata->client, 2, wrbuf, 2, rdbuf);\r\nif (error)\r\nreturn error;\r\nif ((wrbuf[0] ^ wrbuf[1] ^ rdbuf[0]) != rdbuf[1]) {\r\ndev_err(&tsdata->client->dev,\r\n"crc error: 0x%02x expected, got 0x%02x\n",\r\nwrbuf[0] ^ wrbuf[1] ^ rdbuf[0], rdbuf[1]);\r\nreturn -EIO;\r\n}\r\nreturn rdbuf[0];\r\n}\r\nstatic ssize_t edt_ft5x06_setting_show(struct device *dev,\r\nstruct device_attribute *dattr,\r\nchar *buf)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct edt_ft5x06_ts_data *tsdata = i2c_get_clientdata(client);\r\nstruct edt_ft5x06_attribute *attr =\r\ncontainer_of(dattr, struct edt_ft5x06_attribute, dattr);\r\nu8 *field = (u8 *)((char *)tsdata + attr->field_offset);\r\nint val;\r\nsize_t count = 0;\r\nint error = 0;\r\nmutex_lock(&tsdata->mutex);\r\nif (tsdata->factory_mode) {\r\nerror = -EIO;\r\ngoto out;\r\n}\r\nval = edt_ft5x06_register_read(tsdata, attr->addr);\r\nif (val < 0) {\r\nerror = val;\r\ndev_err(&tsdata->client->dev,\r\n"Failed to fetch attribute %s, error %d\n",\r\ndattr->attr.name, error);\r\ngoto out;\r\n}\r\nif (val != *field) {\r\ndev_warn(&tsdata->client->dev,\r\n"%s: read (%d) and stored value (%d) differ\n",\r\ndattr->attr.name, val, *field);\r\n*field = val;\r\n}\r\ncount = scnprintf(buf, PAGE_SIZE, "%d\n", val);\r\nout:\r\nmutex_unlock(&tsdata->mutex);\r\nreturn error ?: count;\r\n}\r\nstatic ssize_t edt_ft5x06_setting_store(struct device *dev,\r\nstruct device_attribute *dattr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct edt_ft5x06_ts_data *tsdata = i2c_get_clientdata(client);\r\nstruct edt_ft5x06_attribute *attr =\r\ncontainer_of(dattr, struct edt_ft5x06_attribute, dattr);\r\nu8 *field = (u8 *)((char *)tsdata + attr->field_offset);\r\nunsigned int val;\r\nint error;\r\nmutex_lock(&tsdata->mutex);\r\nif (tsdata->factory_mode) {\r\nerror = -EIO;\r\ngoto out;\r\n}\r\nerror = kstrtouint(buf, 0, &val);\r\nif (error)\r\ngoto out;\r\nif (val < attr->limit_low || val > attr->limit_high) {\r\nerror = -ERANGE;\r\ngoto out;\r\n}\r\nerror = edt_ft5x06_register_write(tsdata, attr->addr, val);\r\nif (error) {\r\ndev_err(&tsdata->client->dev,\r\n"Failed to update attribute %s, error: %d\n",\r\ndattr->attr.name, error);\r\ngoto out;\r\n}\r\n*field = val;\r\nout:\r\nmutex_unlock(&tsdata->mutex);\r\nreturn error ?: count;\r\n}\r\nstatic int edt_ft5x06_factory_mode(struct edt_ft5x06_ts_data *tsdata)\r\n{\r\nstruct i2c_client *client = tsdata->client;\r\nint retries = EDT_SWITCH_MODE_RETRIES;\r\nint ret;\r\nint error;\r\ndisable_irq(client->irq);\r\nif (!tsdata->raw_buffer) {\r\ntsdata->raw_bufsize = tsdata->num_x * tsdata->num_y *\r\nsizeof(u16);\r\ntsdata->raw_buffer = kzalloc(tsdata->raw_bufsize, GFP_KERNEL);\r\nif (!tsdata->raw_buffer) {\r\nerror = -ENOMEM;\r\ngoto err_out;\r\n}\r\n}\r\nerror = edt_ft5x06_register_write(tsdata, WORK_REGISTER_OPMODE, 0x03);\r\nif (error) {\r\ndev_err(&client->dev,\r\n"failed to switch to factory mode, error %d\n", error);\r\ngoto err_out;\r\n}\r\ntsdata->factory_mode = true;\r\ndo {\r\nmdelay(EDT_SWITCH_MODE_DELAY);\r\nret = edt_ft5x06_register_read(tsdata, FACTORY_REGISTER_OPMODE);\r\nif (ret == 0x03)\r\nbreak;\r\n} while (--retries > 0);\r\nif (retries == 0) {\r\ndev_err(&client->dev, "not in factory mode after %dms.\n",\r\nEDT_SWITCH_MODE_RETRIES * EDT_SWITCH_MODE_DELAY);\r\nerror = -EIO;\r\ngoto err_out;\r\n}\r\nreturn 0;\r\nerr_out:\r\nkfree(tsdata->raw_buffer);\r\ntsdata->raw_buffer = NULL;\r\ntsdata->factory_mode = false;\r\nenable_irq(client->irq);\r\nreturn error;\r\n}\r\nstatic int edt_ft5x06_work_mode(struct edt_ft5x06_ts_data *tsdata)\r\n{\r\nstruct i2c_client *client = tsdata->client;\r\nint retries = EDT_SWITCH_MODE_RETRIES;\r\nint ret;\r\nint error;\r\nerror = edt_ft5x06_register_write(tsdata, FACTORY_REGISTER_OPMODE, 0x1);\r\nif (error) {\r\ndev_err(&client->dev,\r\n"failed to switch to work mode, error: %d\n", error);\r\nreturn error;\r\n}\r\ntsdata->factory_mode = false;\r\ndo {\r\nmdelay(EDT_SWITCH_MODE_DELAY);\r\nret = edt_ft5x06_register_read(tsdata, WORK_REGISTER_OPMODE);\r\nif (ret == 0x01)\r\nbreak;\r\n} while (--retries > 0);\r\nif (retries == 0) {\r\ndev_err(&client->dev, "not in work mode after %dms.\n",\r\nEDT_SWITCH_MODE_RETRIES * EDT_SWITCH_MODE_DELAY);\r\ntsdata->factory_mode = true;\r\nreturn -EIO;\r\n}\r\nif (tsdata->raw_buffer)\r\nkfree(tsdata->raw_buffer);\r\ntsdata->raw_buffer = NULL;\r\nedt_ft5x06_register_write(tsdata, WORK_REGISTER_THRESHOLD,\r\ntsdata->threshold);\r\nedt_ft5x06_register_write(tsdata, WORK_REGISTER_GAIN,\r\ntsdata->gain);\r\nedt_ft5x06_register_write(tsdata, WORK_REGISTER_OFFSET,\r\ntsdata->offset);\r\nedt_ft5x06_register_write(tsdata, WORK_REGISTER_REPORT_RATE,\r\ntsdata->report_rate);\r\nenable_irq(client->irq);\r\nreturn 0;\r\n}\r\nstatic int edt_ft5x06_debugfs_mode_get(void *data, u64 *mode)\r\n{\r\nstruct edt_ft5x06_ts_data *tsdata = data;\r\n*mode = tsdata->factory_mode;\r\nreturn 0;\r\n}\r\nstatic int edt_ft5x06_debugfs_mode_set(void *data, u64 mode)\r\n{\r\nstruct edt_ft5x06_ts_data *tsdata = data;\r\nint retval = 0;\r\nif (mode > 1)\r\nreturn -ERANGE;\r\nmutex_lock(&tsdata->mutex);\r\nif (mode != tsdata->factory_mode) {\r\nretval = mode ? edt_ft5x06_factory_mode(tsdata) :\r\nedt_ft5x06_work_mode(tsdata);\r\n}\r\nmutex_unlock(&tsdata->mutex);\r\nreturn retval;\r\n}\r\nstatic ssize_t edt_ft5x06_debugfs_raw_data_read(struct file *file,\r\nchar __user *buf, size_t count, loff_t *off)\r\n{\r\nstruct edt_ft5x06_ts_data *tsdata = file->private_data;\r\nstruct i2c_client *client = tsdata->client;\r\nint retries = EDT_RAW_DATA_RETRIES;\r\nint val, i, error;\r\nsize_t read = 0;\r\nint colbytes;\r\nchar wrbuf[3];\r\nu8 *rdbuf;\r\nif (*off < 0 || *off >= tsdata->raw_bufsize)\r\nreturn 0;\r\nmutex_lock(&tsdata->mutex);\r\nif (!tsdata->factory_mode || !tsdata->raw_buffer) {\r\nerror = -EIO;\r\ngoto out;\r\n}\r\nerror = edt_ft5x06_register_write(tsdata, 0x08, 0x01);\r\nif (error) {\r\ndev_dbg(&client->dev,\r\n"failed to write 0x08 register, error %d\n", error);\r\ngoto out;\r\n}\r\ndo {\r\nmsleep(EDT_RAW_DATA_DELAY);\r\nval = edt_ft5x06_register_read(tsdata, 0x08);\r\nif (val < 1)\r\nbreak;\r\n} while (--retries > 0);\r\nif (val < 0) {\r\nerror = val;\r\ndev_dbg(&client->dev,\r\n"failed to read 0x08 register, error %d\n", error);\r\ngoto out;\r\n}\r\nif (retries == 0) {\r\ndev_dbg(&client->dev,\r\n"timed out waiting for register to settle\n");\r\nerror = -ETIMEDOUT;\r\ngoto out;\r\n}\r\nrdbuf = tsdata->raw_buffer;\r\ncolbytes = tsdata->num_y * sizeof(u16);\r\nwrbuf[0] = 0xf5;\r\nwrbuf[1] = 0x0e;\r\nfor (i = 0; i < tsdata->num_x; i++) {\r\nwrbuf[2] = i;\r\nerror = edt_ft5x06_ts_readwrite(tsdata->client,\r\nsizeof(wrbuf), wrbuf,\r\ncolbytes, rdbuf);\r\nif (error)\r\ngoto out;\r\nrdbuf += colbytes;\r\n}\r\nread = min_t(size_t, count, tsdata->raw_bufsize - *off);\r\nif (copy_to_user(buf, tsdata->raw_buffer + *off, read)) {\r\nerror = -EFAULT;\r\ngoto out;\r\n}\r\n*off += read;\r\nout:\r\nmutex_unlock(&tsdata->mutex);\r\nreturn error ?: read;\r\n}\r\nstatic void\r\nedt_ft5x06_ts_prepare_debugfs(struct edt_ft5x06_ts_data *tsdata,\r\nconst char *debugfs_name)\r\n{\r\ntsdata->debug_dir = debugfs_create_dir(debugfs_name, NULL);\r\nif (!tsdata->debug_dir)\r\nreturn;\r\ndebugfs_create_u16("num_x", S_IRUSR, tsdata->debug_dir, &tsdata->num_x);\r\ndebugfs_create_u16("num_y", S_IRUSR, tsdata->debug_dir, &tsdata->num_y);\r\ndebugfs_create_file("mode", S_IRUSR | S_IWUSR,\r\ntsdata->debug_dir, tsdata, &debugfs_mode_fops);\r\ndebugfs_create_file("raw_data", S_IRUSR,\r\ntsdata->debug_dir, tsdata, &debugfs_raw_data_fops);\r\n}\r\nstatic void\r\nedt_ft5x06_ts_teardown_debugfs(struct edt_ft5x06_ts_data *tsdata)\r\n{\r\nif (tsdata->debug_dir)\r\ndebugfs_remove_recursive(tsdata->debug_dir);\r\nkfree(tsdata->raw_buffer);\r\n}\r\nstatic inline void\r\nedt_ft5x06_ts_prepare_debugfs(struct edt_ft5x06_ts_data *tsdata,\r\nconst char *debugfs_name)\r\n{\r\n}\r\nstatic inline void\r\nedt_ft5x06_ts_teardown_debugfs(struct edt_ft5x06_ts_data *tsdata)\r\n{\r\n}\r\nstatic int edt_ft5x06_ts_reset(struct i2c_client *client,\r\nint reset_pin)\r\n{\r\nint error;\r\nif (gpio_is_valid(reset_pin)) {\r\nerror = gpio_request_one(reset_pin, GPIOF_OUT_INIT_LOW,\r\n"edt-ft5x06 reset");\r\nif (error) {\r\ndev_err(&client->dev,\r\n"Failed to request GPIO %d as reset pin, error %d\n",\r\nreset_pin, error);\r\nreturn error;\r\n}\r\nmdelay(50);\r\ngpio_set_value(reset_pin, 1);\r\nmdelay(100);\r\n}\r\nreturn 0;\r\n}\r\nstatic int edt_ft5x06_ts_identify(struct i2c_client *client,\r\nchar *model_name,\r\nchar *fw_version)\r\n{\r\nu8 rdbuf[EDT_NAME_LEN];\r\nchar *p;\r\nint error;\r\nerror = edt_ft5x06_ts_readwrite(client, 1, "\xbb",\r\nEDT_NAME_LEN - 1, rdbuf);\r\nif (error)\r\nreturn error;\r\nrdbuf[EDT_NAME_LEN - 1] = '\0';\r\nif (rdbuf[EDT_NAME_LEN - 2] == '$')\r\nrdbuf[EDT_NAME_LEN - 2] = '\0';\r\np = strchr(rdbuf, '*');\r\nif (p)\r\n*p++ = '\0';\r\nstrlcpy(model_name, rdbuf + 1, EDT_NAME_LEN);\r\nstrlcpy(fw_version, p ? p : "", EDT_NAME_LEN);\r\nreturn 0;\r\n}\r\nstatic void\r\nedt_ft5x06_ts_get_defaults(struct edt_ft5x06_ts_data *tsdata,\r\nconst struct edt_ft5x06_platform_data *pdata)\r\n{\r\nif (!pdata->use_parameters)\r\nreturn;\r\nEDT_ATTR_CHECKSET(threshold, WORK_REGISTER_THRESHOLD);\r\nEDT_ATTR_CHECKSET(gain, WORK_REGISTER_GAIN);\r\nEDT_ATTR_CHECKSET(offset, WORK_REGISTER_OFFSET);\r\nEDT_ATTR_CHECKSET(report_rate, WORK_REGISTER_REPORT_RATE);\r\n}\r\nstatic void\r\nedt_ft5x06_ts_get_parameters(struct edt_ft5x06_ts_data *tsdata)\r\n{\r\ntsdata->threshold = edt_ft5x06_register_read(tsdata,\r\nWORK_REGISTER_THRESHOLD);\r\ntsdata->gain = edt_ft5x06_register_read(tsdata, WORK_REGISTER_GAIN);\r\ntsdata->offset = edt_ft5x06_register_read(tsdata, WORK_REGISTER_OFFSET);\r\ntsdata->report_rate = edt_ft5x06_register_read(tsdata,\r\nWORK_REGISTER_REPORT_RATE);\r\ntsdata->num_x = edt_ft5x06_register_read(tsdata, WORK_REGISTER_NUM_X);\r\ntsdata->num_y = edt_ft5x06_register_read(tsdata, WORK_REGISTER_NUM_Y);\r\n}\r\nstatic int edt_ft5x06_ts_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nconst struct edt_ft5x06_platform_data *pdata =\r\nclient->dev.platform_data;\r\nstruct edt_ft5x06_ts_data *tsdata;\r\nstruct input_dev *input;\r\nint error;\r\nchar fw_version[EDT_NAME_LEN];\r\ndev_dbg(&client->dev, "probing for EDT FT5x06 I2C\n");\r\nif (!pdata) {\r\ndev_err(&client->dev, "no platform data?\n");\r\nreturn -EINVAL;\r\n}\r\nerror = edt_ft5x06_ts_reset(client, pdata->reset_pin);\r\nif (error)\r\nreturn error;\r\nif (gpio_is_valid(pdata->irq_pin)) {\r\nerror = gpio_request_one(pdata->irq_pin,\r\nGPIOF_IN, "edt-ft5x06 irq");\r\nif (error) {\r\ndev_err(&client->dev,\r\n"Failed to request GPIO %d, error %d\n",\r\npdata->irq_pin, error);\r\nreturn error;\r\n}\r\n}\r\ntsdata = kzalloc(sizeof(*tsdata), GFP_KERNEL);\r\ninput = input_allocate_device();\r\nif (!tsdata || !input) {\r\ndev_err(&client->dev, "failed to allocate driver data.\n");\r\nerror = -ENOMEM;\r\ngoto err_free_mem;\r\n}\r\nmutex_init(&tsdata->mutex);\r\ntsdata->client = client;\r\ntsdata->input = input;\r\ntsdata->factory_mode = false;\r\nerror = edt_ft5x06_ts_identify(client, tsdata->name, fw_version);\r\nif (error) {\r\ndev_err(&client->dev, "touchscreen probe failed\n");\r\ngoto err_free_mem;\r\n}\r\nedt_ft5x06_ts_get_defaults(tsdata, pdata);\r\nedt_ft5x06_ts_get_parameters(tsdata);\r\ndev_dbg(&client->dev,\r\n"Model \"%s\", Rev. \"%s\", %dx%d sensors\n",\r\ntsdata->name, fw_version, tsdata->num_x, tsdata->num_y);\r\ninput->name = tsdata->name;\r\ninput->id.bustype = BUS_I2C;\r\ninput->dev.parent = &client->dev;\r\n__set_bit(EV_SYN, input->evbit);\r\n__set_bit(EV_KEY, input->evbit);\r\n__set_bit(EV_ABS, input->evbit);\r\n__set_bit(BTN_TOUCH, input->keybit);\r\ninput_set_abs_params(input, ABS_X, 0, tsdata->num_x * 64 - 1, 0, 0);\r\ninput_set_abs_params(input, ABS_Y, 0, tsdata->num_y * 64 - 1, 0, 0);\r\ninput_set_abs_params(input, ABS_MT_POSITION_X,\r\n0, tsdata->num_x * 64 - 1, 0, 0);\r\ninput_set_abs_params(input, ABS_MT_POSITION_Y,\r\n0, tsdata->num_y * 64 - 1, 0, 0);\r\nerror = input_mt_init_slots(input, MAX_SUPPORT_POINTS, 0);\r\nif (error) {\r\ndev_err(&client->dev, "Unable to init MT slots.\n");\r\ngoto err_free_mem;\r\n}\r\ninput_set_drvdata(input, tsdata);\r\ni2c_set_clientdata(client, tsdata);\r\nerror = request_threaded_irq(client->irq, NULL, edt_ft5x06_ts_isr,\r\nIRQF_TRIGGER_FALLING | IRQF_ONESHOT,\r\nclient->name, tsdata);\r\nif (error) {\r\ndev_err(&client->dev, "Unable to request touchscreen IRQ.\n");\r\ngoto err_free_mem;\r\n}\r\nerror = sysfs_create_group(&client->dev.kobj, &edt_ft5x06_attr_group);\r\nif (error)\r\ngoto err_free_irq;\r\nerror = input_register_device(input);\r\nif (error)\r\ngoto err_remove_attrs;\r\nedt_ft5x06_ts_prepare_debugfs(tsdata, dev_driver_string(&client->dev));\r\ndevice_init_wakeup(&client->dev, 1);\r\ndev_dbg(&client->dev,\r\n"EDT FT5x06 initialized: IRQ pin %d, Reset pin %d.\n",\r\npdata->irq_pin, pdata->reset_pin);\r\nreturn 0;\r\nerr_remove_attrs:\r\nsysfs_remove_group(&client->dev.kobj, &edt_ft5x06_attr_group);\r\nerr_free_irq:\r\nfree_irq(client->irq, tsdata);\r\nerr_free_mem:\r\ninput_free_device(input);\r\nkfree(tsdata);\r\nif (gpio_is_valid(pdata->irq_pin))\r\ngpio_free(pdata->irq_pin);\r\nreturn error;\r\n}\r\nstatic int edt_ft5x06_ts_remove(struct i2c_client *client)\r\n{\r\nconst struct edt_ft5x06_platform_data *pdata =\r\ndev_get_platdata(&client->dev);\r\nstruct edt_ft5x06_ts_data *tsdata = i2c_get_clientdata(client);\r\nedt_ft5x06_ts_teardown_debugfs(tsdata);\r\nsysfs_remove_group(&client->dev.kobj, &edt_ft5x06_attr_group);\r\nfree_irq(client->irq, tsdata);\r\ninput_unregister_device(tsdata->input);\r\nif (gpio_is_valid(pdata->irq_pin))\r\ngpio_free(pdata->irq_pin);\r\nif (gpio_is_valid(pdata->reset_pin))\r\ngpio_free(pdata->reset_pin);\r\nkfree(tsdata);\r\nreturn 0;\r\n}\r\nstatic int edt_ft5x06_ts_suspend(struct device *dev)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nif (device_may_wakeup(dev))\r\nenable_irq_wake(client->irq);\r\nreturn 0;\r\n}\r\nstatic int edt_ft5x06_ts_resume(struct device *dev)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nif (device_may_wakeup(dev))\r\ndisable_irq_wake(client->irq);\r\nreturn 0;\r\n}
