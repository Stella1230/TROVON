static CsrResult _find_in_slut(card_t *card, symbol_t *psym, u32 *pslut)\r\n{\r\nu32 slut_address;\r\nu16 finger_print;\r\nCsrResult r;\r\nCsrResult csrResult;\r\nif (*pslut == 0xffffffff)\r\n{\r\nr = card_wait_for_firmware_to_start(card, &slut_address);\r\nif (r == CSR_WIFI_HIP_RESULT_NO_DEVICE)\r\n{\r\nreturn r;\r\n}\r\nif (r != CSR_RESULT_SUCCESS)\r\n{\r\nunifi_error(card->ospriv, "Firmware hasn't started\n");\r\nreturn r;\r\n}\r\n*pslut = slut_address;\r\ncsrResult = CsrSdioMaxBusClockFrequencySet(card->sdio_if, UNIFI_SDIO_CLOCK_INIT_HZ);\r\nif (csrResult != CSR_RESULT_SUCCESS)\r\n{\r\nr = ConvertCsrSdioToCsrHipResult(card, csrResult);\r\nreturn r;\r\n}\r\ncard->sdio_clock_speed = UNIFI_SDIO_CLOCK_INIT_HZ;\r\n}\r\nelse\r\n{\r\nslut_address = *pslut;\r\n}\r\nunifi_trace(card->ospriv, UDBG4, "SLUT addr: 0x%lX\n", slut_address);\r\nunifi_trace(card->ospriv, UDBG4, "Looking for SLUT finger print\n");\r\nfinger_print = 0;\r\nr = unifi_card_read16(card, slut_address, &finger_print);\r\nif (r == CSR_WIFI_HIP_RESULT_NO_DEVICE)\r\n{\r\nreturn r;\r\n}\r\nif (r != CSR_RESULT_SUCCESS)\r\n{\r\nunifi_error(card->ospriv, "Failed to read SLUT finger print\n");\r\nreturn r;\r\n}\r\nif (finger_print != SLUT_FINGERPRINT)\r\n{\r\nunifi_error(card->ospriv, "Failed to find SLUT fingerprint\n");\r\nreturn CSR_RESULT_FAILURE;\r\n}\r\nslut_address += 2;\r\nwhile (1)\r\n{\r\nu16 id;\r\nu32 obj;\r\nr = unifi_card_read16(card, slut_address, &id);\r\nif (r != CSR_RESULT_SUCCESS)\r\n{\r\nreturn r;\r\n}\r\nslut_address += 2;\r\nif (id == CSR_SLT_END)\r\n{\r\nr = CSR_WIFI_HIP_RESULT_RANGE;\r\nbreak;\r\n}\r\nr = unifi_read32(card, slut_address, &obj);\r\nif (r != CSR_RESULT_SUCCESS)\r\n{\r\nreturn r;\r\n}\r\nslut_address += 4;\r\nunifi_trace(card->ospriv, UDBG3, " found SLUT id %02d.%08lx\n", id, obj);\r\nr = CSR_WIFI_HIP_RESULT_NOT_FOUND;\r\nif (id == psym->id)\r\n{\r\nunifi_trace(card->ospriv, UDBG1, " matched SLUT id %02d.%08lx\n", id, obj);\r\npsym->obj = obj;\r\nr = CSR_RESULT_SUCCESS;\r\nbreak;\r\n}\r\n}\r\nreturn r;\r\n}\r\nstatic CsrResult do_patch_convert_download(card_t *card, void *dlpriv, xbv1_t *pfwinfo)\r\n{\r\nCsrResult r;\r\nu32 slut_base = 0xffffffff;\r\nvoid *pfw;\r\nu32 psize;\r\nsymbol_t sym;\r\nr = unifi_init(card);\r\nif (r != CSR_RESULT_SUCCESS)\r\n{\r\nunifi_error(card->ospriv,\r\n"do_patch_convert_download: failed to re-init UniFi\n");\r\nreturn r;\r\n}\r\nif (card->build_id == 0)\r\n{\r\nu32 ver = 0;\r\nsym.id = CSR_SLT_BUILD_ID_NUMBER;\r\nsym.obj = 0;\r\nunifi_trace(card->ospriv, UDBG1, "Need f/w version\n");\r\nr = _find_in_slut(card, &sym, &slut_base);\r\nif (r != CSR_RESULT_SUCCESS)\r\n{\r\nunifi_error(card->ospriv, "Failed to find CSR_SLT_BUILD_ID_NUMBER\n");\r\nreturn CSR_RESULT_FAILURE;\r\n}\r\nr = unifi_read32(card, sym.obj, &ver);\r\nif (r == CSR_WIFI_HIP_RESULT_NO_DEVICE)\r\n{\r\nreturn r;\r\n}\r\nif (r != CSR_RESULT_SUCCESS)\r\n{\r\nunifi_error(card->ospriv, "Failed to read f/w id\n");\r\nreturn CSR_RESULT_FAILURE;\r\n}\r\ncard->build_id = ver;\r\n}\r\npfw = xbv_to_patch(card, unifi_fw_read, dlpriv, pfwinfo, &psize);\r\nif (!pfw)\r\n{\r\nunifi_error(card->ospriv, "Failed to convert f/w to patch");\r\nreturn CSR_WIFI_HIP_RESULT_NO_MEMORY;\r\n}\r\nelse\r\n{\r\nvoid *desc;\r\nsym.id = CSR_SLT_BOOT_LOADER_CONTROL;\r\nsym.obj = 0;\r\nr = _find_in_slut(card, &sym, &slut_base);\r\nif (r != CSR_RESULT_SUCCESS)\r\n{\r\nunifi_error(card->ospriv, "Failed to find BOOT_LOADER_CONTROL\n");\r\nkfree(pfw);\r\nreturn CSR_RESULT_FAILURE;\r\n}\r\nr = unifi_set_host_state(card, UNIFI_HOST_STATE_AWAKE);\r\nif (r != CSR_RESULT_SUCCESS)\r\n{\r\nunifi_error(card->ospriv, "Failed to wake UniFi\n");\r\n}\r\ndesc = unifi_fw_open_buffer(card->ospriv, pfw, psize);\r\nif (!desc)\r\n{\r\nkfree(pfw);\r\nreturn CSR_WIFI_HIP_RESULT_NO_MEMORY;\r\n}\r\nunifi_info(card->ospriv, "Downloading converted f/w as patch\n");\r\nr = unifi_dl_patch(card, desc, sym.obj);\r\nkfree(pfw);\r\nunifi_fw_close_buffer(card->ospriv, desc);\r\nif (r != CSR_RESULT_SUCCESS)\r\n{\r\nunifi_error(card->ospriv, "Converted patch download failed\n");\r\nreturn r;\r\n}\r\nelse\r\n{\r\nunifi_trace(card->ospriv, UDBG1, "Converted patch downloaded\n");\r\n}\r\nr = unifi_do_loader_op(card, sym.obj + 6, UNIFI_BOOT_LOADER_RESTART);\r\nif (r != CSR_RESULT_SUCCESS)\r\n{\r\nunifi_error(card->ospriv, "Failed to write loader restart cmd\n");\r\n}\r\nreturn r;\r\n}\r\n}\r\nCsrResult unifi_dl_firmware(card_t *card, void *dlpriv)\r\n{\r\nxbv1_t *fwinfo;\r\nCsrResult r;\r\nfwinfo = kmalloc(sizeof(xbv1_t), GFP_KERNEL);\r\nif (fwinfo == NULL)\r\n{\r\nunifi_error(card->ospriv, "Failed to allocate memory for firmware\n");\r\nreturn CSR_WIFI_HIP_RESULT_NO_MEMORY;\r\n}\r\nr = xbv1_parse(card, unifi_fw_read, dlpriv, fwinfo);\r\nif (r != CSR_RESULT_SUCCESS || fwinfo->mode != xbv_firmware)\r\n{\r\nunifi_error(card->ospriv, "File type is %s, expected firmware.\n",\r\nfwinfo->mode == xbv_patch?"patch" : "unknown");\r\nkfree(fwinfo);\r\nreturn CSR_WIFI_HIP_RESULT_INVALID_VALUE;\r\n}\r\nif (card->chip_id > SDIO_CARD_ID_UNIFI_2)\r\n{\r\nunifi_info(card->ospriv, "Must convert f/w to patch format\n");\r\nr = do_patch_convert_download(card, dlpriv, fwinfo);\r\n}\r\nelse\r\n{\r\nunifi_error(card->ospriv, "Only patch downloading supported\n");\r\nr = CSR_WIFI_HIP_RESULT_INVALID_VALUE;\r\n}\r\nkfree(fwinfo);\r\nreturn r;\r\n}\r\nCsrResult unifi_dl_patch(card_t *card, void *dlpriv, u32 boot_ctrl)\r\n{\r\nxbv1_t *fwinfo;\r\nCsrResult r;\r\nunifi_info(card->ospriv, "unifi_dl_patch %p %08x\n", dlpriv, boot_ctrl);\r\nfwinfo = kmalloc(sizeof(xbv1_t), GFP_KERNEL);\r\nif (fwinfo == NULL)\r\n{\r\nunifi_error(card->ospriv, "Failed to allocate memory for patches\n");\r\nreturn CSR_WIFI_HIP_RESULT_NO_MEMORY;\r\n}\r\nr = xbv1_parse(card, unifi_fw_read, dlpriv, fwinfo);\r\nif (r != CSR_RESULT_SUCCESS || fwinfo->mode != xbv_patch)\r\n{\r\nkfree(fwinfo);\r\nunifi_error(card->ospriv, "Failed to read in patch file\n");\r\nreturn CSR_WIFI_HIP_RESULT_INVALID_VALUE;\r\n}\r\nif (card->build_id != fwinfo->build_id)\r\n{\r\nunifi_error(card->ospriv, "Wrong patch file for chip (chip = %lu, file = %lu)\n",\r\ncard->build_id, fwinfo->build_id);\r\nkfree(fwinfo);\r\n#ifndef CSR_WIFI_IGNORE_PATCH_VERSION_MISMATCH\r\nreturn CSR_WIFI_HIP_RESULT_INVALID_VALUE;\r\n#else\r\nfwinfo = NULL;\r\ndlpriv = NULL;\r\nreturn CSR_RESULT_SUCCESS;\r\n#endif\r\n}\r\nr = do_patch_download(card, dlpriv, fwinfo, boot_ctrl);\r\nif (r != CSR_RESULT_SUCCESS)\r\n{\r\nunifi_error(card->ospriv, "Failed to patch image\n");\r\n}\r\nkfree(fwinfo);\r\nreturn r;\r\n}\r\nvoid* unifi_dl_fw_read_start(card_t *card, s8 is_fw)\r\n{\r\ncard_info_t card_info;\r\nunifi_card_info(card, &card_info);\r\nunifi_trace(card->ospriv, UDBG5,\r\n"id=%d, ver=0x%x, fw_build=%u, fw_hip=0x%x, block_size=%d\n",\r\ncard_info.chip_id, card_info.chip_version,\r\ncard_info.fw_build, card_info.fw_hip_version,\r\ncard_info.sdio_block_size);\r\nreturn unifi_fw_read_start(card->ospriv, is_fw, &card_info);\r\n}\r\nstatic CsrResult safe_read_shared_location(card_t *card, u32 address, u8 *pdata)\r\n{\r\nCsrResult r;\r\nu16 limit = 1000;\r\nu8 b, b2;\r\n*pdata = 0;\r\nr = unifi_read_8_or_16(card, address, &b);\r\nif (r != CSR_RESULT_SUCCESS)\r\n{\r\nreturn r;\r\n}\r\nwhile (limit--)\r\n{\r\nr = unifi_read_8_or_16(card, address, &b2);\r\nif (r != CSR_RESULT_SUCCESS)\r\n{\r\nreturn r;\r\n}\r\nif (b == b2)\r\n{\r\n*pdata = b;\r\nreturn CSR_RESULT_SUCCESS;\r\n}\r\nb = b2;\r\n}\r\nreturn CSR_RESULT_FAILURE;\r\n}\r\nCsrResult unifi_do_loader_op(card_t *card, u32 op_addr, u8 opcode)\r\n{\r\nCsrResult r;\r\ns16 op_retries;\r\nunifi_trace(card->ospriv, UDBG4, "Loader cmd 0x%0x -> 0x%08x\n", opcode, op_addr);\r\nr = unifi_write_8_or_16(card, op_addr, opcode);\r\nif (r != CSR_RESULT_SUCCESS)\r\n{\r\nunifi_error(card->ospriv, "Failed to write loader copy command\n");\r\nreturn r;\r\n}\r\nop_retries = 0;\r\nr = CSR_RESULT_SUCCESS;\r\nwhile (1)\r\n{\r\nu8 op;\r\nr = safe_read_shared_location(card, op_addr, &op);\r\nif (r != CSR_RESULT_SUCCESS)\r\n{\r\nunifi_error(card->ospriv, "Failed to read loader status\n");\r\nbreak;\r\n}\r\nif (op == UNIFI_LOADER_IDLE)\r\n{\r\nbreak;\r\n}\r\nif (op != opcode)\r\n{\r\nunifi_error(card->ospriv, "Error reported by loader: 0x%X\n", op);\r\nr = CSR_RESULT_FAILURE;\r\nbreak;\r\n}\r\nif (++op_retries >= OPERATION_TIMEOUT_LOOPS)\r\n{\r\nunifi_error(card->ospriv, "Timeout waiting for loader to ack transfer\n");\r\nr = unifi_card_stop_processor(card, UNIFI_PROC_BOTH);\r\nif (r != CSR_RESULT_SUCCESS)\r\n{\r\nunifi_error(card->ospriv, "Failed to stop UniFi processors\n");\r\n}\r\nelse\r\n{\r\nr = CSR_RESULT_FAILURE;\r\n}\r\nbreak;\r\n}\r\nCsrThreadSleep(OPERATION_TIMEOUT_DELAY);\r\n}\r\nreturn r;\r\n}\r\nstatic CsrResult send_ptdl_to_unifi(card_t *card, void *dlpriv,\r\nconst struct PTDL *ptdl, u32 handle,\r\nu32 op_addr)\r\n{\r\nu32 offset;\r\nu8 *buf;\r\ns32 data_len;\r\nu32 write_len;\r\nCsrResult r;\r\nconst u16 buf_size = 2 * 1024;\r\noffset = ptdl->dl_offset;\r\ndata_len = ptdl->dl_size;\r\nif (data_len > buf_size)\r\n{\r\nunifi_error(card->ospriv, "PTDL block is too large (%u)\n",\r\nptdl->dl_size);\r\nreturn CSR_WIFI_HIP_RESULT_INVALID_VALUE;\r\n}\r\nbuf = kmalloc(buf_size, GFP_KERNEL);\r\nif (buf == NULL)\r\n{\r\nunifi_error(card->ospriv, "Failed to allocate transfer buffer for firmware download\n");\r\nreturn CSR_WIFI_HIP_RESULT_NO_MEMORY;\r\n}\r\nr = CSR_RESULT_SUCCESS;\r\nif (unifi_fw_read(card->ospriv, dlpriv, offset, buf, data_len) != data_len)\r\n{\r\nunifi_error(card->ospriv, "Failed to read from file\n");\r\n}\r\nelse\r\n{\r\nif (card->sdio_io_block_pad)\r\n{\r\nwrite_len = (data_len + (card->sdio_io_block_size - 1)) &\r\n~(card->sdio_io_block_size - 1);\r\nmemset(buf + data_len, 0, write_len - data_len);\r\n}\r\nelse\r\n{\r\nwrite_len = data_len;\r\n}\r\nr = unifi_bulk_rw_noretry(card, handle, buf, write_len, UNIFI_SDIO_WRITE);\r\nif (r != CSR_RESULT_SUCCESS)\r\n{\r\nunifi_error(card->ospriv, "CMD53 failed writing %d bytes to handle %ld\n",\r\ndata_len, handle);\r\n}\r\nelse\r\n{\r\nr = unifi_do_loader_op(card, op_addr, UNIFI_BOOT_LOADER_PATCH);\r\n}\r\n}\r\nkfree(buf);\r\nif (r != CSR_RESULT_SUCCESS && r != CSR_WIFI_HIP_RESULT_NO_DEVICE)\r\n{\r\nunifi_error(card->ospriv, "Failed to copy block of %u bytes to UniFi\n",\r\nptdl->dl_size);\r\n}\r\nreturn r;\r\n}\r\nstatic CsrResult do_patch_download(card_t *card, void *dlpriv, xbv1_t *pfwinfo, u32 boot_ctrl_addr)\r\n{\r\nCsrResult r;\r\ns32 i;\r\nu16 loader_version;\r\nu16 handle;\r\nu32 total_bytes;\r\nr = unifi_card_read16(card, boot_ctrl_addr, &loader_version);\r\nif (r != CSR_RESULT_SUCCESS)\r\n{\r\nunifi_error(card->ospriv, "Patch download: Failed to read loader version\n");\r\nreturn r;\r\n}\r\nunifi_trace(card->ospriv, UDBG2, "Patch download: boot loader version 0x%04X\n", loader_version);\r\nswitch (loader_version)\r\n{\r\ncase 0x0000:\r\nbreak;\r\ndefault:\r\nunifi_error(card->ospriv, "Patch loader version (0x%04X) is not supported by this driver\n",\r\nloader_version);\r\nreturn CSR_WIFI_HIP_RESULT_INVALID_VALUE;\r\n}\r\nr = unifi_card_read16(card, boot_ctrl_addr + 4, &handle);\r\nif (r != CSR_RESULT_SUCCESS)\r\n{\r\nunifi_error(card->ospriv, "Patch download: Failed to read loader handle\n");\r\nreturn r;\r\n}\r\nif (card->loader_led_mask)\r\n{\r\nr = unifi_card_write16(card, boot_ctrl_addr + 2,\r\n(u16)card->loader_led_mask);\r\nif (r != CSR_RESULT_SUCCESS)\r\n{\r\nunifi_error(card->ospriv, "Patch download: Failed to write LED mask\n");\r\nreturn r;\r\n}\r\n}\r\ntotal_bytes = 0;\r\nfor (i = 0; i < pfwinfo->num_ptdl; i++)\r\n{\r\nunifi_trace(card->ospriv, UDBG3, "Patch download: %d Downloading for %d from offset %d\n",\r\ni,\r\npfwinfo->ptdl[i].dl_size,\r\npfwinfo->ptdl[i].dl_offset);\r\nr = send_ptdl_to_unifi(card, dlpriv, &pfwinfo->ptdl[i],\r\nhandle, boot_ctrl_addr + 6);\r\nif (r == CSR_WIFI_HIP_RESULT_NO_DEVICE)\r\n{\r\nreturn r;\r\n}\r\nif (r != CSR_RESULT_SUCCESS)\r\n{\r\nunifi_error(card->ospriv, "Patch failed after %u bytes\n",\r\ntotal_bytes);\r\nreturn r;\r\n}\r\ntotal_bytes += pfwinfo->ptdl[i].dl_size;\r\n}\r\nreturn CSR_RESULT_SUCCESS;\r\n}
