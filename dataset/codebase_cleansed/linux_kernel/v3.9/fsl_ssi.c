static inline void write_ssi_mask(u32 __iomem *addr, u32 clear, u32 set)\r\n{\r\nu32 val = readl(addr);\r\nval = (val & ~clear) | set;\r\nwritel(val, addr);\r\n}\r\nstatic irqreturn_t fsl_ssi_isr(int irq, void *dev_id)\r\n{\r\nstruct fsl_ssi_private *ssi_private = dev_id;\r\nstruct ccsr_ssi __iomem *ssi = ssi_private->ssi;\r\nirqreturn_t ret = IRQ_NONE;\r\n__be32 sisr;\r\n__be32 sisr2 = 0;\r\nsisr = read_ssi(&ssi->sisr) & SIER_FLAGS;\r\nif (sisr & CCSR_SSI_SISR_RFRC) {\r\nssi_private->stats.rfrc++;\r\nsisr2 |= CCSR_SSI_SISR_RFRC;\r\nret = IRQ_HANDLED;\r\n}\r\nif (sisr & CCSR_SSI_SISR_TFRC) {\r\nssi_private->stats.tfrc++;\r\nsisr2 |= CCSR_SSI_SISR_TFRC;\r\nret = IRQ_HANDLED;\r\n}\r\nif (sisr & CCSR_SSI_SISR_CMDAU) {\r\nssi_private->stats.cmdau++;\r\nret = IRQ_HANDLED;\r\n}\r\nif (sisr & CCSR_SSI_SISR_CMDDU) {\r\nssi_private->stats.cmddu++;\r\nret = IRQ_HANDLED;\r\n}\r\nif (sisr & CCSR_SSI_SISR_RXT) {\r\nssi_private->stats.rxt++;\r\nret = IRQ_HANDLED;\r\n}\r\nif (sisr & CCSR_SSI_SISR_RDR1) {\r\nssi_private->stats.rdr1++;\r\nret = IRQ_HANDLED;\r\n}\r\nif (sisr & CCSR_SSI_SISR_RDR0) {\r\nssi_private->stats.rdr0++;\r\nret = IRQ_HANDLED;\r\n}\r\nif (sisr & CCSR_SSI_SISR_TDE1) {\r\nssi_private->stats.tde1++;\r\nret = IRQ_HANDLED;\r\n}\r\nif (sisr & CCSR_SSI_SISR_TDE0) {\r\nssi_private->stats.tde0++;\r\nret = IRQ_HANDLED;\r\n}\r\nif (sisr & CCSR_SSI_SISR_ROE1) {\r\nssi_private->stats.roe1++;\r\nsisr2 |= CCSR_SSI_SISR_ROE1;\r\nret = IRQ_HANDLED;\r\n}\r\nif (sisr & CCSR_SSI_SISR_ROE0) {\r\nssi_private->stats.roe0++;\r\nsisr2 |= CCSR_SSI_SISR_ROE0;\r\nret = IRQ_HANDLED;\r\n}\r\nif (sisr & CCSR_SSI_SISR_TUE1) {\r\nssi_private->stats.tue1++;\r\nsisr2 |= CCSR_SSI_SISR_TUE1;\r\nret = IRQ_HANDLED;\r\n}\r\nif (sisr & CCSR_SSI_SISR_TUE0) {\r\nssi_private->stats.tue0++;\r\nsisr2 |= CCSR_SSI_SISR_TUE0;\r\nret = IRQ_HANDLED;\r\n}\r\nif (sisr & CCSR_SSI_SISR_TFS) {\r\nssi_private->stats.tfs++;\r\nret = IRQ_HANDLED;\r\n}\r\nif (sisr & CCSR_SSI_SISR_RFS) {\r\nssi_private->stats.rfs++;\r\nret = IRQ_HANDLED;\r\n}\r\nif (sisr & CCSR_SSI_SISR_TLS) {\r\nssi_private->stats.tls++;\r\nret = IRQ_HANDLED;\r\n}\r\nif (sisr & CCSR_SSI_SISR_RLS) {\r\nssi_private->stats.rls++;\r\nret = IRQ_HANDLED;\r\n}\r\nif (sisr & CCSR_SSI_SISR_RFF1) {\r\nssi_private->stats.rff1++;\r\nret = IRQ_HANDLED;\r\n}\r\nif (sisr & CCSR_SSI_SISR_RFF0) {\r\nssi_private->stats.rff0++;\r\nret = IRQ_HANDLED;\r\n}\r\nif (sisr & CCSR_SSI_SISR_TFE1) {\r\nssi_private->stats.tfe1++;\r\nret = IRQ_HANDLED;\r\n}\r\nif (sisr & CCSR_SSI_SISR_TFE0) {\r\nssi_private->stats.tfe0++;\r\nret = IRQ_HANDLED;\r\n}\r\nif (sisr2)\r\nwrite_ssi(sisr2, &ssi->sisr);\r\nreturn ret;\r\n}\r\nstatic int fsl_ssi_startup(struct snd_pcm_substream *substream,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\nstruct fsl_ssi_private *ssi_private =\r\nsnd_soc_dai_get_drvdata(rtd->cpu_dai);\r\nint synchronous = ssi_private->cpu_dai_drv.symmetric_rates;\r\nif (!ssi_private->first_stream) {\r\nstruct ccsr_ssi __iomem *ssi = ssi_private->ssi;\r\nssi_private->first_stream = substream;\r\nwrite_ssi_mask(&ssi->scr, CCSR_SSI_SCR_SSIEN, 0);\r\nwrite_ssi_mask(&ssi->scr,\r\nCCSR_SSI_SCR_I2S_MODE_MASK | CCSR_SSI_SCR_SYN,\r\nCCSR_SSI_SCR_TFR_CLK_DIS | CCSR_SSI_SCR_I2S_MODE_SLAVE\r\n| (synchronous ? CCSR_SSI_SCR_SYN : 0));\r\nwrite_ssi(CCSR_SSI_STCR_TXBIT0 | CCSR_SSI_STCR_TFEN0 |\r\nCCSR_SSI_STCR_TFSI | CCSR_SSI_STCR_TEFS |\r\nCCSR_SSI_STCR_TSCKP, &ssi->stcr);\r\nwrite_ssi(CCSR_SSI_SRCR_RXBIT0 | CCSR_SSI_SRCR_RFEN0 |\r\nCCSR_SSI_SRCR_RFSI | CCSR_SSI_SRCR_REFS |\r\nCCSR_SSI_SRCR_RSCKP, &ssi->srcr);\r\nwrite_ssi(SIER_FLAGS, &ssi->sier);\r\nwrite_ssi(CCSR_SSI_SFCSR_TFWM0(ssi_private->fifo_depth - 2) |\r\nCCSR_SSI_SFCSR_RFWM0(ssi_private->fifo_depth - 2),\r\n&ssi->sfcsr);\r\n} else {\r\nif (synchronous) {\r\nstruct snd_pcm_runtime *first_runtime =\r\nssi_private->first_stream->runtime;\r\nif (!first_runtime->sample_bits) {\r\ndev_err(substream->pcm->card->dev,\r\n"set sample size in %s stream first\n",\r\nsubstream->stream ==\r\nSNDRV_PCM_STREAM_PLAYBACK\r\n? "capture" : "playback");\r\nreturn -EAGAIN;\r\n}\r\nsnd_pcm_hw_constraint_minmax(substream->runtime,\r\nSNDRV_PCM_HW_PARAM_SAMPLE_BITS,\r\nfirst_runtime->sample_bits,\r\nfirst_runtime->sample_bits);\r\n}\r\nssi_private->second_stream = substream;\r\n}\r\nif (ssi_private->ssi_on_imx)\r\nsnd_soc_dai_set_dma_data(dai, substream,\r\n(substream->stream == SNDRV_PCM_STREAM_PLAYBACK) ?\r\n&ssi_private->dma_params_tx :\r\n&ssi_private->dma_params_rx);\r\nreturn 0;\r\n}\r\nstatic int fsl_ssi_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *hw_params, struct snd_soc_dai *cpu_dai)\r\n{\r\nstruct fsl_ssi_private *ssi_private = snd_soc_dai_get_drvdata(cpu_dai);\r\nstruct ccsr_ssi __iomem *ssi = ssi_private->ssi;\r\nunsigned int sample_size =\r\nsnd_pcm_format_width(params_format(hw_params));\r\nu32 wl = CCSR_SSI_SxCCR_WL(sample_size);\r\nint enabled = read_ssi(&ssi->scr) & CCSR_SSI_SCR_SSIEN;\r\nif (enabled && ssi_private->cpu_dai_drv.symmetric_rates)\r\nreturn 0;\r\nif ((substream->stream == SNDRV_PCM_STREAM_PLAYBACK) ||\r\nssi_private->cpu_dai_drv.symmetric_rates)\r\nwrite_ssi_mask(&ssi->stccr, CCSR_SSI_SxCCR_WL_MASK, wl);\r\nelse\r\nwrite_ssi_mask(&ssi->srccr, CCSR_SSI_SxCCR_WL_MASK, wl);\r\nreturn 0;\r\n}\r\nstatic int fsl_ssi_trigger(struct snd_pcm_substream *substream, int cmd,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\nstruct fsl_ssi_private *ssi_private = snd_soc_dai_get_drvdata(rtd->cpu_dai);\r\nstruct ccsr_ssi __iomem *ssi = ssi_private->ssi;\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\ncase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\r\nwrite_ssi_mask(&ssi->scr, 0,\r\nCCSR_SSI_SCR_SSIEN | CCSR_SSI_SCR_TE);\r\nelse\r\nwrite_ssi_mask(&ssi->scr, 0,\r\nCCSR_SSI_SCR_SSIEN | CCSR_SSI_SCR_RE);\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\ncase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\r\nwrite_ssi_mask(&ssi->scr, CCSR_SSI_SCR_TE, 0);\r\nelse\r\nwrite_ssi_mask(&ssi->scr, CCSR_SSI_SCR_RE, 0);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic void fsl_ssi_shutdown(struct snd_pcm_substream *substream,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\nstruct fsl_ssi_private *ssi_private = snd_soc_dai_get_drvdata(rtd->cpu_dai);\r\nif (ssi_private->first_stream == substream)\r\nssi_private->first_stream = ssi_private->second_stream;\r\nssi_private->second_stream = NULL;\r\nif (!ssi_private->first_stream) {\r\nstruct ccsr_ssi __iomem *ssi = ssi_private->ssi;\r\nwrite_ssi_mask(&ssi->scr, CCSR_SSI_SCR_SSIEN, 0);\r\n}\r\n}\r\nstatic ssize_t fsl_sysfs_ssi_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct fsl_ssi_private *ssi_private =\r\ncontainer_of(attr, struct fsl_ssi_private, dev_attr);\r\nssize_t length = 0;\r\nSIER_SHOW(RFRC_EN, rfrc);\r\nSIER_SHOW(TFRC_EN, tfrc);\r\nSIER_SHOW(CMDAU_EN, cmdau);\r\nSIER_SHOW(CMDDU_EN, cmddu);\r\nSIER_SHOW(RXT_EN, rxt);\r\nSIER_SHOW(RDR1_EN, rdr1);\r\nSIER_SHOW(RDR0_EN, rdr0);\r\nSIER_SHOW(TDE1_EN, tde1);\r\nSIER_SHOW(TDE0_EN, tde0);\r\nSIER_SHOW(ROE1_EN, roe1);\r\nSIER_SHOW(ROE0_EN, roe0);\r\nSIER_SHOW(TUE1_EN, tue1);\r\nSIER_SHOW(TUE0_EN, tue0);\r\nSIER_SHOW(TFS_EN, tfs);\r\nSIER_SHOW(RFS_EN, rfs);\r\nSIER_SHOW(TLS_EN, tls);\r\nSIER_SHOW(RLS_EN, rls);\r\nSIER_SHOW(RFF1_EN, rff1);\r\nSIER_SHOW(RFF0_EN, rff0);\r\nSIER_SHOW(TFE1_EN, tfe1);\r\nSIER_SHOW(TFE0_EN, tfe0);\r\nreturn length;\r\n}\r\nstatic void make_lowercase(char *s)\r\n{\r\nchar *p = s;\r\nchar c;\r\nwhile ((c = *p)) {\r\nif ((c >= 'A') && (c <= 'Z'))\r\n*p = c + ('a' - 'A');\r\np++;\r\n}\r\n}\r\nstatic int fsl_ssi_probe(struct platform_device *pdev)\r\n{\r\nstruct fsl_ssi_private *ssi_private;\r\nint ret = 0;\r\nstruct device_attribute *dev_attr = NULL;\r\nstruct device_node *np = pdev->dev.of_node;\r\nconst char *p, *sprop;\r\nconst uint32_t *iprop;\r\nstruct resource res;\r\nchar name[64];\r\nif (!of_device_is_available(np))\r\nreturn -ENODEV;\r\nsprop = of_get_property(np, "fsl,mode", NULL);\r\nif (!sprop || strcmp(sprop, "i2s-slave")) {\r\ndev_notice(&pdev->dev, "mode %s is unsupported\n", sprop);\r\nreturn -ENODEV;\r\n}\r\np = strrchr(np->full_name, '/') + 1;\r\nssi_private = kzalloc(sizeof(struct fsl_ssi_private) + strlen(p),\r\nGFP_KERNEL);\r\nif (!ssi_private) {\r\ndev_err(&pdev->dev, "could not allocate DAI object\n");\r\nreturn -ENOMEM;\r\n}\r\nstrcpy(ssi_private->name, p);\r\nmemcpy(&ssi_private->cpu_dai_drv, &fsl_ssi_dai_template,\r\nsizeof(fsl_ssi_dai_template));\r\nssi_private->cpu_dai_drv.name = ssi_private->name;\r\nret = of_address_to_resource(np, 0, &res);\r\nif (ret) {\r\ndev_err(&pdev->dev, "could not determine device resources\n");\r\ngoto error_kmalloc;\r\n}\r\nssi_private->ssi = of_iomap(np, 0);\r\nif (!ssi_private->ssi) {\r\ndev_err(&pdev->dev, "could not map device resources\n");\r\nret = -ENOMEM;\r\ngoto error_kmalloc;\r\n}\r\nssi_private->ssi_phys = res.start;\r\nssi_private->irq = irq_of_parse_and_map(np, 0);\r\nif (ssi_private->irq == NO_IRQ) {\r\ndev_err(&pdev->dev, "no irq for node %s\n", np->full_name);\r\nret = -ENXIO;\r\ngoto error_iomap;\r\n}\r\nret = request_irq(ssi_private->irq, fsl_ssi_isr, 0, ssi_private->name,\r\nssi_private);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "could not claim irq %u\n", ssi_private->irq);\r\ngoto error_irqmap;\r\n}\r\nif (!of_find_property(np, "fsl,ssi-asynchronous", NULL))\r\nssi_private->cpu_dai_drv.symmetric_rates = 1;\r\niprop = of_get_property(np, "fsl,fifo-depth", NULL);\r\nif (iprop)\r\nssi_private->fifo_depth = be32_to_cpup(iprop);\r\nelse\r\nssi_private->fifo_depth = 8;\r\nif (of_device_is_compatible(pdev->dev.of_node, "fsl,imx21-ssi")) {\r\nu32 dma_events[2];\r\nssi_private->ssi_on_imx = true;\r\nssi_private->clk = clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(ssi_private->clk)) {\r\nret = PTR_ERR(ssi_private->clk);\r\ndev_err(&pdev->dev, "could not get clock: %d\n", ret);\r\ngoto error_irq;\r\n}\r\nclk_prepare_enable(ssi_private->clk);\r\nssi_private->dma_params_tx.burstsize =\r\nssi_private->fifo_depth - 2;\r\nssi_private->dma_params_rx.burstsize =\r\nssi_private->fifo_depth - 2;\r\nssi_private->dma_params_tx.dma_addr =\r\nssi_private->ssi_phys + offsetof(struct ccsr_ssi, stx0);\r\nssi_private->dma_params_rx.dma_addr =\r\nssi_private->ssi_phys + offsetof(struct ccsr_ssi, srx0);\r\nret = of_property_read_u32_array(pdev->dev.of_node,\r\n"fsl,ssi-dma-events", dma_events, 2);\r\nif (ret) {\r\ndev_err(&pdev->dev, "could not get dma events\n");\r\ngoto error_clk;\r\n}\r\nssi_private->dma_params_tx.dma = dma_events[0];\r\nssi_private->dma_params_rx.dma = dma_events[1];\r\nssi_private->dma_params_tx.shared_peripheral =\r\nof_device_is_compatible(of_get_parent(np),\r\n"fsl,spba-bus");\r\nssi_private->dma_params_rx.shared_peripheral =\r\nssi_private->dma_params_tx.shared_peripheral;\r\n}\r\ndev_attr = &ssi_private->dev_attr;\r\nsysfs_attr_init(&dev_attr->attr);\r\ndev_attr->attr.name = "statistics";\r\ndev_attr->attr.mode = S_IRUGO;\r\ndev_attr->show = fsl_sysfs_ssi_show;\r\nret = device_create_file(&pdev->dev, dev_attr);\r\nif (ret) {\r\ndev_err(&pdev->dev, "could not create sysfs %s file\n",\r\nssi_private->dev_attr.attr.name);\r\ngoto error_irq;\r\n}\r\ndev_set_drvdata(&pdev->dev, ssi_private);\r\nret = snd_soc_register_dai(&pdev->dev, &ssi_private->cpu_dai_drv);\r\nif (ret) {\r\ndev_err(&pdev->dev, "failed to register DAI: %d\n", ret);\r\ngoto error_dev;\r\n}\r\nif (ssi_private->ssi_on_imx) {\r\nssi_private->imx_pcm_pdev =\r\nplatform_device_register_simple("imx-pcm-audio",\r\n-1, NULL, 0);\r\nif (IS_ERR(ssi_private->imx_pcm_pdev)) {\r\nret = PTR_ERR(ssi_private->imx_pcm_pdev);\r\ngoto error_dev;\r\n}\r\n}\r\nif (!of_get_property(np, "codec-handle", NULL)) {\r\nssi_private->new_binding = true;\r\ngoto done;\r\n}\r\nsprop = of_get_property(of_find_node_by_path("/"), "compatible", NULL);\r\np = strrchr(sprop, ',');\r\nif (p)\r\nsprop = p + 1;\r\nsnprintf(name, sizeof(name), "snd-soc-%s", sprop);\r\nmake_lowercase(name);\r\nssi_private->pdev =\r\nplatform_device_register_data(&pdev->dev, name, 0, NULL, 0);\r\nif (IS_ERR(ssi_private->pdev)) {\r\nret = PTR_ERR(ssi_private->pdev);\r\ndev_err(&pdev->dev, "failed to register platform: %d\n", ret);\r\ngoto error_dai;\r\n}\r\ndone:\r\nreturn 0;\r\nerror_dai:\r\nif (ssi_private->ssi_on_imx)\r\nplatform_device_unregister(ssi_private->imx_pcm_pdev);\r\nsnd_soc_unregister_dai(&pdev->dev);\r\nerror_dev:\r\ndev_set_drvdata(&pdev->dev, NULL);\r\ndevice_remove_file(&pdev->dev, dev_attr);\r\nerror_clk:\r\nif (ssi_private->ssi_on_imx) {\r\nclk_disable_unprepare(ssi_private->clk);\r\nclk_put(ssi_private->clk);\r\n}\r\nerror_irq:\r\nfree_irq(ssi_private->irq, ssi_private);\r\nerror_irqmap:\r\nirq_dispose_mapping(ssi_private->irq);\r\nerror_iomap:\r\niounmap(ssi_private->ssi);\r\nerror_kmalloc:\r\nkfree(ssi_private);\r\nreturn ret;\r\n}\r\nstatic int fsl_ssi_remove(struct platform_device *pdev)\r\n{\r\nstruct fsl_ssi_private *ssi_private = dev_get_drvdata(&pdev->dev);\r\nif (!ssi_private->new_binding)\r\nplatform_device_unregister(ssi_private->pdev);\r\nif (ssi_private->ssi_on_imx) {\r\nplatform_device_unregister(ssi_private->imx_pcm_pdev);\r\nclk_disable_unprepare(ssi_private->clk);\r\nclk_put(ssi_private->clk);\r\n}\r\nsnd_soc_unregister_dai(&pdev->dev);\r\ndevice_remove_file(&pdev->dev, &ssi_private->dev_attr);\r\nfree_irq(ssi_private->irq, ssi_private);\r\nirq_dispose_mapping(ssi_private->irq);\r\nkfree(ssi_private);\r\ndev_set_drvdata(&pdev->dev, NULL);\r\nreturn 0;\r\n}
