static u32 __combo_phy_reg_read(u8 sata_port, u32 addr)\r\n{\r\nu32 data;\r\nu8 dev = port_data[sata_port].phy_devs;\r\nspin_lock(&cphy_lock);\r\nwritel(CPHY_MAP(dev, addr), port_data[sata_port].phy_base + 0x800);\r\ndata = readl(port_data[sata_port].phy_base + CPHY_ADDR(addr));\r\nspin_unlock(&cphy_lock);\r\nreturn data;\r\n}\r\nstatic void __combo_phy_reg_write(u8 sata_port, u32 addr, u32 data)\r\n{\r\nu8 dev = port_data[sata_port].phy_devs;\r\nspin_lock(&cphy_lock);\r\nwritel(CPHY_MAP(dev, addr), port_data[sata_port].phy_base + 0x800);\r\nwritel(data, port_data[sata_port].phy_base + CPHY_ADDR(addr));\r\nspin_unlock(&cphy_lock);\r\n}\r\nstatic void combo_phy_wait_for_ready(u8 sata_port)\r\n{\r\nwhile (__combo_phy_reg_read(sata_port, SERDES_CR_CTL) & CR_BUSY)\r\nudelay(5);\r\n}\r\nstatic u32 combo_phy_read(u8 sata_port, u32 addr)\r\n{\r\ncombo_phy_wait_for_ready(sata_port);\r\n__combo_phy_reg_write(sata_port, SERDES_CR_ADDR, addr);\r\n__combo_phy_reg_write(sata_port, SERDES_CR_CTL, CR_START);\r\ncombo_phy_wait_for_ready(sata_port);\r\nreturn __combo_phy_reg_read(sata_port, SERDES_CR_DATA);\r\n}\r\nstatic void combo_phy_write(u8 sata_port, u32 addr, u32 data)\r\n{\r\ncombo_phy_wait_for_ready(sata_port);\r\n__combo_phy_reg_write(sata_port, SERDES_CR_ADDR, addr);\r\n__combo_phy_reg_write(sata_port, SERDES_CR_DATA, data);\r\n__combo_phy_reg_write(sata_port, SERDES_CR_CTL, CR_WR_RDN | CR_START);\r\n}\r\nstatic void highbank_cphy_disable_overrides(u8 sata_port)\r\n{\r\nu8 lane = port_data[sata_port].lane_mapping;\r\nu32 tmp;\r\nif (unlikely(port_data[sata_port].phy_base == NULL))\r\nreturn;\r\ntmp = combo_phy_read(sata_port, CPHY_RX_INPUT_STS + lane * SPHY_LANE);\r\ntmp &= ~CPHY_SATA_OVERRIDE;\r\ncombo_phy_write(sata_port, CPHY_OVERRIDE + lane * SPHY_LANE, tmp);\r\n}\r\nstatic void cphy_override_rx_mode(u8 sata_port, u32 val)\r\n{\r\nu8 lane = port_data[sata_port].lane_mapping;\r\nu32 tmp;\r\ntmp = combo_phy_read(sata_port, CPHY_RX_INPUT_STS + lane * SPHY_LANE);\r\ntmp &= ~CPHY_SATA_OVERRIDE;\r\ncombo_phy_write(sata_port, CPHY_OVERRIDE + lane * SPHY_LANE, tmp);\r\ntmp |= CPHY_SATA_OVERRIDE;\r\ncombo_phy_write(sata_port, CPHY_OVERRIDE + lane * SPHY_LANE, tmp);\r\ntmp &= ~CPHY_SATA_DPLL_MODE;\r\ntmp |= val << CPHY_SATA_DPLL_SHIFT;\r\ncombo_phy_write(sata_port, CPHY_OVERRIDE + lane * SPHY_LANE, tmp);\r\ntmp |= CPHY_SATA_DPLL_RESET;\r\ncombo_phy_write(sata_port, CPHY_OVERRIDE + lane * SPHY_LANE, tmp);\r\ntmp &= ~CPHY_SATA_DPLL_RESET;\r\ncombo_phy_write(sata_port, CPHY_OVERRIDE + lane * SPHY_LANE, tmp);\r\nmsleep(15);\r\n}\r\nstatic void highbank_cphy_override_lane(u8 sata_port)\r\n{\r\nu8 lane = port_data[sata_port].lane_mapping;\r\nu32 tmp, k = 0;\r\nif (unlikely(port_data[sata_port].phy_base == NULL))\r\nreturn;\r\ndo {\r\ntmp = combo_phy_read(sata_port, CPHY_RX_INPUT_STS +\r\nlane * SPHY_LANE);\r\n} while ((tmp & SPHY_HALF_RATE) && (k++ < 1000));\r\ncphy_override_rx_mode(sata_port, 3);\r\n}\r\nstatic int highbank_initialize_phys(struct device *dev, void __iomem *addr)\r\n{\r\nstruct device_node *sata_node = dev->of_node;\r\nint phy_count = 0, phy, port = 0;\r\nvoid __iomem *cphy_base[CPHY_PHY_COUNT];\r\nstruct device_node *phy_nodes[CPHY_PHY_COUNT];\r\nmemset(port_data, 0, sizeof(struct phy_lane_info) * CPHY_PORT_COUNT);\r\nmemset(phy_nodes, 0, sizeof(struct device_node*) * CPHY_PHY_COUNT);\r\ndo {\r\nu32 tmp;\r\nstruct of_phandle_args phy_data;\r\nif (of_parse_phandle_with_args(sata_node,\r\n"calxeda,port-phys", "#phy-cells",\r\nport, &phy_data))\r\nbreak;\r\nfor (phy = 0; phy < phy_count; phy++) {\r\nif (phy_nodes[phy] == phy_data.np)\r\nbreak;\r\n}\r\nif (phy_nodes[phy] == NULL) {\r\nphy_nodes[phy] = phy_data.np;\r\ncphy_base[phy] = of_iomap(phy_nodes[phy], 0);\r\nif (cphy_base[phy] == NULL) {\r\nreturn 0;\r\n}\r\nphy_count += 1;\r\n}\r\nport_data[port].lane_mapping = phy_data.args[0];\r\nof_property_read_u32(phy_nodes[phy], "phydev", &tmp);\r\nport_data[port].phy_devs = tmp;\r\nport_data[port].phy_base = cphy_base[phy];\r\nof_node_put(phy_data.np);\r\nport += 1;\r\n} while (port < CPHY_PORT_COUNT);\r\nreturn 0;\r\n}\r\nstatic int ahci_highbank_hardreset(struct ata_link *link, unsigned int *class,\r\nunsigned long deadline)\r\n{\r\nconst unsigned long *timing = sata_ehc_deb_timing(&link->eh_context);\r\nstruct ata_port *ap = link->ap;\r\nstruct ahci_port_priv *pp = ap->private_data;\r\nu8 *d2h_fis = pp->rx_fis + RX_FIS_D2H_REG;\r\nstruct ata_taskfile tf;\r\nbool online;\r\nu32 sstatus;\r\nint rc;\r\nint retry = 10;\r\nahci_stop_engine(ap);\r\nata_tf_init(link->device, &tf);\r\ntf.command = ATA_BUSY;\r\nata_tf_to_fis(&tf, 0, 0, d2h_fis);\r\ndo {\r\nhighbank_cphy_disable_overrides(link->ap->port_no);\r\nrc = sata_link_hardreset(link, timing, deadline, &online, NULL);\r\nhighbank_cphy_override_lane(link->ap->port_no);\r\nif (sata_scr_read(link, SCR_STATUS, &sstatus))\r\nbreak;\r\nif (!(sstatus & 0x3))\r\nbreak;\r\n} while (!online && retry--);\r\nahci_start_engine(ap);\r\nif (online)\r\n*class = ahci_dev_classify(ap);\r\nreturn rc;\r\n}\r\nstatic int ahci_highbank_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct ahci_host_priv *hpriv;\r\nstruct ata_host *host;\r\nstruct resource *mem;\r\nint irq;\r\nint n_ports;\r\nint i;\r\nint rc;\r\nstruct ata_port_info pi = ahci_highbank_port_info;\r\nconst struct ata_port_info *ppi[] = { &pi, NULL };\r\nmem = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!mem) {\r\ndev_err(dev, "no mmio space\n");\r\nreturn -EINVAL;\r\n}\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq <= 0) {\r\ndev_err(dev, "no irq\n");\r\nreturn -EINVAL;\r\n}\r\nhpriv = devm_kzalloc(dev, sizeof(*hpriv), GFP_KERNEL);\r\nif (!hpriv) {\r\ndev_err(dev, "can't alloc ahci_host_priv\n");\r\nreturn -ENOMEM;\r\n}\r\nhpriv->flags |= (unsigned long)pi.private_data;\r\nhpriv->mmio = devm_ioremap(dev, mem->start, resource_size(mem));\r\nif (!hpriv->mmio) {\r\ndev_err(dev, "can't map %pR\n", mem);\r\nreturn -ENOMEM;\r\n}\r\nrc = highbank_initialize_phys(dev, hpriv->mmio);\r\nif (rc)\r\nreturn rc;\r\nahci_save_initial_config(dev, hpriv, 0, 0);\r\nif (hpriv->cap & HOST_CAP_NCQ)\r\npi.flags |= ATA_FLAG_NCQ;\r\nif (hpriv->cap & HOST_CAP_PMP)\r\npi.flags |= ATA_FLAG_PMP;\r\nahci_set_em_messages(hpriv, &pi);\r\nn_ports = max(ahci_nr_ports(hpriv->cap), fls(hpriv->port_map));\r\nhost = ata_host_alloc_pinfo(dev, ppi, n_ports);\r\nif (!host) {\r\nrc = -ENOMEM;\r\ngoto err0;\r\n}\r\nhost->private_data = hpriv;\r\nif (!(hpriv->cap & HOST_CAP_SSS) || ahci_ignore_sss)\r\nhost->flags |= ATA_HOST_PARALLEL_SCAN;\r\nif (pi.flags & ATA_FLAG_EM)\r\nahci_reset_em(host);\r\nfor (i = 0; i < host->n_ports; i++) {\r\nstruct ata_port *ap = host->ports[i];\r\nata_port_desc(ap, "mmio %pR", mem);\r\nata_port_desc(ap, "port 0x%x", 0x100 + ap->port_no * 0x80);\r\nif (ap->flags & ATA_FLAG_EM)\r\nap->em_message_type = hpriv->em_msg_type;\r\nif (!(hpriv->port_map & (1 << i)))\r\nap->ops = &ata_dummy_port_ops;\r\n}\r\nrc = ahci_reset_controller(host);\r\nif (rc)\r\ngoto err0;\r\nahci_init_controller(host);\r\nahci_print_info(host, "platform");\r\nrc = ata_host_activate(host, irq, ahci_interrupt, 0,\r\n&ahci_highbank_platform_sht);\r\nif (rc)\r\ngoto err0;\r\nreturn 0;\r\nerr0:\r\nreturn rc;\r\n}\r\nstatic int ahci_highbank_suspend(struct device *dev)\r\n{\r\nstruct ata_host *host = dev_get_drvdata(dev);\r\nstruct ahci_host_priv *hpriv = host->private_data;\r\nvoid __iomem *mmio = hpriv->mmio;\r\nu32 ctl;\r\nint rc;\r\nif (hpriv->flags & AHCI_HFLAG_NO_SUSPEND) {\r\ndev_err(dev, "firmware update required for suspend/resume\n");\r\nreturn -EIO;\r\n}\r\nctl = readl(mmio + HOST_CTL);\r\nctl &= ~HOST_IRQ_EN;\r\nwritel(ctl, mmio + HOST_CTL);\r\nreadl(mmio + HOST_CTL);\r\nrc = ata_host_suspend(host, PMSG_SUSPEND);\r\nif (rc)\r\nreturn rc;\r\nreturn 0;\r\n}\r\nstatic int ahci_highbank_resume(struct device *dev)\r\n{\r\nstruct ata_host *host = dev_get_drvdata(dev);\r\nint rc;\r\nif (dev->power.power_state.event == PM_EVENT_SUSPEND) {\r\nrc = ahci_reset_controller(host);\r\nif (rc)\r\nreturn rc;\r\nahci_init_controller(host);\r\n}\r\nata_host_resume(host);\r\nreturn 0;\r\n}
