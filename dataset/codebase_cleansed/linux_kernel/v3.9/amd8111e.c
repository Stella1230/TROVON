static int amd8111e_read_phy(struct amd8111e_priv* lp, int phy_id, int reg, u32* val)\r\n{\r\nvoid __iomem *mmio = lp->mmio;\r\nunsigned int reg_val;\r\nunsigned int repeat= REPEAT_CNT;\r\nreg_val = readl(mmio + PHY_ACCESS);\r\nwhile (reg_val & PHY_CMD_ACTIVE)\r\nreg_val = readl( mmio + PHY_ACCESS );\r\nwritel( PHY_RD_CMD | ((phy_id & 0x1f) << 21) |\r\n((reg & 0x1f) << 16), mmio +PHY_ACCESS);\r\ndo{\r\nreg_val = readl(mmio + PHY_ACCESS);\r\nudelay(30);\r\n} while (--repeat && (reg_val & PHY_CMD_ACTIVE));\r\nif(reg_val & PHY_RD_ERR)\r\ngoto err_phy_read;\r\n*val = reg_val & 0xffff;\r\nreturn 0;\r\nerr_phy_read:\r\n*val = 0;\r\nreturn -EINVAL;\r\n}\r\nstatic int amd8111e_write_phy(struct amd8111e_priv* lp,int phy_id, int reg, u32 val)\r\n{\r\nunsigned int repeat = REPEAT_CNT;\r\nvoid __iomem *mmio = lp->mmio;\r\nunsigned int reg_val;\r\nreg_val = readl(mmio + PHY_ACCESS);\r\nwhile (reg_val & PHY_CMD_ACTIVE)\r\nreg_val = readl( mmio + PHY_ACCESS );\r\nwritel( PHY_WR_CMD | ((phy_id & 0x1f) << 21) |\r\n((reg & 0x1f) << 16)|val, mmio + PHY_ACCESS);\r\ndo{\r\nreg_val = readl(mmio + PHY_ACCESS);\r\nudelay(30);\r\n} while (--repeat && (reg_val & PHY_CMD_ACTIVE));\r\nif(reg_val & PHY_RD_ERR)\r\ngoto err_phy_write;\r\nreturn 0;\r\nerr_phy_write:\r\nreturn -EINVAL;\r\n}\r\nstatic int amd8111e_mdio_read(struct net_device * dev, int phy_id, int reg_num)\r\n{\r\nstruct amd8111e_priv* lp = netdev_priv(dev);\r\nunsigned int reg_val;\r\namd8111e_read_phy(lp,phy_id,reg_num,&reg_val);\r\nreturn reg_val;\r\n}\r\nstatic void amd8111e_mdio_write(struct net_device * dev, int phy_id, int reg_num, int val)\r\n{\r\nstruct amd8111e_priv* lp = netdev_priv(dev);\r\namd8111e_write_phy(lp, phy_id, reg_num, val);\r\n}\r\nstatic void amd8111e_set_ext_phy(struct net_device *dev)\r\n{\r\nstruct amd8111e_priv *lp = netdev_priv(dev);\r\nu32 bmcr,advert,tmp;\r\nadvert = amd8111e_mdio_read(dev, lp->ext_phy_addr, MII_ADVERTISE);\r\ntmp = advert & ~(ADVERTISE_ALL | ADVERTISE_100BASE4);\r\nswitch (lp->ext_phy_option){\r\ndefault:\r\ncase SPEED_AUTONEG:\r\ntmp |= ( ADVERTISE_10HALF|ADVERTISE_10FULL|\r\nADVERTISE_100HALF|ADVERTISE_100FULL) ;\r\nbreak;\r\ncase SPEED10_HALF:\r\ntmp |= ADVERTISE_10HALF;\r\nbreak;\r\ncase SPEED10_FULL:\r\ntmp |= ADVERTISE_10FULL;\r\nbreak;\r\ncase SPEED100_HALF:\r\ntmp |= ADVERTISE_100HALF;\r\nbreak;\r\ncase SPEED100_FULL:\r\ntmp |= ADVERTISE_100FULL;\r\nbreak;\r\n}\r\nif(advert != tmp)\r\namd8111e_mdio_write(dev, lp->ext_phy_addr, MII_ADVERTISE, tmp);\r\nbmcr = amd8111e_mdio_read(dev, lp->ext_phy_addr, MII_BMCR);\r\nbmcr |= (BMCR_ANENABLE | BMCR_ANRESTART);\r\namd8111e_mdio_write(dev, lp->ext_phy_addr, MII_BMCR, bmcr);\r\n}\r\nstatic int amd8111e_free_skbs(struct net_device *dev)\r\n{\r\nstruct amd8111e_priv *lp = netdev_priv(dev);\r\nstruct sk_buff* rx_skbuff;\r\nint i;\r\nfor(i = 0; i < NUM_TX_BUFFERS; i++){\r\nif(lp->tx_skbuff[i]){\r\npci_unmap_single(lp->pci_dev,lp->tx_dma_addr[i], lp->tx_skbuff[i]->len,PCI_DMA_TODEVICE);\r\ndev_kfree_skb (lp->tx_skbuff[i]);\r\nlp->tx_skbuff[i] = NULL;\r\nlp->tx_dma_addr[i] = 0;\r\n}\r\n}\r\nfor (i = 0; i < NUM_RX_BUFFERS; i++){\r\nrx_skbuff = lp->rx_skbuff[i];\r\nif(rx_skbuff != NULL){\r\npci_unmap_single(lp->pci_dev,lp->rx_dma_addr[i],\r\nlp->rx_buff_len - 2,PCI_DMA_FROMDEVICE);\r\ndev_kfree_skb(lp->rx_skbuff[i]);\r\nlp->rx_skbuff[i] = NULL;\r\nlp->rx_dma_addr[i] = 0;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic inline void amd8111e_set_rx_buff_len(struct net_device* dev)\r\n{\r\nstruct amd8111e_priv* lp = netdev_priv(dev);\r\nunsigned int mtu = dev->mtu;\r\nif (mtu > ETH_DATA_LEN){\r\nlp->rx_buff_len = mtu + ETH_HLEN + 10;\r\nlp->options |= OPTION_JUMBO_ENABLE;\r\n} else{\r\nlp->rx_buff_len = PKT_BUFF_SZ;\r\nlp->options &= ~OPTION_JUMBO_ENABLE;\r\n}\r\n}\r\nstatic int amd8111e_init_ring(struct net_device *dev)\r\n{\r\nstruct amd8111e_priv *lp = netdev_priv(dev);\r\nint i;\r\nlp->rx_idx = lp->tx_idx = 0;\r\nlp->tx_complete_idx = 0;\r\nlp->tx_ring_idx = 0;\r\nif(lp->opened)\r\namd8111e_free_skbs(dev);\r\nelse{\r\nif((lp->tx_ring = pci_alloc_consistent(lp->pci_dev,\r\nsizeof(struct amd8111e_tx_dr)*NUM_TX_RING_DR,\r\n&lp->tx_ring_dma_addr)) == NULL)\r\ngoto err_no_mem;\r\nif((lp->rx_ring = pci_alloc_consistent(lp->pci_dev,\r\nsizeof(struct amd8111e_rx_dr)*NUM_RX_RING_DR,\r\n&lp->rx_ring_dma_addr)) == NULL)\r\ngoto err_free_tx_ring;\r\n}\r\namd8111e_set_rx_buff_len(dev);\r\nfor (i = 0; i < NUM_RX_BUFFERS; i++) {\r\nlp->rx_skbuff[i] = netdev_alloc_skb(dev, lp->rx_buff_len);\r\nif (!lp->rx_skbuff[i]) {\r\nfor(--i; i >= 0 ;i--)\r\ndev_kfree_skb(lp->rx_skbuff[i]);\r\ngoto err_free_rx_ring;\r\n}\r\nskb_reserve(lp->rx_skbuff[i],2);\r\n}\r\nfor (i = 0; i < NUM_RX_BUFFERS; i++) {\r\nlp->rx_dma_addr[i] = pci_map_single(lp->pci_dev,\r\nlp->rx_skbuff[i]->data,lp->rx_buff_len-2, PCI_DMA_FROMDEVICE);\r\nlp->rx_ring[i].buff_phy_addr = cpu_to_le32(lp->rx_dma_addr[i]);\r\nlp->rx_ring[i].buff_count = cpu_to_le16(lp->rx_buff_len-2);\r\nwmb();\r\nlp->rx_ring[i].rx_flags = cpu_to_le16(OWN_BIT);\r\n}\r\nfor (i = 0; i < NUM_TX_RING_DR; i++) {\r\nlp->tx_ring[i].buff_phy_addr = 0;\r\nlp->tx_ring[i].tx_flags = 0;\r\nlp->tx_ring[i].buff_count = 0;\r\n}\r\nreturn 0;\r\nerr_free_rx_ring:\r\npci_free_consistent(lp->pci_dev,\r\nsizeof(struct amd8111e_rx_dr)*NUM_RX_RING_DR,lp->rx_ring,\r\nlp->rx_ring_dma_addr);\r\nerr_free_tx_ring:\r\npci_free_consistent(lp->pci_dev,\r\nsizeof(struct amd8111e_tx_dr)*NUM_TX_RING_DR,lp->tx_ring,\r\nlp->tx_ring_dma_addr);\r\nerr_no_mem:\r\nreturn -ENOMEM;\r\n}\r\nstatic int amd8111e_set_coalesce(struct net_device * dev, enum coal_mode cmod)\r\n{\r\nunsigned int timeout;\r\nunsigned int event_count;\r\nstruct amd8111e_priv *lp = netdev_priv(dev);\r\nvoid __iomem *mmio = lp->mmio;\r\nstruct amd8111e_coalesce_conf * coal_conf = &lp->coal_conf;\r\nswitch(cmod)\r\n{\r\ncase RX_INTR_COAL :\r\ntimeout = coal_conf->rx_timeout;\r\nevent_count = coal_conf->rx_event_count;\r\nif( timeout > MAX_TIMEOUT ||\r\nevent_count > MAX_EVENT_COUNT )\r\nreturn -EINVAL;\r\ntimeout = timeout * DELAY_TIMER_CONV;\r\nwritel(VAL0|STINTEN, mmio+INTEN0);\r\nwritel((u32)DLY_INT_A_R0|( event_count<< 16 )|timeout,\r\nmmio+DLY_INT_A);\r\nbreak;\r\ncase TX_INTR_COAL :\r\ntimeout = coal_conf->tx_timeout;\r\nevent_count = coal_conf->tx_event_count;\r\nif( timeout > MAX_TIMEOUT ||\r\nevent_count > MAX_EVENT_COUNT )\r\nreturn -EINVAL;\r\ntimeout = timeout * DELAY_TIMER_CONV;\r\nwritel(VAL0|STINTEN,mmio+INTEN0);\r\nwritel((u32)DLY_INT_B_T0|( event_count<< 16 )|timeout,\r\nmmio+DLY_INT_B);\r\nbreak;\r\ncase DISABLE_COAL:\r\nwritel(0,mmio+STVAL);\r\nwritel(STINTEN, mmio+INTEN0);\r\nwritel(0, mmio +DLY_INT_B);\r\nwritel(0, mmio+DLY_INT_A);\r\nbreak;\r\ncase ENABLE_COAL:\r\nwritel((u32)SOFT_TIMER_FREQ, mmio+STVAL);\r\nwritel(VAL0|STINTEN, mmio+INTEN0);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int amd8111e_restart(struct net_device *dev)\r\n{\r\nstruct amd8111e_priv *lp = netdev_priv(dev);\r\nvoid __iomem *mmio = lp->mmio;\r\nint i,reg_val;\r\nwritel(RUN, mmio + CMD0);\r\nif(amd8111e_init_ring(dev))\r\nreturn -ENOMEM;\r\nwritel((u32) VAL1|EN_PMGR, mmio + CMD3 );\r\nwritel((u32)XPHYANE|XPHYRST , mmio + CTRL2);\r\namd8111e_set_ext_phy(dev);\r\nreg_val = readl(mmio + CTRL1);\r\nreg_val &= ~XMTSP_MASK;\r\nwritel( reg_val| XMTSP_128 | CACHE_ALIGN, mmio + CTRL1 );\r\nwritel( APINT5EN | APINT4EN | APINT3EN | APINT2EN | APINT1EN |\r\nAPINT0EN | MIIPDTINTEN | MCCIINTEN | MCCINTEN | MREINTEN |\r\nSPNDINTEN | MPINTEN | SINTEN | STINTEN, mmio + INTEN0);\r\nwritel(VAL3 | LCINTEN | VAL1 | TINTEN0 | VAL0 | RINTEN0, mmio + INTEN0);\r\nwritel((u32)lp->tx_ring_dma_addr,mmio + XMT_RING_BASE_ADDR0);\r\nwritel((u32)lp->rx_ring_dma_addr,mmio+ RCV_RING_BASE_ADDR0);\r\nwritew((u32)NUM_TX_RING_DR, mmio + XMT_RING_LEN0);\r\nwritew((u16)NUM_RX_RING_DR, mmio + RCV_RING_LEN0);\r\nwritew((u32)DEFAULT_IPG,mmio+IPG);\r\nwritew((u32)(DEFAULT_IPG-IFS1_DELTA), mmio + IFS1);\r\nif(lp->options & OPTION_JUMBO_ENABLE){\r\nwritel((u32)VAL2|JUMBO, mmio + CMD3);\r\nwritel( REX_UFLO, mmio + CMD2);\r\nwritel( VAL0 | APAD_XMT|REX_RTRY , mmio + CMD2);\r\n}else{\r\nwritel( VAL0 | APAD_XMT | REX_RTRY|REX_UFLO, mmio + CMD2);\r\nwritel((u32)JUMBO, mmio + CMD3);\r\n}\r\n#if AMD8111E_VLAN_TAG_USED\r\nwritel((u32) VAL2|VSIZE|VL_TAG_DEL, mmio + CMD3);\r\n#endif\r\nwritel( VAL0 | APAD_XMT | REX_RTRY, mmio + CMD2 );\r\nfor (i = 0; i < ETH_ALEN; i++)\r\nwriteb( dev->dev_addr[i], mmio + PADR + i );\r\nif(lp->options & OPTION_INTR_COAL_ENABLE){\r\nprintk(KERN_INFO "%s: Interrupt Coalescing Enabled.\n",\r\ndev->name);\r\namd8111e_set_coalesce(dev,ENABLE_COAL);\r\n}\r\nwritel(VAL2 | RDMD0, mmio + CMD0);\r\nwritel(VAL0 | INTREN | RUN, mmio + CMD0);\r\nreadl(mmio+CMD0);\r\nreturn 0;\r\n}\r\nstatic void amd8111e_init_hw_default( struct amd8111e_priv* lp)\r\n{\r\nunsigned int reg_val;\r\nunsigned int logic_filter[2] ={0,};\r\nvoid __iomem *mmio = lp->mmio;\r\nwritel(RUN, mmio + CMD0);\r\nwritew( 0x8100 | lp->ext_phy_addr, mmio + AUTOPOLL0);\r\nwritel(0, mmio + RCV_RING_BASE_ADDR0);\r\nwritel(0, mmio + XMT_RING_BASE_ADDR0);\r\nwritel(0, mmio + XMT_RING_BASE_ADDR1);\r\nwritel(0, mmio + XMT_RING_BASE_ADDR2);\r\nwritel(0, mmio + XMT_RING_BASE_ADDR3);\r\nwritel(CMD0_CLEAR,mmio + CMD0);\r\nwritel(CMD2_CLEAR, mmio +CMD2);\r\nwritel(CMD7_CLEAR , mmio + CMD7);\r\nwritel(0x0, mmio + DLY_INT_A);\r\nwritel(0x0, mmio + DLY_INT_B);\r\nwritel(0x0, mmio + FLOW_CONTROL);\r\nreg_val = readl(mmio + INT0);\r\nwritel(reg_val, mmio + INT0);\r\nwritel(0x0, mmio + STVAL);\r\nwritel( INTEN0_CLEAR, mmio + INTEN0);\r\nwritel(0x0 , mmio + LADRF);\r\nwritel( 0x80010,mmio + SRAM_SIZE);\r\nwritel(0x0, mmio + RCV_RING_LEN0);\r\nwritel(0x0, mmio + XMT_RING_LEN0);\r\nwritel(0x0, mmio + XMT_RING_LEN1);\r\nwritel(0x0, mmio + XMT_RING_LEN2);\r\nwritel(0x0, mmio + XMT_RING_LEN3);\r\nwritel(0x0, mmio + XMT_RING_LIMIT);\r\nwritew(MIB_CLEAR, mmio + MIB_ADDR);\r\namd8111e_writeq(*(u64*)logic_filter,mmio+LADRF);\r\nreg_val = readl(mmio + SRAM_SIZE);\r\nif(lp->options & OPTION_JUMBO_ENABLE)\r\nwritel( VAL2|JUMBO, mmio + CMD3);\r\n#if AMD8111E_VLAN_TAG_USED\r\nwritel(VAL2|VSIZE|VL_TAG_DEL, mmio + CMD3 );\r\n#endif\r\nwritel(CTRL1_DEFAULT, mmio + CTRL1);\r\nreadl(mmio + CMD2);\r\n}\r\nstatic void amd8111e_disable_interrupt(struct amd8111e_priv* lp)\r\n{\r\nu32 intr0;\r\nwritel(INTREN, lp->mmio + CMD0);\r\nintr0 = readl(lp->mmio + INT0);\r\nwritel(intr0, lp->mmio + INT0);\r\nreadl(lp->mmio + INT0);\r\n}\r\nstatic void amd8111e_stop_chip(struct amd8111e_priv* lp)\r\n{\r\nwritel(RUN, lp->mmio + CMD0);\r\nreadl(lp->mmio + CMD0);\r\n}\r\nstatic void amd8111e_free_ring(struct amd8111e_priv* lp)\r\n{\r\nif(lp->rx_ring){\r\npci_free_consistent(lp->pci_dev,\r\nsizeof(struct amd8111e_rx_dr)*NUM_RX_RING_DR,\r\nlp->rx_ring, lp->rx_ring_dma_addr);\r\nlp->rx_ring = NULL;\r\n}\r\nif(lp->tx_ring){\r\npci_free_consistent(lp->pci_dev,\r\nsizeof(struct amd8111e_tx_dr)*NUM_TX_RING_DR,\r\nlp->tx_ring, lp->tx_ring_dma_addr);\r\nlp->tx_ring = NULL;\r\n}\r\n}\r\nstatic int amd8111e_tx(struct net_device *dev)\r\n{\r\nstruct amd8111e_priv* lp = netdev_priv(dev);\r\nint tx_index = lp->tx_complete_idx & TX_RING_DR_MOD_MASK;\r\nint status;\r\nwhile (lp->tx_complete_idx != lp->tx_idx){\r\ntx_index = lp->tx_complete_idx & TX_RING_DR_MOD_MASK;\r\nstatus = le16_to_cpu(lp->tx_ring[tx_index].tx_flags);\r\nif(status & OWN_BIT)\r\nbreak;\r\nlp->tx_ring[tx_index].buff_phy_addr = 0;\r\nif (lp->tx_skbuff[tx_index]) {\r\npci_unmap_single(lp->pci_dev, lp->tx_dma_addr[tx_index],\r\nlp->tx_skbuff[tx_index]->len,\r\nPCI_DMA_TODEVICE);\r\ndev_kfree_skb_irq (lp->tx_skbuff[tx_index]);\r\nlp->tx_skbuff[tx_index] = NULL;\r\nlp->tx_dma_addr[tx_index] = 0;\r\n}\r\nlp->tx_complete_idx++;\r\nlp->coal_conf.tx_packets++;\r\nlp->coal_conf.tx_bytes +=\r\nle16_to_cpu(lp->tx_ring[tx_index].buff_count);\r\nif (netif_queue_stopped(dev) &&\r\nlp->tx_complete_idx > lp->tx_idx - NUM_TX_BUFFERS +2){\r\nnetif_wake_queue (dev);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int amd8111e_rx_poll(struct napi_struct *napi, int budget)\r\n{\r\nstruct amd8111e_priv *lp = container_of(napi, struct amd8111e_priv, napi);\r\nstruct net_device *dev = lp->amd8111e_net_dev;\r\nint rx_index = lp->rx_idx & RX_RING_DR_MOD_MASK;\r\nvoid __iomem *mmio = lp->mmio;\r\nstruct sk_buff *skb,*new_skb;\r\nint min_pkt_len, status;\r\nunsigned int intr0;\r\nint num_rx_pkt = 0;\r\nshort pkt_len;\r\n#if AMD8111E_VLAN_TAG_USED\r\nshort vtag;\r\n#endif\r\nint rx_pkt_limit = budget;\r\nunsigned long flags;\r\ndo{\r\nwhile(1) {\r\nstatus = le16_to_cpu(lp->rx_ring[rx_index].rx_flags);\r\nif (status & OWN_BIT)\r\nbreak;\r\nif(status & ERR_BIT) {\r\nlp->rx_ring[rx_index].rx_flags &= RESET_RX_FLAGS;\r\ngoto err_next_pkt;\r\n}\r\nif(!((status & STP_BIT) && (status & ENP_BIT))){\r\nlp->rx_ring[rx_index].rx_flags &= RESET_RX_FLAGS;\r\ngoto err_next_pkt;\r\n}\r\npkt_len = le16_to_cpu(lp->rx_ring[rx_index].msg_count) - 4;\r\n#if AMD8111E_VLAN_TAG_USED\r\nvtag = status & TT_MASK;\r\nif (vtag != 0)\r\nmin_pkt_len =MIN_PKT_LEN - 4;\r\nelse\r\n#endif\r\nmin_pkt_len =MIN_PKT_LEN;\r\nif (pkt_len < min_pkt_len) {\r\nlp->rx_ring[rx_index].rx_flags &= RESET_RX_FLAGS;\r\nlp->drv_rx_errors++;\r\ngoto err_next_pkt;\r\n}\r\nif(--rx_pkt_limit < 0)\r\ngoto rx_not_empty;\r\nnew_skb = netdev_alloc_skb(dev, lp->rx_buff_len);\r\nif (!new_skb) {\r\nlp->rx_ring[rx_index].rx_flags &= RESET_RX_FLAGS;\r\nlp->drv_rx_errors++;\r\ngoto err_next_pkt;\r\n}\r\nskb_reserve(new_skb, 2);\r\nskb = lp->rx_skbuff[rx_index];\r\npci_unmap_single(lp->pci_dev,lp->rx_dma_addr[rx_index],\r\nlp->rx_buff_len-2, PCI_DMA_FROMDEVICE);\r\nskb_put(skb, pkt_len);\r\nlp->rx_skbuff[rx_index] = new_skb;\r\nlp->rx_dma_addr[rx_index] = pci_map_single(lp->pci_dev,\r\nnew_skb->data,\r\nlp->rx_buff_len-2,\r\nPCI_DMA_FROMDEVICE);\r\nskb->protocol = eth_type_trans(skb, dev);\r\n#if AMD8111E_VLAN_TAG_USED\r\nif (vtag == TT_VLAN_TAGGED){\r\nu16 vlan_tag = le16_to_cpu(lp->rx_ring[rx_index].tag_ctrl_info);\r\n__vlan_hwaccel_put_tag(skb, vlan_tag);\r\n}\r\n#endif\r\nnetif_receive_skb(skb);\r\nlp->coal_conf.rx_packets++;\r\nlp->coal_conf.rx_bytes += pkt_len;\r\nnum_rx_pkt++;\r\nerr_next_pkt:\r\nlp->rx_ring[rx_index].buff_phy_addr\r\n= cpu_to_le32(lp->rx_dma_addr[rx_index]);\r\nlp->rx_ring[rx_index].buff_count =\r\ncpu_to_le16(lp->rx_buff_len-2);\r\nwmb();\r\nlp->rx_ring[rx_index].rx_flags |= cpu_to_le16(OWN_BIT);\r\nrx_index = (++lp->rx_idx) & RX_RING_DR_MOD_MASK;\r\n}\r\nintr0 = readl(mmio + INT0);\r\nwritel(intr0 & RINT0,mmio + INT0);\r\n} while(intr0 & RINT0);\r\nif (rx_pkt_limit > 0) {\r\nspin_lock_irqsave(&lp->lock, flags);\r\n__napi_complete(napi);\r\nwritel(VAL0|RINTEN0, mmio + INTEN0);\r\nwritel(VAL2 | RDMD0, mmio + CMD0);\r\nspin_unlock_irqrestore(&lp->lock, flags);\r\n}\r\nrx_not_empty:\r\nreturn num_rx_pkt;\r\n}\r\nstatic int amd8111e_link_change(struct net_device* dev)\r\n{\r\nstruct amd8111e_priv *lp = netdev_priv(dev);\r\nint status0,speed;\r\nstatus0 = readl(lp->mmio + STAT0);\r\nif(status0 & LINK_STATS){\r\nif(status0 & AUTONEG_COMPLETE)\r\nlp->link_config.autoneg = AUTONEG_ENABLE;\r\nelse\r\nlp->link_config.autoneg = AUTONEG_DISABLE;\r\nif(status0 & FULL_DPLX)\r\nlp->link_config.duplex = DUPLEX_FULL;\r\nelse\r\nlp->link_config.duplex = DUPLEX_HALF;\r\nspeed = (status0 & SPEED_MASK) >> 7;\r\nif(speed == PHY_SPEED_10)\r\nlp->link_config.speed = SPEED_10;\r\nelse if(speed == PHY_SPEED_100)\r\nlp->link_config.speed = SPEED_100;\r\nprintk(KERN_INFO "%s: Link is Up. Speed is %s Mbps %s Duplex\n", dev->name,\r\n(lp->link_config.speed == SPEED_100) ? "100": "10",\r\n(lp->link_config.duplex == DUPLEX_FULL)? "Full": "Half");\r\nnetif_carrier_on(dev);\r\n}\r\nelse{\r\nlp->link_config.speed = SPEED_INVALID;\r\nlp->link_config.duplex = DUPLEX_INVALID;\r\nlp->link_config.autoneg = AUTONEG_INVALID;\r\nprintk(KERN_INFO "%s: Link is Down.\n",dev->name);\r\nnetif_carrier_off(dev);\r\n}\r\nreturn 0;\r\n}\r\nstatic int amd8111e_read_mib(void __iomem *mmio, u8 MIB_COUNTER)\r\n{\r\nunsigned int status;\r\nunsigned int data;\r\nunsigned int repeat = REPEAT_CNT;\r\nwritew( MIB_RD_CMD | MIB_COUNTER, mmio + MIB_ADDR);\r\ndo {\r\nstatus = readw(mmio + MIB_ADDR);\r\nudelay(2);\r\n}\r\nwhile (--repeat && (status & MIB_CMD_ACTIVE));\r\ndata = readl(mmio + MIB_DATA);\r\nreturn data;\r\n}\r\nstatic struct net_device_stats *amd8111e_get_stats(struct net_device *dev)\r\n{\r\nstruct amd8111e_priv *lp = netdev_priv(dev);\r\nvoid __iomem *mmio = lp->mmio;\r\nunsigned long flags;\r\nstruct net_device_stats *new_stats = &dev->stats;\r\nif (!lp->opened)\r\nreturn new_stats;\r\nspin_lock_irqsave (&lp->lock, flags);\r\nnew_stats->rx_packets = amd8111e_read_mib(mmio, rcv_broadcast_pkts)+\r\namd8111e_read_mib(mmio, rcv_multicast_pkts)+\r\namd8111e_read_mib(mmio, rcv_unicast_pkts);\r\nnew_stats->tx_packets = amd8111e_read_mib(mmio, xmt_packets);\r\nnew_stats->rx_bytes = amd8111e_read_mib(mmio, rcv_octets);\r\nnew_stats->tx_bytes = amd8111e_read_mib(mmio, xmt_octets);\r\nnew_stats->rx_errors = amd8111e_read_mib(mmio, rcv_undersize_pkts)+\r\namd8111e_read_mib(mmio, rcv_fragments)+\r\namd8111e_read_mib(mmio, rcv_jabbers)+\r\namd8111e_read_mib(mmio, rcv_alignment_errors)+\r\namd8111e_read_mib(mmio, rcv_fcs_errors)+\r\namd8111e_read_mib(mmio, rcv_miss_pkts)+\r\nlp->drv_rx_errors;\r\nnew_stats->tx_errors = amd8111e_read_mib(mmio, xmt_underrun_pkts);\r\nnew_stats->rx_dropped = amd8111e_read_mib(mmio, rcv_miss_pkts);\r\nnew_stats->tx_dropped = amd8111e_read_mib(mmio, xmt_underrun_pkts);\r\nnew_stats->multicast = amd8111e_read_mib(mmio, rcv_multicast_pkts);\r\nnew_stats->collisions = amd8111e_read_mib(mmio, xmt_collisions);\r\nnew_stats->rx_length_errors =\r\namd8111e_read_mib(mmio, rcv_undersize_pkts)+\r\namd8111e_read_mib(mmio, rcv_oversize_pkts);\r\nnew_stats->rx_over_errors = amd8111e_read_mib(mmio, rcv_miss_pkts);\r\nnew_stats->rx_crc_errors = amd8111e_read_mib(mmio, rcv_fcs_errors);\r\nnew_stats->rx_frame_errors =\r\namd8111e_read_mib(mmio, rcv_alignment_errors);\r\nnew_stats->rx_fifo_errors = amd8111e_read_mib(mmio, rcv_miss_pkts);\r\nnew_stats->rx_missed_errors = amd8111e_read_mib(mmio, rcv_miss_pkts);\r\nnew_stats->tx_aborted_errors =\r\namd8111e_read_mib(mmio, xmt_excessive_collision);\r\nnew_stats->tx_carrier_errors =\r\namd8111e_read_mib(mmio, xmt_loss_carrier);\r\nnew_stats->tx_fifo_errors = amd8111e_read_mib(mmio, xmt_underrun_pkts);\r\nnew_stats->tx_window_errors =\r\namd8111e_read_mib(mmio, xmt_late_collision);\r\nspin_unlock_irqrestore (&lp->lock, flags);\r\nreturn new_stats;\r\n}\r\nstatic int amd8111e_calc_coalesce(struct net_device *dev)\r\n{\r\nstruct amd8111e_priv *lp = netdev_priv(dev);\r\nstruct amd8111e_coalesce_conf * coal_conf = &lp->coal_conf;\r\nint tx_pkt_rate;\r\nint rx_pkt_rate;\r\nint tx_data_rate;\r\nint rx_data_rate;\r\nint rx_pkt_size;\r\nint tx_pkt_size;\r\ntx_pkt_rate = coal_conf->tx_packets - coal_conf->tx_prev_packets;\r\ncoal_conf->tx_prev_packets = coal_conf->tx_packets;\r\ntx_data_rate = coal_conf->tx_bytes - coal_conf->tx_prev_bytes;\r\ncoal_conf->tx_prev_bytes = coal_conf->tx_bytes;\r\nrx_pkt_rate = coal_conf->rx_packets - coal_conf->rx_prev_packets;\r\ncoal_conf->rx_prev_packets = coal_conf->rx_packets;\r\nrx_data_rate = coal_conf->rx_bytes - coal_conf->rx_prev_bytes;\r\ncoal_conf->rx_prev_bytes = coal_conf->rx_bytes;\r\nif(rx_pkt_rate < 800){\r\nif(coal_conf->rx_coal_type != NO_COALESCE){\r\ncoal_conf->rx_timeout = 0x0;\r\ncoal_conf->rx_event_count = 0;\r\namd8111e_set_coalesce(dev,RX_INTR_COAL);\r\ncoal_conf->rx_coal_type = NO_COALESCE;\r\n}\r\n}\r\nelse{\r\nrx_pkt_size = rx_data_rate/rx_pkt_rate;\r\nif (rx_pkt_size < 128){\r\nif(coal_conf->rx_coal_type != NO_COALESCE){\r\ncoal_conf->rx_timeout = 0;\r\ncoal_conf->rx_event_count = 0;\r\namd8111e_set_coalesce(dev,RX_INTR_COAL);\r\ncoal_conf->rx_coal_type = NO_COALESCE;\r\n}\r\n}\r\nelse if ( (rx_pkt_size >= 128) && (rx_pkt_size < 512) ){\r\nif(coal_conf->rx_coal_type != LOW_COALESCE){\r\ncoal_conf->rx_timeout = 1;\r\ncoal_conf->rx_event_count = 4;\r\namd8111e_set_coalesce(dev,RX_INTR_COAL);\r\ncoal_conf->rx_coal_type = LOW_COALESCE;\r\n}\r\n}\r\nelse if ((rx_pkt_size >= 512) && (rx_pkt_size < 1024)){\r\nif(coal_conf->rx_coal_type != MEDIUM_COALESCE){\r\ncoal_conf->rx_timeout = 1;\r\ncoal_conf->rx_event_count = 4;\r\namd8111e_set_coalesce(dev,RX_INTR_COAL);\r\ncoal_conf->rx_coal_type = MEDIUM_COALESCE;\r\n}\r\n}\r\nelse if(rx_pkt_size >= 1024){\r\nif(coal_conf->rx_coal_type != HIGH_COALESCE){\r\ncoal_conf->rx_timeout = 2;\r\ncoal_conf->rx_event_count = 3;\r\namd8111e_set_coalesce(dev,RX_INTR_COAL);\r\ncoal_conf->rx_coal_type = HIGH_COALESCE;\r\n}\r\n}\r\n}\r\nif(tx_pkt_rate < 800){\r\nif(coal_conf->tx_coal_type != NO_COALESCE){\r\ncoal_conf->tx_timeout = 0x0;\r\ncoal_conf->tx_event_count = 0;\r\namd8111e_set_coalesce(dev,TX_INTR_COAL);\r\ncoal_conf->tx_coal_type = NO_COALESCE;\r\n}\r\n}\r\nelse{\r\ntx_pkt_size = tx_data_rate/tx_pkt_rate;\r\nif (tx_pkt_size < 128){\r\nif(coal_conf->tx_coal_type != NO_COALESCE){\r\ncoal_conf->tx_timeout = 0;\r\ncoal_conf->tx_event_count = 0;\r\namd8111e_set_coalesce(dev,TX_INTR_COAL);\r\ncoal_conf->tx_coal_type = NO_COALESCE;\r\n}\r\n}\r\nelse if ( (tx_pkt_size >= 128) && (tx_pkt_size < 512) ){\r\nif(coal_conf->tx_coal_type != LOW_COALESCE){\r\ncoal_conf->tx_timeout = 1;\r\ncoal_conf->tx_event_count = 2;\r\namd8111e_set_coalesce(dev,TX_INTR_COAL);\r\ncoal_conf->tx_coal_type = LOW_COALESCE;\r\n}\r\n}\r\nelse if ((tx_pkt_size >= 512) && (tx_pkt_size < 1024)){\r\nif(coal_conf->tx_coal_type != MEDIUM_COALESCE){\r\ncoal_conf->tx_timeout = 2;\r\ncoal_conf->tx_event_count = 5;\r\namd8111e_set_coalesce(dev,TX_INTR_COAL);\r\ncoal_conf->tx_coal_type = MEDIUM_COALESCE;\r\n}\r\n}\r\nelse if(tx_pkt_size >= 1024){\r\nif (tx_pkt_size >= 1024){\r\nif(coal_conf->tx_coal_type != HIGH_COALESCE){\r\ncoal_conf->tx_timeout = 4;\r\ncoal_conf->tx_event_count = 8;\r\namd8111e_set_coalesce(dev,TX_INTR_COAL);\r\ncoal_conf->tx_coal_type = HIGH_COALESCE;\r\n}\r\n}\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic irqreturn_t amd8111e_interrupt(int irq, void *dev_id)\r\n{\r\nstruct net_device * dev = (struct net_device *) dev_id;\r\nstruct amd8111e_priv *lp = netdev_priv(dev);\r\nvoid __iomem *mmio = lp->mmio;\r\nunsigned int intr0, intren0;\r\nunsigned int handled = 1;\r\nif(unlikely(dev == NULL))\r\nreturn IRQ_NONE;\r\nspin_lock(&lp->lock);\r\nwritel(INTREN, mmio + CMD0);\r\nintr0 = readl(mmio + INT0);\r\nintren0 = readl(mmio + INTEN0);\r\nif (!(intr0 & INTR)){\r\nhandled = 0;\r\ngoto err_no_interrupt;\r\n}\r\nwritel(intr0, mmio + INT0);\r\nif (intr0 & RINT0) {\r\nif (napi_schedule_prep(&lp->napi)) {\r\nwritel(RINTEN0, mmio + INTEN0);\r\n__napi_schedule(&lp->napi);\r\n} else if (intren0 & RINTEN0) {\r\nprintk("************Driver bug! interrupt while in poll\n");\r\nwritel(RINTEN0, mmio + INTEN0);\r\n}\r\n}\r\nif (intr0 & TINT0)\r\namd8111e_tx(dev);\r\nif (intr0 & LCINT)\r\namd8111e_link_change(dev);\r\nif (intr0 & STINT)\r\namd8111e_calc_coalesce(dev);\r\nerr_no_interrupt:\r\nwritel( VAL0 | INTREN,mmio + CMD0);\r\nspin_unlock(&lp->lock);\r\nreturn IRQ_RETVAL(handled);\r\n}\r\nstatic void amd8111e_poll(struct net_device *dev)\r\n{\r\nunsigned long flags;\r\nlocal_irq_save(flags);\r\namd8111e_interrupt(0, dev);\r\nlocal_irq_restore(flags);\r\n}\r\nstatic int amd8111e_close(struct net_device * dev)\r\n{\r\nstruct amd8111e_priv *lp = netdev_priv(dev);\r\nnetif_stop_queue(dev);\r\nnapi_disable(&lp->napi);\r\nspin_lock_irq(&lp->lock);\r\namd8111e_disable_interrupt(lp);\r\namd8111e_stop_chip(lp);\r\namd8111e_free_skbs(lp->amd8111e_net_dev);\r\nnetif_carrier_off(lp->amd8111e_net_dev);\r\nif(lp->options & OPTION_DYN_IPG_ENABLE)\r\ndel_timer_sync(&lp->ipg_data.ipg_timer);\r\nspin_unlock_irq(&lp->lock);\r\nfree_irq(dev->irq, dev);\r\namd8111e_free_ring(lp);\r\namd8111e_get_stats(dev);\r\nlp->opened = 0;\r\nreturn 0;\r\n}\r\nstatic int amd8111e_open(struct net_device * dev )\r\n{\r\nstruct amd8111e_priv *lp = netdev_priv(dev);\r\nif(dev->irq ==0 || request_irq(dev->irq, amd8111e_interrupt, IRQF_SHARED,\r\ndev->name, dev))\r\nreturn -EAGAIN;\r\nnapi_enable(&lp->napi);\r\nspin_lock_irq(&lp->lock);\r\namd8111e_init_hw_default(lp);\r\nif(amd8111e_restart(dev)){\r\nspin_unlock_irq(&lp->lock);\r\nnapi_disable(&lp->napi);\r\nif (dev->irq)\r\nfree_irq(dev->irq, dev);\r\nreturn -ENOMEM;\r\n}\r\nif(lp->options & OPTION_DYN_IPG_ENABLE){\r\nadd_timer(&lp->ipg_data.ipg_timer);\r\nprintk(KERN_INFO "%s: Dynamic IPG Enabled.\n",dev->name);\r\n}\r\nlp->opened = 1;\r\nspin_unlock_irq(&lp->lock);\r\nnetif_start_queue(dev);\r\nreturn 0;\r\n}\r\nstatic int amd8111e_tx_queue_avail(struct amd8111e_priv* lp )\r\n{\r\nint tx_index = lp->tx_idx & TX_BUFF_MOD_MASK;\r\nif (lp->tx_skbuff[tx_index])\r\nreturn -1;\r\nelse\r\nreturn 0;\r\n}\r\nstatic netdev_tx_t amd8111e_start_xmit(struct sk_buff *skb,\r\nstruct net_device * dev)\r\n{\r\nstruct amd8111e_priv *lp = netdev_priv(dev);\r\nint tx_index;\r\nunsigned long flags;\r\nspin_lock_irqsave(&lp->lock, flags);\r\ntx_index = lp->tx_idx & TX_RING_DR_MOD_MASK;\r\nlp->tx_ring[tx_index].buff_count = cpu_to_le16(skb->len);\r\nlp->tx_skbuff[tx_index] = skb;\r\nlp->tx_ring[tx_index].tx_flags = 0;\r\n#if AMD8111E_VLAN_TAG_USED\r\nif (vlan_tx_tag_present(skb)) {\r\nlp->tx_ring[tx_index].tag_ctrl_cmd |=\r\ncpu_to_le16(TCC_VLAN_INSERT);\r\nlp->tx_ring[tx_index].tag_ctrl_info =\r\ncpu_to_le16(vlan_tx_tag_get(skb));\r\n}\r\n#endif\r\nlp->tx_dma_addr[tx_index] =\r\npci_map_single(lp->pci_dev, skb->data, skb->len, PCI_DMA_TODEVICE);\r\nlp->tx_ring[tx_index].buff_phy_addr =\r\ncpu_to_le32(lp->tx_dma_addr[tx_index]);\r\nwmb();\r\nlp->tx_ring[tx_index].tx_flags |=\r\ncpu_to_le16(OWN_BIT | STP_BIT | ENP_BIT|ADD_FCS_BIT|LTINT_BIT);\r\nlp->tx_idx++;\r\nwritel( VAL1 | TDMD0, lp->mmio + CMD0);\r\nwritel( VAL2 | RDMD0,lp->mmio + CMD0);\r\nif(amd8111e_tx_queue_avail(lp) < 0){\r\nnetif_stop_queue(dev);\r\n}\r\nspin_unlock_irqrestore(&lp->lock, flags);\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic void amd8111e_read_regs(struct amd8111e_priv *lp, u32 *buf)\r\n{\r\nvoid __iomem *mmio = lp->mmio;\r\nbuf[0] = readl(mmio + XMT_RING_BASE_ADDR0);\r\nbuf[1] = readl(mmio + XMT_RING_LEN0);\r\nbuf[2] = readl(mmio + RCV_RING_BASE_ADDR0);\r\nbuf[3] = readl(mmio + RCV_RING_LEN0);\r\nbuf[4] = readl(mmio + CMD0);\r\nbuf[5] = readl(mmio + CMD2);\r\nbuf[6] = readl(mmio + CMD3);\r\nbuf[7] = readl(mmio + CMD7);\r\nbuf[8] = readl(mmio + INT0);\r\nbuf[9] = readl(mmio + INTEN0);\r\nbuf[10] = readl(mmio + LADRF);\r\nbuf[11] = readl(mmio + LADRF+4);\r\nbuf[12] = readl(mmio + STAT0);\r\n}\r\nstatic void amd8111e_set_multicast_list(struct net_device *dev)\r\n{\r\nstruct netdev_hw_addr *ha;\r\nstruct amd8111e_priv *lp = netdev_priv(dev);\r\nu32 mc_filter[2] ;\r\nint bit_num;\r\nif(dev->flags & IFF_PROMISC){\r\nwritel( VAL2 | PROM, lp->mmio + CMD2);\r\nreturn;\r\n}\r\nelse\r\nwritel( PROM, lp->mmio + CMD2);\r\nif (dev->flags & IFF_ALLMULTI ||\r\nnetdev_mc_count(dev) > MAX_FILTER_SIZE) {\r\nmc_filter[1] = mc_filter[0] = 0xffffffff;\r\nlp->options |= OPTION_MULTICAST_ENABLE;\r\namd8111e_writeq(*(u64*)mc_filter,lp->mmio + LADRF);\r\nreturn;\r\n}\r\nif (netdev_mc_empty(dev)) {\r\nmc_filter[1] = mc_filter[0] = 0;\r\nlp->options &= ~OPTION_MULTICAST_ENABLE;\r\namd8111e_writeq(*(u64*)mc_filter,lp->mmio + LADRF);\r\nwritel(PROM, lp->mmio + CMD2);\r\nreturn;\r\n}\r\nlp->options |= OPTION_MULTICAST_ENABLE;\r\nmc_filter[1] = mc_filter[0] = 0;\r\nnetdev_for_each_mc_addr(ha, dev) {\r\nbit_num = (ether_crc_le(ETH_ALEN, ha->addr) >> 26) & 0x3f;\r\nmc_filter[bit_num >> 5] |= 1 << (bit_num & 31);\r\n}\r\namd8111e_writeq(*(u64*)mc_filter,lp->mmio+ LADRF);\r\nreadl(lp->mmio + CMD2);\r\n}\r\nstatic void amd8111e_get_drvinfo(struct net_device* dev, struct ethtool_drvinfo *info)\r\n{\r\nstruct amd8111e_priv *lp = netdev_priv(dev);\r\nstruct pci_dev *pci_dev = lp->pci_dev;\r\nstrlcpy(info->driver, MODULE_NAME, sizeof(info->driver));\r\nstrlcpy(info->version, MODULE_VERS, sizeof(info->version));\r\nsnprintf(info->fw_version, sizeof(info->fw_version),\r\n"%u", chip_version);\r\nstrlcpy(info->bus_info, pci_name(pci_dev), sizeof(info->bus_info));\r\n}\r\nstatic int amd8111e_get_regs_len(struct net_device *dev)\r\n{\r\nreturn AMD8111E_REG_DUMP_LEN;\r\n}\r\nstatic void amd8111e_get_regs(struct net_device *dev, struct ethtool_regs *regs, void *buf)\r\n{\r\nstruct amd8111e_priv *lp = netdev_priv(dev);\r\nregs->version = 0;\r\namd8111e_read_regs(lp, buf);\r\n}\r\nstatic int amd8111e_get_settings(struct net_device *dev, struct ethtool_cmd *ecmd)\r\n{\r\nstruct amd8111e_priv *lp = netdev_priv(dev);\r\nspin_lock_irq(&lp->lock);\r\nmii_ethtool_gset(&lp->mii_if, ecmd);\r\nspin_unlock_irq(&lp->lock);\r\nreturn 0;\r\n}\r\nstatic int amd8111e_set_settings(struct net_device *dev, struct ethtool_cmd *ecmd)\r\n{\r\nstruct amd8111e_priv *lp = netdev_priv(dev);\r\nint res;\r\nspin_lock_irq(&lp->lock);\r\nres = mii_ethtool_sset(&lp->mii_if, ecmd);\r\nspin_unlock_irq(&lp->lock);\r\nreturn res;\r\n}\r\nstatic int amd8111e_nway_reset(struct net_device *dev)\r\n{\r\nstruct amd8111e_priv *lp = netdev_priv(dev);\r\nreturn mii_nway_restart(&lp->mii_if);\r\n}\r\nstatic u32 amd8111e_get_link(struct net_device *dev)\r\n{\r\nstruct amd8111e_priv *lp = netdev_priv(dev);\r\nreturn mii_link_ok(&lp->mii_if);\r\n}\r\nstatic void amd8111e_get_wol(struct net_device *dev, struct ethtool_wolinfo *wol_info)\r\n{\r\nstruct amd8111e_priv *lp = netdev_priv(dev);\r\nwol_info->supported = WAKE_MAGIC|WAKE_PHY;\r\nif (lp->options & OPTION_WOL_ENABLE)\r\nwol_info->wolopts = WAKE_MAGIC;\r\n}\r\nstatic int amd8111e_set_wol(struct net_device *dev, struct ethtool_wolinfo *wol_info)\r\n{\r\nstruct amd8111e_priv *lp = netdev_priv(dev);\r\nif (wol_info->wolopts & ~(WAKE_MAGIC|WAKE_PHY))\r\nreturn -EINVAL;\r\nspin_lock_irq(&lp->lock);\r\nif (wol_info->wolopts & WAKE_MAGIC)\r\nlp->options |=\r\n(OPTION_WOL_ENABLE | OPTION_WAKE_MAGIC_ENABLE);\r\nelse if(wol_info->wolopts & WAKE_PHY)\r\nlp->options |=\r\n(OPTION_WOL_ENABLE | OPTION_WAKE_PHY_ENABLE);\r\nelse\r\nlp->options &= ~OPTION_WOL_ENABLE;\r\nspin_unlock_irq(&lp->lock);\r\nreturn 0;\r\n}\r\nstatic int amd8111e_ioctl(struct net_device * dev , struct ifreq *ifr, int cmd)\r\n{\r\nstruct mii_ioctl_data *data = if_mii(ifr);\r\nstruct amd8111e_priv *lp = netdev_priv(dev);\r\nint err;\r\nu32 mii_regval;\r\nswitch(cmd) {\r\ncase SIOCGMIIPHY:\r\ndata->phy_id = lp->ext_phy_addr;\r\ncase SIOCGMIIREG:\r\nspin_lock_irq(&lp->lock);\r\nerr = amd8111e_read_phy(lp, data->phy_id,\r\ndata->reg_num & PHY_REG_ADDR_MASK, &mii_regval);\r\nspin_unlock_irq(&lp->lock);\r\ndata->val_out = mii_regval;\r\nreturn err;\r\ncase SIOCSMIIREG:\r\nspin_lock_irq(&lp->lock);\r\nerr = amd8111e_write_phy(lp, data->phy_id,\r\ndata->reg_num & PHY_REG_ADDR_MASK, data->val_in);\r\nspin_unlock_irq(&lp->lock);\r\nreturn err;\r\ndefault:\r\nbreak;\r\n}\r\nreturn -EOPNOTSUPP;\r\n}\r\nstatic int amd8111e_set_mac_address(struct net_device *dev, void *p)\r\n{\r\nstruct amd8111e_priv *lp = netdev_priv(dev);\r\nint i;\r\nstruct sockaddr *addr = p;\r\nmemcpy(dev->dev_addr, addr->sa_data, dev->addr_len);\r\nspin_lock_irq(&lp->lock);\r\nfor (i = 0; i < ETH_ALEN; i++)\r\nwriteb( dev->dev_addr[i], lp->mmio + PADR + i );\r\nspin_unlock_irq(&lp->lock);\r\nreturn 0;\r\n}\r\nstatic int amd8111e_change_mtu(struct net_device *dev, int new_mtu)\r\n{\r\nstruct amd8111e_priv *lp = netdev_priv(dev);\r\nint err;\r\nif ((new_mtu < AMD8111E_MIN_MTU) || (new_mtu > AMD8111E_MAX_MTU))\r\nreturn -EINVAL;\r\nif (!netif_running(dev)) {\r\ndev->mtu = new_mtu;\r\nreturn 0;\r\n}\r\nspin_lock_irq(&lp->lock);\r\nwritel(RUN, lp->mmio + CMD0);\r\ndev->mtu = new_mtu;\r\nerr = amd8111e_restart(dev);\r\nspin_unlock_irq(&lp->lock);\r\nif(!err)\r\nnetif_start_queue(dev);\r\nreturn err;\r\n}\r\nstatic int amd8111e_enable_magicpkt(struct amd8111e_priv* lp)\r\n{\r\nwritel( VAL1|MPPLBA, lp->mmio + CMD3);\r\nwritel( VAL0|MPEN_SW, lp->mmio + CMD7);\r\nreadl(lp->mmio + CMD7);\r\nreturn 0;\r\n}\r\nstatic int amd8111e_enable_link_change(struct amd8111e_priv* lp)\r\n{\r\nwritel(VAL0|LCMODE_SW,lp->mmio + CMD7);\r\nreadl(lp->mmio + CMD7);\r\nreturn 0;\r\n}\r\nstatic void amd8111e_tx_timeout(struct net_device *dev)\r\n{\r\nstruct amd8111e_priv* lp = netdev_priv(dev);\r\nint err;\r\nprintk(KERN_ERR "%s: transmit timed out, resetting\n",\r\ndev->name);\r\nspin_lock_irq(&lp->lock);\r\nerr = amd8111e_restart(dev);\r\nspin_unlock_irq(&lp->lock);\r\nif(!err)\r\nnetif_wake_queue(dev);\r\n}\r\nstatic int amd8111e_suspend(struct pci_dev *pci_dev, pm_message_t state)\r\n{\r\nstruct net_device *dev = pci_get_drvdata(pci_dev);\r\nstruct amd8111e_priv *lp = netdev_priv(dev);\r\nif (!netif_running(dev))\r\nreturn 0;\r\nspin_lock_irq(&lp->lock);\r\namd8111e_disable_interrupt(lp);\r\nspin_unlock_irq(&lp->lock);\r\nnetif_device_detach(dev);\r\nspin_lock_irq(&lp->lock);\r\nif(lp->options & OPTION_DYN_IPG_ENABLE)\r\ndel_timer_sync(&lp->ipg_data.ipg_timer);\r\namd8111e_stop_chip(lp);\r\nspin_unlock_irq(&lp->lock);\r\nif(lp->options & OPTION_WOL_ENABLE){\r\nif(lp->options & OPTION_WAKE_MAGIC_ENABLE)\r\namd8111e_enable_magicpkt(lp);\r\nif(lp->options & OPTION_WAKE_PHY_ENABLE)\r\namd8111e_enable_link_change(lp);\r\npci_enable_wake(pci_dev, PCI_D3hot, 1);\r\npci_enable_wake(pci_dev, PCI_D3cold, 1);\r\n}\r\nelse{\r\npci_enable_wake(pci_dev, PCI_D3hot, 0);\r\npci_enable_wake(pci_dev, PCI_D3cold, 0);\r\n}\r\npci_save_state(pci_dev);\r\npci_set_power_state(pci_dev, PCI_D3hot);\r\nreturn 0;\r\n}\r\nstatic int amd8111e_resume(struct pci_dev *pci_dev)\r\n{\r\nstruct net_device *dev = pci_get_drvdata(pci_dev);\r\nstruct amd8111e_priv *lp = netdev_priv(dev);\r\nif (!netif_running(dev))\r\nreturn 0;\r\npci_set_power_state(pci_dev, PCI_D0);\r\npci_restore_state(pci_dev);\r\npci_enable_wake(pci_dev, PCI_D3hot, 0);\r\npci_enable_wake(pci_dev, PCI_D3cold, 0);\r\nnetif_device_attach(dev);\r\nspin_lock_irq(&lp->lock);\r\namd8111e_restart(dev);\r\nif(lp->options & OPTION_DYN_IPG_ENABLE)\r\nmod_timer(&lp->ipg_data.ipg_timer,\r\njiffies + IPG_CONVERGE_JIFFIES);\r\nspin_unlock_irq(&lp->lock);\r\nreturn 0;\r\n}\r\nstatic void amd8111e_remove_one(struct pci_dev *pdev)\r\n{\r\nstruct net_device *dev = pci_get_drvdata(pdev);\r\nif (dev) {\r\nunregister_netdev(dev);\r\niounmap(((struct amd8111e_priv *)netdev_priv(dev))->mmio);\r\nfree_netdev(dev);\r\npci_release_regions(pdev);\r\npci_disable_device(pdev);\r\npci_set_drvdata(pdev, NULL);\r\n}\r\n}\r\nstatic void amd8111e_config_ipg(struct net_device* dev)\r\n{\r\nstruct amd8111e_priv *lp = netdev_priv(dev);\r\nstruct ipg_info* ipg_data = &lp->ipg_data;\r\nvoid __iomem *mmio = lp->mmio;\r\nunsigned int prev_col_cnt = ipg_data->col_cnt;\r\nunsigned int total_col_cnt;\r\nunsigned int tmp_ipg;\r\nif(lp->link_config.duplex == DUPLEX_FULL){\r\nipg_data->ipg = DEFAULT_IPG;\r\nreturn;\r\n}\r\nif(ipg_data->ipg_state == SSTATE){\r\nif(ipg_data->timer_tick == IPG_STABLE_TIME){\r\nipg_data->timer_tick = 0;\r\nipg_data->ipg = MIN_IPG - IPG_STEP;\r\nipg_data->current_ipg = MIN_IPG;\r\nipg_data->diff_col_cnt = 0xFFFFFFFF;\r\nipg_data->ipg_state = CSTATE;\r\n}\r\nelse\r\nipg_data->timer_tick++;\r\n}\r\nif(ipg_data->ipg_state == CSTATE){\r\ntotal_col_cnt = ipg_data->col_cnt =\r\namd8111e_read_mib(mmio, xmt_collisions);\r\nif ((total_col_cnt - prev_col_cnt) <\r\n(ipg_data->diff_col_cnt)){\r\nipg_data->diff_col_cnt =\r\ntotal_col_cnt - prev_col_cnt ;\r\nipg_data->ipg = ipg_data->current_ipg;\r\n}\r\nipg_data->current_ipg += IPG_STEP;\r\nif (ipg_data->current_ipg <= MAX_IPG)\r\ntmp_ipg = ipg_data->current_ipg;\r\nelse{\r\ntmp_ipg = ipg_data->ipg;\r\nipg_data->ipg_state = SSTATE;\r\n}\r\nwritew((u32)tmp_ipg, mmio + IPG);\r\nwritew((u32)(tmp_ipg - IFS1_DELTA), mmio + IFS1);\r\n}\r\nmod_timer(&lp->ipg_data.ipg_timer, jiffies + IPG_CONVERGE_JIFFIES);\r\nreturn;\r\n}\r\nstatic void amd8111e_probe_ext_phy(struct net_device *dev)\r\n{\r\nstruct amd8111e_priv *lp = netdev_priv(dev);\r\nint i;\r\nfor (i = 0x1e; i >= 0; i--) {\r\nu32 id1, id2;\r\nif (amd8111e_read_phy(lp, i, MII_PHYSID1, &id1))\r\ncontinue;\r\nif (amd8111e_read_phy(lp, i, MII_PHYSID2, &id2))\r\ncontinue;\r\nlp->ext_phy_id = (id1 << 16) | id2;\r\nlp->ext_phy_addr = i;\r\nreturn;\r\n}\r\nlp->ext_phy_id = 0;\r\nlp->ext_phy_addr = 1;\r\n}\r\nstatic int amd8111e_probe_one(struct pci_dev *pdev,\r\nconst struct pci_device_id *ent)\r\n{\r\nint err,i,pm_cap;\r\nunsigned long reg_addr,reg_len;\r\nstruct amd8111e_priv* lp;\r\nstruct net_device* dev;\r\nerr = pci_enable_device(pdev);\r\nif(err){\r\nprintk(KERN_ERR "amd8111e: Cannot enable new PCI device, "\r\n"exiting.\n");\r\nreturn err;\r\n}\r\nif(!(pci_resource_flags(pdev, 0) & IORESOURCE_MEM)){\r\nprintk(KERN_ERR "amd8111e: Cannot find PCI base address, "\r\n"exiting.\n");\r\nerr = -ENODEV;\r\ngoto err_disable_pdev;\r\n}\r\nerr = pci_request_regions(pdev, MODULE_NAME);\r\nif(err){\r\nprintk(KERN_ERR "amd8111e: Cannot obtain PCI resources, "\r\n"exiting.\n");\r\ngoto err_disable_pdev;\r\n}\r\npci_set_master(pdev);\r\nif((pm_cap = pci_find_capability(pdev, PCI_CAP_ID_PM))==0){\r\nprintk(KERN_ERR "amd8111e: No Power Management capability, "\r\n"exiting.\n");\r\nerr = -ENODEV;\r\ngoto err_free_reg;\r\n}\r\nif (pci_set_dma_mask(pdev, DMA_BIT_MASK(32)) < 0) {\r\nprintk(KERN_ERR "amd8111e: DMA not supported,"\r\n"exiting.\n");\r\nerr = -ENODEV;\r\ngoto err_free_reg;\r\n}\r\nreg_addr = pci_resource_start(pdev, 0);\r\nreg_len = pci_resource_len(pdev, 0);\r\ndev = alloc_etherdev(sizeof(struct amd8111e_priv));\r\nif (!dev) {\r\nerr = -ENOMEM;\r\ngoto err_free_reg;\r\n}\r\nSET_NETDEV_DEV(dev, &pdev->dev);\r\n#if AMD8111E_VLAN_TAG_USED\r\ndev->features |= NETIF_F_HW_VLAN_TX | NETIF_F_HW_VLAN_RX ;\r\n#endif\r\nlp = netdev_priv(dev);\r\nlp->pci_dev = pdev;\r\nlp->amd8111e_net_dev = dev;\r\nlp->pm_cap = pm_cap;\r\nspin_lock_init(&lp->lock);\r\nlp->mmio = ioremap(reg_addr, reg_len);\r\nif (!lp->mmio) {\r\nprintk(KERN_ERR "amd8111e: Cannot map device registers, "\r\n"exiting\n");\r\nerr = -ENOMEM;\r\ngoto err_free_dev;\r\n}\r\nfor (i = 0; i < ETH_ALEN; i++)\r\ndev->dev_addr[i] = readb(lp->mmio + PADR + i);\r\nlp->ext_phy_option = speed_duplex[card_idx];\r\nif(coalesce[card_idx])\r\nlp->options |= OPTION_INTR_COAL_ENABLE;\r\nif(dynamic_ipg[card_idx++])\r\nlp->options |= OPTION_DYN_IPG_ENABLE;\r\ndev->netdev_ops = &amd8111e_netdev_ops;\r\nSET_ETHTOOL_OPS(dev, &ops);\r\ndev->irq =pdev->irq;\r\ndev->watchdog_timeo = AMD8111E_TX_TIMEOUT;\r\nnetif_napi_add(dev, &lp->napi, amd8111e_rx_poll, 32);\r\n#if AMD8111E_VLAN_TAG_USED\r\ndev->features |= NETIF_F_HW_VLAN_TX | NETIF_F_HW_VLAN_RX;\r\n#endif\r\namd8111e_probe_ext_phy(dev);\r\nlp->mii_if.dev = dev;\r\nlp->mii_if.mdio_read = amd8111e_mdio_read;\r\nlp->mii_if.mdio_write = amd8111e_mdio_write;\r\nlp->mii_if.phy_id = lp->ext_phy_addr;\r\namd8111e_set_rx_buff_len(dev);\r\nerr = register_netdev(dev);\r\nif (err) {\r\nprintk(KERN_ERR "amd8111e: Cannot register net device, "\r\n"exiting.\n");\r\ngoto err_iounmap;\r\n}\r\npci_set_drvdata(pdev, dev);\r\nif(lp->options & OPTION_DYN_IPG_ENABLE){\r\ninit_timer(&lp->ipg_data.ipg_timer);\r\nlp->ipg_data.ipg_timer.data = (unsigned long) dev;\r\nlp->ipg_data.ipg_timer.function = (void *)&amd8111e_config_ipg;\r\nlp->ipg_data.ipg_timer.expires = jiffies +\r\nIPG_CONVERGE_JIFFIES;\r\nlp->ipg_data.ipg = DEFAULT_IPG;\r\nlp->ipg_data.ipg_state = CSTATE;\r\n}\r\nchip_version = (readl(lp->mmio + CHIPID) & 0xf0000000)>>28;\r\nprintk(KERN_INFO "%s: AMD-8111e Driver Version: %s\n",\r\ndev->name,MODULE_VERS);\r\nprintk(KERN_INFO "%s: [ Rev %x ] PCI 10/100BaseT Ethernet %pM\n",\r\ndev->name, chip_version, dev->dev_addr);\r\nif (lp->ext_phy_id)\r\nprintk(KERN_INFO "%s: Found MII PHY ID 0x%08x at address 0x%02x\n",\r\ndev->name, lp->ext_phy_id, lp->ext_phy_addr);\r\nelse\r\nprintk(KERN_INFO "%s: Couldn't detect MII PHY, assuming address 0x01\n",\r\ndev->name);\r\nreturn 0;\r\nerr_iounmap:\r\niounmap(lp->mmio);\r\nerr_free_dev:\r\nfree_netdev(dev);\r\nerr_free_reg:\r\npci_release_regions(pdev);\r\nerr_disable_pdev:\r\npci_disable_device(pdev);\r\npci_set_drvdata(pdev, NULL);\r\nreturn err;\r\n}\r\nstatic int __init amd8111e_init(void)\r\n{\r\nreturn pci_register_driver(&amd8111e_driver);\r\n}\r\nstatic void __exit amd8111e_cleanup(void)\r\n{\r\npci_unregister_driver(&amd8111e_driver);\r\n}
