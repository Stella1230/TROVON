static u32 *ps3vram_get_notifier(void *reports, int notifier)\r\n{\r\nreturn reports + DMA_NOTIFIER_OFFSET_BASE +\r\nDMA_NOTIFIER_SIZE * notifier;\r\n}\r\nstatic void ps3vram_notifier_reset(struct ps3_system_bus_device *dev)\r\n{\r\nstruct ps3vram_priv *priv = ps3_system_bus_get_drvdata(dev);\r\nu32 *notify = ps3vram_get_notifier(priv->reports, NOTIFIER);\r\nint i;\r\nfor (i = 0; i < 4; i++)\r\nnotify[i] = 0xffffffff;\r\n}\r\nstatic int ps3vram_notifier_wait(struct ps3_system_bus_device *dev,\r\nunsigned int timeout_ms)\r\n{\r\nstruct ps3vram_priv *priv = ps3_system_bus_get_drvdata(dev);\r\nu32 *notify = ps3vram_get_notifier(priv->reports, NOTIFIER);\r\nunsigned long timeout;\r\nfor (timeout = 20; timeout; timeout--) {\r\nif (!notify[3])\r\nreturn 0;\r\nudelay(10);\r\n}\r\ntimeout = jiffies + msecs_to_jiffies(timeout_ms);\r\ndo {\r\nif (!notify[3])\r\nreturn 0;\r\nmsleep(1);\r\n} while (time_before(jiffies, timeout));\r\nreturn -ETIMEDOUT;\r\n}\r\nstatic void ps3vram_init_ring(struct ps3_system_bus_device *dev)\r\n{\r\nstruct ps3vram_priv *priv = ps3_system_bus_get_drvdata(dev);\r\npriv->ctrl[CTRL_PUT] = FIFO_BASE + FIFO_OFFSET;\r\npriv->ctrl[CTRL_GET] = FIFO_BASE + FIFO_OFFSET;\r\n}\r\nstatic int ps3vram_wait_ring(struct ps3_system_bus_device *dev,\r\nunsigned int timeout_ms)\r\n{\r\nstruct ps3vram_priv *priv = ps3_system_bus_get_drvdata(dev);\r\nunsigned long timeout = jiffies + msecs_to_jiffies(timeout_ms);\r\ndo {\r\nif (priv->ctrl[CTRL_PUT] == priv->ctrl[CTRL_GET])\r\nreturn 0;\r\nmsleep(1);\r\n} while (time_before(jiffies, timeout));\r\ndev_warn(&dev->core, "FIFO timeout (%08x/%08x/%08x)\n",\r\npriv->ctrl[CTRL_PUT], priv->ctrl[CTRL_GET],\r\npriv->ctrl[CTRL_TOP]);\r\nreturn -ETIMEDOUT;\r\n}\r\nstatic void ps3vram_out_ring(struct ps3vram_priv *priv, u32 data)\r\n{\r\n*(priv->fifo_ptr)++ = data;\r\n}\r\nstatic void ps3vram_begin_ring(struct ps3vram_priv *priv, u32 chan, u32 tag,\r\nu32 size)\r\n{\r\nps3vram_out_ring(priv, (size << 18) | (chan << 13) | tag);\r\n}\r\nstatic void ps3vram_rewind_ring(struct ps3_system_bus_device *dev)\r\n{\r\nstruct ps3vram_priv *priv = ps3_system_bus_get_drvdata(dev);\r\nint status;\r\nps3vram_out_ring(priv, 0x20000000 | (FIFO_BASE + FIFO_OFFSET));\r\npriv->ctrl[CTRL_PUT] = FIFO_BASE + FIFO_OFFSET;\r\nstatus = lv1_gpu_fb_blit(priv->context_handle, 0, 0, 0, 0);\r\nif (status)\r\ndev_err(&dev->core, "%s: lv1_gpu_fb_blit failed %d\n",\r\n__func__, status);\r\npriv->fifo_ptr = priv->fifo_base;\r\n}\r\nstatic void ps3vram_fire_ring(struct ps3_system_bus_device *dev)\r\n{\r\nstruct ps3vram_priv *priv = ps3_system_bus_get_drvdata(dev);\r\nint status;\r\nmutex_lock(&ps3_gpu_mutex);\r\npriv->ctrl[CTRL_PUT] = FIFO_BASE + FIFO_OFFSET +\r\n(priv->fifo_ptr - priv->fifo_base) * sizeof(u32);\r\nstatus = lv1_gpu_fb_blit(priv->context_handle, 0, 0, 0, 0);\r\nif (status)\r\ndev_err(&dev->core, "%s: lv1_gpu_fb_blit failed %d\n",\r\n__func__, status);\r\nif ((priv->fifo_ptr - priv->fifo_base) * sizeof(u32) >\r\nFIFO_SIZE - 1024) {\r\ndev_dbg(&dev->core, "FIFO full, rewinding\n");\r\nps3vram_wait_ring(dev, 200);\r\nps3vram_rewind_ring(dev);\r\n}\r\nmutex_unlock(&ps3_gpu_mutex);\r\n}\r\nstatic void ps3vram_bind(struct ps3_system_bus_device *dev)\r\n{\r\nstruct ps3vram_priv *priv = ps3_system_bus_get_drvdata(dev);\r\nps3vram_begin_ring(priv, UPLOAD_SUBCH, 0, 1);\r\nps3vram_out_ring(priv, 0x31337303);\r\nps3vram_begin_ring(priv, UPLOAD_SUBCH, 0x180, 3);\r\nps3vram_out_ring(priv, DMA_NOTIFIER_HANDLE_BASE + NOTIFIER);\r\nps3vram_out_ring(priv, 0xfeed0001);\r\nps3vram_out_ring(priv, 0xfeed0000);\r\nps3vram_begin_ring(priv, DOWNLOAD_SUBCH, 0, 1);\r\nps3vram_out_ring(priv, 0x3137c0de);\r\nps3vram_begin_ring(priv, DOWNLOAD_SUBCH, 0x180, 3);\r\nps3vram_out_ring(priv, DMA_NOTIFIER_HANDLE_BASE + NOTIFIER);\r\nps3vram_out_ring(priv, 0xfeed0000);\r\nps3vram_out_ring(priv, 0xfeed0001);\r\nps3vram_fire_ring(dev);\r\n}\r\nstatic int ps3vram_upload(struct ps3_system_bus_device *dev,\r\nunsigned int src_offset, unsigned int dst_offset,\r\nint len, int count)\r\n{\r\nstruct ps3vram_priv *priv = ps3_system_bus_get_drvdata(dev);\r\nps3vram_begin_ring(priv, UPLOAD_SUBCH,\r\nNV_MEMORY_TO_MEMORY_FORMAT_OFFSET_IN, 8);\r\nps3vram_out_ring(priv, XDR_IOIF + src_offset);\r\nps3vram_out_ring(priv, dst_offset);\r\nps3vram_out_ring(priv, len);\r\nps3vram_out_ring(priv, len);\r\nps3vram_out_ring(priv, len);\r\nps3vram_out_ring(priv, count);\r\nps3vram_out_ring(priv, (1 << 8) | 1);\r\nps3vram_out_ring(priv, 0);\r\nps3vram_notifier_reset(dev);\r\nps3vram_begin_ring(priv, UPLOAD_SUBCH,\r\nNV_MEMORY_TO_MEMORY_FORMAT_NOTIFY, 1);\r\nps3vram_out_ring(priv, 0);\r\nps3vram_begin_ring(priv, UPLOAD_SUBCH, 0x100, 1);\r\nps3vram_out_ring(priv, 0);\r\nps3vram_fire_ring(dev);\r\nif (ps3vram_notifier_wait(dev, 200) < 0) {\r\ndev_warn(&dev->core, "%s: Notifier timeout\n", __func__);\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ps3vram_download(struct ps3_system_bus_device *dev,\r\nunsigned int src_offset, unsigned int dst_offset,\r\nint len, int count)\r\n{\r\nstruct ps3vram_priv *priv = ps3_system_bus_get_drvdata(dev);\r\nps3vram_begin_ring(priv, DOWNLOAD_SUBCH,\r\nNV_MEMORY_TO_MEMORY_FORMAT_OFFSET_IN, 8);\r\nps3vram_out_ring(priv, src_offset);\r\nps3vram_out_ring(priv, XDR_IOIF + dst_offset);\r\nps3vram_out_ring(priv, len);\r\nps3vram_out_ring(priv, len);\r\nps3vram_out_ring(priv, len);\r\nps3vram_out_ring(priv, count);\r\nps3vram_out_ring(priv, (1 << 8) | 1);\r\nps3vram_out_ring(priv, 0);\r\nps3vram_notifier_reset(dev);\r\nps3vram_begin_ring(priv, DOWNLOAD_SUBCH,\r\nNV_MEMORY_TO_MEMORY_FORMAT_NOTIFY, 1);\r\nps3vram_out_ring(priv, 0);\r\nps3vram_begin_ring(priv, DOWNLOAD_SUBCH, 0x100, 1);\r\nps3vram_out_ring(priv, 0);\r\nps3vram_fire_ring(dev);\r\nif (ps3vram_notifier_wait(dev, 200) < 0) {\r\ndev_warn(&dev->core, "%s: Notifier timeout\n", __func__);\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic void ps3vram_cache_evict(struct ps3_system_bus_device *dev, int entry)\r\n{\r\nstruct ps3vram_priv *priv = ps3_system_bus_get_drvdata(dev);\r\nstruct ps3vram_cache *cache = &priv->cache;\r\nif (!(cache->tags[entry].flags & CACHE_PAGE_DIRTY))\r\nreturn;\r\ndev_dbg(&dev->core, "Flushing %d: 0x%08x\n", entry,\r\ncache->tags[entry].address);\r\nif (ps3vram_upload(dev, CACHE_OFFSET + entry * cache->page_size,\r\ncache->tags[entry].address, DMA_PAGE_SIZE,\r\ncache->page_size / DMA_PAGE_SIZE) < 0) {\r\ndev_err(&dev->core,\r\n"Failed to upload from 0x%x to " "0x%x size 0x%x\n",\r\nentry * cache->page_size, cache->tags[entry].address,\r\ncache->page_size);\r\n}\r\ncache->tags[entry].flags &= ~CACHE_PAGE_DIRTY;\r\n}\r\nstatic void ps3vram_cache_load(struct ps3_system_bus_device *dev, int entry,\r\nunsigned int address)\r\n{\r\nstruct ps3vram_priv *priv = ps3_system_bus_get_drvdata(dev);\r\nstruct ps3vram_cache *cache = &priv->cache;\r\ndev_dbg(&dev->core, "Fetching %d: 0x%08x\n", entry, address);\r\nif (ps3vram_download(dev, address,\r\nCACHE_OFFSET + entry * cache->page_size,\r\nDMA_PAGE_SIZE,\r\ncache->page_size / DMA_PAGE_SIZE) < 0) {\r\ndev_err(&dev->core,\r\n"Failed to download from 0x%x to 0x%x size 0x%x\n",\r\naddress, entry * cache->page_size, cache->page_size);\r\n}\r\ncache->tags[entry].address = address;\r\ncache->tags[entry].flags |= CACHE_PAGE_PRESENT;\r\n}\r\nstatic void ps3vram_cache_flush(struct ps3_system_bus_device *dev)\r\n{\r\nstruct ps3vram_priv *priv = ps3_system_bus_get_drvdata(dev);\r\nstruct ps3vram_cache *cache = &priv->cache;\r\nint i;\r\ndev_dbg(&dev->core, "FLUSH\n");\r\nfor (i = 0; i < cache->page_count; i++) {\r\nps3vram_cache_evict(dev, i);\r\ncache->tags[i].flags = 0;\r\n}\r\n}\r\nstatic unsigned int ps3vram_cache_match(struct ps3_system_bus_device *dev,\r\nloff_t address)\r\n{\r\nstruct ps3vram_priv *priv = ps3_system_bus_get_drvdata(dev);\r\nstruct ps3vram_cache *cache = &priv->cache;\r\nunsigned int base;\r\nunsigned int offset;\r\nint i;\r\nstatic int counter;\r\noffset = (unsigned int) (address & (cache->page_size - 1));\r\nbase = (unsigned int) (address - offset);\r\nfor (i = 0; i < cache->page_count; i++) {\r\nif ((cache->tags[i].flags & CACHE_PAGE_PRESENT) &&\r\ncache->tags[i].address == base) {\r\ncache->hit++;\r\ndev_dbg(&dev->core, "Found entry %d: 0x%08x\n", i,\r\ncache->tags[i].address);\r\nreturn i;\r\n}\r\n}\r\ni = (jiffies + (counter++)) % cache->page_count;\r\ndev_dbg(&dev->core, "Using entry %d\n", i);\r\nps3vram_cache_evict(dev, i);\r\nps3vram_cache_load(dev, i, base);\r\ncache->miss++;\r\nreturn i;\r\n}\r\nstatic int ps3vram_cache_init(struct ps3_system_bus_device *dev)\r\n{\r\nstruct ps3vram_priv *priv = ps3_system_bus_get_drvdata(dev);\r\npriv->cache.page_count = CACHE_PAGE_COUNT;\r\npriv->cache.page_size = CACHE_PAGE_SIZE;\r\npriv->cache.tags = kzalloc(sizeof(struct ps3vram_tag) *\r\nCACHE_PAGE_COUNT, GFP_KERNEL);\r\nif (priv->cache.tags == NULL) {\r\ndev_err(&dev->core, "Could not allocate cache tags\n");\r\nreturn -ENOMEM;\r\n}\r\ndev_info(&dev->core, "Created ram cache: %d entries, %d KiB each\n",\r\nCACHE_PAGE_COUNT, CACHE_PAGE_SIZE / 1024);\r\nreturn 0;\r\n}\r\nstatic void ps3vram_cache_cleanup(struct ps3_system_bus_device *dev)\r\n{\r\nstruct ps3vram_priv *priv = ps3_system_bus_get_drvdata(dev);\r\nps3vram_cache_flush(dev);\r\nkfree(priv->cache.tags);\r\n}\r\nstatic int ps3vram_read(struct ps3_system_bus_device *dev, loff_t from,\r\nsize_t len, size_t *retlen, u_char *buf)\r\n{\r\nstruct ps3vram_priv *priv = ps3_system_bus_get_drvdata(dev);\r\nunsigned int cached, count;\r\ndev_dbg(&dev->core, "%s: from=0x%08x len=0x%zx\n", __func__,\r\n(unsigned int)from, len);\r\nif (from >= priv->size)\r\nreturn -EIO;\r\nif (len > priv->size - from)\r\nlen = priv->size - from;\r\ncount = len;\r\nwhile (count) {\r\nunsigned int offset, avail;\r\nunsigned int entry;\r\noffset = (unsigned int) (from & (priv->cache.page_size - 1));\r\navail = priv->cache.page_size - offset;\r\nentry = ps3vram_cache_match(dev, from);\r\ncached = CACHE_OFFSET + entry * priv->cache.page_size + offset;\r\ndev_dbg(&dev->core, "%s: from=%08x cached=%08x offset=%08x "\r\n"avail=%08x count=%08x\n", __func__,\r\n(unsigned int)from, cached, offset, avail, count);\r\nif (avail > count)\r\navail = count;\r\nmemcpy(buf, priv->xdr_buf + cached, avail);\r\nbuf += avail;\r\ncount -= avail;\r\nfrom += avail;\r\n}\r\n*retlen = len;\r\nreturn 0;\r\n}\r\nstatic int ps3vram_write(struct ps3_system_bus_device *dev, loff_t to,\r\nsize_t len, size_t *retlen, const u_char *buf)\r\n{\r\nstruct ps3vram_priv *priv = ps3_system_bus_get_drvdata(dev);\r\nunsigned int cached, count;\r\nif (to >= priv->size)\r\nreturn -EIO;\r\nif (len > priv->size - to)\r\nlen = priv->size - to;\r\ncount = len;\r\nwhile (count) {\r\nunsigned int offset, avail;\r\nunsigned int entry;\r\noffset = (unsigned int) (to & (priv->cache.page_size - 1));\r\navail = priv->cache.page_size - offset;\r\nentry = ps3vram_cache_match(dev, to);\r\ncached = CACHE_OFFSET + entry * priv->cache.page_size + offset;\r\ndev_dbg(&dev->core, "%s: to=%08x cached=%08x offset=%08x "\r\n"avail=%08x count=%08x\n", __func__, (unsigned int)to,\r\ncached, offset, avail, count);\r\nif (avail > count)\r\navail = count;\r\nmemcpy(priv->xdr_buf + cached, buf, avail);\r\npriv->cache.tags[entry].flags |= CACHE_PAGE_DIRTY;\r\nbuf += avail;\r\ncount -= avail;\r\nto += avail;\r\n}\r\n*retlen = len;\r\nreturn 0;\r\n}\r\nstatic int ps3vram_proc_show(struct seq_file *m, void *v)\r\n{\r\nstruct ps3vram_priv *priv = m->private;\r\nseq_printf(m, "hit:%u\nmiss:%u\n", priv->cache.hit, priv->cache.miss);\r\nreturn 0;\r\n}\r\nstatic int ps3vram_proc_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, ps3vram_proc_show, PDE(inode)->data);\r\n}\r\nstatic void ps3vram_proc_init(struct ps3_system_bus_device *dev)\r\n{\r\nstruct ps3vram_priv *priv = ps3_system_bus_get_drvdata(dev);\r\nstruct proc_dir_entry *pde;\r\npde = proc_create_data(DEVICE_NAME, 0444, NULL, &ps3vram_proc_fops,\r\npriv);\r\nif (!pde)\r\ndev_warn(&dev->core, "failed to create /proc entry\n");\r\n}\r\nstatic struct bio *ps3vram_do_bio(struct ps3_system_bus_device *dev,\r\nstruct bio *bio)\r\n{\r\nstruct ps3vram_priv *priv = ps3_system_bus_get_drvdata(dev);\r\nint write = bio_data_dir(bio) == WRITE;\r\nconst char *op = write ? "write" : "read";\r\nloff_t offset = bio->bi_sector << 9;\r\nint error = 0;\r\nstruct bio_vec *bvec;\r\nunsigned int i;\r\nstruct bio *next;\r\nbio_for_each_segment(bvec, bio, i) {\r\nchar *ptr = page_address(bvec->bv_page) + bvec->bv_offset;\r\nsize_t len = bvec->bv_len, retlen;\r\ndev_dbg(&dev->core, " %s %zu bytes at offset %llu\n", op,\r\nlen, offset);\r\nif (write)\r\nerror = ps3vram_write(dev, offset, len, &retlen, ptr);\r\nelse\r\nerror = ps3vram_read(dev, offset, len, &retlen, ptr);\r\nif (error) {\r\ndev_err(&dev->core, "%s failed\n", op);\r\ngoto out;\r\n}\r\nif (retlen != len) {\r\ndev_err(&dev->core, "Short %s\n", op);\r\nerror = -EIO;\r\ngoto out;\r\n}\r\noffset += len;\r\n}\r\ndev_dbg(&dev->core, "%s completed\n", op);\r\nout:\r\nspin_lock_irq(&priv->lock);\r\nbio_list_pop(&priv->list);\r\nnext = bio_list_peek(&priv->list);\r\nspin_unlock_irq(&priv->lock);\r\nbio_endio(bio, error);\r\nreturn next;\r\n}\r\nstatic void ps3vram_make_request(struct request_queue *q, struct bio *bio)\r\n{\r\nstruct ps3_system_bus_device *dev = q->queuedata;\r\nstruct ps3vram_priv *priv = ps3_system_bus_get_drvdata(dev);\r\nint busy;\r\ndev_dbg(&dev->core, "%s\n", __func__);\r\nspin_lock_irq(&priv->lock);\r\nbusy = !bio_list_empty(&priv->list);\r\nbio_list_add(&priv->list, bio);\r\nspin_unlock_irq(&priv->lock);\r\nif (busy)\r\nreturn;\r\ndo {\r\nbio = ps3vram_do_bio(dev, bio);\r\n} while (bio);\r\n}\r\nstatic int ps3vram_probe(struct ps3_system_bus_device *dev)\r\n{\r\nstruct ps3vram_priv *priv;\r\nint error, status;\r\nstruct request_queue *queue;\r\nstruct gendisk *gendisk;\r\nu64 ddr_size, ddr_lpar, ctrl_lpar, info_lpar, reports_lpar,\r\nreports_size, xdr_lpar;\r\nchar *rest;\r\npriv = kzalloc(sizeof(*priv), GFP_KERNEL);\r\nif (!priv) {\r\nerror = -ENOMEM;\r\ngoto fail;\r\n}\r\nspin_lock_init(&priv->lock);\r\nbio_list_init(&priv->list);\r\nps3_system_bus_set_drvdata(dev, priv);\r\npriv->xdr_buf = (void *)__get_free_pages(GFP_KERNEL,\r\nget_order(XDR_BUF_SIZE));\r\nif (priv->xdr_buf == NULL) {\r\ndev_err(&dev->core, "Could not allocate XDR buffer\n");\r\nerror = -ENOMEM;\r\ngoto fail_free_priv;\r\n}\r\npriv->fifo_base = (u32 *) (priv->xdr_buf + FIFO_OFFSET);\r\npriv->fifo_ptr = priv->fifo_base;\r\nif (ps3_open_hv_device(dev)) {\r\ndev_err(&dev->core, "ps3_open_hv_device failed\n");\r\nerror = -EAGAIN;\r\ngoto out_free_xdr_buf;\r\n}\r\nstatus = -1;\r\nddr_size = ALIGN(memparse(size, &rest), 1024*1024);\r\nif (!ddr_size) {\r\ndev_err(&dev->core, "Specified size is too small\n");\r\nerror = -EINVAL;\r\ngoto out_close_gpu;\r\n}\r\nwhile (ddr_size > 0) {\r\nstatus = lv1_gpu_memory_allocate(ddr_size, 0, 0, 0, 0,\r\n&priv->memory_handle,\r\n&ddr_lpar);\r\nif (!status)\r\nbreak;\r\nddr_size -= 1024*1024;\r\n}\r\nif (status) {\r\ndev_err(&dev->core, "lv1_gpu_memory_allocate failed %d\n",\r\nstatus);\r\nerror = -ENOMEM;\r\ngoto out_close_gpu;\r\n}\r\nstatus = lv1_gpu_context_allocate(priv->memory_handle, 0,\r\n&priv->context_handle, &ctrl_lpar,\r\n&info_lpar, &reports_lpar,\r\n&reports_size);\r\nif (status) {\r\ndev_err(&dev->core, "lv1_gpu_context_allocate failed %d\n",\r\nstatus);\r\nerror = -ENOMEM;\r\ngoto out_free_memory;\r\n}\r\nxdr_lpar = ps3_mm_phys_to_lpar(__pa(priv->xdr_buf));\r\nstatus = lv1_gpu_context_iomap(priv->context_handle, XDR_IOIF,\r\nxdr_lpar, XDR_BUF_SIZE,\r\nCBE_IOPTE_PP_W | CBE_IOPTE_PP_R |\r\nCBE_IOPTE_M);\r\nif (status) {\r\ndev_err(&dev->core, "lv1_gpu_context_iomap failed %d\n",\r\nstatus);\r\nerror = -ENOMEM;\r\ngoto out_free_context;\r\n}\r\npriv->ctrl = ioremap(ctrl_lpar, 64 * 1024);\r\nif (!priv->ctrl) {\r\ndev_err(&dev->core, "ioremap CTRL failed\n");\r\nerror = -ENOMEM;\r\ngoto out_unmap_context;\r\n}\r\npriv->reports = ioremap(reports_lpar, reports_size);\r\nif (!priv->reports) {\r\ndev_err(&dev->core, "ioremap REPORTS failed\n");\r\nerror = -ENOMEM;\r\ngoto out_unmap_ctrl;\r\n}\r\nmutex_lock(&ps3_gpu_mutex);\r\nps3vram_init_ring(dev);\r\nmutex_unlock(&ps3_gpu_mutex);\r\npriv->size = ddr_size;\r\nps3vram_bind(dev);\r\nmutex_lock(&ps3_gpu_mutex);\r\nerror = ps3vram_wait_ring(dev, 100);\r\nmutex_unlock(&ps3_gpu_mutex);\r\nif (error < 0) {\r\ndev_err(&dev->core, "Failed to initialize channels\n");\r\nerror = -ETIMEDOUT;\r\ngoto out_unmap_reports;\r\n}\r\nps3vram_cache_init(dev);\r\nps3vram_proc_init(dev);\r\nqueue = blk_alloc_queue(GFP_KERNEL);\r\nif (!queue) {\r\ndev_err(&dev->core, "blk_alloc_queue failed\n");\r\nerror = -ENOMEM;\r\ngoto out_cache_cleanup;\r\n}\r\npriv->queue = queue;\r\nqueue->queuedata = dev;\r\nblk_queue_make_request(queue, ps3vram_make_request);\r\nblk_queue_max_segments(queue, BLK_MAX_SEGMENTS);\r\nblk_queue_max_segment_size(queue, BLK_MAX_SEGMENT_SIZE);\r\nblk_queue_max_hw_sectors(queue, BLK_SAFE_MAX_SECTORS);\r\ngendisk = alloc_disk(1);\r\nif (!gendisk) {\r\ndev_err(&dev->core, "alloc_disk failed\n");\r\nerror = -ENOMEM;\r\ngoto fail_cleanup_queue;\r\n}\r\npriv->gendisk = gendisk;\r\ngendisk->major = ps3vram_major;\r\ngendisk->first_minor = 0;\r\ngendisk->fops = &ps3vram_fops;\r\ngendisk->queue = queue;\r\ngendisk->private_data = dev;\r\ngendisk->driverfs_dev = &dev->core;\r\nstrlcpy(gendisk->disk_name, DEVICE_NAME, sizeof(gendisk->disk_name));\r\nset_capacity(gendisk, priv->size >> 9);\r\ndev_info(&dev->core, "%s: Using %lu MiB of GPU memory\n",\r\ngendisk->disk_name, get_capacity(gendisk) >> 11);\r\nadd_disk(gendisk);\r\nreturn 0;\r\nfail_cleanup_queue:\r\nblk_cleanup_queue(queue);\r\nout_cache_cleanup:\r\nremove_proc_entry(DEVICE_NAME, NULL);\r\nps3vram_cache_cleanup(dev);\r\nout_unmap_reports:\r\niounmap(priv->reports);\r\nout_unmap_ctrl:\r\niounmap(priv->ctrl);\r\nout_unmap_context:\r\nlv1_gpu_context_iomap(priv->context_handle, XDR_IOIF, xdr_lpar,\r\nXDR_BUF_SIZE, CBE_IOPTE_M);\r\nout_free_context:\r\nlv1_gpu_context_free(priv->context_handle);\r\nout_free_memory:\r\nlv1_gpu_memory_free(priv->memory_handle);\r\nout_close_gpu:\r\nps3_close_hv_device(dev);\r\nout_free_xdr_buf:\r\nfree_pages((unsigned long) priv->xdr_buf, get_order(XDR_BUF_SIZE));\r\nfail_free_priv:\r\nkfree(priv);\r\nps3_system_bus_set_drvdata(dev, NULL);\r\nfail:\r\nreturn error;\r\n}\r\nstatic int ps3vram_remove(struct ps3_system_bus_device *dev)\r\n{\r\nstruct ps3vram_priv *priv = ps3_system_bus_get_drvdata(dev);\r\ndel_gendisk(priv->gendisk);\r\nput_disk(priv->gendisk);\r\nblk_cleanup_queue(priv->queue);\r\nremove_proc_entry(DEVICE_NAME, NULL);\r\nps3vram_cache_cleanup(dev);\r\niounmap(priv->reports);\r\niounmap(priv->ctrl);\r\nlv1_gpu_context_iomap(priv->context_handle, XDR_IOIF,\r\nps3_mm_phys_to_lpar(__pa(priv->xdr_buf)),\r\nXDR_BUF_SIZE, CBE_IOPTE_M);\r\nlv1_gpu_context_free(priv->context_handle);\r\nlv1_gpu_memory_free(priv->memory_handle);\r\nps3_close_hv_device(dev);\r\nfree_pages((unsigned long) priv->xdr_buf, get_order(XDR_BUF_SIZE));\r\nkfree(priv);\r\nps3_system_bus_set_drvdata(dev, NULL);\r\nreturn 0;\r\n}\r\nstatic int __init ps3vram_init(void)\r\n{\r\nint error;\r\nif (!firmware_has_feature(FW_FEATURE_PS3_LV1))\r\nreturn -ENODEV;\r\nerror = register_blkdev(0, DEVICE_NAME);\r\nif (error <= 0) {\r\npr_err("%s: register_blkdev failed %d\n", DEVICE_NAME, error);\r\nreturn error;\r\n}\r\nps3vram_major = error;\r\npr_info("%s: registered block device major %d\n", DEVICE_NAME,\r\nps3vram_major);\r\nerror = ps3_system_bus_driver_register(&ps3vram);\r\nif (error)\r\nunregister_blkdev(ps3vram_major, DEVICE_NAME);\r\nreturn error;\r\n}\r\nstatic void __exit ps3vram_exit(void)\r\n{\r\nps3_system_bus_driver_unregister(&ps3vram);\r\nunregister_blkdev(ps3vram_major, DEVICE_NAME);\r\n}
