static void set_inverse_transl(struct vc_data *conp, struct uni_pagedir *p, int i)\r\n{\r\nint j, glyph;\r\nunsigned short *t = translations[i];\r\nunsigned char *q;\r\nif (!p) return;\r\nq = p->inverse_translations[i];\r\nif (!q) {\r\nq = p->inverse_translations[i] = (unsigned char *)\r\nkmalloc(MAX_GLYPH, GFP_KERNEL);\r\nif (!q) return;\r\n}\r\nmemset(q, 0, MAX_GLYPH);\r\nfor (j = 0; j < E_TABSZ; j++) {\r\nglyph = conv_uni_to_pc(conp, t[j]);\r\nif (glyph >= 0 && glyph < MAX_GLYPH && q[glyph] < 32) {\r\nq[glyph] = j;\r\n}\r\n}\r\n}\r\nstatic void set_inverse_trans_unicode(struct vc_data *conp,\r\nstruct uni_pagedir *p)\r\n{\r\nint i, j, k, glyph;\r\nu16 **p1, *p2;\r\nu16 *q;\r\nif (!p) return;\r\nq = p->inverse_trans_unicode;\r\nif (!q) {\r\nq = p->inverse_trans_unicode =\r\nkmalloc(MAX_GLYPH * sizeof(u16), GFP_KERNEL);\r\nif (!q)\r\nreturn;\r\n}\r\nmemset(q, 0, MAX_GLYPH * sizeof(u16));\r\nfor (i = 0; i < 32; i++) {\r\np1 = p->uni_pgdir[i];\r\nif (!p1)\r\ncontinue;\r\nfor (j = 0; j < 32; j++) {\r\np2 = p1[j];\r\nif (!p2)\r\ncontinue;\r\nfor (k = 0; k < 64; k++) {\r\nglyph = p2[k];\r\nif (glyph >= 0 && glyph < MAX_GLYPH\r\n&& q[glyph] < 32)\r\nq[glyph] = (i << 11) + (j << 6) + k;\r\n}\r\n}\r\n}\r\n}\r\nunsigned short *set_translate(int m, struct vc_data *vc)\r\n{\r\ninv_translate[vc->vc_num] = m;\r\nreturn translations[m];\r\n}\r\nu16 inverse_translate(struct vc_data *conp, int glyph, int use_unicode)\r\n{\r\nstruct uni_pagedir *p;\r\nint m;\r\nif (glyph < 0 || glyph >= MAX_GLYPH)\r\nreturn 0;\r\nelse if (!(p = (struct uni_pagedir *)*conp->vc_uni_pagedir_loc))\r\nreturn glyph;\r\nelse if (use_unicode) {\r\nif (!p->inverse_trans_unicode)\r\nreturn glyph;\r\nelse\r\nreturn p->inverse_trans_unicode[glyph];\r\n} else {\r\nm = inv_translate[conp->vc_num];\r\nif (!p->inverse_translations[m])\r\nreturn glyph;\r\nelse\r\nreturn p->inverse_translations[m][glyph];\r\n}\r\n}\r\nstatic void update_user_maps(void)\r\n{\r\nint i;\r\nstruct uni_pagedir *p, *q = NULL;\r\nfor (i = 0; i < MAX_NR_CONSOLES; i++) {\r\nif (!vc_cons_allocated(i))\r\ncontinue;\r\np = (struct uni_pagedir *)*vc_cons[i].d->vc_uni_pagedir_loc;\r\nif (p && p != q) {\r\nset_inverse_transl(vc_cons[i].d, p, USER_MAP);\r\nset_inverse_trans_unicode(vc_cons[i].d, p);\r\nq = p;\r\n}\r\n}\r\n}\r\nint con_set_trans_old(unsigned char __user * arg)\r\n{\r\nint i;\r\nunsigned short *p = translations[USER_MAP];\r\nif (!access_ok(VERIFY_READ, arg, E_TABSZ))\r\nreturn -EFAULT;\r\nconsole_lock();\r\nfor (i=0; i<E_TABSZ ; i++) {\r\nunsigned char uc;\r\n__get_user(uc, arg+i);\r\np[i] = UNI_DIRECT_BASE | uc;\r\n}\r\nupdate_user_maps();\r\nconsole_unlock();\r\nreturn 0;\r\n}\r\nint con_get_trans_old(unsigned char __user * arg)\r\n{\r\nint i, ch;\r\nunsigned short *p = translations[USER_MAP];\r\nif (!access_ok(VERIFY_WRITE, arg, E_TABSZ))\r\nreturn -EFAULT;\r\nconsole_lock();\r\nfor (i=0; i<E_TABSZ ; i++)\r\n{\r\nch = conv_uni_to_pc(vc_cons[fg_console].d, p[i]);\r\n__put_user((ch & ~0xff) ? 0 : ch, arg+i);\r\n}\r\nconsole_unlock();\r\nreturn 0;\r\n}\r\nint con_set_trans_new(ushort __user * arg)\r\n{\r\nint i;\r\nunsigned short *p = translations[USER_MAP];\r\nif (!access_ok(VERIFY_READ, arg, E_TABSZ*sizeof(unsigned short)))\r\nreturn -EFAULT;\r\nconsole_lock();\r\nfor (i=0; i<E_TABSZ ; i++) {\r\nunsigned short us;\r\n__get_user(us, arg+i);\r\np[i] = us;\r\n}\r\nupdate_user_maps();\r\nconsole_unlock();\r\nreturn 0;\r\n}\r\nint con_get_trans_new(ushort __user * arg)\r\n{\r\nint i;\r\nunsigned short *p = translations[USER_MAP];\r\nif (!access_ok(VERIFY_WRITE, arg, E_TABSZ*sizeof(unsigned short)))\r\nreturn -EFAULT;\r\nconsole_lock();\r\nfor (i=0; i<E_TABSZ ; i++)\r\n__put_user(p[i], arg+i);\r\nconsole_unlock();\r\nreturn 0;\r\n}\r\nstatic void con_release_unimap(struct uni_pagedir *p)\r\n{\r\nu16 **p1;\r\nint i, j;\r\nif (p == dflt) dflt = NULL;\r\nfor (i = 0; i < 32; i++) {\r\nif ((p1 = p->uni_pgdir[i]) != NULL) {\r\nfor (j = 0; j < 32; j++)\r\nkfree(p1[j]);\r\nkfree(p1);\r\n}\r\np->uni_pgdir[i] = NULL;\r\n}\r\nfor (i = 0; i < 4; i++) {\r\nkfree(p->inverse_translations[i]);\r\np->inverse_translations[i] = NULL;\r\n}\r\nkfree(p->inverse_trans_unicode);\r\np->inverse_trans_unicode = NULL;\r\n}\r\nvoid con_free_unimap(struct vc_data *vc)\r\n{\r\nstruct uni_pagedir *p;\r\np = (struct uni_pagedir *)*vc->vc_uni_pagedir_loc;\r\nif (!p)\r\nreturn;\r\n*vc->vc_uni_pagedir_loc = 0;\r\nif (--p->refcount)\r\nreturn;\r\ncon_release_unimap(p);\r\nkfree(p);\r\n}\r\nstatic int con_unify_unimap(struct vc_data *conp, struct uni_pagedir *p)\r\n{\r\nint i, j, k;\r\nstruct uni_pagedir *q;\r\nfor (i = 0; i < MAX_NR_CONSOLES; i++) {\r\nif (!vc_cons_allocated(i))\r\ncontinue;\r\nq = (struct uni_pagedir *)*vc_cons[i].d->vc_uni_pagedir_loc;\r\nif (!q || q == p || q->sum != p->sum)\r\ncontinue;\r\nfor (j = 0; j < 32; j++) {\r\nu16 **p1, **q1;\r\np1 = p->uni_pgdir[j]; q1 = q->uni_pgdir[j];\r\nif (!p1 && !q1)\r\ncontinue;\r\nif (!p1 || !q1)\r\nbreak;\r\nfor (k = 0; k < 32; k++) {\r\nif (!p1[k] && !q1[k])\r\ncontinue;\r\nif (!p1[k] || !q1[k])\r\nbreak;\r\nif (memcmp(p1[k], q1[k], 64*sizeof(u16)))\r\nbreak;\r\n}\r\nif (k < 32)\r\nbreak;\r\n}\r\nif (j == 32) {\r\nq->refcount++;\r\n*conp->vc_uni_pagedir_loc = (unsigned long)q;\r\ncon_release_unimap(p);\r\nkfree(p);\r\nreturn 1;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\ncon_insert_unipair(struct uni_pagedir *p, u_short unicode, u_short fontpos)\r\n{\r\nint i, n;\r\nu16 **p1, *p2;\r\nif (!(p1 = p->uni_pgdir[n = unicode >> 11])) {\r\np1 = p->uni_pgdir[n] = kmalloc(32*sizeof(u16 *), GFP_KERNEL);\r\nif (!p1) return -ENOMEM;\r\nfor (i = 0; i < 32; i++)\r\np1[i] = NULL;\r\n}\r\nif (!(p2 = p1[n = (unicode >> 6) & 0x1f])) {\r\np2 = p1[n] = kmalloc(64*sizeof(u16), GFP_KERNEL);\r\nif (!p2) return -ENOMEM;\r\nmemset(p2, 0xff, 64*sizeof(u16));\r\n}\r\np2[unicode & 0x3f] = fontpos;\r\np->sum += (fontpos << 20) + unicode;\r\nreturn 0;\r\n}\r\nstatic int con_do_clear_unimap(struct vc_data *vc, struct unimapinit *ui)\r\n{\r\nstruct uni_pagedir *p, *q;\r\np = (struct uni_pagedir *)*vc->vc_uni_pagedir_loc;\r\nif (p && p->readonly)\r\nreturn -EIO;\r\nif (!p || --p->refcount) {\r\nq = kzalloc(sizeof(*p), GFP_KERNEL);\r\nif (!q) {\r\nif (p)\r\np->refcount++;\r\nreturn -ENOMEM;\r\n}\r\nq->refcount=1;\r\n*vc->vc_uni_pagedir_loc = (unsigned long)q;\r\n} else {\r\nif (p == dflt) dflt = NULL;\r\np->refcount++;\r\np->sum = 0;\r\ncon_release_unimap(p);\r\n}\r\nreturn 0;\r\n}\r\nint con_clear_unimap(struct vc_data *vc, struct unimapinit *ui)\r\n{\r\nint ret;\r\nconsole_lock();\r\nret = con_do_clear_unimap(vc, ui);\r\nconsole_unlock();\r\nreturn ret;\r\n}\r\nint con_set_unimap(struct vc_data *vc, ushort ct, struct unipair __user *list)\r\n{\r\nint err = 0, err1, i;\r\nstruct uni_pagedir *p, *q;\r\nconsole_lock();\r\np = (struct uni_pagedir *)*vc->vc_uni_pagedir_loc;\r\nif (p->readonly) {\r\nconsole_unlock();\r\nreturn -EIO;\r\n}\r\nif (!ct) {\r\nconsole_unlock();\r\nreturn 0;\r\n}\r\nif (p->refcount > 1) {\r\nint j, k;\r\nu16 **p1, *p2, l;\r\nerr1 = con_do_clear_unimap(vc, NULL);\r\nif (err1) {\r\nconsole_unlock();\r\nreturn err1;\r\n}\r\nq = (struct uni_pagedir *)*vc->vc_uni_pagedir_loc;\r\nl = 0;\r\nfor (i = 0; i < 32; i++)\r\nif ((p1 = p->uni_pgdir[i]))\r\nfor (j = 0; j < 32; j++)\r\nif ((p2 = p1[j])) {\r\nfor (k = 0; k < 64; k++, l++)\r\nif (p2[k] != 0xffff) {\r\nerr1 = con_insert_unipair(q, l, p2[k]);\r\nif (err1) {\r\np->refcount++;\r\n*vc->vc_uni_pagedir_loc = (unsigned long)p;\r\ncon_release_unimap(q);\r\nkfree(q);\r\nconsole_unlock();\r\nreturn err1;\r\n}\r\n}\r\n} else {\r\nl += 64;\r\n}\r\nelse\r\nl += 32 * 64;\r\np = q;\r\n} else if (p == dflt) {\r\ndflt = NULL;\r\n}\r\nwhile (ct--) {\r\nunsigned short unicode, fontpos;\r\n__get_user(unicode, &list->unicode);\r\n__get_user(fontpos, &list->fontpos);\r\nif ((err1 = con_insert_unipair(p, unicode,fontpos)) != 0)\r\nerr = err1;\r\nlist++;\r\n}\r\nif (con_unify_unimap(vc, p)) {\r\nconsole_unlock();\r\nreturn err;\r\n}\r\nfor (i = 0; i <= 3; i++)\r\nset_inverse_transl(vc, p, i);\r\nset_inverse_trans_unicode(vc, p);\r\nconsole_unlock();\r\nreturn err;\r\n}\r\nint con_set_default_unimap(struct vc_data *vc)\r\n{\r\nint i, j, err = 0, err1;\r\nu16 *q;\r\nstruct uni_pagedir *p;\r\nif (dflt) {\r\np = (struct uni_pagedir *)*vc->vc_uni_pagedir_loc;\r\nif (p == dflt)\r\nreturn 0;\r\ndflt->refcount++;\r\n*vc->vc_uni_pagedir_loc = (unsigned long)dflt;\r\nif (p && !--p->refcount) {\r\ncon_release_unimap(p);\r\nkfree(p);\r\n}\r\nreturn 0;\r\n}\r\nerr = con_do_clear_unimap(vc, NULL);\r\nif (err)\r\nreturn err;\r\np = (struct uni_pagedir *)*vc->vc_uni_pagedir_loc;\r\nq = dfont_unitable;\r\nfor (i = 0; i < 256; i++)\r\nfor (j = dfont_unicount[i]; j; j--) {\r\nerr1 = con_insert_unipair(p, *(q++), i);\r\nif (err1)\r\nerr = err1;\r\n}\r\nif (con_unify_unimap(vc, p)) {\r\ndflt = (struct uni_pagedir *)*vc->vc_uni_pagedir_loc;\r\nreturn err;\r\n}\r\nfor (i = 0; i <= 3; i++)\r\nset_inverse_transl(vc, p, i);\r\nset_inverse_trans_unicode(vc, p);\r\ndflt = p;\r\nreturn err;\r\n}\r\nint con_copy_unimap(struct vc_data *dst_vc, struct vc_data *src_vc)\r\n{\r\nstruct uni_pagedir *q;\r\nif (!*src_vc->vc_uni_pagedir_loc)\r\nreturn -EINVAL;\r\nif (*dst_vc->vc_uni_pagedir_loc == *src_vc->vc_uni_pagedir_loc)\r\nreturn 0;\r\ncon_free_unimap(dst_vc);\r\nq = (struct uni_pagedir *)*src_vc->vc_uni_pagedir_loc;\r\nq->refcount++;\r\n*dst_vc->vc_uni_pagedir_loc = (long)q;\r\nreturn 0;\r\n}\r\nint con_get_unimap(struct vc_data *vc, ushort ct, ushort __user *uct, struct unipair __user *list)\r\n{\r\nint i, j, k, ect;\r\nu16 **p1, *p2;\r\nstruct uni_pagedir *p;\r\nconsole_lock();\r\nect = 0;\r\nif (*vc->vc_uni_pagedir_loc) {\r\np = (struct uni_pagedir *)*vc->vc_uni_pagedir_loc;\r\nfor (i = 0; i < 32; i++)\r\nif ((p1 = p->uni_pgdir[i]))\r\nfor (j = 0; j < 32; j++)\r\nif ((p2 = *(p1++)))\r\nfor (k = 0; k < 64; k++) {\r\nif (*p2 < MAX_GLYPH && ect++ < ct) {\r\n__put_user((u_short)((i<<11)+(j<<6)+k),\r\n&list->unicode);\r\n__put_user((u_short) *p2,\r\n&list->fontpos);\r\nlist++;\r\n}\r\np2++;\r\n}\r\n}\r\n__put_user(ect, uct);\r\nconsole_unlock();\r\nreturn ((ect <= ct) ? 0 : -ENOMEM);\r\n}\r\nu32 conv_8bit_to_uni(unsigned char c)\r\n{\r\nunsigned short uni = translations[USER_MAP][c];\r\nreturn uni == (0xf000 | c) ? c : uni;\r\n}\r\nint conv_uni_to_8bit(u32 uni)\r\n{\r\nint c;\r\nfor (c = 0; c < 0x100; c++)\r\nif (translations[USER_MAP][c] == uni ||\r\n(translations[USER_MAP][c] == (c | 0xf000) && uni == c))\r\nreturn c;\r\nreturn -1;\r\n}\r\nint\r\nconv_uni_to_pc(struct vc_data *conp, long ucs)\r\n{\r\nint h;\r\nu16 **p1, *p2;\r\nstruct uni_pagedir *p;\r\nif (ucs > 0xffff)\r\nreturn -4;\r\nelse if (ucs < 0x20)\r\nreturn -1;\r\nelse if (ucs == 0xfeff || (ucs >= 0x200b && ucs <= 0x200f))\r\nreturn -2;\r\nelse if ((ucs & ~UNI_DIRECT_MASK) == UNI_DIRECT_BASE)\r\nreturn ucs & UNI_DIRECT_MASK;\r\nif (!*conp->vc_uni_pagedir_loc)\r\nreturn -3;\r\np = (struct uni_pagedir *)*conp->vc_uni_pagedir_loc;\r\nif ((p1 = p->uni_pgdir[ucs >> 11]) &&\r\n(p2 = p1[(ucs >> 6) & 0x1f]) &&\r\n(h = p2[ucs & 0x3f]) < MAX_GLYPH)\r\nreturn h;\r\nreturn -4;\r\n}\r\nvoid __init\r\nconsole_map_init(void)\r\n{\r\nint i;\r\nfor (i = 0; i < MAX_NR_CONSOLES; i++)\r\nif (vc_cons_allocated(i) && !*vc_cons[i].d->vc_uni_pagedir_loc)\r\ncon_set_default_unimap(vc_cons[i].d);\r\n}
