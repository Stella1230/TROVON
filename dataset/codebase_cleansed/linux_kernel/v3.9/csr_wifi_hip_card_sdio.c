card_t* unifi_alloc_card(CsrSdioFunction *sdio, void *ospriv)\r\n{\r\ncard_t *card;\r\nu32 i;\r\ncard = kzalloc(sizeof(card_t), GFP_KERNEL);\r\nif (card == NULL)\r\n{\r\nreturn NULL;\r\n}\r\ncard->sdio_if = sdio;\r\ncard->ospriv = ospriv;\r\ncard->unifi_interrupt_seq = 1;\r\ncard->proc_select = (u32)(-1);\r\ncard->dmem_page = (u32)(-1);\r\ncard->pmem_page = (u32)(-1);\r\ncard->bh_reason_host = 0;\r\ncard->bh_reason_unifi = 0;\r\nfor (i = 0; i < sizeof(card->tx_q_paused_flag) / sizeof(card->tx_q_paused_flag[0]); i++)\r\n{\r\ncard->tx_q_paused_flag[i] = 0;\r\n}\r\ncard->memory_resources_allocated = 0;\r\ncard->low_power_mode = UNIFI_LOW_POWER_DISABLED;\r\ncard->periodic_wake_mode = UNIFI_PERIODIC_WAKE_HOST_DISABLED;\r\ncard->host_state = UNIFI_HOST_STATE_AWAKE;\r\ncard->intmode = CSR_WIFI_INTMODE_DEFAULT;\r\ncard->fh_command_queue.q_body = card->fh_command_q_body;\r\ncard->fh_command_queue.q_length = UNIFI_SOFT_COMMAND_Q_LENGTH;\r\nfor (i = 0; i < UNIFI_NO_OF_TX_QS; i++)\r\n{\r\ncard->fh_traffic_queue[i].q_body = card->fh_traffic_q_body[i];\r\ncard->fh_traffic_queue[i].q_length = UNIFI_SOFT_TRAFFIC_Q_LENGTH;\r\n}\r\ncard->request_coredump_on_reset = 0;\r\ncard->dump_next_write = NULL;\r\ncard->dump_cur_read = NULL;\r\ncard->dump_buf = NULL;\r\n#ifdef UNIFI_DEBUG\r\n{\r\nu32 val = 0x01234567;\r\nif (*((u8 *)&val) == 0x01)\r\n{\r\ncard->lsb = sizeof(void *) - 1;\r\n}\r\nelse\r\n{\r\ncard->lsb = 0;\r\n}\r\n}\r\n#endif\r\nreturn card;\r\n}\r\nCsrResult unifi_init_card(card_t *card, s32 led_mask)\r\n{\r\nCsrResult r;\r\nif (card == NULL)\r\n{\r\nreturn CSR_WIFI_HIP_RESULT_INVALID_VALUE;\r\n}\r\nr = unifi_init(card);\r\nif (r != CSR_RESULT_SUCCESS)\r\n{\r\nreturn r;\r\n}\r\nr = unifi_hip_init(card);\r\nif (r == CSR_WIFI_HIP_RESULT_NO_DEVICE)\r\n{\r\nreturn r;\r\n}\r\nif (r != CSR_RESULT_SUCCESS)\r\n{\r\nunifi_error(card->ospriv, "Failed to start host protocol.\n");\r\nreturn r;\r\n}\r\nreturn CSR_RESULT_SUCCESS;\r\n}\r\nCsrResult unifi_init(card_t *card)\r\n{\r\nCsrResult r;\r\nCsrResult csrResult;\r\nif (card == NULL)\r\n{\r\nreturn CSR_WIFI_HIP_RESULT_INVALID_VALUE;\r\n}\r\ncsrResult = CsrSdioInterruptDisable(card->sdio_if);\r\nif (csrResult == CSR_SDIO_RESULT_NO_DEVICE)\r\n{\r\nreturn CSR_WIFI_HIP_RESULT_NO_DEVICE;\r\n}\r\ncsrResult = CsrSdioMaxBusClockFrequencySet(card->sdio_if, UNIFI_SDIO_CLOCK_SAFE_HZ);\r\nif (csrResult != CSR_RESULT_SUCCESS)\r\n{\r\nr = ConvertCsrSdioToCsrHipResult(card, csrResult);\r\nreturn r;\r\n}\r\ncard->sdio_clock_speed = UNIFI_SDIO_CLOCK_SAFE_HZ;\r\nunifi_trace(card->ospriv, UDBG1, "Resetting UniFi\n");\r\nr = unifi_reset_hardware(card);\r\nif (r == CSR_WIFI_HIP_RESULT_NO_DEVICE)\r\n{\r\nreturn r;\r\n}\r\nif (r != CSR_RESULT_SUCCESS)\r\n{\r\nunifi_error(card->ospriv, "Failed to reset UniFi\n");\r\nreturn r;\r\n}\r\nr = unifi_configure_low_power_mode(card,\r\nUNIFI_LOW_POWER_DISABLED, UNIFI_PERIODIC_WAKE_HOST_DISABLED);\r\nif (r != CSR_RESULT_SUCCESS)\r\n{\r\nunifi_error(card->ospriv, "Failed to set power save mode\n");\r\nreturn r;\r\n}\r\ncard->proc_select = (u32)(-1);\r\ncard->dmem_page = (u32)(-1);\r\ncard->pmem_page = (u32)(-1);\r\nr = unifi_write_direct16(card, ChipHelper_HOST_WINDOW3_PAGE(card->helper) * 2, 0);\r\nif (r == CSR_WIFI_HIP_RESULT_NO_DEVICE)\r\n{\r\nreturn r;\r\n}\r\nif (r != CSR_RESULT_SUCCESS)\r\n{\r\nunifi_error(card->ospriv, "Failed to write SHARED_DMEM_PAGE\n");\r\nreturn r;\r\n}\r\nr = unifi_write_direct16(card, ChipHelper_HOST_WINDOW2_PAGE(card->helper) * 2, 0);\r\nif (r == CSR_WIFI_HIP_RESULT_NO_DEVICE)\r\n{\r\nreturn r;\r\n}\r\nif (r != CSR_RESULT_SUCCESS)\r\n{\r\nunifi_error(card->ospriv, "Failed to write PROG_MEM2_PAGE\n");\r\nreturn r;\r\n}\r\n(void)unifi_coredump_handle_request(card);\r\nr = firmware_present_in_flash(card);\r\nif (r == CSR_WIFI_HIP_RESULT_NO_DEVICE)\r\n{\r\nreturn r;\r\n}\r\nif (r == CSR_WIFI_HIP_RESULT_NOT_FOUND)\r\n{\r\nunifi_error(card->ospriv, "No firmware found\n");\r\n}\r\nelse if (r != CSR_RESULT_SUCCESS)\r\n{\r\nunifi_error(card->ospriv, "Probe for Flash failed\n");\r\n}\r\nreturn r;\r\n}\r\nCsrResult unifi_download(card_t *card, s32 led_mask)\r\n{\r\nCsrResult r;\r\nvoid *dlpriv;\r\nif (card == NULL)\r\n{\r\nreturn CSR_WIFI_HIP_RESULT_INVALID_VALUE;\r\n}\r\ncard->loader_led_mask = led_mask;\r\nunifi_trace(card->ospriv, UDBG1, "downloading firmware...\n");\r\ndlpriv = unifi_dl_fw_read_start(card, UNIFI_FW_STA);\r\nif (dlpriv == NULL)\r\n{\r\nreturn CSR_WIFI_HIP_RESULT_NOT_FOUND;\r\n}\r\nr = unifi_dl_firmware(card, dlpriv);\r\nif (r != CSR_RESULT_SUCCESS)\r\n{\r\nunifi_error(card->ospriv, "Failed to download firmware\n");\r\nreturn r;\r\n}\r\nunifi_fw_read_stop(card->ospriv, dlpriv);\r\nreturn CSR_RESULT_SUCCESS;\r\n}\r\nstatic CsrResult unifi_hip_init(card_t *card)\r\n{\r\nCsrResult r;\r\nCsrResult csrResult;\r\nr = card_hw_init(card);\r\nif (r == CSR_WIFI_HIP_RESULT_NO_DEVICE)\r\n{\r\nreturn r;\r\n}\r\nif (r != CSR_RESULT_SUCCESS)\r\n{\r\nunifi_error(card->ospriv, "Failed to establish communication with UniFi\n");\r\nreturn r;\r\n}\r\n#ifdef CSR_PRE_ALLOC_NET_DATA\r\nprealloc_netdata_free(card);\r\n#endif\r\nr = card_init_slots(card);\r\nif (r == CSR_WIFI_HIP_RESULT_NO_DEVICE)\r\n{\r\nreturn r;\r\n}\r\nif (r != CSR_RESULT_SUCCESS)\r\n{\r\nunifi_error(card->ospriv, "Init slots failed: %d\n", r);\r\nreturn r;\r\n}\r\nunifi_trace(card->ospriv, UDBG2, "Sending first UniFi interrupt\n");\r\nr = unifi_set_host_state(card, UNIFI_HOST_STATE_AWAKE);\r\nif (r != CSR_RESULT_SUCCESS)\r\n{\r\nreturn r;\r\n}\r\ncsrResult = CsrSdioInterruptEnable(card->sdio_if);\r\nif (csrResult == CSR_SDIO_RESULT_NO_DEVICE)\r\n{\r\nreturn CSR_WIFI_HIP_RESULT_NO_DEVICE;\r\n}\r\nr = CardGenInt(card);\r\nif (r != CSR_RESULT_SUCCESS)\r\n{\r\nreturn r;\r\n}\r\nreturn CSR_RESULT_SUCCESS;\r\n}\r\nstatic void _build_sdio_config_data(sdio_config_data_t *cfg_data,\r\nconst u8 *cfg_data_buf)\r\n{\r\ns16 offset = 0;\r\ncfg_data->version = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(cfg_data_buf + offset);\r\noffset += SIZEOF_UINT16;\r\ncfg_data->sdio_ctrl_offset = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(cfg_data_buf + offset);\r\noffset += SIZEOF_UINT16;\r\ncfg_data->fromhost_sigbuf_handle = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(cfg_data_buf + offset);\r\noffset += SIZEOF_UINT16;\r\ncfg_data->tohost_sigbuf_handle = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(cfg_data_buf + offset);\r\noffset += SIZEOF_UINT16;\r\ncfg_data->num_fromhost_sig_frags = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(cfg_data_buf + offset);\r\noffset += SIZEOF_UINT16;\r\ncfg_data->num_tohost_sig_frags = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(cfg_data_buf + offset);\r\noffset += SIZEOF_UINT16;\r\ncfg_data->num_fromhost_data_slots = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(cfg_data_buf + offset);\r\noffset += SIZEOF_UINT16;\r\ncfg_data->num_tohost_data_slots = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(cfg_data_buf + offset);\r\noffset += SIZEOF_UINT16;\r\ncfg_data->data_slot_size = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(cfg_data_buf + offset);\r\noffset += SIZEOF_UINT16;\r\ncfg_data->initialised = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(cfg_data_buf + offset);\r\noffset += SIZEOF_UINT16;\r\ncfg_data->overlay_size = CSR_GET_UINT32_FROM_LITTLE_ENDIAN(cfg_data_buf + offset);\r\noffset += SIZEOF_UINT32;\r\ncfg_data->data_slot_round = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(cfg_data_buf + offset);\r\noffset += SIZEOF_UINT16;\r\ncfg_data->sig_frag_size = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(cfg_data_buf + offset);\r\noffset += SIZEOF_UINT16;\r\ncfg_data->tohost_signal_padding = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(cfg_data_buf + offset);\r\n}\r\nstatic CsrResult card_hw_init(card_t *card)\r\n{\r\nu32 slut_address;\r\nu16 initialised;\r\nu16 finger_print;\r\nsymbol_t slut;\r\nsdio_config_data_t *cfg_data;\r\nu8 cfg_data_buf[SDIO_CONFIG_DATA_SIZE];\r\nCsrResult r;\r\nvoid *dlpriv;\r\ns16 major, minor;\r\ns16 search_4slut_again;\r\nCsrResult csrResult;\r\ndo\r\n{\r\nsearch_4slut_again = 0;\r\ncfg_data = NULL;\r\nr = card_wait_for_firmware_to_start(card, &slut_address);\r\nif (r == CSR_WIFI_HIP_RESULT_NO_DEVICE)\r\n{\r\nreturn r;\r\n}\r\nif (r != CSR_RESULT_SUCCESS)\r\n{\r\nunifi_error(card->ospriv, "Firmware hasn't started\n");\r\nreturn r;\r\n}\r\nunifi_trace(card->ospriv, UDBG4, "SLUT addr 0x%lX\n", slut_address);\r\ncsrResult = CsrSdioMaxBusClockFrequencySet(card->sdio_if, UNIFI_SDIO_CLOCK_INIT_HZ);\r\nif (csrResult != CSR_RESULT_SUCCESS)\r\n{\r\nr = ConvertCsrSdioToCsrHipResult(card, csrResult);\r\nreturn r;\r\n}\r\ncard->sdio_clock_speed = UNIFI_SDIO_CLOCK_INIT_HZ;\r\nunifi_trace(card->ospriv, UDBG4, "Looking for SLUT finger print\n");\r\nfinger_print = 0;\r\nr = unifi_card_read16(card, slut_address, &finger_print);\r\nif (r == CSR_WIFI_HIP_RESULT_NO_DEVICE)\r\n{\r\nreturn r;\r\n}\r\nif (r != CSR_RESULT_SUCCESS)\r\n{\r\nunifi_error(card->ospriv, "Failed to read SLUT finger print\n");\r\nreturn r;\r\n}\r\nif (finger_print != SLUT_FINGERPRINT)\r\n{\r\nunifi_error(card->ospriv, "Failed to find Symbol lookup table fingerprint\n");\r\nreturn CSR_RESULT_FAILURE;\r\n}\r\nslut_address += 2;\r\nwhile (!search_4slut_again)\r\n{\r\nu16 s;\r\nu32 l;\r\nr = unifi_card_read16(card, slut_address, &s);\r\nif (r != CSR_RESULT_SUCCESS)\r\n{\r\nreturn r;\r\n}\r\nslut_address += 2;\r\nif (s == CSR_SLT_END)\r\n{\r\nunifi_trace(card->ospriv, UDBG3, " found CSR_SLT_END\n");\r\nbreak;\r\n}\r\nr = unifi_read32(card, slut_address, &l);\r\nif (r != CSR_RESULT_SUCCESS)\r\n{\r\nreturn r;\r\n}\r\nslut_address += 4;\r\nslut.id = s;\r\nslut.obj = l;\r\nunifi_trace(card->ospriv, UDBG3, " found SLUT id %02d.%08lx\n", slut.id, slut.obj);\r\nswitch (slut.id)\r\n{\r\ncase CSR_SLT_SDIO_SLOT_CONFIG:\r\ncfg_data = &card->config_data;\r\nr = unifi_card_readn(card, slut.obj, cfg_data_buf, SDIO_CONFIG_DATA_SIZE);\r\nif (r == CSR_WIFI_HIP_RESULT_NO_DEVICE)\r\n{\r\nreturn r;\r\n}\r\nif (r != CSR_RESULT_SUCCESS)\r\n{\r\nunifi_error(card->ospriv, "Failed to read config data\n");\r\nreturn r;\r\n}\r\n_build_sdio_config_data(cfg_data, cfg_data_buf);\r\nif ((cfg_data->num_fromhost_data_slots < UNIFI_RESERVED_COMMAND_SLOTS)\r\n|| (cfg_data->num_fromhost_data_slots - UNIFI_RESERVED_COMMAND_SLOTS) / UNIFI_NO_OF_TX_QS == 0)\r\n{\r\nunifi_error(card->ospriv, "From host data slots %d\n", cfg_data->num_fromhost_data_slots);\r\nunifi_error(card->ospriv, "need to be (queues * x + 2) (UNIFI_RESERVED_COMMAND_SLOTS for commands)\n");\r\nreturn CSR_RESULT_FAILURE;\r\n}\r\nif (card->sdio_io_block_pad)\r\n{\r\nif (cfg_data->data_slot_round < card->sdio_io_block_size)\r\n{\r\nunifi_error(card->ospriv,\r\n"Configuration error: Block size of %d exceeds f/w data_slot_round of %d\n",\r\ncard->sdio_io_block_size, cfg_data->data_slot_round);\r\nreturn CSR_WIFI_HIP_RESULT_INVALID_VALUE;\r\n}\r\nif ((card->sdio_io_block_size % cfg_data->sig_frag_size) != 0)\r\n{\r\nunifi_error(card->ospriv, "Configuration error: Can not pad to-host signals.\n");\r\nreturn CSR_WIFI_HIP_RESULT_INVALID_VALUE;\r\n}\r\ncfg_data->tohost_signal_padding = (u16) (card->sdio_io_block_size / cfg_data->sig_frag_size);\r\nunifi_info(card->ospriv, "SDIO block size %d requires %d padding chunks\n",\r\ncard->sdio_io_block_size, cfg_data->tohost_signal_padding);\r\nr = unifi_card_write16(card, slut.obj + SDIO_TO_HOST_SIG_PADDING_OFFSET, cfg_data->tohost_signal_padding);\r\nif (r == CSR_WIFI_HIP_RESULT_NO_DEVICE)\r\n{\r\nreturn r;\r\n}\r\nif (r != CSR_RESULT_SUCCESS)\r\n{\r\nunifi_error(card->ospriv, "Failed to write To-Host Signal Padding Fragments\n");\r\nreturn r;\r\n}\r\n}\r\ncard->sdio_ctrl_addr = cfg_data->sdio_ctrl_offset | (UNIFI_SH_DMEM << 24);\r\ncard->init_flag_addr = slut.obj + SDIO_INIT_FLAG_OFFSET;\r\nbreak;\r\ncase CSR_SLT_BUILD_ID_NUMBER:\r\n{\r\nu32 n;\r\nr = unifi_read32(card, slut.obj, &n);\r\nif (r == CSR_WIFI_HIP_RESULT_NO_DEVICE)\r\n{\r\nreturn r;\r\n}\r\nif (r != CSR_RESULT_SUCCESS)\r\n{\r\nunifi_error(card->ospriv, "Failed to read build id\n");\r\nreturn r;\r\n}\r\ncard->build_id = n;\r\n}\r\nbreak;\r\ncase CSR_SLT_BUILD_ID_STRING:\r\nr = unifi_readnz(card, slut.obj, card->build_id_string,\r\nsizeof(card->build_id_string));\r\nif (r == CSR_WIFI_HIP_RESULT_NO_DEVICE)\r\n{\r\nreturn r;\r\n}\r\nif (r != CSR_RESULT_SUCCESS)\r\n{\r\nunifi_error(card->ospriv, "Failed to read build string\n");\r\nreturn r;\r\n}\r\nbreak;\r\ncase CSR_SLT_PERSISTENT_STORE_DB:\r\nbreak;\r\ncase CSR_SLT_BOOT_LOADER_CONTROL:\r\nr = unifi_do_loader_op(card, slut.obj + 6, UNIFI_BOOT_LOADER_LOAD_STA);\r\nif (r != CSR_RESULT_SUCCESS)\r\n{\r\nunifi_error(card->ospriv, "Failed to write loader load image command\n");\r\nreturn r;\r\n}\r\ndlpriv = unifi_dl_fw_read_start(card, UNIFI_FW_STA);\r\nif (dlpriv != NULL)\r\n{\r\nr = unifi_dl_patch(card, dlpriv, slut.obj);\r\nunifi_fw_read_stop(card->ospriv, dlpriv);\r\nif (r != CSR_RESULT_SUCCESS)\r\n{\r\nunifi_error(card->ospriv, "Failed to patch firmware\n");\r\nreturn r;\r\n}\r\n}\r\nr = unifi_do_loader_op(card, slut.obj + 6, UNIFI_BOOT_LOADER_RESTART);\r\nif (r != CSR_RESULT_SUCCESS)\r\n{\r\nunifi_error(card->ospriv, "Failed to write loader restart command\n");\r\nreturn r;\r\n}\r\nsearch_4slut_again = 1;\r\nbreak;\r\ncase CSR_SLT_PANIC_DATA_PHY:\r\ncard->panic_data_phy_addr = slut.obj;\r\nbreak;\r\ncase CSR_SLT_PANIC_DATA_MAC:\r\ncard->panic_data_mac_addr = slut.obj;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\n} while (search_4slut_again);\r\nif (cfg_data == NULL)\r\n{\r\nunifi_error(card->ospriv, "Failed to find SDIO_SLOT_CONFIG Symbol\n");\r\nreturn CSR_RESULT_FAILURE;\r\n}\r\nr = unifi_card_read16(card, card->init_flag_addr, &initialised);\r\nif (r == CSR_WIFI_HIP_RESULT_NO_DEVICE)\r\n{\r\nreturn r;\r\n}\r\nif (r != CSR_RESULT_SUCCESS)\r\n{\r\nunifi_error(card->ospriv, "Failed to read init flag at %08lx\n",\r\ncard->init_flag_addr);\r\nreturn r;\r\n}\r\nif (initialised != 0)\r\n{\r\nreturn CSR_RESULT_FAILURE;\r\n}\r\nmajor = (cfg_data->version >> 8) & 0xFF;\r\nminor = cfg_data->version & 0xFF;\r\nunifi_info(card->ospriv, "UniFi f/w protocol version %d.%d (driver %d.%d)\n",\r\nmajor, minor,\r\nUNIFI_HIP_MAJOR_VERSION, UNIFI_HIP_MINOR_VERSION);\r\nunifi_info(card->ospriv, "Firmware build %u: %s\n",\r\ncard->build_id, card->build_id_string);\r\nif (major != UNIFI_HIP_MAJOR_VERSION)\r\n{\r\nunifi_error(card->ospriv, "UniFi f/w protocol major version (%d) is different from driver (v%d.%d)\n",\r\nmajor, UNIFI_HIP_MAJOR_VERSION, UNIFI_HIP_MINOR_VERSION);\r\n#ifndef CSR_WIFI_DISABLE_HIP_VERSION_CHECK\r\nreturn CSR_RESULT_FAILURE;\r\n#endif\r\n}\r\nif (minor < UNIFI_HIP_MINOR_VERSION)\r\n{\r\nunifi_error(card->ospriv, "UniFi f/w protocol version (v%d.%d) is older than minimum required by driver (v%d.%d).\n",\r\nmajor, minor,\r\nUNIFI_HIP_MAJOR_VERSION, UNIFI_HIP_MINOR_VERSION);\r\n#ifndef CSR_WIFI_DISABLE_HIP_VERSION_CHECK\r\nreturn CSR_RESULT_FAILURE;\r\n#endif\r\n}\r\nunifi_read_panic(card);\r\nreturn CSR_RESULT_SUCCESS;\r\n}\r\nstatic CsrResult card_wait_for_unifi_to_reset(card_t *card)\r\n{\r\ns16 i;\r\nCsrResult r;\r\nu8 io_enable;\r\nCsrResult csrResult;\r\nr = CSR_RESULT_SUCCESS;\r\nfor (i = 0; i < MAILBOX2_ATTEMPTS; i++)\r\n{\r\nunifi_trace(card->ospriv, UDBG1, "waiting for reset to complete, attempt %d\n", i);\r\nif (card->chip_id > SDIO_CARD_ID_UNIFI_2)\r\n{\r\n#if defined (CSR_WIFI_HIP_DEBUG_OFFLINE) && defined (CSR_WIFI_HIP_SDIO_TRACE)\r\nunifi_debug_log_to_buf("m0@%02X=", SDIO_IO_READY);\r\n#endif\r\ncsrResult = CsrSdioF0Read8(card->sdio_if, SDIO_IO_READY, &io_enable);\r\n#if defined (CSR_WIFI_HIP_DEBUG_OFFLINE) && defined (CSR_WIFI_HIP_SDIO_TRACE)\r\nif (csrResult != CSR_RESULT_SUCCESS)\r\n{\r\nunifi_debug_log_to_buf("error=%X\n", csrResult);\r\n}\r\nelse\r\n{\r\nunifi_debug_log_to_buf("%X\n", io_enable);\r\n}\r\n#endif\r\nif (csrResult == CSR_SDIO_RESULT_NO_DEVICE)\r\n{\r\nreturn CSR_WIFI_HIP_RESULT_NO_DEVICE;\r\n}\r\nr = CSR_RESULT_SUCCESS;\r\nif (csrResult != CSR_RESULT_SUCCESS)\r\n{\r\nr = ConvertCsrSdioToCsrHipResult(card, csrResult);\r\n}\r\n}\r\nelse\r\n{\r\nr = sdio_read_f0(card, SDIO_IO_ENABLE, &io_enable);\r\n}\r\nif (r == CSR_WIFI_HIP_RESULT_NO_DEVICE)\r\n{\r\nreturn r;\r\n}\r\nif (r == CSR_RESULT_SUCCESS)\r\n{\r\nu16 mbox2;\r\ns16 enabled = io_enable & (1 << card->function);\r\nif (!enabled)\r\n{\r\nunifi_trace(card->ospriv, UDBG1,\r\n"Reset complete (function %d is disabled) in ~ %u msecs\n",\r\ncard->function, i * MAILBOX2_TIMEOUT);\r\ncsrResult = CsrSdioFunctionEnable(card->sdio_if);\r\nif (csrResult != CSR_RESULT_SUCCESS)\r\n{\r\nr = ConvertCsrSdioToCsrHipResult(card, csrResult);\r\nunifi_error(card->ospriv, "CsrSdioFunctionEnable failed %d\n", r);\r\nbreak;\r\n}\r\n}\r\nr = unifi_read_direct16(card, ChipHelper_SDIO_HIP_HANDSHAKE(card->helper) * 2, &mbox2);\r\nif (r != CSR_RESULT_SUCCESS)\r\n{\r\nunifi_error(card->ospriv, "read HIP_HANDSHAKE failed %d\n", r);\r\nbreak;\r\n}\r\nif (mbox2 != 0)\r\n{\r\nunifi_error(card->ospriv, "MAILBOX2 non-zero after reset (mbox2 = %04x)\n", mbox2);\r\nr = CSR_RESULT_FAILURE;\r\n}\r\nbreak;\r\n}\r\nelse\r\n{\r\nif (card->chip_id > SDIO_CARD_ID_UNIFI_2)\r\n{\r\nif (i > MAILBOX2_ATTEMPTS / 4)\r\n{\r\nunifi_trace(card->ospriv, UDBG1, "Failed to read CCCR IO Ready register while polling for reset\n");\r\n}\r\n}\r\nelse\r\n{\r\nunifi_trace(card->ospriv, UDBG1, "Failed to read CCCR IO Enable register while polling for reset\n");\r\n}\r\n}\r\nCsrThreadSleep(MAILBOX2_TIMEOUT);\r\n}\r\nif (r == CSR_RESULT_SUCCESS && i == MAILBOX2_ATTEMPTS)\r\n{\r\nunifi_trace(card->ospriv, UDBG1, "Timeout waiting for UniFi to complete reset\n");\r\nr = CSR_RESULT_FAILURE;\r\n}\r\nreturn r;\r\n}\r\nstatic CsrResult card_wait_for_unifi_to_disable(card_t *card)\r\n{\r\ns16 i;\r\nCsrResult r;\r\nu8 io_enable;\r\nCsrResult csrResult;\r\nif (card->chip_id <= SDIO_CARD_ID_UNIFI_2)\r\n{\r\nunifi_error(card->ospriv,\r\n"Function reset method not supported for chip_id=%d\n",\r\ncard->chip_id);\r\nreturn CSR_RESULT_FAILURE;\r\n}\r\nr = CSR_RESULT_SUCCESS;\r\nfor (i = 0; i < MAILBOX2_ATTEMPTS; i++)\r\n{\r\nunifi_trace(card->ospriv, UDBG1, "waiting for disable to complete, attempt %d\n", i);\r\n#if defined (CSR_WIFI_HIP_DEBUG_OFFLINE) && defined (CSR_WIFI_HIP_SDIO_TRACE)\r\nunifi_debug_log_to_buf("r0@%02X=", SDIO_IO_READY);\r\n#endif\r\ncsrResult = CsrSdioF0Read8(card->sdio_if, SDIO_IO_READY, &io_enable);\r\n#if defined (CSR_WIFI_HIP_DEBUG_OFFLINE) && defined (CSR_WIFI_HIP_SDIO_TRACE)\r\nif (csrResult != CSR_RESULT_SUCCESS)\r\n{\r\nunifi_debug_log_to_buf("error=%X\n", csrResult);\r\n}\r\nelse\r\n{\r\nunifi_debug_log_to_buf("%X\n", io_enable);\r\n}\r\n#endif\r\nif (csrResult == CSR_SDIO_RESULT_NO_DEVICE)\r\n{\r\nreturn CSR_WIFI_HIP_RESULT_NO_DEVICE;\r\n}\r\nif (csrResult == CSR_RESULT_SUCCESS)\r\n{\r\ns16 enabled = io_enable & (1 << card->function);\r\nr = CSR_RESULT_SUCCESS;\r\nif (!enabled)\r\n{\r\nunifi_trace(card->ospriv, UDBG1,\r\n"Disable complete (function %d is disabled) in ~ %u msecs\n",\r\ncard->function, i * MAILBOX2_TIMEOUT);\r\nbreak;\r\n}\r\n}\r\nelse\r\n{\r\nr = ConvertCsrSdioToCsrHipResult(card, csrResult);\r\nif (i > (MAILBOX2_ATTEMPTS / 4))\r\n{\r\nunifi_trace(card->ospriv, UDBG1,\r\n"Failed to read CCCR IO Ready register while polling for disable\n");\r\n}\r\n}\r\nCsrThreadSleep(MAILBOX2_TIMEOUT);\r\n}\r\nif ((r == CSR_RESULT_SUCCESS) && (i == MAILBOX2_ATTEMPTS))\r\n{\r\nunifi_trace(card->ospriv, UDBG1, "Timeout waiting for UniFi to complete disable\n");\r\nr = CSR_RESULT_FAILURE;\r\n}\r\nreturn r;\r\n}\r\nCsrResult card_wait_for_firmware_to_start(card_t *card, u32 *paddr)\r\n{\r\ns32 i;\r\nu16 mbox0, mbox1;\r\nCsrResult r;\r\nCsrThreadSleep(MAILBOX1_TIMEOUT);\r\nmbox1 = 0;\r\nunifi_trace(card->ospriv, UDBG1, "waiting for MAILBOX1 to be non-zero...\n");\r\nfor (i = 0; i < MAILBOX1_ATTEMPTS; i++)\r\n{\r\nr = unifi_read_direct16(card, ChipHelper_MAILBOX1(card->helper) * 2, &mbox1);\r\nif (r == CSR_WIFI_HIP_RESULT_NO_DEVICE)\r\n{\r\nreturn r;\r\n}\r\nif (r != CSR_RESULT_SUCCESS)\r\n{\r\nunifi_warning(card->ospriv, "Failed to read UniFi Mailbox1 register\n");\r\n}\r\nif ((r == CSR_RESULT_SUCCESS) && (mbox1 != 0))\r\n{\r\nunifi_trace(card->ospriv, UDBG1, "MAILBOX1 ready (0x%04X) in %u millisecs\n",\r\nmbox1, i * MAILBOX1_TIMEOUT);\r\nr = unifi_read_direct16(card, ChipHelper_MAILBOX1(card->helper) * 2, &mbox1);\r\nif (r == CSR_WIFI_HIP_RESULT_NO_DEVICE)\r\n{\r\nreturn r;\r\n}\r\nif (r != CSR_RESULT_SUCCESS)\r\n{\r\nunifi_error(card->ospriv, "Failed to read UniFi Mailbox1 register for second time\n");\r\nreturn r;\r\n}\r\nunifi_trace(card->ospriv, UDBG1, "MAILBOX1 value=0x%04X\n", mbox1);\r\nbreak;\r\n}\r\nCsrThreadSleep(MAILBOX1_TIMEOUT);\r\nif ((i % 100) == 99)\r\n{\r\nunifi_trace(card->ospriv, UDBG2, "MAILBOX1 not ready (0x%X), still trying...\n", mbox1);\r\n}\r\n}\r\nif ((r == CSR_RESULT_SUCCESS) && (mbox1 == 0))\r\n{\r\nunifi_trace(card->ospriv, UDBG1, "Timeout waiting for firmware to start, Mailbox1 still 0 after %d ms\n",\r\nMAILBOX1_ATTEMPTS * MAILBOX1_TIMEOUT);\r\nreturn CSR_RESULT_FAILURE;\r\n}\r\nr = unifi_write_direct16(card, ChipHelper_SDIO_HIP_HANDSHAKE(card->helper) * 2, 0xFFFF);\r\nif (r == CSR_WIFI_HIP_RESULT_NO_DEVICE)\r\n{\r\nreturn r;\r\n}\r\nif (r != CSR_RESULT_SUCCESS)\r\n{\r\nunifi_error(card->ospriv, "Failed to write f/w startup handshake to MAILBOX2\n");\r\nreturn r;\r\n}\r\nmbox0 = 0;\r\nr = unifi_read_direct16(card, ChipHelper_MAILBOX0(card->helper) * 2, &mbox0);\r\nif (r == CSR_WIFI_HIP_RESULT_NO_DEVICE)\r\n{\r\nreturn r;\r\n}\r\nif (r != CSR_RESULT_SUCCESS)\r\n{\r\nunifi_error(card->ospriv, "Failed to read UniFi Mailbox0 register\n");\r\nreturn r;\r\n}\r\n*paddr = (((u32)mbox1 << 16) | mbox0);\r\nreturn CSR_RESULT_SUCCESS;\r\n}\r\nCsrResult unifi_capture_panic(card_t *card)\r\n{\r\nif (!card->panic_data_phy_addr || !card->panic_data_mac_addr)\r\n{\r\nreturn CSR_RESULT_SUCCESS;\r\n}\r\nif (card_access_panic(card) == CSR_RESULT_SUCCESS)\r\n{\r\nunifi_read_panic(card);\r\n}\r\nelse\r\n{\r\nunifi_info(card->ospriv, "Unable to read panic codes");\r\n}\r\nreturn CSR_RESULT_SUCCESS;\r\n}\r\nstatic CsrResult card_access_panic(card_t *card)\r\n{\r\nu16 data_u16 = 0;\r\ns32 i;\r\nCsrResult r, sr;\r\nif (!card->chip_version)\r\n{\r\nunifi_info(card->ospriv, "Unknown chip version\n");\r\nreturn CSR_RESULT_FAILURE;\r\n}\r\nr = unifi_set_host_state(card, UNIFI_HOST_STATE_AWAKE);\r\nif (r == CSR_WIFI_HIP_RESULT_NO_DEVICE)\r\n{\r\nreturn r;\r\n}\r\nif (r != CSR_RESULT_SUCCESS)\r\n{\r\nunifi_error(card->ospriv, "unifi_set_host_state() failed %d\n", r);\r\nreturn CSR_RESULT_FAILURE;\r\n}\r\nCsrThreadSleep(20);\r\nfor (i = 0; i < 3; i++)\r\n{\r\nsr = CsrSdioRead16(card->sdio_if, CHIP_HELPER_UNIFI_GBL_CHIP_VERSION * 2, &data_u16);\r\nif (sr != CSR_RESULT_SUCCESS || data_u16 != card->chip_version)\r\n{\r\nunifi_info(card->ospriv, "Failed to read valid chip version sr=%d (0x%04x want 0x%04x) try %d\n",\r\nsr, data_u16, card->chip_version, i);\r\nsr = CsrSdioMaxBusClockFrequencySet(card->sdio_if, UNIFI_SDIO_CLOCK_SAFE_HZ);\r\nif (sr != CSR_RESULT_SUCCESS)\r\n{\r\nunifi_error(card->ospriv, "CsrSdioMaxBusClockFrequencySet() failed1 %d\n", sr);\r\nr = ConvertCsrSdioToCsrHipResult(card, sr);\r\n}\r\ncard->sdio_clock_speed = UNIFI_SDIO_CLOCK_SAFE_HZ;\r\nif (i == 0)\r\n{\r\nunifi_info(card->ospriv, "Try function enable\n");\r\nsr = CsrSdioFunctionEnable(card->sdio_if);\r\nif (sr != CSR_RESULT_SUCCESS)\r\n{\r\nr = ConvertCsrSdioToCsrHipResult(card, sr);\r\nunifi_error(card->ospriv, "CsrSdioFunctionEnable failed %d (HIP %d)\n", sr, r);\r\n}\r\ncontinue;\r\n}\r\nunifi_info(card->ospriv, "Try set awake\n");\r\nr = unifi_set_host_state(card, UNIFI_HOST_STATE_AWAKE);\r\nif (r == CSR_WIFI_HIP_RESULT_NO_DEVICE)\r\n{\r\nreturn r;\r\n}\r\nif (r != CSR_RESULT_SUCCESS)\r\n{\r\nunifi_error(card->ospriv, "unifi_set_host_state() failed2 %d\n", r);\r\n}\r\nsr = CsrSdioMaxBusClockFrequencySet(card->sdio_if, UNIFI_SDIO_CLOCK_SAFE_HZ);\r\nif (sr != CSR_RESULT_SUCCESS)\r\n{\r\nunifi_error(card->ospriv, "CsrSdioMaxBusClockFrequencySet() failed2 %d\n", sr);\r\n}\r\ncard->sdio_clock_speed = UNIFI_SDIO_CLOCK_SAFE_HZ;\r\nif (i == 1)\r\n{\r\ncontinue;\r\n}\r\nunifi_info(card->ospriv, "Try s/w reset\n");\r\nr = unifi_card_hard_reset(card);\r\nif (r != CSR_RESULT_SUCCESS)\r\n{\r\nunifi_error(card->ospriv, "unifi_card_hard_reset() failed %d\n", r);\r\n}\r\n}\r\nelse\r\n{\r\nif (i > 0)\r\n{\r\nunifi_info(card->ospriv, "Read chip version 0x%x after %d retries\n", data_u16, i);\r\n}\r\nbreak;\r\n}\r\n}\r\nr = ConvertCsrSdioToCsrHipResult(card, sr);\r\nreturn r;\r\n}\r\nvoid unifi_read_panic(card_t *card)\r\n{\r\nCsrResult r;\r\nu16 p_code, p_arg;\r\nif (!card->panic_data_phy_addr || !card->panic_data_mac_addr)\r\n{\r\nreturn;\r\n}\r\nr = unifi_card_read16(card, card->panic_data_phy_addr, &p_code);\r\nif (r != CSR_RESULT_SUCCESS)\r\n{\r\nunifi_error(card->ospriv, "capture_panic: unifi_read16 %08x failed %d\n", card->panic_data_phy_addr, r);\r\np_code = 0;\r\n}\r\nif (p_code)\r\n{\r\nr = unifi_card_read16(card, card->panic_data_phy_addr + 2, &p_arg);\r\nif (r != CSR_RESULT_SUCCESS)\r\n{\r\nunifi_error(card->ospriv, "capture_panic: unifi_read16 %08x failed %d\n", card->panic_data_phy_addr + 2, r);\r\n}\r\nunifi_error(card->ospriv, "Last UniFi PHY PANIC %04x arg %04x\n", p_code, p_arg);\r\ncard->last_phy_panic_code = p_code;\r\ncard->last_phy_panic_arg = p_arg;\r\n}\r\nr = unifi_card_read16(card, card->panic_data_mac_addr, &p_code);\r\nif (r != CSR_RESULT_SUCCESS)\r\n{\r\nunifi_error(card->ospriv, "capture_panic: unifi_read16 %08x failed %d\n", card->panic_data_mac_addr, r);\r\np_code = 0;\r\n}\r\nif (p_code)\r\n{\r\nr = unifi_card_read16(card, card->panic_data_mac_addr + 2, &p_arg);\r\nif (r != CSR_RESULT_SUCCESS)\r\n{\r\nunifi_error(card->ospriv, "capture_panic: unifi_read16 %08x failed %d\n", card->panic_data_mac_addr + 2, r);\r\n}\r\nunifi_error(card->ospriv, "Last UniFi MAC PANIC %04x arg %04x\n", p_code, p_arg);\r\ncard->last_mac_panic_code = p_code;\r\ncard->last_mac_panic_arg = p_arg;\r\n}\r\n}\r\nstatic CsrResult card_allocate_memory_resources(card_t *card)\r\n{\r\ns16 n, i, k, r;\r\nsdio_config_data_t *cfg_data;\r\ncard->fh_command_queue.q_rd_ptr = 0;\r\ncard->fh_command_queue.q_wr_ptr = 0;\r\n(void)scnprintf(card->fh_command_queue.name, UNIFI_QUEUE_NAME_MAX_LENGTH,\r\n"fh_cmd_q");\r\nfor (i = 0; i < UNIFI_NO_OF_TX_QS; i++)\r\n{\r\ncard->fh_traffic_queue[i].q_rd_ptr = 0;\r\ncard->fh_traffic_queue[i].q_wr_ptr = 0;\r\n(void)scnprintf(card->fh_traffic_queue[i].name,\r\nUNIFI_QUEUE_NAME_MAX_LENGTH, "fh_data_q%d", i);\r\n}\r\n#ifndef CSR_WIFI_HIP_TA_DISABLE\r\nunifi_ta_sampling_init(card);\r\n#endif\r\ncfg_data = &card->config_data;\r\ncard->fh_buffer.buf = kmalloc(UNIFI_FH_BUF_SIZE, GFP_KERNEL);\r\nif (card->fh_buffer.buf == NULL)\r\n{\r\nunifi_error(card->ospriv, "Failed to allocate memory for F-H signals\n");\r\nreturn CSR_WIFI_HIP_RESULT_NO_MEMORY;\r\n}\r\ncard->fh_buffer.bufsize = UNIFI_FH_BUF_SIZE;\r\ncard->fh_buffer.ptr = card->fh_buffer.buf;\r\ncard->fh_buffer.count = 0;\r\ncard->th_buffer.buf = kmalloc(UNIFI_FH_BUF_SIZE, GFP_KERNEL);\r\nif (card->th_buffer.buf == NULL)\r\n{\r\nunifi_error(card->ospriv, "Failed to allocate memory for T-H signals\n");\r\nreturn CSR_WIFI_HIP_RESULT_NO_MEMORY;\r\n}\r\ncard->th_buffer.bufsize = UNIFI_FH_BUF_SIZE;\r\ncard->th_buffer.ptr = card->th_buffer.buf;\r\ncard->th_buffer.count = 0;\r\nn = cfg_data->num_fromhost_data_slots;\r\nunifi_trace(card->ospriv, UDBG3, "Alloc from-host resources, %d slots.\n", n);\r\ncard->from_host_data = kmalloc(n * sizeof(slot_desc_t), GFP_KERNEL);\r\nif (card->from_host_data == NULL)\r\n{\r\nunifi_error(card->ospriv, "Failed to allocate memory for F-H bulk data array\n");\r\nreturn CSR_WIFI_HIP_RESULT_NO_MEMORY;\r\n}\r\nfor (i = 0; i < n; i++)\r\n{\r\nUNIFI_INIT_BULK_DATA(&card->from_host_data[i].bd);\r\n}\r\ncard->fh_slot_host_tag_record = kmalloc(n * sizeof(u32), GFP_KERNEL);\r\nif (card->fh_slot_host_tag_record == NULL)\r\n{\r\nunifi_error(card->ospriv, "Failed to allocate memory for F-H slot host tag mapping array\n");\r\nreturn CSR_WIFI_HIP_RESULT_NO_MEMORY;\r\n}\r\nfor (i = 0; i < n; i++)\r\n{\r\ncard->fh_slot_host_tag_record[i] = CSR_WIFI_HIP_RESERVED_HOST_TAG;\r\n}\r\nn = cfg_data->num_tohost_data_slots;\r\nunifi_trace(card->ospriv, UDBG3, "Alloc to-host resources, %d slots.\n", n);\r\ncard->to_host_data = kmalloc(n * sizeof(bulk_data_desc_t), GFP_KERNEL);\r\nif (card->to_host_data == NULL)\r\n{\r\nunifi_error(card->ospriv, "Failed to allocate memory for T-H bulk data array\n");\r\nreturn CSR_WIFI_HIP_RESULT_NO_MEMORY;\r\n}\r\nfor (i = 0; i < n; i++)\r\n{\r\nUNIFI_INIT_BULK_DATA(&card->to_host_data[i]);\r\n}\r\nfor (i = 0; i < UNIFI_SOFT_COMMAND_Q_LENGTH; i++)\r\n{\r\nfor (r = 0; r < UNIFI_MAX_DATA_REFERENCES; r++)\r\n{\r\nUNIFI_INIT_BULK_DATA(&card->fh_command_q_body[i].bulkdata[r]);\r\n}\r\n}\r\nfor (k = 0; k < UNIFI_NO_OF_TX_QS; k++)\r\n{\r\nfor (i = 0; i < UNIFI_SOFT_TRAFFIC_Q_LENGTH; i++)\r\n{\r\nfor (r = 0; r < UNIFI_MAX_DATA_REFERENCES; r++)\r\n{\r\nUNIFI_INIT_BULK_DATA(&card->fh_traffic_q_body[k][i].bulkdata[r]);\r\n}\r\n}\r\n}\r\ncard->memory_resources_allocated = 1;\r\nreturn CSR_RESULT_SUCCESS;\r\n}\r\nstatic void unifi_free_bulk_data(card_t *card, bulk_data_desc_t *bulk_data_slot)\r\n{\r\nif (bulk_data_slot->data_length != 0)\r\n{\r\nunifi_net_data_free(card->ospriv, bulk_data_slot);\r\n}\r\n}\r\nstatic void card_free_memory_resources(card_t *card)\r\n{\r\nunifi_trace(card->ospriv, UDBG1, "Freeing card memory resources.\n");\r\nunifi_cancel_pending_signals(card);\r\nkfree(card->to_host_data);\r\ncard->to_host_data = NULL;\r\nkfree(card->from_host_data);\r\ncard->from_host_data = NULL;\r\nkfree(card->fh_slot_host_tag_record);\r\ncard->fh_slot_host_tag_record = NULL;\r\nkfree(card->fh_buffer.buf);\r\ncard->fh_buffer.ptr = card->fh_buffer.buf = NULL;\r\ncard->fh_buffer.bufsize = 0;\r\ncard->fh_buffer.count = 0;\r\nkfree(card->th_buffer.buf);\r\ncard->th_buffer.ptr = card->th_buffer.buf = NULL;\r\ncard->th_buffer.bufsize = 0;\r\ncard->th_buffer.count = 0;\r\ncard->memory_resources_allocated = 0;\r\n}\r\nstatic void card_init_soft_queues(card_t *card)\r\n{\r\ns16 i;\r\nunifi_trace(card->ospriv, UDBG1, "Initialising internal signal queues.\n");\r\ncard->fh_command_queue.q_rd_ptr = 0;\r\ncard->fh_command_queue.q_wr_ptr = 0;\r\n(void)scnprintf(card->fh_command_queue.name, UNIFI_QUEUE_NAME_MAX_LENGTH,\r\n"fh_cmd_q");\r\nfor (i = 0; i < UNIFI_NO_OF_TX_QS; i++)\r\n{\r\ncard->fh_traffic_queue[i].q_rd_ptr = 0;\r\ncard->fh_traffic_queue[i].q_wr_ptr = 0;\r\n(void)scnprintf(card->fh_traffic_queue[i].name,\r\nUNIFI_QUEUE_NAME_MAX_LENGTH, "fh_data_q%d", i);\r\n}\r\n#ifndef CSR_WIFI_HIP_TA_DISABLE\r\nunifi_ta_sampling_init(card);\r\n#endif\r\n}\r\nvoid unifi_cancel_pending_signals(card_t *card)\r\n{\r\ns16 i, n, r;\r\nunifi_trace(card->ospriv, UDBG1, "Canceling pending signals.\n");\r\nif (card->to_host_data)\r\n{\r\nn = card->config_data.num_tohost_data_slots;\r\nunifi_trace(card->ospriv, UDBG3, "Freeing to-host resources, %d slots.\n", n);\r\nfor (i = 0; i < n; i++)\r\n{\r\nunifi_free_bulk_data(card, &card->to_host_data[i]);\r\n}\r\n}\r\nif (card->from_host_data)\r\n{\r\nn = card->config_data.num_fromhost_data_slots;\r\nunifi_trace(card->ospriv, UDBG3, "Freeing from-host resources, %d slots.\n", n);\r\nfor (i = 0; i < n; i++)\r\n{\r\nunifi_free_bulk_data(card, &card->from_host_data[i].bd);\r\n}\r\nfor (i = 0; i < UNIFI_NO_OF_TX_QS; i++)\r\n{\r\ncard->dynamic_slot_data.from_host_used_slots[i] = 0;\r\ncard->dynamic_slot_data.from_host_max_slots[i] = 0;\r\ncard->dynamic_slot_data.from_host_reserved_slots[i] = 0;\r\n}\r\n}\r\nunifi_trace(card->ospriv, UDBG3, "Freeing cmd q resources.\n");\r\nfor (i = 0; i < UNIFI_SOFT_COMMAND_Q_LENGTH; i++)\r\n{\r\nfor (r = 0; r < UNIFI_MAX_DATA_REFERENCES; r++)\r\n{\r\nunifi_free_bulk_data(card, &card->fh_command_q_body[i].bulkdata[r]);\r\n}\r\n}\r\nunifi_trace(card->ospriv, UDBG3, "Freeing traffic q resources.\n");\r\nfor (n = 0; n < UNIFI_NO_OF_TX_QS; n++)\r\n{\r\nfor (i = 0; i < UNIFI_SOFT_TRAFFIC_Q_LENGTH; i++)\r\n{\r\nfor (r = 0; r < UNIFI_MAX_DATA_REFERENCES; r++)\r\n{\r\nunifi_free_bulk_data(card, &card->fh_traffic_q_body[n][i].bulkdata[r]);\r\n}\r\n}\r\n}\r\ncard_init_soft_queues(card);\r\n}\r\nvoid unifi_free_card(card_t *card)\r\n{\r\n#ifdef CSR_PRE_ALLOC_NET_DATA\r\nprealloc_netdata_free(card);\r\n#endif\r\ncard_free_memory_resources(card);\r\nif (card->dump_buf)\r\n{\r\nunifi_error(card->ospriv, "Caller should call unifi_coredump_free()\n");\r\nunifi_coredump_free(card);\r\n}\r\nkfree(card);\r\n}\r\nstatic CsrResult card_init_slots(card_t *card)\r\n{\r\nCsrResult r;\r\nu8 i;\r\nif (card->memory_resources_allocated == 1)\r\n{\r\ncard_free_memory_resources(card);\r\n}\r\nelse\r\n{\r\ncard_init_soft_queues(card);\r\n}\r\nr = card_allocate_memory_resources(card);\r\nif (r != CSR_RESULT_SUCCESS)\r\n{\r\nunifi_error(card->ospriv, "Failed to allocate card memory resources.\n");\r\ncard_free_memory_resources(card);\r\nreturn r;\r\n}\r\nif (card->sdio_ctrl_addr == 0)\r\n{\r\nunifi_error(card->ospriv, "Failed to find config struct!\n");\r\nreturn CSR_WIFI_HIP_RESULT_INVALID_VALUE;\r\n}\r\ncard->from_host_data_head = 0;\r\n{\r\nu16 s;\r\nr = unifi_card_read16(card, card->sdio_ctrl_addr + 0, &s);\r\nif (r == CSR_WIFI_HIP_RESULT_NO_DEVICE)\r\n{\r\nreturn r;\r\n}\r\nif (r != CSR_RESULT_SUCCESS)\r\n{\r\nunifi_error(card->ospriv, "Failed to read from-host sig written count\n");\r\nreturn r;\r\n}\r\ncard->from_host_signals_w = (s16)s;\r\nr = unifi_card_read16(card, card->sdio_ctrl_addr + 6, &s);\r\nif (r == CSR_WIFI_HIP_RESULT_NO_DEVICE)\r\n{\r\nreturn r;\r\n}\r\nif (r != CSR_RESULT_SUCCESS)\r\n{\r\nunifi_error(card->ospriv, "Failed to read to-host sig read count\n");\r\nreturn r;\r\n}\r\ncard->to_host_signals_r = (s16)s;\r\n}\r\nr = unifi_card_write16(card, card->init_flag_addr, 0x0001);\r\nif (r == CSR_WIFI_HIP_RESULT_NO_DEVICE)\r\n{\r\nreturn r;\r\n}\r\nif (r != CSR_RESULT_SUCCESS)\r\n{\r\nunifi_error(card->ospriv, "Failed to write initialised flag\n");\r\nreturn r;\r\n}\r\nmemset(&card->dynamic_slot_data, 0, sizeof(card_dynamic_slot_t));\r\nfor (i = 0; i < UNIFI_NO_OF_TX_QS; i++)\r\n{\r\ncard->dynamic_slot_data.from_host_max_slots[i] = card->config_data.num_fromhost_data_slots -\r\nUNIFI_RESERVED_COMMAND_SLOTS;\r\ncard->dynamic_slot_data.queue_stable[i] = FALSE;\r\n}\r\ncard->dynamic_slot_data.packets_interval = UNIFI_PACKETS_INTERVAL;\r\nreturn CSR_RESULT_SUCCESS;\r\n}\r\nCsrResult unifi_set_udi_hook(card_t *card, udi_func_t udi_fn)\r\n{\r\nif (card == NULL)\r\n{\r\nreturn CSR_WIFI_HIP_RESULT_INVALID_VALUE;\r\n}\r\nif (card->udi_hook == NULL)\r\n{\r\ncard->udi_hook = udi_fn;\r\n}\r\nreturn CSR_RESULT_SUCCESS;\r\n}\r\nCsrResult unifi_remove_udi_hook(card_t *card, udi_func_t udi_fn)\r\n{\r\nif (card == NULL)\r\n{\r\nreturn CSR_WIFI_HIP_RESULT_INVALID_VALUE;\r\n}\r\nif (card->udi_hook == udi_fn)\r\n{\r\ncard->udi_hook = NULL;\r\n}\r\nreturn CSR_RESULT_SUCCESS;\r\n}\r\nstatic void CardReassignDynamicReservation(card_t *card)\r\n{\r\nu8 i;\r\nunifi_trace(card->ospriv, UDBG5, "Packets Txed %d %d %d %d\n",\r\ncard->dynamic_slot_data.packets_txed[0],\r\ncard->dynamic_slot_data.packets_txed[1],\r\ncard->dynamic_slot_data.packets_txed[2],\r\ncard->dynamic_slot_data.packets_txed[3]);\r\nfor (i = 0; i < UNIFI_NO_OF_TX_QS; i++)\r\n{\r\ncard->dynamic_slot_data.queue_stable[i] = FALSE;\r\ncard->dynamic_slot_data.from_host_reserved_slots[i] = 0;\r\ncard->dynamic_slot_data.from_host_max_slots[i] = card->config_data.num_fromhost_data_slots -\r\nUNIFI_RESERVED_COMMAND_SLOTS;\r\ncard->dynamic_slot_data.packets_txed[i] = 0;\r\nunifi_trace(card->ospriv, UDBG5, "CardReassignDynamicReservation: queue %d reserved %d Max %d\n", i,\r\ncard->dynamic_slot_data.from_host_reserved_slots[i],\r\ncard->dynamic_slot_data.from_host_max_slots[i]);\r\n}\r\ncard->dynamic_slot_data.total_packets_txed = 0;\r\n}\r\nstatic void CardCheckDynamicReservation(card_t *card, unifi_TrafficQueue queue)\r\n{\r\nu16 q_len, active_queues = 0, excess_queue_slots, div_extra_slots,\r\nqueue_fair_share, reserved_slots = 0, q, excess_need_queues = 0, unmovable_slots = 0;\r\ns32 i;\r\nq_t *sigq;\r\nu16 num_data_slots = card->config_data.num_fromhost_data_slots - UNIFI_RESERVED_COMMAND_SLOTS;\r\nsigq = &card->fh_traffic_queue[queue];\r\nq_len = CSR_WIFI_HIP_Q_SLOTS_USED(sigq);\r\nif (q_len <= card->dynamic_slot_data.from_host_reserved_slots[queue])\r\n{\r\nunifi_trace(card->ospriv, UDBG5, "queue %d q_len %d already has that many reserved slots, exiting\n", queue, q_len);\r\nreturn;\r\n}\r\nif (q_len > num_data_slots)\r\n{\r\nq_len = num_data_slots;\r\n}\r\nfor (i = 0; i < UNIFI_NO_OF_TX_QS; i++)\r\n{\r\nif (i != (s32)queue)\r\n{\r\nreserved_slots += card->dynamic_slot_data.from_host_reserved_slots[i];\r\n}\r\nif ((i == (s32)queue) || (card->dynamic_slot_data.from_host_reserved_slots[i] > 0))\r\n{\r\nactive_queues++;\r\n}\r\n}\r\nunifi_trace(card->ospriv, UDBG5, "CardCheckDynamicReservation: queue %d q_len %d\n", queue, q_len);\r\nunifi_trace(card->ospriv, UDBG5, "Active queues %d reserved slots on other queues %d\n",\r\nactive_queues, reserved_slots);\r\nif (reserved_slots + q_len <= num_data_slots)\r\n{\r\ncard->dynamic_slot_data.from_host_reserved_slots[queue] = q_len;\r\nif (q_len == num_data_slots)\r\n{\r\ncard->dynamic_slot_data.queue_stable[queue] = TRUE;\r\n}\r\n}\r\nelse\r\n{\r\nqueue_fair_share = num_data_slots / active_queues;\r\nunifi_trace(card->ospriv, UDBG5, "queue fair share %d\n", queue_fair_share);\r\ncard->dynamic_slot_data.from_host_reserved_slots[queue] = q_len;\r\nfor (i = 0; i < UNIFI_NO_OF_TX_QS; i++)\r\n{\r\nif (card->dynamic_slot_data.from_host_reserved_slots[i] > queue_fair_share)\r\n{\r\nexcess_need_queues++;\r\n}\r\nelse\r\n{\r\nunmovable_slots += card->dynamic_slot_data.from_host_reserved_slots[i];\r\n}\r\n}\r\nunifi_trace(card->ospriv, UDBG5, "Excess need queues %d\n", excess_need_queues);\r\nexcess_queue_slots = (num_data_slots - unmovable_slots) / excess_need_queues;\r\ndiv_extra_slots = (num_data_slots - unmovable_slots) - excess_queue_slots * excess_need_queues;\r\nfor (i = UNIFI_NO_OF_TX_QS - 1; i >= 0; i--)\r\n{\r\nif (card->dynamic_slot_data.from_host_reserved_slots[i] > excess_queue_slots)\r\n{\r\ncard->dynamic_slot_data.from_host_reserved_slots[i] = excess_queue_slots;\r\nif (div_extra_slots > 0)\r\n{\r\ncard->dynamic_slot_data.from_host_reserved_slots[i]++;\r\ndiv_extra_slots--;\r\n}\r\ncard->dynamic_slot_data.queue_stable[i] = TRUE;\r\nunifi_trace(card->ospriv, UDBG5, "queue stable %d\n", i);\r\n}\r\n}\r\n}\r\nfor (i = 0; i < UNIFI_NO_OF_TX_QS; i++)\r\n{\r\nreserved_slots = 0;\r\nfor (q = 0; q < UNIFI_NO_OF_TX_QS; q++)\r\n{\r\nif (i != q)\r\n{\r\nreserved_slots += card->dynamic_slot_data.from_host_reserved_slots[q];\r\n}\r\n}\r\ncard->dynamic_slot_data.from_host_max_slots[i] = num_data_slots - reserved_slots;\r\nunifi_trace(card->ospriv, UDBG5, "queue %d reserved %d Max %d\n", i,\r\ncard->dynamic_slot_data.from_host_reserved_slots[i],\r\ncard->dynamic_slot_data.from_host_max_slots[i]);\r\n}\r\n}\r\nvoid CardClearFromHostDataSlot(card_t *card, const s16 slot)\r\n{\r\nu8 queue = card->from_host_data[slot].queue;\r\nconst void *os_data_ptr = card->from_host_data[slot].bd.os_data_ptr;\r\nif (card->from_host_data[slot].bd.data_length == 0)\r\n{\r\nunifi_warning(card->ospriv,\r\n"Surprise: request to clear an already free FH data slot: %d\n",\r\nslot);\r\nreturn;\r\n}\r\nif (os_data_ptr == NULL)\r\n{\r\nunifi_warning(card->ospriv,\r\n"Clearing FH data slot %d: has null payload, len=%d\n",\r\nslot, card->from_host_data[slot].bd.data_length);\r\n}\r\nunifi_free_bulk_data(card, &card->from_host_data[slot].bd);\r\nif (queue < UNIFI_NO_OF_TX_QS)\r\n{\r\nif (card->dynamic_slot_data.from_host_used_slots[queue] == 0)\r\n{\r\nunifi_error(card->ospriv, "Goofed up used slots q = %d used slots = %d\n",\r\nqueue,\r\ncard->dynamic_slot_data.from_host_used_slots[queue]);\r\n}\r\nelse\r\n{\r\ncard->dynamic_slot_data.from_host_used_slots[queue]--;\r\n}\r\ncard->dynamic_slot_data.packets_txed[queue]++;\r\ncard->dynamic_slot_data.total_packets_txed++;\r\nif (card->dynamic_slot_data.total_packets_txed >= card->dynamic_slot_data.packets_interval)\r\n{\r\nCardReassignDynamicReservation(card);\r\n}\r\n}\r\nunifi_trace(card->ospriv, UDBG4, "CardClearFromHostDataSlot: slot %d recycled %p\n", slot, os_data_ptr);\r\n}\r\nvoid CardClearFromHostDataSlotWithoutFreeingBulkData(card_t *card, const s16 slot)\r\n{\r\nu8 queue = card->from_host_data[slot].queue;\r\nUNIFI_INIT_BULK_DATA(&card->from_host_data[slot].bd);\r\nqueue = card->from_host_data[slot].queue;\r\nif (queue < UNIFI_NO_OF_TX_QS)\r\n{\r\nif (card->dynamic_slot_data.from_host_used_slots[queue] == 0)\r\n{\r\nunifi_error(card->ospriv, "Goofed up used slots q = %d used slots = %d\n",\r\nqueue,\r\ncard->dynamic_slot_data.from_host_used_slots[queue]);\r\n}\r\nelse\r\n{\r\ncard->dynamic_slot_data.from_host_used_slots[queue]--;\r\n}\r\ncard->dynamic_slot_data.packets_txed[queue]++;\r\ncard->dynamic_slot_data.total_packets_txed++;\r\nif (card->dynamic_slot_data.total_packets_txed >=\r\ncard->dynamic_slot_data.packets_interval)\r\n{\r\nCardReassignDynamicReservation(card);\r\n}\r\n}\r\n}\r\nu16 CardGetDataSlotSize(card_t *card)\r\n{\r\nreturn card->config_data.data_slot_size;\r\n}\r\nu16 CardGetFreeFromHostDataSlots(card_t *card)\r\n{\r\nu16 i, n = 0;\r\nfor (i = 0; i < card->config_data.num_fromhost_data_slots; i++)\r\n{\r\nif (card->from_host_data[i].bd.data_length == 0)\r\n{\r\nn++;\r\n}\r\n}\r\nreturn n;\r\n}\r\nu16 CardAreAllFromHostDataSlotsEmpty(card_t *card)\r\n{\r\nu16 i;\r\nfor (i = 0; i < card->config_data.num_fromhost_data_slots; i++)\r\n{\r\nif (card->from_host_data[i].bd.data_length != 0)\r\n{\r\nreturn 0;\r\n}\r\n}\r\nreturn 1;\r\n}\r\nstatic CsrResult unifi_identify_hw(card_t *card)\r\n{\r\ncard->chip_id = card->sdio_if->sdioId.cardId;\r\ncard->function = card->sdio_if->sdioId.sdioFunction;\r\ncard->sdio_io_block_size = card->sdio_if->blockSize;\r\ncard->sdio_io_block_pad = (card->sdio_if->features & CSR_SDIO_FEATURE_BYTE_MODE)?FALSE : TRUE;\r\ncard->helper = ChipHelper_GetVersionSdio((u8)card->chip_id);\r\nif (!card->helper)\r\n{\r\nunifi_error(card->ospriv, "Null ChipHelper\n");\r\n}\r\nunifi_info(card->ospriv, "Chip ID 0x%02X Function %u Block Size %u Name %s(%s)\n",\r\ncard->chip_id, card->function, card->sdio_io_block_size,\r\nChipHelper_MarketingName(card->helper),\r\nChipHelper_FriendlyName(card->helper));\r\nreturn CSR_RESULT_SUCCESS;\r\n}\r\nstatic CsrResult unifi_prepare_hw(card_t *card)\r\n{\r\nCsrResult r;\r\nCsrResult csrResult;\r\nenum unifi_host_state old_state = card->host_state;\r\nr = unifi_identify_hw(card);\r\nif (r == CSR_WIFI_HIP_RESULT_NO_DEVICE)\r\n{\r\nreturn r;\r\n}\r\nif (r != CSR_RESULT_SUCCESS)\r\n{\r\nunifi_error(card->ospriv, "Failed to identify hw\n");\r\nreturn r;\r\n}\r\nunifi_trace(card->ospriv, UDBG1,\r\n"%s mode SDIO\n", card->sdio_io_block_pad?"Block" : "Byte");\r\nr = unifi_set_host_state(card, UNIFI_HOST_STATE_AWAKE);\r\nif (r == CSR_WIFI_HIP_RESULT_NO_DEVICE)\r\n{\r\nreturn r;\r\n}\r\nif (old_state == UNIFI_HOST_STATE_TORPID)\r\n{\r\ncsrResult = CsrSdioMaxBusClockFrequencySet(card->sdio_if, UNIFI_SDIO_CLOCK_INIT_HZ);\r\nif (csrResult != CSR_RESULT_SUCCESS)\r\n{\r\nr = ConvertCsrSdioToCsrHipResult(card, csrResult);\r\nreturn r;\r\n}\r\ncard->sdio_clock_speed = UNIFI_SDIO_CLOCK_INIT_HZ;\r\n}\r\ncsrResult = CsrSdioFunctionEnable(card->sdio_if);\r\nif (csrResult == CSR_SDIO_RESULT_NO_DEVICE)\r\n{\r\nreturn CSR_WIFI_HIP_RESULT_NO_DEVICE;\r\n}\r\nif (csrResult != CSR_RESULT_SUCCESS)\r\n{\r\nr = ConvertCsrSdioToCsrHipResult(card, csrResult);\r\nunifi_error(card->ospriv, "Failed to re-enable function %d.\n", card->function);\r\nreturn r;\r\n}\r\nbootstrap_chip_hw(card);\r\nr = unifi_read_chip_version(card);\r\nif (r != CSR_RESULT_SUCCESS)\r\n{\r\nreturn r;\r\n}\r\nreturn CSR_RESULT_SUCCESS;\r\n}\r\nstatic CsrResult unifi_read_chip_version(card_t *card)\r\n{\r\nu32 gbl_chip_version;\r\nCsrResult r;\r\nu16 ver;\r\ngbl_chip_version = ChipHelper_GBL_CHIP_VERSION(card->helper);\r\nif (gbl_chip_version != 0)\r\n{\r\nr = unifi_read_direct16(card, gbl_chip_version * 2, &ver);\r\nif (r == CSR_WIFI_HIP_RESULT_NO_DEVICE)\r\n{\r\nreturn r;\r\n}\r\nif (r != CSR_RESULT_SUCCESS)\r\n{\r\nunifi_error(card->ospriv, "Failed to read GBL_CHIP_VERSION\n");\r\nreturn r;\r\n}\r\ncard->chip_version = ver;\r\n}\r\nelse\r\n{\r\nunifi_info(card->ospriv, "Unknown Chip ID, cannot locate GBL_CHIP_VERSION\n");\r\nr = CSR_RESULT_FAILURE;\r\n}\r\nunifi_info(card->ospriv, "Chip Version 0x%04X\n", card->chip_version);\r\nreturn r;\r\n}\r\nstatic CsrResult unifi_reset_hardware(card_t *card)\r\n{\r\nCsrResult r;\r\nu16 new_block_size = UNIFI_IO_BLOCK_SIZE;\r\nCsrResult csrResult;\r\nr = unifi_prepare_hw(card);\r\nif (r == CSR_WIFI_HIP_RESULT_NO_DEVICE)\r\n{\r\nreturn r;\r\n}\r\nunifi_info(card->ospriv, "Calling CsrSdioHardReset\n");\r\ncsrResult = CsrSdioHardReset(card->sdio_if);\r\nif (csrResult == CSR_RESULT_SUCCESS)\r\n{\r\nunifi_info(card->ospriv, "CsrSdioHardReset succeeded on reseting UniFi\n");\r\nr = unifi_prepare_hw(card);\r\nif (r == CSR_WIFI_HIP_RESULT_NO_DEVICE)\r\n{\r\nreturn r;\r\n}\r\nif (r != CSR_RESULT_SUCCESS)\r\n{\r\nunifi_error(card->ospriv, "unifi_prepare_hw failed after hard reset\n");\r\nreturn r;\r\n}\r\n}\r\nelse if (csrResult == CSR_SDIO_RESULT_NO_DEVICE)\r\n{\r\nreturn CSR_WIFI_HIP_RESULT_NO_DEVICE;\r\n}\r\nelse\r\n{\r\nunifi_info(card->ospriv, "Falling back to software hard reset\n");\r\nr = unifi_card_hard_reset(card);\r\nif (r == CSR_WIFI_HIP_RESULT_NO_DEVICE)\r\n{\r\nreturn r;\r\n}\r\nif (r != CSR_RESULT_SUCCESS)\r\n{\r\nunifi_error(card->ospriv, "software hard reset failed\n");\r\nreturn r;\r\n}\r\nif (card->chip_version == 0)\r\n{\r\nr = unifi_read_chip_version(card);\r\nif (r != CSR_RESULT_SUCCESS)\r\n{\r\nreturn r;\r\n}\r\n}\r\n}\r\n#ifdef CSR_WIFI_HIP_SDIO_BLOCK_SIZE\r\nnew_block_size = CSR_WIFI_HIP_SDIO_BLOCK_SIZE;\r\n#endif\r\ncsrResult = CsrSdioBlockSizeSet(card->sdio_if, new_block_size);\r\nr = ConvertCsrSdioToCsrHipResult(card, csrResult);\r\nif (card->sdio_if->blockSize != new_block_size)\r\n{\r\nunifi_info(card->ospriv,\r\n"Actually got block size %d\n", card->sdio_if->blockSize);\r\n}\r\nif (card->sdio_if->blockSize == 0)\r\n{\r\nunifi_info(card->ospriv, "Block size 0, block mode not available\n");\r\ncard->sdio_io_block_size = 1;\r\nif (!(card->sdio_if->features & CSR_SDIO_FEATURE_BYTE_MODE))\r\n{\r\nunifi_error(card->ospriv, "Requires byte mode\n");\r\nr = CSR_WIFI_HIP_RESULT_INVALID_VALUE;\r\n}\r\n}\r\nelse\r\n{\r\ncard->sdio_io_block_size = card->sdio_if->blockSize;\r\n}\r\nreturn r;\r\n}\r\nstatic CsrResult card_reset_method_io_enable(card_t *card)\r\n{\r\nCsrResult r;\r\nCsrResult csrResult;\r\nunifi_trace(card->ospriv, UDBG1, "Hard reset (IO_ENABLE)\n");\r\ncsrResult = CsrSdioFunctionDisable(card->sdio_if);\r\nif (csrResult == CSR_SDIO_RESULT_NO_DEVICE)\r\n{\r\nreturn CSR_WIFI_HIP_RESULT_NO_DEVICE;\r\n}\r\nif (csrResult != CSR_RESULT_SUCCESS)\r\n{\r\nr = ConvertCsrSdioToCsrHipResult(card, csrResult);\r\nunifi_warning(card->ospriv, "SDIO error writing IO_ENABLE: %d\n", r);\r\n}\r\nelse\r\n{\r\nCsrThreadSleep(RESET_SETTLE_DELAY);\r\nr = card_wait_for_unifi_to_disable(card);\r\nif (r == CSR_WIFI_HIP_RESULT_NO_DEVICE)\r\n{\r\nreturn r;\r\n}\r\nif (r == CSR_RESULT_SUCCESS)\r\n{\r\nr = card_wait_for_unifi_to_reset(card);\r\nif (r == CSR_WIFI_HIP_RESULT_NO_DEVICE)\r\n{\r\nreturn r;\r\n}\r\n}\r\n}\r\nif (r != CSR_RESULT_SUCCESS)\r\n{\r\nunifi_trace(card->ospriv, UDBG1, "Hard reset (CSR_FUNC_EN)\n");\r\nr = sdio_write_f0(card, SDIO_CSR_FUNC_EN, 0);\r\nif (r == CSR_WIFI_HIP_RESULT_NO_DEVICE)\r\n{\r\nreturn r;\r\n}\r\nif (r != CSR_RESULT_SUCCESS)\r\n{\r\nunifi_warning(card->ospriv, "SDIO error writing SDIO_CSR_FUNC_EN: %d\n", r);\r\nreturn r;\r\n}\r\nelse\r\n{\r\nCsrThreadSleep(RESET_SETTLE_DELAY);\r\nr = card_wait_for_unifi_to_reset(card);\r\nif (r == CSR_WIFI_HIP_RESULT_NO_DEVICE)\r\n{\r\nreturn r;\r\n}\r\n}\r\n}\r\nif (r != CSR_RESULT_SUCCESS)\r\n{\r\nunifi_warning(card->ospriv, "card_reset_method_io_enable failed to reset UniFi\n");\r\n}\r\nreturn r;\r\n}\r\nstatic CsrResult card_reset_method_dbg_reset(card_t *card)\r\n{\r\nCsrResult r;\r\nif (card->host_state == UNIFI_HOST_STATE_TORPID)\r\n{\r\nr = unifi_set_host_state(card, UNIFI_HOST_STATE_DROWSY);\r\nif (r == CSR_WIFI_HIP_RESULT_NO_DEVICE)\r\n{\r\nreturn r;\r\n}\r\nif (r != CSR_RESULT_SUCCESS)\r\n{\r\nunifi_error(card->ospriv, "Failed to set UNIFI_HOST_STATE_DROWSY\n");\r\nreturn r;\r\n}\r\nCsrThreadSleep(5);\r\n}\r\nr = unifi_card_stop_processor(card, UNIFI_PROC_BOTH);\r\nif (r == CSR_WIFI_HIP_RESULT_NO_DEVICE)\r\n{\r\nreturn r;\r\n}\r\nif (r != CSR_RESULT_SUCCESS)\r\n{\r\nunifi_error(card->ospriv, "Can't stop processors\n");\r\nreturn r;\r\n}\r\nunifi_trace(card->ospriv, UDBG1, "Hard reset (DBG_RESET)\n");\r\nr = unifi_write_direct_8_or_16(card, ChipHelper_DBG_RESET(card->helper) * 2, 1);\r\nif (r == CSR_WIFI_HIP_RESULT_NO_DEVICE)\r\n{\r\nreturn r;\r\n}\r\nif (r != CSR_RESULT_SUCCESS)\r\n{\r\nunifi_warning(card->ospriv, "SDIO error writing DBG_RESET: %d\n", r);\r\nreturn r;\r\n}\r\nCsrThreadSleep(RESET_SETTLE_DELAY);\r\nr = card_wait_for_unifi_to_reset(card);\r\nif (r == CSR_WIFI_HIP_RESULT_NO_DEVICE)\r\n{\r\nreturn r;\r\n}\r\nif (r != CSR_RESULT_SUCCESS)\r\n{\r\nunifi_warning(card->ospriv, "card_reset_method_dbg_reset failed to reset UniFi\n");\r\n}\r\nreturn r;\r\n}\r\nCsrResult unifi_card_hard_reset(card_t *card)\r\n{\r\nCsrResult r;\r\nconst struct chip_helper_reset_values *init_data;\r\nu32 chunks;\r\ncard->proc_select = (u32)(-1);\r\ncard->dmem_page = (u32)(-1);\r\ncard->pmem_page = (u32)(-1);\r\nr = unifi_identify_hw(card);\r\nif (r == CSR_WIFI_HIP_RESULT_NO_DEVICE)\r\n{\r\nreturn r;\r\n}\r\nif (r != CSR_RESULT_SUCCESS)\r\n{\r\nunifi_error(card->ospriv, "unifi_card_hard_reset failed to identify h/w\n");\r\nreturn r;\r\n}\r\nchunks = ChipHelper_HostResetSequence(card->helper, &init_data);\r\nif (chunks != 0)\r\n{\r\nunifi_error(card->ospriv,\r\n"Hard reset (Code download) is unsupported\n");\r\nreturn CSR_RESULT_FAILURE;\r\n}\r\nif (card->chip_id > SDIO_CARD_ID_UNIFI_2)\r\n{\r\nr = card_reset_method_io_enable(card);\r\nif (r == CSR_WIFI_HIP_RESULT_NO_DEVICE)\r\n{\r\nreturn r;\r\n}\r\nif (r == CSR_RESULT_SUCCESS)\r\n{\r\nreturn r;\r\n}\r\n}\r\nr = card_reset_method_dbg_reset(card);\r\nreturn r;\r\n}\r\nCsrResult CardGenInt(card_t *card)\r\n{\r\nCsrResult r;\r\nif (card->chip_id > SDIO_CARD_ID_UNIFI_2)\r\n{\r\nr = sdio_write_f0(card, SDIO_CSR_FROM_HOST_SCRATCH0,\r\n(u8)card->unifi_interrupt_seq);\r\n}\r\nelse\r\n{\r\nr = unifi_write_direct_8_or_16(card,\r\nChipHelper_SHARED_IO_INTERRUPT(card->helper) * 2,\r\n(u8)card->unifi_interrupt_seq);\r\n}\r\nif (r == CSR_WIFI_HIP_RESULT_NO_DEVICE)\r\n{\r\nreturn r;\r\n}\r\nif (r != CSR_RESULT_SUCCESS)\r\n{\r\nunifi_error(card->ospriv, "SDIO error writing UNIFI_SHARED_IO_INTERRUPT: %d\n", r);\r\nreturn r;\r\n}\r\ncard->unifi_interrupt_seq++;\r\nreturn CSR_RESULT_SUCCESS;\r\n}\r\nCsrResult CardEnableInt(card_t *card)\r\n{\r\nCsrResult r;\r\nu8 int_enable;\r\nr = sdio_read_f0(card, SDIO_INT_ENABLE, &int_enable);\r\nif (r == CSR_WIFI_HIP_RESULT_NO_DEVICE)\r\n{\r\nreturn r;\r\n}\r\nif (r != CSR_RESULT_SUCCESS)\r\n{\r\nunifi_error(card->ospriv, "SDIO error reading SDIO_INT_ENABLE\n");\r\nreturn r;\r\n}\r\nint_enable |= (1 << card->function) | UNIFI_SD_INT_ENABLE_IENM;\r\nr = sdio_write_f0(card, SDIO_INT_ENABLE, int_enable);\r\nif (r == CSR_WIFI_HIP_RESULT_NO_DEVICE)\r\n{\r\nreturn r;\r\n}\r\nif (r != CSR_RESULT_SUCCESS)\r\n{\r\nunifi_error(card->ospriv, "SDIO error writing SDIO_INT_ENABLE\n");\r\nreturn r;\r\n}\r\nreturn CSR_RESULT_SUCCESS;\r\n}\r\nCsrResult CardDisableInt(card_t *card)\r\n{\r\nCsrResult r;\r\nu8 int_enable;\r\nr = sdio_read_f0(card, SDIO_INT_ENABLE, &int_enable);\r\nif (r == CSR_WIFI_HIP_RESULT_NO_DEVICE)\r\n{\r\nreturn r;\r\n}\r\nif (r != CSR_RESULT_SUCCESS)\r\n{\r\nunifi_error(card->ospriv, "SDIO error reading SDIO_INT_ENABLE\n");\r\nreturn r;\r\n}\r\nint_enable &= ~(1 << card->function);\r\nr = sdio_write_f0(card, SDIO_INT_ENABLE, int_enable);\r\nif (r == CSR_WIFI_HIP_RESULT_NO_DEVICE)\r\n{\r\nreturn r;\r\n}\r\nif (r != CSR_RESULT_SUCCESS)\r\n{\r\nunifi_error(card->ospriv, "SDIO error writing SDIO_INT_ENABLE\n");\r\nreturn r;\r\n}\r\nreturn CSR_RESULT_SUCCESS;\r\n}\r\nCsrResult CardPendingInt(card_t *card, u8 *pintr)\r\n{\r\nCsrResult r;\r\nu8 pending;\r\n*pintr = FALSE;\r\nr = sdio_read_f0(card, SDIO_INT_PENDING, &pending);\r\nif (r == CSR_WIFI_HIP_RESULT_NO_DEVICE)\r\n{\r\nreturn r;\r\n}\r\nif (r != CSR_RESULT_SUCCESS)\r\n{\r\nunifi_error(card->ospriv, "SDIO error reading SDIO_INT_PENDING\n");\r\nreturn r;\r\n}\r\n*pintr = (pending & (1 << card->function))?TRUE : FALSE;\r\nreturn CSR_RESULT_SUCCESS;\r\n}\r\nCsrResult CardClearInt(card_t *card)\r\n{\r\nCsrResult r;\r\nu8 intr;\r\nif (card->chip_id > SDIO_CARD_ID_UNIFI_2)\r\n{\r\nr = CardPendingInt(card, &intr);\r\nif (intr == FALSE)\r\n{\r\nreturn r;\r\n}\r\nr = sdio_write_f0(card, SDIO_CSR_HOST_INT_CLEAR, 1);\r\nif (r == CSR_WIFI_HIP_RESULT_NO_DEVICE)\r\n{\r\nreturn r;\r\n}\r\nif (r != CSR_RESULT_SUCCESS)\r\n{\r\nunifi_error(card->ospriv, "SDIO error writing SDIO_CSR_HOST_INT_CLEAR\n");\r\n}\r\n}\r\nelse\r\n{\r\nr = unifi_write_direct_8_or_16(card,\r\nChipHelper_SDIO_HOST_INT(card->helper) * 2,\r\n0);\r\nif (r == CSR_WIFI_HIP_RESULT_NO_DEVICE)\r\n{\r\nreturn r;\r\n}\r\nif (r != CSR_RESULT_SUCCESS)\r\n{\r\nunifi_error(card->ospriv, "SDIO error writing UNIFI_SDIO_HOST_INT\n");\r\n}\r\n}\r\nreturn r;\r\n}\r\nCsrResult CardIntEnabled(card_t *card, u8 *enabled)\r\n{\r\nCsrResult r;\r\nu8 int_enable;\r\nr = sdio_read_f0(card, SDIO_INT_ENABLE, &int_enable);\r\nif (r == CSR_WIFI_HIP_RESULT_NO_DEVICE)\r\n{\r\nreturn r;\r\n}\r\nif (r != CSR_RESULT_SUCCESS)\r\n{\r\nunifi_error(card->ospriv, "SDIO error reading SDIO_INT_ENABLE\n");\r\nreturn r;\r\n}\r\n*enabled = (int_enable & (1 << card->function))?TRUE : FALSE;\r\nreturn CSR_RESULT_SUCCESS;\r\n}\r\nCsrResult CardWriteBulkData(card_t *card, card_signal_t *csptr, unifi_TrafficQueue queue)\r\n{\r\nu16 i, slots[UNIFI_MAX_DATA_REFERENCES], j = 0;\r\nu8 *packed_sigptr, num_slots_required = 0;\r\nbulk_data_desc_t *bulkdata = csptr->bulkdata;\r\ns16 h, nslots;\r\nfor (i = 0; i < UNIFI_MAX_DATA_REFERENCES; i++)\r\n{\r\nif (bulkdata[i].data_length != 0)\r\n{\r\nnum_slots_required++;\r\n}\r\n}\r\nif (num_slots_required != 0)\r\n{\r\nif (queue == UNIFI_TRAFFIC_Q_MLME)\r\n{\r\nh = card->config_data.num_fromhost_data_slots - UNIFI_RESERVED_COMMAND_SLOTS;\r\nfor (i = 0; i < card->config_data.num_fromhost_data_slots; i++)\r\n{\r\nif (card->from_host_data[h].bd.data_length == 0)\r\n{\r\nslots[j++] = h;\r\nif (j == num_slots_required)\r\n{\r\nbreak;\r\n}\r\n}\r\nif (++h >= card->config_data.num_fromhost_data_slots)\r\n{\r\nh = 0;\r\n}\r\n}\r\n}\r\nelse\r\n{\r\nif (card->dynamic_slot_data.from_host_used_slots[queue]\r\n< card->dynamic_slot_data.from_host_max_slots[queue])\r\n{\r\nnslots = card->config_data.num_fromhost_data_slots - UNIFI_RESERVED_COMMAND_SLOTS;\r\nh = card->from_host_data_head;\r\nfor (i = 0; i < nslots; i++)\r\n{\r\nif (card->from_host_data[h].bd.data_length == 0)\r\n{\r\nslots[j++] = h;\r\nif (j == num_slots_required)\r\n{\r\nbreak;\r\n}\r\n}\r\nif (++h >= nslots)\r\n{\r\nh = 0;\r\n}\r\n}\r\ncard->from_host_data_head = h;\r\n}\r\n}\r\nif (j != num_slots_required)\r\n{\r\nunifi_trace(card->ospriv, UDBG5, "CardWriteBulkData: didn't find free slot/s\n");\r\nif ((queue != UNIFI_TRAFFIC_Q_MLME) && (card->dynamic_slot_data.queue_stable[queue] == FALSE))\r\n{\r\nCardCheckDynamicReservation(card, queue);\r\n}\r\nfor (i = 0; i < card->config_data.num_fromhost_data_slots; i++)\r\n{\r\nunifi_trace(card->ospriv, UDBG5, "fh data slot %d: %d\n", i, card->from_host_data[i].bd.data_length);\r\n}\r\nreturn CSR_RESULT_FAILURE;\r\n}\r\n}\r\npacked_sigptr = csptr->sigbuf;\r\nj = 0;\r\nfor (i = 0; i < UNIFI_MAX_DATA_REFERENCES; i++)\r\n{\r\nif (bulkdata[i].data_length == 0)\r\n{\r\nSET_PACKED_DATAREF_SLOT(packed_sigptr, i, 0);\r\nSET_PACKED_DATAREF_LEN(packed_sigptr, i, 0);\r\n}\r\nelse\r\n{\r\nSET_PACKED_DATAREF_SLOT(packed_sigptr, i, slots[j] | (((u16)packed_sigptr[SIZEOF_SIGNAL_HEADER + (i * SIZEOF_DATAREF) + 1]) << 8));\r\nSET_PACKED_DATAREF_LEN(packed_sigptr, i, bulkdata[i].data_length);\r\ncard->from_host_data[slots[j]].bd.os_data_ptr = bulkdata[i].os_data_ptr;\r\ncard->from_host_data[slots[j]].bd.os_net_buf_ptr = bulkdata[i].os_net_buf_ptr;\r\ncard->from_host_data[slots[j]].bd.data_length = bulkdata[i].data_length;\r\ncard->from_host_data[slots[j]].bd.net_buf_length = bulkdata[i].net_buf_length;\r\ncard->from_host_data[slots[j]].queue = queue;\r\nunifi_trace(card->ospriv, UDBG4, "CardWriteBulkData sig=0x%x, fh slot %d = %p\n",\r\nGET_SIGNAL_ID(packed_sigptr), i, bulkdata[i].os_data_ptr);\r\nif (!bulkdata[i].os_data_ptr)\r\n{\r\nunifi_error(card->ospriv, "Assign null os_data_ptr (len=%d) fh slot %d, i=%d, q=%d, sig=0x%x",\r\nbulkdata[i].data_length, slots[j], i, queue, GET_SIGNAL_ID(packed_sigptr));\r\n}\r\nj++;\r\nif (queue < UNIFI_NO_OF_TX_QS)\r\n{\r\ncard->dynamic_slot_data.from_host_used_slots[queue]++;\r\n}\r\n}\r\n}\r\nreturn CSR_RESULT_SUCCESS;\r\n}\r\nbulk_data_desc_t* card_find_data_slot(card_t *card, s16 slot)\r\n{\r\ns16 sn;\r\nbulk_data_desc_t *bd;\r\nsn = slot & 0x7FFF;\r\nif (slot & SLOT_DIR_TO_HOST)\r\n{\r\nbd = &card->to_host_data[sn];\r\n}\r\nelse\r\n{\r\nbd = &card->from_host_data[sn].bd;\r\n}\r\nreturn bd;\r\n}\r\nstatic CsrResult firmware_present_in_flash(card_t *card)\r\n{\r\nCsrResult r;\r\nu16 m1, m5;\r\nif (ChipHelper_HasRom(card->helper))\r\n{\r\nreturn CSR_RESULT_SUCCESS;\r\n}\r\nif (!ChipHelper_HasFlash(card->helper))\r\n{\r\nreturn CSR_WIFI_HIP_RESULT_NOT_FOUND;\r\n}\r\nr = unifi_card_read16(card, UNIFI_MAKE_GP(EXT_FLASH, 2), &m1);\r\nif (r != CSR_RESULT_SUCCESS)\r\n{\r\nreturn r;\r\n}\r\nr = unifi_card_read16(card, UNIFI_MAKE_GP(EXT_FLASH, 10), &m5);\r\nif (r != CSR_RESULT_SUCCESS)\r\n{\r\nreturn r;\r\n}\r\nif ((m1 == 0x0008) || (m1 == 0xFFFF) ||\r\n(m1 == 0x0004) || (m5 == 0x0004) ||\r\n(m5 == 0x0008) || (m5 == 0xFFFF))\r\n{\r\nreturn CSR_WIFI_HIP_RESULT_NOT_FOUND;\r\n}\r\nreturn CSR_RESULT_SUCCESS;\r\n}\r\nstatic void bootstrap_chip_hw(card_t *card)\r\n{\r\nconst struct chip_helper_init_values *vals;\r\nu32 i, len;\r\nvoid *sdio = card->sdio_if;\r\nCsrResult csrResult;\r\nlen = ChipHelper_ClockStartupSequence(card->helper, &vals);\r\nif (len != 0)\r\n{\r\nfor (i = 0; i < len; i++)\r\n{\r\ncsrResult = CsrSdioWrite16(sdio, vals[i].addr * 2, vals[i].value);\r\nif (csrResult != CSR_RESULT_SUCCESS)\r\n{\r\nunifi_warning(card->ospriv, "Failed to write bootstrap value %d\n", i);\r\n}\r\nCsrThreadSleep(1);\r\n}\r\n}\r\n}\r\nCsrResult unifi_card_stop_processor(card_t *card, enum unifi_dbg_processors_select which)\r\n{\r\nCsrResult r = CSR_RESULT_SUCCESS;\r\nu8 status;\r\ns16 retry = 100;\r\nwhile (retry--)\r\n{\r\nr = unifi_set_proc_select(card, which);\r\nif (r != CSR_RESULT_SUCCESS)\r\n{\r\nbreak;\r\n}\r\nr = unifi_write_direct16(card, ChipHelper_DBG_EMU_CMD(card->helper) * 2, 2);\r\nif (r != CSR_RESULT_SUCCESS)\r\n{\r\nbreak;\r\n}\r\nr = unifi_read_direct_8_or_16(card,\r\nChipHelper_DBG_HOST_STOP_STATUS(card->helper) * 2,\r\n&status);\r\nif (r != CSR_RESULT_SUCCESS)\r\n{\r\nbreak;\r\n}\r\nif ((status & 1) == 1)\r\n{\r\nreturn CSR_RESULT_SUCCESS;\r\n}\r\n}\r\nif (r != CSR_RESULT_SUCCESS)\r\n{\r\nunifi_error(card->ospriv, "Failed to stop processors: SDIO error\n");\r\n}\r\nelse\r\n{\r\nunifi_error(card->ospriv, "Failed to stop processors: timeout waiting for stopped status\n");\r\nr = CSR_RESULT_FAILURE;\r\n}\r\nreturn r;\r\n}\r\nCsrResult card_start_processor(card_t *card, enum unifi_dbg_processors_select which)\r\n{\r\nCsrResult r;\r\nr = unifi_set_proc_select(card, which);\r\nif (r != CSR_RESULT_SUCCESS)\r\n{\r\nunifi_error(card->ospriv, "unifi_set_proc_select failed: %d.\n", r);\r\nreturn r;\r\n}\r\nr = unifi_write_direct_8_or_16(card,\r\nChipHelper_DBG_EMU_CMD(card->helper) * 2, 8);\r\nif (r != CSR_RESULT_SUCCESS)\r\n{\r\nreturn r;\r\n}\r\nr = unifi_write_direct_8_or_16(card,\r\nChipHelper_DBG_EMU_CMD(card->helper) * 2, 0);\r\nif (r != CSR_RESULT_SUCCESS)\r\n{\r\nreturn r;\r\n}\r\nreturn CSR_RESULT_SUCCESS;\r\n}\r\nvoid unifi_set_interrupt_mode(card_t *card, u32 mode)\r\n{\r\nif (mode == CSR_WIFI_INTMODE_RUN_BH_ONCE)\r\n{\r\nunifi_info(card->ospriv, "Scheduled interrupt mode");\r\n}\r\ncard->intmode = mode;\r\n}\r\nCsrResult unifi_start_processors(card_t *card)\r\n{\r\nreturn card_start_processor(card, UNIFI_PROC_BOTH);\r\n}\r\nvoid unifi_request_max_sdio_clock(card_t *card)\r\n{\r\ncard->request_max_clock = 1;\r\n}\r\nCsrResult unifi_set_host_state(card_t *card, enum unifi_host_state state)\r\n{\r\nCsrResult r = CSR_RESULT_SUCCESS;\r\nCsrResult csrResult;\r\nstatic const char *const states[] = {\r\n"AWAKE", "DROWSY", "TORPID"\r\n};\r\nstatic const u8 state_csr_host_wakeup[] = {\r\n1, 3, 0\r\n};\r\nstatic const u8 state_io_abort[] = {\r\n0, 2, 3\r\n};\r\nunifi_trace(card->ospriv, UDBG4, "State %s to %s\n",\r\nstates[card->host_state], states[state]);\r\nif (card->host_state == UNIFI_HOST_STATE_TORPID)\r\n{\r\nCsrSdioFunctionActive(card->sdio_if);\r\n}\r\nif (card->chip_id > SDIO_CARD_ID_UNIFI_2)\r\n{\r\nr = sdio_write_f0(card, SDIO_CSR_HOST_WAKEUP,\r\n(u8)((card->function << 4) | state_csr_host_wakeup[state]));\r\n}\r\nelse\r\n{\r\nr = sdio_write_f0(card, SDIO_IO_ABORT, state_io_abort[state]);\r\n}\r\nif (r == CSR_WIFI_HIP_RESULT_NO_DEVICE)\r\n{\r\nreturn r;\r\n}\r\nif (r != CSR_RESULT_SUCCESS)\r\n{\r\nunifi_error(card->ospriv, "Failed to write UniFi deep sleep state\n");\r\n}\r\nelse\r\n{\r\nif (card->host_state == UNIFI_HOST_STATE_TORPID)\r\n{\r\ncsrResult = CsrSdioMaxBusClockFrequencySet(card->sdio_if,\r\nUNIFI_SDIO_CLOCK_MAX_HZ);\r\nr = ConvertCsrSdioToCsrHipResult(card, csrResult);\r\nif (r != CSR_RESULT_SUCCESS && r != CSR_WIFI_HIP_RESULT_NO_DEVICE)\r\n{\r\nunifi_warning(card->ospriv,\r\n"Failed to increase the SDIO clock speed\n");\r\n}\r\nelse\r\n{\r\ncard->sdio_clock_speed = UNIFI_SDIO_CLOCK_MAX_HZ;\r\n}\r\n}\r\ncard->host_state = state;\r\nif (state == UNIFI_HOST_STATE_TORPID)\r\n{\r\ncsrResult = CsrSdioMaxBusClockFrequencySet(card->sdio_if,\r\nUNIFI_SDIO_CLOCK_SAFE_HZ);\r\nr = ConvertCsrSdioToCsrHipResult(card, csrResult);\r\nif (r != CSR_RESULT_SUCCESS && r != CSR_WIFI_HIP_RESULT_NO_DEVICE)\r\n{\r\nunifi_warning(card->ospriv,\r\n"Failed to decrease the SDIO clock speed\n");\r\n}\r\nelse\r\n{\r\ncard->sdio_clock_speed = UNIFI_SDIO_CLOCK_SAFE_HZ;\r\n}\r\nCsrSdioFunctionIdle(card->sdio_if);\r\n}\r\n}\r\nreturn r;\r\n}\r\nvoid unifi_card_info(card_t *card, card_info_t *card_info)\r\n{\r\ncard_info->chip_id = card->chip_id;\r\ncard_info->chip_version = card->chip_version;\r\ncard_info->fw_build = card->build_id;\r\ncard_info->fw_hip_version = card->config_data.version;\r\ncard_info->sdio_block_size = card->sdio_io_block_size;\r\n}\r\nCsrResult unifi_check_io_status(card_t *card, s32 *status)\r\n{\r\nu8 io_en;\r\nCsrResult r;\r\nu8 pending;\r\n*status = 0;\r\nr = sdio_read_f0(card, SDIO_IO_ENABLE, &io_en);\r\nif (r == CSR_WIFI_HIP_RESULT_NO_DEVICE)\r\n{\r\nreturn r;\r\n}\r\nif (r != CSR_RESULT_SUCCESS)\r\n{\r\nunifi_error(card->ospriv, "Failed to read SDIO_IO_ENABLE to check for spontaneous reset\n");\r\nreturn r;\r\n}\r\nif ((io_en & (1 << card->function)) == 0)\r\n{\r\ns32 fw_count;\r\n*status = 1;\r\nunifi_error(card->ospriv, "UniFi has spontaneously reset.\n");\r\nfw_count = unifi_read_shared_count(card, card->sdio_ctrl_addr + 4);\r\nif (fw_count < 0)\r\n{\r\nunifi_error(card->ospriv, "Failed to read to-host sig written count\n");\r\n}\r\nelse\r\n{\r\nunifi_error(card->ospriv, "thsw: %u (driver thinks is %u)\n",\r\nfw_count, card->to_host_signals_w);\r\n}\r\nfw_count = unifi_read_shared_count(card, card->sdio_ctrl_addr + 2);\r\nif (fw_count < 0)\r\n{\r\nunifi_error(card->ospriv, "Failed to read from-host sig read count\n");\r\n}\r\nelse\r\n{\r\nunifi_error(card->ospriv, "fhsr: %u (driver thinks is %u)\n",\r\nfw_count, card->from_host_signals_r);\r\n}\r\nreturn r;\r\n}\r\nunifi_info(card->ospriv, "UniFi function %d is enabled.\n", card->function);\r\nr = CardPendingInt(card, &pending);\r\nif (pending)\r\n{\r\nunifi_error(card->ospriv, "There is an unhandled pending interrupt.\n");\r\n*status = 2;\r\nreturn r;\r\n}\r\nreturn r;\r\n}\r\nvoid unifi_get_hip_qos_info(card_t *card, unifi_HipQosInfo *hipqosinfo)\r\n{\r\ns32 count_fhr;\r\ns16 t;\r\nu32 occupied_fh;\r\nq_t *sigq;\r\nu16 nslots, i;\r\nmemset(hipqosinfo, 0, sizeof(unifi_HipQosInfo));\r\nnslots = card->config_data.num_fromhost_data_slots;\r\nfor (i = 0; i < nslots; i++)\r\n{\r\nif (card->from_host_data[i].bd.data_length == 0)\r\n{\r\nhipqosinfo->free_fh_bulkdata_slots++;\r\n}\r\n}\r\nfor (i = 0; i < UNIFI_NO_OF_TX_QS; i++)\r\n{\r\nsigq = &card->fh_traffic_queue[i];\r\nt = sigq->q_wr_ptr - sigq->q_rd_ptr;\r\nif (t < 0)\r\n{\r\nt += sigq->q_length;\r\n}\r\nhipqosinfo->free_fh_sig_queue_slots[i] = (sigq->q_length - t) - 1;\r\n}\r\ncount_fhr = unifi_read_shared_count(card, card->sdio_ctrl_addr + 2);\r\nif (count_fhr < 0)\r\n{\r\nunifi_error(card->ospriv, "Failed to read from-host sig read count - %d\n", count_fhr);\r\nhipqosinfo->free_fh_fw_slots = 0xfa;\r\nreturn;\r\n}\r\noccupied_fh = (card->from_host_signals_w - count_fhr) % 128;\r\nhipqosinfo->free_fh_fw_slots = (u16)(card->config_data.num_fromhost_sig_frags - occupied_fh);\r\n}\r\nCsrResult ConvertCsrSdioToCsrHipResult(card_t *card, CsrResult csrResult)\r\n{\r\nCsrResult r = CSR_RESULT_FAILURE;\r\nswitch (csrResult)\r\n{\r\ncase CSR_RESULT_SUCCESS:\r\nr = CSR_RESULT_SUCCESS;\r\nbreak;\r\ncase CSR_SDIO_RESULT_TIMEOUT:\r\ncase CSR_SDIO_RESULT_CRC_ERROR:\r\nr = CSR_RESULT_FAILURE;\r\nbreak;\r\ncase CSR_SDIO_RESULT_NO_DEVICE:\r\nr = CSR_WIFI_HIP_RESULT_NO_DEVICE;\r\nbreak;\r\ncase CSR_SDIO_RESULT_INVALID_VALUE:\r\nr = CSR_WIFI_HIP_RESULT_INVALID_VALUE;\r\nbreak;\r\ncase CSR_RESULT_FAILURE:\r\nr = CSR_RESULT_FAILURE;\r\nbreak;\r\ndefault:\r\nunifi_warning(card->ospriv, "Unrecognised csrResult error code: %d\n", csrResult);\r\nbreak;\r\n}\r\nreturn r;\r\n}
