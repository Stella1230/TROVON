static int hpfb_setcolreg(unsigned regno, unsigned red, unsigned green,\r\nunsigned blue, unsigned transp,\r\nstruct fb_info *info)\r\n{\r\nunsigned char _red =red>>8;\r\nunsigned char _green=green>>8;\r\nunsigned char _blue =blue>>8;\r\nunsigned char _regno=regno;\r\nif (regno >= info->cmap.len)\r\nreturn 1;\r\nwhile (in_be16(fb_regs + 0x6002) & 0x4) udelay(1);\r\nout_be16(fb_regs + 0x60ba, 0xff);\r\nout_be16(fb_regs + 0x60b2, _red);\r\nout_be16(fb_regs + 0x60b4, _green);\r\nout_be16(fb_regs + 0x60b6, _blue);\r\nout_be16(fb_regs + 0x60b8, ~_regno);\r\nout_be16(fb_regs + 0x60f0, 0xff);\r\nudelay(100);\r\nwhile (in_be16(fb_regs + 0x6002) & 0x4) udelay(1);\r\nout_be16(fb_regs + 0x60b2, 0);\r\nout_be16(fb_regs + 0x60b4, 0);\r\nout_be16(fb_regs + 0x60b6, 0);\r\nout_be16(fb_regs + 0x60b8, 0);\r\nreturn 0;\r\n}\r\nstatic int hpfb_blank(int blank, struct fb_info *info)\r\n{\r\nout_8(fb_regs + TC_NBLANK, (blank ? 0x00 : fb_bitmask));\r\nreturn 0;\r\n}\r\nstatic void topcat_blit(int x0, int y0, int x1, int y1, int w, int h, int rr)\r\n{\r\nif (rr >= 0) {\r\nwhile (in_8(fb_regs + BUSY) & fb_bitmask)\r\n;\r\n}\r\nout_8(fb_regs + TC_FBEN, fb_bitmask);\r\nif (rr >= 0) {\r\nout_8(fb_regs + TC_WEN, fb_bitmask);\r\nout_8(fb_regs + WMRR, rr);\r\n}\r\nout_be16(fb_regs + SOURCE_X, x0);\r\nout_be16(fb_regs + SOURCE_Y, y0);\r\nout_be16(fb_regs + DEST_X, x1);\r\nout_be16(fb_regs + DEST_Y, y1);\r\nout_be16(fb_regs + WWIDTH, w);\r\nout_be16(fb_regs + WHEIGHT, h);\r\nout_8(fb_regs + WMOVE, fb_bitmask);\r\n}\r\nstatic void hpfb_copyarea(struct fb_info *info, const struct fb_copyarea *area)\r\n{\r\ntopcat_blit(area->sx, area->sy, area->dx, area->dy, area->width, area->height, RR_COPY);\r\n}\r\nstatic void hpfb_fillrect(struct fb_info *p, const struct fb_fillrect *region)\r\n{\r\nu8 clr;\r\nclr = region->color & 0xff;\r\nwhile (in_8(fb_regs + BUSY) & fb_bitmask)\r\n;\r\nout_8(fb_regs + TC_WEN, fb_bitmask & clr);\r\nout_8(fb_regs + WMRR, (region->rop == ROP_COPY ? RR_SET : RR_INVERT));\r\nout_8(fb_regs + TC_WEN, fb_bitmask & ~clr);\r\nout_8(fb_regs + WMRR, (region->rop == ROP_COPY ? RR_CLEAR : RR_NOOP));\r\ntopcat_blit(region->dx, region->dy, region->dx, region->dy, region->width, region->height, -1);\r\n}\r\nstatic int hpfb_sync(struct fb_info *info)\r\n{\r\nwhile (in_8(fb_regs + BUSY) & fb_bitmask)\r\n;\r\nout_8(fb_regs + TC_WEN, fb_bitmask);\r\nout_8(fb_regs + TC_PRR, RR_COPY);\r\nout_8(fb_regs + TC_FBEN, fb_bitmask);\r\nreturn 0;\r\n}\r\nstatic int hpfb_init_one(unsigned long phys_base, unsigned long virt_base)\r\n{\r\nunsigned long fboff, fb_width, fb_height, fb_start;\r\nint ret;\r\nfb_regs = virt_base;\r\nfboff = (in_8(fb_regs + HPFB_FBOMSB) << 8) | in_8(fb_regs + HPFB_FBOLSB);\r\nfb_info.fix.smem_start = (in_8(fb_regs + fboff) << 16);\r\nif (phys_base >= DIOII_BASE) {\r\nfb_info.fix.smem_start += phys_base;\r\n}\r\nif (DIO_SECID(fb_regs) != DIO_ID2_TOPCAT) {\r\nwhile (in_be16(fb_regs+0x4800) & 1)\r\n;\r\nout_be16(fb_regs+0x4800, 0);\r\nout_be16(fb_regs+0x4510, 0);\r\nout_be16(fb_regs+0x4512, 0);\r\nout_be16(fb_regs+0x4514, 0);\r\nout_be16(fb_regs+0x4516, 0);\r\nout_be16(fb_regs+0x4206, 0x90);\r\nout_be16(fb_regs+0x60a2, 0);\r\nout_be16(fb_regs+0x60bc, 0);\r\n}\r\nfb_width = (in_8(fb_regs + HPFB_FBWMSB) << 8) | in_8(fb_regs + HPFB_FBWLSB);\r\nfb_info.fix.line_length = fb_width;\r\nfb_height = (in_8(fb_regs + HPFB_FBHMSB) << 8) | in_8(fb_regs + HPFB_FBHLSB);\r\nfb_info.fix.smem_len = fb_width * fb_height;\r\nfb_start = (unsigned long)ioremap_writethrough(fb_info.fix.smem_start,\r\nfb_info.fix.smem_len);\r\nhpfb_defined.xres = (in_8(fb_regs + HPFB_DWMSB) << 8) | in_8(fb_regs + HPFB_DWLSB);\r\nhpfb_defined.yres = (in_8(fb_regs + HPFB_DHMSB) << 8) | in_8(fb_regs + HPFB_DHLSB);\r\nhpfb_defined.xres_virtual = hpfb_defined.xres;\r\nhpfb_defined.yres_virtual = hpfb_defined.yres;\r\nhpfb_defined.bits_per_pixel = in_8(fb_regs + HPFB_NUMPLANES);\r\nprintk(KERN_INFO "hpfb: framebuffer at 0x%lx, mapped to 0x%lx, size %dk\n",\r\nfb_info.fix.smem_start, fb_start, fb_info.fix.smem_len/1024);\r\nprintk(KERN_INFO "hpfb: mode is %dx%dx%d, linelength=%d\n",\r\nhpfb_defined.xres, hpfb_defined.yres, hpfb_defined.bits_per_pixel, fb_info.fix.line_length);\r\nout_8(fb_regs + TC_WEN, 0xff);\r\nout_8(fb_regs + TC_PRR, RR_COPY);\r\nout_8(fb_regs + TC_FBEN, 0xff);\r\nout_8(fb_start, 0xff);\r\nfb_bitmask = in_8(fb_start);\r\nout_8(fb_start, 0);\r\nout_8(fb_regs + TC_WEN, fb_bitmask);\r\nout_8(fb_regs + TC_PRR, RR_COPY);\r\nout_8(fb_regs + TC_REN, fb_bitmask);\r\nout_8(fb_regs + TC_FBEN, fb_bitmask);\r\ntopcat_blit(0, 0, 0, 0, fb_width, fb_height, RR_CLEAR);\r\nif (DIO_SECID(fb_regs) == DIO_ID2_TOPCAT)\r\nstrcat(fb_info.fix.id, "Topcat");\r\nelse\r\nstrcat(fb_info.fix.id, "Catseye");\r\nfb_info.fbops = &hpfb_ops;\r\nfb_info.flags = FBINFO_DEFAULT;\r\nfb_info.var = hpfb_defined;\r\nfb_info.screen_base = (char *)fb_start;\r\nret = fb_alloc_cmap(&fb_info.cmap, 1 << hpfb_defined.bits_per_pixel, 0);\r\nif (ret < 0)\r\ngoto unmap_screen_base;\r\nret = register_framebuffer(&fb_info);\r\nif (ret < 0)\r\ngoto dealloc_cmap;\r\nprintk(KERN_INFO "fb%d: %s frame buffer device\n",\r\nfb_info.node, fb_info.fix.id);\r\nreturn 0;\r\ndealloc_cmap:\r\nfb_dealloc_cmap(&fb_info.cmap);\r\nunmap_screen_base:\r\nif (fb_info.screen_base) {\r\niounmap(fb_info.screen_base);\r\nfb_info.screen_base = NULL;\r\n}\r\nreturn ret;\r\n}\r\nstatic int hpfb_dio_probe(struct dio_dev *d, const struct dio_device_id *ent)\r\n{\r\nunsigned long paddr, vaddr;\r\npaddr = d->resource.start;\r\nif (!request_mem_region(d->resource.start, resource_size(&d->resource), d->name))\r\nreturn -EBUSY;\r\nif (d->scode >= DIOII_SCBASE) {\r\nvaddr = (unsigned long)ioremap(paddr, resource_size(&d->resource));\r\n} else {\r\nvaddr = paddr + DIO_VIRADDRBASE;\r\n}\r\nprintk(KERN_INFO "Topcat found at DIO select code %d "\r\n"(secondary id %02x)\n", d->scode, (d->id >> 8) & 0xff);\r\nif (hpfb_init_one(paddr, vaddr)) {\r\nif (d->scode >= DIOII_SCBASE)\r\niounmap((void *)vaddr);\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}\r\nstatic void hpfb_remove_one(struct dio_dev *d)\r\n{\r\nunregister_framebuffer(&fb_info);\r\nif (d->scode >= DIOII_SCBASE)\r\niounmap((void *)fb_regs);\r\nrelease_mem_region(d->resource.start, resource_size(&d->resource));\r\nfb_dealloc_cmap(&fb_info.cmap);\r\nif (fb_info.screen_base)\r\niounmap(fb_info.screen_base);\r\n}\r\nint __init hpfb_init(void)\r\n{\r\nunsigned int sid;\r\nmm_segment_t fs;\r\nunsigned char i;\r\nint err;\r\n#define INTFBVADDR 0xf0560000\r\n#define INTFBPADDR 0x560000\r\nif (!MACH_IS_HP300)\r\nreturn -ENODEV;\r\nif (fb_get_options("hpfb", NULL))\r\nreturn -ENODEV;\r\nerr = dio_register_driver(&hpfb_driver);\r\nif (err)\r\nreturn err;\r\nfs = get_fs();\r\nset_fs(KERNEL_DS);\r\nerr = get_user(i, (unsigned char *)INTFBVADDR + DIO_IDOFF);\r\nset_fs(fs);\r\nif (!err && (i == DIO_ID_FBUFFER) && topcat_sid_ok(sid = DIO_SECID(INTFBVADDR))) {\r\nif (!request_mem_region(INTFBPADDR, DIO_DEVSIZE, "Internal Topcat"))\r\nreturn -EBUSY;\r\nprintk(KERN_INFO "Internal Topcat found (secondary id %02x)\n", sid);\r\nif (hpfb_init_one(INTFBPADDR, INTFBVADDR)) {\r\nreturn -ENOMEM;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nvoid __exit hpfb_cleanup_module(void)\r\n{\r\ndio_unregister_driver(&hpfb_driver);\r\n}
