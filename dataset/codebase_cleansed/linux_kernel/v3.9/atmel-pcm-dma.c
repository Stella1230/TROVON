static void atmel_pcm_dma_irq(u32 ssc_sr,\r\nstruct snd_pcm_substream *substream)\r\n{\r\nstruct atmel_pcm_dma_params *prtd;\r\nprtd = snd_dmaengine_pcm_get_data(substream);\r\nif (ssc_sr & prtd->mask->ssc_error) {\r\nif (snd_pcm_running(substream))\r\npr_warn("atmel-pcm: buffer %s on %s (SSC_SR=%#x)\n",\r\nsubstream->stream == SNDRV_PCM_STREAM_PLAYBACK\r\n? "underrun" : "overrun", prtd->name,\r\nssc_sr);\r\nssc_writex(prtd->ssc->regs, SSC_CR, prtd->mask->ssc_disable);\r\nsnd_pcm_stop(substream, SNDRV_PCM_STATE_XRUN);\r\nssc_readx(prtd->ssc->regs, SSC_RHR);\r\nssc_readx(prtd->ssc->regs, SSC_SR);\r\n}\r\n}\r\nstatic bool filter(struct dma_chan *chan, void *slave)\r\n{\r\nstruct at_dma_slave *sl = slave;\r\nif (sl->dma_dev == chan->device->dev) {\r\nchan->private = sl;\r\nreturn true;\r\n} else {\r\nreturn false;\r\n}\r\n}\r\nstatic int atmel_pcm_configure_dma(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params)\r\n{\r\nstruct atmel_pcm_dma_params *prtd;\r\nstruct ssc_device *ssc;\r\nstruct dma_chan *dma_chan;\r\nstruct dma_slave_config slave_config;\r\nint ret;\r\nprtd = snd_dmaengine_pcm_get_data(substream);\r\nssc = prtd->ssc;\r\nret = snd_hwparams_to_dma_slave_config(substream, params,\r\n&slave_config);\r\nif (ret) {\r\npr_err("atmel-pcm: hwparams to dma slave configure failed\n");\r\nreturn ret;\r\n}\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\r\nslave_config.dst_addr = (dma_addr_t)ssc->phybase + SSC_THR;\r\nslave_config.dst_maxburst = 1;\r\n} else {\r\nslave_config.src_addr = (dma_addr_t)ssc->phybase + SSC_RHR;\r\nslave_config.src_maxburst = 1;\r\n}\r\nslave_config.device_fc = false;\r\ndma_chan = snd_dmaengine_pcm_get_chan(substream);\r\nif (dmaengine_slave_config(dma_chan, &slave_config)) {\r\npr_err("atmel-pcm: failed to configure dma channel\n");\r\nret = -EBUSY;\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int atmel_pcm_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params)\r\n{\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\nstruct atmel_pcm_dma_params *prtd;\r\nstruct ssc_device *ssc;\r\nstruct at_dma_slave *sdata = NULL;\r\nint ret;\r\nsnd_pcm_set_runtime_buffer(substream, &substream->dma_buffer);\r\nprtd = snd_soc_dai_get_dma_data(rtd->cpu_dai, substream);\r\nssc = prtd->ssc;\r\nif (ssc->pdev)\r\nsdata = ssc->pdev->dev.platform_data;\r\nret = snd_dmaengine_pcm_open(substream, filter, sdata);\r\nif (ret) {\r\npr_err("atmel-pcm: dmaengine pcm open failed\n");\r\nreturn -EINVAL;\r\n}\r\nsnd_dmaengine_pcm_set_data(substream, prtd);\r\nret = atmel_pcm_configure_dma(substream, params);\r\nif (ret) {\r\npr_err("atmel-pcm: failed to configure dmai\n");\r\ngoto err;\r\n}\r\nprtd->dma_intr_handler = atmel_pcm_dma_irq;\r\nreturn 0;\r\nerr:\r\nsnd_dmaengine_pcm_close(substream);\r\nreturn ret;\r\n}\r\nstatic int atmel_pcm_dma_prepare(struct snd_pcm_substream *substream)\r\n{\r\nstruct atmel_pcm_dma_params *prtd;\r\nprtd = snd_dmaengine_pcm_get_data(substream);\r\nssc_writex(prtd->ssc->regs, SSC_IER, prtd->mask->ssc_error);\r\nssc_writex(prtd->ssc->regs, SSC_CR, prtd->mask->ssc_enable);\r\nreturn 0;\r\n}\r\nstatic int atmel_pcm_open(struct snd_pcm_substream *substream)\r\n{\r\nsnd_soc_set_runtime_hwparams(substream, &atmel_pcm_dma_hardware);\r\nreturn 0;\r\n}\r\nstatic int atmel_pcm_close(struct snd_pcm_substream *substream)\r\n{\r\nsnd_dmaengine_pcm_close(substream);\r\nreturn 0;\r\n}\r\nint atmel_pcm_dma_platform_register(struct device *dev)\r\n{\r\nreturn snd_soc_register_platform(dev, &atmel_soc_platform);\r\n}\r\nvoid atmel_pcm_dma_platform_unregister(struct device *dev)\r\n{\r\nsnd_soc_unregister_platform(dev);\r\n}
