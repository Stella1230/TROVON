static inline char mon_text_get_setup(struct mon_event_text *ep,\r\nstruct urb *urb, char ev_type, struct mon_bus *mbus)\r\n{\r\nif (ep->xfertype != USB_ENDPOINT_XFER_CONTROL || ev_type != 'S')\r\nreturn '-';\r\nif (urb->setup_packet == NULL)\r\nreturn 'Z';\r\nmemcpy(ep->setup, urb->setup_packet, SETUP_MAX);\r\nreturn 0;\r\n}\r\nstatic inline char mon_text_get_data(struct mon_event_text *ep, struct urb *urb,\r\nint len, char ev_type, struct mon_bus *mbus)\r\n{\r\nvoid *src;\r\nif (len <= 0)\r\nreturn 'L';\r\nif (len >= DATA_MAX)\r\nlen = DATA_MAX;\r\nif (ep->is_in) {\r\nif (ev_type != 'C')\r\nreturn '<';\r\n} else {\r\nif (ev_type != 'S')\r\nreturn '>';\r\n}\r\nif (urb->num_sgs == 0) {\r\nsrc = urb->transfer_buffer;\r\nif (src == NULL)\r\nreturn 'Z';\r\n} else {\r\nstruct scatterlist *sg = urb->sg;\r\nif (PageHighMem(sg_page(sg)))\r\nreturn 'D';\r\nlen = min_t(int, sg->length, len);\r\nsrc = sg_virt(sg);\r\n}\r\nmemcpy(ep->data, src, len);\r\nreturn 0;\r\n}\r\nstatic inline unsigned int mon_get_timestamp(void)\r\n{\r\nstruct timeval tval;\r\nunsigned int stamp;\r\ndo_gettimeofday(&tval);\r\nstamp = tval.tv_sec & 0xFFF;\r\nstamp = stamp * 1000000 + tval.tv_usec;\r\nreturn stamp;\r\n}\r\nstatic void mon_text_event(struct mon_reader_text *rp, struct urb *urb,\r\nchar ev_type, int status)\r\n{\r\nstruct mon_event_text *ep;\r\nunsigned int stamp;\r\nstruct usb_iso_packet_descriptor *fp;\r\nstruct mon_iso_desc *dp;\r\nint i, ndesc;\r\nstamp = mon_get_timestamp();\r\nif (rp->nevents >= EVENT_MAX ||\r\n(ep = kmem_cache_alloc(rp->e_slab, GFP_ATOMIC)) == NULL) {\r\nrp->r.m_bus->cnt_text_lost++;\r\nreturn;\r\n}\r\nep->type = ev_type;\r\nep->id = (unsigned long) urb;\r\nep->busnum = urb->dev->bus->busnum;\r\nep->devnum = urb->dev->devnum;\r\nep->epnum = usb_endpoint_num(&urb->ep->desc);\r\nep->xfertype = usb_endpoint_type(&urb->ep->desc);\r\nep->is_in = usb_urb_dir_in(urb);\r\nep->tstamp = stamp;\r\nep->length = (ev_type == 'S') ?\r\nurb->transfer_buffer_length : urb->actual_length;\r\nep->status = status;\r\nif (ep->xfertype == USB_ENDPOINT_XFER_INT) {\r\nep->interval = urb->interval;\r\n} else if (ep->xfertype == USB_ENDPOINT_XFER_ISOC) {\r\nep->interval = urb->interval;\r\nep->start_frame = urb->start_frame;\r\nep->error_count = urb->error_count;\r\n}\r\nep->numdesc = urb->number_of_packets;\r\nif (ep->xfertype == USB_ENDPOINT_XFER_ISOC &&\r\nurb->number_of_packets > 0) {\r\nif ((ndesc = urb->number_of_packets) > ISODESC_MAX)\r\nndesc = ISODESC_MAX;\r\nfp = urb->iso_frame_desc;\r\ndp = ep->isodesc;\r\nfor (i = 0; i < ndesc; i++) {\r\ndp->status = fp->status;\r\ndp->offset = fp->offset;\r\ndp->length = (ev_type == 'S') ?\r\nfp->length : fp->actual_length;\r\nfp++;\r\ndp++;\r\n}\r\nif (ev_type == 'C')\r\nep->length = urb->transfer_buffer_length;\r\n}\r\nep->setup_flag = mon_text_get_setup(ep, urb, ev_type, rp->r.m_bus);\r\nep->data_flag = mon_text_get_data(ep, urb, ep->length, ev_type,\r\nrp->r.m_bus);\r\nrp->nevents++;\r\nlist_add_tail(&ep->e_link, &rp->e_list);\r\nwake_up(&rp->wait);\r\n}\r\nstatic void mon_text_submit(void *data, struct urb *urb)\r\n{\r\nstruct mon_reader_text *rp = data;\r\nmon_text_event(rp, urb, 'S', -EINPROGRESS);\r\n}\r\nstatic void mon_text_complete(void *data, struct urb *urb, int status)\r\n{\r\nstruct mon_reader_text *rp = data;\r\nmon_text_event(rp, urb, 'C', status);\r\n}\r\nstatic void mon_text_error(void *data, struct urb *urb, int error)\r\n{\r\nstruct mon_reader_text *rp = data;\r\nstruct mon_event_text *ep;\r\nif (rp->nevents >= EVENT_MAX ||\r\n(ep = kmem_cache_alloc(rp->e_slab, GFP_ATOMIC)) == NULL) {\r\nrp->r.m_bus->cnt_text_lost++;\r\nreturn;\r\n}\r\nep->type = 'E';\r\nep->id = (unsigned long) urb;\r\nep->busnum = urb->dev->bus->busnum;\r\nep->devnum = urb->dev->devnum;\r\nep->epnum = usb_endpoint_num(&urb->ep->desc);\r\nep->xfertype = usb_endpoint_type(&urb->ep->desc);\r\nep->is_in = usb_urb_dir_in(urb);\r\nep->tstamp = mon_get_timestamp();\r\nep->length = 0;\r\nep->status = error;\r\nep->setup_flag = '-';\r\nep->data_flag = 'E';\r\nrp->nevents++;\r\nlist_add_tail(&ep->e_link, &rp->e_list);\r\nwake_up(&rp->wait);\r\n}\r\nstatic struct mon_event_text *mon_text_fetch(struct mon_reader_text *rp,\r\nstruct mon_bus *mbus)\r\n{\r\nstruct list_head *p;\r\nunsigned long flags;\r\nspin_lock_irqsave(&mbus->lock, flags);\r\nif (list_empty(&rp->e_list)) {\r\nspin_unlock_irqrestore(&mbus->lock, flags);\r\nreturn NULL;\r\n}\r\np = rp->e_list.next;\r\nlist_del(p);\r\n--rp->nevents;\r\nspin_unlock_irqrestore(&mbus->lock, flags);\r\nreturn list_entry(p, struct mon_event_text, e_link);\r\n}\r\nstatic int mon_text_open(struct inode *inode, struct file *file)\r\n{\r\nstruct mon_bus *mbus;\r\nstruct mon_reader_text *rp;\r\nint rc;\r\nmutex_lock(&mon_lock);\r\nmbus = inode->i_private;\r\nrp = kzalloc(sizeof(struct mon_reader_text), GFP_KERNEL);\r\nif (rp == NULL) {\r\nrc = -ENOMEM;\r\ngoto err_alloc;\r\n}\r\nINIT_LIST_HEAD(&rp->e_list);\r\ninit_waitqueue_head(&rp->wait);\r\nmutex_init(&rp->printf_lock);\r\nrp->printf_size = PRINTF_DFL;\r\nrp->printf_buf = kmalloc(rp->printf_size, GFP_KERNEL);\r\nif (rp->printf_buf == NULL) {\r\nrc = -ENOMEM;\r\ngoto err_alloc_pr;\r\n}\r\nrp->r.m_bus = mbus;\r\nrp->r.r_data = rp;\r\nrp->r.rnf_submit = mon_text_submit;\r\nrp->r.rnf_error = mon_text_error;\r\nrp->r.rnf_complete = mon_text_complete;\r\nsnprintf(rp->slab_name, SLAB_NAME_SZ, "mon_text_%p", rp);\r\nrp->e_slab = kmem_cache_create(rp->slab_name,\r\nsizeof(struct mon_event_text), sizeof(long), 0,\r\nmon_text_ctor);\r\nif (rp->e_slab == NULL) {\r\nrc = -ENOMEM;\r\ngoto err_slab;\r\n}\r\nmon_reader_add(mbus, &rp->r);\r\nfile->private_data = rp;\r\nmutex_unlock(&mon_lock);\r\nreturn 0;\r\nerr_slab:\r\nkfree(rp->printf_buf);\r\nerr_alloc_pr:\r\nkfree(rp);\r\nerr_alloc:\r\nmutex_unlock(&mon_lock);\r\nreturn rc;\r\n}\r\nstatic ssize_t mon_text_read_t(struct file *file, char __user *buf,\r\nsize_t nbytes, loff_t *ppos)\r\n{\r\nstruct mon_reader_text *rp = file->private_data;\r\nstruct mon_event_text *ep;\r\nstruct mon_text_ptr ptr;\r\nif (IS_ERR(ep = mon_text_read_wait(rp, file)))\r\nreturn PTR_ERR(ep);\r\nmutex_lock(&rp->printf_lock);\r\nptr.cnt = 0;\r\nptr.pbuf = rp->printf_buf;\r\nptr.limit = rp->printf_size;\r\nmon_text_read_head_t(rp, &ptr, ep);\r\nmon_text_read_statset(rp, &ptr, ep);\r\nptr.cnt += snprintf(ptr.pbuf + ptr.cnt, ptr.limit - ptr.cnt,\r\n" %d", ep->length);\r\nmon_text_read_data(rp, &ptr, ep);\r\nif (copy_to_user(buf, rp->printf_buf, ptr.cnt))\r\nptr.cnt = -EFAULT;\r\nmutex_unlock(&rp->printf_lock);\r\nkmem_cache_free(rp->e_slab, ep);\r\nreturn ptr.cnt;\r\n}\r\nstatic ssize_t mon_text_read_u(struct file *file, char __user *buf,\r\nsize_t nbytes, loff_t *ppos)\r\n{\r\nstruct mon_reader_text *rp = file->private_data;\r\nstruct mon_event_text *ep;\r\nstruct mon_text_ptr ptr;\r\nif (IS_ERR(ep = mon_text_read_wait(rp, file)))\r\nreturn PTR_ERR(ep);\r\nmutex_lock(&rp->printf_lock);\r\nptr.cnt = 0;\r\nptr.pbuf = rp->printf_buf;\r\nptr.limit = rp->printf_size;\r\nmon_text_read_head_u(rp, &ptr, ep);\r\nif (ep->type == 'E') {\r\nmon_text_read_statset(rp, &ptr, ep);\r\n} else if (ep->xfertype == USB_ENDPOINT_XFER_ISOC) {\r\nmon_text_read_isostat(rp, &ptr, ep);\r\nmon_text_read_isodesc(rp, &ptr, ep);\r\n} else if (ep->xfertype == USB_ENDPOINT_XFER_INT) {\r\nmon_text_read_intstat(rp, &ptr, ep);\r\n} else {\r\nmon_text_read_statset(rp, &ptr, ep);\r\n}\r\nptr.cnt += snprintf(ptr.pbuf + ptr.cnt, ptr.limit - ptr.cnt,\r\n" %d", ep->length);\r\nmon_text_read_data(rp, &ptr, ep);\r\nif (copy_to_user(buf, rp->printf_buf, ptr.cnt))\r\nptr.cnt = -EFAULT;\r\nmutex_unlock(&rp->printf_lock);\r\nkmem_cache_free(rp->e_slab, ep);\r\nreturn ptr.cnt;\r\n}\r\nstatic struct mon_event_text *mon_text_read_wait(struct mon_reader_text *rp,\r\nstruct file *file)\r\n{\r\nstruct mon_bus *mbus = rp->r.m_bus;\r\nDECLARE_WAITQUEUE(waita, current);\r\nstruct mon_event_text *ep;\r\nadd_wait_queue(&rp->wait, &waita);\r\nset_current_state(TASK_INTERRUPTIBLE);\r\nwhile ((ep = mon_text_fetch(rp, mbus)) == NULL) {\r\nif (file->f_flags & O_NONBLOCK) {\r\nset_current_state(TASK_RUNNING);\r\nremove_wait_queue(&rp->wait, &waita);\r\nreturn ERR_PTR(-EWOULDBLOCK);\r\n}\r\nschedule();\r\nif (signal_pending(current)) {\r\nremove_wait_queue(&rp->wait, &waita);\r\nreturn ERR_PTR(-EINTR);\r\n}\r\nset_current_state(TASK_INTERRUPTIBLE);\r\n}\r\nset_current_state(TASK_RUNNING);\r\nremove_wait_queue(&rp->wait, &waita);\r\nreturn ep;\r\n}\r\nstatic void mon_text_read_head_t(struct mon_reader_text *rp,\r\nstruct mon_text_ptr *p, const struct mon_event_text *ep)\r\n{\r\nchar udir, utype;\r\nudir = (ep->is_in ? 'i' : 'o');\r\nswitch (ep->xfertype) {\r\ncase USB_ENDPOINT_XFER_ISOC: utype = 'Z'; break;\r\ncase USB_ENDPOINT_XFER_INT: utype = 'I'; break;\r\ncase USB_ENDPOINT_XFER_CONTROL: utype = 'C'; break;\r\ndefault: utype = 'B';\r\n}\r\np->cnt += snprintf(p->pbuf + p->cnt, p->limit - p->cnt,\r\n"%lx %u %c %c%c:%03u:%02u",\r\nep->id, ep->tstamp, ep->type,\r\nutype, udir, ep->devnum, ep->epnum);\r\n}\r\nstatic void mon_text_read_head_u(struct mon_reader_text *rp,\r\nstruct mon_text_ptr *p, const struct mon_event_text *ep)\r\n{\r\nchar udir, utype;\r\nudir = (ep->is_in ? 'i' : 'o');\r\nswitch (ep->xfertype) {\r\ncase USB_ENDPOINT_XFER_ISOC: utype = 'Z'; break;\r\ncase USB_ENDPOINT_XFER_INT: utype = 'I'; break;\r\ncase USB_ENDPOINT_XFER_CONTROL: utype = 'C'; break;\r\ndefault: utype = 'B';\r\n}\r\np->cnt += snprintf(p->pbuf + p->cnt, p->limit - p->cnt,\r\n"%lx %u %c %c%c:%d:%03u:%u",\r\nep->id, ep->tstamp, ep->type,\r\nutype, udir, ep->busnum, ep->devnum, ep->epnum);\r\n}\r\nstatic void mon_text_read_statset(struct mon_reader_text *rp,\r\nstruct mon_text_ptr *p, const struct mon_event_text *ep)\r\n{\r\nif (ep->setup_flag == 0) {\r\np->cnt += snprintf(p->pbuf + p->cnt, p->limit - p->cnt,\r\n" s %02x %02x %04x %04x %04x",\r\nep->setup[0],\r\nep->setup[1],\r\n(ep->setup[3] << 8) | ep->setup[2],\r\n(ep->setup[5] << 8) | ep->setup[4],\r\n(ep->setup[7] << 8) | ep->setup[6]);\r\n} else if (ep->setup_flag != '-') {\r\np->cnt += snprintf(p->pbuf + p->cnt, p->limit - p->cnt,\r\n" %c __ __ ____ ____ ____", ep->setup_flag);\r\n} else {\r\np->cnt += snprintf(p->pbuf + p->cnt, p->limit - p->cnt,\r\n" %d", ep->status);\r\n}\r\n}\r\nstatic void mon_text_read_intstat(struct mon_reader_text *rp,\r\nstruct mon_text_ptr *p, const struct mon_event_text *ep)\r\n{\r\np->cnt += snprintf(p->pbuf + p->cnt, p->limit - p->cnt,\r\n" %d:%d", ep->status, ep->interval);\r\n}\r\nstatic void mon_text_read_isostat(struct mon_reader_text *rp,\r\nstruct mon_text_ptr *p, const struct mon_event_text *ep)\r\n{\r\nif (ep->type == 'S') {\r\np->cnt += snprintf(p->pbuf + p->cnt, p->limit - p->cnt,\r\n" %d:%d:%d", ep->status, ep->interval, ep->start_frame);\r\n} else {\r\np->cnt += snprintf(p->pbuf + p->cnt, p->limit - p->cnt,\r\n" %d:%d:%d:%d",\r\nep->status, ep->interval, ep->start_frame, ep->error_count);\r\n}\r\n}\r\nstatic void mon_text_read_isodesc(struct mon_reader_text *rp,\r\nstruct mon_text_ptr *p, const struct mon_event_text *ep)\r\n{\r\nint ndesc;\r\nint i;\r\nconst struct mon_iso_desc *dp;\r\np->cnt += snprintf(p->pbuf + p->cnt, p->limit - p->cnt,\r\n" %d", ep->numdesc);\r\nndesc = ep->numdesc;\r\nif (ndesc > ISODESC_MAX)\r\nndesc = ISODESC_MAX;\r\nif (ndesc < 0)\r\nndesc = 0;\r\ndp = ep->isodesc;\r\nfor (i = 0; i < ndesc; i++) {\r\np->cnt += snprintf(p->pbuf + p->cnt, p->limit - p->cnt,\r\n" %d:%u:%u", dp->status, dp->offset, dp->length);\r\ndp++;\r\n}\r\n}\r\nstatic void mon_text_read_data(struct mon_reader_text *rp,\r\nstruct mon_text_ptr *p, const struct mon_event_text *ep)\r\n{\r\nint data_len, i;\r\nif ((data_len = ep->length) > 0) {\r\nif (ep->data_flag == 0) {\r\np->cnt += snprintf(p->pbuf + p->cnt, p->limit - p->cnt,\r\n" =");\r\nif (data_len >= DATA_MAX)\r\ndata_len = DATA_MAX;\r\nfor (i = 0; i < data_len; i++) {\r\nif (i % 4 == 0) {\r\np->cnt += snprintf(p->pbuf + p->cnt,\r\np->limit - p->cnt,\r\n" ");\r\n}\r\np->cnt += snprintf(p->pbuf + p->cnt,\r\np->limit - p->cnt,\r\n"%02x", ep->data[i]);\r\n}\r\np->cnt += snprintf(p->pbuf + p->cnt, p->limit - p->cnt,\r\n"\n");\r\n} else {\r\np->cnt += snprintf(p->pbuf + p->cnt, p->limit - p->cnt,\r\n" %c\n", ep->data_flag);\r\n}\r\n} else {\r\np->cnt += snprintf(p->pbuf + p->cnt, p->limit - p->cnt, "\n");\r\n}\r\n}\r\nstatic int mon_text_release(struct inode *inode, struct file *file)\r\n{\r\nstruct mon_reader_text *rp = file->private_data;\r\nstruct mon_bus *mbus;\r\nstruct list_head *p;\r\nstruct mon_event_text *ep;\r\nmutex_lock(&mon_lock);\r\nmbus = inode->i_private;\r\nif (mbus->nreaders <= 0) {\r\nprintk(KERN_ERR TAG ": consistency error on close\n");\r\nmutex_unlock(&mon_lock);\r\nreturn 0;\r\n}\r\nmon_reader_del(mbus, &rp->r);\r\nwhile (!list_empty(&rp->e_list)) {\r\np = rp->e_list.next;\r\nep = list_entry(p, struct mon_event_text, e_link);\r\nlist_del(p);\r\n--rp->nevents;\r\nkmem_cache_free(rp->e_slab, ep);\r\n}\r\nkmem_cache_destroy(rp->e_slab);\r\nkfree(rp->printf_buf);\r\nkfree(rp);\r\nmutex_unlock(&mon_lock);\r\nreturn 0;\r\n}\r\nint mon_text_add(struct mon_bus *mbus, const struct usb_bus *ubus)\r\n{\r\nstruct dentry *d;\r\nenum { NAMESZ = 10 };\r\nchar name[NAMESZ];\r\nint busnum = ubus? ubus->busnum: 0;\r\nint rc;\r\nif (mon_dir == NULL)\r\nreturn 0;\r\nif (ubus != NULL) {\r\nrc = snprintf(name, NAMESZ, "%dt", busnum);\r\nif (rc <= 0 || rc >= NAMESZ)\r\ngoto err_print_t;\r\nd = debugfs_create_file(name, 0600, mon_dir, mbus,\r\n&mon_fops_text_t);\r\nif (d == NULL)\r\ngoto err_create_t;\r\nmbus->dent_t = d;\r\n}\r\nrc = snprintf(name, NAMESZ, "%du", busnum);\r\nif (rc <= 0 || rc >= NAMESZ)\r\ngoto err_print_u;\r\nd = debugfs_create_file(name, 0600, mon_dir, mbus, &mon_fops_text_u);\r\nif (d == NULL)\r\ngoto err_create_u;\r\nmbus->dent_u = d;\r\nrc = snprintf(name, NAMESZ, "%ds", busnum);\r\nif (rc <= 0 || rc >= NAMESZ)\r\ngoto err_print_s;\r\nd = debugfs_create_file(name, 0600, mon_dir, mbus, &mon_fops_stat);\r\nif (d == NULL)\r\ngoto err_create_s;\r\nmbus->dent_s = d;\r\nreturn 1;\r\nerr_create_s:\r\nerr_print_s:\r\ndebugfs_remove(mbus->dent_u);\r\nmbus->dent_u = NULL;\r\nerr_create_u:\r\nerr_print_u:\r\nif (ubus != NULL) {\r\ndebugfs_remove(mbus->dent_t);\r\nmbus->dent_t = NULL;\r\n}\r\nerr_create_t:\r\nerr_print_t:\r\nreturn 0;\r\n}\r\nvoid mon_text_del(struct mon_bus *mbus)\r\n{\r\ndebugfs_remove(mbus->dent_u);\r\nif (mbus->dent_t != NULL)\r\ndebugfs_remove(mbus->dent_t);\r\ndebugfs_remove(mbus->dent_s);\r\n}\r\nstatic void mon_text_ctor(void *mem)\r\n{\r\nmemset(mem, 0xe5, sizeof(struct mon_event_text));\r\n}\r\nint __init mon_text_init(void)\r\n{\r\nstruct dentry *mondir;\r\nmondir = debugfs_create_dir("usbmon", usb_debug_root);\r\nif (IS_ERR(mondir)) {\r\nreturn 0;\r\n}\r\nif (mondir == NULL) {\r\nprintk(KERN_NOTICE TAG ": unable to create usbmon directory\n");\r\nreturn -ENOMEM;\r\n}\r\nmon_dir = mondir;\r\nreturn 0;\r\n}\r\nvoid mon_text_exit(void)\r\n{\r\ndebugfs_remove(mon_dir);\r\n}
