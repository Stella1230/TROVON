static inline void pvr2fb_set_pal_type(unsigned int type)\r\n{\r\nstruct pvr2fb_par *par = (struct pvr2fb_par *)fb_info->par;\r\nfb_writel(type, par->mmio_base + 0x108);\r\n}\r\nstatic inline void pvr2fb_set_pal_entry(struct pvr2fb_par *par,\r\nunsigned int regno,\r\nunsigned int val)\r\n{\r\nfb_writel(val, par->mmio_base + 0x1000 + (4 * regno));\r\n}\r\nstatic int pvr2fb_blank(int blank, struct fb_info *info)\r\n{\r\ndo_blank = blank ? blank : -1;\r\nreturn 0;\r\n}\r\nstatic inline unsigned long get_line_length(int xres_virtual, int bpp)\r\n{\r\nreturn (unsigned long)((((xres_virtual*bpp)+31)&~31) >> 3);\r\n}\r\nstatic void set_color_bitfields(struct fb_var_screeninfo *var)\r\n{\r\nswitch (var->bits_per_pixel) {\r\ncase 16:\r\npvr2fb_set_pal_type(PAL_RGB565);\r\nvar->red.offset = 11; var->red.length = 5;\r\nvar->green.offset = 5; var->green.length = 6;\r\nvar->blue.offset = 0; var->blue.length = 5;\r\nvar->transp.offset = 0; var->transp.length = 0;\r\nbreak;\r\ncase 24:\r\nvar->red.offset = 16; var->red.length = 8;\r\nvar->green.offset = 8; var->green.length = 8;\r\nvar->blue.offset = 0; var->blue.length = 8;\r\nvar->transp.offset = 0; var->transp.length = 0;\r\nbreak;\r\ncase 32:\r\npvr2fb_set_pal_type(PAL_ARGB8888);\r\nvar->red.offset = 16; var->red.length = 8;\r\nvar->green.offset = 8; var->green.length = 8;\r\nvar->blue.offset = 0; var->blue.length = 8;\r\nvar->transp.offset = 24; var->transp.length = 8;\r\nbreak;\r\n}\r\n}\r\nstatic int pvr2fb_setcolreg(unsigned int regno, unsigned int red,\r\nunsigned int green, unsigned int blue,\r\nunsigned int transp, struct fb_info *info)\r\n{\r\nstruct pvr2fb_par *par = (struct pvr2fb_par *)info->par;\r\nunsigned int tmp;\r\nif (regno > info->cmap.len)\r\nreturn 1;\r\nswitch (info->var.bits_per_pixel) {\r\ncase 16:\r\ntmp = (red & 0xf800) |\r\n((green & 0xfc00) >> 5) |\r\n((blue & 0xf800) >> 11);\r\npvr2fb_set_pal_entry(par, regno, tmp);\r\nbreak;\r\ncase 24:\r\nred >>= 8; green >>= 8; blue >>= 8;\r\ntmp = (red << 16) | (green << 8) | blue;\r\nbreak;\r\ncase 32:\r\nred >>= 8; green >>= 8; blue >>= 8;\r\ntmp = (transp << 24) | (red << 16) | (green << 8) | blue;\r\npvr2fb_set_pal_entry(par, regno, tmp);\r\nbreak;\r\ndefault:\r\npr_debug("Invalid bit depth %d?!?\n", info->var.bits_per_pixel);\r\nreturn 1;\r\n}\r\nif (regno < 16)\r\n((u32*)(info->pseudo_palette))[regno] = tmp;\r\nreturn 0;\r\n}\r\nstatic int pvr2fb_set_par(struct fb_info *info)\r\n{\r\nstruct pvr2fb_par *par = (struct pvr2fb_par *)info->par;\r\nstruct fb_var_screeninfo *var = &info->var;\r\nunsigned long line_length;\r\nunsigned int vtotal;\r\ncable_type = pvr2_init_cable();\r\nif (cable_type == CT_VGA && video_output != VO_VGA)\r\nvideo_output = VO_VGA;\r\nvar->vmode &= FB_VMODE_MASK;\r\nif (var->vmode & FB_VMODE_INTERLACED && video_output != VO_VGA)\r\npar->is_interlaced = 1;\r\nif (var->vmode & FB_VMODE_DOUBLE && video_output == VO_VGA)\r\npar->is_doublescan = 1;\r\npar->hsync_total = var->left_margin + var->xres + var->right_margin +\r\nvar->hsync_len;\r\npar->vsync_total = var->upper_margin + var->yres + var->lower_margin +\r\nvar->vsync_len;\r\nif (var->sync & FB_SYNC_BROADCAST) {\r\nvtotal = par->vsync_total;\r\nif (par->is_interlaced)\r\nvtotal /= 2;\r\nif (vtotal > (PAL_VTOTAL + NTSC_VTOTAL)/2) {\r\npar->borderstart_h = 116;\r\npar->borderstart_v = 44;\r\n} else {\r\npar->borderstart_h = 126;\r\npar->borderstart_v = 18;\r\n}\r\n} else {\r\npar->borderstart_h = 126;\r\npar->borderstart_v = 40;\r\n}\r\npar->diwstart_h = par->borderstart_h + var->left_margin;\r\npar->diwstart_v = par->borderstart_v + var->upper_margin;\r\npar->borderstop_h = par->diwstart_h + var->xres +\r\nvar->right_margin;\r\npar->borderstop_v = par->diwstart_v + var->yres +\r\nvar->lower_margin;\r\nif (!par->is_interlaced)\r\npar->borderstop_v /= 2;\r\nif (info->var.xres < 640)\r\npar->is_lowres = 1;\r\nline_length = get_line_length(var->xres_virtual, var->bits_per_pixel);\r\npar->disp_start = info->fix.smem_start + (line_length * var->yoffset) * line_length;\r\ninfo->fix.line_length = line_length;\r\nreturn 0;\r\n}\r\nstatic int pvr2fb_check_var(struct fb_var_screeninfo *var, struct fb_info *info)\r\n{\r\nstruct pvr2fb_par *par = (struct pvr2fb_par *)info->par;\r\nunsigned int vtotal, hsync_total;\r\nunsigned long line_length;\r\nif (var->pixclock != TV_CLK && var->pixclock != VGA_CLK) {\r\npr_debug("Invalid pixclock value %d\n", var->pixclock);\r\nreturn -EINVAL;\r\n}\r\nif (var->xres < 320)\r\nvar->xres = 320;\r\nif (var->yres < 240)\r\nvar->yres = 240;\r\nif (var->xres_virtual < var->xres)\r\nvar->xres_virtual = var->xres;\r\nif (var->yres_virtual < var->yres)\r\nvar->yres_virtual = var->yres;\r\nif (var->bits_per_pixel <= 16)\r\nvar->bits_per_pixel = 16;\r\nelse if (var->bits_per_pixel <= 24)\r\nvar->bits_per_pixel = 24;\r\nelse if (var->bits_per_pixel <= 32)\r\nvar->bits_per_pixel = 32;\r\nset_color_bitfields(var);\r\nif (var->vmode & FB_VMODE_YWRAP) {\r\nif (var->xoffset || var->yoffset < 0 ||\r\nvar->yoffset >= var->yres_virtual) {\r\nvar->xoffset = var->yoffset = 0;\r\n} else {\r\nif (var->xoffset > var->xres_virtual - var->xres ||\r\nvar->yoffset > var->yres_virtual - var->yres ||\r\nvar->xoffset < 0 || var->yoffset < 0)\r\nvar->xoffset = var->yoffset = 0;\r\n}\r\n} else {\r\nvar->xoffset = var->yoffset = 0;\r\n}\r\nif (var->yres < 480 && video_output == VO_VGA)\r\nvar->vmode |= FB_VMODE_DOUBLE;\r\nif (video_output != VO_VGA) {\r\nvar->sync |= FB_SYNC_BROADCAST;\r\nvar->vmode |= FB_VMODE_INTERLACED;\r\n} else {\r\nvar->sync &= ~FB_SYNC_BROADCAST;\r\nvar->vmode &= ~FB_VMODE_INTERLACED;\r\nvar->vmode |= FB_VMODE_NONINTERLACED;\r\n}\r\nif ((var->activate & FB_ACTIVATE_MASK) != FB_ACTIVATE_TEST) {\r\nvar->right_margin = par->borderstop_h -\r\n(par->diwstart_h + var->xres);\r\nvar->left_margin = par->diwstart_h - par->borderstart_h;\r\nvar->hsync_len = par->borderstart_h +\r\n(par->hsync_total - par->borderstop_h);\r\nvar->upper_margin = par->diwstart_v - par->borderstart_v;\r\nvar->lower_margin = par->borderstop_v -\r\n(par->diwstart_v + var->yres);\r\nvar->vsync_len = par->borderstop_v +\r\n(par->vsync_total - par->borderstop_v);\r\n}\r\nhsync_total = var->left_margin + var->xres + var->right_margin +\r\nvar->hsync_len;\r\nvtotal = var->upper_margin + var->yres + var->lower_margin +\r\nvar->vsync_len;\r\nif (var->sync & FB_SYNC_BROADCAST) {\r\nif (var->vmode & FB_VMODE_INTERLACED)\r\nvtotal /= 2;\r\nif (vtotal > (PAL_VTOTAL + NTSC_VTOTAL)/2) {\r\nif (hsync_total != PAL_HTOTAL) {\r\npr_debug("invalid hsync total for PAL\n");\r\nreturn -EINVAL;\r\n}\r\n} else {\r\nif (hsync_total != NTSC_HTOTAL) {\r\npr_debug("invalid hsync total for NTSC\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\n}\r\nline_length = get_line_length(var->xres_virtual, var->bits_per_pixel);\r\nif (line_length * var->yres_virtual > info->fix.smem_len)\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nstatic void pvr2_update_display(struct fb_info *info)\r\n{\r\nstruct pvr2fb_par *par = (struct pvr2fb_par *) info->par;\r\nstruct fb_var_screeninfo *var = &info->var;\r\nfb_writel(par->disp_start, DISP_DIWADDRL);\r\nfb_writel(par->disp_start +\r\nget_line_length(var->xoffset+var->xres, var->bits_per_pixel),\r\nDISP_DIWADDRS);\r\n}\r\nstatic void pvr2_init_display(struct fb_info *info)\r\n{\r\nstruct pvr2fb_par *par = (struct pvr2fb_par *) info->par;\r\nstruct fb_var_screeninfo *var = &info->var;\r\nunsigned int diw_height, diw_width, diw_modulo = 1;\r\nunsigned int bytesperpixel = var->bits_per_pixel >> 3;\r\nfb_writel((par->vsync_total << 16) | par->hsync_total, DISP_SYNCSIZE);\r\nif (video_output != VO_VGA && par->is_interlaced)\r\ndiw_modulo += info->fix.line_length / 4;\r\ndiw_height = (par->is_interlaced ? var->yres / 2 : var->yres);\r\ndiw_width = get_line_length(var->xres, var->bits_per_pixel) / 4;\r\nfb_writel((diw_modulo << 20) | (--diw_height << 10) | --diw_width,\r\nDISP_DIWSIZE);\r\nfb_writel(par->disp_start, DISP_DIWADDRL);\r\nfb_writel(par->disp_start +\r\nget_line_length(var->xoffset+var->xres, var->bits_per_pixel),\r\nDISP_DIWADDRS);\r\nfb_writel((par->borderstart_h << 16) | par->borderstop_h, DISP_BRDRHORZ);\r\nfb_writel((par->borderstart_v << 16) | par->borderstop_v, DISP_BRDRVERT);\r\nfb_writel(0, DISP_BRDRCOLR);\r\nfb_writel(par->diwstart_h, DISP_DIWHSTRT);\r\nfb_writel((par->diwstart_v << 16) | par->diwstart_v, DISP_DIWVSTRT);\r\nfb_writel((0x16 << 16) | par->is_lowres, DISP_DIWCONF);\r\nfb_writel(((video_output == VO_VGA) << 23) |\r\n(par->is_doublescan << 1) | 1, DISP_DIWMODE);\r\nfb_writel(fb_readl(DISP_DIWMODE) | (--bytesperpixel << 2), DISP_DIWMODE);\r\nfb_writel(bytesperpixel << 2, DISP_PIXDEPTH);\r\nfb_writel(0x100 | ((par->is_interlaced ) << 4), DISP_SYNCCONF);\r\n}\r\nstatic void pvr2_do_blank(void)\r\n{\r\nstruct pvr2fb_par *par = currentpar;\r\nunsigned long diwconf;\r\ndiwconf = fb_readl(DISP_DIWCONF);\r\nif (do_blank > 0)\r\nfb_writel(diwconf | BLANK_BIT, DISP_DIWCONF);\r\nelse\r\nfb_writel(diwconf & ~BLANK_BIT, DISP_DIWCONF);\r\nis_blanked = do_blank > 0 ? do_blank : 0;\r\n}\r\nstatic irqreturn_t pvr2fb_interrupt(int irq, void *dev_id)\r\n{\r\nstruct fb_info *info = dev_id;\r\nif (do_vmode_pan || do_vmode_full)\r\npvr2_update_display(info);\r\nif (do_vmode_full)\r\npvr2_init_display(info);\r\nif (do_vmode_pan)\r\ndo_vmode_pan = 0;\r\nif (do_vmode_full)\r\ndo_vmode_full = 0;\r\nif (do_blank) {\r\npvr2_do_blank();\r\ndo_blank = 0;\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int pvr2_init_cable(void)\r\n{\r\nif (cable_type < 0) {\r\nfb_writel((fb_readl(PCTRA) & 0xfff0ffff) | 0x000a0000,\r\nPCTRA);\r\ncable_type = (fb_readw(PDTRA) >> 8) & 3;\r\n}\r\nif (cable_type == CT_COMPOSITE)\r\nfb_writel(3 << 8, VOUTC);\r\nelse if (cable_type == CT_RGB)\r\nfb_writel(1 << 9, VOUTC);\r\nelse\r\nfb_writel(0, VOUTC);\r\nreturn cable_type;\r\n}\r\nstatic ssize_t pvr2fb_write(struct fb_info *info, const char *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nunsigned long dst, start, end, len;\r\nunsigned int nr_pages;\r\nstruct page **pages;\r\nint ret, i;\r\nnr_pages = (count + PAGE_SIZE - 1) >> PAGE_SHIFT;\r\npages = kmalloc(nr_pages * sizeof(struct page *), GFP_KERNEL);\r\nif (!pages)\r\nreturn -ENOMEM;\r\ndown_read(&current->mm->mmap_sem);\r\nret = get_user_pages(current, current->mm, (unsigned long)buf,\r\nnr_pages, WRITE, 0, pages, NULL);\r\nup_read(&current->mm->mmap_sem);\r\nif (ret < nr_pages) {\r\nnr_pages = ret;\r\nret = -EINVAL;\r\ngoto out_unmap;\r\n}\r\ndma_configure_channel(shdma, 0x12c1);\r\ndst = (unsigned long)fb_info->screen_base + *ppos;\r\nstart = (unsigned long)page_address(pages[0]);\r\nend = (unsigned long)page_address(pages[nr_pages]);\r\nlen = nr_pages << PAGE_SHIFT;\r\nif (start + len == end) {\r\nif ((*ppos + len) > fb_info->fix.smem_len) {\r\nret = -ENOSPC;\r\ngoto out_unmap;\r\n}\r\ndma_write(shdma, start, 0, len);\r\ndma_write(pvr2dma, 0, dst, len);\r\ndma_wait_for_completion(pvr2dma);\r\ngoto out;\r\n}\r\nfor (i = 0; i < nr_pages; i++, dst += PAGE_SIZE) {\r\nif ((*ppos + (i << PAGE_SHIFT)) > fb_info->fix.smem_len) {\r\nret = -ENOSPC;\r\ngoto out_unmap;\r\n}\r\ndma_write_page(shdma, (unsigned long)page_address(pages[i]), 0);\r\ndma_write_page(pvr2dma, 0, dst);\r\ndma_wait_for_completion(pvr2dma);\r\n}\r\nout:\r\n*ppos += count;\r\nret = count;\r\nout_unmap:\r\nfor (i = 0; i < nr_pages; i++)\r\npage_cache_release(pages[i]);\r\nkfree(pages);\r\nreturn ret;\r\n}\r\nstatic int pvr2fb_common_init(void)\r\n{\r\nstruct pvr2fb_par *par = currentpar;\r\nunsigned long modememused, rev;\r\nfb_info->screen_base = ioremap_nocache(pvr2_fix.smem_start,\r\npvr2_fix.smem_len);\r\nif (!fb_info->screen_base) {\r\nprintk(KERN_ERR "pvr2fb: Failed to remap smem space\n");\r\ngoto out_err;\r\n}\r\npar->mmio_base = (unsigned long)ioremap_nocache(pvr2_fix.mmio_start,\r\npvr2_fix.mmio_len);\r\nif (!par->mmio_base) {\r\nprintk(KERN_ERR "pvr2fb: Failed to remap mmio space\n");\r\ngoto out_err;\r\n}\r\nfb_memset(fb_info->screen_base, 0, pvr2_fix.smem_len);\r\npvr2_fix.ypanstep = nopan ? 0 : 1;\r\npvr2_fix.ywrapstep = nowrap ? 0 : 1;\r\nfb_info->fbops = &pvr2fb_ops;\r\nfb_info->fix = pvr2_fix;\r\nfb_info->par = currentpar;\r\nfb_info->pseudo_palette = currentpar->palette;\r\nfb_info->flags = FBINFO_DEFAULT | FBINFO_HWACCEL_YPAN;\r\nif (video_output == VO_VGA)\r\ndefmode = DEFMODE_VGA;\r\nif (!mode_option)\r\nmode_option = "640x480@60";\r\nif (!fb_find_mode(&fb_info->var, fb_info, mode_option, pvr2_modedb,\r\nNUM_TOTAL_MODES, &pvr2_modedb[defmode], 16))\r\nfb_info->var = pvr2_var;\r\nfb_alloc_cmap(&fb_info->cmap, 256, 0);\r\nif (register_framebuffer(fb_info) < 0)\r\ngoto out_err;\r\npvr2_init_display(fb_info);\r\nmodememused = get_line_length(fb_info->var.xres_virtual,\r\nfb_info->var.bits_per_pixel);\r\nmodememused *= fb_info->var.yres_virtual;\r\nrev = fb_readl(par->mmio_base + 0x04);\r\nprintk("fb%d: %s (rev %ld.%ld) frame buffer device, using %ldk/%ldk of video memory\n",\r\nfb_info->node, fb_info->fix.id, (rev >> 4) & 0x0f, rev & 0x0f,\r\nmodememused >> 10, (unsigned long)(fb_info->fix.smem_len >> 10));\r\nprintk("fb%d: Mode %dx%d-%d pitch = %ld cable: %s video output: %s\n",\r\nfb_info->node, fb_info->var.xres, fb_info->var.yres,\r\nfb_info->var.bits_per_pixel,\r\nget_line_length(fb_info->var.xres, fb_info->var.bits_per_pixel),\r\n(char *)pvr2_get_param(cables, NULL, cable_type, 3),\r\n(char *)pvr2_get_param(outputs, NULL, video_output, 3));\r\n#ifdef CONFIG_SH_STORE_QUEUES\r\nprintk(KERN_NOTICE "fb%d: registering with SQ API\n", fb_info->node);\r\npvr2fb_map = sq_remap(fb_info->fix.smem_start, fb_info->fix.smem_len,\r\nfb_info->fix.id, PAGE_SHARED);\r\nprintk(KERN_NOTICE "fb%d: Mapped video memory to SQ addr 0x%lx\n",\r\nfb_info->node, pvr2fb_map);\r\n#endif\r\nreturn 0;\r\nout_err:\r\nif (fb_info->screen_base)\r\niounmap(fb_info->screen_base);\r\nif (par->mmio_base)\r\niounmap((void *)par->mmio_base);\r\nreturn -ENXIO;\r\n}\r\nstatic int __init pvr2fb_dc_init(void)\r\n{\r\nif (!mach_is_dreamcast())\r\nreturn -ENXIO;\r\nif (pvr2_init_cable() == CT_VGA) {\r\nfb_info->monspecs.hfmin = 30000;\r\nfb_info->monspecs.hfmax = 70000;\r\nfb_info->monspecs.vfmin = 60;\r\nfb_info->monspecs.vfmax = 60;\r\n} else {\r\nfb_info->monspecs.hfmin = 15469;\r\nfb_info->monspecs.hfmax = 15781;\r\nfb_info->monspecs.vfmin = 49;\r\nfb_info->monspecs.vfmax = 51;\r\n}\r\nif (video_output < 0) {\r\nif (cable_type == CT_VGA) {\r\nvideo_output = VO_VGA;\r\n} else {\r\nvideo_output = VO_NTSC;\r\n}\r\n}\r\npvr2_fix.smem_start = 0xa5000000;\r\npvr2_fix.smem_len = 8 << 20;\r\npvr2_fix.mmio_start = 0xa05f8000;\r\npvr2_fix.mmio_len = 0x2000;\r\nif (request_irq(HW_EVENT_VSYNC, pvr2fb_interrupt, IRQF_SHARED,\r\n"pvr2 VBL handler", fb_info)) {\r\nreturn -EBUSY;\r\n}\r\n#ifdef CONFIG_PVR2_DMA\r\nif (request_dma(pvr2dma, "pvr2") != 0) {\r\nfree_irq(HW_EVENT_VSYNC, fb_info);\r\nreturn -EBUSY;\r\n}\r\n#endif\r\nreturn pvr2fb_common_init();\r\n}\r\nstatic void __exit pvr2fb_dc_exit(void)\r\n{\r\nif (fb_info->screen_base) {\r\niounmap(fb_info->screen_base);\r\nfb_info->screen_base = NULL;\r\n}\r\nif (currentpar->mmio_base) {\r\niounmap((void *)currentpar->mmio_base);\r\ncurrentpar->mmio_base = 0;\r\n}\r\nfree_irq(HW_EVENT_VSYNC, fb_info);\r\n#ifdef CONFIG_PVR2_DMA\r\nfree_dma(pvr2dma);\r\n#endif\r\n}\r\nstatic int pvr2fb_pci_probe(struct pci_dev *pdev,\r\nconst struct pci_device_id *ent)\r\n{\r\nint ret;\r\nret = pci_enable_device(pdev);\r\nif (ret) {\r\nprintk(KERN_ERR "pvr2fb: PCI enable failed\n");\r\nreturn ret;\r\n}\r\nret = pci_request_regions(pdev, "pvr2fb");\r\nif (ret) {\r\nprintk(KERN_ERR "pvr2fb: PCI request regions failed\n");\r\nreturn ret;\r\n}\r\npvr2_fix.smem_start = pci_resource_start(pdev, 0);\r\npvr2_fix.smem_len = pci_resource_len(pdev, 0);\r\npvr2_fix.mmio_start = pci_resource_start(pdev, 1);\r\npvr2_fix.mmio_len = pci_resource_len(pdev, 1);\r\nfb_info->device = &pdev->dev;\r\nreturn pvr2fb_common_init();\r\n}\r\nstatic void pvr2fb_pci_remove(struct pci_dev *pdev)\r\n{\r\nif (fb_info->screen_base) {\r\niounmap(fb_info->screen_base);\r\nfb_info->screen_base = NULL;\r\n}\r\nif (currentpar->mmio_base) {\r\niounmap((void *)currentpar->mmio_base);\r\ncurrentpar->mmio_base = 0;\r\n}\r\npci_release_regions(pdev);\r\n}\r\nstatic int __init pvr2fb_pci_init(void)\r\n{\r\nreturn pci_register_driver(&pvr2fb_pci_driver);\r\n}\r\nstatic void __exit pvr2fb_pci_exit(void)\r\n{\r\npci_unregister_driver(&pvr2fb_pci_driver);\r\n}\r\nstatic int pvr2_get_param(const struct pvr2_params *p, const char *s, int val,\r\nint size)\r\n{\r\nint i;\r\nfor (i = 0 ; i < size ; i++ ) {\r\nif (s != NULL) {\r\nif (!strnicmp(p[i].name, s, strlen(s)))\r\nreturn p[i].val;\r\n} else {\r\nif (p[i].val == val)\r\nreturn (int)p[i].name;\r\n}\r\n}\r\nreturn -1;\r\n}\r\nstatic int __init pvr2fb_setup(char *options)\r\n{\r\nchar *this_opt;\r\nchar cable_arg[80];\r\nchar output_arg[80];\r\nif (!options || !*options)\r\nreturn 0;\r\nwhile ((this_opt = strsep(&options, ","))) {\r\nif (!*this_opt)\r\ncontinue;\r\nif (!strcmp(this_opt, "inverse")) {\r\nfb_invert_cmaps();\r\n} else if (!strncmp(this_opt, "cable:", 6)) {\r\nstrcpy(cable_arg, this_opt + 6);\r\n} else if (!strncmp(this_opt, "output:", 7)) {\r\nstrcpy(output_arg, this_opt + 7);\r\n} else if (!strncmp(this_opt, "nopan", 5)) {\r\nnopan = 1;\r\n} else if (!strncmp(this_opt, "nowrap", 6)) {\r\nnowrap = 1;\r\n} else {\r\nmode_option = this_opt;\r\n}\r\n}\r\nif (*cable_arg)\r\ncable_type = pvr2_get_param(cables, cable_arg, 0, 3);\r\nif (*output_arg)\r\nvideo_output = pvr2_get_param(outputs, output_arg, 0, 3);\r\nreturn 0;\r\n}\r\nstatic int __init pvr2fb_init(void)\r\n{\r\nint i, ret = -ENODEV;\r\nint size;\r\n#ifndef MODULE\r\nchar *option = NULL;\r\nif (fb_get_options("pvr2fb", &option))\r\nreturn -ENODEV;\r\npvr2fb_setup(option);\r\n#endif\r\nsize = sizeof(struct fb_info) + sizeof(struct pvr2fb_par) + 16 * sizeof(u32);\r\nfb_info = framebuffer_alloc(sizeof(struct pvr2fb_par), NULL);\r\nif (!fb_info) {\r\nprintk(KERN_ERR "Failed to allocate memory for fb_info\n");\r\nreturn -ENOMEM;\r\n}\r\ncurrentpar = fb_info->par;\r\nfor (i = 0; i < ARRAY_SIZE(board_driver); i++) {\r\nstruct pvr2_board *pvr_board = board_driver + i;\r\nif (!pvr_board->init)\r\ncontinue;\r\nret = pvr_board->init();\r\nif (ret != 0) {\r\nprintk(KERN_ERR "pvr2fb: Failed init of %s device\n",\r\npvr_board->name);\r\nframebuffer_release(fb_info);\r\nbreak;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic void __exit pvr2fb_exit(void)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(board_driver); i++) {\r\nstruct pvr2_board *pvr_board = board_driver + i;\r\nif (pvr_board->exit)\r\npvr_board->exit();\r\n}\r\n#ifdef CONFIG_SH_STORE_QUEUES\r\nsq_unmap(pvr2fb_map);\r\n#endif\r\nunregister_framebuffer(fb_info);\r\nframebuffer_release(fb_info);\r\n}
