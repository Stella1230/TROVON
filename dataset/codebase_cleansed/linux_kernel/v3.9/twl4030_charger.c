static int twl4030_clear_set(u8 mod_no, u8 clear, u8 set, u8 reg)\r\n{\r\nu8 val = 0;\r\nint ret;\r\nret = twl_i2c_read_u8(mod_no, &val, reg);\r\nif (ret)\r\nreturn ret;\r\nval &= ~clear;\r\nval |= set;\r\nreturn twl_i2c_write_u8(mod_no, val, reg);\r\n}\r\nstatic int twl4030_bci_read(u8 reg, u8 *val)\r\n{\r\nreturn twl_i2c_read_u8(TWL_MODULE_MAIN_CHARGE, val, reg);\r\n}\r\nstatic int twl4030_clear_set_boot_bci(u8 clear, u8 set)\r\n{\r\nreturn twl4030_clear_set(TWL_MODULE_PM_MASTER, clear,\r\nTWL4030_CONFIG_DONE | TWL4030_BCIAUTOWEN | set,\r\nTWL4030_PM_MASTER_BOOT_BCI);\r\n}\r\nstatic int twl4030bci_read_adc_val(u8 reg)\r\n{\r\nint ret, temp;\r\nu8 val;\r\nret = twl4030_bci_read(reg + 1, &val);\r\nif (ret)\r\nreturn ret;\r\ntemp = (int)(val & 0x03) << 8;\r\nret = twl4030_bci_read(reg, &val);\r\nif (ret)\r\nreturn ret;\r\nreturn temp | val;\r\n}\r\nstatic int twl4030_bci_have_vbus(struct twl4030_bci *bci)\r\n{\r\nint ret;\r\nu8 hwsts;\r\nret = twl_i2c_read_u8(TWL_MODULE_PM_MASTER, &hwsts,\r\nTWL4030_PM_MASTER_STS_HW_CONDITIONS);\r\nif (ret < 0)\r\nreturn 0;\r\ndev_dbg(bci->dev, "check_vbus: HW_CONDITIONS %02x\n", hwsts);\r\nif ((hwsts & TWL4030_STS_VBUS) && !(hwsts & TWL4030_STS_USB_ID))\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic int twl4030_charger_enable_usb(struct twl4030_bci *bci, bool enable)\r\n{\r\nint ret;\r\nif (enable) {\r\nif (!twl4030_bci_have_vbus(bci))\r\nreturn -ENODEV;\r\nif (!allow_usb) {\r\ndev_warn(bci->dev, "USB charging is disabled.\n");\r\nreturn -EACCES;\r\n}\r\nif (!bci->usb_enabled) {\r\nregulator_enable(bci->usb_reg);\r\nbci->usb_enabled = 1;\r\n}\r\nret = twl4030_clear_set_boot_bci(0, TWL4030_BCIAUTOUSB);\r\nif (ret < 0)\r\nreturn ret;\r\nret = twl4030_clear_set(TWL_MODULE_MAIN_CHARGE, 0,\r\nTWL4030_USBFASTMCHG, TWL4030_BCIMFSTS4);\r\n} else {\r\nret = twl4030_clear_set_boot_bci(TWL4030_BCIAUTOUSB, 0);\r\nif (bci->usb_enabled) {\r\nregulator_disable(bci->usb_reg);\r\nbci->usb_enabled = 0;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic int twl4030_charger_enable_ac(bool enable)\r\n{\r\nint ret;\r\nif (enable)\r\nret = twl4030_clear_set_boot_bci(0, TWL4030_BCIAUTOAC);\r\nelse\r\nret = twl4030_clear_set_boot_bci(TWL4030_BCIAUTOAC, 0);\r\nreturn ret;\r\n}\r\nstatic int twl4030_charger_enable_backup(int uvolt, int uamp)\r\n{\r\nint ret;\r\nu8 flags;\r\nif (uvolt < 2500000 ||\r\nuamp < 25) {\r\nret = twl4030_clear_set(TWL_MODULE_PM_RECEIVER,\r\nTWL4030_BBCHEN, 0, TWL4030_BB_CFG);\r\nreturn ret;\r\n}\r\nflags = TWL4030_BBCHEN;\r\nif (uvolt >= 3200000)\r\nflags |= TWL4030_BBSEL_3V2;\r\nelse if (uvolt >= 3100000)\r\nflags |= TWL4030_BBSEL_3V1;\r\nelse if (uvolt >= 3000000)\r\nflags |= TWL4030_BBSEL_3V0;\r\nelse\r\nflags |= TWL4030_BBSEL_2V5;\r\nif (uamp >= 1000)\r\nflags |= TWL4030_BBISEL_1000uA;\r\nelse if (uamp >= 500)\r\nflags |= TWL4030_BBISEL_500uA;\r\nelse if (uamp >= 150)\r\nflags |= TWL4030_BBISEL_150uA;\r\nelse\r\nflags |= TWL4030_BBISEL_25uA;\r\nret = twl4030_clear_set(TWL_MODULE_PM_RECEIVER,\r\nTWL4030_BBSEL_MASK | TWL4030_BBISEL_MASK,\r\nflags,\r\nTWL4030_BB_CFG);\r\nreturn ret;\r\n}\r\nstatic irqreturn_t twl4030_charger_interrupt(int irq, void *arg)\r\n{\r\nstruct twl4030_bci *bci = arg;\r\ndev_dbg(bci->dev, "CHG_PRES irq\n");\r\npower_supply_changed(&bci->ac);\r\npower_supply_changed(&bci->usb);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t twl4030_bci_interrupt(int irq, void *arg)\r\n{\r\nstruct twl4030_bci *bci = arg;\r\nu8 irqs1, irqs2;\r\nint ret;\r\nret = twl_i2c_read_u8(TWL4030_MODULE_INTERRUPTS, &irqs1,\r\nTWL4030_INTERRUPTS_BCIISR1A);\r\nif (ret < 0)\r\nreturn IRQ_HANDLED;\r\nret = twl_i2c_read_u8(TWL4030_MODULE_INTERRUPTS, &irqs2,\r\nTWL4030_INTERRUPTS_BCIISR2A);\r\nif (ret < 0)\r\nreturn IRQ_HANDLED;\r\ndev_dbg(bci->dev, "BCI irq %02x %02x\n", irqs2, irqs1);\r\nif (irqs1 & (TWL4030_ICHGLOW | TWL4030_ICHGEOC)) {\r\npower_supply_changed(&bci->ac);\r\npower_supply_changed(&bci->usb);\r\n}\r\nif (irqs1 & (TWL4030_TBATOR2 | TWL4030_TBATOR1))\r\ndev_warn(bci->dev, "battery temperature out of range\n");\r\nif (irqs1 & TWL4030_BATSTS)\r\ndev_crit(bci->dev, "battery disconnected\n");\r\nif (irqs2 & TWL4030_VBATOV)\r\ndev_crit(bci->dev, "VBAT overvoltage\n");\r\nif (irqs2 & TWL4030_VBUSOV)\r\ndev_crit(bci->dev, "VBUS overvoltage\n");\r\nif (irqs2 & TWL4030_ACCHGOV)\r\ndev_crit(bci->dev, "Ac charger overvoltage\n");\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void twl4030_bci_usb_work(struct work_struct *data)\r\n{\r\nstruct twl4030_bci *bci = container_of(data, struct twl4030_bci, work);\r\nswitch (bci->event) {\r\ncase USB_EVENT_VBUS:\r\ncase USB_EVENT_CHARGER:\r\ntwl4030_charger_enable_usb(bci, true);\r\nbreak;\r\ncase USB_EVENT_NONE:\r\ntwl4030_charger_enable_usb(bci, false);\r\nbreak;\r\n}\r\n}\r\nstatic int twl4030_bci_usb_ncb(struct notifier_block *nb, unsigned long val,\r\nvoid *priv)\r\n{\r\nstruct twl4030_bci *bci = container_of(nb, struct twl4030_bci, usb_nb);\r\ndev_dbg(bci->dev, "OTG notify %lu\n", val);\r\nbci->event = val;\r\nschedule_work(&bci->work);\r\nreturn NOTIFY_OK;\r\n}\r\nstatic int twl4030_charger_get_current(void)\r\n{\r\nint curr;\r\nint ret;\r\nu8 bcictl1;\r\ncurr = twl4030bci_read_adc_val(TWL4030_BCIICHG);\r\nif (curr < 0)\r\nreturn curr;\r\nret = twl4030_bci_read(TWL4030_BCICTL1, &bcictl1);\r\nif (ret)\r\nreturn ret;\r\nret = (curr * 16618 - 850 * 10000) / 10;\r\nif (bcictl1 & TWL4030_CGAIN)\r\nret *= 2;\r\nreturn ret;\r\n}\r\nstatic int twl4030bci_state(struct twl4030_bci *bci)\r\n{\r\nint ret;\r\nu8 state;\r\nret = twl4030_bci_read(TWL4030_BCIMSTATEC, &state);\r\nif (ret) {\r\npr_err("twl4030_bci: error reading BCIMSTATEC\n");\r\nreturn ret;\r\n}\r\ndev_dbg(bci->dev, "state: %02x\n", state);\r\nreturn state;\r\n}\r\nstatic int twl4030_bci_state_to_status(int state)\r\n{\r\nstate &= TWL4030_MSTATEC_MASK;\r\nif (TWL4030_MSTATEC_QUICK1 <= state && state <= TWL4030_MSTATEC_QUICK7)\r\nreturn POWER_SUPPLY_STATUS_CHARGING;\r\nelse if (TWL4030_MSTATEC_COMPLETE1 <= state &&\r\nstate <= TWL4030_MSTATEC_COMPLETE4)\r\nreturn POWER_SUPPLY_STATUS_FULL;\r\nelse\r\nreturn POWER_SUPPLY_STATUS_NOT_CHARGING;\r\n}\r\nstatic int twl4030_bci_get_property(struct power_supply *psy,\r\nenum power_supply_property psp,\r\nunion power_supply_propval *val)\r\n{\r\nstruct twl4030_bci *bci = dev_get_drvdata(psy->dev->parent);\r\nint is_charging;\r\nint state;\r\nint ret;\r\nstate = twl4030bci_state(bci);\r\nif (state < 0)\r\nreturn state;\r\nif (psy->type == POWER_SUPPLY_TYPE_USB)\r\nis_charging = state & TWL4030_MSTATEC_USB;\r\nelse\r\nis_charging = state & TWL4030_MSTATEC_AC;\r\nswitch (psp) {\r\ncase POWER_SUPPLY_PROP_STATUS:\r\nif (is_charging)\r\nval->intval = twl4030_bci_state_to_status(state);\r\nelse\r\nval->intval = POWER_SUPPLY_STATUS_NOT_CHARGING;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_VOLTAGE_NOW:\r\nif (!is_charging)\r\nreturn -ENODATA;\r\nif (psy->type == POWER_SUPPLY_TYPE_USB) {\r\nret = twl4030bci_read_adc_val(TWL4030_BCIVBUS);\r\nif (ret < 0)\r\nreturn ret;\r\nval->intval = ret * 6843;\r\n} else {\r\nret = twl4030bci_read_adc_val(TWL4030_BCIVAC);\r\nif (ret < 0)\r\nreturn ret;\r\nval->intval = ret * 9775;\r\n}\r\nbreak;\r\ncase POWER_SUPPLY_PROP_CURRENT_NOW:\r\nif (!is_charging)\r\nreturn -ENODATA;\r\nret = twl4030_charger_get_current();\r\nif (ret < 0)\r\nreturn ret;\r\nval->intval = ret;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_ONLINE:\r\nval->intval = is_charging &&\r\ntwl4030_bci_state_to_status(state) !=\r\nPOWER_SUPPLY_STATUS_NOT_CHARGING;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init twl4030_bci_probe(struct platform_device *pdev)\r\n{\r\nstruct twl4030_bci *bci;\r\nstruct twl4030_bci_platform_data *pdata = pdev->dev.platform_data;\r\nint ret;\r\nu32 reg;\r\nbci = kzalloc(sizeof(*bci), GFP_KERNEL);\r\nif (bci == NULL)\r\nreturn -ENOMEM;\r\nbci->dev = &pdev->dev;\r\nbci->irq_chg = platform_get_irq(pdev, 0);\r\nbci->irq_bci = platform_get_irq(pdev, 1);\r\nplatform_set_drvdata(pdev, bci);\r\nbci->ac.name = "twl4030_ac";\r\nbci->ac.type = POWER_SUPPLY_TYPE_MAINS;\r\nbci->ac.properties = twl4030_charger_props;\r\nbci->ac.num_properties = ARRAY_SIZE(twl4030_charger_props);\r\nbci->ac.get_property = twl4030_bci_get_property;\r\nret = power_supply_register(&pdev->dev, &bci->ac);\r\nif (ret) {\r\ndev_err(&pdev->dev, "failed to register ac: %d\n", ret);\r\ngoto fail_register_ac;\r\n}\r\nbci->usb.name = "twl4030_usb";\r\nbci->usb.type = POWER_SUPPLY_TYPE_USB;\r\nbci->usb.properties = twl4030_charger_props;\r\nbci->usb.num_properties = ARRAY_SIZE(twl4030_charger_props);\r\nbci->usb.get_property = twl4030_bci_get_property;\r\nbci->usb_reg = regulator_get(bci->dev, "bci3v1");\r\nret = power_supply_register(&pdev->dev, &bci->usb);\r\nif (ret) {\r\ndev_err(&pdev->dev, "failed to register usb: %d\n", ret);\r\ngoto fail_register_usb;\r\n}\r\nret = request_threaded_irq(bci->irq_chg, NULL,\r\ntwl4030_charger_interrupt, IRQF_ONESHOT, pdev->name,\r\nbci);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "could not request irq %d, status %d\n",\r\nbci->irq_chg, ret);\r\ngoto fail_chg_irq;\r\n}\r\nret = request_threaded_irq(bci->irq_bci, NULL,\r\ntwl4030_bci_interrupt, IRQF_ONESHOT, pdev->name, bci);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "could not request irq %d, status %d\n",\r\nbci->irq_bci, ret);\r\ngoto fail_bci_irq;\r\n}\r\nINIT_WORK(&bci->work, twl4030_bci_usb_work);\r\nbci->transceiver = usb_get_phy(USB_PHY_TYPE_USB2);\r\nif (!IS_ERR_OR_NULL(bci->transceiver)) {\r\nbci->usb_nb.notifier_call = twl4030_bci_usb_ncb;\r\nusb_register_notifier(bci->transceiver, &bci->usb_nb);\r\n}\r\nreg = ~(u32)(TWL4030_ICHGLOW | TWL4030_ICHGEOC | TWL4030_TBATOR2 |\r\nTWL4030_TBATOR1 | TWL4030_BATSTS);\r\nret = twl_i2c_write_u8(TWL4030_MODULE_INTERRUPTS, reg,\r\nTWL4030_INTERRUPTS_BCIIMR1A);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "failed to unmask interrupts: %d\n", ret);\r\ngoto fail_unmask_interrupts;\r\n}\r\nreg = ~(u32)(TWL4030_VBATOV | TWL4030_VBUSOV | TWL4030_ACCHGOV);\r\nret = twl_i2c_write_u8(TWL4030_MODULE_INTERRUPTS, reg,\r\nTWL4030_INTERRUPTS_BCIIMR2A);\r\nif (ret < 0)\r\ndev_warn(&pdev->dev, "failed to unmask interrupts: %d\n", ret);\r\ntwl4030_charger_enable_ac(true);\r\ntwl4030_charger_enable_usb(bci, true);\r\ntwl4030_charger_enable_backup(pdata->bb_uvolt,\r\npdata->bb_uamp);\r\nreturn 0;\r\nfail_unmask_interrupts:\r\nif (!IS_ERR_OR_NULL(bci->transceiver)) {\r\nusb_unregister_notifier(bci->transceiver, &bci->usb_nb);\r\nusb_put_phy(bci->transceiver);\r\n}\r\nfree_irq(bci->irq_bci, bci);\r\nfail_bci_irq:\r\nfree_irq(bci->irq_chg, bci);\r\nfail_chg_irq:\r\npower_supply_unregister(&bci->usb);\r\nfail_register_usb:\r\npower_supply_unregister(&bci->ac);\r\nfail_register_ac:\r\nplatform_set_drvdata(pdev, NULL);\r\nkfree(bci);\r\nreturn ret;\r\n}\r\nstatic int __exit twl4030_bci_remove(struct platform_device *pdev)\r\n{\r\nstruct twl4030_bci *bci = platform_get_drvdata(pdev);\r\ntwl4030_charger_enable_ac(false);\r\ntwl4030_charger_enable_usb(bci, false);\r\ntwl4030_charger_enable_backup(0, 0);\r\ntwl_i2c_write_u8(TWL4030_MODULE_INTERRUPTS, 0xff,\r\nTWL4030_INTERRUPTS_BCIIMR1A);\r\ntwl_i2c_write_u8(TWL4030_MODULE_INTERRUPTS, 0xff,\r\nTWL4030_INTERRUPTS_BCIIMR2A);\r\nif (!IS_ERR_OR_NULL(bci->transceiver)) {\r\nusb_unregister_notifier(bci->transceiver, &bci->usb_nb);\r\nusb_put_phy(bci->transceiver);\r\n}\r\nfree_irq(bci->irq_bci, bci);\r\nfree_irq(bci->irq_chg, bci);\r\npower_supply_unregister(&bci->usb);\r\npower_supply_unregister(&bci->ac);\r\nplatform_set_drvdata(pdev, NULL);\r\nkfree(bci);\r\nreturn 0;\r\n}\r\nstatic int __init twl4030_bci_init(void)\r\n{\r\nreturn platform_driver_probe(&twl4030_bci_driver, twl4030_bci_probe);\r\n}\r\nstatic void __exit twl4030_bci_exit(void)\r\n{\r\nplatform_driver_unregister(&twl4030_bci_driver);\r\n}
