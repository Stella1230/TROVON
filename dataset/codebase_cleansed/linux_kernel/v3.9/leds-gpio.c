static void gpio_led_work(struct work_struct *work)\r\n{\r\nstruct gpio_led_data *led_dat =\r\ncontainer_of(work, struct gpio_led_data, work);\r\nif (led_dat->blinking) {\r\nled_dat->platform_gpio_blink_set(led_dat->gpio,\r\nled_dat->new_level,\r\nNULL, NULL);\r\nled_dat->blinking = 0;\r\n} else\r\ngpio_set_value_cansleep(led_dat->gpio, led_dat->new_level);\r\n}\r\nstatic void gpio_led_set(struct led_classdev *led_cdev,\r\nenum led_brightness value)\r\n{\r\nstruct gpio_led_data *led_dat =\r\ncontainer_of(led_cdev, struct gpio_led_data, cdev);\r\nint level;\r\nif (value == LED_OFF)\r\nlevel = 0;\r\nelse\r\nlevel = 1;\r\nif (led_dat->active_low)\r\nlevel = !level;\r\nif (led_dat->can_sleep) {\r\nled_dat->new_level = level;\r\nschedule_work(&led_dat->work);\r\n} else {\r\nif (led_dat->blinking) {\r\nled_dat->platform_gpio_blink_set(led_dat->gpio, level,\r\nNULL, NULL);\r\nled_dat->blinking = 0;\r\n} else\r\ngpio_set_value(led_dat->gpio, level);\r\n}\r\n}\r\nstatic int gpio_blink_set(struct led_classdev *led_cdev,\r\nunsigned long *delay_on, unsigned long *delay_off)\r\n{\r\nstruct gpio_led_data *led_dat =\r\ncontainer_of(led_cdev, struct gpio_led_data, cdev);\r\nled_dat->blinking = 1;\r\nreturn led_dat->platform_gpio_blink_set(led_dat->gpio, GPIO_LED_BLINK,\r\ndelay_on, delay_off);\r\n}\r\nstatic int create_gpio_led(const struct gpio_led *template,\r\nstruct gpio_led_data *led_dat, struct device *parent,\r\nint (*blink_set)(unsigned, int, unsigned long *, unsigned long *))\r\n{\r\nint ret, state;\r\nled_dat->gpio = -1;\r\nif (!gpio_is_valid(template->gpio)) {\r\ndev_info(parent, "Skipping unavailable LED gpio %d (%s)\n",\r\ntemplate->gpio, template->name);\r\nreturn 0;\r\n}\r\nled_dat->cdev.name = template->name;\r\nled_dat->cdev.default_trigger = template->default_trigger;\r\nled_dat->gpio = template->gpio;\r\nled_dat->can_sleep = gpio_cansleep(template->gpio);\r\nled_dat->active_low = template->active_low;\r\nled_dat->blinking = 0;\r\nif (blink_set) {\r\nled_dat->platform_gpio_blink_set = blink_set;\r\nled_dat->cdev.blink_set = gpio_blink_set;\r\n}\r\nled_dat->cdev.brightness_set = gpio_led_set;\r\nif (template->default_state == LEDS_GPIO_DEFSTATE_KEEP)\r\nstate = !!gpio_get_value_cansleep(led_dat->gpio) ^ led_dat->active_low;\r\nelse\r\nstate = (template->default_state == LEDS_GPIO_DEFSTATE_ON);\r\nled_dat->cdev.brightness = state ? LED_FULL : LED_OFF;\r\nif (!template->retain_state_suspended)\r\nled_dat->cdev.flags |= LED_CORE_SUSPENDRESUME;\r\nret = devm_gpio_request_one(parent, template->gpio,\r\n(led_dat->active_low ^ state) ?\r\nGPIOF_OUT_INIT_HIGH : GPIOF_OUT_INIT_LOW,\r\ntemplate->name);\r\nif (ret < 0)\r\nreturn ret;\r\nINIT_WORK(&led_dat->work, gpio_led_work);\r\nret = led_classdev_register(parent, &led_dat->cdev);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nstatic void delete_gpio_led(struct gpio_led_data *led)\r\n{\r\nif (!gpio_is_valid(led->gpio))\r\nreturn;\r\nled_classdev_unregister(&led->cdev);\r\ncancel_work_sync(&led->work);\r\n}\r\nstatic inline int sizeof_gpio_leds_priv(int num_leds)\r\n{\r\nreturn sizeof(struct gpio_leds_priv) +\r\n(sizeof(struct gpio_led_data) * num_leds);\r\n}\r\nstatic struct gpio_leds_priv *gpio_leds_create_of(struct platform_device *pdev)\r\n{\r\nstruct device_node *np = pdev->dev.of_node, *child;\r\nstruct gpio_leds_priv *priv;\r\nint count, ret;\r\ncount = of_get_child_count(np);\r\nif (!count)\r\nreturn ERR_PTR(-ENODEV);\r\nfor_each_child_of_node(np, child)\r\nif (of_get_gpio(child, 0) == -EPROBE_DEFER)\r\nreturn ERR_PTR(-EPROBE_DEFER);\r\npriv = devm_kzalloc(&pdev->dev, sizeof_gpio_leds_priv(count),\r\nGFP_KERNEL);\r\nif (!priv)\r\nreturn ERR_PTR(-ENOMEM);\r\nfor_each_child_of_node(np, child) {\r\nstruct gpio_led led = {};\r\nenum of_gpio_flags flags;\r\nconst char *state;\r\nled.gpio = of_get_gpio_flags(child, 0, &flags);\r\nled.active_low = flags & OF_GPIO_ACTIVE_LOW;\r\nled.name = of_get_property(child, "label", NULL) ? : child->name;\r\nled.default_trigger =\r\nof_get_property(child, "linux,default-trigger", NULL);\r\nstate = of_get_property(child, "default-state", NULL);\r\nif (state) {\r\nif (!strcmp(state, "keep"))\r\nled.default_state = LEDS_GPIO_DEFSTATE_KEEP;\r\nelse if (!strcmp(state, "on"))\r\nled.default_state = LEDS_GPIO_DEFSTATE_ON;\r\nelse\r\nled.default_state = LEDS_GPIO_DEFSTATE_OFF;\r\n}\r\nret = create_gpio_led(&led, &priv->leds[priv->num_leds++],\r\n&pdev->dev, NULL);\r\nif (ret < 0) {\r\nof_node_put(child);\r\ngoto err;\r\n}\r\n}\r\nreturn priv;\r\nerr:\r\nfor (count = priv->num_leds - 2; count >= 0; count--)\r\ndelete_gpio_led(&priv->leds[count]);\r\nreturn ERR_PTR(-ENODEV);\r\n}\r\nstatic struct gpio_leds_priv *gpio_leds_create_of(struct platform_device *pdev)\r\n{\r\nreturn ERR_PTR(-ENODEV);\r\n}\r\nstatic int gpio_led_probe(struct platform_device *pdev)\r\n{\r\nstruct gpio_led_platform_data *pdata = pdev->dev.platform_data;\r\nstruct gpio_leds_priv *priv;\r\nstruct pinctrl *pinctrl;\r\nint i, ret = 0;\r\npinctrl = devm_pinctrl_get_select_default(&pdev->dev);\r\nif (IS_ERR(pinctrl))\r\ndev_warn(&pdev->dev,\r\n"pins are not configured from the driver\n");\r\nif (pdata && pdata->num_leds) {\r\npriv = devm_kzalloc(&pdev->dev,\r\nsizeof_gpio_leds_priv(pdata->num_leds),\r\nGFP_KERNEL);\r\nif (!priv)\r\nreturn -ENOMEM;\r\npriv->num_leds = pdata->num_leds;\r\nfor (i = 0; i < priv->num_leds; i++) {\r\nret = create_gpio_led(&pdata->leds[i],\r\n&priv->leds[i],\r\n&pdev->dev, pdata->gpio_blink_set);\r\nif (ret < 0) {\r\nfor (i = i - 1; i >= 0; i--)\r\ndelete_gpio_led(&priv->leds[i]);\r\nreturn ret;\r\n}\r\n}\r\n} else {\r\npriv = gpio_leds_create_of(pdev);\r\nif (IS_ERR(priv))\r\nreturn PTR_ERR(priv);\r\n}\r\nplatform_set_drvdata(pdev, priv);\r\nreturn 0;\r\n}\r\nstatic int gpio_led_remove(struct platform_device *pdev)\r\n{\r\nstruct gpio_leds_priv *priv = platform_get_drvdata(pdev);\r\nint i;\r\nfor (i = 0; i < priv->num_leds; i++)\r\ndelete_gpio_led(&priv->leds[i]);\r\nplatform_set_drvdata(pdev, NULL);\r\nreturn 0;\r\n}
