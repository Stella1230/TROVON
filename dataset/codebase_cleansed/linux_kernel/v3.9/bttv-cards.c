void bttv_idcard(struct bttv *btv)\r\n{\r\nunsigned int gpiobits;\r\nint i,type;\r\nbtv->cardid = btv->c.pci->subsystem_device << 16;\r\nbtv->cardid |= btv->c.pci->subsystem_vendor;\r\nif (0 != btv->cardid && 0xffffffff != btv->cardid) {\r\nfor (type = -1, i = 0; cards[i].id != 0; i++)\r\nif (cards[i].id == btv->cardid)\r\ntype = i;\r\nif (type != -1) {\r\npr_info("%d: detected: %s [card=%d], PCI subsystem ID is %04x:%04x\n",\r\nbtv->c.nr, cards[type].name, cards[type].cardnr,\r\nbtv->cardid & 0xffff,\r\n(btv->cardid >> 16) & 0xffff);\r\nbtv->c.type = cards[type].cardnr;\r\n} else {\r\npr_info("%d: subsystem: %04x:%04x (UNKNOWN)\n",\r\nbtv->c.nr, btv->cardid & 0xffff,\r\n(btv->cardid >> 16) & 0xffff);\r\npr_debug("please mail id, board name and the correct card= insmod option to linux-media@vger.kernel.org\n");\r\n}\r\n}\r\nif (card[btv->c.nr] < bttv_num_tvcards)\r\nbtv->c.type=card[btv->c.nr];\r\npr_info("%d: using: %s [card=%d,%s]\n",\r\nbtv->c.nr, bttv_tvcards[btv->c.type].name, btv->c.type,\r\ncard[btv->c.nr] < bttv_num_tvcards\r\n? "insmod option" : "autodetected");\r\nif (UNSET == audioall && UNSET == audiomux[0])\r\nreturn;\r\nif (UNSET != audiomux[0]) {\r\ngpiobits = 0;\r\nfor (i = 0; i < ARRAY_SIZE(bttv_tvcards->gpiomux); i++) {\r\nbttv_tvcards[btv->c.type].gpiomux[i] = audiomux[i];\r\ngpiobits |= audiomux[i];\r\n}\r\n} else {\r\ngpiobits = audioall;\r\nfor (i = 0; i < ARRAY_SIZE(bttv_tvcards->gpiomux); i++) {\r\nbttv_tvcards[btv->c.type].gpiomux[i] = audioall;\r\n}\r\n}\r\nbttv_tvcards[btv->c.type].gpiomask = (UNSET != gpiomask) ? gpiomask : gpiobits;\r\npr_info("%d: gpio config override: mask=0x%x, mux=",\r\nbtv->c.nr, bttv_tvcards[btv->c.type].gpiomask);\r\nfor (i = 0; i < ARRAY_SIZE(bttv_tvcards->gpiomux); i++) {\r\npr_cont("%s0x%x",\r\ni ? "," : "", bttv_tvcards[btv->c.type].gpiomux[i]);\r\n}\r\npr_cont("\n");\r\n}\r\nstatic void identify_by_eeprom(struct bttv *btv, unsigned char eeprom_data[256])\r\n{\r\nint type = -1;\r\nif (0 == strncmp(eeprom_data,"GET MM20xPCTV",13))\r\ntype = BTTV_BOARD_MODTEC_205;\r\nelse if (0 == strncmp(eeprom_data+20,"Picolo",7))\r\ntype = BTTV_BOARD_EURESYS_PICOLO;\r\nelse if (eeprom_data[0] == 0x84 && eeprom_data[2]== 0)\r\ntype = BTTV_BOARD_HAUPPAUGE;\r\nif (-1 != type) {\r\nbtv->c.type = type;\r\npr_info("%d: detected by eeprom: %s [card=%d]\n",\r\nbtv->c.nr, bttv_tvcards[btv->c.type].name, btv->c.type);\r\n}\r\n}\r\nstatic void flyvideo_gpio(struct bttv *btv)\r\n{\r\nint gpio, has_remote, has_radio, is_capture_only;\r\nint is_lr90, has_tda9820_tda9821;\r\nint tuner_type = UNSET, ttype;\r\ngpio_inout(0xffffff, 0);\r\nudelay(8);\r\ngpio = gpio_read();\r\nttype = (gpio & 0x0f0000) >> 16;\r\nswitch (ttype) {\r\ncase 0x0:\r\ntuner_type = 2;\r\nbreak;\r\ncase 0x2:\r\ntuner_type = 39;\r\nbreak;\r\ncase 0x4:\r\ntuner_type = 5;\r\nbreak;\r\ncase 0x6:\r\ntuner_type = 37;\r\nbreak;\r\ncase 0xC:\r\ntuner_type = 3;\r\nbreak;\r\ndefault:\r\npr_info("%d: FlyVideo_gpio: unknown tuner type\n", btv->c.nr);\r\nbreak;\r\n}\r\nhas_remote = gpio & 0x800000;\r\nhas_radio = gpio & 0x400000;\r\nis_capture_only = !(gpio & 0x008000);\r\nhas_tda9820_tda9821 = !(gpio & 0x004000);\r\nis_lr90 = !(gpio & 0x002000);\r\nif (is_capture_only)\r\ntuner_type = TUNER_ABSENT;\r\npr_info("%d: FlyVideo Radio=%s RemoteControl=%s Tuner=%d gpio=0x%06x\n",\r\nbtv->c.nr, has_radio ? "yes" : "no",\r\nhas_remote ? "yes" : "no", tuner_type, gpio);\r\npr_info("%d: FlyVideo LR90=%s tda9821/tda9820=%s capture_only=%s\n",\r\nbtv->c.nr, is_lr90 ? "yes" : "no",\r\nhas_tda9820_tda9821 ? "yes" : "no",\r\nis_capture_only ? "yes" : "no");\r\nif (tuner_type != UNSET)\r\nbtv->tuner_type = tuner_type;\r\nbtv->has_radio = has_radio;\r\nif (has_tda9820_tda9821)\r\nbtv->audio_mode_gpio = lt9415_audio;\r\n}\r\nstatic void miro_pinnacle_gpio(struct bttv *btv)\r\n{\r\nint id,msp,gpio;\r\nchar *info;\r\ngpio_inout(0xffffff, 0);\r\ngpio = gpio_read();\r\nid = ((gpio>>10) & 63) -1;\r\nmsp = bttv_I2CRead(btv, I2C_ADDR_MSP3400, "MSP34xx");\r\nif (id < 32) {\r\nbtv->tuner_type = miro_tunermap[id];\r\nif (0 == (gpio & 0x20)) {\r\nbtv->has_radio = 1;\r\nif (!miro_fmtuner[id]) {\r\nbtv->has_matchbox = 1;\r\nbtv->mbox_we = (1<<6);\r\nbtv->mbox_most = (1<<7);\r\nbtv->mbox_clk = (1<<8);\r\nbtv->mbox_data = (1<<9);\r\nbtv->mbox_mask = (1<<6)|(1<<7)|(1<<8)|(1<<9);\r\n}\r\n} else {\r\nbtv->has_radio = 0;\r\n}\r\nif (-1 != msp) {\r\nif (btv->c.type == BTTV_BOARD_MIRO)\r\nbtv->c.type = BTTV_BOARD_MIROPRO;\r\nif (btv->c.type == BTTV_BOARD_PINNACLE)\r\nbtv->c.type = BTTV_BOARD_PINNACLEPRO;\r\n}\r\npr_info("%d: miro: id=%d tuner=%d radio=%s stereo=%s\n",\r\nbtv->c.nr, id+1, btv->tuner_type,\r\n!btv->has_radio ? "no" :\r\n(btv->has_matchbox ? "matchbox" : "fmtuner"),\r\n(-1 == msp) ? "no" : "yes");\r\n} else {\r\nid = 63 - id;\r\nbtv->has_radio = 0;\r\nswitch (id) {\r\ncase 1:\r\ninfo = "PAL / mono";\r\nbtv->tda9887_conf = TDA9887_INTERCARRIER;\r\nbreak;\r\ncase 2:\r\ninfo = "PAL+SECAM / stereo";\r\nbtv->has_radio = 1;\r\nbtv->tda9887_conf = TDA9887_QSS;\r\nbreak;\r\ncase 3:\r\ninfo = "NTSC / stereo";\r\nbtv->has_radio = 1;\r\nbtv->tda9887_conf = TDA9887_QSS;\r\nbreak;\r\ncase 4:\r\ninfo = "PAL+SECAM / mono";\r\nbtv->tda9887_conf = TDA9887_QSS;\r\nbreak;\r\ncase 5:\r\ninfo = "NTSC / mono";\r\nbtv->tda9887_conf = TDA9887_INTERCARRIER;\r\nbreak;\r\ncase 6:\r\ninfo = "NTSC / stereo";\r\nbtv->tda9887_conf = TDA9887_INTERCARRIER;\r\nbreak;\r\ncase 7:\r\ninfo = "PAL / stereo";\r\nbtv->tda9887_conf = TDA9887_INTERCARRIER;\r\nbreak;\r\ndefault:\r\ninfo = "oops: unknown card";\r\nbreak;\r\n}\r\nif (-1 != msp)\r\nbtv->c.type = BTTV_BOARD_PINNACLEPRO;\r\npr_info("%d: pinnacle/mt: id=%d info=\"%s\" radio=%s\n",\r\nbtv->c.nr, id, info, btv->has_radio ? "yes" : "no");\r\nbtv->tuner_type = TUNER_MT2032;\r\n}\r\n}\r\nstatic void init_ids_eagle(struct bttv *btv)\r\n{\r\ngpio_inout(0xffffff,0xFFFF37);\r\ngpio_write(0x200020);\r\ngpio_write(0x200024);\r\ngpio_bits(LM1882_SYNC_DRIVE,LM1882_SYNC_DRIVE);\r\nbtaor((2)<<5, ~(2<<5), BT848_IFORM);\r\n}\r\nstatic void eagle_muxsel(struct bttv *btv, unsigned int input)\r\n{\r\ngpio_bits(3, input & 3);\r\nbtor(BT848_ADC_C_SLEEP, BT848_ADC);\r\nbtand(~BT848_CONTROL_COMP, BT848_E_CONTROL);\r\nbtand(~BT848_CONTROL_COMP, BT848_O_CONTROL);\r\ngpio_bits(LM1882_SYNC_DRIVE,LM1882_SYNC_DRIVE);\r\n}\r\nstatic void gvc1100_muxsel(struct bttv *btv, unsigned int input)\r\n{\r\nstatic const int masks[] = {0x30, 0x01, 0x12, 0x23};\r\ngpio_write(masks[input%4]);\r\n}\r\nstatic void init_lmlbt4x(struct bttv *btv)\r\n{\r\npr_debug("LMLBT4x init\n");\r\nbtwrite(0x000000, BT848_GPIO_REG_INP);\r\ngpio_inout(0xffffff, 0x0006C0);\r\ngpio_write(0x000000);\r\n}\r\nstatic void sigmaSQ_muxsel(struct bttv *btv, unsigned int input)\r\n{\r\nunsigned int inmux = input % 8;\r\ngpio_inout( 0xf, 0xf );\r\ngpio_bits( 0xf, inmux );\r\n}\r\nstatic void sigmaSLC_muxsel(struct bttv *btv, unsigned int input)\r\n{\r\nunsigned int inmux = input % 4;\r\ngpio_inout( 3<<9, 3<<9 );\r\ngpio_bits( 3<<9, inmux<<9 );\r\n}\r\nstatic void geovision_muxsel(struct bttv *btv, unsigned int input)\r\n{\r\nunsigned int inmux = input % 16;\r\ngpio_inout(0xf, 0xf);\r\ngpio_bits(0xf, inmux);\r\n}\r\nstatic void td3116_latch_value(struct bttv *btv, u32 value)\r\n{\r\ngpio_bits((1<<18) | 0xff, value);\r\ngpio_bits((1<<18) | 0xff, (1<<18) | value);\r\nudelay(1);\r\ngpio_bits((1<<18) | 0xff, value);\r\n}\r\nstatic void td3116_muxsel(struct bttv *btv, unsigned int input)\r\n{\r\nu32 value;\r\nu32 highbit;\r\nhighbit = (input & 0x8) >> 3 ;\r\nvalue = 0x11;\r\nvalue |= ((input & 0x7) << 1) << (4 * highbit);\r\ntd3116_latch_value(btv, value);\r\nvalue &= ~0x11;\r\nvalue |= ((highbit ^ 0x1) << 4) | highbit;\r\ntd3116_latch_value(btv, value);\r\n}\r\nstatic void bttv_reset_audio(struct bttv *btv)\r\n{\r\nif (btv->id != 878)\r\nreturn;\r\nif (bttv_debug)\r\npr_debug("%d: BT878A ARESET\n", btv->c.nr);\r\nbtwrite((1<<7), 0x058);\r\nudelay(10);\r\nbtwrite( 0, 0x058);\r\n}\r\nvoid bttv_init_card1(struct bttv *btv)\r\n{\r\nswitch (btv->c.type) {\r\ncase BTTV_BOARD_HAUPPAUGE:\r\ncase BTTV_BOARD_HAUPPAUGE878:\r\nboot_msp34xx(btv,5);\r\nbreak;\r\ncase BTTV_BOARD_VOODOOTV_200:\r\ncase BTTV_BOARD_VOODOOTV_FM:\r\nboot_msp34xx(btv,20);\r\nbreak;\r\ncase BTTV_BOARD_AVERMEDIA98:\r\nboot_msp34xx(btv,11);\r\nbreak;\r\ncase BTTV_BOARD_HAUPPAUGEPVR:\r\npvr_boot(btv);\r\nbreak;\r\ncase BTTV_BOARD_TWINHAN_DST:\r\ncase BTTV_BOARD_AVDVBT_771:\r\ncase BTTV_BOARD_PINNACLESAT:\r\nbtv->use_i2c_hw = 1;\r\nbreak;\r\ncase BTTV_BOARD_ADLINK_RTV24:\r\ninit_RTV24( btv );\r\nbreak;\r\n}\r\nif (!bttv_tvcards[btv->c.type].has_dvb)\r\nbttv_reset_audio(btv);\r\n}\r\nvoid bttv_init_card2(struct bttv *btv)\r\n{\r\nbtv->tuner_type = UNSET;\r\nif (BTTV_BOARD_UNKNOWN == btv->c.type) {\r\nbttv_readee(btv,eeprom_data,0xa0);\r\nidentify_by_eeprom(btv,eeprom_data);\r\n}\r\nswitch (btv->c.type) {\r\ncase BTTV_BOARD_MIRO:\r\ncase BTTV_BOARD_MIROPRO:\r\ncase BTTV_BOARD_PINNACLE:\r\ncase BTTV_BOARD_PINNACLEPRO:\r\nmiro_pinnacle_gpio(btv);\r\nbreak;\r\ncase BTTV_BOARD_FLYVIDEO_98:\r\ncase BTTV_BOARD_MAXI:\r\ncase BTTV_BOARD_LIFE_FLYKIT:\r\ncase BTTV_BOARD_FLYVIDEO:\r\ncase BTTV_BOARD_TYPHOON_TVIEW:\r\ncase BTTV_BOARD_CHRONOS_VS2:\r\ncase BTTV_BOARD_FLYVIDEO_98FM:\r\ncase BTTV_BOARD_FLYVIDEO2000:\r\ncase BTTV_BOARD_FLYVIDEO98EZ:\r\ncase BTTV_BOARD_CONFERENCETV:\r\ncase BTTV_BOARD_LIFETEC_9415:\r\nflyvideo_gpio(btv);\r\nbreak;\r\ncase BTTV_BOARD_HAUPPAUGE:\r\ncase BTTV_BOARD_HAUPPAUGE878:\r\ncase BTTV_BOARD_HAUPPAUGEPVR:\r\nbttv_readee(btv,eeprom_data,0xa0);\r\nhauppauge_eeprom(btv);\r\nbreak;\r\ncase BTTV_BOARD_AVERMEDIA98:\r\ncase BTTV_BOARD_AVPHONE98:\r\nbttv_readee(btv,eeprom_data,0xa0);\r\navermedia_eeprom(btv);\r\nbreak;\r\ncase BTTV_BOARD_PXC200:\r\ninit_PXC200(btv);\r\nbreak;\r\ncase BTTV_BOARD_PICOLO_TETRA_CHIP:\r\npicolo_tetra_init(btv);\r\nbreak;\r\ncase BTTV_BOARD_VHX:\r\nbtv->has_radio = 1;\r\nbtv->has_matchbox = 1;\r\nbtv->mbox_we = 0x20;\r\nbtv->mbox_most = 0;\r\nbtv->mbox_clk = 0x08;\r\nbtv->mbox_data = 0x10;\r\nbtv->mbox_mask = 0x38;\r\nbreak;\r\ncase BTTV_BOARD_VOBIS_BOOSTAR:\r\ncase BTTV_BOARD_TERRATV:\r\nterratec_active_radio_upgrade(btv);\r\nbreak;\r\ncase BTTV_BOARD_MAGICTVIEW061:\r\nif (btv->cardid == 0x3002144f) {\r\nbtv->has_radio=1;\r\npr_info("%d: radio detected by subsystem id (CPH05x)\n",\r\nbtv->c.nr);\r\n}\r\nbreak;\r\ncase BTTV_BOARD_STB2:\r\nif (btv->cardid == 0x3060121a) {\r\nbtv->has_radio=0;\r\nbtv->tuner_type=TUNER_TEMIC_NTSC;\r\n}\r\nbreak;\r\ncase BTTV_BOARD_OSPREY1x0:\r\ncase BTTV_BOARD_OSPREY1x0_848:\r\ncase BTTV_BOARD_OSPREY101_848:\r\ncase BTTV_BOARD_OSPREY1x1:\r\ncase BTTV_BOARD_OSPREY1x1_SVID:\r\ncase BTTV_BOARD_OSPREY2xx:\r\ncase BTTV_BOARD_OSPREY2x0_SVID:\r\ncase BTTV_BOARD_OSPREY2x0:\r\ncase BTTV_BOARD_OSPREY440:\r\ncase BTTV_BOARD_OSPREY500:\r\ncase BTTV_BOARD_OSPREY540:\r\ncase BTTV_BOARD_OSPREY2000:\r\nbttv_readee(btv,eeprom_data,0xa0);\r\nosprey_eeprom(btv, eeprom_data);\r\nbreak;\r\ncase BTTV_BOARD_IDS_EAGLE:\r\ninit_ids_eagle(btv);\r\nbreak;\r\ncase BTTV_BOARD_MODTEC_205:\r\nbttv_readee(btv,eeprom_data,0xa0);\r\nmodtec_eeprom(btv);\r\nbreak;\r\ncase BTTV_BOARD_LMLBT4:\r\ninit_lmlbt4x(btv);\r\nbreak;\r\ncase BTTV_BOARD_TIBET_CS16:\r\ntibetCS16_init(btv);\r\nbreak;\r\ncase BTTV_BOARD_KODICOM_4400R:\r\nkodicom4400r_init(btv);\r\nbreak;\r\ncase BTTV_BOARD_GEOVISION_GV800S:\r\ngv800s_init(btv);\r\nbreak;\r\n}\r\nif (!(btv->id==848 && btv->revision==0x11)) {\r\nif (PLL_28 == bttv_tvcards[btv->c.type].pll) {\r\nbtv->pll.pll_ifreq=28636363;\r\nbtv->pll.pll_crystal=BT848_IFORM_XT0;\r\n}\r\nif (PLL_35 == bttv_tvcards[btv->c.type].pll) {\r\nbtv->pll.pll_ifreq=35468950;\r\nbtv->pll.pll_crystal=BT848_IFORM_XT1;\r\n}\r\nswitch (pll[btv->c.nr]) {\r\ncase 0:\r\nbtv->pll.pll_crystal = 0;\r\nbtv->pll.pll_ifreq = 0;\r\nbtv->pll.pll_ofreq = 0;\r\nbreak;\r\ncase 1:\r\ncase 28:\r\nbtv->pll.pll_ifreq = 28636363;\r\nbtv->pll.pll_ofreq = 0;\r\nbtv->pll.pll_crystal = BT848_IFORM_XT0;\r\nbreak;\r\ncase 2:\r\ncase 35:\r\nbtv->pll.pll_ifreq = 35468950;\r\nbtv->pll.pll_ofreq = 0;\r\nbtv->pll.pll_crystal = BT848_IFORM_XT1;\r\nbreak;\r\n}\r\n}\r\nbtv->pll.pll_current = -1;\r\nif (UNSET != bttv_tvcards[btv->c.type].tuner_type)\r\nif (UNSET == btv->tuner_type)\r\nbtv->tuner_type = bttv_tvcards[btv->c.type].tuner_type;\r\nif (UNSET != tuner[btv->c.nr])\r\nbtv->tuner_type = tuner[btv->c.nr];\r\nif (btv->tuner_type == TUNER_ABSENT)\r\npr_info("%d: tuner absent\n", btv->c.nr);\r\nelse if (btv->tuner_type == UNSET)\r\npr_warn("%d: tuner type unset\n", btv->c.nr);\r\nelse\r\npr_info("%d: tuner type=%d\n", btv->c.nr, btv->tuner_type);\r\nif (autoload != UNSET) {\r\npr_warn("%d: the autoload option is obsolete\n", btv->c.nr);\r\npr_warn("%d: use option msp3400, tda7432 or tvaudio to override which audio module should be used\n",\r\nbtv->c.nr);\r\n}\r\nif (UNSET == btv->tuner_type)\r\nbtv->tuner_type = TUNER_ABSENT;\r\nbtv->dig = bttv_tvcards[btv->c.type].has_dig_in ?\r\nbttv_tvcards[btv->c.type].video_inputs - 1 : UNSET;\r\nbtv->svhs = bttv_tvcards[btv->c.type].svhs == NO_SVHS ?\r\nUNSET : bttv_tvcards[btv->c.type].svhs;\r\nif (svhs[btv->c.nr] != UNSET)\r\nbtv->svhs = svhs[btv->c.nr];\r\nif (remote[btv->c.nr] != UNSET)\r\nbtv->has_remote = remote[btv->c.nr];\r\nif (bttv_tvcards[btv->c.type].has_radio)\r\nbtv->has_radio = 1;\r\nif (bttv_tvcards[btv->c.type].has_remote)\r\nbtv->has_remote = 1;\r\nif (!bttv_tvcards[btv->c.type].no_gpioirq)\r\nbtv->gpioirq = 1;\r\nif (bttv_tvcards[btv->c.type].volume_gpio)\r\nbtv->volume_gpio = bttv_tvcards[btv->c.type].volume_gpio;\r\nif (bttv_tvcards[btv->c.type].audio_mode_gpio)\r\nbtv->audio_mode_gpio = bttv_tvcards[btv->c.type].audio_mode_gpio;\r\nif (btv->tuner_type == TUNER_ABSENT)\r\nreturn;\r\nif (btv->has_saa6588 || saa6588[btv->c.nr]) {\r\nstatic const unsigned short addrs[] = {\r\n0x20 >> 1,\r\n0x22 >> 1,\r\nI2C_CLIENT_END\r\n};\r\nstruct v4l2_subdev *sd;\r\nsd = v4l2_i2c_new_subdev(&btv->c.v4l2_dev,\r\n&btv->c.i2c_adap, "saa6588", 0, addrs);\r\nbtv->has_saa6588 = (sd != NULL);\r\n}\r\nswitch (audiodev[btv->c.nr]) {\r\ncase -1:\r\nreturn;\r\ncase 0:\r\nbreak;\r\ncase 1: {\r\nstatic const unsigned short addrs[] = {\r\nI2C_ADDR_MSP3400 >> 1,\r\nI2C_ADDR_MSP3400_ALT >> 1,\r\nI2C_CLIENT_END\r\n};\r\nbtv->sd_msp34xx = v4l2_i2c_new_subdev(&btv->c.v4l2_dev,\r\n&btv->c.i2c_adap, "msp3400", 0, addrs);\r\nif (btv->sd_msp34xx)\r\nreturn;\r\ngoto no_audio;\r\n}\r\ncase 2: {\r\nstatic const unsigned short addrs[] = {\r\nI2C_ADDR_TDA7432 >> 1,\r\nI2C_CLIENT_END\r\n};\r\nif (v4l2_i2c_new_subdev(&btv->c.v4l2_dev,\r\n&btv->c.i2c_adap, "tda7432", 0, addrs))\r\nreturn;\r\ngoto no_audio;\r\n}\r\ncase 3: {\r\nbtv->sd_tvaudio = v4l2_i2c_new_subdev(&btv->c.v4l2_dev,\r\n&btv->c.i2c_adap, "tvaudio", 0, tvaudio_addrs());\r\nif (btv->sd_tvaudio)\r\nreturn;\r\ngoto no_audio;\r\n}\r\ndefault:\r\npr_warn("%d: unknown audiodev value!\n", btv->c.nr);\r\nreturn;\r\n}\r\nif (!bttv_tvcards[btv->c.type].no_msp34xx) {\r\nbtv->sd_msp34xx = v4l2_i2c_new_subdev(&btv->c.v4l2_dev,\r\n&btv->c.i2c_adap, "msp3400",\r\n0, I2C_ADDRS(I2C_ADDR_MSP3400 >> 1));\r\n} else if (bttv_tvcards[btv->c.type].msp34xx_alt) {\r\nbtv->sd_msp34xx = v4l2_i2c_new_subdev(&btv->c.v4l2_dev,\r\n&btv->c.i2c_adap, "msp3400",\r\n0, I2C_ADDRS(I2C_ADDR_MSP3400_ALT >> 1));\r\n}\r\nif (btv->sd_msp34xx)\r\nreturn;\r\nif (!bttv_tvcards[btv->c.type].no_tda7432) {\r\nstatic const unsigned short addrs[] = {\r\nI2C_ADDR_TDA7432 >> 1,\r\nI2C_CLIENT_END\r\n};\r\nif (v4l2_i2c_new_subdev(&btv->c.v4l2_dev,\r\n&btv->c.i2c_adap, "tda7432", 0, addrs))\r\nreturn;\r\n}\r\nbtv->sd_tvaudio = v4l2_i2c_new_subdev(&btv->c.v4l2_dev,\r\n&btv->c.i2c_adap, "tvaudio", 0, tvaudio_addrs());\r\nif (btv->sd_tvaudio)\r\nreturn;\r\nno_audio:\r\npr_warn("%d: audio absent, no audio device found!\n", btv->c.nr);\r\n}\r\nvoid bttv_init_tuner(struct bttv *btv)\r\n{\r\nint addr = ADDR_UNSET;\r\nif (ADDR_UNSET != bttv_tvcards[btv->c.type].tuner_addr)\r\naddr = bttv_tvcards[btv->c.type].tuner_addr;\r\nif (btv->tuner_type != TUNER_ABSENT) {\r\nstruct tuner_setup tun_setup;\r\nif (btv->has_radio)\r\nv4l2_i2c_new_subdev(&btv->c.v4l2_dev,\r\n&btv->c.i2c_adap, "tuner",\r\n0, v4l2_i2c_tuner_addrs(ADDRS_RADIO));\r\nv4l2_i2c_new_subdev(&btv->c.v4l2_dev,\r\n&btv->c.i2c_adap, "tuner",\r\n0, v4l2_i2c_tuner_addrs(ADDRS_DEMOD));\r\nv4l2_i2c_new_subdev(&btv->c.v4l2_dev,\r\n&btv->c.i2c_adap, "tuner",\r\n0, v4l2_i2c_tuner_addrs(ADDRS_TV_WITH_DEMOD));\r\ntun_setup.mode_mask = T_ANALOG_TV;\r\ntun_setup.type = btv->tuner_type;\r\ntun_setup.addr = addr;\r\nif (btv->has_radio)\r\ntun_setup.mode_mask |= T_RADIO;\r\nbttv_call_all(btv, tuner, s_type_addr, &tun_setup);\r\n}\r\nif (btv->tda9887_conf) {\r\nstruct v4l2_priv_tun_config tda9887_cfg;\r\ntda9887_cfg.tuner = TUNER_TDA9887;\r\ntda9887_cfg.priv = &btv->tda9887_conf;\r\nbttv_call_all(btv, tuner, s_config, &tda9887_cfg);\r\n}\r\n}\r\nstatic void modtec_eeprom(struct bttv *btv)\r\n{\r\nif( strncmp(&(eeprom_data[0x1e]),"Temic 4066 FY5",14) ==0) {\r\nbtv->tuner_type=TUNER_TEMIC_4066FY5_PAL_I;\r\npr_info("%d: Modtec: Tuner autodetected by eeprom: %s\n",\r\nbtv->c.nr, &eeprom_data[0x1e]);\r\n} else if (strncmp(&(eeprom_data[0x1e]),"Alps TSBB5",10) ==0) {\r\nbtv->tuner_type=TUNER_ALPS_TSBB5_PAL_I;\r\npr_info("%d: Modtec: Tuner autodetected by eeprom: %s\n",\r\nbtv->c.nr, &eeprom_data[0x1e]);\r\n} else if (strncmp(&(eeprom_data[0x1e]),"Philips FM1246",14) ==0) {\r\nbtv->tuner_type=TUNER_PHILIPS_NTSC;\r\npr_info("%d: Modtec: Tuner autodetected by eeprom: %s\n",\r\nbtv->c.nr, &eeprom_data[0x1e]);\r\n} else {\r\npr_info("%d: Modtec: Unknown TunerString: %s\n",\r\nbtv->c.nr, &eeprom_data[0x1e]);\r\n}\r\n}\r\nstatic void hauppauge_eeprom(struct bttv *btv)\r\n{\r\nstruct tveeprom tv;\r\ntveeprom_hauppauge_analog(&btv->i2c_client, &tv, eeprom_data);\r\nbtv->tuner_type = tv.tuner_type;\r\nbtv->has_radio = tv.has_radio;\r\npr_info("%d: Hauppauge eeprom indicates model#%d\n",\r\nbtv->c.nr, tv.model);\r\nif(tv.model == 64900) {\r\npr_info("%d: Switching board type from %s to %s\n",\r\nbtv->c.nr,\r\nbttv_tvcards[btv->c.type].name,\r\nbttv_tvcards[BTTV_BOARD_HAUPPAUGE_IMPACTVCB].name);\r\nbtv->c.type = BTTV_BOARD_HAUPPAUGE_IMPACTVCB;\r\n}\r\nif (tv.model == 61334)\r\nbtv->radio_uses_msp_demodulator = 1;\r\n}\r\nstatic int terratec_active_radio_upgrade(struct bttv *btv)\r\n{\r\nint freq;\r\nbtv->has_radio = 1;\r\nbtv->has_matchbox = 1;\r\nbtv->mbox_we = 0x10;\r\nbtv->mbox_most = 0x20;\r\nbtv->mbox_clk = 0x08;\r\nbtv->mbox_data = 0x04;\r\nbtv->mbox_mask = 0x3c;\r\nbtv->mbox_iow = 1 << 8;\r\nbtv->mbox_ior = 1 << 9;\r\nbtv->mbox_csel = 1 << 10;\r\nfreq=88000/62.5;\r\ntea5757_write(btv, 5 * freq + 0x358);\r\nif (0x1ed8 == tea5757_read(btv)) {\r\npr_info("%d: Terratec Active Radio Upgrade found\n", btv->c.nr);\r\nbtv->has_radio = 1;\r\nbtv->has_saa6588 = 1;\r\nbtv->has_matchbox = 1;\r\n} else {\r\nbtv->has_radio = 0;\r\nbtv->has_matchbox = 0;\r\n}\r\nreturn 0;\r\n}\r\nstatic int pvr_altera_load(struct bttv *btv, const u8 *micro, u32 microlen)\r\n{\r\nu32 n;\r\nu8 bits;\r\nint i;\r\ngpio_inout(0xffffff,BTTV_ALT_DATA|BTTV_ALT_DCLK|BTTV_ALT_NCONFIG);\r\ngpio_write(0);\r\nudelay(PVR_GPIO_DELAY);\r\ngpio_write(BTTV_ALT_NCONFIG);\r\nudelay(PVR_GPIO_DELAY);\r\nfor (n = 0; n < microlen; n++) {\r\nbits = micro[n];\r\nfor (i = 0 ; i < 8 ; i++) {\r\ngpio_bits(BTTV_ALT_DCLK,0);\r\nif (bits & 0x01)\r\ngpio_bits(BTTV_ALT_DATA,BTTV_ALT_DATA);\r\nelse\r\ngpio_bits(BTTV_ALT_DATA,0);\r\ngpio_bits(BTTV_ALT_DCLK,BTTV_ALT_DCLK);\r\nbits >>= 1;\r\n}\r\n}\r\ngpio_bits(BTTV_ALT_DCLK,0);\r\nudelay(PVR_GPIO_DELAY);\r\nfor (i = 0 ; i < 30 ; i++) {\r\ngpio_bits(BTTV_ALT_DCLK,0);\r\ngpio_bits(BTTV_ALT_DCLK,BTTV_ALT_DCLK);\r\n}\r\ngpio_bits(BTTV_ALT_DCLK,0);\r\nreturn 0;\r\n}\r\nstatic int pvr_boot(struct bttv *btv)\r\n{\r\nconst struct firmware *fw_entry;\r\nint rc;\r\nrc = request_firmware(&fw_entry, "hcwamc.rbf", &btv->c.pci->dev);\r\nif (rc != 0) {\r\npr_warn("%d: no altera firmware [via hotplug]\n", btv->c.nr);\r\nreturn rc;\r\n}\r\nrc = pvr_altera_load(btv, fw_entry->data, fw_entry->size);\r\npr_info("%d: altera firmware upload %s\n",\r\nbtv->c.nr, (rc < 0) ? "failed" : "ok");\r\nrelease_firmware(fw_entry);\r\nreturn rc;\r\n}\r\nstatic void osprey_eeprom(struct bttv *btv, const u8 ee[256])\r\n{\r\nint i;\r\nu32 serial = 0;\r\nint cardid = -1;\r\nif (btv->c.type == BTTV_BOARD_UNKNOWN) {\r\nif (!strncmp(ee, "MMAC", 4)) {\r\nu8 checksum = 0;\r\nfor (i = 0; i < 21; i++)\r\nchecksum += ee[i];\r\nif (checksum != ee[21])\r\nreturn;\r\ncardid = BTTV_BOARD_OSPREY1x0_848;\r\nfor (i = 12; i < 21; i++)\r\nserial *= 10, serial += ee[i] - '0';\r\n}\r\n} else {\r\nunsigned short type;\r\nfor (i = 4*16; i < 8*16; i += 16) {\r\nu16 checksum = ip_compute_csum(ee + i, 16);\r\nif ((checksum&0xff) + (checksum>>8) == 0xff)\r\nbreak;\r\n}\r\nif (i >= 8*16)\r\nreturn;\r\nee += i;\r\ntype = get_unaligned_be16((__be16 *)(ee+4));\r\nswitch(type) {\r\ncase 0x0004:\r\ncardid = BTTV_BOARD_OSPREY1x0_848;\r\nbreak;\r\ncase 0x0005:\r\ncardid = BTTV_BOARD_OSPREY101_848;\r\nbreak;\r\ncase 0x0012:\r\ncase 0x0013:\r\ncardid = BTTV_BOARD_OSPREY1x0;\r\nbreak;\r\ncase 0x0014:\r\ncase 0x0015:\r\ncardid = BTTV_BOARD_OSPREY1x1;\r\nbreak;\r\ncase 0x0016:\r\ncase 0x0017:\r\ncase 0x0020:\r\ncardid = BTTV_BOARD_OSPREY1x1_SVID;\r\nbreak;\r\ncase 0x0018:\r\ncase 0x0019:\r\ncase 0x001E:\r\ncase 0x001F:\r\ncardid = BTTV_BOARD_OSPREY2xx;\r\nbreak;\r\ncase 0x001A:\r\ncase 0x001B:\r\ncardid = BTTV_BOARD_OSPREY2x0_SVID;\r\nbreak;\r\ncase 0x0040:\r\ncardid = BTTV_BOARD_OSPREY500;\r\nbreak;\r\ncase 0x0050:\r\ncase 0x0056:\r\ncardid = BTTV_BOARD_OSPREY540;\r\nbreak;\r\ncase 0x0060:\r\ncase 0x0070:\r\ncase 0x00A0:\r\ncardid = BTTV_BOARD_OSPREY2x0;\r\ngpio_inout(0xffffff,0x000303);\r\nbreak;\r\ncase 0x00D8:\r\ncardid = BTTV_BOARD_OSPREY440;\r\nbreak;\r\ndefault:\r\npr_info("%d: osprey eeprom: unknown card type 0x%04x\n",\r\nbtv->c.nr, type);\r\nbreak;\r\n}\r\nserial = get_unaligned_be32((__be32 *)(ee+6));\r\n}\r\npr_info("%d: osprey eeprom: card=%d '%s' serial=%u\n",\r\nbtv->c.nr, cardid,\r\ncardid > 0 ? bttv_tvcards[cardid].name : "Unknown", serial);\r\nif (cardid<0 || btv->c.type == cardid)\r\nreturn;\r\nif (card[btv->c.nr] < bttv_num_tvcards) {\r\npr_warn("%d: osprey eeprom: Not overriding user specified card type\n",\r\nbtv->c.nr);\r\n} else {\r\npr_info("%d: osprey eeprom: Changing card type from %d to %d\n",\r\nbtv->c.nr, btv->c.type, cardid);\r\nbtv->c.type = cardid;\r\n}\r\n}\r\nstatic void avermedia_eeprom(struct bttv *btv)\r\n{\r\nint tuner_make, tuner_tv_fm, tuner_format, tuner_type = 0;\r\ntuner_make = (eeprom_data[0x41] & 0x7);\r\ntuner_tv_fm = (eeprom_data[0x41] & 0x18) >> 3;\r\ntuner_format = (eeprom_data[0x42] & 0xf0) >> 4;\r\nbtv->has_remote = (eeprom_data[0x42] & 0x01);\r\nif (tuner_make == 0 || tuner_make == 2)\r\nif (tuner_format <= 0x0a)\r\ntuner_type = tuner_0_table[tuner_format];\r\nif (tuner_make == 1)\r\nif (tuner_format <= 9)\r\ntuner_type = tuner_1_table[tuner_format];\r\nif (tuner_make == 4)\r\nif (tuner_format == 0x09)\r\ntuner_type = TUNER_LG_NTSC_NEW_TAPC;\r\npr_info("%d: Avermedia eeprom[0x%02x%02x]: tuner=",\r\nbtv->c.nr, eeprom_data[0x41], eeprom_data[0x42]);\r\nif (tuner_type) {\r\nbtv->tuner_type = tuner_type;\r\npr_cont("%d", tuner_type);\r\n} else\r\npr_cont("Unknown type");\r\npr_cont(" radio:%s remote control:%s\n",\r\ntuner_tv_fm ? "yes" : "no",\r\nbtv->has_remote ? "yes" : "no");\r\n}\r\nu32 bttv_tda9880_setnorm(struct bttv *btv, u32 gpiobits)\r\n{\r\nif (btv->audio == TVAUDIO_INPUT_TUNER) {\r\nif (bttv_tvnorms[btv->tvnorm].v4l2_id & V4L2_STD_MN)\r\ngpiobits |= 0x10000;\r\nelse\r\ngpiobits &= ~0x10000;\r\n}\r\ngpio_bits(bttv_tvcards[btv->c.type].gpiomask, gpiobits);\r\nreturn gpiobits;\r\n}\r\nstatic void boot_msp34xx(struct bttv *btv, int pin)\r\n{\r\nint mask = (1 << pin);\r\ngpio_inout(mask,mask);\r\ngpio_bits(mask,0);\r\nmdelay(2);\r\nudelay(500);\r\ngpio_bits(mask,mask);\r\nif (bttv_gpio)\r\nbttv_gpio_tracking(btv,"msp34xx");\r\nif (bttv_verbose)\r\npr_info("%d: Hauppauge/Voodoo msp34xx: reset line init [%d]\n",\r\nbtv->c.nr, pin);\r\n}\r\nstatic void init_PXC200(struct bttv *btv)\r\n{\r\nstatic int vals[] = { 0x08, 0x09, 0x0a, 0x0b, 0x0d, 0x0d, 0x01, 0x02,\r\n0x03, 0x04, 0x05, 0x06, 0x00 };\r\nunsigned int i;\r\nint tmp;\r\nu32 val;\r\ngpio_inout(0xffffff, (1<<13));\r\ngpio_write(0);\r\nudelay(3);\r\ngpio_write(1<<13);\r\ngpio_bits(0xffffff, 0);\r\nif (bttv_gpio)\r\nbttv_gpio_tracking(btv,"pxc200");\r\nbtwrite(BT848_ADC_RESERVED|BT848_ADC_AGC_EN, BT848_ADC);\r\npr_info("Setting DAC reference voltage level ...\n");\r\nbttv_I2CWrite(btv,0x5E,0,0x80,1);\r\npr_info("Initialising 12C508 PIC chip ...\n");\r\nval = btread(BT848_GPIO_DMA_CTL);\r\nval |= BT848_GPIO_DMA_CTL_GPCLKMODE;\r\nbtwrite(val, BT848_GPIO_DMA_CTL);\r\ngpio_inout(0xffffff,(1<<2));\r\ngpio_write(0);\r\nudelay(10);\r\ngpio_write(1<<2);\r\nfor (i = 0; i < ARRAY_SIZE(vals); i++) {\r\ntmp=bttv_I2CWrite(btv,0x1E,0,vals[i],1);\r\nif (tmp != -1) {\r\npr_info("I2C Write(%2.2x) = %i\nI2C Read () = %2.2x\n\n",\r\nvals[i],tmp,bttv_I2CRead(btv,0x1F,NULL));\r\n}\r\n}\r\npr_info("PXC200 Initialised\n");\r\n}\r\nstatic void\r\ninit_RTV24 (struct bttv *btv)\r\n{\r\nuint32_t dataRead = 0;\r\nlong watchdog_value = 0x0E;\r\npr_info("%d: Adlink RTV-24 initialisation in progress ...\n",\r\nbtv->c.nr);\r\nbtwrite (0x00c3feff, BT848_GPIO_OUT_EN);\r\nbtwrite (0 + watchdog_value, BT848_GPIO_DATA);\r\nmsleep (1);\r\nbtwrite (0x10 + watchdog_value, BT848_GPIO_DATA);\r\nmsleep (10);\r\nbtwrite (0 + watchdog_value, BT848_GPIO_DATA);\r\ndataRead = btread (BT848_GPIO_DATA);\r\nif ((((dataRead >> 18) & 0x01) != 0) || (((dataRead >> 19) & 0x01) != 1)) {\r\npr_info("%d: Adlink RTV-24 initialisation(1) ERROR_CPLD_Check_Failed (read %d)\n",\r\nbtv->c.nr, dataRead);\r\n}\r\nbtwrite (0x4400 + watchdog_value, BT848_GPIO_DATA);\r\nmsleep (10);\r\nbtwrite (0x4410 + watchdog_value, BT848_GPIO_DATA);\r\nmsleep (1);\r\nbtwrite (watchdog_value, BT848_GPIO_DATA);\r\nmsleep (1);\r\ndataRead = btread (BT848_GPIO_DATA);\r\nif ((((dataRead >> 18) & 0x01) != 0) || (((dataRead >> 19) & 0x01) != 0)) {\r\npr_info("%d: Adlink RTV-24 initialisation(2) ERROR_CPLD_Check_Failed (read %d)\n",\r\nbtv->c.nr, dataRead);\r\nreturn;\r\n}\r\npr_info("%d: Adlink RTV-24 initialisation complete\n", btv->c.nr);\r\n}\r\nstatic void bus_low(struct bttv *btv, int bit)\r\n{\r\nif (btv->mbox_ior) {\r\ngpio_bits(btv->mbox_ior | btv->mbox_iow | btv->mbox_csel,\r\nbtv->mbox_ior | btv->mbox_iow | btv->mbox_csel);\r\nudelay(5);\r\n}\r\ngpio_bits(bit,0);\r\nudelay(5);\r\nif (btv->mbox_ior) {\r\ngpio_bits(btv->mbox_iow | btv->mbox_csel, 0);\r\nudelay(5);\r\n}\r\n}\r\nstatic void bus_high(struct bttv *btv, int bit)\r\n{\r\nif (btv->mbox_ior) {\r\ngpio_bits(btv->mbox_ior | btv->mbox_iow | btv->mbox_csel,\r\nbtv->mbox_ior | btv->mbox_iow | btv->mbox_csel);\r\nudelay(5);\r\n}\r\ngpio_bits(bit,bit);\r\nudelay(5);\r\nif (btv->mbox_ior) {\r\ngpio_bits(btv->mbox_iow | btv->mbox_csel, 0);\r\nudelay(5);\r\n}\r\n}\r\nstatic int bus_in(struct bttv *btv, int bit)\r\n{\r\nif (btv->mbox_ior) {\r\ngpio_bits(btv->mbox_ior | btv->mbox_iow | btv->mbox_csel,\r\nbtv->mbox_ior | btv->mbox_iow | btv->mbox_csel);\r\nudelay(5);\r\ngpio_bits(btv->mbox_iow | btv->mbox_csel, 0);\r\nudelay(5);\r\n}\r\nreturn gpio_read() & (bit);\r\n}\r\nstatic int tea5757_read(struct bttv *btv)\r\n{\r\nunsigned long timeout;\r\nint value = 0;\r\nint i;\r\ngpio_inout(btv->mbox_mask, btv->mbox_clk | btv->mbox_we);\r\nif (btv->mbox_ior) {\r\ngpio_bits(btv->mbox_ior | btv->mbox_iow | btv->mbox_csel,\r\nbtv->mbox_ior | btv->mbox_iow | btv->mbox_csel);\r\nudelay(5);\r\n}\r\nif (bttv_gpio)\r\nbttv_gpio_tracking(btv,"tea5757 read");\r\nbus_low(btv,btv->mbox_we);\r\nbus_low(btv,btv->mbox_clk);\r\nudelay(10);\r\ntimeout= jiffies + msecs_to_jiffies(1000);\r\nwhile (bus_in(btv,btv->mbox_data) && time_before(jiffies, timeout))\r\nschedule();\r\nif (bus_in(btv,btv->mbox_data)) {\r\npr_warn("%d: tea5757: read timeout\n", btv->c.nr);\r\nreturn -1;\r\n}\r\ndprintk("%d: tea5757:", btv->c.nr);\r\nfor (i = 0; i < 24; i++) {\r\nudelay(5);\r\nbus_high(btv,btv->mbox_clk);\r\nudelay(5);\r\ndprintk_cont("%c",\r\nbus_in(btv, btv->mbox_most) == 0 ? 'T' : '-');\r\nbus_low(btv,btv->mbox_clk);\r\nvalue <<= 1;\r\nvalue |= (bus_in(btv,btv->mbox_data) == 0)?0:1;\r\ndprintk_cont("%c",\r\nbus_in(btv, btv->mbox_most) == 0 ? 'S' : 'M');\r\n}\r\ndprintk_cont("\n");\r\ndprintk("%d: tea5757: read 0x%X\n", btv->c.nr, value);\r\nreturn value;\r\n}\r\nstatic int tea5757_write(struct bttv *btv, int value)\r\n{\r\nint i;\r\nint reg = value;\r\ngpio_inout(btv->mbox_mask, btv->mbox_clk | btv->mbox_we | btv->mbox_data);\r\nif (btv->mbox_ior) {\r\ngpio_bits(btv->mbox_ior | btv->mbox_iow | btv->mbox_csel,\r\nbtv->mbox_ior | btv->mbox_iow | btv->mbox_csel);\r\nudelay(5);\r\n}\r\nif (bttv_gpio)\r\nbttv_gpio_tracking(btv,"tea5757 write");\r\ndprintk("%d: tea5757: write 0x%X\n", btv->c.nr, value);\r\nbus_low(btv,btv->mbox_clk);\r\nbus_high(btv,btv->mbox_we);\r\nfor (i = 0; i < 25; i++) {\r\nif (reg & 0x1000000)\r\nbus_high(btv,btv->mbox_data);\r\nelse\r\nbus_low(btv,btv->mbox_data);\r\nreg <<= 1;\r\nbus_high(btv,btv->mbox_clk);\r\nudelay(10);\r\nbus_low(btv,btv->mbox_clk);\r\nudelay(10);\r\n}\r\nbus_low(btv,btv->mbox_we);\r\nreturn 0;\r\n}\r\nvoid tea5757_set_freq(struct bttv *btv, unsigned short freq)\r\n{\r\ndprintk("tea5757_set_freq %d\n",freq);\r\ntea5757_write(btv, 5 * freq + 0x358);\r\n}\r\nstatic void rv605_muxsel(struct bttv *btv, unsigned int input)\r\n{\r\nstatic const u8 muxgpio[] = { 0x3, 0x1, 0x2, 0x4, 0xf, 0x7, 0xe, 0x0,\r\n0xd, 0xb, 0xc, 0x6, 0x9, 0x5, 0x8, 0xa };\r\ngpio_bits(0x07f, muxgpio[input]);\r\ngpio_bits(0x200,0x200);\r\nmdelay(1);\r\ngpio_bits(0x200,0x000);\r\nmdelay(1);\r\ngpio_bits(0x480,0x480);\r\nmdelay(1);\r\ngpio_bits(0x480,0x080);\r\nmdelay(1);\r\n}\r\nstatic void tibetCS16_muxsel(struct bttv *btv, unsigned int input)\r\n{\r\ngpio_bits(0x0f0000, input << 16);\r\n}\r\nstatic void tibetCS16_init(struct bttv *btv)\r\n{\r\ngpio_inout(0xffffff, 0x0f7fff);\r\ngpio_write(0x0f7fff);\r\n}\r\nstatic void kodicom4400r_write(struct bttv *btv,\r\nunsigned char xaddr,\r\nunsigned char yaddr,\r\nunsigned char data) {\r\nunsigned int udata;\r\nudata = (data << 7) | ((yaddr&3) << 4) | (xaddr&0xf);\r\ngpio_bits(0x1ff, udata);\r\ngpio_bits(0x1ff, udata | (1 << 8));\r\ngpio_bits(0x1ff, udata);\r\n}\r\nstatic void kodicom4400r_muxsel(struct bttv *btv, unsigned int input)\r\n{\r\nchar *sw_status;\r\nint xaddr, yaddr;\r\nstruct bttv *mctlr;\r\nstatic unsigned char map[4] = {3, 0, 2, 1};\r\nmctlr = master[btv->c.nr];\r\nif (mctlr == NULL) {\r\nreturn;\r\n}\r\nyaddr = (btv->c.nr - mctlr->c.nr + 1) & 3;\r\nyaddr = map[yaddr];\r\nsw_status = (char *)(&mctlr->mbox_we);\r\nxaddr = input & 0xf;\r\nif (sw_status[yaddr] != xaddr)\r\n{\r\nkodicom4400r_write(mctlr, sw_status[yaddr], yaddr, 0);\r\nsw_status[yaddr] = xaddr;\r\nkodicom4400r_write(mctlr, xaddr, yaddr, 1);\r\n}\r\n}\r\nstatic void kodicom4400r_init(struct bttv *btv)\r\n{\r\nchar *sw_status = (char *)(&btv->mbox_we);\r\nint ix;\r\ngpio_inout(0x0003ff, 0x0003ff);\r\ngpio_write(1 << 9);\r\ngpio_write(0);\r\nfor (ix = 0; ix < 4; ix++) {\r\nsw_status[ix] = ix;\r\nkodicom4400r_write(btv, ix, ix, 1);\r\n}\r\nif ((btv->c.nr<1) || (btv->c.nr>BTTV_MAX-3))\r\nreturn;\r\nmaster[btv->c.nr-1] = btv;\r\nmaster[btv->c.nr] = btv;\r\nmaster[btv->c.nr+1] = btv;\r\nmaster[btv->c.nr+2] = btv;\r\n}\r\nstatic void xguard_muxsel(struct bttv *btv, unsigned int input)\r\n{\r\nstatic const int masks[] = {\r\nENB0, ENB0|IN00, ENB0|IN10, ENB0|IN00|IN10,\r\nENA0, ENA0|IN00, ENA0|IN10, ENA0|IN00|IN10,\r\nENB1, ENB1|IN01, ENB1|IN11, ENB1|IN01|IN11,\r\nENA1, ENA1|IN01, ENA1|IN11, ENA1|IN01|IN11,\r\n};\r\ngpio_write(masks[input%16]);\r\n}\r\nstatic void picolo_tetra_init(struct bttv *btv)\r\n{\r\nbtwrite (0x08<<16,BT848_GPIO_DATA);\r\nbtwrite (0x04<<16,BT848_GPIO_DATA);\r\n}\r\nstatic void picolo_tetra_muxsel (struct bttv* btv, unsigned int input)\r\n{\r\ndprintk("%d : picolo_tetra_muxsel => input = %d\n", btv->c.nr, input);\r\nbtwrite (input<<20,BT848_GPIO_DATA);\r\n}\r\nstatic void ivc120_muxsel(struct bttv *btv, unsigned int input)\r\n{\r\nint key = input % 4;\r\nint matrix = input / 4;\r\ndprintk("%d: ivc120_muxsel: Input - %02d | TDA - %02d | In - %02d\n",\r\nbtv->c.nr, input, matrix, key);\r\nbttv_I2CWrite(btv, I2C_TDA8540_ALT3, 0x00,\r\n((matrix == 3) ? (key | key << 2) : 0x00), 1);\r\nbttv_I2CWrite(btv, I2C_TDA8540_ALT4, 0x00,\r\n((matrix == 0) ? (key | key << 2) : 0x00), 1);\r\nbttv_I2CWrite(btv, I2C_TDA8540_ALT5, 0x00,\r\n((matrix == 1) ? (key | key << 2) : 0x00), 1);\r\nbttv_I2CWrite(btv, I2C_TDA8540_ALT6, 0x00,\r\n((matrix == 2) ? (key | key << 2) : 0x00), 1);\r\nbttv_I2CWrite(btv, I2C_TDA8540_ALT3, 0x02,\r\n((matrix == 3) ? 0x03 : 0x00), 1);\r\nbttv_I2CWrite(btv, I2C_TDA8540_ALT4, 0x02,\r\n((matrix == 0) ? 0x03 : 0x00), 1);\r\nbttv_I2CWrite(btv, I2C_TDA8540_ALT5, 0x02,\r\n((matrix == 1) ? 0x03 : 0x00), 1);\r\nbttv_I2CWrite(btv, I2C_TDA8540_ALT6, 0x02,\r\n((matrix == 2) ? 0x03 : 0x00), 1);\r\n}\r\nstatic void PXC200_muxsel(struct bttv *btv, unsigned int input)\r\n{\r\nint rc;\r\nlong mux;\r\nint bitmask;\r\nunsigned char buf[2];\r\nbuf[0]=0;\r\nbuf[1]=0;\r\nrc=bttv_I2CWrite(btv,(PX_I2C_PIC<<1),buf[0],buf[1],1);\r\nif (rc) {\r\npr_debug("%d: PXC200_muxsel: pic cfg write failed:%d\n",\r\nbtv->c.nr, rc);\r\nreturn;\r\n}\r\nrc=bttv_I2CRead(btv,(PX_I2C_PIC<<1),NULL);\r\nif (!(rc & PX_CFG_PXC200F)) {\r\npr_debug("%d: PXC200_muxsel: not PXC200F rc:%d\n",\r\nbtv->c.nr, rc);\r\nreturn;\r\n}\r\nmux = input;\r\nbitmask=0x302;\r\nif (btv->cardid == PX_PXC200A_CARDID) {\r\nbitmask ^= 0x180;\r\nbitmask |= 7<<4;\r\n}\r\nbtwrite(bitmask, BT848_GPIO_OUT_EN);\r\nbitmask = btread(BT848_GPIO_DATA);\r\nif (btv->cardid == PX_PXC200A_CARDID)\r\nbitmask = (bitmask & ~0x280) | ((mux & 2) << 8) | ((mux & 1) << 7);\r\nelse\r\nbitmask = (bitmask & ~0x300) | ((mux & 3) << 8);\r\nbtwrite(bitmask,BT848_GPIO_DATA);\r\nif (btv->cardid == PX_PXC200A_CARDID)\r\nbtaor(2<<5, ~BT848_IFORM_MUXSEL, BT848_IFORM);\r\nelse\r\nbtand(~BT848_IFORM_MUXSEL,BT848_IFORM);\r\npr_debug("%d: setting input channel to:%d\n", btv->c.nr, (int)mux);\r\n}\r\nstatic void phytec_muxsel(struct bttv *btv, unsigned int input)\r\n{\r\nunsigned int mux = input % 4;\r\nif (input == btv->svhs)\r\nmux = 0;\r\ngpio_bits(0x3, mux);\r\n}\r\nstatic void gv800s_write(struct bttv *btv,\r\nunsigned char xaddr,\r\nunsigned char yaddr,\r\nunsigned char data) {\r\nconst u32 ADDRESS = ((xaddr&0xf) | (yaddr&3)<<4);\r\nconst u32 CSELECT = 1<<16;\r\nconst u32 STROBE = 1<<17;\r\nconst u32 DATA = data<<18;\r\ngpio_bits(0x1007f, ADDRESS | CSELECT);\r\ngpio_bits(0x20000, STROBE);\r\ngpio_bits(0x40000, DATA);\r\ngpio_bits(0x20000, ~STROBE);\r\n}\r\nstatic void gv800s_muxsel(struct bttv *btv, unsigned int input)\r\n{\r\nstruct bttv *mctlr;\r\nchar *sw_status;\r\nint xaddr, yaddr;\r\nstatic unsigned int map[4][4] = { { 0x0, 0x4, 0xa, 0x6 },\r\n{ 0x1, 0x5, 0xb, 0x7 },\r\n{ 0x2, 0x8, 0xc, 0xe },\r\n{ 0x3, 0x9, 0xd, 0xf } };\r\ninput = input%4;\r\nmctlr = master[btv->c.nr];\r\nif (mctlr == NULL) {\r\nreturn;\r\n}\r\nyaddr = (btv->c.nr - mctlr->c.nr) & 3;\r\nsw_status = (char *)(&mctlr->mbox_we);\r\nxaddr = map[yaddr][input] & 0xf;\r\nif (sw_status[yaddr] != xaddr) {\r\ngv800s_write(mctlr, sw_status[yaddr], yaddr, 0);\r\nsw_status[yaddr] = xaddr;\r\ngv800s_write(mctlr, xaddr, yaddr, 1);\r\n}\r\n}\r\nstatic void gv800s_init(struct bttv *btv)\r\n{\r\nchar *sw_status = (char *)(&btv->mbox_we);\r\nint ix;\r\ngpio_inout(0xf107f, 0xf107f);\r\ngpio_write(1<<19);\r\ngpio_write(0);\r\nfor (ix = 0; ix < 4; ix++) {\r\nsw_status[ix] = ix;\r\ngv800s_write(btv, ix, ix, 1);\r\n}\r\nbttv_I2CWrite(btv, 0x18, 0x5, 0x90, 1);\r\nif (btv->c.nr > BTTV_MAX-4)\r\nreturn;\r\nmaster[btv->c.nr] = btv;\r\nmaster[btv->c.nr+1] = btv;\r\nmaster[btv->c.nr+2] = btv;\r\nmaster[btv->c.nr+3] = btv;\r\n}\r\nvoid __init bttv_check_chipset(void)\r\n{\r\nint pcipci_fail = 0;\r\nstruct pci_dev *dev = NULL;\r\nif (pci_pci_problems & (PCIPCI_FAIL|PCIAGP_FAIL))\r\npcipci_fail = 1;\r\nif (pci_pci_problems & (PCIPCI_TRITON|PCIPCI_NATOMA|PCIPCI_VIAETBF))\r\ntriton1 = 1;\r\nif (pci_pci_problems & PCIPCI_VSFX)\r\nvsfx = 1;\r\n#ifdef PCIPCI_ALIMAGIK\r\nif (pci_pci_problems & PCIPCI_ALIMAGIK)\r\nlatency = 0x0A;\r\n#endif\r\nif (triton1)\r\npr_info("Host bridge needs ETBF enabled\n");\r\nif (vsfx)\r\npr_info("Host bridge needs VSFX enabled\n");\r\nif (pcipci_fail) {\r\npr_info("bttv and your chipset may not work together\n");\r\nif (!no_overlay) {\r\npr_info("overlay will be disabled\n");\r\nno_overlay = 1;\r\n} else {\r\npr_info("overlay forced. Use this option at your own risk.\n");\r\n}\r\n}\r\nif (UNSET != latency)\r\npr_info("pci latency fixup [%d]\n", latency);\r\nwhile ((dev = pci_get_device(PCI_VENDOR_ID_INTEL,\r\nPCI_DEVICE_ID_INTEL_82441, dev))) {\r\nunsigned char b;\r\npci_read_config_byte(dev, 0x53, &b);\r\nif (bttv_debug)\r\npr_info("Host bridge: 82441FX Natoma, bufcon=0x%02x\n",\r\nb);\r\n}\r\n}\r\nint bttv_handle_chipset(struct bttv *btv)\r\n{\r\nunsigned char command;\r\nif (!triton1 && !vsfx && UNSET == latency)\r\nreturn 0;\r\nif (bttv_verbose) {\r\nif (triton1)\r\npr_info("%d: enabling ETBF (430FX/VP3 compatibility)\n",\r\nbtv->c.nr);\r\nif (vsfx && btv->id >= 878)\r\npr_info("%d: enabling VSFX\n", btv->c.nr);\r\nif (UNSET != latency)\r\npr_info("%d: setting pci timer to %d\n",\r\nbtv->c.nr, latency);\r\n}\r\nif (btv->id < 878) {\r\nif (triton1)\r\nbtv->triton1 = BT848_INT_ETBF;\r\n} else {\r\npci_read_config_byte(btv->c.pci, BT878_DEVCTRL, &command);\r\nif (triton1)\r\ncommand |= BT878_EN_TBFX;\r\nif (vsfx)\r\ncommand |= BT878_EN_VSFX;\r\npci_write_config_byte(btv->c.pci, BT878_DEVCTRL, command);\r\n}\r\nif (UNSET != latency)\r\npci_write_config_byte(btv->c.pci, PCI_LATENCY_TIMER, latency);\r\nreturn 0;\r\n}
