static void vr_nor_destroy_partitions(struct vr_nor_mtd *p)\r\n{\r\nmtd_device_unregister(p->info);\r\n}\r\nstatic int vr_nor_init_partitions(struct vr_nor_mtd *p)\r\n{\r\nreturn mtd_device_parse_register(p->info, NULL, NULL, NULL, 0);\r\n}\r\nstatic void vr_nor_destroy_mtd_setup(struct vr_nor_mtd *p)\r\n{\r\nmap_destroy(p->info);\r\n}\r\nstatic int vr_nor_mtd_setup(struct vr_nor_mtd *p)\r\n{\r\nstatic const char *probe_types[] =\r\n{ "cfi_probe", "jedec_probe", NULL };\r\nconst char **type;\r\nfor (type = probe_types; !p->info && *type; type++)\r\np->info = do_map_probe(*type, &p->map);\r\nif (!p->info)\r\nreturn -ENODEV;\r\np->info->owner = THIS_MODULE;\r\nreturn 0;\r\n}\r\nstatic void vr_nor_destroy_maps(struct vr_nor_mtd *p)\r\n{\r\nunsigned int exp_timing_cs0;\r\nexp_timing_cs0 = readl(p->csr_base + EXP_TIMING_CS0);\r\nexp_timing_cs0 &= ~TIMING_WR_EN;\r\nwritel(exp_timing_cs0, p->csr_base + EXP_TIMING_CS0);\r\niounmap(p->map.virt);\r\niounmap(p->csr_base);\r\n}\r\nstatic int vr_nor_init_maps(struct vr_nor_mtd *p)\r\n{\r\nunsigned long csr_phys, csr_len;\r\nunsigned long win_phys, win_len;\r\nunsigned int exp_timing_cs0;\r\nint err;\r\ncsr_phys = pci_resource_start(p->dev, EXP_CSR_MBAR);\r\ncsr_len = pci_resource_len(p->dev, EXP_CSR_MBAR);\r\nwin_phys = pci_resource_start(p->dev, EXP_WIN_MBAR);\r\nwin_len = pci_resource_len(p->dev, EXP_WIN_MBAR);\r\nif (!csr_phys || !csr_len || !win_phys || !win_len)\r\nreturn -ENODEV;\r\nif (win_len < (CS0_START + CS0_SIZE))\r\nreturn -ENXIO;\r\np->csr_base = ioremap_nocache(csr_phys, csr_len);\r\nif (!p->csr_base)\r\nreturn -ENOMEM;\r\nexp_timing_cs0 = readl(p->csr_base + EXP_TIMING_CS0);\r\nif (!(exp_timing_cs0 & TIMING_CS_EN)) {\r\ndev_warn(&p->dev->dev, "Expansion Bus Chip Select 0 "\r\n"is disabled.\n");\r\nerr = -ENODEV;\r\ngoto release;\r\n}\r\nif ((exp_timing_cs0 & TIMING_MASK) == TIMING_MASK) {\r\ndev_warn(&p->dev->dev, "Expansion Bus Chip Select 0 "\r\n"is configured for maximally slow access times.\n");\r\n}\r\np->map.name = DRV_NAME;\r\np->map.bankwidth = (exp_timing_cs0 & TIMING_BYTE_EN) ? 1 : 2;\r\np->map.phys = win_phys + CS0_START;\r\np->map.size = CS0_SIZE;\r\np->map.virt = ioremap_nocache(p->map.phys, p->map.size);\r\nif (!p->map.virt) {\r\nerr = -ENOMEM;\r\ngoto release;\r\n}\r\nsimple_map_init(&p->map);\r\nexp_timing_cs0 |= TIMING_BOOT_ACCEL_DIS | TIMING_WR_EN;\r\nwritel(exp_timing_cs0, p->csr_base + EXP_TIMING_CS0);\r\nreturn 0;\r\nrelease:\r\niounmap(p->csr_base);\r\nreturn err;\r\n}\r\nstatic void vr_nor_pci_remove(struct pci_dev *dev)\r\n{\r\nstruct vr_nor_mtd *p = pci_get_drvdata(dev);\r\npci_set_drvdata(dev, NULL);\r\nvr_nor_destroy_partitions(p);\r\nvr_nor_destroy_mtd_setup(p);\r\nvr_nor_destroy_maps(p);\r\nkfree(p);\r\npci_release_regions(dev);\r\npci_disable_device(dev);\r\n}\r\nstatic int vr_nor_pci_probe(struct pci_dev *dev, const struct pci_device_id *id)\r\n{\r\nstruct vr_nor_mtd *p = NULL;\r\nunsigned int exp_timing_cs0;\r\nint err;\r\nerr = pci_enable_device(dev);\r\nif (err)\r\ngoto out;\r\nerr = pci_request_regions(dev, DRV_NAME);\r\nif (err)\r\ngoto disable_dev;\r\np = kzalloc(sizeof(*p), GFP_KERNEL);\r\nerr = -ENOMEM;\r\nif (!p)\r\ngoto release;\r\np->dev = dev;\r\nerr = vr_nor_init_maps(p);\r\nif (err)\r\ngoto release;\r\nerr = vr_nor_mtd_setup(p);\r\nif (err)\r\ngoto destroy_maps;\r\nerr = vr_nor_init_partitions(p);\r\nif (err)\r\ngoto destroy_mtd_setup;\r\npci_set_drvdata(dev, p);\r\nreturn 0;\r\ndestroy_mtd_setup:\r\nmap_destroy(p->info);\r\ndestroy_maps:\r\nexp_timing_cs0 = readl(p->csr_base + EXP_TIMING_CS0);\r\nexp_timing_cs0 &= ~TIMING_WR_EN;\r\nwritel(exp_timing_cs0, p->csr_base + EXP_TIMING_CS0);\r\niounmap(p->map.virt);\r\niounmap(p->csr_base);\r\nrelease:\r\nkfree(p);\r\npci_release_regions(dev);\r\ndisable_dev:\r\npci_disable_device(dev);\r\nout:\r\nreturn err;\r\n}
