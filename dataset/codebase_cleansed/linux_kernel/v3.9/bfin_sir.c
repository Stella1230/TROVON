static void turnaround_delay(unsigned long last_jif, int mtt)\r\n{\r\nlong ticks;\r\nmtt = mtt < 10000 ? 10000 : mtt;\r\nticks = 1 + mtt / (USEC_PER_SEC / HZ);\r\nschedule_timeout_uninterruptible(ticks);\r\n}\r\nstatic void bfin_sir_init_ports(struct bfin_sir_port *sp, struct platform_device *pdev)\r\n{\r\nint i;\r\nstruct resource *res;\r\nfor (i = 0; i < pdev->num_resources; i++) {\r\nres = &pdev->resource[i];\r\nswitch (res->flags) {\r\ncase IORESOURCE_MEM:\r\nsp->membase = (void __iomem *)res->start;\r\nbreak;\r\ncase IORESOURCE_IRQ:\r\nsp->irq = res->start;\r\nbreak;\r\ncase IORESOURCE_DMA:\r\nsp->rx_dma_channel = res->start;\r\nsp->tx_dma_channel = res->end;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nsp->clk = get_sclk();\r\n#ifdef CONFIG_SIR_BFIN_DMA\r\nsp->tx_done = 1;\r\ninit_timer(&(sp->rx_dma_timer));\r\n#endif\r\n}\r\nstatic void bfin_sir_stop_tx(struct bfin_sir_port *port)\r\n{\r\n#ifdef CONFIG_SIR_BFIN_DMA\r\ndisable_dma(port->tx_dma_channel);\r\n#endif\r\nwhile (!(UART_GET_LSR(port) & THRE)) {\r\ncpu_relax();\r\ncontinue;\r\n}\r\nUART_CLEAR_IER(port, ETBEI);\r\n}\r\nstatic void bfin_sir_enable_tx(struct bfin_sir_port *port)\r\n{\r\nUART_SET_IER(port, ETBEI);\r\n}\r\nstatic void bfin_sir_stop_rx(struct bfin_sir_port *port)\r\n{\r\nUART_CLEAR_IER(port, ERBFI);\r\n}\r\nstatic void bfin_sir_enable_rx(struct bfin_sir_port *port)\r\n{\r\nUART_SET_IER(port, ERBFI);\r\n}\r\nstatic int bfin_sir_set_speed(struct bfin_sir_port *port, int speed)\r\n{\r\nint ret = -EINVAL;\r\nunsigned int quot;\r\nunsigned short val, lsr, lcr;\r\nstatic int utime;\r\nint count = 10;\r\nlcr = WLS(8);\r\nswitch (speed) {\r\ncase 9600:\r\ncase 19200:\r\ncase 38400:\r\ncase 57600:\r\ncase 115200:\r\nquot = (port->clk + (8 * speed)) / (16 * speed);\r\ndo {\r\nudelay(utime);\r\nlsr = UART_GET_LSR(port);\r\n} while (!(lsr & TEMT) && count--);\r\nutime = 1000000 / speed + 1;\r\nval = UART_GET_GCTL(port);\r\nval &= ~UCEN;\r\nUART_PUT_GCTL(port, val);\r\nUART_SET_DLAB(port);\r\nSSYNC();\r\nUART_PUT_DLL(port, quot & 0xFF);\r\nUART_PUT_DLH(port, (quot >> 8) & 0xFF);\r\nSSYNC();\r\nUART_CLEAR_DLAB(port);\r\nSSYNC();\r\nUART_PUT_LCR(port, lcr);\r\nval = UART_GET_GCTL(port);\r\nval |= UCEN;\r\nUART_PUT_GCTL(port, val);\r\nret = 0;\r\nbreak;\r\ndefault:\r\nprintk(KERN_WARNING "bfin_sir: Invalid speed %d\n", speed);\r\nbreak;\r\n}\r\nval = UART_GET_GCTL(port);\r\nval |= UMOD_IRDA | RPOLC;\r\nUART_PUT_GCTL(port, val);\r\nreturn ret;\r\n}\r\nstatic int bfin_sir_is_receiving(struct net_device *dev)\r\n{\r\nstruct bfin_sir_self *self = netdev_priv(dev);\r\nstruct bfin_sir_port *port = self->sir_port;\r\nif (!(UART_GET_IER(port) & ERBFI))\r\nreturn 0;\r\nreturn self->rx_buff.state != OUTSIDE_FRAME;\r\n}\r\nstatic void bfin_sir_tx_chars(struct net_device *dev)\r\n{\r\nunsigned int chr;\r\nstruct bfin_sir_self *self = netdev_priv(dev);\r\nstruct bfin_sir_port *port = self->sir_port;\r\nif (self->tx_buff.len != 0) {\r\nchr = *(self->tx_buff.data);\r\nUART_PUT_CHAR(port, chr);\r\nself->tx_buff.data++;\r\nself->tx_buff.len--;\r\n} else {\r\nself->stats.tx_packets++;\r\nself->stats.tx_bytes += self->tx_buff.data - self->tx_buff.head;\r\nif (self->newspeed) {\r\nbfin_sir_set_speed(port, self->newspeed);\r\nself->speed = self->newspeed;\r\nself->newspeed = 0;\r\n}\r\nbfin_sir_stop_tx(port);\r\nbfin_sir_enable_rx(port);\r\nnetif_wake_queue(dev);\r\n}\r\n}\r\nstatic void bfin_sir_rx_chars(struct net_device *dev)\r\n{\r\nstruct bfin_sir_self *self = netdev_priv(dev);\r\nstruct bfin_sir_port *port = self->sir_port;\r\nunsigned char ch;\r\nUART_CLEAR_LSR(port);\r\nch = UART_GET_CHAR(port);\r\nasync_unwrap_char(dev, &self->stats, &self->rx_buff, ch);\r\ndev->last_rx = jiffies;\r\n}\r\nstatic irqreturn_t bfin_sir_rx_int(int irq, void *dev_id)\r\n{\r\nstruct net_device *dev = dev_id;\r\nstruct bfin_sir_self *self = netdev_priv(dev);\r\nstruct bfin_sir_port *port = self->sir_port;\r\nspin_lock(&self->lock);\r\nwhile ((UART_GET_LSR(port) & DR))\r\nbfin_sir_rx_chars(dev);\r\nspin_unlock(&self->lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t bfin_sir_tx_int(int irq, void *dev_id)\r\n{\r\nstruct net_device *dev = dev_id;\r\nstruct bfin_sir_self *self = netdev_priv(dev);\r\nstruct bfin_sir_port *port = self->sir_port;\r\nspin_lock(&self->lock);\r\nif (UART_GET_LSR(port) & THRE)\r\nbfin_sir_tx_chars(dev);\r\nspin_unlock(&self->lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void bfin_sir_dma_tx_chars(struct net_device *dev)\r\n{\r\nstruct bfin_sir_self *self = netdev_priv(dev);\r\nstruct bfin_sir_port *port = self->sir_port;\r\nif (!port->tx_done)\r\nreturn;\r\nport->tx_done = 0;\r\nif (self->tx_buff.len == 0) {\r\nself->stats.tx_packets++;\r\nif (self->newspeed) {\r\nbfin_sir_set_speed(port, self->newspeed);\r\nself->speed = self->newspeed;\r\nself->newspeed = 0;\r\n}\r\nbfin_sir_enable_rx(port);\r\nport->tx_done = 1;\r\nnetif_wake_queue(dev);\r\nreturn;\r\n}\r\nblackfin_dcache_flush_range((unsigned long)(self->tx_buff.data),\r\n(unsigned long)(self->tx_buff.data+self->tx_buff.len));\r\nset_dma_config(port->tx_dma_channel,\r\nset_bfin_dma_config(DIR_READ, DMA_FLOW_STOP,\r\nINTR_ON_BUF, DIMENSION_LINEAR, DATA_SIZE_8,\r\nDMA_SYNC_RESTART));\r\nset_dma_start_addr(port->tx_dma_channel,\r\n(unsigned long)(self->tx_buff.data));\r\nset_dma_x_count(port->tx_dma_channel, self->tx_buff.len);\r\nset_dma_x_modify(port->tx_dma_channel, 1);\r\nenable_dma(port->tx_dma_channel);\r\n}\r\nstatic irqreturn_t bfin_sir_dma_tx_int(int irq, void *dev_id)\r\n{\r\nstruct net_device *dev = dev_id;\r\nstruct bfin_sir_self *self = netdev_priv(dev);\r\nstruct bfin_sir_port *port = self->sir_port;\r\nspin_lock(&self->lock);\r\nif (!(get_dma_curr_irqstat(port->tx_dma_channel) & DMA_RUN)) {\r\nclear_dma_irqstat(port->tx_dma_channel);\r\nbfin_sir_stop_tx(port);\r\nself->stats.tx_packets++;\r\nself->stats.tx_bytes += self->tx_buff.len;\r\nself->tx_buff.len = 0;\r\nif (self->newspeed) {\r\nbfin_sir_set_speed(port, self->newspeed);\r\nself->speed = self->newspeed;\r\nself->newspeed = 0;\r\n}\r\nbfin_sir_enable_rx(port);\r\nnetif_wake_queue(dev);\r\nport->tx_done = 1;\r\n}\r\nspin_unlock(&self->lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void bfin_sir_dma_rx_chars(struct net_device *dev)\r\n{\r\nstruct bfin_sir_self *self = netdev_priv(dev);\r\nstruct bfin_sir_port *port = self->sir_port;\r\nint i;\r\nUART_CLEAR_LSR(port);\r\nfor (i = port->rx_dma_buf.head; i < port->rx_dma_buf.tail; i++)\r\nasync_unwrap_char(dev, &self->stats, &self->rx_buff, port->rx_dma_buf.buf[i]);\r\n}\r\nvoid bfin_sir_rx_dma_timeout(struct net_device *dev)\r\n{\r\nstruct bfin_sir_self *self = netdev_priv(dev);\r\nstruct bfin_sir_port *port = self->sir_port;\r\nint x_pos, pos;\r\nunsigned long flags;\r\nspin_lock_irqsave(&self->lock, flags);\r\nx_pos = DMA_SIR_RX_XCNT - get_dma_curr_xcount(port->rx_dma_channel);\r\nif (x_pos == DMA_SIR_RX_XCNT)\r\nx_pos = 0;\r\npos = port->rx_dma_nrows * DMA_SIR_RX_XCNT + x_pos;\r\nif (pos > port->rx_dma_buf.tail) {\r\nport->rx_dma_buf.tail = pos;\r\nbfin_sir_dma_rx_chars(dev);\r\nport->rx_dma_buf.head = port->rx_dma_buf.tail;\r\n}\r\nspin_unlock_irqrestore(&self->lock, flags);\r\n}\r\nstatic irqreturn_t bfin_sir_dma_rx_int(int irq, void *dev_id)\r\n{\r\nstruct net_device *dev = dev_id;\r\nstruct bfin_sir_self *self = netdev_priv(dev);\r\nstruct bfin_sir_port *port = self->sir_port;\r\nunsigned short irqstat;\r\nspin_lock(&self->lock);\r\nport->rx_dma_nrows++;\r\nport->rx_dma_buf.tail = DMA_SIR_RX_XCNT * port->rx_dma_nrows;\r\nbfin_sir_dma_rx_chars(dev);\r\nif (port->rx_dma_nrows >= DMA_SIR_RX_YCNT) {\r\nport->rx_dma_nrows = 0;\r\nport->rx_dma_buf.tail = 0;\r\n}\r\nport->rx_dma_buf.head = port->rx_dma_buf.tail;\r\nirqstat = get_dma_curr_irqstat(port->rx_dma_channel);\r\nclear_dma_irqstat(port->rx_dma_channel);\r\nspin_unlock(&self->lock);\r\nmod_timer(&port->rx_dma_timer, jiffies + DMA_SIR_RX_FLUSH_JIFS);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int bfin_sir_startup(struct bfin_sir_port *port, struct net_device *dev)\r\n{\r\n#ifdef CONFIG_SIR_BFIN_DMA\r\ndma_addr_t dma_handle;\r\n#endif\r\nif (request_dma(port->rx_dma_channel, "BFIN_UART_RX") < 0) {\r\ndev_warn(&dev->dev, "Unable to attach SIR RX DMA channel\n");\r\nreturn -EBUSY;\r\n}\r\nif (request_dma(port->tx_dma_channel, "BFIN_UART_TX") < 0) {\r\ndev_warn(&dev->dev, "Unable to attach SIR TX DMA channel\n");\r\nfree_dma(port->rx_dma_channel);\r\nreturn -EBUSY;\r\n}\r\n#ifdef CONFIG_SIR_BFIN_DMA\r\nset_dma_callback(port->rx_dma_channel, bfin_sir_dma_rx_int, dev);\r\nset_dma_callback(port->tx_dma_channel, bfin_sir_dma_tx_int, dev);\r\nport->rx_dma_buf.buf = (unsigned char *)dma_alloc_coherent(NULL, PAGE_SIZE, &dma_handle, GFP_DMA);\r\nport->rx_dma_buf.head = 0;\r\nport->rx_dma_buf.tail = 0;\r\nport->rx_dma_nrows = 0;\r\nset_dma_config(port->rx_dma_channel,\r\nset_bfin_dma_config(DIR_WRITE, DMA_FLOW_AUTO,\r\nINTR_ON_ROW, DIMENSION_2D,\r\nDATA_SIZE_8, DMA_SYNC_RESTART));\r\nset_dma_x_count(port->rx_dma_channel, DMA_SIR_RX_XCNT);\r\nset_dma_x_modify(port->rx_dma_channel, 1);\r\nset_dma_y_count(port->rx_dma_channel, DMA_SIR_RX_YCNT);\r\nset_dma_y_modify(port->rx_dma_channel, 1);\r\nset_dma_start_addr(port->rx_dma_channel, (unsigned long)port->rx_dma_buf.buf);\r\nenable_dma(port->rx_dma_channel);\r\nport->rx_dma_timer.data = (unsigned long)(dev);\r\nport->rx_dma_timer.function = (void *)bfin_sir_rx_dma_timeout;\r\n#else\r\nif (request_irq(port->irq, bfin_sir_rx_int, IRQF_DISABLED, "BFIN_SIR_RX", dev)) {\r\ndev_warn(&dev->dev, "Unable to attach SIR RX interrupt\n");\r\nreturn -EBUSY;\r\n}\r\nif (request_irq(port->irq+1, bfin_sir_tx_int, IRQF_DISABLED, "BFIN_SIR_TX", dev)) {\r\ndev_warn(&dev->dev, "Unable to attach SIR TX interrupt\n");\r\nfree_irq(port->irq, dev);\r\nreturn -EBUSY;\r\n}\r\n#endif\r\nreturn 0;\r\n}\r\nstatic void bfin_sir_shutdown(struct bfin_sir_port *port, struct net_device *dev)\r\n{\r\nunsigned short val;\r\nbfin_sir_stop_rx(port);\r\nval = UART_GET_GCTL(port);\r\nval &= ~(UCEN | UMOD_MASK | RPOLC);\r\nUART_PUT_GCTL(port, val);\r\n#ifdef CONFIG_SIR_BFIN_DMA\r\ndisable_dma(port->tx_dma_channel);\r\ndisable_dma(port->rx_dma_channel);\r\ndel_timer(&(port->rx_dma_timer));\r\ndma_free_coherent(NULL, PAGE_SIZE, port->rx_dma_buf.buf, 0);\r\n#else\r\nfree_irq(port->irq+1, dev);\r\nfree_irq(port->irq, dev);\r\n#endif\r\nfree_dma(port->tx_dma_channel);\r\nfree_dma(port->rx_dma_channel);\r\n}\r\nstatic int bfin_sir_suspend(struct platform_device *pdev, pm_message_t state)\r\n{\r\nstruct bfin_sir_port *sir_port;\r\nstruct net_device *dev;\r\nstruct bfin_sir_self *self;\r\nsir_port = platform_get_drvdata(pdev);\r\nif (!sir_port)\r\nreturn 0;\r\ndev = sir_port->dev;\r\nself = netdev_priv(dev);\r\nif (self->open) {\r\nflush_work(&self->work);\r\nbfin_sir_shutdown(self->sir_port, dev);\r\nnetif_device_detach(dev);\r\n}\r\nreturn 0;\r\n}\r\nstatic int bfin_sir_resume(struct platform_device *pdev)\r\n{\r\nstruct bfin_sir_port *sir_port;\r\nstruct net_device *dev;\r\nstruct bfin_sir_self *self;\r\nstruct bfin_sir_port *port;\r\nsir_port = platform_get_drvdata(pdev);\r\nif (!sir_port)\r\nreturn 0;\r\ndev = sir_port->dev;\r\nself = netdev_priv(dev);\r\nport = self->sir_port;\r\nif (self->open) {\r\nif (self->newspeed) {\r\nself->speed = self->newspeed;\r\nself->newspeed = 0;\r\n}\r\nbfin_sir_startup(port, dev);\r\nbfin_sir_set_speed(port, 9600);\r\nbfin_sir_enable_rx(port);\r\nnetif_device_attach(dev);\r\n}\r\nreturn 0;\r\n}\r\nstatic void bfin_sir_send_work(struct work_struct *work)\r\n{\r\nstruct bfin_sir_self *self = container_of(work, struct bfin_sir_self, work);\r\nstruct net_device *dev = self->sir_port->dev;\r\nstruct bfin_sir_port *port = self->sir_port;\r\nunsigned short val;\r\nint tx_cnt = 10;\r\nwhile (bfin_sir_is_receiving(dev) && --tx_cnt)\r\nturnaround_delay(dev->last_rx, self->mtt);\r\nbfin_sir_stop_rx(port);\r\nval = UART_GET_GCTL(port);\r\nval &= ~(UMOD_MASK | RPOLC);\r\nUART_PUT_GCTL(port, val);\r\nSSYNC();\r\nval |= UMOD_IRDA | RPOLC;\r\nUART_PUT_GCTL(port, val);\r\nSSYNC();\r\n#ifdef CONFIG_SIR_BFIN_DMA\r\nbfin_sir_dma_tx_chars(dev);\r\n#endif\r\nbfin_sir_enable_tx(port);\r\ndev->trans_start = jiffies;\r\n}\r\nstatic int bfin_sir_hard_xmit(struct sk_buff *skb, struct net_device *dev)\r\n{\r\nstruct bfin_sir_self *self = netdev_priv(dev);\r\nint speed = irda_get_next_speed(skb);\r\nnetif_stop_queue(dev);\r\nself->mtt = irda_get_mtt(skb);\r\nif (speed != self->speed && speed != -1)\r\nself->newspeed = speed;\r\nself->tx_buff.data = self->tx_buff.head;\r\nif (skb->len == 0)\r\nself->tx_buff.len = 0;\r\nelse\r\nself->tx_buff.len = async_wrap_skb(skb, self->tx_buff.data, self->tx_buff.truesize);\r\nschedule_work(&self->work);\r\ndev_kfree_skb(skb);\r\nreturn 0;\r\n}\r\nstatic int bfin_sir_ioctl(struct net_device *dev, struct ifreq *ifreq, int cmd)\r\n{\r\nstruct if_irda_req *rq = (struct if_irda_req *)ifreq;\r\nstruct bfin_sir_self *self = netdev_priv(dev);\r\nstruct bfin_sir_port *port = self->sir_port;\r\nint ret = 0;\r\nswitch (cmd) {\r\ncase SIOCSBANDWIDTH:\r\nif (capable(CAP_NET_ADMIN)) {\r\nif (self->open) {\r\nret = bfin_sir_set_speed(port, rq->ifr_baudrate);\r\nbfin_sir_enable_rx(port);\r\n} else {\r\ndev_warn(&dev->dev, "SIOCSBANDWIDTH: !netif_running\n");\r\nret = 0;\r\n}\r\n}\r\nbreak;\r\ncase SIOCSMEDIABUSY:\r\nret = -EPERM;\r\nif (capable(CAP_NET_ADMIN)) {\r\nirda_device_set_media_busy(dev, TRUE);\r\nret = 0;\r\n}\r\nbreak;\r\ncase SIOCGRECEIVING:\r\nrq->ifr_receiving = bfin_sir_is_receiving(dev);\r\nbreak;\r\ndefault:\r\nret = -EOPNOTSUPP;\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic struct net_device_stats *bfin_sir_stats(struct net_device *dev)\r\n{\r\nstruct bfin_sir_self *self = netdev_priv(dev);\r\nreturn &self->stats;\r\n}\r\nstatic int bfin_sir_open(struct net_device *dev)\r\n{\r\nstruct bfin_sir_self *self = netdev_priv(dev);\r\nstruct bfin_sir_port *port = self->sir_port;\r\nint err = -ENOMEM;\r\nself->newspeed = 0;\r\nself->speed = 9600;\r\nspin_lock_init(&self->lock);\r\nerr = bfin_sir_startup(port, dev);\r\nif (err)\r\ngoto err_startup;\r\nbfin_sir_set_speed(port, 9600);\r\nself->irlap = irlap_open(dev, &self->qos, DRIVER_NAME);\r\nif (!self->irlap)\r\ngoto err_irlap;\r\nINIT_WORK(&self->work, bfin_sir_send_work);\r\nself->open = 1;\r\nbfin_sir_enable_rx(port);\r\nnetif_start_queue(dev);\r\nreturn 0;\r\nerr_irlap:\r\nself->open = 0;\r\nbfin_sir_shutdown(port, dev);\r\nerr_startup:\r\nreturn err;\r\n}\r\nstatic int bfin_sir_stop(struct net_device *dev)\r\n{\r\nstruct bfin_sir_self *self = netdev_priv(dev);\r\nflush_work(&self->work);\r\nbfin_sir_shutdown(self->sir_port, dev);\r\nif (self->rxskb) {\r\ndev_kfree_skb(self->rxskb);\r\nself->rxskb = NULL;\r\n}\r\nif (self->irlap) {\r\nirlap_close(self->irlap);\r\nself->irlap = NULL;\r\n}\r\nnetif_stop_queue(dev);\r\nself->open = 0;\r\nreturn 0;\r\n}\r\nstatic int bfin_sir_init_iobuf(iobuff_t *io, int size)\r\n{\r\nio->head = kmalloc(size, GFP_KERNEL);\r\nif (!io->head)\r\nreturn -ENOMEM;\r\nio->truesize = size;\r\nio->in_frame = FALSE;\r\nio->state = OUTSIDE_FRAME;\r\nio->data = io->head;\r\nreturn 0;\r\n}\r\nstatic int bfin_sir_probe(struct platform_device *pdev)\r\n{\r\nstruct net_device *dev;\r\nstruct bfin_sir_self *self;\r\nunsigned int baudrate_mask;\r\nstruct bfin_sir_port *sir_port;\r\nint err;\r\nif (pdev->id >= 0 && pdev->id < ARRAY_SIZE(per) && \\r\nper[pdev->id][3] == pdev->id) {\r\nerr = peripheral_request_list(per[pdev->id], DRIVER_NAME);\r\nif (err)\r\nreturn err;\r\n} else {\r\ndev_err(&pdev->dev, "Invalid pdev id, please check board file\n");\r\nreturn -ENODEV;\r\n}\r\nerr = -ENOMEM;\r\nsir_port = kmalloc(sizeof(*sir_port), GFP_KERNEL);\r\nif (!sir_port)\r\ngoto err_mem_0;\r\nbfin_sir_init_ports(sir_port, pdev);\r\ndev = alloc_irdadev(sizeof(*self));\r\nif (!dev)\r\ngoto err_mem_1;\r\nself = netdev_priv(dev);\r\nself->dev = &pdev->dev;\r\nself->sir_port = sir_port;\r\nsir_port->dev = dev;\r\nerr = bfin_sir_init_iobuf(&self->rx_buff, IRDA_SKB_MAX_MTU);\r\nif (err)\r\ngoto err_mem_2;\r\nerr = bfin_sir_init_iobuf(&self->tx_buff, IRDA_SIR_MAX_FRAME);\r\nif (err)\r\ngoto err_mem_3;\r\ndev->netdev_ops = &bfin_sir_ndo;\r\ndev->irq = sir_port->irq;\r\nirda_init_max_qos_capabilies(&self->qos);\r\nbaudrate_mask = IR_9600;\r\nswitch (max_rate) {\r\ncase 115200:\r\nbaudrate_mask |= IR_115200;\r\ncase 57600:\r\nbaudrate_mask |= IR_57600;\r\ncase 38400:\r\nbaudrate_mask |= IR_38400;\r\ncase 19200:\r\nbaudrate_mask |= IR_19200;\r\ncase 9600:\r\nbreak;\r\ndefault:\r\ndev_warn(&pdev->dev, "Invalid maximum baud rate, using 9600\n");\r\n}\r\nself->qos.baud_rate.bits &= baudrate_mask;\r\nself->qos.min_turn_time.bits = 1;\r\nirda_qos_bits_to_value(&self->qos);\r\nerr = register_netdev(dev);\r\nif (err) {\r\nkfree(self->tx_buff.head);\r\nerr_mem_3:\r\nkfree(self->rx_buff.head);\r\nerr_mem_2:\r\nfree_netdev(dev);\r\nerr_mem_1:\r\nkfree(sir_port);\r\nerr_mem_0:\r\nperipheral_free_list(per[pdev->id]);\r\n} else\r\nplatform_set_drvdata(pdev, sir_port);\r\nreturn err;\r\n}\r\nstatic int bfin_sir_remove(struct platform_device *pdev)\r\n{\r\nstruct bfin_sir_port *sir_port;\r\nstruct net_device *dev = NULL;\r\nstruct bfin_sir_self *self;\r\nsir_port = platform_get_drvdata(pdev);\r\nif (!sir_port)\r\nreturn 0;\r\ndev = sir_port->dev;\r\nself = netdev_priv(dev);\r\nunregister_netdev(dev);\r\nkfree(self->tx_buff.head);\r\nkfree(self->rx_buff.head);\r\nfree_netdev(dev);\r\nkfree(sir_port);\r\nplatform_set_drvdata(pdev, NULL);\r\nreturn 0;\r\n}
