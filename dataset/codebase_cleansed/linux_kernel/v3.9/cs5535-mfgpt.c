int cs5535_mfgpt_toggle_event(struct cs5535_mfgpt_timer *timer, int cmp,\r\nint event, int enable)\r\n{\r\nuint32_t msr, mask, value, dummy;\r\nint shift = (cmp == MFGPT_CMP1) ? 0 : 8;\r\nif (!timer) {\r\nWARN_ON(1);\r\nreturn -EIO;\r\n}\r\nswitch (event) {\r\ncase MFGPT_EVENT_RESET:\r\nmsr = MSR_MFGPT_NR;\r\nmask = 1 << (timer->nr + 24);\r\nbreak;\r\ncase MFGPT_EVENT_NMI:\r\nmsr = MSR_MFGPT_NR;\r\nmask = 1 << (timer->nr + shift);\r\nbreak;\r\ncase MFGPT_EVENT_IRQ:\r\nmsr = MSR_MFGPT_IRQ;\r\nmask = 1 << (timer->nr + shift);\r\nbreak;\r\ndefault:\r\nreturn -EIO;\r\n}\r\nrdmsr(msr, value, dummy);\r\nif (enable)\r\nvalue |= mask;\r\nelse\r\nvalue &= ~mask;\r\nwrmsr(msr, value, dummy);\r\nreturn 0;\r\n}\r\nint cs5535_mfgpt_set_irq(struct cs5535_mfgpt_timer *timer, int cmp, int *irq,\r\nint enable)\r\n{\r\nuint32_t zsel, lpc, dummy;\r\nint shift;\r\nif (!timer) {\r\nWARN_ON(1);\r\nreturn -EIO;\r\n}\r\nrdmsr(MSR_PIC_ZSEL_LOW, zsel, dummy);\r\nshift = ((cmp == MFGPT_CMP1 ? 0 : 4) + timer->nr % 4) * 4;\r\nif (((zsel >> shift) & 0xF) == 2)\r\nreturn -EIO;\r\nif (!*irq)\r\n*irq = (zsel >> shift) & 0xF;\r\nif (!*irq)\r\n*irq = CONFIG_CS5535_MFGPT_DEFAULT_IRQ;\r\nif (*irq < 1 || *irq == 2 || *irq > 15)\r\nreturn -EIO;\r\nrdmsr(MSR_PIC_IRQM_LPC, lpc, dummy);\r\nif (lpc & (1 << *irq))\r\nreturn -EIO;\r\nif (cs5535_mfgpt_toggle_event(timer, cmp, MFGPT_EVENT_IRQ, enable))\r\nreturn -EIO;\r\nif (enable) {\r\nzsel = (zsel & ~(0xF << shift)) | (*irq << shift);\r\nwrmsr(MSR_PIC_ZSEL_LOW, zsel, dummy);\r\n}\r\nreturn 0;\r\n}\r\nstruct cs5535_mfgpt_timer *cs5535_mfgpt_alloc_timer(int timer_nr, int domain)\r\n{\r\nstruct cs5535_mfgpt_chip *mfgpt = &cs5535_mfgpt_chip;\r\nstruct cs5535_mfgpt_timer *timer = NULL;\r\nunsigned long flags;\r\nint max;\r\nif (!mfgpt->initialized)\r\ngoto done;\r\nif (domain == MFGPT_DOMAIN_WORKING)\r\nmax = 6;\r\nelse\r\nmax = MFGPT_MAX_TIMERS;\r\nif (timer_nr >= max) {\r\nWARN_ON(1);\r\ngoto done;\r\n}\r\nspin_lock_irqsave(&mfgpt->lock, flags);\r\nif (timer_nr < 0) {\r\nunsigned long t;\r\nt = find_first_bit(mfgpt->avail, max);\r\ntimer_nr = t < max ? (int) t : -1;\r\n} else {\r\nif (!test_bit(timer_nr, mfgpt->avail))\r\ntimer_nr = -1;\r\n}\r\nif (timer_nr >= 0)\r\n__clear_bit(timer_nr, mfgpt->avail);\r\nspin_unlock_irqrestore(&mfgpt->lock, flags);\r\nif (timer_nr < 0)\r\ngoto done;\r\ntimer = kmalloc(sizeof(*timer), GFP_KERNEL);\r\nif (!timer) {\r\nspin_lock_irqsave(&mfgpt->lock, flags);\r\n__set_bit(timer_nr, mfgpt->avail);\r\nspin_unlock_irqrestore(&mfgpt->lock, flags);\r\ngoto done;\r\n}\r\ntimer->chip = mfgpt;\r\ntimer->nr = timer_nr;\r\ndev_info(&mfgpt->pdev->dev, "registered timer %d\n", timer_nr);\r\ndone:\r\nreturn timer;\r\n}\r\nvoid cs5535_mfgpt_free_timer(struct cs5535_mfgpt_timer *timer)\r\n{\r\nunsigned long flags;\r\nuint16_t val;\r\nval = cs5535_mfgpt_read(timer, MFGPT_REG_SETUP);\r\nif (!(val & MFGPT_SETUP_SETUP)) {\r\nspin_lock_irqsave(&timer->chip->lock, flags);\r\n__set_bit(timer->nr, timer->chip->avail);\r\nspin_unlock_irqrestore(&timer->chip->lock, flags);\r\n}\r\nkfree(timer);\r\n}\r\nuint16_t cs5535_mfgpt_read(struct cs5535_mfgpt_timer *timer, uint16_t reg)\r\n{\r\nreturn inw(timer->chip->base + reg + (timer->nr * 8));\r\n}\r\nvoid cs5535_mfgpt_write(struct cs5535_mfgpt_timer *timer, uint16_t reg,\r\nuint16_t value)\r\n{\r\noutw(value, timer->chip->base + reg + (timer->nr * 8));\r\n}\r\nstatic void reset_all_timers(void)\r\n{\r\nuint32_t val, dummy;\r\nval = 0xFF; dummy = 0;\r\nwrmsr(MSR_MFGPT_SETUP, val, dummy);\r\n}\r\nstatic int scan_timers(struct cs5535_mfgpt_chip *mfgpt)\r\n{\r\nstruct cs5535_mfgpt_timer timer = { .chip = mfgpt };\r\nunsigned long flags;\r\nint timers = 0;\r\nuint16_t val;\r\nint i;\r\nif (mfgpt_reset_timers)\r\nreset_all_timers();\r\nspin_lock_irqsave(&mfgpt->lock, flags);\r\nfor (i = 0; i < MFGPT_MAX_TIMERS; i++) {\r\ntimer.nr = i;\r\nval = cs5535_mfgpt_read(&timer, MFGPT_REG_SETUP);\r\nif (!(val & MFGPT_SETUP_SETUP)) {\r\n__set_bit(i, mfgpt->avail);\r\ntimers++;\r\n}\r\n}\r\nspin_unlock_irqrestore(&mfgpt->lock, flags);\r\nreturn timers;\r\n}\r\nstatic int cs5535_mfgpt_probe(struct platform_device *pdev)\r\n{\r\nstruct resource *res;\r\nint err = -EIO, t;\r\nres = platform_get_resource(pdev, IORESOURCE_IO, 0);\r\nif (!res) {\r\ndev_err(&pdev->dev, "can't fetch device resource info\n");\r\ngoto done;\r\n}\r\nif (!request_region(res->start, resource_size(res), pdev->name)) {\r\ndev_err(&pdev->dev, "can't request region\n");\r\ngoto done;\r\n}\r\ncs5535_mfgpt_chip.base = res->start;\r\ncs5535_mfgpt_chip.pdev = pdev;\r\nspin_lock_init(&cs5535_mfgpt_chip.lock);\r\ndev_info(&pdev->dev, "reserved resource region %pR\n", res);\r\nt = scan_timers(&cs5535_mfgpt_chip);\r\ndev_info(&pdev->dev, "%d MFGPT timers available\n", t);\r\ncs5535_mfgpt_chip.initialized = 1;\r\nreturn 0;\r\ndone:\r\nreturn err;\r\n}\r\nstatic int __init cs5535_mfgpt_init(void)\r\n{\r\nreturn platform_driver_register(&cs5535_mfgpt_driver);\r\n}
