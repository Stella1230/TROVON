static int snd_pmac_probe(struct platform_device *devptr)\r\n{\r\nstruct snd_card *card;\r\nstruct snd_pmac *chip;\r\nchar *name_ext;\r\nint err;\r\nerr = snd_card_create(index, id, THIS_MODULE, 0, &card);\r\nif (err < 0)\r\nreturn err;\r\nif ((err = snd_pmac_new(card, &chip)) < 0)\r\ngoto __error;\r\ncard->private_data = chip;\r\nswitch (chip->model) {\r\ncase PMAC_BURGUNDY:\r\nstrcpy(card->driver, "PMac Burgundy");\r\nstrcpy(card->shortname, "PowerMac Burgundy");\r\nsprintf(card->longname, "%s (Dev %d) Sub-frame %d",\r\ncard->shortname, chip->device_id, chip->subframe);\r\nif ((err = snd_pmac_burgundy_init(chip)) < 0)\r\ngoto __error;\r\nbreak;\r\ncase PMAC_DACA:\r\nstrcpy(card->driver, "PMac DACA");\r\nstrcpy(card->shortname, "PowerMac DACA");\r\nsprintf(card->longname, "%s (Dev %d) Sub-frame %d",\r\ncard->shortname, chip->device_id, chip->subframe);\r\nif ((err = snd_pmac_daca_init(chip)) < 0)\r\ngoto __error;\r\nbreak;\r\ncase PMAC_TUMBLER:\r\ncase PMAC_SNAPPER:\r\nname_ext = chip->model == PMAC_TUMBLER ? "Tumbler" : "Snapper";\r\nsprintf(card->driver, "PMac %s", name_ext);\r\nsprintf(card->shortname, "PowerMac %s", name_ext);\r\nsprintf(card->longname, "%s (Dev %d) Sub-frame %d",\r\ncard->shortname, chip->device_id, chip->subframe);\r\nif ( snd_pmac_tumbler_init(chip) < 0 || snd_pmac_tumbler_post_init() < 0)\r\ngoto __error;\r\nbreak;\r\ncase PMAC_AWACS:\r\ncase PMAC_SCREAMER:\r\nname_ext = chip->model == PMAC_SCREAMER ? "Screamer" : "AWACS";\r\nsprintf(card->driver, "PMac %s", name_ext);\r\nsprintf(card->shortname, "PowerMac %s", name_ext);\r\nif (chip->is_pbook_3400)\r\nname_ext = " [PB3400]";\r\nelse if (chip->is_pbook_G3)\r\nname_ext = " [PBG3]";\r\nelse\r\nname_ext = "";\r\nsprintf(card->longname, "%s%s Rev %d",\r\ncard->shortname, name_ext, chip->revision);\r\nif ((err = snd_pmac_awacs_init(chip)) < 0)\r\ngoto __error;\r\nbreak;\r\ndefault:\r\nsnd_printk(KERN_ERR "unsupported hardware %d\n", chip->model);\r\nerr = -EINVAL;\r\ngoto __error;\r\n}\r\nif ((err = snd_pmac_pcm_new(chip)) < 0)\r\ngoto __error;\r\nchip->initialized = 1;\r\nif (enable_beep)\r\nsnd_pmac_attach_beep(chip);\r\nsnd_card_set_dev(card, &devptr->dev);\r\nif ((err = snd_card_register(card)) < 0)\r\ngoto __error;\r\nplatform_set_drvdata(devptr, card);\r\nreturn 0;\r\n__error:\r\nsnd_card_free(card);\r\nreturn err;\r\n}\r\nstatic int snd_pmac_remove(struct platform_device *devptr)\r\n{\r\nsnd_card_free(platform_get_drvdata(devptr));\r\nplatform_set_drvdata(devptr, NULL);\r\nreturn 0;\r\n}\r\nstatic int snd_pmac_driver_suspend(struct device *dev)\r\n{\r\nstruct snd_card *card = dev_get_drvdata(dev);\r\nsnd_pmac_suspend(card->private_data);\r\nreturn 0;\r\n}\r\nstatic int snd_pmac_driver_resume(struct device *dev)\r\n{\r\nstruct snd_card *card = dev_get_drvdata(dev);\r\nsnd_pmac_resume(card->private_data);\r\nreturn 0;\r\n}\r\nstatic int __init alsa_card_pmac_init(void)\r\n{\r\nint err;\r\nif ((err = platform_driver_register(&snd_pmac_driver)) < 0)\r\nreturn err;\r\ndevice = platform_device_register_simple(SND_PMAC_DRIVER, -1, NULL, 0);\r\nreturn 0;\r\n}\r\nstatic void __exit alsa_card_pmac_exit(void)\r\n{\r\nif (!IS_ERR(device))\r\nplatform_device_unregister(device);\r\nplatform_driver_unregister(&snd_pmac_driver);\r\n}
