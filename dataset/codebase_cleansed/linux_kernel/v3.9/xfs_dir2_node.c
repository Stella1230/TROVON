static void\r\nxfs_dir2_free_verify(\r\nstruct xfs_buf *bp)\r\n{\r\nstruct xfs_mount *mp = bp->b_target->bt_mount;\r\nstruct xfs_dir2_free_hdr *hdr = bp->b_addr;\r\nint block_ok = 0;\r\nblock_ok = hdr->magic == cpu_to_be32(XFS_DIR2_FREE_MAGIC);\r\nif (!block_ok) {\r\nXFS_CORRUPTION_ERROR("xfs_dir2_free_verify magic",\r\nXFS_ERRLEVEL_LOW, mp, hdr);\r\nxfs_buf_ioerror(bp, EFSCORRUPTED);\r\n}\r\n}\r\nstatic void\r\nxfs_dir2_free_read_verify(\r\nstruct xfs_buf *bp)\r\n{\r\nxfs_dir2_free_verify(bp);\r\n}\r\nstatic void\r\nxfs_dir2_free_write_verify(\r\nstruct xfs_buf *bp)\r\n{\r\nxfs_dir2_free_verify(bp);\r\n}\r\nstatic int\r\n__xfs_dir2_free_read(\r\nstruct xfs_trans *tp,\r\nstruct xfs_inode *dp,\r\nxfs_dablk_t fbno,\r\nxfs_daddr_t mappedbno,\r\nstruct xfs_buf **bpp)\r\n{\r\nreturn xfs_da_read_buf(tp, dp, fbno, mappedbno, bpp,\r\nXFS_DATA_FORK, &xfs_dir2_free_buf_ops);\r\n}\r\nint\r\nxfs_dir2_free_read(\r\nstruct xfs_trans *tp,\r\nstruct xfs_inode *dp,\r\nxfs_dablk_t fbno,\r\nstruct xfs_buf **bpp)\r\n{\r\nreturn __xfs_dir2_free_read(tp, dp, fbno, -1, bpp);\r\n}\r\nstatic int\r\nxfs_dir2_free_try_read(\r\nstruct xfs_trans *tp,\r\nstruct xfs_inode *dp,\r\nxfs_dablk_t fbno,\r\nstruct xfs_buf **bpp)\r\n{\r\nreturn __xfs_dir2_free_read(tp, dp, fbno, -2, bpp);\r\n}\r\nSTATIC void\r\nxfs_dir2_free_log_bests(\r\nstruct xfs_trans *tp,\r\nstruct xfs_buf *bp,\r\nint first,\r\nint last)\r\n{\r\nxfs_dir2_free_t *free;\r\nfree = bp->b_addr;\r\nASSERT(free->hdr.magic == cpu_to_be32(XFS_DIR2_FREE_MAGIC));\r\nxfs_trans_log_buf(tp, bp,\r\n(uint)((char *)&free->bests[first] - (char *)free),\r\n(uint)((char *)&free->bests[last] - (char *)free +\r\nsizeof(free->bests[0]) - 1));\r\n}\r\nstatic void\r\nxfs_dir2_free_log_header(\r\nstruct xfs_trans *tp,\r\nstruct xfs_buf *bp)\r\n{\r\nxfs_dir2_free_t *free;\r\nfree = bp->b_addr;\r\nASSERT(free->hdr.magic == cpu_to_be32(XFS_DIR2_FREE_MAGIC));\r\nxfs_trans_log_buf(tp, bp, (uint)((char *)&free->hdr - (char *)free),\r\n(uint)(sizeof(xfs_dir2_free_hdr_t) - 1));\r\n}\r\nint\r\nxfs_dir2_leaf_to_node(\r\nxfs_da_args_t *args,\r\nstruct xfs_buf *lbp)\r\n{\r\nxfs_inode_t *dp;\r\nint error;\r\nstruct xfs_buf *fbp;\r\nxfs_dir2_db_t fdb;\r\nxfs_dir2_free_t *free;\r\n__be16 *from;\r\nint i;\r\nxfs_dir2_leaf_t *leaf;\r\nxfs_dir2_leaf_tail_t *ltp;\r\nxfs_mount_t *mp;\r\nint n;\r\nxfs_dir2_data_off_t off;\r\n__be16 *to;\r\nxfs_trans_t *tp;\r\ntrace_xfs_dir2_leaf_to_node(args);\r\ndp = args->dp;\r\nmp = dp->i_mount;\r\ntp = args->trans;\r\nif ((error = xfs_dir2_grow_inode(args, XFS_DIR2_FREE_SPACE, &fdb))) {\r\nreturn error;\r\n}\r\nASSERT(fdb == XFS_DIR2_FREE_FIRSTDB(mp));\r\nerror = xfs_da_get_buf(tp, dp, xfs_dir2_db_to_da(mp, fdb), -1, &fbp,\r\nXFS_DATA_FORK);\r\nif (error)\r\nreturn error;\r\nfbp->b_ops = &xfs_dir2_free_buf_ops;\r\nfree = fbp->b_addr;\r\nleaf = lbp->b_addr;\r\nltp = xfs_dir2_leaf_tail_p(mp, leaf);\r\nfree->hdr.magic = cpu_to_be32(XFS_DIR2_FREE_MAGIC);\r\nfree->hdr.firstdb = 0;\r\nASSERT(be32_to_cpu(ltp->bestcount) <= (uint)dp->i_d.di_size / mp->m_dirblksize);\r\nfree->hdr.nvalid = ltp->bestcount;\r\nfor (i = n = 0, from = xfs_dir2_leaf_bests_p(ltp), to = free->bests;\r\ni < be32_to_cpu(ltp->bestcount); i++, from++, to++) {\r\nif ((off = be16_to_cpu(*from)) != NULLDATAOFF)\r\nn++;\r\n*to = cpu_to_be16(off);\r\n}\r\nfree->hdr.nused = cpu_to_be32(n);\r\nlbp->b_ops = &xfs_dir2_leafn_buf_ops;\r\nleaf->hdr.info.magic = cpu_to_be16(XFS_DIR2_LEAFN_MAGIC);\r\nxfs_dir2_leaf_log_header(tp, lbp);\r\nxfs_dir2_free_log_header(tp, fbp);\r\nxfs_dir2_free_log_bests(tp, fbp, 0, be32_to_cpu(free->hdr.nvalid) - 1);\r\nxfs_dir2_leafn_check(dp, lbp);\r\nreturn 0;\r\n}\r\nstatic int\r\nxfs_dir2_leafn_add(\r\nstruct xfs_buf *bp,\r\nxfs_da_args_t *args,\r\nint index)\r\n{\r\nint compact;\r\nxfs_inode_t *dp;\r\nint highstale;\r\nxfs_dir2_leaf_t *leaf;\r\nxfs_dir2_leaf_entry_t *lep;\r\nint lfloghigh;\r\nint lfloglow;\r\nint lowstale;\r\nxfs_mount_t *mp;\r\nxfs_trans_t *tp;\r\ntrace_xfs_dir2_leafn_add(args, index);\r\ndp = args->dp;\r\nmp = dp->i_mount;\r\ntp = args->trans;\r\nleaf = bp->b_addr;\r\nif (index < 0)\r\nreturn XFS_ERROR(EFSCORRUPTED);\r\nif (be16_to_cpu(leaf->hdr.count) == xfs_dir2_max_leaf_ents(mp)) {\r\nif (!leaf->hdr.stale)\r\nreturn XFS_ERROR(ENOSPC);\r\ncompact = be16_to_cpu(leaf->hdr.stale) > 1;\r\n} else\r\ncompact = 0;\r\nASSERT(index == 0 || be32_to_cpu(leaf->ents[index - 1].hashval) <= args->hashval);\r\nASSERT(index == be16_to_cpu(leaf->hdr.count) ||\r\nbe32_to_cpu(leaf->ents[index].hashval) >= args->hashval);\r\nif (args->op_flags & XFS_DA_OP_JUSTCHECK)\r\nreturn 0;\r\nif (compact) {\r\nxfs_dir2_leaf_compact_x1(bp, &index, &lowstale, &highstale,\r\n&lfloglow, &lfloghigh);\r\n}\r\nelse if (leaf->hdr.stale) {\r\nlfloglow = be16_to_cpu(leaf->hdr.count);\r\nlfloghigh = -1;\r\n}\r\nlep = xfs_dir2_leaf_find_entry(leaf, index, compact, lowstale,\r\nhighstale, &lfloglow, &lfloghigh);\r\nlep->hashval = cpu_to_be32(args->hashval);\r\nlep->address = cpu_to_be32(xfs_dir2_db_off_to_dataptr(mp,\r\nargs->blkno, args->index));\r\nxfs_dir2_leaf_log_header(tp, bp);\r\nxfs_dir2_leaf_log_ents(tp, bp, lfloglow, lfloghigh);\r\nxfs_dir2_leafn_check(dp, bp);\r\nreturn 0;\r\n}\r\nvoid\r\nxfs_dir2_leafn_check(\r\nstruct xfs_inode *dp,\r\nstruct xfs_buf *bp)\r\n{\r\nint i;\r\nxfs_dir2_leaf_t *leaf;\r\nxfs_mount_t *mp;\r\nint stale;\r\nleaf = bp->b_addr;\r\nmp = dp->i_mount;\r\nASSERT(leaf->hdr.info.magic == cpu_to_be16(XFS_DIR2_LEAFN_MAGIC));\r\nASSERT(be16_to_cpu(leaf->hdr.count) <= xfs_dir2_max_leaf_ents(mp));\r\nfor (i = stale = 0; i < be16_to_cpu(leaf->hdr.count); i++) {\r\nif (i + 1 < be16_to_cpu(leaf->hdr.count)) {\r\nASSERT(be32_to_cpu(leaf->ents[i].hashval) <=\r\nbe32_to_cpu(leaf->ents[i + 1].hashval));\r\n}\r\nif (leaf->ents[i].address == cpu_to_be32(XFS_DIR2_NULL_DATAPTR))\r\nstale++;\r\n}\r\nASSERT(be16_to_cpu(leaf->hdr.stale) == stale);\r\n}\r\nxfs_dahash_t\r\nxfs_dir2_leafn_lasthash(\r\nstruct xfs_buf *bp,\r\nint *count)\r\n{\r\nxfs_dir2_leaf_t *leaf;\r\nleaf = bp->b_addr;\r\nASSERT(leaf->hdr.info.magic == cpu_to_be16(XFS_DIR2_LEAFN_MAGIC));\r\nif (count)\r\n*count = be16_to_cpu(leaf->hdr.count);\r\nif (!leaf->hdr.count)\r\nreturn 0;\r\nreturn be32_to_cpu(leaf->ents[be16_to_cpu(leaf->hdr.count) - 1].hashval);\r\n}\r\nSTATIC int\r\nxfs_dir2_leafn_lookup_for_addname(\r\nstruct xfs_buf *bp,\r\nxfs_da_args_t *args,\r\nint *indexp,\r\nxfs_da_state_t *state)\r\n{\r\nstruct xfs_buf *curbp = NULL;\r\nxfs_dir2_db_t curdb = -1;\r\nxfs_dir2_db_t curfdb = -1;\r\nxfs_inode_t *dp;\r\nint error;\r\nint fi;\r\nxfs_dir2_free_t *free = NULL;\r\nint index;\r\nxfs_dir2_leaf_t *leaf;\r\nint length;\r\nxfs_dir2_leaf_entry_t *lep;\r\nxfs_mount_t *mp;\r\nxfs_dir2_db_t newdb;\r\nxfs_dir2_db_t newfdb;\r\nxfs_trans_t *tp;\r\ndp = args->dp;\r\ntp = args->trans;\r\nmp = dp->i_mount;\r\nleaf = bp->b_addr;\r\nASSERT(leaf->hdr.info.magic == cpu_to_be16(XFS_DIR2_LEAFN_MAGIC));\r\n#ifdef __KERNEL__\r\nASSERT(be16_to_cpu(leaf->hdr.count) > 0);\r\n#endif\r\nxfs_dir2_leafn_check(dp, bp);\r\nindex = xfs_dir2_leaf_search_hash(args, bp);\r\nif (state->extravalid) {\r\ncurbp = state->extrablk.bp;\r\ncurfdb = state->extrablk.blkno;\r\nfree = curbp->b_addr;\r\nASSERT(free->hdr.magic == cpu_to_be32(XFS_DIR2_FREE_MAGIC));\r\n}\r\nlength = xfs_dir2_data_entsize(args->namelen);\r\nfor (lep = &leaf->ents[index]; index < be16_to_cpu(leaf->hdr.count) &&\r\nbe32_to_cpu(lep->hashval) == args->hashval;\r\nlep++, index++) {\r\nif (be32_to_cpu(lep->address) == XFS_DIR2_NULL_DATAPTR)\r\ncontinue;\r\nnewdb = xfs_dir2_dataptr_to_db(mp, be32_to_cpu(lep->address));\r\nif (newdb != curdb) {\r\ncurdb = newdb;\r\nnewfdb = xfs_dir2_db_to_fdb(mp, newdb);\r\nif (newfdb != curfdb) {\r\nif (curbp)\r\nxfs_trans_brelse(tp, curbp);\r\nerror = xfs_dir2_free_read(tp, dp,\r\nxfs_dir2_db_to_da(mp, newfdb),\r\n&curbp);\r\nif (error)\r\nreturn error;\r\nfree = curbp->b_addr;\r\nASSERT(be32_to_cpu(free->hdr.magic) ==\r\nXFS_DIR2_FREE_MAGIC);\r\nASSERT((be32_to_cpu(free->hdr.firstdb) %\r\nxfs_dir2_free_max_bests(mp)) == 0);\r\nASSERT(be32_to_cpu(free->hdr.firstdb) <= curdb);\r\nASSERT(curdb < be32_to_cpu(free->hdr.firstdb) +\r\nbe32_to_cpu(free->hdr.nvalid));\r\n}\r\nfi = xfs_dir2_db_to_fdindex(mp, curdb);\r\nif (unlikely(free->bests[fi] ==\r\ncpu_to_be16(NULLDATAOFF))) {\r\nXFS_ERROR_REPORT("xfs_dir2_leafn_lookup_int",\r\nXFS_ERRLEVEL_LOW, mp);\r\nif (curfdb != newfdb)\r\nxfs_trans_brelse(tp, curbp);\r\nreturn XFS_ERROR(EFSCORRUPTED);\r\n}\r\ncurfdb = newfdb;\r\nif (be16_to_cpu(free->bests[fi]) >= length)\r\ngoto out;\r\n}\r\n}\r\nfi = -1;\r\nout:\r\nASSERT(args->op_flags & XFS_DA_OP_OKNOENT);\r\nif (curbp) {\r\nstate->extravalid = 1;\r\nstate->extrablk.bp = curbp;\r\nstate->extrablk.index = fi;\r\nstate->extrablk.blkno = curfdb;\r\nstate->extrablk.magic = XFS_DIR2_FREE_MAGIC;\r\n} else {\r\nstate->extravalid = 0;\r\n}\r\n*indexp = index;\r\nreturn XFS_ERROR(ENOENT);\r\n}\r\nSTATIC int\r\nxfs_dir2_leafn_lookup_for_entry(\r\nstruct xfs_buf *bp,\r\nxfs_da_args_t *args,\r\nint *indexp,\r\nxfs_da_state_t *state)\r\n{\r\nstruct xfs_buf *curbp = NULL;\r\nxfs_dir2_db_t curdb = -1;\r\nxfs_dir2_data_entry_t *dep;\r\nxfs_inode_t *dp;\r\nint error;\r\nint index;\r\nxfs_dir2_leaf_t *leaf;\r\nxfs_dir2_leaf_entry_t *lep;\r\nxfs_mount_t *mp;\r\nxfs_dir2_db_t newdb;\r\nxfs_trans_t *tp;\r\nenum xfs_dacmp cmp;\r\ndp = args->dp;\r\ntp = args->trans;\r\nmp = dp->i_mount;\r\nleaf = bp->b_addr;\r\nASSERT(leaf->hdr.info.magic == cpu_to_be16(XFS_DIR2_LEAFN_MAGIC));\r\n#ifdef __KERNEL__\r\nASSERT(be16_to_cpu(leaf->hdr.count) > 0);\r\n#endif\r\nxfs_dir2_leafn_check(dp, bp);\r\nindex = xfs_dir2_leaf_search_hash(args, bp);\r\nif (state->extravalid) {\r\ncurbp = state->extrablk.bp;\r\ncurdb = state->extrablk.blkno;\r\n}\r\nfor (lep = &leaf->ents[index]; index < be16_to_cpu(leaf->hdr.count) &&\r\nbe32_to_cpu(lep->hashval) == args->hashval;\r\nlep++, index++) {\r\nif (be32_to_cpu(lep->address) == XFS_DIR2_NULL_DATAPTR)\r\ncontinue;\r\nnewdb = xfs_dir2_dataptr_to_db(mp, be32_to_cpu(lep->address));\r\nif (newdb != curdb) {\r\nif (curbp && (args->cmpresult == XFS_CMP_DIFFERENT ||\r\ncurdb != state->extrablk.blkno))\r\nxfs_trans_brelse(tp, curbp);\r\nif (args->cmpresult != XFS_CMP_DIFFERENT &&\r\nnewdb == state->extrablk.blkno) {\r\nASSERT(state->extravalid);\r\ncurbp = state->extrablk.bp;\r\n} else {\r\nerror = xfs_dir2_data_read(tp, dp,\r\nxfs_dir2_db_to_da(mp, newdb),\r\n-1, &curbp);\r\nif (error)\r\nreturn error;\r\n}\r\nxfs_dir2_data_check(dp, curbp);\r\ncurdb = newdb;\r\n}\r\ndep = (xfs_dir2_data_entry_t *)((char *)curbp->b_addr +\r\nxfs_dir2_dataptr_to_off(mp, be32_to_cpu(lep->address)));\r\ncmp = mp->m_dirnameops->compname(args, dep->name, dep->namelen);\r\nif (cmp != XFS_CMP_DIFFERENT && cmp != args->cmpresult) {\r\nif (args->cmpresult != XFS_CMP_DIFFERENT &&\r\ncurdb != state->extrablk.blkno)\r\nxfs_trans_brelse(tp, state->extrablk.bp);\r\nargs->cmpresult = cmp;\r\nargs->inumber = be64_to_cpu(dep->inumber);\r\n*indexp = index;\r\nstate->extravalid = 1;\r\nstate->extrablk.bp = curbp;\r\nstate->extrablk.blkno = curdb;\r\nstate->extrablk.index = (int)((char *)dep -\r\n(char *)curbp->b_addr);\r\nstate->extrablk.magic = XFS_DIR2_DATA_MAGIC;\r\ncurbp->b_ops = &xfs_dir2_data_buf_ops;\r\nif (cmp == XFS_CMP_EXACT)\r\nreturn XFS_ERROR(EEXIST);\r\n}\r\n}\r\nASSERT(index == be16_to_cpu(leaf->hdr.count) ||\r\n(args->op_flags & XFS_DA_OP_OKNOENT));\r\nif (curbp) {\r\nif (args->cmpresult == XFS_CMP_DIFFERENT) {\r\nstate->extravalid = 1;\r\nstate->extrablk.bp = curbp;\r\nstate->extrablk.index = -1;\r\nstate->extrablk.blkno = curdb;\r\nstate->extrablk.magic = XFS_DIR2_DATA_MAGIC;\r\ncurbp->b_ops = &xfs_dir2_data_buf_ops;\r\n} else {\r\nif (state->extrablk.bp != curbp)\r\nxfs_trans_brelse(tp, curbp);\r\n}\r\n} else {\r\nstate->extravalid = 0;\r\n}\r\n*indexp = index;\r\nreturn XFS_ERROR(ENOENT);\r\n}\r\nint\r\nxfs_dir2_leafn_lookup_int(\r\nstruct xfs_buf *bp,\r\nxfs_da_args_t *args,\r\nint *indexp,\r\nxfs_da_state_t *state)\r\n{\r\nif (args->op_flags & XFS_DA_OP_ADDNAME)\r\nreturn xfs_dir2_leafn_lookup_for_addname(bp, args, indexp,\r\nstate);\r\nreturn xfs_dir2_leafn_lookup_for_entry(bp, args, indexp, state);\r\n}\r\nstatic void\r\nxfs_dir2_leafn_moveents(\r\nxfs_da_args_t *args,\r\nstruct xfs_buf *bp_s,\r\nint start_s,\r\nstruct xfs_buf *bp_d,\r\nint start_d,\r\nint count)\r\n{\r\nxfs_dir2_leaf_t *leaf_d;\r\nxfs_dir2_leaf_t *leaf_s;\r\nint stale;\r\nxfs_trans_t *tp;\r\ntrace_xfs_dir2_leafn_moveents(args, start_s, start_d, count);\r\nif (count == 0) {\r\nreturn;\r\n}\r\ntp = args->trans;\r\nleaf_s = bp_s->b_addr;\r\nleaf_d = bp_d->b_addr;\r\nif (start_d < be16_to_cpu(leaf_d->hdr.count)) {\r\nmemmove(&leaf_d->ents[start_d + count], &leaf_d->ents[start_d],\r\n(be16_to_cpu(leaf_d->hdr.count) - start_d) *\r\nsizeof(xfs_dir2_leaf_entry_t));\r\nxfs_dir2_leaf_log_ents(tp, bp_d, start_d + count,\r\ncount + be16_to_cpu(leaf_d->hdr.count) - 1);\r\n}\r\nif (leaf_s->hdr.stale) {\r\nint i;\r\nfor (i = start_s, stale = 0; i < start_s + count; i++) {\r\nif (leaf_s->ents[i].address ==\r\ncpu_to_be32(XFS_DIR2_NULL_DATAPTR))\r\nstale++;\r\n}\r\n} else\r\nstale = 0;\r\nmemcpy(&leaf_d->ents[start_d], &leaf_s->ents[start_s],\r\ncount * sizeof(xfs_dir2_leaf_entry_t));\r\nxfs_dir2_leaf_log_ents(tp, bp_d, start_d, start_d + count - 1);\r\nif (start_s + count < be16_to_cpu(leaf_s->hdr.count)) {\r\nmemmove(&leaf_s->ents[start_s], &leaf_s->ents[start_s + count],\r\ncount * sizeof(xfs_dir2_leaf_entry_t));\r\nxfs_dir2_leaf_log_ents(tp, bp_s, start_s, start_s + count - 1);\r\n}\r\nbe16_add_cpu(&leaf_s->hdr.count, -(count));\r\nbe16_add_cpu(&leaf_s->hdr.stale, -(stale));\r\nbe16_add_cpu(&leaf_d->hdr.count, count);\r\nbe16_add_cpu(&leaf_d->hdr.stale, stale);\r\nxfs_dir2_leaf_log_header(tp, bp_s);\r\nxfs_dir2_leaf_log_header(tp, bp_d);\r\nxfs_dir2_leafn_check(args->dp, bp_s);\r\nxfs_dir2_leafn_check(args->dp, bp_d);\r\n}\r\nint\r\nxfs_dir2_leafn_order(\r\nstruct xfs_buf *leaf1_bp,\r\nstruct xfs_buf *leaf2_bp)\r\n{\r\nxfs_dir2_leaf_t *leaf1;\r\nxfs_dir2_leaf_t *leaf2;\r\nleaf1 = leaf1_bp->b_addr;\r\nleaf2 = leaf2_bp->b_addr;\r\nASSERT(leaf1->hdr.info.magic == cpu_to_be16(XFS_DIR2_LEAFN_MAGIC));\r\nASSERT(leaf2->hdr.info.magic == cpu_to_be16(XFS_DIR2_LEAFN_MAGIC));\r\nif (be16_to_cpu(leaf1->hdr.count) > 0 &&\r\nbe16_to_cpu(leaf2->hdr.count) > 0 &&\r\n(be32_to_cpu(leaf2->ents[0].hashval) < be32_to_cpu(leaf1->ents[0].hashval) ||\r\nbe32_to_cpu(leaf2->ents[be16_to_cpu(leaf2->hdr.count) - 1].hashval) <\r\nbe32_to_cpu(leaf1->ents[be16_to_cpu(leaf1->hdr.count) - 1].hashval)))\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic void\r\nxfs_dir2_leafn_rebalance(\r\nxfs_da_state_t *state,\r\nxfs_da_state_blk_t *blk1,\r\nxfs_da_state_blk_t *blk2)\r\n{\r\nxfs_da_args_t *args;\r\nint count;\r\nint isleft;\r\nxfs_dir2_leaf_t *leaf1;\r\nxfs_dir2_leaf_t *leaf2;\r\nint mid;\r\n#ifdef DEBUG\r\nint oldstale;\r\n#endif\r\nint oldsum;\r\nint swap;\r\nargs = state->args;\r\nif ((swap = xfs_dir2_leafn_order(blk1->bp, blk2->bp))) {\r\nxfs_da_state_blk_t *tmp;\r\ntmp = blk1;\r\nblk1 = blk2;\r\nblk2 = tmp;\r\n}\r\nleaf1 = blk1->bp->b_addr;\r\nleaf2 = blk2->bp->b_addr;\r\noldsum = be16_to_cpu(leaf1->hdr.count) + be16_to_cpu(leaf2->hdr.count);\r\n#ifdef DEBUG\r\noldstale = be16_to_cpu(leaf1->hdr.stale) + be16_to_cpu(leaf2->hdr.stale);\r\n#endif\r\nmid = oldsum >> 1;\r\nif (oldsum & 1) {\r\nxfs_dahash_t midhash;\r\nif (mid >= be16_to_cpu(leaf1->hdr.count))\r\nmidhash = be32_to_cpu(leaf2->ents[mid - be16_to_cpu(leaf1->hdr.count)].hashval);\r\nelse\r\nmidhash = be32_to_cpu(leaf1->ents[mid].hashval);\r\nisleft = args->hashval <= midhash;\r\n}\r\nelse\r\nisleft = 1;\r\ncount = be16_to_cpu(leaf1->hdr.count) - mid + (isleft == 0);\r\nif (count > 0)\r\nxfs_dir2_leafn_moveents(args, blk1->bp,\r\nbe16_to_cpu(leaf1->hdr.count) - count, blk2->bp, 0, count);\r\nelse if (count < 0)\r\nxfs_dir2_leafn_moveents(args, blk2->bp, 0, blk1->bp,\r\nbe16_to_cpu(leaf1->hdr.count), count);\r\nASSERT(be16_to_cpu(leaf1->hdr.count) + be16_to_cpu(leaf2->hdr.count) == oldsum);\r\nASSERT(be16_to_cpu(leaf1->hdr.stale) + be16_to_cpu(leaf2->hdr.stale) == oldstale);\r\nif (be16_to_cpu(leaf1->hdr.count) < be16_to_cpu(leaf2->hdr.count))\r\nstate->inleaf = swap;\r\nelse if (be16_to_cpu(leaf1->hdr.count) > be16_to_cpu(leaf2->hdr.count))\r\nstate->inleaf = !swap;\r\nelse\r\nstate->inleaf =\r\nswap ^ (blk1->index <= be16_to_cpu(leaf1->hdr.count));\r\nif (!state->inleaf)\r\nblk2->index = blk1->index - be16_to_cpu(leaf1->hdr.count);\r\nif(blk2->index < 0) {\r\nstate->inleaf = 1;\r\nblk2->index = 0;\r\nxfs_alert(args->dp->i_mount,\r\n"%s: picked the wrong leaf? reverting original leaf: blk1->index %d\n",\r\n__func__, blk1->index);\r\n}\r\n}\r\nstatic int\r\nxfs_dir2_data_block_free(\r\nxfs_da_args_t *args,\r\nstruct xfs_dir2_data_hdr *hdr,\r\nstruct xfs_dir2_free *free,\r\nxfs_dir2_db_t fdb,\r\nint findex,\r\nstruct xfs_buf *fbp,\r\nint longest)\r\n{\r\nstruct xfs_trans *tp = args->trans;\r\nint logfree = 0;\r\nif (!hdr) {\r\nbe32_add_cpu(&free->hdr.nused, -1);\r\nxfs_dir2_free_log_header(tp, fbp);\r\nif (findex == be32_to_cpu(free->hdr.nvalid) - 1) {\r\nint i;\r\nfor (i = findex - 1; i >= 0; i--) {\r\nif (free->bests[i] != cpu_to_be16(NULLDATAOFF))\r\nbreak;\r\n}\r\nfree->hdr.nvalid = cpu_to_be32(i + 1);\r\nlogfree = 0;\r\n} else {\r\nfree->bests[findex] = cpu_to_be16(NULLDATAOFF);\r\nlogfree = 1;\r\n}\r\nif (!free->hdr.nused) {\r\nint error;\r\nerror = xfs_dir2_shrink_inode(args, fdb, fbp);\r\nif (error == 0) {\r\nfbp = NULL;\r\nlogfree = 0;\r\n} else if (error != ENOSPC || args->total != 0)\r\nreturn error;\r\n}\r\n} else {\r\nfree->bests[findex] = cpu_to_be16(longest);\r\nlogfree = 1;\r\n}\r\nif (logfree)\r\nxfs_dir2_free_log_bests(tp, fbp, findex, findex);\r\nreturn 0;\r\n}\r\nstatic int\r\nxfs_dir2_leafn_remove(\r\nxfs_da_args_t *args,\r\nstruct xfs_buf *bp,\r\nint index,\r\nxfs_da_state_blk_t *dblk,\r\nint *rval)\r\n{\r\nxfs_dir2_data_hdr_t *hdr;\r\nxfs_dir2_db_t db;\r\nstruct xfs_buf *dbp;\r\nxfs_dir2_data_entry_t *dep;\r\nxfs_inode_t *dp;\r\nxfs_dir2_leaf_t *leaf;\r\nxfs_dir2_leaf_entry_t *lep;\r\nint longest;\r\nint off;\r\nxfs_mount_t *mp;\r\nint needlog;\r\nint needscan;\r\nxfs_trans_t *tp;\r\ntrace_xfs_dir2_leafn_remove(args, index);\r\ndp = args->dp;\r\ntp = args->trans;\r\nmp = dp->i_mount;\r\nleaf = bp->b_addr;\r\nASSERT(leaf->hdr.info.magic == cpu_to_be16(XFS_DIR2_LEAFN_MAGIC));\r\nlep = &leaf->ents[index];\r\ndb = xfs_dir2_dataptr_to_db(mp, be32_to_cpu(lep->address));\r\nASSERT(dblk->blkno == db);\r\noff = xfs_dir2_dataptr_to_off(mp, be32_to_cpu(lep->address));\r\nASSERT(dblk->index == off);\r\nbe16_add_cpu(&leaf->hdr.stale, 1);\r\nxfs_dir2_leaf_log_header(tp, bp);\r\nlep->address = cpu_to_be32(XFS_DIR2_NULL_DATAPTR);\r\nxfs_dir2_leaf_log_ents(tp, bp, index, index);\r\ndbp = dblk->bp;\r\nhdr = dbp->b_addr;\r\ndep = (xfs_dir2_data_entry_t *)((char *)hdr + off);\r\nlongest = be16_to_cpu(hdr->bestfree[0].length);\r\nneedlog = needscan = 0;\r\nxfs_dir2_data_make_free(tp, dbp, off,\r\nxfs_dir2_data_entsize(dep->namelen), &needlog, &needscan);\r\nif (needscan)\r\nxfs_dir2_data_freescan(mp, hdr, &needlog);\r\nif (needlog)\r\nxfs_dir2_data_log_header(tp, dbp);\r\nxfs_dir2_data_check(dp, dbp);\r\nif (longest < be16_to_cpu(hdr->bestfree[0].length)) {\r\nint error;\r\nstruct xfs_buf *fbp;\r\nxfs_dir2_db_t fdb;\r\nint findex;\r\nxfs_dir2_free_t *free;\r\nfdb = xfs_dir2_db_to_fdb(mp, db);\r\nerror = xfs_dir2_free_read(tp, dp, xfs_dir2_db_to_da(mp, fdb),\r\n&fbp);\r\nif (error)\r\nreturn error;\r\nfree = fbp->b_addr;\r\nASSERT(free->hdr.magic == cpu_to_be32(XFS_DIR2_FREE_MAGIC));\r\nASSERT(be32_to_cpu(free->hdr.firstdb) ==\r\nxfs_dir2_free_max_bests(mp) *\r\n(fdb - XFS_DIR2_FREE_FIRSTDB(mp)));\r\nfindex = xfs_dir2_db_to_fdindex(mp, db);\r\nlongest = be16_to_cpu(hdr->bestfree[0].length);\r\nif (longest == mp->m_dirblksize - (uint)sizeof(*hdr)) {\r\nerror = xfs_dir2_shrink_inode(args, db, dbp);\r\nif (error == 0) {\r\ndblk->bp = NULL;\r\nhdr = NULL;\r\n}\r\nelse if (!(error == ENOSPC && args->total == 0))\r\nreturn error;\r\n}\r\nerror = xfs_dir2_data_block_free(args, hdr, free,\r\nfdb, findex, fbp, longest);\r\nif (error)\r\nreturn error;\r\n}\r\nxfs_dir2_leafn_check(dp, bp);\r\n*rval =\r\n((uint)sizeof(leaf->hdr) +\r\n(uint)sizeof(leaf->ents[0]) *\r\n(be16_to_cpu(leaf->hdr.count) - be16_to_cpu(leaf->hdr.stale))) <\r\nmp->m_dir_magicpct;\r\nreturn 0;\r\n}\r\nint\r\nxfs_dir2_leafn_split(\r\nxfs_da_state_t *state,\r\nxfs_da_state_blk_t *oldblk,\r\nxfs_da_state_blk_t *newblk)\r\n{\r\nxfs_da_args_t *args;\r\nxfs_dablk_t blkno;\r\nint error;\r\nxfs_mount_t *mp;\r\nargs = state->args;\r\nmp = args->dp->i_mount;\r\nASSERT(args != NULL);\r\nASSERT(oldblk->magic == XFS_DIR2_LEAFN_MAGIC);\r\nerror = xfs_da_grow_inode(args, &blkno);\r\nif (error) {\r\nreturn error;\r\n}\r\nerror = xfs_dir2_leaf_init(args, xfs_dir2_da_to_db(mp, blkno),\r\n&newblk->bp, XFS_DIR2_LEAFN_MAGIC);\r\nif (error) {\r\nreturn error;\r\n}\r\nnewblk->blkno = blkno;\r\nnewblk->magic = XFS_DIR2_LEAFN_MAGIC;\r\nxfs_dir2_leafn_rebalance(state, oldblk, newblk);\r\nerror = xfs_da_blk_link(state, oldblk, newblk);\r\nif (error) {\r\nreturn error;\r\n}\r\nif (state->inleaf)\r\nerror = xfs_dir2_leafn_add(oldblk->bp, args, oldblk->index);\r\nelse\r\nerror = xfs_dir2_leafn_add(newblk->bp, args, newblk->index);\r\noldblk->hashval = xfs_dir2_leafn_lasthash(oldblk->bp, NULL);\r\nnewblk->hashval = xfs_dir2_leafn_lasthash(newblk->bp, NULL);\r\nxfs_dir2_leafn_check(args->dp, oldblk->bp);\r\nxfs_dir2_leafn_check(args->dp, newblk->bp);\r\nreturn error;\r\n}\r\nint\r\nxfs_dir2_leafn_toosmall(\r\nxfs_da_state_t *state,\r\nint *action)\r\n{\r\nxfs_da_state_blk_t *blk;\r\nxfs_dablk_t blkno;\r\nstruct xfs_buf *bp;\r\nint bytes;\r\nint count;\r\nint error;\r\nint forward;\r\nint i;\r\nxfs_da_blkinfo_t *info;\r\nxfs_dir2_leaf_t *leaf;\r\nint rval;\r\nblk = &state->path.blk[state->path.active - 1];\r\ninfo = blk->bp->b_addr;\r\nASSERT(info->magic == cpu_to_be16(XFS_DIR2_LEAFN_MAGIC));\r\nleaf = (xfs_dir2_leaf_t *)info;\r\ncount = be16_to_cpu(leaf->hdr.count) - be16_to_cpu(leaf->hdr.stale);\r\nbytes = (uint)sizeof(leaf->hdr) + count * (uint)sizeof(leaf->ents[0]);\r\nif (bytes > (state->blocksize >> 1)) {\r\n*action = 0;\r\nreturn 0;\r\n}\r\nif (count == 0) {\r\nforward = (info->forw != 0);\r\nmemcpy(&state->altpath, &state->path, sizeof(state->path));\r\nerror = xfs_da_path_shift(state, &state->altpath, forward, 0,\r\n&rval);\r\nif (error)\r\nreturn error;\r\n*action = rval ? 2 : 0;\r\nreturn 0;\r\n}\r\nforward = be32_to_cpu(info->forw) < be32_to_cpu(info->back);\r\nfor (i = 0, bp = NULL; i < 2; forward = !forward, i++) {\r\nblkno = forward ? be32_to_cpu(info->forw) : be32_to_cpu(info->back);\r\nif (blkno == 0)\r\ncontinue;\r\nerror = xfs_dir2_leafn_read(state->args->trans, state->args->dp,\r\nblkno, -1, &bp);\r\nif (error)\r\nreturn error;\r\nleaf = (xfs_dir2_leaf_t *)info;\r\ncount = be16_to_cpu(leaf->hdr.count) - be16_to_cpu(leaf->hdr.stale);\r\nbytes = state->blocksize - (state->blocksize >> 2);\r\nleaf = bp->b_addr;\r\nASSERT(leaf->hdr.info.magic == cpu_to_be16(XFS_DIR2_LEAFN_MAGIC));\r\ncount += be16_to_cpu(leaf->hdr.count) - be16_to_cpu(leaf->hdr.stale);\r\nbytes -= count * (uint)sizeof(leaf->ents[0]);\r\nif (bytes >= 0)\r\nbreak;\r\nxfs_trans_brelse(state->args->trans, bp);\r\n}\r\nif (i >= 2) {\r\n*action = 0;\r\nreturn 0;\r\n}\r\nmemcpy(&state->altpath, &state->path, sizeof(state->path));\r\nif (blkno < blk->blkno)\r\nerror = xfs_da_path_shift(state, &state->altpath, forward, 0,\r\n&rval);\r\nelse\r\nerror = xfs_da_path_shift(state, &state->path, forward, 0,\r\n&rval);\r\nif (error) {\r\nreturn error;\r\n}\r\n*action = rval ? 0 : 1;\r\nreturn 0;\r\n}\r\nvoid\r\nxfs_dir2_leafn_unbalance(\r\nxfs_da_state_t *state,\r\nxfs_da_state_blk_t *drop_blk,\r\nxfs_da_state_blk_t *save_blk)\r\n{\r\nxfs_da_args_t *args;\r\nxfs_dir2_leaf_t *drop_leaf;\r\nxfs_dir2_leaf_t *save_leaf;\r\nargs = state->args;\r\nASSERT(drop_blk->magic == XFS_DIR2_LEAFN_MAGIC);\r\nASSERT(save_blk->magic == XFS_DIR2_LEAFN_MAGIC);\r\ndrop_leaf = drop_blk->bp->b_addr;\r\nsave_leaf = save_blk->bp->b_addr;\r\nASSERT(drop_leaf->hdr.info.magic == cpu_to_be16(XFS_DIR2_LEAFN_MAGIC));\r\nASSERT(save_leaf->hdr.info.magic == cpu_to_be16(XFS_DIR2_LEAFN_MAGIC));\r\nif (drop_leaf->hdr.stale)\r\nxfs_dir2_leaf_compact(args, drop_blk->bp);\r\nif (save_leaf->hdr.stale)\r\nxfs_dir2_leaf_compact(args, save_blk->bp);\r\ndrop_blk->hashval = be32_to_cpu(drop_leaf->ents[be16_to_cpu(drop_leaf->hdr.count) - 1].hashval);\r\nif (xfs_dir2_leafn_order(save_blk->bp, drop_blk->bp))\r\nxfs_dir2_leafn_moveents(args, drop_blk->bp, 0, save_blk->bp, 0,\r\nbe16_to_cpu(drop_leaf->hdr.count));\r\nelse\r\nxfs_dir2_leafn_moveents(args, drop_blk->bp, 0, save_blk->bp,\r\nbe16_to_cpu(save_leaf->hdr.count), be16_to_cpu(drop_leaf->hdr.count));\r\nsave_blk->hashval = be32_to_cpu(save_leaf->ents[be16_to_cpu(save_leaf->hdr.count) - 1].hashval);\r\nxfs_dir2_leafn_check(args->dp, save_blk->bp);\r\n}\r\nint\r\nxfs_dir2_node_addname(\r\nxfs_da_args_t *args)\r\n{\r\nxfs_da_state_blk_t *blk;\r\nint error;\r\nint rval;\r\nxfs_da_state_t *state;\r\ntrace_xfs_dir2_node_addname(args);\r\nstate = xfs_da_state_alloc();\r\nstate->args = args;\r\nstate->mp = args->dp->i_mount;\r\nstate->blocksize = state->mp->m_dirblksize;\r\nstate->node_ents = state->mp->m_dir_node_ents;\r\nerror = xfs_da_node_lookup_int(state, &rval);\r\nif (error)\r\nrval = error;\r\nif (rval != ENOENT) {\r\ngoto done;\r\n}\r\nrval = xfs_dir2_node_addname_int(args,\r\nstate->extravalid ? &state->extrablk : NULL);\r\nif (rval) {\r\ngoto done;\r\n}\r\nblk = &state->path.blk[state->path.active - 1];\r\nASSERT(blk->magic == XFS_DIR2_LEAFN_MAGIC);\r\nrval = xfs_dir2_leafn_add(blk->bp, args, blk->index);\r\nif (rval == 0) {\r\nif (!(args->op_flags & XFS_DA_OP_JUSTCHECK))\r\nxfs_da_fixhashpath(state, &state->path);\r\n} else {\r\nif (args->total == 0) {\r\nASSERT(rval == ENOSPC);\r\ngoto done;\r\n}\r\nrval = xfs_da_split(state);\r\n}\r\ndone:\r\nxfs_da_state_free(state);\r\nreturn rval;\r\n}\r\nstatic int\r\nxfs_dir2_node_addname_int(\r\nxfs_da_args_t *args,\r\nxfs_da_state_blk_t *fblk)\r\n{\r\nxfs_dir2_data_hdr_t *hdr;\r\nxfs_dir2_db_t dbno;\r\nstruct xfs_buf *dbp;\r\nxfs_dir2_data_entry_t *dep;\r\nxfs_inode_t *dp;\r\nxfs_dir2_data_unused_t *dup;\r\nint error;\r\nxfs_dir2_db_t fbno;\r\nstruct xfs_buf *fbp;\r\nint findex;\r\nxfs_dir2_free_t *free=NULL;\r\nxfs_dir2_db_t ifbno;\r\nxfs_dir2_db_t lastfbno=0;\r\nint length;\r\nint logfree;\r\nxfs_mount_t *mp;\r\nint needlog;\r\nint needscan;\r\n__be16 *tagp;\r\nxfs_trans_t *tp;\r\ndp = args->dp;\r\nmp = dp->i_mount;\r\ntp = args->trans;\r\nlength = xfs_dir2_data_entsize(args->namelen);\r\nif (fblk) {\r\nfbp = fblk->bp;\r\nifbno = fblk->blkno;\r\nfree = fbp->b_addr;\r\nASSERT(free->hdr.magic == cpu_to_be32(XFS_DIR2_FREE_MAGIC));\r\nfindex = fblk->index;\r\nif (findex >= 0) {\r\nASSERT(findex < be32_to_cpu(free->hdr.nvalid));\r\nASSERT(be16_to_cpu(free->bests[findex]) != NULLDATAOFF);\r\nASSERT(be16_to_cpu(free->bests[findex]) >= length);\r\ndbno = be32_to_cpu(free->hdr.firstdb) + findex;\r\n}\r\nelse {\r\ndbno = -1;\r\nfindex = 0;\r\n}\r\n}\r\nelse {\r\nifbno = dbno = -1;\r\nfbp = NULL;\r\nfindex = 0;\r\n}\r\nif (dbno == -1) {\r\nxfs_fileoff_t fo;\r\nif ((error = xfs_bmap_last_offset(tp, dp, &fo, XFS_DATA_FORK)))\r\nreturn error;\r\nlastfbno = xfs_dir2_da_to_db(mp, (xfs_dablk_t)fo);\r\nfbno = ifbno;\r\n}\r\nwhile (dbno == -1) {\r\nif (fbp == NULL) {\r\nif (++fbno == 0)\r\nfbno = XFS_DIR2_FREE_FIRSTDB(mp);\r\nif (fbno == ifbno)\r\nfbno++;\r\nif (fbno >= lastfbno)\r\nbreak;\r\nerror = xfs_dir2_free_try_read(tp, dp,\r\nxfs_dir2_db_to_da(mp, fbno),\r\n&fbp);\r\nif (error)\r\nreturn error;\r\nif (!fbp)\r\ncontinue;\r\nfree = fbp->b_addr;\r\nASSERT(free->hdr.magic == cpu_to_be32(XFS_DIR2_FREE_MAGIC));\r\nfindex = 0;\r\n}\r\nif (be16_to_cpu(free->bests[findex]) != NULLDATAOFF &&\r\nbe16_to_cpu(free->bests[findex]) >= length)\r\ndbno = be32_to_cpu(free->hdr.firstdb) + findex;\r\nelse {\r\nif (++findex == be32_to_cpu(free->hdr.nvalid)) {\r\nxfs_trans_brelse(tp, fbp);\r\nfbp = NULL;\r\nif (fblk && fblk->bp)\r\nfblk->bp = NULL;\r\n}\r\n}\r\n}\r\nif (unlikely(dbno == -1)) {\r\nif ((args->op_flags & XFS_DA_OP_JUSTCHECK) || args->total == 0)\r\nreturn XFS_ERROR(ENOSPC);\r\nif (unlikely((error = xfs_dir2_grow_inode(args,\r\nXFS_DIR2_DATA_SPACE,\r\n&dbno)) ||\r\n(error = xfs_dir2_data_init(args, dbno, &dbp))))\r\nreturn error;\r\nif (fbp)\r\nxfs_trans_brelse(tp, fbp);\r\nif (fblk && fblk->bp)\r\nfblk->bp = NULL;\r\nfbno = xfs_dir2_db_to_fdb(mp, dbno);\r\nerror = xfs_dir2_free_try_read(tp, dp,\r\nxfs_dir2_db_to_da(mp, fbno),\r\n&fbp);\r\nif (error)\r\nreturn error;\r\nif( fbp == NULL ) {\r\nif ((error = xfs_dir2_grow_inode(args, XFS_DIR2_FREE_SPACE,\r\n&fbno))) {\r\nreturn error;\r\n}\r\nif (unlikely(xfs_dir2_db_to_fdb(mp, dbno) != fbno)) {\r\nxfs_alert(mp,\r\n"%s: dir ino %llu needed freesp block %lld for\n"\r\n" data block %lld, got %lld ifbno %llu lastfbno %d",\r\n__func__, (unsigned long long)dp->i_ino,\r\n(long long)xfs_dir2_db_to_fdb(mp, dbno),\r\n(long long)dbno, (long long)fbno,\r\n(unsigned long long)ifbno, lastfbno);\r\nif (fblk) {\r\nxfs_alert(mp,\r\n" fblk 0x%p blkno %llu index %d magic 0x%x",\r\nfblk,\r\n(unsigned long long)fblk->blkno,\r\nfblk->index,\r\nfblk->magic);\r\n} else {\r\nxfs_alert(mp, " ... fblk is NULL");\r\n}\r\nXFS_ERROR_REPORT("xfs_dir2_node_addname_int",\r\nXFS_ERRLEVEL_LOW, mp);\r\nreturn XFS_ERROR(EFSCORRUPTED);\r\n}\r\nerror = xfs_da_get_buf(tp, dp,\r\nxfs_dir2_db_to_da(mp, fbno),\r\n-1, &fbp, XFS_DATA_FORK);\r\nif (error)\r\nreturn error;\r\nfbp->b_ops = &xfs_dir2_free_buf_ops;\r\nfree = fbp->b_addr;\r\nfree->hdr.magic = cpu_to_be32(XFS_DIR2_FREE_MAGIC);\r\nfree->hdr.firstdb = cpu_to_be32(\r\n(fbno - XFS_DIR2_FREE_FIRSTDB(mp)) *\r\nxfs_dir2_free_max_bests(mp));\r\nfree->hdr.nvalid = 0;\r\nfree->hdr.nused = 0;\r\n} else {\r\nfree = fbp->b_addr;\r\nASSERT(free->hdr.magic == cpu_to_be32(XFS_DIR2_FREE_MAGIC));\r\n}\r\nfindex = xfs_dir2_db_to_fdindex(mp, dbno);\r\nif (findex >= be32_to_cpu(free->hdr.nvalid)) {\r\nASSERT(findex < xfs_dir2_free_max_bests(mp));\r\nfree->hdr.nvalid = cpu_to_be32(findex + 1);\r\nfree->bests[findex] = cpu_to_be16(NULLDATAOFF);\r\n}\r\nif (free->bests[findex] == cpu_to_be16(NULLDATAOFF)) {\r\nbe32_add_cpu(&free->hdr.nused, 1);\r\nxfs_dir2_free_log_header(tp, fbp);\r\n}\r\nhdr = dbp->b_addr;\r\nfree->bests[findex] = hdr->bestfree[0].length;\r\nlogfree = 1;\r\n}\r\nelse {\r\nif (args->op_flags & XFS_DA_OP_JUSTCHECK)\r\nreturn 0;\r\nerror = xfs_dir2_data_read(tp, dp, xfs_dir2_db_to_da(mp, dbno),\r\n-1, &dbp);\r\nif (error)\r\nreturn error;\r\nhdr = dbp->b_addr;\r\nlogfree = 0;\r\n}\r\nASSERT(be16_to_cpu(hdr->bestfree[0].length) >= length);\r\ndup = (xfs_dir2_data_unused_t *)\r\n((char *)hdr + be16_to_cpu(hdr->bestfree[0].offset));\r\nneedscan = needlog = 0;\r\nxfs_dir2_data_use_free(tp, dbp, dup,\r\n(xfs_dir2_data_aoff_t)((char *)dup - (char *)hdr), length,\r\n&needlog, &needscan);\r\ndep = (xfs_dir2_data_entry_t *)dup;\r\ndep->inumber = cpu_to_be64(args->inumber);\r\ndep->namelen = args->namelen;\r\nmemcpy(dep->name, args->name, dep->namelen);\r\ntagp = xfs_dir2_data_entry_tag_p(dep);\r\n*tagp = cpu_to_be16((char *)dep - (char *)hdr);\r\nxfs_dir2_data_log_entry(tp, dbp, dep);\r\nif (needscan)\r\nxfs_dir2_data_freescan(mp, hdr, &needlog);\r\nif (needlog)\r\nxfs_dir2_data_log_header(tp, dbp);\r\nif (be16_to_cpu(free->bests[findex]) != be16_to_cpu(hdr->bestfree[0].length)) {\r\nfree->bests[findex] = hdr->bestfree[0].length;\r\nlogfree = 1;\r\n}\r\nif (logfree)\r\nxfs_dir2_free_log_bests(tp, fbp, findex, findex);\r\nargs->blkno = (xfs_dablk_t)dbno;\r\nargs->index = be16_to_cpu(*tagp);\r\nreturn 0;\r\n}\r\nint\r\nxfs_dir2_node_lookup(\r\nxfs_da_args_t *args)\r\n{\r\nint error;\r\nint i;\r\nint rval;\r\nxfs_da_state_t *state;\r\ntrace_xfs_dir2_node_lookup(args);\r\nstate = xfs_da_state_alloc();\r\nstate->args = args;\r\nstate->mp = args->dp->i_mount;\r\nstate->blocksize = state->mp->m_dirblksize;\r\nstate->node_ents = state->mp->m_dir_node_ents;\r\nerror = xfs_da_node_lookup_int(state, &rval);\r\nif (error)\r\nrval = error;\r\nelse if (rval == ENOENT && args->cmpresult == XFS_CMP_CASE) {\r\nxfs_dir2_data_entry_t *dep;\r\ndep = (xfs_dir2_data_entry_t *)\r\n((char *)state->extrablk.bp->b_addr +\r\nstate->extrablk.index);\r\nrval = xfs_dir_cilookup_result(args, dep->name, dep->namelen);\r\n}\r\nfor (i = 0; i < state->path.active; i++) {\r\nxfs_trans_brelse(args->trans, state->path.blk[i].bp);\r\nstate->path.blk[i].bp = NULL;\r\n}\r\nif (state->extravalid && state->extrablk.bp) {\r\nxfs_trans_brelse(args->trans, state->extrablk.bp);\r\nstate->extrablk.bp = NULL;\r\n}\r\nxfs_da_state_free(state);\r\nreturn rval;\r\n}\r\nint\r\nxfs_dir2_node_removename(\r\nxfs_da_args_t *args)\r\n{\r\nxfs_da_state_blk_t *blk;\r\nint error;\r\nint rval;\r\nxfs_da_state_t *state;\r\ntrace_xfs_dir2_node_removename(args);\r\nstate = xfs_da_state_alloc();\r\nstate->args = args;\r\nstate->mp = args->dp->i_mount;\r\nstate->blocksize = state->mp->m_dirblksize;\r\nstate->node_ents = state->mp->m_dir_node_ents;\r\nerror = xfs_da_node_lookup_int(state, &rval);\r\nif (error)\r\nrval = error;\r\nif (rval != EEXIST) {\r\nxfs_da_state_free(state);\r\nreturn rval;\r\n}\r\nblk = &state->path.blk[state->path.active - 1];\r\nASSERT(blk->magic == XFS_DIR2_LEAFN_MAGIC);\r\nASSERT(state->extravalid);\r\nerror = xfs_dir2_leafn_remove(args, blk->bp, blk->index,\r\n&state->extrablk, &rval);\r\nif (error)\r\nreturn error;\r\nxfs_da_fixhashpath(state, &state->path);\r\nif (rval && state->path.active > 1)\r\nerror = xfs_da_join(state);\r\nif (!error)\r\nerror = xfs_dir2_node_to_leaf(state);\r\nxfs_da_state_free(state);\r\nreturn error;\r\n}\r\nint\r\nxfs_dir2_node_replace(\r\nxfs_da_args_t *args)\r\n{\r\nxfs_da_state_blk_t *blk;\r\nxfs_dir2_data_hdr_t *hdr;\r\nxfs_dir2_data_entry_t *dep;\r\nint error;\r\nint i;\r\nxfs_ino_t inum;\r\nxfs_dir2_leaf_t *leaf;\r\nxfs_dir2_leaf_entry_t *lep;\r\nint rval;\r\nxfs_da_state_t *state;\r\ntrace_xfs_dir2_node_replace(args);\r\nstate = xfs_da_state_alloc();\r\nstate->args = args;\r\nstate->mp = args->dp->i_mount;\r\nstate->blocksize = state->mp->m_dirblksize;\r\nstate->node_ents = state->mp->m_dir_node_ents;\r\ninum = args->inumber;\r\nerror = xfs_da_node_lookup_int(state, &rval);\r\nif (error) {\r\nrval = error;\r\n}\r\nif (rval == EEXIST) {\r\nblk = &state->path.blk[state->path.active - 1];\r\nASSERT(blk->magic == XFS_DIR2_LEAFN_MAGIC);\r\nleaf = blk->bp->b_addr;\r\nlep = &leaf->ents[blk->index];\r\nASSERT(state->extravalid);\r\nhdr = state->extrablk.bp->b_addr;\r\nASSERT(hdr->magic == cpu_to_be32(XFS_DIR2_DATA_MAGIC));\r\ndep = (xfs_dir2_data_entry_t *)\r\n((char *)hdr +\r\nxfs_dir2_dataptr_to_off(state->mp, be32_to_cpu(lep->address)));\r\nASSERT(inum != be64_to_cpu(dep->inumber));\r\ndep->inumber = cpu_to_be64(inum);\r\nxfs_dir2_data_log_entry(args->trans, state->extrablk.bp, dep);\r\nrval = 0;\r\n}\r\nelse if (state->extravalid) {\r\nxfs_trans_brelse(args->trans, state->extrablk.bp);\r\nstate->extrablk.bp = NULL;\r\n}\r\nfor (i = 0; i < state->path.active; i++) {\r\nxfs_trans_brelse(args->trans, state->path.blk[i].bp);\r\nstate->path.blk[i].bp = NULL;\r\n}\r\nxfs_da_state_free(state);\r\nreturn rval;\r\n}\r\nint\r\nxfs_dir2_node_trim_free(\r\nxfs_da_args_t *args,\r\nxfs_fileoff_t fo,\r\nint *rvalp)\r\n{\r\nstruct xfs_buf *bp;\r\nxfs_inode_t *dp;\r\nint error;\r\nxfs_dir2_free_t *free;\r\nxfs_mount_t *mp;\r\nxfs_trans_t *tp;\r\ndp = args->dp;\r\nmp = dp->i_mount;\r\ntp = args->trans;\r\nerror = xfs_dir2_free_try_read(tp, dp, fo, &bp);\r\nif (error)\r\nreturn error;\r\nif (!bp)\r\nreturn 0;\r\nfree = bp->b_addr;\r\nASSERT(free->hdr.magic == cpu_to_be32(XFS_DIR2_FREE_MAGIC));\r\nif (be32_to_cpu(free->hdr.nused) > 0) {\r\nxfs_trans_brelse(tp, bp);\r\n*rvalp = 0;\r\nreturn 0;\r\n}\r\nif ((error =\r\nxfs_dir2_shrink_inode(args, xfs_dir2_da_to_db(mp, (xfs_dablk_t)fo),\r\nbp))) {\r\nASSERT(error != ENOSPC);\r\nxfs_trans_brelse(tp, bp);\r\nreturn error;\r\n}\r\n*rvalp = 1;\r\nreturn 0;\r\n}
