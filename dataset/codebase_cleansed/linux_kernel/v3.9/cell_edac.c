static void cell_edac_count_ce(struct mem_ctl_info *mci, int chan, u64 ar)\r\n{\r\nstruct cell_edac_priv *priv = mci->pvt_info;\r\nstruct csrow_info *csrow = mci->csrows[0];\r\nunsigned long address, pfn, offset, syndrome;\r\ndev_dbg(mci->pdev, "ECC CE err on node %d, channel %d, ar = 0x%016llx\n",\r\npriv->node, chan, ar);\r\naddress = (ar & 0xffffffffe0000000ul) >> 29;\r\nif (priv->chanmask == 0x3)\r\naddress = (address << 1) | chan;\r\npfn = address >> PAGE_SHIFT;\r\noffset = address & ~PAGE_MASK;\r\nsyndrome = (ar & 0x000000001fe00000ul) >> 21;\r\nedac_mc_handle_error(HW_EVENT_ERR_CORRECTED, mci, 1,\r\ncsrow->first_page + pfn, offset, syndrome,\r\n0, chan, -1, "", "");\r\n}\r\nstatic void cell_edac_count_ue(struct mem_ctl_info *mci, int chan, u64 ar)\r\n{\r\nstruct cell_edac_priv *priv = mci->pvt_info;\r\nstruct csrow_info *csrow = mci->csrows[0];\r\nunsigned long address, pfn, offset;\r\ndev_dbg(mci->pdev, "ECC UE err on node %d, channel %d, ar = 0x%016llx\n",\r\npriv->node, chan, ar);\r\naddress = (ar & 0xffffffffe0000000ul) >> 29;\r\nif (priv->chanmask == 0x3)\r\naddress = (address << 1) | chan;\r\npfn = address >> PAGE_SHIFT;\r\noffset = address & ~PAGE_MASK;\r\nedac_mc_handle_error(HW_EVENT_ERR_UNCORRECTED, mci, 1,\r\ncsrow->first_page + pfn, offset, 0,\r\n0, chan, -1, "", "");\r\n}\r\nstatic void cell_edac_check(struct mem_ctl_info *mci)\r\n{\r\nstruct cell_edac_priv *priv = mci->pvt_info;\r\nu64 fir, addreg, clear = 0;\r\nfir = in_be64(&priv->regs->mic_fir);\r\n#ifdef DEBUG\r\nif (fir != priv->prev_fir) {\r\ndev_dbg(mci->pdev, "fir change : 0x%016lx\n", fir);\r\npriv->prev_fir = fir;\r\n}\r\n#endif\r\nif ((priv->chanmask & 0x1) && (fir & CBE_MIC_FIR_ECC_SINGLE_0_ERR)) {\r\naddreg = in_be64(&priv->regs->mic_df_ecc_address_0);\r\nclear |= CBE_MIC_FIR_ECC_SINGLE_0_RESET;\r\ncell_edac_count_ce(mci, 0, addreg);\r\n}\r\nif ((priv->chanmask & 0x2) && (fir & CBE_MIC_FIR_ECC_SINGLE_1_ERR)) {\r\naddreg = in_be64(&priv->regs->mic_df_ecc_address_1);\r\nclear |= CBE_MIC_FIR_ECC_SINGLE_1_RESET;\r\ncell_edac_count_ce(mci, 1, addreg);\r\n}\r\nif ((priv->chanmask & 0x1) && (fir & CBE_MIC_FIR_ECC_MULTI_0_ERR)) {\r\naddreg = in_be64(&priv->regs->mic_df_ecc_address_0);\r\nclear |= CBE_MIC_FIR_ECC_MULTI_0_RESET;\r\ncell_edac_count_ue(mci, 0, addreg);\r\n}\r\nif ((priv->chanmask & 0x2) && (fir & CBE_MIC_FIR_ECC_MULTI_1_ERR)) {\r\naddreg = in_be64(&priv->regs->mic_df_ecc_address_1);\r\nclear |= CBE_MIC_FIR_ECC_MULTI_1_RESET;\r\ncell_edac_count_ue(mci, 1, addreg);\r\n}\r\nif (clear) {\r\nfir &= ~(CBE_MIC_FIR_ECC_ERR_MASK | CBE_MIC_FIR_ECC_SET_MASK);\r\nfir |= CBE_MIC_FIR_ECC_RESET_MASK;\r\nfir &= ~clear;\r\nout_be64(&priv->regs->mic_fir, fir);\r\n(void)in_be64(&priv->regs->mic_fir);\r\nmb();\r\n#ifdef DEBUG\r\nfir = in_be64(&priv->regs->mic_fir);\r\ndev_dbg(mci->pdev, "fir clear : 0x%016lx\n", fir);\r\n#endif\r\n}\r\n}\r\nstatic void cell_edac_init_csrows(struct mem_ctl_info *mci)\r\n{\r\nstruct csrow_info *csrow = mci->csrows[0];\r\nstruct dimm_info *dimm;\r\nstruct cell_edac_priv *priv = mci->pvt_info;\r\nstruct device_node *np;\r\nint j;\r\nu32 nr_pages;\r\nfor (np = NULL;\r\n(np = of_find_node_by_name(np, "memory")) != NULL;) {\r\nstruct resource r;\r\nif (of_address_to_resource(np, 0, &r))\r\ncontinue;\r\nif (of_node_to_nid(np) != priv->node)\r\ncontinue;\r\ncsrow->first_page = r.start >> PAGE_SHIFT;\r\nnr_pages = resource_size(&r) >> PAGE_SHIFT;\r\ncsrow->last_page = csrow->first_page + nr_pages - 1;\r\nfor (j = 0; j < csrow->nr_channels; j++) {\r\ndimm = csrow->channels[j]->dimm;\r\ndimm->mtype = MEM_XDR;\r\ndimm->edac_mode = EDAC_SECDED;\r\ndimm->nr_pages = nr_pages / csrow->nr_channels;\r\n}\r\ndev_dbg(mci->pdev,\r\n"Initialized on node %d, chanmask=0x%x,"\r\n" first_page=0x%lx, nr_pages=0x%x\n",\r\npriv->node, priv->chanmask,\r\ncsrow->first_page, nr_pages);\r\nbreak;\r\n}\r\n}\r\nstatic int cell_edac_probe(struct platform_device *pdev)\r\n{\r\nstruct cbe_mic_tm_regs __iomem *regs;\r\nstruct mem_ctl_info *mci;\r\nstruct edac_mc_layer layers[2];\r\nstruct cell_edac_priv *priv;\r\nu64 reg;\r\nint rc, chanmask, num_chans;\r\nregs = cbe_get_cpu_mic_tm_regs(cbe_node_to_cpu(pdev->id));\r\nif (regs == NULL)\r\nreturn -ENODEV;\r\nedac_op_state = EDAC_OPSTATE_POLL;\r\nreg = in_be64(&regs->mic_mnt_cfg);\r\ndev_dbg(&pdev->dev, "MIC_MNT_CFG = 0x%016llx\n", reg);\r\nchanmask = 0;\r\nif (reg & CBE_MIC_MNT_CFG_CHAN_0_POP)\r\nchanmask |= 0x1;\r\nif (reg & CBE_MIC_MNT_CFG_CHAN_1_POP)\r\nchanmask |= 0x2;\r\nif (chanmask == 0) {\r\ndev_warn(&pdev->dev,\r\n"Yuck ! No channel populated ? Aborting !\n");\r\nreturn -ENODEV;\r\n}\r\ndev_dbg(&pdev->dev, "Initial FIR = 0x%016llx\n",\r\nin_be64(&regs->mic_fir));\r\nnum_chans = chanmask == 3 ? 2 : 1;\r\nlayers[0].type = EDAC_MC_LAYER_CHIP_SELECT;\r\nlayers[0].size = 1;\r\nlayers[0].is_virt_csrow = true;\r\nlayers[1].type = EDAC_MC_LAYER_CHANNEL;\r\nlayers[1].size = num_chans;\r\nlayers[1].is_virt_csrow = false;\r\nmci = edac_mc_alloc(pdev->id, ARRAY_SIZE(layers), layers,\r\nsizeof(struct cell_edac_priv));\r\nif (mci == NULL)\r\nreturn -ENOMEM;\r\npriv = mci->pvt_info;\r\npriv->regs = regs;\r\npriv->node = pdev->id;\r\npriv->chanmask = chanmask;\r\nmci->pdev = &pdev->dev;\r\nmci->mtype_cap = MEM_FLAG_XDR;\r\nmci->edac_ctl_cap = EDAC_FLAG_NONE | EDAC_FLAG_EC | EDAC_FLAG_SECDED;\r\nmci->edac_cap = EDAC_FLAG_EC | EDAC_FLAG_SECDED;\r\nmci->mod_name = "cell_edac";\r\nmci->ctl_name = "MIC";\r\nmci->dev_name = dev_name(&pdev->dev);\r\nmci->edac_check = cell_edac_check;\r\ncell_edac_init_csrows(mci);\r\nrc = edac_mc_add_mc(mci);\r\nif (rc) {\r\ndev_err(&pdev->dev, "failed to register with EDAC core\n");\r\nedac_mc_free(mci);\r\nreturn rc;\r\n}\r\nreturn 0;\r\n}\r\nstatic int cell_edac_remove(struct platform_device *pdev)\r\n{\r\nstruct mem_ctl_info *mci = edac_mc_del_mc(&pdev->dev);\r\nif (mci)\r\nedac_mc_free(mci);\r\nreturn 0;\r\n}\r\nstatic int __init cell_edac_init(void)\r\n{\r\nBUILD_BUG_ON(offsetof(struct cbe_mic_tm_regs,\r\nmic_df_ecc_address_0) != 0xf8);\r\nBUILD_BUG_ON(offsetof(struct cbe_mic_tm_regs,\r\nmic_df_ecc_address_1) != 0x1b8);\r\nBUILD_BUG_ON(offsetof(struct cbe_mic_tm_regs,\r\nmic_df_config) != 0x218);\r\nBUILD_BUG_ON(offsetof(struct cbe_mic_tm_regs,\r\nmic_fir) != 0x230);\r\nBUILD_BUG_ON(offsetof(struct cbe_mic_tm_regs,\r\nmic_mnt_cfg) != 0x210);\r\nBUILD_BUG_ON(offsetof(struct cbe_mic_tm_regs,\r\nmic_exc) != 0x208);\r\nreturn platform_driver_register(&cell_edac_driver);\r\n}\r\nstatic void __exit cell_edac_exit(void)\r\n{\r\nplatform_driver_unregister(&cell_edac_driver);\r\n}
