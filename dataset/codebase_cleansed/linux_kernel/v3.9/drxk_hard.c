static bool IsDVBT(struct drxk_state *state)\r\n{\r\nreturn state->m_OperationMode == OM_DVBT;\r\n}\r\nstatic bool IsQAM(struct drxk_state *state)\r\n{\r\nreturn state->m_OperationMode == OM_QAM_ITU_A ||\r\nstate->m_OperationMode == OM_QAM_ITU_B ||\r\nstate->m_OperationMode == OM_QAM_ITU_C;\r\n}\r\nstatic inline u32 MulDiv32(u32 a, u32 b, u32 c)\r\n{\r\nu64 tmp64;\r\ntmp64 = (u64) a * (u64) b;\r\ndo_div(tmp64, c);\r\nreturn (u32) tmp64;\r\n}\r\nstatic inline u32 Frac28a(u32 a, u32 c)\r\n{\r\nint i = 0;\r\nu32 Q1 = 0;\r\nu32 R0 = 0;\r\nR0 = (a % c) << 4;\r\nQ1 = a / c;\r\nfor (i = 0; i < 7; i++) {\r\nQ1 = (Q1 << 4) | (R0 / c);\r\nR0 = (R0 % c) << 4;\r\n}\r\nif ((R0 >> 3) >= c)\r\nQ1++;\r\nreturn Q1;\r\n}\r\nstatic u32 Log10Times100(u32 x)\r\n{\r\nstatic const u8 scale = 15;\r\nstatic const u8 indexWidth = 5;\r\nu8 i = 0;\r\nu32 y = 0;\r\nu32 d = 0;\r\nu32 k = 0;\r\nu32 r = 0;\r\nstatic const u32 log2lut[] = {\r\n0,\r\n290941,\r\n573196,\r\n847269,\r\n1113620,\r\n1372674,\r\n1624818,\r\n1870412,\r\n2109788,\r\n2343253,\r\n2571091,\r\n2793569,\r\n3010931,\r\n3223408,\r\n3431216,\r\n3634553,\r\n3833610,\r\n4028562,\r\n4219576,\r\n4406807,\r\n4590402,\r\n4770499,\r\n4947231,\r\n5120719,\r\n5291081,\r\n5458428,\r\n5622864,\r\n5784489,\r\n5943398,\r\n6099680,\r\n6253421,\r\n6404702,\r\n6553600,\r\n};\r\nif (x == 0)\r\nreturn 0;\r\nif ((x & ((0xffffffff) << (scale + 1))) == 0) {\r\nfor (k = scale; k > 0; k--) {\r\nif (x & (((u32) 1) << scale))\r\nbreak;\r\nx <<= 1;\r\n}\r\n} else {\r\nfor (k = scale; k < 31; k++) {\r\nif ((x & (((u32) (-1)) << (scale + 1))) == 0)\r\nbreak;\r\nx >>= 1;\r\n}\r\n}\r\ny = k * ((((u32) 1) << scale) * 200);\r\nx &= ((((u32) 1) << scale) - 1);\r\ni = (u8) (x >> (scale - indexWidth));\r\nd = x & ((((u32) 1) << (scale - indexWidth)) - 1);\r\ny += log2lut[i] +\r\n((d * (log2lut[i + 1] - log2lut[i])) >> (scale - indexWidth));\r\ny /= 108853;\r\nr = (y >> 1);\r\nif (y & ((u32) 1))\r\nr++;\r\nreturn r;\r\n}\r\nstatic int drxk_i2c_lock(struct drxk_state *state)\r\n{\r\ni2c_lock_adapter(state->i2c);\r\nstate->drxk_i2c_exclusive_lock = true;\r\nreturn 0;\r\n}\r\nstatic void drxk_i2c_unlock(struct drxk_state *state)\r\n{\r\nif (!state->drxk_i2c_exclusive_lock)\r\nreturn;\r\ni2c_unlock_adapter(state->i2c);\r\nstate->drxk_i2c_exclusive_lock = false;\r\n}\r\nstatic int drxk_i2c_transfer(struct drxk_state *state, struct i2c_msg *msgs,\r\nunsigned len)\r\n{\r\nif (state->drxk_i2c_exclusive_lock)\r\nreturn __i2c_transfer(state->i2c, msgs, len);\r\nelse\r\nreturn i2c_transfer(state->i2c, msgs, len);\r\n}\r\nstatic int i2c_read1(struct drxk_state *state, u8 adr, u8 *val)\r\n{\r\nstruct i2c_msg msgs[1] = { {.addr = adr, .flags = I2C_M_RD,\r\n.buf = val, .len = 1}\r\n};\r\nreturn drxk_i2c_transfer(state, msgs, 1);\r\n}\r\nstatic int i2c_write(struct drxk_state *state, u8 adr, u8 *data, int len)\r\n{\r\nint status;\r\nstruct i2c_msg msg = {\r\n.addr = adr, .flags = 0, .buf = data, .len = len };\r\ndprintk(3, ":");\r\nif (debug > 2) {\r\nint i;\r\nfor (i = 0; i < len; i++)\r\nprintk(KERN_CONT " %02x", data[i]);\r\nprintk(KERN_CONT "\n");\r\n}\r\nstatus = drxk_i2c_transfer(state, &msg, 1);\r\nif (status >= 0 && status != 1)\r\nstatus = -EIO;\r\nif (status < 0)\r\nprintk(KERN_ERR "drxk: i2c write error at addr 0x%02x\n", adr);\r\nreturn status;\r\n}\r\nstatic int i2c_read(struct drxk_state *state,\r\nu8 adr, u8 *msg, int len, u8 *answ, int alen)\r\n{\r\nint status;\r\nstruct i2c_msg msgs[2] = {\r\n{.addr = adr, .flags = 0,\r\n.buf = msg, .len = len},\r\n{.addr = adr, .flags = I2C_M_RD,\r\n.buf = answ, .len = alen}\r\n};\r\nstatus = drxk_i2c_transfer(state, msgs, 2);\r\nif (status != 2) {\r\nif (debug > 2)\r\nprintk(KERN_CONT ": ERROR!\n");\r\nif (status >= 0)\r\nstatus = -EIO;\r\nprintk(KERN_ERR "drxk: i2c read error at addr 0x%02x\n", adr);\r\nreturn status;\r\n}\r\nif (debug > 2) {\r\nint i;\r\ndprintk(2, ": read from");\r\nfor (i = 0; i < len; i++)\r\nprintk(KERN_CONT " %02x", msg[i]);\r\nprintk(KERN_CONT ", value = ");\r\nfor (i = 0; i < alen; i++)\r\nprintk(KERN_CONT " %02x", answ[i]);\r\nprintk(KERN_CONT "\n");\r\n}\r\nreturn 0;\r\n}\r\nstatic int read16_flags(struct drxk_state *state, u32 reg, u16 *data, u8 flags)\r\n{\r\nint status;\r\nu8 adr = state->demod_address, mm1[4], mm2[2], len;\r\nif (state->single_master)\r\nflags |= 0xC0;\r\nif (DRXDAP_FASI_LONG_FORMAT(reg) || (flags != 0)) {\r\nmm1[0] = (((reg << 1) & 0xFF) | 0x01);\r\nmm1[1] = ((reg >> 16) & 0xFF);\r\nmm1[2] = ((reg >> 24) & 0xFF) | flags;\r\nmm1[3] = ((reg >> 7) & 0xFF);\r\nlen = 4;\r\n} else {\r\nmm1[0] = ((reg << 1) & 0xFF);\r\nmm1[1] = (((reg >> 16) & 0x0F) | ((reg >> 18) & 0xF0));\r\nlen = 2;\r\n}\r\ndprintk(2, "(0x%08x, 0x%02x)\n", reg, flags);\r\nstatus = i2c_read(state, adr, mm1, len, mm2, 2);\r\nif (status < 0)\r\nreturn status;\r\nif (data)\r\n*data = mm2[0] | (mm2[1] << 8);\r\nreturn 0;\r\n}\r\nstatic int read16(struct drxk_state *state, u32 reg, u16 *data)\r\n{\r\nreturn read16_flags(state, reg, data, 0);\r\n}\r\nstatic int read32_flags(struct drxk_state *state, u32 reg, u32 *data, u8 flags)\r\n{\r\nint status;\r\nu8 adr = state->demod_address, mm1[4], mm2[4], len;\r\nif (state->single_master)\r\nflags |= 0xC0;\r\nif (DRXDAP_FASI_LONG_FORMAT(reg) || (flags != 0)) {\r\nmm1[0] = (((reg << 1) & 0xFF) | 0x01);\r\nmm1[1] = ((reg >> 16) & 0xFF);\r\nmm1[2] = ((reg >> 24) & 0xFF) | flags;\r\nmm1[3] = ((reg >> 7) & 0xFF);\r\nlen = 4;\r\n} else {\r\nmm1[0] = ((reg << 1) & 0xFF);\r\nmm1[1] = (((reg >> 16) & 0x0F) | ((reg >> 18) & 0xF0));\r\nlen = 2;\r\n}\r\ndprintk(2, "(0x%08x, 0x%02x)\n", reg, flags);\r\nstatus = i2c_read(state, adr, mm1, len, mm2, 4);\r\nif (status < 0)\r\nreturn status;\r\nif (data)\r\n*data = mm2[0] | (mm2[1] << 8) |\r\n(mm2[2] << 16) | (mm2[3] << 24);\r\nreturn 0;\r\n}\r\nstatic int read32(struct drxk_state *state, u32 reg, u32 *data)\r\n{\r\nreturn read32_flags(state, reg, data, 0);\r\n}\r\nstatic int write16_flags(struct drxk_state *state, u32 reg, u16 data, u8 flags)\r\n{\r\nu8 adr = state->demod_address, mm[6], len;\r\nif (state->single_master)\r\nflags |= 0xC0;\r\nif (DRXDAP_FASI_LONG_FORMAT(reg) || (flags != 0)) {\r\nmm[0] = (((reg << 1) & 0xFF) | 0x01);\r\nmm[1] = ((reg >> 16) & 0xFF);\r\nmm[2] = ((reg >> 24) & 0xFF) | flags;\r\nmm[3] = ((reg >> 7) & 0xFF);\r\nlen = 4;\r\n} else {\r\nmm[0] = ((reg << 1) & 0xFF);\r\nmm[1] = (((reg >> 16) & 0x0F) | ((reg >> 18) & 0xF0));\r\nlen = 2;\r\n}\r\nmm[len] = data & 0xff;\r\nmm[len + 1] = (data >> 8) & 0xff;\r\ndprintk(2, "(0x%08x, 0x%04x, 0x%02x)\n", reg, data, flags);\r\nreturn i2c_write(state, adr, mm, len + 2);\r\n}\r\nstatic int write16(struct drxk_state *state, u32 reg, u16 data)\r\n{\r\nreturn write16_flags(state, reg, data, 0);\r\n}\r\nstatic int write32_flags(struct drxk_state *state, u32 reg, u32 data, u8 flags)\r\n{\r\nu8 adr = state->demod_address, mm[8], len;\r\nif (state->single_master)\r\nflags |= 0xC0;\r\nif (DRXDAP_FASI_LONG_FORMAT(reg) || (flags != 0)) {\r\nmm[0] = (((reg << 1) & 0xFF) | 0x01);\r\nmm[1] = ((reg >> 16) & 0xFF);\r\nmm[2] = ((reg >> 24) & 0xFF) | flags;\r\nmm[3] = ((reg >> 7) & 0xFF);\r\nlen = 4;\r\n} else {\r\nmm[0] = ((reg << 1) & 0xFF);\r\nmm[1] = (((reg >> 16) & 0x0F) | ((reg >> 18) & 0xF0));\r\nlen = 2;\r\n}\r\nmm[len] = data & 0xff;\r\nmm[len + 1] = (data >> 8) & 0xff;\r\nmm[len + 2] = (data >> 16) & 0xff;\r\nmm[len + 3] = (data >> 24) & 0xff;\r\ndprintk(2, "(0x%08x, 0x%08x, 0x%02x)\n", reg, data, flags);\r\nreturn i2c_write(state, adr, mm, len + 4);\r\n}\r\nstatic int write32(struct drxk_state *state, u32 reg, u32 data)\r\n{\r\nreturn write32_flags(state, reg, data, 0);\r\n}\r\nstatic int write_block(struct drxk_state *state, u32 Address,\r\nconst int BlockSize, const u8 pBlock[])\r\n{\r\nint status = 0, BlkSize = BlockSize;\r\nu8 Flags = 0;\r\nif (state->single_master)\r\nFlags |= 0xC0;\r\nwhile (BlkSize > 0) {\r\nint Chunk = BlkSize > state->m_ChunkSize ?\r\nstate->m_ChunkSize : BlkSize;\r\nu8 *AdrBuf = &state->Chunk[0];\r\nu32 AdrLength = 0;\r\nif (DRXDAP_FASI_LONG_FORMAT(Address) || (Flags != 0)) {\r\nAdrBuf[0] = (((Address << 1) & 0xFF) | 0x01);\r\nAdrBuf[1] = ((Address >> 16) & 0xFF);\r\nAdrBuf[2] = ((Address >> 24) & 0xFF);\r\nAdrBuf[3] = ((Address >> 7) & 0xFF);\r\nAdrBuf[2] |= Flags;\r\nAdrLength = 4;\r\nif (Chunk == state->m_ChunkSize)\r\nChunk -= 2;\r\n} else {\r\nAdrBuf[0] = ((Address << 1) & 0xFF);\r\nAdrBuf[1] = (((Address >> 16) & 0x0F) |\r\n((Address >> 18) & 0xF0));\r\nAdrLength = 2;\r\n}\r\nmemcpy(&state->Chunk[AdrLength], pBlock, Chunk);\r\ndprintk(2, "(0x%08x, 0x%02x)\n", Address, Flags);\r\nif (debug > 1) {\r\nint i;\r\nif (pBlock)\r\nfor (i = 0; i < Chunk; i++)\r\nprintk(KERN_CONT " %02x", pBlock[i]);\r\nprintk(KERN_CONT "\n");\r\n}\r\nstatus = i2c_write(state, state->demod_address,\r\n&state->Chunk[0], Chunk + AdrLength);\r\nif (status < 0) {\r\nprintk(KERN_ERR "drxk: %s: i2c write error at addr 0x%02x\n",\r\n__func__, Address);\r\nbreak;\r\n}\r\npBlock += Chunk;\r\nAddress += (Chunk >> 1);\r\nBlkSize -= Chunk;\r\n}\r\nreturn status;\r\n}\r\nstatic int PowerUpDevice(struct drxk_state *state)\r\n{\r\nint status;\r\nu8 data = 0;\r\nu16 retryCount = 0;\r\ndprintk(1, "\n");\r\nstatus = i2c_read1(state, state->demod_address, &data);\r\nif (status < 0) {\r\ndo {\r\ndata = 0;\r\nstatus = i2c_write(state, state->demod_address,\r\n&data, 1);\r\nmsleep(10);\r\nretryCount++;\r\nif (status < 0)\r\ncontinue;\r\nstatus = i2c_read1(state, state->demod_address,\r\n&data);\r\n} while (status < 0 &&\r\n(retryCount < DRXK_MAX_RETRIES_POWERUP));\r\nif (status < 0 && retryCount >= DRXK_MAX_RETRIES_POWERUP)\r\ngoto error;\r\n}\r\nstatus = write16(state, SIO_CC_PWD_MODE__A, SIO_CC_PWD_MODE_LEVEL_NONE);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SIO_CC_UPDATE__A, SIO_CC_UPDATE_KEY);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SIO_CC_PLL_LOCK__A, 1);\r\nif (status < 0)\r\ngoto error;\r\nstate->m_currentPowerMode = DRX_POWER_UP;\r\nerror:\r\nif (status < 0)\r\nprintk(KERN_ERR "drxk: Error %d on %s\n", status, __func__);\r\nreturn status;\r\n}\r\nstatic int init_state(struct drxk_state *state)\r\n{\r\nu32 ulVSBIfAgcMode = DRXK_AGC_CTRL_AUTO;\r\nu32 ulVSBIfAgcOutputLevel = 0;\r\nu32 ulVSBIfAgcMinLevel = 0;\r\nu32 ulVSBIfAgcMaxLevel = 0x7FFF;\r\nu32 ulVSBIfAgcSpeed = 3;\r\nu32 ulVSBRfAgcMode = DRXK_AGC_CTRL_AUTO;\r\nu32 ulVSBRfAgcOutputLevel = 0;\r\nu32 ulVSBRfAgcMinLevel = 0;\r\nu32 ulVSBRfAgcMaxLevel = 0x7FFF;\r\nu32 ulVSBRfAgcSpeed = 3;\r\nu32 ulVSBRfAgcTop = 9500;\r\nu32 ulVSBRfAgcCutOffCurrent = 4000;\r\nu32 ulATVIfAgcMode = DRXK_AGC_CTRL_AUTO;\r\nu32 ulATVIfAgcOutputLevel = 0;\r\nu32 ulATVIfAgcMinLevel = 0;\r\nu32 ulATVIfAgcMaxLevel = 0;\r\nu32 ulATVIfAgcSpeed = 3;\r\nu32 ulATVRfAgcMode = DRXK_AGC_CTRL_OFF;\r\nu32 ulATVRfAgcOutputLevel = 0;\r\nu32 ulATVRfAgcMinLevel = 0;\r\nu32 ulATVRfAgcMaxLevel = 0;\r\nu32 ulATVRfAgcTop = 9500;\r\nu32 ulATVRfAgcCutOffCurrent = 4000;\r\nu32 ulATVRfAgcSpeed = 3;\r\nu32 ulQual83 = DEFAULT_MER_83;\r\nu32 ulQual93 = DEFAULT_MER_93;\r\nu32 ulMpegLockTimeOut = DEFAULT_DRXK_MPEG_LOCK_TIMEOUT;\r\nu32 ulDemodLockTimeOut = DEFAULT_DRXK_DEMOD_LOCK_TIMEOUT;\r\nu32 ulGPIOCfg = 0x0113;\r\nu32 ulInvertTSClock = 0;\r\nu32 ulTSDataStrength = DRXK_MPEG_SERIAL_OUTPUT_PIN_DRIVE_STRENGTH;\r\nu32 ulDVBTBitrate = 50000000;\r\nu32 ulDVBCBitrate = DRXK_QAM_SYMBOLRATE_MAX * 8;\r\nu32 ulInsertRSByte = 0;\r\nu32 ulRfMirror = 1;\r\nu32 ulPowerDown = 0;\r\ndprintk(1, "\n");\r\nstate->m_hasLNA = false;\r\nstate->m_hasDVBT = false;\r\nstate->m_hasDVBC = false;\r\nstate->m_hasATV = false;\r\nstate->m_hasOOB = false;\r\nstate->m_hasAudio = false;\r\nif (!state->m_ChunkSize)\r\nstate->m_ChunkSize = 124;\r\nstate->m_oscClockFreq = 0;\r\nstate->m_smartAntInverted = false;\r\nstate->m_bPDownOpenBridge = false;\r\nstate->m_sysClockFreq = 151875;\r\nstate->m_HICfgTimingDiv = ((state->m_sysClockFreq / 1000) *\r\nHI_I2C_DELAY) / 1000;\r\nif (state->m_HICfgTimingDiv > SIO_HI_RA_RAM_PAR_2_CFG_DIV__M)\r\nstate->m_HICfgTimingDiv = SIO_HI_RA_RAM_PAR_2_CFG_DIV__M;\r\nstate->m_HICfgWakeUpKey = (state->demod_address << 1);\r\nstate->m_HICfgCtrl = SIO_HI_RA_RAM_PAR_5_CFG_SLV0_SLAVE;\r\nstate->m_bPowerDown = (ulPowerDown != 0);\r\nstate->m_DRXK_A3_PATCH_CODE = false;\r\nstate->m_vsbIfAgcCfg.ctrlMode = (ulVSBIfAgcMode);\r\nstate->m_vsbIfAgcCfg.outputLevel = (ulVSBIfAgcOutputLevel);\r\nstate->m_vsbIfAgcCfg.minOutputLevel = (ulVSBIfAgcMinLevel);\r\nstate->m_vsbIfAgcCfg.maxOutputLevel = (ulVSBIfAgcMaxLevel);\r\nstate->m_vsbIfAgcCfg.speed = (ulVSBIfAgcSpeed);\r\nstate->m_vsbPgaCfg = 140;\r\nstate->m_vsbRfAgcCfg.ctrlMode = (ulVSBRfAgcMode);\r\nstate->m_vsbRfAgcCfg.outputLevel = (ulVSBRfAgcOutputLevel);\r\nstate->m_vsbRfAgcCfg.minOutputLevel = (ulVSBRfAgcMinLevel);\r\nstate->m_vsbRfAgcCfg.maxOutputLevel = (ulVSBRfAgcMaxLevel);\r\nstate->m_vsbRfAgcCfg.speed = (ulVSBRfAgcSpeed);\r\nstate->m_vsbRfAgcCfg.top = (ulVSBRfAgcTop);\r\nstate->m_vsbRfAgcCfg.cutOffCurrent = (ulVSBRfAgcCutOffCurrent);\r\nstate->m_vsbPreSawCfg.reference = 0x07;\r\nstate->m_vsbPreSawCfg.usePreSaw = true;\r\nstate->m_Quality83percent = DEFAULT_MER_83;\r\nstate->m_Quality93percent = DEFAULT_MER_93;\r\nif (ulQual93 <= 500 && ulQual83 < ulQual93) {\r\nstate->m_Quality83percent = ulQual83;\r\nstate->m_Quality93percent = ulQual93;\r\n}\r\nstate->m_atvIfAgcCfg.ctrlMode = (ulATVIfAgcMode);\r\nstate->m_atvIfAgcCfg.outputLevel = (ulATVIfAgcOutputLevel);\r\nstate->m_atvIfAgcCfg.minOutputLevel = (ulATVIfAgcMinLevel);\r\nstate->m_atvIfAgcCfg.maxOutputLevel = (ulATVIfAgcMaxLevel);\r\nstate->m_atvIfAgcCfg.speed = (ulATVIfAgcSpeed);\r\nstate->m_atvRfAgcCfg.ctrlMode = (ulATVRfAgcMode);\r\nstate->m_atvRfAgcCfg.outputLevel = (ulATVRfAgcOutputLevel);\r\nstate->m_atvRfAgcCfg.minOutputLevel = (ulATVRfAgcMinLevel);\r\nstate->m_atvRfAgcCfg.maxOutputLevel = (ulATVRfAgcMaxLevel);\r\nstate->m_atvRfAgcCfg.speed = (ulATVRfAgcSpeed);\r\nstate->m_atvRfAgcCfg.top = (ulATVRfAgcTop);\r\nstate->m_atvRfAgcCfg.cutOffCurrent = (ulATVRfAgcCutOffCurrent);\r\nstate->m_atvPreSawCfg.reference = 0x04;\r\nstate->m_atvPreSawCfg.usePreSaw = true;\r\nstate->m_dvbtRfAgcCfg.ctrlMode = DRXK_AGC_CTRL_OFF;\r\nstate->m_dvbtRfAgcCfg.outputLevel = 0;\r\nstate->m_dvbtRfAgcCfg.minOutputLevel = 0;\r\nstate->m_dvbtRfAgcCfg.maxOutputLevel = 0xFFFF;\r\nstate->m_dvbtRfAgcCfg.top = 0x2100;\r\nstate->m_dvbtRfAgcCfg.cutOffCurrent = 4000;\r\nstate->m_dvbtRfAgcCfg.speed = 1;\r\nstate->m_dvbtIfAgcCfg.ctrlMode = DRXK_AGC_CTRL_AUTO;\r\nstate->m_dvbtIfAgcCfg.outputLevel = 0;\r\nstate->m_dvbtIfAgcCfg.minOutputLevel = 0;\r\nstate->m_dvbtIfAgcCfg.maxOutputLevel = 9000;\r\nstate->m_dvbtIfAgcCfg.top = 13424;\r\nstate->m_dvbtIfAgcCfg.cutOffCurrent = 0;\r\nstate->m_dvbtIfAgcCfg.speed = 3;\r\nstate->m_dvbtIfAgcCfg.FastClipCtrlDelay = 30;\r\nstate->m_dvbtIfAgcCfg.IngainTgtMax = 30000;\r\nstate->m_dvbtPreSawCfg.reference = 4;\r\nstate->m_dvbtPreSawCfg.usePreSaw = false;\r\nstate->m_qamRfAgcCfg.ctrlMode = DRXK_AGC_CTRL_OFF;\r\nstate->m_qamRfAgcCfg.outputLevel = 0;\r\nstate->m_qamRfAgcCfg.minOutputLevel = 6023;\r\nstate->m_qamRfAgcCfg.maxOutputLevel = 27000;\r\nstate->m_qamRfAgcCfg.top = 0x2380;\r\nstate->m_qamRfAgcCfg.cutOffCurrent = 4000;\r\nstate->m_qamRfAgcCfg.speed = 3;\r\nstate->m_qamIfAgcCfg.ctrlMode = DRXK_AGC_CTRL_AUTO;\r\nstate->m_qamIfAgcCfg.outputLevel = 0;\r\nstate->m_qamIfAgcCfg.minOutputLevel = 0;\r\nstate->m_qamIfAgcCfg.maxOutputLevel = 9000;\r\nstate->m_qamIfAgcCfg.top = 0x0511;\r\nstate->m_qamIfAgcCfg.cutOffCurrent = 0;\r\nstate->m_qamIfAgcCfg.speed = 3;\r\nstate->m_qamIfAgcCfg.IngainTgtMax = 5119;\r\nstate->m_qamIfAgcCfg.FastClipCtrlDelay = 50;\r\nstate->m_qamPgaCfg = 140;\r\nstate->m_qamPreSawCfg.reference = 4;\r\nstate->m_qamPreSawCfg.usePreSaw = false;\r\nstate->m_OperationMode = OM_NONE;\r\nstate->m_DrxkState = DRXK_UNINITIALIZED;\r\nstate->m_enableMPEGOutput = true;\r\nstate->m_insertRSByte = false;\r\nstate->m_invertDATA = false;\r\nstate->m_invertERR = false;\r\nstate->m_invertSTR = false;\r\nstate->m_invertVAL = false;\r\nstate->m_invertCLK = (ulInvertTSClock != 0);\r\nstate->m_DVBTBitrate = ulDVBTBitrate;\r\nstate->m_DVBCBitrate = ulDVBCBitrate;\r\nstate->m_TSDataStrength = (ulTSDataStrength & 0x07);\r\nstate->m_mpegTsStaticBitrate = 19392658;\r\nstate->m_disableTEIhandling = false;\r\nif (ulInsertRSByte)\r\nstate->m_insertRSByte = true;\r\nstate->m_MpegLockTimeOut = DEFAULT_DRXK_MPEG_LOCK_TIMEOUT;\r\nif (ulMpegLockTimeOut < 10000)\r\nstate->m_MpegLockTimeOut = ulMpegLockTimeOut;\r\nstate->m_DemodLockTimeOut = DEFAULT_DRXK_DEMOD_LOCK_TIMEOUT;\r\nif (ulDemodLockTimeOut < 10000)\r\nstate->m_DemodLockTimeOut = ulDemodLockTimeOut;\r\nstate->m_Constellation = DRX_CONSTELLATION_AUTO;\r\nstate->m_qamInterleaveMode = DRXK_QAM_I12_J17;\r\nstate->m_fecRsPlen = 204 * 8;\r\nstate->m_fecRsPrescale = 1;\r\nstate->m_sqiSpeed = DRXK_DVBT_SQI_SPEED_MEDIUM;\r\nstate->m_agcFastClipCtrlDelay = 0;\r\nstate->m_GPIOCfg = (ulGPIOCfg);\r\nstate->m_bPowerDown = false;\r\nstate->m_currentPowerMode = DRX_POWER_DOWN;\r\nstate->m_rfmirror = (ulRfMirror == 0);\r\nstate->m_IfAgcPol = false;\r\nreturn 0;\r\n}\r\nstatic int DRXX_Open(struct drxk_state *state)\r\n{\r\nint status = 0;\r\nu32 jtag = 0;\r\nu16 bid = 0;\r\nu16 key = 0;\r\ndprintk(1, "\n");\r\nstatus = write16(state, SCU_RAM_GPIO__A, SCU_RAM_GPIO_HW_LOCK_IND_DISABLE);\r\nif (status < 0)\r\ngoto error;\r\nstatus = read16(state, SIO_TOP_COMM_KEY__A, &key);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SIO_TOP_COMM_KEY__A, SIO_TOP_COMM_KEY_KEY);\r\nif (status < 0)\r\ngoto error;\r\nstatus = read32(state, SIO_TOP_JTAGID_LO__A, &jtag);\r\nif (status < 0)\r\ngoto error;\r\nstatus = read16(state, SIO_PDR_UIO_IN_HI__A, &bid);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SIO_TOP_COMM_KEY__A, key);\r\nerror:\r\nif (status < 0)\r\nprintk(KERN_ERR "drxk: Error %d on %s\n", status, __func__);\r\nreturn status;\r\n}\r\nstatic int GetDeviceCapabilities(struct drxk_state *state)\r\n{\r\nu16 sioPdrOhwCfg = 0;\r\nu32 sioTopJtagidLo = 0;\r\nint status;\r\nconst char *spin = "";\r\ndprintk(1, "\n");\r\nstatus = write16(state, SCU_RAM_GPIO__A, SCU_RAM_GPIO_HW_LOCK_IND_DISABLE);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SIO_TOP_COMM_KEY__A, SIO_TOP_COMM_KEY_KEY);\r\nif (status < 0)\r\ngoto error;\r\nstatus = read16(state, SIO_PDR_OHW_CFG__A, &sioPdrOhwCfg);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SIO_TOP_COMM_KEY__A, 0x0000);\r\nif (status < 0)\r\ngoto error;\r\nswitch ((sioPdrOhwCfg & SIO_PDR_OHW_CFG_FREF_SEL__M)) {\r\ncase 0:\r\nbreak;\r\ncase 1:\r\nstate->m_oscClockFreq = 27000;\r\nbreak;\r\ncase 2:\r\nstate->m_oscClockFreq = 20250;\r\nbreak;\r\ncase 3:\r\nstate->m_oscClockFreq = 20250;\r\nbreak;\r\ndefault:\r\nprintk(KERN_ERR "drxk: Clock Frequency is unknown\n");\r\nreturn -EINVAL;\r\n}\r\nstatus = read32(state, SIO_TOP_JTAGID_LO__A, &sioTopJtagidLo);\r\nif (status < 0)\r\ngoto error;\r\nprintk(KERN_INFO "drxk: status = 0x%08x\n", sioTopJtagidLo);\r\nswitch ((sioTopJtagidLo >> 29) & 0xF) {\r\ncase 0:\r\nstate->m_deviceSpin = DRXK_SPIN_A1;\r\nspin = "A1";\r\nbreak;\r\ncase 2:\r\nstate->m_deviceSpin = DRXK_SPIN_A2;\r\nspin = "A2";\r\nbreak;\r\ncase 3:\r\nstate->m_deviceSpin = DRXK_SPIN_A3;\r\nspin = "A3";\r\nbreak;\r\ndefault:\r\nstate->m_deviceSpin = DRXK_SPIN_UNKNOWN;\r\nstatus = -EINVAL;\r\nprintk(KERN_ERR "drxk: Spin %d unknown\n",\r\n(sioTopJtagidLo >> 29) & 0xF);\r\ngoto error2;\r\n}\r\nswitch ((sioTopJtagidLo >> 12) & 0xFF) {\r\ncase 0x13:\r\nstate->m_hasLNA = false;\r\nstate->m_hasOOB = false;\r\nstate->m_hasATV = false;\r\nstate->m_hasAudio = false;\r\nstate->m_hasDVBT = true;\r\nstate->m_hasDVBC = true;\r\nstate->m_hasSAWSW = true;\r\nstate->m_hasGPIO2 = false;\r\nstate->m_hasGPIO1 = false;\r\nstate->m_hasIRQN = false;\r\nbreak;\r\ncase 0x15:\r\nstate->m_hasLNA = false;\r\nstate->m_hasOOB = false;\r\nstate->m_hasATV = true;\r\nstate->m_hasAudio = false;\r\nstate->m_hasDVBT = true;\r\nstate->m_hasDVBC = false;\r\nstate->m_hasSAWSW = true;\r\nstate->m_hasGPIO2 = true;\r\nstate->m_hasGPIO1 = true;\r\nstate->m_hasIRQN = false;\r\nbreak;\r\ncase 0x16:\r\nstate->m_hasLNA = false;\r\nstate->m_hasOOB = false;\r\nstate->m_hasATV = true;\r\nstate->m_hasAudio = false;\r\nstate->m_hasDVBT = true;\r\nstate->m_hasDVBC = false;\r\nstate->m_hasSAWSW = true;\r\nstate->m_hasGPIO2 = true;\r\nstate->m_hasGPIO1 = true;\r\nstate->m_hasIRQN = false;\r\nbreak;\r\ncase 0x18:\r\nstate->m_hasLNA = false;\r\nstate->m_hasOOB = false;\r\nstate->m_hasATV = true;\r\nstate->m_hasAudio = true;\r\nstate->m_hasDVBT = true;\r\nstate->m_hasDVBC = false;\r\nstate->m_hasSAWSW = true;\r\nstate->m_hasGPIO2 = true;\r\nstate->m_hasGPIO1 = true;\r\nstate->m_hasIRQN = false;\r\nbreak;\r\ncase 0x21:\r\nstate->m_hasLNA = false;\r\nstate->m_hasOOB = false;\r\nstate->m_hasATV = true;\r\nstate->m_hasAudio = true;\r\nstate->m_hasDVBT = true;\r\nstate->m_hasDVBC = true;\r\nstate->m_hasSAWSW = true;\r\nstate->m_hasGPIO2 = true;\r\nstate->m_hasGPIO1 = true;\r\nstate->m_hasIRQN = false;\r\nbreak;\r\ncase 0x23:\r\nstate->m_hasLNA = false;\r\nstate->m_hasOOB = false;\r\nstate->m_hasATV = true;\r\nstate->m_hasAudio = true;\r\nstate->m_hasDVBT = true;\r\nstate->m_hasDVBC = true;\r\nstate->m_hasSAWSW = true;\r\nstate->m_hasGPIO2 = true;\r\nstate->m_hasGPIO1 = true;\r\nstate->m_hasIRQN = false;\r\nbreak;\r\ncase 0x25:\r\nstate->m_hasLNA = false;\r\nstate->m_hasOOB = false;\r\nstate->m_hasATV = true;\r\nstate->m_hasAudio = true;\r\nstate->m_hasDVBT = true;\r\nstate->m_hasDVBC = true;\r\nstate->m_hasSAWSW = true;\r\nstate->m_hasGPIO2 = true;\r\nstate->m_hasGPIO1 = true;\r\nstate->m_hasIRQN = false;\r\nbreak;\r\ncase 0x26:\r\nstate->m_hasLNA = false;\r\nstate->m_hasOOB = false;\r\nstate->m_hasATV = true;\r\nstate->m_hasAudio = false;\r\nstate->m_hasDVBT = true;\r\nstate->m_hasDVBC = true;\r\nstate->m_hasSAWSW = true;\r\nstate->m_hasGPIO2 = true;\r\nstate->m_hasGPIO1 = true;\r\nstate->m_hasIRQN = false;\r\nbreak;\r\ndefault:\r\nprintk(KERN_ERR "drxk: DeviceID 0x%02x not supported\n",\r\n((sioTopJtagidLo >> 12) & 0xFF));\r\nstatus = -EINVAL;\r\ngoto error2;\r\n}\r\nprintk(KERN_INFO\r\n"drxk: detected a drx-39%02xk, spin %s, xtal %d.%03d MHz\n",\r\n((sioTopJtagidLo >> 12) & 0xFF), spin,\r\nstate->m_oscClockFreq / 1000,\r\nstate->m_oscClockFreq % 1000);\r\nerror:\r\nif (status < 0)\r\nprintk(KERN_ERR "drxk: Error %d on %s\n", status, __func__);\r\nerror2:\r\nreturn status;\r\n}\r\nstatic int HI_Command(struct drxk_state *state, u16 cmd, u16 *pResult)\r\n{\r\nint status;\r\nbool powerdown_cmd;\r\ndprintk(1, "\n");\r\nstatus = write16(state, SIO_HI_RA_RAM_CMD__A, cmd);\r\nif (status < 0)\r\ngoto error;\r\nif (cmd == SIO_HI_RA_RAM_CMD_RESET)\r\nmsleep(1);\r\npowerdown_cmd =\r\n(bool) ((cmd == SIO_HI_RA_RAM_CMD_CONFIG) &&\r\n((state->m_HICfgCtrl) &\r\nSIO_HI_RA_RAM_PAR_5_CFG_SLEEP__M) ==\r\nSIO_HI_RA_RAM_PAR_5_CFG_SLEEP_ZZZ);\r\nif (powerdown_cmd == false) {\r\nu32 retryCount = 0;\r\nu16 waitCmd;\r\ndo {\r\nmsleep(1);\r\nretryCount += 1;\r\nstatus = read16(state, SIO_HI_RA_RAM_CMD__A,\r\n&waitCmd);\r\n} while ((status < 0) && (retryCount < DRXK_MAX_RETRIES)\r\n&& (waitCmd != 0));\r\nif (status < 0)\r\ngoto error;\r\nstatus = read16(state, SIO_HI_RA_RAM_RES__A, pResult);\r\n}\r\nerror:\r\nif (status < 0)\r\nprintk(KERN_ERR "drxk: Error %d on %s\n", status, __func__);\r\nreturn status;\r\n}\r\nstatic int HI_CfgCommand(struct drxk_state *state)\r\n{\r\nint status;\r\ndprintk(1, "\n");\r\nmutex_lock(&state->mutex);\r\nstatus = write16(state, SIO_HI_RA_RAM_PAR_6__A, state->m_HICfgTimeout);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SIO_HI_RA_RAM_PAR_5__A, state->m_HICfgCtrl);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SIO_HI_RA_RAM_PAR_4__A, state->m_HICfgWakeUpKey);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SIO_HI_RA_RAM_PAR_3__A, state->m_HICfgBridgeDelay);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SIO_HI_RA_RAM_PAR_2__A, state->m_HICfgTimingDiv);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SIO_HI_RA_RAM_PAR_1__A, SIO_HI_RA_RAM_PAR_1_PAR1_SEC_KEY);\r\nif (status < 0)\r\ngoto error;\r\nstatus = HI_Command(state, SIO_HI_RA_RAM_CMD_CONFIG, 0);\r\nif (status < 0)\r\ngoto error;\r\nstate->m_HICfgCtrl &= ~SIO_HI_RA_RAM_PAR_5_CFG_SLEEP_ZZZ;\r\nerror:\r\nmutex_unlock(&state->mutex);\r\nif (status < 0)\r\nprintk(KERN_ERR "drxk: Error %d on %s\n", status, __func__);\r\nreturn status;\r\n}\r\nstatic int InitHI(struct drxk_state *state)\r\n{\r\ndprintk(1, "\n");\r\nstate->m_HICfgWakeUpKey = (state->demod_address << 1);\r\nstate->m_HICfgTimeout = 0x96FF;\r\nstate->m_HICfgCtrl = SIO_HI_RA_RAM_PAR_5_CFG_SLV0_SLAVE;\r\nreturn HI_CfgCommand(state);\r\n}\r\nstatic int MPEGTSConfigurePins(struct drxk_state *state, bool mpegEnable)\r\n{\r\nint status = -1;\r\nu16 sioPdrMclkCfg = 0;\r\nu16 sioPdrMdxCfg = 0;\r\nu16 err_cfg = 0;\r\ndprintk(1, ": mpeg %s, %s mode\n",\r\nmpegEnable ? "enable" : "disable",\r\nstate->m_enableParallel ? "parallel" : "serial");\r\nstatus = write16(state, SCU_RAM_GPIO__A, SCU_RAM_GPIO_HW_LOCK_IND_DISABLE);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SIO_TOP_COMM_KEY__A, SIO_TOP_COMM_KEY_KEY);\r\nif (status < 0)\r\ngoto error;\r\nif (mpegEnable == false) {\r\nstatus = write16(state, SIO_PDR_MSTRT_CFG__A, 0x0000);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SIO_PDR_MERR_CFG__A, 0x0000);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SIO_PDR_MCLK_CFG__A, 0x0000);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SIO_PDR_MVAL_CFG__A, 0x0000);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SIO_PDR_MD0_CFG__A, 0x0000);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SIO_PDR_MD1_CFG__A, 0x0000);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SIO_PDR_MD2_CFG__A, 0x0000);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SIO_PDR_MD3_CFG__A, 0x0000);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SIO_PDR_MD4_CFG__A, 0x0000);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SIO_PDR_MD5_CFG__A, 0x0000);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SIO_PDR_MD6_CFG__A, 0x0000);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SIO_PDR_MD7_CFG__A, 0x0000);\r\nif (status < 0)\r\ngoto error;\r\n} else {\r\nsioPdrMdxCfg =\r\n((state->m_TSDataStrength <<\r\nSIO_PDR_MD0_CFG_DRIVE__B) | 0x0003);\r\nsioPdrMclkCfg = ((state->m_TSClockkStrength <<\r\nSIO_PDR_MCLK_CFG_DRIVE__B) |\r\n0x0003);\r\nstatus = write16(state, SIO_PDR_MSTRT_CFG__A, sioPdrMdxCfg);\r\nif (status < 0)\r\ngoto error;\r\nif (state->enable_merr_cfg)\r\nerr_cfg = sioPdrMdxCfg;\r\nstatus = write16(state, SIO_PDR_MERR_CFG__A, err_cfg);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SIO_PDR_MVAL_CFG__A, err_cfg);\r\nif (status < 0)\r\ngoto error;\r\nif (state->m_enableParallel == true) {\r\nstatus = write16(state, SIO_PDR_MD1_CFG__A, sioPdrMdxCfg);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SIO_PDR_MD2_CFG__A, sioPdrMdxCfg);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SIO_PDR_MD3_CFG__A, sioPdrMdxCfg);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SIO_PDR_MD4_CFG__A, sioPdrMdxCfg);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SIO_PDR_MD5_CFG__A, sioPdrMdxCfg);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SIO_PDR_MD6_CFG__A, sioPdrMdxCfg);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SIO_PDR_MD7_CFG__A, sioPdrMdxCfg);\r\nif (status < 0)\r\ngoto error;\r\n} else {\r\nsioPdrMdxCfg = ((state->m_TSDataStrength <<\r\nSIO_PDR_MD0_CFG_DRIVE__B)\r\n| 0x0003);\r\nstatus = write16(state, SIO_PDR_MD1_CFG__A, 0x0000);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SIO_PDR_MD2_CFG__A, 0x0000);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SIO_PDR_MD3_CFG__A, 0x0000);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SIO_PDR_MD4_CFG__A, 0x0000);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SIO_PDR_MD5_CFG__A, 0x0000);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SIO_PDR_MD6_CFG__A, 0x0000);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SIO_PDR_MD7_CFG__A, 0x0000);\r\nif (status < 0)\r\ngoto error;\r\n}\r\nstatus = write16(state, SIO_PDR_MCLK_CFG__A, sioPdrMclkCfg);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SIO_PDR_MD0_CFG__A, sioPdrMdxCfg);\r\nif (status < 0)\r\ngoto error;\r\n}\r\nstatus = write16(state, SIO_PDR_MON_CFG__A, 0x0000);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SIO_TOP_COMM_KEY__A, 0x0000);\r\nerror:\r\nif (status < 0)\r\nprintk(KERN_ERR "drxk: Error %d on %s\n", status, __func__);\r\nreturn status;\r\n}\r\nstatic int MPEGTSDisable(struct drxk_state *state)\r\n{\r\ndprintk(1, "\n");\r\nreturn MPEGTSConfigurePins(state, false);\r\n}\r\nstatic int BLChainCmd(struct drxk_state *state,\r\nu16 romOffset, u16 nrOfElements, u32 timeOut)\r\n{\r\nu16 blStatus = 0;\r\nint status;\r\nunsigned long end;\r\ndprintk(1, "\n");\r\nmutex_lock(&state->mutex);\r\nstatus = write16(state, SIO_BL_MODE__A, SIO_BL_MODE_CHAIN);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SIO_BL_CHAIN_ADDR__A, romOffset);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SIO_BL_CHAIN_LEN__A, nrOfElements);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SIO_BL_ENABLE__A, SIO_BL_ENABLE_ON);\r\nif (status < 0)\r\ngoto error;\r\nend = jiffies + msecs_to_jiffies(timeOut);\r\ndo {\r\nmsleep(1);\r\nstatus = read16(state, SIO_BL_STATUS__A, &blStatus);\r\nif (status < 0)\r\ngoto error;\r\n} while ((blStatus == 0x1) &&\r\n((time_is_after_jiffies(end))));\r\nif (blStatus == 0x1) {\r\nprintk(KERN_ERR "drxk: SIO not ready\n");\r\nstatus = -EINVAL;\r\ngoto error2;\r\n}\r\nerror:\r\nif (status < 0)\r\nprintk(KERN_ERR "drxk: Error %d on %s\n", status, __func__);\r\nerror2:\r\nmutex_unlock(&state->mutex);\r\nreturn status;\r\n}\r\nstatic int DownloadMicrocode(struct drxk_state *state,\r\nconst u8 pMCImage[], u32 Length)\r\n{\r\nconst u8 *pSrc = pMCImage;\r\nu32 Address;\r\nu16 nBlocks;\r\nu16 BlockSize;\r\nu32 offset = 0;\r\nu32 i;\r\nint status = 0;\r\ndprintk(1, "\n");\r\n#if 0\r\nDrain = (pSrc[0] << 8) | pSrc[1];\r\n#endif\r\npSrc += sizeof(u16);\r\noffset += sizeof(u16);\r\nnBlocks = (pSrc[0] << 8) | pSrc[1];\r\npSrc += sizeof(u16);\r\noffset += sizeof(u16);\r\nfor (i = 0; i < nBlocks; i += 1) {\r\nAddress = (pSrc[0] << 24) | (pSrc[1] << 16) |\r\n(pSrc[2] << 8) | pSrc[3];\r\npSrc += sizeof(u32);\r\noffset += sizeof(u32);\r\nBlockSize = ((pSrc[0] << 8) | pSrc[1]) * sizeof(u16);\r\npSrc += sizeof(u16);\r\noffset += sizeof(u16);\r\n#if 0\r\nFlags = (pSrc[0] << 8) | pSrc[1];\r\n#endif\r\npSrc += sizeof(u16);\r\noffset += sizeof(u16);\r\n#if 0\r\nBlockCRC = (pSrc[0] << 8) | pSrc[1];\r\n#endif\r\npSrc += sizeof(u16);\r\noffset += sizeof(u16);\r\nif (offset + BlockSize > Length) {\r\nprintk(KERN_ERR "drxk: Firmware is corrupted.\n");\r\nreturn -EINVAL;\r\n}\r\nstatus = write_block(state, Address, BlockSize, pSrc);\r\nif (status < 0) {\r\nprintk(KERN_ERR "drxk: Error %d while loading firmware\n", status);\r\nbreak;\r\n}\r\npSrc += BlockSize;\r\noffset += BlockSize;\r\n}\r\nreturn status;\r\n}\r\nstatic int DVBTEnableOFDMTokenRing(struct drxk_state *state, bool enable)\r\n{\r\nint status;\r\nu16 data = 0;\r\nu16 desiredCtrl = SIO_OFDM_SH_OFDM_RING_ENABLE_ON;\r\nu16 desiredStatus = SIO_OFDM_SH_OFDM_RING_STATUS_ENABLED;\r\nunsigned long end;\r\ndprintk(1, "\n");\r\nif (enable == false) {\r\ndesiredCtrl = SIO_OFDM_SH_OFDM_RING_ENABLE_OFF;\r\ndesiredStatus = SIO_OFDM_SH_OFDM_RING_STATUS_DOWN;\r\n}\r\nstatus = read16(state, SIO_OFDM_SH_OFDM_RING_STATUS__A, &data);\r\nif (status >= 0 && data == desiredStatus) {\r\nreturn status;\r\n}\r\nstatus = write16(state, SIO_OFDM_SH_OFDM_RING_ENABLE__A, desiredCtrl);\r\nend = jiffies + msecs_to_jiffies(DRXK_OFDM_TR_SHUTDOWN_TIMEOUT);\r\ndo {\r\nstatus = read16(state, SIO_OFDM_SH_OFDM_RING_STATUS__A, &data);\r\nif ((status >= 0 && data == desiredStatus) || time_is_after_jiffies(end))\r\nbreak;\r\nmsleep(1);\r\n} while (1);\r\nif (data != desiredStatus) {\r\nprintk(KERN_ERR "drxk: SIO not ready\n");\r\nreturn -EINVAL;\r\n}\r\nreturn status;\r\n}\r\nstatic int MPEGTSStop(struct drxk_state *state)\r\n{\r\nint status = 0;\r\nu16 fecOcSncMode = 0;\r\nu16 fecOcIprMode = 0;\r\ndprintk(1, "\n");\r\nstatus = read16(state, FEC_OC_SNC_MODE__A, &fecOcSncMode);\r\nif (status < 0)\r\ngoto error;\r\nfecOcSncMode |= FEC_OC_SNC_MODE_SHUTDOWN__M;\r\nstatus = write16(state, FEC_OC_SNC_MODE__A, fecOcSncMode);\r\nif (status < 0)\r\ngoto error;\r\nstatus = read16(state, FEC_OC_IPR_MODE__A, &fecOcIprMode);\r\nif (status < 0)\r\ngoto error;\r\nfecOcIprMode |= FEC_OC_IPR_MODE_MCLK_DIS_DAT_ABS__M;\r\nstatus = write16(state, FEC_OC_IPR_MODE__A, fecOcIprMode);\r\nerror:\r\nif (status < 0)\r\nprintk(KERN_ERR "drxk: Error %d on %s\n", status, __func__);\r\nreturn status;\r\n}\r\nstatic int scu_command(struct drxk_state *state,\r\nu16 cmd, u8 parameterLen,\r\nu16 *parameter, u8 resultLen, u16 *result)\r\n{\r\n#if (SCU_RAM_PARAM_0__A - SCU_RAM_PARAM_15__A) != 15\r\n#error DRXK register mapping no longer compatible with this routine!\r\n#endif\r\nu16 curCmd = 0;\r\nint status = -EINVAL;\r\nunsigned long end;\r\nu8 buffer[34];\r\nint cnt = 0, ii;\r\nconst char *p;\r\nchar errname[30];\r\ndprintk(1, "\n");\r\nif ((cmd == 0) || ((parameterLen > 0) && (parameter == NULL)) ||\r\n((resultLen > 0) && (result == NULL))) {\r\nprintk(KERN_ERR "drxk: Error %d on %s\n", status, __func__);\r\nreturn status;\r\n}\r\nmutex_lock(&state->mutex);\r\nfor (ii = parameterLen - 1; ii >= 0; ii -= 1) {\r\nbuffer[cnt++] = (parameter[ii] & 0xFF);\r\nbuffer[cnt++] = ((parameter[ii] >> 8) & 0xFF);\r\n}\r\nbuffer[cnt++] = (cmd & 0xFF);\r\nbuffer[cnt++] = ((cmd >> 8) & 0xFF);\r\nwrite_block(state, SCU_RAM_PARAM_0__A -\r\n(parameterLen - 1), cnt, buffer);\r\nend = jiffies + msecs_to_jiffies(DRXK_MAX_WAITTIME);\r\ndo {\r\nmsleep(1);\r\nstatus = read16(state, SCU_RAM_COMMAND__A, &curCmd);\r\nif (status < 0)\r\ngoto error;\r\n} while (!(curCmd == DRX_SCU_READY) && (time_is_after_jiffies(end)));\r\nif (curCmd != DRX_SCU_READY) {\r\nprintk(KERN_ERR "drxk: SCU not ready\n");\r\nstatus = -EIO;\r\ngoto error2;\r\n}\r\nif ((resultLen > 0) && (result != NULL)) {\r\ns16 err;\r\nint ii;\r\nfor (ii = resultLen - 1; ii >= 0; ii -= 1) {\r\nstatus = read16(state, SCU_RAM_PARAM_0__A - ii, &result[ii]);\r\nif (status < 0)\r\ngoto error;\r\n}\r\nerr = (s16)result[0];\r\nif (err >= 0)\r\ngoto error;\r\nswitch (err) {\r\ncase SCU_RESULT_UNKCMD:\r\np = "SCU_RESULT_UNKCMD";\r\nbreak;\r\ncase SCU_RESULT_UNKSTD:\r\np = "SCU_RESULT_UNKSTD";\r\nbreak;\r\ncase SCU_RESULT_SIZE:\r\np = "SCU_RESULT_SIZE";\r\nbreak;\r\ncase SCU_RESULT_INVPAR:\r\np = "SCU_RESULT_INVPAR";\r\nbreak;\r\ndefault:\r\nsprintf(errname, "ERROR: %d\n", err);\r\np = errname;\r\n}\r\nprintk(KERN_ERR "drxk: %s while sending cmd 0x%04x with params:", p, cmd);\r\nprint_hex_dump_bytes("drxk: ", DUMP_PREFIX_NONE, buffer, cnt);\r\nstatus = -EINVAL;\r\ngoto error2;\r\n}\r\nerror:\r\nif (status < 0)\r\nprintk(KERN_ERR "drxk: Error %d on %s\n", status, __func__);\r\nerror2:\r\nmutex_unlock(&state->mutex);\r\nreturn status;\r\n}\r\nstatic int SetIqmAf(struct drxk_state *state, bool active)\r\n{\r\nu16 data = 0;\r\nint status;\r\ndprintk(1, "\n");\r\nstatus = read16(state, IQM_AF_STDBY__A, &data);\r\nif (status < 0)\r\ngoto error;\r\nif (!active) {\r\ndata |= (IQM_AF_STDBY_STDBY_ADC_STANDBY\r\n| IQM_AF_STDBY_STDBY_AMP_STANDBY\r\n| IQM_AF_STDBY_STDBY_PD_STANDBY\r\n| IQM_AF_STDBY_STDBY_TAGC_IF_STANDBY\r\n| IQM_AF_STDBY_STDBY_TAGC_RF_STANDBY);\r\n} else {\r\ndata &= ((~IQM_AF_STDBY_STDBY_ADC_STANDBY)\r\n& (~IQM_AF_STDBY_STDBY_AMP_STANDBY)\r\n& (~IQM_AF_STDBY_STDBY_PD_STANDBY)\r\n& (~IQM_AF_STDBY_STDBY_TAGC_IF_STANDBY)\r\n& (~IQM_AF_STDBY_STDBY_TAGC_RF_STANDBY)\r\n);\r\n}\r\nstatus = write16(state, IQM_AF_STDBY__A, data);\r\nerror:\r\nif (status < 0)\r\nprintk(KERN_ERR "drxk: Error %d on %s\n", status, __func__);\r\nreturn status;\r\n}\r\nstatic int CtrlPowerMode(struct drxk_state *state, enum DRXPowerMode *mode)\r\n{\r\nint status = 0;\r\nu16 sioCcPwdMode = 0;\r\ndprintk(1, "\n");\r\nif (mode == NULL)\r\nreturn -EINVAL;\r\nswitch (*mode) {\r\ncase DRX_POWER_UP:\r\nsioCcPwdMode = SIO_CC_PWD_MODE_LEVEL_NONE;\r\nbreak;\r\ncase DRXK_POWER_DOWN_OFDM:\r\nsioCcPwdMode = SIO_CC_PWD_MODE_LEVEL_OFDM;\r\nbreak;\r\ncase DRXK_POWER_DOWN_CORE:\r\nsioCcPwdMode = SIO_CC_PWD_MODE_LEVEL_CLOCK;\r\nbreak;\r\ncase DRXK_POWER_DOWN_PLL:\r\nsioCcPwdMode = SIO_CC_PWD_MODE_LEVEL_PLL;\r\nbreak;\r\ncase DRX_POWER_DOWN:\r\nsioCcPwdMode = SIO_CC_PWD_MODE_LEVEL_OSC;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (state->m_currentPowerMode == *mode)\r\nreturn 0;\r\nif (state->m_currentPowerMode != DRX_POWER_UP) {\r\nstatus = PowerUpDevice(state);\r\nif (status < 0)\r\ngoto error;\r\nstatus = DVBTEnableOFDMTokenRing(state, true);\r\nif (status < 0)\r\ngoto error;\r\n}\r\nif (*mode == DRX_POWER_UP) {\r\n} else {\r\nswitch (state->m_OperationMode) {\r\ncase OM_DVBT:\r\nstatus = MPEGTSStop(state);\r\nif (status < 0)\r\ngoto error;\r\nstatus = PowerDownDVBT(state, false);\r\nif (status < 0)\r\ngoto error;\r\nbreak;\r\ncase OM_QAM_ITU_A:\r\ncase OM_QAM_ITU_C:\r\nstatus = MPEGTSStop(state);\r\nif (status < 0)\r\ngoto error;\r\nstatus = PowerDownQAM(state);\r\nif (status < 0)\r\ngoto error;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nstatus = DVBTEnableOFDMTokenRing(state, false);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SIO_CC_PWD_MODE__A, sioCcPwdMode);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SIO_CC_UPDATE__A, SIO_CC_UPDATE_KEY);\r\nif (status < 0)\r\ngoto error;\r\nif (*mode != DRXK_POWER_DOWN_OFDM) {\r\nstate->m_HICfgCtrl |=\r\nSIO_HI_RA_RAM_PAR_5_CFG_SLEEP_ZZZ;\r\nstatus = HI_CfgCommand(state);\r\nif (status < 0)\r\ngoto error;\r\n}\r\n}\r\nstate->m_currentPowerMode = *mode;\r\nerror:\r\nif (status < 0)\r\nprintk(KERN_ERR "drxk: Error %d on %s\n", status, __func__);\r\nreturn status;\r\n}\r\nstatic int PowerDownDVBT(struct drxk_state *state, bool setPowerMode)\r\n{\r\nenum DRXPowerMode powerMode = DRXK_POWER_DOWN_OFDM;\r\nu16 cmdResult = 0;\r\nu16 data = 0;\r\nint status;\r\ndprintk(1, "\n");\r\nstatus = read16(state, SCU_COMM_EXEC__A, &data);\r\nif (status < 0)\r\ngoto error;\r\nif (data == SCU_COMM_EXEC_ACTIVE) {\r\nstatus = scu_command(state, SCU_RAM_COMMAND_STANDARD_OFDM | SCU_RAM_COMMAND_CMD_DEMOD_STOP, 0, NULL, 1, &cmdResult);\r\nif (status < 0)\r\ngoto error;\r\nstatus = scu_command(state, SCU_RAM_COMMAND_STANDARD_OFDM | SCU_RAM_COMMAND_CMD_DEMOD_RESET, 0, NULL, 1, &cmdResult);\r\nif (status < 0)\r\ngoto error;\r\n}\r\nstatus = write16(state, OFDM_SC_COMM_EXEC__A, OFDM_SC_COMM_EXEC_STOP);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, OFDM_LC_COMM_EXEC__A, OFDM_LC_COMM_EXEC_STOP);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, IQM_COMM_EXEC__A, IQM_COMM_EXEC_B_STOP);\r\nif (status < 0)\r\ngoto error;\r\nstatus = SetIqmAf(state, false);\r\nif (status < 0)\r\ngoto error;\r\nif (setPowerMode) {\r\nstatus = CtrlPowerMode(state, &powerMode);\r\nif (status < 0)\r\ngoto error;\r\n}\r\nerror:\r\nif (status < 0)\r\nprintk(KERN_ERR "drxk: Error %d on %s\n", status, __func__);\r\nreturn status;\r\n}\r\nstatic int SetOperationMode(struct drxk_state *state,\r\nenum OperationMode oMode)\r\n{\r\nint status = 0;\r\ndprintk(1, "\n");\r\nstatus = write16(state, SCU_RAM_GPIO__A, SCU_RAM_GPIO_HW_LOCK_IND_DISABLE);\r\nif (status < 0)\r\ngoto error;\r\nif (state->m_OperationMode == oMode)\r\nreturn 0;\r\nswitch (state->m_OperationMode) {\r\ncase OM_NONE:\r\nbreak;\r\ncase OM_DVBT:\r\nstatus = MPEGTSStop(state);\r\nif (status < 0)\r\ngoto error;\r\nstatus = PowerDownDVBT(state, true);\r\nif (status < 0)\r\ngoto error;\r\nstate->m_OperationMode = OM_NONE;\r\nbreak;\r\ncase OM_QAM_ITU_A:\r\ncase OM_QAM_ITU_C:\r\nstatus = MPEGTSStop(state);\r\nif (status < 0)\r\ngoto error;\r\nstatus = PowerDownQAM(state);\r\nif (status < 0)\r\ngoto error;\r\nstate->m_OperationMode = OM_NONE;\r\nbreak;\r\ncase OM_QAM_ITU_B:\r\ndefault:\r\nstatus = -EINVAL;\r\ngoto error;\r\n}\r\nswitch (oMode) {\r\ncase OM_DVBT:\r\ndprintk(1, ": DVB-T\n");\r\nstate->m_OperationMode = oMode;\r\nstatus = SetDVBTStandard(state, oMode);\r\nif (status < 0)\r\ngoto error;\r\nbreak;\r\ncase OM_QAM_ITU_A:\r\ncase OM_QAM_ITU_C:\r\ndprintk(1, ": DVB-C Annex %c\n",\r\n(state->m_OperationMode == OM_QAM_ITU_A) ? 'A' : 'C');\r\nstate->m_OperationMode = oMode;\r\nstatus = SetQAMStandard(state, oMode);\r\nif (status < 0)\r\ngoto error;\r\nbreak;\r\ncase OM_QAM_ITU_B:\r\ndefault:\r\nstatus = -EINVAL;\r\n}\r\nerror:\r\nif (status < 0)\r\nprintk(KERN_ERR "drxk: Error %d on %s\n", status, __func__);\r\nreturn status;\r\n}\r\nstatic int Start(struct drxk_state *state, s32 offsetFreq,\r\ns32 IntermediateFrequency)\r\n{\r\nint status = -EINVAL;\r\nu16 IFreqkHz;\r\ns32 OffsetkHz = offsetFreq / 1000;\r\ndprintk(1, "\n");\r\nif (state->m_DrxkState != DRXK_STOPPED &&\r\nstate->m_DrxkState != DRXK_DTV_STARTED)\r\ngoto error;\r\nstate->m_bMirrorFreqSpect = (state->props.inversion == INVERSION_ON);\r\nif (IntermediateFrequency < 0) {\r\nstate->m_bMirrorFreqSpect = !state->m_bMirrorFreqSpect;\r\nIntermediateFrequency = -IntermediateFrequency;\r\n}\r\nswitch (state->m_OperationMode) {\r\ncase OM_QAM_ITU_A:\r\ncase OM_QAM_ITU_C:\r\nIFreqkHz = (IntermediateFrequency / 1000);\r\nstatus = SetQAM(state, IFreqkHz, OffsetkHz);\r\nif (status < 0)\r\ngoto error;\r\nstate->m_DrxkState = DRXK_DTV_STARTED;\r\nbreak;\r\ncase OM_DVBT:\r\nIFreqkHz = (IntermediateFrequency / 1000);\r\nstatus = MPEGTSStop(state);\r\nif (status < 0)\r\ngoto error;\r\nstatus = SetDVBT(state, IFreqkHz, OffsetkHz);\r\nif (status < 0)\r\ngoto error;\r\nstatus = DVBTStart(state);\r\nif (status < 0)\r\ngoto error;\r\nstate->m_DrxkState = DRXK_DTV_STARTED;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nerror:\r\nif (status < 0)\r\nprintk(KERN_ERR "drxk: Error %d on %s\n", status, __func__);\r\nreturn status;\r\n}\r\nstatic int ShutDown(struct drxk_state *state)\r\n{\r\ndprintk(1, "\n");\r\nMPEGTSStop(state);\r\nreturn 0;\r\n}\r\nstatic int GetLockStatus(struct drxk_state *state, u32 *pLockStatus,\r\nu32 Time)\r\n{\r\nint status = -EINVAL;\r\ndprintk(1, "\n");\r\nif (pLockStatus == NULL)\r\ngoto error;\r\n*pLockStatus = NOT_LOCKED;\r\nswitch (state->m_OperationMode) {\r\ncase OM_QAM_ITU_A:\r\ncase OM_QAM_ITU_B:\r\ncase OM_QAM_ITU_C:\r\nstatus = GetQAMLockStatus(state, pLockStatus);\r\nbreak;\r\ncase OM_DVBT:\r\nstatus = GetDVBTLockStatus(state, pLockStatus);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nerror:\r\nif (status < 0)\r\nprintk(KERN_ERR "drxk: Error %d on %s\n", status, __func__);\r\nreturn status;\r\n}\r\nstatic int MPEGTSStart(struct drxk_state *state)\r\n{\r\nint status;\r\nu16 fecOcSncMode = 0;\r\nstatus = read16(state, FEC_OC_SNC_MODE__A, &fecOcSncMode);\r\nif (status < 0)\r\ngoto error;\r\nfecOcSncMode &= ~FEC_OC_SNC_MODE_SHUTDOWN__M;\r\nstatus = write16(state, FEC_OC_SNC_MODE__A, fecOcSncMode);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, FEC_OC_SNC_UNLOCK__A, 1);\r\nerror:\r\nif (status < 0)\r\nprintk(KERN_ERR "drxk: Error %d on %s\n", status, __func__);\r\nreturn status;\r\n}\r\nstatic int MPEGTSDtoInit(struct drxk_state *state)\r\n{\r\nint status;\r\ndprintk(1, "\n");\r\nstatus = write16(state, FEC_OC_RCN_CTL_STEP_LO__A, 0x0000);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, FEC_OC_RCN_CTL_STEP_HI__A, 0x000C);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, FEC_OC_RCN_GAIN__A, 0x000A);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, FEC_OC_AVR_PARM_A__A, 0x0008);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, FEC_OC_AVR_PARM_B__A, 0x0006);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, FEC_OC_TMD_HI_MARGIN__A, 0x0680);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, FEC_OC_TMD_LO_MARGIN__A, 0x0080);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, FEC_OC_TMD_COUNT__A, 0x03F4);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, FEC_OC_OCR_INVERT__A, 0);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, FEC_OC_SNC_LWM__A, 2);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, FEC_OC_SNC_HWM__A, 12);\r\nerror:\r\nif (status < 0)\r\nprintk(KERN_ERR "drxk: Error %d on %s\n", status, __func__);\r\nreturn status;\r\n}\r\nstatic int MPEGTSDtoSetup(struct drxk_state *state,\r\nenum OperationMode oMode)\r\n{\r\nint status;\r\nu16 fecOcRegMode = 0;\r\nu16 fecOcRegIprMode = 0;\r\nu16 fecOcDtoMode = 0;\r\nu16 fecOcFctMode = 0;\r\nu16 fecOcDtoPeriod = 2;\r\nu16 fecOcDtoBurstLen = 188;\r\nu32 fecOcRcnCtlRate = 0;\r\nu16 fecOcTmdMode = 0;\r\nu16 fecOcTmdIntUpdRate = 0;\r\nu32 maxBitRate = 0;\r\nbool staticCLK = false;\r\ndprintk(1, "\n");\r\nstatus = read16(state, FEC_OC_MODE__A, &fecOcRegMode);\r\nif (status < 0)\r\ngoto error;\r\nstatus = read16(state, FEC_OC_IPR_MODE__A, &fecOcRegIprMode);\r\nif (status < 0)\r\ngoto error;\r\nfecOcRegMode &= (~FEC_OC_MODE_PARITY__M);\r\nfecOcRegIprMode &= (~FEC_OC_IPR_MODE_MVAL_DIS_PAR__M);\r\nif (state->m_insertRSByte == true) {\r\nfecOcRegMode |= FEC_OC_MODE_PARITY__M;\r\nfecOcRegIprMode |= FEC_OC_IPR_MODE_MVAL_DIS_PAR__M;\r\nfecOcDtoBurstLen = 204;\r\n}\r\nfecOcRegIprMode &= (~(FEC_OC_IPR_MODE_SERIAL__M));\r\nif (state->m_enableParallel == false) {\r\nfecOcRegIprMode |= FEC_OC_IPR_MODE_SERIAL__M;\r\n}\r\nswitch (oMode) {\r\ncase OM_DVBT:\r\nmaxBitRate = state->m_DVBTBitrate;\r\nfecOcTmdMode = 3;\r\nfecOcRcnCtlRate = 0xC00000;\r\nstaticCLK = state->m_DVBTStaticCLK;\r\nbreak;\r\ncase OM_QAM_ITU_A:\r\ncase OM_QAM_ITU_C:\r\nfecOcTmdMode = 0x0004;\r\nfecOcRcnCtlRate = 0xD2B4EE;\r\nmaxBitRate = state->m_DVBCBitrate;\r\nstaticCLK = state->m_DVBCStaticCLK;\r\nbreak;\r\ndefault:\r\nstatus = -EINVAL;\r\n}\r\nif (status < 0)\r\ngoto error;\r\nif (staticCLK) {\r\nu32 bitRate = 0;\r\nfecOcDtoMode = (FEC_OC_DTO_MODE_DYNAMIC__M |\r\nFEC_OC_DTO_MODE_OFFSET_ENABLE__M);\r\nfecOcFctMode = (FEC_OC_FCT_MODE_RAT_ENA__M |\r\nFEC_OC_FCT_MODE_VIRT_ENA__M);\r\nbitRate = maxBitRate;\r\nif (bitRate > 75900000UL) {\r\nbitRate = 75900000UL;\r\n}\r\nfecOcDtoPeriod = (u16) (((state->m_sysClockFreq)\r\n* 1000) / bitRate);\r\nif (fecOcDtoPeriod <= 2)\r\nfecOcDtoPeriod = 0;\r\nelse\r\nfecOcDtoPeriod -= 2;\r\nfecOcTmdIntUpdRate = 8;\r\n} else {\r\nfecOcDtoMode = FEC_OC_DTO_MODE_DYNAMIC__M;\r\nfecOcFctMode = FEC_OC_FCT_MODE__PRE;\r\nfecOcTmdIntUpdRate = 5;\r\n}\r\nstatus = write16(state, FEC_OC_DTO_BURST_LEN__A, fecOcDtoBurstLen);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, FEC_OC_DTO_PERIOD__A, fecOcDtoPeriod);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, FEC_OC_DTO_MODE__A, fecOcDtoMode);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, FEC_OC_FCT_MODE__A, fecOcFctMode);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, FEC_OC_MODE__A, fecOcRegMode);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, FEC_OC_IPR_MODE__A, fecOcRegIprMode);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write32(state, FEC_OC_RCN_CTL_RATE_LO__A, fecOcRcnCtlRate);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, FEC_OC_TMD_INT_UPD_RATE__A, fecOcTmdIntUpdRate);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, FEC_OC_TMD_MODE__A, fecOcTmdMode);\r\nerror:\r\nif (status < 0)\r\nprintk(KERN_ERR "drxk: Error %d on %s\n", status, __func__);\r\nreturn status;\r\n}\r\nstatic int MPEGTSConfigurePolarity(struct drxk_state *state)\r\n{\r\nu16 fecOcRegIprInvert = 0;\r\nu16 InvertDataMask =\r\nFEC_OC_IPR_INVERT_MD7__M | FEC_OC_IPR_INVERT_MD6__M |\r\nFEC_OC_IPR_INVERT_MD5__M | FEC_OC_IPR_INVERT_MD4__M |\r\nFEC_OC_IPR_INVERT_MD3__M | FEC_OC_IPR_INVERT_MD2__M |\r\nFEC_OC_IPR_INVERT_MD1__M | FEC_OC_IPR_INVERT_MD0__M;\r\ndprintk(1, "\n");\r\nfecOcRegIprInvert &= (~(InvertDataMask));\r\nif (state->m_invertDATA == true)\r\nfecOcRegIprInvert |= InvertDataMask;\r\nfecOcRegIprInvert &= (~(FEC_OC_IPR_INVERT_MERR__M));\r\nif (state->m_invertERR == true)\r\nfecOcRegIprInvert |= FEC_OC_IPR_INVERT_MERR__M;\r\nfecOcRegIprInvert &= (~(FEC_OC_IPR_INVERT_MSTRT__M));\r\nif (state->m_invertSTR == true)\r\nfecOcRegIprInvert |= FEC_OC_IPR_INVERT_MSTRT__M;\r\nfecOcRegIprInvert &= (~(FEC_OC_IPR_INVERT_MVAL__M));\r\nif (state->m_invertVAL == true)\r\nfecOcRegIprInvert |= FEC_OC_IPR_INVERT_MVAL__M;\r\nfecOcRegIprInvert &= (~(FEC_OC_IPR_INVERT_MCLK__M));\r\nif (state->m_invertCLK == true)\r\nfecOcRegIprInvert |= FEC_OC_IPR_INVERT_MCLK__M;\r\nreturn write16(state, FEC_OC_IPR_INVERT__A, fecOcRegIprInvert);\r\n}\r\nstatic int SetAgcRf(struct drxk_state *state,\r\nstruct SCfgAgc *pAgcCfg, bool isDTV)\r\n{\r\nint status = -EINVAL;\r\nu16 data = 0;\r\nstruct SCfgAgc *pIfAgcSettings;\r\ndprintk(1, "\n");\r\nif (pAgcCfg == NULL)\r\ngoto error;\r\nswitch (pAgcCfg->ctrlMode) {\r\ncase DRXK_AGC_CTRL_AUTO:\r\nstatus = read16(state, IQM_AF_STDBY__A, &data);\r\nif (status < 0)\r\ngoto error;\r\ndata &= ~IQM_AF_STDBY_STDBY_TAGC_RF_STANDBY;\r\nstatus = write16(state, IQM_AF_STDBY__A, data);\r\nif (status < 0)\r\ngoto error;\r\nstatus = read16(state, SCU_RAM_AGC_CONFIG__A, &data);\r\nif (status < 0)\r\ngoto error;\r\ndata &= ~SCU_RAM_AGC_CONFIG_DISABLE_RF_AGC__M;\r\nif (state->m_RfAgcPol)\r\ndata |= SCU_RAM_AGC_CONFIG_INV_RF_POL__M;\r\nelse\r\ndata &= ~SCU_RAM_AGC_CONFIG_INV_RF_POL__M;\r\nstatus = write16(state, SCU_RAM_AGC_CONFIG__A, data);\r\nif (status < 0)\r\ngoto error;\r\nstatus = read16(state, SCU_RAM_AGC_KI_RED__A, &data);\r\nif (status < 0)\r\ngoto error;\r\ndata &= ~SCU_RAM_AGC_KI_RED_RAGC_RED__M;\r\ndata |= (~(pAgcCfg->speed <<\r\nSCU_RAM_AGC_KI_RED_RAGC_RED__B)\r\n& SCU_RAM_AGC_KI_RED_RAGC_RED__M);\r\nstatus = write16(state, SCU_RAM_AGC_KI_RED__A, data);\r\nif (status < 0)\r\ngoto error;\r\nif (IsDVBT(state))\r\npIfAgcSettings = &state->m_dvbtIfAgcCfg;\r\nelse if (IsQAM(state))\r\npIfAgcSettings = &state->m_qamIfAgcCfg;\r\nelse\r\npIfAgcSettings = &state->m_atvIfAgcCfg;\r\nif (pIfAgcSettings == NULL) {\r\nstatus = -EINVAL;\r\ngoto error;\r\n}\r\nif (pIfAgcSettings->ctrlMode == DRXK_AGC_CTRL_AUTO)\r\nstatus = write16(state, SCU_RAM_AGC_IF_IACCU_HI_TGT_MAX__A, pAgcCfg->top);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_AGC_RF_IACCU_HI_CO__A, pAgcCfg->cutOffCurrent);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_AGC_RF_MAX__A, pAgcCfg->maxOutputLevel);\r\nif (status < 0)\r\ngoto error;\r\nbreak;\r\ncase DRXK_AGC_CTRL_USER:\r\nstatus = read16(state, IQM_AF_STDBY__A, &data);\r\nif (status < 0)\r\ngoto error;\r\ndata &= ~IQM_AF_STDBY_STDBY_TAGC_RF_STANDBY;\r\nstatus = write16(state, IQM_AF_STDBY__A, data);\r\nif (status < 0)\r\ngoto error;\r\nstatus = read16(state, SCU_RAM_AGC_CONFIG__A, &data);\r\nif (status < 0)\r\ngoto error;\r\ndata |= SCU_RAM_AGC_CONFIG_DISABLE_RF_AGC__M;\r\nif (state->m_RfAgcPol)\r\ndata |= SCU_RAM_AGC_CONFIG_INV_RF_POL__M;\r\nelse\r\ndata &= ~SCU_RAM_AGC_CONFIG_INV_RF_POL__M;\r\nstatus = write16(state, SCU_RAM_AGC_CONFIG__A, data);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_AGC_RF_IACCU_HI_CO__A, 0);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_AGC_RF_IACCU_HI__A, pAgcCfg->outputLevel);\r\nif (status < 0)\r\ngoto error;\r\nbreak;\r\ncase DRXK_AGC_CTRL_OFF:\r\nstatus = read16(state, IQM_AF_STDBY__A, &data);\r\nif (status < 0)\r\ngoto error;\r\ndata |= IQM_AF_STDBY_STDBY_TAGC_RF_STANDBY;\r\nstatus = write16(state, IQM_AF_STDBY__A, data);\r\nif (status < 0)\r\ngoto error;\r\nstatus = read16(state, SCU_RAM_AGC_CONFIG__A, &data);\r\nif (status < 0)\r\ngoto error;\r\ndata |= SCU_RAM_AGC_CONFIG_DISABLE_RF_AGC__M;\r\nstatus = write16(state, SCU_RAM_AGC_CONFIG__A, data);\r\nif (status < 0)\r\ngoto error;\r\nbreak;\r\ndefault:\r\nstatus = -EINVAL;\r\n}\r\nerror:\r\nif (status < 0)\r\nprintk(KERN_ERR "drxk: Error %d on %s\n", status, __func__);\r\nreturn status;\r\n}\r\nstatic int SetAgcIf(struct drxk_state *state,\r\nstruct SCfgAgc *pAgcCfg, bool isDTV)\r\n{\r\nu16 data = 0;\r\nint status = 0;\r\nstruct SCfgAgc *pRfAgcSettings;\r\ndprintk(1, "\n");\r\nswitch (pAgcCfg->ctrlMode) {\r\ncase DRXK_AGC_CTRL_AUTO:\r\nstatus = read16(state, IQM_AF_STDBY__A, &data);\r\nif (status < 0)\r\ngoto error;\r\ndata &= ~IQM_AF_STDBY_STDBY_TAGC_IF_STANDBY;\r\nstatus = write16(state, IQM_AF_STDBY__A, data);\r\nif (status < 0)\r\ngoto error;\r\nstatus = read16(state, SCU_RAM_AGC_CONFIG__A, &data);\r\nif (status < 0)\r\ngoto error;\r\ndata &= ~SCU_RAM_AGC_CONFIG_DISABLE_IF_AGC__M;\r\nif (state->m_IfAgcPol)\r\ndata |= SCU_RAM_AGC_CONFIG_INV_IF_POL__M;\r\nelse\r\ndata &= ~SCU_RAM_AGC_CONFIG_INV_IF_POL__M;\r\nstatus = write16(state, SCU_RAM_AGC_CONFIG__A, data);\r\nif (status < 0)\r\ngoto error;\r\nstatus = read16(state, SCU_RAM_AGC_KI_RED__A, &data);\r\nif (status < 0)\r\ngoto error;\r\ndata &= ~SCU_RAM_AGC_KI_RED_IAGC_RED__M;\r\ndata |= (~(pAgcCfg->speed <<\r\nSCU_RAM_AGC_KI_RED_IAGC_RED__B)\r\n& SCU_RAM_AGC_KI_RED_IAGC_RED__M);\r\nstatus = write16(state, SCU_RAM_AGC_KI_RED__A, data);\r\nif (status < 0)\r\ngoto error;\r\nif (IsQAM(state))\r\npRfAgcSettings = &state->m_qamRfAgcCfg;\r\nelse\r\npRfAgcSettings = &state->m_atvRfAgcCfg;\r\nif (pRfAgcSettings == NULL)\r\nreturn -1;\r\nstatus = write16(state, SCU_RAM_AGC_IF_IACCU_HI_TGT_MAX__A, pRfAgcSettings->top);\r\nif (status < 0)\r\ngoto error;\r\nbreak;\r\ncase DRXK_AGC_CTRL_USER:\r\nstatus = read16(state, IQM_AF_STDBY__A, &data);\r\nif (status < 0)\r\ngoto error;\r\ndata &= ~IQM_AF_STDBY_STDBY_TAGC_IF_STANDBY;\r\nstatus = write16(state, IQM_AF_STDBY__A, data);\r\nif (status < 0)\r\ngoto error;\r\nstatus = read16(state, SCU_RAM_AGC_CONFIG__A, &data);\r\nif (status < 0)\r\ngoto error;\r\ndata |= SCU_RAM_AGC_CONFIG_DISABLE_IF_AGC__M;\r\nif (state->m_IfAgcPol)\r\ndata |= SCU_RAM_AGC_CONFIG_INV_IF_POL__M;\r\nelse\r\ndata &= ~SCU_RAM_AGC_CONFIG_INV_IF_POL__M;\r\nstatus = write16(state, SCU_RAM_AGC_CONFIG__A, data);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_AGC_IF_IACCU_HI_TGT_MAX__A, pAgcCfg->outputLevel);\r\nif (status < 0)\r\ngoto error;\r\nbreak;\r\ncase DRXK_AGC_CTRL_OFF:\r\nstatus = read16(state, IQM_AF_STDBY__A, &data);\r\nif (status < 0)\r\ngoto error;\r\ndata |= IQM_AF_STDBY_STDBY_TAGC_IF_STANDBY;\r\nstatus = write16(state, IQM_AF_STDBY__A, data);\r\nif (status < 0)\r\ngoto error;\r\nstatus = read16(state, SCU_RAM_AGC_CONFIG__A, &data);\r\nif (status < 0)\r\ngoto error;\r\ndata |= SCU_RAM_AGC_CONFIG_DISABLE_IF_AGC__M;\r\nstatus = write16(state, SCU_RAM_AGC_CONFIG__A, data);\r\nif (status < 0)\r\ngoto error;\r\nbreak;\r\n}\r\nstatus = write16(state, SCU_RAM_AGC_INGAIN_TGT_MIN__A, pAgcCfg->top);\r\nerror:\r\nif (status < 0)\r\nprintk(KERN_ERR "drxk: Error %d on %s\n", status, __func__);\r\nreturn status;\r\n}\r\nstatic int ReadIFAgc(struct drxk_state *state, u32 *pValue)\r\n{\r\nu16 agcDacLvl;\r\nint status;\r\nu16 Level = 0;\r\ndprintk(1, "\n");\r\nstatus = read16(state, IQM_AF_AGC_IF__A, &agcDacLvl);\r\nif (status < 0) {\r\nprintk(KERN_ERR "drxk: Error %d on %s\n", status, __func__);\r\nreturn status;\r\n}\r\n*pValue = 0;\r\nif (agcDacLvl > DRXK_AGC_DAC_OFFSET)\r\nLevel = agcDacLvl - DRXK_AGC_DAC_OFFSET;\r\nif (Level < 14000)\r\n*pValue = (14000 - Level) / 4;\r\nelse\r\n*pValue = 0;\r\nreturn status;\r\n}\r\nstatic int GetQAMSignalToNoise(struct drxk_state *state,\r\ns32 *pSignalToNoise)\r\n{\r\nint status = 0;\r\nu16 qamSlErrPower = 0;\r\nu32 qamSlSigPower = 0;\r\nu32 qamSlMer = 0;\r\ndprintk(1, "\n");\r\nstatus = read16(state, QAM_SL_ERR_POWER__A, &qamSlErrPower);\r\nif (status < 0) {\r\nprintk(KERN_ERR "drxk: Error %d on %s\n", status, __func__);\r\nreturn -EINVAL;\r\n}\r\nswitch (state->props.modulation) {\r\ncase QAM_16:\r\nqamSlSigPower = DRXK_QAM_SL_SIG_POWER_QAM16 << 2;\r\nbreak;\r\ncase QAM_32:\r\nqamSlSigPower = DRXK_QAM_SL_SIG_POWER_QAM32 << 2;\r\nbreak;\r\ncase QAM_64:\r\nqamSlSigPower = DRXK_QAM_SL_SIG_POWER_QAM64 << 2;\r\nbreak;\r\ncase QAM_128:\r\nqamSlSigPower = DRXK_QAM_SL_SIG_POWER_QAM128 << 2;\r\nbreak;\r\ndefault:\r\ncase QAM_256:\r\nqamSlSigPower = DRXK_QAM_SL_SIG_POWER_QAM256 << 2;\r\nbreak;\r\n}\r\nif (qamSlErrPower > 0) {\r\nqamSlMer = Log10Times100(qamSlSigPower) -\r\nLog10Times100((u32) qamSlErrPower);\r\n}\r\n*pSignalToNoise = qamSlMer;\r\nreturn status;\r\n}\r\nstatic int GetDVBTSignalToNoise(struct drxk_state *state,\r\ns32 *pSignalToNoise)\r\n{\r\nint status;\r\nu16 regData = 0;\r\nu32 EqRegTdSqrErrI = 0;\r\nu32 EqRegTdSqrErrQ = 0;\r\nu16 EqRegTdSqrErrExp = 0;\r\nu16 EqRegTdTpsPwrOfs = 0;\r\nu16 EqRegTdReqSmbCnt = 0;\r\nu32 tpsCnt = 0;\r\nu32 SqrErrIQ = 0;\r\nu32 a = 0;\r\nu32 b = 0;\r\nu32 c = 0;\r\nu32 iMER = 0;\r\nu16 transmissionParams = 0;\r\ndprintk(1, "\n");\r\nstatus = read16(state, OFDM_EQ_TOP_TD_TPS_PWR_OFS__A, &EqRegTdTpsPwrOfs);\r\nif (status < 0)\r\ngoto error;\r\nstatus = read16(state, OFDM_EQ_TOP_TD_REQ_SMB_CNT__A, &EqRegTdReqSmbCnt);\r\nif (status < 0)\r\ngoto error;\r\nstatus = read16(state, OFDM_EQ_TOP_TD_SQR_ERR_EXP__A, &EqRegTdSqrErrExp);\r\nif (status < 0)\r\ngoto error;\r\nstatus = read16(state, OFDM_EQ_TOP_TD_SQR_ERR_I__A, &regData);\r\nif (status < 0)\r\ngoto error;\r\nEqRegTdSqrErrI = (u32) regData;\r\nif ((EqRegTdSqrErrExp > 11) &&\r\n(EqRegTdSqrErrI < 0x00000FFFUL)) {\r\nEqRegTdSqrErrI += 0x00010000UL;\r\n}\r\nstatus = read16(state, OFDM_EQ_TOP_TD_SQR_ERR_Q__A, &regData);\r\nif (status < 0)\r\ngoto error;\r\nEqRegTdSqrErrQ = (u32) regData;\r\nif ((EqRegTdSqrErrExp > 11) &&\r\n(EqRegTdSqrErrQ < 0x00000FFFUL))\r\nEqRegTdSqrErrQ += 0x00010000UL;\r\nstatus = read16(state, OFDM_SC_RA_RAM_OP_PARAM__A, &transmissionParams);\r\nif (status < 0)\r\ngoto error;\r\nif ((EqRegTdTpsPwrOfs == 0) || (EqRegTdReqSmbCnt == 0))\r\niMER = 0;\r\nelse if ((EqRegTdSqrErrI + EqRegTdSqrErrQ) == 0) {\r\niMER = 0;\r\n} else {\r\nSqrErrIQ = (EqRegTdSqrErrI + EqRegTdSqrErrQ) <<\r\nEqRegTdSqrErrExp;\r\nif ((transmissionParams &\r\nOFDM_SC_RA_RAM_OP_PARAM_MODE__M)\r\n== OFDM_SC_RA_RAM_OP_PARAM_MODE_2K)\r\ntpsCnt = 17;\r\nelse\r\ntpsCnt = 68;\r\na = Log10Times100(EqRegTdTpsPwrOfs *\r\nEqRegTdTpsPwrOfs);\r\nb = Log10Times100(EqRegTdReqSmbCnt * tpsCnt);\r\nc = Log10Times100(SqrErrIQ);\r\niMER = a + b;\r\nif (iMER > c)\r\niMER -= c;\r\nelse\r\niMER = 0;\r\n}\r\n*pSignalToNoise = iMER;\r\nerror:\r\nif (status < 0)\r\nprintk(KERN_ERR "drxk: Error %d on %s\n", status, __func__);\r\nreturn status;\r\n}\r\nstatic int GetSignalToNoise(struct drxk_state *state, s32 *pSignalToNoise)\r\n{\r\ndprintk(1, "\n");\r\n*pSignalToNoise = 0;\r\nswitch (state->m_OperationMode) {\r\ncase OM_DVBT:\r\nreturn GetDVBTSignalToNoise(state, pSignalToNoise);\r\ncase OM_QAM_ITU_A:\r\ncase OM_QAM_ITU_C:\r\nreturn GetQAMSignalToNoise(state, pSignalToNoise);\r\ndefault:\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ConfigureI2CBridge(struct drxk_state *state, bool bEnableBridge)\r\n{\r\nint status = -EINVAL;\r\ndprintk(1, "\n");\r\nif (state->m_DrxkState == DRXK_UNINITIALIZED)\r\nreturn 0;\r\nif (state->m_DrxkState == DRXK_POWERED_DOWN)\r\ngoto error;\r\nif (state->no_i2c_bridge)\r\nreturn 0;\r\nstatus = write16(state, SIO_HI_RA_RAM_PAR_1__A, SIO_HI_RA_RAM_PAR_1_PAR1_SEC_KEY);\r\nif (status < 0)\r\ngoto error;\r\nif (bEnableBridge) {\r\nstatus = write16(state, SIO_HI_RA_RAM_PAR_2__A, SIO_HI_RA_RAM_PAR_2_BRD_CFG_CLOSED);\r\nif (status < 0)\r\ngoto error;\r\n} else {\r\nstatus = write16(state, SIO_HI_RA_RAM_PAR_2__A, SIO_HI_RA_RAM_PAR_2_BRD_CFG_OPEN);\r\nif (status < 0)\r\ngoto error;\r\n}\r\nstatus = HI_Command(state, SIO_HI_RA_RAM_CMD_BRDCTRL, 0);\r\nerror:\r\nif (status < 0)\r\nprintk(KERN_ERR "drxk: Error %d on %s\n", status, __func__);\r\nreturn status;\r\n}\r\nstatic int SetPreSaw(struct drxk_state *state,\r\nstruct SCfgPreSaw *pPreSawCfg)\r\n{\r\nint status = -EINVAL;\r\ndprintk(1, "\n");\r\nif ((pPreSawCfg == NULL)\r\n|| (pPreSawCfg->reference > IQM_AF_PDREF__M))\r\ngoto error;\r\nstatus = write16(state, IQM_AF_PDREF__A, pPreSawCfg->reference);\r\nerror:\r\nif (status < 0)\r\nprintk(KERN_ERR "drxk: Error %d on %s\n", status, __func__);\r\nreturn status;\r\n}\r\nstatic int BLDirectCmd(struct drxk_state *state, u32 targetAddr,\r\nu16 romOffset, u16 nrOfElements, u32 timeOut)\r\n{\r\nu16 blStatus = 0;\r\nu16 offset = (u16) ((targetAddr >> 0) & 0x00FFFF);\r\nu16 blockbank = (u16) ((targetAddr >> 16) & 0x000FFF);\r\nint status;\r\nunsigned long end;\r\ndprintk(1, "\n");\r\nmutex_lock(&state->mutex);\r\nstatus = write16(state, SIO_BL_MODE__A, SIO_BL_MODE_DIRECT);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SIO_BL_TGT_HDR__A, blockbank);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SIO_BL_TGT_ADDR__A, offset);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SIO_BL_SRC_ADDR__A, romOffset);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SIO_BL_SRC_LEN__A, nrOfElements);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SIO_BL_ENABLE__A, SIO_BL_ENABLE_ON);\r\nif (status < 0)\r\ngoto error;\r\nend = jiffies + msecs_to_jiffies(timeOut);\r\ndo {\r\nstatus = read16(state, SIO_BL_STATUS__A, &blStatus);\r\nif (status < 0)\r\ngoto error;\r\n} while ((blStatus == 0x1) && time_is_after_jiffies(end));\r\nif (blStatus == 0x1) {\r\nprintk(KERN_ERR "drxk: SIO not ready\n");\r\nstatus = -EINVAL;\r\ngoto error2;\r\n}\r\nerror:\r\nif (status < 0)\r\nprintk(KERN_ERR "drxk: Error %d on %s\n", status, __func__);\r\nerror2:\r\nmutex_unlock(&state->mutex);\r\nreturn status;\r\n}\r\nstatic int ADCSyncMeasurement(struct drxk_state *state, u16 *count)\r\n{\r\nu16 data = 0;\r\nint status;\r\ndprintk(1, "\n");\r\nstatus = write16(state, IQM_AF_COMM_EXEC__A, IQM_AF_COMM_EXEC_ACTIVE);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, IQM_AF_START_LOCK__A, 1);\r\nif (status < 0)\r\ngoto error;\r\n*count = 0;\r\nstatus = read16(state, IQM_AF_PHASE0__A, &data);\r\nif (status < 0)\r\ngoto error;\r\nif (data == 127)\r\n*count = *count + 1;\r\nstatus = read16(state, IQM_AF_PHASE1__A, &data);\r\nif (status < 0)\r\ngoto error;\r\nif (data == 127)\r\n*count = *count + 1;\r\nstatus = read16(state, IQM_AF_PHASE2__A, &data);\r\nif (status < 0)\r\ngoto error;\r\nif (data == 127)\r\n*count = *count + 1;\r\nerror:\r\nif (status < 0)\r\nprintk(KERN_ERR "drxk: Error %d on %s\n", status, __func__);\r\nreturn status;\r\n}\r\nstatic int ADCSynchronization(struct drxk_state *state)\r\n{\r\nu16 count = 0;\r\nint status;\r\ndprintk(1, "\n");\r\nstatus = ADCSyncMeasurement(state, &count);\r\nif (status < 0)\r\ngoto error;\r\nif (count == 1) {\r\nu16 clkNeg = 0;\r\nstatus = read16(state, IQM_AF_CLKNEG__A, &clkNeg);\r\nif (status < 0)\r\ngoto error;\r\nif ((clkNeg & IQM_AF_CLKNEG_CLKNEGDATA__M) ==\r\nIQM_AF_CLKNEG_CLKNEGDATA_CLK_ADC_DATA_POS) {\r\nclkNeg &= (~(IQM_AF_CLKNEG_CLKNEGDATA__M));\r\nclkNeg |=\r\nIQM_AF_CLKNEG_CLKNEGDATA_CLK_ADC_DATA_NEG;\r\n} else {\r\nclkNeg &= (~(IQM_AF_CLKNEG_CLKNEGDATA__M));\r\nclkNeg |=\r\nIQM_AF_CLKNEG_CLKNEGDATA_CLK_ADC_DATA_POS;\r\n}\r\nstatus = write16(state, IQM_AF_CLKNEG__A, clkNeg);\r\nif (status < 0)\r\ngoto error;\r\nstatus = ADCSyncMeasurement(state, &count);\r\nif (status < 0)\r\ngoto error;\r\n}\r\nif (count < 2)\r\nstatus = -EINVAL;\r\nerror:\r\nif (status < 0)\r\nprintk(KERN_ERR "drxk: Error %d on %s\n", status, __func__);\r\nreturn status;\r\n}\r\nstatic int SetFrequencyShifter(struct drxk_state *state,\r\nu16 intermediateFreqkHz,\r\ns32 tunerFreqOffset, bool isDTV)\r\n{\r\nbool selectPosImage = false;\r\nu32 rfFreqResidual = tunerFreqOffset;\r\nu32 fmFrequencyShift = 0;\r\nbool tunerMirror = !state->m_bMirrorFreqSpect;\r\nu32 adcFreq;\r\nbool adcFlip;\r\nint status;\r\nu32 ifFreqActual;\r\nu32 samplingFrequency = (u32) (state->m_sysClockFreq / 3);\r\nu32 frequencyShift;\r\nbool imageToSelect;\r\ndprintk(1, "\n");\r\nif (isDTV) {\r\nif ((state->m_OperationMode == OM_QAM_ITU_A) ||\r\n(state->m_OperationMode == OM_QAM_ITU_C) ||\r\n(state->m_OperationMode == OM_DVBT))\r\nselectPosImage = true;\r\nelse\r\nselectPosImage = false;\r\n}\r\nif (tunerMirror)\r\nifFreqActual = intermediateFreqkHz +\r\nrfFreqResidual + fmFrequencyShift;\r\nelse\r\nifFreqActual = intermediateFreqkHz -\r\nrfFreqResidual - fmFrequencyShift;\r\nif (ifFreqActual > samplingFrequency / 2) {\r\nadcFreq = samplingFrequency - ifFreqActual;\r\nadcFlip = true;\r\n} else {\r\nadcFreq = ifFreqActual;\r\nadcFlip = false;\r\n}\r\nfrequencyShift = adcFreq;\r\nimageToSelect = state->m_rfmirror ^ tunerMirror ^\r\nadcFlip ^ selectPosImage;\r\nstate->m_IqmFsRateOfs =\r\nFrac28a((frequencyShift), samplingFrequency);\r\nif (imageToSelect)\r\nstate->m_IqmFsRateOfs = ~state->m_IqmFsRateOfs + 1;\r\nstatus = write32(state, IQM_FS_RATE_OFS_LO__A,\r\nstate->m_IqmFsRateOfs);\r\nif (status < 0)\r\nprintk(KERN_ERR "drxk: Error %d on %s\n", status, __func__);\r\nreturn status;\r\n}\r\nstatic int InitAGC(struct drxk_state *state, bool isDTV)\r\n{\r\nu16 ingainTgt = 0;\r\nu16 ingainTgtMin = 0;\r\nu16 ingainTgtMax = 0;\r\nu16 clpCyclen = 0;\r\nu16 clpSumMin = 0;\r\nu16 clpDirTo = 0;\r\nu16 snsSumMin = 0;\r\nu16 snsSumMax = 0;\r\nu16 clpSumMax = 0;\r\nu16 snsDirTo = 0;\r\nu16 kiInnergainMin = 0;\r\nu16 ifIaccuHiTgt = 0;\r\nu16 ifIaccuHiTgtMin = 0;\r\nu16 ifIaccuHiTgtMax = 0;\r\nu16 data = 0;\r\nu16 fastClpCtrlDelay = 0;\r\nu16 clpCtrlMode = 0;\r\nint status = 0;\r\ndprintk(1, "\n");\r\nsnsSumMax = 1023;\r\nifIaccuHiTgtMin = 2047;\r\nclpCyclen = 500;\r\nclpSumMax = 1023;\r\nif (!IsQAM(state)) {\r\nprintk(KERN_ERR "drxk: %s: mode %d is not DVB-C\n", __func__, state->m_OperationMode);\r\nreturn -EINVAL;\r\n}\r\nclpSumMin = 8;\r\nclpDirTo = (u16) -9;\r\nclpCtrlMode = 0;\r\nsnsSumMin = 8;\r\nsnsDirTo = (u16) -9;\r\nkiInnergainMin = (u16) -1030;\r\nifIaccuHiTgtMax = 0x2380;\r\nifIaccuHiTgt = 0x2380;\r\ningainTgtMin = 0x0511;\r\ningainTgt = 0x0511;\r\ningainTgtMax = 5119;\r\nfastClpCtrlDelay = state->m_qamIfAgcCfg.FastClipCtrlDelay;\r\nstatus = write16(state, SCU_RAM_AGC_FAST_CLP_CTRL_DELAY__A, fastClpCtrlDelay);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_AGC_CLP_CTRL_MODE__A, clpCtrlMode);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_AGC_INGAIN_TGT__A, ingainTgt);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_AGC_INGAIN_TGT_MIN__A, ingainTgtMin);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_AGC_INGAIN_TGT_MAX__A, ingainTgtMax);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_AGC_IF_IACCU_HI_TGT_MIN__A, ifIaccuHiTgtMin);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_AGC_IF_IACCU_HI_TGT_MAX__A, ifIaccuHiTgtMax);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_AGC_IF_IACCU_HI__A, 0);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_AGC_IF_IACCU_LO__A, 0);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_AGC_RF_IACCU_HI__A, 0);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_AGC_RF_IACCU_LO__A, 0);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_AGC_CLP_SUM_MAX__A, clpSumMax);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_AGC_SNS_SUM_MAX__A, snsSumMax);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_AGC_KI_INNERGAIN_MIN__A, kiInnergainMin);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_AGC_IF_IACCU_HI_TGT__A, ifIaccuHiTgt);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_AGC_CLP_CYCLEN__A, clpCyclen);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_AGC_RF_SNS_DEV_MAX__A, 1023);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_AGC_RF_SNS_DEV_MIN__A, (u16) -1023);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_AGC_FAST_SNS_CTRL_DELAY__A, 50);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_AGC_KI_MAXMINGAIN_TH__A, 20);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_AGC_CLP_SUM_MIN__A, clpSumMin);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_AGC_SNS_SUM_MIN__A, snsSumMin);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_AGC_CLP_DIR_TO__A, clpDirTo);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_AGC_SNS_DIR_TO__A, snsDirTo);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_AGC_KI_MINGAIN__A, 0x7fff);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_AGC_KI_MAXGAIN__A, 0x0);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_AGC_KI_MIN__A, 0x0117);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_AGC_KI_MAX__A, 0x0657);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_AGC_CLP_SUM__A, 0);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_AGC_CLP_CYCCNT__A, 0);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_AGC_CLP_DIR_WD__A, 0);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_AGC_CLP_DIR_STP__A, 1);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_AGC_SNS_SUM__A, 0);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_AGC_SNS_CYCCNT__A, 0);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_AGC_SNS_DIR_WD__A, 0);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_AGC_SNS_DIR_STP__A, 1);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_AGC_SNS_CYCLEN__A, 500);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_AGC_KI_CYCLEN__A, 500);\r\nif (status < 0)\r\ngoto error;\r\nstatus = read16(state, SCU_RAM_AGC_KI__A, &data);\r\nif (status < 0)\r\ngoto error;\r\ndata = 0x0657;\r\ndata &= ~SCU_RAM_AGC_KI_RF__M;\r\ndata |= (DRXK_KI_RAGC_QAM << SCU_RAM_AGC_KI_RF__B);\r\ndata &= ~SCU_RAM_AGC_KI_IF__M;\r\ndata |= (DRXK_KI_IAGC_QAM << SCU_RAM_AGC_KI_IF__B);\r\nstatus = write16(state, SCU_RAM_AGC_KI__A, data);\r\nerror:\r\nif (status < 0)\r\nprintk(KERN_ERR "drxk: Error %d on %s\n", status, __func__);\r\nreturn status;\r\n}\r\nstatic int DVBTQAMGetAccPktErr(struct drxk_state *state, u16 *packetErr)\r\n{\r\nint status;\r\ndprintk(1, "\n");\r\nif (packetErr == NULL)\r\nstatus = write16(state, SCU_RAM_FEC_ACCUM_PKT_FAILURES__A, 0);\r\nelse\r\nstatus = read16(state, SCU_RAM_FEC_ACCUM_PKT_FAILURES__A, packetErr);\r\nif (status < 0)\r\nprintk(KERN_ERR "drxk: Error %d on %s\n", status, __func__);\r\nreturn status;\r\n}\r\nstatic int DVBTScCommand(struct drxk_state *state,\r\nu16 cmd, u16 subcmd,\r\nu16 param0, u16 param1, u16 param2,\r\nu16 param3, u16 param4)\r\n{\r\nu16 curCmd = 0;\r\nu16 errCode = 0;\r\nu16 retryCnt = 0;\r\nu16 scExec = 0;\r\nint status;\r\ndprintk(1, "\n");\r\nstatus = read16(state, OFDM_SC_COMM_EXEC__A, &scExec);\r\nif (scExec != 1) {\r\nstatus = -EINVAL;\r\n}\r\nif (status < 0)\r\ngoto error;\r\nretryCnt = 0;\r\ndo {\r\nmsleep(1);\r\nstatus = read16(state, OFDM_SC_RA_RAM_CMD__A, &curCmd);\r\nretryCnt++;\r\n} while ((curCmd != 0) && (retryCnt < DRXK_MAX_RETRIES));\r\nif (retryCnt >= DRXK_MAX_RETRIES && (status < 0))\r\ngoto error;\r\nswitch (cmd) {\r\ncase OFDM_SC_RA_RAM_CMD_PROC_START:\r\ncase OFDM_SC_RA_RAM_CMD_SET_PREF_PARAM:\r\ncase OFDM_SC_RA_RAM_CMD_PROGRAM_PARAM:\r\nstatus = write16(state, OFDM_SC_RA_RAM_CMD_ADDR__A, subcmd);\r\nif (status < 0)\r\ngoto error;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nswitch (cmd) {\r\ncase OFDM_SC_RA_RAM_CMD_PROC_START:\r\ncase OFDM_SC_RA_RAM_CMD_SET_PREF_PARAM:\r\ncase OFDM_SC_RA_RAM_CMD_PROGRAM_PARAM:\r\nstatus = write16(state, OFDM_SC_RA_RAM_PARAM1__A, param1);\r\ncase OFDM_SC_RA_RAM_CMD_SET_ECHO_TIMING:\r\ncase OFDM_SC_RA_RAM_CMD_USER_IO:\r\nstatus = write16(state, OFDM_SC_RA_RAM_PARAM0__A, param0);\r\ncase OFDM_SC_RA_RAM_CMD_GET_OP_PARAM:\r\ncase OFDM_SC_RA_RAM_CMD_NULL:\r\nstatus = write16(state, OFDM_SC_RA_RAM_CMD__A, cmd);\r\nbreak;\r\ndefault:\r\nstatus = -EINVAL;\r\n}\r\nif (status < 0)\r\ngoto error;\r\nretryCnt = 0;\r\ndo {\r\nmsleep(1);\r\nstatus = read16(state, OFDM_SC_RA_RAM_CMD__A, &curCmd);\r\nretryCnt++;\r\n} while ((curCmd != 0) && (retryCnt < DRXK_MAX_RETRIES));\r\nif (retryCnt >= DRXK_MAX_RETRIES && (status < 0))\r\ngoto error;\r\nstatus = read16(state, OFDM_SC_RA_RAM_CMD_ADDR__A, &errCode);\r\nif (errCode == 0xFFFF) {\r\nstatus = -EINVAL;\r\n}\r\nif (status < 0)\r\ngoto error;\r\nswitch (cmd) {\r\ncase OFDM_SC_RA_RAM_CMD_USER_IO:\r\ncase OFDM_SC_RA_RAM_CMD_GET_OP_PARAM:\r\nstatus = read16(state, OFDM_SC_RA_RAM_PARAM0__A, &(param0));\r\ncase OFDM_SC_RA_RAM_CMD_SET_ECHO_TIMING:\r\ncase OFDM_SC_RA_RAM_CMD_SET_TIMER:\r\ncase OFDM_SC_RA_RAM_CMD_PROC_START:\r\ncase OFDM_SC_RA_RAM_CMD_SET_PREF_PARAM:\r\ncase OFDM_SC_RA_RAM_CMD_PROGRAM_PARAM:\r\ncase OFDM_SC_RA_RAM_CMD_NULL:\r\nbreak;\r\ndefault:\r\nstatus = -EINVAL;\r\nbreak;\r\n}\r\nerror:\r\nif (status < 0)\r\nprintk(KERN_ERR "drxk: Error %d on %s\n", status, __func__);\r\nreturn status;\r\n}\r\nstatic int PowerUpDVBT(struct drxk_state *state)\r\n{\r\nenum DRXPowerMode powerMode = DRX_POWER_UP;\r\nint status;\r\ndprintk(1, "\n");\r\nstatus = CtrlPowerMode(state, &powerMode);\r\nif (status < 0)\r\nprintk(KERN_ERR "drxk: Error %d on %s\n", status, __func__);\r\nreturn status;\r\n}\r\nstatic int DVBTCtrlSetIncEnable(struct drxk_state *state, bool *enabled)\r\n{\r\nint status;\r\ndprintk(1, "\n");\r\nif (*enabled == true)\r\nstatus = write16(state, IQM_CF_BYPASSDET__A, 0);\r\nelse\r\nstatus = write16(state, IQM_CF_BYPASSDET__A, 1);\r\nif (status < 0)\r\nprintk(KERN_ERR "drxk: Error %d on %s\n", status, __func__);\r\nreturn status;\r\n}\r\nstatic int DVBTCtrlSetFrEnable(struct drxk_state *state, bool *enabled)\r\n{\r\nint status;\r\ndprintk(1, "\n");\r\nif (*enabled == true) {\r\nstatus = write16(state, OFDM_SC_RA_RAM_FR_THRES_8K__A,\r\nDEFAULT_FR_THRES_8K);\r\n} else {\r\nstatus = write16(state, OFDM_SC_RA_RAM_FR_THRES_8K__A, 0);\r\n}\r\nif (status < 0)\r\nprintk(KERN_ERR "drxk: Error %d on %s\n", status, __func__);\r\nreturn status;\r\n}\r\nstatic int DVBTCtrlSetEchoThreshold(struct drxk_state *state,\r\nstruct DRXKCfgDvbtEchoThres_t *echoThres)\r\n{\r\nu16 data = 0;\r\nint status;\r\ndprintk(1, "\n");\r\nstatus = read16(state, OFDM_SC_RA_RAM_ECHO_THRES__A, &data);\r\nif (status < 0)\r\ngoto error;\r\nswitch (echoThres->fftMode) {\r\ncase DRX_FFTMODE_2K:\r\ndata &= ~OFDM_SC_RA_RAM_ECHO_THRES_2K__M;\r\ndata |= ((echoThres->threshold <<\r\nOFDM_SC_RA_RAM_ECHO_THRES_2K__B)\r\n& (OFDM_SC_RA_RAM_ECHO_THRES_2K__M));\r\nbreak;\r\ncase DRX_FFTMODE_8K:\r\ndata &= ~OFDM_SC_RA_RAM_ECHO_THRES_8K__M;\r\ndata |= ((echoThres->threshold <<\r\nOFDM_SC_RA_RAM_ECHO_THRES_8K__B)\r\n& (OFDM_SC_RA_RAM_ECHO_THRES_8K__M));\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nstatus = write16(state, OFDM_SC_RA_RAM_ECHO_THRES__A, data);\r\nerror:\r\nif (status < 0)\r\nprintk(KERN_ERR "drxk: Error %d on %s\n", status, __func__);\r\nreturn status;\r\n}\r\nstatic int DVBTCtrlSetSqiSpeed(struct drxk_state *state,\r\nenum DRXKCfgDvbtSqiSpeed *speed)\r\n{\r\nint status = -EINVAL;\r\ndprintk(1, "\n");\r\nswitch (*speed) {\r\ncase DRXK_DVBT_SQI_SPEED_FAST:\r\ncase DRXK_DVBT_SQI_SPEED_MEDIUM:\r\ncase DRXK_DVBT_SQI_SPEED_SLOW:\r\nbreak;\r\ndefault:\r\ngoto error;\r\n}\r\nstatus = write16(state, SCU_RAM_FEC_PRE_RS_BER_FILTER_SH__A,\r\n(u16) *speed);\r\nerror:\r\nif (status < 0)\r\nprintk(KERN_ERR "drxk: Error %d on %s\n", status, __func__);\r\nreturn status;\r\n}\r\nstatic int DVBTActivatePresets(struct drxk_state *state)\r\n{\r\nint status;\r\nbool setincenable = false;\r\nbool setfrenable = true;\r\nstruct DRXKCfgDvbtEchoThres_t echoThres2k = { 0, DRX_FFTMODE_2K };\r\nstruct DRXKCfgDvbtEchoThres_t echoThres8k = { 0, DRX_FFTMODE_8K };\r\ndprintk(1, "\n");\r\nstatus = DVBTCtrlSetIncEnable(state, &setincenable);\r\nif (status < 0)\r\ngoto error;\r\nstatus = DVBTCtrlSetFrEnable(state, &setfrenable);\r\nif (status < 0)\r\ngoto error;\r\nstatus = DVBTCtrlSetEchoThreshold(state, &echoThres2k);\r\nif (status < 0)\r\ngoto error;\r\nstatus = DVBTCtrlSetEchoThreshold(state, &echoThres8k);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_AGC_INGAIN_TGT_MAX__A, state->m_dvbtIfAgcCfg.IngainTgtMax);\r\nerror:\r\nif (status < 0)\r\nprintk(KERN_ERR "drxk: Error %d on %s\n", status, __func__);\r\nreturn status;\r\n}\r\nstatic int SetDVBTStandard(struct drxk_state *state,\r\nenum OperationMode oMode)\r\n{\r\nu16 cmdResult = 0;\r\nu16 data = 0;\r\nint status;\r\ndprintk(1, "\n");\r\nPowerUpDVBT(state);\r\nSwitchAntennaToDVBT(state);\r\nstatus = scu_command(state, SCU_RAM_COMMAND_STANDARD_OFDM | SCU_RAM_COMMAND_CMD_DEMOD_RESET, 0, NULL, 1, &cmdResult);\r\nif (status < 0)\r\ngoto error;\r\nstatus = scu_command(state, SCU_RAM_COMMAND_STANDARD_OFDM | SCU_RAM_COMMAND_CMD_DEMOD_SET_ENV, 0, NULL, 1, &cmdResult);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, OFDM_SC_COMM_EXEC__A, OFDM_SC_COMM_EXEC_STOP);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, OFDM_LC_COMM_EXEC__A, OFDM_LC_COMM_EXEC_STOP);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, IQM_COMM_EXEC__A, IQM_COMM_EXEC_B_STOP);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, IQM_AF_UPD_SEL__A, 1);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, IQM_AF_CLP_LEN__A, 0);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, IQM_AF_SNS_LEN__A, 0);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, IQM_AF_AMUX__A, IQM_AF_AMUX_SIGNAL2ADC);\r\nif (status < 0)\r\ngoto error;\r\nstatus = SetIqmAf(state, true);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, IQM_AF_AGC_RF__A, 0);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, IQM_AF_INC_LCT__A, 0);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, IQM_CF_DET_LCT__A, 0);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, IQM_CF_WND_LEN__A, 3);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, IQM_RC_STRETCH__A, 16);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, IQM_CF_OUT_ENA__A, 0x4);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, IQM_CF_DS_ENA__A, 0x4);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, IQM_CF_SCALE__A, 1600);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, IQM_CF_SCALE_SH__A, 0);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, IQM_AF_CLP_TH__A, 448);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, IQM_CF_DATATH__A, 495);\r\nif (status < 0)\r\ngoto error;\r\nstatus = BLChainCmd(state, DRXK_BL_ROM_OFFSET_TAPS_DVBT, DRXK_BLCC_NR_ELEMENTS_TAPS, DRXK_BLC_TIMEOUT);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, IQM_CF_PKDTH__A, 2);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, IQM_CF_POW_MEAS_LEN__A, 2);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, IQM_CF_COMM_INT_MSK__A, 1);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, IQM_COMM_EXEC__A, IQM_COMM_EXEC_B_ACTIVE);\r\nif (status < 0)\r\ngoto error;\r\nstatus = ADCSynchronization(state);\r\nif (status < 0)\r\ngoto error;\r\nstatus = SetPreSaw(state, &state->m_dvbtPreSawCfg);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_COMM_EXEC__A, SCU_COMM_EXEC_HOLD);\r\nif (status < 0)\r\ngoto error;\r\nstatus = SetAgcRf(state, &state->m_dvbtRfAgcCfg, true);\r\nif (status < 0)\r\ngoto error;\r\nstatus = SetAgcIf(state, &state->m_dvbtIfAgcCfg, true);\r\nif (status < 0)\r\ngoto error;\r\nstatus = read16(state, OFDM_SC_RA_RAM_CONFIG__A, &data);\r\nif (status < 0)\r\ngoto error;\r\ndata |= OFDM_SC_RA_RAM_CONFIG_NE_FIX_ENABLE__M;\r\nstatus = write16(state, OFDM_SC_RA_RAM_CONFIG__A, data);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_COMM_EXEC__A, SCU_COMM_EXEC_ACTIVE);\r\nif (status < 0)\r\ngoto error;\r\nif (!state->m_DRXK_A3_ROM_CODE) {\r\nstatus = write16(state, SCU_RAM_AGC_FAST_CLP_CTRL_DELAY__A, state->m_dvbtIfAgcCfg.FastClipCtrlDelay);\r\nif (status < 0)\r\ngoto error;\r\n}\r\n#ifdef COMPILE_FOR_NONRT\r\nstatus = write16(state, OFDM_SC_RA_RAM_BE_OPT_DELAY__A, 1);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, OFDM_SC_RA_RAM_BE_OPT_INIT_DELAY__A, 2);\r\nif (status < 0)\r\ngoto error;\r\n#endif\r\nstatus = write16(state, FEC_DI_INPUT_CTL__A, 1);\r\nif (status < 0)\r\ngoto error;\r\n#ifdef COMPILE_FOR_NONRT\r\nstatus = write16(state, FEC_RS_MEASUREMENT_PERIOD__A, 0x400);\r\nif (status < 0)\r\ngoto error;\r\n#else\r\nstatus = write16(state, FEC_RS_MEASUREMENT_PERIOD__A, 0x1000);\r\nif (status < 0)\r\ngoto error;\r\n#endif\r\nstatus = write16(state, FEC_RS_MEASUREMENT_PRESCALE__A, 0x0001);\r\nif (status < 0)\r\ngoto error;\r\nstatus = MPEGTSDtoSetup(state, OM_DVBT);\r\nif (status < 0)\r\ngoto error;\r\nstatus = DVBTActivatePresets(state);\r\nif (status < 0)\r\ngoto error;\r\nerror:\r\nif (status < 0)\r\nprintk(KERN_ERR "drxk: Error %d on %s\n", status, __func__);\r\nreturn status;\r\n}\r\nstatic int DVBTStart(struct drxk_state *state)\r\n{\r\nu16 param1;\r\nint status;\r\ndprintk(1, "\n");\r\nparam1 = OFDM_SC_RA_RAM_LOCKTRACK_MIN;\r\nstatus = DVBTScCommand(state, OFDM_SC_RA_RAM_CMD_PROC_START, 0, OFDM_SC_RA_RAM_SW_EVENT_RUN_NMASK__M, param1, 0, 0, 0);\r\nif (status < 0)\r\ngoto error;\r\nstatus = MPEGTSStart(state);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, FEC_COMM_EXEC__A, FEC_COMM_EXEC_ACTIVE);\r\nif (status < 0)\r\ngoto error;\r\nerror:\r\nif (status < 0)\r\nprintk(KERN_ERR "drxk: Error %d on %s\n", status, __func__);\r\nreturn status;\r\n}\r\nstatic int SetDVBT(struct drxk_state *state, u16 IntermediateFreqkHz,\r\ns32 tunerFreqOffset)\r\n{\r\nu16 cmdResult = 0;\r\nu16 transmissionParams = 0;\r\nu16 operationMode = 0;\r\nu32 iqmRcRateOfs = 0;\r\nu32 bandwidth = 0;\r\nu16 param1;\r\nint status;\r\ndprintk(1, "IF =%d, TFO = %d\n", IntermediateFreqkHz, tunerFreqOffset);\r\nstatus = scu_command(state, SCU_RAM_COMMAND_STANDARD_OFDM | SCU_RAM_COMMAND_CMD_DEMOD_STOP, 0, NULL, 1, &cmdResult);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_COMM_EXEC__A, SCU_COMM_EXEC_HOLD);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, OFDM_SC_COMM_EXEC__A, OFDM_SC_COMM_EXEC_STOP);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, OFDM_LC_COMM_EXEC__A, OFDM_LC_COMM_EXEC_STOP);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, OFDM_CP_COMM_EXEC__A, OFDM_CP_COMM_EXEC_STOP);\r\nif (status < 0)\r\ngoto error;\r\nswitch (state->props.transmission_mode) {\r\ncase TRANSMISSION_MODE_AUTO:\r\ndefault:\r\noperationMode |= OFDM_SC_RA_RAM_OP_AUTO_MODE__M;\r\ncase TRANSMISSION_MODE_8K:\r\ntransmissionParams |= OFDM_SC_RA_RAM_OP_PARAM_MODE_8K;\r\nbreak;\r\ncase TRANSMISSION_MODE_2K:\r\ntransmissionParams |= OFDM_SC_RA_RAM_OP_PARAM_MODE_2K;\r\nbreak;\r\n}\r\nswitch (state->props.guard_interval) {\r\ndefault:\r\ncase GUARD_INTERVAL_AUTO:\r\noperationMode |= OFDM_SC_RA_RAM_OP_AUTO_GUARD__M;\r\ncase GUARD_INTERVAL_1_4:\r\ntransmissionParams |= OFDM_SC_RA_RAM_OP_PARAM_GUARD_4;\r\nbreak;\r\ncase GUARD_INTERVAL_1_32:\r\ntransmissionParams |= OFDM_SC_RA_RAM_OP_PARAM_GUARD_32;\r\nbreak;\r\ncase GUARD_INTERVAL_1_16:\r\ntransmissionParams |= OFDM_SC_RA_RAM_OP_PARAM_GUARD_16;\r\nbreak;\r\ncase GUARD_INTERVAL_1_8:\r\ntransmissionParams |= OFDM_SC_RA_RAM_OP_PARAM_GUARD_8;\r\nbreak;\r\n}\r\nswitch (state->props.hierarchy) {\r\ncase HIERARCHY_AUTO:\r\ncase HIERARCHY_NONE:\r\ndefault:\r\noperationMode |= OFDM_SC_RA_RAM_OP_AUTO_HIER__M;\r\ncase HIERARCHY_1:\r\ntransmissionParams |= OFDM_SC_RA_RAM_OP_PARAM_HIER_A1;\r\nbreak;\r\ncase HIERARCHY_2:\r\ntransmissionParams |= OFDM_SC_RA_RAM_OP_PARAM_HIER_A2;\r\nbreak;\r\ncase HIERARCHY_4:\r\ntransmissionParams |= OFDM_SC_RA_RAM_OP_PARAM_HIER_A4;\r\nbreak;\r\n}\r\nswitch (state->props.modulation) {\r\ncase QAM_AUTO:\r\ndefault:\r\noperationMode |= OFDM_SC_RA_RAM_OP_AUTO_CONST__M;\r\ncase QAM_64:\r\ntransmissionParams |= OFDM_SC_RA_RAM_OP_PARAM_CONST_QAM64;\r\nbreak;\r\ncase QPSK:\r\ntransmissionParams |= OFDM_SC_RA_RAM_OP_PARAM_CONST_QPSK;\r\nbreak;\r\ncase QAM_16:\r\ntransmissionParams |= OFDM_SC_RA_RAM_OP_PARAM_CONST_QAM16;\r\nbreak;\r\n}\r\n#if 0\r\nswitch (channel->priority) {\r\ncase DRX_PRIORITY_LOW:\r\ntransmissionParams |= OFDM_SC_RA_RAM_OP_PARAM_PRIO_LO;\r\nWR16(devAddr, OFDM_EC_SB_PRIOR__A,\r\nOFDM_EC_SB_PRIOR_LO);\r\nbreak;\r\ncase DRX_PRIORITY_HIGH:\r\ntransmissionParams |= OFDM_SC_RA_RAM_OP_PARAM_PRIO_HI;\r\nWR16(devAddr, OFDM_EC_SB_PRIOR__A,\r\nOFDM_EC_SB_PRIOR_HI));\r\nbreak;\r\ncase DRX_PRIORITY_UNKNOWN:\r\ndefault:\r\nstatus = -EINVAL;\r\ngoto error;\r\n}\r\n#else\r\ntransmissionParams |= OFDM_SC_RA_RAM_OP_PARAM_PRIO_HI;\r\nstatus = write16(state, OFDM_EC_SB_PRIOR__A, OFDM_EC_SB_PRIOR_HI);\r\nif (status < 0)\r\ngoto error;\r\n#endif\r\nswitch (state->props.code_rate_HP) {\r\ncase FEC_AUTO:\r\ndefault:\r\noperationMode |= OFDM_SC_RA_RAM_OP_AUTO_RATE__M;\r\ncase FEC_2_3:\r\ntransmissionParams |= OFDM_SC_RA_RAM_OP_PARAM_RATE_2_3;\r\nbreak;\r\ncase FEC_1_2:\r\ntransmissionParams |= OFDM_SC_RA_RAM_OP_PARAM_RATE_1_2;\r\nbreak;\r\ncase FEC_3_4:\r\ntransmissionParams |= OFDM_SC_RA_RAM_OP_PARAM_RATE_3_4;\r\nbreak;\r\ncase FEC_5_6:\r\ntransmissionParams |= OFDM_SC_RA_RAM_OP_PARAM_RATE_5_6;\r\nbreak;\r\ncase FEC_7_8:\r\ntransmissionParams |= OFDM_SC_RA_RAM_OP_PARAM_RATE_7_8;\r\nbreak;\r\n}\r\nswitch (state->props.bandwidth_hz) {\r\ncase 0:\r\nstate->props.bandwidth_hz = 8000000;\r\ncase 8000000:\r\nbandwidth = DRXK_BANDWIDTH_8MHZ_IN_HZ;\r\nstatus = write16(state, OFDM_SC_RA_RAM_SRMM_FIX_FACT_8K__A, 3052);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, OFDM_SC_RA_RAM_NI_INIT_8K_PER_LEFT__A, 7);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, OFDM_SC_RA_RAM_NI_INIT_8K_PER_RIGHT__A, 7);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, OFDM_SC_RA_RAM_NI_INIT_2K_PER_LEFT__A, 7);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, OFDM_SC_RA_RAM_NI_INIT_2K_PER_RIGHT__A, 1);\r\nif (status < 0)\r\ngoto error;\r\nbreak;\r\ncase 7000000:\r\nbandwidth = DRXK_BANDWIDTH_7MHZ_IN_HZ;\r\nstatus = write16(state, OFDM_SC_RA_RAM_SRMM_FIX_FACT_8K__A, 3491);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, OFDM_SC_RA_RAM_NI_INIT_8K_PER_LEFT__A, 8);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, OFDM_SC_RA_RAM_NI_INIT_8K_PER_RIGHT__A, 8);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, OFDM_SC_RA_RAM_NI_INIT_2K_PER_LEFT__A, 4);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, OFDM_SC_RA_RAM_NI_INIT_2K_PER_RIGHT__A, 1);\r\nif (status < 0)\r\ngoto error;\r\nbreak;\r\ncase 6000000:\r\nbandwidth = DRXK_BANDWIDTH_6MHZ_IN_HZ;\r\nstatus = write16(state, OFDM_SC_RA_RAM_SRMM_FIX_FACT_8K__A, 4073);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, OFDM_SC_RA_RAM_NI_INIT_8K_PER_LEFT__A, 19);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, OFDM_SC_RA_RAM_NI_INIT_8K_PER_RIGHT__A, 19);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, OFDM_SC_RA_RAM_NI_INIT_2K_PER_LEFT__A, 14);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, OFDM_SC_RA_RAM_NI_INIT_2K_PER_RIGHT__A, 1);\r\nif (status < 0)\r\ngoto error;\r\nbreak;\r\ndefault:\r\nstatus = -EINVAL;\r\ngoto error;\r\n}\r\nif (iqmRcRateOfs == 0) {\r\niqmRcRateOfs = Frac28a((u32)\r\n((state->m_sysClockFreq *\r\n1000) / 3), bandwidth);\r\nif ((iqmRcRateOfs & 0x7fL) >= 0x40)\r\niqmRcRateOfs += 0x80L;\r\niqmRcRateOfs = iqmRcRateOfs >> 7;\r\niqmRcRateOfs = iqmRcRateOfs - (1 << 23);\r\n}\r\niqmRcRateOfs &=\r\n((((u32) IQM_RC_RATE_OFS_HI__M) <<\r\nIQM_RC_RATE_OFS_LO__W) | IQM_RC_RATE_OFS_LO__M);\r\nstatus = write32(state, IQM_RC_RATE_OFS_LO__A, iqmRcRateOfs);\r\nif (status < 0)\r\ngoto error;\r\n#if 0\r\nstatus = DVBTSetFrequencyShift(demod, channel, tunerOffset);\r\nif (status < 0)\r\ngoto error;\r\n#endif\r\nstatus = SetFrequencyShifter(state, IntermediateFreqkHz, tunerFreqOffset, true);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_COMM_EXEC__A, SCU_COMM_EXEC_ACTIVE);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, OFDM_SC_COMM_STATE__A, 0);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, OFDM_SC_COMM_EXEC__A, 1);\r\nif (status < 0)\r\ngoto error;\r\nstatus = scu_command(state, SCU_RAM_COMMAND_STANDARD_OFDM | SCU_RAM_COMMAND_CMD_DEMOD_START, 0, NULL, 1, &cmdResult);\r\nif (status < 0)\r\ngoto error;\r\nparam1 = (OFDM_SC_RA_RAM_OP_AUTO_MODE__M |\r\nOFDM_SC_RA_RAM_OP_AUTO_GUARD__M |\r\nOFDM_SC_RA_RAM_OP_AUTO_CONST__M |\r\nOFDM_SC_RA_RAM_OP_AUTO_HIER__M |\r\nOFDM_SC_RA_RAM_OP_AUTO_RATE__M);\r\nstatus = DVBTScCommand(state, OFDM_SC_RA_RAM_CMD_SET_PREF_PARAM,\r\n0, transmissionParams, param1, 0, 0, 0);\r\nif (status < 0)\r\ngoto error;\r\nif (!state->m_DRXK_A3_ROM_CODE)\r\nstatus = DVBTCtrlSetSqiSpeed(state, &state->m_sqiSpeed);\r\nerror:\r\nif (status < 0)\r\nprintk(KERN_ERR "drxk: Error %d on %s\n", status, __func__);\r\nreturn status;\r\n}\r\nstatic int GetDVBTLockStatus(struct drxk_state *state, u32 *pLockStatus)\r\n{\r\nint status;\r\nconst u16 mpeg_lock_mask = (OFDM_SC_RA_RAM_LOCK_MPEG__M |\r\nOFDM_SC_RA_RAM_LOCK_FEC__M);\r\nconst u16 fec_lock_mask = (OFDM_SC_RA_RAM_LOCK_FEC__M);\r\nconst u16 demod_lock_mask = OFDM_SC_RA_RAM_LOCK_DEMOD__M;\r\nu16 ScRaRamLock = 0;\r\nu16 ScCommExec = 0;\r\ndprintk(1, "\n");\r\n*pLockStatus = NOT_LOCKED;\r\nstatus = read16(state, OFDM_SC_COMM_EXEC__A, &ScCommExec);\r\nif (status < 0)\r\ngoto end;\r\nif (ScCommExec == OFDM_SC_COMM_EXEC_STOP)\r\ngoto end;\r\nstatus = read16(state, OFDM_SC_RA_RAM_LOCK__A, &ScRaRamLock);\r\nif (status < 0)\r\ngoto end;\r\nif ((ScRaRamLock & mpeg_lock_mask) == mpeg_lock_mask)\r\n*pLockStatus = MPEG_LOCK;\r\nelse if ((ScRaRamLock & fec_lock_mask) == fec_lock_mask)\r\n*pLockStatus = FEC_LOCK;\r\nelse if ((ScRaRamLock & demod_lock_mask) == demod_lock_mask)\r\n*pLockStatus = DEMOD_LOCK;\r\nelse if (ScRaRamLock & OFDM_SC_RA_RAM_LOCK_NODVBT__M)\r\n*pLockStatus = NEVER_LOCK;\r\nend:\r\nif (status < 0)\r\nprintk(KERN_ERR "drxk: Error %d on %s\n", status, __func__);\r\nreturn status;\r\n}\r\nstatic int PowerUpQAM(struct drxk_state *state)\r\n{\r\nenum DRXPowerMode powerMode = DRXK_POWER_DOWN_OFDM;\r\nint status;\r\ndprintk(1, "\n");\r\nstatus = CtrlPowerMode(state, &powerMode);\r\nif (status < 0)\r\nprintk(KERN_ERR "drxk: Error %d on %s\n", status, __func__);\r\nreturn status;\r\n}\r\nstatic int PowerDownQAM(struct drxk_state *state)\r\n{\r\nu16 data = 0;\r\nu16 cmdResult;\r\nint status = 0;\r\ndprintk(1, "\n");\r\nstatus = read16(state, SCU_COMM_EXEC__A, &data);\r\nif (status < 0)\r\ngoto error;\r\nif (data == SCU_COMM_EXEC_ACTIVE) {\r\nstatus = write16(state, QAM_COMM_EXEC__A, QAM_COMM_EXEC_STOP);\r\nif (status < 0)\r\ngoto error;\r\nstatus = scu_command(state, SCU_RAM_COMMAND_STANDARD_QAM | SCU_RAM_COMMAND_CMD_DEMOD_STOP, 0, NULL, 1, &cmdResult);\r\nif (status < 0)\r\ngoto error;\r\n}\r\nstatus = SetIqmAf(state, false);\r\nerror:\r\nif (status < 0)\r\nprintk(KERN_ERR "drxk: Error %d on %s\n", status, __func__);\r\nreturn status;\r\n}\r\nstatic int SetQAMMeasurement(struct drxk_state *state,\r\nenum EDrxkConstellation modulation,\r\nu32 symbolRate)\r\n{\r\nu32 fecBitsDesired = 0;\r\nu32 fecRsPeriodTotal = 0;\r\nu16 fecRsPrescale = 0;\r\nu16 fecRsPeriod = 0;\r\nint status = 0;\r\ndprintk(1, "\n");\r\nfecRsPrescale = 1;\r\nswitch (modulation) {\r\ncase DRX_CONSTELLATION_QAM16:\r\nfecBitsDesired = 4 * symbolRate;\r\nbreak;\r\ncase DRX_CONSTELLATION_QAM32:\r\nfecBitsDesired = 5 * symbolRate;\r\nbreak;\r\ncase DRX_CONSTELLATION_QAM64:\r\nfecBitsDesired = 6 * symbolRate;\r\nbreak;\r\ncase DRX_CONSTELLATION_QAM128:\r\nfecBitsDesired = 7 * symbolRate;\r\nbreak;\r\ncase DRX_CONSTELLATION_QAM256:\r\nfecBitsDesired = 8 * symbolRate;\r\nbreak;\r\ndefault:\r\nstatus = -EINVAL;\r\n}\r\nif (status < 0)\r\ngoto error;\r\nfecBitsDesired /= 1000;\r\nfecBitsDesired *= 500;\r\nfecRsPeriodTotal = (fecBitsDesired / 1632UL) + 1;\r\nfecRsPrescale = 1 + (u16) (fecRsPeriodTotal >> 16);\r\nif (fecRsPrescale == 0) {\r\nstatus = -EINVAL;\r\nif (status < 0)\r\ngoto error;\r\n}\r\nfecRsPeriod =\r\n((u16) fecRsPeriodTotal +\r\n(fecRsPrescale >> 1)) / fecRsPrescale;\r\nstatus = write16(state, FEC_RS_MEASUREMENT_PERIOD__A, fecRsPeriod);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, FEC_RS_MEASUREMENT_PRESCALE__A, fecRsPrescale);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, FEC_OC_SNC_FAIL_PERIOD__A, fecRsPeriod);\r\nerror:\r\nif (status < 0)\r\nprintk(KERN_ERR "drxk: Error %d on %s\n", status, __func__);\r\nreturn status;\r\n}\r\nstatic int SetQAM16(struct drxk_state *state)\r\n{\r\nint status = 0;\r\ndprintk(1, "\n");\r\nstatus = write16(state, SCU_RAM_QAM_EQ_CMA_RAD0__A, 13517);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_QAM_EQ_CMA_RAD1__A, 13517);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_QAM_EQ_CMA_RAD2__A, 13517);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_QAM_EQ_CMA_RAD3__A, 13517);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_QAM_EQ_CMA_RAD4__A, 13517);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_QAM_EQ_CMA_RAD5__A, 13517);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, QAM_DQ_QUAL_FUN0__A, 2);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, QAM_DQ_QUAL_FUN1__A, 2);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, QAM_DQ_QUAL_FUN2__A, 2);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, QAM_DQ_QUAL_FUN3__A, 2);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, QAM_DQ_QUAL_FUN4__A, 2);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, QAM_DQ_QUAL_FUN5__A, 0);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, QAM_SY_SYNC_HWM__A, 5);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, QAM_SY_SYNC_AWM__A, 4);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, QAM_SY_SYNC_LWM__A, 3);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_QAM_SL_SIG_POWER__A, DRXK_QAM_SL_SIG_POWER_QAM16);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_QAM_LC_CA_FINE__A, 15);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_QAM_LC_CA_COARSE__A, 40);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_QAM_LC_EP_FINE__A, 12);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_QAM_LC_EP_MEDIUM__A, 24);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_QAM_LC_EP_COARSE__A, 24);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_QAM_LC_EI_FINE__A, 12);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_QAM_LC_EI_MEDIUM__A, 16);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_QAM_LC_EI_COARSE__A, 16);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_QAM_LC_CP_FINE__A, 5);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_QAM_LC_CP_MEDIUM__A, 20);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_QAM_LC_CP_COARSE__A, 80);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_QAM_LC_CI_FINE__A, 5);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_QAM_LC_CI_MEDIUM__A, 20);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_QAM_LC_CI_COARSE__A, 50);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_QAM_LC_CF_FINE__A, 16);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_QAM_LC_CF_MEDIUM__A, 16);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_QAM_LC_CF_COARSE__A, 32);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_QAM_LC_CF1_FINE__A, 5);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_QAM_LC_CF1_MEDIUM__A, 10);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_QAM_LC_CF1_COARSE__A, 10);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_QAM_FSM_RTH__A, 140);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_QAM_FSM_FTH__A, 50);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_QAM_FSM_CTH__A, 95);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_QAM_FSM_PTH__A, 120);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_QAM_FSM_QTH__A, 230);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_QAM_FSM_MTH__A, 105);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_QAM_FSM_RATE_LIM__A, 40);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_QAM_FSM_COUNT_LIM__A, 4);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_QAM_FSM_FREQ_LIM__A, 24);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_QAM_FSM_MEDIAN_AV_MULT__A, (u16) 16);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_QAM_FSM_RADIUS_AV_LIMIT__A, (u16) 220);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_QAM_FSM_LCAVG_OFFSET1__A, (u16) 25);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_QAM_FSM_LCAVG_OFFSET2__A, (u16) 6);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_QAM_FSM_LCAVG_OFFSET3__A, (u16) -24);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_QAM_FSM_LCAVG_OFFSET4__A, (u16) -65);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_QAM_FSM_LCAVG_OFFSET5__A, (u16) -127);\r\nif (status < 0)\r\ngoto error;\r\nerror:\r\nif (status < 0)\r\nprintk(KERN_ERR "drxk: Error %d on %s\n", status, __func__);\r\nreturn status;\r\n}\r\nstatic int SetQAM32(struct drxk_state *state)\r\n{\r\nint status = 0;\r\ndprintk(1, "\n");\r\nstatus = write16(state, SCU_RAM_QAM_EQ_CMA_RAD0__A, 6707);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_QAM_EQ_CMA_RAD1__A, 6707);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_QAM_EQ_CMA_RAD2__A, 6707);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_QAM_EQ_CMA_RAD3__A, 6707);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_QAM_EQ_CMA_RAD4__A, 6707);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_QAM_EQ_CMA_RAD5__A, 6707);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, QAM_DQ_QUAL_FUN0__A, 3);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, QAM_DQ_QUAL_FUN1__A, 3);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, QAM_DQ_QUAL_FUN2__A, 3);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, QAM_DQ_QUAL_FUN3__A, 3);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, QAM_DQ_QUAL_FUN4__A, 3);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, QAM_DQ_QUAL_FUN5__A, 0);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, QAM_SY_SYNC_HWM__A, 6);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, QAM_SY_SYNC_AWM__A, 5);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, QAM_SY_SYNC_LWM__A, 3);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_QAM_SL_SIG_POWER__A, DRXK_QAM_SL_SIG_POWER_QAM32);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_QAM_LC_CA_FINE__A, 15);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_QAM_LC_CA_COARSE__A, 40);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_QAM_LC_EP_FINE__A, 12);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_QAM_LC_EP_MEDIUM__A, 24);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_QAM_LC_EP_COARSE__A, 24);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_QAM_LC_EI_FINE__A, 12);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_QAM_LC_EI_MEDIUM__A, 16);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_QAM_LC_EI_COARSE__A, 16);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_QAM_LC_CP_FINE__A, 5);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_QAM_LC_CP_MEDIUM__A, 20);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_QAM_LC_CP_COARSE__A, 80);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_QAM_LC_CI_FINE__A, 5);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_QAM_LC_CI_MEDIUM__A, 20);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_QAM_LC_CI_COARSE__A, 50);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_QAM_LC_CF_FINE__A, 16);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_QAM_LC_CF_MEDIUM__A, 16);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_QAM_LC_CF_COARSE__A, 16);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_QAM_LC_CF1_FINE__A, 5);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_QAM_LC_CF1_MEDIUM__A, 10);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_QAM_LC_CF1_COARSE__A, 0);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_QAM_FSM_RTH__A, 90);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_QAM_FSM_FTH__A, 50);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_QAM_FSM_CTH__A, 80);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_QAM_FSM_PTH__A, 100);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_QAM_FSM_QTH__A, 170);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_QAM_FSM_MTH__A, 100);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_QAM_FSM_RATE_LIM__A, 40);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_QAM_FSM_COUNT_LIM__A, 4);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_QAM_FSM_FREQ_LIM__A, 10);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_QAM_FSM_MEDIAN_AV_MULT__A, (u16) 12);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_QAM_FSM_RADIUS_AV_LIMIT__A, (u16) 140);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_QAM_FSM_LCAVG_OFFSET1__A, (u16) -8);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_QAM_FSM_LCAVG_OFFSET2__A, (u16) -16);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_QAM_FSM_LCAVG_OFFSET3__A, (u16) -26);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_QAM_FSM_LCAVG_OFFSET4__A, (u16) -56);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_QAM_FSM_LCAVG_OFFSET5__A, (u16) -86);\r\nerror:\r\nif (status < 0)\r\nprintk(KERN_ERR "drxk: Error %d on %s\n", status, __func__);\r\nreturn status;\r\n}\r\nstatic int SetQAM64(struct drxk_state *state)\r\n{\r\nint status = 0;\r\ndprintk(1, "\n");\r\nstatus = write16(state, SCU_RAM_QAM_EQ_CMA_RAD0__A, 13336);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_QAM_EQ_CMA_RAD1__A, 12618);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_QAM_EQ_CMA_RAD2__A, 11988);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_QAM_EQ_CMA_RAD3__A, 13809);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_QAM_EQ_CMA_RAD4__A, 13809);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_QAM_EQ_CMA_RAD5__A, 15609);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, QAM_DQ_QUAL_FUN0__A, 4);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, QAM_DQ_QUAL_FUN1__A, 4);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, QAM_DQ_QUAL_FUN2__A, 4);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, QAM_DQ_QUAL_FUN3__A, 4);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, QAM_DQ_QUAL_FUN4__A, 3);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, QAM_DQ_QUAL_FUN5__A, 0);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, QAM_SY_SYNC_HWM__A, 5);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, QAM_SY_SYNC_AWM__A, 4);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, QAM_SY_SYNC_LWM__A, 3);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_QAM_SL_SIG_POWER__A, DRXK_QAM_SL_SIG_POWER_QAM64);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_QAM_LC_CA_FINE__A, 15);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_QAM_LC_CA_COARSE__A, 40);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_QAM_LC_EP_FINE__A, 12);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_QAM_LC_EP_MEDIUM__A, 24);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_QAM_LC_EP_COARSE__A, 24);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_QAM_LC_EI_FINE__A, 12);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_QAM_LC_EI_MEDIUM__A, 16);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_QAM_LC_EI_COARSE__A, 16);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_QAM_LC_CP_FINE__A, 5);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_QAM_LC_CP_MEDIUM__A, 30);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_QAM_LC_CP_COARSE__A, 100);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_QAM_LC_CI_FINE__A, 5);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_QAM_LC_CI_MEDIUM__A, 30);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_QAM_LC_CI_COARSE__A, 50);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_QAM_LC_CF_FINE__A, 16);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_QAM_LC_CF_MEDIUM__A, 25);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_QAM_LC_CF_COARSE__A, 48);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_QAM_LC_CF1_FINE__A, 5);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_QAM_LC_CF1_MEDIUM__A, 10);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_QAM_LC_CF1_COARSE__A, 10);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_QAM_FSM_RTH__A, 100);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_QAM_FSM_FTH__A, 60);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_QAM_FSM_CTH__A, 80);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_QAM_FSM_PTH__A, 110);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_QAM_FSM_QTH__A, 200);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_QAM_FSM_MTH__A, 95);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_QAM_FSM_RATE_LIM__A, 40);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_QAM_FSM_COUNT_LIM__A, 4);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_QAM_FSM_FREQ_LIM__A, 15);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_QAM_FSM_MEDIAN_AV_MULT__A, (u16) 12);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_QAM_FSM_RADIUS_AV_LIMIT__A, (u16) 141);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_QAM_FSM_LCAVG_OFFSET1__A, (u16) 7);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_QAM_FSM_LCAVG_OFFSET2__A, (u16) 0);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_QAM_FSM_LCAVG_OFFSET3__A, (u16) -15);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_QAM_FSM_LCAVG_OFFSET4__A, (u16) -45);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_QAM_FSM_LCAVG_OFFSET5__A, (u16) -80);\r\nerror:\r\nif (status < 0)\r\nprintk(KERN_ERR "drxk: Error %d on %s\n", status, __func__);\r\nreturn status;\r\n}\r\nstatic int SetQAM128(struct drxk_state *state)\r\n{\r\nint status = 0;\r\ndprintk(1, "\n");\r\nstatus = write16(state, SCU_RAM_QAM_EQ_CMA_RAD0__A, 6564);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_QAM_EQ_CMA_RAD1__A, 6598);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_QAM_EQ_CMA_RAD2__A, 6394);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_QAM_EQ_CMA_RAD3__A, 6409);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_QAM_EQ_CMA_RAD4__A, 6656);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_QAM_EQ_CMA_RAD5__A, 7238);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, QAM_DQ_QUAL_FUN0__A, 6);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, QAM_DQ_QUAL_FUN1__A, 6);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, QAM_DQ_QUAL_FUN2__A, 6);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, QAM_DQ_QUAL_FUN3__A, 6);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, QAM_DQ_QUAL_FUN4__A, 5);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, QAM_DQ_QUAL_FUN5__A, 0);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, QAM_SY_SYNC_HWM__A, 6);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, QAM_SY_SYNC_AWM__A, 5);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, QAM_SY_SYNC_LWM__A, 3);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_QAM_SL_SIG_POWER__A, DRXK_QAM_SL_SIG_POWER_QAM128);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_QAM_LC_CA_FINE__A, 15);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_QAM_LC_CA_COARSE__A, 40);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_QAM_LC_EP_FINE__A, 12);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_QAM_LC_EP_MEDIUM__A, 24);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_QAM_LC_EP_COARSE__A, 24);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_QAM_LC_EI_FINE__A, 12);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_QAM_LC_EI_MEDIUM__A, 16);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_QAM_LC_EI_COARSE__A, 16);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_QAM_LC_CP_FINE__A, 5);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_QAM_LC_CP_MEDIUM__A, 40);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_QAM_LC_CP_COARSE__A, 120);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_QAM_LC_CI_FINE__A, 5);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_QAM_LC_CI_MEDIUM__A, 40);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_QAM_LC_CI_COARSE__A, 60);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_QAM_LC_CF_FINE__A, 16);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_QAM_LC_CF_MEDIUM__A, 25);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_QAM_LC_CF_COARSE__A, 64);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_QAM_LC_CF1_FINE__A, 5);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_QAM_LC_CF1_MEDIUM__A, 10);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_QAM_LC_CF1_COARSE__A, 0);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_QAM_FSM_RTH__A, 50);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_QAM_FSM_FTH__A, 60);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_QAM_FSM_CTH__A, 80);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_QAM_FSM_PTH__A, 100);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_QAM_FSM_QTH__A, 140);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_QAM_FSM_MTH__A, 100);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_QAM_FSM_RATE_LIM__A, 40);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_QAM_FSM_COUNT_LIM__A, 5);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_QAM_FSM_FREQ_LIM__A, 12);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_QAM_FSM_MEDIAN_AV_MULT__A, (u16) 8);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_QAM_FSM_RADIUS_AV_LIMIT__A, (u16) 65);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_QAM_FSM_LCAVG_OFFSET1__A, (u16) 5);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_QAM_FSM_LCAVG_OFFSET2__A, (u16) 3);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_QAM_FSM_LCAVG_OFFSET3__A, (u16) -1);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_QAM_FSM_LCAVG_OFFSET4__A, (u16) -12);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_QAM_FSM_LCAVG_OFFSET5__A, (u16) -23);\r\nerror:\r\nif (status < 0)\r\nprintk(KERN_ERR "drxk: Error %d on %s\n", status, __func__);\r\nreturn status;\r\n}\r\nstatic int SetQAM256(struct drxk_state *state)\r\n{\r\nint status = 0;\r\ndprintk(1, "\n");\r\nstatus = write16(state, SCU_RAM_QAM_EQ_CMA_RAD0__A, 11502);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_QAM_EQ_CMA_RAD1__A, 12084);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_QAM_EQ_CMA_RAD2__A, 12543);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_QAM_EQ_CMA_RAD3__A, 12931);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_QAM_EQ_CMA_RAD4__A, 13629);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_QAM_EQ_CMA_RAD5__A, 15385);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, QAM_DQ_QUAL_FUN0__A, 8);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, QAM_DQ_QUAL_FUN1__A, 8);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, QAM_DQ_QUAL_FUN2__A, 8);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, QAM_DQ_QUAL_FUN3__A, 8);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, QAM_DQ_QUAL_FUN4__A, 6);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, QAM_DQ_QUAL_FUN5__A, 0);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, QAM_SY_SYNC_HWM__A, 5);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, QAM_SY_SYNC_AWM__A, 4);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, QAM_SY_SYNC_LWM__A, 3);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_QAM_SL_SIG_POWER__A, DRXK_QAM_SL_SIG_POWER_QAM256);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_QAM_LC_CA_FINE__A, 15);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_QAM_LC_CA_COARSE__A, 40);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_QAM_LC_EP_FINE__A, 12);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_QAM_LC_EP_MEDIUM__A, 24);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_QAM_LC_EP_COARSE__A, 24);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_QAM_LC_EI_FINE__A, 12);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_QAM_LC_EI_MEDIUM__A, 16);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_QAM_LC_EI_COARSE__A, 16);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_QAM_LC_CP_FINE__A, 5);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_QAM_LC_CP_MEDIUM__A, 50);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_QAM_LC_CP_COARSE__A, 250);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_QAM_LC_CI_FINE__A, 5);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_QAM_LC_CI_MEDIUM__A, 50);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_QAM_LC_CI_COARSE__A, 125);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_QAM_LC_CF_FINE__A, 16);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_QAM_LC_CF_MEDIUM__A, 25);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_QAM_LC_CF_COARSE__A, 48);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_QAM_LC_CF1_FINE__A, 5);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_QAM_LC_CF1_MEDIUM__A, 10);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_QAM_LC_CF1_COARSE__A, 10);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_QAM_FSM_RTH__A, 50);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_QAM_FSM_FTH__A, 60);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_QAM_FSM_CTH__A, 80);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_QAM_FSM_PTH__A, 100);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_QAM_FSM_QTH__A, 150);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_QAM_FSM_MTH__A, 110);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_QAM_FSM_RATE_LIM__A, 40);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_QAM_FSM_COUNT_LIM__A, 4);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_QAM_FSM_FREQ_LIM__A, 12);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_QAM_FSM_MEDIAN_AV_MULT__A, (u16) 8);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_QAM_FSM_RADIUS_AV_LIMIT__A, (u16) 74);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_QAM_FSM_LCAVG_OFFSET1__A, (u16) 18);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_QAM_FSM_LCAVG_OFFSET2__A, (u16) 13);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_QAM_FSM_LCAVG_OFFSET3__A, (u16) 7);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_QAM_FSM_LCAVG_OFFSET4__A, (u16) 0);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_QAM_FSM_LCAVG_OFFSET5__A, (u16) -8);\r\nerror:\r\nif (status < 0)\r\nprintk(KERN_ERR "drxk: Error %d on %s\n", status, __func__);\r\nreturn status;\r\n}\r\nstatic int QAMResetQAM(struct drxk_state *state)\r\n{\r\nint status;\r\nu16 cmdResult;\r\ndprintk(1, "\n");\r\nstatus = write16(state, QAM_COMM_EXEC__A, QAM_COMM_EXEC_STOP);\r\nif (status < 0)\r\ngoto error;\r\nstatus = scu_command(state, SCU_RAM_COMMAND_STANDARD_QAM | SCU_RAM_COMMAND_CMD_DEMOD_RESET, 0, NULL, 1, &cmdResult);\r\nerror:\r\nif (status < 0)\r\nprintk(KERN_ERR "drxk: Error %d on %s\n", status, __func__);\r\nreturn status;\r\n}\r\nstatic int QAMSetSymbolrate(struct drxk_state *state)\r\n{\r\nu32 adcFrequency = 0;\r\nu32 symbFreq = 0;\r\nu32 iqmRcRate = 0;\r\nu16 ratesel = 0;\r\nu32 lcSymbRate = 0;\r\nint status;\r\ndprintk(1, "\n");\r\nadcFrequency = (state->m_sysClockFreq * 1000) / 3;\r\nratesel = 0;\r\nif (state->props.symbol_rate <= 1188750)\r\nratesel = 3;\r\nelse if (state->props.symbol_rate <= 2377500)\r\nratesel = 2;\r\nelse if (state->props.symbol_rate <= 4755000)\r\nratesel = 1;\r\nstatus = write16(state, IQM_FD_RATESEL__A, ratesel);\r\nif (status < 0)\r\ngoto error;\r\nsymbFreq = state->props.symbol_rate * (1 << ratesel);\r\nif (symbFreq == 0) {\r\nstatus = -EINVAL;\r\ngoto error;\r\n}\r\niqmRcRate = (adcFrequency / symbFreq) * (1 << 21) +\r\n(Frac28a((adcFrequency % symbFreq), symbFreq) >> 7) -\r\n(1 << 23);\r\nstatus = write32(state, IQM_RC_RATE_OFS_LO__A, iqmRcRate);\r\nif (status < 0)\r\ngoto error;\r\nstate->m_iqmRcRate = iqmRcRate;\r\nsymbFreq = state->props.symbol_rate;\r\nif (adcFrequency == 0) {\r\nstatus = -EINVAL;\r\ngoto error;\r\n}\r\nlcSymbRate = (symbFreq / adcFrequency) * (1 << 12) +\r\n(Frac28a((symbFreq % adcFrequency), adcFrequency) >>\r\n16);\r\nif (lcSymbRate > 511)\r\nlcSymbRate = 511;\r\nstatus = write16(state, QAM_LC_SYMBOL_FREQ__A, (u16) lcSymbRate);\r\nerror:\r\nif (status < 0)\r\nprintk(KERN_ERR "drxk: Error %d on %s\n", status, __func__);\r\nreturn status;\r\n}\r\nstatic int GetQAMLockStatus(struct drxk_state *state, u32 *pLockStatus)\r\n{\r\nint status;\r\nu16 Result[2] = { 0, 0 };\r\ndprintk(1, "\n");\r\n*pLockStatus = NOT_LOCKED;\r\nstatus = scu_command(state,\r\nSCU_RAM_COMMAND_STANDARD_QAM |\r\nSCU_RAM_COMMAND_CMD_DEMOD_GET_LOCK, 0, NULL, 2,\r\nResult);\r\nif (status < 0)\r\nprintk(KERN_ERR "drxk: Error %d on %s\n", status, __func__);\r\nif (Result[1] < SCU_RAM_QAM_LOCKED_LOCKED_DEMOD_LOCKED) {\r\n} else if (Result[1] < SCU_RAM_QAM_LOCKED_LOCKED_LOCKED) {\r\n*pLockStatus = DEMOD_LOCK;\r\n} else if (Result[1] < SCU_RAM_QAM_LOCKED_LOCKED_NEVER_LOCK) {\r\n*pLockStatus = MPEG_LOCK;\r\n} else {\r\n*pLockStatus = NEVER_LOCK;\r\n}\r\nreturn status;\r\n}\r\nstatic int QAMDemodulatorCommand(struct drxk_state *state,\r\nint numberOfParameters)\r\n{\r\nint status;\r\nu16 cmdResult;\r\nu16 setParamParameters[4] = { 0, 0, 0, 0 };\r\nsetParamParameters[0] = state->m_Constellation;\r\nsetParamParameters[1] = DRXK_QAM_I12_J17;\r\nif (numberOfParameters == 2) {\r\nu16 setEnvParameters[1] = { 0 };\r\nif (state->m_OperationMode == OM_QAM_ITU_C)\r\nsetEnvParameters[0] = QAM_TOP_ANNEX_C;\r\nelse\r\nsetEnvParameters[0] = QAM_TOP_ANNEX_A;\r\nstatus = scu_command(state,\r\nSCU_RAM_COMMAND_STANDARD_QAM | SCU_RAM_COMMAND_CMD_DEMOD_SET_ENV,\r\n1, setEnvParameters, 1, &cmdResult);\r\nif (status < 0)\r\ngoto error;\r\nstatus = scu_command(state,\r\nSCU_RAM_COMMAND_STANDARD_QAM | SCU_RAM_COMMAND_CMD_DEMOD_SET_PARAM,\r\nnumberOfParameters, setParamParameters,\r\n1, &cmdResult);\r\n} else if (numberOfParameters == 4) {\r\nif (state->m_OperationMode == OM_QAM_ITU_C)\r\nsetParamParameters[2] = QAM_TOP_ANNEX_C;\r\nelse\r\nsetParamParameters[2] = QAM_TOP_ANNEX_A;\r\nsetParamParameters[3] |= (QAM_MIRROR_AUTO_ON);\r\nstatus = scu_command(state,\r\nSCU_RAM_COMMAND_STANDARD_QAM | SCU_RAM_COMMAND_CMD_DEMOD_SET_PARAM,\r\nnumberOfParameters, setParamParameters,\r\n1, &cmdResult);\r\n} else {\r\nprintk(KERN_WARNING "drxk: Unknown QAM demodulator parameter "\r\n"count %d\n", numberOfParameters);\r\nstatus = -EINVAL;\r\n}\r\nerror:\r\nif (status < 0)\r\nprintk(KERN_WARNING "drxk: Warning %d on %s\n",\r\nstatus, __func__);\r\nreturn status;\r\n}\r\nstatic int SetQAM(struct drxk_state *state, u16 IntermediateFreqkHz,\r\ns32 tunerFreqOffset)\r\n{\r\nint status;\r\nu16 cmdResult;\r\nint qamDemodParamCount = state->qam_demod_parameter_count;\r\ndprintk(1, "\n");\r\nstatus = write16(state, FEC_DI_COMM_EXEC__A, FEC_DI_COMM_EXEC_STOP);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, FEC_RS_COMM_EXEC__A, FEC_RS_COMM_EXEC_STOP);\r\nif (status < 0)\r\ngoto error;\r\nstatus = QAMResetQAM(state);\r\nif (status < 0)\r\ngoto error;\r\nstatus = QAMSetSymbolrate(state);\r\nif (status < 0)\r\ngoto error;\r\nswitch (state->props.modulation) {\r\ncase QAM_256:\r\nstate->m_Constellation = DRX_CONSTELLATION_QAM256;\r\nbreak;\r\ncase QAM_AUTO:\r\ncase QAM_64:\r\nstate->m_Constellation = DRX_CONSTELLATION_QAM64;\r\nbreak;\r\ncase QAM_16:\r\nstate->m_Constellation = DRX_CONSTELLATION_QAM16;\r\nbreak;\r\ncase QAM_32:\r\nstate->m_Constellation = DRX_CONSTELLATION_QAM32;\r\nbreak;\r\ncase QAM_128:\r\nstate->m_Constellation = DRX_CONSTELLATION_QAM128;\r\nbreak;\r\ndefault:\r\nstatus = -EINVAL;\r\nbreak;\r\n}\r\nif (status < 0)\r\ngoto error;\r\nif (state->qam_demod_parameter_count == 4\r\n|| !state->qam_demod_parameter_count) {\r\nqamDemodParamCount = 4;\r\nstatus = QAMDemodulatorCommand(state, qamDemodParamCount);\r\n}\r\nif (state->qam_demod_parameter_count == 2\r\n|| (!state->qam_demod_parameter_count && status < 0)) {\r\nqamDemodParamCount = 2;\r\nstatus = QAMDemodulatorCommand(state, qamDemodParamCount);\r\n}\r\nif (status < 0) {\r\ndprintk(1, "Could not set demodulator parameters. Make "\r\n"sure qam_demod_parameter_count (%d) is correct for "\r\n"your firmware (%s).\n",\r\nstate->qam_demod_parameter_count,\r\nstate->microcode_name);\r\ngoto error;\r\n} else if (!state->qam_demod_parameter_count) {\r\ndprintk(1, "Auto-probing the correct QAM demodulator command "\r\n"parameters was successful - using %d parameters.\n",\r\nqamDemodParamCount);\r\nstate->qam_demod_parameter_count = qamDemodParamCount;\r\n}\r\n#if 0\r\nstatus = SetFrequency(channel, tunerFreqOffset));\r\nif (status < 0)\r\ngoto error;\r\n#endif\r\nstatus = SetFrequencyShifter(state, IntermediateFreqkHz, tunerFreqOffset, true);\r\nif (status < 0)\r\ngoto error;\r\nstatus = SetQAMMeasurement(state, state->m_Constellation, state->props.symbol_rate);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, IQM_CF_SCALE_SH__A, IQM_CF_SCALE_SH__PRE);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, QAM_SY_TIMEOUT__A, QAM_SY_TIMEOUT__PRE);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, QAM_LC_RATE_LIMIT__A, 3);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, QAM_LC_LPF_FACTORP__A, 4);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, QAM_LC_LPF_FACTORI__A, 4);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, QAM_LC_MODE__A, 7);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, QAM_LC_QUAL_TAB0__A, 1);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, QAM_LC_QUAL_TAB1__A, 1);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, QAM_LC_QUAL_TAB2__A, 1);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, QAM_LC_QUAL_TAB3__A, 1);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, QAM_LC_QUAL_TAB4__A, 2);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, QAM_LC_QUAL_TAB5__A, 2);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, QAM_LC_QUAL_TAB6__A, 2);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, QAM_LC_QUAL_TAB8__A, 2);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, QAM_LC_QUAL_TAB9__A, 2);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, QAM_LC_QUAL_TAB10__A, 2);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, QAM_LC_QUAL_TAB12__A, 2);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, QAM_LC_QUAL_TAB15__A, 3);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, QAM_LC_QUAL_TAB16__A, 3);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, QAM_LC_QUAL_TAB20__A, 4);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, QAM_LC_QUAL_TAB25__A, 4);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, QAM_SY_SP_INV__A, QAM_SY_SP_INV_SPECTRUM_INV_DIS);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_COMM_EXEC__A, SCU_COMM_EXEC_HOLD);\r\nif (status < 0)\r\ngoto error;\r\nswitch (state->props.modulation) {\r\ncase QAM_16:\r\nstatus = SetQAM16(state);\r\nbreak;\r\ncase QAM_32:\r\nstatus = SetQAM32(state);\r\nbreak;\r\ncase QAM_AUTO:\r\ncase QAM_64:\r\nstatus = SetQAM64(state);\r\nbreak;\r\ncase QAM_128:\r\nstatus = SetQAM128(state);\r\nbreak;\r\ncase QAM_256:\r\nstatus = SetQAM256(state);\r\nbreak;\r\ndefault:\r\nstatus = -EINVAL;\r\nbreak;\r\n}\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_COMM_EXEC__A, SCU_COMM_EXEC_ACTIVE);\r\nif (status < 0)\r\ngoto error;\r\nstatus = MPEGTSDtoSetup(state, state->m_OperationMode);\r\nif (status < 0)\r\ngoto error;\r\nstatus = MPEGTSStart(state);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, FEC_COMM_EXEC__A, FEC_COMM_EXEC_ACTIVE);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, QAM_COMM_EXEC__A, QAM_COMM_EXEC_ACTIVE);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, IQM_COMM_EXEC__A, IQM_COMM_EXEC_B_ACTIVE);\r\nif (status < 0)\r\ngoto error;\r\nstatus = scu_command(state, SCU_RAM_COMMAND_STANDARD_QAM | SCU_RAM_COMMAND_CMD_DEMOD_START, 0, NULL, 1, &cmdResult);\r\nif (status < 0)\r\ngoto error;\r\nerror:\r\nif (status < 0)\r\nprintk(KERN_ERR "drxk: Error %d on %s\n", status, __func__);\r\nreturn status;\r\n}\r\nstatic int SetQAMStandard(struct drxk_state *state,\r\nenum OperationMode oMode)\r\n{\r\nint status;\r\n#ifdef DRXK_QAM_TAPS\r\n#define DRXK_QAMA_TAPS_SELECT\r\n#include "drxk_filters.h"\r\n#undef DRXK_QAMA_TAPS_SELECT\r\n#endif\r\ndprintk(1, "\n");\r\nSwitchAntennaToQAM(state);\r\nstatus = PowerUpQAM(state);\r\nif (status < 0)\r\ngoto error;\r\nstatus = QAMResetQAM(state);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, IQM_COMM_EXEC__A, IQM_COMM_EXEC_B_STOP);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, IQM_AF_AMUX__A, IQM_AF_AMUX_SIGNAL2ADC);\r\nif (status < 0)\r\ngoto error;\r\nswitch (oMode) {\r\ncase OM_QAM_ITU_A:\r\nstatus = BLChainCmd(state, DRXK_BL_ROM_OFFSET_TAPS_ITU_A, DRXK_BLCC_NR_ELEMENTS_TAPS, DRXK_BLC_TIMEOUT);\r\nbreak;\r\ncase OM_QAM_ITU_C:\r\nstatus = BLDirectCmd(state, IQM_CF_TAP_RE0__A, DRXK_BL_ROM_OFFSET_TAPS_ITU_C, DRXK_BLDC_NR_ELEMENTS_TAPS, DRXK_BLC_TIMEOUT);\r\nif (status < 0)\r\ngoto error;\r\nstatus = BLDirectCmd(state, IQM_CF_TAP_IM0__A, DRXK_BL_ROM_OFFSET_TAPS_ITU_C, DRXK_BLDC_NR_ELEMENTS_TAPS, DRXK_BLC_TIMEOUT);\r\nbreak;\r\ndefault:\r\nstatus = -EINVAL;\r\n}\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, IQM_CF_OUT_ENA__A, (1 << IQM_CF_OUT_ENA_QAM__B));\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, IQM_CF_SYMMETRIC__A, 0);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, IQM_CF_MIDTAP__A, ((1 << IQM_CF_MIDTAP_RE__B) | (1 << IQM_CF_MIDTAP_IM__B)));\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, IQM_RC_STRETCH__A, 21);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, IQM_AF_CLP_LEN__A, 0);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, IQM_AF_CLP_TH__A, 448);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, IQM_AF_SNS_LEN__A, 0);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, IQM_CF_POW_MEAS_LEN__A, 0);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, IQM_FS_ADJ_SEL__A, 1);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, IQM_RC_ADJ_SEL__A, 1);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, IQM_CF_ADJ_SEL__A, 1);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, IQM_AF_UPD_SEL__A, 0);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, IQM_CF_CLP_VAL__A, 500);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, IQM_CF_DATATH__A, 1000);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, IQM_CF_BYPASSDET__A, 1);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, IQM_CF_DET_LCT__A, 0);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, IQM_CF_WND_LEN__A, 1);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, IQM_CF_PKDTH__A, 1);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, IQM_AF_INC_BYPASS__A, 1);\r\nif (status < 0)\r\ngoto error;\r\nstatus = SetIqmAf(state, true);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, IQM_AF_START_LOCK__A, 0x01);\r\nif (status < 0)\r\ngoto error;\r\nstatus = ADCSynchronization(state);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_RAM_QAM_FSM_STEP_PERIOD__A, 2000);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_COMM_EXEC__A, SCU_COMM_EXEC_HOLD);\r\nif (status < 0)\r\ngoto error;\r\nstatus = InitAGC(state, true);\r\nif (status < 0)\r\ngoto error;\r\nstatus = SetPreSaw(state, &(state->m_qamPreSawCfg));\r\nif (status < 0)\r\ngoto error;\r\nstatus = SetAgcRf(state, &(state->m_qamRfAgcCfg), true);\r\nif (status < 0)\r\ngoto error;\r\nstatus = SetAgcIf(state, &(state->m_qamIfAgcCfg), true);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_COMM_EXEC__A, SCU_COMM_EXEC_ACTIVE);\r\nerror:\r\nif (status < 0)\r\nprintk(KERN_ERR "drxk: Error %d on %s\n", status, __func__);\r\nreturn status;\r\n}\r\nstatic int WriteGPIO(struct drxk_state *state)\r\n{\r\nint status;\r\nu16 value = 0;\r\ndprintk(1, "\n");\r\nstatus = write16(state, SCU_RAM_GPIO__A, SCU_RAM_GPIO_HW_LOCK_IND_DISABLE);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SIO_TOP_COMM_KEY__A, SIO_TOP_COMM_KEY_KEY);\r\nif (status < 0)\r\ngoto error;\r\nif (state->m_hasSAWSW) {\r\nif (state->UIO_mask & 0x0001) {\r\nstatus = write16(state, SIO_PDR_SMA_TX_CFG__A, state->m_GPIOCfg);\r\nif (status < 0)\r\ngoto error;\r\nstatus = read16(state, SIO_PDR_UIO_OUT_LO__A, &value);\r\nif (status < 0)\r\ngoto error;\r\nif ((state->m_GPIO & 0x0001) == 0)\r\nvalue &= 0x7FFF;\r\nelse\r\nvalue |= 0x8000;\r\nstatus = write16(state, SIO_PDR_UIO_OUT_LO__A, value);\r\nif (status < 0)\r\ngoto error;\r\n}\r\nif (state->UIO_mask & 0x0002) {\r\nstatus = write16(state, SIO_PDR_SMA_RX_CFG__A, state->m_GPIOCfg);\r\nif (status < 0)\r\ngoto error;\r\nstatus = read16(state, SIO_PDR_UIO_OUT_LO__A, &value);\r\nif (status < 0)\r\ngoto error;\r\nif ((state->m_GPIO & 0x0002) == 0)\r\nvalue &= 0xBFFF;\r\nelse\r\nvalue |= 0x4000;\r\nstatus = write16(state, SIO_PDR_UIO_OUT_LO__A, value);\r\nif (status < 0)\r\ngoto error;\r\n}\r\nif (state->UIO_mask & 0x0004) {\r\nstatus = write16(state, SIO_PDR_GPIO_CFG__A, state->m_GPIOCfg);\r\nif (status < 0)\r\ngoto error;\r\nstatus = read16(state, SIO_PDR_UIO_OUT_LO__A, &value);\r\nif (status < 0)\r\ngoto error;\r\nif ((state->m_GPIO & 0x0004) == 0)\r\nvalue &= 0xFFFB;\r\nelse\r\nvalue |= 0x0004;\r\nstatus = write16(state, SIO_PDR_UIO_OUT_LO__A, value);\r\nif (status < 0)\r\ngoto error;\r\n}\r\n}\r\nstatus = write16(state, SIO_TOP_COMM_KEY__A, 0x0000);\r\nerror:\r\nif (status < 0)\r\nprintk(KERN_ERR "drxk: Error %d on %s\n", status, __func__);\r\nreturn status;\r\n}\r\nstatic int SwitchAntennaToQAM(struct drxk_state *state)\r\n{\r\nint status = 0;\r\nbool gpio_state;\r\ndprintk(1, "\n");\r\nif (!state->antenna_gpio)\r\nreturn 0;\r\ngpio_state = state->m_GPIO & state->antenna_gpio;\r\nif (state->antenna_dvbt ^ gpio_state) {\r\nif (state->antenna_dvbt)\r\nstate->m_GPIO &= ~state->antenna_gpio;\r\nelse\r\nstate->m_GPIO |= state->antenna_gpio;\r\nstatus = WriteGPIO(state);\r\n}\r\nif (status < 0)\r\nprintk(KERN_ERR "drxk: Error %d on %s\n", status, __func__);\r\nreturn status;\r\n}\r\nstatic int SwitchAntennaToDVBT(struct drxk_state *state)\r\n{\r\nint status = 0;\r\nbool gpio_state;\r\ndprintk(1, "\n");\r\nif (!state->antenna_gpio)\r\nreturn 0;\r\ngpio_state = state->m_GPIO & state->antenna_gpio;\r\nif (!(state->antenna_dvbt ^ gpio_state)) {\r\nif (state->antenna_dvbt)\r\nstate->m_GPIO |= state->antenna_gpio;\r\nelse\r\nstate->m_GPIO &= ~state->antenna_gpio;\r\nstatus = WriteGPIO(state);\r\n}\r\nif (status < 0)\r\nprintk(KERN_ERR "drxk: Error %d on %s\n", status, __func__);\r\nreturn status;\r\n}\r\nstatic int PowerDownDevice(struct drxk_state *state)\r\n{\r\nint status;\r\ndprintk(1, "\n");\r\nif (state->m_bPDownOpenBridge) {\r\nstatus = ConfigureI2CBridge(state, true);\r\nif (status < 0)\r\ngoto error;\r\n}\r\nstatus = DVBTEnableOFDMTokenRing(state, false);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SIO_CC_PWD_MODE__A, SIO_CC_PWD_MODE_LEVEL_CLOCK);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SIO_CC_UPDATE__A, SIO_CC_UPDATE_KEY);\r\nif (status < 0)\r\ngoto error;\r\nstate->m_HICfgCtrl |= SIO_HI_RA_RAM_PAR_5_CFG_SLEEP_ZZZ;\r\nstatus = HI_CfgCommand(state);\r\nerror:\r\nif (status < 0)\r\nprintk(KERN_ERR "drxk: Error %d on %s\n", status, __func__);\r\nreturn status;\r\n}\r\nstatic int init_drxk(struct drxk_state *state)\r\n{\r\nint status = 0, n = 0;\r\nenum DRXPowerMode powerMode = DRXK_POWER_DOWN_OFDM;\r\nu16 driverVersion;\r\ndprintk(1, "\n");\r\nif ((state->m_DrxkState == DRXK_UNINITIALIZED)) {\r\ndrxk_i2c_lock(state);\r\nstatus = PowerUpDevice(state);\r\nif (status < 0)\r\ngoto error;\r\nstatus = DRXX_Open(state);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SIO_CC_SOFT_RST__A, SIO_CC_SOFT_RST_OFDM__M | SIO_CC_SOFT_RST_SYS__M | SIO_CC_SOFT_RST_OSC__M);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SIO_CC_UPDATE__A, SIO_CC_UPDATE_KEY);\r\nif (status < 0)\r\ngoto error;\r\nmsleep(1);\r\nstate->m_DRXK_A3_PATCH_CODE = true;\r\nstatus = GetDeviceCapabilities(state);\r\nif (status < 0)\r\ngoto error;\r\nstate->m_HICfgBridgeDelay =\r\n(u16) ((state->m_oscClockFreq / 1000) *\r\nHI_I2C_BRIDGE_DELAY) / 1000;\r\nif (state->m_HICfgBridgeDelay >\r\nSIO_HI_RA_RAM_PAR_3_CFG_DBL_SDA__M) {\r\nstate->m_HICfgBridgeDelay =\r\nSIO_HI_RA_RAM_PAR_3_CFG_DBL_SDA__M;\r\n}\r\nstate->m_HICfgBridgeDelay +=\r\nstate->m_HICfgBridgeDelay <<\r\nSIO_HI_RA_RAM_PAR_3_CFG_DBL_SCL__B;\r\nstatus = InitHI(state);\r\nif (status < 0)\r\ngoto error;\r\n#if NOA1ROM\r\nif (!(state->m_DRXK_A1_ROM_CODE)\r\n&& !(state->m_DRXK_A2_ROM_CODE))\r\n#endif\r\n{\r\nstatus = write16(state, SCU_RAM_GPIO__A, SCU_RAM_GPIO_HW_LOCK_IND_DISABLE);\r\nif (status < 0)\r\ngoto error;\r\n}\r\nstatus = MPEGTSDisable(state);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, AUD_COMM_EXEC__A, AUD_COMM_EXEC_STOP);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_COMM_EXEC__A, SCU_COMM_EXEC_STOP);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SIO_OFDM_SH_OFDM_RING_ENABLE__A, SIO_OFDM_SH_OFDM_RING_ENABLE_ON);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SIO_BL_COMM_EXEC__A, SIO_BL_COMM_EXEC_ACTIVE);\r\nif (status < 0)\r\ngoto error;\r\nstatus = BLChainCmd(state, 0, 6, 100);\r\nif (status < 0)\r\ngoto error;\r\nif (state->fw) {\r\nstatus = DownloadMicrocode(state, state->fw->data,\r\nstate->fw->size);\r\nif (status < 0)\r\ngoto error;\r\n}\r\nstatus = write16(state, SIO_OFDM_SH_OFDM_RING_ENABLE__A, SIO_OFDM_SH_OFDM_RING_ENABLE_OFF);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, SCU_COMM_EXEC__A, SCU_COMM_EXEC_ACTIVE);\r\nif (status < 0)\r\ngoto error;\r\nstatus = DRXX_Open(state);\r\nif (status < 0)\r\ngoto error;\r\nmsleep(30);\r\npowerMode = DRXK_POWER_DOWN_OFDM;\r\nstatus = CtrlPowerMode(state, &powerMode);\r\nif (status < 0)\r\ngoto error;\r\ndriverVersion =\r\n(((DRXK_VERSION_MAJOR / 100) % 10) << 12) +\r\n(((DRXK_VERSION_MAJOR / 10) % 10) << 8) +\r\n((DRXK_VERSION_MAJOR % 10) << 4) +\r\n(DRXK_VERSION_MINOR % 10);\r\nstatus = write16(state, SCU_RAM_DRIVER_VER_HI__A, driverVersion);\r\nif (status < 0)\r\ngoto error;\r\ndriverVersion =\r\n(((DRXK_VERSION_PATCH / 1000) % 10) << 12) +\r\n(((DRXK_VERSION_PATCH / 100) % 10) << 8) +\r\n(((DRXK_VERSION_PATCH / 10) % 10) << 4) +\r\n(DRXK_VERSION_PATCH % 10);\r\nstatus = write16(state, SCU_RAM_DRIVER_VER_LO__A, driverVersion);\r\nif (status < 0)\r\ngoto error;\r\nprintk(KERN_INFO "DRXK driver version %d.%d.%d\n",\r\nDRXK_VERSION_MAJOR, DRXK_VERSION_MINOR,\r\nDRXK_VERSION_PATCH);\r\nstatus = write16(state, SCU_RAM_DRIVER_DEBUG__A, 0);\r\nif (status < 0)\r\ngoto error;\r\nstatus = write16(state, FEC_COMM_EXEC__A, FEC_COMM_EXEC_STOP);\r\nif (status < 0)\r\ngoto error;\r\nstatus = MPEGTSDtoInit(state);\r\nif (status < 0)\r\ngoto error;\r\nstatus = MPEGTSStop(state);\r\nif (status < 0)\r\ngoto error;\r\nstatus = MPEGTSConfigurePolarity(state);\r\nif (status < 0)\r\ngoto error;\r\nstatus = MPEGTSConfigurePins(state, state->m_enableMPEGOutput);\r\nif (status < 0)\r\ngoto error;\r\nstatus = WriteGPIO(state);\r\nif (status < 0)\r\ngoto error;\r\nstate->m_DrxkState = DRXK_STOPPED;\r\nif (state->m_bPowerDown) {\r\nstatus = PowerDownDevice(state);\r\nif (status < 0)\r\ngoto error;\r\nstate->m_DrxkState = DRXK_POWERED_DOWN;\r\n} else\r\nstate->m_DrxkState = DRXK_STOPPED;\r\nn = 0;\r\nif (state->m_hasDVBC) {\r\nstate->frontend.ops.delsys[n++] = SYS_DVBC_ANNEX_A;\r\nstate->frontend.ops.delsys[n++] = SYS_DVBC_ANNEX_C;\r\nstrlcat(state->frontend.ops.info.name, " DVB-C",\r\nsizeof(state->frontend.ops.info.name));\r\n}\r\nif (state->m_hasDVBT) {\r\nstate->frontend.ops.delsys[n++] = SYS_DVBT;\r\nstrlcat(state->frontend.ops.info.name, " DVB-T",\r\nsizeof(state->frontend.ops.info.name));\r\n}\r\ndrxk_i2c_unlock(state);\r\n}\r\nerror:\r\nif (status < 0) {\r\nstate->m_DrxkState = DRXK_NO_DEV;\r\ndrxk_i2c_unlock(state);\r\nprintk(KERN_ERR "drxk: Error %d on %s\n", status, __func__);\r\n}\r\nreturn status;\r\n}\r\nstatic void load_firmware_cb(const struct firmware *fw,\r\nvoid *context)\r\n{\r\nstruct drxk_state *state = context;\r\ndprintk(1, ": %s\n", fw ? "firmware loaded" : "firmware not loaded");\r\nif (!fw) {\r\nprintk(KERN_ERR\r\n"drxk: Could not load firmware file %s.\n",\r\nstate->microcode_name);\r\nprintk(KERN_INFO\r\n"drxk: Copy %s to your hotplug directory!\n",\r\nstate->microcode_name);\r\nstate->microcode_name = NULL;\r\n}\r\nstate->fw = fw;\r\ninit_drxk(state);\r\n}\r\nstatic void drxk_release(struct dvb_frontend *fe)\r\n{\r\nstruct drxk_state *state = fe->demodulator_priv;\r\ndprintk(1, "\n");\r\nif (state->fw)\r\nrelease_firmware(state->fw);\r\nkfree(state);\r\n}\r\nstatic int drxk_sleep(struct dvb_frontend *fe)\r\n{\r\nstruct drxk_state *state = fe->demodulator_priv;\r\ndprintk(1, "\n");\r\nif (state->m_DrxkState == DRXK_NO_DEV)\r\nreturn -ENODEV;\r\nif (state->m_DrxkState == DRXK_UNINITIALIZED)\r\nreturn 0;\r\nShutDown(state);\r\nreturn 0;\r\n}\r\nstatic int drxk_gate_ctrl(struct dvb_frontend *fe, int enable)\r\n{\r\nstruct drxk_state *state = fe->demodulator_priv;\r\ndprintk(1, ": %s\n", enable ? "enable" : "disable");\r\nif (state->m_DrxkState == DRXK_NO_DEV)\r\nreturn -ENODEV;\r\nreturn ConfigureI2CBridge(state, enable ? true : false);\r\n}\r\nstatic int drxk_set_parameters(struct dvb_frontend *fe)\r\n{\r\nstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\r\nu32 delsys = p->delivery_system, old_delsys;\r\nstruct drxk_state *state = fe->demodulator_priv;\r\nu32 IF;\r\ndprintk(1, "\n");\r\nif (state->m_DrxkState == DRXK_NO_DEV)\r\nreturn -ENODEV;\r\nif (state->m_DrxkState == DRXK_UNINITIALIZED)\r\nreturn -EAGAIN;\r\nif (!fe->ops.tuner_ops.get_if_frequency) {\r\nprintk(KERN_ERR\r\n"drxk: Error: get_if_frequency() not defined at tuner. Can't work without it!\n");\r\nreturn -EINVAL;\r\n}\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 1);\r\nif (fe->ops.tuner_ops.set_params)\r\nfe->ops.tuner_ops.set_params(fe);\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 0);\r\nold_delsys = state->props.delivery_system;\r\nstate->props = *p;\r\nif (old_delsys != delsys) {\r\nShutDown(state);\r\nswitch (delsys) {\r\ncase SYS_DVBC_ANNEX_A:\r\ncase SYS_DVBC_ANNEX_C:\r\nif (!state->m_hasDVBC)\r\nreturn -EINVAL;\r\nstate->m_itut_annex_c = (delsys == SYS_DVBC_ANNEX_C) ? true : false;\r\nif (state->m_itut_annex_c)\r\nSetOperationMode(state, OM_QAM_ITU_C);\r\nelse\r\nSetOperationMode(state, OM_QAM_ITU_A);\r\nbreak;\r\ncase SYS_DVBT:\r\nif (!state->m_hasDVBT)\r\nreturn -EINVAL;\r\nSetOperationMode(state, OM_DVBT);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nfe->ops.tuner_ops.get_if_frequency(fe, &IF);\r\nStart(state, 0, IF);\r\nreturn 0;\r\n}\r\nstatic int drxk_read_status(struct dvb_frontend *fe, fe_status_t *status)\r\n{\r\nstruct drxk_state *state = fe->demodulator_priv;\r\nu32 stat;\r\ndprintk(1, "\n");\r\nif (state->m_DrxkState == DRXK_NO_DEV)\r\nreturn -ENODEV;\r\nif (state->m_DrxkState == DRXK_UNINITIALIZED)\r\nreturn -EAGAIN;\r\n*status = 0;\r\nGetLockStatus(state, &stat, 0);\r\nif (stat == MPEG_LOCK)\r\n*status |= 0x1f;\r\nif (stat == FEC_LOCK)\r\n*status |= 0x0f;\r\nif (stat == DEMOD_LOCK)\r\n*status |= 0x07;\r\nreturn 0;\r\n}\r\nstatic int drxk_read_ber(struct dvb_frontend *fe, u32 *ber)\r\n{\r\nstruct drxk_state *state = fe->demodulator_priv;\r\ndprintk(1, "\n");\r\nif (state->m_DrxkState == DRXK_NO_DEV)\r\nreturn -ENODEV;\r\nif (state->m_DrxkState == DRXK_UNINITIALIZED)\r\nreturn -EAGAIN;\r\n*ber = 0;\r\nreturn 0;\r\n}\r\nstatic int drxk_read_signal_strength(struct dvb_frontend *fe,\r\nu16 *strength)\r\n{\r\nstruct drxk_state *state = fe->demodulator_priv;\r\nu32 val = 0;\r\ndprintk(1, "\n");\r\nif (state->m_DrxkState == DRXK_NO_DEV)\r\nreturn -ENODEV;\r\nif (state->m_DrxkState == DRXK_UNINITIALIZED)\r\nreturn -EAGAIN;\r\nReadIFAgc(state, &val);\r\n*strength = val & 0xffff;\r\nreturn 0;\r\n}\r\nstatic int drxk_read_snr(struct dvb_frontend *fe, u16 *snr)\r\n{\r\nstruct drxk_state *state = fe->demodulator_priv;\r\ns32 snr2;\r\ndprintk(1, "\n");\r\nif (state->m_DrxkState == DRXK_NO_DEV)\r\nreturn -ENODEV;\r\nif (state->m_DrxkState == DRXK_UNINITIALIZED)\r\nreturn -EAGAIN;\r\nGetSignalToNoise(state, &snr2);\r\n*snr = snr2 & 0xffff;\r\nreturn 0;\r\n}\r\nstatic int drxk_read_ucblocks(struct dvb_frontend *fe, u32 *ucblocks)\r\n{\r\nstruct drxk_state *state = fe->demodulator_priv;\r\nu16 err;\r\ndprintk(1, "\n");\r\nif (state->m_DrxkState == DRXK_NO_DEV)\r\nreturn -ENODEV;\r\nif (state->m_DrxkState == DRXK_UNINITIALIZED)\r\nreturn -EAGAIN;\r\nDVBTQAMGetAccPktErr(state, &err);\r\n*ucblocks = (u32) err;\r\nreturn 0;\r\n}\r\nstatic int drxk_get_tune_settings(struct dvb_frontend *fe, struct dvb_frontend_tune_settings\r\n*sets)\r\n{\r\nstruct drxk_state *state = fe->demodulator_priv;\r\nstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\r\ndprintk(1, "\n");\r\nif (state->m_DrxkState == DRXK_NO_DEV)\r\nreturn -ENODEV;\r\nif (state->m_DrxkState == DRXK_UNINITIALIZED)\r\nreturn -EAGAIN;\r\nswitch (p->delivery_system) {\r\ncase SYS_DVBC_ANNEX_A:\r\ncase SYS_DVBC_ANNEX_C:\r\ncase SYS_DVBT:\r\nsets->min_delay_ms = 3000;\r\nsets->max_drift = 0;\r\nsets->step_size = 0;\r\nreturn 0;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstruct dvb_frontend *drxk_attach(const struct drxk_config *config,\r\nstruct i2c_adapter *i2c)\r\n{\r\nstruct drxk_state *state = NULL;\r\nu8 adr = config->adr;\r\nint status;\r\ndprintk(1, "\n");\r\nstate = kzalloc(sizeof(struct drxk_state), GFP_KERNEL);\r\nif (!state)\r\nreturn NULL;\r\nstate->i2c = i2c;\r\nstate->demod_address = adr;\r\nstate->single_master = config->single_master;\r\nstate->microcode_name = config->microcode_name;\r\nstate->qam_demod_parameter_count = config->qam_demod_parameter_count;\r\nstate->no_i2c_bridge = config->no_i2c_bridge;\r\nstate->antenna_gpio = config->antenna_gpio;\r\nstate->antenna_dvbt = config->antenna_dvbt;\r\nstate->m_ChunkSize = config->chunk_size;\r\nstate->enable_merr_cfg = config->enable_merr_cfg;\r\nif (config->dynamic_clk) {\r\nstate->m_DVBTStaticCLK = 0;\r\nstate->m_DVBCStaticCLK = 0;\r\n} else {\r\nstate->m_DVBTStaticCLK = 1;\r\nstate->m_DVBCStaticCLK = 1;\r\n}\r\nif (config->mpeg_out_clk_strength)\r\nstate->m_TSClockkStrength = config->mpeg_out_clk_strength & 0x07;\r\nelse\r\nstate->m_TSClockkStrength = 0x06;\r\nif (config->parallel_ts)\r\nstate->m_enableParallel = true;\r\nelse\r\nstate->m_enableParallel = false;\r\nstate->UIO_mask = config->antenna_gpio;\r\nif (!state->antenna_dvbt && state->antenna_gpio)\r\nstate->m_GPIO |= state->antenna_gpio;\r\nelse\r\nstate->m_GPIO &= ~state->antenna_gpio;\r\nmutex_init(&state->mutex);\r\nmemcpy(&state->frontend.ops, &drxk_ops, sizeof(drxk_ops));\r\nstate->frontend.demodulator_priv = state;\r\ninit_state(state);\r\nif (state->microcode_name) {\r\nif (config->load_firmware_sync) {\r\nconst struct firmware *fw = NULL;\r\nstatus = request_firmware(&fw, state->microcode_name,\r\nstate->i2c->dev.parent);\r\nif (status < 0)\r\nfw = NULL;\r\nload_firmware_cb(fw, state);\r\n} else {\r\nstatus = request_firmware_nowait(THIS_MODULE, 1,\r\nstate->microcode_name,\r\nstate->i2c->dev.parent,\r\nGFP_KERNEL,\r\nstate, load_firmware_cb);\r\nif (status < 0) {\r\nprintk(KERN_ERR\r\n"drxk: failed to request a firmware\n");\r\nreturn NULL;\r\n}\r\n}\r\n} else if (init_drxk(state) < 0)\r\ngoto error;\r\nprintk(KERN_INFO "drxk: frontend initialized.\n");\r\nreturn &state->frontend;\r\nerror:\r\nprintk(KERN_ERR "drxk: not found\n");\r\nkfree(state);\r\nreturn NULL;\r\n}
