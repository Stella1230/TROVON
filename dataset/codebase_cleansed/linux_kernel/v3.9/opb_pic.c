static u32 opb_in(struct opb_pic *opb, int offset)\r\n{\r\nreturn in_be32(opb->regs + offset);\r\n}\r\nstatic void opb_out(struct opb_pic *opb, int offset, u32 val)\r\n{\r\nout_be32(opb->regs + offset, val);\r\n}\r\nstatic void opb_unmask_irq(struct irq_data *d)\r\n{\r\nstruct opb_pic *opb;\r\nunsigned long flags;\r\nu32 ier, bitset;\r\nopb = d->chip_data;\r\nbitset = (1 << (31 - irqd_to_hwirq(d)));\r\nspin_lock_irqsave(&opb->lock, flags);\r\nier = opb_in(opb, OPB_MLSIER);\r\nopb_out(opb, OPB_MLSIER, ier | bitset);\r\nier = opb_in(opb, OPB_MLSIER);\r\nspin_unlock_irqrestore(&opb->lock, flags);\r\n}\r\nstatic void opb_mask_irq(struct irq_data *d)\r\n{\r\nstruct opb_pic *opb;\r\nunsigned long flags;\r\nu32 ier, mask;\r\nopb = d->chip_data;\r\nmask = ~(1 << (31 - irqd_to_hwirq(d)));\r\nspin_lock_irqsave(&opb->lock, flags);\r\nier = opb_in(opb, OPB_MLSIER);\r\nopb_out(opb, OPB_MLSIER, ier & mask);\r\nier = opb_in(opb, OPB_MLSIER);\r\nspin_unlock_irqrestore(&opb->lock, flags);\r\n}\r\nstatic void opb_ack_irq(struct irq_data *d)\r\n{\r\nstruct opb_pic *opb;\r\nunsigned long flags;\r\nu32 bitset;\r\nopb = d->chip_data;\r\nbitset = (1 << (31 - irqd_to_hwirq(d)));\r\nspin_lock_irqsave(&opb->lock, flags);\r\nopb_out(opb, OPB_MLSIR, bitset);\r\nopb_in(opb, OPB_MLSIR);\r\nspin_unlock_irqrestore(&opb->lock, flags);\r\n}\r\nstatic void opb_mask_ack_irq(struct irq_data *d)\r\n{\r\nstruct opb_pic *opb;\r\nunsigned long flags;\r\nu32 bitset;\r\nu32 ier, ir;\r\nopb = d->chip_data;\r\nbitset = (1 << (31 - irqd_to_hwirq(d)));\r\nspin_lock_irqsave(&opb->lock, flags);\r\nier = opb_in(opb, OPB_MLSIER);\r\nopb_out(opb, OPB_MLSIER, ier & ~bitset);\r\nier = opb_in(opb, OPB_MLSIER);\r\nopb_out(opb, OPB_MLSIR, bitset);\r\nir = opb_in(opb, OPB_MLSIR);\r\nspin_unlock_irqrestore(&opb->lock, flags);\r\n}\r\nstatic int opb_set_irq_type(struct irq_data *d, unsigned int flow)\r\n{\r\nstruct opb_pic *opb;\r\nunsigned long flags;\r\nint invert, ipr, mask, bit;\r\nopb = d->chip_data;\r\nswitch (flow) {\r\ncase IRQ_TYPE_NONE:\r\nopb_mask_irq(d);\r\nreturn 0;\r\ncase IRQ_TYPE_LEVEL_HIGH:\r\ninvert = 0;\r\nbreak;\r\ncase IRQ_TYPE_LEVEL_LOW:\r\ninvert = 1;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nbit = (1 << (31 - irqd_to_hwirq(d)));\r\nmask = ~bit;\r\nspin_lock_irqsave(&opb->lock, flags);\r\nipr = opb_in(opb, OPB_MLSIPR);\r\nipr = (ipr & mask) | (invert ? bit : 0);\r\nopb_out(opb, OPB_MLSIPR, ipr);\r\nipr = opb_in(opb, OPB_MLSIPR);\r\nspin_unlock_irqrestore(&opb->lock, flags);\r\nirqd_set_trigger_type(d, flow);\r\nreturn 0;\r\n}\r\nstatic int opb_host_map(struct irq_domain *host, unsigned int virq,\r\nirq_hw_number_t hwirq)\r\n{\r\nstruct opb_pic *opb;\r\nopb = host->host_data;\r\nirq_set_chip_data(virq, opb);\r\nirq_set_chip_and_handler(virq, &opb_irq_chip, handle_level_irq);\r\nirq_set_irq_type(virq, IRQ_TYPE_NONE);\r\nreturn 0;\r\n}\r\nirqreturn_t opb_irq_handler(int irq, void *private)\r\n{\r\nstruct opb_pic *opb;\r\nu32 ir, src, subvirq;\r\nopb = (struct opb_pic *) private;\r\nir = opb_in(opb, OPB_MLSIR);\r\nif (!ir)\r\nreturn IRQ_NONE;\r\ndo {\r\nsrc = 32 - ffs(ir);\r\nsubvirq = irq_linear_revmap(opb->host, src);\r\ngeneric_handle_irq(subvirq);\r\n} while ((ir = opb_in(opb, OPB_MLSIR)));\r\nreturn IRQ_HANDLED;\r\n}\r\nstruct opb_pic *opb_pic_init_one(struct device_node *dn)\r\n{\r\nstruct opb_pic *opb;\r\nstruct resource res;\r\nif (of_address_to_resource(dn, 0, &res)) {\r\nprintk(KERN_ERR "opb: Couldn't translate resource\n");\r\nreturn NULL;\r\n}\r\nopb = kzalloc(sizeof(struct opb_pic), GFP_KERNEL);\r\nif (!opb) {\r\nprintk(KERN_ERR "opb: Failed to allocate opb struct!\n");\r\nreturn NULL;\r\n}\r\nopb->regs = ioremap(res.start + 0x10000, 0x1000);\r\nif (!opb->regs) {\r\nprintk(KERN_ERR "opb: Failed to allocate register space!\n");\r\ngoto free_opb;\r\n}\r\nopb->host = irq_domain_add_linear(dn, OPB_NR_IRQS, &opb_host_ops, opb);\r\nif (!opb->host) {\r\nprintk(KERN_ERR "opb: Failed to allocate IRQ host!\n");\r\ngoto free_regs;\r\n}\r\nopb->index = opb_index++;\r\nspin_lock_init(&opb->lock);\r\nopb_out(opb, OPB_MLSASIER, 0);\r\nopb_out(opb, OPB_MLSIER, 0);\r\nopb_out(opb, OPB_MLSIR, 0xFFFFFFFF);\r\nreturn opb;\r\nfree_regs:\r\niounmap(opb->regs);\r\nfree_opb:\r\nkfree(opb);\r\nreturn NULL;\r\n}\r\nvoid __init opb_pic_init(void)\r\n{\r\nstruct device_node *dn;\r\nstruct opb_pic *opb;\r\nint virq;\r\nint rc;\r\nfor_each_compatible_node(dn, NULL, "ibm,opb") {\r\nopb = opb_pic_init_one(dn);\r\nif (!opb) {\r\nprintk(KERN_WARNING "opb: Failed to init node, skipped!\n");\r\ncontinue;\r\n}\r\nvirq = irq_of_parse_and_map(dn, 0);\r\nif (virq <= 0) {\r\nprintk("opb: irq_op_parse_and_map failed!\n");\r\ncontinue;\r\n}\r\nrc = request_irq(virq, opb_irq_handler, IRQF_NO_THREAD,\r\n"OPB LS Cascade", opb);\r\nif (rc) {\r\nprintk("opb: request_irq failed: %d\n", rc);\r\ncontinue;\r\n}\r\nprintk("OPB%d init with %d IRQs at %p\n", opb->index,\r\nOPB_NR_IRQS, opb->regs);\r\n}\r\n}
