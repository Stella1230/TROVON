static inline struct nf_tcp_net *tcp_pernet(struct net *net)\r\n{\r\nreturn &net->ct.nf_ct_proto.tcp;\r\n}\r\nstatic bool tcp_pkt_to_tuple(const struct sk_buff *skb, unsigned int dataoff,\r\nstruct nf_conntrack_tuple *tuple)\r\n{\r\nconst struct tcphdr *hp;\r\nstruct tcphdr _hdr;\r\nhp = skb_header_pointer(skb, dataoff, 8, &_hdr);\r\nif (hp == NULL)\r\nreturn false;\r\ntuple->src.u.tcp.port = hp->source;\r\ntuple->dst.u.tcp.port = hp->dest;\r\nreturn true;\r\n}\r\nstatic bool tcp_invert_tuple(struct nf_conntrack_tuple *tuple,\r\nconst struct nf_conntrack_tuple *orig)\r\n{\r\ntuple->src.u.tcp.port = orig->dst.u.tcp.port;\r\ntuple->dst.u.tcp.port = orig->src.u.tcp.port;\r\nreturn true;\r\n}\r\nstatic int tcp_print_tuple(struct seq_file *s,\r\nconst struct nf_conntrack_tuple *tuple)\r\n{\r\nreturn seq_printf(s, "sport=%hu dport=%hu ",\r\nntohs(tuple->src.u.tcp.port),\r\nntohs(tuple->dst.u.tcp.port));\r\n}\r\nstatic int tcp_print_conntrack(struct seq_file *s, struct nf_conn *ct)\r\n{\r\nenum tcp_conntrack state;\r\nspin_lock_bh(&ct->lock);\r\nstate = ct->proto.tcp.state;\r\nspin_unlock_bh(&ct->lock);\r\nreturn seq_printf(s, "%s ", tcp_conntrack_names[state]);\r\n}\r\nstatic unsigned int get_conntrack_index(const struct tcphdr *tcph)\r\n{\r\nif (tcph->rst) return TCP_RST_SET;\r\nelse if (tcph->syn) return (tcph->ack ? TCP_SYNACK_SET : TCP_SYN_SET);\r\nelse if (tcph->fin) return TCP_FIN_SET;\r\nelse if (tcph->ack) return TCP_ACK_SET;\r\nelse return TCP_NONE_SET;\r\n}\r\nstatic inline __u32 segment_seq_plus_len(__u32 seq,\r\nsize_t len,\r\nunsigned int dataoff,\r\nconst struct tcphdr *tcph)\r\n{\r\nreturn (seq + len - dataoff - tcph->doff*4\r\n+ (tcph->syn ? 1 : 0) + (tcph->fin ? 1 : 0));\r\n}\r\nstatic void tcp_options(const struct sk_buff *skb,\r\nunsigned int dataoff,\r\nconst struct tcphdr *tcph,\r\nstruct ip_ct_tcp_state *state)\r\n{\r\nunsigned char buff[(15 * 4) - sizeof(struct tcphdr)];\r\nconst unsigned char *ptr;\r\nint length = (tcph->doff*4) - sizeof(struct tcphdr);\r\nif (!length)\r\nreturn;\r\nptr = skb_header_pointer(skb, dataoff + sizeof(struct tcphdr),\r\nlength, buff);\r\nBUG_ON(ptr == NULL);\r\nstate->td_scale =\r\nstate->flags = 0;\r\nwhile (length > 0) {\r\nint opcode=*ptr++;\r\nint opsize;\r\nswitch (opcode) {\r\ncase TCPOPT_EOL:\r\nreturn;\r\ncase TCPOPT_NOP:\r\nlength--;\r\ncontinue;\r\ndefault:\r\nopsize=*ptr++;\r\nif (opsize < 2)\r\nreturn;\r\nif (opsize > length)\r\nreturn;\r\nif (opcode == TCPOPT_SACK_PERM\r\n&& opsize == TCPOLEN_SACK_PERM)\r\nstate->flags |= IP_CT_TCP_FLAG_SACK_PERM;\r\nelse if (opcode == TCPOPT_WINDOW\r\n&& opsize == TCPOLEN_WINDOW) {\r\nstate->td_scale = *(u_int8_t *)ptr;\r\nif (state->td_scale > 14) {\r\nstate->td_scale = 14;\r\n}\r\nstate->flags |=\r\nIP_CT_TCP_FLAG_WINDOW_SCALE;\r\n}\r\nptr += opsize - 2;\r\nlength -= opsize;\r\n}\r\n}\r\n}\r\nstatic void tcp_sack(const struct sk_buff *skb, unsigned int dataoff,\r\nconst struct tcphdr *tcph, __u32 *sack)\r\n{\r\nunsigned char buff[(15 * 4) - sizeof(struct tcphdr)];\r\nconst unsigned char *ptr;\r\nint length = (tcph->doff*4) - sizeof(struct tcphdr);\r\n__u32 tmp;\r\nif (!length)\r\nreturn;\r\nptr = skb_header_pointer(skb, dataoff + sizeof(struct tcphdr),\r\nlength, buff);\r\nBUG_ON(ptr == NULL);\r\nif (length == TCPOLEN_TSTAMP_ALIGNED\r\n&& *(__be32 *)ptr == htonl((TCPOPT_NOP << 24)\r\n| (TCPOPT_NOP << 16)\r\n| (TCPOPT_TIMESTAMP << 8)\r\n| TCPOLEN_TIMESTAMP))\r\nreturn;\r\nwhile (length > 0) {\r\nint opcode = *ptr++;\r\nint opsize, i;\r\nswitch (opcode) {\r\ncase TCPOPT_EOL:\r\nreturn;\r\ncase TCPOPT_NOP:\r\nlength--;\r\ncontinue;\r\ndefault:\r\nopsize = *ptr++;\r\nif (opsize < 2)\r\nreturn;\r\nif (opsize > length)\r\nreturn;\r\nif (opcode == TCPOPT_SACK\r\n&& opsize >= (TCPOLEN_SACK_BASE\r\n+ TCPOLEN_SACK_PERBLOCK)\r\n&& !((opsize - TCPOLEN_SACK_BASE)\r\n% TCPOLEN_SACK_PERBLOCK)) {\r\nfor (i = 0;\r\ni < (opsize - TCPOLEN_SACK_BASE);\r\ni += TCPOLEN_SACK_PERBLOCK) {\r\ntmp = get_unaligned_be32((__be32 *)(ptr+i)+1);\r\nif (after(tmp, *sack))\r\n*sack = tmp;\r\n}\r\nreturn;\r\n}\r\nptr += opsize - 2;\r\nlength -= opsize;\r\n}\r\n}\r\n}\r\nstatic inline s16 nat_offset(const struct nf_conn *ct,\r\nenum ip_conntrack_dir dir,\r\nu32 seq)\r\n{\r\ntypeof(nf_ct_nat_offset) get_offset = rcu_dereference(nf_ct_nat_offset);\r\nreturn get_offset != NULL ? get_offset(ct, dir, seq) : 0;\r\n}\r\nstatic bool tcp_in_window(const struct nf_conn *ct,\r\nstruct ip_ct_tcp *state,\r\nenum ip_conntrack_dir dir,\r\nunsigned int index,\r\nconst struct sk_buff *skb,\r\nunsigned int dataoff,\r\nconst struct tcphdr *tcph,\r\nu_int8_t pf)\r\n{\r\nstruct net *net = nf_ct_net(ct);\r\nstruct nf_tcp_net *tn = tcp_pernet(net);\r\nstruct ip_ct_tcp_state *sender = &state->seen[dir];\r\nstruct ip_ct_tcp_state *receiver = &state->seen[!dir];\r\nconst struct nf_conntrack_tuple *tuple = &ct->tuplehash[dir].tuple;\r\n__u32 seq, ack, sack, end, win, swin;\r\ns16 receiver_offset;\r\nbool res;\r\nseq = ntohl(tcph->seq);\r\nack = sack = ntohl(tcph->ack_seq);\r\nwin = ntohs(tcph->window);\r\nend = segment_seq_plus_len(seq, skb->len, dataoff, tcph);\r\nif (receiver->flags & IP_CT_TCP_FLAG_SACK_PERM)\r\ntcp_sack(skb, dataoff, tcph, &sack);\r\nreceiver_offset = NAT_OFFSET(ct, !dir, ack - 1);\r\nack -= receiver_offset;\r\nsack -= receiver_offset;\r\npr_debug("tcp_in_window: START\n");\r\npr_debug("tcp_in_window: ");\r\nnf_ct_dump_tuple(tuple);\r\npr_debug("seq=%u ack=%u+(%d) sack=%u+(%d) win=%u end=%u\n",\r\nseq, ack, receiver_offset, sack, receiver_offset, win, end);\r\npr_debug("tcp_in_window: sender end=%u maxend=%u maxwin=%u scale=%i "\r\n"receiver end=%u maxend=%u maxwin=%u scale=%i\n",\r\nsender->td_end, sender->td_maxend, sender->td_maxwin,\r\nsender->td_scale,\r\nreceiver->td_end, receiver->td_maxend, receiver->td_maxwin,\r\nreceiver->td_scale);\r\nif (sender->td_maxwin == 0) {\r\nif (tcph->syn) {\r\nsender->td_end =\r\nsender->td_maxend = end;\r\nsender->td_maxwin = (win == 0 ? 1 : win);\r\ntcp_options(skb, dataoff, tcph, sender);\r\nif (!(sender->flags & IP_CT_TCP_FLAG_WINDOW_SCALE\r\n&& receiver->flags & IP_CT_TCP_FLAG_WINDOW_SCALE))\r\nsender->td_scale =\r\nreceiver->td_scale = 0;\r\nif (!tcph->ack)\r\nreturn true;\r\n} else {\r\nsender->td_end = end;\r\nswin = win << sender->td_scale;\r\nsender->td_maxwin = (swin == 0 ? 1 : swin);\r\nsender->td_maxend = end + sender->td_maxwin;\r\nif (receiver->td_maxwin == 0)\r\nreceiver->td_end = receiver->td_maxend = sack;\r\n}\r\n} else if (((state->state == TCP_CONNTRACK_SYN_SENT\r\n&& dir == IP_CT_DIR_ORIGINAL)\r\n|| (state->state == TCP_CONNTRACK_SYN_RECV\r\n&& dir == IP_CT_DIR_REPLY))\r\n&& after(end, sender->td_end)) {\r\nsender->td_end =\r\nsender->td_maxend = end;\r\nsender->td_maxwin = (win == 0 ? 1 : win);\r\ntcp_options(skb, dataoff, tcph, sender);\r\n}\r\nif (!(tcph->ack)) {\r\nack = sack = receiver->td_end;\r\n} else if (((tcp_flag_word(tcph) & (TCP_FLAG_ACK|TCP_FLAG_RST)) ==\r\n(TCP_FLAG_ACK|TCP_FLAG_RST))\r\n&& (ack == 0)) {\r\nack = sack = receiver->td_end;\r\n}\r\nif (tcph->rst && seq == 0 && state->state == TCP_CONNTRACK_SYN_SENT)\r\nseq = end = sender->td_end;\r\npr_debug("tcp_in_window: ");\r\nnf_ct_dump_tuple(tuple);\r\npr_debug("seq=%u ack=%u+(%d) sack=%u+(%d) win=%u end=%u\n",\r\nseq, ack, receiver_offset, sack, receiver_offset, win, end);\r\npr_debug("tcp_in_window: sender end=%u maxend=%u maxwin=%u scale=%i "\r\n"receiver end=%u maxend=%u maxwin=%u scale=%i\n",\r\nsender->td_end, sender->td_maxend, sender->td_maxwin,\r\nsender->td_scale,\r\nreceiver->td_end, receiver->td_maxend, receiver->td_maxwin,\r\nreceiver->td_scale);\r\npr_debug("tcp_in_window: I=%i II=%i III=%i IV=%i\n",\r\nbefore(seq, sender->td_maxend + 1),\r\nafter(end, sender->td_end - receiver->td_maxwin - 1),\r\nbefore(sack, receiver->td_end + 1),\r\nafter(sack, receiver->td_end - MAXACKWINDOW(sender) - 1));\r\nif (before(seq, sender->td_maxend + 1) &&\r\nafter(end, sender->td_end - receiver->td_maxwin - 1) &&\r\nbefore(sack, receiver->td_end + 1) &&\r\nafter(sack, receiver->td_end - MAXACKWINDOW(sender) - 1)) {\r\nif (!tcph->syn)\r\nwin <<= sender->td_scale;\r\nswin = win + (sack - ack);\r\nif (sender->td_maxwin < swin)\r\nsender->td_maxwin = swin;\r\nif (after(end, sender->td_end)) {\r\nsender->td_end = end;\r\nsender->flags |= IP_CT_TCP_FLAG_DATA_UNACKNOWLEDGED;\r\n}\r\nif (tcph->ack) {\r\nif (!(sender->flags & IP_CT_TCP_FLAG_MAXACK_SET)) {\r\nsender->td_maxack = ack;\r\nsender->flags |= IP_CT_TCP_FLAG_MAXACK_SET;\r\n} else if (after(ack, sender->td_maxack))\r\nsender->td_maxack = ack;\r\n}\r\nif (receiver->td_maxwin != 0 && after(end, sender->td_maxend))\r\nreceiver->td_maxwin += end - sender->td_maxend;\r\nif (after(sack + win, receiver->td_maxend - 1)) {\r\nreceiver->td_maxend = sack + win;\r\nif (win == 0)\r\nreceiver->td_maxend++;\r\n}\r\nif (ack == receiver->td_end)\r\nreceiver->flags &= ~IP_CT_TCP_FLAG_DATA_UNACKNOWLEDGED;\r\nif (index == TCP_ACK_SET) {\r\nif (state->last_dir == dir\r\n&& state->last_seq == seq\r\n&& state->last_ack == ack\r\n&& state->last_end == end\r\n&& state->last_win == win)\r\nstate->retrans++;\r\nelse {\r\nstate->last_dir = dir;\r\nstate->last_seq = seq;\r\nstate->last_ack = ack;\r\nstate->last_end = end;\r\nstate->last_win = win;\r\nstate->retrans = 0;\r\n}\r\n}\r\nres = true;\r\n} else {\r\nres = false;\r\nif (sender->flags & IP_CT_TCP_FLAG_BE_LIBERAL ||\r\ntn->tcp_be_liberal)\r\nres = true;\r\nif (!res && LOG_INVALID(net, IPPROTO_TCP))\r\nnf_log_packet(pf, 0, skb, NULL, NULL, NULL,\r\n"nf_ct_tcp: %s ",\r\nbefore(seq, sender->td_maxend + 1) ?\r\nafter(end, sender->td_end - receiver->td_maxwin - 1) ?\r\nbefore(sack, receiver->td_end + 1) ?\r\nafter(sack, receiver->td_end - MAXACKWINDOW(sender) - 1) ? "BUG"\r\n: "ACK is under the lower bound (possible overly delayed ACK)"\r\n: "ACK is over the upper bound (ACKed data not seen yet)"\r\n: "SEQ is under the lower bound (already ACKed data retransmitted)"\r\n: "SEQ is over the upper bound (over the window of the receiver)");\r\n}\r\npr_debug("tcp_in_window: res=%u sender end=%u maxend=%u maxwin=%u "\r\n"receiver end=%u maxend=%u maxwin=%u\n",\r\nres, sender->td_end, sender->td_maxend, sender->td_maxwin,\r\nreceiver->td_end, receiver->td_maxend, receiver->td_maxwin);\r\nreturn res;\r\n}\r\nstatic int tcp_error(struct net *net, struct nf_conn *tmpl,\r\nstruct sk_buff *skb,\r\nunsigned int dataoff,\r\nenum ip_conntrack_info *ctinfo,\r\nu_int8_t pf,\r\nunsigned int hooknum)\r\n{\r\nconst struct tcphdr *th;\r\nstruct tcphdr _tcph;\r\nunsigned int tcplen = skb->len - dataoff;\r\nu_int8_t tcpflags;\r\nth = skb_header_pointer(skb, dataoff, sizeof(_tcph), &_tcph);\r\nif (th == NULL) {\r\nif (LOG_INVALID(net, IPPROTO_TCP))\r\nnf_log_packet(pf, 0, skb, NULL, NULL, NULL,\r\n"nf_ct_tcp: short packet ");\r\nreturn -NF_ACCEPT;\r\n}\r\nif (th->doff*4 < sizeof(struct tcphdr) || tcplen < th->doff*4) {\r\nif (LOG_INVALID(net, IPPROTO_TCP))\r\nnf_log_packet(pf, 0, skb, NULL, NULL, NULL,\r\n"nf_ct_tcp: truncated/malformed packet ");\r\nreturn -NF_ACCEPT;\r\n}\r\nif (net->ct.sysctl_checksum && hooknum == NF_INET_PRE_ROUTING &&\r\nnf_checksum(skb, hooknum, dataoff, IPPROTO_TCP, pf)) {\r\nif (LOG_INVALID(net, IPPROTO_TCP))\r\nnf_log_packet(pf, 0, skb, NULL, NULL, NULL,\r\n"nf_ct_tcp: bad TCP checksum ");\r\nreturn -NF_ACCEPT;\r\n}\r\ntcpflags = (tcp_flag_byte(th) & ~(TCPHDR_ECE|TCPHDR_CWR|TCPHDR_PSH));\r\nif (!tcp_valid_flags[tcpflags]) {\r\nif (LOG_INVALID(net, IPPROTO_TCP))\r\nnf_log_packet(pf, 0, skb, NULL, NULL, NULL,\r\n"nf_ct_tcp: invalid TCP flag combination ");\r\nreturn -NF_ACCEPT;\r\n}\r\nreturn NF_ACCEPT;\r\n}\r\nstatic unsigned int *tcp_get_timeouts(struct net *net)\r\n{\r\nreturn tcp_pernet(net)->timeouts;\r\n}\r\nstatic int tcp_packet(struct nf_conn *ct,\r\nconst struct sk_buff *skb,\r\nunsigned int dataoff,\r\nenum ip_conntrack_info ctinfo,\r\nu_int8_t pf,\r\nunsigned int hooknum,\r\nunsigned int *timeouts)\r\n{\r\nstruct net *net = nf_ct_net(ct);\r\nstruct nf_tcp_net *tn = tcp_pernet(net);\r\nstruct nf_conntrack_tuple *tuple;\r\nenum tcp_conntrack new_state, old_state;\r\nenum ip_conntrack_dir dir;\r\nconst struct tcphdr *th;\r\nstruct tcphdr _tcph;\r\nunsigned long timeout;\r\nunsigned int index;\r\nth = skb_header_pointer(skb, dataoff, sizeof(_tcph), &_tcph);\r\nBUG_ON(th == NULL);\r\nspin_lock_bh(&ct->lock);\r\nold_state = ct->proto.tcp.state;\r\ndir = CTINFO2DIR(ctinfo);\r\nindex = get_conntrack_index(th);\r\nnew_state = tcp_conntracks[dir][index][old_state];\r\ntuple = &ct->tuplehash[dir].tuple;\r\nswitch (new_state) {\r\ncase TCP_CONNTRACK_SYN_SENT:\r\nif (old_state < TCP_CONNTRACK_TIME_WAIT)\r\nbreak;\r\nif (((ct->proto.tcp.seen[dir].flags\r\n| ct->proto.tcp.seen[!dir].flags)\r\n& IP_CT_TCP_FLAG_CLOSE_INIT)\r\n|| (ct->proto.tcp.last_dir == dir\r\n&& ct->proto.tcp.last_index == TCP_RST_SET)) {\r\nspin_unlock_bh(&ct->lock);\r\nif (nf_ct_kill(ct))\r\nreturn -NF_REPEAT;\r\nreturn NF_DROP;\r\n}\r\ncase TCP_CONNTRACK_IGNORE:\r\nif (index == TCP_SYNACK_SET\r\n&& ct->proto.tcp.last_index == TCP_SYN_SET\r\n&& ct->proto.tcp.last_dir != dir\r\n&& ntohl(th->ack_seq) == ct->proto.tcp.last_end) {\r\nold_state = TCP_CONNTRACK_SYN_SENT;\r\nnew_state = TCP_CONNTRACK_SYN_RECV;\r\nct->proto.tcp.seen[ct->proto.tcp.last_dir].td_end =\r\nct->proto.tcp.last_end;\r\nct->proto.tcp.seen[ct->proto.tcp.last_dir].td_maxend =\r\nct->proto.tcp.last_end;\r\nct->proto.tcp.seen[ct->proto.tcp.last_dir].td_maxwin =\r\nct->proto.tcp.last_win == 0 ?\r\n1 : ct->proto.tcp.last_win;\r\nct->proto.tcp.seen[ct->proto.tcp.last_dir].td_scale =\r\nct->proto.tcp.last_wscale;\r\nct->proto.tcp.seen[ct->proto.tcp.last_dir].flags =\r\nct->proto.tcp.last_flags;\r\nmemset(&ct->proto.tcp.seen[dir], 0,\r\nsizeof(struct ip_ct_tcp_state));\r\nbreak;\r\n}\r\nct->proto.tcp.last_index = index;\r\nct->proto.tcp.last_dir = dir;\r\nct->proto.tcp.last_seq = ntohl(th->seq);\r\nct->proto.tcp.last_end =\r\nsegment_seq_plus_len(ntohl(th->seq), skb->len, dataoff, th);\r\nct->proto.tcp.last_win = ntohs(th->window);\r\nif (index == TCP_SYN_SET && dir == IP_CT_DIR_ORIGINAL) {\r\nstruct ip_ct_tcp_state seen = {};\r\nct->proto.tcp.last_flags =\r\nct->proto.tcp.last_wscale = 0;\r\ntcp_options(skb, dataoff, th, &seen);\r\nif (seen.flags & IP_CT_TCP_FLAG_WINDOW_SCALE) {\r\nct->proto.tcp.last_flags |=\r\nIP_CT_TCP_FLAG_WINDOW_SCALE;\r\nct->proto.tcp.last_wscale = seen.td_scale;\r\n}\r\nif (seen.flags & IP_CT_TCP_FLAG_SACK_PERM) {\r\nct->proto.tcp.last_flags |=\r\nIP_CT_TCP_FLAG_SACK_PERM;\r\n}\r\n}\r\nspin_unlock_bh(&ct->lock);\r\nif (LOG_INVALID(net, IPPROTO_TCP))\r\nnf_log_packet(pf, 0, skb, NULL, NULL, NULL,\r\n"nf_ct_tcp: invalid packet ignored in "\r\n"state %s ", tcp_conntrack_names[old_state]);\r\nreturn NF_ACCEPT;\r\ncase TCP_CONNTRACK_MAX:\r\npr_debug("nf_ct_tcp: Invalid dir=%i index=%u ostate=%u\n",\r\ndir, get_conntrack_index(th), old_state);\r\nspin_unlock_bh(&ct->lock);\r\nif (LOG_INVALID(net, IPPROTO_TCP))\r\nnf_log_packet(pf, 0, skb, NULL, NULL, NULL,\r\n"nf_ct_tcp: invalid state ");\r\nreturn -NF_ACCEPT;\r\ncase TCP_CONNTRACK_CLOSE:\r\nif (index == TCP_RST_SET\r\n&& (ct->proto.tcp.seen[!dir].flags & IP_CT_TCP_FLAG_MAXACK_SET)\r\n&& before(ntohl(th->seq), ct->proto.tcp.seen[!dir].td_maxack)) {\r\nspin_unlock_bh(&ct->lock);\r\nif (LOG_INVALID(net, IPPROTO_TCP))\r\nnf_log_packet(pf, 0, skb, NULL, NULL, NULL,\r\n"nf_ct_tcp: invalid RST ");\r\nreturn -NF_ACCEPT;\r\n}\r\nif (index == TCP_RST_SET\r\n&& ((test_bit(IPS_SEEN_REPLY_BIT, &ct->status)\r\n&& ct->proto.tcp.last_index == TCP_SYN_SET)\r\n|| (!test_bit(IPS_ASSURED_BIT, &ct->status)\r\n&& ct->proto.tcp.last_index == TCP_ACK_SET))\r\n&& ntohl(th->ack_seq) == ct->proto.tcp.last_end) {\r\ngoto in_window;\r\n}\r\ndefault:\r\nbreak;\r\n}\r\nif (!tcp_in_window(ct, &ct->proto.tcp, dir, index,\r\nskb, dataoff, th, pf)) {\r\nspin_unlock_bh(&ct->lock);\r\nreturn -NF_ACCEPT;\r\n}\r\nin_window:\r\nct->proto.tcp.last_index = index;\r\nct->proto.tcp.last_dir = dir;\r\npr_debug("tcp_conntracks: ");\r\nnf_ct_dump_tuple(tuple);\r\npr_debug("syn=%i ack=%i fin=%i rst=%i old=%i new=%i\n",\r\n(th->syn ? 1 : 0), (th->ack ? 1 : 0),\r\n(th->fin ? 1 : 0), (th->rst ? 1 : 0),\r\nold_state, new_state);\r\nct->proto.tcp.state = new_state;\r\nif (old_state != new_state\r\n&& new_state == TCP_CONNTRACK_FIN_WAIT)\r\nct->proto.tcp.seen[dir].flags |= IP_CT_TCP_FLAG_CLOSE_INIT;\r\nif (ct->proto.tcp.retrans >= tn->tcp_max_retrans &&\r\ntimeouts[new_state] > timeouts[TCP_CONNTRACK_RETRANS])\r\ntimeout = timeouts[TCP_CONNTRACK_RETRANS];\r\nelse if ((ct->proto.tcp.seen[0].flags | ct->proto.tcp.seen[1].flags) &\r\nIP_CT_TCP_FLAG_DATA_UNACKNOWLEDGED &&\r\ntimeouts[new_state] > timeouts[TCP_CONNTRACK_UNACK])\r\ntimeout = timeouts[TCP_CONNTRACK_UNACK];\r\nelse\r\ntimeout = timeouts[new_state];\r\nspin_unlock_bh(&ct->lock);\r\nif (new_state != old_state)\r\nnf_conntrack_event_cache(IPCT_PROTOINFO, ct);\r\nif (!test_bit(IPS_SEEN_REPLY_BIT, &ct->status)) {\r\nif (th->rst) {\r\nnf_ct_kill_acct(ct, ctinfo, skb);\r\nreturn NF_ACCEPT;\r\n}\r\n} else if (!test_bit(IPS_ASSURED_BIT, &ct->status)\r\n&& (old_state == TCP_CONNTRACK_SYN_RECV\r\n|| old_state == TCP_CONNTRACK_ESTABLISHED)\r\n&& new_state == TCP_CONNTRACK_ESTABLISHED) {\r\nset_bit(IPS_ASSURED_BIT, &ct->status);\r\nnf_conntrack_event_cache(IPCT_ASSURED, ct);\r\n}\r\nnf_ct_refresh_acct(ct, ctinfo, skb, timeout);\r\nreturn NF_ACCEPT;\r\n}\r\nstatic bool tcp_new(struct nf_conn *ct, const struct sk_buff *skb,\r\nunsigned int dataoff, unsigned int *timeouts)\r\n{\r\nenum tcp_conntrack new_state;\r\nconst struct tcphdr *th;\r\nstruct tcphdr _tcph;\r\nstruct net *net = nf_ct_net(ct);\r\nstruct nf_tcp_net *tn = tcp_pernet(net);\r\nconst struct ip_ct_tcp_state *sender = &ct->proto.tcp.seen[0];\r\nconst struct ip_ct_tcp_state *receiver = &ct->proto.tcp.seen[1];\r\nth = skb_header_pointer(skb, dataoff, sizeof(_tcph), &_tcph);\r\nBUG_ON(th == NULL);\r\nnew_state = tcp_conntracks[0][get_conntrack_index(th)][TCP_CONNTRACK_NONE];\r\nif (new_state >= TCP_CONNTRACK_MAX) {\r\npr_debug("nf_ct_tcp: invalid new deleting.\n");\r\nreturn false;\r\n}\r\nif (new_state == TCP_CONNTRACK_SYN_SENT) {\r\nmemset(&ct->proto.tcp, 0, sizeof(ct->proto.tcp));\r\nct->proto.tcp.seen[0].td_end =\r\nsegment_seq_plus_len(ntohl(th->seq), skb->len,\r\ndataoff, th);\r\nct->proto.tcp.seen[0].td_maxwin = ntohs(th->window);\r\nif (ct->proto.tcp.seen[0].td_maxwin == 0)\r\nct->proto.tcp.seen[0].td_maxwin = 1;\r\nct->proto.tcp.seen[0].td_maxend =\r\nct->proto.tcp.seen[0].td_end;\r\ntcp_options(skb, dataoff, th, &ct->proto.tcp.seen[0]);\r\n} else if (tn->tcp_loose == 0) {\r\nreturn false;\r\n} else {\r\nmemset(&ct->proto.tcp, 0, sizeof(ct->proto.tcp));\r\nct->proto.tcp.seen[0].td_end =\r\nsegment_seq_plus_len(ntohl(th->seq), skb->len,\r\ndataoff, th);\r\nct->proto.tcp.seen[0].td_maxwin = ntohs(th->window);\r\nif (ct->proto.tcp.seen[0].td_maxwin == 0)\r\nct->proto.tcp.seen[0].td_maxwin = 1;\r\nct->proto.tcp.seen[0].td_maxend =\r\nct->proto.tcp.seen[0].td_end +\r\nct->proto.tcp.seen[0].td_maxwin;\r\nct->proto.tcp.seen[0].flags =\r\nct->proto.tcp.seen[1].flags = IP_CT_TCP_FLAG_SACK_PERM |\r\nIP_CT_TCP_FLAG_BE_LIBERAL;\r\n}\r\nct->proto.tcp.last_index = TCP_NONE_SET;\r\npr_debug("tcp_new: sender end=%u maxend=%u maxwin=%u scale=%i "\r\n"receiver end=%u maxend=%u maxwin=%u scale=%i\n",\r\nsender->td_end, sender->td_maxend, sender->td_maxwin,\r\nsender->td_scale,\r\nreceiver->td_end, receiver->td_maxend, receiver->td_maxwin,\r\nreceiver->td_scale);\r\nreturn true;\r\n}\r\nstatic int tcp_to_nlattr(struct sk_buff *skb, struct nlattr *nla,\r\nstruct nf_conn *ct)\r\n{\r\nstruct nlattr *nest_parms;\r\nstruct nf_ct_tcp_flags tmp = {};\r\nspin_lock_bh(&ct->lock);\r\nnest_parms = nla_nest_start(skb, CTA_PROTOINFO_TCP | NLA_F_NESTED);\r\nif (!nest_parms)\r\ngoto nla_put_failure;\r\nif (nla_put_u8(skb, CTA_PROTOINFO_TCP_STATE, ct->proto.tcp.state) ||\r\nnla_put_u8(skb, CTA_PROTOINFO_TCP_WSCALE_ORIGINAL,\r\nct->proto.tcp.seen[0].td_scale) ||\r\nnla_put_u8(skb, CTA_PROTOINFO_TCP_WSCALE_REPLY,\r\nct->proto.tcp.seen[1].td_scale))\r\ngoto nla_put_failure;\r\ntmp.flags = ct->proto.tcp.seen[0].flags;\r\nif (nla_put(skb, CTA_PROTOINFO_TCP_FLAGS_ORIGINAL,\r\nsizeof(struct nf_ct_tcp_flags), &tmp))\r\ngoto nla_put_failure;\r\ntmp.flags = ct->proto.tcp.seen[1].flags;\r\nif (nla_put(skb, CTA_PROTOINFO_TCP_FLAGS_REPLY,\r\nsizeof(struct nf_ct_tcp_flags), &tmp))\r\ngoto nla_put_failure;\r\nspin_unlock_bh(&ct->lock);\r\nnla_nest_end(skb, nest_parms);\r\nreturn 0;\r\nnla_put_failure:\r\nspin_unlock_bh(&ct->lock);\r\nreturn -1;\r\n}\r\nstatic int nlattr_to_tcp(struct nlattr *cda[], struct nf_conn *ct)\r\n{\r\nstruct nlattr *pattr = cda[CTA_PROTOINFO_TCP];\r\nstruct nlattr *tb[CTA_PROTOINFO_TCP_MAX+1];\r\nint err;\r\nif (!pattr)\r\nreturn 0;\r\nerr = nla_parse_nested(tb, CTA_PROTOINFO_TCP_MAX, pattr, tcp_nla_policy);\r\nif (err < 0)\r\nreturn err;\r\nif (tb[CTA_PROTOINFO_TCP_STATE] &&\r\nnla_get_u8(tb[CTA_PROTOINFO_TCP_STATE]) >= TCP_CONNTRACK_MAX)\r\nreturn -EINVAL;\r\nspin_lock_bh(&ct->lock);\r\nif (tb[CTA_PROTOINFO_TCP_STATE])\r\nct->proto.tcp.state = nla_get_u8(tb[CTA_PROTOINFO_TCP_STATE]);\r\nif (tb[CTA_PROTOINFO_TCP_FLAGS_ORIGINAL]) {\r\nstruct nf_ct_tcp_flags *attr =\r\nnla_data(tb[CTA_PROTOINFO_TCP_FLAGS_ORIGINAL]);\r\nct->proto.tcp.seen[0].flags &= ~attr->mask;\r\nct->proto.tcp.seen[0].flags |= attr->flags & attr->mask;\r\n}\r\nif (tb[CTA_PROTOINFO_TCP_FLAGS_REPLY]) {\r\nstruct nf_ct_tcp_flags *attr =\r\nnla_data(tb[CTA_PROTOINFO_TCP_FLAGS_REPLY]);\r\nct->proto.tcp.seen[1].flags &= ~attr->mask;\r\nct->proto.tcp.seen[1].flags |= attr->flags & attr->mask;\r\n}\r\nif (tb[CTA_PROTOINFO_TCP_WSCALE_ORIGINAL] &&\r\ntb[CTA_PROTOINFO_TCP_WSCALE_REPLY] &&\r\nct->proto.tcp.seen[0].flags & IP_CT_TCP_FLAG_WINDOW_SCALE &&\r\nct->proto.tcp.seen[1].flags & IP_CT_TCP_FLAG_WINDOW_SCALE) {\r\nct->proto.tcp.seen[0].td_scale =\r\nnla_get_u8(tb[CTA_PROTOINFO_TCP_WSCALE_ORIGINAL]);\r\nct->proto.tcp.seen[1].td_scale =\r\nnla_get_u8(tb[CTA_PROTOINFO_TCP_WSCALE_REPLY]);\r\n}\r\nspin_unlock_bh(&ct->lock);\r\nreturn 0;\r\n}\r\nstatic int tcp_nlattr_size(void)\r\n{\r\nreturn nla_total_size(0)\r\n+ nla_policy_len(tcp_nla_policy, CTA_PROTOINFO_TCP_MAX + 1);\r\n}\r\nstatic int tcp_nlattr_tuple_size(void)\r\n{\r\nreturn nla_policy_len(nf_ct_port_nla_policy, CTA_PROTO_MAX + 1);\r\n}\r\nstatic int tcp_timeout_nlattr_to_obj(struct nlattr *tb[],\r\nstruct net *net, void *data)\r\n{\r\nunsigned int *timeouts = data;\r\nstruct nf_tcp_net *tn = tcp_pernet(net);\r\nint i;\r\nfor (i=0; i<TCP_CONNTRACK_TIMEOUT_MAX; i++)\r\ntimeouts[i] = tn->timeouts[i];\r\nif (tb[CTA_TIMEOUT_TCP_SYN_SENT]) {\r\ntimeouts[TCP_CONNTRACK_SYN_SENT] =\r\nntohl(nla_get_be32(tb[CTA_TIMEOUT_TCP_SYN_SENT]))*HZ;\r\n}\r\nif (tb[CTA_TIMEOUT_TCP_SYN_RECV]) {\r\ntimeouts[TCP_CONNTRACK_SYN_RECV] =\r\nntohl(nla_get_be32(tb[CTA_TIMEOUT_TCP_SYN_RECV]))*HZ;\r\n}\r\nif (tb[CTA_TIMEOUT_TCP_ESTABLISHED]) {\r\ntimeouts[TCP_CONNTRACK_ESTABLISHED] =\r\nntohl(nla_get_be32(tb[CTA_TIMEOUT_TCP_ESTABLISHED]))*HZ;\r\n}\r\nif (tb[CTA_TIMEOUT_TCP_FIN_WAIT]) {\r\ntimeouts[TCP_CONNTRACK_FIN_WAIT] =\r\nntohl(nla_get_be32(tb[CTA_TIMEOUT_TCP_FIN_WAIT]))*HZ;\r\n}\r\nif (tb[CTA_TIMEOUT_TCP_CLOSE_WAIT]) {\r\ntimeouts[TCP_CONNTRACK_CLOSE_WAIT] =\r\nntohl(nla_get_be32(tb[CTA_TIMEOUT_TCP_CLOSE_WAIT]))*HZ;\r\n}\r\nif (tb[CTA_TIMEOUT_TCP_LAST_ACK]) {\r\ntimeouts[TCP_CONNTRACK_LAST_ACK] =\r\nntohl(nla_get_be32(tb[CTA_TIMEOUT_TCP_LAST_ACK]))*HZ;\r\n}\r\nif (tb[CTA_TIMEOUT_TCP_TIME_WAIT]) {\r\ntimeouts[TCP_CONNTRACK_TIME_WAIT] =\r\nntohl(nla_get_be32(tb[CTA_TIMEOUT_TCP_TIME_WAIT]))*HZ;\r\n}\r\nif (tb[CTA_TIMEOUT_TCP_CLOSE]) {\r\ntimeouts[TCP_CONNTRACK_CLOSE] =\r\nntohl(nla_get_be32(tb[CTA_TIMEOUT_TCP_CLOSE]))*HZ;\r\n}\r\nif (tb[CTA_TIMEOUT_TCP_SYN_SENT2]) {\r\ntimeouts[TCP_CONNTRACK_SYN_SENT2] =\r\nntohl(nla_get_be32(tb[CTA_TIMEOUT_TCP_SYN_SENT2]))*HZ;\r\n}\r\nif (tb[CTA_TIMEOUT_TCP_RETRANS]) {\r\ntimeouts[TCP_CONNTRACK_RETRANS] =\r\nntohl(nla_get_be32(tb[CTA_TIMEOUT_TCP_RETRANS]))*HZ;\r\n}\r\nif (tb[CTA_TIMEOUT_TCP_UNACK]) {\r\ntimeouts[TCP_CONNTRACK_UNACK] =\r\nntohl(nla_get_be32(tb[CTA_TIMEOUT_TCP_UNACK]))*HZ;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\ntcp_timeout_obj_to_nlattr(struct sk_buff *skb, const void *data)\r\n{\r\nconst unsigned int *timeouts = data;\r\nif (nla_put_be32(skb, CTA_TIMEOUT_TCP_SYN_SENT,\r\nhtonl(timeouts[TCP_CONNTRACK_SYN_SENT] / HZ)) ||\r\nnla_put_be32(skb, CTA_TIMEOUT_TCP_SYN_RECV,\r\nhtonl(timeouts[TCP_CONNTRACK_SYN_RECV] / HZ)) ||\r\nnla_put_be32(skb, CTA_TIMEOUT_TCP_ESTABLISHED,\r\nhtonl(timeouts[TCP_CONNTRACK_ESTABLISHED] / HZ)) ||\r\nnla_put_be32(skb, CTA_TIMEOUT_TCP_FIN_WAIT,\r\nhtonl(timeouts[TCP_CONNTRACK_FIN_WAIT] / HZ)) ||\r\nnla_put_be32(skb, CTA_TIMEOUT_TCP_CLOSE_WAIT,\r\nhtonl(timeouts[TCP_CONNTRACK_CLOSE_WAIT] / HZ)) ||\r\nnla_put_be32(skb, CTA_TIMEOUT_TCP_LAST_ACK,\r\nhtonl(timeouts[TCP_CONNTRACK_LAST_ACK] / HZ)) ||\r\nnla_put_be32(skb, CTA_TIMEOUT_TCP_TIME_WAIT,\r\nhtonl(timeouts[TCP_CONNTRACK_TIME_WAIT] / HZ)) ||\r\nnla_put_be32(skb, CTA_TIMEOUT_TCP_CLOSE,\r\nhtonl(timeouts[TCP_CONNTRACK_CLOSE] / HZ)) ||\r\nnla_put_be32(skb, CTA_TIMEOUT_TCP_SYN_SENT2,\r\nhtonl(timeouts[TCP_CONNTRACK_SYN_SENT2] / HZ)) ||\r\nnla_put_be32(skb, CTA_TIMEOUT_TCP_RETRANS,\r\nhtonl(timeouts[TCP_CONNTRACK_RETRANS] / HZ)) ||\r\nnla_put_be32(skb, CTA_TIMEOUT_TCP_UNACK,\r\nhtonl(timeouts[TCP_CONNTRACK_UNACK] / HZ)))\r\ngoto nla_put_failure;\r\nreturn 0;\r\nnla_put_failure:\r\nreturn -ENOSPC;\r\n}\r\nstatic int tcp_kmemdup_sysctl_table(struct nf_proto_net *pn,\r\nstruct nf_tcp_net *tn)\r\n{\r\n#ifdef CONFIG_SYSCTL\r\nif (pn->ctl_table)\r\nreturn 0;\r\npn->ctl_table = kmemdup(tcp_sysctl_table,\r\nsizeof(tcp_sysctl_table),\r\nGFP_KERNEL);\r\nif (!pn->ctl_table)\r\nreturn -ENOMEM;\r\npn->ctl_table[0].data = &tn->timeouts[TCP_CONNTRACK_SYN_SENT];\r\npn->ctl_table[1].data = &tn->timeouts[TCP_CONNTRACK_SYN_RECV];\r\npn->ctl_table[2].data = &tn->timeouts[TCP_CONNTRACK_ESTABLISHED];\r\npn->ctl_table[3].data = &tn->timeouts[TCP_CONNTRACK_FIN_WAIT];\r\npn->ctl_table[4].data = &tn->timeouts[TCP_CONNTRACK_CLOSE_WAIT];\r\npn->ctl_table[5].data = &tn->timeouts[TCP_CONNTRACK_LAST_ACK];\r\npn->ctl_table[6].data = &tn->timeouts[TCP_CONNTRACK_TIME_WAIT];\r\npn->ctl_table[7].data = &tn->timeouts[TCP_CONNTRACK_CLOSE];\r\npn->ctl_table[8].data = &tn->timeouts[TCP_CONNTRACK_RETRANS];\r\npn->ctl_table[9].data = &tn->timeouts[TCP_CONNTRACK_UNACK];\r\npn->ctl_table[10].data = &tn->tcp_loose;\r\npn->ctl_table[11].data = &tn->tcp_be_liberal;\r\npn->ctl_table[12].data = &tn->tcp_max_retrans;\r\n#endif\r\nreturn 0;\r\n}\r\nstatic int tcp_kmemdup_compat_sysctl_table(struct nf_proto_net *pn,\r\nstruct nf_tcp_net *tn)\r\n{\r\n#ifdef CONFIG_SYSCTL\r\n#ifdef CONFIG_NF_CONNTRACK_PROC_COMPAT\r\npn->ctl_compat_table = kmemdup(tcp_compat_sysctl_table,\r\nsizeof(tcp_compat_sysctl_table),\r\nGFP_KERNEL);\r\nif (!pn->ctl_compat_table)\r\nreturn -ENOMEM;\r\npn->ctl_compat_table[0].data = &tn->timeouts[TCP_CONNTRACK_SYN_SENT];\r\npn->ctl_compat_table[1].data = &tn->timeouts[TCP_CONNTRACK_SYN_SENT2];\r\npn->ctl_compat_table[2].data = &tn->timeouts[TCP_CONNTRACK_SYN_RECV];\r\npn->ctl_compat_table[3].data = &tn->timeouts[TCP_CONNTRACK_ESTABLISHED];\r\npn->ctl_compat_table[4].data = &tn->timeouts[TCP_CONNTRACK_FIN_WAIT];\r\npn->ctl_compat_table[5].data = &tn->timeouts[TCP_CONNTRACK_CLOSE_WAIT];\r\npn->ctl_compat_table[6].data = &tn->timeouts[TCP_CONNTRACK_LAST_ACK];\r\npn->ctl_compat_table[7].data = &tn->timeouts[TCP_CONNTRACK_TIME_WAIT];\r\npn->ctl_compat_table[8].data = &tn->timeouts[TCP_CONNTRACK_CLOSE];\r\npn->ctl_compat_table[9].data = &tn->timeouts[TCP_CONNTRACK_RETRANS];\r\npn->ctl_compat_table[10].data = &tn->tcp_loose;\r\npn->ctl_compat_table[11].data = &tn->tcp_be_liberal;\r\npn->ctl_compat_table[12].data = &tn->tcp_max_retrans;\r\n#endif\r\n#endif\r\nreturn 0;\r\n}\r\nstatic int tcp_init_net(struct net *net, u_int16_t proto)\r\n{\r\nint ret;\r\nstruct nf_tcp_net *tn = tcp_pernet(net);\r\nstruct nf_proto_net *pn = &tn->pn;\r\nif (!pn->users) {\r\nint i;\r\nfor (i = 0; i < TCP_CONNTRACK_TIMEOUT_MAX; i++)\r\ntn->timeouts[i] = tcp_timeouts[i];\r\ntn->tcp_loose = nf_ct_tcp_loose;\r\ntn->tcp_be_liberal = nf_ct_tcp_be_liberal;\r\ntn->tcp_max_retrans = nf_ct_tcp_max_retrans;\r\n}\r\nif (proto == AF_INET) {\r\nret = tcp_kmemdup_compat_sysctl_table(pn, tn);\r\nif (ret < 0)\r\nreturn ret;\r\nret = tcp_kmemdup_sysctl_table(pn, tn);\r\nif (ret < 0)\r\nnf_ct_kfree_compat_sysctl_table(pn);\r\n} else\r\nret = tcp_kmemdup_sysctl_table(pn, tn);\r\nreturn ret;\r\n}\r\nstatic struct nf_proto_net *tcp_get_net_proto(struct net *net)\r\n{\r\nreturn &net->ct.nf_ct_proto.tcp.pn;\r\n}
