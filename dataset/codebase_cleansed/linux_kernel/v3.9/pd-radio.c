static int poseidon_check_mode_radio(struct poseidon *p)\r\n{\r\nint ret;\r\nu32 status;\r\nset_current_state(TASK_INTERRUPTIBLE);\r\nschedule_timeout(HZ/2);\r\nret = usb_set_interface(p->udev, 0, BULK_ALTERNATE_IFACE);\r\nif (ret < 0)\r\ngoto out;\r\nret = set_tuner_mode(p, TLG_MODE_FM_RADIO);\r\nif (ret != 0)\r\ngoto out;\r\nret = send_set_req(p, SGNL_SRC_SEL, TLG_SIG_SRC_ANTENNA, &status);\r\nret = send_set_req(p, TUNER_AUD_ANA_STD,\r\np->radio_data.pre_emphasis, &status);\r\nret |= send_set_req(p, TUNER_AUD_MODE,\r\nTLG_TUNE_TVAUDIO_MODE_STEREO, &status);\r\nret |= send_set_req(p, AUDIO_SAMPLE_RATE_SEL,\r\nATV_AUDIO_RATE_48K, &status);\r\nret |= send_set_req(p, TUNE_FREQ_SELECT, TUNER_FREQ_MIN_FM, &status);\r\nout:\r\nreturn ret;\r\n}\r\nstatic int pm_fm_suspend(struct poseidon *p)\r\n{\r\nlogpm(p);\r\npm_alsa_suspend(p);\r\nusb_set_interface(p->udev, 0, 0);\r\nmsleep(300);\r\nreturn 0;\r\n}\r\nstatic int pm_fm_resume(struct poseidon *p)\r\n{\r\nlogpm(p);\r\nposeidon_check_mode_radio(p);\r\nset_frequency(p, p->radio_data.fm_freq);\r\npm_alsa_resume(p);\r\nreturn 0;\r\n}\r\nstatic int poseidon_fm_open(struct file *filp)\r\n{\r\nstruct video_device *vfd = video_devdata(filp);\r\nstruct poseidon *p = video_get_drvdata(vfd);\r\nint ret = 0;\r\nif (!p)\r\nreturn -1;\r\nmutex_lock(&p->lock);\r\nif (p->state & POSEIDON_STATE_DISCONNECT) {\r\nret = -ENODEV;\r\ngoto out;\r\n}\r\nif (p->state && !(p->state & POSEIDON_STATE_FM)) {\r\nret = -EBUSY;\r\ngoto out;\r\n}\r\nusb_autopm_get_interface(p->interface);\r\nif (0 == p->state) {\r\nif (p->radio_data.pre_emphasis == 0)\r\np->radio_data.pre_emphasis = TLG_TUNE_ASTD_FM_EUR;\r\nset_debug_mode(vfd, debug_mode);\r\nret = poseidon_check_mode_radio(p);\r\nif (ret < 0) {\r\nusb_autopm_put_interface(p->interface);\r\ngoto out;\r\n}\r\np->state |= POSEIDON_STATE_FM;\r\n}\r\np->radio_data.users++;\r\nkref_get(&p->kref);\r\nfilp->private_data = p;\r\nout:\r\nmutex_unlock(&p->lock);\r\nreturn ret;\r\n}\r\nstatic int poseidon_fm_close(struct file *filp)\r\n{\r\nstruct poseidon *p = filp->private_data;\r\nstruct radio_data *fm = &p->radio_data;\r\nuint32_t status;\r\nmutex_lock(&p->lock);\r\nfm->users--;\r\nif (0 == fm->users)\r\np->state &= ~POSEIDON_STATE_FM;\r\nif (fm->is_radio_streaming && filp == p->file_for_stream) {\r\nfm->is_radio_streaming = 0;\r\nsend_set_req(p, PLAY_SERVICE, TLG_TUNE_PLAY_SVC_STOP, &status);\r\n}\r\nusb_autopm_put_interface(p->interface);\r\nmutex_unlock(&p->lock);\r\nkref_put(&p->kref, poseidon_delete);\r\nfilp->private_data = NULL;\r\nreturn 0;\r\n}\r\nstatic int vidioc_querycap(struct file *file, void *priv,\r\nstruct v4l2_capability *v)\r\n{\r\nstruct poseidon *p = file->private_data;\r\nstrlcpy(v->driver, "tele-radio", sizeof(v->driver));\r\nstrlcpy(v->card, "Telegent Poseidon", sizeof(v->card));\r\nusb_make_path(p->udev, v->bus_info, sizeof(v->bus_info));\r\nv->capabilities = V4L2_CAP_TUNER | V4L2_CAP_RADIO;\r\nreturn 0;\r\n}\r\nstatic int tlg_fm_vidioc_g_tuner(struct file *file, void *priv,\r\nstruct v4l2_tuner *vt)\r\n{\r\nstruct tuner_fm_sig_stat_s fm_stat = {};\r\nint ret, status, count = 5;\r\nstruct poseidon *p = file->private_data;\r\nif (vt->index != 0)\r\nreturn -EINVAL;\r\nvt->type = V4L2_TUNER_RADIO;\r\nvt->capability = V4L2_TUNER_CAP_STEREO;\r\nvt->rangelow = TUNER_FREQ_MIN_FM / 62500;\r\nvt->rangehigh = TUNER_FREQ_MAX_FM / 62500;\r\nvt->rxsubchans = V4L2_TUNER_SUB_STEREO;\r\nvt->audmode = V4L2_TUNER_MODE_STEREO;\r\nvt->signal = 0;\r\nvt->afc = 0;\r\nmutex_lock(&p->lock);\r\nret = send_get_req(p, TUNER_STATUS, TLG_MODE_FM_RADIO,\r\n&fm_stat, &status, sizeof(fm_stat));\r\nwhile (fm_stat.sig_lock_busy && count-- && !ret) {\r\nset_current_state(TASK_INTERRUPTIBLE);\r\nschedule_timeout(HZ);\r\nret = send_get_req(p, TUNER_STATUS, TLG_MODE_FM_RADIO,\r\n&fm_stat, &status, sizeof(fm_stat));\r\n}\r\nmutex_unlock(&p->lock);\r\nif (ret || status) {\r\nvt->signal = 0;\r\n} else if ((fm_stat.sig_present || fm_stat.sig_locked)\r\n&& fm_stat.sig_strength == 0) {\r\nvt->signal = 0xffff;\r\n} else\r\nvt->signal = (fm_stat.sig_strength * 255 / 10) << 8;\r\nreturn 0;\r\n}\r\nstatic int fm_get_freq(struct file *file, void *priv,\r\nstruct v4l2_frequency *argp)\r\n{\r\nstruct poseidon *p = file->private_data;\r\nargp->frequency = p->radio_data.fm_freq;\r\nreturn 0;\r\n}\r\nstatic int set_frequency(struct poseidon *p, __u32 frequency)\r\n{\r\n__u32 freq ;\r\nint ret, status;\r\nmutex_lock(&p->lock);\r\nret = send_set_req(p, TUNER_AUD_ANA_STD,\r\np->radio_data.pre_emphasis, &status);\r\nfreq = (frequency * 125) * 500 / 1000;\r\nif (freq < TUNER_FREQ_MIN_FM/1000 || freq > TUNER_FREQ_MAX_FM/1000) {\r\nret = -EINVAL;\r\ngoto error;\r\n}\r\nret = send_set_req(p, TUNE_FREQ_SELECT, freq, &status);\r\nif (ret < 0)\r\ngoto error ;\r\nret = send_set_req(p, TAKE_REQUEST, 0, &status);\r\nset_current_state(TASK_INTERRUPTIBLE);\r\nschedule_timeout(HZ/4);\r\nif (!p->radio_data.is_radio_streaming) {\r\nret = send_set_req(p, TAKE_REQUEST, 0, &status);\r\nret = send_set_req(p, PLAY_SERVICE,\r\nTLG_TUNE_PLAY_SVC_START, &status);\r\np->radio_data.is_radio_streaming = 1;\r\n}\r\np->radio_data.fm_freq = frequency;\r\nerror:\r\nmutex_unlock(&p->lock);\r\nreturn ret;\r\n}\r\nstatic int fm_set_freq(struct file *file, void *priv,\r\nstruct v4l2_frequency *argp)\r\n{\r\nstruct poseidon *p = file->private_data;\r\np->file_for_stream = file;\r\n#ifdef CONFIG_PM\r\np->pm_suspend = pm_fm_suspend;\r\np->pm_resume = pm_fm_resume;\r\n#endif\r\nreturn set_frequency(p, argp->frequency);\r\n}\r\nstatic int tlg_fm_vidioc_g_ctrl(struct file *file, void *priv,\r\nstruct v4l2_control *arg)\r\n{\r\nreturn 0;\r\n}\r\nstatic int tlg_fm_vidioc_g_exts_ctrl(struct file *file, void *fh,\r\nstruct v4l2_ext_controls *ctrls)\r\n{\r\nstruct poseidon *p = file->private_data;\r\nint i;\r\nif (ctrls->ctrl_class != V4L2_CTRL_CLASS_FM_TX)\r\nreturn -EINVAL;\r\nfor (i = 0; i < ctrls->count; i++) {\r\nstruct v4l2_ext_control *ctrl = ctrls->controls + i;\r\nif (ctrl->id != V4L2_CID_TUNE_PREEMPHASIS)\r\ncontinue;\r\nif (i < MAX_PREEMPHASIS)\r\nctrl->value = p->radio_data.pre_emphasis;\r\n}\r\nreturn 0;\r\n}\r\nstatic int tlg_fm_vidioc_s_exts_ctrl(struct file *file, void *fh,\r\nstruct v4l2_ext_controls *ctrls)\r\n{\r\nint i;\r\nif (ctrls->ctrl_class != V4L2_CTRL_CLASS_FM_TX)\r\nreturn -EINVAL;\r\nfor (i = 0; i < ctrls->count; i++) {\r\nstruct v4l2_ext_control *ctrl = ctrls->controls + i;\r\nif (ctrl->id != V4L2_CID_TUNE_PREEMPHASIS)\r\ncontinue;\r\nif (ctrl->value >= 0 && ctrl->value < MAX_PREEMPHASIS) {\r\nstruct poseidon *p = file->private_data;\r\nint pre_emphasis = preemphasis[ctrl->value];\r\nu32 status;\r\nsend_set_req(p, TUNER_AUD_ANA_STD,\r\npre_emphasis, &status);\r\np->radio_data.pre_emphasis = pre_emphasis;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int tlg_fm_vidioc_s_ctrl(struct file *file, void *priv,\r\nstruct v4l2_control *ctrl)\r\n{\r\nreturn 0;\r\n}\r\nstatic int tlg_fm_vidioc_queryctrl(struct file *file, void *priv,\r\nstruct v4l2_queryctrl *ctrl)\r\n{\r\nif (!(ctrl->id & V4L2_CTRL_FLAG_NEXT_CTRL))\r\nreturn -EINVAL;\r\nctrl->id &= ~V4L2_CTRL_FLAG_NEXT_CTRL;\r\nif (ctrl->id != V4L2_CID_TUNE_PREEMPHASIS) {\r\nctrl->id = V4L2_CID_TUNE_PREEMPHASIS;\r\nv4l2_ctrl_query_fill(ctrl, V4L2_PREEMPHASIS_DISABLED,\r\nV4L2_PREEMPHASIS_75_uS, 1,\r\nV4L2_PREEMPHASIS_50_uS);\r\nctrl->flags = V4L2_CTRL_FLAG_UPDATE;\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int tlg_fm_vidioc_querymenu(struct file *file, void *fh,\r\nstruct v4l2_querymenu *qmenu)\r\n{\r\nreturn v4l2_ctrl_query_menu(qmenu, NULL, NULL);\r\n}\r\nstatic int vidioc_s_tuner(struct file *file, void *priv, struct v4l2_tuner *vt)\r\n{\r\nreturn vt->index > 0 ? -EINVAL : 0;\r\n}\r\nstatic int vidioc_s_audio(struct file *file, void *priv, const struct v4l2_audio *va)\r\n{\r\nreturn (va->index != 0) ? -EINVAL : 0;\r\n}\r\nstatic int vidioc_g_audio(struct file *file, void *priv, struct v4l2_audio *a)\r\n{\r\na->index = 0;\r\na->mode = 0;\r\na->capability = V4L2_AUDCAP_STEREO;\r\nstrcpy(a->name, "Radio");\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_input(struct file *filp, void *priv, u32 i)\r\n{\r\nreturn (i != 0) ? -EINVAL : 0;\r\n}\r\nstatic int vidioc_g_input(struct file *filp, void *priv, u32 *i)\r\n{\r\nreturn (*i != 0) ? -EINVAL : 0;\r\n}\r\nint poseidon_fm_init(struct poseidon *p)\r\n{\r\nstruct video_device *fm_dev;\r\nfm_dev = vdev_init(p, &poseidon_fm_template);\r\nif (fm_dev == NULL)\r\nreturn -1;\r\nif (video_register_device(fm_dev, VFL_TYPE_RADIO, -1) < 0) {\r\nvideo_device_release(fm_dev);\r\nreturn -1;\r\n}\r\np->radio_data.fm_dev = fm_dev;\r\nreturn 0;\r\n}\r\nint poseidon_fm_exit(struct poseidon *p)\r\n{\r\ndestroy_video_device(&p->radio_data.fm_dev);\r\nreturn 0;\r\n}
