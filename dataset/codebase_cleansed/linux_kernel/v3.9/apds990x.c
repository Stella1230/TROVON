static int apds990x_read_byte(struct apds990x_chip *chip, u8 reg, u8 *data)\r\n{\r\nstruct i2c_client *client = chip->client;\r\ns32 ret;\r\nreg &= ~APDS990x_CMD_TYPE_MASK;\r\nreg |= APDS990x_CMD | APDS990x_CMD_TYPE_RB;\r\nret = i2c_smbus_read_byte_data(client, reg);\r\n*data = ret;\r\nreturn (int)ret;\r\n}\r\nstatic int apds990x_read_word(struct apds990x_chip *chip, u8 reg, u16 *data)\r\n{\r\nstruct i2c_client *client = chip->client;\r\ns32 ret;\r\nreg &= ~APDS990x_CMD_TYPE_MASK;\r\nreg |= APDS990x_CMD | APDS990x_CMD_TYPE_INC;\r\nret = i2c_smbus_read_word_data(client, reg);\r\n*data = ret;\r\nreturn (int)ret;\r\n}\r\nstatic int apds990x_write_byte(struct apds990x_chip *chip, u8 reg, u8 data)\r\n{\r\nstruct i2c_client *client = chip->client;\r\ns32 ret;\r\nreg &= ~APDS990x_CMD_TYPE_MASK;\r\nreg |= APDS990x_CMD | APDS990x_CMD_TYPE_RB;\r\nret = i2c_smbus_write_byte_data(client, reg, data);\r\nreturn (int)ret;\r\n}\r\nstatic int apds990x_write_word(struct apds990x_chip *chip, u8 reg, u16 data)\r\n{\r\nstruct i2c_client *client = chip->client;\r\ns32 ret;\r\nreg &= ~APDS990x_CMD_TYPE_MASK;\r\nreg |= APDS990x_CMD | APDS990x_CMD_TYPE_INC;\r\nret = i2c_smbus_write_word_data(client, reg, data);\r\nreturn (int)ret;\r\n}\r\nstatic int apds990x_mode_on(struct apds990x_chip *chip)\r\n{\r\nu8 reg = APDS990X_EN_AIEN | APDS990X_EN_PON | APDS990X_EN_AEN |\r\nAPDS990X_EN_WEN;\r\nif (chip->prox_en)\r\nreg |= APDS990X_EN_PIEN | APDS990X_EN_PEN;\r\nreturn apds990x_write_byte(chip, APDS990X_ENABLE, reg);\r\n}\r\nstatic u16 apds990x_lux_to_threshold(struct apds990x_chip *chip, u32 lux)\r\n{\r\nu32 thres;\r\nu32 cpl;\r\nu32 ir;\r\nif (lux == 0)\r\nreturn 0;\r\nelse if (lux == APDS_RANGE)\r\nreturn APDS_RANGE;\r\nlux = lux * (APDS_CALIB_SCALER / 4) / (chip->lux_calib / 4);\r\ncpl = ((u32)chip->atime * (u32)again[chip->again_next] *\r\nAPDS_PARAM_SCALE * 64) / (chip->cf.ga * chip->cf.df);\r\nthres = lux * cpl / 64;\r\nir = (u32)chip->lux_ir * (u32)again[chip->again_next] /\r\n(u32)again[chip->again_meas];\r\nif (chip->lux_clear * APDS_PARAM_SCALE >=\r\nchip->rcf.afactor * chip->lux_ir)\r\nthres = (chip->rcf.cf1 * thres + chip->rcf.irf1 * ir) /\r\nAPDS_PARAM_SCALE;\r\nelse\r\nthres = (chip->rcf.cf2 * thres + chip->rcf.irf2 * ir) /\r\nAPDS_PARAM_SCALE;\r\nif (thres >= chip->a_max_result)\r\nthres = chip->a_max_result - 1;\r\nreturn thres;\r\n}\r\nstatic inline int apds990x_set_atime(struct apds990x_chip *chip, u32 time_ms)\r\n{\r\nu8 reg_value;\r\nchip->atime = time_ms;\r\nreg_value = 256 - ((time_ms * TIME_STEP_SCALER) / TIMESTEP);\r\nchip->a_max_result = (u16)(256 - reg_value) * APDS990X_TIME_TO_ADC;\r\nreturn apds990x_write_byte(chip, APDS990X_ATIME, reg_value);\r\n}\r\nstatic int apds990x_refresh_pthres(struct apds990x_chip *chip, int data)\r\n{\r\nint ret, lo, hi;\r\nif (pm_runtime_suspended(&chip->client->dev))\r\nreturn 0;\r\nif (data < chip->prox_thres) {\r\nlo = 0;\r\nhi = chip->prox_thres;\r\n} else {\r\nlo = chip->prox_thres - APDS_PROX_HYSTERESIS;\r\nif (chip->prox_continuous_mode)\r\nhi = chip->prox_thres;\r\nelse\r\nhi = APDS_RANGE;\r\n}\r\nret = apds990x_write_word(chip, APDS990X_PILTL, lo);\r\nret |= apds990x_write_word(chip, APDS990X_PIHTL, hi);\r\nreturn ret;\r\n}\r\nstatic int apds990x_refresh_athres(struct apds990x_chip *chip)\r\n{\r\nint ret;\r\nif (pm_runtime_suspended(&chip->client->dev))\r\nreturn 0;\r\nret = apds990x_write_word(chip, APDS990X_AILTL,\r\napds990x_lux_to_threshold(chip, chip->lux_thres_lo));\r\nret |= apds990x_write_word(chip, APDS990X_AIHTL,\r\napds990x_lux_to_threshold(chip, chip->lux_thres_hi));\r\nreturn ret;\r\n}\r\nstatic void apds990x_force_a_refresh(struct apds990x_chip *chip)\r\n{\r\napds990x_write_word(chip, APDS990X_AILTL, APDS_LUX_DEF_THRES_LO);\r\napds990x_write_word(chip, APDS990X_AIHTL, APDS_LUX_DEF_THRES_HI);\r\n}\r\nstatic void apds990x_force_p_refresh(struct apds990x_chip *chip)\r\n{\r\napds990x_write_word(chip, APDS990X_PILTL, APDS_PROX_DEF_THRES - 1);\r\napds990x_write_word(chip, APDS990X_PIHTL, APDS_PROX_DEF_THRES);\r\n}\r\nstatic int apds990x_calc_again(struct apds990x_chip *chip)\r\n{\r\nint curr_again = chip->again_meas;\r\nint next_again = chip->again_meas;\r\nint ret = 0;\r\nif (chip->lux_clear == chip->a_max_result)\r\nnext_again -= 2;\r\nelse if (chip->lux_clear > chip->a_max_result / 2)\r\nnext_again--;\r\nelse if (chip->lux_clear < APDS_LUX_GAIN_LO_LIMIT_STRICT)\r\nnext_again += 2;\r\nelse if (chip->lux_clear < APDS_LUX_GAIN_LO_LIMIT)\r\nnext_again++;\r\nif (next_again < 0)\r\nnext_again = 0;\r\nelse if (next_again > APDS990X_MAX_AGAIN)\r\nnext_again = APDS990X_MAX_AGAIN;\r\nif (chip->lux_clear == chip->a_max_result)\r\nret = -ERANGE;\r\nelse if (next_again != curr_again &&\r\nchip->lux_clear < APDS_LUX_GAIN_LO_LIMIT_STRICT)\r\nret = -ERANGE;\r\nchip->again_next = next_again;\r\napds990x_write_byte(chip, APDS990X_CONTROL,\r\n(chip->pdrive << 6) |\r\n(chip->pdiode << 4) |\r\n(chip->pgain << 2) |\r\n(chip->again_next << 0));\r\nif (ret < 0)\r\napds990x_force_a_refresh(chip);\r\nelse\r\napds990x_refresh_athres(chip);\r\nreturn ret;\r\n}\r\nstatic int apds990x_get_lux(struct apds990x_chip *chip, int clear, int ir)\r\n{\r\nint iac, iac1, iac2;\r\nu32 lpc;\r\niac1 = (chip->cf.cf1 * clear - chip->cf.irf1 * ir) / APDS_PARAM_SCALE;\r\niac2 = (chip->cf.cf2 * clear - chip->cf.irf2 * ir) / APDS_PARAM_SCALE;\r\niac = max(iac1, iac2);\r\niac = max(iac, 0);\r\nlpc = APDS990X_LUX_OUTPUT_SCALE * (chip->cf.df * chip->cf.ga) /\r\n(u32)(again[chip->again_meas] * (u32)chip->atime);\r\nreturn (iac * lpc) / APDS_PARAM_SCALE;\r\n}\r\nstatic int apds990x_ack_int(struct apds990x_chip *chip, u8 mode)\r\n{\r\nstruct i2c_client *client = chip->client;\r\ns32 ret;\r\nu8 reg = APDS990x_CMD | APDS990x_CMD_TYPE_SPE;\r\nswitch (mode & (APDS990X_ST_AINT | APDS990X_ST_PINT)) {\r\ncase APDS990X_ST_AINT:\r\nreg |= APDS990X_INT_ACK_ALS;\r\nbreak;\r\ncase APDS990X_ST_PINT:\r\nreg |= APDS990X_INT_ACK_PS;\r\nbreak;\r\ndefault:\r\nreg |= APDS990X_INT_ACK_BOTH;\r\nbreak;\r\n}\r\nret = i2c_smbus_read_byte_data(client, reg);\r\nreturn (int)ret;\r\n}\r\nstatic irqreturn_t apds990x_irq(int irq, void *data)\r\n{\r\nstruct apds990x_chip *chip = data;\r\nu8 status;\r\napds990x_read_byte(chip, APDS990X_STATUS, &status);\r\napds990x_ack_int(chip, status);\r\nmutex_lock(&chip->mutex);\r\nif (!pm_runtime_suspended(&chip->client->dev)) {\r\nif (status & APDS990X_ST_AINT) {\r\napds990x_read_word(chip, APDS990X_CDATAL,\r\n&chip->lux_clear);\r\napds990x_read_word(chip, APDS990X_IRDATAL,\r\n&chip->lux_ir);\r\nchip->again_meas = chip->again_next;\r\nchip->lux_raw = apds990x_get_lux(chip,\r\nchip->lux_clear,\r\nchip->lux_ir);\r\nif (apds990x_calc_again(chip) == 0) {\r\nchip->lux = chip->lux_raw;\r\nchip->lux_wait_fresh_res = false;\r\nwake_up(&chip->wait);\r\nsysfs_notify(&chip->client->dev.kobj,\r\nNULL, "lux0_input");\r\n}\r\n}\r\nif ((status & APDS990X_ST_PINT) && chip->prox_en) {\r\nu16 clr_ch;\r\napds990x_read_word(chip, APDS990X_CDATAL, &clr_ch);\r\nif (chip->again_meas == 0 &&\r\nclr_ch == chip->a_max_result)\r\nchip->prox_data = 0;\r\nelse\r\napds990x_read_word(chip,\r\nAPDS990X_PDATAL,\r\n&chip->prox_data);\r\napds990x_refresh_pthres(chip, chip->prox_data);\r\nif (chip->prox_data < chip->prox_thres)\r\nchip->prox_data = 0;\r\nelse if (!chip->prox_continuous_mode)\r\nchip->prox_data = APDS_PROX_RANGE;\r\nsysfs_notify(&chip->client->dev.kobj,\r\nNULL, "prox0_raw");\r\n}\r\n}\r\nmutex_unlock(&chip->mutex);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int apds990x_configure(struct apds990x_chip *chip)\r\n{\r\napds990x_write_byte(chip, APDS990X_ENABLE, APDS990X_EN_DISABLE_ALL);\r\napds990x_write_byte(chip, APDS990X_PTIME, APDS990X_PTIME_DEFAULT);\r\napds990x_write_byte(chip, APDS990X_WTIME, APDS990X_WTIME_DEFAULT);\r\napds990x_set_atime(chip, APDS_LUX_AVERAGING_TIME);\r\napds990x_write_byte(chip, APDS990X_CONFIG, 0);\r\napds990x_write_byte(chip, APDS990X_PERS,\r\n(chip->lux_persistence << APDS990X_APERS_SHIFT) |\r\n(chip->prox_persistence << APDS990X_PPERS_SHIFT));\r\napds990x_write_byte(chip, APDS990X_PPCOUNT, chip->pdata->ppcount);\r\nchip->again_meas = 1;\r\nchip->again_next = 1;\r\napds990x_write_byte(chip, APDS990X_CONTROL,\r\n(chip->pdrive << 6) |\r\n(chip->pdiode << 4) |\r\n(chip->pgain << 2) |\r\n(chip->again_next << 0));\r\nreturn 0;\r\n}\r\nstatic int apds990x_detect(struct apds990x_chip *chip)\r\n{\r\nstruct i2c_client *client = chip->client;\r\nint ret;\r\nu8 id;\r\nret = apds990x_read_byte(chip, APDS990X_ID, &id);\r\nif (ret < 0) {\r\ndev_err(&client->dev, "ID read failed\n");\r\nreturn ret;\r\n}\r\nret = apds990x_read_byte(chip, APDS990X_REV, &chip->revision);\r\nif (ret < 0) {\r\ndev_err(&client->dev, "REV read failed\n");\r\nreturn ret;\r\n}\r\nswitch (id) {\r\ncase APDS990X_ID_0:\r\ncase APDS990X_ID_4:\r\ncase APDS990X_ID_29:\r\nsnprintf(chip->chipname, sizeof(chip->chipname), "APDS-990x");\r\nbreak;\r\ndefault:\r\nret = -ENODEV;\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int apds990x_chip_on(struct apds990x_chip *chip)\r\n{\r\nint err = regulator_bulk_enable(ARRAY_SIZE(chip->regs),\r\nchip->regs);\r\nif (err < 0)\r\nreturn err;\r\nusleep_range(APDS_STARTUP_DELAY, 2 * APDS_STARTUP_DELAY);\r\nchip->prox_data = 0;\r\napds990x_configure(chip);\r\napds990x_mode_on(chip);\r\nreturn 0;\r\n}\r\nstatic int apds990x_chip_off(struct apds990x_chip *chip)\r\n{\r\napds990x_write_byte(chip, APDS990X_ENABLE, APDS990X_EN_DISABLE_ALL);\r\nregulator_bulk_disable(ARRAY_SIZE(chip->regs), chip->regs);\r\nreturn 0;\r\n}\r\nstatic ssize_t apds990x_lux_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct apds990x_chip *chip = dev_get_drvdata(dev);\r\nssize_t ret;\r\nu32 result;\r\nlong timeout;\r\nif (pm_runtime_suspended(dev))\r\nreturn -EIO;\r\ntimeout = wait_event_interruptible_timeout(chip->wait,\r\n!chip->lux_wait_fresh_res,\r\nmsecs_to_jiffies(APDS_TIMEOUT));\r\nif (!timeout)\r\nreturn -EIO;\r\nmutex_lock(&chip->mutex);\r\nresult = (chip->lux * chip->lux_calib) / APDS_CALIB_SCALER;\r\nif (result > (APDS_RANGE * APDS990X_LUX_OUTPUT_SCALE))\r\nresult = APDS_RANGE * APDS990X_LUX_OUTPUT_SCALE;\r\nret = sprintf(buf, "%d.%d\n",\r\nresult / APDS990X_LUX_OUTPUT_SCALE,\r\nresult % APDS990X_LUX_OUTPUT_SCALE);\r\nmutex_unlock(&chip->mutex);\r\nreturn ret;\r\n}\r\nstatic ssize_t apds990x_lux_range_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nreturn sprintf(buf, "%u\n", APDS_RANGE);\r\n}\r\nstatic ssize_t apds990x_lux_calib_format_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nreturn sprintf(buf, "%u\n", APDS_CALIB_SCALER);\r\n}\r\nstatic ssize_t apds990x_lux_calib_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct apds990x_chip *chip = dev_get_drvdata(dev);\r\nreturn sprintf(buf, "%u\n", chip->lux_calib);\r\n}\r\nstatic ssize_t apds990x_lux_calib_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t len)\r\n{\r\nstruct apds990x_chip *chip = dev_get_drvdata(dev);\r\nunsigned long value;\r\nif (strict_strtoul(buf, 0, &value))\r\nreturn -EINVAL;\r\nif (chip->lux_calib > APDS_RANGE)\r\nreturn -EINVAL;\r\nchip->lux_calib = value;\r\nreturn len;\r\n}\r\nstatic ssize_t apds990x_rate_avail(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nint i;\r\nint pos = 0;\r\nfor (i = 0; i < ARRAY_SIZE(arates_hz); i++)\r\npos += sprintf(buf + pos, "%d ", arates_hz[i]);\r\nsprintf(buf + pos - 1, "\n");\r\nreturn pos;\r\n}\r\nstatic ssize_t apds990x_rate_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct apds990x_chip *chip = dev_get_drvdata(dev);\r\nreturn sprintf(buf, "%d\n", chip->arate);\r\n}\r\nstatic int apds990x_set_arate(struct apds990x_chip *chip, int rate)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(arates_hz); i++)\r\nif (rate >= arates_hz[i])\r\nbreak;\r\nif (i == ARRAY_SIZE(arates_hz))\r\nreturn -EINVAL;\r\nchip->lux_persistence = apersis[i];\r\nchip->arate = arates_hz[i];\r\nif (pm_runtime_suspended(&chip->client->dev))\r\nreturn 0;\r\nreturn apds990x_write_byte(chip, APDS990X_PERS,\r\n(chip->lux_persistence << APDS990X_APERS_SHIFT) |\r\n(chip->prox_persistence << APDS990X_PPERS_SHIFT));\r\n}\r\nstatic ssize_t apds990x_rate_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t len)\r\n{\r\nstruct apds990x_chip *chip = dev_get_drvdata(dev);\r\nunsigned long value;\r\nint ret;\r\nif (strict_strtoul(buf, 0, &value))\r\nreturn -EINVAL;\r\nmutex_lock(&chip->mutex);\r\nret = apds990x_set_arate(chip, value);\r\nmutex_unlock(&chip->mutex);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn len;\r\n}\r\nstatic ssize_t apds990x_prox_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nssize_t ret;\r\nstruct apds990x_chip *chip = dev_get_drvdata(dev);\r\nif (pm_runtime_suspended(dev) || !chip->prox_en)\r\nreturn -EIO;\r\nmutex_lock(&chip->mutex);\r\nret = sprintf(buf, "%d\n", chip->prox_data);\r\nmutex_unlock(&chip->mutex);\r\nreturn ret;\r\n}\r\nstatic ssize_t apds990x_prox_range_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nreturn sprintf(buf, "%u\n", APDS_PROX_RANGE);\r\n}\r\nstatic ssize_t apds990x_prox_enable_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct apds990x_chip *chip = dev_get_drvdata(dev);\r\nreturn sprintf(buf, "%d\n", chip->prox_en);\r\n}\r\nstatic ssize_t apds990x_prox_enable_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t len)\r\n{\r\nstruct apds990x_chip *chip = dev_get_drvdata(dev);\r\nunsigned long value;\r\nif (strict_strtoul(buf, 0, &value))\r\nreturn -EINVAL;\r\nmutex_lock(&chip->mutex);\r\nif (!chip->prox_en)\r\nchip->prox_data = 0;\r\nif (value)\r\nchip->prox_en++;\r\nelse if (chip->prox_en > 0)\r\nchip->prox_en--;\r\nif (!pm_runtime_suspended(dev))\r\napds990x_mode_on(chip);\r\nmutex_unlock(&chip->mutex);\r\nreturn len;\r\n}\r\nstatic ssize_t apds990x_prox_reporting_mode_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct apds990x_chip *chip = dev_get_drvdata(dev);\r\nreturn sprintf(buf, "%s\n",\r\nreporting_modes[!!chip->prox_continuous_mode]);\r\n}\r\nstatic ssize_t apds990x_prox_reporting_mode_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t len)\r\n{\r\nstruct apds990x_chip *chip = dev_get_drvdata(dev);\r\nif (sysfs_streq(buf, reporting_modes[0]))\r\nchip->prox_continuous_mode = 0;\r\nelse if (sysfs_streq(buf, reporting_modes[1]))\r\nchip->prox_continuous_mode = 1;\r\nelse\r\nreturn -EINVAL;\r\nreturn len;\r\n}\r\nstatic ssize_t apds990x_prox_reporting_avail_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nreturn sprintf(buf, "%s %s\n", reporting_modes[0], reporting_modes[1]);\r\n}\r\nstatic ssize_t apds990x_lux_thresh_above_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct apds990x_chip *chip = dev_get_drvdata(dev);\r\nreturn sprintf(buf, "%d\n", chip->lux_thres_hi);\r\n}\r\nstatic ssize_t apds990x_lux_thresh_below_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct apds990x_chip *chip = dev_get_drvdata(dev);\r\nreturn sprintf(buf, "%d\n", chip->lux_thres_lo);\r\n}\r\nstatic ssize_t apds990x_set_lux_thresh(struct apds990x_chip *chip, u32 *target,\r\nconst char *buf)\r\n{\r\nint ret = 0;\r\nunsigned long thresh;\r\nif (strict_strtoul(buf, 0, &thresh))\r\nreturn -EINVAL;\r\nif (thresh > APDS_RANGE)\r\nreturn -EINVAL;\r\nmutex_lock(&chip->mutex);\r\n*target = thresh;\r\nif (!chip->lux_wait_fresh_res)\r\napds990x_refresh_athres(chip);\r\nmutex_unlock(&chip->mutex);\r\nreturn ret;\r\n}\r\nstatic ssize_t apds990x_lux_thresh_above_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t len)\r\n{\r\nstruct apds990x_chip *chip = dev_get_drvdata(dev);\r\nint ret = apds990x_set_lux_thresh(chip, &chip->lux_thres_hi, buf);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn len;\r\n}\r\nstatic ssize_t apds990x_lux_thresh_below_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t len)\r\n{\r\nstruct apds990x_chip *chip = dev_get_drvdata(dev);\r\nint ret = apds990x_set_lux_thresh(chip, &chip->lux_thres_lo, buf);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn len;\r\n}\r\nstatic ssize_t apds990x_prox_threshold_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct apds990x_chip *chip = dev_get_drvdata(dev);\r\nreturn sprintf(buf, "%d\n", chip->prox_thres);\r\n}\r\nstatic ssize_t apds990x_prox_threshold_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t len)\r\n{\r\nstruct apds990x_chip *chip = dev_get_drvdata(dev);\r\nunsigned long value;\r\nif (strict_strtoul(buf, 0, &value))\r\nreturn -EINVAL;\r\nif ((value > APDS_RANGE) || (value == 0) ||\r\n(value < APDS_PROX_HYSTERESIS))\r\nreturn -EINVAL;\r\nmutex_lock(&chip->mutex);\r\nchip->prox_thres = value;\r\napds990x_force_p_refresh(chip);\r\nmutex_unlock(&chip->mutex);\r\nreturn len;\r\n}\r\nstatic ssize_t apds990x_power_state_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nreturn sprintf(buf, "%d\n", !pm_runtime_suspended(dev));\r\nreturn 0;\r\n}\r\nstatic ssize_t apds990x_power_state_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t len)\r\n{\r\nstruct apds990x_chip *chip = dev_get_drvdata(dev);\r\nunsigned long value;\r\nif (strict_strtoul(buf, 0, &value))\r\nreturn -EINVAL;\r\nif (value) {\r\npm_runtime_get_sync(dev);\r\nmutex_lock(&chip->mutex);\r\nchip->lux_wait_fresh_res = true;\r\napds990x_force_a_refresh(chip);\r\napds990x_force_p_refresh(chip);\r\nmutex_unlock(&chip->mutex);\r\n} else {\r\nif (!pm_runtime_suspended(dev))\r\npm_runtime_put(dev);\r\n}\r\nreturn len;\r\n}\r\nstatic ssize_t apds990x_chip_id_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct apds990x_chip *chip = dev_get_drvdata(dev);\r\nreturn sprintf(buf, "%s %d\n", chip->chipname, chip->revision);\r\n}\r\nstatic int apds990x_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct apds990x_chip *chip;\r\nint err;\r\nchip = kzalloc(sizeof *chip, GFP_KERNEL);\r\nif (!chip)\r\nreturn -ENOMEM;\r\ni2c_set_clientdata(client, chip);\r\nchip->client = client;\r\ninit_waitqueue_head(&chip->wait);\r\nmutex_init(&chip->mutex);\r\nchip->pdata = client->dev.platform_data;\r\nif (chip->pdata == NULL) {\r\ndev_err(&client->dev, "platform data is mandatory\n");\r\nerr = -EINVAL;\r\ngoto fail1;\r\n}\r\nif (chip->pdata->cf.ga == 0) {\r\nchip->cf.ga = 1966;\r\nchip->cf.cf1 = 4096;\r\nchip->cf.irf1 = 9134;\r\nchip->cf.cf2 = 2867;\r\nchip->cf.irf2 = 5816;\r\nchip->cf.df = 52;\r\n} else {\r\nchip->cf = chip->pdata->cf;\r\n}\r\nchip->rcf.afactor =\r\n(chip->cf.irf1 - chip->cf.irf2) * APDS_PARAM_SCALE /\r\n(chip->cf.cf1 - chip->cf.cf2);\r\nchip->rcf.cf1 = APDS_PARAM_SCALE * APDS_PARAM_SCALE /\r\nchip->cf.cf1;\r\nchip->rcf.irf1 = chip->cf.irf1 * APDS_PARAM_SCALE /\r\nchip->cf.cf1;\r\nchip->rcf.cf2 = APDS_PARAM_SCALE * APDS_PARAM_SCALE /\r\nchip->cf.cf2;\r\nchip->rcf.irf2 = chip->cf.irf2 * APDS_PARAM_SCALE /\r\nchip->cf.cf2;\r\nchip->lux_thres_hi = APDS_LUX_DEF_THRES_HI;\r\nchip->lux_thres_lo = APDS_LUX_DEF_THRES_LO;\r\nchip->lux_calib = APDS_LUX_NEUTRAL_CALIB_VALUE;\r\nchip->prox_thres = APDS_PROX_DEF_THRES;\r\nchip->pdrive = chip->pdata->pdrive;\r\nchip->pdiode = APDS_PDIODE_IR;\r\nchip->pgain = APDS_PGAIN_1X;\r\nchip->prox_calib = APDS_PROX_NEUTRAL_CALIB_VALUE;\r\nchip->prox_persistence = APDS_DEFAULT_PROX_PERS;\r\nchip->prox_continuous_mode = false;\r\nchip->regs[0].supply = reg_vcc;\r\nchip->regs[1].supply = reg_vled;\r\nerr = regulator_bulk_get(&client->dev,\r\nARRAY_SIZE(chip->regs), chip->regs);\r\nif (err < 0) {\r\ndev_err(&client->dev, "Cannot get regulators\n");\r\ngoto fail1;\r\n}\r\nerr = regulator_bulk_enable(ARRAY_SIZE(chip->regs), chip->regs);\r\nif (err < 0) {\r\ndev_err(&client->dev, "Cannot enable regulators\n");\r\ngoto fail2;\r\n}\r\nusleep_range(APDS_STARTUP_DELAY, 2 * APDS_STARTUP_DELAY);\r\nerr = apds990x_detect(chip);\r\nif (err < 0) {\r\ndev_err(&client->dev, "APDS990X not found\n");\r\ngoto fail3;\r\n}\r\npm_runtime_set_active(&client->dev);\r\napds990x_configure(chip);\r\napds990x_set_arate(chip, APDS_LUX_DEFAULT_RATE);\r\napds990x_mode_on(chip);\r\npm_runtime_enable(&client->dev);\r\nif (chip->pdata->setup_resources) {\r\nerr = chip->pdata->setup_resources();\r\nif (err) {\r\nerr = -EINVAL;\r\ngoto fail3;\r\n}\r\n}\r\nerr = sysfs_create_group(&chip->client->dev.kobj,\r\napds990x_attribute_group);\r\nif (err < 0) {\r\ndev_err(&chip->client->dev, "Sysfs registration failed\n");\r\ngoto fail4;\r\n}\r\nerr = request_threaded_irq(client->irq, NULL,\r\napds990x_irq,\r\nIRQF_TRIGGER_FALLING | IRQF_TRIGGER_LOW |\r\nIRQF_ONESHOT,\r\n"apds990x", chip);\r\nif (err) {\r\ndev_err(&client->dev, "could not get IRQ %d\n",\r\nclient->irq);\r\ngoto fail5;\r\n}\r\nreturn err;\r\nfail5:\r\nsysfs_remove_group(&chip->client->dev.kobj,\r\n&apds990x_attribute_group[0]);\r\nfail4:\r\nif (chip->pdata && chip->pdata->release_resources)\r\nchip->pdata->release_resources();\r\nfail3:\r\nregulator_bulk_disable(ARRAY_SIZE(chip->regs), chip->regs);\r\nfail2:\r\nregulator_bulk_free(ARRAY_SIZE(chip->regs), chip->regs);\r\nfail1:\r\nkfree(chip);\r\nreturn err;\r\n}\r\nstatic int apds990x_remove(struct i2c_client *client)\r\n{\r\nstruct apds990x_chip *chip = i2c_get_clientdata(client);\r\nfree_irq(client->irq, chip);\r\nsysfs_remove_group(&chip->client->dev.kobj,\r\napds990x_attribute_group);\r\nif (chip->pdata && chip->pdata->release_resources)\r\nchip->pdata->release_resources();\r\nif (!pm_runtime_suspended(&client->dev))\r\napds990x_chip_off(chip);\r\npm_runtime_disable(&client->dev);\r\npm_runtime_set_suspended(&client->dev);\r\nregulator_bulk_free(ARRAY_SIZE(chip->regs), chip->regs);\r\nkfree(chip);\r\nreturn 0;\r\n}\r\nstatic int apds990x_suspend(struct device *dev)\r\n{\r\nstruct i2c_client *client = container_of(dev, struct i2c_client, dev);\r\nstruct apds990x_chip *chip = i2c_get_clientdata(client);\r\napds990x_chip_off(chip);\r\nreturn 0;\r\n}\r\nstatic int apds990x_resume(struct device *dev)\r\n{\r\nstruct i2c_client *client = container_of(dev, struct i2c_client, dev);\r\nstruct apds990x_chip *chip = i2c_get_clientdata(client);\r\napds990x_chip_on(chip);\r\nreturn 0;\r\n}\r\nstatic int apds990x_runtime_suspend(struct device *dev)\r\n{\r\nstruct i2c_client *client = container_of(dev, struct i2c_client, dev);\r\nstruct apds990x_chip *chip = i2c_get_clientdata(client);\r\napds990x_chip_off(chip);\r\nreturn 0;\r\n}\r\nstatic int apds990x_runtime_resume(struct device *dev)\r\n{\r\nstruct i2c_client *client = container_of(dev, struct i2c_client, dev);\r\nstruct apds990x_chip *chip = i2c_get_clientdata(client);\r\napds990x_chip_on(chip);\r\nreturn 0;\r\n}
