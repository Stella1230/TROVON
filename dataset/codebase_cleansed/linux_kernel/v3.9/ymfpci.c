static int snd_ymfpci_create_gameport(struct snd_ymfpci *chip, int dev,\r\nint legacy_ctrl, int legacy_ctrl2)\r\n{\r\nstruct gameport *gp;\r\nstruct resource *r = NULL;\r\nint io_port = joystick_port[dev];\r\nif (!io_port)\r\nreturn -ENODEV;\r\nif (chip->pci->device >= 0x0010) {\r\nif (io_port == 1) {\r\nif (!(io_port = pci_resource_start(chip->pci, 2)))\r\nreturn -ENODEV;\r\n}\r\n} else {\r\nif (io_port == 1) {\r\nfor (io_port = 0x201; io_port <= 0x205; io_port++) {\r\nif (io_port == 0x203)\r\ncontinue;\r\nif ((r = request_region(io_port, 1, "YMFPCI gameport")) != NULL)\r\nbreak;\r\n}\r\nif (!r) {\r\nprintk(KERN_ERR "ymfpci: no gameport ports available\n");\r\nreturn -EBUSY;\r\n}\r\n}\r\nswitch (io_port) {\r\ncase 0x201: legacy_ctrl2 |= 0 << 6; break;\r\ncase 0x202: legacy_ctrl2 |= 1 << 6; break;\r\ncase 0x204: legacy_ctrl2 |= 2 << 6; break;\r\ncase 0x205: legacy_ctrl2 |= 3 << 6; break;\r\ndefault:\r\nprintk(KERN_ERR "ymfpci: invalid joystick port %#x", io_port);\r\nreturn -EINVAL;\r\n}\r\n}\r\nif (!r && !(r = request_region(io_port, 1, "YMFPCI gameport"))) {\r\nprintk(KERN_ERR "ymfpci: joystick port %#x is in use.\n", io_port);\r\nreturn -EBUSY;\r\n}\r\nchip->gameport = gp = gameport_allocate_port();\r\nif (!gp) {\r\nprintk(KERN_ERR "ymfpci: cannot allocate memory for gameport\n");\r\nrelease_and_free_resource(r);\r\nreturn -ENOMEM;\r\n}\r\ngameport_set_name(gp, "Yamaha YMF Gameport");\r\ngameport_set_phys(gp, "pci%s/gameport0", pci_name(chip->pci));\r\ngameport_set_dev_parent(gp, &chip->pci->dev);\r\ngp->io = io_port;\r\ngameport_set_port_data(gp, r);\r\nif (chip->pci->device >= 0x0010)\r\npci_write_config_word(chip->pci, PCIR_DSXG_JOYBASE, io_port);\r\npci_write_config_word(chip->pci, PCIR_DSXG_LEGACY, legacy_ctrl | YMFPCI_LEGACY_JPEN);\r\npci_write_config_word(chip->pci, PCIR_DSXG_ELEGACY, legacy_ctrl2);\r\ngameport_register_port(chip->gameport);\r\nreturn 0;\r\n}\r\nvoid snd_ymfpci_free_gameport(struct snd_ymfpci *chip)\r\n{\r\nif (chip->gameport) {\r\nstruct resource *r = gameport_get_port_data(chip->gameport);\r\ngameport_unregister_port(chip->gameport);\r\nchip->gameport = NULL;\r\nrelease_and_free_resource(r);\r\n}\r\n}\r\nstatic inline int snd_ymfpci_create_gameport(struct snd_ymfpci *chip, int dev, int l, int l2) { return -ENOSYS; }\r\nvoid snd_ymfpci_free_gameport(struct snd_ymfpci *chip) { }\r\nstatic int snd_card_ymfpci_probe(struct pci_dev *pci,\r\nconst struct pci_device_id *pci_id)\r\n{\r\nstatic int dev;\r\nstruct snd_card *card;\r\nstruct resource *fm_res = NULL;\r\nstruct resource *mpu_res = NULL;\r\nstruct snd_ymfpci *chip;\r\nstruct snd_opl3 *opl3;\r\nconst char *str, *model;\r\nint err;\r\nu16 legacy_ctrl, legacy_ctrl2, old_legacy_ctrl;\r\nif (dev >= SNDRV_CARDS)\r\nreturn -ENODEV;\r\nif (!enable[dev]) {\r\ndev++;\r\nreturn -ENOENT;\r\n}\r\nerr = snd_card_create(index[dev], id[dev], THIS_MODULE, 0, &card);\r\nif (err < 0)\r\nreturn err;\r\nswitch (pci_id->device) {\r\ncase 0x0004: str = "YMF724"; model = "DS-1"; break;\r\ncase 0x000d: str = "YMF724F"; model = "DS-1"; break;\r\ncase 0x000a: str = "YMF740"; model = "DS-1L"; break;\r\ncase 0x000c: str = "YMF740C"; model = "DS-1L"; break;\r\ncase 0x0010: str = "YMF744"; model = "DS-1S"; break;\r\ncase 0x0012: str = "YMF754"; model = "DS-1E"; break;\r\ndefault: model = str = "???"; break;\r\n}\r\nlegacy_ctrl = 0;\r\nlegacy_ctrl2 = 0x0800;\r\nif (pci_id->device >= 0x0010) {\r\nif (fm_port[dev] == 1) {\r\nfm_port[dev] = pci_resource_start(pci, 1);\r\n}\r\nif (fm_port[dev] > 0 &&\r\n(fm_res = request_region(fm_port[dev], 4, "YMFPCI OPL3")) != NULL) {\r\nlegacy_ctrl |= YMFPCI_LEGACY_FMEN;\r\npci_write_config_word(pci, PCIR_DSXG_FMBASE, fm_port[dev]);\r\n}\r\nif (mpu_port[dev] == 1) {\r\nmpu_port[dev] = pci_resource_start(pci, 1) + 0x20;\r\n}\r\nif (mpu_port[dev] > 0 &&\r\n(mpu_res = request_region(mpu_port[dev], 2, "YMFPCI MPU401")) != NULL) {\r\nlegacy_ctrl |= YMFPCI_LEGACY_MEN;\r\npci_write_config_word(pci, PCIR_DSXG_MPU401BASE, mpu_port[dev]);\r\n}\r\n} else {\r\nswitch (fm_port[dev]) {\r\ncase 0x388: legacy_ctrl2 |= 0; break;\r\ncase 0x398: legacy_ctrl2 |= 1; break;\r\ncase 0x3a0: legacy_ctrl2 |= 2; break;\r\ncase 0x3a8: legacy_ctrl2 |= 3; break;\r\ndefault: fm_port[dev] = 0; break;\r\n}\r\nif (fm_port[dev] > 0 &&\r\n(fm_res = request_region(fm_port[dev], 4, "YMFPCI OPL3")) != NULL) {\r\nlegacy_ctrl |= YMFPCI_LEGACY_FMEN;\r\n} else {\r\nlegacy_ctrl2 &= ~YMFPCI_LEGACY2_FMIO;\r\nfm_port[dev] = 0;\r\n}\r\nswitch (mpu_port[dev]) {\r\ncase 0x330: legacy_ctrl2 |= 0 << 4; break;\r\ncase 0x300: legacy_ctrl2 |= 1 << 4; break;\r\ncase 0x332: legacy_ctrl2 |= 2 << 4; break;\r\ncase 0x334: legacy_ctrl2 |= 3 << 4; break;\r\ndefault: mpu_port[dev] = 0; break;\r\n}\r\nif (mpu_port[dev] > 0 &&\r\n(mpu_res = request_region(mpu_port[dev], 2, "YMFPCI MPU401")) != NULL) {\r\nlegacy_ctrl |= YMFPCI_LEGACY_MEN;\r\n} else {\r\nlegacy_ctrl2 &= ~YMFPCI_LEGACY2_MPUIO;\r\nmpu_port[dev] = 0;\r\n}\r\n}\r\nif (mpu_res) {\r\nlegacy_ctrl |= YMFPCI_LEGACY_MIEN;\r\nlegacy_ctrl2 |= YMFPCI_LEGACY2_IMOD;\r\n}\r\npci_read_config_word(pci, PCIR_DSXG_LEGACY, &old_legacy_ctrl);\r\npci_write_config_word(pci, PCIR_DSXG_LEGACY, legacy_ctrl);\r\npci_write_config_word(pci, PCIR_DSXG_ELEGACY, legacy_ctrl2);\r\nif ((err = snd_ymfpci_create(card, pci,\r\nold_legacy_ctrl,\r\n&chip)) < 0) {\r\nsnd_card_free(card);\r\nrelease_and_free_resource(mpu_res);\r\nrelease_and_free_resource(fm_res);\r\nreturn err;\r\n}\r\nchip->fm_res = fm_res;\r\nchip->mpu_res = mpu_res;\r\ncard->private_data = chip;\r\nstrcpy(card->driver, str);\r\nsprintf(card->shortname, "Yamaha %s (%s)", model, str);\r\nsprintf(card->longname, "%s at 0x%lx, irq %i",\r\ncard->shortname,\r\nchip->reg_area_phys,\r\nchip->irq);\r\nif ((err = snd_ymfpci_pcm(chip, 0, NULL)) < 0) {\r\nsnd_card_free(card);\r\nreturn err;\r\n}\r\nif ((err = snd_ymfpci_pcm_spdif(chip, 1, NULL)) < 0) {\r\nsnd_card_free(card);\r\nreturn err;\r\n}\r\nerr = snd_ymfpci_mixer(chip, rear_switch[dev]);\r\nif (err < 0) {\r\nsnd_card_free(card);\r\nreturn err;\r\n}\r\nif (chip->ac97->ext_id & AC97_EI_SDAC) {\r\nerr = snd_ymfpci_pcm_4ch(chip, 2, NULL);\r\nif (err < 0) {\r\nsnd_card_free(card);\r\nreturn err;\r\n}\r\nerr = snd_ymfpci_pcm2(chip, 3, NULL);\r\nif (err < 0) {\r\nsnd_card_free(card);\r\nreturn err;\r\n}\r\n}\r\nif ((err = snd_ymfpci_timer(chip, 0)) < 0) {\r\nsnd_card_free(card);\r\nreturn err;\r\n}\r\nif (chip->mpu_res) {\r\nif ((err = snd_mpu401_uart_new(card, 0, MPU401_HW_YMFPCI,\r\nmpu_port[dev],\r\nMPU401_INFO_INTEGRATED |\r\nMPU401_INFO_IRQ_HOOK,\r\n-1, &chip->rawmidi)) < 0) {\r\nprintk(KERN_WARNING "ymfpci: cannot initialize MPU401 at 0x%lx, skipping...\n", mpu_port[dev]);\r\nlegacy_ctrl &= ~YMFPCI_LEGACY_MIEN;\r\npci_write_config_word(pci, PCIR_DSXG_LEGACY, legacy_ctrl);\r\n}\r\n}\r\nif (chip->fm_res) {\r\nif ((err = snd_opl3_create(card,\r\nfm_port[dev],\r\nfm_port[dev] + 2,\r\nOPL3_HW_OPL3, 1, &opl3)) < 0) {\r\nprintk(KERN_WARNING "ymfpci: cannot initialize FM OPL3 at 0x%lx, skipping...\n", fm_port[dev]);\r\nlegacy_ctrl &= ~YMFPCI_LEGACY_FMEN;\r\npci_write_config_word(pci, PCIR_DSXG_LEGACY, legacy_ctrl);\r\n} else if ((err = snd_opl3_hwdep_new(opl3, 0, 1, NULL)) < 0) {\r\nsnd_card_free(card);\r\nsnd_printk(KERN_ERR "cannot create opl3 hwdep\n");\r\nreturn err;\r\n}\r\n}\r\nsnd_ymfpci_create_gameport(chip, dev, legacy_ctrl, legacy_ctrl2);\r\nif ((err = snd_card_register(card)) < 0) {\r\nsnd_card_free(card);\r\nreturn err;\r\n}\r\npci_set_drvdata(pci, card);\r\ndev++;\r\nreturn 0;\r\n}\r\nstatic void snd_card_ymfpci_remove(struct pci_dev *pci)\r\n{\r\nsnd_card_free(pci_get_drvdata(pci));\r\npci_set_drvdata(pci, NULL);\r\n}
