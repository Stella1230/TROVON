static int zfcp_cfdc_copy_from_user(struct scatterlist *sg,\r\nvoid __user *user_buffer)\r\n{\r\nunsigned int length;\r\nunsigned int size = ZFCP_CFDC_MAX_SIZE;\r\nwhile (size) {\r\nlength = min((unsigned int)size, sg->length);\r\nif (copy_from_user(sg_virt(sg++), user_buffer, length))\r\nreturn -EFAULT;\r\nuser_buffer += length;\r\nsize -= length;\r\n}\r\nreturn 0;\r\n}\r\nstatic int zfcp_cfdc_copy_to_user(void __user *user_buffer,\r\nstruct scatterlist *sg)\r\n{\r\nunsigned int length;\r\nunsigned int size = ZFCP_CFDC_MAX_SIZE;\r\nwhile (size) {\r\nlength = min((unsigned int) size, sg->length);\r\nif (copy_to_user(user_buffer, sg_virt(sg++), length))\r\nreturn -EFAULT;\r\nuser_buffer += length;\r\nsize -= length;\r\n}\r\nreturn 0;\r\n}\r\nstatic struct zfcp_adapter *zfcp_cfdc_get_adapter(u32 devno)\r\n{\r\nchar busid[9];\r\nstruct ccw_device *cdev;\r\nstruct zfcp_adapter *adapter;\r\nsnprintf(busid, sizeof(busid), "0.0.%04x", devno);\r\ncdev = get_ccwdev_by_busid(&zfcp_ccw_driver, busid);\r\nif (!cdev)\r\nreturn NULL;\r\nadapter = zfcp_ccw_adapter_by_cdev(cdev);\r\nput_device(&cdev->dev);\r\nreturn adapter;\r\n}\r\nstatic int zfcp_cfdc_set_fsf(struct zfcp_fsf_cfdc *fsf_cfdc, int command)\r\n{\r\nswitch (command) {\r\ncase ZFCP_CFDC_CMND_DOWNLOAD_NORMAL:\r\nfsf_cfdc->command = FSF_QTCB_DOWNLOAD_CONTROL_FILE;\r\nfsf_cfdc->option = FSF_CFDC_OPTION_NORMAL_MODE;\r\nbreak;\r\ncase ZFCP_CFDC_CMND_DOWNLOAD_FORCE:\r\nfsf_cfdc->command = FSF_QTCB_DOWNLOAD_CONTROL_FILE;\r\nfsf_cfdc->option = FSF_CFDC_OPTION_FORCE;\r\nbreak;\r\ncase ZFCP_CFDC_CMND_FULL_ACCESS:\r\nfsf_cfdc->command = FSF_QTCB_DOWNLOAD_CONTROL_FILE;\r\nfsf_cfdc->option = FSF_CFDC_OPTION_FULL_ACCESS;\r\nbreak;\r\ncase ZFCP_CFDC_CMND_RESTRICTED_ACCESS:\r\nfsf_cfdc->command = FSF_QTCB_DOWNLOAD_CONTROL_FILE;\r\nfsf_cfdc->option = FSF_CFDC_OPTION_RESTRICTED_ACCESS;\r\nbreak;\r\ncase ZFCP_CFDC_CMND_UPLOAD:\r\nfsf_cfdc->command = FSF_QTCB_UPLOAD_CONTROL_FILE;\r\nfsf_cfdc->option = 0;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int zfcp_cfdc_sg_setup(int command, struct scatterlist *sg,\r\nu8 __user *control_file)\r\n{\r\nint retval;\r\nretval = zfcp_sg_setup_table(sg, ZFCP_CFDC_PAGES);\r\nif (retval)\r\nreturn retval;\r\nsg[ZFCP_CFDC_PAGES - 1].length = ZFCP_CFDC_MAX_SIZE % PAGE_SIZE;\r\nif (command & ZFCP_CFDC_WITH_CONTROL_FILE &&\r\ncommand & ZFCP_CFDC_DOWNLOAD) {\r\nretval = zfcp_cfdc_copy_from_user(sg, control_file);\r\nif (retval) {\r\nzfcp_sg_free_table(sg, ZFCP_CFDC_PAGES);\r\nreturn -EFAULT;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void zfcp_cfdc_req_to_sense(struct zfcp_cfdc_data *data,\r\nstruct zfcp_fsf_req *req)\r\n{\r\ndata->fsf_status = req->qtcb->header.fsf_status;\r\nmemcpy(&data->fsf_status_qual, &req->qtcb->header.fsf_status_qual,\r\nsizeof(union fsf_status_qual));\r\nmemcpy(&data->payloads, &req->qtcb->bottom.support.els,\r\nsizeof(req->qtcb->bottom.support.els));\r\n}\r\nstatic long zfcp_cfdc_dev_ioctl(struct file *file, unsigned int command,\r\nunsigned long arg)\r\n{\r\nstruct zfcp_cfdc_data *data;\r\nstruct zfcp_cfdc_data __user *data_user;\r\nstruct zfcp_adapter *adapter;\r\nstruct zfcp_fsf_req *req;\r\nstruct zfcp_fsf_cfdc *fsf_cfdc;\r\nint retval;\r\nif (command != ZFCP_CFDC_IOC)\r\nreturn -ENOTTY;\r\nif (is_compat_task())\r\ndata_user = compat_ptr(arg);\r\nelse\r\ndata_user = (void __user *)arg;\r\nif (!data_user)\r\nreturn -EINVAL;\r\nfsf_cfdc = kmalloc(sizeof(struct zfcp_fsf_cfdc), GFP_KERNEL);\r\nif (!fsf_cfdc)\r\nreturn -ENOMEM;\r\ndata = memdup_user(data_user, sizeof(*data_user));\r\nif (IS_ERR(data)) {\r\nretval = PTR_ERR(data);\r\ngoto no_mem_sense;\r\n}\r\nif (data->signature != 0xCFDCACDF) {\r\nretval = -EINVAL;\r\ngoto free_buffer;\r\n}\r\nretval = zfcp_cfdc_set_fsf(fsf_cfdc, data->command);\r\nadapter = zfcp_cfdc_get_adapter(data->devno);\r\nif (!adapter) {\r\nretval = -ENXIO;\r\ngoto free_buffer;\r\n}\r\nretval = zfcp_cfdc_sg_setup(data->command, fsf_cfdc->sg,\r\ndata_user->control_file);\r\nif (retval)\r\ngoto adapter_put;\r\nreq = zfcp_fsf_control_file(adapter, fsf_cfdc);\r\nif (IS_ERR(req)) {\r\nretval = PTR_ERR(req);\r\ngoto free_sg;\r\n}\r\nif (req->status & ZFCP_STATUS_FSFREQ_ERROR) {\r\nretval = -ENXIO;\r\ngoto free_fsf;\r\n}\r\nzfcp_cfdc_req_to_sense(data, req);\r\nretval = copy_to_user(data_user, data, sizeof(*data_user));\r\nif (retval) {\r\nretval = -EFAULT;\r\ngoto free_fsf;\r\n}\r\nif (data->command & ZFCP_CFDC_UPLOAD)\r\nretval = zfcp_cfdc_copy_to_user(&data_user->control_file,\r\nfsf_cfdc->sg);\r\nfree_fsf:\r\nzfcp_fsf_req_free(req);\r\nfree_sg:\r\nzfcp_sg_free_table(fsf_cfdc->sg, ZFCP_CFDC_PAGES);\r\nadapter_put:\r\nzfcp_ccw_adapter_put(adapter);\r\nfree_buffer:\r\nkfree(data);\r\nno_mem_sense:\r\nkfree(fsf_cfdc);\r\nreturn retval;\r\n}\r\nvoid zfcp_cfdc_adapter_access_changed(struct zfcp_adapter *adapter)\r\n{\r\nunsigned long flags;\r\nstruct zfcp_port *port;\r\nstruct scsi_device *sdev;\r\nstruct zfcp_scsi_dev *zfcp_sdev;\r\nint status;\r\nif (adapter->connection_features & FSF_FEATURE_NPIV_MODE)\r\nreturn;\r\nread_lock_irqsave(&adapter->port_list_lock, flags);\r\nlist_for_each_entry(port, &adapter->port_list, list) {\r\nstatus = atomic_read(&port->status);\r\nif ((status & ZFCP_STATUS_COMMON_ACCESS_DENIED) ||\r\n(status & ZFCP_STATUS_COMMON_ACCESS_BOXED))\r\nzfcp_erp_port_reopen(port,\r\nZFCP_STATUS_COMMON_ERP_FAILED,\r\n"cfaac_1");\r\n}\r\nread_unlock_irqrestore(&adapter->port_list_lock, flags);\r\nshost_for_each_device(sdev, adapter->scsi_host) {\r\nzfcp_sdev = sdev_to_zfcp(sdev);\r\nstatus = atomic_read(&zfcp_sdev->status);\r\nif ((status & ZFCP_STATUS_COMMON_ACCESS_DENIED) ||\r\n(status & ZFCP_STATUS_COMMON_ACCESS_BOXED))\r\nzfcp_erp_lun_reopen(sdev,\r\nZFCP_STATUS_COMMON_ERP_FAILED,\r\n"cfaac_2");\r\n}\r\n}\r\nstatic void zfcp_act_eval_err(struct zfcp_adapter *adapter, u32 table)\r\n{\r\nu16 subtable = table >> 16;\r\nu16 rule = table & 0xffff;\r\nconst char *act_type[] = { "unknown", "OS", "WWPN", "DID", "LUN" };\r\nif (subtable && subtable < ARRAY_SIZE(act_type))\r\ndev_warn(&adapter->ccw_device->dev,\r\n"Access denied according to ACT rule type %s, "\r\n"rule %d\n", act_type[subtable], rule);\r\n}\r\nvoid zfcp_cfdc_port_denied(struct zfcp_port *port,\r\nunion fsf_status_qual *qual)\r\n{\r\ndev_warn(&port->adapter->ccw_device->dev,\r\n"Access denied to port 0x%016Lx\n",\r\n(unsigned long long)port->wwpn);\r\nzfcp_act_eval_err(port->adapter, qual->halfword[0]);\r\nzfcp_act_eval_err(port->adapter, qual->halfword[1]);\r\nzfcp_erp_set_port_status(port,\r\nZFCP_STATUS_COMMON_ERP_FAILED |\r\nZFCP_STATUS_COMMON_ACCESS_DENIED);\r\n}\r\nvoid zfcp_cfdc_lun_denied(struct scsi_device *sdev,\r\nunion fsf_status_qual *qual)\r\n{\r\nstruct zfcp_scsi_dev *zfcp_sdev = sdev_to_zfcp(sdev);\r\ndev_warn(&zfcp_sdev->port->adapter->ccw_device->dev,\r\n"Access denied to LUN 0x%016Lx on port 0x%016Lx\n",\r\nzfcp_scsi_dev_lun(sdev),\r\n(unsigned long long)zfcp_sdev->port->wwpn);\r\nzfcp_act_eval_err(zfcp_sdev->port->adapter, qual->halfword[0]);\r\nzfcp_act_eval_err(zfcp_sdev->port->adapter, qual->halfword[1]);\r\nzfcp_erp_set_lun_status(sdev,\r\nZFCP_STATUS_COMMON_ERP_FAILED |\r\nZFCP_STATUS_COMMON_ACCESS_DENIED);\r\natomic_clear_mask(ZFCP_STATUS_LUN_SHARED, &zfcp_sdev->status);\r\natomic_clear_mask(ZFCP_STATUS_LUN_READONLY, &zfcp_sdev->status);\r\n}\r\nvoid zfcp_cfdc_lun_shrng_vltn(struct scsi_device *sdev,\r\nunion fsf_status_qual *qual)\r\n{\r\nstruct zfcp_scsi_dev *zfcp_sdev = sdev_to_zfcp(sdev);\r\nif (qual->word[0])\r\ndev_warn(&zfcp_sdev->port->adapter->ccw_device->dev,\r\n"LUN 0x%Lx on port 0x%Lx is already in "\r\n"use by CSS%d, MIF Image ID %x\n",\r\nzfcp_scsi_dev_lun(sdev),\r\n(unsigned long long)zfcp_sdev->port->wwpn,\r\nqual->fsf_queue_designator.cssid,\r\nqual->fsf_queue_designator.hla);\r\nelse\r\nzfcp_act_eval_err(zfcp_sdev->port->adapter, qual->word[2]);\r\nzfcp_erp_set_lun_status(sdev,\r\nZFCP_STATUS_COMMON_ERP_FAILED |\r\nZFCP_STATUS_COMMON_ACCESS_DENIED);\r\natomic_clear_mask(ZFCP_STATUS_LUN_SHARED, &zfcp_sdev->status);\r\natomic_clear_mask(ZFCP_STATUS_LUN_READONLY, &zfcp_sdev->status);\r\n}\r\nint zfcp_cfdc_open_lun_eval(struct scsi_device *sdev,\r\nstruct fsf_qtcb_bottom_support *bottom)\r\n{\r\nint shared, rw;\r\nstruct zfcp_scsi_dev *zfcp_sdev = sdev_to_zfcp(sdev);\r\nstruct zfcp_adapter *adapter = zfcp_sdev->port->adapter;\r\nif ((adapter->connection_features & FSF_FEATURE_NPIV_MODE) ||\r\n!(adapter->adapter_features & FSF_FEATURE_LUN_SHARING) ||\r\nzfcp_ccw_priv_sch(adapter))\r\nreturn 0;\r\nshared = !(bottom->lun_access_info & FSF_UNIT_ACCESS_EXCLUSIVE);\r\nrw = (bottom->lun_access_info & FSF_UNIT_ACCESS_OUTBOUND_TRANSFER);\r\nif (shared)\r\natomic_set_mask(ZFCP_STATUS_LUN_SHARED, &zfcp_sdev->status);\r\nif (!rw) {\r\natomic_set_mask(ZFCP_STATUS_LUN_READONLY, &zfcp_sdev->status);\r\ndev_info(&adapter->ccw_device->dev, "SCSI device at LUN "\r\n"0x%016Lx on port 0x%016Lx opened read-only\n",\r\nzfcp_scsi_dev_lun(sdev),\r\n(unsigned long long)zfcp_sdev->port->wwpn);\r\n}\r\nif (!shared && !rw) {\r\ndev_err(&adapter->ccw_device->dev, "Exclusive read-only access "\r\n"not supported (LUN 0x%016Lx, port 0x%016Lx)\n",\r\nzfcp_scsi_dev_lun(sdev),\r\n(unsigned long long)zfcp_sdev->port->wwpn);\r\nzfcp_erp_set_lun_status(sdev, ZFCP_STATUS_COMMON_ERP_FAILED);\r\nzfcp_erp_lun_shutdown(sdev, 0, "fsouh_6");\r\nreturn -EACCES;\r\n}\r\nif (shared && rw) {\r\ndev_err(&adapter->ccw_device->dev,\r\n"Shared read-write access not supported "\r\n"(LUN 0x%016Lx, port 0x%016Lx)\n",\r\nzfcp_scsi_dev_lun(sdev),\r\n(unsigned long long)zfcp_sdev->port->wwpn);\r\nzfcp_erp_set_lun_status(sdev, ZFCP_STATUS_COMMON_ERP_FAILED);\r\nzfcp_erp_lun_shutdown(sdev, 0, "fsosh_8");\r\nreturn -EACCES;\r\n}\r\nreturn 0;\r\n}
