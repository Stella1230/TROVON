static int bp_device_event(struct notifier_block *unused,\r\nunsigned long event, void *ptr)\r\n{\r\nstruct net_device *dev = ptr;\r\nstatic bpctl_dev_t *pbpctl_dev = NULL, *pbpctl_dev_m = NULL;\r\nint dev_num = 0, ret = 0, ret_d = 0, time_left = 0;\r\nif (!dev)\r\nreturn NOTIFY_DONE;\r\nif (event == NETDEV_REGISTER) {\r\n{\r\nstruct ethtool_drvinfo drvinfo;\r\nchar cbuf[32];\r\nchar *buf = NULL;\r\nchar res[10];\r\nint i = 0, ifindex, idx_dev = 0;\r\nint bus = 0, slot = 0, func = 0;\r\nifindex = dev->ifindex;\r\nmemset(res, 0, 10);\r\nmemset(&drvinfo, 0, sizeof(struct ethtool_drvinfo));\r\nif (dev->ethtool_ops && dev->ethtool_ops->get_drvinfo) {\r\nmemset(&drvinfo, 0, sizeof(drvinfo));\r\ndev->ethtool_ops->get_drvinfo(dev, &drvinfo);\r\n} else\r\nreturn NOTIFY_DONE;\r\nif (!drvinfo.bus_info)\r\nreturn NOTIFY_DONE;\r\nif (!strcmp(drvinfo.bus_info, "N/A"))\r\nreturn NOTIFY_DONE;\r\nmemcpy(&cbuf, drvinfo.bus_info, 32);\r\nbuf = &cbuf[0];\r\nwhile (*buf++ != ':') ;\r\nfor (i = 0; i < 10; i++, buf++) {\r\nif (*buf == ':')\r\nbreak;\r\nres[i] = *buf;\r\n}\r\nbuf++;\r\nbus = str_to_hex(res);\r\nmemset(res, 0, 10);\r\nfor (i = 0; i < 10; i++, buf++) {\r\nif (*buf == '.')\r\nbreak;\r\nres[i] = *buf;\r\n}\r\nbuf++;\r\nslot = str_to_hex(res);\r\nfunc = str_to_hex(buf);\r\nidx_dev = get_dev_idx_bsf(bus, slot, func);\r\nif (idx_dev != -1) {\r\nbpctl_dev_arr[idx_dev].ifindex = ifindex;\r\nbpctl_dev_arr[idx_dev].ndev = dev;\r\nbypass_proc_remove_dev_sd(&bpctl_dev_arr\r\n[idx_dev]);\r\nbypass_proc_create_dev_sd(&bpctl_dev_arr\r\n[idx_dev]);\r\n}\r\n}\r\nreturn NOTIFY_DONE;\r\n}\r\nif (event == NETDEV_UNREGISTER) {\r\nint idx_dev = 0;\r\nfor (idx_dev = 0;\r\n((bpctl_dev_arr[idx_dev].pdev != NULL)\r\n&& (idx_dev < device_num)); idx_dev++) {\r\nif (bpctl_dev_arr[idx_dev].ndev == dev) {\r\nbypass_proc_remove_dev_sd(&bpctl_dev_arr\r\n[idx_dev]);\r\nbpctl_dev_arr[idx_dev].ndev = NULL;\r\nreturn NOTIFY_DONE;\r\n}\r\n}\r\nreturn NOTIFY_DONE;\r\n}\r\nif (event == NETDEV_CHANGENAME) {\r\nint idx_dev = 0;\r\nfor (idx_dev = 0;\r\n((bpctl_dev_arr[idx_dev].pdev != NULL)\r\n&& (idx_dev < device_num)); idx_dev++) {\r\nif (bpctl_dev_arr[idx_dev].ndev == dev) {\r\nbypass_proc_remove_dev_sd(&bpctl_dev_arr\r\n[idx_dev]);\r\nbypass_proc_create_dev_sd(&bpctl_dev_arr\r\n[idx_dev]);\r\nreturn NOTIFY_DONE;\r\n}\r\n}\r\nreturn NOTIFY_DONE;\r\n}\r\nswitch (event) {\r\ncase NETDEV_CHANGE:{\r\nif (netif_carrier_ok(dev))\r\nreturn NOTIFY_DONE;\r\nif (((dev_num = get_dev_idx(dev->ifindex)) == -1) ||\r\n(!(pbpctl_dev = &bpctl_dev_arr[dev_num])))\r\nreturn NOTIFY_DONE;\r\nif ((is_bypass_fn(pbpctl_dev)) == 1)\r\npbpctl_dev_m = pbpctl_dev;\r\nelse\r\npbpctl_dev_m = get_master_port_fn(pbpctl_dev);\r\nif (!pbpctl_dev_m)\r\nreturn NOTIFY_DONE;\r\nret = bypass_status(pbpctl_dev_m);\r\nif (ret == 1)\r\nprintk("bpmod: %s is in the Bypass mode now",\r\ndev->name);\r\nret_d = disc_status(pbpctl_dev_m);\r\nif (ret_d == 1)\r\nprintk\r\n("bpmod: %s is in the Disconnect mode now",\r\ndev->name);\r\nif (ret || ret_d) {\r\nwdt_timer(pbpctl_dev_m, &time_left);\r\nif (time_left == -1)\r\nprintk("; WDT has expired");\r\nprintk(".\n");\r\n}\r\nreturn NOTIFY_DONE;\r\n}\r\ndefault:\r\nreturn NOTIFY_DONE;\r\n}\r\nreturn NOTIFY_DONE;\r\n}\r\nstatic int device_open(struct inode *inode, struct file *file)\r\n{\r\n#ifdef DEBUG\r\nprintk("device_open(%p)\n", file);\r\n#endif\r\nDevice_Open++;\r\nreturn SUCCESS;\r\n}\r\nstatic int device_release(struct inode *inode, struct file *file)\r\n{\r\n#ifdef DEBUG\r\nprintk("device_release(%p,%p)\n", inode, file);\r\n#endif\r\nDevice_Open--;\r\nreturn SUCCESS;\r\n}\r\nstatic void write_pulse(bpctl_dev_t *pbpctl_dev,\r\nunsigned int ctrl_ext,\r\nunsigned char value, unsigned char len)\r\n{\r\nunsigned char ctrl_val = 0;\r\nunsigned int i = len;\r\nunsigned int ctrl = 0;\r\nbpctl_dev_t *pbpctl_dev_c = NULL;\r\nif (pbpctl_dev->bp_i80)\r\nctrl = BPCTL_READ_REG(pbpctl_dev, CTRL_EXT);\r\nif (pbpctl_dev->bp_540)\r\nctrl = BP10G_READ_REG(pbpctl_dev, ESDP);\r\nif (pbpctl_dev->bp_10g9) {\r\nif (!(pbpctl_dev_c = get_status_port_fn(pbpctl_dev)))\r\nreturn;\r\nctrl = BP10G_READ_REG(pbpctl_dev_c, ESDP);\r\n}\r\nwhile (i--) {\r\nctrl_val = (value >> i) & 0x1;\r\nif (ctrl_val) {\r\nif (pbpctl_dev->bp_10g9) {\r\nBP10G_WRITE_REG(pbpctl_dev, I2CCTL,\r\nctrl_ext |\r\nBP10G_MDIO_DATA_OUT9);\r\nBP10G_WRITE_REG(pbpctl_dev_c, ESDP,\r\n(ctrl | BP10G_MCLK_DATA_OUT9 |\r\nBP10G_MCLK_DIR_OUT9));\r\n} else if (pbpctl_dev->bp_fiber5) {\r\nBPCTL_BP_WRITE_REG(pbpctl_dev, CTRL, (ctrl_ext |\r\nBPCTLI_CTRL_EXT_MCLK_DIR5\r\n|\r\nBPCTLI_CTRL_EXT_MDIO_DIR5\r\n|\r\nBPCTLI_CTRL_EXT_MDIO_DATA5\r\n|\r\nBPCTLI_CTRL_EXT_MCLK_DATA5));\r\n} else if (pbpctl_dev->bp_i80) {\r\nBPCTL_BP_WRITE_REG(pbpctl_dev, CTRL, (ctrl_ext |\r\nBPCTLI_CTRL_EXT_MDIO_DIR80\r\n|\r\nBPCTLI_CTRL_EXT_MDIO_DATA80));\r\nBPCTL_BP_WRITE_REG(pbpctl_dev, CTRL_EXT, (ctrl |\r\nBPCTLI_CTRL_EXT_MCLK_DIR80\r\n|\r\nBPCTLI_CTRL_EXT_MCLK_DATA80));\r\n} else if (pbpctl_dev->bp_540) {\r\nBP10G_WRITE_REG(pbpctl_dev, ESDP, (ctrl |\r\nBP540_MDIO_DIR\r\n|\r\nBP540_MDIO_DATA\r\n|\r\nBP540_MCLK_DIR\r\n|\r\nBP540_MCLK_DATA));\r\n} else if (pbpctl_dev->bp_10gb) {\r\nBP10GB_WRITE_REG(pbpctl_dev, MISC_REG_SPIO,\r\n(ctrl_ext | BP10GB_MDIO_SET |\r\nBP10GB_MCLK_SET) &\r\n~(BP10GB_MCLK_DIR |\r\nBP10GB_MDIO_DIR |\r\nBP10GB_MDIO_CLR |\r\nBP10GB_MCLK_CLR));\r\n} else if (!pbpctl_dev->bp_10g)\r\nBPCTL_BP_WRITE_REG(pbpctl_dev, CTRL_EXT,\r\n(ctrl_ext |\r\nBPCTLI_CTRL_EXT_MCLK_DIR |\r\nBPCTLI_CTRL_EXT_MDIO_DIR |\r\nBPCTLI_CTRL_EXT_MDIO_DATA |\r\nBPCTLI_CTRL_EXT_MCLK_DATA));\r\nelse {\r\nBP10G_WRITE_REG(pbpctl_dev, EODSDP,\r\n(ctrl_ext | BP10G_MCLK_DATA_OUT\r\n| BP10G_MDIO_DATA_OUT));\r\n}\r\nusec_delay(PULSE_TIME);\r\nif (pbpctl_dev->bp_10g9) {\r\nBP10G_WRITE_REG(pbpctl_dev, I2CCTL,\r\nctrl_ext |\r\nBP10G_MDIO_DATA_OUT9);\r\nBP10G_WRITE_REG(pbpctl_dev_c, ESDP,\r\n(ctrl | BP10G_MCLK_DIR_OUT9) &\r\n~BP10G_MCLK_DATA_OUT9);\r\n} else if (pbpctl_dev->bp_fiber5) {\r\nBPCTL_BP_WRITE_REG(pbpctl_dev, CTRL,\r\n((ctrl_ext |\r\nBPCTLI_CTRL_EXT_MCLK_DIR5 |\r\nBPCTLI_CTRL_EXT_MDIO_DIR5 |\r\nBPCTLI_CTRL_EXT_MDIO_DATA5)\r\n&\r\n~\r\n(BPCTLI_CTRL_EXT_MCLK_DATA5)));\r\n} else if (pbpctl_dev->bp_i80) {\r\nBPCTL_BP_WRITE_REG(pbpctl_dev, CTRL, (ctrl_ext |\r\nBPCTLI_CTRL_EXT_MDIO_DIR80\r\n|\r\nBPCTLI_CTRL_EXT_MDIO_DATA80));\r\nBPCTL_BP_WRITE_REG(pbpctl_dev, CTRL_EXT,\r\n((ctrl |\r\nBPCTLI_CTRL_EXT_MCLK_DIR80)\r\n&\r\n~\r\n(BPCTLI_CTRL_EXT_MCLK_DATA80)));\r\n} else if (pbpctl_dev->bp_540) {\r\nBP10G_WRITE_REG(pbpctl_dev, ESDP,\r\n(ctrl | BP540_MDIO_DIR |\r\nBP540_MDIO_DATA |\r\nBP540_MCLK_DIR) &\r\n~(BP540_MCLK_DATA));\r\n} else if (pbpctl_dev->bp_10gb) {\r\nBP10GB_WRITE_REG(pbpctl_dev, MISC_REG_SPIO,\r\n(ctrl_ext | BP10GB_MDIO_SET |\r\nBP10GB_MCLK_CLR) &\r\n~(BP10GB_MCLK_DIR |\r\nBP10GB_MDIO_DIR |\r\nBP10GB_MDIO_CLR |\r\nBP10GB_MCLK_SET));\r\n} else if (!pbpctl_dev->bp_10g)\r\nBPCTL_BP_WRITE_REG(pbpctl_dev, CTRL_EXT,\r\n((ctrl_ext |\r\nBPCTLI_CTRL_EXT_MCLK_DIR |\r\nBPCTLI_CTRL_EXT_MDIO_DIR |\r\nBPCTLI_CTRL_EXT_MDIO_DATA)\r\n&\r\n~\r\n(BPCTLI_CTRL_EXT_MCLK_DATA)));\r\nelse {\r\nBP10G_WRITE_REG(pbpctl_dev, EODSDP,\r\n((ctrl_ext |\r\nBP10G_MDIO_DATA_OUT) &\r\n~(BP10G_MCLK_DATA_OUT)));\r\n}\r\nusec_delay(PULSE_TIME);\r\n} else {\r\nif (pbpctl_dev->bp_10g9) {\r\nBP10G_WRITE_REG(pbpctl_dev, I2CCTL,\r\n(ctrl_ext &\r\n~BP10G_MDIO_DATA_OUT9));\r\nBP10G_WRITE_REG(pbpctl_dev_c, ESDP,\r\n(ctrl | BP10G_MCLK_DATA_OUT9 |\r\nBP10G_MCLK_DIR_OUT9));\r\n} else if (pbpctl_dev->bp_fiber5) {\r\nBPCTL_BP_WRITE_REG(pbpctl_dev, CTRL,\r\n((ctrl_ext |\r\nBPCTLI_CTRL_EXT_MCLK_DIR5 |\r\nBPCTLI_CTRL_EXT_MDIO_DIR5 |\r\nBPCTLI_CTRL_EXT_MCLK_DATA5)\r\n&\r\n~\r\n(BPCTLI_CTRL_EXT_MDIO_DATA5)));\r\n} else if (pbpctl_dev->bp_i80) {\r\nBPCTL_BP_WRITE_REG(pbpctl_dev, CTRL,\r\n((ctrl_ext |\r\nBPCTLI_CTRL_EXT_MDIO_DIR80)\r\n&\r\n~\r\n(BPCTLI_CTRL_EXT_MDIO_DATA80)));\r\nBPCTL_BP_WRITE_REG(pbpctl_dev, CTRL_EXT,\r\n(ctrl |\r\nBPCTLI_CTRL_EXT_MCLK_DIR80 |\r\nBPCTLI_CTRL_EXT_MCLK_DATA80));\r\n} else if (pbpctl_dev->bp_540) {\r\nBP10G_WRITE_REG(pbpctl_dev, ESDP,\r\n((ctrl | BP540_MCLK_DIR |\r\nBP540_MCLK_DATA |\r\nBP540_MDIO_DIR) &\r\n~(BP540_MDIO_DATA)));\r\n} else if (pbpctl_dev->bp_10gb) {\r\nBP10GB_WRITE_REG(pbpctl_dev, MISC_REG_SPIO,\r\n(ctrl_ext | BP10GB_MDIO_CLR |\r\nBP10GB_MCLK_SET) &\r\n~(BP10GB_MCLK_DIR |\r\nBP10GB_MDIO_DIR |\r\nBP10GB_MDIO_SET |\r\nBP10GB_MCLK_CLR));\r\n} else if (!pbpctl_dev->bp_10g)\r\nBPCTL_BP_WRITE_REG(pbpctl_dev, CTRL_EXT,\r\n((ctrl_ext |\r\nBPCTLI_CTRL_EXT_MCLK_DIR |\r\nBPCTLI_CTRL_EXT_MDIO_DIR |\r\nBPCTLI_CTRL_EXT_MCLK_DATA)\r\n&\r\n~\r\n(BPCTLI_CTRL_EXT_MDIO_DATA)));\r\nelse {\r\nBP10G_WRITE_REG(pbpctl_dev, EODSDP,\r\n((ctrl_ext |\r\nBP10G_MCLK_DATA_OUT) &\r\n~BP10G_MDIO_DATA_OUT));\r\n}\r\nusec_delay(PULSE_TIME);\r\nif (pbpctl_dev->bp_10g9) {\r\nBP10G_WRITE_REG(pbpctl_dev, I2CCTL,\r\n(ctrl_ext &\r\n~BP10G_MDIO_DATA_OUT9));\r\nBP10G_WRITE_REG(pbpctl_dev_c, ESDP,\r\n((ctrl | BP10G_MCLK_DIR_OUT9) &\r\n~(BP10G_MCLK_DATA_OUT9)));\r\n} else if (pbpctl_dev->bp_fiber5) {\r\nBPCTL_BP_WRITE_REG(pbpctl_dev, CTRL,\r\n((ctrl_ext |\r\nBPCTLI_CTRL_EXT_MCLK_DIR5 |\r\nBPCTLI_CTRL_EXT_MDIO_DIR5)\r\n&\r\n~(BPCTLI_CTRL_EXT_MCLK_DATA5\r\n|\r\nBPCTLI_CTRL_EXT_MDIO_DATA5)));\r\n} else if (pbpctl_dev->bp_i80) {\r\nBPCTL_BP_WRITE_REG(pbpctl_dev, CTRL,\r\n((ctrl_ext |\r\nBPCTLI_CTRL_EXT_MDIO_DIR80)\r\n&\r\n~BPCTLI_CTRL_EXT_MDIO_DATA80));\r\nBPCTL_BP_WRITE_REG(pbpctl_dev, CTRL_EXT,\r\n((ctrl |\r\nBPCTLI_CTRL_EXT_MCLK_DIR80)\r\n&\r\n~\r\n(BPCTLI_CTRL_EXT_MCLK_DATA80)));\r\n} else if (pbpctl_dev->bp_540) {\r\nBP10G_WRITE_REG(pbpctl_dev, ESDP,\r\n((ctrl | BP540_MCLK_DIR |\r\nBP540_MDIO_DIR) &\r\n~(BP540_MDIO_DATA |\r\nBP540_MCLK_DATA)));\r\n} else if (pbpctl_dev->bp_10gb) {\r\nBP10GB_WRITE_REG(pbpctl_dev, MISC_REG_SPIO,\r\n(ctrl_ext | BP10GB_MDIO_CLR |\r\nBP10GB_MCLK_CLR) &\r\n~(BP10GB_MCLK_DIR |\r\nBP10GB_MDIO_DIR |\r\nBP10GB_MDIO_SET |\r\nBP10GB_MCLK_SET));\r\n} else if (!pbpctl_dev->bp_10g)\r\nBPCTL_BP_WRITE_REG(pbpctl_dev, CTRL_EXT,\r\n((ctrl_ext |\r\nBPCTLI_CTRL_EXT_MCLK_DIR |\r\nBPCTLI_CTRL_EXT_MDIO_DIR) &\r\n~(BPCTLI_CTRL_EXT_MCLK_DATA\r\n|\r\nBPCTLI_CTRL_EXT_MDIO_DATA)));\r\nelse {\r\nBP10G_WRITE_REG(pbpctl_dev, EODSDP,\r\n(ctrl_ext &\r\n~(BP10G_MCLK_DATA_OUT |\r\nBP10G_MDIO_DATA_OUT)));\r\n}\r\nusec_delay(PULSE_TIME);\r\n}\r\n}\r\n}\r\nstatic int read_pulse(bpctl_dev_t *pbpctl_dev, unsigned int ctrl_ext,\r\nunsigned char len)\r\n{\r\nunsigned char ctrl_val = 0;\r\nunsigned int i = len;\r\nunsigned int ctrl = 0;\r\nbpctl_dev_t *pbpctl_dev_c = NULL;\r\nif (pbpctl_dev->bp_i80)\r\nctrl = BPCTL_READ_REG(pbpctl_dev, CTRL_EXT);\r\nif (pbpctl_dev->bp_540)\r\nctrl = BP10G_READ_REG(pbpctl_dev, ESDP);\r\nif (pbpctl_dev->bp_10g9) {\r\nif (!(pbpctl_dev_c = get_status_port_fn(pbpctl_dev)))\r\nreturn -1;\r\nctrl = BP10G_READ_REG(pbpctl_dev_c, ESDP);\r\n}\r\nwhile (i--) {\r\nif (pbpctl_dev->bp_10g9) {\r\nBP10G_WRITE_REG(pbpctl_dev_c, ESDP,\r\n((ctrl | BP10G_MCLK_DIR_OUT9) &\r\n~(BP10G_MCLK_DATA_OUT9)));\r\n} else if (pbpctl_dev->bp_fiber5) {\r\nBPCTL_BP_WRITE_REG(pbpctl_dev, CTRL, ((ctrl_ext |\r\nBPCTLI_CTRL_EXT_MCLK_DIR5)\r\n&\r\n~\r\n(BPCTLI_CTRL_EXT_MDIO_DIR5\r\n|\r\nBPCTLI_CTRL_EXT_MCLK_DATA5)));\r\n} else if (pbpctl_dev->bp_i80) {\r\nBPCTL_BP_WRITE_REG(pbpctl_dev, CTRL,\r\n(ctrl_ext &\r\n~BPCTLI_CTRL_EXT_MDIO_DIR80));\r\nBPCTL_BP_WRITE_REG(pbpctl_dev, CTRL_EXT,\r\n((ctrl | BPCTLI_CTRL_EXT_MCLK_DIR80)\r\n& ~(BPCTLI_CTRL_EXT_MCLK_DATA80)));\r\n} else if (pbpctl_dev->bp_540) {\r\nBP10G_WRITE_REG(pbpctl_dev, ESDP,\r\n((ctrl | BP540_MCLK_DIR) &\r\n~(BP540_MDIO_DIR | BP540_MCLK_DATA)));\r\n} else if (pbpctl_dev->bp_10gb) {\r\nBP10GB_WRITE_REG(pbpctl_dev, MISC_REG_SPIO,\r\n(ctrl_ext | BP10GB_MDIO_DIR |\r\nBP10GB_MCLK_CLR) & ~(BP10GB_MCLK_DIR |\r\nBP10GB_MDIO_CLR |\r\nBP10GB_MDIO_SET |\r\nBP10GB_MCLK_SET));\r\n} else if (!pbpctl_dev->bp_10g)\r\nBPCTL_BP_WRITE_REG(pbpctl_dev, CTRL_EXT, ((ctrl_ext |\r\nBPCTLI_CTRL_EXT_MCLK_DIR)\r\n&\r\n~\r\n(BPCTLI_CTRL_EXT_MDIO_DIR\r\n|\r\nBPCTLI_CTRL_EXT_MCLK_DATA)));\r\nelse {\r\nBP10G_WRITE_REG(pbpctl_dev, EODSDP, ((ctrl_ext | BP10G_MDIO_DATA_OUT) & ~BP10G_MCLK_DATA_OUT));\r\n}\r\nusec_delay(PULSE_TIME);\r\nif (pbpctl_dev->bp_10g9) {\r\nBP10G_WRITE_REG(pbpctl_dev_c, ESDP,\r\n(ctrl | BP10G_MCLK_DATA_OUT9 |\r\nBP10G_MCLK_DIR_OUT9));\r\n} else if (pbpctl_dev->bp_fiber5) {\r\nBPCTL_BP_WRITE_REG(pbpctl_dev, CTRL, ((ctrl_ext |\r\nBPCTLI_CTRL_EXT_MCLK_DIR5\r\n|\r\nBPCTLI_CTRL_EXT_MCLK_DATA5)\r\n&\r\n~\r\n(BPCTLI_CTRL_EXT_MDIO_DIR5)));\r\n} else if (pbpctl_dev->bp_i80) {\r\nBPCTL_BP_WRITE_REG(pbpctl_dev, CTRL,\r\n(ctrl_ext &\r\n~(BPCTLI_CTRL_EXT_MDIO_DIR80)));\r\nBPCTL_BP_WRITE_REG(pbpctl_dev, CTRL_EXT,\r\n(ctrl | BPCTLI_CTRL_EXT_MCLK_DIR80 |\r\nBPCTLI_CTRL_EXT_MCLK_DATA80));\r\n} else if (pbpctl_dev->bp_540) {\r\nBP10G_WRITE_REG(pbpctl_dev, ESDP,\r\n((ctrl | BP540_MCLK_DIR |\r\nBP540_MCLK_DATA) &\r\n~(BP540_MDIO_DIR)));\r\n} else if (pbpctl_dev->bp_10gb) {\r\nBP10GB_WRITE_REG(pbpctl_dev, MISC_REG_SPIO,\r\n(ctrl_ext | BP10GB_MDIO_DIR |\r\nBP10GB_MCLK_SET) & ~(BP10GB_MCLK_DIR |\r\nBP10GB_MDIO_CLR |\r\nBP10GB_MDIO_SET |\r\nBP10GB_MCLK_CLR));\r\n} else if (!pbpctl_dev->bp_10g)\r\nBPCTL_BP_WRITE_REG(pbpctl_dev, CTRL_EXT, ((ctrl_ext |\r\nBPCTLI_CTRL_EXT_MCLK_DIR\r\n|\r\nBPCTLI_CTRL_EXT_MCLK_DATA)\r\n&\r\n~\r\n(BPCTLI_CTRL_EXT_MDIO_DIR)));\r\nelse {\r\nBP10G_WRITE_REG(pbpctl_dev, EODSDP,\r\n(ctrl_ext | BP10G_MCLK_DATA_OUT |\r\nBP10G_MDIO_DATA_OUT));\r\n}\r\nif (pbpctl_dev->bp_10g9) {\r\nctrl_ext = BP10G_READ_REG(pbpctl_dev, I2CCTL);\r\n} else if ((pbpctl_dev->bp_fiber5) || (pbpctl_dev->bp_i80)) {\r\nctrl_ext = BPCTL_READ_REG(pbpctl_dev, CTRL);\r\n} else if (pbpctl_dev->bp_540) {\r\nctrl_ext = BP10G_READ_REG(pbpctl_dev, ESDP);\r\n} else if (pbpctl_dev->bp_10gb)\r\nctrl_ext = BP10GB_READ_REG(pbpctl_dev, MISC_REG_SPIO);\r\nelse if (!pbpctl_dev->bp_10g)\r\nctrl_ext = BPCTL_READ_REG(pbpctl_dev, CTRL_EXT);\r\nelse\r\nctrl_ext = BP10G_READ_REG(pbpctl_dev, EODSDP);\r\nusec_delay(PULSE_TIME);\r\nif (pbpctl_dev->bp_10g9) {\r\nif (ctrl_ext & BP10G_MDIO_DATA_IN9)\r\nctrl_val |= 1 << i;\r\n} else if (pbpctl_dev->bp_fiber5) {\r\nif (ctrl_ext & BPCTLI_CTRL_EXT_MDIO_DATA5)\r\nctrl_val |= 1 << i;\r\n} else if (pbpctl_dev->bp_i80) {\r\nif (ctrl_ext & BPCTLI_CTRL_EXT_MDIO_DATA80)\r\nctrl_val |= 1 << i;\r\n} else if (pbpctl_dev->bp_540) {\r\nif (ctrl_ext & BP540_MDIO_DATA)\r\nctrl_val |= 1 << i;\r\n} else if (pbpctl_dev->bp_10gb) {\r\nif (ctrl_ext & BP10GB_MDIO_DATA)\r\nctrl_val |= 1 << i;\r\n} else if (!pbpctl_dev->bp_10g) {\r\nif (ctrl_ext & BPCTLI_CTRL_EXT_MDIO_DATA)\r\nctrl_val |= 1 << i;\r\n} else {\r\nif (ctrl_ext & BP10G_MDIO_DATA_IN)\r\nctrl_val |= 1 << i;\r\n}\r\n}\r\nreturn ctrl_val;\r\n}\r\nstatic void write_reg(bpctl_dev_t *pbpctl_dev, unsigned char value,\r\nunsigned char addr)\r\n{\r\nuint32_t ctrl_ext = 0, ctrl = 0;\r\nbpctl_dev_t *pbpctl_dev_c = NULL;\r\nunsigned long flags;\r\nif (pbpctl_dev->bp_10g9) {\r\nif (!(pbpctl_dev_c = get_status_port_fn(pbpctl_dev)))\r\nreturn;\r\n}\r\nif ((pbpctl_dev->wdt_status == WDT_STATUS_EN) &&\r\n(pbpctl_dev->bp_ext_ver < PXG4BPFI_VER))\r\nwdt_time_left(pbpctl_dev);\r\n#ifdef BP_SYNC_FLAG\r\nspin_lock_irqsave(&pbpctl_dev->bypass_wr_lock, flags);\r\n#else\r\natomic_set(&pbpctl_dev->wdt_busy, 1);\r\n#endif\r\nif (pbpctl_dev->bp_10g9) {\r\nctrl_ext = BP10G_READ_REG(pbpctl_dev, I2CCTL);\r\nctrl = BP10G_READ_REG(pbpctl_dev_c, ESDP);\r\nBP10G_WRITE_REG(pbpctl_dev, I2CCTL,\r\n(ctrl_ext & ~BP10G_MDIO_DATA_OUT9));\r\nBP10G_WRITE_REG(pbpctl_dev_c, ESDP,\r\n((ctrl | BP10G_MCLK_DIR_OUT9) &\r\n~(BP10G_MCLK_DATA_OUT9)));\r\n} else if (pbpctl_dev->bp_fiber5) {\r\nctrl_ext = BPCTL_READ_REG(pbpctl_dev, CTRL);\r\nBPCTL_BP_WRITE_REG(pbpctl_dev, CTRL, ((ctrl_ext |\r\nBPCTLI_CTRL_EXT_MCLK_DIR5\r\n|\r\nBPCTLI_CTRL_EXT_MDIO_DIR5)\r\n&\r\n~\r\n(BPCTLI_CTRL_EXT_MDIO_DATA5\r\n|\r\nBPCTLI_CTRL_EXT_MCLK_DATA5)));\r\n} else if (pbpctl_dev->bp_i80) {\r\nctrl_ext = BPCTL_READ_REG(pbpctl_dev, CTRL);\r\nctrl = BPCTL_READ_REG(pbpctl_dev, CTRL_EXT);\r\nBPCTL_BP_WRITE_REG(pbpctl_dev, CTRL, ((ctrl_ext |\r\nBPCTLI_CTRL_EXT_MDIO_DIR80)\r\n&\r\n~BPCTLI_CTRL_EXT_MDIO_DATA80));\r\nBPCTL_BP_WRITE_REG(pbpctl_dev, CTRL_EXT,\r\n((ctrl | BPCTLI_CTRL_EXT_MCLK_DIR80) &\r\n~BPCTLI_CTRL_EXT_MCLK_DATA80));\r\n} else if (pbpctl_dev->bp_540) {\r\nctrl = ctrl_ext = BP10G_READ_REG(pbpctl_dev, ESDP);\r\nBP10G_WRITE_REG(pbpctl_dev, ESDP, ((ctrl |\r\nBP540_MDIO_DIR |\r\nBP540_MCLK_DIR) &\r\n~(BP540_MDIO_DATA |\r\nBP540_MCLK_DATA)));\r\n} else if (pbpctl_dev->bp_10gb) {\r\nctrl_ext = BP10GB_READ_REG(pbpctl_dev, MISC_REG_SPIO);\r\nBP10GB_WRITE_REG(pbpctl_dev, MISC_REG_SPIO,\r\n(ctrl_ext | BP10GB_MDIO_CLR | BP10GB_MCLK_CLR)\r\n& ~(BP10GB_MCLK_DIR | BP10GB_MDIO_DIR |\r\nBP10GB_MDIO_SET | BP10GB_MCLK_SET));\r\n} else if (!pbpctl_dev->bp_10g) {\r\nctrl_ext = BPCTL_READ_REG(pbpctl_dev, CTRL_EXT);\r\nBPCTL_BP_WRITE_REG(pbpctl_dev, CTRL_EXT, ((ctrl_ext |\r\nBPCTLI_CTRL_EXT_MCLK_DIR\r\n|\r\nBPCTLI_CTRL_EXT_MDIO_DIR)\r\n&\r\n~\r\n(BPCTLI_CTRL_EXT_MDIO_DATA\r\n|\r\nBPCTLI_CTRL_EXT_MCLK_DATA)));\r\n} else {\r\nctrl = BP10G_READ_REG(pbpctl_dev, ESDP);\r\nctrl_ext = BP10G_READ_REG(pbpctl_dev, EODSDP);\r\nBP10G_WRITE_REG(pbpctl_dev, EODSDP,\r\n(ctrl_ext &\r\n~(BP10G_MCLK_DATA_OUT | BP10G_MDIO_DATA_OUT)));\r\n}\r\nusec_delay(CMND_INTERVAL);\r\nwrite_pulse(pbpctl_dev, ctrl_ext, SYNC_CMD_VAL, SYNC_CMD_LEN);\r\nwrite_pulse(pbpctl_dev, ctrl_ext, WR_CMD_VAL, WR_CMD_LEN);\r\nwrite_pulse(pbpctl_dev, ctrl_ext, addr, ADDR_CMD_LEN);\r\nwrite_pulse(pbpctl_dev, ctrl_ext, value, WR_DATA_LEN);\r\nif (pbpctl_dev->bp_10g9) {\r\nBP10G_WRITE_REG(pbpctl_dev, I2CCTL,\r\n(ctrl_ext & ~BP10G_MDIO_DATA_OUT9));\r\nBP10G_WRITE_REG(pbpctl_dev_c, ESDP,\r\n((ctrl | BP10G_MCLK_DIR_OUT9) &\r\n~(BP10G_MCLK_DATA_OUT9)));\r\n} else if (pbpctl_dev->bp_fiber5) {\r\nBPCTL_BP_WRITE_REG(pbpctl_dev, CTRL, ((ctrl_ext |\r\nBPCTLI_CTRL_EXT_MCLK_DIR5\r\n|\r\nBPCTLI_CTRL_EXT_MDIO_DIR5)\r\n&\r\n~\r\n(BPCTLI_CTRL_EXT_MDIO_DATA5\r\n|\r\nBPCTLI_CTRL_EXT_MCLK_DATA5)));\r\n} else if (pbpctl_dev->bp_i80) {\r\nBPCTL_BP_WRITE_REG(pbpctl_dev, CTRL, ((ctrl_ext |\r\nBPCTLI_CTRL_EXT_MDIO_DIR80)\r\n&\r\n~BPCTLI_CTRL_EXT_MDIO_DATA80));\r\nBPCTL_BP_WRITE_REG(pbpctl_dev, CTRL_EXT,\r\n((ctrl | BPCTLI_CTRL_EXT_MCLK_DIR80) &\r\n~BPCTLI_CTRL_EXT_MCLK_DATA80));\r\n} else if (pbpctl_dev->bp_540) {\r\nBP10G_WRITE_REG(pbpctl_dev, ESDP, ((ctrl |\r\nBP540_MDIO_DIR |\r\nBP540_MCLK_DIR) &\r\n~(BP540_MDIO_DATA |\r\nBP540_MCLK_DATA)));\r\n} else if (pbpctl_dev->bp_10gb) {\r\nBP10GB_WRITE_REG(pbpctl_dev, MISC_REG_SPIO,\r\n(ctrl_ext | BP10GB_MDIO_CLR | BP10GB_MCLK_CLR)\r\n& ~(BP10GB_MCLK_DIR | BP10GB_MDIO_DIR |\r\nBP10GB_MDIO_SET | BP10GB_MCLK_SET));\r\n} else if (!pbpctl_dev->bp_10g)\r\nBPCTL_BP_WRITE_REG(pbpctl_dev, CTRL_EXT, ((ctrl_ext |\r\nBPCTLI_CTRL_EXT_MCLK_DIR\r\n|\r\nBPCTLI_CTRL_EXT_MDIO_DIR)\r\n&\r\n~\r\n(BPCTLI_CTRL_EXT_MDIO_DATA\r\n|\r\nBPCTLI_CTRL_EXT_MCLK_DATA)));\r\nelse {\r\nBP10G_WRITE_REG(pbpctl_dev, EODSDP,\r\n(ctrl_ext &\r\n~(BP10G_MCLK_DATA_OUT | BP10G_MDIO_DATA_OUT)));\r\n}\r\nusec_delay(CMND_INTERVAL * 4);\r\nif ((pbpctl_dev->wdt_status == WDT_STATUS_EN) &&\r\n(pbpctl_dev->bp_ext_ver < PXG4BPFI_VER) && (addr == CMND_REG_ADDR))\r\npbpctl_dev->bypass_wdt_on_time = jiffies;\r\n#ifdef BP_SYNC_FLAG\r\nspin_unlock_irqrestore(&pbpctl_dev->bypass_wr_lock, flags);\r\n#else\r\natomic_set(&pbpctl_dev->wdt_busy, 0);\r\n#endif\r\n}\r\nstatic void write_data(bpctl_dev_t *pbpctl_dev, unsigned char value)\r\n{\r\nwrite_reg(pbpctl_dev, value, CMND_REG_ADDR);\r\n}\r\nstatic int read_reg(bpctl_dev_t *pbpctl_dev, unsigned char addr)\r\n{\r\nuint32_t ctrl_ext = 0, ctrl = 0, ctrl_value = 0;\r\nbpctl_dev_t *pbpctl_dev_c = NULL;\r\n#ifdef BP_SYNC_FLAG\r\nunsigned long flags;\r\nspin_lock_irqsave(&pbpctl_dev->bypass_wr_lock, flags);\r\n#else\r\natomic_set(&pbpctl_dev->wdt_busy, 1);\r\n#endif\r\nif (pbpctl_dev->bp_10g9) {\r\nif (!(pbpctl_dev_c = get_status_port_fn(pbpctl_dev)))\r\nreturn -1;\r\n}\r\nif (pbpctl_dev->bp_10g9) {\r\nctrl_ext = BP10G_READ_REG(pbpctl_dev, I2CCTL);\r\nctrl = BP10G_READ_REG(pbpctl_dev_c, ESDP);\r\nBP10G_WRITE_REG(pbpctl_dev, I2CCTL,\r\n(ctrl_ext & ~BP10G_MDIO_DATA_OUT9));\r\nBP10G_WRITE_REG(pbpctl_dev_c, ESDP,\r\n((ctrl | BP10G_MCLK_DIR_OUT9) &\r\n~(BP10G_MCLK_DATA_OUT9)));\r\n} else if (pbpctl_dev->bp_fiber5) {\r\nctrl_ext = BPCTL_READ_REG(pbpctl_dev, CTRL);\r\nBPCTL_BP_WRITE_REG(pbpctl_dev, CTRL, ((ctrl_ext |\r\nBPCTLI_CTRL_EXT_MCLK_DIR5\r\n|\r\nBPCTLI_CTRL_EXT_MDIO_DIR5)\r\n&\r\n~\r\n(BPCTLI_CTRL_EXT_MDIO_DATA5\r\n|\r\nBPCTLI_CTRL_EXT_MCLK_DATA5)));\r\n} else if (pbpctl_dev->bp_i80) {\r\nctrl_ext = BPCTL_READ_REG(pbpctl_dev, CTRL);\r\nctrl = BPCTL_READ_REG(pbpctl_dev, CTRL_EXT);\r\nBPCTL_BP_WRITE_REG(pbpctl_dev, CTRL, ((ctrl_ext |\r\nBPCTLI_CTRL_EXT_MDIO_DIR80)\r\n&\r\n~BPCTLI_CTRL_EXT_MDIO_DATA80));\r\nBPCTL_BP_WRITE_REG(pbpctl_dev, CTRL_EXT,\r\n((ctrl | BPCTLI_CTRL_EXT_MCLK_DIR80) &\r\n~BPCTLI_CTRL_EXT_MCLK_DATA80));\r\n} else if (pbpctl_dev->bp_540) {\r\nctrl_ext = BP10G_READ_REG(pbpctl_dev, ESDP);\r\nctrl = BP10G_READ_REG(pbpctl_dev, ESDP);\r\nBP10G_WRITE_REG(pbpctl_dev, ESDP, ((ctrl | BP540_MCLK_DIR |\r\nBP540_MDIO_DIR) &\r\n~(BP540_MDIO_DATA |\r\nBP540_MCLK_DATA)));\r\n} else if (pbpctl_dev->bp_10gb) {\r\nctrl_ext = BP10GB_READ_REG(pbpctl_dev, MISC_REG_SPIO);\r\nBP10GB_WRITE_REG(pbpctl_dev, MISC_REG_SPIO,\r\n(ctrl_ext | BP10GB_MDIO_CLR | BP10GB_MCLK_CLR)\r\n& ~(BP10GB_MCLK_DIR | BP10GB_MDIO_DIR |\r\nBP10GB_MDIO_SET | BP10GB_MCLK_SET));\r\n#if 0\r\nBP10GB_WRITE_REG(pbpctl_dev, MISC_REG_SPIO, ((ctrl_ext |\r\nBP10GB_MCLK_SET |\r\nBP10GB_MDIO_CLR))\r\n& ~(BP10GB_MCLK_CLR | BP10GB_MDIO_SET |\r\nBP10GB_MCLK_DIR | BP10GB_MDIO_DIR));\r\nctrl_ext = BP10GB_READ_REG(pbpctl_dev, MISC_REG_SPIO);\r\nprintk("2reg=%x\n", ctrl_ext);\r\n#ifdef BP_SYNC_FLAG\r\nspin_unlock_irqrestore(&pbpctl_dev->bypass_wr_lock, flags);\r\n#else\r\natomic_set(&pbpctl_dev->wdt_busy, 0);\r\n#endif\r\nreturn 0;\r\n#endif\r\n} else if (!pbpctl_dev->bp_10g) {\r\nctrl_ext = BPCTL_READ_REG(pbpctl_dev, CTRL_EXT);\r\nBPCTL_BP_WRITE_REG(pbpctl_dev, CTRL_EXT, ((ctrl_ext |\r\nBPCTLI_CTRL_EXT_MCLK_DIR\r\n|\r\nBPCTLI_CTRL_EXT_MDIO_DIR)\r\n&\r\n~\r\n(BPCTLI_CTRL_EXT_MDIO_DATA\r\n|\r\nBPCTLI_CTRL_EXT_MCLK_DATA)));\r\n} else {\r\nctrl = BP10G_READ_REG(pbpctl_dev, ESDP);\r\nctrl_ext = BP10G_READ_REG(pbpctl_dev, EODSDP);\r\nBP10G_WRITE_REG(pbpctl_dev, EODSDP,\r\n(ctrl_ext &\r\n~(BP10G_MCLK_DATA_OUT | BP10G_MDIO_DATA_OUT)));\r\n}\r\nusec_delay(CMND_INTERVAL);\r\nwrite_pulse(pbpctl_dev, ctrl_ext, SYNC_CMD_VAL, SYNC_CMD_LEN);\r\nwrite_pulse(pbpctl_dev, ctrl_ext, RD_CMD_VAL, RD_CMD_LEN);\r\nwrite_pulse(pbpctl_dev, ctrl_ext, addr, ADDR_CMD_LEN);\r\nif (pbpctl_dev->bp_10g9) {\r\nBP10G_WRITE_REG(pbpctl_dev, I2CCTL,\r\n(ctrl_ext | BP10G_MDIO_DATA_OUT9));\r\nBP10G_WRITE_REG(pbpctl_dev_c, ESDP,\r\n(ctrl | BP10G_MCLK_DATA_OUT9 |\r\nBP10G_MCLK_DIR_OUT9));\r\n} else if (pbpctl_dev->bp_fiber5) {\r\nBPCTL_BP_WRITE_REG(pbpctl_dev, CTRL, ((ctrl_ext |\r\nBPCTLI_CTRL_EXT_MCLK_DIR5\r\n|\r\nBPCTLI_CTRL_EXT_MCLK_DATA5)\r\n&\r\n~\r\n(BPCTLI_CTRL_EXT_MDIO_DIR5\r\n|\r\nBPCTLI_CTRL_EXT_MDIO_DATA5)));\r\n} else if (pbpctl_dev->bp_i80) {\r\nBPCTL_BP_WRITE_REG(pbpctl_dev, CTRL,\r\n(ctrl_ext &\r\n~(BPCTLI_CTRL_EXT_MDIO_DATA80 |\r\nBPCTLI_CTRL_EXT_MDIO_DIR80)));\r\nBPCTL_BP_WRITE_REG(pbpctl_dev, CTRL_EXT,\r\n(ctrl | BPCTLI_CTRL_EXT_MCLK_DIR80 |\r\nBPCTLI_CTRL_EXT_MCLK_DATA80));\r\n} else if (pbpctl_dev->bp_540) {\r\nBP10G_WRITE_REG(pbpctl_dev, ESDP,\r\n(((ctrl | BP540_MDIO_DIR | BP540_MCLK_DIR |\r\nBP540_MCLK_DATA) & ~BP540_MDIO_DATA)));\r\n} else if (pbpctl_dev->bp_10gb) {\r\nBP10GB_WRITE_REG(pbpctl_dev, MISC_REG_SPIO,\r\n(ctrl_ext | BP10GB_MDIO_DIR | BP10GB_MCLK_SET)\r\n& ~(BP10GB_MCLK_DIR | BP10GB_MDIO_SET |\r\nBP10GB_MDIO_CLR | BP10GB_MCLK_CLR));\r\n} else if (!pbpctl_dev->bp_10g)\r\nBPCTL_BP_WRITE_REG(pbpctl_dev, CTRL_EXT, ((ctrl_ext |\r\nBPCTLI_CTRL_EXT_MCLK_DIR\r\n|\r\nBPCTLI_CTRL_EXT_MCLK_DATA)\r\n&\r\n~\r\n(BPCTLI_CTRL_EXT_MDIO_DIR\r\n|\r\nBPCTLI_CTRL_EXT_MDIO_DATA)));\r\nelse {\r\nBP10G_WRITE_REG(pbpctl_dev, EODSDP,\r\n(ctrl_ext | BP10G_MCLK_DATA_OUT |\r\nBP10G_MDIO_DATA_OUT));\r\n}\r\nusec_delay(PULSE_TIME);\r\nctrl_value = read_pulse(pbpctl_dev, ctrl_ext, RD_DATA_LEN);\r\nif (pbpctl_dev->bp_10g9) {\r\nctrl_ext = BP10G_READ_REG(pbpctl_dev, I2CCTL);\r\nctrl = BP10G_READ_REG(pbpctl_dev_c, ESDP);\r\nBP10G_WRITE_REG(pbpctl_dev, I2CCTL,\r\n(ctrl_ext & ~BP10G_MDIO_DATA_OUT9));\r\nBP10G_WRITE_REG(pbpctl_dev_c, ESDP,\r\n((ctrl | BP10G_MCLK_DIR_OUT9) &\r\n~(BP10G_MCLK_DATA_OUT9)));\r\n} else if (pbpctl_dev->bp_fiber5) {\r\nBPCTL_BP_WRITE_REG(pbpctl_dev, CTRL, ((ctrl_ext |\r\nBPCTLI_CTRL_EXT_MCLK_DIR5\r\n|\r\nBPCTLI_CTRL_EXT_MDIO_DIR5)\r\n&\r\n~\r\n(BPCTLI_CTRL_EXT_MDIO_DATA5\r\n|\r\nBPCTLI_CTRL_EXT_MCLK_DATA5)));\r\n} else if (pbpctl_dev->bp_i80) {\r\nBPCTL_BP_WRITE_REG(pbpctl_dev, CTRL, ((ctrl_ext |\r\nBPCTLI_CTRL_EXT_MDIO_DIR80)\r\n&\r\n~BPCTLI_CTRL_EXT_MDIO_DATA80));\r\nBPCTL_BP_WRITE_REG(pbpctl_dev, CTRL_EXT,\r\n((ctrl | BPCTLI_CTRL_EXT_MCLK_DIR80) &\r\n~BPCTLI_CTRL_EXT_MCLK_DATA80));\r\n} else if (pbpctl_dev->bp_540) {\r\nctrl = BP10G_READ_REG(pbpctl_dev, ESDP);\r\nBP10G_WRITE_REG(pbpctl_dev, ESDP, ((ctrl | BP540_MCLK_DIR |\r\nBP540_MDIO_DIR) &\r\n~(BP540_MDIO_DATA |\r\nBP540_MCLK_DATA)));\r\n} else if (pbpctl_dev->bp_10gb) {\r\nctrl_ext = BP10GB_READ_REG(pbpctl_dev, MISC_REG_SPIO);\r\nBP10GB_WRITE_REG(pbpctl_dev, MISC_REG_SPIO,\r\n(ctrl_ext | BP10GB_MDIO_CLR | BP10GB_MCLK_CLR)\r\n& ~(BP10GB_MCLK_DIR | BP10GB_MDIO_DIR |\r\nBP10GB_MDIO_SET | BP10GB_MCLK_SET));\r\n} else if (!pbpctl_dev->bp_10g) {\r\nBPCTL_BP_WRITE_REG(pbpctl_dev, CTRL_EXT, ((ctrl_ext |\r\nBPCTLI_CTRL_EXT_MCLK_DIR\r\n|\r\nBPCTLI_CTRL_EXT_MDIO_DIR)\r\n&\r\n~\r\n(BPCTLI_CTRL_EXT_MDIO_DATA\r\n|\r\nBPCTLI_CTRL_EXT_MCLK_DATA)));\r\n} else {\r\nctrl = BP10G_READ_REG(pbpctl_dev, ESDP);\r\nctrl_ext = BP10G_READ_REG(pbpctl_dev, EODSDP);\r\nBP10G_WRITE_REG(pbpctl_dev, EODSDP,\r\n(ctrl_ext &\r\n~(BP10G_MCLK_DATA_OUT | BP10G_MDIO_DATA_OUT)));\r\n}\r\nusec_delay(CMND_INTERVAL * 4);\r\n#ifdef BP_SYNC_FLAG\r\nspin_unlock_irqrestore(&pbpctl_dev->bypass_wr_lock, flags);\r\n#else\r\natomic_set(&pbpctl_dev->wdt_busy, 0);\r\n#endif\r\nreturn ctrl_value;\r\n}\r\nstatic int wdt_pulse(bpctl_dev_t *pbpctl_dev)\r\n{\r\nuint32_t ctrl_ext = 0, ctrl = 0;\r\nbpctl_dev_t *pbpctl_dev_c = NULL;\r\n#ifdef BP_SYNC_FLAG\r\nunsigned long flags;\r\nspin_lock_irqsave(&pbpctl_dev->bypass_wr_lock, flags);\r\n#else\r\nif ((atomic_read(&pbpctl_dev->wdt_busy)) == 1)\r\nreturn -1;\r\n#endif\r\nif (pbpctl_dev->bp_10g9) {\r\nif (!(pbpctl_dev_c = get_status_port_fn(pbpctl_dev)))\r\nreturn -1;\r\n}\r\nif (pbpctl_dev->bp_10g9) {\r\nctrl_ext = BP10G_READ_REG(pbpctl_dev, I2CCTL);\r\nctrl = BP10G_READ_REG(pbpctl_dev_c, ESDP);\r\nBP10G_WRITE_REG(pbpctl_dev, I2CCTL,\r\n(ctrl_ext & ~BP10G_MDIO_DATA_OUT9));\r\nBP10G_WRITE_REG(pbpctl_dev_c, ESDP,\r\n((ctrl | BP10G_MCLK_DIR_OUT9) &\r\n~(BP10G_MCLK_DATA_OUT9)));\r\n} else if (pbpctl_dev->bp_fiber5) {\r\nctrl_ext = BPCTL_READ_REG(pbpctl_dev, CTRL);\r\nBPCTL_BP_WRITE_REG(pbpctl_dev, CTRL, ((ctrl_ext |\r\nBPCTLI_CTRL_EXT_MCLK_DIR5\r\n|\r\nBPCTLI_CTRL_EXT_MDIO_DIR5)\r\n&\r\n~\r\n(BPCTLI_CTRL_EXT_MDIO_DATA5\r\n|\r\nBPCTLI_CTRL_EXT_MCLK_DATA5)));\r\n} else if (pbpctl_dev->bp_i80) {\r\nctrl_ext = BPCTL_READ_REG(pbpctl_dev, CTRL);\r\nctrl = BPCTL_READ_REG(pbpctl_dev, CTRL_EXT);\r\nBPCTL_BP_WRITE_REG(pbpctl_dev, CTRL, ((ctrl_ext |\r\nBPCTLI_CTRL_EXT_MDIO_DIR80)\r\n&\r\n~BPCTLI_CTRL_EXT_MDIO_DATA80));\r\nBPCTL_BP_WRITE_REG(pbpctl_dev, CTRL_EXT,\r\n((ctrl | BPCTLI_CTRL_EXT_MCLK_DIR80) &\r\n~BPCTLI_CTRL_EXT_MCLK_DATA80));\r\n} else if (pbpctl_dev->bp_540) {\r\nctrl_ext = ctrl = BP10G_READ_REG(pbpctl_dev, ESDP);\r\nBP10G_WRITE_REG(pbpctl_dev, ESDP, ((ctrl | BP540_MCLK_DIR |\r\nBP540_MDIO_DIR) &\r\n~(BP540_MDIO_DATA |\r\nBP540_MCLK_DATA)));\r\n} else if (pbpctl_dev->bp_10gb) {\r\nctrl_ext = BP10GB_READ_REG(pbpctl_dev, MISC_REG_SPIO);\r\nBP10GB_WRITE_REG(pbpctl_dev, MISC_REG_SPIO,\r\n(ctrl_ext | BP10GB_MDIO_CLR | BP10GB_MCLK_CLR)\r\n& ~(BP10GB_MCLK_DIR | BP10GB_MDIO_DIR |\r\nBP10GB_MDIO_SET | BP10GB_MCLK_SET));\r\n} else if (!pbpctl_dev->bp_10g) {\r\nctrl_ext = BPCTL_READ_REG(pbpctl_dev, CTRL_EXT);\r\nBPCTL_BP_WRITE_REG(pbpctl_dev, CTRL_EXT, ((ctrl_ext |\r\nBPCTLI_CTRL_EXT_MCLK_DIR\r\n|\r\nBPCTLI_CTRL_EXT_MDIO_DIR)\r\n&\r\n~\r\n(BPCTLI_CTRL_EXT_MDIO_DATA\r\n|\r\nBPCTLI_CTRL_EXT_MCLK_DATA)));\r\n} else {\r\nctrl = BP10G_READ_REG(pbpctl_dev, ESDP);\r\nctrl_ext = BP10G_READ_REG(pbpctl_dev, EODSDP);\r\nBP10G_WRITE_REG(pbpctl_dev, EODSDP,\r\n(ctrl_ext &\r\n~(BP10G_MCLK_DATA_OUT | BP10G_MDIO_DATA_OUT)));\r\n}\r\nif (pbpctl_dev->bp_10g9) {\r\nBP10G_WRITE_REG(pbpctl_dev, I2CCTL,\r\n(ctrl_ext & ~BP10G_MDIO_DATA_OUT9));\r\nBP10G_WRITE_REG(pbpctl_dev_c, ESDP,\r\n(ctrl | BP10G_MCLK_DATA_OUT9 |\r\nBP10G_MCLK_DIR_OUT9));\r\n} else if (pbpctl_dev->bp_fiber5) {\r\nBPCTL_BP_WRITE_REG(pbpctl_dev, CTRL, ((ctrl_ext |\r\nBPCTLI_CTRL_EXT_MCLK_DIR5\r\n|\r\nBPCTLI_CTRL_EXT_MDIO_DIR5\r\n|\r\nBPCTLI_CTRL_EXT_MCLK_DATA5)\r\n&\r\n~\r\n(BPCTLI_CTRL_EXT_MDIO_DATA5)));\r\n} else if (pbpctl_dev->bp_i80) {\r\nBPCTL_BP_WRITE_REG(pbpctl_dev, CTRL, ((ctrl_ext |\r\nBPCTLI_CTRL_EXT_MDIO_DIR80)\r\n&\r\n~BPCTLI_CTRL_EXT_MDIO_DATA80));\r\nBPCTL_BP_WRITE_REG(pbpctl_dev, CTRL_EXT,\r\n(ctrl | BPCTLI_CTRL_EXT_MCLK_DIR80 |\r\nBPCTLI_CTRL_EXT_MCLK_DATA80));\r\n} else if (pbpctl_dev->bp_540) {\r\nBP10G_WRITE_REG(pbpctl_dev, ESDP, ((ctrl |\r\nBP540_MDIO_DIR |\r\nBP540_MCLK_DIR |\r\nBP540_MCLK_DATA) &\r\n~BP540_MDIO_DATA));\r\n} else if (pbpctl_dev->bp_10gb) {\r\nctrl_ext = BP10GB_READ_REG(pbpctl_dev, MISC_REG_SPIO);\r\nBP10GB_WRITE_REG(pbpctl_dev, MISC_REG_SPIO,\r\n(ctrl_ext | BP10GB_MDIO_CLR | BP10GB_MCLK_SET)\r\n& ~(BP10GB_MCLK_DIR | BP10GB_MDIO_DIR |\r\nBP10GB_MDIO_SET | BP10GB_MCLK_CLR));\r\n} else if (!pbpctl_dev->bp_10g)\r\nBPCTL_BP_WRITE_REG(pbpctl_dev, CTRL_EXT, ((ctrl_ext |\r\nBPCTLI_CTRL_EXT_MCLK_DIR\r\n|\r\nBPCTLI_CTRL_EXT_MDIO_DIR\r\n|\r\nBPCTLI_CTRL_EXT_MCLK_DATA)\r\n&\r\n~\r\n(BPCTLI_CTRL_EXT_MDIO_DATA)));\r\nelse {\r\nBP10G_WRITE_REG(pbpctl_dev, EODSDP,\r\n((ctrl_ext | BP10G_MCLK_DATA_OUT) &\r\n~BP10G_MDIO_DATA_OUT));\r\n}\r\nusec_delay(WDT_INTERVAL);\r\nif (pbpctl_dev->bp_10g9) {\r\nBP10G_WRITE_REG(pbpctl_dev, I2CCTL,\r\n(ctrl_ext & ~BP10G_MDIO_DATA_OUT9));\r\nBP10G_WRITE_REG(pbpctl_dev_c, ESDP,\r\n((ctrl | BP10G_MCLK_DIR_OUT9) &\r\n~(BP10G_MCLK_DATA_OUT9)));\r\n} else if (pbpctl_dev->bp_fiber5) {\r\nBPCTL_BP_WRITE_REG(pbpctl_dev, CTRL, ((ctrl_ext |\r\nBPCTLI_CTRL_EXT_MCLK_DIR5\r\n|\r\nBPCTLI_CTRL_EXT_MDIO_DIR5)\r\n&\r\n~\r\n(BPCTLI_CTRL_EXT_MCLK_DATA5\r\n|\r\nBPCTLI_CTRL_EXT_MDIO_DATA5)));\r\n} else if (pbpctl_dev->bp_i80) {\r\nBPCTL_BP_WRITE_REG(pbpctl_dev, CTRL, ((ctrl_ext |\r\nBPCTLI_CTRL_EXT_MDIO_DIR80)\r\n&\r\n~BPCTLI_CTRL_EXT_MDIO_DATA80));\r\nBPCTL_BP_WRITE_REG(pbpctl_dev, CTRL_EXT,\r\n((ctrl | BPCTLI_CTRL_EXT_MCLK_DIR80) &\r\n~BPCTLI_CTRL_EXT_MCLK_DATA80));\r\n} else if (pbpctl_dev->bp_540) {\r\nBP10G_WRITE_REG(pbpctl_dev, ESDP, ((ctrl | BP540_MCLK_DIR |\r\nBP540_MDIO_DIR) &\r\n~(BP540_MDIO_DATA |\r\nBP540_MCLK_DATA)));\r\n} else if (pbpctl_dev->bp_10gb) {\r\nctrl_ext = BP10GB_READ_REG(pbpctl_dev, MISC_REG_SPIO);\r\nBP10GB_WRITE_REG(pbpctl_dev, MISC_REG_SPIO,\r\n(ctrl_ext | BP10GB_MDIO_CLR | BP10GB_MCLK_CLR)\r\n& ~(BP10GB_MCLK_DIR | BP10GB_MDIO_DIR |\r\nBP10GB_MDIO_SET | BP10GB_MCLK_SET));\r\n} else if (!pbpctl_dev->bp_10g)\r\nBPCTL_BP_WRITE_REG(pbpctl_dev, CTRL_EXT, ((ctrl_ext |\r\nBPCTLI_CTRL_EXT_MCLK_DIR\r\n|\r\nBPCTLI_CTRL_EXT_MDIO_DIR)\r\n&\r\n~\r\n(BPCTLI_CTRL_EXT_MCLK_DATA\r\n|\r\nBPCTLI_CTRL_EXT_MDIO_DATA)));\r\nelse {\r\nBP10G_WRITE_REG(pbpctl_dev, EODSDP,\r\n(ctrl_ext &\r\n~(BP10G_MCLK_DATA_OUT | BP10G_MDIO_DATA_OUT)));\r\n}\r\nif ((pbpctl_dev->wdt_status == WDT_STATUS_EN) )\r\npbpctl_dev->bypass_wdt_on_time = jiffies;\r\n#ifdef BP_SYNC_FLAG\r\nspin_unlock_irqrestore(&pbpctl_dev->bypass_wr_lock, flags);\r\n#endif\r\nusec_delay(CMND_INTERVAL * 4);\r\nreturn 0;\r\n}\r\nstatic void data_pulse(bpctl_dev_t *pbpctl_dev, unsigned char value)\r\n{\r\nuint32_t ctrl_ext = 0;\r\n#ifdef BP_SYNC_FLAG\r\nunsigned long flags;\r\n#endif\r\nwdt_time_left(pbpctl_dev);\r\n#ifdef BP_SYNC_FLAG\r\nspin_lock_irqsave(&pbpctl_dev->bypass_wr_lock, flags);\r\n#else\r\natomic_set(&pbpctl_dev->wdt_busy, 1);\r\n#endif\r\nctrl_ext = BPCTL_READ_REG(pbpctl_dev, CTRL_EXT);\r\nBPCTL_BP_WRITE_REG(pbpctl_dev, CTRL_EXT, ((ctrl_ext |\r\nBPCTLI_CTRL_EXT_SDP6_DIR |\r\nBPCTLI_CTRL_EXT_SDP7_DIR) &\r\n~(BPCTLI_CTRL_EXT_SDP6_DATA |\r\nBPCTLI_CTRL_EXT_SDP7_DATA)));\r\nusec_delay(INIT_CMND_INTERVAL);\r\nBPCTL_BP_WRITE_REG(pbpctl_dev, CTRL_EXT, ((ctrl_ext |\r\nBPCTLI_CTRL_EXT_SDP6_DIR |\r\nBPCTLI_CTRL_EXT_SDP7_DIR |\r\nBPCTLI_CTRL_EXT_SDP6_DATA) &\r\n~\r\n(BPCTLI_CTRL_EXT_SDP7_DATA)));\r\nusec_delay(INIT_CMND_INTERVAL);\r\nwhile (value) {\r\nBPCTL_BP_WRITE_REG(pbpctl_dev, CTRL_EXT, ctrl_ext |\r\nBPCTLI_CTRL_EXT_SDP6_DIR |\r\nBPCTLI_CTRL_EXT_SDP7_DIR |\r\nBPCTLI_CTRL_EXT_SDP6_DATA |\r\nBPCTLI_CTRL_EXT_SDP7_DATA);\r\nusec_delay(PULSE_INTERVAL);\r\nBPCTL_BP_WRITE_REG(pbpctl_dev, CTRL_EXT, ((ctrl_ext |\r\nBPCTLI_CTRL_EXT_SDP6_DIR\r\n|\r\nBPCTLI_CTRL_EXT_SDP7_DIR\r\n|\r\nBPCTLI_CTRL_EXT_SDP6_DATA)\r\n&\r\n~BPCTLI_CTRL_EXT_SDP7_DATA));\r\nusec_delay(PULSE_INTERVAL);\r\nvalue--;\r\n}\r\nusec_delay(INIT_CMND_INTERVAL - PULSE_INTERVAL);\r\nBPCTL_BP_WRITE_REG(pbpctl_dev, CTRL_EXT, ((ctrl_ext |\r\nBPCTLI_CTRL_EXT_SDP6_DIR |\r\nBPCTLI_CTRL_EXT_SDP7_DIR) &\r\n~(BPCTLI_CTRL_EXT_SDP6_DATA |\r\nBPCTLI_CTRL_EXT_SDP7_DATA)));\r\nusec_delay(WDT_TIME_CNT);\r\nif (pbpctl_dev->wdt_status == WDT_STATUS_EN)\r\npbpctl_dev->bypass_wdt_on_time = jiffies;\r\n#ifdef BP_SYNC_FLAG\r\nspin_unlock_irqrestore(&pbpctl_dev->bypass_wr_lock, flags);\r\n#else\r\natomic_set(&pbpctl_dev->wdt_busy, 0);\r\n#endif\r\n}\r\nstatic int send_wdt_pulse(bpctl_dev_t *pbpctl_dev)\r\n{\r\nuint32_t ctrl_ext = 0;\r\n#ifdef BP_SYNC_FLAG\r\nunsigned long flags;\r\nspin_lock_irqsave(&pbpctl_dev->bypass_wr_lock, flags);\r\n#else\r\nif ((atomic_read(&pbpctl_dev->wdt_busy)) == 1)\r\nreturn -1;\r\n#endif\r\nwdt_time_left(pbpctl_dev);\r\nctrl_ext = BPCTL_READ_REG(pbpctl_dev, CTRL_EXT);\r\nBPCTL_BP_WRITE_REG(pbpctl_dev, CTRL_EXT, ctrl_ext |\r\nBPCTLI_CTRL_EXT_SDP7_DIR |\r\nBPCTLI_CTRL_EXT_SDP7_DATA);\r\nusec_delay(PULSE_INTERVAL);\r\nBPCTL_BP_WRITE_REG(pbpctl_dev, CTRL_EXT, ((ctrl_ext |\r\nBPCTLI_CTRL_EXT_SDP7_DIR) &\r\n~BPCTLI_CTRL_EXT_SDP7_DATA));\r\nusec_delay(PULSE_INTERVAL);\r\nif (pbpctl_dev->wdt_status == WDT_STATUS_EN)\r\npbpctl_dev->bypass_wdt_on_time = jiffies;\r\n#ifdef BP_SYNC_FLAG\r\nspin_unlock_irqrestore(&pbpctl_dev->bypass_wr_lock, flags);\r\n#endif\r\nreturn 0;\r\n}\r\nvoid send_bypass_clear_pulse(bpctl_dev_t *pbpctl_dev, unsigned int value)\r\n{\r\nuint32_t ctrl_ext = 0;\r\nctrl_ext = BPCTL_READ_REG(pbpctl_dev, CTRL_EXT);\r\nBPCTL_BP_WRITE_REG(pbpctl_dev, CTRL_EXT, ((ctrl_ext |\r\nBPCTLI_CTRL_EXT_SDP6_DIR) &\r\n~BPCTLI_CTRL_EXT_SDP6_DATA));\r\nusec_delay(PULSE_INTERVAL);\r\nwhile (value) {\r\nBPCTL_BP_WRITE_REG(pbpctl_dev, CTRL_EXT, ctrl_ext |\r\nBPCTLI_CTRL_EXT_SDP6_DIR |\r\nBPCTLI_CTRL_EXT_SDP6_DATA);\r\nusec_delay(PULSE_INTERVAL);\r\nvalue--;\r\n}\r\nBPCTL_BP_WRITE_REG(pbpctl_dev, CTRL_EXT, ((ctrl_ext |\r\nBPCTLI_CTRL_EXT_SDP6_DIR) &\r\n~BPCTLI_CTRL_EXT_SDP6_DATA));\r\nusec_delay(PULSE_INTERVAL);\r\n}\r\nint pulse_set_fn(bpctl_dev_t *pbpctl_dev, unsigned int counter)\r\n{\r\nuint32_t ctrl_ext = 0;\r\nif (!pbpctl_dev)\r\nreturn -1;\r\nctrl_ext = BPCTL_READ_REG(pbpctl_dev, CTRL_EXT);\r\nwrite_pulse_1(pbpctl_dev, ctrl_ext, counter, counter);\r\npbpctl_dev->bypass_wdt_status = 0;\r\nif (pbpctl_dev->bp_ext_ver >= PXG2BPI_VER) {\r\nwrite_pulse_1(pbpctl_dev, ctrl_ext, counter, counter);\r\n} else {\r\nwdt_time_left(pbpctl_dev);\r\nif (pbpctl_dev->wdt_status == WDT_STATUS_EN) {\r\npbpctl_dev->wdt_status = 0;\r\ndata_pulse(pbpctl_dev, counter);\r\npbpctl_dev->wdt_status = WDT_STATUS_EN;\r\npbpctl_dev->bypass_wdt_on_time = jiffies;\r\n} else\r\ndata_pulse(pbpctl_dev, counter);\r\n}\r\nreturn 0;\r\n}\r\nint zero_set_fn(bpctl_dev_t *pbpctl_dev)\r\n{\r\nuint32_t ctrl_ext = 0, ctrl_value = 0;\r\nif (!pbpctl_dev)\r\nreturn -1;\r\nif (pbpctl_dev->bp_ext_ver >= PXG2BPI_VER) {\r\nprintk("zero_set");\r\nctrl_ext = BPCTL_READ_REG(pbpctl_dev, CTRL_EXT);\r\nBPCTL_BP_WRITE_REG(pbpctl_dev, CTRL_EXT, ((ctrl_ext |\r\nBPCTLI_CTRL_EXT_MCLK_DIR)\r\n&\r\n~\r\n(BPCTLI_CTRL_EXT_MCLK_DATA\r\n|\r\nBPCTLI_CTRL_EXT_MDIO_DIR\r\n|\r\nBPCTLI_CTRL_EXT_MDIO_DATA)));\r\n}\r\nreturn ctrl_value;\r\n}\r\nint pulse_get2_fn(bpctl_dev_t *pbpctl_dev)\r\n{\r\nuint32_t ctrl_ext = 0, ctrl_value = 0;\r\nif (!pbpctl_dev)\r\nreturn -1;\r\nif (pbpctl_dev->bp_ext_ver >= PXG2BPI_VER) {\r\nprintk("pulse_get_fn\n");\r\nctrl_ext = BPCTL_READ_REG(pbpctl_dev, CTRL_EXT);\r\nctrl_value = read_pulse_2(pbpctl_dev, ctrl_ext);\r\nprintk("read:%d\n", ctrl_value);\r\n}\r\nreturn ctrl_value;\r\n}\r\nint pulse_get1_fn(bpctl_dev_t *pbpctl_dev)\r\n{\r\nuint32_t ctrl_ext = 0, ctrl_value = 0;\r\nif (!pbpctl_dev)\r\nreturn -1;\r\nif (pbpctl_dev->bp_ext_ver >= PXG2BPI_VER) {\r\nprintk("pulse_get_fn\n");\r\nctrl_ext = BPCTL_READ_REG(pbpctl_dev, CTRL_EXT);\r\nctrl_value = read_pulse_1(pbpctl_dev, ctrl_ext);\r\nprintk("read:%d\n", ctrl_value);\r\n}\r\nreturn ctrl_value;\r\n}\r\nint gpio6_set_fn(bpctl_dev_t *pbpctl_dev)\r\n{\r\nuint32_t ctrl_ext = 0;\r\nctrl_ext = BPCTL_READ_REG(pbpctl_dev, CTRL_EXT);\r\nBPCTL_BP_WRITE_REG(pbpctl_dev, CTRL_EXT, ctrl_ext |\r\nBPCTLI_CTRL_EXT_SDP6_DIR |\r\nBPCTLI_CTRL_EXT_SDP6_DATA);\r\nreturn 0;\r\n}\r\nint gpio7_set_fn(bpctl_dev_t *pbpctl_dev)\r\n{\r\nuint32_t ctrl_ext = 0;\r\nctrl_ext = BPCTL_READ_REG(pbpctl_dev, CTRL_EXT);\r\nBPCTL_BP_WRITE_REG(pbpctl_dev, CTRL_EXT, ctrl_ext |\r\nBPCTLI_CTRL_EXT_SDP7_DIR |\r\nBPCTLI_CTRL_EXT_SDP7_DATA);\r\nreturn 0;\r\n}\r\nint gpio7_clear_fn(bpctl_dev_t *pbpctl_dev)\r\n{\r\nuint32_t ctrl_ext = 0;\r\nctrl_ext = BPCTL_READ_REG(pbpctl_dev, CTRL_EXT);\r\nBPCTL_BP_WRITE_REG(pbpctl_dev, CTRL_EXT, ((ctrl_ext |\r\nBPCTLI_CTRL_EXT_SDP7_DIR) &\r\n~BPCTLI_CTRL_EXT_SDP7_DATA));\r\nreturn 0;\r\n}\r\nint gpio6_clear_fn(bpctl_dev_t *pbpctl_dev)\r\n{\r\nuint32_t ctrl_ext = 0;\r\nctrl_ext = BPCTL_READ_REG(pbpctl_dev, CTRL_EXT);\r\nBPCTL_BP_WRITE_REG(pbpctl_dev, CTRL_EXT, ((ctrl_ext |\r\nBPCTLI_CTRL_EXT_SDP6_DIR) &\r\n~BPCTLI_CTRL_EXT_SDP6_DATA));\r\nreturn 0;\r\n}\r\nstatic bpctl_dev_t *get_status_port_fn(bpctl_dev_t *pbpctl_dev)\r\n{\r\nint idx_dev = 0;\r\nif (pbpctl_dev == NULL)\r\nreturn NULL;\r\nif ((pbpctl_dev->func == 0) || (pbpctl_dev->func == 2)) {\r\nfor (idx_dev = 0;\r\n((bpctl_dev_arr[idx_dev].pdev != NULL)\r\n&& (idx_dev < device_num)); idx_dev++) {\r\nif ((bpctl_dev_arr[idx_dev].bus == pbpctl_dev->bus)\r\n&& (bpctl_dev_arr[idx_dev].slot == pbpctl_dev->slot)\r\n&& ((bpctl_dev_arr[idx_dev].func == 1)\r\n&& (pbpctl_dev->func == 0))) {\r\nreturn &(bpctl_dev_arr[idx_dev]);\r\n}\r\nif ((bpctl_dev_arr[idx_dev].bus == pbpctl_dev->bus) &&\r\n(bpctl_dev_arr[idx_dev].slot == pbpctl_dev->slot) &&\r\n((bpctl_dev_arr[idx_dev].func == 3)\r\n&& (pbpctl_dev->func == 2))) {\r\nreturn &(bpctl_dev_arr[idx_dev]);\r\n}\r\n}\r\n}\r\nreturn NULL;\r\n}\r\nstatic bpctl_dev_t *get_master_port_fn(bpctl_dev_t *pbpctl_dev)\r\n{\r\nint idx_dev = 0;\r\nif (pbpctl_dev == NULL)\r\nreturn NULL;\r\nif ((pbpctl_dev->func == 1) || (pbpctl_dev->func == 3)) {\r\nfor (idx_dev = 0;\r\n((bpctl_dev_arr[idx_dev].pdev != NULL)\r\n&& (idx_dev < device_num)); idx_dev++) {\r\nif ((bpctl_dev_arr[idx_dev].bus == pbpctl_dev->bus)\r\n&& (bpctl_dev_arr[idx_dev].slot == pbpctl_dev->slot)\r\n&& ((bpctl_dev_arr[idx_dev].func == 0)\r\n&& (pbpctl_dev->func == 1))) {\r\nreturn &(bpctl_dev_arr[idx_dev]);\r\n}\r\nif ((bpctl_dev_arr[idx_dev].bus == pbpctl_dev->bus) &&\r\n(bpctl_dev_arr[idx_dev].slot == pbpctl_dev->slot) &&\r\n((bpctl_dev_arr[idx_dev].func == 2)\r\n&& (pbpctl_dev->func == 3))) {\r\nreturn &(bpctl_dev_arr[idx_dev]);\r\n}\r\n}\r\n}\r\nreturn NULL;\r\n}\r\nstatic void write_data_port_int(bpctl_dev_t *pbpctl_dev,\r\nunsigned char ctrl_value)\r\n{\r\nuint32_t value;\r\nvalue = BPCTL_READ_REG(pbpctl_dev, CTRL);\r\nvalue |= BPCTLI_CTRL_SDP0_DIR;\r\nBPCTL_BP_WRITE_REG(pbpctl_dev, CTRL, value);\r\nvalue &= ~BPCTLI_CTRL_SDP0_DATA;\r\nvalue |= ((ctrl_value & 0x1) << BPCTLI_CTRL_SDP0_SHIFT);\r\nBPCTL_BP_WRITE_REG(pbpctl_dev, CTRL, value);\r\nvalue = (BPCTL_READ_REG(pbpctl_dev, CTRL_EXT));\r\nvalue |= BPCTLI_CTRL_EXT_SDP6_DIR;\r\nBPCTL_BP_WRITE_REG(pbpctl_dev, CTRL_EXT, value);\r\nvalue &= ~BPCTLI_CTRL_EXT_SDP6_DATA;\r\nvalue |= (((ctrl_value & 0x2) >> 1) << BPCTLI_CTRL_EXT_SDP6_SHIFT);\r\nBPCTL_BP_WRITE_REG(pbpctl_dev, CTRL_EXT, value);\r\n}\r\nstatic int write_data_int(bpctl_dev_t *pbpctl_dev, unsigned char value)\r\n{\r\nbpctl_dev_t *pbpctl_dev_b = NULL;\r\nif (!(pbpctl_dev_b = get_status_port_fn(pbpctl_dev)))\r\nreturn -1;\r\natomic_set(&pbpctl_dev->wdt_busy, 1);\r\nwrite_data_port_int(pbpctl_dev, value & 0x3);\r\nwrite_data_port_int(pbpctl_dev_b, ((value & 0xc) >> 2));\r\natomic_set(&pbpctl_dev->wdt_busy, 0);\r\nreturn 0;\r\n}\r\nstatic int wdt_pulse_int(bpctl_dev_t *pbpctl_dev)\r\n{\r\nif ((atomic_read(&pbpctl_dev->wdt_busy)) == 1)\r\nreturn -1;\r\nif ((write_data_int(pbpctl_dev, RESET_WDT_INT)) < 0)\r\nreturn -1;\r\nmsec_delay_bp(CMND_INTERVAL_INT);\r\nif ((write_data_int(pbpctl_dev, CMND_OFF_INT)) < 0)\r\nreturn -1;\r\nmsec_delay_bp(CMND_INTERVAL_INT);\r\nif (pbpctl_dev->wdt_status == WDT_STATUS_EN)\r\npbpctl_dev->bypass_wdt_on_time = jiffies;\r\nreturn 0;\r\n}\r\nint cmnd_on(bpctl_dev_t *pbpctl_dev)\r\n{\r\nint ret = BP_NOT_CAP;\r\nif (pbpctl_dev->bp_caps & SW_CTL_CAP) {\r\nif (INTEL_IF_SERIES(pbpctl_dev->subdevice))\r\nreturn 0;\r\nif (pbpctl_dev->bp_ext_ver >= PXG2BPI_VER)\r\nwrite_data(pbpctl_dev, CMND_ON);\r\nelse\r\ndata_pulse(pbpctl_dev, CMND_ON);\r\nret = 0;\r\n}\r\nreturn ret;\r\n}\r\nint cmnd_off(bpctl_dev_t *pbpctl_dev)\r\n{\r\nint ret = BP_NOT_CAP;\r\nif (pbpctl_dev->bp_caps & SW_CTL_CAP) {\r\nif (INTEL_IF_SERIES(pbpctl_dev->subdevice)) {\r\nwrite_data_int(pbpctl_dev, CMND_OFF_INT);\r\nmsec_delay_bp(CMND_INTERVAL_INT);\r\n} else if (pbpctl_dev->bp_ext_ver >= PXG2BPI_VER)\r\nwrite_data(pbpctl_dev, CMND_OFF);\r\nelse\r\ndata_pulse(pbpctl_dev, CMND_OFF);\r\nret = 0;\r\n};\r\nreturn ret;\r\n}\r\nint bypass_on(bpctl_dev_t *pbpctl_dev)\r\n{\r\nint ret = BP_NOT_CAP;\r\nif (pbpctl_dev->bp_caps & BP_CAP) {\r\nif (INTEL_IF_SERIES(pbpctl_dev->subdevice)) {\r\nwrite_data_int(pbpctl_dev, BYPASS_ON_INT);\r\nmsec_delay_bp(BYPASS_DELAY_INT);\r\npbpctl_dev->bp_status_un = 0;\r\n} else if (pbpctl_dev->bp_ext_ver >= PXG2BPI_VER) {\r\nwrite_data(pbpctl_dev, BYPASS_ON);\r\nif (pbpctl_dev->bp_ext_ver >= PXG2TBPI_VER)\r\nmsec_delay_bp(LATCH_DELAY);\r\n} else\r\ndata_pulse(pbpctl_dev, BYPASS_ON);\r\nret = 0;\r\n};\r\nreturn ret;\r\n}\r\nint bypass_off(bpctl_dev_t *pbpctl_dev)\r\n{\r\nint ret = BP_NOT_CAP;\r\nif (pbpctl_dev->bp_caps & BP_CAP) {\r\nif (INTEL_IF_SERIES(pbpctl_dev->subdevice)) {\r\nwrite_data_int(pbpctl_dev, DIS_BYPASS_CAP_INT);\r\nmsec_delay_bp(BYPASS_DELAY_INT);\r\nwrite_data_int(pbpctl_dev, PWROFF_BYPASS_ON_INT);\r\nmsec_delay_bp(BYPASS_DELAY_INT);\r\npbpctl_dev->bp_status_un = 0;\r\n} else if (pbpctl_dev->bp_ext_ver >= PXG2BPI_VER) {\r\nwrite_data(pbpctl_dev, BYPASS_OFF);\r\nif (pbpctl_dev->bp_ext_ver >= PXG2TBPI_VER)\r\nmsec_delay_bp(LATCH_DELAY);\r\n} else\r\ndata_pulse(pbpctl_dev, BYPASS_OFF);\r\nret = 0;\r\n}\r\nreturn ret;\r\n}\r\nint tap_off(bpctl_dev_t *pbpctl_dev)\r\n{\r\nint ret = BP_NOT_CAP;\r\nif ((pbpctl_dev->bp_caps & TAP_CAP)\r\n&& (pbpctl_dev->bp_ext_ver >= PXG2TBPI_VER)) {\r\nwrite_data(pbpctl_dev, TAP_OFF);\r\nmsec_delay_bp(LATCH_DELAY);\r\nret = 0;\r\n};\r\nreturn ret;\r\n}\r\nint tap_on(bpctl_dev_t *pbpctl_dev)\r\n{\r\nint ret = BP_NOT_CAP;\r\nif ((pbpctl_dev->bp_caps & TAP_CAP)\r\n&& (pbpctl_dev->bp_ext_ver >= PXG2TBPI_VER)) {\r\nwrite_data(pbpctl_dev, TAP_ON);\r\nmsec_delay_bp(LATCH_DELAY);\r\nret = 0;\r\n};\r\nreturn ret;\r\n}\r\nint disc_off(bpctl_dev_t *pbpctl_dev)\r\n{\r\nint ret = 0;\r\nif ((pbpctl_dev->bp_caps & DISC_CAP) && (pbpctl_dev->bp_ext_ver >= 0x8)) {\r\nwrite_data(pbpctl_dev, DISC_OFF);\r\nmsec_delay_bp(LATCH_DELAY);\r\n} else\r\nret = BP_NOT_CAP;\r\nreturn ret;\r\n}\r\nint disc_on(bpctl_dev_t *pbpctl_dev)\r\n{\r\nint ret = 0;\r\nif ((pbpctl_dev->bp_caps & DISC_CAP) && (pbpctl_dev->bp_ext_ver >= 0x8)) {\r\nwrite_data(pbpctl_dev, 0x85);\r\nmsec_delay_bp(LATCH_DELAY);\r\n} else\r\nret = BP_NOT_CAP;\r\nreturn ret;\r\n}\r\nint disc_port_on(bpctl_dev_t *pbpctl_dev)\r\n{\r\nint ret = 0;\r\nbpctl_dev_t *pbpctl_dev_m;\r\nif ((is_bypass_fn(pbpctl_dev)) == 1)\r\npbpctl_dev_m = pbpctl_dev;\r\nelse\r\npbpctl_dev_m = get_master_port_fn(pbpctl_dev);\r\nif (pbpctl_dev_m == NULL)\r\nreturn BP_NOT_CAP;\r\nif (pbpctl_dev_m->bp_caps_ex & DISC_PORT_CAP_EX) {\r\nif (is_bypass_fn(pbpctl_dev) == 1) {\r\nwrite_data(pbpctl_dev_m, TX_DISA);\r\n} else {\r\nwrite_data(pbpctl_dev_m, TX_DISB);\r\n}\r\nmsec_delay_bp(LATCH_DELAY);\r\n}\r\nreturn ret;\r\n}\r\nint disc_port_off(bpctl_dev_t *pbpctl_dev)\r\n{\r\nint ret = 0;\r\nbpctl_dev_t *pbpctl_dev_m;\r\nif ((is_bypass_fn(pbpctl_dev)) == 1)\r\npbpctl_dev_m = pbpctl_dev;\r\nelse\r\npbpctl_dev_m = get_master_port_fn(pbpctl_dev);\r\nif (pbpctl_dev_m == NULL)\r\nreturn BP_NOT_CAP;\r\nif (pbpctl_dev_m->bp_caps_ex & DISC_PORT_CAP_EX) {\r\nif (is_bypass_fn(pbpctl_dev) == 1)\r\nwrite_data(pbpctl_dev_m, TX_ENA);\r\nelse\r\nwrite_data(pbpctl_dev_m, TX_ENB);\r\nmsec_delay_bp(LATCH_DELAY);\r\n}\r\nreturn ret;\r\n}\r\nint tpl_hw_on(bpctl_dev_t *pbpctl_dev)\r\n{\r\nint ret = 0, ctrl = 0;\r\nbpctl_dev_t *pbpctl_dev_b = NULL;\r\nif (!(pbpctl_dev_b = get_status_port_fn(pbpctl_dev)))\r\nreturn BP_NOT_CAP;\r\nif (pbpctl_dev->bp_caps_ex & TPL2_CAP_EX) {\r\ncmnd_on(pbpctl_dev);\r\nwrite_data(pbpctl_dev, TPL2_ON);\r\nmsec_delay_bp(LATCH_DELAY + EEPROM_WR_DELAY);\r\ncmnd_off(pbpctl_dev);\r\nreturn ret;\r\n}\r\nif (TPL_IF_SERIES(pbpctl_dev->subdevice)) {\r\nctrl = BPCTL_READ_REG(pbpctl_dev_b, CTRL);\r\nBPCTL_BP_WRITE_REG(pbpctl_dev_b, CTRL,\r\n((ctrl | BPCTLI_CTRL_SWDPIO0) &\r\n~BPCTLI_CTRL_SWDPIN0));\r\n} else\r\nret = BP_NOT_CAP;\r\nreturn ret;\r\n}\r\nint tpl_hw_off(bpctl_dev_t *pbpctl_dev)\r\n{\r\nint ret = 0, ctrl = 0;\r\nbpctl_dev_t *pbpctl_dev_b = NULL;\r\nif (!(pbpctl_dev_b = get_status_port_fn(pbpctl_dev)))\r\nreturn BP_NOT_CAP;\r\nif (pbpctl_dev->bp_caps_ex & TPL2_CAP_EX) {\r\ncmnd_on(pbpctl_dev);\r\nwrite_data(pbpctl_dev, TPL2_OFF);\r\nmsec_delay_bp(LATCH_DELAY + EEPROM_WR_DELAY);\r\ncmnd_off(pbpctl_dev);\r\nreturn ret;\r\n}\r\nif (TPL_IF_SERIES(pbpctl_dev->subdevice)) {\r\nctrl = BPCTL_READ_REG(pbpctl_dev_b, CTRL);\r\nBPCTL_BP_WRITE_REG(pbpctl_dev_b, CTRL,\r\n(ctrl | BPCTLI_CTRL_SWDPIO0 |\r\nBPCTLI_CTRL_SWDPIN0));\r\n} else\r\nret = BP_NOT_CAP;\r\nreturn ret;\r\n}\r\nint wdt_off(bpctl_dev_t *pbpctl_dev)\r\n{\r\nint ret = BP_NOT_CAP;\r\nif (pbpctl_dev->bp_caps & WD_CTL_CAP) {\r\nif (INTEL_IF_SERIES(pbpctl_dev->subdevice)) {\r\nbypass_off(pbpctl_dev);\r\n} else if (pbpctl_dev->bp_ext_ver >= PXG2BPI_VER)\r\nwrite_data(pbpctl_dev, WDT_OFF);\r\nelse\r\ndata_pulse(pbpctl_dev, WDT_OFF);\r\npbpctl_dev->wdt_status = WDT_STATUS_DIS;\r\nret = 0;\r\n};\r\nreturn ret;\r\n}\r\nint wdt_on(bpctl_dev_t *pbpctl_dev, unsigned int timeout)\r\n{\r\nif (pbpctl_dev->bp_caps & WD_CTL_CAP) {\r\nunsigned int pulse = 0, temp_value = 0, temp_cnt = 0;\r\npbpctl_dev->wdt_status = 0;\r\nif (INTEL_IF_SERIES(pbpctl_dev->subdevice)) {\r\nfor (; wdt_val_array[temp_cnt]; temp_cnt++)\r\nif (timeout <= wdt_val_array[temp_cnt])\r\nbreak;\r\nif (!wdt_val_array[temp_cnt])\r\ntemp_cnt--;\r\ntimeout = wdt_val_array[temp_cnt];\r\ntemp_cnt += 0x7;\r\nwrite_data_int(pbpctl_dev, DIS_BYPASS_CAP_INT);\r\nmsec_delay_bp(BYPASS_DELAY_INT);\r\npbpctl_dev->bp_status_un = 0;\r\nwrite_data_int(pbpctl_dev, temp_cnt);\r\npbpctl_dev->bypass_wdt_on_time = jiffies;\r\nmsec_delay_bp(CMND_INTERVAL_INT);\r\npbpctl_dev->bypass_timer_interval = timeout;\r\n} else {\r\ntimeout =\r\n(timeout <\r\nTIMEOUT_UNIT ? TIMEOUT_UNIT : (timeout >\r\nWDT_TIMEOUT_MAX ?\r\nWDT_TIMEOUT_MAX :\r\ntimeout));\r\ntemp_value = timeout / 100;\r\nwhile ((temp_value >>= 1))\r\ntemp_cnt++;\r\nif (timeout > ((1 << temp_cnt) * 100))\r\ntemp_cnt++;\r\npbpctl_dev->bypass_wdt_on_time = jiffies;\r\npulse = (WDT_ON | temp_cnt);\r\nif (pbpctl_dev->bp_ext_ver == OLD_IF_VER)\r\ndata_pulse(pbpctl_dev, pulse);\r\nelse\r\nwrite_data(pbpctl_dev, pulse);\r\npbpctl_dev->bypass_timer_interval =\r\n(1 << temp_cnt) * 100;\r\n}\r\npbpctl_dev->wdt_status = WDT_STATUS_EN;\r\nreturn 0;\r\n}\r\nreturn BP_NOT_CAP;\r\n}\r\nvoid bp75_put_hw_semaphore_generic(bpctl_dev_t *pbpctl_dev)\r\n{\r\nu32 swsm;\r\nswsm = BPCTL_READ_REG(pbpctl_dev, SWSM);\r\nswsm &= ~(BPCTLI_SWSM_SMBI | BPCTLI_SWSM_SWESMBI);\r\nBPCTL_WRITE_REG(pbpctl_dev, SWSM, swsm);\r\n}\r\ns32 bp75_get_hw_semaphore_generic(bpctl_dev_t *pbpctl_dev)\r\n{\r\nu32 swsm;\r\ns32 ret_val = 0;\r\ns32 timeout = 8192 + 1;\r\ns32 i = 0;\r\nwhile (i < timeout) {\r\nswsm = BPCTL_READ_REG(pbpctl_dev, SWSM);\r\nif (!(swsm & BPCTLI_SWSM_SMBI))\r\nbreak;\r\nusec_delay(50);\r\ni++;\r\n}\r\nif (i == timeout) {\r\nprintk\r\n("bpctl_mod: Driver can't access device - SMBI bit is set.\n");\r\nret_val = -1;\r\ngoto out;\r\n}\r\nfor (i = 0; i < timeout; i++) {\r\nswsm = BPCTL_READ_REG(pbpctl_dev, SWSM);\r\nBPCTL_WRITE_REG(pbpctl_dev, SWSM, swsm | BPCTLI_SWSM_SWESMBI);\r\nif (BPCTL_READ_REG(pbpctl_dev, SWSM) & BPCTLI_SWSM_SWESMBI)\r\nbreak;\r\nusec_delay(50);\r\n}\r\nif (i == timeout) {\r\nbp75_put_hw_semaphore_generic(pbpctl_dev);\r\nprintk("bpctl_mod: Driver can't access the NVM\n");\r\nret_val = -1;\r\ngoto out;\r\n}\r\nout:\r\nreturn ret_val;\r\n}\r\nstatic void bp75_release_phy(bpctl_dev_t *pbpctl_dev)\r\n{\r\nu16 mask = BPCTLI_SWFW_PHY0_SM;\r\nu32 swfw_sync;\r\nif ((pbpctl_dev->func == 1) || (pbpctl_dev->func == 3))\r\nmask = BPCTLI_SWFW_PHY1_SM;\r\nwhile (bp75_get_hw_semaphore_generic(pbpctl_dev) != 0) ;\r\nswfw_sync = BPCTL_READ_REG(pbpctl_dev, SW_FW_SYNC);\r\nswfw_sync &= ~mask;\r\nBPCTL_WRITE_REG(pbpctl_dev, SW_FW_SYNC, swfw_sync);\r\nbp75_put_hw_semaphore_generic(pbpctl_dev);\r\n}\r\nstatic s32 bp75_acquire_phy(bpctl_dev_t *pbpctl_dev)\r\n{\r\nu16 mask = BPCTLI_SWFW_PHY0_SM;\r\nu32 swfw_sync;\r\nu32 swmask;\r\nu32 fwmask;\r\ns32 ret_val = 0;\r\ns32 i = 0, timeout = 200;\r\nif ((pbpctl_dev->func == 1) || (pbpctl_dev->func == 3))\r\nmask = BPCTLI_SWFW_PHY1_SM;\r\nswmask = mask;\r\nfwmask = mask << 16;\r\nwhile (i < timeout) {\r\nif (bp75_get_hw_semaphore_generic(pbpctl_dev)) {\r\nret_val = -1;\r\ngoto out;\r\n}\r\nswfw_sync = BPCTL_READ_REG(pbpctl_dev, SW_FW_SYNC);\r\nif (!(swfw_sync & (fwmask | swmask)))\r\nbreak;\r\nbp75_put_hw_semaphore_generic(pbpctl_dev);\r\nmdelay(5);\r\ni++;\r\n}\r\nif (i == timeout) {\r\nprintk\r\n("bpctl_mod: Driver can't access resource, SW_FW_SYNC timeout.\n");\r\nret_val = -1;\r\ngoto out;\r\n}\r\nswfw_sync |= swmask;\r\nBPCTL_WRITE_REG(pbpctl_dev, SW_FW_SYNC, swfw_sync);\r\nbp75_put_hw_semaphore_generic(pbpctl_dev);\r\nout:\r\nreturn ret_val;\r\n}\r\ns32 bp75_read_phy_reg_mdic(bpctl_dev_t *pbpctl_dev, u32 offset, u16 *data)\r\n{\r\nu32 i, mdic = 0;\r\ns32 ret_val = 0;\r\nu32 phy_addr = 1;\r\nmdic = ((offset << BPCTLI_MDIC_REG_SHIFT) |\r\n(phy_addr << BPCTLI_MDIC_PHY_SHIFT) | (BPCTLI_MDIC_OP_READ));\r\nBPCTL_WRITE_REG(pbpctl_dev, MDIC, mdic);\r\nfor (i = 0; i < (BPCTLI_GEN_POLL_TIMEOUT * 3); i++) {\r\nusec_delay(50);\r\nmdic = BPCTL_READ_REG(pbpctl_dev, MDIC);\r\nif (mdic & BPCTLI_MDIC_READY)\r\nbreak;\r\n}\r\nif (!(mdic & BPCTLI_MDIC_READY)) {\r\nprintk("bpctl_mod: MDI Read did not complete\n");\r\nret_val = -1;\r\ngoto out;\r\n}\r\nif (mdic & BPCTLI_MDIC_ERROR) {\r\nprintk("bpctl_mod: MDI Error\n");\r\nret_val = -1;\r\ngoto out;\r\n}\r\n*data = (u16) mdic;\r\nout:\r\nreturn ret_val;\r\n}\r\ns32 bp75_write_phy_reg_mdic(bpctl_dev_t *pbpctl_dev, u32 offset, u16 data)\r\n{\r\nu32 i, mdic = 0;\r\ns32 ret_val = 0;\r\nu32 phy_addr = 1;\r\nmdic = (((u32) data) |\r\n(offset << BPCTLI_MDIC_REG_SHIFT) |\r\n(phy_addr << BPCTLI_MDIC_PHY_SHIFT) | (BPCTLI_MDIC_OP_WRITE));\r\nBPCTL_WRITE_REG(pbpctl_dev, MDIC, mdic);\r\nfor (i = 0; i < (BPCTLI_GEN_POLL_TIMEOUT * 3); i++) {\r\nusec_delay(50);\r\nmdic = BPCTL_READ_REG(pbpctl_dev, MDIC);\r\nif (mdic & BPCTLI_MDIC_READY)\r\nbreak;\r\n}\r\nif (!(mdic & BPCTLI_MDIC_READY)) {\r\nprintk("bpctl_mod: MDI Write did not complete\n");\r\nret_val = -1;\r\ngoto out;\r\n}\r\nif (mdic & BPCTLI_MDIC_ERROR) {\r\nprintk("bpctl_mod: MDI Error\n");\r\nret_val = -1;\r\ngoto out;\r\n}\r\nout:\r\nreturn ret_val;\r\n}\r\nstatic s32 bp75_read_phy_reg(bpctl_dev_t *pbpctl_dev, u32 offset, u16 *data)\r\n{\r\ns32 ret_val = 0;\r\nret_val = bp75_acquire_phy(pbpctl_dev);\r\nif (ret_val)\r\ngoto out;\r\nif (offset > BPCTLI_MAX_PHY_MULTI_PAGE_REG) {\r\nret_val = bp75_write_phy_reg_mdic(pbpctl_dev,\r\nBPCTLI_IGP01E1000_PHY_PAGE_SELECT,\r\n(u16) offset);\r\nif (ret_val)\r\ngoto release;\r\n}\r\nret_val =\r\nbp75_read_phy_reg_mdic(pbpctl_dev,\r\nBPCTLI_MAX_PHY_REG_ADDRESS & offset, data);\r\nrelease:\r\nbp75_release_phy(pbpctl_dev);\r\nout:\r\nreturn ret_val;\r\n}\r\nstatic s32 bp75_write_phy_reg(bpctl_dev_t *pbpctl_dev, u32 offset, u16 data)\r\n{\r\ns32 ret_val = 0;\r\nret_val = bp75_acquire_phy(pbpctl_dev);\r\nif (ret_val)\r\ngoto out;\r\nif (offset > BPCTLI_MAX_PHY_MULTI_PAGE_REG) {\r\nret_val = bp75_write_phy_reg_mdic(pbpctl_dev,\r\nBPCTLI_IGP01E1000_PHY_PAGE_SELECT,\r\n(u16) offset);\r\nif (ret_val)\r\ngoto release;\r\n}\r\nret_val =\r\nbp75_write_phy_reg_mdic(pbpctl_dev,\r\nBPCTLI_MAX_PHY_REG_ADDRESS & offset, data);\r\nrelease:\r\nbp75_release_phy(pbpctl_dev);\r\nout:\r\nreturn ret_val;\r\n}\r\nstatic int set_tx(bpctl_dev_t *pbpctl_dev, int tx_state)\r\n{\r\nint ret = 0, ctrl = 0;\r\nbpctl_dev_t *pbpctl_dev_m;\r\nif ((is_bypass_fn(pbpctl_dev)) == 1)\r\npbpctl_dev_m = pbpctl_dev;\r\nelse\r\npbpctl_dev_m = get_master_port_fn(pbpctl_dev);\r\nif (pbpctl_dev_m == NULL)\r\nreturn BP_NOT_CAP;\r\nif (pbpctl_dev_m->bp_caps_ex & DISC_PORT_CAP_EX) {\r\nctrl = BPCTL_READ_REG(pbpctl_dev, CTRL);\r\nif (!tx_state) {\r\nif (pbpctl_dev->bp_540) {\r\nctrl = BP10G_READ_REG(pbpctl_dev, ESDP);\r\nBP10G_WRITE_REG(pbpctl_dev, ESDP,\r\n(ctrl | BP10G_SDP1_DIR |\r\nBP10G_SDP1_DATA));\r\n} else {\r\nBPCTL_BP_WRITE_REG(pbpctl_dev, CTRL,\r\n(ctrl | BPCTLI_CTRL_SDP1_DIR\r\n| BPCTLI_CTRL_SWDPIN1));\r\n}\r\n} else {\r\nif (pbpctl_dev->bp_540) {\r\nctrl = BP10G_READ_REG(pbpctl_dev, ESDP);\r\nBP10G_WRITE_REG(pbpctl_dev, ESDP,\r\n((ctrl | BP10G_SDP1_DIR) &\r\n~BP10G_SDP1_DATA));\r\n} else {\r\nBPCTL_BP_WRITE_REG(pbpctl_dev, CTRL,\r\n((ctrl |\r\nBPCTLI_CTRL_SDP1_DIR) &\r\n~BPCTLI_CTRL_SWDPIN1));\r\n}\r\nreturn ret;\r\n}\r\n} else if (pbpctl_dev->bp_caps & TX_CTL_CAP) {\r\nif (PEG5_IF_SERIES(pbpctl_dev->subdevice)) {\r\nif (tx_state) {\r\nuint16_t mii_reg;\r\nif (!\r\n(ret =\r\nbp75_read_phy_reg(pbpctl_dev,\r\nBPCTLI_PHY_CONTROL,\r\n&mii_reg))) {\r\nif (mii_reg & BPCTLI_MII_CR_POWER_DOWN) {\r\nret =\r\nbp75_write_phy_reg\r\n(pbpctl_dev,\r\nBPCTLI_PHY_CONTROL,\r\nmii_reg &\r\n~BPCTLI_MII_CR_POWER_DOWN);\r\n}\r\n}\r\n} else {\r\nuint16_t mii_reg;\r\nif (!\r\n(ret =\r\nbp75_read_phy_reg(pbpctl_dev,\r\nBPCTLI_PHY_CONTROL,\r\n&mii_reg))) {\r\nmii_reg |= BPCTLI_MII_CR_POWER_DOWN;\r\nret =\r\nbp75_write_phy_reg(pbpctl_dev,\r\nBPCTLI_PHY_CONTROL,\r\nmii_reg);\r\n}\r\n}\r\n}\r\nif (pbpctl_dev->bp_fiber5) {\r\nctrl = BPCTL_READ_REG(pbpctl_dev, CTRL_EXT);\r\n} else if (pbpctl_dev->bp_10gb)\r\nctrl = BP10GB_READ_REG(pbpctl_dev, MISC_REG_GPIO);\r\nelse if (!pbpctl_dev->bp_10g)\r\nctrl = BPCTL_READ_REG(pbpctl_dev, CTRL);\r\nelse\r\nctrl = BP10G_READ_REG(pbpctl_dev, ESDP);\r\nif (!tx_state)\r\nif (pbpctl_dev->bp_10g9) {\r\nBP10G_WRITE_REG(pbpctl_dev, ESDP,\r\n(ctrl | BP10G_SDP3_DATA |\r\nBP10G_SDP3_DIR));\r\n} else if (pbpctl_dev->bp_fiber5) {\r\nBPCTL_BP_WRITE_REG(pbpctl_dev, CTRL_EXT,\r\n(ctrl |\r\nBPCTLI_CTRL_EXT_SDP6_DIR |\r\nBPCTLI_CTRL_EXT_SDP6_DATA));\r\n} else if (pbpctl_dev->bp_10gb) {\r\nif ((pbpctl_dev->func == 1)\r\n|| (pbpctl_dev->func == 3))\r\nBP10GB_WRITE_REG(pbpctl_dev,\r\nMISC_REG_GPIO,\r\n(ctrl |\r\nBP10GB_GPIO0_SET_P1) &\r\n~(BP10GB_GPIO0_CLR_P1 |\r\nBP10GB_GPIO0_OE_P1));\r\nelse\r\nBP10GB_WRITE_REG(pbpctl_dev,\r\nMISC_REG_GPIO,\r\n(ctrl |\r\nBP10GB_GPIO0_OE_P0 |\r\nBP10GB_GPIO0_SET_P0));\r\n} else if (pbpctl_dev->bp_i80) {\r\nBPCTL_BP_WRITE_REG(pbpctl_dev, CTRL,\r\n(ctrl | BPCTLI_CTRL_SDP1_DIR\r\n| BPCTLI_CTRL_SWDPIN1));\r\n} else if (pbpctl_dev->bp_540) {\r\nctrl = BP10G_READ_REG(pbpctl_dev, ESDP);\r\nBP10G_WRITE_REG(pbpctl_dev, ESDP,\r\n(ctrl | BP10G_SDP1_DIR |\r\nBP10G_SDP1_DATA));\r\n}\r\nelse if (!pbpctl_dev->bp_10g)\r\nBPCTL_BP_WRITE_REG(pbpctl_dev, CTRL,\r\n(ctrl | BPCTLI_CTRL_SWDPIO0 |\r\nBPCTLI_CTRL_SWDPIN0));\r\nelse\r\nBP10G_WRITE_REG(pbpctl_dev, ESDP,\r\n(ctrl | BP10G_SDP0_DATA |\r\nBP10G_SDP0_DIR));\r\nelse {\r\nif (pbpctl_dev->bp_10g9) {\r\nBP10G_WRITE_REG(pbpctl_dev, ESDP,\r\n((ctrl | BP10G_SDP3_DIR) &\r\n~BP10G_SDP3_DATA));\r\n} else if (pbpctl_dev->bp_fiber5) {\r\nBPCTL_BP_WRITE_REG(pbpctl_dev, CTRL_EXT,\r\n((ctrl |\r\nBPCTLI_CTRL_EXT_SDP6_DIR) &\r\n~BPCTLI_CTRL_EXT_SDP6_DATA));\r\n} else if (pbpctl_dev->bp_10gb) {\r\nif ((bpctl_dev_arr->func == 1)\r\n|| (bpctl_dev_arr->func == 3))\r\nBP10GB_WRITE_REG(pbpctl_dev,\r\nMISC_REG_GPIO,\r\n(ctrl |\r\nBP10GB_GPIO0_CLR_P1) &\r\n~(BP10GB_GPIO0_SET_P1 |\r\nBP10GB_GPIO0_OE_P1));\r\nelse\r\nBP10GB_WRITE_REG(pbpctl_dev,\r\nMISC_REG_GPIO,\r\n(ctrl |\r\nBP10GB_GPIO0_OE_P0 |\r\nBP10GB_GPIO0_CLR_P0));\r\n} else if (pbpctl_dev->bp_i80) {\r\nBPCTL_BP_WRITE_REG(pbpctl_dev, CTRL,\r\n((ctrl |\r\nBPCTLI_CTRL_SDP1_DIR) &\r\n~BPCTLI_CTRL_SWDPIN1));\r\n} else if (pbpctl_dev->bp_540) {\r\nctrl = BP10G_READ_REG(pbpctl_dev, ESDP);\r\nBP10G_WRITE_REG(pbpctl_dev, ESDP,\r\n((ctrl | BP10G_SDP1_DIR) &\r\n~BP10G_SDP1_DATA));\r\n}\r\nelse if (!pbpctl_dev->bp_10g) {\r\nBPCTL_BP_WRITE_REG(pbpctl_dev, CTRL,\r\n((ctrl | BPCTLI_CTRL_SWDPIO0)\r\n& ~BPCTLI_CTRL_SWDPIN0));\r\nif (!PEGF_IF_SERIES(pbpctl_dev->subdevice)) {\r\nBPCTL_BP_WRITE_REG(pbpctl_dev, CTRL,\r\n(ctrl &\r\n~\r\n(BPCTLI_CTRL_SDP0_DATA\r\n|\r\nBPCTLI_CTRL_SDP0_DIR)));\r\n}\r\n} else\r\nBP10G_WRITE_REG(pbpctl_dev, ESDP,\r\n((ctrl | BP10G_SDP0_DIR) &\r\n~BP10G_SDP0_DATA));\r\n}\r\n} else\r\nret = BP_NOT_CAP;\r\nreturn ret;\r\n}\r\nstatic int set_bp_force_link(bpctl_dev_t *pbpctl_dev, int tx_state)\r\n{\r\nint ret = 0, ctrl = 0;\r\nif (DBI_IF_SERIES(pbpctl_dev->subdevice)) {\r\nif ((pbpctl_dev->bp_10g) || (pbpctl_dev->bp_10g9)) {\r\nctrl = BPCTL_READ_REG(pbpctl_dev, CTRL);\r\nif (!tx_state)\r\nBP10G_WRITE_REG(pbpctl_dev, ESDP,\r\nctrl & ~BP10G_SDP1_DIR);\r\nelse\r\nBP10G_WRITE_REG(pbpctl_dev, ESDP,\r\n((ctrl | BP10G_SDP1_DIR) &\r\n~BP10G_SDP1_DATA));\r\nreturn ret;\r\n}\r\n}\r\nreturn BP_NOT_CAP;\r\n}\r\nint reset_cont(bpctl_dev_t *pbpctl_dev)\r\n{\r\nint ret = BP_NOT_CAP;\r\nif (pbpctl_dev->bp_caps & SW_CTL_CAP) {\r\nif (INTEL_IF_SERIES(pbpctl_dev->subdevice))\r\nreturn BP_NOT_CAP;\r\nif (pbpctl_dev->bp_ext_ver >= PXG2BPI_VER)\r\nwrite_data(pbpctl_dev, RESET_CONT);\r\nelse\r\ndata_pulse(pbpctl_dev, RESET_CONT);\r\nret = 0;\r\n};\r\nreturn ret;\r\n}\r\nint dis_bypass_cap(bpctl_dev_t *pbpctl_dev)\r\n{\r\nif (pbpctl_dev->bp_caps & BP_DIS_CAP) {\r\nif (INTEL_IF_SERIES(pbpctl_dev->subdevice)) {\r\nwrite_data_int(pbpctl_dev, DIS_BYPASS_CAP_INT);\r\nmsec_delay_bp(BYPASS_DELAY_INT);\r\n} else {\r\nwrite_data(pbpctl_dev, BYPASS_OFF);\r\nmsec_delay_bp(LATCH_DELAY);\r\nwrite_data(pbpctl_dev, DIS_BYPASS_CAP);\r\nmsec_delay_bp(BYPASS_CAP_DELAY);\r\n}\r\nreturn 0;\r\n}\r\nreturn BP_NOT_CAP;\r\n}\r\nint en_bypass_cap(bpctl_dev_t *pbpctl_dev)\r\n{\r\nif (pbpctl_dev->bp_caps & BP_DIS_CAP) {\r\nif (INTEL_IF_SERIES(pbpctl_dev->subdevice)) {\r\nwrite_data_int(pbpctl_dev, PWROFF_BYPASS_ON_INT);\r\nmsec_delay_bp(BYPASS_DELAY_INT);\r\n} else {\r\nwrite_data(pbpctl_dev, EN_BYPASS_CAP);\r\nmsec_delay_bp(BYPASS_CAP_DELAY);\r\n}\r\nreturn 0;\r\n}\r\nreturn BP_NOT_CAP;\r\n}\r\nint bypass_state_pwron(bpctl_dev_t *pbpctl_dev)\r\n{\r\nif (pbpctl_dev->bp_caps & BP_PWUP_CTL_CAP) {\r\nwrite_data(pbpctl_dev, BYPASS_STATE_PWRON);\r\nif (pbpctl_dev->bp_ext_ver == PXG2BPI_VER)\r\nmsec_delay_bp(DFLT_PWRON_DELAY);\r\nelse\r\nmsec_delay_bp(LATCH_DELAY + EEPROM_WR_DELAY);\r\nreturn 0;\r\n}\r\nreturn BP_NOT_CAP;\r\n}\r\nint normal_state_pwron(bpctl_dev_t *pbpctl_dev)\r\n{\r\nif ((pbpctl_dev->bp_caps & BP_PWUP_CTL_CAP)\r\n|| (pbpctl_dev->bp_caps & TAP_PWUP_CTL_CAP)) {\r\nwrite_data(pbpctl_dev, NORMAL_STATE_PWRON);\r\nif (pbpctl_dev->bp_ext_ver == PXG2BPI_VER)\r\nmsec_delay_bp(DFLT_PWRON_DELAY);\r\nelse\r\nmsec_delay_bp(LATCH_DELAY + EEPROM_WR_DELAY);\r\nreturn 0;\r\n}\r\nreturn BP_NOT_CAP;\r\n}\r\nint bypass_state_pwroff(bpctl_dev_t *pbpctl_dev)\r\n{\r\nif (pbpctl_dev->bp_caps & BP_PWOFF_CTL_CAP) {\r\nwrite_data(pbpctl_dev, BYPASS_STATE_PWROFF);\r\nmsec_delay_bp(LATCH_DELAY + EEPROM_WR_DELAY);\r\nreturn 0;\r\n}\r\nreturn BP_NOT_CAP;\r\n}\r\nint normal_state_pwroff(bpctl_dev_t *pbpctl_dev)\r\n{\r\nif ((pbpctl_dev->bp_caps & BP_PWOFF_CTL_CAP)) {\r\nwrite_data(pbpctl_dev, NORMAL_STATE_PWROFF);\r\nmsec_delay_bp(LATCH_DELAY + EEPROM_WR_DELAY);\r\nreturn 0;\r\n}\r\nreturn BP_NOT_CAP;\r\n}\r\nint tap_state_pwron(bpctl_dev_t *pbpctl_dev)\r\n{\r\nif (pbpctl_dev->bp_caps & TAP_PWUP_CTL_CAP) {\r\nwrite_data(pbpctl_dev, TAP_STATE_PWRON);\r\nmsec_delay_bp(LATCH_DELAY + EEPROM_WR_DELAY);\r\nreturn 0;\r\n}\r\nreturn BP_NOT_CAP;\r\n}\r\nint dis_tap_cap(bpctl_dev_t *pbpctl_dev)\r\n{\r\nif (pbpctl_dev->bp_caps & TAP_DIS_CAP) {\r\nwrite_data(pbpctl_dev, DIS_TAP_CAP);\r\nmsec_delay_bp(BYPASS_CAP_DELAY);\r\nreturn 0;\r\n}\r\nreturn BP_NOT_CAP;\r\n}\r\nint en_tap_cap(bpctl_dev_t *pbpctl_dev)\r\n{\r\nif (pbpctl_dev->bp_caps & TAP_DIS_CAP) {\r\nwrite_data(pbpctl_dev, EN_TAP_CAP);\r\nmsec_delay_bp(BYPASS_CAP_DELAY);\r\nreturn 0;\r\n}\r\nreturn BP_NOT_CAP;\r\n}\r\nint disc_state_pwron(bpctl_dev_t *pbpctl_dev)\r\n{\r\nif (pbpctl_dev->bp_caps & DISC_PWUP_CTL_CAP) {\r\nif (pbpctl_dev->bp_ext_ver >= 0x8) {\r\nwrite_data(pbpctl_dev, DISC_STATE_PWRON);\r\nmsec_delay_bp(LATCH_DELAY + EEPROM_WR_DELAY);\r\nreturn BP_OK;\r\n}\r\n}\r\nreturn BP_NOT_CAP;\r\n}\r\nint dis_disc_cap(bpctl_dev_t *pbpctl_dev)\r\n{\r\nif (pbpctl_dev->bp_caps & DISC_DIS_CAP) {\r\nif (pbpctl_dev->bp_ext_ver >= 0x8) {\r\nwrite_data(pbpctl_dev, DIS_DISC_CAP);\r\nmsec_delay_bp(BYPASS_CAP_DELAY);\r\nreturn BP_OK;\r\n}\r\n}\r\nreturn BP_NOT_CAP;\r\n}\r\nint disc_port_state_pwron(bpctl_dev_t *pbpctl_dev)\r\n{\r\nint ret = 0;\r\nbpctl_dev_t *pbpctl_dev_m;\r\nreturn BP_NOT_CAP;\r\nif ((is_bypass_fn(pbpctl_dev)) == 1)\r\npbpctl_dev_m = pbpctl_dev;\r\nelse\r\npbpctl_dev_m = get_master_port_fn(pbpctl_dev);\r\nif (pbpctl_dev_m == NULL)\r\nreturn BP_NOT_CAP;\r\nif (pbpctl_dev_m->bp_caps_ex & DISC_PORT_CAP_EX) {\r\nif (is_bypass_fn(pbpctl_dev) == 1)\r\nwrite_data(pbpctl_dev_m, TX_DISA_PWRUP);\r\nelse\r\nwrite_data(pbpctl_dev_m, TX_DISB_PWRUP);\r\nmsec_delay_bp(LATCH_DELAY);\r\n}\r\nreturn ret;\r\n}\r\nint normal_port_state_pwron(bpctl_dev_t *pbpctl_dev)\r\n{\r\nint ret = 0;\r\nbpctl_dev_t *pbpctl_dev_m;\r\nreturn BP_NOT_CAP;\r\nif ((is_bypass_fn(pbpctl_dev)) == 1)\r\npbpctl_dev_m = pbpctl_dev;\r\nelse\r\npbpctl_dev_m = get_master_port_fn(pbpctl_dev);\r\nif (pbpctl_dev_m == NULL)\r\nreturn BP_NOT_CAP;\r\nif (pbpctl_dev_m->bp_caps_ex & DISC_PORT_CAP_EX) {\r\nif (is_bypass_fn(pbpctl_dev) == 1)\r\nwrite_data(pbpctl_dev_m, TX_ENA_PWRUP);\r\nelse\r\nwrite_data(pbpctl_dev_m, TX_ENB_PWRUP);\r\nmsec_delay_bp(LATCH_DELAY);\r\n}\r\nreturn ret;\r\n}\r\nint en_disc_cap(bpctl_dev_t *pbpctl_dev)\r\n{\r\nif (pbpctl_dev->bp_caps & DISC_DIS_CAP) {\r\nif (pbpctl_dev->bp_ext_ver >= 0x8) {\r\nwrite_data(pbpctl_dev, EN_DISC_CAP);\r\nmsec_delay_bp(BYPASS_CAP_DELAY);\r\nreturn BP_OK;\r\n}\r\n}\r\nreturn BP_NOT_CAP;\r\n}\r\nint std_nic_on(bpctl_dev_t *pbpctl_dev)\r\n{\r\nif (pbpctl_dev->bp_caps & STD_NIC_CAP) {\r\nif (INTEL_IF_SERIES(pbpctl_dev->subdevice)) {\r\nwrite_data_int(pbpctl_dev, DIS_BYPASS_CAP_INT);\r\nmsec_delay_bp(BYPASS_DELAY_INT);\r\npbpctl_dev->bp_status_un = 0;\r\nreturn BP_OK;\r\n}\r\nif (pbpctl_dev->bp_ext_ver >= 0x8) {\r\nwrite_data(pbpctl_dev, STD_NIC_ON);\r\nmsec_delay_bp(BYPASS_CAP_DELAY);\r\nreturn BP_OK;\r\n}\r\nif (pbpctl_dev->bp_ext_ver >= PXG2BPI_VER) {\r\nwdt_off(pbpctl_dev);\r\nif (pbpctl_dev->bp_caps & BP_CAP) {\r\nwrite_data(pbpctl_dev, BYPASS_OFF);\r\nmsec_delay_bp(LATCH_DELAY);\r\n}\r\nif (pbpctl_dev->bp_caps & TAP_CAP) {\r\nwrite_data(pbpctl_dev, TAP_OFF);\r\nmsec_delay_bp(LATCH_DELAY);\r\n}\r\nwrite_data(pbpctl_dev, NORMAL_STATE_PWRON);\r\nif (pbpctl_dev->bp_ext_ver == PXG2BPI_VER)\r\nmsec_delay_bp(DFLT_PWRON_DELAY);\r\nelse\r\nmsec_delay_bp(LATCH_DELAY + EEPROM_WR_DELAY);\r\nif (pbpctl_dev->bp_caps & BP_DIS_CAP) {\r\nwrite_data(pbpctl_dev, DIS_BYPASS_CAP);\r\nmsec_delay_bp(BYPASS_CAP_DELAY);\r\n}\r\nif (pbpctl_dev->bp_caps & TAP_DIS_CAP) {\r\nwrite_data(pbpctl_dev, DIS_TAP_CAP);\r\nmsec_delay_bp(BYPASS_CAP_DELAY);\r\n}\r\nreturn 0;\r\n}\r\n}\r\nreturn BP_NOT_CAP;\r\n}\r\nint std_nic_off(bpctl_dev_t *pbpctl_dev)\r\n{\r\nif (pbpctl_dev->bp_caps & STD_NIC_CAP) {\r\nif (INTEL_IF_SERIES(pbpctl_dev->subdevice)) {\r\nwrite_data_int(pbpctl_dev, PWROFF_BYPASS_ON_INT);\r\nmsec_delay_bp(BYPASS_DELAY_INT);\r\nreturn BP_OK;\r\n}\r\nif (pbpctl_dev->bp_ext_ver >= 0x8) {\r\nwrite_data(pbpctl_dev, STD_NIC_OFF);\r\nmsec_delay_bp(BYPASS_CAP_DELAY);\r\nreturn BP_OK;\r\n}\r\nif (pbpctl_dev->bp_ext_ver >= PXG2BPI_VER) {\r\nif (pbpctl_dev->bp_caps & TAP_PWUP_CTL_CAP) {\r\nwrite_data(pbpctl_dev, TAP_STATE_PWRON);\r\nmsec_delay_bp(LATCH_DELAY + EEPROM_WR_DELAY);\r\n}\r\nif (pbpctl_dev->bp_caps & BP_PWUP_CTL_CAP) {\r\nwrite_data(pbpctl_dev, BYPASS_STATE_PWRON);\r\nif (pbpctl_dev->bp_ext_ver > PXG2BPI_VER)\r\nmsec_delay_bp(LATCH_DELAY +\r\nEEPROM_WR_DELAY);\r\nelse\r\nmsec_delay_bp(DFLT_PWRON_DELAY);\r\n}\r\nif (pbpctl_dev->bp_caps & TAP_DIS_CAP) {\r\nwrite_data(pbpctl_dev, EN_TAP_CAP);\r\nmsec_delay_bp(BYPASS_CAP_DELAY);\r\n}\r\nif (pbpctl_dev->bp_caps & DISC_DIS_CAP) {\r\nwrite_data(pbpctl_dev, EN_DISC_CAP);\r\nmsec_delay_bp(BYPASS_CAP_DELAY);\r\n}\r\nif (pbpctl_dev->bp_caps & BP_DIS_CAP) {\r\nwrite_data(pbpctl_dev, EN_BYPASS_CAP);\r\nmsec_delay_bp(BYPASS_CAP_DELAY);\r\n}\r\nreturn 0;\r\n}\r\n}\r\nreturn BP_NOT_CAP;\r\n}\r\nint wdt_time_left(bpctl_dev_t *pbpctl_dev)\r\n{\r\nunsigned long curr_time = jiffies, delta_time = 0, wdt_on_time =\r\npbpctl_dev->bypass_wdt_on_time, delta_time_msec = 0;\r\nint time_left = 0;\r\nswitch (pbpctl_dev->wdt_status) {\r\ncase WDT_STATUS_DIS:\r\ntime_left = 0;\r\nbreak;\r\ncase WDT_STATUS_EN:\r\ndelta_time =\r\n(curr_time >=\r\nwdt_on_time) ? (curr_time - wdt_on_time) : (~wdt_on_time +\r\ncurr_time);\r\ndelta_time_msec = jiffies_to_msecs(delta_time);\r\ntime_left = pbpctl_dev->bypass_timer_interval - delta_time_msec;\r\nif (time_left < 0) {\r\ntime_left = -1;\r\npbpctl_dev->wdt_status = WDT_STATUS_EXP;\r\n}\r\nbreak;\r\ncase WDT_STATUS_EXP:\r\ntime_left = -1;\r\nbreak;\r\n}\r\nreturn time_left;\r\n}\r\nstatic int wdt_timer(bpctl_dev_t *pbpctl_dev, int *time_left)\r\n{\r\nint ret = 0;\r\nif (pbpctl_dev->bp_caps & WD_CTL_CAP) {\r\n{\r\nif (pbpctl_dev->wdt_status == WDT_STATUS_UNKNOWN)\r\nret = BP_NOT_CAP;\r\nelse\r\n*time_left = wdt_time_left(pbpctl_dev);\r\n}\r\n} else\r\nret = BP_NOT_CAP;\r\nreturn ret;\r\n}\r\nstatic int wdt_timer_reload(bpctl_dev_t *pbpctl_dev)\r\n{\r\nint ret = 0;\r\nif ((pbpctl_dev->bp_caps & WD_CTL_CAP) &&\r\n(pbpctl_dev->wdt_status != WDT_STATUS_UNKNOWN)) {\r\nif (pbpctl_dev->wdt_status == WDT_STATUS_DIS)\r\nreturn 0;\r\nif (pbpctl_dev->bp_ext_ver >= PXG2BPI_VER)\r\nret = wdt_pulse(pbpctl_dev);\r\nelse if (INTEL_IF_SERIES(pbpctl_dev->subdevice))\r\nret = wdt_pulse_int(pbpctl_dev);\r\nelse\r\nret = send_wdt_pulse(pbpctl_dev);\r\nreturn 1;\r\n}\r\nreturn BP_NOT_CAP;\r\n}\r\nstatic void wd_reset_timer(unsigned long param)\r\n{\r\nbpctl_dev_t *pbpctl_dev = (bpctl_dev_t *) param;\r\n#ifdef BP_SELF_TEST\r\nstruct sk_buff *skb_tmp;\r\n#endif\r\nif ((pbpctl_dev->bp_ext_ver >= PXG2BPI_VER) &&\r\n((atomic_read(&pbpctl_dev->wdt_busy)) == 1)) {\r\nmod_timer(&pbpctl_dev->bp_timer, jiffies + 1);\r\nreturn;\r\n}\r\n#ifdef BP_SELF_TEST\r\nif (pbpctl_dev->bp_self_test_flag == 1) {\r\nskb_tmp = dev_alloc_skb(BPTEST_DATA_LEN + 2);\r\nif ((skb_tmp) && (pbpctl_dev->ndev) && (pbpctl_dev->bp_tx_data)) {\r\nmemcpy(skb_put(skb_tmp, BPTEST_DATA_LEN),\r\npbpctl_dev->bp_tx_data, BPTEST_DATA_LEN);\r\nskb_tmp->dev = pbpctl_dev->ndev;\r\nskb_tmp->protocol =\r\neth_type_trans(skb_tmp, pbpctl_dev->ndev);\r\nskb_tmp->ip_summed = CHECKSUM_UNNECESSARY;\r\nnetif_receive_skb(skb_tmp);\r\ngoto bp_timer_reload;\r\nreturn;\r\n}\r\n}\r\n#endif\r\nwdt_timer_reload(pbpctl_dev);\r\n#ifdef BP_SELF_TEST\r\nbp_timer_reload:\r\n#endif\r\nif (pbpctl_dev->reset_time) {\r\nmod_timer(&pbpctl_dev->bp_timer,\r\njiffies + (HZ * pbpctl_dev->reset_time) / 1000);\r\n}\r\n}\r\nint bp_wait_at_pwup_en(bpctl_dev_t *pbpctl_dev)\r\n{\r\nif (pbpctl_dev->bp_caps & SW_CTL_CAP) {\r\nif (pbpctl_dev->bp_ext_ver >= BP_FW_EXT_VER8) {\r\nwrite_data(pbpctl_dev, BP_WAIT_AT_PWUP_EN);\r\nmsec_delay_bp(LATCH_DELAY + EEPROM_WR_DELAY);\r\nreturn BP_OK;\r\n}\r\n}\r\nreturn BP_NOT_CAP;\r\n}\r\nint bp_wait_at_pwup_dis(bpctl_dev_t *pbpctl_dev)\r\n{\r\nif (pbpctl_dev->bp_caps & SW_CTL_CAP) {\r\nif (pbpctl_dev->bp_ext_ver >= BP_FW_EXT_VER8) {\r\nwrite_data(pbpctl_dev, BP_WAIT_AT_PWUP_DIS);\r\nmsec_delay_bp(LATCH_DELAY + EEPROM_WR_DELAY);\r\nreturn BP_OK;\r\n}\r\n}\r\nreturn BP_NOT_CAP;\r\n}\r\nint bp_hw_reset_en(bpctl_dev_t *pbpctl_dev)\r\n{\r\nif (pbpctl_dev->bp_caps & SW_CTL_CAP) {\r\nif (pbpctl_dev->bp_ext_ver >= BP_FW_EXT_VER8) {\r\nwrite_data(pbpctl_dev, BP_HW_RESET_EN);\r\nmsec_delay_bp(LATCH_DELAY + EEPROM_WR_DELAY);\r\nreturn BP_OK;\r\n}\r\n}\r\nreturn BP_NOT_CAP;\r\n}\r\nint bp_hw_reset_dis(bpctl_dev_t *pbpctl_dev)\r\n{\r\nif (pbpctl_dev->bp_caps & SW_CTL_CAP) {\r\nif (pbpctl_dev->bp_ext_ver >= BP_FW_EXT_VER8) {\r\nwrite_data(pbpctl_dev, BP_HW_RESET_DIS);\r\nmsec_delay_bp(LATCH_DELAY + EEPROM_WR_DELAY);\r\nreturn BP_OK;\r\n}\r\n}\r\nreturn BP_NOT_CAP;\r\n}\r\nint wdt_exp_mode(bpctl_dev_t *pbpctl_dev, int mode)\r\n{\r\nuint32_t status_reg = 0, status_reg1 = 0;\r\nif ((pbpctl_dev->bp_caps & (TAP_STATUS_CAP | DISC_CAP)) &&\r\n(pbpctl_dev->bp_caps & BP_CAP)) {\r\nif (pbpctl_dev->bp_ext_ver >= PXE2TBPI_VER) {\r\nif ((pbpctl_dev->bp_ext_ver >= 0x8) &&\r\n(mode == 2) && (pbpctl_dev->bp_caps & DISC_CAP)) {\r\nstatus_reg1 =\r\nread_reg(pbpctl_dev, STATUS_DISC_REG_ADDR);\r\nif (!(status_reg1 & WDTE_DISC_BPN_MASK))\r\nwrite_reg(pbpctl_dev,\r\nstatus_reg1 |\r\nWDTE_DISC_BPN_MASK,\r\nSTATUS_DISC_REG_ADDR);\r\nreturn BP_OK;\r\n}\r\n}\r\nstatus_reg = read_reg(pbpctl_dev, STATUS_TAP_REG_ADDR);\r\nif ((mode == 0) && (pbpctl_dev->bp_caps & BP_CAP)) {\r\nif (pbpctl_dev->bp_ext_ver >= 0x8) {\r\nstatus_reg1 =\r\nread_reg(pbpctl_dev, STATUS_DISC_REG_ADDR);\r\nif (status_reg1 & WDTE_DISC_BPN_MASK)\r\nwrite_reg(pbpctl_dev,\r\nstatus_reg1 &\r\n~WDTE_DISC_BPN_MASK,\r\nSTATUS_DISC_REG_ADDR);\r\n}\r\nif (status_reg & WDTE_TAP_BPN_MASK)\r\nwrite_reg(pbpctl_dev,\r\nstatus_reg & ~WDTE_TAP_BPN_MASK,\r\nSTATUS_TAP_REG_ADDR);\r\nreturn BP_OK;\r\n} else if ((mode == 1) && (pbpctl_dev->bp_caps & TAP_CAP)) {\r\nif (!(status_reg & WDTE_TAP_BPN_MASK))\r\nwrite_reg(pbpctl_dev,\r\nstatus_reg | WDTE_TAP_BPN_MASK,\r\nSTATUS_TAP_REG_ADDR);\r\nreturn BP_OK;\r\n}\r\n}\r\nreturn BP_NOT_CAP;\r\n}\r\nint bypass_fw_ver(bpctl_dev_t *pbpctl_dev)\r\n{\r\nif (is_bypass_fn(pbpctl_dev))\r\nreturn read_reg(pbpctl_dev, VER_REG_ADDR);\r\nelse\r\nreturn BP_NOT_CAP;\r\n}\r\nint bypass_sign_check(bpctl_dev_t *pbpctl_dev)\r\n{\r\nif (is_bypass_fn(pbpctl_dev))\r\nreturn (((read_reg(pbpctl_dev, PIC_SIGN_REG_ADDR)) ==\r\nPIC_SIGN_VALUE) ? 1 : 0);\r\nelse\r\nreturn BP_NOT_CAP;\r\n}\r\nstatic int tx_status(bpctl_dev_t *pbpctl_dev)\r\n{\r\nuint32_t ctrl = 0;\r\nbpctl_dev_t *pbpctl_dev_m;\r\nif ((is_bypass_fn(pbpctl_dev)) == 1)\r\npbpctl_dev_m = pbpctl_dev;\r\nelse\r\npbpctl_dev_m = get_master_port_fn(pbpctl_dev);\r\nif (pbpctl_dev_m == NULL)\r\nreturn BP_NOT_CAP;\r\nif (pbpctl_dev_m->bp_caps_ex & DISC_PORT_CAP_EX) {\r\nctrl = BPCTL_READ_REG(pbpctl_dev, CTRL);\r\nif (pbpctl_dev->bp_i80)\r\nreturn ((ctrl & BPCTLI_CTRL_SWDPIN1) != 0 ? 0 : 1);\r\nif (pbpctl_dev->bp_540) {\r\nctrl = BP10G_READ_REG(pbpctl_dev, ESDP);\r\nreturn ((ctrl & BP10G_SDP1_DATA) != 0 ? 0 : 1);\r\n}\r\n}\r\nif (pbpctl_dev->bp_caps & TX_CTL_CAP) {\r\nif (PEG5_IF_SERIES(pbpctl_dev->subdevice)) {\r\nuint16_t mii_reg;\r\nif (!\r\n(bp75_read_phy_reg\r\n(pbpctl_dev, BPCTLI_PHY_CONTROL, &mii_reg))) {\r\nif (mii_reg & BPCTLI_MII_CR_POWER_DOWN)\r\nreturn 0;\r\nelse\r\nreturn 1;\r\n}\r\nreturn -1;\r\n}\r\nif (pbpctl_dev->bp_10g9) {\r\nreturn ((BP10G_READ_REG(pbpctl_dev, ESDP) &\r\nBP10G_SDP3_DATA) != 0 ? 0 : 1);\r\n} else if (pbpctl_dev->bp_fiber5) {\r\nctrl = BPCTL_READ_REG(pbpctl_dev, CTRL_EXT);\r\nif (ctrl & BPCTLI_CTRL_EXT_SDP6_DATA)\r\nreturn 0;\r\nreturn 1;\r\n} else if (pbpctl_dev->bp_10gb) {\r\nctrl = BP10GB_READ_REG(pbpctl_dev, MISC_REG_GPIO);\r\nBP10GB_WRITE_REG(pbpctl_dev, MISC_REG_GPIO,\r\n(ctrl | BP10GB_GPIO0_OE_P1) &\r\n~(BP10GB_GPIO0_SET_P1 |\r\nBP10GB_GPIO0_CLR_P1));\r\nif ((pbpctl_dev->func == 1) || (pbpctl_dev->func == 3))\r\nreturn (((BP10GB_READ_REG\r\n(pbpctl_dev,\r\nMISC_REG_GPIO)) & BP10GB_GPIO0_P1) !=\r\n0 ? 0 : 1);\r\nelse\r\nreturn (((BP10GB_READ_REG\r\n(pbpctl_dev,\r\nMISC_REG_GPIO)) & BP10GB_GPIO0_P0) !=\r\n0 ? 0 : 1);\r\n}\r\nif (!pbpctl_dev->bp_10g) {\r\nctrl = BPCTL_READ_REG(pbpctl_dev, CTRL);\r\nif (pbpctl_dev->bp_i80)\r\nreturn ((ctrl & BPCTLI_CTRL_SWDPIN1) !=\r\n0 ? 0 : 1);\r\nif (pbpctl_dev->bp_540) {\r\nctrl = BP10G_READ_REG(pbpctl_dev, ESDP);\r\nreturn ((ctrl & BP10G_SDP1_DATA) != 0 ? 0 : 1);\r\n}\r\nreturn ((ctrl & BPCTLI_CTRL_SWDPIN0) != 0 ? 0 : 1);\r\n} else\r\nreturn ((BP10G_READ_REG(pbpctl_dev, ESDP) &\r\nBP10G_SDP0_DATA) != 0 ? 0 : 1);\r\n}\r\nreturn BP_NOT_CAP;\r\n}\r\nstatic int bp_force_link_status(bpctl_dev_t *pbpctl_dev)\r\n{\r\nif (DBI_IF_SERIES(pbpctl_dev->subdevice)) {\r\nif ((pbpctl_dev->bp_10g) || (pbpctl_dev->bp_10g9)) {\r\nreturn ((BP10G_READ_REG(pbpctl_dev, ESDP) &\r\nBP10G_SDP1_DIR) != 0 ? 1 : 0);\r\n}\r\n}\r\nreturn BP_NOT_CAP;\r\n}\r\nint bypass_from_last_read(bpctl_dev_t *pbpctl_dev)\r\n{\r\nuint32_t ctrl_ext = 0;\r\nbpctl_dev_t *pbpctl_dev_b = NULL;\r\nif ((pbpctl_dev->bp_caps & SW_CTL_CAP)\r\n&& (pbpctl_dev_b = get_status_port_fn(pbpctl_dev))) {\r\nctrl_ext = BPCTL_READ_REG(pbpctl_dev_b, CTRL_EXT);\r\nBPCTL_BP_WRITE_REG(pbpctl_dev_b, CTRL_EXT,\r\n(ctrl_ext & ~BPCTLI_CTRL_EXT_SDP7_DIR));\r\nctrl_ext = BPCTL_READ_REG(pbpctl_dev_b, CTRL_EXT);\r\nif (ctrl_ext & BPCTLI_CTRL_EXT_SDP7_DATA)\r\nreturn 0;\r\nreturn 1;\r\n} else\r\nreturn BP_NOT_CAP;\r\n}\r\nint bypass_status_clear(bpctl_dev_t *pbpctl_dev)\r\n{\r\nbpctl_dev_t *pbpctl_dev_b = NULL;\r\nif ((pbpctl_dev->bp_caps & SW_CTL_CAP)\r\n&& (pbpctl_dev_b = get_status_port_fn(pbpctl_dev))) {\r\nsend_bypass_clear_pulse(pbpctl_dev_b, 1);\r\nreturn 0;\r\n} else\r\nreturn BP_NOT_CAP;\r\n}\r\nint bypass_flag_status(bpctl_dev_t *pbpctl_dev)\r\n{\r\nif ((pbpctl_dev->bp_caps & BP_CAP)) {\r\nif (pbpctl_dev->bp_ext_ver >= PXG2BPI_VER) {\r\nreturn ((((read_reg(pbpctl_dev, STATUS_REG_ADDR)) &\r\nBYPASS_FLAG_MASK) ==\r\nBYPASS_FLAG_MASK) ? 1 : 0);\r\n}\r\n}\r\nreturn BP_NOT_CAP;\r\n}\r\nint bypass_flag_status_clear(bpctl_dev_t *pbpctl_dev)\r\n{\r\nif (pbpctl_dev->bp_caps & BP_CAP) {\r\nif (pbpctl_dev->bp_ext_ver >= PXG2BPI_VER) {\r\nuint32_t status_reg = 0;\r\nstatus_reg = read_reg(pbpctl_dev, STATUS_REG_ADDR);\r\nwrite_reg(pbpctl_dev, status_reg & ~BYPASS_FLAG_MASK,\r\nSTATUS_REG_ADDR);\r\nreturn 0;\r\n}\r\n}\r\nreturn BP_NOT_CAP;\r\n}\r\nint bypass_change_status(bpctl_dev_t *pbpctl_dev)\r\n{\r\nint ret = BP_NOT_CAP;\r\nif (pbpctl_dev->bp_caps & BP_STATUS_CHANGE_CAP) {\r\nif (pbpctl_dev->bp_ext_ver >= 0x8) {\r\nret = bypass_flag_status(pbpctl_dev);\r\nbypass_flag_status_clear(pbpctl_dev);\r\n} else if (pbpctl_dev->bp_ext_ver >= PXG2BPI_VER) {\r\nret = bypass_flag_status(pbpctl_dev);\r\nbypass_flag_status_clear(pbpctl_dev);\r\n} else {\r\nret = bypass_from_last_read(pbpctl_dev);\r\nbypass_status_clear(pbpctl_dev);\r\n}\r\n}\r\nreturn ret;\r\n}\r\nint bypass_off_status(bpctl_dev_t *pbpctl_dev)\r\n{\r\nif (pbpctl_dev->bp_caps & BP_CAP) {\r\nif (pbpctl_dev->bp_ext_ver >= PXG2BPI_VER) {\r\nreturn ((((read_reg(pbpctl_dev, STATUS_REG_ADDR)) &\r\nBYPASS_OFF_MASK) == BYPASS_OFF_MASK) ? 1 : 0);\r\n}\r\n}\r\nreturn BP_NOT_CAP;\r\n}\r\nstatic int bypass_status(bpctl_dev_t *pbpctl_dev)\r\n{\r\nu32 ctrl_ext = 0;\r\nif (pbpctl_dev->bp_caps & BP_CAP) {\r\nbpctl_dev_t *pbpctl_dev_b = NULL;\r\nif (!(pbpctl_dev_b = get_status_port_fn(pbpctl_dev)))\r\nreturn BP_NOT_CAP;\r\nif (INTEL_IF_SERIES(pbpctl_dev->subdevice)) {\r\nif (!pbpctl_dev->bp_status_un)\r\nreturn (((BPCTL_READ_REG\r\n(pbpctl_dev_b,\r\nCTRL_EXT)) &\r\nBPCTLI_CTRL_EXT_SDP7_DATA) !=\r\n0 ? 1 : 0);\r\nelse\r\nreturn BP_NOT_CAP;\r\n}\r\nif (pbpctl_dev->bp_ext_ver >= 0x8) {\r\nif (pbpctl_dev->bp_10g9) {\r\nctrl_ext = BP10G_READ_REG(pbpctl_dev_b, I2CCTL);\r\nBP10G_WRITE_REG(pbpctl_dev_b, I2CCTL,\r\n(ctrl_ext | BP10G_I2C_CLK_OUT));\r\nreturn ((BP10G_READ_REG(pbpctl_dev_b, I2CCTL) &\r\nBP10G_I2C_CLK_IN) != 0 ? 0 : 1);\r\n} else if (pbpctl_dev->bp_540) {\r\nreturn (((BP10G_READ_REG(pbpctl_dev_b, ESDP)) &\r\nBP10G_SDP0_DATA) != 0 ? 0 : 1);\r\n}\r\nelse if ((pbpctl_dev->bp_fiber5)\r\n|| (pbpctl_dev->bp_i80)) {\r\nreturn (((BPCTL_READ_REG(pbpctl_dev_b, CTRL)) &\r\nBPCTLI_CTRL_SWDPIN0) != 0 ? 0 : 1);\r\n} else if (pbpctl_dev->bp_10gb) {\r\nctrl_ext =\r\nBP10GB_READ_REG(pbpctl_dev, MISC_REG_GPIO);\r\nBP10GB_WRITE_REG(pbpctl_dev, MISC_REG_GPIO,\r\n(ctrl_ext | BP10GB_GPIO3_OE_P0)\r\n& ~(BP10GB_GPIO3_SET_P0 |\r\nBP10GB_GPIO3_CLR_P0));\r\nreturn (((BP10GB_READ_REG\r\n(pbpctl_dev,\r\nMISC_REG_GPIO)) & BP10GB_GPIO3_P0) !=\r\n0 ? 0 : 1);\r\n}\r\nelse if (!pbpctl_dev->bp_10g)\r\nreturn (((BPCTL_READ_REG\r\n(pbpctl_dev_b,\r\nCTRL_EXT)) &\r\nBPCTLI_CTRL_EXT_SDP7_DATA) !=\r\n0 ? 0 : 1);\r\nelse {\r\nctrl_ext = BP10G_READ_REG(pbpctl_dev_b, EODSDP);\r\nBP10G_WRITE_REG(pbpctl_dev_b, EODSDP,\r\n(ctrl_ext |\r\nBP10G_SDP7_DATA_OUT));\r\nreturn ((BP10G_READ_REG(pbpctl_dev_b, EODSDP) &\r\nBP10G_SDP7_DATA_IN) != 0 ? 0 : 1);\r\n}\r\n} else if (pbpctl_dev->media_type == bp_copper) {\r\nreturn (((BPCTL_READ_REG(pbpctl_dev_b, CTRL)) &\r\nBPCTLI_CTRL_SWDPIN1) != 0 ? 1 : 0);\r\n} else {\r\nif ((bypass_status_clear(pbpctl_dev)) >= 0)\r\nreturn bypass_from_last_read(pbpctl_dev);\r\n}\r\n}\r\nreturn BP_NOT_CAP;\r\n}\r\nint default_pwron_status(bpctl_dev_t *pbpctl_dev)\r\n{\r\nif (pbpctl_dev->bp_caps & SW_CTL_CAP) {\r\nif (pbpctl_dev->bp_caps & BP_PWUP_CTL_CAP) {\r\nif (pbpctl_dev->bp_ext_ver >= PXG2BPI_VER) {\r\nreturn ((((read_reg\r\n(pbpctl_dev,\r\nSTATUS_REG_ADDR)) & DFLT_PWRON_MASK)\r\n== DFLT_PWRON_MASK) ? 0 : 1);\r\n}\r\n}\r\n}\r\nreturn BP_NOT_CAP;\r\n}\r\nstatic int default_pwroff_status(bpctl_dev_t *pbpctl_dev)\r\n{\r\nif ((pbpctl_dev->bp_caps & SW_CTL_CAP)\r\n&& (pbpctl_dev->bp_caps & BP_PWOFF_CTL_CAP)) {\r\nreturn ((((read_reg(pbpctl_dev, STATUS_REG_ADDR)) &\r\nDFLT_PWROFF_MASK) == DFLT_PWROFF_MASK) ? 0 : 1);\r\n}\r\nreturn BP_NOT_CAP;\r\n}\r\nint dis_bypass_cap_status(bpctl_dev_t *pbpctl_dev)\r\n{\r\nif (pbpctl_dev->bp_caps & BP_DIS_CAP) {\r\nif (pbpctl_dev->bp_ext_ver >= PXG2BPI_VER) {\r\nreturn ((((read_reg(pbpctl_dev, STATUS_REG_ADDR)) &\r\nDIS_BYPASS_CAP_MASK) ==\r\nDIS_BYPASS_CAP_MASK) ? 1 : 0);\r\n}\r\n}\r\nreturn BP_NOT_CAP;\r\n}\r\nint cmd_en_status(bpctl_dev_t *pbpctl_dev)\r\n{\r\nif (pbpctl_dev->bp_caps & SW_CTL_CAP) {\r\nif (pbpctl_dev->bp_ext_ver >= PXG2BPI_VER) {\r\nreturn ((((read_reg(pbpctl_dev, STATUS_REG_ADDR)) &\r\nCMND_EN_MASK) == CMND_EN_MASK) ? 1 : 0);\r\n}\r\n}\r\nreturn BP_NOT_CAP;\r\n}\r\nint wdt_en_status(bpctl_dev_t *pbpctl_dev)\r\n{\r\nif (pbpctl_dev->bp_caps & WD_CTL_CAP) {\r\nif (pbpctl_dev->bp_ext_ver >= PXG2BPI_VER) {\r\nreturn ((((read_reg(pbpctl_dev, STATUS_REG_ADDR)) &\r\nWDT_EN_MASK) == WDT_EN_MASK) ? 1 : 0);\r\n}\r\n}\r\nreturn BP_NOT_CAP;\r\n}\r\nint wdt_programmed(bpctl_dev_t *pbpctl_dev, int *timeout)\r\n{\r\nint ret = 0;\r\nif (pbpctl_dev->bp_caps & WD_CTL_CAP) {\r\nif (pbpctl_dev->bp_ext_ver >= PXG2BPI_VER) {\r\nif ((read_reg(pbpctl_dev, STATUS_REG_ADDR)) &\r\nWDT_EN_MASK) {\r\nu8 wdt_val;\r\nwdt_val = read_reg(pbpctl_dev, WDT_REG_ADDR);\r\n*timeout = (1 << wdt_val) * 100;\r\n} else\r\n*timeout = 0;\r\n} else {\r\nint curr_wdt_status = pbpctl_dev->wdt_status;\r\nif (curr_wdt_status == WDT_STATUS_UNKNOWN)\r\n*timeout = -1;\r\nelse\r\n*timeout =\r\ncurr_wdt_status ==\r\n0 ? 0 : pbpctl_dev->bypass_timer_interval;\r\n};\r\n} else\r\nret = BP_NOT_CAP;\r\nreturn ret;\r\n}\r\nint bypass_support(bpctl_dev_t *pbpctl_dev)\r\n{\r\nint ret = 0;\r\nif (pbpctl_dev->bp_caps & SW_CTL_CAP) {\r\nif (pbpctl_dev->bp_ext_ver >= PXG2TBPI_VER) {\r\nret =\r\n((((read_reg(pbpctl_dev, PRODUCT_CAP_REG_ADDR)) &\r\nBYPASS_SUPPORT_MASK) ==\r\nBYPASS_SUPPORT_MASK) ? 1 : 0);\r\n} else if (pbpctl_dev->bp_ext_ver == PXG2BPI_VER)\r\nret = 1;\r\n} else\r\nret = BP_NOT_CAP;\r\nreturn ret;\r\n}\r\nint tap_support(bpctl_dev_t *pbpctl_dev)\r\n{\r\nint ret = 0;\r\nif (pbpctl_dev->bp_caps & SW_CTL_CAP) {\r\nif (pbpctl_dev->bp_ext_ver >= PXG2TBPI_VER) {\r\nret =\r\n((((read_reg(pbpctl_dev, PRODUCT_CAP_REG_ADDR)) &\r\nTAP_SUPPORT_MASK) == TAP_SUPPORT_MASK) ? 1 : 0);\r\n} else if (pbpctl_dev->bp_ext_ver == PXG2BPI_VER)\r\nret = 0;\r\n} else\r\nret = BP_NOT_CAP;\r\nreturn ret;\r\n}\r\nint normal_support(bpctl_dev_t *pbpctl_dev)\r\n{\r\nint ret = BP_NOT_CAP;\r\nif (pbpctl_dev->bp_caps & SW_CTL_CAP) {\r\nif (pbpctl_dev->bp_ext_ver >= PXG2TBPI_VER) {\r\nret =\r\n((((read_reg(pbpctl_dev, PRODUCT_CAP_REG_ADDR)) &\r\nNORMAL_UNSUPPORT_MASK) ==\r\nNORMAL_UNSUPPORT_MASK) ? 0 : 1);\r\n} else\r\nret = 1;\r\n};\r\nreturn ret;\r\n}\r\nint get_bp_prod_caps(bpctl_dev_t *pbpctl_dev)\r\n{\r\nif ((pbpctl_dev->bp_caps & SW_CTL_CAP) &&\r\n(pbpctl_dev->bp_ext_ver >= PXG2TBPI_VER))\r\nreturn read_reg(pbpctl_dev, PRODUCT_CAP_REG_ADDR);\r\nreturn BP_NOT_CAP;\r\n}\r\nint tap_flag_status(bpctl_dev_t *pbpctl_dev)\r\n{\r\nif (pbpctl_dev->bp_caps & TAP_STATUS_CAP) {\r\nif (pbpctl_dev->bp_ext_ver >= PXG2TBPI_VER)\r\nreturn ((((read_reg(pbpctl_dev, STATUS_TAP_REG_ADDR)) &\r\nTAP_FLAG_MASK) == TAP_FLAG_MASK) ? 1 : 0);\r\n}\r\nreturn BP_NOT_CAP;\r\n}\r\nint tap_flag_status_clear(bpctl_dev_t *pbpctl_dev)\r\n{\r\nuint32_t status_reg = 0;\r\nif (pbpctl_dev->bp_caps & TAP_STATUS_CAP) {\r\nif (pbpctl_dev->bp_ext_ver >= PXG2TBPI_VER) {\r\nstatus_reg = read_reg(pbpctl_dev, STATUS_TAP_REG_ADDR);\r\nwrite_reg(pbpctl_dev, status_reg & ~TAP_FLAG_MASK,\r\nSTATUS_TAP_REG_ADDR);\r\nreturn 0;\r\n}\r\n}\r\nreturn BP_NOT_CAP;\r\n}\r\nint tap_change_status(bpctl_dev_t *pbpctl_dev)\r\n{\r\nint ret = BP_NOT_CAP;\r\nif (pbpctl_dev->bp_ext_ver >= PXG2TBPI_VER) {\r\nif (pbpctl_dev->bp_caps & TAP_CAP) {\r\nif (pbpctl_dev->bp_caps & BP_CAP) {\r\nret = tap_flag_status(pbpctl_dev);\r\ntap_flag_status_clear(pbpctl_dev);\r\n} else {\r\nret = bypass_from_last_read(pbpctl_dev);\r\nbypass_status_clear(pbpctl_dev);\r\n}\r\n}\r\n}\r\nreturn ret;\r\n}\r\nint tap_off_status(bpctl_dev_t *pbpctl_dev)\r\n{\r\nif (pbpctl_dev->bp_caps & TAP_CAP) {\r\nif (pbpctl_dev->bp_ext_ver >= PXG2TBPI_VER)\r\nreturn ((((read_reg(pbpctl_dev, STATUS_TAP_REG_ADDR)) &\r\nTAP_OFF_MASK) == TAP_OFF_MASK) ? 1 : 0);\r\n}\r\nreturn BP_NOT_CAP;\r\n}\r\nint tap_status(bpctl_dev_t *pbpctl_dev)\r\n{\r\nu32 ctrl_ext = 0;\r\nif (pbpctl_dev->bp_caps & TAP_CAP) {\r\nbpctl_dev_t *pbpctl_dev_b = NULL;\r\nif (!(pbpctl_dev_b = get_status_port_fn(pbpctl_dev)))\r\nreturn BP_NOT_CAP;\r\nif (pbpctl_dev->bp_ext_ver >= 0x8) {\r\nif (!pbpctl_dev->bp_10g)\r\nreturn (((BPCTL_READ_REG\r\n(pbpctl_dev_b,\r\nCTRL_EXT)) &\r\nBPCTLI_CTRL_EXT_SDP6_DATA) !=\r\n0 ? 0 : 1);\r\nelse {\r\nctrl_ext = BP10G_READ_REG(pbpctl_dev_b, EODSDP);\r\nBP10G_WRITE_REG(pbpctl_dev_b, EODSDP,\r\n(ctrl_ext |\r\nBP10G_SDP6_DATA_OUT));\r\nreturn ((BP10G_READ_REG(pbpctl_dev_b, EODSDP) &\r\nBP10G_SDP6_DATA_IN) != 0 ? 0 : 1);\r\n}\r\n} else if (pbpctl_dev->media_type == bp_copper)\r\nreturn (((BPCTL_READ_REG(pbpctl_dev, CTRL)) &\r\nBPCTLI_CTRL_SWDPIN0) != 0 ? 1 : 0);\r\nelse {\r\nif ((bypass_status_clear(pbpctl_dev)) >= 0)\r\nreturn bypass_from_last_read(pbpctl_dev);\r\n}\r\n}\r\nreturn BP_NOT_CAP;\r\n}\r\nint default_pwron_tap_status(bpctl_dev_t *pbpctl_dev)\r\n{\r\nif (pbpctl_dev->bp_caps & TAP_PWUP_CTL_CAP) {\r\nif (pbpctl_dev->bp_ext_ver >= PXG2TBPI_VER)\r\nreturn ((((read_reg(pbpctl_dev, STATUS_TAP_REG_ADDR)) &\r\nDFLT_PWRON_TAP_MASK) ==\r\nDFLT_PWRON_TAP_MASK) ? 1 : 0);\r\n}\r\nreturn BP_NOT_CAP;\r\n}\r\nint dis_tap_cap_status(bpctl_dev_t *pbpctl_dev)\r\n{\r\nif (pbpctl_dev->bp_caps & TAP_PWUP_CTL_CAP) {\r\nif (pbpctl_dev->bp_ext_ver >= PXG2TBPI_VER)\r\nreturn ((((read_reg(pbpctl_dev, STATUS_TAP_REG_ADDR)) &\r\nDIS_TAP_CAP_MASK) ==\r\nDIS_TAP_CAP_MASK) ? 1 : 0);\r\n}\r\nreturn BP_NOT_CAP;\r\n}\r\nint disc_flag_status(bpctl_dev_t *pbpctl_dev)\r\n{\r\nif (pbpctl_dev->bp_caps & DISC_CAP) {\r\nif (pbpctl_dev->bp_ext_ver >= 0x8)\r\nreturn ((((read_reg(pbpctl_dev, STATUS_DISC_REG_ADDR)) &\r\nDISC_FLAG_MASK) == DISC_FLAG_MASK) ? 1 : 0);\r\n}\r\nreturn BP_NOT_CAP;\r\n}\r\nint disc_flag_status_clear(bpctl_dev_t *pbpctl_dev)\r\n{\r\nuint32_t status_reg = 0;\r\nif (pbpctl_dev->bp_caps & DISC_CAP) {\r\nif (pbpctl_dev->bp_ext_ver >= 0x8) {\r\nstatus_reg = read_reg(pbpctl_dev, STATUS_DISC_REG_ADDR);\r\nwrite_reg(pbpctl_dev, status_reg & ~DISC_FLAG_MASK,\r\nSTATUS_DISC_REG_ADDR);\r\nreturn BP_OK;\r\n}\r\n}\r\nreturn BP_NOT_CAP;\r\n}\r\nint disc_change_status(bpctl_dev_t *pbpctl_dev)\r\n{\r\nint ret = BP_NOT_CAP;\r\nif (pbpctl_dev->bp_caps & DISC_CAP) {\r\nret = disc_flag_status(pbpctl_dev);\r\ndisc_flag_status_clear(pbpctl_dev);\r\nreturn ret;\r\n}\r\nreturn BP_NOT_CAP;\r\n}\r\nint disc_off_status(bpctl_dev_t *pbpctl_dev)\r\n{\r\nbpctl_dev_t *pbpctl_dev_b = NULL;\r\nu32 ctrl_ext = 0;\r\nif (pbpctl_dev->bp_caps & DISC_CAP) {\r\nif (!(pbpctl_dev_b = get_status_port_fn(pbpctl_dev)))\r\nreturn BP_NOT_CAP;\r\nif (DISCF_IF_SERIES(pbpctl_dev->subdevice))\r\nreturn ((((read_reg(pbpctl_dev, STATUS_DISC_REG_ADDR)) &\r\nDISC_OFF_MASK) == DISC_OFF_MASK) ? 1 : 0);\r\nif (pbpctl_dev->bp_i80) {\r\nreturn (((BPCTL_READ_REG(pbpctl_dev_b, CTRL_EXT)) &\r\nBPCTLI_CTRL_EXT_SDP6_DATA) != 0 ? 1 : 0);\r\n}\r\nif (pbpctl_dev->bp_540) {\r\nctrl_ext = BP10G_READ_REG(pbpctl_dev_b, ESDP);\r\nreturn ((BP10G_READ_REG(pbpctl_dev_b, ESDP) &\r\nBP10G_SDP2_DATA) != 0 ? 1 : 0);\r\n}\r\nif (pbpctl_dev->media_type == bp_copper) {\r\n#if 0\r\nreturn ((((read_reg(pbpctl_dev, STATUS_DISC_REG_ADDR)) &\r\nDISC_OFF_MASK) == DISC_OFF_MASK) ? 1 : 0);\r\n#endif\r\nif (!pbpctl_dev->bp_10g)\r\nreturn (((BPCTL_READ_REG(pbpctl_dev_b, CTRL)) &\r\nBPCTLI_CTRL_SWDPIN1) != 0 ? 1 : 0);\r\nelse\r\nreturn ((BP10G_READ_REG(pbpctl_dev_b, ESDP) &\r\nBP10G_SDP1_DATA) != 0 ? 1 : 0);\r\n} else {\r\nif (pbpctl_dev->bp_10g9) {\r\nctrl_ext = BP10G_READ_REG(pbpctl_dev_b, I2CCTL);\r\nBP10G_WRITE_REG(pbpctl_dev_b, I2CCTL,\r\n(ctrl_ext |\r\nBP10G_I2C_DATA_OUT));\r\nreturn ((BP10G_READ_REG(pbpctl_dev_b, I2CCTL) &\r\nBP10G_I2C_DATA_IN) != 0 ? 1 : 0);\r\n} else if (pbpctl_dev->bp_fiber5) {\r\nreturn (((BPCTL_READ_REG(pbpctl_dev_b, CTRL)) &\r\nBPCTLI_CTRL_SWDPIN1) != 0 ? 1 : 0);\r\n} else if (pbpctl_dev->bp_10gb) {\r\nctrl_ext =\r\nBP10GB_READ_REG(pbpctl_dev, MISC_REG_GPIO);\r\nBP10GB_WRITE_REG(pbpctl_dev, MISC_REG_GPIO,\r\n(ctrl_ext | BP10GB_GPIO3_OE_P1)\r\n& ~(BP10GB_GPIO3_SET_P1 |\r\nBP10GB_GPIO3_CLR_P1));\r\nreturn (((BP10GB_READ_REG\r\n(pbpctl_dev,\r\nMISC_REG_GPIO)) & BP10GB_GPIO3_P1) !=\r\n0 ? 1 : 0);\r\n}\r\nif (!pbpctl_dev->bp_10g) {\r\nreturn (((BPCTL_READ_REG\r\n(pbpctl_dev_b,\r\nCTRL_EXT)) &\r\nBPCTLI_CTRL_EXT_SDP6_DATA) !=\r\n0 ? 1 : 0);\r\n} else {\r\nctrl_ext = BP10G_READ_REG(pbpctl_dev_b, EODSDP);\r\nBP10G_WRITE_REG(pbpctl_dev_b, EODSDP,\r\n(ctrl_ext |\r\nBP10G_SDP6_DATA_OUT));\r\nreturn (((BP10G_READ_REG(pbpctl_dev_b, EODSDP))\r\n& BP10G_SDP6_DATA_IN) != 0 ? 1 : 0);\r\n}\r\n}\r\n}\r\nreturn BP_NOT_CAP;\r\n}\r\nstatic int disc_status(bpctl_dev_t *pbpctl_dev)\r\n{\r\nint ctrl = 0;\r\nif (pbpctl_dev->bp_caps & DISC_CAP) {\r\nif ((ctrl = disc_off_status(pbpctl_dev)) < 0)\r\nreturn ctrl;\r\nreturn ((ctrl == 0) ? 1 : 0);\r\n}\r\nreturn BP_NOT_CAP;\r\n}\r\nint default_pwron_disc_status(bpctl_dev_t *pbpctl_dev)\r\n{\r\nif (pbpctl_dev->bp_caps & DISC_PWUP_CTL_CAP) {\r\nif (pbpctl_dev->bp_ext_ver >= 0x8)\r\nreturn ((((read_reg(pbpctl_dev, STATUS_DISC_REG_ADDR)) &\r\nDFLT_PWRON_DISC_MASK) ==\r\nDFLT_PWRON_DISC_MASK) ? 1 : 0);\r\n}\r\nreturn BP_NOT_CAP;\r\n}\r\nint dis_disc_cap_status(bpctl_dev_t *pbpctl_dev)\r\n{\r\nif (pbpctl_dev->bp_caps & DIS_DISC_CAP) {\r\nif (pbpctl_dev->bp_ext_ver >= 0x8)\r\nreturn ((((read_reg(pbpctl_dev, STATUS_DISC_REG_ADDR)) &\r\nDIS_DISC_CAP_MASK) ==\r\nDIS_DISC_CAP_MASK) ? 1 : 0);\r\n}\r\nreturn BP_NOT_CAP;\r\n}\r\nint disc_port_status(bpctl_dev_t *pbpctl_dev)\r\n{\r\nint ret = BP_NOT_CAP;\r\nbpctl_dev_t *pbpctl_dev_m;\r\nif ((is_bypass_fn(pbpctl_dev)) == 1)\r\npbpctl_dev_m = pbpctl_dev;\r\nelse\r\npbpctl_dev_m = get_master_port_fn(pbpctl_dev);\r\nif (pbpctl_dev_m == NULL)\r\nreturn BP_NOT_CAP;\r\nif (pbpctl_dev_m->bp_caps_ex & DISC_PORT_CAP_EX) {\r\nif (is_bypass_fn(pbpctl_dev) == 1) {\r\nreturn ((((read_reg(pbpctl_dev, STATUS_TAP_REG_ADDR)) &\r\nTX_DISA_MASK) == TX_DISA_MASK) ? 1 : 0);\r\n} else\r\nreturn ((((read_reg(pbpctl_dev, STATUS_TAP_REG_ADDR)) &\r\nTX_DISB_MASK) == TX_DISB_MASK) ? 1 : 0);\r\n}\r\nreturn ret;\r\n}\r\nint default_pwron_disc_port_status(bpctl_dev_t *pbpctl_dev)\r\n{\r\nint ret = BP_NOT_CAP;\r\nbpctl_dev_t *pbpctl_dev_m;\r\nif ((is_bypass_fn(pbpctl_dev)) == 1)\r\npbpctl_dev_m = pbpctl_dev;\r\nelse\r\npbpctl_dev_m = get_master_port_fn(pbpctl_dev);\r\nif (pbpctl_dev_m == NULL)\r\nreturn BP_NOT_CAP;\r\nif (pbpctl_dev_m->bp_caps_ex & DISC_PORT_CAP_EX) {\r\nif (is_bypass_fn(pbpctl_dev) == 1)\r\nreturn ret;\r\nelse\r\nreturn ret;\r\n}\r\nreturn ret;\r\n}\r\nint wdt_exp_mode_status(bpctl_dev_t *pbpctl_dev)\r\n{\r\nif (pbpctl_dev->bp_caps & WD_CTL_CAP) {\r\nif (pbpctl_dev->bp_ext_ver <= PXG2BPI_VER)\r\nreturn 0;\r\nelse if (pbpctl_dev->bp_ext_ver == PXG2TBPI_VER)\r\nreturn 1;\r\nelse if (pbpctl_dev->bp_ext_ver >= PXE2TBPI_VER) {\r\nif (pbpctl_dev->bp_ext_ver >= 0x8) {\r\nif (((read_reg\r\n(pbpctl_dev,\r\nSTATUS_DISC_REG_ADDR)) &\r\nWDTE_DISC_BPN_MASK) == WDTE_DISC_BPN_MASK)\r\nreturn 2;\r\n}\r\nreturn ((((read_reg(pbpctl_dev, STATUS_TAP_REG_ADDR)) &\r\nWDTE_TAP_BPN_MASK) ==\r\nWDTE_TAP_BPN_MASK) ? 1 : 0);\r\n}\r\n}\r\nreturn BP_NOT_CAP;\r\n}\r\nint tpl2_flag_status(bpctl_dev_t *pbpctl_dev)\r\n{\r\nif (pbpctl_dev->bp_caps_ex & TPL2_CAP_EX) {\r\nreturn ((((read_reg(pbpctl_dev, STATUS_DISC_REG_ADDR)) &\r\nTPL2_FLAG_MASK) == TPL2_FLAG_MASK) ? 1 : 0);\r\n}\r\nreturn BP_NOT_CAP;\r\n}\r\nint tpl_hw_status(bpctl_dev_t *pbpctl_dev)\r\n{\r\nbpctl_dev_t *pbpctl_dev_b = NULL;\r\nif (!(pbpctl_dev_b = get_status_port_fn(pbpctl_dev)))\r\nreturn BP_NOT_CAP;\r\nif (TPL_IF_SERIES(pbpctl_dev->subdevice))\r\nreturn (((BPCTL_READ_REG(pbpctl_dev, CTRL)) &\r\nBPCTLI_CTRL_SWDPIN0) != 0 ? 1 : 0);\r\nreturn BP_NOT_CAP;\r\n}\r\nint bp_wait_at_pwup_status(bpctl_dev_t *pbpctl_dev)\r\n{\r\nif (pbpctl_dev->bp_caps & SW_CTL_CAP) {\r\nif (pbpctl_dev->bp_ext_ver >= 0x8)\r\nreturn ((((read_reg(pbpctl_dev, CONT_CONFIG_REG_ADDR)) &\r\nWAIT_AT_PWUP_MASK) ==\r\nWAIT_AT_PWUP_MASK) ? 1 : 0);\r\n}\r\nreturn BP_NOT_CAP;\r\n}\r\nint bp_hw_reset_status(bpctl_dev_t *pbpctl_dev)\r\n{\r\nif (pbpctl_dev->bp_caps & SW_CTL_CAP) {\r\nif (pbpctl_dev->bp_ext_ver >= 0x8)\r\nreturn ((((read_reg(pbpctl_dev, CONT_CONFIG_REG_ADDR)) &\r\nEN_HW_RESET_MASK) ==\r\nEN_HW_RESET_MASK) ? 1 : 0);\r\n}\r\nreturn BP_NOT_CAP;\r\n}\r\nint std_nic_status(bpctl_dev_t *pbpctl_dev)\r\n{\r\nint status_val = 0;\r\nif (pbpctl_dev->bp_caps & STD_NIC_CAP) {\r\nif (INTEL_IF_SERIES(pbpctl_dev->subdevice))\r\nreturn BP_NOT_CAP;\r\nif (pbpctl_dev->bp_ext_ver >= BP_FW_EXT_VER8) {\r\nreturn ((((read_reg(pbpctl_dev, STATUS_DISC_REG_ADDR)) &\r\nSTD_NIC_ON_MASK) == STD_NIC_ON_MASK) ? 1 : 0);\r\n}\r\nif (pbpctl_dev->bp_ext_ver >= PXG2BPI_VER) {\r\nif (pbpctl_dev->bp_caps & BP_CAP) {\r\nstatus_val =\r\nread_reg(pbpctl_dev, STATUS_REG_ADDR);\r\nif (((!(status_val & WDT_EN_MASK))\r\n&& ((status_val & STD_NIC_MASK) ==\r\nSTD_NIC_MASK)))\r\nstatus_val = 1;\r\nelse\r\nreturn 0;\r\n}\r\nif (pbpctl_dev->bp_caps & TAP_CAP) {\r\nstatus_val =\r\nread_reg(pbpctl_dev, STATUS_TAP_REG_ADDR);\r\nif ((status_val & STD_NIC_TAP_MASK) ==\r\nSTD_NIC_TAP_MASK)\r\nstatus_val = 1;\r\nelse\r\nreturn 0;\r\n}\r\nif (pbpctl_dev->bp_caps & TAP_CAP) {\r\nif ((disc_off_status(pbpctl_dev)))\r\nstatus_val = 1;\r\nelse\r\nreturn 0;\r\n}\r\nreturn status_val;\r\n}\r\n}\r\nreturn BP_NOT_CAP;\r\n}\r\nvoid bypass_caps_init(bpctl_dev_t *pbpctl_dev)\r\n{\r\nu_int32_t ctrl_ext = 0;\r\nbpctl_dev_t *pbpctl_dev_m = NULL;\r\n#ifdef BYPASS_DEBUG\r\nint ret = 0;\r\nif (!(INTEL_IF_SERIES(adapter->bp_device_block.subdevice))) {\r\nret = read_reg(pbpctl_dev, VER_REG_ADDR);\r\nprintk("VER_REG reg1=%x\n", ret);\r\nret = read_reg(pbpctl_dev, PRODUCT_CAP_REG_ADDR);\r\nprintk("PRODUCT_CAP reg=%x\n", ret);\r\nret = read_reg(pbpctl_dev, STATUS_TAP_REG_ADDR);\r\nprintk("STATUS_TAP reg1=%x\n", ret);\r\nret = read_reg(pbpctl_dev, 0x7);\r\nprintk("SIG_REG reg1=%x\n", ret);\r\nret = read_reg(pbpctl_dev, STATUS_REG_ADDR);\r\nprintk("STATUS_REG_ADDR=%x\n", ret);\r\nret = read_reg(pbpctl_dev, WDT_REG_ADDR);\r\nprintk("WDT_REG_ADDR=%x\n", ret);\r\nret = read_reg(pbpctl_dev, TMRL_REG_ADDR);\r\nprintk("TMRL_REG_ADDR=%x\n", ret);\r\nret = read_reg(pbpctl_dev, TMRH_REG_ADDR);\r\nprintk("TMRH_REG_ADDR=%x\n", ret);\r\n}\r\n#endif\r\nif ((pbpctl_dev->bp_fiber5) || (pbpctl_dev->bp_10g9)) {\r\npbpctl_dev->media_type = bp_fiber;\r\n} else if (pbpctl_dev->bp_10gb) {\r\nif (BP10GB_CX4_SERIES(pbpctl_dev->subdevice))\r\npbpctl_dev->media_type = bp_cx4;\r\nelse\r\npbpctl_dev->media_type = bp_fiber;\r\n}\r\nelse if (pbpctl_dev->bp_540)\r\npbpctl_dev->media_type = bp_none;\r\nelse if (!pbpctl_dev->bp_10g) {\r\nctrl_ext = BPCTL_READ_REG(pbpctl_dev, CTRL_EXT);\r\nif ((ctrl_ext & BPCTLI_CTRL_EXT_LINK_MODE_MASK) == 0x0)\r\npbpctl_dev->media_type = bp_copper;\r\nelse\r\npbpctl_dev->media_type = bp_fiber;\r\n} else {\r\nif (BP10G_CX4_SERIES(pbpctl_dev->subdevice))\r\npbpctl_dev->media_type = bp_cx4;\r\nelse\r\npbpctl_dev->media_type = bp_fiber;\r\n}\r\nif (is_bypass_fn(pbpctl_dev)) {\r\npbpctl_dev->bp_caps |= BP_PWOFF_ON_CAP;\r\nif (pbpctl_dev->media_type == bp_fiber)\r\npbpctl_dev->bp_caps |=\r\n(TX_CTL_CAP | TX_STATUS_CAP | TPL_CAP);\r\nif (TPL_IF_SERIES(pbpctl_dev->subdevice)) {\r\npbpctl_dev->bp_caps |= TPL_CAP;\r\n}\r\nif (INTEL_IF_SERIES(pbpctl_dev->subdevice)) {\r\npbpctl_dev->bp_caps |=\r\n(BP_CAP | BP_STATUS_CAP | SW_CTL_CAP |\r\nBP_PWUP_ON_CAP | BP_PWUP_OFF_CAP | BP_PWOFF_OFF_CAP\r\n| WD_CTL_CAP | WD_STATUS_CAP | STD_NIC_CAP |\r\nWD_TIMEOUT_CAP);\r\npbpctl_dev->bp_ext_ver = OLD_IF_VER;\r\nreturn;\r\n}\r\nif ((pbpctl_dev->bp_fw_ver == 0xff) &&\r\nOLD_IF_SERIES(pbpctl_dev->subdevice)) {\r\npbpctl_dev->bp_caps |=\r\n(BP_CAP | BP_STATUS_CAP | BP_STATUS_CHANGE_CAP |\r\nSW_CTL_CAP | BP_PWUP_ON_CAP | WD_CTL_CAP |\r\nWD_STATUS_CAP | WD_TIMEOUT_CAP);\r\npbpctl_dev->bp_ext_ver = OLD_IF_VER;\r\nreturn;\r\n}\r\nelse {\r\nswitch (pbpctl_dev->bp_fw_ver) {\r\ncase BP_FW_VER_A0:\r\ncase BP_FW_VER_A1:{\r\npbpctl_dev->bp_ext_ver =\r\n(pbpctl_dev->\r\nbp_fw_ver & EXT_VER_MASK);\r\nbreak;\r\n}\r\ndefault:{\r\nif ((bypass_sign_check(pbpctl_dev)) !=\r\n1) {\r\npbpctl_dev->bp_caps = 0;\r\nreturn;\r\n}\r\npbpctl_dev->bp_ext_ver =\r\n(pbpctl_dev->\r\nbp_fw_ver & EXT_VER_MASK);\r\n}\r\n}\r\n}\r\nif (pbpctl_dev->bp_ext_ver == PXG2BPI_VER)\r\npbpctl_dev->bp_caps |=\r\n(BP_CAP | BP_STATUS_CAP | BP_STATUS_CHANGE_CAP |\r\nSW_CTL_CAP | BP_DIS_CAP | BP_DIS_STATUS_CAP |\r\nBP_PWUP_ON_CAP | BP_PWUP_OFF_CAP | BP_PWUP_CTL_CAP\r\n| WD_CTL_CAP | STD_NIC_CAP | WD_STATUS_CAP |\r\nWD_TIMEOUT_CAP);\r\nelse if (pbpctl_dev->bp_ext_ver >= PXG2TBPI_VER) {\r\nint cap_reg;\r\npbpctl_dev->bp_caps |=\r\n(SW_CTL_CAP | WD_CTL_CAP | WD_STATUS_CAP |\r\nWD_TIMEOUT_CAP);\r\ncap_reg = get_bp_prod_caps(pbpctl_dev);\r\nif ((cap_reg & NORMAL_UNSUPPORT_MASK) ==\r\nNORMAL_UNSUPPORT_MASK)\r\npbpctl_dev->bp_caps |= NIC_CAP_NEG;\r\nelse\r\npbpctl_dev->bp_caps |= STD_NIC_CAP;\r\nif ((normal_support(pbpctl_dev)) == 1)\r\npbpctl_dev->bp_caps |= STD_NIC_CAP;\r\nelse\r\npbpctl_dev->bp_caps |= NIC_CAP_NEG;\r\nif ((cap_reg & BYPASS_SUPPORT_MASK) ==\r\nBYPASS_SUPPORT_MASK) {\r\npbpctl_dev->bp_caps |=\r\n(BP_CAP | BP_STATUS_CAP |\r\nBP_STATUS_CHANGE_CAP | BP_DIS_CAP |\r\nBP_DIS_STATUS_CAP | BP_PWUP_ON_CAP |\r\nBP_PWUP_OFF_CAP | BP_PWUP_CTL_CAP);\r\nif (pbpctl_dev->bp_ext_ver >= BP_FW_EXT_VER7)\r\npbpctl_dev->bp_caps |=\r\nBP_PWOFF_ON_CAP | BP_PWOFF_OFF_CAP |\r\nBP_PWOFF_CTL_CAP;\r\n}\r\nif ((cap_reg & TAP_SUPPORT_MASK) == TAP_SUPPORT_MASK) {\r\npbpctl_dev->bp_caps |=\r\n(TAP_CAP | TAP_STATUS_CAP |\r\nTAP_STATUS_CHANGE_CAP | TAP_DIS_CAP |\r\nTAP_DIS_STATUS_CAP | TAP_PWUP_ON_CAP |\r\nTAP_PWUP_OFF_CAP | TAP_PWUP_CTL_CAP);\r\n}\r\nif (pbpctl_dev->bp_ext_ver >= BP_FW_EXT_VER8) {\r\nif ((cap_reg & DISC_SUPPORT_MASK) ==\r\nDISC_SUPPORT_MASK)\r\npbpctl_dev->bp_caps |=\r\n(DISC_CAP | DISC_DIS_CAP |\r\nDISC_PWUP_CTL_CAP);\r\nif ((cap_reg & TPL2_SUPPORT_MASK) ==\r\nTPL2_SUPPORT_MASK) {\r\npbpctl_dev->bp_caps_ex |= TPL2_CAP_EX;\r\npbpctl_dev->bp_caps |= TPL_CAP;\r\npbpctl_dev->bp_tpl_flag =\r\ntpl2_flag_status(pbpctl_dev);\r\n}\r\n}\r\nif (pbpctl_dev->bp_ext_ver >= BP_FW_EXT_VER9) {\r\nif ((cap_reg & DISC_PORT_SUPPORT_MASK) ==\r\nDISC_PORT_SUPPORT_MASK) {\r\npbpctl_dev->bp_caps_ex |=\r\nDISC_PORT_CAP_EX;\r\npbpctl_dev->bp_caps |=\r\n(TX_CTL_CAP | TX_STATUS_CAP);\r\n}\r\n}\r\n}\r\nif (pbpctl_dev->bp_ext_ver >= PXG2BPI_VER) {\r\nif ((read_reg(pbpctl_dev, STATUS_REG_ADDR)) &\r\nWDT_EN_MASK)\r\npbpctl_dev->wdt_status = WDT_STATUS_EN;\r\nelse\r\npbpctl_dev->wdt_status = WDT_STATUS_DIS;\r\n}\r\n} else if ((P2BPFI_IF_SERIES(pbpctl_dev->subdevice)) ||\r\n(PEGF5_IF_SERIES(pbpctl_dev->subdevice)) ||\r\n(PEGF80_IF_SERIES(pbpctl_dev->subdevice)) ||\r\n(BP10G9_IF_SERIES(pbpctl_dev->subdevice))) {\r\npbpctl_dev->bp_caps |= (TX_CTL_CAP | TX_STATUS_CAP);\r\n}\r\nif ((pbpctl_dev->subdevice & 0xa00) == 0xa00)\r\npbpctl_dev->bp_caps |= (TX_CTL_CAP | TX_STATUS_CAP);\r\nif (PEG5_IF_SERIES(pbpctl_dev->subdevice))\r\npbpctl_dev->bp_caps |= (TX_CTL_CAP | TX_STATUS_CAP);\r\nif (BP10GB_IF_SERIES(pbpctl_dev->subdevice)) {\r\npbpctl_dev->bp_caps &= ~(TX_CTL_CAP | TX_STATUS_CAP);\r\n}\r\npbpctl_dev_m = get_master_port_fn(pbpctl_dev);\r\nif (pbpctl_dev_m != NULL) {\r\nint cap_reg = 0;\r\nif (pbpctl_dev_m->bp_ext_ver >= 0x9) {\r\ncap_reg = get_bp_prod_caps(pbpctl_dev_m);\r\nif ((cap_reg & DISC_PORT_SUPPORT_MASK) ==\r\nDISC_PORT_SUPPORT_MASK)\r\npbpctl_dev->bp_caps |=\r\n(TX_CTL_CAP | TX_STATUS_CAP);\r\npbpctl_dev->bp_caps_ex |= DISC_PORT_CAP_EX;\r\n}\r\n}\r\n}\r\nint bypass_off_init(bpctl_dev_t *pbpctl_dev)\r\n{\r\nint ret = 0;\r\nif ((ret = cmnd_on(pbpctl_dev)) < 0)\r\nreturn ret;\r\nif (INTEL_IF_SERIES(pbpctl_dev->subdevice))\r\nreturn dis_bypass_cap(pbpctl_dev);\r\nwdt_off(pbpctl_dev);\r\nif (pbpctl_dev->bp_caps & BP_CAP)\r\nbypass_off(pbpctl_dev);\r\nif (pbpctl_dev->bp_caps & TAP_CAP)\r\ntap_off(pbpctl_dev);\r\ncmnd_off(pbpctl_dev);\r\nreturn 0;\r\n}\r\nvoid remove_bypass_wd_auto(bpctl_dev_t *pbpctl_dev)\r\n{\r\n#ifdef BP_SELF_TEST\r\nbpctl_dev_t *pbpctl_dev_sl = NULL;\r\n#endif\r\nif (pbpctl_dev->bp_caps & WD_CTL_CAP) {\r\ndel_timer_sync(&pbpctl_dev->bp_timer);\r\n#ifdef BP_SELF_TEST\r\npbpctl_dev_sl = get_status_port_fn(pbpctl_dev);\r\nif (pbpctl_dev_sl && (pbpctl_dev_sl->ndev)) {\r\nif ((pbpctl_dev_sl->ndev->netdev_ops)\r\n&& (pbpctl_dev_sl->old_ops)) {\r\nrtnl_lock();\r\npbpctl_dev_sl->ndev->netdev_ops =\r\npbpctl_dev_sl->old_ops;\r\npbpctl_dev_sl->old_ops = NULL;\r\nrtnl_unlock();\r\n}\r\n}\r\n#endif\r\n}\r\n}\r\nint init_bypass_wd_auto(bpctl_dev_t *pbpctl_dev)\r\n{\r\nif (pbpctl_dev->bp_caps & WD_CTL_CAP) {\r\ninit_timer(&pbpctl_dev->bp_timer);\r\npbpctl_dev->bp_timer.function = &wd_reset_timer;\r\npbpctl_dev->bp_timer.data = (unsigned long)pbpctl_dev;\r\nreturn 1;\r\n}\r\nreturn BP_NOT_CAP;\r\n}\r\nint bp_hard_start_xmit(struct sk_buff *skb, struct net_device *dev)\r\n{\r\nbpctl_dev_t *pbpctl_dev = NULL, *pbpctl_dev_m = NULL;\r\nint idx_dev = 0;\r\nstruct ethhdr *eth = (struct ethhdr *)skb->data;\r\nfor (idx_dev = 0;\r\n((bpctl_dev_arr[idx_dev].ndev != NULL) && (idx_dev < device_num));\r\nidx_dev++) {\r\nif (bpctl_dev_arr[idx_dev].ndev == dev) {\r\npbpctl_dev = &bpctl_dev_arr[idx_dev];\r\nbreak;\r\n}\r\n}\r\nif (!pbpctl_dev)\r\nreturn 1;\r\nif ((htons(ETH_P_BPTEST) == eth->h_proto)) {\r\npbpctl_dev_m = get_master_port_fn(pbpctl_dev);\r\nif (pbpctl_dev_m) {\r\nif (bypass_status(pbpctl_dev_m)) {\r\ncmnd_on(pbpctl_dev_m);\r\nbypass_off(pbpctl_dev_m);\r\ncmnd_off(pbpctl_dev_m);\r\n}\r\nwdt_timer_reload(pbpctl_dev_m);\r\n}\r\ndev_kfree_skb_irq(skb);\r\nreturn 0;\r\n}\r\nreturn pbpctl_dev->hard_start_xmit_save(skb, dev);\r\n}\r\nint set_bypass_wd_auto(bpctl_dev_t *pbpctl_dev, unsigned int param)\r\n{\r\nif (pbpctl_dev->bp_caps & WD_CTL_CAP) {\r\nif (pbpctl_dev->reset_time != param) {\r\nif (INTEL_IF_SERIES(pbpctl_dev->subdevice))\r\npbpctl_dev->reset_time =\r\n(param <\r\nWDT_AUTO_MIN_INT) ? WDT_AUTO_MIN_INT :\r\nparam;\r\nelse\r\npbpctl_dev->reset_time = param;\r\nif (param)\r\nmod_timer(&pbpctl_dev->bp_timer, jiffies);\r\n}\r\nreturn 0;\r\n}\r\nreturn BP_NOT_CAP;\r\n}\r\nint get_bypass_wd_auto(bpctl_dev_t *pbpctl_dev)\r\n{\r\nif (pbpctl_dev->bp_caps & WD_CTL_CAP) {\r\nreturn pbpctl_dev->reset_time;\r\n}\r\nreturn BP_NOT_CAP;\r\n}\r\nint set_bp_self_test(bpctl_dev_t *pbpctl_dev, unsigned int param)\r\n{\r\nbpctl_dev_t *pbpctl_dev_sl = NULL;\r\nif (pbpctl_dev->bp_caps & WD_CTL_CAP) {\r\npbpctl_dev->bp_self_test_flag = param == 0 ? 0 : 1;\r\npbpctl_dev_sl = get_status_port_fn(pbpctl_dev);\r\nif ((pbpctl_dev_sl->ndev) && (pbpctl_dev_sl->ndev->netdev_ops)) {\r\nrtnl_lock();\r\nif (pbpctl_dev->bp_self_test_flag == 1) {\r\npbpctl_dev_sl->old_ops =\r\npbpctl_dev_sl->ndev->netdev_ops;\r\npbpctl_dev_sl->new_ops =\r\n*pbpctl_dev_sl->old_ops;\r\npbpctl_dev_sl->new_ops.ndo_start_xmit =\r\nbp_hard_start_xmit;\r\npbpctl_dev_sl->ndev->netdev_ops =\r\n&pbpctl_dev_sl->new_ops;\r\n} else if (pbpctl_dev_sl->old_ops) {\r\npbpctl_dev_sl->ndev->netdev_ops =\r\npbpctl_dev_sl->old_ops;\r\npbpctl_dev_sl->old_ops = NULL;\r\n}\r\nrtnl_unlock();\r\n}\r\nset_bypass_wd_auto(pbpctl_dev, param);\r\nreturn 0;\r\n}\r\nreturn BP_NOT_CAP;\r\n}\r\nint get_bp_self_test(bpctl_dev_t *pbpctl_dev)\r\n{\r\nif (pbpctl_dev->bp_caps & WD_CTL_CAP) {\r\nif (pbpctl_dev->bp_self_test_flag == 1)\r\nreturn pbpctl_dev->reset_time;\r\nelse\r\nreturn 0;\r\n}\r\nreturn BP_NOT_CAP;\r\n}\r\nint is_bypass_fn(bpctl_dev_t *pbpctl_dev)\r\n{\r\nif (!pbpctl_dev)\r\nreturn -1;\r\nreturn (((pbpctl_dev->func == 0) || (pbpctl_dev->func == 2)) ? 1 : 0);\r\n}\r\nint set_bypass_fn(bpctl_dev_t *pbpctl_dev, int bypass_mode)\r\n{\r\nint ret = 0;\r\nif (!(pbpctl_dev->bp_caps & BP_CAP))\r\nreturn BP_NOT_CAP;\r\nif ((ret = cmnd_on(pbpctl_dev)) < 0)\r\nreturn ret;\r\nif (!bypass_mode)\r\nret = bypass_off(pbpctl_dev);\r\nelse\r\nret = bypass_on(pbpctl_dev);\r\ncmnd_off(pbpctl_dev);\r\nreturn ret;\r\n}\r\nint get_bypass_fn(bpctl_dev_t *pbpctl_dev)\r\n{\r\nreturn bypass_status(pbpctl_dev);\r\n}\r\nint get_bypass_change_fn(bpctl_dev_t *pbpctl_dev)\r\n{\r\nif (!pbpctl_dev)\r\nreturn -1;\r\nreturn bypass_change_status(pbpctl_dev);\r\n}\r\nint set_dis_bypass_fn(bpctl_dev_t *pbpctl_dev, int dis_param)\r\n{\r\nint ret = 0;\r\nif (!pbpctl_dev)\r\nreturn -1;\r\nif (!(pbpctl_dev->bp_caps & BP_DIS_CAP))\r\nreturn BP_NOT_CAP;\r\nif ((ret = cmnd_on(pbpctl_dev)) < 0)\r\nreturn ret;\r\nif (dis_param)\r\nret = dis_bypass_cap(pbpctl_dev);\r\nelse\r\nret = en_bypass_cap(pbpctl_dev);\r\ncmnd_off(pbpctl_dev);\r\nreturn ret;\r\n}\r\nint get_dis_bypass_fn(bpctl_dev_t *pbpctl_dev)\r\n{\r\nif (!pbpctl_dev)\r\nreturn -1;\r\nreturn dis_bypass_cap_status(pbpctl_dev);\r\n}\r\nint set_bypass_pwoff_fn(bpctl_dev_t *pbpctl_dev, int bypass_mode)\r\n{\r\nint ret = 0;\r\nif (!pbpctl_dev)\r\nreturn -1;\r\nif (!(pbpctl_dev->bp_caps & BP_PWOFF_CTL_CAP))\r\nreturn BP_NOT_CAP;\r\nif ((ret = cmnd_on(pbpctl_dev)) < 0)\r\nreturn ret;\r\nif (bypass_mode)\r\nret = bypass_state_pwroff(pbpctl_dev);\r\nelse\r\nret = normal_state_pwroff(pbpctl_dev);\r\ncmnd_off(pbpctl_dev);\r\nreturn ret;\r\n}\r\nint get_bypass_pwoff_fn(bpctl_dev_t *pbpctl_dev)\r\n{\r\nif (!pbpctl_dev)\r\nreturn -1;\r\nreturn default_pwroff_status(pbpctl_dev);\r\n}\r\nint set_bypass_pwup_fn(bpctl_dev_t *pbpctl_dev, int bypass_mode)\r\n{\r\nint ret = 0;\r\nif (!pbpctl_dev)\r\nreturn -1;\r\nif (!(pbpctl_dev->bp_caps & BP_PWUP_CTL_CAP))\r\nreturn BP_NOT_CAP;\r\nif ((ret = cmnd_on(pbpctl_dev)) < 0)\r\nreturn ret;\r\nif (bypass_mode)\r\nret = bypass_state_pwron(pbpctl_dev);\r\nelse\r\nret = normal_state_pwron(pbpctl_dev);\r\ncmnd_off(pbpctl_dev);\r\nreturn ret;\r\n}\r\nint get_bypass_pwup_fn(bpctl_dev_t *pbpctl_dev)\r\n{\r\nif (!pbpctl_dev)\r\nreturn -1;\r\nreturn default_pwron_status(pbpctl_dev);\r\n}\r\nint set_bypass_wd_fn(bpctl_dev_t *pbpctl_dev, int timeout)\r\n{\r\nint ret = 0;\r\nif (!pbpctl_dev)\r\nreturn -1;\r\nif (!(pbpctl_dev->bp_caps & WD_CTL_CAP))\r\nreturn BP_NOT_CAP;\r\nif ((ret = cmnd_on(pbpctl_dev)) < 0)\r\nreturn ret;\r\nif (!timeout)\r\nret = wdt_off(pbpctl_dev);\r\nelse {\r\nwdt_on(pbpctl_dev, timeout);\r\nret = pbpctl_dev->bypass_timer_interval;\r\n}\r\ncmnd_off(pbpctl_dev);\r\nreturn ret;\r\n}\r\nint get_bypass_wd_fn(bpctl_dev_t *pbpctl_dev, int *timeout)\r\n{\r\nif (!pbpctl_dev)\r\nreturn -1;\r\nreturn wdt_programmed(pbpctl_dev, timeout);\r\n}\r\nint get_wd_expire_time_fn(bpctl_dev_t *pbpctl_dev, int *time_left)\r\n{\r\nif (!pbpctl_dev)\r\nreturn -1;\r\nreturn wdt_timer(pbpctl_dev, time_left);\r\n}\r\nint reset_bypass_wd_timer_fn(bpctl_dev_t *pbpctl_dev)\r\n{\r\nif (!pbpctl_dev)\r\nreturn -1;\r\nreturn wdt_timer_reload(pbpctl_dev);\r\n}\r\nint get_wd_set_caps_fn(bpctl_dev_t *pbpctl_dev)\r\n{\r\nint bp_status = 0;\r\nunsigned int step_value = TIMEOUT_MAX_STEP + 1, bit_cnt = 0;\r\nif (!pbpctl_dev)\r\nreturn -1;\r\nif (INTEL_IF_SERIES(pbpctl_dev->subdevice))\r\nreturn BP_NOT_CAP;\r\nwhile ((step_value >>= 1))\r\nbit_cnt++;\r\nif (is_bypass_fn(pbpctl_dev)) {\r\nbp_status =\r\nWD_STEP_COUNT_MASK(bit_cnt) | WDT_STEP_TIME |\r\nWD_MIN_TIME_MASK(TIMEOUT_UNIT / 100);\r\n} else\r\nreturn -1;\r\nreturn bp_status;\r\n}\r\nint set_std_nic_fn(bpctl_dev_t *pbpctl_dev, int nic_mode)\r\n{\r\nint ret = 0;\r\nif (!pbpctl_dev)\r\nreturn -1;\r\nif (!(pbpctl_dev->bp_caps & STD_NIC_CAP))\r\nreturn BP_NOT_CAP;\r\nif ((ret = cmnd_on(pbpctl_dev)) < 0)\r\nreturn ret;\r\nif (nic_mode)\r\nret = std_nic_on(pbpctl_dev);\r\nelse\r\nret = std_nic_off(pbpctl_dev);\r\ncmnd_off(pbpctl_dev);\r\nreturn ret;\r\n}\r\nint get_std_nic_fn(bpctl_dev_t *pbpctl_dev)\r\n{\r\nif (!pbpctl_dev)\r\nreturn -1;\r\nreturn std_nic_status(pbpctl_dev);\r\n}\r\nint set_tap_fn(bpctl_dev_t *pbpctl_dev, int tap_mode)\r\n{\r\nif (!pbpctl_dev)\r\nreturn -1;\r\nif ((pbpctl_dev->bp_caps & TAP_CAP) && ((cmnd_on(pbpctl_dev)) >= 0)) {\r\nif (!tap_mode)\r\ntap_off(pbpctl_dev);\r\nelse\r\ntap_on(pbpctl_dev);\r\ncmnd_off(pbpctl_dev);\r\nreturn 0;\r\n}\r\nreturn BP_NOT_CAP;\r\n}\r\nint get_tap_fn(bpctl_dev_t *pbpctl_dev)\r\n{\r\nif (!pbpctl_dev)\r\nreturn -1;\r\nreturn tap_status(pbpctl_dev);\r\n}\r\nint set_tap_pwup_fn(bpctl_dev_t *pbpctl_dev, int tap_mode)\r\n{\r\nint ret = 0;\r\nif (!pbpctl_dev)\r\nreturn -1;\r\nif ((pbpctl_dev->bp_caps & TAP_PWUP_CTL_CAP)\r\n&& ((cmnd_on(pbpctl_dev)) >= 0)) {\r\nif (tap_mode)\r\nret = tap_state_pwron(pbpctl_dev);\r\nelse\r\nret = normal_state_pwron(pbpctl_dev);\r\ncmnd_off(pbpctl_dev);\r\n} else\r\nret = BP_NOT_CAP;\r\nreturn ret;\r\n}\r\nint get_tap_pwup_fn(bpctl_dev_t *pbpctl_dev)\r\n{\r\nint ret = 0;\r\nif (!pbpctl_dev)\r\nreturn -1;\r\nif ((ret = default_pwron_tap_status(pbpctl_dev)) < 0)\r\nreturn ret;\r\nreturn ((ret == 0) ? 1 : 0);\r\n}\r\nint get_tap_change_fn(bpctl_dev_t *pbpctl_dev)\r\n{\r\nif (!pbpctl_dev)\r\nreturn -1;\r\nreturn tap_change_status(pbpctl_dev);\r\n}\r\nint set_dis_tap_fn(bpctl_dev_t *pbpctl_dev, int dis_param)\r\n{\r\nint ret = 0;\r\nif (!pbpctl_dev)\r\nreturn -1;\r\nif ((pbpctl_dev->bp_caps & TAP_DIS_CAP) && ((cmnd_on(pbpctl_dev)) >= 0)) {\r\nif (dis_param)\r\nret = dis_tap_cap(pbpctl_dev);\r\nelse\r\nret = en_tap_cap(pbpctl_dev);\r\ncmnd_off(pbpctl_dev);\r\nreturn ret;\r\n} else\r\nreturn BP_NOT_CAP;\r\n}\r\nint get_dis_tap_fn(bpctl_dev_t *pbpctl_dev)\r\n{\r\nif (!pbpctl_dev)\r\nreturn -1;\r\nreturn dis_tap_cap_status(pbpctl_dev);\r\n}\r\nint set_disc_fn(bpctl_dev_t *pbpctl_dev, int disc_mode)\r\n{\r\nif (!pbpctl_dev)\r\nreturn -1;\r\nif ((pbpctl_dev->bp_caps & DISC_CAP) && ((cmnd_on(pbpctl_dev)) >= 0)) {\r\nif (!disc_mode)\r\ndisc_off(pbpctl_dev);\r\nelse\r\ndisc_on(pbpctl_dev);\r\ncmnd_off(pbpctl_dev);\r\nreturn BP_OK;\r\n}\r\nreturn BP_NOT_CAP;\r\n}\r\nint get_disc_fn(bpctl_dev_t *pbpctl_dev)\r\n{\r\nint ret = 0;\r\nif (!pbpctl_dev)\r\nreturn -1;\r\nret = disc_status(pbpctl_dev);\r\nreturn ret;\r\n}\r\nint set_disc_pwup_fn(bpctl_dev_t *pbpctl_dev, int disc_mode)\r\n{\r\nint ret = 0;\r\nif (!pbpctl_dev)\r\nreturn -1;\r\nif ((pbpctl_dev->bp_caps & DISC_PWUP_CTL_CAP)\r\n&& ((cmnd_on(pbpctl_dev)) >= 0)) {\r\nif (disc_mode)\r\nret = disc_state_pwron(pbpctl_dev);\r\nelse\r\nret = normal_state_pwron(pbpctl_dev);\r\ncmnd_off(pbpctl_dev);\r\n} else\r\nret = BP_NOT_CAP;\r\nreturn ret;\r\n}\r\nint get_disc_pwup_fn(bpctl_dev_t *pbpctl_dev)\r\n{\r\nint ret = 0;\r\nif (!pbpctl_dev)\r\nreturn -1;\r\nret = default_pwron_disc_status(pbpctl_dev);\r\nreturn (ret == 0 ? 1 : (ret < 0 ? BP_NOT_CAP : 0));\r\n}\r\nint get_disc_change_fn(bpctl_dev_t *pbpctl_dev)\r\n{\r\nint ret = 0;\r\nif (!pbpctl_dev)\r\nreturn -1;\r\nret = disc_change_status(pbpctl_dev);\r\nreturn ret;\r\n}\r\nint set_dis_disc_fn(bpctl_dev_t *pbpctl_dev, int dis_param)\r\n{\r\nint ret = 0;\r\nif (!pbpctl_dev)\r\nreturn -1;\r\nif ((pbpctl_dev->bp_caps & DISC_DIS_CAP)\r\n&& ((cmnd_on(pbpctl_dev)) >= 0)) {\r\nif (dis_param)\r\nret = dis_disc_cap(pbpctl_dev);\r\nelse\r\nret = en_disc_cap(pbpctl_dev);\r\ncmnd_off(pbpctl_dev);\r\nreturn ret;\r\n} else\r\nreturn BP_NOT_CAP;\r\n}\r\nint get_dis_disc_fn(bpctl_dev_t *pbpctl_dev)\r\n{\r\nint ret = 0;\r\nif (!pbpctl_dev)\r\nreturn -1;\r\nret = dis_disc_cap_status(pbpctl_dev);\r\nreturn ret;\r\n}\r\nint set_disc_port_fn(bpctl_dev_t *pbpctl_dev, int disc_mode)\r\n{\r\nint ret = BP_NOT_CAP;\r\nif (!pbpctl_dev)\r\nreturn -1;\r\nif (!disc_mode)\r\nret = disc_port_off(pbpctl_dev);\r\nelse\r\nret = disc_port_on(pbpctl_dev);\r\nreturn ret;\r\n}\r\nint get_disc_port_fn(bpctl_dev_t *pbpctl_dev)\r\n{\r\nif (!pbpctl_dev)\r\nreturn -1;\r\nreturn disc_port_status(pbpctl_dev);\r\n}\r\nint set_disc_port_pwup_fn(bpctl_dev_t *pbpctl_dev, int disc_mode)\r\n{\r\nint ret = BP_NOT_CAP;\r\nif (!pbpctl_dev)\r\nreturn -1;\r\nif (!disc_mode)\r\nret = normal_port_state_pwron(pbpctl_dev);\r\nelse\r\nret = disc_port_state_pwron(pbpctl_dev);\r\nreturn ret;\r\n}\r\nint get_disc_port_pwup_fn(bpctl_dev_t *pbpctl_dev)\r\n{\r\nint ret = 0;\r\nif (!pbpctl_dev)\r\nreturn -1;\r\nif ((ret = default_pwron_disc_port_status(pbpctl_dev)) < 0)\r\nreturn ret;\r\nreturn ((ret == 0) ? 1 : 0);\r\n}\r\nint get_wd_exp_mode_fn(bpctl_dev_t *pbpctl_dev)\r\n{\r\nif (!pbpctl_dev)\r\nreturn -1;\r\nreturn wdt_exp_mode_status(pbpctl_dev);\r\n}\r\nint set_wd_exp_mode_fn(bpctl_dev_t *pbpctl_dev, int param)\r\n{\r\nif (!pbpctl_dev)\r\nreturn -1;\r\nreturn wdt_exp_mode(pbpctl_dev, param);\r\n}\r\nint reset_cont_fn(bpctl_dev_t *pbpctl_dev)\r\n{\r\nint ret = 0;\r\nif (!pbpctl_dev)\r\nreturn -1;\r\nif ((ret = cmnd_on(pbpctl_dev)) < 0)\r\nreturn ret;\r\nreturn reset_cont(pbpctl_dev);\r\n}\r\nint set_tx_fn(bpctl_dev_t *pbpctl_dev, int tx_state)\r\n{\r\nbpctl_dev_t *pbpctl_dev_b = NULL;\r\nif (!pbpctl_dev)\r\nreturn -1;\r\nif ((pbpctl_dev->bp_caps & TPL_CAP) &&\r\n(pbpctl_dev->bp_caps & SW_CTL_CAP)) {\r\nif ((pbpctl_dev->bp_tpl_flag))\r\nreturn BP_NOT_CAP;\r\n} else if ((pbpctl_dev_b = get_master_port_fn(pbpctl_dev))) {\r\nif ((pbpctl_dev_b->bp_caps & TPL_CAP) &&\r\n(pbpctl_dev_b->bp_tpl_flag))\r\nreturn BP_NOT_CAP;\r\n}\r\nreturn set_tx(pbpctl_dev, tx_state);\r\n}\r\nint set_bp_force_link_fn(int dev_num, int tx_state)\r\n{\r\nstatic bpctl_dev_t *bpctl_dev_curr;\r\nif ((dev_num < 0) || (dev_num > device_num)\r\n|| (bpctl_dev_arr[dev_num].pdev == NULL))\r\nreturn -1;\r\nbpctl_dev_curr = &bpctl_dev_arr[dev_num];\r\nreturn set_bp_force_link(bpctl_dev_curr, tx_state);\r\n}\r\nint set_wd_autoreset_fn(bpctl_dev_t *pbpctl_dev, int param)\r\n{\r\nif (!pbpctl_dev)\r\nreturn -1;\r\nreturn set_bypass_wd_auto(pbpctl_dev, param);\r\n}\r\nint get_wd_autoreset_fn(bpctl_dev_t *pbpctl_dev)\r\n{\r\nif (!pbpctl_dev)\r\nreturn -1;\r\nreturn get_bypass_wd_auto(pbpctl_dev);\r\n}\r\nint set_bp_self_test_fn(bpctl_dev_t *pbpctl_dev, int param)\r\n{\r\nif (!pbpctl_dev)\r\nreturn -1;\r\nreturn set_bp_self_test(pbpctl_dev, param);\r\n}\r\nint get_bp_self_test_fn(bpctl_dev_t *pbpctl_dev)\r\n{\r\nif (!pbpctl_dev)\r\nreturn -1;\r\nreturn get_bp_self_test(pbpctl_dev);\r\n}\r\nint get_bypass_caps_fn(bpctl_dev_t *pbpctl_dev)\r\n{\r\nif (!pbpctl_dev)\r\nreturn -1;\r\nreturn pbpctl_dev->bp_caps;\r\n}\r\nint get_bypass_slave_fn(bpctl_dev_t *pbpctl_dev, bpctl_dev_t **pbpctl_dev_out)\r\n{\r\nint idx_dev = 0;\r\nif (!pbpctl_dev)\r\nreturn -1;\r\nif ((pbpctl_dev->func == 0) || (pbpctl_dev->func == 2)) {\r\nfor (idx_dev = 0;\r\n((bpctl_dev_arr[idx_dev].pdev != NULL)\r\n&& (idx_dev < device_num)); idx_dev++) {\r\nif ((bpctl_dev_arr[idx_dev].bus == pbpctl_dev->bus)\r\n&& (bpctl_dev_arr[idx_dev].slot ==\r\npbpctl_dev->slot)) {\r\nif ((pbpctl_dev->func == 0)\r\n&& (bpctl_dev_arr[idx_dev].func == 1)) {\r\n*pbpctl_dev_out =\r\n&bpctl_dev_arr[idx_dev];\r\nreturn 1;\r\n}\r\nif ((pbpctl_dev->func == 2) &&\r\n(bpctl_dev_arr[idx_dev].func == 3)) {\r\n*pbpctl_dev_out =\r\n&bpctl_dev_arr[idx_dev];\r\nreturn 1;\r\n}\r\n}\r\n}\r\nreturn -1;\r\n} else\r\nreturn 0;\r\n}\r\nint is_bypass(bpctl_dev_t *pbpctl_dev)\r\n{\r\nif (!pbpctl_dev)\r\nreturn -1;\r\nif ((pbpctl_dev->func == 0) || (pbpctl_dev->func == 2))\r\nreturn 1;\r\nelse\r\nreturn 0;\r\n}\r\nint get_tx_fn(bpctl_dev_t *pbpctl_dev)\r\n{\r\nbpctl_dev_t *pbpctl_dev_b = NULL;\r\nif (!pbpctl_dev)\r\nreturn -1;\r\nif ((pbpctl_dev->bp_caps & TPL_CAP) &&\r\n(pbpctl_dev->bp_caps & SW_CTL_CAP)) {\r\nif ((pbpctl_dev->bp_tpl_flag))\r\nreturn BP_NOT_CAP;\r\n} else if ((pbpctl_dev_b = get_master_port_fn(pbpctl_dev))) {\r\nif ((pbpctl_dev_b->bp_caps & TPL_CAP) &&\r\n(pbpctl_dev_b->bp_tpl_flag))\r\nreturn BP_NOT_CAP;\r\n}\r\nreturn tx_status(pbpctl_dev);\r\n}\r\nint get_bp_force_link_fn(int dev_num)\r\n{\r\nstatic bpctl_dev_t *bpctl_dev_curr;\r\nif ((dev_num < 0) || (dev_num > device_num)\r\n|| (bpctl_dev_arr[dev_num].pdev == NULL))\r\nreturn -1;\r\nbpctl_dev_curr = &bpctl_dev_arr[dev_num];\r\nreturn bp_force_link_status(bpctl_dev_curr);\r\n}\r\nstatic int get_bypass_link_status(bpctl_dev_t *pbpctl_dev)\r\n{\r\nif (!pbpctl_dev)\r\nreturn -1;\r\nif (pbpctl_dev->media_type == bp_fiber)\r\nreturn ((BPCTL_READ_REG(pbpctl_dev, CTRL) &\r\nBPCTLI_CTRL_SWDPIN1));\r\nelse\r\nreturn ((BPCTL_READ_REG(pbpctl_dev, STATUS) &\r\nBPCTLI_STATUS_LU));\r\n}\r\nstatic void bp_tpl_timer_fn(unsigned long param)\r\n{\r\nbpctl_dev_t *pbpctl_dev = (bpctl_dev_t *) param;\r\nuint32_t link1, link2;\r\nbpctl_dev_t *pbpctl_dev_b = NULL;\r\nif (!(pbpctl_dev_b = get_status_port_fn(pbpctl_dev)))\r\nreturn;\r\nif (!pbpctl_dev->bp_tpl_flag) {\r\nset_tx(pbpctl_dev_b, 1);\r\nset_tx(pbpctl_dev, 1);\r\nreturn;\r\n}\r\nlink1 = get_bypass_link_status(pbpctl_dev);\r\nlink2 = get_bypass_link_status(pbpctl_dev_b);\r\nif ((link1) && (tx_status(pbpctl_dev))) {\r\nif ((!link2) && (tx_status(pbpctl_dev_b))) {\r\nset_tx(pbpctl_dev, 0);\r\n} else if (!tx_status(pbpctl_dev_b)) {\r\nset_tx(pbpctl_dev_b, 1);\r\n}\r\n} else if ((!link1) && (tx_status(pbpctl_dev))) {\r\nif ((link2) && (tx_status(pbpctl_dev_b))) {\r\nset_tx(pbpctl_dev_b, 0);\r\n}\r\n} else if ((link1) && (!tx_status(pbpctl_dev))) {\r\nif ((link2) && (tx_status(pbpctl_dev_b))) {\r\nset_tx(pbpctl_dev, 1);\r\n}\r\n} else if ((!link1) && (!tx_status(pbpctl_dev))) {\r\nif ((link2) && (tx_status(pbpctl_dev_b))) {\r\nset_tx(pbpctl_dev, 1);\r\n}\r\n}\r\nmod_timer(&pbpctl_dev->bp_tpl_timer, jiffies + BP_LINK_MON_DELAY * HZ);\r\n}\r\nvoid remove_bypass_tpl_auto(bpctl_dev_t *pbpctl_dev)\r\n{\r\nbpctl_dev_t *pbpctl_dev_b = NULL;\r\nif (!pbpctl_dev)\r\nreturn;\r\npbpctl_dev_b = get_status_port_fn(pbpctl_dev);\r\nif (pbpctl_dev->bp_caps & TPL_CAP) {\r\ndel_timer_sync(&pbpctl_dev->bp_tpl_timer);\r\npbpctl_dev->bp_tpl_flag = 0;\r\npbpctl_dev_b = get_status_port_fn(pbpctl_dev);\r\nif (pbpctl_dev_b)\r\nset_tx(pbpctl_dev_b, 1);\r\nset_tx(pbpctl_dev, 1);\r\n}\r\nreturn;\r\n}\r\nint init_bypass_tpl_auto(bpctl_dev_t *pbpctl_dev)\r\n{\r\nif (!pbpctl_dev)\r\nreturn -1;\r\nif (pbpctl_dev->bp_caps & TPL_CAP) {\r\ninit_timer(&pbpctl_dev->bp_tpl_timer);\r\npbpctl_dev->bp_tpl_timer.function = &bp_tpl_timer_fn;\r\npbpctl_dev->bp_tpl_timer.data = (unsigned long)pbpctl_dev;\r\nreturn BP_OK;\r\n}\r\nreturn BP_NOT_CAP;\r\n}\r\nint set_bypass_tpl_auto(bpctl_dev_t *pbpctl_dev, unsigned int param)\r\n{\r\nif (!pbpctl_dev)\r\nreturn -1;\r\nif (pbpctl_dev->bp_caps & TPL_CAP) {\r\nif ((param) && (!pbpctl_dev->bp_tpl_flag)) {\r\npbpctl_dev->bp_tpl_flag = param;\r\nmod_timer(&pbpctl_dev->bp_tpl_timer, jiffies + 1);\r\nreturn BP_OK;\r\n};\r\nif ((!param) && (pbpctl_dev->bp_tpl_flag))\r\nremove_bypass_tpl_auto(pbpctl_dev);\r\nreturn BP_OK;\r\n}\r\nreturn BP_NOT_CAP;\r\n}\r\nint get_bypass_tpl_auto(bpctl_dev_t *pbpctl_dev)\r\n{\r\nif (!pbpctl_dev)\r\nreturn -1;\r\nif (pbpctl_dev->bp_caps & TPL_CAP) {\r\nreturn pbpctl_dev->bp_tpl_flag;\r\n}\r\nreturn BP_NOT_CAP;\r\n}\r\nint set_tpl_fn(bpctl_dev_t *pbpctl_dev, int tpl_mode)\r\n{\r\nbpctl_dev_t *pbpctl_dev_b = NULL;\r\nif (!pbpctl_dev)\r\nreturn -1;\r\npbpctl_dev_b = get_status_port_fn(pbpctl_dev);\r\nif (pbpctl_dev->bp_caps & TPL_CAP) {\r\nif (tpl_mode) {\r\nif ((pbpctl_dev_b = get_status_port_fn(pbpctl_dev)))\r\nset_tx(pbpctl_dev_b, 1);\r\nset_tx(pbpctl_dev, 1);\r\n}\r\nif ((TPL_IF_SERIES(pbpctl_dev->subdevice)) ||\r\n(pbpctl_dev->bp_caps_ex & TPL2_CAP_EX)) {\r\npbpctl_dev->bp_tpl_flag = tpl_mode;\r\nif (!tpl_mode)\r\ntpl_hw_off(pbpctl_dev);\r\nelse\r\ntpl_hw_on(pbpctl_dev);\r\n} else\r\nset_bypass_tpl_auto(pbpctl_dev, tpl_mode);\r\nreturn 0;\r\n}\r\nreturn BP_NOT_CAP;\r\n}\r\nint get_tpl_fn(bpctl_dev_t *pbpctl_dev)\r\n{\r\nint ret = BP_NOT_CAP;\r\nif (!pbpctl_dev)\r\nreturn -1;\r\nif (pbpctl_dev->bp_caps & TPL_CAP) {\r\nif (pbpctl_dev->bp_caps_ex & TPL2_CAP_EX)\r\nreturn tpl2_flag_status(pbpctl_dev);\r\nret = pbpctl_dev->bp_tpl_flag;\r\n}\r\nreturn ret;\r\n}\r\nint set_bp_wait_at_pwup_fn(bpctl_dev_t *pbpctl_dev, int tap_mode)\r\n{\r\nif (!pbpctl_dev)\r\nreturn -1;\r\nif (pbpctl_dev->bp_caps & SW_CTL_CAP) {\r\ncmnd_on(pbpctl_dev);\r\nif (!tap_mode)\r\nbp_wait_at_pwup_dis(pbpctl_dev);\r\nelse\r\nbp_wait_at_pwup_en(pbpctl_dev);\r\ncmnd_off(pbpctl_dev);\r\nreturn BP_OK;\r\n}\r\nreturn BP_NOT_CAP;\r\n}\r\nint get_bp_wait_at_pwup_fn(bpctl_dev_t *pbpctl_dev)\r\n{\r\nint ret = 0;\r\nif (!pbpctl_dev)\r\nreturn -1;\r\nret = bp_wait_at_pwup_status(pbpctl_dev);\r\nreturn ret;\r\n}\r\nint set_bp_hw_reset_fn(bpctl_dev_t *pbpctl_dev, int tap_mode)\r\n{\r\nif (!pbpctl_dev)\r\nreturn -1;\r\nif (pbpctl_dev->bp_caps & SW_CTL_CAP) {\r\ncmnd_on(pbpctl_dev);\r\nif (!tap_mode)\r\nbp_hw_reset_dis(pbpctl_dev);\r\nelse\r\nbp_hw_reset_en(pbpctl_dev);\r\ncmnd_off(pbpctl_dev);\r\nreturn BP_OK;\r\n}\r\nreturn BP_NOT_CAP;\r\n}\r\nint get_bp_hw_reset_fn(bpctl_dev_t *pbpctl_dev)\r\n{\r\nint ret = 0;\r\nif (!pbpctl_dev)\r\nreturn -1;\r\nret = bp_hw_reset_status(pbpctl_dev);\r\nreturn ret;\r\n}\r\nint get_bypass_info_fn(bpctl_dev_t *pbpctl_dev, char *dev_name,\r\nchar *add_param)\r\n{\r\nif (!pbpctl_dev)\r\nreturn -1;\r\nif (!is_bypass_fn(pbpctl_dev))\r\nreturn -1;\r\nstrcpy(dev_name, pbpctl_dev->name);\r\n*add_param = pbpctl_dev->bp_fw_ver;\r\nreturn 0;\r\n}\r\nint get_dev_idx_bsf(int bus, int slot, int func)\r\n{\r\nint idx_dev = 0;\r\nfor (idx_dev = 0;\r\n((bpctl_dev_arr[idx_dev].pdev != NULL) && (idx_dev < device_num));\r\nidx_dev++) {\r\nif ((bus == bpctl_dev_arr[idx_dev].bus)\r\n&& (slot == bpctl_dev_arr[idx_dev].slot)\r\n&& (func == bpctl_dev_arr[idx_dev].func))\r\nreturn idx_dev;\r\n}\r\nreturn -1;\r\n}\r\nstatic void str_low(char *str)\r\n{\r\nint i;\r\nfor (i = 0; i < strlen(str); i++)\r\nif ((str[i] >= 65) && (str[i] <= 90))\r\nstr[i] += 32;\r\n}\r\nstatic unsigned long str_to_hex(char *p)\r\n{\r\nunsigned long hex = 0;\r\nunsigned long length = strlen(p), shift = 0;\r\nunsigned char dig = 0;\r\nstr_low(p);\r\nlength = strlen(p);\r\nif (length == 0)\r\nreturn 0;\r\ndo {\r\ndig = p[--length];\r\ndig = dig < 'a' ? (dig - '0') : (dig - 'a' + 0xa);\r\nhex |= (dig << shift);\r\nshift += 4;\r\n} while (length);\r\nreturn hex;\r\n}\r\nstatic int get_dev_idx(int ifindex)\r\n{\r\nint idx_dev = 0;\r\nfor (idx_dev = 0;\r\n((bpctl_dev_arr[idx_dev].pdev != NULL) && (idx_dev < device_num));\r\nidx_dev++) {\r\nif (ifindex == bpctl_dev_arr[idx_dev].ifindex)\r\nreturn idx_dev;\r\n}\r\nreturn -1;\r\n}\r\nstatic bpctl_dev_t *get_dev_idx_p(int ifindex)\r\n{\r\nint idx_dev = 0;\r\nfor (idx_dev = 0;\r\n((bpctl_dev_arr[idx_dev].pdev != NULL) && (idx_dev < device_num));\r\nidx_dev++) {\r\nif (ifindex == bpctl_dev_arr[idx_dev].ifindex)\r\nreturn &bpctl_dev_arr[idx_dev];\r\n}\r\nreturn NULL;\r\n}\r\nstatic void if_scan_init(void)\r\n{\r\nint idx_dev = 0;\r\nstruct net_device *dev;\r\nint ifindex;\r\nfor_each_netdev(&init_net, dev) {\r\nstruct ethtool_drvinfo drvinfo;\r\nchar cbuf[32];\r\nchar *buf = NULL;\r\nchar res[10];\r\nint i = 0;\r\nint bus = 0, slot = 0, func = 0;\r\nifindex = dev->ifindex;\r\nmemset(res, 0, 10);\r\nmemset(&drvinfo, 0, sizeof(struct ethtool_drvinfo));\r\nif (dev->ethtool_ops && dev->ethtool_ops->get_drvinfo) {\r\nmemset(&drvinfo, 0, sizeof(drvinfo));\r\ndev->ethtool_ops->get_drvinfo(dev, &drvinfo);\r\n} else\r\ncontinue;\r\nif (!strcmp(drvinfo.bus_info, "N/A"))\r\ncontinue;\r\nmemcpy(&cbuf, drvinfo.bus_info, 32);\r\nbuf = &cbuf[0];\r\nwhile (*buf++ != ':') ;\r\nfor (i = 0; i < 10; i++, buf++) {\r\nif (*buf == ':')\r\nbreak;\r\nres[i] = *buf;\r\n}\r\nbuf++;\r\nbus = str_to_hex(res);\r\nmemset(res, 0, 10);\r\nfor (i = 0; i < 10; i++, buf++) {\r\nif (*buf == '.')\r\nbreak;\r\nres[i] = *buf;\r\n}\r\nbuf++;\r\nslot = str_to_hex(res);\r\nfunc = str_to_hex(buf);\r\nidx_dev = get_dev_idx_bsf(bus, slot, func);\r\nif (idx_dev != -1) {\r\nbpctl_dev_arr[idx_dev].ifindex = ifindex;\r\nbpctl_dev_arr[idx_dev].ndev = dev;\r\n}\r\n}\r\n}\r\nstatic long device_ioctl(struct file *file,\r\nunsigned int ioctl_num,\r\nunsigned long ioctl_param)\r\n{\r\nstruct bpctl_cmd bpctl_cmd;\r\nint dev_idx = 0;\r\nbpctl_dev_t *pbpctl_dev_out;\r\nvoid __user *argp = (void __user *)ioctl_param;\r\nint ret = 0;\r\nunsigned long flags;\r\nstatic bpctl_dev_t *pbpctl_dev;\r\nlock_bpctl();\r\nif (ioctl_num == IOCTL_TX_MSG(IF_SCAN)) {\r\nif_scan_init();\r\nret = SUCCESS;\r\ngoto bp_exit;\r\n}\r\nif (copy_from_user(&bpctl_cmd, argp, sizeof(struct bpctl_cmd))) {\r\nret = -EFAULT;\r\ngoto bp_exit;\r\n}\r\nif (ioctl_num == IOCTL_TX_MSG(GET_DEV_NUM)) {\r\nbpctl_cmd.out_param[0] = device_num;\r\nif (copy_to_user\r\n(argp, (void *)&bpctl_cmd, sizeof(struct bpctl_cmd))) {\r\nret = -EFAULT;\r\ngoto bp_exit;\r\n}\r\nret = SUCCESS;\r\ngoto bp_exit;\r\n}\r\nlocal_irq_save(flags);\r\nif (!spin_trylock(&bpvm_lock)) {\r\nlocal_irq_restore(flags);\r\nunlock_bpctl();\r\nreturn -1;\r\n}\r\nif ((bpctl_cmd.in_param[5]) ||\r\n(bpctl_cmd.in_param[6]) || (bpctl_cmd.in_param[7]))\r\ndev_idx = get_dev_idx_bsf(bpctl_cmd.in_param[5],\r\nbpctl_cmd.in_param[6],\r\nbpctl_cmd.in_param[7]);\r\nelse if (bpctl_cmd.in_param[1] == 0)\r\ndev_idx = bpctl_cmd.in_param[0];\r\nelse\r\ndev_idx = get_dev_idx(bpctl_cmd.in_param[1]);\r\nif (dev_idx < 0 || dev_idx > device_num) {\r\nret = -EOPNOTSUPP;\r\nspin_unlock_irqrestore(&bpvm_lock, flags);\r\ngoto bp_exit;\r\n}\r\nbpctl_cmd.out_param[0] = bpctl_dev_arr[dev_idx].bus;\r\nbpctl_cmd.out_param[1] = bpctl_dev_arr[dev_idx].slot;\r\nbpctl_cmd.out_param[2] = bpctl_dev_arr[dev_idx].func;\r\nbpctl_cmd.out_param[3] = bpctl_dev_arr[dev_idx].ifindex;\r\nif ((bpctl_dev_arr[dev_idx].bp_10gb)\r\n&& (!(bpctl_dev_arr[dev_idx].ifindex))) {\r\nprintk("Please load network driver for %s adapter!\n",\r\nbpctl_dev_arr[dev_idx].name);\r\nbpctl_cmd.status = -1;\r\nret = SUCCESS;\r\nspin_unlock_irqrestore(&bpvm_lock, flags);\r\ngoto bp_exit;\r\n}\r\nif ((bpctl_dev_arr[dev_idx].bp_10gb) && (bpctl_dev_arr[dev_idx].ndev)) {\r\nif (!(bpctl_dev_arr[dev_idx].ndev->flags & IFF_UP)) {\r\nif (!(bpctl_dev_arr[dev_idx].ndev->flags & IFF_UP)) {\r\nprintk\r\n("Please bring up network interfaces for %s adapter!\n",\r\nbpctl_dev_arr[dev_idx].name);\r\nbpctl_cmd.status = -1;\r\nret = SUCCESS;\r\nspin_unlock_irqrestore(&bpvm_lock, flags);\r\ngoto bp_exit;\r\n}\r\n}\r\n}\r\nif ((dev_idx < 0) || (dev_idx > device_num)\r\n|| (bpctl_dev_arr[dev_idx].pdev == NULL)) {\r\nbpctl_cmd.status = -1;\r\ngoto bpcmd_exit;\r\n}\r\npbpctl_dev = &bpctl_dev_arr[dev_idx];\r\nswitch (ioctl_num) {\r\ncase IOCTL_TX_MSG(SET_BYPASS_PWOFF):\r\nbpctl_cmd.status =\r\nset_bypass_pwoff_fn(pbpctl_dev, bpctl_cmd.in_param[2]);\r\nbreak;\r\ncase IOCTL_TX_MSG(GET_BYPASS_PWOFF):\r\nbpctl_cmd.status = get_bypass_pwoff_fn(pbpctl_dev);\r\nbreak;\r\ncase IOCTL_TX_MSG(SET_BYPASS_PWUP):\r\nbpctl_cmd.status =\r\nset_bypass_pwup_fn(pbpctl_dev, bpctl_cmd.in_param[2]);\r\nbreak;\r\ncase IOCTL_TX_MSG(GET_BYPASS_PWUP):\r\nbpctl_cmd.status = get_bypass_pwup_fn(pbpctl_dev);\r\nbreak;\r\ncase IOCTL_TX_MSG(SET_BYPASS_WD):\r\nbpctl_cmd.status =\r\nset_bypass_wd_fn(pbpctl_dev, bpctl_cmd.in_param[2]);\r\nbreak;\r\ncase IOCTL_TX_MSG(GET_BYPASS_WD):\r\nbpctl_cmd.status =\r\nget_bypass_wd_fn(pbpctl_dev, (int *)&(bpctl_cmd.data[0]));\r\nbreak;\r\ncase IOCTL_TX_MSG(GET_WD_EXPIRE_TIME):\r\nbpctl_cmd.status =\r\nget_wd_expire_time_fn(pbpctl_dev,\r\n(int *)&(bpctl_cmd.data[0]));\r\nbreak;\r\ncase IOCTL_TX_MSG(RESET_BYPASS_WD_TIMER):\r\nbpctl_cmd.status = reset_bypass_wd_timer_fn(pbpctl_dev);\r\nbreak;\r\ncase IOCTL_TX_MSG(GET_WD_SET_CAPS):\r\nbpctl_cmd.status = get_wd_set_caps_fn(pbpctl_dev);\r\nbreak;\r\ncase IOCTL_TX_MSG(SET_STD_NIC):\r\nbpctl_cmd.status =\r\nset_std_nic_fn(pbpctl_dev, bpctl_cmd.in_param[2]);\r\nbreak;\r\ncase IOCTL_TX_MSG(GET_STD_NIC):\r\nbpctl_cmd.status = get_std_nic_fn(pbpctl_dev);\r\nbreak;\r\ncase IOCTL_TX_MSG(SET_TAP):\r\nbpctl_cmd.status =\r\nset_tap_fn(pbpctl_dev, bpctl_cmd.in_param[2]);\r\nbreak;\r\ncase IOCTL_TX_MSG(GET_TAP):\r\nbpctl_cmd.status = get_tap_fn(pbpctl_dev);\r\nbreak;\r\ncase IOCTL_TX_MSG(GET_TAP_CHANGE):\r\nbpctl_cmd.status = get_tap_change_fn(pbpctl_dev);\r\nbreak;\r\ncase IOCTL_TX_MSG(SET_DIS_TAP):\r\nbpctl_cmd.status =\r\nset_dis_tap_fn(pbpctl_dev, bpctl_cmd.in_param[2]);\r\nbreak;\r\ncase IOCTL_TX_MSG(GET_DIS_TAP):\r\nbpctl_cmd.status = get_dis_tap_fn(pbpctl_dev);\r\nbreak;\r\ncase IOCTL_TX_MSG(SET_TAP_PWUP):\r\nbpctl_cmd.status =\r\nset_tap_pwup_fn(pbpctl_dev, bpctl_cmd.in_param[2]);\r\nbreak;\r\ncase IOCTL_TX_MSG(GET_TAP_PWUP):\r\nbpctl_cmd.status = get_tap_pwup_fn(pbpctl_dev);\r\nbreak;\r\ncase IOCTL_TX_MSG(SET_WD_EXP_MODE):\r\nbpctl_cmd.status =\r\nset_wd_exp_mode_fn(pbpctl_dev, bpctl_cmd.in_param[2]);\r\nbreak;\r\ncase IOCTL_TX_MSG(GET_WD_EXP_MODE):\r\nbpctl_cmd.status = get_wd_exp_mode_fn(pbpctl_dev);\r\nbreak;\r\ncase IOCTL_TX_MSG(GET_DIS_BYPASS):\r\nbpctl_cmd.status = get_dis_bypass_fn(pbpctl_dev);\r\nbreak;\r\ncase IOCTL_TX_MSG(SET_DIS_BYPASS):\r\nbpctl_cmd.status =\r\nset_dis_bypass_fn(pbpctl_dev, bpctl_cmd.in_param[2]);\r\nbreak;\r\ncase IOCTL_TX_MSG(GET_BYPASS_CHANGE):\r\nbpctl_cmd.status = get_bypass_change_fn(pbpctl_dev);\r\nbreak;\r\ncase IOCTL_TX_MSG(GET_BYPASS):\r\nbpctl_cmd.status = get_bypass_fn(pbpctl_dev);\r\nbreak;\r\ncase IOCTL_TX_MSG(SET_BYPASS):\r\nbpctl_cmd.status =\r\nset_bypass_fn(pbpctl_dev, bpctl_cmd.in_param[2]);\r\nbreak;\r\ncase IOCTL_TX_MSG(GET_BYPASS_CAPS):\r\nbpctl_cmd.status = get_bypass_caps_fn(pbpctl_dev);\r\nspin_unlock_irqrestore(&bpvm_lock, flags);\r\nif (copy_to_user\r\n(argp, (void *)&bpctl_cmd, sizeof(struct bpctl_cmd))) {\r\nret = -EFAULT;\r\ngoto bp_exit;\r\n}\r\ngoto bp_exit;\r\ncase IOCTL_TX_MSG(GET_BYPASS_SLAVE):\r\nbpctl_cmd.status =\r\nget_bypass_slave_fn(pbpctl_dev, &pbpctl_dev_out);\r\nif (bpctl_cmd.status == 1) {\r\nbpctl_cmd.out_param[4] = pbpctl_dev_out->bus;\r\nbpctl_cmd.out_param[5] = pbpctl_dev_out->slot;\r\nbpctl_cmd.out_param[6] = pbpctl_dev_out->func;\r\nbpctl_cmd.out_param[7] = pbpctl_dev_out->ifindex;\r\n}\r\nbreak;\r\ncase IOCTL_TX_MSG(IS_BYPASS):\r\nbpctl_cmd.status = is_bypass(pbpctl_dev);\r\nbreak;\r\ncase IOCTL_TX_MSG(SET_TX):\r\nbpctl_cmd.status = set_tx_fn(pbpctl_dev, bpctl_cmd.in_param[2]);\r\nbreak;\r\ncase IOCTL_TX_MSG(GET_TX):\r\nbpctl_cmd.status = get_tx_fn(pbpctl_dev);\r\nbreak;\r\ncase IOCTL_TX_MSG(SET_WD_AUTORESET):\r\nbpctl_cmd.status =\r\nset_wd_autoreset_fn(pbpctl_dev, bpctl_cmd.in_param[2]);\r\nbreak;\r\ncase IOCTL_TX_MSG(GET_WD_AUTORESET):\r\nbpctl_cmd.status = get_wd_autoreset_fn(pbpctl_dev);\r\nbreak;\r\ncase IOCTL_TX_MSG(SET_DISC):\r\nbpctl_cmd.status =\r\nset_disc_fn(pbpctl_dev, bpctl_cmd.in_param[2]);\r\nbreak;\r\ncase IOCTL_TX_MSG(GET_DISC):\r\nbpctl_cmd.status = get_disc_fn(pbpctl_dev);\r\nbreak;\r\ncase IOCTL_TX_MSG(GET_DISC_CHANGE):\r\nbpctl_cmd.status = get_disc_change_fn(pbpctl_dev);\r\nbreak;\r\ncase IOCTL_TX_MSG(SET_DIS_DISC):\r\nbpctl_cmd.status =\r\nset_dis_disc_fn(pbpctl_dev, bpctl_cmd.in_param[2]);\r\nbreak;\r\ncase IOCTL_TX_MSG(GET_DIS_DISC):\r\nbpctl_cmd.status = get_dis_disc_fn(pbpctl_dev);\r\nbreak;\r\ncase IOCTL_TX_MSG(SET_DISC_PWUP):\r\nbpctl_cmd.status =\r\nset_disc_pwup_fn(pbpctl_dev, bpctl_cmd.in_param[2]);\r\nbreak;\r\ncase IOCTL_TX_MSG(GET_DISC_PWUP):\r\nbpctl_cmd.status = get_disc_pwup_fn(pbpctl_dev);\r\nbreak;\r\ncase IOCTL_TX_MSG(GET_BYPASS_INFO):\r\nbpctl_cmd.status =\r\nget_bypass_info_fn(pbpctl_dev, (char *)&bpctl_cmd.data,\r\n(char *)&bpctl_cmd.out_param[4]);\r\nbreak;\r\ncase IOCTL_TX_MSG(SET_TPL):\r\nbpctl_cmd.status =\r\nset_tpl_fn(pbpctl_dev, bpctl_cmd.in_param[2]);\r\nbreak;\r\ncase IOCTL_TX_MSG(GET_TPL):\r\nbpctl_cmd.status = get_tpl_fn(pbpctl_dev);\r\nbreak;\r\ncase IOCTL_TX_MSG(SET_BP_WAIT_AT_PWUP):\r\nbpctl_cmd.status =\r\nset_bp_wait_at_pwup_fn(pbpctl_dev, bpctl_cmd.in_param[2]);\r\nbreak;\r\ncase IOCTL_TX_MSG(GET_BP_WAIT_AT_PWUP):\r\nbpctl_cmd.status = get_bp_wait_at_pwup_fn(pbpctl_dev);\r\nbreak;\r\ncase IOCTL_TX_MSG(SET_BP_HW_RESET):\r\nbpctl_cmd.status =\r\nset_bp_hw_reset_fn(pbpctl_dev, bpctl_cmd.in_param[2]);\r\nbreak;\r\ncase IOCTL_TX_MSG(GET_BP_HW_RESET):\r\nbpctl_cmd.status = get_bp_hw_reset_fn(pbpctl_dev);\r\nbreak;\r\n#ifdef BP_SELF_TEST\r\ncase IOCTL_TX_MSG(SET_BP_SELF_TEST):\r\nbpctl_cmd.status =\r\nset_bp_self_test_fn(pbpctl_dev, bpctl_cmd.in_param[2]);\r\nbreak;\r\ncase IOCTL_TX_MSG(GET_BP_SELF_TEST):\r\nbpctl_cmd.status = get_bp_self_test_fn(pbpctl_dev);\r\nbreak;\r\n#endif\r\n#if 0\r\ncase IOCTL_TX_MSG(SET_DISC_PORT):\r\nbpctl_cmd.status =\r\nset_disc_port_fn(pbpctl_dev, bpctl_cmd.in_param[2]);\r\nbreak;\r\ncase IOCTL_TX_MSG(GET_DISC_PORT):\r\nbpctl_cmd.status = get_disc_port_fn(pbpctl_dev);\r\nbreak;\r\ncase IOCTL_TX_MSG(SET_DISC_PORT_PWUP):\r\nbpctl_cmd.status =\r\nset_disc_port_pwup_fn(pbpctl_dev, bpctl_cmd.in_param[2]);\r\nbreak;\r\ncase IOCTL_TX_MSG(GET_DISC_PORT_PWUP):\r\nbpctl_cmd.status = get_disc_port_pwup_fn(pbpctl_dev);\r\nbreak;\r\n#endif\r\ncase IOCTL_TX_MSG(SET_BP_FORCE_LINK):\r\nbpctl_cmd.status =\r\nset_bp_force_link_fn(dev_idx, bpctl_cmd.in_param[2]);\r\nbreak;\r\ncase IOCTL_TX_MSG(GET_BP_FORCE_LINK):\r\nbpctl_cmd.status = get_bp_force_link_fn(dev_idx);\r\nbreak;\r\ndefault:\r\nret = -EOPNOTSUPP;\r\nspin_unlock_irqrestore(&bpvm_lock, flags);\r\ngoto bp_exit;\r\n}\r\nbpcmd_exit:\r\nspin_unlock_irqrestore(&bpvm_lock, flags);\r\nif (copy_to_user(argp, (void *)&bpctl_cmd, sizeof(struct bpctl_cmd)))\r\nret = -EFAULT;\r\nret = SUCCESS;\r\nbp_exit:\r\nunlock_bpctl();\r\nreturn ret;\r\n}\r\nstatic int __init bypass_init_module(void)\r\n{\r\nint ret_val, idx, idx_dev = 0;\r\nstruct pci_dev *pdev1 = NULL;\r\nunsigned long mmio_start, mmio_len;\r\nprintk(BP_MOD_DESCR " v" BP_MOD_VER "\n");\r\nret_val = register_chrdev(major_num, DEVICE_NAME, &Fops);\r\nif (ret_val < 0) {\r\nprintk("%s failed with %d\n", DEVICE_NAME, ret_val);\r\nreturn ret_val;\r\n}\r\nmajor_num = ret_val;\r\nfor (idx = 0; tx_ctl_pci_tbl[idx].vendor; idx++) {\r\nwhile ((pdev1 = pci_get_subsys(tx_ctl_pci_tbl[idx].vendor,\r\ntx_ctl_pci_tbl[idx].device,\r\ntx_ctl_pci_tbl[idx].subvendor,\r\ntx_ctl_pci_tbl[idx].subdevice,\r\npdev1))) {\r\ndevice_num++;\r\n}\r\n}\r\nif (!device_num) {\r\nprintk("No such device\n");\r\nunregister_chrdev(major_num, DEVICE_NAME);\r\nreturn -1;\r\n}\r\nbpctl_dev_arr = kmalloc((device_num) * sizeof(bpctl_dev_t), GFP_KERNEL);\r\nif (!bpctl_dev_arr) {\r\nprintk("Allocation error\n");\r\nunregister_chrdev(major_num, DEVICE_NAME);\r\nreturn -1;\r\n}\r\nmemset(bpctl_dev_arr, 0, ((device_num) * sizeof(bpctl_dev_t)));\r\npdev1 = NULL;\r\nfor (idx = 0; tx_ctl_pci_tbl[idx].vendor; idx++) {\r\nwhile ((pdev1 = pci_get_subsys(tx_ctl_pci_tbl[idx].vendor,\r\ntx_ctl_pci_tbl[idx].device,\r\ntx_ctl_pci_tbl[idx].subvendor,\r\ntx_ctl_pci_tbl[idx].subdevice,\r\npdev1))) {\r\nbpctl_dev_arr[idx_dev].pdev = pdev1;\r\nmmio_start = pci_resource_start(pdev1, 0);\r\nmmio_len = pci_resource_len(pdev1, 0);\r\nbpctl_dev_arr[idx_dev].desc =\r\ndev_desc[tx_ctl_pci_tbl[idx].index].name;\r\nbpctl_dev_arr[idx_dev].name =\r\ntx_ctl_pci_tbl[idx].bp_name;\r\nbpctl_dev_arr[idx_dev].device =\r\ntx_ctl_pci_tbl[idx].device;\r\nbpctl_dev_arr[idx_dev].vendor =\r\ntx_ctl_pci_tbl[idx].vendor;\r\nbpctl_dev_arr[idx_dev].subdevice =\r\ntx_ctl_pci_tbl[idx].subdevice;\r\nbpctl_dev_arr[idx_dev].subvendor =\r\ntx_ctl_pci_tbl[idx].subvendor;\r\nbpctl_dev_arr[idx_dev].func = PCI_FUNC(pdev1->devfn);\r\nbpctl_dev_arr[idx_dev].slot = PCI_SLOT(pdev1->devfn);\r\nbpctl_dev_arr[idx_dev].bus = pdev1->bus->number;\r\nbpctl_dev_arr[idx_dev].mem_map =\r\n(unsigned long)ioremap(mmio_start, mmio_len);\r\n#ifdef BP_SYNC_FLAG\r\nspin_lock_init(&bpctl_dev_arr[idx_dev].bypass_wr_lock);\r\n#endif\r\nif (BP10G9_IF_SERIES(bpctl_dev_arr[idx_dev].subdevice))\r\nbpctl_dev_arr[idx_dev].bp_10g9 = 1;\r\nif (BP10G_IF_SERIES(bpctl_dev_arr[idx_dev].subdevice))\r\nbpctl_dev_arr[idx_dev].bp_10g = 1;\r\nif (PEG540_IF_SERIES(bpctl_dev_arr[idx_dev].subdevice)) {\r\nbpctl_dev_arr[idx_dev].bp_540 = 1;\r\n}\r\nif (PEGF5_IF_SERIES(bpctl_dev_arr[idx_dev].subdevice))\r\nbpctl_dev_arr[idx_dev].bp_fiber5 = 1;\r\nif (PEG80_IF_SERIES(bpctl_dev_arr[idx_dev].subdevice))\r\nbpctl_dev_arr[idx_dev].bp_i80 = 1;\r\nif (PEGF80_IF_SERIES(bpctl_dev_arr[idx_dev].subdevice))\r\nbpctl_dev_arr[idx_dev].bp_i80 = 1;\r\nif ((bpctl_dev_arr[idx_dev].subdevice & 0xa00) == 0xa00)\r\nbpctl_dev_arr[idx_dev].bp_i80 = 1;\r\nif (BP10GB_IF_SERIES(bpctl_dev_arr[idx_dev].subdevice)) {\r\nif (bpctl_dev_arr[idx_dev].ifindex == 0) {\r\nunregister_chrdev(major_num,\r\nDEVICE_NAME);\r\nprintk\r\n("Please load network driver for %s adapter!\n",\r\nbpctl_dev_arr[idx_dev].name);\r\nreturn -1;\r\n}\r\nif (bpctl_dev_arr[idx_dev].ndev) {\r\nif (!\r\n(bpctl_dev_arr[idx_dev].ndev->\r\nflags & IFF_UP)) {\r\nif (!\r\n(bpctl_dev_arr[idx_dev].\r\nndev->flags & IFF_UP)) {\r\nunregister_chrdev\r\n(major_num,\r\nDEVICE_NAME);\r\nprintk\r\n("Please bring up network interfaces for %s adapter!\n",\r\nbpctl_dev_arr\r\n[idx_dev].name);\r\nreturn -1;\r\n}\r\n}\r\n}\r\nbpctl_dev_arr[idx_dev].bp_10gb = 1;\r\n}\r\nif (!bpctl_dev_arr[idx_dev].bp_10g9) {\r\nif (is_bypass_fn(&bpctl_dev_arr[idx_dev])) {\r\nprintk(KERN_INFO "%s found, ",\r\nbpctl_dev_arr[idx_dev].name);\r\nif ((OLD_IF_SERIES\r\n(bpctl_dev_arr[idx_dev].subdevice))\r\n||\r\n(INTEL_IF_SERIES\r\n(bpctl_dev_arr[idx_dev].\r\nsubdevice)))\r\nbpctl_dev_arr[idx_dev].\r\nbp_fw_ver = 0xff;\r\nelse\r\nbpctl_dev_arr[idx_dev].\r\nbp_fw_ver =\r\nbypass_fw_ver(&bpctl_dev_arr\r\n[idx_dev]);\r\nif ((bpctl_dev_arr[idx_dev].bp_10gb ==\r\n1)\r\n&& (bpctl_dev_arr[idx_dev].\r\nbp_fw_ver == 0xff)) {\r\nint cnt = 100;\r\nwhile (cnt--) {\r\niounmap((void\r\n*)\r\n(bpctl_dev_arr\r\n[idx_dev].\r\nmem_map));\r\nmmio_start =\r\npci_resource_start\r\n(pdev1, 0);\r\nmmio_len =\r\npci_resource_len\r\n(pdev1, 0);\r\nbpctl_dev_arr[idx_dev].\r\nmem_map =\r\n(unsigned long)\r\nioremap(mmio_start,\r\nmmio_len);\r\nbpctl_dev_arr[idx_dev].\r\nbp_fw_ver =\r\nbypass_fw_ver\r\n(&bpctl_dev_arr\r\n[idx_dev]);\r\nif (bpctl_dev_arr\r\n[idx_dev].\r\nbp_fw_ver == 0xa8)\r\nbreak;\r\n}\r\n}\r\nprintk("firmware version: 0x%x\n",\r\nbpctl_dev_arr[idx_dev].\r\nbp_fw_ver);\r\n}\r\nbpctl_dev_arr[idx_dev].wdt_status =\r\nWDT_STATUS_UNKNOWN;\r\nbpctl_dev_arr[idx_dev].reset_time = 0;\r\natomic_set(&bpctl_dev_arr[idx_dev].wdt_busy, 0);\r\nbpctl_dev_arr[idx_dev].bp_status_un = 1;\r\nbypass_caps_init(&bpctl_dev_arr[idx_dev]);\r\ninit_bypass_wd_auto(&bpctl_dev_arr[idx_dev]);\r\ninit_bypass_tpl_auto(&bpctl_dev_arr[idx_dev]);\r\nif (NOKIA_SERIES\r\n(bpctl_dev_arr[idx_dev].subdevice))\r\nreset_cont(&bpctl_dev_arr[idx_dev]);\r\n}\r\n#ifdef BP_SELF_TEST\r\nif ((bpctl_dev_arr[idx_dev].bp_tx_data =\r\nkmalloc(BPTEST_DATA_LEN, GFP_KERNEL))) {\r\nmemset(bpctl_dev_arr[idx_dev].bp_tx_data, 0x0,\r\nBPTEST_DATA_LEN);\r\nmemset(bpctl_dev_arr[idx_dev].bp_tx_data, 0xff,\r\n6);\r\nmemset(bpctl_dev_arr[idx_dev].bp_tx_data + 6,\r\n0x0, 1);\r\nmemset(bpctl_dev_arr[idx_dev].bp_tx_data + 7,\r\n0xaa, 5);\r\n*(__be16 *) (bpctl_dev_arr[idx_dev].bp_tx_data +\r\n12) = htons(ETH_P_BPTEST);\r\n} else\r\nprintk("bp_ctl: Memory allocation error!\n");\r\n#endif\r\nidx_dev++;\r\n}\r\n}\r\nif_scan_init();\r\nsema_init(&bpctl_sema, 1);\r\nspin_lock_init(&bpvm_lock);\r\n{\r\nbpctl_dev_t *pbpctl_dev_c = NULL;\r\nfor (idx_dev = 0;\r\n((bpctl_dev_arr[idx_dev].pdev != NULL)\r\n&& (idx_dev < device_num)); idx_dev++) {\r\nif (bpctl_dev_arr[idx_dev].bp_10g9) {\r\npbpctl_dev_c =\r\nget_status_port_fn(&bpctl_dev_arr[idx_dev]);\r\nif (is_bypass_fn(&bpctl_dev_arr[idx_dev])) {\r\nprintk(KERN_INFO "%s found, ",\r\nbpctl_dev_arr[idx_dev].name);\r\nbpctl_dev_arr[idx_dev].bp_fw_ver =\r\nbypass_fw_ver(&bpctl_dev_arr\r\n[idx_dev]);\r\nprintk("firmware version: 0x%x\n",\r\nbpctl_dev_arr[idx_dev].\r\nbp_fw_ver);\r\n}\r\nbpctl_dev_arr[idx_dev].wdt_status =\r\nWDT_STATUS_UNKNOWN;\r\nbpctl_dev_arr[idx_dev].reset_time = 0;\r\natomic_set(&bpctl_dev_arr[idx_dev].wdt_busy, 0);\r\nbpctl_dev_arr[idx_dev].bp_status_un = 1;\r\nbypass_caps_init(&bpctl_dev_arr[idx_dev]);\r\ninit_bypass_wd_auto(&bpctl_dev_arr[idx_dev]);\r\ninit_bypass_tpl_auto(&bpctl_dev_arr[idx_dev]);\r\n}\r\n}\r\n}\r\nregister_netdevice_notifier(&bp_notifier_block);\r\n#ifdef BP_PROC_SUPPORT\r\n{\r\nint i = 0;\r\nbp_proc_create();\r\nfor (i = 0; i < device_num; i++) {\r\nif (bpctl_dev_arr[i].ifindex) {\r\nbypass_proc_remove_dev_sd(&bpctl_dev_arr[i]);\r\nbypass_proc_create_dev_sd(&bpctl_dev_arr[i]);\r\n}\r\n}\r\n}\r\n#endif\r\nreturn 0;\r\n}\r\nstatic void __exit bypass_cleanup_module(void)\r\n{\r\nint i;\r\nunregister_netdevice_notifier(&bp_notifier_block);\r\nfor (i = 0; i < device_num; i++) {\r\n#ifdef BP_PROC_SUPPORT\r\nbypass_proc_remove_dev_sd(&bpctl_dev_arr[i]);\r\n#endif\r\nremove_bypass_wd_auto(&bpctl_dev_arr[i]);\r\nbpctl_dev_arr[i].reset_time = 0;\r\nremove_bypass_tpl_auto(&bpctl_dev_arr[i]);\r\n}\r\nfor (i = 0; i < device_num; i++) {\r\n#ifdef BP_SELF_TEST\r\nif (bpctl_dev_arr[i].bp_tx_data)\r\nkfree(bpctl_dev_arr[i].bp_tx_data);\r\n#endif\r\niounmap((void *)(bpctl_dev_arr[i].mem_map));\r\n}\r\nif (bpctl_dev_arr)\r\nkfree(bpctl_dev_arr);\r\nunregister_chrdev(major_num, DEVICE_NAME);\r\n}\r\nint is_bypass_sd(int ifindex)\r\n{\r\nreturn is_bypass(get_dev_idx_p(ifindex));\r\n}\r\nint set_bypass_sd(int ifindex, int bypass_mode)\r\n{\r\nreturn set_bypass_fn(get_dev_idx_p(ifindex), bypass_mode);\r\n}\r\nint get_bypass_sd(int ifindex)\r\n{\r\nreturn get_bypass_fn(get_dev_idx_p(ifindex));\r\n}\r\nint get_bypass_change_sd(int ifindex)\r\n{\r\nreturn get_bypass_change_fn(get_dev_idx_p(ifindex));\r\n}\r\nint set_dis_bypass_sd(int ifindex, int dis_param)\r\n{\r\nreturn set_dis_bypass_fn(get_dev_idx_p(ifindex), dis_param);\r\n}\r\nint get_dis_bypass_sd(int ifindex)\r\n{\r\nreturn get_dis_bypass_fn(get_dev_idx_p(ifindex));\r\n}\r\nint set_bypass_pwoff_sd(int ifindex, int bypass_mode)\r\n{\r\nreturn set_bypass_pwoff_fn(get_dev_idx_p(ifindex), bypass_mode);\r\n}\r\nint get_bypass_pwoff_sd(int ifindex)\r\n{\r\nreturn get_bypass_pwoff_fn(get_dev_idx_p(ifindex));\r\n}\r\nint set_bypass_pwup_sd(int ifindex, int bypass_mode)\r\n{\r\nreturn set_bypass_pwup_fn(get_dev_idx_p(ifindex), bypass_mode);\r\n}\r\nint get_bypass_pwup_sd(int ifindex)\r\n{\r\nreturn get_bypass_pwup_fn(get_dev_idx_p(ifindex));\r\n}\r\nint set_bypass_wd_sd(int if_index, int ms_timeout, int *ms_timeout_set)\r\n{\r\nif ((is_bypass(get_dev_idx_p(if_index))) <= 0)\r\nreturn BP_NOT_CAP;\r\n*ms_timeout_set = set_bypass_wd_fn(get_dev_idx_p(if_index), ms_timeout);\r\nreturn 0;\r\n}\r\nint get_bypass_wd_sd(int ifindex, int *timeout)\r\n{\r\nreturn get_bypass_wd_fn(get_dev_idx_p(ifindex), timeout);\r\n}\r\nint get_wd_expire_time_sd(int ifindex, int *time_left)\r\n{\r\nreturn get_wd_expire_time_fn(get_dev_idx_p(ifindex), time_left);\r\n}\r\nint reset_bypass_wd_timer_sd(int ifindex)\r\n{\r\nreturn reset_bypass_wd_timer_fn(get_dev_idx_p(ifindex));\r\n}\r\nint get_wd_set_caps_sd(int ifindex)\r\n{\r\nreturn get_wd_set_caps_fn(get_dev_idx_p(ifindex));\r\n}\r\nint set_std_nic_sd(int ifindex, int nic_mode)\r\n{\r\nreturn set_std_nic_fn(get_dev_idx_p(ifindex), nic_mode);\r\n}\r\nint get_std_nic_sd(int ifindex)\r\n{\r\nreturn get_std_nic_fn(get_dev_idx_p(ifindex));\r\n}\r\nint set_tap_sd(int ifindex, int tap_mode)\r\n{\r\nreturn set_tap_fn(get_dev_idx_p(ifindex), tap_mode);\r\n}\r\nint get_tap_sd(int ifindex)\r\n{\r\nreturn get_tap_fn(get_dev_idx_p(ifindex));\r\n}\r\nint set_tap_pwup_sd(int ifindex, int tap_mode)\r\n{\r\nreturn set_tap_pwup_fn(get_dev_idx_p(ifindex), tap_mode);\r\n}\r\nint get_tap_pwup_sd(int ifindex)\r\n{\r\nreturn get_tap_pwup_fn(get_dev_idx_p(ifindex));\r\n}\r\nint get_tap_change_sd(int ifindex)\r\n{\r\nreturn get_tap_change_fn(get_dev_idx_p(ifindex));\r\n}\r\nint set_dis_tap_sd(int ifindex, int dis_param)\r\n{\r\nreturn set_dis_tap_fn(get_dev_idx_p(ifindex), dis_param);\r\n}\r\nint get_dis_tap_sd(int ifindex)\r\n{\r\nreturn get_dis_tap_fn(get_dev_idx_p(ifindex));\r\n}\r\nint set_bp_disc_sd(int ifindex, int disc_mode)\r\n{\r\nreturn set_disc_fn(get_dev_idx_p(ifindex), disc_mode);\r\n}\r\nint get_bp_disc_sd(int ifindex)\r\n{\r\nreturn get_disc_fn(get_dev_idx_p(ifindex));\r\n}\r\nint set_bp_disc_pwup_sd(int ifindex, int disc_mode)\r\n{\r\nreturn set_disc_pwup_fn(get_dev_idx_p(ifindex), disc_mode);\r\n}\r\nint get_bp_disc_pwup_sd(int ifindex)\r\n{\r\nreturn get_disc_pwup_fn(get_dev_idx_p(ifindex));\r\n}\r\nint get_bp_disc_change_sd(int ifindex)\r\n{\r\nreturn get_disc_change_fn(get_dev_idx_p(ifindex));\r\n}\r\nint set_bp_dis_disc_sd(int ifindex, int dis_param)\r\n{\r\nreturn set_dis_disc_fn(get_dev_idx_p(ifindex), dis_param);\r\n}\r\nint get_bp_dis_disc_sd(int ifindex)\r\n{\r\nreturn get_dis_disc_fn(get_dev_idx_p(ifindex));\r\n}\r\nint get_wd_exp_mode_sd(int ifindex)\r\n{\r\nreturn get_wd_exp_mode_fn(get_dev_idx_p(ifindex));\r\n}\r\nint set_wd_exp_mode_sd(int ifindex, int param)\r\n{\r\nreturn set_wd_exp_mode_fn(get_dev_idx_p(ifindex), param);\r\n}\r\nint reset_cont_sd(int ifindex)\r\n{\r\nreturn reset_cont_fn(get_dev_idx_p(ifindex));\r\n}\r\nint set_tx_sd(int ifindex, int tx_state)\r\n{\r\nreturn set_tx_fn(get_dev_idx_p(ifindex), tx_state);\r\n}\r\nint set_tpl_sd(int ifindex, int tpl_state)\r\n{\r\nreturn set_tpl_fn(get_dev_idx_p(ifindex), tpl_state);\r\n}\r\nint set_bp_hw_reset_sd(int ifindex, int status)\r\n{\r\nreturn set_bp_hw_reset_fn(get_dev_idx_p(ifindex), status);\r\n}\r\nint set_wd_autoreset_sd(int ifindex, int param)\r\n{\r\nreturn set_wd_autoreset_fn(get_dev_idx_p(ifindex), param);\r\n}\r\nint get_wd_autoreset_sd(int ifindex)\r\n{\r\nreturn get_wd_autoreset_fn(get_dev_idx_p(ifindex));\r\n}\r\nint get_bypass_caps_sd(int ifindex)\r\n{\r\nreturn get_bypass_caps_fn(get_dev_idx_p(ifindex));\r\n}\r\nint get_bypass_slave_sd(int ifindex)\r\n{\r\nbpctl_dev_t *pbpctl_dev_out;\r\nint ret = get_bypass_slave_fn(get_dev_idx_p(ifindex), &pbpctl_dev_out);\r\nif (ret == 1)\r\nreturn pbpctl_dev_out->ifindex;\r\nreturn -1;\r\n}\r\nint get_tx_sd(int ifindex)\r\n{\r\nreturn get_tx_fn(get_dev_idx_p(ifindex));\r\n}\r\nint get_tpl_sd(int ifindex)\r\n{\r\nreturn get_tpl_fn(get_dev_idx_p(ifindex));\r\n}\r\nint get_bp_hw_reset_sd(int ifindex)\r\n{\r\nreturn get_bp_hw_reset_fn(get_dev_idx_p(ifindex));\r\n}\r\nint get_bypass_info_sd(int ifindex, struct bp_info *bp_info)\r\n{\r\nreturn get_bypass_info_fn(get_dev_idx_p(ifindex), bp_info->prod_name, &bp_info->fw_ver);\r\n}\r\nint bp_if_scan_sd(void)\r\n{\r\nif_scan_init();\r\nreturn 0;\r\n}\r\nstatic struct proc_dir_entry *proc_getdir(char *name,\r\nstruct proc_dir_entry *proc_dir)\r\n{\r\nstruct proc_dir_entry *pde = proc_dir;\r\nfor (pde = pde->subdir; pde; pde = pde->next) {\r\nif (pde->namelen && (strcmp(name, pde->name) == 0)) {\r\nbreak;\r\n}\r\n}\r\nif (pde == (struct proc_dir_entry *)0) {\r\npde = proc_mkdir(name, proc_dir);\r\nif (pde == (struct proc_dir_entry *)0) {\r\nreturn pde;\r\n}\r\n}\r\nreturn pde;\r\n}\r\nint bp_proc_create(void)\r\n{\r\nbp_procfs_dir = proc_getdir(BP_PROC_DIR, init_net.proc_net);\r\nif (bp_procfs_dir == (struct proc_dir_entry *)0) {\r\nprintk(KERN_DEBUG\r\n"Could not create procfs nicinfo directory %s\n",\r\nBP_PROC_DIR);\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nint\r\nbypass_proc_create_entry_sd(struct pfs_unit_sd *pfs_unit_curr,\r\nchar *proc_name,\r\nwrite_proc_t *write_proc,\r\nread_proc_t *read_proc,\r\nstruct proc_dir_entry *parent_pfs, void *data)\r\n{\r\nstrcpy(pfs_unit_curr->proc_name, proc_name);\r\npfs_unit_curr->proc_entry = create_proc_entry(pfs_unit_curr->proc_name,\r\nS_IFREG | S_IRUSR |\r\nS_IWUSR | S_IRGRP |\r\nS_IROTH, parent_pfs);\r\nif (pfs_unit_curr->proc_entry == NULL)\r\nreturn -1;\r\npfs_unit_curr->proc_entry->read_proc = read_proc;\r\npfs_unit_curr->proc_entry->write_proc = write_proc;\r\npfs_unit_curr->proc_entry->data = data;\r\nreturn 0;\r\n}\r\nint\r\nget_bypass_info_pfs(char *page, char **start, off_t off, int count,\r\nint *eof, void *data)\r\n{\r\nbpctl_dev_t *pbp_device_block = (bpctl_dev_t *) data;\r\nint len = 0;\r\nlen += sprintf(page, "Name\t\t\t%s\n", pbp_device_block->name);\r\nlen +=\r\nsprintf(page + len, "Firmware version\t0x%x\n",\r\npbp_device_block->bp_fw_ver);\r\n*eof = 1;\r\nreturn len;\r\n}\r\nint\r\nget_bypass_slave_pfs(char *page, char **start, off_t off, int count,\r\nint *eof, void *data)\r\n{\r\nbpctl_dev_t *pbp_device_block = (bpctl_dev_t *) data;\r\nint len = 0;\r\nbpctl_dev_t *pbp_device_block_slave = NULL;\r\nint idx_dev = 0;\r\nstruct net_device *net_slave_dev = NULL;\r\nif ((pbp_device_block->func == 0) || (pbp_device_block->func == 2)) {\r\nfor (idx_dev = 0;\r\n((bpctl_dev_arr[idx_dev].pdev != NULL)\r\n&& (idx_dev < device_num)); idx_dev++) {\r\nif ((bpctl_dev_arr[idx_dev].bus ==\r\npbp_device_block->bus)\r\n&& (bpctl_dev_arr[idx_dev].slot ==\r\npbp_device_block->slot)) {\r\nif ((pbp_device_block->func == 0)\r\n&& (bpctl_dev_arr[idx_dev].func == 1)) {\r\npbp_device_block_slave =\r\n&bpctl_dev_arr[idx_dev];\r\nbreak;\r\n}\r\nif ((pbp_device_block->func == 2) &&\r\n(bpctl_dev_arr[idx_dev].func == 3)) {\r\npbp_device_block_slave =\r\n&bpctl_dev_arr[idx_dev];\r\nbreak;\r\n}\r\n}\r\n}\r\n} else\r\npbp_device_block_slave = pbp_device_block;\r\nif (!pbp_device_block_slave) {\r\nlen = sprintf(page, "fail\n");\r\n*eof = 1;\r\nreturn len;\r\n}\r\nnet_slave_dev = pbp_device_block_slave->ndev;\r\nif (net_slave_dev)\r\nlen = sprintf(page, "%s\n", net_slave_dev->name);\r\n*eof = 1;\r\nreturn len;\r\n}\r\nint\r\nget_bypass_caps_pfs(char *page, char **start, off_t off, int count,\r\nint *eof, void *data)\r\n{\r\nbpctl_dev_t *pbp_device_block = (bpctl_dev_t *) data;\r\nint len = 0, ret = 0;\r\nret = get_bypass_caps_fn(pbp_device_block);\r\nif (ret == BP_NOT_CAP)\r\nlen = sprintf(page, "-1\n");\r\nelse\r\nlen = sprintf(page, "0x%x\n", ret);\r\n*eof = 1;\r\nreturn len;\r\n}\r\nint\r\nget_wd_set_caps_pfs(char *page, char **start, off_t off, int count,\r\nint *eof, void *data)\r\n{\r\nbpctl_dev_t *pbp_device_block = (bpctl_dev_t *) data;\r\nint len = 0, ret = 0;\r\nret = get_wd_set_caps_fn(pbp_device_block);\r\nif (ret == BP_NOT_CAP)\r\nlen = sprintf(page, "-1\n");\r\nelse\r\nlen = sprintf(page, "0x%x\n", ret);\r\n*eof = 1;\r\nreturn len;\r\n}\r\nint\r\nset_bypass_pfs(struct file *file, const char *buffer,\r\nunsigned long count, void *data)\r\n{\r\nchar kbuf[256];\r\nbpctl_dev_t *pbp_device_block = (bpctl_dev_t *) data;\r\nint bypass_param = 0, length = 0;\r\nif (count > (sizeof(kbuf) - 1))\r\nreturn -1;\r\nif (copy_from_user(&kbuf, buffer, count)) {\r\nreturn -1;\r\n}\r\nkbuf[count] = '\0';\r\nlength = strlen(kbuf);\r\nif (kbuf[length - 1] == '\n')\r\nkbuf[--length] = '\0';\r\nif (strcmp(kbuf, "on") == 0)\r\nbypass_param = 1;\r\nelse if (strcmp(kbuf, "off") == 0)\r\nbypass_param = 0;\r\nset_bypass_fn(pbp_device_block, bypass_param);\r\nreturn count;\r\n}\r\nint\r\nset_tap_pfs(struct file *file, const char *buffer,\r\nunsigned long count, void *data)\r\n{\r\nchar kbuf[256];\r\nbpctl_dev_t *pbp_device_block = (bpctl_dev_t *) data;\r\nint tap_param = 0, length = 0;\r\nif (count > (sizeof(kbuf) - 1))\r\nreturn -1;\r\nif (copy_from_user(&kbuf, buffer, count)) {\r\nreturn -1;\r\n}\r\nkbuf[count] = '\0';\r\nlength = strlen(kbuf);\r\nif (kbuf[length - 1] == '\n')\r\nkbuf[--length] = '\0';\r\nif (strcmp(kbuf, "on") == 0)\r\ntap_param = 1;\r\nelse if (strcmp(kbuf, "off") == 0)\r\ntap_param = 0;\r\nset_tap_fn(pbp_device_block, tap_param);\r\nreturn count;\r\n}\r\nint\r\nset_disc_pfs(struct file *file, const char *buffer,\r\nunsigned long count, void *data)\r\n{\r\nchar kbuf[256];\r\nbpctl_dev_t *pbp_device_block = (bpctl_dev_t *) data;\r\nint tap_param = 0, length = 0;\r\nif (count > (sizeof(kbuf) - 1))\r\nreturn -1;\r\nif (copy_from_user(&kbuf, buffer, count)) {\r\nreturn -1;\r\n}\r\nkbuf[count] = '\0';\r\nlength = strlen(kbuf);\r\nif (kbuf[length - 1] == '\n')\r\nkbuf[--length] = '\0';\r\nif (strcmp(kbuf, "on") == 0)\r\ntap_param = 1;\r\nelse if (strcmp(kbuf, "off") == 0)\r\ntap_param = 0;\r\nset_disc_fn(pbp_device_block, tap_param);\r\nreturn count;\r\n}\r\nint\r\nget_bypass_pfs(char *page, char **start, off_t off, int count,\r\nint *eof, void *data)\r\n{\r\nbpctl_dev_t *pbp_device_block = (bpctl_dev_t *) data;\r\nint len = 0, ret = 0;\r\nret = get_bypass_fn(pbp_device_block);\r\nif (ret == BP_NOT_CAP)\r\nlen = sprintf(page, "fail\n");\r\nelse if (ret == 1)\r\nlen = sprintf(page, "on\n");\r\nelse if (ret == 0)\r\nlen = sprintf(page, "off\n");\r\n*eof = 1;\r\nreturn len;\r\n}\r\nint\r\nget_tap_pfs(char *page, char **start, off_t off, int count,\r\nint *eof, void *data)\r\n{\r\nbpctl_dev_t *pbp_device_block = (bpctl_dev_t *) data;\r\nint len = 0, ret = 0;\r\nret = get_tap_fn(pbp_device_block);\r\nif (ret == BP_NOT_CAP)\r\nlen = sprintf(page, "fail\n");\r\nelse if (ret == 1)\r\nlen = sprintf(page, "on\n");\r\nelse if (ret == 0)\r\nlen = sprintf(page, "off\n");\r\n*eof = 1;\r\nreturn len;\r\n}\r\nint\r\nget_disc_pfs(char *page, char **start, off_t off, int count,\r\nint *eof, void *data)\r\n{\r\nbpctl_dev_t *pbp_device_block = (bpctl_dev_t *) data;\r\nint len = 0, ret = 0;\r\nret = get_disc_fn(pbp_device_block);\r\nif (ret == BP_NOT_CAP)\r\nlen = sprintf(page, "fail\n");\r\nelse if (ret == 1)\r\nlen = sprintf(page, "on\n");\r\nelse if (ret == 0)\r\nlen = sprintf(page, "off\n");\r\n*eof = 1;\r\nreturn len;\r\n}\r\nint\r\nget_bypass_change_pfs(char *page, char **start, off_t off, int count,\r\nint *eof, void *data)\r\n{\r\nbpctl_dev_t *pbp_device_block = (bpctl_dev_t *) data;\r\nint len = 0, ret = 0;\r\nret = get_bypass_change_fn(pbp_device_block);\r\nif (ret == 1)\r\nlen = sprintf(page, "on\n");\r\nelse if (ret == 0)\r\nlen = sprintf(page, "off\n");\r\nelse\r\nlen = sprintf(page, "fail\n");\r\n*eof = 1;\r\nreturn len;\r\n}\r\nint\r\nget_tap_change_pfs(char *page, char **start, off_t off, int count,\r\nint *eof, void *data)\r\n{\r\nbpctl_dev_t *pbp_device_block = (bpctl_dev_t *) data;\r\nint len = 0, ret = 0;\r\nret = get_tap_change_fn(pbp_device_block);\r\nif (ret == 1)\r\nlen = sprintf(page, "on\n");\r\nelse if (ret == 0)\r\nlen = sprintf(page, "off\n");\r\nelse\r\nlen = sprintf(page, "fail\n");\r\n*eof = 1;\r\nreturn len;\r\n}\r\nint\r\nget_disc_change_pfs(char *page, char **start, off_t off, int count,\r\nint *eof, void *data)\r\n{\r\nbpctl_dev_t *pbp_device_block = (bpctl_dev_t *) data;\r\nint len = 0, ret = 0;\r\nret = get_disc_change_fn(pbp_device_block);\r\nif (ret == 1)\r\nlen = sprintf(page, "on\n");\r\nelse if (ret == 0)\r\nlen = sprintf(page, "off\n");\r\nelse\r\nlen = sprintf(page, "fail\n");\r\n*eof = 1;\r\nreturn len;\r\n}\r\n__inline static int atoi(char **s)\r\n{\r\nint i = 0;\r\nwhile (isdigit(**s))\r\ni = i * 10 + *((*s)++) - '0';\r\nreturn i;\r\n}\r\nint\r\nset_bypass_wd_pfs(struct file *file, const char *buffer,\r\nunsigned long count, void *data)\r\n{\r\nbpctl_dev_t *pbp_device_block = (bpctl_dev_t *) data;\r\nint timeout;\r\nint ret;\r\nret = kstrtoint_from_user(buffer, count, 10, &timeout);\r\nif (ret)\r\nreturn ret;\r\nset_bypass_wd_fn(pbp_device_block, timeout);\r\nreturn count;\r\n}\r\nint\r\nget_bypass_wd_pfs(char *page, char **start, off_t off, int count,\r\nint *eof, void *data)\r\n{\r\nbpctl_dev_t *pbp_device_block = (bpctl_dev_t *) data;\r\nint len = 0, ret = 0, timeout = 0;\r\nret = get_bypass_wd_fn(pbp_device_block, &timeout);\r\nif (ret == BP_NOT_CAP)\r\nlen = sprintf(page, "fail\n");\r\nelse if (timeout == -1)\r\nlen = sprintf(page, "unknown\n");\r\nelse if (timeout == 0)\r\nlen = sprintf(page, "disable\n");\r\nelse\r\nlen = sprintf(page, "%d\n", timeout);\r\n*eof = 1;\r\nreturn len;\r\n}\r\nint\r\nget_wd_expire_time_pfs(char *page, char **start, off_t off, int count,\r\nint *eof, void *data)\r\n{\r\nbpctl_dev_t *pbp_device_block = (bpctl_dev_t *) data;\r\nint len = 0, ret = 0, timeout = 0;\r\nret = get_wd_expire_time_fn(pbp_device_block, &timeout);\r\nif (ret == BP_NOT_CAP)\r\nlen = sprintf(page, "fail\n");\r\nelse if (timeout == -1)\r\nlen = sprintf(page, "expire\n");\r\nelse if (timeout == 0)\r\nlen = sprintf(page, "disable\n");\r\nelse\r\nlen = sprintf(page, "%d\n", timeout);\r\n*eof = 1;\r\nreturn len;\r\n}\r\nint\r\nget_tpl_pfs(char *page, char **start, off_t off, int count,\r\nint *eof, void *data)\r\n{\r\nbpctl_dev_t *pbp_device_block = (bpctl_dev_t *) data;\r\nint len = 0, ret = 0;\r\nret = get_tpl_fn(pbp_device_block);\r\nif (ret == BP_NOT_CAP)\r\nlen = sprintf(page, "fail\n");\r\nelse if (ret == 1)\r\nlen = sprintf(page, "on\n");\r\nelse if (ret == 0)\r\nlen = sprintf(page, "off\n");\r\n*eof = 1;\r\nreturn len;\r\n}\r\nint\r\nget_wait_at_pwup_pfs(char *page, char **start, off_t off, int count,\r\nint *eof, void *data)\r\n{\r\nbpctl_dev_t *pbp_device_block = (bpctl_dev_t *) data;\r\nint len = 0, ret = 0;\r\nret = get_bp_wait_at_pwup_fn(pbp_device_block);\r\nif (ret == BP_NOT_CAP)\r\nlen = sprintf(page, "fail\n");\r\nelse if (ret == 1)\r\nlen = sprintf(page, "on\n");\r\nelse if (ret == 0)\r\nlen = sprintf(page, "off\n");\r\n*eof = 1;\r\nreturn len;\r\n}\r\nint\r\nget_hw_reset_pfs(char *page, char **start, off_t off, int count,\r\nint *eof, void *data)\r\n{\r\nbpctl_dev_t *pbp_device_block = (bpctl_dev_t *) data;\r\nint len = 0, ret = 0;\r\nret = get_bp_hw_reset_fn(pbp_device_block);\r\nif (ret == BP_NOT_CAP)\r\nlen = sprintf(page, "fail\n");\r\nelse if (ret == 1)\r\nlen = sprintf(page, "on\n");\r\nelse if (ret == 0)\r\nlen = sprintf(page, "off\n");\r\n*eof = 1;\r\nreturn len;\r\n}\r\nint\r\nreset_bypass_wd_pfs(char *page, char **start, off_t off, int count,\r\nint *eof, void *data)\r\n{\r\nbpctl_dev_t *pbp_device_block = (bpctl_dev_t *) data;\r\nint len = 0, ret = 0;\r\nret = reset_bypass_wd_timer_fn(pbp_device_block);\r\nif (ret == BP_NOT_CAP)\r\nlen = sprintf(page, "fail\n");\r\nelse if (ret == 0)\r\nlen = sprintf(page, "disable\n");\r\nelse if (ret == 1)\r\nlen = sprintf(page, "success\n");\r\n*eof = 1;\r\nreturn len;\r\n}\r\nint\r\nset_dis_bypass_pfs(struct file *file, const char *buffer,\r\nunsigned long count, void *data)\r\n{\r\nchar kbuf[256];\r\nbpctl_dev_t *pbp_device_block = (bpctl_dev_t *) data;\r\nint bypass_param = 0, length = 0;\r\nif (count >= sizeof(kbuf))\r\nreturn -EINVAL;\r\nif (copy_from_user(&kbuf, buffer, count)) {\r\nreturn -1;\r\n}\r\nkbuf[count] = '\0';\r\nlength = strlen(kbuf);\r\nif (kbuf[length - 1] == '\n')\r\nkbuf[--length] = '\0';\r\nif (strcmp(kbuf, "on") == 0)\r\nbypass_param = 1;\r\nelse if (strcmp(kbuf, "off") == 0)\r\nbypass_param = 0;\r\nset_dis_bypass_fn(pbp_device_block, bypass_param);\r\nreturn count;\r\n}\r\nint\r\nset_dis_tap_pfs(struct file *file, const char *buffer,\r\nunsigned long count, void *data)\r\n{\r\nchar kbuf[256];\r\nbpctl_dev_t *pbp_device_block = (bpctl_dev_t *) data;\r\nint tap_param = 0, length = 0;\r\nif (count >= sizeof(kbuf))\r\nreturn -EINVAL;\r\nif (copy_from_user(&kbuf, buffer, count)) {\r\nreturn -1;\r\n}\r\nkbuf[count] = '\0';\r\nlength = strlen(kbuf);\r\nif (kbuf[length - 1] == '\n')\r\nkbuf[--length] = '\0';\r\nif (strcmp(kbuf, "on") == 0)\r\ntap_param = 1;\r\nelse if (strcmp(kbuf, "off") == 0)\r\ntap_param = 0;\r\nset_dis_tap_fn(pbp_device_block, tap_param);\r\nreturn count;\r\n}\r\nint\r\nset_dis_disc_pfs(struct file *file, const char *buffer,\r\nunsigned long count, void *data)\r\n{\r\nchar kbuf[256];\r\nbpctl_dev_t *pbp_device_block = (bpctl_dev_t *) data;\r\nint tap_param = 0, length = 0;\r\nif (count >= sizeof(kbuf))\r\nreturn -EINVAL;\r\nif (copy_from_user(&kbuf, buffer, count)) {\r\nreturn -1;\r\n}\r\nkbuf[count] = '\0';\r\nlength = strlen(kbuf);\r\nif (kbuf[length - 1] == '\n')\r\nkbuf[--length] = '\0';\r\nif (strcmp(kbuf, "on") == 0)\r\ntap_param = 1;\r\nelse if (strcmp(kbuf, "off") == 0)\r\ntap_param = 0;\r\nset_dis_disc_fn(pbp_device_block, tap_param);\r\nreturn count;\r\n}\r\nint\r\nget_dis_bypass_pfs(char *page, char **start, off_t off, int count,\r\nint *eof, void *data)\r\n{\r\nbpctl_dev_t *pbp_device_block = (bpctl_dev_t *) data;\r\nint len = 0, ret = 0;\r\nret = get_dis_bypass_fn(pbp_device_block);\r\nif (ret == BP_NOT_CAP)\r\nlen = sprintf(page, "fail\n");\r\nelse if (ret == 0)\r\nlen = sprintf(page, "off\n");\r\nelse\r\nlen = sprintf(page, "on\n");\r\n*eof = 1;\r\nreturn len;\r\n}\r\nint\r\nget_dis_tap_pfs(char *page, char **start, off_t off, int count,\r\nint *eof, void *data)\r\n{\r\nbpctl_dev_t *pbp_device_block = (bpctl_dev_t *) data;\r\nint len = 0, ret = 0;\r\nret = get_dis_tap_fn(pbp_device_block);\r\nif (ret == BP_NOT_CAP)\r\nlen = sprintf(page, "fail\n");\r\nelse if (ret == 0)\r\nlen = sprintf(page, "off\n");\r\nelse\r\nlen = sprintf(page, "on\n");\r\n*eof = 1;\r\nreturn len;\r\n}\r\nint\r\nget_dis_disc_pfs(char *page, char **start, off_t off, int count,\r\nint *eof, void *data)\r\n{\r\nbpctl_dev_t *pbp_device_block = (bpctl_dev_t *) data;\r\nint len = 0, ret = 0;\r\nret = get_dis_disc_fn(pbp_device_block);\r\nif (ret == BP_NOT_CAP)\r\nlen = sprintf(page, "fail\n");\r\nelse if (ret == 0)\r\nlen = sprintf(page, "off\n");\r\nelse\r\nlen = sprintf(page, "on\n");\r\n*eof = 1;\r\nreturn len;\r\n}\r\nint\r\nset_bypass_pwup_pfs(struct file *file, const char *buffer,\r\nunsigned long count, void *data)\r\n{\r\nchar kbuf[256];\r\nbpctl_dev_t *pbp_device_block = (bpctl_dev_t *) data;\r\nint bypass_param = 0, length = 0;\r\nif (count >= sizeof(kbuf))\r\nreturn -EINVAL;\r\nif (copy_from_user(&kbuf, buffer, count)) {\r\nreturn -1;\r\n}\r\nkbuf[count] = '\0';\r\nlength = strlen(kbuf);\r\nif (kbuf[length - 1] == '\n')\r\nkbuf[--length] = '\0';\r\nif (strcmp(kbuf, "on") == 0)\r\nbypass_param = 1;\r\nelse if (strcmp(kbuf, "off") == 0)\r\nbypass_param = 0;\r\nset_bypass_pwup_fn(pbp_device_block, bypass_param);\r\nreturn count;\r\n}\r\nint\r\nset_bypass_pwoff_pfs(struct file *file, const char *buffer,\r\nunsigned long count, void *data)\r\n{\r\nchar kbuf[256];\r\nbpctl_dev_t *pbp_device_block = (bpctl_dev_t *) data;\r\nint bypass_param = 0, length = 0;\r\nif (count >= sizeof(kbuf))\r\nreturn -EINVAL;\r\nif (copy_from_user(&kbuf, buffer, count)) {\r\nreturn -1;\r\n}\r\nkbuf[count] = '\0';\r\nlength = strlen(kbuf);\r\nif (kbuf[length - 1] == '\n')\r\nkbuf[--length] = '\0';\r\nif (strcmp(kbuf, "on") == 0)\r\nbypass_param = 1;\r\nelse if (strcmp(kbuf, "off") == 0)\r\nbypass_param = 0;\r\nset_bypass_pwoff_fn(pbp_device_block, bypass_param);\r\nreturn count;\r\n}\r\nint\r\nset_tap_pwup_pfs(struct file *file, const char *buffer,\r\nunsigned long count, void *data)\r\n{\r\nchar kbuf[256];\r\nbpctl_dev_t *pbp_device_block = (bpctl_dev_t *) data;\r\nint tap_param = 0, length = 0;\r\nif (count >= sizeof(kbuf))\r\nreturn -EINVAL;\r\nif (copy_from_user(&kbuf, buffer, count)) {\r\nreturn -1;\r\n}\r\nkbuf[count] = '\0';\r\nlength = strlen(kbuf);\r\nif (kbuf[length - 1] == '\n')\r\nkbuf[--length] = '\0';\r\nif (strcmp(kbuf, "on") == 0)\r\ntap_param = 1;\r\nelse if (strcmp(kbuf, "off") == 0)\r\ntap_param = 0;\r\nset_tap_pwup_fn(pbp_device_block, tap_param);\r\nreturn count;\r\n}\r\nint\r\nset_disc_pwup_pfs(struct file *file, const char *buffer,\r\nunsigned long count, void *data)\r\n{\r\nchar kbuf[256];\r\nbpctl_dev_t *pbp_device_block = (bpctl_dev_t *) data;\r\nint tap_param = 0, length = 0;\r\nif (count >= sizeof(kbuf))\r\nreturn -EINVAL;\r\nif (copy_from_user(&kbuf, buffer, count)) {\r\nreturn -1;\r\n}\r\nkbuf[count] = '\0';\r\nlength = strlen(kbuf);\r\nif (kbuf[length - 1] == '\n')\r\nkbuf[--length] = '\0';\r\nif (strcmp(kbuf, "on") == 0)\r\ntap_param = 1;\r\nelse if (strcmp(kbuf, "off") == 0)\r\ntap_param = 0;\r\nset_disc_pwup_fn(pbp_device_block, tap_param);\r\nreturn count;\r\n}\r\nint\r\nget_bypass_pwup_pfs(char *page, char **start, off_t off, int count,\r\nint *eof, void *data)\r\n{\r\nbpctl_dev_t *pbp_device_block = (bpctl_dev_t *) data;\r\nint len = 0, ret = 0;\r\nret = get_bypass_pwup_fn(pbp_device_block);\r\nif (ret == BP_NOT_CAP)\r\nlen = sprintf(page, "fail\n");\r\nelse if (ret == 0)\r\nlen = sprintf(page, "off\n");\r\nelse\r\nlen = sprintf(page, "on\n");\r\n*eof = 1;\r\nreturn len;\r\n}\r\nint\r\nget_bypass_pwoff_pfs(char *page, char **start, off_t off, int count,\r\nint *eof, void *data)\r\n{\r\nbpctl_dev_t *pbp_device_block = (bpctl_dev_t *) data;\r\nint len = 0, ret = 0;\r\nret = get_bypass_pwoff_fn(pbp_device_block);\r\nif (ret == BP_NOT_CAP)\r\nlen = sprintf(page, "fail\n");\r\nelse if (ret == 0)\r\nlen = sprintf(page, "off\n");\r\nelse\r\nlen = sprintf(page, "on\n");\r\n*eof = 1;\r\nreturn len;\r\n}\r\nint\r\nget_tap_pwup_pfs(char *page, char **start, off_t off, int count,\r\nint *eof, void *data)\r\n{\r\nbpctl_dev_t *pbp_device_block = (bpctl_dev_t *) data;\r\nint len = 0, ret = 0;\r\nret = get_tap_pwup_fn(pbp_device_block);\r\nif (ret == BP_NOT_CAP)\r\nlen = sprintf(page, "fail\n");\r\nelse if (ret == 0)\r\nlen = sprintf(page, "off\n");\r\nelse\r\nlen = sprintf(page, "on\n");\r\n*eof = 1;\r\nreturn len;\r\n}\r\nint\r\nget_disc_pwup_pfs(char *page, char **start, off_t off, int count,\r\nint *eof, void *data)\r\n{\r\nbpctl_dev_t *pbp_device_block = (bpctl_dev_t *) data;\r\nint len = 0, ret = 0;\r\nret = get_disc_pwup_fn(pbp_device_block);\r\nif (ret == BP_NOT_CAP)\r\nlen = sprintf(page, "fail\n");\r\nelse if (ret == 0)\r\nlen = sprintf(page, "off\n");\r\nelse\r\nlen = sprintf(page, "on\n");\r\n*eof = 1;\r\nreturn len;\r\n}\r\nint\r\nset_std_nic_pfs(struct file *file, const char *buffer,\r\nunsigned long count, void *data)\r\n{\r\nchar kbuf[256];\r\nbpctl_dev_t *pbp_device_block = (bpctl_dev_t *) data;\r\nint bypass_param = 0, length = 0;\r\nif (count >= sizeof(kbuf))\r\nreturn -EINVAL;\r\nif (copy_from_user(&kbuf, buffer, count)) {\r\nreturn -1;\r\n}\r\nkbuf[count] = '\0';\r\nlength = strlen(kbuf);\r\nif (kbuf[length - 1] == '\n')\r\nkbuf[--length] = '\0';\r\nif (strcmp(kbuf, "on") == 0)\r\nbypass_param = 1;\r\nelse if (strcmp(kbuf, "off") == 0)\r\nbypass_param = 0;\r\nset_std_nic_fn(pbp_device_block, bypass_param);\r\nreturn count;\r\n}\r\nint\r\nget_std_nic_pfs(char *page, char **start, off_t off, int count,\r\nint *eof, void *data)\r\n{\r\nbpctl_dev_t *pbp_device_block = (bpctl_dev_t *) data;\r\nint len = 0, ret = 0;\r\nret = get_std_nic_fn(pbp_device_block);\r\nif (ret == BP_NOT_CAP)\r\nlen = sprintf(page, "fail\n");\r\nelse if (ret == 0)\r\nlen = sprintf(page, "off\n");\r\nelse\r\nlen = sprintf(page, "on\n");\r\n*eof = 1;\r\nreturn len;\r\n}\r\nint\r\nget_wd_exp_mode_pfs(char *page, char **start, off_t off, int count,\r\nint *eof, void *data)\r\n{\r\nbpctl_dev_t *pbp_device_block = (bpctl_dev_t *) data;\r\nint len = 0, ret = 0;\r\nret = get_wd_exp_mode_fn(pbp_device_block);\r\nif (ret == 1)\r\nlen = sprintf(page, "tap\n");\r\nelse if (ret == 0)\r\nlen = sprintf(page, "bypass\n");\r\nelse if (ret == 2)\r\nlen = sprintf(page, "disc\n");\r\nelse\r\nlen = sprintf(page, "fail\n");\r\n*eof = 1;\r\nreturn len;\r\n}\r\nint\r\nset_wd_exp_mode_pfs(struct file *file, const char *buffer,\r\nunsigned long count, void *data)\r\n{\r\nchar kbuf[256];\r\nbpctl_dev_t *pbp_device_block = (bpctl_dev_t *) data;\r\nint bypass_param = 0, length = 0;\r\nif (count > (sizeof(kbuf) - 1))\r\nreturn -1;\r\nif (copy_from_user(&kbuf, buffer, count)) {\r\nreturn -1;\r\n}\r\nkbuf[count] = '\0';\r\nlength = strlen(kbuf);\r\nif (kbuf[length - 1] == '\n')\r\nkbuf[--length] = '\0';\r\nif (strcmp(kbuf, "tap") == 0)\r\nbypass_param = 1;\r\nelse if (strcmp(kbuf, "bypass") == 0)\r\nbypass_param = 0;\r\nelse if (strcmp(kbuf, "disc") == 0)\r\nbypass_param = 2;\r\nset_wd_exp_mode_fn(pbp_device_block, bypass_param);\r\nreturn count;\r\n}\r\nint\r\nget_wd_autoreset_pfs(char *page, char **start, off_t off, int count,\r\nint *eof, void *data)\r\n{\r\nbpctl_dev_t *pbp_device_block = (bpctl_dev_t *) data;\r\nint len = 0, ret = 0;\r\nret = get_wd_autoreset_fn(pbp_device_block);\r\nif (ret >= 0)\r\nlen = sprintf(page, "%d\n", ret);\r\nelse\r\nlen = sprintf(page, "fail\n");\r\n*eof = 1;\r\nreturn len;\r\n}\r\nint\r\nset_wd_autoreset_pfs(struct file *file, const char *buffer,\r\nunsigned long count, void *data)\r\n{\r\nbpctl_dev_t *pbp_device_block = (bpctl_dev_t *) data;\r\nint timeout;\r\nint ret;\r\nret = kstrtoint_from_user(buffer, count, 10, &timeout);\r\nif (ret)\r\nreturn ret;\r\nset_wd_autoreset_fn(pbp_device_block, timeout);\r\nreturn count;\r\n}\r\nint\r\nset_tpl_pfs(struct file *file, const char *buffer,\r\nunsigned long count, void *data)\r\n{\r\nchar kbuf[256];\r\nbpctl_dev_t *pbp_device_block = (bpctl_dev_t *) data;\r\nint tpl_param = 0, length = 0;\r\nif (count > (sizeof(kbuf) - 1))\r\nreturn -1;\r\nif (copy_from_user(&kbuf, buffer, count)) {\r\nreturn -1;\r\n}\r\nkbuf[count] = '\0';\r\nlength = strlen(kbuf);\r\nif (kbuf[length - 1] == '\n')\r\nkbuf[--length] = '\0';\r\nif (strcmp(kbuf, "on") == 0)\r\ntpl_param = 1;\r\nelse if (strcmp(kbuf, "off") == 0)\r\ntpl_param = 0;\r\nset_tpl_fn(pbp_device_block, tpl_param);\r\nreturn count;\r\n}\r\nint\r\nset_wait_at_pwup_pfs(struct file *file, const char *buffer,\r\nunsigned long count, void *data)\r\n{\r\nchar kbuf[256];\r\nbpctl_dev_t *pbp_device_block = (bpctl_dev_t *) data;\r\nint tpl_param = 0, length = 0;\r\nif (count > (sizeof(kbuf) - 1))\r\nreturn -1;\r\nif (copy_from_user(&kbuf, buffer, count)) {\r\nreturn -1;\r\n}\r\nkbuf[count] = '\0';\r\nlength = strlen(kbuf);\r\nif (kbuf[length - 1] == '\n')\r\nkbuf[--length] = '\0';\r\nif (strcmp(kbuf, "on") == 0)\r\ntpl_param = 1;\r\nelse if (strcmp(kbuf, "off") == 0)\r\ntpl_param = 0;\r\nset_bp_wait_at_pwup_fn(pbp_device_block, tpl_param);\r\nreturn count;\r\n}\r\nint\r\nset_hw_reset_pfs(struct file *file, const char *buffer,\r\nunsigned long count, void *data)\r\n{\r\nchar kbuf[256];\r\nbpctl_dev_t *pbp_device_block = (bpctl_dev_t *) data;\r\nint tpl_param = 0, length = 0;\r\nif (count > (sizeof(kbuf) - 1))\r\nreturn -1;\r\nif (copy_from_user(&kbuf, buffer, count)) {\r\nreturn -1;\r\n}\r\nkbuf[count] = '\0';\r\nlength = strlen(kbuf);\r\nif (kbuf[length - 1] == '\n')\r\nkbuf[--length] = '\0';\r\nif (strcmp(kbuf, "on") == 0)\r\ntpl_param = 1;\r\nelse if (strcmp(kbuf, "off") == 0)\r\ntpl_param = 0;\r\nset_bp_hw_reset_fn(pbp_device_block, tpl_param);\r\nreturn count;\r\n}\r\nint bypass_proc_create_dev_sd(bpctl_dev_t *pbp_device_block)\r\n{\r\nstruct bypass_pfs_sd *current_pfs = &(pbp_device_block->bypass_pfs_set);\r\nstatic struct proc_dir_entry *procfs_dir = NULL;\r\nint ret = 0;\r\nif (!pbp_device_block->ndev)\r\nreturn -1;\r\nsprintf(current_pfs->dir_name, "bypass_%s",\r\npbp_device_block->ndev->name);\r\nif (!bp_procfs_dir)\r\nreturn -1;\r\nprocfs_dir = proc_getdir(current_pfs->dir_name, bp_procfs_dir);\r\nif (procfs_dir == 0) {\r\nprintk(KERN_DEBUG "Could not create procfs directory %s\n",\r\ncurrent_pfs->dir_name);\r\nreturn -1;\r\n}\r\ncurrent_pfs->bypass_entry = procfs_dir;\r\nif (bypass_proc_create_entry_sd(&(current_pfs->bypass_info), BYPASS_INFO_ENTRY_SD, NULL,\r\nget_bypass_info_pfs,\r\nprocfs_dir, pbp_device_block))\r\nret = -1;\r\nif (pbp_device_block->bp_caps & SW_CTL_CAP) {\r\nif (bypass_proc_create_entry_sd(&(current_pfs->bypass_slave), BYPASS_SLAVE_ENTRY_SD, NULL,\r\nget_bypass_slave_pfs,\r\nprocfs_dir, pbp_device_block))\r\nret = -1;\r\nif (bypass_proc_create_entry_sd(&(current_pfs->bypass_caps), BYPASS_CAPS_ENTRY_SD, NULL,\r\nget_bypass_caps_pfs,\r\nprocfs_dir, pbp_device_block))\r\nret = -1;\r\nif (bypass_proc_create_entry_sd(&(current_pfs->wd_set_caps), WD_SET_CAPS_ENTRY_SD, NULL,\r\nget_wd_set_caps_pfs,\r\nprocfs_dir, pbp_device_block))\r\nret = -1;\r\nif (bypass_proc_create_entry_sd(&(current_pfs->bypass_wd), BYPASS_WD_ENTRY_SD, set_bypass_wd_pfs,\r\nget_bypass_wd_pfs,\r\nprocfs_dir, pbp_device_block))\r\nret = -1;\r\nif (bypass_proc_create_entry_sd(&(current_pfs->wd_expire_time), WD_EXPIRE_TIME_ENTRY_SD, NULL,\r\nget_wd_expire_time_pfs,\r\nprocfs_dir, pbp_device_block))\r\nret = -1;\r\nif (bypass_proc_create_entry_sd(&(current_pfs->reset_bypass_wd), RESET_BYPASS_WD_ENTRY_SD, NULL,\r\nreset_bypass_wd_pfs,\r\nprocfs_dir, pbp_device_block))\r\nret = -1;\r\nif (bypass_proc_create_entry_sd(&(current_pfs->std_nic), STD_NIC_ENTRY_SD, set_std_nic_pfs,\r\nget_std_nic_pfs,\r\nprocfs_dir, pbp_device_block))\r\nret = -1;\r\nif (pbp_device_block->bp_caps & BP_CAP) {\r\nif (bypass_proc_create_entry_sd(&(current_pfs->bypass), BYPASS_ENTRY_SD, set_bypass_pfs,\r\nget_bypass_pfs,\r\nprocfs_dir,\r\npbp_device_block))\r\nret = -1;\r\nif (bypass_proc_create_entry_sd(&(current_pfs->dis_bypass), DIS_BYPASS_ENTRY_SD, set_dis_bypass_pfs,\r\nget_dis_bypass_pfs,\r\nprocfs_dir,\r\npbp_device_block))\r\nret = -1;\r\nif (bypass_proc_create_entry_sd(&(current_pfs->bypass_pwup), BYPASS_PWUP_ENTRY_SD, set_bypass_pwup_pfs,\r\nget_bypass_pwup_pfs,\r\nprocfs_dir,\r\npbp_device_block))\r\nret = -1;\r\nif (bypass_proc_create_entry_sd(&(current_pfs->bypass_pwoff), BYPASS_PWOFF_ENTRY_SD, set_bypass_pwoff_pfs,\r\nget_bypass_pwoff_pfs,\r\nprocfs_dir,\r\npbp_device_block))\r\nret = -1;\r\nif (bypass_proc_create_entry_sd(&(current_pfs->bypass_change), BYPASS_CHANGE_ENTRY_SD, NULL,\r\nget_bypass_change_pfs,\r\nprocfs_dir,\r\npbp_device_block))\r\nret = -1;\r\n}\r\nif (pbp_device_block->bp_caps & TAP_CAP) {\r\nif (bypass_proc_create_entry_sd(&(current_pfs->tap), TAP_ENTRY_SD, set_tap_pfs,\r\nget_tap_pfs,\r\nprocfs_dir,\r\npbp_device_block))\r\nret = -1;\r\nif (bypass_proc_create_entry_sd(&(current_pfs->dis_tap), DIS_TAP_ENTRY_SD, set_dis_tap_pfs,\r\nget_dis_tap_pfs,\r\nprocfs_dir,\r\npbp_device_block))\r\nret = -1;\r\nif (bypass_proc_create_entry_sd(&(current_pfs->tap_pwup), TAP_PWUP_ENTRY_SD, set_tap_pwup_pfs,\r\nget_tap_pwup_pfs,\r\nprocfs_dir,\r\npbp_device_block))\r\nret = -1;\r\nif (bypass_proc_create_entry_sd(&(current_pfs->tap_change), TAP_CHANGE_ENTRY_SD, NULL,\r\nget_tap_change_pfs,\r\nprocfs_dir,\r\npbp_device_block))\r\nret = -1;\r\n}\r\nif (pbp_device_block->bp_caps & DISC_CAP) {\r\nif (bypass_proc_create_entry_sd(&(current_pfs->tap), DISC_ENTRY_SD, set_disc_pfs,\r\nget_disc_pfs,\r\nprocfs_dir,\r\npbp_device_block))\r\nret = -1;\r\n#if 1\r\nif (bypass_proc_create_entry_sd(&(current_pfs->dis_tap), DIS_DISC_ENTRY_SD, set_dis_disc_pfs,\r\nget_dis_disc_pfs,\r\nprocfs_dir,\r\npbp_device_block))\r\nret = -1;\r\n#endif\r\nif (bypass_proc_create_entry_sd(&(current_pfs->tap_pwup), DISC_PWUP_ENTRY_SD, set_disc_pwup_pfs,\r\nget_disc_pwup_pfs,\r\nprocfs_dir,\r\npbp_device_block))\r\nret = -1;\r\nif (bypass_proc_create_entry_sd(&(current_pfs->tap_change), DISC_CHANGE_ENTRY_SD, NULL,\r\nget_disc_change_pfs,\r\nprocfs_dir,\r\npbp_device_block))\r\nret = -1;\r\n}\r\nif (bypass_proc_create_entry_sd(&(current_pfs->wd_exp_mode), WD_EXP_MODE_ENTRY_SD, set_wd_exp_mode_pfs,\r\nget_wd_exp_mode_pfs,\r\nprocfs_dir, pbp_device_block))\r\nret = -1;\r\nif (bypass_proc_create_entry_sd(&(current_pfs->wd_autoreset), WD_AUTORESET_ENTRY_SD, set_wd_autoreset_pfs,\r\nget_wd_autoreset_pfs,\r\nprocfs_dir, pbp_device_block))\r\nret = -1;\r\nif (bypass_proc_create_entry_sd(&(current_pfs->tpl), TPL_ENTRY_SD, set_tpl_pfs,\r\nget_tpl_pfs,\r\nprocfs_dir, pbp_device_block))\r\nret = -1;\r\n#ifdef PMC_FIX_FLAG\r\nif (bypass_proc_create_entry_sd(&(current_pfs->tpl), WAIT_AT_PWUP_ENTRY_SD, set_wait_at_pwup_pfs,\r\nget_wait_at_pwup_pfs,\r\nprocfs_dir, pbp_device_block))\r\nret = -1;\r\nif (bypass_proc_create_entry_sd(&(current_pfs->tpl), HW_RESET_ENTRY_SD, set_hw_reset_pfs,\r\nget_hw_reset_pfs,\r\nprocfs_dir, pbp_device_block))\r\nret = -1;\r\n#endif\r\n}\r\nif (ret < 0)\r\nprintk(KERN_DEBUG "Create proc entry failed\n");\r\nreturn ret;\r\n}\r\nint bypass_proc_remove_dev_sd(bpctl_dev_t *pbp_device_block)\r\n{\r\nstruct bypass_pfs_sd *current_pfs = &pbp_device_block->bypass_pfs_set;\r\nstruct proc_dir_entry *pde = current_pfs->bypass_entry, *pde_curr =\r\nNULL;\r\nchar name[256];\r\nif (!pde)\r\nreturn 0;\r\nfor (pde = pde->subdir; pde;) {\r\nstrcpy(name, pde->name);\r\npde_curr = pde;\r\npde = pde->next;\r\nremove_proc_entry(name, current_pfs->bypass_entry);\r\n}\r\nif (!pde)\r\nremove_proc_entry(current_pfs->dir_name, bp_procfs_dir);\r\ncurrent_pfs->bypass_entry = NULL;\r\nreturn 0;\r\n}
