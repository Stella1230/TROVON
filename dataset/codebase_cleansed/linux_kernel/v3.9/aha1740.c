static inline struct ecb *ecb_dma_to_cpu (struct Scsi_Host *host,\r\ndma_addr_t dma)\r\n{\r\nstruct aha1740_hostdata *hdata = HOSTDATA (host);\r\ndma_addr_t offset;\r\noffset = dma - hdata->ecb_dma_addr;\r\nreturn (struct ecb *)(((char *) hdata->ecb) + (unsigned int) offset);\r\n}\r\nstatic inline dma_addr_t ecb_cpu_to_dma (struct Scsi_Host *host, void *cpu)\r\n{\r\nstruct aha1740_hostdata *hdata = HOSTDATA (host);\r\ndma_addr_t offset;\r\noffset = (char *) cpu - (char *) hdata->ecb;\r\nreturn hdata->ecb_dma_addr + offset;\r\n}\r\nstatic int aha1740_proc_info(struct Scsi_Host *shpnt, char *buffer,\r\nchar **start, off_t offset,\r\nint length, int inout)\r\n{\r\nint len;\r\nstruct aha1740_hostdata *host;\r\nif (inout)\r\nreturn-ENOSYS;\r\nhost = HOSTDATA(shpnt);\r\nlen = sprintf(buffer, "aha174x at IO:%lx, IRQ %d, SLOT %d.\n"\r\n"Extended translation %sabled.\n",\r\nshpnt->io_port, shpnt->irq, host->edev->slot,\r\nhost->translation ? "en" : "dis");\r\nif (offset > len) {\r\n*start = buffer;\r\nreturn 0;\r\n}\r\n*start = buffer + offset;\r\nlen -= offset;\r\nif (len > length)\r\nlen = length;\r\nreturn len;\r\n}\r\nstatic int aha1740_makecode(unchar *sense, unchar *status)\r\n{\r\nstruct statusword\r\n{\r\nushort don:1,\r\ndu:1,\r\n:1, qf:1,\r\nsc:1,\r\ndor:1,\r\nch:1,\r\nintr:1,\r\nasa:1,\r\nsns:1,\r\n:1, ini:1,\r\nme:1,\r\n:1, eca:1,\r\n:1;\r\n} status_word;\r\nint retval = DID_OK;\r\nstatus_word = * (struct statusword *) status;\r\n#ifdef DEBUG\r\nprintk("makecode from %x,%x,%x,%x %x,%x,%x,%x",\r\nstatus[0], status[1], status[2], status[3],\r\nsense[0], sense[1], sense[2], sense[3]);\r\n#endif\r\nif (!status_word.don) {\r\nif ( (status[1]&0x18) || status_word.sc ) {\r\nswitch ( status[2] ) {\r\ncase 0x12:\r\nif ( status_word.dor )\r\nretval=DID_ERROR;\r\ncase 0x00:\r\nbreak;\r\ncase 0x11:\r\ncase 0x21:\r\nretval=DID_TIME_OUT;\r\nbreak;\r\ncase 0x0a:\r\nretval=DID_BAD_TARGET;\r\nbreak;\r\ncase 0x04:\r\ncase 0x05:\r\nretval=DID_ABORT;\r\nbreak;\r\ndefault:\r\nretval=DID_ERROR;\r\n}\r\n} else {\r\nif ( status_word.qf ) {\r\nretval = DID_TIME_OUT;\r\nprintk("aha1740.c: WARNING: AHA1740 queue overflow!\n");\r\n} else\r\nif ( status[0]&0x60 ) {\r\nretval = DID_ERROR;\r\n}\r\n}\r\n}\r\nreturn status[3] | retval << 16;\r\n}\r\nstatic int aha1740_test_port(unsigned int base)\r\n{\r\nif ( inb(PORTADR(base)) & PORTADDR_ENH )\r\nreturn 1;\r\nprintk("aha174x: Board detected, but not in enhanced mode, so disabled it.\n");\r\nreturn 0;\r\n}\r\nstatic irqreturn_t aha1740_intr_handle(int irq, void *dev_id)\r\n{\r\nstruct Scsi_Host *host = (struct Scsi_Host *) dev_id;\r\nvoid (*my_done)(Scsi_Cmnd *);\r\nint errstatus, adapstat;\r\nint number_serviced;\r\nstruct ecb *ecbptr;\r\nScsi_Cmnd *SCtmp;\r\nunsigned int base;\r\nunsigned long flags;\r\nint handled = 0;\r\nstruct aha1740_sg *sgptr;\r\nstruct eisa_device *edev;\r\nif (!host)\r\npanic("aha1740.c: Irq from unknown host!\n");\r\nspin_lock_irqsave(host->host_lock, flags);\r\nbase = host->io_port;\r\nnumber_serviced = 0;\r\nedev = HOSTDATA(host)->edev;\r\nwhile(inb(G2STAT(base)) & G2STAT_INTPEND) {\r\nhandled = 1;\r\nDEB(printk("aha1740_intr top of loop.\n"));\r\nadapstat = inb(G2INTST(base));\r\necbptr = ecb_dma_to_cpu (host, inl(MBOXIN0(base)));\r\noutb(G2CNTRL_IRST,G2CNTRL(base));\r\nswitch ( adapstat & G2INTST_MASK ) {\r\ncase G2INTST_CCBRETRY:\r\ncase G2INTST_CCBERROR:\r\ncase G2INTST_CCBGOOD:\r\noutb(G2CNTRL_HRDY,G2CNTRL(base));\r\nif (!ecbptr) {\r\nprintk("Aha1740 null ecbptr in interrupt (%x,%x,%x,%d)\n",\r\ninb(G2STAT(base)),adapstat,\r\ninb(G2INTST(base)), number_serviced++);\r\ncontinue;\r\n}\r\nSCtmp = ecbptr->SCpnt;\r\nif (!SCtmp) {\r\nprintk("Aha1740 null SCtmp in interrupt (%x,%x,%x,%d)\n",\r\ninb(G2STAT(base)),adapstat,\r\ninb(G2INTST(base)), number_serviced++);\r\ncontinue;\r\n}\r\nsgptr = (struct aha1740_sg *) SCtmp->host_scribble;\r\nscsi_dma_unmap(SCtmp);\r\ndma_free_coherent (&edev->dev,\r\nsizeof (struct aha1740_sg),\r\nSCtmp->host_scribble,\r\nsgptr->sg_dma_addr);\r\nif ( (adapstat & G2INTST_MASK) == G2INTST_CCBERROR ) {\r\nmemcpy(SCtmp->sense_buffer, ecbptr->sense,\r\nSCSI_SENSE_BUFFERSIZE);\r\nerrstatus = aha1740_makecode(ecbptr->sense,ecbptr->status);\r\n} else\r\nerrstatus = 0;\r\nDEB(if (errstatus)\r\nprintk("aha1740_intr_handle: returning %6x\n",\r\nerrstatus));\r\nSCtmp->result = errstatus;\r\nmy_done = ecbptr->done;\r\nmemset(ecbptr,0,sizeof(struct ecb));\r\nif ( my_done )\r\nmy_done(SCtmp);\r\nbreak;\r\ncase G2INTST_HARDFAIL:\r\nprintk(KERN_ALERT "aha1740 hardware failure!\n");\r\npanic("aha1740.c");\r\ncase G2INTST_ASNEVENT:\r\nprintk("aha1740 asynchronous event: %02x %02x %02x %02x %02x\n",\r\nadapstat,\r\ninb(MBOXIN0(base)),\r\ninb(MBOXIN1(base)),\r\ninb(MBOXIN2(base)),\r\ninb(MBOXIN3(base)));\r\noutb(G2CNTRL_HRDY,G2CNTRL(base));\r\nbreak;\r\ncase G2INTST_CMDGOOD:\r\nbreak;\r\ncase G2INTST_CMDERROR:\r\nbreak;\r\n}\r\nnumber_serviced++;\r\n}\r\nspin_unlock_irqrestore(host->host_lock, flags);\r\nreturn IRQ_RETVAL(handled);\r\n}\r\nstatic int aha1740_queuecommand_lck(Scsi_Cmnd * SCpnt, void (*done)(Scsi_Cmnd *))\r\n{\r\nunchar direction;\r\nunchar *cmd = (unchar *) SCpnt->cmnd;\r\nunchar target = scmd_id(SCpnt);\r\nstruct aha1740_hostdata *host = HOSTDATA(SCpnt->device->host);\r\nunsigned long flags;\r\ndma_addr_t sg_dma;\r\nstruct aha1740_sg *sgptr;\r\nint ecbno, nseg;\r\nDEB(int i);\r\nif(*cmd == REQUEST_SENSE) {\r\nSCpnt->result = 0;\r\ndone(SCpnt);\r\nreturn 0;\r\n}\r\n#ifdef DEBUG\r\nif (*cmd == READ_10 || *cmd == WRITE_10)\r\ni = xscsi2int(cmd+2);\r\nelse if (*cmd == READ_6 || *cmd == WRITE_6)\r\ni = scsi2int(cmd+2);\r\nelse\r\ni = -1;\r\nprintk("aha1740_queuecommand: dev %d cmd %02x pos %d len %d ",\r\ntarget, *cmd, i, bufflen);\r\nprintk("scsi cmd:");\r\nfor (i = 0; i < SCpnt->cmd_len; i++) printk("%02x ", cmd[i]);\r\nprintk("\n");\r\n#endif\r\nspin_lock_irqsave(SCpnt->device->host->host_lock, flags);\r\necbno = host->last_ecb_used + 1;\r\nif (ecbno >= AHA1740_ECBS)\r\necbno = 0;\r\ndo {\r\nif (!host->ecb[ecbno].cmdw)\r\nbreak;\r\necbno++;\r\nif (ecbno >= AHA1740_ECBS)\r\necbno = 0;\r\n} while (ecbno != host->last_ecb_used);\r\nif (host->ecb[ecbno].cmdw)\r\npanic("Unable to find empty ecb for aha1740.\n");\r\nhost->ecb[ecbno].cmdw = AHA1740CMD_INIT;\r\nhost->last_ecb_used = ecbno;\r\nspin_unlock_irqrestore(SCpnt->device->host->host_lock, flags);\r\n#ifdef DEBUG\r\nprintk("Sending command (%d %x)...", ecbno, done);\r\n#endif\r\nhost->ecb[ecbno].cdblen = SCpnt->cmd_len;\r\ndirection = 0;\r\nif (*cmd == READ_10 || *cmd == READ_6)\r\ndirection = 1;\r\nelse if (*cmd == WRITE_10 || *cmd == WRITE_6)\r\ndirection = 0;\r\nmemcpy(host->ecb[ecbno].cdb, cmd, SCpnt->cmd_len);\r\nSCpnt->host_scribble = dma_alloc_coherent (&host->edev->dev,\r\nsizeof (struct aha1740_sg),\r\n&sg_dma, GFP_ATOMIC);\r\nif(SCpnt->host_scribble == NULL) {\r\nprintk(KERN_WARNING "aha1740: out of memory in queuecommand!\n");\r\nreturn 1;\r\n}\r\nsgptr = (struct aha1740_sg *) SCpnt->host_scribble;\r\nsgptr->sg_dma_addr = sg_dma;\r\nnseg = scsi_dma_map(SCpnt);\r\nBUG_ON(nseg < 0);\r\nif (nseg) {\r\nstruct scatterlist *sg;\r\nstruct aha1740_chain * cptr;\r\nint i;\r\nDEB(unsigned char * ptr);\r\nhost->ecb[ecbno].sg = 1;\r\ncptr = sgptr->sg_chain;\r\nscsi_for_each_sg(SCpnt, sg, nseg, i) {\r\ncptr[i].datalen = sg_dma_len (sg);\r\ncptr[i].dataptr = sg_dma_address (sg);\r\n}\r\nhost->ecb[ecbno].datalen = nseg * sizeof(struct aha1740_chain);\r\nhost->ecb[ecbno].dataptr = sg_dma;\r\n#ifdef DEBUG\r\nprintk("cptr %x: ",cptr);\r\nptr = (unsigned char *) cptr;\r\nfor(i=0;i<24;i++) printk("%02x ", ptr[i]);\r\n#endif\r\n} else {\r\nhost->ecb[ecbno].datalen = 0;\r\nhost->ecb[ecbno].dataptr = 0;\r\n}\r\nhost->ecb[ecbno].lun = SCpnt->device->lun;\r\nhost->ecb[ecbno].ses = 1;\r\nhost->ecb[ecbno].dir = direction;\r\nhost->ecb[ecbno].ars = 1;\r\nhost->ecb[ecbno].senselen = 12;\r\nhost->ecb[ecbno].senseptr = ecb_cpu_to_dma (SCpnt->device->host,\r\nhost->ecb[ecbno].sense);\r\nhost->ecb[ecbno].statusptr = ecb_cpu_to_dma (SCpnt->device->host,\r\nhost->ecb[ecbno].status);\r\nhost->ecb[ecbno].done = done;\r\nhost->ecb[ecbno].SCpnt = SCpnt;\r\n#ifdef DEBUG\r\n{\r\nint i;\r\nprintk("aha1740_command: sending.. ");\r\nfor (i = 0; i < sizeof(host->ecb[ecbno]) - 10; i++)\r\nprintk("%02x ", ((unchar *)&host->ecb[ecbno])[i]);\r\n}\r\nprintk("\n");\r\n#endif\r\nif (done) {\r\n#define LOOPCNT_WARN 10\r\n#define LOOPCNT_MAX 1000000\r\nint loopcnt;\r\nunsigned int base = SCpnt->device->host->io_port;\r\nDEB(printk("aha1740[%d] critical section\n",ecbno));\r\nspin_lock_irqsave(SCpnt->device->host->host_lock, flags);\r\nfor (loopcnt = 0; ; loopcnt++) {\r\nif (inb(G2STAT(base)) & G2STAT_MBXOUT) break;\r\nif (loopcnt == LOOPCNT_WARN) {\r\nprintk("aha1740[%d]_mbxout wait!\n",ecbno);\r\n}\r\nif (loopcnt == LOOPCNT_MAX)\r\npanic("aha1740.c: mbxout busy!\n");\r\n}\r\noutl (ecb_cpu_to_dma (SCpnt->device->host, host->ecb + ecbno),\r\nMBOXOUT0(base));\r\nfor (loopcnt = 0; ; loopcnt++) {\r\nif (! (inb(G2STAT(base)) & G2STAT_BUSY)) break;\r\nif (loopcnt == LOOPCNT_WARN) {\r\nprintk("aha1740[%d]_attn wait!\n",ecbno);\r\n}\r\nif (loopcnt == LOOPCNT_MAX)\r\npanic("aha1740.c: attn wait failed!\n");\r\n}\r\noutb(ATTN_START | (target & 7), ATTN(base));\r\nspin_unlock_irqrestore(SCpnt->device->host->host_lock, flags);\r\nDEB(printk("aha1740[%d] request queued.\n",ecbno));\r\n} else\r\nprintk(KERN_ALERT "aha1740_queuecommand: done can't be NULL\n");\r\nreturn 0;\r\n}\r\nint aha1740_eh_abort_handler (Scsi_Cmnd *dummy)\r\n{\r\nreturn 0;\r\n}\r\nstatic int aha1740_probe (struct device *dev)\r\n{\r\nint slotbase, rc;\r\nunsigned int irq_level, irq_type, translation;\r\nstruct Scsi_Host *shpnt;\r\nstruct aha1740_hostdata *host;\r\nstruct eisa_device *edev = to_eisa_device (dev);\r\nDEB(printk("aha1740_probe: \n"));\r\nslotbase = edev->base_addr + EISA_VENDOR_ID_OFFSET;\r\nif (!request_region(slotbase, SLOTSIZE, "aha1740"))\r\nreturn -EBUSY;\r\nif (!aha1740_test_port(slotbase))\r\ngoto err_release_region;\r\naha1740_getconfig(slotbase,&irq_level,&irq_type,&translation);\r\nif ((inb(G2STAT(slotbase)) &\r\n(G2STAT_MBXOUT|G2STAT_BUSY)) != G2STAT_MBXOUT) {\r\noutb(G2CNTRL_HRST, G2CNTRL(slotbase));\r\noutb(0, G2CNTRL(slotbase));\r\n}\r\nprintk(KERN_INFO "Configuring slot %d at IO:%x, IRQ %u (%s)\n",\r\nedev->slot, slotbase, irq_level, irq_type ? "edge" : "level");\r\nprintk(KERN_INFO "aha174x: Extended translation %sabled.\n",\r\ntranslation ? "en" : "dis");\r\nshpnt = scsi_host_alloc(&aha1740_template,\r\nsizeof(struct aha1740_hostdata));\r\nif(shpnt == NULL)\r\ngoto err_release_region;\r\nshpnt->base = 0;\r\nshpnt->io_port = slotbase;\r\nshpnt->n_io_port = SLOTSIZE;\r\nshpnt->irq = irq_level;\r\nshpnt->dma_channel = 0xff;\r\nhost = HOSTDATA(shpnt);\r\nhost->edev = edev;\r\nhost->translation = translation;\r\nhost->ecb_dma_addr = dma_map_single (&edev->dev, host->ecb,\r\nsizeof (host->ecb),\r\nDMA_BIDIRECTIONAL);\r\nif (!host->ecb_dma_addr) {\r\nprintk (KERN_ERR "aha1740_probe: Couldn't map ECB, giving up\n");\r\nscsi_unregister (shpnt);\r\ngoto err_host_put;\r\n}\r\nDEB(printk("aha1740_probe: enable interrupt channel %d\n",irq_level));\r\nif (request_irq(irq_level,aha1740_intr_handle,irq_type ? 0 : IRQF_SHARED,\r\n"aha1740",shpnt)) {\r\nprintk(KERN_ERR "aha1740_probe: Unable to allocate IRQ %d.\n",\r\nirq_level);\r\ngoto err_unmap;\r\n}\r\neisa_set_drvdata (edev, shpnt);\r\nrc = scsi_add_host (shpnt, dev);\r\nif (rc)\r\ngoto err_irq;\r\nscsi_scan_host (shpnt);\r\nreturn 0;\r\nerr_irq:\r\nfree_irq(irq_level, shpnt);\r\nerr_unmap:\r\ndma_unmap_single (&edev->dev, host->ecb_dma_addr,\r\nsizeof (host->ecb), DMA_BIDIRECTIONAL);\r\nerr_host_put:\r\nscsi_host_put (shpnt);\r\nerr_release_region:\r\nrelease_region(slotbase, SLOTSIZE);\r\nreturn -ENODEV;\r\n}\r\nstatic int aha1740_remove (struct device *dev)\r\n{\r\nstruct Scsi_Host *shpnt = dev_get_drvdata(dev);\r\nstruct aha1740_hostdata *host = HOSTDATA (shpnt);\r\nscsi_remove_host(shpnt);\r\nfree_irq (shpnt->irq, shpnt);\r\ndma_unmap_single (dev, host->ecb_dma_addr,\r\nsizeof (host->ecb), DMA_BIDIRECTIONAL);\r\nrelease_region (shpnt->io_port, SLOTSIZE);\r\nscsi_host_put (shpnt);\r\nreturn 0;\r\n}\r\nstatic __init int aha1740_init (void)\r\n{\r\nreturn eisa_driver_register (&aha1740_driver);\r\n}\r\nstatic __exit void aha1740_exit (void)\r\n{\r\neisa_driver_unregister (&aha1740_driver);\r\n}
