static void\r\nmv64xxx_i2c_hw_init(struct mv64xxx_i2c_data *drv_data)\r\n{\r\nwritel(0, drv_data->reg_base + MV64XXX_I2C_REG_SOFT_RESET);\r\nwritel((((drv_data->freq_m & 0xf) << 3) | (drv_data->freq_n & 0x7)),\r\ndrv_data->reg_base + MV64XXX_I2C_REG_BAUD);\r\nwritel(0, drv_data->reg_base + MV64XXX_I2C_REG_SLAVE_ADDR);\r\nwritel(0, drv_data->reg_base + MV64XXX_I2C_REG_EXT_SLAVE_ADDR);\r\nwritel(MV64XXX_I2C_REG_CONTROL_TWSIEN | MV64XXX_I2C_REG_CONTROL_STOP,\r\ndrv_data->reg_base + MV64XXX_I2C_REG_CONTROL);\r\ndrv_data->state = MV64XXX_I2C_STATE_IDLE;\r\n}\r\nstatic void\r\nmv64xxx_i2c_fsm(struct mv64xxx_i2c_data *drv_data, u32 status)\r\n{\r\nif (drv_data->state == MV64XXX_I2C_STATE_IDLE) {\r\ndrv_data->action = MV64XXX_I2C_ACTION_SEND_STOP;\r\nreturn;\r\n}\r\nswitch (status) {\r\ncase MV64XXX_I2C_STATUS_MAST_START:\r\ncase MV64XXX_I2C_STATUS_MAST_REPEAT_START:\r\ndrv_data->action = MV64XXX_I2C_ACTION_SEND_ADDR_1;\r\ndrv_data->state = MV64XXX_I2C_STATE_WAITING_FOR_ADDR_1_ACK;\r\nbreak;\r\ncase MV64XXX_I2C_STATUS_MAST_WR_ADDR_ACK:\r\nif (drv_data->msg->flags & I2C_M_TEN) {\r\ndrv_data->action = MV64XXX_I2C_ACTION_SEND_ADDR_2;\r\ndrv_data->state =\r\nMV64XXX_I2C_STATE_WAITING_FOR_ADDR_2_ACK;\r\nbreak;\r\n}\r\ncase MV64XXX_I2C_STATUS_MAST_WR_ADDR_2_ACK:\r\ncase MV64XXX_I2C_STATUS_MAST_WR_ACK:\r\nif ((drv_data->bytes_left == 0)\r\n|| (drv_data->aborting\r\n&& (drv_data->byte_posn != 0))) {\r\nif (drv_data->send_stop) {\r\ndrv_data->action = MV64XXX_I2C_ACTION_SEND_STOP;\r\ndrv_data->state = MV64XXX_I2C_STATE_IDLE;\r\n} else {\r\ndrv_data->action =\r\nMV64XXX_I2C_ACTION_SEND_RESTART;\r\ndrv_data->state =\r\nMV64XXX_I2C_STATE_WAITING_FOR_RESTART;\r\n}\r\n} else {\r\ndrv_data->action = MV64XXX_I2C_ACTION_SEND_DATA;\r\ndrv_data->state =\r\nMV64XXX_I2C_STATE_WAITING_FOR_SLAVE_ACK;\r\ndrv_data->bytes_left--;\r\n}\r\nbreak;\r\ncase MV64XXX_I2C_STATUS_MAST_RD_ADDR_ACK:\r\nif (drv_data->msg->flags & I2C_M_TEN) {\r\ndrv_data->action = MV64XXX_I2C_ACTION_SEND_ADDR_2;\r\ndrv_data->state =\r\nMV64XXX_I2C_STATE_WAITING_FOR_ADDR_2_ACK;\r\nbreak;\r\n}\r\ncase MV64XXX_I2C_STATUS_MAST_RD_ADDR_2_ACK:\r\nif (drv_data->bytes_left == 0) {\r\ndrv_data->action = MV64XXX_I2C_ACTION_SEND_STOP;\r\ndrv_data->state = MV64XXX_I2C_STATE_IDLE;\r\nbreak;\r\n}\r\ncase MV64XXX_I2C_STATUS_MAST_RD_DATA_ACK:\r\nif (status != MV64XXX_I2C_STATUS_MAST_RD_DATA_ACK)\r\ndrv_data->action = MV64XXX_I2C_ACTION_CONTINUE;\r\nelse {\r\ndrv_data->action = MV64XXX_I2C_ACTION_RCV_DATA;\r\ndrv_data->bytes_left--;\r\n}\r\ndrv_data->state = MV64XXX_I2C_STATE_WAITING_FOR_SLAVE_DATA;\r\nif ((drv_data->bytes_left == 1) || drv_data->aborting)\r\ndrv_data->cntl_bits &= ~MV64XXX_I2C_REG_CONTROL_ACK;\r\nbreak;\r\ncase MV64XXX_I2C_STATUS_MAST_RD_DATA_NO_ACK:\r\ndrv_data->action = MV64XXX_I2C_ACTION_RCV_DATA_STOP;\r\ndrv_data->state = MV64XXX_I2C_STATE_IDLE;\r\nbreak;\r\ncase MV64XXX_I2C_STATUS_MAST_WR_ADDR_NO_ACK:\r\ncase MV64XXX_I2C_STATUS_MAST_WR_NO_ACK:\r\ncase MV64XXX_I2C_STATUS_MAST_RD_ADDR_NO_ACK:\r\ndrv_data->action = MV64XXX_I2C_ACTION_SEND_STOP;\r\ndrv_data->state = MV64XXX_I2C_STATE_IDLE;\r\ndrv_data->rc = -ENODEV;\r\nbreak;\r\ndefault:\r\ndev_err(&drv_data->adapter.dev,\r\n"mv64xxx_i2c_fsm: Ctlr Error -- state: 0x%x, "\r\n"status: 0x%x, addr: 0x%x, flags: 0x%x\n",\r\ndrv_data->state, status, drv_data->msg->addr,\r\ndrv_data->msg->flags);\r\ndrv_data->action = MV64XXX_I2C_ACTION_SEND_STOP;\r\nmv64xxx_i2c_hw_init(drv_data);\r\ndrv_data->rc = -EIO;\r\n}\r\n}\r\nstatic void\r\nmv64xxx_i2c_do_action(struct mv64xxx_i2c_data *drv_data)\r\n{\r\nswitch(drv_data->action) {\r\ncase MV64XXX_I2C_ACTION_SEND_RESTART:\r\ndrv_data->cntl_bits |= MV64XXX_I2C_REG_CONTROL_START;\r\ndrv_data->cntl_bits &= ~MV64XXX_I2C_REG_CONTROL_INTEN;\r\nwritel(drv_data->cntl_bits,\r\ndrv_data->reg_base + MV64XXX_I2C_REG_CONTROL);\r\ndrv_data->block = 0;\r\nwake_up_interruptible(&drv_data->waitq);\r\nbreak;\r\ncase MV64XXX_I2C_ACTION_CONTINUE:\r\nwritel(drv_data->cntl_bits,\r\ndrv_data->reg_base + MV64XXX_I2C_REG_CONTROL);\r\nbreak;\r\ncase MV64XXX_I2C_ACTION_SEND_START:\r\nwritel(drv_data->cntl_bits | MV64XXX_I2C_REG_CONTROL_START,\r\ndrv_data->reg_base + MV64XXX_I2C_REG_CONTROL);\r\nbreak;\r\ncase MV64XXX_I2C_ACTION_SEND_ADDR_1:\r\nwritel(drv_data->addr1,\r\ndrv_data->reg_base + MV64XXX_I2C_REG_DATA);\r\nwritel(drv_data->cntl_bits,\r\ndrv_data->reg_base + MV64XXX_I2C_REG_CONTROL);\r\nbreak;\r\ncase MV64XXX_I2C_ACTION_SEND_ADDR_2:\r\nwritel(drv_data->addr2,\r\ndrv_data->reg_base + MV64XXX_I2C_REG_DATA);\r\nwritel(drv_data->cntl_bits,\r\ndrv_data->reg_base + MV64XXX_I2C_REG_CONTROL);\r\nbreak;\r\ncase MV64XXX_I2C_ACTION_SEND_DATA:\r\nwritel(drv_data->msg->buf[drv_data->byte_posn++],\r\ndrv_data->reg_base + MV64XXX_I2C_REG_DATA);\r\nwritel(drv_data->cntl_bits,\r\ndrv_data->reg_base + MV64XXX_I2C_REG_CONTROL);\r\nbreak;\r\ncase MV64XXX_I2C_ACTION_RCV_DATA:\r\ndrv_data->msg->buf[drv_data->byte_posn++] =\r\nreadl(drv_data->reg_base + MV64XXX_I2C_REG_DATA);\r\nwritel(drv_data->cntl_bits,\r\ndrv_data->reg_base + MV64XXX_I2C_REG_CONTROL);\r\nbreak;\r\ncase MV64XXX_I2C_ACTION_RCV_DATA_STOP:\r\ndrv_data->msg->buf[drv_data->byte_posn++] =\r\nreadl(drv_data->reg_base + MV64XXX_I2C_REG_DATA);\r\ndrv_data->cntl_bits &= ~MV64XXX_I2C_REG_CONTROL_INTEN;\r\nwritel(drv_data->cntl_bits | MV64XXX_I2C_REG_CONTROL_STOP,\r\ndrv_data->reg_base + MV64XXX_I2C_REG_CONTROL);\r\ndrv_data->block = 0;\r\nwake_up_interruptible(&drv_data->waitq);\r\nbreak;\r\ncase MV64XXX_I2C_ACTION_INVALID:\r\ndefault:\r\ndev_err(&drv_data->adapter.dev,\r\n"mv64xxx_i2c_do_action: Invalid action: %d\n",\r\ndrv_data->action);\r\ndrv_data->rc = -EIO;\r\ncase MV64XXX_I2C_ACTION_SEND_STOP:\r\ndrv_data->cntl_bits &= ~MV64XXX_I2C_REG_CONTROL_INTEN;\r\nwritel(drv_data->cntl_bits | MV64XXX_I2C_REG_CONTROL_STOP,\r\ndrv_data->reg_base + MV64XXX_I2C_REG_CONTROL);\r\ndrv_data->block = 0;\r\nwake_up_interruptible(&drv_data->waitq);\r\nbreak;\r\n}\r\n}\r\nstatic irqreturn_t\r\nmv64xxx_i2c_intr(int irq, void *dev_id)\r\n{\r\nstruct mv64xxx_i2c_data *drv_data = dev_id;\r\nunsigned long flags;\r\nu32 status;\r\nirqreturn_t rc = IRQ_NONE;\r\nspin_lock_irqsave(&drv_data->lock, flags);\r\nwhile (readl(drv_data->reg_base + MV64XXX_I2C_REG_CONTROL) &\r\nMV64XXX_I2C_REG_CONTROL_IFLG) {\r\nstatus = readl(drv_data->reg_base + MV64XXX_I2C_REG_STATUS);\r\nmv64xxx_i2c_fsm(drv_data, status);\r\nmv64xxx_i2c_do_action(drv_data);\r\nrc = IRQ_HANDLED;\r\n}\r\nspin_unlock_irqrestore(&drv_data->lock, flags);\r\nreturn rc;\r\n}\r\nstatic void\r\nmv64xxx_i2c_prepare_for_io(struct mv64xxx_i2c_data *drv_data,\r\nstruct i2c_msg *msg)\r\n{\r\nu32 dir = 0;\r\ndrv_data->msg = msg;\r\ndrv_data->byte_posn = 0;\r\ndrv_data->bytes_left = msg->len;\r\ndrv_data->aborting = 0;\r\ndrv_data->rc = 0;\r\ndrv_data->cntl_bits = MV64XXX_I2C_REG_CONTROL_ACK |\r\nMV64XXX_I2C_REG_CONTROL_INTEN | MV64XXX_I2C_REG_CONTROL_TWSIEN;\r\nif (msg->flags & I2C_M_RD)\r\ndir = 1;\r\nif (msg->flags & I2C_M_TEN) {\r\ndrv_data->addr1 = 0xf0 | (((u32)msg->addr & 0x300) >> 7) | dir;\r\ndrv_data->addr2 = (u32)msg->addr & 0xff;\r\n} else {\r\ndrv_data->addr1 = ((u32)msg->addr & 0x7f) << 1 | dir;\r\ndrv_data->addr2 = 0;\r\n}\r\n}\r\nstatic void\r\nmv64xxx_i2c_wait_for_completion(struct mv64xxx_i2c_data *drv_data)\r\n{\r\nlong time_left;\r\nunsigned long flags;\r\nchar abort = 0;\r\ntime_left = wait_event_interruptible_timeout(drv_data->waitq,\r\n!drv_data->block, drv_data->adapter.timeout);\r\nspin_lock_irqsave(&drv_data->lock, flags);\r\nif (!time_left) {\r\ndrv_data->rc = -ETIMEDOUT;\r\nabort = 1;\r\n} else if (time_left < 0) {\r\ndrv_data->rc = time_left;\r\nabort = 1;\r\n}\r\nif (abort && drv_data->block) {\r\ndrv_data->aborting = 1;\r\nspin_unlock_irqrestore(&drv_data->lock, flags);\r\ntime_left = wait_event_timeout(drv_data->waitq,\r\n!drv_data->block, drv_data->adapter.timeout);\r\nif ((time_left <= 0) && drv_data->block) {\r\ndrv_data->state = MV64XXX_I2C_STATE_IDLE;\r\ndev_err(&drv_data->adapter.dev,\r\n"mv64xxx: I2C bus locked, block: %d, "\r\n"time_left: %d\n", drv_data->block,\r\n(int)time_left);\r\nmv64xxx_i2c_hw_init(drv_data);\r\n}\r\n} else\r\nspin_unlock_irqrestore(&drv_data->lock, flags);\r\n}\r\nstatic int\r\nmv64xxx_i2c_execute_msg(struct mv64xxx_i2c_data *drv_data, struct i2c_msg *msg,\r\nint is_first, int is_last)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&drv_data->lock, flags);\r\nmv64xxx_i2c_prepare_for_io(drv_data, msg);\r\nif (unlikely(msg->flags & I2C_M_NOSTART)) {\r\nif (drv_data->msg->flags & I2C_M_RD) {\r\ndrv_data->action = MV64XXX_I2C_ACTION_CONTINUE;\r\ndrv_data->state =\r\nMV64XXX_I2C_STATE_WAITING_FOR_SLAVE_DATA;\r\n} else {\r\ndrv_data->action = MV64XXX_I2C_ACTION_SEND_DATA;\r\ndrv_data->state =\r\nMV64XXX_I2C_STATE_WAITING_FOR_SLAVE_ACK;\r\ndrv_data->bytes_left--;\r\n}\r\n} else {\r\nif (is_first) {\r\ndrv_data->action = MV64XXX_I2C_ACTION_SEND_START;\r\ndrv_data->state =\r\nMV64XXX_I2C_STATE_WAITING_FOR_START_COND;\r\n} else {\r\ndrv_data->action = MV64XXX_I2C_ACTION_SEND_ADDR_1;\r\ndrv_data->state =\r\nMV64XXX_I2C_STATE_WAITING_FOR_ADDR_1_ACK;\r\n}\r\n}\r\ndrv_data->send_stop = is_last;\r\ndrv_data->block = 1;\r\nmv64xxx_i2c_do_action(drv_data);\r\nspin_unlock_irqrestore(&drv_data->lock, flags);\r\nmv64xxx_i2c_wait_for_completion(drv_data);\r\nreturn drv_data->rc;\r\n}\r\nstatic u32\r\nmv64xxx_i2c_functionality(struct i2c_adapter *adap)\r\n{\r\nreturn I2C_FUNC_I2C | I2C_FUNC_10BIT_ADDR | I2C_FUNC_SMBUS_EMUL;\r\n}\r\nstatic int\r\nmv64xxx_i2c_xfer(struct i2c_adapter *adap, struct i2c_msg msgs[], int num)\r\n{\r\nstruct mv64xxx_i2c_data *drv_data = i2c_get_adapdata(adap);\r\nint i, rc;\r\nfor (i = 0; i < num; i++) {\r\nrc = mv64xxx_i2c_execute_msg(drv_data, &msgs[i],\r\ni == 0, i + 1 == num);\r\nif (rc < 0)\r\nreturn rc;\r\n}\r\nreturn num;\r\n}\r\nstatic int\r\nmv64xxx_i2c_map_regs(struct platform_device *pd,\r\nstruct mv64xxx_i2c_data *drv_data)\r\n{\r\nint size;\r\nstruct resource *r = platform_get_resource(pd, IORESOURCE_MEM, 0);\r\nif (!r)\r\nreturn -ENODEV;\r\nsize = resource_size(r);\r\nif (!request_mem_region(r->start, size, drv_data->adapter.name))\r\nreturn -EBUSY;\r\ndrv_data->reg_base = ioremap(r->start, size);\r\ndrv_data->reg_base_p = r->start;\r\ndrv_data->reg_size = size;\r\nreturn 0;\r\n}\r\nstatic void\r\nmv64xxx_i2c_unmap_regs(struct mv64xxx_i2c_data *drv_data)\r\n{\r\nif (drv_data->reg_base) {\r\niounmap(drv_data->reg_base);\r\nrelease_mem_region(drv_data->reg_base_p, drv_data->reg_size);\r\n}\r\ndrv_data->reg_base = NULL;\r\ndrv_data->reg_base_p = 0;\r\n}\r\nstatic int\r\nmv64xxx_calc_freq(const int tclk, const int n, const int m)\r\n{\r\nreturn tclk / (10 * (m + 1) * (2 << n));\r\n}\r\nstatic bool\r\nmv64xxx_find_baud_factors(const u32 req_freq, const u32 tclk, u32 *best_n,\r\nu32 *best_m)\r\n{\r\nint freq, delta, best_delta = INT_MAX;\r\nint m, n;\r\nfor (n = 0; n <= 7; n++)\r\nfor (m = 0; m <= 15; m++) {\r\nfreq = mv64xxx_calc_freq(tclk, n, m);\r\ndelta = req_freq - freq;\r\nif (delta >= 0 && delta < best_delta) {\r\n*best_m = m;\r\n*best_n = n;\r\nbest_delta = delta;\r\n}\r\nif (best_delta == 0)\r\nreturn true;\r\n}\r\nif (best_delta == INT_MAX)\r\nreturn false;\r\nreturn true;\r\n}\r\nstatic int\r\nmv64xxx_of_config(struct mv64xxx_i2c_data *drv_data,\r\nstruct device_node *np)\r\n{\r\nu32 bus_freq, tclk;\r\nint rc = 0;\r\n#if !defined(CONFIG_HAVE_CLK)\r\nreturn -ENODEV;\r\n#else\r\nif (IS_ERR(drv_data->clk)) {\r\nrc = -ENODEV;\r\ngoto out;\r\n}\r\ntclk = clk_get_rate(drv_data->clk);\r\nof_property_read_u32(np, "clock-frequency", &bus_freq);\r\nif (!mv64xxx_find_baud_factors(bus_freq, tclk,\r\n&drv_data->freq_n, &drv_data->freq_m)) {\r\nrc = -EINVAL;\r\ngoto out;\r\n}\r\ndrv_data->irq = irq_of_parse_and_map(np, 0);\r\ndrv_data->adapter.timeout = HZ;\r\nout:\r\nreturn rc;\r\n#endif\r\n}\r\nstatic int\r\nmv64xxx_of_config(struct mv64xxx_i2c_data *drv_data,\r\nstruct device_node *np)\r\n{\r\nreturn -ENODEV;\r\n}\r\nstatic int\r\nmv64xxx_i2c_probe(struct platform_device *pd)\r\n{\r\nstruct mv64xxx_i2c_data *drv_data;\r\nstruct mv64xxx_i2c_pdata *pdata = pd->dev.platform_data;\r\nint rc;\r\nif ((!pdata && !pd->dev.of_node))\r\nreturn -ENODEV;\r\ndrv_data = kzalloc(sizeof(struct mv64xxx_i2c_data), GFP_KERNEL);\r\nif (!drv_data)\r\nreturn -ENOMEM;\r\nif (mv64xxx_i2c_map_regs(pd, drv_data)) {\r\nrc = -ENODEV;\r\ngoto exit_kfree;\r\n}\r\nstrlcpy(drv_data->adapter.name, MV64XXX_I2C_CTLR_NAME " adapter",\r\nsizeof(drv_data->adapter.name));\r\ninit_waitqueue_head(&drv_data->waitq);\r\nspin_lock_init(&drv_data->lock);\r\n#if defined(CONFIG_HAVE_CLK)\r\ndrv_data->clk = clk_get(&pd->dev, NULL);\r\nif (!IS_ERR(drv_data->clk)) {\r\nclk_prepare(drv_data->clk);\r\nclk_enable(drv_data->clk);\r\n}\r\n#endif\r\nif (pdata) {\r\ndrv_data->freq_m = pdata->freq_m;\r\ndrv_data->freq_n = pdata->freq_n;\r\ndrv_data->irq = platform_get_irq(pd, 0);\r\ndrv_data->adapter.timeout = msecs_to_jiffies(pdata->timeout);\r\n} else if (pd->dev.of_node) {\r\nrc = mv64xxx_of_config(drv_data, pd->dev.of_node);\r\nif (rc)\r\ngoto exit_unmap_regs;\r\n}\r\nif (drv_data->irq < 0) {\r\nrc = -ENXIO;\r\ngoto exit_unmap_regs;\r\n}\r\ndrv_data->adapter.dev.parent = &pd->dev;\r\ndrv_data->adapter.algo = &mv64xxx_i2c_algo;\r\ndrv_data->adapter.owner = THIS_MODULE;\r\ndrv_data->adapter.class = I2C_CLASS_HWMON | I2C_CLASS_SPD;\r\ndrv_data->adapter.nr = pd->id;\r\ndrv_data->adapter.dev.of_node = pd->dev.of_node;\r\nplatform_set_drvdata(pd, drv_data);\r\ni2c_set_adapdata(&drv_data->adapter, drv_data);\r\nmv64xxx_i2c_hw_init(drv_data);\r\nif (request_irq(drv_data->irq, mv64xxx_i2c_intr, 0,\r\nMV64XXX_I2C_CTLR_NAME, drv_data)) {\r\ndev_err(&drv_data->adapter.dev,\r\n"mv64xxx: Can't register intr handler irq: %d\n",\r\ndrv_data->irq);\r\nrc = -EINVAL;\r\ngoto exit_unmap_regs;\r\n} else if ((rc = i2c_add_numbered_adapter(&drv_data->adapter)) != 0) {\r\ndev_err(&drv_data->adapter.dev,\r\n"mv64xxx: Can't add i2c adapter, rc: %d\n", -rc);\r\ngoto exit_free_irq;\r\n}\r\nof_i2c_register_devices(&drv_data->adapter);\r\nreturn 0;\r\nexit_free_irq:\r\nfree_irq(drv_data->irq, drv_data);\r\nexit_unmap_regs:\r\n#if defined(CONFIG_HAVE_CLK)\r\nif (!IS_ERR(drv_data->clk)) {\r\nclk_disable(drv_data->clk);\r\nclk_unprepare(drv_data->clk);\r\n}\r\n#endif\r\nmv64xxx_i2c_unmap_regs(drv_data);\r\nexit_kfree:\r\nkfree(drv_data);\r\nreturn rc;\r\n}\r\nstatic int\r\nmv64xxx_i2c_remove(struct platform_device *dev)\r\n{\r\nstruct mv64xxx_i2c_data *drv_data = platform_get_drvdata(dev);\r\nint rc;\r\nrc = i2c_del_adapter(&drv_data->adapter);\r\nfree_irq(drv_data->irq, drv_data);\r\nmv64xxx_i2c_unmap_regs(drv_data);\r\n#if defined(CONFIG_HAVE_CLK)\r\nif (!IS_ERR(drv_data->clk)) {\r\nclk_disable(drv_data->clk);\r\nclk_unprepare(drv_data->clk);\r\n}\r\n#endif\r\nkfree(drv_data);\r\nreturn rc;\r\n}
