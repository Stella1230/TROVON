static struct irq_domain *irq_domain_alloc(struct device_node *of_node,\r\nunsigned int revmap_type,\r\nconst struct irq_domain_ops *ops,\r\nvoid *host_data)\r\n{\r\nstruct irq_domain *domain;\r\ndomain = kzalloc_node(sizeof(*domain), GFP_KERNEL,\r\nof_node_to_nid(of_node));\r\nif (WARN_ON(!domain))\r\nreturn NULL;\r\ndomain->revmap_type = revmap_type;\r\ndomain->ops = ops;\r\ndomain->host_data = host_data;\r\ndomain->of_node = of_node_get(of_node);\r\nreturn domain;\r\n}\r\nstatic void irq_domain_free(struct irq_domain *domain)\r\n{\r\nof_node_put(domain->of_node);\r\nkfree(domain);\r\n}\r\nstatic void irq_domain_add(struct irq_domain *domain)\r\n{\r\nmutex_lock(&irq_domain_mutex);\r\nlist_add(&domain->link, &irq_domain_list);\r\nmutex_unlock(&irq_domain_mutex);\r\npr_debug("Allocated domain of type %d @0x%p\n",\r\ndomain->revmap_type, domain);\r\n}\r\nvoid irq_domain_remove(struct irq_domain *domain)\r\n{\r\nmutex_lock(&irq_domain_mutex);\r\nswitch (domain->revmap_type) {\r\ncase IRQ_DOMAIN_MAP_LEGACY:\r\nbreak;\r\ncase IRQ_DOMAIN_MAP_TREE:\r\nWARN_ON(domain->revmap_data.tree.height);\r\nbreak;\r\ncase IRQ_DOMAIN_MAP_LINEAR:\r\nkfree(domain->revmap_data.linear.revmap);\r\ndomain->revmap_data.linear.size = 0;\r\nbreak;\r\ncase IRQ_DOMAIN_MAP_NOMAP:\r\nbreak;\r\n}\r\nlist_del(&domain->link);\r\nif (unlikely(irq_default_domain == domain))\r\nirq_set_default_host(NULL);\r\nmutex_unlock(&irq_domain_mutex);\r\npr_debug("Removed domain of type %d @0x%p\n",\r\ndomain->revmap_type, domain);\r\nirq_domain_free(domain);\r\n}\r\nstatic unsigned int irq_domain_legacy_revmap(struct irq_domain *domain,\r\nirq_hw_number_t hwirq)\r\n{\r\nirq_hw_number_t first_hwirq = domain->revmap_data.legacy.first_hwirq;\r\nint size = domain->revmap_data.legacy.size;\r\nif (WARN_ON(hwirq < first_hwirq || hwirq >= first_hwirq + size))\r\nreturn 0;\r\nreturn hwirq - first_hwirq + domain->revmap_data.legacy.first_irq;\r\n}\r\nstruct irq_domain *irq_domain_add_simple(struct device_node *of_node,\r\nunsigned int size,\r\nunsigned int first_irq,\r\nconst struct irq_domain_ops *ops,\r\nvoid *host_data)\r\n{\r\nif (first_irq > 0) {\r\nint irq_base;\r\nif (IS_ENABLED(CONFIG_SPARSE_IRQ)) {\r\nirq_base = irq_alloc_descs(first_irq, first_irq, size,\r\nof_node_to_nid(of_node));\r\nif (irq_base < 0) {\r\npr_info("Cannot allocate irq_descs @ IRQ%d, assuming pre-allocated\n",\r\nfirst_irq);\r\nirq_base = first_irq;\r\n}\r\n} else\r\nirq_base = first_irq;\r\nreturn irq_domain_add_legacy(of_node, size, irq_base, 0,\r\nops, host_data);\r\n}\r\nreturn irq_domain_add_linear(of_node, size, ops, host_data);\r\n}\r\nstruct irq_domain *irq_domain_add_legacy(struct device_node *of_node,\r\nunsigned int size,\r\nunsigned int first_irq,\r\nirq_hw_number_t first_hwirq,\r\nconst struct irq_domain_ops *ops,\r\nvoid *host_data)\r\n{\r\nstruct irq_domain *domain;\r\nunsigned int i;\r\ndomain = irq_domain_alloc(of_node, IRQ_DOMAIN_MAP_LEGACY, ops, host_data);\r\nif (!domain)\r\nreturn NULL;\r\ndomain->revmap_data.legacy.first_irq = first_irq;\r\ndomain->revmap_data.legacy.first_hwirq = first_hwirq;\r\ndomain->revmap_data.legacy.size = size;\r\nmutex_lock(&irq_domain_mutex);\r\nfor (i = 0; i < size; i++) {\r\nint irq = first_irq + i;\r\nstruct irq_data *irq_data = irq_get_irq_data(irq);\r\nif (WARN_ON(!irq_data || irq_data->domain)) {\r\nmutex_unlock(&irq_domain_mutex);\r\nirq_domain_free(domain);\r\nreturn NULL;\r\n}\r\n}\r\nfor (i = 0; i < size; i++) {\r\nstruct irq_data *irq_data = irq_get_irq_data(first_irq + i);\r\nirq_data->hwirq = first_hwirq + i;\r\nirq_data->domain = domain;\r\n}\r\nmutex_unlock(&irq_domain_mutex);\r\nfor (i = 0; i < size; i++) {\r\nint irq = first_irq + i;\r\nint hwirq = first_hwirq + i;\r\nif (!irq)\r\ncontinue;\r\nif (ops->map)\r\nops->map(domain, irq, hwirq);\r\nirq_clear_status_flags(irq, IRQ_NOREQUEST);\r\n}\r\nirq_domain_add(domain);\r\nreturn domain;\r\n}\r\nstruct irq_domain *irq_domain_add_linear(struct device_node *of_node,\r\nunsigned int size,\r\nconst struct irq_domain_ops *ops,\r\nvoid *host_data)\r\n{\r\nstruct irq_domain *domain;\r\nunsigned int *revmap;\r\nrevmap = kzalloc_node(sizeof(*revmap) * size, GFP_KERNEL,\r\nof_node_to_nid(of_node));\r\nif (WARN_ON(!revmap))\r\nreturn NULL;\r\ndomain = irq_domain_alloc(of_node, IRQ_DOMAIN_MAP_LINEAR, ops, host_data);\r\nif (!domain) {\r\nkfree(revmap);\r\nreturn NULL;\r\n}\r\ndomain->revmap_data.linear.size = size;\r\ndomain->revmap_data.linear.revmap = revmap;\r\nirq_domain_add(domain);\r\nreturn domain;\r\n}\r\nstruct irq_domain *irq_domain_add_nomap(struct device_node *of_node,\r\nunsigned int max_irq,\r\nconst struct irq_domain_ops *ops,\r\nvoid *host_data)\r\n{\r\nstruct irq_domain *domain = irq_domain_alloc(of_node,\r\nIRQ_DOMAIN_MAP_NOMAP, ops, host_data);\r\nif (domain) {\r\ndomain->revmap_data.nomap.max_irq = max_irq ? max_irq : ~0;\r\nirq_domain_add(domain);\r\n}\r\nreturn domain;\r\n}\r\nstruct irq_domain *irq_domain_add_tree(struct device_node *of_node,\r\nconst struct irq_domain_ops *ops,\r\nvoid *host_data)\r\n{\r\nstruct irq_domain *domain = irq_domain_alloc(of_node,\r\nIRQ_DOMAIN_MAP_TREE, ops, host_data);\r\nif (domain) {\r\nINIT_RADIX_TREE(&domain->revmap_data.tree, GFP_KERNEL);\r\nirq_domain_add(domain);\r\n}\r\nreturn domain;\r\n}\r\nstruct irq_domain *irq_find_host(struct device_node *node)\r\n{\r\nstruct irq_domain *h, *found = NULL;\r\nint rc;\r\nmutex_lock(&irq_domain_mutex);\r\nlist_for_each_entry(h, &irq_domain_list, link) {\r\nif (h->ops->match)\r\nrc = h->ops->match(h, node);\r\nelse\r\nrc = (h->of_node != NULL) && (h->of_node == node);\r\nif (rc) {\r\nfound = h;\r\nbreak;\r\n}\r\n}\r\nmutex_unlock(&irq_domain_mutex);\r\nreturn found;\r\n}\r\nvoid irq_set_default_host(struct irq_domain *domain)\r\n{\r\npr_debug("Default domain set to @0x%p\n", domain);\r\nirq_default_domain = domain;\r\n}\r\nstatic void irq_domain_disassociate_many(struct irq_domain *domain,\r\nunsigned int irq_base, int count)\r\n{\r\nwhile (count--) {\r\nint irq = irq_base + count;\r\nstruct irq_data *irq_data = irq_get_irq_data(irq);\r\nirq_hw_number_t hwirq = irq_data->hwirq;\r\nif (WARN_ON(!irq_data || irq_data->domain != domain))\r\ncontinue;\r\nirq_set_status_flags(irq, IRQ_NOREQUEST);\r\nirq_set_chip_and_handler(irq, NULL, NULL);\r\nsynchronize_irq(irq);\r\nif (domain->ops->unmap)\r\ndomain->ops->unmap(domain, irq);\r\nsmp_mb();\r\nirq_data->domain = NULL;\r\nirq_data->hwirq = 0;\r\nswitch(domain->revmap_type) {\r\ncase IRQ_DOMAIN_MAP_LINEAR:\r\nif (hwirq < domain->revmap_data.linear.size)\r\ndomain->revmap_data.linear.revmap[hwirq] = 0;\r\nbreak;\r\ncase IRQ_DOMAIN_MAP_TREE:\r\nmutex_lock(&revmap_trees_mutex);\r\nradix_tree_delete(&domain->revmap_data.tree, hwirq);\r\nmutex_unlock(&revmap_trees_mutex);\r\nbreak;\r\n}\r\n}\r\n}\r\nint irq_domain_associate_many(struct irq_domain *domain, unsigned int irq_base,\r\nirq_hw_number_t hwirq_base, int count)\r\n{\r\nunsigned int virq = irq_base;\r\nirq_hw_number_t hwirq = hwirq_base;\r\nint i, ret;\r\npr_debug("%s(%s, irqbase=%i, hwbase=%i, count=%i)\n", __func__,\r\nof_node_full_name(domain->of_node), irq_base, (int)hwirq_base, count);\r\nfor (i = 0; i < count; i++) {\r\nstruct irq_data *irq_data = irq_get_irq_data(virq + i);\r\nif (WARN(!irq_data, "error: irq_desc not allocated; "\r\n"irq=%i hwirq=0x%x\n", virq + i, (int)hwirq + i))\r\nreturn -EINVAL;\r\nif (WARN(irq_data->domain, "error: irq_desc already associated; "\r\n"irq=%i hwirq=0x%x\n", virq + i, (int)hwirq + i))\r\nreturn -EINVAL;\r\n};\r\nfor (i = 0; i < count; i++, virq++, hwirq++) {\r\nstruct irq_data *irq_data = irq_get_irq_data(virq);\r\nirq_data->hwirq = hwirq;\r\nirq_data->domain = domain;\r\nif (domain->ops->map) {\r\nret = domain->ops->map(domain, virq, hwirq);\r\nif (ret != 0) {\r\npr_err("irq-%i==>hwirq-0x%lx mapping failed: %d\n",\r\nvirq, hwirq, ret);\r\nWARN_ON(1);\r\nirq_data->domain = NULL;\r\nirq_data->hwirq = 0;\r\ngoto err_unmap;\r\n}\r\n}\r\nswitch (domain->revmap_type) {\r\ncase IRQ_DOMAIN_MAP_LINEAR:\r\nif (hwirq < domain->revmap_data.linear.size)\r\ndomain->revmap_data.linear.revmap[hwirq] = virq;\r\nbreak;\r\ncase IRQ_DOMAIN_MAP_TREE:\r\nmutex_lock(&revmap_trees_mutex);\r\nradix_tree_insert(&domain->revmap_data.tree, hwirq, irq_data);\r\nmutex_unlock(&revmap_trees_mutex);\r\nbreak;\r\n}\r\nirq_clear_status_flags(virq, IRQ_NOREQUEST);\r\n}\r\nreturn 0;\r\nerr_unmap:\r\nirq_domain_disassociate_many(domain, irq_base, i);\r\nreturn -EINVAL;\r\n}\r\nunsigned int irq_create_direct_mapping(struct irq_domain *domain)\r\n{\r\nunsigned int virq;\r\nif (domain == NULL)\r\ndomain = irq_default_domain;\r\nif (WARN_ON(!domain || domain->revmap_type != IRQ_DOMAIN_MAP_NOMAP))\r\nreturn 0;\r\nvirq = irq_alloc_desc_from(1, of_node_to_nid(domain->of_node));\r\nif (!virq) {\r\npr_debug("create_direct virq allocation failed\n");\r\nreturn 0;\r\n}\r\nif (virq >= domain->revmap_data.nomap.max_irq) {\r\npr_err("ERROR: no free irqs available below %i maximum\n",\r\ndomain->revmap_data.nomap.max_irq);\r\nirq_free_desc(virq);\r\nreturn 0;\r\n}\r\npr_debug("create_direct obtained virq %d\n", virq);\r\nif (irq_domain_associate(domain, virq, virq)) {\r\nirq_free_desc(virq);\r\nreturn 0;\r\n}\r\nreturn virq;\r\n}\r\nunsigned int irq_create_mapping(struct irq_domain *domain,\r\nirq_hw_number_t hwirq)\r\n{\r\nunsigned int hint;\r\nint virq;\r\npr_debug("irq_create_mapping(0x%p, 0x%lx)\n", domain, hwirq);\r\nif (domain == NULL)\r\ndomain = irq_default_domain;\r\nif (domain == NULL) {\r\npr_warning("irq_create_mapping called for"\r\n" NULL domain, hwirq=%lx\n", hwirq);\r\nWARN_ON(1);\r\nreturn 0;\r\n}\r\npr_debug("-> using domain @%p\n", domain);\r\nvirq = irq_find_mapping(domain, hwirq);\r\nif (virq) {\r\npr_debug("-> existing mapping on virq %d\n", virq);\r\nreturn virq;\r\n}\r\nif (domain->revmap_type == IRQ_DOMAIN_MAP_LEGACY)\r\nreturn irq_domain_legacy_revmap(domain, hwirq);\r\nhint = hwirq % nr_irqs;\r\nif (hint == 0)\r\nhint++;\r\nvirq = irq_alloc_desc_from(hint, of_node_to_nid(domain->of_node));\r\nif (virq <= 0)\r\nvirq = irq_alloc_desc_from(1, of_node_to_nid(domain->of_node));\r\nif (virq <= 0) {\r\npr_debug("-> virq allocation failed\n");\r\nreturn 0;\r\n}\r\nif (irq_domain_associate(domain, virq, hwirq)) {\r\nirq_free_desc(virq);\r\nreturn 0;\r\n}\r\npr_debug("irq %lu on domain %s mapped to virtual irq %u\n",\r\nhwirq, of_node_full_name(domain->of_node), virq);\r\nreturn virq;\r\n}\r\nint irq_create_strict_mappings(struct irq_domain *domain, unsigned int irq_base,\r\nirq_hw_number_t hwirq_base, int count)\r\n{\r\nint ret;\r\nret = irq_alloc_descs(irq_base, irq_base, count,\r\nof_node_to_nid(domain->of_node));\r\nif (unlikely(ret < 0))\r\nreturn ret;\r\nret = irq_domain_associate_many(domain, irq_base, hwirq_base, count);\r\nif (unlikely(ret < 0)) {\r\nirq_free_descs(irq_base, count);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nunsigned int irq_create_of_mapping(struct device_node *controller,\r\nconst u32 *intspec, unsigned int intsize)\r\n{\r\nstruct irq_domain *domain;\r\nirq_hw_number_t hwirq;\r\nunsigned int type = IRQ_TYPE_NONE;\r\nunsigned int virq;\r\ndomain = controller ? irq_find_host(controller) : irq_default_domain;\r\nif (!domain) {\r\n#ifdef CONFIG_MIPS\r\nif (intsize > 0)\r\nreturn intspec[0];\r\n#endif\r\npr_warning("no irq domain found for %s !\n",\r\nof_node_full_name(controller));\r\nreturn 0;\r\n}\r\nif (domain->ops->xlate == NULL)\r\nhwirq = intspec[0];\r\nelse {\r\nif (domain->ops->xlate(domain, controller, intspec, intsize,\r\n&hwirq, &type))\r\nreturn 0;\r\n}\r\nvirq = irq_create_mapping(domain, hwirq);\r\nif (!virq)\r\nreturn virq;\r\nif (type != IRQ_TYPE_NONE &&\r\ntype != (irqd_get_trigger_type(irq_get_irq_data(virq))))\r\nirq_set_irq_type(virq, type);\r\nreturn virq;\r\n}\r\nvoid irq_dispose_mapping(unsigned int virq)\r\n{\r\nstruct irq_data *irq_data = irq_get_irq_data(virq);\r\nstruct irq_domain *domain;\r\nif (!virq || !irq_data)\r\nreturn;\r\ndomain = irq_data->domain;\r\nif (WARN_ON(domain == NULL))\r\nreturn;\r\nif (domain->revmap_type == IRQ_DOMAIN_MAP_LEGACY)\r\nreturn;\r\nirq_domain_disassociate_many(domain, virq, 1);\r\nirq_free_desc(virq);\r\n}\r\nunsigned int irq_find_mapping(struct irq_domain *domain,\r\nirq_hw_number_t hwirq)\r\n{\r\nstruct irq_data *data;\r\nif (domain == NULL)\r\ndomain = irq_default_domain;\r\nif (domain == NULL)\r\nreturn 0;\r\nswitch (domain->revmap_type) {\r\ncase IRQ_DOMAIN_MAP_LEGACY:\r\nreturn irq_domain_legacy_revmap(domain, hwirq);\r\ncase IRQ_DOMAIN_MAP_LINEAR:\r\nreturn irq_linear_revmap(domain, hwirq);\r\ncase IRQ_DOMAIN_MAP_TREE:\r\nrcu_read_lock();\r\ndata = radix_tree_lookup(&domain->revmap_data.tree, hwirq);\r\nrcu_read_unlock();\r\nif (data)\r\nreturn data->irq;\r\nbreak;\r\ncase IRQ_DOMAIN_MAP_NOMAP:\r\ndata = irq_get_irq_data(hwirq);\r\nif (data && (data->domain == domain) && (data->hwirq == hwirq))\r\nreturn hwirq;\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nunsigned int irq_linear_revmap(struct irq_domain *domain,\r\nirq_hw_number_t hwirq)\r\n{\r\nBUG_ON(domain->revmap_type != IRQ_DOMAIN_MAP_LINEAR);\r\nif (WARN_ON(hwirq >= domain->revmap_data.linear.size))\r\nreturn 0;\r\nreturn domain->revmap_data.linear.revmap[hwirq];\r\n}\r\nstatic int virq_debug_show(struct seq_file *m, void *private)\r\n{\r\nunsigned long flags;\r\nstruct irq_desc *desc;\r\nconst char *p;\r\nstatic const char none[] = "none";\r\nvoid *data;\r\nint i;\r\nseq_printf(m, "%-5s %-7s %-15s %-*s %s\n", "irq", "hwirq",\r\n"chip name", (int)(2 * sizeof(void *) + 2), "chip data",\r\n"domain name");\r\nfor (i = 1; i < nr_irqs; i++) {\r\ndesc = irq_to_desc(i);\r\nif (!desc)\r\ncontinue;\r\nraw_spin_lock_irqsave(&desc->lock, flags);\r\nif (desc->action && desc->action->handler) {\r\nstruct irq_chip *chip;\r\nseq_printf(m, "%5d ", i);\r\nseq_printf(m, "0x%05lx ", desc->irq_data.hwirq);\r\nchip = irq_desc_get_chip(desc);\r\nif (chip && chip->name)\r\np = chip->name;\r\nelse\r\np = none;\r\nseq_printf(m, "%-15s ", p);\r\ndata = irq_desc_get_chip_data(desc);\r\nseq_printf(m, data ? "0x%p " : " %p ", data);\r\nif (desc->irq_data.domain)\r\np = of_node_full_name(desc->irq_data.domain->of_node);\r\nelse\r\np = none;\r\nseq_printf(m, "%s\n", p);\r\n}\r\nraw_spin_unlock_irqrestore(&desc->lock, flags);\r\n}\r\nreturn 0;\r\n}\r\nstatic int virq_debug_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, virq_debug_show, inode->i_private);\r\n}\r\nstatic int __init irq_debugfs_init(void)\r\n{\r\nif (debugfs_create_file("irq_domain_mapping", S_IRUGO, NULL,\r\nNULL, &virq_debug_fops) == NULL)\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nint irq_domain_xlate_onecell(struct irq_domain *d, struct device_node *ctrlr,\r\nconst u32 *intspec, unsigned int intsize,\r\nunsigned long *out_hwirq, unsigned int *out_type)\r\n{\r\nif (WARN_ON(intsize < 1))\r\nreturn -EINVAL;\r\n*out_hwirq = intspec[0];\r\n*out_type = IRQ_TYPE_NONE;\r\nreturn 0;\r\n}\r\nint irq_domain_xlate_twocell(struct irq_domain *d, struct device_node *ctrlr,\r\nconst u32 *intspec, unsigned int intsize,\r\nirq_hw_number_t *out_hwirq, unsigned int *out_type)\r\n{\r\nif (WARN_ON(intsize < 2))\r\nreturn -EINVAL;\r\n*out_hwirq = intspec[0];\r\n*out_type = intspec[1] & IRQ_TYPE_SENSE_MASK;\r\nreturn 0;\r\n}\r\nint irq_domain_xlate_onetwocell(struct irq_domain *d,\r\nstruct device_node *ctrlr,\r\nconst u32 *intspec, unsigned int intsize,\r\nunsigned long *out_hwirq, unsigned int *out_type)\r\n{\r\nif (WARN_ON(intsize < 1))\r\nreturn -EINVAL;\r\n*out_hwirq = intspec[0];\r\n*out_type = (intsize > 1) ? intspec[1] : IRQ_TYPE_NONE;\r\nreturn 0;\r\n}\r\nvoid irq_domain_generate_simple(const struct of_device_id *match,\r\nu64 phys_base, unsigned int irq_start)\r\n{\r\nstruct device_node *node;\r\npr_debug("looking for phys_base=%llx, irq_start=%i\n",\r\n(unsigned long long) phys_base, (int) irq_start);\r\nnode = of_find_matching_node_by_address(NULL, match, phys_base);\r\nif (node)\r\nirq_domain_add_legacy(node, 32, irq_start, 0,\r\n&irq_domain_simple_ops, NULL);\r\n}
