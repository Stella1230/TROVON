static int adis16130_spi_read(struct iio_dev *indio_dev, u8 reg_addr, u32 *val)\r\n{\r\nint ret;\r\nstruct adis16130_state *st = iio_priv(indio_dev);\r\nstruct spi_message msg;\r\nstruct spi_transfer xfer = {\r\n.tx_buf = st->buf,\r\n.rx_buf = st->buf,\r\n.len = 4,\r\n};\r\nmutex_lock(&st->buf_lock);\r\nst->buf[0] = ADIS16130_CON_RD | reg_addr;\r\nst->buf[1] = st->buf[2] = st->buf[3] = 0;\r\nspi_message_init(&msg);\r\nspi_message_add_tail(&xfer, &msg);\r\nret = spi_sync(st->us, &msg);\r\nret = spi_read(st->us, st->buf, 4);\r\nif (ret == 0)\r\n*val = (st->buf[1] << 16) | (st->buf[2] << 8) | st->buf[3];\r\nmutex_unlock(&st->buf_lock);\r\nreturn ret;\r\n}\r\nstatic int adis16130_read_raw(struct iio_dev *indio_dev,\r\nstruct iio_chan_spec const *chan,\r\nint *val, int *val2,\r\nlong mask)\r\n{\r\nint ret;\r\nu32 temp;\r\nmutex_lock(&indio_dev->mlock);\r\nret = adis16130_spi_read(indio_dev, chan->address, &temp);\r\nmutex_unlock(&indio_dev->mlock);\r\nif (ret)\r\nreturn ret;\r\n*val = temp;\r\nreturn IIO_VAL_INT;\r\n}\r\nstatic int adis16130_probe(struct spi_device *spi)\r\n{\r\nint ret;\r\nstruct adis16130_state *st;\r\nstruct iio_dev *indio_dev;\r\nindio_dev = iio_device_alloc(sizeof(*st));\r\nif (indio_dev == NULL) {\r\nret = -ENOMEM;\r\ngoto error_ret;\r\n}\r\nst = iio_priv(indio_dev);\r\nspi_set_drvdata(spi, indio_dev);\r\nst->us = spi;\r\nmutex_init(&st->buf_lock);\r\nindio_dev->name = spi->dev.driver->name;\r\nindio_dev->channels = adis16130_channels;\r\nindio_dev->num_channels = ARRAY_SIZE(adis16130_channels);\r\nindio_dev->dev.parent = &spi->dev;\r\nindio_dev->info = &adis16130_info;\r\nindio_dev->modes = INDIO_DIRECT_MODE;\r\nret = iio_device_register(indio_dev);\r\nif (ret)\r\ngoto error_free_dev;\r\nreturn 0;\r\nerror_free_dev:\r\niio_device_free(indio_dev);\r\nerror_ret:\r\nreturn ret;\r\n}\r\nstatic int adis16130_remove(struct spi_device *spi)\r\n{\r\niio_device_unregister(spi_get_drvdata(spi));\r\niio_device_free(spi_get_drvdata(spi));\r\nreturn 0;\r\n}
