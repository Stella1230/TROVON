static inline struct adv7604_state *to_state(struct v4l2_subdev *sd)\r\n{\r\nreturn container_of(sd, struct adv7604_state, sd);\r\n}\r\nstatic inline struct v4l2_subdev *to_sd(struct v4l2_ctrl *ctrl)\r\n{\r\nreturn &container_of(ctrl->handler, struct adv7604_state, hdl)->sd;\r\n}\r\nstatic inline unsigned hblanking(const struct v4l2_bt_timings *t)\r\n{\r\nreturn t->hfrontporch + t->hsync + t->hbackporch;\r\n}\r\nstatic inline unsigned htotal(const struct v4l2_bt_timings *t)\r\n{\r\nreturn t->width + t->hfrontporch + t->hsync + t->hbackporch;\r\n}\r\nstatic inline unsigned vblanking(const struct v4l2_bt_timings *t)\r\n{\r\nreturn t->vfrontporch + t->vsync + t->vbackporch;\r\n}\r\nstatic inline unsigned vtotal(const struct v4l2_bt_timings *t)\r\n{\r\nreturn t->height + t->vfrontporch + t->vsync + t->vbackporch;\r\n}\r\nstatic s32 adv_smbus_read_byte_data_check(struct i2c_client *client,\r\nu8 command, bool check)\r\n{\r\nunion i2c_smbus_data data;\r\nif (!i2c_smbus_xfer(client->adapter, client->addr, client->flags,\r\nI2C_SMBUS_READ, command,\r\nI2C_SMBUS_BYTE_DATA, &data))\r\nreturn data.byte;\r\nif (check)\r\nv4l_err(client, "error reading %02x, %02x\n",\r\nclient->addr, command);\r\nreturn -EIO;\r\n}\r\nstatic s32 adv_smbus_read_byte_data(struct i2c_client *client, u8 command)\r\n{\r\nreturn adv_smbus_read_byte_data_check(client, command, true);\r\n}\r\nstatic s32 adv_smbus_write_byte_data(struct i2c_client *client,\r\nu8 command, u8 value)\r\n{\r\nunion i2c_smbus_data data;\r\nint err;\r\nint i;\r\ndata.byte = value;\r\nfor (i = 0; i < 3; i++) {\r\nerr = i2c_smbus_xfer(client->adapter, client->addr,\r\nclient->flags,\r\nI2C_SMBUS_WRITE, command,\r\nI2C_SMBUS_BYTE_DATA, &data);\r\nif (!err)\r\nbreak;\r\n}\r\nif (err < 0)\r\nv4l_err(client, "error writing %02x, %02x, %02x\n",\r\nclient->addr, command, value);\r\nreturn err;\r\n}\r\nstatic s32 adv_smbus_write_i2c_block_data(struct i2c_client *client,\r\nu8 command, unsigned length, const u8 *values)\r\n{\r\nunion i2c_smbus_data data;\r\nif (length > I2C_SMBUS_BLOCK_MAX)\r\nlength = I2C_SMBUS_BLOCK_MAX;\r\ndata.block[0] = length;\r\nmemcpy(data.block + 1, values, length);\r\nreturn i2c_smbus_xfer(client->adapter, client->addr, client->flags,\r\nI2C_SMBUS_WRITE, command,\r\nI2C_SMBUS_I2C_BLOCK_DATA, &data);\r\n}\r\nstatic inline int io_read(struct v4l2_subdev *sd, u8 reg)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nreturn adv_smbus_read_byte_data(client, reg);\r\n}\r\nstatic inline int io_write(struct v4l2_subdev *sd, u8 reg, u8 val)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nreturn adv_smbus_write_byte_data(client, reg, val);\r\n}\r\nstatic inline int io_write_and_or(struct v4l2_subdev *sd, u8 reg, u8 mask, u8 val)\r\n{\r\nreturn io_write(sd, reg, (io_read(sd, reg) & mask) | val);\r\n}\r\nstatic inline int avlink_read(struct v4l2_subdev *sd, u8 reg)\r\n{\r\nstruct adv7604_state *state = to_state(sd);\r\nreturn adv_smbus_read_byte_data(state->i2c_avlink, reg);\r\n}\r\nstatic inline int avlink_write(struct v4l2_subdev *sd, u8 reg, u8 val)\r\n{\r\nstruct adv7604_state *state = to_state(sd);\r\nreturn adv_smbus_write_byte_data(state->i2c_avlink, reg, val);\r\n}\r\nstatic inline int cec_read(struct v4l2_subdev *sd, u8 reg)\r\n{\r\nstruct adv7604_state *state = to_state(sd);\r\nreturn adv_smbus_read_byte_data(state->i2c_cec, reg);\r\n}\r\nstatic inline int cec_write(struct v4l2_subdev *sd, u8 reg, u8 val)\r\n{\r\nstruct adv7604_state *state = to_state(sd);\r\nreturn adv_smbus_write_byte_data(state->i2c_cec, reg, val);\r\n}\r\nstatic inline int cec_write_and_or(struct v4l2_subdev *sd, u8 reg, u8 mask, u8 val)\r\n{\r\nreturn cec_write(sd, reg, (cec_read(sd, reg) & mask) | val);\r\n}\r\nstatic inline int infoframe_read(struct v4l2_subdev *sd, u8 reg)\r\n{\r\nstruct adv7604_state *state = to_state(sd);\r\nreturn adv_smbus_read_byte_data(state->i2c_infoframe, reg);\r\n}\r\nstatic inline int infoframe_write(struct v4l2_subdev *sd, u8 reg, u8 val)\r\n{\r\nstruct adv7604_state *state = to_state(sd);\r\nreturn adv_smbus_write_byte_data(state->i2c_infoframe, reg, val);\r\n}\r\nstatic inline int esdp_read(struct v4l2_subdev *sd, u8 reg)\r\n{\r\nstruct adv7604_state *state = to_state(sd);\r\nreturn adv_smbus_read_byte_data(state->i2c_esdp, reg);\r\n}\r\nstatic inline int esdp_write(struct v4l2_subdev *sd, u8 reg, u8 val)\r\n{\r\nstruct adv7604_state *state = to_state(sd);\r\nreturn adv_smbus_write_byte_data(state->i2c_esdp, reg, val);\r\n}\r\nstatic inline int dpp_read(struct v4l2_subdev *sd, u8 reg)\r\n{\r\nstruct adv7604_state *state = to_state(sd);\r\nreturn adv_smbus_read_byte_data(state->i2c_dpp, reg);\r\n}\r\nstatic inline int dpp_write(struct v4l2_subdev *sd, u8 reg, u8 val)\r\n{\r\nstruct adv7604_state *state = to_state(sd);\r\nreturn adv_smbus_write_byte_data(state->i2c_dpp, reg, val);\r\n}\r\nstatic inline int afe_read(struct v4l2_subdev *sd, u8 reg)\r\n{\r\nstruct adv7604_state *state = to_state(sd);\r\nreturn adv_smbus_read_byte_data(state->i2c_afe, reg);\r\n}\r\nstatic inline int afe_write(struct v4l2_subdev *sd, u8 reg, u8 val)\r\n{\r\nstruct adv7604_state *state = to_state(sd);\r\nreturn adv_smbus_write_byte_data(state->i2c_afe, reg, val);\r\n}\r\nstatic inline int rep_read(struct v4l2_subdev *sd, u8 reg)\r\n{\r\nstruct adv7604_state *state = to_state(sd);\r\nreturn adv_smbus_read_byte_data(state->i2c_repeater, reg);\r\n}\r\nstatic inline int rep_write(struct v4l2_subdev *sd, u8 reg, u8 val)\r\n{\r\nstruct adv7604_state *state = to_state(sd);\r\nreturn adv_smbus_write_byte_data(state->i2c_repeater, reg, val);\r\n}\r\nstatic inline int rep_write_and_or(struct v4l2_subdev *sd, u8 reg, u8 mask, u8 val)\r\n{\r\nreturn rep_write(sd, reg, (rep_read(sd, reg) & mask) | val);\r\n}\r\nstatic inline int edid_read(struct v4l2_subdev *sd, u8 reg)\r\n{\r\nstruct adv7604_state *state = to_state(sd);\r\nreturn adv_smbus_read_byte_data(state->i2c_edid, reg);\r\n}\r\nstatic inline int edid_write(struct v4l2_subdev *sd, u8 reg, u8 val)\r\n{\r\nstruct adv7604_state *state = to_state(sd);\r\nreturn adv_smbus_write_byte_data(state->i2c_edid, reg, val);\r\n}\r\nstatic inline int edid_read_block(struct v4l2_subdev *sd, unsigned len, u8 *val)\r\n{\r\nstruct adv7604_state *state = to_state(sd);\r\nstruct i2c_client *client = state->i2c_edid;\r\nu8 msgbuf0[1] = { 0 };\r\nu8 msgbuf1[256];\r\nstruct i2c_msg msg[2] = {\r\n{\r\n.addr = client->addr,\r\n.len = 1,\r\n.buf = msgbuf0\r\n},\r\n{\r\n.addr = client->addr,\r\n.flags = I2C_M_RD,\r\n.len = len,\r\n.buf = msgbuf1\r\n},\r\n};\r\nif (i2c_transfer(client->adapter, msg, 2) < 0)\r\nreturn -EIO;\r\nmemcpy(val, msgbuf1, len);\r\nreturn 0;\r\n}\r\nstatic void adv7604_delayed_work_enable_hotplug(struct work_struct *work)\r\n{\r\nstruct delayed_work *dwork = to_delayed_work(work);\r\nstruct adv7604_state *state = container_of(dwork, struct adv7604_state,\r\ndelayed_work_enable_hotplug);\r\nstruct v4l2_subdev *sd = &state->sd;\r\nv4l2_dbg(2, debug, sd, "%s: enable hotplug\n", __func__);\r\nv4l2_subdev_notify(sd, ADV7604_HOTPLUG, (void *)1);\r\n}\r\nstatic inline int edid_write_block(struct v4l2_subdev *sd,\r\nunsigned len, const u8 *val)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nstruct adv7604_state *state = to_state(sd);\r\nint err = 0;\r\nint i;\r\nv4l2_dbg(2, debug, sd, "%s: write EDID block (%d byte)\n", __func__, len);\r\nv4l2_subdev_notify(sd, ADV7604_HOTPLUG, (void *)0);\r\nrep_write_and_or(sd, 0x77, 0xf0, 0x0);\r\nfor (i = 0; !err && i < len; i += I2C_SMBUS_BLOCK_MAX)\r\nerr = adv_smbus_write_i2c_block_data(state->i2c_edid, i,\r\nI2C_SMBUS_BLOCK_MAX, val + i);\r\nif (err)\r\nreturn err;\r\nrep_write_and_or(sd, 0x77, 0xf0, 0x1);\r\nfor (i = 0; i < 1000; i++) {\r\nif (rep_read(sd, 0x7d) & 1)\r\nbreak;\r\nmdelay(1);\r\n}\r\nif (i == 1000) {\r\nv4l_err(client, "error enabling edid\n");\r\nreturn -EIO;\r\n}\r\nqueue_delayed_work(state->work_queues,\r\n&state->delayed_work_enable_hotplug, HZ / 10);\r\nreturn 0;\r\n}\r\nstatic inline int hdmi_read(struct v4l2_subdev *sd, u8 reg)\r\n{\r\nstruct adv7604_state *state = to_state(sd);\r\nreturn adv_smbus_read_byte_data(state->i2c_hdmi, reg);\r\n}\r\nstatic inline int hdmi_write(struct v4l2_subdev *sd, u8 reg, u8 val)\r\n{\r\nstruct adv7604_state *state = to_state(sd);\r\nreturn adv_smbus_write_byte_data(state->i2c_hdmi, reg, val);\r\n}\r\nstatic inline int test_read(struct v4l2_subdev *sd, u8 reg)\r\n{\r\nstruct adv7604_state *state = to_state(sd);\r\nreturn adv_smbus_read_byte_data(state->i2c_test, reg);\r\n}\r\nstatic inline int test_write(struct v4l2_subdev *sd, u8 reg, u8 val)\r\n{\r\nstruct adv7604_state *state = to_state(sd);\r\nreturn adv_smbus_write_byte_data(state->i2c_test, reg, val);\r\n}\r\nstatic inline int cp_read(struct v4l2_subdev *sd, u8 reg)\r\n{\r\nstruct adv7604_state *state = to_state(sd);\r\nreturn adv_smbus_read_byte_data(state->i2c_cp, reg);\r\n}\r\nstatic inline int cp_write(struct v4l2_subdev *sd, u8 reg, u8 val)\r\n{\r\nstruct adv7604_state *state = to_state(sd);\r\nreturn adv_smbus_write_byte_data(state->i2c_cp, reg, val);\r\n}\r\nstatic inline int cp_write_and_or(struct v4l2_subdev *sd, u8 reg, u8 mask, u8 val)\r\n{\r\nreturn cp_write(sd, reg, (cp_read(sd, reg) & mask) | val);\r\n}\r\nstatic inline int vdp_read(struct v4l2_subdev *sd, u8 reg)\r\n{\r\nstruct adv7604_state *state = to_state(sd);\r\nreturn adv_smbus_read_byte_data(state->i2c_vdp, reg);\r\n}\r\nstatic inline int vdp_write(struct v4l2_subdev *sd, u8 reg, u8 val)\r\n{\r\nstruct adv7604_state *state = to_state(sd);\r\nreturn adv_smbus_write_byte_data(state->i2c_vdp, reg, val);\r\n}\r\nstatic void adv7604_inv_register(struct v4l2_subdev *sd)\r\n{\r\nv4l2_info(sd, "0x000-0x0ff: IO Map\n");\r\nv4l2_info(sd, "0x100-0x1ff: AVLink Map\n");\r\nv4l2_info(sd, "0x200-0x2ff: CEC Map\n");\r\nv4l2_info(sd, "0x300-0x3ff: InfoFrame Map\n");\r\nv4l2_info(sd, "0x400-0x4ff: ESDP Map\n");\r\nv4l2_info(sd, "0x500-0x5ff: DPP Map\n");\r\nv4l2_info(sd, "0x600-0x6ff: AFE Map\n");\r\nv4l2_info(sd, "0x700-0x7ff: Repeater Map\n");\r\nv4l2_info(sd, "0x800-0x8ff: EDID Map\n");\r\nv4l2_info(sd, "0x900-0x9ff: HDMI Map\n");\r\nv4l2_info(sd, "0xa00-0xaff: Test Map\n");\r\nv4l2_info(sd, "0xb00-0xbff: CP Map\n");\r\nv4l2_info(sd, "0xc00-0xcff: VDP Map\n");\r\n}\r\nstatic int adv7604_g_register(struct v4l2_subdev *sd,\r\nstruct v4l2_dbg_register *reg)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nif (!v4l2_chip_match_i2c_client(client, &reg->match))\r\nreturn -EINVAL;\r\nif (!capable(CAP_SYS_ADMIN))\r\nreturn -EPERM;\r\nreg->size = 1;\r\nswitch (reg->reg >> 8) {\r\ncase 0:\r\nreg->val = io_read(sd, reg->reg & 0xff);\r\nbreak;\r\ncase 1:\r\nreg->val = avlink_read(sd, reg->reg & 0xff);\r\nbreak;\r\ncase 2:\r\nreg->val = cec_read(sd, reg->reg & 0xff);\r\nbreak;\r\ncase 3:\r\nreg->val = infoframe_read(sd, reg->reg & 0xff);\r\nbreak;\r\ncase 4:\r\nreg->val = esdp_read(sd, reg->reg & 0xff);\r\nbreak;\r\ncase 5:\r\nreg->val = dpp_read(sd, reg->reg & 0xff);\r\nbreak;\r\ncase 6:\r\nreg->val = afe_read(sd, reg->reg & 0xff);\r\nbreak;\r\ncase 7:\r\nreg->val = rep_read(sd, reg->reg & 0xff);\r\nbreak;\r\ncase 8:\r\nreg->val = edid_read(sd, reg->reg & 0xff);\r\nbreak;\r\ncase 9:\r\nreg->val = hdmi_read(sd, reg->reg & 0xff);\r\nbreak;\r\ncase 0xa:\r\nreg->val = test_read(sd, reg->reg & 0xff);\r\nbreak;\r\ncase 0xb:\r\nreg->val = cp_read(sd, reg->reg & 0xff);\r\nbreak;\r\ncase 0xc:\r\nreg->val = vdp_read(sd, reg->reg & 0xff);\r\nbreak;\r\ndefault:\r\nv4l2_info(sd, "Register %03llx not supported\n", reg->reg);\r\nadv7604_inv_register(sd);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int adv7604_s_register(struct v4l2_subdev *sd,\r\nstruct v4l2_dbg_register *reg)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nif (!v4l2_chip_match_i2c_client(client, &reg->match))\r\nreturn -EINVAL;\r\nif (!capable(CAP_SYS_ADMIN))\r\nreturn -EPERM;\r\nswitch (reg->reg >> 8) {\r\ncase 0:\r\nio_write(sd, reg->reg & 0xff, reg->val & 0xff);\r\nbreak;\r\ncase 1:\r\navlink_write(sd, reg->reg & 0xff, reg->val & 0xff);\r\nbreak;\r\ncase 2:\r\ncec_write(sd, reg->reg & 0xff, reg->val & 0xff);\r\nbreak;\r\ncase 3:\r\ninfoframe_write(sd, reg->reg & 0xff, reg->val & 0xff);\r\nbreak;\r\ncase 4:\r\nesdp_write(sd, reg->reg & 0xff, reg->val & 0xff);\r\nbreak;\r\ncase 5:\r\ndpp_write(sd, reg->reg & 0xff, reg->val & 0xff);\r\nbreak;\r\ncase 6:\r\nafe_write(sd, reg->reg & 0xff, reg->val & 0xff);\r\nbreak;\r\ncase 7:\r\nrep_write(sd, reg->reg & 0xff, reg->val & 0xff);\r\nbreak;\r\ncase 8:\r\nedid_write(sd, reg->reg & 0xff, reg->val & 0xff);\r\nbreak;\r\ncase 9:\r\nhdmi_write(sd, reg->reg & 0xff, reg->val & 0xff);\r\nbreak;\r\ncase 0xa:\r\ntest_write(sd, reg->reg & 0xff, reg->val & 0xff);\r\nbreak;\r\ncase 0xb:\r\ncp_write(sd, reg->reg & 0xff, reg->val & 0xff);\r\nbreak;\r\ncase 0xc:\r\nvdp_write(sd, reg->reg & 0xff, reg->val & 0xff);\r\nbreak;\r\ndefault:\r\nv4l2_info(sd, "Register %03llx not supported\n", reg->reg);\r\nadv7604_inv_register(sd);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int adv7604_s_detect_tx_5v_ctrl(struct v4l2_subdev *sd)\r\n{\r\nstruct adv7604_state *state = to_state(sd);\r\nreturn v4l2_ctrl_s_ctrl(state->detect_tx_5v_ctrl,\r\n((io_read(sd, 0x6f) & 0x10) >> 4));\r\n}\r\nstatic int find_and_set_predefined_video_timings(struct v4l2_subdev *sd,\r\nu8 prim_mode,\r\nconst struct adv7604_video_standards *predef_vid_timings,\r\nconst struct v4l2_dv_timings *timings)\r\n{\r\nstruct adv7604_state *state = to_state(sd);\r\nint i;\r\nfor (i = 0; predef_vid_timings[i].timings.bt.width; i++) {\r\nif (!v4l_match_dv_timings(timings, &predef_vid_timings[i].timings,\r\nDIGITAL_INPUT ? 250000 : 1000000))\r\ncontinue;\r\nio_write(sd, 0x00, predef_vid_timings[i].vid_std);\r\nio_write(sd, 0x01, (predef_vid_timings[i].v_freq << 4) +\r\nprim_mode);\r\nreturn 0;\r\n}\r\nreturn -1;\r\n}\r\nstatic int configure_predefined_video_timings(struct v4l2_subdev *sd,\r\nstruct v4l2_dv_timings *timings)\r\n{\r\nstruct adv7604_state *state = to_state(sd);\r\nint err;\r\nv4l2_dbg(1, debug, sd, "%s", __func__);\r\nio_write(sd, 0x16, 0x43);\r\nio_write(sd, 0x17, 0x5a);\r\ncp_write_and_or(sd, 0x81, 0xef, 0x00);\r\ncp_write(sd, 0x8f, 0x00);\r\ncp_write(sd, 0x90, 0x00);\r\ncp_write(sd, 0xa2, 0x00);\r\ncp_write(sd, 0xa3, 0x00);\r\ncp_write(sd, 0xa4, 0x00);\r\ncp_write(sd, 0xa5, 0x00);\r\ncp_write(sd, 0xa6, 0x00);\r\ncp_write(sd, 0xa7, 0x00);\r\ncp_write(sd, 0xab, 0x00);\r\ncp_write(sd, 0xac, 0x00);\r\nswitch (state->mode) {\r\ncase ADV7604_MODE_COMP:\r\ncase ADV7604_MODE_GR:\r\nerr = find_and_set_predefined_video_timings(sd,\r\n0x01, adv7604_prim_mode_comp, timings);\r\nif (err)\r\nerr = find_and_set_predefined_video_timings(sd,\r\n0x02, adv7604_prim_mode_gr, timings);\r\nbreak;\r\ncase ADV7604_MODE_HDMI:\r\nerr = find_and_set_predefined_video_timings(sd,\r\n0x05, adv7604_prim_mode_hdmi_comp, timings);\r\nif (err)\r\nerr = find_and_set_predefined_video_timings(sd,\r\n0x06, adv7604_prim_mode_hdmi_gr, timings);\r\nbreak;\r\ndefault:\r\nv4l2_dbg(2, debug, sd, "%s: Unknown mode %d\n",\r\n__func__, state->mode);\r\nerr = -1;\r\nbreak;\r\n}\r\nreturn err;\r\n}\r\nstatic void configure_custom_video_timings(struct v4l2_subdev *sd,\r\nconst struct v4l2_bt_timings *bt)\r\n{\r\nstruct adv7604_state *state = to_state(sd);\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nu32 width = htotal(bt);\r\nu32 height = vtotal(bt);\r\nu16 cp_start_sav = bt->hsync + bt->hbackporch - 4;\r\nu16 cp_start_eav = width - bt->hfrontporch;\r\nu16 cp_start_vbi = height - bt->vfrontporch;\r\nu16 cp_end_vbi = bt->vsync + bt->vbackporch;\r\nu16 ch1_fr_ll = (((u32)bt->pixelclock / 100) > 0) ?\r\n((width * (ADV7604_fsc / 100)) / ((u32)bt->pixelclock / 100)) : 0;\r\nconst u8 pll[2] = {\r\n0xc0 | ((width >> 8) & 0x1f),\r\nwidth & 0xff\r\n};\r\nv4l2_dbg(2, debug, sd, "%s\n", __func__);\r\nswitch (state->mode) {\r\ncase ADV7604_MODE_COMP:\r\ncase ADV7604_MODE_GR:\r\nio_write(sd, 0x00, 0x07);\r\nio_write(sd, 0x01, 0x02);\r\ncp_write_and_or(sd, 0x81, 0xef, 0x10);\r\nif (adv_smbus_write_i2c_block_data(client, 0x16, 2, pll)) {\r\nv4l2_err(sd, "writing to reg 0x16 and 0x17 failed\n");\r\nbreak;\r\n}\r\ncp_write(sd, 0xa2, (cp_start_sav >> 4) & 0xff);\r\ncp_write(sd, 0xa3, ((cp_start_sav & 0x0f) << 4) |\r\n((cp_start_eav >> 8) & 0x0f));\r\ncp_write(sd, 0xa4, cp_start_eav & 0xff);\r\ncp_write(sd, 0xa5, (cp_start_vbi >> 4) & 0xff);\r\ncp_write(sd, 0xa6, ((cp_start_vbi & 0xf) << 4) |\r\n((cp_end_vbi >> 8) & 0xf));\r\ncp_write(sd, 0xa7, cp_end_vbi & 0xff);\r\nbreak;\r\ncase ADV7604_MODE_HDMI:\r\nio_write(sd, 0x00, 0x02);\r\nio_write(sd, 0x01, 0x06);\r\nbreak;\r\ndefault:\r\nv4l2_dbg(2, debug, sd, "%s: Unknown mode %d\n",\r\n__func__, state->mode);\r\nbreak;\r\n}\r\ncp_write(sd, 0x8f, (ch1_fr_ll >> 8) & 0x7);\r\ncp_write(sd, 0x90, ch1_fr_ll & 0xff);\r\ncp_write(sd, 0xab, (height >> 4) & 0xff);\r\ncp_write(sd, 0xac, (height & 0x0f) << 4);\r\n}\r\nstatic void set_rgb_quantization_range(struct v4l2_subdev *sd)\r\n{\r\nstruct adv7604_state *state = to_state(sd);\r\nswitch (state->rgb_quantization_range) {\r\ncase V4L2_DV_RGB_RANGE_AUTO:\r\nif (DIGITAL_INPUT && !(hdmi_read(sd, 0x05) & 0x80)) {\r\nif (state->timings.bt.standards & V4L2_DV_BT_STD_CEA861) {\r\nio_write_and_or(sd, 0x02, 0x0f, 0x00);\r\n} else {\r\nio_write_and_or(sd, 0x02, 0x0f, 0x10);\r\n}\r\n} else {\r\nio_write_and_or(sd, 0x02, 0x0f, 0xf0);\r\n}\r\nbreak;\r\ncase V4L2_DV_RGB_RANGE_LIMITED:\r\nio_write_and_or(sd, 0x02, 0x0f, 0x00);\r\nbreak;\r\ncase V4L2_DV_RGB_RANGE_FULL:\r\nio_write_and_or(sd, 0x02, 0x0f, 0x10);\r\nbreak;\r\n}\r\n}\r\nstatic int adv7604_s_ctrl(struct v4l2_ctrl *ctrl)\r\n{\r\nstruct v4l2_subdev *sd = to_sd(ctrl);\r\nstruct adv7604_state *state = to_state(sd);\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_BRIGHTNESS:\r\ncp_write(sd, 0x3c, ctrl->val);\r\nreturn 0;\r\ncase V4L2_CID_CONTRAST:\r\ncp_write(sd, 0x3a, ctrl->val);\r\nreturn 0;\r\ncase V4L2_CID_SATURATION:\r\ncp_write(sd, 0x3b, ctrl->val);\r\nreturn 0;\r\ncase V4L2_CID_HUE:\r\ncp_write(sd, 0x3d, ctrl->val);\r\nreturn 0;\r\ncase V4L2_CID_DV_RX_RGB_RANGE:\r\nstate->rgb_quantization_range = ctrl->val;\r\nset_rgb_quantization_range(sd);\r\nreturn 0;\r\ncase V4L2_CID_ADV_RX_ANALOG_SAMPLING_PHASE:\r\nafe_write(sd, 0xc8, ctrl->val);\r\nreturn 0;\r\ncase V4L2_CID_ADV_RX_FREE_RUN_COLOR_MANUAL:\r\ncp_write_and_or(sd, 0xbf, ~0x04, (ctrl->val << 2));\r\nreturn 0;\r\ncase V4L2_CID_ADV_RX_FREE_RUN_COLOR:\r\ncp_write(sd, 0xc0, (ctrl->val & 0xff0000) >> 16);\r\ncp_write(sd, 0xc1, (ctrl->val & 0x00ff00) >> 8);\r\ncp_write(sd, 0xc2, (u8)(ctrl->val & 0x0000ff));\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int adv7604_g_chip_ident(struct v4l2_subdev *sd,\r\nstruct v4l2_dbg_chip_ident *chip)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nreturn v4l2_chip_ident_i2c_client(client, chip, V4L2_IDENT_ADV7604, 0);\r\n}\r\nstatic inline bool no_power(struct v4l2_subdev *sd)\r\n{\r\nreturn io_read(sd, 0x0c) & 0x24;\r\n}\r\nstatic inline bool no_signal_tmds(struct v4l2_subdev *sd)\r\n{\r\nreturn !(io_read(sd, 0x6a) & 0x10);\r\n}\r\nstatic inline bool no_lock_tmds(struct v4l2_subdev *sd)\r\n{\r\nreturn (io_read(sd, 0x6a) & 0xe0) != 0xe0;\r\n}\r\nstatic inline bool no_lock_sspd(struct v4l2_subdev *sd)\r\n{\r\nreturn ((cp_read(sd, 0xb5) & 0xd0) != 0xd0);\r\n}\r\nstatic inline bool no_lock_stdi(struct v4l2_subdev *sd)\r\n{\r\nreturn !(cp_read(sd, 0xb1) & 0x80);\r\n}\r\nstatic inline bool no_signal(struct v4l2_subdev *sd)\r\n{\r\nstruct adv7604_state *state = to_state(sd);\r\nbool ret;\r\nret = no_power(sd);\r\nret |= no_lock_stdi(sd);\r\nret |= no_lock_sspd(sd);\r\nif (DIGITAL_INPUT) {\r\nret |= no_lock_tmds(sd);\r\nret |= no_signal_tmds(sd);\r\n}\r\nreturn ret;\r\n}\r\nstatic inline bool no_lock_cp(struct v4l2_subdev *sd)\r\n{\r\nreturn io_read(sd, 0x12) & 0x01;\r\n}\r\nstatic int adv7604_g_input_status(struct v4l2_subdev *sd, u32 *status)\r\n{\r\nstruct adv7604_state *state = to_state(sd);\r\n*status = 0;\r\n*status |= no_power(sd) ? V4L2_IN_ST_NO_POWER : 0;\r\n*status |= no_signal(sd) ? V4L2_IN_ST_NO_SIGNAL : 0;\r\nif (no_lock_cp(sd))\r\n*status |= DIGITAL_INPUT ? V4L2_IN_ST_NO_SYNC : V4L2_IN_ST_NO_H_LOCK;\r\nv4l2_dbg(1, debug, sd, "%s: status = 0x%x\n", __func__, *status);\r\nreturn 0;\r\n}\r\nstatic void adv7604_print_timings(struct v4l2_subdev *sd,\r\nstruct v4l2_dv_timings *timings, const char *txt, bool detailed)\r\n{\r\nstruct v4l2_bt_timings *bt = &timings->bt;\r\nu32 htot, vtot;\r\nif (timings->type != V4L2_DV_BT_656_1120)\r\nreturn;\r\nhtot = htotal(bt);\r\nvtot = vtotal(bt);\r\nv4l2_info(sd, "%s %dx%d%s%d (%dx%d)",\r\ntxt, bt->width, bt->height, bt->interlaced ? "i" : "p",\r\n(htot * vtot) > 0 ? ((u32)bt->pixelclock /\r\n(htot * vtot)) : 0,\r\nhtot, vtot);\r\nif (detailed) {\r\nv4l2_info(sd, " horizontal: fp = %d, %ssync = %d, bp = %d\n",\r\nbt->hfrontporch,\r\n(bt->polarities & V4L2_DV_HSYNC_POS_POL) ? "+" : "-",\r\nbt->hsync, bt->hbackporch);\r\nv4l2_info(sd, " vertical: fp = %d, %ssync = %d, bp = %d\n",\r\nbt->vfrontporch,\r\n(bt->polarities & V4L2_DV_VSYNC_POS_POL) ? "+" : "-",\r\nbt->vsync, bt->vbackporch);\r\nv4l2_info(sd, " pixelclock: %lld, flags: 0x%x, standards: 0x%x\n",\r\nbt->pixelclock, bt->flags, bt->standards);\r\n}\r\n}\r\nstatic int stdi2dv_timings(struct v4l2_subdev *sd,\r\nstruct stdi_readback *stdi,\r\nstruct v4l2_dv_timings *timings)\r\n{\r\nstruct adv7604_state *state = to_state(sd);\r\nu32 hfreq = (ADV7604_fsc * 8) / stdi->bl;\r\nu32 pix_clk;\r\nint i;\r\nfor (i = 0; adv7604_timings[i].bt.height; i++) {\r\nif (vtotal(&adv7604_timings[i].bt) != stdi->lcf + 1)\r\ncontinue;\r\nif (adv7604_timings[i].bt.vsync != stdi->lcvs)\r\ncontinue;\r\npix_clk = hfreq * htotal(&adv7604_timings[i].bt);\r\nif ((pix_clk < adv7604_timings[i].bt.pixelclock + 1000000) &&\r\n(pix_clk > adv7604_timings[i].bt.pixelclock - 1000000)) {\r\n*timings = adv7604_timings[i];\r\nreturn 0;\r\n}\r\n}\r\nif (v4l2_detect_cvt(stdi->lcf + 1, hfreq, stdi->lcvs,\r\n(stdi->hs_pol == '+' ? V4L2_DV_HSYNC_POS_POL : 0) |\r\n(stdi->vs_pol == '+' ? V4L2_DV_VSYNC_POS_POL : 0),\r\ntimings))\r\nreturn 0;\r\nif (v4l2_detect_gtf(stdi->lcf + 1, hfreq, stdi->lcvs,\r\n(stdi->hs_pol == '+' ? V4L2_DV_HSYNC_POS_POL : 0) |\r\n(stdi->vs_pol == '+' ? V4L2_DV_VSYNC_POS_POL : 0),\r\nstate->aspect_ratio, timings))\r\nreturn 0;\r\nv4l2_dbg(2, debug, sd,\r\n"%s: No format candidate found for lcvs = %d, lcf=%d, bl = %d, %chsync, %cvsync\n",\r\n__func__, stdi->lcvs, stdi->lcf, stdi->bl,\r\nstdi->hs_pol, stdi->vs_pol);\r\nreturn -1;\r\n}\r\nstatic int read_stdi(struct v4l2_subdev *sd, struct stdi_readback *stdi)\r\n{\r\nif (no_lock_stdi(sd) || no_lock_sspd(sd)) {\r\nv4l2_dbg(2, debug, sd, "%s: STDI and/or SSPD not locked\n", __func__);\r\nreturn -1;\r\n}\r\nstdi->bl = ((cp_read(sd, 0xb1) & 0x3f) << 8) | cp_read(sd, 0xb2);\r\nstdi->lcf = ((cp_read(sd, 0xb3) & 0x7) << 8) | cp_read(sd, 0xb4);\r\nstdi->lcvs = cp_read(sd, 0xb3) >> 3;\r\nstdi->interlaced = io_read(sd, 0x12) & 0x10;\r\nif ((cp_read(sd, 0xb5) & 0x03) == 0x01) {\r\nstdi->hs_pol = ((cp_read(sd, 0xb5) & 0x10) ?\r\n((cp_read(sd, 0xb5) & 0x08) ? '+' : '-') : 'x');\r\nstdi->vs_pol = ((cp_read(sd, 0xb5) & 0x40) ?\r\n((cp_read(sd, 0xb5) & 0x20) ? '+' : '-') : 'x');\r\n} else {\r\nstdi->hs_pol = 'x';\r\nstdi->vs_pol = 'x';\r\n}\r\nif (no_lock_stdi(sd) || no_lock_sspd(sd)) {\r\nv4l2_dbg(2, debug, sd,\r\n"%s: signal lost during readout of STDI/SSPD\n", __func__);\r\nreturn -1;\r\n}\r\nif (stdi->lcf < 239 || stdi->bl < 8 || stdi->bl == 0x3fff) {\r\nv4l2_dbg(2, debug, sd, "%s: invalid signal\n", __func__);\r\nmemset(stdi, 0, sizeof(struct stdi_readback));\r\nreturn -1;\r\n}\r\nv4l2_dbg(2, debug, sd,\r\n"%s: lcf (frame height - 1) = %d, bl = %d, lcvs (vsync) = %d, %chsync, %cvsync, %s\n",\r\n__func__, stdi->lcf, stdi->bl, stdi->lcvs,\r\nstdi->hs_pol, stdi->vs_pol,\r\nstdi->interlaced ? "interlaced" : "progressive");\r\nreturn 0;\r\n}\r\nstatic int adv7604_enum_dv_timings(struct v4l2_subdev *sd,\r\nstruct v4l2_enum_dv_timings *timings)\r\n{\r\nif (timings->index >= ARRAY_SIZE(adv7604_timings) - 1)\r\nreturn -EINVAL;\r\nmemset(timings->reserved, 0, sizeof(timings->reserved));\r\ntimings->timings = adv7604_timings[timings->index];\r\nreturn 0;\r\n}\r\nstatic int adv7604_dv_timings_cap(struct v4l2_subdev *sd,\r\nstruct v4l2_dv_timings_cap *cap)\r\n{\r\nstruct adv7604_state *state = to_state(sd);\r\ncap->type = V4L2_DV_BT_656_1120;\r\ncap->bt.max_width = 1920;\r\ncap->bt.max_height = 1200;\r\ncap->bt.min_pixelclock = 27000000;\r\nif (DIGITAL_INPUT)\r\ncap->bt.max_pixelclock = 225000000;\r\nelse\r\ncap->bt.max_pixelclock = 170000000;\r\ncap->bt.standards = V4L2_DV_BT_STD_CEA861 | V4L2_DV_BT_STD_DMT |\r\nV4L2_DV_BT_STD_GTF | V4L2_DV_BT_STD_CVT;\r\ncap->bt.capabilities = V4L2_DV_BT_CAP_PROGRESSIVE |\r\nV4L2_DV_BT_CAP_REDUCED_BLANKING | V4L2_DV_BT_CAP_CUSTOM;\r\nreturn 0;\r\n}\r\nstatic void adv7604_fill_optional_dv_timings_fields(struct v4l2_subdev *sd,\r\nstruct v4l2_dv_timings *timings)\r\n{\r\nstruct adv7604_state *state = to_state(sd);\r\nint i;\r\nfor (i = 0; adv7604_timings[i].bt.width; i++) {\r\nif (v4l_match_dv_timings(timings, &adv7604_timings[i],\r\nDIGITAL_INPUT ? 250000 : 1000000)) {\r\n*timings = adv7604_timings[i];\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic int adv7604_query_dv_timings(struct v4l2_subdev *sd,\r\nstruct v4l2_dv_timings *timings)\r\n{\r\nstruct adv7604_state *state = to_state(sd);\r\nstruct v4l2_bt_timings *bt = &timings->bt;\r\nstruct stdi_readback stdi;\r\nif (!timings)\r\nreturn -EINVAL;\r\nmemset(timings, 0, sizeof(struct v4l2_dv_timings));\r\nif (no_signal(sd)) {\r\nv4l2_dbg(1, debug, sd, "%s: no valid signal\n", __func__);\r\nreturn -ENOLINK;\r\n}\r\nif (read_stdi(sd, &stdi)) {\r\nv4l2_dbg(1, debug, sd, "%s: STDI/SSPD not locked\n", __func__);\r\nreturn -ENOLINK;\r\n}\r\nbt->interlaced = stdi.interlaced ?\r\nV4L2_DV_INTERLACED : V4L2_DV_PROGRESSIVE;\r\nif (DIGITAL_INPUT) {\r\ntimings->type = V4L2_DV_BT_656_1120;\r\nbt->width = (hdmi_read(sd, 0x07) & 0x0f) * 256 + hdmi_read(sd, 0x08);\r\nbt->height = (hdmi_read(sd, 0x09) & 0x0f) * 256 + hdmi_read(sd, 0x0a);\r\nbt->pixelclock = (hdmi_read(sd, 0x06) * 1000000) +\r\n((hdmi_read(sd, 0x3b) & 0x30) >> 4) * 250000;\r\nbt->hfrontporch = (hdmi_read(sd, 0x20) & 0x03) * 256 +\r\nhdmi_read(sd, 0x21);\r\nbt->hsync = (hdmi_read(sd, 0x22) & 0x03) * 256 +\r\nhdmi_read(sd, 0x23);\r\nbt->hbackporch = (hdmi_read(sd, 0x24) & 0x03) * 256 +\r\nhdmi_read(sd, 0x25);\r\nbt->vfrontporch = ((hdmi_read(sd, 0x2a) & 0x1f) * 256 +\r\nhdmi_read(sd, 0x2b)) / 2;\r\nbt->vsync = ((hdmi_read(sd, 0x2e) & 0x1f) * 256 +\r\nhdmi_read(sd, 0x2f)) / 2;\r\nbt->vbackporch = ((hdmi_read(sd, 0x32) & 0x1f) * 256 +\r\nhdmi_read(sd, 0x33)) / 2;\r\nbt->polarities = ((hdmi_read(sd, 0x05) & 0x10) ? V4L2_DV_VSYNC_POS_POL : 0) |\r\n((hdmi_read(sd, 0x05) & 0x20) ? V4L2_DV_HSYNC_POS_POL : 0);\r\nif (bt->interlaced == V4L2_DV_INTERLACED) {\r\nbt->height += (hdmi_read(sd, 0x0b) & 0x0f) * 256 +\r\nhdmi_read(sd, 0x0c);\r\nbt->il_vfrontporch = ((hdmi_read(sd, 0x2c) & 0x1f) * 256 +\r\nhdmi_read(sd, 0x2d)) / 2;\r\nbt->il_vsync = ((hdmi_read(sd, 0x30) & 0x1f) * 256 +\r\nhdmi_read(sd, 0x31)) / 2;\r\nbt->vbackporch = ((hdmi_read(sd, 0x34) & 0x1f) * 256 +\r\nhdmi_read(sd, 0x35)) / 2;\r\n}\r\nadv7604_fill_optional_dv_timings_fields(sd, timings);\r\n} else {\r\nif (!stdi2dv_timings(sd, &stdi, timings))\r\ngoto found;\r\nstdi.lcvs += 1;\r\nv4l2_dbg(1, debug, sd, "%s: lcvs + 1 = %d\n", __func__, stdi.lcvs);\r\nif (!stdi2dv_timings(sd, &stdi, timings))\r\ngoto found;\r\nstdi.lcvs -= 2;\r\nv4l2_dbg(1, debug, sd, "%s: lcvs - 1 = %d\n", __func__, stdi.lcvs);\r\nif (stdi2dv_timings(sd, &stdi, timings)) {\r\nif (state->restart_stdi_once) {\r\nv4l2_dbg(1, debug, sd, "%s: restart STDI\n", __func__);\r\ncp_write_and_or(sd, 0x86, 0xf9, 0x00);\r\ncp_write_and_or(sd, 0x86, 0xf9, 0x04);\r\ncp_write_and_or(sd, 0x86, 0xf9, 0x02);\r\nstate->restart_stdi_once = false;\r\nreturn -ENOLINK;\r\n}\r\nv4l2_dbg(1, debug, sd, "%s: format not supported\n", __func__);\r\nreturn -ERANGE;\r\n}\r\nstate->restart_stdi_once = true;\r\n}\r\nfound:\r\nif (no_signal(sd)) {\r\nv4l2_dbg(1, debug, sd, "%s: signal lost during readout\n", __func__);\r\nmemset(timings, 0, sizeof(struct v4l2_dv_timings));\r\nreturn -ENOLINK;\r\n}\r\nif ((!DIGITAL_INPUT && bt->pixelclock > 170000000) ||\r\n(DIGITAL_INPUT && bt->pixelclock > 225000000)) {\r\nv4l2_dbg(1, debug, sd, "%s: pixelclock out of range %d\n",\r\n__func__, (u32)bt->pixelclock);\r\nreturn -ERANGE;\r\n}\r\nif (debug > 1)\r\nadv7604_print_timings(sd, timings,\r\n"adv7604_query_dv_timings:", true);\r\nreturn 0;\r\n}\r\nstatic int adv7604_s_dv_timings(struct v4l2_subdev *sd,\r\nstruct v4l2_dv_timings *timings)\r\n{\r\nstruct adv7604_state *state = to_state(sd);\r\nstruct v4l2_bt_timings *bt;\r\nint err;\r\nif (!timings)\r\nreturn -EINVAL;\r\nbt = &timings->bt;\r\nif ((!DIGITAL_INPUT && bt->pixelclock > 170000000) ||\r\n(DIGITAL_INPUT && bt->pixelclock > 225000000)) {\r\nv4l2_dbg(1, debug, sd, "%s: pixelclock out of range %d\n",\r\n__func__, (u32)bt->pixelclock);\r\nreturn -ERANGE;\r\n}\r\nadv7604_fill_optional_dv_timings_fields(sd, timings);\r\nstate->timings = *timings;\r\ncp_write(sd, 0x91, bt->interlaced ? 0x50 : 0x10);\r\nerr = configure_predefined_video_timings(sd, timings);\r\nif (err) {\r\nconfigure_custom_video_timings(sd, bt);\r\n}\r\nset_rgb_quantization_range(sd);\r\nif (debug > 1)\r\nadv7604_print_timings(sd, timings,\r\n"adv7604_s_dv_timings:", true);\r\nreturn 0;\r\n}\r\nstatic int adv7604_g_dv_timings(struct v4l2_subdev *sd,\r\nstruct v4l2_dv_timings *timings)\r\n{\r\nstruct adv7604_state *state = to_state(sd);\r\n*timings = state->timings;\r\nreturn 0;\r\n}\r\nstatic void enable_input(struct v4l2_subdev *sd)\r\n{\r\nstruct adv7604_state *state = to_state(sd);\r\nswitch (state->mode) {\r\ncase ADV7604_MODE_COMP:\r\ncase ADV7604_MODE_GR:\r\nio_write(sd, 0x15, 0xb0);\r\nbreak;\r\ncase ADV7604_MODE_HDMI:\r\nhdmi_write(sd, 0x1a, 0x0a);\r\nhdmi_write(sd, 0x01, 0x00);\r\nio_write(sd, 0x15, 0xa0);\r\nbreak;\r\ndefault:\r\nv4l2_dbg(2, debug, sd, "%s: Unknown mode %d\n",\r\n__func__, state->mode);\r\nbreak;\r\n}\r\n}\r\nstatic void disable_input(struct v4l2_subdev *sd)\r\n{\r\nio_write(sd, 0x15, 0xbe);\r\nhdmi_write(sd, 0x1a, 0x1a);\r\nhdmi_write(sd, 0x01, 0x78);\r\n}\r\nstatic void select_input(struct v4l2_subdev *sd)\r\n{\r\nstruct adv7604_state *state = to_state(sd);\r\nswitch (state->mode) {\r\ncase ADV7604_MODE_COMP:\r\ncase ADV7604_MODE_GR:\r\nhdmi_write(sd, 0x0d, 0x04);\r\nhdmi_write(sd, 0x3d, 0x00);\r\nhdmi_write(sd, 0x3e, 0x74);\r\nhdmi_write(sd, 0x4e, 0x3b);\r\nhdmi_write(sd, 0x57, 0x74);\r\nhdmi_write(sd, 0x58, 0x63);\r\nhdmi_write(sd, 0x8d, 0x18);\r\nhdmi_write(sd, 0x8e, 0x34);\r\nhdmi_write(sd, 0x93, 0x88);\r\nhdmi_write(sd, 0x94, 0x2e);\r\nhdmi_write(sd, 0x96, 0x00);\r\nafe_write(sd, 0x00, 0x08);\r\nafe_write(sd, 0x01, 0x06);\r\nafe_write(sd, 0xc8, 0x00);\r\nafe_write(sd, 0x12, 0x7b);\r\nafe_write(sd, 0x0c, 0x1f);\r\ncp_write(sd, 0x3e, 0x04);\r\ncp_write(sd, 0xc3, 0x39);\r\ncp_write(sd, 0x40, 0x5c);\r\nbreak;\r\ncase ADV7604_MODE_HDMI:\r\nhdmi_write(sd, 0x0d, 0x84);\r\nhdmi_write(sd, 0x3d, 0x10);\r\nhdmi_write(sd, 0x3e, 0x39);\r\nhdmi_write(sd, 0x4e, 0x3b);\r\nhdmi_write(sd, 0x57, 0xb6);\r\nhdmi_write(sd, 0x58, 0x03);\r\nhdmi_write(sd, 0x8d, 0x18);\r\nhdmi_write(sd, 0x8e, 0x34);\r\nhdmi_write(sd, 0x93, 0x8b);\r\nhdmi_write(sd, 0x94, 0x2d);\r\nhdmi_write(sd, 0x96, 0x01);\r\nafe_write(sd, 0x00, 0xff);\r\nafe_write(sd, 0x01, 0xfe);\r\nafe_write(sd, 0xc8, 0x40);\r\nafe_write(sd, 0x12, 0xfb);\r\nafe_write(sd, 0x0c, 0x0d);\r\ncp_write(sd, 0x3e, 0x00);\r\ncp_write(sd, 0xc3, 0x39);\r\ncp_write(sd, 0x40, 0x80);\r\nbreak;\r\ndefault:\r\nv4l2_dbg(2, debug, sd, "%s: Unknown mode %d\n",\r\n__func__, state->mode);\r\nbreak;\r\n}\r\n}\r\nstatic int adv7604_s_routing(struct v4l2_subdev *sd,\r\nu32 input, u32 output, u32 config)\r\n{\r\nstruct adv7604_state *state = to_state(sd);\r\nv4l2_dbg(2, debug, sd, "%s: input %d", __func__, input);\r\nstate->mode = input;\r\ndisable_input(sd);\r\nselect_input(sd);\r\nenable_input(sd);\r\nreturn 0;\r\n}\r\nstatic int adv7604_enum_mbus_fmt(struct v4l2_subdev *sd, unsigned int index,\r\nenum v4l2_mbus_pixelcode *code)\r\n{\r\nif (index)\r\nreturn -EINVAL;\r\n*code = V4L2_MBUS_FMT_FIXED;\r\nreturn 0;\r\n}\r\nstatic int adv7604_g_mbus_fmt(struct v4l2_subdev *sd,\r\nstruct v4l2_mbus_framefmt *fmt)\r\n{\r\nstruct adv7604_state *state = to_state(sd);\r\nfmt->width = state->timings.bt.width;\r\nfmt->height = state->timings.bt.height;\r\nfmt->code = V4L2_MBUS_FMT_FIXED;\r\nfmt->field = V4L2_FIELD_NONE;\r\nif (state->timings.bt.standards & V4L2_DV_BT_STD_CEA861) {\r\nfmt->colorspace = (state->timings.bt.height <= 576) ?\r\nV4L2_COLORSPACE_SMPTE170M : V4L2_COLORSPACE_REC709;\r\n}\r\nreturn 0;\r\n}\r\nstatic int adv7604_isr(struct v4l2_subdev *sd, u32 status, bool *handled)\r\n{\r\nstruct adv7604_state *state = to_state(sd);\r\nu8 fmt_change, fmt_change_digital, tx_5v;\r\nfmt_change = io_read(sd, 0x43) & 0x98;\r\nif (fmt_change)\r\nio_write(sd, 0x44, fmt_change);\r\nfmt_change_digital = DIGITAL_INPUT ? (io_read(sd, 0x6b) & 0xc0) : 0;\r\nif (fmt_change_digital)\r\nio_write(sd, 0x6c, fmt_change_digital);\r\nif (fmt_change || fmt_change_digital) {\r\nv4l2_dbg(1, debug, sd,\r\n"%s: ADV7604_FMT_CHANGE, fmt_change = 0x%x, fmt_change_digital = 0x%x\n",\r\n__func__, fmt_change, fmt_change_digital);\r\nv4l2_subdev_notify(sd, ADV7604_FMT_CHANGE, NULL);\r\nif (handled)\r\n*handled = true;\r\n}\r\ntx_5v = io_read(sd, 0x70) & 0x10;\r\nif (tx_5v) {\r\nv4l2_dbg(1, debug, sd, "%s: tx_5v: 0x%x\n", __func__, tx_5v);\r\nio_write(sd, 0x71, tx_5v);\r\nadv7604_s_detect_tx_5v_ctrl(sd);\r\nif (handled)\r\n*handled = true;\r\n}\r\nreturn 0;\r\n}\r\nstatic int adv7604_get_edid(struct v4l2_subdev *sd, struct v4l2_subdev_edid *edid)\r\n{\r\nstruct adv7604_state *state = to_state(sd);\r\nif (edid->pad != 0)\r\nreturn -EINVAL;\r\nif (edid->blocks == 0)\r\nreturn -EINVAL;\r\nif (edid->start_block >= state->edid_blocks)\r\nreturn -EINVAL;\r\nif (edid->start_block + edid->blocks > state->edid_blocks)\r\nedid->blocks = state->edid_blocks - edid->start_block;\r\nif (!edid->edid)\r\nreturn -EINVAL;\r\nmemcpy(edid->edid + edid->start_block * 128,\r\nstate->edid + edid->start_block * 128,\r\nedid->blocks * 128);\r\nreturn 0;\r\n}\r\nstatic int adv7604_set_edid(struct v4l2_subdev *sd, struct v4l2_subdev_edid *edid)\r\n{\r\nstruct adv7604_state *state = to_state(sd);\r\nint err;\r\nif (edid->pad != 0)\r\nreturn -EINVAL;\r\nif (edid->start_block != 0)\r\nreturn -EINVAL;\r\nif (edid->blocks == 0) {\r\nv4l2_subdev_notify(sd, ADV7604_HOTPLUG, (void *)0);\r\nrep_write_and_or(sd, 0x77, 0xf0, 0x0);\r\nstate->edid_blocks = 0;\r\nstate->aspect_ratio.numerator = 16;\r\nstate->aspect_ratio.denominator = 9;\r\nreturn 0;\r\n}\r\nif (edid->blocks > 2)\r\nreturn -E2BIG;\r\nif (!edid->edid)\r\nreturn -EINVAL;\r\nmemcpy(state->edid, edid->edid, 128 * edid->blocks);\r\nstate->edid_blocks = edid->blocks;\r\nstate->aspect_ratio = v4l2_calc_aspect_ratio(edid->edid[0x15],\r\nedid->edid[0x16]);\r\nerr = edid_write_block(sd, 128 * edid->blocks, state->edid);\r\nif (err < 0)\r\nv4l2_err(sd, "error %d writing edid\n", err);\r\nreturn err;\r\n}\r\nstatic void print_avi_infoframe(struct v4l2_subdev *sd)\r\n{\r\nint i;\r\nu8 buf[14];\r\nu8 avi_len;\r\nu8 avi_ver;\r\nif (!(hdmi_read(sd, 0x05) & 0x80)) {\r\nv4l2_info(sd, "receive DVI-D signal (AVI infoframe not supported)\n");\r\nreturn;\r\n}\r\nif (!(io_read(sd, 0x60) & 0x01)) {\r\nv4l2_info(sd, "AVI infoframe not received\n");\r\nreturn;\r\n}\r\nif (io_read(sd, 0x83) & 0x01) {\r\nv4l2_info(sd, "AVI infoframe checksum error has occurred earlier\n");\r\nio_write(sd, 0x85, 0x01);\r\nif (io_read(sd, 0x83) & 0x01) {\r\nv4l2_info(sd, "AVI infoframe checksum error still present\n");\r\nio_write(sd, 0x85, 0x01);\r\n}\r\n}\r\navi_len = infoframe_read(sd, 0xe2);\r\navi_ver = infoframe_read(sd, 0xe1);\r\nv4l2_info(sd, "AVI infoframe version %d (%d byte)\n",\r\navi_ver, avi_len);\r\nif (avi_ver != 0x02)\r\nreturn;\r\nfor (i = 0; i < 14; i++)\r\nbuf[i] = infoframe_read(sd, i);\r\nv4l2_info(sd,\r\n"\t%02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x\n",\r\nbuf[0], buf[1], buf[2], buf[3], buf[4], buf[5], buf[6], buf[7],\r\nbuf[8], buf[9], buf[10], buf[11], buf[12], buf[13]);\r\n}\r\nstatic int adv7604_log_status(struct v4l2_subdev *sd)\r\n{\r\nstruct adv7604_state *state = to_state(sd);\r\nstruct v4l2_dv_timings timings;\r\nstruct stdi_readback stdi;\r\nu8 reg_io_0x02 = io_read(sd, 0x02);\r\nchar *csc_coeff_sel_rb[16] = {\r\n"bypassed", "YPbPr601 -> RGB", "reserved", "YPbPr709 -> RGB",\r\n"reserved", "RGB -> YPbPr601", "reserved", "RGB -> YPbPr709",\r\n"reserved", "YPbPr709 -> YPbPr601", "YPbPr601 -> YPbPr709",\r\n"reserved", "reserved", "reserved", "reserved", "manual"\r\n};\r\nchar *input_color_space_txt[16] = {\r\n"RGB limited range (16-235)", "RGB full range (0-255)",\r\n"YCbCr Bt.601 (16-235)", "YCbCr Bt.709 (16-235)",\r\n"XvYCC Bt.601", "XvYCC Bt.709",\r\n"YCbCr Bt.601 (0-255)", "YCbCr Bt.709 (0-255)",\r\n"invalid", "invalid", "invalid", "invalid", "invalid",\r\n"invalid", "invalid", "automatic"\r\n};\r\nchar *rgb_quantization_range_txt[] = {\r\n"Automatic",\r\n"RGB limited range (16-235)",\r\n"RGB full range (0-255)",\r\n};\r\nv4l2_info(sd, "-----Chip status-----\n");\r\nv4l2_info(sd, "Chip power: %s\n", no_power(sd) ? "off" : "on");\r\nv4l2_info(sd, "Connector type: %s\n", state->connector_hdmi ?\r\n"HDMI" : (DIGITAL_INPUT ? "DVI-D" : "DVI-A"));\r\nv4l2_info(sd, "EDID: %s\n", ((rep_read(sd, 0x7d) & 0x01) &&\r\n(rep_read(sd, 0x77) & 0x01)) ? "enabled" : "disabled ");\r\nv4l2_info(sd, "CEC: %s\n", !!(cec_read(sd, 0x2a) & 0x01) ?\r\n"enabled" : "disabled");\r\nv4l2_info(sd, "-----Signal status-----\n");\r\nv4l2_info(sd, "Cable detected (+5V power): %s\n",\r\n(io_read(sd, 0x6f) & 0x10) ? "true" : "false");\r\nv4l2_info(sd, "TMDS signal detected: %s\n",\r\nno_signal_tmds(sd) ? "false" : "true");\r\nv4l2_info(sd, "TMDS signal locked: %s\n",\r\nno_lock_tmds(sd) ? "false" : "true");\r\nv4l2_info(sd, "SSPD locked: %s\n", no_lock_sspd(sd) ? "false" : "true");\r\nv4l2_info(sd, "STDI locked: %s\n", no_lock_stdi(sd) ? "false" : "true");\r\nv4l2_info(sd, "CP locked: %s\n", no_lock_cp(sd) ? "false" : "true");\r\nv4l2_info(sd, "CP free run: %s\n",\r\n(!!(cp_read(sd, 0xff) & 0x10) ? "on" : "off"));\r\nv4l2_info(sd, "Prim-mode = 0x%x, video std = 0x%x, v_freq = 0x%x\n",\r\nio_read(sd, 0x01) & 0x0f, io_read(sd, 0x00) & 0x3f,\r\n(io_read(sd, 0x01) & 0x70) >> 4);\r\nv4l2_info(sd, "-----Video Timings-----\n");\r\nif (read_stdi(sd, &stdi))\r\nv4l2_info(sd, "STDI: not locked\n");\r\nelse\r\nv4l2_info(sd, "STDI: lcf (frame height - 1) = %d, bl = %d, lcvs (vsync) = %d, %s, %chsync, %cvsync\n",\r\nstdi.lcf, stdi.bl, stdi.lcvs,\r\nstdi.interlaced ? "interlaced" : "progressive",\r\nstdi.hs_pol, stdi.vs_pol);\r\nif (adv7604_query_dv_timings(sd, &timings))\r\nv4l2_info(sd, "No video detected\n");\r\nelse\r\nadv7604_print_timings(sd, &timings, "Detected format:", true);\r\nadv7604_print_timings(sd, &state->timings, "Configured format:", true);\r\nv4l2_info(sd, "-----Color space-----\n");\r\nv4l2_info(sd, "RGB quantization range ctrl: %s\n",\r\nrgb_quantization_range_txt[state->rgb_quantization_range]);\r\nv4l2_info(sd, "Input color space: %s\n",\r\ninput_color_space_txt[reg_io_0x02 >> 4]);\r\nv4l2_info(sd, "Output color space: %s %s, saturator %s\n",\r\n(reg_io_0x02 & 0x02) ? "RGB" : "YCbCr",\r\n(reg_io_0x02 & 0x04) ? "(16-235)" : "(0-255)",\r\n((reg_io_0x02 & 0x04) ^ (reg_io_0x02 & 0x01)) ?\r\n"enabled" : "disabled");\r\nv4l2_info(sd, "Color space conversion: %s\n",\r\ncsc_coeff_sel_rb[cp_read(sd, 0xfc) >> 4]);\r\nif (DIGITAL_INPUT) {\r\nv4l2_info(sd, "-----HDMI status-----\n");\r\nv4l2_info(sd, "HDCP encrypted content: %s\n",\r\nhdmi_read(sd, 0x05) & 0x40 ? "true" : "false");\r\nprint_avi_infoframe(sd);\r\n}\r\nreturn 0;\r\n}\r\nstatic int adv7604_core_init(struct v4l2_subdev *sd)\r\n{\r\nstruct adv7604_state *state = to_state(sd);\r\nstruct adv7604_platform_data *pdata = &state->pdata;\r\nhdmi_write(sd, 0x48,\r\n(pdata->disable_pwrdnb ? 0x80 : 0) |\r\n(pdata->disable_cable_det_rst ? 0x40 : 0));\r\ndisable_input(sd);\r\nio_write(sd, 0x0c, 0x42);\r\nio_write(sd, 0x0b, 0x44);\r\ncp_write(sd, 0xcf, 0x01);\r\nio_write_and_or(sd, 0x02, 0xf0,\r\npdata->alt_gamma << 3 |\r\npdata->op_656_range << 2 |\r\npdata->rgb_out << 1 |\r\npdata->alt_data_sat << 0);\r\nio_write(sd, 0x03, pdata->op_format_sel);\r\nio_write_and_or(sd, 0x04, 0x1f, pdata->op_ch_sel << 5);\r\nio_write_and_or(sd, 0x05, 0xf0, pdata->blank_data << 3 |\r\npdata->insert_av_codes << 2 |\r\npdata->replicate_av_codes << 1 |\r\npdata->invert_cbcr << 0);\r\ncp_write(sd, 0x69, 0x30);\r\nio_write(sd, 0x06, 0xa6);\r\nio_write(sd, 0x14, 0x7f);\r\ncp_write(sd, 0xba, (pdata->hdmi_free_run_mode << 1) | 0x01);\r\ncp_write(sd, 0xf3, 0xdc);\r\ncp_write(sd, 0xf9, 0x23);\r\ncp_write(sd, 0x45, 0x23);\r\ncp_write(sd, 0xc9, 0x2d);\r\nafe_write(sd, 0xb5, 0x01);\r\nafe_write(sd, 0x02, pdata->ain_sel);\r\nio_write_and_or(sd, 0x30, ~(1 << 4), pdata->output_bus_lsb_to_msb << 4);\r\nio_write(sd, 0x40, 0xc2);\r\nio_write(sd, 0x41, 0xd7);\r\nio_write(sd, 0x46, 0x98);\r\nio_write(sd, 0x6e, 0xc0);\r\nio_write(sd, 0x73, 0x10);\r\nreturn v4l2_ctrl_handler_setup(sd->ctrl_handler);\r\n}\r\nstatic void adv7604_unregister_clients(struct adv7604_state *state)\r\n{\r\nif (state->i2c_avlink)\r\ni2c_unregister_device(state->i2c_avlink);\r\nif (state->i2c_cec)\r\ni2c_unregister_device(state->i2c_cec);\r\nif (state->i2c_infoframe)\r\ni2c_unregister_device(state->i2c_infoframe);\r\nif (state->i2c_esdp)\r\ni2c_unregister_device(state->i2c_esdp);\r\nif (state->i2c_dpp)\r\ni2c_unregister_device(state->i2c_dpp);\r\nif (state->i2c_afe)\r\ni2c_unregister_device(state->i2c_afe);\r\nif (state->i2c_repeater)\r\ni2c_unregister_device(state->i2c_repeater);\r\nif (state->i2c_edid)\r\ni2c_unregister_device(state->i2c_edid);\r\nif (state->i2c_hdmi)\r\ni2c_unregister_device(state->i2c_hdmi);\r\nif (state->i2c_test)\r\ni2c_unregister_device(state->i2c_test);\r\nif (state->i2c_cp)\r\ni2c_unregister_device(state->i2c_cp);\r\nif (state->i2c_vdp)\r\ni2c_unregister_device(state->i2c_vdp);\r\n}\r\nstatic struct i2c_client *adv7604_dummy_client(struct v4l2_subdev *sd,\r\nu8 addr, u8 io_reg)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nif (addr)\r\nio_write(sd, io_reg, addr << 1);\r\nreturn i2c_new_dummy(client->adapter, io_read(sd, io_reg) >> 1);\r\n}\r\nstatic int adv7604_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct adv7604_state *state;\r\nstruct adv7604_platform_data *pdata = client->dev.platform_data;\r\nstruct v4l2_ctrl_handler *hdl;\r\nstruct v4l2_subdev *sd;\r\nint err;\r\nif (!i2c_check_functionality(client->adapter, I2C_FUNC_SMBUS_BYTE_DATA))\r\nreturn -EIO;\r\nv4l_dbg(1, debug, client, "detecting adv7604 client on address 0x%x\n",\r\nclient->addr << 1);\r\nstate = kzalloc(sizeof(struct adv7604_state), GFP_KERNEL);\r\nif (!state) {\r\nv4l_err(client, "Could not allocate adv7604_state memory!\n");\r\nreturn -ENOMEM;\r\n}\r\nif (!pdata) {\r\nv4l_err(client, "No platform data!\n");\r\nerr = -ENODEV;\r\ngoto err_state;\r\n}\r\nmemcpy(&state->pdata, pdata, sizeof(state->pdata));\r\nsd = &state->sd;\r\nv4l2_i2c_subdev_init(sd, client, &adv7604_ops);\r\nsd->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;\r\nstate->connector_hdmi = pdata->connector_hdmi;\r\nif (adv_smbus_read_byte_data_check(client, 0xfb, false) != 0x68) {\r\nv4l2_info(sd, "not an adv7604 on address 0x%x\n",\r\nclient->addr << 1);\r\nerr = -ENODEV;\r\ngoto err_state;\r\n}\r\nhdl = &state->hdl;\r\nv4l2_ctrl_handler_init(hdl, 9);\r\nv4l2_ctrl_new_std(hdl, &adv7604_ctrl_ops,\r\nV4L2_CID_BRIGHTNESS, -128, 127, 1, 0);\r\nv4l2_ctrl_new_std(hdl, &adv7604_ctrl_ops,\r\nV4L2_CID_CONTRAST, 0, 255, 1, 128);\r\nv4l2_ctrl_new_std(hdl, &adv7604_ctrl_ops,\r\nV4L2_CID_SATURATION, 0, 255, 1, 128);\r\nv4l2_ctrl_new_std(hdl, &adv7604_ctrl_ops,\r\nV4L2_CID_HUE, 0, 128, 1, 0);\r\nstate->detect_tx_5v_ctrl = v4l2_ctrl_new_std(hdl, NULL,\r\nV4L2_CID_DV_RX_POWER_PRESENT, 0, 1, 0, 0);\r\nstate->detect_tx_5v_ctrl->is_private = true;\r\nstate->rgb_quantization_range_ctrl =\r\nv4l2_ctrl_new_std_menu(hdl, &adv7604_ctrl_ops,\r\nV4L2_CID_DV_RX_RGB_RANGE, V4L2_DV_RGB_RANGE_FULL,\r\n0, V4L2_DV_RGB_RANGE_AUTO);\r\nstate->rgb_quantization_range_ctrl->is_private = true;\r\nstate->analog_sampling_phase_ctrl =\r\nv4l2_ctrl_new_custom(hdl, &adv7604_ctrl_analog_sampling_phase, NULL);\r\nstate->analog_sampling_phase_ctrl->is_private = true;\r\nstate->free_run_color_manual_ctrl =\r\nv4l2_ctrl_new_custom(hdl, &adv7604_ctrl_free_run_color_manual, NULL);\r\nstate->free_run_color_manual_ctrl->is_private = true;\r\nstate->free_run_color_ctrl =\r\nv4l2_ctrl_new_custom(hdl, &adv7604_ctrl_free_run_color, NULL);\r\nstate->free_run_color_ctrl->is_private = true;\r\nsd->ctrl_handler = hdl;\r\nif (hdl->error) {\r\nerr = hdl->error;\r\ngoto err_hdl;\r\n}\r\nif (adv7604_s_detect_tx_5v_ctrl(sd)) {\r\nerr = -ENODEV;\r\ngoto err_hdl;\r\n}\r\nstate->i2c_avlink = adv7604_dummy_client(sd, pdata->i2c_avlink, 0xf3);\r\nstate->i2c_cec = adv7604_dummy_client(sd, pdata->i2c_cec, 0xf4);\r\nstate->i2c_infoframe = adv7604_dummy_client(sd, pdata->i2c_infoframe, 0xf5);\r\nstate->i2c_esdp = adv7604_dummy_client(sd, pdata->i2c_esdp, 0xf6);\r\nstate->i2c_dpp = adv7604_dummy_client(sd, pdata->i2c_dpp, 0xf7);\r\nstate->i2c_afe = adv7604_dummy_client(sd, pdata->i2c_afe, 0xf8);\r\nstate->i2c_repeater = adv7604_dummy_client(sd, pdata->i2c_repeater, 0xf9);\r\nstate->i2c_edid = adv7604_dummy_client(sd, pdata->i2c_edid, 0xfa);\r\nstate->i2c_hdmi = adv7604_dummy_client(sd, pdata->i2c_hdmi, 0xfb);\r\nstate->i2c_test = adv7604_dummy_client(sd, pdata->i2c_test, 0xfc);\r\nstate->i2c_cp = adv7604_dummy_client(sd, pdata->i2c_cp, 0xfd);\r\nstate->i2c_vdp = adv7604_dummy_client(sd, pdata->i2c_vdp, 0xfe);\r\nif (!state->i2c_avlink || !state->i2c_cec || !state->i2c_infoframe ||\r\n!state->i2c_esdp || !state->i2c_dpp || !state->i2c_afe ||\r\n!state->i2c_repeater || !state->i2c_edid || !state->i2c_hdmi ||\r\n!state->i2c_test || !state->i2c_cp || !state->i2c_vdp) {\r\nerr = -ENOMEM;\r\nv4l2_err(sd, "failed to create all i2c clients\n");\r\ngoto err_i2c;\r\n}\r\nstate->restart_stdi_once = true;\r\nstate->work_queues = create_singlethread_workqueue(client->name);\r\nif (!state->work_queues) {\r\nv4l2_err(sd, "Could not create work queue\n");\r\nerr = -ENOMEM;\r\ngoto err_i2c;\r\n}\r\nINIT_DELAYED_WORK(&state->delayed_work_enable_hotplug,\r\nadv7604_delayed_work_enable_hotplug);\r\nstate->pad.flags = MEDIA_PAD_FL_SOURCE;\r\nerr = media_entity_init(&sd->entity, 1, &state->pad, 0);\r\nif (err)\r\ngoto err_work_queues;\r\nerr = adv7604_core_init(sd);\r\nif (err)\r\ngoto err_entity;\r\nv4l2_info(sd, "%s found @ 0x%x (%s)\n", client->name,\r\nclient->addr << 1, client->adapter->name);\r\nreturn 0;\r\nerr_entity:\r\nmedia_entity_cleanup(&sd->entity);\r\nerr_work_queues:\r\ncancel_delayed_work(&state->delayed_work_enable_hotplug);\r\ndestroy_workqueue(state->work_queues);\r\nerr_i2c:\r\nadv7604_unregister_clients(state);\r\nerr_hdl:\r\nv4l2_ctrl_handler_free(hdl);\r\nerr_state:\r\nkfree(state);\r\nreturn err;\r\n}\r\nstatic int adv7604_remove(struct i2c_client *client)\r\n{\r\nstruct v4l2_subdev *sd = i2c_get_clientdata(client);\r\nstruct adv7604_state *state = to_state(sd);\r\ncancel_delayed_work(&state->delayed_work_enable_hotplug);\r\ndestroy_workqueue(state->work_queues);\r\nv4l2_device_unregister_subdev(sd);\r\nmedia_entity_cleanup(&sd->entity);\r\nadv7604_unregister_clients(to_state(sd));\r\nv4l2_ctrl_handler_free(sd->ctrl_handler);\r\nkfree(to_state(sd));\r\nreturn 0;\r\n}
