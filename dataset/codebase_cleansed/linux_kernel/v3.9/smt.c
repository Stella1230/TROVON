static inline int is_my_addr(const struct s_smc *smc,\r\nconst struct fddi_addr *addr)\r\n{\r\nreturn(*(short *)(&addr->a[0]) ==\r\n*(short *)(&smc->mib.m[MAC0].fddiMACSMTAddress.a[0])\r\n&& *(short *)(&addr->a[2]) ==\r\n*(short *)(&smc->mib.m[MAC0].fddiMACSMTAddress.a[2])\r\n&& *(short *)(&addr->a[4]) ==\r\n*(short *)(&smc->mib.m[MAC0].fddiMACSMTAddress.a[4])) ;\r\n}\r\nstatic inline int is_broadcast(const struct fddi_addr *addr)\r\n{\r\nreturn *(u_short *)(&addr->a[0]) == 0xffff &&\r\n*(u_short *)(&addr->a[2]) == 0xffff &&\r\n*(u_short *)(&addr->a[4]) == 0xffff;\r\n}\r\nstatic inline int is_individual(const struct fddi_addr *addr)\r\n{\r\nreturn !(addr->a[0] & GROUP_ADDR);\r\n}\r\nstatic inline int is_equal(const struct fddi_addr *addr1,\r\nconst struct fddi_addr *addr2)\r\n{\r\nreturn *(u_short *)(&addr1->a[0]) == *(u_short *)(&addr2->a[0]) &&\r\n*(u_short *)(&addr1->a[2]) == *(u_short *)(&addr2->a[2]) &&\r\n*(u_short *)(&addr1->a[4]) == *(u_short *)(&addr2->a[4]);\r\n}\r\nvoid smt_agent_init(struct s_smc *smc)\r\n{\r\nint i ;\r\nsmc->mib.m[MAC0].fddiMACSMTAddress = smc->hw.fddi_home_addr ;\r\nsmc->mib.fddiSMTStationId.sid_oem[0] = 0 ;\r\nsmc->mib.fddiSMTStationId.sid_oem[1] = 0 ;\r\ndriver_get_bia(smc,&smc->mib.fddiSMTStationId.sid_node) ;\r\nfor (i = 0 ; i < 6 ; i ++) {\r\nsmc->mib.fddiSMTStationId.sid_node.a[i] =\r\nbitrev8(smc->mib.fddiSMTStationId.sid_node.a[i]);\r\n}\r\nsmc->mib.fddiSMTManufacturerData[0] =\r\nsmc->mib.fddiSMTStationId.sid_node.a[0] ;\r\nsmc->mib.fddiSMTManufacturerData[1] =\r\nsmc->mib.fddiSMTStationId.sid_node.a[1] ;\r\nsmc->mib.fddiSMTManufacturerData[2] =\r\nsmc->mib.fddiSMTStationId.sid_node.a[2] ;\r\nsmc->sm.smt_tid = 0 ;\r\nsmc->mib.m[MAC0].fddiMACDupAddressTest = DA_NONE ;\r\nsmc->mib.m[MAC0].fddiMACUNDA_Flag = FALSE ;\r\n#ifndef SLIM_SMT\r\nsmt_clear_una_dna(smc) ;\r\nsmt_clear_old_una_dna(smc) ;\r\n#endif\r\nfor (i = 0 ; i < SMT_MAX_TEST ; i++)\r\nsmc->sm.pend[i] = 0 ;\r\nsmc->sm.please_reconnect = 0 ;\r\nsmc->sm.uniq_ticks = 0 ;\r\n}\r\nvoid smt_agent_task(struct s_smc *smc)\r\n{\r\nsmt_timer_start(smc,&smc->sm.smt_timer, (u_long)1000000L,\r\nEV_TOKEN(EVENT_SMT,SM_TIMER)) ;\r\nDB_SMT("SMT agent task\n",0,0) ;\r\n}\r\nvoid smt_emulate_token_ct(struct s_smc *smc, int mac_index)\r\n{\r\nu_long count;\r\nu_long time;\r\ntime = smt_get_time();\r\ncount = ((time - smc->sm.last_tok_time[mac_index]) *\r\n100)/TICKS_PER_SECOND;\r\nif (smc->hw.mac_ring_is_up){\r\nsmc->mib.m[mac_index].fddiMACToken_Ct += count;\r\n}\r\nsmc->sm.last_tok_time[mac_index] = time;\r\n}\r\nvoid smt_event(struct s_smc *smc, int event)\r\n{\r\nu_long time ;\r\n#ifndef SMT_REAL_TOKEN_CT\r\nint i ;\r\n#endif\r\nif (smc->sm.please_reconnect) {\r\nsmc->sm.please_reconnect -- ;\r\nif (smc->sm.please_reconnect == 0) {\r\nqueue_event(smc,EVENT_ECM,EC_CONNECT) ;\r\n}\r\n}\r\nif (event == SM_FAST)\r\nreturn ;\r\nsmt_timer_poll(smc) ;\r\nsmt_start_watchdog(smc) ;\r\n#ifndef SLIM_SMT\r\n#ifndef BOOT\r\n#ifdef ESS\r\ness_timer_poll(smc) ;\r\n#endif\r\n#endif\r\n#ifdef SBA\r\nsba_timer_poll(smc) ;\r\n#endif\r\nsmt_srf_event(smc,0,0,0) ;\r\n#endif\r\ntime = smt_get_time() ;\r\nif (time - smc->sm.smt_last_lem >= TICKS_PER_SECOND*8) {\r\nstruct fddi_mib_m *mib ;\r\nu_long upper ;\r\nu_long lower ;\r\nint cond ;\r\nint port;\r\nstruct s_phy *phy ;\r\nsm_lem_evaluate(smc) ;\r\nsmc->sm.smt_last_lem = time ;\r\n#ifndef SLIM_SMT\r\nmac_update_counter(smc) ;\r\nmib = smc->mib.m ;\r\nupper =\r\n(mib->fddiMACLost_Ct - mib->fddiMACOld_Lost_Ct) +\r\n(mib->fddiMACError_Ct - mib->fddiMACOld_Error_Ct) ;\r\nlower =\r\n(mib->fddiMACFrame_Ct - mib->fddiMACOld_Frame_Ct) +\r\n(mib->fddiMACLost_Ct - mib->fddiMACOld_Lost_Ct) ;\r\nmib->fddiMACFrameErrorRatio = div_ratio(upper,lower) ;\r\ncond =\r\n((!mib->fddiMACFrameErrorThreshold &&\r\nmib->fddiMACError_Ct != mib->fddiMACOld_Error_Ct) ||\r\n(mib->fddiMACFrameErrorRatio >\r\nmib->fddiMACFrameErrorThreshold)) ;\r\nif (cond != mib->fddiMACFrameErrorFlag)\r\nsmt_srf_event(smc,SMT_COND_MAC_FRAME_ERROR,\r\nINDEX_MAC,cond) ;\r\nupper =\r\n(mib->fddiMACNotCopied_Ct - mib->fddiMACOld_NotCopied_Ct) ;\r\nlower =\r\nupper +\r\n(mib->fddiMACCopied_Ct - mib->fddiMACOld_Copied_Ct) ;\r\nmib->fddiMACNotCopiedRatio = div_ratio(upper,lower) ;\r\ncond =\r\n((!mib->fddiMACNotCopiedThreshold &&\r\nmib->fddiMACNotCopied_Ct !=\r\nmib->fddiMACOld_NotCopied_Ct)||\r\n(mib->fddiMACNotCopiedRatio >\r\nmib->fddiMACNotCopiedThreshold)) ;\r\nif (cond != mib->fddiMACNotCopiedFlag)\r\nsmt_srf_event(smc,SMT_COND_MAC_NOT_COPIED,\r\nINDEX_MAC,cond) ;\r\nmib->fddiMACOld_Frame_Ct = mib->fddiMACFrame_Ct ;\r\nmib->fddiMACOld_Copied_Ct = mib->fddiMACCopied_Ct ;\r\nmib->fddiMACOld_Error_Ct = mib->fddiMACError_Ct ;\r\nmib->fddiMACOld_Lost_Ct = mib->fddiMACLost_Ct ;\r\nmib->fddiMACOld_NotCopied_Ct = mib->fddiMACNotCopied_Ct ;\r\nfor (port = 0; port < NUMPHYS; port ++) {\r\nphy = &smc->y[port] ;\r\nif (!phy->mib->fddiPORTHardwarePresent) {\r\ncontinue;\r\n}\r\ncond = (phy->mib->fddiPORTEBError_Ct -\r\nphy->mib->fddiPORTOldEBError_Ct > 5) ;\r\nsmt_srf_event(smc,SMT_COND_PORT_EB_ERROR,\r\n(int) (INDEX_PORT+ phy->np) ,cond) ;\r\nphy->mib->fddiPORTOldEBError_Ct =\r\nphy->mib->fddiPORTEBError_Ct ;\r\n}\r\n#endif\r\n}\r\n#ifndef SLIM_SMT\r\nif (time - smc->sm.smt_last_notify >= (u_long)\r\n(smc->mib.fddiSMTTT_Notify * TICKS_PER_SECOND) ) {\r\nif (!smc->sm.pend[SMT_TID_NIF])\r\nsmc->sm.pend[SMT_TID_NIF] = smt_get_tid(smc) ;\r\nsmt_send_nif(smc,&fddi_broadcast, FC_SMT_NSA,\r\nsmc->sm.pend[SMT_TID_NIF], SMT_REQUEST,0) ;\r\nsmc->sm.smt_last_notify = time ;\r\n}\r\nif (smc->sm.smt_tvu &&\r\ntime - smc->sm.smt_tvu > 228*TICKS_PER_SECOND) {\r\nDB_SMT("SMT : UNA expired\n",0,0) ;\r\nsmc->sm.smt_tvu = 0 ;\r\nif (!is_equal(&smc->mib.m[MAC0].fddiMACUpstreamNbr,\r\n&SMT_Unknown)){\r\nsmc->mib.m[MAC0].fddiMACOldUpstreamNbr=\r\nsmc->mib.m[MAC0].fddiMACUpstreamNbr ;\r\n}\r\nsmc->mib.m[MAC0].fddiMACUpstreamNbr = SMT_Unknown ;\r\nsmc->mib.m[MAC0].fddiMACUNDA_Flag = FALSE ;\r\nupdate_dac(smc,0) ;\r\nsmt_srf_event(smc, SMT_EVENT_MAC_NEIGHBOR_CHANGE,\r\nINDEX_MAC,0) ;\r\n}\r\nif (smc->sm.smt_tvd &&\r\ntime - smc->sm.smt_tvd > 228*TICKS_PER_SECOND) {\r\nDB_SMT("SMT : DNA expired\n",0,0) ;\r\nsmc->sm.smt_tvd = 0 ;\r\nif (!is_equal(&smc->mib.m[MAC0].fddiMACDownstreamNbr,\r\n&SMT_Unknown)){\r\nsmc->mib.m[MAC0].fddiMACOldDownstreamNbr=\r\nsmc->mib.m[MAC0].fddiMACDownstreamNbr ;\r\n}\r\nsmc->mib.m[MAC0].fddiMACDownstreamNbr = SMT_Unknown ;\r\nsmt_srf_event(smc, SMT_EVENT_MAC_NEIGHBOR_CHANGE,\r\nINDEX_MAC,0) ;\r\n}\r\n#endif\r\n#ifndef SMT_REAL_TOKEN_CT\r\nfor (i = MAC0; i < NUMMACS; i++ ){\r\nif (time - smc->sm.last_tok_time[i] > 2*TICKS_PER_SECOND ){\r\nsmt_emulate_token_ct( smc, i );\r\n}\r\n}\r\n#endif\r\nsmt_timer_start(smc,&smc->sm.smt_timer, (u_long)1000000L,\r\nEV_TOKEN(EVENT_SMT,SM_TIMER)) ;\r\n}\r\nstatic int div_ratio(u_long upper, u_long lower)\r\n{\r\nif ((upper<<16L) < upper)\r\nupper = 0xffff0000L ;\r\nelse\r\nupper <<= 16L ;\r\nif (!lower)\r\nreturn 0;\r\nreturn (int)(upper/lower) ;\r\n}\r\nvoid smt_received_pack(struct s_smc *smc, SMbuf *mb, int fs)\r\n{\r\nstruct smt_header *sm ;\r\nint local ;\r\nint illegal = 0 ;\r\nswitch (m_fc(mb)) {\r\ncase FC_SMT_INFO :\r\ncase FC_SMT_LAN_LOC :\r\ncase FC_SMT_LOC :\r\ncase FC_SMT_NSA :\r\nbreak ;\r\ndefault :\r\nsmt_free_mbuf(smc,mb) ;\r\nreturn ;\r\n}\r\nsmc->mib.m[MAC0].fddiMACSMTCopied_Ct++ ;\r\nsm = smtod(mb,struct smt_header *) ;\r\nlocal = ((fs & L_INDICATOR) != 0) ;\r\nhwm_conv_can(smc,(char *)sm,12) ;\r\nif (is_individual(&sm->smt_dest) && !is_my_addr(smc,&sm->smt_dest)) {\r\nsmt_free_mbuf(smc,mb) ;\r\nreturn ;\r\n}\r\n#if 0\r\nif (is_my_addr(smc,&sm->smt_source) && !local) {\r\nsmt_free_mbuf(smc,mb) ;\r\nreturn ;\r\n}\r\n#endif\r\nsmt_swap_para(sm,(int) mb->sm_len,1) ;\r\nDB_SMT("SMT : received packet [%s] at 0x%x\n",\r\nsmt_type_name[m_fc(mb) & 0xf],sm) ;\r\nDB_SMT("SMT : version %d, class %s\n",sm->smt_version,\r\nsmt_class_name[(sm->smt_class>LAST_CLASS)?0 : sm->smt_class]) ;\r\n#ifdef SBA\r\nif (m_fc(mb) == FC_SMT_NSA && sm->smt_class == SMT_NIF &&\r\n(sm->smt_type == SMT_ANNOUNCE || sm->smt_type == SMT_REQUEST)) {\r\nsmc->sba.sm = sm ;\r\nsba(smc,NIF) ;\r\n}\r\n#endif\r\nif ( (fs & A_INDICATOR) && m_fc(mb) == FC_SMT_NSA) {\r\nDB_SMT("SMT : ignoring NSA with A-indicator set from %s\n",\r\naddr_to_string(&sm->smt_source),0) ;\r\nsmt_free_mbuf(smc,mb) ;\r\nreturn ;\r\n}\r\nif (((sm->smt_class == SMT_ECF) && (sm->smt_len > SMT_MAX_ECHO_LEN)) ||\r\n((sm->smt_class != SMT_ECF) && (sm->smt_len > SMT_MAX_INFO_LEN))) {\r\nsmt_free_mbuf(smc,mb) ;\r\nreturn ;\r\n}\r\nswitch (sm->smt_class) {\r\ncase SMT_NIF :\r\ncase SMT_SIF_CONFIG :\r\ncase SMT_SIF_OPER :\r\ncase SMT_ECF :\r\nif (sm->smt_version != SMT_VID)\r\nillegal = 1;\r\nbreak ;\r\ndefault :\r\nif (sm->smt_version != SMT_VID_2)\r\nillegal = 1;\r\nbreak ;\r\n}\r\nif (illegal) {\r\nDB_SMT("SMT : version = %d, dest = %s\n",\r\nsm->smt_version,addr_to_string(&sm->smt_source)) ;\r\nsmt_send_rdf(smc,mb,m_fc(mb),SMT_RDF_VERSION,local) ;\r\nsmt_free_mbuf(smc,mb) ;\r\nreturn ;\r\n}\r\nif ((sm->smt_len > mb->sm_len - sizeof(struct smt_header)) ||\r\n((sm->smt_len & 3) && (sm->smt_class != SMT_ECF))) {\r\nDB_SMT("SMT: info length error, len = %d\n",sm->smt_len,0) ;\r\nsmt_send_rdf(smc,mb,m_fc(mb),SMT_RDF_LENGTH,local) ;\r\nsmt_free_mbuf(smc,mb) ;\r\nreturn ;\r\n}\r\nswitch (sm->smt_class) {\r\ncase SMT_NIF :\r\nif (smt_check_para(smc,sm,plist_nif)) {\r\nDB_SMT("SMT: NIF with para problem, ignoring\n",0,0) ;\r\nbreak ;\r\n}\r\nswitch (sm->smt_type) {\r\ncase SMT_ANNOUNCE :\r\ncase SMT_REQUEST :\r\nif (!(fs & C_INDICATOR) && m_fc(mb) == FC_SMT_NSA\r\n&& is_broadcast(&sm->smt_dest)) {\r\nstruct smt_p_state *st ;\r\nif (!is_equal(\r\n&smc->mib.m[MAC0].fddiMACUpstreamNbr,\r\n&sm->smt_source)) {\r\nDB_SMT("SMT : updated my UNA = %s\n",\r\naddr_to_string(&sm->smt_source),0) ;\r\nif (!is_equal(&smc->mib.m[MAC0].\r\nfddiMACUpstreamNbr,&SMT_Unknown)){\r\nsmc->mib.m[MAC0].fddiMACOldUpstreamNbr=\r\nsmc->mib.m[MAC0].fddiMACUpstreamNbr ;\r\n}\r\nsmc->mib.m[MAC0].fddiMACUpstreamNbr =\r\nsm->smt_source ;\r\nsmt_srf_event(smc,\r\nSMT_EVENT_MAC_NEIGHBOR_CHANGE,\r\nINDEX_MAC,0) ;\r\nsmt_echo_test(smc,0) ;\r\n}\r\nsmc->sm.smt_tvu = smt_get_time() ;\r\nst = (struct smt_p_state *)\r\nsm_to_para(smc,sm,SMT_P_STATE) ;\r\nif (st) {\r\nsmc->mib.m[MAC0].fddiMACUNDA_Flag =\r\n(st->st_dupl_addr & SMT_ST_MY_DUPA) ?\r\nTRUE : FALSE ;\r\nupdate_dac(smc,1) ;\r\n}\r\n}\r\nif ((sm->smt_type == SMT_REQUEST) &&\r\nis_individual(&sm->smt_source) &&\r\n((!(fs & A_INDICATOR) && m_fc(mb) == FC_SMT_NSA) ||\r\n(m_fc(mb) != FC_SMT_NSA))) {\r\nDB_SMT("SMT : replying to NIF request %s\n",\r\naddr_to_string(&sm->smt_source),0) ;\r\nsmt_send_nif(smc,&sm->smt_source,\r\nFC_SMT_INFO,\r\nsm->smt_tid,\r\nSMT_REPLY,local) ;\r\n}\r\nbreak ;\r\ncase SMT_REPLY :\r\nDB_SMT("SMT : received NIF response from %s\n",\r\naddr_to_string(&sm->smt_source),0) ;\r\nif (fs & A_INDICATOR) {\r\nsmc->sm.pend[SMT_TID_NIF] = 0 ;\r\nDB_SMT("SMT : duplicate address\n",0,0) ;\r\nsmc->mib.m[MAC0].fddiMACDupAddressTest =\r\nDA_FAILED ;\r\nsmc->r.dup_addr_test = DA_FAILED ;\r\nqueue_event(smc,EVENT_RMT,RM_DUP_ADDR) ;\r\nsmc->mib.m[MAC0].fddiMACDA_Flag = TRUE ;\r\nupdate_dac(smc,1) ;\r\nbreak ;\r\n}\r\nif (sm->smt_tid == smc->sm.pend[SMT_TID_NIF]) {\r\nsmc->sm.pend[SMT_TID_NIF] = 0 ;\r\nif (!is_equal(\r\n&smc->mib.m[MAC0].fddiMACDownstreamNbr,\r\n&sm->smt_source)) {\r\nDB_SMT("SMT : updated my DNA\n",0,0) ;\r\nif (!is_equal(&smc->mib.m[MAC0].\r\nfddiMACDownstreamNbr, &SMT_Unknown)){\r\nsmc->mib.m[MAC0].fddiMACOldDownstreamNbr =\r\nsmc->mib.m[MAC0].fddiMACDownstreamNbr ;\r\n}\r\nsmc->mib.m[MAC0].fddiMACDownstreamNbr =\r\nsm->smt_source ;\r\nsmt_srf_event(smc,\r\nSMT_EVENT_MAC_NEIGHBOR_CHANGE,\r\nINDEX_MAC,0) ;\r\nsmt_echo_test(smc,1) ;\r\n}\r\nsmc->mib.m[MAC0].fddiMACDA_Flag = FALSE ;\r\nupdate_dac(smc,1) ;\r\nsmc->sm.smt_tvd = smt_get_time() ;\r\nsmc->mib.m[MAC0].fddiMACDupAddressTest =\r\nDA_PASSED ;\r\nif (smc->r.dup_addr_test != DA_PASSED) {\r\nsmc->r.dup_addr_test = DA_PASSED ;\r\nqueue_event(smc,EVENT_RMT,RM_DUP_ADDR) ;\r\n}\r\n}\r\nelse if (sm->smt_tid ==\r\nsmc->sm.pend[SMT_TID_NIF_TEST]) {\r\nDB_SMT("SMT : NIF test TID ok\n",0,0) ;\r\n}\r\nelse {\r\nDB_SMT("SMT : expected TID %lx, got %lx\n",\r\nsmc->sm.pend[SMT_TID_NIF],sm->smt_tid) ;\r\n}\r\nbreak ;\r\ndefault :\r\nillegal = 2 ;\r\nbreak ;\r\n}\r\nbreak ;\r\ncase SMT_SIF_CONFIG :\r\nif (sm->smt_type != SMT_REQUEST)\r\nbreak ;\r\nDB_SMT("SMT : replying to SIF Config request from %s\n",\r\naddr_to_string(&sm->smt_source),0) ;\r\nsmt_send_sif_config(smc,&sm->smt_source,sm->smt_tid,local) ;\r\nbreak ;\r\ncase SMT_SIF_OPER :\r\nif (sm->smt_type != SMT_REQUEST)\r\nbreak ;\r\nDB_SMT("SMT : replying to SIF Operation request from %s\n",\r\naddr_to_string(&sm->smt_source),0) ;\r\nsmt_send_sif_operation(smc,&sm->smt_source,sm->smt_tid,local) ;\r\nbreak ;\r\ncase SMT_ECF :\r\nswitch (sm->smt_type) {\r\ncase SMT_REPLY :\r\nsmc->mib.priv.fddiPRIVECF_Reply_Rx++ ;\r\nDB_SMT("SMT: received ECF reply from %s\n",\r\naddr_to_string(&sm->smt_source),0) ;\r\nif (sm_to_para(smc,sm,SMT_P_ECHODATA) == NULL) {\r\nDB_SMT("SMT: ECHODATA missing\n",0,0) ;\r\nbreak ;\r\n}\r\nif (sm->smt_tid == smc->sm.pend[SMT_TID_ECF]) {\r\nDB_SMT("SMT : ECF test TID ok\n",0,0) ;\r\n}\r\nelse if (sm->smt_tid == smc->sm.pend[SMT_TID_ECF_UNA]) {\r\nDB_SMT("SMT : ECF test UNA ok\n",0,0) ;\r\n}\r\nelse if (sm->smt_tid == smc->sm.pend[SMT_TID_ECF_DNA]) {\r\nDB_SMT("SMT : ECF test DNA ok\n",0,0) ;\r\n}\r\nelse {\r\nDB_SMT("SMT : expected TID %lx, got %lx\n",\r\nsmc->sm.pend[SMT_TID_ECF],\r\nsm->smt_tid) ;\r\n}\r\nbreak ;\r\ncase SMT_REQUEST :\r\nsmc->mib.priv.fddiPRIVECF_Req_Rx++ ;\r\n{\r\nif (sm->smt_len && !sm_to_para(smc,sm,SMT_P_ECHODATA)) {\r\nDB_SMT("SMT: ECF with para problem,sending RDF\n",0,0) ;\r\nsmt_send_rdf(smc,mb,m_fc(mb),SMT_RDF_LENGTH,\r\nlocal) ;\r\nbreak ;\r\n}\r\nDB_SMT("SMT - sending ECF reply to %s\n",\r\naddr_to_string(&sm->smt_source),0) ;\r\nsm->smt_dest = sm->smt_source ;\r\nsm->smt_type = SMT_REPLY ;\r\ndump_smt(smc,sm,"ECF REPLY") ;\r\nsmc->mib.priv.fddiPRIVECF_Reply_Tx++ ;\r\nsmt_send_frame(smc,mb,FC_SMT_INFO,local) ;\r\nreturn ;\r\n}\r\ndefault :\r\nillegal = 1 ;\r\nbreak ;\r\n}\r\nbreak ;\r\n#ifndef BOOT\r\ncase SMT_RAF :\r\n#ifdef ESS\r\nDB_ESSN(2,"ESS: RAF frame received\n",0,0) ;\r\nfs = ess_raf_received_pack(smc,mb,sm,fs) ;\r\n#endif\r\n#ifdef SBA\r\nDB_SBAN(2,"SBA: RAF frame received\n",0,0) ;\r\nsba_raf_received_pack(smc,sm,fs) ;\r\n#endif\r\nbreak ;\r\ncase SMT_RDF :\r\nsmc->mib.priv.fddiPRIVRDF_Rx++ ;\r\nbreak ;\r\ncase SMT_ESF :\r\nif (sm->smt_type == SMT_REQUEST) {\r\nDB_SMT("SMT - received ESF, sending RDF\n",0,0) ;\r\nsmt_send_rdf(smc,mb,m_fc(mb),SMT_RDF_CLASS,local) ;\r\n}\r\nbreak ;\r\ncase SMT_PMF_GET :\r\ncase SMT_PMF_SET :\r\nif (sm->smt_type != SMT_REQUEST)\r\nbreak ;\r\nif (sm->smt_class == SMT_PMF_GET)\r\nsmc->mib.priv.fddiPRIVPMF_Get_Rx++ ;\r\nelse\r\nsmc->mib.priv.fddiPRIVPMF_Set_Rx++ ;\r\nif ((sm->smt_class == SMT_PMF_SET) &&\r\n!is_individual(&sm->smt_dest)) {\r\nDB_SMT("SMT: ignoring PMF-SET with I/G set\n",0,0) ;\r\nbreak ;\r\n}\r\nsmt_pmf_received_pack(smc,mb, local) ;\r\nbreak ;\r\ncase SMT_SRF :\r\ndump_smt(smc,sm,"SRF received") ;\r\nbreak ;\r\ndefault :\r\nif (sm->smt_type != SMT_REQUEST)\r\nbreak ;\r\nDB_SMT("SMT : class = %d, send RDF to %s\n",\r\nsm->smt_class, addr_to_string(&sm->smt_source)) ;\r\nsmt_send_rdf(smc,mb,m_fc(mb),SMT_RDF_CLASS,local) ;\r\nbreak ;\r\n#endif\r\n}\r\nif (illegal) {\r\nDB_SMT("SMT: discarding invalid frame, reason = %d\n",\r\nillegal,0) ;\r\n}\r\nsmt_free_mbuf(smc,mb) ;\r\n}\r\nstatic void update_dac(struct s_smc *smc, int report)\r\n{\r\nint cond ;\r\ncond = ( smc->mib.m[MAC0].fddiMACUNDA_Flag |\r\nsmc->mib.m[MAC0].fddiMACDA_Flag) != 0 ;\r\nif (report && (cond != smc->mib.m[MAC0].fddiMACDuplicateAddressCond))\r\nsmt_srf_event(smc, SMT_COND_MAC_DUP_ADDR,INDEX_MAC,cond) ;\r\nelse\r\nsmc->mib.m[MAC0].fddiMACDuplicateAddressCond = cond ;\r\n}\r\nvoid smt_send_frame(struct s_smc *smc, SMbuf *mb, int fc, int local)\r\n{\r\nstruct smt_header *sm ;\r\nif (!smc->r.sm_ma_avail && !local) {\r\nsmt_free_mbuf(smc,mb) ;\r\nreturn ;\r\n}\r\nsm = smtod(mb,struct smt_header *) ;\r\nsm->smt_source = smc->mib.m[MAC0].fddiMACSMTAddress ;\r\nsm->smt_sid = smc->mib.fddiSMTStationId ;\r\nsmt_swap_para(sm,(int) mb->sm_len,0) ;\r\nhwm_conv_can(smc,(char *)sm,12) ;\r\nsmc->mib.m[MAC0].fddiMACSMTTransmit_Ct++ ;\r\nsmt_send_mbuf(smc,mb,local ? FC_SMT_LOC : fc) ;\r\n}\r\nstatic void smt_send_rdf(struct s_smc *smc, SMbuf *rej, int fc, int reason,\r\nint local)\r\n{\r\nSMbuf *mb ;\r\nstruct smt_header *sm ;\r\nstruct smt_rdf *rdf ;\r\nint len ;\r\nint frame_len ;\r\nsm = smtod(rej,struct smt_header *) ;\r\nif (sm->smt_type != SMT_REQUEST)\r\nreturn ;\r\nDB_SMT("SMT: sending RDF to %s,reason = 0x%x\n",\r\naddr_to_string(&sm->smt_source),reason) ;\r\nframe_len = rej->sm_len ;\r\nif (!(mb=smt_build_frame(smc,SMT_RDF,SMT_REPLY,sizeof(struct smt_rdf))))\r\nreturn ;\r\nrdf = smtod(mb,struct smt_rdf *) ;\r\nrdf->smt.smt_tid = sm->smt_tid ;\r\nrdf->smt.smt_dest = sm->smt_source ;\r\nrdf->reason.para.p_type = SMT_P_REASON ;\r\nrdf->reason.para.p_len = sizeof(struct smt_p_reason) - PARA_LEN ;\r\nrdf->reason.rdf_reason = reason ;\r\nrdf->version.para.p_type = SMT_P_VERSION ;\r\nrdf->version.para.p_len = sizeof(struct smt_p_version) - PARA_LEN ;\r\nrdf->version.v_pad = 0 ;\r\nrdf->version.v_n = 1 ;\r\nrdf->version.v_index = 1 ;\r\nrdf->version.v_version[0] = SMT_VID_2 ;\r\nrdf->version.v_pad2 = 0 ;\r\nif ((unsigned) frame_len <= SMT_MAX_INFO_LEN - sizeof(*rdf) +\r\n2*sizeof(struct smt_header))\r\nlen = frame_len ;\r\nelse\r\nlen = SMT_MAX_INFO_LEN - sizeof(*rdf) +\r\n2*sizeof(struct smt_header) ;\r\nlen &= ~3 ;\r\nrdf->refused.para.p_type = SMT_P_REFUSED ;\r\nrdf->refused.para.p_len = len + 4 ;\r\nrdf->refused.ref_fc = fc ;\r\nsmt_swap_para(sm,frame_len,0) ;\r\nmemcpy((char *) &rdf->refused.ref_header,(char *) sm,len) ;\r\nlen -= sizeof(struct smt_header) ;\r\nmb->sm_len += len ;\r\nrdf->smt.smt_len += len ;\r\ndump_smt(smc,(struct smt_header *)rdf,"RDF") ;\r\nsmc->mib.priv.fddiPRIVRDF_Tx++ ;\r\nsmt_send_frame(smc,mb,FC_SMT_INFO,local) ;\r\n}\r\nstatic void smt_send_nif(struct s_smc *smc, const struct fddi_addr *dest,\r\nint fc, u_long tid, int type, int local)\r\n{\r\nstruct smt_nif *nif ;\r\nSMbuf *mb ;\r\nif (!(mb = smt_build_frame(smc,SMT_NIF,type,sizeof(struct smt_nif))))\r\nreturn ;\r\nnif = smtod(mb, struct smt_nif *) ;\r\nsmt_fill_una(smc,&nif->una) ;\r\nsmt_fill_sde(smc,&nif->sde) ;\r\nsmt_fill_state(smc,&nif->state) ;\r\n#ifdef SMT6_10\r\nsmt_fill_fsc(smc,&nif->fsc) ;\r\n#endif\r\nnif->smt.smt_dest = *dest ;\r\nnif->smt.smt_tid = tid ;\r\ndump_smt(smc,(struct smt_header *)nif,"NIF") ;\r\nsmt_send_frame(smc,mb,fc,local) ;\r\n}\r\nstatic void smt_send_nif_request(struct s_smc *smc, struct fddi_addr *dest)\r\n{\r\nsmc->sm.pend[SMT_TID_NIF_TEST] = smt_get_tid(smc) ;\r\nsmt_send_nif(smc,dest, FC_SMT_INFO, smc->sm.pend[SMT_TID_NIF_TEST],\r\nSMT_REQUEST,0) ;\r\n}\r\nstatic void smt_send_ecf_request(struct s_smc *smc, struct fddi_addr *dest,\r\nint len)\r\n{\r\nsmc->sm.pend[SMT_TID_ECF] = smt_get_tid(smc) ;\r\nsmt_send_ecf(smc,dest, FC_SMT_INFO, smc->sm.pend[SMT_TID_ECF],\r\nSMT_REQUEST,len) ;\r\n}\r\nstatic void smt_echo_test(struct s_smc *smc, int dna)\r\n{\r\nu_long tid ;\r\nsmc->sm.pend[dna ? SMT_TID_ECF_DNA : SMT_TID_ECF_UNA] =\r\ntid = smt_get_tid(smc) ;\r\nsmt_send_ecf(smc, dna ?\r\n&smc->mib.m[MAC0].fddiMACDownstreamNbr :\r\n&smc->mib.m[MAC0].fddiMACUpstreamNbr,\r\nFC_SMT_INFO,tid, SMT_REQUEST, (SMT_TEST_ECHO_LEN & ~3)-8) ;\r\n}\r\nstatic void smt_send_ecf(struct s_smc *smc, struct fddi_addr *dest, int fc,\r\nu_long tid, int type, int len)\r\n{\r\nstruct smt_ecf *ecf ;\r\nSMbuf *mb ;\r\nif (!(mb = smt_build_frame(smc,SMT_ECF,type,SMT_ECF_LEN + len)))\r\nreturn ;\r\necf = smtod(mb, struct smt_ecf *) ;\r\nsmt_fill_echo(smc,&ecf->ec_echo,tid,len) ;\r\necf->smt.smt_dest = *dest ;\r\necf->smt.smt_tid = tid ;\r\nsmc->mib.priv.fddiPRIVECF_Req_Tx++ ;\r\nsmt_send_frame(smc,mb,fc,0) ;\r\n}\r\nstatic void smt_send_sif_config(struct s_smc *smc, struct fddi_addr *dest,\r\nu_long tid, int local)\r\n{\r\nstruct smt_sif_config *sif ;\r\nSMbuf *mb ;\r\nint len ;\r\nif (!(mb = smt_build_frame(smc,SMT_SIF_CONFIG,SMT_REPLY,\r\nSIZEOF_SMT_SIF_CONFIG)))\r\nreturn ;\r\nsif = smtod(mb, struct smt_sif_config *) ;\r\nsmt_fill_timestamp(smc,&sif->ts) ;\r\nsmt_fill_sde(smc,&sif->sde) ;\r\nsmt_fill_version(smc,&sif->version) ;\r\nsmt_fill_state(smc,&sif->state) ;\r\nsmt_fill_policy(smc,&sif->policy) ;\r\nsmt_fill_latency(smc,&sif->latency);\r\nsmt_fill_neighbor(smc,&sif->neighbor);\r\nsmt_fill_setcount(smc,&sif->setcount) ;\r\nlen = smt_fill_path(smc,&sif->path);\r\nsif->smt.smt_dest = *dest ;\r\nsif->smt.smt_tid = tid ;\r\nsmt_add_frame_len(mb,len) ;\r\ndump_smt(smc,(struct smt_header *)sif,"SIF Configuration Reply") ;\r\nsmt_send_frame(smc,mb,FC_SMT_INFO,local) ;\r\n}\r\nstatic void smt_send_sif_operation(struct s_smc *smc, struct fddi_addr *dest,\r\nu_long tid, int local)\r\n{\r\nstruct smt_sif_operation *sif ;\r\nSMbuf *mb ;\r\nint ports ;\r\nint i ;\r\nports = NUMPHYS ;\r\n#ifndef CONCENTRATOR\r\nif (smc->s.sas == SMT_SAS)\r\nports = 1 ;\r\n#endif\r\nif (!(mb = smt_build_frame(smc,SMT_SIF_OPER,SMT_REPLY,\r\nSIZEOF_SMT_SIF_OPERATION+ports*sizeof(struct smt_p_lem))))\r\nreturn ;\r\nsif = smtod(mb, struct smt_sif_operation *) ;\r\nsmt_fill_timestamp(smc,&sif->ts) ;\r\nsmt_fill_mac_status(smc,&sif->status) ;\r\nsmt_fill_mac_counter(smc,&sif->mc) ;\r\nsmt_fill_mac_fnc(smc,&sif->fnc) ;\r\nsmt_fill_manufacturer(smc,&sif->man) ;\r\nsmt_fill_user(smc,&sif->user) ;\r\nsmt_fill_setcount(smc,&sif->setcount) ;\r\nif (ports == 1) {\r\nsmt_fill_lem(smc,sif->lem,PS) ;\r\n}\r\nelse {\r\nfor (i = 0 ; i < ports ; i++) {\r\nsmt_fill_lem(smc,&sif->lem[i],i) ;\r\n}\r\n}\r\nsif->smt.smt_dest = *dest ;\r\nsif->smt.smt_tid = tid ;\r\ndump_smt(smc,(struct smt_header *)sif,"SIF Operation Reply") ;\r\nsmt_send_frame(smc,mb,FC_SMT_INFO,local) ;\r\n}\r\nSMbuf *smt_build_frame(struct s_smc *smc, int class, int type,\r\nint length)\r\n{\r\nSMbuf *mb ;\r\nstruct smt_header *smt ;\r\n#if 0\r\nif (!smc->r.sm_ma_avail) {\r\nreturn 0;\r\n}\r\n#endif\r\nif (!(mb = smt_get_mbuf(smc)))\r\nreturn mb;\r\nmb->sm_len = length ;\r\nsmt = smtod(mb, struct smt_header *) ;\r\nsmt->smt_dest = fddi_broadcast ;\r\nsmt->smt_class = class ;\r\nsmt->smt_type = type ;\r\nswitch (class) {\r\ncase SMT_NIF :\r\ncase SMT_SIF_CONFIG :\r\ncase SMT_SIF_OPER :\r\ncase SMT_ECF :\r\nsmt->smt_version = SMT_VID ;\r\nbreak ;\r\ndefault :\r\nsmt->smt_version = SMT_VID_2 ;\r\nbreak ;\r\n}\r\nsmt->smt_tid = smt_get_tid(smc) ;\r\nsmt->smt_pad = 0 ;\r\nsmt->smt_len = length - sizeof(struct smt_header) ;\r\nreturn mb;\r\n}\r\nstatic void smt_add_frame_len(SMbuf *mb, int len)\r\n{\r\nstruct smt_header *smt ;\r\nsmt = smtod(mb, struct smt_header *) ;\r\nsmt->smt_len += len ;\r\nmb->sm_len += len ;\r\n}\r\nstatic void smt_fill_una(struct s_smc *smc, struct smt_p_una *una)\r\n{\r\nSMTSETPARA(una,SMT_P_UNA) ;\r\nuna->una_pad = 0 ;\r\nuna->una_node = smc->mib.m[MAC0].fddiMACUpstreamNbr ;\r\n}\r\nstatic void smt_fill_sde(struct s_smc *smc, struct smt_p_sde *sde)\r\n{\r\nSMTSETPARA(sde,SMT_P_SDE) ;\r\nsde->sde_non_master = smc->mib.fddiSMTNonMaster_Ct ;\r\nsde->sde_master = smc->mib.fddiSMTMaster_Ct ;\r\nsde->sde_mac_count = NUMMACS ;\r\n#ifdef CONCENTRATOR\r\nsde->sde_type = SMT_SDE_CONCENTRATOR ;\r\n#else\r\nsde->sde_type = SMT_SDE_STATION ;\r\n#endif\r\n}\r\nstatic void smt_fill_state(struct s_smc *smc, struct smt_p_state *state)\r\n{\r\nint top ;\r\nint twist ;\r\nSMTSETPARA(state,SMT_P_STATE) ;\r\nstate->st_pad = 0 ;\r\ntop = 0 ;\r\nif (smc->mib.fddiSMTPeerWrapFlag) {\r\ntop |= SMT_ST_WRAPPED ;\r\n}\r\n#ifdef CONCENTRATOR\r\nif (cfm_status_unattached(smc)) {\r\ntop |= SMT_ST_UNATTACHED ;\r\n}\r\n#endif\r\nif ((twist = pcm_status_twisted(smc)) & 1) {\r\ntop |= SMT_ST_TWISTED_A ;\r\n}\r\nif (twist & 2) {\r\ntop |= SMT_ST_TWISTED_B ;\r\n}\r\n#ifdef OPT_SRF\r\ntop |= SMT_ST_SRF ;\r\n#endif\r\nif (pcm_rooted_station(smc))\r\ntop |= SMT_ST_ROOTED_S ;\r\nif (smc->mib.a[0].fddiPATHSbaPayload != 0)\r\ntop |= SMT_ST_SYNC_SERVICE ;\r\nstate->st_topology = top ;\r\nstate->st_dupl_addr =\r\n((smc->mib.m[MAC0].fddiMACDA_Flag ? SMT_ST_MY_DUPA : 0 ) |\r\n(smc->mib.m[MAC0].fddiMACUNDA_Flag ? SMT_ST_UNA_DUPA : 0)) ;\r\n}\r\nstatic void smt_fill_timestamp(struct s_smc *smc, struct smt_p_timestamp *ts)\r\n{\r\nSMTSETPARA(ts,SMT_P_TIMESTAMP) ;\r\nsmt_set_timestamp(smc,ts->ts_time) ;\r\n}\r\nvoid smt_set_timestamp(struct s_smc *smc, u_char *p)\r\n{\r\nu_long time ;\r\nu_long utime ;\r\nutime = smt_get_time() ;\r\ntime = utime * 100 ;\r\ntime /= TICKS_PER_SECOND ;\r\np[0] = 0 ;\r\np[1] = (u_char)((time>>(8+8+8+8-1)) & 1) ;\r\np[2] = (u_char)(time>>(8+8+8-1)) ;\r\np[3] = (u_char)(time>>(8+8-1)) ;\r\np[4] = (u_char)(time>>(8-1)) ;\r\np[5] = (u_char)(time<<1) ;\r\np[6] = (u_char)(smc->sm.uniq_ticks>>8) ;\r\np[7] = (u_char)smc->sm.uniq_ticks ;\r\nif (utime != smc->sm.uniq_time) {\r\nsmc->sm.uniq_ticks = 0 ;\r\n}\r\nsmc->sm.uniq_ticks++ ;\r\nsmc->sm.uniq_time = utime ;\r\n}\r\nstatic void smt_fill_policy(struct s_smc *smc, struct smt_p_policy *policy)\r\n{\r\nint i ;\r\nconst u_char *map ;\r\nu_short in ;\r\nu_short out ;\r\nstatic const u_char ansi_weirdness[16] = {\r\n0,7,5,3,8,1,6,4,9,10,2,11,12,13,14,15\r\n} ;\r\nSMTSETPARA(policy,SMT_P_POLICY) ;\r\nout = 0 ;\r\nin = smc->mib.fddiSMTConnectionPolicy ;\r\nfor (i = 0, map = ansi_weirdness ; i < 16 ; i++) {\r\nif (in & 1)\r\nout |= (1<<*map) ;\r\nin >>= 1 ;\r\nmap++ ;\r\n}\r\npolicy->pl_config = smc->mib.fddiSMTConfigPolicy ;\r\npolicy->pl_connect = out ;\r\n}\r\nstatic void smt_fill_latency(struct s_smc *smc, struct smt_p_latency *latency)\r\n{\r\nSMTSETPARA(latency,SMT_P_LATENCY) ;\r\nlatency->lt_phyout_idx1 = phy_index(smc,0) ;\r\nlatency->lt_latency1 = 10 ;\r\nif (smc->s.sas == SMT_DAS) {\r\nlatency->lt_phyout_idx2 = phy_index(smc,1) ;\r\nlatency->lt_latency2 = 10 ;\r\n}\r\nelse {\r\nlatency->lt_phyout_idx2 = 0 ;\r\nlatency->lt_latency2 = 0 ;\r\n}\r\n}\r\nstatic void smt_fill_neighbor(struct s_smc *smc, struct smt_p_neighbor *neighbor)\r\n{\r\nSMTSETPARA(neighbor,SMT_P_NEIGHBORS) ;\r\nneighbor->nb_mib_index = INDEX_MAC ;\r\nneighbor->nb_mac_index = mac_index(smc,1) ;\r\nneighbor->nb_una = smc->mib.m[MAC0].fddiMACUpstreamNbr ;\r\nneighbor->nb_dna = smc->mib.m[MAC0].fddiMACDownstreamNbr ;\r\n}\r\nstatic int smt_fill_path(struct s_smc *smc, struct smt_p_path *path)\r\n{\r\nSK_LOC_DECL(int,type) ;\r\nSK_LOC_DECL(int,state) ;\r\nSK_LOC_DECL(int,remote) ;\r\nSK_LOC_DECL(int,mac) ;\r\nint len ;\r\nint p ;\r\nint physp ;\r\nstruct smt_phy_rec *phy ;\r\nstruct smt_mac_rec *pd_mac ;\r\nlen = PARA_LEN +\r\nsizeof(struct smt_mac_rec) * NUMMACS +\r\nsizeof(struct smt_phy_rec) * ALLPHYS ;\r\npath->para.p_type = SMT_P_PATH ;\r\npath->para.p_len = len - PARA_LEN ;\r\nfor (p = 0,phy = path->pd_phy ; p < ALLPHYS ; p++, phy++) {\r\nphysp = p ;\r\n#ifndef CONCENTRATOR\r\nif (smc->s.sas == SMT_SAS)\r\nphysp = PS ;\r\n#endif\r\npcm_status_state(smc,physp,&type,&state,&remote,&mac) ;\r\n#ifdef LITTLE_ENDIAN\r\nphy->phy_mib_index = smt_swap_short((u_short)p+INDEX_PORT) ;\r\n#else\r\nphy->phy_mib_index = p+INDEX_PORT ;\r\n#endif\r\nphy->phy_type = type ;\r\nphy->phy_connect_state = state ;\r\nphy->phy_remote_type = remote ;\r\nphy->phy_remote_mac = mac ;\r\nphy->phy_resource_idx = phy_con_resource_index(smc,p) ;\r\n}\r\npd_mac = (struct smt_mac_rec *) phy ;\r\npd_mac->mac_addr = smc->mib.m[MAC0].fddiMACSMTAddress ;\r\npd_mac->mac_resource_idx = mac_con_resource_index(smc,1) ;\r\nreturn len;\r\n}\r\nstatic void smt_fill_mac_status(struct s_smc *smc, struct smt_p_mac_status *st)\r\n{\r\nSMTSETPARA(st,SMT_P_MAC_STATUS) ;\r\nst->st_mib_index = INDEX_MAC ;\r\nst->st_mac_index = mac_index(smc,1) ;\r\nmac_update_counter(smc) ;\r\nst->st_t_req = smc->mib.m[MAC0].fddiMACT_Req ;\r\nst->st_t_neg = smc->mib.m[MAC0].fddiMACT_Neg ;\r\nst->st_t_max = smc->mib.m[MAC0].fddiMACT_Max ;\r\nst->st_tvx_value = smc->mib.m[MAC0].fddiMACTvxValue ;\r\nst->st_t_min = smc->mib.m[MAC0].fddiMACT_Min ;\r\nst->st_sba = smc->mib.a[PATH0].fddiPATHSbaPayload ;\r\nst->st_frame_ct = smc->mib.m[MAC0].fddiMACFrame_Ct ;\r\nst->st_error_ct = smc->mib.m[MAC0].fddiMACError_Ct ;\r\nst->st_lost_ct = smc->mib.m[MAC0].fddiMACLost_Ct ;\r\n}\r\nstatic void smt_fill_lem(struct s_smc *smc, struct smt_p_lem *lem, int phy)\r\n{\r\nstruct fddi_mib_p *mib ;\r\nmib = smc->y[phy].mib ;\r\nSMTSETPARA(lem,SMT_P_LEM) ;\r\nlem->lem_mib_index = phy+INDEX_PORT ;\r\nlem->lem_phy_index = phy_index(smc,phy) ;\r\nlem->lem_pad2 = 0 ;\r\nlem->lem_cutoff = mib->fddiPORTLer_Cutoff ;\r\nlem->lem_alarm = mib->fddiPORTLer_Alarm ;\r\nlem->lem_estimate = mib->fddiPORTLer_Estimate ;\r\nlem->lem_reject_ct = mib->fddiPORTLem_Reject_Ct ;\r\nlem->lem_ct = mib->fddiPORTLem_Ct ;\r\n}\r\nstatic void smt_fill_version(struct s_smc *smc, struct smt_p_version *vers)\r\n{\r\nSK_UNUSED(smc) ;\r\nSMTSETPARA(vers,SMT_P_VERSION) ;\r\nvers->v_pad = 0 ;\r\nvers->v_n = 1 ;\r\nvers->v_index = 1 ;\r\nvers->v_version[0] = SMT_VID_2 ;\r\nvers->v_pad2 = 0 ;\r\n}\r\nstatic void smt_fill_fsc(struct s_smc *smc, struct smt_p_fsc *fsc)\r\n{\r\nSK_UNUSED(smc) ;\r\nSMTSETPARA(fsc,SMT_P_FSC) ;\r\nfsc->fsc_pad0 = 0 ;\r\nfsc->fsc_mac_index = INDEX_MAC ;\r\nfsc->fsc_pad1 = 0 ;\r\nfsc->fsc_value = FSC_TYPE0 ;\r\n#ifdef LITTLE_ENDIAN\r\nfsc->fsc_mac_index = smt_swap_short(INDEX_MAC) ;\r\nfsc->fsc_value = smt_swap_short(FSC_TYPE0) ;\r\n#endif\r\n}\r\nstatic void smt_fill_mac_counter(struct s_smc *smc, struct smt_p_mac_counter *mc)\r\n{\r\nSMTSETPARA(mc,SMT_P_MAC_COUNTER) ;\r\nmc->mc_mib_index = INDEX_MAC ;\r\nmc->mc_index = mac_index(smc,1) ;\r\nmc->mc_receive_ct = smc->mib.m[MAC0].fddiMACCopied_Ct ;\r\nmc->mc_transmit_ct = smc->mib.m[MAC0].fddiMACTransmit_Ct ;\r\n}\r\nstatic void smt_fill_mac_fnc(struct s_smc *smc, struct smt_p_mac_fnc *fnc)\r\n{\r\nSMTSETPARA(fnc,SMT_P_MAC_FNC) ;\r\nfnc->nc_mib_index = INDEX_MAC ;\r\nfnc->nc_index = mac_index(smc,1) ;\r\nfnc->nc_counter = smc->mib.m[MAC0].fddiMACNotCopied_Ct ;\r\n}\r\nstatic void smt_fill_manufacturer(struct s_smc *smc,\r\nstruct smp_p_manufacturer *man)\r\n{\r\nSMTSETPARA(man,SMT_P_MANUFACTURER) ;\r\nmemcpy((char *) man->mf_data,\r\n(char *) smc->mib.fddiSMTManufacturerData,\r\nsizeof(man->mf_data)) ;\r\n}\r\nstatic void smt_fill_user(struct s_smc *smc, struct smp_p_user *user)\r\n{\r\nSMTSETPARA(user,SMT_P_USER) ;\r\nmemcpy((char *) user->us_data,\r\n(char *) smc->mib.fddiSMTUserData,\r\nsizeof(user->us_data)) ;\r\n}\r\nstatic void smt_fill_setcount(struct s_smc *smc, struct smt_p_setcount *setcount)\r\n{\r\nSK_UNUSED(smc) ;\r\nSMTSETPARA(setcount,SMT_P_SETCOUNT) ;\r\nsetcount->count = smc->mib.fddiSMTSetCount.count ;\r\nmemcpy((char *)setcount->timestamp,\r\n(char *)smc->mib.fddiSMTSetCount.timestamp,8) ;\r\n}\r\nstatic void smt_fill_echo(struct s_smc *smc, struct smt_p_echo *echo, u_long seed,\r\nint len)\r\n{\r\nu_char *p ;\r\nSK_UNUSED(smc) ;\r\nSMTSETPARA(echo,SMT_P_ECHODATA) ;\r\necho->para.p_len = len ;\r\nfor (p = echo->ec_data ; len ; len--) {\r\n*p++ = (u_char) seed ;\r\nseed += 13 ;\r\n}\r\n}\r\nstatic void smt_clear_una_dna(struct s_smc *smc)\r\n{\r\nsmc->mib.m[MAC0].fddiMACUpstreamNbr = SMT_Unknown ;\r\nsmc->mib.m[MAC0].fddiMACDownstreamNbr = SMT_Unknown ;\r\n}\r\nstatic void smt_clear_old_una_dna(struct s_smc *smc)\r\n{\r\nsmc->mib.m[MAC0].fddiMACOldUpstreamNbr = SMT_Unknown ;\r\nsmc->mib.m[MAC0].fddiMACOldDownstreamNbr = SMT_Unknown ;\r\n}\r\nu_long smt_get_tid(struct s_smc *smc)\r\n{\r\nu_long tid ;\r\nwhile ((tid = ++(smc->sm.smt_tid) ^ SMT_TID_MAGIC) == 0)\r\n;\r\nreturn tid & 0x3fffffffL;\r\n}\r\nint smt_check_para(struct s_smc *smc, struct smt_header *sm,\r\nconst u_short list[])\r\n{\r\nconst u_short *p = list ;\r\nwhile (*p) {\r\nif (!sm_to_para(smc,sm,(int) *p)) {\r\nDB_SMT("SMT: smt_check_para - missing para %x\n",*p,0);\r\nreturn -1;\r\n}\r\np++ ;\r\n}\r\nreturn 0;\r\n}\r\nvoid *sm_to_para(struct s_smc *smc, struct smt_header *sm, int para)\r\n{\r\nchar *p ;\r\nint len ;\r\nint plen ;\r\nvoid *found = NULL;\r\nSK_UNUSED(smc) ;\r\nlen = sm->smt_len ;\r\np = (char *)(sm+1) ;\r\nwhile (len > 0 ) {\r\nif (((struct smt_para *)p)->p_type == para)\r\nfound = (void *) p ;\r\nplen = ((struct smt_para *)p)->p_len + PARA_LEN ;\r\np += plen ;\r\nlen -= plen ;\r\nif (len < 0) {\r\nDB_SMT("SMT : sm_to_para - length error %d\n",plen,0) ;\r\nreturn NULL;\r\n}\r\nif ((plen & 3) && (para != SMT_P_ECHODATA)) {\r\nDB_SMT("SMT : sm_to_para - odd length %d\n",plen,0) ;\r\nreturn NULL;\r\n}\r\nif (found)\r\nreturn found;\r\n}\r\nreturn NULL;\r\n}\r\nchar *addr_to_string(struct fddi_addr *addr)\r\n{\r\nint i ;\r\nstatic char string[6*3] = "****" ;\r\nfor (i = 0 ; i < 6 ; i++) {\r\nstring[i * 3] = hex_asc_hi(addr->a[i]);\r\nstring[i * 3 + 1] = hex_asc_lo(addr->a[i]);\r\nstring[i * 3 + 2] = ':';\r\n}\r\nstring[5 * 3 + 2] = 0;\r\nreturn string;\r\n}\r\nint smt_ifconfig(int argc, char *argv[])\r\n{\r\nif (argc >= 2 && !strcmp(argv[0],"opt_bypass") &&\r\n!strcmp(argv[1],"yes")) {\r\nsmc->mib.fddiSMTBypassPresent = 1 ;\r\nreturn 0;\r\n}\r\nreturn amdfddi_config(0, argc, argv);\r\n}\r\nstatic int mac_index(struct s_smc *smc, int mac)\r\n{\r\nSK_UNUSED(mac) ;\r\n#ifdef CONCENTRATOR\r\nSK_UNUSED(smc) ;\r\nreturn NUMPHYS + 1;\r\n#else\r\nreturn (smc->s.sas == SMT_SAS) ? 2 : 3;\r\n#endif\r\n}\r\nstatic int phy_index(struct s_smc *smc, int phy)\r\n{\r\nSK_UNUSED(smc) ;\r\nreturn phy + 1;\r\n}\r\nstatic int mac_con_resource_index(struct s_smc *smc, int mac)\r\n{\r\n#ifdef CONCENTRATOR\r\nSK_UNUSED(smc) ;\r\nSK_UNUSED(mac) ;\r\nreturn entity_to_index(smc, cem_get_downstream(smc, ENTITY_MAC));\r\n#else\r\nSK_UNUSED(mac) ;\r\nswitch (smc->mib.fddiSMTCF_State) {\r\ncase SC9_C_WRAP_A :\r\ncase SC5_THRU_B :\r\ncase SC11_C_WRAP_S :\r\nreturn 1;\r\ncase SC10_C_WRAP_B :\r\ncase SC4_THRU_A :\r\nreturn 2;\r\n}\r\nreturn smc->s.sas == SMT_SAS ? 2 : 3;\r\n#endif\r\n}\r\nstatic int phy_con_resource_index(struct s_smc *smc, int phy)\r\n{\r\n#ifdef CONCENTRATOR\r\nreturn entity_to_index(smc, cem_get_downstream(smc, ENTITY_PHY(phy))) ;\r\n#else\r\nswitch (smc->mib.fddiSMTCF_State) {\r\ncase SC9_C_WRAP_A :\r\nreturn phy == PA ? 3 : 2;\r\ncase SC10_C_WRAP_B :\r\nreturn phy == PA ? 1 : 3;\r\ncase SC4_THRU_A :\r\nreturn phy == PA ? 3 : 1;\r\ncase SC5_THRU_B :\r\nreturn phy == PA ? 2 : 3;\r\ncase SC11_C_WRAP_S :\r\nreturn 2;\r\n}\r\nreturn phy;\r\n#endif\r\n}\r\nstatic int entity_to_index(struct s_smc *smc, int e)\r\n{\r\nif (e == ENTITY_MAC)\r\nreturn mac_index(smc, 1);\r\nelse\r\nreturn phy_index(smc, e - ENTITY_PHY(0));\r\n}\r\nstatic int smt_swap_short(u_short s)\r\n{\r\nreturn ((s>>8)&0xff) | ((s&0xff)<<8);\r\n}\r\nvoid smt_swap_para(struct smt_header *sm, int len, int direction)\r\n{\r\nstruct smt_para *pa ;\r\nconst struct smt_pdef *pd ;\r\nchar *p ;\r\nint plen ;\r\nint type ;\r\nint i ;\r\nsmt_string_swap((char *)sm,SWAP_SMTHEADER,len) ;\r\nlen -= sizeof(struct smt_header) ;\r\np = (char *) (sm + 1) ;\r\nwhile (len > 0) {\r\npa = (struct smt_para *) p ;\r\nplen = pa->p_len ;\r\ntype = pa->p_type ;\r\npa->p_type = smt_swap_short(pa->p_type) ;\r\npa->p_len = smt_swap_short(pa->p_len) ;\r\nif (direction) {\r\nplen = pa->p_len ;\r\ntype = pa->p_type ;\r\n}\r\nif (plen < 0)\r\nbreak ;\r\nplen += PARA_LEN ;\r\nfor (i = N_SMT_PLEN, pd = smt_pdef; i ; i--,pd++) {\r\nif (pd->ptype == type)\r\nbreak ;\r\n}\r\nif (i && pd->pswap) {\r\nsmt_string_swap(p+PARA_LEN,pd->pswap,len) ;\r\n}\r\nlen -= plen ;\r\np += plen ;\r\n}\r\n}\r\nstatic void smt_string_swap(char *data, const char *format, int len)\r\n{\r\nconst char *open_paren = NULL ;\r\nint x ;\r\nwhile (len > 0 && *format) {\r\nswitch (*format) {\r\ncase '[' :\r\nopen_paren = format ;\r\nbreak ;\r\ncase ']' :\r\nformat = open_paren ;\r\nbreak ;\r\ncase '1' :\r\ncase '2' :\r\ncase '3' :\r\ncase '4' :\r\ncase '5' :\r\ncase '6' :\r\ncase '7' :\r\ncase '8' :\r\ncase '9' :\r\ndata += *format - '0' ;\r\nlen -= *format - '0' ;\r\nbreak ;\r\ncase 'c':\r\ndata++ ;\r\nlen-- ;\r\nbreak ;\r\ncase 's' :\r\nx = data[0] ;\r\ndata[0] = data[1] ;\r\ndata[1] = x ;\r\ndata += 2 ;\r\nlen -= 2 ;\r\nbreak ;\r\ncase 'l' :\r\nx = data[0] ;\r\ndata[0] = data[3] ;\r\ndata[3] = x ;\r\nx = data[1] ;\r\ndata[1] = data[2] ;\r\ndata[2] = x ;\r\ndata += 4 ;\r\nlen -= 4 ;\r\nbreak ;\r\n}\r\nformat++ ;\r\n}\r\n}\r\nvoid smt_swap_para(struct smt_header *sm, int len, int direction)\r\n{\r\nSK_UNUSED(sm) ;\r\nSK_UNUSED(len) ;\r\nSK_UNUSED(direction) ;\r\n}\r\nint smt_action(struct s_smc *smc, int class, int code, int index)\r\n{\r\nint event ;\r\nint port ;\r\nDB_SMT("SMT: action %d code %d\n",class,code) ;\r\nswitch(class) {\r\ncase SMT_STATION_ACTION :\r\nswitch(code) {\r\ncase SMT_STATION_ACTION_CONNECT :\r\nsmc->mib.fddiSMTRemoteDisconnectFlag = FALSE ;\r\nqueue_event(smc,EVENT_ECM,EC_CONNECT) ;\r\nbreak ;\r\ncase SMT_STATION_ACTION_DISCONNECT :\r\nqueue_event(smc,EVENT_ECM,EC_DISCONNECT) ;\r\nsmc->mib.fddiSMTRemoteDisconnectFlag = TRUE ;\r\nRS_SET(smc,RS_DISCONNECT) ;\r\nAIX_EVENT(smc, (u_long) FDDI_RING_STATUS, (u_long)\r\nFDDI_SMT_EVENT, (u_long) FDDI_REMOTE_DISCONNECT,\r\nsmt_get_event_word(smc));\r\nbreak ;\r\ncase SMT_STATION_ACTION_PATHTEST :\r\nAIX_EVENT(smc, (u_long) FDDI_RING_STATUS, (u_long)\r\nFDDI_SMT_EVENT, (u_long) FDDI_PATH_TEST,\r\nsmt_get_event_word(smc));\r\nbreak ;\r\ncase SMT_STATION_ACTION_SELFTEST :\r\nAIX_EVENT(smc, (u_long) FDDI_RING_STATUS, (u_long)\r\nFDDI_SMT_EVENT, (u_long) FDDI_REMOTE_SELF_TEST,\r\nsmt_get_event_word(smc));\r\nbreak ;\r\ncase SMT_STATION_ACTION_DISABLE_A :\r\nif (smc->y[PA].pc_mode == PM_PEER) {\r\nRS_SET(smc,RS_EVENT) ;\r\nqueue_event(smc,EVENT_PCM+PA,PC_DISABLE) ;\r\n}\r\nbreak ;\r\ncase SMT_STATION_ACTION_DISABLE_B :\r\nif (smc->y[PB].pc_mode == PM_PEER) {\r\nRS_SET(smc,RS_EVENT) ;\r\nqueue_event(smc,EVENT_PCM+PB,PC_DISABLE) ;\r\n}\r\nbreak ;\r\ncase SMT_STATION_ACTION_DISABLE_M :\r\nfor (port = 0 ; port < NUMPHYS ; port++) {\r\nif (smc->mib.p[port].fddiPORTMy_Type != TM)\r\ncontinue ;\r\nRS_SET(smc,RS_EVENT) ;\r\nqueue_event(smc,EVENT_PCM+port,PC_DISABLE) ;\r\n}\r\nbreak ;\r\ndefault :\r\nreturn 1;\r\n}\r\nbreak ;\r\ncase SMT_PORT_ACTION :\r\nswitch(code) {\r\ncase SMT_PORT_ACTION_ENABLE :\r\nevent = PC_ENABLE ;\r\nbreak ;\r\ncase SMT_PORT_ACTION_DISABLE :\r\nevent = PC_DISABLE ;\r\nbreak ;\r\ncase SMT_PORT_ACTION_MAINT :\r\nevent = PC_MAINT ;\r\nbreak ;\r\ncase SMT_PORT_ACTION_START :\r\nevent = PC_START ;\r\nbreak ;\r\ncase SMT_PORT_ACTION_STOP :\r\nevent = PC_STOP ;\r\nbreak ;\r\ndefault :\r\nreturn 1;\r\n}\r\nqueue_event(smc,EVENT_PCM+index,event) ;\r\nbreak ;\r\ndefault :\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic void hwm_conv_can(struct s_smc *smc, char *data, int len)\r\n{\r\nint i ;\r\nSK_UNUSED(smc) ;\r\nfor (i = len; i ; i--, data++)\r\n*data = bitrev8(*data);\r\n}
