static int usX2Y_usbpcm_urb_capt_retire(struct snd_usX2Y_substream *subs)\r\n{\r\nstruct urb *urb = subs->completed_urb;\r\nstruct snd_pcm_runtime *runtime = subs->pcm_substream->runtime;\r\nint i, lens = 0, hwptr_done = subs->hwptr_done;\r\nstruct usX2Ydev *usX2Y = subs->usX2Y;\r\nif (0 > usX2Y->hwdep_pcm_shm->capture_iso_start) {\r\nint head = usX2Y->hwdep_pcm_shm->captured_iso_head + 1;\r\nif (head >= ARRAY_SIZE(usX2Y->hwdep_pcm_shm->captured_iso))\r\nhead = 0;\r\nusX2Y->hwdep_pcm_shm->capture_iso_start = head;\r\nsnd_printdd("cap start %i\n", head);\r\n}\r\nfor (i = 0; i < nr_of_packs(); i++) {\r\nif (urb->iso_frame_desc[i].status) {\r\nsnd_printk(KERN_ERR "active frame status %i. Most probably some hardware problem.\n", urb->iso_frame_desc[i].status);\r\nreturn urb->iso_frame_desc[i].status;\r\n}\r\nlens += urb->iso_frame_desc[i].actual_length / usX2Y->stride;\r\n}\r\nif ((hwptr_done += lens) >= runtime->buffer_size)\r\nhwptr_done -= runtime->buffer_size;\r\nsubs->hwptr_done = hwptr_done;\r\nsubs->transfer_done += lens;\r\nif (subs->transfer_done >= runtime->period_size) {\r\nsubs->transfer_done -= runtime->period_size;\r\nsnd_pcm_period_elapsed(subs->pcm_substream);\r\n}\r\nreturn 0;\r\n}\r\nstatic inline int usX2Y_iso_frames_per_buffer(struct snd_pcm_runtime *runtime,\r\nstruct usX2Ydev * usX2Y)\r\n{\r\nreturn (runtime->buffer_size * 1000) / usX2Y->rate + 1;\r\n}\r\nstatic int usX2Y_hwdep_urb_play_prepare(struct snd_usX2Y_substream *subs,\r\nstruct urb *urb)\r\n{\r\nint count, counts, pack;\r\nstruct usX2Ydev *usX2Y = subs->usX2Y;\r\nstruct snd_usX2Y_hwdep_pcm_shm *shm = usX2Y->hwdep_pcm_shm;\r\nstruct snd_pcm_runtime *runtime = subs->pcm_substream->runtime;\r\nif (0 > shm->playback_iso_start) {\r\nshm->playback_iso_start = shm->captured_iso_head -\r\nusX2Y_iso_frames_per_buffer(runtime, usX2Y);\r\nif (0 > shm->playback_iso_start)\r\nshm->playback_iso_start += ARRAY_SIZE(shm->captured_iso);\r\nshm->playback_iso_head = shm->playback_iso_start;\r\n}\r\ncount = 0;\r\nfor (pack = 0; pack < nr_of_packs(); pack++) {\r\ncounts = shm->captured_iso[shm->playback_iso_head].length / usX2Y->stride;\r\nif (counts < 43 || counts > 50) {\r\nsnd_printk(KERN_ERR "should not be here with counts=%i\n", counts);\r\nreturn -EPIPE;\r\n}\r\nurb->iso_frame_desc[pack].offset = shm->captured_iso[shm->playback_iso_head].offset;\r\nurb->iso_frame_desc[pack].length = shm->captured_iso[shm->playback_iso_head].length;\r\nif (atomic_read(&subs->state) != state_RUNNING)\r\nmemset((char *)urb->transfer_buffer + urb->iso_frame_desc[pack].offset, 0,\r\nurb->iso_frame_desc[pack].length);\r\nif (++shm->playback_iso_head >= ARRAY_SIZE(shm->captured_iso))\r\nshm->playback_iso_head = 0;\r\ncount += counts;\r\n}\r\nurb->transfer_buffer_length = count * usX2Y->stride;\r\nreturn 0;\r\n}\r\nstatic inline void usX2Y_usbpcm_urb_capt_iso_advance(struct snd_usX2Y_substream *subs,\r\nstruct urb *urb)\r\n{\r\nint pack;\r\nfor (pack = 0; pack < nr_of_packs(); ++pack) {\r\nstruct usb_iso_packet_descriptor *desc = urb->iso_frame_desc + pack;\r\nif (NULL != subs) {\r\nstruct snd_usX2Y_hwdep_pcm_shm *shm = subs->usX2Y->hwdep_pcm_shm;\r\nint head = shm->captured_iso_head + 1;\r\nif (head >= ARRAY_SIZE(shm->captured_iso))\r\nhead = 0;\r\nshm->captured_iso[head].frame = urb->start_frame + pack;\r\nshm->captured_iso[head].offset = desc->offset;\r\nshm->captured_iso[head].length = desc->actual_length;\r\nshm->captured_iso_head = head;\r\nshm->captured_iso_frames++;\r\n}\r\nif ((desc->offset += desc->length * NRURBS*nr_of_packs()) +\r\ndesc->length >= SSS)\r\ndesc->offset -= (SSS - desc->length);\r\n}\r\n}\r\nstatic inline int usX2Y_usbpcm_usbframe_complete(struct snd_usX2Y_substream *capsubs,\r\nstruct snd_usX2Y_substream *capsubs2,\r\nstruct snd_usX2Y_substream *playbacksubs,\r\nint frame)\r\n{\r\nint err, state;\r\nstruct urb *urb = playbacksubs->completed_urb;\r\nstate = atomic_read(&playbacksubs->state);\r\nif (NULL != urb) {\r\nif (state == state_RUNNING)\r\nusX2Y_urb_play_retire(playbacksubs, urb);\r\nelse if (state >= state_PRERUNNING)\r\natomic_inc(&playbacksubs->state);\r\n} else {\r\nswitch (state) {\r\ncase state_STARTING1:\r\nurb = playbacksubs->urb[0];\r\natomic_inc(&playbacksubs->state);\r\nbreak;\r\ncase state_STARTING2:\r\nurb = playbacksubs->urb[1];\r\natomic_inc(&playbacksubs->state);\r\nbreak;\r\n}\r\n}\r\nif (urb) {\r\nif ((err = usX2Y_hwdep_urb_play_prepare(playbacksubs, urb)) ||\r\n(err = usX2Y_urb_submit(playbacksubs, urb, frame))) {\r\nreturn err;\r\n}\r\n}\r\nplaybacksubs->completed_urb = NULL;\r\nstate = atomic_read(&capsubs->state);\r\nif (state >= state_PREPARED) {\r\nif (state == state_RUNNING) {\r\nif ((err = usX2Y_usbpcm_urb_capt_retire(capsubs)))\r\nreturn err;\r\n} else if (state >= state_PRERUNNING)\r\natomic_inc(&capsubs->state);\r\nusX2Y_usbpcm_urb_capt_iso_advance(capsubs, capsubs->completed_urb);\r\nif (NULL != capsubs2)\r\nusX2Y_usbpcm_urb_capt_iso_advance(NULL, capsubs2->completed_urb);\r\nif ((err = usX2Y_urb_submit(capsubs, capsubs->completed_urb, frame)))\r\nreturn err;\r\nif (NULL != capsubs2)\r\nif ((err = usX2Y_urb_submit(capsubs2, capsubs2->completed_urb, frame)))\r\nreturn err;\r\n}\r\ncapsubs->completed_urb = NULL;\r\nif (NULL != capsubs2)\r\ncapsubs2->completed_urb = NULL;\r\nreturn 0;\r\n}\r\nstatic void i_usX2Y_usbpcm_urb_complete(struct urb *urb)\r\n{\r\nstruct snd_usX2Y_substream *subs = urb->context;\r\nstruct usX2Ydev *usX2Y = subs->usX2Y;\r\nstruct snd_usX2Y_substream *capsubs, *capsubs2, *playbacksubs;\r\nif (unlikely(atomic_read(&subs->state) < state_PREPARED)) {\r\nsnd_printdd("hcd_frame=%i ep=%i%s status=%i start_frame=%i\n",\r\nusb_get_current_frame_number(usX2Y->dev),\r\nsubs->endpoint, usb_pipein(urb->pipe) ? "in" : "out",\r\nurb->status, urb->start_frame);\r\nreturn;\r\n}\r\nif (unlikely(urb->status)) {\r\nusX2Y_error_urb_status(usX2Y, subs, urb);\r\nreturn;\r\n}\r\nif (likely((urb->start_frame & 0xFFFF) == (usX2Y->wait_iso_frame & 0xFFFF)))\r\nsubs->completed_urb = urb;\r\nelse {\r\nusX2Y_error_sequence(usX2Y, subs, urb);\r\nreturn;\r\n}\r\ncapsubs = usX2Y->subs[SNDRV_PCM_STREAM_CAPTURE];\r\ncapsubs2 = usX2Y->subs[SNDRV_PCM_STREAM_CAPTURE + 2];\r\nplaybacksubs = usX2Y->subs[SNDRV_PCM_STREAM_PLAYBACK];\r\nif (capsubs->completed_urb && atomic_read(&capsubs->state) >= state_PREPARED &&\r\n(NULL == capsubs2 || capsubs2->completed_urb) &&\r\n(playbacksubs->completed_urb || atomic_read(&playbacksubs->state) < state_PREPARED)) {\r\nif (!usX2Y_usbpcm_usbframe_complete(capsubs, capsubs2, playbacksubs, urb->start_frame))\r\nusX2Y->wait_iso_frame += nr_of_packs();\r\nelse {\r\nsnd_printdd("\n");\r\nusX2Y_clients_stop(usX2Y);\r\n}\r\n}\r\n}\r\nstatic void usX2Y_hwdep_urb_release(struct urb **urb)\r\n{\r\nusb_kill_urb(*urb);\r\nusb_free_urb(*urb);\r\n*urb = NULL;\r\n}\r\nstatic void usX2Y_usbpcm_urbs_release(struct snd_usX2Y_substream *subs)\r\n{\r\nint i;\r\nsnd_printdd("snd_usX2Y_urbs_release() %i\n", subs->endpoint);\r\nfor (i = 0; i < NRURBS; i++)\r\nusX2Y_hwdep_urb_release(subs->urb + i);\r\n}\r\nstatic void usX2Y_usbpcm_subs_startup_finish(struct usX2Ydev * usX2Y)\r\n{\r\nusX2Y_urbs_set_complete(usX2Y, i_usX2Y_usbpcm_urb_complete);\r\nusX2Y->prepare_subs = NULL;\r\n}\r\nstatic void i_usX2Y_usbpcm_subs_startup(struct urb *urb)\r\n{\r\nstruct snd_usX2Y_substream *subs = urb->context;\r\nstruct usX2Ydev *usX2Y = subs->usX2Y;\r\nstruct snd_usX2Y_substream *prepare_subs = usX2Y->prepare_subs;\r\nif (NULL != prepare_subs &&\r\nurb->start_frame == prepare_subs->urb[0]->start_frame) {\r\natomic_inc(&prepare_subs->state);\r\nif (prepare_subs == usX2Y->subs[SNDRV_PCM_STREAM_CAPTURE]) {\r\nstruct snd_usX2Y_substream *cap_subs2 = usX2Y->subs[SNDRV_PCM_STREAM_CAPTURE + 2];\r\nif (cap_subs2 != NULL)\r\natomic_inc(&cap_subs2->state);\r\n}\r\nusX2Y_usbpcm_subs_startup_finish(usX2Y);\r\nwake_up(&usX2Y->prepare_wait_queue);\r\n}\r\ni_usX2Y_usbpcm_urb_complete(urb);\r\n}\r\nstatic int usX2Y_usbpcm_urbs_allocate(struct snd_usX2Y_substream *subs)\r\n{\r\nint i;\r\nunsigned int pipe;\r\nint is_playback = subs == subs->usX2Y->subs[SNDRV_PCM_STREAM_PLAYBACK];\r\nstruct usb_device *dev = subs->usX2Y->dev;\r\npipe = is_playback ? usb_sndisocpipe(dev, subs->endpoint) :\r\nusb_rcvisocpipe(dev, subs->endpoint);\r\nsubs->maxpacksize = usb_maxpacket(dev, pipe, is_playback);\r\nif (!subs->maxpacksize)\r\nreturn -EINVAL;\r\nfor (i = 0; i < NRURBS; i++) {\r\nstruct urb **purb = subs->urb + i;\r\nif (*purb) {\r\nusb_kill_urb(*purb);\r\ncontinue;\r\n}\r\n*purb = usb_alloc_urb(nr_of_packs(), GFP_KERNEL);\r\nif (NULL == *purb) {\r\nusX2Y_usbpcm_urbs_release(subs);\r\nreturn -ENOMEM;\r\n}\r\n(*purb)->transfer_buffer = is_playback ?\r\nsubs->usX2Y->hwdep_pcm_shm->playback : (\r\nsubs->endpoint == 0x8 ?\r\nsubs->usX2Y->hwdep_pcm_shm->capture0x8 :\r\nsubs->usX2Y->hwdep_pcm_shm->capture0xA);\r\n(*purb)->dev = dev;\r\n(*purb)->pipe = pipe;\r\n(*purb)->number_of_packets = nr_of_packs();\r\n(*purb)->context = subs;\r\n(*purb)->interval = 1;\r\n(*purb)->complete = i_usX2Y_usbpcm_subs_startup;\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_usX2Y_usbpcm_hw_free(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct snd_usX2Y_substream *subs = runtime->private_data,\r\n*cap_subs2 = subs->usX2Y->subs[SNDRV_PCM_STREAM_CAPTURE + 2];\r\nmutex_lock(&subs->usX2Y->prepare_mutex);\r\nsnd_printdd("snd_usX2Y_usbpcm_hw_free(%p)\n", substream);\r\nif (SNDRV_PCM_STREAM_PLAYBACK == substream->stream) {\r\nstruct snd_usX2Y_substream *cap_subs = subs->usX2Y->subs[SNDRV_PCM_STREAM_CAPTURE];\r\natomic_set(&subs->state, state_STOPPED);\r\nusX2Y_usbpcm_urbs_release(subs);\r\nif (!cap_subs->pcm_substream ||\r\n!cap_subs->pcm_substream->runtime ||\r\n!cap_subs->pcm_substream->runtime->status ||\r\ncap_subs->pcm_substream->runtime->status->state < SNDRV_PCM_STATE_PREPARED) {\r\natomic_set(&cap_subs->state, state_STOPPED);\r\nif (NULL != cap_subs2)\r\natomic_set(&cap_subs2->state, state_STOPPED);\r\nusX2Y_usbpcm_urbs_release(cap_subs);\r\nif (NULL != cap_subs2)\r\nusX2Y_usbpcm_urbs_release(cap_subs2);\r\n}\r\n} else {\r\nstruct snd_usX2Y_substream *playback_subs = subs->usX2Y->subs[SNDRV_PCM_STREAM_PLAYBACK];\r\nif (atomic_read(&playback_subs->state) < state_PREPARED) {\r\natomic_set(&subs->state, state_STOPPED);\r\nif (NULL != cap_subs2)\r\natomic_set(&cap_subs2->state, state_STOPPED);\r\nusX2Y_usbpcm_urbs_release(subs);\r\nif (NULL != cap_subs2)\r\nusX2Y_usbpcm_urbs_release(cap_subs2);\r\n}\r\n}\r\nmutex_unlock(&subs->usX2Y->prepare_mutex);\r\nreturn snd_pcm_lib_free_pages(substream);\r\n}\r\nstatic void usX2Y_usbpcm_subs_startup(struct snd_usX2Y_substream *subs)\r\n{\r\nstruct usX2Ydev * usX2Y = subs->usX2Y;\r\nusX2Y->prepare_subs = subs;\r\nsubs->urb[0]->start_frame = -1;\r\nsmp_wmb();\r\nusX2Y_urbs_set_complete(usX2Y, i_usX2Y_usbpcm_subs_startup);\r\n}\r\nstatic int usX2Y_usbpcm_urbs_start(struct snd_usX2Y_substream *subs)\r\n{\r\nint p, u, err,\r\nstream = subs->pcm_substream->stream;\r\nstruct usX2Ydev *usX2Y = subs->usX2Y;\r\nif (SNDRV_PCM_STREAM_CAPTURE == stream) {\r\nusX2Y->hwdep_pcm_shm->captured_iso_head = -1;\r\nusX2Y->hwdep_pcm_shm->captured_iso_frames = 0;\r\n}\r\nfor (p = 0; 3 >= (stream + p); p += 2) {\r\nstruct snd_usX2Y_substream *subs = usX2Y->subs[stream + p];\r\nif (subs != NULL) {\r\nif ((err = usX2Y_usbpcm_urbs_allocate(subs)) < 0)\r\nreturn err;\r\nsubs->completed_urb = NULL;\r\n}\r\n}\r\nfor (p = 0; p < 4; p++) {\r\nstruct snd_usX2Y_substream *subs = usX2Y->subs[p];\r\nif (subs != NULL && atomic_read(&subs->state) >= state_PREPARED)\r\ngoto start;\r\n}\r\nstart:\r\nusX2Y_usbpcm_subs_startup(subs);\r\nfor (u = 0; u < NRURBS; u++) {\r\nfor (p = 0; 3 >= (stream + p); p += 2) {\r\nstruct snd_usX2Y_substream *subs = usX2Y->subs[stream + p];\r\nif (subs != NULL) {\r\nstruct urb *urb = subs->urb[u];\r\nif (usb_pipein(urb->pipe)) {\r\nunsigned long pack;\r\nif (0 == u)\r\natomic_set(&subs->state, state_STARTING3);\r\nurb->dev = usX2Y->dev;\r\nurb->transfer_flags = URB_ISO_ASAP;\r\nfor (pack = 0; pack < nr_of_packs(); pack++) {\r\nurb->iso_frame_desc[pack].offset = subs->maxpacksize * (pack + u * nr_of_packs());\r\nurb->iso_frame_desc[pack].length = subs->maxpacksize;\r\n}\r\nurb->transfer_buffer_length = subs->maxpacksize * nr_of_packs();\r\nif ((err = usb_submit_urb(urb, GFP_KERNEL)) < 0) {\r\nsnd_printk (KERN_ERR "cannot usb_submit_urb() for urb %d, err = %d\n", u, err);\r\nerr = -EPIPE;\r\ngoto cleanup;\r\n} else {\r\nsnd_printdd("%i\n", urb->start_frame);\r\nif (u == 0)\r\nusX2Y->wait_iso_frame = urb->start_frame;\r\n}\r\nurb->transfer_flags = 0;\r\n} else {\r\natomic_set(&subs->state, state_STARTING1);\r\nbreak;\r\n}\r\n}\r\n}\r\n}\r\nerr = 0;\r\nwait_event(usX2Y->prepare_wait_queue, NULL == usX2Y->prepare_subs);\r\nif (atomic_read(&subs->state) != state_PREPARED)\r\nerr = -EPIPE;\r\ncleanup:\r\nif (err) {\r\nusX2Y_subs_startup_finish(usX2Y);\r\nusX2Y_clients_stop(usX2Y);\r\n}\r\nreturn err;\r\n}\r\nstatic int snd_usX2Y_usbpcm_prepare(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct snd_usX2Y_substream *subs = runtime->private_data;\r\nstruct usX2Ydev *usX2Y = subs->usX2Y;\r\nstruct snd_usX2Y_substream *capsubs = subs->usX2Y->subs[SNDRV_PCM_STREAM_CAPTURE];\r\nint err = 0;\r\nsnd_printdd("snd_usX2Y_pcm_prepare(%p)\n", substream);\r\nif (NULL == usX2Y->hwdep_pcm_shm) {\r\nif (NULL == (usX2Y->hwdep_pcm_shm = snd_malloc_pages(sizeof(struct snd_usX2Y_hwdep_pcm_shm), GFP_KERNEL)))\r\nreturn -ENOMEM;\r\nmemset(usX2Y->hwdep_pcm_shm, 0, sizeof(struct snd_usX2Y_hwdep_pcm_shm));\r\n}\r\nmutex_lock(&usX2Y->prepare_mutex);\r\nusX2Y_subs_prepare(subs);\r\nif (atomic_read(&capsubs->state) < state_PREPARED) {\r\nif (usX2Y->format != runtime->format)\r\nif ((err = usX2Y_format_set(usX2Y, runtime->format)) < 0)\r\ngoto up_prepare_mutex;\r\nif (usX2Y->rate != runtime->rate)\r\nif ((err = usX2Y_rate_set(usX2Y, runtime->rate)) < 0)\r\ngoto up_prepare_mutex;\r\nsnd_printdd("starting capture pipe for %s\n", subs == capsubs ?\r\n"self" : "playpipe");\r\nif (0 > (err = usX2Y_usbpcm_urbs_start(capsubs)))\r\ngoto up_prepare_mutex;\r\n}\r\nif (subs != capsubs) {\r\nusX2Y->hwdep_pcm_shm->playback_iso_start = -1;\r\nif (atomic_read(&subs->state) < state_PREPARED) {\r\nwhile (usX2Y_iso_frames_per_buffer(runtime, usX2Y) >\r\nusX2Y->hwdep_pcm_shm->captured_iso_frames) {\r\nsnd_printdd("Wait: iso_frames_per_buffer=%i,"\r\n"captured_iso_frames=%i\n",\r\nusX2Y_iso_frames_per_buffer(runtime, usX2Y),\r\nusX2Y->hwdep_pcm_shm->captured_iso_frames);\r\nif (msleep_interruptible(10)) {\r\nerr = -ERESTARTSYS;\r\ngoto up_prepare_mutex;\r\n}\r\n}\r\nif (0 > (err = usX2Y_usbpcm_urbs_start(subs)))\r\ngoto up_prepare_mutex;\r\n}\r\nsnd_printdd("Ready: iso_frames_per_buffer=%i,captured_iso_frames=%i\n",\r\nusX2Y_iso_frames_per_buffer(runtime, usX2Y),\r\nusX2Y->hwdep_pcm_shm->captured_iso_frames);\r\n} else\r\nusX2Y->hwdep_pcm_shm->capture_iso_start = -1;\r\nup_prepare_mutex:\r\nmutex_unlock(&usX2Y->prepare_mutex);\r\nreturn err;\r\n}\r\nstatic int snd_usX2Y_usbpcm_open(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_usX2Y_substream *subs = ((struct snd_usX2Y_substream **)\r\nsnd_pcm_substream_chip(substream))[substream->stream];\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nif (!(subs->usX2Y->chip_status & USX2Y_STAT_CHIP_MMAP_PCM_URBS))\r\nreturn -EBUSY;\r\nruntime->hw = SNDRV_PCM_STREAM_PLAYBACK == substream->stream ? snd_usX2Y_2c :\r\n(subs->usX2Y->subs[3] ? snd_usX2Y_4c : snd_usX2Y_2c);\r\nruntime->private_data = subs;\r\nsubs->pcm_substream = substream;\r\nsnd_pcm_hw_constraint_minmax(runtime, SNDRV_PCM_HW_PARAM_PERIOD_TIME, 1000, 200000);\r\nreturn 0;\r\n}\r\nstatic int snd_usX2Y_usbpcm_close(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct snd_usX2Y_substream *subs = runtime->private_data;\r\nsubs->pcm_substream = NULL;\r\nreturn 0;\r\n}\r\nstatic int usX2Y_pcms_lock_check(struct snd_card *card)\r\n{\r\nstruct list_head *list;\r\nstruct snd_device *dev;\r\nstruct snd_pcm *pcm;\r\nint err = 0;\r\nlist_for_each(list, &card->devices) {\r\ndev = snd_device(list);\r\nif (dev->type != SNDRV_DEV_PCM)\r\ncontinue;\r\npcm = dev->device_data;\r\nmutex_lock(&pcm->open_mutex);\r\n}\r\nlist_for_each(list, &card->devices) {\r\nint s;\r\ndev = snd_device(list);\r\nif (dev->type != SNDRV_DEV_PCM)\r\ncontinue;\r\npcm = dev->device_data;\r\nfor (s = 0; s < 2; ++s) {\r\nstruct snd_pcm_substream *substream;\r\nsubstream = pcm->streams[s].substream;\r\nif (substream && SUBSTREAM_BUSY(substream))\r\nerr = -EBUSY;\r\n}\r\n}\r\nreturn err;\r\n}\r\nstatic void usX2Y_pcms_unlock(struct snd_card *card)\r\n{\r\nstruct list_head *list;\r\nstruct snd_device *dev;\r\nstruct snd_pcm *pcm;\r\nlist_for_each(list, &card->devices) {\r\ndev = snd_device(list);\r\nif (dev->type != SNDRV_DEV_PCM)\r\ncontinue;\r\npcm = dev->device_data;\r\nmutex_unlock(&pcm->open_mutex);\r\n}\r\n}\r\nstatic int snd_usX2Y_hwdep_pcm_open(struct snd_hwdep *hw, struct file *file)\r\n{\r\nstruct snd_card *card = hw->card;\r\nint err = usX2Y_pcms_lock_check(card);\r\nif (0 == err)\r\nusX2Y(card)->chip_status |= USX2Y_STAT_CHIP_MMAP_PCM_URBS;\r\nusX2Y_pcms_unlock(card);\r\nreturn err;\r\n}\r\nstatic int snd_usX2Y_hwdep_pcm_release(struct snd_hwdep *hw, struct file *file)\r\n{\r\nstruct snd_card *card = hw->card;\r\nint err = usX2Y_pcms_lock_check(card);\r\nif (0 == err)\r\nusX2Y(hw->card)->chip_status &= ~USX2Y_STAT_CHIP_MMAP_PCM_URBS;\r\nusX2Y_pcms_unlock(card);\r\nreturn err;\r\n}\r\nstatic void snd_usX2Y_hwdep_pcm_vm_open(struct vm_area_struct *area)\r\n{\r\n}\r\nstatic void snd_usX2Y_hwdep_pcm_vm_close(struct vm_area_struct *area)\r\n{\r\n}\r\nstatic int snd_usX2Y_hwdep_pcm_vm_fault(struct vm_area_struct *area,\r\nstruct vm_fault *vmf)\r\n{\r\nunsigned long offset;\r\nvoid *vaddr;\r\noffset = vmf->pgoff << PAGE_SHIFT;\r\nvaddr = (char*)((struct usX2Ydev *)area->vm_private_data)->hwdep_pcm_shm + offset;\r\nvmf->page = virt_to_page(vaddr);\r\nget_page(vmf->page);\r\nreturn 0;\r\n}\r\nstatic int snd_usX2Y_hwdep_pcm_mmap(struct snd_hwdep * hw, struct file *filp, struct vm_area_struct *area)\r\n{\r\nunsigned long size = (unsigned long)(area->vm_end - area->vm_start);\r\nstruct usX2Ydev *usX2Y = hw->private_data;\r\nif (!(usX2Y->chip_status & USX2Y_STAT_CHIP_INIT))\r\nreturn -EBUSY;\r\nif (size > PAGE_ALIGN(sizeof(struct snd_usX2Y_hwdep_pcm_shm))) {\r\nsnd_printd("%lu > %lu\n", size, (unsigned long)sizeof(struct snd_usX2Y_hwdep_pcm_shm));\r\nreturn -EINVAL;\r\n}\r\nif (!usX2Y->hwdep_pcm_shm) {\r\nreturn -ENODEV;\r\n}\r\narea->vm_ops = &snd_usX2Y_hwdep_pcm_vm_ops;\r\narea->vm_flags |= VM_DONTEXPAND | VM_DONTDUMP;\r\narea->vm_private_data = hw->private_data;\r\nreturn 0;\r\n}\r\nstatic void snd_usX2Y_hwdep_pcm_private_free(struct snd_hwdep *hwdep)\r\n{\r\nstruct usX2Ydev *usX2Y = hwdep->private_data;\r\nif (NULL != usX2Y->hwdep_pcm_shm)\r\nsnd_free_pages(usX2Y->hwdep_pcm_shm, sizeof(struct snd_usX2Y_hwdep_pcm_shm));\r\n}\r\nint usX2Y_hwdep_pcm_new(struct snd_card *card)\r\n{\r\nint err;\r\nstruct snd_hwdep *hw;\r\nstruct snd_pcm *pcm;\r\nstruct usb_device *dev = usX2Y(card)->dev;\r\nif (1 != nr_of_packs())\r\nreturn 0;\r\nif ((err = snd_hwdep_new(card, SND_USX2Y_USBPCM_ID, 1, &hw)) < 0)\r\nreturn err;\r\nhw->iface = SNDRV_HWDEP_IFACE_USX2Y_PCM;\r\nhw->private_data = usX2Y(card);\r\nhw->private_free = snd_usX2Y_hwdep_pcm_private_free;\r\nhw->ops.open = snd_usX2Y_hwdep_pcm_open;\r\nhw->ops.release = snd_usX2Y_hwdep_pcm_release;\r\nhw->ops.mmap = snd_usX2Y_hwdep_pcm_mmap;\r\nhw->exclusive = 1;\r\nsprintf(hw->name, "/proc/bus/usb/%03d/%03d/hwdeppcm", dev->bus->busnum, dev->devnum);\r\nerr = snd_pcm_new(card, NAME_ALLCAPS" hwdep Audio", 2, 1, 1, &pcm);\r\nif (err < 0) {\r\nreturn err;\r\n}\r\nsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &snd_usX2Y_usbpcm_ops);\r\nsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &snd_usX2Y_usbpcm_ops);\r\npcm->private_data = usX2Y(card)->subs;\r\npcm->info_flags = 0;\r\nsprintf(pcm->name, NAME_ALLCAPS" hwdep Audio");\r\nif (0 > (err = snd_pcm_lib_preallocate_pages(pcm->streams[SNDRV_PCM_STREAM_PLAYBACK].substream,\r\nSNDRV_DMA_TYPE_CONTINUOUS,\r\nsnd_dma_continuous_data(GFP_KERNEL),\r\n64*1024, 128*1024)) ||\r\n0 > (err = snd_pcm_lib_preallocate_pages(pcm->streams[SNDRV_PCM_STREAM_CAPTURE].substream,\r\nSNDRV_DMA_TYPE_CONTINUOUS,\r\nsnd_dma_continuous_data(GFP_KERNEL),\r\n64*1024, 128*1024))) {\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nint usX2Y_hwdep_pcm_new(struct snd_card *card)\r\n{\r\nreturn 0;\r\n}
