void impd1_tweak_control(struct device *dev, u32 mask, u32 val)\r\n{\r\nstruct impd1_module *impd1 = dev_get_drvdata(dev);\r\nu32 cur;\r\nval &= mask;\r\ncur = readl(impd1->base + IMPD1_CTRL) & ~mask;\r\nwritel(cur | val, impd1->base + IMPD1_CTRL);\r\n}\r\nstatic void impd1fb_clcd_disable(struct clcd_fb *fb)\r\n{\r\nimpd1_tweak_control(fb->dev->dev.parent, IMPD1_CTRL_DISP_MASK, 0);\r\n}\r\nstatic void impd1fb_clcd_enable(struct clcd_fb *fb)\r\n{\r\nimpd1_tweak_control(fb->dev->dev.parent, IMPD1_CTRL_DISP_MASK,\r\nfb->panel->connector | IMPD1_CTRL_DISP_ENABLE);\r\n}\r\nstatic int impd1fb_clcd_setup(struct clcd_fb *fb)\r\n{\r\nunsigned long framebase = fb->dev->res.start + 0x01000000;\r\nunsigned long framesize = SZ_1M;\r\nint ret = 0;\r\nfb->panel = &PANELTYPE;\r\nif (!request_mem_region(framebase, framesize, "clcd framebuffer")) {\r\nprintk(KERN_ERR "IM-PD1: unable to reserve framebuffer\n");\r\nreturn -EBUSY;\r\n}\r\nfb->fb.screen_base = ioremap(framebase, framesize);\r\nif (!fb->fb.screen_base) {\r\nprintk(KERN_ERR "IM-PD1: unable to map framebuffer\n");\r\nret = -ENOMEM;\r\ngoto free_buffer;\r\n}\r\nfb->fb.fix.smem_start = framebase;\r\nfb->fb.fix.smem_len = framesize;\r\nreturn 0;\r\nfree_buffer:\r\nrelease_mem_region(framebase, framesize);\r\nreturn ret;\r\n}\r\nstatic int impd1fb_clcd_mmap(struct clcd_fb *fb, struct vm_area_struct *vma)\r\n{\r\nunsigned long start, size;\r\nstart = vma->vm_pgoff + (fb->fb.fix.smem_start >> PAGE_SHIFT);\r\nsize = vma->vm_end - vma->vm_start;\r\nreturn remap_pfn_range(vma, vma->vm_start, start, size,\r\nvma->vm_page_prot);\r\n}\r\nstatic void impd1fb_clcd_remove(struct clcd_fb *fb)\r\n{\r\niounmap(fb->fb.screen_base);\r\nrelease_mem_region(fb->fb.fix.smem_start, fb->fb.fix.smem_len);\r\n}\r\nstatic int impd1_probe(struct lm_device *dev)\r\n{\r\nstruct impd1_module *impd1;\r\nint i, ret;\r\nif (dev->id != module_id)\r\nreturn -EINVAL;\r\nif (!request_mem_region(dev->resource.start, SZ_4K, "LM registers"))\r\nreturn -EBUSY;\r\nimpd1 = kzalloc(sizeof(struct impd1_module), GFP_KERNEL);\r\nif (!impd1) {\r\nret = -ENOMEM;\r\ngoto release_lm;\r\n}\r\nimpd1->base = ioremap(dev->resource.start, SZ_4K);\r\nif (!impd1->base) {\r\nret = -ENOMEM;\r\ngoto free_impd1;\r\n}\r\nlm_set_drvdata(dev, impd1);\r\nprintk("IM-PD1 found at 0x%08lx\n",\r\n(unsigned long)dev->resource.start);\r\nintegrator_impd1_clk_init(impd1->base, dev->id);\r\nfor (i = 0; i < ARRAY_SIZE(impd1_devs); i++) {\r\nstruct impd1_device *idev = impd1_devs + i;\r\nstruct amba_device *d;\r\nunsigned long pc_base;\r\nchar devname[32];\r\npc_base = dev->resource.start + idev->offset;\r\nsnprintf(devname, 32, "lm%x:%5.5lx", dev->id, idev->offset >> 12);\r\nd = amba_ahb_device_add_res(&dev->dev, devname, pc_base, SZ_4K,\r\ndev->irq, dev->irq,\r\nidev->platform_data, idev->id,\r\n&dev->resource);\r\nif (IS_ERR(d)) {\r\ndev_err(&dev->dev, "unable to register device: %ld\n", PTR_ERR(d));\r\ncontinue;\r\n}\r\n}\r\nreturn 0;\r\nfree_impd1:\r\nif (impd1 && impd1->base)\r\niounmap(impd1->base);\r\nkfree(impd1);\r\nrelease_lm:\r\nrelease_mem_region(dev->resource.start, SZ_4K);\r\nreturn ret;\r\n}\r\nstatic int impd1_remove_one(struct device *dev, void *data)\r\n{\r\ndevice_unregister(dev);\r\nreturn 0;\r\n}\r\nstatic void impd1_remove(struct lm_device *dev)\r\n{\r\nstruct impd1_module *impd1 = lm_get_drvdata(dev);\r\ndevice_for_each_child(&dev->dev, NULL, impd1_remove_one);\r\nintegrator_impd1_clk_exit(dev->id);\r\nlm_set_drvdata(dev, NULL);\r\niounmap(impd1->base);\r\nkfree(impd1);\r\nrelease_mem_region(dev->resource.start, SZ_4K);\r\n}\r\nstatic int __init impd1_init(void)\r\n{\r\nreturn lm_driver_register(&impd1_driver);\r\n}\r\nstatic void __exit impd1_exit(void)\r\n{\r\nlm_driver_unregister(&impd1_driver);\r\n}
