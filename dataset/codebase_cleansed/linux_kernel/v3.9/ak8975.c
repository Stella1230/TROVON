static int ak8975_write_data(struct i2c_client *client,\r\nu8 reg, u8 val, u8 mask, u8 shift)\r\n{\r\nstruct iio_dev *indio_dev = i2c_get_clientdata(client);\r\nstruct ak8975_data *data = iio_priv(indio_dev);\r\nu8 regval;\r\nint ret;\r\nregval = (data->reg_cache[reg] & ~mask) | (val << shift);\r\nret = i2c_smbus_write_byte_data(client, reg, regval);\r\nif (ret < 0) {\r\ndev_err(&client->dev, "Write to device fails status %x\n", ret);\r\nreturn ret;\r\n}\r\ndata->reg_cache[reg] = regval;\r\nreturn 0;\r\n}\r\nstatic int ak8975_read_data(struct i2c_client *client,\r\nu8 reg, u8 length, u8 *buffer)\r\n{\r\nint ret;\r\nstruct i2c_msg msg[2] = {\r\n{\r\n.addr = client->addr,\r\n.flags = I2C_M_NOSTART,\r\n.len = 1,\r\n.buf = &reg,\r\n}, {\r\n.addr = client->addr,\r\n.flags = I2C_M_RD,\r\n.len = length,\r\n.buf = buffer,\r\n}\r\n};\r\nret = i2c_transfer(client->adapter, msg, 2);\r\nif (ret < 0) {\r\ndev_err(&client->dev, "Read from device fails\n");\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ak8975_setup(struct i2c_client *client)\r\n{\r\nstruct iio_dev *indio_dev = i2c_get_clientdata(client);\r\nstruct ak8975_data *data = iio_priv(indio_dev);\r\nu8 device_id;\r\nint ret;\r\nret = ak8975_read_data(client, AK8975_REG_WIA, 1, &device_id);\r\nif (ret < 0) {\r\ndev_err(&client->dev, "Error reading WIA\n");\r\nreturn ret;\r\n}\r\nif (device_id != AK8975_DEVICE_ID) {\r\ndev_err(&client->dev, "Device ak8975 not found\n");\r\nreturn -ENODEV;\r\n}\r\nret = ak8975_write_data(client,\r\nAK8975_REG_CNTL,\r\nAK8975_REG_CNTL_MODE_FUSE_ROM,\r\nAK8975_REG_CNTL_MODE_MASK,\r\nAK8975_REG_CNTL_MODE_SHIFT);\r\nif (ret < 0) {\r\ndev_err(&client->dev, "Error in setting fuse access mode\n");\r\nreturn ret;\r\n}\r\nret = ak8975_read_data(client, AK8975_REG_ASAX, 3, data->asa);\r\nif (ret < 0) {\r\ndev_err(&client->dev, "Not able to read asa data\n");\r\nreturn ret;\r\n}\r\nret = ak8975_write_data(client,\r\nAK8975_REG_CNTL,\r\nAK8975_REG_CNTL_MODE_POWER_DOWN,\r\nAK8975_REG_CNTL_MODE_MASK,\r\nAK8975_REG_CNTL_MODE_SHIFT);\r\nif (ret < 0) {\r\ndev_err(&client->dev, "Error in setting power-down mode\n");\r\nreturn ret;\r\n}\r\ndata->raw_to_gauss[0] = ((data->asa[0] + 128) * 30) >> 8;\r\ndata->raw_to_gauss[1] = ((data->asa[1] + 128) * 30) >> 8;\r\ndata->raw_to_gauss[2] = ((data->asa[2] + 128) * 30) >> 8;\r\nreturn 0;\r\n}\r\nstatic int wait_conversion_complete_gpio(struct ak8975_data *data)\r\n{\r\nstruct i2c_client *client = data->client;\r\nu8 read_status;\r\nu32 timeout_ms = AK8975_MAX_CONVERSION_TIMEOUT;\r\nint ret;\r\nwhile (timeout_ms) {\r\nmsleep(AK8975_CONVERSION_DONE_POLL_TIME);\r\nif (gpio_get_value(data->eoc_gpio))\r\nbreak;\r\ntimeout_ms -= AK8975_CONVERSION_DONE_POLL_TIME;\r\n}\r\nif (!timeout_ms) {\r\ndev_err(&client->dev, "Conversion timeout happened\n");\r\nreturn -EINVAL;\r\n}\r\nret = ak8975_read_data(client, AK8975_REG_ST1, 1, &read_status);\r\nif (ret < 0) {\r\ndev_err(&client->dev, "Error in reading ST1\n");\r\nreturn ret;\r\n}\r\nreturn read_status;\r\n}\r\nstatic int wait_conversion_complete_polled(struct ak8975_data *data)\r\n{\r\nstruct i2c_client *client = data->client;\r\nu8 read_status;\r\nu32 timeout_ms = AK8975_MAX_CONVERSION_TIMEOUT;\r\nint ret;\r\nwhile (timeout_ms) {\r\nmsleep(AK8975_CONVERSION_DONE_POLL_TIME);\r\nret = ak8975_read_data(client, AK8975_REG_ST1, 1, &read_status);\r\nif (ret < 0) {\r\ndev_err(&client->dev, "Error in reading ST1\n");\r\nreturn ret;\r\n}\r\nif (read_status)\r\nbreak;\r\ntimeout_ms -= AK8975_CONVERSION_DONE_POLL_TIME;\r\n}\r\nif (!timeout_ms) {\r\ndev_err(&client->dev, "Conversion timeout happened\n");\r\nreturn -EINVAL;\r\n}\r\nreturn read_status;\r\n}\r\nstatic int ak8975_read_axis(struct iio_dev *indio_dev, int index, int *val)\r\n{\r\nstruct ak8975_data *data = iio_priv(indio_dev);\r\nstruct i2c_client *client = data->client;\r\nu16 meas_reg;\r\ns16 raw;\r\nu8 read_status;\r\nint ret;\r\nmutex_lock(&data->lock);\r\nret = ak8975_write_data(client,\r\nAK8975_REG_CNTL,\r\nAK8975_REG_CNTL_MODE_ONCE,\r\nAK8975_REG_CNTL_MODE_MASK,\r\nAK8975_REG_CNTL_MODE_SHIFT);\r\nif (ret < 0) {\r\ndev_err(&client->dev, "Error in setting operating mode\n");\r\ngoto exit;\r\n}\r\nif (gpio_is_valid(data->eoc_gpio))\r\nret = wait_conversion_complete_gpio(data);\r\nelse\r\nret = wait_conversion_complete_polled(data);\r\nif (ret < 0)\r\ngoto exit;\r\nread_status = ret;\r\nif (read_status & AK8975_REG_ST1_DRDY_MASK) {\r\nret = ak8975_read_data(client, AK8975_REG_ST2, 1, &read_status);\r\nif (ret < 0) {\r\ndev_err(&client->dev, "Error in reading ST2\n");\r\ngoto exit;\r\n}\r\nif (read_status & (AK8975_REG_ST2_DERR_MASK |\r\nAK8975_REG_ST2_HOFL_MASK)) {\r\ndev_err(&client->dev, "ST2 status error 0x%x\n",\r\nread_status);\r\nret = -EINVAL;\r\ngoto exit;\r\n}\r\n}\r\nret = ak8975_read_data(client, ak8975_index_to_reg[index],\r\n2, (u8 *)&meas_reg);\r\nif (ret < 0) {\r\ndev_err(&client->dev, "Read axis data fails\n");\r\ngoto exit;\r\n}\r\nmutex_unlock(&data->lock);\r\nraw = (s16) (le16_to_cpu(meas_reg));\r\nraw = clamp_t(s16, raw, -4096, 4095);\r\n*val = raw;\r\nreturn IIO_VAL_INT;\r\nexit:\r\nmutex_unlock(&data->lock);\r\nreturn ret;\r\n}\r\nstatic int ak8975_read_raw(struct iio_dev *indio_dev,\r\nstruct iio_chan_spec const *chan,\r\nint *val, int *val2,\r\nlong mask)\r\n{\r\nstruct ak8975_data *data = iio_priv(indio_dev);\r\nswitch (mask) {\r\ncase IIO_CHAN_INFO_RAW:\r\nreturn ak8975_read_axis(indio_dev, chan->address, val);\r\ncase IIO_CHAN_INFO_SCALE:\r\n*val = data->raw_to_gauss[chan->address];\r\nreturn IIO_VAL_INT;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int ak8975_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct ak8975_data *data;\r\nstruct iio_dev *indio_dev;\r\nint eoc_gpio;\r\nint err;\r\nif (client->dev.platform_data == NULL)\r\neoc_gpio = -1;\r\nelse\r\neoc_gpio = *(int *)(client->dev.platform_data);\r\nif (gpio_is_valid(eoc_gpio)) {\r\nerr = gpio_request_one(eoc_gpio, GPIOF_IN, "ak_8975");\r\nif (err < 0) {\r\ndev_err(&client->dev,\r\n"failed to request GPIO %d, error %d\n",\r\neoc_gpio, err);\r\ngoto exit;\r\n}\r\n}\r\nindio_dev = iio_device_alloc(sizeof(*data));\r\nif (indio_dev == NULL) {\r\nerr = -ENOMEM;\r\ngoto exit_gpio;\r\n}\r\ndata = iio_priv(indio_dev);\r\ni2c_set_clientdata(client, indio_dev);\r\nerr = ak8975_setup(client);\r\nif (err < 0) {\r\ndev_err(&client->dev, "AK8975 initialization fails\n");\r\ngoto exit_free_iio;\r\n}\r\ndata->client = client;\r\nmutex_init(&data->lock);\r\ndata->eoc_irq = client->irq;\r\ndata->eoc_gpio = eoc_gpio;\r\nindio_dev->dev.parent = &client->dev;\r\nindio_dev->channels = ak8975_channels;\r\nindio_dev->num_channels = ARRAY_SIZE(ak8975_channels);\r\nindio_dev->info = &ak8975_info;\r\nindio_dev->modes = INDIO_DIRECT_MODE;\r\nerr = iio_device_register(indio_dev);\r\nif (err < 0)\r\ngoto exit_free_iio;\r\nreturn 0;\r\nexit_free_iio:\r\niio_device_free(indio_dev);\r\nexit_gpio:\r\nif (gpio_is_valid(eoc_gpio))\r\ngpio_free(eoc_gpio);\r\nexit:\r\nreturn err;\r\n}\r\nstatic int ak8975_remove(struct i2c_client *client)\r\n{\r\nstruct iio_dev *indio_dev = i2c_get_clientdata(client);\r\nstruct ak8975_data *data = iio_priv(indio_dev);\r\niio_device_unregister(indio_dev);\r\nif (gpio_is_valid(data->eoc_gpio))\r\ngpio_free(data->eoc_gpio);\r\niio_device_free(indio_dev);\r\nreturn 0;\r\n}
