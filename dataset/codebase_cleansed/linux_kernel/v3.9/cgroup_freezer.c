static inline struct freezer *cgroup_freezer(struct cgroup *cgroup)\r\n{\r\nreturn container_of(cgroup_subsys_state(cgroup, freezer_subsys_id),\r\nstruct freezer, css);\r\n}\r\nstatic inline struct freezer *task_freezer(struct task_struct *task)\r\n{\r\nreturn container_of(task_subsys_state(task, freezer_subsys_id),\r\nstruct freezer, css);\r\n}\r\nstatic struct freezer *parent_freezer(struct freezer *freezer)\r\n{\r\nstruct cgroup *pcg = freezer->css.cgroup->parent;\r\nif (pcg)\r\nreturn cgroup_freezer(pcg);\r\nreturn NULL;\r\n}\r\nbool cgroup_freezing(struct task_struct *task)\r\n{\r\nbool ret;\r\nrcu_read_lock();\r\nret = task_freezer(task)->state & CGROUP_FREEZING;\r\nrcu_read_unlock();\r\nreturn ret;\r\n}\r\nstatic const char *freezer_state_strs(unsigned int state)\r\n{\r\nif (state & CGROUP_FROZEN)\r\nreturn "FROZEN";\r\nif (state & CGROUP_FREEZING)\r\nreturn "FREEZING";\r\nreturn "THAWED";\r\n}\r\nstatic struct cgroup_subsys_state *freezer_css_alloc(struct cgroup *cgroup)\r\n{\r\nstruct freezer *freezer;\r\nfreezer = kzalloc(sizeof(struct freezer), GFP_KERNEL);\r\nif (!freezer)\r\nreturn ERR_PTR(-ENOMEM);\r\nspin_lock_init(&freezer->lock);\r\nreturn &freezer->css;\r\n}\r\nstatic int freezer_css_online(struct cgroup *cgroup)\r\n{\r\nstruct freezer *freezer = cgroup_freezer(cgroup);\r\nstruct freezer *parent = parent_freezer(freezer);\r\nif (parent)\r\nspin_lock_irq(&parent->lock);\r\nspin_lock_nested(&freezer->lock, SINGLE_DEPTH_NESTING);\r\nfreezer->state |= CGROUP_FREEZER_ONLINE;\r\nif (parent && (parent->state & CGROUP_FREEZING)) {\r\nfreezer->state |= CGROUP_FREEZING_PARENT | CGROUP_FROZEN;\r\natomic_inc(&system_freezing_cnt);\r\n}\r\nspin_unlock(&freezer->lock);\r\nif (parent)\r\nspin_unlock_irq(&parent->lock);\r\nreturn 0;\r\n}\r\nstatic void freezer_css_offline(struct cgroup *cgroup)\r\n{\r\nstruct freezer *freezer = cgroup_freezer(cgroup);\r\nspin_lock_irq(&freezer->lock);\r\nif (freezer->state & CGROUP_FREEZING)\r\natomic_dec(&system_freezing_cnt);\r\nfreezer->state = 0;\r\nspin_unlock_irq(&freezer->lock);\r\n}\r\nstatic void freezer_css_free(struct cgroup *cgroup)\r\n{\r\nkfree(cgroup_freezer(cgroup));\r\n}\r\nstatic void freezer_attach(struct cgroup *new_cgrp, struct cgroup_taskset *tset)\r\n{\r\nstruct freezer *freezer = cgroup_freezer(new_cgrp);\r\nstruct task_struct *task;\r\nbool clear_frozen = false;\r\nspin_lock_irq(&freezer->lock);\r\ncgroup_taskset_for_each(task, new_cgrp, tset) {\r\nif (!(freezer->state & CGROUP_FREEZING)) {\r\n__thaw_task(task);\r\n} else {\r\nfreeze_task(task);\r\nfreezer->state &= ~CGROUP_FROZEN;\r\nclear_frozen = true;\r\n}\r\n}\r\nspin_unlock_irq(&freezer->lock);\r\nwhile (clear_frozen && (freezer = parent_freezer(freezer))) {\r\nspin_lock_irq(&freezer->lock);\r\nfreezer->state &= ~CGROUP_FROZEN;\r\nclear_frozen = freezer->state & CGROUP_FREEZING;\r\nspin_unlock_irq(&freezer->lock);\r\n}\r\n}\r\nstatic void freezer_fork(struct task_struct *task)\r\n{\r\nstruct freezer *freezer;\r\nrcu_read_lock();\r\nfreezer = task_freezer(task);\r\nif (!freezer->css.cgroup->parent)\r\ngoto out;\r\nspin_lock_irq(&freezer->lock);\r\nif (freezer->state & CGROUP_FREEZING)\r\nfreeze_task(task);\r\nspin_unlock_irq(&freezer->lock);\r\nout:\r\nrcu_read_unlock();\r\n}\r\nstatic void update_if_frozen(struct cgroup *cgroup)\r\n{\r\nstruct freezer *freezer = cgroup_freezer(cgroup);\r\nstruct cgroup *pos;\r\nstruct cgroup_iter it;\r\nstruct task_struct *task;\r\nWARN_ON_ONCE(!rcu_read_lock_held());\r\nspin_lock_irq(&freezer->lock);\r\nif (!(freezer->state & CGROUP_FREEZING) ||\r\n(freezer->state & CGROUP_FROZEN))\r\ngoto out_unlock;\r\ncgroup_for_each_child(pos, cgroup) {\r\nstruct freezer *child = cgroup_freezer(pos);\r\nif ((child->state & CGROUP_FREEZER_ONLINE) &&\r\n!(child->state & CGROUP_FROZEN))\r\ngoto out_unlock;\r\n}\r\ncgroup_iter_start(cgroup, &it);\r\nwhile ((task = cgroup_iter_next(cgroup, &it))) {\r\nif (freezing(task)) {\r\nif (!frozen(task) && !freezer_should_skip(task))\r\ngoto out_iter_end;\r\n}\r\n}\r\nfreezer->state |= CGROUP_FROZEN;\r\nout_iter_end:\r\ncgroup_iter_end(cgroup, &it);\r\nout_unlock:\r\nspin_unlock_irq(&freezer->lock);\r\n}\r\nstatic int freezer_read(struct cgroup *cgroup, struct cftype *cft,\r\nstruct seq_file *m)\r\n{\r\nstruct cgroup *pos;\r\nrcu_read_lock();\r\ncgroup_for_each_descendant_post(pos, cgroup)\r\nupdate_if_frozen(pos);\r\nupdate_if_frozen(cgroup);\r\nrcu_read_unlock();\r\nseq_puts(m, freezer_state_strs(cgroup_freezer(cgroup)->state));\r\nseq_putc(m, '\n');\r\nreturn 0;\r\n}\r\nstatic void freeze_cgroup(struct freezer *freezer)\r\n{\r\nstruct cgroup *cgroup = freezer->css.cgroup;\r\nstruct cgroup_iter it;\r\nstruct task_struct *task;\r\ncgroup_iter_start(cgroup, &it);\r\nwhile ((task = cgroup_iter_next(cgroup, &it)))\r\nfreeze_task(task);\r\ncgroup_iter_end(cgroup, &it);\r\n}\r\nstatic void unfreeze_cgroup(struct freezer *freezer)\r\n{\r\nstruct cgroup *cgroup = freezer->css.cgroup;\r\nstruct cgroup_iter it;\r\nstruct task_struct *task;\r\ncgroup_iter_start(cgroup, &it);\r\nwhile ((task = cgroup_iter_next(cgroup, &it)))\r\n__thaw_task(task);\r\ncgroup_iter_end(cgroup, &it);\r\n}\r\nstatic void freezer_apply_state(struct freezer *freezer, bool freeze,\r\nunsigned int state)\r\n{\r\nlockdep_assert_held(&freezer->lock);\r\nif (!(freezer->state & CGROUP_FREEZER_ONLINE))\r\nreturn;\r\nif (freeze) {\r\nif (!(freezer->state & CGROUP_FREEZING))\r\natomic_inc(&system_freezing_cnt);\r\nfreezer->state |= state;\r\nfreeze_cgroup(freezer);\r\n} else {\r\nbool was_freezing = freezer->state & CGROUP_FREEZING;\r\nfreezer->state &= ~state;\r\nif (!(freezer->state & CGROUP_FREEZING)) {\r\nif (was_freezing)\r\natomic_dec(&system_freezing_cnt);\r\nfreezer->state &= ~CGROUP_FROZEN;\r\nunfreeze_cgroup(freezer);\r\n}\r\n}\r\n}\r\nstatic void freezer_change_state(struct freezer *freezer, bool freeze)\r\n{\r\nstruct cgroup *pos;\r\nspin_lock_irq(&freezer->lock);\r\nfreezer_apply_state(freezer, freeze, CGROUP_FREEZING_SELF);\r\nspin_unlock_irq(&freezer->lock);\r\nrcu_read_lock();\r\ncgroup_for_each_descendant_pre(pos, freezer->css.cgroup) {\r\nstruct freezer *pos_f = cgroup_freezer(pos);\r\nstruct freezer *parent = parent_freezer(pos_f);\r\nspin_lock_irq(&pos_f->lock);\r\nfreezer_apply_state(pos_f, parent->state & CGROUP_FREEZING,\r\nCGROUP_FREEZING_PARENT);\r\nspin_unlock_irq(&pos_f->lock);\r\n}\r\nrcu_read_unlock();\r\n}\r\nstatic int freezer_write(struct cgroup *cgroup, struct cftype *cft,\r\nconst char *buffer)\r\n{\r\nbool freeze;\r\nif (strcmp(buffer, freezer_state_strs(0)) == 0)\r\nfreeze = false;\r\nelse if (strcmp(buffer, freezer_state_strs(CGROUP_FROZEN)) == 0)\r\nfreeze = true;\r\nelse\r\nreturn -EINVAL;\r\nfreezer_change_state(cgroup_freezer(cgroup), freeze);\r\nreturn 0;\r\n}\r\nstatic u64 freezer_self_freezing_read(struct cgroup *cgroup, struct cftype *cft)\r\n{\r\nstruct freezer *freezer = cgroup_freezer(cgroup);\r\nreturn (bool)(freezer->state & CGROUP_FREEZING_SELF);\r\n}\r\nstatic u64 freezer_parent_freezing_read(struct cgroup *cgroup, struct cftype *cft)\r\n{\r\nstruct freezer *freezer = cgroup_freezer(cgroup);\r\nreturn (bool)(freezer->state & CGROUP_FREEZING_PARENT);\r\n}
