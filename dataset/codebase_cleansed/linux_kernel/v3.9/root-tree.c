void btrfs_read_root_item(struct btrfs_root *root,\r\nstruct extent_buffer *eb, int slot,\r\nstruct btrfs_root_item *item)\r\n{\r\nuuid_le uuid;\r\nint len;\r\nint need_reset = 0;\r\nlen = btrfs_item_size_nr(eb, slot);\r\nread_extent_buffer(eb, item, btrfs_item_ptr_offset(eb, slot),\r\nmin_t(int, len, (int)sizeof(*item)));\r\nif (len < sizeof(*item))\r\nneed_reset = 1;\r\nif (!need_reset && btrfs_root_generation(item)\r\n!= btrfs_root_generation_v2(item)) {\r\nif (btrfs_root_generation_v2(item) != 0) {\r\nprintk(KERN_WARNING "btrfs: mismatching "\r\n"generation and generation_v2 "\r\n"found in root item. This root "\r\n"was probably mounted with an "\r\n"older kernel. Resetting all "\r\n"new fields.\n");\r\n}\r\nneed_reset = 1;\r\n}\r\nif (need_reset) {\r\nmemset(&item->generation_v2, 0,\r\nsizeof(*item) - offsetof(struct btrfs_root_item,\r\ngeneration_v2));\r\nuuid_le_gen(&uuid);\r\nmemcpy(item->uuid, uuid.b, BTRFS_UUID_SIZE);\r\n}\r\n}\r\nint btrfs_find_last_root(struct btrfs_root *root, u64 objectid,\r\nstruct btrfs_root_item *item, struct btrfs_key *key)\r\n{\r\nstruct btrfs_path *path;\r\nstruct btrfs_key search_key;\r\nstruct btrfs_key found_key;\r\nstruct extent_buffer *l;\r\nint ret;\r\nint slot;\r\nsearch_key.objectid = objectid;\r\nsearch_key.type = BTRFS_ROOT_ITEM_KEY;\r\nsearch_key.offset = (u64)-1;\r\npath = btrfs_alloc_path();\r\nif (!path)\r\nreturn -ENOMEM;\r\nret = btrfs_search_slot(NULL, root, &search_key, path, 0, 0);\r\nif (ret < 0)\r\ngoto out;\r\nBUG_ON(ret == 0);\r\nif (path->slots[0] == 0) {\r\nret = 1;\r\ngoto out;\r\n}\r\nl = path->nodes[0];\r\nslot = path->slots[0] - 1;\r\nbtrfs_item_key_to_cpu(l, &found_key, slot);\r\nif (found_key.objectid != objectid ||\r\nfound_key.type != BTRFS_ROOT_ITEM_KEY) {\r\nret = 1;\r\ngoto out;\r\n}\r\nif (item)\r\nbtrfs_read_root_item(root, l, slot, item);\r\nif (key)\r\nmemcpy(key, &found_key, sizeof(found_key));\r\nret = 0;\r\nout:\r\nbtrfs_free_path(path);\r\nreturn ret;\r\n}\r\nvoid btrfs_set_root_node(struct btrfs_root_item *item,\r\nstruct extent_buffer *node)\r\n{\r\nbtrfs_set_root_bytenr(item, node->start);\r\nbtrfs_set_root_level(item, btrfs_header_level(node));\r\nbtrfs_set_root_generation(item, btrfs_header_generation(node));\r\n}\r\nint btrfs_update_root(struct btrfs_trans_handle *trans, struct btrfs_root\r\n*root, struct btrfs_key *key, struct btrfs_root_item\r\n*item)\r\n{\r\nstruct btrfs_path *path;\r\nstruct extent_buffer *l;\r\nint ret;\r\nint slot;\r\nunsigned long ptr;\r\nint old_len;\r\npath = btrfs_alloc_path();\r\nif (!path)\r\nreturn -ENOMEM;\r\nret = btrfs_search_slot(trans, root, key, path, 0, 1);\r\nif (ret < 0) {\r\nbtrfs_abort_transaction(trans, root, ret);\r\ngoto out;\r\n}\r\nif (ret != 0) {\r\nbtrfs_print_leaf(root, path->nodes[0]);\r\nprintk(KERN_CRIT "unable to update root key %llu %u %llu\n",\r\n(unsigned long long)key->objectid, key->type,\r\n(unsigned long long)key->offset);\r\nBUG_ON(1);\r\n}\r\nl = path->nodes[0];\r\nslot = path->slots[0];\r\nptr = btrfs_item_ptr_offset(l, slot);\r\nold_len = btrfs_item_size_nr(l, slot);\r\nif (old_len < sizeof(*item)) {\r\nbtrfs_release_path(path);\r\nret = btrfs_search_slot(trans, root, key, path,\r\n-1, 1);\r\nif (ret < 0) {\r\nbtrfs_abort_transaction(trans, root, ret);\r\ngoto out;\r\n}\r\nret = btrfs_del_item(trans, root, path);\r\nif (ret < 0) {\r\nbtrfs_abort_transaction(trans, root, ret);\r\ngoto out;\r\n}\r\nbtrfs_release_path(path);\r\nret = btrfs_insert_empty_item(trans, root, path,\r\nkey, sizeof(*item));\r\nif (ret < 0) {\r\nbtrfs_abort_transaction(trans, root, ret);\r\ngoto out;\r\n}\r\nl = path->nodes[0];\r\nslot = path->slots[0];\r\nptr = btrfs_item_ptr_offset(l, slot);\r\n}\r\nbtrfs_set_root_generation_v2(item, btrfs_root_generation(item));\r\nwrite_extent_buffer(l, item, ptr, sizeof(*item));\r\nbtrfs_mark_buffer_dirty(path->nodes[0]);\r\nout:\r\nbtrfs_free_path(path);\r\nreturn ret;\r\n}\r\nint btrfs_insert_root(struct btrfs_trans_handle *trans, struct btrfs_root *root,\r\nstruct btrfs_key *key, struct btrfs_root_item *item)\r\n{\r\nbtrfs_set_root_generation_v2(item, btrfs_root_generation(item));\r\nreturn btrfs_insert_item(trans, root, key, item, sizeof(*item));\r\n}\r\nint btrfs_find_dead_roots(struct btrfs_root *root, u64 objectid)\r\n{\r\nstruct btrfs_root *dead_root;\r\nstruct btrfs_root_item *ri;\r\nstruct btrfs_key key;\r\nstruct btrfs_key found_key;\r\nstruct btrfs_path *path;\r\nint ret;\r\nu32 nritems;\r\nstruct extent_buffer *leaf;\r\nint slot;\r\nkey.objectid = objectid;\r\nbtrfs_set_key_type(&key, BTRFS_ROOT_ITEM_KEY);\r\nkey.offset = 0;\r\npath = btrfs_alloc_path();\r\nif (!path)\r\nreturn -ENOMEM;\r\nagain:\r\nret = btrfs_search_slot(NULL, root, &key, path, 0, 0);\r\nif (ret < 0)\r\ngoto err;\r\nwhile (1) {\r\nleaf = path->nodes[0];\r\nnritems = btrfs_header_nritems(leaf);\r\nslot = path->slots[0];\r\nif (slot >= nritems) {\r\nret = btrfs_next_leaf(root, path);\r\nif (ret)\r\nbreak;\r\nleaf = path->nodes[0];\r\nnritems = btrfs_header_nritems(leaf);\r\nslot = path->slots[0];\r\n}\r\nbtrfs_item_key_to_cpu(leaf, &key, slot);\r\nif (btrfs_key_type(&key) != BTRFS_ROOT_ITEM_KEY)\r\ngoto next;\r\nif (key.objectid < objectid)\r\ngoto next;\r\nif (key.objectid > objectid)\r\nbreak;\r\nri = btrfs_item_ptr(leaf, slot, struct btrfs_root_item);\r\nif (btrfs_disk_root_refs(leaf, ri) != 0)\r\ngoto next;\r\nmemcpy(&found_key, &key, sizeof(key));\r\nkey.offset++;\r\nbtrfs_release_path(path);\r\ndead_root =\r\nbtrfs_read_fs_root_no_radix(root->fs_info->tree_root,\r\n&found_key);\r\nif (IS_ERR(dead_root)) {\r\nret = PTR_ERR(dead_root);\r\ngoto err;\r\n}\r\nret = btrfs_add_dead_root(dead_root);\r\nif (ret)\r\ngoto err;\r\ngoto again;\r\nnext:\r\nslot++;\r\npath->slots[0]++;\r\n}\r\nret = 0;\r\nerr:\r\nbtrfs_free_path(path);\r\nreturn ret;\r\n}\r\nint btrfs_find_orphan_roots(struct btrfs_root *tree_root)\r\n{\r\nstruct extent_buffer *leaf;\r\nstruct btrfs_path *path;\r\nstruct btrfs_key key;\r\nstruct btrfs_key root_key;\r\nstruct btrfs_root *root;\r\nint err = 0;\r\nint ret;\r\npath = btrfs_alloc_path();\r\nif (!path)\r\nreturn -ENOMEM;\r\nkey.objectid = BTRFS_ORPHAN_OBJECTID;\r\nkey.type = BTRFS_ORPHAN_ITEM_KEY;\r\nkey.offset = 0;\r\nroot_key.type = BTRFS_ROOT_ITEM_KEY;\r\nroot_key.offset = (u64)-1;\r\nwhile (1) {\r\nret = btrfs_search_slot(NULL, tree_root, &key, path, 0, 0);\r\nif (ret < 0) {\r\nerr = ret;\r\nbreak;\r\n}\r\nleaf = path->nodes[0];\r\nif (path->slots[0] >= btrfs_header_nritems(leaf)) {\r\nret = btrfs_next_leaf(tree_root, path);\r\nif (ret < 0)\r\nerr = ret;\r\nif (ret != 0)\r\nbreak;\r\nleaf = path->nodes[0];\r\n}\r\nbtrfs_item_key_to_cpu(leaf, &key, path->slots[0]);\r\nbtrfs_release_path(path);\r\nif (key.objectid != BTRFS_ORPHAN_OBJECTID ||\r\nkey.type != BTRFS_ORPHAN_ITEM_KEY)\r\nbreak;\r\nroot_key.objectid = key.offset;\r\nkey.offset++;\r\nroot = btrfs_read_fs_root_no_name(tree_root->fs_info,\r\n&root_key);\r\nif (!IS_ERR(root))\r\ncontinue;\r\nret = PTR_ERR(root);\r\nif (ret != -ENOENT) {\r\nerr = ret;\r\nbreak;\r\n}\r\nret = btrfs_find_dead_roots(tree_root, root_key.objectid);\r\nif (ret) {\r\nerr = ret;\r\nbreak;\r\n}\r\n}\r\nbtrfs_free_path(path);\r\nreturn err;\r\n}\r\nint btrfs_del_root(struct btrfs_trans_handle *trans, struct btrfs_root *root,\r\nstruct btrfs_key *key)\r\n{\r\nstruct btrfs_path *path;\r\nint ret;\r\nstruct btrfs_root_item *ri;\r\nstruct extent_buffer *leaf;\r\npath = btrfs_alloc_path();\r\nif (!path)\r\nreturn -ENOMEM;\r\nret = btrfs_search_slot(trans, root, key, path, -1, 1);\r\nif (ret < 0)\r\ngoto out;\r\nBUG_ON(ret != 0);\r\nleaf = path->nodes[0];\r\nri = btrfs_item_ptr(leaf, path->slots[0], struct btrfs_root_item);\r\nret = btrfs_del_item(trans, root, path);\r\nout:\r\nbtrfs_free_path(path);\r\nreturn ret;\r\n}\r\nint btrfs_del_root_ref(struct btrfs_trans_handle *trans,\r\nstruct btrfs_root *tree_root,\r\nu64 root_id, u64 ref_id, u64 dirid, u64 *sequence,\r\nconst char *name, int name_len)\r\n{\r\nstruct btrfs_path *path;\r\nstruct btrfs_root_ref *ref;\r\nstruct extent_buffer *leaf;\r\nstruct btrfs_key key;\r\nunsigned long ptr;\r\nint err = 0;\r\nint ret;\r\npath = btrfs_alloc_path();\r\nif (!path)\r\nreturn -ENOMEM;\r\nkey.objectid = root_id;\r\nkey.type = BTRFS_ROOT_BACKREF_KEY;\r\nkey.offset = ref_id;\r\nagain:\r\nret = btrfs_search_slot(trans, tree_root, &key, path, -1, 1);\r\nBUG_ON(ret < 0);\r\nif (ret == 0) {\r\nleaf = path->nodes[0];\r\nref = btrfs_item_ptr(leaf, path->slots[0],\r\nstruct btrfs_root_ref);\r\nWARN_ON(btrfs_root_ref_dirid(leaf, ref) != dirid);\r\nWARN_ON(btrfs_root_ref_name_len(leaf, ref) != name_len);\r\nptr = (unsigned long)(ref + 1);\r\nWARN_ON(memcmp_extent_buffer(leaf, name, ptr, name_len));\r\n*sequence = btrfs_root_ref_sequence(leaf, ref);\r\nret = btrfs_del_item(trans, tree_root, path);\r\nif (ret) {\r\nerr = ret;\r\ngoto out;\r\n}\r\n} else\r\nerr = -ENOENT;\r\nif (key.type == BTRFS_ROOT_BACKREF_KEY) {\r\nbtrfs_release_path(path);\r\nkey.objectid = ref_id;\r\nkey.type = BTRFS_ROOT_REF_KEY;\r\nkey.offset = root_id;\r\ngoto again;\r\n}\r\nout:\r\nbtrfs_free_path(path);\r\nreturn err;\r\n}\r\nint btrfs_find_root_ref(struct btrfs_root *tree_root,\r\nstruct btrfs_path *path,\r\nu64 root_id, u64 ref_id)\r\n{\r\nstruct btrfs_key key;\r\nint ret;\r\nkey.objectid = root_id;\r\nkey.type = BTRFS_ROOT_REF_KEY;\r\nkey.offset = ref_id;\r\nret = btrfs_search_slot(NULL, tree_root, &key, path, 0, 0);\r\nreturn ret;\r\n}\r\nint btrfs_add_root_ref(struct btrfs_trans_handle *trans,\r\nstruct btrfs_root *tree_root,\r\nu64 root_id, u64 ref_id, u64 dirid, u64 sequence,\r\nconst char *name, int name_len)\r\n{\r\nstruct btrfs_key key;\r\nint ret;\r\nstruct btrfs_path *path;\r\nstruct btrfs_root_ref *ref;\r\nstruct extent_buffer *leaf;\r\nunsigned long ptr;\r\npath = btrfs_alloc_path();\r\nif (!path)\r\nreturn -ENOMEM;\r\nkey.objectid = root_id;\r\nkey.type = BTRFS_ROOT_BACKREF_KEY;\r\nkey.offset = ref_id;\r\nagain:\r\nret = btrfs_insert_empty_item(trans, tree_root, path, &key,\r\nsizeof(*ref) + name_len);\r\nif (ret) {\r\nbtrfs_abort_transaction(trans, tree_root, ret);\r\nbtrfs_free_path(path);\r\nreturn ret;\r\n}\r\nleaf = path->nodes[0];\r\nref = btrfs_item_ptr(leaf, path->slots[0], struct btrfs_root_ref);\r\nbtrfs_set_root_ref_dirid(leaf, ref, dirid);\r\nbtrfs_set_root_ref_sequence(leaf, ref, sequence);\r\nbtrfs_set_root_ref_name_len(leaf, ref, name_len);\r\nptr = (unsigned long)(ref + 1);\r\nwrite_extent_buffer(leaf, name, ptr, name_len);\r\nbtrfs_mark_buffer_dirty(leaf);\r\nif (key.type == BTRFS_ROOT_BACKREF_KEY) {\r\nbtrfs_release_path(path);\r\nkey.objectid = ref_id;\r\nkey.type = BTRFS_ROOT_REF_KEY;\r\nkey.offset = root_id;\r\ngoto again;\r\n}\r\nbtrfs_free_path(path);\r\nreturn 0;\r\n}\r\nvoid btrfs_check_and_init_root_item(struct btrfs_root_item *root_item)\r\n{\r\nu64 inode_flags = le64_to_cpu(root_item->inode.flags);\r\nif (!(inode_flags & BTRFS_INODE_ROOT_ITEM_INIT)) {\r\ninode_flags |= BTRFS_INODE_ROOT_ITEM_INIT;\r\nroot_item->inode.flags = cpu_to_le64(inode_flags);\r\nroot_item->flags = 0;\r\nroot_item->byte_limit = 0;\r\n}\r\n}\r\nvoid btrfs_update_root_times(struct btrfs_trans_handle *trans,\r\nstruct btrfs_root *root)\r\n{\r\nstruct btrfs_root_item *item = &root->root_item;\r\nstruct timespec ct = CURRENT_TIME;\r\nspin_lock(&root->root_item_lock);\r\nitem->ctransid = cpu_to_le64(trans->transid);\r\nitem->ctime.sec = cpu_to_le64(ct.tv_sec);\r\nitem->ctime.nsec = cpu_to_le32(ct.tv_nsec);\r\nspin_unlock(&root->root_item_lock);\r\n}
