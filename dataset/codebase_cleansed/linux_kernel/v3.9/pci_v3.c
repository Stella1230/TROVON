static void __iomem *v3_open_config_window(struct pci_bus *bus,\r\nunsigned int devfn, int offset)\r\n{\r\nunsigned int address, mapaddress, busnr;\r\nbusnr = bus->number;\r\nBUG_ON(offset > 255);\r\nBUG_ON(busnr > 255);\r\nBUG_ON(devfn > 255);\r\nif (busnr == 0) {\r\nint slot = PCI_SLOT(devfn);\r\naddress = PCI_FUNC(devfn) << 8;\r\nmapaddress = V3_LB_MAP_TYPE_CONFIG;\r\nif (slot > 12)\r\nmapaddress |= 1 << (slot - 5);\r\nelse\r\naddress |= 1 << (slot + 11);\r\n} else {\r\nmapaddress = V3_LB_MAP_TYPE_CONFIG | V3_LB_MAP_AD_LOW_EN;\r\naddress = (busnr << 16) | (devfn << 8);\r\n}\r\nv3_writel(V3_LB_BASE0, v3_addr_to_lb_base(PHYS_PCI_MEM_BASE) |\r\nV3_LB_BASE_ADR_SIZE_512MB | V3_LB_BASE_ENABLE);\r\nv3_writel(V3_LB_BASE1, v3_addr_to_lb_base(PHYS_PCI_CONFIG_BASE) |\r\nV3_LB_BASE_ADR_SIZE_16MB | V3_LB_BASE_ENABLE);\r\nv3_writew(V3_LB_MAP1, mapaddress);\r\nreturn PCI_CONFIG_VADDR + address + offset;\r\n}\r\nstatic void v3_close_config_window(void)\r\n{\r\nv3_writel(V3_LB_BASE1, v3_addr_to_lb_base(PHYS_PCI_MEM_BASE + SZ_256M) |\r\nV3_LB_BASE_ADR_SIZE_256MB | V3_LB_BASE_PREFETCH |\r\nV3_LB_BASE_ENABLE);\r\nv3_writew(V3_LB_MAP1, v3_addr_to_lb_map(PCI_BUS_PREMEM_START) |\r\nV3_LB_MAP_TYPE_MEM_MULTIPLE);\r\nv3_writel(V3_LB_BASE0, v3_addr_to_lb_base(PHYS_PCI_MEM_BASE) |\r\nV3_LB_BASE_ADR_SIZE_256MB | V3_LB_BASE_ENABLE);\r\n}\r\nstatic int v3_read_config(struct pci_bus *bus, unsigned int devfn, int where,\r\nint size, u32 *val)\r\n{\r\nvoid __iomem *addr;\r\nunsigned long flags;\r\nu32 v;\r\nraw_spin_lock_irqsave(&v3_lock, flags);\r\naddr = v3_open_config_window(bus, devfn, where);\r\nswitch (size) {\r\ncase 1:\r\nv = __raw_readb(addr);\r\nbreak;\r\ncase 2:\r\nv = __raw_readw(addr);\r\nbreak;\r\ndefault:\r\nv = __raw_readl(addr);\r\nbreak;\r\n}\r\nv3_close_config_window();\r\nraw_spin_unlock_irqrestore(&v3_lock, flags);\r\n*val = v;\r\nreturn PCIBIOS_SUCCESSFUL;\r\n}\r\nstatic int v3_write_config(struct pci_bus *bus, unsigned int devfn, int where,\r\nint size, u32 val)\r\n{\r\nvoid __iomem *addr;\r\nunsigned long flags;\r\nraw_spin_lock_irqsave(&v3_lock, flags);\r\naddr = v3_open_config_window(bus, devfn, where);\r\nswitch (size) {\r\ncase 1:\r\n__raw_writeb((u8)val, addr);\r\n__raw_readb(addr);\r\nbreak;\r\ncase 2:\r\n__raw_writew((u16)val, addr);\r\n__raw_readw(addr);\r\nbreak;\r\ncase 4:\r\n__raw_writel(val, addr);\r\n__raw_readl(addr);\r\nbreak;\r\n}\r\nv3_close_config_window();\r\nraw_spin_unlock_irqrestore(&v3_lock, flags);\r\nreturn PCIBIOS_SUCCESSFUL;\r\n}\r\nstatic int __init pci_v3_setup_resources(struct pci_sys_data *sys)\r\n{\r\nif (request_resource(&iomem_resource, &non_mem)) {\r\nprintk(KERN_ERR "PCI: unable to allocate non-prefetchable "\r\n"memory region\n");\r\nreturn -EBUSY;\r\n}\r\nif (request_resource(&iomem_resource, &pre_mem)) {\r\nrelease_resource(&non_mem);\r\nprintk(KERN_ERR "PCI: unable to allocate prefetchable "\r\n"memory region\n");\r\nreturn -EBUSY;\r\n}\r\npci_add_resource_offset(&sys->resources, &non_mem, sys->mem_offset);\r\npci_add_resource_offset(&sys->resources, &pre_mem, sys->mem_offset);\r\nreturn 1;\r\n}\r\nstatic int\r\nv3_pci_fault(unsigned long addr, unsigned int fsr, struct pt_regs *regs)\r\n{\r\nunsigned long pc = instruction_pointer(regs);\r\nunsigned long instr = *(unsigned long *)pc;\r\n#if 0\r\nchar buf[128];\r\nsprintf(buf, "V3 fault: addr 0x%08lx, FSR 0x%03x, PC 0x%08lx [%08lx] LBFADDR=%08x LBFCODE=%02x ISTAT=%02x\n",\r\naddr, fsr, pc, instr, __raw_readl(ap_syscon_base + INTEGRATOR_SC_LBFADDR_OFFSET), __raw_readl(ap_syscon_base + INTEGRATOR_SC_LBFCODE_OFFSET) & 255,\r\nv3_readb(V3_LB_ISTAT));\r\nprintk(KERN_DEBUG "%s", buf);\r\n#endif\r\nv3_writeb(V3_LB_ISTAT, 0);\r\n__raw_writel(3, ap_syscon_base + INTEGRATOR_SC_PCIENABLE_OFFSET);\r\nif ((instr & 0x0c100000) == 0x04100000) {\r\nint reg = (instr >> 12) & 15;\r\nunsigned long val;\r\nif (instr & 0x00400000)\r\nval = 255;\r\nelse\r\nval = -1;\r\nregs->uregs[reg] = val;\r\nregs->ARM_pc += 4;\r\nreturn 0;\r\n}\r\nif ((instr & 0x0e100090) == 0x00100090) {\r\nint reg = (instr >> 12) & 15;\r\nregs->uregs[reg] = -1;\r\nregs->ARM_pc += 4;\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nstatic irqreturn_t v3_irq(int dummy, void *devid)\r\n{\r\n#ifdef CONFIG_DEBUG_LL\r\nstruct pt_regs *regs = get_irq_regs();\r\nunsigned long pc = instruction_pointer(regs);\r\nunsigned long instr = *(unsigned long *)pc;\r\nchar buf[128];\r\nextern void printascii(const char *);\r\nsprintf(buf, "V3 int %d: pc=0x%08lx [%08lx] LBFADDR=%08x LBFCODE=%02x "\r\n"ISTAT=%02x\n", IRQ_AP_V3INT, pc, instr,\r\n__raw_readl(ap_syscon_base + INTEGRATOR_SC_LBFADDR_OFFSET),\r\n__raw_readl(ap_syscon_base + INTEGRATOR_SC_LBFCODE_OFFSET) & 255,\r\nv3_readb(V3_LB_ISTAT));\r\nprintascii(buf);\r\n#endif\r\nv3_writew(V3_PCI_STAT, 0xf000);\r\nv3_writeb(V3_LB_ISTAT, 0);\r\n__raw_writel(3, ap_syscon_base + INTEGRATOR_SC_PCIENABLE_OFFSET);\r\n#ifdef CONFIG_DEBUG_LL\r\nif ((instr & 0x0c100000) == 0x04100000) {\r\nint reg = (instr >> 16) & 15;\r\nsprintf(buf, " reg%d = %08lx\n", reg, regs->uregs[reg]);\r\nprintascii(buf);\r\n}\r\n#endif\r\nreturn IRQ_HANDLED;\r\n}\r\nint __init pci_v3_setup(int nr, struct pci_sys_data *sys)\r\n{\r\nint ret = 0;\r\nif (!ap_syscon_base)\r\nreturn -EINVAL;\r\nif (nr == 0) {\r\nsys->mem_offset = PHYS_PCI_MEM_BASE;\r\nret = pci_v3_setup_resources(sys);\r\n}\r\nreturn ret;\r\n}\r\nvoid __init pci_v3_preinit(void)\r\n{\r\nunsigned long flags;\r\nunsigned int temp;\r\nint ret;\r\nap_syscon_base = ioremap(INTEGRATOR_SC_BASE, 0x100);\r\nif (!ap_syscon_base) {\r\npr_err("unable to remap the AP syscon for PCIv3\n");\r\nreturn;\r\n}\r\npcibios_min_mem = 0x00100000;\r\nhook_fault_code(4, v3_pci_fault, SIGBUS, 0, "external abort on linefetch");\r\nhook_fault_code(6, v3_pci_fault, SIGBUS, 0, "external abort on linefetch");\r\nhook_fault_code(8, v3_pci_fault, SIGBUS, 0, "external abort on non-linefetch");\r\nhook_fault_code(10, v3_pci_fault, SIGBUS, 0, "external abort on non-linefetch");\r\nraw_spin_lock_irqsave(&v3_lock, flags);\r\nif (v3_readw(V3_SYSTEM) & V3_SYSTEM_M_LOCK)\r\nv3_writew(V3_SYSTEM, 0xa05f);\r\nv3_writel(V3_LB_BASE0, v3_addr_to_lb_base(PHYS_PCI_MEM_BASE) |\r\nV3_LB_BASE_ADR_SIZE_256MB | V3_LB_BASE_ENABLE);\r\nv3_writew(V3_LB_MAP0, v3_addr_to_lb_map(PCI_BUS_NONMEM_START) |\r\nV3_LB_MAP_TYPE_MEM);\r\nv3_writel(V3_LB_BASE1, v3_addr_to_lb_base(PHYS_PCI_MEM_BASE + SZ_256M) |\r\nV3_LB_BASE_ADR_SIZE_256MB | V3_LB_BASE_PREFETCH |\r\nV3_LB_BASE_ENABLE);\r\nv3_writew(V3_LB_MAP1, v3_addr_to_lb_map(PCI_BUS_PREMEM_START) |\r\nV3_LB_MAP_TYPE_MEM_MULTIPLE);\r\nv3_writel(V3_LB_BASE2, v3_addr_to_lb_base2(PHYS_PCI_IO_BASE) |\r\nV3_LB_BASE_ENABLE);\r\nv3_writew(V3_LB_MAP2, v3_addr_to_lb_map2(0));\r\ntemp = v3_readw(V3_PCI_CFG) & ~V3_PCI_CFG_M_I2O_EN;\r\ntemp |= V3_PCI_CFG_M_IO_REG_DIS | V3_PCI_CFG_M_IO_DIS;\r\nv3_writew(V3_PCI_CFG, temp);\r\nprintk(KERN_DEBUG "FIFO_CFG: %04x FIFO_PRIO: %04x\n",\r\nv3_readw(V3_FIFO_CFG), v3_readw(V3_FIFO_PRIORITY));\r\nv3_writew(V3_FIFO_PRIORITY, 0x0a0a);\r\ntemp = v3_readw(V3_SYSTEM) | V3_SYSTEM_M_LOCK;\r\nv3_writew(V3_SYSTEM, temp);\r\nv3_writeb(V3_LB_ISTAT, 0);\r\nv3_writew(V3_LB_CFG, v3_readw(V3_LB_CFG) | (1 << 10));\r\nv3_writeb(V3_LB_IMASK, 0x28);\r\n__raw_writel(3, ap_syscon_base + INTEGRATOR_SC_PCIENABLE_OFFSET);\r\nret = request_irq(IRQ_AP_V3INT, v3_irq, 0, "V3", NULL);\r\nif (ret)\r\nprintk(KERN_ERR "PCI: unable to grab PCI error "\r\n"interrupt: %d\n", ret);\r\nraw_spin_unlock_irqrestore(&v3_lock, flags);\r\n}\r\nvoid __init pci_v3_postinit(void)\r\n{\r\nunsigned int pci_cmd;\r\npci_cmd = PCI_COMMAND_MEMORY |\r\nPCI_COMMAND_MASTER | PCI_COMMAND_INVALIDATE;\r\nv3_writew(V3_PCI_CMD, pci_cmd);\r\nv3_writeb(V3_LB_ISTAT, ~0x40);\r\nv3_writeb(V3_LB_IMASK, 0x68);\r\n#if 0\r\nret = request_irq(IRQ_AP_LBUSTIMEOUT, lb_timeout, 0, "bus timeout", NULL);\r\nif (ret)\r\nprintk(KERN_ERR "PCI: unable to grab local bus timeout "\r\n"interrupt: %d\n", ret);\r\n#endif\r\nregister_isa_ports(PHYS_PCI_MEM_BASE, PHYS_PCI_IO_BASE, 0);\r\n}
