static int plat_nand_probe(struct platform_device *pdev)\r\n{\r\nstruct platform_nand_data *pdata = pdev->dev.platform_data;\r\nstruct mtd_part_parser_data ppdata;\r\nstruct plat_nand_data *data;\r\nstruct resource *res;\r\nconst char **part_types;\r\nint err = 0;\r\nif (!pdata) {\r\ndev_err(&pdev->dev, "platform_nand_data is missing\n");\r\nreturn -EINVAL;\r\n}\r\nif (pdata->chip.nr_chips < 1) {\r\ndev_err(&pdev->dev, "invalid number of chips specified\n");\r\nreturn -EINVAL;\r\n}\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!res)\r\nreturn -ENXIO;\r\ndata = kzalloc(sizeof(struct plat_nand_data), GFP_KERNEL);\r\nif (!data) {\r\ndev_err(&pdev->dev, "failed to allocate device structure.\n");\r\nreturn -ENOMEM;\r\n}\r\nif (!request_mem_region(res->start, resource_size(res),\r\ndev_name(&pdev->dev))) {\r\ndev_err(&pdev->dev, "request_mem_region failed\n");\r\nerr = -EBUSY;\r\ngoto out_free;\r\n}\r\ndata->io_base = ioremap(res->start, resource_size(res));\r\nif (data->io_base == NULL) {\r\ndev_err(&pdev->dev, "ioremap failed\n");\r\nerr = -EIO;\r\ngoto out_release_io;\r\n}\r\ndata->chip.priv = &data;\r\ndata->mtd.priv = &data->chip;\r\ndata->mtd.owner = THIS_MODULE;\r\ndata->mtd.name = dev_name(&pdev->dev);\r\ndata->chip.IO_ADDR_R = data->io_base;\r\ndata->chip.IO_ADDR_W = data->io_base;\r\ndata->chip.cmd_ctrl = pdata->ctrl.cmd_ctrl;\r\ndata->chip.dev_ready = pdata->ctrl.dev_ready;\r\ndata->chip.select_chip = pdata->ctrl.select_chip;\r\ndata->chip.write_buf = pdata->ctrl.write_buf;\r\ndata->chip.read_buf = pdata->ctrl.read_buf;\r\ndata->chip.read_byte = pdata->ctrl.read_byte;\r\ndata->chip.chip_delay = pdata->chip.chip_delay;\r\ndata->chip.options |= pdata->chip.options;\r\ndata->chip.bbt_options |= pdata->chip.bbt_options;\r\ndata->chip.ecc.hwctl = pdata->ctrl.hwcontrol;\r\ndata->chip.ecc.layout = pdata->chip.ecclayout;\r\ndata->chip.ecc.mode = NAND_ECC_SOFT;\r\nplatform_set_drvdata(pdev, data);\r\nif (pdata->ctrl.probe) {\r\nerr = pdata->ctrl.probe(pdev);\r\nif (err)\r\ngoto out;\r\n}\r\nif (nand_scan(&data->mtd, pdata->chip.nr_chips)) {\r\nerr = -ENXIO;\r\ngoto out;\r\n}\r\npart_types = pdata->chip.part_probe_types ? : part_probe_types;\r\nppdata.of_node = pdev->dev.of_node;\r\nerr = mtd_device_parse_register(&data->mtd, part_types, &ppdata,\r\npdata->chip.partitions,\r\npdata->chip.nr_partitions);\r\nif (!err)\r\nreturn err;\r\nnand_release(&data->mtd);\r\nout:\r\nif (pdata->ctrl.remove)\r\npdata->ctrl.remove(pdev);\r\nplatform_set_drvdata(pdev, NULL);\r\niounmap(data->io_base);\r\nout_release_io:\r\nrelease_mem_region(res->start, resource_size(res));\r\nout_free:\r\nkfree(data);\r\nreturn err;\r\n}\r\nstatic int plat_nand_remove(struct platform_device *pdev)\r\n{\r\nstruct plat_nand_data *data = platform_get_drvdata(pdev);\r\nstruct platform_nand_data *pdata = pdev->dev.platform_data;\r\nstruct resource *res;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nnand_release(&data->mtd);\r\nif (pdata->ctrl.remove)\r\npdata->ctrl.remove(pdev);\r\niounmap(data->io_base);\r\nrelease_mem_region(res->start, resource_size(res));\r\nkfree(data);\r\nreturn 0;\r\n}
