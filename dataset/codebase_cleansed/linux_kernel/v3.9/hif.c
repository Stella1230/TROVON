static int ath6kl_hif_cp_scat_dma_buf(struct hif_scatter_req *req,\r\nbool from_dma)\r\n{\r\nu8 *buf;\r\nint i;\r\nbuf = req->virt_dma_buf;\r\nfor (i = 0; i < req->scat_entries; i++) {\r\nif (from_dma)\r\nmemcpy(req->scat_list[i].buf, buf,\r\nreq->scat_list[i].len);\r\nelse\r\nmemcpy(buf, req->scat_list[i].buf,\r\nreq->scat_list[i].len);\r\nbuf += req->scat_list[i].len;\r\n}\r\nreturn 0;\r\n}\r\nint ath6kl_hif_rw_comp_handler(void *context, int status)\r\n{\r\nstruct htc_packet *packet = context;\r\nath6kl_dbg(ATH6KL_DBG_HIF, "hif rw completion pkt 0x%p status %d\n",\r\npacket, status);\r\npacket->status = status;\r\npacket->completion(packet->context, packet);\r\nreturn 0;\r\n}\r\nstatic void ath6kl_hif_dump_fw_crash(struct ath6kl *ar)\r\n{\r\n__le32 regdump_val[REGISTER_DUMP_LEN_MAX];\r\nu32 i, address, regdump_addr = 0;\r\nint ret;\r\nif (ar->target_type != TARGET_TYPE_AR6003)\r\nreturn;\r\naddress = ath6kl_get_hi_item_addr(ar, HI_ITEM(hi_failure_state));\r\naddress = TARG_VTOP(ar->target_type, address);\r\nret = ath6kl_diag_read32(ar, address, &regdump_addr);\r\nif (ret || !regdump_addr) {\r\nath6kl_warn("failed to get ptr to register dump area: %d\n",\r\nret);\r\nreturn;\r\n}\r\nath6kl_dbg(ATH6KL_DBG_IRQ, "register dump data address 0x%x\n",\r\nregdump_addr);\r\nregdump_addr = TARG_VTOP(ar->target_type, regdump_addr);\r\nret = ath6kl_diag_read(ar, regdump_addr, (u8 *)&regdump_val[0],\r\nREG_DUMP_COUNT_AR6003 * (sizeof(u32)));\r\nif (ret) {\r\nath6kl_warn("failed to get register dump: %d\n", ret);\r\nreturn;\r\n}\r\nath6kl_info("crash dump:\n");\r\nath6kl_info("hw 0x%x fw %s\n", ar->wiphy->hw_version,\r\nar->wiphy->fw_version);\r\nBUILD_BUG_ON(REG_DUMP_COUNT_AR6003 % 4);\r\nfor (i = 0; i < REG_DUMP_COUNT_AR6003; i += 4) {\r\nath6kl_info("%d: 0x%8.8x 0x%8.8x 0x%8.8x 0x%8.8x\n",\r\ni,\r\nle32_to_cpu(regdump_val[i]),\r\nle32_to_cpu(regdump_val[i + 1]),\r\nle32_to_cpu(regdump_val[i + 2]),\r\nle32_to_cpu(regdump_val[i + 3]));\r\n}\r\n}\r\nstatic int ath6kl_hif_proc_dbg_intr(struct ath6kl_device *dev)\r\n{\r\nu32 dummy;\r\nint ret;\r\nath6kl_warn("firmware crashed\n");\r\nret = hif_read_write_sync(dev->ar, COUNT_DEC_ADDRESS,\r\n(u8 *)&dummy, 4, HIF_RD_SYNC_BYTE_INC);\r\nif (ret)\r\nath6kl_warn("Failed to clear debug interrupt: %d\n", ret);\r\nath6kl_hif_dump_fw_crash(dev->ar);\r\nath6kl_read_fwlogs(dev->ar);\r\nath6kl_recovery_err_notify(dev->ar, ATH6KL_FW_ASSERT);\r\nreturn ret;\r\n}\r\nint ath6kl_hif_poll_mboxmsg_rx(struct ath6kl_device *dev, u32 *lk_ahd,\r\nint timeout)\r\n{\r\nstruct ath6kl_irq_proc_registers *rg;\r\nint status = 0, i;\r\nu8 htc_mbox = 1 << HTC_MAILBOX;\r\nfor (i = timeout / ATH6KL_TIME_QUANTUM; i > 0; i--) {\r\nstatus = hif_read_write_sync(dev->ar, HOST_INT_STATUS_ADDRESS,\r\n(u8 *) &dev->irq_proc_reg,\r\nsizeof(dev->irq_proc_reg),\r\nHIF_RD_SYNC_BYTE_INC);\r\nif (status) {\r\nath6kl_err("failed to read reg table\n");\r\nreturn status;\r\n}\r\nif (dev->irq_proc_reg.host_int_status & htc_mbox) {\r\nif (dev->irq_proc_reg.rx_lkahd_valid &\r\nhtc_mbox) {\r\nrg = &dev->irq_proc_reg;\r\n*lk_ahd =\r\nle32_to_cpu(rg->rx_lkahd[HTC_MAILBOX]);\r\nbreak;\r\n}\r\n}\r\nmdelay(ATH6KL_TIME_QUANTUM);\r\nath6kl_dbg(ATH6KL_DBG_HIF, "hif retry mbox poll try %d\n", i);\r\n}\r\nif (i == 0) {\r\nath6kl_err("timeout waiting for recv message\n");\r\nstatus = -ETIME;\r\nif (dev->irq_proc_reg.counter_int_status &\r\nATH6KL_TARGET_DEBUG_INTR_MASK)\r\nath6kl_hif_proc_dbg_intr(dev);\r\n}\r\nreturn status;\r\n}\r\nint ath6kl_hif_rx_control(struct ath6kl_device *dev, bool enable_rx)\r\n{\r\nstruct ath6kl_irq_enable_reg regs;\r\nint status = 0;\r\nath6kl_dbg(ATH6KL_DBG_HIF, "hif rx %s\n",\r\nenable_rx ? "enable" : "disable");\r\nspin_lock_bh(&dev->lock);\r\nif (enable_rx)\r\ndev->irq_en_reg.int_status_en |=\r\nSM(INT_STATUS_ENABLE_MBOX_DATA, 0x01);\r\nelse\r\ndev->irq_en_reg.int_status_en &=\r\n~SM(INT_STATUS_ENABLE_MBOX_DATA, 0x01);\r\nmemcpy(&regs, &dev->irq_en_reg, sizeof(regs));\r\nspin_unlock_bh(&dev->lock);\r\nstatus = hif_read_write_sync(dev->ar, INT_STATUS_ENABLE_ADDRESS,\r\n&regs.int_status_en,\r\nsizeof(struct ath6kl_irq_enable_reg),\r\nHIF_WR_SYNC_BYTE_INC);\r\nreturn status;\r\n}\r\nint ath6kl_hif_submit_scat_req(struct ath6kl_device *dev,\r\nstruct hif_scatter_req *scat_req, bool read)\r\n{\r\nint status = 0;\r\nif (read) {\r\nscat_req->req = HIF_RD_SYNC_BLOCK_FIX;\r\nscat_req->addr = dev->ar->mbox_info.htc_addr;\r\n} else {\r\nscat_req->req = HIF_WR_ASYNC_BLOCK_INC;\r\nscat_req->addr =\r\n(scat_req->len > HIF_MBOX_WIDTH) ?\r\ndev->ar->mbox_info.htc_ext_addr :\r\ndev->ar->mbox_info.htc_addr;\r\n}\r\nath6kl_dbg(ATH6KL_DBG_HIF,\r\n"hif submit scatter request entries %d len %d mbox 0x%x %s %s\n",\r\nscat_req->scat_entries, scat_req->len,\r\nscat_req->addr, !read ? "async" : "sync",\r\n(read) ? "rd" : "wr");\r\nif (!read && scat_req->virt_scat) {\r\nstatus = ath6kl_hif_cp_scat_dma_buf(scat_req, false);\r\nif (status) {\r\nscat_req->status = status;\r\nscat_req->complete(dev->ar->htc_target, scat_req);\r\nreturn 0;\r\n}\r\n}\r\nstatus = ath6kl_hif_scat_req_rw(dev->ar, scat_req);\r\nif (read) {\r\nscat_req->status = status;\r\nif (!status && scat_req->virt_scat)\r\nscat_req->status =\r\nath6kl_hif_cp_scat_dma_buf(scat_req, true);\r\n}\r\nreturn status;\r\n}\r\nstatic int ath6kl_hif_proc_counter_intr(struct ath6kl_device *dev)\r\n{\r\nu8 counter_int_status;\r\nath6kl_dbg(ATH6KL_DBG_IRQ, "counter interrupt\n");\r\ncounter_int_status = dev->irq_proc_reg.counter_int_status &\r\ndev->irq_en_reg.cntr_int_status_en;\r\nath6kl_dbg(ATH6KL_DBG_IRQ,\r\n"valid interrupt source(s) in COUNTER_INT_STATUS: 0x%x\n",\r\ncounter_int_status);\r\nif (counter_int_status & ATH6KL_TARGET_DEBUG_INTR_MASK)\r\nreturn ath6kl_hif_proc_dbg_intr(dev);\r\nreturn 0;\r\n}\r\nstatic int ath6kl_hif_proc_err_intr(struct ath6kl_device *dev)\r\n{\r\nint status;\r\nu8 error_int_status;\r\nu8 reg_buf[4];\r\nath6kl_dbg(ATH6KL_DBG_IRQ, "error interrupt\n");\r\nerror_int_status = dev->irq_proc_reg.error_int_status & 0x0F;\r\nif (!error_int_status) {\r\nWARN_ON(1);\r\nreturn -EIO;\r\n}\r\nath6kl_dbg(ATH6KL_DBG_IRQ,\r\n"valid interrupt source(s) in ERROR_INT_STATUS: 0x%x\n",\r\nerror_int_status);\r\nif (MS(ERROR_INT_STATUS_WAKEUP, error_int_status))\r\nath6kl_dbg(ATH6KL_DBG_IRQ, "error : wakeup\n");\r\nif (MS(ERROR_INT_STATUS_RX_UNDERFLOW, error_int_status))\r\nath6kl_err("rx underflow\n");\r\nif (MS(ERROR_INT_STATUS_TX_OVERFLOW, error_int_status))\r\nath6kl_err("tx overflow\n");\r\ndev->irq_proc_reg.error_int_status &= ~error_int_status;\r\nreg_buf[0] = error_int_status;\r\nreg_buf[1] = 0;\r\nreg_buf[2] = 0;\r\nreg_buf[3] = 0;\r\nstatus = hif_read_write_sync(dev->ar, ERROR_INT_STATUS_ADDRESS,\r\nreg_buf, 4, HIF_WR_SYNC_BYTE_FIX);\r\nWARN_ON(status);\r\nreturn status;\r\n}\r\nstatic int ath6kl_hif_proc_cpu_intr(struct ath6kl_device *dev)\r\n{\r\nint status;\r\nu8 cpu_int_status;\r\nu8 reg_buf[4];\r\nath6kl_dbg(ATH6KL_DBG_IRQ, "cpu interrupt\n");\r\ncpu_int_status = dev->irq_proc_reg.cpu_int_status &\r\ndev->irq_en_reg.cpu_int_status_en;\r\nif (!cpu_int_status) {\r\nWARN_ON(1);\r\nreturn -EIO;\r\n}\r\nath6kl_dbg(ATH6KL_DBG_IRQ,\r\n"valid interrupt source(s) in CPU_INT_STATUS: 0x%x\n",\r\ncpu_int_status);\r\ndev->irq_proc_reg.cpu_int_status &= ~cpu_int_status;\r\nreg_buf[0] = cpu_int_status;\r\nreg_buf[1] = 0;\r\nreg_buf[2] = 0;\r\nreg_buf[3] = 0;\r\nstatus = hif_read_write_sync(dev->ar, CPU_INT_STATUS_ADDRESS,\r\nreg_buf, 4, HIF_WR_SYNC_BYTE_FIX);\r\nWARN_ON(status);\r\nreturn status;\r\n}\r\nstatic int proc_pending_irqs(struct ath6kl_device *dev, bool *done)\r\n{\r\nstruct ath6kl_irq_proc_registers *rg;\r\nint status = 0;\r\nu8 host_int_status = 0;\r\nu32 lk_ahd = 0;\r\nu8 htc_mbox = 1 << HTC_MAILBOX;\r\nath6kl_dbg(ATH6KL_DBG_IRQ, "proc_pending_irqs: (dev: 0x%p)\n", dev);\r\nif (dev->irq_en_reg.int_status_en) {\r\nstatus = hif_read_write_sync(dev->ar, HOST_INT_STATUS_ADDRESS,\r\n(u8 *) &dev->irq_proc_reg,\r\nsizeof(dev->irq_proc_reg),\r\nHIF_RD_SYNC_BYTE_INC);\r\nif (status)\r\ngoto out;\r\nath6kl_dump_registers(dev, &dev->irq_proc_reg,\r\n&dev->irq_en_reg);\r\nhost_int_status = dev->irq_proc_reg.host_int_status &\r\ndev->irq_en_reg.int_status_en;\r\nif (host_int_status & htc_mbox) {\r\nhost_int_status &= ~htc_mbox;\r\nif (dev->irq_proc_reg.rx_lkahd_valid &\r\nhtc_mbox) {\r\nrg = &dev->irq_proc_reg;\r\nlk_ahd = le32_to_cpu(rg->rx_lkahd[HTC_MAILBOX]);\r\nif (!lk_ahd)\r\nath6kl_err("lookAhead is zero!\n");\r\n}\r\n}\r\n}\r\nif (!host_int_status && !lk_ahd) {\r\n*done = true;\r\ngoto out;\r\n}\r\nif (lk_ahd) {\r\nint fetched = 0;\r\nath6kl_dbg(ATH6KL_DBG_IRQ,\r\n"pending mailbox msg, lk_ahd: 0x%X\n", lk_ahd);\r\nstatus = ath6kl_htc_rxmsg_pending_handler(dev->htc_cnxt,\r\nlk_ahd, &fetched);\r\nif (status)\r\ngoto out;\r\nif (!fetched)\r\ndev->htc_cnxt->chk_irq_status_cnt = 0;\r\n}\r\nath6kl_dbg(ATH6KL_DBG_IRQ,\r\n"valid interrupt source(s) for other interrupts: 0x%x\n",\r\nhost_int_status);\r\nif (MS(HOST_INT_STATUS_CPU, host_int_status)) {\r\nstatus = ath6kl_hif_proc_cpu_intr(dev);\r\nif (status)\r\ngoto out;\r\n}\r\nif (MS(HOST_INT_STATUS_ERROR, host_int_status)) {\r\nstatus = ath6kl_hif_proc_err_intr(dev);\r\nif (status)\r\ngoto out;\r\n}\r\nif (MS(HOST_INT_STATUS_COUNTER, host_int_status))\r\nstatus = ath6kl_hif_proc_counter_intr(dev);\r\nout:\r\nath6kl_dbg(ATH6KL_DBG_IRQ,\r\n"bypassing irq status re-check, forcing done\n");\r\nif (!dev->htc_cnxt->chk_irq_status_cnt)\r\n*done = true;\r\nath6kl_dbg(ATH6KL_DBG_IRQ,\r\n"proc_pending_irqs: (done:%d, status=%d\n", *done, status);\r\nreturn status;\r\n}\r\nint ath6kl_hif_intr_bh_handler(struct ath6kl *ar)\r\n{\r\nstruct ath6kl_device *dev = ar->htc_target->dev;\r\nunsigned long timeout;\r\nint status = 0;\r\nbool done = false;\r\ndev->htc_cnxt->chk_irq_status_cnt = 0;\r\ntimeout = jiffies + msecs_to_jiffies(ATH6KL_HIF_COMMUNICATION_TIMEOUT);\r\nwhile (time_before(jiffies, timeout) && !done) {\r\nstatus = proc_pending_irqs(dev, &done);\r\nif (status)\r\nbreak;\r\n}\r\nreturn status;\r\n}\r\nstatic int ath6kl_hif_enable_intrs(struct ath6kl_device *dev)\r\n{\r\nstruct ath6kl_irq_enable_reg regs;\r\nint status;\r\nspin_lock_bh(&dev->lock);\r\ndev->irq_en_reg.int_status_en =\r\nSM(INT_STATUS_ENABLE_ERROR, 0x01) |\r\nSM(INT_STATUS_ENABLE_CPU, 0x01) |\r\nSM(INT_STATUS_ENABLE_COUNTER, 0x01);\r\ndev->irq_en_reg.int_status_en |= SM(INT_STATUS_ENABLE_MBOX_DATA, 0x01);\r\ndev->irq_en_reg.cpu_int_status_en = 0;\r\ndev->irq_en_reg.err_int_status_en =\r\nSM(ERROR_STATUS_ENABLE_RX_UNDERFLOW, 0x01) |\r\nSM(ERROR_STATUS_ENABLE_TX_OVERFLOW, 0x1);\r\ndev->irq_en_reg.cntr_int_status_en = SM(COUNTER_INT_STATUS_ENABLE_BIT,\r\nATH6KL_TARGET_DEBUG_INTR_MASK);\r\nmemcpy(&regs, &dev->irq_en_reg, sizeof(regs));\r\nspin_unlock_bh(&dev->lock);\r\nstatus = hif_read_write_sync(dev->ar, INT_STATUS_ENABLE_ADDRESS,\r\n&regs.int_status_en, sizeof(regs),\r\nHIF_WR_SYNC_BYTE_INC);\r\nif (status)\r\nath6kl_err("failed to update interrupt ctl reg err: %d\n",\r\nstatus);\r\nreturn status;\r\n}\r\nint ath6kl_hif_disable_intrs(struct ath6kl_device *dev)\r\n{\r\nstruct ath6kl_irq_enable_reg regs;\r\nspin_lock_bh(&dev->lock);\r\ndev->irq_en_reg.int_status_en = 0;\r\ndev->irq_en_reg.cpu_int_status_en = 0;\r\ndev->irq_en_reg.err_int_status_en = 0;\r\ndev->irq_en_reg.cntr_int_status_en = 0;\r\nmemcpy(&regs, &dev->irq_en_reg, sizeof(regs));\r\nspin_unlock_bh(&dev->lock);\r\nreturn hif_read_write_sync(dev->ar, INT_STATUS_ENABLE_ADDRESS,\r\n&regs.int_status_en, sizeof(regs),\r\nHIF_WR_SYNC_BYTE_INC);\r\n}\r\nint ath6kl_hif_unmask_intrs(struct ath6kl_device *dev)\r\n{\r\nint status = 0;\r\nath6kl_hif_disable_intrs(dev);\r\nath6kl_hif_irq_enable(dev->ar);\r\nstatus = ath6kl_hif_enable_intrs(dev);\r\nreturn status;\r\n}\r\nint ath6kl_hif_mask_intrs(struct ath6kl_device *dev)\r\n{\r\nath6kl_hif_irq_disable(dev->ar);\r\nreturn ath6kl_hif_disable_intrs(dev);\r\n}\r\nint ath6kl_hif_setup(struct ath6kl_device *dev)\r\n{\r\nint status = 0;\r\nspin_lock_init(&dev->lock);\r\ndev->htc_cnxt->block_sz = dev->ar->mbox_info.block_size;\r\nif ((dev->htc_cnxt->block_sz & (dev->htc_cnxt->block_sz - 1)) != 0) {\r\nWARN_ON(1);\r\nstatus = -EINVAL;\r\ngoto fail_setup;\r\n}\r\ndev->htc_cnxt->block_mask = dev->htc_cnxt->block_sz - 1;\r\nath6kl_dbg(ATH6KL_DBG_HIF, "hif block size %d mbox addr 0x%x\n",\r\ndev->htc_cnxt->block_sz, dev->ar->mbox_info.htc_addr);\r\nstatus = ath6kl_hif_disable_intrs(dev);\r\nfail_setup:\r\nreturn status;\r\n}
