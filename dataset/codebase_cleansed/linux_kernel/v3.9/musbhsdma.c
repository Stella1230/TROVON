static int dma_controller_start(struct dma_controller *c)\r\n{\r\nreturn 0;\r\n}\r\nstatic int dma_controller_stop(struct dma_controller *c)\r\n{\r\nstruct musb_dma_controller *controller = container_of(c,\r\nstruct musb_dma_controller, controller);\r\nstruct musb *musb = controller->private_data;\r\nstruct dma_channel *channel;\r\nu8 bit;\r\nif (controller->used_channels != 0) {\r\ndev_err(musb->controller,\r\n"Stopping DMA controller while channel active\n");\r\nfor (bit = 0; bit < MUSB_HSDMA_CHANNELS; bit++) {\r\nif (controller->used_channels & (1 << bit)) {\r\nchannel = &controller->channel[bit].channel;\r\ndma_channel_release(channel);\r\nif (!controller->used_channels)\r\nbreak;\r\n}\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic struct dma_channel *dma_channel_allocate(struct dma_controller *c,\r\nstruct musb_hw_ep *hw_ep, u8 transmit)\r\n{\r\nstruct musb_dma_controller *controller = container_of(c,\r\nstruct musb_dma_controller, controller);\r\nstruct musb_dma_channel *musb_channel = NULL;\r\nstruct dma_channel *channel = NULL;\r\nu8 bit;\r\nfor (bit = 0; bit < MUSB_HSDMA_CHANNELS; bit++) {\r\nif (!(controller->used_channels & (1 << bit))) {\r\ncontroller->used_channels |= (1 << bit);\r\nmusb_channel = &(controller->channel[bit]);\r\nmusb_channel->controller = controller;\r\nmusb_channel->idx = bit;\r\nmusb_channel->epnum = hw_ep->epnum;\r\nmusb_channel->transmit = transmit;\r\nchannel = &(musb_channel->channel);\r\nchannel->private_data = musb_channel;\r\nchannel->status = MUSB_DMA_STATUS_FREE;\r\nchannel->max_len = 0x100000;\r\nchannel->desired_mode = transmit;\r\nchannel->actual_len = 0;\r\nbreak;\r\n}\r\n}\r\nreturn channel;\r\n}\r\nstatic void dma_channel_release(struct dma_channel *channel)\r\n{\r\nstruct musb_dma_channel *musb_channel = channel->private_data;\r\nchannel->actual_len = 0;\r\nmusb_channel->start_addr = 0;\r\nmusb_channel->len = 0;\r\nmusb_channel->controller->used_channels &=\r\n~(1 << musb_channel->idx);\r\nchannel->status = MUSB_DMA_STATUS_UNKNOWN;\r\n}\r\nstatic void configure_channel(struct dma_channel *channel,\r\nu16 packet_sz, u8 mode,\r\ndma_addr_t dma_addr, u32 len)\r\n{\r\nstruct musb_dma_channel *musb_channel = channel->private_data;\r\nstruct musb_dma_controller *controller = musb_channel->controller;\r\nstruct musb *musb = controller->private_data;\r\nvoid __iomem *mbase = controller->base;\r\nu8 bchannel = musb_channel->idx;\r\nu16 csr = 0;\r\ndev_dbg(musb->controller, "%p, pkt_sz %d, addr 0x%x, len %d, mode %d\n",\r\nchannel, packet_sz, dma_addr, len, mode);\r\nif (mode) {\r\ncsr |= 1 << MUSB_HSDMA_MODE1_SHIFT;\r\nBUG_ON(len < packet_sz);\r\n}\r\ncsr |= MUSB_HSDMA_BURSTMODE_INCR16\r\n<< MUSB_HSDMA_BURSTMODE_SHIFT;\r\ncsr |= (musb_channel->epnum << MUSB_HSDMA_ENDPOINT_SHIFT)\r\n| (1 << MUSB_HSDMA_ENABLE_SHIFT)\r\n| (1 << MUSB_HSDMA_IRQENABLE_SHIFT)\r\n| (musb_channel->transmit\r\n? (1 << MUSB_HSDMA_TRANSMIT_SHIFT)\r\n: 0);\r\nmusb_write_hsdma_addr(mbase, bchannel, dma_addr);\r\nmusb_write_hsdma_count(mbase, bchannel, len);\r\nmusb_writew(mbase,\r\nMUSB_HSDMA_CHANNEL_OFFSET(bchannel, MUSB_HSDMA_CONTROL),\r\ncsr);\r\n}\r\nstatic int dma_channel_program(struct dma_channel *channel,\r\nu16 packet_sz, u8 mode,\r\ndma_addr_t dma_addr, u32 len)\r\n{\r\nstruct musb_dma_channel *musb_channel = channel->private_data;\r\nstruct musb_dma_controller *controller = musb_channel->controller;\r\nstruct musb *musb = controller->private_data;\r\ndev_dbg(musb->controller, "ep%d-%s pkt_sz %d, dma_addr 0x%x length %d, mode %d\n",\r\nmusb_channel->epnum,\r\nmusb_channel->transmit ? "Tx" : "Rx",\r\npacket_sz, dma_addr, len, mode);\r\nBUG_ON(channel->status == MUSB_DMA_STATUS_UNKNOWN ||\r\nchannel->status == MUSB_DMA_STATUS_BUSY);\r\nif (musb->ops->adjust_channel_params) {\r\nint ret = musb->ops->adjust_channel_params(channel,\r\npacket_sz, &mode, &dma_addr, &len);\r\nif (ret)\r\nreturn ret;\r\n}\r\nif ((musb->hwvers >= MUSB_HWVERS_1800) && (dma_addr % 4))\r\nreturn false;\r\nchannel->actual_len = 0;\r\nmusb_channel->start_addr = dma_addr;\r\nmusb_channel->len = len;\r\nmusb_channel->max_packet_sz = packet_sz;\r\nchannel->status = MUSB_DMA_STATUS_BUSY;\r\nconfigure_channel(channel, packet_sz, mode, dma_addr, len);\r\nreturn true;\r\n}\r\nstatic int dma_channel_abort(struct dma_channel *channel)\r\n{\r\nstruct musb_dma_channel *musb_channel = channel->private_data;\r\nvoid __iomem *mbase = musb_channel->controller->base;\r\nu8 bchannel = musb_channel->idx;\r\nint offset;\r\nu16 csr;\r\nif (channel->status == MUSB_DMA_STATUS_BUSY) {\r\nif (musb_channel->transmit) {\r\noffset = MUSB_EP_OFFSET(musb_channel->epnum,\r\nMUSB_TXCSR);\r\ncsr = musb_readw(mbase, offset);\r\ncsr &= ~(MUSB_TXCSR_AUTOSET | MUSB_TXCSR_DMAENAB);\r\nmusb_writew(mbase, offset, csr);\r\ncsr &= ~MUSB_TXCSR_DMAMODE;\r\nmusb_writew(mbase, offset, csr);\r\n} else {\r\noffset = MUSB_EP_OFFSET(musb_channel->epnum,\r\nMUSB_RXCSR);\r\ncsr = musb_readw(mbase, offset);\r\ncsr &= ~(MUSB_RXCSR_AUTOCLEAR |\r\nMUSB_RXCSR_DMAENAB |\r\nMUSB_RXCSR_DMAMODE);\r\nmusb_writew(mbase, offset, csr);\r\n}\r\nmusb_writew(mbase,\r\nMUSB_HSDMA_CHANNEL_OFFSET(bchannel, MUSB_HSDMA_CONTROL),\r\n0);\r\nmusb_write_hsdma_addr(mbase, bchannel, 0);\r\nmusb_write_hsdma_count(mbase, bchannel, 0);\r\nchannel->status = MUSB_DMA_STATUS_FREE;\r\n}\r\nreturn 0;\r\n}\r\nstatic irqreturn_t dma_controller_irq(int irq, void *private_data)\r\n{\r\nstruct musb_dma_controller *controller = private_data;\r\nstruct musb *musb = controller->private_data;\r\nstruct musb_dma_channel *musb_channel;\r\nstruct dma_channel *channel;\r\nvoid __iomem *mbase = controller->base;\r\nirqreturn_t retval = IRQ_NONE;\r\nunsigned long flags;\r\nu8 bchannel;\r\nu8 int_hsdma;\r\nu32 addr, count;\r\nu16 csr;\r\nspin_lock_irqsave(&musb->lock, flags);\r\nint_hsdma = musb_readb(mbase, MUSB_HSDMA_INTR);\r\n#ifdef CONFIG_BLACKFIN\r\nmusb_writeb(mbase, MUSB_HSDMA_INTR, int_hsdma);\r\n#endif\r\nif (!int_hsdma) {\r\ndev_dbg(musb->controller, "spurious DMA irq\n");\r\nfor (bchannel = 0; bchannel < MUSB_HSDMA_CHANNELS; bchannel++) {\r\nmusb_channel = (struct musb_dma_channel *)\r\n&(controller->channel[bchannel]);\r\nchannel = &musb_channel->channel;\r\nif (channel->status == MUSB_DMA_STATUS_BUSY) {\r\ncount = musb_read_hsdma_count(mbase, bchannel);\r\nif (count == 0)\r\nint_hsdma |= (1 << bchannel);\r\n}\r\n}\r\ndev_dbg(musb->controller, "int_hsdma = 0x%x\n", int_hsdma);\r\nif (!int_hsdma)\r\ngoto done;\r\n}\r\nfor (bchannel = 0; bchannel < MUSB_HSDMA_CHANNELS; bchannel++) {\r\nif (int_hsdma & (1 << bchannel)) {\r\nmusb_channel = (struct musb_dma_channel *)\r\n&(controller->channel[bchannel]);\r\nchannel = &musb_channel->channel;\r\ncsr = musb_readw(mbase,\r\nMUSB_HSDMA_CHANNEL_OFFSET(bchannel,\r\nMUSB_HSDMA_CONTROL));\r\nif (csr & (1 << MUSB_HSDMA_BUSERROR_SHIFT)) {\r\nmusb_channel->channel.status =\r\nMUSB_DMA_STATUS_BUS_ABORT;\r\n} else {\r\nu8 devctl;\r\naddr = musb_read_hsdma_addr(mbase,\r\nbchannel);\r\nchannel->actual_len = addr\r\n- musb_channel->start_addr;\r\ndev_dbg(musb->controller, "ch %p, 0x%x -> 0x%x (%zu / %d) %s\n",\r\nchannel, musb_channel->start_addr,\r\naddr, channel->actual_len,\r\nmusb_channel->len,\r\n(channel->actual_len\r\n< musb_channel->len) ?\r\n"=> reconfig 0" : "=> complete");\r\ndevctl = musb_readb(mbase, MUSB_DEVCTL);\r\nchannel->status = MUSB_DMA_STATUS_FREE;\r\nif ((devctl & MUSB_DEVCTL_HM)\r\n&& (musb_channel->transmit)\r\n&& ((channel->desired_mode == 0)\r\n|| (channel->actual_len &\r\n(musb_channel->max_packet_sz - 1)))\r\n) {\r\nu8 epnum = musb_channel->epnum;\r\nint offset = MUSB_EP_OFFSET(epnum,\r\nMUSB_TXCSR);\r\nu16 txcsr;\r\nmusb_ep_select(mbase, epnum);\r\ntxcsr = musb_readw(mbase, offset);\r\ntxcsr &= ~(MUSB_TXCSR_DMAENAB\r\n| MUSB_TXCSR_AUTOSET);\r\nmusb_writew(mbase, offset, txcsr);\r\ntxcsr &= ~MUSB_TXCSR_DMAMODE;\r\ntxcsr |= MUSB_TXCSR_TXPKTRDY;\r\nmusb_writew(mbase, offset, txcsr);\r\n}\r\nmusb_dma_completion(musb, musb_channel->epnum,\r\nmusb_channel->transmit);\r\n}\r\n}\r\n}\r\nretval = IRQ_HANDLED;\r\ndone:\r\nspin_unlock_irqrestore(&musb->lock, flags);\r\nreturn retval;\r\n}\r\nvoid dma_controller_destroy(struct dma_controller *c)\r\n{\r\nstruct musb_dma_controller *controller = container_of(c,\r\nstruct musb_dma_controller, controller);\r\nif (!controller)\r\nreturn;\r\nif (controller->irq)\r\nfree_irq(controller->irq, c);\r\nkfree(controller);\r\n}\r\nstruct dma_controller *dma_controller_create(struct musb *musb, void __iomem *base)\r\n{\r\nstruct musb_dma_controller *controller;\r\nstruct device *dev = musb->controller;\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nint irq = platform_get_irq_byname(pdev, "dma");\r\nif (irq <= 0) {\r\ndev_err(dev, "No DMA interrupt line!\n");\r\nreturn NULL;\r\n}\r\ncontroller = kzalloc(sizeof(*controller), GFP_KERNEL);\r\nif (!controller)\r\nreturn NULL;\r\ncontroller->channel_count = MUSB_HSDMA_CHANNELS;\r\ncontroller->private_data = musb;\r\ncontroller->base = base;\r\ncontroller->controller.start = dma_controller_start;\r\ncontroller->controller.stop = dma_controller_stop;\r\ncontroller->controller.channel_alloc = dma_channel_allocate;\r\ncontroller->controller.channel_release = dma_channel_release;\r\ncontroller->controller.channel_program = dma_channel_program;\r\ncontroller->controller.channel_abort = dma_channel_abort;\r\nif (request_irq(irq, dma_controller_irq, 0,\r\ndev_name(musb->controller), &controller->controller)) {\r\ndev_err(dev, "request_irq %d failed!\n", irq);\r\ndma_controller_destroy(&controller->controller);\r\nreturn NULL;\r\n}\r\ncontroller->irq = irq;\r\nreturn &controller->controller;\r\n}
