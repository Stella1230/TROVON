static int omap4_enter_idle_simple(struct cpuidle_device *dev,\r\nstruct cpuidle_driver *drv,\r\nint index)\r\n{\r\nlocal_fiq_disable();\r\nomap_do_wfi();\r\nlocal_fiq_enable();\r\nreturn index;\r\n}\r\nstatic int omap4_enter_idle_coupled(struct cpuidle_device *dev,\r\nstruct cpuidle_driver *drv,\r\nint index)\r\n{\r\nstruct omap4_idle_statedata *cx = &omap4_idle_data[index];\r\nint cpu_id = smp_processor_id();\r\nlocal_fiq_disable();\r\nif (dev->cpu == 0 && cpumask_test_cpu(1, cpu_online_mask)) {\r\nwhile (pwrdm_read_pwrst(cpu_pd[1]) != PWRDM_POWER_OFF) {\r\ncpu_relax();\r\nif (cpu_done[1])\r\ngoto fail;\r\n}\r\n}\r\nclockevents_notify(CLOCK_EVT_NOTIFY_BROADCAST_ENTER, &cpu_id);\r\ncpu_pm_enter();\r\nif (dev->cpu == 0) {\r\npwrdm_set_logic_retst(mpu_pd, cx->mpu_logic_state);\r\nomap_set_pwrdm_state(mpu_pd, cx->mpu_state);\r\nif ((cx->mpu_state == PWRDM_POWER_RET) &&\r\n(cx->mpu_logic_state == PWRDM_POWER_OFF))\r\ncpu_cluster_pm_enter();\r\n}\r\nomap4_enter_lowpower(dev->cpu, cx->cpu_state);\r\ncpu_done[dev->cpu] = true;\r\nif (dev->cpu == 0 && cpumask_test_cpu(1, cpu_online_mask)) {\r\nclkdm_wakeup(cpu_clkdm[1]);\r\nclkdm_allow_idle(cpu_clkdm[1]);\r\n}\r\ncpu_pm_exit();\r\nif (omap4_mpuss_read_prev_context_state())\r\ncpu_cluster_pm_exit();\r\nclockevents_notify(CLOCK_EVT_NOTIFY_BROADCAST_EXIT, &cpu_id);\r\nfail:\r\ncpuidle_coupled_parallel_barrier(dev, &abort_barrier);\r\ncpu_done[dev->cpu] = false;\r\nlocal_fiq_enable();\r\nreturn index;\r\n}\r\nstatic void omap_setup_broadcast_timer(void *arg)\r\n{\r\nint cpu = smp_processor_id();\r\nclockevents_notify(CLOCK_EVT_NOTIFY_BROADCAST_ON, &cpu);\r\n}\r\nint __init omap4_idle_init(void)\r\n{\r\nstruct cpuidle_device *dev;\r\nunsigned int cpu_id = 0;\r\nmpu_pd = pwrdm_lookup("mpu_pwrdm");\r\ncpu_pd[0] = pwrdm_lookup("cpu0_pwrdm");\r\ncpu_pd[1] = pwrdm_lookup("cpu1_pwrdm");\r\nif ((!mpu_pd) || (!cpu_pd[0]) || (!cpu_pd[1]))\r\nreturn -ENODEV;\r\ncpu_clkdm[0] = clkdm_lookup("mpu0_clkdm");\r\ncpu_clkdm[1] = clkdm_lookup("mpu1_clkdm");\r\nif (!cpu_clkdm[0] || !cpu_clkdm[1])\r\nreturn -ENODEV;\r\non_each_cpu(omap_setup_broadcast_timer, NULL, 1);\r\nfor_each_cpu(cpu_id, cpu_online_mask) {\r\ndev = &per_cpu(omap4_idle_dev, cpu_id);\r\ndev->cpu = cpu_id;\r\n#ifdef CONFIG_ARCH_NEEDS_CPU_IDLE_COUPLED\r\ndev->coupled_cpus = *cpu_online_mask;\r\n#endif\r\ncpuidle_register_driver(&omap4_idle_driver);\r\nif (cpuidle_register_device(dev)) {\r\npr_err("%s: CPUidle register failed\n", __func__);\r\nreturn -EIO;\r\n}\r\n}\r\nreturn 0;\r\n}
