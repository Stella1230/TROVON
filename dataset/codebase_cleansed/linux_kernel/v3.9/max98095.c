static int max98095_readable(struct snd_soc_codec *codec, unsigned int reg)\r\n{\r\nif (reg >= M98095_REG_CNT)\r\nreturn 0;\r\nreturn max98095_access[reg].readable != 0;\r\n}\r\nstatic int max98095_volatile(struct snd_soc_codec *codec, unsigned int reg)\r\n{\r\nif (reg > M98095_REG_MAX_CACHED)\r\nreturn 1;\r\nswitch (reg) {\r\ncase M98095_000_HOST_DATA:\r\ncase M98095_001_HOST_INT_STS:\r\ncase M98095_002_HOST_RSP_STS:\r\ncase M98095_003_HOST_CMD_STS:\r\ncase M98095_004_CODEC_STS:\r\ncase M98095_005_DAI1_ALC_STS:\r\ncase M98095_006_DAI2_ALC_STS:\r\ncase M98095_007_JACK_AUTO_STS:\r\ncase M98095_008_JACK_MANUAL_STS:\r\ncase M98095_009_JACK_VBAT_STS:\r\ncase M98095_00A_ACC_ADC_STS:\r\ncase M98095_00B_MIC_NG_AGC_STS:\r\ncase M98095_00C_SPK_L_VOLT_STS:\r\ncase M98095_00D_SPK_R_VOLT_STS:\r\ncase M98095_00E_TEMP_SENSOR_STS:\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int max98095_hw_write(struct snd_soc_codec *codec, unsigned int reg,\r\nunsigned int value)\r\n{\r\nint ret;\r\ncodec->cache_bypass = 1;\r\nret = snd_soc_write(codec, reg, value);\r\ncodec->cache_bypass = 0;\r\nreturn ret ? -EIO : 0;\r\n}\r\nstatic void m98095_eq_band(struct snd_soc_codec *codec, unsigned int dai,\r\nunsigned int band, u16 *coefs)\r\n{\r\nunsigned int eq_reg;\r\nunsigned int i;\r\nBUG_ON(band > 4);\r\nBUG_ON(dai > 1);\r\neq_reg = dai ? M98095_142_DAI2_EQ_BASE : M98095_110_DAI1_EQ_BASE;\r\neq_reg += band * (M98095_COEFS_PER_BAND << 1);\r\nfor (i = 0; i < M98095_COEFS_PER_BAND; i++) {\r\nmax98095_hw_write(codec, eq_reg++, M98095_BYTE1(coefs[i]));\r\nmax98095_hw_write(codec, eq_reg++, M98095_BYTE0(coefs[i]));\r\n}\r\n}\r\nstatic void m98095_biquad_band(struct snd_soc_codec *codec, unsigned int dai,\r\nunsigned int band, u16 *coefs)\r\n{\r\nunsigned int bq_reg;\r\nunsigned int i;\r\nBUG_ON(band > 1);\r\nBUG_ON(dai > 1);\r\nbq_reg = dai ? M98095_17E_DAI2_BQ_BASE : M98095_174_DAI1_BQ_BASE;\r\nbq_reg += band * (M98095_COEFS_PER_BAND << 1);\r\nfor (i = 0; i < M98095_COEFS_PER_BAND; i++) {\r\nmax98095_hw_write(codec, bq_reg++, M98095_BYTE1(coefs[i]));\r\nmax98095_hw_write(codec, bq_reg++, M98095_BYTE0(coefs[i]));\r\n}\r\n}\r\nstatic int max98095_mic1pre_set(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);\r\nstruct max98095_priv *max98095 = snd_soc_codec_get_drvdata(codec);\r\nunsigned int sel = ucontrol->value.integer.value[0];\r\nmax98095->mic1pre = sel;\r\nsnd_soc_update_bits(codec, M98095_05F_LVL_MIC1, M98095_MICPRE_MASK,\r\n(1+sel)<<M98095_MICPRE_SHIFT);\r\nreturn 0;\r\n}\r\nstatic int max98095_mic1pre_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);\r\nstruct max98095_priv *max98095 = snd_soc_codec_get_drvdata(codec);\r\nucontrol->value.integer.value[0] = max98095->mic1pre;\r\nreturn 0;\r\n}\r\nstatic int max98095_mic2pre_set(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);\r\nstruct max98095_priv *max98095 = snd_soc_codec_get_drvdata(codec);\r\nunsigned int sel = ucontrol->value.integer.value[0];\r\nmax98095->mic2pre = sel;\r\nsnd_soc_update_bits(codec, M98095_060_LVL_MIC2, M98095_MICPRE_MASK,\r\n(1+sel)<<M98095_MICPRE_SHIFT);\r\nreturn 0;\r\n}\r\nstatic int max98095_mic2pre_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);\r\nstruct max98095_priv *max98095 = snd_soc_codec_get_drvdata(codec);\r\nucontrol->value.integer.value[0] = max98095->mic2pre;\r\nreturn 0;\r\n}\r\nstatic int max98095_mic_event(struct snd_soc_dapm_widget *w,\r\nstruct snd_kcontrol *kcontrol, int event)\r\n{\r\nstruct snd_soc_codec *codec = w->codec;\r\nstruct max98095_priv *max98095 = snd_soc_codec_get_drvdata(codec);\r\nswitch (event) {\r\ncase SND_SOC_DAPM_POST_PMU:\r\nif (w->reg == M98095_05F_LVL_MIC1) {\r\nsnd_soc_update_bits(codec, w->reg, M98095_MICPRE_MASK,\r\n(1+max98095->mic1pre)<<M98095_MICPRE_SHIFT);\r\n} else {\r\nsnd_soc_update_bits(codec, w->reg, M98095_MICPRE_MASK,\r\n(1+max98095->mic2pre)<<M98095_MICPRE_SHIFT);\r\n}\r\nbreak;\r\ncase SND_SOC_DAPM_POST_PMD:\r\nsnd_soc_update_bits(codec, w->reg, M98095_MICPRE_MASK, 0);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int max98095_line_pga(struct snd_soc_dapm_widget *w,\r\nint event, u8 channel)\r\n{\r\nstruct snd_soc_codec *codec = w->codec;\r\nstruct max98095_priv *max98095 = snd_soc_codec_get_drvdata(codec);\r\nu8 *state;\r\nBUG_ON(!((channel == 1) || (channel == 2)));\r\nstate = &max98095->lin_state;\r\nswitch (event) {\r\ncase SND_SOC_DAPM_POST_PMU:\r\n*state |= channel;\r\nsnd_soc_update_bits(codec, w->reg,\r\n(1 << w->shift), (1 << w->shift));\r\nbreak;\r\ncase SND_SOC_DAPM_POST_PMD:\r\n*state &= ~channel;\r\nif (*state == 0) {\r\nsnd_soc_update_bits(codec, w->reg,\r\n(1 << w->shift), 0);\r\n}\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int max98095_pga_in1_event(struct snd_soc_dapm_widget *w,\r\nstruct snd_kcontrol *k, int event)\r\n{\r\nreturn max98095_line_pga(w, event, 1);\r\n}\r\nstatic int max98095_pga_in2_event(struct snd_soc_dapm_widget *w,\r\nstruct snd_kcontrol *k, int event)\r\n{\r\nreturn max98095_line_pga(w, event, 2);\r\n}\r\nstatic int max98095_lineout_event(struct snd_soc_dapm_widget *w,\r\nstruct snd_kcontrol *kcontrol, int event)\r\n{\r\nstruct snd_soc_codec *codec = w->codec;\r\nswitch (event) {\r\ncase SND_SOC_DAPM_POST_PMU:\r\nsnd_soc_update_bits(codec, w->reg,\r\n(1 << (w->shift+2)), (1 << (w->shift+2)));\r\nbreak;\r\ncase SND_SOC_DAPM_POST_PMD:\r\nsnd_soc_update_bits(codec, w->reg,\r\n(1 << (w->shift+2)), 0);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int max98095_add_widgets(struct snd_soc_codec *codec)\r\n{\r\nsnd_soc_add_codec_controls(codec, max98095_snd_controls,\r\nARRAY_SIZE(max98095_snd_controls));\r\nreturn 0;\r\n}\r\nstatic int rate_value(int rate, u8 *value)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(rate_table); i++) {\r\nif (rate_table[i].rate >= rate) {\r\n*value = rate_table[i].sr;\r\nreturn 0;\r\n}\r\n}\r\n*value = rate_table[0].sr;\r\nreturn -EINVAL;\r\n}\r\nstatic int max98095_dai1_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nstruct max98095_priv *max98095 = snd_soc_codec_get_drvdata(codec);\r\nstruct max98095_cdata *cdata;\r\nunsigned long long ni;\r\nunsigned int rate;\r\nu8 regval;\r\ncdata = &max98095->dai[0];\r\nrate = params_rate(params);\r\nswitch (params_format(params)) {\r\ncase SNDRV_PCM_FORMAT_S16_LE:\r\nsnd_soc_update_bits(codec, M98095_02A_DAI1_FORMAT,\r\nM98095_DAI_WS, 0);\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S24_LE:\r\nsnd_soc_update_bits(codec, M98095_02A_DAI1_FORMAT,\r\nM98095_DAI_WS, M98095_DAI_WS);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (rate_value(rate, &regval))\r\nreturn -EINVAL;\r\nsnd_soc_update_bits(codec, M98095_027_DAI1_CLKMODE,\r\nM98095_CLKMODE_MASK, regval);\r\ncdata->rate = rate;\r\nif (snd_soc_read(codec, M98095_02A_DAI1_FORMAT) & M98095_DAI_MAS) {\r\nif (max98095->sysclk == 0) {\r\ndev_err(codec->dev, "Invalid system clock frequency\n");\r\nreturn -EINVAL;\r\n}\r\nni = 65536ULL * (rate < 50000 ? 96ULL : 48ULL)\r\n* (unsigned long long int)rate;\r\ndo_div(ni, (unsigned long long int)max98095->sysclk);\r\nsnd_soc_write(codec, M98095_028_DAI1_CLKCFG_HI,\r\n(ni >> 8) & 0x7F);\r\nsnd_soc_write(codec, M98095_029_DAI1_CLKCFG_LO,\r\nni & 0xFF);\r\n}\r\nif (rate < 50000)\r\nsnd_soc_update_bits(codec, M98095_02E_DAI1_FILTERS,\r\nM98095_DAI_DHF, 0);\r\nelse\r\nsnd_soc_update_bits(codec, M98095_02E_DAI1_FILTERS,\r\nM98095_DAI_DHF, M98095_DAI_DHF);\r\nreturn 0;\r\n}\r\nstatic int max98095_dai2_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nstruct max98095_priv *max98095 = snd_soc_codec_get_drvdata(codec);\r\nstruct max98095_cdata *cdata;\r\nunsigned long long ni;\r\nunsigned int rate;\r\nu8 regval;\r\ncdata = &max98095->dai[1];\r\nrate = params_rate(params);\r\nswitch (params_format(params)) {\r\ncase SNDRV_PCM_FORMAT_S16_LE:\r\nsnd_soc_update_bits(codec, M98095_034_DAI2_FORMAT,\r\nM98095_DAI_WS, 0);\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S24_LE:\r\nsnd_soc_update_bits(codec, M98095_034_DAI2_FORMAT,\r\nM98095_DAI_WS, M98095_DAI_WS);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (rate_value(rate, &regval))\r\nreturn -EINVAL;\r\nsnd_soc_update_bits(codec, M98095_031_DAI2_CLKMODE,\r\nM98095_CLKMODE_MASK, regval);\r\ncdata->rate = rate;\r\nif (snd_soc_read(codec, M98095_034_DAI2_FORMAT) & M98095_DAI_MAS) {\r\nif (max98095->sysclk == 0) {\r\ndev_err(codec->dev, "Invalid system clock frequency\n");\r\nreturn -EINVAL;\r\n}\r\nni = 65536ULL * (rate < 50000 ? 96ULL : 48ULL)\r\n* (unsigned long long int)rate;\r\ndo_div(ni, (unsigned long long int)max98095->sysclk);\r\nsnd_soc_write(codec, M98095_032_DAI2_CLKCFG_HI,\r\n(ni >> 8) & 0x7F);\r\nsnd_soc_write(codec, M98095_033_DAI2_CLKCFG_LO,\r\nni & 0xFF);\r\n}\r\nif (rate < 50000)\r\nsnd_soc_update_bits(codec, M98095_038_DAI2_FILTERS,\r\nM98095_DAI_DHF, 0);\r\nelse\r\nsnd_soc_update_bits(codec, M98095_038_DAI2_FILTERS,\r\nM98095_DAI_DHF, M98095_DAI_DHF);\r\nreturn 0;\r\n}\r\nstatic int max98095_dai3_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nstruct max98095_priv *max98095 = snd_soc_codec_get_drvdata(codec);\r\nstruct max98095_cdata *cdata;\r\nunsigned long long ni;\r\nunsigned int rate;\r\nu8 regval;\r\ncdata = &max98095->dai[2];\r\nrate = params_rate(params);\r\nswitch (params_format(params)) {\r\ncase SNDRV_PCM_FORMAT_S16_LE:\r\nsnd_soc_update_bits(codec, M98095_03E_DAI3_FORMAT,\r\nM98095_DAI_WS, 0);\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S24_LE:\r\nsnd_soc_update_bits(codec, M98095_03E_DAI3_FORMAT,\r\nM98095_DAI_WS, M98095_DAI_WS);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (rate_value(rate, &regval))\r\nreturn -EINVAL;\r\nsnd_soc_update_bits(codec, M98095_03B_DAI3_CLKMODE,\r\nM98095_CLKMODE_MASK, regval);\r\ncdata->rate = rate;\r\nif (snd_soc_read(codec, M98095_03E_DAI3_FORMAT) & M98095_DAI_MAS) {\r\nif (max98095->sysclk == 0) {\r\ndev_err(codec->dev, "Invalid system clock frequency\n");\r\nreturn -EINVAL;\r\n}\r\nni = 65536ULL * (rate < 50000 ? 96ULL : 48ULL)\r\n* (unsigned long long int)rate;\r\ndo_div(ni, (unsigned long long int)max98095->sysclk);\r\nsnd_soc_write(codec, M98095_03C_DAI3_CLKCFG_HI,\r\n(ni >> 8) & 0x7F);\r\nsnd_soc_write(codec, M98095_03D_DAI3_CLKCFG_LO,\r\nni & 0xFF);\r\n}\r\nif (rate < 50000)\r\nsnd_soc_update_bits(codec, M98095_042_DAI3_FILTERS,\r\nM98095_DAI_DHF, 0);\r\nelse\r\nsnd_soc_update_bits(codec, M98095_042_DAI3_FILTERS,\r\nM98095_DAI_DHF, M98095_DAI_DHF);\r\nreturn 0;\r\n}\r\nstatic int max98095_dai_set_sysclk(struct snd_soc_dai *dai,\r\nint clk_id, unsigned int freq, int dir)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nstruct max98095_priv *max98095 = snd_soc_codec_get_drvdata(codec);\r\nif (freq == max98095->sysclk)\r\nreturn 0;\r\nif ((freq >= 10000000) && (freq < 20000000)) {\r\nsnd_soc_write(codec, M98095_026_SYS_CLK, 0x10);\r\n} else if ((freq >= 20000000) && (freq < 40000000)) {\r\nsnd_soc_write(codec, M98095_026_SYS_CLK, 0x20);\r\n} else if ((freq >= 40000000) && (freq < 60000000)) {\r\nsnd_soc_write(codec, M98095_026_SYS_CLK, 0x30);\r\n} else {\r\ndev_err(codec->dev, "Invalid master clock frequency\n");\r\nreturn -EINVAL;\r\n}\r\ndev_dbg(dai->dev, "Clock source is %d at %uHz\n", clk_id, freq);\r\nmax98095->sysclk = freq;\r\nreturn 0;\r\n}\r\nstatic int max98095_dai1_set_fmt(struct snd_soc_dai *codec_dai,\r\nunsigned int fmt)\r\n{\r\nstruct snd_soc_codec *codec = codec_dai->codec;\r\nstruct max98095_priv *max98095 = snd_soc_codec_get_drvdata(codec);\r\nstruct max98095_cdata *cdata;\r\nu8 regval = 0;\r\ncdata = &max98095->dai[0];\r\nif (fmt != cdata->fmt) {\r\ncdata->fmt = fmt;\r\nswitch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {\r\ncase SND_SOC_DAIFMT_CBS_CFS:\r\nsnd_soc_write(codec, M98095_028_DAI1_CLKCFG_HI,\r\n0x80);\r\nsnd_soc_write(codec, M98095_029_DAI1_CLKCFG_LO,\r\n0x00);\r\nbreak;\r\ncase SND_SOC_DAIFMT_CBM_CFM:\r\nregval |= M98095_DAI_MAS;\r\nbreak;\r\ncase SND_SOC_DAIFMT_CBS_CFM:\r\ncase SND_SOC_DAIFMT_CBM_CFS:\r\ndefault:\r\ndev_err(codec->dev, "Clock mode unsupported");\r\nreturn -EINVAL;\r\n}\r\nswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\r\ncase SND_SOC_DAIFMT_I2S:\r\nregval |= M98095_DAI_DLY;\r\nbreak;\r\ncase SND_SOC_DAIFMT_LEFT_J:\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\r\ncase SND_SOC_DAIFMT_NB_NF:\r\nbreak;\r\ncase SND_SOC_DAIFMT_NB_IF:\r\nregval |= M98095_DAI_WCI;\r\nbreak;\r\ncase SND_SOC_DAIFMT_IB_NF:\r\nregval |= M98095_DAI_BCI;\r\nbreak;\r\ncase SND_SOC_DAIFMT_IB_IF:\r\nregval |= M98095_DAI_BCI|M98095_DAI_WCI;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nsnd_soc_update_bits(codec, M98095_02A_DAI1_FORMAT,\r\nM98095_DAI_MAS | M98095_DAI_DLY | M98095_DAI_BCI |\r\nM98095_DAI_WCI, regval);\r\nsnd_soc_write(codec, M98095_02B_DAI1_CLOCK, M98095_DAI_BSEL64);\r\n}\r\nreturn 0;\r\n}\r\nstatic int max98095_dai2_set_fmt(struct snd_soc_dai *codec_dai,\r\nunsigned int fmt)\r\n{\r\nstruct snd_soc_codec *codec = codec_dai->codec;\r\nstruct max98095_priv *max98095 = snd_soc_codec_get_drvdata(codec);\r\nstruct max98095_cdata *cdata;\r\nu8 regval = 0;\r\ncdata = &max98095->dai[1];\r\nif (fmt != cdata->fmt) {\r\ncdata->fmt = fmt;\r\nswitch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {\r\ncase SND_SOC_DAIFMT_CBS_CFS:\r\nsnd_soc_write(codec, M98095_032_DAI2_CLKCFG_HI,\r\n0x80);\r\nsnd_soc_write(codec, M98095_033_DAI2_CLKCFG_LO,\r\n0x00);\r\nbreak;\r\ncase SND_SOC_DAIFMT_CBM_CFM:\r\nregval |= M98095_DAI_MAS;\r\nbreak;\r\ncase SND_SOC_DAIFMT_CBS_CFM:\r\ncase SND_SOC_DAIFMT_CBM_CFS:\r\ndefault:\r\ndev_err(codec->dev, "Clock mode unsupported");\r\nreturn -EINVAL;\r\n}\r\nswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\r\ncase SND_SOC_DAIFMT_I2S:\r\nregval |= M98095_DAI_DLY;\r\nbreak;\r\ncase SND_SOC_DAIFMT_LEFT_J:\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\r\ncase SND_SOC_DAIFMT_NB_NF:\r\nbreak;\r\ncase SND_SOC_DAIFMT_NB_IF:\r\nregval |= M98095_DAI_WCI;\r\nbreak;\r\ncase SND_SOC_DAIFMT_IB_NF:\r\nregval |= M98095_DAI_BCI;\r\nbreak;\r\ncase SND_SOC_DAIFMT_IB_IF:\r\nregval |= M98095_DAI_BCI|M98095_DAI_WCI;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nsnd_soc_update_bits(codec, M98095_034_DAI2_FORMAT,\r\nM98095_DAI_MAS | M98095_DAI_DLY | M98095_DAI_BCI |\r\nM98095_DAI_WCI, regval);\r\nsnd_soc_write(codec, M98095_035_DAI2_CLOCK,\r\nM98095_DAI_BSEL64);\r\n}\r\nreturn 0;\r\n}\r\nstatic int max98095_dai3_set_fmt(struct snd_soc_dai *codec_dai,\r\nunsigned int fmt)\r\n{\r\nstruct snd_soc_codec *codec = codec_dai->codec;\r\nstruct max98095_priv *max98095 = snd_soc_codec_get_drvdata(codec);\r\nstruct max98095_cdata *cdata;\r\nu8 regval = 0;\r\ncdata = &max98095->dai[2];\r\nif (fmt != cdata->fmt) {\r\ncdata->fmt = fmt;\r\nswitch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {\r\ncase SND_SOC_DAIFMT_CBS_CFS:\r\nsnd_soc_write(codec, M98095_03C_DAI3_CLKCFG_HI,\r\n0x80);\r\nsnd_soc_write(codec, M98095_03D_DAI3_CLKCFG_LO,\r\n0x00);\r\nbreak;\r\ncase SND_SOC_DAIFMT_CBM_CFM:\r\nregval |= M98095_DAI_MAS;\r\nbreak;\r\ncase SND_SOC_DAIFMT_CBS_CFM:\r\ncase SND_SOC_DAIFMT_CBM_CFS:\r\ndefault:\r\ndev_err(codec->dev, "Clock mode unsupported");\r\nreturn -EINVAL;\r\n}\r\nswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\r\ncase SND_SOC_DAIFMT_I2S:\r\nregval |= M98095_DAI_DLY;\r\nbreak;\r\ncase SND_SOC_DAIFMT_LEFT_J:\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\r\ncase SND_SOC_DAIFMT_NB_NF:\r\nbreak;\r\ncase SND_SOC_DAIFMT_NB_IF:\r\nregval |= M98095_DAI_WCI;\r\nbreak;\r\ncase SND_SOC_DAIFMT_IB_NF:\r\nregval |= M98095_DAI_BCI;\r\nbreak;\r\ncase SND_SOC_DAIFMT_IB_IF:\r\nregval |= M98095_DAI_BCI|M98095_DAI_WCI;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nsnd_soc_update_bits(codec, M98095_03E_DAI3_FORMAT,\r\nM98095_DAI_MAS | M98095_DAI_DLY | M98095_DAI_BCI |\r\nM98095_DAI_WCI, regval);\r\nsnd_soc_write(codec, M98095_03F_DAI3_CLOCK,\r\nM98095_DAI_BSEL64);\r\n}\r\nreturn 0;\r\n}\r\nstatic int max98095_set_bias_level(struct snd_soc_codec *codec,\r\nenum snd_soc_bias_level level)\r\n{\r\nint ret;\r\nswitch (level) {\r\ncase SND_SOC_BIAS_ON:\r\nbreak;\r\ncase SND_SOC_BIAS_PREPARE:\r\nbreak;\r\ncase SND_SOC_BIAS_STANDBY:\r\nif (codec->dapm.bias_level == SND_SOC_BIAS_OFF) {\r\nret = snd_soc_cache_sync(codec);\r\nif (ret != 0) {\r\ndev_err(codec->dev, "Failed to sync cache: %d\n", ret);\r\nreturn ret;\r\n}\r\n}\r\nsnd_soc_update_bits(codec, M98095_090_PWR_EN_IN,\r\nM98095_MBEN, M98095_MBEN);\r\nbreak;\r\ncase SND_SOC_BIAS_OFF:\r\nsnd_soc_update_bits(codec, M98095_090_PWR_EN_IN,\r\nM98095_MBEN, 0);\r\ncodec->cache_sync = 1;\r\nbreak;\r\n}\r\ncodec->dapm.bias_level = level;\r\nreturn 0;\r\n}\r\nstatic int max98095_get_eq_channel(const char *name)\r\n{\r\nif (strcmp(name, "EQ1 Mode") == 0)\r\nreturn 0;\r\nif (strcmp(name, "EQ2 Mode") == 0)\r\nreturn 1;\r\nreturn -EINVAL;\r\n}\r\nstatic int max98095_put_eq_enum(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);\r\nstruct max98095_priv *max98095 = snd_soc_codec_get_drvdata(codec);\r\nstruct max98095_pdata *pdata = max98095->pdata;\r\nint channel = max98095_get_eq_channel(kcontrol->id.name);\r\nstruct max98095_cdata *cdata;\r\nint sel = ucontrol->value.integer.value[0];\r\nstruct max98095_eq_cfg *coef_set;\r\nint fs, best, best_val, i;\r\nint regmask, regsave;\r\nBUG_ON(channel > 1);\r\nif (!pdata || !max98095->eq_textcnt)\r\nreturn 0;\r\nif (sel >= pdata->eq_cfgcnt)\r\nreturn -EINVAL;\r\ncdata = &max98095->dai[channel];\r\ncdata->eq_sel = sel;\r\nfs = cdata->rate;\r\nbest = 0;\r\nbest_val = INT_MAX;\r\nfor (i = 0; i < pdata->eq_cfgcnt; i++) {\r\nif (strcmp(pdata->eq_cfg[i].name, max98095->eq_texts[sel]) == 0 &&\r\nabs(pdata->eq_cfg[i].rate - fs) < best_val) {\r\nbest = i;\r\nbest_val = abs(pdata->eq_cfg[i].rate - fs);\r\n}\r\n}\r\ndev_dbg(codec->dev, "Selected %s/%dHz for %dHz sample rate\n",\r\npdata->eq_cfg[best].name,\r\npdata->eq_cfg[best].rate, fs);\r\ncoef_set = &pdata->eq_cfg[best];\r\nregmask = (channel == 0) ? M98095_EQ1EN : M98095_EQ2EN;\r\nregsave = snd_soc_read(codec, M98095_088_CFG_LEVEL);\r\nsnd_soc_update_bits(codec, M98095_088_CFG_LEVEL, regmask, 0);\r\nmutex_lock(&codec->mutex);\r\nsnd_soc_update_bits(codec, M98095_00F_HOST_CFG, M98095_SEG, M98095_SEG);\r\nm98095_eq_band(codec, channel, 0, coef_set->band1);\r\nm98095_eq_band(codec, channel, 1, coef_set->band2);\r\nm98095_eq_band(codec, channel, 2, coef_set->band3);\r\nm98095_eq_band(codec, channel, 3, coef_set->band4);\r\nm98095_eq_band(codec, channel, 4, coef_set->band5);\r\nsnd_soc_update_bits(codec, M98095_00F_HOST_CFG, M98095_SEG, 0);\r\nmutex_unlock(&codec->mutex);\r\nsnd_soc_update_bits(codec, M98095_088_CFG_LEVEL, regmask, regsave);\r\nreturn 0;\r\n}\r\nstatic int max98095_get_eq_enum(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);\r\nstruct max98095_priv *max98095 = snd_soc_codec_get_drvdata(codec);\r\nint channel = max98095_get_eq_channel(kcontrol->id.name);\r\nstruct max98095_cdata *cdata;\r\ncdata = &max98095->dai[channel];\r\nucontrol->value.enumerated.item[0] = cdata->eq_sel;\r\nreturn 0;\r\n}\r\nstatic void max98095_handle_eq_pdata(struct snd_soc_codec *codec)\r\n{\r\nstruct max98095_priv *max98095 = snd_soc_codec_get_drvdata(codec);\r\nstruct max98095_pdata *pdata = max98095->pdata;\r\nstruct max98095_eq_cfg *cfg;\r\nunsigned int cfgcnt;\r\nint i, j;\r\nconst char **t;\r\nint ret;\r\nstruct snd_kcontrol_new controls[] = {\r\nSOC_ENUM_EXT("EQ1 Mode",\r\nmax98095->eq_enum,\r\nmax98095_get_eq_enum,\r\nmax98095_put_eq_enum),\r\nSOC_ENUM_EXT("EQ2 Mode",\r\nmax98095->eq_enum,\r\nmax98095_get_eq_enum,\r\nmax98095_put_eq_enum),\r\n};\r\ncfg = pdata->eq_cfg;\r\ncfgcnt = pdata->eq_cfgcnt;\r\nmax98095->eq_textcnt = 0;\r\nmax98095->eq_texts = NULL;\r\nfor (i = 0; i < cfgcnt; i++) {\r\nfor (j = 0; j < max98095->eq_textcnt; j++) {\r\nif (strcmp(cfg[i].name, max98095->eq_texts[j]) == 0)\r\nbreak;\r\n}\r\nif (j != max98095->eq_textcnt)\r\ncontinue;\r\nt = krealloc(max98095->eq_texts,\r\nsizeof(char *) * (max98095->eq_textcnt + 1),\r\nGFP_KERNEL);\r\nif (t == NULL)\r\ncontinue;\r\nt[max98095->eq_textcnt] = cfg[i].name;\r\nmax98095->eq_textcnt++;\r\nmax98095->eq_texts = t;\r\n}\r\nmax98095->eq_enum.texts = max98095->eq_texts;\r\nmax98095->eq_enum.max = max98095->eq_textcnt;\r\nret = snd_soc_add_codec_controls(codec, controls, ARRAY_SIZE(controls));\r\nif (ret != 0)\r\ndev_err(codec->dev, "Failed to add EQ control: %d\n", ret);\r\n}\r\nstatic int max98095_get_bq_channel(struct snd_soc_codec *codec,\r\nconst char *name)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(bq_mode_name); i++)\r\nif (strcmp(name, bq_mode_name[i]) == 0)\r\nreturn i;\r\ndev_err(codec->dev, "Bad biquad channel name '%s'\n", name);\r\nreturn -EINVAL;\r\n}\r\nstatic int max98095_put_bq_enum(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);\r\nstruct max98095_priv *max98095 = snd_soc_codec_get_drvdata(codec);\r\nstruct max98095_pdata *pdata = max98095->pdata;\r\nint channel = max98095_get_bq_channel(codec, kcontrol->id.name);\r\nstruct max98095_cdata *cdata;\r\nint sel = ucontrol->value.integer.value[0];\r\nstruct max98095_biquad_cfg *coef_set;\r\nint fs, best, best_val, i;\r\nint regmask, regsave;\r\nif (channel < 0)\r\nreturn channel;\r\nif (!pdata || !max98095->bq_textcnt)\r\nreturn 0;\r\nif (sel >= pdata->bq_cfgcnt)\r\nreturn -EINVAL;\r\ncdata = &max98095->dai[channel];\r\ncdata->bq_sel = sel;\r\nfs = cdata->rate;\r\nbest = 0;\r\nbest_val = INT_MAX;\r\nfor (i = 0; i < pdata->bq_cfgcnt; i++) {\r\nif (strcmp(pdata->bq_cfg[i].name, max98095->bq_texts[sel]) == 0 &&\r\nabs(pdata->bq_cfg[i].rate - fs) < best_val) {\r\nbest = i;\r\nbest_val = abs(pdata->bq_cfg[i].rate - fs);\r\n}\r\n}\r\ndev_dbg(codec->dev, "Selected %s/%dHz for %dHz sample rate\n",\r\npdata->bq_cfg[best].name,\r\npdata->bq_cfg[best].rate, fs);\r\ncoef_set = &pdata->bq_cfg[best];\r\nregmask = (channel == 0) ? M98095_BQ1EN : M98095_BQ2EN;\r\nregsave = snd_soc_read(codec, M98095_088_CFG_LEVEL);\r\nsnd_soc_update_bits(codec, M98095_088_CFG_LEVEL, regmask, 0);\r\nmutex_lock(&codec->mutex);\r\nsnd_soc_update_bits(codec, M98095_00F_HOST_CFG, M98095_SEG, M98095_SEG);\r\nm98095_biquad_band(codec, channel, 0, coef_set->band1);\r\nm98095_biquad_band(codec, channel, 1, coef_set->band2);\r\nsnd_soc_update_bits(codec, M98095_00F_HOST_CFG, M98095_SEG, 0);\r\nmutex_unlock(&codec->mutex);\r\nsnd_soc_update_bits(codec, M98095_088_CFG_LEVEL, regmask, regsave);\r\nreturn 0;\r\n}\r\nstatic int max98095_get_bq_enum(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);\r\nstruct max98095_priv *max98095 = snd_soc_codec_get_drvdata(codec);\r\nint channel = max98095_get_bq_channel(codec, kcontrol->id.name);\r\nstruct max98095_cdata *cdata;\r\nif (channel < 0)\r\nreturn channel;\r\ncdata = &max98095->dai[channel];\r\nucontrol->value.enumerated.item[0] = cdata->bq_sel;\r\nreturn 0;\r\n}\r\nstatic void max98095_handle_bq_pdata(struct snd_soc_codec *codec)\r\n{\r\nstruct max98095_priv *max98095 = snd_soc_codec_get_drvdata(codec);\r\nstruct max98095_pdata *pdata = max98095->pdata;\r\nstruct max98095_biquad_cfg *cfg;\r\nunsigned int cfgcnt;\r\nint i, j;\r\nconst char **t;\r\nint ret;\r\nstruct snd_kcontrol_new controls[] = {\r\nSOC_ENUM_EXT((char *)bq_mode_name[0],\r\nmax98095->bq_enum,\r\nmax98095_get_bq_enum,\r\nmax98095_put_bq_enum),\r\nSOC_ENUM_EXT((char *)bq_mode_name[1],\r\nmax98095->bq_enum,\r\nmax98095_get_bq_enum,\r\nmax98095_put_bq_enum),\r\n};\r\nBUILD_BUG_ON(ARRAY_SIZE(controls) != ARRAY_SIZE(bq_mode_name));\r\ncfg = pdata->bq_cfg;\r\ncfgcnt = pdata->bq_cfgcnt;\r\nmax98095->bq_textcnt = 0;\r\nmax98095->bq_texts = NULL;\r\nfor (i = 0; i < cfgcnt; i++) {\r\nfor (j = 0; j < max98095->bq_textcnt; j++) {\r\nif (strcmp(cfg[i].name, max98095->bq_texts[j]) == 0)\r\nbreak;\r\n}\r\nif (j != max98095->bq_textcnt)\r\ncontinue;\r\nt = krealloc(max98095->bq_texts,\r\nsizeof(char *) * (max98095->bq_textcnt + 1),\r\nGFP_KERNEL);\r\nif (t == NULL)\r\ncontinue;\r\nt[max98095->bq_textcnt] = cfg[i].name;\r\nmax98095->bq_textcnt++;\r\nmax98095->bq_texts = t;\r\n}\r\nmax98095->bq_enum.texts = max98095->bq_texts;\r\nmax98095->bq_enum.max = max98095->bq_textcnt;\r\nret = snd_soc_add_codec_controls(codec, controls, ARRAY_SIZE(controls));\r\nif (ret != 0)\r\ndev_err(codec->dev, "Failed to add Biquad control: %d\n", ret);\r\n}\r\nstatic void max98095_handle_pdata(struct snd_soc_codec *codec)\r\n{\r\nstruct max98095_priv *max98095 = snd_soc_codec_get_drvdata(codec);\r\nstruct max98095_pdata *pdata = max98095->pdata;\r\nu8 regval = 0;\r\nif (!pdata) {\r\ndev_dbg(codec->dev, "No platform data\n");\r\nreturn;\r\n}\r\nif (pdata->digmic_left_mode)\r\nregval |= M98095_DIGMIC_L;\r\nif (pdata->digmic_right_mode)\r\nregval |= M98095_DIGMIC_R;\r\nsnd_soc_write(codec, M98095_087_CFG_MIC, regval);\r\nif (pdata->eq_cfgcnt)\r\nmax98095_handle_eq_pdata(codec);\r\nif (pdata->bq_cfgcnt)\r\nmax98095_handle_bq_pdata(codec);\r\n}\r\nstatic irqreturn_t max98095_report_jack(int irq, void *data)\r\n{\r\nstruct snd_soc_codec *codec = data;\r\nstruct max98095_priv *max98095 = snd_soc_codec_get_drvdata(codec);\r\nunsigned int value;\r\nint hp_report = 0;\r\nint mic_report = 0;\r\nvalue = snd_soc_read(codec, M98095_007_JACK_AUTO_STS);\r\nif ((value & M98095_DDONE) == 0)\r\nreturn IRQ_NONE;\r\nif ((value & M98095_HP_IN || value & M98095_LO_IN) &&\r\nmax98095->headphone_jack)\r\nhp_report |= SND_JACK_HEADPHONE;\r\nif ((value & M98095_MIC_IN) && max98095->mic_jack)\r\nmic_report |= SND_JACK_MICROPHONE;\r\nif (max98095->headphone_jack == max98095->mic_jack) {\r\nsnd_soc_jack_report(max98095->headphone_jack,\r\nhp_report | mic_report,\r\nSND_JACK_HEADSET);\r\n} else {\r\nif (max98095->headphone_jack)\r\nsnd_soc_jack_report(max98095->headphone_jack,\r\nhp_report, SND_JACK_HEADPHONE);\r\nif (max98095->mic_jack)\r\nsnd_soc_jack_report(max98095->mic_jack,\r\nmic_report, SND_JACK_MICROPHONE);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int max98095_jack_detect_enable(struct snd_soc_codec *codec)\r\n{\r\nstruct max98095_priv *max98095 = snd_soc_codec_get_drvdata(codec);\r\nint ret = 0;\r\nint detect_enable = M98095_JDEN;\r\nunsigned int slew = M98095_DEFAULT_SLEW_DELAY;\r\nif (max98095->pdata->jack_detect_pin5en)\r\ndetect_enable |= M98095_PIN5EN;\r\nif (max98095->pdata->jack_detect_delay)\r\nslew = max98095->pdata->jack_detect_delay;\r\nret = snd_soc_write(codec, M98095_08E_JACK_DC_SLEW, slew);\r\nif (ret < 0) {\r\ndev_err(codec->dev, "Failed to cfg auto detect %d\n", ret);\r\nreturn ret;\r\n}\r\nret = snd_soc_write(codec, M98095_089_JACK_DET_AUTO, detect_enable);\r\nif (ret < 0) {\r\ndev_err(codec->dev, "Failed to cfg auto detect %d\n", ret);\r\nreturn ret;\r\n}\r\nreturn ret;\r\n}\r\nstatic int max98095_jack_detect_disable(struct snd_soc_codec *codec)\r\n{\r\nint ret = 0;\r\nret = snd_soc_write(codec, M98095_089_JACK_DET_AUTO, 0x0);\r\nif (ret < 0) {\r\ndev_err(codec->dev, "Failed to cfg auto detect %d\n", ret);\r\nreturn ret;\r\n}\r\nreturn ret;\r\n}\r\nint max98095_jack_detect(struct snd_soc_codec *codec,\r\nstruct snd_soc_jack *hp_jack, struct snd_soc_jack *mic_jack)\r\n{\r\nstruct max98095_priv *max98095 = snd_soc_codec_get_drvdata(codec);\r\nstruct i2c_client *client = to_i2c_client(codec->dev);\r\nint ret = 0;\r\nmax98095->headphone_jack = hp_jack;\r\nmax98095->mic_jack = mic_jack;\r\nif (!hp_jack && !mic_jack)\r\nreturn -EINVAL;\r\nmax98095_jack_detect_enable(codec);\r\nret = snd_soc_update_bits(codec, M98095_013_JACK_INT_EN,\r\nM98095_IDDONE, M98095_IDDONE);\r\nif (ret < 0) {\r\ndev_err(codec->dev, "Failed to cfg jack irqs %d\n", ret);\r\nreturn ret;\r\n}\r\nmax98095_report_jack(client->irq, codec);\r\nreturn 0;\r\n}\r\nstatic int max98095_suspend(struct snd_soc_codec *codec)\r\n{\r\nstruct max98095_priv *max98095 = snd_soc_codec_get_drvdata(codec);\r\nif (max98095->headphone_jack || max98095->mic_jack)\r\nmax98095_jack_detect_disable(codec);\r\nmax98095_set_bias_level(codec, SND_SOC_BIAS_OFF);\r\nreturn 0;\r\n}\r\nstatic int max98095_resume(struct snd_soc_codec *codec)\r\n{\r\nstruct max98095_priv *max98095 = snd_soc_codec_get_drvdata(codec);\r\nstruct i2c_client *client = to_i2c_client(codec->dev);\r\nmax98095_set_bias_level(codec, SND_SOC_BIAS_STANDBY);\r\nif (max98095->headphone_jack || max98095->mic_jack) {\r\nmax98095_jack_detect_enable(codec);\r\nmax98095_report_jack(client->irq, codec);\r\n}\r\nreturn 0;\r\n}\r\nstatic int max98095_reset(struct snd_soc_codec *codec)\r\n{\r\nint i, ret;\r\nret = snd_soc_write(codec, M98095_00F_HOST_CFG, 0);\r\nif (ret < 0) {\r\ndev_err(codec->dev, "Failed to reset DSP: %d\n", ret);\r\nreturn ret;\r\n}\r\nret = snd_soc_write(codec, M98095_097_PWR_SYS, 0);\r\nif (ret < 0) {\r\ndev_err(codec->dev, "Failed to reset codec: %d\n", ret);\r\nreturn ret;\r\n}\r\nfor (i = M98095_010_HOST_INT_CFG; i < M98095_REG_MAX_CACHED; i++) {\r\nret = snd_soc_write(codec, i, max98095_reg_def[i]);\r\nif (ret < 0) {\r\ndev_err(codec->dev, "Failed to reset: %d\n", ret);\r\nreturn ret;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic int max98095_probe(struct snd_soc_codec *codec)\r\n{\r\nstruct max98095_priv *max98095 = snd_soc_codec_get_drvdata(codec);\r\nstruct max98095_cdata *cdata;\r\nstruct i2c_client *client;\r\nint ret = 0;\r\nret = snd_soc_codec_set_cache_io(codec, 8, 8, SND_SOC_I2C);\r\nif (ret != 0) {\r\ndev_err(codec->dev, "Failed to set cache I/O: %d\n", ret);\r\nreturn ret;\r\n}\r\nmax98095_reset(codec);\r\nclient = to_i2c_client(codec->dev);\r\nmax98095->sysclk = (unsigned)-1;\r\nmax98095->eq_textcnt = 0;\r\nmax98095->bq_textcnt = 0;\r\ncdata = &max98095->dai[0];\r\ncdata->rate = (unsigned)-1;\r\ncdata->fmt = (unsigned)-1;\r\ncdata->eq_sel = 0;\r\ncdata->bq_sel = 0;\r\ncdata = &max98095->dai[1];\r\ncdata->rate = (unsigned)-1;\r\ncdata->fmt = (unsigned)-1;\r\ncdata->eq_sel = 0;\r\ncdata->bq_sel = 0;\r\ncdata = &max98095->dai[2];\r\ncdata->rate = (unsigned)-1;\r\ncdata->fmt = (unsigned)-1;\r\ncdata->eq_sel = 0;\r\ncdata->bq_sel = 0;\r\nmax98095->lin_state = 0;\r\nmax98095->mic1pre = 0;\r\nmax98095->mic2pre = 0;\r\nif (client->irq) {\r\nret = request_threaded_irq(client->irq, NULL,\r\nmax98095_report_jack,\r\nIRQF_TRIGGER_FALLING | IRQF_TRIGGER_RISING,\r\n"max98095", codec);\r\nif (ret) {\r\ndev_err(codec->dev, "Failed to request IRQ: %d\n", ret);\r\ngoto err_access;\r\n}\r\n}\r\nret = snd_soc_read(codec, M98095_0FF_REV_ID);\r\nif (ret < 0) {\r\ndev_err(codec->dev, "Failure reading hardware revision: %d\n",\r\nret);\r\ngoto err_irq;\r\n}\r\ndev_info(codec->dev, "Hardware revision: %c\n", ret - 0x40 + 'A');\r\nsnd_soc_write(codec, M98095_097_PWR_SYS, M98095_PWRSV);\r\nmax98095_set_bias_level(codec, SND_SOC_BIAS_STANDBY);\r\nsnd_soc_write(codec, M98095_048_MIX_DAC_LR,\r\nM98095_DAI1L_TO_DACL|M98095_DAI1R_TO_DACR);\r\nsnd_soc_write(codec, M98095_049_MIX_DAC_M,\r\nM98095_DAI2M_TO_DACM|M98095_DAI3M_TO_DACM);\r\nsnd_soc_write(codec, M98095_092_PWR_EN_OUT, M98095_SPK_SPREADSPECTRUM);\r\nsnd_soc_write(codec, M98095_045_CFG_DSP, M98095_DSPNORMAL);\r\nsnd_soc_write(codec, M98095_04E_CFG_HP, M98095_HPNORMAL);\r\nsnd_soc_write(codec, M98095_02C_DAI1_IOCFG,\r\nM98095_S1NORMAL|M98095_SDATA);\r\nsnd_soc_write(codec, M98095_036_DAI2_IOCFG,\r\nM98095_S2NORMAL|M98095_SDATA);\r\nsnd_soc_write(codec, M98095_040_DAI3_IOCFG,\r\nM98095_S3NORMAL|M98095_SDATA);\r\nmax98095_handle_pdata(codec);\r\nsnd_soc_update_bits(codec, M98095_097_PWR_SYS, M98095_SHDNRUN,\r\nM98095_SHDNRUN);\r\nmax98095_add_widgets(codec);\r\nreturn 0;\r\nerr_irq:\r\nif (client->irq)\r\nfree_irq(client->irq, codec);\r\nerr_access:\r\nreturn ret;\r\n}\r\nstatic int max98095_remove(struct snd_soc_codec *codec)\r\n{\r\nstruct max98095_priv *max98095 = snd_soc_codec_get_drvdata(codec);\r\nstruct i2c_client *client = to_i2c_client(codec->dev);\r\nmax98095_set_bias_level(codec, SND_SOC_BIAS_OFF);\r\nif (max98095->headphone_jack || max98095->mic_jack)\r\nmax98095_jack_detect_disable(codec);\r\nif (client->irq)\r\nfree_irq(client->irq, codec);\r\nreturn 0;\r\n}\r\nstatic int max98095_i2c_probe(struct i2c_client *i2c,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct max98095_priv *max98095;\r\nint ret;\r\nmax98095 = devm_kzalloc(&i2c->dev, sizeof(struct max98095_priv),\r\nGFP_KERNEL);\r\nif (max98095 == NULL)\r\nreturn -ENOMEM;\r\nmax98095->devtype = id->driver_data;\r\ni2c_set_clientdata(i2c, max98095);\r\nmax98095->pdata = i2c->dev.platform_data;\r\nret = snd_soc_register_codec(&i2c->dev, &soc_codec_dev_max98095,\r\nmax98095_dai, ARRAY_SIZE(max98095_dai));\r\nreturn ret;\r\n}\r\nstatic int max98095_i2c_remove(struct i2c_client *client)\r\n{\r\nsnd_soc_unregister_codec(&client->dev);\r\nreturn 0;\r\n}
