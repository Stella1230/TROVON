static unsigned short snd_trident_codec_read(struct snd_ac97 *ac97, unsigned short reg)\r\n{\r\nunsigned int data = 0, treg;\r\nunsigned short count = 0xffff;\r\nunsigned long flags;\r\nstruct snd_trident *trident = ac97->private_data;\r\nspin_lock_irqsave(&trident->reg_lock, flags);\r\nif (trident->device == TRIDENT_DEVICE_ID_DX) {\r\ndata = (DX_AC97_BUSY_READ | (reg & 0x000000ff));\r\noutl(data, TRID_REG(trident, DX_ACR1_AC97_R));\r\ndo {\r\ndata = inl(TRID_REG(trident, DX_ACR1_AC97_R));\r\nif ((data & DX_AC97_BUSY_READ) == 0)\r\nbreak;\r\n} while (--count);\r\n} else if (trident->device == TRIDENT_DEVICE_ID_NX) {\r\ndata = (NX_AC97_BUSY_READ | (reg & 0x000000ff));\r\ntreg = ac97->num == 0 ? NX_ACR2_AC97_R_PRIMARY : NX_ACR3_AC97_R_SECONDARY;\r\noutl(data, TRID_REG(trident, treg));\r\ndo {\r\ndata = inl(TRID_REG(trident, treg));\r\nif ((data & 0x00000C00) == 0)\r\nbreak;\r\n} while (--count);\r\n} else if (trident->device == TRIDENT_DEVICE_ID_SI7018) {\r\ndata = SI_AC97_BUSY_READ | SI_AC97_AUDIO_BUSY | (reg & 0x000000ff);\r\nif (ac97->num == 1)\r\ndata |= SI_AC97_SECONDARY;\r\noutl(data, TRID_REG(trident, SI_AC97_READ));\r\ndo {\r\ndata = inl(TRID_REG(trident, SI_AC97_READ));\r\nif ((data & (SI_AC97_BUSY_READ)) == 0)\r\nbreak;\r\n} while (--count);\r\n}\r\nif (count == 0 && !trident->ac97_detect) {\r\nsnd_printk(KERN_ERR "ac97 codec read TIMEOUT [0x%x/0x%x]!!!\n",\r\nreg, data);\r\ndata = 0;\r\n}\r\nspin_unlock_irqrestore(&trident->reg_lock, flags);\r\nreturn ((unsigned short) (data >> 16));\r\n}\r\nstatic void snd_trident_codec_write(struct snd_ac97 *ac97, unsigned short reg,\r\nunsigned short wdata)\r\n{\r\nunsigned int address, data;\r\nunsigned short count = 0xffff;\r\nunsigned long flags;\r\nstruct snd_trident *trident = ac97->private_data;\r\ndata = ((unsigned long) wdata) << 16;\r\nspin_lock_irqsave(&trident->reg_lock, flags);\r\nif (trident->device == TRIDENT_DEVICE_ID_DX) {\r\naddress = DX_ACR0_AC97_W;\r\ndo {\r\nif ((inw(TRID_REG(trident, address)) & DX_AC97_BUSY_WRITE) == 0)\r\nbreak;\r\n} while (--count);\r\ndata |= (DX_AC97_BUSY_WRITE | (reg & 0x000000ff));\r\n} else if (trident->device == TRIDENT_DEVICE_ID_NX) {\r\naddress = NX_ACR1_AC97_W;\r\ndo {\r\nif ((inw(TRID_REG(trident, address)) & NX_AC97_BUSY_WRITE) == 0)\r\nbreak;\r\n} while (--count);\r\ndata |= (NX_AC97_BUSY_WRITE | (ac97->num << 8) | (reg & 0x000000ff));\r\n} else if (trident->device == TRIDENT_DEVICE_ID_SI7018) {\r\naddress = SI_AC97_WRITE;\r\ndo {\r\nif ((inw(TRID_REG(trident, address)) & (SI_AC97_BUSY_WRITE)) == 0)\r\nbreak;\r\n} while (--count);\r\ndata |= SI_AC97_BUSY_WRITE | SI_AC97_AUDIO_BUSY | (reg & 0x000000ff);\r\nif (ac97->num == 1)\r\ndata |= SI_AC97_SECONDARY;\r\n} else {\r\naddress = 0;\r\ncount = 0;\r\n}\r\nif (count == 0) {\r\nspin_unlock_irqrestore(&trident->reg_lock, flags);\r\nreturn;\r\n}\r\noutl(data, TRID_REG(trident, address));\r\nspin_unlock_irqrestore(&trident->reg_lock, flags);\r\n}\r\nstatic void snd_trident_enable_eso(struct snd_trident * trident)\r\n{\r\nunsigned int val;\r\nval = inl(TRID_REG(trident, T4D_LFO_GC_CIR));\r\nval |= ENDLP_IE;\r\nval |= MIDLP_IE;\r\nif (trident->device == TRIDENT_DEVICE_ID_SI7018)\r\nval |= BANK_B_EN;\r\noutl(val, TRID_REG(trident, T4D_LFO_GC_CIR));\r\n}\r\nstatic void snd_trident_disable_eso(struct snd_trident * trident)\r\n{\r\nunsigned int tmp;\r\ntmp = inl(TRID_REG(trident, T4D_LFO_GC_CIR));\r\ntmp &= ~ENDLP_IE;\r\ntmp &= ~MIDLP_IE;\r\noutl(tmp, TRID_REG(trident, T4D_LFO_GC_CIR));\r\n}\r\nvoid snd_trident_start_voice(struct snd_trident * trident, unsigned int voice)\r\n{\r\nunsigned int mask = 1 << (voice & 0x1f);\r\nunsigned int reg = (voice & 0x20) ? T4D_START_B : T4D_START_A;\r\noutl(mask, TRID_REG(trident, reg));\r\n}\r\nvoid snd_trident_stop_voice(struct snd_trident * trident, unsigned int voice)\r\n{\r\nunsigned int mask = 1 << (voice & 0x1f);\r\nunsigned int reg = (voice & 0x20) ? T4D_STOP_B : T4D_STOP_A;\r\noutl(mask, TRID_REG(trident, reg));\r\n}\r\nstatic int snd_trident_allocate_pcm_channel(struct snd_trident * trident)\r\n{\r\nint idx;\r\nif (trident->ChanPCMcnt >= trident->ChanPCM)\r\nreturn -1;\r\nfor (idx = 31; idx >= 0; idx--) {\r\nif (!(trident->ChanMap[T4D_BANK_B] & (1 << idx))) {\r\ntrident->ChanMap[T4D_BANK_B] |= 1 << idx;\r\ntrident->ChanPCMcnt++;\r\nreturn idx + 32;\r\n}\r\n}\r\nreturn -1;\r\n}\r\nstatic void snd_trident_free_pcm_channel(struct snd_trident *trident, int channel)\r\n{\r\nif (channel < 32 || channel > 63)\r\nreturn;\r\nchannel &= 0x1f;\r\nif (trident->ChanMap[T4D_BANK_B] & (1 << channel)) {\r\ntrident->ChanMap[T4D_BANK_B] &= ~(1 << channel);\r\ntrident->ChanPCMcnt--;\r\n}\r\n}\r\nstatic int snd_trident_allocate_synth_channel(struct snd_trident * trident)\r\n{\r\nint idx;\r\nfor (idx = 31; idx >= 0; idx--) {\r\nif (!(trident->ChanMap[T4D_BANK_A] & (1 << idx))) {\r\ntrident->ChanMap[T4D_BANK_A] |= 1 << idx;\r\ntrident->synth.ChanSynthCount++;\r\nreturn idx;\r\n}\r\n}\r\nreturn -1;\r\n}\r\nstatic void snd_trident_free_synth_channel(struct snd_trident *trident, int channel)\r\n{\r\nif (channel < 0 || channel > 31)\r\nreturn;\r\nchannel &= 0x1f;\r\nif (trident->ChanMap[T4D_BANK_A] & (1 << channel)) {\r\ntrident->ChanMap[T4D_BANK_A] &= ~(1 << channel);\r\ntrident->synth.ChanSynthCount--;\r\n}\r\n}\r\nvoid snd_trident_write_voice_regs(struct snd_trident * trident,\r\nstruct snd_trident_voice * voice)\r\n{\r\nunsigned int FmcRvolCvol;\r\nunsigned int regs[5];\r\nregs[1] = voice->LBA;\r\nregs[4] = (voice->GVSel << 31) |\r\n((voice->Pan & 0x0000007f) << 24) |\r\n((voice->CTRL & 0x0000000f) << 12);\r\nFmcRvolCvol = ((voice->FMC & 3) << 14) |\r\n((voice->RVol & 0x7f) << 7) |\r\n(voice->CVol & 0x7f);\r\nswitch (trident->device) {\r\ncase TRIDENT_DEVICE_ID_SI7018:\r\nregs[4] |= voice->number > 31 ?\r\n(voice->Vol & 0x000003ff) :\r\n((voice->Vol & 0x00003fc) << (16-2)) |\r\n(voice->EC & 0x00000fff);\r\nregs[0] = (voice->CSO << 16) | ((voice->Alpha & 0x00000fff) << 4) |\r\n(voice->FMS & 0x0000000f);\r\nregs[2] = (voice->ESO << 16) | (voice->Delta & 0x0ffff);\r\nregs[3] = (voice->Attribute << 16) | FmcRvolCvol;\r\nbreak;\r\ncase TRIDENT_DEVICE_ID_DX:\r\nregs[4] |= ((voice->Vol & 0x000003fc) << (16-2)) |\r\n(voice->EC & 0x00000fff);\r\nregs[0] = (voice->CSO << 16) | ((voice->Alpha & 0x00000fff) << 4) |\r\n(voice->FMS & 0x0000000f);\r\nregs[2] = (voice->ESO << 16) | (voice->Delta & 0x0ffff);\r\nregs[3] = FmcRvolCvol;\r\nbreak;\r\ncase TRIDENT_DEVICE_ID_NX:\r\nregs[4] |= ((voice->Vol & 0x000003fc) << (16-2)) |\r\n(voice->EC & 0x00000fff);\r\nregs[0] = (voice->Delta << 24) | (voice->CSO & 0x00ffffff);\r\nregs[2] = ((voice->Delta << 16) & 0xff000000) |\r\n(voice->ESO & 0x00ffffff);\r\nregs[3] = (voice->Alpha << 20) |\r\n((voice->FMS & 0x0000000f) << 16) | FmcRvolCvol;\r\nbreak;\r\ndefault:\r\nsnd_BUG();\r\nreturn;\r\n}\r\noutb(voice->number, TRID_REG(trident, T4D_LFO_GC_CIR));\r\noutl(regs[0], TRID_REG(trident, CH_START + 0));\r\noutl(regs[1], TRID_REG(trident, CH_START + 4));\r\noutl(regs[2], TRID_REG(trident, CH_START + 8));\r\noutl(regs[3], TRID_REG(trident, CH_START + 12));\r\noutl(regs[4], TRID_REG(trident, CH_START + 16));\r\n#if 0\r\nprintk(KERN_DEBUG "written %i channel:\n", voice->number);\r\nprintk(KERN_DEBUG " regs[0] = 0x%x/0x%x\n",\r\nregs[0], inl(TRID_REG(trident, CH_START + 0)));\r\nprintk(KERN_DEBUG " regs[1] = 0x%x/0x%x\n",\r\nregs[1], inl(TRID_REG(trident, CH_START + 4)));\r\nprintk(KERN_DEBUG " regs[2] = 0x%x/0x%x\n",\r\nregs[2], inl(TRID_REG(trident, CH_START + 8)));\r\nprintk(KERN_DEBUG " regs[3] = 0x%x/0x%x\n",\r\nregs[3], inl(TRID_REG(trident, CH_START + 12)));\r\nprintk(KERN_DEBUG " regs[4] = 0x%x/0x%x\n",\r\nregs[4], inl(TRID_REG(trident, CH_START + 16)));\r\n#endif\r\n}\r\nstatic void snd_trident_write_cso_reg(struct snd_trident * trident,\r\nstruct snd_trident_voice * voice,\r\nunsigned int CSO)\r\n{\r\nvoice->CSO = CSO;\r\noutb(voice->number, TRID_REG(trident, T4D_LFO_GC_CIR));\r\nif (trident->device != TRIDENT_DEVICE_ID_NX) {\r\noutw(voice->CSO, TRID_REG(trident, CH_DX_CSO_ALPHA_FMS) + 2);\r\n} else {\r\noutl((voice->Delta << 24) |\r\n(voice->CSO & 0x00ffffff), TRID_REG(trident, CH_NX_DELTA_CSO));\r\n}\r\n}\r\nstatic void snd_trident_write_eso_reg(struct snd_trident * trident,\r\nstruct snd_trident_voice * voice,\r\nunsigned int ESO)\r\n{\r\nvoice->ESO = ESO;\r\noutb(voice->number, TRID_REG(trident, T4D_LFO_GC_CIR));\r\nif (trident->device != TRIDENT_DEVICE_ID_NX) {\r\noutw(voice->ESO, TRID_REG(trident, CH_DX_ESO_DELTA) + 2);\r\n} else {\r\noutl(((voice->Delta << 16) & 0xff000000) | (voice->ESO & 0x00ffffff),\r\nTRID_REG(trident, CH_NX_DELTA_ESO));\r\n}\r\n}\r\nstatic void snd_trident_write_vol_reg(struct snd_trident * trident,\r\nstruct snd_trident_voice * voice,\r\nunsigned int Vol)\r\n{\r\nvoice->Vol = Vol;\r\noutb(voice->number, TRID_REG(trident, T4D_LFO_GC_CIR));\r\nswitch (trident->device) {\r\ncase TRIDENT_DEVICE_ID_DX:\r\ncase TRIDENT_DEVICE_ID_NX:\r\noutb(voice->Vol >> 2, TRID_REG(trident, CH_GVSEL_PAN_VOL_CTRL_EC + 2));\r\nbreak;\r\ncase TRIDENT_DEVICE_ID_SI7018:\r\noutw((voice->CTRL << 12) | voice->Vol,\r\nTRID_REG(trident, CH_GVSEL_PAN_VOL_CTRL_EC));\r\nbreak;\r\n}\r\n}\r\nstatic void snd_trident_write_pan_reg(struct snd_trident * trident,\r\nstruct snd_trident_voice * voice,\r\nunsigned int Pan)\r\n{\r\nvoice->Pan = Pan;\r\noutb(voice->number, TRID_REG(trident, T4D_LFO_GC_CIR));\r\noutb(((voice->GVSel & 0x01) << 7) | (voice->Pan & 0x7f),\r\nTRID_REG(trident, CH_GVSEL_PAN_VOL_CTRL_EC + 3));\r\n}\r\nstatic void snd_trident_write_rvol_reg(struct snd_trident * trident,\r\nstruct snd_trident_voice * voice,\r\nunsigned int RVol)\r\n{\r\nvoice->RVol = RVol;\r\noutb(voice->number, TRID_REG(trident, T4D_LFO_GC_CIR));\r\noutw(((voice->FMC & 0x0003) << 14) | ((voice->RVol & 0x007f) << 7) |\r\n(voice->CVol & 0x007f),\r\nTRID_REG(trident, trident->device == TRIDENT_DEVICE_ID_NX ?\r\nCH_NX_ALPHA_FMS_FMC_RVOL_CVOL : CH_DX_FMC_RVOL_CVOL));\r\n}\r\nstatic void snd_trident_write_cvol_reg(struct snd_trident * trident,\r\nstruct snd_trident_voice * voice,\r\nunsigned int CVol)\r\n{\r\nvoice->CVol = CVol;\r\noutb(voice->number, TRID_REG(trident, T4D_LFO_GC_CIR));\r\noutw(((voice->FMC & 0x0003) << 14) | ((voice->RVol & 0x007f) << 7) |\r\n(voice->CVol & 0x007f),\r\nTRID_REG(trident, trident->device == TRIDENT_DEVICE_ID_NX ?\r\nCH_NX_ALPHA_FMS_FMC_RVOL_CVOL : CH_DX_FMC_RVOL_CVOL));\r\n}\r\nstatic unsigned int snd_trident_convert_rate(unsigned int rate)\r\n{\r\nunsigned int delta;\r\nif (rate == 44100)\r\ndelta = 0xeb3;\r\nelse if (rate == 8000)\r\ndelta = 0x2ab;\r\nelse if (rate == 48000)\r\ndelta = 0x1000;\r\nelse\r\ndelta = (((rate << 12) + 24000) / 48000) & 0x0000ffff;\r\nreturn delta;\r\n}\r\nstatic unsigned int snd_trident_convert_adc_rate(unsigned int rate)\r\n{\r\nunsigned int delta;\r\nif (rate == 44100)\r\ndelta = 0x116a;\r\nelse if (rate == 8000)\r\ndelta = 0x6000;\r\nelse if (rate == 48000)\r\ndelta = 0x1000;\r\nelse\r\ndelta = ((48000 << 12) / rate) & 0x0000ffff;\r\nreturn delta;\r\n}\r\nstatic unsigned int snd_trident_spurious_threshold(unsigned int rate,\r\nunsigned int period_size)\r\n{\r\nunsigned int res = (rate * period_size) / 48000;\r\nif (res < 64)\r\nres = res / 2;\r\nelse\r\nres -= 32;\r\nreturn res;\r\n}\r\nstatic unsigned int snd_trident_control_mode(struct snd_pcm_substream *substream)\r\n{\r\nunsigned int CTRL;\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nCTRL = 0x00000001;\r\nif (snd_pcm_format_width(runtime->format) == 16)\r\nCTRL |= 0x00000008;\r\nif (snd_pcm_format_signed(runtime->format))\r\nCTRL |= 0x00000002;\r\nif (runtime->channels > 1)\r\nCTRL |= 0x00000004;\r\nreturn CTRL;\r\n}\r\nstatic int snd_trident_ioctl(struct snd_pcm_substream *substream,\r\nunsigned int cmd,\r\nvoid *arg)\r\n{\r\nreturn snd_pcm_lib_ioctl(substream, cmd, arg);\r\n}\r\nstatic int snd_trident_allocate_pcm_mem(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *hw_params)\r\n{\r\nstruct snd_trident *trident = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct snd_trident_voice *voice = runtime->private_data;\r\nint err;\r\nif ((err = snd_pcm_lib_malloc_pages(substream, params_buffer_bytes(hw_params))) < 0)\r\nreturn err;\r\nif (trident->tlb.entries) {\r\nif (err > 0) {\r\nif (voice->memblk)\r\nsnd_trident_free_pages(trident, voice->memblk);\r\nvoice->memblk = snd_trident_alloc_pages(trident, substream);\r\nif (voice->memblk == NULL)\r\nreturn -ENOMEM;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_trident_allocate_evoice(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *hw_params)\r\n{\r\nstruct snd_trident *trident = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct snd_trident_voice *voice = runtime->private_data;\r\nstruct snd_trident_voice *evoice = voice->extra;\r\nif (params_buffer_size(hw_params) / 2 != params_period_size(hw_params)) {\r\nif (evoice == NULL) {\r\nevoice = snd_trident_alloc_voice(trident, SNDRV_TRIDENT_VOICE_TYPE_PCM, 0, 0);\r\nif (evoice == NULL)\r\nreturn -ENOMEM;\r\nvoice->extra = evoice;\r\nevoice->substream = substream;\r\n}\r\n} else {\r\nif (evoice != NULL) {\r\nsnd_trident_free_voice(trident, evoice);\r\nvoice->extra = evoice = NULL;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_trident_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *hw_params)\r\n{\r\nint err;\r\nerr = snd_trident_allocate_pcm_mem(substream, hw_params);\r\nif (err >= 0)\r\nerr = snd_trident_allocate_evoice(substream, hw_params);\r\nreturn err;\r\n}\r\nstatic int snd_trident_hw_free(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_trident *trident = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct snd_trident_voice *voice = runtime->private_data;\r\nstruct snd_trident_voice *evoice = voice ? voice->extra : NULL;\r\nif (trident->tlb.entries) {\r\nif (voice && voice->memblk) {\r\nsnd_trident_free_pages(trident, voice->memblk);\r\nvoice->memblk = NULL;\r\n}\r\n}\r\nsnd_pcm_lib_free_pages(substream);\r\nif (evoice != NULL) {\r\nsnd_trident_free_voice(trident, evoice);\r\nvoice->extra = NULL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_trident_playback_prepare(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_trident *trident = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct snd_trident_voice *voice = runtime->private_data;\r\nstruct snd_trident_voice *evoice = voice->extra;\r\nstruct snd_trident_pcm_mixer *mix = &trident->pcm_mixer[substream->number];\r\nspin_lock_irq(&trident->reg_lock);\r\nvoice->Delta = snd_trident_convert_rate(runtime->rate);\r\nvoice->spurious_threshold = snd_trident_spurious_threshold(runtime->rate, runtime->period_size);\r\nif (voice->memblk)\r\nvoice->LBA = voice->memblk->offset;\r\nelse\r\nvoice->LBA = runtime->dma_addr;\r\nvoice->CSO = 0;\r\nvoice->ESO = runtime->buffer_size - 1;\r\nvoice->CTRL = snd_trident_control_mode(substream);\r\nvoice->FMC = 3;\r\nvoice->GVSel = 1;\r\nvoice->EC = 0;\r\nvoice->Alpha = 0;\r\nvoice->FMS = 0;\r\nvoice->Vol = mix->vol;\r\nvoice->RVol = mix->rvol;\r\nvoice->CVol = mix->cvol;\r\nvoice->Pan = mix->pan;\r\nvoice->Attribute = 0;\r\n#if 0\r\nvoice->Attribute = (1<<(30-16))|(2<<(26-16))|\r\n(0<<(24-16))|(0x1f<<(19-16));\r\n#else\r\nvoice->Attribute = 0;\r\n#endif\r\nsnd_trident_write_voice_regs(trident, voice);\r\nif (evoice != NULL) {\r\nevoice->Delta = voice->Delta;\r\nevoice->spurious_threshold = voice->spurious_threshold;\r\nevoice->LBA = voice->LBA;\r\nevoice->CSO = 0;\r\nevoice->ESO = (runtime->period_size * 2) + 4 - 1;\r\nevoice->CTRL = voice->CTRL;\r\nevoice->FMC = 3;\r\nevoice->GVSel = trident->device == TRIDENT_DEVICE_ID_SI7018 ? 0 : 1;\r\nevoice->EC = 0;\r\nevoice->Alpha = 0;\r\nevoice->FMS = 0;\r\nevoice->Vol = 0x3ff;\r\nevoice->RVol = evoice->CVol = 0x7f;\r\nevoice->Pan = 0x7f;\r\n#if 0\r\nevoice->Attribute = (1<<(30-16))|(2<<(26-16))|\r\n(0<<(24-16))|(0x1f<<(19-16));\r\n#else\r\nevoice->Attribute = 0;\r\n#endif\r\nsnd_trident_write_voice_regs(trident, evoice);\r\nevoice->isync2 = 1;\r\nevoice->isync_mark = runtime->period_size;\r\nevoice->ESO = (runtime->period_size * 2) - 1;\r\n}\r\nspin_unlock_irq(&trident->reg_lock);\r\nreturn 0;\r\n}\r\nstatic int snd_trident_capture_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *hw_params)\r\n{\r\nreturn snd_trident_allocate_pcm_mem(substream, hw_params);\r\n}\r\nstatic int snd_trident_capture_prepare(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_trident *trident = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct snd_trident_voice *voice = runtime->private_data;\r\nunsigned int val, ESO_bytes;\r\nspin_lock_irq(&trident->reg_lock);\r\noutb(0, TRID_REG(trident, LEGACY_DMAR15));\r\noutb(0x54, TRID_REG(trident, LEGACY_DMAR11));\r\nvoice->LBA = runtime->dma_addr;\r\noutl(voice->LBA, TRID_REG(trident, LEGACY_DMAR0));\r\nif (voice->memblk)\r\nvoice->LBA = voice->memblk->offset;\r\nESO_bytes = snd_pcm_lib_buffer_bytes(substream) - 1;\r\noutb((ESO_bytes & 0x00ff0000) >> 16, TRID_REG(trident, LEGACY_DMAR6));\r\noutw((ESO_bytes & 0x0000ffff), TRID_REG(trident, LEGACY_DMAR4));\r\nESO_bytes++;\r\nval = (((unsigned int) 48000L << 12) + (runtime->rate/2)) / runtime->rate;\r\noutw(val, TRID_REG(trident, T4D_SBDELTA_DELTA_R));\r\nif (snd_pcm_format_width(runtime->format) == 16) {\r\nval = (unsigned short) ((ESO_bytes >> 1) - 1);\r\n} else {\r\nval = (unsigned short) (ESO_bytes - 1);\r\n}\r\noutl((val << 16) | val, TRID_REG(trident, T4D_SBBL_SBCL));\r\ntrident->bDMAStart = 0x19;\r\nif (snd_pcm_format_width(runtime->format) == 16)\r\ntrident->bDMAStart |= 0x80;\r\nif (snd_pcm_format_signed(runtime->format))\r\ntrident->bDMAStart |= 0x20;\r\nif (runtime->channels > 1)\r\ntrident->bDMAStart |= 0x40;\r\nvoice->Delta = snd_trident_convert_rate(runtime->rate);\r\nvoice->spurious_threshold = snd_trident_spurious_threshold(runtime->rate, runtime->period_size);\r\nvoice->isync = 1;\r\nvoice->isync_mark = runtime->period_size;\r\nvoice->isync_max = runtime->buffer_size;\r\nvoice->CSO = 0;\r\nvoice->ESO = voice->isync_ESO = (runtime->period_size * 2) + 6 - 1;\r\nvoice->CTRL = snd_trident_control_mode(substream);\r\nvoice->FMC = 3;\r\nvoice->RVol = 0x7f;\r\nvoice->CVol = 0x7f;\r\nvoice->GVSel = 1;\r\nvoice->Pan = 0x7f;\r\nvoice->Vol = 0x3ff;\r\nvoice->EC = 0;\r\nvoice->Alpha = 0;\r\nvoice->FMS = 0;\r\nvoice->Attribute = 0;\r\nsnd_trident_write_voice_regs(trident, voice);\r\nspin_unlock_irq(&trident->reg_lock);\r\nreturn 0;\r\n}\r\nstatic int snd_trident_si7018_capture_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *hw_params)\r\n{\r\nint err;\r\nif ((err = snd_pcm_lib_malloc_pages(substream, params_buffer_bytes(hw_params))) < 0)\r\nreturn err;\r\nreturn snd_trident_allocate_evoice(substream, hw_params);\r\n}\r\nstatic int snd_trident_si7018_capture_hw_free(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_trident *trident = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct snd_trident_voice *voice = runtime->private_data;\r\nstruct snd_trident_voice *evoice = voice ? voice->extra : NULL;\r\nsnd_pcm_lib_free_pages(substream);\r\nif (evoice != NULL) {\r\nsnd_trident_free_voice(trident, evoice);\r\nvoice->extra = NULL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_trident_si7018_capture_prepare(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_trident *trident = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct snd_trident_voice *voice = runtime->private_data;\r\nstruct snd_trident_voice *evoice = voice->extra;\r\nspin_lock_irq(&trident->reg_lock);\r\nvoice->LBA = runtime->dma_addr;\r\nvoice->Delta = snd_trident_convert_adc_rate(runtime->rate);\r\nvoice->spurious_threshold = snd_trident_spurious_threshold(runtime->rate, runtime->period_size);\r\nvoice->CSO = 0;\r\nvoice->ESO = runtime->buffer_size - 1;\r\nvoice->CTRL = snd_trident_control_mode(substream);\r\nvoice->FMC = 0;\r\nvoice->RVol = 0;\r\nvoice->CVol = 0;\r\nvoice->GVSel = 1;\r\nvoice->Pan = T4D_DEFAULT_PCM_PAN;\r\nvoice->Vol = 0;\r\nvoice->EC = 0;\r\nvoice->Alpha = 0;\r\nvoice->FMS = 0;\r\nvoice->Attribute = (2 << (30-16)) |\r\n(2 << (26-16)) |\r\n(2 << (24-16)) |\r\n(1 << (23-16));\r\nsnd_trident_write_voice_regs(trident, voice);\r\nif (evoice != NULL) {\r\nevoice->Delta = snd_trident_convert_rate(runtime->rate);\r\nevoice->spurious_threshold = voice->spurious_threshold;\r\nevoice->LBA = voice->LBA;\r\nevoice->CSO = 0;\r\nevoice->ESO = (runtime->period_size * 2) + 20 - 1;\r\nevoice->CTRL = voice->CTRL;\r\nevoice->FMC = 3;\r\nevoice->GVSel = 0;\r\nevoice->EC = 0;\r\nevoice->Alpha = 0;\r\nevoice->FMS = 0;\r\nevoice->Vol = 0x3ff;\r\nevoice->RVol = evoice->CVol = 0x7f;\r\nevoice->Pan = 0x7f;\r\nevoice->Attribute = 0;\r\nsnd_trident_write_voice_regs(trident, evoice);\r\nevoice->isync2 = 1;\r\nevoice->isync_mark = runtime->period_size;\r\nevoice->ESO = (runtime->period_size * 2) - 1;\r\n}\r\nspin_unlock_irq(&trident->reg_lock);\r\nreturn 0;\r\n}\r\nstatic int snd_trident_foldback_prepare(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_trident *trident = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct snd_trident_voice *voice = runtime->private_data;\r\nstruct snd_trident_voice *evoice = voice->extra;\r\nspin_lock_irq(&trident->reg_lock);\r\nif (voice->memblk)\r\nvoice->LBA = voice->memblk->offset;\r\nelse\r\nvoice->LBA = runtime->dma_addr;\r\nvoice->ESO = runtime->buffer_size - 1;\r\nvoice->Delta = 0x1000;\r\nvoice->spurious_threshold = snd_trident_spurious_threshold(48000, runtime->period_size);\r\nvoice->CSO = 0;\r\nvoice->CTRL = snd_trident_control_mode(substream);\r\nvoice->FMC = 3;\r\nvoice->RVol = 0x7f;\r\nvoice->CVol = 0x7f;\r\nvoice->GVSel = 1;\r\nvoice->Pan = 0x7f;\r\nvoice->Vol = 0x3ff;\r\nvoice->EC = 0;\r\nvoice->Alpha = 0;\r\nvoice->FMS = 0;\r\nvoice->Attribute = 0;\r\noutb(((voice->number & 0x3f) | 0x80), TRID_REG(trident, T4D_RCI + voice->foldback_chan));\r\nsnd_trident_write_voice_regs(trident, voice);\r\nif (evoice != NULL) {\r\nevoice->Delta = voice->Delta;\r\nevoice->spurious_threshold = voice->spurious_threshold;\r\nevoice->LBA = voice->LBA;\r\nevoice->CSO = 0;\r\nevoice->ESO = (runtime->period_size * 2) + 4 - 1;\r\nevoice->CTRL = voice->CTRL;\r\nevoice->FMC = 3;\r\nevoice->GVSel = trident->device == TRIDENT_DEVICE_ID_SI7018 ? 0 : 1;\r\nevoice->EC = 0;\r\nevoice->Alpha = 0;\r\nevoice->FMS = 0;\r\nevoice->Vol = 0x3ff;\r\nevoice->RVol = evoice->CVol = 0x7f;\r\nevoice->Pan = 0x7f;\r\nevoice->Attribute = 0;\r\nsnd_trident_write_voice_regs(trident, evoice);\r\nevoice->isync2 = 1;\r\nevoice->isync_mark = runtime->period_size;\r\nevoice->ESO = (runtime->period_size * 2) - 1;\r\n}\r\nspin_unlock_irq(&trident->reg_lock);\r\nreturn 0;\r\n}\r\nstatic int snd_trident_spdif_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *hw_params)\r\n{\r\nstruct snd_trident *trident = snd_pcm_substream_chip(substream);\r\nunsigned int old_bits = 0, change = 0;\r\nint err;\r\nerr = snd_trident_allocate_pcm_mem(substream, hw_params);\r\nif (err < 0)\r\nreturn err;\r\nif (trident->device == TRIDENT_DEVICE_ID_SI7018) {\r\nerr = snd_trident_allocate_evoice(substream, hw_params);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nspin_lock_irq(&trident->reg_lock);\r\nold_bits = trident->spdif_pcm_bits;\r\nif (old_bits & IEC958_AES0_PROFESSIONAL)\r\ntrident->spdif_pcm_bits &= ~IEC958_AES0_PRO_FS;\r\nelse\r\ntrident->spdif_pcm_bits &= ~(IEC958_AES3_CON_FS << 24);\r\nif (params_rate(hw_params) >= 48000) {\r\ntrident->spdif_pcm_ctrl = 0x3c;\r\ntrident->spdif_pcm_bits |=\r\ntrident->spdif_bits & IEC958_AES0_PROFESSIONAL ?\r\nIEC958_AES0_PRO_FS_48000 :\r\n(IEC958_AES3_CON_FS_48000 << 24);\r\n}\r\nelse if (params_rate(hw_params) >= 44100) {\r\ntrident->spdif_pcm_ctrl = 0x3e;\r\ntrident->spdif_pcm_bits |=\r\ntrident->spdif_bits & IEC958_AES0_PROFESSIONAL ?\r\nIEC958_AES0_PRO_FS_44100 :\r\n(IEC958_AES3_CON_FS_44100 << 24);\r\n}\r\nelse {\r\ntrident->spdif_pcm_ctrl = 0x3d;\r\ntrident->spdif_pcm_bits |=\r\ntrident->spdif_bits & IEC958_AES0_PROFESSIONAL ?\r\nIEC958_AES0_PRO_FS_32000 :\r\n(IEC958_AES3_CON_FS_32000 << 24);\r\n}\r\nchange = old_bits != trident->spdif_pcm_bits;\r\nspin_unlock_irq(&trident->reg_lock);\r\nif (change)\r\nsnd_ctl_notify(trident->card, SNDRV_CTL_EVENT_MASK_VALUE, &trident->spdif_pcm_ctl->id);\r\nreturn 0;\r\n}\r\nstatic int snd_trident_spdif_prepare(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_trident *trident = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct snd_trident_voice *voice = runtime->private_data;\r\nstruct snd_trident_voice *evoice = voice->extra;\r\nstruct snd_trident_pcm_mixer *mix = &trident->pcm_mixer[substream->number];\r\nunsigned int RESO, LBAO;\r\nunsigned int temp;\r\nspin_lock_irq(&trident->reg_lock);\r\nif (trident->device != TRIDENT_DEVICE_ID_SI7018) {\r\nvoice->Delta = snd_trident_convert_rate(runtime->rate);\r\nvoice->spurious_threshold = snd_trident_spurious_threshold(runtime->rate, runtime->period_size);\r\nLBAO = runtime->dma_addr;\r\nif (voice->memblk)\r\nvoice->LBA = voice->memblk->offset;\r\nelse\r\nvoice->LBA = LBAO;\r\nvoice->isync = 1;\r\nvoice->isync3 = 1;\r\nvoice->isync_mark = runtime->period_size;\r\nvoice->isync_max = runtime->buffer_size;\r\nRESO = runtime->buffer_size - 1;\r\nvoice->ESO = voice->isync_ESO = (runtime->period_size * 2) + 6 - 1;\r\nvoice->CTRL = snd_trident_control_mode(substream);\r\nvoice->FMC = 3;\r\nvoice->RVol = 0x7f;\r\nvoice->CVol = 0x7f;\r\nvoice->GVSel = 1;\r\nvoice->Pan = 0x7f;\r\nvoice->Vol = 0x3ff;\r\nvoice->EC = 0;\r\nvoice->CSO = 0;\r\nvoice->Alpha = 0;\r\nvoice->FMS = 0;\r\nvoice->Attribute = 0;\r\nsnd_trident_write_voice_regs(trident, voice);\r\noutw((RESO & 0xffff), TRID_REG(trident, NX_SPESO));\r\noutb((RESO >> 16), TRID_REG(trident, NX_SPESO + 2));\r\noutl((LBAO & 0xfffffffc), TRID_REG(trident, NX_SPLBA));\r\noutw((voice->CSO & 0xffff), TRID_REG(trident, NX_SPCTRL_SPCSO));\r\noutb((voice->CSO >> 16), TRID_REG(trident, NX_SPCTRL_SPCSO + 2));\r\noutb(trident->spdif_pcm_ctrl, TRID_REG(trident, NX_SPCTRL_SPCSO + 3));\r\noutl(trident->spdif_pcm_bits, TRID_REG(trident, NX_SPCSTATUS));\r\n} else {\r\nvoice->Delta = 0x800;\r\nvoice->spurious_threshold = snd_trident_spurious_threshold(48000, runtime->period_size);\r\nif (voice->memblk)\r\nvoice->LBA = voice->memblk->offset;\r\nelse\r\nvoice->LBA = runtime->dma_addr;\r\nvoice->CSO = 0;\r\nvoice->ESO = runtime->buffer_size - 1;\r\nvoice->CTRL = snd_trident_control_mode(substream);\r\nvoice->FMC = 3;\r\nvoice->GVSel = 1;\r\nvoice->EC = 0;\r\nvoice->Alpha = 0;\r\nvoice->FMS = 0;\r\nvoice->Vol = mix->vol;\r\nvoice->RVol = mix->rvol;\r\nvoice->CVol = mix->cvol;\r\nvoice->Pan = mix->pan;\r\nvoice->Attribute = (1<<(30-16))|(7<<(26-16))|\r\n(0<<(24-16))|(0<<(19-16));\r\nsnd_trident_write_voice_regs(trident, voice);\r\nif (evoice != NULL) {\r\nevoice->Delta = voice->Delta;\r\nevoice->spurious_threshold = voice->spurious_threshold;\r\nevoice->LBA = voice->LBA;\r\nevoice->CSO = 0;\r\nevoice->ESO = (runtime->period_size * 2) + 4 - 1;\r\nevoice->CTRL = voice->CTRL;\r\nevoice->FMC = 3;\r\nevoice->GVSel = trident->device == TRIDENT_DEVICE_ID_SI7018 ? 0 : 1;\r\nevoice->EC = 0;\r\nevoice->Alpha = 0;\r\nevoice->FMS = 0;\r\nevoice->Vol = 0x3ff;\r\nevoice->RVol = evoice->CVol = 0x7f;\r\nevoice->Pan = 0x7f;\r\nevoice->Attribute = 0;\r\nsnd_trident_write_voice_regs(trident, evoice);\r\nevoice->isync2 = 1;\r\nevoice->isync_mark = runtime->period_size;\r\nevoice->ESO = (runtime->period_size * 2) - 1;\r\n}\r\noutl(trident->spdif_pcm_bits, TRID_REG(trident, SI_SPDIF_CS));\r\ntemp = inl(TRID_REG(trident, T4D_LFO_GC_CIR));\r\ntemp &= ~(1<<19);\r\noutl(temp, TRID_REG(trident, T4D_LFO_GC_CIR));\r\ntemp = inl(TRID_REG(trident, SI_SERIAL_INTF_CTRL));\r\ntemp |= SPDIF_EN;\r\noutl(temp, TRID_REG(trident, SI_SERIAL_INTF_CTRL));\r\n}\r\nspin_unlock_irq(&trident->reg_lock);\r\nreturn 0;\r\n}\r\nstatic int snd_trident_trigger(struct snd_pcm_substream *substream,\r\nint cmd)\r\n{\r\nstruct snd_trident *trident = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_substream *s;\r\nunsigned int what, whati, capture_flag, spdif_flag;\r\nstruct snd_trident_voice *voice, *evoice;\r\nunsigned int val, go;\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\ncase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\r\ncase SNDRV_PCM_TRIGGER_RESUME:\r\ngo = 1;\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\ncase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\r\ncase SNDRV_PCM_TRIGGER_SUSPEND:\r\ngo = 0;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nwhat = whati = capture_flag = spdif_flag = 0;\r\nspin_lock(&trident->reg_lock);\r\nval = inl(TRID_REG(trident, T4D_STIMER)) & 0x00ffffff;\r\nsnd_pcm_group_for_each_entry(s, substream) {\r\nif ((struct snd_trident *) snd_pcm_substream_chip(s) == trident) {\r\nvoice = s->runtime->private_data;\r\nevoice = voice->extra;\r\nwhat |= 1 << (voice->number & 0x1f);\r\nif (evoice == NULL) {\r\nwhati |= 1 << (voice->number & 0x1f);\r\n} else {\r\nwhat |= 1 << (evoice->number & 0x1f);\r\nwhati |= 1 << (evoice->number & 0x1f);\r\nif (go)\r\nevoice->stimer = val;\r\n}\r\nif (go) {\r\nvoice->running = 1;\r\nvoice->stimer = val;\r\n} else {\r\nvoice->running = 0;\r\n}\r\nsnd_pcm_trigger_done(s, substream);\r\nif (voice->capture)\r\ncapture_flag = 1;\r\nif (voice->spdif)\r\nspdif_flag = 1;\r\n}\r\n}\r\nif (spdif_flag) {\r\nif (trident->device != TRIDENT_DEVICE_ID_SI7018) {\r\noutl(trident->spdif_pcm_bits, TRID_REG(trident, NX_SPCSTATUS));\r\nval = trident->spdif_pcm_ctrl;\r\nif (!go)\r\nval &= ~(0x28);\r\noutb(val, TRID_REG(trident, NX_SPCTRL_SPCSO + 3));\r\n} else {\r\noutl(trident->spdif_pcm_bits, TRID_REG(trident, SI_SPDIF_CS));\r\nval = inl(TRID_REG(trident, SI_SERIAL_INTF_CTRL)) | SPDIF_EN;\r\noutl(val, TRID_REG(trident, SI_SERIAL_INTF_CTRL));\r\n}\r\n}\r\nif (!go)\r\noutl(what, TRID_REG(trident, T4D_STOP_B));\r\nval = inl(TRID_REG(trident, T4D_AINTEN_B));\r\nif (go) {\r\nval |= whati;\r\n} else {\r\nval &= ~whati;\r\n}\r\noutl(val, TRID_REG(trident, T4D_AINTEN_B));\r\nif (go) {\r\noutl(what, TRID_REG(trident, T4D_START_B));\r\nif (capture_flag && trident->device != TRIDENT_DEVICE_ID_SI7018)\r\noutb(trident->bDMAStart, TRID_REG(trident, T4D_SBCTRL_SBE2R_SBDD));\r\n} else {\r\nif (capture_flag && trident->device != TRIDENT_DEVICE_ID_SI7018)\r\noutb(0x00, TRID_REG(trident, T4D_SBCTRL_SBE2R_SBDD));\r\n}\r\nspin_unlock(&trident->reg_lock);\r\nreturn 0;\r\n}\r\nstatic snd_pcm_uframes_t snd_trident_playback_pointer(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_trident *trident = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct snd_trident_voice *voice = runtime->private_data;\r\nunsigned int cso;\r\nif (!voice->running)\r\nreturn 0;\r\nspin_lock(&trident->reg_lock);\r\noutb(voice->number, TRID_REG(trident, T4D_LFO_GC_CIR));\r\nif (trident->device != TRIDENT_DEVICE_ID_NX) {\r\ncso = inw(TRID_REG(trident, CH_DX_CSO_ALPHA_FMS + 2));\r\n} else {\r\ncso = (unsigned int) inl(TRID_REG(trident, CH_NX_DELTA_CSO)) & 0x00ffffff;\r\n}\r\nspin_unlock(&trident->reg_lock);\r\nif (cso >= runtime->buffer_size)\r\ncso = 0;\r\nreturn cso;\r\n}\r\nstatic snd_pcm_uframes_t snd_trident_capture_pointer(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_trident *trident = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct snd_trident_voice *voice = runtime->private_data;\r\nunsigned int result;\r\nif (!voice->running)\r\nreturn 0;\r\nresult = inw(TRID_REG(trident, T4D_SBBL_SBCL));\r\nif (runtime->channels > 1)\r\nresult >>= 1;\r\nif (result > 0)\r\nresult = runtime->buffer_size - result;\r\nreturn result;\r\n}\r\nstatic snd_pcm_uframes_t snd_trident_spdif_pointer(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_trident *trident = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct snd_trident_voice *voice = runtime->private_data;\r\nunsigned int result;\r\nif (!voice->running)\r\nreturn 0;\r\nresult = inl(TRID_REG(trident, NX_SPCTRL_SPCSO)) & 0x00ffffff;\r\nreturn result;\r\n}\r\nstatic void snd_trident_pcm_free_substream(struct snd_pcm_runtime *runtime)\r\n{\r\nstruct snd_trident_voice *voice = runtime->private_data;\r\nstruct snd_trident *trident;\r\nif (voice) {\r\ntrident = voice->trident;\r\nsnd_trident_free_voice(trident, voice);\r\n}\r\n}\r\nstatic int snd_trident_playback_open(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_trident *trident = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct snd_trident_voice *voice;\r\nvoice = snd_trident_alloc_voice(trident, SNDRV_TRIDENT_VOICE_TYPE_PCM, 0, 0);\r\nif (voice == NULL)\r\nreturn -EAGAIN;\r\nsnd_trident_pcm_mixer_build(trident, voice, substream);\r\nvoice->substream = substream;\r\nruntime->private_data = voice;\r\nruntime->private_free = snd_trident_pcm_free_substream;\r\nruntime->hw = snd_trident_playback;\r\nsnd_pcm_set_sync(substream);\r\nsnd_pcm_hw_constraint_minmax(runtime, SNDRV_PCM_HW_PARAM_BUFFER_SIZE, 0, 64*1024);\r\nreturn 0;\r\n}\r\nstatic int snd_trident_playback_close(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_trident *trident = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct snd_trident_voice *voice = runtime->private_data;\r\nsnd_trident_pcm_mixer_free(trident, voice, substream);\r\nreturn 0;\r\n}\r\nstatic int snd_trident_spdif_open(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_trident *trident = snd_pcm_substream_chip(substream);\r\nstruct snd_trident_voice *voice;\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nvoice = snd_trident_alloc_voice(trident, SNDRV_TRIDENT_VOICE_TYPE_PCM, 0, 0);\r\nif (voice == NULL)\r\nreturn -EAGAIN;\r\nvoice->spdif = 1;\r\nvoice->substream = substream;\r\nspin_lock_irq(&trident->reg_lock);\r\ntrident->spdif_pcm_bits = trident->spdif_bits;\r\nspin_unlock_irq(&trident->reg_lock);\r\nruntime->private_data = voice;\r\nruntime->private_free = snd_trident_pcm_free_substream;\r\nif (trident->device == TRIDENT_DEVICE_ID_SI7018) {\r\nruntime->hw = snd_trident_spdif;\r\n} else {\r\nruntime->hw = snd_trident_spdif_7018;\r\n}\r\ntrident->spdif_pcm_ctl->vd[0].access &= ~SNDRV_CTL_ELEM_ACCESS_INACTIVE;\r\nsnd_ctl_notify(trident->card, SNDRV_CTL_EVENT_MASK_VALUE |\r\nSNDRV_CTL_EVENT_MASK_INFO, &trident->spdif_pcm_ctl->id);\r\nsnd_pcm_hw_constraint_minmax(runtime, SNDRV_PCM_HW_PARAM_BUFFER_SIZE, 0, 64*1024);\r\nreturn 0;\r\n}\r\nstatic int snd_trident_spdif_close(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_trident *trident = snd_pcm_substream_chip(substream);\r\nunsigned int temp;\r\nspin_lock_irq(&trident->reg_lock);\r\nif (trident->device != TRIDENT_DEVICE_ID_SI7018) {\r\noutb(trident->spdif_ctrl, TRID_REG(trident, NX_SPCTRL_SPCSO + 3));\r\noutl(trident->spdif_bits, TRID_REG(trident, NX_SPCSTATUS));\r\n} else {\r\noutl(trident->spdif_bits, TRID_REG(trident, SI_SPDIF_CS));\r\ntemp = inl(TRID_REG(trident, SI_SERIAL_INTF_CTRL));\r\nif (trident->spdif_ctrl) {\r\ntemp |= SPDIF_EN;\r\n} else {\r\ntemp &= ~SPDIF_EN;\r\n}\r\noutl(temp, TRID_REG(trident, SI_SERIAL_INTF_CTRL));\r\n}\r\nspin_unlock_irq(&trident->reg_lock);\r\ntrident->spdif_pcm_ctl->vd[0].access |= SNDRV_CTL_ELEM_ACCESS_INACTIVE;\r\nsnd_ctl_notify(trident->card, SNDRV_CTL_EVENT_MASK_VALUE |\r\nSNDRV_CTL_EVENT_MASK_INFO, &trident->spdif_pcm_ctl->id);\r\nreturn 0;\r\n}\r\nstatic int snd_trident_capture_open(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_trident *trident = snd_pcm_substream_chip(substream);\r\nstruct snd_trident_voice *voice;\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nvoice = snd_trident_alloc_voice(trident, SNDRV_TRIDENT_VOICE_TYPE_PCM, 0, 0);\r\nif (voice == NULL)\r\nreturn -EAGAIN;\r\nvoice->capture = 1;\r\nvoice->substream = substream;\r\nruntime->private_data = voice;\r\nruntime->private_free = snd_trident_pcm_free_substream;\r\nruntime->hw = snd_trident_capture;\r\nsnd_pcm_set_sync(substream);\r\nsnd_pcm_hw_constraint_minmax(runtime, SNDRV_PCM_HW_PARAM_BUFFER_SIZE, 0, 64*1024);\r\nreturn 0;\r\n}\r\nstatic int snd_trident_capture_close(struct snd_pcm_substream *substream)\r\n{\r\nreturn 0;\r\n}\r\nstatic int snd_trident_foldback_open(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_trident *trident = snd_pcm_substream_chip(substream);\r\nstruct snd_trident_voice *voice;\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nvoice = snd_trident_alloc_voice(trident, SNDRV_TRIDENT_VOICE_TYPE_PCM, 0, 0);\r\nif (voice == NULL)\r\nreturn -EAGAIN;\r\nvoice->foldback_chan = substream->number;\r\nvoice->substream = substream;\r\nruntime->private_data = voice;\r\nruntime->private_free = snd_trident_pcm_free_substream;\r\nruntime->hw = snd_trident_foldback;\r\nsnd_pcm_hw_constraint_minmax(runtime, SNDRV_PCM_HW_PARAM_BUFFER_SIZE, 0, 64*1024);\r\nreturn 0;\r\n}\r\nstatic int snd_trident_foldback_close(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_trident *trident = snd_pcm_substream_chip(substream);\r\nstruct snd_trident_voice *voice;\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nvoice = runtime->private_data;\r\nspin_lock_irq(&trident->reg_lock);\r\noutb(0x00, TRID_REG(trident, T4D_RCI + voice->foldback_chan));\r\nspin_unlock_irq(&trident->reg_lock);\r\nreturn 0;\r\n}\r\nint snd_trident_pcm(struct snd_trident *trident,\r\nint device, struct snd_pcm **rpcm)\r\n{\r\nstruct snd_pcm *pcm;\r\nint err;\r\nif (rpcm)\r\n*rpcm = NULL;\r\nif ((err = snd_pcm_new(trident->card, "trident_dx_nx", device, trident->ChanPCM, 1, &pcm)) < 0)\r\nreturn err;\r\npcm->private_data = trident;\r\nif (trident->tlb.entries) {\r\nsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &snd_trident_nx_playback_ops);\r\n} else {\r\nsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &snd_trident_playback_ops);\r\n}\r\nsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE,\r\ntrident->device != TRIDENT_DEVICE_ID_SI7018 ?\r\n&snd_trident_capture_ops :\r\n&snd_trident_si7018_capture_ops);\r\npcm->info_flags = 0;\r\npcm->dev_subclass = SNDRV_PCM_SUBCLASS_GENERIC_MIX;\r\nstrcpy(pcm->name, "Trident 4DWave");\r\ntrident->pcm = pcm;\r\nif (trident->tlb.entries) {\r\nstruct snd_pcm_substream *substream;\r\nfor (substream = pcm->streams[SNDRV_PCM_STREAM_PLAYBACK].substream; substream; substream = substream->next)\r\nsnd_pcm_lib_preallocate_pages(substream, SNDRV_DMA_TYPE_DEV_SG,\r\nsnd_dma_pci_data(trident->pci),\r\n64*1024, 128*1024);\r\nsnd_pcm_lib_preallocate_pages(pcm->streams[SNDRV_PCM_STREAM_CAPTURE].substream,\r\nSNDRV_DMA_TYPE_DEV, snd_dma_pci_data(trident->pci),\r\n64*1024, 128*1024);\r\n} else {\r\nsnd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_DEV,\r\nsnd_dma_pci_data(trident->pci), 64*1024, 128*1024);\r\n}\r\nif (rpcm)\r\n*rpcm = pcm;\r\nreturn 0;\r\n}\r\nint snd_trident_foldback_pcm(struct snd_trident *trident,\r\nint device, struct snd_pcm **rpcm)\r\n{\r\nstruct snd_pcm *foldback;\r\nint err;\r\nint num_chan = 3;\r\nstruct snd_pcm_substream *substream;\r\nif (rpcm)\r\n*rpcm = NULL;\r\nif (trident->device == TRIDENT_DEVICE_ID_NX)\r\nnum_chan = 4;\r\nif ((err = snd_pcm_new(trident->card, "trident_dx_nx", device, 0, num_chan, &foldback)) < 0)\r\nreturn err;\r\nfoldback->private_data = trident;\r\nif (trident->tlb.entries)\r\nsnd_pcm_set_ops(foldback, SNDRV_PCM_STREAM_CAPTURE, &snd_trident_nx_foldback_ops);\r\nelse\r\nsnd_pcm_set_ops(foldback, SNDRV_PCM_STREAM_CAPTURE, &snd_trident_foldback_ops);\r\nfoldback->info_flags = 0;\r\nstrcpy(foldback->name, "Trident 4DWave");\r\nsubstream = foldback->streams[SNDRV_PCM_STREAM_CAPTURE].substream;\r\nstrcpy(substream->name, "Front Mixer");\r\nsubstream = substream->next;\r\nstrcpy(substream->name, "Reverb Mixer");\r\nsubstream = substream->next;\r\nstrcpy(substream->name, "Chorus Mixer");\r\nif (num_chan == 4) {\r\nsubstream = substream->next;\r\nstrcpy(substream->name, "Second AC'97 ADC");\r\n}\r\ntrident->foldback = foldback;\r\nif (trident->tlb.entries)\r\nsnd_pcm_lib_preallocate_pages_for_all(foldback, SNDRV_DMA_TYPE_DEV_SG,\r\nsnd_dma_pci_data(trident->pci), 0, 128*1024);\r\nelse\r\nsnd_pcm_lib_preallocate_pages_for_all(foldback, SNDRV_DMA_TYPE_DEV,\r\nsnd_dma_pci_data(trident->pci), 64*1024, 128*1024);\r\nif (rpcm)\r\n*rpcm = foldback;\r\nreturn 0;\r\n}\r\nint snd_trident_spdif_pcm(struct snd_trident *trident,\r\nint device, struct snd_pcm **rpcm)\r\n{\r\nstruct snd_pcm *spdif;\r\nint err;\r\nif (rpcm)\r\n*rpcm = NULL;\r\nif ((err = snd_pcm_new(trident->card, "trident_dx_nx IEC958", device, 1, 0, &spdif)) < 0)\r\nreturn err;\r\nspdif->private_data = trident;\r\nif (trident->device != TRIDENT_DEVICE_ID_SI7018) {\r\nsnd_pcm_set_ops(spdif, SNDRV_PCM_STREAM_PLAYBACK, &snd_trident_spdif_ops);\r\n} else {\r\nsnd_pcm_set_ops(spdif, SNDRV_PCM_STREAM_PLAYBACK, &snd_trident_spdif_7018_ops);\r\n}\r\nspdif->info_flags = 0;\r\nstrcpy(spdif->name, "Trident 4DWave IEC958");\r\ntrident->spdif = spdif;\r\nsnd_pcm_lib_preallocate_pages_for_all(spdif, SNDRV_DMA_TYPE_DEV, snd_dma_pci_data(trident->pci), 64*1024, 128*1024);\r\nif (rpcm)\r\n*rpcm = spdif;\r\nreturn 0;\r\n}\r\nstatic int snd_trident_spdif_control_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_trident *trident = snd_kcontrol_chip(kcontrol);\r\nunsigned char val;\r\nspin_lock_irq(&trident->reg_lock);\r\nval = trident->spdif_ctrl;\r\nucontrol->value.integer.value[0] = val == kcontrol->private_value;\r\nspin_unlock_irq(&trident->reg_lock);\r\nreturn 0;\r\n}\r\nstatic int snd_trident_spdif_control_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_trident *trident = snd_kcontrol_chip(kcontrol);\r\nunsigned char val;\r\nint change;\r\nval = ucontrol->value.integer.value[0] ? (unsigned char) kcontrol->private_value : 0x00;\r\nspin_lock_irq(&trident->reg_lock);\r\nchange = trident->spdif_ctrl != val;\r\ntrident->spdif_ctrl = val;\r\nif (trident->device != TRIDENT_DEVICE_ID_SI7018) {\r\nif ((inb(TRID_REG(trident, NX_SPCTRL_SPCSO + 3)) & 0x10) == 0) {\r\noutl(trident->spdif_bits, TRID_REG(trident, NX_SPCSTATUS));\r\noutb(trident->spdif_ctrl, TRID_REG(trident, NX_SPCTRL_SPCSO + 3));\r\n}\r\n} else {\r\nif (trident->spdif == NULL) {\r\nunsigned int temp;\r\noutl(trident->spdif_bits, TRID_REG(trident, SI_SPDIF_CS));\r\ntemp = inl(TRID_REG(trident, SI_SERIAL_INTF_CTRL)) & ~SPDIF_EN;\r\nif (val)\r\ntemp |= SPDIF_EN;\r\noutl(temp, TRID_REG(trident, SI_SERIAL_INTF_CTRL));\r\n}\r\n}\r\nspin_unlock_irq(&trident->reg_lock);\r\nreturn change;\r\n}\r\nstatic int snd_trident_spdif_default_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_IEC958;\r\nuinfo->count = 1;\r\nreturn 0;\r\n}\r\nstatic int snd_trident_spdif_default_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_trident *trident = snd_kcontrol_chip(kcontrol);\r\nspin_lock_irq(&trident->reg_lock);\r\nucontrol->value.iec958.status[0] = (trident->spdif_bits >> 0) & 0xff;\r\nucontrol->value.iec958.status[1] = (trident->spdif_bits >> 8) & 0xff;\r\nucontrol->value.iec958.status[2] = (trident->spdif_bits >> 16) & 0xff;\r\nucontrol->value.iec958.status[3] = (trident->spdif_bits >> 24) & 0xff;\r\nspin_unlock_irq(&trident->reg_lock);\r\nreturn 0;\r\n}\r\nstatic int snd_trident_spdif_default_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_trident *trident = snd_kcontrol_chip(kcontrol);\r\nunsigned int val;\r\nint change;\r\nval = (ucontrol->value.iec958.status[0] << 0) |\r\n(ucontrol->value.iec958.status[1] << 8) |\r\n(ucontrol->value.iec958.status[2] << 16) |\r\n(ucontrol->value.iec958.status[3] << 24);\r\nspin_lock_irq(&trident->reg_lock);\r\nchange = trident->spdif_bits != val;\r\ntrident->spdif_bits = val;\r\nif (trident->device != TRIDENT_DEVICE_ID_SI7018) {\r\nif ((inb(TRID_REG(trident, NX_SPCTRL_SPCSO + 3)) & 0x10) == 0)\r\noutl(trident->spdif_bits, TRID_REG(trident, NX_SPCSTATUS));\r\n} else {\r\nif (trident->spdif == NULL)\r\noutl(trident->spdif_bits, TRID_REG(trident, SI_SPDIF_CS));\r\n}\r\nspin_unlock_irq(&trident->reg_lock);\r\nreturn change;\r\n}\r\nstatic int snd_trident_spdif_mask_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_IEC958;\r\nuinfo->count = 1;\r\nreturn 0;\r\n}\r\nstatic int snd_trident_spdif_mask_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nucontrol->value.iec958.status[0] = 0xff;\r\nucontrol->value.iec958.status[1] = 0xff;\r\nucontrol->value.iec958.status[2] = 0xff;\r\nucontrol->value.iec958.status[3] = 0xff;\r\nreturn 0;\r\n}\r\nstatic int snd_trident_spdif_stream_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_IEC958;\r\nuinfo->count = 1;\r\nreturn 0;\r\n}\r\nstatic int snd_trident_spdif_stream_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_trident *trident = snd_kcontrol_chip(kcontrol);\r\nspin_lock_irq(&trident->reg_lock);\r\nucontrol->value.iec958.status[0] = (trident->spdif_pcm_bits >> 0) & 0xff;\r\nucontrol->value.iec958.status[1] = (trident->spdif_pcm_bits >> 8) & 0xff;\r\nucontrol->value.iec958.status[2] = (trident->spdif_pcm_bits >> 16) & 0xff;\r\nucontrol->value.iec958.status[3] = (trident->spdif_pcm_bits >> 24) & 0xff;\r\nspin_unlock_irq(&trident->reg_lock);\r\nreturn 0;\r\n}\r\nstatic int snd_trident_spdif_stream_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_trident *trident = snd_kcontrol_chip(kcontrol);\r\nunsigned int val;\r\nint change;\r\nval = (ucontrol->value.iec958.status[0] << 0) |\r\n(ucontrol->value.iec958.status[1] << 8) |\r\n(ucontrol->value.iec958.status[2] << 16) |\r\n(ucontrol->value.iec958.status[3] << 24);\r\nspin_lock_irq(&trident->reg_lock);\r\nchange = trident->spdif_pcm_bits != val;\r\ntrident->spdif_pcm_bits = val;\r\nif (trident->spdif != NULL) {\r\nif (trident->device != TRIDENT_DEVICE_ID_SI7018) {\r\noutl(trident->spdif_pcm_bits, TRID_REG(trident, NX_SPCSTATUS));\r\n} else {\r\noutl(trident->spdif_bits, TRID_REG(trident, SI_SPDIF_CS));\r\n}\r\n}\r\nspin_unlock_irq(&trident->reg_lock);\r\nreturn change;\r\n}\r\nstatic int snd_trident_ac97_control_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_trident *trident = snd_kcontrol_chip(kcontrol);\r\nunsigned char val;\r\nspin_lock_irq(&trident->reg_lock);\r\nval = trident->ac97_ctrl = inl(TRID_REG(trident, NX_ACR0_AC97_COM_STAT));\r\nucontrol->value.integer.value[0] = (val & (1 << kcontrol->private_value)) ? 1 : 0;\r\nspin_unlock_irq(&trident->reg_lock);\r\nreturn 0;\r\n}\r\nstatic int snd_trident_ac97_control_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_trident *trident = snd_kcontrol_chip(kcontrol);\r\nunsigned char val;\r\nint change = 0;\r\nspin_lock_irq(&trident->reg_lock);\r\nval = trident->ac97_ctrl = inl(TRID_REG(trident, NX_ACR0_AC97_COM_STAT));\r\nval &= ~(1 << kcontrol->private_value);\r\nif (ucontrol->value.integer.value[0])\r\nval |= 1 << kcontrol->private_value;\r\nchange = val != trident->ac97_ctrl;\r\ntrident->ac97_ctrl = val;\r\noutl(trident->ac97_ctrl = val, TRID_REG(trident, NX_ACR0_AC97_COM_STAT));\r\nspin_unlock_irq(&trident->reg_lock);\r\nreturn change;\r\n}\r\nstatic int snd_trident_vol_control_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\r\nuinfo->count = 2;\r\nuinfo->value.integer.min = 0;\r\nuinfo->value.integer.max = 255;\r\nreturn 0;\r\n}\r\nstatic int snd_trident_vol_control_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_trident *trident = snd_kcontrol_chip(kcontrol);\r\nunsigned int val;\r\nval = trident->musicvol_wavevol;\r\nucontrol->value.integer.value[0] = 255 - ((val >> kcontrol->private_value) & 0xff);\r\nucontrol->value.integer.value[1] = 255 - ((val >> (kcontrol->private_value + 8)) & 0xff);\r\nreturn 0;\r\n}\r\nstatic int snd_trident_vol_control_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_trident *trident = snd_kcontrol_chip(kcontrol);\r\nunsigned int val;\r\nint change = 0;\r\nspin_lock_irq(&trident->reg_lock);\r\nval = trident->musicvol_wavevol;\r\nval &= ~(0xffff << kcontrol->private_value);\r\nval |= ((255 - (ucontrol->value.integer.value[0] & 0xff)) |\r\n((255 - (ucontrol->value.integer.value[1] & 0xff)) << 8)) << kcontrol->private_value;\r\nchange = val != trident->musicvol_wavevol;\r\noutl(trident->musicvol_wavevol = val, TRID_REG(trident, T4D_MUSICVOL_WAVEVOL));\r\nspin_unlock_irq(&trident->reg_lock);\r\nreturn change;\r\n}\r\nstatic int snd_trident_pcm_vol_control_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nstruct snd_trident *trident = snd_kcontrol_chip(kcontrol);\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\r\nuinfo->count = 1;\r\nuinfo->value.integer.min = 0;\r\nuinfo->value.integer.max = 255;\r\nif (trident->device == TRIDENT_DEVICE_ID_SI7018)\r\nuinfo->value.integer.max = 1023;\r\nreturn 0;\r\n}\r\nstatic int snd_trident_pcm_vol_control_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_trident *trident = snd_kcontrol_chip(kcontrol);\r\nstruct snd_trident_pcm_mixer *mix = &trident->pcm_mixer[snd_ctl_get_ioffnum(kcontrol, &ucontrol->id)];\r\nif (trident->device == TRIDENT_DEVICE_ID_SI7018) {\r\nucontrol->value.integer.value[0] = 1023 - mix->vol;\r\n} else {\r\nucontrol->value.integer.value[0] = 255 - (mix->vol>>2);\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_trident_pcm_vol_control_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_trident *trident = snd_kcontrol_chip(kcontrol);\r\nstruct snd_trident_pcm_mixer *mix = &trident->pcm_mixer[snd_ctl_get_ioffnum(kcontrol, &ucontrol->id)];\r\nunsigned int val;\r\nint change = 0;\r\nif (trident->device == TRIDENT_DEVICE_ID_SI7018) {\r\nval = 1023 - (ucontrol->value.integer.value[0] & 1023);\r\n} else {\r\nval = (255 - (ucontrol->value.integer.value[0] & 255)) << 2;\r\n}\r\nspin_lock_irq(&trident->reg_lock);\r\nchange = val != mix->vol;\r\nmix->vol = val;\r\nif (mix->voice != NULL)\r\nsnd_trident_write_vol_reg(trident, mix->voice, val);\r\nspin_unlock_irq(&trident->reg_lock);\r\nreturn change;\r\n}\r\nstatic int snd_trident_pcm_pan_control_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\r\nuinfo->count = 1;\r\nuinfo->value.integer.min = 0;\r\nuinfo->value.integer.max = 127;\r\nreturn 0;\r\n}\r\nstatic int snd_trident_pcm_pan_control_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_trident *trident = snd_kcontrol_chip(kcontrol);\r\nstruct snd_trident_pcm_mixer *mix = &trident->pcm_mixer[snd_ctl_get_ioffnum(kcontrol, &ucontrol->id)];\r\nucontrol->value.integer.value[0] = mix->pan;\r\nif (ucontrol->value.integer.value[0] & 0x40) {\r\nucontrol->value.integer.value[0] = (0x3f - (ucontrol->value.integer.value[0] & 0x3f));\r\n} else {\r\nucontrol->value.integer.value[0] |= 0x40;\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_trident_pcm_pan_control_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_trident *trident = snd_kcontrol_chip(kcontrol);\r\nstruct snd_trident_pcm_mixer *mix = &trident->pcm_mixer[snd_ctl_get_ioffnum(kcontrol, &ucontrol->id)];\r\nunsigned char val;\r\nint change = 0;\r\nif (ucontrol->value.integer.value[0] & 0x40)\r\nval = ucontrol->value.integer.value[0] & 0x3f;\r\nelse\r\nval = (0x3f - (ucontrol->value.integer.value[0] & 0x3f)) | 0x40;\r\nspin_lock_irq(&trident->reg_lock);\r\nchange = val != mix->pan;\r\nmix->pan = val;\r\nif (mix->voice != NULL)\r\nsnd_trident_write_pan_reg(trident, mix->voice, val);\r\nspin_unlock_irq(&trident->reg_lock);\r\nreturn change;\r\n}\r\nstatic int snd_trident_pcm_rvol_control_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\r\nuinfo->count = 1;\r\nuinfo->value.integer.min = 0;\r\nuinfo->value.integer.max = 127;\r\nreturn 0;\r\n}\r\nstatic int snd_trident_pcm_rvol_control_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_trident *trident = snd_kcontrol_chip(kcontrol);\r\nstruct snd_trident_pcm_mixer *mix = &trident->pcm_mixer[snd_ctl_get_ioffnum(kcontrol, &ucontrol->id)];\r\nucontrol->value.integer.value[0] = 127 - mix->rvol;\r\nreturn 0;\r\n}\r\nstatic int snd_trident_pcm_rvol_control_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_trident *trident = snd_kcontrol_chip(kcontrol);\r\nstruct snd_trident_pcm_mixer *mix = &trident->pcm_mixer[snd_ctl_get_ioffnum(kcontrol, &ucontrol->id)];\r\nunsigned short val;\r\nint change = 0;\r\nval = 0x7f - (ucontrol->value.integer.value[0] & 0x7f);\r\nspin_lock_irq(&trident->reg_lock);\r\nchange = val != mix->rvol;\r\nmix->rvol = val;\r\nif (mix->voice != NULL)\r\nsnd_trident_write_rvol_reg(trident, mix->voice, val);\r\nspin_unlock_irq(&trident->reg_lock);\r\nreturn change;\r\n}\r\nstatic int snd_trident_pcm_cvol_control_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\r\nuinfo->count = 1;\r\nuinfo->value.integer.min = 0;\r\nuinfo->value.integer.max = 127;\r\nreturn 0;\r\n}\r\nstatic int snd_trident_pcm_cvol_control_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_trident *trident = snd_kcontrol_chip(kcontrol);\r\nstruct snd_trident_pcm_mixer *mix = &trident->pcm_mixer[snd_ctl_get_ioffnum(kcontrol, &ucontrol->id)];\r\nucontrol->value.integer.value[0] = 127 - mix->cvol;\r\nreturn 0;\r\n}\r\nstatic int snd_trident_pcm_cvol_control_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_trident *trident = snd_kcontrol_chip(kcontrol);\r\nstruct snd_trident_pcm_mixer *mix = &trident->pcm_mixer[snd_ctl_get_ioffnum(kcontrol, &ucontrol->id)];\r\nunsigned short val;\r\nint change = 0;\r\nval = 0x7f - (ucontrol->value.integer.value[0] & 0x7f);\r\nspin_lock_irq(&trident->reg_lock);\r\nchange = val != mix->cvol;\r\nmix->cvol = val;\r\nif (mix->voice != NULL)\r\nsnd_trident_write_cvol_reg(trident, mix->voice, val);\r\nspin_unlock_irq(&trident->reg_lock);\r\nreturn change;\r\n}\r\nstatic void snd_trident_notify_pcm_change1(struct snd_card *card,\r\nstruct snd_kcontrol *kctl,\r\nint num, int activate)\r\n{\r\nstruct snd_ctl_elem_id id;\r\nif (! kctl)\r\nreturn;\r\nif (activate)\r\nkctl->vd[num].access &= ~SNDRV_CTL_ELEM_ACCESS_INACTIVE;\r\nelse\r\nkctl->vd[num].access |= SNDRV_CTL_ELEM_ACCESS_INACTIVE;\r\nsnd_ctl_notify(card, SNDRV_CTL_EVENT_MASK_VALUE |\r\nSNDRV_CTL_EVENT_MASK_INFO,\r\nsnd_ctl_build_ioff(&id, kctl, num));\r\n}\r\nstatic void snd_trident_notify_pcm_change(struct snd_trident *trident,\r\nstruct snd_trident_pcm_mixer *tmix,\r\nint num, int activate)\r\n{\r\nsnd_trident_notify_pcm_change1(trident->card, trident->ctl_vol, num, activate);\r\nsnd_trident_notify_pcm_change1(trident->card, trident->ctl_pan, num, activate);\r\nsnd_trident_notify_pcm_change1(trident->card, trident->ctl_rvol, num, activate);\r\nsnd_trident_notify_pcm_change1(trident->card, trident->ctl_cvol, num, activate);\r\n}\r\nstatic int snd_trident_pcm_mixer_build(struct snd_trident *trident,\r\nstruct snd_trident_voice *voice,\r\nstruct snd_pcm_substream *substream)\r\n{\r\nstruct snd_trident_pcm_mixer *tmix;\r\nif (snd_BUG_ON(!trident || !voice || !substream))\r\nreturn -EINVAL;\r\ntmix = &trident->pcm_mixer[substream->number];\r\ntmix->voice = voice;\r\ntmix->vol = T4D_DEFAULT_PCM_VOL;\r\ntmix->pan = T4D_DEFAULT_PCM_PAN;\r\ntmix->rvol = T4D_DEFAULT_PCM_RVOL;\r\ntmix->cvol = T4D_DEFAULT_PCM_CVOL;\r\nsnd_trident_notify_pcm_change(trident, tmix, substream->number, 1);\r\nreturn 0;\r\n}\r\nstatic int snd_trident_pcm_mixer_free(struct snd_trident *trident, struct snd_trident_voice *voice, struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_trident_pcm_mixer *tmix;\r\nif (snd_BUG_ON(!trident || !substream))\r\nreturn -EINVAL;\r\ntmix = &trident->pcm_mixer[substream->number];\r\ntmix->voice = NULL;\r\nsnd_trident_notify_pcm_change(trident, tmix, substream->number, 0);\r\nreturn 0;\r\n}\r\nstatic int snd_trident_mixer(struct snd_trident *trident, int pcm_spdif_device)\r\n{\r\nstruct snd_ac97_template _ac97;\r\nstruct snd_card *card = trident->card;\r\nstruct snd_kcontrol *kctl;\r\nstruct snd_ctl_elem_value *uctl;\r\nint idx, err, retries = 2;\r\nstatic struct snd_ac97_bus_ops ops = {\r\n.write = snd_trident_codec_write,\r\n.read = snd_trident_codec_read,\r\n};\r\nuctl = kzalloc(sizeof(*uctl), GFP_KERNEL);\r\nif (!uctl)\r\nreturn -ENOMEM;\r\nif ((err = snd_ac97_bus(trident->card, 0, &ops, NULL, &trident->ac97_bus)) < 0)\r\ngoto __out;\r\nmemset(&_ac97, 0, sizeof(_ac97));\r\n_ac97.private_data = trident;\r\ntrident->ac97_detect = 1;\r\n__again:\r\nif ((err = snd_ac97_mixer(trident->ac97_bus, &_ac97, &trident->ac97)) < 0) {\r\nif (trident->device == TRIDENT_DEVICE_ID_SI7018) {\r\nif ((err = snd_trident_sis_reset(trident)) < 0)\r\ngoto __out;\r\nif (retries-- > 0)\r\ngoto __again;\r\nerr = -EIO;\r\n}\r\ngoto __out;\r\n}\r\nif (trident->device == TRIDENT_DEVICE_ID_SI7018 &&\r\n(inl(TRID_REG(trident, SI_SERIAL_INTF_CTRL)) & SI_AC97_PRIMARY_READY) != 0) {\r\n_ac97.num = 1;\r\nerr = snd_ac97_mixer(trident->ac97_bus, &_ac97, &trident->ac97_sec);\r\nif (err < 0)\r\nsnd_printk(KERN_ERR "SI7018: the secondary codec - invalid access\n");\r\n#if 0\r\n{\r\nstruct snd_ac97 *mc97;\r\nerr = snd_ac97_modem(trident->card, &_ac97, &mc97);\r\nif (err < 0)\r\nsnd_printk(KERN_ERR "snd_ac97_modem returned error %i\n", err);\r\n}\r\n#endif\r\n}\r\ntrident->ac97_detect = 0;\r\nif (trident->device != TRIDENT_DEVICE_ID_SI7018) {\r\nif ((err = snd_ctl_add(card, kctl = snd_ctl_new1(&snd_trident_vol_wave_control, trident))) < 0)\r\ngoto __out;\r\nkctl->put(kctl, uctl);\r\nif ((err = snd_ctl_add(card, kctl = snd_ctl_new1(&snd_trident_vol_music_control, trident))) < 0)\r\ngoto __out;\r\nkctl->put(kctl, uctl);\r\noutl(trident->musicvol_wavevol = 0x00000000, TRID_REG(trident, T4D_MUSICVOL_WAVEVOL));\r\n} else {\r\noutl(trident->musicvol_wavevol = 0xffff0000, TRID_REG(trident, T4D_MUSICVOL_WAVEVOL));\r\n}\r\nfor (idx = 0; idx < 32; idx++) {\r\nstruct snd_trident_pcm_mixer *tmix;\r\ntmix = &trident->pcm_mixer[idx];\r\ntmix->voice = NULL;\r\n}\r\nif ((trident->ctl_vol = snd_ctl_new1(&snd_trident_pcm_vol_control, trident)) == NULL)\r\ngoto __nomem;\r\nif ((err = snd_ctl_add(card, trident->ctl_vol)))\r\ngoto __out;\r\nif ((trident->ctl_pan = snd_ctl_new1(&snd_trident_pcm_pan_control, trident)) == NULL)\r\ngoto __nomem;\r\nif ((err = snd_ctl_add(card, trident->ctl_pan)))\r\ngoto __out;\r\nif ((trident->ctl_rvol = snd_ctl_new1(&snd_trident_pcm_rvol_control, trident)) == NULL)\r\ngoto __nomem;\r\nif ((err = snd_ctl_add(card, trident->ctl_rvol)))\r\ngoto __out;\r\nif ((trident->ctl_cvol = snd_ctl_new1(&snd_trident_pcm_cvol_control, trident)) == NULL)\r\ngoto __nomem;\r\nif ((err = snd_ctl_add(card, trident->ctl_cvol)))\r\ngoto __out;\r\nif (trident->device == TRIDENT_DEVICE_ID_NX) {\r\nif ((err = snd_ctl_add(card, kctl = snd_ctl_new1(&snd_trident_ac97_rear_control, trident))) < 0)\r\ngoto __out;\r\nkctl->put(kctl, uctl);\r\n}\r\nif (trident->device == TRIDENT_DEVICE_ID_NX || trident->device == TRIDENT_DEVICE_ID_SI7018) {\r\nkctl = snd_ctl_new1(&snd_trident_spdif_control, trident);\r\nif (kctl == NULL) {\r\nerr = -ENOMEM;\r\ngoto __out;\r\n}\r\nif (trident->ac97->ext_id & AC97_EI_SPDIF)\r\nkctl->id.index++;\r\nif (trident->ac97_sec && (trident->ac97_sec->ext_id & AC97_EI_SPDIF))\r\nkctl->id.index++;\r\nidx = kctl->id.index;\r\nif ((err = snd_ctl_add(card, kctl)) < 0)\r\ngoto __out;\r\nkctl->put(kctl, uctl);\r\nkctl = snd_ctl_new1(&snd_trident_spdif_default, trident);\r\nif (kctl == NULL) {\r\nerr = -ENOMEM;\r\ngoto __out;\r\n}\r\nkctl->id.index = idx;\r\nkctl->id.device = pcm_spdif_device;\r\nif ((err = snd_ctl_add(card, kctl)) < 0)\r\ngoto __out;\r\nkctl = snd_ctl_new1(&snd_trident_spdif_mask, trident);\r\nif (kctl == NULL) {\r\nerr = -ENOMEM;\r\ngoto __out;\r\n}\r\nkctl->id.index = idx;\r\nkctl->id.device = pcm_spdif_device;\r\nif ((err = snd_ctl_add(card, kctl)) < 0)\r\ngoto __out;\r\nkctl = snd_ctl_new1(&snd_trident_spdif_stream, trident);\r\nif (kctl == NULL) {\r\nerr = -ENOMEM;\r\ngoto __out;\r\n}\r\nkctl->id.index = idx;\r\nkctl->id.device = pcm_spdif_device;\r\nif ((err = snd_ctl_add(card, kctl)) < 0)\r\ngoto __out;\r\ntrident->spdif_pcm_ctl = kctl;\r\n}\r\nerr = 0;\r\ngoto __out;\r\n__nomem:\r\nerr = -ENOMEM;\r\n__out:\r\nkfree(uctl);\r\nreturn err;\r\n}\r\nstatic unsigned char snd_trident_gameport_read(struct gameport *gameport)\r\n{\r\nstruct snd_trident *chip = gameport_get_port_data(gameport);\r\nif (snd_BUG_ON(!chip))\r\nreturn 0;\r\nreturn inb(TRID_REG(chip, GAMEPORT_LEGACY));\r\n}\r\nstatic void snd_trident_gameport_trigger(struct gameport *gameport)\r\n{\r\nstruct snd_trident *chip = gameport_get_port_data(gameport);\r\nif (snd_BUG_ON(!chip))\r\nreturn;\r\noutb(0xff, TRID_REG(chip, GAMEPORT_LEGACY));\r\n}\r\nstatic int snd_trident_gameport_cooked_read(struct gameport *gameport, int *axes, int *buttons)\r\n{\r\nstruct snd_trident *chip = gameport_get_port_data(gameport);\r\nint i;\r\nif (snd_BUG_ON(!chip))\r\nreturn 0;\r\n*buttons = (~inb(TRID_REG(chip, GAMEPORT_LEGACY)) >> 4) & 0xf;\r\nfor (i = 0; i < 4; i++) {\r\naxes[i] = inw(TRID_REG(chip, GAMEPORT_AXES + i * 2));\r\nif (axes[i] == 0xffff) axes[i] = -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_trident_gameport_open(struct gameport *gameport, int mode)\r\n{\r\nstruct snd_trident *chip = gameport_get_port_data(gameport);\r\nif (snd_BUG_ON(!chip))\r\nreturn 0;\r\nswitch (mode) {\r\ncase GAMEPORT_MODE_COOKED:\r\noutb(GAMEPORT_MODE_ADC, TRID_REG(chip, GAMEPORT_GCR));\r\nmsleep(20);\r\nreturn 0;\r\ncase GAMEPORT_MODE_RAW:\r\noutb(0, TRID_REG(chip, GAMEPORT_GCR));\r\nreturn 0;\r\ndefault:\r\nreturn -1;\r\n}\r\n}\r\nint snd_trident_create_gameport(struct snd_trident *chip)\r\n{\r\nstruct gameport *gp;\r\nchip->gameport = gp = gameport_allocate_port();\r\nif (!gp) {\r\nprintk(KERN_ERR "trident: cannot allocate memory for gameport\n");\r\nreturn -ENOMEM;\r\n}\r\ngameport_set_name(gp, "Trident 4DWave");\r\ngameport_set_phys(gp, "pci%s/gameport0", pci_name(chip->pci));\r\ngameport_set_dev_parent(gp, &chip->pci->dev);\r\ngameport_set_port_data(gp, chip);\r\ngp->fuzz = 64;\r\ngp->read = snd_trident_gameport_read;\r\ngp->trigger = snd_trident_gameport_trigger;\r\ngp->cooked_read = snd_trident_gameport_cooked_read;\r\ngp->open = snd_trident_gameport_open;\r\ngameport_register_port(gp);\r\nreturn 0;\r\n}\r\nstatic inline void snd_trident_free_gameport(struct snd_trident *chip)\r\n{\r\nif (chip->gameport) {\r\ngameport_unregister_port(chip->gameport);\r\nchip->gameport = NULL;\r\n}\r\n}\r\nint snd_trident_create_gameport(struct snd_trident *chip) { return -ENOSYS; }\r\nstatic inline void snd_trident_free_gameport(struct snd_trident *chip) { }\r\nstatic inline void do_delay(struct snd_trident *chip)\r\n{\r\nschedule_timeout_uninterruptible(1);\r\n}\r\nstatic int snd_trident_sis_reset(struct snd_trident *trident)\r\n{\r\nunsigned long end_time;\r\nunsigned int i;\r\nint r;\r\nr = trident->in_suspend ? 0 : 2;\r\n__si7018_retry:\r\npci_write_config_byte(trident->pci, 0x46, 0x04);\r\nudelay(100);\r\npci_write_config_byte(trident->pci, 0x46, 0x00);\r\nudelay(100);\r\noutb(0x00, TRID_REG(trident, SI_AC97_GPIO));\r\ni = PCMOUT|SURROUT|CENTEROUT|LFEOUT|SECONDARY_ID|COLD_RESET;\r\noutl(i, TRID_REG(trident, SI_SERIAL_INTF_CTRL));\r\nudelay(1000);\r\ni &= ~COLD_RESET;\r\noutl(i, TRID_REG(trident, SI_SERIAL_INTF_CTRL));\r\nudelay(2000);\r\nend_time = (jiffies + (HZ * 3) / 4) + 1;\r\ndo {\r\nif ((inl(TRID_REG(trident, SI_SERIAL_INTF_CTRL)) & SI_AC97_PRIMARY_READY) != 0)\r\ngoto __si7018_ok;\r\ndo_delay(trident);\r\n} while (time_after_eq(end_time, jiffies));\r\nsnd_printk(KERN_ERR "AC'97 codec ready error [0x%x]\n", inl(TRID_REG(trident, SI_SERIAL_INTF_CTRL)));\r\nif (r-- > 0) {\r\nend_time = jiffies + HZ;\r\ndo {\r\ndo_delay(trident);\r\n} while (time_after_eq(end_time, jiffies));\r\ngoto __si7018_retry;\r\n}\r\n__si7018_ok:\r\ndo {\r\nif ((inl(TRID_REG(trident, SI_SERIAL_INTF_CTRL)) & SI_AC97_SECONDARY_READY) != 0)\r\nbreak;\r\ndo_delay(trident);\r\n} while (time_after_eq(end_time, jiffies));\r\noutl(BANK_B_EN, TRID_REG(trident, T4D_LFO_GC_CIR));\r\nreturn 0;\r\n}\r\nstatic void snd_trident_proc_read(struct snd_info_entry *entry,\r\nstruct snd_info_buffer *buffer)\r\n{\r\nstruct snd_trident *trident = entry->private_data;\r\nchar *s;\r\nswitch (trident->device) {\r\ncase TRIDENT_DEVICE_ID_SI7018:\r\ns = "SiS 7018 Audio";\r\nbreak;\r\ncase TRIDENT_DEVICE_ID_DX:\r\ns = "Trident 4DWave PCI DX";\r\nbreak;\r\ncase TRIDENT_DEVICE_ID_NX:\r\ns = "Trident 4DWave PCI NX";\r\nbreak;\r\ndefault:\r\ns = "???";\r\n}\r\nsnd_iprintf(buffer, "%s\n\n", s);\r\nsnd_iprintf(buffer, "Spurious IRQs : %d\n", trident->spurious_irq_count);\r\nsnd_iprintf(buffer, "Spurious IRQ dlta: %d\n", trident->spurious_irq_max_delta);\r\nif (trident->device == TRIDENT_DEVICE_ID_NX || trident->device == TRIDENT_DEVICE_ID_SI7018)\r\nsnd_iprintf(buffer, "IEC958 Mixer Out : %s\n", trident->spdif_ctrl == 0x28 ? "on" : "off");\r\nif (trident->device == TRIDENT_DEVICE_ID_NX) {\r\nsnd_iprintf(buffer, "Rear Speakers : %s\n", trident->ac97_ctrl & 0x00000010 ? "on" : "off");\r\nif (trident->tlb.entries) {\r\nsnd_iprintf(buffer,"\nVirtual Memory\n");\r\nsnd_iprintf(buffer, "Memory Maximum : %d\n", trident->tlb.memhdr->size);\r\nsnd_iprintf(buffer, "Memory Used : %d\n", trident->tlb.memhdr->used);\r\nsnd_iprintf(buffer, "Memory Free : %d\n", snd_util_mem_avail(trident->tlb.memhdr));\r\n}\r\n}\r\n}\r\nstatic void snd_trident_proc_init(struct snd_trident *trident)\r\n{\r\nstruct snd_info_entry *entry;\r\nconst char *s = "trident";\r\nif (trident->device == TRIDENT_DEVICE_ID_SI7018)\r\ns = "sis7018";\r\nif (! snd_card_proc_new(trident->card, s, &entry))\r\nsnd_info_set_text_ops(entry, trident, snd_trident_proc_read);\r\n}\r\nstatic int snd_trident_dev_free(struct snd_device *device)\r\n{\r\nstruct snd_trident *trident = device->device_data;\r\nreturn snd_trident_free(trident);\r\n}\r\nstatic int snd_trident_tlb_alloc(struct snd_trident *trident)\r\n{\r\nint i;\r\nif (snd_dma_alloc_pages(SNDRV_DMA_TYPE_DEV, snd_dma_pci_data(trident->pci),\r\n2 * SNDRV_TRIDENT_MAX_PAGES * 4, &trident->tlb.buffer) < 0) {\r\nsnd_printk(KERN_ERR "trident: unable to allocate TLB buffer\n");\r\nreturn -ENOMEM;\r\n}\r\ntrident->tlb.entries = (unsigned int*)ALIGN((unsigned long)trident->tlb.buffer.area, SNDRV_TRIDENT_MAX_PAGES * 4);\r\ntrident->tlb.entries_dmaaddr = ALIGN(trident->tlb.buffer.addr, SNDRV_TRIDENT_MAX_PAGES * 4);\r\ntrident->tlb.shadow_entries = vmalloc(SNDRV_TRIDENT_MAX_PAGES*sizeof(unsigned long));\r\nif (trident->tlb.shadow_entries == NULL) {\r\nsnd_printk(KERN_ERR "trident: unable to allocate shadow TLB entries\n");\r\nreturn -ENOMEM;\r\n}\r\nif (snd_dma_alloc_pages(SNDRV_DMA_TYPE_DEV, snd_dma_pci_data(trident->pci),\r\nSNDRV_TRIDENT_PAGE_SIZE, &trident->tlb.silent_page) < 0) {\r\nsnd_printk(KERN_ERR "trident: unable to allocate silent page\n");\r\nreturn -ENOMEM;\r\n}\r\nmemset(trident->tlb.silent_page.area, 0, SNDRV_TRIDENT_PAGE_SIZE);\r\nfor (i = 0; i < SNDRV_TRIDENT_MAX_PAGES; i++) {\r\ntrident->tlb.entries[i] = cpu_to_le32(trident->tlb.silent_page.addr & ~(SNDRV_TRIDENT_PAGE_SIZE-1));\r\ntrident->tlb.shadow_entries[i] = (unsigned long)trident->tlb.silent_page.area;\r\n}\r\ntrident->tlb.memhdr = snd_util_memhdr_new(SNDRV_TRIDENT_PAGE_SIZE * SNDRV_TRIDENT_MAX_PAGES);\r\nif (trident->tlb.memhdr == NULL)\r\nreturn -ENOMEM;\r\ntrident->tlb.memhdr->block_extra_size = sizeof(struct snd_trident_memblk_arg);\r\nreturn 0;\r\n}\r\nstatic void snd_trident_stop_all_voices(struct snd_trident *trident)\r\n{\r\noutl(0xffffffff, TRID_REG(trident, T4D_STOP_A));\r\noutl(0xffffffff, TRID_REG(trident, T4D_STOP_B));\r\noutl(0, TRID_REG(trident, T4D_AINTEN_A));\r\noutl(0, TRID_REG(trident, T4D_AINTEN_B));\r\n}\r\nstatic int snd_trident_4d_dx_init(struct snd_trident *trident)\r\n{\r\nstruct pci_dev *pci = trident->pci;\r\nunsigned long end_time;\r\npci_write_config_dword(pci, 0x40, 0);\r\npci_write_config_byte(pci, 0x44, 0);\r\npci_write_config_byte(pci, 0x45, 0);\r\npci_write_config_byte(pci, 0x46, 4);\r\nudelay(100);\r\npci_write_config_byte(pci, 0x46, 0);\r\nudelay(100);\r\noutl(0x00000001, TRID_REG(trident, DX_ACR2_AC97_COM_STAT));\r\nudelay(100);\r\noutl(0x00000000, TRID_REG(trident, DX_ACR2_AC97_COM_STAT));\r\ntrident->ac97_ctrl = 0x0000004a;\r\noutl(trident->ac97_ctrl, TRID_REG(trident, DX_ACR2_AC97_COM_STAT));\r\nend_time = (jiffies + (HZ * 3) / 4) + 1;\r\ndo {\r\nif ((inl(TRID_REG(trident, DX_ACR2_AC97_COM_STAT)) & 0x0010) != 0)\r\ngoto __dx_ok;\r\ndo_delay(trident);\r\n} while (time_after_eq(end_time, jiffies));\r\nsnd_printk(KERN_ERR "AC'97 codec ready error\n");\r\nreturn -EIO;\r\n__dx_ok:\r\nsnd_trident_stop_all_voices(trident);\r\nreturn 0;\r\n}\r\nstatic int snd_trident_4d_nx_init(struct snd_trident *trident)\r\n{\r\nstruct pci_dev *pci = trident->pci;\r\nunsigned long end_time;\r\npci_write_config_dword(pci, 0x40, 0);\r\npci_write_config_byte(pci, 0x44, 0);\r\npci_write_config_byte(pci, 0x45, 0);\r\npci_write_config_byte(pci, 0x46, 1);\r\nudelay(100);\r\npci_write_config_byte(pci, 0x46, 0);\r\nudelay(100);\r\noutl(0x00000001, TRID_REG(trident, NX_ACR0_AC97_COM_STAT));\r\nudelay(100);\r\noutl(0x00000000, TRID_REG(trident, NX_ACR0_AC97_COM_STAT));\r\nend_time = (jiffies + (HZ * 3) / 4) + 1;\r\ndo {\r\nif ((inl(TRID_REG(trident, NX_ACR0_AC97_COM_STAT)) & 0x0008) != 0)\r\ngoto __nx_ok;\r\ndo_delay(trident);\r\n} while (time_after_eq(end_time, jiffies));\r\nsnd_printk(KERN_ERR "AC'97 codec ready error [0x%x]\n", inl(TRID_REG(trident, NX_ACR0_AC97_COM_STAT)));\r\nreturn -EIO;\r\n__nx_ok:\r\ntrident->ac97_ctrl = 0x00000002;\r\noutl(trident->ac97_ctrl, TRID_REG(trident, NX_ACR0_AC97_COM_STAT));\r\noutl(NX_SB_IRQ_DISABLE, TRID_REG(trident, T4D_MISCINT));\r\nsnd_trident_stop_all_voices(trident);\r\nif (trident->tlb.entries != NULL) {\r\nunsigned int i;\r\ni = trident->tlb.entries_dmaaddr;\r\ni |= 0x00000001;\r\noutl(i, TRID_REG(trident, NX_TLBC));\r\n} else {\r\noutl(0, TRID_REG(trident, NX_TLBC));\r\n}\r\noutl(trident->spdif_bits, TRID_REG(trident, NX_SPCSTATUS));\r\noutb(trident->spdif_ctrl, TRID_REG(trident, NX_SPCTRL_SPCSO + 3));\r\nreturn 0;\r\n}\r\nstatic int snd_trident_sis_init(struct snd_trident *trident)\r\n{\r\nint err;\r\nif ((err = snd_trident_sis_reset(trident)) < 0)\r\nreturn err;\r\nsnd_trident_stop_all_voices(trident);\r\noutl(trident->spdif_bits, TRID_REG(trident, SI_SPDIF_CS));\r\nreturn 0;\r\n}\r\nint snd_trident_create(struct snd_card *card,\r\nstruct pci_dev *pci,\r\nint pcm_streams,\r\nint pcm_spdif_device,\r\nint max_wavetable_size,\r\nstruct snd_trident ** rtrident)\r\n{\r\nstruct snd_trident *trident;\r\nint i, err;\r\nstruct snd_trident_voice *voice;\r\nstruct snd_trident_pcm_mixer *tmix;\r\nstatic struct snd_device_ops ops = {\r\n.dev_free = snd_trident_dev_free,\r\n};\r\n*rtrident = NULL;\r\nif ((err = pci_enable_device(pci)) < 0)\r\nreturn err;\r\nif (pci_set_dma_mask(pci, DMA_BIT_MASK(30)) < 0 ||\r\npci_set_consistent_dma_mask(pci, DMA_BIT_MASK(30)) < 0) {\r\nsnd_printk(KERN_ERR "architecture does not support 30bit PCI busmaster DMA\n");\r\npci_disable_device(pci);\r\nreturn -ENXIO;\r\n}\r\ntrident = kzalloc(sizeof(*trident), GFP_KERNEL);\r\nif (trident == NULL) {\r\npci_disable_device(pci);\r\nreturn -ENOMEM;\r\n}\r\ntrident->device = (pci->vendor << 16) | pci->device;\r\ntrident->card = card;\r\ntrident->pci = pci;\r\nspin_lock_init(&trident->reg_lock);\r\nspin_lock_init(&trident->event_lock);\r\nspin_lock_init(&trident->voice_alloc);\r\nif (pcm_streams < 1)\r\npcm_streams = 1;\r\nif (pcm_streams > 32)\r\npcm_streams = 32;\r\ntrident->ChanPCM = pcm_streams;\r\nif (max_wavetable_size < 0 )\r\nmax_wavetable_size = 0;\r\ntrident->synth.max_size = max_wavetable_size * 1024;\r\ntrident->irq = -1;\r\ntrident->midi_port = TRID_REG(trident, T4D_MPU401_BASE);\r\npci_set_master(pci);\r\nif ((err = pci_request_regions(pci, "Trident Audio")) < 0) {\r\nkfree(trident);\r\npci_disable_device(pci);\r\nreturn err;\r\n}\r\ntrident->port = pci_resource_start(pci, 0);\r\nif (request_irq(pci->irq, snd_trident_interrupt, IRQF_SHARED,\r\nKBUILD_MODNAME, trident)) {\r\nsnd_printk(KERN_ERR "unable to grab IRQ %d\n", pci->irq);\r\nsnd_trident_free(trident);\r\nreturn -EBUSY;\r\n}\r\ntrident->irq = pci->irq;\r\ntrident->tlb.entries = NULL;\r\ntrident->tlb.buffer.area = NULL;\r\nif (trident->device == TRIDENT_DEVICE_ID_NX) {\r\nif ((err = snd_trident_tlb_alloc(trident)) < 0) {\r\nsnd_trident_free(trident);\r\nreturn err;\r\n}\r\n}\r\ntrident->spdif_bits = trident->spdif_pcm_bits = SNDRV_PCM_DEFAULT_CON_SPDIF;\r\nswitch (trident->device) {\r\ncase TRIDENT_DEVICE_ID_DX:\r\nerr = snd_trident_4d_dx_init(trident);\r\nbreak;\r\ncase TRIDENT_DEVICE_ID_NX:\r\nerr = snd_trident_4d_nx_init(trident);\r\nbreak;\r\ncase TRIDENT_DEVICE_ID_SI7018:\r\nerr = snd_trident_sis_init(trident);\r\nbreak;\r\ndefault:\r\nsnd_BUG();\r\nbreak;\r\n}\r\nif (err < 0) {\r\nsnd_trident_free(trident);\r\nreturn err;\r\n}\r\nif ((err = snd_device_new(card, SNDRV_DEV_LOWLEVEL, trident, &ops)) < 0) {\r\nsnd_trident_free(trident);\r\nreturn err;\r\n}\r\nif ((err = snd_trident_mixer(trident, pcm_spdif_device)) < 0)\r\nreturn err;\r\nfor (i = 0; i < 64; i++) {\r\nvoice = &trident->synth.voices[i];\r\nvoice->number = i;\r\nvoice->trident = trident;\r\n}\r\nfor (i = 0; i < 32; i++) {\r\ntmix = &trident->pcm_mixer[i];\r\ntmix->vol = T4D_DEFAULT_PCM_VOL;\r\ntmix->pan = T4D_DEFAULT_PCM_PAN;\r\ntmix->rvol = T4D_DEFAULT_PCM_RVOL;\r\ntmix->cvol = T4D_DEFAULT_PCM_CVOL;\r\n}\r\nsnd_trident_enable_eso(trident);\r\nsnd_trident_proc_init(trident);\r\nsnd_card_set_dev(card, &pci->dev);\r\n*rtrident = trident;\r\nreturn 0;\r\n}\r\nstatic int snd_trident_free(struct snd_trident *trident)\r\n{\r\nsnd_trident_free_gameport(trident);\r\nsnd_trident_disable_eso(trident);\r\nif (trident->device == TRIDENT_DEVICE_ID_NX)\r\noutb(0x00, TRID_REG(trident, NX_SPCTRL_SPCSO + 3));\r\nelse if (trident->device == TRIDENT_DEVICE_ID_SI7018) {\r\noutl(0, TRID_REG(trident, SI_SERIAL_INTF_CTRL));\r\n}\r\nif (trident->irq >= 0)\r\nfree_irq(trident->irq, trident);\r\nif (trident->tlb.buffer.area) {\r\noutl(0, TRID_REG(trident, NX_TLBC));\r\nif (trident->tlb.memhdr)\r\nsnd_util_memhdr_free(trident->tlb.memhdr);\r\nif (trident->tlb.silent_page.area)\r\nsnd_dma_free_pages(&trident->tlb.silent_page);\r\nvfree(trident->tlb.shadow_entries);\r\nsnd_dma_free_pages(&trident->tlb.buffer);\r\n}\r\npci_release_regions(trident->pci);\r\npci_disable_device(trident->pci);\r\nkfree(trident);\r\nreturn 0;\r\n}\r\nstatic irqreturn_t snd_trident_interrupt(int irq, void *dev_id)\r\n{\r\nstruct snd_trident *trident = dev_id;\r\nunsigned int audio_int, chn_int, stimer, channel, mask, tmp;\r\nint delta;\r\nstruct snd_trident_voice *voice;\r\naudio_int = inl(TRID_REG(trident, T4D_MISCINT));\r\nif ((audio_int & (ADDRESS_IRQ|MPU401_IRQ)) == 0)\r\nreturn IRQ_NONE;\r\nif (audio_int & ADDRESS_IRQ) {\r\nspin_lock(&trident->reg_lock);\r\nstimer = inl(TRID_REG(trident, T4D_STIMER)) & 0x00ffffff;\r\nchn_int = inl(TRID_REG(trident, T4D_AINT_A));\r\nif (chn_int == 0)\r\ngoto __skip1;\r\noutl(chn_int, TRID_REG(trident, T4D_AINT_A));\r\n__skip1:\r\nchn_int = inl(TRID_REG(trident, T4D_AINT_B));\r\nif (chn_int == 0)\r\ngoto __skip2;\r\nfor (channel = 63; channel >= 32; channel--) {\r\nmask = 1 << (channel&0x1f);\r\nif ((chn_int & mask) == 0)\r\ncontinue;\r\nvoice = &trident->synth.voices[channel];\r\nif (!voice->pcm || voice->substream == NULL) {\r\noutl(mask, TRID_REG(trident, T4D_STOP_B));\r\ncontinue;\r\n}\r\ndelta = (int)stimer - (int)voice->stimer;\r\nif (delta < 0)\r\ndelta = -delta;\r\nif ((unsigned int)delta < voice->spurious_threshold) {\r\ntrident->spurious_irq_count++;\r\nif (trident->spurious_irq_max_delta < (unsigned int)delta)\r\ntrident->spurious_irq_max_delta = delta;\r\ncontinue;\r\n}\r\nvoice->stimer = stimer;\r\nif (voice->isync) {\r\nif (!voice->isync3) {\r\ntmp = inw(TRID_REG(trident, T4D_SBBL_SBCL));\r\nif (trident->bDMAStart & 0x40)\r\ntmp >>= 1;\r\nif (tmp > 0)\r\ntmp = voice->isync_max - tmp;\r\n} else {\r\ntmp = inl(TRID_REG(trident, NX_SPCTRL_SPCSO)) & 0x00ffffff;\r\n}\r\nif (tmp < voice->isync_mark) {\r\nif (tmp > 0x10)\r\ntmp = voice->isync_ESO - 7;\r\nelse\r\ntmp = voice->isync_ESO + 2;\r\nsnd_trident_stop_voice(trident, voice->number);\r\nsnd_trident_write_eso_reg(trident, voice, tmp);\r\nsnd_trident_start_voice(trident, voice->number);\r\n}\r\n} else if (voice->isync2) {\r\nvoice->isync2 = 0;\r\nsnd_trident_stop_voice(trident, voice->number);\r\nsnd_trident_write_cso_reg(trident, voice, voice->isync_mark);\r\nsnd_trident_write_eso_reg(trident, voice, voice->ESO);\r\nsnd_trident_start_voice(trident, voice->number);\r\n}\r\n#if 0\r\nif (voice->extra) {\r\nsnd_trident_stop_voice(trident, voice->extra->number);\r\nsnd_trident_write_cso_reg(trident, voice->extra, 0);\r\nsnd_trident_start_voice(trident, voice->extra->number);\r\n}\r\n#endif\r\nspin_unlock(&trident->reg_lock);\r\nsnd_pcm_period_elapsed(voice->substream);\r\nspin_lock(&trident->reg_lock);\r\n}\r\noutl(chn_int, TRID_REG(trident, T4D_AINT_B));\r\n__skip2:\r\nspin_unlock(&trident->reg_lock);\r\n}\r\nif (audio_int & MPU401_IRQ) {\r\nif (trident->rmidi) {\r\nsnd_mpu401_uart_interrupt(irq, trident->rmidi->private_data);\r\n} else {\r\ninb(TRID_REG(trident, T4D_MPUR0));\r\n}\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstruct snd_trident_voice *snd_trident_alloc_voice(struct snd_trident * trident, int type, int client, int port)\r\n{\r\nstruct snd_trident_voice *pvoice;\r\nunsigned long flags;\r\nint idx;\r\nspin_lock_irqsave(&trident->voice_alloc, flags);\r\nif (type == SNDRV_TRIDENT_VOICE_TYPE_PCM) {\r\nidx = snd_trident_allocate_pcm_channel(trident);\r\nif(idx < 0) {\r\nspin_unlock_irqrestore(&trident->voice_alloc, flags);\r\nreturn NULL;\r\n}\r\npvoice = &trident->synth.voices[idx];\r\npvoice->use = 1;\r\npvoice->pcm = 1;\r\npvoice->capture = 0;\r\npvoice->spdif = 0;\r\npvoice->memblk = NULL;\r\npvoice->substream = NULL;\r\nspin_unlock_irqrestore(&trident->voice_alloc, flags);\r\nreturn pvoice;\r\n}\r\nif (type == SNDRV_TRIDENT_VOICE_TYPE_SYNTH) {\r\nidx = snd_trident_allocate_synth_channel(trident);\r\nif(idx < 0) {\r\nspin_unlock_irqrestore(&trident->voice_alloc, flags);\r\nreturn NULL;\r\n}\r\npvoice = &trident->synth.voices[idx];\r\npvoice->use = 1;\r\npvoice->synth = 1;\r\npvoice->client = client;\r\npvoice->port = port;\r\npvoice->memblk = NULL;\r\nspin_unlock_irqrestore(&trident->voice_alloc, flags);\r\nreturn pvoice;\r\n}\r\nif (type == SNDRV_TRIDENT_VOICE_TYPE_MIDI) {\r\n}\r\nspin_unlock_irqrestore(&trident->voice_alloc, flags);\r\nreturn NULL;\r\n}\r\nvoid snd_trident_free_voice(struct snd_trident * trident, struct snd_trident_voice *voice)\r\n{\r\nunsigned long flags;\r\nvoid (*private_free)(struct snd_trident_voice *);\r\nvoid *private_data;\r\nif (voice == NULL || !voice->use)\r\nreturn;\r\nsnd_trident_clear_voices(trident, voice->number, voice->number);\r\nspin_lock_irqsave(&trident->voice_alloc, flags);\r\nprivate_free = voice->private_free;\r\nprivate_data = voice->private_data;\r\nvoice->private_free = NULL;\r\nvoice->private_data = NULL;\r\nif (voice->pcm)\r\nsnd_trident_free_pcm_channel(trident, voice->number);\r\nif (voice->synth)\r\nsnd_trident_free_synth_channel(trident, voice->number);\r\nvoice->use = voice->pcm = voice->synth = voice->midi = 0;\r\nvoice->capture = voice->spdif = 0;\r\nvoice->sample_ops = NULL;\r\nvoice->substream = NULL;\r\nvoice->extra = NULL;\r\nspin_unlock_irqrestore(&trident->voice_alloc, flags);\r\nif (private_free)\r\nprivate_free(voice);\r\n}\r\nstatic void snd_trident_clear_voices(struct snd_trident * trident, unsigned short v_min, unsigned short v_max)\r\n{\r\nunsigned int i, val, mask[2] = { 0, 0 };\r\nif (snd_BUG_ON(v_min > 63 || v_max > 63))\r\nreturn;\r\nfor (i = v_min; i <= v_max; i++)\r\nmask[i >> 5] |= 1 << (i & 0x1f);\r\nif (mask[0]) {\r\noutl(mask[0], TRID_REG(trident, T4D_STOP_A));\r\nval = inl(TRID_REG(trident, T4D_AINTEN_A));\r\noutl(val & ~mask[0], TRID_REG(trident, T4D_AINTEN_A));\r\n}\r\nif (mask[1]) {\r\noutl(mask[1], TRID_REG(trident, T4D_STOP_B));\r\nval = inl(TRID_REG(trident, T4D_AINTEN_B));\r\noutl(val & ~mask[1], TRID_REG(trident, T4D_AINTEN_B));\r\n}\r\n}\r\nstatic int snd_trident_suspend(struct device *dev)\r\n{\r\nstruct pci_dev *pci = to_pci_dev(dev);\r\nstruct snd_card *card = dev_get_drvdata(dev);\r\nstruct snd_trident *trident = card->private_data;\r\ntrident->in_suspend = 1;\r\nsnd_power_change_state(card, SNDRV_CTL_POWER_D3hot);\r\nsnd_pcm_suspend_all(trident->pcm);\r\nsnd_pcm_suspend_all(trident->foldback);\r\nsnd_pcm_suspend_all(trident->spdif);\r\nsnd_ac97_suspend(trident->ac97);\r\nsnd_ac97_suspend(trident->ac97_sec);\r\npci_disable_device(pci);\r\npci_save_state(pci);\r\npci_set_power_state(pci, PCI_D3hot);\r\nreturn 0;\r\n}\r\nstatic int snd_trident_resume(struct device *dev)\r\n{\r\nstruct pci_dev *pci = to_pci_dev(dev);\r\nstruct snd_card *card = dev_get_drvdata(dev);\r\nstruct snd_trident *trident = card->private_data;\r\npci_set_power_state(pci, PCI_D0);\r\npci_restore_state(pci);\r\nif (pci_enable_device(pci) < 0) {\r\nprintk(KERN_ERR "trident: pci_enable_device failed, "\r\n"disabling device\n");\r\nsnd_card_disconnect(card);\r\nreturn -EIO;\r\n}\r\npci_set_master(pci);\r\nswitch (trident->device) {\r\ncase TRIDENT_DEVICE_ID_DX:\r\nsnd_trident_4d_dx_init(trident);\r\nbreak;\r\ncase TRIDENT_DEVICE_ID_NX:\r\nsnd_trident_4d_nx_init(trident);\r\nbreak;\r\ncase TRIDENT_DEVICE_ID_SI7018:\r\nsnd_trident_sis_init(trident);\r\nbreak;\r\n}\r\nsnd_ac97_resume(trident->ac97);\r\nsnd_ac97_resume(trident->ac97_sec);\r\noutl(trident->musicvol_wavevol, TRID_REG(trident, T4D_MUSICVOL_WAVEVOL));\r\nsnd_trident_enable_eso(trident);\r\nsnd_power_change_state(card, SNDRV_CTL_POWER_D0);\r\ntrident->in_suspend = 0;\r\nreturn 0;\r\n}
