static inline struct list_head *list_first(struct list_head *head)\r\n{\r\nreturn head->next;\r\n}\r\nstatic struct pci_dev *__xen_pcibk_get_pci_dev(struct xen_pcibk_device *pdev,\r\nunsigned int domain,\r\nunsigned int bus,\r\nunsigned int devfn)\r\n{\r\nstruct pci_dev_entry *entry;\r\nstruct pci_dev *dev = NULL;\r\nstruct vpci_dev_data *vpci_dev = pdev->pci_dev_data;\r\nif (domain != 0 || bus != 0)\r\nreturn NULL;\r\nif (PCI_SLOT(devfn) < PCI_SLOT_MAX) {\r\nmutex_lock(&vpci_dev->lock);\r\nlist_for_each_entry(entry,\r\n&vpci_dev->dev_list[PCI_SLOT(devfn)],\r\nlist) {\r\nif (PCI_FUNC(entry->dev->devfn) == PCI_FUNC(devfn)) {\r\ndev = entry->dev;\r\nbreak;\r\n}\r\n}\r\nmutex_unlock(&vpci_dev->lock);\r\n}\r\nreturn dev;\r\n}\r\nstatic inline int match_slot(struct pci_dev *l, struct pci_dev *r)\r\n{\r\nif (pci_domain_nr(l->bus) == pci_domain_nr(r->bus)\r\n&& l->bus == r->bus && PCI_SLOT(l->devfn) == PCI_SLOT(r->devfn))\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic int __xen_pcibk_add_pci_dev(struct xen_pcibk_device *pdev,\r\nstruct pci_dev *dev, int devid,\r\npublish_pci_dev_cb publish_cb)\r\n{\r\nint err = 0, slot, func = -1;\r\nstruct pci_dev_entry *t, *dev_entry;\r\nstruct vpci_dev_data *vpci_dev = pdev->pci_dev_data;\r\nif ((dev->class >> 24) == PCI_BASE_CLASS_BRIDGE) {\r\nerr = -EFAULT;\r\nxenbus_dev_fatal(pdev->xdev, err,\r\n"Can't export bridges on the virtual PCI bus");\r\ngoto out;\r\n}\r\ndev_entry = kmalloc(sizeof(*dev_entry), GFP_KERNEL);\r\nif (!dev_entry) {\r\nerr = -ENOMEM;\r\nxenbus_dev_fatal(pdev->xdev, err,\r\n"Error adding entry to virtual PCI bus");\r\ngoto out;\r\n}\r\ndev_entry->dev = dev;\r\nmutex_lock(&vpci_dev->lock);\r\nif (!dev->is_virtfn) {\r\nfor (slot = 0; slot < PCI_SLOT_MAX; slot++) {\r\nif (list_empty(&vpci_dev->dev_list[slot]))\r\ncontinue;\r\nt = list_entry(list_first(&vpci_dev->dev_list[slot]),\r\nstruct pci_dev_entry, list);\r\nif (match_slot(dev, t->dev)) {\r\npr_info(DRV_NAME ": vpci: %s: "\r\n"assign to virtual slot %d func %d\n",\r\npci_name(dev), slot,\r\nPCI_FUNC(dev->devfn));\r\nlist_add_tail(&dev_entry->list,\r\n&vpci_dev->dev_list[slot]);\r\nfunc = PCI_FUNC(dev->devfn);\r\ngoto unlock;\r\n}\r\n}\r\n}\r\nfor (slot = 0; slot < PCI_SLOT_MAX; slot++) {\r\nif (list_empty(&vpci_dev->dev_list[slot])) {\r\nprintk(KERN_INFO DRV_NAME\r\n": vpci: %s: assign to virtual slot %d\n",\r\npci_name(dev), slot);\r\nlist_add_tail(&dev_entry->list,\r\n&vpci_dev->dev_list[slot]);\r\nfunc = dev->is_virtfn ? 0 : PCI_FUNC(dev->devfn);\r\ngoto unlock;\r\n}\r\n}\r\nerr = -ENOMEM;\r\nxenbus_dev_fatal(pdev->xdev, err,\r\n"No more space on root virtual PCI bus");\r\nunlock:\r\nmutex_unlock(&vpci_dev->lock);\r\nif (!err)\r\nerr = publish_cb(pdev, 0, 0, PCI_DEVFN(slot, func), devid);\r\nout:\r\nreturn err;\r\n}\r\nstatic void __xen_pcibk_release_pci_dev(struct xen_pcibk_device *pdev,\r\nstruct pci_dev *dev)\r\n{\r\nint slot;\r\nstruct vpci_dev_data *vpci_dev = pdev->pci_dev_data;\r\nstruct pci_dev *found_dev = NULL;\r\nmutex_lock(&vpci_dev->lock);\r\nfor (slot = 0; slot < PCI_SLOT_MAX; slot++) {\r\nstruct pci_dev_entry *e;\r\nlist_for_each_entry(e, &vpci_dev->dev_list[slot], list) {\r\nif (e->dev == dev) {\r\nlist_del(&e->list);\r\nfound_dev = e->dev;\r\nkfree(e);\r\ngoto out;\r\n}\r\n}\r\n}\r\nout:\r\nmutex_unlock(&vpci_dev->lock);\r\nif (found_dev)\r\npcistub_put_pci_dev(found_dev);\r\n}\r\nstatic int __xen_pcibk_init_devices(struct xen_pcibk_device *pdev)\r\n{\r\nint slot;\r\nstruct vpci_dev_data *vpci_dev;\r\nvpci_dev = kmalloc(sizeof(*vpci_dev), GFP_KERNEL);\r\nif (!vpci_dev)\r\nreturn -ENOMEM;\r\nmutex_init(&vpci_dev->lock);\r\nfor (slot = 0; slot < PCI_SLOT_MAX; slot++)\r\nINIT_LIST_HEAD(&vpci_dev->dev_list[slot]);\r\npdev->pci_dev_data = vpci_dev;\r\nreturn 0;\r\n}\r\nstatic int __xen_pcibk_publish_pci_roots(struct xen_pcibk_device *pdev,\r\npublish_pci_root_cb publish_cb)\r\n{\r\nreturn publish_cb(pdev, 0, 0);\r\n}\r\nstatic void __xen_pcibk_release_devices(struct xen_pcibk_device *pdev)\r\n{\r\nint slot;\r\nstruct vpci_dev_data *vpci_dev = pdev->pci_dev_data;\r\nfor (slot = 0; slot < PCI_SLOT_MAX; slot++) {\r\nstruct pci_dev_entry *e, *tmp;\r\nlist_for_each_entry_safe(e, tmp, &vpci_dev->dev_list[slot],\r\nlist) {\r\nlist_del(&e->list);\r\npcistub_put_pci_dev(e->dev);\r\nkfree(e);\r\n}\r\n}\r\nkfree(vpci_dev);\r\npdev->pci_dev_data = NULL;\r\n}\r\nstatic int __xen_pcibk_get_pcifront_dev(struct pci_dev *pcidev,\r\nstruct xen_pcibk_device *pdev,\r\nunsigned int *domain, unsigned int *bus,\r\nunsigned int *devfn)\r\n{\r\nstruct pci_dev_entry *entry;\r\nstruct pci_dev *dev = NULL;\r\nstruct vpci_dev_data *vpci_dev = pdev->pci_dev_data;\r\nint found = 0, slot;\r\nmutex_lock(&vpci_dev->lock);\r\nfor (slot = 0; slot < PCI_SLOT_MAX; slot++) {\r\nlist_for_each_entry(entry,\r\n&vpci_dev->dev_list[slot],\r\nlist) {\r\ndev = entry->dev;\r\nif (dev && dev->bus->number == pcidev->bus->number\r\n&& pci_domain_nr(dev->bus) ==\r\npci_domain_nr(pcidev->bus)\r\n&& dev->devfn == pcidev->devfn) {\r\nfound = 1;\r\n*domain = 0;\r\n*bus = 0;\r\n*devfn = PCI_DEVFN(slot,\r\nPCI_FUNC(pcidev->devfn));\r\n}\r\n}\r\n}\r\nmutex_unlock(&vpci_dev->lock);\r\nreturn found;\r\n}
