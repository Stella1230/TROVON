int\r\nsgl_to_sgl_fcnvxf(\r\nint *srcptr,\r\nunsigned int *nullptr,\r\nsgl_floating_point *dstptr,\r\nunsigned int *status)\r\n{\r\nregister int src, dst_exponent;\r\nregister unsigned int result = 0;\r\nsrc = *srcptr;\r\nif (src < 0) {\r\nSgl_setone_sign(result);\r\nInt_negate(src);\r\n}\r\nelse {\r\nSgl_setzero_sign(result);\r\nif (src == 0) {\r\nSgl_setzero(result);\r\n*dstptr = result;\r\nreturn(NOEXCEPTION);\r\n}\r\n}\r\ndst_exponent = 16;\r\nFind_ms_one_bit(src,dst_exponent);\r\nif (dst_exponent >= 0) src <<= dst_exponent;\r\nelse src = 1 << 30;\r\nSgl_set_mantissa(result, src >> (SGL_EXP_LENGTH-1));\r\nSgl_set_exponent(result, 30+SGL_BIAS - dst_exponent);\r\nif (Int_isinexact_to_sgl(src)) {\r\nswitch (Rounding_mode()) {\r\ncase ROUNDPLUS:\r\nif (Sgl_iszero_sign(result))\r\nSgl_increment(result);\r\nbreak;\r\ncase ROUNDMINUS:\r\nif (Sgl_isone_sign(result))\r\nSgl_increment(result);\r\nbreak;\r\ncase ROUNDNEAREST:\r\nSgl_roundnearest_from_int(src,result);\r\n}\r\nif (Is_inexacttrap_enabled()) {\r\n*dstptr = result;\r\nreturn(INEXACTEXCEPTION);\r\n}\r\nelse Set_inexactflag();\r\n}\r\n*dstptr = result;\r\nreturn(NOEXCEPTION);\r\n}\r\nint\r\nsgl_to_dbl_fcnvxf(\r\nint *srcptr,\r\nunsigned int *nullptr,\r\ndbl_floating_point *dstptr,\r\nunsigned int *status)\r\n{\r\nregister int src, dst_exponent;\r\nregister unsigned int resultp1 = 0, resultp2 = 0;\r\nsrc = *srcptr;\r\nif (src < 0) {\r\nDbl_setone_sign(resultp1);\r\nInt_negate(src);\r\n}\r\nelse {\r\nDbl_setzero_sign(resultp1);\r\nif (src == 0) {\r\nDbl_setzero(resultp1,resultp2);\r\nDbl_copytoptr(resultp1,resultp2,dstptr);\r\nreturn(NOEXCEPTION);\r\n}\r\n}\r\ndst_exponent = 16;\r\nFind_ms_one_bit(src,dst_exponent);\r\nif (dst_exponent >= 0) src <<= dst_exponent;\r\nelse src = 1 << 30;\r\nDbl_set_mantissap1(resultp1, src >> DBL_EXP_LENGTH - 1);\r\nDbl_set_mantissap2(resultp2, src << (33-DBL_EXP_LENGTH));\r\nDbl_set_exponent(resultp1, (30+DBL_BIAS) - dst_exponent);\r\nDbl_copytoptr(resultp1,resultp2,dstptr);\r\nreturn(NOEXCEPTION);\r\n}\r\nint\r\ndbl_to_sgl_fcnvxf(\r\ndbl_integer *srcptr,\r\nunsigned int *nullptr,\r\nsgl_floating_point *dstptr,\r\nunsigned int *status)\r\n{\r\nint dst_exponent, srcp1;\r\nunsigned int result = 0, srcp2;\r\nDint_copyfromptr(srcptr,srcp1,srcp2);\r\nif (srcp1 < 0) {\r\nSgl_setone_sign(result);\r\nDint_negate(srcp1,srcp2);\r\n}\r\nelse {\r\nSgl_setzero_sign(result);\r\nif (srcp1 == 0 && srcp2 == 0) {\r\nSgl_setzero(result);\r\n*dstptr = result;\r\nreturn(NOEXCEPTION);\r\n}\r\n}\r\ndst_exponent = 16;\r\nif (srcp1 == 0) {\r\nFind_ms_one_bit(srcp2,dst_exponent);\r\nif (dst_exponent >= 0) {\r\nsrcp1 = srcp2 << dst_exponent;\r\nsrcp2 = 0;\r\n}\r\nelse {\r\nsrcp1 = srcp2 >> 1;\r\nsrcp2 <<= 31;\r\n}\r\ndst_exponent += 32;\r\n}\r\nelse {\r\nFind_ms_one_bit(srcp1,dst_exponent);\r\nif (dst_exponent > 0) {\r\nVariable_shift_double(srcp1,srcp2,(32-dst_exponent),\r\nsrcp1);\r\nsrcp2 <<= dst_exponent;\r\n}\r\nelse srcp1 >>= -(dst_exponent);\r\n}\r\nSgl_set_mantissa(result, srcp1 >> SGL_EXP_LENGTH - 1);\r\nSgl_set_exponent(result, (62+SGL_BIAS) - dst_exponent);\r\nif (Dint_isinexact_to_sgl(srcp1,srcp2)) {\r\nswitch (Rounding_mode()) {\r\ncase ROUNDPLUS:\r\nif (Sgl_iszero_sign(result))\r\nSgl_increment(result);\r\nbreak;\r\ncase ROUNDMINUS:\r\nif (Sgl_isone_sign(result))\r\nSgl_increment(result);\r\nbreak;\r\ncase ROUNDNEAREST:\r\nSgl_roundnearest_from_dint(srcp1,srcp2,result);\r\n}\r\nif (Is_inexacttrap_enabled()) {\r\n*dstptr = result;\r\nreturn(INEXACTEXCEPTION);\r\n}\r\nelse Set_inexactflag();\r\n}\r\n*dstptr = result;\r\nreturn(NOEXCEPTION);\r\n}\r\nint\r\ndbl_to_dbl_fcnvxf(\r\ndbl_integer *srcptr,\r\nunsigned int *nullptr,\r\ndbl_floating_point *dstptr,\r\nunsigned int *status)\r\n{\r\nregister int srcp1, dst_exponent;\r\nregister unsigned int srcp2, resultp1 = 0, resultp2 = 0;\r\nDint_copyfromptr(srcptr,srcp1,srcp2);\r\nif (srcp1 < 0) {\r\nDbl_setone_sign(resultp1);\r\nDint_negate(srcp1,srcp2);\r\n}\r\nelse {\r\nDbl_setzero_sign(resultp1);\r\nif (srcp1 == 0 && srcp2 ==0) {\r\nDbl_setzero(resultp1,resultp2);\r\nDbl_copytoptr(resultp1,resultp2,dstptr);\r\nreturn(NOEXCEPTION);\r\n}\r\n}\r\ndst_exponent = 16;\r\nif (srcp1 == 0) {\r\nFind_ms_one_bit(srcp2,dst_exponent);\r\nif (dst_exponent >= 0) {\r\nsrcp1 = srcp2 << dst_exponent;\r\nsrcp2 = 0;\r\n}\r\nelse {\r\nsrcp1 = srcp2 >> 1;\r\nsrcp2 <<= 31;\r\n}\r\ndst_exponent += 32;\r\n}\r\nelse {\r\nFind_ms_one_bit(srcp1,dst_exponent);\r\nif (dst_exponent > 0) {\r\nVariable_shift_double(srcp1,srcp2,(32-dst_exponent),\r\nsrcp1);\r\nsrcp2 <<= dst_exponent;\r\n}\r\nelse srcp1 >>= -(dst_exponent);\r\n}\r\nDbl_set_mantissap1(resultp1, srcp1 >> (DBL_EXP_LENGTH-1));\r\nShiftdouble(srcp1,srcp2,DBL_EXP_LENGTH-1,resultp2);\r\nDbl_set_exponent(resultp1, (62+DBL_BIAS) - dst_exponent);\r\nif (Dint_isinexact_to_dbl(srcp2)) {\r\nswitch (Rounding_mode()) {\r\ncase ROUNDPLUS:\r\nif (Dbl_iszero_sign(resultp1)) {\r\nDbl_increment(resultp1,resultp2);\r\n}\r\nbreak;\r\ncase ROUNDMINUS:\r\nif (Dbl_isone_sign(resultp1)) {\r\nDbl_increment(resultp1,resultp2);\r\n}\r\nbreak;\r\ncase ROUNDNEAREST:\r\nDbl_roundnearest_from_dint(srcp2,resultp1,\r\nresultp2);\r\n}\r\nif (Is_inexacttrap_enabled()) {\r\nDbl_copytoptr(resultp1,resultp2,dstptr);\r\nreturn(INEXACTEXCEPTION);\r\n}\r\nelse Set_inexactflag();\r\n}\r\nDbl_copytoptr(resultp1,resultp2,dstptr);\r\nreturn(NOEXCEPTION);\r\n}
