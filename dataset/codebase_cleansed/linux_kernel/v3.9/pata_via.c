static int via_cable_override(struct pci_dev *pdev)\r\n{\r\nif (dmi_check_system(cable_dmi_table))\r\nreturn 1;\r\nif (pdev->subsystem_vendor == 0x161F && pdev->subsystem_device == 0x2032)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic int via_cable_detect(struct ata_port *ap) {\r\nconst struct via_isa_bridge *config = ap->host->private_data;\r\nstruct pci_dev *pdev = to_pci_dev(ap->host->dev);\r\nu32 ata66;\r\nif (via_cable_override(pdev))\r\nreturn ATA_CBL_PATA40_SHORT;\r\nif ((config->flags & VIA_SATA_PATA) && ap->port_no == 0)\r\nreturn ATA_CBL_SATA;\r\nif (config->udma_mask < ATA_UDMA4)\r\nreturn ATA_CBL_PATA40;\r\nelse if (config->udma_mask < ATA_UDMA5)\r\nreturn ATA_CBL_PATA_UNK;\r\npci_read_config_dword(pdev, 0x50, &ata66);\r\nif (ata66 & (0x10100000 >> (16 * ap->port_no)))\r\nreturn ATA_CBL_PATA80;\r\nif (ata_acpi_init_gtm(ap) &&\r\nata_acpi_cbl_80wire(ap, ata_acpi_init_gtm(ap)))\r\nreturn ATA_CBL_PATA80;\r\nreturn ATA_CBL_PATA40;\r\n}\r\nstatic int via_pre_reset(struct ata_link *link, unsigned long deadline)\r\n{\r\nstruct ata_port *ap = link->ap;\r\nconst struct via_isa_bridge *config = ap->host->private_data;\r\nif (!(config->flags & VIA_NO_ENABLES)) {\r\nstatic const struct pci_bits via_enable_bits[] = {\r\n{ 0x40, 1, 0x02, 0x02 },\r\n{ 0x40, 1, 0x01, 0x01 }\r\n};\r\nstruct pci_dev *pdev = to_pci_dev(ap->host->dev);\r\nif (!pci_test_config_bits(pdev, &via_enable_bits[ap->port_no]))\r\nreturn -ENOENT;\r\n}\r\nreturn ata_sff_prereset(link, deadline);\r\n}\r\nstatic void via_do_set_mode(struct ata_port *ap, struct ata_device *adev,\r\nint mode, int set_ast, int udma_type)\r\n{\r\nstruct pci_dev *pdev = to_pci_dev(ap->host->dev);\r\nstruct ata_device *peer = ata_dev_pair(adev);\r\nstruct ata_timing t, p;\r\nstatic int via_clock = 33333;\r\nunsigned long T = 1000000000 / via_clock;\r\nunsigned long UT = T;\r\nint ut;\r\nint offset = 3 - (2*ap->port_no) - adev->devno;\r\nswitch (udma_type) {\r\ncase ATA_UDMA4:\r\nUT = T / 2; break;\r\ncase ATA_UDMA5:\r\nUT = T / 3; break;\r\ncase ATA_UDMA6:\r\nUT = T / 4; break;\r\n}\r\nata_timing_compute(adev, mode, &t, T, UT);\r\nif (peer) {\r\nif (peer->pio_mode) {\r\nata_timing_compute(peer, peer->pio_mode, &p, T, UT);\r\nata_timing_merge(&p, &t, &t, ATA_TIMING_8BIT);\r\n}\r\n}\r\nif (set_ast) {\r\nu8 setup;\r\nint shift = 2 * offset;\r\npci_read_config_byte(pdev, 0x4C, &setup);\r\nsetup &= ~(3 << shift);\r\nsetup |= (clamp_val(t.setup, 1, 4) - 1) << shift;\r\npci_write_config_byte(pdev, 0x4C, setup);\r\n}\r\npci_write_config_byte(pdev, 0x4F - ap->port_no,\r\n((clamp_val(t.act8b, 1, 16) - 1) << 4) | (clamp_val(t.rec8b, 1, 16) - 1));\r\npci_write_config_byte(pdev, 0x48 + offset,\r\n((clamp_val(t.active, 1, 16) - 1) << 4) | (clamp_val(t.recover, 1, 16) - 1));\r\nswitch (udma_type) {\r\ncase ATA_UDMA2:\r\ndefault:\r\nut = t.udma ? (0xe0 | (clamp_val(t.udma, 2, 5) - 2)) : 0x03;\r\nbreak;\r\ncase ATA_UDMA4:\r\nut = t.udma ? (0xe8 | (clamp_val(t.udma, 2, 9) - 2)) : 0x0f;\r\nbreak;\r\ncase ATA_UDMA5:\r\nut = t.udma ? (0xe0 | (clamp_val(t.udma, 2, 9) - 2)) : 0x07;\r\nbreak;\r\ncase ATA_UDMA6:\r\nut = t.udma ? (0xe0 | (clamp_val(t.udma, 2, 9) - 2)) : 0x07;\r\nbreak;\r\n}\r\nif (udma_type) {\r\nu8 udma_etc;\r\npci_read_config_byte(pdev, 0x50 + offset, &udma_etc);\r\nudma_etc &= ~0x20;\r\nif (t.udma) {\r\nudma_etc &= 0x10;\r\nudma_etc |= ut;\r\n}\r\npci_write_config_byte(pdev, 0x50 + offset, udma_etc);\r\n}\r\n}\r\nstatic void via_set_piomode(struct ata_port *ap, struct ata_device *adev)\r\n{\r\nconst struct via_isa_bridge *config = ap->host->private_data;\r\nint set_ast = (config->flags & VIA_BAD_AST) ? 0 : 1;\r\nvia_do_set_mode(ap, adev, adev->pio_mode, set_ast, config->udma_mask);\r\n}\r\nstatic void via_set_dmamode(struct ata_port *ap, struct ata_device *adev)\r\n{\r\nconst struct via_isa_bridge *config = ap->host->private_data;\r\nint set_ast = (config->flags & VIA_BAD_AST) ? 0 : 1;\r\nvia_do_set_mode(ap, adev, adev->dma_mode, set_ast, config->udma_mask);\r\n}\r\nstatic unsigned long via_mode_filter(struct ata_device *dev, unsigned long mask)\r\n{\r\nstruct ata_host *host = dev->link->ap->host;\r\nconst struct via_isa_bridge *config = host->private_data;\r\nunsigned char model_num[ATA_ID_PROD_LEN + 1];\r\nif (config->id == PCI_DEVICE_ID_VIA_82C586_0) {\r\nata_id_c_string(dev->id, model_num, ATA_ID_PROD, sizeof(model_num));\r\nif (strcmp(model_num, "TS64GSSD25-M") == 0) {\r\nata_dev_warn(dev,\r\n"disabling UDMA mode due to reported lockups with this device\n");\r\nmask &= ~ ATA_MASK_UDMA;\r\n}\r\n}\r\nif (dev->class == ATA_DEV_ATAPI &&\r\ndmi_check_system(no_atapi_dma_dmi_table)) {\r\nata_dev_warn(dev, "controller locks up on ATAPI DMA, forcing PIO\n");\r\nmask &= ATA_MASK_PIO;\r\n}\r\nreturn mask;\r\n}\r\nstatic void via_tf_load(struct ata_port *ap, const struct ata_taskfile *tf)\r\n{\r\nstruct ata_ioports *ioaddr = &ap->ioaddr;\r\nstruct via_port *vp = ap->private_data;\r\nunsigned int is_addr = tf->flags & ATA_TFLAG_ISADDR;\r\nint newctl = 0;\r\nif (tf->ctl != ap->last_ctl) {\r\niowrite8(tf->ctl, ioaddr->ctl_addr);\r\nap->last_ctl = tf->ctl;\r\nata_wait_idle(ap);\r\nnewctl = 1;\r\n}\r\nif (tf->flags & ATA_TFLAG_DEVICE) {\r\niowrite8(tf->device, ioaddr->device_addr);\r\nvp->cached_device = tf->device;\r\n} else if (newctl)\r\niowrite8(vp->cached_device, ioaddr->device_addr);\r\nif (is_addr && (tf->flags & ATA_TFLAG_LBA48)) {\r\nWARN_ON_ONCE(!ioaddr->ctl_addr);\r\niowrite8(tf->hob_feature, ioaddr->feature_addr);\r\niowrite8(tf->hob_nsect, ioaddr->nsect_addr);\r\niowrite8(tf->hob_lbal, ioaddr->lbal_addr);\r\niowrite8(tf->hob_lbam, ioaddr->lbam_addr);\r\niowrite8(tf->hob_lbah, ioaddr->lbah_addr);\r\nVPRINTK("hob: feat 0x%X nsect 0x%X, lba 0x%X 0x%X 0x%X\n",\r\ntf->hob_feature,\r\ntf->hob_nsect,\r\ntf->hob_lbal,\r\ntf->hob_lbam,\r\ntf->hob_lbah);\r\n}\r\nif (is_addr) {\r\niowrite8(tf->feature, ioaddr->feature_addr);\r\niowrite8(tf->nsect, ioaddr->nsect_addr);\r\niowrite8(tf->lbal, ioaddr->lbal_addr);\r\niowrite8(tf->lbam, ioaddr->lbam_addr);\r\niowrite8(tf->lbah, ioaddr->lbah_addr);\r\nVPRINTK("feat 0x%X nsect 0x%X lba 0x%X 0x%X 0x%X\n",\r\ntf->feature,\r\ntf->nsect,\r\ntf->lbal,\r\ntf->lbam,\r\ntf->lbah);\r\n}\r\nata_wait_idle(ap);\r\n}\r\nstatic int via_port_start(struct ata_port *ap)\r\n{\r\nstruct via_port *vp;\r\nstruct pci_dev *pdev = to_pci_dev(ap->host->dev);\r\nint ret = ata_bmdma_port_start(ap);\r\nif (ret < 0)\r\nreturn ret;\r\nvp = devm_kzalloc(&pdev->dev, sizeof(struct via_port), GFP_KERNEL);\r\nif (vp == NULL)\r\nreturn -ENOMEM;\r\nap->private_data = vp;\r\nreturn 0;\r\n}\r\nstatic void via_config_fifo(struct pci_dev *pdev, unsigned int flags)\r\n{\r\nu8 enable;\r\npci_read_config_byte(pdev, 0x40 , &enable);\r\nenable &= 3;\r\nif (flags & VIA_SET_FIFO) {\r\nstatic const u8 fifo_setting[4] = {0x00, 0x60, 0x00, 0x20};\r\nu8 fifo;\r\npci_read_config_byte(pdev, 0x43, &fifo);\r\nif (flags & VIA_BAD_PREQ)\r\nfifo &= 0x7F;\r\nelse\r\nfifo &= 0x9f;\r\nfifo |= fifo_setting[enable];\r\npci_write_config_byte(pdev, 0x43, fifo);\r\n}\r\n}\r\nstatic void via_fixup(struct pci_dev *pdev, const struct via_isa_bridge *config)\r\n{\r\nu32 timing;\r\nvia_config_fifo(pdev, config->flags);\r\nif (config->udma_mask == ATA_UDMA4) {\r\npci_read_config_dword(pdev, 0x50, &timing);\r\ntiming |= 0x80008;\r\npci_write_config_dword(pdev, 0x50, timing);\r\n}\r\nif (config->flags & VIA_BAD_CLK66) {\r\npci_read_config_dword(pdev, 0x50, &timing);\r\ntiming &= ~0x80008;\r\npci_write_config_dword(pdev, 0x50, timing);\r\n}\r\n}\r\nstatic int via_init_one(struct pci_dev *pdev, const struct pci_device_id *id)\r\n{\r\nstatic const struct ata_port_info via_mwdma_info = {\r\n.flags = ATA_FLAG_SLAVE_POSS,\r\n.pio_mask = ATA_PIO4,\r\n.mwdma_mask = ATA_MWDMA2,\r\n.port_ops = &via_port_ops\r\n};\r\nstatic const struct ata_port_info via_mwdma_info_borked = {\r\n.flags = ATA_FLAG_SLAVE_POSS,\r\n.pio_mask = ATA_PIO4,\r\n.mwdma_mask = ATA_MWDMA2,\r\n.port_ops = &via_port_ops_noirq,\r\n};\r\nstatic const struct ata_port_info via_udma33_info = {\r\n.flags = ATA_FLAG_SLAVE_POSS,\r\n.pio_mask = ATA_PIO4,\r\n.mwdma_mask = ATA_MWDMA2,\r\n.udma_mask = ATA_UDMA2,\r\n.port_ops = &via_port_ops\r\n};\r\nstatic const struct ata_port_info via_udma66_info = {\r\n.flags = ATA_FLAG_SLAVE_POSS,\r\n.pio_mask = ATA_PIO4,\r\n.mwdma_mask = ATA_MWDMA2,\r\n.udma_mask = ATA_UDMA4,\r\n.port_ops = &via_port_ops\r\n};\r\nstatic const struct ata_port_info via_udma100_info = {\r\n.flags = ATA_FLAG_SLAVE_POSS,\r\n.pio_mask = ATA_PIO4,\r\n.mwdma_mask = ATA_MWDMA2,\r\n.udma_mask = ATA_UDMA5,\r\n.port_ops = &via_port_ops\r\n};\r\nstatic const struct ata_port_info via_udma133_info = {\r\n.flags = ATA_FLAG_SLAVE_POSS,\r\n.pio_mask = ATA_PIO4,\r\n.mwdma_mask = ATA_MWDMA2,\r\n.udma_mask = ATA_UDMA6,\r\n.port_ops = &via_port_ops\r\n};\r\nconst struct ata_port_info *ppi[] = { NULL, NULL };\r\nstruct pci_dev *isa;\r\nconst struct via_isa_bridge *config;\r\nu8 enable;\r\nunsigned long flags = id->driver_data;\r\nint rc;\r\nata_print_version_once(&pdev->dev, DRV_VERSION);\r\nrc = pcim_enable_device(pdev);\r\nif (rc)\r\nreturn rc;\r\nif (flags & VIA_IDFLAG_SINGLE)\r\nppi[1] = &ata_dummy_port_info;\r\nfor (config = via_isa_bridges; config->id != PCI_DEVICE_ID_VIA_ANON;\r\nconfig++)\r\nif ((isa = pci_get_device(PCI_VENDOR_ID_VIA +\r\n!!(config->flags & VIA_BAD_ID),\r\nconfig->id, NULL))) {\r\nu8 rev = isa->revision;\r\npci_dev_put(isa);\r\nif ((id->device == 0x0415 || id->device == 0x3164) &&\r\n(config->id != id->device))\r\ncontinue;\r\nif (rev >= config->rev_min && rev <= config->rev_max)\r\nbreak;\r\n}\r\nif (!(config->flags & VIA_NO_ENABLES)) {\r\npci_read_config_byte(pdev, 0x40 , &enable);\r\nenable &= 3;\r\nif (enable == 0)\r\nreturn -ENODEV;\r\n}\r\nswitch (config->udma_mask) {\r\ncase 0x00:\r\nif (config->flags & VIA_NO_UNMASK)\r\nppi[0] = &via_mwdma_info_borked;\r\nelse\r\nppi[0] = &via_mwdma_info;\r\nbreak;\r\ncase ATA_UDMA2:\r\nppi[0] = &via_udma33_info;\r\nbreak;\r\ncase ATA_UDMA4:\r\nppi[0] = &via_udma66_info;\r\nbreak;\r\ncase ATA_UDMA5:\r\nppi[0] = &via_udma100_info;\r\nbreak;\r\ncase ATA_UDMA6:\r\nppi[0] = &via_udma133_info;\r\nbreak;\r\ndefault:\r\nWARN_ON(1);\r\nreturn -ENODEV;\r\n}\r\nvia_fixup(pdev, config);\r\nreturn ata_pci_bmdma_init_one(pdev, ppi, &via_sht, (void *)config, 0);\r\n}\r\nstatic int via_reinit_one(struct pci_dev *pdev)\r\n{\r\nstruct ata_host *host = dev_get_drvdata(&pdev->dev);\r\nint rc;\r\nrc = ata_pci_device_do_resume(pdev);\r\nif (rc)\r\nreturn rc;\r\nvia_fixup(pdev, host->private_data);\r\nata_host_resume(host);\r\nreturn 0;\r\n}
