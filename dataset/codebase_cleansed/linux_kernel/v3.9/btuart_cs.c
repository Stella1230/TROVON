static int btuart_write(unsigned int iobase, int fifo_size, __u8 *buf, int len)\r\n{\r\nint actual = 0;\r\nif (!(inb(iobase + UART_LSR) & UART_LSR_THRE))\r\nreturn 0;\r\nwhile ((fifo_size-- > 0) && (actual < len)) {\r\noutb(buf[actual], iobase + UART_TX);\r\nactual++;\r\n}\r\nreturn actual;\r\n}\r\nstatic void btuart_write_wakeup(btuart_info_t *info)\r\n{\r\nif (!info) {\r\nBT_ERR("Unknown device");\r\nreturn;\r\n}\r\nif (test_and_set_bit(XMIT_SENDING, &(info->tx_state))) {\r\nset_bit(XMIT_WAKEUP, &(info->tx_state));\r\nreturn;\r\n}\r\ndo {\r\nunsigned int iobase = info->p_dev->resource[0]->start;\r\nregister struct sk_buff *skb;\r\nint len;\r\nclear_bit(XMIT_WAKEUP, &(info->tx_state));\r\nif (!pcmcia_dev_present(info->p_dev))\r\nreturn;\r\nif (!(skb = skb_dequeue(&(info->txq))))\r\nbreak;\r\nlen = btuart_write(iobase, 16, skb->data, skb->len);\r\nset_bit(XMIT_WAKEUP, &(info->tx_state));\r\nif (len == skb->len) {\r\nkfree_skb(skb);\r\n} else {\r\nskb_pull(skb, len);\r\nskb_queue_head(&(info->txq), skb);\r\n}\r\ninfo->hdev->stat.byte_tx += len;\r\n} while (test_bit(XMIT_WAKEUP, &(info->tx_state)));\r\nclear_bit(XMIT_SENDING, &(info->tx_state));\r\n}\r\nstatic void btuart_receive(btuart_info_t *info)\r\n{\r\nunsigned int iobase;\r\nint boguscount = 0;\r\nif (!info) {\r\nBT_ERR("Unknown device");\r\nreturn;\r\n}\r\niobase = info->p_dev->resource[0]->start;\r\ndo {\r\ninfo->hdev->stat.byte_rx++;\r\nif (info->rx_skb == NULL) {\r\ninfo->rx_state = RECV_WAIT_PACKET_TYPE;\r\ninfo->rx_count = 0;\r\nif (!(info->rx_skb = bt_skb_alloc(HCI_MAX_FRAME_SIZE, GFP_ATOMIC))) {\r\nBT_ERR("Can't allocate mem for new packet");\r\nreturn;\r\n}\r\n}\r\nif (info->rx_state == RECV_WAIT_PACKET_TYPE) {\r\ninfo->rx_skb->dev = (void *) info->hdev;\r\nbt_cb(info->rx_skb)->pkt_type = inb(iobase + UART_RX);\r\nswitch (bt_cb(info->rx_skb)->pkt_type) {\r\ncase HCI_EVENT_PKT:\r\ninfo->rx_state = RECV_WAIT_EVENT_HEADER;\r\ninfo->rx_count = HCI_EVENT_HDR_SIZE;\r\nbreak;\r\ncase HCI_ACLDATA_PKT:\r\ninfo->rx_state = RECV_WAIT_ACL_HEADER;\r\ninfo->rx_count = HCI_ACL_HDR_SIZE;\r\nbreak;\r\ncase HCI_SCODATA_PKT:\r\ninfo->rx_state = RECV_WAIT_SCO_HEADER;\r\ninfo->rx_count = HCI_SCO_HDR_SIZE;\r\nbreak;\r\ndefault:\r\nBT_ERR("Unknown HCI packet with type 0x%02x received", bt_cb(info->rx_skb)->pkt_type);\r\ninfo->hdev->stat.err_rx++;\r\nclear_bit(HCI_RUNNING, &(info->hdev->flags));\r\nkfree_skb(info->rx_skb);\r\ninfo->rx_skb = NULL;\r\nbreak;\r\n}\r\n} else {\r\n*skb_put(info->rx_skb, 1) = inb(iobase + UART_RX);\r\ninfo->rx_count--;\r\nif (info->rx_count == 0) {\r\nint dlen;\r\nstruct hci_event_hdr *eh;\r\nstruct hci_acl_hdr *ah;\r\nstruct hci_sco_hdr *sh;\r\nswitch (info->rx_state) {\r\ncase RECV_WAIT_EVENT_HEADER:\r\neh = hci_event_hdr(info->rx_skb);\r\ninfo->rx_state = RECV_WAIT_DATA;\r\ninfo->rx_count = eh->plen;\r\nbreak;\r\ncase RECV_WAIT_ACL_HEADER:\r\nah = hci_acl_hdr(info->rx_skb);\r\ndlen = __le16_to_cpu(ah->dlen);\r\ninfo->rx_state = RECV_WAIT_DATA;\r\ninfo->rx_count = dlen;\r\nbreak;\r\ncase RECV_WAIT_SCO_HEADER:\r\nsh = hci_sco_hdr(info->rx_skb);\r\ninfo->rx_state = RECV_WAIT_DATA;\r\ninfo->rx_count = sh->dlen;\r\nbreak;\r\ncase RECV_WAIT_DATA:\r\nhci_recv_frame(info->rx_skb);\r\ninfo->rx_skb = NULL;\r\nbreak;\r\n}\r\n}\r\n}\r\nif (boguscount++ > 16)\r\nbreak;\r\n} while (inb(iobase + UART_LSR) & UART_LSR_DR);\r\n}\r\nstatic irqreturn_t btuart_interrupt(int irq, void *dev_inst)\r\n{\r\nbtuart_info_t *info = dev_inst;\r\nunsigned int iobase;\r\nint boguscount = 0;\r\nint iir, lsr;\r\nirqreturn_t r = IRQ_NONE;\r\nif (!info || !info->hdev)\r\nreturn IRQ_NONE;\r\niobase = info->p_dev->resource[0]->start;\r\nspin_lock(&(info->lock));\r\niir = inb(iobase + UART_IIR) & UART_IIR_ID;\r\nwhile (iir) {\r\nr = IRQ_HANDLED;\r\nlsr = inb(iobase + UART_LSR);\r\nswitch (iir) {\r\ncase UART_IIR_RLSI:\r\nBT_ERR("RLSI");\r\nbreak;\r\ncase UART_IIR_RDI:\r\nbtuart_receive(info);\r\nbreak;\r\ncase UART_IIR_THRI:\r\nif (lsr & UART_LSR_THRE) {\r\nbtuart_write_wakeup(info);\r\n}\r\nbreak;\r\ndefault:\r\nBT_ERR("Unhandled IIR=%#x", iir);\r\nbreak;\r\n}\r\nif (boguscount++ > 100)\r\nbreak;\r\niir = inb(iobase + UART_IIR) & UART_IIR_ID;\r\n}\r\nspin_unlock(&(info->lock));\r\nreturn r;\r\n}\r\nstatic void btuart_change_speed(btuart_info_t *info, unsigned int speed)\r\n{\r\nunsigned long flags;\r\nunsigned int iobase;\r\nint fcr;\r\nint lcr;\r\nint divisor;\r\nif (!info) {\r\nBT_ERR("Unknown device");\r\nreturn;\r\n}\r\niobase = info->p_dev->resource[0]->start;\r\nspin_lock_irqsave(&(info->lock), flags);\r\noutb(0, iobase + UART_IER);\r\ndivisor = SPEED_MAX / speed;\r\nfcr = UART_FCR_ENABLE_FIFO | UART_FCR_CLEAR_RCVR | UART_FCR_CLEAR_XMIT;\r\nif (speed < 38400)\r\nfcr |= UART_FCR_TRIGGER_1;\r\nelse\r\nfcr |= UART_FCR_TRIGGER_14;\r\nlcr = UART_LCR_WLEN8;\r\noutb(UART_LCR_DLAB | lcr, iobase + UART_LCR);\r\noutb(divisor & 0xff, iobase + UART_DLL);\r\noutb(divisor >> 8, iobase + UART_DLM);\r\noutb(lcr, iobase + UART_LCR);\r\noutb(fcr, iobase + UART_FCR);\r\noutb(UART_IER_RLSI | UART_IER_RDI | UART_IER_THRI, iobase + UART_IER);\r\nspin_unlock_irqrestore(&(info->lock), flags);\r\n}\r\nstatic int btuart_hci_flush(struct hci_dev *hdev)\r\n{\r\nbtuart_info_t *info = hci_get_drvdata(hdev);\r\nskb_queue_purge(&(info->txq));\r\nreturn 0;\r\n}\r\nstatic int btuart_hci_open(struct hci_dev *hdev)\r\n{\r\nset_bit(HCI_RUNNING, &(hdev->flags));\r\nreturn 0;\r\n}\r\nstatic int btuart_hci_close(struct hci_dev *hdev)\r\n{\r\nif (!test_and_clear_bit(HCI_RUNNING, &(hdev->flags)))\r\nreturn 0;\r\nbtuart_hci_flush(hdev);\r\nreturn 0;\r\n}\r\nstatic int btuart_hci_send_frame(struct sk_buff *skb)\r\n{\r\nbtuart_info_t *info;\r\nstruct hci_dev *hdev = (struct hci_dev *)(skb->dev);\r\nif (!hdev) {\r\nBT_ERR("Frame for unknown HCI device (hdev=NULL)");\r\nreturn -ENODEV;\r\n}\r\ninfo = hci_get_drvdata(hdev);\r\nswitch (bt_cb(skb)->pkt_type) {\r\ncase HCI_COMMAND_PKT:\r\nhdev->stat.cmd_tx++;\r\nbreak;\r\ncase HCI_ACLDATA_PKT:\r\nhdev->stat.acl_tx++;\r\nbreak;\r\ncase HCI_SCODATA_PKT:\r\nhdev->stat.sco_tx++;\r\nbreak;\r\n}\r\nmemcpy(skb_push(skb, 1), &bt_cb(skb)->pkt_type, 1);\r\nskb_queue_tail(&(info->txq), skb);\r\nbtuart_write_wakeup(info);\r\nreturn 0;\r\n}\r\nstatic int btuart_hci_ioctl(struct hci_dev *hdev, unsigned int cmd, unsigned long arg)\r\n{\r\nreturn -ENOIOCTLCMD;\r\n}\r\nstatic int btuart_open(btuart_info_t *info)\r\n{\r\nunsigned long flags;\r\nunsigned int iobase = info->p_dev->resource[0]->start;\r\nstruct hci_dev *hdev;\r\nspin_lock_init(&(info->lock));\r\nskb_queue_head_init(&(info->txq));\r\ninfo->rx_state = RECV_WAIT_PACKET_TYPE;\r\ninfo->rx_count = 0;\r\ninfo->rx_skb = NULL;\r\nhdev = hci_alloc_dev();\r\nif (!hdev) {\r\nBT_ERR("Can't allocate HCI device");\r\nreturn -ENOMEM;\r\n}\r\ninfo->hdev = hdev;\r\nhdev->bus = HCI_PCCARD;\r\nhci_set_drvdata(hdev, info);\r\nSET_HCIDEV_DEV(hdev, &info->p_dev->dev);\r\nhdev->open = btuart_hci_open;\r\nhdev->close = btuart_hci_close;\r\nhdev->flush = btuart_hci_flush;\r\nhdev->send = btuart_hci_send_frame;\r\nhdev->ioctl = btuart_hci_ioctl;\r\nspin_lock_irqsave(&(info->lock), flags);\r\noutb(0, iobase + UART_MCR);\r\noutb(0, iobase + UART_IER);\r\noutb(UART_LCR_WLEN8, iobase + UART_LCR);\r\noutb((UART_MCR_DTR | UART_MCR_RTS | UART_MCR_OUT2), iobase + UART_MCR);\r\nspin_unlock_irqrestore(&(info->lock), flags);\r\nbtuart_change_speed(info, DEFAULT_BAUD_RATE);\r\nmsleep(1000);\r\nif (hci_register_dev(hdev) < 0) {\r\nBT_ERR("Can't register HCI device");\r\ninfo->hdev = NULL;\r\nhci_free_dev(hdev);\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\n}\r\nstatic int btuart_close(btuart_info_t *info)\r\n{\r\nunsigned long flags;\r\nunsigned int iobase = info->p_dev->resource[0]->start;\r\nstruct hci_dev *hdev = info->hdev;\r\nif (!hdev)\r\nreturn -ENODEV;\r\nbtuart_hci_close(hdev);\r\nspin_lock_irqsave(&(info->lock), flags);\r\noutb(0, iobase + UART_MCR);\r\noutb(0, iobase + UART_IER);\r\nspin_unlock_irqrestore(&(info->lock), flags);\r\nhci_unregister_dev(hdev);\r\nhci_free_dev(hdev);\r\nreturn 0;\r\n}\r\nstatic int btuart_probe(struct pcmcia_device *link)\r\n{\r\nbtuart_info_t *info;\r\ninfo = devm_kzalloc(&link->dev, sizeof(*info), GFP_KERNEL);\r\nif (!info)\r\nreturn -ENOMEM;\r\ninfo->p_dev = link;\r\nlink->priv = info;\r\nlink->config_flags |= CONF_ENABLE_IRQ | CONF_AUTO_SET_VPP |\r\nCONF_AUTO_SET_IO;\r\nreturn btuart_config(link);\r\n}\r\nstatic void btuart_detach(struct pcmcia_device *link)\r\n{\r\nbtuart_release(link);\r\n}\r\nstatic int btuart_check_config(struct pcmcia_device *p_dev, void *priv_data)\r\n{\r\nint *try = priv_data;\r\nif (!try)\r\np_dev->io_lines = 16;\r\nif ((p_dev->resource[0]->end != 8) || (p_dev->resource[0]->start == 0))\r\nreturn -EINVAL;\r\np_dev->resource[0]->end = 8;\r\np_dev->resource[0]->flags &= ~IO_DATA_PATH_WIDTH;\r\np_dev->resource[0]->flags |= IO_DATA_PATH_WIDTH_8;\r\nreturn pcmcia_request_io(p_dev);\r\n}\r\nstatic int btuart_check_config_notpicky(struct pcmcia_device *p_dev,\r\nvoid *priv_data)\r\n{\r\nstatic unsigned int base[5] = { 0x3f8, 0x2f8, 0x3e8, 0x2e8, 0x0 };\r\nint j;\r\nif (p_dev->io_lines > 3)\r\nreturn -ENODEV;\r\np_dev->resource[0]->flags &= ~IO_DATA_PATH_WIDTH;\r\np_dev->resource[0]->flags |= IO_DATA_PATH_WIDTH_8;\r\np_dev->resource[0]->end = 8;\r\nfor (j = 0; j < 5; j++) {\r\np_dev->resource[0]->start = base[j];\r\np_dev->io_lines = base[j] ? 16 : 3;\r\nif (!pcmcia_request_io(p_dev))\r\nreturn 0;\r\n}\r\nreturn -ENODEV;\r\n}\r\nstatic int btuart_config(struct pcmcia_device *link)\r\n{\r\nbtuart_info_t *info = link->priv;\r\nint i;\r\nint try;\r\nfor (try = 0; try < 2; try++)\r\nif (!pcmcia_loop_config(link, btuart_check_config, &try))\r\ngoto found_port;\r\nif (!pcmcia_loop_config(link, btuart_check_config_notpicky, NULL))\r\ngoto found_port;\r\nBT_ERR("No usable port range found");\r\ngoto failed;\r\nfound_port:\r\ni = pcmcia_request_irq(link, btuart_interrupt);\r\nif (i != 0)\r\ngoto failed;\r\ni = pcmcia_enable_device(link);\r\nif (i != 0)\r\ngoto failed;\r\nif (btuart_open(info) != 0)\r\ngoto failed;\r\nreturn 0;\r\nfailed:\r\nbtuart_release(link);\r\nreturn -ENODEV;\r\n}\r\nstatic void btuart_release(struct pcmcia_device *link)\r\n{\r\nbtuart_info_t *info = link->priv;\r\nbtuart_close(info);\r\npcmcia_disable_device(link);\r\n}\r\nstatic int __init init_btuart_cs(void)\r\n{\r\nreturn pcmcia_register_driver(&btuart_driver);\r\n}\r\nstatic void __exit exit_btuart_cs(void)\r\n{\r\npcmcia_unregister_driver(&btuart_driver);\r\n}
