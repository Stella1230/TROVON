static int visor_open(struct tty_struct *tty, struct usb_serial_port *port)\r\n{\r\nint result = 0;\r\nif (!port->read_urb) {\r\ndev_err(&port->dev, "Device lied about number of ports, please use a lower one.\n");\r\nreturn -ENODEV;\r\n}\r\nresult = usb_serial_generic_open(tty, port);\r\nif (result)\r\ngoto exit;\r\nif (port->interrupt_in_urb) {\r\ndev_dbg(&port->dev, "adding interrupt input for treo\n");\r\nresult = usb_submit_urb(port->interrupt_in_urb, GFP_KERNEL);\r\nif (result)\r\ndev_err(&port->dev,\r\n"%s - failed submitting interrupt urb, error %d\n",\r\n__func__, result);\r\n}\r\nexit:\r\nreturn result;\r\n}\r\nstatic void visor_close(struct usb_serial_port *port)\r\n{\r\nunsigned char *transfer_buffer;\r\nusb_serial_generic_close(port);\r\nusb_kill_urb(port->interrupt_in_urb);\r\nmutex_lock(&port->serial->disc_mutex);\r\nif (!port->serial->disconnected) {\r\ntransfer_buffer = kmalloc(0x12, GFP_KERNEL);\r\nif (transfer_buffer) {\r\nusb_control_msg(port->serial->dev,\r\nusb_rcvctrlpipe(port->serial->dev, 0),\r\nVISOR_CLOSE_NOTIFICATION, 0xc2,\r\n0x0000, 0x0000,\r\ntransfer_buffer, 0x12, 300);\r\nkfree(transfer_buffer);\r\n}\r\n}\r\nmutex_unlock(&port->serial->disc_mutex);\r\n}\r\nstatic void visor_read_int_callback(struct urb *urb)\r\n{\r\nstruct usb_serial_port *port = urb->context;\r\nint status = urb->status;\r\nint result;\r\nswitch (status) {\r\ncase 0:\r\nbreak;\r\ncase -ECONNRESET:\r\ncase -ENOENT:\r\ncase -ESHUTDOWN:\r\ndev_dbg(&port->dev, "%s - urb shutting down with status: %d\n",\r\n__func__, status);\r\nreturn;\r\ndefault:\r\ndev_dbg(&port->dev, "%s - nonzero urb status received: %d\n",\r\n__func__, status);\r\ngoto exit;\r\n}\r\nusb_serial_debug_data(&port->dev, __func__, urb->actual_length,\r\nurb->transfer_buffer);\r\nexit:\r\nresult = usb_submit_urb(urb, GFP_ATOMIC);\r\nif (result)\r\ndev_err(&urb->dev->dev,\r\n"%s - Error %d submitting interrupt urb\n",\r\n__func__, result);\r\n}\r\nstatic int palm_os_3_probe(struct usb_serial *serial,\r\nconst struct usb_device_id *id)\r\n{\r\nstruct device *dev = &serial->dev->dev;\r\nstruct visor_connection_info *connection_info;\r\nunsigned char *transfer_buffer;\r\nchar *string;\r\nint retval = 0;\r\nint i;\r\nint num_ports = 0;\r\ntransfer_buffer = kmalloc(sizeof(*connection_info), GFP_KERNEL);\r\nif (!transfer_buffer) {\r\ndev_err(dev, "%s - kmalloc(%Zd) failed.\n", __func__,\r\nsizeof(*connection_info));\r\nreturn -ENOMEM;\r\n}\r\nretval = usb_control_msg(serial->dev,\r\nusb_rcvctrlpipe(serial->dev, 0),\r\nVISOR_GET_CONNECTION_INFORMATION,\r\n0xc2, 0x0000, 0x0000, transfer_buffer,\r\nsizeof(*connection_info), 300);\r\nif (retval < 0) {\r\ndev_err(dev, "%s - error %d getting connection information\n",\r\n__func__, retval);\r\ngoto exit;\r\n}\r\nif (retval == sizeof(*connection_info)) {\r\nconnection_info = (struct visor_connection_info *)\r\ntransfer_buffer;\r\nnum_ports = le16_to_cpu(connection_info->num_ports);\r\nfor (i = 0; i < num_ports; ++i) {\r\nswitch (\r\nconnection_info->connections[i].port_function_id) {\r\ncase VISOR_FUNCTION_GENERIC:\r\nstring = "Generic";\r\nbreak;\r\ncase VISOR_FUNCTION_DEBUGGER:\r\nstring = "Debugger";\r\nbreak;\r\ncase VISOR_FUNCTION_HOTSYNC:\r\nstring = "HotSync";\r\nbreak;\r\ncase VISOR_FUNCTION_CONSOLE:\r\nstring = "Console";\r\nbreak;\r\ncase VISOR_FUNCTION_REMOTE_FILE_SYS:\r\nstring = "Remote File System";\r\nbreak;\r\ndefault:\r\nstring = "unknown";\r\nbreak;\r\n}\r\ndev_info(dev, "%s: port %d, is for %s use\n",\r\nserial->type->description,\r\nconnection_info->connections[i].port, string);\r\n}\r\n}\r\nif (num_ports == 0 || num_ports > 2) {\r\ndev_warn(dev, "%s: No valid connect info available\n",\r\nserial->type->description);\r\nnum_ports = 2;\r\n}\r\ndev_info(dev, "%s: Number of ports: %d\n", serial->type->description,\r\nnum_ports);\r\nusb_set_serial_data(serial, (void *)(long)num_ports);\r\nretval = usb_control_msg(serial->dev,\r\nusb_rcvctrlpipe(serial->dev, 0),\r\nVISOR_REQUEST_BYTES_AVAILABLE,\r\n0xc2, 0x0000, 0x0005, transfer_buffer,\r\n0x02, 300);\r\nif (retval < 0)\r\ndev_err(dev, "%s - error %d getting bytes available request\n",\r\n__func__, retval);\r\nretval = 0;\r\nexit:\r\nkfree(transfer_buffer);\r\nreturn retval;\r\n}\r\nstatic int palm_os_4_probe(struct usb_serial *serial,\r\nconst struct usb_device_id *id)\r\n{\r\nstruct device *dev = &serial->dev->dev;\r\nstruct palm_ext_connection_info *connection_info;\r\nunsigned char *transfer_buffer;\r\nint retval;\r\ntransfer_buffer = kmalloc(sizeof(*connection_info), GFP_KERNEL);\r\nif (!transfer_buffer) {\r\ndev_err(dev, "%s - kmalloc(%Zd) failed.\n", __func__,\r\nsizeof(*connection_info));\r\nreturn -ENOMEM;\r\n}\r\nretval = usb_control_msg(serial->dev,\r\nusb_rcvctrlpipe(serial->dev, 0),\r\nPALM_GET_EXT_CONNECTION_INFORMATION,\r\n0xc2, 0x0000, 0x0000, transfer_buffer,\r\nsizeof(*connection_info), 300);\r\nif (retval < 0)\r\ndev_err(dev, "%s - error %d getting connection info\n",\r\n__func__, retval);\r\nelse\r\nusb_serial_debug_data(dev, __func__, retval, transfer_buffer);\r\nkfree(transfer_buffer);\r\nreturn 0;\r\n}\r\nstatic int visor_probe(struct usb_serial *serial,\r\nconst struct usb_device_id *id)\r\n{\r\nint retval = 0;\r\nint (*startup)(struct usb_serial *serial,\r\nconst struct usb_device_id *id);\r\nif (id->idVendor == SAMSUNG_VENDOR_ID &&\r\nid->idProduct == SAMSUNG_SPH_I500_ID &&\r\nserial->dev->descriptor.bDeviceClass == USB_CLASS_COMM &&\r\nserial->dev->descriptor.bDeviceSubClass ==\r\nUSB_CDC_SUBCLASS_ACM)\r\nreturn -ENODEV;\r\nif (serial->dev->actconfig->desc.bConfigurationValue != 1) {\r\ndev_err(&serial->dev->dev, "active config #%d != 1 ??\n",\r\nserial->dev->actconfig->desc.bConfigurationValue);\r\nreturn -ENODEV;\r\n}\r\nif (id->driver_info) {\r\nstartup = (void *)id->driver_info;\r\nretval = startup(serial, id);\r\n}\r\nreturn retval;\r\n}\r\nstatic int visor_calc_num_ports(struct usb_serial *serial)\r\n{\r\nint num_ports = (int)(long)(usb_get_serial_data(serial));\r\nif (num_ports)\r\nusb_set_serial_data(serial, NULL);\r\nreturn num_ports;\r\n}\r\nstatic int clie_3_5_startup(struct usb_serial *serial)\r\n{\r\nstruct device *dev = &serial->dev->dev;\r\nint result;\r\nu8 *data;\r\ndata = kmalloc(1, GFP_KERNEL);\r\nif (!data)\r\nreturn -ENOMEM;\r\nresult = usb_control_msg(serial->dev, usb_rcvctrlpipe(serial->dev, 0),\r\nUSB_REQ_GET_CONFIGURATION, USB_DIR_IN,\r\n0, 0, data, 1, 3000);\r\nif (result < 0) {\r\ndev_err(dev, "%s: get config number failed: %d\n",\r\n__func__, result);\r\ngoto out;\r\n}\r\nif (result != 1) {\r\ndev_err(dev, "%s: get config number bad return length: %d\n",\r\n__func__, result);\r\nresult = -EIO;\r\ngoto out;\r\n}\r\nresult = usb_control_msg(serial->dev, usb_rcvctrlpipe(serial->dev, 0),\r\nUSB_REQ_GET_INTERFACE,\r\nUSB_DIR_IN | USB_RECIP_INTERFACE,\r\n0, 0, data, 1, 3000);\r\nif (result < 0) {\r\ndev_err(dev, "%s: get interface number failed: %d\n",\r\n__func__, result);\r\ngoto out;\r\n}\r\nif (result != 1) {\r\ndev_err(dev,\r\n"%s: get interface number bad return length: %d\n",\r\n__func__, result);\r\nresult = -EIO;\r\ngoto out;\r\n}\r\nresult = 0;\r\nout:\r\nkfree(data);\r\nreturn result;\r\n}\r\nstatic int treo_attach(struct usb_serial *serial)\r\n{\r\nstruct usb_serial_port *swap_port;\r\nif (!((le16_to_cpu(serial->dev->descriptor.idVendor)\r\n== HANDSPRING_VENDOR_ID) ||\r\n(le16_to_cpu(serial->dev->descriptor.idVendor)\r\n== KYOCERA_VENDOR_ID)) ||\r\n(serial->num_interrupt_in == 0))\r\nreturn 0;\r\n#define COPY_PORT(dest, src) \\r\ndo { \\r\ndest->read_urb = src->read_urb; \\r\ndest->bulk_in_endpointAddress = src->bulk_in_endpointAddress;\\r\ndest->bulk_in_buffer = src->bulk_in_buffer; \\r\ndest->interrupt_in_urb = src->interrupt_in_urb; \\r\ndest->interrupt_in_endpointAddress = \\r\nsrc->interrupt_in_endpointAddress;\\r\ndest->interrupt_in_buffer = src->interrupt_in_buffer; \\r\n} while (0);\r\nswap_port = kmalloc(sizeof(*swap_port), GFP_KERNEL);\r\nif (!swap_port)\r\nreturn -ENOMEM;\r\nCOPY_PORT(swap_port, serial->port[0]);\r\nCOPY_PORT(serial->port[0], serial->port[1]);\r\nCOPY_PORT(serial->port[1], swap_port);\r\nkfree(swap_port);\r\nreturn 0;\r\n}\r\nstatic int clie_5_attach(struct usb_serial *serial)\r\n{\r\nstruct usb_serial_port *port;\r\nunsigned int pipe;\r\nint j;\r\nif (serial->num_ports < 2)\r\nreturn -1;\r\nport = serial->port[0];\r\nport->bulk_out_endpointAddress =\r\nserial->port[1]->bulk_out_endpointAddress;\r\npipe = usb_sndbulkpipe(serial->dev, port->bulk_out_endpointAddress);\r\nfor (j = 0; j < ARRAY_SIZE(port->write_urbs); ++j)\r\nport->write_urbs[j]->pipe = pipe;\r\nreturn 0;\r\n}
