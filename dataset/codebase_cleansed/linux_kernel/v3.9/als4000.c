static inline void snd_als4k_iobase_writeb(unsigned long iobase,\r\nenum als4k_iobase_t reg,\r\nu8 val)\r\n{\r\noutb(val, iobase + reg);\r\n}\r\nstatic inline void snd_als4k_iobase_writel(unsigned long iobase,\r\nenum als4k_iobase_t reg,\r\nu32 val)\r\n{\r\noutl(val, iobase + reg);\r\n}\r\nstatic inline u8 snd_als4k_iobase_readb(unsigned long iobase,\r\nenum als4k_iobase_t reg)\r\n{\r\nreturn inb(iobase + reg);\r\n}\r\nstatic inline u32 snd_als4k_iobase_readl(unsigned long iobase,\r\nenum als4k_iobase_t reg)\r\n{\r\nreturn inl(iobase + reg);\r\n}\r\nstatic inline void snd_als4k_gcr_write_addr(unsigned long iobase,\r\nenum als4k_gcr_t reg,\r\nu32 val)\r\n{\r\nsnd_als4k_iobase_writeb(iobase, ALS4K_IOB_0C_GCR_INDEX, reg);\r\nsnd_als4k_iobase_writel(iobase, ALS4K_IOD_08_GCR_DATA, val);\r\n}\r\nstatic inline void snd_als4k_gcr_write(struct snd_sb *sb,\r\nenum als4k_gcr_t reg,\r\nu32 val)\r\n{\r\nsnd_als4k_gcr_write_addr(sb->alt_port, reg, val);\r\n}\r\nstatic inline u32 snd_als4k_gcr_read_addr(unsigned long iobase,\r\nenum als4k_gcr_t reg)\r\n{\r\nsnd_als4k_iobase_writeb(iobase, ALS4K_IOB_0C_GCR_INDEX, reg);\r\nreturn snd_als4k_iobase_readl(iobase, ALS4K_IOD_08_GCR_DATA);\r\n}\r\nstatic inline u32 snd_als4k_gcr_read(struct snd_sb *sb, enum als4k_gcr_t reg)\r\n{\r\nreturn snd_als4k_gcr_read_addr(sb->alt_port, reg);\r\n}\r\nstatic inline void snd_als4_cr_write(struct snd_sb *chip,\r\nenum als4k_cr_t reg,\r\nu8 data)\r\n{\r\nsnd_sbmixer_write(chip, reg | 0xc0, data);\r\n}\r\nstatic inline u8 snd_als4_cr_read(struct snd_sb *chip,\r\nenum als4k_cr_t reg)\r\n{\r\nreturn snd_sbmixer_read(chip, reg | 0xc0);\r\n}\r\nstatic void snd_als4000_set_rate(struct snd_sb *chip, unsigned int rate)\r\n{\r\nif (!(chip->mode & SB_RATE_LOCK)) {\r\nsnd_sbdsp_command(chip, SB_DSP_SAMPLE_RATE_OUT);\r\nsnd_sbdsp_command(chip, rate>>8);\r\nsnd_sbdsp_command(chip, rate);\r\n}\r\n}\r\nstatic inline void snd_als4000_set_capture_dma(struct snd_sb *chip,\r\ndma_addr_t addr, unsigned size)\r\n{\r\nsnd_als4k_gcr_write(chip, ALS4K_GCRA2_FIFO2_PCIADDR, addr);\r\nsnd_als4k_gcr_write(chip, ALS4K_GCRA3_FIFO2_COUNT, (size-1));\r\n}\r\nstatic inline void snd_als4000_set_playback_dma(struct snd_sb *chip,\r\ndma_addr_t addr,\r\nunsigned size)\r\n{\r\nsnd_als4k_gcr_write(chip, ALS4K_GCR91_DMA0_ADDR, addr);\r\nsnd_als4k_gcr_write(chip, ALS4K_GCR92_DMA0_MODE_COUNT,\r\n(size-1)|0x180000);\r\n}\r\nstatic int snd_als4000_get_format(struct snd_pcm_runtime *runtime)\r\n{\r\nint result;\r\nresult = 0;\r\nif (snd_pcm_format_signed(runtime->format))\r\nresult |= ALS4000_FORMAT_SIGNED;\r\nif (snd_pcm_format_physical_width(runtime->format) == 16)\r\nresult |= ALS4000_FORMAT_16BIT;\r\nif (runtime->channels > 1)\r\nresult |= ALS4000_FORMAT_STEREO;\r\nreturn result;\r\n}\r\nstatic int snd_als4000_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *hw_params)\r\n{\r\nreturn snd_pcm_lib_malloc_pages(substream, params_buffer_bytes(hw_params));\r\n}\r\nstatic int snd_als4000_hw_free(struct snd_pcm_substream *substream)\r\n{\r\nsnd_pcm_lib_free_pages(substream);\r\nreturn 0;\r\n}\r\nstatic int snd_als4000_capture_prepare(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_sb *chip = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nunsigned long size;\r\nunsigned count;\r\nchip->capture_format = snd_als4000_get_format(runtime);\r\nsize = snd_pcm_lib_buffer_bytes(substream);\r\ncount = snd_pcm_lib_period_bytes(substream);\r\nif (chip->capture_format & ALS4000_FORMAT_16BIT)\r\ncount >>= 1;\r\ncount--;\r\nspin_lock_irq(&chip->reg_lock);\r\nsnd_als4000_set_rate(chip, runtime->rate);\r\nsnd_als4000_set_capture_dma(chip, runtime->dma_addr, size);\r\nspin_unlock_irq(&chip->reg_lock);\r\nspin_lock_irq(&chip->mixer_lock);\r\nsnd_als4_cr_write(chip, ALS4K_CR1C_FIFO2_BLOCK_LENGTH_LO, count & 0xff);\r\nsnd_als4_cr_write(chip, ALS4K_CR1D_FIFO2_BLOCK_LENGTH_HI, count >> 8);\r\nspin_unlock_irq(&chip->mixer_lock);\r\nreturn 0;\r\n}\r\nstatic int snd_als4000_playback_prepare(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_sb *chip = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nunsigned long size;\r\nunsigned count;\r\nchip->playback_format = snd_als4000_get_format(runtime);\r\nsize = snd_pcm_lib_buffer_bytes(substream);\r\ncount = snd_pcm_lib_period_bytes(substream);\r\nif (chip->playback_format & ALS4000_FORMAT_16BIT)\r\ncount >>= 1;\r\ncount--;\r\nspin_lock_irq(&chip->reg_lock);\r\nsnd_als4000_set_rate(chip, runtime->rate);\r\nsnd_als4000_set_playback_dma(chip, runtime->dma_addr, size);\r\nsnd_sbdsp_command(chip, playback_cmd(chip).dsp_cmd);\r\nsnd_sbdsp_command(chip, playback_cmd(chip).format);\r\nsnd_sbdsp_command(chip, count & 0xff);\r\nsnd_sbdsp_command(chip, count >> 8);\r\nsnd_sbdsp_command(chip, playback_cmd(chip).dma_off);\r\nspin_unlock_irq(&chip->reg_lock);\r\nreturn 0;\r\n}\r\nstatic int snd_als4000_capture_trigger(struct snd_pcm_substream *substream, int cmd)\r\n{\r\nstruct snd_sb *chip = snd_pcm_substream_chip(substream);\r\nint result = 0;\r\nspin_lock(&chip->mixer_lock);\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\ncase SNDRV_PCM_TRIGGER_RESUME:\r\nchip->mode |= SB_RATE_LOCK_CAPTURE;\r\nsnd_als4_cr_write(chip, ALS4K_CR1E_FIFO2_CONTROL,\r\ncapture_cmd(chip));\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\ncase SNDRV_PCM_TRIGGER_SUSPEND:\r\nchip->mode &= ~SB_RATE_LOCK_CAPTURE;\r\nsnd_als4_cr_write(chip, ALS4K_CR1E_FIFO2_CONTROL,\r\ncapture_cmd(chip));\r\nbreak;\r\ndefault:\r\nresult = -EINVAL;\r\nbreak;\r\n}\r\nspin_unlock(&chip->mixer_lock);\r\nreturn result;\r\n}\r\nstatic int snd_als4000_playback_trigger(struct snd_pcm_substream *substream, int cmd)\r\n{\r\nstruct snd_sb *chip = snd_pcm_substream_chip(substream);\r\nint result = 0;\r\nspin_lock(&chip->reg_lock);\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\ncase SNDRV_PCM_TRIGGER_RESUME:\r\nchip->mode |= SB_RATE_LOCK_PLAYBACK;\r\nsnd_sbdsp_command(chip, playback_cmd(chip).dma_on);\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\ncase SNDRV_PCM_TRIGGER_SUSPEND:\r\nsnd_sbdsp_command(chip, playback_cmd(chip).dma_off);\r\nchip->mode &= ~SB_RATE_LOCK_PLAYBACK;\r\nbreak;\r\ndefault:\r\nresult = -EINVAL;\r\nbreak;\r\n}\r\nspin_unlock(&chip->reg_lock);\r\nreturn result;\r\n}\r\nstatic snd_pcm_uframes_t snd_als4000_capture_pointer(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_sb *chip = snd_pcm_substream_chip(substream);\r\nunsigned int result;\r\nspin_lock(&chip->reg_lock);\r\nresult = snd_als4k_gcr_read(chip, ALS4K_GCRA4_FIFO2_CURRENT_ADDR);\r\nspin_unlock(&chip->reg_lock);\r\nresult &= 0xffff;\r\nreturn bytes_to_frames( substream->runtime, result );\r\n}\r\nstatic snd_pcm_uframes_t snd_als4000_playback_pointer(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_sb *chip = snd_pcm_substream_chip(substream);\r\nunsigned result;\r\nspin_lock(&chip->reg_lock);\r\nresult = snd_als4k_gcr_read(chip, ALS4K_GCRA0_FIFO1_CURRENT_ADDR);\r\nspin_unlock(&chip->reg_lock);\r\nresult &= 0xffff;\r\nreturn bytes_to_frames( substream->runtime, result );\r\n}\r\nstatic irqreturn_t snd_als4000_interrupt(int irq, void *dev_id)\r\n{\r\nstruct snd_sb *chip = dev_id;\r\nunsigned pci_irqstatus;\r\nunsigned sb_irqstatus;\r\npci_irqstatus = snd_als4k_iobase_readb(chip->alt_port,\r\nALS4K_IOB_0E_IRQTYPE_SB_CR1E_MPU);\r\nif ((pci_irqstatus & ALS4K_IOB_0E_SB_DMA_IRQ)\r\n&& (chip->playback_substream))\r\nsnd_pcm_period_elapsed(chip->playback_substream);\r\nif ((pci_irqstatus & ALS4K_IOB_0E_CR1E_IRQ)\r\n&& (chip->capture_substream))\r\nsnd_pcm_period_elapsed(chip->capture_substream);\r\nif ((pci_irqstatus & ALS4K_IOB_0E_MPU_IRQ)\r\n&& (chip->rmidi))\r\nsnd_mpu401_uart_interrupt(irq, chip->rmidi->private_data);\r\nsnd_als4k_iobase_writeb(chip->alt_port,\r\nALS4K_IOB_0E_IRQTYPE_SB_CR1E_MPU, pci_irqstatus);\r\nspin_lock(&chip->mixer_lock);\r\nsb_irqstatus = snd_sbmixer_read(chip, SB_DSP4_IRQSTATUS);\r\nspin_unlock(&chip->mixer_lock);\r\nif (sb_irqstatus & SB_IRQTYPE_8BIT)\r\nsnd_sb_ack_8bit(chip);\r\nif (sb_irqstatus & SB_IRQTYPE_16BIT)\r\nsnd_sb_ack_16bit(chip);\r\nif (sb_irqstatus & SB_IRQTYPE_MPUIN)\r\ninb(chip->mpu_port);\r\nif (sb_irqstatus & ALS4K_IRQTYPE_CR1E_DMA)\r\nsnd_als4k_iobase_readb(chip->alt_port,\r\nALS4K_IOB_16_ACK_FOR_CR1E);\r\nreturn IRQ_RETVAL(\r\n(pci_irqstatus & (ALS4K_IOB_0E_SB_DMA_IRQ|ALS4K_IOB_0E_CR1E_IRQ|\r\nALS4K_IOB_0E_MPU_IRQ))\r\n|| (sb_irqstatus & (SB_IRQTYPE_8BIT|SB_IRQTYPE_16BIT|\r\nSB_IRQTYPE_MPUIN|ALS4K_IRQTYPE_CR1E_DMA))\r\n);\r\n}\r\nstatic int snd_als4000_playback_open(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_sb *chip = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nchip->playback_substream = substream;\r\nruntime->hw = snd_als4000_playback;\r\nreturn 0;\r\n}\r\nstatic int snd_als4000_playback_close(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_sb *chip = snd_pcm_substream_chip(substream);\r\nchip->playback_substream = NULL;\r\nsnd_pcm_lib_free_pages(substream);\r\nreturn 0;\r\n}\r\nstatic int snd_als4000_capture_open(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_sb *chip = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nchip->capture_substream = substream;\r\nruntime->hw = snd_als4000_capture;\r\nreturn 0;\r\n}\r\nstatic int snd_als4000_capture_close(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_sb *chip = snd_pcm_substream_chip(substream);\r\nchip->capture_substream = NULL;\r\nsnd_pcm_lib_free_pages(substream);\r\nreturn 0;\r\n}\r\nstatic int snd_als4000_pcm(struct snd_sb *chip, int device)\r\n{\r\nstruct snd_pcm *pcm;\r\nint err;\r\nerr = snd_pcm_new(chip->card, "ALS4000 DSP", device, 1, 1, &pcm);\r\nif (err < 0)\r\nreturn err;\r\npcm->private_data = chip;\r\npcm->info_flags = SNDRV_PCM_INFO_JOINT_DUPLEX;\r\nsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &snd_als4000_playback_ops);\r\nsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &snd_als4000_capture_ops);\r\nsnd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_DEV, snd_dma_pci_data(chip->pci),\r\n64*1024, 64*1024);\r\nchip->pcm = pcm;\r\nreturn 0;\r\n}\r\nstatic void snd_als4000_set_addr(unsigned long iobase,\r\nunsigned int sb_io,\r\nunsigned int mpu_io,\r\nunsigned int opl_io,\r\nunsigned int game_io)\r\n{\r\nu32 cfg1 = 0;\r\nu32 cfg2 = 0;\r\nif (mpu_io > 0)\r\ncfg2 |= (mpu_io | 1) << 16;\r\nif (sb_io > 0)\r\ncfg2 |= (sb_io | 1);\r\nif (game_io > 0)\r\ncfg1 |= (game_io | 1) << 16;\r\nif (opl_io > 0)\r\ncfg1 |= (opl_io | 1);\r\nsnd_als4k_gcr_write_addr(iobase, ALS4K_GCRA8_LEGACY_CFG1, cfg1);\r\nsnd_als4k_gcr_write_addr(iobase, ALS4K_GCRA9_LEGACY_CFG2, cfg2);\r\n}\r\nstatic void snd_als4000_configure(struct snd_sb *chip)\r\n{\r\nu8 tmp;\r\nint i;\r\nspin_lock_irq(&chip->mixer_lock);\r\ntmp = snd_als4_cr_read(chip, ALS4K_CR0_SB_CONFIG);\r\nsnd_als4_cr_write(chip, ALS4K_CR0_SB_CONFIG,\r\ntmp|ALS4K_CR0_MX80_81_REG_WRITE_ENABLE);\r\nsnd_sbmixer_write(chip, SB_DSP4_DMASETUP, SB_DMASETUP_DMA0);\r\nsnd_als4_cr_write(chip, ALS4K_CR0_SB_CONFIG,\r\ntmp & ~ALS4K_CR0_MX80_81_REG_WRITE_ENABLE);\r\nspin_unlock_irq(&chip->mixer_lock);\r\nspin_lock_irq(&chip->reg_lock);\r\nsnd_als4k_gcr_write(chip, ALS4K_GCR8C_MISC_CTRL,\r\nALS4K_GCR8C_IRQ_MASK_CTRL_ENABLE);\r\nfor (i = ALS4K_GCR91_DMA0_ADDR; i <= ALS4K_GCR96_DMA3_MODE_COUNT; ++i)\r\nsnd_als4k_gcr_write(chip, i, 0);\r\nsnd_als4k_gcr_write(chip, ALS4K_GCR99_DMA_EMULATION_CTRL,\r\n(snd_als4k_gcr_read(chip, ALS4K_GCR99_DMA_EMULATION_CTRL) & ~0x07) | 0x04);\r\nspin_unlock_irq(&chip->reg_lock);\r\n}\r\nstatic int snd_als4000_create_gameport(struct snd_card_als4000 *acard, int dev)\r\n{\r\nstruct gameport *gp;\r\nstruct resource *r;\r\nint io_port;\r\nif (joystick_port[dev] == 0)\r\nreturn -ENODEV;\r\nif (joystick_port[dev] == 1) {\r\nfor (io_port = 0x200; io_port <= 0x218; io_port += 8) {\r\nr = request_region(io_port, 8, "ALS4000 gameport");\r\nif (r)\r\nbreak;\r\n}\r\n} else {\r\nio_port = joystick_port[dev];\r\nr = request_region(io_port, 8, "ALS4000 gameport");\r\n}\r\nif (!r) {\r\nprintk(KERN_WARNING "als4000: cannot reserve joystick ports\n");\r\nreturn -EBUSY;\r\n}\r\nacard->gameport = gp = gameport_allocate_port();\r\nif (!gp) {\r\nprintk(KERN_ERR "als4000: cannot allocate memory for gameport\n");\r\nrelease_and_free_resource(r);\r\nreturn -ENOMEM;\r\n}\r\ngameport_set_name(gp, "ALS4000 Gameport");\r\ngameport_set_phys(gp, "pci%s/gameport0", pci_name(acard->pci));\r\ngameport_set_dev_parent(gp, &acard->pci->dev);\r\ngp->io = io_port;\r\ngameport_set_port_data(gp, r);\r\nsnd_als4000_set_addr(acard->iobase, 0, 0, 0, 1);\r\ngameport_register_port(acard->gameport);\r\nreturn 0;\r\n}\r\nstatic void snd_als4000_free_gameport(struct snd_card_als4000 *acard)\r\n{\r\nif (acard->gameport) {\r\nstruct resource *r = gameport_get_port_data(acard->gameport);\r\ngameport_unregister_port(acard->gameport);\r\nacard->gameport = NULL;\r\nsnd_als4000_set_addr(acard->iobase, 0, 0, 0, 0);\r\nrelease_and_free_resource(r);\r\n}\r\n}\r\nstatic inline int snd_als4000_create_gameport(struct snd_card_als4000 *acard, int dev) { return -ENOSYS; }\r\nstatic inline void snd_als4000_free_gameport(struct snd_card_als4000 *acard) { }\r\nstatic void snd_card_als4000_free( struct snd_card *card )\r\n{\r\nstruct snd_card_als4000 *acard = card->private_data;\r\nsnd_als4k_gcr_write_addr(acard->iobase, ALS4K_GCR8C_MISC_CTRL, 0);\r\nsnd_als4000_free_gameport(acard);\r\npci_release_regions(acard->pci);\r\npci_disable_device(acard->pci);\r\n}\r\nstatic int snd_card_als4000_probe(struct pci_dev *pci,\r\nconst struct pci_device_id *pci_id)\r\n{\r\nstatic int dev;\r\nstruct snd_card *card;\r\nstruct snd_card_als4000 *acard;\r\nunsigned long iobase;\r\nstruct snd_sb *chip;\r\nstruct snd_opl3 *opl3;\r\nunsigned short word;\r\nint err;\r\nif (dev >= SNDRV_CARDS)\r\nreturn -ENODEV;\r\nif (!enable[dev]) {\r\ndev++;\r\nreturn -ENOENT;\r\n}\r\nif ((err = pci_enable_device(pci)) < 0) {\r\nreturn err;\r\n}\r\nif (pci_set_dma_mask(pci, DMA_BIT_MASK(24)) < 0 ||\r\npci_set_consistent_dma_mask(pci, DMA_BIT_MASK(24)) < 0) {\r\nsnd_printk(KERN_ERR "architecture does not support 24bit PCI busmaster DMA\n");\r\npci_disable_device(pci);\r\nreturn -ENXIO;\r\n}\r\nif ((err = pci_request_regions(pci, "ALS4000")) < 0) {\r\npci_disable_device(pci);\r\nreturn err;\r\n}\r\niobase = pci_resource_start(pci, 0);\r\npci_read_config_word(pci, PCI_COMMAND, &word);\r\npci_write_config_word(pci, PCI_COMMAND, word | PCI_COMMAND_IO);\r\npci_set_master(pci);\r\nerr = snd_card_create(index[dev], id[dev], THIS_MODULE,\r\nsizeof(*acard) ,\r\n&card);\r\nif (err < 0) {\r\npci_release_regions(pci);\r\npci_disable_device(pci);\r\nreturn err;\r\n}\r\nacard = card->private_data;\r\nacard->pci = pci;\r\nacard->iobase = iobase;\r\ncard->private_free = snd_card_als4000_free;\r\nsnd_als4000_set_addr(acard->iobase, 0, 0, 0, 0);\r\nif ((err = snd_sbdsp_create(card,\r\niobase + ALS4K_IOB_10_ADLIB_ADDR0,\r\npci->irq,\r\nsnd_als4000_interrupt,\r\n-1,\r\n-1,\r\nSB_HW_ALS4000,\r\n&chip)) < 0) {\r\ngoto out_err;\r\n}\r\nacard->chip = chip;\r\nchip->pci = pci;\r\nchip->alt_port = iobase;\r\nsnd_card_set_dev(card, &pci->dev);\r\nsnd_als4000_configure(chip);\r\nstrcpy(card->driver, "ALS4000");\r\nstrcpy(card->shortname, "Avance Logic ALS4000");\r\nsprintf(card->longname, "%s at 0x%lx, irq %i",\r\ncard->shortname, chip->alt_port, chip->irq);\r\nif ((err = snd_mpu401_uart_new( card, 0, MPU401_HW_ALS4000,\r\niobase + ALS4K_IOB_30_MIDI_DATA,\r\nMPU401_INFO_INTEGRATED |\r\nMPU401_INFO_IRQ_HOOK,\r\n-1, &chip->rmidi)) < 0) {\r\nprintk(KERN_ERR "als4000: no MPU-401 device at 0x%lx?\n",\r\niobase + ALS4K_IOB_30_MIDI_DATA);\r\ngoto out_err;\r\n}\r\nif ((err = snd_als4000_pcm(chip, 0)) < 0) {\r\ngoto out_err;\r\n}\r\nif ((err = snd_sbmixer_new(chip)) < 0) {\r\ngoto out_err;\r\n}\r\nif (snd_opl3_create(card,\r\niobase + ALS4K_IOB_10_ADLIB_ADDR0,\r\niobase + ALS4K_IOB_12_ADLIB_ADDR2,\r\nOPL3_HW_AUTO, 1, &opl3) < 0) {\r\nprintk(KERN_ERR "als4000: no OPL device at 0x%lx-0x%lx?\n",\r\niobase + ALS4K_IOB_10_ADLIB_ADDR0,\r\niobase + ALS4K_IOB_12_ADLIB_ADDR2);\r\n} else {\r\nif ((err = snd_opl3_hwdep_new(opl3, 0, 1, NULL)) < 0) {\r\ngoto out_err;\r\n}\r\n}\r\nsnd_als4000_create_gameport(acard, dev);\r\nif ((err = snd_card_register(card)) < 0) {\r\ngoto out_err;\r\n}\r\npci_set_drvdata(pci, card);\r\ndev++;\r\nerr = 0;\r\ngoto out;\r\nout_err:\r\nsnd_card_free(card);\r\nout:\r\nreturn err;\r\n}\r\nstatic void snd_card_als4000_remove(struct pci_dev *pci)\r\n{\r\nsnd_card_free(pci_get_drvdata(pci));\r\npci_set_drvdata(pci, NULL);\r\n}\r\nstatic int snd_als4000_suspend(struct device *dev)\r\n{\r\nstruct pci_dev *pci = to_pci_dev(dev);\r\nstruct snd_card *card = dev_get_drvdata(dev);\r\nstruct snd_card_als4000 *acard = card->private_data;\r\nstruct snd_sb *chip = acard->chip;\r\nsnd_power_change_state(card, SNDRV_CTL_POWER_D3hot);\r\nsnd_pcm_suspend_all(chip->pcm);\r\nsnd_sbmixer_suspend(chip);\r\npci_disable_device(pci);\r\npci_save_state(pci);\r\npci_set_power_state(pci, PCI_D3hot);\r\nreturn 0;\r\n}\r\nstatic int snd_als4000_resume(struct device *dev)\r\n{\r\nstruct pci_dev *pci = to_pci_dev(dev);\r\nstruct snd_card *card = dev_get_drvdata(dev);\r\nstruct snd_card_als4000 *acard = card->private_data;\r\nstruct snd_sb *chip = acard->chip;\r\npci_set_power_state(pci, PCI_D0);\r\npci_restore_state(pci);\r\nif (pci_enable_device(pci) < 0) {\r\nprintk(KERN_ERR "als4000: pci_enable_device failed, "\r\n"disabling device\n");\r\nsnd_card_disconnect(card);\r\nreturn -EIO;\r\n}\r\npci_set_master(pci);\r\nsnd_als4000_configure(chip);\r\nsnd_sbdsp_reset(chip);\r\nsnd_sbmixer_resume(chip);\r\n#ifdef SUPPORT_JOYSTICK\r\nif (acard->gameport)\r\nsnd_als4000_set_addr(acard->iobase, 0, 0, 0, 1);\r\n#endif\r\nsnd_power_change_state(card, SNDRV_CTL_POWER_D0);\r\nreturn 0;\r\n}
