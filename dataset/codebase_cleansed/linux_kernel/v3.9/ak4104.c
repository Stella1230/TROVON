static int ak4104_set_dai_fmt(struct snd_soc_dai *codec_dai,\r\nunsigned int format)\r\n{\r\nstruct snd_soc_codec *codec = codec_dai->codec;\r\nint val = 0;\r\nint ret;\r\nswitch (format & SND_SOC_DAIFMT_FORMAT_MASK) {\r\ncase SND_SOC_DAIFMT_RIGHT_J:\r\nbreak;\r\ncase SND_SOC_DAIFMT_LEFT_J:\r\nval |= AK4104_CONTROL1_DIF0;\r\nbreak;\r\ncase SND_SOC_DAIFMT_I2S:\r\nval |= AK4104_CONTROL1_DIF0 | AK4104_CONTROL1_DIF1;\r\nbreak;\r\ndefault:\r\ndev_err(codec->dev, "invalid dai format\n");\r\nreturn -EINVAL;\r\n}\r\nif ((format & SND_SOC_DAIFMT_MASTER_MASK) != SND_SOC_DAIFMT_CBS_CFS)\r\nreturn -EINVAL;\r\nret = snd_soc_update_bits(codec, AK4104_REG_CONTROL1,\r\nAK4104_CONTROL1_DIF0 | AK4104_CONTROL1_DIF1,\r\nval);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nstatic int ak4104_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nint val = 0;\r\nval |= IEC958_AES0_CON_NOT_COPYRIGHT;\r\nsnd_soc_write(codec, AK4104_REG_CHN_STATUS(0), val);\r\nval = 0;\r\nswitch (params_rate(params)) {\r\ncase 22050:\r\nval |= IEC958_AES3_CON_FS_22050;\r\nbreak;\r\ncase 24000:\r\nval |= IEC958_AES3_CON_FS_24000;\r\nbreak;\r\ncase 32000:\r\nval |= IEC958_AES3_CON_FS_32000;\r\nbreak;\r\ncase 44100:\r\nval |= IEC958_AES3_CON_FS_44100;\r\nbreak;\r\ncase 48000:\r\nval |= IEC958_AES3_CON_FS_48000;\r\nbreak;\r\ncase 88200:\r\nval |= IEC958_AES3_CON_FS_88200;\r\nbreak;\r\ncase 96000:\r\nval |= IEC958_AES3_CON_FS_96000;\r\nbreak;\r\ncase 176400:\r\nval |= IEC958_AES3_CON_FS_176400;\r\nbreak;\r\ncase 192000:\r\nval |= IEC958_AES3_CON_FS_192000;\r\nbreak;\r\ndefault:\r\ndev_err(codec->dev, "unsupported sampling rate\n");\r\nreturn -EINVAL;\r\n}\r\nreturn snd_soc_write(codec, AK4104_REG_CHN_STATUS(3), val);\r\n}\r\nstatic int ak4104_probe(struct snd_soc_codec *codec)\r\n{\r\nstruct ak4104_private *ak4104 = snd_soc_codec_get_drvdata(codec);\r\nint ret;\r\ncodec->control_data = ak4104->regmap;\r\nret = snd_soc_codec_set_cache_io(codec, 8, 8, SND_SOC_REGMAP);\r\nif (ret != 0)\r\nreturn ret;\r\nret = snd_soc_update_bits(codec, AK4104_REG_CONTROL1,\r\nAK4104_CONTROL1_PW | AK4104_CONTROL1_RSTN,\r\nAK4104_CONTROL1_PW | AK4104_CONTROL1_RSTN);\r\nif (ret < 0)\r\nreturn ret;\r\nret = snd_soc_update_bits(codec, AK4104_REG_TX,\r\nAK4104_TX_TXE, AK4104_TX_TXE);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nstatic int ak4104_remove(struct snd_soc_codec *codec)\r\n{\r\nsnd_soc_update_bits(codec, AK4104_REG_CONTROL1,\r\nAK4104_CONTROL1_PW | AK4104_CONTROL1_RSTN, 0);\r\nreturn 0;\r\n}\r\nstatic int ak4104_spi_probe(struct spi_device *spi)\r\n{\r\nstruct device_node *np = spi->dev.of_node;\r\nstruct ak4104_private *ak4104;\r\nunsigned int val;\r\nint ret;\r\nspi->bits_per_word = 8;\r\nspi->mode = SPI_MODE_0;\r\nret = spi_setup(spi);\r\nif (ret < 0)\r\nreturn ret;\r\nak4104 = devm_kzalloc(&spi->dev, sizeof(struct ak4104_private),\r\nGFP_KERNEL);\r\nif (ak4104 == NULL)\r\nreturn -ENOMEM;\r\nak4104->regmap = devm_regmap_init_spi(spi, &ak4104_regmap);\r\nif (IS_ERR(ak4104->regmap)) {\r\nret = PTR_ERR(ak4104->regmap);\r\nreturn ret;\r\n}\r\nif (np) {\r\nenum of_gpio_flags flags;\r\nint gpio = of_get_named_gpio_flags(np, "reset-gpio", 0, &flags);\r\nif (gpio_is_valid(gpio)) {\r\nret = devm_gpio_request_one(&spi->dev, gpio,\r\nflags & OF_GPIO_ACTIVE_LOW ?\r\nGPIOF_OUT_INIT_LOW : GPIOF_OUT_INIT_HIGH,\r\n"ak4104 reset");\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\n}\r\nret = regmap_read(ak4104->regmap, AK4104_REG_RESERVED, &val);\r\nif (ret != 0)\r\nreturn ret;\r\nif (val != AK4104_RESERVED_VAL)\r\nreturn -ENODEV;\r\nspi_set_drvdata(spi, ak4104);\r\nret = snd_soc_register_codec(&spi->dev,\r\n&soc_codec_device_ak4104, &ak4104_dai, 1);\r\nreturn ret;\r\n}\r\nstatic int ak4104_spi_remove(struct spi_device *spi)\r\n{\r\nsnd_soc_unregister_codec(&spi->dev);\r\nreturn 0;\r\n}
