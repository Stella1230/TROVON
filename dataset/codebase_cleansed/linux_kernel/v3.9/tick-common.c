struct tick_device *tick_get_device(int cpu)\r\n{\r\nreturn &per_cpu(tick_cpu_device, cpu);\r\n}\r\nint tick_is_oneshot_available(void)\r\n{\r\nstruct clock_event_device *dev = __this_cpu_read(tick_cpu_device.evtdev);\r\nif (!dev || !(dev->features & CLOCK_EVT_FEAT_ONESHOT))\r\nreturn 0;\r\nif (!(dev->features & CLOCK_EVT_FEAT_C3STOP))\r\nreturn 1;\r\nreturn tick_broadcast_oneshot_available();\r\n}\r\nstatic void tick_periodic(int cpu)\r\n{\r\nif (tick_do_timer_cpu == cpu) {\r\nwrite_seqlock(&jiffies_lock);\r\ntick_next_period = ktime_add(tick_next_period, tick_period);\r\ndo_timer(1);\r\nwrite_sequnlock(&jiffies_lock);\r\n}\r\nupdate_process_times(user_mode(get_irq_regs()));\r\nprofile_tick(CPU_PROFILING);\r\n}\r\nvoid tick_handle_periodic(struct clock_event_device *dev)\r\n{\r\nint cpu = smp_processor_id();\r\nktime_t next;\r\ntick_periodic(cpu);\r\nif (dev->mode != CLOCK_EVT_MODE_ONESHOT)\r\nreturn;\r\nnext = ktime_add(dev->next_event, tick_period);\r\nfor (;;) {\r\nif (!clockevents_program_event(dev, next, false))\r\nreturn;\r\nif (timekeeping_valid_for_hres())\r\ntick_periodic(cpu);\r\nnext = ktime_add(next, tick_period);\r\n}\r\n}\r\nvoid tick_setup_periodic(struct clock_event_device *dev, int broadcast)\r\n{\r\ntick_set_periodic_handler(dev, broadcast);\r\nif (!tick_device_is_functional(dev))\r\nreturn;\r\nif ((dev->features & CLOCK_EVT_FEAT_PERIODIC) &&\r\n!tick_broadcast_oneshot_active()) {\r\nclockevents_set_mode(dev, CLOCK_EVT_MODE_PERIODIC);\r\n} else {\r\nunsigned long seq;\r\nktime_t next;\r\ndo {\r\nseq = read_seqbegin(&jiffies_lock);\r\nnext = tick_next_period;\r\n} while (read_seqretry(&jiffies_lock, seq));\r\nclockevents_set_mode(dev, CLOCK_EVT_MODE_ONESHOT);\r\nfor (;;) {\r\nif (!clockevents_program_event(dev, next, false))\r\nreturn;\r\nnext = ktime_add(next, tick_period);\r\n}\r\n}\r\n}\r\nstatic void tick_setup_device(struct tick_device *td,\r\nstruct clock_event_device *newdev, int cpu,\r\nconst struct cpumask *cpumask)\r\n{\r\nktime_t next_event;\r\nvoid (*handler)(struct clock_event_device *) = NULL;\r\nif (!td->evtdev) {\r\nif (tick_do_timer_cpu == TICK_DO_TIMER_BOOT) {\r\ntick_do_timer_cpu = cpu;\r\ntick_next_period = ktime_get();\r\ntick_period = ktime_set(0, NSEC_PER_SEC / HZ);\r\n}\r\ntd->mode = TICKDEV_MODE_PERIODIC;\r\n} else {\r\nhandler = td->evtdev->event_handler;\r\nnext_event = td->evtdev->next_event;\r\ntd->evtdev->event_handler = clockevents_handle_noop;\r\n}\r\ntd->evtdev = newdev;\r\nif (!cpumask_equal(newdev->cpumask, cpumask))\r\nirq_set_affinity(newdev->irq, cpumask);\r\nif (tick_device_uses_broadcast(newdev, cpu))\r\nreturn;\r\nif (td->mode == TICKDEV_MODE_PERIODIC)\r\ntick_setup_periodic(newdev, 0);\r\nelse\r\ntick_setup_oneshot(newdev, handler, next_event);\r\n}\r\nstatic int tick_check_new_device(struct clock_event_device *newdev)\r\n{\r\nstruct clock_event_device *curdev;\r\nstruct tick_device *td;\r\nint cpu, ret = NOTIFY_OK;\r\nunsigned long flags;\r\nraw_spin_lock_irqsave(&tick_device_lock, flags);\r\ncpu = smp_processor_id();\r\nif (!cpumask_test_cpu(cpu, newdev->cpumask))\r\ngoto out_bc;\r\ntd = &per_cpu(tick_cpu_device, cpu);\r\ncurdev = td->evtdev;\r\nif (!cpumask_equal(newdev->cpumask, cpumask_of(cpu))) {\r\nif (!irq_can_set_affinity(newdev->irq))\r\ngoto out_bc;\r\nif (curdev && cpumask_equal(curdev->cpumask, cpumask_of(cpu)))\r\ngoto out_bc;\r\n}\r\nif (curdev) {\r\nif ((curdev->features & CLOCK_EVT_FEAT_ONESHOT) &&\r\n!(newdev->features & CLOCK_EVT_FEAT_ONESHOT))\r\ngoto out_bc;\r\nif (curdev->rating >= newdev->rating)\r\ngoto out_bc;\r\n}\r\nif (tick_is_broadcast_device(curdev)) {\r\nclockevents_shutdown(curdev);\r\ncurdev = NULL;\r\n}\r\nclockevents_exchange_device(curdev, newdev);\r\ntick_setup_device(td, newdev, cpu, cpumask_of(cpu));\r\nif (newdev->features & CLOCK_EVT_FEAT_ONESHOT)\r\ntick_oneshot_notify();\r\nraw_spin_unlock_irqrestore(&tick_device_lock, flags);\r\nreturn NOTIFY_STOP;\r\nout_bc:\r\nif (tick_check_broadcast_device(newdev))\r\nret = NOTIFY_STOP;\r\nraw_spin_unlock_irqrestore(&tick_device_lock, flags);\r\nreturn ret;\r\n}\r\nstatic void tick_handover_do_timer(int *cpup)\r\n{\r\nif (*cpup == tick_do_timer_cpu) {\r\nint cpu = cpumask_first(cpu_online_mask);\r\ntick_do_timer_cpu = (cpu < nr_cpu_ids) ? cpu :\r\nTICK_DO_TIMER_NONE;\r\n}\r\n}\r\nstatic void tick_shutdown(unsigned int *cpup)\r\n{\r\nstruct tick_device *td = &per_cpu(tick_cpu_device, *cpup);\r\nstruct clock_event_device *dev = td->evtdev;\r\nunsigned long flags;\r\nraw_spin_lock_irqsave(&tick_device_lock, flags);\r\ntd->mode = TICKDEV_MODE_PERIODIC;\r\nif (dev) {\r\ndev->mode = CLOCK_EVT_MODE_UNUSED;\r\nclockevents_exchange_device(dev, NULL);\r\ntd->evtdev = NULL;\r\n}\r\nraw_spin_unlock_irqrestore(&tick_device_lock, flags);\r\n}\r\nstatic void tick_suspend(void)\r\n{\r\nstruct tick_device *td = &__get_cpu_var(tick_cpu_device);\r\nunsigned long flags;\r\nraw_spin_lock_irqsave(&tick_device_lock, flags);\r\nclockevents_shutdown(td->evtdev);\r\nraw_spin_unlock_irqrestore(&tick_device_lock, flags);\r\n}\r\nstatic void tick_resume(void)\r\n{\r\nstruct tick_device *td = &__get_cpu_var(tick_cpu_device);\r\nunsigned long flags;\r\nint broadcast = tick_resume_broadcast();\r\nraw_spin_lock_irqsave(&tick_device_lock, flags);\r\nclockevents_set_mode(td->evtdev, CLOCK_EVT_MODE_RESUME);\r\nif (!broadcast) {\r\nif (td->mode == TICKDEV_MODE_PERIODIC)\r\ntick_setup_periodic(td->evtdev, 0);\r\nelse\r\ntick_resume_oneshot();\r\n}\r\nraw_spin_unlock_irqrestore(&tick_device_lock, flags);\r\n}\r\nstatic int tick_notify(struct notifier_block *nb, unsigned long reason,\r\nvoid *dev)\r\n{\r\nswitch (reason) {\r\ncase CLOCK_EVT_NOTIFY_ADD:\r\nreturn tick_check_new_device(dev);\r\ncase CLOCK_EVT_NOTIFY_BROADCAST_ON:\r\ncase CLOCK_EVT_NOTIFY_BROADCAST_OFF:\r\ncase CLOCK_EVT_NOTIFY_BROADCAST_FORCE:\r\ntick_broadcast_on_off(reason, dev);\r\nbreak;\r\ncase CLOCK_EVT_NOTIFY_BROADCAST_ENTER:\r\ncase CLOCK_EVT_NOTIFY_BROADCAST_EXIT:\r\ntick_broadcast_oneshot_control(reason);\r\nbreak;\r\ncase CLOCK_EVT_NOTIFY_CPU_DYING:\r\ntick_handover_do_timer(dev);\r\nbreak;\r\ncase CLOCK_EVT_NOTIFY_CPU_DEAD:\r\ntick_shutdown_broadcast_oneshot(dev);\r\ntick_shutdown_broadcast(dev);\r\ntick_shutdown(dev);\r\nbreak;\r\ncase CLOCK_EVT_NOTIFY_SUSPEND:\r\ntick_suspend();\r\ntick_suspend_broadcast();\r\nbreak;\r\ncase CLOCK_EVT_NOTIFY_RESUME:\r\ntick_resume();\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn NOTIFY_OK;\r\n}\r\nvoid __init tick_init(void)\r\n{\r\nclockevents_register_notifier(&tick_notifier);\r\n}
