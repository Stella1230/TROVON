static inline int bd2802_is_rgb_off(struct bd2802_led *led, enum led_ids id,\r\nenum led_colors color)\r\n{\r\nswitch (color) {\r\ncase RED:\r\nreturn !led->led[id].r;\r\ncase GREEN:\r\nreturn !led->led[id].g;\r\ncase BLUE:\r\nreturn !led->led[id].b;\r\ndefault:\r\ndev_err(&led->client->dev, "%s: Invalid color\n", __func__);\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic inline int bd2802_is_led_off(struct bd2802_led *led, enum led_ids id)\r\n{\r\nif (led->led[id].r || led->led[id].g || led->led[id].b)\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic inline int bd2802_is_all_off(struct bd2802_led *led)\r\n{\r\nint i;\r\nfor (i = 0; i < LED_NUM; i++)\r\nif (!bd2802_is_led_off(led, i))\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic inline u8 bd2802_get_base_offset(enum led_ids id, enum led_colors color)\r\n{\r\nreturn id * BD2802_LED_OFFSET + color * BD2802_COLOR_OFFSET;\r\n}\r\nstatic inline u8 bd2802_get_reg_addr(enum led_ids id, enum led_colors color,\r\nu8 reg_offset)\r\n{\r\nreturn reg_offset + bd2802_get_base_offset(id, color);\r\n}\r\nstatic int bd2802_write_byte(struct i2c_client *client, u8 reg, u8 val)\r\n{\r\nint ret = i2c_smbus_write_byte_data(client, reg, val);\r\nif (ret >= 0)\r\nreturn 0;\r\ndev_err(&client->dev, "%s: reg 0x%x, val 0x%x, err %d\n",\r\n__func__, reg, val, ret);\r\nreturn ret;\r\n}\r\nstatic void bd2802_update_state(struct bd2802_led *led, enum led_ids id,\r\nenum led_colors color, enum led_bits led_bit)\r\n{\r\nint i;\r\nu8 value;\r\nfor (i = 0; i < LED_NUM; i++) {\r\nif (i == id) {\r\nswitch (color) {\r\ncase RED:\r\nled->led[i].r = led_bit;\r\nbreak;\r\ncase GREEN:\r\nled->led[i].g = led_bit;\r\nbreak;\r\ncase BLUE:\r\nled->led[i].b = led_bit;\r\nbreak;\r\ndefault:\r\ndev_err(&led->client->dev,\r\n"%s: Invalid color\n", __func__);\r\nreturn;\r\n}\r\n}\r\n}\r\nif (led_bit == BD2802_BLINK || led_bit == BD2802_ON)\r\nreturn;\r\nif (!bd2802_is_led_off(led, id))\r\nreturn;\r\nif (bd2802_is_all_off(led) && !led->adf_on) {\r\ngpio_set_value(led->pdata->reset_gpio, 0);\r\nreturn;\r\n}\r\nvalue = (id == LED1) ? LED_CTL(1, 0) : LED_CTL(0, 1);\r\nbd2802_write_byte(led->client, BD2802_REG_CONTROL, value);\r\n}\r\nstatic void bd2802_configure(struct bd2802_led *led)\r\n{\r\nstruct bd2802_led_platform_data *pdata = led->pdata;\r\nu8 reg;\r\nreg = bd2802_get_reg_addr(LED1, RED, BD2802_REG_HOURSETUP);\r\nbd2802_write_byte(led->client, reg, pdata->rgb_time);\r\nreg = bd2802_get_reg_addr(LED2, RED, BD2802_REG_HOURSETUP);\r\nbd2802_write_byte(led->client, reg, pdata->rgb_time);\r\n}\r\nstatic void bd2802_reset_cancel(struct bd2802_led *led)\r\n{\r\ngpio_set_value(led->pdata->reset_gpio, 1);\r\nudelay(100);\r\nbd2802_configure(led);\r\n}\r\nstatic void bd2802_enable(struct bd2802_led *led, enum led_ids id)\r\n{\r\nenum led_ids other_led = (id == LED1) ? LED2 : LED1;\r\nu8 value, other_led_on;\r\nother_led_on = !bd2802_is_led_off(led, other_led);\r\nif (id == LED1)\r\nvalue = LED_CTL(other_led_on, 1);\r\nelse\r\nvalue = LED_CTL(1 , other_led_on);\r\nbd2802_write_byte(led->client, BD2802_REG_CONTROL, value);\r\n}\r\nstatic void bd2802_set_on(struct bd2802_led *led, enum led_ids id,\r\nenum led_colors color)\r\n{\r\nu8 reg;\r\nif (bd2802_is_all_off(led) && !led->adf_on)\r\nbd2802_reset_cancel(led);\r\nreg = bd2802_get_reg_addr(id, color, BD2802_REG_CURRENT1SETUP);\r\nbd2802_write_byte(led->client, reg, led->rgb_current);\r\nreg = bd2802_get_reg_addr(id, color, BD2802_REG_CURRENT2SETUP);\r\nbd2802_write_byte(led->client, reg, BD2802_CURRENT_000);\r\nreg = bd2802_get_reg_addr(id, color, BD2802_REG_WAVEPATTERN);\r\nbd2802_write_byte(led->client, reg, BD2802_PATTERN_FULL);\r\nbd2802_enable(led, id);\r\nbd2802_update_state(led, id, color, BD2802_ON);\r\n}\r\nstatic void bd2802_set_blink(struct bd2802_led *led, enum led_ids id,\r\nenum led_colors color)\r\n{\r\nu8 reg;\r\nif (bd2802_is_all_off(led) && !led->adf_on)\r\nbd2802_reset_cancel(led);\r\nreg = bd2802_get_reg_addr(id, color, BD2802_REG_CURRENT1SETUP);\r\nbd2802_write_byte(led->client, reg, BD2802_CURRENT_000);\r\nreg = bd2802_get_reg_addr(id, color, BD2802_REG_CURRENT2SETUP);\r\nbd2802_write_byte(led->client, reg, led->rgb_current);\r\nreg = bd2802_get_reg_addr(id, color, BD2802_REG_WAVEPATTERN);\r\nbd2802_write_byte(led->client, reg, led->wave_pattern);\r\nbd2802_enable(led, id);\r\nbd2802_update_state(led, id, color, BD2802_BLINK);\r\n}\r\nstatic void bd2802_turn_on(struct bd2802_led *led, enum led_ids id,\r\nenum led_colors color, enum led_bits led_bit)\r\n{\r\nif (led_bit == BD2802_OFF) {\r\ndev_err(&led->client->dev,\r\n"Only 'blink' and 'on' are allowed\n");\r\nreturn;\r\n}\r\nif (led_bit == BD2802_BLINK)\r\nbd2802_set_blink(led, id, color);\r\nelse\r\nbd2802_set_on(led, id, color);\r\n}\r\nstatic void bd2802_turn_off(struct bd2802_led *led, enum led_ids id,\r\nenum led_colors color)\r\n{\r\nu8 reg;\r\nif (bd2802_is_rgb_off(led, id, color))\r\nreturn;\r\nreg = bd2802_get_reg_addr(id, color, BD2802_REG_CURRENT1SETUP);\r\nbd2802_write_byte(led->client, reg, BD2802_CURRENT_000);\r\nreg = bd2802_get_reg_addr(id, color, BD2802_REG_CURRENT2SETUP);\r\nbd2802_write_byte(led->client, reg, BD2802_CURRENT_000);\r\nbd2802_update_state(led, id, color, BD2802_OFF);\r\n}\r\nstatic void bd2802_enable_adv_conf(struct bd2802_led *led)\r\n{\r\nint i, ret;\r\nfor (i = 0; i < ARRAY_SIZE(bd2802_addr_attributes); i++) {\r\nret = device_create_file(&led->client->dev,\r\nbd2802_addr_attributes[i]);\r\nif (ret) {\r\ndev_err(&led->client->dev, "failed: sysfs file %s\n",\r\nbd2802_addr_attributes[i]->attr.name);\r\ngoto failed_remove_files;\r\n}\r\n}\r\nif (bd2802_is_all_off(led))\r\nbd2802_reset_cancel(led);\r\nled->adf_on = 1;\r\nreturn;\r\nfailed_remove_files:\r\nfor (i--; i >= 0; i--)\r\ndevice_remove_file(&led->client->dev,\r\nbd2802_addr_attributes[i]);\r\n}\r\nstatic void bd2802_disable_adv_conf(struct bd2802_led *led)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(bd2802_addr_attributes); i++)\r\ndevice_remove_file(&led->client->dev,\r\nbd2802_addr_attributes[i]);\r\nif (bd2802_is_all_off(led))\r\ngpio_set_value(led->pdata->reset_gpio, 0);\r\nled->adf_on = 0;\r\n}\r\nstatic ssize_t bd2802_show_adv_conf(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct bd2802_led *led = i2c_get_clientdata(to_i2c_client(dev));\r\nssize_t ret;\r\ndown_read(&led->rwsem);\r\nif (led->adf_on)\r\nret = sprintf(buf, "on\n");\r\nelse\r\nret = sprintf(buf, "off\n");\r\nup_read(&led->rwsem);\r\nreturn ret;\r\n}\r\nstatic ssize_t bd2802_store_adv_conf(struct device *dev,\r\nstruct device_attribute *attr, const char *buf, size_t count)\r\n{\r\nstruct bd2802_led *led = i2c_get_clientdata(to_i2c_client(dev));\r\nif (!count)\r\nreturn -EINVAL;\r\ndown_write(&led->rwsem);\r\nif (!led->adf_on && !strncmp(buf, "on", 2))\r\nbd2802_enable_adv_conf(led);\r\nelse if (led->adf_on && !strncmp(buf, "off", 3))\r\nbd2802_disable_adv_conf(led);\r\nup_write(&led->rwsem);\r\nreturn count;\r\n}\r\nstatic void bd2802_led_work(struct work_struct *work)\r\n{\r\nstruct bd2802_led *led = container_of(work, struct bd2802_led, work);\r\nif (led->state)\r\nbd2802_turn_on(led, led->led_id, led->color, led->state);\r\nelse\r\nbd2802_turn_off(led, led->led_id, led->color);\r\n}\r\nstatic int bd2802_register_led_classdev(struct bd2802_led *led)\r\n{\r\nint ret;\r\nINIT_WORK(&led->work, bd2802_led_work);\r\nled->cdev_led1r.name = "led1_R";\r\nled->cdev_led1r.brightness = LED_OFF;\r\nled->cdev_led1r.brightness_set = bd2802_set_led1r_brightness;\r\nled->cdev_led1r.blink_set = bd2802_set_led1r_blink;\r\nret = led_classdev_register(&led->client->dev, &led->cdev_led1r);\r\nif (ret < 0) {\r\ndev_err(&led->client->dev, "couldn't register LED %s\n",\r\nled->cdev_led1r.name);\r\ngoto failed_unregister_led1_R;\r\n}\r\nled->cdev_led1g.name = "led1_G";\r\nled->cdev_led1g.brightness = LED_OFF;\r\nled->cdev_led1g.brightness_set = bd2802_set_led1g_brightness;\r\nled->cdev_led1g.blink_set = bd2802_set_led1g_blink;\r\nret = led_classdev_register(&led->client->dev, &led->cdev_led1g);\r\nif (ret < 0) {\r\ndev_err(&led->client->dev, "couldn't register LED %s\n",\r\nled->cdev_led1g.name);\r\ngoto failed_unregister_led1_G;\r\n}\r\nled->cdev_led1b.name = "led1_B";\r\nled->cdev_led1b.brightness = LED_OFF;\r\nled->cdev_led1b.brightness_set = bd2802_set_led1b_brightness;\r\nled->cdev_led1b.blink_set = bd2802_set_led1b_blink;\r\nret = led_classdev_register(&led->client->dev, &led->cdev_led1b);\r\nif (ret < 0) {\r\ndev_err(&led->client->dev, "couldn't register LED %s\n",\r\nled->cdev_led1b.name);\r\ngoto failed_unregister_led1_B;\r\n}\r\nled->cdev_led2r.name = "led2_R";\r\nled->cdev_led2r.brightness = LED_OFF;\r\nled->cdev_led2r.brightness_set = bd2802_set_led2r_brightness;\r\nled->cdev_led2r.blink_set = bd2802_set_led2r_blink;\r\nret = led_classdev_register(&led->client->dev, &led->cdev_led2r);\r\nif (ret < 0) {\r\ndev_err(&led->client->dev, "couldn't register LED %s\n",\r\nled->cdev_led2r.name);\r\ngoto failed_unregister_led2_R;\r\n}\r\nled->cdev_led2g.name = "led2_G";\r\nled->cdev_led2g.brightness = LED_OFF;\r\nled->cdev_led2g.brightness_set = bd2802_set_led2g_brightness;\r\nled->cdev_led2g.blink_set = bd2802_set_led2g_blink;\r\nret = led_classdev_register(&led->client->dev, &led->cdev_led2g);\r\nif (ret < 0) {\r\ndev_err(&led->client->dev, "couldn't register LED %s\n",\r\nled->cdev_led2g.name);\r\ngoto failed_unregister_led2_G;\r\n}\r\nled->cdev_led2b.name = "led2_B";\r\nled->cdev_led2b.brightness = LED_OFF;\r\nled->cdev_led2b.brightness_set = bd2802_set_led2b_brightness;\r\nled->cdev_led2b.blink_set = bd2802_set_led2b_blink;\r\nled->cdev_led2b.flags |= LED_CORE_SUSPENDRESUME;\r\nret = led_classdev_register(&led->client->dev, &led->cdev_led2b);\r\nif (ret < 0) {\r\ndev_err(&led->client->dev, "couldn't register LED %s\n",\r\nled->cdev_led2b.name);\r\ngoto failed_unregister_led2_B;\r\n}\r\nreturn 0;\r\nfailed_unregister_led2_B:\r\nled_classdev_unregister(&led->cdev_led2g);\r\nfailed_unregister_led2_G:\r\nled_classdev_unregister(&led->cdev_led2r);\r\nfailed_unregister_led2_R:\r\nled_classdev_unregister(&led->cdev_led1b);\r\nfailed_unregister_led1_B:\r\nled_classdev_unregister(&led->cdev_led1g);\r\nfailed_unregister_led1_G:\r\nled_classdev_unregister(&led->cdev_led1r);\r\nfailed_unregister_led1_R:\r\nreturn ret;\r\n}\r\nstatic void bd2802_unregister_led_classdev(struct bd2802_led *led)\r\n{\r\ncancel_work_sync(&led->work);\r\nled_classdev_unregister(&led->cdev_led2b);\r\nled_classdev_unregister(&led->cdev_led2g);\r\nled_classdev_unregister(&led->cdev_led2r);\r\nled_classdev_unregister(&led->cdev_led1b);\r\nled_classdev_unregister(&led->cdev_led1g);\r\nled_classdev_unregister(&led->cdev_led1r);\r\n}\r\nstatic int bd2802_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct bd2802_led *led;\r\nstruct bd2802_led_platform_data *pdata;\r\nint ret, i;\r\nled = devm_kzalloc(&client->dev, sizeof(struct bd2802_led), GFP_KERNEL);\r\nif (!led) {\r\ndev_err(&client->dev, "failed to allocate driver data\n");\r\nreturn -ENOMEM;\r\n}\r\nled->client = client;\r\npdata = led->pdata = client->dev.platform_data;\r\ni2c_set_clientdata(client, led);\r\ngpio_request_one(pdata->reset_gpio, GPIOF_OUT_INIT_HIGH, "RGB_RESETB");\r\nudelay(100);\r\nret = bd2802_write_byte(client, BD2802_REG_CLKSETUP, 0x00);\r\nif (ret < 0) {\r\ndev_err(&client->dev, "failed to detect device\n");\r\nreturn ret;\r\n} else\r\ndev_info(&client->dev, "return 0x%02x\n", ret);\r\ngpio_set_value(led->pdata->reset_gpio, 0);\r\nled->wave_pattern = BD2802_PATTERN_HALF;\r\nled->rgb_current = BD2802_CURRENT_032;\r\ninit_rwsem(&led->rwsem);\r\nfor (i = 0; i < ARRAY_SIZE(bd2802_attributes); i++) {\r\nret = device_create_file(&led->client->dev,\r\nbd2802_attributes[i]);\r\nif (ret) {\r\ndev_err(&led->client->dev, "failed: sysfs file %s\n",\r\nbd2802_attributes[i]->attr.name);\r\ngoto failed_unregister_dev_file;\r\n}\r\n}\r\nret = bd2802_register_led_classdev(led);\r\nif (ret < 0)\r\ngoto failed_unregister_dev_file;\r\nreturn 0;\r\nfailed_unregister_dev_file:\r\nfor (i--; i >= 0; i--)\r\ndevice_remove_file(&led->client->dev, bd2802_attributes[i]);\r\nreturn ret;\r\n}\r\nstatic int __exit bd2802_remove(struct i2c_client *client)\r\n{\r\nstruct bd2802_led *led = i2c_get_clientdata(client);\r\nint i;\r\ngpio_set_value(led->pdata->reset_gpio, 0);\r\nbd2802_unregister_led_classdev(led);\r\nif (led->adf_on)\r\nbd2802_disable_adv_conf(led);\r\nfor (i = 0; i < ARRAY_SIZE(bd2802_attributes); i++)\r\ndevice_remove_file(&led->client->dev, bd2802_attributes[i]);\r\nreturn 0;\r\n}\r\nstatic void bd2802_restore_state(struct bd2802_led *led)\r\n{\r\nint i;\r\nfor (i = 0; i < LED_NUM; i++) {\r\nif (led->led[i].r)\r\nbd2802_turn_on(led, i, RED, led->led[i].r);\r\nif (led->led[i].g)\r\nbd2802_turn_on(led, i, GREEN, led->led[i].g);\r\nif (led->led[i].b)\r\nbd2802_turn_on(led, i, BLUE, led->led[i].b);\r\n}\r\n}\r\nstatic int bd2802_suspend(struct device *dev)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct bd2802_led *led = i2c_get_clientdata(client);\r\ngpio_set_value(led->pdata->reset_gpio, 0);\r\nreturn 0;\r\n}\r\nstatic int bd2802_resume(struct device *dev)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct bd2802_led *led = i2c_get_clientdata(client);\r\nif (!bd2802_is_all_off(led) || led->adf_on) {\r\nbd2802_reset_cancel(led);\r\nbd2802_restore_state(led);\r\n}\r\nreturn 0;\r\n}
