static int rcar_usb_phy_init(struct usb_phy *phy)\r\n{\r\nstruct rcar_usb_phy_priv *priv = usb_phy_to_priv(phy);\r\nstruct device *dev = phy->dev;\r\nvoid __iomem *reg0 = priv->reg0;\r\nvoid __iomem *reg1 = priv->reg1;\r\nint i;\r\nu32 val;\r\nunsigned long flags;\r\nspin_lock_irqsave(&priv->lock, flags);\r\nif (priv->counter++ == 0) {\r\niowrite32(PHY_ENB, (reg0 + USBPCTRL1));\r\niowrite32(PHY_ENB | PLL_ENB, (reg0 + USBPCTRL1));\r\nfor (i = 0; i < 1024; i++) {\r\nudelay(10);\r\nval = ioread32(reg0 + USBST);\r\nif (val == (ST_ACT | ST_PLL))\r\nbreak;\r\n}\r\nif (val != (ST_ACT | ST_PLL)) {\r\ndev_err(dev, "USB phy not ready\n");\r\ngoto phy_init_end;\r\n}\r\niowrite32(PHY_ENB | PLL_ENB | PHY_RST, (reg0 + USBPCTRL1));\r\niowrite32(0x00000000, (reg0 + USBPCTRL0));\r\niowrite32(0x00ff0040, (reg0 + EIIBC1));\r\niowrite32(0x00ff0040, (reg1 + EIIBC1));\r\niowrite32(0x00000001, (reg0 + EIIBC2));\r\niowrite32(0x00000001, (reg1 + EIIBC2));\r\niowrite32(0x00000000, (reg0 + USBEH0));\r\niowrite32(0x00000000, (reg0 + USBOH0));\r\n}\r\nphy_init_end:\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\nreturn 0;\r\n}\r\nstatic void rcar_usb_phy_shutdown(struct usb_phy *phy)\r\n{\r\nstruct rcar_usb_phy_priv *priv = usb_phy_to_priv(phy);\r\nvoid __iomem *reg0 = priv->reg0;\r\nunsigned long flags;\r\nspin_lock_irqsave(&priv->lock, flags);\r\nif (priv->counter-- == 1) {\r\niowrite32(0x00000000, (reg0 + USBPCTRL0));\r\niowrite32(0x00000000, (reg0 + USBPCTRL1));\r\n}\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\n}\r\nstatic int rcar_usb_phy_probe(struct platform_device *pdev)\r\n{\r\nstruct rcar_usb_phy_priv *priv;\r\nstruct resource *res0, *res1;\r\nstruct device *dev = &pdev->dev;\r\nvoid __iomem *reg0, *reg1;\r\nint ret;\r\nres0 = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nres1 = platform_get_resource(pdev, IORESOURCE_MEM, 1);\r\nif (!res0 || !res1) {\r\ndev_err(dev, "Not enough platform resources\n");\r\nreturn -EINVAL;\r\n}\r\nreg0 = devm_ioremap_nocache(dev, res0->start, resource_size(res0));\r\nreg1 = devm_ioremap_nocache(dev, res1->start, resource_size(res1));\r\nif (!reg0 || !reg1) {\r\ndev_err(dev, "ioremap error\n");\r\nreturn -ENOMEM;\r\n}\r\npriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\r\nif (!priv) {\r\ndev_err(dev, "priv data allocation error\n");\r\nreturn -ENOMEM;\r\n}\r\npriv->reg0 = reg0;\r\npriv->reg1 = reg1;\r\npriv->counter = 0;\r\npriv->phy.dev = dev;\r\npriv->phy.label = dev_name(dev);\r\npriv->phy.init = rcar_usb_phy_init;\r\npriv->phy.shutdown = rcar_usb_phy_shutdown;\r\nspin_lock_init(&priv->lock);\r\nret = usb_add_phy(&priv->phy, USB_PHY_TYPE_USB2);\r\nif (ret < 0) {\r\ndev_err(dev, "usb phy addition error\n");\r\nreturn ret;\r\n}\r\nplatform_set_drvdata(pdev, priv);\r\nreturn ret;\r\n}\r\nstatic int rcar_usb_phy_remove(struct platform_device *pdev)\r\n{\r\nstruct rcar_usb_phy_priv *priv = platform_get_drvdata(pdev);\r\nusb_remove_phy(&priv->phy);\r\nreturn 0;\r\n}
