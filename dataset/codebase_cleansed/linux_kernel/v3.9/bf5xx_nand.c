static struct bf5xx_nand_info *mtd_to_nand_info(struct mtd_info *mtd)\r\n{\r\nreturn container_of(mtd, struct bf5xx_nand_info, mtd);\r\n}\r\nstatic struct bf5xx_nand_info *to_nand_info(struct platform_device *pdev)\r\n{\r\nreturn platform_get_drvdata(pdev);\r\n}\r\nstatic struct bf5xx_nand_platform *to_nand_plat(struct platform_device *pdev)\r\n{\r\nreturn pdev->dev.platform_data;\r\n}\r\nstatic void bf5xx_nand_hwcontrol(struct mtd_info *mtd, int cmd,\r\nunsigned int ctrl)\r\n{\r\nif (cmd == NAND_CMD_NONE)\r\nreturn;\r\nwhile (bfin_read_NFC_STAT() & WB_FULL)\r\ncpu_relax();\r\nif (ctrl & NAND_CLE)\r\nbfin_write_NFC_CMD(cmd);\r\nelse if (ctrl & NAND_ALE)\r\nbfin_write_NFC_ADDR(cmd);\r\nSSYNC();\r\n}\r\nstatic int bf5xx_nand_devready(struct mtd_info *mtd)\r\n{\r\nunsigned short val = bfin_read_NFC_STAT();\r\nif ((val & NBUSY) == NBUSY)\r\nreturn 1;\r\nelse\r\nreturn 0;\r\n}\r\nstatic int bf5xx_nand_correct_data_256(struct mtd_info *mtd, u_char *dat,\r\nu_char *read_ecc, u_char *calc_ecc)\r\n{\r\nstruct bf5xx_nand_info *info = mtd_to_nand_info(mtd);\r\nu32 syndrome[5];\r\nu32 calced, stored;\r\nint i;\r\nunsigned short failing_bit, failing_byte;\r\nu_char data;\r\ncalced = calc_ecc[0] | (calc_ecc[1] << 8) | (calc_ecc[2] << 16);\r\nstored = read_ecc[0] | (read_ecc[1] << 8) | (read_ecc[2] << 16);\r\nsyndrome[0] = (calced ^ stored);\r\nif (!syndrome[0] || !calced || !stored)\r\nreturn 0;\r\nif (hweight32(syndrome[0]) == 1) {\r\ndev_err(info->device, "ECC data was incorrect!\n");\r\nreturn 1;\r\n}\r\nsyndrome[1] = (calced & 0x7FF) ^ (stored & 0x7FF);\r\nsyndrome[2] = (calced & 0x7FF) ^ ((calced >> 11) & 0x7FF);\r\nsyndrome[3] = (stored & 0x7FF) ^ ((stored >> 11) & 0x7FF);\r\nsyndrome[4] = syndrome[2] ^ syndrome[3];\r\nfor (i = 0; i < 5; i++)\r\ndev_info(info->device, "syndrome[%d] 0x%08x\n", i, syndrome[i]);\r\ndev_info(info->device,\r\n"calced[0x%08x], stored[0x%08x]\n",\r\ncalced, stored);\r\nif (hweight32(syndrome[0]) == 11 && syndrome[4] == 0x7FF) {\r\ndev_info(info->device,\r\n"1-bit correctable error, correct it.\n");\r\ndev_info(info->device,\r\n"syndrome[1] 0x%08x\n", syndrome[1]);\r\nfailing_bit = syndrome[1] & 0x7;\r\nfailing_byte = syndrome[1] >> 0x3;\r\ndata = *(dat + failing_byte);\r\ndata = data ^ (0x1 << failing_bit);\r\n*(dat + failing_byte) = data;\r\nreturn 0;\r\n}\r\ndev_err(info->device,\r\n"More than 1-bit error, non-correctable error.\n");\r\ndev_err(info->device,\r\n"Please discard data, mark bad block\n");\r\nreturn 1;\r\n}\r\nstatic int bf5xx_nand_correct_data(struct mtd_info *mtd, u_char *dat,\r\nu_char *read_ecc, u_char *calc_ecc)\r\n{\r\nstruct nand_chip *chip = mtd->priv;\r\nint ret;\r\nret = bf5xx_nand_correct_data_256(mtd, dat, read_ecc, calc_ecc);\r\nif (chip->ecc.size == 512) {\r\ndat += 256;\r\nread_ecc += 3;\r\ncalc_ecc += 3;\r\nret |= bf5xx_nand_correct_data_256(mtd, dat, read_ecc, calc_ecc);\r\n}\r\nreturn ret;\r\n}\r\nstatic void bf5xx_nand_enable_hwecc(struct mtd_info *mtd, int mode)\r\n{\r\nreturn;\r\n}\r\nstatic int bf5xx_nand_calculate_ecc(struct mtd_info *mtd,\r\nconst u_char *dat, u_char *ecc_code)\r\n{\r\nstruct bf5xx_nand_info *info = mtd_to_nand_info(mtd);\r\nstruct nand_chip *chip = mtd->priv;\r\nu16 ecc0, ecc1;\r\nu32 code[2];\r\nu8 *p;\r\necc0 = bfin_read_NFC_ECC0();\r\necc1 = bfin_read_NFC_ECC1();\r\ncode[0] = (ecc0 & 0x7ff) | ((ecc1 & 0x7ff) << 11);\r\ndev_dbg(info->device, "returning ecc 0x%08x\n", code[0]);\r\np = (u8 *) code;\r\nmemcpy(ecc_code, p, 3);\r\nif (chip->ecc.size == 512) {\r\necc0 = bfin_read_NFC_ECC2();\r\necc1 = bfin_read_NFC_ECC3();\r\ncode[1] = (ecc0 & 0x7ff) | ((ecc1 & 0x7ff) << 11);\r\np = (u8 *) (code + 1);\r\nmemcpy((ecc_code + 3), p, 3);\r\ndev_dbg(info->device, "returning ecc 0x%08x\n", code[1]);\r\n}\r\nreturn 0;\r\n}\r\nstatic void bf5xx_nand_read_buf(struct mtd_info *mtd, uint8_t *buf, int len)\r\n{\r\nint i;\r\nunsigned short val;\r\nfor (i = 0; i < len; i++) {\r\nwhile (bfin_read_NFC_STAT() & WB_FULL)\r\ncpu_relax();\r\nbfin_write_NFC_DATA_RD(0x0000);\r\nSSYNC();\r\nwhile ((bfin_read_NFC_IRQSTAT() & RD_RDY) != RD_RDY)\r\ncpu_relax();\r\nbuf[i] = bfin_read_NFC_READ();\r\nval = bfin_read_NFC_IRQSTAT();\r\nval |= RD_RDY;\r\nbfin_write_NFC_IRQSTAT(val);\r\nSSYNC();\r\n}\r\n}\r\nstatic uint8_t bf5xx_nand_read_byte(struct mtd_info *mtd)\r\n{\r\nuint8_t val;\r\nbf5xx_nand_read_buf(mtd, &val, 1);\r\nreturn val;\r\n}\r\nstatic void bf5xx_nand_write_buf(struct mtd_info *mtd,\r\nconst uint8_t *buf, int len)\r\n{\r\nint i;\r\nfor (i = 0; i < len; i++) {\r\nwhile (bfin_read_NFC_STAT() & WB_FULL)\r\ncpu_relax();\r\nbfin_write_NFC_DATA_WR(buf[i]);\r\nSSYNC();\r\n}\r\n}\r\nstatic void bf5xx_nand_read_buf16(struct mtd_info *mtd, uint8_t *buf, int len)\r\n{\r\nint i;\r\nu16 *p = (u16 *) buf;\r\nlen >>= 1;\r\nbfin_write_NFC_DATA_RD(0x5555);\r\nSSYNC();\r\nfor (i = 0; i < len; i++)\r\np[i] = bfin_read_NFC_READ();\r\n}\r\nstatic void bf5xx_nand_write_buf16(struct mtd_info *mtd,\r\nconst uint8_t *buf, int len)\r\n{\r\nint i;\r\nu16 *p = (u16 *) buf;\r\nlen >>= 1;\r\nfor (i = 0; i < len; i++)\r\nbfin_write_NFC_DATA_WR(p[i]);\r\nSSYNC();\r\n}\r\nstatic irqreturn_t bf5xx_nand_dma_irq(int irq, void *dev_id)\r\n{\r\nstruct bf5xx_nand_info *info = dev_id;\r\nclear_dma_irqstat(CH_NFC);\r\ndisable_dma(CH_NFC);\r\ncomplete(&info->dma_completion);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void bf5xx_nand_dma_rw(struct mtd_info *mtd,\r\nuint8_t *buf, int is_read)\r\n{\r\nstruct bf5xx_nand_info *info = mtd_to_nand_info(mtd);\r\nstruct nand_chip *chip = mtd->priv;\r\nunsigned short val;\r\ndev_dbg(info->device, " mtd->%p, buf->%p, is_read %d\n",\r\nmtd, buf, is_read);\r\nif (is_read)\r\ninvalidate_dcache_range((unsigned int)buf,\r\n(unsigned int)(buf + chip->ecc.size));\r\nelse\r\nflush_dcache_range((unsigned int)buf,\r\n(unsigned int)(buf + chip->ecc.size));\r\nbfin_write_NFC_RST(ECC_RST);\r\nSSYNC();\r\nwhile (bfin_read_NFC_RST() & ECC_RST)\r\ncpu_relax();\r\ndisable_dma(CH_NFC);\r\nclear_dma_irqstat(CH_NFC);\r\nset_dma_config(CH_NFC, 0x0);\r\nset_dma_start_addr(CH_NFC, (unsigned long) buf);\r\n#ifdef CONFIG_BF52x\r\nset_dma_x_count(CH_NFC, (chip->ecc.size >> 1));\r\nset_dma_x_modify(CH_NFC, 2);\r\nval = DI_EN | WDSIZE_16;\r\n#endif\r\n#ifdef CONFIG_BF54x\r\nset_dma_x_count(CH_NFC, (chip->ecc.size >> 2));\r\nset_dma_x_modify(CH_NFC, 4);\r\nval = DI_EN | WDSIZE_32;\r\n#endif\r\nif (is_read)\r\nval |= WNR;\r\nset_dma_config(CH_NFC, val);\r\nenable_dma(CH_NFC);\r\nif (is_read)\r\nbfin_write_NFC_PGCTL(PG_RD_START);\r\nelse\r\nbfin_write_NFC_PGCTL(PG_WR_START);\r\nwait_for_completion(&info->dma_completion);\r\n}\r\nstatic void bf5xx_nand_dma_read_buf(struct mtd_info *mtd,\r\nuint8_t *buf, int len)\r\n{\r\nstruct bf5xx_nand_info *info = mtd_to_nand_info(mtd);\r\nstruct nand_chip *chip = mtd->priv;\r\ndev_dbg(info->device, "mtd->%p, buf->%p, int %d\n", mtd, buf, len);\r\nif (len == chip->ecc.size)\r\nbf5xx_nand_dma_rw(mtd, buf, 1);\r\nelse\r\nbf5xx_nand_read_buf(mtd, buf, len);\r\n}\r\nstatic void bf5xx_nand_dma_write_buf(struct mtd_info *mtd,\r\nconst uint8_t *buf, int len)\r\n{\r\nstruct bf5xx_nand_info *info = mtd_to_nand_info(mtd);\r\nstruct nand_chip *chip = mtd->priv;\r\ndev_dbg(info->device, "mtd->%p, buf->%p, len %d\n", mtd, buf, len);\r\nif (len == chip->ecc.size)\r\nbf5xx_nand_dma_rw(mtd, (uint8_t *)buf, 0);\r\nelse\r\nbf5xx_nand_write_buf(mtd, buf, len);\r\n}\r\nstatic int bf5xx_nand_read_page_raw(struct mtd_info *mtd, struct nand_chip *chip,\r\nuint8_t *buf, int oob_required, int page)\r\n{\r\nbf5xx_nand_read_buf(mtd, buf, mtd->writesize);\r\nbf5xx_nand_read_buf(mtd, chip->oob_poi, mtd->oobsize);\r\nreturn 0;\r\n}\r\nstatic int bf5xx_nand_write_page_raw(struct mtd_info *mtd,\r\nstruct nand_chip *chip, const uint8_t *buf, int oob_required)\r\n{\r\nbf5xx_nand_write_buf(mtd, buf, mtd->writesize);\r\nbf5xx_nand_write_buf(mtd, chip->oob_poi, mtd->oobsize);\r\nreturn 0;\r\n}\r\nstatic int bf5xx_nand_dma_init(struct bf5xx_nand_info *info)\r\n{\r\nint ret;\r\nif (!hardware_ecc)\r\nreturn 0;\r\ninit_completion(&info->dma_completion);\r\nret = request_dma(CH_NFC, "BF5XX NFC driver");\r\nif (ret < 0) {\r\ndev_err(info->device, " unable to get DMA channel\n");\r\nreturn ret;\r\n}\r\n#ifdef CONFIG_BF54x\r\nbfin_write_DMAC1_PERIMUX(bfin_read_DMAC1_PERIMUX() & ~1);\r\nSSYNC();\r\n#endif\r\nset_dma_callback(CH_NFC, bf5xx_nand_dma_irq, info);\r\ndisable_dma(CH_NFC);\r\nreturn 0;\r\n}\r\nstatic void bf5xx_nand_dma_remove(struct bf5xx_nand_info *info)\r\n{\r\nif (hardware_ecc)\r\nfree_dma(CH_NFC);\r\n}\r\nstatic int bf5xx_nand_hw_init(struct bf5xx_nand_info *info)\r\n{\r\nint err = 0;\r\nunsigned short val;\r\nstruct bf5xx_nand_platform *plat = info->platform;\r\ndev_info(info->device,\r\n"data_width=%d, wr_dly=%d, rd_dly=%d\n",\r\n(plat->data_width ? 16 : 8),\r\nplat->wr_dly, plat->rd_dly);\r\nval = (1 << NFC_PG_SIZE_OFFSET) |\r\n(plat->data_width << NFC_NWIDTH_OFFSET) |\r\n(plat->rd_dly << NFC_RDDLY_OFFSET) |\r\n(plat->wr_dly << NFC_WRDLY_OFFSET);\r\ndev_dbg(info->device, "NFC_CTL is 0x%04x\n", val);\r\nbfin_write_NFC_CTL(val);\r\nSSYNC();\r\nbfin_write_NFC_IRQMASK(0x0);\r\nSSYNC();\r\nval = bfin_read_NFC_IRQSTAT();\r\nbfin_write_NFC_IRQSTAT(val);\r\nSSYNC();\r\nif (bf5xx_nand_dma_init(info))\r\nerr = -ENXIO;\r\nreturn err;\r\n}\r\nstatic int bf5xx_nand_add_partition(struct bf5xx_nand_info *info)\r\n{\r\nstruct mtd_info *mtd = &info->mtd;\r\nstruct mtd_partition *parts = info->platform->partitions;\r\nint nr = info->platform->nr_partitions;\r\nreturn mtd_device_register(mtd, parts, nr);\r\n}\r\nstatic int bf5xx_nand_remove(struct platform_device *pdev)\r\n{\r\nstruct bf5xx_nand_info *info = to_nand_info(pdev);\r\nplatform_set_drvdata(pdev, NULL);\r\nnand_release(&info->mtd);\r\nperipheral_free_list(bfin_nfc_pin_req);\r\nbf5xx_nand_dma_remove(info);\r\nkfree(info);\r\nreturn 0;\r\n}\r\nstatic int bf5xx_nand_scan(struct mtd_info *mtd)\r\n{\r\nstruct nand_chip *chip = mtd->priv;\r\nint ret;\r\nret = nand_scan_ident(mtd, 1, NULL);\r\nif (ret)\r\nreturn ret;\r\nif (hardware_ecc) {\r\nif (likely(mtd->writesize >= 512)) {\r\nchip->ecc.size = 512;\r\nchip->ecc.bytes = 6;\r\nchip->ecc.strength = 2;\r\n} else {\r\nchip->ecc.size = 256;\r\nchip->ecc.bytes = 3;\r\nchip->ecc.strength = 1;\r\nbfin_write_NFC_CTL(bfin_read_NFC_CTL() & ~(1 << NFC_PG_SIZE_OFFSET));\r\nSSYNC();\r\n}\r\n}\r\nreturn nand_scan_tail(mtd);\r\n}\r\nstatic int bf5xx_nand_probe(struct platform_device *pdev)\r\n{\r\nstruct bf5xx_nand_platform *plat = to_nand_plat(pdev);\r\nstruct bf5xx_nand_info *info = NULL;\r\nstruct nand_chip *chip = NULL;\r\nstruct mtd_info *mtd = NULL;\r\nint err = 0;\r\ndev_dbg(&pdev->dev, "(%p)\n", pdev);\r\nif (!plat) {\r\ndev_err(&pdev->dev, "no platform specific information\n");\r\nreturn -EINVAL;\r\n}\r\nif (peripheral_request_list(bfin_nfc_pin_req, DRV_NAME)) {\r\ndev_err(&pdev->dev, "requesting Peripherals failed\n");\r\nreturn -EFAULT;\r\n}\r\ninfo = kzalloc(sizeof(*info), GFP_KERNEL);\r\nif (info == NULL) {\r\ndev_err(&pdev->dev, "no memory for flash info\n");\r\nerr = -ENOMEM;\r\ngoto out_err_kzalloc;\r\n}\r\nplatform_set_drvdata(pdev, info);\r\nspin_lock_init(&info->controller.lock);\r\ninit_waitqueue_head(&info->controller.wq);\r\ninfo->device = &pdev->dev;\r\ninfo->platform = plat;\r\nchip = &info->chip;\r\nif (plat->data_width)\r\nchip->options |= NAND_BUSWIDTH_16;\r\nchip->options |= NAND_CACHEPRG | NAND_SKIP_BBTSCAN;\r\nchip->read_buf = (plat->data_width) ?\r\nbf5xx_nand_read_buf16 : bf5xx_nand_read_buf;\r\nchip->write_buf = (plat->data_width) ?\r\nbf5xx_nand_write_buf16 : bf5xx_nand_write_buf;\r\nchip->read_byte = bf5xx_nand_read_byte;\r\nchip->cmd_ctrl = bf5xx_nand_hwcontrol;\r\nchip->dev_ready = bf5xx_nand_devready;\r\nchip->priv = &info->mtd;\r\nchip->controller = &info->controller;\r\nchip->IO_ADDR_R = (void __iomem *) NFC_READ;\r\nchip->IO_ADDR_W = (void __iomem *) NFC_DATA_WR;\r\nchip->chip_delay = 0;\r\nmtd = &info->mtd;\r\nmtd->priv = chip;\r\nmtd->owner = THIS_MODULE;\r\nerr = bf5xx_nand_hw_init(info);\r\nif (err)\r\ngoto out_err_hw_init;\r\nif (hardware_ecc) {\r\n#ifdef CONFIG_MTD_NAND_BF5XX_BOOTROM_ECC\r\nchip->ecc.layout = &bootrom_ecclayout;\r\n#endif\r\nchip->read_buf = bf5xx_nand_dma_read_buf;\r\nchip->write_buf = bf5xx_nand_dma_write_buf;\r\nchip->ecc.calculate = bf5xx_nand_calculate_ecc;\r\nchip->ecc.correct = bf5xx_nand_correct_data;\r\nchip->ecc.mode = NAND_ECC_HW;\r\nchip->ecc.hwctl = bf5xx_nand_enable_hwecc;\r\nchip->ecc.read_page_raw = bf5xx_nand_read_page_raw;\r\nchip->ecc.write_page_raw = bf5xx_nand_write_page_raw;\r\n} else {\r\nchip->ecc.mode = NAND_ECC_SOFT;\r\n}\r\nif (bf5xx_nand_scan(mtd)) {\r\nerr = -ENXIO;\r\ngoto out_err_nand_scan;\r\n}\r\n#ifdef CONFIG_MTD_NAND_BF5XX_BOOTROM_ECC\r\nchip->badblockpos = 63;\r\n#endif\r\nbf5xx_nand_add_partition(info);\r\ndev_dbg(&pdev->dev, "initialised ok\n");\r\nreturn 0;\r\nout_err_nand_scan:\r\nbf5xx_nand_dma_remove(info);\r\nout_err_hw_init:\r\nplatform_set_drvdata(pdev, NULL);\r\nkfree(info);\r\nout_err_kzalloc:\r\nperipheral_free_list(bfin_nfc_pin_req);\r\nreturn err;\r\n}\r\nstatic int bf5xx_nand_suspend(struct platform_device *dev, pm_message_t pm)\r\n{\r\nstruct bf5xx_nand_info *info = platform_get_drvdata(dev);\r\nreturn 0;\r\n}\r\nstatic int bf5xx_nand_resume(struct platform_device *dev)\r\n{\r\nstruct bf5xx_nand_info *info = platform_get_drvdata(dev);\r\nreturn 0;\r\n}\r\nstatic int __init bf5xx_nand_init(void)\r\n{\r\nprintk(KERN_INFO "%s, Version %s (c) 2007 Analog Devices, Inc.\n",\r\nDRV_DESC, DRV_VERSION);\r\nreturn platform_driver_register(&bf5xx_nand_driver);\r\n}\r\nstatic void __exit bf5xx_nand_exit(void)\r\n{\r\nplatform_driver_unregister(&bf5xx_nand_driver);\r\n}
