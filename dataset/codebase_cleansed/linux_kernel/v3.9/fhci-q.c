static int status_to_error(u32 status)\r\n{\r\nif (status == USB_TD_OK)\r\nreturn 0;\r\nelse if (status & USB_TD_RX_ER_CRC)\r\nreturn -EILSEQ;\r\nelse if (status & USB_TD_RX_ER_NONOCT)\r\nreturn -EPROTO;\r\nelse if (status & USB_TD_RX_ER_OVERUN)\r\nreturn -ECOMM;\r\nelse if (status & USB_TD_RX_ER_BITSTUFF)\r\nreturn -EPROTO;\r\nelse if (status & USB_TD_RX_ER_PID)\r\nreturn -EILSEQ;\r\nelse if (status & (USB_TD_TX_ER_NAK | USB_TD_TX_ER_TIMEOUT))\r\nreturn -ETIMEDOUT;\r\nelse if (status & USB_TD_TX_ER_STALL)\r\nreturn -EPIPE;\r\nelse if (status & USB_TD_TX_ER_UNDERUN)\r\nreturn -ENOSR;\r\nelse if (status & USB_TD_RX_DATA_UNDERUN)\r\nreturn -EREMOTEIO;\r\nelse if (status & USB_TD_RX_DATA_OVERUN)\r\nreturn -EOVERFLOW;\r\nelse\r\nreturn -EINVAL;\r\n}\r\nvoid fhci_add_td_to_frame(struct fhci_time_frame *frame, struct td *td)\r\n{\r\nlist_add_tail(&td->frame_lh, &frame->tds_list);\r\n}\r\nvoid fhci_add_tds_to_ed(struct ed *ed, struct td **td_list, int number)\r\n{\r\nint i;\r\nfor (i = 0; i < number; i++) {\r\nstruct td *td = td_list[i];\r\nlist_add_tail(&td->node, &ed->td_list);\r\n}\r\nif (ed->td_head == NULL)\r\ned->td_head = td_list[0];\r\n}\r\nstatic struct td *peek_td_from_ed(struct ed *ed)\r\n{\r\nstruct td *td;\r\nif (!list_empty(&ed->td_list))\r\ntd = list_entry(ed->td_list.next, struct td, node);\r\nelse\r\ntd = NULL;\r\nreturn td;\r\n}\r\nstruct td *fhci_remove_td_from_frame(struct fhci_time_frame *frame)\r\n{\r\nstruct td *td;\r\nif (!list_empty(&frame->tds_list)) {\r\ntd = list_entry(frame->tds_list.next, struct td, frame_lh);\r\nlist_del_init(frame->tds_list.next);\r\n} else\r\ntd = NULL;\r\nreturn td;\r\n}\r\nstruct td *fhci_peek_td_from_frame(struct fhci_time_frame *frame)\r\n{\r\nstruct td *td;\r\nif (!list_empty(&frame->tds_list))\r\ntd = list_entry(frame->tds_list.next, struct td, frame_lh);\r\nelse\r\ntd = NULL;\r\nreturn td;\r\n}\r\nstruct td *fhci_remove_td_from_ed(struct ed *ed)\r\n{\r\nstruct td *td;\r\nif (!list_empty(&ed->td_list)) {\r\ntd = list_entry(ed->td_list.next, struct td, node);\r\nlist_del_init(ed->td_list.next);\r\nif (!list_empty(&ed->td_list))\r\ned->td_head = list_entry(ed->td_list.next, struct td,\r\nnode);\r\nelse\r\ned->td_head = NULL;\r\n} else\r\ntd = NULL;\r\nreturn td;\r\n}\r\nstruct td *fhci_remove_td_from_done_list(struct fhci_controller_list *p_list)\r\n{\r\nstruct td *td;\r\nif (!list_empty(&p_list->done_list)) {\r\ntd = list_entry(p_list->done_list.next, struct td, node);\r\nlist_del_init(p_list->done_list.next);\r\n} else\r\ntd = NULL;\r\nreturn td;\r\n}\r\nvoid fhci_move_td_from_ed_to_done_list(struct fhci_usb *usb, struct ed *ed)\r\n{\r\nstruct td *td;\r\ntd = ed->td_head;\r\nlist_del_init(&td->node);\r\nif (!list_empty(&ed->td_list))\r\ned->td_head = list_entry(ed->td_list.next, struct td, node);\r\nelse {\r\ned->td_head = NULL;\r\ned->state = FHCI_ED_SKIP;\r\n}\r\ned->toggle_carry = td->toggle;\r\nlist_add_tail(&td->node, &usb->hc_list->done_list);\r\nif (td->ioc)\r\nusb->transfer_confirm(usb->fhci);\r\n}\r\nstatic void free_urb_priv(struct fhci_hcd *fhci, struct urb *urb)\r\n{\r\nint i;\r\nstruct urb_priv *urb_priv = urb->hcpriv;\r\nstruct ed *ed = urb_priv->ed;\r\nfor (i = 0; i < urb_priv->num_of_tds; i++) {\r\nlist_del_init(&urb_priv->tds[i]->node);\r\nfhci_recycle_empty_td(fhci, urb_priv->tds[i]);\r\n}\r\nif (!list_empty(&ed->td_list))\r\ned->td_head = list_entry(ed->td_list.next, struct td, node);\r\nelse\r\ned->td_head = NULL;\r\nkfree(urb_priv->tds);\r\nkfree(urb_priv);\r\nurb->hcpriv = NULL;\r\nif (ed->td_head == NULL)\r\nlist_del_init(&ed->node);\r\nfhci->active_urbs--;\r\n}\r\nvoid fhci_urb_complete_free(struct fhci_hcd *fhci, struct urb *urb)\r\n{\r\nfree_urb_priv(fhci, urb);\r\nif (urb->status == -EINPROGRESS) {\r\nif (urb->actual_length != urb->transfer_buffer_length &&\r\nurb->transfer_flags & URB_SHORT_NOT_OK)\r\nurb->status = -EREMOTEIO;\r\nelse\r\nurb->status = 0;\r\n}\r\nusb_hcd_unlink_urb_from_ep(fhci_to_hcd(fhci), urb);\r\nspin_unlock(&fhci->lock);\r\nusb_hcd_giveback_urb(fhci_to_hcd(fhci), urb, urb->status);\r\nspin_lock(&fhci->lock);\r\n}\r\nvoid fhci_done_td(struct urb *urb, struct td *td)\r\n{\r\nstruct ed *ed = td->ed;\r\nu32 cc = td->status;\r\nif (ed->mode == FHCI_TF_ISO) {\r\nu32 len;\r\nif (!(urb->transfer_flags & URB_SHORT_NOT_OK &&\r\ncc == USB_TD_RX_DATA_UNDERUN))\r\ncc = USB_TD_OK;\r\nif (usb_pipeout(urb->pipe))\r\nlen = urb->iso_frame_desc[td->iso_index].length;\r\nelse\r\nlen = td->actual_len;\r\nurb->actual_length += len;\r\nurb->iso_frame_desc[td->iso_index].actual_length = len;\r\nurb->iso_frame_desc[td->iso_index].status =\r\nstatus_to_error(cc);\r\n}\r\nelse {\r\nif (td->error_cnt >= 3)\r\nurb->error_count = 3;\r\nif (!(urb->transfer_flags & URB_SHORT_NOT_OK) &&\r\ncc == USB_TD_RX_DATA_UNDERUN) {\r\ned->state = FHCI_ED_OPER;\r\ncc = USB_TD_OK;\r\n}\r\nif (cc != USB_TD_OK) {\r\nif (urb->status == -EINPROGRESS)\r\nurb->status = status_to_error(cc);\r\n}\r\nif (td->type != FHCI_TA_SETUP || td->iso_index != 0)\r\nurb->actual_length += td->actual_len;\r\n}\r\n}\r\nvoid fhci_del_ed_list(struct fhci_hcd *fhci, struct ed *ed)\r\n{\r\nstruct td *td = peek_td_from_ed(ed);\r\nstruct urb *urb = td->urb;\r\nstruct urb_priv *urb_priv = urb->hcpriv;\r\nif (urb_priv->state == URB_DEL) {\r\ntd = fhci_remove_td_from_ed(ed);\r\nif (td->status != USB_TD_INPROGRESS)\r\nfhci_done_td(urb, td);\r\nif (++(urb_priv->tds_cnt) == urb_priv->num_of_tds)\r\nfhci_urb_complete_free(fhci, urb);\r\n}\r\n}
