static void octeon_lmc_edac_poll(struct mem_ctl_info *mci)\r\n{\r\nunion cvmx_lmcx_mem_cfg0 cfg0;\r\nbool do_clear = false;\r\nchar msg[64];\r\ncfg0.u64 = cvmx_read_csr(CVMX_LMCX_MEM_CFG0(mci->mc_idx));\r\nif (cfg0.s.sec_err || cfg0.s.ded_err) {\r\nunion cvmx_lmcx_fadr fadr;\r\nfadr.u64 = cvmx_read_csr(CVMX_LMCX_FADR(mci->mc_idx));\r\nsnprintf(msg, sizeof(msg),\r\n"DIMM %d rank %d bank %d row %d col %d",\r\nfadr.cn30xx.fdimm, fadr.cn30xx.fbunk,\r\nfadr.cn30xx.fbank, fadr.cn30xx.frow, fadr.cn30xx.fcol);\r\n}\r\nif (cfg0.s.sec_err) {\r\nedac_mc_handle_error(HW_EVENT_ERR_CORRECTED, mci, 1, 0, 0, 0,\r\n-1, -1, -1, msg, "");\r\ncfg0.s.sec_err = -1;\r\ndo_clear = true;\r\n}\r\nif (cfg0.s.ded_err) {\r\nedac_mc_handle_error(HW_EVENT_ERR_UNCORRECTED, mci, 1, 0, 0, 0,\r\n-1, -1, -1, msg, "");\r\ncfg0.s.ded_err = -1;\r\ndo_clear = true;\r\n}\r\nif (do_clear)\r\ncvmx_write_csr(CVMX_LMCX_MEM_CFG0(mci->mc_idx), cfg0.u64);\r\n}\r\nstatic void octeon_lmc_edac_poll_o2(struct mem_ctl_info *mci)\r\n{\r\nunion cvmx_lmcx_int int_reg;\r\nbool do_clear = false;\r\nchar msg[64];\r\nint_reg.u64 = cvmx_read_csr(CVMX_LMCX_INT(mci->mc_idx));\r\nif (int_reg.s.sec_err || int_reg.s.ded_err) {\r\nunion cvmx_lmcx_fadr fadr;\r\nfadr.u64 = cvmx_read_csr(CVMX_LMCX_FADR(mci->mc_idx));\r\nsnprintf(msg, sizeof(msg),\r\n"DIMM %d rank %d bank %d row %d col %d",\r\nfadr.cn61xx.fdimm, fadr.cn61xx.fbunk,\r\nfadr.cn61xx.fbank, fadr.cn61xx.frow, fadr.cn61xx.fcol);\r\n}\r\nif (int_reg.s.sec_err) {\r\nedac_mc_handle_error(HW_EVENT_ERR_CORRECTED, mci, 1, 0, 0, 0,\r\n-1, -1, -1, msg, "");\r\nint_reg.s.sec_err = -1;\r\ndo_clear = true;\r\n}\r\nif (int_reg.s.ded_err) {\r\nedac_mc_handle_error(HW_EVENT_ERR_UNCORRECTED, mci, 1, 0, 0, 0,\r\n-1, -1, -1, msg, "");\r\nint_reg.s.ded_err = -1;\r\ndo_clear = true;\r\n}\r\nif (do_clear)\r\ncvmx_write_csr(CVMX_LMCX_INT(mci->mc_idx), int_reg.u64);\r\n}\r\nstatic int octeon_lmc_edac_probe(struct platform_device *pdev)\r\n{\r\nstruct mem_ctl_info *mci;\r\nstruct edac_mc_layer layers[1];\r\nint mc = pdev->id;\r\nlayers[0].type = EDAC_MC_LAYER_CHANNEL;\r\nlayers[0].size = 1;\r\nlayers[0].is_virt_csrow = false;\r\nif (OCTEON_IS_MODEL(OCTEON_FAM_1_PLUS)) {\r\nunion cvmx_lmcx_mem_cfg0 cfg0;\r\ncfg0.u64 = cvmx_read_csr(CVMX_LMCX_MEM_CFG0(0));\r\nif (!cfg0.s.ecc_ena) {\r\ndev_info(&pdev->dev, "Disabled (ECC not enabled)\n");\r\nreturn 0;\r\n}\r\nmci = edac_mc_alloc(mc, ARRAY_SIZE(layers), layers, 0);\r\nif (!mci)\r\nreturn -ENXIO;\r\nmci->pdev = &pdev->dev;\r\nmci->dev_name = dev_name(&pdev->dev);\r\nmci->mod_name = "octeon-lmc";\r\nmci->ctl_name = "octeon-lmc-err";\r\nmci->edac_check = octeon_lmc_edac_poll;\r\nif (edac_mc_add_mc(mci)) {\r\ndev_err(&pdev->dev, "edac_mc_add_mc() failed\n");\r\nedac_mc_free(mci);\r\nreturn -ENXIO;\r\n}\r\ncfg0.u64 = cvmx_read_csr(CVMX_LMCX_MEM_CFG0(mc));\r\ncfg0.s.intr_ded_ena = 0;\r\ncfg0.s.intr_sec_ena = 0;\r\ncvmx_write_csr(CVMX_LMCX_MEM_CFG0(mc), cfg0.u64);\r\n} else {\r\nunion cvmx_lmcx_int_en en;\r\nunion cvmx_lmcx_config config;\r\nconfig.u64 = cvmx_read_csr(CVMX_LMCX_CONFIG(0));\r\nif (!config.s.ecc_ena) {\r\ndev_info(&pdev->dev, "Disabled (ECC not enabled)\n");\r\nreturn 0;\r\n}\r\nmci = edac_mc_alloc(mc, ARRAY_SIZE(layers), layers, 0);\r\nif (!mci)\r\nreturn -ENXIO;\r\nmci->pdev = &pdev->dev;\r\nmci->dev_name = dev_name(&pdev->dev);\r\nmci->mod_name = "octeon-lmc";\r\nmci->ctl_name = "co_lmc_err";\r\nmci->edac_check = octeon_lmc_edac_poll_o2;\r\nif (edac_mc_add_mc(mci)) {\r\ndev_err(&pdev->dev, "edac_mc_add_mc() failed\n");\r\nedac_mc_free(mci);\r\nreturn -ENXIO;\r\n}\r\nen.u64 = cvmx_read_csr(CVMX_LMCX_MEM_CFG0(mc));\r\nen.s.intr_ded_ena = 0;\r\nen.s.intr_sec_ena = 0;\r\ncvmx_write_csr(CVMX_LMCX_MEM_CFG0(mc), en.u64);\r\n}\r\nplatform_set_drvdata(pdev, mci);\r\nreturn 0;\r\n}\r\nstatic int octeon_lmc_edac_remove(struct platform_device *pdev)\r\n{\r\nstruct mem_ctl_info *mci = platform_get_drvdata(pdev);\r\nedac_mc_del_mc(&pdev->dev);\r\nedac_mc_free(mci);\r\nreturn 0;\r\n}
