static irqreturn_t ep93xx_keypad_irq_handler(int irq, void *dev_id)\r\n{\r\nstruct ep93xx_keypad *keypad = dev_id;\r\nstruct input_dev *input_dev = keypad->input_dev;\r\nunsigned int status;\r\nint keycode, key1, key2;\r\nstatus = __raw_readl(keypad->mmio_base + KEY_REG);\r\nkeycode = (status & KEY_REG_KEY1_MASK) >> KEY_REG_KEY1_SHIFT;\r\nkey1 = keypad->keycodes[keycode];\r\nkeycode = (status & KEY_REG_KEY2_MASK) >> KEY_REG_KEY2_SHIFT;\r\nkey2 = keypad->keycodes[keycode];\r\nif (status & KEY_REG_2KEYS) {\r\nif (keypad->key1 && key1 != keypad->key1 && key2 != keypad->key1)\r\ninput_report_key(input_dev, keypad->key1, 0);\r\nif (keypad->key2 && key1 != keypad->key2 && key2 != keypad->key2)\r\ninput_report_key(input_dev, keypad->key2, 0);\r\ninput_report_key(input_dev, key1, 1);\r\ninput_report_key(input_dev, key2, 1);\r\nkeypad->key1 = key1;\r\nkeypad->key2 = key2;\r\n} else if (status & KEY_REG_1KEY) {\r\nif (keypad->key1 && key1 != keypad->key1)\r\ninput_report_key(input_dev, keypad->key1, 0);\r\nif (keypad->key2 && key1 != keypad->key2)\r\ninput_report_key(input_dev, keypad->key2, 0);\r\ninput_report_key(input_dev, key1, 1);\r\nkeypad->key1 = key1;\r\nkeypad->key2 = 0;\r\n} else {\r\ninput_report_key(input_dev, keypad->key1, 0);\r\ninput_report_key(input_dev, keypad->key2, 0);\r\nkeypad->key1 = keypad->key2 = 0;\r\n}\r\ninput_sync(input_dev);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void ep93xx_keypad_config(struct ep93xx_keypad *keypad)\r\n{\r\nstruct ep93xx_keypad_platform_data *pdata = keypad->pdata;\r\nunsigned int val = 0;\r\nif (pdata->flags & EP93XX_KEYPAD_KDIV)\r\nclk_set_rate(keypad->clk, EP93XX_KEYTCHCLK_DIV4);\r\nelse\r\nclk_set_rate(keypad->clk, EP93XX_KEYTCHCLK_DIV16);\r\nif (pdata->flags & EP93XX_KEYPAD_DISABLE_3_KEY)\r\nval |= KEY_INIT_DIS3KY;\r\nif (pdata->flags & EP93XX_KEYPAD_DIAG_MODE)\r\nval |= KEY_INIT_DIAG;\r\nif (pdata->flags & EP93XX_KEYPAD_BACK_DRIVE)\r\nval |= KEY_INIT_BACK;\r\nif (pdata->flags & EP93XX_KEYPAD_TEST_MODE)\r\nval |= KEY_INIT_T2;\r\nval |= ((pdata->debounce << KEY_INIT_DBNC_SHIFT) & KEY_INIT_DBNC_MASK);\r\nval |= ((pdata->prescale << KEY_INIT_PRSCL_SHIFT) & KEY_INIT_PRSCL_MASK);\r\n__raw_writel(val, keypad->mmio_base + KEY_INIT);\r\n}\r\nstatic int ep93xx_keypad_open(struct input_dev *pdev)\r\n{\r\nstruct ep93xx_keypad *keypad = input_get_drvdata(pdev);\r\nif (!keypad->enabled) {\r\nep93xx_keypad_config(keypad);\r\nclk_enable(keypad->clk);\r\nkeypad->enabled = true;\r\n}\r\nreturn 0;\r\n}\r\nstatic void ep93xx_keypad_close(struct input_dev *pdev)\r\n{\r\nstruct ep93xx_keypad *keypad = input_get_drvdata(pdev);\r\nif (keypad->enabled) {\r\nclk_disable(keypad->clk);\r\nkeypad->enabled = false;\r\n}\r\n}\r\nstatic int ep93xx_keypad_suspend(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct ep93xx_keypad *keypad = platform_get_drvdata(pdev);\r\nstruct input_dev *input_dev = keypad->input_dev;\r\nmutex_lock(&input_dev->mutex);\r\nif (keypad->enabled) {\r\nclk_disable(keypad->clk);\r\nkeypad->enabled = false;\r\n}\r\nmutex_unlock(&input_dev->mutex);\r\nif (device_may_wakeup(&pdev->dev))\r\nenable_irq_wake(keypad->irq);\r\nreturn 0;\r\n}\r\nstatic int ep93xx_keypad_resume(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct ep93xx_keypad *keypad = platform_get_drvdata(pdev);\r\nstruct input_dev *input_dev = keypad->input_dev;\r\nif (device_may_wakeup(&pdev->dev))\r\ndisable_irq_wake(keypad->irq);\r\nmutex_lock(&input_dev->mutex);\r\nif (input_dev->users) {\r\nif (!keypad->enabled) {\r\nep93xx_keypad_config(keypad);\r\nclk_enable(keypad->clk);\r\nkeypad->enabled = true;\r\n}\r\n}\r\nmutex_unlock(&input_dev->mutex);\r\nreturn 0;\r\n}\r\nstatic int ep93xx_keypad_probe(struct platform_device *pdev)\r\n{\r\nstruct ep93xx_keypad *keypad;\r\nconst struct matrix_keymap_data *keymap_data;\r\nstruct input_dev *input_dev;\r\nstruct resource *res;\r\nint err;\r\nkeypad = kzalloc(sizeof(struct ep93xx_keypad), GFP_KERNEL);\r\nif (!keypad)\r\nreturn -ENOMEM;\r\nkeypad->pdata = pdev->dev.platform_data;\r\nif (!keypad->pdata) {\r\nerr = -EINVAL;\r\ngoto failed_free;\r\n}\r\nkeymap_data = keypad->pdata->keymap_data;\r\nif (!keymap_data) {\r\nerr = -EINVAL;\r\ngoto failed_free;\r\n}\r\nkeypad->irq = platform_get_irq(pdev, 0);\r\nif (!keypad->irq) {\r\nerr = -ENXIO;\r\ngoto failed_free;\r\n}\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!res) {\r\nerr = -ENXIO;\r\ngoto failed_free;\r\n}\r\nres = request_mem_region(res->start, resource_size(res), pdev->name);\r\nif (!res) {\r\nerr = -EBUSY;\r\ngoto failed_free;\r\n}\r\nkeypad->mmio_base = ioremap(res->start, resource_size(res));\r\nif (keypad->mmio_base == NULL) {\r\nerr = -ENXIO;\r\ngoto failed_free_mem;\r\n}\r\nerr = ep93xx_keypad_acquire_gpio(pdev);\r\nif (err)\r\ngoto failed_free_io;\r\nkeypad->clk = clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(keypad->clk)) {\r\nerr = PTR_ERR(keypad->clk);\r\ngoto failed_free_gpio;\r\n}\r\ninput_dev = input_allocate_device();\r\nif (!input_dev) {\r\nerr = -ENOMEM;\r\ngoto failed_put_clk;\r\n}\r\nkeypad->input_dev = input_dev;\r\ninput_dev->name = pdev->name;\r\ninput_dev->id.bustype = BUS_HOST;\r\ninput_dev->open = ep93xx_keypad_open;\r\ninput_dev->close = ep93xx_keypad_close;\r\ninput_dev->dev.parent = &pdev->dev;\r\nerr = matrix_keypad_build_keymap(keymap_data, NULL,\r\nEP93XX_MATRIX_ROWS, EP93XX_MATRIX_COLS,\r\nkeypad->keycodes, input_dev);\r\nif (err)\r\ngoto failed_free_dev;\r\nif (keypad->pdata->flags & EP93XX_KEYPAD_AUTOREPEAT)\r\n__set_bit(EV_REP, input_dev->evbit);\r\ninput_set_drvdata(input_dev, keypad);\r\nerr = request_irq(keypad->irq, ep93xx_keypad_irq_handler,\r\n0, pdev->name, keypad);\r\nif (err)\r\ngoto failed_free_dev;\r\nerr = input_register_device(input_dev);\r\nif (err)\r\ngoto failed_free_irq;\r\nplatform_set_drvdata(pdev, keypad);\r\ndevice_init_wakeup(&pdev->dev, 1);\r\nreturn 0;\r\nfailed_free_irq:\r\nfree_irq(keypad->irq, pdev);\r\nplatform_set_drvdata(pdev, NULL);\r\nfailed_free_dev:\r\ninput_free_device(input_dev);\r\nfailed_put_clk:\r\nclk_put(keypad->clk);\r\nfailed_free_gpio:\r\nep93xx_keypad_release_gpio(pdev);\r\nfailed_free_io:\r\niounmap(keypad->mmio_base);\r\nfailed_free_mem:\r\nrelease_mem_region(res->start, resource_size(res));\r\nfailed_free:\r\nkfree(keypad);\r\nreturn err;\r\n}\r\nstatic int ep93xx_keypad_remove(struct platform_device *pdev)\r\n{\r\nstruct ep93xx_keypad *keypad = platform_get_drvdata(pdev);\r\nstruct resource *res;\r\nfree_irq(keypad->irq, pdev);\r\nplatform_set_drvdata(pdev, NULL);\r\nif (keypad->enabled)\r\nclk_disable(keypad->clk);\r\nclk_put(keypad->clk);\r\ninput_unregister_device(keypad->input_dev);\r\nep93xx_keypad_release_gpio(pdev);\r\niounmap(keypad->mmio_base);\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nrelease_mem_region(res->start, resource_size(res));\r\nkfree(keypad);\r\nreturn 0;\r\n}
