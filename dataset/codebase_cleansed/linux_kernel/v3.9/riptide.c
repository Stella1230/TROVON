static u32 atoh(const unsigned char *in, unsigned int len)\r\n{\r\nu32 sum = 0;\r\nunsigned int mult = 1;\r\nunsigned char c;\r\nwhile (len) {\r\nint value;\r\nc = in[len - 1];\r\nvalue = hex_to_bin(c);\r\nif (value >= 0)\r\nsum += mult * value;\r\nmult *= 16;\r\n--len;\r\n}\r\nreturn sum;\r\n}\r\nstatic int senddata(struct cmdif *cif, const unsigned char *in, u32 offset)\r\n{\r\nu32 addr;\r\nu32 data;\r\nu32 i;\r\nconst unsigned char *p;\r\ni = atoh(&in[1], 2);\r\naddr = offset + atoh(&in[3], 4);\r\nif (SEND_SMEM(cif, 0, addr) != 0)\r\nreturn -EACCES;\r\np = in + 9;\r\nwhile (i) {\r\ndata = atoh(p, 8);\r\nif (SEND_WMEM(cif, 2,\r\n((data & 0x0f0f0f0f) << 4) | ((data & 0xf0f0f0f0)\r\n>> 4)))\r\nreturn -EACCES;\r\ni -= 4;\r\np += 8;\r\n}\r\nreturn 0;\r\n}\r\nstatic int loadfirmware(struct cmdif *cif, const unsigned char *img,\r\nunsigned int size)\r\n{\r\nconst unsigned char *in;\r\nu32 laddr, saddr, t, val;\r\nint err = 0;\r\nladdr = saddr = 0;\r\nwhile (size > 0 && err == 0) {\r\nin = img;\r\nif (in[0] == ':') {\r\nt = atoh(&in[7], 2);\r\nswitch (t) {\r\ncase DATA_REC:\r\nerr = senddata(cif, in, laddr + saddr);\r\nbreak;\r\ncase EXT_SEG_ADDR_REC:\r\nsaddr = atoh(&in[9], 4) << 4;\r\nbreak;\r\ncase EXT_LIN_ADDR_REC:\r\nladdr = atoh(&in[9], 4) << 16;\r\nbreak;\r\ncase EXT_GOTO_CMD_REC:\r\nval = atoh(&in[9], 8);\r\nif (SEND_GOTO(cif, val) != 0)\r\nerr = -EACCES;\r\nbreak;\r\ncase EXT_END_OF_FILE:\r\nsize = 0;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nwhile (size > 0) {\r\nsize--;\r\nif (*img++ == '\n')\r\nbreak;\r\n}\r\n}\r\n}\r\nsnd_printdd("load firmware return %d\n", err);\r\nreturn err;\r\n}\r\nstatic void\r\nalloclbuspath(struct cmdif *cif, unsigned char source,\r\nunsigned char *path, unsigned char *mixer, unsigned char *s)\r\n{\r\nwhile (*path != 0xff) {\r\nunsigned char sink, type;\r\nsink = *path & (~SPLIT_PATH);\r\nif (sink != E2SINK_MAX) {\r\nsnd_printdd("alloc path 0x%x->0x%x\n", source, sink);\r\nSEND_PSEL(cif, source, sink);\r\nsource = lbusin2out[sink][0];\r\ntype = lbusin2out[sink][1];\r\nif (type == LS_MIXER_IN) {\r\nif (mixer)\r\n*mixer = sink - DIGITAL_MIXER_IN0;\r\n}\r\nif (type == LS_SRC_DECIMATORM ||\r\ntype == LS_SRC_DECIMATOR ||\r\ntype == LS_SRC_INTERPOLATORM ||\r\ntype == LS_SRC_INTERPOLATOR) {\r\nif (s) {\r\nif (s[0] != 0xff)\r\ns[1] = sink;\r\nelse\r\ns[0] = sink;\r\n}\r\n}\r\n}\r\nif (*path++ & SPLIT_PATH) {\r\nunsigned char *npath = path;\r\nwhile (*npath != 0xff)\r\nnpath++;\r\nalloclbuspath(cif, source + 1, ++npath, mixer, s);\r\n}\r\n}\r\n}\r\nstatic void\r\nfreelbuspath(struct cmdif *cif, unsigned char source, unsigned char *path)\r\n{\r\nwhile (*path != 0xff) {\r\nunsigned char sink;\r\nsink = *path & (~SPLIT_PATH);\r\nif (sink != E2SINK_MAX) {\r\nsnd_printdd("free path 0x%x->0x%x\n", source, sink);\r\nSEND_PCLR(cif, source, sink);\r\nsource = lbusin2out[sink][0];\r\n}\r\nif (*path++ & SPLIT_PATH) {\r\nunsigned char *npath = path;\r\nwhile (*npath != 0xff)\r\nnpath++;\r\nfreelbuspath(cif, source + 1, ++npath);\r\n}\r\n}\r\n}\r\nstatic int writearm(struct cmdif *cif, u32 addr, u32 data, u32 mask)\r\n{\r\nunion cmdret rptr = CMDRET_ZERO;\r\nunsigned int i = MAX_WRITE_RETRY;\r\nint flag = 1;\r\nSEND_RMEM(cif, 0x02, addr, &rptr);\r\nrptr.retlongs[0] &= (~mask);\r\nwhile (--i) {\r\nSEND_SMEM(cif, 0x01, addr);\r\nSEND_WMEM(cif, 0x02, (rptr.retlongs[0] | data));\r\nSEND_RMEM(cif, 0x02, addr, &rptr);\r\nif ((rptr.retlongs[0] & data) == data) {\r\nflag = 0;\r\nbreak;\r\n} else\r\nrptr.retlongs[0] &= ~mask;\r\n}\r\nsnd_printdd("send arm 0x%x 0x%x 0x%x return %d\n", addr, data, mask,\r\nflag);\r\nreturn flag;\r\n}\r\nstatic int sendcmd(struct cmdif *cif, u32 flags, u32 cmd, u32 parm,\r\nunion cmdret *ret)\r\n{\r\nint i, j;\r\nint err;\r\nunsigned int time = 0;\r\nunsigned long irqflags;\r\nstruct riptideport *hwport;\r\nstruct cmdport *cmdport = NULL;\r\nif (snd_BUG_ON(!cif))\r\nreturn -EINVAL;\r\nhwport = cif->hwport;\r\nif (cif->errcnt > MAX_ERROR_COUNT) {\r\nif (cif->is_reset) {\r\nsnd_printk(KERN_ERR\r\n"Riptide: Too many failed cmds, reinitializing\n");\r\nif (riptide_reset(cif, NULL) == 0) {\r\ncif->errcnt = 0;\r\nreturn -EIO;\r\n}\r\n}\r\nsnd_printk(KERN_ERR "Riptide: Initialization failed.\n");\r\nreturn -EINVAL;\r\n}\r\nif (ret) {\r\nret->retlongs[0] = 0;\r\nret->retlongs[1] = 0;\r\n}\r\ni = 0;\r\nspin_lock_irqsave(&cif->lock, irqflags);\r\nwhile (i++ < CMDIF_TIMEOUT && !IS_READY(cif->hwport))\r\nudelay(10);\r\nif (i > CMDIF_TIMEOUT) {\r\nerr = -EBUSY;\r\ngoto errout;\r\n}\r\nerr = 0;\r\nfor (j = 0, time = 0; time < CMDIF_TIMEOUT; j++, time += 2) {\r\ncmdport = &(hwport->port[j % 2]);\r\nif (IS_DATF(cmdport)) {\r\nREAD_PORT_ULONG(cmdport->data1);\r\nREAD_PORT_ULONG(cmdport->data2);\r\n}\r\nif (IS_CMDE(cmdport)) {\r\nif (flags & PARM)\r\nWRITE_PORT_ULONG(cmdport->data2, parm);\r\nWRITE_PORT_ULONG(cmdport->data1, cmd);\r\nif ((flags & RESP) && ret) {\r\nwhile (!IS_DATF(cmdport) &&\r\ntime < CMDIF_TIMEOUT) {\r\nudelay(10);\r\ntime++;\r\n}\r\nif (time < CMDIF_TIMEOUT) {\r\nret->retlongs[0] =\r\nREAD_PORT_ULONG(cmdport->data1);\r\nret->retlongs[1] =\r\nREAD_PORT_ULONG(cmdport->data2);\r\n} else {\r\nerr = -ENOSYS;\r\ngoto errout;\r\n}\r\n}\r\nbreak;\r\n}\r\nudelay(20);\r\n}\r\nif (time == CMDIF_TIMEOUT) {\r\nerr = -ENODATA;\r\ngoto errout;\r\n}\r\nspin_unlock_irqrestore(&cif->lock, irqflags);\r\ncif->cmdcnt++;\r\ncif->cmdtime += time;\r\nif (time > cif->cmdtimemax)\r\ncif->cmdtimemax = time;\r\nif (time < cif->cmdtimemin)\r\ncif->cmdtimemin = time;\r\nif ((cif->cmdcnt) % 1000 == 0)\r\nsnd_printdd\r\n("send cmd %d time: %d mintime: %d maxtime %d err: %d\n",\r\ncif->cmdcnt, cif->cmdtime, cif->cmdtimemin,\r\ncif->cmdtimemax, cif->errcnt);\r\nreturn 0;\r\nerrout:\r\ncif->errcnt++;\r\nspin_unlock_irqrestore(&cif->lock, irqflags);\r\nsnd_printdd\r\n("send cmd %d hw: 0x%x flag: 0x%x cmd: 0x%x parm: 0x%x ret: 0x%x 0x%x CMDE: %d DATF: %d failed %d\n",\r\ncif->cmdcnt, (int)((void *)&(cmdport->stat) - (void *)hwport),\r\nflags, cmd, parm, ret ? ret->retlongs[0] : 0,\r\nret ? ret->retlongs[1] : 0, IS_CMDE(cmdport), IS_DATF(cmdport),\r\nerr);\r\nreturn err;\r\n}\r\nstatic int\r\nsetmixer(struct cmdif *cif, short num, unsigned short rval, unsigned short lval)\r\n{\r\nunion cmdret rptr = CMDRET_ZERO;\r\nint i = 0;\r\nsnd_printdd("sent mixer %d: 0x%d 0x%d\n", num, rval, lval);\r\ndo {\r\nSEND_SDGV(cif, num, num, rval, lval);\r\nSEND_RDGV(cif, num, num, &rptr);\r\nif (rptr.retwords[0] == lval && rptr.retwords[1] == rval)\r\nreturn 0;\r\n} while (i++ < MAX_WRITE_RETRY);\r\nsnd_printdd("sent mixer failed\n");\r\nreturn -EIO;\r\n}\r\nstatic int getpaths(struct cmdif *cif, unsigned char *o)\r\n{\r\nunsigned char src[E2SINK_MAX];\r\nunsigned char sink[E2SINK_MAX];\r\nint i, j = 0;\r\nfor (i = 0; i < E2SINK_MAX; i++) {\r\ngetsourcesink(cif, i, i, &src[i], &sink[i]);\r\nif (sink[i] < E2SINK_MAX) {\r\no[j++] = sink[i];\r\no[j++] = i;\r\n}\r\n}\r\nreturn j;\r\n}\r\nstatic int\r\ngetsourcesink(struct cmdif *cif, unsigned char source, unsigned char sink,\r\nunsigned char *a, unsigned char *b)\r\n{\r\nunion cmdret rptr = CMDRET_ZERO;\r\nif (SEND_RSSV(cif, source, sink, &rptr) &&\r\nSEND_RSSV(cif, source, sink, &rptr))\r\nreturn -EIO;\r\n*a = rptr.retbytes[0];\r\n*b = rptr.retbytes[1];\r\nsnd_printdd("getsourcesink 0x%x 0x%x\n", *a, *b);\r\nreturn 0;\r\n}\r\nstatic int\r\ngetsamplerate(struct cmdif *cif, unsigned char *intdec, unsigned int *rate)\r\n{\r\nunsigned char *s;\r\nunsigned int p[2] = { 0, 0 };\r\nint i;\r\nunion cmdret rptr = CMDRET_ZERO;\r\ns = intdec;\r\nfor (i = 0; i < 2; i++) {\r\nif (*s != 0xff) {\r\nif (SEND_RSRC(cif, *s, &rptr) &&\r\nSEND_RSRC(cif, *s, &rptr))\r\nreturn -EIO;\r\np[i] += rptr.retwords[1];\r\np[i] *= rptr.retwords[2];\r\np[i] += rptr.retwords[3];\r\np[i] /= 65536;\r\n}\r\ns++;\r\n}\r\nif (p[0]) {\r\nif (p[1] != p[0])\r\nsnd_printdd("rates differ %d %d\n", p[0], p[1]);\r\n*rate = (unsigned int)p[0];\r\n} else\r\n*rate = (unsigned int)p[1];\r\nsnd_printdd("getsampleformat %d %d %d\n", intdec[0], intdec[1], *rate);\r\nreturn 0;\r\n}\r\nstatic int\r\nsetsampleformat(struct cmdif *cif,\r\nunsigned char mixer, unsigned char id,\r\nunsigned char channels, unsigned char format)\r\n{\r\nunsigned char w, ch, sig, order;\r\nsnd_printdd\r\n("setsampleformat mixer: %d id: %d channels: %d format: %d\n",\r\nmixer, id, channels, format);\r\nch = channels == 1;\r\nw = snd_pcm_format_width(format) == 8;\r\nsig = snd_pcm_format_unsigned(format) != 0;\r\norder = snd_pcm_format_big_endian(format) != 0;\r\nif (SEND_SETF(cif, mixer, w, ch, order, sig, id) &&\r\nSEND_SETF(cif, mixer, w, ch, order, sig, id)) {\r\nsnd_printdd("setsampleformat failed\n");\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nsetsamplerate(struct cmdif *cif, unsigned char *intdec, unsigned int rate)\r\n{\r\nu32 D, M, N;\r\nunion cmdret rptr = CMDRET_ZERO;\r\nint i;\r\nsnd_printdd("setsamplerate intdec: %d,%d rate: %d\n", intdec[0],\r\nintdec[1], rate);\r\nD = 48000;\r\nM = ((rate == 48000) ? 47999 : rate) * 65536;\r\nN = M % D;\r\nM /= D;\r\nfor (i = 0; i < 2; i++) {\r\nif (*intdec != 0xff) {\r\ndo {\r\nSEND_SSRC(cif, *intdec, D, M, N);\r\nSEND_RSRC(cif, *intdec, &rptr);\r\n} while (rptr.retwords[1] != D &&\r\nrptr.retwords[2] != M &&\r\nrptr.retwords[3] != N &&\r\ni++ < MAX_WRITE_RETRY);\r\nif (i > MAX_WRITE_RETRY) {\r\nsnd_printdd("sent samplerate %d: %d failed\n",\r\n*intdec, rate);\r\nreturn -EIO;\r\n}\r\n}\r\nintdec++;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\ngetmixer(struct cmdif *cif, short num, unsigned short *rval,\r\nunsigned short *lval)\r\n{\r\nunion cmdret rptr = CMDRET_ZERO;\r\nif (SEND_RDGV(cif, num, num, &rptr) && SEND_RDGV(cif, num, num, &rptr))\r\nreturn -EIO;\r\n*rval = rptr.retwords[0];\r\n*lval = rptr.retwords[1];\r\nsnd_printdd("got mixer %d: 0x%d 0x%d\n", num, *rval, *lval);\r\nreturn 0;\r\n}\r\nstatic void riptide_handleirq(unsigned long dev_id)\r\n{\r\nstruct snd_riptide *chip = (void *)dev_id;\r\nstruct cmdif *cif = chip->cif;\r\nstruct snd_pcm_substream *substream[PLAYBACK_SUBSTREAMS + 1];\r\nstruct snd_pcm_runtime *runtime;\r\nstruct pcmhw *data = NULL;\r\nunsigned int pos, period_bytes;\r\nstruct sgd *c;\r\nint i, j;\r\nunsigned int flag;\r\nif (!cif)\r\nreturn;\r\nfor (i = 0; i < PLAYBACK_SUBSTREAMS; i++)\r\nsubstream[i] = chip->playback_substream[i];\r\nsubstream[i] = chip->capture_substream;\r\nfor (i = 0; i < PLAYBACK_SUBSTREAMS + 1; i++) {\r\nif (substream[i] &&\r\n(runtime = substream[i]->runtime) &&\r\n(data = runtime->private_data) && data->state != ST_STOP) {\r\npos = 0;\r\nfor (j = 0; j < data->pages; j++) {\r\nc = &data->sgdbuf[j];\r\nflag = le32_to_cpu(c->dwStat_Ctl);\r\nif (flag & EOB_STATUS)\r\npos += le32_to_cpu(c->dwSegLen);\r\nif (flag & EOC_STATUS)\r\npos += le32_to_cpu(c->dwSegLen);\r\nif ((flag & EOS_STATUS)\r\n&& (data->state == ST_PLAY)) {\r\ndata->state = ST_STOP;\r\nsnd_printk(KERN_ERR\r\n"Riptide: DMA stopped unexpectedly\n");\r\n}\r\nc->dwStat_Ctl =\r\ncpu_to_le32(flag &\r\n~(EOS_STATUS | EOB_STATUS |\r\nEOC_STATUS));\r\n}\r\ndata->pointer += pos;\r\npos += data->oldpos;\r\nif (data->state != ST_STOP) {\r\nperiod_bytes =\r\nframes_to_bytes(runtime,\r\nruntime->period_size);\r\nsnd_printdd\r\n("interrupt 0x%x after 0x%lx of 0x%lx frames in period\n",\r\nREAD_AUDIO_STATUS(cif->hwport),\r\nbytes_to_frames(runtime, pos),\r\nruntime->period_size);\r\nj = 0;\r\nif (pos >= period_bytes) {\r\nj++;\r\nwhile (pos >= period_bytes)\r\npos -= period_bytes;\r\n}\r\ndata->oldpos = pos;\r\nif (j > 0)\r\nsnd_pcm_period_elapsed(substream[i]);\r\n}\r\n}\r\n}\r\n}\r\nstatic int riptide_suspend(struct device *dev)\r\n{\r\nstruct pci_dev *pci = to_pci_dev(dev);\r\nstruct snd_card *card = dev_get_drvdata(dev);\r\nstruct snd_riptide *chip = card->private_data;\r\nchip->in_suspend = 1;\r\nsnd_power_change_state(card, SNDRV_CTL_POWER_D3hot);\r\nsnd_pcm_suspend_all(chip->pcm);\r\nsnd_ac97_suspend(chip->ac97);\r\npci_disable_device(pci);\r\npci_save_state(pci);\r\npci_set_power_state(pci, PCI_D3hot);\r\nreturn 0;\r\n}\r\nstatic int riptide_resume(struct device *dev)\r\n{\r\nstruct pci_dev *pci = to_pci_dev(dev);\r\nstruct snd_card *card = dev_get_drvdata(dev);\r\nstruct snd_riptide *chip = card->private_data;\r\npci_set_power_state(pci, PCI_D0);\r\npci_restore_state(pci);\r\nif (pci_enable_device(pci) < 0) {\r\nprintk(KERN_ERR "riptide: pci_enable_device failed, "\r\n"disabling device\n");\r\nsnd_card_disconnect(card);\r\nreturn -EIO;\r\n}\r\npci_set_master(pci);\r\nsnd_riptide_initialize(chip);\r\nsnd_ac97_resume(chip->ac97);\r\nsnd_power_change_state(card, SNDRV_CTL_POWER_D0);\r\nchip->in_suspend = 0;\r\nreturn 0;\r\n}\r\nstatic int try_to_load_firmware(struct cmdif *cif, struct snd_riptide *chip)\r\n{\r\nunion firmware_version firmware = { .ret = CMDRET_ZERO };\r\nint i, timeout, err;\r\nfor (i = 0; i < 2; i++) {\r\nWRITE_PORT_ULONG(cif->hwport->port[i].data1, 0);\r\nWRITE_PORT_ULONG(cif->hwport->port[i].data2, 0);\r\n}\r\nSET_GRESET(cif->hwport);\r\nudelay(100);\r\nUNSET_GRESET(cif->hwport);\r\nudelay(100);\r\nfor (timeout = 100000; --timeout; udelay(10)) {\r\nif (IS_READY(cif->hwport) && !IS_GERR(cif->hwport))\r\nbreak;\r\n}\r\nif (!timeout) {\r\nsnd_printk(KERN_ERR\r\n"Riptide: device not ready, audio status: 0x%x "\r\n"ready: %d gerr: %d\n",\r\nREAD_AUDIO_STATUS(cif->hwport),\r\nIS_READY(cif->hwport), IS_GERR(cif->hwport));\r\nreturn -EIO;\r\n} else {\r\nsnd_printdd\r\n("Riptide: audio status: 0x%x ready: %d gerr: %d\n",\r\nREAD_AUDIO_STATUS(cif->hwport),\r\nIS_READY(cif->hwport), IS_GERR(cif->hwport));\r\n}\r\nSEND_GETV(cif, &firmware.ret);\r\nsnd_printdd("Firmware version: ASIC: %d CODEC %d AUXDSP %d PROG %d\n",\r\nfirmware.firmware.ASIC, firmware.firmware.CODEC,\r\nfirmware.firmware.AUXDSP, firmware.firmware.PROG);\r\nif (!chip)\r\nreturn 1;\r\nfor (i = 0; i < FIRMWARE_VERSIONS; i++) {\r\nif (!memcmp(&firmware_versions[i], &firmware, sizeof(firmware)))\r\nreturn 1;\r\n}\r\nsnd_printdd("Writing Firmware\n");\r\nif (!chip->fw_entry) {\r\nerr = request_firmware(&chip->fw_entry, "riptide.hex",\r\n&chip->pci->dev);\r\nif (err) {\r\nsnd_printk(KERN_ERR\r\n"Riptide: Firmware not available %d\n", err);\r\nreturn -EIO;\r\n}\r\n}\r\nerr = loadfirmware(cif, chip->fw_entry->data, chip->fw_entry->size);\r\nif (err) {\r\nsnd_printk(KERN_ERR\r\n"Riptide: Could not load firmware %d\n", err);\r\nreturn err;\r\n}\r\nchip->firmware = firmware;\r\nreturn 1;\r\n}\r\nstatic int riptide_reset(struct cmdif *cif, struct snd_riptide *chip)\r\n{\r\nunion cmdret rptr = CMDRET_ZERO;\r\nint err, tries;\r\nif (!cif)\r\nreturn -EINVAL;\r\ncif->cmdcnt = 0;\r\ncif->cmdtime = 0;\r\ncif->cmdtimemax = 0;\r\ncif->cmdtimemin = 0xffffffff;\r\ncif->errcnt = 0;\r\ncif->is_reset = 0;\r\ntries = RESET_TRIES;\r\ndo {\r\nerr = try_to_load_firmware(cif, chip);\r\nif (err < 0)\r\nreturn err;\r\n} while (!err && --tries);\r\nSEND_SACR(cif, 0, AC97_RESET);\r\nSEND_RACR(cif, AC97_RESET, &rptr);\r\nsnd_printdd("AC97: 0x%x 0x%x\n", rptr.retlongs[0], rptr.retlongs[1]);\r\nSEND_PLST(cif, 0);\r\nSEND_SLST(cif, 0);\r\nSEND_DLST(cif, 0);\r\nSEND_ALST(cif, 0);\r\nSEND_KDMA(cif);\r\nwritearm(cif, 0x301F8, 1, 1);\r\nwritearm(cif, 0x301F4, 1, 1);\r\nSEND_LSEL(cif, MODEM_CMD, 0, 0, MODEM_INTDEC, MODEM_MERGER,\r\nMODEM_SPLITTER, MODEM_MIXER);\r\nsetmixer(cif, MODEM_MIXER, 0x7fff, 0x7fff);\r\nalloclbuspath(cif, ARM2LBUS_FIFO13, lbus_play_modem, NULL, NULL);\r\nSEND_LSEL(cif, FM_CMD, 0, 0, FM_INTDEC, FM_MERGER, FM_SPLITTER,\r\nFM_MIXER);\r\nsetmixer(cif, FM_MIXER, 0x7fff, 0x7fff);\r\nwritearm(cif, 0x30648 + FM_MIXER * 4, 0x01, 0x00000005);\r\nwritearm(cif, 0x301A8, 0x02, 0x00000002);\r\nwritearm(cif, 0x30264, 0x08, 0xffffffff);\r\nalloclbuspath(cif, OPL3_SAMPLE, lbus_play_opl3, NULL, NULL);\r\nSEND_SSRC(cif, I2S_INTDEC, 48000,\r\n((u32) I2S_RATE * 65536) / 48000,\r\n((u32) I2S_RATE * 65536) % 48000);\r\nSEND_LSEL(cif, I2S_CMD0, 0, 0, I2S_INTDEC, I2S_MERGER, I2S_SPLITTER,\r\nI2S_MIXER);\r\nSEND_SI2S(cif, 1);\r\nalloclbuspath(cif, ARM2LBUS_FIFO0, lbus_play_i2s, NULL, NULL);\r\nalloclbuspath(cif, DIGITAL_MIXER_OUT0, lbus_play_out, NULL, NULL);\r\nalloclbuspath(cif, DIGITAL_MIXER_OUT0, lbus_play_outhp, NULL, NULL);\r\nSET_AIACK(cif->hwport);\r\nSET_AIE(cif->hwport);\r\nSET_AIACK(cif->hwport);\r\ncif->is_reset = 1;\r\nreturn 0;\r\n}\r\nstatic snd_pcm_uframes_t snd_riptide_pointer(struct snd_pcm_substream\r\n*substream)\r\n{\r\nstruct snd_riptide *chip = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct pcmhw *data = get_pcmhwdev(substream);\r\nstruct cmdif *cif = chip->cif;\r\nunion cmdret rptr = CMDRET_ZERO;\r\nsnd_pcm_uframes_t ret;\r\nSEND_GPOS(cif, 0, data->id, &rptr);\r\nif (data->size && runtime->period_size) {\r\nsnd_printdd\r\n("pointer stream %d position 0x%x(0x%x in buffer) bytes 0x%lx(0x%lx in period) frames\n",\r\ndata->id, rptr.retlongs[1], rptr.retlongs[1] % data->size,\r\nbytes_to_frames(runtime, rptr.retlongs[1]),\r\nbytes_to_frames(runtime,\r\nrptr.retlongs[1]) % runtime->period_size);\r\nif (rptr.retlongs[1] > data->pointer)\r\nret =\r\nbytes_to_frames(runtime,\r\nrptr.retlongs[1] % data->size);\r\nelse\r\nret =\r\nbytes_to_frames(runtime,\r\ndata->pointer % data->size);\r\n} else {\r\nsnd_printdd("stream not started or strange parms (%d %ld)\n",\r\ndata->size, runtime->period_size);\r\nret = bytes_to_frames(runtime, 0);\r\n}\r\nreturn ret;\r\n}\r\nstatic int snd_riptide_trigger(struct snd_pcm_substream *substream, int cmd)\r\n{\r\nint i, j;\r\nstruct snd_riptide *chip = snd_pcm_substream_chip(substream);\r\nstruct pcmhw *data = get_pcmhwdev(substream);\r\nstruct cmdif *cif = chip->cif;\r\nunion cmdret rptr = CMDRET_ZERO;\r\nspin_lock(&chip->lock);\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\ncase SNDRV_PCM_TRIGGER_RESUME:\r\nif (!(data->state & ST_PLAY)) {\r\nSEND_SSTR(cif, data->id, data->sgdlist.addr);\r\nSET_AIE(cif->hwport);\r\ndata->state = ST_PLAY;\r\nif (data->mixer != 0xff)\r\nsetmixer(cif, data->mixer, 0x7fff, 0x7fff);\r\nchip->openstreams++;\r\ndata->oldpos = 0;\r\ndata->pointer = 0;\r\n}\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\ncase SNDRV_PCM_TRIGGER_SUSPEND:\r\nif (data->mixer != 0xff)\r\nsetmixer(cif, data->mixer, 0, 0);\r\nsetmixer(cif, data->mixer, 0, 0);\r\nSEND_KSTR(cif, data->id);\r\ndata->state = ST_STOP;\r\nchip->openstreams--;\r\nj = 0;\r\ndo {\r\ni = rptr.retlongs[1];\r\nSEND_GPOS(cif, 0, data->id, &rptr);\r\nudelay(1);\r\n} while (i != rptr.retlongs[1] && j++ < MAX_WRITE_RETRY);\r\nif (j > MAX_WRITE_RETRY)\r\nsnd_printk(KERN_ERR "Riptide: Could not stop stream!");\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\r\nif (!(data->state & ST_PAUSE)) {\r\nSEND_PSTR(cif, data->id);\r\ndata->state |= ST_PAUSE;\r\nchip->openstreams--;\r\n}\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\r\nif (data->state & ST_PAUSE) {\r\nSEND_SSTR(cif, data->id, data->sgdlist.addr);\r\ndata->state &= ~ST_PAUSE;\r\nchip->openstreams++;\r\n}\r\nbreak;\r\ndefault:\r\nspin_unlock(&chip->lock);\r\nreturn -EINVAL;\r\n}\r\nspin_unlock(&chip->lock);\r\nreturn 0;\r\n}\r\nstatic int snd_riptide_prepare(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_riptide *chip = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct pcmhw *data = get_pcmhwdev(substream);\r\nstruct cmdif *cif = chip->cif;\r\nunsigned char *lbuspath = NULL;\r\nunsigned int rate, channels;\r\nint err = 0;\r\nsnd_pcm_format_t format;\r\nif (snd_BUG_ON(!cif || !data))\r\nreturn -EINVAL;\r\nsnd_printdd("prepare id %d ch: %d f:0x%x r:%d\n", data->id,\r\nruntime->channels, runtime->format, runtime->rate);\r\nspin_lock_irq(&chip->lock);\r\nchannels = runtime->channels;\r\nformat = runtime->format;\r\nrate = runtime->rate;\r\nswitch (channels) {\r\ncase 1:\r\nif (rate == 48000 && format == SNDRV_PCM_FORMAT_S16_LE)\r\nlbuspath = data->paths.noconv;\r\nelse\r\nlbuspath = data->paths.mono;\r\nbreak;\r\ncase 2:\r\nif (rate == 48000 && format == SNDRV_PCM_FORMAT_S16_LE)\r\nlbuspath = data->paths.noconv;\r\nelse\r\nlbuspath = data->paths.stereo;\r\nbreak;\r\n}\r\nsnd_printdd("use sgdlist at 0x%p\n",\r\ndata->sgdlist.area);\r\nif (data->sgdlist.area) {\r\nunsigned int i, j, size, pages, f, pt, period;\r\nstruct sgd *c, *p = NULL;\r\nsize = frames_to_bytes(runtime, runtime->buffer_size);\r\nperiod = frames_to_bytes(runtime, runtime->period_size);\r\nf = PAGE_SIZE;\r\nwhile ((size + (f >> 1) - 1) <= (f << 7) && (f << 1) > period)\r\nf = f >> 1;\r\npages = (size + f - 1) / f;\r\ndata->size = size;\r\ndata->pages = pages;\r\nsnd_printdd\r\n("create sgd size: 0x%x pages %d of size 0x%x for period 0x%x\n",\r\nsize, pages, f, period);\r\npt = 0;\r\nj = 0;\r\nfor (i = 0; i < pages; i++) {\r\nunsigned int ofs, addr;\r\nc = &data->sgdbuf[i];\r\nif (p)\r\np->dwNextLink = cpu_to_le32(data->sgdlist.addr +\r\n(i *\r\nsizeof(struct\r\nsgd)));\r\nc->dwNextLink = cpu_to_le32(data->sgdlist.addr);\r\nofs = j << PAGE_SHIFT;\r\naddr = snd_pcm_sgbuf_get_addr(substream, ofs) + pt;\r\nc->dwSegPtrPhys = cpu_to_le32(addr);\r\npt = (pt + f) % PAGE_SIZE;\r\nif (pt == 0)\r\nj++;\r\nc->dwSegLen = cpu_to_le32(f);\r\nc->dwStat_Ctl =\r\ncpu_to_le32(IEOB_ENABLE | IEOS_ENABLE |\r\nIEOC_ENABLE);\r\np = c;\r\nsize -= f;\r\n}\r\ndata->sgdbuf[i].dwSegLen = cpu_to_le32(size);\r\n}\r\nif (lbuspath && lbuspath != data->lbuspath) {\r\nif (data->lbuspath)\r\nfreelbuspath(cif, data->source, data->lbuspath);\r\nalloclbuspath(cif, data->source, lbuspath,\r\n&data->mixer, data->intdec);\r\ndata->lbuspath = lbuspath;\r\ndata->rate = 0;\r\n}\r\nif (data->rate != rate || data->format != format ||\r\ndata->channels != channels) {\r\ndata->rate = rate;\r\ndata->format = format;\r\ndata->channels = channels;\r\nif (setsampleformat\r\n(cif, data->mixer, data->id, channels, format)\r\n|| setsamplerate(cif, data->intdec, rate))\r\nerr = -EIO;\r\n}\r\nspin_unlock_irq(&chip->lock);\r\nreturn err;\r\n}\r\nstatic int\r\nsnd_riptide_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *hw_params)\r\n{\r\nstruct snd_riptide *chip = snd_pcm_substream_chip(substream);\r\nstruct pcmhw *data = get_pcmhwdev(substream);\r\nstruct snd_dma_buffer *sgdlist = &data->sgdlist;\r\nint err;\r\nsnd_printdd("hw params id %d (sgdlist: 0x%p 0x%lx %d)\n", data->id,\r\nsgdlist->area, (unsigned long)sgdlist->addr,\r\n(int)sgdlist->bytes);\r\nif (sgdlist->area)\r\nsnd_dma_free_pages(sgdlist);\r\nif ((err = snd_dma_alloc_pages(SNDRV_DMA_TYPE_DEV,\r\nsnd_dma_pci_data(chip->pci),\r\nsizeof(struct sgd) * (DESC_MAX_MASK + 1),\r\nsgdlist)) < 0) {\r\nsnd_printk(KERN_ERR "Riptide: failed to alloc %d dma bytes\n",\r\n(int)sizeof(struct sgd) * (DESC_MAX_MASK + 1));\r\nreturn err;\r\n}\r\ndata->sgdbuf = (struct sgd *)sgdlist->area;\r\nreturn snd_pcm_lib_malloc_pages(substream,\r\nparams_buffer_bytes(hw_params));\r\n}\r\nstatic int snd_riptide_hw_free(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_riptide *chip = snd_pcm_substream_chip(substream);\r\nstruct pcmhw *data = get_pcmhwdev(substream);\r\nstruct cmdif *cif = chip->cif;\r\nif (cif && data) {\r\nif (data->lbuspath)\r\nfreelbuspath(cif, data->source, data->lbuspath);\r\ndata->lbuspath = NULL;\r\ndata->source = 0xff;\r\ndata->intdec[0] = 0xff;\r\ndata->intdec[1] = 0xff;\r\nif (data->sgdlist.area) {\r\nsnd_dma_free_pages(&data->sgdlist);\r\ndata->sgdlist.area = NULL;\r\n}\r\n}\r\nreturn snd_pcm_lib_free_pages(substream);\r\n}\r\nstatic int snd_riptide_playback_open(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_riptide *chip = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct pcmhw *data;\r\nint sub_num = substream->number;\r\nchip->playback_substream[sub_num] = substream;\r\nruntime->hw = snd_riptide_playback;\r\ndata = kzalloc(sizeof(struct pcmhw), GFP_KERNEL);\r\nif (data == NULL)\r\nreturn -ENOMEM;\r\ndata->paths = lbus_play_paths[sub_num];\r\ndata->id = play_ids[sub_num];\r\ndata->source = play_sources[sub_num];\r\ndata->intdec[0] = 0xff;\r\ndata->intdec[1] = 0xff;\r\ndata->state = ST_STOP;\r\nruntime->private_data = data;\r\nreturn snd_pcm_hw_constraint_integer(runtime,\r\nSNDRV_PCM_HW_PARAM_PERIODS);\r\n}\r\nstatic int snd_riptide_capture_open(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_riptide *chip = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct pcmhw *data;\r\nchip->capture_substream = substream;\r\nruntime->hw = snd_riptide_capture;\r\ndata = kzalloc(sizeof(struct pcmhw), GFP_KERNEL);\r\nif (data == NULL)\r\nreturn -ENOMEM;\r\ndata->paths = lbus_rec_path;\r\ndata->id = PADC;\r\ndata->source = ACLNK2PADC;\r\ndata->intdec[0] = 0xff;\r\ndata->intdec[1] = 0xff;\r\ndata->state = ST_STOP;\r\nruntime->private_data = data;\r\nreturn snd_pcm_hw_constraint_integer(runtime,\r\nSNDRV_PCM_HW_PARAM_PERIODS);\r\n}\r\nstatic int snd_riptide_playback_close(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_riptide *chip = snd_pcm_substream_chip(substream);\r\nstruct pcmhw *data = get_pcmhwdev(substream);\r\nint sub_num = substream->number;\r\nsubstream->runtime->private_data = NULL;\r\nchip->playback_substream[sub_num] = NULL;\r\nkfree(data);\r\nreturn 0;\r\n}\r\nstatic int snd_riptide_capture_close(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_riptide *chip = snd_pcm_substream_chip(substream);\r\nstruct pcmhw *data = get_pcmhwdev(substream);\r\nsubstream->runtime->private_data = NULL;\r\nchip->capture_substream = NULL;\r\nkfree(data);\r\nreturn 0;\r\n}\r\nstatic int\r\nsnd_riptide_pcm(struct snd_riptide *chip, int device, struct snd_pcm **rpcm)\r\n{\r\nstruct snd_pcm *pcm;\r\nint err;\r\nif (rpcm)\r\n*rpcm = NULL;\r\nif ((err =\r\nsnd_pcm_new(chip->card, "RIPTIDE", device, PLAYBACK_SUBSTREAMS, 1,\r\n&pcm)) < 0)\r\nreturn err;\r\nsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK,\r\n&snd_riptide_playback_ops);\r\nsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE,\r\n&snd_riptide_capture_ops);\r\npcm->private_data = chip;\r\npcm->info_flags = 0;\r\nstrcpy(pcm->name, "RIPTIDE");\r\nchip->pcm = pcm;\r\nsnd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_DEV_SG,\r\nsnd_dma_pci_data(chip->pci),\r\n64 * 1024, 128 * 1024);\r\nif (rpcm)\r\n*rpcm = pcm;\r\nreturn 0;\r\n}\r\nstatic irqreturn_t\r\nsnd_riptide_interrupt(int irq, void *dev_id)\r\n{\r\nstruct snd_riptide *chip = dev_id;\r\nstruct cmdif *cif = chip->cif;\r\nif (cif) {\r\nchip->received_irqs++;\r\nif (IS_EOBIRQ(cif->hwport) || IS_EOSIRQ(cif->hwport) ||\r\nIS_EOCIRQ(cif->hwport)) {\r\nchip->handled_irqs++;\r\ntasklet_schedule(&chip->riptide_tq);\r\n}\r\nif (chip->rmidi && IS_MPUIRQ(cif->hwport)) {\r\nchip->handled_irqs++;\r\nsnd_mpu401_uart_interrupt(irq,\r\nchip->rmidi->private_data);\r\n}\r\nSET_AIACK(cif->hwport);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void\r\nsnd_riptide_codec_write(struct snd_ac97 *ac97, unsigned short reg,\r\nunsigned short val)\r\n{\r\nstruct snd_riptide *chip = ac97->private_data;\r\nstruct cmdif *cif = chip->cif;\r\nunion cmdret rptr = CMDRET_ZERO;\r\nint i = 0;\r\nif (snd_BUG_ON(!cif))\r\nreturn;\r\nsnd_printdd("Write AC97 reg 0x%x 0x%x\n", reg, val);\r\ndo {\r\nSEND_SACR(cif, val, reg);\r\nSEND_RACR(cif, reg, &rptr);\r\n} while (rptr.retwords[1] != val && i++ < MAX_WRITE_RETRY);\r\nif (i > MAX_WRITE_RETRY)\r\nsnd_printdd("Write AC97 reg failed\n");\r\n}\r\nstatic unsigned short snd_riptide_codec_read(struct snd_ac97 *ac97,\r\nunsigned short reg)\r\n{\r\nstruct snd_riptide *chip = ac97->private_data;\r\nstruct cmdif *cif = chip->cif;\r\nunion cmdret rptr = CMDRET_ZERO;\r\nif (snd_BUG_ON(!cif))\r\nreturn 0;\r\nif (SEND_RACR(cif, reg, &rptr) != 0)\r\nSEND_RACR(cif, reg, &rptr);\r\nsnd_printdd("Read AC97 reg 0x%x got 0x%x\n", reg, rptr.retwords[1]);\r\nreturn rptr.retwords[1];\r\n}\r\nstatic int snd_riptide_initialize(struct snd_riptide *chip)\r\n{\r\nstruct cmdif *cif;\r\nunsigned int device_id;\r\nint err;\r\nif (snd_BUG_ON(!chip))\r\nreturn -EINVAL;\r\ncif = chip->cif;\r\nif (!cif) {\r\nif ((cif = kzalloc(sizeof(struct cmdif), GFP_KERNEL)) == NULL)\r\nreturn -ENOMEM;\r\ncif->hwport = (struct riptideport *)chip->port;\r\nspin_lock_init(&cif->lock);\r\nchip->cif = cif;\r\n}\r\ncif->is_reset = 0;\r\nif ((err = riptide_reset(cif, chip)) != 0)\r\nreturn err;\r\ndevice_id = chip->device_id;\r\nswitch (device_id) {\r\ncase 0x4310:\r\ncase 0x4320:\r\ncase 0x4330:\r\nsnd_printdd("Modem enable?\n");\r\nSEND_SETDPLL(cif);\r\nbreak;\r\n}\r\nsnd_printdd("Enabling MPU IRQs\n");\r\nif (chip->rmidi)\r\nSET_EMPUIRQ(cif->hwport);\r\nreturn err;\r\n}\r\nstatic int snd_riptide_free(struct snd_riptide *chip)\r\n{\r\nstruct cmdif *cif;\r\nif (!chip)\r\nreturn 0;\r\nif ((cif = chip->cif)) {\r\nSET_GRESET(cif->hwport);\r\nudelay(100);\r\nUNSET_GRESET(cif->hwport);\r\nkfree(chip->cif);\r\n}\r\nif (chip->irq >= 0)\r\nfree_irq(chip->irq, chip);\r\nrelease_firmware(chip->fw_entry);\r\nrelease_and_free_resource(chip->res_port);\r\nkfree(chip);\r\nreturn 0;\r\n}\r\nstatic int snd_riptide_dev_free(struct snd_device *device)\r\n{\r\nstruct snd_riptide *chip = device->device_data;\r\nreturn snd_riptide_free(chip);\r\n}\r\nstatic int\r\nsnd_riptide_create(struct snd_card *card, struct pci_dev *pci,\r\nstruct snd_riptide **rchip)\r\n{\r\nstruct snd_riptide *chip;\r\nstruct riptideport *hwport;\r\nint err;\r\nstatic struct snd_device_ops ops = {\r\n.dev_free = snd_riptide_dev_free,\r\n};\r\n*rchip = NULL;\r\nif ((err = pci_enable_device(pci)) < 0)\r\nreturn err;\r\nif (!(chip = kzalloc(sizeof(struct snd_riptide), GFP_KERNEL)))\r\nreturn -ENOMEM;\r\nspin_lock_init(&chip->lock);\r\nchip->card = card;\r\nchip->pci = pci;\r\nchip->irq = -1;\r\nchip->openstreams = 0;\r\nchip->port = pci_resource_start(pci, 0);\r\nchip->received_irqs = 0;\r\nchip->handled_irqs = 0;\r\nchip->cif = NULL;\r\ntasklet_init(&chip->riptide_tq, riptide_handleirq, (unsigned long)chip);\r\nif ((chip->res_port =\r\nrequest_region(chip->port, 64, "RIPTIDE")) == NULL) {\r\nsnd_printk(KERN_ERR\r\n"Riptide: unable to grab region 0x%lx-0x%lx\n",\r\nchip->port, chip->port + 64 - 1);\r\nsnd_riptide_free(chip);\r\nreturn -EBUSY;\r\n}\r\nhwport = (struct riptideport *)chip->port;\r\nUNSET_AIE(hwport);\r\nif (request_irq(pci->irq, snd_riptide_interrupt, IRQF_SHARED,\r\nKBUILD_MODNAME, chip)) {\r\nsnd_printk(KERN_ERR "Riptide: unable to grab IRQ %d\n",\r\npci->irq);\r\nsnd_riptide_free(chip);\r\nreturn -EBUSY;\r\n}\r\nchip->irq = pci->irq;\r\nchip->device_id = pci->device;\r\npci_set_master(pci);\r\nif ((err = snd_riptide_initialize(chip)) < 0) {\r\nsnd_riptide_free(chip);\r\nreturn err;\r\n}\r\nif ((err = snd_device_new(card, SNDRV_DEV_LOWLEVEL, chip, &ops)) < 0) {\r\nsnd_riptide_free(chip);\r\nreturn err;\r\n}\r\nsnd_card_set_dev(card, &pci->dev);\r\n*rchip = chip;\r\nreturn 0;\r\n}\r\nstatic void\r\nsnd_riptide_proc_read(struct snd_info_entry *entry,\r\nstruct snd_info_buffer *buffer)\r\n{\r\nstruct snd_riptide *chip = entry->private_data;\r\nstruct pcmhw *data;\r\nint i;\r\nstruct cmdif *cif = NULL;\r\nunsigned char p[256];\r\nunsigned short rval = 0, lval = 0;\r\nunsigned int rate;\r\nif (!chip)\r\nreturn;\r\nsnd_iprintf(buffer, "%s\n\n", chip->card->longname);\r\nsnd_iprintf(buffer, "Device ID: 0x%x\nReceived IRQs: (%ld)%ld\nPorts:",\r\nchip->device_id, chip->handled_irqs, chip->received_irqs);\r\nfor (i = 0; i < 64; i += 4)\r\nsnd_iprintf(buffer, "%c%02x: %08x",\r\n(i % 16) ? ' ' : '\n', i, inl(chip->port + i));\r\nif ((cif = chip->cif)) {\r\nsnd_iprintf(buffer,\r\n"\nVersion: ASIC: %d CODEC: %d AUXDSP: %d PROG: %d",\r\nchip->firmware.firmware.ASIC,\r\nchip->firmware.firmware.CODEC,\r\nchip->firmware.firmware.AUXDSP,\r\nchip->firmware.firmware.PROG);\r\nsnd_iprintf(buffer, "\nDigital mixer:");\r\nfor (i = 0; i < 12; i++) {\r\ngetmixer(cif, i, &rval, &lval);\r\nsnd_iprintf(buffer, "\n %d: %d %d", i, rval, lval);\r\n}\r\nsnd_iprintf(buffer,\r\n"\nARM Commands num: %d failed: %d time: %d max: %d min: %d",\r\ncif->cmdcnt, cif->errcnt,\r\ncif->cmdtime, cif->cmdtimemax, cif->cmdtimemin);\r\n}\r\nsnd_iprintf(buffer, "\nOpen streams %d:\n", chip->openstreams);\r\nfor (i = 0; i < PLAYBACK_SUBSTREAMS; i++) {\r\nif (chip->playback_substream[i]\r\n&& chip->playback_substream[i]->runtime\r\n&& (data =\r\nchip->playback_substream[i]->runtime->private_data)) {\r\nsnd_iprintf(buffer,\r\n"stream: %d mixer: %d source: %d (%d,%d)\n",\r\ndata->id, data->mixer, data->source,\r\ndata->intdec[0], data->intdec[1]);\r\nif (!(getsamplerate(cif, data->intdec, &rate)))\r\nsnd_iprintf(buffer, "rate: %d\n", rate);\r\n}\r\n}\r\nif (chip->capture_substream\r\n&& chip->capture_substream->runtime\r\n&& (data = chip->capture_substream->runtime->private_data)) {\r\nsnd_iprintf(buffer,\r\n"stream: %d mixer: %d source: %d (%d,%d)\n",\r\ndata->id, data->mixer,\r\ndata->source, data->intdec[0], data->intdec[1]);\r\nif (!(getsamplerate(cif, data->intdec, &rate)))\r\nsnd_iprintf(buffer, "rate: %d\n", rate);\r\n}\r\nsnd_iprintf(buffer, "Paths:\n");\r\ni = getpaths(cif, p);\r\nwhile (i >= 2) {\r\ni -= 2;\r\nsnd_iprintf(buffer, "%x->%x ", p[i], p[i + 1]);\r\n}\r\nsnd_iprintf(buffer, "\n");\r\n}\r\nstatic void snd_riptide_proc_init(struct snd_riptide *chip)\r\n{\r\nstruct snd_info_entry *entry;\r\nif (!snd_card_proc_new(chip->card, "riptide", &entry))\r\nsnd_info_set_text_ops(entry, chip, snd_riptide_proc_read);\r\n}\r\nstatic int snd_riptide_mixer(struct snd_riptide *chip)\r\n{\r\nstruct snd_ac97_bus *pbus;\r\nstruct snd_ac97_template ac97;\r\nint err = 0;\r\nstatic struct snd_ac97_bus_ops ops = {\r\n.write = snd_riptide_codec_write,\r\n.read = snd_riptide_codec_read,\r\n};\r\nmemset(&ac97, 0, sizeof(ac97));\r\nac97.private_data = chip;\r\nac97.scaps = AC97_SCAP_SKIP_MODEM;\r\nif ((err = snd_ac97_bus(chip->card, 0, &ops, chip, &pbus)) < 0)\r\nreturn err;\r\nchip->ac97_bus = pbus;\r\nac97.pci = chip->pci;\r\nif ((err = snd_ac97_mixer(pbus, &ac97, &chip->ac97)) < 0)\r\nreturn err;\r\nreturn err;\r\n}\r\nstatic int\r\nsnd_riptide_joystick_probe(struct pci_dev *pci, const struct pci_device_id *id)\r\n{\r\nstatic int dev;\r\nstruct gameport *gameport;\r\nif (dev >= SNDRV_CARDS)\r\nreturn -ENODEV;\r\nif (!enable[dev]) {\r\ndev++;\r\nreturn -ENOENT;\r\n}\r\nif (!joystick_port[dev++])\r\nreturn 0;\r\ngameport = gameport_allocate_port();\r\nif (!gameport)\r\nreturn -ENOMEM;\r\nif (!request_region(joystick_port[dev], 8, "Riptide gameport")) {\r\nsnd_printk(KERN_WARNING\r\n"Riptide: cannot grab gameport 0x%x\n",\r\njoystick_port[dev]);\r\ngameport_free_port(gameport);\r\nreturn -EBUSY;\r\n}\r\ngameport->io = joystick_port[dev];\r\ngameport_register_port(gameport);\r\npci_set_drvdata(pci, gameport);\r\nreturn 0;\r\n}\r\nstatic void snd_riptide_joystick_remove(struct pci_dev *pci)\r\n{\r\nstruct gameport *gameport = pci_get_drvdata(pci);\r\nif (gameport) {\r\nrelease_region(gameport->io, 8);\r\ngameport_unregister_port(gameport);\r\npci_set_drvdata(pci, NULL);\r\n}\r\n}\r\nstatic int\r\nsnd_card_riptide_probe(struct pci_dev *pci, const struct pci_device_id *pci_id)\r\n{\r\nstatic int dev;\r\nstruct snd_card *card;\r\nstruct snd_riptide *chip;\r\nunsigned short val;\r\nint err;\r\nif (dev >= SNDRV_CARDS)\r\nreturn -ENODEV;\r\nif (!enable[dev]) {\r\ndev++;\r\nreturn -ENOENT;\r\n}\r\nerr = snd_card_create(index[dev], id[dev], THIS_MODULE, 0, &card);\r\nif (err < 0)\r\nreturn err;\r\nerr = snd_riptide_create(card, pci, &chip);\r\nif (err < 0)\r\ngoto error;\r\ncard->private_data = chip;\r\nerr = snd_riptide_pcm(chip, 0, NULL);\r\nif (err < 0)\r\ngoto error;\r\nerr = snd_riptide_mixer(chip);\r\nif (err < 0)\r\ngoto error;\r\nval = LEGACY_ENABLE_ALL;\r\nif (opl3_port[dev])\r\nval |= LEGACY_ENABLE_FM;\r\n#ifdef SUPPORT_JOYSTICK\r\nif (joystick_port[dev])\r\nval |= LEGACY_ENABLE_GAMEPORT;\r\n#endif\r\nif (mpu_port[dev])\r\nval |= LEGACY_ENABLE_MPU_INT | LEGACY_ENABLE_MPU;\r\nval |= (chip->irq << 4) & 0xf0;\r\npci_write_config_word(chip->pci, PCI_EXT_Legacy_Mask, val);\r\nif (mpu_port[dev]) {\r\nval = mpu_port[dev];\r\npci_write_config_word(chip->pci, PCI_EXT_MPU_Base, val);\r\nerr = snd_mpu401_uart_new(card, 0, MPU401_HW_RIPTIDE,\r\nval, MPU401_INFO_IRQ_HOOK, -1,\r\n&chip->rmidi);\r\nif (err < 0)\r\nsnd_printk(KERN_WARNING\r\n"Riptide: Can't Allocate MPU at 0x%x\n",\r\nval);\r\nelse\r\nchip->mpuaddr = val;\r\n}\r\nif (opl3_port[dev]) {\r\nval = opl3_port[dev];\r\npci_write_config_word(chip->pci, PCI_EXT_FM_Base, val);\r\nerr = snd_opl3_create(card, val, val + 2,\r\nOPL3_HW_RIPTIDE, 0, &chip->opl3);\r\nif (err < 0)\r\nsnd_printk(KERN_WARNING\r\n"Riptide: Can't Allocate OPL3 at 0x%x\n",\r\nval);\r\nelse {\r\nchip->opladdr = val;\r\nerr = snd_opl3_hwdep_new(chip->opl3, 0, 1, NULL);\r\nif (err < 0)\r\nsnd_printk(KERN_WARNING\r\n"Riptide: Can't Allocate OPL3-HWDEP\n");\r\n}\r\n}\r\n#ifdef SUPPORT_JOYSTICK\r\nif (joystick_port[dev]) {\r\nval = joystick_port[dev];\r\npci_write_config_word(chip->pci, PCI_EXT_Game_Base, val);\r\nchip->gameaddr = val;\r\n}\r\n#endif\r\nstrcpy(card->driver, "RIPTIDE");\r\nstrcpy(card->shortname, "Riptide");\r\n#ifdef SUPPORT_JOYSTICK\r\nsnprintf(card->longname, sizeof(card->longname),\r\n"%s at 0x%lx, irq %i mpu 0x%x opl3 0x%x gameport 0x%x",\r\ncard->shortname, chip->port, chip->irq, chip->mpuaddr,\r\nchip->opladdr, chip->gameaddr);\r\n#else\r\nsnprintf(card->longname, sizeof(card->longname),\r\n"%s at 0x%lx, irq %i mpu 0x%x opl3 0x%x",\r\ncard->shortname, chip->port, chip->irq, chip->mpuaddr,\r\nchip->opladdr);\r\n#endif\r\nsnd_riptide_proc_init(chip);\r\nerr = snd_card_register(card);\r\nif (err < 0)\r\ngoto error;\r\npci_set_drvdata(pci, card);\r\ndev++;\r\nreturn 0;\r\nerror:\r\nsnd_card_free(card);\r\nreturn err;\r\n}\r\nstatic void snd_card_riptide_remove(struct pci_dev *pci)\r\n{\r\nsnd_card_free(pci_get_drvdata(pci));\r\npci_set_drvdata(pci, NULL);\r\n}\r\nstatic int __init alsa_card_riptide_init(void)\r\n{\r\nint err;\r\nerr = pci_register_driver(&driver);\r\nif (err < 0)\r\nreturn err;\r\n#if defined(SUPPORT_JOYSTICK)\r\nerr = pci_register_driver(&joystick_driver);\r\nif (err < 0)\r\npci_unregister_driver(&driver);\r\n#endif\r\nreturn err;\r\n}\r\nstatic void __exit alsa_card_riptide_exit(void)\r\n{\r\npci_unregister_driver(&driver);\r\n#if defined(SUPPORT_JOYSTICK)\r\npci_unregister_driver(&joystick_driver);\r\n#endif\r\n}
