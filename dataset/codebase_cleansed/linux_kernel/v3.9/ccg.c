static void ccg_work(struct work_struct *data)\r\n{\r\nstruct ccg_dev *dev = container_of(data, struct ccg_dev, work);\r\nstruct usb_composite_dev *cdev = dev->cdev;\r\nstatic char *disconnected[2] = { "USB_STATE=DISCONNECTED", NULL };\r\nstatic char *connected[2] = { "USB_STATE=CONNECTED", NULL };\r\nstatic char *configured[2] = { "USB_STATE=CONFIGURED", NULL };\r\nchar **uevent_envp = NULL;\r\nunsigned long flags;\r\nspin_lock_irqsave(&cdev->lock, flags);\r\nif (cdev->config)\r\nuevent_envp = configured;\r\nelse if (dev->connected != dev->sw_connected)\r\nuevent_envp = dev->connected ? connected : disconnected;\r\ndev->sw_connected = dev->connected;\r\nspin_unlock_irqrestore(&cdev->lock, flags);\r\nif (uevent_envp) {\r\nkobject_uevent_env(&dev->dev->kobj, KOBJ_CHANGE, uevent_envp);\r\npr_info("%s: sent uevent %s\n", __func__, uevent_envp[0]);\r\n} else {\r\npr_info("%s: did not send uevent (%d %d %p)\n", __func__,\r\ndev->connected, dev->sw_connected, cdev->config);\r\n}\r\n}\r\nstatic struct ffs_obj *functionfs_find_dev(struct ccg_dev *dev,\r\nconst char *dev_name)\r\n{\r\nint i;\r\nfor (i = 0; i < dev->max_func_num; i++)\r\nif (strcmp(dev->ffs_tab[i].name, dev_name) == 0)\r\nreturn &dev->ffs_tab[i];\r\nreturn NULL;\r\n}\r\nstatic bool functionfs_all_ready(struct ccg_dev *dev)\r\n{\r\nint i;\r\nfor (i = 0; i < dev->max_func_num; i++)\r\nif (dev->ffs_tab[i].used && !dev->ffs_tab[i].desc_ready)\r\nreturn false;\r\nreturn true;\r\n}\r\nstatic int functionfs_ready_callback(struct ffs_data *ffs)\r\n{\r\nstruct ffs_obj *ffs_obj;\r\nint ret;\r\nmutex_lock(&_ccg_dev->mutex);\r\nffs_obj = ffs->private_data;\r\nif (!ffs_obj) {\r\nret = -EINVAL;\r\ngoto done;\r\n}\r\nif (WARN_ON(ffs_obj->desc_ready)) {\r\nret = -EBUSY;\r\ngoto done;\r\n}\r\nffs_obj->ffs_data = ffs;\r\nif (functionfs_all_ready(_ccg_dev)) {\r\nret = -EBUSY;\r\ngoto done;\r\n}\r\nffs_obj->desc_ready = true;\r\ndone:\r\nmutex_unlock(&_ccg_dev->mutex);\r\nreturn ret;\r\n}\r\nstatic void reset_usb(struct ccg_dev *dev)\r\n{\r\nusb_ep_dequeue(dev->cdev->gadget->ep0, dev->cdev->req);\r\nusb_remove_config(dev->cdev, &ccg_config_driver);\r\ndev->enabled = false;\r\nusb_gadget_disconnect(dev->cdev->gadget);\r\n}\r\nstatic void functionfs_closed_callback(struct ffs_data *ffs)\r\n{\r\nstruct ffs_obj *ffs_obj;\r\nmutex_lock(&_ccg_dev->mutex);\r\nffs_obj = ffs->private_data;\r\nif (!ffs_obj)\r\ngoto done;\r\nffs_obj->desc_ready = false;\r\nif (_ccg_dev->enabled)\r\nreset_usb(_ccg_dev);\r\ndone:\r\nmutex_unlock(&_ccg_dev->mutex);\r\n}\r\nstatic void *functionfs_acquire_dev_callback(const char *dev_name)\r\n{\r\nstruct ffs_obj *ffs_dev;\r\nmutex_lock(&_ccg_dev->mutex);\r\nffs_dev = functionfs_find_dev(_ccg_dev, dev_name);\r\nif (!ffs_dev) {\r\nffs_dev = ERR_PTR(-ENODEV);\r\ngoto done;\r\n}\r\nif (ffs_dev->mounted) {\r\nffs_dev = ERR_PTR(-EBUSY);\r\ngoto done;\r\n}\r\nffs_dev->mounted = true;\r\ndone:\r\nmutex_unlock(&_ccg_dev->mutex);\r\nreturn ffs_dev;\r\n}\r\nstatic void functionfs_release_dev_callback(struct ffs_data *ffs_data)\r\n{\r\nstruct ffs_obj *ffs_dev;\r\nmutex_lock(&_ccg_dev->mutex);\r\nffs_dev = ffs_data->private_data;\r\nif (ffs_dev)\r\nffs_dev->mounted = false;\r\nmutex_unlock(&_ccg_dev->mutex);\r\n}\r\nstatic int functionfs_function_init(struct ccg_usb_function *f,\r\nstruct usb_composite_dev *cdev)\r\n{\r\nreturn functionfs_init();\r\n}\r\nstatic void functionfs_function_cleanup(struct ccg_usb_function *f)\r\n{\r\nfunctionfs_cleanup();\r\n}\r\nstatic int functionfs_function_bind_config(struct ccg_usb_function *f,\r\nstruct usb_configuration *c)\r\n{\r\nstruct ccg_dev *dev = _ccg_dev;\r\nint i, ret;\r\nfor (i = dev->max_func_num; i--; ) {\r\nif (!dev->ffs_tab[i].used)\r\ncontinue;\r\nret = functionfs_bind(dev->ffs_tab[i].ffs_data, c->cdev);\r\nif (unlikely(ret < 0)) {\r\nwhile (++i < dev->max_func_num)\r\nfunctionfs_unbind(dev->ffs_tab[i].ffs_data);\r\nreturn ret;\r\n}\r\n}\r\nfor (i = dev->max_func_num; i--; ) {\r\nif (!dev->ffs_tab[i].used)\r\ncontinue;\r\nret = functionfs_bind_config(c->cdev, c,\r\ndev->ffs_tab[i].ffs_data);\r\nif (unlikely(ret < 0))\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic void functionfs_function_unbind_config(struct ccg_usb_function *f,\r\nstruct usb_configuration *c)\r\n{\r\nstruct ccg_dev *dev = _ccg_dev;\r\nint i;\r\nfor (i = dev->max_func_num; i--; )\r\nif (dev->ffs_tab[i].ffs_data)\r\nfunctionfs_unbind(dev->ffs_tab[i].ffs_data);\r\n}\r\nstatic ssize_t functionfs_user_functions_show(struct device *_dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct ccg_dev *dev = _ccg_dev;\r\nchar *buff = buf;\r\nint i;\r\nmutex_lock(&dev->mutex);\r\nfor (i = 0; i < dev->max_func_num; i++)\r\nbuff += snprintf(buff, PAGE_SIZE + buf - buff, "%s,",\r\ndev->ffs_tab[i].name);\r\nmutex_unlock(&dev->mutex);\r\nif (buff != buf)\r\n*(buff - 1) = '\n';\r\nreturn buff - buf;\r\n}\r\nstatic ssize_t functionfs_user_functions_store(struct device *_dev,\r\nstruct device_attribute *attr,\r\nconst char *buff, size_t size)\r\n{\r\nstruct ccg_dev *dev = _ccg_dev;\r\nchar *name, *b;\r\nssize_t ret = size;\r\nint i;\r\nbuff = skip_spaces(buff);\r\nif (!*buff)\r\nreturn -EINVAL;\r\nmutex_lock(&dev->mutex);\r\nif (dev->enabled) {\r\nret = -EBUSY;\r\ngoto end;\r\n}\r\nfor (i = 0; i < dev->max_func_num; i++)\r\nif (dev->ffs_tab[i].mounted) {\r\nret = -EBUSY;\r\ngoto end;\r\n}\r\nstrlcpy(func_names_buf, buff, sizeof(func_names_buf));\r\nb = strim(func_names_buf);\r\ndev->max_func_num = 0;\r\nwhile (b) {\r\nname = strsep(&b, ",");\r\nif (dev->max_func_num == GFS_MAX_DEVS) {\r\nret = -ENOSPC;\r\ngoto end;\r\n}\r\nif (functionfs_find_dev(dev, name)) {\r\nret = -EEXIST;\r\ncontinue;\r\n}\r\ndev->ffs_tab[dev->max_func_num++].name = name;\r\n}\r\nend:\r\nmutex_unlock(&dev->mutex);\r\nreturn ret;\r\n}\r\nstatic ssize_t functionfs_max_user_functions_show(struct device *_dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nreturn sprintf(buf, "%d", GFS_MAX_DEVS);\r\n}\r\nstatic int\r\nacm_function_init(struct ccg_usb_function *f, struct usb_composite_dev *cdev)\r\n{\r\nf->config = kzalloc(sizeof(struct acm_function_config), GFP_KERNEL);\r\nif (!f->config)\r\nreturn -ENOMEM;\r\nreturn gserial_setup(cdev->gadget, MAX_ACM_INSTANCES);\r\n}\r\nstatic void acm_function_cleanup(struct ccg_usb_function *f)\r\n{\r\ngserial_cleanup();\r\nkfree(f->config);\r\nf->config = NULL;\r\n}\r\nstatic int\r\nacm_function_bind_config(struct ccg_usb_function *f,\r\nstruct usb_configuration *c)\r\n{\r\nint i;\r\nint ret = 0;\r\nstruct acm_function_config *config = f->config;\r\nfor (i = 0; i < config->instances; i++) {\r\nret = acm_bind_config(c, i);\r\nif (ret) {\r\npr_err("Could not bind acm%u config\n", i);\r\nbreak;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic ssize_t acm_instances_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct ccg_usb_function *f = dev_get_drvdata(dev);\r\nstruct acm_function_config *config = f->config;\r\nreturn sprintf(buf, "%d\n", config->instances);\r\n}\r\nstatic ssize_t acm_instances_store(struct device *dev,\r\nstruct device_attribute *attr, const char *buf, size_t size)\r\n{\r\nstruct ccg_usb_function *f = dev_get_drvdata(dev);\r\nstruct acm_function_config *config = f->config;\r\nint value;\r\nint ret = 0;\r\nret = kstrtoint(buf, 10, &value);\r\nif (ret)\r\nreturn ret;\r\nif (value > MAX_ACM_INSTANCES)\r\nreturn -EINVAL;\r\nconfig->instances = value;\r\nreturn size;\r\n}\r\nstatic int rndis_function_init(struct ccg_usb_function *f,\r\nstruct usb_composite_dev *cdev)\r\n{\r\nf->config = kzalloc(sizeof(struct rndis_function_config), GFP_KERNEL);\r\nif (!f->config)\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nstatic void rndis_function_cleanup(struct ccg_usb_function *f)\r\n{\r\nkfree(f->config);\r\nf->config = NULL;\r\n}\r\nstatic int rndis_function_bind_config(struct ccg_usb_function *f,\r\nstruct usb_configuration *c)\r\n{\r\nint ret;\r\nstruct rndis_function_config *rndis = f->config;\r\nif (!rndis) {\r\npr_err("%s: rndis_pdata\n", __func__);\r\nreturn -1;\r\n}\r\npr_info("%s MAC: %pM\n", __func__, rndis->ethaddr);\r\nret = gether_setup_name(c->cdev->gadget, rndis->ethaddr, "rndis");\r\nif (ret) {\r\npr_err("%s: gether_setup failed\n", __func__);\r\nreturn ret;\r\n}\r\nif (rndis->wceis) {\r\nrndis_iad_descriptor.bFunctionClass =\r\nUSB_CLASS_WIRELESS_CONTROLLER;\r\nrndis_iad_descriptor.bFunctionSubClass = 0x01;\r\nrndis_iad_descriptor.bFunctionProtocol = 0x03;\r\nrndis_control_intf.bInterfaceClass =\r\nUSB_CLASS_WIRELESS_CONTROLLER;\r\nrndis_control_intf.bInterfaceSubClass = 0x01;\r\nrndis_control_intf.bInterfaceProtocol = 0x03;\r\n}\r\nreturn rndis_bind_config_vendor(c, rndis->ethaddr, rndis->vendorID,\r\nrndis->manufacturer);\r\n}\r\nstatic void rndis_function_unbind_config(struct ccg_usb_function *f,\r\nstruct usb_configuration *c)\r\n{\r\ngether_cleanup();\r\n}\r\nstatic ssize_t rndis_manufacturer_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct ccg_usb_function *f = dev_get_drvdata(dev);\r\nstruct rndis_function_config *config = f->config;\r\nreturn sprintf(buf, "%s\n", config->manufacturer);\r\n}\r\nstatic ssize_t rndis_manufacturer_store(struct device *dev,\r\nstruct device_attribute *attr, const char *buf, size_t size)\r\n{\r\nstruct ccg_usb_function *f = dev_get_drvdata(dev);\r\nstruct rndis_function_config *config = f->config;\r\nif (size >= sizeof(config->manufacturer))\r\nreturn -EINVAL;\r\nmemcpy(config->manufacturer, buf, size);\r\nconfig->manufacturer[size] = 0;\r\nreturn size;\r\n}\r\nstatic ssize_t rndis_wceis_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct ccg_usb_function *f = dev_get_drvdata(dev);\r\nstruct rndis_function_config *config = f->config;\r\nreturn sprintf(buf, "%d\n", config->wceis);\r\n}\r\nstatic ssize_t rndis_wceis_store(struct device *dev,\r\nstruct device_attribute *attr, const char *buf, size_t size)\r\n{\r\nstruct ccg_usb_function *f = dev_get_drvdata(dev);\r\nstruct rndis_function_config *config = f->config;\r\nint value;\r\nint ret;\r\nret = kstrtoint(buf, 10, &value);\r\nif (ret)\r\nreturn ret;\r\nconfig->wceis = value;\r\nreturn size;\r\n}\r\nstatic ssize_t rndis_ethaddr_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct ccg_usb_function *f = dev_get_drvdata(dev);\r\nstruct rndis_function_config *rndis = f->config;\r\nreturn sprintf(buf, "%pM\n", rndis->ethaddr);\r\n}\r\nstatic ssize_t rndis_ethaddr_store(struct device *dev,\r\nstruct device_attribute *attr, const char *buf, size_t size)\r\n{\r\nstruct ccg_usb_function *f = dev_get_drvdata(dev);\r\nstruct rndis_function_config *rndis = f->config;\r\nunsigned char tmp[6];\r\nif (sscanf(buf, "%hhx:%hhx:%hhx:%hhx:%hhx:%hhx",\r\ntmp + 0, tmp + 1, tmp + 2, tmp + 3, tmp + 4, tmp + 5) !=\r\nETH_ALEN)\r\nreturn -EINVAL;\r\nmemcpy(rndis->ethaddr, tmp, ETH_ALEN);\r\nreturn ETH_ALEN;\r\n}\r\nstatic ssize_t rndis_vendorID_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct ccg_usb_function *f = dev_get_drvdata(dev);\r\nstruct rndis_function_config *config = f->config;\r\nreturn sprintf(buf, "%04x\n", config->vendorID);\r\n}\r\nstatic ssize_t rndis_vendorID_store(struct device *dev,\r\nstruct device_attribute *attr, const char *buf, size_t size)\r\n{\r\nstruct ccg_usb_function *f = dev_get_drvdata(dev);\r\nstruct rndis_function_config *config = f->config;\r\nint value;\r\nint ret;\r\nret = kstrtou32(buf, 16, &value);\r\nif (ret)\r\nreturn ret;\r\nconfig->vendorID = value;\r\nreturn size;\r\n}\r\nstatic int mass_storage_function_init(struct ccg_usb_function *f,\r\nstruct usb_composite_dev *cdev)\r\n{\r\nstruct fsg_config fsg;\r\nstruct fsg_common *common;\r\nint err;\r\nmemset(&fsg, 0, sizeof(fsg));\r\nfsg.nluns = 1;\r\nfsg.luns[0].removable = 1;\r\nfsg.vendor_name = iManufacturer;\r\nfsg.product_name = iProduct;\r\ncommon = fsg_common_init(NULL, cdev, &fsg);\r\nif (IS_ERR(common))\r\nreturn PTR_ERR(common);\r\nerr = sysfs_create_link(&f->dev->kobj,\r\n&common->luns[0].dev.kobj,\r\n"lun");\r\nif (err) {\r\nfsg_common_put(common);\r\nreturn err;\r\n}\r\nf->config = common;\r\nreturn 0;\r\n}\r\nstatic void mass_storage_function_cleanup(struct ccg_usb_function *f)\r\n{\r\nfsg_common_put(f->config);\r\nf->config = NULL;\r\n}\r\nstatic int mass_storage_function_bind_config(struct ccg_usb_function *f,\r\nstruct usb_configuration *c)\r\n{\r\nstruct fsg_common *common = f->config;\r\nreturn fsg_bind_config(c->cdev, c, common);\r\n}\r\nstatic int ccg_init_functions(struct ccg_usb_function **functions,\r\nstruct usb_composite_dev *cdev)\r\n{\r\nstruct ccg_dev *dev = _ccg_dev;\r\nstruct ccg_usb_function *f;\r\nstruct device_attribute **attrs;\r\nstruct device_attribute *attr;\r\nint err;\r\nint index = 0;\r\nfor (; (f = *functions++); index++) {\r\nf->dev_name = kasprintf(GFP_KERNEL, "f_%s", f->name);\r\nif (!f->dev_name) {\r\npr_err("%s: Failed to alloc name %s", __func__,\r\nf->name);\r\nerr = -ENOMEM;\r\ngoto err_alloc;\r\n}\r\nf->dev = device_create(ccg_class, dev->dev,\r\nMKDEV(0, index), f, f->dev_name);\r\nif (IS_ERR(f->dev)) {\r\npr_err("%s: Failed to create dev %s", __func__,\r\nf->dev_name);\r\nerr = PTR_ERR(f->dev);\r\nf->dev = NULL;\r\ngoto err_create;\r\n}\r\nif (f->init) {\r\nerr = f->init(f, cdev);\r\nif (err) {\r\npr_err("%s: Failed to init %s", __func__,\r\nf->name);\r\ngoto err_out;\r\n}\r\n}\r\nattrs = f->attributes;\r\nif (attrs) {\r\nwhile ((attr = *attrs++) && !err)\r\nerr = device_create_file(f->dev, attr);\r\n}\r\nif (err) {\r\npr_err("%s: Failed to create function %s attributes",\r\n__func__, f->name);\r\ngoto err_uninit;\r\n}\r\n}\r\nreturn 0;\r\nerr_uninit:\r\nif (f->cleanup)\r\nf->cleanup(f);\r\nerr_out:\r\ndevice_destroy(ccg_class, f->dev->devt);\r\nf->dev = NULL;\r\nerr_create:\r\nkfree(f->dev_name);\r\nerr_alloc:\r\nreturn err;\r\n}\r\nstatic void ccg_cleanup_functions(struct ccg_usb_function **functions)\r\n{\r\nstruct ccg_usb_function *f;\r\nwhile (*functions) {\r\nf = *functions++;\r\nif (f->dev) {\r\nif (f->cleanup)\r\nf->cleanup(f);\r\ndevice_destroy(ccg_class, f->dev->devt);\r\nkfree(f->dev_name);\r\n}\r\n}\r\n}\r\nstatic int ccg_bind_enabled_functions(struct ccg_dev *dev,\r\nstruct usb_configuration *c)\r\n{\r\nstruct ccg_usb_function *f;\r\nint ret;\r\nlist_for_each_entry(f, &dev->enabled_functions, enabled_list) {\r\nret = f->bind_config(f, c);\r\nif (ret) {\r\npr_err("%s: %s failed", __func__, f->name);\r\nreturn ret;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void ccg_unbind_enabled_functions(struct ccg_dev *dev,\r\nstruct usb_configuration *c)\r\n{\r\nstruct ccg_usb_function *f;\r\nlist_for_each_entry(f, &dev->enabled_functions, enabled_list)\r\nif (f->unbind_config)\r\nf->unbind_config(f, c);\r\n}\r\nstatic int ccg_enable_function(struct ccg_dev *dev, char *name)\r\n{\r\nstruct ccg_usb_function **functions = dev->functions;\r\nstruct ccg_usb_function *f;\r\nwhile ((f = *functions++)) {\r\nif (!strcmp(name, f->name)) {\r\nlist_add_tail(&f->enabled_list,\r\n&dev->enabled_functions);\r\nreturn 0;\r\n}\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic ssize_t\r\nfunctions_show(struct device *pdev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct ccg_dev *dev = dev_get_drvdata(pdev);\r\nstruct ccg_usb_function *f;\r\nchar *buff = buf;\r\nint i;\r\nmutex_lock(&dev->mutex);\r\nlist_for_each_entry(f, &dev->enabled_functions, enabled_list)\r\nbuff += sprintf(buff, "%s,", f->name);\r\nfor (i = 0; i < dev->max_func_num; i++)\r\nif (dev->ffs_tab[i].used)\r\nbuff += sprintf(buff, "%s", dev->ffs_tab[i].name);\r\nmutex_unlock(&dev->mutex);\r\nif (buff != buf)\r\n*(buff-1) = '\n';\r\nreturn buff - buf;\r\n}\r\nstatic ssize_t\r\nfunctions_store(struct device *pdev, struct device_attribute *attr,\r\nconst char *buff, size_t size)\r\n{\r\nstruct ccg_dev *dev = dev_get_drvdata(pdev);\r\nchar *name;\r\nchar buf[256], *b;\r\nint err, i;\r\nbool functionfs_enabled;\r\nbuff = skip_spaces(buff);\r\nif (!*buff)\r\nreturn -EINVAL;\r\nmutex_lock(&dev->mutex);\r\nif (dev->enabled) {\r\nmutex_unlock(&dev->mutex);\r\nreturn -EBUSY;\r\n}\r\nINIT_LIST_HEAD(&dev->enabled_functions);\r\nfunctionfs_enabled = false;\r\nfor (i = 0; i < dev->max_func_num; i++)\r\ndev->ffs_tab[i].used = false;\r\nstrlcpy(buf, buff, sizeof(buf));\r\nb = strim(buf);\r\nwhile (b) {\r\nstruct ffs_obj *user_func;\r\nname = strsep(&b, ",");\r\nif (!strcmp(name, functionfs_function.name)) {\r\npr_err("ccg_usb: Cannot explicitly enable '%s'", name);\r\ncontinue;\r\n}\r\nuser_func = functionfs_find_dev(dev, name);\r\nif (user_func)\r\nname = functionfs_function.name;\r\nerr = 0;\r\nif (!user_func || !functionfs_enabled)\r\nerr = ccg_enable_function(dev, name);\r\nif (err)\r\npr_err("ccg_usb: Cannot enable '%s'", name);\r\nelse if (user_func) {\r\nuser_func->used = true;\r\ndev->func_num++;\r\nfunctionfs_enabled = true;\r\n}\r\n}\r\nmutex_unlock(&dev->mutex);\r\nreturn size;\r\n}\r\nstatic ssize_t enable_show(struct device *pdev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct ccg_dev *dev = dev_get_drvdata(pdev);\r\nreturn sprintf(buf, "%d\n", dev->enabled);\r\n}\r\nstatic ssize_t enable_store(struct device *pdev, struct device_attribute *attr,\r\nconst char *buff, size_t size)\r\n{\r\nstruct ccg_dev *dev = dev_get_drvdata(pdev);\r\nstruct usb_composite_dev *cdev = dev->cdev;\r\nint enabled = 0;\r\nmutex_lock(&dev->mutex);\r\nsscanf(buff, "%d", &enabled);\r\nif (enabled && dev->func_num && !functionfs_all_ready(dev)) {\r\nmutex_unlock(&dev->mutex);\r\nreturn -ENODEV;\r\n}\r\nif (enabled && !dev->enabled) {\r\nint ret;\r\ncdev->next_string_id = 0;\r\ncdev->desc.bDeviceClass = device_desc.bDeviceClass;\r\ncdev->desc.bDeviceSubClass = device_desc.bDeviceSubClass;\r\ncdev->desc.bDeviceProtocol = device_desc.bDeviceProtocol;\r\ncdev->desc.idVendor = idVendor;\r\ncdev->desc.idProduct = idProduct;\r\ncdev->desc.bcdDevice = bcdDevice;\r\nusb_add_config(cdev, &ccg_config_driver, ccg_bind_config);\r\ndev->enabled = true;\r\nret = usb_gadget_connect(cdev->gadget);\r\nif (ret) {\r\ndev->enabled = false;\r\nusb_remove_config(cdev, &ccg_config_driver);\r\n}\r\n} else if (!enabled && dev->enabled) {\r\nreset_usb(dev);\r\n} else {\r\npr_err("ccg_usb: already %s\n",\r\ndev->enabled ? "enabled" : "disabled");\r\n}\r\nmutex_unlock(&dev->mutex);\r\nreturn size;\r\n}\r\nstatic ssize_t state_show(struct device *pdev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct ccg_dev *dev = dev_get_drvdata(pdev);\r\nstruct usb_composite_dev *cdev = dev->cdev;\r\nchar *state = "DISCONNECTED";\r\nunsigned long flags;\r\nif (!cdev)\r\ngoto out;\r\nspin_lock_irqsave(&cdev->lock, flags);\r\nif (cdev->config)\r\nstate = "CONFIGURED";\r\nelse if (dev->connected)\r\nstate = "CONNECTED";\r\nspin_unlock_irqrestore(&cdev->lock, flags);\r\nout:\r\nreturn sprintf(buf, "%s\n", state);\r\n}\r\nstatic int ccg_bind_config(struct usb_configuration *c)\r\n{\r\nstruct ccg_dev *dev = _ccg_dev;\r\nreturn ccg_bind_enabled_functions(dev, c);\r\n}\r\nstatic void ccg_unbind_config(struct usb_configuration *c)\r\n{\r\nstruct ccg_dev *dev = _ccg_dev;\r\nccg_unbind_enabled_functions(dev, c);\r\nusb_ep_autoconfig_reset(dev->cdev->gadget);\r\n}\r\nstatic int ccg_bind(struct usb_composite_dev *cdev)\r\n{\r\nstruct ccg_dev *dev = _ccg_dev;\r\nstruct usb_gadget *gadget = cdev->gadget;\r\nint gcnum, ret;\r\nusb_gadget_disconnect(gadget);\r\nret = ccg_init_functions(dev->functions, cdev);\r\nif (ret)\r\nreturn ret;\r\ngcnum = usb_gadget_controller_number(gadget);\r\nif (gcnum >= 0)\r\ndevice_desc.bcdDevice = cpu_to_le16(0x0200 + gcnum);\r\nelse {\r\npr_warn("%s: controller '%s' not recognized\n",\r\nlongname, gadget->name);\r\ndevice_desc.bcdDevice = __constant_cpu_to_le16(0x9999);\r\n}\r\nusb_gadget_set_selfpowered(gadget);\r\ndev->cdev = cdev;\r\nreturn 0;\r\n}\r\nstatic int ccg_usb_unbind(struct usb_composite_dev *cdev)\r\n{\r\nstruct ccg_dev *dev = _ccg_dev;\r\ncancel_work_sync(&dev->work);\r\nccg_cleanup_functions(dev->functions);\r\nreturn 0;\r\n}\r\nstatic int ccg_setup(struct usb_gadget *gadget, const struct usb_ctrlrequest *c)\r\n{\r\nstruct ccg_dev *dev = _ccg_dev;\r\nstruct usb_composite_dev *cdev = get_gadget_data(gadget);\r\nstruct usb_request *req = cdev->req;\r\nstruct ccg_usb_function *f;\r\nint value = -EOPNOTSUPP;\r\nunsigned long flags;\r\nreq->zero = 0;\r\nreq->complete = composite_setup_complete;\r\nreq->length = 0;\r\ngadget->ep0->driver_data = cdev;\r\nlist_for_each_entry(f, &dev->enabled_functions, enabled_list) {\r\nif (f->ctrlrequest) {\r\nvalue = f->ctrlrequest(f, cdev, c);\r\nif (value >= 0)\r\nbreak;\r\n}\r\n}\r\nif (value < 0)\r\nvalue = composite_setup(gadget, c);\r\nspin_lock_irqsave(&cdev->lock, flags);\r\nif (!dev->connected) {\r\ndev->connected = 1;\r\nschedule_work(&dev->work);\r\n} else if (c->bRequest == USB_REQ_SET_CONFIGURATION &&\r\ncdev->config) {\r\nschedule_work(&dev->work);\r\n}\r\nspin_unlock_irqrestore(&cdev->lock, flags);\r\nreturn value;\r\n}\r\nstatic void ccg_disconnect(struct usb_gadget *gadget)\r\n{\r\nstruct ccg_dev *dev = _ccg_dev;\r\nstruct usb_composite_dev *cdev = get_gadget_data(gadget);\r\nunsigned long flags;\r\ncomposite_disconnect(gadget);\r\nspin_lock_irqsave(&cdev->lock, flags);\r\ndev->connected = 0;\r\nschedule_work(&dev->work);\r\nspin_unlock_irqrestore(&cdev->lock, flags);\r\n}\r\nstatic int ccg_create_device(struct ccg_dev *dev)\r\n{\r\nstruct device_attribute **attrs = ccg_usb_attributes;\r\nstruct device_attribute *attr;\r\nint err;\r\ndev->dev = device_create(ccg_class, NULL, MKDEV(0, 0), NULL, "ccg0");\r\nif (IS_ERR(dev->dev))\r\nreturn PTR_ERR(dev->dev);\r\ndev_set_drvdata(dev->dev, dev);\r\nwhile ((attr = *attrs++)) {\r\nerr = device_create_file(dev->dev, attr);\r\nif (err) {\r\ndevice_destroy(ccg_class, dev->dev->devt);\r\nreturn err;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init ccg_init(void)\r\n{\r\nstruct ccg_dev *dev;\r\nint err;\r\nccg_class = class_create(THIS_MODULE, "ccg_usb");\r\nif (IS_ERR(ccg_class))\r\nreturn PTR_ERR(ccg_class);\r\ndev = kzalloc(sizeof(*dev), GFP_KERNEL);\r\nif (!dev) {\r\nclass_destroy(ccg_class);\r\nreturn -ENOMEM;\r\n}\r\ndev->functions = supported_functions;\r\nINIT_LIST_HEAD(&dev->enabled_functions);\r\nINIT_WORK(&dev->work, ccg_work);\r\nmutex_init(&dev->mutex);\r\nerr = ccg_create_device(dev);\r\nif (err) {\r\nclass_destroy(ccg_class);\r\nkfree(dev);\r\nreturn err;\r\n}\r\n_ccg_dev = dev;\r\ncomposite_driver.setup = ccg_setup;\r\ncomposite_driver.disconnect = ccg_disconnect;\r\nerr = usb_composite_probe(&ccg_usb_driver);\r\nif (err) {\r\nclass_destroy(ccg_class);\r\nkfree(dev);\r\n}\r\nreturn err;\r\n}\r\nstatic void __exit ccg_exit(void)\r\n{\r\nusb_composite_unregister(&ccg_usb_driver);\r\nclass_destroy(ccg_class);\r\nkfree(_ccg_dev);\r\n_ccg_dev = NULL;\r\n}
