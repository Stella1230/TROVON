static void exynos_gpio_irq_unmask(struct irq_data *irqd)\r\n{\r\nstruct samsung_pin_bank *bank = irq_data_get_irq_chip_data(irqd);\r\nstruct samsung_pinctrl_drv_data *d = bank->drvdata;\r\nunsigned long reg_mask = d->ctrl->geint_mask + bank->eint_offset;\r\nunsigned long mask;\r\nmask = readl(d->virt_base + reg_mask);\r\nmask &= ~(1 << irqd->hwirq);\r\nwritel(mask, d->virt_base + reg_mask);\r\n}\r\nstatic void exynos_gpio_irq_mask(struct irq_data *irqd)\r\n{\r\nstruct samsung_pin_bank *bank = irq_data_get_irq_chip_data(irqd);\r\nstruct samsung_pinctrl_drv_data *d = bank->drvdata;\r\nunsigned long reg_mask = d->ctrl->geint_mask + bank->eint_offset;\r\nunsigned long mask;\r\nmask = readl(d->virt_base + reg_mask);\r\nmask |= 1 << irqd->hwirq;\r\nwritel(mask, d->virt_base + reg_mask);\r\n}\r\nstatic void exynos_gpio_irq_ack(struct irq_data *irqd)\r\n{\r\nstruct samsung_pin_bank *bank = irq_data_get_irq_chip_data(irqd);\r\nstruct samsung_pinctrl_drv_data *d = bank->drvdata;\r\nunsigned long reg_pend = d->ctrl->geint_pend + bank->eint_offset;\r\nwritel(1 << irqd->hwirq, d->virt_base + reg_pend);\r\n}\r\nstatic int exynos_gpio_irq_set_type(struct irq_data *irqd, unsigned int type)\r\n{\r\nstruct samsung_pin_bank *bank = irq_data_get_irq_chip_data(irqd);\r\nstruct samsung_pinctrl_drv_data *d = bank->drvdata;\r\nstruct samsung_pin_ctrl *ctrl = d->ctrl;\r\nunsigned int pin = irqd->hwirq;\r\nunsigned int shift = EXYNOS_EINT_CON_LEN * pin;\r\nunsigned int con, trig_type;\r\nunsigned long reg_con = ctrl->geint_con + bank->eint_offset;\r\nunsigned int mask;\r\nswitch (type) {\r\ncase IRQ_TYPE_EDGE_RISING:\r\ntrig_type = EXYNOS_EINT_EDGE_RISING;\r\nbreak;\r\ncase IRQ_TYPE_EDGE_FALLING:\r\ntrig_type = EXYNOS_EINT_EDGE_FALLING;\r\nbreak;\r\ncase IRQ_TYPE_EDGE_BOTH:\r\ntrig_type = EXYNOS_EINT_EDGE_BOTH;\r\nbreak;\r\ncase IRQ_TYPE_LEVEL_HIGH:\r\ntrig_type = EXYNOS_EINT_LEVEL_HIGH;\r\nbreak;\r\ncase IRQ_TYPE_LEVEL_LOW:\r\ntrig_type = EXYNOS_EINT_LEVEL_LOW;\r\nbreak;\r\ndefault:\r\npr_err("unsupported external interrupt type\n");\r\nreturn -EINVAL;\r\n}\r\nif (type & IRQ_TYPE_EDGE_BOTH)\r\n__irq_set_handler_locked(irqd->irq, handle_edge_irq);\r\nelse\r\n__irq_set_handler_locked(irqd->irq, handle_level_irq);\r\ncon = readl(d->virt_base + reg_con);\r\ncon &= ~(EXYNOS_EINT_CON_MASK << shift);\r\ncon |= trig_type << shift;\r\nwritel(con, d->virt_base + reg_con);\r\nreg_con = bank->pctl_offset;\r\nshift = pin * bank->func_width;\r\nmask = (1 << bank->func_width) - 1;\r\ncon = readl(d->virt_base + reg_con);\r\ncon &= ~(mask << shift);\r\ncon |= EXYNOS_EINT_FUNC << shift;\r\nwritel(con, d->virt_base + reg_con);\r\nreturn 0;\r\n}\r\nstatic int exynos_gpio_irq_map(struct irq_domain *h, unsigned int virq,\r\nirq_hw_number_t hw)\r\n{\r\nstruct samsung_pin_bank *b = h->host_data;\r\nirq_set_chip_data(virq, b);\r\nirq_set_chip_and_handler(virq, &exynos_gpio_irq_chip,\r\nhandle_level_irq);\r\nset_irq_flags(virq, IRQF_VALID);\r\nreturn 0;\r\n}\r\nstatic irqreturn_t exynos_eint_gpio_irq(int irq, void *data)\r\n{\r\nstruct samsung_pinctrl_drv_data *d = data;\r\nstruct samsung_pin_ctrl *ctrl = d->ctrl;\r\nstruct samsung_pin_bank *bank = ctrl->pin_banks;\r\nunsigned int svc, group, pin, virq;\r\nsvc = readl(d->virt_base + ctrl->svc);\r\ngroup = EXYNOS_SVC_GROUP(svc);\r\npin = svc & EXYNOS_SVC_NUM_MASK;\r\nif (!group)\r\nreturn IRQ_HANDLED;\r\nbank += (group - 1);\r\nvirq = irq_linear_revmap(bank->irq_domain, pin);\r\nif (!virq)\r\nreturn IRQ_NONE;\r\ngeneric_handle_irq(virq);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int exynos_eint_gpio_init(struct samsung_pinctrl_drv_data *d)\r\n{\r\nstruct samsung_pin_bank *bank;\r\nstruct device *dev = d->dev;\r\nunsigned int ret;\r\nunsigned int i;\r\nif (!d->irq) {\r\ndev_err(dev, "irq number not available\n");\r\nreturn -EINVAL;\r\n}\r\nret = devm_request_irq(dev, d->irq, exynos_eint_gpio_irq,\r\n0, dev_name(dev), d);\r\nif (ret) {\r\ndev_err(dev, "irq request failed\n");\r\nreturn -ENXIO;\r\n}\r\nbank = d->ctrl->pin_banks;\r\nfor (i = 0; i < d->ctrl->nr_banks; ++i, ++bank) {\r\nif (bank->eint_type != EINT_TYPE_GPIO)\r\ncontinue;\r\nbank->irq_domain = irq_domain_add_linear(bank->of_node,\r\nbank->nr_pins, &exynos_gpio_irqd_ops, bank);\r\nif (!bank->irq_domain) {\r\ndev_err(dev, "gpio irq domain add failed\n");\r\nreturn -ENXIO;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void exynos_wkup_irq_unmask(struct irq_data *irqd)\r\n{\r\nstruct samsung_pin_bank *b = irq_data_get_irq_chip_data(irqd);\r\nstruct samsung_pinctrl_drv_data *d = b->drvdata;\r\nunsigned long reg_mask = d->ctrl->weint_mask + b->eint_offset;\r\nunsigned long mask;\r\nmask = readl(d->virt_base + reg_mask);\r\nmask &= ~(1 << irqd->hwirq);\r\nwritel(mask, d->virt_base + reg_mask);\r\n}\r\nstatic void exynos_wkup_irq_mask(struct irq_data *irqd)\r\n{\r\nstruct samsung_pin_bank *b = irq_data_get_irq_chip_data(irqd);\r\nstruct samsung_pinctrl_drv_data *d = b->drvdata;\r\nunsigned long reg_mask = d->ctrl->weint_mask + b->eint_offset;\r\nunsigned long mask;\r\nmask = readl(d->virt_base + reg_mask);\r\nmask |= 1 << irqd->hwirq;\r\nwritel(mask, d->virt_base + reg_mask);\r\n}\r\nstatic void exynos_wkup_irq_ack(struct irq_data *irqd)\r\n{\r\nstruct samsung_pin_bank *b = irq_data_get_irq_chip_data(irqd);\r\nstruct samsung_pinctrl_drv_data *d = b->drvdata;\r\nunsigned long pend = d->ctrl->weint_pend + b->eint_offset;\r\nwritel(1 << irqd->hwirq, d->virt_base + pend);\r\n}\r\nstatic int exynos_wkup_irq_set_type(struct irq_data *irqd, unsigned int type)\r\n{\r\nstruct samsung_pin_bank *bank = irq_data_get_irq_chip_data(irqd);\r\nstruct samsung_pinctrl_drv_data *d = bank->drvdata;\r\nunsigned int pin = irqd->hwirq;\r\nunsigned long reg_con = d->ctrl->weint_con + bank->eint_offset;\r\nunsigned long shift = EXYNOS_EINT_CON_LEN * pin;\r\nunsigned long con, trig_type;\r\nunsigned int mask;\r\nswitch (type) {\r\ncase IRQ_TYPE_EDGE_RISING:\r\ntrig_type = EXYNOS_EINT_EDGE_RISING;\r\nbreak;\r\ncase IRQ_TYPE_EDGE_FALLING:\r\ntrig_type = EXYNOS_EINT_EDGE_FALLING;\r\nbreak;\r\ncase IRQ_TYPE_EDGE_BOTH:\r\ntrig_type = EXYNOS_EINT_EDGE_BOTH;\r\nbreak;\r\ncase IRQ_TYPE_LEVEL_HIGH:\r\ntrig_type = EXYNOS_EINT_LEVEL_HIGH;\r\nbreak;\r\ncase IRQ_TYPE_LEVEL_LOW:\r\ntrig_type = EXYNOS_EINT_LEVEL_LOW;\r\nbreak;\r\ndefault:\r\npr_err("unsupported external interrupt type\n");\r\nreturn -EINVAL;\r\n}\r\nif (type & IRQ_TYPE_EDGE_BOTH)\r\n__irq_set_handler_locked(irqd->irq, handle_edge_irq);\r\nelse\r\n__irq_set_handler_locked(irqd->irq, handle_level_irq);\r\ncon = readl(d->virt_base + reg_con);\r\ncon &= ~(EXYNOS_EINT_CON_MASK << shift);\r\ncon |= trig_type << shift;\r\nwritel(con, d->virt_base + reg_con);\r\nreg_con = bank->pctl_offset;\r\nshift = pin * bank->func_width;\r\nmask = (1 << bank->func_width) - 1;\r\ncon = readl(d->virt_base + reg_con);\r\ncon &= ~(mask << shift);\r\ncon |= EXYNOS_EINT_FUNC << shift;\r\nwritel(con, d->virt_base + reg_con);\r\nreturn 0;\r\n}\r\nstatic void exynos_irq_eint0_15(unsigned int irq, struct irq_desc *desc)\r\n{\r\nstruct exynos_weint_data *eintd = irq_get_handler_data(irq);\r\nstruct samsung_pin_bank *bank = eintd->bank;\r\nstruct irq_chip *chip = irq_get_chip(irq);\r\nint eint_irq;\r\nchained_irq_enter(chip, desc);\r\nchip->irq_mask(&desc->irq_data);\r\nif (chip->irq_ack)\r\nchip->irq_ack(&desc->irq_data);\r\neint_irq = irq_linear_revmap(bank->irq_domain, eintd->irq);\r\ngeneric_handle_irq(eint_irq);\r\nchip->irq_unmask(&desc->irq_data);\r\nchained_irq_exit(chip, desc);\r\n}\r\nstatic inline void exynos_irq_demux_eint(unsigned long pend,\r\nstruct irq_domain *domain)\r\n{\r\nunsigned int irq;\r\nwhile (pend) {\r\nirq = fls(pend) - 1;\r\ngeneric_handle_irq(irq_find_mapping(domain, irq));\r\npend &= ~(1 << irq);\r\n}\r\n}\r\nstatic void exynos_irq_demux_eint16_31(unsigned int irq, struct irq_desc *desc)\r\n{\r\nstruct irq_chip *chip = irq_get_chip(irq);\r\nstruct exynos_muxed_weint_data *eintd = irq_get_handler_data(irq);\r\nstruct samsung_pinctrl_drv_data *d = eintd->banks[0]->drvdata;\r\nstruct samsung_pin_ctrl *ctrl = d->ctrl;\r\nunsigned long pend;\r\nunsigned long mask;\r\nint i;\r\nchained_irq_enter(chip, desc);\r\nfor (i = 0; i < eintd->nr_banks; ++i) {\r\nstruct samsung_pin_bank *b = eintd->banks[i];\r\npend = readl(d->virt_base + ctrl->weint_pend + b->eint_offset);\r\nmask = readl(d->virt_base + ctrl->weint_mask + b->eint_offset);\r\nexynos_irq_demux_eint(pend & ~mask, b->irq_domain);\r\n}\r\nchained_irq_exit(chip, desc);\r\n}\r\nstatic int exynos_wkup_irq_map(struct irq_domain *h, unsigned int virq,\r\nirq_hw_number_t hw)\r\n{\r\nirq_set_chip_and_handler(virq, &exynos_wkup_irq_chip, handle_level_irq);\r\nirq_set_chip_data(virq, h->host_data);\r\nset_irq_flags(virq, IRQF_VALID);\r\nreturn 0;\r\n}\r\nstatic int exynos_eint_wkup_init(struct samsung_pinctrl_drv_data *d)\r\n{\r\nstruct device *dev = d->dev;\r\nstruct device_node *wkup_np = NULL;\r\nstruct device_node *np;\r\nstruct samsung_pin_bank *bank;\r\nstruct exynos_weint_data *weint_data;\r\nstruct exynos_muxed_weint_data *muxed_data;\r\nunsigned int muxed_banks = 0;\r\nunsigned int i;\r\nint idx, irq;\r\nfor_each_child_of_node(dev->of_node, np) {\r\nif (of_match_node(exynos_wkup_irq_ids, np)) {\r\nwkup_np = np;\r\nbreak;\r\n}\r\n}\r\nif (!wkup_np)\r\nreturn -ENODEV;\r\nbank = d->ctrl->pin_banks;\r\nfor (i = 0; i < d->ctrl->nr_banks; ++i, ++bank) {\r\nif (bank->eint_type != EINT_TYPE_WKUP)\r\ncontinue;\r\nbank->irq_domain = irq_domain_add_linear(bank->of_node,\r\nbank->nr_pins, &exynos_wkup_irqd_ops, bank);\r\nif (!bank->irq_domain) {\r\ndev_err(dev, "wkup irq domain add failed\n");\r\nreturn -ENXIO;\r\n}\r\nif (!of_find_property(bank->of_node, "interrupts", NULL)) {\r\nbank->eint_type = EINT_TYPE_WKUP_MUX;\r\n++muxed_banks;\r\ncontinue;\r\n}\r\nweint_data = devm_kzalloc(dev, bank->nr_pins\r\n* sizeof(*weint_data), GFP_KERNEL);\r\nif (!weint_data) {\r\ndev_err(dev, "could not allocate memory for weint_data\n");\r\nreturn -ENOMEM;\r\n}\r\nfor (idx = 0; idx < bank->nr_pins; ++idx) {\r\nirq = irq_of_parse_and_map(bank->of_node, idx);\r\nif (!irq) {\r\ndev_err(dev, "irq number for eint-%s-%d not found\n",\r\nbank->name, idx);\r\ncontinue;\r\n}\r\nweint_data[idx].irq = idx;\r\nweint_data[idx].bank = bank;\r\nirq_set_handler_data(irq, &weint_data[idx]);\r\nirq_set_chained_handler(irq, exynos_irq_eint0_15);\r\n}\r\n}\r\nif (!muxed_banks)\r\nreturn 0;\r\nirq = irq_of_parse_and_map(wkup_np, 0);\r\nif (!irq) {\r\ndev_err(dev, "irq number for muxed EINTs not found\n");\r\nreturn 0;\r\n}\r\nmuxed_data = devm_kzalloc(dev, sizeof(*muxed_data)\r\n+ muxed_banks*sizeof(struct samsung_pin_bank *), GFP_KERNEL);\r\nif (!muxed_data) {\r\ndev_err(dev, "could not allocate memory for muxed_data\n");\r\nreturn -ENOMEM;\r\n}\r\nirq_set_chained_handler(irq, exynos_irq_demux_eint16_31);\r\nirq_set_handler_data(irq, muxed_data);\r\nbank = d->ctrl->pin_banks;\r\nidx = 0;\r\nfor (i = 0; i < d->ctrl->nr_banks; ++i, ++bank) {\r\nif (bank->eint_type != EINT_TYPE_WKUP_MUX)\r\ncontinue;\r\nmuxed_data->banks[idx++] = bank;\r\n}\r\nmuxed_data->nr_banks = muxed_banks;\r\nreturn 0;\r\n}
