static unsigned __maybe_unused pcs_readb(void __iomem *reg)\r\n{\r\nreturn readb(reg);\r\n}\r\nstatic unsigned __maybe_unused pcs_readw(void __iomem *reg)\r\n{\r\nreturn readw(reg);\r\n}\r\nstatic unsigned __maybe_unused pcs_readl(void __iomem *reg)\r\n{\r\nreturn readl(reg);\r\n}\r\nstatic void __maybe_unused pcs_writeb(unsigned val, void __iomem *reg)\r\n{\r\nwriteb(val, reg);\r\n}\r\nstatic void __maybe_unused pcs_writew(unsigned val, void __iomem *reg)\r\n{\r\nwritew(val, reg);\r\n}\r\nstatic void __maybe_unused pcs_writel(unsigned val, void __iomem *reg)\r\n{\r\nwritel(val, reg);\r\n}\r\nstatic int pcs_get_groups_count(struct pinctrl_dev *pctldev)\r\n{\r\nstruct pcs_device *pcs;\r\npcs = pinctrl_dev_get_drvdata(pctldev);\r\nreturn pcs->ngroups;\r\n}\r\nstatic const char *pcs_get_group_name(struct pinctrl_dev *pctldev,\r\nunsigned gselector)\r\n{\r\nstruct pcs_device *pcs;\r\nstruct pcs_pingroup *group;\r\npcs = pinctrl_dev_get_drvdata(pctldev);\r\ngroup = radix_tree_lookup(&pcs->pgtree, gselector);\r\nif (!group) {\r\ndev_err(pcs->dev, "%s could not find pingroup%i\n",\r\n__func__, gselector);\r\nreturn NULL;\r\n}\r\nreturn group->name;\r\n}\r\nstatic int pcs_get_group_pins(struct pinctrl_dev *pctldev,\r\nunsigned gselector,\r\nconst unsigned **pins,\r\nunsigned *npins)\r\n{\r\nstruct pcs_device *pcs;\r\nstruct pcs_pingroup *group;\r\npcs = pinctrl_dev_get_drvdata(pctldev);\r\ngroup = radix_tree_lookup(&pcs->pgtree, gselector);\r\nif (!group) {\r\ndev_err(pcs->dev, "%s could not find pingroup%i\n",\r\n__func__, gselector);\r\nreturn -EINVAL;\r\n}\r\n*pins = group->gpins;\r\n*npins = group->ngpins;\r\nreturn 0;\r\n}\r\nstatic void pcs_pin_dbg_show(struct pinctrl_dev *pctldev,\r\nstruct seq_file *s,\r\nunsigned pin)\r\n{\r\nstruct pcs_device *pcs;\r\nunsigned val, mux_bytes;\r\npcs = pinctrl_dev_get_drvdata(pctldev);\r\nmux_bytes = pcs->width / BITS_PER_BYTE;\r\nval = pcs->read(pcs->base + pin * mux_bytes);\r\nseq_printf(s, "%08x %s " , val, DRIVER_NAME);\r\n}\r\nstatic void pcs_dt_free_map(struct pinctrl_dev *pctldev,\r\nstruct pinctrl_map *map, unsigned num_maps)\r\n{\r\nstruct pcs_device *pcs;\r\npcs = pinctrl_dev_get_drvdata(pctldev);\r\ndevm_kfree(pcs->dev, map);\r\n}\r\nstatic int pcs_get_functions_count(struct pinctrl_dev *pctldev)\r\n{\r\nstruct pcs_device *pcs;\r\npcs = pinctrl_dev_get_drvdata(pctldev);\r\nreturn pcs->nfuncs;\r\n}\r\nstatic const char *pcs_get_function_name(struct pinctrl_dev *pctldev,\r\nunsigned fselector)\r\n{\r\nstruct pcs_device *pcs;\r\nstruct pcs_function *func;\r\npcs = pinctrl_dev_get_drvdata(pctldev);\r\nfunc = radix_tree_lookup(&pcs->ftree, fselector);\r\nif (!func) {\r\ndev_err(pcs->dev, "%s could not find function%i\n",\r\n__func__, fselector);\r\nreturn NULL;\r\n}\r\nreturn func->name;\r\n}\r\nstatic int pcs_get_function_groups(struct pinctrl_dev *pctldev,\r\nunsigned fselector,\r\nconst char * const **groups,\r\nunsigned * const ngroups)\r\n{\r\nstruct pcs_device *pcs;\r\nstruct pcs_function *func;\r\npcs = pinctrl_dev_get_drvdata(pctldev);\r\nfunc = radix_tree_lookup(&pcs->ftree, fselector);\r\nif (!func) {\r\ndev_err(pcs->dev, "%s could not find function%i\n",\r\n__func__, fselector);\r\nreturn -EINVAL;\r\n}\r\n*groups = func->pgnames;\r\n*ngroups = func->npgnames;\r\nreturn 0;\r\n}\r\nstatic int pcs_enable(struct pinctrl_dev *pctldev, unsigned fselector,\r\nunsigned group)\r\n{\r\nstruct pcs_device *pcs;\r\nstruct pcs_function *func;\r\nint i;\r\npcs = pinctrl_dev_get_drvdata(pctldev);\r\nfunc = radix_tree_lookup(&pcs->ftree, fselector);\r\nif (!func)\r\nreturn -EINVAL;\r\ndev_dbg(pcs->dev, "enabling %s function%i\n",\r\nfunc->name, fselector);\r\nfor (i = 0; i < func->nvals; i++) {\r\nstruct pcs_func_vals *vals;\r\nunsigned val, mask;\r\nvals = &func->vals[i];\r\nval = pcs->read(vals->reg);\r\nif (!vals->mask)\r\nmask = pcs->fmask;\r\nelse\r\nmask = pcs->fmask & vals->mask;\r\nval &= ~mask;\r\nval |= (vals->val & mask);\r\npcs->write(val, vals->reg);\r\n}\r\nreturn 0;\r\n}\r\nstatic void pcs_disable(struct pinctrl_dev *pctldev, unsigned fselector,\r\nunsigned group)\r\n{\r\nstruct pcs_device *pcs;\r\nstruct pcs_function *func;\r\nint i;\r\npcs = pinctrl_dev_get_drvdata(pctldev);\r\nfunc = radix_tree_lookup(&pcs->ftree, fselector);\r\nif (!func) {\r\ndev_err(pcs->dev, "%s could not find function%i\n",\r\n__func__, fselector);\r\nreturn;\r\n}\r\nif (pcs->foff == PCS_OFF_DISABLED) {\r\ndev_dbg(pcs->dev, "ignoring disable for %s function%i\n",\r\nfunc->name, fselector);\r\nreturn;\r\n}\r\ndev_dbg(pcs->dev, "disabling function%i %s\n",\r\nfselector, func->name);\r\nfor (i = 0; i < func->nvals; i++) {\r\nstruct pcs_func_vals *vals;\r\nunsigned val;\r\nvals = &func->vals[i];\r\nval = pcs->read(vals->reg);\r\nval &= ~pcs->fmask;\r\nval |= pcs->foff << pcs->fshift;\r\npcs->write(val, vals->reg);\r\n}\r\n}\r\nstatic int pcs_request_gpio(struct pinctrl_dev *pctldev,\r\nstruct pinctrl_gpio_range *range, unsigned offset)\r\n{\r\nreturn -ENOTSUPP;\r\n}\r\nstatic int pcs_pinconf_get(struct pinctrl_dev *pctldev,\r\nunsigned pin, unsigned long *config)\r\n{\r\nreturn -ENOTSUPP;\r\n}\r\nstatic int pcs_pinconf_set(struct pinctrl_dev *pctldev,\r\nunsigned pin, unsigned long config)\r\n{\r\nreturn -ENOTSUPP;\r\n}\r\nstatic int pcs_pinconf_group_get(struct pinctrl_dev *pctldev,\r\nunsigned group, unsigned long *config)\r\n{\r\nreturn -ENOTSUPP;\r\n}\r\nstatic int pcs_pinconf_group_set(struct pinctrl_dev *pctldev,\r\nunsigned group, unsigned long config)\r\n{\r\nreturn -ENOTSUPP;\r\n}\r\nstatic void pcs_pinconf_dbg_show(struct pinctrl_dev *pctldev,\r\nstruct seq_file *s, unsigned offset)\r\n{\r\n}\r\nstatic void pcs_pinconf_group_dbg_show(struct pinctrl_dev *pctldev,\r\nstruct seq_file *s, unsigned selector)\r\n{\r\n}\r\nstatic int pcs_add_pin(struct pcs_device *pcs, unsigned offset)\r\n{\r\nstruct pinctrl_pin_desc *pin;\r\nstruct pcs_name *pn;\r\nint i;\r\ni = pcs->pins.cur;\r\nif (i >= pcs->desc.npins) {\r\ndev_err(pcs->dev, "too many pins, max %i\n",\r\npcs->desc.npins);\r\nreturn -ENOMEM;\r\n}\r\npin = &pcs->pins.pa[i];\r\npn = &pcs->names[i];\r\nsprintf(pn->name, "%lx",\r\n(unsigned long)pcs->res->start + offset);\r\npin->name = pn->name;\r\npin->number = i;\r\npcs->pins.cur++;\r\nreturn i;\r\n}\r\nstatic int pcs_allocate_pin_table(struct pcs_device *pcs)\r\n{\r\nint mux_bytes, nr_pins, i;\r\nmux_bytes = pcs->width / BITS_PER_BYTE;\r\nnr_pins = pcs->size / mux_bytes;\r\ndev_dbg(pcs->dev, "allocating %i pins\n", nr_pins);\r\npcs->pins.pa = devm_kzalloc(pcs->dev,\r\nsizeof(*pcs->pins.pa) * nr_pins,\r\nGFP_KERNEL);\r\nif (!pcs->pins.pa)\r\nreturn -ENOMEM;\r\npcs->names = devm_kzalloc(pcs->dev,\r\nsizeof(struct pcs_name) * nr_pins,\r\nGFP_KERNEL);\r\nif (!pcs->names)\r\nreturn -ENOMEM;\r\npcs->desc.pins = pcs->pins.pa;\r\npcs->desc.npins = nr_pins;\r\nfor (i = 0; i < pcs->desc.npins; i++) {\r\nunsigned offset;\r\nint res;\r\noffset = i * mux_bytes;\r\nres = pcs_add_pin(pcs, offset);\r\nif (res < 0) {\r\ndev_err(pcs->dev, "error adding pins: %i\n", res);\r\nreturn res;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic struct pcs_function *pcs_add_function(struct pcs_device *pcs,\r\nstruct device_node *np,\r\nconst char *name,\r\nstruct pcs_func_vals *vals,\r\nunsigned nvals,\r\nconst char **pgnames,\r\nunsigned npgnames)\r\n{\r\nstruct pcs_function *function;\r\nfunction = devm_kzalloc(pcs->dev, sizeof(*function), GFP_KERNEL);\r\nif (!function)\r\nreturn NULL;\r\nfunction->name = name;\r\nfunction->vals = vals;\r\nfunction->nvals = nvals;\r\nfunction->pgnames = pgnames;\r\nfunction->npgnames = npgnames;\r\nmutex_lock(&pcs->mutex);\r\nlist_add_tail(&function->node, &pcs->functions);\r\nradix_tree_insert(&pcs->ftree, pcs->nfuncs, function);\r\npcs->nfuncs++;\r\nmutex_unlock(&pcs->mutex);\r\nreturn function;\r\n}\r\nstatic void pcs_remove_function(struct pcs_device *pcs,\r\nstruct pcs_function *function)\r\n{\r\nint i;\r\nmutex_lock(&pcs->mutex);\r\nfor (i = 0; i < pcs->nfuncs; i++) {\r\nstruct pcs_function *found;\r\nfound = radix_tree_lookup(&pcs->ftree, i);\r\nif (found == function)\r\nradix_tree_delete(&pcs->ftree, i);\r\n}\r\nlist_del(&function->node);\r\nmutex_unlock(&pcs->mutex);\r\n}\r\nstatic int pcs_add_pingroup(struct pcs_device *pcs,\r\nstruct device_node *np,\r\nconst char *name,\r\nint *gpins,\r\nint ngpins)\r\n{\r\nstruct pcs_pingroup *pingroup;\r\npingroup = devm_kzalloc(pcs->dev, sizeof(*pingroup), GFP_KERNEL);\r\nif (!pingroup)\r\nreturn -ENOMEM;\r\npingroup->name = name;\r\npingroup->np = np;\r\npingroup->gpins = gpins;\r\npingroup->ngpins = ngpins;\r\nmutex_lock(&pcs->mutex);\r\nlist_add_tail(&pingroup->node, &pcs->pingroups);\r\nradix_tree_insert(&pcs->pgtree, pcs->ngroups, pingroup);\r\npcs->ngroups++;\r\nmutex_unlock(&pcs->mutex);\r\nreturn 0;\r\n}\r\nstatic int pcs_get_pin_by_offset(struct pcs_device *pcs, unsigned offset)\r\n{\r\nunsigned index;\r\nif (offset >= pcs->size) {\r\ndev_err(pcs->dev, "mux offset out of range: 0x%x (0x%x)\n",\r\noffset, pcs->size);\r\nreturn -EINVAL;\r\n}\r\nindex = offset / (pcs->width / BITS_PER_BYTE);\r\nreturn index;\r\n}\r\nstatic int pcs_parse_one_pinctrl_entry(struct pcs_device *pcs,\r\nstruct device_node *np,\r\nstruct pinctrl_map **map,\r\nconst char **pgnames)\r\n{\r\nstruct pcs_func_vals *vals;\r\nconst __be32 *mux;\r\nint size, params, rows, *pins, index = 0, found = 0, res = -ENOMEM;\r\nstruct pcs_function *function;\r\nif (pcs->bits_per_mux) {\r\nparams = 3;\r\nmux = of_get_property(np, PCS_MUX_BITS_NAME, &size);\r\n} else {\r\nparams = 2;\r\nmux = of_get_property(np, PCS_MUX_PINS_NAME, &size);\r\n}\r\nif (!mux) {\r\ndev_err(pcs->dev, "no valid property for %s\n", np->name);\r\nreturn -EINVAL;\r\n}\r\nif (size < (sizeof(*mux) * params)) {\r\ndev_err(pcs->dev, "bad data for %s\n", np->name);\r\nreturn -EINVAL;\r\n}\r\nsize /= sizeof(*mux);\r\nrows = size / params;\r\nvals = devm_kzalloc(pcs->dev, sizeof(*vals) * rows, GFP_KERNEL);\r\nif (!vals)\r\nreturn -ENOMEM;\r\npins = devm_kzalloc(pcs->dev, sizeof(*pins) * rows, GFP_KERNEL);\r\nif (!pins)\r\ngoto free_vals;\r\nwhile (index < size) {\r\nunsigned offset, val;\r\nint pin;\r\noffset = be32_to_cpup(mux + index++);\r\nval = be32_to_cpup(mux + index++);\r\nvals[found].reg = pcs->base + offset;\r\nvals[found].val = val;\r\nif (params == 3) {\r\nval = be32_to_cpup(mux + index++);\r\nvals[found].mask = val;\r\n}\r\npin = pcs_get_pin_by_offset(pcs, offset);\r\nif (pin < 0) {\r\ndev_err(pcs->dev,\r\n"could not add functions for %s %ux\n",\r\nnp->name, offset);\r\nbreak;\r\n}\r\npins[found++] = pin;\r\n}\r\npgnames[0] = np->name;\r\nfunction = pcs_add_function(pcs, np, np->name, vals, found, pgnames, 1);\r\nif (!function)\r\ngoto free_pins;\r\nres = pcs_add_pingroup(pcs, np, np->name, pins, found);\r\nif (res < 0)\r\ngoto free_function;\r\n(*map)->type = PIN_MAP_TYPE_MUX_GROUP;\r\n(*map)->data.mux.group = np->name;\r\n(*map)->data.mux.function = np->name;\r\nreturn 0;\r\nfree_function:\r\npcs_remove_function(pcs, function);\r\nfree_pins:\r\ndevm_kfree(pcs->dev, pins);\r\nfree_vals:\r\ndevm_kfree(pcs->dev, vals);\r\nreturn res;\r\n}\r\nstatic int pcs_dt_node_to_map(struct pinctrl_dev *pctldev,\r\nstruct device_node *np_config,\r\nstruct pinctrl_map **map, unsigned *num_maps)\r\n{\r\nstruct pcs_device *pcs;\r\nconst char **pgnames;\r\nint ret;\r\npcs = pinctrl_dev_get_drvdata(pctldev);\r\n*map = devm_kzalloc(pcs->dev, sizeof(**map), GFP_KERNEL);\r\nif (!*map)\r\nreturn -ENOMEM;\r\n*num_maps = 0;\r\npgnames = devm_kzalloc(pcs->dev, sizeof(*pgnames), GFP_KERNEL);\r\nif (!pgnames) {\r\nret = -ENOMEM;\r\ngoto free_map;\r\n}\r\nret = pcs_parse_one_pinctrl_entry(pcs, np_config, map, pgnames);\r\nif (ret < 0) {\r\ndev_err(pcs->dev, "no pins entries for %s\n",\r\nnp_config->name);\r\ngoto free_pgnames;\r\n}\r\n*num_maps = 1;\r\nreturn 0;\r\nfree_pgnames:\r\ndevm_kfree(pcs->dev, pgnames);\r\nfree_map:\r\ndevm_kfree(pcs->dev, *map);\r\nreturn ret;\r\n}\r\nstatic void pcs_free_funcs(struct pcs_device *pcs)\r\n{\r\nstruct list_head *pos, *tmp;\r\nint i;\r\nmutex_lock(&pcs->mutex);\r\nfor (i = 0; i < pcs->nfuncs; i++) {\r\nstruct pcs_function *func;\r\nfunc = radix_tree_lookup(&pcs->ftree, i);\r\nif (!func)\r\ncontinue;\r\nradix_tree_delete(&pcs->ftree, i);\r\n}\r\nlist_for_each_safe(pos, tmp, &pcs->functions) {\r\nstruct pcs_function *function;\r\nfunction = list_entry(pos, struct pcs_function, node);\r\nlist_del(&function->node);\r\n}\r\nmutex_unlock(&pcs->mutex);\r\n}\r\nstatic void pcs_free_pingroups(struct pcs_device *pcs)\r\n{\r\nstruct list_head *pos, *tmp;\r\nint i;\r\nmutex_lock(&pcs->mutex);\r\nfor (i = 0; i < pcs->ngroups; i++) {\r\nstruct pcs_pingroup *pingroup;\r\npingroup = radix_tree_lookup(&pcs->pgtree, i);\r\nif (!pingroup)\r\ncontinue;\r\nradix_tree_delete(&pcs->pgtree, i);\r\n}\r\nlist_for_each_safe(pos, tmp, &pcs->pingroups) {\r\nstruct pcs_pingroup *pingroup;\r\npingroup = list_entry(pos, struct pcs_pingroup, node);\r\nlist_del(&pingroup->node);\r\n}\r\nmutex_unlock(&pcs->mutex);\r\n}\r\nstatic void pcs_free_resources(struct pcs_device *pcs)\r\n{\r\nif (pcs->pctl)\r\npinctrl_unregister(pcs->pctl);\r\npcs_free_funcs(pcs);\r\npcs_free_pingroups(pcs);\r\n}\r\nstatic int pcs_probe(struct platform_device *pdev)\r\n{\r\nstruct device_node *np = pdev->dev.of_node;\r\nconst struct of_device_id *match;\r\nstruct resource *res;\r\nstruct pcs_device *pcs;\r\nint ret;\r\nmatch = of_match_device(pcs_of_match, &pdev->dev);\r\nif (!match)\r\nreturn -EINVAL;\r\npcs = devm_kzalloc(&pdev->dev, sizeof(*pcs), GFP_KERNEL);\r\nif (!pcs) {\r\ndev_err(&pdev->dev, "could not allocate\n");\r\nreturn -ENOMEM;\r\n}\r\npcs->dev = &pdev->dev;\r\nmutex_init(&pcs->mutex);\r\nINIT_LIST_HEAD(&pcs->pingroups);\r\nINIT_LIST_HEAD(&pcs->functions);\r\nPCS_GET_PROP_U32("pinctrl-single,register-width", &pcs->width,\r\n"register width not specified\n");\r\nPCS_GET_PROP_U32("pinctrl-single,function-mask", &pcs->fmask,\r\n"function register mask not specified\n");\r\npcs->fshift = ffs(pcs->fmask) - 1;\r\npcs->fmax = pcs->fmask >> pcs->fshift;\r\nret = of_property_read_u32(np, "pinctrl-single,function-off",\r\n&pcs->foff);\r\nif (ret)\r\npcs->foff = PCS_OFF_DISABLED;\r\npcs->bits_per_mux = of_property_read_bool(np,\r\n"pinctrl-single,bit-per-mux");\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!res) {\r\ndev_err(pcs->dev, "could not get resource\n");\r\nreturn -ENODEV;\r\n}\r\npcs->res = devm_request_mem_region(pcs->dev, res->start,\r\nresource_size(res), DRIVER_NAME);\r\nif (!pcs->res) {\r\ndev_err(pcs->dev, "could not get mem_region\n");\r\nreturn -EBUSY;\r\n}\r\npcs->size = resource_size(pcs->res);\r\npcs->base = devm_ioremap(pcs->dev, pcs->res->start, pcs->size);\r\nif (!pcs->base) {\r\ndev_err(pcs->dev, "could not ioremap\n");\r\nreturn -ENODEV;\r\n}\r\nINIT_RADIX_TREE(&pcs->pgtree, GFP_KERNEL);\r\nINIT_RADIX_TREE(&pcs->ftree, GFP_KERNEL);\r\nplatform_set_drvdata(pdev, pcs);\r\nswitch (pcs->width) {\r\ncase 8:\r\npcs->read = pcs_readb;\r\npcs->write = pcs_writeb;\r\nbreak;\r\ncase 16:\r\npcs->read = pcs_readw;\r\npcs->write = pcs_writew;\r\nbreak;\r\ncase 32:\r\npcs->read = pcs_readl;\r\npcs->write = pcs_writel;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\npcs->desc.name = DRIVER_NAME;\r\npcs->desc.pctlops = &pcs_pinctrl_ops;\r\npcs->desc.pmxops = &pcs_pinmux_ops;\r\npcs->desc.confops = &pcs_pinconf_ops;\r\npcs->desc.owner = THIS_MODULE;\r\nret = pcs_allocate_pin_table(pcs);\r\nif (ret < 0)\r\ngoto free;\r\npcs->pctl = pinctrl_register(&pcs->desc, pcs->dev, pcs);\r\nif (!pcs->pctl) {\r\ndev_err(pcs->dev, "could not register single pinctrl driver\n");\r\nret = -EINVAL;\r\ngoto free;\r\n}\r\ndev_info(pcs->dev, "%i pins at pa %p size %u\n",\r\npcs->desc.npins, pcs->base, pcs->size);\r\nreturn 0;\r\nfree:\r\npcs_free_resources(pcs);\r\nreturn ret;\r\n}\r\nstatic int pcs_remove(struct platform_device *pdev)\r\n{\r\nstruct pcs_device *pcs = platform_get_drvdata(pdev);\r\nif (!pcs)\r\nreturn 0;\r\npcs_free_resources(pcs);\r\nreturn 0;\r\n}
