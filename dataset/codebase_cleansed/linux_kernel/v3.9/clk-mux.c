static u8 clk_mux_get_parent(struct clk_hw *hw)\r\n{\r\nstruct clk_mux *mux = to_clk_mux(hw);\r\nu32 val;\r\nval = readl(mux->reg) >> mux->shift;\r\nval &= (1 << mux->width) - 1;\r\nif (val && (mux->flags & CLK_MUX_INDEX_BIT))\r\nval = ffs(val) - 1;\r\nif (val && (mux->flags & CLK_MUX_INDEX_ONE))\r\nval--;\r\nif (val >= __clk_get_num_parents(hw->clk))\r\nreturn -EINVAL;\r\nreturn val;\r\n}\r\nstatic int clk_mux_set_parent(struct clk_hw *hw, u8 index)\r\n{\r\nstruct clk_mux *mux = to_clk_mux(hw);\r\nu32 val;\r\nunsigned long flags = 0;\r\nif (mux->flags & CLK_MUX_INDEX_BIT)\r\nindex = (1 << ffs(index));\r\nif (mux->flags & CLK_MUX_INDEX_ONE)\r\nindex++;\r\nif (mux->lock)\r\nspin_lock_irqsave(mux->lock, flags);\r\nval = readl(mux->reg);\r\nval &= ~(((1 << mux->width) - 1) << mux->shift);\r\nval |= index << mux->shift;\r\nwritel(val, mux->reg);\r\nif (mux->lock)\r\nspin_unlock_irqrestore(mux->lock, flags);\r\nreturn 0;\r\n}\r\nstruct clk *clk_register_mux(struct device *dev, const char *name,\r\nconst char **parent_names, u8 num_parents, unsigned long flags,\r\nvoid __iomem *reg, u8 shift, u8 width,\r\nu8 clk_mux_flags, spinlock_t *lock)\r\n{\r\nstruct clk_mux *mux;\r\nstruct clk *clk;\r\nstruct clk_init_data init;\r\nmux = kzalloc(sizeof(struct clk_mux), GFP_KERNEL);\r\nif (!mux) {\r\npr_err("%s: could not allocate mux clk\n", __func__);\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\ninit.name = name;\r\ninit.ops = &clk_mux_ops;\r\ninit.flags = flags | CLK_IS_BASIC;\r\ninit.parent_names = parent_names;\r\ninit.num_parents = num_parents;\r\nmux->reg = reg;\r\nmux->shift = shift;\r\nmux->width = width;\r\nmux->flags = clk_mux_flags;\r\nmux->lock = lock;\r\nmux->hw.init = &init;\r\nclk = clk_register(dev, &mux->hw);\r\nif (IS_ERR(clk))\r\nkfree(mux);\r\nreturn clk;\r\n}
