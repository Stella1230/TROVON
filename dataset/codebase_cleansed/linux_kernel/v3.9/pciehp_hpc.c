static inline int pciehp_readw(struct controller *ctrl, int reg, u16 *value)\r\n{\r\nstruct pci_dev *dev = ctrl->pcie->port;\r\nreturn pcie_capability_read_word(dev, reg, value);\r\n}\r\nstatic inline int pciehp_readl(struct controller *ctrl, int reg, u32 *value)\r\n{\r\nstruct pci_dev *dev = ctrl->pcie->port;\r\nreturn pcie_capability_read_dword(dev, reg, value);\r\n}\r\nstatic inline int pciehp_writew(struct controller *ctrl, int reg, u16 value)\r\n{\r\nstruct pci_dev *dev = ctrl->pcie->port;\r\nreturn pcie_capability_write_word(dev, reg, value);\r\n}\r\nstatic inline int pciehp_writel(struct controller *ctrl, int reg, u32 value)\r\n{\r\nstruct pci_dev *dev = ctrl->pcie->port;\r\nreturn pcie_capability_write_dword(dev, reg, value);\r\n}\r\nstatic void int_poll_timeout(unsigned long data)\r\n{\r\nstruct controller *ctrl = (struct controller *)data;\r\npcie_isr(0, ctrl);\r\ninit_timer(&ctrl->poll_timer);\r\nif (!pciehp_poll_time)\r\npciehp_poll_time = 2;\r\nstart_int_poll_timer(ctrl, pciehp_poll_time);\r\n}\r\nstatic void start_int_poll_timer(struct controller *ctrl, int sec)\r\n{\r\nif ((sec <= 0) || (sec > 60))\r\nsec = 2;\r\nctrl->poll_timer.function = &int_poll_timeout;\r\nctrl->poll_timer.data = (unsigned long)ctrl;\r\nctrl->poll_timer.expires = jiffies + sec * HZ;\r\nadd_timer(&ctrl->poll_timer);\r\n}\r\nstatic inline int pciehp_request_irq(struct controller *ctrl)\r\n{\r\nint retval, irq = ctrl->pcie->irq;\r\nif (pciehp_poll_mode) {\r\ninit_timer(&ctrl->poll_timer);\r\nstart_int_poll_timer(ctrl, 10);\r\nreturn 0;\r\n}\r\nretval = request_irq(irq, pcie_isr, IRQF_SHARED, MY_NAME, ctrl);\r\nif (retval)\r\nctrl_err(ctrl, "Cannot get irq %d for the hotplug controller\n",\r\nirq);\r\nreturn retval;\r\n}\r\nstatic inline void pciehp_free_irq(struct controller *ctrl)\r\n{\r\nif (pciehp_poll_mode)\r\ndel_timer_sync(&ctrl->poll_timer);\r\nelse\r\nfree_irq(ctrl->pcie->irq, ctrl);\r\n}\r\nstatic int pcie_poll_cmd(struct controller *ctrl)\r\n{\r\nu16 slot_status;\r\nint err, timeout = 1000;\r\nerr = pciehp_readw(ctrl, PCI_EXP_SLTSTA, &slot_status);\r\nif (!err && (slot_status & PCI_EXP_SLTSTA_CC)) {\r\npciehp_writew(ctrl, PCI_EXP_SLTSTA, PCI_EXP_SLTSTA_CC);\r\nreturn 1;\r\n}\r\nwhile (timeout > 0) {\r\nmsleep(10);\r\ntimeout -= 10;\r\nerr = pciehp_readw(ctrl, PCI_EXP_SLTSTA, &slot_status);\r\nif (!err && (slot_status & PCI_EXP_SLTSTA_CC)) {\r\npciehp_writew(ctrl, PCI_EXP_SLTSTA, PCI_EXP_SLTSTA_CC);\r\nreturn 1;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void pcie_wait_cmd(struct controller *ctrl, int poll)\r\n{\r\nunsigned int msecs = pciehp_poll_mode ? 2500 : 1000;\r\nunsigned long timeout = msecs_to_jiffies(msecs);\r\nint rc;\r\nif (poll)\r\nrc = pcie_poll_cmd(ctrl);\r\nelse\r\nrc = wait_event_timeout(ctrl->queue, !ctrl->cmd_busy, timeout);\r\nif (!rc)\r\nctrl_dbg(ctrl, "Command not completed in 1000 msec\n");\r\n}\r\nstatic int pcie_write_cmd(struct controller *ctrl, u16 cmd, u16 mask)\r\n{\r\nint retval = 0;\r\nu16 slot_status;\r\nu16 slot_ctrl;\r\nmutex_lock(&ctrl->ctrl_lock);\r\nretval = pciehp_readw(ctrl, PCI_EXP_SLTSTA, &slot_status);\r\nif (retval) {\r\nctrl_err(ctrl, "%s: Cannot read SLOTSTATUS register\n",\r\n__func__);\r\ngoto out;\r\n}\r\nif (slot_status & PCI_EXP_SLTSTA_CC) {\r\nif (!ctrl->no_cmd_complete) {\r\nctrl_dbg(ctrl, "CMD_COMPLETED not clear after 1 sec\n");\r\n} else if (!NO_CMD_CMPL(ctrl)) {\r\nctrl_dbg(ctrl, "Unexpected CMD_COMPLETED. Need to "\r\n"wait for command completed event.\n");\r\nctrl->no_cmd_complete = 0;\r\n} else {\r\nctrl_dbg(ctrl, "Unexpected CMD_COMPLETED. Maybe "\r\n"the controller is broken.\n");\r\n}\r\n}\r\nretval = pciehp_readw(ctrl, PCI_EXP_SLTCTL, &slot_ctrl);\r\nif (retval) {\r\nctrl_err(ctrl, "%s: Cannot read SLOTCTRL register\n", __func__);\r\ngoto out;\r\n}\r\nslot_ctrl &= ~mask;\r\nslot_ctrl |= (cmd & mask);\r\nctrl->cmd_busy = 1;\r\nsmp_mb();\r\nretval = pciehp_writew(ctrl, PCI_EXP_SLTCTL, slot_ctrl);\r\nif (retval)\r\nctrl_err(ctrl, "Cannot write to SLOTCTRL register\n");\r\nif (!retval && !ctrl->no_cmd_complete) {\r\nint poll = 0;\r\nif (!(slot_ctrl & PCI_EXP_SLTCTL_HPIE) ||\r\n!(slot_ctrl & PCI_EXP_SLTCTL_CCIE))\r\npoll = 1;\r\npcie_wait_cmd(ctrl, poll);\r\n}\r\nout:\r\nmutex_unlock(&ctrl->ctrl_lock);\r\nreturn retval;\r\n}\r\nstatic bool check_link_active(struct controller *ctrl)\r\n{\r\nbool ret = false;\r\nu16 lnk_status;\r\nif (pciehp_readw(ctrl, PCI_EXP_LNKSTA, &lnk_status))\r\nreturn ret;\r\nret = !!(lnk_status & PCI_EXP_LNKSTA_DLLLA);\r\nif (ret)\r\nctrl_dbg(ctrl, "%s: lnk_status = %x\n", __func__, lnk_status);\r\nreturn ret;\r\n}\r\nstatic void __pcie_wait_link_active(struct controller *ctrl, bool active)\r\n{\r\nint timeout = 1000;\r\nif (check_link_active(ctrl) == active)\r\nreturn;\r\nwhile (timeout > 0) {\r\nmsleep(10);\r\ntimeout -= 10;\r\nif (check_link_active(ctrl) == active)\r\nreturn;\r\n}\r\nctrl_dbg(ctrl, "Data Link Layer Link Active not %s in 1000 msec\n",\r\nactive ? "set" : "cleared");\r\n}\r\nstatic void pcie_wait_link_active(struct controller *ctrl)\r\n{\r\n__pcie_wait_link_active(ctrl, true);\r\n}\r\nstatic void pcie_wait_link_not_active(struct controller *ctrl)\r\n{\r\n__pcie_wait_link_active(ctrl, false);\r\n}\r\nstatic bool pci_bus_check_dev(struct pci_bus *bus, int devfn)\r\n{\r\nu32 l;\r\nint count = 0;\r\nint delay = 1000, step = 20;\r\nbool found = false;\r\ndo {\r\nfound = pci_bus_read_dev_vendor_id(bus, devfn, &l, 0);\r\ncount++;\r\nif (found)\r\nbreak;\r\nmsleep(step);\r\ndelay -= step;\r\n} while (delay > 0);\r\nif (count > 1 && pciehp_debug)\r\nprintk(KERN_DEBUG "pci %04x:%02x:%02x.%d id reading try %d times with interval %d ms to get %08x\n",\r\npci_domain_nr(bus), bus->number, PCI_SLOT(devfn),\r\nPCI_FUNC(devfn), count, step, l);\r\nreturn found;\r\n}\r\nint pciehp_check_link_status(struct controller *ctrl)\r\n{\r\nu16 lnk_status;\r\nint retval = 0;\r\nbool found = false;\r\nif (ctrl->link_active_reporting)\r\npcie_wait_link_active(ctrl);\r\nelse\r\nmsleep(1000);\r\nmsleep(100);\r\nfound = pci_bus_check_dev(ctrl->pcie->port->subordinate,\r\nPCI_DEVFN(0, 0));\r\nretval = pciehp_readw(ctrl, PCI_EXP_LNKSTA, &lnk_status);\r\nif (retval) {\r\nctrl_err(ctrl, "Cannot read LNKSTATUS register\n");\r\nreturn retval;\r\n}\r\nctrl_dbg(ctrl, "%s: lnk_status = %x\n", __func__, lnk_status);\r\nif ((lnk_status & PCI_EXP_LNKSTA_LT) ||\r\n!(lnk_status & PCI_EXP_LNKSTA_NLW)) {\r\nctrl_err(ctrl, "Link Training Error occurs \n");\r\nretval = -1;\r\nreturn retval;\r\n}\r\npcie_update_link_speed(ctrl->pcie->port->subordinate, lnk_status);\r\nif (!found && !retval)\r\nretval = -1;\r\nreturn retval;\r\n}\r\nstatic int __pciehp_link_set(struct controller *ctrl, bool enable)\r\n{\r\nu16 lnk_ctrl;\r\nint retval = 0;\r\nretval = pciehp_readw(ctrl, PCI_EXP_LNKCTL, &lnk_ctrl);\r\nif (retval) {\r\nctrl_err(ctrl, "Cannot read LNKCTRL register\n");\r\nreturn retval;\r\n}\r\nif (enable)\r\nlnk_ctrl &= ~PCI_EXP_LNKCTL_LD;\r\nelse\r\nlnk_ctrl |= PCI_EXP_LNKCTL_LD;\r\nretval = pciehp_writew(ctrl, PCI_EXP_LNKCTL, lnk_ctrl);\r\nif (retval) {\r\nctrl_err(ctrl, "Cannot write LNKCTRL register\n");\r\nreturn retval;\r\n}\r\nctrl_dbg(ctrl, "%s: lnk_ctrl = %x\n", __func__, lnk_ctrl);\r\nreturn retval;\r\n}\r\nstatic int pciehp_link_enable(struct controller *ctrl)\r\n{\r\nreturn __pciehp_link_set(ctrl, true);\r\n}\r\nstatic int pciehp_link_disable(struct controller *ctrl)\r\n{\r\nreturn __pciehp_link_set(ctrl, false);\r\n}\r\nint pciehp_get_attention_status(struct slot *slot, u8 *status)\r\n{\r\nstruct controller *ctrl = slot->ctrl;\r\nu16 slot_ctrl;\r\nu8 atten_led_state;\r\nint retval = 0;\r\nretval = pciehp_readw(ctrl, PCI_EXP_SLTCTL, &slot_ctrl);\r\nif (retval) {\r\nctrl_err(ctrl, "%s: Cannot read SLOTCTRL register\n", __func__);\r\nreturn retval;\r\n}\r\nctrl_dbg(ctrl, "%s: SLOTCTRL %x, value read %x\n", __func__,\r\npci_pcie_cap(ctrl->pcie->port) + PCI_EXP_SLTCTL, slot_ctrl);\r\natten_led_state = (slot_ctrl & PCI_EXP_SLTCTL_AIC) >> 6;\r\nswitch (atten_led_state) {\r\ncase 0:\r\n*status = 0xFF;\r\nbreak;\r\ncase 1:\r\n*status = 1;\r\nbreak;\r\ncase 2:\r\n*status = 2;\r\nbreak;\r\ncase 3:\r\n*status = 0;\r\nbreak;\r\ndefault:\r\n*status = 0xFF;\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nint pciehp_get_power_status(struct slot *slot, u8 *status)\r\n{\r\nstruct controller *ctrl = slot->ctrl;\r\nu16 slot_ctrl;\r\nu8 pwr_state;\r\nint retval = 0;\r\nretval = pciehp_readw(ctrl, PCI_EXP_SLTCTL, &slot_ctrl);\r\nif (retval) {\r\nctrl_err(ctrl, "%s: Cannot read SLOTCTRL register\n", __func__);\r\nreturn retval;\r\n}\r\nctrl_dbg(ctrl, "%s: SLOTCTRL %x value read %x\n", __func__,\r\npci_pcie_cap(ctrl->pcie->port) + PCI_EXP_SLTCTL, slot_ctrl);\r\npwr_state = (slot_ctrl & PCI_EXP_SLTCTL_PCC) >> 10;\r\nswitch (pwr_state) {\r\ncase 0:\r\n*status = 1;\r\nbreak;\r\ncase 1:\r\n*status = 0;\r\nbreak;\r\ndefault:\r\n*status = 0xFF;\r\nbreak;\r\n}\r\nreturn retval;\r\n}\r\nint pciehp_get_latch_status(struct slot *slot, u8 *status)\r\n{\r\nstruct controller *ctrl = slot->ctrl;\r\nu16 slot_status;\r\nint retval;\r\nretval = pciehp_readw(ctrl, PCI_EXP_SLTSTA, &slot_status);\r\nif (retval) {\r\nctrl_err(ctrl, "%s: Cannot read SLOTSTATUS register\n",\r\n__func__);\r\nreturn retval;\r\n}\r\n*status = !!(slot_status & PCI_EXP_SLTSTA_MRLSS);\r\nreturn 0;\r\n}\r\nint pciehp_get_adapter_status(struct slot *slot, u8 *status)\r\n{\r\nstruct controller *ctrl = slot->ctrl;\r\nu16 slot_status;\r\nint retval;\r\nretval = pciehp_readw(ctrl, PCI_EXP_SLTSTA, &slot_status);\r\nif (retval) {\r\nctrl_err(ctrl, "%s: Cannot read SLOTSTATUS register\n",\r\n__func__);\r\nreturn retval;\r\n}\r\n*status = !!(slot_status & PCI_EXP_SLTSTA_PDS);\r\nreturn 0;\r\n}\r\nint pciehp_query_power_fault(struct slot *slot)\r\n{\r\nstruct controller *ctrl = slot->ctrl;\r\nu16 slot_status;\r\nint retval;\r\nretval = pciehp_readw(ctrl, PCI_EXP_SLTSTA, &slot_status);\r\nif (retval) {\r\nctrl_err(ctrl, "Cannot check for power fault\n");\r\nreturn retval;\r\n}\r\nreturn !!(slot_status & PCI_EXP_SLTSTA_PFD);\r\n}\r\nint pciehp_set_attention_status(struct slot *slot, u8 value)\r\n{\r\nstruct controller *ctrl = slot->ctrl;\r\nu16 slot_cmd;\r\nu16 cmd_mask;\r\ncmd_mask = PCI_EXP_SLTCTL_AIC;\r\nswitch (value) {\r\ncase 0 :\r\nslot_cmd = 0x00C0;\r\nbreak;\r\ncase 1:\r\nslot_cmd = 0x0040;\r\nbreak;\r\ncase 2:\r\nslot_cmd = 0x0080;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nctrl_dbg(ctrl, "%s: SLOTCTRL %x write cmd %x\n", __func__,\r\npci_pcie_cap(ctrl->pcie->port) + PCI_EXP_SLTCTL, slot_cmd);\r\nreturn pcie_write_cmd(ctrl, slot_cmd, cmd_mask);\r\n}\r\nvoid pciehp_green_led_on(struct slot *slot)\r\n{\r\nstruct controller *ctrl = slot->ctrl;\r\nu16 slot_cmd;\r\nu16 cmd_mask;\r\nslot_cmd = 0x0100;\r\ncmd_mask = PCI_EXP_SLTCTL_PIC;\r\npcie_write_cmd(ctrl, slot_cmd, cmd_mask);\r\nctrl_dbg(ctrl, "%s: SLOTCTRL %x write cmd %x\n", __func__,\r\npci_pcie_cap(ctrl->pcie->port) + PCI_EXP_SLTCTL, slot_cmd);\r\n}\r\nvoid pciehp_green_led_off(struct slot *slot)\r\n{\r\nstruct controller *ctrl = slot->ctrl;\r\nu16 slot_cmd;\r\nu16 cmd_mask;\r\nslot_cmd = 0x0300;\r\ncmd_mask = PCI_EXP_SLTCTL_PIC;\r\npcie_write_cmd(ctrl, slot_cmd, cmd_mask);\r\nctrl_dbg(ctrl, "%s: SLOTCTRL %x write cmd %x\n", __func__,\r\npci_pcie_cap(ctrl->pcie->port) + PCI_EXP_SLTCTL, slot_cmd);\r\n}\r\nvoid pciehp_green_led_blink(struct slot *slot)\r\n{\r\nstruct controller *ctrl = slot->ctrl;\r\nu16 slot_cmd;\r\nu16 cmd_mask;\r\nslot_cmd = 0x0200;\r\ncmd_mask = PCI_EXP_SLTCTL_PIC;\r\npcie_write_cmd(ctrl, slot_cmd, cmd_mask);\r\nctrl_dbg(ctrl, "%s: SLOTCTRL %x write cmd %x\n", __func__,\r\npci_pcie_cap(ctrl->pcie->port) + PCI_EXP_SLTCTL, slot_cmd);\r\n}\r\nint pciehp_power_on_slot(struct slot * slot)\r\n{\r\nstruct controller *ctrl = slot->ctrl;\r\nu16 slot_cmd;\r\nu16 cmd_mask;\r\nu16 slot_status;\r\nint retval = 0;\r\nretval = pciehp_readw(ctrl, PCI_EXP_SLTSTA, &slot_status);\r\nif (retval) {\r\nctrl_err(ctrl, "%s: Cannot read SLOTSTATUS register\n",\r\n__func__);\r\nreturn retval;\r\n}\r\nslot_status &= PCI_EXP_SLTSTA_PFD;\r\nif (slot_status) {\r\nretval = pciehp_writew(ctrl, PCI_EXP_SLTSTA, slot_status);\r\nif (retval) {\r\nctrl_err(ctrl,\r\n"%s: Cannot write to SLOTSTATUS register\n",\r\n__func__);\r\nreturn retval;\r\n}\r\n}\r\nctrl->power_fault_detected = 0;\r\nslot_cmd = POWER_ON;\r\ncmd_mask = PCI_EXP_SLTCTL_PCC;\r\nretval = pcie_write_cmd(ctrl, slot_cmd, cmd_mask);\r\nif (retval) {\r\nctrl_err(ctrl, "Write %x command failed!\n", slot_cmd);\r\nreturn retval;\r\n}\r\nctrl_dbg(ctrl, "%s: SLOTCTRL %x write cmd %x\n", __func__,\r\npci_pcie_cap(ctrl->pcie->port) + PCI_EXP_SLTCTL, slot_cmd);\r\nretval = pciehp_link_enable(ctrl);\r\nif (retval)\r\nctrl_err(ctrl, "%s: Can not enable the link!\n", __func__);\r\nreturn retval;\r\n}\r\nint pciehp_power_off_slot(struct slot * slot)\r\n{\r\nstruct controller *ctrl = slot->ctrl;\r\nu16 slot_cmd;\r\nu16 cmd_mask;\r\nint retval;\r\npciehp_link_disable(ctrl);\r\nif (ctrl->link_active_reporting)\r\npcie_wait_link_not_active(ctrl);\r\nelse\r\nmsleep(1000);\r\nslot_cmd = POWER_OFF;\r\ncmd_mask = PCI_EXP_SLTCTL_PCC;\r\nretval = pcie_write_cmd(ctrl, slot_cmd, cmd_mask);\r\nif (retval) {\r\nctrl_err(ctrl, "Write command failed!\n");\r\nreturn retval;\r\n}\r\nctrl_dbg(ctrl, "%s: SLOTCTRL %x write cmd %x\n", __func__,\r\npci_pcie_cap(ctrl->pcie->port) + PCI_EXP_SLTCTL, slot_cmd);\r\nreturn 0;\r\n}\r\nstatic irqreturn_t pcie_isr(int irq, void *dev_id)\r\n{\r\nstruct controller *ctrl = (struct controller *)dev_id;\r\nstruct slot *slot = ctrl->slot;\r\nu16 detected, intr_loc;\r\nintr_loc = 0;\r\ndo {\r\nif (pciehp_readw(ctrl, PCI_EXP_SLTSTA, &detected)) {\r\nctrl_err(ctrl, "%s: Cannot read SLOTSTATUS\n",\r\n__func__);\r\nreturn IRQ_NONE;\r\n}\r\ndetected &= (PCI_EXP_SLTSTA_ABP | PCI_EXP_SLTSTA_PFD |\r\nPCI_EXP_SLTSTA_MRLSC | PCI_EXP_SLTSTA_PDC |\r\nPCI_EXP_SLTSTA_CC);\r\ndetected &= ~intr_loc;\r\nintr_loc |= detected;\r\nif (!intr_loc)\r\nreturn IRQ_NONE;\r\nif (detected && pciehp_writew(ctrl, PCI_EXP_SLTSTA, intr_loc)) {\r\nctrl_err(ctrl, "%s: Cannot write to SLOTSTATUS\n",\r\n__func__);\r\nreturn IRQ_NONE;\r\n}\r\n} while (detected);\r\nctrl_dbg(ctrl, "%s: intr_loc %x\n", __func__, intr_loc);\r\nif (intr_loc & PCI_EXP_SLTSTA_CC) {\r\nctrl->cmd_busy = 0;\r\nsmp_mb();\r\nwake_up(&ctrl->queue);\r\n}\r\nif (!(intr_loc & ~PCI_EXP_SLTSTA_CC))\r\nreturn IRQ_HANDLED;\r\nif (intr_loc & PCI_EXP_SLTSTA_MRLSC)\r\npciehp_handle_switch_change(slot);\r\nif (intr_loc & PCI_EXP_SLTSTA_ABP)\r\npciehp_handle_attention_button(slot);\r\nif (intr_loc & PCI_EXP_SLTSTA_PDC)\r\npciehp_handle_presence_change(slot);\r\nif ((intr_loc & PCI_EXP_SLTSTA_PFD) && !ctrl->power_fault_detected) {\r\nctrl->power_fault_detected = 1;\r\npciehp_handle_power_fault(slot);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nint pcie_enable_notification(struct controller *ctrl)\r\n{\r\nu16 cmd, mask;\r\ncmd = PCI_EXP_SLTCTL_PDCE;\r\nif (ATTN_BUTTN(ctrl))\r\ncmd |= PCI_EXP_SLTCTL_ABPE;\r\nif (MRL_SENS(ctrl))\r\ncmd |= PCI_EXP_SLTCTL_MRLSCE;\r\nif (!pciehp_poll_mode)\r\ncmd |= PCI_EXP_SLTCTL_HPIE | PCI_EXP_SLTCTL_CCIE;\r\nmask = (PCI_EXP_SLTCTL_PDCE | PCI_EXP_SLTCTL_ABPE |\r\nPCI_EXP_SLTCTL_MRLSCE | PCI_EXP_SLTCTL_PFDE |\r\nPCI_EXP_SLTCTL_HPIE | PCI_EXP_SLTCTL_CCIE);\r\nif (pcie_write_cmd(ctrl, cmd, mask)) {\r\nctrl_err(ctrl, "Cannot enable software notification\n");\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic void pcie_disable_notification(struct controller *ctrl)\r\n{\r\nu16 mask;\r\nmask = (PCI_EXP_SLTCTL_PDCE | PCI_EXP_SLTCTL_ABPE |\r\nPCI_EXP_SLTCTL_MRLSCE | PCI_EXP_SLTCTL_PFDE |\r\nPCI_EXP_SLTCTL_HPIE | PCI_EXP_SLTCTL_CCIE |\r\nPCI_EXP_SLTCTL_DLLSCE);\r\nif (pcie_write_cmd(ctrl, 0, mask))\r\nctrl_warn(ctrl, "Cannot disable software notification\n");\r\n}\r\nint pcie_init_notification(struct controller *ctrl)\r\n{\r\nif (pciehp_request_irq(ctrl))\r\nreturn -1;\r\nif (pcie_enable_notification(ctrl)) {\r\npciehp_free_irq(ctrl);\r\nreturn -1;\r\n}\r\nctrl->notification_enabled = 1;\r\nreturn 0;\r\n}\r\nstatic void pcie_shutdown_notification(struct controller *ctrl)\r\n{\r\nif (ctrl->notification_enabled) {\r\npcie_disable_notification(ctrl);\r\npciehp_free_irq(ctrl);\r\nctrl->notification_enabled = 0;\r\n}\r\n}\r\nstatic int pcie_init_slot(struct controller *ctrl)\r\n{\r\nstruct slot *slot;\r\nchar name[32];\r\nslot = kzalloc(sizeof(*slot), GFP_KERNEL);\r\nif (!slot)\r\nreturn -ENOMEM;\r\nsnprintf(name, sizeof(name), "pciehp-%u", PSN(ctrl));\r\nslot->wq = alloc_workqueue(name, 0, 0);\r\nif (!slot->wq)\r\ngoto abort;\r\nslot->ctrl = ctrl;\r\nmutex_init(&slot->lock);\r\nINIT_DELAYED_WORK(&slot->work, pciehp_queue_pushbutton_work);\r\nctrl->slot = slot;\r\nreturn 0;\r\nabort:\r\nkfree(slot);\r\nreturn -ENOMEM;\r\n}\r\nstatic void pcie_cleanup_slot(struct controller *ctrl)\r\n{\r\nstruct slot *slot = ctrl->slot;\r\ncancel_delayed_work(&slot->work);\r\ndestroy_workqueue(slot->wq);\r\nkfree(slot);\r\n}\r\nstatic inline void dbg_ctrl(struct controller *ctrl)\r\n{\r\nint i;\r\nu16 reg16;\r\nstruct pci_dev *pdev = ctrl->pcie->port;\r\nif (!pciehp_debug)\r\nreturn;\r\nctrl_info(ctrl, "Hotplug Controller:\n");\r\nctrl_info(ctrl, " Seg/Bus/Dev/Func/IRQ : %s IRQ %d\n",\r\npci_name(pdev), pdev->irq);\r\nctrl_info(ctrl, " Vendor ID : 0x%04x\n", pdev->vendor);\r\nctrl_info(ctrl, " Device ID : 0x%04x\n", pdev->device);\r\nctrl_info(ctrl, " Subsystem ID : 0x%04x\n",\r\npdev->subsystem_device);\r\nctrl_info(ctrl, " Subsystem Vendor ID : 0x%04x\n",\r\npdev->subsystem_vendor);\r\nctrl_info(ctrl, " PCIe Cap offset : 0x%02x\n",\r\npci_pcie_cap(pdev));\r\nfor (i = 0; i < DEVICE_COUNT_RESOURCE; i++) {\r\nif (!pci_resource_len(pdev, i))\r\ncontinue;\r\nctrl_info(ctrl, " PCI resource [%d] : %pR\n",\r\ni, &pdev->resource[i]);\r\n}\r\nctrl_info(ctrl, "Slot Capabilities : 0x%08x\n", ctrl->slot_cap);\r\nctrl_info(ctrl, " Physical Slot Number : %d\n", PSN(ctrl));\r\nctrl_info(ctrl, " Attention Button : %3s\n",\r\nATTN_BUTTN(ctrl) ? "yes" : "no");\r\nctrl_info(ctrl, " Power Controller : %3s\n",\r\nPOWER_CTRL(ctrl) ? "yes" : "no");\r\nctrl_info(ctrl, " MRL Sensor : %3s\n",\r\nMRL_SENS(ctrl) ? "yes" : "no");\r\nctrl_info(ctrl, " Attention Indicator : %3s\n",\r\nATTN_LED(ctrl) ? "yes" : "no");\r\nctrl_info(ctrl, " Power Indicator : %3s\n",\r\nPWR_LED(ctrl) ? "yes" : "no");\r\nctrl_info(ctrl, " Hot-Plug Surprise : %3s\n",\r\nHP_SUPR_RM(ctrl) ? "yes" : "no");\r\nctrl_info(ctrl, " EMI Present : %3s\n",\r\nEMI(ctrl) ? "yes" : "no");\r\nctrl_info(ctrl, " Command Completed : %3s\n",\r\nNO_CMD_CMPL(ctrl) ? "no" : "yes");\r\npciehp_readw(ctrl, PCI_EXP_SLTSTA, &reg16);\r\nctrl_info(ctrl, "Slot Status : 0x%04x\n", reg16);\r\npciehp_readw(ctrl, PCI_EXP_SLTCTL, &reg16);\r\nctrl_info(ctrl, "Slot Control : 0x%04x\n", reg16);\r\n}\r\nstruct controller *pcie_init(struct pcie_device *dev)\r\n{\r\nstruct controller *ctrl;\r\nu32 slot_cap, link_cap;\r\nstruct pci_dev *pdev = dev->port;\r\nctrl = kzalloc(sizeof(*ctrl), GFP_KERNEL);\r\nif (!ctrl) {\r\ndev_err(&dev->device, "%s: Out of memory\n", __func__);\r\ngoto abort;\r\n}\r\nctrl->pcie = dev;\r\nif (pciehp_readl(ctrl, PCI_EXP_SLTCAP, &slot_cap)) {\r\nctrl_err(ctrl, "Cannot read SLOTCAP register\n");\r\ngoto abort_ctrl;\r\n}\r\nctrl->slot_cap = slot_cap;\r\nmutex_init(&ctrl->ctrl_lock);\r\ninit_waitqueue_head(&ctrl->queue);\r\ndbg_ctrl(ctrl);\r\nif (NO_CMD_CMPL(ctrl) ||\r\n!(POWER_CTRL(ctrl) | ATTN_LED(ctrl) | PWR_LED(ctrl) | EMI(ctrl)))\r\nctrl->no_cmd_complete = 1;\r\nif (pciehp_readl(ctrl, PCI_EXP_LNKCAP, &link_cap)) {\r\nctrl_err(ctrl, "%s: Cannot read LNKCAP register\n", __func__);\r\ngoto abort_ctrl;\r\n}\r\nif (link_cap & PCI_EXP_LNKCAP_DLLLARC) {\r\nctrl_dbg(ctrl, "Link Active Reporting supported\n");\r\nctrl->link_active_reporting = 1;\r\n}\r\nif (pciehp_writew(ctrl, PCI_EXP_SLTSTA, 0x1f))\r\ngoto abort_ctrl;\r\npcie_disable_notification(ctrl);\r\nctrl_info(ctrl, "HPC vendor_id %x device_id %x ss_vid %x ss_did %x\n",\r\npdev->vendor, pdev->device, pdev->subsystem_vendor,\r\npdev->subsystem_device);\r\nif (pcie_init_slot(ctrl))\r\ngoto abort_ctrl;\r\nreturn ctrl;\r\nabort_ctrl:\r\nkfree(ctrl);\r\nabort:\r\nreturn NULL;\r\n}\r\nvoid pciehp_release_ctrl(struct controller *ctrl)\r\n{\r\npcie_shutdown_notification(ctrl);\r\npcie_cleanup_slot(ctrl);\r\nkfree(ctrl);\r\n}
