static bool iov_empty(const struct iovec iov[], unsigned int num_iov)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < num_iov; i++)\r\nif (iov[i].iov_len)\r\nreturn false;\r\nreturn true;\r\n}\r\nstatic void iov_consume(struct iovec iov[], unsigned num_iov,\r\nvoid *dest, unsigned len)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < num_iov; i++) {\r\nunsigned int used;\r\nused = iov[i].iov_len < len ? iov[i].iov_len : len;\r\nif (dest) {\r\nmemcpy(dest, iov[i].iov_base, used);\r\ndest += used;\r\n}\r\niov[i].iov_base += used;\r\niov[i].iov_len -= used;\r\nlen -= used;\r\n}\r\nif (len != 0)\r\nerrx(1, "iovec too short!");\r\n}\r\nstatic u8 *get_feature_bits(struct device *dev)\r\n{\r\nreturn (u8 *)(dev->desc + 1)\r\n+ dev->num_vq * sizeof(struct lguest_vqconfig);\r\n}\r\nstatic void *from_guest_phys(unsigned long addr)\r\n{\r\nreturn guest_base + addr;\r\n}\r\nstatic unsigned long to_guest_phys(const void *addr)\r\n{\r\nreturn (addr - guest_base);\r\n}\r\nstatic int open_or_die(const char *name, int flags)\r\n{\r\nint fd = open(name, flags);\r\nif (fd < 0)\r\nerr(1, "Failed to open %s", name);\r\nreturn fd;\r\n}\r\nstatic void *map_zeroed_pages(unsigned int num)\r\n{\r\nint fd = open_or_die("/dev/zero", O_RDONLY);\r\nvoid *addr;\r\naddr = mmap(NULL, getpagesize() * (num+2),\r\nPROT_NONE, MAP_PRIVATE, fd, 0);\r\nif (addr == MAP_FAILED)\r\nerr(1, "Mmapping %u pages of /dev/zero", num);\r\nif (mprotect(addr + getpagesize(), getpagesize() * num,\r\nPROT_READ|PROT_WRITE) == -1)\r\nerr(1, "mprotect rw %u pages failed", num);\r\nclose(fd);\r\nreturn addr + getpagesize();\r\n}\r\nstatic void *get_pages(unsigned int num)\r\n{\r\nvoid *addr = from_guest_phys(guest_limit);\r\nguest_limit += num * getpagesize();\r\nif (guest_limit > guest_max)\r\nerrx(1, "Not enough memory for devices");\r\nreturn addr;\r\n}\r\nstatic void map_at(int fd, void *addr, unsigned long offset, unsigned long len)\r\n{\r\nssize_t r;\r\nif (mmap(addr, len, PROT_READ|PROT_WRITE,\r\nMAP_FIXED|MAP_PRIVATE, fd, offset) != MAP_FAILED)\r\nreturn;\r\nr = pread(fd, addr, len, offset);\r\nif (r != len)\r\nerr(1, "Reading offset %lu len %lu gave %zi", offset, len, r);\r\n}\r\nstatic unsigned long map_elf(int elf_fd, const Elf32_Ehdr *ehdr)\r\n{\r\nElf32_Phdr phdr[ehdr->e_phnum];\r\nunsigned int i;\r\nif (ehdr->e_type != ET_EXEC\r\n|| ehdr->e_machine != EM_386\r\n|| ehdr->e_phentsize != sizeof(Elf32_Phdr)\r\n|| ehdr->e_phnum < 1 || ehdr->e_phnum > 65536U/sizeof(Elf32_Phdr))\r\nerrx(1, "Malformed elf header");\r\nif (lseek(elf_fd, ehdr->e_phoff, SEEK_SET) < 0)\r\nerr(1, "Seeking to program headers");\r\nif (read(elf_fd, phdr, sizeof(phdr)) != sizeof(phdr))\r\nerr(1, "Reading program headers");\r\nfor (i = 0; i < ehdr->e_phnum; i++) {\r\nif (phdr[i].p_type != PT_LOAD)\r\ncontinue;\r\nverbose("Section %i: size %i addr %p\n",\r\ni, phdr[i].p_memsz, (void *)phdr[i].p_paddr);\r\nmap_at(elf_fd, from_guest_phys(phdr[i].p_paddr),\r\nphdr[i].p_offset, phdr[i].p_filesz);\r\n}\r\nreturn ehdr->e_entry;\r\n}\r\nstatic unsigned long load_bzimage(int fd)\r\n{\r\nstruct boot_params boot;\r\nint r;\r\nvoid *p = from_guest_phys(0x100000);\r\nlseek(fd, 0, SEEK_SET);\r\nread(fd, &boot, sizeof(boot));\r\nif (memcmp(&boot.hdr.header, "HdrS", 4) != 0)\r\nerrx(1, "This doesn't look like a bzImage to me");\r\nlseek(fd, (boot.hdr.setup_sects+1) * 512, SEEK_SET);\r\nwhile ((r = read(fd, p, 65536)) > 0)\r\np += r;\r\nreturn boot.hdr.code32_start;\r\n}\r\nstatic unsigned long load_kernel(int fd)\r\n{\r\nElf32_Ehdr hdr;\r\nif (read(fd, &hdr, sizeof(hdr)) != sizeof(hdr))\r\nerr(1, "Reading kernel");\r\nif (memcmp(hdr.e_ident, ELFMAG, SELFMAG) == 0)\r\nreturn map_elf(fd, &hdr);\r\nreturn load_bzimage(fd);\r\n}\r\nstatic inline unsigned long page_align(unsigned long addr)\r\n{\r\nreturn ((addr + getpagesize()-1) & ~(getpagesize()-1));\r\n}\r\nstatic unsigned long load_initrd(const char *name, unsigned long mem)\r\n{\r\nint ifd;\r\nstruct stat st;\r\nunsigned long len;\r\nifd = open_or_die(name, O_RDONLY);\r\nif (fstat(ifd, &st) < 0)\r\nerr(1, "fstat() on initrd '%s'", name);\r\nlen = page_align(st.st_size);\r\nmap_at(ifd, from_guest_phys(mem - len), 0, st.st_size);\r\nclose(ifd);\r\nverbose("mapped initrd %s size=%lu @ %p\n", name, len, (void*)mem-len);\r\nreturn len;\r\n}\r\nstatic void concat(char *dst, char *args[])\r\n{\r\nunsigned int i, len = 0;\r\nfor (i = 0; args[i]; i++) {\r\nif (i) {\r\nstrcat(dst+len, " ");\r\nlen++;\r\n}\r\nstrcpy(dst+len, args[i]);\r\nlen += strlen(args[i]);\r\n}\r\ndst[len] = '\0';\r\n}\r\nstatic void tell_kernel(unsigned long start)\r\n{\r\nunsigned long args[] = { LHREQ_INITIALIZE,\r\n(unsigned long)guest_base,\r\nguest_limit / getpagesize(), start };\r\nverbose("Guest: %p - %p (%#lx)\n",\r\nguest_base, guest_base + guest_limit, guest_limit);\r\nlguest_fd = open_or_die("/dev/lguest", O_RDWR);\r\nif (write(lguest_fd, args, sizeof(args)) < 0)\r\nerr(1, "Writing to /dev/lguest");\r\n}\r\nstatic void *_check_pointer(unsigned long addr, unsigned int size,\r\nunsigned int line)\r\n{\r\nif ((addr + size) > guest_limit || (addr + size) < addr)\r\nerrx(1, "%s:%i: Invalid address %#lx", __FILE__, line, addr);\r\nreturn from_guest_phys(addr);\r\n}\r\nstatic unsigned next_desc(struct vring_desc *desc,\r\nunsigned int i, unsigned int max)\r\n{\r\nunsigned int next;\r\nif (!(desc[i].flags & VRING_DESC_F_NEXT))\r\nreturn max;\r\nnext = desc[i].next;\r\nwmb();\r\nif (next >= max)\r\nerrx(1, "Desc next is %u", next);\r\nreturn next;\r\n}\r\nstatic void trigger_irq(struct virtqueue *vq)\r\n{\r\nunsigned long buf[] = { LHREQ_IRQ, vq->config.irq };\r\nif (!vq->pending_used)\r\nreturn;\r\nvq->pending_used = 0;\r\nif (vq->vring.avail->flags & VRING_AVAIL_F_NO_INTERRUPT) {\r\nreturn;\r\n}\r\nif (write(lguest_fd, buf, sizeof(buf)) != 0)\r\nerr(1, "Triggering irq %i", vq->config.irq);\r\n}\r\nstatic unsigned wait_for_vq_desc(struct virtqueue *vq,\r\nstruct iovec iov[],\r\nunsigned int *out_num, unsigned int *in_num)\r\n{\r\nunsigned int i, head, max;\r\nstruct vring_desc *desc;\r\nu16 last_avail = lg_last_avail(vq);\r\nwhile (last_avail == vq->vring.avail->idx) {\r\nu64 event;\r\ntrigger_irq(vq);\r\nvq->vring.used->flags &= ~VRING_USED_F_NO_NOTIFY;\r\nmb();\r\nif (last_avail != vq->vring.avail->idx) {\r\nvq->vring.used->flags |= VRING_USED_F_NO_NOTIFY;\r\nbreak;\r\n}\r\nif (read(vq->eventfd, &event, sizeof(event)) != sizeof(event))\r\nerrx(1, "Event read failed?");\r\nvq->vring.used->flags |= VRING_USED_F_NO_NOTIFY;\r\n}\r\nif ((u16)(vq->vring.avail->idx - last_avail) > vq->vring.num)\r\nerrx(1, "Guest moved used index from %u to %u",\r\nlast_avail, vq->vring.avail->idx);\r\nhead = vq->vring.avail->ring[last_avail % vq->vring.num];\r\nlg_last_avail(vq)++;\r\nif (head >= vq->vring.num)\r\nerrx(1, "Guest says index %u is available", head);\r\n*out_num = *in_num = 0;\r\nmax = vq->vring.num;\r\ndesc = vq->vring.desc;\r\ni = head;\r\nif (desc[i].flags & VRING_DESC_F_INDIRECT) {\r\nif (desc[i].len % sizeof(struct vring_desc))\r\nerrx(1, "Invalid size for indirect buffer table");\r\nmax = desc[i].len / sizeof(struct vring_desc);\r\ndesc = check_pointer(desc[i].addr, desc[i].len);\r\ni = 0;\r\n}\r\ndo {\r\niov[*out_num + *in_num].iov_len = desc[i].len;\r\niov[*out_num + *in_num].iov_base\r\n= check_pointer(desc[i].addr, desc[i].len);\r\nif (desc[i].flags & VRING_DESC_F_WRITE)\r\n(*in_num)++;\r\nelse {\r\nif (*in_num)\r\nerrx(1, "Descriptor has out after in");\r\n(*out_num)++;\r\n}\r\nif (*out_num + *in_num > max)\r\nerrx(1, "Looped descriptor");\r\n} while ((i = next_desc(desc, i, max)) != max);\r\nreturn head;\r\n}\r\nstatic void add_used(struct virtqueue *vq, unsigned int head, int len)\r\n{\r\nstruct vring_used_elem *used;\r\nused = &vq->vring.used->ring[vq->vring.used->idx % vq->vring.num];\r\nused->id = head;\r\nused->len = len;\r\nwmb();\r\nvq->vring.used->idx++;\r\nvq->pending_used++;\r\n}\r\nstatic void add_used_and_trigger(struct virtqueue *vq, unsigned head, int len)\r\n{\r\nadd_used(vq, head, len);\r\ntrigger_irq(vq);\r\n}\r\nstatic void console_input(struct virtqueue *vq)\r\n{\r\nint len;\r\nunsigned int head, in_num, out_num;\r\nstruct console_abort *abort = vq->dev->priv;\r\nstruct iovec iov[vq->vring.num];\r\nhead = wait_for_vq_desc(vq, iov, &out_num, &in_num);\r\nif (out_num)\r\nerrx(1, "Output buffers in console in queue?");\r\nlen = readv(STDIN_FILENO, iov, in_num);\r\nif (len <= 0) {\r\nwarnx("Failed to get console input, ignoring console.");\r\nfor (;;)\r\npause();\r\n}\r\nadd_used_and_trigger(vq, head, len);\r\nif (len != 1 || ((char *)iov[0].iov_base)[0] != 3) {\r\nabort->count = 0;\r\nreturn;\r\n}\r\nabort->count++;\r\nif (abort->count == 1)\r\ngettimeofday(&abort->start, NULL);\r\nelse if (abort->count == 3) {\r\nstruct timeval now;\r\ngettimeofday(&now, NULL);\r\nif (now.tv_sec <= abort->start.tv_sec+1)\r\nkill(0, SIGINT);\r\nabort->count = 0;\r\n}\r\n}\r\nstatic void console_output(struct virtqueue *vq)\r\n{\r\nunsigned int head, out, in;\r\nstruct iovec iov[vq->vring.num];\r\nhead = wait_for_vq_desc(vq, iov, &out, &in);\r\nif (in)\r\nerrx(1, "Input buffers in console output queue?");\r\nwhile (!iov_empty(iov, out)) {\r\nint len = writev(STDOUT_FILENO, iov, out);\r\nif (len <= 0) {\r\nwarn("Write to stdout gave %i (%d)", len, errno);\r\nbreak;\r\n}\r\niov_consume(iov, out, NULL, len);\r\n}\r\nadd_used(vq, head, 0);\r\n}\r\nstatic void net_output(struct virtqueue *vq)\r\n{\r\nstruct net_info *net_info = vq->dev->priv;\r\nunsigned int head, out, in;\r\nstruct iovec iov[vq->vring.num];\r\nhead = wait_for_vq_desc(vq, iov, &out, &in);\r\nif (in)\r\nerrx(1, "Input buffers in net output queue?");\r\nif (writev(net_info->tunfd, iov, out) < 0)\r\nwarnx("Write to tun failed (%d)?", errno);\r\nadd_used(vq, head, 0);\r\n}\r\nstatic bool will_block(int fd)\r\n{\r\nfd_set fdset;\r\nstruct timeval zero = { 0, 0 };\r\nFD_ZERO(&fdset);\r\nFD_SET(fd, &fdset);\r\nreturn select(fd+1, &fdset, NULL, NULL, &zero) != 1;\r\n}\r\nstatic void net_input(struct virtqueue *vq)\r\n{\r\nint len;\r\nunsigned int head, out, in;\r\nstruct iovec iov[vq->vring.num];\r\nstruct net_info *net_info = vq->dev->priv;\r\nhead = wait_for_vq_desc(vq, iov, &out, &in);\r\nif (out)\r\nerrx(1, "Output buffers in net input queue?");\r\nif (vq->pending_used && will_block(net_info->tunfd))\r\ntrigger_irq(vq);\r\nlen = readv(net_info->tunfd, iov, in);\r\nif (len <= 0)\r\nwarn("Failed to read from tun (%d).", errno);\r\nadd_used(vq, head, len);\r\n}\r\nstatic int do_thread(void *_vq)\r\n{\r\nstruct virtqueue *vq = _vq;\r\nfor (;;)\r\nvq->service(vq);\r\nreturn 0;\r\n}\r\nstatic void kill_launcher(int signal)\r\n{\r\nkill(0, SIGTERM);\r\n}\r\nstatic void reset_device(struct device *dev)\r\n{\r\nstruct virtqueue *vq;\r\nverbose("Resetting device %s\n", dev->name);\r\nmemset(get_feature_bits(dev) + dev->feature_len, 0, dev->feature_len);\r\nsignal(SIGCHLD, SIG_IGN);\r\nfor (vq = dev->vq; vq; vq = vq->next) {\r\nif (vq->thread != (pid_t)-1) {\r\nkill(vq->thread, SIGTERM);\r\nwaitpid(vq->thread, NULL, 0);\r\nvq->thread = (pid_t)-1;\r\n}\r\nmemset(vq->vring.desc, 0,\r\nvring_size(vq->config.num, LGUEST_VRING_ALIGN));\r\nlg_last_avail(vq) = 0;\r\n}\r\ndev->running = false;\r\nsignal(SIGCHLD, (void *)kill_launcher);\r\n}\r\nstatic void create_thread(struct virtqueue *vq)\r\n{\r\nchar *stack = malloc(32768);\r\nunsigned long args[] = { LHREQ_EVENTFD,\r\nvq->config.pfn*getpagesize(), 0 };\r\nvq->eventfd = eventfd(0, 0);\r\nif (vq->eventfd < 0)\r\nerr(1, "Creating eventfd");\r\nargs[2] = vq->eventfd;\r\nif (write(lguest_fd, &args, sizeof(args)) != 0)\r\nerr(1, "Attaching eventfd");\r\nvq->thread = clone(do_thread, stack + 32768, CLONE_VM | SIGCHLD, vq);\r\nif (vq->thread == (pid_t)-1)\r\nerr(1, "Creating clone");\r\nclose(vq->eventfd);\r\n}\r\nstatic void start_device(struct device *dev)\r\n{\r\nunsigned int i;\r\nstruct virtqueue *vq;\r\nverbose("Device %s OK: offered", dev->name);\r\nfor (i = 0; i < dev->feature_len; i++)\r\nverbose(" %02x", get_feature_bits(dev)[i]);\r\nverbose(", accepted");\r\nfor (i = 0; i < dev->feature_len; i++)\r\nverbose(" %02x", get_feature_bits(dev)\r\n[dev->feature_len+i]);\r\nfor (vq = dev->vq; vq; vq = vq->next) {\r\nif (vq->service)\r\ncreate_thread(vq);\r\n}\r\ndev->running = true;\r\n}\r\nstatic void cleanup_devices(void)\r\n{\r\nstruct device *dev;\r\nfor (dev = devices.dev; dev; dev = dev->next)\r\nreset_device(dev);\r\nif (orig_term.c_lflag & (ISIG|ICANON|ECHO))\r\ntcsetattr(STDIN_FILENO, TCSANOW, &orig_term);\r\n}\r\nstatic void update_device_status(struct device *dev)\r\n{\r\nif (dev->desc->status == 0)\r\nreset_device(dev);\r\nelse if (dev->desc->status & VIRTIO_CONFIG_S_FAILED) {\r\nwarnx("Device %s configuration FAILED", dev->name);\r\nif (dev->running)\r\nreset_device(dev);\r\n} else {\r\nif (dev->running)\r\nerr(1, "Device %s features finalized twice", dev->name);\r\nstart_device(dev);\r\n}\r\n}\r\nstatic void handle_output(unsigned long addr)\r\n{\r\nstruct device *i;\r\nfor (i = devices.dev; i; i = i->next) {\r\nstruct virtqueue *vq;\r\nif (from_guest_phys(addr) == i->desc) {\r\nupdate_device_status(i);\r\nreturn;\r\n}\r\nfor (vq = i->vq; vq; vq = vq->next) {\r\nif (addr != vq->config.pfn*getpagesize())\r\ncontinue;\r\nerrx(1, "Notification on %s before setup!", i->name);\r\n}\r\n}\r\nif (addr >= guest_limit)\r\nerrx(1, "Bad NOTIFY %#lx", addr);\r\nwrite(STDOUT_FILENO, from_guest_phys(addr),\r\nstrnlen(from_guest_phys(addr), guest_limit - addr));\r\n}\r\nstatic u8 *device_config(const struct device *dev)\r\n{\r\nreturn (void *)(dev->desc + 1)\r\n+ dev->num_vq * sizeof(struct lguest_vqconfig)\r\n+ dev->feature_len * 2;\r\n}\r\nstatic struct lguest_device_desc *new_dev_desc(u16 type)\r\n{\r\nstruct lguest_device_desc d = { .type = type };\r\nvoid *p;\r\nif (devices.lastdev)\r\np = device_config(devices.lastdev)\r\n+ devices.lastdev->desc->config_len;\r\nelse\r\np = devices.descpage;\r\nif (p + sizeof(d) > (void *)devices.descpage + getpagesize())\r\nerrx(1, "Too many devices");\r\nreturn memcpy(p, &d, sizeof(d));\r\n}\r\nstatic void add_virtqueue(struct device *dev, unsigned int num_descs,\r\nvoid (*service)(struct virtqueue *))\r\n{\r\nunsigned int pages;\r\nstruct virtqueue **i, *vq = malloc(sizeof(*vq));\r\nvoid *p;\r\npages = (vring_size(num_descs, LGUEST_VRING_ALIGN) + getpagesize() - 1)\r\n/ getpagesize();\r\np = get_pages(pages);\r\nvq->next = NULL;\r\nvq->last_avail_idx = 0;\r\nvq->dev = dev;\r\nvq->service = service;\r\nvq->thread = (pid_t)-1;\r\nvq->config.num = num_descs;\r\nvq->config.irq = devices.next_irq++;\r\nvq->config.pfn = to_guest_phys(p) / getpagesize();\r\nvring_init(&vq->vring, num_descs, p, LGUEST_VRING_ALIGN);\r\nassert(dev->desc->config_len == 0 && dev->desc->feature_len == 0);\r\nmemcpy(device_config(dev), &vq->config, sizeof(vq->config));\r\ndev->num_vq++;\r\ndev->desc->num_vq++;\r\nverbose("Virtqueue page %#lx\n", to_guest_phys(p));\r\nfor (i = &dev->vq; *i; i = &(*i)->next);\r\n*i = vq;\r\n}\r\nstatic void add_feature(struct device *dev, unsigned bit)\r\n{\r\nu8 *features = get_feature_bits(dev);\r\nif (dev->desc->feature_len <= bit / CHAR_BIT) {\r\nassert(dev->desc->config_len == 0);\r\ndev->feature_len = dev->desc->feature_len = (bit/CHAR_BIT) + 1;\r\n}\r\nfeatures[bit / CHAR_BIT] |= (1 << (bit % CHAR_BIT));\r\n}\r\nstatic void set_config(struct device *dev, unsigned len, const void *conf)\r\n{\r\nif (device_config(dev) + len > devices.descpage + getpagesize())\r\nerrx(1, "Too many devices");\r\nmemcpy(device_config(dev), conf, len);\r\ndev->desc->config_len = len;\r\nassert(dev->desc->config_len == len);\r\n}\r\nstatic struct device *new_device(const char *name, u16 type)\r\n{\r\nstruct device *dev = malloc(sizeof(*dev));\r\ndev->desc = new_dev_desc(type);\r\ndev->name = name;\r\ndev->vq = NULL;\r\ndev->feature_len = 0;\r\ndev->num_vq = 0;\r\ndev->running = false;\r\ndev->next = NULL;\r\nif (devices.lastdev)\r\ndevices.lastdev->next = dev;\r\nelse\r\ndevices.dev = dev;\r\ndevices.lastdev = dev;\r\nreturn dev;\r\n}\r\nstatic void setup_console(void)\r\n{\r\nstruct device *dev;\r\nif (tcgetattr(STDIN_FILENO, &orig_term) == 0) {\r\nstruct termios term = orig_term;\r\nterm.c_lflag &= ~(ISIG|ICANON|ECHO);\r\ntcsetattr(STDIN_FILENO, TCSANOW, &term);\r\n}\r\ndev = new_device("console", VIRTIO_ID_CONSOLE);\r\ndev->priv = malloc(sizeof(struct console_abort));\r\n((struct console_abort *)dev->priv)->count = 0;\r\nadd_virtqueue(dev, VIRTQUEUE_NUM, console_input);\r\nadd_virtqueue(dev, VIRTQUEUE_NUM, console_output);\r\nverbose("device %u: console\n", ++devices.device_num);\r\n}\r\nstatic u32 str2ip(const char *ipaddr)\r\n{\r\nunsigned int b[4];\r\nif (sscanf(ipaddr, "%u.%u.%u.%u", &b[0], &b[1], &b[2], &b[3]) != 4)\r\nerrx(1, "Failed to parse IP address '%s'", ipaddr);\r\nreturn (b[0] << 24) | (b[1] << 16) | (b[2] << 8) | b[3];\r\n}\r\nstatic void str2mac(const char *macaddr, unsigned char mac[6])\r\n{\r\nunsigned int m[6];\r\nif (sscanf(macaddr, "%02x:%02x:%02x:%02x:%02x:%02x",\r\n&m[0], &m[1], &m[2], &m[3], &m[4], &m[5]) != 6)\r\nerrx(1, "Failed to parse mac address '%s'", macaddr);\r\nmac[0] = m[0];\r\nmac[1] = m[1];\r\nmac[2] = m[2];\r\nmac[3] = m[3];\r\nmac[4] = m[4];\r\nmac[5] = m[5];\r\n}\r\nstatic void add_to_bridge(int fd, const char *if_name, const char *br_name)\r\n{\r\nint ifidx;\r\nstruct ifreq ifr;\r\nif (!*br_name)\r\nerrx(1, "must specify bridge name");\r\nifidx = if_nametoindex(if_name);\r\nif (!ifidx)\r\nerrx(1, "interface %s does not exist!", if_name);\r\nstrncpy(ifr.ifr_name, br_name, IFNAMSIZ);\r\nifr.ifr_name[IFNAMSIZ-1] = '\0';\r\nifr.ifr_ifindex = ifidx;\r\nif (ioctl(fd, SIOCBRADDIF, &ifr) < 0)\r\nerr(1, "can't add %s to bridge %s", if_name, br_name);\r\n}\r\nstatic void configure_device(int fd, const char *tapif, u32 ipaddr)\r\n{\r\nstruct ifreq ifr;\r\nstruct sockaddr_in sin;\r\nmemset(&ifr, 0, sizeof(ifr));\r\nstrcpy(ifr.ifr_name, tapif);\r\nsin.sin_family = AF_INET;\r\nsin.sin_addr.s_addr = htonl(ipaddr);\r\nmemcpy(&ifr.ifr_addr, &sin, sizeof(sin));\r\nif (ioctl(fd, SIOCSIFADDR, &ifr) != 0)\r\nerr(1, "Setting %s interface address", tapif);\r\nifr.ifr_flags = IFF_UP;\r\nif (ioctl(fd, SIOCSIFFLAGS, &ifr) != 0)\r\nerr(1, "Bringing interface %s up", tapif);\r\n}\r\nstatic int get_tun_device(char tapif[IFNAMSIZ])\r\n{\r\nstruct ifreq ifr;\r\nint netfd;\r\nmemset(&ifr, 0, sizeof(ifr));\r\nnetfd = open_or_die("/dev/net/tun", O_RDWR);\r\nifr.ifr_flags = IFF_TAP | IFF_NO_PI | IFF_VNET_HDR;\r\nstrcpy(ifr.ifr_name, "tap%d");\r\nif (ioctl(netfd, TUNSETIFF, &ifr) != 0)\r\nerr(1, "configuring /dev/net/tun");\r\nif (ioctl(netfd, TUNSETOFFLOAD,\r\nTUN_F_CSUM|TUN_F_TSO4|TUN_F_TSO6|TUN_F_TSO_ECN) != 0)\r\nerr(1, "Could not set features for tun device");\r\nioctl(netfd, TUNSETNOCSUM, 1);\r\nmemcpy(tapif, ifr.ifr_name, IFNAMSIZ);\r\nreturn netfd;\r\n}\r\nstatic void setup_tun_net(char *arg)\r\n{\r\nstruct device *dev;\r\nstruct net_info *net_info = malloc(sizeof(*net_info));\r\nint ipfd;\r\nu32 ip = INADDR_ANY;\r\nbool bridging = false;\r\nchar tapif[IFNAMSIZ], *p;\r\nstruct virtio_net_config conf;\r\nnet_info->tunfd = get_tun_device(tapif);\r\ndev = new_device("net", VIRTIO_ID_NET);\r\ndev->priv = net_info;\r\nadd_virtqueue(dev, VIRTQUEUE_NUM, net_input);\r\nadd_virtqueue(dev, VIRTQUEUE_NUM, net_output);\r\nipfd = socket(PF_INET, SOCK_DGRAM, IPPROTO_IP);\r\nif (ipfd < 0)\r\nerr(1, "opening IP socket");\r\nif (!strncmp(BRIDGE_PFX, arg, strlen(BRIDGE_PFX))) {\r\narg += strlen(BRIDGE_PFX);\r\nbridging = true;\r\n}\r\np = strchr(arg, ':');\r\nif (p) {\r\nstr2mac(p+1, conf.mac);\r\nadd_feature(dev, VIRTIO_NET_F_MAC);\r\n*p = '\0';\r\n}\r\nif (bridging)\r\nadd_to_bridge(ipfd, tapif, arg);\r\nelse\r\nip = str2ip(arg);\r\nconfigure_device(ipfd, tapif, ip);\r\nadd_feature(dev, VIRTIO_NET_F_CSUM);\r\nadd_feature(dev, VIRTIO_NET_F_GUEST_CSUM);\r\nadd_feature(dev, VIRTIO_NET_F_GUEST_TSO4);\r\nadd_feature(dev, VIRTIO_NET_F_GUEST_TSO6);\r\nadd_feature(dev, VIRTIO_NET_F_GUEST_ECN);\r\nadd_feature(dev, VIRTIO_NET_F_HOST_TSO4);\r\nadd_feature(dev, VIRTIO_NET_F_HOST_TSO6);\r\nadd_feature(dev, VIRTIO_NET_F_HOST_ECN);\r\nadd_feature(dev, VIRTIO_RING_F_INDIRECT_DESC);\r\nset_config(dev, sizeof(conf), &conf);\r\nclose(ipfd);\r\ndevices.device_num++;\r\nif (bridging)\r\nverbose("device %u: tun %s attached to bridge: %s\n",\r\ndevices.device_num, tapif, arg);\r\nelse\r\nverbose("device %u: tun %s: %s\n",\r\ndevices.device_num, tapif, arg);\r\n}\r\nstatic void blk_request(struct virtqueue *vq)\r\n{\r\nstruct vblk_info *vblk = vq->dev->priv;\r\nunsigned int head, out_num, in_num, wlen;\r\nint ret, i;\r\nu8 *in;\r\nstruct virtio_blk_outhdr out;\r\nstruct iovec iov[vq->vring.num];\r\noff64_t off;\r\nhead = wait_for_vq_desc(vq, iov, &out_num, &in_num);\r\niov_consume(iov, out_num, &out, sizeof(out));\r\nin = NULL;\r\nfor (i = out_num + in_num - 1; i >= out_num; i--) {\r\nif (iov[i].iov_len > 0) {\r\nin = iov[i].iov_base + iov[i].iov_len - 1;\r\niov[i].iov_len--;\r\nbreak;\r\n}\r\n}\r\nif (!in)\r\nerrx(1, "Bad virtblk cmd with no room for status");\r\noff = out.sector * 512;\r\nif (out.type & VIRTIO_BLK_T_SCSI_CMD) {\r\nfprintf(stderr, "Scsi commands unsupported\n");\r\n*in = VIRTIO_BLK_S_UNSUPP;\r\nwlen = sizeof(*in);\r\n} else if (out.type & VIRTIO_BLK_T_OUT) {\r\nif (lseek64(vblk->fd, off, SEEK_SET) != off)\r\nerr(1, "Bad seek to sector %llu", out.sector);\r\nret = writev(vblk->fd, iov, out_num);\r\nverbose("WRITE to sector %llu: %i\n", out.sector, ret);\r\nif (ret > 0 && off + ret > vblk->len) {\r\nftruncate64(vblk->fd, vblk->len);\r\nerrx(1, "Write past end %llu+%u", off, ret);\r\n}\r\nwlen = sizeof(*in);\r\n*in = (ret >= 0 ? VIRTIO_BLK_S_OK : VIRTIO_BLK_S_IOERR);\r\n} else if (out.type & VIRTIO_BLK_T_FLUSH) {\r\nret = fdatasync(vblk->fd);\r\nverbose("FLUSH fdatasync: %i\n", ret);\r\nwlen = sizeof(*in);\r\n*in = (ret >= 0 ? VIRTIO_BLK_S_OK : VIRTIO_BLK_S_IOERR);\r\n} else {\r\nif (lseek64(vblk->fd, off, SEEK_SET) != off)\r\nerr(1, "Bad seek to sector %llu", out.sector);\r\nret = readv(vblk->fd, iov + out_num, in_num);\r\nif (ret >= 0) {\r\nwlen = sizeof(*in) + ret;\r\n*in = VIRTIO_BLK_S_OK;\r\n} else {\r\nwlen = sizeof(*in);\r\n*in = VIRTIO_BLK_S_IOERR;\r\n}\r\n}\r\nadd_used(vq, head, wlen);\r\n}\r\nstatic void setup_block_file(const char *filename)\r\n{\r\nstruct device *dev;\r\nstruct vblk_info *vblk;\r\nstruct virtio_blk_config conf;\r\ndev = new_device("block", VIRTIO_ID_BLOCK);\r\nadd_virtqueue(dev, VIRTQUEUE_NUM, blk_request);\r\nvblk = dev->priv = malloc(sizeof(*vblk));\r\nvblk->fd = open_or_die(filename, O_RDWR|O_LARGEFILE);\r\nvblk->len = lseek64(vblk->fd, 0, SEEK_END);\r\nadd_feature(dev, VIRTIO_BLK_F_FLUSH);\r\nconf.capacity = cpu_to_le64(vblk->len / 512);\r\nadd_feature(dev, VIRTIO_BLK_F_SEG_MAX);\r\nconf.seg_max = cpu_to_le32(VIRTQUEUE_NUM - 2);\r\nset_config(dev, offsetof(struct virtio_blk_config, geometry), &conf);\r\nverbose("device %u: virtblock %llu sectors\n",\r\n++devices.device_num, le64_to_cpu(conf.capacity));\r\n}\r\nstatic void rng_input(struct virtqueue *vq)\r\n{\r\nint len;\r\nunsigned int head, in_num, out_num, totlen = 0;\r\nstruct rng_info *rng_info = vq->dev->priv;\r\nstruct iovec iov[vq->vring.num];\r\nhead = wait_for_vq_desc(vq, iov, &out_num, &in_num);\r\nif (out_num)\r\nerrx(1, "Output buffers in rng?");\r\nwhile (!iov_empty(iov, in_num)) {\r\nlen = readv(rng_info->rfd, iov, in_num);\r\nif (len <= 0)\r\nerr(1, "Read from /dev/random gave %i", len);\r\niov_consume(iov, in_num, NULL, len);\r\ntotlen += len;\r\n}\r\nadd_used(vq, head, totlen);\r\n}\r\nstatic void setup_rng(void)\r\n{\r\nstruct device *dev;\r\nstruct rng_info *rng_info = malloc(sizeof(*rng_info));\r\nrng_info->rfd = open_or_die("/dev/random", O_RDONLY);\r\ndev = new_device("rng", VIRTIO_ID_RNG);\r\ndev->priv = rng_info;\r\nadd_virtqueue(dev, VIRTQUEUE_NUM, rng_input);\r\nverbose("device %u: rng\n", devices.device_num++);\r\n}\r\nstatic void usage(void)\r\n{\r\nerrx(1, "Usage: lguest [--verbose] "\r\n"[--tunnet=(<ipaddr>:<macaddr>|bridge:<bridgename>:<macaddr>)\n"\r\n"|--block=<filename>|--initrd=<filename>]...\n"\r\n"<mem-in-mb> vmlinux [args...]");\r\n}\r\nint main(int argc, char *argv[])\r\n{\r\nunsigned long mem = 0, start, initrd_size = 0;\r\nint i, c;\r\nstruct boot_params *boot;\r\nconst char *initrd_name = NULL;\r\nstruct passwd *user_details = NULL;\r\nchar *chroot_path = NULL;\r\nmain_args = argv;\r\ndevices.lastdev = NULL;\r\ndevices.next_irq = 1;\r\ncpu_id = 0;\r\nfor (i = 1; i < argc; i++) {\r\nif (argv[i][0] != '-') {\r\nmem = atoi(argv[i]) * 1024 * 1024;\r\nguest_base = map_zeroed_pages(mem / getpagesize()\r\n+ DEVICE_PAGES);\r\nguest_limit = mem;\r\nguest_max = mem + DEVICE_PAGES*getpagesize();\r\ndevices.descpage = get_pages(1);\r\nbreak;\r\n}\r\n}\r\nwhile ((c = getopt_long(argc, argv, "v", opts, NULL)) != EOF) {\r\nswitch (c) {\r\ncase 'v':\r\nverbose = true;\r\nbreak;\r\ncase 't':\r\nsetup_tun_net(optarg);\r\nbreak;\r\ncase 'b':\r\nsetup_block_file(optarg);\r\nbreak;\r\ncase 'r':\r\nsetup_rng();\r\nbreak;\r\ncase 'i':\r\ninitrd_name = optarg;\r\nbreak;\r\ncase 'u':\r\nuser_details = getpwnam(optarg);\r\nif (!user_details)\r\nerr(1, "getpwnam failed, incorrect username?");\r\nbreak;\r\ncase 'c':\r\nchroot_path = optarg;\r\nbreak;\r\ndefault:\r\nwarnx("Unknown argument %s", argv[optind]);\r\nusage();\r\n}\r\n}\r\nif (optind + 2 > argc)\r\nusage();\r\nverbose("Guest base is at %p\n", guest_base);\r\nsetup_console();\r\nstart = load_kernel(open_or_die(argv[optind+1], O_RDONLY));\r\nboot = from_guest_phys(0);\r\nif (initrd_name) {\r\ninitrd_size = load_initrd(initrd_name, mem);\r\nboot->hdr.ramdisk_image = mem - initrd_size;\r\nboot->hdr.ramdisk_size = initrd_size;\r\nboot->hdr.type_of_loader = 0xFF;\r\n}\r\nboot->e820_entries = 1;\r\nboot->e820_map[0] = ((struct e820entry) { 0, mem, E820_RAM });\r\nboot->hdr.cmd_line_ptr = to_guest_phys(boot + 1);\r\nconcat((char *)(boot + 1), argv+optind+2);\r\nboot->hdr.kernel_alignment = 0x1000000;\r\nboot->hdr.version = 0x207;\r\nboot->hdr.hardware_subarch = 1;\r\nboot->hdr.loadflags |= KEEP_SEGMENTS;\r\ntell_kernel(start);\r\nsignal(SIGCHLD, kill_launcher);\r\natexit(cleanup_devices);\r\nif (chroot_path) {\r\nif (chroot(chroot_path) != 0)\r\nerr(1, "chroot(\"%s\") failed", chroot_path);\r\nif (chdir("/") != 0)\r\nerr(1, "chdir(\"/\") failed");\r\nverbose("chroot done\n");\r\n}\r\nif (user_details) {\r\nuid_t u;\r\ngid_t g;\r\nu = user_details->pw_uid;\r\ng = user_details->pw_gid;\r\nif (initgroups(user_details->pw_name, g) != 0)\r\nerr(1, "initgroups failed");\r\nif (setresgid(g, g, g) != 0)\r\nerr(1, "setresgid failed");\r\nif (setresuid(u, u, u) != 0)\r\nerr(1, "setresuid failed");\r\nverbose("Dropping privileges completed\n");\r\n}\r\nrun_guest();\r\n}
