static char *aa_simple_write_to_buffer(int op, const char __user *userbuf,\r\nsize_t alloc_size, size_t copy_size,\r\nloff_t *pos)\r\n{\r\nchar *data;\r\nBUG_ON(copy_size > alloc_size);\r\nif (*pos != 0)\r\nreturn ERR_PTR(-ESPIPE);\r\nif (!aa_may_manage_policy(op))\r\nreturn ERR_PTR(-EACCES);\r\ndata = kvmalloc(alloc_size);\r\nif (data == NULL)\r\nreturn ERR_PTR(-ENOMEM);\r\nif (copy_from_user(data, userbuf, copy_size)) {\r\nkvfree(data);\r\nreturn ERR_PTR(-EFAULT);\r\n}\r\nreturn data;\r\n}\r\nstatic ssize_t profile_load(struct file *f, const char __user *buf, size_t size,\r\nloff_t *pos)\r\n{\r\nchar *data;\r\nssize_t error;\r\ndata = aa_simple_write_to_buffer(OP_PROF_LOAD, buf, size, size, pos);\r\nerror = PTR_ERR(data);\r\nif (!IS_ERR(data)) {\r\nerror = aa_replace_profiles(data, size, PROF_ADD);\r\nkvfree(data);\r\n}\r\nreturn error;\r\n}\r\nstatic ssize_t profile_replace(struct file *f, const char __user *buf,\r\nsize_t size, loff_t *pos)\r\n{\r\nchar *data;\r\nssize_t error;\r\ndata = aa_simple_write_to_buffer(OP_PROF_REPL, buf, size, size, pos);\r\nerror = PTR_ERR(data);\r\nif (!IS_ERR(data)) {\r\nerror = aa_replace_profiles(data, size, PROF_REPLACE);\r\nkvfree(data);\r\n}\r\nreturn error;\r\n}\r\nstatic ssize_t profile_remove(struct file *f, const char __user *buf,\r\nsize_t size, loff_t *pos)\r\n{\r\nchar *data;\r\nssize_t error;\r\ndata = aa_simple_write_to_buffer(OP_PROF_RM, buf, size + 1, size, pos);\r\nerror = PTR_ERR(data);\r\nif (!IS_ERR(data)) {\r\ndata[size] = 0;\r\nerror = aa_remove_profiles(data, size);\r\nkvfree(data);\r\n}\r\nreturn error;\r\n}\r\nstatic int aa_fs_seq_show(struct seq_file *seq, void *v)\r\n{\r\nstruct aa_fs_entry *fs_file = seq->private;\r\nif (!fs_file)\r\nreturn 0;\r\nswitch (fs_file->v_type) {\r\ncase AA_FS_TYPE_BOOLEAN:\r\nseq_printf(seq, "%s\n", fs_file->v.boolean ? "yes" : "no");\r\nbreak;\r\ncase AA_FS_TYPE_STRING:\r\nseq_printf(seq, "%s\n", fs_file->v.string);\r\nbreak;\r\ncase AA_FS_TYPE_U64:\r\nseq_printf(seq, "%#08lx\n", fs_file->v.u64);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int aa_fs_seq_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, aa_fs_seq_show, inode->i_private);\r\n}\r\nstatic int __init aafs_create_file(struct aa_fs_entry *fs_file,\r\nstruct dentry *parent)\r\n{\r\nint error = 0;\r\nfs_file->dentry = securityfs_create_file(fs_file->name,\r\nS_IFREG | fs_file->mode,\r\nparent, fs_file,\r\nfs_file->file_ops);\r\nif (IS_ERR(fs_file->dentry)) {\r\nerror = PTR_ERR(fs_file->dentry);\r\nfs_file->dentry = NULL;\r\n}\r\nreturn error;\r\n}\r\nstatic int __init aafs_create_dir(struct aa_fs_entry *fs_dir,\r\nstruct dentry *parent)\r\n{\r\nint error;\r\nstruct aa_fs_entry *fs_file;\r\nfs_dir->dentry = securityfs_create_dir(fs_dir->name, parent);\r\nif (IS_ERR(fs_dir->dentry)) {\r\nerror = PTR_ERR(fs_dir->dentry);\r\nfs_dir->dentry = NULL;\r\ngoto failed;\r\n}\r\nfor (fs_file = fs_dir->v.files; fs_file->name; ++fs_file) {\r\nif (fs_file->v_type == AA_FS_TYPE_DIR)\r\nerror = aafs_create_dir(fs_file, fs_dir->dentry);\r\nelse\r\nerror = aafs_create_file(fs_file, fs_dir->dentry);\r\nif (error)\r\ngoto failed;\r\n}\r\nreturn 0;\r\nfailed:\r\nreturn error;\r\n}\r\nstatic void __init aafs_remove_file(struct aa_fs_entry *fs_file)\r\n{\r\nif (!fs_file->dentry)\r\nreturn;\r\nsecurityfs_remove(fs_file->dentry);\r\nfs_file->dentry = NULL;\r\n}\r\nstatic void __init aafs_remove_dir(struct aa_fs_entry *fs_dir)\r\n{\r\nstruct aa_fs_entry *fs_file;\r\nfor (fs_file = fs_dir->v.files; fs_file->name; ++fs_file) {\r\nif (fs_file->v_type == AA_FS_TYPE_DIR)\r\naafs_remove_dir(fs_file);\r\nelse\r\naafs_remove_file(fs_file);\r\n}\r\naafs_remove_file(fs_dir);\r\n}\r\nvoid __init aa_destroy_aafs(void)\r\n{\r\naafs_remove_dir(&aa_fs_entry);\r\n}\r\nstatic int __init aa_create_aafs(void)\r\n{\r\nint error;\r\nif (!apparmor_initialized)\r\nreturn 0;\r\nif (aa_fs_entry.dentry) {\r\nAA_ERROR("%s: AppArmor securityfs already exists\n", __func__);\r\nreturn -EEXIST;\r\n}\r\nerror = aafs_create_dir(&aa_fs_entry, NULL);\r\nif (error)\r\ngoto error;\r\naa_info_message("AppArmor Filesystem Enabled");\r\nreturn 0;\r\nerror:\r\naa_destroy_aafs();\r\nAA_ERROR("Error creating AppArmor securityfs\n");\r\nreturn error;\r\n}
