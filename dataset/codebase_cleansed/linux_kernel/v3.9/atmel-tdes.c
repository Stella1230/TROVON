static int atmel_tdes_sg_copy(struct scatterlist **sg, size_t *offset,\r\nvoid *buf, size_t buflen, size_t total, int out)\r\n{\r\nunsigned int count, off = 0;\r\nwhile (buflen && total) {\r\ncount = min((*sg)->length - *offset, total);\r\ncount = min(count, buflen);\r\nif (!count)\r\nreturn off;\r\nscatterwalk_map_and_copy(buf + off, *sg, *offset, count, out);\r\noff += count;\r\nbuflen -= count;\r\n*offset += count;\r\ntotal -= count;\r\nif (*offset == (*sg)->length) {\r\n*sg = sg_next(*sg);\r\nif (*sg)\r\n*offset = 0;\r\nelse\r\ntotal = 0;\r\n}\r\n}\r\nreturn off;\r\n}\r\nstatic inline u32 atmel_tdes_read(struct atmel_tdes_dev *dd, u32 offset)\r\n{\r\nreturn readl_relaxed(dd->io_base + offset);\r\n}\r\nstatic inline void atmel_tdes_write(struct atmel_tdes_dev *dd,\r\nu32 offset, u32 value)\r\n{\r\nwritel_relaxed(value, dd->io_base + offset);\r\n}\r\nstatic void atmel_tdes_write_n(struct atmel_tdes_dev *dd, u32 offset,\r\nu32 *value, int count)\r\n{\r\nfor (; count--; value++, offset += 4)\r\natmel_tdes_write(dd, offset, *value);\r\n}\r\nstatic struct atmel_tdes_dev *atmel_tdes_find_dev(struct atmel_tdes_ctx *ctx)\r\n{\r\nstruct atmel_tdes_dev *tdes_dd = NULL;\r\nstruct atmel_tdes_dev *tmp;\r\nspin_lock_bh(&atmel_tdes.lock);\r\nif (!ctx->dd) {\r\nlist_for_each_entry(tmp, &atmel_tdes.dev_list, list) {\r\ntdes_dd = tmp;\r\nbreak;\r\n}\r\nctx->dd = tdes_dd;\r\n} else {\r\ntdes_dd = ctx->dd;\r\n}\r\nspin_unlock_bh(&atmel_tdes.lock);\r\nreturn tdes_dd;\r\n}\r\nstatic int atmel_tdes_hw_init(struct atmel_tdes_dev *dd)\r\n{\r\nclk_prepare_enable(dd->iclk);\r\nif (!(dd->flags & TDES_FLAGS_INIT)) {\r\natmel_tdes_write(dd, TDES_CR, TDES_CR_SWRST);\r\ndd->flags |= TDES_FLAGS_INIT;\r\ndd->err = 0;\r\n}\r\nreturn 0;\r\n}\r\nstatic int atmel_tdes_write_ctrl(struct atmel_tdes_dev *dd)\r\n{\r\nint err;\r\nu32 valcr = 0, valmr = TDES_MR_SMOD_PDC;\r\nerr = atmel_tdes_hw_init(dd);\r\nif (err)\r\nreturn err;\r\natmel_tdes_write(dd, TDES_PTCR, TDES_PTCR_TXTDIS|TDES_PTCR_RXTDIS);\r\nif (dd->ctx->keylen > (DES_KEY_SIZE << 1)) {\r\nvalmr |= TDES_MR_KEYMOD_3KEY;\r\nvalmr |= TDES_MR_TDESMOD_TDES;\r\n} else if (dd->ctx->keylen > DES_KEY_SIZE) {\r\nvalmr |= TDES_MR_KEYMOD_2KEY;\r\nvalmr |= TDES_MR_TDESMOD_TDES;\r\n} else {\r\nvalmr |= TDES_MR_TDESMOD_DES;\r\n}\r\nif (dd->flags & TDES_FLAGS_CBC) {\r\nvalmr |= TDES_MR_OPMOD_CBC;\r\n} else if (dd->flags & TDES_FLAGS_CFB) {\r\nvalmr |= TDES_MR_OPMOD_CFB;\r\nif (dd->flags & TDES_FLAGS_CFB8)\r\nvalmr |= TDES_MR_CFBS_8b;\r\nelse if (dd->flags & TDES_FLAGS_CFB16)\r\nvalmr |= TDES_MR_CFBS_16b;\r\nelse if (dd->flags & TDES_FLAGS_CFB32)\r\nvalmr |= TDES_MR_CFBS_32b;\r\n} else if (dd->flags & TDES_FLAGS_OFB) {\r\nvalmr |= TDES_MR_OPMOD_OFB;\r\n}\r\nif ((dd->flags & TDES_FLAGS_ENCRYPT) || (dd->flags & TDES_FLAGS_OFB))\r\nvalmr |= TDES_MR_CYPHER_ENC;\r\natmel_tdes_write(dd, TDES_CR, valcr);\r\natmel_tdes_write(dd, TDES_MR, valmr);\r\natmel_tdes_write_n(dd, TDES_KEY1W1R, dd->ctx->key,\r\ndd->ctx->keylen >> 2);\r\nif (((dd->flags & TDES_FLAGS_CBC) || (dd->flags & TDES_FLAGS_CFB) ||\r\n(dd->flags & TDES_FLAGS_OFB)) && dd->req->info) {\r\natmel_tdes_write_n(dd, TDES_IV1R, dd->req->info, 2);\r\n}\r\nreturn 0;\r\n}\r\nstatic int atmel_tdes_crypt_dma_stop(struct atmel_tdes_dev *dd)\r\n{\r\nint err = 0;\r\nsize_t count;\r\natmel_tdes_write(dd, TDES_PTCR, TDES_PTCR_TXTDIS|TDES_PTCR_RXTDIS);\r\nif (dd->flags & TDES_FLAGS_FAST) {\r\ndma_unmap_sg(dd->dev, dd->out_sg, 1, DMA_FROM_DEVICE);\r\ndma_unmap_sg(dd->dev, dd->in_sg, 1, DMA_TO_DEVICE);\r\n} else {\r\ndma_sync_single_for_device(dd->dev, dd->dma_addr_out,\r\ndd->dma_size, DMA_FROM_DEVICE);\r\ncount = atmel_tdes_sg_copy(&dd->out_sg, &dd->out_offset,\r\ndd->buf_out, dd->buflen, dd->dma_size, 1);\r\nif (count != dd->dma_size) {\r\nerr = -EINVAL;\r\npr_err("not all data converted: %u\n", count);\r\n}\r\n}\r\nreturn err;\r\n}\r\nstatic int atmel_tdes_dma_init(struct atmel_tdes_dev *dd)\r\n{\r\nint err = -ENOMEM;\r\ndd->buf_in = (void *)__get_free_pages(GFP_KERNEL, 0);\r\ndd->buf_out = (void *)__get_free_pages(GFP_KERNEL, 0);\r\ndd->buflen = PAGE_SIZE;\r\ndd->buflen &= ~(DES_BLOCK_SIZE - 1);\r\nif (!dd->buf_in || !dd->buf_out) {\r\ndev_err(dd->dev, "unable to alloc pages.\n");\r\ngoto err_alloc;\r\n}\r\ndd->dma_addr_in = dma_map_single(dd->dev, dd->buf_in,\r\ndd->buflen, DMA_TO_DEVICE);\r\nif (dma_mapping_error(dd->dev, dd->dma_addr_in)) {\r\ndev_err(dd->dev, "dma %d bytes error\n", dd->buflen);\r\nerr = -EINVAL;\r\ngoto err_map_in;\r\n}\r\ndd->dma_addr_out = dma_map_single(dd->dev, dd->buf_out,\r\ndd->buflen, DMA_FROM_DEVICE);\r\nif (dma_mapping_error(dd->dev, dd->dma_addr_out)) {\r\ndev_err(dd->dev, "dma %d bytes error\n", dd->buflen);\r\nerr = -EINVAL;\r\ngoto err_map_out;\r\n}\r\nreturn 0;\r\nerr_map_out:\r\ndma_unmap_single(dd->dev, dd->dma_addr_in, dd->buflen,\r\nDMA_TO_DEVICE);\r\nerr_map_in:\r\nfree_page((unsigned long)dd->buf_out);\r\nfree_page((unsigned long)dd->buf_in);\r\nerr_alloc:\r\nif (err)\r\npr_err("error: %d\n", err);\r\nreturn err;\r\n}\r\nstatic void atmel_tdes_dma_cleanup(struct atmel_tdes_dev *dd)\r\n{\r\ndma_unmap_single(dd->dev, dd->dma_addr_out, dd->buflen,\r\nDMA_FROM_DEVICE);\r\ndma_unmap_single(dd->dev, dd->dma_addr_in, dd->buflen,\r\nDMA_TO_DEVICE);\r\nfree_page((unsigned long)dd->buf_out);\r\nfree_page((unsigned long)dd->buf_in);\r\n}\r\nstatic int atmel_tdes_crypt_dma(struct crypto_tfm *tfm, dma_addr_t dma_addr_in,\r\ndma_addr_t dma_addr_out, int length)\r\n{\r\nstruct atmel_tdes_ctx *ctx = crypto_tfm_ctx(tfm);\r\nstruct atmel_tdes_dev *dd = ctx->dd;\r\nint len32;\r\ndd->dma_size = length;\r\nif (!(dd->flags & TDES_FLAGS_FAST)) {\r\ndma_sync_single_for_device(dd->dev, dma_addr_in, length,\r\nDMA_TO_DEVICE);\r\n}\r\nif ((dd->flags & TDES_FLAGS_CFB) && (dd->flags & TDES_FLAGS_CFB8))\r\nlen32 = DIV_ROUND_UP(length, sizeof(u8));\r\nelse if ((dd->flags & TDES_FLAGS_CFB) && (dd->flags & TDES_FLAGS_CFB16))\r\nlen32 = DIV_ROUND_UP(length, sizeof(u16));\r\nelse\r\nlen32 = DIV_ROUND_UP(length, sizeof(u32));\r\natmel_tdes_write(dd, TDES_PTCR, TDES_PTCR_TXTDIS|TDES_PTCR_RXTDIS);\r\natmel_tdes_write(dd, TDES_TPR, dma_addr_in);\r\natmel_tdes_write(dd, TDES_TCR, len32);\r\natmel_tdes_write(dd, TDES_RPR, dma_addr_out);\r\natmel_tdes_write(dd, TDES_RCR, len32);\r\natmel_tdes_write(dd, TDES_IER, TDES_INT_ENDRX);\r\natmel_tdes_write(dd, TDES_PTCR, TDES_PTCR_TXTEN | TDES_PTCR_RXTEN);\r\nreturn 0;\r\n}\r\nstatic int atmel_tdes_crypt_dma_start(struct atmel_tdes_dev *dd)\r\n{\r\nstruct crypto_tfm *tfm = crypto_ablkcipher_tfm(\r\ncrypto_ablkcipher_reqtfm(dd->req));\r\nint err, fast = 0, in, out;\r\nsize_t count;\r\ndma_addr_t addr_in, addr_out;\r\nif (sg_is_last(dd->in_sg) && sg_is_last(dd->out_sg)) {\r\nin = IS_ALIGNED((u32)dd->in_sg->offset, sizeof(u32));\r\nout = IS_ALIGNED((u32)dd->out_sg->offset, sizeof(u32));\r\nfast = in && out;\r\n}\r\nif (fast) {\r\ncount = min(dd->total, sg_dma_len(dd->in_sg));\r\ncount = min(count, sg_dma_len(dd->out_sg));\r\nif (count != dd->total) {\r\npr_err("request length != buffer length\n");\r\nreturn -EINVAL;\r\n}\r\nerr = dma_map_sg(dd->dev, dd->in_sg, 1, DMA_TO_DEVICE);\r\nif (!err) {\r\ndev_err(dd->dev, "dma_map_sg() error\n");\r\nreturn -EINVAL;\r\n}\r\nerr = dma_map_sg(dd->dev, dd->out_sg, 1,\r\nDMA_FROM_DEVICE);\r\nif (!err) {\r\ndev_err(dd->dev, "dma_map_sg() error\n");\r\ndma_unmap_sg(dd->dev, dd->in_sg, 1,\r\nDMA_TO_DEVICE);\r\nreturn -EINVAL;\r\n}\r\naddr_in = sg_dma_address(dd->in_sg);\r\naddr_out = sg_dma_address(dd->out_sg);\r\ndd->flags |= TDES_FLAGS_FAST;\r\n} else {\r\ncount = atmel_tdes_sg_copy(&dd->in_sg, &dd->in_offset,\r\ndd->buf_in, dd->buflen, dd->total, 0);\r\naddr_in = dd->dma_addr_in;\r\naddr_out = dd->dma_addr_out;\r\ndd->flags &= ~TDES_FLAGS_FAST;\r\n}\r\ndd->total -= count;\r\nerr = atmel_tdes_crypt_dma(tfm, addr_in, addr_out, count);\r\nif (err) {\r\ndma_unmap_sg(dd->dev, dd->in_sg, 1, DMA_TO_DEVICE);\r\ndma_unmap_sg(dd->dev, dd->out_sg, 1, DMA_TO_DEVICE);\r\n}\r\nreturn err;\r\n}\r\nstatic void atmel_tdes_finish_req(struct atmel_tdes_dev *dd, int err)\r\n{\r\nstruct ablkcipher_request *req = dd->req;\r\nclk_disable_unprepare(dd->iclk);\r\ndd->flags &= ~TDES_FLAGS_BUSY;\r\nreq->base.complete(&req->base, err);\r\n}\r\nstatic int atmel_tdes_handle_queue(struct atmel_tdes_dev *dd,\r\nstruct ablkcipher_request *req)\r\n{\r\nstruct crypto_async_request *async_req, *backlog;\r\nstruct atmel_tdes_ctx *ctx;\r\nstruct atmel_tdes_reqctx *rctx;\r\nunsigned long flags;\r\nint err, ret = 0;\r\nspin_lock_irqsave(&dd->lock, flags);\r\nif (req)\r\nret = ablkcipher_enqueue_request(&dd->queue, req);\r\nif (dd->flags & TDES_FLAGS_BUSY) {\r\nspin_unlock_irqrestore(&dd->lock, flags);\r\nreturn ret;\r\n}\r\nbacklog = crypto_get_backlog(&dd->queue);\r\nasync_req = crypto_dequeue_request(&dd->queue);\r\nif (async_req)\r\ndd->flags |= TDES_FLAGS_BUSY;\r\nspin_unlock_irqrestore(&dd->lock, flags);\r\nif (!async_req)\r\nreturn ret;\r\nif (backlog)\r\nbacklog->complete(backlog, -EINPROGRESS);\r\nreq = ablkcipher_request_cast(async_req);\r\ndd->req = req;\r\ndd->total = req->nbytes;\r\ndd->in_offset = 0;\r\ndd->in_sg = req->src;\r\ndd->out_offset = 0;\r\ndd->out_sg = req->dst;\r\nrctx = ablkcipher_request_ctx(req);\r\nctx = crypto_ablkcipher_ctx(crypto_ablkcipher_reqtfm(req));\r\nrctx->mode &= TDES_FLAGS_MODE_MASK;\r\ndd->flags = (dd->flags & ~TDES_FLAGS_MODE_MASK) | rctx->mode;\r\ndd->ctx = ctx;\r\nctx->dd = dd;\r\nerr = atmel_tdes_write_ctrl(dd);\r\nif (!err)\r\nerr = atmel_tdes_crypt_dma_start(dd);\r\nif (err) {\r\natmel_tdes_finish_req(dd, err);\r\ntasklet_schedule(&dd->queue_task);\r\n}\r\nreturn ret;\r\n}\r\nstatic int atmel_tdes_crypt(struct ablkcipher_request *req, unsigned long mode)\r\n{\r\nstruct atmel_tdes_ctx *ctx = crypto_ablkcipher_ctx(\r\ncrypto_ablkcipher_reqtfm(req));\r\nstruct atmel_tdes_reqctx *rctx = ablkcipher_request_ctx(req);\r\nstruct atmel_tdes_dev *dd;\r\nif (mode & TDES_FLAGS_CFB8) {\r\nif (!IS_ALIGNED(req->nbytes, CFB8_BLOCK_SIZE)) {\r\npr_err("request size is not exact amount of CFB8 blocks\n");\r\nreturn -EINVAL;\r\n}\r\n} else if (mode & TDES_FLAGS_CFB16) {\r\nif (!IS_ALIGNED(req->nbytes, CFB16_BLOCK_SIZE)) {\r\npr_err("request size is not exact amount of CFB16 blocks\n");\r\nreturn -EINVAL;\r\n}\r\n} else if (mode & TDES_FLAGS_CFB32) {\r\nif (!IS_ALIGNED(req->nbytes, CFB32_BLOCK_SIZE)) {\r\npr_err("request size is not exact amount of CFB32 blocks\n");\r\nreturn -EINVAL;\r\n}\r\n} else if (!IS_ALIGNED(req->nbytes, DES_BLOCK_SIZE)) {\r\npr_err("request size is not exact amount of DES blocks\n");\r\nreturn -EINVAL;\r\n}\r\ndd = atmel_tdes_find_dev(ctx);\r\nif (!dd)\r\nreturn -ENODEV;\r\nrctx->mode = mode;\r\nreturn atmel_tdes_handle_queue(dd, req);\r\n}\r\nstatic int atmel_des_setkey(struct crypto_ablkcipher *tfm, const u8 *key,\r\nunsigned int keylen)\r\n{\r\nu32 tmp[DES_EXPKEY_WORDS];\r\nint err;\r\nstruct crypto_tfm *ctfm = crypto_ablkcipher_tfm(tfm);\r\nstruct atmel_tdes_ctx *ctx = crypto_ablkcipher_ctx(tfm);\r\nif (keylen != DES_KEY_SIZE) {\r\ncrypto_ablkcipher_set_flags(tfm, CRYPTO_TFM_RES_BAD_KEY_LEN);\r\nreturn -EINVAL;\r\n}\r\nerr = des_ekey(tmp, key);\r\nif (err == 0 && (ctfm->crt_flags & CRYPTO_TFM_REQ_WEAK_KEY)) {\r\nctfm->crt_flags |= CRYPTO_TFM_RES_WEAK_KEY;\r\nreturn -EINVAL;\r\n}\r\nmemcpy(ctx->key, key, keylen);\r\nctx->keylen = keylen;\r\nreturn 0;\r\n}\r\nstatic int atmel_tdes_setkey(struct crypto_ablkcipher *tfm, const u8 *key,\r\nunsigned int keylen)\r\n{\r\nstruct atmel_tdes_ctx *ctx = crypto_ablkcipher_ctx(tfm);\r\nconst char *alg_name;\r\nalg_name = crypto_tfm_alg_name(crypto_ablkcipher_tfm(tfm));\r\nif (strstr(alg_name, "cfb") && (keylen != 2*DES_KEY_SIZE)) {\r\ncrypto_ablkcipher_set_flags(tfm, CRYPTO_TFM_RES_BAD_KEY_LEN);\r\nreturn -EINVAL;\r\n} else if ((keylen != 2*DES_KEY_SIZE) && (keylen != 3*DES_KEY_SIZE)) {\r\ncrypto_ablkcipher_set_flags(tfm, CRYPTO_TFM_RES_BAD_KEY_LEN);\r\nreturn -EINVAL;\r\n}\r\nmemcpy(ctx->key, key, keylen);\r\nctx->keylen = keylen;\r\nreturn 0;\r\n}\r\nstatic int atmel_tdes_ecb_encrypt(struct ablkcipher_request *req)\r\n{\r\nreturn atmel_tdes_crypt(req, TDES_FLAGS_ENCRYPT);\r\n}\r\nstatic int atmel_tdes_ecb_decrypt(struct ablkcipher_request *req)\r\n{\r\nreturn atmel_tdes_crypt(req, 0);\r\n}\r\nstatic int atmel_tdes_cbc_encrypt(struct ablkcipher_request *req)\r\n{\r\nreturn atmel_tdes_crypt(req, TDES_FLAGS_ENCRYPT | TDES_FLAGS_CBC);\r\n}\r\nstatic int atmel_tdes_cbc_decrypt(struct ablkcipher_request *req)\r\n{\r\nreturn atmel_tdes_crypt(req, TDES_FLAGS_CBC);\r\n}\r\nstatic int atmel_tdes_cfb_encrypt(struct ablkcipher_request *req)\r\n{\r\nreturn atmel_tdes_crypt(req, TDES_FLAGS_ENCRYPT | TDES_FLAGS_CFB);\r\n}\r\nstatic int atmel_tdes_cfb_decrypt(struct ablkcipher_request *req)\r\n{\r\nreturn atmel_tdes_crypt(req, TDES_FLAGS_CFB);\r\n}\r\nstatic int atmel_tdes_cfb8_encrypt(struct ablkcipher_request *req)\r\n{\r\nreturn atmel_tdes_crypt(req, TDES_FLAGS_ENCRYPT | TDES_FLAGS_CFB |\r\nTDES_FLAGS_CFB8);\r\n}\r\nstatic int atmel_tdes_cfb8_decrypt(struct ablkcipher_request *req)\r\n{\r\nreturn atmel_tdes_crypt(req, TDES_FLAGS_CFB | TDES_FLAGS_CFB8);\r\n}\r\nstatic int atmel_tdes_cfb16_encrypt(struct ablkcipher_request *req)\r\n{\r\nreturn atmel_tdes_crypt(req, TDES_FLAGS_ENCRYPT | TDES_FLAGS_CFB |\r\nTDES_FLAGS_CFB16);\r\n}\r\nstatic int atmel_tdes_cfb16_decrypt(struct ablkcipher_request *req)\r\n{\r\nreturn atmel_tdes_crypt(req, TDES_FLAGS_CFB | TDES_FLAGS_CFB16);\r\n}\r\nstatic int atmel_tdes_cfb32_encrypt(struct ablkcipher_request *req)\r\n{\r\nreturn atmel_tdes_crypt(req, TDES_FLAGS_ENCRYPT | TDES_FLAGS_CFB |\r\nTDES_FLAGS_CFB32);\r\n}\r\nstatic int atmel_tdes_cfb32_decrypt(struct ablkcipher_request *req)\r\n{\r\nreturn atmel_tdes_crypt(req, TDES_FLAGS_CFB | TDES_FLAGS_CFB32);\r\n}\r\nstatic int atmel_tdes_ofb_encrypt(struct ablkcipher_request *req)\r\n{\r\nreturn atmel_tdes_crypt(req, TDES_FLAGS_ENCRYPT | TDES_FLAGS_OFB);\r\n}\r\nstatic int atmel_tdes_ofb_decrypt(struct ablkcipher_request *req)\r\n{\r\nreturn atmel_tdes_crypt(req, TDES_FLAGS_OFB);\r\n}\r\nstatic int atmel_tdes_cra_init(struct crypto_tfm *tfm)\r\n{\r\ntfm->crt_ablkcipher.reqsize = sizeof(struct atmel_tdes_reqctx);\r\nreturn 0;\r\n}\r\nstatic void atmel_tdes_cra_exit(struct crypto_tfm *tfm)\r\n{\r\n}\r\nstatic void atmel_tdes_queue_task(unsigned long data)\r\n{\r\nstruct atmel_tdes_dev *dd = (struct atmel_tdes_dev *)data;\r\natmel_tdes_handle_queue(dd, NULL);\r\n}\r\nstatic void atmel_tdes_done_task(unsigned long data)\r\n{\r\nstruct atmel_tdes_dev *dd = (struct atmel_tdes_dev *) data;\r\nint err;\r\nerr = atmel_tdes_crypt_dma_stop(dd);\r\nerr = dd->err ? : err;\r\nif (dd->total && !err) {\r\nerr = atmel_tdes_crypt_dma_start(dd);\r\nif (!err)\r\nreturn;\r\n}\r\natmel_tdes_finish_req(dd, err);\r\natmel_tdes_handle_queue(dd, NULL);\r\n}\r\nstatic irqreturn_t atmel_tdes_irq(int irq, void *dev_id)\r\n{\r\nstruct atmel_tdes_dev *tdes_dd = dev_id;\r\nu32 reg;\r\nreg = atmel_tdes_read(tdes_dd, TDES_ISR);\r\nif (reg & atmel_tdes_read(tdes_dd, TDES_IMR)) {\r\natmel_tdes_write(tdes_dd, TDES_IDR, reg);\r\nif (TDES_FLAGS_BUSY & tdes_dd->flags)\r\ntasklet_schedule(&tdes_dd->done_task);\r\nelse\r\ndev_warn(tdes_dd->dev, "TDES interrupt when no active requests.\n");\r\nreturn IRQ_HANDLED;\r\n}\r\nreturn IRQ_NONE;\r\n}\r\nstatic void atmel_tdes_unregister_algs(struct atmel_tdes_dev *dd)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(tdes_algs); i++)\r\ncrypto_unregister_alg(&tdes_algs[i]);\r\n}\r\nstatic int atmel_tdes_register_algs(struct atmel_tdes_dev *dd)\r\n{\r\nint err, i, j;\r\nfor (i = 0; i < ARRAY_SIZE(tdes_algs); i++) {\r\nerr = crypto_register_alg(&tdes_algs[i]);\r\nif (err)\r\ngoto err_tdes_algs;\r\n}\r\nreturn 0;\r\nerr_tdes_algs:\r\nfor (j = 0; j < i; j++)\r\ncrypto_unregister_alg(&tdes_algs[j]);\r\nreturn err;\r\n}\r\nstatic int atmel_tdes_probe(struct platform_device *pdev)\r\n{\r\nstruct atmel_tdes_dev *tdes_dd;\r\nstruct device *dev = &pdev->dev;\r\nstruct resource *tdes_res;\r\nunsigned long tdes_phys_size;\r\nint err;\r\ntdes_dd = kzalloc(sizeof(struct atmel_tdes_dev), GFP_KERNEL);\r\nif (tdes_dd == NULL) {\r\ndev_err(dev, "unable to alloc data struct.\n");\r\nerr = -ENOMEM;\r\ngoto tdes_dd_err;\r\n}\r\ntdes_dd->dev = dev;\r\nplatform_set_drvdata(pdev, tdes_dd);\r\nINIT_LIST_HEAD(&tdes_dd->list);\r\ntasklet_init(&tdes_dd->done_task, atmel_tdes_done_task,\r\n(unsigned long)tdes_dd);\r\ntasklet_init(&tdes_dd->queue_task, atmel_tdes_queue_task,\r\n(unsigned long)tdes_dd);\r\ncrypto_init_queue(&tdes_dd->queue, ATMEL_TDES_QUEUE_LENGTH);\r\ntdes_dd->irq = -1;\r\ntdes_res = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!tdes_res) {\r\ndev_err(dev, "no MEM resource info\n");\r\nerr = -ENODEV;\r\ngoto res_err;\r\n}\r\ntdes_dd->phys_base = tdes_res->start;\r\ntdes_phys_size = resource_size(tdes_res);\r\ntdes_dd->irq = platform_get_irq(pdev, 0);\r\nif (tdes_dd->irq < 0) {\r\ndev_err(dev, "no IRQ resource info\n");\r\nerr = tdes_dd->irq;\r\ngoto res_err;\r\n}\r\nerr = request_irq(tdes_dd->irq, atmel_tdes_irq, IRQF_SHARED,\r\n"atmel-tdes", tdes_dd);\r\nif (err) {\r\ndev_err(dev, "unable to request tdes irq.\n");\r\ngoto tdes_irq_err;\r\n}\r\ntdes_dd->iclk = clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(tdes_dd->iclk)) {\r\ndev_err(dev, "clock intialization failed.\n");\r\nerr = PTR_ERR(tdes_dd->iclk);\r\ngoto clk_err;\r\n}\r\ntdes_dd->io_base = ioremap(tdes_dd->phys_base, tdes_phys_size);\r\nif (!tdes_dd->io_base) {\r\ndev_err(dev, "can't ioremap\n");\r\nerr = -ENOMEM;\r\ngoto tdes_io_err;\r\n}\r\nerr = atmel_tdes_dma_init(tdes_dd);\r\nif (err)\r\ngoto err_tdes_dma;\r\nspin_lock(&atmel_tdes.lock);\r\nlist_add_tail(&tdes_dd->list, &atmel_tdes.dev_list);\r\nspin_unlock(&atmel_tdes.lock);\r\nerr = atmel_tdes_register_algs(tdes_dd);\r\nif (err)\r\ngoto err_algs;\r\ndev_info(dev, "Atmel DES/TDES\n");\r\nreturn 0;\r\nerr_algs:\r\nspin_lock(&atmel_tdes.lock);\r\nlist_del(&tdes_dd->list);\r\nspin_unlock(&atmel_tdes.lock);\r\natmel_tdes_dma_cleanup(tdes_dd);\r\nerr_tdes_dma:\r\niounmap(tdes_dd->io_base);\r\ntdes_io_err:\r\nclk_put(tdes_dd->iclk);\r\nclk_err:\r\nfree_irq(tdes_dd->irq, tdes_dd);\r\ntdes_irq_err:\r\nres_err:\r\ntasklet_kill(&tdes_dd->done_task);\r\ntasklet_kill(&tdes_dd->queue_task);\r\nkfree(tdes_dd);\r\ntdes_dd = NULL;\r\ntdes_dd_err:\r\ndev_err(dev, "initialization failed.\n");\r\nreturn err;\r\n}\r\nstatic int atmel_tdes_remove(struct platform_device *pdev)\r\n{\r\nstatic struct atmel_tdes_dev *tdes_dd;\r\ntdes_dd = platform_get_drvdata(pdev);\r\nif (!tdes_dd)\r\nreturn -ENODEV;\r\nspin_lock(&atmel_tdes.lock);\r\nlist_del(&tdes_dd->list);\r\nspin_unlock(&atmel_tdes.lock);\r\natmel_tdes_unregister_algs(tdes_dd);\r\ntasklet_kill(&tdes_dd->done_task);\r\ntasklet_kill(&tdes_dd->queue_task);\r\natmel_tdes_dma_cleanup(tdes_dd);\r\niounmap(tdes_dd->io_base);\r\nclk_put(tdes_dd->iclk);\r\nif (tdes_dd->irq >= 0)\r\nfree_irq(tdes_dd->irq, tdes_dd);\r\nkfree(tdes_dd);\r\ntdes_dd = NULL;\r\nreturn 0;\r\n}
