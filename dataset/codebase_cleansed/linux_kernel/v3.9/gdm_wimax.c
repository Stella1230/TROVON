static void printk_hex(u8 *buf, u32 size)\r\n{\r\nint i;\r\nfor (i = 0; i < size; i++) {\r\nif (i && i % 16 == 0)\r\nprintk(KERN_DEBUG "\n%02x ", *buf++);\r\nelse\r\nprintk(KERN_DEBUG "%02x ", *buf++);\r\n}\r\nprintk(KERN_DEBUG "\n");\r\n}\r\nstatic const char *get_protocol_name(u16 protocol)\r\n{\r\nstatic char buf[32];\r\nconst char *name = "-";\r\nswitch (protocol) {\r\ncase ETH_P_ARP:\r\nname = "ARP";\r\nbreak;\r\ncase ETH_P_IP:\r\nname = "IP";\r\nbreak;\r\ncase ETH_P_IPV6:\r\nname = "IPv6";\r\nbreak;\r\n}\r\nsprintf(buf, "0x%04x(%s)", protocol, name);\r\nreturn buf;\r\n}\r\nstatic const char *get_ip_protocol_name(u8 ip_protocol)\r\n{\r\nstatic char buf[32];\r\nconst char *name = "-";\r\nswitch (ip_protocol) {\r\ncase IPPROTO_TCP:\r\nname = "TCP";\r\nbreak;\r\ncase IPPROTO_UDP:\r\nname = "UDP";\r\nbreak;\r\ncase IPPROTO_ICMP:\r\nname = "ICMP";\r\nbreak;\r\n}\r\nsprintf(buf, "%u(%s)", ip_protocol, name);\r\nreturn buf;\r\n}\r\nstatic const char *get_port_name(u16 port)\r\n{\r\nstatic char buf[32];\r\nconst char *name = "-";\r\nswitch (port) {\r\ncase 67:\r\nname = "DHCP-Server";\r\nbreak;\r\ncase 68:\r\nname = "DHCP-Client";\r\nbreak;\r\ncase 69:\r\nname = "TFTP";\r\nbreak;\r\n}\r\nsprintf(buf, "%u(%s)", port, name);\r\nreturn buf;\r\n}\r\nstatic void dump_eth_packet(const char *title, u8 *data, int len)\r\n{\r\nstruct iphdr *ih = NULL;\r\nstruct udphdr *uh = NULL;\r\nu16 protocol = 0;\r\nu8 ip_protocol = 0;\r\nu16 port = 0;\r\nprotocol = (data[12]<<8) | data[13];\r\nih = (struct iphdr *) (data+ETH_HLEN);\r\nif (protocol == ETH_P_IP) {\r\nuh = (struct udphdr *) ((char *)ih + sizeof(struct iphdr));\r\nip_protocol = ih->protocol;\r\nport = ntohs(uh->dest);\r\n} else if (protocol == ETH_P_IPV6) {\r\nstruct ipv6hdr *i6h = (struct ipv6hdr *) data;\r\nuh = (struct udphdr *) ((char *)i6h + sizeof(struct ipv6hdr));\r\nip_protocol = i6h->nexthdr;\r\nport = ntohs(uh->dest);\r\n}\r\nprintk(KERN_DEBUG "[%s] len=%d, %s, %s, %s\n",\r\ntitle, len,\r\nget_protocol_name(protocol),\r\nget_ip_protocol_name(ip_protocol),\r\nget_port_name(port));\r\nif (!(data[0] == 0xff && data[1] == 0xff)) {\r\nif (protocol == ETH_P_IP) {\r\nprintk(KERN_DEBUG " src=%pI4\n", &ih->saddr);\r\n} else if (protocol == ETH_P_IPV6) {\r\nprintk(KERN_DEBUG " src=%pI6\n", &ih->saddr);\r\n}\r\n}\r\n#if (DUMP_PACKET & DUMP_SDU_ALL)\r\nprintk_hex(data, len);\r\n#else\r\n#if (DUMP_PACKET & DUMP_SDU_ARP)\r\nif (protocol == ETH_P_ARP)\r\nprintk_hex(data, len);\r\n#endif\r\n#if (DUMP_PACKET & DUMP_SDU_IP)\r\nif (protocol == ETH_P_IP || protocol == ETH_P_IPV6)\r\nprintk_hex(data, len);\r\n#else\r\n#if (DUMP_PACKET & DUMP_SDU_IP_TCP)\r\nif (ip_protocol == IPPROTO_TCP)\r\nprintk_hex(data, len);\r\n#endif\r\n#if (DUMP_PACKET & DUMP_SDU_IP_UDP)\r\nif (ip_protocol == IPPROTO_UDP)\r\nprintk_hex(data, len);\r\n#endif\r\n#if (DUMP_PACKET & DUMP_SDU_IP_ICMP)\r\nif (ip_protocol == IPPROTO_ICMP)\r\nprintk_hex(data, len);\r\n#endif\r\n#endif\r\n#endif\r\n}\r\nstatic inline int gdm_wimax_header(struct sk_buff **pskb)\r\n{\r\nu16 buf[HCI_HEADER_SIZE / sizeof(u16)];\r\nstruct sk_buff *skb = *pskb;\r\nint ret = 0;\r\nif (unlikely(skb_headroom(skb) < HCI_HEADER_SIZE)) {\r\nstruct sk_buff *skb2;\r\nskb2 = skb_realloc_headroom(skb, HCI_HEADER_SIZE);\r\nif (skb2 == NULL)\r\nreturn -ENOMEM;\r\nif (skb->sk)\r\nskb_set_owner_w(skb2, skb->sk);\r\nkfree_skb(skb);\r\nskb = skb2;\r\n}\r\nskb_push(skb, HCI_HEADER_SIZE);\r\nbuf[0] = H2B(WIMAX_TX_SDU);\r\nbuf[1] = H2B(skb->len - HCI_HEADER_SIZE);\r\nmemcpy(skb->data, buf, HCI_HEADER_SIZE);\r\n*pskb = skb;\r\nreturn ret;\r\n}\r\nstatic void gdm_wimax_event_rcv(struct net_device *dev, u16 type, void *msg,\r\nint len)\r\n{\r\nstruct nic *nic = netdev_priv(dev);\r\n#if defined(DEBUG_HCI)\r\nu8 *buf = (u8 *) msg;\r\nu16 hci_cmd = (buf[0]<<8) | buf[1];\r\nu16 hci_len = (buf[2]<<8) | buf[3];\r\nprintk(KERN_DEBUG "H=>D: 0x%04x(%d)\n", hci_cmd, hci_len);\r\n#endif\r\ngdm_wimax_send(nic, msg, len);\r\n}\r\nstatic int gdm_wimax_event_init(void)\r\n{\r\nif (!wm_event.ref_cnt) {\r\nwm_event.sock = netlink_init(NETLINK_WIMAX,\r\ngdm_wimax_event_rcv);\r\nif (wm_event.sock) {\r\nINIT_LIST_HEAD(&wm_event.evtq);\r\nINIT_LIST_HEAD(&wm_event.freeq);\r\nINIT_WORK(&wm_event.ws, __gdm_wimax_event_send);\r\nspin_lock_init(&wm_event.evt_lock);\r\n}\r\n}\r\nif (wm_event.sock) {\r\nwm_event.ref_cnt++;\r\nreturn 0;\r\n}\r\npr_err("Creating WiMax Event netlink is failed\n");\r\nreturn -1;\r\n}\r\nstatic void gdm_wimax_event_exit(void)\r\n{\r\nif (wm_event.sock && --wm_event.ref_cnt == 0) {\r\nstruct evt_entry *e, *temp;\r\nunsigned long flags;\r\nspin_lock_irqsave(&wm_event.evt_lock, flags);\r\nlist_for_each_entry_safe(e, temp, &wm_event.evtq, list) {\r\nlist_del(&e->list);\r\nfree_event_entry(e);\r\n}\r\nlist_for_each_entry_safe(e, temp, &wm_event.freeq, list) {\r\nlist_del(&e->list);\r\nfree_event_entry(e);\r\n}\r\nspin_unlock_irqrestore(&wm_event.evt_lock, flags);\r\nnetlink_exit(wm_event.sock);\r\nwm_event.sock = NULL;\r\n}\r\n}\r\nstatic inline struct evt_entry *alloc_event_entry(void)\r\n{\r\nreturn kmalloc(sizeof(struct evt_entry), GFP_ATOMIC);\r\n}\r\nstatic inline void free_event_entry(struct evt_entry *e)\r\n{\r\nkfree(e);\r\n}\r\nstatic struct evt_entry *get_event_entry(void)\r\n{\r\nstruct evt_entry *e;\r\nif (list_empty(&wm_event.freeq))\r\ne = alloc_event_entry();\r\nelse {\r\ne = list_entry(wm_event.freeq.next, struct evt_entry, list);\r\nlist_del(&e->list);\r\n}\r\nreturn e;\r\n}\r\nstatic void put_event_entry(struct evt_entry *e)\r\n{\r\nBUG_ON(!e);\r\nlist_add_tail(&e->list, &wm_event.freeq);\r\n}\r\nstatic void __gdm_wimax_event_send(struct work_struct *work)\r\n{\r\nint idx;\r\nunsigned long flags;\r\nstruct evt_entry *e;\r\nspin_lock_irqsave(&wm_event.evt_lock, flags);\r\nwhile (!list_empty(&wm_event.evtq)) {\r\ne = list_entry(wm_event.evtq.next, struct evt_entry, list);\r\nspin_unlock_irqrestore(&wm_event.evt_lock, flags);\r\nsscanf(e->dev->name, "wm%d", &idx);\r\nnetlink_send(wm_event.sock, idx, 0, e->evt_data, e->size);\r\nspin_lock_irqsave(&wm_event.evt_lock, flags);\r\nlist_del(&e->list);\r\nput_event_entry(e);\r\n}\r\nspin_unlock_irqrestore(&wm_event.evt_lock, flags);\r\n}\r\nstatic int gdm_wimax_event_send(struct net_device *dev, char *buf, int size)\r\n{\r\nstruct evt_entry *e;\r\nunsigned long flags;\r\n#if defined(DEBUG_HCI)\r\nu16 hci_cmd = ((u8)buf[0]<<8) | (u8)buf[1];\r\nu16 hci_len = ((u8)buf[2]<<8) | (u8)buf[3];\r\nprintk(KERN_DEBUG "D=>H: 0x%04x(%d)\n", hci_cmd, hci_len);\r\n#endif\r\nspin_lock_irqsave(&wm_event.evt_lock, flags);\r\ne = get_event_entry();\r\nif (!e) {\r\nnetdev_err(dev, "%s: No memory for event\n", __func__);\r\nspin_unlock_irqrestore(&wm_event.evt_lock, flags);\r\nreturn -ENOMEM;\r\n}\r\ne->dev = dev;\r\ne->size = size;\r\nmemcpy(e->evt_data, buf, size);\r\nlist_add_tail(&e->list, &wm_event.evtq);\r\nspin_unlock_irqrestore(&wm_event.evt_lock, flags);\r\nschedule_work(&wm_event.ws);\r\nreturn 0;\r\n}\r\nstatic void tx_complete(void *arg)\r\n{\r\nstruct nic *nic = arg;\r\nif (netif_queue_stopped(nic->netdev))\r\nnetif_wake_queue(nic->netdev);\r\n}\r\nint gdm_wimax_send_tx(struct sk_buff *skb, struct net_device *dev)\r\n{\r\nint ret = 0;\r\nstruct nic *nic = netdev_priv(dev);\r\nret = gdm_wimax_send_with_cb(nic, skb->data, skb->len, tx_complete,\r\nnic);\r\nif (ret == -ENOSPC) {\r\nnetif_stop_queue(dev);\r\nret = 0;\r\n}\r\nif (ret) {\r\nskb_pull(skb, HCI_HEADER_SIZE);\r\nreturn ret;\r\n}\r\nnic->stats.tx_packets++;\r\nnic->stats.tx_bytes += skb->len - HCI_HEADER_SIZE;\r\nkfree_skb(skb);\r\nreturn ret;\r\n}\r\nstatic int gdm_wimax_tx(struct sk_buff *skb, struct net_device *dev)\r\n{\r\nint ret = 0;\r\nstruct nic *nic = netdev_priv(dev);\r\nstruct fsm_s *fsm = (struct fsm_s *) nic->sdk_data[SIOC_DATA_FSM].buf;\r\n#if defined(DEBUG_SDU)\r\ndump_eth_packet("TX", skb->data, skb->len);\r\n#endif\r\nret = gdm_wimax_header(&skb);\r\nif (ret < 0) {\r\nskb_pull(skb, HCI_HEADER_SIZE);\r\nreturn ret;\r\n}\r\n#if !defined(LOOPBACK_TEST)\r\nif (!fsm)\r\nnetdev_err(dev, "ASSERTION ERROR: fsm is NULL!!\n");\r\nelse if (fsm->m_status != M_CONNECTED) {\r\nnetdev_emerg(dev, "ASSERTION ERROR: Device is NOT ready. status=%d\n",\r\nfsm->m_status);\r\nkfree_skb(skb);\r\nreturn 0;\r\n}\r\n#endif\r\n#if defined(CONFIG_WIMAX_GDM72XX_QOS)\r\nret = gdm_qos_send_hci_pkt(skb, dev);\r\n#else\r\nret = gdm_wimax_send_tx(skb, dev);\r\n#endif\r\nreturn ret;\r\n}\r\nstatic int gdm_wimax_set_config(struct net_device *dev, struct ifmap *map)\r\n{\r\nif (dev->flags & IFF_UP)\r\nreturn -EBUSY;\r\nreturn 0;\r\n}\r\nstatic void __gdm_wimax_set_mac_addr(struct net_device *dev, char *mac_addr)\r\n{\r\nu16 hci_pkt_buf[32 / sizeof(u16)];\r\nu8 *pkt = (u8 *) &hci_pkt_buf[0];\r\nstruct nic *nic = netdev_priv(dev);\r\nmemcpy(dev->dev_addr, mac_addr, dev->addr_len);\r\nhci_pkt_buf[0] = H2B(WIMAX_SET_INFO);\r\nhci_pkt_buf[1] = H2B(8);\r\npkt[4] = 0;\r\npkt[5] = 6;\r\nmemcpy(pkt + 6, mac_addr, dev->addr_len);\r\ngdm_wimax_send(nic, pkt, HCI_HEADER_SIZE + 8);\r\n}\r\nstatic int gdm_wimax_set_mac_addr(struct net_device *dev, void *p)\r\n{\r\nstruct sockaddr *addr = p;\r\nif (netif_running(dev))\r\nreturn -EBUSY;\r\nif (!is_valid_ether_addr(addr->sa_data))\r\nreturn -EADDRNOTAVAIL;\r\n__gdm_wimax_set_mac_addr(dev, addr->sa_data);\r\nreturn 0;\r\n}\r\nstatic struct net_device_stats *gdm_wimax_stats(struct net_device *dev)\r\n{\r\nstruct nic *nic = netdev_priv(dev);\r\nreturn &nic->stats;\r\n}\r\nstatic int gdm_wimax_open(struct net_device *dev)\r\n{\r\nstruct nic *nic = netdev_priv(dev);\r\nstruct fsm_s *fsm = (struct fsm_s *) nic->sdk_data[SIOC_DATA_FSM].buf;\r\nnetif_start_queue(dev);\r\nif (fsm && fsm->m_status != M_INIT)\r\ngdm_wimax_ind_if_updown(dev, 1);\r\nreturn 0;\r\n}\r\nstatic int gdm_wimax_close(struct net_device *dev)\r\n{\r\nstruct nic *nic = netdev_priv(dev);\r\nstruct fsm_s *fsm = (struct fsm_s *) nic->sdk_data[SIOC_DATA_FSM].buf;\r\nnetif_stop_queue(dev);\r\nif (fsm && fsm->m_status != M_INIT)\r\ngdm_wimax_ind_if_updown(dev, 0);\r\nreturn 0;\r\n}\r\nstatic void kdelete(void **buf)\r\n{\r\nif (buf && *buf) {\r\nkfree(*buf);\r\n*buf = NULL;\r\n}\r\n}\r\nstatic int gdm_wimax_ioctl_get_data(struct data_s *dst, struct data_s *src)\r\n{\r\nint size;\r\nsize = dst->size < src->size ? dst->size : src->size;\r\ndst->size = size;\r\nif (src->size) {\r\nif (!dst->buf)\r\nreturn -EINVAL;\r\nif (copy_to_user(dst->buf, src->buf, size))\r\nreturn -EFAULT;\r\n}\r\nreturn 0;\r\n}\r\nstatic int gdm_wimax_ioctl_set_data(struct data_s *dst, struct data_s *src)\r\n{\r\nif (!src->size) {\r\ndst->size = 0;\r\nreturn 0;\r\n}\r\nif (!src->buf)\r\nreturn -EINVAL;\r\nif (!(dst->buf && dst->size == src->size)) {\r\nkdelete(&dst->buf);\r\ndst->buf = kmalloc(src->size, GFP_KERNEL);\r\nif (dst->buf == NULL)\r\nreturn -ENOMEM;\r\n}\r\nif (copy_from_user(dst->buf, src->buf, src->size)) {\r\nkdelete(&dst->buf);\r\nreturn -EFAULT;\r\n}\r\ndst->size = src->size;\r\nreturn 0;\r\n}\r\nstatic void gdm_wimax_cleanup_ioctl(struct net_device *dev)\r\n{\r\nstruct nic *nic = netdev_priv(dev);\r\nint i;\r\nfor (i = 0; i < SIOC_DATA_MAX; i++)\r\nkdelete(&nic->sdk_data[i].buf);\r\n}\r\nstatic void gdm_update_fsm(struct net_device *dev, struct fsm_s *new_fsm)\r\n{\r\nstruct nic *nic = netdev_priv(dev);\r\nstruct fsm_s *cur_fsm =\r\n(struct fsm_s *) nic->sdk_data[SIOC_DATA_FSM].buf;\r\nif (!cur_fsm)\r\nreturn;\r\nif (cur_fsm->m_status != new_fsm->m_status ||\r\ncur_fsm->c_status != new_fsm->c_status) {\r\nif (new_fsm->m_status == M_CONNECTED)\r\nnetif_carrier_on(dev);\r\nelse if (cur_fsm->m_status == M_CONNECTED) {\r\nnetif_carrier_off(dev);\r\n#if defined(CONFIG_WIMAX_GDM72XX_QOS)\r\ngdm_qos_release_list(nic);\r\n#endif\r\n}\r\ngdm_wimax_ind_fsm_update(dev, new_fsm);\r\n}\r\n}\r\nstatic int gdm_wimax_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)\r\n{\r\nstruct wm_req_s *req = (struct wm_req_s *) ifr;\r\nstruct nic *nic = netdev_priv(dev);\r\nint ret;\r\nif (cmd != SIOCWMIOCTL)\r\nreturn -EOPNOTSUPP;\r\nswitch (req->cmd) {\r\ncase SIOCG_DATA:\r\ncase SIOCS_DATA:\r\nif (req->data_id >= SIOC_DATA_MAX) {\r\nnetdev_err(dev, "%s error: data-index(%d) is invalid!!\n",\r\n__func__, req->data_id);\r\nreturn -EOPNOTSUPP;\r\n}\r\nif (req->cmd == SIOCG_DATA) {\r\nret = gdm_wimax_ioctl_get_data(&req->data,\r\n&nic->sdk_data[req->data_id]);\r\nif (ret < 0)\r\nreturn ret;\r\n} else if (req->cmd == SIOCS_DATA) {\r\nif (req->data_id == SIOC_DATA_FSM) {\r\ngdm_update_fsm(dev,\r\n(struct fsm_s *) req->data.buf);\r\n}\r\nret = gdm_wimax_ioctl_set_data(\r\n&nic->sdk_data[req->data_id], &req->data);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nbreak;\r\ndefault:\r\nnetdev_err(dev, "%s: %x unknown ioctl\n", __func__, cmd);\r\nreturn -EOPNOTSUPP;\r\n}\r\nreturn 0;\r\n}\r\nstatic void gdm_wimax_prepare_device(struct net_device *dev)\r\n{\r\nstruct nic *nic = netdev_priv(dev);\r\nu16 buf[32 / sizeof(u16)];\r\nstruct hci_s *hci = (struct hci_s *) buf;\r\nu16 len = 0;\r\nu32 val = 0;\r\n#define BIT_MULTI_CS 0\r\n#define BIT_WIMAX 1\r\n#define BIT_QOS 2\r\n#define BIT_AGGREGATION 3\r\nlen = 0;\r\nhci->cmd_evt = H2B(WIMAX_GET_INFO);\r\nhci->data[len++] = TLV_T(T_MAC_ADDRESS);\r\nhci->length = H2B(len);\r\ngdm_wimax_send(nic, hci, HCI_HEADER_SIZE+len);\r\nval = (1<<BIT_WIMAX) | (1<<BIT_MULTI_CS);\r\n#if defined(CONFIG_WIMAX_GDM72XX_QOS)\r\nval |= (1<<BIT_QOS);\r\n#endif\r\n#if defined(CONFIG_WIMAX_GDM72XX_WIMAX2)\r\nval |= (1<<BIT_AGGREGATION);\r\n#endif\r\nlen = 0;\r\nhci->cmd_evt = H2B(WIMAX_SET_INFO);\r\nhci->data[len++] = TLV_T(T_CAPABILITY);\r\nhci->data[len++] = TLV_L(T_CAPABILITY);\r\nval = DH2B(val);\r\nmemcpy(&hci->data[len], &val, TLV_L(T_CAPABILITY));\r\nlen += TLV_L(T_CAPABILITY);\r\nhci->length = H2B(len);\r\ngdm_wimax_send(nic, hci, HCI_HEADER_SIZE+len);\r\nnetdev_info(dev, "GDM WiMax Set CAPABILITY: 0x%08X\n", DB2H(val));\r\n}\r\nstatic int gdm_wimax_hci_get_tlv(u8 *buf, u8 *T, u16 *L, u8 **V)\r\n{\r\n#define __U82U16(b) ((u16)((u8 *)(b))[0] | ((u16)((u8 *)(b))[1] << 8))\r\nint next_pos;\r\n*T = buf[0];\r\nif (buf[1] == 0x82) {\r\n*L = B2H(__U82U16(&buf[2]));\r\nnext_pos = 1+3;\r\n} else {\r\n*L = buf[1];\r\nnext_pos = 1+1;\r\n}\r\n*V = &buf[next_pos];\r\nnext_pos += *L;\r\nreturn next_pos;\r\n}\r\nstatic int gdm_wimax_get_prepared_info(struct net_device *dev, char *buf,\r\nint len)\r\n{\r\nu8 T, *V;\r\nu16 L;\r\nu16 cmd_evt, cmd_len;\r\nint pos = HCI_HEADER_SIZE;\r\ncmd_evt = B2H(*(u16 *)&buf[0]);\r\ncmd_len = B2H(*(u16 *)&buf[2]);\r\nif (len < cmd_len + HCI_HEADER_SIZE) {\r\nnetdev_err(dev, "%s: invalid length [%d/%d]\n", __func__,\r\ncmd_len + HCI_HEADER_SIZE, len);\r\nreturn -1;\r\n}\r\nif (cmd_evt == WIMAX_GET_INFO_RESULT) {\r\nif (cmd_len < 2) {\r\nnetdev_err(dev, "%s: len is too short [%x/%d]\n",\r\n__func__, cmd_evt, len);\r\nreturn -1;\r\n}\r\npos += gdm_wimax_hci_get_tlv(&buf[pos], &T, &L, &V);\r\nif (T == TLV_T(T_MAC_ADDRESS)) {\r\nif (L != dev->addr_len) {\r\nnetdev_err(dev,\r\n"%s Invalid inofrmation result T/L [%x/%d]\n",\r\n__func__, T, L);\r\nreturn -1;\r\n}\r\nnetdev_info(dev, "MAC change [%pM]->[%pM]\n",\r\ndev->dev_addr, V);\r\nmemcpy(dev->dev_addr, V, dev->addr_len);\r\nreturn 1;\r\n}\r\n}\r\ngdm_wimax_event_send(dev, buf, len);\r\nreturn 0;\r\n}\r\nstatic void gdm_wimax_netif_rx(struct net_device *dev, char *buf, int len)\r\n{\r\nstruct nic *nic = netdev_priv(dev);\r\nstruct sk_buff *skb;\r\nint ret;\r\n#if defined(DEBUG_SDU)\r\ndump_eth_packet("RX", buf, len);\r\n#endif\r\nskb = dev_alloc_skb(len + 2);\r\nif (!skb) {\r\nnetdev_err(dev, "%s: dev_alloc_skb failed!\n", __func__);\r\nreturn;\r\n}\r\nskb_reserve(skb, 2);\r\nnic->stats.rx_packets++;\r\nnic->stats.rx_bytes += len;\r\nmemcpy(skb_put(skb, len), buf, len);\r\nskb->dev = dev;\r\nskb->protocol = eth_type_trans(skb, dev);\r\nret = in_interrupt() ? netif_rx(skb) : netif_rx_ni(skb);\r\nif (ret == NET_RX_DROP)\r\nnetdev_err(dev, "%s skb dropped\n", __func__);\r\n}\r\nstatic void gdm_wimax_transmit_aggr_pkt(struct net_device *dev, char *buf,\r\nint len)\r\n{\r\n#define HCI_PADDING_BYTE 4\r\n#define HCI_RESERVED_BYTE 4\r\nstruct hci_s *hci;\r\nint length;\r\nwhile (len > 0) {\r\nhci = (struct hci_s *) buf;\r\nif (B2H(hci->cmd_evt) != WIMAX_RX_SDU) {\r\nnetdev_err(dev, "Wrong cmd_evt(0x%04X)\n",\r\nB2H(hci->cmd_evt));\r\nbreak;\r\n}\r\nlength = B2H(hci->length);\r\ngdm_wimax_netif_rx(dev, hci->data, length);\r\nif (length & 0x3) {\r\nlength += HCI_PADDING_BYTE - (length & 0x3);\r\n}\r\nlength += HCI_HEADER_SIZE + HCI_RESERVED_BYTE;\r\nlen -= length;\r\nbuf += length;\r\n}\r\n}\r\nstatic void gdm_wimax_transmit_pkt(struct net_device *dev, char *buf, int len)\r\n{\r\n#if defined(CONFIG_WIMAX_GDM72XX_QOS)\r\nstruct nic *nic = netdev_priv(dev);\r\n#endif\r\nu16 cmd_evt, cmd_len;\r\nif (len == 0)\r\nreturn;\r\ncmd_evt = B2H(*(u16 *)&buf[0]);\r\ncmd_len = B2H(*(u16 *)&buf[2]);\r\nif (len < cmd_len + HCI_HEADER_SIZE) {\r\nif (len)\r\nnetdev_err(dev, "%s: invalid length [%d/%d]\n",\r\n__func__, cmd_len + HCI_HEADER_SIZE, len);\r\nreturn;\r\n}\r\nswitch (cmd_evt) {\r\ncase WIMAX_RX_SDU_AGGR:\r\ngdm_wimax_transmit_aggr_pkt(dev, &buf[HCI_HEADER_SIZE],\r\ncmd_len);\r\nbreak;\r\ncase WIMAX_RX_SDU:\r\ngdm_wimax_netif_rx(dev, &buf[HCI_HEADER_SIZE], cmd_len);\r\nbreak;\r\n#if defined(CONFIG_WIMAX_GDM72XX_QOS)\r\ncase WIMAX_EVT_MODEM_REPORT:\r\ngdm_recv_qos_hci_packet(nic, buf, len);\r\nbreak;\r\n#endif\r\ncase WIMAX_SDU_TX_FLOW:\r\nif (buf[4] == 0) {\r\nif (!netif_queue_stopped(dev))\r\nnetif_stop_queue(dev);\r\n} else if (buf[4] == 1) {\r\nif (netif_queue_stopped(dev))\r\nnetif_wake_queue(dev);\r\n}\r\nbreak;\r\ndefault:\r\ngdm_wimax_event_send(dev, buf, len);\r\nbreak;\r\n}\r\n}\r\nstatic void gdm_wimax_ind_fsm_update(struct net_device *dev, struct fsm_s *fsm)\r\n{\r\nu16 buf[32 / sizeof(u16)];\r\nu8 *hci_pkt_buf = (u8 *)&buf[0];\r\nbuf[0] = H2B(WIMAX_FSM_UPDATE);\r\nbuf[1] = H2B(sizeof(struct fsm_s));\r\nmemcpy(&hci_pkt_buf[HCI_HEADER_SIZE], fsm, sizeof(struct fsm_s));\r\ngdm_wimax_event_send(dev, hci_pkt_buf,\r\nHCI_HEADER_SIZE + sizeof(struct fsm_s));\r\n}\r\nstatic void gdm_wimax_ind_if_updown(struct net_device *dev, int if_up)\r\n{\r\nu16 buf[32 / sizeof(u16)];\r\nstruct hci_s *hci = (struct hci_s *) buf;\r\nunsigned char up_down;\r\nup_down = if_up ? WIMAX_IF_UP : WIMAX_IF_DOWN;\r\nhci->cmd_evt = H2B(WIMAX_IF_UPDOWN);\r\nhci->length = H2B(sizeof(up_down));\r\nhci->data[0] = up_down;\r\ngdm_wimax_event_send(dev, (char *)hci, HCI_HEADER_SIZE+sizeof(up_down));\r\n}\r\nstatic void rx_complete(void *arg, void *data, int len)\r\n{\r\nstruct nic *nic = arg;\r\ngdm_wimax_transmit_pkt(nic->netdev, data, len);\r\ngdm_wimax_rcv_with_cb(nic, rx_complete, nic);\r\n}\r\nstatic void prepare_rx_complete(void *arg, void *data, int len)\r\n{\r\nstruct nic *nic = arg;\r\nint ret;\r\nret = gdm_wimax_get_prepared_info(nic->netdev, data, len);\r\nif (ret == 1)\r\ngdm_wimax_rcv_with_cb(nic, rx_complete, nic);\r\nelse {\r\nif (ret < 0)\r\nnetdev_err(nic->netdev,\r\n"get_prepared_info failed(%d)\n", ret);\r\ngdm_wimax_rcv_with_cb(nic, prepare_rx_complete, nic);\r\n#if 0\r\ngdm_wimax_prepare_device(nic->netdev);\r\n#endif\r\n}\r\n}\r\nstatic void start_rx_proc(struct nic *nic)\r\n{\r\ngdm_wimax_rcv_with_cb(nic, prepare_rx_complete, nic);\r\n}\r\nint register_wimax_device(struct phy_dev *phy_dev, struct device *pdev)\r\n{\r\nstruct nic *nic = NULL;\r\nstruct net_device *dev;\r\nint ret;\r\ndev = (struct net_device *)alloc_netdev(sizeof(*nic),\r\n"wm%d", ether_setup);\r\nif (dev == NULL) {\r\npr_err("alloc_etherdev failed\n");\r\nreturn -ENOMEM;\r\n}\r\nSET_NETDEV_DEV(dev, pdev);\r\ndev->mtu = 1400;\r\ndev->netdev_ops = &gdm_netdev_ops;\r\ndev->flags &= ~IFF_MULTICAST;\r\nmemcpy(dev->dev_addr, gdm_wimax_macaddr, sizeof(gdm_wimax_macaddr));\r\nnic = netdev_priv(dev);\r\nmemset(nic, 0, sizeof(*nic));\r\nnic->netdev = dev;\r\nnic->phy_dev = phy_dev;\r\nphy_dev->netdev = dev;\r\nret = gdm_wimax_event_init();\r\nif (ret < 0) {\r\npr_err("Cannot create event.\n");\r\ngoto cleanup;\r\n}\r\nret = register_netdev(dev);\r\nif (ret)\r\ngoto cleanup;\r\n#if defined(LOOPBACK_TEST)\r\nnetif_start_queue(dev);\r\nnetif_carrier_on(dev);\r\n#else\r\nnetif_carrier_off(dev);\r\n#endif\r\n#ifdef CONFIG_WIMAX_GDM72XX_QOS\r\ngdm_qos_init(nic);\r\n#endif\r\nstart_rx_proc(nic);\r\ngdm_wimax_prepare_device(dev);\r\nreturn 0;\r\ncleanup:\r\npr_err("register_netdev failed\n");\r\nfree_netdev(dev);\r\nreturn ret;\r\n}\r\nvoid unregister_wimax_device(struct phy_dev *phy_dev)\r\n{\r\nstruct nic *nic = netdev_priv(phy_dev->netdev);\r\nstruct fsm_s *fsm = (struct fsm_s *) nic->sdk_data[SIOC_DATA_FSM].buf;\r\nif (fsm)\r\nfsm->m_status = M_INIT;\r\nunregister_netdev(nic->netdev);\r\ngdm_wimax_event_exit();\r\n#if defined(CONFIG_WIMAX_GDM72XX_QOS)\r\ngdm_qos_release_list(nic);\r\n#endif\r\ngdm_wimax_cleanup_ioctl(phy_dev->netdev);\r\nfree_netdev(nic->netdev);\r\n}
