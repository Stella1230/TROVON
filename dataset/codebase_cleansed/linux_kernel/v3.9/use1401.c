static short CheckHandle(short h)\r\n{\r\nif ((h < 0) || (h >= MAX1401))\r\nreturn U14ERR_BADHAND;\r\nif (aHand1401[h] <= 0)\r\nreturn U14ERR_BADHAND;\r\nreturn U14ERR_NOERROR;\r\n}\r\nstatic short U14Status1401(short sHand, LONG lCode, TCSBLOCK* pBlk)\r\n{\r\nDWORD dwBytes = 0;\r\nif ((sHand < 0) || (sHand >= MAX1401))\r\nreturn U14ERR_BADHAND;\r\n#ifndef _WIN64\r\nif (!USE_NT_DIOC(sHand))\r\n{\r\nif (DeviceIoControl(aHand1401[sHand], lCode, NULL, 0, pBlk,sizeof(TCSBLOCK),&dwBytes,NULL))\r\nreturn (short)((dwBytes>=sizeof(TCSBLOCK)) ? U14ERR_NOERROR : U14ERR_DRIVCOMMS);\r\nelse\r\nreturn (short)GetLastError();\r\n}\r\nelse\r\n#endif\r\n{\r\nPARAMBLK rWork;\r\nrWork.sState = U14ERR_DRIVCOMMS;\r\nif (DeviceIoControl(aHand1401[sHand], lCode, NULL, 0, &rWork,sizeof(PARAMBLK),&dwBytes,NULL) &&\r\n(dwBytes >= sizeof(PARAMBLK)))\r\n{\r\n*pBlk = rWork.csBlock;\r\nreturn rWork.sState;\r\n}\r\n}\r\nreturn U14ERR_DRIVCOMMS;\r\n}\r\nstatic short U14Control1401(short sHand, LONG lCode, TCSBLOCK* pBlk)\r\n{\r\nDWORD dwBytes = 0;\r\nif ((sHand < 0) || (sHand >= MAX1401))\r\nreturn U14ERR_BADHAND;\r\n#ifndef _WIN64\r\nif (!USE_NT_DIOC(sHand))\r\n{\r\nif (DeviceIoControl(aHand1401[sHand], lCode, NULL, 0, pBlk, sizeof(TCSBLOCK), &dwBytes, NULL))\r\nreturn (short)(dwBytes >= sizeof(TCSBLOCK) ? U14ERR_NOERROR : U14ERR_DRIVCOMMS);\r\nelse\r\nreturn (short)GetLastError();\r\n}\r\nelse\r\n#endif\r\n{\r\nPARAMBLK rWork;\r\nrWork.sState = U14ERR_DRIVCOMMS;\r\nif (DeviceIoControl(aHand1401[sHand], lCode, pBlk, sizeof(TCSBLOCK), &rWork, sizeof(PARAMBLK), &dwBytes, NULL) &&\r\n(dwBytes >= sizeof(PARAMBLK)))\r\nreturn rWork.sState;\r\n}\r\nreturn U14ERR_DRIVCOMMS;\r\n}\r\nstatic long SafeTickCount()\r\n{\r\n#ifdef _IS_WINDOWS_\r\nreturn GetTickCount();\r\n#endif\r\n#ifdef LINUX\r\nstruct timeval tv;\r\ngettimeofday(&tv, NULL);\r\nreturn (tv.tv_sec*1000 + tv.tv_usec/1000);\r\n#endif\r\n}\r\nstatic int ExtForType(short sType, char* szExt)\r\n{\r\nszExt[0] = 0;\r\nswitch (sType)\r\n{\r\ncase U14TYPE1401: strcpy(szExt, ".CMD"); break;\r\ncase U14TYPEPLUS: strcpy(szExt, ".GXC"); break;\r\ndefault:\r\nstrcpy(szExt, ".ARM");\r\nszExt[3] = (char)('M' + sType - U14TYPEU1401);\r\nif (szExt[3] > 'Z')\r\nszExt[3] = (char)(szExt[3] - 26);\r\n}\r\nreturn 0;\r\n}\r\nstatic void TranslateString(char* pStr)\r\n{\r\nint i = 0;\r\nwhile (pStr[i])\r\n{\r\nif (pStr[i] == ',')\r\npStr[i] = ' ';\r\n++i;\r\n}\r\nif ((i > 0) && (pStr[i-1] == '\n'))\r\npStr[i-1] = (char)0;\r\n}\r\nstatic int GetDriverVersion(short hand)\r\n{\r\n#ifdef _IS_WINDOWS_\r\nTCSBLOCK csBlock;\r\nint iErr = U14Status1401(hand, U14_GETDRIVERREVISION, &csBlock);\r\nif (iErr == U14ERR_NOERROR)\r\niErr = csBlock.longs[0];\r\nreturn iErr;\r\n#endif\r\n#ifdef LINUX\r\nreturn CED_GetDriverRevision(aHand1401[hand]);\r\n#endif\r\n}\r\nstatic short U14TryToOpen(int n1401, long* plRetVal, short* psHandle)\r\n{\r\nshort sErr = U14ERR_NOERROR;\r\nHANDLE hDevice = INVALID_HANDLE_VALUE;\r\nDWORD dwErr = 0;\r\nint nFirst, nLast, nDev = 0;\r\nBOOL bOldName = FALSE;\r\nif (n1401 == 0)\r\n{\r\nnFirst = 1;\r\nnLast = MAX1401;\r\n}\r\nelse\r\nnFirst = nLast = n1401;\r\nwhile (hDevice == INVALID_HANDLE_VALUE)\r\n{\r\nfor (nDev = nFirst; nDev <= nLast; nDev++)\r\n{\r\nchar szDevName[40];\r\nsprintf(szDevName, bOldName ? U14NAMEOLD : U14NAMENEW, nDev);\r\nhDevice = CreateFile(szDevName, GENERIC_WRITE | GENERIC_READ,\r\n0, 0,\r\nOPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);\r\nif (hDevice != INVALID_HANDLE_VALUE)\r\n{\r\nTCSBLOCK csBlock;\r\nassert(aHand1401[nDev-1] == INVALID_HANDLE_VALUE);\r\naHand1401[nDev-1] = hDevice;\r\n#ifndef _WIN64\r\nabUseNTDIOC[nDev-1] = (BOOL)(!bWindows9x || !bOldName);\r\n#endif\r\nsErr = U14Status1401((short)(nDev-1), U14_TYPEOF1401, &csBlock);\r\nif (sErr == U14ERR_NOERROR)\r\n{\r\n*plRetVal = csBlock.ints[0];\r\nif (csBlock.ints[0] == U14ERR_INUSE)\r\n{\r\nCloseHandle(hDevice);\r\nhDevice = INVALID_HANDLE_VALUE;\r\naHand1401[nDev-1] = INVALID_HANDLE_VALUE;\r\nsErr = U14ERR_INUSE;\r\n}\r\nelse\r\nbreak;\r\n}\r\nelse\r\n{\r\nCloseHandle(hDevice);\r\nhDevice = INVALID_HANDLE_VALUE;\r\naHand1401[nDev-1] = INVALID_HANDLE_VALUE;\r\n}\r\n}\r\nelse\r\n{\r\nDWORD dwe = GetLastError();\r\nif ((dwe != ERROR_FILE_NOT_FOUND) || (dwErr == 0))\r\ndwErr = dwe;\r\n}\r\n}\r\nif ((hDevice == INVALID_HANDLE_VALUE) &&\r\n(bWindows9x) &&\r\n(bOldName == FALSE))\r\nbOldName = TRUE;\r\nelse\r\nbreak;\r\n}\r\nif (hDevice != INVALID_HANDLE_VALUE)\r\n*psHandle = (short)(nDev-1);\r\nelse\r\n{\r\nif (dwErr == ERROR_FILE_NOT_FOUND)\r\nsErr = U14ERR_NO1401DRIV;\r\nelse if (dwErr == ERROR_NOT_SUPPORTED)\r\nsErr = U14ERR_DRIVTOOOLD;\r\nelse if (dwErr == ERROR_ACCESS_DENIED)\r\nsErr = U14ERR_INUSE;\r\nelse\r\nsErr = U14ERR_DRIVCOMMS;\r\n}\r\nreturn sErr;\r\n}\r\nstatic short U14TryToOpen(int n1401, long* plRetVal, short* psHandle)\r\n{\r\nshort sErr = U14ERR_NOERROR;\r\nint fh = 0;\r\nint iErr = 0;\r\nint nFirst, nLast, nDev = 0;\r\nif (n1401 == 0)\r\n{\r\nnFirst = 1;\r\nnLast = MAX1401;\r\n}\r\nelse\r\nnFirst = nLast = n1401;\r\nfor (nDev = nFirst; nDev <= nLast; nDev++)\r\n{\r\nchar szDevName[40];\r\nsprintf(szDevName,"/dev/cedusb/%d", nDev-1);\r\nfh = open(szDevName, O_RDWR);\r\nif (fh > 0)\r\n{\r\nint iType1401 = CED_TypeOf1401(fh);\r\naHand1401[nDev-1] = fh;\r\nif (iType1401 >= 0)\r\n{\r\n*plRetVal = iType1401;\r\nbreak;\r\n}\r\nelse\r\n{\r\nclose(fh);\r\nfh = 0;\r\naHand1401[nDev-1] = 0;\r\n}\r\n}\r\nelse\r\n{\r\nif (((errno != ENODEV) && (errno != ENOENT)) || (iErr == 0))\r\niErr = errno;\r\n}\r\n}\r\nif (fh)\r\n*psHandle = (short)(nDev-1);\r\nelse\r\n{\r\nif ((iErr == ENODEV) || (iErr == ENOENT))\r\nsErr = U14ERR_NO1401DRIV;\r\nelse if (iErr == EBUSY)\r\nsErr = U14ERR_INUSE;\r\nelse\r\nsErr = U14ERR_DRIVCOMMS;\r\n}\r\nreturn sErr;\r\n}\r\nstatic short Transfer(short hand, BOOL bTo1401, char* pData,\r\nDWORD dwSize, DWORD dw1401, short eSz)\r\n{\r\nchar strcopy[MAXSTRLEN+1];\r\nshort sResult = U14SetTransArea(hand, 0, (void *)pData, dwSize, eSz);\r\nif (sResult == U14ERR_NOERROR)\r\n{\r\nsprintf(strcopy,\r\n"TO%s,$%X,$%X,0;", bTo1401 ? "1401" : "HOST", dw1401, dwSize);\r\nU14SendString(hand, strcopy);\r\nsResult = U14CheckErr(hand);\r\nif (sResult > 0)\r\nsResult = U14ERR_TOXXXERR;\r\nU14UnSetTransfer(hand, 0);\r\n}\r\nreturn sResult;\r\n}\r\nstatic DWORD GetModuleFileName(void* dummy, char* buffer, int max)\r\n{\r\nchar szProcPath[32];\r\nsprintf(szProcPath, "/proc/%d/exe", getpid());\r\nif (readlink(szProcPath, buffer, max) != -1)\r\n{\r\ndirname (buffer);\r\nstrcat (buffer, "/");\r\nreturn strlen(buffer);\r\n}\r\nreturn 0;\r\n}\r\nINT APIENTRY DllMain(HANDLE hInst, DWORD ul_reason_being_called, LPVOID lpReserved)\r\n{\r\nint iRetVal = 1;\r\nswitch (ul_reason_being_called)\r\n{\r\ncase DLL_PROCESS_ATTACH:\r\niRetVal = U14InitLib() > 0;\r\n++iAttached;\r\nbreak;\r\ncase DLL_PROCESS_DETACH:\r\nif (--iAttached == 0)\r\nU14CloseAll();\r\nbreak;\r\n}\r\nreturn iRetVal;\r\nUNREFERENCED_PARAMETER(lpReserved);\r\n}
