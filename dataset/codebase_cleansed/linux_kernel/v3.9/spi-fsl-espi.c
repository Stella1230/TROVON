static void fsl_espi_change_mode(struct spi_device *spi)\r\n{\r\nstruct mpc8xxx_spi *mspi = spi_master_get_devdata(spi->master);\r\nstruct spi_mpc8xxx_cs *cs = spi->controller_state;\r\nstruct fsl_espi_reg *reg_base = mspi->reg_base;\r\n__be32 __iomem *mode = &reg_base->csmode[spi->chip_select];\r\n__be32 __iomem *espi_mode = &reg_base->mode;\r\nu32 tmp;\r\nunsigned long flags;\r\nlocal_irq_save(flags);\r\ntmp = mpc8xxx_spi_read_reg(espi_mode);\r\nmpc8xxx_spi_write_reg(espi_mode, tmp & ~SPMODE_ENABLE);\r\nmpc8xxx_spi_write_reg(mode, cs->hw_mode);\r\nmpc8xxx_spi_write_reg(espi_mode, tmp);\r\nlocal_irq_restore(flags);\r\n}\r\nstatic u32 fsl_espi_tx_buf_lsb(struct mpc8xxx_spi *mpc8xxx_spi)\r\n{\r\nu32 data;\r\nu16 data_h;\r\nu16 data_l;\r\nconst u32 *tx = mpc8xxx_spi->tx;\r\nif (!tx)\r\nreturn 0;\r\ndata = *tx++ << mpc8xxx_spi->tx_shift;\r\ndata_l = data & 0xffff;\r\ndata_h = (data >> 16) & 0xffff;\r\nswab16s(&data_l);\r\nswab16s(&data_h);\r\ndata = data_h | data_l;\r\nmpc8xxx_spi->tx = tx;\r\nreturn data;\r\n}\r\nstatic int fsl_espi_setup_transfer(struct spi_device *spi,\r\nstruct spi_transfer *t)\r\n{\r\nstruct mpc8xxx_spi *mpc8xxx_spi = spi_master_get_devdata(spi->master);\r\nint bits_per_word = 0;\r\nu8 pm;\r\nu32 hz = 0;\r\nstruct spi_mpc8xxx_cs *cs = spi->controller_state;\r\nif (t) {\r\nbits_per_word = t->bits_per_word;\r\nhz = t->speed_hz;\r\n}\r\nif (!bits_per_word)\r\nbits_per_word = spi->bits_per_word;\r\nif ((bits_per_word < 4) || (bits_per_word > 16))\r\nreturn -EINVAL;\r\nif (!hz)\r\nhz = spi->max_speed_hz;\r\ncs->rx_shift = 0;\r\ncs->tx_shift = 0;\r\ncs->get_rx = mpc8xxx_spi_rx_buf_u32;\r\ncs->get_tx = mpc8xxx_spi_tx_buf_u32;\r\nif (bits_per_word <= 8) {\r\ncs->rx_shift = 8 - bits_per_word;\r\n} else if (bits_per_word <= 16) {\r\ncs->rx_shift = 16 - bits_per_word;\r\nif (spi->mode & SPI_LSB_FIRST)\r\ncs->get_tx = fsl_espi_tx_buf_lsb;\r\n} else {\r\nreturn -EINVAL;\r\n}\r\nmpc8xxx_spi->rx_shift = cs->rx_shift;\r\nmpc8xxx_spi->tx_shift = cs->tx_shift;\r\nmpc8xxx_spi->get_rx = cs->get_rx;\r\nmpc8xxx_spi->get_tx = cs->get_tx;\r\nbits_per_word = bits_per_word - 1;\r\ncs->hw_mode &= ~(CSMODE_LEN(0xF) | CSMODE_DIV16 | CSMODE_PM(0xF));\r\ncs->hw_mode |= CSMODE_LEN(bits_per_word);\r\nif ((mpc8xxx_spi->spibrg / hz) > 64) {\r\ncs->hw_mode |= CSMODE_DIV16;\r\npm = DIV_ROUND_UP(mpc8xxx_spi->spibrg, hz * 16 * 4);\r\nWARN_ONCE(pm > 33, "%s: Requested speed is too low: %d Hz. "\r\n"Will use %d Hz instead.\n", dev_name(&spi->dev),\r\nhz, mpc8xxx_spi->spibrg / (4 * 16 * (32 + 1)));\r\nif (pm > 33)\r\npm = 33;\r\n} else {\r\npm = DIV_ROUND_UP(mpc8xxx_spi->spibrg, hz * 4);\r\n}\r\nif (pm)\r\npm--;\r\nif (pm < 2)\r\npm = 2;\r\ncs->hw_mode |= CSMODE_PM(pm);\r\nfsl_espi_change_mode(spi);\r\nreturn 0;\r\n}\r\nstatic int fsl_espi_cpu_bufs(struct mpc8xxx_spi *mspi, struct spi_transfer *t,\r\nunsigned int len)\r\n{\r\nu32 word;\r\nstruct fsl_espi_reg *reg_base = mspi->reg_base;\r\nmspi->count = len;\r\nmpc8xxx_spi_write_reg(&reg_base->mask, SPIM_NE);\r\nword = mspi->get_tx(mspi);\r\nmpc8xxx_spi_write_reg(&reg_base->transmit, word);\r\nreturn 0;\r\n}\r\nstatic int fsl_espi_bufs(struct spi_device *spi, struct spi_transfer *t)\r\n{\r\nstruct mpc8xxx_spi *mpc8xxx_spi = spi_master_get_devdata(spi->master);\r\nstruct fsl_espi_reg *reg_base = mpc8xxx_spi->reg_base;\r\nunsigned int len = t->len;\r\nu8 bits_per_word;\r\nint ret;\r\nbits_per_word = spi->bits_per_word;\r\nif (t->bits_per_word)\r\nbits_per_word = t->bits_per_word;\r\nmpc8xxx_spi->len = t->len;\r\nlen = roundup(len, 4) / 4;\r\nmpc8xxx_spi->tx = t->tx_buf;\r\nmpc8xxx_spi->rx = t->rx_buf;\r\nINIT_COMPLETION(mpc8xxx_spi->done);\r\nif ((t->len - 1) > SPCOM_TRANLEN_MAX) {\r\ndev_err(mpc8xxx_spi->dev, "Transaction length (%d)"\r\n" beyond the SPCOM[TRANLEN] field\n", t->len);\r\nreturn -EINVAL;\r\n}\r\nmpc8xxx_spi_write_reg(&reg_base->command,\r\n(SPCOM_CS(spi->chip_select) | SPCOM_TRANLEN(t->len - 1)));\r\nret = fsl_espi_cpu_bufs(mpc8xxx_spi, t, len);\r\nif (ret)\r\nreturn ret;\r\nwait_for_completion(&mpc8xxx_spi->done);\r\nmpc8xxx_spi_write_reg(&reg_base->mask, 0);\r\nreturn mpc8xxx_spi->count;\r\n}\r\nstatic inline void fsl_espi_addr2cmd(unsigned int addr, u8 *cmd)\r\n{\r\nif (cmd) {\r\ncmd[1] = (u8)(addr >> 16);\r\ncmd[2] = (u8)(addr >> 8);\r\ncmd[3] = (u8)(addr >> 0);\r\n}\r\n}\r\nstatic inline unsigned int fsl_espi_cmd2addr(u8 *cmd)\r\n{\r\nif (cmd)\r\nreturn cmd[1] << 16 | cmd[2] << 8 | cmd[3] << 0;\r\nreturn 0;\r\n}\r\nstatic void fsl_espi_do_trans(struct spi_message *m,\r\nstruct fsl_espi_transfer *tr)\r\n{\r\nstruct spi_device *spi = m->spi;\r\nstruct mpc8xxx_spi *mspi = spi_master_get_devdata(spi->master);\r\nstruct fsl_espi_transfer *espi_trans = tr;\r\nstruct spi_message message;\r\nstruct spi_transfer *t, *first, trans;\r\nint status = 0;\r\nspi_message_init(&message);\r\nmemset(&trans, 0, sizeof(trans));\r\nfirst = list_first_entry(&m->transfers, struct spi_transfer,\r\ntransfer_list);\r\nlist_for_each_entry(t, &m->transfers, transfer_list) {\r\nif ((first->bits_per_word != t->bits_per_word) ||\r\n(first->speed_hz != t->speed_hz)) {\r\nespi_trans->status = -EINVAL;\r\ndev_err(mspi->dev, "bits_per_word/speed_hz should be"\r\n" same for the same SPI transfer\n");\r\nreturn;\r\n}\r\ntrans.speed_hz = t->speed_hz;\r\ntrans.bits_per_word = t->bits_per_word;\r\ntrans.delay_usecs = max(first->delay_usecs, t->delay_usecs);\r\n}\r\ntrans.len = espi_trans->len;\r\ntrans.tx_buf = espi_trans->tx_buf;\r\ntrans.rx_buf = espi_trans->rx_buf;\r\nspi_message_add_tail(&trans, &message);\r\nlist_for_each_entry(t, &message.transfers, transfer_list) {\r\nif (t->bits_per_word || t->speed_hz) {\r\nstatus = -EINVAL;\r\nstatus = fsl_espi_setup_transfer(spi, t);\r\nif (status < 0)\r\nbreak;\r\n}\r\nif (t->len)\r\nstatus = fsl_espi_bufs(spi, t);\r\nif (status) {\r\nstatus = -EMSGSIZE;\r\nbreak;\r\n}\r\nif (t->delay_usecs)\r\nudelay(t->delay_usecs);\r\n}\r\nespi_trans->status = status;\r\nfsl_espi_setup_transfer(spi, NULL);\r\n}\r\nstatic void fsl_espi_cmd_trans(struct spi_message *m,\r\nstruct fsl_espi_transfer *trans, u8 *rx_buff)\r\n{\r\nstruct spi_transfer *t;\r\nu8 *local_buf;\r\nint i = 0;\r\nstruct fsl_espi_transfer *espi_trans = trans;\r\nlocal_buf = kzalloc(SPCOM_TRANLEN_MAX, GFP_KERNEL);\r\nif (!local_buf) {\r\nespi_trans->status = -ENOMEM;\r\nreturn;\r\n}\r\nlist_for_each_entry(t, &m->transfers, transfer_list) {\r\nif (t->tx_buf) {\r\nmemcpy(local_buf + i, t->tx_buf, t->len);\r\ni += t->len;\r\n}\r\n}\r\nespi_trans->tx_buf = local_buf;\r\nespi_trans->rx_buf = local_buf + espi_trans->n_tx;\r\nfsl_espi_do_trans(m, espi_trans);\r\nespi_trans->actual_length = espi_trans->len;\r\nkfree(local_buf);\r\n}\r\nstatic void fsl_espi_rw_trans(struct spi_message *m,\r\nstruct fsl_espi_transfer *trans, u8 *rx_buff)\r\n{\r\nstruct fsl_espi_transfer *espi_trans = trans;\r\nunsigned int n_tx = espi_trans->n_tx;\r\nunsigned int n_rx = espi_trans->n_rx;\r\nstruct spi_transfer *t;\r\nu8 *local_buf;\r\nu8 *rx_buf = rx_buff;\r\nunsigned int trans_len;\r\nunsigned int addr;\r\nint i, pos, loop;\r\nlocal_buf = kzalloc(SPCOM_TRANLEN_MAX, GFP_KERNEL);\r\nif (!local_buf) {\r\nespi_trans->status = -ENOMEM;\r\nreturn;\r\n}\r\nfor (pos = 0, loop = 0; pos < n_rx; pos += trans_len, loop++) {\r\ntrans_len = n_rx - pos;\r\nif (trans_len > SPCOM_TRANLEN_MAX - n_tx)\r\ntrans_len = SPCOM_TRANLEN_MAX - n_tx;\r\ni = 0;\r\nlist_for_each_entry(t, &m->transfers, transfer_list) {\r\nif (t->tx_buf) {\r\nmemcpy(local_buf + i, t->tx_buf, t->len);\r\ni += t->len;\r\n}\r\n}\r\nif (pos > 0) {\r\naddr = fsl_espi_cmd2addr(local_buf);\r\naddr += pos;\r\nfsl_espi_addr2cmd(addr, local_buf);\r\n}\r\nespi_trans->n_tx = n_tx;\r\nespi_trans->n_rx = trans_len;\r\nespi_trans->len = trans_len + n_tx;\r\nespi_trans->tx_buf = local_buf;\r\nespi_trans->rx_buf = local_buf + n_tx;\r\nfsl_espi_do_trans(m, espi_trans);\r\nmemcpy(rx_buf + pos, espi_trans->rx_buf + n_tx, trans_len);\r\nif (loop > 0)\r\nespi_trans->actual_length += espi_trans->len - n_tx;\r\nelse\r\nespi_trans->actual_length += espi_trans->len;\r\n}\r\nkfree(local_buf);\r\n}\r\nstatic void fsl_espi_do_one_msg(struct spi_message *m)\r\n{\r\nstruct spi_transfer *t;\r\nu8 *rx_buf = NULL;\r\nunsigned int n_tx = 0;\r\nunsigned int n_rx = 0;\r\nstruct fsl_espi_transfer espi_trans;\r\nlist_for_each_entry(t, &m->transfers, transfer_list) {\r\nif (t->tx_buf)\r\nn_tx += t->len;\r\nif (t->rx_buf) {\r\nn_rx += t->len;\r\nrx_buf = t->rx_buf;\r\n}\r\n}\r\nespi_trans.n_tx = n_tx;\r\nespi_trans.n_rx = n_rx;\r\nespi_trans.len = n_tx + n_rx;\r\nespi_trans.actual_length = 0;\r\nespi_trans.status = 0;\r\nif (!rx_buf)\r\nfsl_espi_cmd_trans(m, &espi_trans, NULL);\r\nelse\r\nfsl_espi_rw_trans(m, &espi_trans, rx_buf);\r\nm->actual_length = espi_trans.actual_length;\r\nm->status = espi_trans.status;\r\nm->complete(m->context);\r\n}\r\nstatic int fsl_espi_setup(struct spi_device *spi)\r\n{\r\nstruct mpc8xxx_spi *mpc8xxx_spi;\r\nstruct fsl_espi_reg *reg_base;\r\nint retval;\r\nu32 hw_mode;\r\nu32 loop_mode;\r\nstruct spi_mpc8xxx_cs *cs = spi->controller_state;\r\nif (!spi->max_speed_hz)\r\nreturn -EINVAL;\r\nif (!cs) {\r\ncs = kzalloc(sizeof *cs, GFP_KERNEL);\r\nif (!cs)\r\nreturn -ENOMEM;\r\nspi->controller_state = cs;\r\n}\r\nmpc8xxx_spi = spi_master_get_devdata(spi->master);\r\nreg_base = mpc8xxx_spi->reg_base;\r\nhw_mode = cs->hw_mode;\r\ncs->hw_mode = mpc8xxx_spi_read_reg(\r\n&reg_base->csmode[spi->chip_select]);\r\ncs->hw_mode &= ~(CSMODE_CP_BEGIN_EDGECLK | CSMODE_CI_INACTIVEHIGH\r\n| CSMODE_REV);\r\nif (spi->mode & SPI_CPHA)\r\ncs->hw_mode |= CSMODE_CP_BEGIN_EDGECLK;\r\nif (spi->mode & SPI_CPOL)\r\ncs->hw_mode |= CSMODE_CI_INACTIVEHIGH;\r\nif (!(spi->mode & SPI_LSB_FIRST))\r\ncs->hw_mode |= CSMODE_REV;\r\nloop_mode = mpc8xxx_spi_read_reg(&reg_base->mode);\r\nloop_mode &= ~SPMODE_LOOP;\r\nif (spi->mode & SPI_LOOP)\r\nloop_mode |= SPMODE_LOOP;\r\nmpc8xxx_spi_write_reg(&reg_base->mode, loop_mode);\r\nretval = fsl_espi_setup_transfer(spi, NULL);\r\nif (retval < 0) {\r\ncs->hw_mode = hw_mode;\r\nreturn retval;\r\n}\r\nreturn 0;\r\n}\r\nvoid fsl_espi_cpu_irq(struct mpc8xxx_spi *mspi, u32 events)\r\n{\r\nstruct fsl_espi_reg *reg_base = mspi->reg_base;\r\nif (events & SPIE_NE) {\r\nu32 rx_data, tmp;\r\nu8 rx_data_8;\r\nwhile (SPIE_RXCNT(events) < min(4, mspi->len)) {\r\ncpu_relax();\r\nevents = mpc8xxx_spi_read_reg(&reg_base->event);\r\n}\r\nif (mspi->len >= 4) {\r\nrx_data = mpc8xxx_spi_read_reg(&reg_base->receive);\r\n} else {\r\ntmp = mspi->len;\r\nrx_data = 0;\r\nwhile (tmp--) {\r\nrx_data_8 = in_8((u8 *)&reg_base->receive);\r\nrx_data |= (rx_data_8 << (tmp * 8));\r\n}\r\nrx_data <<= (4 - mspi->len) * 8;\r\n}\r\nmspi->len -= 4;\r\nif (mspi->rx)\r\nmspi->get_rx(rx_data, mspi);\r\n}\r\nif (!(events & SPIE_NF)) {\r\nint ret;\r\nret = spin_event_timeout(((events = mpc8xxx_spi_read_reg(\r\n&reg_base->event)) & SPIE_NF) == 0, 1000, 0);\r\nif (!ret) {\r\ndev_err(mspi->dev, "tired waiting for SPIE_NF\n");\r\nreturn;\r\n}\r\n}\r\nmpc8xxx_spi_write_reg(&reg_base->event, events);\r\nmspi->count -= 1;\r\nif (mspi->count) {\r\nu32 word = mspi->get_tx(mspi);\r\nmpc8xxx_spi_write_reg(&reg_base->transmit, word);\r\n} else {\r\ncomplete(&mspi->done);\r\n}\r\n}\r\nstatic irqreturn_t fsl_espi_irq(s32 irq, void *context_data)\r\n{\r\nstruct mpc8xxx_spi *mspi = context_data;\r\nstruct fsl_espi_reg *reg_base = mspi->reg_base;\r\nirqreturn_t ret = IRQ_NONE;\r\nu32 events;\r\nevents = mpc8xxx_spi_read_reg(&reg_base->event);\r\nif (events)\r\nret = IRQ_HANDLED;\r\ndev_vdbg(mspi->dev, "%s: events %x\n", __func__, events);\r\nfsl_espi_cpu_irq(mspi, events);\r\nreturn ret;\r\n}\r\nstatic void fsl_espi_remove(struct mpc8xxx_spi *mspi)\r\n{\r\niounmap(mspi->reg_base);\r\n}\r\nstatic struct spi_master * fsl_espi_probe(struct device *dev,\r\nstruct resource *mem, unsigned int irq)\r\n{\r\nstruct fsl_spi_platform_data *pdata = dev->platform_data;\r\nstruct spi_master *master;\r\nstruct mpc8xxx_spi *mpc8xxx_spi;\r\nstruct fsl_espi_reg *reg_base;\r\nu32 regval;\r\nint i, ret = 0;\r\nmaster = spi_alloc_master(dev, sizeof(struct mpc8xxx_spi));\r\nif (!master) {\r\nret = -ENOMEM;\r\ngoto err;\r\n}\r\ndev_set_drvdata(dev, master);\r\nret = mpc8xxx_spi_probe(dev, mem, irq);\r\nif (ret)\r\ngoto err_probe;\r\nmaster->setup = fsl_espi_setup;\r\nmpc8xxx_spi = spi_master_get_devdata(master);\r\nmpc8xxx_spi->spi_do_one_msg = fsl_espi_do_one_msg;\r\nmpc8xxx_spi->spi_remove = fsl_espi_remove;\r\nmpc8xxx_spi->reg_base = ioremap(mem->start, resource_size(mem));\r\nif (!mpc8xxx_spi->reg_base) {\r\nret = -ENOMEM;\r\ngoto err_probe;\r\n}\r\nreg_base = mpc8xxx_spi->reg_base;\r\nret = request_irq(mpc8xxx_spi->irq, fsl_espi_irq,\r\n0, "fsl_espi", mpc8xxx_spi);\r\nif (ret)\r\ngoto free_irq;\r\nif (mpc8xxx_spi->flags & SPI_QE_CPU_MODE) {\r\nmpc8xxx_spi->rx_shift = 16;\r\nmpc8xxx_spi->tx_shift = 24;\r\n}\r\nmpc8xxx_spi_write_reg(&reg_base->mode, 0);\r\nmpc8xxx_spi_write_reg(&reg_base->mask, 0);\r\nmpc8xxx_spi_write_reg(&reg_base->command, 0);\r\nmpc8xxx_spi_write_reg(&reg_base->event, 0xffffffff);\r\nfor (i = 0; i < pdata->max_chipselect; i++)\r\nmpc8xxx_spi_write_reg(&reg_base->csmode[i], CSMODE_INIT_VAL);\r\nregval = pdata->initial_spmode | SPMODE_INIT_VAL | SPMODE_ENABLE;\r\nmpc8xxx_spi_write_reg(&reg_base->mode, regval);\r\nret = spi_register_master(master);\r\nif (ret < 0)\r\ngoto unreg_master;\r\ndev_info(dev, "at 0x%p (irq = %d)\n", reg_base, mpc8xxx_spi->irq);\r\nreturn master;\r\nunreg_master:\r\nfree_irq(mpc8xxx_spi->irq, mpc8xxx_spi);\r\nfree_irq:\r\niounmap(mpc8xxx_spi->reg_base);\r\nerr_probe:\r\nspi_master_put(master);\r\nerr:\r\nreturn ERR_PTR(ret);\r\n}\r\nstatic int of_fsl_espi_get_chipselects(struct device *dev)\r\n{\r\nstruct device_node *np = dev->of_node;\r\nstruct fsl_spi_platform_data *pdata = dev->platform_data;\r\nconst u32 *prop;\r\nint len;\r\nprop = of_get_property(np, "fsl,espi-num-chipselects", &len);\r\nif (!prop || len < sizeof(*prop)) {\r\ndev_err(dev, "No 'fsl,espi-num-chipselects' property\n");\r\nreturn -EINVAL;\r\n}\r\npdata->max_chipselect = *prop;\r\npdata->cs_control = NULL;\r\nreturn 0;\r\n}\r\nstatic int of_fsl_espi_probe(struct platform_device *ofdev)\r\n{\r\nstruct device *dev = &ofdev->dev;\r\nstruct device_node *np = ofdev->dev.of_node;\r\nstruct spi_master *master;\r\nstruct resource mem;\r\nstruct resource irq;\r\nint ret = -ENOMEM;\r\nret = of_mpc8xxx_spi_probe(ofdev);\r\nif (ret)\r\nreturn ret;\r\nret = of_fsl_espi_get_chipselects(dev);\r\nif (ret)\r\ngoto err;\r\nret = of_address_to_resource(np, 0, &mem);\r\nif (ret)\r\ngoto err;\r\nret = of_irq_to_resource(np, 0, &irq);\r\nif (!ret) {\r\nret = -EINVAL;\r\ngoto err;\r\n}\r\nmaster = fsl_espi_probe(dev, &mem, irq.start);\r\nif (IS_ERR(master)) {\r\nret = PTR_ERR(master);\r\ngoto err;\r\n}\r\nreturn 0;\r\nerr:\r\nreturn ret;\r\n}\r\nstatic int of_fsl_espi_remove(struct platform_device *dev)\r\n{\r\nreturn mpc8xxx_spi_remove(&dev->dev);\r\n}
