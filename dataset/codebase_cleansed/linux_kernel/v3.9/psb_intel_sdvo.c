static struct psb_intel_sdvo *to_psb_intel_sdvo(struct drm_encoder *encoder)\r\n{\r\nreturn container_of(encoder, struct psb_intel_sdvo, base.base);\r\n}\r\nstatic struct psb_intel_sdvo *intel_attached_sdvo(struct drm_connector *connector)\r\n{\r\nreturn container_of(psb_intel_attached_encoder(connector),\r\nstruct psb_intel_sdvo, base);\r\n}\r\nstatic struct psb_intel_sdvo_connector *to_psb_intel_sdvo_connector(struct drm_connector *connector)\r\n{\r\nreturn container_of(to_psb_intel_connector(connector), struct psb_intel_sdvo_connector, base);\r\n}\r\nstatic void psb_intel_sdvo_write_sdvox(struct psb_intel_sdvo *psb_intel_sdvo, u32 val)\r\n{\r\nstruct drm_device *dev = psb_intel_sdvo->base.base.dev;\r\nu32 bval = val, cval = val;\r\nint i;\r\nif (psb_intel_sdvo->sdvo_reg == SDVOB) {\r\ncval = REG_READ(SDVOC);\r\n} else {\r\nbval = REG_READ(SDVOB);\r\n}\r\nfor (i = 0; i < 2; i++)\r\n{\r\nREG_WRITE(SDVOB, bval);\r\nREG_READ(SDVOB);\r\nREG_WRITE(SDVOC, cval);\r\nREG_READ(SDVOC);\r\n}\r\n}\r\nstatic bool psb_intel_sdvo_read_byte(struct psb_intel_sdvo *psb_intel_sdvo, u8 addr, u8 *ch)\r\n{\r\nstruct i2c_msg msgs[] = {\r\n{\r\n.addr = psb_intel_sdvo->slave_addr,\r\n.flags = 0,\r\n.len = 1,\r\n.buf = &addr,\r\n},\r\n{\r\n.addr = psb_intel_sdvo->slave_addr,\r\n.flags = I2C_M_RD,\r\n.len = 1,\r\n.buf = ch,\r\n}\r\n};\r\nint ret;\r\nif ((ret = i2c_transfer(psb_intel_sdvo->i2c, msgs, 2)) == 2)\r\nreturn true;\r\nDRM_DEBUG_KMS("i2c transfer returned %d\n", ret);\r\nreturn false;\r\n}\r\nstatic void psb_intel_sdvo_debug_write(struct psb_intel_sdvo *psb_intel_sdvo, u8 cmd,\r\nconst void *args, int args_len)\r\n{\r\nint i;\r\nDRM_DEBUG_KMS("%s: W: %02X ",\r\nSDVO_NAME(psb_intel_sdvo), cmd);\r\nfor (i = 0; i < args_len; i++)\r\nDRM_LOG_KMS("%02X ", ((u8 *)args)[i]);\r\nfor (; i < 8; i++)\r\nDRM_LOG_KMS(" ");\r\nfor (i = 0; i < ARRAY_SIZE(sdvo_cmd_names); i++) {\r\nif (cmd == sdvo_cmd_names[i].cmd) {\r\nDRM_LOG_KMS("(%s)", sdvo_cmd_names[i].name);\r\nbreak;\r\n}\r\n}\r\nif (i == ARRAY_SIZE(sdvo_cmd_names))\r\nDRM_LOG_KMS("(%02X)", cmd);\r\nDRM_LOG_KMS("\n");\r\n}\r\nstatic bool psb_intel_sdvo_write_cmd(struct psb_intel_sdvo *psb_intel_sdvo, u8 cmd,\r\nconst void *args, int args_len)\r\n{\r\nu8 buf[args_len*2 + 2], status;\r\nstruct i2c_msg msgs[args_len + 3];\r\nint i, ret;\r\npsb_intel_sdvo_debug_write(psb_intel_sdvo, cmd, args, args_len);\r\nfor (i = 0; i < args_len; i++) {\r\nmsgs[i].addr = psb_intel_sdvo->slave_addr;\r\nmsgs[i].flags = 0;\r\nmsgs[i].len = 2;\r\nmsgs[i].buf = buf + 2 *i;\r\nbuf[2*i + 0] = SDVO_I2C_ARG_0 - i;\r\nbuf[2*i + 1] = ((u8*)args)[i];\r\n}\r\nmsgs[i].addr = psb_intel_sdvo->slave_addr;\r\nmsgs[i].flags = 0;\r\nmsgs[i].len = 2;\r\nmsgs[i].buf = buf + 2*i;\r\nbuf[2*i + 0] = SDVO_I2C_OPCODE;\r\nbuf[2*i + 1] = cmd;\r\nstatus = SDVO_I2C_CMD_STATUS;\r\nmsgs[i+1].addr = psb_intel_sdvo->slave_addr;\r\nmsgs[i+1].flags = 0;\r\nmsgs[i+1].len = 1;\r\nmsgs[i+1].buf = &status;\r\nmsgs[i+2].addr = psb_intel_sdvo->slave_addr;\r\nmsgs[i+2].flags = I2C_M_RD;\r\nmsgs[i+2].len = 1;\r\nmsgs[i+2].buf = &status;\r\nret = i2c_transfer(psb_intel_sdvo->i2c, msgs, i+3);\r\nif (ret < 0) {\r\nDRM_DEBUG_KMS("I2c transfer returned %d\n", ret);\r\nreturn false;\r\n}\r\nif (ret != i+3) {\r\nDRM_DEBUG_KMS("I2c transfer returned %d/%d\n", ret, i+3);\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\nstatic bool psb_intel_sdvo_read_response(struct psb_intel_sdvo *psb_intel_sdvo,\r\nvoid *response, int response_len)\r\n{\r\nu8 retry = 5;\r\nu8 status;\r\nint i;\r\nDRM_DEBUG_KMS("%s: R: ", SDVO_NAME(psb_intel_sdvo));\r\nif (!psb_intel_sdvo_read_byte(psb_intel_sdvo,\r\nSDVO_I2C_CMD_STATUS,\r\n&status))\r\ngoto log_fail;\r\nwhile (status == SDVO_CMD_STATUS_PENDING && retry--) {\r\nudelay(15);\r\nif (!psb_intel_sdvo_read_byte(psb_intel_sdvo,\r\nSDVO_I2C_CMD_STATUS,\r\n&status))\r\ngoto log_fail;\r\n}\r\nif (status <= SDVO_CMD_STATUS_SCALING_NOT_SUPP)\r\nDRM_LOG_KMS("(%s)", cmd_status_names[status]);\r\nelse\r\nDRM_LOG_KMS("(??? %d)", status);\r\nif (status != SDVO_CMD_STATUS_SUCCESS)\r\ngoto log_fail;\r\nfor (i = 0; i < response_len; i++) {\r\nif (!psb_intel_sdvo_read_byte(psb_intel_sdvo,\r\nSDVO_I2C_RETURN_0 + i,\r\n&((u8 *)response)[i]))\r\ngoto log_fail;\r\nDRM_LOG_KMS(" %02X", ((u8 *)response)[i]);\r\n}\r\nDRM_LOG_KMS("\n");\r\nreturn true;\r\nlog_fail:\r\nDRM_LOG_KMS("... failed\n");\r\nreturn false;\r\n}\r\nstatic int psb_intel_sdvo_get_pixel_multiplier(struct drm_display_mode *mode)\r\n{\r\nif (mode->clock >= 100000)\r\nreturn 1;\r\nelse if (mode->clock >= 50000)\r\nreturn 2;\r\nelse\r\nreturn 4;\r\n}\r\nstatic bool psb_intel_sdvo_set_control_bus_switch(struct psb_intel_sdvo *psb_intel_sdvo,\r\nu8 ddc_bus)\r\n{\r\nreturn psb_intel_sdvo_write_cmd(psb_intel_sdvo,\r\nSDVO_CMD_SET_CONTROL_BUS_SWITCH,\r\n&ddc_bus, 1);\r\n}\r\nstatic bool psb_intel_sdvo_set_value(struct psb_intel_sdvo *psb_intel_sdvo, u8 cmd, const void *data, int len)\r\n{\r\nif (!psb_intel_sdvo_write_cmd(psb_intel_sdvo, cmd, data, len))\r\nreturn false;\r\nreturn psb_intel_sdvo_read_response(psb_intel_sdvo, NULL, 0);\r\n}\r\nstatic bool\r\npsb_intel_sdvo_get_value(struct psb_intel_sdvo *psb_intel_sdvo, u8 cmd, void *value, int len)\r\n{\r\nif (!psb_intel_sdvo_write_cmd(psb_intel_sdvo, cmd, NULL, 0))\r\nreturn false;\r\nreturn psb_intel_sdvo_read_response(psb_intel_sdvo, value, len);\r\n}\r\nstatic bool psb_intel_sdvo_set_target_input(struct psb_intel_sdvo *psb_intel_sdvo)\r\n{\r\nstruct psb_intel_sdvo_set_target_input_args targets = {0};\r\nreturn psb_intel_sdvo_set_value(psb_intel_sdvo,\r\nSDVO_CMD_SET_TARGET_INPUT,\r\n&targets, sizeof(targets));\r\n}\r\nstatic bool psb_intel_sdvo_get_trained_inputs(struct psb_intel_sdvo *psb_intel_sdvo, bool *input_1, bool *input_2)\r\n{\r\nstruct psb_intel_sdvo_get_trained_inputs_response response;\r\nBUILD_BUG_ON(sizeof(response) != 1);\r\nif (!psb_intel_sdvo_get_value(psb_intel_sdvo, SDVO_CMD_GET_TRAINED_INPUTS,\r\n&response, sizeof(response)))\r\nreturn false;\r\n*input_1 = response.input0_trained;\r\n*input_2 = response.input1_trained;\r\nreturn true;\r\n}\r\nstatic bool psb_intel_sdvo_set_active_outputs(struct psb_intel_sdvo *psb_intel_sdvo,\r\nu16 outputs)\r\n{\r\nreturn psb_intel_sdvo_set_value(psb_intel_sdvo,\r\nSDVO_CMD_SET_ACTIVE_OUTPUTS,\r\n&outputs, sizeof(outputs));\r\n}\r\nstatic bool psb_intel_sdvo_set_encoder_power_state(struct psb_intel_sdvo *psb_intel_sdvo,\r\nint mode)\r\n{\r\nu8 state = SDVO_ENCODER_STATE_ON;\r\nswitch (mode) {\r\ncase DRM_MODE_DPMS_ON:\r\nstate = SDVO_ENCODER_STATE_ON;\r\nbreak;\r\ncase DRM_MODE_DPMS_STANDBY:\r\nstate = SDVO_ENCODER_STATE_STANDBY;\r\nbreak;\r\ncase DRM_MODE_DPMS_SUSPEND:\r\nstate = SDVO_ENCODER_STATE_SUSPEND;\r\nbreak;\r\ncase DRM_MODE_DPMS_OFF:\r\nstate = SDVO_ENCODER_STATE_OFF;\r\nbreak;\r\n}\r\nreturn psb_intel_sdvo_set_value(psb_intel_sdvo,\r\nSDVO_CMD_SET_ENCODER_POWER_STATE, &state, sizeof(state));\r\n}\r\nstatic bool psb_intel_sdvo_get_input_pixel_clock_range(struct psb_intel_sdvo *psb_intel_sdvo,\r\nint *clock_min,\r\nint *clock_max)\r\n{\r\nstruct psb_intel_sdvo_pixel_clock_range clocks;\r\nBUILD_BUG_ON(sizeof(clocks) != 4);\r\nif (!psb_intel_sdvo_get_value(psb_intel_sdvo,\r\nSDVO_CMD_GET_INPUT_PIXEL_CLOCK_RANGE,\r\n&clocks, sizeof(clocks)))\r\nreturn false;\r\n*clock_min = clocks.min * 10;\r\n*clock_max = clocks.max * 10;\r\nreturn true;\r\n}\r\nstatic bool psb_intel_sdvo_set_target_output(struct psb_intel_sdvo *psb_intel_sdvo,\r\nu16 outputs)\r\n{\r\nreturn psb_intel_sdvo_set_value(psb_intel_sdvo,\r\nSDVO_CMD_SET_TARGET_OUTPUT,\r\n&outputs, sizeof(outputs));\r\n}\r\nstatic bool psb_intel_sdvo_set_timing(struct psb_intel_sdvo *psb_intel_sdvo, u8 cmd,\r\nstruct psb_intel_sdvo_dtd *dtd)\r\n{\r\nreturn psb_intel_sdvo_set_value(psb_intel_sdvo, cmd, &dtd->part1, sizeof(dtd->part1)) &&\r\npsb_intel_sdvo_set_value(psb_intel_sdvo, cmd + 1, &dtd->part2, sizeof(dtd->part2));\r\n}\r\nstatic bool psb_intel_sdvo_set_input_timing(struct psb_intel_sdvo *psb_intel_sdvo,\r\nstruct psb_intel_sdvo_dtd *dtd)\r\n{\r\nreturn psb_intel_sdvo_set_timing(psb_intel_sdvo,\r\nSDVO_CMD_SET_INPUT_TIMINGS_PART1, dtd);\r\n}\r\nstatic bool psb_intel_sdvo_set_output_timing(struct psb_intel_sdvo *psb_intel_sdvo,\r\nstruct psb_intel_sdvo_dtd *dtd)\r\n{\r\nreturn psb_intel_sdvo_set_timing(psb_intel_sdvo,\r\nSDVO_CMD_SET_OUTPUT_TIMINGS_PART1, dtd);\r\n}\r\nstatic bool\r\npsb_intel_sdvo_create_preferred_input_timing(struct psb_intel_sdvo *psb_intel_sdvo,\r\nuint16_t clock,\r\nuint16_t width,\r\nuint16_t height)\r\n{\r\nstruct psb_intel_sdvo_preferred_input_timing_args args;\r\nmemset(&args, 0, sizeof(args));\r\nargs.clock = clock;\r\nargs.width = width;\r\nargs.height = height;\r\nargs.interlace = 0;\r\nif (psb_intel_sdvo->is_lvds &&\r\n(psb_intel_sdvo->sdvo_lvds_fixed_mode->hdisplay != width ||\r\npsb_intel_sdvo->sdvo_lvds_fixed_mode->vdisplay != height))\r\nargs.scaled = 1;\r\nreturn psb_intel_sdvo_set_value(psb_intel_sdvo,\r\nSDVO_CMD_CREATE_PREFERRED_INPUT_TIMING,\r\n&args, sizeof(args));\r\n}\r\nstatic bool psb_intel_sdvo_get_preferred_input_timing(struct psb_intel_sdvo *psb_intel_sdvo,\r\nstruct psb_intel_sdvo_dtd *dtd)\r\n{\r\nBUILD_BUG_ON(sizeof(dtd->part1) != 8);\r\nBUILD_BUG_ON(sizeof(dtd->part2) != 8);\r\nreturn psb_intel_sdvo_get_value(psb_intel_sdvo, SDVO_CMD_GET_PREFERRED_INPUT_TIMING_PART1,\r\n&dtd->part1, sizeof(dtd->part1)) &&\r\npsb_intel_sdvo_get_value(psb_intel_sdvo, SDVO_CMD_GET_PREFERRED_INPUT_TIMING_PART2,\r\n&dtd->part2, sizeof(dtd->part2));\r\n}\r\nstatic bool psb_intel_sdvo_set_clock_rate_mult(struct psb_intel_sdvo *psb_intel_sdvo, u8 val)\r\n{\r\nreturn psb_intel_sdvo_set_value(psb_intel_sdvo, SDVO_CMD_SET_CLOCK_RATE_MULT, &val, 1);\r\n}\r\nstatic void psb_intel_sdvo_get_dtd_from_mode(struct psb_intel_sdvo_dtd *dtd,\r\nconst struct drm_display_mode *mode)\r\n{\r\nuint16_t width, height;\r\nuint16_t h_blank_len, h_sync_len, v_blank_len, v_sync_len;\r\nuint16_t h_sync_offset, v_sync_offset;\r\nwidth = mode->crtc_hdisplay;\r\nheight = mode->crtc_vdisplay;\r\nh_blank_len = mode->crtc_hblank_end - mode->crtc_hblank_start;\r\nh_sync_len = mode->crtc_hsync_end - mode->crtc_hsync_start;\r\nv_blank_len = mode->crtc_vblank_end - mode->crtc_vblank_start;\r\nv_sync_len = mode->crtc_vsync_end - mode->crtc_vsync_start;\r\nh_sync_offset = mode->crtc_hsync_start - mode->crtc_hblank_start;\r\nv_sync_offset = mode->crtc_vsync_start - mode->crtc_vblank_start;\r\ndtd->part1.clock = mode->clock / 10;\r\ndtd->part1.h_active = width & 0xff;\r\ndtd->part1.h_blank = h_blank_len & 0xff;\r\ndtd->part1.h_high = (((width >> 8) & 0xf) << 4) |\r\n((h_blank_len >> 8) & 0xf);\r\ndtd->part1.v_active = height & 0xff;\r\ndtd->part1.v_blank = v_blank_len & 0xff;\r\ndtd->part1.v_high = (((height >> 8) & 0xf) << 4) |\r\n((v_blank_len >> 8) & 0xf);\r\ndtd->part2.h_sync_off = h_sync_offset & 0xff;\r\ndtd->part2.h_sync_width = h_sync_len & 0xff;\r\ndtd->part2.v_sync_off_width = (v_sync_offset & 0xf) << 4 |\r\n(v_sync_len & 0xf);\r\ndtd->part2.sync_off_width_high = ((h_sync_offset & 0x300) >> 2) |\r\n((h_sync_len & 0x300) >> 4) | ((v_sync_offset & 0x30) >> 2) |\r\n((v_sync_len & 0x30) >> 4);\r\ndtd->part2.dtd_flags = 0x18;\r\nif (mode->flags & DRM_MODE_FLAG_PHSYNC)\r\ndtd->part2.dtd_flags |= 0x2;\r\nif (mode->flags & DRM_MODE_FLAG_PVSYNC)\r\ndtd->part2.dtd_flags |= 0x4;\r\ndtd->part2.sdvo_flags = 0;\r\ndtd->part2.v_sync_off_high = v_sync_offset & 0xc0;\r\ndtd->part2.reserved = 0;\r\n}\r\nstatic void psb_intel_sdvo_get_mode_from_dtd(struct drm_display_mode * mode,\r\nconst struct psb_intel_sdvo_dtd *dtd)\r\n{\r\nmode->hdisplay = dtd->part1.h_active;\r\nmode->hdisplay += ((dtd->part1.h_high >> 4) & 0x0f) << 8;\r\nmode->hsync_start = mode->hdisplay + dtd->part2.h_sync_off;\r\nmode->hsync_start += (dtd->part2.sync_off_width_high & 0xc0) << 2;\r\nmode->hsync_end = mode->hsync_start + dtd->part2.h_sync_width;\r\nmode->hsync_end += (dtd->part2.sync_off_width_high & 0x30) << 4;\r\nmode->htotal = mode->hdisplay + dtd->part1.h_blank;\r\nmode->htotal += (dtd->part1.h_high & 0xf) << 8;\r\nmode->vdisplay = dtd->part1.v_active;\r\nmode->vdisplay += ((dtd->part1.v_high >> 4) & 0x0f) << 8;\r\nmode->vsync_start = mode->vdisplay;\r\nmode->vsync_start += (dtd->part2.v_sync_off_width >> 4) & 0xf;\r\nmode->vsync_start += (dtd->part2.sync_off_width_high & 0x0c) << 2;\r\nmode->vsync_start += dtd->part2.v_sync_off_high & 0xc0;\r\nmode->vsync_end = mode->vsync_start +\r\n(dtd->part2.v_sync_off_width & 0xf);\r\nmode->vsync_end += (dtd->part2.sync_off_width_high & 0x3) << 4;\r\nmode->vtotal = mode->vdisplay + dtd->part1.v_blank;\r\nmode->vtotal += (dtd->part1.v_high & 0xf) << 8;\r\nmode->clock = dtd->part1.clock * 10;\r\nmode->flags &= ~(DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC);\r\nif (dtd->part2.dtd_flags & 0x2)\r\nmode->flags |= DRM_MODE_FLAG_PHSYNC;\r\nif (dtd->part2.dtd_flags & 0x4)\r\nmode->flags |= DRM_MODE_FLAG_PVSYNC;\r\n}\r\nstatic bool psb_intel_sdvo_check_supp_encode(struct psb_intel_sdvo *psb_intel_sdvo)\r\n{\r\nstruct psb_intel_sdvo_encode encode;\r\nBUILD_BUG_ON(sizeof(encode) != 2);\r\nreturn psb_intel_sdvo_get_value(psb_intel_sdvo,\r\nSDVO_CMD_GET_SUPP_ENCODE,\r\n&encode, sizeof(encode));\r\n}\r\nstatic bool psb_intel_sdvo_set_encode(struct psb_intel_sdvo *psb_intel_sdvo,\r\nuint8_t mode)\r\n{\r\nreturn psb_intel_sdvo_set_value(psb_intel_sdvo, SDVO_CMD_SET_ENCODE, &mode, 1);\r\n}\r\nstatic bool psb_intel_sdvo_set_colorimetry(struct psb_intel_sdvo *psb_intel_sdvo,\r\nuint8_t mode)\r\n{\r\nreturn psb_intel_sdvo_set_value(psb_intel_sdvo, SDVO_CMD_SET_COLORIMETRY, &mode, 1);\r\n}\r\nstatic bool psb_intel_sdvo_set_avi_infoframe(struct psb_intel_sdvo *psb_intel_sdvo)\r\n{\r\nDRM_INFO("HDMI is not supported yet");\r\nreturn false;\r\n#if 0\r\nstruct dip_infoframe avi_if = {\r\n.type = DIP_TYPE_AVI,\r\n.ver = DIP_VERSION_AVI,\r\n.len = DIP_LEN_AVI,\r\n};\r\nuint8_t tx_rate = SDVO_HBUF_TX_VSYNC;\r\nuint8_t set_buf_index[2] = { 1, 0 };\r\nuint64_t *data = (uint64_t *)&avi_if;\r\nunsigned i;\r\nintel_dip_infoframe_csum(&avi_if);\r\nif (!psb_intel_sdvo_set_value(psb_intel_sdvo,\r\nSDVO_CMD_SET_HBUF_INDEX,\r\nset_buf_index, 2))\r\nreturn false;\r\nfor (i = 0; i < sizeof(avi_if); i += 8) {\r\nif (!psb_intel_sdvo_set_value(psb_intel_sdvo,\r\nSDVO_CMD_SET_HBUF_DATA,\r\ndata, 8))\r\nreturn false;\r\ndata++;\r\n}\r\nreturn psb_intel_sdvo_set_value(psb_intel_sdvo,\r\nSDVO_CMD_SET_HBUF_TXRATE,\r\n&tx_rate, 1);\r\n#endif\r\n}\r\nstatic bool psb_intel_sdvo_set_tv_format(struct psb_intel_sdvo *psb_intel_sdvo)\r\n{\r\nstruct psb_intel_sdvo_tv_format format;\r\nuint32_t format_map;\r\nformat_map = 1 << psb_intel_sdvo->tv_format_index;\r\nmemset(&format, 0, sizeof(format));\r\nmemcpy(&format, &format_map, min(sizeof(format), sizeof(format_map)));\r\nBUILD_BUG_ON(sizeof(format) != 6);\r\nreturn psb_intel_sdvo_set_value(psb_intel_sdvo,\r\nSDVO_CMD_SET_TV_FORMAT,\r\n&format, sizeof(format));\r\n}\r\nstatic bool\r\npsb_intel_sdvo_set_output_timings_from_mode(struct psb_intel_sdvo *psb_intel_sdvo,\r\nconst struct drm_display_mode *mode)\r\n{\r\nstruct psb_intel_sdvo_dtd output_dtd;\r\nif (!psb_intel_sdvo_set_target_output(psb_intel_sdvo,\r\npsb_intel_sdvo->attached_output))\r\nreturn false;\r\npsb_intel_sdvo_get_dtd_from_mode(&output_dtd, mode);\r\nif (!psb_intel_sdvo_set_output_timing(psb_intel_sdvo, &output_dtd))\r\nreturn false;\r\nreturn true;\r\n}\r\nstatic bool\r\npsb_intel_sdvo_set_input_timings_for_mode(struct psb_intel_sdvo *psb_intel_sdvo,\r\nconst struct drm_display_mode *mode,\r\nstruct drm_display_mode *adjusted_mode)\r\n{\r\nif (!psb_intel_sdvo_set_target_input(psb_intel_sdvo))\r\nreturn false;\r\nif (!psb_intel_sdvo_create_preferred_input_timing(psb_intel_sdvo,\r\nmode->clock / 10,\r\nmode->hdisplay,\r\nmode->vdisplay))\r\nreturn false;\r\nif (!psb_intel_sdvo_get_preferred_input_timing(psb_intel_sdvo,\r\n&psb_intel_sdvo->input_dtd))\r\nreturn false;\r\npsb_intel_sdvo_get_mode_from_dtd(adjusted_mode, &psb_intel_sdvo->input_dtd);\r\ndrm_mode_set_crtcinfo(adjusted_mode, 0);\r\nreturn true;\r\n}\r\nstatic bool psb_intel_sdvo_mode_fixup(struct drm_encoder *encoder,\r\nconst struct drm_display_mode *mode,\r\nstruct drm_display_mode *adjusted_mode)\r\n{\r\nstruct psb_intel_sdvo *psb_intel_sdvo = to_psb_intel_sdvo(encoder);\r\nint multiplier;\r\nif (psb_intel_sdvo->is_tv) {\r\nif (!psb_intel_sdvo_set_output_timings_from_mode(psb_intel_sdvo, mode))\r\nreturn false;\r\n(void) psb_intel_sdvo_set_input_timings_for_mode(psb_intel_sdvo,\r\nmode,\r\nadjusted_mode);\r\n} else if (psb_intel_sdvo->is_lvds) {\r\nif (!psb_intel_sdvo_set_output_timings_from_mode(psb_intel_sdvo,\r\npsb_intel_sdvo->sdvo_lvds_fixed_mode))\r\nreturn false;\r\n(void) psb_intel_sdvo_set_input_timings_for_mode(psb_intel_sdvo,\r\nmode,\r\nadjusted_mode);\r\n}\r\nmultiplier = psb_intel_sdvo_get_pixel_multiplier(adjusted_mode);\r\npsb_intel_mode_set_pixel_multiplier(adjusted_mode, multiplier);\r\nreturn true;\r\n}\r\nstatic void psb_intel_sdvo_mode_set(struct drm_encoder *encoder,\r\nstruct drm_display_mode *mode,\r\nstruct drm_display_mode *adjusted_mode)\r\n{\r\nstruct drm_device *dev = encoder->dev;\r\nstruct drm_crtc *crtc = encoder->crtc;\r\nstruct psb_intel_crtc *psb_intel_crtc = to_psb_intel_crtc(crtc);\r\nstruct psb_intel_sdvo *psb_intel_sdvo = to_psb_intel_sdvo(encoder);\r\nu32 sdvox;\r\nstruct psb_intel_sdvo_in_out_map in_out;\r\nstruct psb_intel_sdvo_dtd input_dtd;\r\nint pixel_multiplier = psb_intel_mode_get_pixel_multiplier(adjusted_mode);\r\nint rate;\r\nif (!mode)\r\nreturn;\r\nin_out.in0 = psb_intel_sdvo->attached_output;\r\nin_out.in1 = 0;\r\npsb_intel_sdvo_set_value(psb_intel_sdvo,\r\nSDVO_CMD_SET_IN_OUT_MAP,\r\n&in_out, sizeof(in_out));\r\nif (!psb_intel_sdvo_set_target_output(psb_intel_sdvo,\r\npsb_intel_sdvo->attached_output))\r\nreturn;\r\nif (psb_intel_sdvo->is_tv || psb_intel_sdvo->is_lvds) {\r\ninput_dtd = psb_intel_sdvo->input_dtd;\r\n} else {\r\nif (!psb_intel_sdvo_set_target_output(psb_intel_sdvo,\r\npsb_intel_sdvo->attached_output))\r\nreturn;\r\npsb_intel_sdvo_get_dtd_from_mode(&input_dtd, adjusted_mode);\r\n(void) psb_intel_sdvo_set_output_timing(psb_intel_sdvo, &input_dtd);\r\n}\r\nif (!psb_intel_sdvo_set_target_input(psb_intel_sdvo))\r\nreturn;\r\nif (psb_intel_sdvo->has_hdmi_monitor) {\r\npsb_intel_sdvo_set_encode(psb_intel_sdvo, SDVO_ENCODE_HDMI);\r\npsb_intel_sdvo_set_colorimetry(psb_intel_sdvo,\r\nSDVO_COLORIMETRY_RGB256);\r\npsb_intel_sdvo_set_avi_infoframe(psb_intel_sdvo);\r\n} else\r\npsb_intel_sdvo_set_encode(psb_intel_sdvo, SDVO_ENCODE_DVI);\r\nif (psb_intel_sdvo->is_tv &&\r\n!psb_intel_sdvo_set_tv_format(psb_intel_sdvo))\r\nreturn;\r\n(void) psb_intel_sdvo_set_input_timing(psb_intel_sdvo, &input_dtd);\r\nswitch (pixel_multiplier) {\r\ndefault:\r\ncase 1: rate = SDVO_CLOCK_RATE_MULT_1X; break;\r\ncase 2: rate = SDVO_CLOCK_RATE_MULT_2X; break;\r\ncase 4: rate = SDVO_CLOCK_RATE_MULT_4X; break;\r\n}\r\nif (!psb_intel_sdvo_set_clock_rate_mult(psb_intel_sdvo, rate))\r\nreturn;\r\nsdvox = REG_READ(psb_intel_sdvo->sdvo_reg);\r\nswitch (psb_intel_sdvo->sdvo_reg) {\r\ncase SDVOB:\r\nsdvox &= SDVOB_PRESERVE_MASK;\r\nbreak;\r\ncase SDVOC:\r\nsdvox &= SDVOC_PRESERVE_MASK;\r\nbreak;\r\n}\r\nsdvox |= (9 << 19) | SDVO_BORDER_ENABLE;\r\nif (psb_intel_crtc->pipe == 1)\r\nsdvox |= SDVO_PIPE_B_SELECT;\r\nif (psb_intel_sdvo->has_hdmi_audio)\r\nsdvox |= SDVO_AUDIO_ENABLE;\r\nif (input_dtd.part2.sdvo_flags & SDVO_NEED_TO_STALL)\r\nsdvox |= SDVO_STALL_SELECT;\r\npsb_intel_sdvo_write_sdvox(psb_intel_sdvo, sdvox);\r\n}\r\nstatic void psb_intel_sdvo_dpms(struct drm_encoder *encoder, int mode)\r\n{\r\nstruct drm_device *dev = encoder->dev;\r\nstruct psb_intel_sdvo *psb_intel_sdvo = to_psb_intel_sdvo(encoder);\r\nu32 temp;\r\nswitch (mode) {\r\ncase DRM_MODE_DPMS_ON:\r\nDRM_DEBUG("DPMS_ON");\r\nbreak;\r\ncase DRM_MODE_DPMS_OFF:\r\nDRM_DEBUG("DPMS_OFF");\r\nbreak;\r\ndefault:\r\nDRM_DEBUG("DPMS: %d", mode);\r\n}\r\nif (mode != DRM_MODE_DPMS_ON) {\r\npsb_intel_sdvo_set_active_outputs(psb_intel_sdvo, 0);\r\nif (0)\r\npsb_intel_sdvo_set_encoder_power_state(psb_intel_sdvo, mode);\r\nif (mode == DRM_MODE_DPMS_OFF) {\r\ntemp = REG_READ(psb_intel_sdvo->sdvo_reg);\r\nif ((temp & SDVO_ENABLE) != 0) {\r\npsb_intel_sdvo_write_sdvox(psb_intel_sdvo, temp & ~SDVO_ENABLE);\r\n}\r\n}\r\n} else {\r\nbool input1, input2;\r\nint i;\r\nu8 status;\r\ntemp = REG_READ(psb_intel_sdvo->sdvo_reg);\r\nif ((temp & SDVO_ENABLE) == 0)\r\npsb_intel_sdvo_write_sdvox(psb_intel_sdvo, temp | SDVO_ENABLE);\r\nfor (i = 0; i < 2; i++)\r\npsb_intel_wait_for_vblank(dev);\r\nstatus = psb_intel_sdvo_get_trained_inputs(psb_intel_sdvo, &input1, &input2);\r\nif (status == SDVO_CMD_STATUS_SUCCESS && !input1) {\r\nDRM_DEBUG_KMS("First %s output reported failure to "\r\n"sync\n", SDVO_NAME(psb_intel_sdvo));\r\n}\r\nif (0)\r\npsb_intel_sdvo_set_encoder_power_state(psb_intel_sdvo, mode);\r\npsb_intel_sdvo_set_active_outputs(psb_intel_sdvo, psb_intel_sdvo->attached_output);\r\n}\r\nreturn;\r\n}\r\nstatic int psb_intel_sdvo_mode_valid(struct drm_connector *connector,\r\nstruct drm_display_mode *mode)\r\n{\r\nstruct psb_intel_sdvo *psb_intel_sdvo = intel_attached_sdvo(connector);\r\nif (mode->flags & DRM_MODE_FLAG_DBLSCAN)\r\nreturn MODE_NO_DBLESCAN;\r\nif (psb_intel_sdvo->pixel_clock_min > mode->clock)\r\nreturn MODE_CLOCK_LOW;\r\nif (psb_intel_sdvo->pixel_clock_max < mode->clock)\r\nreturn MODE_CLOCK_HIGH;\r\nif (psb_intel_sdvo->is_lvds) {\r\nif (mode->hdisplay > psb_intel_sdvo->sdvo_lvds_fixed_mode->hdisplay)\r\nreturn MODE_PANEL;\r\nif (mode->vdisplay > psb_intel_sdvo->sdvo_lvds_fixed_mode->vdisplay)\r\nreturn MODE_PANEL;\r\n}\r\nreturn MODE_OK;\r\n}\r\nstatic bool psb_intel_sdvo_get_capabilities(struct psb_intel_sdvo *psb_intel_sdvo, struct psb_intel_sdvo_caps *caps)\r\n{\r\nBUILD_BUG_ON(sizeof(*caps) != 8);\r\nif (!psb_intel_sdvo_get_value(psb_intel_sdvo,\r\nSDVO_CMD_GET_DEVICE_CAPS,\r\ncaps, sizeof(*caps)))\r\nreturn false;\r\nDRM_DEBUG_KMS("SDVO capabilities:\n"\r\n" vendor_id: %d\n"\r\n" device_id: %d\n"\r\n" device_rev_id: %d\n"\r\n" sdvo_version_major: %d\n"\r\n" sdvo_version_minor: %d\n"\r\n" sdvo_inputs_mask: %d\n"\r\n" smooth_scaling: %d\n"\r\n" sharp_scaling: %d\n"\r\n" up_scaling: %d\n"\r\n" down_scaling: %d\n"\r\n" stall_support: %d\n"\r\n" output_flags: %d\n",\r\ncaps->vendor_id,\r\ncaps->device_id,\r\ncaps->device_rev_id,\r\ncaps->sdvo_version_major,\r\ncaps->sdvo_version_minor,\r\ncaps->sdvo_inputs_mask,\r\ncaps->smooth_scaling,\r\ncaps->sharp_scaling,\r\ncaps->up_scaling,\r\ncaps->down_scaling,\r\ncaps->stall_support,\r\ncaps->output_flags);\r\nreturn true;\r\n}\r\nstatic bool\r\npsb_intel_sdvo_multifunc_encoder(struct psb_intel_sdvo *psb_intel_sdvo)\r\n{\r\nint caps = psb_intel_sdvo->caps.output_flags & 0xf;\r\nreturn caps & -caps;\r\n}\r\nstatic struct edid *\r\npsb_intel_sdvo_get_edid(struct drm_connector *connector)\r\n{\r\nstruct psb_intel_sdvo *sdvo = intel_attached_sdvo(connector);\r\nreturn drm_get_edid(connector, &sdvo->ddc);\r\n}\r\nstatic struct edid *\r\npsb_intel_sdvo_get_analog_edid(struct drm_connector *connector)\r\n{\r\nstruct drm_psb_private *dev_priv = connector->dev->dev_private;\r\nreturn drm_get_edid(connector,\r\n&dev_priv->gmbus[dev_priv->crt_ddc_pin].adapter);\r\n}\r\nstatic enum drm_connector_status\r\npsb_intel_sdvo_hdmi_sink_detect(struct drm_connector *connector)\r\n{\r\nstruct psb_intel_sdvo *psb_intel_sdvo = intel_attached_sdvo(connector);\r\nenum drm_connector_status status;\r\nstruct edid *edid;\r\nedid = psb_intel_sdvo_get_edid(connector);\r\nif (edid == NULL && psb_intel_sdvo_multifunc_encoder(psb_intel_sdvo)) {\r\nu8 ddc, saved_ddc = psb_intel_sdvo->ddc_bus;\r\nfor (ddc = psb_intel_sdvo->ddc_bus >> 1; ddc > 1; ddc >>= 1) {\r\npsb_intel_sdvo->ddc_bus = ddc;\r\nedid = psb_intel_sdvo_get_edid(connector);\r\nif (edid)\r\nbreak;\r\n}\r\nif (edid == NULL)\r\npsb_intel_sdvo->ddc_bus = saved_ddc;\r\n}\r\nif (edid == NULL)\r\nedid = psb_intel_sdvo_get_analog_edid(connector);\r\nstatus = connector_status_unknown;\r\nif (edid != NULL) {\r\nif (edid->input & DRM_EDID_INPUT_DIGITAL) {\r\nstatus = connector_status_connected;\r\nif (psb_intel_sdvo->is_hdmi) {\r\npsb_intel_sdvo->has_hdmi_monitor = drm_detect_hdmi_monitor(edid);\r\npsb_intel_sdvo->has_hdmi_audio = drm_detect_monitor_audio(edid);\r\n}\r\n} else\r\nstatus = connector_status_disconnected;\r\nkfree(edid);\r\n}\r\nif (status == connector_status_connected) {\r\nstruct psb_intel_sdvo_connector *psb_intel_sdvo_connector = to_psb_intel_sdvo_connector(connector);\r\nif (psb_intel_sdvo_connector->force_audio)\r\npsb_intel_sdvo->has_hdmi_audio = psb_intel_sdvo_connector->force_audio > 0;\r\n}\r\nreturn status;\r\n}\r\nstatic enum drm_connector_status\r\npsb_intel_sdvo_detect(struct drm_connector *connector, bool force)\r\n{\r\nuint16_t response;\r\nstruct psb_intel_sdvo *psb_intel_sdvo = intel_attached_sdvo(connector);\r\nstruct psb_intel_sdvo_connector *psb_intel_sdvo_connector = to_psb_intel_sdvo_connector(connector);\r\nenum drm_connector_status ret;\r\nif (!psb_intel_sdvo_write_cmd(psb_intel_sdvo,\r\nSDVO_CMD_GET_ATTACHED_DISPLAYS, NULL, 0))\r\nreturn connector_status_unknown;\r\nif (psb_intel_sdvo->caps.output_flags &\r\n(SDVO_OUTPUT_SVID0 | SDVO_OUTPUT_CVBS0))\r\nmdelay(30);\r\nif (!psb_intel_sdvo_read_response(psb_intel_sdvo, &response, 2))\r\nreturn connector_status_unknown;\r\nDRM_DEBUG_KMS("SDVO response %d %d [%x]\n",\r\nresponse & 0xff, response >> 8,\r\npsb_intel_sdvo_connector->output_flag);\r\nif (response == 0)\r\nreturn connector_status_disconnected;\r\npsb_intel_sdvo->attached_output = response;\r\npsb_intel_sdvo->has_hdmi_monitor = false;\r\npsb_intel_sdvo->has_hdmi_audio = false;\r\nif ((psb_intel_sdvo_connector->output_flag & response) == 0)\r\nret = connector_status_disconnected;\r\nelse if (IS_TMDS(psb_intel_sdvo_connector))\r\nret = psb_intel_sdvo_hdmi_sink_detect(connector);\r\nelse {\r\nstruct edid *edid;\r\nedid = psb_intel_sdvo_get_edid(connector);\r\nif (edid == NULL)\r\nedid = psb_intel_sdvo_get_analog_edid(connector);\r\nif (edid != NULL) {\r\nif (edid->input & DRM_EDID_INPUT_DIGITAL)\r\nret = connector_status_disconnected;\r\nelse\r\nret = connector_status_connected;\r\nkfree(edid);\r\n} else\r\nret = connector_status_connected;\r\n}\r\nif (ret == connector_status_connected) {\r\npsb_intel_sdvo->is_tv = false;\r\npsb_intel_sdvo->is_lvds = false;\r\npsb_intel_sdvo->base.needs_tv_clock = false;\r\nif (response & SDVO_TV_MASK) {\r\npsb_intel_sdvo->is_tv = true;\r\npsb_intel_sdvo->base.needs_tv_clock = true;\r\n}\r\nif (response & SDVO_LVDS_MASK)\r\npsb_intel_sdvo->is_lvds = psb_intel_sdvo->sdvo_lvds_fixed_mode != NULL;\r\n}\r\nreturn ret;\r\n}\r\nstatic void psb_intel_sdvo_get_ddc_modes(struct drm_connector *connector)\r\n{\r\nstruct edid *edid;\r\nedid = psb_intel_sdvo_get_edid(connector);\r\nif (edid == NULL)\r\nedid = psb_intel_sdvo_get_analog_edid(connector);\r\nif (edid != NULL) {\r\nstruct psb_intel_sdvo_connector *psb_intel_sdvo_connector = to_psb_intel_sdvo_connector(connector);\r\nbool monitor_is_digital = !!(edid->input & DRM_EDID_INPUT_DIGITAL);\r\nbool connector_is_digital = !!IS_TMDS(psb_intel_sdvo_connector);\r\nif (connector_is_digital == monitor_is_digital) {\r\ndrm_mode_connector_update_edid_property(connector, edid);\r\ndrm_add_edid_modes(connector, edid);\r\n}\r\nkfree(edid);\r\n}\r\n}\r\nstatic void psb_intel_sdvo_get_tv_modes(struct drm_connector *connector)\r\n{\r\nstruct psb_intel_sdvo *psb_intel_sdvo = intel_attached_sdvo(connector);\r\nstruct psb_intel_sdvo_sdtv_resolution_request tv_res;\r\nuint32_t reply = 0, format_map = 0;\r\nint i;\r\nformat_map = 1 << psb_intel_sdvo->tv_format_index;\r\nmemcpy(&tv_res, &format_map,\r\nmin(sizeof(format_map), sizeof(struct psb_intel_sdvo_sdtv_resolution_request)));\r\nif (!psb_intel_sdvo_set_target_output(psb_intel_sdvo, psb_intel_sdvo->attached_output))\r\nreturn;\r\nBUILD_BUG_ON(sizeof(tv_res) != 3);\r\nif (!psb_intel_sdvo_write_cmd(psb_intel_sdvo,\r\nSDVO_CMD_GET_SDTV_RESOLUTION_SUPPORT,\r\n&tv_res, sizeof(tv_res)))\r\nreturn;\r\nif (!psb_intel_sdvo_read_response(psb_intel_sdvo, &reply, 3))\r\nreturn;\r\nfor (i = 0; i < ARRAY_SIZE(sdvo_tv_modes); i++)\r\nif (reply & (1 << i)) {\r\nstruct drm_display_mode *nmode;\r\nnmode = drm_mode_duplicate(connector->dev,\r\n&sdvo_tv_modes[i]);\r\nif (nmode)\r\ndrm_mode_probed_add(connector, nmode);\r\n}\r\n}\r\nstatic void psb_intel_sdvo_get_lvds_modes(struct drm_connector *connector)\r\n{\r\nstruct psb_intel_sdvo *psb_intel_sdvo = intel_attached_sdvo(connector);\r\nstruct drm_psb_private *dev_priv = connector->dev->dev_private;\r\nstruct drm_display_mode *newmode;\r\npsb_intel_ddc_get_modes(connector, psb_intel_sdvo->i2c);\r\nif (list_empty(&connector->probed_modes) == false)\r\ngoto end;\r\nif (dev_priv->sdvo_lvds_vbt_mode != NULL) {\r\nnewmode = drm_mode_duplicate(connector->dev,\r\ndev_priv->sdvo_lvds_vbt_mode);\r\nif (newmode != NULL) {\r\nnewmode->type = (DRM_MODE_TYPE_PREFERRED |\r\nDRM_MODE_TYPE_DRIVER);\r\ndrm_mode_probed_add(connector, newmode);\r\n}\r\n}\r\nend:\r\nlist_for_each_entry(newmode, &connector->probed_modes, head) {\r\nif (newmode->type & DRM_MODE_TYPE_PREFERRED) {\r\npsb_intel_sdvo->sdvo_lvds_fixed_mode =\r\ndrm_mode_duplicate(connector->dev, newmode);\r\ndrm_mode_set_crtcinfo(psb_intel_sdvo->sdvo_lvds_fixed_mode,\r\n0);\r\npsb_intel_sdvo->is_lvds = true;\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic int psb_intel_sdvo_get_modes(struct drm_connector *connector)\r\n{\r\nstruct psb_intel_sdvo_connector *psb_intel_sdvo_connector = to_psb_intel_sdvo_connector(connector);\r\nif (IS_TV(psb_intel_sdvo_connector))\r\npsb_intel_sdvo_get_tv_modes(connector);\r\nelse if (IS_LVDS(psb_intel_sdvo_connector))\r\npsb_intel_sdvo_get_lvds_modes(connector);\r\nelse\r\npsb_intel_sdvo_get_ddc_modes(connector);\r\nreturn !list_empty(&connector->probed_modes);\r\n}\r\nstatic void\r\npsb_intel_sdvo_destroy_enhance_property(struct drm_connector *connector)\r\n{\r\nstruct psb_intel_sdvo_connector *psb_intel_sdvo_connector = to_psb_intel_sdvo_connector(connector);\r\nstruct drm_device *dev = connector->dev;\r\nif (psb_intel_sdvo_connector->left)\r\ndrm_property_destroy(dev, psb_intel_sdvo_connector->left);\r\nif (psb_intel_sdvo_connector->right)\r\ndrm_property_destroy(dev, psb_intel_sdvo_connector->right);\r\nif (psb_intel_sdvo_connector->top)\r\ndrm_property_destroy(dev, psb_intel_sdvo_connector->top);\r\nif (psb_intel_sdvo_connector->bottom)\r\ndrm_property_destroy(dev, psb_intel_sdvo_connector->bottom);\r\nif (psb_intel_sdvo_connector->hpos)\r\ndrm_property_destroy(dev, psb_intel_sdvo_connector->hpos);\r\nif (psb_intel_sdvo_connector->vpos)\r\ndrm_property_destroy(dev, psb_intel_sdvo_connector->vpos);\r\nif (psb_intel_sdvo_connector->saturation)\r\ndrm_property_destroy(dev, psb_intel_sdvo_connector->saturation);\r\nif (psb_intel_sdvo_connector->contrast)\r\ndrm_property_destroy(dev, psb_intel_sdvo_connector->contrast);\r\nif (psb_intel_sdvo_connector->hue)\r\ndrm_property_destroy(dev, psb_intel_sdvo_connector->hue);\r\nif (psb_intel_sdvo_connector->sharpness)\r\ndrm_property_destroy(dev, psb_intel_sdvo_connector->sharpness);\r\nif (psb_intel_sdvo_connector->flicker_filter)\r\ndrm_property_destroy(dev, psb_intel_sdvo_connector->flicker_filter);\r\nif (psb_intel_sdvo_connector->flicker_filter_2d)\r\ndrm_property_destroy(dev, psb_intel_sdvo_connector->flicker_filter_2d);\r\nif (psb_intel_sdvo_connector->flicker_filter_adaptive)\r\ndrm_property_destroy(dev, psb_intel_sdvo_connector->flicker_filter_adaptive);\r\nif (psb_intel_sdvo_connector->tv_luma_filter)\r\ndrm_property_destroy(dev, psb_intel_sdvo_connector->tv_luma_filter);\r\nif (psb_intel_sdvo_connector->tv_chroma_filter)\r\ndrm_property_destroy(dev, psb_intel_sdvo_connector->tv_chroma_filter);\r\nif (psb_intel_sdvo_connector->dot_crawl)\r\ndrm_property_destroy(dev, psb_intel_sdvo_connector->dot_crawl);\r\nif (psb_intel_sdvo_connector->brightness)\r\ndrm_property_destroy(dev, psb_intel_sdvo_connector->brightness);\r\n}\r\nstatic void psb_intel_sdvo_destroy(struct drm_connector *connector)\r\n{\r\nstruct psb_intel_sdvo_connector *psb_intel_sdvo_connector = to_psb_intel_sdvo_connector(connector);\r\nif (psb_intel_sdvo_connector->tv_format)\r\ndrm_property_destroy(connector->dev,\r\npsb_intel_sdvo_connector->tv_format);\r\npsb_intel_sdvo_destroy_enhance_property(connector);\r\ndrm_sysfs_connector_remove(connector);\r\ndrm_connector_cleanup(connector);\r\nkfree(connector);\r\n}\r\nstatic bool psb_intel_sdvo_detect_hdmi_audio(struct drm_connector *connector)\r\n{\r\nstruct psb_intel_sdvo *psb_intel_sdvo = intel_attached_sdvo(connector);\r\nstruct edid *edid;\r\nbool has_audio = false;\r\nif (!psb_intel_sdvo->is_hdmi)\r\nreturn false;\r\nedid = psb_intel_sdvo_get_edid(connector);\r\nif (edid != NULL && edid->input & DRM_EDID_INPUT_DIGITAL)\r\nhas_audio = drm_detect_monitor_audio(edid);\r\nreturn has_audio;\r\n}\r\nstatic int\r\npsb_intel_sdvo_set_property(struct drm_connector *connector,\r\nstruct drm_property *property,\r\nuint64_t val)\r\n{\r\nstruct psb_intel_sdvo *psb_intel_sdvo = intel_attached_sdvo(connector);\r\nstruct psb_intel_sdvo_connector *psb_intel_sdvo_connector = to_psb_intel_sdvo_connector(connector);\r\nstruct drm_psb_private *dev_priv = connector->dev->dev_private;\r\nuint16_t temp_value;\r\nuint8_t cmd;\r\nint ret;\r\nret = drm_object_property_set_value(&connector->base, property, val);\r\nif (ret)\r\nreturn ret;\r\nif (property == dev_priv->force_audio_property) {\r\nint i = val;\r\nbool has_audio;\r\nif (i == psb_intel_sdvo_connector->force_audio)\r\nreturn 0;\r\npsb_intel_sdvo_connector->force_audio = i;\r\nif (i == 0)\r\nhas_audio = psb_intel_sdvo_detect_hdmi_audio(connector);\r\nelse\r\nhas_audio = i > 0;\r\nif (has_audio == psb_intel_sdvo->has_hdmi_audio)\r\nreturn 0;\r\npsb_intel_sdvo->has_hdmi_audio = has_audio;\r\ngoto done;\r\n}\r\nif (property == dev_priv->broadcast_rgb_property) {\r\nif (val == !!psb_intel_sdvo->color_range)\r\nreturn 0;\r\npsb_intel_sdvo->color_range = val ? SDVO_COLOR_RANGE_16_235 : 0;\r\ngoto done;\r\n}\r\n#define CHECK_PROPERTY(name, NAME) \\r\nif (psb_intel_sdvo_connector->name == property) { \\r\nif (psb_intel_sdvo_connector->cur_##name == temp_value) return 0; \\r\nif (psb_intel_sdvo_connector->max_##name < temp_value) return -EINVAL; \\r\ncmd = SDVO_CMD_SET_##NAME; \\r\npsb_intel_sdvo_connector->cur_##name = temp_value; \\r\ngoto set_value; \\r\n}\r\nif (property == psb_intel_sdvo_connector->tv_format) {\r\nif (val >= TV_FORMAT_NUM)\r\nreturn -EINVAL;\r\nif (psb_intel_sdvo->tv_format_index ==\r\npsb_intel_sdvo_connector->tv_format_supported[val])\r\nreturn 0;\r\npsb_intel_sdvo->tv_format_index = psb_intel_sdvo_connector->tv_format_supported[val];\r\ngoto done;\r\n} else if (IS_TV_OR_LVDS(psb_intel_sdvo_connector)) {\r\ntemp_value = val;\r\nif (psb_intel_sdvo_connector->left == property) {\r\ndrm_object_property_set_value(&connector->base,\r\npsb_intel_sdvo_connector->right, val);\r\nif (psb_intel_sdvo_connector->left_margin == temp_value)\r\nreturn 0;\r\npsb_intel_sdvo_connector->left_margin = temp_value;\r\npsb_intel_sdvo_connector->right_margin = temp_value;\r\ntemp_value = psb_intel_sdvo_connector->max_hscan -\r\npsb_intel_sdvo_connector->left_margin;\r\ncmd = SDVO_CMD_SET_OVERSCAN_H;\r\ngoto set_value;\r\n} else if (psb_intel_sdvo_connector->right == property) {\r\ndrm_object_property_set_value(&connector->base,\r\npsb_intel_sdvo_connector->left, val);\r\nif (psb_intel_sdvo_connector->right_margin == temp_value)\r\nreturn 0;\r\npsb_intel_sdvo_connector->left_margin = temp_value;\r\npsb_intel_sdvo_connector->right_margin = temp_value;\r\ntemp_value = psb_intel_sdvo_connector->max_hscan -\r\npsb_intel_sdvo_connector->left_margin;\r\ncmd = SDVO_CMD_SET_OVERSCAN_H;\r\ngoto set_value;\r\n} else if (psb_intel_sdvo_connector->top == property) {\r\ndrm_object_property_set_value(&connector->base,\r\npsb_intel_sdvo_connector->bottom, val);\r\nif (psb_intel_sdvo_connector->top_margin == temp_value)\r\nreturn 0;\r\npsb_intel_sdvo_connector->top_margin = temp_value;\r\npsb_intel_sdvo_connector->bottom_margin = temp_value;\r\ntemp_value = psb_intel_sdvo_connector->max_vscan -\r\npsb_intel_sdvo_connector->top_margin;\r\ncmd = SDVO_CMD_SET_OVERSCAN_V;\r\ngoto set_value;\r\n} else if (psb_intel_sdvo_connector->bottom == property) {\r\ndrm_object_property_set_value(&connector->base,\r\npsb_intel_sdvo_connector->top, val);\r\nif (psb_intel_sdvo_connector->bottom_margin == temp_value)\r\nreturn 0;\r\npsb_intel_sdvo_connector->top_margin = temp_value;\r\npsb_intel_sdvo_connector->bottom_margin = temp_value;\r\ntemp_value = psb_intel_sdvo_connector->max_vscan -\r\npsb_intel_sdvo_connector->top_margin;\r\ncmd = SDVO_CMD_SET_OVERSCAN_V;\r\ngoto set_value;\r\n}\r\nCHECK_PROPERTY(hpos, HPOS)\r\nCHECK_PROPERTY(vpos, VPOS)\r\nCHECK_PROPERTY(saturation, SATURATION)\r\nCHECK_PROPERTY(contrast, CONTRAST)\r\nCHECK_PROPERTY(hue, HUE)\r\nCHECK_PROPERTY(brightness, BRIGHTNESS)\r\nCHECK_PROPERTY(sharpness, SHARPNESS)\r\nCHECK_PROPERTY(flicker_filter, FLICKER_FILTER)\r\nCHECK_PROPERTY(flicker_filter_2d, FLICKER_FILTER_2D)\r\nCHECK_PROPERTY(flicker_filter_adaptive, FLICKER_FILTER_ADAPTIVE)\r\nCHECK_PROPERTY(tv_chroma_filter, TV_CHROMA_FILTER)\r\nCHECK_PROPERTY(tv_luma_filter, TV_LUMA_FILTER)\r\nCHECK_PROPERTY(dot_crawl, DOT_CRAWL)\r\n}\r\nreturn -EINVAL;\r\nset_value:\r\nif (!psb_intel_sdvo_set_value(psb_intel_sdvo, cmd, &temp_value, 2))\r\nreturn -EIO;\r\ndone:\r\nif (psb_intel_sdvo->base.base.crtc) {\r\nstruct drm_crtc *crtc = psb_intel_sdvo->base.base.crtc;\r\ndrm_crtc_helper_set_mode(crtc, &crtc->mode, crtc->x,\r\ncrtc->y, crtc->fb);\r\n}\r\nreturn 0;\r\n#undef CHECK_PROPERTY\r\n}\r\nstatic void psb_intel_sdvo_enc_destroy(struct drm_encoder *encoder)\r\n{\r\nstruct psb_intel_sdvo *psb_intel_sdvo = to_psb_intel_sdvo(encoder);\r\nif (psb_intel_sdvo->sdvo_lvds_fixed_mode != NULL)\r\ndrm_mode_destroy(encoder->dev,\r\npsb_intel_sdvo->sdvo_lvds_fixed_mode);\r\ni2c_del_adapter(&psb_intel_sdvo->ddc);\r\npsb_intel_encoder_destroy(encoder);\r\n}\r\nstatic void\r\npsb_intel_sdvo_guess_ddc_bus(struct psb_intel_sdvo *sdvo)\r\n{\r\nsdvo->ddc_bus = 2;\r\n#if 0\r\nuint16_t mask = 0;\r\nunsigned int num_bits;\r\nswitch (sdvo->controlled_output) {\r\ncase SDVO_OUTPUT_LVDS1:\r\nmask |= SDVO_OUTPUT_LVDS1;\r\ncase SDVO_OUTPUT_LVDS0:\r\nmask |= SDVO_OUTPUT_LVDS0;\r\ncase SDVO_OUTPUT_TMDS1:\r\nmask |= SDVO_OUTPUT_TMDS1;\r\ncase SDVO_OUTPUT_TMDS0:\r\nmask |= SDVO_OUTPUT_TMDS0;\r\ncase SDVO_OUTPUT_RGB1:\r\nmask |= SDVO_OUTPUT_RGB1;\r\ncase SDVO_OUTPUT_RGB0:\r\nmask |= SDVO_OUTPUT_RGB0;\r\nbreak;\r\n}\r\nmask &= sdvo->caps.output_flags;\r\nnum_bits = hweight16(mask);\r\nif (num_bits > 3)\r\nnum_bits = 3;\r\nsdvo->ddc_bus = 1 << num_bits;\r\n#endif\r\n}\r\nstatic void\r\npsb_intel_sdvo_select_ddc_bus(struct drm_psb_private *dev_priv,\r\nstruct psb_intel_sdvo *sdvo, u32 reg)\r\n{\r\nstruct sdvo_device_mapping *mapping;\r\nif (IS_SDVOB(reg))\r\nmapping = &(dev_priv->sdvo_mappings[0]);\r\nelse\r\nmapping = &(dev_priv->sdvo_mappings[1]);\r\nif (mapping->initialized)\r\nsdvo->ddc_bus = 1 << ((mapping->ddc_pin & 0xf0) >> 4);\r\nelse\r\npsb_intel_sdvo_guess_ddc_bus(sdvo);\r\n}\r\nstatic void\r\npsb_intel_sdvo_select_i2c_bus(struct drm_psb_private *dev_priv,\r\nstruct psb_intel_sdvo *sdvo, u32 reg)\r\n{\r\nstruct sdvo_device_mapping *mapping;\r\nu8 pin, speed;\r\nif (IS_SDVOB(reg))\r\nmapping = &dev_priv->sdvo_mappings[0];\r\nelse\r\nmapping = &dev_priv->sdvo_mappings[1];\r\npin = GMBUS_PORT_DPB;\r\nspeed = GMBUS_RATE_1MHZ >> 8;\r\nif (mapping->initialized) {\r\npin = mapping->i2c_pin;\r\nspeed = mapping->i2c_speed;\r\n}\r\nif (pin < GMBUS_NUM_PORTS) {\r\nsdvo->i2c = &dev_priv->gmbus[pin].adapter;\r\ngma_intel_gmbus_set_speed(sdvo->i2c, speed);\r\ngma_intel_gmbus_force_bit(sdvo->i2c, true);\r\n} else\r\nsdvo->i2c = &dev_priv->gmbus[GMBUS_PORT_DPB].adapter;\r\n}\r\nstatic bool\r\npsb_intel_sdvo_is_hdmi_connector(struct psb_intel_sdvo *psb_intel_sdvo, int device)\r\n{\r\nreturn psb_intel_sdvo_check_supp_encode(psb_intel_sdvo);\r\n}\r\nstatic u8\r\npsb_intel_sdvo_get_slave_addr(struct drm_device *dev, int sdvo_reg)\r\n{\r\nstruct drm_psb_private *dev_priv = dev->dev_private;\r\nstruct sdvo_device_mapping *my_mapping, *other_mapping;\r\nif (IS_SDVOB(sdvo_reg)) {\r\nmy_mapping = &dev_priv->sdvo_mappings[0];\r\nother_mapping = &dev_priv->sdvo_mappings[1];\r\n} else {\r\nmy_mapping = &dev_priv->sdvo_mappings[1];\r\nother_mapping = &dev_priv->sdvo_mappings[0];\r\n}\r\nif (my_mapping->slave_addr)\r\nreturn my_mapping->slave_addr;\r\nif (other_mapping->slave_addr) {\r\nif (other_mapping->slave_addr == 0x70)\r\nreturn 0x72;\r\nelse\r\nreturn 0x70;\r\n}\r\nif (IS_SDVOB(sdvo_reg))\r\nreturn 0x70;\r\nelse\r\nreturn 0x72;\r\n}\r\nstatic void\r\npsb_intel_sdvo_connector_init(struct psb_intel_sdvo_connector *connector,\r\nstruct psb_intel_sdvo *encoder)\r\n{\r\ndrm_connector_init(encoder->base.base.dev,\r\n&connector->base.base,\r\n&psb_intel_sdvo_connector_funcs,\r\nconnector->base.base.connector_type);\r\ndrm_connector_helper_add(&connector->base.base,\r\n&psb_intel_sdvo_connector_helper_funcs);\r\nconnector->base.base.interlace_allowed = 0;\r\nconnector->base.base.doublescan_allowed = 0;\r\nconnector->base.base.display_info.subpixel_order = SubPixelHorizontalRGB;\r\npsb_intel_connector_attach_encoder(&connector->base, &encoder->base);\r\ndrm_sysfs_connector_add(&connector->base.base);\r\n}\r\nstatic void\r\npsb_intel_sdvo_add_hdmi_properties(struct psb_intel_sdvo_connector *connector)\r\n{\r\n}\r\nstatic bool\r\npsb_intel_sdvo_dvi_init(struct psb_intel_sdvo *psb_intel_sdvo, int device)\r\n{\r\nstruct drm_encoder *encoder = &psb_intel_sdvo->base.base;\r\nstruct drm_connector *connector;\r\nstruct psb_intel_connector *intel_connector;\r\nstruct psb_intel_sdvo_connector *psb_intel_sdvo_connector;\r\npsb_intel_sdvo_connector = kzalloc(sizeof(struct psb_intel_sdvo_connector), GFP_KERNEL);\r\nif (!psb_intel_sdvo_connector)\r\nreturn false;\r\nif (device == 0) {\r\npsb_intel_sdvo->controlled_output |= SDVO_OUTPUT_TMDS0;\r\npsb_intel_sdvo_connector->output_flag = SDVO_OUTPUT_TMDS0;\r\n} else if (device == 1) {\r\npsb_intel_sdvo->controlled_output |= SDVO_OUTPUT_TMDS1;\r\npsb_intel_sdvo_connector->output_flag = SDVO_OUTPUT_TMDS1;\r\n}\r\nintel_connector = &psb_intel_sdvo_connector->base;\r\nconnector = &intel_connector->base;\r\nencoder->encoder_type = DRM_MODE_ENCODER_TMDS;\r\nconnector->connector_type = DRM_MODE_CONNECTOR_DVID;\r\nif (psb_intel_sdvo_is_hdmi_connector(psb_intel_sdvo, device)) {\r\nconnector->connector_type = DRM_MODE_CONNECTOR_HDMIA;\r\npsb_intel_sdvo->is_hdmi = true;\r\n}\r\npsb_intel_sdvo->base.clone_mask = ((1 << INTEL_SDVO_NON_TV_CLONE_BIT) |\r\n(1 << INTEL_ANALOG_CLONE_BIT));\r\npsb_intel_sdvo_connector_init(psb_intel_sdvo_connector, psb_intel_sdvo);\r\nif (psb_intel_sdvo->is_hdmi)\r\npsb_intel_sdvo_add_hdmi_properties(psb_intel_sdvo_connector);\r\nreturn true;\r\n}\r\nstatic bool\r\npsb_intel_sdvo_tv_init(struct psb_intel_sdvo *psb_intel_sdvo, int type)\r\n{\r\nstruct drm_encoder *encoder = &psb_intel_sdvo->base.base;\r\nstruct drm_connector *connector;\r\nstruct psb_intel_connector *intel_connector;\r\nstruct psb_intel_sdvo_connector *psb_intel_sdvo_connector;\r\npsb_intel_sdvo_connector = kzalloc(sizeof(struct psb_intel_sdvo_connector), GFP_KERNEL);\r\nif (!psb_intel_sdvo_connector)\r\nreturn false;\r\nintel_connector = &psb_intel_sdvo_connector->base;\r\nconnector = &intel_connector->base;\r\nencoder->encoder_type = DRM_MODE_ENCODER_TVDAC;\r\nconnector->connector_type = DRM_MODE_CONNECTOR_SVIDEO;\r\npsb_intel_sdvo->controlled_output |= type;\r\npsb_intel_sdvo_connector->output_flag = type;\r\npsb_intel_sdvo->is_tv = true;\r\npsb_intel_sdvo->base.needs_tv_clock = true;\r\npsb_intel_sdvo->base.clone_mask = 1 << INTEL_SDVO_TV_CLONE_BIT;\r\npsb_intel_sdvo_connector_init(psb_intel_sdvo_connector, psb_intel_sdvo);\r\nif (!psb_intel_sdvo_tv_create_property(psb_intel_sdvo, psb_intel_sdvo_connector, type))\r\ngoto err;\r\nif (!psb_intel_sdvo_create_enhance_property(psb_intel_sdvo, psb_intel_sdvo_connector))\r\ngoto err;\r\nreturn true;\r\nerr:\r\npsb_intel_sdvo_destroy(connector);\r\nreturn false;\r\n}\r\nstatic bool\r\npsb_intel_sdvo_analog_init(struct psb_intel_sdvo *psb_intel_sdvo, int device)\r\n{\r\nstruct drm_encoder *encoder = &psb_intel_sdvo->base.base;\r\nstruct drm_connector *connector;\r\nstruct psb_intel_connector *intel_connector;\r\nstruct psb_intel_sdvo_connector *psb_intel_sdvo_connector;\r\npsb_intel_sdvo_connector = kzalloc(sizeof(struct psb_intel_sdvo_connector), GFP_KERNEL);\r\nif (!psb_intel_sdvo_connector)\r\nreturn false;\r\nintel_connector = &psb_intel_sdvo_connector->base;\r\nconnector = &intel_connector->base;\r\nconnector->polled = DRM_CONNECTOR_POLL_CONNECT;\r\nencoder->encoder_type = DRM_MODE_ENCODER_DAC;\r\nconnector->connector_type = DRM_MODE_CONNECTOR_VGA;\r\nif (device == 0) {\r\npsb_intel_sdvo->controlled_output |= SDVO_OUTPUT_RGB0;\r\npsb_intel_sdvo_connector->output_flag = SDVO_OUTPUT_RGB0;\r\n} else if (device == 1) {\r\npsb_intel_sdvo->controlled_output |= SDVO_OUTPUT_RGB1;\r\npsb_intel_sdvo_connector->output_flag = SDVO_OUTPUT_RGB1;\r\n}\r\npsb_intel_sdvo->base.clone_mask = ((1 << INTEL_SDVO_NON_TV_CLONE_BIT) |\r\n(1 << INTEL_ANALOG_CLONE_BIT));\r\npsb_intel_sdvo_connector_init(psb_intel_sdvo_connector,\r\npsb_intel_sdvo);\r\nreturn true;\r\n}\r\nstatic bool\r\npsb_intel_sdvo_lvds_init(struct psb_intel_sdvo *psb_intel_sdvo, int device)\r\n{\r\nstruct drm_encoder *encoder = &psb_intel_sdvo->base.base;\r\nstruct drm_connector *connector;\r\nstruct psb_intel_connector *intel_connector;\r\nstruct psb_intel_sdvo_connector *psb_intel_sdvo_connector;\r\npsb_intel_sdvo_connector = kzalloc(sizeof(struct psb_intel_sdvo_connector), GFP_KERNEL);\r\nif (!psb_intel_sdvo_connector)\r\nreturn false;\r\nintel_connector = &psb_intel_sdvo_connector->base;\r\nconnector = &intel_connector->base;\r\nencoder->encoder_type = DRM_MODE_ENCODER_LVDS;\r\nconnector->connector_type = DRM_MODE_CONNECTOR_LVDS;\r\nif (device == 0) {\r\npsb_intel_sdvo->controlled_output |= SDVO_OUTPUT_LVDS0;\r\npsb_intel_sdvo_connector->output_flag = SDVO_OUTPUT_LVDS0;\r\n} else if (device == 1) {\r\npsb_intel_sdvo->controlled_output |= SDVO_OUTPUT_LVDS1;\r\npsb_intel_sdvo_connector->output_flag = SDVO_OUTPUT_LVDS1;\r\n}\r\npsb_intel_sdvo->base.clone_mask = ((1 << INTEL_ANALOG_CLONE_BIT) |\r\n(1 << INTEL_SDVO_LVDS_CLONE_BIT));\r\npsb_intel_sdvo_connector_init(psb_intel_sdvo_connector, psb_intel_sdvo);\r\nif (!psb_intel_sdvo_create_enhance_property(psb_intel_sdvo, psb_intel_sdvo_connector))\r\ngoto err;\r\nreturn true;\r\nerr:\r\npsb_intel_sdvo_destroy(connector);\r\nreturn false;\r\n}\r\nstatic bool\r\npsb_intel_sdvo_output_setup(struct psb_intel_sdvo *psb_intel_sdvo, uint16_t flags)\r\n{\r\npsb_intel_sdvo->is_tv = false;\r\npsb_intel_sdvo->base.needs_tv_clock = false;\r\npsb_intel_sdvo->is_lvds = false;\r\nif (flags & SDVO_OUTPUT_TMDS0)\r\nif (!psb_intel_sdvo_dvi_init(psb_intel_sdvo, 0))\r\nreturn false;\r\nif ((flags & SDVO_TMDS_MASK) == SDVO_TMDS_MASK)\r\nif (!psb_intel_sdvo_dvi_init(psb_intel_sdvo, 1))\r\nreturn false;\r\nif (flags & SDVO_OUTPUT_SVID0)\r\nif (!psb_intel_sdvo_tv_init(psb_intel_sdvo, SDVO_OUTPUT_SVID0))\r\nreturn false;\r\nif (flags & SDVO_OUTPUT_CVBS0)\r\nif (!psb_intel_sdvo_tv_init(psb_intel_sdvo, SDVO_OUTPUT_CVBS0))\r\nreturn false;\r\nif (flags & SDVO_OUTPUT_RGB0)\r\nif (!psb_intel_sdvo_analog_init(psb_intel_sdvo, 0))\r\nreturn false;\r\nif ((flags & SDVO_RGB_MASK) == SDVO_RGB_MASK)\r\nif (!psb_intel_sdvo_analog_init(psb_intel_sdvo, 1))\r\nreturn false;\r\nif (flags & SDVO_OUTPUT_LVDS0)\r\nif (!psb_intel_sdvo_lvds_init(psb_intel_sdvo, 0))\r\nreturn false;\r\nif ((flags & SDVO_LVDS_MASK) == SDVO_LVDS_MASK)\r\nif (!psb_intel_sdvo_lvds_init(psb_intel_sdvo, 1))\r\nreturn false;\r\nif ((flags & SDVO_OUTPUT_MASK) == 0) {\r\nunsigned char bytes[2];\r\npsb_intel_sdvo->controlled_output = 0;\r\nmemcpy(bytes, &psb_intel_sdvo->caps.output_flags, 2);\r\nDRM_DEBUG_KMS("%s: Unknown SDVO output type (0x%02x%02x)\n",\r\nSDVO_NAME(psb_intel_sdvo),\r\nbytes[0], bytes[1]);\r\nreturn false;\r\n}\r\npsb_intel_sdvo->base.crtc_mask = (1 << 0) | (1 << 1);\r\nreturn true;\r\n}\r\nstatic bool psb_intel_sdvo_tv_create_property(struct psb_intel_sdvo *psb_intel_sdvo,\r\nstruct psb_intel_sdvo_connector *psb_intel_sdvo_connector,\r\nint type)\r\n{\r\nstruct drm_device *dev = psb_intel_sdvo->base.base.dev;\r\nstruct psb_intel_sdvo_tv_format format;\r\nuint32_t format_map, i;\r\nif (!psb_intel_sdvo_set_target_output(psb_intel_sdvo, type))\r\nreturn false;\r\nBUILD_BUG_ON(sizeof(format) != 6);\r\nif (!psb_intel_sdvo_get_value(psb_intel_sdvo,\r\nSDVO_CMD_GET_SUPPORTED_TV_FORMATS,\r\n&format, sizeof(format)))\r\nreturn false;\r\nmemcpy(&format_map, &format, min(sizeof(format_map), sizeof(format)));\r\nif (format_map == 0)\r\nreturn false;\r\npsb_intel_sdvo_connector->format_supported_num = 0;\r\nfor (i = 0 ; i < TV_FORMAT_NUM; i++)\r\nif (format_map & (1 << i))\r\npsb_intel_sdvo_connector->tv_format_supported[psb_intel_sdvo_connector->format_supported_num++] = i;\r\npsb_intel_sdvo_connector->tv_format =\r\ndrm_property_create(dev, DRM_MODE_PROP_ENUM,\r\n"mode", psb_intel_sdvo_connector->format_supported_num);\r\nif (!psb_intel_sdvo_connector->tv_format)\r\nreturn false;\r\nfor (i = 0; i < psb_intel_sdvo_connector->format_supported_num; i++)\r\ndrm_property_add_enum(\r\npsb_intel_sdvo_connector->tv_format, i,\r\ni, tv_format_names[psb_intel_sdvo_connector->tv_format_supported[i]]);\r\npsb_intel_sdvo->tv_format_index = psb_intel_sdvo_connector->tv_format_supported[0];\r\ndrm_object_attach_property(&psb_intel_sdvo_connector->base.base.base,\r\npsb_intel_sdvo_connector->tv_format, 0);\r\nreturn true;\r\n}\r\nstatic bool\r\npsb_intel_sdvo_create_enhance_property_tv(struct psb_intel_sdvo *psb_intel_sdvo,\r\nstruct psb_intel_sdvo_connector *psb_intel_sdvo_connector,\r\nstruct psb_intel_sdvo_enhancements_reply enhancements)\r\n{\r\nstruct drm_device *dev = psb_intel_sdvo->base.base.dev;\r\nstruct drm_connector *connector = &psb_intel_sdvo_connector->base.base;\r\nuint16_t response, data_value[2];\r\nif (enhancements.overscan_h) {\r\nif (!psb_intel_sdvo_get_value(psb_intel_sdvo,\r\nSDVO_CMD_GET_MAX_OVERSCAN_H,\r\n&data_value, 4))\r\nreturn false;\r\nif (!psb_intel_sdvo_get_value(psb_intel_sdvo,\r\nSDVO_CMD_GET_OVERSCAN_H,\r\n&response, 2))\r\nreturn false;\r\npsb_intel_sdvo_connector->max_hscan = data_value[0];\r\npsb_intel_sdvo_connector->left_margin = data_value[0] - response;\r\npsb_intel_sdvo_connector->right_margin = psb_intel_sdvo_connector->left_margin;\r\npsb_intel_sdvo_connector->left =\r\ndrm_property_create_range(dev, 0, "left_margin", 0, data_value[0]);\r\nif (!psb_intel_sdvo_connector->left)\r\nreturn false;\r\ndrm_object_attach_property(&connector->base,\r\npsb_intel_sdvo_connector->left,\r\npsb_intel_sdvo_connector->left_margin);\r\npsb_intel_sdvo_connector->right =\r\ndrm_property_create_range(dev, 0, "right_margin", 0, data_value[0]);\r\nif (!psb_intel_sdvo_connector->right)\r\nreturn false;\r\ndrm_object_attach_property(&connector->base,\r\npsb_intel_sdvo_connector->right,\r\npsb_intel_sdvo_connector->right_margin);\r\nDRM_DEBUG_KMS("h_overscan: max %d, "\r\n"default %d, current %d\n",\r\ndata_value[0], data_value[1], response);\r\n}\r\nif (enhancements.overscan_v) {\r\nif (!psb_intel_sdvo_get_value(psb_intel_sdvo,\r\nSDVO_CMD_GET_MAX_OVERSCAN_V,\r\n&data_value, 4))\r\nreturn false;\r\nif (!psb_intel_sdvo_get_value(psb_intel_sdvo,\r\nSDVO_CMD_GET_OVERSCAN_V,\r\n&response, 2))\r\nreturn false;\r\npsb_intel_sdvo_connector->max_vscan = data_value[0];\r\npsb_intel_sdvo_connector->top_margin = data_value[0] - response;\r\npsb_intel_sdvo_connector->bottom_margin = psb_intel_sdvo_connector->top_margin;\r\npsb_intel_sdvo_connector->top =\r\ndrm_property_create_range(dev, 0, "top_margin", 0, data_value[0]);\r\nif (!psb_intel_sdvo_connector->top)\r\nreturn false;\r\ndrm_object_attach_property(&connector->base,\r\npsb_intel_sdvo_connector->top,\r\npsb_intel_sdvo_connector->top_margin);\r\npsb_intel_sdvo_connector->bottom =\r\ndrm_property_create_range(dev, 0, "bottom_margin", 0, data_value[0]);\r\nif (!psb_intel_sdvo_connector->bottom)\r\nreturn false;\r\ndrm_object_attach_property(&connector->base,\r\npsb_intel_sdvo_connector->bottom,\r\npsb_intel_sdvo_connector->bottom_margin);\r\nDRM_DEBUG_KMS("v_overscan: max %d, "\r\n"default %d, current %d\n",\r\ndata_value[0], data_value[1], response);\r\n}\r\nENHANCEMENT(hpos, HPOS);\r\nENHANCEMENT(vpos, VPOS);\r\nENHANCEMENT(saturation, SATURATION);\r\nENHANCEMENT(contrast, CONTRAST);\r\nENHANCEMENT(hue, HUE);\r\nENHANCEMENT(sharpness, SHARPNESS);\r\nENHANCEMENT(brightness, BRIGHTNESS);\r\nENHANCEMENT(flicker_filter, FLICKER_FILTER);\r\nENHANCEMENT(flicker_filter_adaptive, FLICKER_FILTER_ADAPTIVE);\r\nENHANCEMENT(flicker_filter_2d, FLICKER_FILTER_2D);\r\nENHANCEMENT(tv_chroma_filter, TV_CHROMA_FILTER);\r\nENHANCEMENT(tv_luma_filter, TV_LUMA_FILTER);\r\nif (enhancements.dot_crawl) {\r\nif (!psb_intel_sdvo_get_value(psb_intel_sdvo, SDVO_CMD_GET_DOT_CRAWL, &response, 2))\r\nreturn false;\r\npsb_intel_sdvo_connector->max_dot_crawl = 1;\r\npsb_intel_sdvo_connector->cur_dot_crawl = response & 0x1;\r\npsb_intel_sdvo_connector->dot_crawl =\r\ndrm_property_create_range(dev, 0, "dot_crawl", 0, 1);\r\nif (!psb_intel_sdvo_connector->dot_crawl)\r\nreturn false;\r\ndrm_object_attach_property(&connector->base,\r\npsb_intel_sdvo_connector->dot_crawl,\r\npsb_intel_sdvo_connector->cur_dot_crawl);\r\nDRM_DEBUG_KMS("dot crawl: current %d\n", response);\r\n}\r\nreturn true;\r\n}\r\nstatic bool\r\npsb_intel_sdvo_create_enhance_property_lvds(struct psb_intel_sdvo *psb_intel_sdvo,\r\nstruct psb_intel_sdvo_connector *psb_intel_sdvo_connector,\r\nstruct psb_intel_sdvo_enhancements_reply enhancements)\r\n{\r\nstruct drm_device *dev = psb_intel_sdvo->base.base.dev;\r\nstruct drm_connector *connector = &psb_intel_sdvo_connector->base.base;\r\nuint16_t response, data_value[2];\r\nENHANCEMENT(brightness, BRIGHTNESS);\r\nreturn true;\r\n}\r\nstatic bool psb_intel_sdvo_create_enhance_property(struct psb_intel_sdvo *psb_intel_sdvo,\r\nstruct psb_intel_sdvo_connector *psb_intel_sdvo_connector)\r\n{\r\nunion {\r\nstruct psb_intel_sdvo_enhancements_reply reply;\r\nuint16_t response;\r\n} enhancements;\r\nBUILD_BUG_ON(sizeof(enhancements) != 2);\r\nenhancements.response = 0;\r\npsb_intel_sdvo_get_value(psb_intel_sdvo,\r\nSDVO_CMD_GET_SUPPORTED_ENHANCEMENTS,\r\n&enhancements, sizeof(enhancements));\r\nif (enhancements.response == 0) {\r\nDRM_DEBUG_KMS("No enhancement is supported\n");\r\nreturn true;\r\n}\r\nif (IS_TV(psb_intel_sdvo_connector))\r\nreturn psb_intel_sdvo_create_enhance_property_tv(psb_intel_sdvo, psb_intel_sdvo_connector, enhancements.reply);\r\nelse if(IS_LVDS(psb_intel_sdvo_connector))\r\nreturn psb_intel_sdvo_create_enhance_property_lvds(psb_intel_sdvo, psb_intel_sdvo_connector, enhancements.reply);\r\nelse\r\nreturn true;\r\n}\r\nstatic int psb_intel_sdvo_ddc_proxy_xfer(struct i2c_adapter *adapter,\r\nstruct i2c_msg *msgs,\r\nint num)\r\n{\r\nstruct psb_intel_sdvo *sdvo = adapter->algo_data;\r\nif (!psb_intel_sdvo_set_control_bus_switch(sdvo, sdvo->ddc_bus))\r\nreturn -EIO;\r\nreturn sdvo->i2c->algo->master_xfer(sdvo->i2c, msgs, num);\r\n}\r\nstatic u32 psb_intel_sdvo_ddc_proxy_func(struct i2c_adapter *adapter)\r\n{\r\nstruct psb_intel_sdvo *sdvo = adapter->algo_data;\r\nreturn sdvo->i2c->algo->functionality(sdvo->i2c);\r\n}\r\nstatic bool\r\npsb_intel_sdvo_init_ddc_proxy(struct psb_intel_sdvo *sdvo,\r\nstruct drm_device *dev)\r\n{\r\nsdvo->ddc.owner = THIS_MODULE;\r\nsdvo->ddc.class = I2C_CLASS_DDC;\r\nsnprintf(sdvo->ddc.name, I2C_NAME_SIZE, "SDVO DDC proxy");\r\nsdvo->ddc.dev.parent = &dev->pdev->dev;\r\nsdvo->ddc.algo_data = sdvo;\r\nsdvo->ddc.algo = &psb_intel_sdvo_ddc_proxy;\r\nreturn i2c_add_adapter(&sdvo->ddc) == 0;\r\n}\r\nbool psb_intel_sdvo_init(struct drm_device *dev, int sdvo_reg)\r\n{\r\nstruct drm_psb_private *dev_priv = dev->dev_private;\r\nstruct psb_intel_encoder *psb_intel_encoder;\r\nstruct psb_intel_sdvo *psb_intel_sdvo;\r\nint i;\r\npsb_intel_sdvo = kzalloc(sizeof(struct psb_intel_sdvo), GFP_KERNEL);\r\nif (!psb_intel_sdvo)\r\nreturn false;\r\npsb_intel_sdvo->sdvo_reg = sdvo_reg;\r\npsb_intel_sdvo->slave_addr = psb_intel_sdvo_get_slave_addr(dev, sdvo_reg) >> 1;\r\npsb_intel_sdvo_select_i2c_bus(dev_priv, psb_intel_sdvo, sdvo_reg);\r\nif (!psb_intel_sdvo_init_ddc_proxy(psb_intel_sdvo, dev)) {\r\nkfree(psb_intel_sdvo);\r\nreturn false;\r\n}\r\npsb_intel_encoder = &psb_intel_sdvo->base;\r\npsb_intel_encoder->type = INTEL_OUTPUT_SDVO;\r\ndrm_encoder_init(dev, &psb_intel_encoder->base, &psb_intel_sdvo_enc_funcs, 0);\r\nfor (i = 0; i < 0x40; i++) {\r\nu8 byte;\r\nif (!psb_intel_sdvo_read_byte(psb_intel_sdvo, i, &byte)) {\r\nDRM_DEBUG_KMS("No SDVO device found on SDVO%c\n",\r\nIS_SDVOB(sdvo_reg) ? 'B' : 'C');\r\ngoto err;\r\n}\r\n}\r\nif (IS_SDVOB(sdvo_reg))\r\ndev_priv->hotplug_supported_mask |= SDVOB_HOTPLUG_INT_STATUS;\r\nelse\r\ndev_priv->hotplug_supported_mask |= SDVOC_HOTPLUG_INT_STATUS;\r\ndrm_encoder_helper_add(&psb_intel_encoder->base, &psb_intel_sdvo_helper_funcs);\r\nif (!psb_intel_sdvo_get_capabilities(psb_intel_sdvo, &psb_intel_sdvo->caps))\r\ngoto err;\r\nif (psb_intel_sdvo_output_setup(psb_intel_sdvo,\r\npsb_intel_sdvo->caps.output_flags) != true) {\r\nDRM_DEBUG_KMS("SDVO output failed to setup on SDVO%c\n",\r\nIS_SDVOB(sdvo_reg) ? 'B' : 'C');\r\ngoto err;\r\n}\r\npsb_intel_sdvo_select_ddc_bus(dev_priv, psb_intel_sdvo, sdvo_reg);\r\nif (!psb_intel_sdvo_set_target_input(psb_intel_sdvo))\r\ngoto err;\r\nif (!psb_intel_sdvo_get_input_pixel_clock_range(psb_intel_sdvo,\r\n&psb_intel_sdvo->pixel_clock_min,\r\n&psb_intel_sdvo->pixel_clock_max))\r\ngoto err;\r\nDRM_DEBUG_KMS("%s device VID/DID: %02X:%02X.%02X, "\r\n"clock range %dMHz - %dMHz, "\r\n"input 1: %c, input 2: %c, "\r\n"output 1: %c, output 2: %c\n",\r\nSDVO_NAME(psb_intel_sdvo),\r\npsb_intel_sdvo->caps.vendor_id, psb_intel_sdvo->caps.device_id,\r\npsb_intel_sdvo->caps.device_rev_id,\r\npsb_intel_sdvo->pixel_clock_min / 1000,\r\npsb_intel_sdvo->pixel_clock_max / 1000,\r\n(psb_intel_sdvo->caps.sdvo_inputs_mask & 0x1) ? 'Y' : 'N',\r\n(psb_intel_sdvo->caps.sdvo_inputs_mask & 0x2) ? 'Y' : 'N',\r\npsb_intel_sdvo->caps.output_flags &\r\n(SDVO_OUTPUT_TMDS0 | SDVO_OUTPUT_RGB0) ? 'Y' : 'N',\r\npsb_intel_sdvo->caps.output_flags &\r\n(SDVO_OUTPUT_TMDS1 | SDVO_OUTPUT_RGB1) ? 'Y' : 'N');\r\nreturn true;\r\nerr:\r\ndrm_encoder_cleanup(&psb_intel_encoder->base);\r\ni2c_del_adapter(&psb_intel_sdvo->ddc);\r\nkfree(psb_intel_sdvo);\r\nreturn false;\r\n}
