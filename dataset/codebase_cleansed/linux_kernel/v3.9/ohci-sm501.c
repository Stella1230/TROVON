static int ohci_sm501_init(struct usb_hcd *hcd)\r\n{\r\nreturn ohci_init(hcd_to_ohci(hcd));\r\n}\r\nstatic int ohci_sm501_start(struct usb_hcd *hcd)\r\n{\r\nstruct device *dev = hcd->self.controller;\r\nint ret;\r\nret = ohci_run(hcd_to_ohci(hcd));\r\nif (ret < 0) {\r\ndev_err(dev, "can't start %s", hcd->self.bus_name);\r\nohci_stop(hcd);\r\n}\r\nreturn ret;\r\n}\r\nstatic int ohci_hcd_sm501_drv_probe(struct platform_device *pdev)\r\n{\r\nconst struct hc_driver *driver = &ohci_sm501_hc_driver;\r\nstruct device *dev = &pdev->dev;\r\nstruct resource *res, *mem;\r\nint retval, irq;\r\nstruct usb_hcd *hcd = NULL;\r\nirq = retval = platform_get_irq(pdev, 0);\r\nif (retval < 0)\r\ngoto err0;\r\nmem = platform_get_resource(pdev, IORESOURCE_MEM, 1);\r\nif (mem == NULL) {\r\ndev_err(dev, "no resource definition for memory\n");\r\nretval = -ENOENT;\r\ngoto err0;\r\n}\r\nif (!request_mem_region(mem->start, resource_size(mem), pdev->name)) {\r\ndev_err(dev, "request_mem_region failed\n");\r\nretval = -EBUSY;\r\ngoto err0;\r\n}\r\nif (!dma_declare_coherent_memory(dev, mem->start,\r\nmem->start - mem->parent->start,\r\nresource_size(mem),\r\nDMA_MEMORY_MAP |\r\nDMA_MEMORY_EXCLUSIVE)) {\r\ndev_err(dev, "cannot declare coherent memory\n");\r\nretval = -ENXIO;\r\ngoto err1;\r\n}\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (res == NULL) {\r\ndev_err(dev, "no resource definition for registers\n");\r\nretval = -ENOENT;\r\ngoto err2;\r\n}\r\nhcd = usb_create_hcd(driver, &pdev->dev, dev_name(&pdev->dev));\r\nif (!hcd) {\r\nretval = -ENOMEM;\r\ngoto err2;\r\n}\r\nhcd->rsrc_start = res->start;\r\nhcd->rsrc_len = resource_size(res);\r\nif (!request_mem_region(hcd->rsrc_start, hcd->rsrc_len, pdev->name)) {\r\ndev_err(dev, "request_mem_region failed\n");\r\nretval = -EBUSY;\r\ngoto err3;\r\n}\r\nhcd->regs = ioremap(hcd->rsrc_start, hcd->rsrc_len);\r\nif (hcd->regs == NULL) {\r\ndev_err(dev, "cannot remap registers\n");\r\nretval = -ENXIO;\r\ngoto err4;\r\n}\r\nohci_hcd_init(hcd_to_ohci(hcd));\r\nretval = usb_add_hcd(hcd, irq, IRQF_SHARED);\r\nif (retval)\r\ngoto err5;\r\nsm501_unit_power(dev->parent, SM501_GATE_USB_HOST, 1);\r\nsm501_modify_reg(dev->parent, SM501_IRQ_MASK, 1 << 6, 0);\r\nreturn 0;\r\nerr5:\r\niounmap(hcd->regs);\r\nerr4:\r\nrelease_mem_region(hcd->rsrc_start, hcd->rsrc_len);\r\nerr3:\r\nusb_put_hcd(hcd);\r\nerr2:\r\ndma_release_declared_memory(dev);\r\nerr1:\r\nrelease_mem_region(mem->start, resource_size(mem));\r\nerr0:\r\nreturn retval;\r\n}\r\nstatic int ohci_hcd_sm501_drv_remove(struct platform_device *pdev)\r\n{\r\nstruct usb_hcd *hcd = platform_get_drvdata(pdev);\r\nstruct resource *mem;\r\nusb_remove_hcd(hcd);\r\nrelease_mem_region(hcd->rsrc_start, hcd->rsrc_len);\r\nusb_put_hcd(hcd);\r\ndma_release_declared_memory(&pdev->dev);\r\nmem = platform_get_resource(pdev, IORESOURCE_MEM, 1);\r\nif (mem)\r\nrelease_mem_region(mem->start, resource_size(mem));\r\nsm501_modify_reg(pdev->dev.parent, SM501_IRQ_MASK, 0, 1 << 6);\r\nsm501_unit_power(pdev->dev.parent, SM501_GATE_USB_HOST, 0);\r\nplatform_set_drvdata(pdev, NULL);\r\nreturn 0;\r\n}\r\nstatic int ohci_sm501_suspend(struct platform_device *pdev, pm_message_t msg)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct ohci_hcd *ohci = hcd_to_ohci(platform_get_drvdata(pdev));\r\nif (time_before(jiffies, ohci->next_statechange))\r\nmsleep(5);\r\nohci->next_statechange = jiffies;\r\nsm501_unit_power(dev->parent, SM501_GATE_USB_HOST, 0);\r\nreturn 0;\r\n}\r\nstatic int ohci_sm501_resume(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct usb_hcd *hcd = platform_get_drvdata(pdev);\r\nstruct ohci_hcd *ohci = hcd_to_ohci(hcd);\r\nif (time_before(jiffies, ohci->next_statechange))\r\nmsleep(5);\r\nohci->next_statechange = jiffies;\r\nsm501_unit_power(dev->parent, SM501_GATE_USB_HOST, 1);\r\nohci_resume(hcd, false);\r\nreturn 0;\r\n}
