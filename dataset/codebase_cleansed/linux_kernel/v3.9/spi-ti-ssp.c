static u32 ti_ssp_spi_rx(struct ti_ssp_spi *hw)\r\n{\r\nu32 ret;\r\nti_ssp_run(hw->dev, hw->pc_rd, 0, &ret);\r\nreturn ret;\r\n}\r\nstatic void ti_ssp_spi_tx(struct ti_ssp_spi *hw, u32 data)\r\n{\r\nti_ssp_run(hw->dev, hw->pc_wr, data << (32 - hw->bpw), NULL);\r\n}\r\nstatic int ti_ssp_spi_txrx(struct ti_ssp_spi *hw, struct spi_message *msg,\r\nstruct spi_transfer *t)\r\n{\r\nint count;\r\nif (hw->bpw <= 8) {\r\nu8 *rx = t->rx_buf;\r\nconst u8 *tx = t->tx_buf;\r\nfor (count = 0; count < t->len; count += 1) {\r\nif (t->tx_buf)\r\nti_ssp_spi_tx(hw, *tx++);\r\nif (t->rx_buf)\r\n*rx++ = ti_ssp_spi_rx(hw);\r\n}\r\n} else if (hw->bpw <= 16) {\r\nu16 *rx = t->rx_buf;\r\nconst u16 *tx = t->tx_buf;\r\nfor (count = 0; count < t->len; count += 2) {\r\nif (t->tx_buf)\r\nti_ssp_spi_tx(hw, *tx++);\r\nif (t->rx_buf)\r\n*rx++ = ti_ssp_spi_rx(hw);\r\n}\r\n} else {\r\nu32 *rx = t->rx_buf;\r\nconst u32 *tx = t->tx_buf;\r\nfor (count = 0; count < t->len; count += 4) {\r\nif (t->tx_buf)\r\nti_ssp_spi_tx(hw, *tx++);\r\nif (t->rx_buf)\r\n*rx++ = ti_ssp_spi_rx(hw);\r\n}\r\n}\r\nmsg->actual_length += count;\r\ndev_dbg(&msg->spi->dev, "xfer %s%s, %d bytes, %d bpw, count %d%s\n",\r\nt->tx_buf ? "tx" : "", t->rx_buf ? "rx" : "", t->len,\r\nhw->bpw, count, (count < t->len) ? " (under)" : "");\r\nreturn (count < t->len) ? -EIO : 0;\r\n}\r\nstatic void ti_ssp_spi_chip_select(struct ti_ssp_spi *hw, int cs_active)\r\n{\r\ncs_active = !!cs_active;\r\nif (cs_active == hw->cs_active)\r\nreturn;\r\nti_ssp_run(hw->dev, cs_active ? hw->pc_en : hw->pc_dis, 0, NULL);\r\nhw->cs_active = cs_active;\r\n}\r\nstatic int ti_ssp_spi_setup_transfer(struct ti_ssp_spi *hw, u8 bpw, u8 mode)\r\n{\r\nint error, idx = 0;\r\nu32 seqram[16];\r\nu32 cs_en, cs_dis, clk;\r\nu32 topbits, botbits;\r\nmode &= MODE_BITS;\r\nif (mode == hw->mode && bpw == hw->bpw)\r\nreturn 0;\r\ncs_en = (mode & SPI_CS_HIGH) ? SSP_CS_HIGH : SSP_CS_LOW;\r\ncs_dis = (mode & SPI_CS_HIGH) ? SSP_CS_LOW : SSP_CS_HIGH;\r\nclk = (mode & SPI_CPOL) ? SSP_CLK_HIGH : SSP_CLK_LOW;\r\nhw->pc_dis = idx;\r\nseqram[idx++] = SSP_OPCODE_DIRECT | SSP_OUT_MODE | cs_dis | clk;\r\nseqram[idx++] = SSP_OPCODE_STOP | SSP_OUT_MODE | cs_dis | clk;\r\nhw->pc_en = idx;\r\nseqram[idx++] = SSP_OPCODE_DIRECT | SSP_OUT_MODE | cs_en | clk;\r\nseqram[idx++] = SSP_OPCODE_STOP | SSP_OUT_MODE | cs_en | clk;\r\ntopbits = (bpw > 16) ? 16 : bpw;\r\nbotbits = bpw - topbits;\r\nhw->pc_wr = idx;\r\nseqram[idx++] = __SHIFT_OUT(topbits) | SSP_ADDR_REG;\r\nif (botbits)\r\nseqram[idx++] = __SHIFT_OUT(botbits) | SSP_DATA_REG;\r\nseqram[idx++] = SSP_OPCODE_STOP | SSP_OUT_MODE | cs_en | clk;\r\nhw->pc_rd = idx;\r\nif (botbits)\r\nseqram[idx++] = __SHIFT_IN(botbits) | SSP_ADDR_REG;\r\nseqram[idx++] = __SHIFT_IN(topbits) | SSP_DATA_REG;\r\nseqram[idx++] = SSP_OPCODE_STOP | SSP_OUT_MODE | cs_en | clk;\r\nerror = ti_ssp_load(hw->dev, 0, seqram, idx);\r\nif (error < 0)\r\nreturn error;\r\nerror = ti_ssp_set_mode(hw->dev, ((mode & SPI_CPHA) ?\r\n0 : SSP_EARLY_DIN));\r\nif (error < 0)\r\nreturn error;\r\nhw->bpw = bpw;\r\nhw->mode = mode;\r\nreturn error;\r\n}\r\nstatic void ti_ssp_spi_work(struct work_struct *work)\r\n{\r\nstruct ti_ssp_spi *hw = container_of(work, struct ti_ssp_spi, work);\r\nspin_lock(&hw->lock);\r\nwhile (!list_empty(&hw->msg_queue)) {\r\nstruct spi_message *m;\r\nstruct spi_device *spi;\r\nstruct spi_transfer *t = NULL;\r\nint status = 0;\r\nm = container_of(hw->msg_queue.next, struct spi_message,\r\nqueue);\r\nlist_del_init(&m->queue);\r\nspin_unlock(&hw->lock);\r\nspi = m->spi;\r\nif (hw->select)\r\nhw->select(spi->chip_select);\r\nlist_for_each_entry(t, &m->transfers, transfer_list) {\r\nint bpw = spi->bits_per_word;\r\nint xfer_status;\r\nif (t->bits_per_word)\r\nbpw = t->bits_per_word;\r\nif (ti_ssp_spi_setup_transfer(hw, bpw, spi->mode) < 0)\r\nbreak;\r\nti_ssp_spi_chip_select(hw, 1);\r\nxfer_status = ti_ssp_spi_txrx(hw, m, t);\r\nif (xfer_status < 0)\r\nstatus = xfer_status;\r\nif (t->delay_usecs)\r\nudelay(t->delay_usecs);\r\nif (t->cs_change)\r\nti_ssp_spi_chip_select(hw, 0);\r\n}\r\nti_ssp_spi_chip_select(hw, 0);\r\nm->status = status;\r\nm->complete(m->context);\r\nspin_lock(&hw->lock);\r\n}\r\nif (hw->shutdown)\r\ncomplete(&hw->complete);\r\nspin_unlock(&hw->lock);\r\n}\r\nstatic int ti_ssp_spi_setup(struct spi_device *spi)\r\n{\r\nif (spi->bits_per_word > 32)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int ti_ssp_spi_transfer(struct spi_device *spi, struct spi_message *m)\r\n{\r\nstruct ti_ssp_spi *hw;\r\nstruct spi_transfer *t;\r\nint error = 0;\r\nm->actual_length = 0;\r\nm->status = -EINPROGRESS;\r\nhw = spi_master_get_devdata(spi->master);\r\nif (list_empty(&m->transfers) || !m->complete)\r\nreturn -EINVAL;\r\nlist_for_each_entry(t, &m->transfers, transfer_list) {\r\nif (t->len && !(t->rx_buf || t->tx_buf)) {\r\ndev_err(&spi->dev, "invalid xfer, no buffer\n");\r\nreturn -EINVAL;\r\n}\r\nif (t->len && t->rx_buf && t->tx_buf) {\r\ndev_err(&spi->dev, "invalid xfer, full duplex\n");\r\nreturn -EINVAL;\r\n}\r\nif (t->bits_per_word > 32) {\r\ndev_err(&spi->dev, "invalid xfer width %d\n",\r\nt->bits_per_word);\r\nreturn -EINVAL;\r\n}\r\n}\r\nspin_lock(&hw->lock);\r\nif (hw->shutdown) {\r\nerror = -ESHUTDOWN;\r\ngoto error_unlock;\r\n}\r\nlist_add_tail(&m->queue, &hw->msg_queue);\r\nqueue_work(hw->workqueue, &hw->work);\r\nerror_unlock:\r\nspin_unlock(&hw->lock);\r\nreturn error;\r\n}\r\nstatic int ti_ssp_spi_probe(struct platform_device *pdev)\r\n{\r\nconst struct ti_ssp_spi_data *pdata;\r\nstruct ti_ssp_spi *hw;\r\nstruct spi_master *master;\r\nstruct device *dev = &pdev->dev;\r\nint error = 0;\r\npdata = dev->platform_data;\r\nif (!pdata) {\r\ndev_err(dev, "platform data not found\n");\r\nreturn -EINVAL;\r\n}\r\nmaster = spi_alloc_master(dev, sizeof(struct ti_ssp_spi));\r\nif (!master) {\r\ndev_err(dev, "cannot allocate SPI master\n");\r\nreturn -ENOMEM;\r\n}\r\nhw = spi_master_get_devdata(master);\r\nplatform_set_drvdata(pdev, hw);\r\nhw->master = master;\r\nhw->dev = dev;\r\nhw->select = pdata->select;\r\nspin_lock_init(&hw->lock);\r\ninit_completion(&hw->complete);\r\nINIT_LIST_HEAD(&hw->msg_queue);\r\nINIT_WORK(&hw->work, ti_ssp_spi_work);\r\nhw->workqueue = create_singlethread_workqueue(dev_name(dev));\r\nif (!hw->workqueue) {\r\nerror = -ENOMEM;\r\ndev_err(dev, "work queue creation failed\n");\r\ngoto error_wq;\r\n}\r\nerror = ti_ssp_set_iosel(hw->dev, pdata->iosel);\r\nif (error < 0) {\r\ndev_err(dev, "io setup failed\n");\r\ngoto error_iosel;\r\n}\r\nmaster->bus_num = pdev->id;\r\nmaster->num_chipselect = pdata->num_cs;\r\nmaster->mode_bits = MODE_BITS;\r\nmaster->flags = SPI_MASTER_HALF_DUPLEX;\r\nmaster->setup = ti_ssp_spi_setup;\r\nmaster->transfer = ti_ssp_spi_transfer;\r\nerror = spi_register_master(master);\r\nif (error) {\r\ndev_err(dev, "master registration failed\n");\r\ngoto error_reg;\r\n}\r\nreturn 0;\r\nerror_reg:\r\nerror_iosel:\r\ndestroy_workqueue(hw->workqueue);\r\nerror_wq:\r\nspi_master_put(master);\r\nreturn error;\r\n}\r\nstatic int ti_ssp_spi_remove(struct platform_device *pdev)\r\n{\r\nstruct ti_ssp_spi *hw = platform_get_drvdata(pdev);\r\nint error;\r\nhw->shutdown = 1;\r\nwhile (!list_empty(&hw->msg_queue)) {\r\nerror = wait_for_completion_interruptible(&hw->complete);\r\nif (error < 0) {\r\nhw->shutdown = 0;\r\nreturn error;\r\n}\r\n}\r\ndestroy_workqueue(hw->workqueue);\r\nspi_unregister_master(hw->master);\r\nreturn 0;\r\n}
