static int lq035q1_control(struct spi_device *spi, unsigned char reg, unsigned short value)\r\n{\r\nint ret;\r\nu8 regs[3] = { LQ035_INDEX, 0, 0 };\r\nu8 dat[3] = { LQ035_DATA, 0, 0 };\r\nif (!spi)\r\nreturn -ENODEV;\r\nregs[2] = reg;\r\ndat[1] = value >> 8;\r\ndat[2] = value & 0xFF;\r\nret = spi_write(spi, regs, ARRAY_SIZE(regs));\r\nret |= spi_write(spi, dat, ARRAY_SIZE(dat));\r\nreturn ret;\r\n}\r\nstatic int lq035q1_spidev_probe(struct spi_device *spi)\r\n{\r\nint ret;\r\nstruct spi_control *ctl;\r\nstruct bfin_lq035q1fb_info *info = container_of(spi->dev.driver,\r\nstruct bfin_lq035q1fb_info,\r\nspidrv.driver);\r\nctl = kzalloc(sizeof(*ctl), GFP_KERNEL);\r\nif (!ctl)\r\nreturn -ENOMEM;\r\nctl->mode = (info->disp_info->mode &\r\nLQ035_DRIVER_OUTPUT_MASK) | LQ035_DRIVER_OUTPUT_DEFAULT;\r\nret = lq035q1_control(spi, LQ035_SHUT_CTL, LQ035_ON);\r\nret |= lq035q1_control(spi, LQ035_DRIVER_OUTPUT_CTL, ctl->mode);\r\nif (ret) {\r\nkfree(ctl);\r\nreturn ret;\r\n}\r\nspi_set_drvdata(spi, ctl);\r\nreturn 0;\r\n}\r\nstatic int lq035q1_spidev_remove(struct spi_device *spi)\r\n{\r\nreturn lq035q1_control(spi, LQ035_SHUT_CTL, LQ035_SHUT);\r\n}\r\nstatic int lq035q1_spidev_suspend(struct spi_device *spi, pm_message_t state)\r\n{\r\nreturn lq035q1_control(spi, LQ035_SHUT_CTL, LQ035_SHUT);\r\n}\r\nstatic int lq035q1_spidev_resume(struct spi_device *spi)\r\n{\r\nint ret;\r\nstruct spi_control *ctl = spi_get_drvdata(spi);\r\nret = lq035q1_control(spi, LQ035_DRIVER_OUTPUT_CTL, ctl->mode);\r\nif (ret)\r\nreturn ret;\r\nreturn lq035q1_control(spi, LQ035_SHUT_CTL, LQ035_ON);\r\n}\r\nstatic void lq035q1_spidev_shutdown(struct spi_device *spi)\r\n{\r\nlq035q1_control(spi, LQ035_SHUT_CTL, LQ035_SHUT);\r\n}\r\nstatic int lq035q1_backlight(struct bfin_lq035q1fb_info *info, unsigned arg)\r\n{\r\nif (info->disp_info->use_bl)\r\ngpio_set_value(info->disp_info->gpio_bl, arg);\r\nreturn 0;\r\n}\r\nstatic int bfin_lq035q1_calc_timing(struct bfin_lq035q1fb_info *fbi)\r\n{\r\nunsigned long clocks_per_pix, cpld_pipeline_delay_cor;\r\nswitch (fbi->disp_info->ppi_mode) {\r\ncase USE_RGB565_16_BIT_PPI:\r\nfbi->lcd_bpp = 16;\r\nclocks_per_pix = 1;\r\ncpld_pipeline_delay_cor = 0;\r\nbreak;\r\ncase USE_RGB565_8_BIT_PPI:\r\nfbi->lcd_bpp = 16;\r\nclocks_per_pix = 2;\r\ncpld_pipeline_delay_cor = 3;\r\nbreak;\r\ncase USE_RGB888_8_BIT_PPI:\r\nfbi->lcd_bpp = 24;\r\nclocks_per_pix = 3;\r\ncpld_pipeline_delay_cor = 5;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nfbi->h_actpix = (LCD_X_RES * clocks_per_pix);\r\nfbi->h_period = (336 * clocks_per_pix);\r\nfbi->h_pulse = (2 * clocks_per_pix);\r\nfbi->h_start = (7 * clocks_per_pix + cpld_pipeline_delay_cor);\r\nfbi->v_lines = (LCD_Y_RES + U_LINE);\r\nfbi->v_pulse = (2 * clocks_per_pix);\r\nfbi->v_period = (fbi->h_period * fbi->v_lines);\r\nreturn 0;\r\n}\r\nstatic void bfin_lq035q1_config_ppi(struct bfin_lq035q1fb_info *fbi)\r\n{\r\nunsigned ppi_pmode;\r\nif (fbi->disp_info->ppi_mode == USE_RGB565_16_BIT_PPI)\r\nppi_pmode = DLEN_16;\r\nelse\r\nppi_pmode = (DLEN_8 | PACK_EN);\r\nbfin_write_PPI_DELAY(fbi->h_start);\r\nbfin_write_PPI_COUNT(fbi->h_actpix - 1);\r\nbfin_write_PPI_FRAME(fbi->v_lines);\r\nbfin_write_PPI_CONTROL(PPI_TX_MODE |\r\nPPI_XFER_TYPE_11 |\r\nPPI_PORT_CFG_01 |\r\nppi_pmode |\r\nPPI_POLS_1);\r\n}\r\nstatic inline void bfin_lq035q1_disable_ppi(void)\r\n{\r\nbfin_write_PPI_CONTROL(bfin_read_PPI_CONTROL() & ~PORT_EN);\r\n}\r\nstatic inline void bfin_lq035q1_enable_ppi(void)\r\n{\r\nbfin_write_PPI_CONTROL(bfin_read_PPI_CONTROL() | PORT_EN);\r\n}\r\nstatic void bfin_lq035q1_start_timers(void)\r\n{\r\nenable_gptimers(TIMER_VSYNCbit | TIMER_HSYNCbit);\r\n}\r\nstatic void bfin_lq035q1_stop_timers(void)\r\n{\r\ndisable_gptimers(TIMER_HSYNCbit | TIMER_VSYNCbit);\r\nset_gptimer_status(0, TIMER_HSYNC_STATUS_TRUN | TIMER_VSYNC_STATUS_TRUN |\r\nTIMER_HSYNC_STATUS_TIMIL | TIMER_VSYNC_STATUS_TIMIL |\r\nTIMER_HSYNC_STATUS_TOVF | TIMER_VSYNC_STATUS_TOVF);\r\n}\r\nstatic void bfin_lq035q1_init_timers(struct bfin_lq035q1fb_info *fbi)\r\n{\r\nbfin_lq035q1_stop_timers();\r\nset_gptimer_period(TIMER_HSYNC_id, fbi->h_period);\r\nset_gptimer_pwidth(TIMER_HSYNC_id, fbi->h_pulse);\r\nset_gptimer_config(TIMER_HSYNC_id, TIMER_MODE_PWM | TIMER_PERIOD_CNT |\r\nTIMER_TIN_SEL | TIMER_CLK_SEL|\r\nTIMER_EMU_RUN);\r\nset_gptimer_period(TIMER_VSYNC_id, fbi->v_period);\r\nset_gptimer_pwidth(TIMER_VSYNC_id, fbi->v_pulse);\r\nset_gptimer_config(TIMER_VSYNC_id, TIMER_MODE_PWM | TIMER_PERIOD_CNT |\r\nTIMER_TIN_SEL | TIMER_CLK_SEL |\r\nTIMER_EMU_RUN);\r\n}\r\nstatic void bfin_lq035q1_config_dma(struct bfin_lq035q1fb_info *fbi)\r\n{\r\nset_dma_config(CH_PPI,\r\nset_bfin_dma_config(DIR_READ, DMA_FLOW_AUTO,\r\nINTR_DISABLE, DIMENSION_2D,\r\nDATA_SIZE_16,\r\nDMA_NOSYNC_KEEP_DMA_BUF));\r\nset_dma_x_count(CH_PPI, (LCD_X_RES * fbi->lcd_bpp) / DMA_BUS_SIZE);\r\nset_dma_x_modify(CH_PPI, DMA_BUS_SIZE / 8);\r\nset_dma_y_count(CH_PPI, fbi->v_lines);\r\nset_dma_y_modify(CH_PPI, DMA_BUS_SIZE / 8);\r\nset_dma_start_addr(CH_PPI, (unsigned long)fbi->fb_buffer);\r\n}\r\nstatic inline void bfin_lq035q1_free_ports(unsigned ppi16)\r\n{\r\nif (ppi16)\r\nperipheral_free_list(ppi0_req_16);\r\nelse\r\nperipheral_free_list(ppi0_req_8);\r\nif (ANOMALY_05000400)\r\ngpio_free(P_IDENT(P_PPI0_FS3));\r\n}\r\nstatic int bfin_lq035q1_request_ports(struct platform_device *pdev,\r\nunsigned ppi16)\r\n{\r\nint ret;\r\nif (ANOMALY_05000400) {\r\nint ret = gpio_request_one(P_IDENT(P_PPI0_FS3),\r\nGPIOF_OUT_INIT_LOW, "PPI_FS3");\r\nif (ret)\r\nreturn ret;\r\n}\r\nif (ppi16)\r\nret = peripheral_request_list(ppi0_req_16, DRIVER_NAME);\r\nelse\r\nret = peripheral_request_list(ppi0_req_8, DRIVER_NAME);\r\nif (ret) {\r\ndev_err(&pdev->dev, "requesting peripherals failed\n");\r\nreturn -EFAULT;\r\n}\r\nreturn 0;\r\n}\r\nstatic int bfin_lq035q1_fb_open(struct fb_info *info, int user)\r\n{\r\nstruct bfin_lq035q1fb_info *fbi = info->par;\r\nspin_lock(&fbi->lock);\r\nfbi->lq035_open_cnt++;\r\nif (fbi->lq035_open_cnt <= 1) {\r\nbfin_lq035q1_disable_ppi();\r\nSSYNC();\r\nbfin_lq035q1_config_dma(fbi);\r\nbfin_lq035q1_config_ppi(fbi);\r\nbfin_lq035q1_init_timers(fbi);\r\nenable_dma(CH_PPI);\r\nbfin_lq035q1_enable_ppi();\r\nbfin_lq035q1_start_timers();\r\nlq035q1_backlight(fbi, 1);\r\n}\r\nspin_unlock(&fbi->lock);\r\nreturn 0;\r\n}\r\nstatic int bfin_lq035q1_fb_release(struct fb_info *info, int user)\r\n{\r\nstruct bfin_lq035q1fb_info *fbi = info->par;\r\nspin_lock(&fbi->lock);\r\nfbi->lq035_open_cnt--;\r\nif (fbi->lq035_open_cnt <= 0) {\r\nlq035q1_backlight(fbi, 0);\r\nbfin_lq035q1_disable_ppi();\r\nSSYNC();\r\ndisable_dma(CH_PPI);\r\nbfin_lq035q1_stop_timers();\r\n}\r\nspin_unlock(&fbi->lock);\r\nreturn 0;\r\n}\r\nstatic int bfin_lq035q1_fb_check_var(struct fb_var_screeninfo *var,\r\nstruct fb_info *info)\r\n{\r\nstruct bfin_lq035q1fb_info *fbi = info->par;\r\nif (var->bits_per_pixel == fbi->lcd_bpp) {\r\nvar->red.offset = info->var.red.offset;\r\nvar->green.offset = info->var.green.offset;\r\nvar->blue.offset = info->var.blue.offset;\r\nvar->red.length = info->var.red.length;\r\nvar->green.length = info->var.green.length;\r\nvar->blue.length = info->var.blue.length;\r\nvar->transp.offset = 0;\r\nvar->transp.length = 0;\r\nvar->transp.msb_right = 0;\r\nvar->red.msb_right = 0;\r\nvar->green.msb_right = 0;\r\nvar->blue.msb_right = 0;\r\n} else {\r\npr_debug("%s: depth not supported: %u BPP\n", __func__,\r\nvar->bits_per_pixel);\r\nreturn -EINVAL;\r\n}\r\nif (info->var.xres != var->xres || info->var.yres != var->yres ||\r\ninfo->var.xres_virtual != var->xres_virtual ||\r\ninfo->var.yres_virtual != var->yres_virtual) {\r\npr_debug("%s: Resolution not supported: X%u x Y%u \n",\r\n__func__, var->xres, var->yres);\r\nreturn -EINVAL;\r\n}\r\nif ((info->fix.line_length * var->yres_virtual) > info->fix.smem_len) {\r\npr_debug("%s: Memory Limit requested yres_virtual = %u\n",\r\n__func__, var->yres_virtual);\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}\r\nint bfin_lq035q1_fb_cursor(struct fb_info *info, struct fb_cursor *cursor)\r\n{\r\nif (nocursor)\r\nreturn 0;\r\nelse\r\nreturn -EINVAL;\r\n}\r\nstatic int bfin_lq035q1_fb_setcolreg(u_int regno, u_int red, u_int green,\r\nu_int blue, u_int transp,\r\nstruct fb_info *info)\r\n{\r\nif (regno >= BFIN_LCD_NBR_PALETTE_ENTRIES)\r\nreturn -EINVAL;\r\nif (info->var.grayscale) {\r\nred = green = blue = (red * 77 + green * 151 + blue * 28) >> 8;\r\n}\r\nif (info->fix.visual == FB_VISUAL_TRUECOLOR) {\r\nu32 value;\r\nif (regno > 16)\r\nreturn -EINVAL;\r\nred >>= (16 - info->var.red.length);\r\ngreen >>= (16 - info->var.green.length);\r\nblue >>= (16 - info->var.blue.length);\r\nvalue = (red << info->var.red.offset) |\r\n(green << info->var.green.offset) |\r\n(blue << info->var.blue.offset);\r\nvalue &= 0xFFFFFF;\r\n((u32 *) (info->pseudo_palette))[regno] = value;\r\n}\r\nreturn 0;\r\n}\r\nstatic irqreturn_t bfin_lq035q1_irq_error(int irq, void *dev_id)\r\n{\r\nu16 status = bfin_read_PPI_STATUS();\r\nbfin_write_PPI_STATUS(-1);\r\nif (status) {\r\nbfin_lq035q1_disable_ppi();\r\ndisable_dma(CH_PPI);\r\nenable_dma(CH_PPI);\r\nbfin_lq035q1_enable_ppi();\r\nbfin_write_PPI_STATUS(-1);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int bfin_lq035q1_probe(struct platform_device *pdev)\r\n{\r\nstruct bfin_lq035q1fb_info *info;\r\nstruct fb_info *fbinfo;\r\nu32 active_video_mem_offset;\r\nint ret;\r\nret = request_dma(CH_PPI, DRIVER_NAME"_CH_PPI");\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "PPI DMA unavailable\n");\r\ngoto out1;\r\n}\r\nfbinfo = framebuffer_alloc(sizeof(*info), &pdev->dev);\r\nif (!fbinfo) {\r\nret = -ENOMEM;\r\ngoto out2;\r\n}\r\ninfo = fbinfo->par;\r\ninfo->fb = fbinfo;\r\ninfo->dev = &pdev->dev;\r\nspin_lock_init(&info->lock);\r\ninfo->disp_info = pdev->dev.platform_data;\r\nplatform_set_drvdata(pdev, fbinfo);\r\nret = bfin_lq035q1_calc_timing(info);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "Failed PPI Mode\n");\r\ngoto out3;\r\n}\r\nstrcpy(fbinfo->fix.id, DRIVER_NAME);\r\nfbinfo->fix.type = FB_TYPE_PACKED_PIXELS;\r\nfbinfo->fix.type_aux = 0;\r\nfbinfo->fix.xpanstep = 0;\r\nfbinfo->fix.ypanstep = 0;\r\nfbinfo->fix.ywrapstep = 0;\r\nfbinfo->fix.accel = FB_ACCEL_NONE;\r\nfbinfo->fix.visual = FB_VISUAL_TRUECOLOR;\r\nfbinfo->var.nonstd = 0;\r\nfbinfo->var.activate = FB_ACTIVATE_NOW;\r\nfbinfo->var.height = -1;\r\nfbinfo->var.width = -1;\r\nfbinfo->var.accel_flags = 0;\r\nfbinfo->var.vmode = FB_VMODE_NONINTERLACED;\r\nfbinfo->var.xres = LCD_X_RES;\r\nfbinfo->var.xres_virtual = LCD_X_RES;\r\nfbinfo->var.yres = LCD_Y_RES;\r\nfbinfo->var.yres_virtual = LCD_Y_RES;\r\nfbinfo->var.bits_per_pixel = info->lcd_bpp;\r\nif (info->disp_info->mode & LQ035_BGR) {\r\nif (info->lcd_bpp == 24) {\r\nfbinfo->var.red.offset = 0;\r\nfbinfo->var.green.offset = 8;\r\nfbinfo->var.blue.offset = 16;\r\n} else {\r\nfbinfo->var.red.offset = 0;\r\nfbinfo->var.green.offset = 5;\r\nfbinfo->var.blue.offset = 11;\r\n}\r\n} else {\r\nif (info->lcd_bpp == 24) {\r\nfbinfo->var.red.offset = 16;\r\nfbinfo->var.green.offset = 8;\r\nfbinfo->var.blue.offset = 0;\r\n} else {\r\nfbinfo->var.red.offset = 11;\r\nfbinfo->var.green.offset = 5;\r\nfbinfo->var.blue.offset = 0;\r\n}\r\n}\r\nfbinfo->var.transp.offset = 0;\r\nif (info->lcd_bpp == 24) {\r\nfbinfo->var.red.length = 8;\r\nfbinfo->var.green.length = 8;\r\nfbinfo->var.blue.length = 8;\r\n} else {\r\nfbinfo->var.red.length = 5;\r\nfbinfo->var.green.length = 6;\r\nfbinfo->var.blue.length = 5;\r\n}\r\nfbinfo->var.transp.length = 0;\r\nactive_video_mem_offset = ((U_LINE / 2) * LCD_X_RES * (info->lcd_bpp / 8));\r\nfbinfo->fix.smem_len = LCD_X_RES * LCD_Y_RES * info->lcd_bpp / 8\r\n+ active_video_mem_offset;\r\nfbinfo->fix.line_length = fbinfo->var.xres_virtual *\r\nfbinfo->var.bits_per_pixel / 8;\r\nfbinfo->fbops = &bfin_lq035q1_fb_ops;\r\nfbinfo->flags = FBINFO_FLAG_DEFAULT;\r\ninfo->fb_buffer =\r\ndma_alloc_coherent(NULL, fbinfo->fix.smem_len, &info->dma_handle,\r\nGFP_KERNEL);\r\nif (NULL == info->fb_buffer) {\r\ndev_err(&pdev->dev, "couldn't allocate dma buffer\n");\r\nret = -ENOMEM;\r\ngoto out3;\r\n}\r\nfbinfo->screen_base = (void *)info->fb_buffer + active_video_mem_offset;\r\nfbinfo->fix.smem_start = (int)info->fb_buffer + active_video_mem_offset;\r\nfbinfo->fbops = &bfin_lq035q1_fb_ops;\r\nfbinfo->pseudo_palette = &info->pseudo_pal;\r\nret = fb_alloc_cmap(&fbinfo->cmap, BFIN_LCD_NBR_PALETTE_ENTRIES, 0);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "failed to allocate colormap (%d entries)\n",\r\nBFIN_LCD_NBR_PALETTE_ENTRIES);\r\ngoto out4;\r\n}\r\nret = bfin_lq035q1_request_ports(pdev,\r\ninfo->disp_info->ppi_mode == USE_RGB565_16_BIT_PPI);\r\nif (ret) {\r\ndev_err(&pdev->dev, "couldn't request gpio port\n");\r\ngoto out6;\r\n}\r\ninfo->irq = platform_get_irq(pdev, 0);\r\nif (info->irq < 0) {\r\nret = -EINVAL;\r\ngoto out7;\r\n}\r\nret = request_irq(info->irq, bfin_lq035q1_irq_error, 0,\r\nDRIVER_NAME" PPI ERROR", info);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "unable to request PPI ERROR IRQ\n");\r\ngoto out7;\r\n}\r\ninfo->spidrv.driver.name = DRIVER_NAME"-spi";\r\ninfo->spidrv.probe = lq035q1_spidev_probe;\r\ninfo->spidrv.remove = lq035q1_spidev_remove;\r\ninfo->spidrv.shutdown = lq035q1_spidev_shutdown;\r\ninfo->spidrv.suspend = lq035q1_spidev_suspend;\r\ninfo->spidrv.resume = lq035q1_spidev_resume;\r\nret = spi_register_driver(&info->spidrv);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "couldn't register SPI Interface\n");\r\ngoto out8;\r\n}\r\nif (info->disp_info->use_bl) {\r\nret = gpio_request_one(info->disp_info->gpio_bl,\r\nGPIOF_OUT_INIT_LOW, "LQ035 Backlight");\r\nif (ret) {\r\ndev_err(&pdev->dev, "failed to request GPIO %d\n",\r\ninfo->disp_info->gpio_bl);\r\ngoto out9;\r\n}\r\n}\r\nret = register_framebuffer(fbinfo);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "unable to register framebuffer\n");\r\ngoto out10;\r\n}\r\ndev_info(&pdev->dev, "%dx%d %d-bit RGB FrameBuffer initialized\n",\r\nLCD_X_RES, LCD_Y_RES, info->lcd_bpp);\r\nreturn 0;\r\nout10:\r\nif (info->disp_info->use_bl)\r\ngpio_free(info->disp_info->gpio_bl);\r\nout9:\r\nspi_unregister_driver(&info->spidrv);\r\nout8:\r\nfree_irq(info->irq, info);\r\nout7:\r\nbfin_lq035q1_free_ports(info->disp_info->ppi_mode ==\r\nUSE_RGB565_16_BIT_PPI);\r\nout6:\r\nfb_dealloc_cmap(&fbinfo->cmap);\r\nout4:\r\ndma_free_coherent(NULL, fbinfo->fix.smem_len, info->fb_buffer,\r\ninfo->dma_handle);\r\nout3:\r\nframebuffer_release(fbinfo);\r\nout2:\r\nfree_dma(CH_PPI);\r\nout1:\r\nplatform_set_drvdata(pdev, NULL);\r\nreturn ret;\r\n}\r\nstatic int bfin_lq035q1_remove(struct platform_device *pdev)\r\n{\r\nstruct fb_info *fbinfo = platform_get_drvdata(pdev);\r\nstruct bfin_lq035q1fb_info *info = fbinfo->par;\r\nif (info->disp_info->use_bl)\r\ngpio_free(info->disp_info->gpio_bl);\r\nspi_unregister_driver(&info->spidrv);\r\nunregister_framebuffer(fbinfo);\r\nfree_dma(CH_PPI);\r\nfree_irq(info->irq, info);\r\nif (info->fb_buffer != NULL)\r\ndma_free_coherent(NULL, fbinfo->fix.smem_len, info->fb_buffer,\r\ninfo->dma_handle);\r\nfb_dealloc_cmap(&fbinfo->cmap);\r\nbfin_lq035q1_free_ports(info->disp_info->ppi_mode ==\r\nUSE_RGB565_16_BIT_PPI);\r\nplatform_set_drvdata(pdev, NULL);\r\nframebuffer_release(fbinfo);\r\ndev_info(&pdev->dev, "unregistered LCD driver\n");\r\nreturn 0;\r\n}\r\nstatic int bfin_lq035q1_suspend(struct device *dev)\r\n{\r\nstruct fb_info *fbinfo = dev_get_drvdata(dev);\r\nstruct bfin_lq035q1fb_info *info = fbinfo->par;\r\nif (info->lq035_open_cnt) {\r\nlq035q1_backlight(info, 0);\r\nbfin_lq035q1_disable_ppi();\r\nSSYNC();\r\ndisable_dma(CH_PPI);\r\nbfin_lq035q1_stop_timers();\r\nbfin_write_PPI_STATUS(-1);\r\n}\r\nreturn 0;\r\n}\r\nstatic int bfin_lq035q1_resume(struct device *dev)\r\n{\r\nstruct fb_info *fbinfo = dev_get_drvdata(dev);\r\nstruct bfin_lq035q1fb_info *info = fbinfo->par;\r\nif (info->lq035_open_cnt) {\r\nbfin_lq035q1_disable_ppi();\r\nSSYNC();\r\nbfin_lq035q1_config_dma(info);\r\nbfin_lq035q1_config_ppi(info);\r\nbfin_lq035q1_init_timers(info);\r\nenable_dma(CH_PPI);\r\nbfin_lq035q1_enable_ppi();\r\nbfin_lq035q1_start_timers();\r\nlq035q1_backlight(info, 1);\r\n}\r\nreturn 0;\r\n}
