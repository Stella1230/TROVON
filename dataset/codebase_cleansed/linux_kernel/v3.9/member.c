int dlm_slots_version(struct dlm_header *h)\r\n{\r\nif ((h->h_version & 0x0000FFFF) < DLM_HEADER_SLOTS)\r\nreturn 0;\r\nreturn 1;\r\n}\r\nvoid dlm_slot_save(struct dlm_ls *ls, struct dlm_rcom *rc,\r\nstruct dlm_member *memb)\r\n{\r\nstruct rcom_config *rf = (struct rcom_config *)rc->rc_buf;\r\nif (!dlm_slots_version(&rc->rc_header))\r\nreturn;\r\nmemb->slot = le16_to_cpu(rf->rf_our_slot);\r\nmemb->generation = le32_to_cpu(rf->rf_generation);\r\n}\r\nvoid dlm_slots_copy_out(struct dlm_ls *ls, struct dlm_rcom *rc)\r\n{\r\nstruct dlm_slot *slot;\r\nstruct rcom_slot *ro;\r\nint i;\r\nro = (struct rcom_slot *)(rc->rc_buf + sizeof(struct rcom_config));\r\nfor (i = 0; i < ls->ls_slots_size; i++) {\r\nslot = &ls->ls_slots[i];\r\nif (!slot->nodeid)\r\ncontinue;\r\nro->ro_nodeid = cpu_to_le32(slot->nodeid);\r\nro->ro_slot = cpu_to_le16(slot->slot);\r\nro++;\r\n}\r\n}\r\nstatic void log_debug_slots(struct dlm_ls *ls, uint32_t gen, int num_slots,\r\nstruct rcom_slot *ro0, struct dlm_slot *array,\r\nint array_size)\r\n{\r\nchar line[SLOT_DEBUG_LINE];\r\nint len = SLOT_DEBUG_LINE - 1;\r\nint pos = 0;\r\nint ret, i;\r\nif (!dlm_config.ci_log_debug)\r\nreturn;\r\nmemset(line, 0, sizeof(line));\r\nif (array) {\r\nfor (i = 0; i < array_size; i++) {\r\nif (!array[i].nodeid)\r\ncontinue;\r\nret = snprintf(line + pos, len - pos, " %d:%d",\r\narray[i].slot, array[i].nodeid);\r\nif (ret >= len - pos)\r\nbreak;\r\npos += ret;\r\n}\r\n} else if (ro0) {\r\nfor (i = 0; i < num_slots; i++) {\r\nret = snprintf(line + pos, len - pos, " %d:%d",\r\nro0[i].ro_slot, ro0[i].ro_nodeid);\r\nif (ret >= len - pos)\r\nbreak;\r\npos += ret;\r\n}\r\n}\r\nlog_debug(ls, "generation %u slots %d%s", gen, num_slots, line);\r\n}\r\nint dlm_slots_copy_in(struct dlm_ls *ls)\r\n{\r\nstruct dlm_member *memb;\r\nstruct dlm_rcom *rc = ls->ls_recover_buf;\r\nstruct rcom_config *rf = (struct rcom_config *)rc->rc_buf;\r\nstruct rcom_slot *ro0, *ro;\r\nint our_nodeid = dlm_our_nodeid();\r\nint i, num_slots;\r\nuint32_t gen;\r\nif (!dlm_slots_version(&rc->rc_header))\r\nreturn -1;\r\ngen = le32_to_cpu(rf->rf_generation);\r\nif (gen <= ls->ls_generation) {\r\nlog_error(ls, "dlm_slots_copy_in gen %u old %u",\r\ngen, ls->ls_generation);\r\n}\r\nls->ls_generation = gen;\r\nnum_slots = le16_to_cpu(rf->rf_num_slots);\r\nif (!num_slots)\r\nreturn -1;\r\nro0 = (struct rcom_slot *)(rc->rc_buf + sizeof(struct rcom_config));\r\nfor (i = 0, ro = ro0; i < num_slots; i++, ro++) {\r\nro->ro_nodeid = le32_to_cpu(ro->ro_nodeid);\r\nro->ro_slot = le16_to_cpu(ro->ro_slot);\r\n}\r\nlog_debug_slots(ls, gen, num_slots, ro0, NULL, 0);\r\nlist_for_each_entry(memb, &ls->ls_nodes, list) {\r\nfor (i = 0, ro = ro0; i < num_slots; i++, ro++) {\r\nif (ro->ro_nodeid != memb->nodeid)\r\ncontinue;\r\nmemb->slot = ro->ro_slot;\r\nmemb->slot_prev = memb->slot;\r\nbreak;\r\n}\r\nif (memb->nodeid == our_nodeid) {\r\nif (ls->ls_slot && ls->ls_slot != memb->slot) {\r\nlog_error(ls, "dlm_slots_copy_in our slot "\r\n"changed %d %d", ls->ls_slot,\r\nmemb->slot);\r\nreturn -1;\r\n}\r\nif (!ls->ls_slot)\r\nls->ls_slot = memb->slot;\r\n}\r\nif (!memb->slot) {\r\nlog_error(ls, "dlm_slots_copy_in nodeid %d no slot",\r\nmemb->nodeid);\r\nreturn -1;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nint dlm_slots_assign(struct dlm_ls *ls, int *num_slots, int *slots_size,\r\nstruct dlm_slot **slots_out, uint32_t *gen_out)\r\n{\r\nstruct dlm_member *memb;\r\nstruct dlm_slot *array;\r\nint our_nodeid = dlm_our_nodeid();\r\nint array_size, max_slots, i;\r\nint need = 0;\r\nint max = 0;\r\nint num = 0;\r\nuint32_t gen = 0;\r\nlist_for_each_entry(memb, &ls->ls_nodes, list) {\r\nif (memb->nodeid == our_nodeid) {\r\nmemb->slot = ls->ls_slot;\r\nmemb->generation = ls->ls_generation;\r\nbreak;\r\n}\r\n}\r\nlist_for_each_entry(memb, &ls->ls_nodes, list) {\r\nif (memb->generation > gen)\r\ngen = memb->generation;\r\nif (memb->slot == -1)\r\nreturn -1;\r\nif (!memb->slot)\r\nneed++;\r\nnum++;\r\nif (!max || max < memb->slot)\r\nmax = memb->slot;\r\nif (memb->slot_prev && memb->slot && memb->slot_prev != memb->slot) {\r\nlog_error(ls, "nodeid %d slot changed %d %d",\r\nmemb->nodeid, memb->slot_prev, memb->slot);\r\nreturn -1;\r\n}\r\nmemb->slot_prev = memb->slot;\r\n}\r\narray_size = max + need;\r\narray = kzalloc(array_size * sizeof(struct dlm_slot), GFP_NOFS);\r\nif (!array)\r\nreturn -ENOMEM;\r\nnum = 0;\r\nlist_for_each_entry(memb, &ls->ls_nodes, list) {\r\nif (!memb->slot)\r\ncontinue;\r\nif (memb->slot > array_size) {\r\nlog_error(ls, "invalid slot number %d", memb->slot);\r\nkfree(array);\r\nreturn -1;\r\n}\r\narray[memb->slot - 1].nodeid = memb->nodeid;\r\narray[memb->slot - 1].slot = memb->slot;\r\nnum++;\r\n}\r\nlist_for_each_entry(memb, &ls->ls_nodes, list) {\r\nif (memb->slot)\r\ncontinue;\r\nfor (i = 0; i < array_size; i++) {\r\nif (array[i].nodeid)\r\ncontinue;\r\nmemb->slot = i + 1;\r\nmemb->slot_prev = memb->slot;\r\narray[i].nodeid = memb->nodeid;\r\narray[i].slot = memb->slot;\r\nnum++;\r\nif (!ls->ls_slot && memb->nodeid == our_nodeid)\r\nls->ls_slot = memb->slot;\r\nbreak;\r\n}\r\nif (!memb->slot) {\r\nlog_error(ls, "no free slot found");\r\nkfree(array);\r\nreturn -1;\r\n}\r\n}\r\ngen++;\r\nlog_debug_slots(ls, gen, num, NULL, array, array_size);\r\nmax_slots = (dlm_config.ci_buffer_size - sizeof(struct dlm_rcom) -\r\nsizeof(struct rcom_config)) / sizeof(struct rcom_slot);\r\nif (num > max_slots) {\r\nlog_error(ls, "num_slots %d exceeds max_slots %d",\r\nnum, max_slots);\r\nkfree(array);\r\nreturn -1;\r\n}\r\n*gen_out = gen;\r\n*slots_out = array;\r\n*slots_size = array_size;\r\n*num_slots = num;\r\nreturn 0;\r\n}\r\nstatic void add_ordered_member(struct dlm_ls *ls, struct dlm_member *new)\r\n{\r\nstruct dlm_member *memb = NULL;\r\nstruct list_head *tmp;\r\nstruct list_head *newlist = &new->list;\r\nstruct list_head *head = &ls->ls_nodes;\r\nlist_for_each(tmp, head) {\r\nmemb = list_entry(tmp, struct dlm_member, list);\r\nif (new->nodeid < memb->nodeid)\r\nbreak;\r\n}\r\nif (!memb)\r\nlist_add_tail(newlist, head);\r\nelse {\r\nnewlist->prev = tmp->prev;\r\nnewlist->next = tmp;\r\ntmp->prev->next = newlist;\r\ntmp->prev = newlist;\r\n}\r\n}\r\nstatic int dlm_add_member(struct dlm_ls *ls, struct dlm_config_node *node)\r\n{\r\nstruct dlm_member *memb;\r\nint error;\r\nmemb = kzalloc(sizeof(struct dlm_member), GFP_NOFS);\r\nif (!memb)\r\nreturn -ENOMEM;\r\nerror = dlm_lowcomms_connect_node(node->nodeid);\r\nif (error < 0) {\r\nkfree(memb);\r\nreturn error;\r\n}\r\nmemb->nodeid = node->nodeid;\r\nmemb->weight = node->weight;\r\nmemb->comm_seq = node->comm_seq;\r\nadd_ordered_member(ls, memb);\r\nls->ls_num_nodes++;\r\nreturn 0;\r\n}\r\nstatic struct dlm_member *find_memb(struct list_head *head, int nodeid)\r\n{\r\nstruct dlm_member *memb;\r\nlist_for_each_entry(memb, head, list) {\r\nif (memb->nodeid == nodeid)\r\nreturn memb;\r\n}\r\nreturn NULL;\r\n}\r\nint dlm_is_member(struct dlm_ls *ls, int nodeid)\r\n{\r\nif (find_memb(&ls->ls_nodes, nodeid))\r\nreturn 1;\r\nreturn 0;\r\n}\r\nint dlm_is_removed(struct dlm_ls *ls, int nodeid)\r\n{\r\nif (find_memb(&ls->ls_nodes_gone, nodeid))\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic void clear_memb_list(struct list_head *head)\r\n{\r\nstruct dlm_member *memb;\r\nwhile (!list_empty(head)) {\r\nmemb = list_entry(head->next, struct dlm_member, list);\r\nlist_del(&memb->list);\r\nkfree(memb);\r\n}\r\n}\r\nvoid dlm_clear_members(struct dlm_ls *ls)\r\n{\r\nclear_memb_list(&ls->ls_nodes);\r\nls->ls_num_nodes = 0;\r\n}\r\nvoid dlm_clear_members_gone(struct dlm_ls *ls)\r\n{\r\nclear_memb_list(&ls->ls_nodes_gone);\r\n}\r\nstatic void make_member_array(struct dlm_ls *ls)\r\n{\r\nstruct dlm_member *memb;\r\nint i, w, x = 0, total = 0, all_zero = 0, *array;\r\nkfree(ls->ls_node_array);\r\nls->ls_node_array = NULL;\r\nlist_for_each_entry(memb, &ls->ls_nodes, list) {\r\nif (memb->weight)\r\ntotal += memb->weight;\r\n}\r\nif (!total) {\r\ntotal = ls->ls_num_nodes;\r\nall_zero = 1;\r\n}\r\nls->ls_total_weight = total;\r\narray = kmalloc(sizeof(int) * total, GFP_NOFS);\r\nif (!array)\r\nreturn;\r\nlist_for_each_entry(memb, &ls->ls_nodes, list) {\r\nif (!all_zero && !memb->weight)\r\ncontinue;\r\nif (all_zero)\r\nw = 1;\r\nelse\r\nw = memb->weight;\r\nDLM_ASSERT(x < total, printk("total %d x %d\n", total, x););\r\nfor (i = 0; i < w; i++)\r\narray[x++] = memb->nodeid;\r\n}\r\nls->ls_node_array = array;\r\n}\r\nstatic int ping_members(struct dlm_ls *ls)\r\n{\r\nstruct dlm_member *memb;\r\nint error = 0;\r\nlist_for_each_entry(memb, &ls->ls_nodes, list) {\r\nerror = dlm_recovery_stopped(ls);\r\nif (error)\r\nbreak;\r\nerror = dlm_rcom_status(ls, memb->nodeid, 0);\r\nif (error)\r\nbreak;\r\n}\r\nif (error)\r\nlog_debug(ls, "ping_members aborted %d last nodeid %d",\r\nerror, ls->ls_recover_nodeid);\r\nreturn error;\r\n}\r\nstatic void dlm_lsop_recover_prep(struct dlm_ls *ls)\r\n{\r\nif (!ls->ls_ops || !ls->ls_ops->recover_prep)\r\nreturn;\r\nls->ls_ops->recover_prep(ls->ls_ops_arg);\r\n}\r\nstatic void dlm_lsop_recover_slot(struct dlm_ls *ls, struct dlm_member *memb)\r\n{\r\nstruct dlm_slot slot;\r\nuint32_t seq;\r\nint error;\r\nif (!ls->ls_ops || !ls->ls_ops->recover_slot)\r\nreturn;\r\nerror = dlm_comm_seq(memb->nodeid, &seq);\r\nif (!error && seq == memb->comm_seq)\r\nreturn;\r\nslot.nodeid = memb->nodeid;\r\nslot.slot = memb->slot;\r\nls->ls_ops->recover_slot(ls->ls_ops_arg, &slot);\r\n}\r\nvoid dlm_lsop_recover_done(struct dlm_ls *ls)\r\n{\r\nstruct dlm_member *memb;\r\nstruct dlm_slot *slots;\r\nint i, num;\r\nif (!ls->ls_ops || !ls->ls_ops->recover_done)\r\nreturn;\r\nnum = ls->ls_num_nodes;\r\nslots = kzalloc(num * sizeof(struct dlm_slot), GFP_KERNEL);\r\nif (!slots)\r\nreturn;\r\ni = 0;\r\nlist_for_each_entry(memb, &ls->ls_nodes, list) {\r\nif (i == num) {\r\nlog_error(ls, "dlm_lsop_recover_done bad num %d", num);\r\ngoto out;\r\n}\r\nslots[i].nodeid = memb->nodeid;\r\nslots[i].slot = memb->slot;\r\ni++;\r\n}\r\nls->ls_ops->recover_done(ls->ls_ops_arg, slots, num,\r\nls->ls_slot, ls->ls_generation);\r\nout:\r\nkfree(slots);\r\n}\r\nstatic struct dlm_config_node *find_config_node(struct dlm_recover *rv,\r\nint nodeid)\r\n{\r\nint i;\r\nfor (i = 0; i < rv->nodes_count; i++) {\r\nif (rv->nodes[i].nodeid == nodeid)\r\nreturn &rv->nodes[i];\r\n}\r\nreturn NULL;\r\n}\r\nint dlm_recover_members(struct dlm_ls *ls, struct dlm_recover *rv, int *neg_out)\r\n{\r\nstruct dlm_member *memb, *safe;\r\nstruct dlm_config_node *node;\r\nint i, error, neg = 0, low = -1;\r\nlist_for_each_entry(memb, &ls->ls_nodes_gone, list) {\r\nlog_debug(ls, "prev removed member %d", memb->nodeid);\r\nneg++;\r\n}\r\nlist_for_each_entry_safe(memb, safe, &ls->ls_nodes, list) {\r\nnode = find_config_node(rv, memb->nodeid);\r\nif (node && !node->new)\r\ncontinue;\r\nif (!node) {\r\nlog_debug(ls, "remove member %d", memb->nodeid);\r\n} else {\r\nlog_debug(ls, "remove member %d comm_seq %u %u",\r\nmemb->nodeid, memb->comm_seq, node->comm_seq);\r\n}\r\nneg++;\r\nlist_move(&memb->list, &ls->ls_nodes_gone);\r\nls->ls_num_nodes--;\r\ndlm_lsop_recover_slot(ls, memb);\r\n}\r\nfor (i = 0; i < rv->nodes_count; i++) {\r\nnode = &rv->nodes[i];\r\nif (dlm_is_member(ls, node->nodeid))\r\ncontinue;\r\ndlm_add_member(ls, node);\r\nlog_debug(ls, "add member %d", node->nodeid);\r\n}\r\nlist_for_each_entry(memb, &ls->ls_nodes, list) {\r\nif (low == -1 || memb->nodeid < low)\r\nlow = memb->nodeid;\r\n}\r\nls->ls_low_nodeid = low;\r\nmake_member_array(ls);\r\n*neg_out = neg;\r\nerror = ping_members(ls);\r\nif (!error || error == -EPROTO) {\r\nls->ls_members_result = error;\r\ncomplete(&ls->ls_members_done);\r\n}\r\nlog_debug(ls, "dlm_recover_members %d nodes", ls->ls_num_nodes);\r\nreturn error;\r\n}\r\nint dlm_ls_stop(struct dlm_ls *ls)\r\n{\r\nint new;\r\ndown_write(&ls->ls_recv_active);\r\nspin_lock(&ls->ls_recover_lock);\r\nset_bit(LSFL_RECOVER_STOP, &ls->ls_flags);\r\nnew = test_and_clear_bit(LSFL_RUNNING, &ls->ls_flags);\r\nls->ls_recover_seq++;\r\nspin_unlock(&ls->ls_recover_lock);\r\nup_write(&ls->ls_recv_active);\r\nif (new) {\r\nset_bit(LSFL_RECOVER_DOWN, &ls->ls_flags);\r\nwake_up_process(ls->ls_recoverd_task);\r\nwait_event(ls->ls_recover_lock_wait,\r\ntest_bit(LSFL_RECOVER_LOCK, &ls->ls_flags));\r\n}\r\ndlm_recoverd_suspend(ls);\r\nspin_lock(&ls->ls_recover_lock);\r\nkfree(ls->ls_slots);\r\nls->ls_slots = NULL;\r\nls->ls_num_slots = 0;\r\nls->ls_slots_size = 0;\r\nls->ls_recover_status = 0;\r\nspin_unlock(&ls->ls_recover_lock);\r\ndlm_recoverd_resume(ls);\r\nif (!ls->ls_recover_begin)\r\nls->ls_recover_begin = jiffies;\r\ndlm_lsop_recover_prep(ls);\r\nreturn 0;\r\n}\r\nint dlm_ls_start(struct dlm_ls *ls)\r\n{\r\nstruct dlm_recover *rv = NULL, *rv_old;\r\nstruct dlm_config_node *nodes;\r\nint error, count;\r\nrv = kzalloc(sizeof(struct dlm_recover), GFP_NOFS);\r\nif (!rv)\r\nreturn -ENOMEM;\r\nerror = dlm_config_nodes(ls->ls_name, &nodes, &count);\r\nif (error < 0)\r\ngoto fail;\r\nspin_lock(&ls->ls_recover_lock);\r\nif (!dlm_locking_stopped(ls)) {\r\nspin_unlock(&ls->ls_recover_lock);\r\nlog_error(ls, "start ignored: lockspace running");\r\nerror = -EINVAL;\r\ngoto fail;\r\n}\r\nrv->nodes = nodes;\r\nrv->nodes_count = count;\r\nrv->seq = ++ls->ls_recover_seq;\r\nrv_old = ls->ls_recover_args;\r\nls->ls_recover_args = rv;\r\nspin_unlock(&ls->ls_recover_lock);\r\nif (rv_old) {\r\nlog_error(ls, "unused recovery %llx %d",\r\n(unsigned long long)rv_old->seq, rv_old->nodes_count);\r\nkfree(rv_old->nodes);\r\nkfree(rv_old);\r\n}\r\nset_bit(LSFL_RECOVER_WORK, &ls->ls_flags);\r\nwake_up_process(ls->ls_recoverd_task);\r\nreturn 0;\r\nfail:\r\nkfree(rv);\r\nkfree(nodes);\r\nreturn error;\r\n}
