static inline void __iomem *port_mmio(struct ata_port *ap, unsigned int offset)\r\n{\r\nreturn ap->host->iomap[PDC_MMIO_BAR] + ap->port_no * 0x100 + offset;\r\n}\r\nstatic inline void __iomem *dev_mmio(struct ata_port *ap, struct ata_device *adev, unsigned int offset)\r\n{\r\nu8 adj = (adev->devno) ? 0x08 : 0x00;\r\nreturn port_mmio(ap, offset) + adj;\r\n}\r\nstatic int pdc2027x_cable_detect(struct ata_port *ap)\r\n{\r\nu32 cgcr;\r\ncgcr = ioread32(port_mmio(ap, PDC_GLOBAL_CTL));\r\nif (cgcr & (1 << 26))\r\ngoto cbl40;\r\nPDPRINTK("No cable or 80-conductor cable on port %d\n", ap->port_no);\r\nreturn ATA_CBL_PATA80;\r\ncbl40:\r\nprintk(KERN_INFO DRV_NAME ": 40-conductor cable detected on port %d\n", ap->port_no);\r\nreturn ATA_CBL_PATA40;\r\n}\r\nstatic inline int pdc2027x_port_enabled(struct ata_port *ap)\r\n{\r\nreturn ioread8(port_mmio(ap, PDC_ATA_CTL)) & 0x02;\r\n}\r\nstatic int pdc2027x_prereset(struct ata_link *link, unsigned long deadline)\r\n{\r\nif (!pdc2027x_port_enabled(link->ap))\r\nreturn -ENOENT;\r\nreturn ata_sff_prereset(link, deadline);\r\n}\r\nstatic unsigned long pdc2027x_mode_filter(struct ata_device *adev, unsigned long mask)\r\n{\r\nunsigned char model_num[ATA_ID_PROD_LEN + 1];\r\nstruct ata_device *pair = ata_dev_pair(adev);\r\nif (adev->class != ATA_DEV_ATA || adev->devno == 0 || pair == NULL)\r\nreturn mask;\r\nata_id_c_string(pair->id, model_num, ATA_ID_PROD,\r\nATA_ID_PROD_LEN + 1);\r\nif (strstr(model_num, "Maxtor") == NULL && pair->dma_mode == XFER_UDMA_6)\r\nmask &= ~ (1 << (6 + ATA_SHIFT_UDMA));\r\nreturn mask;\r\n}\r\nstatic void pdc2027x_set_piomode(struct ata_port *ap, struct ata_device *adev)\r\n{\r\nunsigned int pio = adev->pio_mode - XFER_PIO_0;\r\nu32 ctcr0, ctcr1;\r\nPDPRINTK("adev->pio_mode[%X]\n", adev->pio_mode);\r\nif (pio > 4) {\r\nprintk(KERN_ERR DRV_NAME ": Unknown pio mode [%d] ignored\n", pio);\r\nreturn;\r\n}\r\nPDPRINTK("Set pio regs... \n");\r\nctcr0 = ioread32(dev_mmio(ap, adev, PDC_CTCR0));\r\nctcr0 &= 0xffff0000;\r\nctcr0 |= pdc2027x_pio_timing_tbl[pio].value0 |\r\n(pdc2027x_pio_timing_tbl[pio].value1 << 8);\r\niowrite32(ctcr0, dev_mmio(ap, adev, PDC_CTCR0));\r\nctcr1 = ioread32(dev_mmio(ap, adev, PDC_CTCR1));\r\nctcr1 &= 0x00ffffff;\r\nctcr1 |= (pdc2027x_pio_timing_tbl[pio].value2 << 24);\r\niowrite32(ctcr1, dev_mmio(ap, adev, PDC_CTCR1));\r\nPDPRINTK("Set pio regs done\n");\r\nPDPRINTK("Set to pio mode[%u] \n", pio);\r\n}\r\nstatic void pdc2027x_set_dmamode(struct ata_port *ap, struct ata_device *adev)\r\n{\r\nunsigned int dma_mode = adev->dma_mode;\r\nu32 ctcr0, ctcr1;\r\nif ((dma_mode >= XFER_UDMA_0) &&\r\n(dma_mode <= XFER_UDMA_6)) {\r\nunsigned int udma_mode = dma_mode & 0x07;\r\nif (dma_mode == XFER_UDMA_2) {\r\nctcr1 = ioread32(dev_mmio(ap, adev, PDC_CTCR1));\r\niowrite32(ctcr1 & ~(1 << 7), dev_mmio(ap, adev, PDC_CTCR1));\r\n}\r\nPDPRINTK("Set udma regs... \n");\r\nctcr1 = ioread32(dev_mmio(ap, adev, PDC_CTCR1));\r\nctcr1 &= 0xff000000;\r\nctcr1 |= pdc2027x_udma_timing_tbl[udma_mode].value0 |\r\n(pdc2027x_udma_timing_tbl[udma_mode].value1 << 8) |\r\n(pdc2027x_udma_timing_tbl[udma_mode].value2 << 16);\r\niowrite32(ctcr1, dev_mmio(ap, adev, PDC_CTCR1));\r\nPDPRINTK("Set udma regs done\n");\r\nPDPRINTK("Set to udma mode[%u] \n", udma_mode);\r\n} else if ((dma_mode >= XFER_MW_DMA_0) &&\r\n(dma_mode <= XFER_MW_DMA_2)) {\r\nunsigned int mdma_mode = dma_mode & 0x07;\r\nPDPRINTK("Set mdma regs... \n");\r\nctcr0 = ioread32(dev_mmio(ap, adev, PDC_CTCR0));\r\nctcr0 &= 0x0000ffff;\r\nctcr0 |= (pdc2027x_mdma_timing_tbl[mdma_mode].value0 << 16) |\r\n(pdc2027x_mdma_timing_tbl[mdma_mode].value1 << 24);\r\niowrite32(ctcr0, dev_mmio(ap, adev, PDC_CTCR0));\r\nPDPRINTK("Set mdma regs done\n");\r\nPDPRINTK("Set to mdma mode[%u] \n", mdma_mode);\r\n} else {\r\nprintk(KERN_ERR DRV_NAME ": Unknown dma mode [%u] ignored\n", dma_mode);\r\n}\r\n}\r\nstatic int pdc2027x_set_mode(struct ata_link *link, struct ata_device **r_failed)\r\n{\r\nstruct ata_port *ap = link->ap;\r\nstruct ata_device *dev;\r\nint rc;\r\nrc = ata_do_set_mode(link, r_failed);\r\nif (rc < 0)\r\nreturn rc;\r\nata_for_each_dev(dev, link, ENABLED) {\r\npdc2027x_set_piomode(ap, dev);\r\nif (dev->xfer_shift == ATA_SHIFT_PIO) {\r\nu32 ctcr1 = ioread32(dev_mmio(ap, dev, PDC_CTCR1));\r\nctcr1 |= (1 << 25);\r\niowrite32(ctcr1, dev_mmio(ap, dev, PDC_CTCR1));\r\nPDPRINTK("Turn on prefetch\n");\r\n} else {\r\npdc2027x_set_dmamode(ap, dev);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int pdc2027x_check_atapi_dma(struct ata_queued_cmd *qc)\r\n{\r\nstruct scsi_cmnd *cmd = qc->scsicmd;\r\nu8 *scsicmd = cmd->cmnd;\r\nint rc = 1;\r\nswitch (scsicmd[0]) {\r\ncase READ_10:\r\ncase WRITE_10:\r\ncase READ_12:\r\ncase WRITE_12:\r\ncase READ_6:\r\ncase WRITE_6:\r\ncase 0xad:\r\ncase 0xbe:\r\nrc = 0;\r\nbreak;\r\ndefault:\r\n;\r\n}\r\nreturn rc;\r\n}\r\nstatic long pdc_read_counter(struct ata_host *host)\r\n{\r\nvoid __iomem *mmio_base = host->iomap[PDC_MMIO_BAR];\r\nlong counter;\r\nint retry = 1;\r\nu32 bccrl, bccrh, bccrlv, bccrhv;\r\nretry:\r\nbccrl = ioread32(mmio_base + PDC_BYTE_COUNT) & 0x7fff;\r\nbccrh = ioread32(mmio_base + PDC_BYTE_COUNT + 0x100) & 0x7fff;\r\nbccrlv = ioread32(mmio_base + PDC_BYTE_COUNT) & 0x7fff;\r\nbccrhv = ioread32(mmio_base + PDC_BYTE_COUNT + 0x100) & 0x7fff;\r\ncounter = (bccrh << 15) | bccrl;\r\nPDPRINTK("bccrh [%X] bccrl [%X]\n", bccrh, bccrl);\r\nPDPRINTK("bccrhv[%X] bccrlv[%X]\n", bccrhv, bccrlv);\r\nif (retry && !(bccrh == bccrhv && bccrl >= bccrlv)) {\r\nretry--;\r\nPDPRINTK("rereading counter\n");\r\ngoto retry;\r\n}\r\nreturn counter;\r\n}\r\nstatic void pdc_adjust_pll(struct ata_host *host, long pll_clock, unsigned int board_idx)\r\n{\r\nvoid __iomem *mmio_base = host->iomap[PDC_MMIO_BAR];\r\nu16 pll_ctl;\r\nlong pll_clock_khz = pll_clock / 1000;\r\nlong pout_required = board_idx? PDC_133_MHZ:PDC_100_MHZ;\r\nlong ratio = pout_required / pll_clock_khz;\r\nint F, R;\r\nif (unlikely(pll_clock_khz < 5000L || pll_clock_khz > 70000L)) {\r\nprintk(KERN_ERR DRV_NAME ": Invalid PLL input clock %ldkHz, give up!\n", pll_clock_khz);\r\nreturn;\r\n}\r\n#ifdef PDC_DEBUG\r\nPDPRINTK("pout_required is %ld\n", pout_required);\r\npll_ctl = ioread16(mmio_base + PDC_PLL_CTL);\r\nPDPRINTK("pll_ctl[%X]\n", pll_ctl);\r\n#endif\r\nif (ratio < 8600L) {\r\nR = 0x0d;\r\n} else if (ratio < 12900L) {\r\nR = 0x08;\r\n} else if (ratio < 16100L) {\r\nR = 0x06;\r\n} else if (ratio < 64000L) {\r\nR = 0x00;\r\n} else {\r\nprintk(KERN_ERR DRV_NAME ": Invalid ratio %ld, give up!\n", ratio);\r\nreturn;\r\n}\r\nF = (ratio * (R+2)) / 1000 - 2;\r\nif (unlikely(F < 0 || F > 127)) {\r\nprintk(KERN_ERR DRV_NAME ": F[%d] invalid!\n", F);\r\nreturn;\r\n}\r\nPDPRINTK("F[%d] R[%d] ratio*1000[%ld]\n", F, R, ratio);\r\npll_ctl = (R << 8) | F;\r\nPDPRINTK("Writing pll_ctl[%X]\n", pll_ctl);\r\niowrite16(pll_ctl, mmio_base + PDC_PLL_CTL);\r\nioread16(mmio_base + PDC_PLL_CTL);\r\nmdelay(30);\r\n#ifdef PDC_DEBUG\r\npll_ctl = ioread16(mmio_base + PDC_PLL_CTL);\r\nPDPRINTK("pll_ctl[%X]\n", pll_ctl);\r\n#endif\r\nreturn;\r\n}\r\nstatic long pdc_detect_pll_input_clock(struct ata_host *host)\r\n{\r\nvoid __iomem *mmio_base = host->iomap[PDC_MMIO_BAR];\r\nu32 scr;\r\nlong start_count, end_count;\r\nstruct timeval start_time, end_time;\r\nlong pll_clock, usec_elapsed;\r\nscr = ioread32(mmio_base + PDC_SYS_CTL);\r\nPDPRINTK("scr[%X]\n", scr);\r\niowrite32(scr | (0x01 << 14), mmio_base + PDC_SYS_CTL);\r\nioread32(mmio_base + PDC_SYS_CTL);\r\nstart_count = pdc_read_counter(host);\r\ndo_gettimeofday(&start_time);\r\nmdelay(100);\r\nend_count = pdc_read_counter(host);\r\ndo_gettimeofday(&end_time);\r\nscr = ioread32(mmio_base + PDC_SYS_CTL);\r\nPDPRINTK("scr[%X]\n", scr);\r\niowrite32(scr & ~(0x01 << 14), mmio_base + PDC_SYS_CTL);\r\nioread32(mmio_base + PDC_SYS_CTL);\r\nusec_elapsed = (end_time.tv_sec - start_time.tv_sec) * 1000000 +\r\n(end_time.tv_usec - start_time.tv_usec);\r\npll_clock = ((start_count - end_count) & 0x3fffffff) / 100 *\r\n(100000000 / usec_elapsed);\r\nPDPRINTK("start[%ld] end[%ld] \n", start_count, end_count);\r\nPDPRINTK("PLL input clock[%ld]Hz\n", pll_clock);\r\nreturn pll_clock;\r\n}\r\nstatic int pdc_hardware_init(struct ata_host *host, unsigned int board_idx)\r\n{\r\nlong pll_clock;\r\npll_clock = pdc_detect_pll_input_clock(host);\r\ndev_info(host->dev, "PLL input clock %ld kHz\n", pll_clock/1000);\r\npdc_adjust_pll(host, pll_clock, board_idx);\r\nreturn 0;\r\n}\r\nstatic void pdc_ata_setup_port(struct ata_ioports *port, void __iomem *base)\r\n{\r\nport->cmd_addr =\r\nport->data_addr = base;\r\nport->feature_addr =\r\nport->error_addr = base + 0x05;\r\nport->nsect_addr = base + 0x0a;\r\nport->lbal_addr = base + 0x0f;\r\nport->lbam_addr = base + 0x10;\r\nport->lbah_addr = base + 0x15;\r\nport->device_addr = base + 0x1a;\r\nport->command_addr =\r\nport->status_addr = base + 0x1f;\r\nport->altstatus_addr =\r\nport->ctl_addr = base + 0x81a;\r\n}\r\nstatic int pdc2027x_init_one(struct pci_dev *pdev,\r\nconst struct pci_device_id *ent)\r\n{\r\nstatic const unsigned long cmd_offset[] = { 0x17c0, 0x15c0 };\r\nstatic const unsigned long bmdma_offset[] = { 0x1000, 0x1008 };\r\nunsigned int board_idx = (unsigned int) ent->driver_data;\r\nconst struct ata_port_info *ppi[] =\r\n{ &pdc2027x_port_info[board_idx], NULL };\r\nstruct ata_host *host;\r\nvoid __iomem *mmio_base;\r\nint i, rc;\r\nata_print_version_once(&pdev->dev, DRV_VERSION);\r\nhost = ata_host_alloc_pinfo(&pdev->dev, ppi, 2);\r\nif (!host)\r\nreturn -ENOMEM;\r\nrc = pcim_enable_device(pdev);\r\nif (rc)\r\nreturn rc;\r\nrc = pcim_iomap_regions(pdev, 1 << PDC_MMIO_BAR, DRV_NAME);\r\nif (rc)\r\nreturn rc;\r\nhost->iomap = pcim_iomap_table(pdev);\r\nrc = pci_set_dma_mask(pdev, ATA_DMA_MASK);\r\nif (rc)\r\nreturn rc;\r\nrc = pci_set_consistent_dma_mask(pdev, ATA_DMA_MASK);\r\nif (rc)\r\nreturn rc;\r\nmmio_base = host->iomap[PDC_MMIO_BAR];\r\nfor (i = 0; i < 2; i++) {\r\nstruct ata_port *ap = host->ports[i];\r\npdc_ata_setup_port(&ap->ioaddr, mmio_base + cmd_offset[i]);\r\nap->ioaddr.bmdma_addr = mmio_base + bmdma_offset[i];\r\nata_port_pbar_desc(ap, PDC_MMIO_BAR, -1, "mmio");\r\nata_port_pbar_desc(ap, PDC_MMIO_BAR, cmd_offset[i], "cmd");\r\n}\r\nif (pdc_hardware_init(host, board_idx) != 0)\r\nreturn -EIO;\r\npci_set_master(pdev);\r\nreturn ata_host_activate(host, pdev->irq, ata_bmdma_interrupt,\r\nIRQF_SHARED, &pdc2027x_sht);\r\n}\r\nstatic int pdc2027x_reinit_one(struct pci_dev *pdev)\r\n{\r\nstruct ata_host *host = dev_get_drvdata(&pdev->dev);\r\nunsigned int board_idx;\r\nint rc;\r\nrc = ata_pci_device_do_resume(pdev);\r\nif (rc)\r\nreturn rc;\r\nif (pdev->device == PCI_DEVICE_ID_PROMISE_20268 ||\r\npdev->device == PCI_DEVICE_ID_PROMISE_20270)\r\nboard_idx = PDC_UDMA_100;\r\nelse\r\nboard_idx = PDC_UDMA_133;\r\nif (pdc_hardware_init(host, board_idx))\r\nreturn -EIO;\r\nata_host_resume(host);\r\nreturn 0;\r\n}
