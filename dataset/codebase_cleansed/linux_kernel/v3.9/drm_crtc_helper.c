void drm_helper_move_panel_connectors_to_head(struct drm_device *dev)\r\n{\r\nstruct drm_connector *connector, *tmp;\r\nstruct list_head panel_list;\r\nINIT_LIST_HEAD(&panel_list);\r\nlist_for_each_entry_safe(connector, tmp,\r\n&dev->mode_config.connector_list, head) {\r\nif (connector->connector_type == DRM_MODE_CONNECTOR_LVDS ||\r\nconnector->connector_type == DRM_MODE_CONNECTOR_eDP)\r\nlist_move_tail(&connector->head, &panel_list);\r\n}\r\nlist_splice(&panel_list, &dev->mode_config.connector_list);\r\n}\r\nstatic void drm_mode_validate_flag(struct drm_connector *connector,\r\nint flags)\r\n{\r\nstruct drm_display_mode *mode;\r\nif (flags == (DRM_MODE_FLAG_DBLSCAN | DRM_MODE_FLAG_INTERLACE))\r\nreturn;\r\nlist_for_each_entry(mode, &connector->modes, head) {\r\nif ((mode->flags & DRM_MODE_FLAG_INTERLACE) &&\r\n!(flags & DRM_MODE_FLAG_INTERLACE))\r\nmode->status = MODE_NO_INTERLACE;\r\nif ((mode->flags & DRM_MODE_FLAG_DBLSCAN) &&\r\n!(flags & DRM_MODE_FLAG_DBLSCAN))\r\nmode->status = MODE_NO_DBLESCAN;\r\n}\r\nreturn;\r\n}\r\nint drm_helper_probe_single_connector_modes(struct drm_connector *connector,\r\nuint32_t maxX, uint32_t maxY)\r\n{\r\nstruct drm_device *dev = connector->dev;\r\nstruct drm_display_mode *mode;\r\nstruct drm_connector_helper_funcs *connector_funcs =\r\nconnector->helper_private;\r\nint count = 0;\r\nint mode_flags = 0;\r\nDRM_DEBUG_KMS("[CONNECTOR:%d:%s]\n", connector->base.id,\r\ndrm_get_connector_name(connector));\r\nlist_for_each_entry(mode, &connector->modes, head)\r\nmode->status = MODE_UNVERIFIED;\r\nif (connector->force) {\r\nif (connector->force == DRM_FORCE_ON)\r\nconnector->status = connector_status_connected;\r\nelse\r\nconnector->status = connector_status_disconnected;\r\nif (connector->funcs->force)\r\nconnector->funcs->force(connector);\r\n} else {\r\nconnector->status = connector->funcs->detect(connector, true);\r\n}\r\nif (drm_kms_helper_poll != dev->mode_config.poll_running)\r\ndrm_kms_helper_poll_enable(dev);\r\ndev->mode_config.poll_running = drm_kms_helper_poll;\r\nif (connector->status == connector_status_disconnected) {\r\nDRM_DEBUG_KMS("[CONNECTOR:%d:%s] disconnected\n",\r\nconnector->base.id, drm_get_connector_name(connector));\r\ndrm_mode_connector_update_edid_property(connector, NULL);\r\ngoto prune;\r\n}\r\n#ifdef CONFIG_DRM_LOAD_EDID_FIRMWARE\r\ncount = drm_load_edid_firmware(connector);\r\nif (count == 0)\r\n#endif\r\ncount = (*connector_funcs->get_modes)(connector);\r\nif (count == 0 && connector->status == connector_status_connected)\r\ncount = drm_add_modes_noedid(connector, 1024, 768);\r\nif (count == 0)\r\ngoto prune;\r\ndrm_mode_connector_list_update(connector);\r\nif (maxX && maxY)\r\ndrm_mode_validate_size(dev, &connector->modes, maxX,\r\nmaxY, 0);\r\nif (connector->interlace_allowed)\r\nmode_flags |= DRM_MODE_FLAG_INTERLACE;\r\nif (connector->doublescan_allowed)\r\nmode_flags |= DRM_MODE_FLAG_DBLSCAN;\r\ndrm_mode_validate_flag(connector, mode_flags);\r\nlist_for_each_entry(mode, &connector->modes, head) {\r\nif (mode->status == MODE_OK)\r\nmode->status = connector_funcs->mode_valid(connector,\r\nmode);\r\n}\r\nprune:\r\ndrm_mode_prune_invalid(dev, &connector->modes, true);\r\nif (list_empty(&connector->modes))\r\nreturn 0;\r\ndrm_mode_sort(&connector->modes);\r\nDRM_DEBUG_KMS("[CONNECTOR:%d:%s] probed modes :\n", connector->base.id,\r\ndrm_get_connector_name(connector));\r\nlist_for_each_entry(mode, &connector->modes, head) {\r\nmode->vrefresh = drm_mode_vrefresh(mode);\r\ndrm_mode_set_crtcinfo(mode, CRTC_INTERLACE_HALVE_V);\r\ndrm_mode_debug_printmodeline(mode);\r\n}\r\nreturn count;\r\n}\r\nbool drm_helper_encoder_in_use(struct drm_encoder *encoder)\r\n{\r\nstruct drm_connector *connector;\r\nstruct drm_device *dev = encoder->dev;\r\nlist_for_each_entry(connector, &dev->mode_config.connector_list, head)\r\nif (connector->encoder == encoder)\r\nreturn true;\r\nreturn false;\r\n}\r\nbool drm_helper_crtc_in_use(struct drm_crtc *crtc)\r\n{\r\nstruct drm_encoder *encoder;\r\nstruct drm_device *dev = crtc->dev;\r\nlist_for_each_entry(encoder, &dev->mode_config.encoder_list, head)\r\nif (encoder->crtc == crtc && drm_helper_encoder_in_use(encoder))\r\nreturn true;\r\nreturn false;\r\n}\r\nstatic void\r\ndrm_encoder_disable(struct drm_encoder *encoder)\r\n{\r\nstruct drm_encoder_helper_funcs *encoder_funcs = encoder->helper_private;\r\nif (encoder_funcs->disable)\r\n(*encoder_funcs->disable)(encoder);\r\nelse\r\n(*encoder_funcs->dpms)(encoder, DRM_MODE_DPMS_OFF);\r\n}\r\nvoid drm_helper_disable_unused_functions(struct drm_device *dev)\r\n{\r\nstruct drm_encoder *encoder;\r\nstruct drm_connector *connector;\r\nstruct drm_crtc *crtc;\r\nlist_for_each_entry(connector, &dev->mode_config.connector_list, head) {\r\nif (!connector->encoder)\r\ncontinue;\r\nif (connector->status == connector_status_disconnected)\r\nconnector->encoder = NULL;\r\n}\r\nlist_for_each_entry(encoder, &dev->mode_config.encoder_list, head) {\r\nif (!drm_helper_encoder_in_use(encoder)) {\r\ndrm_encoder_disable(encoder);\r\nencoder->crtc = NULL;\r\n}\r\n}\r\nlist_for_each_entry(crtc, &dev->mode_config.crtc_list, head) {\r\nstruct drm_crtc_helper_funcs *crtc_funcs = crtc->helper_private;\r\ncrtc->enabled = drm_helper_crtc_in_use(crtc);\r\nif (!crtc->enabled) {\r\nif (crtc_funcs->disable)\r\n(*crtc_funcs->disable)(crtc);\r\nelse\r\n(*crtc_funcs->dpms)(crtc, DRM_MODE_DPMS_OFF);\r\ncrtc->fb = NULL;\r\n}\r\n}\r\n}\r\nstatic bool drm_encoder_crtc_ok(struct drm_encoder *encoder,\r\nstruct drm_crtc *crtc)\r\n{\r\nstruct drm_device *dev;\r\nstruct drm_crtc *tmp;\r\nint crtc_mask = 1;\r\nWARN(!crtc, "checking null crtc?\n");\r\ndev = crtc->dev;\r\nlist_for_each_entry(tmp, &dev->mode_config.crtc_list, head) {\r\nif (tmp == crtc)\r\nbreak;\r\ncrtc_mask <<= 1;\r\n}\r\nif (encoder->possible_crtcs & crtc_mask)\r\nreturn true;\r\nreturn false;\r\n}\r\nstatic void\r\ndrm_crtc_prepare_encoders(struct drm_device *dev)\r\n{\r\nstruct drm_encoder_helper_funcs *encoder_funcs;\r\nstruct drm_encoder *encoder;\r\nlist_for_each_entry(encoder, &dev->mode_config.encoder_list, head) {\r\nencoder_funcs = encoder->helper_private;\r\nif (encoder->crtc == NULL)\r\ndrm_encoder_disable(encoder);\r\nif (encoder_funcs->get_crtc &&\r\nencoder->crtc != (*encoder_funcs->get_crtc)(encoder))\r\ndrm_encoder_disable(encoder);\r\n}\r\n}\r\nbool drm_crtc_helper_set_mode(struct drm_crtc *crtc,\r\nstruct drm_display_mode *mode,\r\nint x, int y,\r\nstruct drm_framebuffer *old_fb)\r\n{\r\nstruct drm_device *dev = crtc->dev;\r\nstruct drm_display_mode *adjusted_mode, saved_mode, saved_hwmode;\r\nstruct drm_crtc_helper_funcs *crtc_funcs = crtc->helper_private;\r\nstruct drm_encoder_helper_funcs *encoder_funcs;\r\nint saved_x, saved_y;\r\nstruct drm_encoder *encoder;\r\nbool ret = true;\r\ncrtc->enabled = drm_helper_crtc_in_use(crtc);\r\nif (!crtc->enabled)\r\nreturn true;\r\nadjusted_mode = drm_mode_duplicate(dev, mode);\r\nif (!adjusted_mode)\r\nreturn false;\r\nsaved_hwmode = crtc->hwmode;\r\nsaved_mode = crtc->mode;\r\nsaved_x = crtc->x;\r\nsaved_y = crtc->y;\r\ncrtc->mode = *mode;\r\ncrtc->x = x;\r\ncrtc->y = y;\r\nlist_for_each_entry(encoder, &dev->mode_config.encoder_list, head) {\r\nif (encoder->crtc != crtc)\r\ncontinue;\r\nencoder_funcs = encoder->helper_private;\r\nif (!(ret = encoder_funcs->mode_fixup(encoder, mode,\r\nadjusted_mode))) {\r\nDRM_DEBUG_KMS("Encoder fixup failed\n");\r\ngoto done;\r\n}\r\n}\r\nif (!(ret = crtc_funcs->mode_fixup(crtc, mode, adjusted_mode))) {\r\nDRM_DEBUG_KMS("CRTC fixup failed\n");\r\ngoto done;\r\n}\r\nDRM_DEBUG_KMS("[CRTC:%d]\n", crtc->base.id);\r\nlist_for_each_entry(encoder, &dev->mode_config.encoder_list, head) {\r\nif (encoder->crtc != crtc)\r\ncontinue;\r\nencoder_funcs = encoder->helper_private;\r\nencoder_funcs->prepare(encoder);\r\n}\r\ndrm_crtc_prepare_encoders(dev);\r\ncrtc_funcs->prepare(crtc);\r\nret = !crtc_funcs->mode_set(crtc, mode, adjusted_mode, x, y, old_fb);\r\nif (!ret)\r\ngoto done;\r\nlist_for_each_entry(encoder, &dev->mode_config.encoder_list, head) {\r\nif (encoder->crtc != crtc)\r\ncontinue;\r\nDRM_DEBUG_KMS("[ENCODER:%d:%s] set [MODE:%d:%s]\n",\r\nencoder->base.id, drm_get_encoder_name(encoder),\r\nmode->base.id, mode->name);\r\nencoder_funcs = encoder->helper_private;\r\nencoder_funcs->mode_set(encoder, mode, adjusted_mode);\r\n}\r\ncrtc_funcs->commit(crtc);\r\nlist_for_each_entry(encoder, &dev->mode_config.encoder_list, head) {\r\nif (encoder->crtc != crtc)\r\ncontinue;\r\nencoder_funcs = encoder->helper_private;\r\nencoder_funcs->commit(encoder);\r\n}\r\ncrtc->hwmode = *adjusted_mode;\r\ndrm_calc_timestamping_constants(crtc);\r\ndone:\r\ndrm_mode_destroy(dev, adjusted_mode);\r\nif (!ret) {\r\ncrtc->hwmode = saved_hwmode;\r\ncrtc->mode = saved_mode;\r\ncrtc->x = saved_x;\r\ncrtc->y = saved_y;\r\n}\r\nreturn ret;\r\n}\r\nstatic int\r\ndrm_crtc_helper_disable(struct drm_crtc *crtc)\r\n{\r\nstruct drm_device *dev = crtc->dev;\r\nstruct drm_connector *connector;\r\nstruct drm_encoder *encoder;\r\nlist_for_each_entry(encoder, &dev->mode_config.encoder_list, head) {\r\nif (encoder->crtc != crtc)\r\ncontinue;\r\nlist_for_each_entry(connector, &dev->mode_config.connector_list, head) {\r\nif (connector->encoder != encoder)\r\ncontinue;\r\nconnector->encoder = NULL;\r\n}\r\n}\r\ndrm_helper_disable_unused_functions(dev);\r\nreturn 0;\r\n}\r\nint drm_crtc_helper_set_config(struct drm_mode_set *set)\r\n{\r\nstruct drm_device *dev;\r\nstruct drm_crtc *save_crtcs, *new_crtc, *crtc;\r\nstruct drm_encoder *save_encoders, *new_encoder, *encoder;\r\nstruct drm_framebuffer *old_fb = NULL;\r\nbool mode_changed = false;\r\nbool fb_changed = false;\r\nstruct drm_connector *save_connectors, *connector;\r\nint count = 0, ro, fail = 0;\r\nstruct drm_crtc_helper_funcs *crtc_funcs;\r\nstruct drm_mode_set save_set;\r\nint ret;\r\nint i;\r\nDRM_DEBUG_KMS("\n");\r\nif (!set)\r\nreturn -EINVAL;\r\nif (!set->crtc)\r\nreturn -EINVAL;\r\nif (!set->crtc->helper_private)\r\nreturn -EINVAL;\r\ncrtc_funcs = set->crtc->helper_private;\r\nif (!set->mode)\r\nset->fb = NULL;\r\nif (set->fb) {\r\nDRM_DEBUG_KMS("[CRTC:%d] [FB:%d] #connectors=%d (x y) (%i %i)\n",\r\nset->crtc->base.id, set->fb->base.id,\r\n(int)set->num_connectors, set->x, set->y);\r\n} else {\r\nDRM_DEBUG_KMS("[CRTC:%d] [NOFB]\n", set->crtc->base.id);\r\nreturn drm_crtc_helper_disable(set->crtc);\r\n}\r\ndev = set->crtc->dev;\r\nsave_crtcs = kzalloc(dev->mode_config.num_crtc *\r\nsizeof(struct drm_crtc), GFP_KERNEL);\r\nif (!save_crtcs)\r\nreturn -ENOMEM;\r\nsave_encoders = kzalloc(dev->mode_config.num_encoder *\r\nsizeof(struct drm_encoder), GFP_KERNEL);\r\nif (!save_encoders) {\r\nkfree(save_crtcs);\r\nreturn -ENOMEM;\r\n}\r\nsave_connectors = kzalloc(dev->mode_config.num_connector *\r\nsizeof(struct drm_connector), GFP_KERNEL);\r\nif (!save_connectors) {\r\nkfree(save_crtcs);\r\nkfree(save_encoders);\r\nreturn -ENOMEM;\r\n}\r\ncount = 0;\r\nlist_for_each_entry(crtc, &dev->mode_config.crtc_list, head) {\r\nsave_crtcs[count++] = *crtc;\r\n}\r\ncount = 0;\r\nlist_for_each_entry(encoder, &dev->mode_config.encoder_list, head) {\r\nsave_encoders[count++] = *encoder;\r\n}\r\ncount = 0;\r\nlist_for_each_entry(connector, &dev->mode_config.connector_list, head) {\r\nsave_connectors[count++] = *connector;\r\n}\r\nsave_set.crtc = set->crtc;\r\nsave_set.mode = &set->crtc->mode;\r\nsave_set.x = set->crtc->x;\r\nsave_set.y = set->crtc->y;\r\nsave_set.fb = set->crtc->fb;\r\nif (set->crtc->fb != set->fb) {\r\nif (set->crtc->fb == NULL) {\r\nDRM_DEBUG_KMS("crtc has no fb, full mode set\n");\r\nmode_changed = true;\r\n} else if (set->fb == NULL) {\r\nmode_changed = true;\r\n} else if (set->fb->depth != set->crtc->fb->depth) {\r\nmode_changed = true;\r\n} else if (set->fb->bits_per_pixel !=\r\nset->crtc->fb->bits_per_pixel) {\r\nmode_changed = true;\r\n} else\r\nfb_changed = true;\r\n}\r\nif (set->x != set->crtc->x || set->y != set->crtc->y)\r\nfb_changed = true;\r\nif (set->mode && !drm_mode_equal(set->mode, &set->crtc->mode)) {\r\nDRM_DEBUG_KMS("modes are different, full mode set\n");\r\ndrm_mode_debug_printmodeline(&set->crtc->mode);\r\ndrm_mode_debug_printmodeline(set->mode);\r\nmode_changed = true;\r\n}\r\ncount = 0;\r\nlist_for_each_entry(connector, &dev->mode_config.connector_list, head) {\r\nstruct drm_connector_helper_funcs *connector_funcs =\r\nconnector->helper_private;\r\nnew_encoder = connector->encoder;\r\nfor (ro = 0; ro < set->num_connectors; ro++) {\r\nif (set->connectors[ro] == connector) {\r\nnew_encoder = connector_funcs->best_encoder(connector);\r\nif (new_encoder == NULL)\r\nfail = 1;\r\nbreak;\r\n}\r\n}\r\nif (new_encoder != connector->encoder) {\r\nDRM_DEBUG_KMS("encoder changed, full mode switch\n");\r\nmode_changed = true;\r\nif (connector->encoder)\r\nconnector->encoder->crtc = NULL;\r\nconnector->encoder = new_encoder;\r\n}\r\n}\r\nif (fail) {\r\nret = -EINVAL;\r\ngoto fail;\r\n}\r\ncount = 0;\r\nlist_for_each_entry(connector, &dev->mode_config.connector_list, head) {\r\nif (!connector->encoder)\r\ncontinue;\r\nif (connector->encoder->crtc == set->crtc)\r\nnew_crtc = NULL;\r\nelse\r\nnew_crtc = connector->encoder->crtc;\r\nfor (ro = 0; ro < set->num_connectors; ro++) {\r\nif (set->connectors[ro] == connector)\r\nnew_crtc = set->crtc;\r\n}\r\nif (new_crtc &&\r\n!drm_encoder_crtc_ok(connector->encoder, new_crtc)) {\r\nret = -EINVAL;\r\ngoto fail;\r\n}\r\nif (new_crtc != connector->encoder->crtc) {\r\nDRM_DEBUG_KMS("crtc changed, full mode switch\n");\r\nmode_changed = true;\r\nconnector->encoder->crtc = new_crtc;\r\n}\r\nif (new_crtc) {\r\nDRM_DEBUG_KMS("[CONNECTOR:%d:%s] to [CRTC:%d]\n",\r\nconnector->base.id, drm_get_connector_name(connector),\r\nnew_crtc->base.id);\r\n} else {\r\nDRM_DEBUG_KMS("[CONNECTOR:%d:%s] to [NOCRTC]\n",\r\nconnector->base.id, drm_get_connector_name(connector));\r\n}\r\n}\r\nif (fb_changed && !crtc_funcs->mode_set_base)\r\nmode_changed = true;\r\nif (mode_changed) {\r\nset->crtc->enabled = drm_helper_crtc_in_use(set->crtc);\r\nif (set->crtc->enabled) {\r\nDRM_DEBUG_KMS("attempting to set mode from"\r\n" userspace\n");\r\ndrm_mode_debug_printmodeline(set->mode);\r\nold_fb = set->crtc->fb;\r\nset->crtc->fb = set->fb;\r\nif (!drm_crtc_helper_set_mode(set->crtc, set->mode,\r\nset->x, set->y,\r\nold_fb)) {\r\nDRM_ERROR("failed to set mode on [CRTC:%d]\n",\r\nset->crtc->base.id);\r\nset->crtc->fb = old_fb;\r\nret = -EINVAL;\r\ngoto fail;\r\n}\r\nDRM_DEBUG_KMS("Setting connector DPMS state to on\n");\r\nfor (i = 0; i < set->num_connectors; i++) {\r\nDRM_DEBUG_KMS("\t[CONNECTOR:%d:%s] set DPMS on\n", set->connectors[i]->base.id,\r\ndrm_get_connector_name(set->connectors[i]));\r\nset->connectors[i]->funcs->dpms(set->connectors[i], DRM_MODE_DPMS_ON);\r\n}\r\n}\r\ndrm_helper_disable_unused_functions(dev);\r\n} else if (fb_changed) {\r\nset->crtc->x = set->x;\r\nset->crtc->y = set->y;\r\nold_fb = set->crtc->fb;\r\nif (set->crtc->fb != set->fb)\r\nset->crtc->fb = set->fb;\r\nret = crtc_funcs->mode_set_base(set->crtc,\r\nset->x, set->y, old_fb);\r\nif (ret != 0) {\r\nset->crtc->fb = old_fb;\r\ngoto fail;\r\n}\r\n}\r\nkfree(save_connectors);\r\nkfree(save_encoders);\r\nkfree(save_crtcs);\r\nreturn 0;\r\nfail:\r\ncount = 0;\r\nlist_for_each_entry(crtc, &dev->mode_config.crtc_list, head) {\r\n*crtc = save_crtcs[count++];\r\n}\r\ncount = 0;\r\nlist_for_each_entry(encoder, &dev->mode_config.encoder_list, head) {\r\n*encoder = save_encoders[count++];\r\n}\r\ncount = 0;\r\nlist_for_each_entry(connector, &dev->mode_config.connector_list, head) {\r\n*connector = save_connectors[count++];\r\n}\r\nif (mode_changed &&\r\n!drm_crtc_helper_set_mode(save_set.crtc, save_set.mode, save_set.x,\r\nsave_set.y, save_set.fb))\r\nDRM_ERROR("failed to restore config after modeset failure\n");\r\nkfree(save_connectors);\r\nkfree(save_encoders);\r\nkfree(save_crtcs);\r\nreturn ret;\r\n}\r\nstatic int drm_helper_choose_encoder_dpms(struct drm_encoder *encoder)\r\n{\r\nint dpms = DRM_MODE_DPMS_OFF;\r\nstruct drm_connector *connector;\r\nstruct drm_device *dev = encoder->dev;\r\nlist_for_each_entry(connector, &dev->mode_config.connector_list, head)\r\nif (connector->encoder == encoder)\r\nif (connector->dpms < dpms)\r\ndpms = connector->dpms;\r\nreturn dpms;\r\n}\r\nstatic int drm_helper_choose_crtc_dpms(struct drm_crtc *crtc)\r\n{\r\nint dpms = DRM_MODE_DPMS_OFF;\r\nstruct drm_connector *connector;\r\nstruct drm_device *dev = crtc->dev;\r\nlist_for_each_entry(connector, &dev->mode_config.connector_list, head)\r\nif (connector->encoder && connector->encoder->crtc == crtc)\r\nif (connector->dpms < dpms)\r\ndpms = connector->dpms;\r\nreturn dpms;\r\n}\r\nvoid drm_helper_connector_dpms(struct drm_connector *connector, int mode)\r\n{\r\nstruct drm_encoder *encoder = connector->encoder;\r\nstruct drm_crtc *crtc = encoder ? encoder->crtc : NULL;\r\nint old_dpms;\r\nif (mode == connector->dpms)\r\nreturn;\r\nold_dpms = connector->dpms;\r\nconnector->dpms = mode;\r\nif (mode < old_dpms) {\r\nif (crtc) {\r\nstruct drm_crtc_helper_funcs *crtc_funcs = crtc->helper_private;\r\nif (crtc_funcs->dpms)\r\n(*crtc_funcs->dpms) (crtc,\r\ndrm_helper_choose_crtc_dpms(crtc));\r\n}\r\nif (encoder) {\r\nstruct drm_encoder_helper_funcs *encoder_funcs = encoder->helper_private;\r\nif (encoder_funcs->dpms)\r\n(*encoder_funcs->dpms) (encoder,\r\ndrm_helper_choose_encoder_dpms(encoder));\r\n}\r\n}\r\nif (mode > old_dpms) {\r\nif (encoder) {\r\nstruct drm_encoder_helper_funcs *encoder_funcs = encoder->helper_private;\r\nif (encoder_funcs->dpms)\r\n(*encoder_funcs->dpms) (encoder,\r\ndrm_helper_choose_encoder_dpms(encoder));\r\n}\r\nif (crtc) {\r\nstruct drm_crtc_helper_funcs *crtc_funcs = crtc->helper_private;\r\nif (crtc_funcs->dpms)\r\n(*crtc_funcs->dpms) (crtc,\r\ndrm_helper_choose_crtc_dpms(crtc));\r\n}\r\n}\r\nreturn;\r\n}\r\nint drm_helper_mode_fill_fb_struct(struct drm_framebuffer *fb,\r\nstruct drm_mode_fb_cmd2 *mode_cmd)\r\n{\r\nint i;\r\nfb->width = mode_cmd->width;\r\nfb->height = mode_cmd->height;\r\nfor (i = 0; i < 4; i++) {\r\nfb->pitches[i] = mode_cmd->pitches[i];\r\nfb->offsets[i] = mode_cmd->offsets[i];\r\n}\r\ndrm_fb_get_bpp_depth(mode_cmd->pixel_format, &fb->depth,\r\n&fb->bits_per_pixel);\r\nfb->pixel_format = mode_cmd->pixel_format;\r\nreturn 0;\r\n}\r\nint drm_helper_resume_force_mode(struct drm_device *dev)\r\n{\r\nstruct drm_crtc *crtc;\r\nstruct drm_encoder *encoder;\r\nstruct drm_encoder_helper_funcs *encoder_funcs;\r\nstruct drm_crtc_helper_funcs *crtc_funcs;\r\nint ret;\r\nlist_for_each_entry(crtc, &dev->mode_config.crtc_list, head) {\r\nif (!crtc->enabled)\r\ncontinue;\r\nret = drm_crtc_helper_set_mode(crtc, &crtc->mode,\r\ncrtc->x, crtc->y, crtc->fb);\r\nif (ret == false)\r\nDRM_ERROR("failed to set mode on crtc %p\n", crtc);\r\nif (drm_helper_choose_crtc_dpms(crtc)) {\r\nlist_for_each_entry(encoder, &dev->mode_config.encoder_list, head) {\r\nif(encoder->crtc != crtc)\r\ncontinue;\r\nencoder_funcs = encoder->helper_private;\r\nif (encoder_funcs->dpms)\r\n(*encoder_funcs->dpms) (encoder,\r\ndrm_helper_choose_encoder_dpms(encoder));\r\n}\r\ncrtc_funcs = crtc->helper_private;\r\nif (crtc_funcs->dpms)\r\n(*crtc_funcs->dpms) (crtc,\r\ndrm_helper_choose_crtc_dpms(crtc));\r\n}\r\n}\r\ndrm_helper_disable_unused_functions(dev);\r\nreturn 0;\r\n}\r\nvoid drm_kms_helper_hotplug_event(struct drm_device *dev)\r\n{\r\ndrm_sysfs_hotplug_event(dev);\r\nif (dev->mode_config.funcs->output_poll_changed)\r\ndev->mode_config.funcs->output_poll_changed(dev);\r\n}\r\nstatic void output_poll_execute(struct work_struct *work)\r\n{\r\nstruct delayed_work *delayed_work = to_delayed_work(work);\r\nstruct drm_device *dev = container_of(delayed_work, struct drm_device, mode_config.output_poll_work);\r\nstruct drm_connector *connector;\r\nenum drm_connector_status old_status;\r\nbool repoll = false, changed = false;\r\nif (!drm_kms_helper_poll)\r\nreturn;\r\nmutex_lock(&dev->mode_config.mutex);\r\nlist_for_each_entry(connector, &dev->mode_config.connector_list, head) {\r\nif (connector->force)\r\ncontinue;\r\nif (!connector->polled || connector->polled == DRM_CONNECTOR_POLL_HPD)\r\ncontinue;\r\nrepoll = true;\r\nold_status = connector->status;\r\nif (old_status == connector_status_connected &&\r\n!(connector->polled & DRM_CONNECTOR_POLL_DISCONNECT))\r\ncontinue;\r\nconnector->status = connector->funcs->detect(connector, false);\r\nDRM_DEBUG_KMS("[CONNECTOR:%d:%s] status updated from %d to %d\n",\r\nconnector->base.id,\r\ndrm_get_connector_name(connector),\r\nold_status, connector->status);\r\nif (old_status != connector->status)\r\nchanged = true;\r\n}\r\nmutex_unlock(&dev->mode_config.mutex);\r\nif (changed)\r\ndrm_kms_helper_hotplug_event(dev);\r\nif (repoll)\r\nschedule_delayed_work(delayed_work, DRM_OUTPUT_POLL_PERIOD);\r\n}\r\nvoid drm_kms_helper_poll_disable(struct drm_device *dev)\r\n{\r\nif (!dev->mode_config.poll_enabled)\r\nreturn;\r\ncancel_delayed_work_sync(&dev->mode_config.output_poll_work);\r\n}\r\nvoid drm_kms_helper_poll_enable(struct drm_device *dev)\r\n{\r\nbool poll = false;\r\nstruct drm_connector *connector;\r\nif (!dev->mode_config.poll_enabled || !drm_kms_helper_poll)\r\nreturn;\r\nlist_for_each_entry(connector, &dev->mode_config.connector_list, head) {\r\nif (connector->polled & (DRM_CONNECTOR_POLL_CONNECT |\r\nDRM_CONNECTOR_POLL_DISCONNECT))\r\npoll = true;\r\n}\r\nif (poll)\r\nschedule_delayed_work(&dev->mode_config.output_poll_work, DRM_OUTPUT_POLL_PERIOD);\r\n}\r\nvoid drm_kms_helper_poll_init(struct drm_device *dev)\r\n{\r\nINIT_DELAYED_WORK(&dev->mode_config.output_poll_work, output_poll_execute);\r\ndev->mode_config.poll_enabled = true;\r\ndrm_kms_helper_poll_enable(dev);\r\n}\r\nvoid drm_kms_helper_poll_fini(struct drm_device *dev)\r\n{\r\ndrm_kms_helper_poll_disable(dev);\r\n}\r\nvoid drm_helper_hpd_irq_event(struct drm_device *dev)\r\n{\r\nstruct drm_connector *connector;\r\nenum drm_connector_status old_status;\r\nbool changed = false;\r\nif (!dev->mode_config.poll_enabled)\r\nreturn;\r\nmutex_lock(&dev->mode_config.mutex);\r\nlist_for_each_entry(connector, &dev->mode_config.connector_list, head) {\r\nif (!(connector->polled & DRM_CONNECTOR_POLL_HPD))\r\ncontinue;\r\nold_status = connector->status;\r\nconnector->status = connector->funcs->detect(connector, false);\r\nDRM_DEBUG_KMS("[CONNECTOR:%d:%s] status updated from %d to %d\n",\r\nconnector->base.id,\r\ndrm_get_connector_name(connector),\r\nold_status, connector->status);\r\nif (old_status != connector->status)\r\nchanged = true;\r\n}\r\nmutex_unlock(&dev->mode_config.mutex);\r\nif (changed)\r\ndrm_kms_helper_hotplug_event(dev);\r\n}
