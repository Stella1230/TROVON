void __init early_init_dt_add_memory_arch(u64 base, u64 size)\r\n{\r\narm_add_memory(base, size);\r\n}\r\nvoid * __init early_init_dt_alloc_memory_arch(u64 size, u64 align)\r\n{\r\nreturn alloc_bootmem_align(size, align);\r\n}\r\nvoid __init arm_dt_memblock_reserve(void)\r\n{\r\nu64 *reserve_map, base, size;\r\nif (!initial_boot_params)\r\nreturn;\r\nmemblock_reserve(virt_to_phys(initial_boot_params),\r\nbe32_to_cpu(initial_boot_params->totalsize));\r\nreserve_map = ((void*)initial_boot_params) +\r\nbe32_to_cpu(initial_boot_params->off_mem_rsvmap);\r\nwhile (1) {\r\nbase = be64_to_cpup(reserve_map++);\r\nsize = be64_to_cpup(reserve_map++);\r\nif (!size)\r\nbreak;\r\nmemblock_reserve(base, size);\r\n}\r\n}\r\nvoid __init arm_dt_init_cpu_maps(void)\r\n{\r\nstruct device_node *cpu, *cpus;\r\nu32 i, j, cpuidx = 1;\r\nu32 mpidr = is_smp() ? read_cpuid_mpidr() & MPIDR_HWID_BITMASK : 0;\r\nu32 tmp_map[NR_CPUS] = { [0 ... NR_CPUS-1] = UINT_MAX };\r\nbool bootcpu_valid = false;\r\ncpus = of_find_node_by_path("/cpus");\r\nif (!cpus)\r\nreturn;\r\nfor_each_child_of_node(cpus, cpu) {\r\nu32 hwid;\r\npr_debug(" * %s...\n", cpu->full_name);\r\nif (of_property_read_u32(cpu, "reg", &hwid)) {\r\npr_debug(" * %s missing reg property\n",\r\ncpu->full_name);\r\nreturn;\r\n}\r\nif (hwid & ~MPIDR_HWID_BITMASK)\r\nreturn;\r\nfor (j = 0; j < cpuidx; j++)\r\nif (WARN(tmp_map[j] == hwid, "Duplicate /cpu reg "\r\n"properties in the DT\n"))\r\nreturn;\r\nif (hwid == mpidr) {\r\ni = 0;\r\nbootcpu_valid = true;\r\n} else {\r\ni = cpuidx++;\r\n}\r\nif (WARN(cpuidx > nr_cpu_ids, "DT /cpu %u nodes greater than "\r\n"max cores %u, capping them\n",\r\ncpuidx, nr_cpu_ids)) {\r\ncpuidx = nr_cpu_ids;\r\nbreak;\r\n}\r\ntmp_map[i] = hwid;\r\n}\r\nif (WARN(!bootcpu_valid, "DT missing boot CPU MPIDR[23:0], "\r\n"fall back to default cpu_logical_map\n"))\r\nreturn;\r\nfor (i = 0; i < cpuidx; i++) {\r\nset_cpu_possible(i, true);\r\ncpu_logical_map(i) = tmp_map[i];\r\npr_debug("cpu logical map 0x%x\n", cpu_logical_map(i));\r\n}\r\n}\r\nstruct machine_desc * __init setup_machine_fdt(unsigned int dt_phys)\r\n{\r\nstruct boot_param_header *devtree;\r\nstruct machine_desc *mdesc, *mdesc_best = NULL;\r\nunsigned int score, mdesc_score = ~1;\r\nunsigned long dt_root;\r\nconst char *model;\r\nif (!dt_phys)\r\nreturn NULL;\r\ndevtree = phys_to_virt(dt_phys);\r\nif (be32_to_cpu(devtree->magic) != OF_DT_HEADER)\r\nreturn NULL;\r\ninitial_boot_params = devtree;\r\ndt_root = of_get_flat_dt_root();\r\nfor_each_machine_desc(mdesc) {\r\nscore = of_flat_dt_match(dt_root, mdesc->dt_compat);\r\nif (score > 0 && score < mdesc_score) {\r\nmdesc_best = mdesc;\r\nmdesc_score = score;\r\n}\r\n}\r\nif (!mdesc_best) {\r\nconst char *prop;\r\nlong size;\r\nearly_print("\nError: unrecognized/unsupported "\r\n"device tree compatible list:\n[ ");\r\nprop = of_get_flat_dt_prop(dt_root, "compatible", &size);\r\nwhile (size > 0) {\r\nearly_print("'%s' ", prop);\r\nsize -= strlen(prop) + 1;\r\nprop += strlen(prop) + 1;\r\n}\r\nearly_print("]\n\n");\r\ndump_machine_table();\r\n}\r\nmodel = of_get_flat_dt_prop(dt_root, "model", NULL);\r\nif (!model)\r\nmodel = of_get_flat_dt_prop(dt_root, "compatible", NULL);\r\nif (!model)\r\nmodel = "<unknown>";\r\npr_info("Machine: %s, model: %s\n", mdesc_best->name, model);\r\nof_scan_flat_dt(early_init_dt_scan_chosen, boot_command_line);\r\nof_scan_flat_dt(early_init_dt_scan_root, NULL);\r\nof_scan_flat_dt(early_init_dt_scan_memory, NULL);\r\n__machine_arch_type = mdesc_best->nr;\r\nreturn mdesc_best;\r\n}
