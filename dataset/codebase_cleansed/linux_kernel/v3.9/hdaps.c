static inline u8 __get_latch(u16 port)\r\n{\r\nreturn inb(port) & 0xff;\r\n}\r\nstatic inline int __check_latch(u16 port, u8 val)\r\n{\r\nif (__get_latch(port) == val)\r\nreturn 0;\r\nreturn -EINVAL;\r\n}\r\nstatic int __wait_latch(u16 port, u8 val)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < 20; i++) {\r\nif (!__check_latch(port, val))\r\nreturn 0;\r\nudelay(5);\r\n}\r\nreturn -EIO;\r\n}\r\nstatic void __device_refresh(void)\r\n{\r\nudelay(200);\r\nif (inb(0x1604) != STATE_FRESH) {\r\noutb(0x11, 0x1610);\r\noutb(0x01, 0x161f);\r\n}\r\n}\r\nstatic int __device_refresh_sync(void)\r\n{\r\n__device_refresh();\r\nreturn __wait_latch(0x1604, STATE_FRESH);\r\n}\r\nstatic inline void __device_complete(void)\r\n{\r\ninb(0x161f);\r\ninb(0x1604);\r\n__device_refresh();\r\n}\r\nstatic int hdaps_readb_one(unsigned int port, u8 *val)\r\n{\r\nint ret;\r\nmutex_lock(&hdaps_mtx);\r\nret = __device_refresh_sync();\r\nif (ret)\r\ngoto out;\r\n*val = inb(port);\r\n__device_complete();\r\nout:\r\nmutex_unlock(&hdaps_mtx);\r\nreturn ret;\r\n}\r\nstatic int __hdaps_read_pair(unsigned int port1, unsigned int port2,\r\nint *x, int *y)\r\n{\r\nif (__device_refresh_sync())\r\nreturn -EIO;\r\n*y = inw(port2);\r\n*x = inw(port1);\r\nkm_activity = inb(HDAPS_PORT_KMACT);\r\n__device_complete();\r\nif (hdaps_invert & HDAPS_X_AXIS)\r\n*x = -*x;\r\nif (hdaps_invert & HDAPS_Y_AXIS)\r\n*y = -*y;\r\nreturn 0;\r\n}\r\nstatic int hdaps_read_pair(unsigned int port1, unsigned int port2,\r\nint *val1, int *val2)\r\n{\r\nint ret;\r\nmutex_lock(&hdaps_mtx);\r\nret = __hdaps_read_pair(port1, port2, val1, val2);\r\nmutex_unlock(&hdaps_mtx);\r\nreturn ret;\r\n}\r\nstatic int hdaps_device_init(void)\r\n{\r\nint total, ret = -ENXIO;\r\nmutex_lock(&hdaps_mtx);\r\noutb(0x13, 0x1610);\r\noutb(0x01, 0x161f);\r\nif (__wait_latch(0x161f, 0x00))\r\ngoto out;\r\nif (__check_latch(0x1611, 0x03) &&\r\n__check_latch(0x1611, 0x02) &&\r\n__check_latch(0x1611, 0x01))\r\ngoto out;\r\nprintk(KERN_DEBUG "hdaps: initial latch check good (0x%02x)\n",\r\n__get_latch(0x1611));\r\noutb(0x17, 0x1610);\r\noutb(0x81, 0x1611);\r\noutb(0x01, 0x161f);\r\nif (__wait_latch(0x161f, 0x00))\r\ngoto out;\r\nif (__wait_latch(0x1611, 0x00))\r\ngoto out;\r\nif (__wait_latch(0x1612, 0x60))\r\ngoto out;\r\nif (__wait_latch(0x1613, 0x00))\r\ngoto out;\r\noutb(0x14, 0x1610);\r\noutb(0x01, 0x1611);\r\noutb(0x01, 0x161f);\r\nif (__wait_latch(0x161f, 0x00))\r\ngoto out;\r\noutb(0x10, 0x1610);\r\noutb(0xc8, 0x1611);\r\noutb(0x00, 0x1612);\r\noutb(0x02, 0x1613);\r\noutb(0x01, 0x161f);\r\nif (__wait_latch(0x161f, 0x00))\r\ngoto out;\r\nif (__device_refresh_sync())\r\ngoto out;\r\nif (__wait_latch(0x1611, 0x00))\r\ngoto out;\r\nfor (total = INIT_TIMEOUT_MSECS; total > 0; total -= INIT_WAIT_MSECS) {\r\nint x, y;\r\n__hdaps_read_pair(HDAPS_PORT_XPOS, HDAPS_PORT_YPOS, &x, &y);\r\nif (!__wait_latch(0x1611, 0x02)) {\r\nret = 0;\r\nbreak;\r\n}\r\nmsleep(INIT_WAIT_MSECS);\r\n}\r\nout:\r\nmutex_unlock(&hdaps_mtx);\r\nreturn ret;\r\n}\r\nstatic int hdaps_probe(struct platform_device *dev)\r\n{\r\nint ret;\r\nret = hdaps_device_init();\r\nif (ret)\r\nreturn ret;\r\npr_info("device successfully initialized\n");\r\nreturn 0;\r\n}\r\nstatic int hdaps_resume(struct device *dev)\r\n{\r\nreturn hdaps_device_init();\r\n}\r\nstatic void hdaps_calibrate(void)\r\n{\r\n__hdaps_read_pair(HDAPS_PORT_XPOS, HDAPS_PORT_YPOS, &rest_x, &rest_y);\r\n}\r\nstatic void hdaps_mousedev_poll(struct input_polled_dev *dev)\r\n{\r\nstruct input_dev *input_dev = dev->input;\r\nint x, y;\r\nmutex_lock(&hdaps_mtx);\r\nif (__hdaps_read_pair(HDAPS_PORT_XPOS, HDAPS_PORT_YPOS, &x, &y))\r\ngoto out;\r\ninput_report_abs(input_dev, ABS_X, x - rest_x);\r\ninput_report_abs(input_dev, ABS_Y, y - rest_y);\r\ninput_sync(input_dev);\r\nout:\r\nmutex_unlock(&hdaps_mtx);\r\n}\r\nstatic ssize_t hdaps_position_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nint ret, x, y;\r\nret = hdaps_read_pair(HDAPS_PORT_XPOS, HDAPS_PORT_YPOS, &x, &y);\r\nif (ret)\r\nreturn ret;\r\nreturn sprintf(buf, "(%d,%d)\n", x, y);\r\n}\r\nstatic ssize_t hdaps_variance_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nint ret, x, y;\r\nret = hdaps_read_pair(HDAPS_PORT_XVAR, HDAPS_PORT_YVAR, &x, &y);\r\nif (ret)\r\nreturn ret;\r\nreturn sprintf(buf, "(%d,%d)\n", x, y);\r\n}\r\nstatic ssize_t hdaps_temp1_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nu8 uninitialized_var(temp);\r\nint ret;\r\nret = hdaps_readb_one(HDAPS_PORT_TEMP1, &temp);\r\nif (ret)\r\nreturn ret;\r\nreturn sprintf(buf, "%u\n", temp);\r\n}\r\nstatic ssize_t hdaps_temp2_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nu8 uninitialized_var(temp);\r\nint ret;\r\nret = hdaps_readb_one(HDAPS_PORT_TEMP2, &temp);\r\nif (ret)\r\nreturn ret;\r\nreturn sprintf(buf, "%u\n", temp);\r\n}\r\nstatic ssize_t hdaps_keyboard_activity_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nreturn sprintf(buf, "%u\n", KEYBD_ISSET(km_activity));\r\n}\r\nstatic ssize_t hdaps_mouse_activity_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nreturn sprintf(buf, "%u\n", MOUSE_ISSET(km_activity));\r\n}\r\nstatic ssize_t hdaps_calibrate_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nreturn sprintf(buf, "(%d,%d)\n", rest_x, rest_y);\r\n}\r\nstatic ssize_t hdaps_calibrate_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nmutex_lock(&hdaps_mtx);\r\nhdaps_calibrate();\r\nmutex_unlock(&hdaps_mtx);\r\nreturn count;\r\n}\r\nstatic ssize_t hdaps_invert_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nreturn sprintf(buf, "%u\n", hdaps_invert);\r\n}\r\nstatic ssize_t hdaps_invert_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nint invert;\r\nif (sscanf(buf, "%d", &invert) != 1 ||\r\ninvert < 0 || invert > HDAPS_BOTH_AXES)\r\nreturn -EINVAL;\r\nhdaps_invert = invert;\r\nhdaps_calibrate();\r\nreturn count;\r\n}\r\nstatic int __init hdaps_dmi_match(const struct dmi_system_id *id)\r\n{\r\npr_info("%s detected\n", id->ident);\r\nreturn 1;\r\n}\r\nstatic int __init hdaps_dmi_match_invert(const struct dmi_system_id *id)\r\n{\r\nhdaps_invert = (unsigned long)id->driver_data;\r\npr_info("inverting axis (%u) readings\n", hdaps_invert);\r\nreturn hdaps_dmi_match(id);\r\n}\r\nstatic int __init hdaps_init(void)\r\n{\r\nstruct input_dev *idev;\r\nint ret;\r\nif (!dmi_check_system(hdaps_whitelist)) {\r\npr_warn("supported laptop not found!\n");\r\nret = -ENODEV;\r\ngoto out;\r\n}\r\nif (!request_region(HDAPS_LOW_PORT, HDAPS_NR_PORTS, "hdaps")) {\r\nret = -ENXIO;\r\ngoto out;\r\n}\r\nret = platform_driver_register(&hdaps_driver);\r\nif (ret)\r\ngoto out_region;\r\npdev = platform_device_register_simple("hdaps", -1, NULL, 0);\r\nif (IS_ERR(pdev)) {\r\nret = PTR_ERR(pdev);\r\ngoto out_driver;\r\n}\r\nret = sysfs_create_group(&pdev->dev.kobj, &hdaps_attribute_group);\r\nif (ret)\r\ngoto out_device;\r\nhdaps_idev = input_allocate_polled_device();\r\nif (!hdaps_idev) {\r\nret = -ENOMEM;\r\ngoto out_group;\r\n}\r\nhdaps_idev->poll = hdaps_mousedev_poll;\r\nhdaps_idev->poll_interval = HDAPS_POLL_INTERVAL;\r\nhdaps_calibrate();\r\nidev = hdaps_idev->input;\r\nidev->name = "hdaps";\r\nidev->phys = "isa1600/input0";\r\nidev->id.bustype = BUS_ISA;\r\nidev->dev.parent = &pdev->dev;\r\nidev->evbit[0] = BIT_MASK(EV_ABS);\r\ninput_set_abs_params(idev, ABS_X,\r\n-256, 256, HDAPS_INPUT_FUZZ, HDAPS_INPUT_FLAT);\r\ninput_set_abs_params(idev, ABS_Y,\r\n-256, 256, HDAPS_INPUT_FUZZ, HDAPS_INPUT_FLAT);\r\nret = input_register_polled_device(hdaps_idev);\r\nif (ret)\r\ngoto out_idev;\r\npr_info("driver successfully loaded\n");\r\nreturn 0;\r\nout_idev:\r\ninput_free_polled_device(hdaps_idev);\r\nout_group:\r\nsysfs_remove_group(&pdev->dev.kobj, &hdaps_attribute_group);\r\nout_device:\r\nplatform_device_unregister(pdev);\r\nout_driver:\r\nplatform_driver_unregister(&hdaps_driver);\r\nout_region:\r\nrelease_region(HDAPS_LOW_PORT, HDAPS_NR_PORTS);\r\nout:\r\npr_warn("driver init failed (ret=%d)!\n", ret);\r\nreturn ret;\r\n}\r\nstatic void __exit hdaps_exit(void)\r\n{\r\ninput_unregister_polled_device(hdaps_idev);\r\ninput_free_polled_device(hdaps_idev);\r\nsysfs_remove_group(&pdev->dev.kobj, &hdaps_attribute_group);\r\nplatform_device_unregister(pdev);\r\nplatform_driver_unregister(&hdaps_driver);\r\nrelease_region(HDAPS_LOW_PORT, HDAPS_NR_PORTS);\r\npr_info("driver unloaded\n");\r\n}
