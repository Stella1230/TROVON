int\r\ncsio_is_rnode_ready(struct csio_rnode *rn)\r\n{\r\nreturn csio_match_state(rn, csio_rns_ready);\r\n}\r\nstatic int\r\ncsio_is_rnode_uninit(struct csio_rnode *rn)\r\n{\r\nreturn csio_match_state(rn, csio_rns_uninit);\r\n}\r\nstatic int\r\ncsio_is_rnode_wka(uint8_t rport_type)\r\n{\r\nif ((rport_type == FLOGI_VFPORT) ||\r\n(rport_type == FDISC_VFPORT) ||\r\n(rport_type == NS_VNPORT) ||\r\n(rport_type == FDMI_VNPORT))\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic struct csio_rnode *\r\ncsio_rn_lookup(struct csio_lnode *ln, uint32_t flowid)\r\n{\r\nstruct csio_rnode *rnhead = (struct csio_rnode *) &ln->rnhead;\r\nstruct list_head *tmp;\r\nstruct csio_rnode *rn;\r\nlist_for_each(tmp, &rnhead->sm.sm_list) {\r\nrn = (struct csio_rnode *) tmp;\r\nif (rn->flowid == flowid)\r\nreturn rn;\r\n}\r\nreturn NULL;\r\n}\r\nstatic struct csio_rnode *\r\ncsio_rn_lookup_wwpn(struct csio_lnode *ln, uint8_t *wwpn)\r\n{\r\nstruct csio_rnode *rnhead = (struct csio_rnode *) &ln->rnhead;\r\nstruct list_head *tmp;\r\nstruct csio_rnode *rn;\r\nlist_for_each(tmp, &rnhead->sm.sm_list) {\r\nrn = (struct csio_rnode *) tmp;\r\nif (!memcmp(csio_rn_wwpn(rn), wwpn, 8))\r\nreturn rn;\r\n}\r\nreturn NULL;\r\n}\r\nstruct csio_rnode *\r\ncsio_rnode_lookup_portid(struct csio_lnode *ln, uint32_t portid)\r\n{\r\nstruct csio_rnode *rnhead = (struct csio_rnode *) &ln->rnhead;\r\nstruct list_head *tmp;\r\nstruct csio_rnode *rn;\r\nlist_for_each(tmp, &rnhead->sm.sm_list) {\r\nrn = (struct csio_rnode *) tmp;\r\nif (rn->nport_id == portid)\r\nreturn rn;\r\n}\r\nreturn NULL;\r\n}\r\nstatic int\r\ncsio_rn_dup_flowid(struct csio_lnode *ln, uint32_t rdev_flowid,\r\nuint32_t *vnp_flowid)\r\n{\r\nstruct csio_rnode *rnhead;\r\nstruct list_head *tmp, *tmp1;\r\nstruct csio_rnode *rn;\r\nstruct csio_lnode *ln_tmp;\r\nstruct csio_hw *hw = csio_lnode_to_hw(ln);\r\nlist_for_each(tmp1, &hw->sln_head) {\r\nln_tmp = (struct csio_lnode *) tmp1;\r\nif (ln_tmp == ln)\r\ncontinue;\r\nrnhead = (struct csio_rnode *)&ln_tmp->rnhead;\r\nlist_for_each(tmp, &rnhead->sm.sm_list) {\r\nrn = (struct csio_rnode *) tmp;\r\nif (csio_is_rnode_ready(rn)) {\r\nif (rn->flowid == rdev_flowid) {\r\n*vnp_flowid = csio_ln_flowid(ln_tmp);\r\nreturn 1;\r\n}\r\n}\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic struct csio_rnode *\r\ncsio_alloc_rnode(struct csio_lnode *ln)\r\n{\r\nstruct csio_hw *hw = csio_lnode_to_hw(ln);\r\nstruct csio_rnode *rn = mempool_alloc(hw->rnode_mempool, GFP_ATOMIC);\r\nif (!rn)\r\ngoto err;\r\nmemset(rn, 0, sizeof(struct csio_rnode));\r\nif (csio_rnode_init(rn, ln))\r\ngoto err_free;\r\nCSIO_INC_STATS(ln, n_rnode_alloc);\r\nreturn rn;\r\nerr_free:\r\nmempool_free(rn, hw->rnode_mempool);\r\nerr:\r\nCSIO_INC_STATS(ln, n_rnode_nomem);\r\nreturn NULL;\r\n}\r\nstatic void\r\ncsio_free_rnode(struct csio_rnode *rn)\r\n{\r\nstruct csio_hw *hw = csio_lnode_to_hw(csio_rnode_to_lnode(rn));\r\ncsio_rnode_exit(rn);\r\nCSIO_INC_STATS(rn->lnp, n_rnode_free);\r\nmempool_free(rn, hw->rnode_mempool);\r\n}\r\nstatic struct csio_rnode *\r\ncsio_get_rnode(struct csio_lnode *ln, uint32_t flowid)\r\n{\r\nstruct csio_rnode *rn;\r\nrn = csio_rn_lookup(ln, flowid);\r\nif (!rn) {\r\nrn = csio_alloc_rnode(ln);\r\nif (!rn)\r\nreturn NULL;\r\nrn->flowid = flowid;\r\n}\r\nreturn rn;\r\n}\r\nvoid\r\ncsio_put_rnode(struct csio_lnode *ln, struct csio_rnode *rn)\r\n{\r\nCSIO_DB_ASSERT(csio_is_rnode_uninit(rn) != 0);\r\ncsio_free_rnode(rn);\r\n}\r\nstruct csio_rnode *\r\ncsio_confirm_rnode(struct csio_lnode *ln, uint32_t rdev_flowid,\r\nstruct fcoe_rdev_entry *rdevp)\r\n{\r\nuint8_t rport_type;\r\nstruct csio_rnode *rn, *match_rn;\r\nuint32_t vnp_flowid;\r\n__be32 *port_id;\r\nport_id = (__be32 *)&rdevp->r_id[0];\r\nrport_type =\r\nFW_RDEV_WR_RPORT_TYPE_GET(rdevp->rd_xfer_rdy_to_rport_type);\r\nif (rport_type == FAB_CTLR_VNPORT) {\r\ncsio_ln_dbg(ln,\r\n"Unhandled rport_type:%d recv in rdev evt "\r\n"ssni:x%x\n", rport_type, rdev_flowid);\r\nreturn NULL;\r\n}\r\nrn = csio_rn_lookup(ln, rdev_flowid);\r\nif (!rn) {\r\nif (csio_rn_dup_flowid(ln, rdev_flowid, &vnp_flowid)) {\r\ncsio_ln_warn(ln,\r\n"ssni:%x already active on vnpi:%x",\r\nrdev_flowid, vnp_flowid);\r\nreturn NULL;\r\n}\r\nrn = csio_rn_lookup_wwpn(ln, rdevp->wwpn);\r\nif (!rn)\r\ngoto alloc_rnode;\r\n} else {\r\nif (csio_is_rnode_wka(rport_type)) {\r\nmatch_rn = csio_rnode_lookup_portid(ln,\r\n((ntohl(*port_id) >> 8) & CSIO_DID_MASK));\r\nif (match_rn == NULL) {\r\ncsio_rn_flowid(rn) = CSIO_INVALID_IDX;\r\ngoto alloc_rnode;\r\n}\r\nif (!memcmp(csio_rn_wwpn(match_rn), rdevp->wwpn, 8)) {\r\nif (csio_is_rnode_ready(rn)) {\r\ncsio_ln_warn(ln,\r\n"rnode is already"\r\n"active ssni:x%x\n",\r\nrdev_flowid);\r\nCSIO_ASSERT(0);\r\n}\r\ncsio_rn_flowid(rn) = CSIO_INVALID_IDX;\r\nrn = match_rn;\r\ngoto found_rnode;\r\n}\r\ncsio_rn_flowid(rn) = CSIO_INVALID_IDX;\r\ngoto alloc_rnode;\r\n}\r\nif (!memcmp(csio_rn_wwpn(rn), rdevp->wwpn, 8))\r\ngoto found_rnode;\r\nmatch_rn = csio_rn_lookup_wwpn(ln, rdevp->wwpn);\r\nif (match_rn != NULL) {\r\ncsio_ln_dbg(ln,\r\n"ssni:x%x changed for rport name(wwpn):%llx "\r\n"did:x%x\n", rdev_flowid,\r\nwwn_to_u64(rdevp->wwpn),\r\nmatch_rn->nport_id);\r\ncsio_rn_flowid(rn) = CSIO_INVALID_IDX;\r\nrn = match_rn;\r\n} else {\r\ncsio_ln_dbg(ln,\r\n"rnode wwpn mismatch found ssni:x%x "\r\n"name(wwpn):%llx\n",\r\nrdev_flowid,\r\nwwn_to_u64(csio_rn_wwpn(rn)));\r\nif (csio_is_rnode_ready(rn)) {\r\ncsio_ln_warn(ln,\r\n"rnode is already active "\r\n"wwpn:%llx ssni:x%x\n",\r\nwwn_to_u64(csio_rn_wwpn(rn)),\r\nrdev_flowid);\r\nCSIO_ASSERT(0);\r\n}\r\ncsio_rn_flowid(rn) = CSIO_INVALID_IDX;\r\ngoto alloc_rnode;\r\n}\r\n}\r\nfound_rnode:\r\ncsio_ln_dbg(ln, "found rnode:%p ssni:x%x name(wwpn):%llx\n",\r\nrn, rdev_flowid, wwn_to_u64(rdevp->wwpn));\r\ncsio_rn_flowid(rn) = rdev_flowid;\r\nrn->rdev_entry = rdevp;\r\nCSIO_INC_STATS(ln, n_rnode_match);\r\nreturn rn;\r\nalloc_rnode:\r\nrn = csio_get_rnode(ln, rdev_flowid);\r\nif (!rn)\r\nreturn NULL;\r\ncsio_ln_dbg(ln, "alloc rnode:%p ssni:x%x name(wwpn):%llx\n",\r\nrn, rdev_flowid, wwn_to_u64(rdevp->wwpn));\r\nrn->rdev_entry = rdevp;\r\nreturn rn;\r\n}\r\nstatic int\r\ncsio_rn_verify_rparams(struct csio_lnode *ln, struct csio_rnode *rn,\r\nstruct fcoe_rdev_entry *rdevp)\r\n{\r\nuint8_t null[8];\r\nuint8_t rport_type;\r\nuint8_t fc_class;\r\n__be32 *did;\r\ndid = (__be32 *) &rdevp->r_id[0];\r\nrport_type =\r\nFW_RDEV_WR_RPORT_TYPE_GET(rdevp->rd_xfer_rdy_to_rport_type);\r\nswitch (rport_type) {\r\ncase FLOGI_VFPORT:\r\nrn->role = CSIO_RNFR_FABRIC;\r\nif (((ntohl(*did) >> 8) & CSIO_DID_MASK) != FC_FID_FLOGI) {\r\ncsio_ln_err(ln, "ssni:x%x invalid fabric portid\n",\r\ncsio_rn_flowid(rn));\r\nreturn -EINVAL;\r\n}\r\nif (FW_RDEV_WR_NPIV_GET(rdevp->vft_to_qos))\r\nln->flags |= CSIO_LNF_NPIVSUPP;\r\nbreak;\r\ncase NS_VNPORT:\r\nrn->role = CSIO_RNFR_NS;\r\nif (((ntohl(*did) >> 8) & CSIO_DID_MASK) != FC_FID_DIR_SERV) {\r\ncsio_ln_err(ln, "ssni:x%x invalid fabric portid\n",\r\ncsio_rn_flowid(rn));\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ncase REG_FC4_VNPORT:\r\ncase REG_VNPORT:\r\nrn->role = CSIO_RNFR_NPORT;\r\nif (rdevp->event_cause == PRLI_ACC_RCVD ||\r\nrdevp->event_cause == PRLI_RCVD) {\r\nif (FW_RDEV_WR_TASK_RETRY_ID_GET(\r\nrdevp->enh_disc_to_tgt))\r\nrn->fcp_flags |= FCP_SPPF_OVLY_ALLOW;\r\nif (FW_RDEV_WR_RETRY_GET(rdevp->enh_disc_to_tgt))\r\nrn->fcp_flags |= FCP_SPPF_RETRY;\r\nif (FW_RDEV_WR_CONF_CMPL_GET(rdevp->enh_disc_to_tgt))\r\nrn->fcp_flags |= FCP_SPPF_CONF_COMPL;\r\nif (FW_RDEV_WR_TGT_GET(rdevp->enh_disc_to_tgt))\r\nrn->role |= CSIO_RNFR_TARGET;\r\nif (FW_RDEV_WR_INI_GET(rdevp->enh_disc_to_tgt))\r\nrn->role |= CSIO_RNFR_INITIATOR;\r\n}\r\nbreak;\r\ncase FDMI_VNPORT:\r\ncase FAB_CTLR_VNPORT:\r\nrn->role = 0;\r\nbreak;\r\ndefault:\r\ncsio_ln_err(ln, "ssni:x%x invalid rport type recv x%x\n",\r\ncsio_rn_flowid(rn), rport_type);\r\nreturn -EINVAL;\r\n}\r\nif (rport_type == REG_VNPORT || rport_type == NS_VNPORT) {\r\nmemset(null, 0, 8);\r\nif (!memcmp(rdevp->wwnn, null, 8)) {\r\ncsio_ln_err(ln,\r\n"ssni:x%x invalid wwnn received from"\r\n" rport did:x%x\n",\r\ncsio_rn_flowid(rn),\r\n(ntohl(*did) & CSIO_DID_MASK));\r\nreturn -EINVAL;\r\n}\r\nif (!memcmp(rdevp->wwpn, null, 8)) {\r\ncsio_ln_err(ln,\r\n"ssni:x%x invalid wwpn received from"\r\n" rport did:x%x\n",\r\ncsio_rn_flowid(rn),\r\n(ntohl(*did) & CSIO_DID_MASK));\r\nreturn -EINVAL;\r\n}\r\n}\r\nrn->nport_id = (ntohl(*did) >> 8) & CSIO_DID_MASK;\r\nmemcpy(csio_rn_wwnn(rn), rdevp->wwnn, 8);\r\nmemcpy(csio_rn_wwpn(rn), rdevp->wwpn, 8);\r\nrn->rn_sparm.csp.sp_bb_data = rdevp->rcv_fr_sz;\r\nfc_class = FW_RDEV_WR_CLASS_GET(rdevp->vft_to_qos);\r\nrn->rn_sparm.clsp[fc_class - 1].cp_class = htons(FC_CPC_VALID);\r\nreturn 0;\r\n}\r\nstatic void\r\n__csio_reg_rnode(struct csio_rnode *rn)\r\n{\r\nstruct csio_lnode *ln = csio_rnode_to_lnode(rn);\r\nstruct csio_hw *hw = csio_lnode_to_hw(ln);\r\nspin_unlock_irq(&hw->lock);\r\ncsio_reg_rnode(rn);\r\nspin_lock_irq(&hw->lock);\r\nif (rn->role & CSIO_RNFR_TARGET)\r\nln->n_scsi_tgts++;\r\nif (rn->nport_id == FC_FID_MGMT_SERV)\r\ncsio_ln_fdmi_start(ln, (void *) rn);\r\n}\r\nstatic void\r\n__csio_unreg_rnode(struct csio_rnode *rn)\r\n{\r\nstruct csio_lnode *ln = csio_rnode_to_lnode(rn);\r\nstruct csio_hw *hw = csio_lnode_to_hw(ln);\r\nLIST_HEAD(tmp_q);\r\nint cmpl = 0;\r\nif (!list_empty(&rn->host_cmpl_q)) {\r\ncsio_dbg(hw, "Returning completion queue I/Os\n");\r\nlist_splice_tail_init(&rn->host_cmpl_q, &tmp_q);\r\ncmpl = 1;\r\n}\r\nif (rn->role & CSIO_RNFR_TARGET) {\r\nln->n_scsi_tgts--;\r\nln->last_scan_ntgts--;\r\n}\r\nspin_unlock_irq(&hw->lock);\r\ncsio_unreg_rnode(rn);\r\nspin_lock_irq(&hw->lock);\r\nif (cmpl)\r\ncsio_scsi_cleanup_io_q(csio_hw_to_scsim(hw), &tmp_q);\r\n}\r\nstatic void\r\ncsio_rns_uninit(struct csio_rnode *rn, enum csio_rn_ev evt)\r\n{\r\nstruct csio_lnode *ln = csio_rnode_to_lnode(rn);\r\nint ret = 0;\r\nCSIO_INC_STATS(rn, n_evt_sm[evt]);\r\nswitch (evt) {\r\ncase CSIO_RNFE_LOGGED_IN:\r\ncase CSIO_RNFE_PLOGI_RECV:\r\nret = csio_rn_verify_rparams(ln, rn, rn->rdev_entry);\r\nif (!ret) {\r\ncsio_set_state(&rn->sm, csio_rns_ready);\r\n__csio_reg_rnode(rn);\r\n} else {\r\nCSIO_INC_STATS(rn, n_err_inval);\r\n}\r\nbreak;\r\ncase CSIO_RNFE_LOGO_RECV:\r\ncsio_ln_dbg(ln,\r\n"ssni:x%x Ignoring event %d recv "\r\n"in rn state[uninit]\n", csio_rn_flowid(rn), evt);\r\nCSIO_INC_STATS(rn, n_evt_drop);\r\nbreak;\r\ndefault:\r\ncsio_ln_dbg(ln,\r\n"ssni:x%x unexp event %d recv "\r\n"in rn state[uninit]\n", csio_rn_flowid(rn), evt);\r\nCSIO_INC_STATS(rn, n_evt_unexp);\r\nbreak;\r\n}\r\n}\r\nstatic void\r\ncsio_rns_ready(struct csio_rnode *rn, enum csio_rn_ev evt)\r\n{\r\nstruct csio_lnode *ln = csio_rnode_to_lnode(rn);\r\nint ret = 0;\r\nCSIO_INC_STATS(rn, n_evt_sm[evt]);\r\nswitch (evt) {\r\ncase CSIO_RNFE_LOGGED_IN:\r\ncase CSIO_RNFE_PLOGI_RECV:\r\ncsio_ln_dbg(ln,\r\n"ssni:x%x Ignoring event %d recv from did:x%x "\r\n"in rn state[ready]\n", csio_rn_flowid(rn), evt,\r\nrn->nport_id);\r\nCSIO_INC_STATS(rn, n_evt_drop);\r\nbreak;\r\ncase CSIO_RNFE_PRLI_DONE:\r\ncase CSIO_RNFE_PRLI_RECV:\r\nret = csio_rn_verify_rparams(ln, rn, rn->rdev_entry);\r\nif (!ret)\r\n__csio_reg_rnode(rn);\r\nelse\r\nCSIO_INC_STATS(rn, n_err_inval);\r\nbreak;\r\ncase CSIO_RNFE_DOWN:\r\ncsio_set_state(&rn->sm, csio_rns_offline);\r\n__csio_unreg_rnode(rn);\r\nbreak;\r\ncase CSIO_RNFE_LOGO_RECV:\r\ncsio_set_state(&rn->sm, csio_rns_offline);\r\n__csio_unreg_rnode(rn);\r\nbreak;\r\ncase CSIO_RNFE_CLOSE:\r\ncsio_set_state(&rn->sm, csio_rns_uninit);\r\n__csio_unreg_rnode(rn);\r\nbreak;\r\ncase CSIO_RNFE_NAME_MISSING:\r\ncsio_set_state(&rn->sm, csio_rns_disappeared);\r\n__csio_unreg_rnode(rn);\r\nbreak;\r\ndefault:\r\ncsio_ln_dbg(ln,\r\n"ssni:x%x unexp event %d recv from did:x%x "\r\n"in rn state[uninit]\n", csio_rn_flowid(rn), evt,\r\nrn->nport_id);\r\nCSIO_INC_STATS(rn, n_evt_unexp);\r\nbreak;\r\n}\r\n}\r\nstatic void\r\ncsio_rns_offline(struct csio_rnode *rn, enum csio_rn_ev evt)\r\n{\r\nstruct csio_lnode *ln = csio_rnode_to_lnode(rn);\r\nint ret = 0;\r\nCSIO_INC_STATS(rn, n_evt_sm[evt]);\r\nswitch (evt) {\r\ncase CSIO_RNFE_LOGGED_IN:\r\ncase CSIO_RNFE_PLOGI_RECV:\r\nret = csio_rn_verify_rparams(ln, rn, rn->rdev_entry);\r\nif (!ret) {\r\ncsio_set_state(&rn->sm, csio_rns_ready);\r\n__csio_reg_rnode(rn);\r\n} else {\r\nCSIO_INC_STATS(rn, n_err_inval);\r\ncsio_post_event(&rn->sm, CSIO_RNFE_CLOSE);\r\n}\r\nbreak;\r\ncase CSIO_RNFE_DOWN:\r\ncsio_ln_dbg(ln,\r\n"ssni:x%x Ignoring event %d recv from did:x%x "\r\n"in rn state[offline]\n", csio_rn_flowid(rn), evt,\r\nrn->nport_id);\r\nCSIO_INC_STATS(rn, n_evt_drop);\r\nbreak;\r\ncase CSIO_RNFE_CLOSE:\r\ncsio_set_state(&rn->sm, csio_rns_uninit);\r\nbreak;\r\ncase CSIO_RNFE_NAME_MISSING:\r\ncsio_set_state(&rn->sm, csio_rns_disappeared);\r\nbreak;\r\ndefault:\r\ncsio_ln_dbg(ln,\r\n"ssni:x%x unexp event %d recv from did:x%x "\r\n"in rn state[offline]\n", csio_rn_flowid(rn), evt,\r\nrn->nport_id);\r\nCSIO_INC_STATS(rn, n_evt_unexp);\r\nbreak;\r\n}\r\n}\r\nstatic void\r\ncsio_rns_disappeared(struct csio_rnode *rn, enum csio_rn_ev evt)\r\n{\r\nstruct csio_lnode *ln = csio_rnode_to_lnode(rn);\r\nint ret = 0;\r\nCSIO_INC_STATS(rn, n_evt_sm[evt]);\r\nswitch (evt) {\r\ncase CSIO_RNFE_LOGGED_IN:\r\ncase CSIO_RNFE_PLOGI_RECV:\r\nret = csio_rn_verify_rparams(ln, rn, rn->rdev_entry);\r\nif (!ret) {\r\ncsio_set_state(&rn->sm, csio_rns_ready);\r\n__csio_reg_rnode(rn);\r\n} else {\r\nCSIO_INC_STATS(rn, n_err_inval);\r\ncsio_post_event(&rn->sm, CSIO_RNFE_CLOSE);\r\n}\r\nbreak;\r\ncase CSIO_RNFE_CLOSE:\r\ncsio_set_state(&rn->sm, csio_rns_uninit);\r\nbreak;\r\ncase CSIO_RNFE_DOWN:\r\ncase CSIO_RNFE_NAME_MISSING:\r\ncsio_ln_dbg(ln,\r\n"ssni:x%x Ignoring event %d recv from did x%x"\r\n"in rn state[disappeared]\n", csio_rn_flowid(rn),\r\nevt, rn->nport_id);\r\nbreak;\r\ndefault:\r\ncsio_ln_dbg(ln,\r\n"ssni:x%x unexp event %d recv from did x%x"\r\n"in rn state[disappeared]\n", csio_rn_flowid(rn),\r\nevt, rn->nport_id);\r\nCSIO_INC_STATS(rn, n_evt_unexp);\r\nbreak;\r\n}\r\n}\r\nvoid\r\ncsio_rnode_devloss_handler(struct csio_rnode *rn)\r\n{\r\nstruct csio_lnode *ln = csio_rnode_to_lnode(rn);\r\nif (csio_is_rnode_ready(rn))\r\nreturn;\r\ncsio_post_event(&rn->sm, CSIO_RNFE_CLOSE);\r\nif (csio_is_rnode_uninit(rn))\r\ncsio_put_rnode(ln, rn);\r\n}\r\nvoid\r\ncsio_rnode_fwevt_handler(struct csio_rnode *rn, uint8_t fwevt)\r\n{\r\nstruct csio_lnode *ln = csio_rnode_to_lnode(rn);\r\nenum csio_rn_ev evt;\r\nevt = CSIO_FWE_TO_RNFE(fwevt);\r\nif (!evt) {\r\ncsio_ln_err(ln, "ssni:x%x Unhandled FW Rdev event: %d\n",\r\ncsio_rn_flowid(rn), fwevt);\r\nCSIO_INC_STATS(rn, n_evt_unexp);\r\nreturn;\r\n}\r\nCSIO_INC_STATS(rn, n_evt_fw[fwevt]);\r\nrn->prev_evt = rn->cur_evt;\r\nrn->cur_evt = fwevt;\r\ncsio_post_event(&rn->sm, evt);\r\nif (csio_is_rnode_uninit(rn))\r\ncsio_put_rnode(ln, rn);\r\n}\r\nstatic int\r\ncsio_rnode_init(struct csio_rnode *rn, struct csio_lnode *ln)\r\n{\r\ncsio_rnode_to_lnode(rn) = ln;\r\ncsio_init_state(&rn->sm, csio_rns_uninit);\r\nINIT_LIST_HEAD(&rn->host_cmpl_q);\r\ncsio_rn_flowid(rn) = CSIO_INVALID_IDX;\r\nlist_add_tail(&rn->sm.sm_list, &ln->rnhead);\r\nreturn 0;\r\n}\r\nstatic void\r\ncsio_rnode_exit(struct csio_rnode *rn)\r\n{\r\nlist_del_init(&rn->sm.sm_list);\r\nCSIO_DB_ASSERT(list_empty(&rn->host_cmpl_q));\r\n}
