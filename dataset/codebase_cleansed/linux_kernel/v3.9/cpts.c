static int event_expired(struct cpts_event *event)\r\n{\r\nreturn time_after(jiffies, event->tmo);\r\n}\r\nstatic int event_type(struct cpts_event *event)\r\n{\r\nreturn (event->high >> EVENT_TYPE_SHIFT) & EVENT_TYPE_MASK;\r\n}\r\nstatic int cpts_fifo_pop(struct cpts *cpts, u32 *high, u32 *low)\r\n{\r\nu32 r = cpts_read32(cpts, intstat_raw);\r\nif (r & TS_PEND_RAW) {\r\n*high = cpts_read32(cpts, event_high);\r\n*low = cpts_read32(cpts, event_low);\r\ncpts_write32(cpts, EVENT_POP, event_pop);\r\nreturn 0;\r\n}\r\nreturn -1;\r\n}\r\nstatic int cpts_fifo_read(struct cpts *cpts, int match)\r\n{\r\nint i, type = -1;\r\nu32 hi, lo;\r\nstruct cpts_event *event;\r\nfor (i = 0; i < CPTS_FIFO_DEPTH; i++) {\r\nif (cpts_fifo_pop(cpts, &hi, &lo))\r\nbreak;\r\nif (list_empty(&cpts->pool)) {\r\npr_err("cpts: event pool is empty\n");\r\nreturn -1;\r\n}\r\nevent = list_first_entry(&cpts->pool, struct cpts_event, list);\r\nevent->tmo = jiffies + 2;\r\nevent->high = hi;\r\nevent->low = lo;\r\ntype = event_type(event);\r\nswitch (type) {\r\ncase CPTS_EV_PUSH:\r\ncase CPTS_EV_RX:\r\ncase CPTS_EV_TX:\r\nlist_del_init(&event->list);\r\nlist_add_tail(&event->list, &cpts->events);\r\nbreak;\r\ncase CPTS_EV_ROLL:\r\ncase CPTS_EV_HALF:\r\ncase CPTS_EV_HW:\r\nbreak;\r\ndefault:\r\npr_err("cpts: unkown event type\n");\r\nbreak;\r\n}\r\nif (type == match)\r\nbreak;\r\n}\r\nreturn type == match ? 0 : -1;\r\n}\r\nstatic cycle_t cpts_systim_read(const struct cyclecounter *cc)\r\n{\r\nu64 val = 0;\r\nstruct cpts_event *event;\r\nstruct list_head *this, *next;\r\nstruct cpts *cpts = container_of(cc, struct cpts, cc);\r\ncpts_write32(cpts, TS_PUSH, ts_push);\r\nif (cpts_fifo_read(cpts, CPTS_EV_PUSH))\r\npr_err("cpts: unable to obtain a time stamp\n");\r\nlist_for_each_safe(this, next, &cpts->events) {\r\nevent = list_entry(this, struct cpts_event, list);\r\nif (event_type(event) == CPTS_EV_PUSH) {\r\nlist_del_init(&event->list);\r\nlist_add(&event->list, &cpts->pool);\r\nval = event->low;\r\nbreak;\r\n}\r\n}\r\nreturn val;\r\n}\r\nstatic int cpts_ptp_adjfreq(struct ptp_clock_info *ptp, s32 ppb)\r\n{\r\nu64 adj;\r\nu32 diff, mult;\r\nint neg_adj = 0;\r\nunsigned long flags;\r\nstruct cpts *cpts = container_of(ptp, struct cpts, info);\r\nif (ppb < 0) {\r\nneg_adj = 1;\r\nppb = -ppb;\r\n}\r\nmult = cpts->cc_mult;\r\nadj = mult;\r\nadj *= ppb;\r\ndiff = div_u64(adj, 1000000000ULL);\r\nspin_lock_irqsave(&cpts->lock, flags);\r\ntimecounter_read(&cpts->tc);\r\ncpts->cc.mult = neg_adj ? mult - diff : mult + diff;\r\nspin_unlock_irqrestore(&cpts->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int cpts_ptp_adjtime(struct ptp_clock_info *ptp, s64 delta)\r\n{\r\ns64 now;\r\nunsigned long flags;\r\nstruct cpts *cpts = container_of(ptp, struct cpts, info);\r\nspin_lock_irqsave(&cpts->lock, flags);\r\nnow = timecounter_read(&cpts->tc);\r\nnow += delta;\r\ntimecounter_init(&cpts->tc, &cpts->cc, now);\r\nspin_unlock_irqrestore(&cpts->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int cpts_ptp_gettime(struct ptp_clock_info *ptp, struct timespec *ts)\r\n{\r\nu64 ns;\r\nu32 remainder;\r\nunsigned long flags;\r\nstruct cpts *cpts = container_of(ptp, struct cpts, info);\r\nspin_lock_irqsave(&cpts->lock, flags);\r\nns = timecounter_read(&cpts->tc);\r\nspin_unlock_irqrestore(&cpts->lock, flags);\r\nts->tv_sec = div_u64_rem(ns, 1000000000, &remainder);\r\nts->tv_nsec = remainder;\r\nreturn 0;\r\n}\r\nstatic int cpts_ptp_settime(struct ptp_clock_info *ptp,\r\nconst struct timespec *ts)\r\n{\r\nu64 ns;\r\nunsigned long flags;\r\nstruct cpts *cpts = container_of(ptp, struct cpts, info);\r\nns = ts->tv_sec * 1000000000ULL;\r\nns += ts->tv_nsec;\r\nspin_lock_irqsave(&cpts->lock, flags);\r\ntimecounter_init(&cpts->tc, &cpts->cc, ns);\r\nspin_unlock_irqrestore(&cpts->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int cpts_ptp_enable(struct ptp_clock_info *ptp,\r\nstruct ptp_clock_request *rq, int on)\r\n{\r\nreturn -EOPNOTSUPP;\r\n}\r\nstatic void cpts_overflow_check(struct work_struct *work)\r\n{\r\nstruct timespec ts;\r\nstruct cpts *cpts = container_of(work, struct cpts, overflow_work.work);\r\ncpts_write32(cpts, CPTS_EN, control);\r\ncpts_write32(cpts, TS_PEND_EN, int_enable);\r\ncpts_ptp_gettime(&cpts->info, &ts);\r\npr_debug("cpts overflow check at %ld.%09lu\n", ts.tv_sec, ts.tv_nsec);\r\nschedule_delayed_work(&cpts->overflow_work, CPTS_OVERFLOW_PERIOD);\r\n}\r\nstatic void cpts_clk_init(struct cpts *cpts)\r\n{\r\ncpts->refclk = clk_get(NULL, CPTS_REF_CLOCK_NAME);\r\nif (IS_ERR(cpts->refclk)) {\r\npr_err("Failed to clk_get %s\n", CPTS_REF_CLOCK_NAME);\r\ncpts->refclk = NULL;\r\nreturn;\r\n}\r\nclk_prepare_enable(cpts->refclk);\r\n}\r\nstatic void cpts_clk_release(struct cpts *cpts)\r\n{\r\nclk_disable(cpts->refclk);\r\nclk_put(cpts->refclk);\r\n}\r\nstatic int cpts_match(struct sk_buff *skb, unsigned int ptp_class,\r\nu16 ts_seqid, u8 ts_msgtype)\r\n{\r\nu16 *seqid;\r\nunsigned int offset;\r\nu8 *msgtype, *data = skb->data;\r\nswitch (ptp_class) {\r\ncase PTP_CLASS_V1_IPV4:\r\ncase PTP_CLASS_V2_IPV4:\r\noffset = ETH_HLEN + IPV4_HLEN(data) + UDP_HLEN;\r\nbreak;\r\ncase PTP_CLASS_V1_IPV6:\r\ncase PTP_CLASS_V2_IPV6:\r\noffset = OFF_PTP6;\r\nbreak;\r\ncase PTP_CLASS_V2_L2:\r\noffset = ETH_HLEN;\r\nbreak;\r\ncase PTP_CLASS_V2_VLAN:\r\noffset = ETH_HLEN + VLAN_HLEN;\r\nbreak;\r\ndefault:\r\nreturn 0;\r\n}\r\nif (skb->len + ETH_HLEN < offset + OFF_PTP_SEQUENCE_ID + sizeof(*seqid))\r\nreturn 0;\r\nif (unlikely(ptp_class & PTP_CLASS_V1))\r\nmsgtype = data + offset + OFF_PTP_CONTROL;\r\nelse\r\nmsgtype = data + offset;\r\nseqid = (u16 *)(data + offset + OFF_PTP_SEQUENCE_ID);\r\nreturn (ts_msgtype == (*msgtype & 0xf) && ts_seqid == ntohs(*seqid));\r\n}\r\nstatic u64 cpts_find_ts(struct cpts *cpts, struct sk_buff *skb, int ev_type)\r\n{\r\nu64 ns = 0;\r\nstruct cpts_event *event;\r\nstruct list_head *this, *next;\r\nunsigned int class = sk_run_filter(skb, ptp_filter);\r\nunsigned long flags;\r\nu16 seqid;\r\nu8 mtype;\r\nif (class == PTP_CLASS_NONE)\r\nreturn 0;\r\nspin_lock_irqsave(&cpts->lock, flags);\r\ncpts_fifo_read(cpts, CPTS_EV_PUSH);\r\nlist_for_each_safe(this, next, &cpts->events) {\r\nevent = list_entry(this, struct cpts_event, list);\r\nif (event_expired(event)) {\r\nlist_del_init(&event->list);\r\nlist_add(&event->list, &cpts->pool);\r\ncontinue;\r\n}\r\nmtype = (event->high >> MESSAGE_TYPE_SHIFT) & MESSAGE_TYPE_MASK;\r\nseqid = (event->high >> SEQUENCE_ID_SHIFT) & SEQUENCE_ID_MASK;\r\nif (ev_type == event_type(event) &&\r\ncpts_match(skb, class, seqid, mtype)) {\r\nns = timecounter_cyc2time(&cpts->tc, event->low);\r\nlist_del_init(&event->list);\r\nlist_add(&event->list, &cpts->pool);\r\nbreak;\r\n}\r\n}\r\nspin_unlock_irqrestore(&cpts->lock, flags);\r\nreturn ns;\r\n}\r\nvoid cpts_rx_timestamp(struct cpts *cpts, struct sk_buff *skb)\r\n{\r\nu64 ns;\r\nstruct skb_shared_hwtstamps *ssh;\r\nif (!cpts->rx_enable)\r\nreturn;\r\nns = cpts_find_ts(cpts, skb, CPTS_EV_RX);\r\nif (!ns)\r\nreturn;\r\nssh = skb_hwtstamps(skb);\r\nmemset(ssh, 0, sizeof(*ssh));\r\nssh->hwtstamp = ns_to_ktime(ns);\r\n}\r\nvoid cpts_tx_timestamp(struct cpts *cpts, struct sk_buff *skb)\r\n{\r\nu64 ns;\r\nstruct skb_shared_hwtstamps ssh;\r\nif (!(skb_shinfo(skb)->tx_flags & SKBTX_IN_PROGRESS))\r\nreturn;\r\nns = cpts_find_ts(cpts, skb, CPTS_EV_TX);\r\nif (!ns)\r\nreturn;\r\nmemset(&ssh, 0, sizeof(ssh));\r\nssh.hwtstamp = ns_to_ktime(ns);\r\nskb_tstamp_tx(skb, &ssh);\r\n}\r\nint cpts_register(struct device *dev, struct cpts *cpts,\r\nu32 mult, u32 shift)\r\n{\r\n#ifdef CONFIG_TI_CPTS\r\nint err, i;\r\nunsigned long flags;\r\nif (ptp_filter_init(ptp_filter, ARRAY_SIZE(ptp_filter))) {\r\npr_err("cpts: bad ptp filter\n");\r\nreturn -EINVAL;\r\n}\r\ncpts->info = cpts_info;\r\ncpts->clock = ptp_clock_register(&cpts->info, dev);\r\nif (IS_ERR(cpts->clock)) {\r\nerr = PTR_ERR(cpts->clock);\r\ncpts->clock = NULL;\r\nreturn err;\r\n}\r\nspin_lock_init(&cpts->lock);\r\ncpts->cc.read = cpts_systim_read;\r\ncpts->cc.mask = CLOCKSOURCE_MASK(32);\r\ncpts->cc_mult = mult;\r\ncpts->cc.mult = mult;\r\ncpts->cc.shift = shift;\r\nINIT_LIST_HEAD(&cpts->events);\r\nINIT_LIST_HEAD(&cpts->pool);\r\nfor (i = 0; i < CPTS_MAX_EVENTS; i++)\r\nlist_add(&cpts->pool_data[i].list, &cpts->pool);\r\ncpts_clk_init(cpts);\r\ncpts_write32(cpts, CPTS_EN, control);\r\ncpts_write32(cpts, TS_PEND_EN, int_enable);\r\nspin_lock_irqsave(&cpts->lock, flags);\r\ntimecounter_init(&cpts->tc, &cpts->cc, ktime_to_ns(ktime_get_real()));\r\nspin_unlock_irqrestore(&cpts->lock, flags);\r\nINIT_DELAYED_WORK(&cpts->overflow_work, cpts_overflow_check);\r\nschedule_delayed_work(&cpts->overflow_work, CPTS_OVERFLOW_PERIOD);\r\ncpts->phc_index = ptp_clock_index(cpts->clock);\r\n#endif\r\nreturn 0;\r\n}\r\nvoid cpts_unregister(struct cpts *cpts)\r\n{\r\n#ifdef CONFIG_TI_CPTS\r\nif (cpts->clock) {\r\nptp_clock_unregister(cpts->clock);\r\ncancel_delayed_work_sync(&cpts->overflow_work);\r\n}\r\nif (cpts->refclk)\r\ncpts_clk_release(cpts);\r\n#endif\r\n}
