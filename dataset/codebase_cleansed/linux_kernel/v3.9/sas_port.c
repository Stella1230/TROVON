static bool phy_is_wideport_member(struct asd_sas_port *port, struct asd_sas_phy *phy)\r\n{\r\nstruct sas_ha_struct *sas_ha = phy->ha;\r\nif (memcmp(port->attached_sas_addr, phy->attached_sas_addr,\r\nSAS_ADDR_SIZE) != 0 || (sas_ha->strict_wide_ports &&\r\nmemcmp(port->sas_addr, phy->sas_addr, SAS_ADDR_SIZE) != 0))\r\nreturn false;\r\nreturn true;\r\n}\r\nstatic void sas_resume_port(struct asd_sas_phy *phy)\r\n{\r\nstruct domain_device *dev;\r\nstruct asd_sas_port *port = phy->port;\r\nstruct sas_ha_struct *sas_ha = phy->ha;\r\nstruct sas_internal *si = to_sas_internal(sas_ha->core.shost->transportt);\r\nif (si->dft->lldd_port_formed)\r\nsi->dft->lldd_port_formed(phy);\r\nif (port->suspended)\r\nport->suspended = 0;\r\nelse {\r\nreturn;\r\n}\r\nlist_for_each_entry(dev, &port->dev_list, dev_list_node) {\r\nint i, rc;\r\nrc = sas_notify_lldd_dev_found(dev);\r\nif (rc) {\r\nsas_unregister_dev(port, dev);\r\ncontinue;\r\n}\r\nif (dev->dev_type == EDGE_DEV || dev->dev_type == FANOUT_DEV) {\r\ndev->ex_dev.ex_change_count = -1;\r\nfor (i = 0; i < dev->ex_dev.num_phys; i++) {\r\nstruct ex_phy *phy = &dev->ex_dev.ex_phy[i];\r\nphy->phy_change_count = -1;\r\n}\r\n}\r\n}\r\nsas_discover_event(port, DISCE_RESUME);\r\n}\r\nstatic void sas_form_port(struct asd_sas_phy *phy)\r\n{\r\nint i;\r\nstruct sas_ha_struct *sas_ha = phy->ha;\r\nstruct asd_sas_port *port = phy->port;\r\nstruct sas_internal *si =\r\nto_sas_internal(sas_ha->core.shost->transportt);\r\nunsigned long flags;\r\nif (port) {\r\nif (!phy_is_wideport_member(port, phy))\r\nsas_deform_port(phy, 0);\r\nelse if (phy->suspended) {\r\nphy->suspended = 0;\r\nsas_resume_port(phy);\r\nwake_up(&sas_ha->eh_wait_q);\r\nreturn;\r\n} else {\r\nSAS_DPRINTK("%s: phy%d belongs to port%d already(%d)!\n",\r\n__func__, phy->id, phy->port->id,\r\nphy->port->num_phys);\r\nreturn;\r\n}\r\n}\r\nspin_lock_irqsave(&sas_ha->phy_port_lock, flags);\r\nfor (i = 0; i < sas_ha->num_phys; i++) {\r\nport = sas_ha->sas_port[i];\r\nspin_lock(&port->phy_list_lock);\r\nif (*(u64 *) port->sas_addr &&\r\nphy_is_wideport_member(port, phy) && port->num_phys > 0) {\r\nSAS_DPRINTK("phy%d matched wide port%d\n", phy->id,\r\nport->id);\r\nbreak;\r\n}\r\nspin_unlock(&port->phy_list_lock);\r\n}\r\nif (i == sas_ha->num_phys) {\r\nfor (i = 0; i < sas_ha->num_phys; i++) {\r\nport = sas_ha->sas_port[i];\r\nspin_lock(&port->phy_list_lock);\r\nif (*(u64 *)port->sas_addr == 0\r\n&& port->num_phys == 0) {\r\nmemcpy(port->sas_addr, phy->sas_addr,\r\nSAS_ADDR_SIZE);\r\nbreak;\r\n}\r\nspin_unlock(&port->phy_list_lock);\r\n}\r\n}\r\nif (i >= sas_ha->num_phys) {\r\nprintk(KERN_NOTICE "%s: couldn't find a free port, bug?\n",\r\n__func__);\r\nspin_unlock_irqrestore(&sas_ha->phy_port_lock, flags);\r\nreturn;\r\n}\r\nlist_add_tail(&phy->port_phy_el, &port->phy_list);\r\nsas_phy_set_target(phy, port->port_dev);\r\nphy->port = port;\r\nport->num_phys++;\r\nport->phy_mask |= (1U << phy->id);\r\nif (*(u64 *)port->attached_sas_addr == 0) {\r\nport->class = phy->class;\r\nmemcpy(port->attached_sas_addr, phy->attached_sas_addr,\r\nSAS_ADDR_SIZE);\r\nport->iproto = phy->iproto;\r\nport->tproto = phy->tproto;\r\nport->oob_mode = phy->oob_mode;\r\nport->linkrate = phy->linkrate;\r\n} else\r\nport->linkrate = max(port->linkrate, phy->linkrate);\r\nspin_unlock(&port->phy_list_lock);\r\nspin_unlock_irqrestore(&sas_ha->phy_port_lock, flags);\r\nif (!port->port) {\r\nport->port = sas_port_alloc(phy->phy->dev.parent, port->id);\r\nBUG_ON(!port->port);\r\nsas_port_add(port->port);\r\n}\r\nsas_port_add_phy(port->port, phy->phy);\r\nSAS_DPRINTK("%s added to %s, phy_mask:0x%x (%16llx)\n",\r\ndev_name(&phy->phy->dev), dev_name(&port->port->dev),\r\nport->phy_mask,\r\nSAS_ADDR(port->attached_sas_addr));\r\nif (port->port_dev)\r\nport->port_dev->pathways = port->num_phys;\r\nif (si->dft->lldd_port_formed)\r\nsi->dft->lldd_port_formed(phy);\r\nsas_discover_event(phy->port, DISCE_DISCOVER_DOMAIN);\r\n}\r\nvoid sas_deform_port(struct asd_sas_phy *phy, int gone)\r\n{\r\nstruct sas_ha_struct *sas_ha = phy->ha;\r\nstruct asd_sas_port *port = phy->port;\r\nstruct sas_internal *si =\r\nto_sas_internal(sas_ha->core.shost->transportt);\r\nstruct domain_device *dev;\r\nunsigned long flags;\r\nif (!port)\r\nreturn;\r\ndev = port->port_dev;\r\nif (dev)\r\ndev->pathways--;\r\nif (port->num_phys == 1) {\r\nsas_unregister_domain_devices(port, gone);\r\nsas_port_delete(port->port);\r\nport->port = NULL;\r\n} else {\r\nsas_port_delete_phy(port->port, phy->phy);\r\nsas_device_set_phy(dev, port->port);\r\n}\r\nif (si->dft->lldd_port_deformed)\r\nsi->dft->lldd_port_deformed(phy);\r\nspin_lock_irqsave(&sas_ha->phy_port_lock, flags);\r\nspin_lock(&port->phy_list_lock);\r\nlist_del_init(&phy->port_phy_el);\r\nsas_phy_set_target(phy, NULL);\r\nphy->port = NULL;\r\nport->num_phys--;\r\nport->phy_mask &= ~(1U << phy->id);\r\nif (port->num_phys == 0) {\r\nINIT_LIST_HEAD(&port->phy_list);\r\nmemset(port->sas_addr, 0, SAS_ADDR_SIZE);\r\nmemset(port->attached_sas_addr, 0, SAS_ADDR_SIZE);\r\nport->class = 0;\r\nport->iproto = 0;\r\nport->tproto = 0;\r\nport->oob_mode = 0;\r\nport->phy_mask = 0;\r\n}\r\nspin_unlock(&port->phy_list_lock);\r\nspin_unlock_irqrestore(&sas_ha->phy_port_lock, flags);\r\nreturn;\r\n}\r\nvoid sas_porte_bytes_dmaed(struct work_struct *work)\r\n{\r\nstruct asd_sas_event *ev = to_asd_sas_event(work);\r\nstruct asd_sas_phy *phy = ev->phy;\r\nclear_bit(PORTE_BYTES_DMAED, &phy->port_events_pending);\r\nsas_form_port(phy);\r\n}\r\nvoid sas_porte_broadcast_rcvd(struct work_struct *work)\r\n{\r\nstruct asd_sas_event *ev = to_asd_sas_event(work);\r\nstruct asd_sas_phy *phy = ev->phy;\r\nunsigned long flags;\r\nu32 prim;\r\nclear_bit(PORTE_BROADCAST_RCVD, &phy->port_events_pending);\r\nspin_lock_irqsave(&phy->sas_prim_lock, flags);\r\nprim = phy->sas_prim;\r\nspin_unlock_irqrestore(&phy->sas_prim_lock, flags);\r\nSAS_DPRINTK("broadcast received: %d\n", prim);\r\nsas_discover_event(phy->port, DISCE_REVALIDATE_DOMAIN);\r\n}\r\nvoid sas_porte_link_reset_err(struct work_struct *work)\r\n{\r\nstruct asd_sas_event *ev = to_asd_sas_event(work);\r\nstruct asd_sas_phy *phy = ev->phy;\r\nclear_bit(PORTE_LINK_RESET_ERR, &phy->port_events_pending);\r\nsas_deform_port(phy, 1);\r\n}\r\nvoid sas_porte_timer_event(struct work_struct *work)\r\n{\r\nstruct asd_sas_event *ev = to_asd_sas_event(work);\r\nstruct asd_sas_phy *phy = ev->phy;\r\nclear_bit(PORTE_TIMER_EVENT, &phy->port_events_pending);\r\nsas_deform_port(phy, 1);\r\n}\r\nvoid sas_porte_hard_reset(struct work_struct *work)\r\n{\r\nstruct asd_sas_event *ev = to_asd_sas_event(work);\r\nstruct asd_sas_phy *phy = ev->phy;\r\nclear_bit(PORTE_HARD_RESET, &phy->port_events_pending);\r\nsas_deform_port(phy, 1);\r\n}\r\nstatic void sas_init_port(struct asd_sas_port *port,\r\nstruct sas_ha_struct *sas_ha, int i)\r\n{\r\nmemset(port, 0, sizeof(*port));\r\nport->id = i;\r\nINIT_LIST_HEAD(&port->dev_list);\r\nINIT_LIST_HEAD(&port->disco_list);\r\nINIT_LIST_HEAD(&port->destroy_list);\r\nspin_lock_init(&port->phy_list_lock);\r\nINIT_LIST_HEAD(&port->phy_list);\r\nport->ha = sas_ha;\r\nspin_lock_init(&port->dev_list_lock);\r\n}\r\nint sas_register_ports(struct sas_ha_struct *sas_ha)\r\n{\r\nint i;\r\nfor (i = 0; i < sas_ha->num_phys; i++) {\r\nstruct asd_sas_port *port = sas_ha->sas_port[i];\r\nsas_init_port(port, sas_ha, i);\r\nsas_init_disc(&port->disc, port);\r\n}\r\nreturn 0;\r\n}\r\nvoid sas_unregister_ports(struct sas_ha_struct *sas_ha)\r\n{\r\nint i;\r\nfor (i = 0; i < sas_ha->num_phys; i++)\r\nif (sas_ha->sas_phy[i]->port)\r\nsas_deform_port(sas_ha->sas_phy[i], 0);\r\n}
