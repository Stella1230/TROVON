static size_t logger_offset(struct logger_log *log, size_t n)\r\n{\r\nreturn n & (log->size - 1);\r\n}\r\nstatic inline struct logger_log *file_get_log(struct file *file)\r\n{\r\nif (file->f_mode & FMODE_READ) {\r\nstruct logger_reader *reader = file->private_data;\r\nreturn reader->log;\r\n} else\r\nreturn file->private_data;\r\n}\r\nstatic __u32 get_entry_len(struct logger_log *log, size_t off)\r\n{\r\n__u16 val;\r\n((__u8 *)&val)[0] = log->buffer[off];\r\nif (likely(off+1 < log->size))\r\n((__u8 *)&val)[1] = log->buffer[off+1];\r\nelse\r\n((__u8 *)&val)[1] = log->buffer[0];\r\nreturn sizeof(struct logger_entry) + val;\r\n}\r\nstatic ssize_t do_read_log_to_user(struct logger_log *log,\r\nstruct logger_reader *reader,\r\nchar __user *buf,\r\nsize_t count)\r\n{\r\nsize_t len;\r\nlen = min(count, log->size - reader->r_off);\r\nif (copy_to_user(buf, log->buffer + reader->r_off, len))\r\nreturn -EFAULT;\r\nif (count != len)\r\nif (copy_to_user(buf + len, log->buffer, count - len))\r\nreturn -EFAULT;\r\nreader->r_off = logger_offset(log, reader->r_off + count);\r\nreturn count;\r\n}\r\nstatic ssize_t logger_read(struct file *file, char __user *buf,\r\nsize_t count, loff_t *pos)\r\n{\r\nstruct logger_reader *reader = file->private_data;\r\nstruct logger_log *log = reader->log;\r\nssize_t ret;\r\nDEFINE_WAIT(wait);\r\nstart:\r\nwhile (1) {\r\nmutex_lock(&log->mutex);\r\nprepare_to_wait(&log->wq, &wait, TASK_INTERRUPTIBLE);\r\nret = (log->w_off == reader->r_off);\r\nmutex_unlock(&log->mutex);\r\nif (!ret)\r\nbreak;\r\nif (file->f_flags & O_NONBLOCK) {\r\nret = -EAGAIN;\r\nbreak;\r\n}\r\nif (signal_pending(current)) {\r\nret = -EINTR;\r\nbreak;\r\n}\r\nschedule();\r\n}\r\nfinish_wait(&log->wq, &wait);\r\nif (ret)\r\nreturn ret;\r\nmutex_lock(&log->mutex);\r\nif (unlikely(log->w_off == reader->r_off)) {\r\nmutex_unlock(&log->mutex);\r\ngoto start;\r\n}\r\nret = get_entry_len(log, reader->r_off);\r\nif (count < ret) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nret = do_read_log_to_user(log, reader, buf, ret);\r\nout:\r\nmutex_unlock(&log->mutex);\r\nreturn ret;\r\n}\r\nstatic size_t get_next_entry(struct logger_log *log, size_t off, size_t len)\r\n{\r\nsize_t count = 0;\r\ndo {\r\nsize_t nr = get_entry_len(log, off);\r\noff = logger_offset(log, off + nr);\r\ncount += nr;\r\n} while (count < len);\r\nreturn off;\r\n}\r\nstatic inline int is_between(size_t a, size_t b, size_t c)\r\n{\r\nif (a < b) {\r\nif (a < c && c <= b)\r\nreturn 1;\r\n} else {\r\nif (c <= b || a < c)\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic void fix_up_readers(struct logger_log *log, size_t len)\r\n{\r\nsize_t old = log->w_off;\r\nsize_t new = logger_offset(log, old + len);\r\nstruct logger_reader *reader;\r\nif (is_between(old, new, log->head))\r\nlog->head = get_next_entry(log, log->head, len);\r\nlist_for_each_entry(reader, &log->readers, list)\r\nif (is_between(old, new, reader->r_off))\r\nreader->r_off = get_next_entry(log, reader->r_off, len);\r\n}\r\nstatic void do_write_log(struct logger_log *log, const void *buf, size_t count)\r\n{\r\nsize_t len;\r\nlen = min(count, log->size - log->w_off);\r\nmemcpy(log->buffer + log->w_off, buf, len);\r\nif (count != len)\r\nmemcpy(log->buffer, buf + len, count - len);\r\nlog->w_off = logger_offset(log, log->w_off + count);\r\n}\r\nstatic ssize_t do_write_log_from_user(struct logger_log *log,\r\nconst void __user *buf, size_t count)\r\n{\r\nsize_t len;\r\nlen = min(count, log->size - log->w_off);\r\nif (len && copy_from_user(log->buffer + log->w_off, buf, len))\r\nreturn -EFAULT;\r\nif (count != len)\r\nif (copy_from_user(log->buffer, buf + len, count - len))\r\nreturn -EFAULT;\r\nlog->w_off = logger_offset(log, log->w_off + count);\r\nreturn count;\r\n}\r\nstatic ssize_t logger_aio_write(struct kiocb *iocb, const struct iovec *iov,\r\nunsigned long nr_segs, loff_t ppos)\r\n{\r\nstruct logger_log *log = file_get_log(iocb->ki_filp);\r\nsize_t orig = log->w_off;\r\nstruct logger_entry header;\r\nstruct timespec now;\r\nssize_t ret = 0;\r\nnow = current_kernel_time();\r\nheader.pid = current->tgid;\r\nheader.tid = current->pid;\r\nheader.sec = now.tv_sec;\r\nheader.nsec = now.tv_nsec;\r\nheader.len = min_t(size_t, iocb->ki_left, LOGGER_ENTRY_MAX_PAYLOAD);\r\nif (unlikely(!header.len))\r\nreturn 0;\r\nmutex_lock(&log->mutex);\r\nfix_up_readers(log, sizeof(struct logger_entry) + header.len);\r\ndo_write_log(log, &header, sizeof(struct logger_entry));\r\nwhile (nr_segs-- > 0) {\r\nsize_t len;\r\nssize_t nr;\r\nlen = min_t(size_t, iov->iov_len, header.len - ret);\r\nnr = do_write_log_from_user(log, iov->iov_base, len);\r\nif (unlikely(nr < 0)) {\r\nlog->w_off = orig;\r\nmutex_unlock(&log->mutex);\r\nreturn nr;\r\n}\r\niov++;\r\nret += nr;\r\n}\r\nmutex_unlock(&log->mutex);\r\nwake_up_interruptible(&log->wq);\r\nreturn ret;\r\n}\r\nstatic struct logger_log *get_log_from_minor(int minor)\r\n{\r\nstruct logger_log *log;\r\nlist_for_each_entry(log, &log_list, logs)\r\nif (log->misc.minor == minor)\r\nreturn log;\r\nreturn NULL;\r\n}\r\nstatic int logger_open(struct inode *inode, struct file *file)\r\n{\r\nstruct logger_log *log;\r\nint ret;\r\nret = nonseekable_open(inode, file);\r\nif (ret)\r\nreturn ret;\r\nlog = get_log_from_minor(MINOR(inode->i_rdev));\r\nif (!log)\r\nreturn -ENODEV;\r\nif (file->f_mode & FMODE_READ) {\r\nstruct logger_reader *reader;\r\nreader = kmalloc(sizeof(struct logger_reader), GFP_KERNEL);\r\nif (!reader)\r\nreturn -ENOMEM;\r\nreader->log = log;\r\nINIT_LIST_HEAD(&reader->list);\r\nmutex_lock(&log->mutex);\r\nreader->r_off = log->head;\r\nlist_add_tail(&reader->list, &log->readers);\r\nmutex_unlock(&log->mutex);\r\nfile->private_data = reader;\r\n} else\r\nfile->private_data = log;\r\nreturn 0;\r\n}\r\nstatic int logger_release(struct inode *ignored, struct file *file)\r\n{\r\nif (file->f_mode & FMODE_READ) {\r\nstruct logger_reader *reader = file->private_data;\r\nstruct logger_log *log = reader->log;\r\nmutex_lock(&log->mutex);\r\nlist_del(&reader->list);\r\nmutex_unlock(&log->mutex);\r\nkfree(reader);\r\n}\r\nreturn 0;\r\n}\r\nstatic unsigned int logger_poll(struct file *file, poll_table *wait)\r\n{\r\nstruct logger_reader *reader;\r\nstruct logger_log *log;\r\nunsigned int ret = POLLOUT | POLLWRNORM;\r\nif (!(file->f_mode & FMODE_READ))\r\nreturn ret;\r\nreader = file->private_data;\r\nlog = reader->log;\r\npoll_wait(file, &log->wq, wait);\r\nmutex_lock(&log->mutex);\r\nif (log->w_off != reader->r_off)\r\nret |= POLLIN | POLLRDNORM;\r\nmutex_unlock(&log->mutex);\r\nreturn ret;\r\n}\r\nstatic long logger_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\r\n{\r\nstruct logger_log *log = file_get_log(file);\r\nstruct logger_reader *reader;\r\nlong ret = -ENOTTY;\r\nmutex_lock(&log->mutex);\r\nswitch (cmd) {\r\ncase LOGGER_GET_LOG_BUF_SIZE:\r\nret = log->size;\r\nbreak;\r\ncase LOGGER_GET_LOG_LEN:\r\nif (!(file->f_mode & FMODE_READ)) {\r\nret = -EBADF;\r\nbreak;\r\n}\r\nreader = file->private_data;\r\nif (log->w_off >= reader->r_off)\r\nret = log->w_off - reader->r_off;\r\nelse\r\nret = (log->size - reader->r_off) + log->w_off;\r\nbreak;\r\ncase LOGGER_GET_NEXT_ENTRY_LEN:\r\nif (!(file->f_mode & FMODE_READ)) {\r\nret = -EBADF;\r\nbreak;\r\n}\r\nreader = file->private_data;\r\nif (log->w_off != reader->r_off)\r\nret = get_entry_len(log, reader->r_off);\r\nelse\r\nret = 0;\r\nbreak;\r\ncase LOGGER_FLUSH_LOG:\r\nif (!(file->f_mode & FMODE_WRITE)) {\r\nret = -EBADF;\r\nbreak;\r\n}\r\nlist_for_each_entry(reader, &log->readers, list)\r\nreader->r_off = log->w_off;\r\nlog->head = log->w_off;\r\nret = 0;\r\nbreak;\r\n}\r\nmutex_unlock(&log->mutex);\r\nreturn ret;\r\n}\r\nstatic int __init create_log(char *log_name, int size)\r\n{\r\nint ret = 0;\r\nstruct logger_log *log;\r\nunsigned char *buffer;\r\nbuffer = vmalloc(size);\r\nif (buffer == NULL)\r\nreturn -ENOMEM;\r\nlog = kzalloc(sizeof(struct logger_log), GFP_KERNEL);\r\nif (log == NULL) {\r\nret = -ENOMEM;\r\ngoto out_free_buffer;\r\n}\r\nlog->buffer = buffer;\r\nlog->misc.minor = MISC_DYNAMIC_MINOR;\r\nlog->misc.name = kstrdup(log_name, GFP_KERNEL);\r\nif (log->misc.name == NULL) {\r\nret = -ENOMEM;\r\ngoto out_free_log;\r\n}\r\nlog->misc.fops = &logger_fops;\r\nlog->misc.parent = NULL;\r\ninit_waitqueue_head(&log->wq);\r\nINIT_LIST_HEAD(&log->readers);\r\nmutex_init(&log->mutex);\r\nlog->w_off = 0;\r\nlog->head = 0;\r\nlog->size = size;\r\nINIT_LIST_HEAD(&log->logs);\r\nlist_add_tail(&log->logs, &log_list);\r\nret = misc_register(&log->misc);\r\nif (unlikely(ret)) {\r\npr_err("failed to register misc device for log '%s'!\n",\r\nlog->misc.name);\r\ngoto out_free_log;\r\n}\r\npr_info("created %luK log '%s'\n",\r\n(unsigned long) log->size >> 10, log->misc.name);\r\nreturn 0;\r\nout_free_log:\r\nkfree(log);\r\nout_free_buffer:\r\nvfree(buffer);\r\nreturn ret;\r\n}\r\nstatic int __init logger_init(void)\r\n{\r\nint ret;\r\nret = create_log(LOGGER_LOG_MAIN, 256*1024);\r\nif (unlikely(ret))\r\ngoto out;\r\nret = create_log(LOGGER_LOG_EVENTS, 256*1024);\r\nif (unlikely(ret))\r\ngoto out;\r\nret = create_log(LOGGER_LOG_RADIO, 256*1024);\r\nif (unlikely(ret))\r\ngoto out;\r\nret = create_log(LOGGER_LOG_SYSTEM, 256*1024);\r\nif (unlikely(ret))\r\ngoto out;\r\nout:\r\nreturn ret;\r\n}\r\nstatic void __exit logger_exit(void)\r\n{\r\nstruct logger_log *current_log, *next_log;\r\nlist_for_each_entry_safe(current_log, next_log, &log_list, logs) {\r\nmisc_deregister(&current_log->misc);\r\nvfree(current_log->buffer);\r\nkfree(current_log->misc.name);\r\nlist_del(&current_log->logs);\r\nkfree(current_log);\r\n}\r\n}
