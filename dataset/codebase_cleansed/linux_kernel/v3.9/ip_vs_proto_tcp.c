static int\r\ntcp_conn_schedule(int af, struct sk_buff *skb, struct ip_vs_proto_data *pd,\r\nint *verdict, struct ip_vs_conn **cpp,\r\nstruct ip_vs_iphdr *iph)\r\n{\r\nstruct net *net;\r\nstruct ip_vs_service *svc;\r\nstruct tcphdr _tcph, *th;\r\nth = skb_header_pointer(skb, iph->len, sizeof(_tcph), &_tcph);\r\nif (th == NULL) {\r\n*verdict = NF_DROP;\r\nreturn 0;\r\n}\r\nnet = skb_net(skb);\r\nif (th->syn &&\r\n(svc = ip_vs_service_get(net, af, skb->mark, iph->protocol,\r\n&iph->daddr, th->dest))) {\r\nint ignored;\r\nif (ip_vs_todrop(net_ipvs(net))) {\r\nip_vs_service_put(svc);\r\n*verdict = NF_DROP;\r\nreturn 0;\r\n}\r\n*cpp = ip_vs_schedule(svc, skb, pd, &ignored, iph);\r\nif (!*cpp && ignored <= 0) {\r\nif (!ignored)\r\n*verdict = ip_vs_leave(svc, skb, pd, iph);\r\nelse {\r\nip_vs_service_put(svc);\r\n*verdict = NF_DROP;\r\n}\r\nreturn 0;\r\n}\r\nip_vs_service_put(svc);\r\n}\r\nreturn 1;\r\n}\r\nstatic inline void\r\ntcp_fast_csum_update(int af, struct tcphdr *tcph,\r\nconst union nf_inet_addr *oldip,\r\nconst union nf_inet_addr *newip,\r\n__be16 oldport, __be16 newport)\r\n{\r\n#ifdef CONFIG_IP_VS_IPV6\r\nif (af == AF_INET6)\r\ntcph->check =\r\ncsum_fold(ip_vs_check_diff16(oldip->ip6, newip->ip6,\r\nip_vs_check_diff2(oldport, newport,\r\n~csum_unfold(tcph->check))));\r\nelse\r\n#endif\r\ntcph->check =\r\ncsum_fold(ip_vs_check_diff4(oldip->ip, newip->ip,\r\nip_vs_check_diff2(oldport, newport,\r\n~csum_unfold(tcph->check))));\r\n}\r\nstatic inline void\r\ntcp_partial_csum_update(int af, struct tcphdr *tcph,\r\nconst union nf_inet_addr *oldip,\r\nconst union nf_inet_addr *newip,\r\n__be16 oldlen, __be16 newlen)\r\n{\r\n#ifdef CONFIG_IP_VS_IPV6\r\nif (af == AF_INET6)\r\ntcph->check =\r\n~csum_fold(ip_vs_check_diff16(oldip->ip6, newip->ip6,\r\nip_vs_check_diff2(oldlen, newlen,\r\ncsum_unfold(tcph->check))));\r\nelse\r\n#endif\r\ntcph->check =\r\n~csum_fold(ip_vs_check_diff4(oldip->ip, newip->ip,\r\nip_vs_check_diff2(oldlen, newlen,\r\ncsum_unfold(tcph->check))));\r\n}\r\nstatic int\r\ntcp_snat_handler(struct sk_buff *skb, struct ip_vs_protocol *pp,\r\nstruct ip_vs_conn *cp, struct ip_vs_iphdr *iph)\r\n{\r\nstruct tcphdr *tcph;\r\nunsigned int tcphoff = iph->len;\r\nint oldlen;\r\nint payload_csum = 0;\r\n#ifdef CONFIG_IP_VS_IPV6\r\nif (cp->af == AF_INET6 && iph->fragoffs)\r\nreturn 1;\r\n#endif\r\noldlen = skb->len - tcphoff;\r\nif (!skb_make_writable(skb, tcphoff+sizeof(*tcph)))\r\nreturn 0;\r\nif (unlikely(cp->app != NULL)) {\r\nint ret;\r\nif (pp->csum_check && !pp->csum_check(cp->af, skb, pp))\r\nreturn 0;\r\nif (!(ret = ip_vs_app_pkt_out(cp, skb)))\r\nreturn 0;\r\nif (ret == 1)\r\noldlen = skb->len - tcphoff;\r\nelse\r\npayload_csum = 1;\r\n}\r\ntcph = (void *)skb_network_header(skb) + tcphoff;\r\ntcph->source = cp->vport;\r\nif (skb->ip_summed == CHECKSUM_PARTIAL) {\r\ntcp_partial_csum_update(cp->af, tcph, &cp->daddr, &cp->vaddr,\r\nhtons(oldlen),\r\nhtons(skb->len - tcphoff));\r\n} else if (!payload_csum) {\r\ntcp_fast_csum_update(cp->af, tcph, &cp->daddr, &cp->vaddr,\r\ncp->dport, cp->vport);\r\nif (skb->ip_summed == CHECKSUM_COMPLETE)\r\nskb->ip_summed = (cp->app && pp->csum_check) ?\r\nCHECKSUM_UNNECESSARY : CHECKSUM_NONE;\r\n} else {\r\ntcph->check = 0;\r\nskb->csum = skb_checksum(skb, tcphoff, skb->len - tcphoff, 0);\r\n#ifdef CONFIG_IP_VS_IPV6\r\nif (cp->af == AF_INET6)\r\ntcph->check = csum_ipv6_magic(&cp->vaddr.in6,\r\n&cp->caddr.in6,\r\nskb->len - tcphoff,\r\ncp->protocol, skb->csum);\r\nelse\r\n#endif\r\ntcph->check = csum_tcpudp_magic(cp->vaddr.ip,\r\ncp->caddr.ip,\r\nskb->len - tcphoff,\r\ncp->protocol,\r\nskb->csum);\r\nskb->ip_summed = CHECKSUM_UNNECESSARY;\r\nIP_VS_DBG(11, "O-pkt: %s O-csum=%d (+%zd)\n",\r\npp->name, tcph->check,\r\n(char*)&(tcph->check) - (char*)tcph);\r\n}\r\nreturn 1;\r\n}\r\nstatic int\r\ntcp_dnat_handler(struct sk_buff *skb, struct ip_vs_protocol *pp,\r\nstruct ip_vs_conn *cp, struct ip_vs_iphdr *iph)\r\n{\r\nstruct tcphdr *tcph;\r\nunsigned int tcphoff = iph->len;\r\nint oldlen;\r\nint payload_csum = 0;\r\n#ifdef CONFIG_IP_VS_IPV6\r\nif (cp->af == AF_INET6 && iph->fragoffs)\r\nreturn 1;\r\n#endif\r\noldlen = skb->len - tcphoff;\r\nif (!skb_make_writable(skb, tcphoff+sizeof(*tcph)))\r\nreturn 0;\r\nif (unlikely(cp->app != NULL)) {\r\nint ret;\r\nif (pp->csum_check && !pp->csum_check(cp->af, skb, pp))\r\nreturn 0;\r\nif (!(ret = ip_vs_app_pkt_in(cp, skb)))\r\nreturn 0;\r\nif (ret == 1)\r\noldlen = skb->len - tcphoff;\r\nelse\r\npayload_csum = 1;\r\n}\r\ntcph = (void *)skb_network_header(skb) + tcphoff;\r\ntcph->dest = cp->dport;\r\nif (skb->ip_summed == CHECKSUM_PARTIAL) {\r\ntcp_partial_csum_update(cp->af, tcph, &cp->vaddr, &cp->daddr,\r\nhtons(oldlen),\r\nhtons(skb->len - tcphoff));\r\n} else if (!payload_csum) {\r\ntcp_fast_csum_update(cp->af, tcph, &cp->vaddr, &cp->daddr,\r\ncp->vport, cp->dport);\r\nif (skb->ip_summed == CHECKSUM_COMPLETE)\r\nskb->ip_summed = (cp->app && pp->csum_check) ?\r\nCHECKSUM_UNNECESSARY : CHECKSUM_NONE;\r\n} else {\r\ntcph->check = 0;\r\nskb->csum = skb_checksum(skb, tcphoff, skb->len - tcphoff, 0);\r\n#ifdef CONFIG_IP_VS_IPV6\r\nif (cp->af == AF_INET6)\r\ntcph->check = csum_ipv6_magic(&cp->caddr.in6,\r\n&cp->daddr.in6,\r\nskb->len - tcphoff,\r\ncp->protocol, skb->csum);\r\nelse\r\n#endif\r\ntcph->check = csum_tcpudp_magic(cp->caddr.ip,\r\ncp->daddr.ip,\r\nskb->len - tcphoff,\r\ncp->protocol,\r\nskb->csum);\r\nskb->ip_summed = CHECKSUM_UNNECESSARY;\r\n}\r\nreturn 1;\r\n}\r\nstatic int\r\ntcp_csum_check(int af, struct sk_buff *skb, struct ip_vs_protocol *pp)\r\n{\r\nunsigned int tcphoff;\r\n#ifdef CONFIG_IP_VS_IPV6\r\nif (af == AF_INET6)\r\ntcphoff = sizeof(struct ipv6hdr);\r\nelse\r\n#endif\r\ntcphoff = ip_hdrlen(skb);\r\nswitch (skb->ip_summed) {\r\ncase CHECKSUM_NONE:\r\nskb->csum = skb_checksum(skb, tcphoff, skb->len - tcphoff, 0);\r\ncase CHECKSUM_COMPLETE:\r\n#ifdef CONFIG_IP_VS_IPV6\r\nif (af == AF_INET6) {\r\nif (csum_ipv6_magic(&ipv6_hdr(skb)->saddr,\r\n&ipv6_hdr(skb)->daddr,\r\nskb->len - tcphoff,\r\nipv6_hdr(skb)->nexthdr,\r\nskb->csum)) {\r\nIP_VS_DBG_RL_PKT(0, af, pp, skb, 0,\r\n"Failed checksum for");\r\nreturn 0;\r\n}\r\n} else\r\n#endif\r\nif (csum_tcpudp_magic(ip_hdr(skb)->saddr,\r\nip_hdr(skb)->daddr,\r\nskb->len - tcphoff,\r\nip_hdr(skb)->protocol,\r\nskb->csum)) {\r\nIP_VS_DBG_RL_PKT(0, af, pp, skb, 0,\r\n"Failed checksum for");\r\nreturn 0;\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn 1;\r\n}\r\nstatic const char * tcp_state_name(int state)\r\n{\r\nif (state >= IP_VS_TCP_S_LAST)\r\nreturn "ERR!";\r\nreturn tcp_state_name_table[state] ? tcp_state_name_table[state] : "?";\r\n}\r\nstatic void tcp_timeout_change(struct ip_vs_proto_data *pd, int flags)\r\n{\r\nint on = (flags & 1);\r\npd->tcp_state_table = (on ? tcp_states_dos : tcp_states);\r\n}\r\nstatic inline int tcp_state_idx(struct tcphdr *th)\r\n{\r\nif (th->rst)\r\nreturn 3;\r\nif (th->syn)\r\nreturn 0;\r\nif (th->fin)\r\nreturn 1;\r\nif (th->ack)\r\nreturn 2;\r\nreturn -1;\r\n}\r\nstatic inline void\r\nset_tcp_state(struct ip_vs_proto_data *pd, struct ip_vs_conn *cp,\r\nint direction, struct tcphdr *th)\r\n{\r\nint state_idx;\r\nint new_state = IP_VS_TCP_S_CLOSE;\r\nint state_off = tcp_state_off[direction];\r\nif (cp->flags & IP_VS_CONN_F_NOOUTPUT) {\r\nif (state_off == TCP_DIR_OUTPUT)\r\ncp->flags &= ~IP_VS_CONN_F_NOOUTPUT;\r\nelse\r\nstate_off = TCP_DIR_INPUT_ONLY;\r\n}\r\nif ((state_idx = tcp_state_idx(th)) < 0) {\r\nIP_VS_DBG(8, "tcp_state_idx=%d!!!\n", state_idx);\r\ngoto tcp_state_out;\r\n}\r\nnew_state =\r\npd->tcp_state_table[state_off+state_idx].next_state[cp->state];\r\ntcp_state_out:\r\nif (new_state != cp->state) {\r\nstruct ip_vs_dest *dest = cp->dest;\r\nIP_VS_DBG_BUF(8, "%s %s [%c%c%c%c] %s:%d->"\r\n"%s:%d state: %s->%s conn->refcnt:%d\n",\r\npd->pp->name,\r\n((state_off == TCP_DIR_OUTPUT) ?\r\n"output " : "input "),\r\nth->syn ? 'S' : '.',\r\nth->fin ? 'F' : '.',\r\nth->ack ? 'A' : '.',\r\nth->rst ? 'R' : '.',\r\nIP_VS_DBG_ADDR(cp->af, &cp->daddr),\r\nntohs(cp->dport),\r\nIP_VS_DBG_ADDR(cp->af, &cp->caddr),\r\nntohs(cp->cport),\r\ntcp_state_name(cp->state),\r\ntcp_state_name(new_state),\r\natomic_read(&cp->refcnt));\r\nif (dest) {\r\nif (!(cp->flags & IP_VS_CONN_F_INACTIVE) &&\r\n(new_state != IP_VS_TCP_S_ESTABLISHED)) {\r\natomic_dec(&dest->activeconns);\r\natomic_inc(&dest->inactconns);\r\ncp->flags |= IP_VS_CONN_F_INACTIVE;\r\n} else if ((cp->flags & IP_VS_CONN_F_INACTIVE) &&\r\n(new_state == IP_VS_TCP_S_ESTABLISHED)) {\r\natomic_inc(&dest->activeconns);\r\natomic_dec(&dest->inactconns);\r\ncp->flags &= ~IP_VS_CONN_F_INACTIVE;\r\n}\r\n}\r\n}\r\nif (likely(pd))\r\ncp->timeout = pd->timeout_table[cp->state = new_state];\r\nelse\r\ncp->timeout = tcp_timeouts[cp->state = new_state];\r\n}\r\nstatic void\r\ntcp_state_transition(struct ip_vs_conn *cp, int direction,\r\nconst struct sk_buff *skb,\r\nstruct ip_vs_proto_data *pd)\r\n{\r\nstruct tcphdr _tcph, *th;\r\n#ifdef CONFIG_IP_VS_IPV6\r\nint ihl = cp->af == AF_INET ? ip_hdrlen(skb) : sizeof(struct ipv6hdr);\r\n#else\r\nint ihl = ip_hdrlen(skb);\r\n#endif\r\nth = skb_header_pointer(skb, ihl, sizeof(_tcph), &_tcph);\r\nif (th == NULL)\r\nreturn;\r\nspin_lock(&cp->lock);\r\nset_tcp_state(pd, cp, direction, th);\r\nspin_unlock(&cp->lock);\r\n}\r\nstatic inline __u16 tcp_app_hashkey(__be16 port)\r\n{\r\nreturn (((__force u16)port >> TCP_APP_TAB_BITS) ^ (__force u16)port)\r\n& TCP_APP_TAB_MASK;\r\n}\r\nstatic int tcp_register_app(struct net *net, struct ip_vs_app *inc)\r\n{\r\nstruct ip_vs_app *i;\r\n__u16 hash;\r\n__be16 port = inc->port;\r\nint ret = 0;\r\nstruct netns_ipvs *ipvs = net_ipvs(net);\r\nstruct ip_vs_proto_data *pd = ip_vs_proto_data_get(net, IPPROTO_TCP);\r\nhash = tcp_app_hashkey(port);\r\nspin_lock_bh(&ipvs->tcp_app_lock);\r\nlist_for_each_entry(i, &ipvs->tcp_apps[hash], p_list) {\r\nif (i->port == port) {\r\nret = -EEXIST;\r\ngoto out;\r\n}\r\n}\r\nlist_add(&inc->p_list, &ipvs->tcp_apps[hash]);\r\natomic_inc(&pd->appcnt);\r\nout:\r\nspin_unlock_bh(&ipvs->tcp_app_lock);\r\nreturn ret;\r\n}\r\nstatic void\r\ntcp_unregister_app(struct net *net, struct ip_vs_app *inc)\r\n{\r\nstruct netns_ipvs *ipvs = net_ipvs(net);\r\nstruct ip_vs_proto_data *pd = ip_vs_proto_data_get(net, IPPROTO_TCP);\r\nspin_lock_bh(&ipvs->tcp_app_lock);\r\natomic_dec(&pd->appcnt);\r\nlist_del(&inc->p_list);\r\nspin_unlock_bh(&ipvs->tcp_app_lock);\r\n}\r\nstatic int\r\ntcp_app_conn_bind(struct ip_vs_conn *cp)\r\n{\r\nstruct netns_ipvs *ipvs = net_ipvs(ip_vs_conn_net(cp));\r\nint hash;\r\nstruct ip_vs_app *inc;\r\nint result = 0;\r\nif (IP_VS_FWD_METHOD(cp) != IP_VS_CONN_F_MASQ)\r\nreturn 0;\r\nhash = tcp_app_hashkey(cp->vport);\r\nspin_lock(&ipvs->tcp_app_lock);\r\nlist_for_each_entry(inc, &ipvs->tcp_apps[hash], p_list) {\r\nif (inc->port == cp->vport) {\r\nif (unlikely(!ip_vs_app_inc_get(inc)))\r\nbreak;\r\nspin_unlock(&ipvs->tcp_app_lock);\r\nIP_VS_DBG_BUF(9, "%s(): Binding conn %s:%u->"\r\n"%s:%u to app %s on port %u\n",\r\n__func__,\r\nIP_VS_DBG_ADDR(cp->af, &cp->caddr),\r\nntohs(cp->cport),\r\nIP_VS_DBG_ADDR(cp->af, &cp->vaddr),\r\nntohs(cp->vport),\r\ninc->name, ntohs(inc->port));\r\ncp->app = inc;\r\nif (inc->init_conn)\r\nresult = inc->init_conn(inc, cp);\r\ngoto out;\r\n}\r\n}\r\nspin_unlock(&ipvs->tcp_app_lock);\r\nout:\r\nreturn result;\r\n}\r\nvoid ip_vs_tcp_conn_listen(struct net *net, struct ip_vs_conn *cp)\r\n{\r\nstruct ip_vs_proto_data *pd = ip_vs_proto_data_get(net, IPPROTO_TCP);\r\nspin_lock(&cp->lock);\r\ncp->state = IP_VS_TCP_S_LISTEN;\r\ncp->timeout = (pd ? pd->timeout_table[IP_VS_TCP_S_LISTEN]\r\n: tcp_timeouts[IP_VS_TCP_S_LISTEN]);\r\nspin_unlock(&cp->lock);\r\n}\r\nstatic int __ip_vs_tcp_init(struct net *net, struct ip_vs_proto_data *pd)\r\n{\r\nstruct netns_ipvs *ipvs = net_ipvs(net);\r\nip_vs_init_hash_table(ipvs->tcp_apps, TCP_APP_TAB_SIZE);\r\nspin_lock_init(&ipvs->tcp_app_lock);\r\npd->timeout_table = ip_vs_create_timeout_table((int *)tcp_timeouts,\r\nsizeof(tcp_timeouts));\r\nif (!pd->timeout_table)\r\nreturn -ENOMEM;\r\npd->tcp_state_table = tcp_states;\r\nreturn 0;\r\n}\r\nstatic void __ip_vs_tcp_exit(struct net *net, struct ip_vs_proto_data *pd)\r\n{\r\nkfree(pd->timeout_table);\r\n}
