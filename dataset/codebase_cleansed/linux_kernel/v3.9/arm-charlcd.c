static irqreturn_t charlcd_interrupt(int irq, void *data)\r\n{\r\nstruct charlcd *lcd = data;\r\nu8 status;\r\nstatus = readl(lcd->virtbase + CHAR_STAT) & 0x01;\r\nwritel(CHAR_RAW_CLEAR, lcd->virtbase + CHAR_RAW);\r\nif (status)\r\ncomplete(&lcd->complete);\r\nelse\r\ndev_info(lcd->dev, "Spurious IRQ (%02x)\n", status);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void charlcd_wait_complete_irq(struct charlcd *lcd)\r\n{\r\nint ret;\r\nret = wait_for_completion_interruptible_timeout(&lcd->complete,\r\nCHARLCD_TIMEOUT);\r\nwritel(0x00, lcd->virtbase + CHAR_MASK);\r\nif (ret < 0) {\r\ndev_err(lcd->dev,\r\n"wait_for_completion_interruptible_timeout() "\r\n"returned %d waiting for ready\n", ret);\r\nreturn;\r\n}\r\nif (ret == 0) {\r\ndev_err(lcd->dev, "charlcd controller timed out "\r\n"waiting for ready\n");\r\nreturn;\r\n}\r\n}\r\nstatic u8 charlcd_4bit_read_char(struct charlcd *lcd)\r\n{\r\nu8 data;\r\nu32 val;\r\nint i;\r\nif (lcd->irq >= 0)\r\ncharlcd_wait_complete_irq(lcd);\r\nelse {\r\ni = 0;\r\nval = 0;\r\nwhile (!(val & CHAR_RAW_VALID) && i < 10) {\r\nudelay(100);\r\nval = readl(lcd->virtbase + CHAR_RAW);\r\ni++;\r\n}\r\nwritel(CHAR_RAW_CLEAR, lcd->virtbase + CHAR_RAW);\r\n}\r\nmsleep(1);\r\ndata = readl(lcd->virtbase + CHAR_RD) & 0xf0;\r\ni = 0;\r\nval = 0;\r\nwhile (!(val & CHAR_RAW_VALID) && i < 10) {\r\nudelay(100);\r\nval = readl(lcd->virtbase + CHAR_RAW);\r\ni++;\r\n}\r\nwritel(CHAR_RAW_CLEAR, lcd->virtbase + CHAR_RAW);\r\nmsleep(1);\r\ndata |= (readl(lcd->virtbase + CHAR_RD) >> 4) & 0x0f;\r\nreturn data;\r\n}\r\nstatic bool charlcd_4bit_read_bf(struct charlcd *lcd)\r\n{\r\nif (lcd->irq >= 0) {\r\nwritel(CHAR_RAW_CLEAR, lcd->virtbase + CHAR_RAW);\r\ninit_completion(&lcd->complete);\r\nwritel(0x01, lcd->virtbase + CHAR_MASK);\r\n}\r\nreadl(lcd->virtbase + CHAR_COM);\r\nreturn charlcd_4bit_read_char(lcd) & HD_BUSY_FLAG ? true : false;\r\n}\r\nstatic void charlcd_4bit_wait_busy(struct charlcd *lcd)\r\n{\r\nint retries = 50;\r\nudelay(100);\r\nwhile (charlcd_4bit_read_bf(lcd) && retries)\r\nretries--;\r\nif (!retries)\r\ndev_err(lcd->dev, "timeout waiting for busyflag\n");\r\n}\r\nstatic void charlcd_4bit_command(struct charlcd *lcd, u8 cmd)\r\n{\r\nu32 cmdlo = (cmd << 4) & 0xf0;\r\nu32 cmdhi = (cmd & 0xf0);\r\nwritel(cmdhi, lcd->virtbase + CHAR_COM);\r\nudelay(10);\r\nwritel(cmdlo, lcd->virtbase + CHAR_COM);\r\ncharlcd_4bit_wait_busy(lcd);\r\n}\r\nstatic void charlcd_4bit_char(struct charlcd *lcd, u8 ch)\r\n{\r\nu32 chlo = (ch << 4) & 0xf0;\r\nu32 chhi = (ch & 0xf0);\r\nwritel(chhi, lcd->virtbase + CHAR_DAT);\r\nudelay(10);\r\nwritel(chlo, lcd->virtbase + CHAR_DAT);\r\ncharlcd_4bit_wait_busy(lcd);\r\n}\r\nstatic void charlcd_4bit_print(struct charlcd *lcd, int line, const char *str)\r\n{\r\nu8 offset;\r\nint i;\r\nif (line == 0)\r\noffset = 0;\r\nelse if (line == 1)\r\noffset = 0x28;\r\nelse\r\nreturn;\r\ncharlcd_4bit_command(lcd, HD_SET_DDRAM | offset);\r\nfor (i = 0; i < strlen(str) && i < 0x28; i++)\r\ncharlcd_4bit_char(lcd, str[i]);\r\n}\r\nstatic void charlcd_4bit_init(struct charlcd *lcd)\r\n{\r\nwritel(HD_FUNCSET | HD_FUNCSET_8BIT, lcd->virtbase + CHAR_COM);\r\nmsleep(5);\r\nwritel(HD_FUNCSET | HD_FUNCSET_8BIT, lcd->virtbase + CHAR_COM);\r\nudelay(100);\r\nwritel(HD_FUNCSET | HD_FUNCSET_8BIT, lcd->virtbase + CHAR_COM);\r\nudelay(100);\r\nwritel(HD_FUNCSET, lcd->virtbase + CHAR_COM);\r\nudelay(100);\r\ncharlcd_4bit_command(lcd, HD_FUNCSET | HD_FUNCSET_2_LINES);\r\ncharlcd_4bit_command(lcd, HD_DISPCTRL | HD_DISPCTRL_ON);\r\ncharlcd_4bit_command(lcd, HD_ENTRYMODE | HD_ENTRYMODE_INCREMENT);\r\ncharlcd_4bit_command(lcd, HD_CLEAR);\r\ncharlcd_4bit_command(lcd, HD_HOME);\r\ncharlcd_4bit_print(lcd, 0, "ARM Linux");\r\ncharlcd_4bit_print(lcd, 1, UTS_RELEASE);\r\n}\r\nstatic void charlcd_init_work(struct work_struct *work)\r\n{\r\nstruct charlcd *lcd =\r\ncontainer_of(work, struct charlcd, init_work.work);\r\ncharlcd_4bit_init(lcd);\r\n}\r\nstatic int __init charlcd_probe(struct platform_device *pdev)\r\n{\r\nint ret;\r\nstruct charlcd *lcd;\r\nstruct resource *res;\r\nlcd = kzalloc(sizeof(struct charlcd), GFP_KERNEL);\r\nif (!lcd)\r\nreturn -ENOMEM;\r\nlcd->dev = &pdev->dev;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!res) {\r\nret = -ENOENT;\r\ngoto out_no_resource;\r\n}\r\nlcd->phybase = res->start;\r\nlcd->physize = resource_size(res);\r\nif (request_mem_region(lcd->phybase, lcd->physize,\r\nDRIVERNAME) == NULL) {\r\nret = -EBUSY;\r\ngoto out_no_memregion;\r\n}\r\nlcd->virtbase = ioremap(lcd->phybase, lcd->physize);\r\nif (!lcd->virtbase) {\r\nret = -ENOMEM;\r\ngoto out_no_remap;\r\n}\r\nlcd->irq = platform_get_irq(pdev, 0);\r\nif (lcd->irq >= 0) {\r\nif (request_irq(lcd->irq, charlcd_interrupt, IRQF_DISABLED,\r\nDRIVERNAME, lcd)) {\r\nret = -EIO;\r\ngoto out_no_irq;\r\n}\r\n}\r\nplatform_set_drvdata(pdev, lcd);\r\nINIT_DELAYED_WORK(&lcd->init_work, charlcd_init_work);\r\nschedule_delayed_work(&lcd->init_work, 0);\r\ndev_info(&pdev->dev, "initialized ARM character LCD at %08x\n",\r\nlcd->phybase);\r\nreturn 0;\r\nout_no_irq:\r\niounmap(lcd->virtbase);\r\nout_no_remap:\r\nplatform_set_drvdata(pdev, NULL);\r\nout_no_memregion:\r\nrelease_mem_region(lcd->phybase, SZ_4K);\r\nout_no_resource:\r\nkfree(lcd);\r\nreturn ret;\r\n}\r\nstatic int __exit charlcd_remove(struct platform_device *pdev)\r\n{\r\nstruct charlcd *lcd = platform_get_drvdata(pdev);\r\nif (lcd) {\r\nfree_irq(lcd->irq, lcd);\r\niounmap(lcd->virtbase);\r\nrelease_mem_region(lcd->phybase, lcd->physize);\r\nplatform_set_drvdata(pdev, NULL);\r\nkfree(lcd);\r\n}\r\nreturn 0;\r\n}\r\nstatic int charlcd_suspend(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct charlcd *lcd = platform_get_drvdata(pdev);\r\ncharlcd_4bit_command(lcd, HD_DISPCTRL);\r\nreturn 0;\r\n}\r\nstatic int charlcd_resume(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct charlcd *lcd = platform_get_drvdata(pdev);\r\ncharlcd_4bit_command(lcd, HD_DISPCTRL | HD_DISPCTRL_ON);\r\nreturn 0;\r\n}\r\nstatic int __init charlcd_init(void)\r\n{\r\nreturn platform_driver_probe(&charlcd_driver, charlcd_probe);\r\n}\r\nstatic void __exit charlcd_exit(void)\r\n{\r\nplatform_driver_unregister(&charlcd_driver);\r\n}
