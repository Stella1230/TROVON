void *mpc85xx_cache_sram_alloc(unsigned int size,\r\nphys_addr_t *phys, unsigned int align)\r\n{\r\nunsigned long offset;\r\nunsigned long flags;\r\nif (unlikely(cache_sram == NULL))\r\nreturn NULL;\r\nif (!size || (size > cache_sram->size) || (align > cache_sram->size)) {\r\npr_err("%s(): size(=%x) or align(=%x) zero or too big\n",\r\n__func__, size, align);\r\nreturn NULL;\r\n}\r\nif ((align & (align - 1)) || align <= 1) {\r\npr_err("%s(): align(=%x) must be power of two and >1\n",\r\n__func__, align);\r\nreturn NULL;\r\n}\r\nspin_lock_irqsave(&cache_sram->lock, flags);\r\noffset = rh_alloc_align(cache_sram->rh, size, align, NULL);\r\nspin_unlock_irqrestore(&cache_sram->lock, flags);\r\nif (IS_ERR_VALUE(offset))\r\nreturn NULL;\r\n*phys = cache_sram->base_phys + offset;\r\nreturn (unsigned char *)cache_sram->base_virt + offset;\r\n}\r\nvoid mpc85xx_cache_sram_free(void *ptr)\r\n{\r\nunsigned long flags;\r\nBUG_ON(!ptr);\r\nspin_lock_irqsave(&cache_sram->lock, flags);\r\nrh_free(cache_sram->rh, ptr - cache_sram->base_virt);\r\nspin_unlock_irqrestore(&cache_sram->lock, flags);\r\n}\r\nint __init instantiate_cache_sram(struct platform_device *dev,\r\nstruct sram_parameters sram_params)\r\n{\r\nint ret = 0;\r\nif (cache_sram) {\r\ndev_err(&dev->dev, "Already initialized cache-sram\n");\r\nreturn -EBUSY;\r\n}\r\ncache_sram = kzalloc(sizeof(struct mpc85xx_cache_sram), GFP_KERNEL);\r\nif (!cache_sram) {\r\ndev_err(&dev->dev, "Out of memory for cache_sram structure\n");\r\nreturn -ENOMEM;\r\n}\r\ncache_sram->base_phys = sram_params.sram_offset;\r\ncache_sram->size = sram_params.sram_size;\r\nif (!request_mem_region(cache_sram->base_phys, cache_sram->size,\r\n"fsl_85xx_cache_sram")) {\r\ndev_err(&dev->dev, "%s: request memory failed\n",\r\ndev->dev.of_node->full_name);\r\nret = -ENXIO;\r\ngoto out_free;\r\n}\r\ncache_sram->base_virt = ioremap_prot(cache_sram->base_phys,\r\ncache_sram->size, _PAGE_COHERENT | PAGE_KERNEL);\r\nif (!cache_sram->base_virt) {\r\ndev_err(&dev->dev, "%s: ioremap_prot failed\n",\r\ndev->dev.of_node->full_name);\r\nret = -ENOMEM;\r\ngoto out_release;\r\n}\r\ncache_sram->rh = rh_create(sizeof(unsigned int));\r\nif (IS_ERR(cache_sram->rh)) {\r\ndev_err(&dev->dev, "%s: Unable to create remote heap\n",\r\ndev->dev.of_node->full_name);\r\nret = PTR_ERR(cache_sram->rh);\r\ngoto out_unmap;\r\n}\r\nrh_attach_region(cache_sram->rh, 0, cache_sram->size);\r\nspin_lock_init(&cache_sram->lock);\r\ndev_info(&dev->dev, "[base:0x%llx, size:0x%x] configured and loaded\n",\r\n(unsigned long long)cache_sram->base_phys, cache_sram->size);\r\nreturn 0;\r\nout_unmap:\r\niounmap(cache_sram->base_virt);\r\nout_release:\r\nrelease_mem_region(cache_sram->base_phys, cache_sram->size);\r\nout_free:\r\nkfree(cache_sram);\r\nreturn ret;\r\n}\r\nvoid remove_cache_sram(struct platform_device *dev)\r\n{\r\nBUG_ON(!cache_sram);\r\nrh_detach_region(cache_sram->rh, 0, cache_sram->size);\r\nrh_destroy(cache_sram->rh);\r\niounmap(cache_sram->base_virt);\r\nrelease_mem_region(cache_sram->base_phys, cache_sram->size);\r\nkfree(cache_sram);\r\ncache_sram = NULL;\r\ndev_info(&dev->dev, "MPC85xx Cache-SRAM driver unloaded\n");\r\n}
