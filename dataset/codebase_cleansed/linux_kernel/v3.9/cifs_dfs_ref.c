static void cifs_dfs_expire_automounts(struct work_struct *work)\r\n{\r\nstruct list_head *list = &cifs_dfs_automount_list;\r\nmark_mounts_for_expiry(list);\r\nif (!list_empty(list))\r\nschedule_delayed_work(&cifs_dfs_automount_task,\r\ncifs_dfs_mountpoint_expiry_timeout);\r\n}\r\nvoid cifs_dfs_release_automount_timer(void)\r\n{\r\nBUG_ON(!list_empty(&cifs_dfs_automount_list));\r\ncancel_delayed_work_sync(&cifs_dfs_automount_task);\r\n}\r\nstatic char *cifs_get_share_name(const char *node_name)\r\n{\r\nint len;\r\nchar *UNC;\r\nchar *pSep;\r\nlen = strlen(node_name);\r\nUNC = kmalloc(len+2 ,\r\nGFP_KERNEL);\r\nif (!UNC)\r\nreturn ERR_PTR(-ENOMEM);\r\nif (node_name[1] != '\\') {\r\nUNC[0] = '\\';\r\nstrncpy(UNC+1, node_name, len);\r\nlen++;\r\nUNC[len] = 0;\r\n} else {\r\nstrncpy(UNC, node_name, len);\r\nUNC[len] = 0;\r\n}\r\npSep = memchr(UNC+2, '\\', len-2);\r\nif (!pSep) {\r\ncERROR(1, "%s: no server name end in node name: %s",\r\n__func__, node_name);\r\nkfree(UNC);\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\npSep++;\r\npSep = memchr(UNC+(pSep-UNC), '\\', len-(pSep-UNC));\r\nif (pSep) {\r\n*pSep = 0;\r\n}\r\nreturn UNC;\r\n}\r\nchar *cifs_compose_mount_options(const char *sb_mountdata,\r\nconst char *fullpath,\r\nconst struct dfs_info3_param *ref,\r\nchar **devname)\r\n{\r\nint rc;\r\nchar *mountdata = NULL;\r\nint md_len;\r\nchar *tkn_e;\r\nchar *srvIP = NULL;\r\nchar sep = ',';\r\nint off, noff;\r\nif (sb_mountdata == NULL)\r\nreturn ERR_PTR(-EINVAL);\r\n*devname = cifs_get_share_name(ref->node_name);\r\nif (IS_ERR(*devname)) {\r\nrc = PTR_ERR(*devname);\r\n*devname = NULL;\r\ngoto compose_mount_options_err;\r\n}\r\nrc = dns_resolve_server_name_to_ip(*devname, &srvIP);\r\nif (rc < 0) {\r\ncFYI(1, "%s: Failed to resolve server part of %s to IP: %d",\r\n__func__, *devname, rc);\r\ngoto compose_mount_options_err;\r\n}\r\nmd_len = strlen(sb_mountdata) + rc + strlen(ref->node_name) + 12;\r\nmountdata = kzalloc(md_len+1, GFP_KERNEL);\r\nif (mountdata == NULL) {\r\nrc = -ENOMEM;\r\ngoto compose_mount_options_err;\r\n}\r\noff = 0;\r\nif (strncmp(sb_mountdata, "sep=", 4) == 0) {\r\nsep = sb_mountdata[4];\r\nstrncpy(mountdata, sb_mountdata, 5);\r\noff += 5;\r\n}\r\ndo {\r\ntkn_e = strchr(sb_mountdata + off, sep);\r\nif (tkn_e == NULL)\r\nnoff = strlen(sb_mountdata + off);\r\nelse\r\nnoff = tkn_e - (sb_mountdata + off) + 1;\r\nif (strnicmp(sb_mountdata + off, "unc=", 4) == 0) {\r\noff += noff;\r\ncontinue;\r\n}\r\nif (strnicmp(sb_mountdata + off, "ip=", 3) == 0) {\r\noff += noff;\r\ncontinue;\r\n}\r\nif (strnicmp(sb_mountdata + off, "prefixpath=", 11) == 0) {\r\noff += noff;\r\ncontinue;\r\n}\r\nstrncat(mountdata, sb_mountdata + off, noff);\r\noff += noff;\r\n} while (tkn_e);\r\nstrcat(mountdata, sb_mountdata + off);\r\nmountdata[md_len] = '\0';\r\nif (mountdata[strlen(mountdata) - 1] != sep)\r\nstrncat(mountdata, &sep, 1);\r\nstrcat(mountdata, "ip=");\r\nstrcat(mountdata, srvIP);\r\nstrncat(mountdata, &sep, 1);\r\nstrcat(mountdata, "unc=");\r\nstrcat(mountdata, *devname);\r\ntkn_e = strchr(ref->node_name + 2, '\\');\r\nif (tkn_e == NULL) {\r\nrc = -EINVAL;\r\ngoto compose_mount_options_err;\r\n}\r\ntkn_e = strchr(tkn_e + 1, '\\');\r\nif (tkn_e || (strlen(fullpath) - ref->path_consumed)) {\r\nstrncat(mountdata, &sep, 1);\r\nstrcat(mountdata, "prefixpath=");\r\nif (tkn_e)\r\nstrcat(mountdata, tkn_e + 1);\r\nstrcat(mountdata, fullpath + ref->path_consumed);\r\n}\r\ncompose_mount_options_out:\r\nkfree(srvIP);\r\nreturn mountdata;\r\ncompose_mount_options_err:\r\nkfree(mountdata);\r\nmountdata = ERR_PTR(rc);\r\nkfree(*devname);\r\n*devname = NULL;\r\ngoto compose_mount_options_out;\r\n}\r\nstatic struct vfsmount *cifs_dfs_do_refmount(struct cifs_sb_info *cifs_sb,\r\nconst char *fullpath, const struct dfs_info3_param *ref)\r\n{\r\nstruct vfsmount *mnt;\r\nchar *mountdata;\r\nchar *devname = NULL;\r\nmountdata = cifs_compose_mount_options(cifs_sb->mountdata,\r\nfullpath + 1, ref, &devname);\r\nif (IS_ERR(mountdata))\r\nreturn (struct vfsmount *)mountdata;\r\nmnt = vfs_kern_mount(&cifs_fs_type, 0, devname, mountdata);\r\nkfree(mountdata);\r\nkfree(devname);\r\nreturn mnt;\r\n}\r\nstatic void dump_referral(const struct dfs_info3_param *ref)\r\n{\r\ncFYI(1, "DFS: ref path: %s", ref->path_name);\r\ncFYI(1, "DFS: node path: %s", ref->node_name);\r\ncFYI(1, "DFS: fl: %hd, srv_type: %hd", ref->flags, ref->server_type);\r\ncFYI(1, "DFS: ref_flags: %hd, path_consumed: %hd", ref->ref_flag,\r\nref->path_consumed);\r\n}\r\nstatic struct vfsmount *cifs_dfs_do_automount(struct dentry *mntpt)\r\n{\r\nstruct dfs_info3_param *referrals = NULL;\r\nunsigned int num_referrals = 0;\r\nstruct cifs_sb_info *cifs_sb;\r\nstruct cifs_ses *ses;\r\nchar *full_path;\r\nunsigned int xid;\r\nint i;\r\nint rc;\r\nstruct vfsmount *mnt;\r\nstruct tcon_link *tlink;\r\ncFYI(1, "in %s", __func__);\r\nBUG_ON(IS_ROOT(mntpt));\r\nmnt = ERR_PTR(-ENOMEM);\r\nfull_path = build_path_from_dentry(mntpt);\r\nif (full_path == NULL)\r\ngoto cdda_exit;\r\ncifs_sb = CIFS_SB(mntpt->d_inode->i_sb);\r\ntlink = cifs_sb_tlink(cifs_sb);\r\nif (IS_ERR(tlink)) {\r\nmnt = ERR_CAST(tlink);\r\ngoto free_full_path;\r\n}\r\nses = tlink_tcon(tlink)->ses;\r\nxid = get_xid();\r\nrc = get_dfs_path(xid, ses, full_path + 1, cifs_sb->local_nls,\r\n&num_referrals, &referrals,\r\ncifs_sb->mnt_cifs_flags & CIFS_MOUNT_MAP_SPECIAL_CHR);\r\nfree_xid(xid);\r\ncifs_put_tlink(tlink);\r\nmnt = ERR_PTR(-ENOENT);\r\nfor (i = 0; i < num_referrals; i++) {\r\nint len;\r\ndump_referral(referrals + i);\r\nlen = strlen(referrals[i].node_name);\r\nif (len < 2) {\r\ncERROR(1, "%s: Net Address path too short: %s",\r\n__func__, referrals[i].node_name);\r\nmnt = ERR_PTR(-EINVAL);\r\nbreak;\r\n}\r\nmnt = cifs_dfs_do_refmount(cifs_sb,\r\nfull_path, referrals + i);\r\ncFYI(1, "%s: cifs_dfs_do_refmount:%s , mnt:%p", __func__,\r\nreferrals[i].node_name, mnt);\r\nif (!IS_ERR(mnt))\r\ngoto success;\r\n}\r\nif (rc != 0)\r\nmnt = ERR_PTR(rc);\r\nsuccess:\r\nfree_dfs_info_array(referrals, num_referrals);\r\nfree_full_path:\r\nkfree(full_path);\r\ncdda_exit:\r\ncFYI(1, "leaving %s" , __func__);\r\nreturn mnt;\r\n}\r\nstruct vfsmount *cifs_dfs_d_automount(struct path *path)\r\n{\r\nstruct vfsmount *newmnt;\r\ncFYI(1, "in %s", __func__);\r\nnewmnt = cifs_dfs_do_automount(path->dentry);\r\nif (IS_ERR(newmnt)) {\r\ncFYI(1, "leaving %s [automount failed]" , __func__);\r\nreturn newmnt;\r\n}\r\nmntget(newmnt);\r\nmnt_set_expiry(newmnt, &cifs_dfs_automount_list);\r\nschedule_delayed_work(&cifs_dfs_automount_task,\r\ncifs_dfs_mountpoint_expiry_timeout);\r\ncFYI(1, "leaving %s [ok]" , __func__);\r\nreturn newmnt;\r\n}
