static int cx24123_i2c_writereg(struct cx24123_state *state,\r\nu8 i2c_addr, int reg, int data)\r\n{\r\nu8 buf[] = { reg, data };\r\nstruct i2c_msg msg = {\r\n.addr = i2c_addr, .flags = 0, .buf = buf, .len = 2\r\n};\r\nint err;\r\nerr = i2c_transfer(state->i2c, &msg, 1);\r\nif (err != 1) {\r\nprintk("%s: writereg error(err == %i, reg == 0x%02x,"\r\n" data == 0x%02x)\n", __func__, err, reg, data);\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic int cx24123_i2c_readreg(struct cx24123_state *state, u8 i2c_addr, u8 reg)\r\n{\r\nint ret;\r\nu8 b = 0;\r\nstruct i2c_msg msg[] = {\r\n{ .addr = i2c_addr, .flags = 0, .buf = &reg, .len = 1 },\r\n{ .addr = i2c_addr, .flags = I2C_M_RD, .buf = &b, .len = 1 }\r\n};\r\nret = i2c_transfer(state->i2c, msg, 2);\r\nif (ret != 2) {\r\nerr("%s: reg=0x%x (error=%d)\n", __func__, reg, ret);\r\nreturn ret;\r\n}\r\nreturn b;\r\n}\r\nstatic int cx24123_set_inversion(struct cx24123_state *state,\r\nfe_spectral_inversion_t inversion)\r\n{\r\nu8 nom_reg = cx24123_readreg(state, 0x0e);\r\nu8 auto_reg = cx24123_readreg(state, 0x10);\r\nswitch (inversion) {\r\ncase INVERSION_OFF:\r\ndprintk("inversion off\n");\r\ncx24123_writereg(state, 0x0e, nom_reg & ~0x80);\r\ncx24123_writereg(state, 0x10, auto_reg | 0x80);\r\nbreak;\r\ncase INVERSION_ON:\r\ndprintk("inversion on\n");\r\ncx24123_writereg(state, 0x0e, nom_reg | 0x80);\r\ncx24123_writereg(state, 0x10, auto_reg | 0x80);\r\nbreak;\r\ncase INVERSION_AUTO:\r\ndprintk("inversion auto\n");\r\ncx24123_writereg(state, 0x10, auto_reg & ~0x80);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int cx24123_get_inversion(struct cx24123_state *state,\r\nfe_spectral_inversion_t *inversion)\r\n{\r\nu8 val;\r\nval = cx24123_readreg(state, 0x1b) >> 7;\r\nif (val == 0) {\r\ndprintk("read inversion off\n");\r\n*inversion = INVERSION_OFF;\r\n} else {\r\ndprintk("read inversion on\n");\r\n*inversion = INVERSION_ON;\r\n}\r\nreturn 0;\r\n}\r\nstatic int cx24123_set_fec(struct cx24123_state *state, fe_code_rate_t fec)\r\n{\r\nu8 nom_reg = cx24123_readreg(state, 0x0e) & ~0x07;\r\nif (((int)fec < FEC_NONE) || (fec > FEC_AUTO))\r\nfec = FEC_AUTO;\r\nif (fec == FEC_1_2)\r\ncx24123_writereg(state, 0x43,\r\ncx24123_readreg(state, 0x43) | 0x01);\r\nelse\r\ncx24123_writereg(state, 0x43,\r\ncx24123_readreg(state, 0x43) & ~0x01);\r\nswitch (fec) {\r\ncase FEC_1_2:\r\ndprintk("set FEC to 1/2\n");\r\ncx24123_writereg(state, 0x0e, nom_reg | 0x01);\r\ncx24123_writereg(state, 0x0f, 0x02);\r\nbreak;\r\ncase FEC_2_3:\r\ndprintk("set FEC to 2/3\n");\r\ncx24123_writereg(state, 0x0e, nom_reg | 0x02);\r\ncx24123_writereg(state, 0x0f, 0x04);\r\nbreak;\r\ncase FEC_3_4:\r\ndprintk("set FEC to 3/4\n");\r\ncx24123_writereg(state, 0x0e, nom_reg | 0x03);\r\ncx24123_writereg(state, 0x0f, 0x08);\r\nbreak;\r\ncase FEC_4_5:\r\ndprintk("set FEC to 4/5\n");\r\ncx24123_writereg(state, 0x0e, nom_reg | 0x04);\r\ncx24123_writereg(state, 0x0f, 0x10);\r\nbreak;\r\ncase FEC_5_6:\r\ndprintk("set FEC to 5/6\n");\r\ncx24123_writereg(state, 0x0e, nom_reg | 0x05);\r\ncx24123_writereg(state, 0x0f, 0x20);\r\nbreak;\r\ncase FEC_6_7:\r\ndprintk("set FEC to 6/7\n");\r\ncx24123_writereg(state, 0x0e, nom_reg | 0x06);\r\ncx24123_writereg(state, 0x0f, 0x40);\r\nbreak;\r\ncase FEC_7_8:\r\ndprintk("set FEC to 7/8\n");\r\ncx24123_writereg(state, 0x0e, nom_reg | 0x07);\r\ncx24123_writereg(state, 0x0f, 0x80);\r\nbreak;\r\ncase FEC_AUTO:\r\ndprintk("set FEC to auto\n");\r\ncx24123_writereg(state, 0x0f, 0xfe);\r\nbreak;\r\ndefault:\r\nreturn -EOPNOTSUPP;\r\n}\r\nreturn 0;\r\n}\r\nstatic int cx24123_get_fec(struct cx24123_state *state, fe_code_rate_t *fec)\r\n{\r\nint ret;\r\nret = cx24123_readreg(state, 0x1b);\r\nif (ret < 0)\r\nreturn ret;\r\nret = ret & 0x07;\r\nswitch (ret) {\r\ncase 1:\r\n*fec = FEC_1_2;\r\nbreak;\r\ncase 2:\r\n*fec = FEC_2_3;\r\nbreak;\r\ncase 3:\r\n*fec = FEC_3_4;\r\nbreak;\r\ncase 4:\r\n*fec = FEC_4_5;\r\nbreak;\r\ncase 5:\r\n*fec = FEC_5_6;\r\nbreak;\r\ncase 6:\r\n*fec = FEC_6_7;\r\nbreak;\r\ncase 7:\r\n*fec = FEC_7_8;\r\nbreak;\r\ndefault:\r\n*fec = FEC_NONE;\r\n}\r\nreturn 0;\r\n}\r\nstatic u32 cx24123_int_log2(u32 a, u32 b)\r\n{\r\nu32 exp, nearest = 0;\r\nu32 div = a / b;\r\nif (a % b >= b / 2)\r\n++div;\r\nif (div < (1 << 31)) {\r\nfor (exp = 1; div > exp; nearest++)\r\nexp += exp;\r\n}\r\nreturn nearest;\r\n}\r\nstatic int cx24123_set_symbolrate(struct cx24123_state *state, u32 srate)\r\n{\r\nu32 tmp, sample_rate, ratio, sample_gain;\r\nu8 pll_mult;\r\nif ((srate > state->frontend.ops.info.symbol_rate_max) ||\r\n(srate < state->frontend.ops.info.symbol_rate_min))\r\nreturn -EOPNOTSUPP;\r\nif (srate < (XTAL*2)/2)\r\npll_mult = 2;\r\nelse if (srate < (XTAL*3)/2)\r\npll_mult = 3;\r\nelse if (srate < (XTAL*4)/2)\r\npll_mult = 4;\r\nelse if (srate < (XTAL*5)/2)\r\npll_mult = 5;\r\nelse if (srate < (XTAL*6)/2)\r\npll_mult = 6;\r\nelse if (srate < (XTAL*7)/2)\r\npll_mult = 7;\r\nelse if (srate < (XTAL*8)/2)\r\npll_mult = 8;\r\nelse\r\npll_mult = 9;\r\nsample_rate = pll_mult * XTAL;\r\ntmp = srate << 6;\r\nratio = tmp / sample_rate;\r\ntmp = (tmp % sample_rate) << 6;\r\nratio = (ratio << 6) + (tmp / sample_rate);\r\ntmp = (tmp % sample_rate) << 6;\r\nratio = (ratio << 6) + (tmp / sample_rate);\r\ntmp = (tmp % sample_rate) << 5;\r\nratio = (ratio << 5) + (tmp / sample_rate);\r\ncx24123_writereg(state, 0x01, pll_mult * 6);\r\ncx24123_writereg(state, 0x08, (ratio >> 16) & 0x3f);\r\ncx24123_writereg(state, 0x09, (ratio >> 8) & 0xff);\r\ncx24123_writereg(state, 0x0a, ratio & 0xff);\r\nsample_gain = cx24123_int_log2(sample_rate, srate);\r\ntmp = cx24123_readreg(state, 0x0c) & ~0xe0;\r\ncx24123_writereg(state, 0x0c, tmp | sample_gain << 5);\r\ndprintk("srate=%d, ratio=0x%08x, sample_rate=%i sample_gain=%d\n",\r\nsrate, ratio, sample_rate, sample_gain);\r\nreturn 0;\r\n}\r\nstatic int cx24123_pll_calculate(struct dvb_frontend *fe)\r\n{\r\nstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\r\nstruct cx24123_state *state = fe->demodulator_priv;\r\nu32 ndiv = 0, adiv = 0, vco_div = 0;\r\nint i = 0;\r\nint pump = 2;\r\nint band = 0;\r\nint num_bands = ARRAY_SIZE(cx24123_bandselect_vals);\r\nstruct cx24123_bandselect_val *bsv = NULL;\r\nstruct cx24123_AGC_val *agcv = NULL;\r\nstate->VCAarg = cx24123_AGC_vals[0].VCAprogdata;\r\nstate->VGAarg = cx24123_AGC_vals[0].VGAprogdata;\r\nstate->bandselectarg = cx24123_bandselect_vals[0].progdata;\r\nvco_div = cx24123_bandselect_vals[0].VCOdivider;\r\nfor (i = 0; i < ARRAY_SIZE(cx24123_AGC_vals); i++) {\r\nagcv = &cx24123_AGC_vals[i];\r\nif ((agcv->symbolrate_low <= p->symbol_rate) &&\r\n(agcv->symbolrate_high >= p->symbol_rate)) {\r\nstate->VCAarg = agcv->VCAprogdata;\r\nstate->VGAarg = agcv->VGAprogdata;\r\nstate->FILTune = agcv->FILTune;\r\n}\r\n}\r\nif (force_band < 1 || force_band > num_bands) {\r\nfor (i = 0; i < num_bands; i++) {\r\nbsv = &cx24123_bandselect_vals[i];\r\nif ((bsv->freq_low <= p->frequency) &&\r\n(bsv->freq_high >= p->frequency))\r\nband = i;\r\n}\r\n} else\r\nband = force_band - 1;\r\nstate->bandselectarg = cx24123_bandselect_vals[band].progdata;\r\nvco_div = cx24123_bandselect_vals[band].VCOdivider;\r\nif (p->frequency < (cx24123_bandselect_vals[band].freq_low +\r\ncx24123_bandselect_vals[band].freq_high) / 2)\r\npump = 0x01;\r\nelse\r\npump = 0x02;\r\nndiv = (((p->frequency * vco_div * 10) /\r\n(2 * XTAL / 1000)) / 32) & 0x1ff;\r\nadiv = (((p->frequency * vco_div * 10) /\r\n(2 * XTAL / 1000)) % 32) & 0x1f;\r\nif (adiv == 0 && ndiv > 0)\r\nndiv--;\r\nstate->pllarg = (3 << 19) | (3 << 17) | (1 << 16) |\r\n(pump << 14) | (ndiv << 5) | adiv;\r\nreturn 0;\r\n}\r\nstatic int cx24123_pll_writereg(struct dvb_frontend *fe, u32 data)\r\n{\r\nstruct cx24123_state *state = fe->demodulator_priv;\r\nunsigned long timeout;\r\ndprintk("pll writereg called, data=0x%08x\n", data);\r\ndata = data << 3;\r\ncx24123_writereg(state, 0x21, 0x15);\r\ntimeout = jiffies + msecs_to_jiffies(40);\r\ncx24123_writereg(state, 0x22, (data >> 16) & 0xff);\r\nwhile ((cx24123_readreg(state, 0x20) & 0x40) == 0) {\r\nif (time_after(jiffies, timeout)) {\r\nerr("%s: demodulator is not responding, "\\r\n"possibly hung, aborting.\n", __func__);\r\nreturn -EREMOTEIO;\r\n}\r\nmsleep(10);\r\n}\r\ntimeout = jiffies + msecs_to_jiffies(40);\r\ncx24123_writereg(state, 0x22, (data >> 8) & 0xff);\r\nwhile ((cx24123_readreg(state, 0x20) & 0x40) == 0) {\r\nif (time_after(jiffies, timeout)) {\r\nerr("%s: demodulator is not responding, "\\r\n"possibly hung, aborting.\n", __func__);\r\nreturn -EREMOTEIO;\r\n}\r\nmsleep(10);\r\n}\r\ntimeout = jiffies + msecs_to_jiffies(40);\r\ncx24123_writereg(state, 0x22, (data) & 0xff);\r\nwhile ((cx24123_readreg(state, 0x20) & 0x80)) {\r\nif (time_after(jiffies, timeout)) {\r\nerr("%s: demodulator is not responding," \\r\n"possibly hung, aborting.\n", __func__);\r\nreturn -EREMOTEIO;\r\n}\r\nmsleep(10);\r\n}\r\ncx24123_writereg(state, 0x20, cx24123_readreg(state, 0x20) | 2);\r\ncx24123_writereg(state, 0x20, cx24123_readreg(state, 0x20) & 0xfd);\r\nreturn 0;\r\n}\r\nstatic int cx24123_pll_tune(struct dvb_frontend *fe)\r\n{\r\nstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\r\nstruct cx24123_state *state = fe->demodulator_priv;\r\nu8 val;\r\ndprintk("frequency=%i\n", p->frequency);\r\nif (cx24123_pll_calculate(fe) != 0) {\r\nerr("%s: cx24123_pll_calcutate failed\n", __func__);\r\nreturn -EINVAL;\r\n}\r\ncx24123_pll_writereg(fe, state->VCAarg);\r\ncx24123_pll_writereg(fe, state->VGAarg);\r\ncx24123_pll_writereg(fe, state->bandselectarg);\r\ncx24123_pll_writereg(fe, state->pllarg);\r\nval = cx24123_readreg(state, 0x28) & ~0x3;\r\ncx24123_writereg(state, 0x27, state->FILTune >> 2);\r\ncx24123_writereg(state, 0x28, val | (state->FILTune & 0x3));\r\ndprintk("pll tune VCA=%d, band=%d, pll=%d\n", state->VCAarg,\r\nstate->bandselectarg, state->pllarg);\r\nreturn 0;\r\n}\r\nstatic int cx24123_repeater_mode(struct cx24123_state *state, u8 mode, u8 start)\r\n{\r\nu8 r = cx24123_readreg(state, 0x23) & 0x1e;\r\nif (mode)\r\nr |= (1 << 6) | (start << 5);\r\nelse\r\nr |= (1 << 7) | (start);\r\nreturn cx24123_writereg(state, 0x23, r);\r\n}\r\nstatic int cx24123_initfe(struct dvb_frontend *fe)\r\n{\r\nstruct cx24123_state *state = fe->demodulator_priv;\r\nint i;\r\ndprintk("init frontend\n");\r\nfor (i = 0; i < ARRAY_SIZE(cx24123_regdata); i++)\r\ncx24123_writereg(state, cx24123_regdata[i].reg,\r\ncx24123_regdata[i].data);\r\nif (state->config->lnb_polarity)\r\ncx24123_writereg(state, 0x32,\r\ncx24123_readreg(state, 0x32) | 0x02);\r\nif (state->config->dont_use_pll)\r\ncx24123_repeater_mode(state, 1, 0);\r\nreturn 0;\r\n}\r\nstatic int cx24123_set_voltage(struct dvb_frontend *fe,\r\nfe_sec_voltage_t voltage)\r\n{\r\nstruct cx24123_state *state = fe->demodulator_priv;\r\nu8 val;\r\nval = cx24123_readreg(state, 0x29) & ~0x40;\r\nswitch (voltage) {\r\ncase SEC_VOLTAGE_13:\r\ndprintk("setting voltage 13V\n");\r\nreturn cx24123_writereg(state, 0x29, val & 0x7f);\r\ncase SEC_VOLTAGE_18:\r\ndprintk("setting voltage 18V\n");\r\nreturn cx24123_writereg(state, 0x29, val | 0x80);\r\ncase SEC_VOLTAGE_OFF:\r\nreturn 0;\r\ndefault:\r\nreturn -EINVAL;\r\n};\r\nreturn 0;\r\n}\r\nstatic void cx24123_wait_for_diseqc(struct cx24123_state *state)\r\n{\r\nunsigned long timeout = jiffies + msecs_to_jiffies(200);\r\nwhile (!(cx24123_readreg(state, 0x29) & 0x40)) {\r\nif (time_after(jiffies, timeout)) {\r\nerr("%s: diseqc queue not ready, " \\r\n"command may be lost.\n", __func__);\r\nbreak;\r\n}\r\nmsleep(10);\r\n}\r\n}\r\nstatic int cx24123_send_diseqc_msg(struct dvb_frontend *fe,\r\nstruct dvb_diseqc_master_cmd *cmd)\r\n{\r\nstruct cx24123_state *state = fe->demodulator_priv;\r\nint i, val, tone;\r\ndprintk("\n");\r\ntone = cx24123_readreg(state, 0x29);\r\nif (tone & 0x10)\r\ncx24123_writereg(state, 0x29, tone & ~0x50);\r\ncx24123_wait_for_diseqc(state);\r\ncx24123_writereg(state, 0x2a, cx24123_readreg(state, 0x2a) & 0xfb);\r\nfor (i = 0; i < cmd->msg_len; i++)\r\ncx24123_writereg(state, 0x2C + i, cmd->msg[i]);\r\nval = cx24123_readreg(state, 0x29);\r\ncx24123_writereg(state, 0x29, ((val & 0x90) | 0x40) |\r\n((cmd->msg_len-3) & 3));\r\ncx24123_wait_for_diseqc(state);\r\nif (tone & 0x10)\r\ncx24123_writereg(state, 0x29, tone & ~0x40);\r\nreturn 0;\r\n}\r\nstatic int cx24123_diseqc_send_burst(struct dvb_frontend *fe,\r\nfe_sec_mini_cmd_t burst)\r\n{\r\nstruct cx24123_state *state = fe->demodulator_priv;\r\nint val, tone;\r\ndprintk("\n");\r\ntone = cx24123_readreg(state, 0x29);\r\nif (tone & 0x10)\r\ncx24123_writereg(state, 0x29, tone & ~0x50);\r\ncx24123_wait_for_diseqc(state);\r\ncx24123_writereg(state, 0x2a, cx24123_readreg(state, 0x2a) | 0x4);\r\nmsleep(30);\r\nval = cx24123_readreg(state, 0x29);\r\nif (burst == SEC_MINI_A)\r\ncx24123_writereg(state, 0x29, ((val & 0x90) | 0x40 | 0x00));\r\nelse if (burst == SEC_MINI_B)\r\ncx24123_writereg(state, 0x29, ((val & 0x90) | 0x40 | 0x08));\r\nelse\r\nreturn -EINVAL;\r\ncx24123_wait_for_diseqc(state);\r\ncx24123_writereg(state, 0x2a, cx24123_readreg(state, 0x2a) & 0xfb);\r\nif (tone & 0x10)\r\ncx24123_writereg(state, 0x29, tone & ~0x40);\r\nreturn 0;\r\n}\r\nstatic int cx24123_read_status(struct dvb_frontend *fe, fe_status_t *status)\r\n{\r\nstruct cx24123_state *state = fe->demodulator_priv;\r\nint sync = cx24123_readreg(state, 0x14);\r\n*status = 0;\r\nif (state->config->dont_use_pll) {\r\nu32 tun_status = 0;\r\nif (fe->ops.tuner_ops.get_status)\r\nfe->ops.tuner_ops.get_status(fe, &tun_status);\r\nif (tun_status & TUNER_STATUS_LOCKED)\r\n*status |= FE_HAS_SIGNAL;\r\n} else {\r\nint lock = cx24123_readreg(state, 0x20);\r\nif (lock & 0x01)\r\n*status |= FE_HAS_SIGNAL;\r\n}\r\nif (sync & 0x02)\r\n*status |= FE_HAS_CARRIER;\r\nif (sync & 0x04)\r\n*status |= FE_HAS_VITERBI;\r\nif (sync & 0x08)\r\n*status |= FE_HAS_SYNC;\r\nif (sync & 0x80)\r\n*status |= FE_HAS_LOCK;\r\nreturn 0;\r\n}\r\nstatic int cx24123_read_ber(struct dvb_frontend *fe, u32 *ber)\r\n{\r\nstruct cx24123_state *state = fe->demodulator_priv;\r\n*ber = ((cx24123_readreg(state, 0x1c) & 0x3f) << 16) |\r\n(cx24123_readreg(state, 0x1d) << 8 |\r\ncx24123_readreg(state, 0x1e));\r\ndprintk("BER = %d\n", *ber);\r\nreturn 0;\r\n}\r\nstatic int cx24123_read_signal_strength(struct dvb_frontend *fe,\r\nu16 *signal_strength)\r\n{\r\nstruct cx24123_state *state = fe->demodulator_priv;\r\n*signal_strength = cx24123_readreg(state, 0x3b) << 8;\r\ndprintk("Signal strength = %d\n", *signal_strength);\r\nreturn 0;\r\n}\r\nstatic int cx24123_read_snr(struct dvb_frontend *fe, u16 *snr)\r\n{\r\nstruct cx24123_state *state = fe->demodulator_priv;\r\n*snr = 65535 - (((u16)cx24123_readreg(state, 0x18) << 8) |\r\n(u16)cx24123_readreg(state, 0x19));\r\ndprintk("read S/N index = %d\n", *snr);\r\nreturn 0;\r\n}\r\nstatic int cx24123_set_frontend(struct dvb_frontend *fe)\r\n{\r\nstruct cx24123_state *state = fe->demodulator_priv;\r\nstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\r\ndprintk("\n");\r\nif (state->config->set_ts_params)\r\nstate->config->set_ts_params(fe, 0);\r\nstate->currentfreq = p->frequency;\r\nstate->currentsymbolrate = p->symbol_rate;\r\ncx24123_set_inversion(state, p->inversion);\r\ncx24123_set_fec(state, p->fec_inner);\r\ncx24123_set_symbolrate(state, p->symbol_rate);\r\nif (!state->config->dont_use_pll)\r\ncx24123_pll_tune(fe);\r\nelse if (fe->ops.tuner_ops.set_params)\r\nfe->ops.tuner_ops.set_params(fe);\r\nelse\r\nerr("it seems I don't have a tuner...");\r\ncx24123_writereg(state, 0x03, (cx24123_readreg(state, 0x03) | 0x07));\r\ncx24123_writereg(state, 0x00, 0x10);\r\ncx24123_writereg(state, 0x00, 0);\r\nif (state->config->agc_callback)\r\nstate->config->agc_callback(fe);\r\nreturn 0;\r\n}\r\nstatic int cx24123_get_frontend(struct dvb_frontend *fe)\r\n{\r\nstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\r\nstruct cx24123_state *state = fe->demodulator_priv;\r\ndprintk("\n");\r\nif (cx24123_get_inversion(state, &p->inversion) != 0) {\r\nerr("%s: Failed to get inversion status\n", __func__);\r\nreturn -EREMOTEIO;\r\n}\r\nif (cx24123_get_fec(state, &p->fec_inner) != 0) {\r\nerr("%s: Failed to get fec status\n", __func__);\r\nreturn -EREMOTEIO;\r\n}\r\np->frequency = state->currentfreq;\r\np->symbol_rate = state->currentsymbolrate;\r\nreturn 0;\r\n}\r\nstatic int cx24123_set_tone(struct dvb_frontend *fe, fe_sec_tone_mode_t tone)\r\n{\r\nstruct cx24123_state *state = fe->demodulator_priv;\r\nu8 val;\r\ncx24123_wait_for_diseqc(state);\r\nval = cx24123_readreg(state, 0x29) & ~0x40;\r\nswitch (tone) {\r\ncase SEC_TONE_ON:\r\ndprintk("setting tone on\n");\r\nreturn cx24123_writereg(state, 0x29, val | 0x10);\r\ncase SEC_TONE_OFF:\r\ndprintk("setting tone off\n");\r\nreturn cx24123_writereg(state, 0x29, val & 0xef);\r\ndefault:\r\nerr("CASE reached default with tone=%d\n", tone);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int cx24123_tune(struct dvb_frontend *fe,\r\nbool re_tune,\r\nunsigned int mode_flags,\r\nunsigned int *delay,\r\nfe_status_t *status)\r\n{\r\nint retval = 0;\r\nif (re_tune)\r\nretval = cx24123_set_frontend(fe);\r\nif (!(mode_flags & FE_TUNE_MODE_ONESHOT))\r\ncx24123_read_status(fe, status);\r\n*delay = HZ/10;\r\nreturn retval;\r\n}\r\nstatic int cx24123_get_algo(struct dvb_frontend *fe)\r\n{\r\nreturn 1;\r\n}\r\nstatic void cx24123_release(struct dvb_frontend *fe)\r\n{\r\nstruct cx24123_state *state = fe->demodulator_priv;\r\ndprintk("\n");\r\ni2c_del_adapter(&state->tuner_i2c_adapter);\r\nkfree(state);\r\n}\r\nstatic int cx24123_tuner_i2c_tuner_xfer(struct i2c_adapter *i2c_adap,\r\nstruct i2c_msg msg[], int num)\r\n{\r\nstruct cx24123_state *state = i2c_get_adapdata(i2c_adap);\r\ncx24123_repeater_mode(state, 1, 1);\r\nreturn i2c_transfer(state->i2c, msg, num);\r\n}\r\nstatic u32 cx24123_tuner_i2c_func(struct i2c_adapter *adapter)\r\n{\r\nreturn I2C_FUNC_I2C;\r\n}\r\nstruct i2c_adapter *\r\ncx24123_get_tuner_i2c_adapter(struct dvb_frontend *fe)\r\n{\r\nstruct cx24123_state *state = fe->demodulator_priv;\r\nreturn &state->tuner_i2c_adapter;\r\n}\r\nstruct dvb_frontend *cx24123_attach(const struct cx24123_config *config,\r\nstruct i2c_adapter *i2c)\r\n{\r\nstruct cx24123_state *state =\r\nkzalloc(sizeof(struct cx24123_state), GFP_KERNEL);\r\ndprintk("\n");\r\nif (state == NULL) {\r\nerr("Unable to kzalloc\n");\r\ngoto error;\r\n}\r\nstate->config = config;\r\nstate->i2c = i2c;\r\nstate->demod_rev = cx24123_readreg(state, 0x00);\r\nswitch (state->demod_rev) {\r\ncase 0xe1:\r\ninfo("detected CX24123C\n");\r\nbreak;\r\ncase 0xd1:\r\ninfo("detected CX24123\n");\r\nbreak;\r\ndefault:\r\nerr("wrong demod revision: %x\n", state->demod_rev);\r\ngoto error;\r\n}\r\nmemcpy(&state->frontend.ops, &cx24123_ops,\r\nsizeof(struct dvb_frontend_ops));\r\nstate->frontend.demodulator_priv = state;\r\nif (config->dont_use_pll)\r\ncx24123_repeater_mode(state, 1, 0);\r\nstrlcpy(state->tuner_i2c_adapter.name, "CX24123 tuner I2C bus",\r\nsizeof(state->tuner_i2c_adapter.name));\r\nstate->tuner_i2c_adapter.algo = &cx24123_tuner_i2c_algo;\r\nstate->tuner_i2c_adapter.algo_data = NULL;\r\ni2c_set_adapdata(&state->tuner_i2c_adapter, state);\r\nif (i2c_add_adapter(&state->tuner_i2c_adapter) < 0) {\r\nerr("tuner i2c bus could not be initialized\n");\r\ngoto error;\r\n}\r\nreturn &state->frontend;\r\nerror:\r\nkfree(state);\r\nreturn NULL;\r\n}
