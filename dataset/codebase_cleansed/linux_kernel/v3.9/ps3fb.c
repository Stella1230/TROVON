static int ps3fb_cmp_mode(const struct fb_videomode *vmode,\r\nconst struct fb_var_screeninfo *var)\r\n{\r\nlong xres, yres, left_margin, right_margin, upper_margin, lower_margin;\r\nlong dx, dy;\r\nif (var->xres > vmode->xres || var->yres > vmode->yres ||\r\nvar->pixclock > vmode->pixclock ||\r\nvar->hsync_len > vmode->hsync_len ||\r\nvar->vsync_len > vmode->vsync_len)\r\nreturn -1;\r\nif ((var->vmode & FB_VMODE_MASK) != vmode->vmode)\r\nreturn -1;\r\nxres = max(var->xres, 1U);\r\nyres = max(var->yres, 1U);\r\nleft_margin = max(var->left_margin, vmode->left_margin);\r\nright_margin = max(var->right_margin, vmode->right_margin);\r\nupper_margin = max(var->upper_margin, vmode->upper_margin);\r\nlower_margin = max(var->lower_margin, vmode->lower_margin);\r\ndx = ((long)vmode->left_margin + (long)vmode->xres +\r\n(long)vmode->right_margin) -\r\n(left_margin + xres + right_margin);\r\nif (dx < 0)\r\nreturn -1;\r\ndy = ((long)vmode->upper_margin + (long)vmode->yres +\r\n(long)vmode->lower_margin) -\r\n(upper_margin + yres + lower_margin);\r\nif (dy < 0)\r\nreturn -1;\r\nif (!dx && !dy)\r\nreturn 0;\r\nreturn (vmode->xres - xres) * (vmode->yres - yres);\r\n}\r\nstatic const struct fb_videomode *ps3fb_native_vmode(enum ps3av_mode_num id)\r\n{\r\nreturn &ps3fb_modedb[FIRST_NATIVE_MODE_INDEX + id - 1];\r\n}\r\nstatic const struct fb_videomode *ps3fb_vmode(int id)\r\n{\r\nu32 mode = id & PS3AV_MODE_MASK;\r\nif (mode < PS3AV_MODE_480I || mode > PS3AV_MODE_WUXGA)\r\nreturn NULL;\r\nif (mode <= PS3AV_MODE_1080P50 && !(id & PS3AV_MODE_FULL)) {\r\nreturn &ps3fb_modedb[mode - 1];\r\n}\r\nreturn ps3fb_native_vmode(mode);\r\n}\r\nstatic unsigned int ps3fb_find_mode(struct fb_var_screeninfo *var,\r\nu32 *ddr_line_length, u32 *xdr_line_length)\r\n{\r\nunsigned int id, best_id;\r\nint diff, best_diff;\r\nconst struct fb_videomode *vmode;\r\nlong gap;\r\nbest_id = 0;\r\nbest_diff = INT_MAX;\r\npr_debug("%s: wanted %u [%u] %u x %u [%u] %u\n", __func__,\r\nvar->left_margin, var->xres, var->right_margin,\r\nvar->upper_margin, var->yres, var->lower_margin);\r\nfor (id = PS3AV_MODE_480I; id <= PS3AV_MODE_WUXGA; id++) {\r\nvmode = ps3fb_native_vmode(id);\r\ndiff = ps3fb_cmp_mode(vmode, var);\r\npr_debug("%s: mode %u: %u [%u] %u x %u [%u] %u: diff = %d\n",\r\n__func__, id, vmode->left_margin, vmode->xres,\r\nvmode->right_margin, vmode->upper_margin,\r\nvmode->yres, vmode->lower_margin, diff);\r\nif (diff < 0)\r\ncontinue;\r\nif (diff < best_diff) {\r\nbest_id = id;\r\nif (!diff)\r\nbreak;\r\nbest_diff = diff;\r\n}\r\n}\r\nif (!best_id) {\r\npr_debug("%s: no suitable mode found\n", __func__);\r\nreturn 0;\r\n}\r\nid = best_id;\r\nvmode = ps3fb_native_vmode(id);\r\n*ddr_line_length = vmode->xres * BPP;\r\nif (!var->xres)\r\nvar->xres = 1;\r\nif (!var->yres)\r\nvar->yres = 1;\r\nif (var->xres_virtual < var->xres)\r\nvar->xres_virtual = var->xres;\r\nif (var->yres_virtual < var->yres)\r\nvar->yres_virtual = var->yres;\r\nif (var->left_margin < vmode->left_margin)\r\nvar->left_margin = vmode->left_margin;\r\nif (var->right_margin < vmode->right_margin)\r\nvar->right_margin = vmode->right_margin;\r\nif (var->upper_margin < vmode->upper_margin)\r\nvar->upper_margin = vmode->upper_margin;\r\nif (var->lower_margin < vmode->lower_margin)\r\nvar->lower_margin = vmode->lower_margin;\r\ngap = ((long)vmode->left_margin + (long)vmode->xres +\r\n(long)vmode->right_margin) -\r\n((long)var->left_margin + (long)var->xres +\r\n(long)var->right_margin);\r\nif (gap > 0) {\r\nvar->left_margin += gap/2;\r\nvar->right_margin += (gap+1)/2;\r\npr_debug("%s: rounded up H to %u [%u] %u\n", __func__,\r\nvar->left_margin, var->xres, var->right_margin);\r\n}\r\ngap = ((long)vmode->upper_margin + (long)vmode->yres +\r\n(long)vmode->lower_margin) -\r\n((long)var->upper_margin + (long)var->yres +\r\n(long)var->lower_margin);\r\nif (gap > 0) {\r\nvar->upper_margin += gap/2;\r\nvar->lower_margin += (gap+1)/2;\r\npr_debug("%s: rounded up V to %u [%u] %u\n", __func__,\r\nvar->upper_margin, var->yres, var->lower_margin);\r\n}\r\nvar->pixclock = vmode->pixclock;\r\nvar->hsync_len = vmode->hsync_len;\r\nvar->vsync_len = vmode->vsync_len;\r\nvar->sync = vmode->sync;\r\nif (ps3_compare_firmware_version(1, 9, 0) >= 0) {\r\n*xdr_line_length = GPU_ALIGN_UP(var->xres_virtual * BPP);\r\nif (*xdr_line_length > GPU_MAX_LINE_LENGTH)\r\n*xdr_line_length = GPU_MAX_LINE_LENGTH;\r\n} else\r\n*xdr_line_length = *ddr_line_length;\r\nif (vmode->sync & FB_SYNC_BROADCAST) {\r\nif (vmode->xres == var->xres && vmode->yres == var->yres)\r\nid |= PS3AV_MODE_FULL;\r\n}\r\npr_debug("%s: mode %u\n", __func__, id);\r\nreturn id;\r\n}\r\nstatic void ps3fb_sync_image(struct device *dev, u64 frame_offset,\r\nu64 dst_offset, u64 src_offset, u32 width,\r\nu32 height, u32 dst_line_length,\r\nu32 src_line_length)\r\n{\r\nint status;\r\nu64 line_length;\r\nline_length = dst_line_length;\r\nif (src_line_length != dst_line_length)\r\nline_length |= (u64)src_line_length << 32;\r\nsrc_offset += GPU_FB_START;\r\nmutex_lock(&ps3_gpu_mutex);\r\nstatus = lv1_gpu_fb_blit(ps3fb.context_handle, dst_offset,\r\nGPU_IOIF + src_offset,\r\nL1GPU_FB_BLIT_WAIT_FOR_COMPLETION |\r\n(width << 16) | height,\r\nline_length);\r\nmutex_unlock(&ps3_gpu_mutex);\r\nif (status)\r\ndev_err(dev, "%s: lv1_gpu_fb_blit failed: %d\n", __func__,\r\nstatus);\r\n#ifdef HEAD_A\r\nstatus = lv1_gpu_display_flip(ps3fb.context_handle, 0, frame_offset);\r\nif (status)\r\ndev_err(dev, "%s: lv1_gpu_display_flip failed: %d\n", __func__,\r\nstatus);\r\n#endif\r\n#ifdef HEAD_B\r\nstatus = lv1_gpu_display_flip(ps3fb.context_handle, 1, frame_offset);\r\nif (status)\r\ndev_err(dev, "%s: lv1_gpu_display_flip failed: %d\n", __func__,\r\nstatus);\r\n#endif\r\n}\r\nstatic int ps3fb_sync(struct fb_info *info, u32 frame)\r\n{\r\nstruct ps3fb_par *par = info->par;\r\nint error = 0;\r\nu64 ddr_base, xdr_base;\r\nif (frame > par->num_frames - 1) {\r\ndev_dbg(info->device, "%s: invalid frame number (%u)\n",\r\n__func__, frame);\r\nerror = -EINVAL;\r\ngoto out;\r\n}\r\nxdr_base = frame * par->xdr_frame_size;\r\nddr_base = frame * par->ddr_frame_size;\r\nps3fb_sync_image(info->device, ddr_base + par->full_offset,\r\nddr_base + par->fb_offset, xdr_base + par->pan_offset,\r\npar->width, par->height, par->ddr_line_length,\r\ninfo->fix.line_length);\r\nout:\r\nreturn error;\r\n}\r\nstatic int ps3fb_open(struct fb_info *info, int user)\r\n{\r\natomic_inc(&ps3fb.f_count);\r\nreturn 0;\r\n}\r\nstatic int ps3fb_release(struct fb_info *info, int user)\r\n{\r\nif (atomic_dec_and_test(&ps3fb.f_count)) {\r\nif (atomic_read(&ps3fb.ext_flip)) {\r\natomic_set(&ps3fb.ext_flip, 0);\r\nif (console_trylock()) {\r\nps3fb_sync(info, 0);\r\nconsole_unlock();\r\n}\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int ps3fb_check_var(struct fb_var_screeninfo *var, struct fb_info *info)\r\n{\r\nu32 xdr_line_length, ddr_line_length;\r\nint mode;\r\nmode = ps3fb_find_mode(var, &ddr_line_length, &xdr_line_length);\r\nif (!mode)\r\nreturn -EINVAL;\r\nif (var->xres_virtual > xdr_line_length / BPP) {\r\ndev_dbg(info->device,\r\n"Horizontal virtual screen size too large\n");\r\nreturn -EINVAL;\r\n}\r\nif (var->xoffset + var->xres > var->xres_virtual ||\r\nvar->yoffset + var->yres > var->yres_virtual) {\r\ndev_dbg(info->device, "panning out-of-range\n");\r\nreturn -EINVAL;\r\n}\r\nif (var->bits_per_pixel > 32 || var->grayscale ||\r\nvar->red.offset > 16 || var->green.offset > 8 ||\r\nvar->blue.offset > 0 || var->transp.offset > 24 ||\r\nvar->red.length > 8 || var->green.length > 8 ||\r\nvar->blue.length > 8 || var->transp.length > 8 ||\r\nvar->red.msb_right || var->green.msb_right ||\r\nvar->blue.msb_right || var->transp.msb_right || var->nonstd) {\r\ndev_dbg(info->device, "We support ARGB8888 only\n");\r\nreturn -EINVAL;\r\n}\r\nvar->bits_per_pixel = 32;\r\nvar->red.offset = 16;\r\nvar->green.offset = 8;\r\nvar->blue.offset = 0;\r\nvar->transp.offset = 24;\r\nvar->red.length = 8;\r\nvar->green.length = 8;\r\nvar->blue.length = 8;\r\nvar->transp.length = 8;\r\nvar->red.msb_right = 0;\r\nvar->green.msb_right = 0;\r\nvar->blue.msb_right = 0;\r\nvar->transp.msb_right = 0;\r\nif (var->rotate) {\r\ndev_dbg(info->device, "Rotation is not supported\n");\r\nreturn -EINVAL;\r\n}\r\nif (var->yres_virtual * xdr_line_length > info->fix.smem_len) {\r\ndev_dbg(info->device, "Not enough memory\n");\r\nreturn -ENOMEM;\r\n}\r\nvar->height = -1;\r\nvar->width = -1;\r\nreturn 0;\r\n}\r\nstatic int ps3fb_set_par(struct fb_info *info)\r\n{\r\nstruct ps3fb_par *par = info->par;\r\nunsigned int mode, ddr_line_length, xdr_line_length, lines, maxlines;\r\nunsigned int ddr_xoff, ddr_yoff, offset;\r\nconst struct fb_videomode *vmode;\r\nu64 dst;\r\nmode = ps3fb_find_mode(&info->var, &ddr_line_length, &xdr_line_length);\r\nif (!mode)\r\nreturn -EINVAL;\r\nvmode = ps3fb_native_vmode(mode & PS3AV_MODE_MASK);\r\ninfo->fix.xpanstep = info->var.xres_virtual > info->var.xres ? 1 : 0;\r\ninfo->fix.ypanstep = info->var.yres_virtual > info->var.yres ? 1 : 0;\r\ninfo->fix.line_length = xdr_line_length;\r\npar->ddr_line_length = ddr_line_length;\r\npar->ddr_frame_size = vmode->yres * ddr_line_length;\r\npar->xdr_frame_size = info->var.yres_virtual * xdr_line_length;\r\npar->num_frames = info->fix.smem_len /\r\nmax(par->ddr_frame_size, par->xdr_frame_size);\r\npar->new_mode_id = (par->new_mode_id & ~PS3AV_MODE_MASK) | mode;\r\npar->width = info->var.xres;\r\npar->height = info->var.yres;\r\nddr_xoff = info->var.left_margin - vmode->left_margin;\r\nddr_yoff = info->var.upper_margin - vmode->upper_margin;\r\noffset = ddr_yoff * ddr_line_length + ddr_xoff * BPP;\r\npar->fb_offset = GPU_ALIGN_UP(offset);\r\npar->full_offset = par->fb_offset - offset;\r\npar->pan_offset = info->var.yoffset * xdr_line_length +\r\ninfo->var.xoffset * BPP;\r\nif (par->new_mode_id != par->mode_id) {\r\nif (ps3av_set_video_mode(par->new_mode_id)) {\r\npar->new_mode_id = par->mode_id;\r\nreturn -EINVAL;\r\n}\r\npar->mode_id = par->new_mode_id;\r\n}\r\nmemset((void __force *)info->screen_base, 0, info->fix.smem_len);\r\nlines = vmode->yres * par->num_frames;\r\nif (par->full_offset)\r\nlines++;\r\nmaxlines = info->fix.smem_len / ddr_line_length;\r\nfor (dst = 0; lines; dst += maxlines * ddr_line_length) {\r\nunsigned int l = min(lines, maxlines);\r\nps3fb_sync_image(info->device, 0, dst, 0, vmode->xres, l,\r\nddr_line_length, ddr_line_length);\r\nlines -= l;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ps3fb_setcolreg(unsigned int regno, unsigned int red,\r\nunsigned int green, unsigned int blue,\r\nunsigned int transp, struct fb_info *info)\r\n{\r\nif (regno >= 16)\r\nreturn 1;\r\nred >>= 8;\r\ngreen >>= 8;\r\nblue >>= 8;\r\ntransp >>= 8;\r\n((u32 *)info->pseudo_palette)[regno] = transp << 24 | red << 16 |\r\ngreen << 8 | blue;\r\nreturn 0;\r\n}\r\nstatic int ps3fb_pan_display(struct fb_var_screeninfo *var,\r\nstruct fb_info *info)\r\n{\r\nstruct ps3fb_par *par = info->par;\r\npar->pan_offset = var->yoffset * info->fix.line_length +\r\nvar->xoffset * BPP;\r\nreturn 0;\r\n}\r\nstatic int ps3fb_mmap(struct fb_info *info, struct vm_area_struct *vma)\r\n{\r\nunsigned long size, offset;\r\nsize = vma->vm_end - vma->vm_start;\r\noffset = vma->vm_pgoff << PAGE_SHIFT;\r\nif (offset + size > info->fix.smem_len)\r\nreturn -EINVAL;\r\noffset += info->fix.smem_start;\r\nif (remap_pfn_range(vma, vma->vm_start, offset >> PAGE_SHIFT,\r\nsize, vma->vm_page_prot))\r\nreturn -EAGAIN;\r\ndev_dbg(info->device, "ps3fb: mmap framebuffer P(%lx)->V(%lx)\n",\r\noffset, vma->vm_start);\r\nreturn 0;\r\n}\r\nstatic int ps3fb_blank(int blank, struct fb_info *info)\r\n{\r\nint retval;\r\ndev_dbg(info->device, "%s: blank:%d\n", __func__, blank);\r\nswitch (blank) {\r\ncase FB_BLANK_POWERDOWN:\r\ncase FB_BLANK_HSYNC_SUSPEND:\r\ncase FB_BLANK_VSYNC_SUSPEND:\r\ncase FB_BLANK_NORMAL:\r\nretval = ps3av_video_mute(1);\r\nif (!retval)\r\nps3fb.is_blanked = 1;\r\nbreak;\r\ndefault:\r\nretval = ps3av_video_mute(0);\r\nif (!retval)\r\nps3fb.is_blanked = 0;\r\nbreak;\r\n}\r\nreturn retval;\r\n}\r\nstatic int ps3fb_get_vblank(struct fb_vblank *vblank)\r\n{\r\nmemset(vblank, 0, sizeof(*vblank));\r\nvblank->flags = FB_VBLANK_HAVE_VSYNC;\r\nreturn 0;\r\n}\r\nstatic int ps3fb_wait_for_vsync(u32 crtc)\r\n{\r\nint ret;\r\nu64 count;\r\ncount = ps3fb.vblank_count;\r\nret = wait_event_interruptible_timeout(ps3fb.wait_vsync,\r\ncount != ps3fb.vblank_count,\r\nHZ / 10);\r\nif (!ret)\r\nreturn -ETIMEDOUT;\r\nreturn 0;\r\n}\r\nstatic int ps3fb_ioctl(struct fb_info *info, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\nvoid __user *argp = (void __user *)arg;\r\nu32 val;\r\nint retval = -EFAULT;\r\nswitch (cmd) {\r\ncase FBIOGET_VBLANK:\r\n{\r\nstruct fb_vblank vblank;\r\ndev_dbg(info->device, "FBIOGET_VBLANK:\n");\r\nretval = ps3fb_get_vblank(&vblank);\r\nif (retval)\r\nbreak;\r\nif (copy_to_user(argp, &vblank, sizeof(vblank)))\r\nretval = -EFAULT;\r\nbreak;\r\n}\r\ncase FBIO_WAITFORVSYNC:\r\n{\r\nu32 crt;\r\ndev_dbg(info->device, "FBIO_WAITFORVSYNC:\n");\r\nif (get_user(crt, (u32 __user *) arg))\r\nbreak;\r\nretval = ps3fb_wait_for_vsync(crt);\r\nbreak;\r\n}\r\ncase PS3FB_IOCTL_SETMODE:\r\n{\r\nstruct ps3fb_par *par = info->par;\r\nconst struct fb_videomode *vmode;\r\nstruct fb_var_screeninfo var;\r\nif (copy_from_user(&val, argp, sizeof(val)))\r\nbreak;\r\nif (!(val & PS3AV_MODE_MASK)) {\r\nu32 id = ps3av_get_auto_mode();\r\nif (id > 0)\r\nval = (val & ~PS3AV_MODE_MASK) | id;\r\n}\r\ndev_dbg(info->device, "PS3FB_IOCTL_SETMODE:%x\n", val);\r\nretval = -EINVAL;\r\nvmode = ps3fb_vmode(val);\r\nif (vmode) {\r\nvar = info->var;\r\nfb_videomode_to_var(&var, vmode);\r\nconsole_lock();\r\ninfo->flags |= FBINFO_MISC_USEREVENT;\r\nvar.activate |= FB_ACTIVATE_FORCE;\r\npar->new_mode_id = val;\r\nretval = fb_set_var(info, &var);\r\ninfo->flags &= ~FBINFO_MISC_USEREVENT;\r\nconsole_unlock();\r\n}\r\nbreak;\r\n}\r\ncase PS3FB_IOCTL_GETMODE:\r\nval = ps3av_get_mode();\r\ndev_dbg(info->device, "PS3FB_IOCTL_GETMODE:%x\n", val);\r\nif (!copy_to_user(argp, &val, sizeof(val)))\r\nretval = 0;\r\nbreak;\r\ncase PS3FB_IOCTL_SCREENINFO:\r\n{\r\nstruct ps3fb_par *par = info->par;\r\nstruct ps3fb_ioctl_res res;\r\ndev_dbg(info->device, "PS3FB_IOCTL_SCREENINFO:\n");\r\nres.xres = info->fix.line_length / BPP;\r\nres.yres = info->var.yres_virtual;\r\nres.xoff = (res.xres - info->var.xres) / 2;\r\nres.yoff = (res.yres - info->var.yres) / 2;\r\nres.num_frames = par->num_frames;\r\nif (!copy_to_user(argp, &res, sizeof(res)))\r\nretval = 0;\r\nbreak;\r\n}\r\ncase PS3FB_IOCTL_ON:\r\ndev_dbg(info->device, "PS3FB_IOCTL_ON:\n");\r\natomic_inc(&ps3fb.ext_flip);\r\nretval = 0;\r\nbreak;\r\ncase PS3FB_IOCTL_OFF:\r\ndev_dbg(info->device, "PS3FB_IOCTL_OFF:\n");\r\natomic_dec_if_positive(&ps3fb.ext_flip);\r\nretval = 0;\r\nbreak;\r\ncase PS3FB_IOCTL_FSEL:\r\nif (copy_from_user(&val, argp, sizeof(val)))\r\nbreak;\r\ndev_dbg(info->device, "PS3FB_IOCTL_FSEL:%d\n", val);\r\nconsole_lock();\r\nretval = ps3fb_sync(info, val);\r\nconsole_unlock();\r\nbreak;\r\ndefault:\r\nretval = -ENOIOCTLCMD;\r\nbreak;\r\n}\r\nreturn retval;\r\n}\r\nstatic int ps3fbd(void *arg)\r\n{\r\nstruct fb_info *info = arg;\r\nset_freezable();\r\nwhile (!kthread_should_stop()) {\r\ntry_to_freeze();\r\nset_current_state(TASK_INTERRUPTIBLE);\r\nif (ps3fb.is_kicked) {\r\nps3fb.is_kicked = 0;\r\nconsole_lock();\r\nps3fb_sync(info, 0);\r\nconsole_unlock();\r\n}\r\nschedule();\r\n}\r\nreturn 0;\r\n}\r\nstatic irqreturn_t ps3fb_vsync_interrupt(int irq, void *ptr)\r\n{\r\nstruct device *dev = ptr;\r\nu64 v1;\r\nint status;\r\nstruct display_head *head = &ps3fb.dinfo->display_head[1];\r\nstatus = lv1_gpu_context_intr(ps3fb.context_handle, &v1);\r\nif (status) {\r\ndev_err(dev, "%s: lv1_gpu_context_intr failed: %d\n", __func__,\r\nstatus);\r\nreturn IRQ_NONE;\r\n}\r\nif (v1 & (1 << GPU_INTR_STATUS_VSYNC_1)) {\r\nps3fb.vblank_count = head->vblank_count;\r\nif (ps3fb.task && !ps3fb.is_blanked &&\r\n!atomic_read(&ps3fb.ext_flip)) {\r\nps3fb.is_kicked = 1;\r\nwake_up_process(ps3fb.task);\r\n}\r\nwake_up_interruptible(&ps3fb.wait_vsync);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int ps3fb_probe(struct ps3_system_bus_device *dev)\r\n{\r\nstruct fb_info *info;\r\nstruct ps3fb_par *par;\r\nint retval;\r\nu64 ddr_lpar = 0;\r\nu64 lpar_dma_control = 0;\r\nu64 lpar_driver_info = 0;\r\nu64 lpar_reports = 0;\r\nu64 lpar_reports_size = 0;\r\nu64 xdr_lpar;\r\nstruct gpu_driver_info *dinfo;\r\nvoid *fb_start;\r\nint status;\r\nstruct task_struct *task;\r\nunsigned long max_ps3fb_size;\r\nif (ps3fb_videomemory.size < GPU_CMD_BUF_SIZE) {\r\ndev_err(&dev->core, "%s: Not enough video memory\n", __func__);\r\nreturn -ENOMEM;\r\n}\r\nretval = ps3_open_hv_device(dev);\r\nif (retval) {\r\ndev_err(&dev->core, "%s: ps3_open_hv_device failed\n",\r\n__func__);\r\ngoto err;\r\n}\r\nif (!ps3fb_mode)\r\nps3fb_mode = ps3av_get_mode();\r\ndev_dbg(&dev->core, "ps3fb_mode: %d\n", ps3fb_mode);\r\natomic_set(&ps3fb.f_count, -1);\r\natomic_set(&ps3fb.ext_flip, 0);\r\ninit_waitqueue_head(&ps3fb.wait_vsync);\r\n#ifdef HEAD_A\r\nstatus = lv1_gpu_display_sync(0x0, 0, L1GPU_DISPLAY_SYNC_VSYNC);\r\nif (status) {\r\ndev_err(&dev->core, "%s: lv1_gpu_display_sync failed: %d\n",\r\n__func__, status);\r\nretval = -ENODEV;\r\ngoto err_close_device;\r\n}\r\n#endif\r\n#ifdef HEAD_B\r\nstatus = lv1_gpu_display_sync(0x0, 1, L1GPU_DISPLAY_SYNC_VSYNC);\r\nif (status) {\r\ndev_err(&dev->core, "%s: lv1_gpu_display_sync failed: %d\n",\r\n__func__, status);\r\nretval = -ENODEV;\r\ngoto err_close_device;\r\n}\r\n#endif\r\nmax_ps3fb_size = _ALIGN_UP(GPU_IOIF, 256*1024*1024) - GPU_IOIF;\r\nif (ps3fb_videomemory.size > max_ps3fb_size) {\r\ndev_info(&dev->core, "Limiting ps3fb mem size to %lu bytes\n",\r\nmax_ps3fb_size);\r\nps3fb_videomemory.size = max_ps3fb_size;\r\n}\r\nstatus = lv1_gpu_memory_allocate(ps3fb_videomemory.size, 0, 0, 0, 0,\r\n&ps3fb.memory_handle, &ddr_lpar);\r\nif (status) {\r\ndev_err(&dev->core, "%s: lv1_gpu_memory_allocate failed: %d\n",\r\n__func__, status);\r\nretval = -ENOMEM;\r\ngoto err_close_device;\r\n}\r\ndev_dbg(&dev->core, "ddr:lpar:0x%llx\n", ddr_lpar);\r\nstatus = lv1_gpu_context_allocate(ps3fb.memory_handle, 0,\r\n&ps3fb.context_handle,\r\n&lpar_dma_control, &lpar_driver_info,\r\n&lpar_reports, &lpar_reports_size);\r\nif (status) {\r\ndev_err(&dev->core,\r\n"%s: lv1_gpu_context_allocate failed: %d\n", __func__,\r\nstatus);\r\nretval = -ENOMEM;\r\ngoto err_gpu_memory_free;\r\n}\r\ndinfo = (void __force *)ioremap(lpar_driver_info, 128 * 1024);\r\nif (!dinfo) {\r\ndev_err(&dev->core, "%s: ioremap failed\n", __func__);\r\nretval = -ENOMEM;\r\ngoto err_gpu_context_free;\r\n}\r\nps3fb.dinfo = dinfo;\r\ndev_dbg(&dev->core, "version_driver:%x\n", dinfo->version_driver);\r\ndev_dbg(&dev->core, "irq outlet:%x\n", dinfo->irq.irq_outlet);\r\ndev_dbg(&dev->core, "version_gpu: %x memory_size: %x ch: %x "\r\n"core_freq: %d mem_freq:%d\n", dinfo->version_gpu,\r\ndinfo->memory_size, dinfo->hardware_channel,\r\ndinfo->nvcore_frequency/1000000,\r\ndinfo->memory_frequency/1000000);\r\nif (dinfo->version_driver != GPU_DRIVER_INFO_VERSION) {\r\ndev_err(&dev->core, "%s: version_driver err:%x\n", __func__,\r\ndinfo->version_driver);\r\nretval = -EINVAL;\r\ngoto err_iounmap_dinfo;\r\n}\r\nretval = ps3_irq_plug_setup(PS3_BINDING_CPU_ANY, dinfo->irq.irq_outlet,\r\n&ps3fb.irq_no);\r\nif (retval) {\r\ndev_err(&dev->core, "%s: ps3_alloc_irq failed %d\n", __func__,\r\nretval);\r\ngoto err_iounmap_dinfo;\r\n}\r\nretval = request_irq(ps3fb.irq_no, ps3fb_vsync_interrupt,\r\n0, DEVICE_NAME, &dev->core);\r\nif (retval) {\r\ndev_err(&dev->core, "%s: request_irq failed %d\n", __func__,\r\nretval);\r\ngoto err_destroy_plug;\r\n}\r\ndinfo->irq.mask = (1 << GPU_INTR_STATUS_VSYNC_1) |\r\n(1 << GPU_INTR_STATUS_FLIP_1);\r\nmemset(ps3fb_videomemory.address, 0, ps3fb_videomemory.size);\r\nxdr_lpar = ps3_mm_phys_to_lpar(__pa(ps3fb_videomemory.address));\r\nstatus = lv1_gpu_context_iomap(ps3fb.context_handle, GPU_IOIF,\r\nxdr_lpar, ps3fb_videomemory.size,\r\nCBE_IOPTE_PP_W | CBE_IOPTE_PP_R |\r\nCBE_IOPTE_M);\r\nif (status) {\r\ndev_err(&dev->core, "%s: lv1_gpu_context_iomap failed: %d\n",\r\n__func__, status);\r\nretval = -ENXIO;\r\ngoto err_free_irq;\r\n}\r\ndev_dbg(&dev->core, "video:%p ioif:%lx lpar:%llx size:%lx\n",\r\nps3fb_videomemory.address, GPU_IOIF, xdr_lpar,\r\nps3fb_videomemory.size);\r\nstatus = lv1_gpu_fb_setup(ps3fb.context_handle, xdr_lpar,\r\nGPU_CMD_BUF_SIZE, GPU_IOIF);\r\nif (status) {\r\ndev_err(&dev->core, "%s: lv1_gpu_fb_setup failed: %d\n",\r\n__func__, status);\r\nretval = -ENXIO;\r\ngoto err_context_unmap;\r\n}\r\ninfo = framebuffer_alloc(sizeof(struct ps3fb_par), &dev->core);\r\nif (!info) {\r\nretval = -ENOMEM;\r\ngoto err_context_fb_close;\r\n}\r\npar = info->par;\r\npar->mode_id = ~ps3fb_mode;\r\npar->new_mode_id = ps3fb_mode;\r\npar->num_frames = 1;\r\ninfo->fbops = &ps3fb_ops;\r\ninfo->fix = ps3fb_fix;\r\nfb_start = ps3fb_videomemory.address + GPU_FB_START;\r\ninfo->screen_base = (char __force __iomem *)fb_start;\r\ninfo->fix.smem_start = __pa(fb_start);\r\ninfo->fix.smem_len = ps3fb_videomemory.size - GPU_FB_START;\r\ninfo->pseudo_palette = par->pseudo_palette;\r\ninfo->flags = FBINFO_DEFAULT | FBINFO_READS_FAST |\r\nFBINFO_HWACCEL_XPAN | FBINFO_HWACCEL_YPAN;\r\nretval = fb_alloc_cmap(&info->cmap, 256, 0);\r\nif (retval < 0)\r\ngoto err_framebuffer_release;\r\nif (!fb_find_mode(&info->var, info, mode_option, ps3fb_modedb,\r\nARRAY_SIZE(ps3fb_modedb),\r\nps3fb_vmode(par->new_mode_id), 32)) {\r\nretval = -EINVAL;\r\ngoto err_fb_dealloc;\r\n}\r\nfb_videomode_to_modelist(ps3fb_modedb, ARRAY_SIZE(ps3fb_modedb),\r\n&info->modelist);\r\nretval = register_framebuffer(info);\r\nif (retval < 0)\r\ngoto err_fb_dealloc;\r\nps3_system_bus_set_drvdata(dev, info);\r\ndev_info(info->device, "%s %s, using %u KiB of video memory\n",\r\ndev_driver_string(info->dev), dev_name(info->dev),\r\ninfo->fix.smem_len >> 10);\r\ntask = kthread_run(ps3fbd, info, DEVICE_NAME);\r\nif (IS_ERR(task)) {\r\nretval = PTR_ERR(task);\r\ngoto err_unregister_framebuffer;\r\n}\r\nps3fb.task = task;\r\nreturn 0;\r\nerr_unregister_framebuffer:\r\nunregister_framebuffer(info);\r\nerr_fb_dealloc:\r\nfb_dealloc_cmap(&info->cmap);\r\nerr_framebuffer_release:\r\nframebuffer_release(info);\r\nerr_context_fb_close:\r\nlv1_gpu_fb_close(ps3fb.context_handle);\r\nerr_context_unmap:\r\nlv1_gpu_context_iomap(ps3fb.context_handle, GPU_IOIF, xdr_lpar,\r\nps3fb_videomemory.size, CBE_IOPTE_M);\r\nerr_free_irq:\r\nfree_irq(ps3fb.irq_no, &dev->core);\r\nerr_destroy_plug:\r\nps3_irq_plug_destroy(ps3fb.irq_no);\r\nerr_iounmap_dinfo:\r\niounmap((u8 __force __iomem *)ps3fb.dinfo);\r\nerr_gpu_context_free:\r\nlv1_gpu_context_free(ps3fb.context_handle);\r\nerr_gpu_memory_free:\r\nlv1_gpu_memory_free(ps3fb.memory_handle);\r\nerr_close_device:\r\nps3_close_hv_device(dev);\r\nerr:\r\nreturn retval;\r\n}\r\nstatic int ps3fb_shutdown(struct ps3_system_bus_device *dev)\r\n{\r\nstruct fb_info *info = ps3_system_bus_get_drvdata(dev);\r\nu64 xdr_lpar = ps3_mm_phys_to_lpar(__pa(ps3fb_videomemory.address));\r\ndev_dbg(&dev->core, " -> %s:%d\n", __func__, __LINE__);\r\natomic_inc(&ps3fb.ext_flip);\r\nps3fb.dinfo->irq.mask = 0;\r\nif (ps3fb.task) {\r\nstruct task_struct *task = ps3fb.task;\r\nps3fb.task = NULL;\r\nkthread_stop(task);\r\n}\r\nif (ps3fb.irq_no) {\r\nfree_irq(ps3fb.irq_no, &dev->core);\r\nps3_irq_plug_destroy(ps3fb.irq_no);\r\n}\r\nif (info) {\r\nunregister_framebuffer(info);\r\nfb_dealloc_cmap(&info->cmap);\r\nframebuffer_release(info);\r\nps3_system_bus_set_drvdata(dev, NULL);\r\n}\r\niounmap((u8 __force __iomem *)ps3fb.dinfo);\r\nlv1_gpu_fb_close(ps3fb.context_handle);\r\nlv1_gpu_context_iomap(ps3fb.context_handle, GPU_IOIF, xdr_lpar,\r\nps3fb_videomemory.size, CBE_IOPTE_M);\r\nlv1_gpu_context_free(ps3fb.context_handle);\r\nlv1_gpu_memory_free(ps3fb.memory_handle);\r\nps3_close_hv_device(dev);\r\ndev_dbg(&dev->core, " <- %s:%d\n", __func__, __LINE__);\r\nreturn 0;\r\n}\r\nstatic int __init ps3fb_setup(void)\r\n{\r\nchar *options;\r\n#ifdef MODULE\r\nreturn 0;\r\n#endif\r\nif (fb_get_options(DEVICE_NAME, &options))\r\nreturn -ENXIO;\r\nif (!options || !*options)\r\nreturn 0;\r\nwhile (1) {\r\nchar *this_opt = strsep(&options, ",");\r\nif (!this_opt)\r\nbreak;\r\nif (!*this_opt)\r\ncontinue;\r\nif (!strncmp(this_opt, "mode:", 5))\r\nps3fb_mode = simple_strtoul(this_opt + 5, NULL, 0);\r\nelse\r\nmode_option = this_opt;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init ps3fb_init(void)\r\n{\r\nif (!ps3fb_videomemory.address || ps3fb_setup())\r\nreturn -ENXIO;\r\nreturn ps3_system_bus_driver_register(&ps3fb_driver);\r\n}\r\nstatic void __exit ps3fb_exit(void)\r\n{\r\npr_debug(" -> %s:%d\n", __func__, __LINE__);\r\nps3_system_bus_driver_unregister(&ps3fb_driver);\r\npr_debug(" <- %s:%d\n", __func__, __LINE__);\r\n}
