static int imx_drm_driver_firstopen(struct drm_device *drm)\r\n{\r\nif (!imx_drm_device_get())\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic void imx_drm_driver_lastclose(struct drm_device *drm)\r\n{\r\nstruct imx_drm_device *imxdrm = drm->dev_private;\r\nif (imxdrm->fbhelper)\r\ndrm_fbdev_cma_restore_mode(imxdrm->fbhelper);\r\nimx_drm_device_put();\r\n}\r\nstatic int imx_drm_driver_unload(struct drm_device *drm)\r\n{\r\nstruct imx_drm_device *imxdrm = drm->dev_private;\r\ndrm_mode_config_cleanup(imxdrm->drm);\r\ndrm_kms_helper_poll_fini(imxdrm->drm);\r\nreturn 0;\r\n}\r\nstatic struct imx_drm_crtc *imx_drm_crtc_by_num(struct imx_drm_device *imxdrm,\r\nint num)\r\n{\r\nstruct imx_drm_crtc *imx_drm_crtc;\r\nlist_for_each_entry(imx_drm_crtc, &imxdrm->crtc_list, list)\r\nif (imx_drm_crtc->pipe == num)\r\nreturn imx_drm_crtc;\r\nreturn NULL;\r\n}\r\nint imx_drm_crtc_panel_format(struct drm_crtc *crtc, u32 encoder_type,\r\nu32 interface_pix_fmt)\r\n{\r\nstruct imx_drm_device *imxdrm = crtc->dev->dev_private;\r\nstruct imx_drm_crtc *imx_crtc;\r\nstruct imx_drm_crtc_helper_funcs *helper;\r\nmutex_lock(&imxdrm->mutex);\r\nlist_for_each_entry(imx_crtc, &imxdrm->crtc_list, list)\r\nif (imx_crtc->crtc == crtc)\r\ngoto found;\r\nmutex_unlock(&imxdrm->mutex);\r\nreturn -EINVAL;\r\nfound:\r\nmutex_unlock(&imxdrm->mutex);\r\nhelper = &imx_crtc->imx_drm_helper_funcs;\r\nif (helper->set_interface_pix_fmt)\r\nreturn helper->set_interface_pix_fmt(crtc,\r\nencoder_type, interface_pix_fmt);\r\nreturn 0;\r\n}\r\nint imx_drm_crtc_vblank_get(struct imx_drm_crtc *imx_drm_crtc)\r\n{\r\nreturn drm_vblank_get(imx_drm_crtc->imxdrm->drm, imx_drm_crtc->pipe);\r\n}\r\nvoid imx_drm_crtc_vblank_put(struct imx_drm_crtc *imx_drm_crtc)\r\n{\r\ndrm_vblank_put(imx_drm_crtc->imxdrm->drm, imx_drm_crtc->pipe);\r\n}\r\nvoid imx_drm_handle_vblank(struct imx_drm_crtc *imx_drm_crtc)\r\n{\r\ndrm_handle_vblank(imx_drm_crtc->imxdrm->drm, imx_drm_crtc->pipe);\r\n}\r\nstatic int imx_drm_enable_vblank(struct drm_device *drm, int crtc)\r\n{\r\nstruct imx_drm_device *imxdrm = drm->dev_private;\r\nstruct imx_drm_crtc *imx_drm_crtc;\r\nint ret;\r\nimx_drm_crtc = imx_drm_crtc_by_num(imxdrm, crtc);\r\nif (!imx_drm_crtc)\r\nreturn -EINVAL;\r\nif (!imx_drm_crtc->imx_drm_helper_funcs.enable_vblank)\r\nreturn -ENOSYS;\r\nret = imx_drm_crtc->imx_drm_helper_funcs.enable_vblank(\r\nimx_drm_crtc->crtc);\r\nreturn ret;\r\n}\r\nstatic void imx_drm_disable_vblank(struct drm_device *drm, int crtc)\r\n{\r\nstruct imx_drm_device *imxdrm = drm->dev_private;\r\nstruct imx_drm_crtc *imx_drm_crtc;\r\nimx_drm_crtc = imx_drm_crtc_by_num(imxdrm, crtc);\r\nif (!imx_drm_crtc)\r\nreturn;\r\nif (!imx_drm_crtc->imx_drm_helper_funcs.disable_vblank)\r\nreturn;\r\nimx_drm_crtc->imx_drm_helper_funcs.disable_vblank(imx_drm_crtc->crtc);\r\n}\r\nstatic struct imx_drm_device *__imx_drm_device(void)\r\n{\r\nreturn imx_drm_device;\r\n}\r\nstruct drm_device *imx_drm_device_get(void)\r\n{\r\nstruct imx_drm_device *imxdrm = __imx_drm_device();\r\nstruct imx_drm_encoder *enc;\r\nstruct imx_drm_connector *con;\r\nstruct imx_drm_crtc *crtc;\r\nmutex_lock(&imxdrm->mutex);\r\nlist_for_each_entry(enc, &imxdrm->encoder_list, list) {\r\nif (!try_module_get(enc->owner)) {\r\ndev_err(imxdrm->dev, "could not get module %s\n",\r\nmodule_name(enc->owner));\r\ngoto unwind_enc;\r\n}\r\n}\r\nlist_for_each_entry(con, &imxdrm->connector_list, list) {\r\nif (!try_module_get(con->owner)) {\r\ndev_err(imxdrm->dev, "could not get module %s\n",\r\nmodule_name(con->owner));\r\ngoto unwind_con;\r\n}\r\n}\r\nlist_for_each_entry(crtc, &imxdrm->crtc_list, list) {\r\nif (!try_module_get(crtc->owner)) {\r\ndev_err(imxdrm->dev, "could not get module %s\n",\r\nmodule_name(crtc->owner));\r\ngoto unwind_crtc;\r\n}\r\n}\r\nimxdrm->references++;\r\nmutex_unlock(&imxdrm->mutex);\r\nreturn imxdrm->drm;\r\nunwind_crtc:\r\nlist_for_each_entry_continue_reverse(crtc, &imxdrm->crtc_list, list)\r\nmodule_put(crtc->owner);\r\nunwind_con:\r\nlist_for_each_entry_continue_reverse(con, &imxdrm->connector_list, list)\r\nmodule_put(con->owner);\r\nunwind_enc:\r\nlist_for_each_entry_continue_reverse(enc, &imxdrm->encoder_list, list)\r\nmodule_put(enc->owner);\r\nmutex_unlock(&imxdrm->mutex);\r\nreturn NULL;\r\n}\r\nvoid imx_drm_device_put(void)\r\n{\r\nstruct imx_drm_device *imxdrm = __imx_drm_device();\r\nstruct imx_drm_encoder *enc;\r\nstruct imx_drm_connector *con;\r\nstruct imx_drm_crtc *crtc;\r\nmutex_lock(&imxdrm->mutex);\r\nlist_for_each_entry(crtc, &imxdrm->crtc_list, list)\r\nmodule_put(crtc->owner);\r\nlist_for_each_entry(con, &imxdrm->connector_list, list)\r\nmodule_put(con->owner);\r\nlist_for_each_entry(enc, &imxdrm->encoder_list, list)\r\nmodule_put(enc->owner);\r\nimxdrm->references--;\r\nmutex_unlock(&imxdrm->mutex);\r\n}\r\nstatic int drm_mode_group_reinit(struct drm_device *dev)\r\n{\r\nstruct drm_mode_group *group = &dev->primary->mode_group;\r\nuint32_t *id_list = group->id_list;\r\nint ret;\r\nret = drm_mode_group_init_legacy_group(dev, group);\r\nif (ret < 0)\r\nreturn ret;\r\nkfree(id_list);\r\nreturn 0;\r\n}\r\nstatic int imx_drm_encoder_register(struct imx_drm_encoder *imx_drm_encoder)\r\n{\r\nstruct imx_drm_device *imxdrm = __imx_drm_device();\r\nINIT_LIST_HEAD(&imx_drm_encoder->possible_crtcs);\r\ndrm_encoder_init(imxdrm->drm, imx_drm_encoder->encoder,\r\nimx_drm_encoder->encoder->funcs,\r\nimx_drm_encoder->encoder->encoder_type);\r\ndrm_mode_group_reinit(imxdrm->drm);\r\nreturn 0;\r\n}\r\nstatic void imx_drm_encoder_unregister(struct imx_drm_encoder\r\n*imx_drm_encoder)\r\n{\r\nstruct imx_drm_device *imxdrm = __imx_drm_device();\r\ndrm_encoder_cleanup(imx_drm_encoder->encoder);\r\ndrm_mode_group_reinit(imxdrm->drm);\r\n}\r\nstatic int imx_drm_connector_register(\r\nstruct imx_drm_connector *imx_drm_connector)\r\n{\r\nstruct imx_drm_device *imxdrm = __imx_drm_device();\r\ndrm_connector_init(imxdrm->drm, imx_drm_connector->connector,\r\nimx_drm_connector->connector->funcs,\r\nimx_drm_connector->connector->connector_type);\r\ndrm_mode_group_reinit(imxdrm->drm);\r\nreturn drm_sysfs_connector_add(imx_drm_connector->connector);\r\n}\r\nstatic void imx_drm_connector_unregister(\r\nstruct imx_drm_connector *imx_drm_connector)\r\n{\r\nstruct imx_drm_device *imxdrm = __imx_drm_device();\r\ndrm_sysfs_connector_remove(imx_drm_connector->connector);\r\ndrm_connector_cleanup(imx_drm_connector->connector);\r\ndrm_mode_group_reinit(imxdrm->drm);\r\n}\r\nstatic int imx_drm_crtc_register(struct imx_drm_crtc *imx_drm_crtc)\r\n{\r\nstruct imx_drm_device *imxdrm = __imx_drm_device();\r\nint ret;\r\ndrm_crtc_init(imxdrm->drm, imx_drm_crtc->crtc,\r\nimx_drm_crtc->imx_drm_helper_funcs.crtc_funcs);\r\nret = drm_mode_crtc_set_gamma_size(imx_drm_crtc->crtc, 256);\r\nif (ret)\r\nreturn ret;\r\ndrm_crtc_helper_add(imx_drm_crtc->crtc,\r\nimx_drm_crtc->imx_drm_helper_funcs.crtc_helper_funcs);\r\ndrm_mode_group_reinit(imxdrm->drm);\r\nreturn 0;\r\n}\r\nstatic int imx_drm_driver_load(struct drm_device *drm, unsigned long flags)\r\n{\r\nstruct imx_drm_device *imxdrm = __imx_drm_device();\r\nint ret;\r\nimxdrm->drm = drm;\r\ndrm->dev_private = imxdrm;\r\ndrm->irq_enabled = 1;\r\ndrm_mode_config_init(drm);\r\nimx_drm_mode_config_init(drm);\r\nmutex_lock(&imxdrm->mutex);\r\ndrm_kms_helper_poll_init(imxdrm->drm);\r\nret = drm_mode_group_init_legacy_group(imxdrm->drm,\r\n&imxdrm->drm->primary->mode_group);\r\nif (ret)\r\ngoto err_init;\r\nret = drm_vblank_init(imxdrm->drm, MAX_CRTC);\r\nif (ret)\r\ngoto err_init;\r\nimxdrm->drm->vblank_disable_allowed = 1;\r\nret = 0;\r\nerr_init:\r\nmutex_unlock(&imxdrm->mutex);\r\nreturn ret;\r\n}\r\nstatic void imx_drm_update_possible_crtcs(void)\r\n{\r\nstruct imx_drm_device *imxdrm = __imx_drm_device();\r\nstruct imx_drm_crtc *imx_drm_crtc;\r\nstruct imx_drm_encoder *enc;\r\nstruct crtc_cookie *cookie;\r\nlist_for_each_entry(enc, &imxdrm->encoder_list, list) {\r\nu32 possible_crtcs = 0;\r\nlist_for_each_entry(cookie, &enc->possible_crtcs, list) {\r\nlist_for_each_entry(imx_drm_crtc, &imxdrm->crtc_list, list) {\r\nif (imx_drm_crtc->cookie.cookie == cookie->cookie &&\r\nimx_drm_crtc->cookie.id == cookie->id) {\r\npossible_crtcs |= 1 << imx_drm_crtc->pipe;\r\n}\r\n}\r\n}\r\nenc->encoder->possible_crtcs = possible_crtcs;\r\nenc->encoder->possible_clones = possible_crtcs;\r\n}\r\n}\r\nint imx_drm_add_crtc(struct drm_crtc *crtc,\r\nstruct imx_drm_crtc **new_crtc,\r\nconst struct imx_drm_crtc_helper_funcs *imx_drm_helper_funcs,\r\nstruct module *owner, void *cookie, int id)\r\n{\r\nstruct imx_drm_device *imxdrm = __imx_drm_device();\r\nstruct imx_drm_crtc *imx_drm_crtc;\r\nconst struct drm_crtc_funcs *crtc_funcs;\r\nint ret;\r\nmutex_lock(&imxdrm->mutex);\r\nif (imxdrm->references) {\r\nret = -EBUSY;\r\ngoto err_busy;\r\n}\r\nimx_drm_crtc = kzalloc(sizeof(*imx_drm_crtc), GFP_KERNEL);\r\nif (!imx_drm_crtc) {\r\nret = -ENOMEM;\r\ngoto err_alloc;\r\n}\r\nimx_drm_crtc->imx_drm_helper_funcs = *imx_drm_helper_funcs;\r\nimx_drm_crtc->pipe = imxdrm->pipes++;\r\nimx_drm_crtc->cookie.cookie = cookie;\r\nimx_drm_crtc->cookie.id = id;\r\ncrtc_funcs = imx_drm_helper_funcs->crtc_funcs;\r\nimx_drm_crtc->crtc = crtc;\r\nimx_drm_crtc->imxdrm = imxdrm;\r\nimx_drm_crtc->owner = owner;\r\nlist_add_tail(&imx_drm_crtc->list, &imxdrm->crtc_list);\r\n*new_crtc = imx_drm_crtc;\r\nret = imx_drm_crtc_register(imx_drm_crtc);\r\nif (ret)\r\ngoto err_register;\r\nimx_drm_update_possible_crtcs();\r\nmutex_unlock(&imxdrm->mutex);\r\nreturn 0;\r\nerr_register:\r\nkfree(imx_drm_crtc);\r\nerr_alloc:\r\nerr_busy:\r\nmutex_unlock(&imxdrm->mutex);\r\nreturn ret;\r\n}\r\nint imx_drm_remove_crtc(struct imx_drm_crtc *imx_drm_crtc)\r\n{\r\nstruct imx_drm_device *imxdrm = imx_drm_crtc->imxdrm;\r\nmutex_lock(&imxdrm->mutex);\r\ndrm_crtc_cleanup(imx_drm_crtc->crtc);\r\nlist_del(&imx_drm_crtc->list);\r\ndrm_mode_group_reinit(imxdrm->drm);\r\nmutex_unlock(&imxdrm->mutex);\r\nkfree(imx_drm_crtc);\r\nreturn 0;\r\n}\r\nint imx_drm_add_encoder(struct drm_encoder *encoder,\r\nstruct imx_drm_encoder **newenc, struct module *owner)\r\n{\r\nstruct imx_drm_device *imxdrm = __imx_drm_device();\r\nstruct imx_drm_encoder *imx_drm_encoder;\r\nint ret;\r\nmutex_lock(&imxdrm->mutex);\r\nif (imxdrm->references) {\r\nret = -EBUSY;\r\ngoto err_busy;\r\n}\r\nimx_drm_encoder = kzalloc(sizeof(*imx_drm_encoder), GFP_KERNEL);\r\nif (!imx_drm_encoder) {\r\nret = -ENOMEM;\r\ngoto err_alloc;\r\n}\r\nimx_drm_encoder->encoder = encoder;\r\nimx_drm_encoder->owner = owner;\r\nret = imx_drm_encoder_register(imx_drm_encoder);\r\nif (ret) {\r\nret = -ENOMEM;\r\ngoto err_register;\r\n}\r\nlist_add_tail(&imx_drm_encoder->list, &imxdrm->encoder_list);\r\n*newenc = imx_drm_encoder;\r\nmutex_unlock(&imxdrm->mutex);\r\nreturn 0;\r\nerr_register:\r\nkfree(imx_drm_encoder);\r\nerr_alloc:\r\nerr_busy:\r\nmutex_unlock(&imxdrm->mutex);\r\nreturn ret;\r\n}\r\nint imx_drm_encoder_add_possible_crtcs(\r\nstruct imx_drm_encoder *imx_drm_encoder,\r\nstruct device_node *np)\r\n{\r\nstruct imx_drm_device *imxdrm = __imx_drm_device();\r\nstruct of_phandle_args args;\r\nstruct crtc_cookie *c;\r\nint ret = 0;\r\nint i;\r\nif (!list_empty(&imx_drm_encoder->possible_crtcs))\r\nreturn -EBUSY;\r\nfor (i = 0; !ret; i++) {\r\nret = of_parse_phandle_with_args(np, "crtcs",\r\n"#crtc-cells", i, &args);\r\nif (ret < 0)\r\nbreak;\r\nc = kzalloc(sizeof(*c), GFP_KERNEL);\r\nif (!c) {\r\nof_node_put(args.np);\r\nreturn -ENOMEM;\r\n}\r\nc->cookie = args.np;\r\nc->id = args.args_count > 0 ? args.args[0] : 0;\r\nof_node_put(args.np);\r\nmutex_lock(&imxdrm->mutex);\r\nlist_add_tail(&c->list, &imx_drm_encoder->possible_crtcs);\r\nmutex_unlock(&imxdrm->mutex);\r\n}\r\nimx_drm_update_possible_crtcs();\r\nreturn 0;\r\n}\r\nint imx_drm_encoder_get_mux_id(struct imx_drm_encoder *imx_drm_encoder,\r\nstruct drm_crtc *crtc)\r\n{\r\nstruct imx_drm_device *imxdrm = __imx_drm_device();\r\nstruct imx_drm_crtc *imx_crtc;\r\nint i = 0;\r\nmutex_lock(&imxdrm->mutex);\r\nlist_for_each_entry(imx_crtc, &imxdrm->crtc_list, list) {\r\nif (imx_crtc->crtc == crtc)\r\ngoto found;\r\ni++;\r\n}\r\nmutex_unlock(&imxdrm->mutex);\r\nreturn -EINVAL;\r\nfound:\r\nmutex_unlock(&imxdrm->mutex);\r\nreturn i;\r\n}\r\nint imx_drm_remove_encoder(struct imx_drm_encoder *imx_drm_encoder)\r\n{\r\nstruct imx_drm_device *imxdrm = __imx_drm_device();\r\nstruct crtc_cookie *c, *tmp;\r\nmutex_lock(&imxdrm->mutex);\r\nimx_drm_encoder_unregister(imx_drm_encoder);\r\nlist_del(&imx_drm_encoder->list);\r\nlist_for_each_entry_safe(c, tmp, &imx_drm_encoder->possible_crtcs,\r\nlist)\r\nkfree(c);\r\nmutex_unlock(&imxdrm->mutex);\r\nkfree(imx_drm_encoder);\r\nreturn 0;\r\n}\r\nint imx_drm_add_connector(struct drm_connector *connector,\r\nstruct imx_drm_connector **new_con,\r\nstruct module *owner)\r\n{\r\nstruct imx_drm_device *imxdrm = __imx_drm_device();\r\nstruct imx_drm_connector *imx_drm_connector;\r\nint ret;\r\nmutex_lock(&imxdrm->mutex);\r\nif (imxdrm->references) {\r\nret = -EBUSY;\r\ngoto err_busy;\r\n}\r\nimx_drm_connector = kzalloc(sizeof(*imx_drm_connector), GFP_KERNEL);\r\nif (!imx_drm_connector) {\r\nret = -ENOMEM;\r\ngoto err_alloc;\r\n}\r\nimx_drm_connector->connector = connector;\r\nimx_drm_connector->owner = owner;\r\nret = imx_drm_connector_register(imx_drm_connector);\r\nif (ret)\r\ngoto err_register;\r\nlist_add_tail(&imx_drm_connector->list, &imxdrm->connector_list);\r\n*new_con = imx_drm_connector;\r\nmutex_unlock(&imxdrm->mutex);\r\nreturn 0;\r\nerr_register:\r\nkfree(imx_drm_connector);\r\nerr_alloc:\r\nerr_busy:\r\nmutex_unlock(&imxdrm->mutex);\r\nreturn ret;\r\n}\r\nvoid imx_drm_fb_helper_set(struct drm_fbdev_cma *fbdev_helper)\r\n{\r\nstruct imx_drm_device *imxdrm = __imx_drm_device();\r\nimxdrm->fbhelper = fbdev_helper;\r\n}\r\nint imx_drm_remove_connector(struct imx_drm_connector *imx_drm_connector)\r\n{\r\nstruct imx_drm_device *imxdrm = __imx_drm_device();\r\nmutex_lock(&imxdrm->mutex);\r\nimx_drm_connector_unregister(imx_drm_connector);\r\nlist_del(&imx_drm_connector->list);\r\nmutex_unlock(&imxdrm->mutex);\r\nkfree(imx_drm_connector);\r\nreturn 0;\r\n}\r\nstatic int imx_drm_platform_probe(struct platform_device *pdev)\r\n{\r\nimx_drm_device->dev = &pdev->dev;\r\nreturn drm_platform_init(&imx_drm_driver, pdev);\r\n}\r\nstatic int imx_drm_platform_remove(struct platform_device *pdev)\r\n{\r\ndrm_platform_exit(&imx_drm_driver, pdev);\r\nreturn 0;\r\n}\r\nstatic int __init imx_drm_init(void)\r\n{\r\nint ret;\r\nimx_drm_device = kzalloc(sizeof(*imx_drm_device), GFP_KERNEL);\r\nif (!imx_drm_device)\r\nreturn -ENOMEM;\r\nmutex_init(&imx_drm_device->mutex);\r\nINIT_LIST_HEAD(&imx_drm_device->crtc_list);\r\nINIT_LIST_HEAD(&imx_drm_device->connector_list);\r\nINIT_LIST_HEAD(&imx_drm_device->encoder_list);\r\nimx_drm_pdev = platform_device_register_simple("imx-drm", -1, NULL, 0);\r\nif (!imx_drm_pdev) {\r\nret = -EINVAL;\r\ngoto err_pdev;\r\n}\r\nimx_drm_pdev->dev.coherent_dma_mask = DMA_BIT_MASK(32),\r\nret = platform_driver_register(&imx_drm_pdrv);\r\nif (ret)\r\ngoto err_pdrv;\r\nreturn 0;\r\nerr_pdrv:\r\nplatform_device_unregister(imx_drm_pdev);\r\nerr_pdev:\r\nkfree(imx_drm_device);\r\nreturn ret;\r\n}\r\nstatic void __exit imx_drm_exit(void)\r\n{\r\nplatform_device_unregister(imx_drm_pdev);\r\nplatform_driver_unregister(&imx_drm_pdrv);\r\nkfree(imx_drm_device);\r\n}
