static int aci_busy_wait(struct snd_miro_aci *aci)\r\n{\r\nlong timeout;\r\nunsigned char byte;\r\nfor (timeout = 1; timeout <= ACI_MINTIME + 30; timeout++) {\r\nbyte = inb(aci->aci_port + ACI_REG_BUSY);\r\nif ((byte & 1) == 0) {\r\nif (timeout >= ACI_MINTIME)\r\nsnd_printd("aci ready in round %ld.\n",\r\ntimeout-ACI_MINTIME);\r\nreturn byte;\r\n}\r\nif (timeout >= ACI_MINTIME) {\r\nlong out=10*HZ;\r\nswitch (timeout-ACI_MINTIME) {\r\ncase 0 ... 9:\r\nout /= 10;\r\ncase 10 ... 19:\r\nout /= 10;\r\ncase 20 ... 30:\r\nout /= 10;\r\ndefault:\r\nset_current_state(TASK_UNINTERRUPTIBLE);\r\nschedule_timeout(out);\r\nbreak;\r\n}\r\n}\r\n}\r\nsnd_printk(KERN_ERR "aci_busy_wait() time out\n");\r\nreturn -EBUSY;\r\n}\r\nstatic inline int aci_write(struct snd_miro_aci *aci, unsigned char byte)\r\n{\r\nif (aci_busy_wait(aci) >= 0) {\r\noutb(byte, aci->aci_port + ACI_REG_COMMAND);\r\nreturn 0;\r\n} else {\r\nsnd_printk(KERN_ERR "aci busy, aci_write(0x%x) stopped.\n", byte);\r\nreturn -EBUSY;\r\n}\r\n}\r\nstatic inline int aci_read(struct snd_miro_aci *aci)\r\n{\r\nunsigned char byte;\r\nif (aci_busy_wait(aci) >= 0) {\r\nbyte = inb(aci->aci_port + ACI_REG_STATUS);\r\nreturn byte;\r\n} else {\r\nsnd_printk(KERN_ERR "aci busy, aci_read() stopped.\n");\r\nreturn -EBUSY;\r\n}\r\n}\r\nint snd_aci_cmd(struct snd_miro_aci *aci, int write1, int write2, int write3)\r\n{\r\nint write[] = {write1, write2, write3};\r\nint value, i;\r\nif (mutex_lock_interruptible(&aci->aci_mutex))\r\nreturn -EINTR;\r\nfor (i=0; i<3; i++) {\r\nif (write[i]< 0 || write[i] > 255)\r\nbreak;\r\nelse {\r\nvalue = aci_write(aci, write[i]);\r\nif (value < 0)\r\ngoto out;\r\n}\r\n}\r\nvalue = aci_read(aci);\r\nout: mutex_unlock(&aci->aci_mutex);\r\nreturn value;\r\n}\r\nstatic int aci_getvalue(struct snd_miro_aci *aci, unsigned char index)\r\n{\r\nreturn snd_aci_cmd(aci, ACI_STATUS, index, -1);\r\n}\r\nstatic int aci_setvalue(struct snd_miro_aci *aci, unsigned char index,\r\nint value)\r\n{\r\nreturn snd_aci_cmd(aci, index, value, -1);\r\n}\r\nstruct snd_miro_aci *snd_aci_get_aci(void)\r\n{\r\nif (aci_device.aci_port == 0)\r\nreturn NULL;\r\nreturn &aci_device;\r\n}\r\nstatic int snd_miro_get_capture(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_miro *miro = snd_kcontrol_chip(kcontrol);\r\nint value;\r\nvalue = aci_getvalue(miro->aci, ACI_S_GENERAL);\r\nif (value < 0) {\r\nsnd_printk(KERN_ERR "snd_miro_get_capture() failed: %d\n",\r\nvalue);\r\nreturn value;\r\n}\r\nucontrol->value.integer.value[0] = value & 0x20;\r\nreturn 0;\r\n}\r\nstatic int snd_miro_put_capture(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_miro *miro = snd_kcontrol_chip(kcontrol);\r\nint change, value, error;\r\nvalue = !(ucontrol->value.integer.value[0]);\r\nerror = aci_setvalue(miro->aci, ACI_SET_SOLOMODE, value);\r\nif (error < 0) {\r\nsnd_printk(KERN_ERR "snd_miro_put_capture() failed: %d\n",\r\nerror);\r\nreturn error;\r\n}\r\nchange = (value != miro->aci->aci_solomode);\r\nmiro->aci->aci_solomode = value;\r\nreturn change;\r\n}\r\nstatic int snd_miro_info_preamp(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\r\nuinfo->count = 1;\r\nuinfo->value.integer.min = 0;\r\nuinfo->value.integer.max = 3;\r\nreturn 0;\r\n}\r\nstatic int snd_miro_get_preamp(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_miro *miro = snd_kcontrol_chip(kcontrol);\r\nint value;\r\nif (miro->aci->aci_version <= 176) {\r\nucontrol->value.integer.value[0] = miro->aci->aci_preamp;\r\nreturn 0;\r\n}\r\nvalue = aci_getvalue(miro->aci, ACI_GET_PREAMP);\r\nif (value < 0) {\r\nsnd_printk(KERN_ERR "snd_miro_get_preamp() failed: %d\n",\r\nvalue);\r\nreturn value;\r\n}\r\nucontrol->value.integer.value[0] = value;\r\nreturn 0;\r\n}\r\nstatic int snd_miro_put_preamp(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_miro *miro = snd_kcontrol_chip(kcontrol);\r\nint error, value, change;\r\nvalue = ucontrol->value.integer.value[0];\r\nerror = aci_setvalue(miro->aci, ACI_SET_PREAMP, value);\r\nif (error < 0) {\r\nsnd_printk(KERN_ERR "snd_miro_put_preamp() failed: %d\n",\r\nerror);\r\nreturn error;\r\n}\r\nchange = (value != miro->aci->aci_preamp);\r\nmiro->aci->aci_preamp = value;\r\nreturn change;\r\n}\r\nstatic int snd_miro_get_amp(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_miro *miro = snd_kcontrol_chip(kcontrol);\r\nucontrol->value.integer.value[0] = miro->aci->aci_amp;\r\nreturn 0;\r\n}\r\nstatic int snd_miro_put_amp(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_miro *miro = snd_kcontrol_chip(kcontrol);\r\nint error, value, change;\r\nvalue = ucontrol->value.integer.value[0];\r\nerror = aci_setvalue(miro->aci, ACI_SET_POWERAMP, value);\r\nif (error < 0) {\r\nsnd_printk(KERN_ERR "snd_miro_put_amp() to %d failed: %d\n", value, error);\r\nreturn error;\r\n}\r\nchange = (value != miro->aci->aci_amp);\r\nmiro->aci->aci_amp = value;\r\nreturn change;\r\n}\r\nstatic int snd_miro_info_double(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nint reg = kcontrol->private_value & 0xff;\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\r\nuinfo->count = 2;\r\nif ((reg >= ACI_GET_EQ1) && (reg <= ACI_GET_EQ7)) {\r\nuinfo->value.integer.min = - 0x7f;\r\nuinfo->value.integer.max = 0x7f;\r\n} else {\r\nuinfo->value.integer.min = 0;\r\nuinfo->value.integer.max = 0x20;\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_miro_get_double(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *uinfo)\r\n{\r\nstruct snd_miro *miro = snd_kcontrol_chip(kcontrol);\r\nint left_val, right_val;\r\nint right_reg = kcontrol->private_value & 0xff;\r\nint left_reg = right_reg + 1;\r\nright_val = aci_getvalue(miro->aci, right_reg);\r\nif (right_val < 0) {\r\nsnd_printk(KERN_ERR "aci_getvalue(%d) failed: %d\n", right_reg, right_val);\r\nreturn right_val;\r\n}\r\nleft_val = aci_getvalue(miro->aci, left_reg);\r\nif (left_val < 0) {\r\nsnd_printk(KERN_ERR "aci_getvalue(%d) failed: %d\n", left_reg, left_val);\r\nreturn left_val;\r\n}\r\nif ((right_reg >= ACI_GET_EQ1) && (right_reg <= ACI_GET_EQ7)) {\r\nif (left_val < 0x80) {\r\nuinfo->value.integer.value[0] = left_val;\r\n} else {\r\nuinfo->value.integer.value[0] = 0x80 - left_val;\r\n}\r\nif (right_val < 0x80) {\r\nuinfo->value.integer.value[1] = right_val;\r\n} else {\r\nuinfo->value.integer.value[1] = 0x80 - right_val;\r\n}\r\n} else {\r\nuinfo->value.integer.value[0] = 0x20 - left_val;\r\nuinfo->value.integer.value[1] = 0x20 - right_val;\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_miro_put_double(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_miro *miro = snd_kcontrol_chip(kcontrol);\r\nstruct snd_miro_aci *aci = miro->aci;\r\nint left, right, left_old, right_old;\r\nint setreg_left, setreg_right, getreg_left, getreg_right;\r\nint change, error;\r\nleft = ucontrol->value.integer.value[0];\r\nright = ucontrol->value.integer.value[1];\r\nsetreg_right = (kcontrol->private_value >> 8) & 0xff;\r\nsetreg_left = setreg_right + 8;\r\nif (setreg_right == ACI_SET_MASTER)\r\nsetreg_left -= 7;\r\ngetreg_right = kcontrol->private_value & 0xff;\r\ngetreg_left = getreg_right + 1;\r\nleft_old = aci_getvalue(aci, getreg_left);\r\nif (left_old < 0) {\r\nsnd_printk(KERN_ERR "aci_getvalue(%d) failed: %d\n", getreg_left, left_old);\r\nreturn left_old;\r\n}\r\nright_old = aci_getvalue(aci, getreg_right);\r\nif (right_old < 0) {\r\nsnd_printk(KERN_ERR "aci_getvalue(%d) failed: %d\n", getreg_right, right_old);\r\nreturn right_old;\r\n}\r\nif ((getreg_right >= ACI_GET_EQ1) && (getreg_right <= ACI_GET_EQ7)) {\r\nif (left < -0x7f || left > 0x7f ||\r\nright < -0x7f || right > 0x7f)\r\nreturn -EINVAL;\r\nif (left_old > 0x80)\r\nleft_old = 0x80 - left_old;\r\nif (right_old > 0x80)\r\nright_old = 0x80 - right_old;\r\nif (left >= 0) {\r\nerror = aci_setvalue(aci, setreg_left, left);\r\nif (error < 0) {\r\nsnd_printk(KERN_ERR "aci_setvalue(%d) failed: %d\n",\r\nleft, error);\r\nreturn error;\r\n}\r\n} else {\r\nerror = aci_setvalue(aci, setreg_left, 0x80 - left);\r\nif (error < 0) {\r\nsnd_printk(KERN_ERR "aci_setvalue(%d) failed: %d\n",\r\n0x80 - left, error);\r\nreturn error;\r\n}\r\n}\r\nif (right >= 0) {\r\nerror = aci_setvalue(aci, setreg_right, right);\r\nif (error < 0) {\r\nsnd_printk(KERN_ERR "aci_setvalue(%d) failed: %d\n",\r\nright, error);\r\nreturn error;\r\n}\r\n} else {\r\nerror = aci_setvalue(aci, setreg_right, 0x80 - right);\r\nif (error < 0) {\r\nsnd_printk(KERN_ERR "aci_setvalue(%d) failed: %d\n",\r\n0x80 - right, error);\r\nreturn error;\r\n}\r\n}\r\n} else {\r\nif (left < 0 || left > 0x20 ||\r\nright < 0 || right > 0x20)\r\nreturn -EINVAL;\r\nleft_old = 0x20 - left_old;\r\nright_old = 0x20 - right_old;\r\nerror = aci_setvalue(aci, setreg_left, 0x20 - left);\r\nif (error < 0) {\r\nsnd_printk(KERN_ERR "aci_setvalue(%d) failed: %d\n",\r\n0x20 - left, error);\r\nreturn error;\r\n}\r\nerror = aci_setvalue(aci, setreg_right, 0x20 - right);\r\nif (error < 0) {\r\nsnd_printk(KERN_ERR "aci_setvalue(%d) failed: %d\n",\r\n0x20 - right, error);\r\nreturn error;\r\n}\r\n}\r\nchange = (left != left_old) || (right != right_old);\r\nreturn change;\r\n}\r\nstatic int snd_set_aci_init_values(struct snd_miro *miro)\r\n{\r\nint idx, error;\r\nstruct snd_miro_aci *aci = miro->aci;\r\nif ((aci->aci_product == 'A') && wss) {\r\nerror = aci_setvalue(aci, ACI_SET_WSS, wss);\r\nif (error < 0) {\r\nsnd_printk(KERN_ERR "enabling WSS mode failed\n");\r\nreturn error;\r\n}\r\n}\r\nif (ide) {\r\nerror = aci_setvalue(aci, ACI_SET_IDE, ide);\r\nif (error < 0) {\r\nsnd_printk(KERN_ERR "enabling IDE port failed\n");\r\nreturn error;\r\n}\r\n}\r\nfor (idx = 0; idx < ARRAY_SIZE(aci_init_values); idx++) {\r\nerror = aci_setvalue(aci, aci_init_values[idx][0],\r\naci_init_values[idx][1]);\r\nif (error < 0) {\r\nsnd_printk(KERN_ERR "aci_setvalue(%d) failed: %d\n",\r\naci_init_values[idx][0], error);\r\nreturn error;\r\n}\r\n}\r\naci->aci_amp = 0;\r\naci->aci_preamp = 0;\r\naci->aci_solomode = 1;\r\nreturn 0;\r\n}\r\nstatic int snd_miro_mixer(struct snd_card *card,\r\nstruct snd_miro *miro)\r\n{\r\nunsigned int idx;\r\nint err;\r\nif (snd_BUG_ON(!miro || !card))\r\nreturn -EINVAL;\r\nswitch (miro->hardware) {\r\ncase OPTi9XX_HW_82C924:\r\nstrcpy(card->mixername, "ACI & OPTi924");\r\nbreak;\r\ncase OPTi9XX_HW_82C929:\r\nstrcpy(card->mixername, "ACI & OPTi929");\r\nbreak;\r\ndefault:\r\nsnd_BUG();\r\nbreak;\r\n}\r\nfor (idx = 0; idx < ARRAY_SIZE(snd_miro_controls); idx++) {\r\nif ((err = snd_ctl_add(card, snd_ctl_new1(&snd_miro_controls[idx], miro))) < 0)\r\nreturn err;\r\n}\r\nif ((miro->aci->aci_product == 'A') ||\r\n(miro->aci->aci_product == 'B')) {\r\nif ((err = snd_ctl_add(card, snd_ctl_new1(&snd_miro_line_control[0], miro))) < 0)\r\nreturn err;\r\nif ((err = snd_ctl_add(card, snd_ctl_new1(&snd_miro_amp_control[0], miro))) < 0)\r\nreturn err;\r\n}\r\nif ((miro->aci->aci_product == 'B') ||\r\n(miro->aci->aci_product == 'C')) {\r\nif ((err = snd_ctl_add(card, snd_ctl_new1(&snd_miro_preamp_control[0], miro))) < 0)\r\nreturn err;\r\nif (miro->aci->aci_version >= 176)\r\nif ((err = snd_ctl_add(card, snd_ctl_new1(&snd_miro_capture_control[0], miro))) < 0)\r\nreturn err;\r\n}\r\nif (miro->aci->aci_product == 'C') {\r\nif ((err = snd_ctl_add(card, snd_ctl_new1(&snd_miro_radio_control[0], miro))) < 0)\r\nreturn err;\r\nfor (idx = 0; idx < ARRAY_SIZE(snd_miro_eq_controls); idx++) {\r\nif ((err = snd_ctl_add(card, snd_ctl_new1(&snd_miro_eq_controls[idx], miro))) < 0)\r\nreturn err;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_miro_init(struct snd_miro *chip,\r\nunsigned short hardware)\r\n{\r\nstatic int opti9xx_mc_size[] = {7, 7, 10, 10, 2, 2, 2};\r\nchip->hardware = hardware;\r\nstrcpy(chip->name, snd_opti9xx_names[hardware]);\r\nchip->mc_base_size = opti9xx_mc_size[hardware];\r\nspin_lock_init(&chip->lock);\r\nchip->wss_base = -1;\r\nchip->irq = -1;\r\nchip->dma1 = -1;\r\nchip->dma2 = -1;\r\nchip->mpu_port = -1;\r\nchip->mpu_irq = -1;\r\nchip->pwd_reg = 3;\r\n#ifdef CONFIG_PNP\r\nif (isapnp && chip->mc_base)\r\nchip->mc_base |= 0xc00;\r\nelse\r\n#endif\r\nchip->mc_base = 0xf8c;\r\nswitch (hardware) {\r\ncase OPTi9XX_HW_82C929:\r\nchip->password = 0xe3;\r\nbreak;\r\ncase OPTi9XX_HW_82C924:\r\nchip->password = 0xe5;\r\nbreak;\r\ndefault:\r\nsnd_printk(KERN_ERR "sorry, no support for %d\n", hardware);\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\n}\r\nstatic unsigned char snd_miro_read(struct snd_miro *chip,\r\nunsigned char reg)\r\n{\r\nunsigned long flags;\r\nunsigned char retval = 0xff;\r\nspin_lock_irqsave(&chip->lock, flags);\r\noutb(chip->password, chip->mc_base + chip->pwd_reg);\r\nswitch (chip->hardware) {\r\ncase OPTi9XX_HW_82C924:\r\nif (reg > 7) {\r\noutb(reg, chip->mc_base + 8);\r\noutb(chip->password, chip->mc_base + chip->pwd_reg);\r\nretval = inb(chip->mc_base + 9);\r\nbreak;\r\n}\r\ncase OPTi9XX_HW_82C929:\r\nretval = inb(chip->mc_base + reg);\r\nbreak;\r\ndefault:\r\nsnd_printk(KERN_ERR "sorry, no support for %d\n", chip->hardware);\r\n}\r\nspin_unlock_irqrestore(&chip->lock, flags);\r\nreturn retval;\r\n}\r\nstatic void snd_miro_write(struct snd_miro *chip, unsigned char reg,\r\nunsigned char value)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&chip->lock, flags);\r\noutb(chip->password, chip->mc_base + chip->pwd_reg);\r\nswitch (chip->hardware) {\r\ncase OPTi9XX_HW_82C924:\r\nif (reg > 7) {\r\noutb(reg, chip->mc_base + 8);\r\noutb(chip->password, chip->mc_base + chip->pwd_reg);\r\noutb(value, chip->mc_base + 9);\r\nbreak;\r\n}\r\ncase OPTi9XX_HW_82C929:\r\noutb(value, chip->mc_base + reg);\r\nbreak;\r\ndefault:\r\nsnd_printk(KERN_ERR "sorry, no support for %d\n", chip->hardware);\r\n}\r\nspin_unlock_irqrestore(&chip->lock, flags);\r\n}\r\nstatic void snd_miro_proc_read(struct snd_info_entry * entry,\r\nstruct snd_info_buffer *buffer)\r\n{\r\nstruct snd_miro *miro = (struct snd_miro *) entry->private_data;\r\nstruct snd_miro_aci *aci = miro->aci;\r\nchar* model = "unknown";\r\nif ((miro->hardware == OPTi9XX_HW_82C929) &&\r\n(aci->aci_vendor == 'm') &&\r\n(aci->aci_product == 'A')) {\r\nswitch (aci->aci_version) {\r\ncase 3:\r\nmodel = "miroSOUND PCM1 pro";\r\nbreak;\r\ndefault:\r\nmodel = "miroSOUND PCM1 pro / (early) PCM12";\r\nbreak;\r\n}\r\n}\r\nif ((miro->hardware == OPTi9XX_HW_82C924) &&\r\n(aci->aci_vendor == 'm') &&\r\n(aci->aci_product == 'B')) {\r\nswitch (aci->aci_version) {\r\ncase 4:\r\nmodel = "miroSOUND PCM12";\r\nbreak;\r\ncase 176:\r\nmodel = "miroSOUND PCM12 (Rev. E)";\r\nbreak;\r\ndefault:\r\nmodel = "miroSOUND PCM12 / PCM12 pnp";\r\nbreak;\r\n}\r\n}\r\nif ((miro->hardware == OPTi9XX_HW_82C924) &&\r\n(aci->aci_vendor == 'm') &&\r\n(aci->aci_product == 'C')) {\r\nswitch (aci->aci_version) {\r\ncase 7:\r\nmodel = "miroSOUND PCM20 radio (Rev. E)";\r\nbreak;\r\ndefault:\r\nmodel = "miroSOUND PCM20 radio";\r\nbreak;\r\n}\r\n}\r\nsnd_iprintf(buffer, "\nGeneral information:\n");\r\nsnd_iprintf(buffer, " model : %s\n", model);\r\nsnd_iprintf(buffer, " opti : %s\n", miro->name);\r\nsnd_iprintf(buffer, " codec : %s\n", miro->pcm->name);\r\nsnd_iprintf(buffer, " port : 0x%lx\n", miro->wss_base);\r\nsnd_iprintf(buffer, " irq : %d\n", miro->irq);\r\nsnd_iprintf(buffer, " dma : %d,%d\n\n", miro->dma1, miro->dma2);\r\nsnd_iprintf(buffer, "MPU-401:\n");\r\nsnd_iprintf(buffer, " port : 0x%lx\n", miro->mpu_port);\r\nsnd_iprintf(buffer, " irq : %d\n\n", miro->mpu_irq);\r\nsnd_iprintf(buffer, "ACI information:\n");\r\nsnd_iprintf(buffer, " vendor : ");\r\nswitch (aci->aci_vendor) {\r\ncase 'm':\r\nsnd_iprintf(buffer, "Miro\n");\r\nbreak;\r\ndefault:\r\nsnd_iprintf(buffer, "unknown (0x%x)\n", aci->aci_vendor);\r\nbreak;\r\n}\r\nsnd_iprintf(buffer, " product : ");\r\nswitch (aci->aci_product) {\r\ncase 'A':\r\nsnd_iprintf(buffer, "miroSOUND PCM1 pro / (early) PCM12\n");\r\nbreak;\r\ncase 'B':\r\nsnd_iprintf(buffer, "miroSOUND PCM12\n");\r\nbreak;\r\ncase 'C':\r\nsnd_iprintf(buffer, "miroSOUND PCM20 radio\n");\r\nbreak;\r\ndefault:\r\nsnd_iprintf(buffer, "unknown (0x%x)\n", aci->aci_product);\r\nbreak;\r\n}\r\nsnd_iprintf(buffer, " firmware: %d (0x%x)\n",\r\naci->aci_version, aci->aci_version);\r\nsnd_iprintf(buffer, " port : 0x%lx-0x%lx\n",\r\naci->aci_port, aci->aci_port+2);\r\nsnd_iprintf(buffer, " wss : 0x%x\n", wss);\r\nsnd_iprintf(buffer, " ide : 0x%x\n", ide);\r\nsnd_iprintf(buffer, " solomode: 0x%x\n", aci->aci_solomode);\r\nsnd_iprintf(buffer, " amp : 0x%x\n", aci->aci_amp);\r\nsnd_iprintf(buffer, " preamp : 0x%x\n", aci->aci_preamp);\r\n}\r\nstatic void snd_miro_proc_init(struct snd_card *card,\r\nstruct snd_miro *miro)\r\n{\r\nstruct snd_info_entry *entry;\r\nif (!snd_card_proc_new(card, "miro", &entry))\r\nsnd_info_set_text_ops(entry, miro, snd_miro_proc_read);\r\n}\r\nstatic int snd_miro_configure(struct snd_miro *chip)\r\n{\r\nunsigned char wss_base_bits;\r\nunsigned char irq_bits;\r\nunsigned char dma_bits;\r\nunsigned char mpu_port_bits = 0;\r\nunsigned char mpu_irq_bits;\r\nunsigned long flags;\r\nsnd_miro_write_mask(chip, OPTi9XX_MC_REG(1), 0x80, 0x80);\r\nsnd_miro_write_mask(chip, OPTi9XX_MC_REG(2), 0x20, 0x20);\r\nsnd_miro_write_mask(chip, OPTi9XX_MC_REG(5), 0x02, 0x02);\r\nswitch (chip->hardware) {\r\ncase OPTi9XX_HW_82C924:\r\nsnd_miro_write_mask(chip, OPTi9XX_MC_REG(6), 0x02, 0x02);\r\nsnd_miro_write_mask(chip, OPTi9XX_MC_REG(3), 0xf0, 0xff);\r\nbreak;\r\ncase OPTi9XX_HW_82C929:\r\nsnd_miro_write_mask(chip, OPTi9XX_MC_REG(4), 0x00, 0x0c);\r\nbreak;\r\ndefault:\r\nsnd_printk(KERN_ERR "chip %d not supported\n", chip->hardware);\r\nreturn -EINVAL;\r\n}\r\nswitch (chip->wss_base & 0x3ff) {\r\ncase 0x130:\r\nchip->wss_base = 0x530;\r\nwss_base_bits = 0x00;\r\nbreak;\r\ncase 0x204:\r\nchip->wss_base = 0x604;\r\nwss_base_bits = 0x03;\r\nbreak;\r\ncase 0x280:\r\nchip->wss_base = 0xe80;\r\nwss_base_bits = 0x01;\r\nbreak;\r\ncase 0x340:\r\nchip->wss_base = 0xf40;\r\nwss_base_bits = 0x02;\r\nbreak;\r\ndefault:\r\nsnd_printk(KERN_ERR "WSS port 0x%lx not valid\n", chip->wss_base);\r\ngoto __skip_base;\r\n}\r\nsnd_miro_write_mask(chip, OPTi9XX_MC_REG(1), wss_base_bits << 4, 0x30);\r\n__skip_base:\r\nswitch (chip->irq) {\r\ncase 5:\r\nirq_bits = 0x05;\r\nbreak;\r\ncase 7:\r\nirq_bits = 0x01;\r\nbreak;\r\ncase 9:\r\nirq_bits = 0x02;\r\nbreak;\r\ncase 10:\r\nirq_bits = 0x03;\r\nbreak;\r\ncase 11:\r\nirq_bits = 0x04;\r\nbreak;\r\ndefault:\r\nsnd_printk(KERN_ERR "WSS irq # %d not valid\n", chip->irq);\r\ngoto __skip_resources;\r\n}\r\nswitch (chip->dma1) {\r\ncase 0:\r\ndma_bits = 0x01;\r\nbreak;\r\ncase 1:\r\ndma_bits = 0x02;\r\nbreak;\r\ncase 3:\r\ndma_bits = 0x03;\r\nbreak;\r\ndefault:\r\nsnd_printk(KERN_ERR "WSS dma1 # %d not valid\n", chip->dma1);\r\ngoto __skip_resources;\r\n}\r\nif (chip->dma1 == chip->dma2) {\r\nsnd_printk(KERN_ERR "don't want to share dmas\n");\r\nreturn -EBUSY;\r\n}\r\nswitch (chip->dma2) {\r\ncase 0:\r\ncase 1:\r\nbreak;\r\ndefault:\r\nsnd_printk(KERN_ERR "WSS dma2 # %d not valid\n", chip->dma2);\r\ngoto __skip_resources;\r\n}\r\ndma_bits |= 0x04;\r\nspin_lock_irqsave(&chip->lock, flags);\r\noutb(irq_bits << 3 | dma_bits, chip->wss_base);\r\nspin_unlock_irqrestore(&chip->lock, flags);\r\n__skip_resources:\r\nif (chip->hardware > OPTi9XX_HW_82C928) {\r\nswitch (chip->mpu_port) {\r\ncase 0:\r\ncase -1:\r\nbreak;\r\ncase 0x300:\r\nmpu_port_bits = 0x03;\r\nbreak;\r\ncase 0x310:\r\nmpu_port_bits = 0x02;\r\nbreak;\r\ncase 0x320:\r\nmpu_port_bits = 0x01;\r\nbreak;\r\ncase 0x330:\r\nmpu_port_bits = 0x00;\r\nbreak;\r\ndefault:\r\nsnd_printk(KERN_ERR "MPU-401 port 0x%lx not valid\n",\r\nchip->mpu_port);\r\ngoto __skip_mpu;\r\n}\r\nswitch (chip->mpu_irq) {\r\ncase 5:\r\nmpu_irq_bits = 0x02;\r\nbreak;\r\ncase 7:\r\nmpu_irq_bits = 0x03;\r\nbreak;\r\ncase 9:\r\nmpu_irq_bits = 0x00;\r\nbreak;\r\ncase 10:\r\nmpu_irq_bits = 0x01;\r\nbreak;\r\ndefault:\r\nsnd_printk(KERN_ERR "MPU-401 irq # %d not valid\n",\r\nchip->mpu_irq);\r\ngoto __skip_mpu;\r\n}\r\nsnd_miro_write_mask(chip, OPTi9XX_MC_REG(6),\r\n(chip->mpu_port <= 0) ? 0x00 :\r\n0x80 | mpu_port_bits << 5 | mpu_irq_bits << 3,\r\n0xf8);\r\n}\r\n__skip_mpu:\r\nreturn 0;\r\n}\r\nstatic int snd_miro_opti_check(struct snd_miro *chip)\r\n{\r\nunsigned char value;\r\nchip->res_mc_base = request_region(chip->mc_base, chip->mc_base_size,\r\n"OPTi9xx MC");\r\nif (chip->res_mc_base == NULL)\r\nreturn -ENOMEM;\r\nvalue = snd_miro_read(chip, OPTi9XX_MC_REG(1));\r\nif (value != 0xff && value != inb(chip->mc_base + OPTi9XX_MC_REG(1)))\r\nif (value == snd_miro_read(chip, OPTi9XX_MC_REG(1)))\r\nreturn 0;\r\nrelease_and_free_resource(chip->res_mc_base);\r\nchip->res_mc_base = NULL;\r\nreturn -ENODEV;\r\n}\r\nstatic int snd_card_miro_detect(struct snd_card *card,\r\nstruct snd_miro *chip)\r\n{\r\nint i, err;\r\nfor (i = OPTi9XX_HW_82C929; i <= OPTi9XX_HW_82C924; i++) {\r\nif ((err = snd_miro_init(chip, i)) < 0)\r\nreturn err;\r\nerr = snd_miro_opti_check(chip);\r\nif (err == 0)\r\nreturn 1;\r\n}\r\nreturn -ENODEV;\r\n}\r\nstatic int snd_card_miro_aci_detect(struct snd_card *card,\r\nstruct snd_miro *miro)\r\n{\r\nunsigned char regval;\r\nint i;\r\nstruct snd_miro_aci *aci = &aci_device;\r\nmiro->aci = aci;\r\nmutex_init(&aci->aci_mutex);\r\nregval=inb(miro->mc_base + 4);\r\naci->aci_port = (regval & 0x10) ? 0x344 : 0x354;\r\nmiro->res_aci_port = request_region(aci->aci_port, 3, "miro aci");\r\nif (miro->res_aci_port == NULL) {\r\nsnd_printk(KERN_ERR "aci i/o area 0x%lx-0x%lx already used.\n",\r\naci->aci_port, aci->aci_port+2);\r\nreturn -ENOMEM;\r\n}\r\nfor (i = 0; i < 3; i++)\r\nif (snd_aci_cmd(aci, ACI_ERROR_OP, -1, -1) < 0) {\r\nsnd_printk(KERN_ERR "can't force aci into known state.\n");\r\nreturn -ENXIO;\r\n}\r\naci->aci_vendor = snd_aci_cmd(aci, ACI_READ_IDCODE, -1, -1);\r\naci->aci_product = snd_aci_cmd(aci, ACI_READ_IDCODE, -1, -1);\r\nif (aci->aci_vendor < 0 || aci->aci_product < 0) {\r\nsnd_printk(KERN_ERR "can't read aci id on 0x%lx.\n",\r\naci->aci_port);\r\nreturn -ENXIO;\r\n}\r\naci->aci_version = snd_aci_cmd(aci, ACI_READ_VERSION, -1, -1);\r\nif (aci->aci_version < 0) {\r\nsnd_printk(KERN_ERR "can't read aci version on 0x%lx.\n",\r\naci->aci_port);\r\nreturn -ENXIO;\r\n}\r\nif (snd_aci_cmd(aci, ACI_INIT, -1, -1) < 0 ||\r\nsnd_aci_cmd(aci, ACI_ERROR_OP, ACI_ERROR_OP, ACI_ERROR_OP) < 0 ||\r\nsnd_aci_cmd(aci, ACI_ERROR_OP, ACI_ERROR_OP, ACI_ERROR_OP) < 0) {\r\nsnd_printk(KERN_ERR "can't initialize aci.\n");\r\nreturn -ENXIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic void snd_card_miro_free(struct snd_card *card)\r\n{\r\nstruct snd_miro *miro = card->private_data;\r\nrelease_and_free_resource(miro->res_aci_port);\r\nif (miro->aci)\r\nmiro->aci->aci_port = 0;\r\nrelease_and_free_resource(miro->res_mc_base);\r\n}\r\nstatic int snd_miro_probe(struct snd_card *card)\r\n{\r\nint error;\r\nstruct snd_miro *miro = card->private_data;\r\nstruct snd_wss *codec;\r\nstruct snd_timer *timer;\r\nstruct snd_pcm *pcm;\r\nstruct snd_rawmidi *rmidi;\r\nif (!miro->res_mc_base) {\r\nmiro->res_mc_base = request_region(miro->mc_base,\r\nmiro->mc_base_size,\r\n"miro (OPTi9xx MC)");\r\nif (miro->res_mc_base == NULL) {\r\nsnd_printk(KERN_ERR "request for OPTI9xx MC failed\n");\r\nreturn -ENOMEM;\r\n}\r\n}\r\nerror = snd_card_miro_aci_detect(card, miro);\r\nif (error < 0) {\r\nsnd_printk(KERN_ERR "unable to detect aci chip\n");\r\nreturn -ENODEV;\r\n}\r\nmiro->wss_base = port;\r\nmiro->mpu_port = mpu_port;\r\nmiro->irq = irq;\r\nmiro->mpu_irq = mpu_irq;\r\nmiro->dma1 = dma1;\r\nmiro->dma2 = dma2;\r\nsnd_miro_proc_init(card, miro);\r\nerror = snd_miro_configure(miro);\r\nif (error)\r\nreturn error;\r\nerror = snd_wss_create(card, miro->wss_base + 4, -1,\r\nmiro->irq, miro->dma1, miro->dma2,\r\nWSS_HW_DETECT, 0, &codec);\r\nif (error < 0)\r\nreturn error;\r\nerror = snd_wss_pcm(codec, 0, &pcm);\r\nif (error < 0)\r\nreturn error;\r\nerror = snd_wss_mixer(codec);\r\nif (error < 0)\r\nreturn error;\r\nerror = snd_wss_timer(codec, 0, &timer);\r\nif (error < 0)\r\nreturn error;\r\nmiro->pcm = pcm;\r\nerror = snd_miro_mixer(card, miro);\r\nif (error < 0)\r\nreturn error;\r\nif (miro->aci->aci_vendor == 'm') {\r\nswitch (miro->aci->aci_product) {\r\ncase 'A':\r\nsprintf(card->shortname,\r\n"miroSOUND PCM1 pro / PCM12");\r\nbreak;\r\ncase 'B':\r\nsprintf(card->shortname,\r\n"miroSOUND PCM12");\r\nbreak;\r\ncase 'C':\r\nsprintf(card->shortname,\r\n"miroSOUND PCM20 radio");\r\nbreak;\r\ndefault:\r\nsprintf(card->shortname,\r\n"unknown miro");\r\nsnd_printk(KERN_INFO "unknown miro aci id\n");\r\nbreak;\r\n}\r\n} else {\r\nsnd_printk(KERN_INFO "found unsupported aci card\n");\r\nsprintf(card->shortname, "unknown Cardinal Technologies");\r\n}\r\nstrcpy(card->driver, "miro");\r\nsprintf(card->longname, "%s: OPTi%s, %s at 0x%lx, irq %d, dma %d&%d",\r\ncard->shortname, miro->name, pcm->name, miro->wss_base + 4,\r\nmiro->irq, miro->dma1, miro->dma2);\r\nif (mpu_port <= 0 || mpu_port == SNDRV_AUTO_PORT)\r\nrmidi = NULL;\r\nelse {\r\nerror = snd_mpu401_uart_new(card, 0, MPU401_HW_MPU401,\r\nmpu_port, 0, miro->mpu_irq, &rmidi);\r\nif (error < 0)\r\nsnd_printk(KERN_WARNING "no MPU-401 device at 0x%lx?\n",\r\nmpu_port);\r\n}\r\nif (fm_port > 0 && fm_port != SNDRV_AUTO_PORT) {\r\nstruct snd_opl3 *opl3 = NULL;\r\nstruct snd_opl4 *opl4;\r\nif (snd_opl4_create(card, fm_port, fm_port - 8,\r\n2, &opl3, &opl4) < 0)\r\nsnd_printk(KERN_WARNING "no OPL4 device at 0x%lx\n",\r\nfm_port);\r\n}\r\nerror = snd_set_aci_init_values(miro);\r\nif (error < 0)\r\nreturn error;\r\nreturn snd_card_register(card);\r\n}\r\nstatic int snd_miro_isa_match(struct device *devptr, unsigned int n)\r\n{\r\n#ifdef CONFIG_PNP\r\nif (snd_miro_pnp_is_probed)\r\nreturn 0;\r\nif (isapnp)\r\nreturn 0;\r\n#endif\r\nreturn 1;\r\n}\r\nstatic int snd_miro_isa_probe(struct device *devptr, unsigned int n)\r\n{\r\nstatic long possible_ports[] = {0x530, 0xe80, 0xf40, 0x604, -1};\r\nstatic long possible_mpu_ports[] = {0x330, 0x300, 0x310, 0x320, -1};\r\nstatic int possible_irqs[] = {11, 9, 10, 7, -1};\r\nstatic int possible_mpu_irqs[] = {10, 5, 9, 7, -1};\r\nstatic int possible_dma1s[] = {3, 1, 0, -1};\r\nstatic int possible_dma2s[][2] = { {1, -1}, {0, -1}, {-1, -1},\r\n{0, -1} };\r\nint error;\r\nstruct snd_miro *miro;\r\nstruct snd_card *card;\r\nerror = snd_card_create(index, id, THIS_MODULE,\r\nsizeof(struct snd_miro), &card);\r\nif (error < 0)\r\nreturn error;\r\ncard->private_free = snd_card_miro_free;\r\nmiro = card->private_data;\r\nerror = snd_card_miro_detect(card, miro);\r\nif (error < 0) {\r\nsnd_card_free(card);\r\nsnd_printk(KERN_ERR "unable to detect OPTi9xx chip\n");\r\nreturn -ENODEV;\r\n}\r\nif (port == SNDRV_AUTO_PORT) {\r\nport = snd_legacy_find_free_ioport(possible_ports, 4);\r\nif (port < 0) {\r\nsnd_card_free(card);\r\nsnd_printk(KERN_ERR "unable to find a free WSS port\n");\r\nreturn -EBUSY;\r\n}\r\n}\r\nif (mpu_port == SNDRV_AUTO_PORT) {\r\nmpu_port = snd_legacy_find_free_ioport(possible_mpu_ports, 2);\r\nif (mpu_port < 0) {\r\nsnd_card_free(card);\r\nsnd_printk(KERN_ERR\r\n"unable to find a free MPU401 port\n");\r\nreturn -EBUSY;\r\n}\r\n}\r\nif (irq == SNDRV_AUTO_IRQ) {\r\nirq = snd_legacy_find_free_irq(possible_irqs);\r\nif (irq < 0) {\r\nsnd_card_free(card);\r\nsnd_printk(KERN_ERR "unable to find a free IRQ\n");\r\nreturn -EBUSY;\r\n}\r\n}\r\nif (mpu_irq == SNDRV_AUTO_IRQ) {\r\nmpu_irq = snd_legacy_find_free_irq(possible_mpu_irqs);\r\nif (mpu_irq < 0) {\r\nsnd_card_free(card);\r\nsnd_printk(KERN_ERR\r\n"unable to find a free MPU401 IRQ\n");\r\nreturn -EBUSY;\r\n}\r\n}\r\nif (dma1 == SNDRV_AUTO_DMA) {\r\ndma1 = snd_legacy_find_free_dma(possible_dma1s);\r\nif (dma1 < 0) {\r\nsnd_card_free(card);\r\nsnd_printk(KERN_ERR "unable to find a free DMA1\n");\r\nreturn -EBUSY;\r\n}\r\n}\r\nif (dma2 == SNDRV_AUTO_DMA) {\r\ndma2 = snd_legacy_find_free_dma(possible_dma2s[dma1 % 4]);\r\nif (dma2 < 0) {\r\nsnd_card_free(card);\r\nsnd_printk(KERN_ERR "unable to find a free DMA2\n");\r\nreturn -EBUSY;\r\n}\r\n}\r\nsnd_card_set_dev(card, devptr);\r\nerror = snd_miro_probe(card);\r\nif (error < 0) {\r\nsnd_card_free(card);\r\nreturn error;\r\n}\r\ndev_set_drvdata(devptr, card);\r\nreturn 0;\r\n}\r\nstatic int snd_miro_isa_remove(struct device *devptr,\r\nunsigned int dev)\r\n{\r\nsnd_card_free(dev_get_drvdata(devptr));\r\ndev_set_drvdata(devptr, NULL);\r\nreturn 0;\r\n}\r\nstatic int snd_card_miro_pnp(struct snd_miro *chip,\r\nstruct pnp_card_link *card,\r\nconst struct pnp_card_device_id *pid)\r\n{\r\nstruct pnp_dev *pdev;\r\nint err;\r\nstruct pnp_dev *devmpu;\r\nstruct pnp_dev *devmc;\r\npdev = pnp_request_card_device(card, pid->devs[0].id, NULL);\r\nif (pdev == NULL)\r\nreturn -EBUSY;\r\ndevmpu = pnp_request_card_device(card, pid->devs[1].id, NULL);\r\nif (devmpu == NULL)\r\nreturn -EBUSY;\r\ndevmc = pnp_request_card_device(card, pid->devs[2].id, NULL);\r\nif (devmc == NULL)\r\nreturn -EBUSY;\r\nerr = pnp_activate_dev(pdev);\r\nif (err < 0) {\r\nsnd_printk(KERN_ERR "AUDIO pnp configure failure: %d\n", err);\r\nreturn err;\r\n}\r\nerr = pnp_activate_dev(devmc);\r\nif (err < 0) {\r\nsnd_printk(KERN_ERR "MC pnp configure failure: %d\n",\r\nerr);\r\nreturn err;\r\n}\r\nport = pnp_port_start(pdev, 1);\r\nfm_port = pnp_port_start(pdev, 2) + 8;\r\nchip->mc_base = pnp_port_start(devmc, 0) - 1;\r\nchip->mc_base_size = pnp_port_len(devmc, 0) + 1;\r\nirq = pnp_irq(pdev, 0);\r\ndma1 = pnp_dma(pdev, 0);\r\ndma2 = pnp_dma(pdev, 1);\r\nif (mpu_port > 0) {\r\nerr = pnp_activate_dev(devmpu);\r\nif (err < 0) {\r\nsnd_printk(KERN_ERR "MPU401 pnp configure failure\n");\r\nmpu_port = -1;\r\nreturn err;\r\n}\r\nmpu_port = pnp_port_start(devmpu, 0);\r\nmpu_irq = pnp_irq(devmpu, 0);\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_miro_pnp_probe(struct pnp_card_link *pcard,\r\nconst struct pnp_card_device_id *pid)\r\n{\r\nstruct snd_card *card;\r\nint err;\r\nstruct snd_miro *miro;\r\nif (snd_miro_pnp_is_probed)\r\nreturn -EBUSY;\r\nif (!isapnp)\r\nreturn -ENODEV;\r\nerr = snd_card_create(index, id, THIS_MODULE,\r\nsizeof(struct snd_miro), &card);\r\nif (err < 0)\r\nreturn err;\r\ncard->private_free = snd_card_miro_free;\r\nmiro = card->private_data;\r\nerr = snd_card_miro_pnp(miro, pcard, pid);\r\nif (err) {\r\nsnd_card_free(card);\r\nreturn err;\r\n}\r\nerr = snd_miro_init(miro, OPTi9XX_HW_82C924);\r\nif (err) {\r\nsnd_card_free(card);\r\nreturn err;\r\n}\r\nerr = snd_miro_opti_check(miro);\r\nif (err) {\r\nsnd_printk(KERN_ERR "OPTI chip not found\n");\r\nsnd_card_free(card);\r\nreturn err;\r\n}\r\nsnd_card_set_dev(card, &pcard->card->dev);\r\nerr = snd_miro_probe(card);\r\nif (err < 0) {\r\nsnd_card_free(card);\r\nreturn err;\r\n}\r\npnp_set_card_drvdata(pcard, card);\r\nsnd_miro_pnp_is_probed = 1;\r\nreturn 0;\r\n}\r\nstatic void snd_miro_pnp_remove(struct pnp_card_link *pcard)\r\n{\r\nsnd_card_free(pnp_get_card_drvdata(pcard));\r\npnp_set_card_drvdata(pcard, NULL);\r\nsnd_miro_pnp_is_probed = 0;\r\n}\r\nstatic int __init alsa_card_miro_init(void)\r\n{\r\n#ifdef CONFIG_PNP\r\npnp_register_card_driver(&miro_pnpc_driver);\r\nif (snd_miro_pnp_is_probed)\r\nreturn 0;\r\npnp_unregister_card_driver(&miro_pnpc_driver);\r\n#endif\r\nreturn isa_register_driver(&snd_miro_driver, 1);\r\n}\r\nstatic void __exit alsa_card_miro_exit(void)\r\n{\r\nif (!snd_miro_pnp_is_probed) {\r\nisa_unregister_driver(&snd_miro_driver);\r\nreturn;\r\n}\r\n#ifdef CONFIG_PNP\r\npnp_unregister_card_driver(&miro_pnpc_driver);\r\n#endif\r\n}
