static void draw_pixel(struct fb_info *fbi, int x, int y, unsigned color)\r\n{\r\nstruct fb_var_screeninfo *var = &fbi->var;\r\nstruct fb_fix_screeninfo *fix = &fbi->fix;\r\nvoid __iomem *addr = fbi->screen_base;\r\nconst unsigned bytespp = var->bits_per_pixel >> 3;\r\nconst unsigned line_len = fix->line_length / bytespp;\r\nint r = (color >> 16) & 0xff;\r\nint g = (color >> 8) & 0xff;\r\nint b = (color >> 0) & 0xff;\r\nif (var->bits_per_pixel == 16) {\r\nu16 __iomem *p = (u16 __iomem *)addr;\r\np += y * line_len + x;\r\nr = r * 32 / 256;\r\ng = g * 64 / 256;\r\nb = b * 32 / 256;\r\n__raw_writew((r << 11) | (g << 5) | (b << 0), p);\r\n} else if (var->bits_per_pixel == 24) {\r\nu8 __iomem *p = (u8 __iomem *)addr;\r\np += (y * line_len + x) * 3;\r\n__raw_writeb(b, p + 0);\r\n__raw_writeb(g, p + 1);\r\n__raw_writeb(r, p + 2);\r\n} else if (var->bits_per_pixel == 32) {\r\nu32 __iomem *p = (u32 __iomem *)addr;\r\np += y * line_len + x;\r\n__raw_writel(color, p);\r\n}\r\n}\r\nstatic void fill_fb(struct fb_info *fbi)\r\n{\r\nstruct fb_var_screeninfo *var = &fbi->var;\r\nconst short w = var->xres_virtual;\r\nconst short h = var->yres_virtual;\r\nvoid __iomem *addr = fbi->screen_base;\r\nint y, x;\r\nif (!addr)\r\nreturn;\r\nDBG("fill_fb %dx%d, line_len %d bytes\n", w, h, fbi->fix.line_length);\r\nfor (y = 0; y < h; y++) {\r\nfor (x = 0; x < w; x++) {\r\nif (x < 20 && y < 20)\r\ndraw_pixel(fbi, x, y, 0xffffff);\r\nelse if (x < 20 && (y > 20 && y < h - 20))\r\ndraw_pixel(fbi, x, y, 0xff);\r\nelse if (y < 20 && (x > 20 && x < w - 20))\r\ndraw_pixel(fbi, x, y, 0xff00);\r\nelse if (x > w - 20 && (y > 20 && y < h - 20))\r\ndraw_pixel(fbi, x, y, 0xff0000);\r\nelse if (y > h - 20 && (x > 20 && x < w - 20))\r\ndraw_pixel(fbi, x, y, 0xffff00);\r\nelse if (x == 20 || x == w - 20 ||\r\ny == 20 || y == h - 20)\r\ndraw_pixel(fbi, x, y, 0xffffff);\r\nelse if (x == y || w - x == h - y)\r\ndraw_pixel(fbi, x, y, 0xff00ff);\r\nelse if (w - x == y || x == h - y)\r\ndraw_pixel(fbi, x, y, 0x00ffff);\r\nelse if (x > 20 && y > 20 && x < w - 20 && y < h - 20) {\r\nint t = x * 3 / w;\r\nunsigned r = 0, g = 0, b = 0;\r\nunsigned c;\r\nif (var->bits_per_pixel == 16) {\r\nif (t == 0)\r\nb = (y % 32) * 256 / 32;\r\nelse if (t == 1)\r\ng = (y % 64) * 256 / 64;\r\nelse if (t == 2)\r\nr = (y % 32) * 256 / 32;\r\n} else {\r\nif (t == 0)\r\nb = (y % 256);\r\nelse if (t == 1)\r\ng = (y % 256);\r\nelse if (t == 2)\r\nr = (y % 256);\r\n}\r\nc = (r << 16) | (g << 8) | (b << 0);\r\ndraw_pixel(fbi, x, y, c);\r\n} else {\r\ndraw_pixel(fbi, x, y, 0);\r\n}\r\n}\r\n}\r\n}\r\nstatic unsigned omapfb_get_vrfb_offset(const struct omapfb_info *ofbi, int rot)\r\n{\r\nconst struct vrfb *vrfb = &ofbi->region->vrfb;\r\nunsigned offset;\r\nswitch (rot) {\r\ncase FB_ROTATE_UR:\r\noffset = 0;\r\nbreak;\r\ncase FB_ROTATE_CW:\r\noffset = vrfb->yoffset;\r\nbreak;\r\ncase FB_ROTATE_UD:\r\noffset = vrfb->yoffset * OMAP_VRFB_LINE_LEN + vrfb->xoffset;\r\nbreak;\r\ncase FB_ROTATE_CCW:\r\noffset = vrfb->xoffset * OMAP_VRFB_LINE_LEN;\r\nbreak;\r\ndefault:\r\nBUG();\r\nreturn 0;\r\n}\r\noffset *= vrfb->bytespp;\r\nreturn offset;\r\n}\r\nstatic u32 omapfb_get_region_rot_paddr(const struct omapfb_info *ofbi, int rot)\r\n{\r\nif (ofbi->rotation_type == OMAP_DSS_ROT_VRFB) {\r\nreturn ofbi->region->vrfb.paddr[rot]\r\n+ omapfb_get_vrfb_offset(ofbi, rot);\r\n} else {\r\nreturn ofbi->region->paddr;\r\n}\r\n}\r\nstatic u32 omapfb_get_region_paddr(const struct omapfb_info *ofbi)\r\n{\r\nif (ofbi->rotation_type == OMAP_DSS_ROT_VRFB)\r\nreturn ofbi->region->vrfb.paddr[0];\r\nelse\r\nreturn ofbi->region->paddr;\r\n}\r\nstatic void __iomem *omapfb_get_region_vaddr(const struct omapfb_info *ofbi)\r\n{\r\nif (ofbi->rotation_type == OMAP_DSS_ROT_VRFB)\r\nreturn ofbi->region->vrfb.vaddr[0];\r\nelse\r\nreturn ofbi->region->vaddr;\r\n}\r\nbool cmp_component(struct fb_bitfield *f1, struct fb_bitfield *f2)\r\n{\r\nreturn f1->length == f2->length &&\r\nf1->offset == f2->offset &&\r\nf1->msb_right == f2->msb_right;\r\n}\r\nstatic void assign_colormode_to_var(struct fb_var_screeninfo *var,\r\nstruct omapfb_colormode *color)\r\n{\r\nvar->bits_per_pixel = color->bits_per_pixel;\r\nvar->nonstd = color->nonstd;\r\nvar->red = color->red;\r\nvar->green = color->green;\r\nvar->blue = color->blue;\r\nvar->transp = color->transp;\r\n}\r\nstatic int fb_mode_to_dss_mode(struct fb_var_screeninfo *var,\r\nenum omap_color_mode *mode)\r\n{\r\nenum omap_color_mode dssmode;\r\nint i;\r\nif (var->nonstd) {\r\nfor (i = 0; i < ARRAY_SIZE(omapfb_colormodes); ++i) {\r\nstruct omapfb_colormode *m = &omapfb_colormodes[i];\r\nif (var->nonstd == m->nonstd) {\r\nassign_colormode_to_var(var, m);\r\n*mode = m->dssmode;\r\nreturn 0;\r\n}\r\n}\r\nreturn -EINVAL;\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(omapfb_colormodes); ++i) {\r\nstruct omapfb_colormode *m = &omapfb_colormodes[i];\r\nif (cmp_var_to_colormode(var, m)) {\r\nassign_colormode_to_var(var, m);\r\n*mode = m->dssmode;\r\nreturn 0;\r\n}\r\n}\r\nswitch (var->bits_per_pixel) {\r\ncase 1:\r\ndssmode = OMAP_DSS_COLOR_CLUT1;\r\nbreak;\r\ncase 2:\r\ndssmode = OMAP_DSS_COLOR_CLUT2;\r\nbreak;\r\ncase 4:\r\ndssmode = OMAP_DSS_COLOR_CLUT4;\r\nbreak;\r\ncase 8:\r\ndssmode = OMAP_DSS_COLOR_CLUT8;\r\nbreak;\r\ncase 12:\r\ndssmode = OMAP_DSS_COLOR_RGB12U;\r\nbreak;\r\ncase 16:\r\ndssmode = OMAP_DSS_COLOR_RGB16;\r\nbreak;\r\ncase 24:\r\ndssmode = OMAP_DSS_COLOR_RGB24P;\r\nbreak;\r\ncase 32:\r\ndssmode = OMAP_DSS_COLOR_RGB24U;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(omapfb_colormodes); ++i) {\r\nstruct omapfb_colormode *m = &omapfb_colormodes[i];\r\nif (dssmode == m->dssmode) {\r\nassign_colormode_to_var(var, m);\r\n*mode = m->dssmode;\r\nreturn 0;\r\n}\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int check_fb_res_bounds(struct fb_var_screeninfo *var)\r\n{\r\nint xres_min = OMAPFB_PLANE_XRES_MIN;\r\nint xres_max = 2048;\r\nint yres_min = OMAPFB_PLANE_YRES_MIN;\r\nint yres_max = 2048;\r\nif (var->xres_virtual == 0)\r\nvar->xres_virtual = var->xres;\r\nif (var->yres_virtual == 0)\r\nvar->yres_virtual = var->yres;\r\nif (var->xres_virtual < xres_min || var->yres_virtual < yres_min)\r\nreturn -EINVAL;\r\nif (var->xres < xres_min)\r\nvar->xres = xres_min;\r\nif (var->yres < yres_min)\r\nvar->yres = yres_min;\r\nif (var->xres > xres_max)\r\nvar->xres = xres_max;\r\nif (var->yres > yres_max)\r\nvar->yres = yres_max;\r\nif (var->xres > var->xres_virtual)\r\nvar->xres = var->xres_virtual;\r\nif (var->yres > var->yres_virtual)\r\nvar->yres = var->yres_virtual;\r\nreturn 0;\r\n}\r\nstatic void shrink_height(unsigned long max_frame_size,\r\nstruct fb_var_screeninfo *var)\r\n{\r\nDBG("can't fit FB into memory, reducing y\n");\r\nvar->yres_virtual = max_frame_size /\r\n(var->xres_virtual * var->bits_per_pixel >> 3);\r\nif (var->yres_virtual < OMAPFB_PLANE_YRES_MIN)\r\nvar->yres_virtual = OMAPFB_PLANE_YRES_MIN;\r\nif (var->yres > var->yres_virtual)\r\nvar->yres = var->yres_virtual;\r\n}\r\nstatic void shrink_width(unsigned long max_frame_size,\r\nstruct fb_var_screeninfo *var)\r\n{\r\nDBG("can't fit FB into memory, reducing x\n");\r\nvar->xres_virtual = max_frame_size / var->yres_virtual /\r\n(var->bits_per_pixel >> 3);\r\nif (var->xres_virtual < OMAPFB_PLANE_XRES_MIN)\r\nvar->xres_virtual = OMAPFB_PLANE_XRES_MIN;\r\nif (var->xres > var->xres_virtual)\r\nvar->xres = var->xres_virtual;\r\n}\r\nstatic int check_vrfb_fb_size(unsigned long region_size,\r\nconst struct fb_var_screeninfo *var)\r\n{\r\nunsigned long min_phys_size = omap_vrfb_min_phys_size(var->xres_virtual,\r\nvar->yres_virtual, var->bits_per_pixel >> 3);\r\nreturn min_phys_size > region_size ? -EINVAL : 0;\r\n}\r\nstatic int check_fb_size(const struct omapfb_info *ofbi,\r\nstruct fb_var_screeninfo *var)\r\n{\r\nunsigned long max_frame_size = ofbi->region->size;\r\nint bytespp = var->bits_per_pixel >> 3;\r\nunsigned long line_size = var->xres_virtual * bytespp;\r\nif (ofbi->rotation_type == OMAP_DSS_ROT_VRFB) {\r\nif (check_vrfb_fb_size(max_frame_size, var))\r\nshrink_height(omap_vrfb_max_height(\r\nmax_frame_size, var->xres_virtual, bytespp) *\r\nline_size, var);\r\nif (check_vrfb_fb_size(max_frame_size, var)) {\r\nDBG("cannot fit FB to memory\n");\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nDBG("max frame size %lu, line size %lu\n", max_frame_size, line_size);\r\nif (line_size * var->yres_virtual > max_frame_size)\r\nshrink_height(max_frame_size, var);\r\nif (line_size * var->yres_virtual > max_frame_size) {\r\nshrink_width(max_frame_size, var);\r\nline_size = var->xres_virtual * bytespp;\r\n}\r\nif (line_size * var->yres_virtual > max_frame_size) {\r\nDBG("cannot fit FB to memory\n");\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int setup_vrfb_rotation(struct fb_info *fbi)\r\n{\r\nstruct omapfb_info *ofbi = FB2OFB(fbi);\r\nstruct omapfb2_mem_region *rg = ofbi->region;\r\nstruct vrfb *vrfb = &rg->vrfb;\r\nstruct fb_var_screeninfo *var = &fbi->var;\r\nstruct fb_fix_screeninfo *fix = &fbi->fix;\r\nunsigned bytespp;\r\nbool yuv_mode;\r\nenum omap_color_mode mode;\r\nint r;\r\nbool reconf;\r\nif (!rg->size || ofbi->rotation_type != OMAP_DSS_ROT_VRFB)\r\nreturn 0;\r\nDBG("setup_vrfb_rotation\n");\r\nr = fb_mode_to_dss_mode(var, &mode);\r\nif (r)\r\nreturn r;\r\nbytespp = var->bits_per_pixel >> 3;\r\nyuv_mode = mode == OMAP_DSS_COLOR_YUV2 || mode == OMAP_DSS_COLOR_UYVY;\r\nreconf = false;\r\nif (yuv_mode != vrfb->yuv_mode)\r\nreconf = true;\r\nelse if (bytespp != vrfb->bytespp)\r\nreconf = true;\r\nelse if (vrfb->xres != var->xres_virtual ||\r\nvrfb->yres != var->yres_virtual)\r\nreconf = true;\r\nif (vrfb->vaddr[0] && reconf) {\r\nfbi->screen_base = NULL;\r\nfix->smem_start = 0;\r\nfix->smem_len = 0;\r\niounmap(vrfb->vaddr[0]);\r\nvrfb->vaddr[0] = NULL;\r\nDBG("setup_vrfb_rotation: reset fb\n");\r\n}\r\nif (vrfb->vaddr[0])\r\nreturn 0;\r\nomap_vrfb_setup(&rg->vrfb, rg->paddr,\r\nvar->xres_virtual,\r\nvar->yres_virtual,\r\nbytespp, yuv_mode);\r\nr = omap_vrfb_map_angle(vrfb, var->yres_virtual, 0);\r\nif (r)\r\nreturn r;\r\nfbi->screen_base = ofbi->region->vrfb.vaddr[0];\r\nfix->smem_start = ofbi->region->vrfb.paddr[0];\r\nswitch (var->nonstd) {\r\ncase OMAPFB_COLOR_YUV422:\r\ncase OMAPFB_COLOR_YUY422:\r\nfix->line_length =\r\n(OMAP_VRFB_LINE_LEN * var->bits_per_pixel) >> 2;\r\nbreak;\r\ndefault:\r\nfix->line_length =\r\n(OMAP_VRFB_LINE_LEN * var->bits_per_pixel) >> 3;\r\nbreak;\r\n}\r\nfix->smem_len = var->yres_virtual * fix->line_length;\r\nreturn 0;\r\n}\r\nint dss_mode_to_fb_mode(enum omap_color_mode dssmode,\r\nstruct fb_var_screeninfo *var)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(omapfb_colormodes); ++i) {\r\nstruct omapfb_colormode *mode = &omapfb_colormodes[i];\r\nif (dssmode == mode->dssmode) {\r\nassign_colormode_to_var(var, mode);\r\nreturn 0;\r\n}\r\n}\r\nreturn -ENOENT;\r\n}\r\nvoid set_fb_fix(struct fb_info *fbi)\r\n{\r\nstruct fb_fix_screeninfo *fix = &fbi->fix;\r\nstruct fb_var_screeninfo *var = &fbi->var;\r\nstruct omapfb_info *ofbi = FB2OFB(fbi);\r\nstruct omapfb2_mem_region *rg = ofbi->region;\r\nDBG("set_fb_fix\n");\r\nfbi->screen_base = (char __iomem *)omapfb_get_region_vaddr(ofbi);\r\nif (ofbi->rotation_type == OMAP_DSS_ROT_VRFB) {\r\nswitch (var->nonstd) {\r\ncase OMAPFB_COLOR_YUV422:\r\ncase OMAPFB_COLOR_YUY422:\r\nfix->line_length =\r\n(OMAP_VRFB_LINE_LEN * var->bits_per_pixel) >> 2;\r\nbreak;\r\ndefault:\r\nfix->line_length =\r\n(OMAP_VRFB_LINE_LEN * var->bits_per_pixel) >> 3;\r\nbreak;\r\n}\r\nfix->smem_len = var->yres_virtual * fix->line_length;\r\n} else {\r\nfix->line_length =\r\n(var->xres_virtual * var->bits_per_pixel) >> 3;\r\nfix->smem_len = rg->size;\r\n}\r\nfix->smem_start = omapfb_get_region_paddr(ofbi);\r\nfix->type = FB_TYPE_PACKED_PIXELS;\r\nif (var->nonstd)\r\nfix->visual = FB_VISUAL_PSEUDOCOLOR;\r\nelse {\r\nswitch (var->bits_per_pixel) {\r\ncase 32:\r\ncase 24:\r\ncase 16:\r\ncase 12:\r\nfix->visual = FB_VISUAL_TRUECOLOR;\r\nbreak;\r\ncase 1:\r\ncase 2:\r\ncase 4:\r\ncase 8:\r\nfix->visual = FB_VISUAL_PSEUDOCOLOR;\r\nbreak;\r\n}\r\n}\r\nfix->accel = FB_ACCEL_NONE;\r\nfix->xpanstep = 1;\r\nfix->ypanstep = 1;\r\n}\r\nint check_fb_var(struct fb_info *fbi, struct fb_var_screeninfo *var)\r\n{\r\nstruct omapfb_info *ofbi = FB2OFB(fbi);\r\nstruct omap_dss_device *display = fb2display(fbi);\r\nenum omap_color_mode mode = 0;\r\nint i;\r\nint r;\r\nDBG("check_fb_var %d\n", ofbi->id);\r\nWARN_ON(!atomic_read(&ofbi->region->lock_count));\r\nr = fb_mode_to_dss_mode(var, &mode);\r\nif (r) {\r\nDBG("cannot convert var to omap dss mode\n");\r\nreturn r;\r\n}\r\nfor (i = 0; i < ofbi->num_overlays; ++i) {\r\nif ((ofbi->overlays[i]->supported_modes & mode) == 0) {\r\nDBG("invalid mode\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\nif (var->rotate > 3)\r\nreturn -EINVAL;\r\nif (check_fb_res_bounds(var))\r\nreturn -EINVAL;\r\nif (ofbi->region->size != 0 && check_fb_size(ofbi, var))\r\nreturn -EINVAL;\r\nif (var->xres + var->xoffset > var->xres_virtual)\r\nvar->xoffset = var->xres_virtual - var->xres;\r\nif (var->yres + var->yoffset > var->yres_virtual)\r\nvar->yoffset = var->yres_virtual - var->yres;\r\nDBG("xres = %d, yres = %d, vxres = %d, vyres = %d\n",\r\nvar->xres, var->yres,\r\nvar->xres_virtual, var->yres_virtual);\r\nif (display && display->driver->get_dimensions) {\r\nu32 w, h;\r\ndisplay->driver->get_dimensions(display, &w, &h);\r\nvar->width = DIV_ROUND_CLOSEST(w, 1000);\r\nvar->height = DIV_ROUND_CLOSEST(h, 1000);\r\n} else {\r\nvar->height = -1;\r\nvar->width = -1;\r\n}\r\nvar->grayscale = 0;\r\nif (display && display->driver->get_timings) {\r\nstruct omap_video_timings timings;\r\ndisplay->driver->get_timings(display, &timings);\r\nvar->pixclock = timings.pixel_clock != 0 ?\r\nKHZ2PICOS(timings.pixel_clock) :\r\n0;\r\nvar->left_margin = timings.hbp;\r\nvar->right_margin = timings.hfp;\r\nvar->upper_margin = timings.vbp;\r\nvar->lower_margin = timings.vfp;\r\nvar->hsync_len = timings.hsw;\r\nvar->vsync_len = timings.vsw;\r\nvar->sync |= timings.hsync_level == OMAPDSS_SIG_ACTIVE_HIGH ?\r\nFB_SYNC_HOR_HIGH_ACT : 0;\r\nvar->sync |= timings.vsync_level == OMAPDSS_SIG_ACTIVE_HIGH ?\r\nFB_SYNC_VERT_HIGH_ACT : 0;\r\nvar->vmode = timings.interlace ?\r\nFB_VMODE_INTERLACED : FB_VMODE_NONINTERLACED;\r\n} else {\r\nvar->pixclock = 0;\r\nvar->left_margin = 0;\r\nvar->right_margin = 0;\r\nvar->upper_margin = 0;\r\nvar->lower_margin = 0;\r\nvar->hsync_len = 0;\r\nvar->vsync_len = 0;\r\nvar->sync = 0;\r\nvar->vmode = FB_VMODE_NONINTERLACED;\r\n}\r\nreturn 0;\r\n}\r\nstatic int omapfb_open(struct fb_info *fbi, int user)\r\n{\r\nreturn 0;\r\n}\r\nstatic int omapfb_release(struct fb_info *fbi, int user)\r\n{\r\nreturn 0;\r\n}\r\nstatic unsigned calc_rotation_offset_dma(const struct fb_var_screeninfo *var,\r\nconst struct fb_fix_screeninfo *fix, int rotation)\r\n{\r\nunsigned offset;\r\noffset = var->yoffset * fix->line_length +\r\nvar->xoffset * (var->bits_per_pixel >> 3);\r\nreturn offset;\r\n}\r\nstatic unsigned calc_rotation_offset_vrfb(const struct fb_var_screeninfo *var,\r\nconst struct fb_fix_screeninfo *fix, int rotation)\r\n{\r\nunsigned offset;\r\nif (rotation == FB_ROTATE_UD)\r\noffset = (var->yres_virtual - var->yres) *\r\nfix->line_length;\r\nelse if (rotation == FB_ROTATE_CW)\r\noffset = (var->yres_virtual - var->yres) *\r\n(var->bits_per_pixel >> 3);\r\nelse\r\noffset = 0;\r\nif (rotation == FB_ROTATE_UR)\r\noffset += var->yoffset * fix->line_length +\r\nvar->xoffset * (var->bits_per_pixel >> 3);\r\nelse if (rotation == FB_ROTATE_UD)\r\noffset -= var->yoffset * fix->line_length +\r\nvar->xoffset * (var->bits_per_pixel >> 3);\r\nelse if (rotation == FB_ROTATE_CW)\r\noffset -= var->xoffset * fix->line_length +\r\nvar->yoffset * (var->bits_per_pixel >> 3);\r\nelse if (rotation == FB_ROTATE_CCW)\r\noffset += var->xoffset * fix->line_length +\r\nvar->yoffset * (var->bits_per_pixel >> 3);\r\nreturn offset;\r\n}\r\nstatic void omapfb_calc_addr(const struct omapfb_info *ofbi,\r\nconst struct fb_var_screeninfo *var,\r\nconst struct fb_fix_screeninfo *fix,\r\nint rotation, u32 *paddr)\r\n{\r\nu32 data_start_p;\r\nint offset;\r\nif (ofbi->rotation_type == OMAP_DSS_ROT_VRFB)\r\ndata_start_p = omapfb_get_region_rot_paddr(ofbi, rotation);\r\nelse\r\ndata_start_p = omapfb_get_region_paddr(ofbi);\r\nif (ofbi->rotation_type == OMAP_DSS_ROT_VRFB)\r\noffset = calc_rotation_offset_vrfb(var, fix, rotation);\r\nelse\r\noffset = calc_rotation_offset_dma(var, fix, rotation);\r\ndata_start_p += offset;\r\nif (offset)\r\nDBG("offset %d, %d = %d\n",\r\nvar->xoffset, var->yoffset, offset);\r\nDBG("paddr %x\n", data_start_p);\r\n*paddr = data_start_p;\r\n}\r\nint omapfb_setup_overlay(struct fb_info *fbi, struct omap_overlay *ovl,\r\nu16 posx, u16 posy, u16 outw, u16 outh)\r\n{\r\nint r = 0;\r\nstruct omapfb_info *ofbi = FB2OFB(fbi);\r\nstruct fb_var_screeninfo *var = &fbi->var;\r\nstruct fb_fix_screeninfo *fix = &fbi->fix;\r\nenum omap_color_mode mode = 0;\r\nu32 data_start_p = 0;\r\nstruct omap_overlay_info info;\r\nint xres, yres;\r\nint screen_width;\r\nint mirror;\r\nint rotation = var->rotate;\r\nint i;\r\nWARN_ON(!atomic_read(&ofbi->region->lock_count));\r\nfor (i = 0; i < ofbi->num_overlays; i++) {\r\nif (ovl != ofbi->overlays[i])\r\ncontinue;\r\nrotation = (rotation + ofbi->rotation[i]) % 4;\r\nbreak;\r\n}\r\nDBG("setup_overlay %d, posx %d, posy %d, outw %d, outh %d\n", ofbi->id,\r\nposx, posy, outw, outh);\r\nif (rotation == FB_ROTATE_CW || rotation == FB_ROTATE_CCW) {\r\nxres = var->yres;\r\nyres = var->xres;\r\n} else {\r\nxres = var->xres;\r\nyres = var->yres;\r\n}\r\nif (ofbi->region->size)\r\nomapfb_calc_addr(ofbi, var, fix, rotation, &data_start_p);\r\nr = fb_mode_to_dss_mode(var, &mode);\r\nif (r) {\r\nDBG("fb_mode_to_dss_mode failed");\r\ngoto err;\r\n}\r\nswitch (var->nonstd) {\r\ncase OMAPFB_COLOR_YUV422:\r\ncase OMAPFB_COLOR_YUY422:\r\nif (ofbi->rotation_type == OMAP_DSS_ROT_VRFB) {\r\nscreen_width = fix->line_length\r\n/ (var->bits_per_pixel >> 2);\r\nbreak;\r\n}\r\ndefault:\r\nscreen_width = fix->line_length / (var->bits_per_pixel >> 3);\r\nbreak;\r\n}\r\novl->get_overlay_info(ovl, &info);\r\nif (ofbi->rotation_type == OMAP_DSS_ROT_VRFB)\r\nmirror = 0;\r\nelse\r\nmirror = ofbi->mirror;\r\ninfo.paddr = data_start_p;\r\ninfo.screen_width = screen_width;\r\ninfo.width = xres;\r\ninfo.height = yres;\r\ninfo.color_mode = mode;\r\ninfo.rotation_type = ofbi->rotation_type;\r\ninfo.rotation = rotation;\r\ninfo.mirror = mirror;\r\ninfo.pos_x = posx;\r\ninfo.pos_y = posy;\r\ninfo.out_width = outw;\r\ninfo.out_height = outh;\r\nr = ovl->set_overlay_info(ovl, &info);\r\nif (r) {\r\nDBG("ovl->setup_overlay_info failed\n");\r\ngoto err;\r\n}\r\nreturn 0;\r\nerr:\r\nDBG("setup_overlay failed\n");\r\nreturn r;\r\n}\r\nint omapfb_apply_changes(struct fb_info *fbi, int init)\r\n{\r\nint r = 0;\r\nstruct omapfb_info *ofbi = FB2OFB(fbi);\r\nstruct fb_var_screeninfo *var = &fbi->var;\r\nstruct omap_overlay *ovl;\r\nu16 posx, posy;\r\nu16 outw, outh;\r\nint i;\r\n#ifdef DEBUG\r\nif (omapfb_test_pattern)\r\nfill_fb(fbi);\r\n#endif\r\nWARN_ON(!atomic_read(&ofbi->region->lock_count));\r\nfor (i = 0; i < ofbi->num_overlays; i++) {\r\novl = ofbi->overlays[i];\r\nDBG("apply_changes, fb %d, ovl %d\n", ofbi->id, ovl->id);\r\nif (ofbi->region->size == 0) {\r\nomapfb_overlay_enable(ovl, 0);\r\nif (!init && ovl->manager)\r\novl->manager->apply(ovl->manager);\r\ncontinue;\r\n}\r\nif (init || (ovl->caps & OMAP_DSS_OVL_CAP_SCALE) == 0) {\r\nint rotation = (var->rotate + ofbi->rotation[i]) % 4;\r\nif (rotation == FB_ROTATE_CW ||\r\nrotation == FB_ROTATE_CCW) {\r\noutw = var->yres;\r\nouth = var->xres;\r\n} else {\r\noutw = var->xres;\r\nouth = var->yres;\r\n}\r\n} else {\r\nstruct omap_overlay_info info;\r\novl->get_overlay_info(ovl, &info);\r\noutw = info.out_width;\r\nouth = info.out_height;\r\n}\r\nif (init) {\r\nposx = 0;\r\nposy = 0;\r\n} else {\r\nstruct omap_overlay_info info;\r\novl->get_overlay_info(ovl, &info);\r\nposx = info.pos_x;\r\nposy = info.pos_y;\r\n}\r\nr = omapfb_setup_overlay(fbi, ovl, posx, posy, outw, outh);\r\nif (r)\r\ngoto err;\r\nif (!init && ovl->manager)\r\novl->manager->apply(ovl->manager);\r\n}\r\nreturn 0;\r\nerr:\r\nDBG("apply_changes failed\n");\r\nreturn r;\r\n}\r\nstatic int omapfb_check_var(struct fb_var_screeninfo *var, struct fb_info *fbi)\r\n{\r\nstruct omapfb_info *ofbi = FB2OFB(fbi);\r\nint r;\r\nDBG("check_var(%d)\n", FB2OFB(fbi)->id);\r\nomapfb_get_mem_region(ofbi->region);\r\nr = check_fb_var(fbi, var);\r\nomapfb_put_mem_region(ofbi->region);\r\nreturn r;\r\n}\r\nstatic int omapfb_set_par(struct fb_info *fbi)\r\n{\r\nstruct omapfb_info *ofbi = FB2OFB(fbi);\r\nint r;\r\nDBG("set_par(%d)\n", FB2OFB(fbi)->id);\r\nomapfb_get_mem_region(ofbi->region);\r\nset_fb_fix(fbi);\r\nr = setup_vrfb_rotation(fbi);\r\nif (r)\r\ngoto out;\r\nr = omapfb_apply_changes(fbi, 0);\r\nout:\r\nomapfb_put_mem_region(ofbi->region);\r\nreturn r;\r\n}\r\nstatic int omapfb_pan_display(struct fb_var_screeninfo *var,\r\nstruct fb_info *fbi)\r\n{\r\nstruct omapfb_info *ofbi = FB2OFB(fbi);\r\nstruct fb_var_screeninfo new_var;\r\nint r;\r\nDBG("pan_display(%d)\n", FB2OFB(fbi)->id);\r\nif (var->xoffset == fbi->var.xoffset &&\r\nvar->yoffset == fbi->var.yoffset)\r\nreturn 0;\r\nnew_var = fbi->var;\r\nnew_var.xoffset = var->xoffset;\r\nnew_var.yoffset = var->yoffset;\r\nfbi->var = new_var;\r\nomapfb_get_mem_region(ofbi->region);\r\nr = omapfb_apply_changes(fbi, 0);\r\nomapfb_put_mem_region(ofbi->region);\r\nreturn r;\r\n}\r\nstatic void mmap_user_open(struct vm_area_struct *vma)\r\n{\r\nstruct omapfb2_mem_region *rg = vma->vm_private_data;\r\nomapfb_get_mem_region(rg);\r\natomic_inc(&rg->map_count);\r\nomapfb_put_mem_region(rg);\r\n}\r\nstatic void mmap_user_close(struct vm_area_struct *vma)\r\n{\r\nstruct omapfb2_mem_region *rg = vma->vm_private_data;\r\nomapfb_get_mem_region(rg);\r\natomic_dec(&rg->map_count);\r\nomapfb_put_mem_region(rg);\r\n}\r\nstatic int omapfb_mmap(struct fb_info *fbi, struct vm_area_struct *vma)\r\n{\r\nstruct omapfb_info *ofbi = FB2OFB(fbi);\r\nstruct fb_fix_screeninfo *fix = &fbi->fix;\r\nstruct omapfb2_mem_region *rg;\r\nunsigned long off;\r\nunsigned long start;\r\nu32 len;\r\nint r = -EINVAL;\r\nif (vma->vm_end - vma->vm_start == 0)\r\nreturn 0;\r\nif (vma->vm_pgoff > (~0UL >> PAGE_SHIFT))\r\nreturn -EINVAL;\r\noff = vma->vm_pgoff << PAGE_SHIFT;\r\nrg = omapfb_get_mem_region(ofbi->region);\r\nstart = omapfb_get_region_paddr(ofbi);\r\nlen = fix->smem_len;\r\nif (off >= len)\r\ngoto error;\r\nif ((vma->vm_end - vma->vm_start + off) > len)\r\ngoto error;\r\noff += start;\r\nDBG("user mmap region start %lx, len %d, off %lx\n", start, len, off);\r\nvma->vm_pgoff = off >> PAGE_SHIFT;\r\nvma->vm_page_prot = pgprot_writecombine(vma->vm_page_prot);\r\nvma->vm_ops = &mmap_user_ops;\r\nvma->vm_private_data = rg;\r\nif (io_remap_pfn_range(vma, vma->vm_start, off >> PAGE_SHIFT,\r\nvma->vm_end - vma->vm_start,\r\nvma->vm_page_prot)) {\r\nr = -EAGAIN;\r\ngoto error;\r\n}\r\natomic_inc(&rg->map_count);\r\nomapfb_put_mem_region(rg);\r\nreturn 0;\r\nerror:\r\nomapfb_put_mem_region(ofbi->region);\r\nreturn r;\r\n}\r\nstatic int _setcolreg(struct fb_info *fbi, u_int regno, u_int red, u_int green,\r\nu_int blue, u_int transp, int update_hw_pal)\r\n{\r\nstruct fb_var_screeninfo *var = &fbi->var;\r\nint r = 0;\r\nenum omapfb_color_format mode = OMAPFB_COLOR_RGB24U;\r\nswitch (mode) {\r\ncase OMAPFB_COLOR_YUV422:\r\ncase OMAPFB_COLOR_YUV420:\r\ncase OMAPFB_COLOR_YUY422:\r\nr = -EINVAL;\r\nbreak;\r\ncase OMAPFB_COLOR_CLUT_8BPP:\r\ncase OMAPFB_COLOR_CLUT_4BPP:\r\ncase OMAPFB_COLOR_CLUT_2BPP:\r\ncase OMAPFB_COLOR_CLUT_1BPP:\r\nr = -EINVAL;\r\nbreak;\r\ncase OMAPFB_COLOR_RGB565:\r\ncase OMAPFB_COLOR_RGB444:\r\ncase OMAPFB_COLOR_RGB24P:\r\ncase OMAPFB_COLOR_RGB24U:\r\nif (r != 0)\r\nbreak;\r\nif (regno < 16) {\r\nu32 pal;\r\npal = ((red >> (16 - var->red.length)) <<\r\nvar->red.offset) |\r\n((green >> (16 - var->green.length)) <<\r\nvar->green.offset) |\r\n(blue >> (16 - var->blue.length));\r\n((u32 *)(fbi->pseudo_palette))[regno] = pal;\r\n}\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\nreturn r;\r\n}\r\nstatic int omapfb_setcolreg(u_int regno, u_int red, u_int green, u_int blue,\r\nu_int transp, struct fb_info *info)\r\n{\r\nDBG("setcolreg\n");\r\nreturn _setcolreg(info, regno, red, green, blue, transp, 1);\r\n}\r\nstatic int omapfb_setcmap(struct fb_cmap *cmap, struct fb_info *info)\r\n{\r\nint count, index, r;\r\nu16 *red, *green, *blue, *transp;\r\nu16 trans = 0xffff;\r\nDBG("setcmap\n");\r\nred = cmap->red;\r\ngreen = cmap->green;\r\nblue = cmap->blue;\r\ntransp = cmap->transp;\r\nindex = cmap->start;\r\nfor (count = 0; count < cmap->len; count++) {\r\nif (transp)\r\ntrans = *transp++;\r\nr = _setcolreg(info, index++, *red++, *green++, *blue++, trans,\r\ncount == cmap->len - 1);\r\nif (r != 0)\r\nreturn r;\r\n}\r\nreturn 0;\r\n}\r\nstatic int omapfb_blank(int blank, struct fb_info *fbi)\r\n{\r\nstruct omapfb_info *ofbi = FB2OFB(fbi);\r\nstruct omapfb2_device *fbdev = ofbi->fbdev;\r\nstruct omap_dss_device *display = fb2display(fbi);\r\nstruct omapfb_display_data *d;\r\nint r = 0;\r\nif (!display)\r\nreturn -EINVAL;\r\nomapfb_lock(fbdev);\r\nd = get_display_data(fbdev, display);\r\nswitch (blank) {\r\ncase FB_BLANK_UNBLANK:\r\nif (display->state == OMAP_DSS_DISPLAY_ACTIVE)\r\ngoto exit;\r\nr = display->driver->enable(display);\r\nif ((display->caps & OMAP_DSS_DISPLAY_CAP_MANUAL_UPDATE) &&\r\nd->update_mode == OMAPFB_AUTO_UPDATE &&\r\n!d->auto_update_work_enabled)\r\nomapfb_start_auto_update(fbdev, display);\r\nbreak;\r\ncase FB_BLANK_NORMAL:\r\ncase FB_BLANK_VSYNC_SUSPEND:\r\ncase FB_BLANK_HSYNC_SUSPEND:\r\ncase FB_BLANK_POWERDOWN:\r\nif (display->state != OMAP_DSS_DISPLAY_ACTIVE)\r\ngoto exit;\r\nif (d->auto_update_work_enabled)\r\nomapfb_stop_auto_update(fbdev, display);\r\ndisplay->driver->disable(display);\r\nbreak;\r\ndefault:\r\nr = -EINVAL;\r\n}\r\nexit:\r\nomapfb_unlock(fbdev);\r\nreturn r;\r\n}\r\nstatic void omapfb_free_fbmem(struct fb_info *fbi)\r\n{\r\nstruct omapfb_info *ofbi = FB2OFB(fbi);\r\nstruct omapfb2_device *fbdev = ofbi->fbdev;\r\nstruct omapfb2_mem_region *rg;\r\nrg = ofbi->region;\r\nif (rg->token == NULL)\r\nreturn;\r\nWARN_ON(atomic_read(&rg->map_count));\r\nif (ofbi->rotation_type == OMAP_DSS_ROT_VRFB) {\r\nif (rg->vrfb.vaddr[0]) {\r\niounmap(rg->vrfb.vaddr[0]);\r\nrg->vrfb.vaddr[0] = NULL;\r\n}\r\nomap_vrfb_release_ctx(&rg->vrfb);\r\n}\r\ndma_free_attrs(fbdev->dev, rg->size, rg->token, rg->dma_handle,\r\n&rg->attrs);\r\nrg->token = NULL;\r\nrg->vaddr = NULL;\r\nrg->paddr = 0;\r\nrg->alloc = 0;\r\nrg->size = 0;\r\n}\r\nstatic void clear_fb_info(struct fb_info *fbi)\r\n{\r\nmemset(&fbi->var, 0, sizeof(fbi->var));\r\nmemset(&fbi->fix, 0, sizeof(fbi->fix));\r\nstrlcpy(fbi->fix.id, MODULE_NAME, sizeof(fbi->fix.id));\r\n}\r\nstatic int omapfb_free_all_fbmem(struct omapfb2_device *fbdev)\r\n{\r\nint i;\r\nDBG("free all fbmem\n");\r\nfor (i = 0; i < fbdev->num_fbs; i++) {\r\nstruct fb_info *fbi = fbdev->fbs[i];\r\nomapfb_free_fbmem(fbi);\r\nclear_fb_info(fbi);\r\n}\r\nreturn 0;\r\n}\r\nstatic int omapfb_alloc_fbmem(struct fb_info *fbi, unsigned long size,\r\nunsigned long paddr)\r\n{\r\nstruct omapfb_info *ofbi = FB2OFB(fbi);\r\nstruct omapfb2_device *fbdev = ofbi->fbdev;\r\nstruct omapfb2_mem_region *rg;\r\nvoid *token;\r\nDEFINE_DMA_ATTRS(attrs);\r\ndma_addr_t dma_handle;\r\nint r;\r\nrg = ofbi->region;\r\nrg->paddr = 0;\r\nrg->vaddr = NULL;\r\nmemset(&rg->vrfb, 0, sizeof rg->vrfb);\r\nrg->size = 0;\r\nrg->type = 0;\r\nrg->alloc = false;\r\nrg->map = false;\r\nsize = PAGE_ALIGN(size);\r\ndma_set_attr(DMA_ATTR_WRITE_COMBINE, &attrs);\r\nif (ofbi->rotation_type == OMAP_DSS_ROT_VRFB)\r\ndma_set_attr(DMA_ATTR_NO_KERNEL_MAPPING, &attrs);\r\nDBG("allocating %lu bytes for fb %d\n", size, ofbi->id);\r\ntoken = dma_alloc_attrs(fbdev->dev, size, &dma_handle,\r\nGFP_KERNEL, &attrs);\r\nif (token == NULL) {\r\ndev_err(fbdev->dev, "failed to allocate framebuffer\n");\r\nreturn -ENOMEM;\r\n}\r\nDBG("allocated VRAM paddr %lx, vaddr %p\n",\r\n(unsigned long)dma_handle, token);\r\nif (ofbi->rotation_type == OMAP_DSS_ROT_VRFB) {\r\nr = omap_vrfb_request_ctx(&rg->vrfb);\r\nif (r) {\r\ndma_free_attrs(fbdev->dev, size, token, dma_handle,\r\n&attrs);\r\ndev_err(fbdev->dev, "vrfb create ctx failed\n");\r\nreturn r;\r\n}\r\n}\r\nrg->attrs = attrs;\r\nrg->token = token;\r\nrg->dma_handle = dma_handle;\r\nrg->paddr = (unsigned long)dma_handle;\r\nrg->vaddr = (void __iomem *)token;\r\nrg->size = size;\r\nrg->alloc = 1;\r\nreturn 0;\r\n}\r\nstatic int omapfb_alloc_fbmem_display(struct fb_info *fbi, unsigned long size,\r\nunsigned long paddr)\r\n{\r\nstruct omapfb_info *ofbi = FB2OFB(fbi);\r\nstruct omapfb2_device *fbdev = ofbi->fbdev;\r\nstruct omap_dss_device *display;\r\nint bytespp;\r\ndisplay = fb2display(fbi);\r\nif (!display)\r\nreturn 0;\r\nswitch (omapfb_get_recommended_bpp(fbdev, display)) {\r\ncase 16:\r\nbytespp = 2;\r\nbreak;\r\ncase 24:\r\nbytespp = 4;\r\nbreak;\r\ndefault:\r\nbytespp = 4;\r\nbreak;\r\n}\r\nif (!size) {\r\nu16 w, h;\r\ndisplay->driver->get_resolution(display, &w, &h);\r\nif (ofbi->rotation_type == OMAP_DSS_ROT_VRFB) {\r\nsize = max(omap_vrfb_min_phys_size(w, h, bytespp),\r\nomap_vrfb_min_phys_size(h, w, bytespp));\r\nDBG("adjusting fb mem size for VRFB, %u -> %lu\n",\r\nw * h * bytespp, size);\r\n} else {\r\nsize = w * h * bytespp;\r\n}\r\n}\r\nif (!size)\r\nreturn 0;\r\nreturn omapfb_alloc_fbmem(fbi, size, paddr);\r\n}\r\nstatic int omapfb_parse_vram_param(const char *param, int max_entries,\r\nunsigned long *sizes, unsigned long *paddrs)\r\n{\r\nint fbnum;\r\nunsigned long size;\r\nunsigned long paddr = 0;\r\nchar *p, *start;\r\nstart = (char *)param;\r\nwhile (1) {\r\np = start;\r\nfbnum = simple_strtoul(p, &p, 10);\r\nif (p == start)\r\nreturn -EINVAL;\r\nif (*p != ':')\r\nreturn -EINVAL;\r\nif (fbnum >= max_entries)\r\nreturn -EINVAL;\r\nsize = memparse(p + 1, &p);\r\nif (!size)\r\nreturn -EINVAL;\r\npaddr = 0;\r\nif (*p == '@') {\r\npaddr = simple_strtoul(p + 1, &p, 16);\r\nif (!paddr)\r\nreturn -EINVAL;\r\n}\r\nWARN_ONCE(paddr,\r\n"reserving memory at predefined address not supported\n");\r\npaddrs[fbnum] = paddr;\r\nsizes[fbnum] = size;\r\nif (*p == 0)\r\nbreak;\r\nif (*p != ',')\r\nreturn -EINVAL;\r\n++p;\r\nstart = p;\r\n}\r\nreturn 0;\r\n}\r\nstatic int omapfb_allocate_all_fbs(struct omapfb2_device *fbdev)\r\n{\r\nint i, r;\r\nunsigned long vram_sizes[10];\r\nunsigned long vram_paddrs[10];\r\nmemset(&vram_sizes, 0, sizeof(vram_sizes));\r\nmemset(&vram_paddrs, 0, sizeof(vram_paddrs));\r\nif (def_vram && omapfb_parse_vram_param(def_vram, 10,\r\nvram_sizes, vram_paddrs)) {\r\ndev_err(fbdev->dev, "failed to parse vram parameter\n");\r\nmemset(&vram_sizes, 0, sizeof(vram_sizes));\r\nmemset(&vram_paddrs, 0, sizeof(vram_paddrs));\r\n}\r\nfor (i = 0; i < fbdev->num_fbs; i++) {\r\nif (i == 0 || vram_sizes[i] != 0) {\r\nr = omapfb_alloc_fbmem_display(fbdev->fbs[i],\r\nvram_sizes[i], vram_paddrs[i]);\r\nif (r)\r\nreturn r;\r\n}\r\n}\r\nfor (i = 0; i < fbdev->num_fbs; i++) {\r\nstruct omapfb_info *ofbi = FB2OFB(fbdev->fbs[i]);\r\nstruct omapfb2_mem_region *rg;\r\nrg = ofbi->region;\r\nDBG("region%d phys %08x virt %p size=%lu\n",\r\ni,\r\nrg->paddr,\r\nrg->vaddr,\r\nrg->size);\r\n}\r\nreturn 0;\r\n}\r\nstatic void omapfb_clear_fb(struct fb_info *fbi)\r\n{\r\nconst struct fb_fillrect rect = {\r\n.dx = 0,\r\n.dy = 0,\r\n.width = fbi->var.xres_virtual,\r\n.height = fbi->var.yres_virtual,\r\n.color = 0,\r\n.rop = ROP_COPY,\r\n};\r\ncfb_fillrect(fbi, &rect);\r\n}\r\nint omapfb_realloc_fbmem(struct fb_info *fbi, unsigned long size, int type)\r\n{\r\nstruct omapfb_info *ofbi = FB2OFB(fbi);\r\nstruct omapfb2_device *fbdev = ofbi->fbdev;\r\nstruct omapfb2_mem_region *rg = ofbi->region;\r\nunsigned long old_size = rg->size;\r\nunsigned long old_paddr = rg->paddr;\r\nint old_type = rg->type;\r\nint r;\r\nif (type != OMAPFB_MEMTYPE_SDRAM)\r\nreturn -EINVAL;\r\nsize = PAGE_ALIGN(size);\r\nif (old_size == size && old_type == type)\r\nreturn 0;\r\nomapfb_free_fbmem(fbi);\r\nif (size == 0) {\r\nclear_fb_info(fbi);\r\nreturn 0;\r\n}\r\nr = omapfb_alloc_fbmem(fbi, size, 0);\r\nif (r) {\r\nif (old_size)\r\nomapfb_alloc_fbmem(fbi, old_size, old_paddr);\r\nif (rg->size == 0)\r\nclear_fb_info(fbi);\r\nreturn r;\r\n}\r\nif (old_size == size)\r\nreturn 0;\r\nif (old_size == 0) {\r\nDBG("initializing fb %d\n", ofbi->id);\r\nr = omapfb_fb_init(fbdev, fbi);\r\nif (r) {\r\nDBG("omapfb_fb_init failed\n");\r\ngoto err;\r\n}\r\nr = omapfb_apply_changes(fbi, 1);\r\nif (r) {\r\nDBG("omapfb_apply_changes failed\n");\r\ngoto err;\r\n}\r\n} else {\r\nstruct fb_var_screeninfo new_var;\r\nmemcpy(&new_var, &fbi->var, sizeof(new_var));\r\nr = check_fb_var(fbi, &new_var);\r\nif (r)\r\ngoto err;\r\nmemcpy(&fbi->var, &new_var, sizeof(fbi->var));\r\nset_fb_fix(fbi);\r\nr = setup_vrfb_rotation(fbi);\r\nif (r)\r\ngoto err;\r\n}\r\nomapfb_clear_fb(fbi);\r\nreturn 0;\r\nerr:\r\nomapfb_free_fbmem(fbi);\r\nclear_fb_info(fbi);\r\nreturn r;\r\n}\r\nstatic void omapfb_auto_update_work(struct work_struct *work)\r\n{\r\nstruct omap_dss_device *dssdev;\r\nstruct omap_dss_driver *dssdrv;\r\nstruct omapfb_display_data *d;\r\nu16 w, h;\r\nunsigned int freq;\r\nstruct omapfb2_device *fbdev;\r\nd = container_of(work, struct omapfb_display_data,\r\nauto_update_work.work);\r\ndssdev = d->dssdev;\r\ndssdrv = dssdev->driver;\r\nfbdev = d->fbdev;\r\nif (!dssdrv || !dssdrv->update)\r\nreturn;\r\nif (dssdrv->sync)\r\ndssdrv->sync(dssdev);\r\ndssdrv->get_resolution(dssdev, &w, &h);\r\ndssdrv->update(dssdev, 0, 0, w, h);\r\nfreq = auto_update_freq;\r\nif (freq == 0)\r\nfreq = 20;\r\nqueue_delayed_work(fbdev->auto_update_wq,\r\n&d->auto_update_work, HZ / freq);\r\n}\r\nvoid omapfb_start_auto_update(struct omapfb2_device *fbdev,\r\nstruct omap_dss_device *display)\r\n{\r\nstruct omapfb_display_data *d;\r\nif (fbdev->auto_update_wq == NULL) {\r\nstruct workqueue_struct *wq;\r\nwq = create_singlethread_workqueue("omapfb_auto_update");\r\nif (wq == NULL) {\r\ndev_err(fbdev->dev, "Failed to create workqueue for "\r\n"auto-update\n");\r\nreturn;\r\n}\r\nfbdev->auto_update_wq = wq;\r\n}\r\nd = get_display_data(fbdev, display);\r\nINIT_DELAYED_WORK(&d->auto_update_work, omapfb_auto_update_work);\r\nd->auto_update_work_enabled = true;\r\nomapfb_auto_update_work(&d->auto_update_work.work);\r\n}\r\nvoid omapfb_stop_auto_update(struct omapfb2_device *fbdev,\r\nstruct omap_dss_device *display)\r\n{\r\nstruct omapfb_display_data *d;\r\nd = get_display_data(fbdev, display);\r\ncancel_delayed_work_sync(&d->auto_update_work);\r\nd->auto_update_work_enabled = false;\r\n}\r\nstatic int omapfb_fb_init(struct omapfb2_device *fbdev, struct fb_info *fbi)\r\n{\r\nstruct fb_var_screeninfo *var = &fbi->var;\r\nstruct omap_dss_device *display = fb2display(fbi);\r\nstruct omapfb_info *ofbi = FB2OFB(fbi);\r\nint r = 0;\r\nfbi->fbops = &omapfb_ops;\r\nfbi->flags = FBINFO_FLAG_DEFAULT;\r\nfbi->pseudo_palette = fbdev->pseudo_palette;\r\nif (ofbi->region->size == 0) {\r\nclear_fb_info(fbi);\r\nreturn 0;\r\n}\r\nvar->nonstd = 0;\r\nvar->bits_per_pixel = 0;\r\nvar->rotate = def_rotate;\r\nif (display) {\r\nu16 w, h;\r\nint rotation = (var->rotate + ofbi->rotation[0]) % 4;\r\ndisplay->driver->get_resolution(display, &w, &h);\r\nif (rotation == FB_ROTATE_CW ||\r\nrotation == FB_ROTATE_CCW) {\r\nvar->xres = h;\r\nvar->yres = w;\r\n} else {\r\nvar->xres = w;\r\nvar->yres = h;\r\n}\r\nvar->xres_virtual = var->xres;\r\nvar->yres_virtual = var->yres;\r\nif (!var->bits_per_pixel) {\r\nswitch (omapfb_get_recommended_bpp(fbdev, display)) {\r\ncase 16:\r\nvar->bits_per_pixel = 16;\r\nbreak;\r\ncase 24:\r\nvar->bits_per_pixel = 32;\r\nbreak;\r\ndefault:\r\ndev_err(fbdev->dev, "illegal display "\r\n"bpp\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\n} else {\r\nvar->xres = 320;\r\nvar->yres = 240;\r\nvar->xres_virtual = var->xres;\r\nvar->yres_virtual = var->yres;\r\nif (!var->bits_per_pixel)\r\nvar->bits_per_pixel = 16;\r\n}\r\nr = check_fb_var(fbi, var);\r\nif (r)\r\ngoto err;\r\nset_fb_fix(fbi);\r\nr = setup_vrfb_rotation(fbi);\r\nif (r)\r\ngoto err;\r\nr = fb_alloc_cmap(&fbi->cmap, 256, 0);\r\nif (r)\r\ndev_err(fbdev->dev, "unable to allocate color map memory\n");\r\nerr:\r\nreturn r;\r\n}\r\nstatic void fbinfo_cleanup(struct omapfb2_device *fbdev, struct fb_info *fbi)\r\n{\r\nfb_dealloc_cmap(&fbi->cmap);\r\n}\r\nstatic void omapfb_free_resources(struct omapfb2_device *fbdev)\r\n{\r\nint i;\r\nDBG("free_resources\n");\r\nif (fbdev == NULL)\r\nreturn;\r\nfor (i = 0; i < fbdev->num_fbs; i++)\r\nunregister_framebuffer(fbdev->fbs[i]);\r\nomapfb_free_all_fbmem(fbdev);\r\nfor (i = 0; i < fbdev->num_fbs; i++) {\r\nfbinfo_cleanup(fbdev, fbdev->fbs[i]);\r\nframebuffer_release(fbdev->fbs[i]);\r\n}\r\nfor (i = 0; i < fbdev->num_displays; i++) {\r\nstruct omap_dss_device *dssdev = fbdev->displays[i].dssdev;\r\nif (fbdev->displays[i].auto_update_work_enabled)\r\nomapfb_stop_auto_update(fbdev, dssdev);\r\nif (dssdev->state != OMAP_DSS_DISPLAY_DISABLED)\r\ndssdev->driver->disable(dssdev);\r\nomap_dss_put_device(dssdev);\r\n}\r\nif (fbdev->auto_update_wq != NULL) {\r\nflush_workqueue(fbdev->auto_update_wq);\r\ndestroy_workqueue(fbdev->auto_update_wq);\r\nfbdev->auto_update_wq = NULL;\r\n}\r\ndev_set_drvdata(fbdev->dev, NULL);\r\n}\r\nstatic int omapfb_create_framebuffers(struct omapfb2_device *fbdev)\r\n{\r\nint r, i;\r\nfbdev->num_fbs = 0;\r\nDBG("create %d framebuffers\n", CONFIG_FB_OMAP2_NUM_FBS);\r\nfor (i = 0; i < CONFIG_FB_OMAP2_NUM_FBS; i++) {\r\nstruct fb_info *fbi;\r\nstruct omapfb_info *ofbi;\r\nfbi = framebuffer_alloc(sizeof(struct omapfb_info),\r\nfbdev->dev);\r\nif (fbi == NULL) {\r\ndev_err(fbdev->dev,\r\n"unable to allocate memory for plane info\n");\r\nreturn -ENOMEM;\r\n}\r\nclear_fb_info(fbi);\r\nfbdev->fbs[i] = fbi;\r\nofbi = FB2OFB(fbi);\r\nofbi->fbdev = fbdev;\r\nofbi->id = i;\r\nofbi->region = &fbdev->regions[i];\r\nofbi->region->id = i;\r\ninit_rwsem(&ofbi->region->lock);\r\nofbi->rotation_type = def_vrfb ? OMAP_DSS_ROT_VRFB :\r\nOMAP_DSS_ROT_DMA;\r\nofbi->mirror = def_mirror;\r\nfbdev->num_fbs++;\r\n}\r\nDBG("fb_infos allocated\n");\r\nfor (i = 0; i < min(fbdev->num_fbs, fbdev->num_overlays); i++) {\r\nstruct omapfb_info *ofbi = FB2OFB(fbdev->fbs[i]);\r\nofbi->overlays[0] = fbdev->overlays[i];\r\nofbi->num_overlays = 1;\r\n}\r\nr = omapfb_allocate_all_fbs(fbdev);\r\nif (r) {\r\ndev_err(fbdev->dev, "failed to allocate fbmem\n");\r\nreturn r;\r\n}\r\nDBG("fbmems allocated\n");\r\nfor (i = 0; i < fbdev->num_fbs; i++) {\r\nstruct fb_info *fbi = fbdev->fbs[i];\r\nstruct omapfb_info *ofbi = FB2OFB(fbi);\r\nomapfb_get_mem_region(ofbi->region);\r\nr = omapfb_fb_init(fbdev, fbi);\r\nomapfb_put_mem_region(ofbi->region);\r\nif (r) {\r\ndev_err(fbdev->dev, "failed to setup fb_info\n");\r\nreturn r;\r\n}\r\n}\r\nfor (i = 0; i < fbdev->num_fbs; i++) {\r\nstruct fb_info *fbi = fbdev->fbs[i];\r\nstruct omapfb_info *ofbi = FB2OFB(fbi);\r\nif (ofbi->region->size == 0)\r\ncontinue;\r\nomapfb_clear_fb(fbi);\r\n}\r\nDBG("fb_infos initialized\n");\r\nfor (i = 0; i < fbdev->num_fbs; i++) {\r\nr = register_framebuffer(fbdev->fbs[i]);\r\nif (r != 0) {\r\ndev_err(fbdev->dev,\r\n"registering framebuffer %d failed\n", i);\r\nreturn r;\r\n}\r\n}\r\nDBG("framebuffers registered\n");\r\nfor (i = 0; i < fbdev->num_fbs; i++) {\r\nstruct fb_info *fbi = fbdev->fbs[i];\r\nstruct omapfb_info *ofbi = FB2OFB(fbi);\r\nomapfb_get_mem_region(ofbi->region);\r\nr = omapfb_apply_changes(fbi, 1);\r\nomapfb_put_mem_region(ofbi->region);\r\nif (r) {\r\ndev_err(fbdev->dev, "failed to change mode\n");\r\nreturn r;\r\n}\r\n}\r\nif (fbdev->num_fbs > 0) {\r\nstruct omapfb_info *ofbi = FB2OFB(fbdev->fbs[0]);\r\nif (ofbi->num_overlays > 0) {\r\nstruct omap_overlay *ovl = ofbi->overlays[0];\r\novl->manager->apply(ovl->manager);\r\nr = omapfb_overlay_enable(ovl, 1);\r\nif (r) {\r\ndev_err(fbdev->dev,\r\n"failed to enable overlay\n");\r\nreturn r;\r\n}\r\n}\r\n}\r\nDBG("create_framebuffers done\n");\r\nreturn 0;\r\n}\r\nstatic int omapfb_mode_to_timings(const char *mode_str,\r\nstruct omap_dss_device *display,\r\nstruct omap_video_timings *timings, u8 *bpp)\r\n{\r\nstruct fb_info *fbi;\r\nstruct fb_var_screeninfo *var;\r\nstruct fb_ops *fbops;\r\nint r;\r\n#ifdef CONFIG_OMAP2_DSS_VENC\r\nif (strcmp(mode_str, "pal") == 0) {\r\n*timings = omap_dss_pal_timings;\r\n*bpp = 24;\r\nreturn 0;\r\n} else if (strcmp(mode_str, "ntsc") == 0) {\r\n*timings = omap_dss_ntsc_timings;\r\n*bpp = 24;\r\nreturn 0;\r\n}\r\n#endif\r\n*bpp = 0;\r\nfbi = NULL;\r\nvar = NULL;\r\nfbops = NULL;\r\nfbi = kzalloc(sizeof(*fbi), GFP_KERNEL);\r\nif (fbi == NULL) {\r\nr = -ENOMEM;\r\ngoto err;\r\n}\r\nvar = kzalloc(sizeof(*var), GFP_KERNEL);\r\nif (var == NULL) {\r\nr = -ENOMEM;\r\ngoto err;\r\n}\r\nfbops = kzalloc(sizeof(*fbops), GFP_KERNEL);\r\nif (fbops == NULL) {\r\nr = -ENOMEM;\r\ngoto err;\r\n}\r\nfbi->fbops = fbops;\r\nr = fb_find_mode(var, fbi, mode_str, NULL, 0, NULL, 24);\r\nif (r == 0) {\r\nr = -EINVAL;\r\ngoto err;\r\n}\r\nif (display->driver->get_timings) {\r\ndisplay->driver->get_timings(display, timings);\r\n} else {\r\ntimings->data_pclk_edge = OMAPDSS_DRIVE_SIG_RISING_EDGE;\r\ntimings->de_level = OMAPDSS_SIG_ACTIVE_HIGH;\r\ntimings->sync_pclk_edge = OMAPDSS_DRIVE_SIG_OPPOSITE_EDGES;\r\n}\r\ntimings->pixel_clock = PICOS2KHZ(var->pixclock);\r\ntimings->hbp = var->left_margin;\r\ntimings->hfp = var->right_margin;\r\ntimings->vbp = var->upper_margin;\r\ntimings->vfp = var->lower_margin;\r\ntimings->hsw = var->hsync_len;\r\ntimings->vsw = var->vsync_len;\r\ntimings->x_res = var->xres;\r\ntimings->y_res = var->yres;\r\ntimings->hsync_level = var->sync & FB_SYNC_HOR_HIGH_ACT ?\r\nOMAPDSS_SIG_ACTIVE_HIGH :\r\nOMAPDSS_SIG_ACTIVE_LOW;\r\ntimings->vsync_level = var->sync & FB_SYNC_VERT_HIGH_ACT ?\r\nOMAPDSS_SIG_ACTIVE_HIGH :\r\nOMAPDSS_SIG_ACTIVE_LOW;\r\ntimings->interlace = var->vmode & FB_VMODE_INTERLACED;\r\nswitch (var->bits_per_pixel) {\r\ncase 16:\r\n*bpp = 16;\r\nbreak;\r\ncase 24:\r\ncase 32:\r\ndefault:\r\n*bpp = 24;\r\nbreak;\r\n}\r\nr = 0;\r\nerr:\r\nkfree(fbi);\r\nkfree(var);\r\nkfree(fbops);\r\nreturn r;\r\n}\r\nstatic int omapfb_set_def_mode(struct omapfb2_device *fbdev,\r\nstruct omap_dss_device *display, char *mode_str)\r\n{\r\nint r;\r\nu8 bpp;\r\nstruct omap_video_timings timings, temp_timings;\r\nstruct omapfb_display_data *d;\r\nr = omapfb_mode_to_timings(mode_str, display, &timings, &bpp);\r\nif (r)\r\nreturn r;\r\nd = get_display_data(fbdev, display);\r\nd->bpp_override = bpp;\r\nif (display->driver->check_timings) {\r\nr = display->driver->check_timings(display, &timings);\r\nif (r)\r\nreturn r;\r\n} else {\r\nif (display->driver->get_timings) {\r\ndisplay->driver->get_timings(display, &temp_timings);\r\nif (temp_timings.x_res != timings.x_res ||\r\ntemp_timings.y_res != timings.y_res)\r\nreturn -EINVAL;\r\n}\r\n}\r\nif (display->driver->set_timings)\r\ndisplay->driver->set_timings(display, &timings);\r\nreturn 0;\r\n}\r\nstatic int omapfb_get_recommended_bpp(struct omapfb2_device *fbdev,\r\nstruct omap_dss_device *dssdev)\r\n{\r\nstruct omapfb_display_data *d;\r\nBUG_ON(dssdev->driver->get_recommended_bpp == NULL);\r\nd = get_display_data(fbdev, dssdev);\r\nif (d->bpp_override != 0)\r\nreturn d->bpp_override;\r\nreturn dssdev->driver->get_recommended_bpp(dssdev);\r\n}\r\nstatic int omapfb_parse_def_modes(struct omapfb2_device *fbdev)\r\n{\r\nchar *str, *options, *this_opt;\r\nint r = 0;\r\nstr = kstrdup(def_mode, GFP_KERNEL);\r\nif (!str)\r\nreturn -ENOMEM;\r\noptions = str;\r\nwhile (!r && (this_opt = strsep(&options, ",")) != NULL) {\r\nchar *p, *display_str, *mode_str;\r\nstruct omap_dss_device *display;\r\nint i;\r\np = strchr(this_opt, ':');\r\nif (!p) {\r\nr = -EINVAL;\r\nbreak;\r\n}\r\n*p = 0;\r\ndisplay_str = this_opt;\r\nmode_str = p + 1;\r\ndisplay = NULL;\r\nfor (i = 0; i < fbdev->num_displays; ++i) {\r\nif (strcmp(fbdev->displays[i].dssdev->name,\r\ndisplay_str) == 0) {\r\ndisplay = fbdev->displays[i].dssdev;\r\nbreak;\r\n}\r\n}\r\nif (!display) {\r\nr = -EINVAL;\r\nbreak;\r\n}\r\nr = omapfb_set_def_mode(fbdev, display, mode_str);\r\nif (r)\r\nbreak;\r\n}\r\nkfree(str);\r\nreturn r;\r\n}\r\nstatic void fb_videomode_to_omap_timings(struct fb_videomode *m,\r\nstruct omap_dss_device *display,\r\nstruct omap_video_timings *t)\r\n{\r\nif (display->driver->get_timings) {\r\ndisplay->driver->get_timings(display, t);\r\n} else {\r\nt->data_pclk_edge = OMAPDSS_DRIVE_SIG_RISING_EDGE;\r\nt->de_level = OMAPDSS_SIG_ACTIVE_HIGH;\r\nt->sync_pclk_edge = OMAPDSS_DRIVE_SIG_OPPOSITE_EDGES;\r\n}\r\nt->x_res = m->xres;\r\nt->y_res = m->yres;\r\nt->pixel_clock = PICOS2KHZ(m->pixclock);\r\nt->hsw = m->hsync_len;\r\nt->hfp = m->right_margin;\r\nt->hbp = m->left_margin;\r\nt->vsw = m->vsync_len;\r\nt->vfp = m->lower_margin;\r\nt->vbp = m->upper_margin;\r\nt->hsync_level = m->sync & FB_SYNC_HOR_HIGH_ACT ?\r\nOMAPDSS_SIG_ACTIVE_HIGH :\r\nOMAPDSS_SIG_ACTIVE_LOW;\r\nt->vsync_level = m->sync & FB_SYNC_VERT_HIGH_ACT ?\r\nOMAPDSS_SIG_ACTIVE_HIGH :\r\nOMAPDSS_SIG_ACTIVE_LOW;\r\nt->interlace = m->vmode & FB_VMODE_INTERLACED;\r\n}\r\nstatic int omapfb_find_best_mode(struct omap_dss_device *display,\r\nstruct omap_video_timings *timings)\r\n{\r\nstruct fb_monspecs *specs;\r\nu8 *edid;\r\nint r, i, best_idx, len;\r\nif (!display->driver->read_edid)\r\nreturn -ENODEV;\r\nlen = 0x80 * 2;\r\nedid = kmalloc(len, GFP_KERNEL);\r\nif (edid == NULL)\r\nreturn -ENOMEM;\r\nr = display->driver->read_edid(display, edid, len);\r\nif (r < 0)\r\ngoto err1;\r\nspecs = kzalloc(sizeof(*specs), GFP_KERNEL);\r\nif (specs == NULL) {\r\nr = -ENOMEM;\r\ngoto err1;\r\n}\r\nfb_edid_to_monspecs(edid, specs);\r\nbest_idx = -1;\r\nfor (i = 0; i < specs->modedb_len; ++i) {\r\nstruct fb_videomode *m;\r\nstruct omap_video_timings t;\r\nm = &specs->modedb[i];\r\nif (m->pixclock == 0)\r\ncontinue;\r\nif (m->xres == 2880 || m->xres == 1440)\r\ncontinue;\r\nif (m->vmode & FB_VMODE_INTERLACED ||\r\nm->vmode & FB_VMODE_DOUBLE)\r\ncontinue;\r\nfb_videomode_to_omap_timings(m, display, &t);\r\nr = display->driver->check_timings(display, &t);\r\nif (r == 0) {\r\nbest_idx = i;\r\nbreak;\r\n}\r\n}\r\nif (best_idx == -1) {\r\nr = -ENOENT;\r\ngoto err2;\r\n}\r\nfb_videomode_to_omap_timings(&specs->modedb[best_idx], display,\r\ntimings);\r\nr = 0;\r\nerr2:\r\nfb_destroy_modedb(specs->modedb);\r\nkfree(specs);\r\nerr1:\r\nkfree(edid);\r\nreturn r;\r\n}\r\nstatic int omapfb_init_display(struct omapfb2_device *fbdev,\r\nstruct omap_dss_device *dssdev)\r\n{\r\nstruct omap_dss_driver *dssdrv = dssdev->driver;\r\nstruct omapfb_display_data *d;\r\nint r;\r\nr = dssdrv->enable(dssdev);\r\nif (r) {\r\ndev_warn(fbdev->dev, "Failed to enable display '%s'\n",\r\ndssdev->name);\r\nreturn r;\r\n}\r\nd = get_display_data(fbdev, dssdev);\r\nd->fbdev = fbdev;\r\nif (dssdev->caps & OMAP_DSS_DISPLAY_CAP_MANUAL_UPDATE) {\r\nu16 w, h;\r\nif (auto_update) {\r\nomapfb_start_auto_update(fbdev, dssdev);\r\nd->update_mode = OMAPFB_AUTO_UPDATE;\r\n} else {\r\nd->update_mode = OMAPFB_MANUAL_UPDATE;\r\n}\r\nif (dssdrv->enable_te) {\r\nr = dssdrv->enable_te(dssdev, 1);\r\nif (r) {\r\ndev_err(fbdev->dev, "Failed to set TE\n");\r\nreturn r;\r\n}\r\n}\r\ndssdrv->get_resolution(dssdev, &w, &h);\r\nr = dssdrv->update(dssdev, 0, 0, w, h);\r\nif (r) {\r\ndev_err(fbdev->dev,\r\n"Failed to update display\n");\r\nreturn r;\r\n}\r\n} else {\r\nd->update_mode = OMAPFB_AUTO_UPDATE;\r\n}\r\nreturn 0;\r\n}\r\nstatic int omapfb_init_connections(struct omapfb2_device *fbdev,\r\nstruct omap_dss_device *def_dssdev)\r\n{\r\nint i, r;\r\nstruct omap_overlay_manager *mgr;\r\nif (!def_dssdev->output) {\r\ndev_err(fbdev->dev, "no output for the default display\n");\r\nreturn -EINVAL;\r\n}\r\nfor (i = 0; i < fbdev->num_displays; ++i) {\r\nstruct omap_dss_device *dssdev = fbdev->displays[i].dssdev;\r\nstruct omap_dss_output *out = dssdev->output;\r\nmgr = omap_dss_get_overlay_manager(dssdev->channel);\r\nif (!mgr || !out)\r\ncontinue;\r\nif (mgr->output)\r\nmgr->unset_output(mgr);\r\nmgr->set_output(mgr, out);\r\n}\r\nmgr = def_dssdev->output->manager;\r\nif (!mgr) {\r\ndev_err(fbdev->dev, "no ovl manager for the default display\n");\r\nreturn -EINVAL;\r\n}\r\nfor (i = 0; i < fbdev->num_overlays; i++) {\r\nstruct omap_overlay *ovl = fbdev->overlays[i];\r\nif (ovl->manager)\r\novl->unset_manager(ovl);\r\nr = ovl->set_manager(ovl, mgr);\r\nif (r)\r\ndev_warn(fbdev->dev,\r\n"failed to connect overlay %s to manager %s\n",\r\novl->name, mgr->name);\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init omapfb_probe(struct platform_device *pdev)\r\n{\r\nstruct omapfb2_device *fbdev = NULL;\r\nint r = 0;\r\nint i;\r\nstruct omap_dss_device *def_display;\r\nstruct omap_dss_device *dssdev;\r\nDBG("omapfb_probe\n");\r\nif (pdev->num_resources != 0) {\r\ndev_err(&pdev->dev, "probed for an unknown device\n");\r\nr = -ENODEV;\r\ngoto err0;\r\n}\r\nfbdev = devm_kzalloc(&pdev->dev, sizeof(struct omapfb2_device),\r\nGFP_KERNEL);\r\nif (fbdev == NULL) {\r\nr = -ENOMEM;\r\ngoto err0;\r\n}\r\nif (def_vrfb && !omap_vrfb_supported()) {\r\ndef_vrfb = 0;\r\ndev_warn(&pdev->dev, "VRFB is not supported on this hardware, "\r\n"ignoring the module parameter vrfb=y\n");\r\n}\r\nr = omapdss_compat_init();\r\nif (r)\r\ngoto err0;\r\nmutex_init(&fbdev->mtx);\r\nfbdev->dev = &pdev->dev;\r\nplatform_set_drvdata(pdev, fbdev);\r\nfbdev->num_displays = 0;\r\ndssdev = NULL;\r\nfor_each_dss_dev(dssdev) {\r\nstruct omapfb_display_data *d;\r\nomap_dss_get_device(dssdev);\r\nif (!dssdev->driver) {\r\ndev_warn(&pdev->dev, "no driver for display: %s\n",\r\ndssdev->name);\r\nomap_dss_put_device(dssdev);\r\ncontinue;\r\n}\r\nd = &fbdev->displays[fbdev->num_displays++];\r\nd->dssdev = dssdev;\r\nif (dssdev->caps & OMAP_DSS_DISPLAY_CAP_MANUAL_UPDATE)\r\nd->update_mode = OMAPFB_MANUAL_UPDATE;\r\nelse\r\nd->update_mode = OMAPFB_AUTO_UPDATE;\r\n}\r\nif (fbdev->num_displays == 0) {\r\ndev_err(&pdev->dev, "no displays\n");\r\nr = -EINVAL;\r\ngoto cleanup;\r\n}\r\nfbdev->num_overlays = omap_dss_get_num_overlays();\r\nfor (i = 0; i < fbdev->num_overlays; i++)\r\nfbdev->overlays[i] = omap_dss_get_overlay(i);\r\nfbdev->num_managers = omap_dss_get_num_overlay_managers();\r\nfor (i = 0; i < fbdev->num_managers; i++)\r\nfbdev->managers[i] = omap_dss_get_overlay_manager(i);\r\ndef_display = NULL;\r\nfor (i = 0; i < fbdev->num_displays; ++i) {\r\nstruct omap_dss_device *dssdev;\r\nconst char *def_name;\r\ndef_name = omapdss_get_default_display_name();\r\ndssdev = fbdev->displays[i].dssdev;\r\nif (def_name == NULL ||\r\n(dssdev->name && strcmp(def_name, dssdev->name) == 0)) {\r\ndef_display = dssdev;\r\nbreak;\r\n}\r\n}\r\nif (def_display == NULL) {\r\ndev_err(fbdev->dev, "failed to find default display\n");\r\nr = -EINVAL;\r\ngoto cleanup;\r\n}\r\nr = omapfb_init_connections(fbdev, def_display);\r\nif (r) {\r\ndev_err(fbdev->dev, "failed to init overlay connections\n");\r\ngoto cleanup;\r\n}\r\nif (def_mode && strlen(def_mode) > 0) {\r\nif (omapfb_parse_def_modes(fbdev))\r\ndev_warn(&pdev->dev, "cannot parse default modes\n");\r\n} else if (def_display && def_display->driver->set_timings &&\r\ndef_display->driver->check_timings) {\r\nstruct omap_video_timings t;\r\nr = omapfb_find_best_mode(def_display, &t);\r\nif (r == 0)\r\ndef_display->driver->set_timings(def_display, &t);\r\n}\r\nr = omapfb_create_framebuffers(fbdev);\r\nif (r)\r\ngoto cleanup;\r\nfor (i = 0; i < fbdev->num_managers; i++) {\r\nstruct omap_overlay_manager *mgr;\r\nmgr = fbdev->managers[i];\r\nr = mgr->apply(mgr);\r\nif (r)\r\ndev_warn(fbdev->dev, "failed to apply dispc config\n");\r\n}\r\nDBG("mgr->apply'ed\n");\r\nif (def_display) {\r\nr = omapfb_init_display(fbdev, def_display);\r\nif (r) {\r\ndev_err(fbdev->dev,\r\n"failed to initialize default "\r\n"display\n");\r\ngoto cleanup;\r\n}\r\n}\r\nDBG("create sysfs for fbs\n");\r\nr = omapfb_create_sysfs(fbdev);\r\nif (r) {\r\ndev_err(fbdev->dev, "failed to create sysfs entries\n");\r\ngoto cleanup;\r\n}\r\nreturn 0;\r\ncleanup:\r\nomapfb_free_resources(fbdev);\r\nomapdss_compat_uninit();\r\nerr0:\r\ndev_err(&pdev->dev, "failed to setup omapfb\n");\r\nreturn r;\r\n}\r\nstatic int __exit omapfb_remove(struct platform_device *pdev)\r\n{\r\nstruct omapfb2_device *fbdev = platform_get_drvdata(pdev);\r\nomapfb_remove_sysfs(fbdev);\r\nomapfb_free_resources(fbdev);\r\nomapdss_compat_uninit();\r\nreturn 0;\r\n}\r\nstatic int __init omapfb_init(void)\r\n{\r\nDBG("omapfb_init\n");\r\nif (platform_driver_probe(&omapfb_driver, omapfb_probe)) {\r\nprintk(KERN_ERR "failed to register omapfb driver\n");\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\n}\r\nstatic void __exit omapfb_exit(void)\r\n{\r\nDBG("omapfb_exit\n");\r\nplatform_driver_unregister(&omapfb_driver);\r\n}
