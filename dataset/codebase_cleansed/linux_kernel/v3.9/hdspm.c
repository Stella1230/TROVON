static inline int HDSPM_bit2freq(int n)\r\n{\r\nstatic const int bit2freq_tab[] = {\r\n0, 32000, 44100, 48000, 64000, 88200,\r\n96000, 128000, 176400, 192000 };\r\nif (n < 1 || n > 9)\r\nreturn 0;\r\nreturn bit2freq_tab[n];\r\n}\r\nstatic inline void hdspm_write(struct hdspm * hdspm, unsigned int reg,\r\nunsigned int val)\r\n{\r\nwritel(val, hdspm->iobase + reg);\r\n}\r\nstatic inline unsigned int hdspm_read(struct hdspm * hdspm, unsigned int reg)\r\n{\r\nreturn readl(hdspm->iobase + reg);\r\n}\r\nstatic inline int hdspm_read_in_gain(struct hdspm * hdspm, unsigned int chan,\r\nunsigned int in)\r\n{\r\nif (chan >= HDSPM_MIXER_CHANNELS || in >= HDSPM_MIXER_CHANNELS)\r\nreturn 0;\r\nreturn hdspm->mixer->ch[chan].in[in];\r\n}\r\nstatic inline int hdspm_read_pb_gain(struct hdspm * hdspm, unsigned int chan,\r\nunsigned int pb)\r\n{\r\nif (chan >= HDSPM_MIXER_CHANNELS || pb >= HDSPM_MIXER_CHANNELS)\r\nreturn 0;\r\nreturn hdspm->mixer->ch[chan].pb[pb];\r\n}\r\nstatic int hdspm_write_in_gain(struct hdspm *hdspm, unsigned int chan,\r\nunsigned int in, unsigned short data)\r\n{\r\nif (chan >= HDSPM_MIXER_CHANNELS || in >= HDSPM_MIXER_CHANNELS)\r\nreturn -1;\r\nhdspm_write(hdspm,\r\nHDSPM_MADI_mixerBase +\r\n((in + 128 * chan) * sizeof(u32)),\r\n(hdspm->mixer->ch[chan].in[in] = data & 0xFFFF));\r\nreturn 0;\r\n}\r\nstatic int hdspm_write_pb_gain(struct hdspm *hdspm, unsigned int chan,\r\nunsigned int pb, unsigned short data)\r\n{\r\nif (chan >= HDSPM_MIXER_CHANNELS || pb >= HDSPM_MIXER_CHANNELS)\r\nreturn -1;\r\nhdspm_write(hdspm,\r\nHDSPM_MADI_mixerBase +\r\n((64 + pb + 128 * chan) * sizeof(u32)),\r\n(hdspm->mixer->ch[chan].pb[pb] = data & 0xFFFF));\r\nreturn 0;\r\n}\r\nstatic inline void snd_hdspm_enable_in(struct hdspm * hdspm, int i, int v)\r\n{\r\nhdspm_write(hdspm, HDSPM_inputEnableBase + (4 * i), v);\r\n}\r\nstatic inline void snd_hdspm_enable_out(struct hdspm * hdspm, int i, int v)\r\n{\r\nhdspm_write(hdspm, HDSPM_outputEnableBase + (4 * i), v);\r\n}\r\nstatic int snd_hdspm_use_is_exclusive(struct hdspm *hdspm)\r\n{\r\nunsigned long flags;\r\nint ret = 1;\r\nspin_lock_irqsave(&hdspm->lock, flags);\r\nif ((hdspm->playback_pid != hdspm->capture_pid) &&\r\n(hdspm->playback_pid >= 0) && (hdspm->capture_pid >= 0)) {\r\nret = 0;\r\n}\r\nspin_unlock_irqrestore(&hdspm->lock, flags);\r\nreturn ret;\r\n}\r\nstatic int hdspm_external_sample_rate(struct hdspm *hdspm)\r\n{\r\nunsigned int status, status2, timecode;\r\nint syncref, rate = 0, rate_bits;\r\nswitch (hdspm->io_type) {\r\ncase AES32:\r\nstatus2 = hdspm_read(hdspm, HDSPM_statusRegister2);\r\nstatus = hdspm_read(hdspm, HDSPM_statusRegister);\r\ntimecode = hdspm_read(hdspm, HDSPM_timecodeRegister);\r\nsyncref = hdspm_autosync_ref(hdspm);\r\nif (syncref == HDSPM_AES32_AUTOSYNC_FROM_WORD &&\r\nstatus & HDSPM_AES32_wcLock)\r\nreturn HDSPM_bit2freq((status >> HDSPM_AES32_wcFreq_bit) & 0xF);\r\nif (syncref >= HDSPM_AES32_AUTOSYNC_FROM_AES1 &&\r\nsyncref <= HDSPM_AES32_AUTOSYNC_FROM_AES8 &&\r\nstatus2 & (HDSPM_LockAES >>\r\n(syncref - HDSPM_AES32_AUTOSYNC_FROM_AES1)))\r\nreturn HDSPM_bit2freq((timecode >> (4*(syncref-HDSPM_AES32_AUTOSYNC_FROM_AES1))) & 0xF);\r\nreturn 0;\r\nbreak;\r\ncase MADIface:\r\nstatus = hdspm_read(hdspm, HDSPM_statusRegister);\r\nif (!(status & HDSPM_madiLock)) {\r\nrate = 0;\r\n} else {\r\nswitch (status & (HDSPM_status1_freqMask)) {\r\ncase HDSPM_status1_F_0*1:\r\nrate = 32000; break;\r\ncase HDSPM_status1_F_0*2:\r\nrate = 44100; break;\r\ncase HDSPM_status1_F_0*3:\r\nrate = 48000; break;\r\ncase HDSPM_status1_F_0*4:\r\nrate = 64000; break;\r\ncase HDSPM_status1_F_0*5:\r\nrate = 88200; break;\r\ncase HDSPM_status1_F_0*6:\r\nrate = 96000; break;\r\ncase HDSPM_status1_F_0*7:\r\nrate = 128000; break;\r\ncase HDSPM_status1_F_0*8:\r\nrate = 176400; break;\r\ncase HDSPM_status1_F_0*9:\r\nrate = 192000; break;\r\ndefault:\r\nrate = 0; break;\r\n}\r\n}\r\nbreak;\r\ncase MADI:\r\ncase AIO:\r\ncase RayDAT:\r\nstatus2 = hdspm_read(hdspm, HDSPM_statusRegister2);\r\nstatus = hdspm_read(hdspm, HDSPM_statusRegister);\r\nrate = 0;\r\nif ((status2 & HDSPM_wcLock) != 0 &&\r\n(status2 & HDSPM_SelSyncRef0) == 0) {\r\nrate_bits = status2 & HDSPM_wcFreqMask;\r\nswitch (rate_bits) {\r\ncase HDSPM_wcFreq32:\r\nrate = 32000;\r\nbreak;\r\ncase HDSPM_wcFreq44_1:\r\nrate = 44100;\r\nbreak;\r\ncase HDSPM_wcFreq48:\r\nrate = 48000;\r\nbreak;\r\ncase HDSPM_wcFreq64:\r\nrate = 64000;\r\nbreak;\r\ncase HDSPM_wcFreq88_2:\r\nrate = 88200;\r\nbreak;\r\ncase HDSPM_wcFreq96:\r\nrate = 96000;\r\nbreak;\r\ndefault:\r\nrate = 0;\r\nbreak;\r\n}\r\n}\r\nif (rate != 0 &&\r\n(status2 & HDSPM_SelSyncRefMask) == HDSPM_SelSyncRef_WORD)\r\nreturn rate;\r\nif (status & HDSPM_madiLock) {\r\nrate_bits = status & HDSPM_madiFreqMask;\r\nswitch (rate_bits) {\r\ncase HDSPM_madiFreq32:\r\nrate = 32000;\r\nbreak;\r\ncase HDSPM_madiFreq44_1:\r\nrate = 44100;\r\nbreak;\r\ncase HDSPM_madiFreq48:\r\nrate = 48000;\r\nbreak;\r\ncase HDSPM_madiFreq64:\r\nrate = 64000;\r\nbreak;\r\ncase HDSPM_madiFreq88_2:\r\nrate = 88200;\r\nbreak;\r\ncase HDSPM_madiFreq96:\r\nrate = 96000;\r\nbreak;\r\ncase HDSPM_madiFreq128:\r\nrate = 128000;\r\nbreak;\r\ncase HDSPM_madiFreq176_4:\r\nrate = 176400;\r\nbreak;\r\ncase HDSPM_madiFreq192:\r\nrate = 192000;\r\nbreak;\r\ndefault:\r\nrate = 0;\r\nbreak;\r\n}\r\nif (rate <= 48000) {\r\nif (hdspm->control_register & HDSPM_QuadSpeed)\r\nrate *= 4;\r\nelse if (hdspm->control_register &\r\nHDSPM_DoubleSpeed)\r\nrate *= 2;\r\n}\r\n}\r\nbreak;\r\n}\r\nreturn rate;\r\n}\r\nstatic int hdspm_get_latency(struct hdspm *hdspm)\r\n{\r\nint n;\r\nn = hdspm_decode_latency(hdspm->control_register);\r\nif ((7 == n) && (RayDAT == hdspm->io_type || AIO == hdspm->io_type))\r\nn = -1;\r\nreturn 1 << (n + 6);\r\n}\r\nstatic inline void hdspm_compute_period_size(struct hdspm *hdspm)\r\n{\r\nhdspm->period_bytes = 4 * hdspm_get_latency(hdspm);\r\n}\r\nstatic snd_pcm_uframes_t hdspm_hw_pointer(struct hdspm *hdspm)\r\n{\r\nint position;\r\nposition = hdspm_read(hdspm, HDSPM_statusRegister);\r\nswitch (hdspm->io_type) {\r\ncase RayDAT:\r\ncase AIO:\r\nposition &= HDSPM_BufferPositionMask;\r\nposition /= 4;\r\nbreak;\r\ndefault:\r\nposition = (position & HDSPM_BufferID) ?\r\n(hdspm->period_bytes / 4) : 0;\r\n}\r\nreturn position;\r\n}\r\nstatic inline void hdspm_start_audio(struct hdspm * s)\r\n{\r\ns->control_register |= (HDSPM_AudioInterruptEnable | HDSPM_Start);\r\nhdspm_write(s, HDSPM_controlRegister, s->control_register);\r\n}\r\nstatic inline void hdspm_stop_audio(struct hdspm * s)\r\n{\r\ns->control_register &= ~(HDSPM_Start | HDSPM_AudioInterruptEnable);\r\nhdspm_write(s, HDSPM_controlRegister, s->control_register);\r\n}\r\nstatic void hdspm_silence_playback(struct hdspm *hdspm)\r\n{\r\nint i;\r\nint n = hdspm->period_bytes;\r\nvoid *buf = hdspm->playback_buffer;\r\nif (buf == NULL)\r\nreturn;\r\nfor (i = 0; i < HDSPM_MAX_CHANNELS; i++) {\r\nmemset(buf, 0, n);\r\nbuf += HDSPM_CHANNEL_BUFFER_BYTES;\r\n}\r\n}\r\nstatic int hdspm_set_interrupt_interval(struct hdspm *s, unsigned int frames)\r\n{\r\nint n;\r\nspin_lock_irq(&s->lock);\r\nif (32 == frames) {\r\nn = 7;\r\n} else {\r\nframes >>= 7;\r\nn = 0;\r\nwhile (frames) {\r\nn++;\r\nframes >>= 1;\r\n}\r\n}\r\ns->control_register &= ~HDSPM_LatencyMask;\r\ns->control_register |= hdspm_encode_latency(n);\r\nhdspm_write(s, HDSPM_controlRegister, s->control_register);\r\nhdspm_compute_period_size(s);\r\nspin_unlock_irq(&s->lock);\r\nreturn 0;\r\n}\r\nstatic u64 hdspm_calc_dds_value(struct hdspm *hdspm, u64 period)\r\n{\r\nu64 freq_const;\r\nif (period == 0)\r\nreturn 0;\r\nswitch (hdspm->io_type) {\r\ncase MADI:\r\ncase AES32:\r\nfreq_const = 110069313433624ULL;\r\nbreak;\r\ncase RayDAT:\r\ncase AIO:\r\nfreq_const = 104857600000000ULL;\r\nbreak;\r\ncase MADIface:\r\nfreq_const = 131072000000000ULL;\r\nbreak;\r\ndefault:\r\nsnd_BUG();\r\nreturn 0;\r\n}\r\nreturn div_u64(freq_const, period);\r\n}\r\nstatic void hdspm_set_dds_value(struct hdspm *hdspm, int rate)\r\n{\r\nu64 n;\r\nif (rate >= 112000)\r\nrate /= 4;\r\nelse if (rate >= 56000)\r\nrate /= 2;\r\nswitch (hdspm->io_type) {\r\ncase MADIface:\r\nn = 131072000000000ULL;\r\nbreak;\r\ncase MADI:\r\ncase AES32:\r\nn = 110069313433624ULL;\r\nbreak;\r\ncase RayDAT:\r\ncase AIO:\r\nn = 104857600000000ULL;\r\nbreak;\r\ndefault:\r\nsnd_BUG();\r\nreturn;\r\n}\r\nn = div_u64(n, rate);\r\nsnd_BUG_ON(n >> 32);\r\nhdspm_write(hdspm, HDSPM_freqReg, (u32)n);\r\n}\r\nstatic int hdspm_set_rate(struct hdspm * hdspm, int rate, int called_internally)\r\n{\r\nint current_rate;\r\nint rate_bits;\r\nint not_set = 0;\r\nint current_speed, target_speed;\r\nif (!(hdspm->control_register & HDSPM_ClockModeMaster)) {\r\nif (called_internally) {\r\nsnd_printk(KERN_WARNING "HDSPM: "\r\n"Warning: device is not running "\r\n"as a clock master.\n");\r\nnot_set = 1;\r\n} else {\r\nint external_freq =\r\nhdspm_external_sample_rate(hdspm);\r\nif (hdspm_autosync_ref(hdspm) ==\r\nHDSPM_AUTOSYNC_FROM_NONE) {\r\nsnd_printk(KERN_WARNING "HDSPM: "\r\n"Detected no Externel Sync \n");\r\nnot_set = 1;\r\n} else if (rate != external_freq) {\r\nsnd_printk(KERN_WARNING "HDSPM: "\r\n"Warning: No AutoSync source for "\r\n"requested rate\n");\r\nnot_set = 1;\r\n}\r\n}\r\n}\r\ncurrent_rate = hdspm->system_sample_rate;\r\nif (current_rate <= 48000)\r\ncurrent_speed = HDSPM_SPEED_SINGLE;\r\nelse if (current_rate <= 96000)\r\ncurrent_speed = HDSPM_SPEED_DOUBLE;\r\nelse\r\ncurrent_speed = HDSPM_SPEED_QUAD;\r\nif (rate <= 48000)\r\ntarget_speed = HDSPM_SPEED_SINGLE;\r\nelse if (rate <= 96000)\r\ntarget_speed = HDSPM_SPEED_DOUBLE;\r\nelse\r\ntarget_speed = HDSPM_SPEED_QUAD;\r\nswitch (rate) {\r\ncase 32000:\r\nrate_bits = HDSPM_Frequency32KHz;\r\nbreak;\r\ncase 44100:\r\nrate_bits = HDSPM_Frequency44_1KHz;\r\nbreak;\r\ncase 48000:\r\nrate_bits = HDSPM_Frequency48KHz;\r\nbreak;\r\ncase 64000:\r\nrate_bits = HDSPM_Frequency64KHz;\r\nbreak;\r\ncase 88200:\r\nrate_bits = HDSPM_Frequency88_2KHz;\r\nbreak;\r\ncase 96000:\r\nrate_bits = HDSPM_Frequency96KHz;\r\nbreak;\r\ncase 128000:\r\nrate_bits = HDSPM_Frequency128KHz;\r\nbreak;\r\ncase 176400:\r\nrate_bits = HDSPM_Frequency176_4KHz;\r\nbreak;\r\ncase 192000:\r\nrate_bits = HDSPM_Frequency192KHz;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (current_speed != target_speed\r\n&& (hdspm->capture_pid >= 0 || hdspm->playback_pid >= 0)) {\r\nsnd_printk\r\n(KERN_ERR "HDSPM: "\r\n"cannot change from %s speed to %s speed mode "\r\n"(capture PID = %d, playback PID = %d)\n",\r\nhdspm_speed_names[current_speed],\r\nhdspm_speed_names[target_speed],\r\nhdspm->capture_pid, hdspm->playback_pid);\r\nreturn -EBUSY;\r\n}\r\nhdspm->control_register &= ~HDSPM_FrequencyMask;\r\nhdspm->control_register |= rate_bits;\r\nhdspm_write(hdspm, HDSPM_controlRegister, hdspm->control_register);\r\nhdspm_set_dds_value(hdspm, rate);\r\nif (AES32 == hdspm->io_type && rate != current_rate)\r\nhdspm_write(hdspm, HDSPM_eeprom_wr, 0);\r\nhdspm->system_sample_rate = rate;\r\nif (rate <= 48000) {\r\nhdspm->channel_map_in = hdspm->channel_map_in_ss;\r\nhdspm->channel_map_out = hdspm->channel_map_out_ss;\r\nhdspm->max_channels_in = hdspm->ss_in_channels;\r\nhdspm->max_channels_out = hdspm->ss_out_channels;\r\nhdspm->port_names_in = hdspm->port_names_in_ss;\r\nhdspm->port_names_out = hdspm->port_names_out_ss;\r\n} else if (rate <= 96000) {\r\nhdspm->channel_map_in = hdspm->channel_map_in_ds;\r\nhdspm->channel_map_out = hdspm->channel_map_out_ds;\r\nhdspm->max_channels_in = hdspm->ds_in_channels;\r\nhdspm->max_channels_out = hdspm->ds_out_channels;\r\nhdspm->port_names_in = hdspm->port_names_in_ds;\r\nhdspm->port_names_out = hdspm->port_names_out_ds;\r\n} else {\r\nhdspm->channel_map_in = hdspm->channel_map_in_qs;\r\nhdspm->channel_map_out = hdspm->channel_map_out_qs;\r\nhdspm->max_channels_in = hdspm->qs_in_channels;\r\nhdspm->max_channels_out = hdspm->qs_out_channels;\r\nhdspm->port_names_in = hdspm->port_names_in_qs;\r\nhdspm->port_names_out = hdspm->port_names_out_qs;\r\n}\r\nif (not_set != 0)\r\nreturn -1;\r\nreturn 0;\r\n}\r\nstatic void all_in_all_mixer(struct hdspm * hdspm, int sgain)\r\n{\r\nint i, j;\r\nunsigned int gain;\r\nif (sgain > UNITY_GAIN)\r\ngain = UNITY_GAIN;\r\nelse if (sgain < 0)\r\ngain = 0;\r\nelse\r\ngain = sgain;\r\nfor (i = 0; i < HDSPM_MIXER_CHANNELS; i++)\r\nfor (j = 0; j < HDSPM_MIXER_CHANNELS; j++) {\r\nhdspm_write_in_gain(hdspm, i, j, gain);\r\nhdspm_write_pb_gain(hdspm, i, j, gain);\r\n}\r\n}\r\nstatic inline unsigned char snd_hdspm_midi_read_byte (struct hdspm *hdspm,\r\nint id)\r\n{\r\nreturn hdspm_read(hdspm, hdspm->midi[id].dataIn);\r\n}\r\nstatic inline void snd_hdspm_midi_write_byte (struct hdspm *hdspm, int id,\r\nint val)\r\n{\r\nreturn hdspm_write(hdspm, hdspm->midi[id].dataOut, val);\r\n}\r\nstatic inline int snd_hdspm_midi_input_available (struct hdspm *hdspm, int id)\r\n{\r\nreturn hdspm_read(hdspm, hdspm->midi[id].statusIn) & 0xFF;\r\n}\r\nstatic inline int snd_hdspm_midi_output_possible (struct hdspm *hdspm, int id)\r\n{\r\nint fifo_bytes_used;\r\nfifo_bytes_used = hdspm_read(hdspm, hdspm->midi[id].statusOut) & 0xFF;\r\nif (fifo_bytes_used < 128)\r\nreturn 128 - fifo_bytes_used;\r\nelse\r\nreturn 0;\r\n}\r\nstatic void snd_hdspm_flush_midi_input(struct hdspm *hdspm, int id)\r\n{\r\nwhile (snd_hdspm_midi_input_available (hdspm, id))\r\nsnd_hdspm_midi_read_byte (hdspm, id);\r\n}\r\nstatic int snd_hdspm_midi_output_write (struct hdspm_midi *hmidi)\r\n{\r\nunsigned long flags;\r\nint n_pending;\r\nint to_write;\r\nint i;\r\nunsigned char buf[128];\r\nspin_lock_irqsave (&hmidi->lock, flags);\r\nif (hmidi->output &&\r\n!snd_rawmidi_transmit_empty (hmidi->output)) {\r\nn_pending = snd_hdspm_midi_output_possible (hmidi->hdspm,\r\nhmidi->id);\r\nif (n_pending > 0) {\r\nif (n_pending > (int)sizeof (buf))\r\nn_pending = sizeof (buf);\r\nto_write = snd_rawmidi_transmit (hmidi->output, buf,\r\nn_pending);\r\nif (to_write > 0) {\r\nfor (i = 0; i < to_write; ++i)\r\nsnd_hdspm_midi_write_byte (hmidi->hdspm,\r\nhmidi->id,\r\nbuf[i]);\r\n}\r\n}\r\n}\r\nspin_unlock_irqrestore (&hmidi->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int snd_hdspm_midi_input_read (struct hdspm_midi *hmidi)\r\n{\r\nunsigned char buf[128];\r\nunsigned long flags;\r\nint n_pending;\r\nint i;\r\nspin_lock_irqsave (&hmidi->lock, flags);\r\nn_pending = snd_hdspm_midi_input_available (hmidi->hdspm, hmidi->id);\r\nif (n_pending > 0) {\r\nif (hmidi->input) {\r\nif (n_pending > (int)sizeof (buf))\r\nn_pending = sizeof (buf);\r\nfor (i = 0; i < n_pending; ++i)\r\nbuf[i] = snd_hdspm_midi_read_byte (hmidi->hdspm,\r\nhmidi->id);\r\nif (n_pending)\r\nsnd_rawmidi_receive (hmidi->input, buf,\r\nn_pending);\r\n} else {\r\nwhile (n_pending--)\r\nsnd_hdspm_midi_read_byte (hmidi->hdspm,\r\nhmidi->id);\r\n}\r\n}\r\nhmidi->pending = 0;\r\nspin_unlock_irqrestore(&hmidi->lock, flags);\r\nspin_lock_irqsave(&hmidi->hdspm->lock, flags);\r\nhmidi->hdspm->control_register |= hmidi->ie;\r\nhdspm_write(hmidi->hdspm, HDSPM_controlRegister,\r\nhmidi->hdspm->control_register);\r\nspin_unlock_irqrestore(&hmidi->hdspm->lock, flags);\r\nreturn snd_hdspm_midi_output_write (hmidi);\r\n}\r\nstatic void\r\nsnd_hdspm_midi_input_trigger(struct snd_rawmidi_substream *substream, int up)\r\n{\r\nstruct hdspm *hdspm;\r\nstruct hdspm_midi *hmidi;\r\nunsigned long flags;\r\nhmidi = substream->rmidi->private_data;\r\nhdspm = hmidi->hdspm;\r\nspin_lock_irqsave (&hdspm->lock, flags);\r\nif (up) {\r\nif (!(hdspm->control_register & hmidi->ie)) {\r\nsnd_hdspm_flush_midi_input (hdspm, hmidi->id);\r\nhdspm->control_register |= hmidi->ie;\r\n}\r\n} else {\r\nhdspm->control_register &= ~hmidi->ie;\r\n}\r\nhdspm_write(hdspm, HDSPM_controlRegister, hdspm->control_register);\r\nspin_unlock_irqrestore (&hdspm->lock, flags);\r\n}\r\nstatic void snd_hdspm_midi_output_timer(unsigned long data)\r\n{\r\nstruct hdspm_midi *hmidi = (struct hdspm_midi *) data;\r\nunsigned long flags;\r\nsnd_hdspm_midi_output_write(hmidi);\r\nspin_lock_irqsave (&hmidi->lock, flags);\r\nif (hmidi->istimer) {\r\nhmidi->timer.expires = 1 + jiffies;\r\nadd_timer(&hmidi->timer);\r\n}\r\nspin_unlock_irqrestore (&hmidi->lock, flags);\r\n}\r\nstatic void\r\nsnd_hdspm_midi_output_trigger(struct snd_rawmidi_substream *substream, int up)\r\n{\r\nstruct hdspm_midi *hmidi;\r\nunsigned long flags;\r\nhmidi = substream->rmidi->private_data;\r\nspin_lock_irqsave (&hmidi->lock, flags);\r\nif (up) {\r\nif (!hmidi->istimer) {\r\ninit_timer(&hmidi->timer);\r\nhmidi->timer.function = snd_hdspm_midi_output_timer;\r\nhmidi->timer.data = (unsigned long) hmidi;\r\nhmidi->timer.expires = 1 + jiffies;\r\nadd_timer(&hmidi->timer);\r\nhmidi->istimer++;\r\n}\r\n} else {\r\nif (hmidi->istimer && --hmidi->istimer <= 0)\r\ndel_timer (&hmidi->timer);\r\n}\r\nspin_unlock_irqrestore (&hmidi->lock, flags);\r\nif (up)\r\nsnd_hdspm_midi_output_write(hmidi);\r\n}\r\nstatic int snd_hdspm_midi_input_open(struct snd_rawmidi_substream *substream)\r\n{\r\nstruct hdspm_midi *hmidi;\r\nhmidi = substream->rmidi->private_data;\r\nspin_lock_irq (&hmidi->lock);\r\nsnd_hdspm_flush_midi_input (hmidi->hdspm, hmidi->id);\r\nhmidi->input = substream;\r\nspin_unlock_irq (&hmidi->lock);\r\nreturn 0;\r\n}\r\nstatic int snd_hdspm_midi_output_open(struct snd_rawmidi_substream *substream)\r\n{\r\nstruct hdspm_midi *hmidi;\r\nhmidi = substream->rmidi->private_data;\r\nspin_lock_irq (&hmidi->lock);\r\nhmidi->output = substream;\r\nspin_unlock_irq (&hmidi->lock);\r\nreturn 0;\r\n}\r\nstatic int snd_hdspm_midi_input_close(struct snd_rawmidi_substream *substream)\r\n{\r\nstruct hdspm_midi *hmidi;\r\nsnd_hdspm_midi_input_trigger (substream, 0);\r\nhmidi = substream->rmidi->private_data;\r\nspin_lock_irq (&hmidi->lock);\r\nhmidi->input = NULL;\r\nspin_unlock_irq (&hmidi->lock);\r\nreturn 0;\r\n}\r\nstatic int snd_hdspm_midi_output_close(struct snd_rawmidi_substream *substream)\r\n{\r\nstruct hdspm_midi *hmidi;\r\nsnd_hdspm_midi_output_trigger (substream, 0);\r\nhmidi = substream->rmidi->private_data;\r\nspin_lock_irq (&hmidi->lock);\r\nhmidi->output = NULL;\r\nspin_unlock_irq (&hmidi->lock);\r\nreturn 0;\r\n}\r\nstatic int snd_hdspm_create_midi(struct snd_card *card,\r\nstruct hdspm *hdspm, int id)\r\n{\r\nint err;\r\nchar buf[32];\r\nhdspm->midi[id].id = id;\r\nhdspm->midi[id].hdspm = hdspm;\r\nspin_lock_init (&hdspm->midi[id].lock);\r\nif (0 == id) {\r\nif (MADIface == hdspm->io_type) {\r\nhdspm->midi[0].dataIn = HDSPM_midiDataIn2;\r\nhdspm->midi[0].statusIn = HDSPM_midiStatusIn2;\r\nhdspm->midi[0].dataOut = HDSPM_midiDataOut2;\r\nhdspm->midi[0].statusOut = HDSPM_midiStatusOut2;\r\nhdspm->midi[0].ie = HDSPM_Midi2InterruptEnable;\r\nhdspm->midi[0].irq = HDSPM_midi2IRQPending;\r\n} else {\r\nhdspm->midi[0].dataIn = HDSPM_midiDataIn0;\r\nhdspm->midi[0].statusIn = HDSPM_midiStatusIn0;\r\nhdspm->midi[0].dataOut = HDSPM_midiDataOut0;\r\nhdspm->midi[0].statusOut = HDSPM_midiStatusOut0;\r\nhdspm->midi[0].ie = HDSPM_Midi0InterruptEnable;\r\nhdspm->midi[0].irq = HDSPM_midi0IRQPending;\r\n}\r\n} else if (1 == id) {\r\nhdspm->midi[1].dataIn = HDSPM_midiDataIn1;\r\nhdspm->midi[1].statusIn = HDSPM_midiStatusIn1;\r\nhdspm->midi[1].dataOut = HDSPM_midiDataOut1;\r\nhdspm->midi[1].statusOut = HDSPM_midiStatusOut1;\r\nhdspm->midi[1].ie = HDSPM_Midi1InterruptEnable;\r\nhdspm->midi[1].irq = HDSPM_midi1IRQPending;\r\n} else if ((2 == id) && (MADI == hdspm->io_type)) {\r\nhdspm->midi[2].dataIn = HDSPM_midiDataIn2;\r\nhdspm->midi[2].statusIn = HDSPM_midiStatusIn2;\r\nhdspm->midi[2].dataOut = HDSPM_midiDataOut2;\r\nhdspm->midi[2].statusOut = HDSPM_midiStatusOut2;\r\nhdspm->midi[2].ie = HDSPM_Midi2InterruptEnable;\r\nhdspm->midi[2].irq = HDSPM_midi2IRQPending;\r\n} else if (2 == id) {\r\nhdspm->midi[2].dataIn = HDSPM_midiDataIn2;\r\nhdspm->midi[2].statusIn = HDSPM_midiStatusIn2;\r\nhdspm->midi[2].dataOut = -1;\r\nhdspm->midi[2].statusOut = -1;\r\nhdspm->midi[2].ie = HDSPM_Midi2InterruptEnable;\r\nhdspm->midi[2].irq = HDSPM_midi2IRQPendingAES;\r\n} else if (3 == id) {\r\nhdspm->midi[3].dataIn = HDSPM_midiDataIn3;\r\nhdspm->midi[3].statusIn = HDSPM_midiStatusIn3;\r\nhdspm->midi[3].dataOut = -1;\r\nhdspm->midi[3].statusOut = -1;\r\nhdspm->midi[3].ie = HDSPM_Midi3InterruptEnable;\r\nhdspm->midi[3].irq = HDSPM_midi3IRQPending;\r\n}\r\nif ((id < 2) || ((2 == id) && ((MADI == hdspm->io_type) ||\r\n(MADIface == hdspm->io_type)))) {\r\nif ((id == 0) && (MADIface == hdspm->io_type)) {\r\nsprintf(buf, "%s MIDIoverMADI", card->shortname);\r\n} else if ((id == 2) && (MADI == hdspm->io_type)) {\r\nsprintf(buf, "%s MIDIoverMADI", card->shortname);\r\n} else {\r\nsprintf(buf, "%s MIDI %d", card->shortname, id+1);\r\n}\r\nerr = snd_rawmidi_new(card, buf, id, 1, 1,\r\n&hdspm->midi[id].rmidi);\r\nif (err < 0)\r\nreturn err;\r\nsprintf(hdspm->midi[id].rmidi->name, "%s MIDI %d",\r\ncard->id, id+1);\r\nhdspm->midi[id].rmidi->private_data = &hdspm->midi[id];\r\nsnd_rawmidi_set_ops(hdspm->midi[id].rmidi,\r\nSNDRV_RAWMIDI_STREAM_OUTPUT,\r\n&snd_hdspm_midi_output);\r\nsnd_rawmidi_set_ops(hdspm->midi[id].rmidi,\r\nSNDRV_RAWMIDI_STREAM_INPUT,\r\n&snd_hdspm_midi_input);\r\nhdspm->midi[id].rmidi->info_flags |=\r\nSNDRV_RAWMIDI_INFO_OUTPUT |\r\nSNDRV_RAWMIDI_INFO_INPUT |\r\nSNDRV_RAWMIDI_INFO_DUPLEX;\r\n} else {\r\nsprintf(buf, "%s MTC %d", card->shortname, id+1);\r\nerr = snd_rawmidi_new(card, buf, id, 1, 1,\r\n&hdspm->midi[id].rmidi);\r\nif (err < 0)\r\nreturn err;\r\nsprintf(hdspm->midi[id].rmidi->name,\r\n"%s MTC %d", card->id, id+1);\r\nhdspm->midi[id].rmidi->private_data = &hdspm->midi[id];\r\nsnd_rawmidi_set_ops(hdspm->midi[id].rmidi,\r\nSNDRV_RAWMIDI_STREAM_INPUT,\r\n&snd_hdspm_midi_input);\r\nhdspm->midi[id].rmidi->info_flags |= SNDRV_RAWMIDI_INFO_INPUT;\r\n}\r\nreturn 0;\r\n}\r\nstatic void hdspm_midi_tasklet(unsigned long arg)\r\n{\r\nstruct hdspm *hdspm = (struct hdspm *)arg;\r\nint i = 0;\r\nwhile (i < hdspm->midiPorts) {\r\nif (hdspm->midi[i].pending)\r\nsnd_hdspm_midi_input_read(&hdspm->midi[i]);\r\ni++;\r\n}\r\n}\r\nstatic int hdspm_get_system_sample_rate(struct hdspm *hdspm)\r\n{\r\nunsigned int period, rate;\r\nperiod = hdspm_read(hdspm, HDSPM_RD_PLL_FREQ);\r\nrate = hdspm_calc_dds_value(hdspm, period);\r\nif (rate > 207000) {\r\nif (0 == hdspm_system_clock_mode(hdspm)) {\r\nrate = hdspm->system_sample_rate;\r\n} else {\r\nrate = hdspm_external_sample_rate(hdspm);\r\n}\r\n}\r\nreturn rate;\r\n}\r\nstatic int snd_hdspm_info_system_sample_rate(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\r\nuinfo->count = 1;\r\nuinfo->value.integer.min = 27000;\r\nuinfo->value.integer.max = 207000;\r\nuinfo->value.integer.step = 1;\r\nreturn 0;\r\n}\r\nstatic int snd_hdspm_get_system_sample_rate(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *\r\nucontrol)\r\n{\r\nstruct hdspm *hdspm = snd_kcontrol_chip(kcontrol);\r\nucontrol->value.integer.value[0] = hdspm_get_system_sample_rate(hdspm);\r\nreturn 0;\r\n}\r\nstatic int snd_hdspm_put_system_sample_rate(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *\r\nucontrol)\r\n{\r\nstruct hdspm *hdspm = snd_kcontrol_chip(kcontrol);\r\nhdspm_set_dds_value(hdspm, ucontrol->value.enumerated.item[0]);\r\nreturn 0;\r\n}\r\nstatic int hdspm_get_wc_sample_rate(struct hdspm *hdspm)\r\n{\r\nint status;\r\nswitch (hdspm->io_type) {\r\ncase RayDAT:\r\ncase AIO:\r\nstatus = hdspm_read(hdspm, HDSPM_RD_STATUS_1);\r\nreturn (status >> 16) & 0xF;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int hdspm_get_tco_sample_rate(struct hdspm *hdspm)\r\n{\r\nint status;\r\nif (hdspm->tco) {\r\nswitch (hdspm->io_type) {\r\ncase RayDAT:\r\ncase AIO:\r\nstatus = hdspm_read(hdspm, HDSPM_RD_STATUS_1);\r\nreturn (status >> 20) & 0xF;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int hdspm_get_sync_in_sample_rate(struct hdspm *hdspm)\r\n{\r\nint status;\r\nif (hdspm->tco) {\r\nswitch (hdspm->io_type) {\r\ncase RayDAT:\r\ncase AIO:\r\nstatus = hdspm_read(hdspm, HDSPM_RD_STATUS_2);\r\nreturn (status >> 12) & 0xF;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int hdspm_get_s1_sample_rate(struct hdspm *hdspm, unsigned int idx)\r\n{\r\nint status = hdspm_read(hdspm, HDSPM_RD_STATUS_2);\r\nreturn (status >> (idx*4)) & 0xF;\r\n}\r\nstatic int snd_hdspm_info_autosync_sample_rate(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;\r\nuinfo->count = 1;\r\nuinfo->value.enumerated.items = 10;\r\nif (uinfo->value.enumerated.item >= uinfo->value.enumerated.items)\r\nuinfo->value.enumerated.item = uinfo->value.enumerated.items - 1;\r\nstrcpy(uinfo->value.enumerated.name,\r\ntexts_freq[uinfo->value.enumerated.item]);\r\nreturn 0;\r\n}\r\nstatic int snd_hdspm_get_autosync_sample_rate(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *\r\nucontrol)\r\n{\r\nstruct hdspm *hdspm = snd_kcontrol_chip(kcontrol);\r\nswitch (hdspm->io_type) {\r\ncase RayDAT:\r\nswitch (kcontrol->private_value) {\r\ncase 0:\r\nucontrol->value.enumerated.item[0] =\r\nhdspm_get_wc_sample_rate(hdspm);\r\nbreak;\r\ncase 7:\r\nucontrol->value.enumerated.item[0] =\r\nhdspm_get_tco_sample_rate(hdspm);\r\nbreak;\r\ncase 8:\r\nucontrol->value.enumerated.item[0] =\r\nhdspm_get_sync_in_sample_rate(hdspm);\r\nbreak;\r\ndefault:\r\nucontrol->value.enumerated.item[0] =\r\nhdspm_get_s1_sample_rate(hdspm,\r\nkcontrol->private_value-1);\r\n}\r\nbreak;\r\ncase AIO:\r\nswitch (kcontrol->private_value) {\r\ncase 0:\r\nucontrol->value.enumerated.item[0] =\r\nhdspm_get_wc_sample_rate(hdspm);\r\nbreak;\r\ncase 4:\r\nucontrol->value.enumerated.item[0] =\r\nhdspm_get_tco_sample_rate(hdspm);\r\nbreak;\r\ncase 5:\r\nucontrol->value.enumerated.item[0] =\r\nhdspm_get_sync_in_sample_rate(hdspm);\r\nbreak;\r\ndefault:\r\nucontrol->value.enumerated.item[0] =\r\nhdspm_get_s1_sample_rate(hdspm,\r\nucontrol->id.index-1);\r\n}\r\nbreak;\r\ncase AES32:\r\nswitch (kcontrol->private_value) {\r\ncase 0:\r\nucontrol->value.enumerated.item[0] =\r\nhdspm_get_wc_sample_rate(hdspm);\r\nbreak;\r\ncase 9:\r\nucontrol->value.enumerated.item[0] =\r\nhdspm_get_tco_sample_rate(hdspm);\r\nbreak;\r\ncase 10:\r\nucontrol->value.enumerated.item[0] =\r\nhdspm_get_sync_in_sample_rate(hdspm);\r\nbreak;\r\ndefault:\r\nucontrol->value.enumerated.item[0] =\r\nhdspm_get_s1_sample_rate(hdspm,\r\nkcontrol->private_value-1);\r\nbreak;\r\n}\r\nbreak;\r\ncase MADI:\r\ncase MADIface:\r\n{\r\nint rate = hdspm_external_sample_rate(hdspm);\r\nint i, selected_rate = 0;\r\nfor (i = 1; i < 10; i++)\r\nif (HDSPM_bit2freq(i) == rate) {\r\nselected_rate = i;\r\nbreak;\r\n}\r\nucontrol->value.enumerated.item[0] = selected_rate;\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int hdspm_system_clock_mode(struct hdspm *hdspm)\r\n{\r\nswitch (hdspm->io_type) {\r\ncase AIO:\r\ncase RayDAT:\r\nif (hdspm->settings_register & HDSPM_c0Master)\r\nreturn 0;\r\nbreak;\r\ndefault:\r\nif (hdspm->control_register & HDSPM_ClockModeMaster)\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nstatic void hdspm_set_system_clock_mode(struct hdspm *hdspm, int mode)\r\n{\r\nswitch (hdspm->io_type) {\r\ncase AIO:\r\ncase RayDAT:\r\nif (0 == mode)\r\nhdspm->settings_register |= HDSPM_c0Master;\r\nelse\r\nhdspm->settings_register &= ~HDSPM_c0Master;\r\nhdspm_write(hdspm, HDSPM_WR_SETTINGS, hdspm->settings_register);\r\nbreak;\r\ndefault:\r\nif (0 == mode)\r\nhdspm->control_register |= HDSPM_ClockModeMaster;\r\nelse\r\nhdspm->control_register &= ~HDSPM_ClockModeMaster;\r\nhdspm_write(hdspm, HDSPM_controlRegister,\r\nhdspm->control_register);\r\n}\r\n}\r\nstatic int snd_hdspm_info_system_clock_mode(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nstatic char *texts[] = { "Master", "AutoSync" };\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;\r\nuinfo->count = 1;\r\nuinfo->value.enumerated.items = 2;\r\nif (uinfo->value.enumerated.item >= uinfo->value.enumerated.items)\r\nuinfo->value.enumerated.item =\r\nuinfo->value.enumerated.items - 1;\r\nstrcpy(uinfo->value.enumerated.name,\r\ntexts[uinfo->value.enumerated.item]);\r\nreturn 0;\r\n}\r\nstatic int snd_hdspm_get_system_clock_mode(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hdspm *hdspm = snd_kcontrol_chip(kcontrol);\r\nucontrol->value.enumerated.item[0] = hdspm_system_clock_mode(hdspm);\r\nreturn 0;\r\n}\r\nstatic int snd_hdspm_put_system_clock_mode(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hdspm *hdspm = snd_kcontrol_chip(kcontrol);\r\nint val;\r\nif (!snd_hdspm_use_is_exclusive(hdspm))\r\nreturn -EBUSY;\r\nval = ucontrol->value.enumerated.item[0];\r\nif (val < 0)\r\nval = 0;\r\nelse if (val > 1)\r\nval = 1;\r\nhdspm_set_system_clock_mode(hdspm, val);\r\nreturn 0;\r\n}\r\nstatic int hdspm_clock_source(struct hdspm * hdspm)\r\n{\r\nswitch (hdspm->system_sample_rate) {\r\ncase 32000: return 0;\r\ncase 44100: return 1;\r\ncase 48000: return 2;\r\ncase 64000: return 3;\r\ncase 88200: return 4;\r\ncase 96000: return 5;\r\ncase 128000: return 6;\r\ncase 176400: return 7;\r\ncase 192000: return 8;\r\n}\r\nreturn -1;\r\n}\r\nstatic int hdspm_set_clock_source(struct hdspm * hdspm, int mode)\r\n{\r\nint rate;\r\nswitch (mode) {\r\ncase 0:\r\nrate = 32000; break;\r\ncase 1:\r\nrate = 44100; break;\r\ncase 2:\r\nrate = 48000; break;\r\ncase 3:\r\nrate = 64000; break;\r\ncase 4:\r\nrate = 88200; break;\r\ncase 5:\r\nrate = 96000; break;\r\ncase 6:\r\nrate = 128000; break;\r\ncase 7:\r\nrate = 176400; break;\r\ncase 8:\r\nrate = 192000; break;\r\ndefault:\r\nrate = 48000;\r\n}\r\nhdspm_set_rate(hdspm, rate, 1);\r\nreturn 0;\r\n}\r\nstatic int snd_hdspm_info_clock_source(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;\r\nuinfo->count = 1;\r\nuinfo->value.enumerated.items = 9;\r\nif (uinfo->value.enumerated.item >= uinfo->value.enumerated.items)\r\nuinfo->value.enumerated.item =\r\nuinfo->value.enumerated.items - 1;\r\nstrcpy(uinfo->value.enumerated.name,\r\ntexts_freq[uinfo->value.enumerated.item+1]);\r\nreturn 0;\r\n}\r\nstatic int snd_hdspm_get_clock_source(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hdspm *hdspm = snd_kcontrol_chip(kcontrol);\r\nucontrol->value.enumerated.item[0] = hdspm_clock_source(hdspm);\r\nreturn 0;\r\n}\r\nstatic int snd_hdspm_put_clock_source(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hdspm *hdspm = snd_kcontrol_chip(kcontrol);\r\nint change;\r\nint val;\r\nif (!snd_hdspm_use_is_exclusive(hdspm))\r\nreturn -EBUSY;\r\nval = ucontrol->value.enumerated.item[0];\r\nif (val < 0)\r\nval = 0;\r\nif (val > 9)\r\nval = 9;\r\nspin_lock_irq(&hdspm->lock);\r\nif (val != hdspm_clock_source(hdspm))\r\nchange = (hdspm_set_clock_source(hdspm, val) == 0) ? 1 : 0;\r\nelse\r\nchange = 0;\r\nspin_unlock_irq(&hdspm->lock);\r\nreturn change;\r\n}\r\nstatic int hdspm_pref_sync_ref(struct hdspm * hdspm)\r\n{\r\nswitch (hdspm->io_type) {\r\ncase AES32:\r\nswitch (hdspm->control_register & HDSPM_SyncRefMask) {\r\ncase 0: return 0;\r\ncase HDSPM_SyncRef0: return 1;\r\ncase HDSPM_SyncRef1: return 2;\r\ncase HDSPM_SyncRef1+HDSPM_SyncRef0: return 3;\r\ncase HDSPM_SyncRef2: return 4;\r\ncase HDSPM_SyncRef2+HDSPM_SyncRef0: return 5;\r\ncase HDSPM_SyncRef2+HDSPM_SyncRef1: return 6;\r\ncase HDSPM_SyncRef2+HDSPM_SyncRef1+HDSPM_SyncRef0:\r\nreturn 7;\r\ncase HDSPM_SyncRef3: return 8;\r\ncase HDSPM_SyncRef3+HDSPM_SyncRef0: return 9;\r\n}\r\nbreak;\r\ncase MADI:\r\ncase MADIface:\r\nif (hdspm->tco) {\r\nswitch (hdspm->control_register & HDSPM_SyncRefMask) {\r\ncase 0: return 0;\r\ncase HDSPM_SyncRef0: return 1;\r\ncase HDSPM_SyncRef1: return 2;\r\ncase HDSPM_SyncRef1+HDSPM_SyncRef0:\r\nreturn 3;\r\n}\r\n} else {\r\nswitch (hdspm->control_register & HDSPM_SyncRefMask) {\r\ncase 0: return 0;\r\ncase HDSPM_SyncRef0: return 1;\r\ncase HDSPM_SyncRef1+HDSPM_SyncRef0:\r\nreturn 2;\r\n}\r\n}\r\nbreak;\r\ncase RayDAT:\r\nif (hdspm->tco) {\r\nswitch ((hdspm->settings_register &\r\nHDSPM_c0_SyncRefMask) / HDSPM_c0_SyncRef0) {\r\ncase 0: return 0;\r\ncase 3: return 1;\r\ncase 4: return 2;\r\ncase 5: return 3;\r\ncase 6: return 4;\r\ncase 1: return 5;\r\ncase 2: return 6;\r\ncase 9: return 7;\r\ncase 10: return 8;\r\n}\r\n} else {\r\nswitch ((hdspm->settings_register &\r\nHDSPM_c0_SyncRefMask) / HDSPM_c0_SyncRef0) {\r\ncase 0: return 0;\r\ncase 3: return 1;\r\ncase 4: return 2;\r\ncase 5: return 3;\r\ncase 6: return 4;\r\ncase 1: return 5;\r\ncase 2: return 6;\r\ncase 10: return 7;\r\n}\r\n}\r\nbreak;\r\ncase AIO:\r\nif (hdspm->tco) {\r\nswitch ((hdspm->settings_register &\r\nHDSPM_c0_SyncRefMask) / HDSPM_c0_SyncRef0) {\r\ncase 0: return 0;\r\ncase 3: return 1;\r\ncase 1: return 2;\r\ncase 2: return 3;\r\ncase 9: return 4;\r\ncase 10: return 5;\r\n}\r\n} else {\r\nswitch ((hdspm->settings_register &\r\nHDSPM_c0_SyncRefMask) / HDSPM_c0_SyncRef0) {\r\ncase 0: return 0;\r\ncase 3: return 1;\r\ncase 1: return 2;\r\ncase 2: return 3;\r\ncase 10: return 4;\r\n}\r\n}\r\nbreak;\r\n}\r\nreturn -1;\r\n}\r\nstatic int hdspm_set_pref_sync_ref(struct hdspm * hdspm, int pref)\r\n{\r\nint p = 0;\r\nswitch (hdspm->io_type) {\r\ncase AES32:\r\nhdspm->control_register &= ~HDSPM_SyncRefMask;\r\nswitch (pref) {\r\ncase 0:\r\nbreak;\r\ncase 1:\r\nhdspm->control_register |= HDSPM_SyncRef0;\r\nbreak;\r\ncase 2:\r\nhdspm->control_register |= HDSPM_SyncRef1;\r\nbreak;\r\ncase 3:\r\nhdspm->control_register |=\r\nHDSPM_SyncRef1+HDSPM_SyncRef0;\r\nbreak;\r\ncase 4:\r\nhdspm->control_register |= HDSPM_SyncRef2;\r\nbreak;\r\ncase 5:\r\nhdspm->control_register |=\r\nHDSPM_SyncRef2+HDSPM_SyncRef0;\r\nbreak;\r\ncase 6:\r\nhdspm->control_register |=\r\nHDSPM_SyncRef2+HDSPM_SyncRef1;\r\nbreak;\r\ncase 7:\r\nhdspm->control_register |=\r\nHDSPM_SyncRef2+HDSPM_SyncRef1+HDSPM_SyncRef0;\r\nbreak;\r\ncase 8:\r\nhdspm->control_register |= HDSPM_SyncRef3;\r\nbreak;\r\ncase 9:\r\nhdspm->control_register |=\r\nHDSPM_SyncRef3+HDSPM_SyncRef0;\r\nbreak;\r\ndefault:\r\nreturn -1;\r\n}\r\nbreak;\r\ncase MADI:\r\ncase MADIface:\r\nhdspm->control_register &= ~HDSPM_SyncRefMask;\r\nif (hdspm->tco) {\r\nswitch (pref) {\r\ncase 0:\r\nbreak;\r\ncase 1:\r\nhdspm->control_register |= HDSPM_SyncRef0;\r\nbreak;\r\ncase 2:\r\nhdspm->control_register |= HDSPM_SyncRef1;\r\nbreak;\r\ncase 3:\r\nhdspm->control_register |=\r\nHDSPM_SyncRef0+HDSPM_SyncRef1;\r\nbreak;\r\ndefault:\r\nreturn -1;\r\n}\r\n} else {\r\nswitch (pref) {\r\ncase 0:\r\nbreak;\r\ncase 1:\r\nhdspm->control_register |= HDSPM_SyncRef0;\r\nbreak;\r\ncase 2:\r\nhdspm->control_register |=\r\nHDSPM_SyncRef0+HDSPM_SyncRef1;\r\nbreak;\r\ndefault:\r\nreturn -1;\r\n}\r\n}\r\nbreak;\r\ncase RayDAT:\r\nif (hdspm->tco) {\r\nswitch (pref) {\r\ncase 0: p = 0; break;\r\ncase 1: p = 3; break;\r\ncase 2: p = 4; break;\r\ncase 3: p = 5; break;\r\ncase 4: p = 6; break;\r\ncase 5: p = 1; break;\r\ncase 6: p = 2; break;\r\ncase 7: p = 9; break;\r\ncase 8: p = 10; break;\r\ndefault: return -1;\r\n}\r\n} else {\r\nswitch (pref) {\r\ncase 0: p = 0; break;\r\ncase 1: p = 3; break;\r\ncase 2: p = 4; break;\r\ncase 3: p = 5; break;\r\ncase 4: p = 6; break;\r\ncase 5: p = 1; break;\r\ncase 6: p = 2; break;\r\ncase 7: p = 10; break;\r\ndefault: return -1;\r\n}\r\n}\r\nbreak;\r\ncase AIO:\r\nif (hdspm->tco) {\r\nswitch (pref) {\r\ncase 0: p = 0; break;\r\ncase 1: p = 3; break;\r\ncase 2: p = 1; break;\r\ncase 3: p = 2; break;\r\ncase 4: p = 9; break;\r\ncase 5: p = 10; break;\r\ndefault: return -1;\r\n}\r\n} else {\r\nswitch (pref) {\r\ncase 0: p = 0; break;\r\ncase 1: p = 3; break;\r\ncase 2: p = 1; break;\r\ncase 3: p = 2; break;\r\ncase 4: p = 10; break;\r\ndefault: return -1;\r\n}\r\n}\r\nbreak;\r\n}\r\nswitch (hdspm->io_type) {\r\ncase RayDAT:\r\ncase AIO:\r\nhdspm->settings_register &= ~HDSPM_c0_SyncRefMask;\r\nhdspm->settings_register |= HDSPM_c0_SyncRef0 * p;\r\nhdspm_write(hdspm, HDSPM_WR_SETTINGS, hdspm->settings_register);\r\nbreak;\r\ncase MADI:\r\ncase MADIface:\r\ncase AES32:\r\nhdspm_write(hdspm, HDSPM_controlRegister,\r\nhdspm->control_register);\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_hdspm_info_pref_sync_ref(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nstruct hdspm *hdspm = snd_kcontrol_chip(kcontrol);\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;\r\nuinfo->count = 1;\r\nuinfo->value.enumerated.items = hdspm->texts_autosync_items;\r\nif (uinfo->value.enumerated.item >= uinfo->value.enumerated.items)\r\nuinfo->value.enumerated.item =\r\nuinfo->value.enumerated.items - 1;\r\nstrcpy(uinfo->value.enumerated.name,\r\nhdspm->texts_autosync[uinfo->value.enumerated.item]);\r\nreturn 0;\r\n}\r\nstatic int snd_hdspm_get_pref_sync_ref(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hdspm *hdspm = snd_kcontrol_chip(kcontrol);\r\nint psf = hdspm_pref_sync_ref(hdspm);\r\nif (psf >= 0) {\r\nucontrol->value.enumerated.item[0] = psf;\r\nreturn 0;\r\n}\r\nreturn -1;\r\n}\r\nstatic int snd_hdspm_put_pref_sync_ref(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hdspm *hdspm = snd_kcontrol_chip(kcontrol);\r\nint val, change = 0;\r\nif (!snd_hdspm_use_is_exclusive(hdspm))\r\nreturn -EBUSY;\r\nval = ucontrol->value.enumerated.item[0];\r\nif (val < 0)\r\nval = 0;\r\nelse if (val >= hdspm->texts_autosync_items)\r\nval = hdspm->texts_autosync_items-1;\r\nspin_lock_irq(&hdspm->lock);\r\nif (val != hdspm_pref_sync_ref(hdspm))\r\nchange = (0 == hdspm_set_pref_sync_ref(hdspm, val)) ? 1 : 0;\r\nspin_unlock_irq(&hdspm->lock);\r\nreturn change;\r\n}\r\nstatic int hdspm_autosync_ref(struct hdspm *hdspm)\r\n{\r\nif (AES32 == hdspm->io_type) {\r\nunsigned int status = hdspm_read(hdspm, HDSPM_statusRegister);\r\nunsigned int syncref =\r\n(status >> HDSPM_AES32_syncref_bit) & 0xF;\r\nif (syncref == 0)\r\nreturn HDSPM_AES32_AUTOSYNC_FROM_WORD;\r\nif (syncref <= 8)\r\nreturn syncref;\r\nreturn HDSPM_AES32_AUTOSYNC_FROM_NONE;\r\n} else if (MADI == hdspm->io_type) {\r\nunsigned int status2 = hdspm_read(hdspm, HDSPM_statusRegister2);\r\nswitch (status2 & HDSPM_SelSyncRefMask) {\r\ncase HDSPM_SelSyncRef_WORD:\r\nreturn HDSPM_AUTOSYNC_FROM_WORD;\r\ncase HDSPM_SelSyncRef_MADI:\r\nreturn HDSPM_AUTOSYNC_FROM_MADI;\r\ncase HDSPM_SelSyncRef_TCO:\r\nreturn HDSPM_AUTOSYNC_FROM_TCO;\r\ncase HDSPM_SelSyncRef_SyncIn:\r\nreturn HDSPM_AUTOSYNC_FROM_SYNC_IN;\r\ncase HDSPM_SelSyncRef_NVALID:\r\nreturn HDSPM_AUTOSYNC_FROM_NONE;\r\ndefault:\r\nreturn 0;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_hdspm_info_autosync_ref(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nstruct hdspm *hdspm = snd_kcontrol_chip(kcontrol);\r\nif (AES32 == hdspm->io_type) {\r\nstatic char *texts[] = { "WordClock", "AES1", "AES2", "AES3",\r\n"AES4", "AES5", "AES6", "AES7", "AES8", "None"};\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;\r\nuinfo->count = 1;\r\nuinfo->value.enumerated.items = 10;\r\nif (uinfo->value.enumerated.item >=\r\nuinfo->value.enumerated.items)\r\nuinfo->value.enumerated.item =\r\nuinfo->value.enumerated.items - 1;\r\nstrcpy(uinfo->value.enumerated.name,\r\ntexts[uinfo->value.enumerated.item]);\r\n} else if (MADI == hdspm->io_type) {\r\nstatic char *texts[] = {"Word Clock", "MADI", "TCO",\r\n"Sync In", "None" };\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;\r\nuinfo->count = 1;\r\nuinfo->value.enumerated.items = 5;\r\nif (uinfo->value.enumerated.item >=\r\nuinfo->value.enumerated.items)\r\nuinfo->value.enumerated.item =\r\nuinfo->value.enumerated.items - 1;\r\nstrcpy(uinfo->value.enumerated.name,\r\ntexts[uinfo->value.enumerated.item]);\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_hdspm_get_autosync_ref(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hdspm *hdspm = snd_kcontrol_chip(kcontrol);\r\nucontrol->value.enumerated.item[0] = hdspm_autosync_ref(hdspm);\r\nreturn 0;\r\n}\r\nstatic int hdspm_toggle_setting(struct hdspm *hdspm, u32 regmask)\r\n{\r\nreturn (hdspm->control_register & regmask) ? 1 : 0;\r\n}\r\nstatic int hdspm_set_toggle_setting(struct hdspm *hdspm, u32 regmask, int out)\r\n{\r\nif (out)\r\nhdspm->control_register |= regmask;\r\nelse\r\nhdspm->control_register &= ~regmask;\r\nhdspm_write(hdspm, HDSPM_controlRegister, hdspm->control_register);\r\nreturn 0;\r\n}\r\nstatic int snd_hdspm_get_toggle_setting(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hdspm *hdspm = snd_kcontrol_chip(kcontrol);\r\nu32 regmask = kcontrol->private_value;\r\nspin_lock_irq(&hdspm->lock);\r\nucontrol->value.integer.value[0] = hdspm_toggle_setting(hdspm, regmask);\r\nspin_unlock_irq(&hdspm->lock);\r\nreturn 0;\r\n}\r\nstatic int snd_hdspm_put_toggle_setting(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hdspm *hdspm = snd_kcontrol_chip(kcontrol);\r\nu32 regmask = kcontrol->private_value;\r\nint change;\r\nunsigned int val;\r\nif (!snd_hdspm_use_is_exclusive(hdspm))\r\nreturn -EBUSY;\r\nval = ucontrol->value.integer.value[0] & 1;\r\nspin_lock_irq(&hdspm->lock);\r\nchange = (int) val != hdspm_toggle_setting(hdspm, regmask);\r\nhdspm_set_toggle_setting(hdspm, regmask, val);\r\nspin_unlock_irq(&hdspm->lock);\r\nreturn change;\r\n}\r\nstatic int hdspm_input_select(struct hdspm * hdspm)\r\n{\r\nreturn (hdspm->control_register & HDSPM_InputSelect0) ? 1 : 0;\r\n}\r\nstatic int hdspm_set_input_select(struct hdspm * hdspm, int out)\r\n{\r\nif (out)\r\nhdspm->control_register |= HDSPM_InputSelect0;\r\nelse\r\nhdspm->control_register &= ~HDSPM_InputSelect0;\r\nhdspm_write(hdspm, HDSPM_controlRegister, hdspm->control_register);\r\nreturn 0;\r\n}\r\nstatic int snd_hdspm_info_input_select(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nstatic char *texts[] = { "optical", "coaxial" };\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;\r\nuinfo->count = 1;\r\nuinfo->value.enumerated.items = 2;\r\nif (uinfo->value.enumerated.item >= uinfo->value.enumerated.items)\r\nuinfo->value.enumerated.item =\r\nuinfo->value.enumerated.items - 1;\r\nstrcpy(uinfo->value.enumerated.name,\r\ntexts[uinfo->value.enumerated.item]);\r\nreturn 0;\r\n}\r\nstatic int snd_hdspm_get_input_select(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hdspm *hdspm = snd_kcontrol_chip(kcontrol);\r\nspin_lock_irq(&hdspm->lock);\r\nucontrol->value.enumerated.item[0] = hdspm_input_select(hdspm);\r\nspin_unlock_irq(&hdspm->lock);\r\nreturn 0;\r\n}\r\nstatic int snd_hdspm_put_input_select(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hdspm *hdspm = snd_kcontrol_chip(kcontrol);\r\nint change;\r\nunsigned int val;\r\nif (!snd_hdspm_use_is_exclusive(hdspm))\r\nreturn -EBUSY;\r\nval = ucontrol->value.integer.value[0] & 1;\r\nspin_lock_irq(&hdspm->lock);\r\nchange = (int) val != hdspm_input_select(hdspm);\r\nhdspm_set_input_select(hdspm, val);\r\nspin_unlock_irq(&hdspm->lock);\r\nreturn change;\r\n}\r\nstatic int hdspm_ds_wire(struct hdspm * hdspm)\r\n{\r\nreturn (hdspm->control_register & HDSPM_DS_DoubleWire) ? 1 : 0;\r\n}\r\nstatic int hdspm_set_ds_wire(struct hdspm * hdspm, int ds)\r\n{\r\nif (ds)\r\nhdspm->control_register |= HDSPM_DS_DoubleWire;\r\nelse\r\nhdspm->control_register &= ~HDSPM_DS_DoubleWire;\r\nhdspm_write(hdspm, HDSPM_controlRegister, hdspm->control_register);\r\nreturn 0;\r\n}\r\nstatic int snd_hdspm_info_ds_wire(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nstatic char *texts[] = { "Single", "Double" };\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;\r\nuinfo->count = 1;\r\nuinfo->value.enumerated.items = 2;\r\nif (uinfo->value.enumerated.item >= uinfo->value.enumerated.items)\r\nuinfo->value.enumerated.item =\r\nuinfo->value.enumerated.items - 1;\r\nstrcpy(uinfo->value.enumerated.name,\r\ntexts[uinfo->value.enumerated.item]);\r\nreturn 0;\r\n}\r\nstatic int snd_hdspm_get_ds_wire(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hdspm *hdspm = snd_kcontrol_chip(kcontrol);\r\nspin_lock_irq(&hdspm->lock);\r\nucontrol->value.enumerated.item[0] = hdspm_ds_wire(hdspm);\r\nspin_unlock_irq(&hdspm->lock);\r\nreturn 0;\r\n}\r\nstatic int snd_hdspm_put_ds_wire(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hdspm *hdspm = snd_kcontrol_chip(kcontrol);\r\nint change;\r\nunsigned int val;\r\nif (!snd_hdspm_use_is_exclusive(hdspm))\r\nreturn -EBUSY;\r\nval = ucontrol->value.integer.value[0] & 1;\r\nspin_lock_irq(&hdspm->lock);\r\nchange = (int) val != hdspm_ds_wire(hdspm);\r\nhdspm_set_ds_wire(hdspm, val);\r\nspin_unlock_irq(&hdspm->lock);\r\nreturn change;\r\n}\r\nstatic int hdspm_qs_wire(struct hdspm * hdspm)\r\n{\r\nif (hdspm->control_register & HDSPM_QS_DoubleWire)\r\nreturn 1;\r\nif (hdspm->control_register & HDSPM_QS_QuadWire)\r\nreturn 2;\r\nreturn 0;\r\n}\r\nstatic int hdspm_set_qs_wire(struct hdspm * hdspm, int mode)\r\n{\r\nhdspm->control_register &= ~(HDSPM_QS_DoubleWire | HDSPM_QS_QuadWire);\r\nswitch (mode) {\r\ncase 0:\r\nbreak;\r\ncase 1:\r\nhdspm->control_register |= HDSPM_QS_DoubleWire;\r\nbreak;\r\ncase 2:\r\nhdspm->control_register |= HDSPM_QS_QuadWire;\r\nbreak;\r\n}\r\nhdspm_write(hdspm, HDSPM_controlRegister, hdspm->control_register);\r\nreturn 0;\r\n}\r\nstatic int snd_hdspm_info_qs_wire(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nstatic char *texts[] = { "Single", "Double", "Quad" };\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;\r\nuinfo->count = 1;\r\nuinfo->value.enumerated.items = 3;\r\nif (uinfo->value.enumerated.item >= uinfo->value.enumerated.items)\r\nuinfo->value.enumerated.item =\r\nuinfo->value.enumerated.items - 1;\r\nstrcpy(uinfo->value.enumerated.name,\r\ntexts[uinfo->value.enumerated.item]);\r\nreturn 0;\r\n}\r\nstatic int snd_hdspm_get_qs_wire(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hdspm *hdspm = snd_kcontrol_chip(kcontrol);\r\nspin_lock_irq(&hdspm->lock);\r\nucontrol->value.enumerated.item[0] = hdspm_qs_wire(hdspm);\r\nspin_unlock_irq(&hdspm->lock);\r\nreturn 0;\r\n}\r\nstatic int snd_hdspm_put_qs_wire(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hdspm *hdspm = snd_kcontrol_chip(kcontrol);\r\nint change;\r\nint val;\r\nif (!snd_hdspm_use_is_exclusive(hdspm))\r\nreturn -EBUSY;\r\nval = ucontrol->value.integer.value[0];\r\nif (val < 0)\r\nval = 0;\r\nif (val > 2)\r\nval = 2;\r\nspin_lock_irq(&hdspm->lock);\r\nchange = val != hdspm_qs_wire(hdspm);\r\nhdspm_set_qs_wire(hdspm, val);\r\nspin_unlock_irq(&hdspm->lock);\r\nreturn change;\r\n}\r\nstatic int hdspm_madi_speedmode(struct hdspm *hdspm)\r\n{\r\nif (hdspm->control_register & HDSPM_QuadSpeed)\r\nreturn 2;\r\nif (hdspm->control_register & HDSPM_DoubleSpeed)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic int hdspm_set_madi_speedmode(struct hdspm *hdspm, int mode)\r\n{\r\nhdspm->control_register &= ~(HDSPM_DoubleSpeed | HDSPM_QuadSpeed);\r\nswitch (mode) {\r\ncase 0:\r\nbreak;\r\ncase 1:\r\nhdspm->control_register |= HDSPM_DoubleSpeed;\r\nbreak;\r\ncase 2:\r\nhdspm->control_register |= HDSPM_QuadSpeed;\r\nbreak;\r\n}\r\nhdspm_write(hdspm, HDSPM_controlRegister, hdspm->control_register);\r\nreturn 0;\r\n}\r\nstatic int snd_hdspm_info_madi_speedmode(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nstatic char *texts[] = { "Single", "Double", "Quad" };\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;\r\nuinfo->count = 1;\r\nuinfo->value.enumerated.items = 3;\r\nif (uinfo->value.enumerated.item >= uinfo->value.enumerated.items)\r\nuinfo->value.enumerated.item =\r\nuinfo->value.enumerated.items - 1;\r\nstrcpy(uinfo->value.enumerated.name,\r\ntexts[uinfo->value.enumerated.item]);\r\nreturn 0;\r\n}\r\nstatic int snd_hdspm_get_madi_speedmode(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hdspm *hdspm = snd_kcontrol_chip(kcontrol);\r\nspin_lock_irq(&hdspm->lock);\r\nucontrol->value.enumerated.item[0] = hdspm_madi_speedmode(hdspm);\r\nspin_unlock_irq(&hdspm->lock);\r\nreturn 0;\r\n}\r\nstatic int snd_hdspm_put_madi_speedmode(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hdspm *hdspm = snd_kcontrol_chip(kcontrol);\r\nint change;\r\nint val;\r\nif (!snd_hdspm_use_is_exclusive(hdspm))\r\nreturn -EBUSY;\r\nval = ucontrol->value.integer.value[0];\r\nif (val < 0)\r\nval = 0;\r\nif (val > 2)\r\nval = 2;\r\nspin_lock_irq(&hdspm->lock);\r\nchange = val != hdspm_madi_speedmode(hdspm);\r\nhdspm_set_madi_speedmode(hdspm, val);\r\nspin_unlock_irq(&hdspm->lock);\r\nreturn change;\r\n}\r\nstatic int snd_hdspm_info_mixer(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\r\nuinfo->count = 3;\r\nuinfo->value.integer.min = 0;\r\nuinfo->value.integer.max = 65535;\r\nuinfo->value.integer.step = 1;\r\nreturn 0;\r\n}\r\nstatic int snd_hdspm_get_mixer(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hdspm *hdspm = snd_kcontrol_chip(kcontrol);\r\nint source;\r\nint destination;\r\nsource = ucontrol->value.integer.value[0];\r\nif (source < 0)\r\nsource = 0;\r\nelse if (source >= 2 * HDSPM_MAX_CHANNELS)\r\nsource = 2 * HDSPM_MAX_CHANNELS - 1;\r\ndestination = ucontrol->value.integer.value[1];\r\nif (destination < 0)\r\ndestination = 0;\r\nelse if (destination >= HDSPM_MAX_CHANNELS)\r\ndestination = HDSPM_MAX_CHANNELS - 1;\r\nspin_lock_irq(&hdspm->lock);\r\nif (source >= HDSPM_MAX_CHANNELS)\r\nucontrol->value.integer.value[2] =\r\nhdspm_read_pb_gain(hdspm, destination,\r\nsource - HDSPM_MAX_CHANNELS);\r\nelse\r\nucontrol->value.integer.value[2] =\r\nhdspm_read_in_gain(hdspm, destination, source);\r\nspin_unlock_irq(&hdspm->lock);\r\nreturn 0;\r\n}\r\nstatic int snd_hdspm_put_mixer(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hdspm *hdspm = snd_kcontrol_chip(kcontrol);\r\nint change;\r\nint source;\r\nint destination;\r\nint gain;\r\nif (!snd_hdspm_use_is_exclusive(hdspm))\r\nreturn -EBUSY;\r\nsource = ucontrol->value.integer.value[0];\r\ndestination = ucontrol->value.integer.value[1];\r\nif (source < 0 || source >= 2 * HDSPM_MAX_CHANNELS)\r\nreturn -1;\r\nif (destination < 0 || destination >= HDSPM_MAX_CHANNELS)\r\nreturn -1;\r\ngain = ucontrol->value.integer.value[2];\r\nspin_lock_irq(&hdspm->lock);\r\nif (source >= HDSPM_MAX_CHANNELS)\r\nchange = gain != hdspm_read_pb_gain(hdspm, destination,\r\nsource -\r\nHDSPM_MAX_CHANNELS);\r\nelse\r\nchange = gain != hdspm_read_in_gain(hdspm, destination,\r\nsource);\r\nif (change) {\r\nif (source >= HDSPM_MAX_CHANNELS)\r\nhdspm_write_pb_gain(hdspm, destination,\r\nsource - HDSPM_MAX_CHANNELS,\r\ngain);\r\nelse\r\nhdspm_write_in_gain(hdspm, destination, source,\r\ngain);\r\n}\r\nspin_unlock_irq(&hdspm->lock);\r\nreturn change;\r\n}\r\nstatic int snd_hdspm_info_playback_mixer(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\r\nuinfo->count = 1;\r\nuinfo->value.integer.min = 0;\r\nuinfo->value.integer.max = 64;\r\nuinfo->value.integer.step = 1;\r\nreturn 0;\r\n}\r\nstatic int snd_hdspm_get_playback_mixer(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hdspm *hdspm = snd_kcontrol_chip(kcontrol);\r\nint channel;\r\nchannel = ucontrol->id.index - 1;\r\nif (snd_BUG_ON(channel < 0 || channel >= HDSPM_MAX_CHANNELS))\r\nreturn -EINVAL;\r\nspin_lock_irq(&hdspm->lock);\r\nucontrol->value.integer.value[0] =\r\n(hdspm_read_pb_gain(hdspm, channel, channel)*64)/UNITY_GAIN;\r\nspin_unlock_irq(&hdspm->lock);\r\nreturn 0;\r\n}\r\nstatic int snd_hdspm_put_playback_mixer(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hdspm *hdspm = snd_kcontrol_chip(kcontrol);\r\nint change;\r\nint channel;\r\nint gain;\r\nif (!snd_hdspm_use_is_exclusive(hdspm))\r\nreturn -EBUSY;\r\nchannel = ucontrol->id.index - 1;\r\nif (snd_BUG_ON(channel < 0 || channel >= HDSPM_MAX_CHANNELS))\r\nreturn -EINVAL;\r\ngain = ucontrol->value.integer.value[0]*UNITY_GAIN/64;\r\nspin_lock_irq(&hdspm->lock);\r\nchange =\r\ngain != hdspm_read_pb_gain(hdspm, channel,\r\nchannel);\r\nif (change)\r\nhdspm_write_pb_gain(hdspm, channel, channel,\r\ngain);\r\nspin_unlock_irq(&hdspm->lock);\r\nreturn change;\r\n}\r\nstatic int snd_hdspm_info_sync_check(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nstatic char *texts[] = { "No Lock", "Lock", "Sync", "N/A" };\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;\r\nuinfo->count = 1;\r\nuinfo->value.enumerated.items = 4;\r\nif (uinfo->value.enumerated.item >= uinfo->value.enumerated.items)\r\nuinfo->value.enumerated.item =\r\nuinfo->value.enumerated.items - 1;\r\nstrcpy(uinfo->value.enumerated.name,\r\ntexts[uinfo->value.enumerated.item]);\r\nreturn 0;\r\n}\r\nstatic int hdspm_wc_sync_check(struct hdspm *hdspm)\r\n{\r\nint status, status2;\r\nswitch (hdspm->io_type) {\r\ncase AES32:\r\nstatus = hdspm_read(hdspm, HDSPM_statusRegister);\r\nif (status & HDSPM_AES32_wcLock) {\r\nif (status & HDSPM_AES32_wcSync)\r\nreturn 2;\r\nelse\r\nreturn 1;\r\n}\r\nreturn 0;\r\nbreak;\r\ncase MADI:\r\nstatus2 = hdspm_read(hdspm, HDSPM_statusRegister2);\r\nif (status2 & HDSPM_wcLock) {\r\nif (status2 & HDSPM_wcSync)\r\nreturn 2;\r\nelse\r\nreturn 1;\r\n}\r\nreturn 0;\r\nbreak;\r\ncase RayDAT:\r\ncase AIO:\r\nstatus = hdspm_read(hdspm, HDSPM_statusRegister);\r\nif (status & 0x2000000)\r\nreturn 2;\r\nelse if (status & 0x1000000)\r\nreturn 1;\r\nreturn 0;\r\nbreak;\r\ncase MADIface:\r\nbreak;\r\n}\r\nreturn 3;\r\n}\r\nstatic int hdspm_madi_sync_check(struct hdspm *hdspm)\r\n{\r\nint status = hdspm_read(hdspm, HDSPM_statusRegister);\r\nif (status & HDSPM_madiLock) {\r\nif (status & HDSPM_madiSync)\r\nreturn 2;\r\nelse\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int hdspm_s1_sync_check(struct hdspm *hdspm, int idx)\r\n{\r\nint status, lock, sync;\r\nstatus = hdspm_read(hdspm, HDSPM_RD_STATUS_1);\r\nlock = (status & (0x1<<idx)) ? 1 : 0;\r\nsync = (status & (0x100<<idx)) ? 1 : 0;\r\nif (lock && sync)\r\nreturn 2;\r\nelse if (lock)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic int hdspm_sync_in_sync_check(struct hdspm *hdspm)\r\n{\r\nint status, lock = 0, sync = 0;\r\nswitch (hdspm->io_type) {\r\ncase RayDAT:\r\ncase AIO:\r\nstatus = hdspm_read(hdspm, HDSPM_RD_STATUS_3);\r\nlock = (status & 0x400) ? 1 : 0;\r\nsync = (status & 0x800) ? 1 : 0;\r\nbreak;\r\ncase MADI:\r\nstatus = hdspm_read(hdspm, HDSPM_statusRegister);\r\nlock = (status & HDSPM_syncInLock) ? 1 : 0;\r\nsync = (status & HDSPM_syncInSync) ? 1 : 0;\r\nbreak;\r\ncase AES32:\r\nstatus = hdspm_read(hdspm, HDSPM_statusRegister2);\r\nlock = (status & 0x100000) ? 1 : 0;\r\nsync = (status & 0x200000) ? 1 : 0;\r\nbreak;\r\ncase MADIface:\r\nbreak;\r\n}\r\nif (lock && sync)\r\nreturn 2;\r\nelse if (lock)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic int hdspm_aes_sync_check(struct hdspm *hdspm, int idx)\r\n{\r\nint status2, lock, sync;\r\nstatus2 = hdspm_read(hdspm, HDSPM_statusRegister2);\r\nlock = (status2 & (0x0080 >> idx)) ? 1 : 0;\r\nsync = (status2 & (0x8000 >> idx)) ? 1 : 0;\r\nif (sync)\r\nreturn 2;\r\nelse if (lock)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic int hdspm_tco_sync_check(struct hdspm *hdspm)\r\n{\r\nint status;\r\nif (hdspm->tco) {\r\nswitch (hdspm->io_type) {\r\ncase MADI:\r\ncase AES32:\r\nstatus = hdspm_read(hdspm, HDSPM_statusRegister);\r\nif (status & HDSPM_tcoLock) {\r\nif (status & HDSPM_tcoSync)\r\nreturn 2;\r\nelse\r\nreturn 1;\r\n}\r\nreturn 0;\r\nbreak;\r\ncase RayDAT:\r\ncase AIO:\r\nstatus = hdspm_read(hdspm, HDSPM_RD_STATUS_1);\r\nif (status & 0x8000000)\r\nreturn 2;\r\nif (status & 0x4000000)\r\nreturn 1;\r\nreturn 0;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nreturn 3;\r\n}\r\nstatic int snd_hdspm_get_sync_check(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hdspm *hdspm = snd_kcontrol_chip(kcontrol);\r\nint val = -1;\r\nswitch (hdspm->io_type) {\r\ncase RayDAT:\r\nswitch (kcontrol->private_value) {\r\ncase 0:\r\nval = hdspm_wc_sync_check(hdspm); break;\r\ncase 7:\r\nval = hdspm_tco_sync_check(hdspm); break;\r\ncase 8:\r\nval = hdspm_sync_in_sync_check(hdspm); break;\r\ndefault:\r\nval = hdspm_s1_sync_check(hdspm,\r\nkcontrol->private_value-1);\r\n}\r\nbreak;\r\ncase AIO:\r\nswitch (kcontrol->private_value) {\r\ncase 0:\r\nval = hdspm_wc_sync_check(hdspm); break;\r\ncase 4:\r\nval = hdspm_tco_sync_check(hdspm); break;\r\ncase 5:\r\nval = hdspm_sync_in_sync_check(hdspm); break;\r\ndefault:\r\nval = hdspm_s1_sync_check(hdspm, ucontrol->id.index-1);\r\n}\r\nbreak;\r\ncase MADI:\r\nswitch (kcontrol->private_value) {\r\ncase 0:\r\nval = hdspm_wc_sync_check(hdspm); break;\r\ncase 1:\r\nval = hdspm_madi_sync_check(hdspm); break;\r\ncase 2:\r\nval = hdspm_tco_sync_check(hdspm); break;\r\ncase 3:\r\nval = hdspm_sync_in_sync_check(hdspm); break;\r\n}\r\nbreak;\r\ncase MADIface:\r\nval = hdspm_madi_sync_check(hdspm);\r\nbreak;\r\ncase AES32:\r\nswitch (kcontrol->private_value) {\r\ncase 0:\r\nval = hdspm_wc_sync_check(hdspm); break;\r\ncase 9:\r\nval = hdspm_tco_sync_check(hdspm); break;\r\ncase 10 :\r\nval = hdspm_sync_in_sync_check(hdspm); break;\r\ndefault:\r\nval = hdspm_aes_sync_check(hdspm,\r\nkcontrol->private_value-1);\r\n}\r\nbreak;\r\n}\r\nif (-1 == val)\r\nval = 3;\r\nucontrol->value.enumerated.item[0] = val;\r\nreturn 0;\r\n}\r\nstatic void hdspm_tco_write(struct hdspm *hdspm)\r\n{\r\nunsigned int tc[4] = { 0, 0, 0, 0};\r\nswitch (hdspm->tco->input) {\r\ncase 0:\r\ntc[2] |= HDSPM_TCO2_set_input_MSB;\r\nbreak;\r\ncase 1:\r\ntc[2] |= HDSPM_TCO2_set_input_LSB;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nswitch (hdspm->tco->framerate) {\r\ncase 1:\r\ntc[1] |= HDSPM_TCO1_LTC_Format_LSB;\r\nbreak;\r\ncase 2:\r\ntc[1] |= HDSPM_TCO1_LTC_Format_MSB;\r\nbreak;\r\ncase 3:\r\ntc[1] |= HDSPM_TCO1_LTC_Format_MSB +\r\nHDSPM_TCO1_set_drop_frame_flag;\r\nbreak;\r\ncase 4:\r\ntc[1] |= HDSPM_TCO1_LTC_Format_LSB +\r\nHDSPM_TCO1_LTC_Format_MSB;\r\nbreak;\r\ncase 5:\r\ntc[1] |= HDSPM_TCO1_LTC_Format_LSB +\r\nHDSPM_TCO1_LTC_Format_MSB +\r\nHDSPM_TCO1_set_drop_frame_flag;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nswitch (hdspm->tco->wordclock) {\r\ncase 1:\r\ntc[2] |= HDSPM_TCO2_WCK_IO_ratio_LSB;\r\nbreak;\r\ncase 2:\r\ntc[2] |= HDSPM_TCO2_WCK_IO_ratio_MSB;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nswitch (hdspm->tco->samplerate) {\r\ncase 1:\r\ntc[2] |= HDSPM_TCO2_set_freq;\r\nbreak;\r\ncase 2:\r\ntc[2] |= HDSPM_TCO2_set_freq_from_app;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nswitch (hdspm->tco->pull) {\r\ncase 1:\r\ntc[2] |= HDSPM_TCO2_set_pull_up;\r\nbreak;\r\ncase 2:\r\ntc[2] |= HDSPM_TCO2_set_pull_down;\r\nbreak;\r\ncase 3:\r\ntc[2] |= HDSPM_TCO2_set_pull_up + HDSPM_TCO2_set_01_4;\r\nbreak;\r\ncase 4:\r\ntc[2] |= HDSPM_TCO2_set_pull_down + HDSPM_TCO2_set_01_4;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif (1 == hdspm->tco->term) {\r\ntc[2] |= HDSPM_TCO2_set_term_75R;\r\n}\r\nhdspm_write(hdspm, HDSPM_WR_TCO, tc[0]);\r\nhdspm_write(hdspm, HDSPM_WR_TCO+4, tc[1]);\r\nhdspm_write(hdspm, HDSPM_WR_TCO+8, tc[2]);\r\nhdspm_write(hdspm, HDSPM_WR_TCO+12, tc[3]);\r\n}\r\nstatic int snd_hdspm_info_tco_sample_rate(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nstatic char *texts[] = { "44.1 kHz", "48 kHz" };\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;\r\nuinfo->count = 1;\r\nuinfo->value.enumerated.items = 2;\r\nif (uinfo->value.enumerated.item >= uinfo->value.enumerated.items)\r\nuinfo->value.enumerated.item =\r\nuinfo->value.enumerated.items - 1;\r\nstrcpy(uinfo->value.enumerated.name,\r\ntexts[uinfo->value.enumerated.item]);\r\nreturn 0;\r\n}\r\nstatic int snd_hdspm_get_tco_sample_rate(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hdspm *hdspm = snd_kcontrol_chip(kcontrol);\r\nucontrol->value.enumerated.item[0] = hdspm->tco->samplerate;\r\nreturn 0;\r\n}\r\nstatic int snd_hdspm_put_tco_sample_rate(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hdspm *hdspm = snd_kcontrol_chip(kcontrol);\r\nif (hdspm->tco->samplerate != ucontrol->value.enumerated.item[0]) {\r\nhdspm->tco->samplerate = ucontrol->value.enumerated.item[0];\r\nhdspm_tco_write(hdspm);\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_hdspm_info_tco_pull(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nstatic char *texts[] = { "0", "+ 0.1 %", "- 0.1 %", "+ 4 %", "- 4 %" };\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;\r\nuinfo->count = 1;\r\nuinfo->value.enumerated.items = 5;\r\nif (uinfo->value.enumerated.item >= uinfo->value.enumerated.items)\r\nuinfo->value.enumerated.item =\r\nuinfo->value.enumerated.items - 1;\r\nstrcpy(uinfo->value.enumerated.name,\r\ntexts[uinfo->value.enumerated.item]);\r\nreturn 0;\r\n}\r\nstatic int snd_hdspm_get_tco_pull(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hdspm *hdspm = snd_kcontrol_chip(kcontrol);\r\nucontrol->value.enumerated.item[0] = hdspm->tco->pull;\r\nreturn 0;\r\n}\r\nstatic int snd_hdspm_put_tco_pull(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hdspm *hdspm = snd_kcontrol_chip(kcontrol);\r\nif (hdspm->tco->pull != ucontrol->value.enumerated.item[0]) {\r\nhdspm->tco->pull = ucontrol->value.enumerated.item[0];\r\nhdspm_tco_write(hdspm);\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_hdspm_info_tco_wck_conversion(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nstatic char *texts[] = { "1:1", "44.1 -> 48", "48 -> 44.1" };\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;\r\nuinfo->count = 1;\r\nuinfo->value.enumerated.items = 3;\r\nif (uinfo->value.enumerated.item >= uinfo->value.enumerated.items)\r\nuinfo->value.enumerated.item =\r\nuinfo->value.enumerated.items - 1;\r\nstrcpy(uinfo->value.enumerated.name,\r\ntexts[uinfo->value.enumerated.item]);\r\nreturn 0;\r\n}\r\nstatic int snd_hdspm_get_tco_wck_conversion(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hdspm *hdspm = snd_kcontrol_chip(kcontrol);\r\nucontrol->value.enumerated.item[0] = hdspm->tco->wordclock;\r\nreturn 0;\r\n}\r\nstatic int snd_hdspm_put_tco_wck_conversion(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hdspm *hdspm = snd_kcontrol_chip(kcontrol);\r\nif (hdspm->tco->wordclock != ucontrol->value.enumerated.item[0]) {\r\nhdspm->tco->wordclock = ucontrol->value.enumerated.item[0];\r\nhdspm_tco_write(hdspm);\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_hdspm_info_tco_frame_rate(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nstatic char *texts[] = { "24 fps", "25 fps", "29.97fps",\r\n"29.97 dfps", "30 fps", "30 dfps" };\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;\r\nuinfo->count = 1;\r\nuinfo->value.enumerated.items = 6;\r\nif (uinfo->value.enumerated.item >= uinfo->value.enumerated.items)\r\nuinfo->value.enumerated.item =\r\nuinfo->value.enumerated.items - 1;\r\nstrcpy(uinfo->value.enumerated.name,\r\ntexts[uinfo->value.enumerated.item]);\r\nreturn 0;\r\n}\r\nstatic int snd_hdspm_get_tco_frame_rate(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hdspm *hdspm = snd_kcontrol_chip(kcontrol);\r\nucontrol->value.enumerated.item[0] = hdspm->tco->framerate;\r\nreturn 0;\r\n}\r\nstatic int snd_hdspm_put_tco_frame_rate(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hdspm *hdspm = snd_kcontrol_chip(kcontrol);\r\nif (hdspm->tco->framerate != ucontrol->value.enumerated.item[0]) {\r\nhdspm->tco->framerate = ucontrol->value.enumerated.item[0];\r\nhdspm_tco_write(hdspm);\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_hdspm_info_tco_sync_source(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nstatic char *texts[] = { "LTC", "Video", "WCK" };\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;\r\nuinfo->count = 1;\r\nuinfo->value.enumerated.items = 3;\r\nif (uinfo->value.enumerated.item >= uinfo->value.enumerated.items)\r\nuinfo->value.enumerated.item =\r\nuinfo->value.enumerated.items - 1;\r\nstrcpy(uinfo->value.enumerated.name,\r\ntexts[uinfo->value.enumerated.item]);\r\nreturn 0;\r\n}\r\nstatic int snd_hdspm_get_tco_sync_source(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hdspm *hdspm = snd_kcontrol_chip(kcontrol);\r\nucontrol->value.enumerated.item[0] = hdspm->tco->input;\r\nreturn 0;\r\n}\r\nstatic int snd_hdspm_put_tco_sync_source(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hdspm *hdspm = snd_kcontrol_chip(kcontrol);\r\nif (hdspm->tco->input != ucontrol->value.enumerated.item[0]) {\r\nhdspm->tco->input = ucontrol->value.enumerated.item[0];\r\nhdspm_tco_write(hdspm);\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_hdspm_info_tco_word_term(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;\r\nuinfo->count = 1;\r\nuinfo->value.integer.min = 0;\r\nuinfo->value.integer.max = 1;\r\nreturn 0;\r\n}\r\nstatic int snd_hdspm_get_tco_word_term(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hdspm *hdspm = snd_kcontrol_chip(kcontrol);\r\nucontrol->value.enumerated.item[0] = hdspm->tco->term;\r\nreturn 0;\r\n}\r\nstatic int snd_hdspm_put_tco_word_term(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hdspm *hdspm = snd_kcontrol_chip(kcontrol);\r\nif (hdspm->tco->term != ucontrol->value.enumerated.item[0]) {\r\nhdspm->tco->term = ucontrol->value.enumerated.item[0];\r\nhdspm_tco_write(hdspm);\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int hdspm_update_simple_mixer_controls(struct hdspm * hdspm)\r\n{\r\nint i;\r\nfor (i = hdspm->ds_out_channels; i < hdspm->ss_out_channels; ++i) {\r\nif (hdspm->system_sample_rate > 48000) {\r\nhdspm->playback_mixer_ctls[i]->vd[0].access =\r\nSNDRV_CTL_ELEM_ACCESS_INACTIVE |\r\nSNDRV_CTL_ELEM_ACCESS_READ |\r\nSNDRV_CTL_ELEM_ACCESS_VOLATILE;\r\n} else {\r\nhdspm->playback_mixer_ctls[i]->vd[0].access =\r\nSNDRV_CTL_ELEM_ACCESS_READWRITE |\r\nSNDRV_CTL_ELEM_ACCESS_VOLATILE;\r\n}\r\nsnd_ctl_notify(hdspm->card, SNDRV_CTL_EVENT_MASK_VALUE |\r\nSNDRV_CTL_EVENT_MASK_INFO,\r\n&hdspm->playback_mixer_ctls[i]->id);\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_hdspm_create_controls(struct snd_card *card,\r\nstruct hdspm *hdspm)\r\n{\r\nunsigned int idx, limit;\r\nint err;\r\nstruct snd_kcontrol *kctl;\r\nstruct snd_kcontrol_new *list = NULL;\r\nswitch (hdspm->io_type) {\r\ncase MADI:\r\nlist = snd_hdspm_controls_madi;\r\nlimit = ARRAY_SIZE(snd_hdspm_controls_madi);\r\nbreak;\r\ncase MADIface:\r\nlist = snd_hdspm_controls_madiface;\r\nlimit = ARRAY_SIZE(snd_hdspm_controls_madiface);\r\nbreak;\r\ncase AIO:\r\nlist = snd_hdspm_controls_aio;\r\nlimit = ARRAY_SIZE(snd_hdspm_controls_aio);\r\nbreak;\r\ncase RayDAT:\r\nlist = snd_hdspm_controls_raydat;\r\nlimit = ARRAY_SIZE(snd_hdspm_controls_raydat);\r\nbreak;\r\ncase AES32:\r\nlist = snd_hdspm_controls_aes32;\r\nlimit = ARRAY_SIZE(snd_hdspm_controls_aes32);\r\nbreak;\r\n}\r\nif (NULL != list) {\r\nfor (idx = 0; idx < limit; idx++) {\r\nerr = snd_ctl_add(card,\r\nsnd_ctl_new1(&list[idx], hdspm));\r\nif (err < 0)\r\nreturn err;\r\n}\r\n}\r\nsnd_hdspm_playback_mixer.name = "Chn";\r\nif (hdspm->system_sample_rate >= 128000) {\r\nlimit = hdspm->qs_out_channels;\r\n} else if (hdspm->system_sample_rate >= 64000) {\r\nlimit = hdspm->ds_out_channels;\r\n} else {\r\nlimit = hdspm->ss_out_channels;\r\n}\r\nfor (idx = 0; idx < limit; ++idx) {\r\nsnd_hdspm_playback_mixer.index = idx + 1;\r\nkctl = snd_ctl_new1(&snd_hdspm_playback_mixer, hdspm);\r\nerr = snd_ctl_add(card, kctl);\r\nif (err < 0)\r\nreturn err;\r\nhdspm->playback_mixer_ctls[idx] = kctl;\r\n}\r\nif (hdspm->tco) {\r\nlist = snd_hdspm_controls_tco;\r\nlimit = ARRAY_SIZE(snd_hdspm_controls_tco);\r\nfor (idx = 0; idx < limit; idx++) {\r\nerr = snd_ctl_add(card,\r\nsnd_ctl_new1(&list[idx], hdspm));\r\nif (err < 0)\r\nreturn err;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void\r\nsnd_hdspm_proc_read_madi(struct snd_info_entry * entry,\r\nstruct snd_info_buffer *buffer)\r\n{\r\nstruct hdspm *hdspm = entry->private_data;\r\nunsigned int status, status2, control, freq;\r\nchar *pref_sync_ref;\r\nchar *autosync_ref;\r\nchar *system_clock_mode;\r\nchar *insel;\r\nint x, x2;\r\nint a, ltc, frames, seconds, minutes, hours;\r\nunsigned int period;\r\nu64 freq_const = 0;\r\nu32 rate;\r\nstatus = hdspm_read(hdspm, HDSPM_statusRegister);\r\nstatus2 = hdspm_read(hdspm, HDSPM_statusRegister2);\r\ncontrol = hdspm->control_register;\r\nfreq = hdspm_read(hdspm, HDSPM_timecodeRegister);\r\nsnd_iprintf(buffer, "%s (Card #%d) Rev.%x Status2first3bits: %x\n",\r\nhdspm->card_name, hdspm->card->number + 1,\r\nhdspm->firmware_rev,\r\n(status2 & HDSPM_version0) |\r\n(status2 & HDSPM_version1) | (status2 &\r\nHDSPM_version2));\r\nsnd_iprintf(buffer, "HW Serial: 0x%06x%06x\n",\r\n(hdspm_read(hdspm, HDSPM_midiStatusIn1)>>8) & 0xFFFFFF,\r\nhdspm->serial);\r\nsnd_iprintf(buffer, "IRQ: %d Registers bus: 0x%lx VM: 0x%lx\n",\r\nhdspm->irq, hdspm->port, (unsigned long)hdspm->iobase);\r\nsnd_iprintf(buffer, "--- System ---\n");\r\nsnd_iprintf(buffer,\r\n"IRQ Pending: Audio=%d, MIDI0=%d, MIDI1=%d, IRQcount=%d\n",\r\nstatus & HDSPM_audioIRQPending,\r\n(status & HDSPM_midi0IRQPending) ? 1 : 0,\r\n(status & HDSPM_midi1IRQPending) ? 1 : 0,\r\nhdspm->irq_count);\r\nsnd_iprintf(buffer,\r\n"HW pointer: id = %d, rawptr = %d (%d->%d) "\r\n"estimated= %ld (bytes)\n",\r\n((status & HDSPM_BufferID) ? 1 : 0),\r\n(status & HDSPM_BufferPositionMask),\r\n(status & HDSPM_BufferPositionMask) %\r\n(2 * (int)hdspm->period_bytes),\r\n((status & HDSPM_BufferPositionMask) - 64) %\r\n(2 * (int)hdspm->period_bytes),\r\n(long) hdspm_hw_pointer(hdspm) * 4);\r\nsnd_iprintf(buffer,\r\n"MIDI FIFO: Out1=0x%x, Out2=0x%x, In1=0x%x, In2=0x%x \n",\r\nhdspm_read(hdspm, HDSPM_midiStatusOut0) & 0xFF,\r\nhdspm_read(hdspm, HDSPM_midiStatusOut1) & 0xFF,\r\nhdspm_read(hdspm, HDSPM_midiStatusIn0) & 0xFF,\r\nhdspm_read(hdspm, HDSPM_midiStatusIn1) & 0xFF);\r\nsnd_iprintf(buffer,\r\n"MIDIoverMADI FIFO: In=0x%x, Out=0x%x \n",\r\nhdspm_read(hdspm, HDSPM_midiStatusIn2) & 0xFF,\r\nhdspm_read(hdspm, HDSPM_midiStatusOut2) & 0xFF);\r\nsnd_iprintf(buffer,\r\n"Register: ctrl1=0x%x, ctrl2=0x%x, status1=0x%x, "\r\n"status2=0x%x\n",\r\nhdspm->control_register, hdspm->control2_register,\r\nstatus, status2);\r\nif (status & HDSPM_tco_detect) {\r\nsnd_iprintf(buffer, "TCO module detected.\n");\r\na = hdspm_read(hdspm, HDSPM_RD_TCO+4);\r\nif (a & HDSPM_TCO1_LTC_Input_valid) {\r\nsnd_iprintf(buffer, " LTC valid, ");\r\nswitch (a & (HDSPM_TCO1_LTC_Format_LSB |\r\nHDSPM_TCO1_LTC_Format_MSB)) {\r\ncase 0:\r\nsnd_iprintf(buffer, "24 fps, ");\r\nbreak;\r\ncase HDSPM_TCO1_LTC_Format_LSB:\r\nsnd_iprintf(buffer, "25 fps, ");\r\nbreak;\r\ncase HDSPM_TCO1_LTC_Format_MSB:\r\nsnd_iprintf(buffer, "29.97 fps, ");\r\nbreak;\r\ndefault:\r\nsnd_iprintf(buffer, "30 fps, ");\r\nbreak;\r\n}\r\nif (a & HDSPM_TCO1_set_drop_frame_flag) {\r\nsnd_iprintf(buffer, "drop frame\n");\r\n} else {\r\nsnd_iprintf(buffer, "full frame\n");\r\n}\r\n} else {\r\nsnd_iprintf(buffer, " no LTC\n");\r\n}\r\nif (a & HDSPM_TCO1_Video_Input_Format_NTSC) {\r\nsnd_iprintf(buffer, " Video: NTSC\n");\r\n} else if (a & HDSPM_TCO1_Video_Input_Format_PAL) {\r\nsnd_iprintf(buffer, " Video: PAL\n");\r\n} else {\r\nsnd_iprintf(buffer, " No video\n");\r\n}\r\nif (a & HDSPM_TCO1_TCO_lock) {\r\nsnd_iprintf(buffer, " Sync: lock\n");\r\n} else {\r\nsnd_iprintf(buffer, " Sync: no lock\n");\r\n}\r\nswitch (hdspm->io_type) {\r\ncase MADI:\r\ncase AES32:\r\nfreq_const = 110069313433624ULL;\r\nbreak;\r\ncase RayDAT:\r\ncase AIO:\r\nfreq_const = 104857600000000ULL;\r\nbreak;\r\ncase MADIface:\r\nbreak;\r\n}\r\nperiod = hdspm_read(hdspm, HDSPM_RD_PLL_FREQ);\r\nsnd_iprintf(buffer, " period: %u\n", period);\r\nrate = div_u64(freq_const, period);\r\nif (control & HDSPM_QuadSpeed) {\r\nrate *= 4;\r\n} else if (control & HDSPM_DoubleSpeed) {\r\nrate *= 2;\r\n}\r\nsnd_iprintf(buffer, " Frequency: %u Hz\n",\r\n(unsigned int) rate);\r\nltc = hdspm_read(hdspm, HDSPM_RD_TCO);\r\nframes = ltc & 0xF;\r\nltc >>= 4;\r\nframes += (ltc & 0x3) * 10;\r\nltc >>= 4;\r\nseconds = ltc & 0xF;\r\nltc >>= 4;\r\nseconds += (ltc & 0x7) * 10;\r\nltc >>= 4;\r\nminutes = ltc & 0xF;\r\nltc >>= 4;\r\nminutes += (ltc & 0x7) * 10;\r\nltc >>= 4;\r\nhours = ltc & 0xF;\r\nltc >>= 4;\r\nhours += (ltc & 0x3) * 10;\r\nsnd_iprintf(buffer,\r\n" LTC In: %02d:%02d:%02d:%02d\n",\r\nhours, minutes, seconds, frames);\r\n} else {\r\nsnd_iprintf(buffer, "No TCO module detected.\n");\r\n}\r\nsnd_iprintf(buffer, "--- Settings ---\n");\r\nx = hdspm_get_latency(hdspm);\r\nsnd_iprintf(buffer,\r\n"Size (Latency): %d samples (2 periods of %lu bytes)\n",\r\nx, (unsigned long) hdspm->period_bytes);\r\nsnd_iprintf(buffer, "Line out: %s\n",\r\n(hdspm->control_register & HDSPM_LineOut) ? "on " : "off");\r\nswitch (hdspm->control_register & HDSPM_InputMask) {\r\ncase HDSPM_InputOptical:\r\ninsel = "Optical";\r\nbreak;\r\ncase HDSPM_InputCoaxial:\r\ninsel = "Coaxial";\r\nbreak;\r\ndefault:\r\ninsel = "Unknown";\r\n}\r\nsnd_iprintf(buffer,\r\n"ClearTrackMarker = %s, Transmit in %s Channel Mode, "\r\n"Auto Input %s\n",\r\n(hdspm->control_register & HDSPM_clr_tms) ? "on" : "off",\r\n(hdspm->control_register & HDSPM_TX_64ch) ? "64" : "56",\r\n(hdspm->control_register & HDSPM_AutoInp) ? "on" : "off");\r\nif (!(hdspm->control_register & HDSPM_ClockModeMaster))\r\nsystem_clock_mode = "AutoSync";\r\nelse\r\nsystem_clock_mode = "Master";\r\nsnd_iprintf(buffer, "AutoSync Reference: %s\n", system_clock_mode);\r\nswitch (hdspm_pref_sync_ref(hdspm)) {\r\ncase HDSPM_SYNC_FROM_WORD:\r\npref_sync_ref = "Word Clock";\r\nbreak;\r\ncase HDSPM_SYNC_FROM_MADI:\r\npref_sync_ref = "MADI Sync";\r\nbreak;\r\ncase HDSPM_SYNC_FROM_TCO:\r\npref_sync_ref = "TCO";\r\nbreak;\r\ncase HDSPM_SYNC_FROM_SYNC_IN:\r\npref_sync_ref = "Sync In";\r\nbreak;\r\ndefault:\r\npref_sync_ref = "XXXX Clock";\r\nbreak;\r\n}\r\nsnd_iprintf(buffer, "Preferred Sync Reference: %s\n",\r\npref_sync_ref);\r\nsnd_iprintf(buffer, "System Clock Frequency: %d\n",\r\nhdspm->system_sample_rate);\r\nsnd_iprintf(buffer, "--- Status:\n");\r\nx = status & HDSPM_madiSync;\r\nx2 = status2 & HDSPM_wcSync;\r\nsnd_iprintf(buffer, "Inputs MADI=%s, WordClock=%s\n",\r\n(status & HDSPM_madiLock) ? (x ? "Sync" : "Lock") :\r\n"NoLock",\r\n(status2 & HDSPM_wcLock) ? (x2 ? "Sync" : "Lock") :\r\n"NoLock");\r\nswitch (hdspm_autosync_ref(hdspm)) {\r\ncase HDSPM_AUTOSYNC_FROM_SYNC_IN:\r\nautosync_ref = "Sync In";\r\nbreak;\r\ncase HDSPM_AUTOSYNC_FROM_TCO:\r\nautosync_ref = "TCO";\r\nbreak;\r\ncase HDSPM_AUTOSYNC_FROM_WORD:\r\nautosync_ref = "Word Clock";\r\nbreak;\r\ncase HDSPM_AUTOSYNC_FROM_MADI:\r\nautosync_ref = "MADI Sync";\r\nbreak;\r\ncase HDSPM_AUTOSYNC_FROM_NONE:\r\nautosync_ref = "Input not valid";\r\nbreak;\r\ndefault:\r\nautosync_ref = "---";\r\nbreak;\r\n}\r\nsnd_iprintf(buffer,\r\n"AutoSync: Reference= %s, Freq=%d (MADI = %d, Word = %d)\n",\r\nautosync_ref, hdspm_external_sample_rate(hdspm),\r\n(status & HDSPM_madiFreqMask) >> 22,\r\n(status2 & HDSPM_wcFreqMask) >> 5);\r\nsnd_iprintf(buffer, "Input: %s, Mode=%s\n",\r\n(status & HDSPM_AB_int) ? "Coax" : "Optical",\r\n(status & HDSPM_RX_64ch) ? "64 channels" :\r\n"56 channels");\r\nsnd_iprintf(buffer, "\n");\r\n}\r\nstatic void\r\nsnd_hdspm_proc_read_aes32(struct snd_info_entry * entry,\r\nstruct snd_info_buffer *buffer)\r\n{\r\nstruct hdspm *hdspm = entry->private_data;\r\nunsigned int status;\r\nunsigned int status2;\r\nunsigned int timecode;\r\nunsigned int wcLock, wcSync;\r\nint pref_syncref;\r\nchar *autosync_ref;\r\nint x;\r\nstatus = hdspm_read(hdspm, HDSPM_statusRegister);\r\nstatus2 = hdspm_read(hdspm, HDSPM_statusRegister2);\r\ntimecode = hdspm_read(hdspm, HDSPM_timecodeRegister);\r\nsnd_iprintf(buffer, "%s (Card #%d) Rev.%x\n",\r\nhdspm->card_name, hdspm->card->number + 1,\r\nhdspm->firmware_rev);\r\nsnd_iprintf(buffer, "IRQ: %d Registers bus: 0x%lx VM: 0x%lx\n",\r\nhdspm->irq, hdspm->port, (unsigned long)hdspm->iobase);\r\nsnd_iprintf(buffer, "--- System ---\n");\r\nsnd_iprintf(buffer,\r\n"IRQ Pending: Audio=%d, MIDI0=%d, MIDI1=%d, IRQcount=%d\n",\r\nstatus & HDSPM_audioIRQPending,\r\n(status & HDSPM_midi0IRQPending) ? 1 : 0,\r\n(status & HDSPM_midi1IRQPending) ? 1 : 0,\r\nhdspm->irq_count);\r\nsnd_iprintf(buffer,\r\n"HW pointer: id = %d, rawptr = %d (%d->%d) "\r\n"estimated= %ld (bytes)\n",\r\n((status & HDSPM_BufferID) ? 1 : 0),\r\n(status & HDSPM_BufferPositionMask),\r\n(status & HDSPM_BufferPositionMask) %\r\n(2 * (int)hdspm->period_bytes),\r\n((status & HDSPM_BufferPositionMask) - 64) %\r\n(2 * (int)hdspm->period_bytes),\r\n(long) hdspm_hw_pointer(hdspm) * 4);\r\nsnd_iprintf(buffer,\r\n"MIDI FIFO: Out1=0x%x, Out2=0x%x, In1=0x%x, In2=0x%x \n",\r\nhdspm_read(hdspm, HDSPM_midiStatusOut0) & 0xFF,\r\nhdspm_read(hdspm, HDSPM_midiStatusOut1) & 0xFF,\r\nhdspm_read(hdspm, HDSPM_midiStatusIn0) & 0xFF,\r\nhdspm_read(hdspm, HDSPM_midiStatusIn1) & 0xFF);\r\nsnd_iprintf(buffer,\r\n"MIDIoverMADI FIFO: In=0x%x, Out=0x%x \n",\r\nhdspm_read(hdspm, HDSPM_midiStatusIn2) & 0xFF,\r\nhdspm_read(hdspm, HDSPM_midiStatusOut2) & 0xFF);\r\nsnd_iprintf(buffer,\r\n"Register: ctrl1=0x%x, ctrl2=0x%x, status1=0x%x, "\r\n"status2=0x%x\n",\r\nhdspm->control_register, hdspm->control2_register,\r\nstatus, status2);\r\nsnd_iprintf(buffer, "--- Settings ---\n");\r\nx = hdspm_get_latency(hdspm);\r\nsnd_iprintf(buffer,\r\n"Size (Latency): %d samples (2 periods of %lu bytes)\n",\r\nx, (unsigned long) hdspm->period_bytes);\r\nsnd_iprintf(buffer, "Line out: %s\n",\r\n(hdspm->\r\ncontrol_register & HDSPM_LineOut) ? "on " : "off");\r\nsnd_iprintf(buffer,\r\n"ClearTrackMarker %s, Emphasis %s, Dolby %s\n",\r\n(hdspm->\r\ncontrol_register & HDSPM_clr_tms) ? "on" : "off",\r\n(hdspm->\r\ncontrol_register & HDSPM_Emphasis) ? "on" : "off",\r\n(hdspm->\r\ncontrol_register & HDSPM_Dolby) ? "on" : "off");\r\npref_syncref = hdspm_pref_sync_ref(hdspm);\r\nif (pref_syncref == 0)\r\nsnd_iprintf(buffer, "Preferred Sync Reference: Word Clock\n");\r\nelse\r\nsnd_iprintf(buffer, "Preferred Sync Reference: AES%d\n",\r\npref_syncref);\r\nsnd_iprintf(buffer, "System Clock Frequency: %d\n",\r\nhdspm->system_sample_rate);\r\nsnd_iprintf(buffer, "Double speed: %s\n",\r\nhdspm->control_register & HDSPM_DS_DoubleWire?\r\n"Double wire" : "Single wire");\r\nsnd_iprintf(buffer, "Quad speed: %s\n",\r\nhdspm->control_register & HDSPM_QS_DoubleWire?\r\n"Double wire" :\r\nhdspm->control_register & HDSPM_QS_QuadWire?\r\n"Quad wire" : "Single wire");\r\nsnd_iprintf(buffer, "--- Status:\n");\r\nwcLock = status & HDSPM_AES32_wcLock;\r\nwcSync = wcLock && (status & HDSPM_AES32_wcSync);\r\nsnd_iprintf(buffer, "Word: %s Frequency: %d\n",\r\n(wcLock) ? (wcSync ? "Sync " : "Lock ") : "No Lock",\r\nHDSPM_bit2freq((status >> HDSPM_AES32_wcFreq_bit) & 0xF));\r\nfor (x = 0; x < 8; x++) {\r\nsnd_iprintf(buffer, "AES%d: %s Frequency: %d\n",\r\nx+1,\r\n(status2 & (HDSPM_LockAES >> x)) ?\r\n"Sync " : "No Lock",\r\nHDSPM_bit2freq((timecode >> (4*x)) & 0xF));\r\n}\r\nswitch (hdspm_autosync_ref(hdspm)) {\r\ncase HDSPM_AES32_AUTOSYNC_FROM_NONE:\r\nautosync_ref = "None"; break;\r\ncase HDSPM_AES32_AUTOSYNC_FROM_WORD:\r\nautosync_ref = "Word Clock"; break;\r\ncase HDSPM_AES32_AUTOSYNC_FROM_AES1:\r\nautosync_ref = "AES1"; break;\r\ncase HDSPM_AES32_AUTOSYNC_FROM_AES2:\r\nautosync_ref = "AES2"; break;\r\ncase HDSPM_AES32_AUTOSYNC_FROM_AES3:\r\nautosync_ref = "AES3"; break;\r\ncase HDSPM_AES32_AUTOSYNC_FROM_AES4:\r\nautosync_ref = "AES4"; break;\r\ncase HDSPM_AES32_AUTOSYNC_FROM_AES5:\r\nautosync_ref = "AES5"; break;\r\ncase HDSPM_AES32_AUTOSYNC_FROM_AES6:\r\nautosync_ref = "AES6"; break;\r\ncase HDSPM_AES32_AUTOSYNC_FROM_AES7:\r\nautosync_ref = "AES7"; break;\r\ncase HDSPM_AES32_AUTOSYNC_FROM_AES8:\r\nautosync_ref = "AES8"; break;\r\ndefault:\r\nautosync_ref = "---"; break;\r\n}\r\nsnd_iprintf(buffer, "AutoSync ref = %s\n", autosync_ref);\r\nsnd_iprintf(buffer, "\n");\r\n}\r\nstatic void\r\nsnd_hdspm_proc_read_raydat(struct snd_info_entry *entry,\r\nstruct snd_info_buffer *buffer)\r\n{\r\nstruct hdspm *hdspm = entry->private_data;\r\nunsigned int status1, status2, status3, control, i;\r\nunsigned int lock, sync;\r\nstatus1 = hdspm_read(hdspm, HDSPM_RD_STATUS_1);\r\nstatus2 = hdspm_read(hdspm, HDSPM_RD_STATUS_2);\r\nstatus3 = hdspm_read(hdspm, HDSPM_RD_STATUS_3);\r\ncontrol = hdspm->control_register;\r\nsnd_iprintf(buffer, "STATUS1: 0x%08x\n", status1);\r\nsnd_iprintf(buffer, "STATUS2: 0x%08x\n", status2);\r\nsnd_iprintf(buffer, "STATUS3: 0x%08x\n", status3);\r\nsnd_iprintf(buffer, "\n*** CLOCK MODE\n\n");\r\nsnd_iprintf(buffer, "Clock mode : %s\n",\r\n(hdspm_system_clock_mode(hdspm) == 0) ? "master" : "slave");\r\nsnd_iprintf(buffer, "System frequency: %d Hz\n",\r\nhdspm_get_system_sample_rate(hdspm));\r\nsnd_iprintf(buffer, "\n*** INPUT STATUS\n\n");\r\nlock = 0x1;\r\nsync = 0x100;\r\nfor (i = 0; i < 8; i++) {\r\nsnd_iprintf(buffer, "s1_input %d: Lock %d, Sync %d, Freq %s\n",\r\ni,\r\n(status1 & lock) ? 1 : 0,\r\n(status1 & sync) ? 1 : 0,\r\ntexts_freq[(status2 >> (i * 4)) & 0xF]);\r\nlock = lock<<1;\r\nsync = sync<<1;\r\n}\r\nsnd_iprintf(buffer, "WC input: Lock %d, Sync %d, Freq %s\n",\r\n(status1 & 0x1000000) ? 1 : 0,\r\n(status1 & 0x2000000) ? 1 : 0,\r\ntexts_freq[(status1 >> 16) & 0xF]);\r\nsnd_iprintf(buffer, "TCO input: Lock %d, Sync %d, Freq %s\n",\r\n(status1 & 0x4000000) ? 1 : 0,\r\n(status1 & 0x8000000) ? 1 : 0,\r\ntexts_freq[(status1 >> 20) & 0xF]);\r\nsnd_iprintf(buffer, "SYNC IN: Lock %d, Sync %d, Freq %s\n",\r\n(status3 & 0x400) ? 1 : 0,\r\n(status3 & 0x800) ? 1 : 0,\r\ntexts_freq[(status2 >> 12) & 0xF]);\r\n}\r\nstatic void\r\nsnd_hdspm_proc_read_debug(struct snd_info_entry *entry,\r\nstruct snd_info_buffer *buffer)\r\n{\r\nstruct hdspm *hdspm = entry->private_data;\r\nint j,i;\r\nfor (i = 0; i < 256 ; i += j) {\r\nsnd_iprintf(buffer, "0x%08X: ", i);\r\nfor (j = 0; j < 16; j += 4)\r\nsnd_iprintf(buffer, "%08X ", hdspm_read(hdspm, i + j));\r\nsnd_iprintf(buffer, "\n");\r\n}\r\n}\r\nstatic void snd_hdspm_proc_ports_in(struct snd_info_entry *entry,\r\nstruct snd_info_buffer *buffer)\r\n{\r\nstruct hdspm *hdspm = entry->private_data;\r\nint i;\r\nsnd_iprintf(buffer, "# generated by hdspm\n");\r\nfor (i = 0; i < hdspm->max_channels_in; i++) {\r\nsnd_iprintf(buffer, "%d=%s\n", i+1, hdspm->port_names_in[i]);\r\n}\r\n}\r\nstatic void snd_hdspm_proc_ports_out(struct snd_info_entry *entry,\r\nstruct snd_info_buffer *buffer)\r\n{\r\nstruct hdspm *hdspm = entry->private_data;\r\nint i;\r\nsnd_iprintf(buffer, "# generated by hdspm\n");\r\nfor (i = 0; i < hdspm->max_channels_out; i++) {\r\nsnd_iprintf(buffer, "%d=%s\n", i+1, hdspm->port_names_out[i]);\r\n}\r\n}\r\nstatic void snd_hdspm_proc_init(struct hdspm *hdspm)\r\n{\r\nstruct snd_info_entry *entry;\r\nif (!snd_card_proc_new(hdspm->card, "hdspm", &entry)) {\r\nswitch (hdspm->io_type) {\r\ncase AES32:\r\nsnd_info_set_text_ops(entry, hdspm,\r\nsnd_hdspm_proc_read_aes32);\r\nbreak;\r\ncase MADI:\r\nsnd_info_set_text_ops(entry, hdspm,\r\nsnd_hdspm_proc_read_madi);\r\nbreak;\r\ncase MADIface:\r\nbreak;\r\ncase RayDAT:\r\nsnd_info_set_text_ops(entry, hdspm,\r\nsnd_hdspm_proc_read_raydat);\r\nbreak;\r\ncase AIO:\r\nbreak;\r\n}\r\n}\r\nif (!snd_card_proc_new(hdspm->card, "ports.in", &entry)) {\r\nsnd_info_set_text_ops(entry, hdspm, snd_hdspm_proc_ports_in);\r\n}\r\nif (!snd_card_proc_new(hdspm->card, "ports.out", &entry)) {\r\nsnd_info_set_text_ops(entry, hdspm, snd_hdspm_proc_ports_out);\r\n}\r\n#ifdef CONFIG_SND_DEBUG\r\nif (!snd_card_proc_new(hdspm->card, "debug", &entry))\r\nsnd_info_set_text_ops(entry, hdspm,\r\nsnd_hdspm_proc_read_debug);\r\n#endif\r\n}\r\nstatic int snd_hdspm_set_defaults(struct hdspm * hdspm)\r\n{\r\nhdspm->settings_register = 0;\r\nswitch (hdspm->io_type) {\r\ncase MADI:\r\ncase MADIface:\r\nhdspm->control_register =\r\n0x2 + 0x8 + 0x10 + 0x80 + 0x400 + 0x4000 + 0x1000000;\r\nbreak;\r\ncase RayDAT:\r\ncase AIO:\r\nhdspm->settings_register = 0x1 + 0x1000;\r\nhdspm->control_register =\r\n0x2 + 0x8 + 0x10 + 0x80 + 0x400 + 0x4000 + 0x1000000;\r\nbreak;\r\ncase AES32:\r\nhdspm->control_register =\r\nHDSPM_ClockModeMaster |\r\nhdspm_encode_latency(7) |\r\nHDSPM_SyncRef0 |\r\nHDSPM_LineOut |\r\nHDSPM_Professional;\r\nbreak;\r\n}\r\nhdspm_write(hdspm, HDSPM_controlRegister, hdspm->control_register);\r\nif (AES32 == hdspm->io_type) {\r\n#ifdef SNDRV_BIG_ENDIAN\r\nhdspm->control2_register = HDSPM_BIGENDIAN_MODE;\r\n#else\r\nhdspm->control2_register = 0;\r\n#endif\r\nhdspm_write(hdspm, HDSPM_control2Reg, hdspm->control2_register);\r\n}\r\nhdspm_compute_period_size(hdspm);\r\nall_in_all_mixer(hdspm, 0 * UNITY_GAIN);\r\nif (hdspm->io_type == AIO || hdspm->io_type == RayDAT) {\r\nhdspm_write(hdspm, HDSPM_WR_SETTINGS, hdspm->settings_register);\r\n}\r\nhdspm_set_rate(hdspm, 48000, 1);\r\nreturn 0;\r\n}\r\nstatic irqreturn_t snd_hdspm_interrupt(int irq, void *dev_id)\r\n{\r\nstruct hdspm *hdspm = (struct hdspm *) dev_id;\r\nunsigned int status;\r\nint i, audio, midi, schedule = 0;\r\nstatus = hdspm_read(hdspm, HDSPM_statusRegister);\r\naudio = status & HDSPM_audioIRQPending;\r\nmidi = status & (HDSPM_midi0IRQPending | HDSPM_midi1IRQPending |\r\nHDSPM_midi2IRQPending | HDSPM_midi3IRQPending);\r\nif (!audio && !midi)\r\nreturn IRQ_NONE;\r\nhdspm_write(hdspm, HDSPM_interruptConfirmation, 0);\r\nhdspm->irq_count++;\r\nif (audio) {\r\nif (hdspm->capture_substream)\r\nsnd_pcm_period_elapsed(hdspm->capture_substream);\r\nif (hdspm->playback_substream)\r\nsnd_pcm_period_elapsed(hdspm->playback_substream);\r\n}\r\nif (midi) {\r\ni = 0;\r\nwhile (i < hdspm->midiPorts) {\r\nif ((hdspm_read(hdspm,\r\nhdspm->midi[i].statusIn) & 0xff) &&\r\n(status & hdspm->midi[i].irq)) {\r\nhdspm->control_register &= ~hdspm->midi[i].ie;\r\nhdspm_write(hdspm, HDSPM_controlRegister,\r\nhdspm->control_register);\r\nhdspm->midi[i].pending = 1;\r\nschedule = 1;\r\n}\r\ni++;\r\n}\r\nif (schedule)\r\ntasklet_hi_schedule(&hdspm->midi_tasklet);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic snd_pcm_uframes_t snd_hdspm_hw_pointer(struct snd_pcm_substream\r\n*substream)\r\n{\r\nstruct hdspm *hdspm = snd_pcm_substream_chip(substream);\r\nreturn hdspm_hw_pointer(hdspm);\r\n}\r\nstatic int snd_hdspm_reset(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct hdspm *hdspm = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_substream *other;\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\r\nother = hdspm->capture_substream;\r\nelse\r\nother = hdspm->playback_substream;\r\nif (hdspm->running)\r\nruntime->status->hw_ptr = hdspm_hw_pointer(hdspm);\r\nelse\r\nruntime->status->hw_ptr = 0;\r\nif (other) {\r\nstruct snd_pcm_substream *s;\r\nstruct snd_pcm_runtime *oruntime = other->runtime;\r\nsnd_pcm_group_for_each_entry(s, substream) {\r\nif (s == other) {\r\noruntime->status->hw_ptr =\r\nruntime->status->hw_ptr;\r\nbreak;\r\n}\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_hdspm_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params)\r\n{\r\nstruct hdspm *hdspm = snd_pcm_substream_chip(substream);\r\nint err;\r\nint i;\r\npid_t this_pid;\r\npid_t other_pid;\r\nspin_lock_irq(&hdspm->lock);\r\nif (substream->pstr->stream == SNDRV_PCM_STREAM_PLAYBACK) {\r\nthis_pid = hdspm->playback_pid;\r\nother_pid = hdspm->capture_pid;\r\n} else {\r\nthis_pid = hdspm->capture_pid;\r\nother_pid = hdspm->playback_pid;\r\n}\r\nif (other_pid > 0 && this_pid != other_pid) {\r\nif (params_rate(params) != hdspm->system_sample_rate) {\r\nspin_unlock_irq(&hdspm->lock);\r\n_snd_pcm_hw_param_setempty(params,\r\nSNDRV_PCM_HW_PARAM_RATE);\r\nreturn -EBUSY;\r\n}\r\nif (params_period_size(params) != hdspm->period_bytes / 4) {\r\nspin_unlock_irq(&hdspm->lock);\r\n_snd_pcm_hw_param_setempty(params,\r\nSNDRV_PCM_HW_PARAM_PERIOD_SIZE);\r\nreturn -EBUSY;\r\n}\r\n}\r\nspin_unlock_irq(&hdspm->lock);\r\nspin_lock_irq(&hdspm->lock);\r\nerr = hdspm_set_rate(hdspm, params_rate(params), 0);\r\nif (err < 0) {\r\nsnd_printk(KERN_INFO "err on hdspm_set_rate: %d\n", err);\r\nspin_unlock_irq(&hdspm->lock);\r\n_snd_pcm_hw_param_setempty(params,\r\nSNDRV_PCM_HW_PARAM_RATE);\r\nreturn err;\r\n}\r\nspin_unlock_irq(&hdspm->lock);\r\nerr = hdspm_set_interrupt_interval(hdspm,\r\nparams_period_size(params));\r\nif (err < 0) {\r\nsnd_printk(KERN_INFO "err on hdspm_set_interrupt_interval: %d\n", err);\r\n_snd_pcm_hw_param_setempty(params,\r\nSNDRV_PCM_HW_PARAM_PERIOD_SIZE);\r\nreturn err;\r\n}\r\nerr =\r\nsnd_pcm_lib_malloc_pages(substream, HDSPM_DMA_AREA_BYTES);\r\nif (err < 0) {\r\nsnd_printk(KERN_INFO "err on snd_pcm_lib_malloc_pages: %d\n", err);\r\nreturn err;\r\n}\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\r\nhdspm_set_sgbuf(hdspm, substream, HDSPM_pageAddressBufferOut,\r\nparams_channels(params));\r\nfor (i = 0; i < params_channels(params); ++i)\r\nsnd_hdspm_enable_out(hdspm, i, 1);\r\nhdspm->playback_buffer =\r\n(unsigned char *) substream->runtime->dma_area;\r\nsnd_printdd("Allocated sample buffer for playback at %p\n",\r\nhdspm->playback_buffer);\r\n} else {\r\nhdspm_set_sgbuf(hdspm, substream, HDSPM_pageAddressBufferIn,\r\nparams_channels(params));\r\nfor (i = 0; i < params_channels(params); ++i)\r\nsnd_hdspm_enable_in(hdspm, i, 1);\r\nhdspm->capture_buffer =\r\n(unsigned char *) substream->runtime->dma_area;\r\nsnd_printdd("Allocated sample buffer for capture at %p\n",\r\nhdspm->capture_buffer);\r\n}\r\nif (SNDRV_PCM_FORMAT_FLOAT_LE == params_format(params)) {\r\nif (!(hdspm->control_register & HDSPe_FLOAT_FORMAT))\r\nsnd_printk(KERN_INFO "hdspm: Switching to native 32bit LE float format.\n");\r\nhdspm->control_register |= HDSPe_FLOAT_FORMAT;\r\n} else if (SNDRV_PCM_FORMAT_S32_LE == params_format(params)) {\r\nif (hdspm->control_register & HDSPe_FLOAT_FORMAT)\r\nsnd_printk(KERN_INFO "hdspm: Switching to native 32bit LE integer format.\n");\r\nhdspm->control_register &= ~HDSPe_FLOAT_FORMAT;\r\n}\r\nhdspm_write(hdspm, HDSPM_controlRegister, hdspm->control_register);\r\nreturn 0;\r\n}\r\nstatic int snd_hdspm_hw_free(struct snd_pcm_substream *substream)\r\n{\r\nint i;\r\nstruct hdspm *hdspm = snd_pcm_substream_chip(substream);\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\r\nfor (i = 0; i < hdspm->max_channels_out; ++i)\r\nsnd_hdspm_enable_out(hdspm, i, 0);\r\nhdspm->playback_buffer = NULL;\r\n} else {\r\nfor (i = 0; i < hdspm->max_channels_in; ++i)\r\nsnd_hdspm_enable_in(hdspm, i, 0);\r\nhdspm->capture_buffer = NULL;\r\n}\r\nsnd_pcm_lib_free_pages(substream);\r\nreturn 0;\r\n}\r\nstatic int snd_hdspm_channel_info(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_channel_info *info)\r\n{\r\nstruct hdspm *hdspm = snd_pcm_substream_chip(substream);\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\r\nif (snd_BUG_ON(info->channel >= hdspm->max_channels_out)) {\r\nsnd_printk(KERN_INFO "snd_hdspm_channel_info: output channel out of range (%d)\n", info->channel);\r\nreturn -EINVAL;\r\n}\r\nif (hdspm->channel_map_out[info->channel] < 0) {\r\nsnd_printk(KERN_INFO "snd_hdspm_channel_info: output channel %d mapped out\n", info->channel);\r\nreturn -EINVAL;\r\n}\r\ninfo->offset = hdspm->channel_map_out[info->channel] *\r\nHDSPM_CHANNEL_BUFFER_BYTES;\r\n} else {\r\nif (snd_BUG_ON(info->channel >= hdspm->max_channels_in)) {\r\nsnd_printk(KERN_INFO "snd_hdspm_channel_info: input channel out of range (%d)\n", info->channel);\r\nreturn -EINVAL;\r\n}\r\nif (hdspm->channel_map_in[info->channel] < 0) {\r\nsnd_printk(KERN_INFO "snd_hdspm_channel_info: input channel %d mapped out\n", info->channel);\r\nreturn -EINVAL;\r\n}\r\ninfo->offset = hdspm->channel_map_in[info->channel] *\r\nHDSPM_CHANNEL_BUFFER_BYTES;\r\n}\r\ninfo->first = 0;\r\ninfo->step = 32;\r\nreturn 0;\r\n}\r\nstatic int snd_hdspm_ioctl(struct snd_pcm_substream *substream,\r\nunsigned int cmd, void *arg)\r\n{\r\nswitch (cmd) {\r\ncase SNDRV_PCM_IOCTL1_RESET:\r\nreturn snd_hdspm_reset(substream);\r\ncase SNDRV_PCM_IOCTL1_CHANNEL_INFO:\r\n{\r\nstruct snd_pcm_channel_info *info = arg;\r\nreturn snd_hdspm_channel_info(substream, info);\r\n}\r\ndefault:\r\nbreak;\r\n}\r\nreturn snd_pcm_lib_ioctl(substream, cmd, arg);\r\n}\r\nstatic int snd_hdspm_trigger(struct snd_pcm_substream *substream, int cmd)\r\n{\r\nstruct hdspm *hdspm = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_substream *other;\r\nint running;\r\nspin_lock(&hdspm->lock);\r\nrunning = hdspm->running;\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\nrunning |= 1 << substream->stream;\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\nrunning &= ~(1 << substream->stream);\r\nbreak;\r\ndefault:\r\nsnd_BUG();\r\nspin_unlock(&hdspm->lock);\r\nreturn -EINVAL;\r\n}\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\r\nother = hdspm->capture_substream;\r\nelse\r\nother = hdspm->playback_substream;\r\nif (other) {\r\nstruct snd_pcm_substream *s;\r\nsnd_pcm_group_for_each_entry(s, substream) {\r\nif (s == other) {\r\nsnd_pcm_trigger_done(s, substream);\r\nif (cmd == SNDRV_PCM_TRIGGER_START)\r\nrunning |= 1 << s->stream;\r\nelse\r\nrunning &= ~(1 << s->stream);\r\ngoto _ok;\r\n}\r\n}\r\nif (cmd == SNDRV_PCM_TRIGGER_START) {\r\nif (!(running & (1 << SNDRV_PCM_STREAM_PLAYBACK))\r\n&& substream->stream ==\r\nSNDRV_PCM_STREAM_CAPTURE)\r\nhdspm_silence_playback(hdspm);\r\n} else {\r\nif (running &&\r\nsubstream->stream == SNDRV_PCM_STREAM_PLAYBACK)\r\nhdspm_silence_playback(hdspm);\r\n}\r\n} else {\r\nif (substream->stream == SNDRV_PCM_STREAM_CAPTURE)\r\nhdspm_silence_playback(hdspm);\r\n}\r\n_ok:\r\nsnd_pcm_trigger_done(substream, substream);\r\nif (!hdspm->running && running)\r\nhdspm_start_audio(hdspm);\r\nelse if (hdspm->running && !running)\r\nhdspm_stop_audio(hdspm);\r\nhdspm->running = running;\r\nspin_unlock(&hdspm->lock);\r\nreturn 0;\r\n}\r\nstatic int snd_hdspm_prepare(struct snd_pcm_substream *substream)\r\n{\r\nreturn 0;\r\n}\r\nstatic int snd_hdspm_hw_rule_in_channels_rate(struct snd_pcm_hw_params *params,\r\nstruct snd_pcm_hw_rule *rule)\r\n{\r\nstruct hdspm *hdspm = rule->private;\r\nstruct snd_interval *c =\r\nhw_param_interval(params, SNDRV_PCM_HW_PARAM_CHANNELS);\r\nstruct snd_interval *r =\r\nhw_param_interval(params, SNDRV_PCM_HW_PARAM_RATE);\r\nif (r->min > 96000 && r->max <= 192000) {\r\nstruct snd_interval t = {\r\n.min = hdspm->qs_in_channels,\r\n.max = hdspm->qs_in_channels,\r\n.integer = 1,\r\n};\r\nreturn snd_interval_refine(c, &t);\r\n} else if (r->min > 48000 && r->max <= 96000) {\r\nstruct snd_interval t = {\r\n.min = hdspm->ds_in_channels,\r\n.max = hdspm->ds_in_channels,\r\n.integer = 1,\r\n};\r\nreturn snd_interval_refine(c, &t);\r\n} else if (r->max < 64000) {\r\nstruct snd_interval t = {\r\n.min = hdspm->ss_in_channels,\r\n.max = hdspm->ss_in_channels,\r\n.integer = 1,\r\n};\r\nreturn snd_interval_refine(c, &t);\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_hdspm_hw_rule_out_channels_rate(struct snd_pcm_hw_params *params,\r\nstruct snd_pcm_hw_rule * rule)\r\n{\r\nstruct hdspm *hdspm = rule->private;\r\nstruct snd_interval *c =\r\nhw_param_interval(params, SNDRV_PCM_HW_PARAM_CHANNELS);\r\nstruct snd_interval *r =\r\nhw_param_interval(params, SNDRV_PCM_HW_PARAM_RATE);\r\nif (r->min > 96000 && r->max <= 192000) {\r\nstruct snd_interval t = {\r\n.min = hdspm->qs_out_channels,\r\n.max = hdspm->qs_out_channels,\r\n.integer = 1,\r\n};\r\nreturn snd_interval_refine(c, &t);\r\n} else if (r->min > 48000 && r->max <= 96000) {\r\nstruct snd_interval t = {\r\n.min = hdspm->ds_out_channels,\r\n.max = hdspm->ds_out_channels,\r\n.integer = 1,\r\n};\r\nreturn snd_interval_refine(c, &t);\r\n} else if (r->max < 64000) {\r\nstruct snd_interval t = {\r\n.min = hdspm->ss_out_channels,\r\n.max = hdspm->ss_out_channels,\r\n.integer = 1,\r\n};\r\nreturn snd_interval_refine(c, &t);\r\n} else {\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_hdspm_hw_rule_rate_in_channels(struct snd_pcm_hw_params *params,\r\nstruct snd_pcm_hw_rule * rule)\r\n{\r\nstruct hdspm *hdspm = rule->private;\r\nstruct snd_interval *c =\r\nhw_param_interval(params, SNDRV_PCM_HW_PARAM_CHANNELS);\r\nstruct snd_interval *r =\r\nhw_param_interval(params, SNDRV_PCM_HW_PARAM_RATE);\r\nif (c->min >= hdspm->ss_in_channels) {\r\nstruct snd_interval t = {\r\n.min = 32000,\r\n.max = 48000,\r\n.integer = 1,\r\n};\r\nreturn snd_interval_refine(r, &t);\r\n} else if (c->max <= hdspm->qs_in_channels) {\r\nstruct snd_interval t = {\r\n.min = 128000,\r\n.max = 192000,\r\n.integer = 1,\r\n};\r\nreturn snd_interval_refine(r, &t);\r\n} else if (c->max <= hdspm->ds_in_channels) {\r\nstruct snd_interval t = {\r\n.min = 64000,\r\n.max = 96000,\r\n.integer = 1,\r\n};\r\nreturn snd_interval_refine(r, &t);\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_hdspm_hw_rule_rate_out_channels(struct snd_pcm_hw_params *params,\r\nstruct snd_pcm_hw_rule *rule)\r\n{\r\nstruct hdspm *hdspm = rule->private;\r\nstruct snd_interval *c =\r\nhw_param_interval(params, SNDRV_PCM_HW_PARAM_CHANNELS);\r\nstruct snd_interval *r =\r\nhw_param_interval(params, SNDRV_PCM_HW_PARAM_RATE);\r\nif (c->min >= hdspm->ss_out_channels) {\r\nstruct snd_interval t = {\r\n.min = 32000,\r\n.max = 48000,\r\n.integer = 1,\r\n};\r\nreturn snd_interval_refine(r, &t);\r\n} else if (c->max <= hdspm->qs_out_channels) {\r\nstruct snd_interval t = {\r\n.min = 128000,\r\n.max = 192000,\r\n.integer = 1,\r\n};\r\nreturn snd_interval_refine(r, &t);\r\n} else if (c->max <= hdspm->ds_out_channels) {\r\nstruct snd_interval t = {\r\n.min = 64000,\r\n.max = 96000,\r\n.integer = 1,\r\n};\r\nreturn snd_interval_refine(r, &t);\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_hdspm_hw_rule_in_channels(struct snd_pcm_hw_params *params,\r\nstruct snd_pcm_hw_rule *rule)\r\n{\r\nunsigned int list[3];\r\nstruct hdspm *hdspm = rule->private;\r\nstruct snd_interval *c = hw_param_interval(params,\r\nSNDRV_PCM_HW_PARAM_CHANNELS);\r\nlist[0] = hdspm->qs_in_channels;\r\nlist[1] = hdspm->ds_in_channels;\r\nlist[2] = hdspm->ss_in_channels;\r\nreturn snd_interval_list(c, 3, list, 0);\r\n}\r\nstatic int snd_hdspm_hw_rule_out_channels(struct snd_pcm_hw_params *params,\r\nstruct snd_pcm_hw_rule *rule)\r\n{\r\nunsigned int list[3];\r\nstruct hdspm *hdspm = rule->private;\r\nstruct snd_interval *c = hw_param_interval(params,\r\nSNDRV_PCM_HW_PARAM_CHANNELS);\r\nlist[0] = hdspm->qs_out_channels;\r\nlist[1] = hdspm->ds_out_channels;\r\nlist[2] = hdspm->ss_out_channels;\r\nreturn snd_interval_list(c, 3, list, 0);\r\n}\r\nstatic int snd_hdspm_playback_open(struct snd_pcm_substream *substream)\r\n{\r\nstruct hdspm *hdspm = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nspin_lock_irq(&hdspm->lock);\r\nsnd_pcm_set_sync(substream);\r\nruntime->hw = snd_hdspm_playback_subinfo;\r\nif (hdspm->capture_substream == NULL)\r\nhdspm_stop_audio(hdspm);\r\nhdspm->playback_pid = current->pid;\r\nhdspm->playback_substream = substream;\r\nspin_unlock_irq(&hdspm->lock);\r\nsnd_pcm_hw_constraint_msbits(runtime, 0, 32, 24);\r\nsnd_pcm_hw_constraint_pow2(runtime, 0, SNDRV_PCM_HW_PARAM_PERIOD_SIZE);\r\nswitch (hdspm->io_type) {\r\ncase AIO:\r\ncase RayDAT:\r\nsnd_pcm_hw_constraint_minmax(runtime,\r\nSNDRV_PCM_HW_PARAM_PERIOD_SIZE,\r\n32, 4096);\r\nsnd_pcm_hw_constraint_minmax(runtime,\r\nSNDRV_PCM_HW_PARAM_BUFFER_SIZE,\r\n16384, 16384);\r\nbreak;\r\ndefault:\r\nsnd_pcm_hw_constraint_minmax(runtime,\r\nSNDRV_PCM_HW_PARAM_PERIOD_SIZE,\r\n64, 8192);\r\nbreak;\r\n}\r\nif (AES32 == hdspm->io_type) {\r\nruntime->hw.rates |= SNDRV_PCM_RATE_KNOT;\r\nsnd_pcm_hw_constraint_list(runtime, 0, SNDRV_PCM_HW_PARAM_RATE,\r\n&hdspm_hw_constraints_aes32_sample_rates);\r\n} else {\r\nsnd_pcm_hw_rule_add(runtime, 0, SNDRV_PCM_HW_PARAM_RATE,\r\nsnd_hdspm_hw_rule_rate_out_channels, hdspm,\r\nSNDRV_PCM_HW_PARAM_CHANNELS, -1);\r\n}\r\nsnd_pcm_hw_rule_add(runtime, 0, SNDRV_PCM_HW_PARAM_CHANNELS,\r\nsnd_hdspm_hw_rule_out_channels, hdspm,\r\nSNDRV_PCM_HW_PARAM_CHANNELS, -1);\r\nsnd_pcm_hw_rule_add(runtime, 0, SNDRV_PCM_HW_PARAM_CHANNELS,\r\nsnd_hdspm_hw_rule_out_channels_rate, hdspm,\r\nSNDRV_PCM_HW_PARAM_RATE, -1);\r\nreturn 0;\r\n}\r\nstatic int snd_hdspm_playback_release(struct snd_pcm_substream *substream)\r\n{\r\nstruct hdspm *hdspm = snd_pcm_substream_chip(substream);\r\nspin_lock_irq(&hdspm->lock);\r\nhdspm->playback_pid = -1;\r\nhdspm->playback_substream = NULL;\r\nspin_unlock_irq(&hdspm->lock);\r\nreturn 0;\r\n}\r\nstatic int snd_hdspm_capture_open(struct snd_pcm_substream *substream)\r\n{\r\nstruct hdspm *hdspm = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nspin_lock_irq(&hdspm->lock);\r\nsnd_pcm_set_sync(substream);\r\nruntime->hw = snd_hdspm_capture_subinfo;\r\nif (hdspm->playback_substream == NULL)\r\nhdspm_stop_audio(hdspm);\r\nhdspm->capture_pid = current->pid;\r\nhdspm->capture_substream = substream;\r\nspin_unlock_irq(&hdspm->lock);\r\nsnd_pcm_hw_constraint_msbits(runtime, 0, 32, 24);\r\nsnd_pcm_hw_constraint_pow2(runtime, 0, SNDRV_PCM_HW_PARAM_PERIOD_SIZE);\r\nswitch (hdspm->io_type) {\r\ncase AIO:\r\ncase RayDAT:\r\nsnd_pcm_hw_constraint_minmax(runtime,\r\nSNDRV_PCM_HW_PARAM_PERIOD_SIZE,\r\n32, 4096);\r\nsnd_pcm_hw_constraint_minmax(runtime,\r\nSNDRV_PCM_HW_PARAM_BUFFER_SIZE,\r\n16384, 16384);\r\nbreak;\r\ndefault:\r\nsnd_pcm_hw_constraint_minmax(runtime,\r\nSNDRV_PCM_HW_PARAM_PERIOD_SIZE,\r\n64, 8192);\r\nbreak;\r\n}\r\nif (AES32 == hdspm->io_type) {\r\nruntime->hw.rates |= SNDRV_PCM_RATE_KNOT;\r\nsnd_pcm_hw_constraint_list(runtime, 0, SNDRV_PCM_HW_PARAM_RATE,\r\n&hdspm_hw_constraints_aes32_sample_rates);\r\n} else {\r\nsnd_pcm_hw_rule_add(runtime, 0, SNDRV_PCM_HW_PARAM_RATE,\r\nsnd_hdspm_hw_rule_rate_in_channels, hdspm,\r\nSNDRV_PCM_HW_PARAM_CHANNELS, -1);\r\n}\r\nsnd_pcm_hw_rule_add(runtime, 0, SNDRV_PCM_HW_PARAM_CHANNELS,\r\nsnd_hdspm_hw_rule_in_channels, hdspm,\r\nSNDRV_PCM_HW_PARAM_CHANNELS, -1);\r\nsnd_pcm_hw_rule_add(runtime, 0, SNDRV_PCM_HW_PARAM_CHANNELS,\r\nsnd_hdspm_hw_rule_in_channels_rate, hdspm,\r\nSNDRV_PCM_HW_PARAM_RATE, -1);\r\nreturn 0;\r\n}\r\nstatic int snd_hdspm_capture_release(struct snd_pcm_substream *substream)\r\n{\r\nstruct hdspm *hdspm = snd_pcm_substream_chip(substream);\r\nspin_lock_irq(&hdspm->lock);\r\nhdspm->capture_pid = -1;\r\nhdspm->capture_substream = NULL;\r\nspin_unlock_irq(&hdspm->lock);\r\nreturn 0;\r\n}\r\nstatic int snd_hdspm_hwdep_dummy_op(struct snd_hwdep *hw, struct file *file)\r\n{\r\nreturn 0;\r\n}\r\nstatic inline int copy_u32_le(void __user *dest, void __iomem *src)\r\n{\r\nu32 val = readl(src);\r\nreturn copy_to_user(dest, &val, 4);\r\n}\r\nstatic int snd_hdspm_hwdep_ioctl(struct snd_hwdep *hw, struct file *file,\r\nunsigned int cmd, unsigned long arg)\r\n{\r\nvoid __user *argp = (void __user *)arg;\r\nstruct hdspm *hdspm = hw->private_data;\r\nstruct hdspm_mixer_ioctl mixer;\r\nstruct hdspm_config info;\r\nstruct hdspm_status status;\r\nstruct hdspm_version hdspm_version;\r\nstruct hdspm_peak_rms *levels;\r\nstruct hdspm_ltc ltc;\r\nunsigned int statusregister;\r\nlong unsigned int s;\r\nint i = 0;\r\nswitch (cmd) {\r\ncase SNDRV_HDSPM_IOCTL_GET_PEAK_RMS:\r\nlevels = &hdspm->peak_rms;\r\nfor (i = 0; i < HDSPM_MAX_CHANNELS; i++) {\r\nlevels->input_peaks[i] =\r\nreadl(hdspm->iobase +\r\nHDSPM_MADI_INPUT_PEAK + i*4);\r\nlevels->playback_peaks[i] =\r\nreadl(hdspm->iobase +\r\nHDSPM_MADI_PLAYBACK_PEAK + i*4);\r\nlevels->output_peaks[i] =\r\nreadl(hdspm->iobase +\r\nHDSPM_MADI_OUTPUT_PEAK + i*4);\r\nlevels->input_rms[i] =\r\n((uint64_t) readl(hdspm->iobase +\r\nHDSPM_MADI_INPUT_RMS_H + i*4) << 32) |\r\n(uint64_t) readl(hdspm->iobase +\r\nHDSPM_MADI_INPUT_RMS_L + i*4);\r\nlevels->playback_rms[i] =\r\n((uint64_t)readl(hdspm->iobase +\r\nHDSPM_MADI_PLAYBACK_RMS_H+i*4) << 32) |\r\n(uint64_t)readl(hdspm->iobase +\r\nHDSPM_MADI_PLAYBACK_RMS_L + i*4);\r\nlevels->output_rms[i] =\r\n((uint64_t)readl(hdspm->iobase +\r\nHDSPM_MADI_OUTPUT_RMS_H + i*4) << 32) |\r\n(uint64_t)readl(hdspm->iobase +\r\nHDSPM_MADI_OUTPUT_RMS_L + i*4);\r\n}\r\nif (hdspm->system_sample_rate > 96000) {\r\nlevels->speed = qs;\r\n} else if (hdspm->system_sample_rate > 48000) {\r\nlevels->speed = ds;\r\n} else {\r\nlevels->speed = ss;\r\n}\r\nlevels->status2 = hdspm_read(hdspm, HDSPM_statusRegister2);\r\ns = copy_to_user(argp, levels, sizeof(struct hdspm_peak_rms));\r\nif (0 != s) {\r\nreturn -EFAULT;\r\n}\r\nbreak;\r\ncase SNDRV_HDSPM_IOCTL_GET_LTC:\r\nltc.ltc = hdspm_read(hdspm, HDSPM_RD_TCO);\r\ni = hdspm_read(hdspm, HDSPM_RD_TCO + 4);\r\nif (i & HDSPM_TCO1_LTC_Input_valid) {\r\nswitch (i & (HDSPM_TCO1_LTC_Format_LSB |\r\nHDSPM_TCO1_LTC_Format_MSB)) {\r\ncase 0:\r\nltc.format = fps_24;\r\nbreak;\r\ncase HDSPM_TCO1_LTC_Format_LSB:\r\nltc.format = fps_25;\r\nbreak;\r\ncase HDSPM_TCO1_LTC_Format_MSB:\r\nltc.format = fps_2997;\r\nbreak;\r\ndefault:\r\nltc.format = 30;\r\nbreak;\r\n}\r\nif (i & HDSPM_TCO1_set_drop_frame_flag) {\r\nltc.frame = drop_frame;\r\n} else {\r\nltc.frame = full_frame;\r\n}\r\n} else {\r\nltc.format = format_invalid;\r\nltc.frame = frame_invalid;\r\n}\r\nif (i & HDSPM_TCO1_Video_Input_Format_NTSC) {\r\nltc.input_format = ntsc;\r\n} else if (i & HDSPM_TCO1_Video_Input_Format_PAL) {\r\nltc.input_format = pal;\r\n} else {\r\nltc.input_format = no_video;\r\n}\r\ns = copy_to_user(argp, &ltc, sizeof(struct hdspm_ltc));\r\nif (0 != s) {\r\nreturn -EFAULT;\r\n}\r\nbreak;\r\ncase SNDRV_HDSPM_IOCTL_GET_CONFIG:\r\nmemset(&info, 0, sizeof(info));\r\nspin_lock_irq(&hdspm->lock);\r\ninfo.pref_sync_ref = hdspm_pref_sync_ref(hdspm);\r\ninfo.wordclock_sync_check = hdspm_wc_sync_check(hdspm);\r\ninfo.system_sample_rate = hdspm->system_sample_rate;\r\ninfo.autosync_sample_rate =\r\nhdspm_external_sample_rate(hdspm);\r\ninfo.system_clock_mode = hdspm_system_clock_mode(hdspm);\r\ninfo.clock_source = hdspm_clock_source(hdspm);\r\ninfo.autosync_ref = hdspm_autosync_ref(hdspm);\r\ninfo.line_out = hdspm_toggle_setting(hdspm, HDSPM_LineOut);\r\ninfo.passthru = 0;\r\nspin_unlock_irq(&hdspm->lock);\r\nif (copy_to_user(argp, &info, sizeof(info)))\r\nreturn -EFAULT;\r\nbreak;\r\ncase SNDRV_HDSPM_IOCTL_GET_STATUS:\r\nmemset(&status, 0, sizeof(status));\r\nstatus.card_type = hdspm->io_type;\r\nstatus.autosync_source = hdspm_autosync_ref(hdspm);\r\nstatus.card_clock = 110069313433624ULL;\r\nstatus.master_period = hdspm_read(hdspm, HDSPM_RD_PLL_FREQ);\r\nswitch (hdspm->io_type) {\r\ncase MADI:\r\ncase MADIface:\r\nstatus.card_specific.madi.sync_wc =\r\nhdspm_wc_sync_check(hdspm);\r\nstatus.card_specific.madi.sync_madi =\r\nhdspm_madi_sync_check(hdspm);\r\nstatus.card_specific.madi.sync_tco =\r\nhdspm_tco_sync_check(hdspm);\r\nstatus.card_specific.madi.sync_in =\r\nhdspm_sync_in_sync_check(hdspm);\r\nstatusregister =\r\nhdspm_read(hdspm, HDSPM_statusRegister);\r\nstatus.card_specific.madi.madi_input =\r\n(statusregister & HDSPM_AB_int) ? 1 : 0;\r\nstatus.card_specific.madi.channel_format =\r\n(statusregister & HDSPM_RX_64ch) ? 1 : 0;\r\nstatus.card_specific.madi.frame_format = 0;\r\ndefault:\r\nbreak;\r\n}\r\nif (copy_to_user(argp, &status, sizeof(status)))\r\nreturn -EFAULT;\r\nbreak;\r\ncase SNDRV_HDSPM_IOCTL_GET_VERSION:\r\nmemset(&hdspm_version, 0, sizeof(hdspm_version));\r\nhdspm_version.card_type = hdspm->io_type;\r\nstrncpy(hdspm_version.cardname, hdspm->card_name,\r\nsizeof(hdspm_version.cardname));\r\nhdspm_version.serial = hdspm->serial;\r\nhdspm_version.firmware_rev = hdspm->firmware_rev;\r\nhdspm_version.addons = 0;\r\nif (hdspm->tco)\r\nhdspm_version.addons |= HDSPM_ADDON_TCO;\r\nif (copy_to_user(argp, &hdspm_version,\r\nsizeof(hdspm_version)))\r\nreturn -EFAULT;\r\nbreak;\r\ncase SNDRV_HDSPM_IOCTL_GET_MIXER:\r\nif (copy_from_user(&mixer, argp, sizeof(mixer)))\r\nreturn -EFAULT;\r\nif (copy_to_user((void __user *)mixer.mixer, hdspm->mixer,\r\nsizeof(struct hdspm_mixer)))\r\nreturn -EFAULT;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_hdspm_create_hwdep(struct snd_card *card,\r\nstruct hdspm *hdspm)\r\n{\r\nstruct snd_hwdep *hw;\r\nint err;\r\nerr = snd_hwdep_new(card, "HDSPM hwdep", 0, &hw);\r\nif (err < 0)\r\nreturn err;\r\nhdspm->hwdep = hw;\r\nhw->private_data = hdspm;\r\nstrcpy(hw->name, "HDSPM hwdep interface");\r\nhw->ops.open = snd_hdspm_hwdep_dummy_op;\r\nhw->ops.ioctl = snd_hdspm_hwdep_ioctl;\r\nhw->ops.ioctl_compat = snd_hdspm_hwdep_ioctl;\r\nhw->ops.release = snd_hdspm_hwdep_dummy_op;\r\nreturn 0;\r\n}\r\nstatic int snd_hdspm_preallocate_memory(struct hdspm *hdspm)\r\n{\r\nint err;\r\nstruct snd_pcm *pcm;\r\nsize_t wanted;\r\npcm = hdspm->pcm;\r\nwanted = HDSPM_DMA_AREA_BYTES;\r\nerr =\r\nsnd_pcm_lib_preallocate_pages_for_all(pcm,\r\nSNDRV_DMA_TYPE_DEV_SG,\r\nsnd_dma_pci_data(hdspm->pci),\r\nwanted,\r\nwanted);\r\nif (err < 0) {\r\nsnd_printdd("Could not preallocate %zd Bytes\n", wanted);\r\nreturn err;\r\n} else\r\nsnd_printdd(" Preallocated %zd Bytes\n", wanted);\r\nreturn 0;\r\n}\r\nstatic void hdspm_set_sgbuf(struct hdspm *hdspm,\r\nstruct snd_pcm_substream *substream,\r\nunsigned int reg, int channels)\r\n{\r\nint i;\r\nfor (i = 0; i < (channels * 16); i++)\r\nhdspm_write(hdspm, reg + 4 * i,\r\nsnd_pcm_sgbuf_get_addr(substream, 4096 * i));\r\n}\r\nstatic int snd_hdspm_create_pcm(struct snd_card *card,\r\nstruct hdspm *hdspm)\r\n{\r\nstruct snd_pcm *pcm;\r\nint err;\r\nerr = snd_pcm_new(card, hdspm->card_name, 0, 1, 1, &pcm);\r\nif (err < 0)\r\nreturn err;\r\nhdspm->pcm = pcm;\r\npcm->private_data = hdspm;\r\nstrcpy(pcm->name, hdspm->card_name);\r\nsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK,\r\n&snd_hdspm_playback_ops);\r\nsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE,\r\n&snd_hdspm_capture_ops);\r\npcm->info_flags = SNDRV_PCM_INFO_JOINT_DUPLEX;\r\nerr = snd_hdspm_preallocate_memory(hdspm);\r\nif (err < 0)\r\nreturn err;\r\nreturn 0;\r\n}\r\nstatic inline void snd_hdspm_initialize_midi_flush(struct hdspm * hdspm)\r\n{\r\nint i;\r\nfor (i = 0; i < hdspm->midiPorts; i++)\r\nsnd_hdspm_flush_midi_input(hdspm, i);\r\n}\r\nstatic int snd_hdspm_create_alsa_devices(struct snd_card *card,\r\nstruct hdspm *hdspm)\r\n{\r\nint err, i;\r\nsnd_printdd("Create card...\n");\r\nerr = snd_hdspm_create_pcm(card, hdspm);\r\nif (err < 0)\r\nreturn err;\r\ni = 0;\r\nwhile (i < hdspm->midiPorts) {\r\nerr = snd_hdspm_create_midi(card, hdspm, i);\r\nif (err < 0) {\r\nreturn err;\r\n}\r\ni++;\r\n}\r\nerr = snd_hdspm_create_controls(card, hdspm);\r\nif (err < 0)\r\nreturn err;\r\nerr = snd_hdspm_create_hwdep(card, hdspm);\r\nif (err < 0)\r\nreturn err;\r\nsnd_printdd("proc init...\n");\r\nsnd_hdspm_proc_init(hdspm);\r\nhdspm->system_sample_rate = -1;\r\nhdspm->last_external_sample_rate = -1;\r\nhdspm->last_internal_sample_rate = -1;\r\nhdspm->playback_pid = -1;\r\nhdspm->capture_pid = -1;\r\nhdspm->capture_substream = NULL;\r\nhdspm->playback_substream = NULL;\r\nsnd_printdd("Set defaults...\n");\r\nerr = snd_hdspm_set_defaults(hdspm);\r\nif (err < 0)\r\nreturn err;\r\nsnd_printdd("Update mixer controls...\n");\r\nhdspm_update_simple_mixer_controls(hdspm);\r\nsnd_printdd("Initializeing complete ???\n");\r\nerr = snd_card_register(card);\r\nif (err < 0) {\r\nsnd_printk(KERN_ERR "HDSPM: error registering card\n");\r\nreturn err;\r\n}\r\nsnd_printdd("... yes now\n");\r\nreturn 0;\r\n}\r\nstatic int snd_hdspm_create(struct snd_card *card,\r\nstruct hdspm *hdspm)\r\n{\r\nstruct pci_dev *pci = hdspm->pci;\r\nint err;\r\nunsigned long io_extent;\r\nhdspm->irq = -1;\r\nhdspm->card = card;\r\nspin_lock_init(&hdspm->lock);\r\npci_read_config_word(hdspm->pci,\r\nPCI_CLASS_REVISION, &hdspm->firmware_rev);\r\nstrcpy(card->mixername, "Xilinx FPGA");\r\nstrcpy(card->driver, "HDSPM");\r\nswitch (hdspm->firmware_rev) {\r\ncase HDSPM_RAYDAT_REV:\r\nhdspm->io_type = RayDAT;\r\nhdspm->card_name = "RME RayDAT";\r\nhdspm->midiPorts = 2;\r\nbreak;\r\ncase HDSPM_AIO_REV:\r\nhdspm->io_type = AIO;\r\nhdspm->card_name = "RME AIO";\r\nhdspm->midiPorts = 1;\r\nbreak;\r\ncase HDSPM_MADIFACE_REV:\r\nhdspm->io_type = MADIface;\r\nhdspm->card_name = "RME MADIface";\r\nhdspm->midiPorts = 1;\r\nbreak;\r\ndefault:\r\nif ((hdspm->firmware_rev == 0xf0) ||\r\n((hdspm->firmware_rev >= 0xe6) &&\r\n(hdspm->firmware_rev <= 0xea))) {\r\nhdspm->io_type = AES32;\r\nhdspm->card_name = "RME AES32";\r\nhdspm->midiPorts = 2;\r\n} else if ((hdspm->firmware_rev == 0xd2) ||\r\n((hdspm->firmware_rev >= 0xc8) &&\r\n(hdspm->firmware_rev <= 0xcf))) {\r\nhdspm->io_type = MADI;\r\nhdspm->card_name = "RME MADI";\r\nhdspm->midiPorts = 3;\r\n} else {\r\nsnd_printk(KERN_ERR\r\n"HDSPM: unknown firmware revision %x\n",\r\nhdspm->firmware_rev);\r\nreturn -ENODEV;\r\n}\r\n}\r\nerr = pci_enable_device(pci);\r\nif (err < 0)\r\nreturn err;\r\npci_set_master(hdspm->pci);\r\nerr = pci_request_regions(pci, "hdspm");\r\nif (err < 0)\r\nreturn err;\r\nhdspm->port = pci_resource_start(pci, 0);\r\nio_extent = pci_resource_len(pci, 0);\r\nsnd_printdd("grabbed memory region 0x%lx-0x%lx\n",\r\nhdspm->port, hdspm->port + io_extent - 1);\r\nhdspm->iobase = ioremap_nocache(hdspm->port, io_extent);\r\nif (!hdspm->iobase) {\r\nsnd_printk(KERN_ERR "HDSPM: "\r\n"unable to remap region 0x%lx-0x%lx\n",\r\nhdspm->port, hdspm->port + io_extent - 1);\r\nreturn -EBUSY;\r\n}\r\nsnd_printdd("remapped region (0x%lx) 0x%lx-0x%lx\n",\r\n(unsigned long)hdspm->iobase, hdspm->port,\r\nhdspm->port + io_extent - 1);\r\nif (request_irq(pci->irq, snd_hdspm_interrupt,\r\nIRQF_SHARED, KBUILD_MODNAME, hdspm)) {\r\nsnd_printk(KERN_ERR "HDSPM: unable to use IRQ %d\n", pci->irq);\r\nreturn -EBUSY;\r\n}\r\nsnd_printdd("use IRQ %d\n", pci->irq);\r\nhdspm->irq = pci->irq;\r\nsnd_printdd("kmalloc Mixer memory of %zd Bytes\n",\r\nsizeof(struct hdspm_mixer));\r\nhdspm->mixer = kzalloc(sizeof(struct hdspm_mixer), GFP_KERNEL);\r\nif (!hdspm->mixer) {\r\nsnd_printk(KERN_ERR "HDSPM: "\r\n"unable to kmalloc Mixer memory of %d Bytes\n",\r\n(int)sizeof(struct hdspm_mixer));\r\nreturn -ENOMEM;\r\n}\r\nhdspm->port_names_in = NULL;\r\nhdspm->port_names_out = NULL;\r\nswitch (hdspm->io_type) {\r\ncase AES32:\r\nhdspm->ss_in_channels = hdspm->ss_out_channels = AES32_CHANNELS;\r\nhdspm->ds_in_channels = hdspm->ds_out_channels = AES32_CHANNELS;\r\nhdspm->qs_in_channels = hdspm->qs_out_channels = AES32_CHANNELS;\r\nhdspm->channel_map_in_ss = hdspm->channel_map_out_ss =\r\nchannel_map_aes32;\r\nhdspm->channel_map_in_ds = hdspm->channel_map_out_ds =\r\nchannel_map_aes32;\r\nhdspm->channel_map_in_qs = hdspm->channel_map_out_qs =\r\nchannel_map_aes32;\r\nhdspm->port_names_in_ss = hdspm->port_names_out_ss =\r\ntexts_ports_aes32;\r\nhdspm->port_names_in_ds = hdspm->port_names_out_ds =\r\ntexts_ports_aes32;\r\nhdspm->port_names_in_qs = hdspm->port_names_out_qs =\r\ntexts_ports_aes32;\r\nhdspm->max_channels_out = hdspm->max_channels_in =\r\nAES32_CHANNELS;\r\nhdspm->port_names_in = hdspm->port_names_out =\r\ntexts_ports_aes32;\r\nhdspm->channel_map_in = hdspm->channel_map_out =\r\nchannel_map_aes32;\r\nbreak;\r\ncase MADI:\r\ncase MADIface:\r\nhdspm->ss_in_channels = hdspm->ss_out_channels =\r\nMADI_SS_CHANNELS;\r\nhdspm->ds_in_channels = hdspm->ds_out_channels =\r\nMADI_DS_CHANNELS;\r\nhdspm->qs_in_channels = hdspm->qs_out_channels =\r\nMADI_QS_CHANNELS;\r\nhdspm->channel_map_in_ss = hdspm->channel_map_out_ss =\r\nchannel_map_unity_ss;\r\nhdspm->channel_map_in_ds = hdspm->channel_map_out_ds =\r\nchannel_map_unity_ss;\r\nhdspm->channel_map_in_qs = hdspm->channel_map_out_qs =\r\nchannel_map_unity_ss;\r\nhdspm->port_names_in_ss = hdspm->port_names_out_ss =\r\ntexts_ports_madi;\r\nhdspm->port_names_in_ds = hdspm->port_names_out_ds =\r\ntexts_ports_madi;\r\nhdspm->port_names_in_qs = hdspm->port_names_out_qs =\r\ntexts_ports_madi;\r\nbreak;\r\ncase AIO:\r\nif (0 == (hdspm_read(hdspm, HDSPM_statusRegister2) & HDSPM_s2_AEBI_D)) {\r\nsnd_printk(KERN_INFO "HDSPM: AEB input board found, but not supported\n");\r\n}\r\nhdspm->ss_in_channels = AIO_IN_SS_CHANNELS;\r\nhdspm->ds_in_channels = AIO_IN_DS_CHANNELS;\r\nhdspm->qs_in_channels = AIO_IN_QS_CHANNELS;\r\nhdspm->ss_out_channels = AIO_OUT_SS_CHANNELS;\r\nhdspm->ds_out_channels = AIO_OUT_DS_CHANNELS;\r\nhdspm->qs_out_channels = AIO_OUT_QS_CHANNELS;\r\nhdspm->channel_map_out_ss = channel_map_aio_out_ss;\r\nhdspm->channel_map_out_ds = channel_map_aio_out_ds;\r\nhdspm->channel_map_out_qs = channel_map_aio_out_qs;\r\nhdspm->channel_map_in_ss = channel_map_aio_in_ss;\r\nhdspm->channel_map_in_ds = channel_map_aio_in_ds;\r\nhdspm->channel_map_in_qs = channel_map_aio_in_qs;\r\nhdspm->port_names_in_ss = texts_ports_aio_in_ss;\r\nhdspm->port_names_out_ss = texts_ports_aio_out_ss;\r\nhdspm->port_names_in_ds = texts_ports_aio_in_ds;\r\nhdspm->port_names_out_ds = texts_ports_aio_out_ds;\r\nhdspm->port_names_in_qs = texts_ports_aio_in_qs;\r\nhdspm->port_names_out_qs = texts_ports_aio_out_qs;\r\nbreak;\r\ncase RayDAT:\r\nhdspm->ss_in_channels = hdspm->ss_out_channels =\r\nRAYDAT_SS_CHANNELS;\r\nhdspm->ds_in_channels = hdspm->ds_out_channels =\r\nRAYDAT_DS_CHANNELS;\r\nhdspm->qs_in_channels = hdspm->qs_out_channels =\r\nRAYDAT_QS_CHANNELS;\r\nhdspm->max_channels_in = RAYDAT_SS_CHANNELS;\r\nhdspm->max_channels_out = RAYDAT_SS_CHANNELS;\r\nhdspm->channel_map_in_ss = hdspm->channel_map_out_ss =\r\nchannel_map_raydat_ss;\r\nhdspm->channel_map_in_ds = hdspm->channel_map_out_ds =\r\nchannel_map_raydat_ds;\r\nhdspm->channel_map_in_qs = hdspm->channel_map_out_qs =\r\nchannel_map_raydat_qs;\r\nhdspm->channel_map_in = hdspm->channel_map_out =\r\nchannel_map_raydat_ss;\r\nhdspm->port_names_in_ss = hdspm->port_names_out_ss =\r\ntexts_ports_raydat_ss;\r\nhdspm->port_names_in_ds = hdspm->port_names_out_ds =\r\ntexts_ports_raydat_ds;\r\nhdspm->port_names_in_qs = hdspm->port_names_out_qs =\r\ntexts_ports_raydat_qs;\r\nbreak;\r\n}\r\nswitch (hdspm->io_type) {\r\ncase AIO:\r\ncase RayDAT:\r\nif (hdspm_read(hdspm, HDSPM_statusRegister2) &\r\nHDSPM_s2_tco_detect) {\r\nhdspm->midiPorts++;\r\nhdspm->tco = kzalloc(sizeof(struct hdspm_tco),\r\nGFP_KERNEL);\r\nif (NULL != hdspm->tco) {\r\nhdspm_tco_write(hdspm);\r\n}\r\nsnd_printk(KERN_INFO "HDSPM: AIO/RayDAT TCO module found\n");\r\n} else {\r\nhdspm->tco = NULL;\r\n}\r\nbreak;\r\ncase MADI:\r\nif (hdspm_read(hdspm, HDSPM_statusRegister) & HDSPM_tco_detect) {\r\nhdspm->midiPorts++;\r\nhdspm->tco = kzalloc(sizeof(struct hdspm_tco),\r\nGFP_KERNEL);\r\nif (NULL != hdspm->tco) {\r\nhdspm_tco_write(hdspm);\r\n}\r\nsnd_printk(KERN_INFO "HDSPM: MADI TCO module found\n");\r\n} else {\r\nhdspm->tco = NULL;\r\n}\r\nbreak;\r\ndefault:\r\nhdspm->tco = NULL;\r\n}\r\nswitch (hdspm->io_type) {\r\ncase AES32:\r\nif (hdspm->tco) {\r\nhdspm->texts_autosync = texts_autosync_aes_tco;\r\nhdspm->texts_autosync_items = 10;\r\n} else {\r\nhdspm->texts_autosync = texts_autosync_aes;\r\nhdspm->texts_autosync_items = 9;\r\n}\r\nbreak;\r\ncase MADI:\r\nif (hdspm->tco) {\r\nhdspm->texts_autosync = texts_autosync_madi_tco;\r\nhdspm->texts_autosync_items = 4;\r\n} else {\r\nhdspm->texts_autosync = texts_autosync_madi;\r\nhdspm->texts_autosync_items = 3;\r\n}\r\nbreak;\r\ncase MADIface:\r\nbreak;\r\ncase RayDAT:\r\nif (hdspm->tco) {\r\nhdspm->texts_autosync = texts_autosync_raydat_tco;\r\nhdspm->texts_autosync_items = 9;\r\n} else {\r\nhdspm->texts_autosync = texts_autosync_raydat;\r\nhdspm->texts_autosync_items = 8;\r\n}\r\nbreak;\r\ncase AIO:\r\nif (hdspm->tco) {\r\nhdspm->texts_autosync = texts_autosync_aio_tco;\r\nhdspm->texts_autosync_items = 6;\r\n} else {\r\nhdspm->texts_autosync = texts_autosync_aio;\r\nhdspm->texts_autosync_items = 5;\r\n}\r\nbreak;\r\n}\r\ntasklet_init(&hdspm->midi_tasklet,\r\nhdspm_midi_tasklet, (unsigned long) hdspm);\r\nif (hdspm->io_type != MADIface) {\r\nhdspm->serial = (hdspm_read(hdspm,\r\nHDSPM_midiStatusIn0)>>8) & 0xFFFFFF;\r\nif (NULL == id[hdspm->dev] && hdspm->serial != 0xFFFFFF) {\r\nsprintf(card->id, "HDSPMx%06x", hdspm->serial);\r\nsnd_card_set_id(card, card->id);\r\n}\r\n}\r\nsnd_printdd("create alsa devices.\n");\r\nerr = snd_hdspm_create_alsa_devices(card, hdspm);\r\nif (err < 0)\r\nreturn err;\r\nsnd_hdspm_initialize_midi_flush(hdspm);\r\nreturn 0;\r\n}\r\nstatic int snd_hdspm_free(struct hdspm * hdspm)\r\n{\r\nif (hdspm->port) {\r\nhdspm->control_register &=\r\n~(HDSPM_Start | HDSPM_AudioInterruptEnable |\r\nHDSPM_Midi0InterruptEnable | HDSPM_Midi1InterruptEnable |\r\nHDSPM_Midi2InterruptEnable | HDSPM_Midi3InterruptEnable);\r\nhdspm_write(hdspm, HDSPM_controlRegister,\r\nhdspm->control_register);\r\n}\r\nif (hdspm->irq >= 0)\r\nfree_irq(hdspm->irq, (void *) hdspm);\r\nkfree(hdspm->mixer);\r\nif (hdspm->iobase)\r\niounmap(hdspm->iobase);\r\nif (hdspm->port)\r\npci_release_regions(hdspm->pci);\r\npci_disable_device(hdspm->pci);\r\nreturn 0;\r\n}\r\nstatic void snd_hdspm_card_free(struct snd_card *card)\r\n{\r\nstruct hdspm *hdspm = card->private_data;\r\nif (hdspm)\r\nsnd_hdspm_free(hdspm);\r\n}\r\nstatic int snd_hdspm_probe(struct pci_dev *pci,\r\nconst struct pci_device_id *pci_id)\r\n{\r\nstatic int dev;\r\nstruct hdspm *hdspm;\r\nstruct snd_card *card;\r\nint err;\r\nif (dev >= SNDRV_CARDS)\r\nreturn -ENODEV;\r\nif (!enable[dev]) {\r\ndev++;\r\nreturn -ENOENT;\r\n}\r\nerr = snd_card_create(index[dev], id[dev],\r\nTHIS_MODULE, sizeof(struct hdspm), &card);\r\nif (err < 0)\r\nreturn err;\r\nhdspm = card->private_data;\r\ncard->private_free = snd_hdspm_card_free;\r\nhdspm->dev = dev;\r\nhdspm->pci = pci;\r\nsnd_card_set_dev(card, &pci->dev);\r\nerr = snd_hdspm_create(card, hdspm);\r\nif (err < 0) {\r\nsnd_card_free(card);\r\nreturn err;\r\n}\r\nif (hdspm->io_type != MADIface) {\r\nsprintf(card->shortname, "%s_%x",\r\nhdspm->card_name,\r\nhdspm->serial);\r\nsprintf(card->longname, "%s S/N 0x%x at 0x%lx, irq %d",\r\nhdspm->card_name,\r\nhdspm->serial,\r\nhdspm->port, hdspm->irq);\r\n} else {\r\nsprintf(card->shortname, "%s", hdspm->card_name);\r\nsprintf(card->longname, "%s at 0x%lx, irq %d",\r\nhdspm->card_name, hdspm->port, hdspm->irq);\r\n}\r\nerr = snd_card_register(card);\r\nif (err < 0) {\r\nsnd_card_free(card);\r\nreturn err;\r\n}\r\npci_set_drvdata(pci, card);\r\ndev++;\r\nreturn 0;\r\n}\r\nstatic void snd_hdspm_remove(struct pci_dev *pci)\r\n{\r\nsnd_card_free(pci_get_drvdata(pci));\r\npci_set_drvdata(pci, NULL);\r\n}
