static inline const char *eeh_pcid_name(struct pci_dev *pdev)\r\n{\r\nif (pdev && pdev->dev.driver)\r\nreturn pdev->dev.driver->name;\r\nreturn "";\r\n}\r\nstatic inline struct pci_driver *eeh_pcid_get(struct pci_dev *pdev)\r\n{\r\nif (!pdev || !pdev->driver)\r\nreturn NULL;\r\nif (!try_module_get(pdev->driver->driver.owner))\r\nreturn NULL;\r\nreturn pdev->driver;\r\n}\r\nstatic inline void eeh_pcid_put(struct pci_dev *pdev)\r\n{\r\nif (!pdev || !pdev->driver)\r\nreturn;\r\nmodule_put(pdev->driver->driver.owner);\r\n}\r\nstatic void eeh_disable_irq(struct pci_dev *dev)\r\n{\r\nstruct eeh_dev *edev = pci_dev_to_eeh_dev(dev);\r\nif (dev->msi_enabled || dev->msix_enabled)\r\nreturn;\r\nif (!irq_has_action(dev->irq))\r\nreturn;\r\nedev->mode |= EEH_DEV_IRQ_DISABLED;\r\ndisable_irq_nosync(dev->irq);\r\n}\r\nstatic void eeh_enable_irq(struct pci_dev *dev)\r\n{\r\nstruct eeh_dev *edev = pci_dev_to_eeh_dev(dev);\r\nif ((edev->mode) & EEH_DEV_IRQ_DISABLED) {\r\nedev->mode &= ~EEH_DEV_IRQ_DISABLED;\r\nenable_irq(dev->irq);\r\n}\r\n}\r\nstatic void *eeh_report_error(void *data, void *userdata)\r\n{\r\nstruct eeh_dev *edev = (struct eeh_dev *)data;\r\nstruct pci_dev *dev = eeh_dev_to_pci_dev(edev);\r\nenum pci_ers_result rc, *res = userdata;\r\nstruct pci_driver *driver;\r\nif (!dev) return NULL;\r\ndev->error_state = pci_channel_io_frozen;\r\ndriver = eeh_pcid_get(dev);\r\nif (!driver) return NULL;\r\neeh_disable_irq(dev);\r\nif (!driver->err_handler ||\r\n!driver->err_handler->error_detected) {\r\neeh_pcid_put(dev);\r\nreturn NULL;\r\n}\r\nrc = driver->err_handler->error_detected(dev, pci_channel_io_frozen);\r\nif (rc == PCI_ERS_RESULT_NEED_RESET) *res = rc;\r\nif (*res == PCI_ERS_RESULT_NONE) *res = rc;\r\neeh_pcid_put(dev);\r\nreturn NULL;\r\n}\r\nstatic void *eeh_report_mmio_enabled(void *data, void *userdata)\r\n{\r\nstruct eeh_dev *edev = (struct eeh_dev *)data;\r\nstruct pci_dev *dev = eeh_dev_to_pci_dev(edev);\r\nenum pci_ers_result rc, *res = userdata;\r\nstruct pci_driver *driver;\r\ndriver = eeh_pcid_get(dev);\r\nif (!driver) return NULL;\r\nif (!driver->err_handler ||\r\n!driver->err_handler->mmio_enabled) {\r\neeh_pcid_put(dev);\r\nreturn NULL;\r\n}\r\nrc = driver->err_handler->mmio_enabled(dev);\r\nif (rc == PCI_ERS_RESULT_NEED_RESET) *res = rc;\r\nif (*res == PCI_ERS_RESULT_NONE) *res = rc;\r\neeh_pcid_put(dev);\r\nreturn NULL;\r\n}\r\nstatic void *eeh_report_reset(void *data, void *userdata)\r\n{\r\nstruct eeh_dev *edev = (struct eeh_dev *)data;\r\nstruct pci_dev *dev = eeh_dev_to_pci_dev(edev);\r\nenum pci_ers_result rc, *res = userdata;\r\nstruct pci_driver *driver;\r\nif (!dev) return NULL;\r\ndev->error_state = pci_channel_io_normal;\r\ndriver = eeh_pcid_get(dev);\r\nif (!driver) return NULL;\r\neeh_enable_irq(dev);\r\nif (!driver->err_handler ||\r\n!driver->err_handler->slot_reset) {\r\neeh_pcid_put(dev);\r\nreturn NULL;\r\n}\r\nrc = driver->err_handler->slot_reset(dev);\r\nif ((*res == PCI_ERS_RESULT_NONE) ||\r\n(*res == PCI_ERS_RESULT_RECOVERED)) *res = rc;\r\nif (*res == PCI_ERS_RESULT_DISCONNECT &&\r\nrc == PCI_ERS_RESULT_NEED_RESET) *res = rc;\r\neeh_pcid_put(dev);\r\nreturn NULL;\r\n}\r\nstatic void *eeh_report_resume(void *data, void *userdata)\r\n{\r\nstruct eeh_dev *edev = (struct eeh_dev *)data;\r\nstruct pci_dev *dev = eeh_dev_to_pci_dev(edev);\r\nstruct pci_driver *driver;\r\nif (!dev) return NULL;\r\ndev->error_state = pci_channel_io_normal;\r\ndriver = eeh_pcid_get(dev);\r\nif (!driver) return NULL;\r\neeh_enable_irq(dev);\r\nif (!driver->err_handler ||\r\n!driver->err_handler->resume) {\r\neeh_pcid_put(dev);\r\nreturn NULL;\r\n}\r\ndriver->err_handler->resume(dev);\r\neeh_pcid_put(dev);\r\nreturn NULL;\r\n}\r\nstatic void *eeh_report_failure(void *data, void *userdata)\r\n{\r\nstruct eeh_dev *edev = (struct eeh_dev *)data;\r\nstruct pci_dev *dev = eeh_dev_to_pci_dev(edev);\r\nstruct pci_driver *driver;\r\nif (!dev) return NULL;\r\ndev->error_state = pci_channel_io_perm_failure;\r\ndriver = eeh_pcid_get(dev);\r\nif (!driver) return NULL;\r\neeh_disable_irq(dev);\r\nif (!driver->err_handler ||\r\n!driver->err_handler->error_detected) {\r\neeh_pcid_put(dev);\r\nreturn NULL;\r\n}\r\ndriver->err_handler->error_detected(dev, pci_channel_io_perm_failure);\r\neeh_pcid_put(dev);\r\nreturn NULL;\r\n}\r\nstatic int eeh_reset_device(struct eeh_pe *pe, struct pci_bus *bus)\r\n{\r\nint cnt, rc;\r\ncnt = pe->freeze_count;\r\nif (bus)\r\n__pcibios_remove_pci_devices(bus, 0);\r\nrc = eeh_reset_pe(pe);\r\nif (rc)\r\nreturn rc;\r\neeh_ops->configure_bridge(pe);\r\neeh_pe_restore_bars(pe);\r\nif (bus) {\r\nssleep(5);\r\npcibios_add_pci_devices(bus);\r\n}\r\npe->freeze_count = cnt;\r\nreturn 0;\r\n}\r\nvoid eeh_handle_event(struct eeh_pe *pe)\r\n{\r\nstruct pci_bus *frozen_bus;\r\nint rc = 0;\r\nenum pci_ers_result result = PCI_ERS_RESULT_NONE;\r\nfrozen_bus = eeh_pe_bus_get(pe);\r\nif (!frozen_bus) {\r\npr_err("%s: Cannot find PCI bus for PHB#%d-PE#%x\n",\r\n__func__, pe->phb->global_number, pe->addr);\r\nreturn;\r\n}\r\npe->freeze_count++;\r\nif (pe->freeze_count > EEH_MAX_ALLOWED_FREEZES)\r\ngoto excess_failures;\r\npr_warning("EEH: This PCI device has failed %d times in the last hour\n",\r\npe->freeze_count);\r\neeh_pe_dev_traverse(pe, eeh_report_error, &result);\r\nrc = eeh_ops->wait_state(pe, MAX_WAIT_FOR_RECOVERY*1000);\r\nif (rc < 0 || rc == EEH_STATE_NOT_SUPPORT) {\r\nprintk(KERN_WARNING "EEH: Permanent failure\n");\r\ngoto hard_fail;\r\n}\r\neeh_slot_error_detail(pe, EEH_LOG_TEMP);\r\nif (result == PCI_ERS_RESULT_NONE) {\r\nrc = eeh_reset_device(pe, frozen_bus);\r\nif (rc) {\r\nprintk(KERN_WARNING "EEH: Unable to reset, rc=%d\n", rc);\r\ngoto hard_fail;\r\n}\r\n}\r\nif (result == PCI_ERS_RESULT_CAN_RECOVER) {\r\nrc = eeh_pci_enable(pe, EEH_OPT_THAW_MMIO);\r\nif (rc < 0)\r\ngoto hard_fail;\r\nif (rc) {\r\nresult = PCI_ERS_RESULT_NEED_RESET;\r\n} else {\r\nresult = PCI_ERS_RESULT_NONE;\r\neeh_pe_dev_traverse(pe, eeh_report_mmio_enabled, &result);\r\n}\r\n}\r\nif (result == PCI_ERS_RESULT_CAN_RECOVER) {\r\nrc = eeh_pci_enable(pe, EEH_OPT_THAW_DMA);\r\nif (rc < 0)\r\ngoto hard_fail;\r\nif (rc)\r\nresult = PCI_ERS_RESULT_NEED_RESET;\r\nelse\r\nresult = PCI_ERS_RESULT_RECOVERED;\r\n}\r\nif (result == PCI_ERS_RESULT_DISCONNECT) {\r\nprintk(KERN_WARNING "EEH: Device driver gave up\n");\r\ngoto hard_fail;\r\n}\r\nif (result == PCI_ERS_RESULT_NEED_RESET) {\r\nrc = eeh_reset_device(pe, NULL);\r\nif (rc) {\r\nprintk(KERN_WARNING "EEH: Cannot reset, rc=%d\n", rc);\r\ngoto hard_fail;\r\n}\r\nresult = PCI_ERS_RESULT_NONE;\r\neeh_pe_dev_traverse(pe, eeh_report_reset, &result);\r\n}\r\nif ((result != PCI_ERS_RESULT_RECOVERED) &&\r\n(result != PCI_ERS_RESULT_NONE)) {\r\nprintk(KERN_WARNING "EEH: Not recovered\n");\r\ngoto hard_fail;\r\n}\r\neeh_pe_dev_traverse(pe, eeh_report_resume, NULL);\r\nreturn;\r\nexcess_failures:\r\npr_err("EEH: PHB#%d-PE#%x has failed %d times in the\n"\r\n"last hour and has been permanently disabled.\n"\r\n"Please try reseating or replacing it.\n",\r\npe->phb->global_number, pe->addr,\r\npe->freeze_count);\r\ngoto perm_error;\r\nhard_fail:\r\npr_err("EEH: Unable to recover from failure from PHB#%d-PE#%x.\n"\r\n"Please try reseating or replacing it\n",\r\npe->phb->global_number, pe->addr);\r\nperm_error:\r\neeh_slot_error_detail(pe, EEH_LOG_PERM);\r\neeh_pe_dev_traverse(pe, eeh_report_failure, NULL);\r\nif (frozen_bus)\r\npcibios_remove_pci_devices(frozen_bus);\r\n}
