int handle_page_fault(unsigned long address, unsigned long ip,\r\nint is_write, int is_user, int *code_out)\r\n{\r\nstruct mm_struct *mm = current->mm;\r\nstruct vm_area_struct *vma;\r\npgd_t *pgd;\r\npud_t *pud;\r\npmd_t *pmd;\r\npte_t *pte;\r\nint err = -EFAULT;\r\nunsigned int flags = FAULT_FLAG_ALLOW_RETRY | FAULT_FLAG_KILLABLE |\r\n(is_write ? FAULT_FLAG_WRITE : 0);\r\n*code_out = SEGV_MAPERR;\r\nif (in_atomic())\r\ngoto out_nosemaphore;\r\nretry:\r\ndown_read(&mm->mmap_sem);\r\nvma = find_vma(mm, address);\r\nif (!vma)\r\ngoto out;\r\nelse if (vma->vm_start <= address)\r\ngoto good_area;\r\nelse if (!(vma->vm_flags & VM_GROWSDOWN))\r\ngoto out;\r\nelse if (is_user && !ARCH_IS_STACKGROW(address))\r\ngoto out;\r\nelse if (expand_stack(vma, address))\r\ngoto out;\r\ngood_area:\r\n*code_out = SEGV_ACCERR;\r\nif (is_write && !(vma->vm_flags & VM_WRITE))\r\ngoto out;\r\nif (!is_write && !(vma->vm_flags & (VM_READ | VM_EXEC)))\r\ngoto out;\r\ndo {\r\nint fault;\r\nfault = handle_mm_fault(mm, vma, address, flags);\r\nif ((fault & VM_FAULT_RETRY) && fatal_signal_pending(current))\r\ngoto out_nosemaphore;\r\nif (unlikely(fault & VM_FAULT_ERROR)) {\r\nif (fault & VM_FAULT_OOM) {\r\ngoto out_of_memory;\r\n} else if (fault & VM_FAULT_SIGBUS) {\r\nerr = -EACCES;\r\ngoto out;\r\n}\r\nBUG();\r\n}\r\nif (flags & FAULT_FLAG_ALLOW_RETRY) {\r\nif (fault & VM_FAULT_MAJOR)\r\ncurrent->maj_flt++;\r\nelse\r\ncurrent->min_flt++;\r\nif (fault & VM_FAULT_RETRY) {\r\nflags &= ~FAULT_FLAG_ALLOW_RETRY;\r\nflags |= FAULT_FLAG_TRIED;\r\ngoto retry;\r\n}\r\n}\r\npgd = pgd_offset(mm, address);\r\npud = pud_offset(pgd, address);\r\npmd = pmd_offset(pud, address);\r\npte = pte_offset_kernel(pmd, address);\r\n} while (!pte_present(*pte));\r\nerr = 0;\r\n#if 0\r\nWARN_ON(!pte_young(*pte) || (is_write && !pte_dirty(*pte)));\r\n#endif\r\nflush_tlb_page(vma, address);\r\nout:\r\nup_read(&mm->mmap_sem);\r\nout_nosemaphore:\r\nreturn err;\r\nout_of_memory:\r\nup_read(&mm->mmap_sem);\r\npagefault_out_of_memory();\r\nreturn 0;\r\n}\r\nstatic void show_segv_info(struct uml_pt_regs *regs)\r\n{\r\nstruct task_struct *tsk = current;\r\nstruct faultinfo *fi = UPT_FAULTINFO(regs);\r\nif (!unhandled_signal(tsk, SIGSEGV))\r\nreturn;\r\nif (!printk_ratelimit())\r\nreturn;\r\nprintk("%s%s[%d]: segfault at %lx ip %p sp %p error %x",\r\ntask_pid_nr(tsk) > 1 ? KERN_INFO : KERN_EMERG,\r\ntsk->comm, task_pid_nr(tsk), FAULT_ADDRESS(*fi),\r\n(void *)UPT_IP(regs), (void *)UPT_SP(regs),\r\nfi->error_code);\r\nprint_vma_addr(KERN_CONT " in ", UPT_IP(regs));\r\nprintk(KERN_CONT "\n");\r\n}\r\nstatic void bad_segv(struct faultinfo fi, unsigned long ip)\r\n{\r\nstruct siginfo si;\r\nsi.si_signo = SIGSEGV;\r\nsi.si_code = SEGV_ACCERR;\r\nsi.si_addr = (void __user *) FAULT_ADDRESS(fi);\r\ncurrent->thread.arch.faultinfo = fi;\r\nforce_sig_info(SIGSEGV, &si, current);\r\n}\r\nvoid fatal_sigsegv(void)\r\n{\r\nforce_sigsegv(SIGSEGV, current);\r\ndo_signal();\r\nos_dump_core();\r\n}\r\nvoid segv_handler(int sig, struct siginfo *unused_si, struct uml_pt_regs *regs)\r\n{\r\nstruct faultinfo * fi = UPT_FAULTINFO(regs);\r\nif (UPT_IS_USER(regs) && !SEGV_IS_FIXABLE(fi)) {\r\nshow_segv_info(regs);\r\nbad_segv(*fi, UPT_IP(regs));\r\nreturn;\r\n}\r\nsegv(*fi, UPT_IP(regs), UPT_IS_USER(regs), regs);\r\n}\r\nunsigned long segv(struct faultinfo fi, unsigned long ip, int is_user,\r\nstruct uml_pt_regs *regs)\r\n{\r\nstruct siginfo si;\r\njmp_buf *catcher;\r\nint err;\r\nint is_write = FAULT_WRITE(fi);\r\nunsigned long address = FAULT_ADDRESS(fi);\r\nif (!is_user && (address >= start_vm) && (address < end_vm)) {\r\nflush_tlb_kernel_vm();\r\nreturn 0;\r\n}\r\nelse if (current->mm == NULL) {\r\nshow_regs(container_of(regs, struct pt_regs, regs));\r\npanic("Segfault with no mm");\r\n}\r\nif (SEGV_IS_FIXABLE(&fi) || SEGV_MAYBE_FIXABLE(&fi))\r\nerr = handle_page_fault(address, ip, is_write, is_user,\r\n&si.si_code);\r\nelse {\r\nerr = -EFAULT;\r\naddress = 0;\r\n}\r\ncatcher = current->thread.fault_catcher;\r\nif (!err)\r\nreturn 0;\r\nelse if (catcher != NULL) {\r\ncurrent->thread.fault_addr = (void *) address;\r\nUML_LONGJMP(catcher, 1);\r\n}\r\nelse if (current->thread.fault_addr != NULL)\r\npanic("fault_addr set but no fault catcher");\r\nelse if (!is_user && arch_fixup(ip, regs))\r\nreturn 0;\r\nif (!is_user) {\r\nshow_regs(container_of(regs, struct pt_regs, regs));\r\npanic("Kernel mode fault at addr 0x%lx, ip 0x%lx",\r\naddress, ip);\r\n}\r\nshow_segv_info(regs);\r\nif (err == -EACCES) {\r\nsi.si_signo = SIGBUS;\r\nsi.si_errno = 0;\r\nsi.si_code = BUS_ADRERR;\r\nsi.si_addr = (void __user *)address;\r\ncurrent->thread.arch.faultinfo = fi;\r\nforce_sig_info(SIGBUS, &si, current);\r\n} else {\r\nBUG_ON(err != -EFAULT);\r\nsi.si_signo = SIGSEGV;\r\nsi.si_addr = (void __user *) address;\r\ncurrent->thread.arch.faultinfo = fi;\r\nforce_sig_info(SIGSEGV, &si, current);\r\n}\r\nreturn 0;\r\n}\r\nvoid relay_signal(int sig, struct siginfo *si, struct uml_pt_regs *regs)\r\n{\r\nstruct faultinfo *fi;\r\nstruct siginfo clean_si;\r\nif (!UPT_IS_USER(regs)) {\r\nif (sig == SIGBUS)\r\nprintk(KERN_ERR "Bus error - the host /dev/shm or /tmp "\r\n"mount likely just ran out of space\n");\r\npanic("Kernel mode signal %d", sig);\r\n}\r\narch_examine_signal(sig, regs);\r\nmemset(&clean_si, 0, sizeof(clean_si));\r\nclean_si.si_signo = si->si_signo;\r\nclean_si.si_errno = si->si_errno;\r\nclean_si.si_code = si->si_code;\r\nswitch (sig) {\r\ncase SIGILL:\r\ncase SIGFPE:\r\ncase SIGSEGV:\r\ncase SIGBUS:\r\ncase SIGTRAP:\r\nfi = UPT_FAULTINFO(regs);\r\nclean_si.si_addr = (void __user *) FAULT_ADDRESS(*fi);\r\ncurrent->thread.arch.faultinfo = *fi;\r\n#ifdef __ARCH_SI_TRAPNO\r\nclean_si.si_trapno = si->si_trapno;\r\n#endif\r\nbreak;\r\ndefault:\r\nprintk(KERN_ERR "Attempted to relay unknown signal %d (si_code = %d)\n",\r\nsig, si->si_code);\r\n}\r\nforce_sig_info(sig, &clean_si, current);\r\n}\r\nvoid bus_handler(int sig, struct siginfo *si, struct uml_pt_regs *regs)\r\n{\r\nif (current->thread.fault_catcher != NULL)\r\nUML_LONGJMP(current->thread.fault_catcher, 1);\r\nelse\r\nrelay_signal(sig, si, regs);\r\n}\r\nvoid winch(int sig, struct siginfo *unused_si, struct uml_pt_regs *regs)\r\n{\r\ndo_IRQ(WINCH_IRQ, regs);\r\n}\r\nvoid trap_init(void)\r\n{\r\n}
