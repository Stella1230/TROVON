static inline struct ti_ssp *dev_to_ssp(struct device *dev)\r\n{\r\nreturn dev_get_drvdata(dev->parent);\r\n}\r\nstatic inline int dev_to_port(struct device *dev)\r\n{\r\nreturn to_platform_device(dev)->id;\r\n}\r\nstatic inline u32 ssp_read(struct ti_ssp *ssp, int reg)\r\n{\r\nreturn __raw_readl(ssp->regs + reg);\r\n}\r\nstatic inline void ssp_write(struct ti_ssp *ssp, int reg, u32 val)\r\n{\r\n__raw_writel(val, ssp->regs + reg);\r\n}\r\nstatic inline void ssp_rmw(struct ti_ssp *ssp, int reg, u32 mask, u32 bits)\r\n{\r\nssp_write(ssp, reg, (ssp_read(ssp, reg) & ~mask) | bits);\r\n}\r\nstatic inline u32 ssp_port_read(struct ti_ssp *ssp, int port, int reg)\r\n{\r\nreturn ssp_read(ssp, ssp_port_base[port] + reg);\r\n}\r\nstatic inline void ssp_port_write(struct ti_ssp *ssp, int port, int reg,\r\nu32 val)\r\n{\r\nssp_write(ssp, ssp_port_base[port] + reg, val);\r\n}\r\nstatic inline void ssp_port_rmw(struct ti_ssp *ssp, int port, int reg,\r\nu32 mask, u32 bits)\r\n{\r\nssp_rmw(ssp, ssp_port_base[port] + reg, mask, bits);\r\n}\r\nstatic inline void ssp_port_clr_bits(struct ti_ssp *ssp, int port, int reg,\r\nu32 bits)\r\n{\r\nssp_port_rmw(ssp, port, reg, bits, 0);\r\n}\r\nstatic inline void ssp_port_set_bits(struct ti_ssp *ssp, int port, int reg,\r\nu32 bits)\r\n{\r\nssp_port_rmw(ssp, port, reg, 0, bits);\r\n}\r\nstatic int __set_mode(struct ti_ssp *ssp, int port, int mode)\r\n{\r\nmode &= SSP_PORT_CONFIG_MASK;\r\nssp_port_rmw(ssp, port, PORT_CFG_1, SSP_PORT_CONFIG_MASK, mode);\r\nreturn 0;\r\n}\r\nint ti_ssp_set_mode(struct device *dev, int mode)\r\n{\r\nstruct ti_ssp *ssp = dev_to_ssp(dev);\r\nint port = dev_to_port(dev);\r\nint ret;\r\nspin_lock(&ssp->lock);\r\nret = __set_mode(ssp, port, mode);\r\nspin_unlock(&ssp->lock);\r\nreturn ret;\r\n}\r\nstatic void __set_iosel2(struct ti_ssp *ssp, u32 mask, u32 val)\r\n{\r\nssp->iosel2 = (ssp->iosel2 & ~mask) | val;\r\nssp_write(ssp, REG_IOSEL_2, ssp->iosel2);\r\n}\r\nstatic void __set_iosel(struct ti_ssp *ssp, int port, u32 iosel)\r\n{\r\nunsigned val, shift = port ? 16 : 0;\r\nval = ssp_read(ssp, REG_IOSEL_1);\r\nval &= 0xffff << (port ? 0 : 16);\r\nval |= (iosel & 0xffff) << (port ? 16 : 0);\r\nssp_write(ssp, REG_IOSEL_1, val);\r\nval = (iosel >> 16) & 0x7;\r\n__set_iosel2(ssp, 0x7 << shift, val << shift);\r\n}\r\nint ti_ssp_set_iosel(struct device *dev, u32 iosel)\r\n{\r\nstruct ti_ssp *ssp = dev_to_ssp(dev);\r\nint port = dev_to_port(dev);\r\nspin_lock(&ssp->lock);\r\n__set_iosel(ssp, port, iosel);\r\nspin_unlock(&ssp->lock);\r\nreturn 0;\r\n}\r\nint ti_ssp_load(struct device *dev, int offs, u32* prog, int len)\r\n{\r\nstruct ti_ssp *ssp = dev_to_ssp(dev);\r\nint port = dev_to_port(dev);\r\nint i;\r\nif (len > SSP_PORT_SEQRAM_SIZE)\r\nreturn -ENOSPC;\r\nspin_lock(&ssp->lock);\r\nssp_port_set_bits(ssp, port, PORT_CFG_2, SSP_SEQRAM_WR_EN);\r\nfor (i = 0; i < len; i++) {\r\n__raw_writel(prog[i], ssp->regs + offs + 4*i +\r\nssp_port_seqram[port]);\r\n}\r\nssp_port_clr_bits(ssp, port, PORT_CFG_2, SSP_SEQRAM_WR_EN);\r\nspin_unlock(&ssp->lock);\r\nreturn 0;\r\n}\r\nint ti_ssp_raw_read(struct device *dev)\r\n{\r\nstruct ti_ssp *ssp = dev_to_ssp(dev);\r\nint port = dev_to_port(dev);\r\nint shift = port ? 27 : 11;\r\nreturn (ssp_read(ssp, REG_IOSEL_2) >> shift) & 0xf;\r\n}\r\nint ti_ssp_raw_write(struct device *dev, u32 val)\r\n{\r\nstruct ti_ssp *ssp = dev_to_ssp(dev);\r\nint port = dev_to_port(dev), shift;\r\nspin_lock(&ssp->lock);\r\nshift = port ? 22 : 6;\r\nval &= 0xf;\r\n__set_iosel2(ssp, 0xf << shift, val << shift);\r\nspin_unlock(&ssp->lock);\r\nreturn 0;\r\n}\r\nstatic inline int __xfer_done(struct ti_ssp *ssp, int port)\r\n{\r\nreturn !(ssp_port_read(ssp, port, PORT_CFG_1) & SSP_BUSY);\r\n}\r\nint ti_ssp_run(struct device *dev, u32 pc, u32 input, u32 *output)\r\n{\r\nstruct ti_ssp *ssp = dev_to_ssp(dev);\r\nint port = dev_to_port(dev);\r\nint ret;\r\nif (pc & ~(0x3f))\r\nreturn -EINVAL;\r\nspin_lock(&ssp->lock);\r\nssp_port_write(ssp, port, PORT_ADDR, input >> 16);\r\nssp_port_write(ssp, port, PORT_DATA, input & 0xffff);\r\nssp_port_rmw(ssp, port, PORT_CFG_1, 0x3f, pc);\r\nspin_lock_irq(&ssp->wqh.lock);\r\nssp_port_set_bits(ssp, port, PORT_CFG_1, SSP_START);\r\nspin_unlock(&ssp->lock);\r\nret = wait_event_interruptible_locked_irq(ssp->wqh,\r\n__xfer_done(ssp, port));\r\nspin_unlock_irq(&ssp->wqh.lock);\r\nif (ret < 0)\r\nreturn ret;\r\nif (output) {\r\n*output = (ssp_port_read(ssp, port, PORT_ADDR) << 16) |\r\n(ssp_port_read(ssp, port, PORT_DATA) & 0xffff);\r\n}\r\nret = ssp_port_read(ssp, port, PORT_STATE) & 0x3f;\r\nreturn ret;\r\n}\r\nstatic irqreturn_t ti_ssp_interrupt(int irq, void *dev_data)\r\n{\r\nstruct ti_ssp *ssp = dev_data;\r\nspin_lock(&ssp->wqh.lock);\r\nssp_write(ssp, REG_INTR_ST, 0x3);\r\nwake_up_locked(&ssp->wqh);\r\nspin_unlock(&ssp->wqh.lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int ti_ssp_probe(struct platform_device *pdev)\r\n{\r\nstatic struct ti_ssp *ssp;\r\nconst struct ti_ssp_data *pdata = pdev->dev.platform_data;\r\nint error = 0, prediv = 0xff, id;\r\nunsigned long sysclk;\r\nstruct device *dev = &pdev->dev;\r\nstruct mfd_cell cells[2];\r\nssp = kzalloc(sizeof(*ssp), GFP_KERNEL);\r\nif (!ssp) {\r\ndev_err(dev, "cannot allocate device info\n");\r\nreturn -ENOMEM;\r\n}\r\nssp->dev = dev;\r\ndev_set_drvdata(dev, ssp);\r\nssp->res = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!ssp->res) {\r\nerror = -ENODEV;\r\ndev_err(dev, "cannot determine register area\n");\r\ngoto error_res;\r\n}\r\nif (!request_mem_region(ssp->res->start, resource_size(ssp->res),\r\npdev->name)) {\r\nerror = -ENOMEM;\r\ndev_err(dev, "cannot claim register memory\n");\r\ngoto error_res;\r\n}\r\nssp->regs = ioremap(ssp->res->start, resource_size(ssp->res));\r\nif (!ssp->regs) {\r\nerror = -ENOMEM;\r\ndev_err(dev, "cannot map register memory\n");\r\ngoto error_map;\r\n}\r\nssp->clk = clk_get(dev, NULL);\r\nif (IS_ERR(ssp->clk)) {\r\nerror = PTR_ERR(ssp->clk);\r\ndev_err(dev, "cannot claim device clock\n");\r\ngoto error_clk;\r\n}\r\nssp->irq = platform_get_irq(pdev, 0);\r\nif (ssp->irq < 0) {\r\nerror = -ENODEV;\r\ndev_err(dev, "unknown irq\n");\r\ngoto error_irq;\r\n}\r\nerror = request_threaded_irq(ssp->irq, NULL, ti_ssp_interrupt, 0,\r\ndev_name(dev), ssp);\r\nif (error < 0) {\r\ndev_err(dev, "cannot acquire irq\n");\r\ngoto error_irq;\r\n}\r\nspin_lock_init(&ssp->lock);\r\ninit_waitqueue_head(&ssp->wqh);\r\nerror = clk_enable(ssp->clk);\r\nif (error) {\r\ndev_err(dev, "cannot enable device clock\n");\r\ngoto error_enable;\r\n}\r\nssp_write(ssp, REG_IOSEL_1, 0);\r\nssp_write(ssp, REG_IOSEL_2, 0);\r\nssp_write(ssp, REG_INTR_EN, 0x3);\r\nssp_write(ssp, REG_INTR_ST, 0x3);\r\nssp_write(ssp, REG_TEST_CTRL, 0);\r\nssp_port_write(ssp, 0, PORT_CFG_1, SSP_PORT_ASL);\r\nssp_port_write(ssp, 1, PORT_CFG_1, SSP_PORT_ASL);\r\nssp_port_write(ssp, 0, PORT_CFG_2, SSP_PORT_CFO1);\r\nssp_port_write(ssp, 1, PORT_CFG_2, SSP_PORT_CFO1);\r\nsysclk = clk_get_rate(ssp->clk);\r\nif (pdata && pdata->out_clock)\r\nprediv = (sysclk / pdata->out_clock) - 1;\r\nprediv = clamp(prediv, 0, 0xff);\r\nssp_rmw(ssp, REG_PREDIV, 0xff, prediv);\r\nmemset(cells, 0, sizeof(cells));\r\nfor (id = 0; id < 2; id++) {\r\nconst struct ti_ssp_dev_data *data = &pdata->dev_data[id];\r\ncells[id].id = id;\r\ncells[id].name = data->dev_name;\r\ncells[id].platform_data = data->pdata;\r\ncells[id].data_size = data->pdata_size;\r\n}\r\nerror = mfd_add_devices(dev, 0, cells, 2, NULL, 0, NULL);\r\nif (error < 0) {\r\ndev_err(dev, "cannot add mfd cells\n");\r\ngoto error_enable;\r\n}\r\nreturn 0;\r\nerror_enable:\r\nfree_irq(ssp->irq, ssp);\r\nerror_irq:\r\nclk_put(ssp->clk);\r\nerror_clk:\r\niounmap(ssp->regs);\r\nerror_map:\r\nrelease_mem_region(ssp->res->start, resource_size(ssp->res));\r\nerror_res:\r\nkfree(ssp);\r\nreturn error;\r\n}\r\nstatic int ti_ssp_remove(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct ti_ssp *ssp = dev_get_drvdata(dev);\r\nmfd_remove_devices(dev);\r\nclk_disable(ssp->clk);\r\nfree_irq(ssp->irq, ssp);\r\nclk_put(ssp->clk);\r\niounmap(ssp->regs);\r\nrelease_mem_region(ssp->res->start, resource_size(ssp->res));\r\nkfree(ssp);\r\ndev_set_drvdata(dev, NULL);\r\nreturn 0;\r\n}
