ChipDescript* ChipHelper_GetVersionSdio(u8 sdio_ver)\r\n{\r\nu32 i;\r\nfor (i = 0; i < nelem(chip_ver_to_desc); i++)\r\n{\r\nif (chip_ver_to_desc[i]->chip_version.sdio == sdio_ver)\r\n{\r\nreturn chip_ver_to_desc[i];\r\n}\r\n}\r\nreturn &chip_device_desc_null;\r\n}\r\nChipDescript* ChipHelper_GetVersionAny(u16 from_FF9A, u16 from_FE81)\r\n{\r\nu32 i;\r\nif ((from_FF9A & 0xFF00) != 0)\r\n{\r\nfor (i = 0; i < nelem(chip_ver_to_desc); i++)\r\n{\r\nif (chip_ver_to_desc[i]->chip_version.pre_bc7 &&\r\n((from_FF9A & chip_ver_to_desc[i]->chip_version.mask) ==\r\nchip_ver_to_desc[i]->chip_version.result))\r\n{\r\nreturn chip_ver_to_desc[i];\r\n}\r\n}\r\n}\r\nelse\r\n{\r\nfor (i = 0; i < nelem(chip_ver_to_desc); i++)\r\n{\r\nif (!chip_ver_to_desc[i]->chip_version.pre_bc7 &&\r\n((from_FE81 & chip_ver_to_desc[i]->chip_version.mask) ==\r\nchip_ver_to_desc[i]->chip_version.result))\r\n{\r\nreturn chip_ver_to_desc[i];\r\n}\r\n}\r\n}\r\nreturn &chip_device_desc_null;\r\n}\r\nChipDescript* ChipHelper_GetVersionUniFi(u16 ver)\r\n{\r\nreturn ChipHelper_GetVersionAny(0x0000, ver);\r\n}\r\nChipDescript *ChipHelper_Null(void)\r\n{\r\nreturn &chip_device_desc_null;\r\n}\r\nChipDescript* ChipHelper_GetVersionBlueCore(enum chip_helper_bluecore_age bc_age, u16 version)\r\n{\r\nif (bc_age == chip_helper_bluecore_pre_bc7)\r\n{\r\nreturn ChipHelper_GetVersionAny(version, 0x0000);\r\n}\r\nelse\r\n{\r\nreturn ChipHelper_GetVersionAny(0x0000, version);\r\n}\r\n}\r\nu16 ChipHelper_MapAddress_SPI2HOST(ChipDescript *chip_help, u16 addr)\r\n{\r\nu32 i;\r\nfor (i = 0; i < chip_help->map.len; i++)\r\n{\r\nif (chip_help->map.vals[i].spi == addr)\r\n{\r\nreturn chip_help->map.vals[i].host;\r\n}\r\n}\r\nreturn addr;\r\n}\r\nu16 ChipHelper_MapAddress_HOST2SPI(ChipDescript *chip_help, u16 addr)\r\n{\r\nu32 i;\r\nfor (i = 0; i < chip_help->map.len; i++)\r\n{\r\nif (chip_help->map.vals[i].host == addr)\r\n{\r\nreturn chip_help->map.vals[i].spi;\r\n}\r\n}\r\nreturn addr;\r\n}\r\nu16 ChipHelper_WINDOW_ADDRESS(ChipDescript *chip_help,\r\nenum chip_helper_window_index window)\r\n{\r\nif (window < CHIP_HELPER_WINDOW_COUNT &&\r\nchip_help->windows[window] != NULL)\r\n{\r\nreturn chip_help->windows[window]->address + chip_help->windows[window]->blocked;\r\n}\r\nreturn 0;\r\n}\r\nu16 ChipHelper_WINDOW_SIZE(ChipDescript *chip_help,\r\nenum chip_helper_window_index window)\r\n{\r\nif (window < CHIP_HELPER_WINDOW_COUNT &&\r\nchip_help->windows[window] != NULL)\r\n{\r\nreturn chip_help->windows[window]->size - chip_help->windows[window]->blocked;\r\n}\r\nreturn 0;\r\n}\r\nu32 ChipHelper_ClockStartupSequence(ChipDescript *chip_help,\r\nconst struct chip_helper_init_values **val)\r\n{\r\n*val = chip_help->init.vals;\r\nreturn chip_help->init.len;\r\n}\r\nu32 ChipHelper_HostResetSequence(ChipDescript *chip_help,\r\nconst struct chip_helper_reset_values **val)\r\n{\r\n*val = chip_help->reset_prog.vals;\r\nreturn chip_help->reset_prog.len;\r\n}\r\ns32 ChipHelper_DecodeWindow(ChipDescript *chip_help,\r\nenum chip_helper_window_index window,\r\nenum chip_helper_window_type type,\r\nu32 offset,\r\nu16 *page, u16 *addr, u32 *len)\r\n{\r\nconst struct window_info_t *win;\r\nconst struct window_shift_info_t *mode;\r\nu16 of, pg;\r\nif (window >= CHIP_HELPER_WINDOW_COUNT)\r\n{\r\nreturn FALSE;\r\n}\r\nif ((win = chip_help->windows[window]) == NULL)\r\n{\r\nreturn FALSE;\r\n}\r\nif (type >= CHIP_HELPER_WT_COUNT)\r\n{\r\nreturn FALSE;\r\n}\r\nif ((mode = &win->mode[type]) == NULL)\r\n{\r\nreturn FALSE;\r\n}\r\nif (!mode->allowed)\r\n{\r\nreturn FALSE;\r\n}\r\npg = (u16)(offset >> mode->page_shift) + mode->page_offset;\r\nof = (u16)(offset & ((1 << mode->page_shift) - 1));\r\nwhile (of < win->blocked)\r\n{\r\nof += 1 << mode->page_shift;\r\npg--;\r\n}\r\n*page = pg;\r\n*addr = win->address + of;\r\n*len = win->size - of;\r\nreturn TRUE;\r\n}
