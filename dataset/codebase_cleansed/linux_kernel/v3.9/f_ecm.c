static inline struct f_ecm *func_to_ecm(struct usb_function *f)\r\n{\r\nreturn container_of(f, struct f_ecm, port.func);\r\n}\r\nstatic inline unsigned ecm_bitrate(struct usb_gadget *g)\r\n{\r\nif (gadget_is_superspeed(g) && g->speed == USB_SPEED_SUPER)\r\nreturn 13 * 1024 * 8 * 1000 * 8;\r\nelse if (gadget_is_dualspeed(g) && g->speed == USB_SPEED_HIGH)\r\nreturn 13 * 512 * 8 * 1000 * 8;\r\nelse\r\nreturn 19 * 64 * 1 * 1000 * 8;\r\n}\r\nstatic void ecm_do_notify(struct f_ecm *ecm)\r\n{\r\nstruct usb_request *req = ecm->notify_req;\r\nstruct usb_cdc_notification *event;\r\nstruct usb_composite_dev *cdev = ecm->port.func.config->cdev;\r\n__le32 *data;\r\nint status;\r\nif (!req)\r\nreturn;\r\nevent = req->buf;\r\nswitch (ecm->notify_state) {\r\ncase ECM_NOTIFY_NONE:\r\nreturn;\r\ncase ECM_NOTIFY_CONNECT:\r\nevent->bNotificationType = USB_CDC_NOTIFY_NETWORK_CONNECTION;\r\nif (ecm->is_open)\r\nevent->wValue = cpu_to_le16(1);\r\nelse\r\nevent->wValue = cpu_to_le16(0);\r\nevent->wLength = 0;\r\nreq->length = sizeof *event;\r\nDBG(cdev, "notify connect %s\n",\r\necm->is_open ? "true" : "false");\r\necm->notify_state = ECM_NOTIFY_SPEED;\r\nbreak;\r\ncase ECM_NOTIFY_SPEED:\r\nevent->bNotificationType = USB_CDC_NOTIFY_SPEED_CHANGE;\r\nevent->wValue = cpu_to_le16(0);\r\nevent->wLength = cpu_to_le16(8);\r\nreq->length = ECM_STATUS_BYTECOUNT;\r\ndata = req->buf + sizeof *event;\r\ndata[0] = cpu_to_le32(ecm_bitrate(cdev->gadget));\r\ndata[1] = data[0];\r\nDBG(cdev, "notify speed %d\n", ecm_bitrate(cdev->gadget));\r\necm->notify_state = ECM_NOTIFY_NONE;\r\nbreak;\r\n}\r\nevent->bmRequestType = 0xA1;\r\nevent->wIndex = cpu_to_le16(ecm->ctrl_id);\r\necm->notify_req = NULL;\r\nstatus = usb_ep_queue(ecm->notify, req, GFP_ATOMIC);\r\nif (status < 0) {\r\necm->notify_req = req;\r\nDBG(cdev, "notify --> %d\n", status);\r\n}\r\n}\r\nstatic void ecm_notify(struct f_ecm *ecm)\r\n{\r\necm->notify_state = ECM_NOTIFY_CONNECT;\r\necm_do_notify(ecm);\r\n}\r\nstatic void ecm_notify_complete(struct usb_ep *ep, struct usb_request *req)\r\n{\r\nstruct f_ecm *ecm = req->context;\r\nstruct usb_composite_dev *cdev = ecm->port.func.config->cdev;\r\nstruct usb_cdc_notification *event = req->buf;\r\nswitch (req->status) {\r\ncase 0:\r\nbreak;\r\ncase -ECONNRESET:\r\ncase -ESHUTDOWN:\r\necm->notify_state = ECM_NOTIFY_NONE;\r\nbreak;\r\ndefault:\r\nDBG(cdev, "event %02x --> %d\n",\r\nevent->bNotificationType, req->status);\r\nbreak;\r\n}\r\necm->notify_req = req;\r\necm_do_notify(ecm);\r\n}\r\nstatic int ecm_setup(struct usb_function *f, const struct usb_ctrlrequest *ctrl)\r\n{\r\nstruct f_ecm *ecm = func_to_ecm(f);\r\nstruct usb_composite_dev *cdev = f->config->cdev;\r\nstruct usb_request *req = cdev->req;\r\nint value = -EOPNOTSUPP;\r\nu16 w_index = le16_to_cpu(ctrl->wIndex);\r\nu16 w_value = le16_to_cpu(ctrl->wValue);\r\nu16 w_length = le16_to_cpu(ctrl->wLength);\r\nswitch ((ctrl->bRequestType << 8) | ctrl->bRequest) {\r\ncase ((USB_DIR_OUT | USB_TYPE_CLASS | USB_RECIP_INTERFACE) << 8)\r\n| USB_CDC_SET_ETHERNET_PACKET_FILTER:\r\nif (w_length != 0 || w_index != ecm->ctrl_id)\r\ngoto invalid;\r\nDBG(cdev, "packet filter %02x\n", w_value);\r\necm->port.cdc_filter = w_value;\r\nvalue = 0;\r\nbreak;\r\ndefault:\r\ninvalid:\r\nDBG(cdev, "invalid control req%02x.%02x v%04x i%04x l%d\n",\r\nctrl->bRequestType, ctrl->bRequest,\r\nw_value, w_index, w_length);\r\n}\r\nif (value >= 0) {\r\nDBG(cdev, "ecm req%02x.%02x v%04x i%04x l%d\n",\r\nctrl->bRequestType, ctrl->bRequest,\r\nw_value, w_index, w_length);\r\nreq->zero = 0;\r\nreq->length = value;\r\nvalue = usb_ep_queue(cdev->gadget->ep0, req, GFP_ATOMIC);\r\nif (value < 0)\r\nERROR(cdev, "ecm req %02x.%02x response err %d\n",\r\nctrl->bRequestType, ctrl->bRequest,\r\nvalue);\r\n}\r\nreturn value;\r\n}\r\nstatic int ecm_set_alt(struct usb_function *f, unsigned intf, unsigned alt)\r\n{\r\nstruct f_ecm *ecm = func_to_ecm(f);\r\nstruct usb_composite_dev *cdev = f->config->cdev;\r\nif (intf == ecm->ctrl_id) {\r\nif (alt != 0)\r\ngoto fail;\r\nif (ecm->notify->driver_data) {\r\nVDBG(cdev, "reset ecm control %d\n", intf);\r\nusb_ep_disable(ecm->notify);\r\n}\r\nif (!(ecm->notify->desc)) {\r\nVDBG(cdev, "init ecm ctrl %d\n", intf);\r\nif (config_ep_by_speed(cdev->gadget, f, ecm->notify))\r\ngoto fail;\r\n}\r\nusb_ep_enable(ecm->notify);\r\necm->notify->driver_data = ecm;\r\n} else if (intf == ecm->data_id) {\r\nif (alt > 1)\r\ngoto fail;\r\nif (ecm->port.in_ep->driver_data) {\r\nDBG(cdev, "reset ecm\n");\r\ngether_disconnect(&ecm->port);\r\n}\r\nif (!ecm->port.in_ep->desc ||\r\n!ecm->port.out_ep->desc) {\r\nDBG(cdev, "init ecm\n");\r\nif (config_ep_by_speed(cdev->gadget, f,\r\necm->port.in_ep) ||\r\nconfig_ep_by_speed(cdev->gadget, f,\r\necm->port.out_ep)) {\r\necm->port.in_ep->desc = NULL;\r\necm->port.out_ep->desc = NULL;\r\ngoto fail;\r\n}\r\n}\r\nif (alt == 1) {\r\nstruct net_device *net;\r\necm->port.is_zlp_ok = !(gadget_is_musbhdrc(cdev->gadget)\r\n);\r\necm->port.cdc_filter = DEFAULT_FILTER;\r\nDBG(cdev, "activate ecm\n");\r\nnet = gether_connect(&ecm->port);\r\nif (IS_ERR(net))\r\nreturn PTR_ERR(net);\r\n}\r\necm_notify(ecm);\r\n} else\r\ngoto fail;\r\nreturn 0;\r\nfail:\r\nreturn -EINVAL;\r\n}\r\nstatic int ecm_get_alt(struct usb_function *f, unsigned intf)\r\n{\r\nstruct f_ecm *ecm = func_to_ecm(f);\r\nif (intf == ecm->ctrl_id)\r\nreturn 0;\r\nreturn ecm->port.in_ep->driver_data ? 1 : 0;\r\n}\r\nstatic void ecm_disable(struct usb_function *f)\r\n{\r\nstruct f_ecm *ecm = func_to_ecm(f);\r\nstruct usb_composite_dev *cdev = f->config->cdev;\r\nDBG(cdev, "ecm deactivated\n");\r\nif (ecm->port.in_ep->driver_data)\r\ngether_disconnect(&ecm->port);\r\nif (ecm->notify->driver_data) {\r\nusb_ep_disable(ecm->notify);\r\necm->notify->driver_data = NULL;\r\necm->notify->desc = NULL;\r\n}\r\n}\r\nstatic void ecm_open(struct gether *geth)\r\n{\r\nstruct f_ecm *ecm = func_to_ecm(&geth->func);\r\nDBG(ecm->port.func.config->cdev, "%s\n", __func__);\r\necm->is_open = true;\r\necm_notify(ecm);\r\n}\r\nstatic void ecm_close(struct gether *geth)\r\n{\r\nstruct f_ecm *ecm = func_to_ecm(&geth->func);\r\nDBG(ecm->port.func.config->cdev, "%s\n", __func__);\r\necm->is_open = false;\r\necm_notify(ecm);\r\n}\r\nstatic int\r\necm_bind(struct usb_configuration *c, struct usb_function *f)\r\n{\r\nstruct usb_composite_dev *cdev = c->cdev;\r\nstruct f_ecm *ecm = func_to_ecm(f);\r\nint status;\r\nstruct usb_ep *ep;\r\nstatus = usb_interface_id(c, f);\r\nif (status < 0)\r\ngoto fail;\r\necm->ctrl_id = status;\r\necm_iad_descriptor.bFirstInterface = status;\r\necm_control_intf.bInterfaceNumber = status;\r\necm_union_desc.bMasterInterface0 = status;\r\nstatus = usb_interface_id(c, f);\r\nif (status < 0)\r\ngoto fail;\r\necm->data_id = status;\r\necm_data_nop_intf.bInterfaceNumber = status;\r\necm_data_intf.bInterfaceNumber = status;\r\necm_union_desc.bSlaveInterface0 = status;\r\nstatus = -ENODEV;\r\nep = usb_ep_autoconfig(cdev->gadget, &fs_ecm_in_desc);\r\nif (!ep)\r\ngoto fail;\r\necm->port.in_ep = ep;\r\nep->driver_data = cdev;\r\nep = usb_ep_autoconfig(cdev->gadget, &fs_ecm_out_desc);\r\nif (!ep)\r\ngoto fail;\r\necm->port.out_ep = ep;\r\nep->driver_data = cdev;\r\nep = usb_ep_autoconfig(cdev->gadget, &fs_ecm_notify_desc);\r\nif (!ep)\r\ngoto fail;\r\necm->notify = ep;\r\nep->driver_data = cdev;\r\nstatus = -ENOMEM;\r\necm->notify_req = usb_ep_alloc_request(ep, GFP_KERNEL);\r\nif (!ecm->notify_req)\r\ngoto fail;\r\necm->notify_req->buf = kmalloc(ECM_STATUS_BYTECOUNT, GFP_KERNEL);\r\nif (!ecm->notify_req->buf)\r\ngoto fail;\r\necm->notify_req->context = ecm;\r\necm->notify_req->complete = ecm_notify_complete;\r\nhs_ecm_in_desc.bEndpointAddress = fs_ecm_in_desc.bEndpointAddress;\r\nhs_ecm_out_desc.bEndpointAddress = fs_ecm_out_desc.bEndpointAddress;\r\nhs_ecm_notify_desc.bEndpointAddress =\r\nfs_ecm_notify_desc.bEndpointAddress;\r\nss_ecm_in_desc.bEndpointAddress = fs_ecm_in_desc.bEndpointAddress;\r\nss_ecm_out_desc.bEndpointAddress = fs_ecm_out_desc.bEndpointAddress;\r\nss_ecm_notify_desc.bEndpointAddress =\r\nfs_ecm_notify_desc.bEndpointAddress;\r\nstatus = usb_assign_descriptors(f, ecm_fs_function, ecm_hs_function,\r\necm_ss_function);\r\nif (status)\r\ngoto fail;\r\necm->port.open = ecm_open;\r\necm->port.close = ecm_close;\r\nDBG(cdev, "CDC Ethernet: %s speed IN/%s OUT/%s NOTIFY/%s\n",\r\ngadget_is_superspeed(c->cdev->gadget) ? "super" :\r\ngadget_is_dualspeed(c->cdev->gadget) ? "dual" : "full",\r\necm->port.in_ep->name, ecm->port.out_ep->name,\r\necm->notify->name);\r\nreturn 0;\r\nfail:\r\nif (ecm->notify_req) {\r\nkfree(ecm->notify_req->buf);\r\nusb_ep_free_request(ecm->notify, ecm->notify_req);\r\n}\r\nif (ecm->notify)\r\necm->notify->driver_data = NULL;\r\nif (ecm->port.out_ep)\r\necm->port.out_ep->driver_data = NULL;\r\nif (ecm->port.in_ep)\r\necm->port.in_ep->driver_data = NULL;\r\nERROR(cdev, "%s: can't bind, err %d\n", f->name, status);\r\nreturn status;\r\n}\r\nstatic void\r\necm_unbind(struct usb_configuration *c, struct usb_function *f)\r\n{\r\nstruct f_ecm *ecm = func_to_ecm(f);\r\nDBG(c->cdev, "ecm unbind\n");\r\necm_string_defs[0].id = 0;\r\nusb_free_all_descriptors(f);\r\nkfree(ecm->notify_req->buf);\r\nusb_ep_free_request(ecm->notify, ecm->notify_req);\r\nkfree(ecm);\r\n}\r\nint\r\necm_bind_config(struct usb_configuration *c, u8 ethaddr[ETH_ALEN])\r\n{\r\nstruct f_ecm *ecm;\r\nint status;\r\nif (!can_support_ecm(c->cdev->gadget) || !ethaddr)\r\nreturn -EINVAL;\r\nif (ecm_string_defs[0].id == 0) {\r\nstatus = usb_string_ids_tab(c->cdev, ecm_string_defs);\r\nif (status)\r\nreturn status;\r\necm_control_intf.iInterface = ecm_string_defs[0].id;\r\necm_data_intf.iInterface = ecm_string_defs[2].id;\r\necm_desc.iMACAddress = ecm_string_defs[1].id;\r\necm_iad_descriptor.iFunction = ecm_string_defs[3].id;\r\n}\r\necm = kzalloc(sizeof *ecm, GFP_KERNEL);\r\nif (!ecm)\r\nreturn -ENOMEM;\r\nsnprintf(ecm->ethaddr, sizeof ecm->ethaddr, "%pm", ethaddr);\r\necm_string_defs[1].s = ecm->ethaddr;\r\necm->port.cdc_filter = DEFAULT_FILTER;\r\necm->port.func.name = "cdc_ethernet";\r\necm->port.func.strings = ecm_strings;\r\necm->port.func.bind = ecm_bind;\r\necm->port.func.unbind = ecm_unbind;\r\necm->port.func.set_alt = ecm_set_alt;\r\necm->port.func.get_alt = ecm_get_alt;\r\necm->port.func.setup = ecm_setup;\r\necm->port.func.disable = ecm_disable;\r\nstatus = usb_add_function(c, &ecm->port.func);\r\nif (status)\r\nkfree(ecm);\r\nreturn status;\r\n}
