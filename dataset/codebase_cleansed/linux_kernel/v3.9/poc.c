static int readback_insn(struct comedi_device *dev, struct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nstruct poc_private *devpriv = dev->private;\r\nint chan;\r\nchan = CR_CHAN(insn->chanspec);\r\ndata[0] = devpriv->ao_readback[chan];\r\nreturn 1;\r\n}\r\nstatic int dac02_ao_winsn(struct comedi_device *dev, struct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nstruct poc_private *devpriv = dev->private;\r\nint temp;\r\nint chan;\r\nint output;\r\nchan = CR_CHAN(insn->chanspec);\r\ndevpriv->ao_readback[chan] = data[0];\r\noutput = data[0];\r\n#ifdef wrong\r\nif ((CR_RANGE(insn->chanspec) & 0x2) == 0)\r\noutput = ~output;\r\n#endif\r\ntemp = (output << 4) & 0xf0;\r\noutb(temp, dev->iobase + DAC02_LSB(chan));\r\ntemp = (output >> 4) & 0xff;\r\noutb(temp, dev->iobase + DAC02_MSB(chan));\r\nreturn 1;\r\n}\r\nstatic int pcl733_insn_bits(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\ndata[1] = inb(dev->iobase + 0);\r\ndata[1] |= (inb(dev->iobase + 1) << 8);\r\ndata[1] |= (inb(dev->iobase + 2) << 16);\r\ndata[1] |= (inb(dev->iobase + 3) << 24);\r\nreturn insn->n;\r\n}\r\nstatic int pcl734_insn_bits(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nif (data[0]) {\r\ns->state &= ~data[0];\r\ns->state |= (data[0] & data[1]);\r\nif ((data[0] >> 0) & 0xff)\r\noutb((s->state >> 0) & 0xff, dev->iobase + 0);\r\nif ((data[0] >> 8) & 0xff)\r\noutb((s->state >> 8) & 0xff, dev->iobase + 1);\r\nif ((data[0] >> 16) & 0xff)\r\noutb((s->state >> 16) & 0xff, dev->iobase + 2);\r\nif ((data[0] >> 24) & 0xff)\r\noutb((s->state >> 24) & 0xff, dev->iobase + 3);\r\n}\r\ndata[1] = s->state;\r\nreturn insn->n;\r\n}\r\nstatic int poc_attach(struct comedi_device *dev, struct comedi_devconfig *it)\r\n{\r\nconst struct boarddef_struct *board = comedi_board(dev);\r\nstruct poc_private *devpriv;\r\nstruct comedi_subdevice *s;\r\nunsigned long iobase;\r\nunsigned int iosize;\r\nint ret;\r\niobase = it->options[0];\r\nprintk(KERN_INFO "comedi%d: poc: using %s iobase 0x%lx\n", dev->minor,\r\nboard->name, iobase);\r\ndev->board_name = board->name;\r\nif (iobase == 0) {\r\nprintk(KERN_ERR "io base address required\n");\r\nreturn -EINVAL;\r\n}\r\niosize = board->iosize;\r\nif (!request_region(iobase, iosize, "dac02")) {\r\nprintk(KERN_ERR "I/O port conflict: failed to allocate ports "\r\n"0x%lx to 0x%lx\n", iobase, iobase + iosize - 1);\r\nreturn -EIO;\r\n}\r\ndev->iobase = iobase;\r\nret = comedi_alloc_subdevices(dev, 1);\r\nif (ret)\r\nreturn ret;\r\ndevpriv = kzalloc(sizeof(*devpriv), GFP_KERNEL);\r\nif (!devpriv)\r\nreturn -ENOMEM;\r\ndev->private = devpriv;\r\ns = &dev->subdevices[0];\r\ns->type = board->type;\r\ns->n_chan = board->n_chan;\r\ns->maxdata = (1 << board->n_bits) - 1;\r\ns->range_table = board->range;\r\ns->insn_write = board->winsn;\r\ns->insn_read = board->rinsn;\r\ns->insn_bits = board->insnbits;\r\nif (s->type == COMEDI_SUBD_AO || s->type == COMEDI_SUBD_DO)\r\ns->subdev_flags = SDF_WRITABLE;\r\nreturn 0;\r\n}\r\nstatic void poc_detach(struct comedi_device *dev)\r\n{\r\nconst struct boarddef_struct *board = comedi_board(dev);\r\nif (dev->iobase)\r\nrelease_region(dev->iobase, board->iosize);\r\n}
