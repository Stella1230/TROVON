static int scs_output_open(struct snd_rawmidi_substream *stream)\r\n{\r\nstruct scs *scs = stream->rmidi->private_data;\r\nscs->output_status = 0;\r\nscs->output_bytes = 1;\r\nscs->output_escaped = false;\r\nreturn 0;\r\n}\r\nstatic int scs_output_close(struct snd_rawmidi_substream *stream)\r\n{\r\nreturn 0;\r\n}\r\nstatic void scs_output_trigger(struct snd_rawmidi_substream *stream, int up)\r\n{\r\nstruct scs *scs = stream->rmidi->private_data;\r\nACCESS_ONCE(scs->output) = up ? stream : NULL;\r\nif (up) {\r\nscs->output_idle = false;\r\ntasklet_schedule(&scs->tasklet);\r\n}\r\n}\r\nstatic void scs_write_callback(struct fw_card *card, int rcode,\r\nvoid *data, size_t length, void *callback_data)\r\n{\r\nstruct scs *scs = callback_data;\r\nif (rcode == RCODE_GENERATION) {\r\n}\r\nscs->transaction_running = false;\r\ntasklet_schedule(&scs->tasklet);\r\n}\r\nstatic bool is_valid_running_status(u8 status)\r\n{\r\nreturn status >= 0x80 && status <= 0xef;\r\n}\r\nstatic bool is_one_byte_cmd(u8 status)\r\n{\r\nreturn status == 0xf6 ||\r\nstatus >= 0xf8;\r\n}\r\nstatic bool is_two_bytes_cmd(u8 status)\r\n{\r\nreturn (status >= 0xc0 && status <= 0xdf) ||\r\nstatus == 0xf1 ||\r\nstatus == 0xf3;\r\n}\r\nstatic bool is_three_bytes_cmd(u8 status)\r\n{\r\nreturn (status >= 0x80 && status <= 0xbf) ||\r\n(status >= 0xe0 && status <= 0xef) ||\r\nstatus == 0xf2;\r\n}\r\nstatic bool is_invalid_cmd(u8 status)\r\n{\r\nreturn status == 0xf4 ||\r\nstatus == 0xf5 ||\r\nstatus == 0xf9 ||\r\nstatus == 0xfd;\r\n}\r\nstatic void scs_output_tasklet(unsigned long data)\r\n{\r\nstruct scs *scs = (void *)data;\r\nstruct snd_rawmidi_substream *stream;\r\nunsigned int i;\r\nu8 byte;\r\nstruct fw_device *dev;\r\nint generation;\r\nif (scs->transaction_running)\r\nreturn;\r\nstream = ACCESS_ONCE(scs->output);\r\nif (!stream) {\r\nscs->output_idle = true;\r\nwake_up(&scs->idle_wait);\r\nreturn;\r\n}\r\ni = scs->output_bytes;\r\nfor (;;) {\r\nif (snd_rawmidi_transmit(stream, &byte, 1) != 1) {\r\nscs->output_bytes = i;\r\nscs->output_idle = true;\r\nwake_up(&scs->idle_wait);\r\nreturn;\r\n}\r\nif (scs->output_escaped && byte < 0x80) {\r\nif (scs->output_escape_high_nibble) {\r\nif (i < HSS1394_MAX_PACKET_SIZE) {\r\nscs->buffer[i] = byte << 4;\r\nscs->output_escape_high_nibble = false;\r\n}\r\n} else {\r\nscs->buffer[i++] |= byte & 0x0f;\r\nscs->output_escape_high_nibble = true;\r\n}\r\n} else if (byte < 0x80) {\r\nif (i == 1) {\r\nif (!is_valid_running_status(scs->output_status))\r\ncontinue;\r\nscs->buffer[0] = HSS1394_TAG_USER_DATA;\r\nscs->buffer[i++] = scs->output_status;\r\n}\r\nscs->buffer[i++] = byte;\r\nif ((i == 3 && is_two_bytes_cmd(scs->output_status)) ||\r\n(i == 4 && is_three_bytes_cmd(scs->output_status)))\r\nbreak;\r\nif (i == 1 + ARRAY_SIZE(sysex_escape_prefix) &&\r\n!memcmp(scs->buffer + 1, sysex_escape_prefix,\r\nARRAY_SIZE(sysex_escape_prefix))) {\r\nscs->output_escaped = true;\r\nscs->output_escape_high_nibble = true;\r\ni = 0;\r\n}\r\nif (i >= HSS1394_MAX_PACKET_SIZE)\r\ni = 1;\r\n} else if (byte == 0xf7) {\r\nif (scs->output_escaped) {\r\nif (i >= 1 && scs->output_escape_high_nibble &&\r\nscs->buffer[0] != HSS1394_TAG_CHANGE_ADDRESS)\r\nbreak;\r\n} else {\r\nif (i > 1 && scs->output_status == 0xf0) {\r\nscs->buffer[i++] = 0xf7;\r\nbreak;\r\n}\r\n}\r\ni = 1;\r\nscs->output_escaped = false;\r\n} else if (!is_invalid_cmd(byte) &&\r\nbyte < 0xf8) {\r\ni = 1;\r\nscs->buffer[0] = HSS1394_TAG_USER_DATA;\r\nscs->buffer[i++] = byte;\r\nscs->output_status = byte;\r\nscs->output_escaped = false;\r\nif (is_one_byte_cmd(byte))\r\nbreak;\r\n}\r\n}\r\nscs->output_bytes = 1;\r\nscs->output_escaped = false;\r\nscs->transaction_running = true;\r\ndev = fw_parent_device(scs->unit);\r\ngeneration = dev->generation;\r\nsmp_rmb();\r\nfw_send_request(dev->card, &scs->transaction, TCODE_WRITE_BLOCK_REQUEST,\r\ndev->node_id, generation, dev->max_speed,\r\nHSS1394_ADDRESS, scs->buffer, i,\r\nscs_write_callback, scs);\r\n}\r\nstatic void scs_output_drain(struct snd_rawmidi_substream *stream)\r\n{\r\nstruct scs *scs = stream->rmidi->private_data;\r\nwait_event(scs->idle_wait, scs->output_idle);\r\n}\r\nstatic int scs_input_open(struct snd_rawmidi_substream *stream)\r\n{\r\nstruct scs *scs = stream->rmidi->private_data;\r\nscs->input_escape_count = 0;\r\nreturn 0;\r\n}\r\nstatic int scs_input_close(struct snd_rawmidi_substream *stream)\r\n{\r\nreturn 0;\r\n}\r\nstatic void scs_input_trigger(struct snd_rawmidi_substream *stream, int up)\r\n{\r\nstruct scs *scs = stream->rmidi->private_data;\r\nACCESS_ONCE(scs->input) = up ? stream : NULL;\r\n}\r\nstatic void scs_input_escaped_byte(struct snd_rawmidi_substream *stream,\r\nu8 byte)\r\n{\r\nu8 nibbles[2];\r\nnibbles[0] = byte >> 4;\r\nnibbles[1] = byte & 0x0f;\r\nsnd_rawmidi_receive(stream, nibbles, 2);\r\n}\r\nstatic void scs_input_midi_byte(struct scs *scs,\r\nstruct snd_rawmidi_substream *stream,\r\nu8 byte)\r\n{\r\nif (scs->input_escape_count > 0) {\r\nscs_input_escaped_byte(stream, byte);\r\nscs->input_escape_count--;\r\nif (scs->input_escape_count == 0)\r\nsnd_rawmidi_receive(stream, (const u8[]) { 0xf7 }, 1);\r\n} else if (byte == 0xf9) {\r\nsnd_rawmidi_receive(stream, sysex_escape_prefix,\r\nARRAY_SIZE(sysex_escape_prefix));\r\nscs_input_escaped_byte(stream, 0x00);\r\nscs_input_escaped_byte(stream, 0xf9);\r\nscs->input_escape_count = 3;\r\n} else {\r\nsnd_rawmidi_receive(stream, &byte, 1);\r\n}\r\n}\r\nstatic void scs_input_packet(struct scs *scs,\r\nstruct snd_rawmidi_substream *stream,\r\nconst u8 *data, unsigned int bytes)\r\n{\r\nunsigned int i;\r\nif (data[0] == HSS1394_TAG_USER_DATA) {\r\nfor (i = 1; i < bytes; ++i)\r\nscs_input_midi_byte(scs, stream, data[i]);\r\n} else {\r\nsnd_rawmidi_receive(stream, sysex_escape_prefix,\r\nARRAY_SIZE(sysex_escape_prefix));\r\nfor (i = 0; i < bytes; ++i)\r\nscs_input_escaped_byte(stream, data[i]);\r\nsnd_rawmidi_receive(stream, (const u8[]) { 0xf7 }, 1);\r\n}\r\n}\r\nstatic int scs_create_midi(struct scs *scs)\r\n{\r\nstruct snd_rawmidi *rmidi;\r\nint err;\r\nerr = snd_rawmidi_new(scs->card, "SCS.1x", 0, 1, 1, &rmidi);\r\nif (err < 0)\r\nreturn err;\r\nsnprintf(rmidi->name, sizeof(rmidi->name),\r\n"%s MIDI", scs->card->shortname);\r\nrmidi->info_flags = SNDRV_RAWMIDI_INFO_OUTPUT |\r\nSNDRV_RAWMIDI_INFO_INPUT |\r\nSNDRV_RAWMIDI_INFO_DUPLEX;\r\nrmidi->private_data = scs;\r\nsnd_rawmidi_set_ops(rmidi, SNDRV_RAWMIDI_STREAM_OUTPUT, &output_ops);\r\nsnd_rawmidi_set_ops(rmidi, SNDRV_RAWMIDI_STREAM_INPUT, &input_ops);\r\nreturn 0;\r\n}\r\nstatic void handle_hss(struct fw_card *card, struct fw_request *request,\r\nint tcode, int destination, int source, int generation,\r\nunsigned long long offset, void *data, size_t length,\r\nvoid *callback_data)\r\n{\r\nstruct scs *scs = callback_data;\r\nstruct snd_rawmidi_substream *stream;\r\nif (offset != scs->hss_handler.offset) {\r\nfw_send_response(card, request, RCODE_ADDRESS_ERROR);\r\nreturn;\r\n}\r\nif (tcode != TCODE_WRITE_QUADLET_REQUEST &&\r\ntcode != TCODE_WRITE_BLOCK_REQUEST) {\r\nfw_send_response(card, request, RCODE_TYPE_ERROR);\r\nreturn;\r\n}\r\nif (length >= 1) {\r\nstream = ACCESS_ONCE(scs->input);\r\nif (stream)\r\nscs_input_packet(scs, stream, data, length);\r\n}\r\nfw_send_response(card, request, RCODE_COMPLETE);\r\n}\r\nstatic int scs_init_hss_address(struct scs *scs)\r\n{\r\n__be64 data;\r\nint err;\r\ndata = cpu_to_be64(((u64)HSS1394_TAG_CHANGE_ADDRESS << 56) |\r\nscs->hss_handler.offset);\r\nerr = snd_fw_transaction(scs->unit, TCODE_WRITE_BLOCK_REQUEST,\r\nHSS1394_ADDRESS, &data, 8);\r\nif (err < 0)\r\ndev_err(&scs->unit->device, "HSS1394 communication failed\n");\r\nreturn err;\r\n}\r\nstatic void scs_card_free(struct snd_card *card)\r\n{\r\nstruct scs *scs = card->private_data;\r\nfw_core_remove_address_handler(&scs->hss_handler);\r\nkfree(scs->buffer);\r\n}\r\nstatic int scs_probe(struct device *unit_dev)\r\n{\r\nstruct fw_unit *unit = fw_unit(unit_dev);\r\nstruct fw_device *fw_dev = fw_parent_device(unit);\r\nstruct snd_card *card;\r\nstruct scs *scs;\r\nint err;\r\nerr = snd_card_create(-16, NULL, THIS_MODULE, sizeof(*scs), &card);\r\nif (err < 0)\r\nreturn err;\r\nsnd_card_set_dev(card, unit_dev);\r\nscs = card->private_data;\r\nscs->card = card;\r\nscs->unit = unit;\r\ntasklet_init(&scs->tasklet, scs_output_tasklet, (unsigned long)scs);\r\ninit_waitqueue_head(&scs->idle_wait);\r\nscs->output_idle = true;\r\nscs->buffer = kmalloc(HSS1394_MAX_PACKET_SIZE, GFP_KERNEL);\r\nif (!scs->buffer)\r\ngoto err_card;\r\nscs->hss_handler.length = HSS1394_MAX_PACKET_SIZE;\r\nscs->hss_handler.address_callback = handle_hss;\r\nscs->hss_handler.callback_data = scs;\r\nerr = fw_core_add_address_handler(&scs->hss_handler,\r\n&fw_high_memory_region);\r\nif (err < 0)\r\ngoto err_buffer;\r\ncard->private_free = scs_card_free;\r\nstrcpy(card->driver, "SCS.1x");\r\nstrcpy(card->shortname, "SCS.1x");\r\nfw_csr_string(unit->directory, CSR_MODEL,\r\ncard->shortname, sizeof(card->shortname));\r\nsnprintf(card->longname, sizeof(card->longname),\r\n"Stanton DJ %s (GUID %08x%08x) at %s, S%d",\r\ncard->shortname, fw_dev->config_rom[3], fw_dev->config_rom[4],\r\ndev_name(&unit->device), 100 << fw_dev->max_speed);\r\nstrcpy(card->mixername, card->shortname);\r\nerr = scs_init_hss_address(scs);\r\nif (err < 0)\r\ngoto err_card;\r\nerr = scs_create_midi(scs);\r\nif (err < 0)\r\ngoto err_card;\r\nerr = snd_card_register(card);\r\nif (err < 0)\r\ngoto err_card;\r\ndev_set_drvdata(unit_dev, scs);\r\nreturn 0;\r\nerr_buffer:\r\nkfree(scs->buffer);\r\nerr_card:\r\nsnd_card_free(card);\r\nreturn err;\r\n}\r\nstatic int scs_remove(struct device *dev)\r\n{\r\nstruct scs *scs = dev_get_drvdata(dev);\r\nsnd_card_disconnect(scs->card);\r\nACCESS_ONCE(scs->output) = NULL;\r\nACCESS_ONCE(scs->input) = NULL;\r\nwait_event(scs->idle_wait, scs->output_idle);\r\ntasklet_kill(&scs->tasklet);\r\nsnd_card_free_when_closed(scs->card);\r\nreturn 0;\r\n}\r\nstatic void scs_update(struct fw_unit *unit)\r\n{\r\nstruct scs *scs = dev_get_drvdata(&unit->device);\r\n__be64 data;\r\ndata = cpu_to_be64(((u64)HSS1394_TAG_CHANGE_ADDRESS << 56) |\r\nscs->hss_handler.offset);\r\nsnd_fw_transaction(scs->unit, TCODE_WRITE_BLOCK_REQUEST,\r\nHSS1394_ADDRESS, &data, 8);\r\n}\r\nstatic int __init alsa_scs1x_init(void)\r\n{\r\nreturn driver_register(&scs_driver.driver);\r\n}\r\nstatic void __exit alsa_scs1x_exit(void)\r\n{\r\ndriver_unregister(&scs_driver.driver);\r\n}
