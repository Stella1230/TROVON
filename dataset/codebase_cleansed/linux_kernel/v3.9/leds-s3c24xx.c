static inline struct s3c24xx_gpio_led *pdev_to_gpio(struct platform_device *dev)\r\n{\r\nreturn platform_get_drvdata(dev);\r\n}\r\nstatic inline struct s3c24xx_gpio_led *to_gpio(struct led_classdev *led_cdev)\r\n{\r\nreturn container_of(led_cdev, struct s3c24xx_gpio_led, cdev);\r\n}\r\nstatic void s3c24xx_led_set(struct led_classdev *led_cdev,\r\nenum led_brightness value)\r\n{\r\nstruct s3c24xx_gpio_led *led = to_gpio(led_cdev);\r\nstruct s3c24xx_led_platdata *pd = led->pdata;\r\nint state = (value ? 1 : 0) ^ (pd->flags & S3C24XX_LEDF_ACTLOW);\r\ngpio_set_value(pd->gpio, state);\r\nif (pd->flags & S3C24XX_LEDF_TRISTATE) {\r\nif (value)\r\ngpio_direction_output(pd->gpio, state);\r\nelse\r\ngpio_direction_input(pd->gpio);\r\n}\r\n}\r\nstatic int s3c24xx_led_remove(struct platform_device *dev)\r\n{\r\nstruct s3c24xx_gpio_led *led = pdev_to_gpio(dev);\r\nled_classdev_unregister(&led->cdev);\r\nreturn 0;\r\n}\r\nstatic int s3c24xx_led_probe(struct platform_device *dev)\r\n{\r\nstruct s3c24xx_led_platdata *pdata = dev->dev.platform_data;\r\nstruct s3c24xx_gpio_led *led;\r\nint ret;\r\nled = devm_kzalloc(&dev->dev, sizeof(struct s3c24xx_gpio_led),\r\nGFP_KERNEL);\r\nif (led == NULL) {\r\ndev_err(&dev->dev, "No memory for device\n");\r\nreturn -ENOMEM;\r\n}\r\nplatform_set_drvdata(dev, led);\r\nled->cdev.brightness_set = s3c24xx_led_set;\r\nled->cdev.default_trigger = pdata->def_trigger;\r\nled->cdev.name = pdata->name;\r\nled->cdev.flags |= LED_CORE_SUSPENDRESUME;\r\nled->pdata = pdata;\r\nret = devm_gpio_request(&dev->dev, pdata->gpio, "S3C24XX_LED");\r\nif (ret < 0)\r\nreturn ret;\r\ns3c_gpio_setpull(pdata->gpio, S3C_GPIO_PULL_NONE);\r\nif (pdata->flags & S3C24XX_LEDF_TRISTATE)\r\ngpio_direction_input(pdata->gpio);\r\nelse\r\ngpio_direction_output(pdata->gpio,\r\npdata->flags & S3C24XX_LEDF_ACTLOW ? 1 : 0);\r\nret = led_classdev_register(&dev->dev, &led->cdev);\r\nif (ret < 0)\r\ndev_err(&dev->dev, "led_classdev_register failed\n");\r\nreturn ret;\r\n}
