static void __mdio_cmd(void __iomem *ioaddr, u32 ctl)\r\n{\r\nunsigned int i;\r\nSIS_W32(GMIIControl, ctl);\r\nmsleep(1);\r\nfor (i = 0; i < 100; i++) {\r\nif (!(SIS_R32(GMIIControl) & EhnMIInotDone))\r\nbreak;\r\nmsleep(1);\r\n}\r\nif (i > 99)\r\npr_err("PHY command failed !\n");\r\n}\r\nstatic void mdio_write(void __iomem *ioaddr, int phy_id, int reg, int val)\r\n{\r\n__mdio_cmd(ioaddr, EhnMIIreq | EhnMIIwrite |\r\n(((u32) reg) << EhnMIIregShift) | (phy_id << EhnMIIpmdShift) |\r\n(((u32) val) << EhnMIIdataShift));\r\n}\r\nstatic int mdio_read(void __iomem *ioaddr, int phy_id, int reg)\r\n{\r\n__mdio_cmd(ioaddr, EhnMIIreq | EhnMIIread |\r\n(((u32) reg) << EhnMIIregShift) | (phy_id << EhnMIIpmdShift));\r\nreturn (u16) (SIS_R32(GMIIControl) >> EhnMIIdataShift);\r\n}\r\nstatic void __mdio_write(struct net_device *dev, int phy_id, int reg, int val)\r\n{\r\nstruct sis190_private *tp = netdev_priv(dev);\r\nmdio_write(tp->mmio_addr, phy_id, reg, val);\r\n}\r\nstatic int __mdio_read(struct net_device *dev, int phy_id, int reg)\r\n{\r\nstruct sis190_private *tp = netdev_priv(dev);\r\nreturn mdio_read(tp->mmio_addr, phy_id, reg);\r\n}\r\nstatic u16 mdio_read_latched(void __iomem *ioaddr, int phy_id, int reg)\r\n{\r\nmdio_read(ioaddr, phy_id, reg);\r\nreturn mdio_read(ioaddr, phy_id, reg);\r\n}\r\nstatic u16 sis190_read_eeprom(void __iomem *ioaddr, u32 reg)\r\n{\r\nu16 data = 0xffff;\r\nunsigned int i;\r\nif (!(SIS_R32(ROMControl) & 0x0002))\r\nreturn 0;\r\nSIS_W32(ROMInterface, EEREQ | EEROP | (reg << 10));\r\nfor (i = 0; i < 200; i++) {\r\nif (!(SIS_R32(ROMInterface) & EEREQ)) {\r\ndata = (SIS_R32(ROMInterface) & 0xffff0000) >> 16;\r\nbreak;\r\n}\r\nmsleep(1);\r\n}\r\nreturn data;\r\n}\r\nstatic void sis190_irq_mask_and_ack(void __iomem *ioaddr)\r\n{\r\nSIS_W32(IntrMask, 0x00);\r\nSIS_W32(IntrStatus, 0xffffffff);\r\nSIS_PCI_COMMIT();\r\n}\r\nstatic void sis190_asic_down(void __iomem *ioaddr)\r\n{\r\nSIS_W32(TxControl, 0x1a00);\r\nSIS_W32(RxControl, 0x1a00);\r\nsis190_irq_mask_and_ack(ioaddr);\r\n}\r\nstatic void sis190_mark_as_last_descriptor(struct RxDesc *desc)\r\n{\r\ndesc->size |= cpu_to_le32(RingEnd);\r\n}\r\nstatic inline void sis190_give_to_asic(struct RxDesc *desc, u32 rx_buf_sz)\r\n{\r\nu32 eor = le32_to_cpu(desc->size) & RingEnd;\r\ndesc->PSize = 0x0;\r\ndesc->size = cpu_to_le32((rx_buf_sz & RX_BUF_MASK) | eor);\r\nwmb();\r\ndesc->status = cpu_to_le32(OWNbit | INTbit);\r\n}\r\nstatic inline void sis190_map_to_asic(struct RxDesc *desc, dma_addr_t mapping,\r\nu32 rx_buf_sz)\r\n{\r\ndesc->addr = cpu_to_le32(mapping);\r\nsis190_give_to_asic(desc, rx_buf_sz);\r\n}\r\nstatic inline void sis190_make_unusable_by_asic(struct RxDesc *desc)\r\n{\r\ndesc->PSize = 0x0;\r\ndesc->addr = cpu_to_le32(0xdeadbeef);\r\ndesc->size &= cpu_to_le32(RingEnd);\r\nwmb();\r\ndesc->status = 0x0;\r\n}\r\nstatic struct sk_buff *sis190_alloc_rx_skb(struct sis190_private *tp,\r\nstruct RxDesc *desc)\r\n{\r\nu32 rx_buf_sz = tp->rx_buf_sz;\r\nstruct sk_buff *skb;\r\ndma_addr_t mapping;\r\nskb = netdev_alloc_skb(tp->dev, rx_buf_sz);\r\nif (unlikely(!skb))\r\ngoto skb_alloc_failed;\r\nmapping = pci_map_single(tp->pci_dev, skb->data, tp->rx_buf_sz,\r\nPCI_DMA_FROMDEVICE);\r\nif (pci_dma_mapping_error(tp->pci_dev, mapping))\r\ngoto out;\r\nsis190_map_to_asic(desc, mapping, rx_buf_sz);\r\nreturn skb;\r\nout:\r\ndev_kfree_skb_any(skb);\r\nskb_alloc_failed:\r\nsis190_make_unusable_by_asic(desc);\r\nreturn NULL;\r\n}\r\nstatic u32 sis190_rx_fill(struct sis190_private *tp, struct net_device *dev,\r\nu32 start, u32 end)\r\n{\r\nu32 cur;\r\nfor (cur = start; cur < end; cur++) {\r\nunsigned int i = cur % NUM_RX_DESC;\r\nif (tp->Rx_skbuff[i])\r\ncontinue;\r\ntp->Rx_skbuff[i] = sis190_alloc_rx_skb(tp, tp->RxDescRing + i);\r\nif (!tp->Rx_skbuff[i])\r\nbreak;\r\n}\r\nreturn cur - start;\r\n}\r\nstatic bool sis190_try_rx_copy(struct sis190_private *tp,\r\nstruct sk_buff **sk_buff, int pkt_size,\r\ndma_addr_t addr)\r\n{\r\nstruct sk_buff *skb;\r\nbool done = false;\r\nif (pkt_size >= rx_copybreak)\r\ngoto out;\r\nskb = netdev_alloc_skb_ip_align(tp->dev, pkt_size);\r\nif (!skb)\r\ngoto out;\r\npci_dma_sync_single_for_cpu(tp->pci_dev, addr, tp->rx_buf_sz,\r\nPCI_DMA_FROMDEVICE);\r\nskb_copy_to_linear_data(skb, sk_buff[0]->data, pkt_size);\r\n*sk_buff = skb;\r\ndone = true;\r\nout:\r\nreturn done;\r\n}\r\nstatic inline int sis190_rx_pkt_err(u32 status, struct net_device_stats *stats)\r\n{\r\n#define ErrMask (OVRUN | SHORT | LIMIT | MIIER | NIBON | COLON | ABORT)\r\nif ((status & CRCOK) && !(status & ErrMask))\r\nreturn 0;\r\nif (!(status & CRCOK))\r\nstats->rx_crc_errors++;\r\nelse if (status & OVRUN)\r\nstats->rx_over_errors++;\r\nelse if (status & (SHORT | LIMIT))\r\nstats->rx_length_errors++;\r\nelse if (status & (MIIER | NIBON | COLON))\r\nstats->rx_frame_errors++;\r\nstats->rx_errors++;\r\nreturn -1;\r\n}\r\nstatic int sis190_rx_interrupt(struct net_device *dev,\r\nstruct sis190_private *tp, void __iomem *ioaddr)\r\n{\r\nstruct net_device_stats *stats = &dev->stats;\r\nu32 rx_left, cur_rx = tp->cur_rx;\r\nu32 delta, count;\r\nrx_left = NUM_RX_DESC + tp->dirty_rx - cur_rx;\r\nrx_left = sis190_rx_quota(rx_left, (u32) dev->quota);\r\nfor (; rx_left > 0; rx_left--, cur_rx++) {\r\nunsigned int entry = cur_rx % NUM_RX_DESC;\r\nstruct RxDesc *desc = tp->RxDescRing + entry;\r\nu32 status;\r\nif (le32_to_cpu(desc->status) & OWNbit)\r\nbreak;\r\nstatus = le32_to_cpu(desc->PSize);\r\nif (sis190_rx_pkt_err(status, stats) < 0)\r\nsis190_give_to_asic(desc, tp->rx_buf_sz);\r\nelse {\r\nstruct sk_buff *skb = tp->Rx_skbuff[entry];\r\ndma_addr_t addr = le32_to_cpu(desc->addr);\r\nint pkt_size = (status & RxSizeMask) - 4;\r\nstruct pci_dev *pdev = tp->pci_dev;\r\nif (unlikely(pkt_size > tp->rx_buf_sz)) {\r\nnetif_info(tp, intr, dev,\r\n"(frag) status = %08x\n", status);\r\nstats->rx_dropped++;\r\nstats->rx_length_errors++;\r\nsis190_give_to_asic(desc, tp->rx_buf_sz);\r\ncontinue;\r\n}\r\nif (sis190_try_rx_copy(tp, &skb, pkt_size, addr)) {\r\npci_dma_sync_single_for_device(pdev, addr,\r\ntp->rx_buf_sz, PCI_DMA_FROMDEVICE);\r\nsis190_give_to_asic(desc, tp->rx_buf_sz);\r\n} else {\r\npci_unmap_single(pdev, addr, tp->rx_buf_sz,\r\nPCI_DMA_FROMDEVICE);\r\ntp->Rx_skbuff[entry] = NULL;\r\nsis190_make_unusable_by_asic(desc);\r\n}\r\nskb_put(skb, pkt_size);\r\nskb->protocol = eth_type_trans(skb, dev);\r\nsis190_rx_skb(skb);\r\nstats->rx_packets++;\r\nstats->rx_bytes += pkt_size;\r\nif ((status & BCAST) == MCAST)\r\nstats->multicast++;\r\n}\r\n}\r\ncount = cur_rx - tp->cur_rx;\r\ntp->cur_rx = cur_rx;\r\ndelta = sis190_rx_fill(tp, dev, tp->dirty_rx, tp->cur_rx);\r\nif (!delta && count)\r\nnetif_info(tp, intr, dev, "no Rx buffer allocated\n");\r\ntp->dirty_rx += delta;\r\nif ((tp->dirty_rx + NUM_RX_DESC) == tp->cur_rx)\r\nnetif_emerg(tp, intr, dev, "Rx buffers exhausted\n");\r\nreturn count;\r\n}\r\nstatic void sis190_unmap_tx_skb(struct pci_dev *pdev, struct sk_buff *skb,\r\nstruct TxDesc *desc)\r\n{\r\nunsigned int len;\r\nlen = skb->len < ETH_ZLEN ? ETH_ZLEN : skb->len;\r\npci_unmap_single(pdev, le32_to_cpu(desc->addr), len, PCI_DMA_TODEVICE);\r\nmemset(desc, 0x00, sizeof(*desc));\r\n}\r\nstatic inline int sis190_tx_pkt_err(u32 status, struct net_device_stats *stats)\r\n{\r\n#define TxErrMask (WND | TABRT | FIFO | LINK)\r\nif (!unlikely(status & TxErrMask))\r\nreturn 0;\r\nif (status & WND)\r\nstats->tx_window_errors++;\r\nif (status & TABRT)\r\nstats->tx_aborted_errors++;\r\nif (status & FIFO)\r\nstats->tx_fifo_errors++;\r\nif (status & LINK)\r\nstats->tx_carrier_errors++;\r\nstats->tx_errors++;\r\nreturn -1;\r\n}\r\nstatic void sis190_tx_interrupt(struct net_device *dev,\r\nstruct sis190_private *tp, void __iomem *ioaddr)\r\n{\r\nstruct net_device_stats *stats = &dev->stats;\r\nu32 pending, dirty_tx = tp->dirty_tx;\r\nunsigned int queue_stopped;\r\nsmp_rmb();\r\npending = tp->cur_tx - dirty_tx;\r\nqueue_stopped = (pending == NUM_TX_DESC);\r\nfor (; pending; pending--, dirty_tx++) {\r\nunsigned int entry = dirty_tx % NUM_TX_DESC;\r\nstruct TxDesc *txd = tp->TxDescRing + entry;\r\nu32 status = le32_to_cpu(txd->status);\r\nstruct sk_buff *skb;\r\nif (status & OWNbit)\r\nbreak;\r\nskb = tp->Tx_skbuff[entry];\r\nif (likely(sis190_tx_pkt_err(status, stats) == 0)) {\r\nstats->tx_packets++;\r\nstats->tx_bytes += skb->len;\r\nstats->collisions += ((status & ColCountMask) - 1);\r\n}\r\nsis190_unmap_tx_skb(tp->pci_dev, skb, txd);\r\ntp->Tx_skbuff[entry] = NULL;\r\ndev_kfree_skb_irq(skb);\r\n}\r\nif (tp->dirty_tx != dirty_tx) {\r\ntp->dirty_tx = dirty_tx;\r\nsmp_wmb();\r\nif (queue_stopped)\r\nnetif_wake_queue(dev);\r\n}\r\n}\r\nstatic irqreturn_t sis190_irq(int irq, void *__dev)\r\n{\r\nstruct net_device *dev = __dev;\r\nstruct sis190_private *tp = netdev_priv(dev);\r\nvoid __iomem *ioaddr = tp->mmio_addr;\r\nunsigned int handled = 0;\r\nu32 status;\r\nstatus = SIS_R32(IntrStatus);\r\nif ((status == 0xffffffff) || !status)\r\ngoto out;\r\nhandled = 1;\r\nif (unlikely(!netif_running(dev))) {\r\nsis190_asic_down(ioaddr);\r\ngoto out;\r\n}\r\nSIS_W32(IntrStatus, status);\r\nif (status & LinkChange) {\r\nnetif_info(tp, intr, dev, "link change\n");\r\ndel_timer(&tp->timer);\r\nschedule_work(&tp->phy_task);\r\n}\r\nif (status & RxQInt)\r\nsis190_rx_interrupt(dev, tp, ioaddr);\r\nif (status & TxQ0Int)\r\nsis190_tx_interrupt(dev, tp, ioaddr);\r\nout:\r\nreturn IRQ_RETVAL(handled);\r\n}\r\nstatic void sis190_netpoll(struct net_device *dev)\r\n{\r\nstruct sis190_private *tp = netdev_priv(dev);\r\nconst int irq = tp->pci_dev->irq;\r\ndisable_irq(irq);\r\nsis190_irq(irq, dev);\r\nenable_irq(irq);\r\n}\r\nstatic void sis190_free_rx_skb(struct sis190_private *tp,\r\nstruct sk_buff **sk_buff, struct RxDesc *desc)\r\n{\r\nstruct pci_dev *pdev = tp->pci_dev;\r\npci_unmap_single(pdev, le32_to_cpu(desc->addr), tp->rx_buf_sz,\r\nPCI_DMA_FROMDEVICE);\r\ndev_kfree_skb(*sk_buff);\r\n*sk_buff = NULL;\r\nsis190_make_unusable_by_asic(desc);\r\n}\r\nstatic void sis190_rx_clear(struct sis190_private *tp)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < NUM_RX_DESC; i++) {\r\nif (!tp->Rx_skbuff[i])\r\ncontinue;\r\nsis190_free_rx_skb(tp, tp->Rx_skbuff + i, tp->RxDescRing + i);\r\n}\r\n}\r\nstatic void sis190_init_ring_indexes(struct sis190_private *tp)\r\n{\r\ntp->dirty_tx = tp->dirty_rx = tp->cur_tx = tp->cur_rx = 0;\r\n}\r\nstatic int sis190_init_ring(struct net_device *dev)\r\n{\r\nstruct sis190_private *tp = netdev_priv(dev);\r\nsis190_init_ring_indexes(tp);\r\nmemset(tp->Tx_skbuff, 0x0, NUM_TX_DESC * sizeof(struct sk_buff *));\r\nmemset(tp->Rx_skbuff, 0x0, NUM_RX_DESC * sizeof(struct sk_buff *));\r\nif (sis190_rx_fill(tp, dev, 0, NUM_RX_DESC) != NUM_RX_DESC)\r\ngoto err_rx_clear;\r\nsis190_mark_as_last_descriptor(tp->RxDescRing + NUM_RX_DESC - 1);\r\nreturn 0;\r\nerr_rx_clear:\r\nsis190_rx_clear(tp);\r\nreturn -ENOMEM;\r\n}\r\nstatic void sis190_set_rx_mode(struct net_device *dev)\r\n{\r\nstruct sis190_private *tp = netdev_priv(dev);\r\nvoid __iomem *ioaddr = tp->mmio_addr;\r\nunsigned long flags;\r\nu32 mc_filter[2];\r\nu16 rx_mode;\r\nif (dev->flags & IFF_PROMISC) {\r\nrx_mode =\r\nAcceptBroadcast | AcceptMulticast | AcceptMyPhys |\r\nAcceptAllPhys;\r\nmc_filter[1] = mc_filter[0] = 0xffffffff;\r\n} else if ((netdev_mc_count(dev) > multicast_filter_limit) ||\r\n(dev->flags & IFF_ALLMULTI)) {\r\nrx_mode = AcceptBroadcast | AcceptMulticast | AcceptMyPhys;\r\nmc_filter[1] = mc_filter[0] = 0xffffffff;\r\n} else {\r\nstruct netdev_hw_addr *ha;\r\nrx_mode = AcceptBroadcast | AcceptMyPhys;\r\nmc_filter[1] = mc_filter[0] = 0;\r\nnetdev_for_each_mc_addr(ha, dev) {\r\nint bit_nr =\r\nether_crc(ETH_ALEN, ha->addr) & 0x3f;\r\nmc_filter[bit_nr >> 5] |= 1 << (bit_nr & 31);\r\nrx_mode |= AcceptMulticast;\r\n}\r\n}\r\nspin_lock_irqsave(&tp->lock, flags);\r\nSIS_W16(RxMacControl, rx_mode | 0x2);\r\nSIS_W32(RxHashTable, mc_filter[0]);\r\nSIS_W32(RxHashTable + 4, mc_filter[1]);\r\nspin_unlock_irqrestore(&tp->lock, flags);\r\n}\r\nstatic void sis190_soft_reset(void __iomem *ioaddr)\r\n{\r\nSIS_W32(IntrControl, 0x8000);\r\nSIS_PCI_COMMIT();\r\nSIS_W32(IntrControl, 0x0);\r\nsis190_asic_down(ioaddr);\r\n}\r\nstatic void sis190_hw_start(struct net_device *dev)\r\n{\r\nstruct sis190_private *tp = netdev_priv(dev);\r\nvoid __iomem *ioaddr = tp->mmio_addr;\r\nsis190_soft_reset(ioaddr);\r\nSIS_W32(TxDescStartAddr, tp->tx_dma);\r\nSIS_W32(RxDescStartAddr, tp->rx_dma);\r\nSIS_W32(IntrStatus, 0xffffffff);\r\nSIS_W32(IntrMask, 0x0);\r\nSIS_W32(GMIIControl, 0x0);\r\nSIS_W32(TxMacControl, 0x60);\r\nSIS_W16(RxMacControl, 0x02);\r\nSIS_W32(RxHashTable, 0x0);\r\nSIS_W32(0x6c, 0x0);\r\nSIS_W32(RxWolCtrl, 0x0);\r\nSIS_W32(RxWolData, 0x0);\r\nSIS_PCI_COMMIT();\r\nsis190_set_rx_mode(dev);\r\nSIS_W32(IntrMask, sis190_intr_mask);\r\nSIS_W32(TxControl, 0x1a00 | CmdTxEnb);\r\nSIS_W32(RxControl, 0x1a1d);\r\nnetif_start_queue(dev);\r\n}\r\nstatic void sis190_phy_task(struct work_struct *work)\r\n{\r\nstruct sis190_private *tp =\r\ncontainer_of(work, struct sis190_private, phy_task);\r\nstruct net_device *dev = tp->dev;\r\nvoid __iomem *ioaddr = tp->mmio_addr;\r\nint phy_id = tp->mii_if.phy_id;\r\nu16 val;\r\nrtnl_lock();\r\nif (!netif_running(dev))\r\ngoto out_unlock;\r\nval = mdio_read(ioaddr, phy_id, MII_BMCR);\r\nif (val & BMCR_RESET) {\r\nmod_timer(&tp->timer, jiffies + HZ/10);\r\ngoto out_unlock;\r\n}\r\nval = mdio_read_latched(ioaddr, phy_id, MII_BMSR);\r\nif (!(val & BMSR_ANEGCOMPLETE) && tp->link_status != LNK_AUTONEG) {\r\nnetif_carrier_off(dev);\r\nnetif_warn(tp, link, dev, "auto-negotiating...\n");\r\ntp->link_status = LNK_AUTONEG;\r\n} else if ((val & BMSR_LSTATUS) && tp->link_status != LNK_ON) {\r\nstruct {\r\nint val;\r\nu32 ctl;\r\nconst char *msg;\r\n} reg31[] = {\r\n{ LPA_1000FULL, 0x07000c00 | 0x00001000,\r\n"1000 Mbps Full Duplex" },\r\n{ LPA_1000HALF, 0x07000c00,\r\n"1000 Mbps Half Duplex" },\r\n{ LPA_100FULL, 0x04000800 | 0x00001000,\r\n"100 Mbps Full Duplex" },\r\n{ LPA_100HALF, 0x04000800,\r\n"100 Mbps Half Duplex" },\r\n{ LPA_10FULL, 0x04000400 | 0x00001000,\r\n"10 Mbps Full Duplex" },\r\n{ LPA_10HALF, 0x04000400,\r\n"10 Mbps Half Duplex" },\r\n{ 0, 0x04000400, "unknown" }\r\n}, *p = NULL;\r\nu16 adv, autoexp, gigadv, gigrec;\r\nval = mdio_read(ioaddr, phy_id, 0x1f);\r\nnetif_info(tp, link, dev, "mii ext = %04x\n", val);\r\nval = mdio_read(ioaddr, phy_id, MII_LPA);\r\nadv = mdio_read(ioaddr, phy_id, MII_ADVERTISE);\r\nautoexp = mdio_read(ioaddr, phy_id, MII_EXPANSION);\r\nnetif_info(tp, link, dev, "mii lpa=%04x adv=%04x exp=%04x\n",\r\nval, adv, autoexp);\r\nif (val & LPA_NPAGE && autoexp & EXPANSION_NWAY) {\r\ngigadv = mdio_read(ioaddr, phy_id, MII_CTRL1000);\r\ngigrec = mdio_read(ioaddr, phy_id, MII_STAT1000);\r\nval = (gigadv & (gigrec >> 2));\r\nif (val & ADVERTISE_1000FULL)\r\np = reg31;\r\nelse if (val & ADVERTISE_1000HALF)\r\np = reg31 + 1;\r\n}\r\nif (!p) {\r\nval &= adv;\r\nfor (p = reg31; p->val; p++) {\r\nif ((val & p->val) == p->val)\r\nbreak;\r\n}\r\n}\r\np->ctl |= SIS_R32(StationControl) & ~0x0f001c00;\r\nif ((tp->features & F_HAS_RGMII) &&\r\n(tp->features & F_PHY_BCM5461)) {\r\nmdio_write(ioaddr, phy_id, 0x18, 0xf1c7);\r\nudelay(200);\r\nmdio_write(ioaddr, phy_id, 0x1c, 0x8c00);\r\np->ctl |= 0x03000000;\r\n}\r\nSIS_W32(StationControl, p->ctl);\r\nif (tp->features & F_HAS_RGMII) {\r\nSIS_W32(RGDelay, 0x0441);\r\nSIS_W32(RGDelay, 0x0440);\r\n}\r\ntp->negotiated_lpa = p->val;\r\nnetif_info(tp, link, dev, "link on %s mode\n", p->msg);\r\nnetif_carrier_on(dev);\r\ntp->link_status = LNK_ON;\r\n} else if (!(val & BMSR_LSTATUS) && tp->link_status != LNK_AUTONEG)\r\ntp->link_status = LNK_OFF;\r\nmod_timer(&tp->timer, jiffies + SIS190_PHY_TIMEOUT);\r\nout_unlock:\r\nrtnl_unlock();\r\n}\r\nstatic void sis190_phy_timer(unsigned long __opaque)\r\n{\r\nstruct net_device *dev = (struct net_device *)__opaque;\r\nstruct sis190_private *tp = netdev_priv(dev);\r\nif (likely(netif_running(dev)))\r\nschedule_work(&tp->phy_task);\r\n}\r\nstatic inline void sis190_delete_timer(struct net_device *dev)\r\n{\r\nstruct sis190_private *tp = netdev_priv(dev);\r\ndel_timer_sync(&tp->timer);\r\n}\r\nstatic inline void sis190_request_timer(struct net_device *dev)\r\n{\r\nstruct sis190_private *tp = netdev_priv(dev);\r\nstruct timer_list *timer = &tp->timer;\r\ninit_timer(timer);\r\ntimer->expires = jiffies + SIS190_PHY_TIMEOUT;\r\ntimer->data = (unsigned long)dev;\r\ntimer->function = sis190_phy_timer;\r\nadd_timer(timer);\r\n}\r\nstatic void sis190_set_rxbufsize(struct sis190_private *tp,\r\nstruct net_device *dev)\r\n{\r\nunsigned int mtu = dev->mtu;\r\ntp->rx_buf_sz = (mtu > RX_BUF_SIZE) ? mtu + ETH_HLEN + 8 : RX_BUF_SIZE;\r\nif (tp->rx_buf_sz & 0x07) {\r\ntp->rx_buf_sz += 8;\r\ntp->rx_buf_sz &= RX_BUF_MASK;\r\n}\r\n}\r\nstatic int sis190_open(struct net_device *dev)\r\n{\r\nstruct sis190_private *tp = netdev_priv(dev);\r\nstruct pci_dev *pdev = tp->pci_dev;\r\nint rc = -ENOMEM;\r\nsis190_set_rxbufsize(tp, dev);\r\ntp->TxDescRing = pci_alloc_consistent(pdev, TX_RING_BYTES, &tp->tx_dma);\r\nif (!tp->TxDescRing)\r\ngoto out;\r\ntp->RxDescRing = pci_alloc_consistent(pdev, RX_RING_BYTES, &tp->rx_dma);\r\nif (!tp->RxDescRing)\r\ngoto err_free_tx_0;\r\nrc = sis190_init_ring(dev);\r\nif (rc < 0)\r\ngoto err_free_rx_1;\r\nsis190_request_timer(dev);\r\nrc = request_irq(pdev->irq, sis190_irq, IRQF_SHARED, dev->name, dev);\r\nif (rc < 0)\r\ngoto err_release_timer_2;\r\nsis190_hw_start(dev);\r\nout:\r\nreturn rc;\r\nerr_release_timer_2:\r\nsis190_delete_timer(dev);\r\nsis190_rx_clear(tp);\r\nerr_free_rx_1:\r\npci_free_consistent(pdev, RX_RING_BYTES, tp->RxDescRing, tp->rx_dma);\r\nerr_free_tx_0:\r\npci_free_consistent(pdev, TX_RING_BYTES, tp->TxDescRing, tp->tx_dma);\r\ngoto out;\r\n}\r\nstatic void sis190_tx_clear(struct sis190_private *tp)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < NUM_TX_DESC; i++) {\r\nstruct sk_buff *skb = tp->Tx_skbuff[i];\r\nif (!skb)\r\ncontinue;\r\nsis190_unmap_tx_skb(tp->pci_dev, skb, tp->TxDescRing + i);\r\ntp->Tx_skbuff[i] = NULL;\r\ndev_kfree_skb(skb);\r\ntp->dev->stats.tx_dropped++;\r\n}\r\ntp->cur_tx = tp->dirty_tx = 0;\r\n}\r\nstatic void sis190_down(struct net_device *dev)\r\n{\r\nstruct sis190_private *tp = netdev_priv(dev);\r\nvoid __iomem *ioaddr = tp->mmio_addr;\r\nunsigned int poll_locked = 0;\r\nsis190_delete_timer(dev);\r\nnetif_stop_queue(dev);\r\ndo {\r\nspin_lock_irq(&tp->lock);\r\nsis190_asic_down(ioaddr);\r\nspin_unlock_irq(&tp->lock);\r\nsynchronize_irq(tp->pci_dev->irq);\r\nif (!poll_locked)\r\npoll_locked++;\r\nsynchronize_sched();\r\n} while (SIS_R32(IntrMask));\r\nsis190_tx_clear(tp);\r\nsis190_rx_clear(tp);\r\n}\r\nstatic int sis190_close(struct net_device *dev)\r\n{\r\nstruct sis190_private *tp = netdev_priv(dev);\r\nstruct pci_dev *pdev = tp->pci_dev;\r\nsis190_down(dev);\r\nfree_irq(pdev->irq, dev);\r\npci_free_consistent(pdev, TX_RING_BYTES, tp->TxDescRing, tp->tx_dma);\r\npci_free_consistent(pdev, RX_RING_BYTES, tp->RxDescRing, tp->rx_dma);\r\ntp->TxDescRing = NULL;\r\ntp->RxDescRing = NULL;\r\nreturn 0;\r\n}\r\nstatic netdev_tx_t sis190_start_xmit(struct sk_buff *skb,\r\nstruct net_device *dev)\r\n{\r\nstruct sis190_private *tp = netdev_priv(dev);\r\nvoid __iomem *ioaddr = tp->mmio_addr;\r\nu32 len, entry, dirty_tx;\r\nstruct TxDesc *desc;\r\ndma_addr_t mapping;\r\nif (unlikely(skb->len < ETH_ZLEN)) {\r\nif (skb_padto(skb, ETH_ZLEN)) {\r\ndev->stats.tx_dropped++;\r\ngoto out;\r\n}\r\nlen = ETH_ZLEN;\r\n} else {\r\nlen = skb->len;\r\n}\r\nentry = tp->cur_tx % NUM_TX_DESC;\r\ndesc = tp->TxDescRing + entry;\r\nif (unlikely(le32_to_cpu(desc->status) & OWNbit)) {\r\nnetif_stop_queue(dev);\r\nnetif_err(tp, tx_err, dev,\r\n"BUG! Tx Ring full when queue awake!\n");\r\nreturn NETDEV_TX_BUSY;\r\n}\r\nmapping = pci_map_single(tp->pci_dev, skb->data, len, PCI_DMA_TODEVICE);\r\nif (pci_dma_mapping_error(tp->pci_dev, mapping)) {\r\nnetif_err(tp, tx_err, dev,\r\n"PCI mapping failed, dropping packet");\r\nreturn NETDEV_TX_BUSY;\r\n}\r\ntp->Tx_skbuff[entry] = skb;\r\ndesc->PSize = cpu_to_le32(len);\r\ndesc->addr = cpu_to_le32(mapping);\r\ndesc->size = cpu_to_le32(len);\r\nif (entry == (NUM_TX_DESC - 1))\r\ndesc->size |= cpu_to_le32(RingEnd);\r\nwmb();\r\ndesc->status = cpu_to_le32(OWNbit | INTbit | DEFbit | CRCbit | PADbit);\r\nif (tp->negotiated_lpa & (LPA_1000HALF | LPA_100HALF | LPA_10HALF)) {\r\ndesc->status |= cpu_to_le32(COLEN | CRSEN | BKFEN);\r\nif (tp->negotiated_lpa & (LPA_1000HALF | LPA_1000FULL))\r\ndesc->status |= cpu_to_le32(EXTEN | BSTEN);\r\n}\r\ntp->cur_tx++;\r\nsmp_wmb();\r\nSIS_W32(TxControl, 0x1a00 | CmdReset | CmdTxEnb);\r\ndirty_tx = tp->dirty_tx;\r\nif ((tp->cur_tx - NUM_TX_DESC) == dirty_tx) {\r\nnetif_stop_queue(dev);\r\nsmp_rmb();\r\nif (dirty_tx != tp->dirty_tx)\r\nnetif_wake_queue(dev);\r\n}\r\nout:\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic void sis190_free_phy(struct list_head *first_phy)\r\n{\r\nstruct sis190_phy *cur, *next;\r\nlist_for_each_entry_safe(cur, next, first_phy, list) {\r\nkfree(cur);\r\n}\r\n}\r\nstatic u16 sis190_default_phy(struct net_device *dev)\r\n{\r\nstruct sis190_phy *phy, *phy_home, *phy_default, *phy_lan;\r\nstruct sis190_private *tp = netdev_priv(dev);\r\nstruct mii_if_info *mii_if = &tp->mii_if;\r\nvoid __iomem *ioaddr = tp->mmio_addr;\r\nu16 status;\r\nphy_home = phy_default = phy_lan = NULL;\r\nlist_for_each_entry(phy, &tp->first_phy, list) {\r\nstatus = mdio_read_latched(ioaddr, phy->phy_id, MII_BMSR);\r\nif ((status & BMSR_LSTATUS) &&\r\n!phy_default &&\r\n(phy->type != UNKNOWN)) {\r\nphy_default = phy;\r\n} else {\r\nstatus = mdio_read(ioaddr, phy->phy_id, MII_BMCR);\r\nmdio_write(ioaddr, phy->phy_id, MII_BMCR,\r\nstatus | BMCR_ANENABLE | BMCR_ISOLATE);\r\nif (phy->type == HOME)\r\nphy_home = phy;\r\nelse if (phy->type == LAN)\r\nphy_lan = phy;\r\n}\r\n}\r\nif (!phy_default) {\r\nif (phy_home)\r\nphy_default = phy_home;\r\nelse if (phy_lan)\r\nphy_default = phy_lan;\r\nelse\r\nphy_default = list_first_entry(&tp->first_phy,\r\nstruct sis190_phy, list);\r\n}\r\nif (mii_if->phy_id != phy_default->phy_id) {\r\nmii_if->phy_id = phy_default->phy_id;\r\nif (netif_msg_probe(tp))\r\npr_info("%s: Using transceiver at address %d as default\n",\r\npci_name(tp->pci_dev), mii_if->phy_id);\r\n}\r\nstatus = mdio_read(ioaddr, mii_if->phy_id, MII_BMCR);\r\nstatus &= (~BMCR_ISOLATE);\r\nmdio_write(ioaddr, mii_if->phy_id, MII_BMCR, status);\r\nstatus = mdio_read_latched(ioaddr, mii_if->phy_id, MII_BMSR);\r\nreturn status;\r\n}\r\nstatic void sis190_init_phy(struct net_device *dev, struct sis190_private *tp,\r\nstruct sis190_phy *phy, unsigned int phy_id,\r\nu16 mii_status)\r\n{\r\nvoid __iomem *ioaddr = tp->mmio_addr;\r\nstruct mii_chip_info *p;\r\nINIT_LIST_HEAD(&phy->list);\r\nphy->status = mii_status;\r\nphy->phy_id = phy_id;\r\nphy->id[0] = mdio_read(ioaddr, phy_id, MII_PHYSID1);\r\nphy->id[1] = mdio_read(ioaddr, phy_id, MII_PHYSID2);\r\nfor (p = mii_chip_table; p->type; p++) {\r\nif ((p->id[0] == phy->id[0]) &&\r\n(p->id[1] == (phy->id[1] & 0xfff0))) {\r\nbreak;\r\n}\r\n}\r\nif (p->id[1]) {\r\nphy->type = (p->type == MIX) ?\r\n((mii_status & (BMSR_100FULL | BMSR_100HALF)) ?\r\nLAN : HOME) : p->type;\r\ntp->features |= p->feature;\r\nif (netif_msg_probe(tp))\r\npr_info("%s: %s transceiver at address %d\n",\r\npci_name(tp->pci_dev), p->name, phy_id);\r\n} else {\r\nphy->type = UNKNOWN;\r\nif (netif_msg_probe(tp))\r\npr_info("%s: unknown PHY 0x%x:0x%x transceiver at address %d\n",\r\npci_name(tp->pci_dev),\r\nphy->id[0], (phy->id[1] & 0xfff0), phy_id);\r\n}\r\n}\r\nstatic void sis190_mii_probe_88e1111_fixup(struct sis190_private *tp)\r\n{\r\nif (tp->features & F_PHY_88E1111) {\r\nvoid __iomem *ioaddr = tp->mmio_addr;\r\nint phy_id = tp->mii_if.phy_id;\r\nu16 reg[2][2] = {\r\n{ 0x808b, 0x0ce1 },\r\n{ 0x808f, 0x0c60 }\r\n}, *p;\r\np = (tp->features & F_HAS_RGMII) ? reg[0] : reg[1];\r\nmdio_write(ioaddr, phy_id, 0x1b, p[0]);\r\nudelay(200);\r\nmdio_write(ioaddr, phy_id, 0x14, p[1]);\r\nudelay(200);\r\n}\r\n}\r\nstatic int sis190_mii_probe(struct net_device *dev)\r\n{\r\nstruct sis190_private *tp = netdev_priv(dev);\r\nstruct mii_if_info *mii_if = &tp->mii_if;\r\nvoid __iomem *ioaddr = tp->mmio_addr;\r\nint phy_id;\r\nint rc = 0;\r\nINIT_LIST_HEAD(&tp->first_phy);\r\nfor (phy_id = 0; phy_id < PHY_MAX_ADDR; phy_id++) {\r\nstruct sis190_phy *phy;\r\nu16 status;\r\nstatus = mdio_read_latched(ioaddr, phy_id, MII_BMSR);\r\nif (status == 0xffff || status == 0x0000)\r\ncontinue;\r\nphy = kmalloc(sizeof(*phy), GFP_KERNEL);\r\nif (!phy) {\r\nsis190_free_phy(&tp->first_phy);\r\nrc = -ENOMEM;\r\ngoto out;\r\n}\r\nsis190_init_phy(dev, tp, phy, phy_id, status);\r\nlist_add(&tp->first_phy, &phy->list);\r\n}\r\nif (list_empty(&tp->first_phy)) {\r\nif (netif_msg_probe(tp))\r\npr_info("%s: No MII transceivers found!\n",\r\npci_name(tp->pci_dev));\r\nrc = -EIO;\r\ngoto out;\r\n}\r\nsis190_default_phy(dev);\r\nsis190_mii_probe_88e1111_fixup(tp);\r\nmii_if->dev = dev;\r\nmii_if->mdio_read = __mdio_read;\r\nmii_if->mdio_write = __mdio_write;\r\nmii_if->phy_id_mask = PHY_ID_ANY;\r\nmii_if->reg_num_mask = MII_REG_ANY;\r\nout:\r\nreturn rc;\r\n}\r\nstatic void sis190_mii_remove(struct net_device *dev)\r\n{\r\nstruct sis190_private *tp = netdev_priv(dev);\r\nsis190_free_phy(&tp->first_phy);\r\n}\r\nstatic void sis190_release_board(struct pci_dev *pdev)\r\n{\r\nstruct net_device *dev = pci_get_drvdata(pdev);\r\nstruct sis190_private *tp = netdev_priv(dev);\r\niounmap(tp->mmio_addr);\r\npci_release_regions(pdev);\r\npci_disable_device(pdev);\r\nfree_netdev(dev);\r\n}\r\nstatic struct net_device *sis190_init_board(struct pci_dev *pdev)\r\n{\r\nstruct sis190_private *tp;\r\nstruct net_device *dev;\r\nvoid __iomem *ioaddr;\r\nint rc;\r\ndev = alloc_etherdev(sizeof(*tp));\r\nif (!dev) {\r\nrc = -ENOMEM;\r\ngoto err_out_0;\r\n}\r\nSET_NETDEV_DEV(dev, &pdev->dev);\r\ntp = netdev_priv(dev);\r\ntp->dev = dev;\r\ntp->msg_enable = netif_msg_init(debug.msg_enable, SIS190_MSG_DEFAULT);\r\nrc = pci_enable_device(pdev);\r\nif (rc < 0) {\r\nif (netif_msg_probe(tp))\r\npr_err("%s: enable failure\n", pci_name(pdev));\r\ngoto err_free_dev_1;\r\n}\r\nrc = -ENODEV;\r\nif (!(pci_resource_flags(pdev, 0) & IORESOURCE_MEM)) {\r\nif (netif_msg_probe(tp))\r\npr_err("%s: region #0 is no MMIO resource\n",\r\npci_name(pdev));\r\ngoto err_pci_disable_2;\r\n}\r\nif (pci_resource_len(pdev, 0) < SIS190_REGS_SIZE) {\r\nif (netif_msg_probe(tp))\r\npr_err("%s: invalid PCI region size(s)\n",\r\npci_name(pdev));\r\ngoto err_pci_disable_2;\r\n}\r\nrc = pci_request_regions(pdev, DRV_NAME);\r\nif (rc < 0) {\r\nif (netif_msg_probe(tp))\r\npr_err("%s: could not request regions\n",\r\npci_name(pdev));\r\ngoto err_pci_disable_2;\r\n}\r\nrc = pci_set_dma_mask(pdev, DMA_BIT_MASK(32));\r\nif (rc < 0) {\r\nif (netif_msg_probe(tp))\r\npr_err("%s: DMA configuration failed\n",\r\npci_name(pdev));\r\ngoto err_free_res_3;\r\n}\r\npci_set_master(pdev);\r\nioaddr = ioremap(pci_resource_start(pdev, 0), SIS190_REGS_SIZE);\r\nif (!ioaddr) {\r\nif (netif_msg_probe(tp))\r\npr_err("%s: cannot remap MMIO, aborting\n",\r\npci_name(pdev));\r\nrc = -EIO;\r\ngoto err_free_res_3;\r\n}\r\ntp->pci_dev = pdev;\r\ntp->mmio_addr = ioaddr;\r\ntp->link_status = LNK_OFF;\r\nsis190_irq_mask_and_ack(ioaddr);\r\nsis190_soft_reset(ioaddr);\r\nout:\r\nreturn dev;\r\nerr_free_res_3:\r\npci_release_regions(pdev);\r\nerr_pci_disable_2:\r\npci_disable_device(pdev);\r\nerr_free_dev_1:\r\nfree_netdev(dev);\r\nerr_out_0:\r\ndev = ERR_PTR(rc);\r\ngoto out;\r\n}\r\nstatic void sis190_tx_timeout(struct net_device *dev)\r\n{\r\nstruct sis190_private *tp = netdev_priv(dev);\r\nvoid __iomem *ioaddr = tp->mmio_addr;\r\nu8 tmp8;\r\ntmp8 = SIS_R8(TxControl);\r\nif (tmp8 & CmdTxEnb)\r\nSIS_W8(TxControl, tmp8 & ~CmdTxEnb);\r\nnetif_info(tp, tx_err, dev, "Transmit timeout, status %08x %08x\n",\r\nSIS_R32(TxControl), SIS_R32(TxSts));\r\nSIS_W32(IntrMask, 0x0000);\r\nspin_lock_irq(&tp->lock);\r\nsis190_tx_clear(tp);\r\nspin_unlock_irq(&tp->lock);\r\nsis190_hw_start(dev);\r\nnetif_wake_queue(dev);\r\n}\r\nstatic void sis190_set_rgmii(struct sis190_private *tp, u8 reg)\r\n{\r\ntp->features |= (reg & 0x80) ? F_HAS_RGMII : 0;\r\n}\r\nstatic int sis190_get_mac_addr_from_eeprom(struct pci_dev *pdev,\r\nstruct net_device *dev)\r\n{\r\nstruct sis190_private *tp = netdev_priv(dev);\r\nvoid __iomem *ioaddr = tp->mmio_addr;\r\nu16 sig;\r\nint i;\r\nif (netif_msg_probe(tp))\r\npr_info("%s: Read MAC address from EEPROM\n", pci_name(pdev));\r\nsig = (u16) sis190_read_eeprom(ioaddr, EEPROMSignature);\r\nif ((sig == 0xffff) || (sig == 0x0000)) {\r\nif (netif_msg_probe(tp))\r\npr_info("%s: Error EEPROM read %x\n",\r\npci_name(pdev), sig);\r\nreturn -EIO;\r\n}\r\nfor (i = 0; i < ETH_ALEN / 2; i++) {\r\nu16 w = sis190_read_eeprom(ioaddr, EEPROMMACAddr + i);\r\n((__le16 *)dev->dev_addr)[i] = cpu_to_le16(w);\r\n}\r\nsis190_set_rgmii(tp, sis190_read_eeprom(ioaddr, EEPROMInfo));\r\nreturn 0;\r\n}\r\nstatic int sis190_get_mac_addr_from_apc(struct pci_dev *pdev,\r\nstruct net_device *dev)\r\n{\r\nstatic const u16 ids[] = { 0x0965, 0x0966, 0x0968 };\r\nstruct sis190_private *tp = netdev_priv(dev);\r\nstruct pci_dev *isa_bridge;\r\nu8 reg, tmp8;\r\nunsigned int i;\r\nif (netif_msg_probe(tp))\r\npr_info("%s: Read MAC address from APC\n", pci_name(pdev));\r\nfor (i = 0; i < ARRAY_SIZE(ids); i++) {\r\nisa_bridge = pci_get_device(PCI_VENDOR_ID_SI, ids[i], NULL);\r\nif (isa_bridge)\r\nbreak;\r\n}\r\nif (!isa_bridge) {\r\nif (netif_msg_probe(tp))\r\npr_info("%s: Can not find ISA bridge\n",\r\npci_name(pdev));\r\nreturn -EIO;\r\n}\r\npci_read_config_byte(isa_bridge, 0x48, &tmp8);\r\nreg = (tmp8 & ~0x02);\r\npci_write_config_byte(isa_bridge, 0x48, reg);\r\nudelay(50);\r\npci_read_config_byte(isa_bridge, 0x48, &reg);\r\nfor (i = 0; i < ETH_ALEN; i++) {\r\noutb(0x9 + i, 0x78);\r\ndev->dev_addr[i] = inb(0x79);\r\n}\r\noutb(0x12, 0x78);\r\nreg = inb(0x79);\r\nsis190_set_rgmii(tp, reg);\r\npci_write_config_byte(isa_bridge, 0x48, tmp8);\r\npci_dev_put(isa_bridge);\r\nreturn 0;\r\n}\r\nstatic inline void sis190_init_rxfilter(struct net_device *dev)\r\n{\r\nstruct sis190_private *tp = netdev_priv(dev);\r\nvoid __iomem *ioaddr = tp->mmio_addr;\r\nu16 ctl;\r\nint i;\r\nctl = SIS_R16(RxMacControl);\r\nSIS_W16(RxMacControl, ctl & ~0x0f00);\r\nfor (i = 0; i < ETH_ALEN; i++)\r\nSIS_W8(RxMacAddr + i, dev->dev_addr[i]);\r\nSIS_W16(RxMacControl, ctl);\r\nSIS_PCI_COMMIT();\r\n}\r\nstatic int sis190_get_mac_addr(struct pci_dev *pdev, struct net_device *dev)\r\n{\r\nint rc;\r\nrc = sis190_get_mac_addr_from_eeprom(pdev, dev);\r\nif (rc < 0) {\r\nu8 reg;\r\npci_read_config_byte(pdev, 0x73, &reg);\r\nif (reg & 0x00000001)\r\nrc = sis190_get_mac_addr_from_apc(pdev, dev);\r\n}\r\nreturn rc;\r\n}\r\nstatic void sis190_set_speed_auto(struct net_device *dev)\r\n{\r\nstruct sis190_private *tp = netdev_priv(dev);\r\nvoid __iomem *ioaddr = tp->mmio_addr;\r\nint phy_id = tp->mii_if.phy_id;\r\nint val;\r\nnetif_info(tp, link, dev, "Enabling Auto-negotiation\n");\r\nval = mdio_read(ioaddr, phy_id, MII_ADVERTISE);\r\nmdio_write(ioaddr, phy_id, MII_ADVERTISE, (val & ADVERTISE_SLCT) |\r\nADVERTISE_100FULL | ADVERTISE_10FULL |\r\nADVERTISE_100HALF | ADVERTISE_10HALF);\r\nmdio_write(ioaddr, phy_id, MII_CTRL1000, ADVERTISE_1000FULL);\r\nmdio_write(ioaddr, phy_id, MII_BMCR,\r\nBMCR_ANENABLE | BMCR_ANRESTART | BMCR_RESET);\r\n}\r\nstatic int sis190_get_settings(struct net_device *dev, struct ethtool_cmd *cmd)\r\n{\r\nstruct sis190_private *tp = netdev_priv(dev);\r\nreturn mii_ethtool_gset(&tp->mii_if, cmd);\r\n}\r\nstatic int sis190_set_settings(struct net_device *dev, struct ethtool_cmd *cmd)\r\n{\r\nstruct sis190_private *tp = netdev_priv(dev);\r\nreturn mii_ethtool_sset(&tp->mii_if, cmd);\r\n}\r\nstatic void sis190_get_drvinfo(struct net_device *dev,\r\nstruct ethtool_drvinfo *info)\r\n{\r\nstruct sis190_private *tp = netdev_priv(dev);\r\nstrlcpy(info->driver, DRV_NAME, sizeof(info->driver));\r\nstrlcpy(info->version, DRV_VERSION, sizeof(info->version));\r\nstrlcpy(info->bus_info, pci_name(tp->pci_dev),\r\nsizeof(info->bus_info));\r\n}\r\nstatic int sis190_get_regs_len(struct net_device *dev)\r\n{\r\nreturn SIS190_REGS_SIZE;\r\n}\r\nstatic void sis190_get_regs(struct net_device *dev, struct ethtool_regs *regs,\r\nvoid *p)\r\n{\r\nstruct sis190_private *tp = netdev_priv(dev);\r\nunsigned long flags;\r\nif (regs->len > SIS190_REGS_SIZE)\r\nregs->len = SIS190_REGS_SIZE;\r\nspin_lock_irqsave(&tp->lock, flags);\r\nmemcpy_fromio(p, tp->mmio_addr, regs->len);\r\nspin_unlock_irqrestore(&tp->lock, flags);\r\n}\r\nstatic int sis190_nway_reset(struct net_device *dev)\r\n{\r\nstruct sis190_private *tp = netdev_priv(dev);\r\nreturn mii_nway_restart(&tp->mii_if);\r\n}\r\nstatic u32 sis190_get_msglevel(struct net_device *dev)\r\n{\r\nstruct sis190_private *tp = netdev_priv(dev);\r\nreturn tp->msg_enable;\r\n}\r\nstatic void sis190_set_msglevel(struct net_device *dev, u32 value)\r\n{\r\nstruct sis190_private *tp = netdev_priv(dev);\r\ntp->msg_enable = value;\r\n}\r\nstatic int sis190_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)\r\n{\r\nstruct sis190_private *tp = netdev_priv(dev);\r\nreturn !netif_running(dev) ? -EINVAL :\r\ngeneric_mii_ioctl(&tp->mii_if, if_mii(ifr), cmd, NULL);\r\n}\r\nstatic int sis190_mac_addr(struct net_device *dev, void *p)\r\n{\r\nint rc;\r\nrc = eth_mac_addr(dev, p);\r\nif (!rc)\r\nsis190_init_rxfilter(dev);\r\nreturn rc;\r\n}\r\nstatic int sis190_init_one(struct pci_dev *pdev,\r\nconst struct pci_device_id *ent)\r\n{\r\nstatic int printed_version = 0;\r\nstruct sis190_private *tp;\r\nstruct net_device *dev;\r\nvoid __iomem *ioaddr;\r\nint rc;\r\nif (!printed_version) {\r\nif (netif_msg_drv(&debug))\r\npr_info(SIS190_DRIVER_NAME " loaded\n");\r\nprinted_version = 1;\r\n}\r\ndev = sis190_init_board(pdev);\r\nif (IS_ERR(dev)) {\r\nrc = PTR_ERR(dev);\r\ngoto out;\r\n}\r\npci_set_drvdata(pdev, dev);\r\ntp = netdev_priv(dev);\r\nioaddr = tp->mmio_addr;\r\nrc = sis190_get_mac_addr(pdev, dev);\r\nif (rc < 0)\r\ngoto err_release_board;\r\nsis190_init_rxfilter(dev);\r\nINIT_WORK(&tp->phy_task, sis190_phy_task);\r\ndev->netdev_ops = &sis190_netdev_ops;\r\nSET_ETHTOOL_OPS(dev, &sis190_ethtool_ops);\r\ndev->watchdog_timeo = SIS190_TX_TIMEOUT;\r\nspin_lock_init(&tp->lock);\r\nrc = sis190_mii_probe(dev);\r\nif (rc < 0)\r\ngoto err_release_board;\r\nrc = register_netdev(dev);\r\nif (rc < 0)\r\ngoto err_remove_mii;\r\nif (netif_msg_probe(tp)) {\r\nnetdev_info(dev, "%s: %s at %p (IRQ: %d), %pM\n",\r\npci_name(pdev),\r\nsis_chip_info[ent->driver_data].name,\r\nioaddr, pdev->irq, dev->dev_addr);\r\nnetdev_info(dev, "%s mode.\n",\r\n(tp->features & F_HAS_RGMII) ? "RGMII" : "GMII");\r\n}\r\nnetif_carrier_off(dev);\r\nsis190_set_speed_auto(dev);\r\nout:\r\nreturn rc;\r\nerr_remove_mii:\r\nsis190_mii_remove(dev);\r\nerr_release_board:\r\nsis190_release_board(pdev);\r\ngoto out;\r\n}\r\nstatic void sis190_remove_one(struct pci_dev *pdev)\r\n{\r\nstruct net_device *dev = pci_get_drvdata(pdev);\r\nstruct sis190_private *tp = netdev_priv(dev);\r\nsis190_mii_remove(dev);\r\ncancel_work_sync(&tp->phy_task);\r\nunregister_netdev(dev);\r\nsis190_release_board(pdev);\r\npci_set_drvdata(pdev, NULL);\r\n}\r\nstatic int __init sis190_init_module(void)\r\n{\r\nreturn pci_register_driver(&sis190_pci_driver);\r\n}\r\nstatic void __exit sis190_cleanup_module(void)\r\n{\r\npci_unregister_driver(&sis190_pci_driver);\r\n}
