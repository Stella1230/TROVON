static int mc33880_write_config(struct mc33880 *mc)\r\n{\r\nreturn spi_write(mc->spi, &mc->port_config, sizeof(mc->port_config));\r\n}\r\nstatic int __mc33880_set(struct mc33880 *mc, unsigned offset, int value)\r\n{\r\nif (value)\r\nmc->port_config |= 1 << offset;\r\nelse\r\nmc->port_config &= ~(1 << offset);\r\nreturn mc33880_write_config(mc);\r\n}\r\nstatic void mc33880_set(struct gpio_chip *chip, unsigned offset, int value)\r\n{\r\nstruct mc33880 *mc = container_of(chip, struct mc33880, chip);\r\nmutex_lock(&mc->lock);\r\n__mc33880_set(mc, offset, value);\r\nmutex_unlock(&mc->lock);\r\n}\r\nstatic int mc33880_probe(struct spi_device *spi)\r\n{\r\nstruct mc33880 *mc;\r\nstruct mc33880_platform_data *pdata;\r\nint ret;\r\npdata = spi->dev.platform_data;\r\nif (!pdata || !pdata->base) {\r\ndev_dbg(&spi->dev, "incorrect or missing platform data\n");\r\nreturn -EINVAL;\r\n}\r\nspi->bits_per_word = 8;\r\nret = spi_setup(spi);\r\nif (ret < 0)\r\nreturn ret;\r\nmc = kzalloc(sizeof(struct mc33880), GFP_KERNEL);\r\nif (!mc)\r\nreturn -ENOMEM;\r\nmutex_init(&mc->lock);\r\ndev_set_drvdata(&spi->dev, mc);\r\nmc->spi = spi;\r\nmc->chip.label = DRIVER_NAME,\r\nmc->chip.set = mc33880_set;\r\nmc->chip.base = pdata->base;\r\nmc->chip.ngpio = PIN_NUMBER;\r\nmc->chip.can_sleep = 1;\r\nmc->chip.dev = &spi->dev;\r\nmc->chip.owner = THIS_MODULE;\r\nmc->port_config = 0x00;\r\nret = mc33880_write_config(mc);\r\nmc->port_config = 0x00;\r\nif (!ret)\r\nret = mc33880_write_config(mc);\r\nif (ret) {\r\nprintk(KERN_ERR "Failed writing to " DRIVER_NAME ": %d\n", ret);\r\ngoto exit_destroy;\r\n}\r\nret = gpiochip_add(&mc->chip);\r\nif (ret)\r\ngoto exit_destroy;\r\nreturn ret;\r\nexit_destroy:\r\ndev_set_drvdata(&spi->dev, NULL);\r\nmutex_destroy(&mc->lock);\r\nkfree(mc);\r\nreturn ret;\r\n}\r\nstatic int mc33880_remove(struct spi_device *spi)\r\n{\r\nstruct mc33880 *mc;\r\nint ret;\r\nmc = dev_get_drvdata(&spi->dev);\r\nif (mc == NULL)\r\nreturn -ENODEV;\r\ndev_set_drvdata(&spi->dev, NULL);\r\nret = gpiochip_remove(&mc->chip);\r\nif (!ret) {\r\nmutex_destroy(&mc->lock);\r\nkfree(mc);\r\n} else\r\ndev_err(&spi->dev, "Failed to remove the GPIO controller: %d\n",\r\nret);\r\nreturn ret;\r\n}\r\nstatic int __init mc33880_init(void)\r\n{\r\nreturn spi_register_driver(&mc33880_driver);\r\n}\r\nstatic void __exit mc33880_exit(void)\r\n{\r\nspi_unregister_driver(&mc33880_driver);\r\n}
