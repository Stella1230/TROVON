void PHY_SetRF8256Bandwidth(struct net_device *dev,\r\nenum ht_channel_width Bandwidth)\r\n{\r\nu8 eRFPath;\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nfor (eRFPath = 0; eRFPath < priv->NumTotalRFPath; eRFPath++) {\r\nif (!rtl8192_phy_CheckIsLegalRFPath(dev, eRFPath))\r\ncontinue;\r\nswitch (Bandwidth) {\r\ncase HT_CHANNEL_WIDTH_20:\r\nif (priv->card_8192_version == VERSION_8190_BD ||\r\npriv->card_8192_version == VERSION_8190_BE) {\r\nrtl8192_phy_SetRFReg(dev,\r\n(enum rf90_radio_path)eRFPath,\r\n0x0b, bMask12Bits, 0x100);\r\nrtl8192_phy_SetRFReg(dev,\r\n(enum rf90_radio_path)eRFPath,\r\n0x2c, bMask12Bits, 0x3d7);\r\nrtl8192_phy_SetRFReg(dev,\r\n(enum rf90_radio_path)eRFPath,\r\n0x0e, bMask12Bits, 0x021);\r\n} else {\r\nRT_TRACE(COMP_ERR, "PHY_SetRF8256Bandwidth(): "\r\n"unknown hardware version\n");\r\n}\r\nbreak;\r\ncase HT_CHANNEL_WIDTH_20_40:\r\nif (priv->card_8192_version == VERSION_8190_BD ||\r\npriv->card_8192_version == VERSION_8190_BE) {\r\nrtl8192_phy_SetRFReg(dev,\r\n(enum rf90_radio_path)eRFPath,\r\n0x0b, bMask12Bits, 0x300);\r\nrtl8192_phy_SetRFReg(dev,\r\n(enum rf90_radio_path)eRFPath,\r\n0x2c, bMask12Bits, 0x3ff);\r\nrtl8192_phy_SetRFReg(dev,\r\n(enum rf90_radio_path)eRFPath,\r\n0x0e, bMask12Bits, 0x0e1);\r\n} else {\r\nRT_TRACE(COMP_ERR, "PHY_SetRF8256Bandwidth(): "\r\n"unknown hardware version\n");\r\n}\r\nbreak;\r\ndefault:\r\nRT_TRACE(COMP_ERR, "PHY_SetRF8256Bandwidth(): unknown "\r\n"Bandwidth: %#X\n", Bandwidth);\r\nbreak;\r\n}\r\n}\r\nreturn;\r\n}\r\nbool PHY_RF8256_Config(struct net_device *dev)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nbool rtStatus = true;\r\npriv->NumTotalRFPath = RTL819X_TOTAL_RF_PATH;\r\nrtStatus = phy_RF8256_Config_ParaFile(dev);\r\nreturn rtStatus;\r\n}\r\nbool phy_RF8256_Config_ParaFile(struct net_device *dev)\r\n{\r\nu32 u4RegValue = 0;\r\nu8 eRFPath;\r\nbool rtStatus = true;\r\nstruct bb_reg_definition *pPhyReg;\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nu32 RegOffSetToBeCheck = 0x3;\r\nu32 RegValueToBeCheck = 0x7f1;\r\nu32 RF3_Final_Value = 0;\r\nu8 ConstRetryTimes = 5, RetryTimes = 5;\r\nu8 ret = 0;\r\nfor (eRFPath = (enum rf90_radio_path)RF90_PATH_A;\r\neRFPath < priv->NumTotalRFPath; eRFPath++) {\r\nif (!rtl8192_phy_CheckIsLegalRFPath(dev, eRFPath))\r\ncontinue;\r\npPhyReg = &priv->PHYRegDef[eRFPath];\r\nswitch (eRFPath) {\r\ncase RF90_PATH_A:\r\ncase RF90_PATH_C:\r\nu4RegValue = rtl8192_QueryBBReg(dev, pPhyReg->rfintfs,\r\nbRFSI_RFENV);\r\nbreak;\r\ncase RF90_PATH_B:\r\ncase RF90_PATH_D:\r\nu4RegValue = rtl8192_QueryBBReg(dev, pPhyReg->rfintfs,\r\nbRFSI_RFENV<<16);\r\nbreak;\r\n}\r\nrtl8192_setBBreg(dev, pPhyReg->rfintfe, bRFSI_RFENV<<16, 0x1);\r\nrtl8192_setBBreg(dev, pPhyReg->rfintfo, bRFSI_RFENV, 0x1);\r\nrtl8192_setBBreg(dev, pPhyReg->rfHSSIPara2,\r\nb3WireAddressLength, 0x0);\r\nrtl8192_setBBreg(dev, pPhyReg->rfHSSIPara2,\r\nb3WireDataLength, 0x0);\r\nrtl8192_phy_SetRFReg(dev, (enum rf90_radio_path) eRFPath, 0x0,\r\nbMask12Bits, 0xbf);\r\nrtStatus = rtl8192_phy_checkBBAndRF(dev, HW90_BLOCK_RF,\r\n(enum rf90_radio_path)eRFPath);\r\nif (rtStatus != true) {\r\nRT_TRACE(COMP_ERR, "PHY_RF8256_Config():Check "\r\n"Radio[%d] Fail!!\n", eRFPath);\r\ngoto phy_RF8256_Config_ParaFile_Fail;\r\n}\r\nRetryTimes = ConstRetryTimes;\r\nRF3_Final_Value = 0;\r\nswitch (eRFPath) {\r\ncase RF90_PATH_A:\r\nwhile (RF3_Final_Value != RegValueToBeCheck &&\r\nRetryTimes != 0) {\r\nret = rtl8192_phy_ConfigRFWithHeaderFile(dev,\r\n(enum rf90_radio_path)eRFPath);\r\nRF3_Final_Value = rtl8192_phy_QueryRFReg(dev,\r\n(enum rf90_radio_path)eRFPath,\r\nRegOffSetToBeCheck,\r\nbMask12Bits);\r\nRT_TRACE(COMP_RF, "RF %d %d register final "\r\n"value: %x\n", eRFPath,\r\nRegOffSetToBeCheck, RF3_Final_Value);\r\nRetryTimes--;\r\n}\r\nbreak;\r\ncase RF90_PATH_B:\r\nwhile (RF3_Final_Value != RegValueToBeCheck &&\r\nRetryTimes != 0) {\r\nret = rtl8192_phy_ConfigRFWithHeaderFile(dev,\r\n(enum rf90_radio_path)eRFPath);\r\nRF3_Final_Value = rtl8192_phy_QueryRFReg(dev,\r\n(enum rf90_radio_path)eRFPath,\r\nRegOffSetToBeCheck,\r\nbMask12Bits);\r\nRT_TRACE(COMP_RF, "RF %d %d register final "\r\n"value: %x\n", eRFPath,\r\nRegOffSetToBeCheck, RF3_Final_Value);\r\nRetryTimes--;\r\n}\r\nbreak;\r\ncase RF90_PATH_C:\r\nwhile (RF3_Final_Value != RegValueToBeCheck &&\r\nRetryTimes != 0) {\r\nret = rtl8192_phy_ConfigRFWithHeaderFile(dev,\r\n(enum rf90_radio_path)eRFPath);\r\nRF3_Final_Value = rtl8192_phy_QueryRFReg(dev,\r\n(enum rf90_radio_path)eRFPath,\r\nRegOffSetToBeCheck,\r\nbMask12Bits);\r\nRT_TRACE(COMP_RF, "RF %d %d register final "\r\n"value: %x\n", eRFPath,\r\nRegOffSetToBeCheck, RF3_Final_Value);\r\nRetryTimes--;\r\n}\r\nbreak;\r\ncase RF90_PATH_D:\r\nwhile (RF3_Final_Value != RegValueToBeCheck &&\r\nRetryTimes != 0) {\r\nret = rtl8192_phy_ConfigRFWithHeaderFile(dev,\r\n(enum rf90_radio_path)eRFPath);\r\nRF3_Final_Value = rtl8192_phy_QueryRFReg(dev,\r\n(enum rf90_radio_path)eRFPath,\r\nRegOffSetToBeCheck, bMask12Bits);\r\nRT_TRACE(COMP_RF, "RF %d %d register final "\r\n"value: %x\n", eRFPath,\r\nRegOffSetToBeCheck, RF3_Final_Value);\r\nRetryTimes--;\r\n}\r\nbreak;\r\n}\r\nswitch (eRFPath) {\r\ncase RF90_PATH_A:\r\ncase RF90_PATH_C:\r\nrtl8192_setBBreg(dev, pPhyReg->rfintfs, bRFSI_RFENV,\r\nu4RegValue);\r\nbreak;\r\ncase RF90_PATH_B:\r\ncase RF90_PATH_D:\r\nrtl8192_setBBreg(dev, pPhyReg->rfintfs, bRFSI_RFENV<<16,\r\nu4RegValue);\r\nbreak;\r\n}\r\nif (ret) {\r\nRT_TRACE(COMP_ERR, "phy_RF8256_Config_ParaFile():"\r\n"Radio[%d] Fail!!", eRFPath);\r\ngoto phy_RF8256_Config_ParaFile_Fail;\r\n}\r\n}\r\nRT_TRACE(COMP_PHY, "PHY Initialization Success\n") ;\r\nreturn true;\r\nphy_RF8256_Config_ParaFile_Fail:\r\nRT_TRACE(COMP_ERR, "PHY Initialization failed\n") ;\r\nreturn false;\r\n}\r\nvoid PHY_SetRF8256CCKTxPower(struct net_device *dev, u8 powerlevel)\r\n{\r\nu32 TxAGC = 0;\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nTxAGC = powerlevel;\r\nif (priv->bDynamicTxLowPower == true) {\r\nif (priv->CustomerID == RT_CID_819x_Netcore)\r\nTxAGC = 0x22;\r\nelse\r\nTxAGC += priv->CckPwEnl;\r\n}\r\nif (TxAGC > 0x24)\r\nTxAGC = 0x24;\r\nrtl8192_setBBreg(dev, rTxAGC_CCK_Mcs32, bTxAGCRateCCK, TxAGC);\r\n}\r\nvoid PHY_SetRF8256OFDMTxPower(struct net_device *dev, u8 powerlevel)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nu32 writeVal, powerBase0, powerBase1, writeVal_tmp;\r\nu8 index = 0;\r\nu16 RegOffset[6] = {0xe00, 0xe04, 0xe10, 0xe14, 0xe18, 0xe1c};\r\nu8 byte0, byte1, byte2, byte3;\r\npowerBase0 = powerlevel + priv->LegacyHTTxPowerDiff;\r\npowerBase0 = (powerBase0 << 24) | (powerBase0 << 16) |\r\n(powerBase0 << 8) | powerBase0;\r\npowerBase1 = powerlevel;\r\npowerBase1 = (powerBase1 << 24) | (powerBase1 << 16) |\r\n(powerBase1 << 8) | powerBase1;\r\nfor (index = 0; index < 6; index++) {\r\nwriteVal = (u32)(priv->MCSTxPowerLevelOriginalOffset[index] +\r\n((index < 2) ? powerBase0 : powerBase1));\r\nbyte0 = (u8)(writeVal & 0x7f);\r\nbyte1 = (u8)((writeVal & 0x7f00)>>8);\r\nbyte2 = (u8)((writeVal & 0x7f0000)>>16);\r\nbyte3 = (u8)((writeVal & 0x7f000000)>>24);\r\nif (byte0 > 0x24)\r\nbyte0 = 0x24;\r\nif (byte1 > 0x24)\r\nbyte1 = 0x24;\r\nif (byte2 > 0x24)\r\nbyte2 = 0x24;\r\nif (byte3 > 0x24)\r\nbyte3 = 0x24;\r\nif (index == 3) {\r\nwriteVal_tmp = (byte3 << 24) | (byte2 << 16) |\r\n(byte1 << 8) | byte0;\r\npriv->Pwr_Track = writeVal_tmp;\r\n}\r\nif (priv->bDynamicTxHighPower == true)\r\nwriteVal = 0x03030303;\r\nelse\r\nwriteVal = (byte3 << 24) | (byte2 << 16) |\r\n(byte1 << 8) | byte0;\r\nrtl8192_setBBreg(dev, RegOffset[index], 0x7f7f7f7f, writeVal);\r\n}\r\nreturn;\r\n}
