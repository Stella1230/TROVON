static void reg_r(struct gspca_dev *gspca_dev,\r\n__u16 index,\r\n__u16 len)\r\n{\r\nstruct usb_device *dev = gspca_dev->dev;\r\n#ifdef GSPCA_DEBUG\r\nif (len > USB_BUF_SZ) {\r\npr_err("reg_r: buffer overflow\n");\r\nreturn;\r\n}\r\n#endif\r\nusb_control_msg(dev,\r\nusb_rcvctrlpipe(dev, 0),\r\n0,\r\nUSB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_INTERFACE,\r\n0,\r\nindex, gspca_dev->usb_buf, len, 500);\r\nPDEBUG(D_USBI, "reg read [%02x] -> %02x ..",\r\nindex, gspca_dev->usb_buf[0]);\r\n}\r\nstatic void reg_w_val(struct gspca_dev *gspca_dev,\r\n__u16 index,\r\n__u8 val)\r\n{\r\nstruct usb_device *dev = gspca_dev->dev;\r\ngspca_dev->usb_buf[0] = val;\r\nusb_control_msg(dev,\r\nusb_sndctrlpipe(dev, 0),\r\n0,\r\nUSB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_INTERFACE,\r\n0,\r\nindex, gspca_dev->usb_buf, 1, 500);\r\n}\r\nstatic void reg_w(struct gspca_dev *gspca_dev,\r\n__u16 index,\r\nconst __u8 *buffer,\r\n__u16 len)\r\n{\r\nstruct usb_device *dev = gspca_dev->dev;\r\n#ifdef GSPCA_DEBUG\r\nif (len > USB_BUF_SZ) {\r\npr_err("reg_w: buffer overflow\n");\r\nreturn;\r\n}\r\nPDEBUG(D_USBO, "reg write [%02x] = %02x..", index, *buffer);\r\n#endif\r\nmemcpy(gspca_dev->usb_buf, buffer, len);\r\nusb_control_msg(dev,\r\nusb_sndctrlpipe(dev, 0),\r\n0,\r\nUSB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_INTERFACE,\r\n0, index, gspca_dev->usb_buf, len, 500);\r\n}\r\nstatic int i2c_w(struct gspca_dev *gspca_dev,\r\n__u8 reg,\r\nconst __u8 *buffer,\r\nint len, __u8 mode)\r\n{\r\n__u8 ptchcount;\r\nreg_w_val(gspca_dev, ET_I2C_BASE, 0x40);\r\nptchcount = ((len & 0x07) << 4) | (mode & 0x03);\r\nreg_w_val(gspca_dev, ET_I2C_COUNT, ptchcount);\r\nreg_w_val(gspca_dev, ET_I2C_REG, reg);\r\nwhile (--len >= 0)\r\nreg_w_val(gspca_dev, ET_I2C_DATA0 + len, buffer[len]);\r\nreturn 0;\r\n}\r\nstatic int i2c_r(struct gspca_dev *gspca_dev,\r\n__u8 reg)\r\n{\r\nreg_w_val(gspca_dev, ET_I2C_BASE, 0x40);\r\nreg_w_val(gspca_dev, ET_I2C_COUNT, 0x11);\r\nreg_w_val(gspca_dev, ET_I2C_REG, reg);\r\nreg_w_val(gspca_dev, ET_I2C_PREFETCH, 0x02);\r\nreg_w_val(gspca_dev, ET_I2C_PREFETCH, 0x00);\r\nreg_r(gspca_dev, ET_I2C_DATA0, 1);\r\nreturn 0;\r\n}\r\nstatic int Et_WaitStatus(struct gspca_dev *gspca_dev)\r\n{\r\nint retry = 10;\r\nwhile (retry--) {\r\nreg_r(gspca_dev, ET_ClCK, 1);\r\nif (gspca_dev->usb_buf[0] != 0)\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int et_video(struct gspca_dev *gspca_dev,\r\nint on)\r\n{\r\nint ret;\r\nreg_w_val(gspca_dev, ET_GPIO_OUT,\r\non ? 0x10\r\n: 0);\r\nret = Et_WaitStatus(gspca_dev);\r\nif (ret != 0)\r\nPDEBUG(D_ERR, "timeout video on/off");\r\nreturn ret;\r\n}\r\nstatic void Et_init2(struct gspca_dev *gspca_dev)\r\n{\r\n__u8 value;\r\nstatic const __u8 FormLine[] = { 0x84, 0x03, 0x14, 0xf4, 0x01, 0x05 };\r\nPDEBUG(D_STREAM, "Open Init2 ET");\r\nreg_w_val(gspca_dev, ET_GPIO_DIR_CTRL, 0x2f);\r\nreg_w_val(gspca_dev, ET_GPIO_OUT, 0x10);\r\nreg_r(gspca_dev, ET_GPIO_IN, 1);\r\nreg_w_val(gspca_dev, ET_ClCK, 0x14);\r\nreg_w_val(gspca_dev, ET_CTRL, 0x1b);\r\nif (gspca_dev->cam.cam_mode[(int) gspca_dev->curr_mode].priv)\r\nvalue = ET_COMP_VAL1;\r\nelse\r\nvalue = ET_COMP_VAL0;\r\nreg_w_val(gspca_dev, ET_COMP, value);\r\nreg_w_val(gspca_dev, ET_MAXQt, 0x1f);\r\nreg_w_val(gspca_dev, ET_MINQt, 0x04);\r\nreg_w_val(gspca_dev, ET_REG1d, 0xff);\r\nreg_w_val(gspca_dev, ET_REG1e, 0xff);\r\nreg_w_val(gspca_dev, ET_REG1f, 0xff);\r\nreg_w_val(gspca_dev, ET_REG20, 0x35);\r\nreg_w_val(gspca_dev, ET_REG21, 0x01);\r\nreg_w_val(gspca_dev, ET_REG22, 0x00);\r\nreg_w_val(gspca_dev, ET_REG23, 0xff);\r\nreg_w_val(gspca_dev, ET_REG24, 0xff);\r\nreg_w_val(gspca_dev, ET_REG25, 0x0f);\r\nreg_w_val(gspca_dev, 0x30, 0x11);\r\nreg_w_val(gspca_dev, 0x31, 0x40);\r\nreg_w_val(gspca_dev, 0x32, 0x00);\r\nreg_w_val(gspca_dev, ET_O_RED, 0x00);\r\nreg_w_val(gspca_dev, ET_O_GREEN1, 0x00);\r\nreg_w_val(gspca_dev, ET_O_BLUE, 0x00);\r\nreg_w_val(gspca_dev, ET_O_GREEN2, 0x00);\r\nreg_w_val(gspca_dev, ET_G_RED, 0x80);\r\nreg_w_val(gspca_dev, ET_G_GREEN1, 0x80);\r\nreg_w_val(gspca_dev, ET_G_BLUE, 0x80);\r\nreg_w_val(gspca_dev, ET_G_GREEN2, 0x80);\r\nreg_w_val(gspca_dev, ET_G_GR_H, 0x00);\r\nreg_w_val(gspca_dev, ET_G_GB_H, 0x00);\r\nreg_w_val(gspca_dev, 0x61, 0x80);\r\nreg_w_val(gspca_dev, 0x62, 0x02);\r\nreg_w_val(gspca_dev, 0x63, 0x03);\r\nreg_w_val(gspca_dev, 0x64, 0x14);\r\nreg_w_val(gspca_dev, 0x65, 0x0e);\r\nreg_w_val(gspca_dev, 0x66, 0x02);\r\nreg_w_val(gspca_dev, 0x67, 0x02);\r\nreg_w_val(gspca_dev, ET_SYNCHRO, 0x8f);\r\nreg_w_val(gspca_dev, ET_STARTX, 0x69);\r\nreg_w_val(gspca_dev, ET_STARTY, 0x0d);\r\nreg_w_val(gspca_dev, ET_WIDTH_LOW, 0x80);\r\nreg_w_val(gspca_dev, ET_HEIGTH_LOW, 0xe0);\r\nreg_w_val(gspca_dev, ET_W_H_HEIGTH, 0x60);\r\nreg_w_val(gspca_dev, ET_REG6e, 0x86);\r\nreg_w_val(gspca_dev, ET_REG6f, 0x01);\r\nreg_w_val(gspca_dev, ET_REG70, 0x26);\r\nreg_w_val(gspca_dev, ET_REG71, 0x7a);\r\nreg_w_val(gspca_dev, ET_REG72, 0x01);\r\nreg_w_val(gspca_dev, ET_REG73, 0x00);\r\nreg_w_val(gspca_dev, ET_REG74, 0x18);\r\nreg_w_val(gspca_dev, ET_REG75, 0x0f);\r\nreg_w_val(gspca_dev, 0x8a, 0x20);\r\nreg_w_val(gspca_dev, 0x8d, 0x0f);\r\nreg_w_val(gspca_dev, 0x8e, 0x08);\r\nreg_w_val(gspca_dev, 0x03, 0x08);\r\nreg_w_val(gspca_dev, ET_PXL_CLK, 0x03);\r\nreg_w_val(gspca_dev, 0x81, 0xff);\r\nreg_w_val(gspca_dev, 0x80, 0x00);\r\nreg_w_val(gspca_dev, 0x81, 0xff);\r\nreg_w_val(gspca_dev, 0x80, 0x20);\r\nreg_w_val(gspca_dev, 0x03, 0x01);\r\nreg_w_val(gspca_dev, 0x03, 0x00);\r\nreg_w_val(gspca_dev, 0x03, 0x08);\r\nif (gspca_dev->cam.cam_mode[(int) gspca_dev->curr_mode].priv)\r\nvalue = 0x04;\r\nelse\r\nvalue = 0x1e;\r\nreg_w_val(gspca_dev, ET_PXL_CLK, value);\r\nreg_w(gspca_dev, 0x62, FormLine, 6);\r\nreg_w_val(gspca_dev, 0x81, 0x47);\r\nreg_w_val(gspca_dev, 0x80, 0x40);\r\nreg_w_val(gspca_dev, 0x81, 0x30);\r\nreg_w_val(gspca_dev, 0x80, 0x20);\r\n}\r\nstatic void setbrightness(struct gspca_dev *gspca_dev, s32 val)\r\n{\r\nint i;\r\nfor (i = 0; i < 4; i++)\r\nreg_w_val(gspca_dev, ET_O_RED + i, val);\r\n}\r\nstatic void setcontrast(struct gspca_dev *gspca_dev, s32 val)\r\n{\r\n__u8 RGBG[] = { 0x80, 0x80, 0x80, 0x80, 0x00, 0x00 };\r\nmemset(RGBG, val, sizeof(RGBG) - 2);\r\nreg_w(gspca_dev, ET_G_RED, RGBG, 6);\r\n}\r\nstatic void setcolors(struct gspca_dev *gspca_dev, s32 val)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\n__u8 I2cc[] = { 0x05, 0x02, 0x02, 0x05, 0x0d };\r\n__u8 i2cflags = 0x01;\r\nI2cc[3] = val;\r\nI2cc[0] = 15 - val;\r\nif (sd->sensor == SENSOR_PAS106) {\r\ni2c_w(gspca_dev, PAS106_REG13, &i2cflags, 1, 3);\r\ni2c_w(gspca_dev, PAS106_REG9, I2cc, sizeof I2cc, 1);\r\n}\r\n}\r\nstatic s32 getcolors(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nif (sd->sensor == SENSOR_PAS106) {\r\ni2c_r(gspca_dev, PAS106_REG9 + 3);\r\nreturn gspca_dev->usb_buf[0] & 0x0f;\r\n}\r\nreturn 0;\r\n}\r\nstatic void setautogain(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nif (sd->autogain)\r\nsd->ag_cnt = AG_CNT_START;\r\nelse\r\nsd->ag_cnt = -1;\r\n}\r\nstatic void Et_init1(struct gspca_dev *gspca_dev)\r\n{\r\n__u8 value;\r\n__u8 I2c0[] = { 0x0a, 0x12, 0x05, 0x6d, 0xcd, 0x00, 0x01, 0x00 };\r\nPDEBUG(D_STREAM, "Open Init1 ET");\r\nreg_w_val(gspca_dev, ET_GPIO_DIR_CTRL, 7);\r\nreg_r(gspca_dev, ET_GPIO_IN, 1);\r\nreg_w_val(gspca_dev, ET_RESET_ALL, 1);\r\nreg_w_val(gspca_dev, ET_RESET_ALL, 0);\r\nreg_w_val(gspca_dev, ET_ClCK, 0x10);\r\nreg_w_val(gspca_dev, ET_CTRL, 0x19);\r\nif (gspca_dev->cam.cam_mode[(int) gspca_dev->curr_mode].priv)\r\nvalue = ET_COMP_VAL1;\r\nelse\r\nvalue = ET_COMP_VAL0;\r\nPDEBUG(D_STREAM, "Open mode %d Compression %d",\r\ngspca_dev->cam.cam_mode[(int) gspca_dev->curr_mode].priv,\r\nvalue);\r\nreg_w_val(gspca_dev, ET_COMP, value);\r\nreg_w_val(gspca_dev, ET_MAXQt, 0x1d);\r\nreg_w_val(gspca_dev, ET_MINQt, 0x02);\r\nreg_w_val(gspca_dev, ET_REG1d, 0xff);\r\nreg_w_val(gspca_dev, ET_REG1e, 0xff);\r\nreg_w_val(gspca_dev, ET_REG1f, 0xff);\r\nreg_w_val(gspca_dev, ET_REG20, 0x35);\r\nreg_w_val(gspca_dev, ET_REG21, 0x01);\r\nreg_w_val(gspca_dev, ET_REG22, 0x00);\r\nreg_w_val(gspca_dev, ET_REG23, 0xf7);\r\nreg_w_val(gspca_dev, ET_REG24, 0xff);\r\nreg_w_val(gspca_dev, ET_REG25, 0x07);\r\nreg_w_val(gspca_dev, ET_G_RED, 0x80);\r\nreg_w_val(gspca_dev, ET_G_GREEN1, 0x80);\r\nreg_w_val(gspca_dev, ET_G_BLUE, 0x80);\r\nreg_w_val(gspca_dev, ET_G_GREEN2, 0x80);\r\nreg_w_val(gspca_dev, ET_G_GR_H, 0x00);\r\nreg_w_val(gspca_dev, ET_G_GB_H, 0x00);\r\nreg_w_val(gspca_dev, ET_SYNCHRO, 0xf0);\r\nreg_w_val(gspca_dev, ET_STARTX, 0x56);\r\nreg_w_val(gspca_dev, ET_STARTY, 0x05);\r\nreg_w_val(gspca_dev, ET_WIDTH_LOW, 0x60);\r\nreg_w_val(gspca_dev, ET_HEIGTH_LOW, 0x20);\r\nreg_w_val(gspca_dev, ET_W_H_HEIGTH, 0x50);\r\nreg_w_val(gspca_dev, ET_REG6e, 0x86);\r\nreg_w_val(gspca_dev, ET_REG6f, 0x01);\r\nreg_w_val(gspca_dev, ET_REG70, 0x86);\r\nreg_w_val(gspca_dev, ET_REG71, 0x14);\r\nreg_w_val(gspca_dev, ET_REG72, 0x00);\r\nreg_w_val(gspca_dev, ET_REG73, 0x00);\r\nreg_w_val(gspca_dev, ET_REG74, 0x00);\r\nreg_w_val(gspca_dev, ET_REG75, 0x0a);\r\nreg_w_val(gspca_dev, ET_I2C_CLK, 0x04);\r\nreg_w_val(gspca_dev, ET_PXL_CLK, 0x01);\r\nif (gspca_dev->cam.cam_mode[(int) gspca_dev->curr_mode].priv) {\r\nI2c0[0] = 0x06;\r\ni2c_w(gspca_dev, PAS106_REG2, I2c0, sizeof I2c0, 1);\r\ni2c_w(gspca_dev, PAS106_REG9, I2c2, sizeof I2c2, 1);\r\nvalue = 0x06;\r\ni2c_w(gspca_dev, PAS106_REG2, &value, 1, 1);\r\ni2c_w(gspca_dev, PAS106_REG3, I2c3, sizeof I2c3, 1);\r\nvalue = 0x04;\r\ni2c_w(gspca_dev, PAS106_REG0e, &value, 1, 1);\r\n} else {\r\nI2c0[0] = 0x0a;\r\ni2c_w(gspca_dev, PAS106_REG2, I2c0, sizeof I2c0, 1);\r\ni2c_w(gspca_dev, PAS106_REG9, I2c2, sizeof I2c2, 1);\r\nvalue = 0x0a;\r\ni2c_w(gspca_dev, PAS106_REG2, &value, 1, 1);\r\ni2c_w(gspca_dev, PAS106_REG3, I2c3, sizeof I2c3, 1);\r\nvalue = 0x04;\r\ni2c_w(gspca_dev, PAS106_REG0e, &value, 1, 1);\r\n}\r\ni2c_w(gspca_dev, PAS106_REG7, I2c4, sizeof I2c4, 1);\r\nreg_w(gspca_dev, ET_G_RED, GainRGBG, 6);\r\nsetcolors(gspca_dev, getcolors(gspca_dev));\r\n}\r\nstatic int sd_config(struct gspca_dev *gspca_dev,\r\nconst struct usb_device_id *id)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nstruct cam *cam;\r\ncam = &gspca_dev->cam;\r\nsd->sensor = id->driver_info;\r\nif (sd->sensor == SENSOR_PAS106) {\r\ncam->cam_mode = sif_mode;\r\ncam->nmodes = ARRAY_SIZE(sif_mode);\r\n} else {\r\ncam->cam_mode = vga_mode;\r\ncam->nmodes = ARRAY_SIZE(vga_mode);\r\n}\r\nsd->ag_cnt = -1;\r\nreturn 0;\r\n}\r\nstatic int sd_init(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nif (sd->sensor == SENSOR_PAS106)\r\nEt_init1(gspca_dev);\r\nelse\r\nEt_init2(gspca_dev);\r\nreg_w_val(gspca_dev, ET_RESET_ALL, 0x08);\r\net_video(gspca_dev, 0);\r\nreturn 0;\r\n}\r\nstatic int sd_start(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nif (sd->sensor == SENSOR_PAS106)\r\nEt_init1(gspca_dev);\r\nelse\r\nEt_init2(gspca_dev);\r\nsetautogain(gspca_dev);\r\nreg_w_val(gspca_dev, ET_RESET_ALL, 0x08);\r\net_video(gspca_dev, 1);\r\nreturn 0;\r\n}\r\nstatic void sd_stopN(struct gspca_dev *gspca_dev)\r\n{\r\net_video(gspca_dev, 0);\r\n}\r\nstatic __u8 Et_getgainG(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nif (sd->sensor == SENSOR_PAS106) {\r\ni2c_r(gspca_dev, PAS106_REG0e);\r\nPDEBUG(D_CONF, "Etoms gain G %d", gspca_dev->usb_buf[0]);\r\nreturn gspca_dev->usb_buf[0];\r\n}\r\nreturn 0x1f;\r\n}\r\nstatic void Et_setgainG(struct gspca_dev *gspca_dev, __u8 gain)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nif (sd->sensor == SENSOR_PAS106) {\r\n__u8 i2cflags = 0x01;\r\ni2c_w(gspca_dev, PAS106_REG13, &i2cflags, 1, 3);\r\ni2c_w(gspca_dev, PAS106_REG0e, &gain, 1, 1);\r\n}\r\n}\r\nstatic void do_autogain(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\n__u8 luma;\r\n__u8 luma_mean = 128;\r\n__u8 luma_delta = 20;\r\n__u8 spring = 4;\r\nint Gbright;\r\n__u8 r, g, b;\r\nif (sd->ag_cnt < 0)\r\nreturn;\r\nif (--sd->ag_cnt >= 0)\r\nreturn;\r\nsd->ag_cnt = AG_CNT_START;\r\nGbright = Et_getgainG(gspca_dev);\r\nreg_r(gspca_dev, ET_LUMA_CENTER, 4);\r\ng = (gspca_dev->usb_buf[0] + gspca_dev->usb_buf[3]) >> 1;\r\nr = gspca_dev->usb_buf[1];\r\nb = gspca_dev->usb_buf[2];\r\nr = ((r << 8) - (r << 4) - (r << 3)) >> 10;\r\nb = ((b << 7) >> 10);\r\ng = ((g << 9) + (g << 7) + (g << 5)) >> 10;\r\nluma = LIMIT(r + g + b);\r\nPDEBUG(D_FRAM, "Etoms luma G %d", luma);\r\nif (luma < luma_mean - luma_delta || luma > luma_mean + luma_delta) {\r\nGbright += (luma_mean - luma) >> spring;\r\nGbright = BLIMIT(Gbright);\r\nPDEBUG(D_FRAM, "Etoms Gbright %d", Gbright);\r\nEt_setgainG(gspca_dev, (__u8) Gbright);\r\n}\r\n}\r\nstatic void sd_pkt_scan(struct gspca_dev *gspca_dev,\r\nu8 *data,\r\nint len)\r\n{\r\nint seqframe;\r\nseqframe = data[0] & 0x3f;\r\nlen = (int) (((data[0] & 0xc0) << 2) | data[1]);\r\nif (seqframe == 0x3f) {\r\nPDEBUG(D_FRAM,\r\n"header packet found datalength %d !!", len);\r\nPDEBUG(D_FRAM, "G %d R %d G %d B %d",\r\ndata[2], data[3], data[4], data[5]);\r\ndata += 30;\r\ngspca_frame_add(gspca_dev, LAST_PACKET, NULL, 0);\r\ngspca_frame_add(gspca_dev, FIRST_PACKET, data, len);\r\nreturn;\r\n}\r\nif (len) {\r\ndata += 8;\r\ngspca_frame_add(gspca_dev, INTER_PACKET, data, len);\r\n} else {\r\ngspca_dev->last_packet_type = DISCARD_PACKET;\r\n}\r\n}\r\nstatic int sd_s_ctrl(struct v4l2_ctrl *ctrl)\r\n{\r\nstruct gspca_dev *gspca_dev =\r\ncontainer_of(ctrl->handler, struct gspca_dev, ctrl_handler);\r\nstruct sd *sd = (struct sd *)gspca_dev;\r\ngspca_dev->usb_err = 0;\r\nif (!gspca_dev->streaming)\r\nreturn 0;\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_BRIGHTNESS:\r\nsetbrightness(gspca_dev, ctrl->val);\r\nbreak;\r\ncase V4L2_CID_CONTRAST:\r\nsetcontrast(gspca_dev, ctrl->val);\r\nbreak;\r\ncase V4L2_CID_SATURATION:\r\nsetcolors(gspca_dev, ctrl->val);\r\nbreak;\r\ncase V4L2_CID_AUTOGAIN:\r\nsd->autogain = ctrl->val;\r\nsetautogain(gspca_dev);\r\nbreak;\r\n}\r\nreturn gspca_dev->usb_err;\r\n}\r\nstatic int sd_init_controls(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *)gspca_dev;\r\nstruct v4l2_ctrl_handler *hdl = &gspca_dev->ctrl_handler;\r\ngspca_dev->vdev.ctrl_handler = hdl;\r\nv4l2_ctrl_handler_init(hdl, 4);\r\nv4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\r\nV4L2_CID_BRIGHTNESS, 1, 127, 1, 63);\r\nv4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\r\nV4L2_CID_CONTRAST, 0, 255, 1, 127);\r\nif (sd->sensor == SENSOR_PAS106)\r\nv4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\r\nV4L2_CID_SATURATION, 0, 15, 1, 7);\r\nv4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\r\nV4L2_CID_AUTOGAIN, 0, 1, 1, 1);\r\nif (hdl->error) {\r\npr_err("Could not initialize controls\n");\r\nreturn hdl->error;\r\n}\r\nreturn 0;\r\n}\r\nstatic int sd_probe(struct usb_interface *intf,\r\nconst struct usb_device_id *id)\r\n{\r\nreturn gspca_dev_probe(intf, id, &sd_desc, sizeof(struct sd),\r\nTHIS_MODULE);\r\n}
