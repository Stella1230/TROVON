static int sl82c105_pre_reset(struct ata_link *link, unsigned long deadline)\r\n{\r\nstatic const struct pci_bits sl82c105_enable_bits[] = {\r\n{ 0x40, 1, 0x01, 0x01 },\r\n{ 0x40, 1, 0x10, 0x10 }\r\n};\r\nstruct ata_port *ap = link->ap;\r\nstruct pci_dev *pdev = to_pci_dev(ap->host->dev);\r\nif (ap->port_no && !pci_test_config_bits(pdev, &sl82c105_enable_bits[ap->port_no]))\r\nreturn -ENOENT;\r\nreturn ata_sff_prereset(link, deadline);\r\n}\r\nstatic void sl82c105_configure_piomode(struct ata_port *ap, struct ata_device *adev, int pio)\r\n{\r\nstruct pci_dev *pdev = to_pci_dev(ap->host->dev);\r\nstatic u16 pio_timing[5] = {\r\n0x50D, 0x407, 0x304, 0x242, 0x240\r\n};\r\nu16 dummy;\r\nint timing = 0x44 + (8 * ap->port_no) + (4 * adev->devno);\r\npci_write_config_word(pdev, timing, pio_timing[pio]);\r\npci_read_config_word(pdev, timing, &dummy);\r\n}\r\nstatic void sl82c105_set_piomode(struct ata_port *ap, struct ata_device *adev)\r\n{\r\nsl82c105_configure_piomode(ap, adev, adev->pio_mode - XFER_PIO_0);\r\n}\r\nstatic void sl82c105_configure_dmamode(struct ata_port *ap, struct ata_device *adev)\r\n{\r\nstruct pci_dev *pdev = to_pci_dev(ap->host->dev);\r\nstatic u16 dma_timing[3] = {\r\n0x707, 0x201, 0x200\r\n};\r\nu16 dummy;\r\nint timing = 0x44 + (8 * ap->port_no) + (4 * adev->devno);\r\nint dma = adev->dma_mode - XFER_MW_DMA_0;\r\npci_write_config_word(pdev, timing, dma_timing[dma]);\r\npci_read_config_word(pdev, timing, &dummy);\r\n}\r\nstatic void sl82c105_reset_engine(struct ata_port *ap)\r\n{\r\nstruct pci_dev *pdev = to_pci_dev(ap->host->dev);\r\nu16 val;\r\npci_read_config_word(pdev, 0x7E, &val);\r\npci_write_config_word(pdev, 0x7E, val | 4);\r\npci_write_config_word(pdev, 0x7E, val & ~4);\r\n}\r\nstatic void sl82c105_bmdma_start(struct ata_queued_cmd *qc)\r\n{\r\nstruct ata_port *ap = qc->ap;\r\nudelay(100);\r\nsl82c105_reset_engine(ap);\r\nudelay(100);\r\nsl82c105_configure_dmamode(ap, qc->dev);\r\nata_bmdma_start(qc);\r\n}\r\nstatic void sl82c105_bmdma_stop(struct ata_queued_cmd *qc)\r\n{\r\nstruct ata_port *ap = qc->ap;\r\nata_bmdma_stop(qc);\r\nsl82c105_reset_engine(ap);\r\nudelay(100);\r\nsl82c105_set_piomode(ap, qc->dev);\r\n}\r\nstatic int sl82c105_qc_defer(struct ata_queued_cmd *qc)\r\n{\r\nstruct ata_host *host = qc->ap->host;\r\nstruct ata_port *alt = host->ports[1 ^ qc->ap->port_no];\r\nint rc;\r\nrc = ata_std_qc_defer(qc);\r\nif (rc != 0)\r\nreturn rc;\r\nif (alt && alt->qc_active)\r\nreturn ATA_DEFER_PORT;\r\nreturn 0;\r\n}\r\nstatic bool sl82c105_sff_irq_check(struct ata_port *ap)\r\n{\r\nstruct pci_dev *pdev = to_pci_dev(ap->host->dev);\r\nu32 val, mask = ap->port_no ? CTRL_IDE_IRQB : CTRL_IDE_IRQA;\r\npci_read_config_dword(pdev, 0x40, &val);\r\nreturn val & mask;\r\n}\r\nstatic int sl82c105_bridge_revision(struct pci_dev *pdev)\r\n{\r\nstruct pci_dev *bridge;\r\nbridge = pci_get_slot(pdev->bus,\r\nPCI_DEVFN(PCI_SLOT(pdev->devfn), 0));\r\nif (!bridge)\r\nreturn -1;\r\nif (bridge->vendor != PCI_VENDOR_ID_WINBOND ||\r\nbridge->device != PCI_DEVICE_ID_WINBOND_83C553 ||\r\nbridge->class >> 8 != PCI_CLASS_BRIDGE_ISA) {\r\npci_dev_put(bridge);\r\nreturn -1;\r\n}\r\npci_dev_put(bridge);\r\nreturn bridge->revision;\r\n}\r\nstatic void sl82c105_fixup(struct pci_dev *pdev)\r\n{\r\nu32 val;\r\npci_read_config_dword(pdev, 0x40, &val);\r\nval |= CTRL_P0EN | CTRL_P0F16 | CTRL_P1F16;\r\npci_write_config_dword(pdev, 0x40, val);\r\n}\r\nstatic int sl82c105_init_one(struct pci_dev *dev, const struct pci_device_id *id)\r\n{\r\nstatic const struct ata_port_info info_dma = {\r\n.flags = ATA_FLAG_SLAVE_POSS,\r\n.pio_mask = ATA_PIO4,\r\n.mwdma_mask = ATA_MWDMA2,\r\n.port_ops = &sl82c105_port_ops\r\n};\r\nstatic const struct ata_port_info info_early = {\r\n.flags = ATA_FLAG_SLAVE_POSS,\r\n.pio_mask = ATA_PIO4,\r\n.port_ops = &sl82c105_port_ops\r\n};\r\nconst struct ata_port_info *ppi[] = { &info_early,\r\nNULL };\r\nint rev;\r\nint rc;\r\nrc = pcim_enable_device(dev);\r\nif (rc)\r\nreturn rc;\r\nrev = sl82c105_bridge_revision(dev);\r\nif (rev == -1)\r\ndev_warn(&dev->dev,\r\n"pata_sl82c105: Unable to find bridge, disabling DMA\n");\r\nelse if (rev <= 5)\r\ndev_warn(&dev->dev,\r\n"pata_sl82c105: Early bridge revision, no DMA available\n");\r\nelse\r\nppi[0] = &info_dma;\r\nsl82c105_fixup(dev);\r\nreturn ata_pci_bmdma_init_one(dev, ppi, &sl82c105_sht, NULL, 0);\r\n}\r\nstatic int sl82c105_reinit_one(struct pci_dev *pdev)\r\n{\r\nstruct ata_host *host = dev_get_drvdata(&pdev->dev);\r\nint rc;\r\nrc = ata_pci_device_do_resume(pdev);\r\nif (rc)\r\nreturn rc;\r\nsl82c105_fixup(pdev);\r\nata_host_resume(host);\r\nreturn 0;\r\n}
