static const struct inet_diag_handler *inet_diag_lock_handler(int proto)\r\n{\r\nif (!inet_diag_table[proto])\r\nrequest_module("net-pf-%d-proto-%d-type-%d-%d", PF_NETLINK,\r\nNETLINK_SOCK_DIAG, AF_INET, proto);\r\nmutex_lock(&inet_diag_table_mutex);\r\nif (!inet_diag_table[proto])\r\nreturn ERR_PTR(-ENOENT);\r\nreturn inet_diag_table[proto];\r\n}\r\nstatic inline void inet_diag_unlock_handler(\r\nconst struct inet_diag_handler *handler)\r\n{\r\nmutex_unlock(&inet_diag_table_mutex);\r\n}\r\nint inet_sk_diag_fill(struct sock *sk, struct inet_connection_sock *icsk,\r\nstruct sk_buff *skb, struct inet_diag_req_v2 *req,\r\nstruct user_namespace *user_ns,\r\nu32 portid, u32 seq, u16 nlmsg_flags,\r\nconst struct nlmsghdr *unlh)\r\n{\r\nconst struct inet_sock *inet = inet_sk(sk);\r\nstruct inet_diag_msg *r;\r\nstruct nlmsghdr *nlh;\r\nstruct nlattr *attr;\r\nvoid *info = NULL;\r\nconst struct inet_diag_handler *handler;\r\nint ext = req->idiag_ext;\r\nhandler = inet_diag_table[req->sdiag_protocol];\r\nBUG_ON(handler == NULL);\r\nnlh = nlmsg_put(skb, portid, seq, unlh->nlmsg_type, sizeof(*r),\r\nnlmsg_flags);\r\nif (!nlh)\r\nreturn -EMSGSIZE;\r\nr = nlmsg_data(nlh);\r\nBUG_ON(sk->sk_state == TCP_TIME_WAIT);\r\nr->idiag_family = sk->sk_family;\r\nr->idiag_state = sk->sk_state;\r\nr->idiag_timer = 0;\r\nr->idiag_retrans = 0;\r\nr->id.idiag_if = sk->sk_bound_dev_if;\r\nsock_diag_save_cookie(sk, r->id.idiag_cookie);\r\nr->id.idiag_sport = inet->inet_sport;\r\nr->id.idiag_dport = inet->inet_dport;\r\nr->id.idiag_src[0] = inet->inet_rcv_saddr;\r\nr->id.idiag_dst[0] = inet->inet_daddr;\r\nif (nla_put_u8(skb, INET_DIAG_SHUTDOWN, sk->sk_shutdown))\r\ngoto errout;\r\nif (ext & (1 << (INET_DIAG_TOS - 1)))\r\nif (nla_put_u8(skb, INET_DIAG_TOS, inet->tos) < 0)\r\ngoto errout;\r\n#if IS_ENABLED(CONFIG_IPV6)\r\nif (r->idiag_family == AF_INET6) {\r\nconst struct ipv6_pinfo *np = inet6_sk(sk);\r\n*(struct in6_addr *)r->id.idiag_src = np->rcv_saddr;\r\n*(struct in6_addr *)r->id.idiag_dst = np->daddr;\r\nif (ext & (1 << (INET_DIAG_TCLASS - 1)))\r\nif (nla_put_u8(skb, INET_DIAG_TCLASS, np->tclass) < 0)\r\ngoto errout;\r\n}\r\n#endif\r\nr->idiag_uid = from_kuid_munged(user_ns, sock_i_uid(sk));\r\nr->idiag_inode = sock_i_ino(sk);\r\nif (ext & (1 << (INET_DIAG_MEMINFO - 1))) {\r\nstruct inet_diag_meminfo minfo = {\r\n.idiag_rmem = sk_rmem_alloc_get(sk),\r\n.idiag_wmem = sk->sk_wmem_queued,\r\n.idiag_fmem = sk->sk_forward_alloc,\r\n.idiag_tmem = sk_wmem_alloc_get(sk),\r\n};\r\nif (nla_put(skb, INET_DIAG_MEMINFO, sizeof(minfo), &minfo) < 0)\r\ngoto errout;\r\n}\r\nif (ext & (1 << (INET_DIAG_SKMEMINFO - 1)))\r\nif (sock_diag_put_meminfo(sk, skb, INET_DIAG_SKMEMINFO))\r\ngoto errout;\r\nif (icsk == NULL) {\r\nhandler->idiag_get_info(sk, r, NULL);\r\ngoto out;\r\n}\r\n#define EXPIRES_IN_MS(tmo) DIV_ROUND_UP((tmo - jiffies) * 1000, HZ)\r\nif (icsk->icsk_pending == ICSK_TIME_RETRANS) {\r\nr->idiag_timer = 1;\r\nr->idiag_retrans = icsk->icsk_retransmits;\r\nr->idiag_expires = EXPIRES_IN_MS(icsk->icsk_timeout);\r\n} else if (icsk->icsk_pending == ICSK_TIME_PROBE0) {\r\nr->idiag_timer = 4;\r\nr->idiag_retrans = icsk->icsk_probes_out;\r\nr->idiag_expires = EXPIRES_IN_MS(icsk->icsk_timeout);\r\n} else if (timer_pending(&sk->sk_timer)) {\r\nr->idiag_timer = 2;\r\nr->idiag_retrans = icsk->icsk_probes_out;\r\nr->idiag_expires = EXPIRES_IN_MS(sk->sk_timer.expires);\r\n} else {\r\nr->idiag_timer = 0;\r\nr->idiag_expires = 0;\r\n}\r\n#undef EXPIRES_IN_MS\r\nif (ext & (1 << (INET_DIAG_INFO - 1))) {\r\nattr = nla_reserve(skb, INET_DIAG_INFO,\r\nsizeof(struct tcp_info));\r\nif (!attr)\r\ngoto errout;\r\ninfo = nla_data(attr);\r\n}\r\nif ((ext & (1 << (INET_DIAG_CONG - 1))) && icsk->icsk_ca_ops)\r\nif (nla_put_string(skb, INET_DIAG_CONG,\r\nicsk->icsk_ca_ops->name) < 0)\r\ngoto errout;\r\nhandler->idiag_get_info(sk, r, info);\r\nif (sk->sk_state < TCP_TIME_WAIT &&\r\nicsk->icsk_ca_ops && icsk->icsk_ca_ops->get_info)\r\nicsk->icsk_ca_ops->get_info(sk, ext, skb);\r\nout:\r\nreturn nlmsg_end(skb, nlh);\r\nerrout:\r\nnlmsg_cancel(skb, nlh);\r\nreturn -EMSGSIZE;\r\n}\r\nstatic int inet_csk_diag_fill(struct sock *sk,\r\nstruct sk_buff *skb, struct inet_diag_req_v2 *req,\r\nstruct user_namespace *user_ns,\r\nu32 portid, u32 seq, u16 nlmsg_flags,\r\nconst struct nlmsghdr *unlh)\r\n{\r\nreturn inet_sk_diag_fill(sk, inet_csk(sk),\r\nskb, req, user_ns, portid, seq, nlmsg_flags, unlh);\r\n}\r\nstatic int inet_twsk_diag_fill(struct inet_timewait_sock *tw,\r\nstruct sk_buff *skb, struct inet_diag_req_v2 *req,\r\nu32 portid, u32 seq, u16 nlmsg_flags,\r\nconst struct nlmsghdr *unlh)\r\n{\r\nlong tmo;\r\nstruct inet_diag_msg *r;\r\nstruct nlmsghdr *nlh;\r\nnlh = nlmsg_put(skb, portid, seq, unlh->nlmsg_type, sizeof(*r),\r\nnlmsg_flags);\r\nif (!nlh)\r\nreturn -EMSGSIZE;\r\nr = nlmsg_data(nlh);\r\nBUG_ON(tw->tw_state != TCP_TIME_WAIT);\r\ntmo = tw->tw_ttd - jiffies;\r\nif (tmo < 0)\r\ntmo = 0;\r\nr->idiag_family = tw->tw_family;\r\nr->idiag_retrans = 0;\r\nr->id.idiag_if = tw->tw_bound_dev_if;\r\nsock_diag_save_cookie(tw, r->id.idiag_cookie);\r\nr->id.idiag_sport = tw->tw_sport;\r\nr->id.idiag_dport = tw->tw_dport;\r\nr->id.idiag_src[0] = tw->tw_rcv_saddr;\r\nr->id.idiag_dst[0] = tw->tw_daddr;\r\nr->idiag_state = tw->tw_substate;\r\nr->idiag_timer = 3;\r\nr->idiag_expires = DIV_ROUND_UP(tmo * 1000, HZ);\r\nr->idiag_rqueue = 0;\r\nr->idiag_wqueue = 0;\r\nr->idiag_uid = 0;\r\nr->idiag_inode = 0;\r\n#if IS_ENABLED(CONFIG_IPV6)\r\nif (tw->tw_family == AF_INET6) {\r\nconst struct inet6_timewait_sock *tw6 =\r\ninet6_twsk((struct sock *)tw);\r\n*(struct in6_addr *)r->id.idiag_src = tw6->tw_v6_rcv_saddr;\r\n*(struct in6_addr *)r->id.idiag_dst = tw6->tw_v6_daddr;\r\n}\r\n#endif\r\nreturn nlmsg_end(skb, nlh);\r\n}\r\nstatic int sk_diag_fill(struct sock *sk, struct sk_buff *skb,\r\nstruct inet_diag_req_v2 *r,\r\nstruct user_namespace *user_ns,\r\nu32 portid, u32 seq, u16 nlmsg_flags,\r\nconst struct nlmsghdr *unlh)\r\n{\r\nif (sk->sk_state == TCP_TIME_WAIT)\r\nreturn inet_twsk_diag_fill((struct inet_timewait_sock *)sk,\r\nskb, r, portid, seq, nlmsg_flags,\r\nunlh);\r\nreturn inet_csk_diag_fill(sk, skb, r, user_ns, portid, seq, nlmsg_flags, unlh);\r\n}\r\nint inet_diag_dump_one_icsk(struct inet_hashinfo *hashinfo, struct sk_buff *in_skb,\r\nconst struct nlmsghdr *nlh, struct inet_diag_req_v2 *req)\r\n{\r\nint err;\r\nstruct sock *sk;\r\nstruct sk_buff *rep;\r\nstruct net *net = sock_net(in_skb->sk);\r\nerr = -EINVAL;\r\nif (req->sdiag_family == AF_INET) {\r\nsk = inet_lookup(net, hashinfo, req->id.idiag_dst[0],\r\nreq->id.idiag_dport, req->id.idiag_src[0],\r\nreq->id.idiag_sport, req->id.idiag_if);\r\n}\r\n#if IS_ENABLED(CONFIG_IPV6)\r\nelse if (req->sdiag_family == AF_INET6) {\r\nsk = inet6_lookup(net, hashinfo,\r\n(struct in6_addr *)req->id.idiag_dst,\r\nreq->id.idiag_dport,\r\n(struct in6_addr *)req->id.idiag_src,\r\nreq->id.idiag_sport,\r\nreq->id.idiag_if);\r\n}\r\n#endif\r\nelse {\r\ngoto out_nosk;\r\n}\r\nerr = -ENOENT;\r\nif (sk == NULL)\r\ngoto out_nosk;\r\nerr = sock_diag_check_cookie(sk, req->id.idiag_cookie);\r\nif (err)\r\ngoto out;\r\nrep = nlmsg_new(sizeof(struct inet_diag_msg) +\r\nsizeof(struct inet_diag_meminfo) +\r\nsizeof(struct tcp_info) + 64, GFP_KERNEL);\r\nif (!rep) {\r\nerr = -ENOMEM;\r\ngoto out;\r\n}\r\nerr = sk_diag_fill(sk, rep, req,\r\nsk_user_ns(NETLINK_CB(in_skb).ssk),\r\nNETLINK_CB(in_skb).portid,\r\nnlh->nlmsg_seq, 0, nlh);\r\nif (err < 0) {\r\nWARN_ON(err == -EMSGSIZE);\r\nnlmsg_free(rep);\r\ngoto out;\r\n}\r\nerr = netlink_unicast(net->diag_nlsk, rep, NETLINK_CB(in_skb).portid,\r\nMSG_DONTWAIT);\r\nif (err > 0)\r\nerr = 0;\r\nout:\r\nif (sk) {\r\nif (sk->sk_state == TCP_TIME_WAIT)\r\ninet_twsk_put((struct inet_timewait_sock *)sk);\r\nelse\r\nsock_put(sk);\r\n}\r\nout_nosk:\r\nreturn err;\r\n}\r\nstatic int inet_diag_get_exact(struct sk_buff *in_skb,\r\nconst struct nlmsghdr *nlh,\r\nstruct inet_diag_req_v2 *req)\r\n{\r\nconst struct inet_diag_handler *handler;\r\nint err;\r\nhandler = inet_diag_lock_handler(req->sdiag_protocol);\r\nif (IS_ERR(handler))\r\nerr = PTR_ERR(handler);\r\nelse\r\nerr = handler->dump_one(in_skb, nlh, req);\r\ninet_diag_unlock_handler(handler);\r\nreturn err;\r\n}\r\nstatic int bitstring_match(const __be32 *a1, const __be32 *a2, int bits)\r\n{\r\nint words = bits >> 5;\r\nbits &= 0x1f;\r\nif (words) {\r\nif (memcmp(a1, a2, words << 2))\r\nreturn 0;\r\n}\r\nif (bits) {\r\n__be32 w1, w2;\r\n__be32 mask;\r\nw1 = a1[words];\r\nw2 = a2[words];\r\nmask = htonl((0xffffffff) << (32 - bits));\r\nif ((w1 ^ w2) & mask)\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nstatic int inet_diag_bc_run(const struct nlattr *_bc,\r\nconst struct inet_diag_entry *entry)\r\n{\r\nconst void *bc = nla_data(_bc);\r\nint len = nla_len(_bc);\r\nwhile (len > 0) {\r\nint yes = 1;\r\nconst struct inet_diag_bc_op *op = bc;\r\nswitch (op->code) {\r\ncase INET_DIAG_BC_NOP:\r\nbreak;\r\ncase INET_DIAG_BC_JMP:\r\nyes = 0;\r\nbreak;\r\ncase INET_DIAG_BC_S_GE:\r\nyes = entry->sport >= op[1].no;\r\nbreak;\r\ncase INET_DIAG_BC_S_LE:\r\nyes = entry->sport <= op[1].no;\r\nbreak;\r\ncase INET_DIAG_BC_D_GE:\r\nyes = entry->dport >= op[1].no;\r\nbreak;\r\ncase INET_DIAG_BC_D_LE:\r\nyes = entry->dport <= op[1].no;\r\nbreak;\r\ncase INET_DIAG_BC_AUTO:\r\nyes = !(entry->userlocks & SOCK_BINDPORT_LOCK);\r\nbreak;\r\ncase INET_DIAG_BC_S_COND:\r\ncase INET_DIAG_BC_D_COND: {\r\nstruct inet_diag_hostcond *cond;\r\n__be32 *addr;\r\ncond = (struct inet_diag_hostcond *)(op + 1);\r\nif (cond->port != -1 &&\r\ncond->port != (op->code == INET_DIAG_BC_S_COND ?\r\nentry->sport : entry->dport)) {\r\nyes = 0;\r\nbreak;\r\n}\r\nif (op->code == INET_DIAG_BC_S_COND)\r\naddr = entry->saddr;\r\nelse\r\naddr = entry->daddr;\r\nif (cond->family != AF_UNSPEC &&\r\ncond->family != entry->family) {\r\nif (entry->family == AF_INET6 &&\r\ncond->family == AF_INET) {\r\nif (addr[0] == 0 && addr[1] == 0 &&\r\naddr[2] == htonl(0xffff) &&\r\nbitstring_match(addr + 3,\r\ncond->addr,\r\ncond->prefix_len))\r\nbreak;\r\n}\r\nyes = 0;\r\nbreak;\r\n}\r\nif (cond->prefix_len == 0)\r\nbreak;\r\nif (bitstring_match(addr, cond->addr,\r\ncond->prefix_len))\r\nbreak;\r\nyes = 0;\r\nbreak;\r\n}\r\n}\r\nif (yes) {\r\nlen -= op->yes;\r\nbc += op->yes;\r\n} else {\r\nlen -= op->no;\r\nbc += op->no;\r\n}\r\n}\r\nreturn len == 0;\r\n}\r\nint inet_diag_bc_sk(const struct nlattr *bc, struct sock *sk)\r\n{\r\nstruct inet_diag_entry entry;\r\nstruct inet_sock *inet = inet_sk(sk);\r\nif (bc == NULL)\r\nreturn 1;\r\nentry.family = sk->sk_family;\r\n#if IS_ENABLED(CONFIG_IPV6)\r\nif (entry.family == AF_INET6) {\r\nstruct ipv6_pinfo *np = inet6_sk(sk);\r\nentry.saddr = np->rcv_saddr.s6_addr32;\r\nentry.daddr = np->daddr.s6_addr32;\r\n} else\r\n#endif\r\n{\r\nentry.saddr = &inet->inet_rcv_saddr;\r\nentry.daddr = &inet->inet_daddr;\r\n}\r\nentry.sport = inet->inet_num;\r\nentry.dport = ntohs(inet->inet_dport);\r\nentry.userlocks = sk->sk_userlocks;\r\nreturn inet_diag_bc_run(bc, &entry);\r\n}\r\nstatic int valid_cc(const void *bc, int len, int cc)\r\n{\r\nwhile (len >= 0) {\r\nconst struct inet_diag_bc_op *op = bc;\r\nif (cc > len)\r\nreturn 0;\r\nif (cc == len)\r\nreturn 1;\r\nif (op->yes < 4 || op->yes & 3)\r\nreturn 0;\r\nlen -= op->yes;\r\nbc += op->yes;\r\n}\r\nreturn 0;\r\n}\r\nstatic bool valid_hostcond(const struct inet_diag_bc_op *op, int len,\r\nint *min_len)\r\n{\r\nint addr_len;\r\nstruct inet_diag_hostcond *cond;\r\n*min_len += sizeof(struct inet_diag_hostcond);\r\nif (len < *min_len)\r\nreturn false;\r\ncond = (struct inet_diag_hostcond *)(op + 1);\r\nswitch (cond->family) {\r\ncase AF_UNSPEC:\r\naddr_len = 0;\r\nbreak;\r\ncase AF_INET:\r\naddr_len = sizeof(struct in_addr);\r\nbreak;\r\ncase AF_INET6:\r\naddr_len = sizeof(struct in6_addr);\r\nbreak;\r\ndefault:\r\nreturn false;\r\n}\r\n*min_len += addr_len;\r\nif (len < *min_len)\r\nreturn false;\r\nif (cond->prefix_len > 8 * addr_len)\r\nreturn false;\r\nreturn true;\r\n}\r\nstatic inline bool valid_port_comparison(const struct inet_diag_bc_op *op,\r\nint len, int *min_len)\r\n{\r\n*min_len += sizeof(struct inet_diag_bc_op);\r\nif (len < *min_len)\r\nreturn false;\r\nreturn true;\r\n}\r\nstatic int inet_diag_bc_audit(const void *bytecode, int bytecode_len)\r\n{\r\nconst void *bc = bytecode;\r\nint len = bytecode_len;\r\nwhile (len > 0) {\r\nconst struct inet_diag_bc_op *op = bc;\r\nint min_len = sizeof(struct inet_diag_bc_op);\r\nswitch (op->code) {\r\ncase INET_DIAG_BC_S_COND:\r\ncase INET_DIAG_BC_D_COND:\r\nif (!valid_hostcond(bc, len, &min_len))\r\nreturn -EINVAL;\r\nbreak;\r\ncase INET_DIAG_BC_S_GE:\r\ncase INET_DIAG_BC_S_LE:\r\ncase INET_DIAG_BC_D_GE:\r\ncase INET_DIAG_BC_D_LE:\r\nif (!valid_port_comparison(bc, len, &min_len))\r\nreturn -EINVAL;\r\nbreak;\r\ncase INET_DIAG_BC_AUTO:\r\ncase INET_DIAG_BC_JMP:\r\ncase INET_DIAG_BC_NOP:\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (op->code != INET_DIAG_BC_NOP) {\r\nif (op->no < min_len || op->no > len + 4 || op->no & 3)\r\nreturn -EINVAL;\r\nif (op->no < len &&\r\n!valid_cc(bytecode, bytecode_len, len - op->no))\r\nreturn -EINVAL;\r\n}\r\nif (op->yes < min_len || op->yes > len + 4 || op->yes & 3)\r\nreturn -EINVAL;\r\nbc += op->yes;\r\nlen -= op->yes;\r\n}\r\nreturn len == 0 ? 0 : -EINVAL;\r\n}\r\nstatic int inet_csk_diag_dump(struct sock *sk,\r\nstruct sk_buff *skb,\r\nstruct netlink_callback *cb,\r\nstruct inet_diag_req_v2 *r,\r\nconst struct nlattr *bc)\r\n{\r\nif (!inet_diag_bc_sk(bc, sk))\r\nreturn 0;\r\nreturn inet_csk_diag_fill(sk, skb, r,\r\nsk_user_ns(NETLINK_CB(cb->skb).ssk),\r\nNETLINK_CB(cb->skb).portid,\r\ncb->nlh->nlmsg_seq, NLM_F_MULTI, cb->nlh);\r\n}\r\nstatic int inet_twsk_diag_dump(struct inet_timewait_sock *tw,\r\nstruct sk_buff *skb,\r\nstruct netlink_callback *cb,\r\nstruct inet_diag_req_v2 *r,\r\nconst struct nlattr *bc)\r\n{\r\nif (bc != NULL) {\r\nstruct inet_diag_entry entry;\r\nentry.family = tw->tw_family;\r\n#if IS_ENABLED(CONFIG_IPV6)\r\nif (tw->tw_family == AF_INET6) {\r\nstruct inet6_timewait_sock *tw6 =\r\ninet6_twsk((struct sock *)tw);\r\nentry.saddr = tw6->tw_v6_rcv_saddr.s6_addr32;\r\nentry.daddr = tw6->tw_v6_daddr.s6_addr32;\r\n} else\r\n#endif\r\n{\r\nentry.saddr = &tw->tw_rcv_saddr;\r\nentry.daddr = &tw->tw_daddr;\r\n}\r\nentry.sport = tw->tw_num;\r\nentry.dport = ntohs(tw->tw_dport);\r\nentry.userlocks = 0;\r\nif (!inet_diag_bc_run(bc, &entry))\r\nreturn 0;\r\n}\r\nreturn inet_twsk_diag_fill(tw, skb, r,\r\nNETLINK_CB(cb->skb).portid,\r\ncb->nlh->nlmsg_seq, NLM_F_MULTI, cb->nlh);\r\n}\r\nstatic inline void inet_diag_req_addrs(const struct sock *sk,\r\nconst struct request_sock *req,\r\nstruct inet_diag_entry *entry)\r\n{\r\nstruct inet_request_sock *ireq = inet_rsk(req);\r\n#if IS_ENABLED(CONFIG_IPV6)\r\nif (sk->sk_family == AF_INET6) {\r\nif (req->rsk_ops->family == AF_INET6) {\r\nentry->saddr = inet6_rsk(req)->loc_addr.s6_addr32;\r\nentry->daddr = inet6_rsk(req)->rmt_addr.s6_addr32;\r\n} else if (req->rsk_ops->family == AF_INET) {\r\nipv6_addr_set_v4mapped(ireq->loc_addr,\r\n&entry->saddr_storage);\r\nipv6_addr_set_v4mapped(ireq->rmt_addr,\r\n&entry->daddr_storage);\r\nentry->saddr = entry->saddr_storage.s6_addr32;\r\nentry->daddr = entry->daddr_storage.s6_addr32;\r\n}\r\n} else\r\n#endif\r\n{\r\nentry->saddr = &ireq->loc_addr;\r\nentry->daddr = &ireq->rmt_addr;\r\n}\r\n}\r\nstatic int inet_diag_fill_req(struct sk_buff *skb, struct sock *sk,\r\nstruct request_sock *req,\r\nstruct user_namespace *user_ns,\r\nu32 portid, u32 seq,\r\nconst struct nlmsghdr *unlh)\r\n{\r\nconst struct inet_request_sock *ireq = inet_rsk(req);\r\nstruct inet_sock *inet = inet_sk(sk);\r\nstruct inet_diag_msg *r;\r\nstruct nlmsghdr *nlh;\r\nlong tmo;\r\nnlh = nlmsg_put(skb, portid, seq, unlh->nlmsg_type, sizeof(*r),\r\nNLM_F_MULTI);\r\nif (!nlh)\r\nreturn -EMSGSIZE;\r\nr = nlmsg_data(nlh);\r\nr->idiag_family = sk->sk_family;\r\nr->idiag_state = TCP_SYN_RECV;\r\nr->idiag_timer = 1;\r\nr->idiag_retrans = req->num_retrans;\r\nr->id.idiag_if = sk->sk_bound_dev_if;\r\nsock_diag_save_cookie(req, r->id.idiag_cookie);\r\ntmo = req->expires - jiffies;\r\nif (tmo < 0)\r\ntmo = 0;\r\nr->id.idiag_sport = inet->inet_sport;\r\nr->id.idiag_dport = ireq->rmt_port;\r\nr->id.idiag_src[0] = ireq->loc_addr;\r\nr->id.idiag_dst[0] = ireq->rmt_addr;\r\nr->idiag_expires = jiffies_to_msecs(tmo);\r\nr->idiag_rqueue = 0;\r\nr->idiag_wqueue = 0;\r\nr->idiag_uid = from_kuid_munged(user_ns, sock_i_uid(sk));\r\nr->idiag_inode = 0;\r\n#if IS_ENABLED(CONFIG_IPV6)\r\nif (r->idiag_family == AF_INET6) {\r\nstruct inet_diag_entry entry;\r\ninet_diag_req_addrs(sk, req, &entry);\r\nmemcpy(r->id.idiag_src, entry.saddr, sizeof(struct in6_addr));\r\nmemcpy(r->id.idiag_dst, entry.daddr, sizeof(struct in6_addr));\r\n}\r\n#endif\r\nreturn nlmsg_end(skb, nlh);\r\n}\r\nstatic int inet_diag_dump_reqs(struct sk_buff *skb, struct sock *sk,\r\nstruct netlink_callback *cb,\r\nstruct inet_diag_req_v2 *r,\r\nconst struct nlattr *bc)\r\n{\r\nstruct inet_diag_entry entry;\r\nstruct inet_connection_sock *icsk = inet_csk(sk);\r\nstruct listen_sock *lopt;\r\nstruct inet_sock *inet = inet_sk(sk);\r\nint j, s_j;\r\nint reqnum, s_reqnum;\r\nint err = 0;\r\ns_j = cb->args[3];\r\ns_reqnum = cb->args[4];\r\nif (s_j > 0)\r\ns_j--;\r\nentry.family = sk->sk_family;\r\nread_lock_bh(&icsk->icsk_accept_queue.syn_wait_lock);\r\nlopt = icsk->icsk_accept_queue.listen_opt;\r\nif (!lopt || !lopt->qlen)\r\ngoto out;\r\nif (bc != NULL) {\r\nentry.sport = inet->inet_num;\r\nentry.userlocks = sk->sk_userlocks;\r\n}\r\nfor (j = s_j; j < lopt->nr_table_entries; j++) {\r\nstruct request_sock *req, *head = lopt->syn_table[j];\r\nreqnum = 0;\r\nfor (req = head; req; reqnum++, req = req->dl_next) {\r\nstruct inet_request_sock *ireq = inet_rsk(req);\r\nif (reqnum < s_reqnum)\r\ncontinue;\r\nif (r->id.idiag_dport != ireq->rmt_port &&\r\nr->id.idiag_dport)\r\ncontinue;\r\nif (bc) {\r\ninet_diag_req_addrs(sk, req, &entry);\r\nentry.dport = ntohs(ireq->rmt_port);\r\nif (!inet_diag_bc_run(bc, &entry))\r\ncontinue;\r\n}\r\nerr = inet_diag_fill_req(skb, sk, req,\r\nsk_user_ns(NETLINK_CB(cb->skb).ssk),\r\nNETLINK_CB(cb->skb).portid,\r\ncb->nlh->nlmsg_seq, cb->nlh);\r\nif (err < 0) {\r\ncb->args[3] = j + 1;\r\ncb->args[4] = reqnum;\r\ngoto out;\r\n}\r\n}\r\ns_reqnum = 0;\r\n}\r\nout:\r\nread_unlock_bh(&icsk->icsk_accept_queue.syn_wait_lock);\r\nreturn err;\r\n}\r\nvoid inet_diag_dump_icsk(struct inet_hashinfo *hashinfo, struct sk_buff *skb,\r\nstruct netlink_callback *cb, struct inet_diag_req_v2 *r, struct nlattr *bc)\r\n{\r\nint i, num;\r\nint s_i, s_num;\r\nstruct net *net = sock_net(skb->sk);\r\ns_i = cb->args[1];\r\ns_num = num = cb->args[2];\r\nif (cb->args[0] == 0) {\r\nif (!(r->idiag_states & (TCPF_LISTEN | TCPF_SYN_RECV)))\r\ngoto skip_listen_ht;\r\nfor (i = s_i; i < INET_LHTABLE_SIZE; i++) {\r\nstruct sock *sk;\r\nstruct hlist_nulls_node *node;\r\nstruct inet_listen_hashbucket *ilb;\r\nnum = 0;\r\nilb = &hashinfo->listening_hash[i];\r\nspin_lock_bh(&ilb->lock);\r\nsk_nulls_for_each(sk, node, &ilb->head) {\r\nstruct inet_sock *inet = inet_sk(sk);\r\nif (!net_eq(sock_net(sk), net))\r\ncontinue;\r\nif (num < s_num) {\r\nnum++;\r\ncontinue;\r\n}\r\nif (r->sdiag_family != AF_UNSPEC &&\r\nsk->sk_family != r->sdiag_family)\r\ngoto next_listen;\r\nif (r->id.idiag_sport != inet->inet_sport &&\r\nr->id.idiag_sport)\r\ngoto next_listen;\r\nif (!(r->idiag_states & TCPF_LISTEN) ||\r\nr->id.idiag_dport ||\r\ncb->args[3] > 0)\r\ngoto syn_recv;\r\nif (inet_csk_diag_dump(sk, skb, cb, r, bc) < 0) {\r\nspin_unlock_bh(&ilb->lock);\r\ngoto done;\r\n}\r\nsyn_recv:\r\nif (!(r->idiag_states & TCPF_SYN_RECV))\r\ngoto next_listen;\r\nif (inet_diag_dump_reqs(skb, sk, cb, r, bc) < 0) {\r\nspin_unlock_bh(&ilb->lock);\r\ngoto done;\r\n}\r\nnext_listen:\r\ncb->args[3] = 0;\r\ncb->args[4] = 0;\r\n++num;\r\n}\r\nspin_unlock_bh(&ilb->lock);\r\ns_num = 0;\r\ncb->args[3] = 0;\r\ncb->args[4] = 0;\r\n}\r\nskip_listen_ht:\r\ncb->args[0] = 1;\r\ns_i = num = s_num = 0;\r\n}\r\nif (!(r->idiag_states & ~(TCPF_LISTEN | TCPF_SYN_RECV)))\r\ngoto out;\r\nfor (i = s_i; i <= hashinfo->ehash_mask; i++) {\r\nstruct inet_ehash_bucket *head = &hashinfo->ehash[i];\r\nspinlock_t *lock = inet_ehash_lockp(hashinfo, i);\r\nstruct sock *sk;\r\nstruct hlist_nulls_node *node;\r\nnum = 0;\r\nif (hlist_nulls_empty(&head->chain) &&\r\nhlist_nulls_empty(&head->twchain))\r\ncontinue;\r\nif (i > s_i)\r\ns_num = 0;\r\nspin_lock_bh(lock);\r\nsk_nulls_for_each(sk, node, &head->chain) {\r\nstruct inet_sock *inet = inet_sk(sk);\r\nif (!net_eq(sock_net(sk), net))\r\ncontinue;\r\nif (num < s_num)\r\ngoto next_normal;\r\nif (!(r->idiag_states & (1 << sk->sk_state)))\r\ngoto next_normal;\r\nif (r->sdiag_family != AF_UNSPEC &&\r\nsk->sk_family != r->sdiag_family)\r\ngoto next_normal;\r\nif (r->id.idiag_sport != inet->inet_sport &&\r\nr->id.idiag_sport)\r\ngoto next_normal;\r\nif (r->id.idiag_dport != inet->inet_dport &&\r\nr->id.idiag_dport)\r\ngoto next_normal;\r\nif (inet_csk_diag_dump(sk, skb, cb, r, bc) < 0) {\r\nspin_unlock_bh(lock);\r\ngoto done;\r\n}\r\nnext_normal:\r\n++num;\r\n}\r\nif (r->idiag_states & TCPF_TIME_WAIT) {\r\nstruct inet_timewait_sock *tw;\r\ninet_twsk_for_each(tw, node,\r\n&head->twchain) {\r\nif (!net_eq(twsk_net(tw), net))\r\ncontinue;\r\nif (num < s_num)\r\ngoto next_dying;\r\nif (r->sdiag_family != AF_UNSPEC &&\r\ntw->tw_family != r->sdiag_family)\r\ngoto next_dying;\r\nif (r->id.idiag_sport != tw->tw_sport &&\r\nr->id.idiag_sport)\r\ngoto next_dying;\r\nif (r->id.idiag_dport != tw->tw_dport &&\r\nr->id.idiag_dport)\r\ngoto next_dying;\r\nif (inet_twsk_diag_dump(tw, skb, cb, r, bc) < 0) {\r\nspin_unlock_bh(lock);\r\ngoto done;\r\n}\r\nnext_dying:\r\n++num;\r\n}\r\n}\r\nspin_unlock_bh(lock);\r\n}\r\ndone:\r\ncb->args[1] = i;\r\ncb->args[2] = num;\r\nout:\r\n;\r\n}\r\nstatic int __inet_diag_dump(struct sk_buff *skb, struct netlink_callback *cb,\r\nstruct inet_diag_req_v2 *r, struct nlattr *bc)\r\n{\r\nconst struct inet_diag_handler *handler;\r\nint err = 0;\r\nhandler = inet_diag_lock_handler(r->sdiag_protocol);\r\nif (!IS_ERR(handler))\r\nhandler->dump(skb, cb, r, bc);\r\nelse\r\nerr = PTR_ERR(handler);\r\ninet_diag_unlock_handler(handler);\r\nreturn err ? : skb->len;\r\n}\r\nstatic int inet_diag_dump(struct sk_buff *skb, struct netlink_callback *cb)\r\n{\r\nstruct nlattr *bc = NULL;\r\nint hdrlen = sizeof(struct inet_diag_req_v2);\r\nif (nlmsg_attrlen(cb->nlh, hdrlen))\r\nbc = nlmsg_find_attr(cb->nlh, hdrlen, INET_DIAG_REQ_BYTECODE);\r\nreturn __inet_diag_dump(skb, cb, nlmsg_data(cb->nlh), bc);\r\n}\r\nstatic inline int inet_diag_type2proto(int type)\r\n{\r\nswitch (type) {\r\ncase TCPDIAG_GETSOCK:\r\nreturn IPPROTO_TCP;\r\ncase DCCPDIAG_GETSOCK:\r\nreturn IPPROTO_DCCP;\r\ndefault:\r\nreturn 0;\r\n}\r\n}\r\nstatic int inet_diag_dump_compat(struct sk_buff *skb, struct netlink_callback *cb)\r\n{\r\nstruct inet_diag_req *rc = nlmsg_data(cb->nlh);\r\nstruct inet_diag_req_v2 req;\r\nstruct nlattr *bc = NULL;\r\nint hdrlen = sizeof(struct inet_diag_req);\r\nreq.sdiag_family = AF_UNSPEC;\r\nreq.sdiag_protocol = inet_diag_type2proto(cb->nlh->nlmsg_type);\r\nreq.idiag_ext = rc->idiag_ext;\r\nreq.idiag_states = rc->idiag_states;\r\nreq.id = rc->id;\r\nif (nlmsg_attrlen(cb->nlh, hdrlen))\r\nbc = nlmsg_find_attr(cb->nlh, hdrlen, INET_DIAG_REQ_BYTECODE);\r\nreturn __inet_diag_dump(skb, cb, &req, bc);\r\n}\r\nstatic int inet_diag_get_exact_compat(struct sk_buff *in_skb,\r\nconst struct nlmsghdr *nlh)\r\n{\r\nstruct inet_diag_req *rc = nlmsg_data(nlh);\r\nstruct inet_diag_req_v2 req;\r\nreq.sdiag_family = rc->idiag_family;\r\nreq.sdiag_protocol = inet_diag_type2proto(nlh->nlmsg_type);\r\nreq.idiag_ext = rc->idiag_ext;\r\nreq.idiag_states = rc->idiag_states;\r\nreq.id = rc->id;\r\nreturn inet_diag_get_exact(in_skb, nlh, &req);\r\n}\r\nstatic int inet_diag_rcv_msg_compat(struct sk_buff *skb, struct nlmsghdr *nlh)\r\n{\r\nint hdrlen = sizeof(struct inet_diag_req);\r\nstruct net *net = sock_net(skb->sk);\r\nif (nlh->nlmsg_type >= INET_DIAG_GETSOCK_MAX ||\r\nnlmsg_len(nlh) < hdrlen)\r\nreturn -EINVAL;\r\nif (nlh->nlmsg_flags & NLM_F_DUMP) {\r\nif (nlmsg_attrlen(nlh, hdrlen)) {\r\nstruct nlattr *attr;\r\nattr = nlmsg_find_attr(nlh, hdrlen,\r\nINET_DIAG_REQ_BYTECODE);\r\nif (attr == NULL ||\r\nnla_len(attr) < sizeof(struct inet_diag_bc_op) ||\r\ninet_diag_bc_audit(nla_data(attr), nla_len(attr)))\r\nreturn -EINVAL;\r\n}\r\n{\r\nstruct netlink_dump_control c = {\r\n.dump = inet_diag_dump_compat,\r\n};\r\nreturn netlink_dump_start(net->diag_nlsk, skb, nlh, &c);\r\n}\r\n}\r\nreturn inet_diag_get_exact_compat(skb, nlh);\r\n}\r\nstatic int inet_diag_handler_dump(struct sk_buff *skb, struct nlmsghdr *h)\r\n{\r\nint hdrlen = sizeof(struct inet_diag_req_v2);\r\nstruct net *net = sock_net(skb->sk);\r\nif (nlmsg_len(h) < hdrlen)\r\nreturn -EINVAL;\r\nif (h->nlmsg_flags & NLM_F_DUMP) {\r\nif (nlmsg_attrlen(h, hdrlen)) {\r\nstruct nlattr *attr;\r\nattr = nlmsg_find_attr(h, hdrlen,\r\nINET_DIAG_REQ_BYTECODE);\r\nif (attr == NULL ||\r\nnla_len(attr) < sizeof(struct inet_diag_bc_op) ||\r\ninet_diag_bc_audit(nla_data(attr), nla_len(attr)))\r\nreturn -EINVAL;\r\n}\r\n{\r\nstruct netlink_dump_control c = {\r\n.dump = inet_diag_dump,\r\n};\r\nreturn netlink_dump_start(net->diag_nlsk, skb, h, &c);\r\n}\r\n}\r\nreturn inet_diag_get_exact(skb, h, nlmsg_data(h));\r\n}\r\nint inet_diag_register(const struct inet_diag_handler *h)\r\n{\r\nconst __u16 type = h->idiag_type;\r\nint err = -EINVAL;\r\nif (type >= IPPROTO_MAX)\r\ngoto out;\r\nmutex_lock(&inet_diag_table_mutex);\r\nerr = -EEXIST;\r\nif (inet_diag_table[type] == NULL) {\r\ninet_diag_table[type] = h;\r\nerr = 0;\r\n}\r\nmutex_unlock(&inet_diag_table_mutex);\r\nout:\r\nreturn err;\r\n}\r\nvoid inet_diag_unregister(const struct inet_diag_handler *h)\r\n{\r\nconst __u16 type = h->idiag_type;\r\nif (type >= IPPROTO_MAX)\r\nreturn;\r\nmutex_lock(&inet_diag_table_mutex);\r\ninet_diag_table[type] = NULL;\r\nmutex_unlock(&inet_diag_table_mutex);\r\n}\r\nstatic int __init inet_diag_init(void)\r\n{\r\nconst int inet_diag_table_size = (IPPROTO_MAX *\r\nsizeof(struct inet_diag_handler *));\r\nint err = -ENOMEM;\r\ninet_diag_table = kzalloc(inet_diag_table_size, GFP_KERNEL);\r\nif (!inet_diag_table)\r\ngoto out;\r\nerr = sock_diag_register(&inet_diag_handler);\r\nif (err)\r\ngoto out_free_nl;\r\nerr = sock_diag_register(&inet6_diag_handler);\r\nif (err)\r\ngoto out_free_inet;\r\nsock_diag_register_inet_compat(inet_diag_rcv_msg_compat);\r\nout:\r\nreturn err;\r\nout_free_inet:\r\nsock_diag_unregister(&inet_diag_handler);\r\nout_free_nl:\r\nkfree(inet_diag_table);\r\ngoto out;\r\n}\r\nstatic void __exit inet_diag_exit(void)\r\n{\r\nsock_diag_unregister(&inet6_diag_handler);\r\nsock_diag_unregister(&inet_diag_handler);\r\nsock_diag_unregister_inet_compat(inet_diag_rcv_msg_compat);\r\nkfree(inet_diag_table);\r\n}
