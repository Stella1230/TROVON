static void reset_counters(struct comedi_device *dev)\r\n{\r\noutw(0xFFC2, dev->iobase + AM9513A_COM_REG);\r\noutw(0xFF02, dev->iobase + AM9513A_COM_REG);\r\noutw(0x4, dev->iobase + AM9513A_DATA_REG);\r\noutw(0xFF0A, dev->iobase + AM9513A_COM_REG);\r\noutw(0x3, dev->iobase + AM9513A_DATA_REG);\r\noutw(0xFF42, dev->iobase + AM9513A_COM_REG);\r\noutw(0xFF42, dev->iobase + AM9513A_COM_REG);\r\noutw(0xFFC4, dev->iobase + AM9513A_COM_REG);\r\noutw(0xFF03, dev->iobase + AM9513A_COM_REG);\r\noutw(0x4, dev->iobase + AM9513A_DATA_REG);\r\noutw(0xFF0B, dev->iobase + AM9513A_COM_REG);\r\noutw(0x3, dev->iobase + AM9513A_DATA_REG);\r\noutw(0xFF44, dev->iobase + AM9513A_COM_REG);\r\noutw(0xFF44, dev->iobase + AM9513A_COM_REG);\r\noutw(0xFFC8, dev->iobase + AM9513A_COM_REG);\r\noutw(0xFF04, dev->iobase + AM9513A_COM_REG);\r\noutw(0x4, dev->iobase + AM9513A_DATA_REG);\r\noutw(0xFF0C, dev->iobase + AM9513A_COM_REG);\r\noutw(0x3, dev->iobase + AM9513A_DATA_REG);\r\noutw(0xFF48, dev->iobase + AM9513A_COM_REG);\r\noutw(0xFF48, dev->iobase + AM9513A_COM_REG);\r\noutw(0xFFD0, dev->iobase + AM9513A_COM_REG);\r\noutw(0xFF05, dev->iobase + AM9513A_COM_REG);\r\noutw(0x4, dev->iobase + AM9513A_DATA_REG);\r\noutw(0xFF0D, dev->iobase + AM9513A_COM_REG);\r\noutw(0x3, dev->iobase + AM9513A_DATA_REG);\r\noutw(0xFF50, dev->iobase + AM9513A_COM_REG);\r\noutw(0xFF50, dev->iobase + AM9513A_COM_REG);\r\noutw(0, dev->iobase + AD_CLEAR_REG);\r\n}\r\nstatic void reset_atmio16d(struct comedi_device *dev)\r\n{\r\nstruct atmio16d_private *devpriv = dev->private;\r\nint i;\r\noutw(0, dev->iobase + COM_REG_1);\r\noutw(0, dev->iobase + COM_REG_2);\r\noutw(0, dev->iobase + MUX_GAIN_REG);\r\noutw(0xFFFF, dev->iobase + AM9513A_COM_REG);\r\noutw(0xFFEF, dev->iobase + AM9513A_COM_REG);\r\noutw(0xFF17, dev->iobase + AM9513A_COM_REG);\r\noutw(0xF000, dev->iobase + AM9513A_DATA_REG);\r\nfor (i = 1; i <= 5; ++i) {\r\noutw(0xFF00 + i, dev->iobase + AM9513A_COM_REG);\r\noutw(0x0004, dev->iobase + AM9513A_DATA_REG);\r\noutw(0xFF08 + i, dev->iobase + AM9513A_COM_REG);\r\noutw(0x3, dev->iobase + AM9513A_DATA_REG);\r\n}\r\noutw(0xFF5F, dev->iobase + AM9513A_COM_REG);\r\noutw(0, dev->iobase + AD_CLEAR_REG);\r\noutw(0, dev->iobase + INT2CLR_REG);\r\ndevpriv->com_reg_1_state |= 1;\r\noutw(devpriv->com_reg_1_state, dev->iobase + COM_REG_1);\r\ndevpriv->adc_coding = adc_straight;\r\noutw(2048, dev->iobase + DAC0_REG);\r\noutw(2048, dev->iobase + DAC1_REG);\r\n}\r\nstatic irqreturn_t atmio16d_interrupt(int irq, void *d)\r\n{\r\nstruct comedi_device *dev = d;\r\nstruct comedi_subdevice *s = &dev->subdevices[0];\r\ncomedi_buf_put(s->async, inw(dev->iobase + AD_FIFO_REG));\r\ncomedi_event(dev, s);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int atmio16d_ai_cmdtest(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_cmd *cmd)\r\n{\r\nint err = 0;\r\nerr |= cfc_check_trigger_src(&cmd->start_src, TRIG_NOW);\r\nerr |= cfc_check_trigger_src(&cmd->scan_begin_src,\r\nTRIG_FOLLOW | TRIG_TIMER);\r\nerr |= cfc_check_trigger_src(&cmd->convert_src, TRIG_TIMER);\r\nerr |= cfc_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);\r\nerr |= cfc_check_trigger_src(&cmd->stop_src, TRIG_COUNT | TRIG_NONE);\r\nif (err)\r\nreturn 1;\r\nerr |= cfc_check_trigger_is_unique(cmd->scan_begin_src);\r\nerr |= cfc_check_trigger_is_unique(cmd->stop_src);\r\nif (err)\r\nreturn 2;\r\nerr |= cfc_check_trigger_arg_is(&cmd->start_arg, 0);\r\nif (cmd->scan_begin_src == TRIG_FOLLOW) {\r\nerr |= cfc_check_trigger_arg_is(&cmd->scan_begin_arg, 0);\r\n} else {\r\n#if 0\r\nerr |= cfc_check_trigger_arg_is(&cmd->scan_begin_arg, 0);\r\n#endif\r\n}\r\nerr |= cfc_check_trigger_arg_min(&cmd->convert_arg, 10000);\r\n#if 0\r\nerr |= cfc_check_trigger_arg_max(&cmd->convert_arg, SLOWEST_TIMER);\r\n#endif\r\nerr |= cfc_check_trigger_arg_is(&cmd->scan_end_arg, cmd->chanlist_len);\r\nif (cmd->stop_src == TRIG_COUNT) {\r\n} else {\r\nerr |= cfc_check_trigger_arg_is(&cmd->stop_arg, 0);\r\n}\r\nif (err)\r\nreturn 3;\r\nreturn 0;\r\n}\r\nstatic int atmio16d_ai_cmd(struct comedi_device *dev,\r\nstruct comedi_subdevice *s)\r\n{\r\nstruct atmio16d_private *devpriv = dev->private;\r\nstruct comedi_cmd *cmd = &s->async->cmd;\r\nunsigned int timer, base_clock;\r\nunsigned int sample_count, tmp, chan, gain;\r\nint i;\r\nreset_counters(dev);\r\ns->async->cur_chan = 0;\r\nif (cmd->chanlist_len < 2) {\r\ndevpriv->com_reg_1_state &= ~COMREG1_SCANEN;\r\noutw(devpriv->com_reg_1_state, dev->iobase + COM_REG_1);\r\n} else {\r\ndevpriv->com_reg_1_state |= COMREG1_SCANEN;\r\ndevpriv->com_reg_2_state |= COMREG2_SCN2;\r\noutw(devpriv->com_reg_1_state, dev->iobase + COM_REG_1);\r\noutw(devpriv->com_reg_2_state, dev->iobase + COM_REG_2);\r\n}\r\nfor (i = 0; i < cmd->chanlist_len; ++i) {\r\nchan = CR_CHAN(cmd->chanlist[i]);\r\ngain = CR_RANGE(cmd->chanlist[i]);\r\noutw(i, dev->iobase + MUX_CNTR_REG);\r\ntmp = chan | (gain << 6);\r\nif (i == cmd->scan_end_arg - 1)\r\ntmp |= 0x0010;\r\noutw(tmp, dev->iobase + MUX_GAIN_REG);\r\n}\r\nif (cmd->convert_arg < 65536000) {\r\nbase_clock = CLOCK_1_MHZ;\r\ntimer = cmd->convert_arg / 1000;\r\n} else if (cmd->convert_arg < 655360000) {\r\nbase_clock = CLOCK_100_KHZ;\r\ntimer = cmd->convert_arg / 10000;\r\n} else if (cmd->convert_arg <= 0xffffffff ) {\r\nbase_clock = CLOCK_10_KHZ;\r\ntimer = cmd->convert_arg / 100000;\r\n} else if (cmd->convert_arg <= 0xffffffff ) {\r\nbase_clock = CLOCK_1_KHZ;\r\ntimer = cmd->convert_arg / 1000000;\r\n}\r\noutw(0xFF03, dev->iobase + AM9513A_COM_REG);\r\noutw(base_clock, dev->iobase + AM9513A_DATA_REG);\r\noutw(0xFF0B, dev->iobase + AM9513A_COM_REG);\r\noutw(0x2, dev->iobase + AM9513A_DATA_REG);\r\noutw(0xFF44, dev->iobase + AM9513A_COM_REG);\r\noutw(0xFFF3, dev->iobase + AM9513A_COM_REG);\r\noutw(timer, dev->iobase + AM9513A_DATA_REG);\r\noutw(0xFF24, dev->iobase + AM9513A_COM_REG);\r\nsample_count = cmd->stop_arg * cmd->scan_end_arg;\r\noutw(0xFF04, dev->iobase + AM9513A_COM_REG);\r\noutw(0x1025, dev->iobase + AM9513A_DATA_REG);\r\noutw(0xFF0C, dev->iobase + AM9513A_COM_REG);\r\nif (sample_count < 65536) {\r\noutw(sample_count, dev->iobase + AM9513A_DATA_REG);\r\noutw(0xFF48, dev->iobase + AM9513A_COM_REG);\r\noutw(0xFFF4, dev->iobase + AM9513A_COM_REG);\r\noutw(0xFF28, dev->iobase + AM9513A_COM_REG);\r\ndevpriv->com_reg_1_state &= ~COMREG1_1632CNT;\r\noutw(devpriv->com_reg_1_state, dev->iobase + COM_REG_1);\r\n} else {\r\ntmp = sample_count & 0xFFFF;\r\nif (tmp)\r\noutw(tmp - 1, dev->iobase + AM9513A_DATA_REG);\r\nelse\r\noutw(0xFFFF, dev->iobase + AM9513A_DATA_REG);\r\noutw(0xFF48, dev->iobase + AM9513A_COM_REG);\r\noutw(0, dev->iobase + AM9513A_DATA_REG);\r\noutw(0xFF28, dev->iobase + AM9513A_COM_REG);\r\noutw(0xFF05, dev->iobase + AM9513A_COM_REG);\r\noutw(0x25, dev->iobase + AM9513A_DATA_REG);\r\noutw(0xFF0D, dev->iobase + AM9513A_COM_REG);\r\ntmp = sample_count & 0xFFFF;\r\nif ((tmp == 0) || (tmp == 1)) {\r\noutw((sample_count >> 16) & 0xFFFF,\r\ndev->iobase + AM9513A_DATA_REG);\r\n} else {\r\noutw(((sample_count >> 16) & 0xFFFF) + 1,\r\ndev->iobase + AM9513A_DATA_REG);\r\n}\r\noutw(0xFF70, dev->iobase + AM9513A_COM_REG);\r\ndevpriv->com_reg_1_state |= COMREG1_1632CNT;\r\noutw(devpriv->com_reg_1_state, dev->iobase + COM_REG_1);\r\n}\r\nif (cmd->chanlist_len > 1) {\r\nif (cmd->scan_begin_arg < 65536000) {\r\nbase_clock = CLOCK_1_MHZ;\r\ntimer = cmd->scan_begin_arg / 1000;\r\n} else if (cmd->scan_begin_arg < 655360000) {\r\nbase_clock = CLOCK_100_KHZ;\r\ntimer = cmd->scan_begin_arg / 10000;\r\n} else if (cmd->scan_begin_arg < 0xffffffff ) {\r\nbase_clock = CLOCK_10_KHZ;\r\ntimer = cmd->scan_begin_arg / 100000;\r\n} else if (cmd->scan_begin_arg < 0xffffffff ) {\r\nbase_clock = CLOCK_1_KHZ;\r\ntimer = cmd->scan_begin_arg / 1000000;\r\n}\r\noutw(0xFF02, dev->iobase + AM9513A_COM_REG);\r\noutw(base_clock, dev->iobase + AM9513A_DATA_REG);\r\noutw(0xFF0A, dev->iobase + AM9513A_COM_REG);\r\noutw(0x2, dev->iobase + AM9513A_DATA_REG);\r\noutw(0xFF42, dev->iobase + AM9513A_COM_REG);\r\noutw(0xFFF2, dev->iobase + AM9513A_COM_REG);\r\noutw(timer, dev->iobase + AM9513A_DATA_REG);\r\noutw(0xFF22, dev->iobase + AM9513A_COM_REG);\r\n}\r\noutw(0, dev->iobase + AD_CLEAR_REG);\r\noutw(0, dev->iobase + MUX_CNTR_REG);\r\noutw(0, dev->iobase + INT2CLR_REG);\r\ndevpriv->com_reg_1_state |= COMREG1_DAQEN;\r\noutw(devpriv->com_reg_1_state, dev->iobase + COM_REG_1);\r\ndevpriv->com_reg_1_state |= COMREG1_CONVINTEN;\r\ndevpriv->com_reg_2_state |= COMREG2_INTEN;\r\noutw(devpriv->com_reg_1_state, dev->iobase + COM_REG_1);\r\noutw(devpriv->com_reg_2_state, dev->iobase + COM_REG_2);\r\noutw(0, dev->iobase + START_DAQ_REG);\r\nreturn 0;\r\n}\r\nstatic int atmio16d_ai_cancel(struct comedi_device *dev,\r\nstruct comedi_subdevice *s)\r\n{\r\nreset_atmio16d(dev);\r\nreturn 0;\r\n}\r\nstatic int atmio16d_ai_insn_read(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nstruct atmio16d_private *devpriv = dev->private;\r\nint i, t;\r\nint chan;\r\nint gain;\r\nint status;\r\nchan = CR_CHAN(insn->chanspec);\r\ngain = CR_RANGE(insn->chanspec);\r\noutw(chan | (gain << 6), dev->iobase + MUX_GAIN_REG);\r\nfor (i = 0; i < insn->n; i++) {\r\noutw(0, dev->iobase + START_CONVERT_REG);\r\nfor (t = 0; t < ATMIO16D_TIMEOUT; t++) {\r\nstatus = inw(dev->iobase + STAT_REG);\r\nif (status & STAT_AD_CONVAVAIL) {\r\ndata[i] = inw(dev->iobase + AD_FIFO_REG);\r\nif (devpriv->adc_coding == adc_2comp)\r\ndata[i] ^= 0x800;\r\nbreak;\r\n}\r\nif (status & STAT_AD_OVERFLOW) {\r\nprintk(KERN_INFO "atmio16d: a/d FIFO overflow\n");\r\noutw(0, dev->iobase + AD_CLEAR_REG);\r\nreturn -ETIME;\r\n}\r\n}\r\nif (t == ATMIO16D_TIMEOUT) {\r\nprintk(KERN_INFO "atmio16d: timeout\n");\r\nreturn -ETIME;\r\n}\r\n}\r\nreturn i;\r\n}\r\nstatic int atmio16d_ao_insn_read(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nstruct atmio16d_private *devpriv = dev->private;\r\nint i;\r\nfor (i = 0; i < insn->n; i++)\r\ndata[i] = devpriv->ao_readback[CR_CHAN(insn->chanspec)];\r\nreturn i;\r\n}\r\nstatic int atmio16d_ao_insn_write(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nstruct atmio16d_private *devpriv = dev->private;\r\nint i;\r\nint chan;\r\nint d;\r\nchan = CR_CHAN(insn->chanspec);\r\nfor (i = 0; i < insn->n; i++) {\r\nd = data[i];\r\nswitch (chan) {\r\ncase 0:\r\nif (devpriv->dac0_coding == dac_2comp)\r\nd ^= 0x800;\r\noutw(d, dev->iobase + DAC0_REG);\r\nbreak;\r\ncase 1:\r\nif (devpriv->dac1_coding == dac_2comp)\r\nd ^= 0x800;\r\noutw(d, dev->iobase + DAC1_REG);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\ndevpriv->ao_readback[chan] = data[i];\r\n}\r\nreturn i;\r\n}\r\nstatic int atmio16d_dio_insn_bits(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nif (data[0]) {\r\ns->state &= ~data[0];\r\ns->state |= (data[0] | data[1]);\r\noutw(s->state, dev->iobase + MIO_16_DIG_OUT_REG);\r\n}\r\ndata[1] = inw(dev->iobase + MIO_16_DIG_IN_REG);\r\nreturn insn->n;\r\n}\r\nstatic int atmio16d_dio_insn_config(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nstruct atmio16d_private *devpriv = dev->private;\r\nint i;\r\nint mask;\r\nfor (i = 0; i < insn->n; i++) {\r\nmask = (CR_CHAN(insn->chanspec) < 4) ? 0x0f : 0xf0;\r\ns->io_bits &= ~mask;\r\nif (data[i])\r\ns->io_bits |= mask;\r\n}\r\ndevpriv->com_reg_2_state &= ~(COMREG2_DOUTEN0 | COMREG2_DOUTEN1);\r\nif (s->io_bits & 0x0f)\r\ndevpriv->com_reg_2_state |= COMREG2_DOUTEN0;\r\nif (s->io_bits & 0xf0)\r\ndevpriv->com_reg_2_state |= COMREG2_DOUTEN1;\r\noutw(devpriv->com_reg_2_state, dev->iobase + COM_REG_2);\r\nreturn i;\r\n}\r\nstatic int atmio16d_attach(struct comedi_device *dev,\r\nstruct comedi_devconfig *it)\r\n{\r\nconst struct atmio16_board_t *board = comedi_board(dev);\r\nstruct atmio16d_private *devpriv;\r\nunsigned int irq;\r\nunsigned long iobase;\r\nint ret;\r\nstruct comedi_subdevice *s;\r\niobase = it->options[0];\r\nprintk(KERN_INFO "comedi%d: atmio16d: 0x%04lx ", dev->minor, iobase);\r\nif (!request_region(iobase, ATMIO16D_SIZE, "ni_atmio16d")) {\r\nprintk("I/O port conflict\n");\r\nreturn -EIO;\r\n}\r\ndev->iobase = iobase;\r\ndev->board_name = board->name;\r\nret = comedi_alloc_subdevices(dev, 4);\r\nif (ret)\r\nreturn ret;\r\ndevpriv = kzalloc(sizeof(*devpriv), GFP_KERNEL);\r\nif (!devpriv)\r\nreturn -ENOMEM;\r\ndev->private = devpriv;\r\nreset_atmio16d(dev);\r\nirq = it->options[1];\r\nif (irq) {\r\nret = request_irq(irq, atmio16d_interrupt, 0, "atmio16d", dev);\r\nif (ret < 0) {\r\nprintk(KERN_INFO "failed to allocate irq %u\n", irq);\r\nreturn ret;\r\n}\r\ndev->irq = irq;\r\nprintk(KERN_INFO "( irq = %u )\n", irq);\r\n} else {\r\nprintk(KERN_INFO "( no irq )");\r\n}\r\ndevpriv->adc_mux = it->options[5];\r\ndevpriv->adc_range = it->options[6];\r\ndevpriv->dac0_range = it->options[7];\r\ndevpriv->dac0_reference = it->options[8];\r\ndevpriv->dac0_coding = it->options[9];\r\ndevpriv->dac1_range = it->options[10];\r\ndevpriv->dac1_reference = it->options[11];\r\ndevpriv->dac1_coding = it->options[12];\r\ns = &dev->subdevices[0];\r\ndev->read_subdev = s;\r\ns->type = COMEDI_SUBD_AI;\r\ns->subdev_flags = SDF_READABLE | SDF_GROUND | SDF_CMD_READ;\r\ns->n_chan = (devpriv->adc_mux ? 16 : 8);\r\ns->len_chanlist = 16;\r\ns->insn_read = atmio16d_ai_insn_read;\r\ns->do_cmdtest = atmio16d_ai_cmdtest;\r\ns->do_cmd = atmio16d_ai_cmd;\r\ns->cancel = atmio16d_ai_cancel;\r\ns->maxdata = 0xfff;\r\nswitch (devpriv->adc_range) {\r\ncase adc_bipolar10:\r\ns->range_table = &range_atmio16d_ai_10_bipolar;\r\nbreak;\r\ncase adc_bipolar5:\r\ns->range_table = &range_atmio16d_ai_5_bipolar;\r\nbreak;\r\ncase adc_unipolar10:\r\ns->range_table = &range_atmio16d_ai_unipolar;\r\nbreak;\r\n}\r\ns = &dev->subdevices[1];\r\ns->type = COMEDI_SUBD_AO;\r\ns->subdev_flags = SDF_WRITABLE;\r\ns->n_chan = 2;\r\ns->insn_read = atmio16d_ao_insn_read;\r\ns->insn_write = atmio16d_ao_insn_write;\r\ns->maxdata = 0xfff;\r\ns->range_table_list = devpriv->ao_range_type_list;\r\nswitch (devpriv->dac0_range) {\r\ncase dac_bipolar:\r\ndevpriv->ao_range_type_list[0] = &range_bipolar10;\r\nbreak;\r\ncase dac_unipolar:\r\ndevpriv->ao_range_type_list[0] = &range_unipolar10;\r\nbreak;\r\n}\r\nswitch (devpriv->dac1_range) {\r\ncase dac_bipolar:\r\ndevpriv->ao_range_type_list[1] = &range_bipolar10;\r\nbreak;\r\ncase dac_unipolar:\r\ndevpriv->ao_range_type_list[1] = &range_unipolar10;\r\nbreak;\r\n}\r\ns = &dev->subdevices[2];\r\ns->type = COMEDI_SUBD_DIO;\r\ns->subdev_flags = SDF_WRITABLE | SDF_READABLE;\r\ns->n_chan = 8;\r\ns->insn_bits = atmio16d_dio_insn_bits;\r\ns->insn_config = atmio16d_dio_insn_config;\r\ns->maxdata = 1;\r\ns->range_table = &range_digital;\r\ns = &dev->subdevices[3];\r\nif (board->has_8255)\r\nsubdev_8255_init(dev, s, NULL, dev->iobase);\r\nelse\r\ns->type = COMEDI_SUBD_UNUSED;\r\n#if 0\r\ns = &dev->subdevices[4];\r\ns->type = COMEDI_SUBD_TIMER;\r\ns->n_chan = 0;\r\ns->maxdata = 0\r\n#endif\r\nprintk("\n");\r\nreturn 0;\r\n}\r\nstatic void atmio16d_detach(struct comedi_device *dev)\r\n{\r\nconst struct atmio16_board_t *board = comedi_board(dev);\r\nstruct comedi_subdevice *s;\r\nif (dev->subdevices && board->has_8255) {\r\ns = &dev->subdevices[3];\r\nsubdev_8255_cleanup(dev, s);\r\n}\r\nif (dev->irq)\r\nfree_irq(dev->irq, dev);\r\nreset_atmio16d(dev);\r\nif (dev->iobase)\r\nrelease_region(dev->iobase, ATMIO16D_SIZE);\r\n}
