int usb_amd_find_chipset_info(void)\r\n{\r\nu8 rev = 0;\r\nunsigned long flags;\r\nstruct amd_chipset_info info;\r\nint ret;\r\nspin_lock_irqsave(&amd_lock, flags);\r\nif (amd_chipset.probe_count > 0) {\r\namd_chipset.probe_count++;\r\nspin_unlock_irqrestore(&amd_lock, flags);\r\nreturn amd_chipset.probe_result;\r\n}\r\nmemset(&info, 0, sizeof(info));\r\nspin_unlock_irqrestore(&amd_lock, flags);\r\ninfo.smbus_dev = pci_get_device(PCI_VENDOR_ID_ATI, 0x4385, NULL);\r\nif (info.smbus_dev) {\r\nrev = info.smbus_dev->revision;\r\nif (rev >= 0x40)\r\ninfo.sb_type = 1;\r\nelse if (rev >= 0x30 && rev <= 0x3b)\r\ninfo.sb_type = 3;\r\n} else {\r\ninfo.smbus_dev = pci_get_device(PCI_VENDOR_ID_AMD,\r\n0x780b, NULL);\r\nif (!info.smbus_dev) {\r\nret = 0;\r\ngoto commit;\r\n}\r\nrev = info.smbus_dev->revision;\r\nif (rev >= 0x11 && rev <= 0x18)\r\ninfo.sb_type = 2;\r\n}\r\nif (info.sb_type == 0) {\r\nif (info.smbus_dev) {\r\npci_dev_put(info.smbus_dev);\r\ninfo.smbus_dev = NULL;\r\n}\r\nret = 0;\r\ngoto commit;\r\n}\r\ninfo.nb_dev = pci_get_device(PCI_VENDOR_ID_AMD, 0x9601, NULL);\r\nif (info.nb_dev) {\r\ninfo.nb_type = 1;\r\n} else {\r\ninfo.nb_dev = pci_get_device(PCI_VENDOR_ID_AMD, 0x1510, NULL);\r\nif (info.nb_dev) {\r\ninfo.nb_type = 2;\r\n} else {\r\ninfo.nb_dev = pci_get_device(PCI_VENDOR_ID_AMD,\r\n0x9600, NULL);\r\nif (info.nb_dev)\r\ninfo.nb_type = 3;\r\n}\r\n}\r\nret = info.probe_result = 1;\r\nprintk(KERN_DEBUG "QUIRK: Enable AMD PLL fix\n");\r\ncommit:\r\nspin_lock_irqsave(&amd_lock, flags);\r\nif (amd_chipset.probe_count > 0) {\r\namd_chipset.probe_count++;\r\nret = amd_chipset.probe_result;\r\nspin_unlock_irqrestore(&amd_lock, flags);\r\nif (info.nb_dev)\r\npci_dev_put(info.nb_dev);\r\nif (info.smbus_dev)\r\npci_dev_put(info.smbus_dev);\r\n} else {\r\ninfo.probe_count++;\r\namd_chipset = info;\r\nspin_unlock_irqrestore(&amd_lock, flags);\r\n}\r\nreturn ret;\r\n}\r\nstatic void usb_amd_quirk_pll(int disable)\r\n{\r\nu32 addr, addr_low, addr_high, val;\r\nu32 bit = disable ? 0 : 1;\r\nunsigned long flags;\r\nspin_lock_irqsave(&amd_lock, flags);\r\nif (disable) {\r\namd_chipset.isoc_reqs++;\r\nif (amd_chipset.isoc_reqs > 1) {\r\nspin_unlock_irqrestore(&amd_lock, flags);\r\nreturn;\r\n}\r\n} else {\r\namd_chipset.isoc_reqs--;\r\nif (amd_chipset.isoc_reqs > 0) {\r\nspin_unlock_irqrestore(&amd_lock, flags);\r\nreturn;\r\n}\r\n}\r\nif (amd_chipset.sb_type == 1 || amd_chipset.sb_type == 2) {\r\noutb_p(AB_REG_BAR_LOW, 0xcd6);\r\naddr_low = inb_p(0xcd7);\r\noutb_p(AB_REG_BAR_HIGH, 0xcd6);\r\naddr_high = inb_p(0xcd7);\r\naddr = addr_high << 8 | addr_low;\r\noutl_p(0x30, AB_INDX(addr));\r\noutl_p(0x40, AB_DATA(addr));\r\noutl_p(0x34, AB_INDX(addr));\r\nval = inl_p(AB_DATA(addr));\r\n} else if (amd_chipset.sb_type == 3) {\r\npci_read_config_dword(amd_chipset.smbus_dev,\r\nAB_REG_BAR_SB700, &addr);\r\noutl(AX_INDXC, AB_INDX(addr));\r\noutl(0x40, AB_DATA(addr));\r\noutl(AX_DATAC, AB_INDX(addr));\r\nval = inl(AB_DATA(addr));\r\n} else {\r\nspin_unlock_irqrestore(&amd_lock, flags);\r\nreturn;\r\n}\r\nif (disable) {\r\nval &= ~0x08;\r\nval |= (1 << 4) | (1 << 9);\r\n} else {\r\nval |= 0x08;\r\nval &= ~((1 << 4) | (1 << 9));\r\n}\r\noutl_p(val, AB_DATA(addr));\r\nif (!amd_chipset.nb_dev) {\r\nspin_unlock_irqrestore(&amd_lock, flags);\r\nreturn;\r\n}\r\nif (amd_chipset.nb_type == 1 || amd_chipset.nb_type == 3) {\r\naddr = PCIE_P_CNTL;\r\npci_write_config_dword(amd_chipset.nb_dev,\r\nNB_PCIE_INDX_ADDR, addr);\r\npci_read_config_dword(amd_chipset.nb_dev,\r\nNB_PCIE_INDX_DATA, &val);\r\nval &= ~(1 | (1 << 3) | (1 << 4) | (1 << 9) | (1 << 12));\r\nval |= bit | (bit << 3) | (bit << 12);\r\nval |= ((!bit) << 4) | ((!bit) << 9);\r\npci_write_config_dword(amd_chipset.nb_dev,\r\nNB_PCIE_INDX_DATA, val);\r\naddr = BIF_NB;\r\npci_write_config_dword(amd_chipset.nb_dev,\r\nNB_PCIE_INDX_ADDR, addr);\r\npci_read_config_dword(amd_chipset.nb_dev,\r\nNB_PCIE_INDX_DATA, &val);\r\nval &= ~(1 << 8);\r\nval |= bit << 8;\r\npci_write_config_dword(amd_chipset.nb_dev,\r\nNB_PCIE_INDX_DATA, val);\r\n} else if (amd_chipset.nb_type == 2) {\r\naddr = NB_PIF0_PWRDOWN_0;\r\npci_write_config_dword(amd_chipset.nb_dev,\r\nNB_PCIE_INDX_ADDR, addr);\r\npci_read_config_dword(amd_chipset.nb_dev,\r\nNB_PCIE_INDX_DATA, &val);\r\nif (disable)\r\nval &= ~(0x3f << 7);\r\nelse\r\nval |= 0x3f << 7;\r\npci_write_config_dword(amd_chipset.nb_dev,\r\nNB_PCIE_INDX_DATA, val);\r\naddr = NB_PIF0_PWRDOWN_1;\r\npci_write_config_dword(amd_chipset.nb_dev,\r\nNB_PCIE_INDX_ADDR, addr);\r\npci_read_config_dword(amd_chipset.nb_dev,\r\nNB_PCIE_INDX_DATA, &val);\r\nif (disable)\r\nval &= ~(0x3f << 7);\r\nelse\r\nval |= 0x3f << 7;\r\npci_write_config_dword(amd_chipset.nb_dev,\r\nNB_PCIE_INDX_DATA, val);\r\n}\r\nspin_unlock_irqrestore(&amd_lock, flags);\r\nreturn;\r\n}\r\nvoid usb_amd_quirk_pll_disable(void)\r\n{\r\nusb_amd_quirk_pll(1);\r\n}\r\nvoid usb_amd_quirk_pll_enable(void)\r\n{\r\nusb_amd_quirk_pll(0);\r\n}\r\nvoid usb_amd_dev_put(void)\r\n{\r\nstruct pci_dev *nb, *smbus;\r\nunsigned long flags;\r\nspin_lock_irqsave(&amd_lock, flags);\r\namd_chipset.probe_count--;\r\nif (amd_chipset.probe_count > 0) {\r\nspin_unlock_irqrestore(&amd_lock, flags);\r\nreturn;\r\n}\r\nnb = amd_chipset.nb_dev;\r\nsmbus = amd_chipset.smbus_dev;\r\namd_chipset.nb_dev = NULL;\r\namd_chipset.smbus_dev = NULL;\r\namd_chipset.nb_type = 0;\r\namd_chipset.sb_type = 0;\r\namd_chipset.isoc_reqs = 0;\r\namd_chipset.probe_result = 0;\r\nspin_unlock_irqrestore(&amd_lock, flags);\r\nif (nb)\r\npci_dev_put(nb);\r\nif (smbus)\r\npci_dev_put(smbus);\r\n}\r\nvoid uhci_reset_hc(struct pci_dev *pdev, unsigned long base)\r\n{\r\npci_write_config_word(pdev, UHCI_USBLEGSUP, UHCI_USBLEGSUP_RWC);\r\noutw(UHCI_USBCMD_HCRESET, base + UHCI_USBCMD);\r\nmb();\r\nudelay(5);\r\nif (inw(base + UHCI_USBCMD) & UHCI_USBCMD_HCRESET)\r\ndev_warn(&pdev->dev, "HCRESET not completed yet!\n");\r\noutw(0, base + UHCI_USBINTR);\r\noutw(0, base + UHCI_USBCMD);\r\n}\r\nint uhci_check_and_reset_hc(struct pci_dev *pdev, unsigned long base)\r\n{\r\nu16 legsup;\r\nunsigned int cmd, intr;\r\npci_read_config_word(pdev, UHCI_USBLEGSUP, &legsup);\r\nif (legsup & ~(UHCI_USBLEGSUP_RO | UHCI_USBLEGSUP_RWC)) {\r\ndev_dbg(&pdev->dev, "%s: legsup = 0x%04x\n",\r\n__func__, legsup);\r\ngoto reset_needed;\r\n}\r\ncmd = inw(base + UHCI_USBCMD);\r\nif ((cmd & UHCI_USBCMD_RUN) || !(cmd & UHCI_USBCMD_CONFIGURE) ||\r\n!(cmd & UHCI_USBCMD_EGSM)) {\r\ndev_dbg(&pdev->dev, "%s: cmd = 0x%04x\n",\r\n__func__, cmd);\r\ngoto reset_needed;\r\n}\r\nintr = inw(base + UHCI_USBINTR);\r\nif (intr & (~UHCI_USBINTR_RESUME)) {\r\ndev_dbg(&pdev->dev, "%s: intr = 0x%04x\n",\r\n__func__, intr);\r\ngoto reset_needed;\r\n}\r\nreturn 0;\r\nreset_needed:\r\ndev_dbg(&pdev->dev, "Performing full reset\n");\r\nuhci_reset_hc(pdev, base);\r\nreturn 1;\r\n}\r\nstatic inline int io_type_enabled(struct pci_dev *pdev, unsigned int mask)\r\n{\r\nu16 cmd;\r\nreturn !pci_read_config_word(pdev, PCI_COMMAND, &cmd) && (cmd & mask);\r\n}\r\nstatic void quirk_usb_handoff_uhci(struct pci_dev *pdev)\r\n{\r\nunsigned long base = 0;\r\nint i;\r\nif (!pio_enabled(pdev))\r\nreturn;\r\nfor (i = 0; i < PCI_ROM_RESOURCE; i++)\r\nif ((pci_resource_flags(pdev, i) & IORESOURCE_IO)) {\r\nbase = pci_resource_start(pdev, i);\r\nbreak;\r\n}\r\nif (base)\r\nuhci_check_and_reset_hc(pdev, base);\r\n}\r\nstatic int mmio_resource_enabled(struct pci_dev *pdev, int idx)\r\n{\r\nreturn pci_resource_start(pdev, idx) && mmio_enabled(pdev);\r\n}\r\nstatic void quirk_usb_handoff_ohci(struct pci_dev *pdev)\r\n{\r\nvoid __iomem *base;\r\nu32 control;\r\nu32 fminterval;\r\nint cnt;\r\nif (!mmio_resource_enabled(pdev, 0))\r\nreturn;\r\nbase = pci_ioremap_bar(pdev, 0);\r\nif (base == NULL)\r\nreturn;\r\ncontrol = readl(base + OHCI_CONTROL);\r\n#ifdef __hppa__\r\n#define OHCI_CTRL_MASK (OHCI_CTRL_RWC | OHCI_CTRL_IR)\r\n#else\r\n#define OHCI_CTRL_MASK OHCI_CTRL_RWC\r\nif (control & OHCI_CTRL_IR) {\r\nint wait_time = 500;\r\nwritel(OHCI_INTR_OC, base + OHCI_INTRENABLE);\r\nwritel(OHCI_OCR, base + OHCI_CMDSTATUS);\r\nwhile (wait_time > 0 &&\r\nreadl(base + OHCI_CONTROL) & OHCI_CTRL_IR) {\r\nwait_time -= 10;\r\nmsleep(10);\r\n}\r\nif (wait_time <= 0)\r\ndev_warn(&pdev->dev, "OHCI: BIOS handoff failed"\r\n" (BIOS bug?) %08x\n",\r\nreadl(base + OHCI_CONTROL));\r\n}\r\n#endif\r\nwritel((u32) ~0, base + OHCI_INTRDISABLE);\r\nif (control & OHCI_HCFS) {\r\nwritel(control & OHCI_CTRL_MASK, base + OHCI_CONTROL);\r\nreadl(base + OHCI_CONTROL);\r\nmsleep(50);\r\n}\r\nfminterval = readl(base + OHCI_FMINTERVAL);\r\nwritel(OHCI_HCR, base + OHCI_CMDSTATUS);\r\nfor (cnt = 30; cnt > 0; --cnt) {\r\nif ((readl(base + OHCI_CMDSTATUS) & OHCI_HCR) == 0)\r\nbreak;\r\nudelay(1);\r\n}\r\nwritel(fminterval, base + OHCI_FMINTERVAL);\r\niounmap(base);\r\n}\r\nstatic void ehci_bios_handoff(struct pci_dev *pdev,\r\nvoid __iomem *op_reg_base,\r\nu32 cap, u8 offset)\r\n{\r\nint try_handoff = 1, tried_handoff = 0;\r\nif (pdev->vendor == 0x8086 && pdev->device == 0x283a) {\r\nif (dmi_check_system(ehci_dmi_nohandoff_table))\r\ntry_handoff = 0;\r\n}\r\nif (try_handoff && (cap & EHCI_USBLEGSUP_BIOS)) {\r\ndev_dbg(&pdev->dev, "EHCI: BIOS handoff\n");\r\n#if 0\r\npci_read_config_dword(pdev, offset + EHCI_USBLEGCTLSTS, &val);\r\npci_write_config_dword(pdev, offset + EHCI_USBLEGCTLSTS,\r\nval | EHCI_USBLEGCTLSTS_SOOE);\r\n#endif\r\npci_write_config_byte(pdev, offset + 3, 1);\r\n}\r\nif (try_handoff) {\r\nint msec = 1000;\r\nwhile ((cap & EHCI_USBLEGSUP_BIOS) && (msec > 0)) {\r\ntried_handoff = 1;\r\nmsleep(10);\r\nmsec -= 10;\r\npci_read_config_dword(pdev, offset, &cap);\r\n}\r\n}\r\nif (cap & EHCI_USBLEGSUP_BIOS) {\r\nif (try_handoff)\r\ndev_warn(&pdev->dev, "EHCI: BIOS handoff failed"\r\n" (BIOS bug?) %08x\n", cap);\r\npci_write_config_byte(pdev, offset + 2, 0);\r\n}\r\npci_write_config_dword(pdev, offset + EHCI_USBLEGCTLSTS, 0);\r\nif (tried_handoff)\r\nwritel(0, op_reg_base + EHCI_CONFIGFLAG);\r\n}\r\nstatic void quirk_usb_disable_ehci(struct pci_dev *pdev)\r\n{\r\nvoid __iomem *base, *op_reg_base;\r\nu32 hcc_params, cap, val;\r\nu8 offset, cap_length;\r\nint wait_time, count = 256/4;\r\nif (!mmio_resource_enabled(pdev, 0))\r\nreturn;\r\nbase = pci_ioremap_bar(pdev, 0);\r\nif (base == NULL)\r\nreturn;\r\ncap_length = readb(base);\r\nop_reg_base = base + cap_length;\r\nhcc_params = readl(base + EHCI_HCC_PARAMS);\r\noffset = (hcc_params >> 8) & 0xff;\r\nwhile (offset && --count) {\r\npci_read_config_dword(pdev, offset, &cap);\r\nswitch (cap & 0xff) {\r\ncase 1:\r\nehci_bios_handoff(pdev, op_reg_base, cap, offset);\r\nbreak;\r\ncase 0:\r\ncap = 0;\r\ndefault:\r\ndev_warn(&pdev->dev, "EHCI: unrecognized capability "\r\n"%02x\n", cap & 0xff);\r\n}\r\noffset = (cap >> 8) & 0xff;\r\n}\r\nif (!count)\r\ndev_printk(KERN_DEBUG, &pdev->dev, "EHCI: capability loop?\n");\r\nval = readl(op_reg_base + EHCI_USBSTS);\r\nif ((val & EHCI_USBSTS_HALTED) == 0) {\r\nval = readl(op_reg_base + EHCI_USBCMD);\r\nval &= ~EHCI_USBCMD_RUN;\r\nwritel(val, op_reg_base + EHCI_USBCMD);\r\nwait_time = 2000;\r\ndo {\r\nwritel(0x3f, op_reg_base + EHCI_USBSTS);\r\nudelay(100);\r\nwait_time -= 100;\r\nval = readl(op_reg_base + EHCI_USBSTS);\r\nif ((val == ~(u32)0) || (val & EHCI_USBSTS_HALTED)) {\r\nbreak;\r\n}\r\n} while (wait_time > 0);\r\n}\r\nwritel(0, op_reg_base + EHCI_USBINTR);\r\nwritel(0x3f, op_reg_base + EHCI_USBSTS);\r\niounmap(base);\r\n}\r\nstatic int handshake(void __iomem *ptr, u32 mask, u32 done,\r\nint wait_usec, int delay_usec)\r\n{\r\nu32 result;\r\ndo {\r\nresult = readl(ptr);\r\nresult &= mask;\r\nif (result == done)\r\nreturn 0;\r\nudelay(delay_usec);\r\nwait_usec -= delay_usec;\r\n} while (wait_usec > 0);\r\nreturn -ETIMEDOUT;\r\n}\r\nbool usb_is_intel_ppt_switchable_xhci(struct pci_dev *pdev)\r\n{\r\nreturn pdev->class == PCI_CLASS_SERIAL_USB_XHCI &&\r\npdev->vendor == PCI_VENDOR_ID_INTEL &&\r\npdev->device == PCI_DEVICE_ID_INTEL_PANTHERPOINT_XHCI;\r\n}\r\nbool usb_is_intel_lpt_switchable_xhci(struct pci_dev *pdev)\r\n{\r\nreturn pdev->class == PCI_CLASS_SERIAL_USB_XHCI &&\r\npdev->vendor == PCI_VENDOR_ID_INTEL &&\r\n(pdev->device == PCI_DEVICE_ID_INTEL_LYNX_POINT_XHCI ||\r\npdev->device == PCI_DEVICE_ID_INTEL_LYNX_POINT_LP_XHCI);\r\n}\r\nbool usb_is_intel_switchable_xhci(struct pci_dev *pdev)\r\n{\r\nreturn usb_is_intel_ppt_switchable_xhci(pdev) ||\r\nusb_is_intel_lpt_switchable_xhci(pdev);\r\n}\r\nvoid usb_enable_xhci_ports(struct pci_dev *xhci_pdev)\r\n{\r\nu32 ports_available;\r\nif (!IS_ENABLED(CONFIG_USB_XHCI_HCD)) {\r\ndev_warn(&xhci_pdev->dev,\r\n"CONFIG_USB_XHCI_HCD is turned off, "\r\n"defaulting to EHCI.\n");\r\ndev_warn(&xhci_pdev->dev,\r\n"USB 3.0 devices will work at USB 2.0 speeds.\n");\r\nusb_disable_xhci_ports(xhci_pdev);\r\nreturn;\r\n}\r\npci_read_config_dword(xhci_pdev, USB_INTEL_USB3PRM,\r\n&ports_available);\r\ndev_dbg(&xhci_pdev->dev, "Configurable ports to enable SuperSpeed: 0x%x\n",\r\nports_available);\r\npci_write_config_dword(xhci_pdev, USB_INTEL_USB3_PSSEN,\r\ncpu_to_le32(ports_available));\r\npci_read_config_dword(xhci_pdev, USB_INTEL_USB3_PSSEN,\r\n&ports_available);\r\ndev_dbg(&xhci_pdev->dev, "USB 3.0 ports that are now enabled "\r\n"under xHCI: 0x%x\n", ports_available);\r\npci_read_config_dword(xhci_pdev, USB_INTEL_USB2PRM,\r\n&ports_available);\r\ndev_dbg(&xhci_pdev->dev, "Configurable USB 2.0 ports to hand over to xCHI: 0x%x\n",\r\nports_available);\r\npci_write_config_dword(xhci_pdev, USB_INTEL_XUSB2PR,\r\ncpu_to_le32(ports_available));\r\npci_read_config_dword(xhci_pdev, USB_INTEL_XUSB2PR,\r\n&ports_available);\r\ndev_dbg(&xhci_pdev->dev, "USB 2.0 ports that are now switched over "\r\n"to xHCI: 0x%x\n", ports_available);\r\n}\r\nvoid usb_disable_xhci_ports(struct pci_dev *xhci_pdev)\r\n{\r\npci_write_config_dword(xhci_pdev, USB_INTEL_USB3_PSSEN, 0x0);\r\npci_write_config_dword(xhci_pdev, USB_INTEL_XUSB2PR, 0x0);\r\n}\r\nstatic void quirk_usb_handoff_xhci(struct pci_dev *pdev)\r\n{\r\nvoid __iomem *base;\r\nint ext_cap_offset;\r\nvoid __iomem *op_reg_base;\r\nu32 val;\r\nint timeout;\r\nint len = pci_resource_len(pdev, 0);\r\nif (!mmio_resource_enabled(pdev, 0))\r\nreturn;\r\nbase = ioremap_nocache(pci_resource_start(pdev, 0), len);\r\nif (base == NULL)\r\nreturn;\r\next_cap_offset = xhci_find_next_cap_offset(base, XHCI_HCC_PARAMS_OFFSET);\r\ndo {\r\nif ((ext_cap_offset + sizeof(val)) > len) {\r\ndev_warn(&pdev->dev,\r\n"xHCI controller failing to respond");\r\nreturn;\r\n}\r\nif (!ext_cap_offset)\r\ngoto hc_init;\r\nval = readl(base + ext_cap_offset);\r\nif (XHCI_EXT_CAPS_ID(val) == XHCI_EXT_CAPS_LEGACY)\r\nbreak;\r\next_cap_offset = xhci_find_next_cap_offset(base, ext_cap_offset);\r\n} while (1);\r\nif (val & XHCI_HC_BIOS_OWNED) {\r\nwritel(val | XHCI_HC_OS_OWNED, base + ext_cap_offset);\r\ntimeout = handshake(base + ext_cap_offset, XHCI_HC_BIOS_OWNED,\r\n0, 5000, 10);\r\nif (timeout) {\r\ndev_warn(&pdev->dev, "xHCI BIOS handoff failed"\r\n" (BIOS bug ?) %08x\n", val);\r\nwritel(val & ~XHCI_HC_BIOS_OWNED, base + ext_cap_offset);\r\n}\r\n}\r\nval = readl(base + ext_cap_offset + XHCI_LEGACY_CONTROL_OFFSET);\r\nval &= XHCI_LEGACY_DISABLE_SMI;\r\nval |= XHCI_LEGACY_SMI_EVENTS;\r\nwritel(val, base + ext_cap_offset + XHCI_LEGACY_CONTROL_OFFSET);\r\nhc_init:\r\nif (usb_is_intel_switchable_xhci(pdev))\r\nusb_enable_xhci_ports(pdev);\r\nop_reg_base = base + XHCI_HC_LENGTH(readl(base));\r\ntimeout = handshake(op_reg_base + XHCI_STS_OFFSET, XHCI_STS_CNR, 0,\r\n5000, 10);\r\nif (timeout) {\r\nval = readl(op_reg_base + XHCI_STS_OFFSET);\r\ndev_warn(&pdev->dev,\r\n"xHCI HW not ready after 5 sec (HC bug?) "\r\n"status = 0x%x\n", val);\r\n}\r\nval = readl(op_reg_base + XHCI_CMD_OFFSET);\r\nval &= ~(XHCI_CMD_RUN | XHCI_IRQS);\r\nwritel(val, op_reg_base + XHCI_CMD_OFFSET);\r\ntimeout = handshake(op_reg_base + XHCI_STS_OFFSET, XHCI_STS_HALT, 1,\r\nXHCI_MAX_HALT_USEC, 125);\r\nif (timeout) {\r\nval = readl(op_reg_base + XHCI_STS_OFFSET);\r\ndev_warn(&pdev->dev,\r\n"xHCI HW did not halt within %d usec "\r\n"status = 0x%x\n", XHCI_MAX_HALT_USEC, val);\r\n}\r\niounmap(base);\r\n}\r\nstatic void quirk_usb_early_handoff(struct pci_dev *pdev)\r\n{\r\nif (pdev->vendor == 0x184e)\r\nreturn;\r\nif (pdev->class != PCI_CLASS_SERIAL_USB_UHCI &&\r\npdev->class != PCI_CLASS_SERIAL_USB_OHCI &&\r\npdev->class != PCI_CLASS_SERIAL_USB_EHCI &&\r\npdev->class != PCI_CLASS_SERIAL_USB_XHCI)\r\nreturn;\r\nif (pci_enable_device(pdev) < 0) {\r\ndev_warn(&pdev->dev, "Can't enable PCI device, "\r\n"BIOS handoff failed.\n");\r\nreturn;\r\n}\r\nif (pdev->class == PCI_CLASS_SERIAL_USB_UHCI)\r\nquirk_usb_handoff_uhci(pdev);\r\nelse if (pdev->class == PCI_CLASS_SERIAL_USB_OHCI)\r\nquirk_usb_handoff_ohci(pdev);\r\nelse if (pdev->class == PCI_CLASS_SERIAL_USB_EHCI)\r\nquirk_usb_disable_ehci(pdev);\r\nelse if (pdev->class == PCI_CLASS_SERIAL_USB_XHCI)\r\nquirk_usb_handoff_xhci(pdev);\r\npci_disable_device(pdev);\r\n}
