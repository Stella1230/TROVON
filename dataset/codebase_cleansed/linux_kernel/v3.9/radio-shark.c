static void shark_write_val(struct snd_tea575x *tea, u32 val)\r\n{\r\nstruct shark_device *shark = tea->private_data;\r\nint i, res, actual_len;\r\nif (shark->last_val == val)\r\nreturn;\r\nmemset(shark->transfer_buffer, 0, TB_LEN);\r\nshark->transfer_buffer[0] = 0xc0;\r\nfor (i = 0; i < 4; i++)\r\nshark->transfer_buffer[i] |= (val >> (24 - i * 8)) & 0xff;\r\nres = usb_interrupt_msg(shark->usbdev,\r\nusb_sndintpipe(shark->usbdev, SHARK_OUT_EP),\r\nshark->transfer_buffer, TB_LEN,\r\n&actual_len, 1000);\r\nif (res >= 0)\r\nshark->last_val = val;\r\nelse\r\nv4l2_err(&shark->v4l2_dev, "set-freq error: %d\n", res);\r\n}\r\nstatic u32 shark_read_val(struct snd_tea575x *tea)\r\n{\r\nstruct shark_device *shark = tea->private_data;\r\nint i, res, actual_len;\r\nu32 val = 0;\r\nmemset(shark->transfer_buffer, 0, TB_LEN);\r\nshark->transfer_buffer[0] = 0x80;\r\nres = usb_interrupt_msg(shark->usbdev,\r\nusb_sndintpipe(shark->usbdev, SHARK_OUT_EP),\r\nshark->transfer_buffer, TB_LEN,\r\n&actual_len, 1000);\r\nif (res < 0) {\r\nv4l2_err(&shark->v4l2_dev, "request-status error: %d\n", res);\r\nreturn shark->last_val;\r\n}\r\nres = usb_interrupt_msg(shark->usbdev,\r\nusb_rcvintpipe(shark->usbdev, SHARK_IN_EP),\r\nshark->transfer_buffer, TB_LEN,\r\n&actual_len, 1000);\r\nif (res < 0) {\r\nv4l2_err(&shark->v4l2_dev, "get-status error: %d\n", res);\r\nreturn shark->last_val;\r\n}\r\nfor (i = 0; i < 4; i++)\r\nval |= shark->transfer_buffer[i] << (24 - i * 8);\r\nshark->last_val = val;\r\nif (((val & TEA575X_BIT_BAND_MASK) == TEA575X_BIT_BAND_FM) &&\r\n!(val & TEA575X_BIT_MONO))\r\nshark->tea.stereo = true;\r\nelse\r\nshark->tea.stereo = false;\r\nreturn val;\r\n}\r\nstatic void shark_led_work(struct work_struct *work)\r\n{\r\nstruct shark_device *shark =\r\ncontainer_of(work, struct shark_device, led_work);\r\nint i, res, brightness, actual_len;\r\nfor (i = 0; i < 3; i++) {\r\nif (!test_and_clear_bit(i, &shark->brightness_new))\r\ncontinue;\r\nbrightness = atomic_read(&shark->brightness[i]);\r\nmemset(shark->transfer_buffer, 0, TB_LEN);\r\nif (i != RED_LED) {\r\nshark->transfer_buffer[0] = 0xA0 + i;\r\nshark->transfer_buffer[1] = brightness;\r\n} else\r\nshark->transfer_buffer[0] = brightness ? 0xA9 : 0xA8;\r\nres = usb_interrupt_msg(shark->usbdev,\r\nusb_sndintpipe(shark->usbdev, 0x05),\r\nshark->transfer_buffer, TB_LEN,\r\n&actual_len, 1000);\r\nif (res < 0)\r\nv4l2_err(&shark->v4l2_dev, "set LED %s error: %d\n",\r\nshark->led_names[i], res);\r\n}\r\n}\r\nstatic void shark_led_set_blue(struct led_classdev *led_cdev,\r\nenum led_brightness value)\r\n{\r\nstruct shark_device *shark =\r\ncontainer_of(led_cdev, struct shark_device, leds[BLUE_LED]);\r\natomic_set(&shark->brightness[BLUE_LED], value);\r\nset_bit(BLUE_LED, &shark->brightness_new);\r\nclear_bit(BLUE_IS_PULSE, &shark->brightness_new);\r\nschedule_work(&shark->led_work);\r\n}\r\nstatic void shark_led_set_blue_pulse(struct led_classdev *led_cdev,\r\nenum led_brightness value)\r\n{\r\nstruct shark_device *shark = container_of(led_cdev,\r\nstruct shark_device, leds[BLUE_PULSE_LED]);\r\natomic_set(&shark->brightness[BLUE_PULSE_LED], 256 - value);\r\nset_bit(BLUE_PULSE_LED, &shark->brightness_new);\r\nset_bit(BLUE_IS_PULSE, &shark->brightness_new);\r\nschedule_work(&shark->led_work);\r\n}\r\nstatic void shark_led_set_red(struct led_classdev *led_cdev,\r\nenum led_brightness value)\r\n{\r\nstruct shark_device *shark =\r\ncontainer_of(led_cdev, struct shark_device, leds[RED_LED]);\r\natomic_set(&shark->brightness[RED_LED], value);\r\nset_bit(RED_LED, &shark->brightness_new);\r\nschedule_work(&shark->led_work);\r\n}\r\nstatic int shark_register_leds(struct shark_device *shark, struct device *dev)\r\n{\r\nint i, retval;\r\natomic_set(&shark->brightness[BLUE_LED], 127);\r\nINIT_WORK(&shark->led_work, shark_led_work);\r\nfor (i = 0; i < NO_LEDS; i++) {\r\nshark->leds[i] = shark_led_templates[i];\r\nsnprintf(shark->led_names[i], sizeof(shark->led_names[0]),\r\nshark->leds[i].name, shark->v4l2_dev.name);\r\nshark->leds[i].name = shark->led_names[i];\r\nretval = led_classdev_register(dev, &shark->leds[i]);\r\nif (retval) {\r\nv4l2_err(&shark->v4l2_dev,\r\n"couldn't register led: %s\n",\r\nshark->led_names[i]);\r\nreturn retval;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void shark_unregister_leds(struct shark_device *shark)\r\n{\r\nint i;\r\nfor (i = 0; i < NO_LEDS; i++)\r\nled_classdev_unregister(&shark->leds[i]);\r\ncancel_work_sync(&shark->led_work);\r\n}\r\nstatic void shark_resume_leds(struct shark_device *shark)\r\n{\r\nif (test_bit(BLUE_IS_PULSE, &shark->brightness_new))\r\nset_bit(BLUE_PULSE_LED, &shark->brightness_new);\r\nelse\r\nset_bit(BLUE_LED, &shark->brightness_new);\r\nset_bit(RED_LED, &shark->brightness_new);\r\nschedule_work(&shark->led_work);\r\n}\r\nstatic int shark_register_leds(struct shark_device *shark, struct device *dev)\r\n{\r\nv4l2_warn(&shark->v4l2_dev,\r\n"CONFIG_LED_CLASS not enabled, LED support disabled\n");\r\nreturn 0;\r\n}\r\nstatic inline void shark_unregister_leds(struct shark_device *shark) { }\r\nstatic inline void shark_resume_leds(struct shark_device *shark) { }\r\nstatic void usb_shark_disconnect(struct usb_interface *intf)\r\n{\r\nstruct v4l2_device *v4l2_dev = usb_get_intfdata(intf);\r\nstruct shark_device *shark = v4l2_dev_to_shark(v4l2_dev);\r\nmutex_lock(&shark->tea.mutex);\r\nv4l2_device_disconnect(&shark->v4l2_dev);\r\nsnd_tea575x_exit(&shark->tea);\r\nmutex_unlock(&shark->tea.mutex);\r\nshark_unregister_leds(shark);\r\nv4l2_device_put(&shark->v4l2_dev);\r\n}\r\nstatic void usb_shark_release(struct v4l2_device *v4l2_dev)\r\n{\r\nstruct shark_device *shark = v4l2_dev_to_shark(v4l2_dev);\r\nv4l2_device_unregister(&shark->v4l2_dev);\r\nkfree(shark->transfer_buffer);\r\nkfree(shark);\r\n}\r\nstatic int usb_shark_probe(struct usb_interface *intf,\r\nconst struct usb_device_id *id)\r\n{\r\nstruct shark_device *shark;\r\nint retval = -ENOMEM;\r\nshark = kzalloc(sizeof(struct shark_device), GFP_KERNEL);\r\nif (!shark)\r\nreturn retval;\r\nshark->transfer_buffer = kmalloc(TB_LEN, GFP_KERNEL);\r\nif (!shark->transfer_buffer)\r\ngoto err_alloc_buffer;\r\nv4l2_device_set_name(&shark->v4l2_dev, DRV_NAME, &shark_instance);\r\nretval = shark_register_leds(shark, &intf->dev);\r\nif (retval)\r\ngoto err_reg_leds;\r\nshark->v4l2_dev.release = usb_shark_release;\r\nretval = v4l2_device_register(&intf->dev, &shark->v4l2_dev);\r\nif (retval) {\r\nv4l2_err(&shark->v4l2_dev, "couldn't register v4l2_device\n");\r\ngoto err_reg_dev;\r\n}\r\nshark->usbdev = interface_to_usbdev(intf);\r\nshark->tea.v4l2_dev = &shark->v4l2_dev;\r\nshark->tea.private_data = shark;\r\nshark->tea.radio_nr = -1;\r\nshark->tea.ops = &shark_tea_ops;\r\nshark->tea.cannot_mute = true;\r\nshark->tea.has_am = true;\r\nstrlcpy(shark->tea.card, "Griffin radioSHARK",\r\nsizeof(shark->tea.card));\r\nusb_make_path(shark->usbdev, shark->tea.bus_info,\r\nsizeof(shark->tea.bus_info));\r\nretval = snd_tea575x_init(&shark->tea, THIS_MODULE);\r\nif (retval) {\r\nv4l2_err(&shark->v4l2_dev, "couldn't init tea5757\n");\r\ngoto err_init_tea;\r\n}\r\nreturn 0;\r\nerr_init_tea:\r\nv4l2_device_unregister(&shark->v4l2_dev);\r\nerr_reg_dev:\r\nshark_unregister_leds(shark);\r\nerr_reg_leds:\r\nkfree(shark->transfer_buffer);\r\nerr_alloc_buffer:\r\nkfree(shark);\r\nreturn retval;\r\n}\r\nstatic int usb_shark_suspend(struct usb_interface *intf, pm_message_t message)\r\n{\r\nreturn 0;\r\n}\r\nstatic int usb_shark_resume(struct usb_interface *intf)\r\n{\r\nstruct v4l2_device *v4l2_dev = usb_get_intfdata(intf);\r\nstruct shark_device *shark = v4l2_dev_to_shark(v4l2_dev);\r\nmutex_lock(&shark->tea.mutex);\r\nsnd_tea575x_set_freq(&shark->tea);\r\nmutex_unlock(&shark->tea.mutex);\r\nshark_resume_leds(shark);\r\nreturn 0;\r\n}
