static void ux500_pcm_dma_hw_free(struct device *dev,\r\nstruct snd_pcm_substream *substream)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct snd_dma_buffer *buf = runtime->dma_buffer_p;\r\nif (runtime->dma_area == NULL)\r\nreturn;\r\nif (buf != &substream->dma_buffer) {\r\ndma_free_coherent(buf->dev.dev, buf->bytes, buf->area,\r\nbuf->addr);\r\nkfree(runtime->dma_buffer_p);\r\n}\r\nsnd_pcm_set_runtime_buffer(substream, NULL);\r\n}\r\nstatic int ux500_pcm_open(struct snd_pcm_substream *substream)\r\n{\r\nint stream_id = substream->pstr->stream;\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\nstruct snd_soc_dai *dai = rtd->cpu_dai;\r\nstruct device *dev = dai->dev;\r\nint ret;\r\nstruct ux500_msp_dma_params *dma_params;\r\nu16 per_data_width, mem_data_width;\r\nstruct stedma40_chan_cfg *dma_cfg;\r\ndev_dbg(dev, "%s: MSP %d (%s): Enter.\n", __func__, dai->id,\r\nsnd_pcm_stream_str(substream));\r\ndev_dbg(dev, "%s: Set runtime hwparams.\n", __func__);\r\nif (stream_id == SNDRV_PCM_STREAM_PLAYBACK)\r\nsnd_soc_set_runtime_hwparams(substream,\r\n&ux500_pcm_hw_playback);\r\nelse\r\nsnd_soc_set_runtime_hwparams(substream,\r\n&ux500_pcm_hw_capture);\r\nret = snd_pcm_hw_constraint_integer(runtime,\r\nSNDRV_PCM_HW_PARAM_PERIODS);\r\nif (ret < 0) {\r\ndev_err(dev, "%s: Error: snd_pcm_hw_constraints failed (%d)\n",\r\n__func__, ret);\r\nreturn ret;\r\n}\r\ndev_dbg(dev, "%s: Set hw-struct for %s.\n", __func__,\r\nsnd_pcm_stream_str(substream));\r\nruntime->hw = (stream_id == SNDRV_PCM_STREAM_PLAYBACK) ?\r\nux500_pcm_hw_playback : ux500_pcm_hw_capture;\r\nmem_data_width = STEDMA40_HALFWORD_WIDTH;\r\ndma_params = snd_soc_dai_get_dma_data(dai, substream);\r\nswitch (dma_params->data_size) {\r\ncase 32:\r\nper_data_width = STEDMA40_WORD_WIDTH;\r\nbreak;\r\ncase 16:\r\nper_data_width = STEDMA40_HALFWORD_WIDTH;\r\nbreak;\r\ncase 8:\r\nper_data_width = STEDMA40_BYTE_WIDTH;\r\nbreak;\r\ndefault:\r\nper_data_width = STEDMA40_WORD_WIDTH;\r\ndev_warn(rtd->platform->dev,\r\n"%s: Unknown data-size (%d)! Assuming 32 bits.\n",\r\n__func__, dma_params->data_size);\r\n}\r\ndma_cfg = dma_params->dma_cfg;\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\r\ndma_cfg->src_info.data_width = mem_data_width;\r\ndma_cfg->dst_info.data_width = per_data_width;\r\n} else {\r\ndma_cfg->src_info.data_width = per_data_width;\r\ndma_cfg->dst_info.data_width = mem_data_width;\r\n}\r\nret = snd_dmaengine_pcm_open(substream, stedma40_filter, dma_cfg);\r\nif (ret) {\r\ndev_dbg(dai->dev,\r\n"%s: ERROR: snd_dmaengine_pcm_open failed (%d)!\n",\r\n__func__, ret);\r\nreturn ret;\r\n}\r\nsnd_dmaengine_pcm_set_data(substream, dma_cfg);\r\nreturn 0;\r\n}\r\nstatic int ux500_pcm_close(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\nstruct snd_soc_dai *dai = rtd->cpu_dai;\r\ndev_dbg(dai->dev, "%s: Enter\n", __func__);\r\nsnd_dmaengine_pcm_close(substream);\r\nreturn 0;\r\n}\r\nstatic int ux500_pcm_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *hw_params)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct snd_dma_buffer *buf = runtime->dma_buffer_p;\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\nint ret = 0;\r\nint size;\r\ndev_dbg(rtd->platform->dev, "%s: Enter\n", __func__);\r\nsize = params_buffer_bytes(hw_params);\r\nif (buf) {\r\nif (buf->bytes >= size)\r\ngoto out;\r\nux500_pcm_dma_hw_free(NULL, substream);\r\n}\r\nif (substream->dma_buffer.area != NULL &&\r\nsubstream->dma_buffer.bytes >= size) {\r\nbuf = &substream->dma_buffer;\r\n} else {\r\nbuf = kmalloc(sizeof(struct snd_dma_buffer), GFP_KERNEL);\r\nif (!buf)\r\ngoto nomem;\r\nbuf->dev.type = SNDRV_DMA_TYPE_DEV;\r\nbuf->dev.dev = NULL;\r\nbuf->area = dma_alloc_coherent(NULL, size, &buf->addr,\r\nGFP_KERNEL);\r\nbuf->bytes = size;\r\nbuf->private_data = NULL;\r\nif (!buf->area)\r\ngoto free;\r\n}\r\nsnd_pcm_set_runtime_buffer(substream, buf);\r\nret = 1;\r\nout:\r\nruntime->dma_bytes = size;\r\nreturn ret;\r\nfree:\r\nkfree(buf);\r\nnomem:\r\nreturn -ENOMEM;\r\n}\r\nstatic int ux500_pcm_hw_free(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\ndev_dbg(rtd->platform->dev, "%s: Enter\n", __func__);\r\nux500_pcm_dma_hw_free(NULL, substream);\r\nreturn 0;\r\n}\r\nstatic int ux500_pcm_mmap(struct snd_pcm_substream *substream,\r\nstruct vm_area_struct *vma)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\ndev_dbg(rtd->platform->dev, "%s: Enter.\n", __func__);\r\nreturn dma_mmap_coherent(NULL, vma, runtime->dma_area,\r\nruntime->dma_addr, runtime->dma_bytes);\r\n}\r\nint ux500_pcm_new(struct snd_soc_pcm_runtime *rtd)\r\n{\r\nstruct snd_pcm *pcm = rtd->pcm;\r\ndev_dbg(rtd->platform->dev, "%s: Enter (id = '%s').\n", __func__,\r\npcm->id);\r\npcm->info_flags = 0;\r\nreturn 0;\r\n}\r\nint ux500_pcm_register_platform(struct platform_device *pdev)\r\n{\r\nint ret;\r\nret = snd_soc_register_platform(&pdev->dev, &ux500_pcm_soc_drv);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev,\r\n"%s: ERROR: Failed to register platform '%s' (%d)!\n",\r\n__func__, pdev->name, ret);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nint ux500_pcm_unregister_platform(struct platform_device *pdev)\r\n{\r\nsnd_soc_unregister_platform(&pdev->dev);\r\nreturn 0;\r\n}
