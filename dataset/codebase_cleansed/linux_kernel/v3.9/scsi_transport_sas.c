static struct sas_end_device *sas_sdev_to_rdev(struct scsi_device *sdev)\r\n{\r\nstruct sas_rphy *rphy = target_to_rphy(sdev->sdev_target);\r\nstruct sas_end_device *rdev;\r\nBUG_ON(rphy->identify.device_type != SAS_END_DEVICE);\r\nrdev = rphy_to_end_device(rphy);\r\nreturn rdev;\r\n}\r\nstatic void sas_smp_request(struct request_queue *q, struct Scsi_Host *shost,\r\nstruct sas_rphy *rphy)\r\n{\r\nstruct request *req;\r\nint ret;\r\nint (*handler)(struct Scsi_Host *, struct sas_rphy *, struct request *);\r\nwhile ((req = blk_fetch_request(q)) != NULL) {\r\nspin_unlock_irq(q->queue_lock);\r\nhandler = to_sas_internal(shost->transportt)->f->smp_handler;\r\nret = handler(shost, rphy, req);\r\nreq->errors = ret;\r\nblk_end_request_all(req, ret);\r\nspin_lock_irq(q->queue_lock);\r\n}\r\n}\r\nstatic void sas_host_smp_request(struct request_queue *q)\r\n{\r\nsas_smp_request(q, (struct Scsi_Host *)q->queuedata, NULL);\r\n}\r\nstatic void sas_non_host_smp_request(struct request_queue *q)\r\n{\r\nstruct sas_rphy *rphy = q->queuedata;\r\nsas_smp_request(q, rphy_to_shost(rphy), rphy);\r\n}\r\nstatic void sas_host_release(struct device *dev)\r\n{\r\nstruct Scsi_Host *shost = dev_to_shost(dev);\r\nstruct sas_host_attrs *sas_host = to_sas_host_attrs(shost);\r\nstruct request_queue *q = sas_host->q;\r\nif (q)\r\nblk_cleanup_queue(q);\r\n}\r\nstatic int sas_bsg_initialize(struct Scsi_Host *shost, struct sas_rphy *rphy)\r\n{\r\nstruct request_queue *q;\r\nint error;\r\nstruct device *dev;\r\nchar namebuf[20];\r\nconst char *name;\r\nvoid (*release)(struct device *);\r\nif (!to_sas_internal(shost->transportt)->f->smp_handler) {\r\nprintk("%s can't handle SMP requests\n", shost->hostt->name);\r\nreturn 0;\r\n}\r\nif (rphy) {\r\nq = blk_init_queue(sas_non_host_smp_request, NULL);\r\ndev = &rphy->dev;\r\nname = dev_name(dev);\r\nrelease = NULL;\r\n} else {\r\nq = blk_init_queue(sas_host_smp_request, NULL);\r\ndev = &shost->shost_gendev;\r\nsnprintf(namebuf, sizeof(namebuf),\r\n"sas_host%d", shost->host_no);\r\nname = namebuf;\r\nrelease = sas_host_release;\r\n}\r\nif (!q)\r\nreturn -ENOMEM;\r\nerror = bsg_register_queue(q, dev, name, release);\r\nif (error) {\r\nblk_cleanup_queue(q);\r\nreturn -ENOMEM;\r\n}\r\nif (rphy)\r\nrphy->q = q;\r\nelse\r\nto_sas_host_attrs(shost)->q = q;\r\nif (rphy)\r\nq->queuedata = rphy;\r\nelse\r\nq->queuedata = shost;\r\nqueue_flag_set_unlocked(QUEUE_FLAG_BIDI, q);\r\nreturn 0;\r\n}\r\nstatic void sas_bsg_remove(struct Scsi_Host *shost, struct sas_rphy *rphy)\r\n{\r\nstruct request_queue *q;\r\nif (rphy)\r\nq = rphy->q;\r\nelse\r\nq = to_sas_host_attrs(shost)->q;\r\nif (!q)\r\nreturn;\r\nbsg_unregister_queue(q);\r\n}\r\nstatic int sas_host_setup(struct transport_container *tc, struct device *dev,\r\nstruct device *cdev)\r\n{\r\nstruct Scsi_Host *shost = dev_to_shost(dev);\r\nstruct sas_host_attrs *sas_host = to_sas_host_attrs(shost);\r\nINIT_LIST_HEAD(&sas_host->rphy_list);\r\nmutex_init(&sas_host->lock);\r\nsas_host->next_target_id = 0;\r\nsas_host->next_expander_id = 0;\r\nsas_host->next_port_id = 0;\r\nif (sas_bsg_initialize(shost, NULL))\r\ndev_printk(KERN_ERR, dev, "fail to a bsg device %d\n",\r\nshost->host_no);\r\nreturn 0;\r\n}\r\nstatic int sas_host_remove(struct transport_container *tc, struct device *dev,\r\nstruct device *cdev)\r\n{\r\nstruct Scsi_Host *shost = dev_to_shost(dev);\r\nsas_bsg_remove(shost, NULL);\r\nreturn 0;\r\n}\r\nstatic int sas_host_match(struct attribute_container *cont,\r\nstruct device *dev)\r\n{\r\nstruct Scsi_Host *shost;\r\nstruct sas_internal *i;\r\nif (!scsi_is_host_device(dev))\r\nreturn 0;\r\nshost = dev_to_shost(dev);\r\nif (!shost->transportt)\r\nreturn 0;\r\nif (shost->transportt->host_attrs.ac.class !=\r\n&sas_host_class.class)\r\nreturn 0;\r\ni = to_sas_internal(shost->transportt);\r\nreturn &i->t.host_attrs.ac == cont;\r\n}\r\nstatic int do_sas_phy_delete(struct device *dev, void *data)\r\n{\r\nint pass = (int)(unsigned long)data;\r\nif (pass == 0 && scsi_is_sas_port(dev))\r\nsas_port_delete(dev_to_sas_port(dev));\r\nelse if (pass == 1 && scsi_is_sas_phy(dev))\r\nsas_phy_delete(dev_to_phy(dev));\r\nreturn 0;\r\n}\r\nvoid sas_remove_children(struct device *dev)\r\n{\r\ndevice_for_each_child(dev, (void *)0, do_sas_phy_delete);\r\ndevice_for_each_child(dev, (void *)1, do_sas_phy_delete);\r\n}\r\nvoid sas_remove_host(struct Scsi_Host *shost)\r\n{\r\nsas_remove_children(&shost->shost_gendev);\r\n}\r\nunsigned int\r\nsas_tlr_supported(struct scsi_device *sdev)\r\n{\r\nconst int vpd_len = 32;\r\nstruct sas_end_device *rdev = sas_sdev_to_rdev(sdev);\r\nchar *buffer = kzalloc(vpd_len, GFP_KERNEL);\r\nint ret = 0;\r\nif (scsi_get_vpd_page(sdev, 0x90, buffer, vpd_len))\r\ngoto out;\r\nret = buffer[12] & 0x01;\r\nout:\r\nkfree(buffer);\r\nrdev->tlr_supported = ret;\r\nreturn ret;\r\n}\r\nvoid\r\nsas_disable_tlr(struct scsi_device *sdev)\r\n{\r\nstruct sas_end_device *rdev = sas_sdev_to_rdev(sdev);\r\nrdev->tlr_enabled = 0;\r\n}\r\nvoid sas_enable_tlr(struct scsi_device *sdev)\r\n{\r\nunsigned int tlr_supported = 0;\r\ntlr_supported = sas_tlr_supported(sdev);\r\nif (tlr_supported) {\r\nstruct sas_end_device *rdev = sas_sdev_to_rdev(sdev);\r\nrdev->tlr_enabled = 1;\r\n}\r\nreturn;\r\n}\r\nunsigned int sas_is_tlr_enabled(struct scsi_device *sdev)\r\n{\r\nstruct sas_end_device *rdev = sas_sdev_to_rdev(sdev);\r\nreturn rdev->tlr_enabled;\r\n}\r\nstatic ssize_t\r\nshow_sas_device_type(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct sas_phy *phy = transport_class_to_phy(dev);\r\nif (!phy->identify.device_type)\r\nreturn snprintf(buf, 20, "none\n");\r\nreturn get_sas_device_type_names(phy->identify.device_type, buf);\r\n}\r\nstatic ssize_t do_sas_phy_enable(struct device *dev,\r\nsize_t count, int enable)\r\n{\r\nstruct sas_phy *phy = transport_class_to_phy(dev);\r\nstruct Scsi_Host *shost = dev_to_shost(phy->dev.parent);\r\nstruct sas_internal *i = to_sas_internal(shost->transportt);\r\nint error;\r\nerror = i->f->phy_enable(phy, enable);\r\nif (error)\r\nreturn error;\r\nphy->enabled = enable;\r\nreturn count;\r\n}\r\nstatic ssize_t\r\nstore_sas_phy_enable(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nif (count < 1)\r\nreturn -EINVAL;\r\nswitch (buf[0]) {\r\ncase '0':\r\ndo_sas_phy_enable(dev, count, 0);\r\nbreak;\r\ncase '1':\r\ndo_sas_phy_enable(dev, count, 1);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn count;\r\n}\r\nstatic ssize_t\r\nshow_sas_phy_enable(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct sas_phy *phy = transport_class_to_phy(dev);\r\nreturn snprintf(buf, 20, "%d", phy->enabled);\r\n}\r\nstatic ssize_t\r\ndo_sas_phy_reset(struct device *dev, size_t count, int hard_reset)\r\n{\r\nstruct sas_phy *phy = transport_class_to_phy(dev);\r\nstruct Scsi_Host *shost = dev_to_shost(phy->dev.parent);\r\nstruct sas_internal *i = to_sas_internal(shost->transportt);\r\nint error;\r\nerror = i->f->phy_reset(phy, hard_reset);\r\nif (error)\r\nreturn error;\r\nphy->enabled = 1;\r\nreturn count;\r\n}\r\nstatic ssize_t\r\nstore_sas_link_reset(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nreturn do_sas_phy_reset(dev, count, 0);\r\n}\r\nstatic ssize_t\r\nstore_sas_hard_reset(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nreturn do_sas_phy_reset(dev, count, 1);\r\n}\r\nstatic int sas_phy_setup(struct transport_container *tc, struct device *dev,\r\nstruct device *cdev)\r\n{\r\nstruct sas_phy *phy = dev_to_phy(dev);\r\nstruct Scsi_Host *shost = dev_to_shost(phy->dev.parent);\r\nstruct sas_internal *i = to_sas_internal(shost->transportt);\r\nif (i->f->phy_setup)\r\ni->f->phy_setup(phy);\r\nreturn 0;\r\n}\r\nstatic int sas_phy_match(struct attribute_container *cont, struct device *dev)\r\n{\r\nstruct Scsi_Host *shost;\r\nstruct sas_internal *i;\r\nif (!scsi_is_sas_phy(dev))\r\nreturn 0;\r\nshost = dev_to_shost(dev->parent);\r\nif (!shost->transportt)\r\nreturn 0;\r\nif (shost->transportt->host_attrs.ac.class !=\r\n&sas_host_class.class)\r\nreturn 0;\r\ni = to_sas_internal(shost->transportt);\r\nreturn &i->phy_attr_cont.ac == cont;\r\n}\r\nstatic void sas_phy_release(struct device *dev)\r\n{\r\nstruct sas_phy *phy = dev_to_phy(dev);\r\nstruct Scsi_Host *shost = dev_to_shost(phy->dev.parent);\r\nstruct sas_internal *i = to_sas_internal(shost->transportt);\r\nif (i->f->phy_release)\r\ni->f->phy_release(phy);\r\nput_device(dev->parent);\r\nkfree(phy);\r\n}\r\nstruct sas_phy *sas_phy_alloc(struct device *parent, int number)\r\n{\r\nstruct Scsi_Host *shost = dev_to_shost(parent);\r\nstruct sas_phy *phy;\r\nphy = kzalloc(sizeof(*phy), GFP_KERNEL);\r\nif (!phy)\r\nreturn NULL;\r\nphy->number = number;\r\nphy->enabled = 1;\r\ndevice_initialize(&phy->dev);\r\nphy->dev.parent = get_device(parent);\r\nphy->dev.release = sas_phy_release;\r\nINIT_LIST_HEAD(&phy->port_siblings);\r\nif (scsi_is_sas_expander_device(parent)) {\r\nstruct sas_rphy *rphy = dev_to_rphy(parent);\r\ndev_set_name(&phy->dev, "phy-%d:%d:%d", shost->host_no,\r\nrphy->scsi_target_id, number);\r\n} else\r\ndev_set_name(&phy->dev, "phy-%d:%d", shost->host_no, number);\r\ntransport_setup_device(&phy->dev);\r\nreturn phy;\r\n}\r\nint sas_phy_add(struct sas_phy *phy)\r\n{\r\nint error;\r\nerror = device_add(&phy->dev);\r\nif (!error) {\r\ntransport_add_device(&phy->dev);\r\ntransport_configure_device(&phy->dev);\r\n}\r\nreturn error;\r\n}\r\nvoid sas_phy_free(struct sas_phy *phy)\r\n{\r\ntransport_destroy_device(&phy->dev);\r\nput_device(&phy->dev);\r\n}\r\nvoid\r\nsas_phy_delete(struct sas_phy *phy)\r\n{\r\nstruct device *dev = &phy->dev;\r\nBUG_ON(!list_empty(&phy->port_siblings));\r\ntransport_remove_device(dev);\r\ndevice_del(dev);\r\ntransport_destroy_device(dev);\r\nput_device(dev);\r\n}\r\nint scsi_is_sas_phy(const struct device *dev)\r\n{\r\nreturn dev->release == sas_phy_release;\r\n}\r\nstatic int sas_port_match(struct attribute_container *cont, struct device *dev)\r\n{\r\nstruct Scsi_Host *shost;\r\nstruct sas_internal *i;\r\nif (!scsi_is_sas_port(dev))\r\nreturn 0;\r\nshost = dev_to_shost(dev->parent);\r\nif (!shost->transportt)\r\nreturn 0;\r\nif (shost->transportt->host_attrs.ac.class !=\r\n&sas_host_class.class)\r\nreturn 0;\r\ni = to_sas_internal(shost->transportt);\r\nreturn &i->port_attr_cont.ac == cont;\r\n}\r\nstatic void sas_port_release(struct device *dev)\r\n{\r\nstruct sas_port *port = dev_to_sas_port(dev);\r\nBUG_ON(!list_empty(&port->phy_list));\r\nput_device(dev->parent);\r\nkfree(port);\r\n}\r\nstatic void sas_port_create_link(struct sas_port *port,\r\nstruct sas_phy *phy)\r\n{\r\nint res;\r\nres = sysfs_create_link(&port->dev.kobj, &phy->dev.kobj,\r\ndev_name(&phy->dev));\r\nif (res)\r\ngoto err;\r\nres = sysfs_create_link(&phy->dev.kobj, &port->dev.kobj, "port");\r\nif (res)\r\ngoto err;\r\nreturn;\r\nerr:\r\nprintk(KERN_ERR "%s: Cannot create port links, err=%d\n",\r\n__func__, res);\r\n}\r\nstatic void sas_port_delete_link(struct sas_port *port,\r\nstruct sas_phy *phy)\r\n{\r\nsysfs_remove_link(&port->dev.kobj, dev_name(&phy->dev));\r\nsysfs_remove_link(&phy->dev.kobj, "port");\r\n}\r\nstruct sas_port *sas_port_alloc(struct device *parent, int port_id)\r\n{\r\nstruct Scsi_Host *shost = dev_to_shost(parent);\r\nstruct sas_port *port;\r\nport = kzalloc(sizeof(*port), GFP_KERNEL);\r\nif (!port)\r\nreturn NULL;\r\nport->port_identifier = port_id;\r\ndevice_initialize(&port->dev);\r\nport->dev.parent = get_device(parent);\r\nport->dev.release = sas_port_release;\r\nmutex_init(&port->phy_list_mutex);\r\nINIT_LIST_HEAD(&port->phy_list);\r\nif (scsi_is_sas_expander_device(parent)) {\r\nstruct sas_rphy *rphy = dev_to_rphy(parent);\r\ndev_set_name(&port->dev, "port-%d:%d:%d", shost->host_no,\r\nrphy->scsi_target_id, port->port_identifier);\r\n} else\r\ndev_set_name(&port->dev, "port-%d:%d", shost->host_no,\r\nport->port_identifier);\r\ntransport_setup_device(&port->dev);\r\nreturn port;\r\n}\r\nstruct sas_port *sas_port_alloc_num(struct device *parent)\r\n{\r\nint index;\r\nstruct Scsi_Host *shost = dev_to_shost(parent);\r\nstruct sas_host_attrs *sas_host = to_sas_host_attrs(shost);\r\nmutex_lock(&sas_host->lock);\r\nif (scsi_is_sas_expander_device(parent)) {\r\nstruct sas_rphy *rphy = dev_to_rphy(parent);\r\nstruct sas_expander_device *exp = rphy_to_expander_device(rphy);\r\nindex = exp->next_port_id++;\r\n} else\r\nindex = sas_host->next_port_id++;\r\nmutex_unlock(&sas_host->lock);\r\nreturn sas_port_alloc(parent, index);\r\n}\r\nint sas_port_add(struct sas_port *port)\r\n{\r\nint error;\r\nBUG_ON(!list_empty(&port->phy_list));\r\nerror = device_add(&port->dev);\r\nif (error)\r\nreturn error;\r\ntransport_add_device(&port->dev);\r\ntransport_configure_device(&port->dev);\r\nreturn 0;\r\n}\r\nvoid sas_port_free(struct sas_port *port)\r\n{\r\ntransport_destroy_device(&port->dev);\r\nput_device(&port->dev);\r\n}\r\nvoid sas_port_delete(struct sas_port *port)\r\n{\r\nstruct device *dev = &port->dev;\r\nstruct sas_phy *phy, *tmp_phy;\r\nif (port->rphy) {\r\nsas_rphy_delete(port->rphy);\r\nport->rphy = NULL;\r\n}\r\nmutex_lock(&port->phy_list_mutex);\r\nlist_for_each_entry_safe(phy, tmp_phy, &port->phy_list,\r\nport_siblings) {\r\nsas_port_delete_link(port, phy);\r\nlist_del_init(&phy->port_siblings);\r\n}\r\nmutex_unlock(&port->phy_list_mutex);\r\nif (port->is_backlink) {\r\nstruct device *parent = port->dev.parent;\r\nsysfs_remove_link(&port->dev.kobj, dev_name(parent));\r\nport->is_backlink = 0;\r\n}\r\ntransport_remove_device(dev);\r\ndevice_del(dev);\r\ntransport_destroy_device(dev);\r\nput_device(dev);\r\n}\r\nint scsi_is_sas_port(const struct device *dev)\r\n{\r\nreturn dev->release == sas_port_release;\r\n}\r\nstruct sas_phy *sas_port_get_phy(struct sas_port *port)\r\n{\r\nstruct sas_phy *phy;\r\nmutex_lock(&port->phy_list_mutex);\r\nif (list_empty(&port->phy_list))\r\nphy = NULL;\r\nelse {\r\nstruct list_head *ent = port->phy_list.next;\r\nphy = list_entry(ent, typeof(*phy), port_siblings);\r\nget_device(&phy->dev);\r\n}\r\nmutex_unlock(&port->phy_list_mutex);\r\nreturn phy;\r\n}\r\nvoid sas_port_add_phy(struct sas_port *port, struct sas_phy *phy)\r\n{\r\nmutex_lock(&port->phy_list_mutex);\r\nif (unlikely(!list_empty(&phy->port_siblings))) {\r\nstruct sas_phy *tmp;\r\nlist_for_each_entry(tmp, &port->phy_list, port_siblings)\r\nif (tmp == phy)\r\nbreak;\r\nif (unlikely(tmp != phy)) {\r\ndev_printk(KERN_ERR, &port->dev, "trying to add phy %s fails: it's already part of another port\n",\r\ndev_name(&phy->dev));\r\nBUG();\r\n}\r\n} else {\r\nsas_port_create_link(port, phy);\r\nlist_add_tail(&phy->port_siblings, &port->phy_list);\r\nport->num_phys++;\r\n}\r\nmutex_unlock(&port->phy_list_mutex);\r\n}\r\nvoid sas_port_delete_phy(struct sas_port *port, struct sas_phy *phy)\r\n{\r\nmutex_lock(&port->phy_list_mutex);\r\nsas_port_delete_link(port, phy);\r\nlist_del_init(&phy->port_siblings);\r\nport->num_phys--;\r\nmutex_unlock(&port->phy_list_mutex);\r\n}\r\nvoid sas_port_mark_backlink(struct sas_port *port)\r\n{\r\nint res;\r\nstruct device *parent = port->dev.parent->parent->parent;\r\nif (port->is_backlink)\r\nreturn;\r\nport->is_backlink = 1;\r\nres = sysfs_create_link(&port->dev.kobj, &parent->kobj,\r\ndev_name(parent));\r\nif (res)\r\ngoto err;\r\nreturn;\r\nerr:\r\nprintk(KERN_ERR "%s: Cannot create port backlink, err=%d\n",\r\n__func__, res);\r\n}\r\nstatic ssize_t\r\nshow_sas_rphy_device_type(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct sas_rphy *rphy = transport_class_to_rphy(dev);\r\nif (!rphy->identify.device_type)\r\nreturn snprintf(buf, 20, "none\n");\r\nreturn get_sas_device_type_names(\r\nrphy->identify.device_type, buf);\r\n}\r\nstatic ssize_t\r\nshow_sas_rphy_enclosure_identifier(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct sas_rphy *rphy = transport_class_to_rphy(dev);\r\nstruct sas_phy *phy = dev_to_phy(rphy->dev.parent);\r\nstruct Scsi_Host *shost = dev_to_shost(phy->dev.parent);\r\nstruct sas_internal *i = to_sas_internal(shost->transportt);\r\nu64 identifier;\r\nint error;\r\nif (scsi_is_sas_phy_local(phy))\r\nreturn -EINVAL;\r\nerror = i->f->get_enclosure_identifier(rphy, &identifier);\r\nif (error)\r\nreturn error;\r\nreturn sprintf(buf, "0x%llx\n", (unsigned long long)identifier);\r\n}\r\nstatic ssize_t\r\nshow_sas_rphy_bay_identifier(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct sas_rphy *rphy = transport_class_to_rphy(dev);\r\nstruct sas_phy *phy = dev_to_phy(rphy->dev.parent);\r\nstruct Scsi_Host *shost = dev_to_shost(phy->dev.parent);\r\nstruct sas_internal *i = to_sas_internal(shost->transportt);\r\nint val;\r\nif (scsi_is_sas_phy_local(phy))\r\nreturn -EINVAL;\r\nval = i->f->get_bay_identifier(rphy);\r\nif (val < 0)\r\nreturn val;\r\nreturn sprintf(buf, "%d\n", val);\r\n}\r\nint sas_read_port_mode_page(struct scsi_device *sdev)\r\n{\r\nchar *buffer = kzalloc(BUF_SIZE, GFP_KERNEL), *msdata;\r\nstruct sas_end_device *rdev = sas_sdev_to_rdev(sdev);\r\nstruct scsi_mode_data mode_data;\r\nint res, error;\r\nif (!buffer)\r\nreturn -ENOMEM;\r\nres = scsi_mode_sense(sdev, 1, 0x19, buffer, BUF_SIZE, 30*HZ, 3,\r\n&mode_data, NULL);\r\nerror = -EINVAL;\r\nif (!scsi_status_is_good(res))\r\ngoto out;\r\nmsdata = buffer + mode_data.header_length +\r\nmode_data.block_descriptor_length;\r\nif (msdata - buffer > BUF_SIZE - 8)\r\ngoto out;\r\nerror = 0;\r\nrdev->ready_led_meaning = msdata[2] & 0x10 ? 1 : 0;\r\nrdev->I_T_nexus_loss_timeout = (msdata[4] << 8) + msdata[5];\r\nrdev->initiator_response_timeout = (msdata[6] << 8) + msdata[7];\r\nout:\r\nkfree(buffer);\r\nreturn error;\r\n}\r\nstatic int sas_rphy_match(struct attribute_container *cont, struct device *dev)\r\n{\r\nstruct Scsi_Host *shost;\r\nstruct sas_internal *i;\r\nif (!scsi_is_sas_rphy(dev))\r\nreturn 0;\r\nshost = dev_to_shost(dev->parent->parent);\r\nif (!shost->transportt)\r\nreturn 0;\r\nif (shost->transportt->host_attrs.ac.class !=\r\n&sas_host_class.class)\r\nreturn 0;\r\ni = to_sas_internal(shost->transportt);\r\nreturn &i->rphy_attr_cont.ac == cont;\r\n}\r\nstatic int sas_end_dev_match(struct attribute_container *cont,\r\nstruct device *dev)\r\n{\r\nstruct Scsi_Host *shost;\r\nstruct sas_internal *i;\r\nstruct sas_rphy *rphy;\r\nif (!scsi_is_sas_rphy(dev))\r\nreturn 0;\r\nshost = dev_to_shost(dev->parent->parent);\r\nrphy = dev_to_rphy(dev);\r\nif (!shost->transportt)\r\nreturn 0;\r\nif (shost->transportt->host_attrs.ac.class !=\r\n&sas_host_class.class)\r\nreturn 0;\r\ni = to_sas_internal(shost->transportt);\r\nreturn &i->end_dev_attr_cont.ac == cont &&\r\nrphy->identify.device_type == SAS_END_DEVICE;\r\n}\r\nstatic int sas_expander_match(struct attribute_container *cont,\r\nstruct device *dev)\r\n{\r\nstruct Scsi_Host *shost;\r\nstruct sas_internal *i;\r\nstruct sas_rphy *rphy;\r\nif (!scsi_is_sas_rphy(dev))\r\nreturn 0;\r\nshost = dev_to_shost(dev->parent->parent);\r\nrphy = dev_to_rphy(dev);\r\nif (!shost->transportt)\r\nreturn 0;\r\nif (shost->transportt->host_attrs.ac.class !=\r\n&sas_host_class.class)\r\nreturn 0;\r\ni = to_sas_internal(shost->transportt);\r\nreturn &i->expander_attr_cont.ac == cont &&\r\n(rphy->identify.device_type == SAS_EDGE_EXPANDER_DEVICE ||\r\nrphy->identify.device_type == SAS_FANOUT_EXPANDER_DEVICE);\r\n}\r\nstatic void sas_expander_release(struct device *dev)\r\n{\r\nstruct sas_rphy *rphy = dev_to_rphy(dev);\r\nstruct sas_expander_device *edev = rphy_to_expander_device(rphy);\r\nif (rphy->q)\r\nblk_cleanup_queue(rphy->q);\r\nput_device(dev->parent);\r\nkfree(edev);\r\n}\r\nstatic void sas_end_device_release(struct device *dev)\r\n{\r\nstruct sas_rphy *rphy = dev_to_rphy(dev);\r\nstruct sas_end_device *edev = rphy_to_end_device(rphy);\r\nif (rphy->q)\r\nblk_cleanup_queue(rphy->q);\r\nput_device(dev->parent);\r\nkfree(edev);\r\n}\r\nstatic void sas_rphy_initialize(struct sas_rphy *rphy)\r\n{\r\nINIT_LIST_HEAD(&rphy->list);\r\n}\r\nstruct sas_rphy *sas_end_device_alloc(struct sas_port *parent)\r\n{\r\nstruct Scsi_Host *shost = dev_to_shost(&parent->dev);\r\nstruct sas_end_device *rdev;\r\nrdev = kzalloc(sizeof(*rdev), GFP_KERNEL);\r\nif (!rdev) {\r\nreturn NULL;\r\n}\r\ndevice_initialize(&rdev->rphy.dev);\r\nrdev->rphy.dev.parent = get_device(&parent->dev);\r\nrdev->rphy.dev.release = sas_end_device_release;\r\nif (scsi_is_sas_expander_device(parent->dev.parent)) {\r\nstruct sas_rphy *rphy = dev_to_rphy(parent->dev.parent);\r\ndev_set_name(&rdev->rphy.dev, "end_device-%d:%d:%d",\r\nshost->host_no, rphy->scsi_target_id,\r\nparent->port_identifier);\r\n} else\r\ndev_set_name(&rdev->rphy.dev, "end_device-%d:%d",\r\nshost->host_no, parent->port_identifier);\r\nrdev->rphy.identify.device_type = SAS_END_DEVICE;\r\nsas_rphy_initialize(&rdev->rphy);\r\ntransport_setup_device(&rdev->rphy.dev);\r\nreturn &rdev->rphy;\r\n}\r\nstruct sas_rphy *sas_expander_alloc(struct sas_port *parent,\r\nenum sas_device_type type)\r\n{\r\nstruct Scsi_Host *shost = dev_to_shost(&parent->dev);\r\nstruct sas_expander_device *rdev;\r\nstruct sas_host_attrs *sas_host = to_sas_host_attrs(shost);\r\nBUG_ON(type != SAS_EDGE_EXPANDER_DEVICE &&\r\ntype != SAS_FANOUT_EXPANDER_DEVICE);\r\nrdev = kzalloc(sizeof(*rdev), GFP_KERNEL);\r\nif (!rdev) {\r\nreturn NULL;\r\n}\r\ndevice_initialize(&rdev->rphy.dev);\r\nrdev->rphy.dev.parent = get_device(&parent->dev);\r\nrdev->rphy.dev.release = sas_expander_release;\r\nmutex_lock(&sas_host->lock);\r\nrdev->rphy.scsi_target_id = sas_host->next_expander_id++;\r\nmutex_unlock(&sas_host->lock);\r\ndev_set_name(&rdev->rphy.dev, "expander-%d:%d",\r\nshost->host_no, rdev->rphy.scsi_target_id);\r\nrdev->rphy.identify.device_type = type;\r\nsas_rphy_initialize(&rdev->rphy);\r\ntransport_setup_device(&rdev->rphy.dev);\r\nreturn &rdev->rphy;\r\n}\r\nint sas_rphy_add(struct sas_rphy *rphy)\r\n{\r\nstruct sas_port *parent = dev_to_sas_port(rphy->dev.parent);\r\nstruct Scsi_Host *shost = dev_to_shost(parent->dev.parent);\r\nstruct sas_host_attrs *sas_host = to_sas_host_attrs(shost);\r\nstruct sas_identify *identify = &rphy->identify;\r\nint error;\r\nif (parent->rphy)\r\nreturn -ENXIO;\r\nparent->rphy = rphy;\r\nerror = device_add(&rphy->dev);\r\nif (error)\r\nreturn error;\r\ntransport_add_device(&rphy->dev);\r\ntransport_configure_device(&rphy->dev);\r\nif (sas_bsg_initialize(shost, rphy))\r\nprintk("fail to a bsg device %s\n", dev_name(&rphy->dev));\r\nmutex_lock(&sas_host->lock);\r\nlist_add_tail(&rphy->list, &sas_host->rphy_list);\r\nif (identify->device_type == SAS_END_DEVICE &&\r\n(identify->target_port_protocols &\r\n(SAS_PROTOCOL_SSP|SAS_PROTOCOL_STP|SAS_PROTOCOL_SATA)))\r\nrphy->scsi_target_id = sas_host->next_target_id++;\r\nelse if (identify->device_type == SAS_END_DEVICE)\r\nrphy->scsi_target_id = -1;\r\nmutex_unlock(&sas_host->lock);\r\nif (identify->device_type == SAS_END_DEVICE &&\r\nrphy->scsi_target_id != -1) {\r\nint lun;\r\nif (identify->target_port_protocols & SAS_PROTOCOL_SSP)\r\nlun = SCAN_WILD_CARD;\r\nelse\r\nlun = 0;\r\nscsi_scan_target(&rphy->dev, 0, rphy->scsi_target_id, lun, 0);\r\n}\r\nreturn 0;\r\n}\r\nvoid sas_rphy_free(struct sas_rphy *rphy)\r\n{\r\nstruct device *dev = &rphy->dev;\r\nstruct Scsi_Host *shost = dev_to_shost(rphy->dev.parent->parent);\r\nstruct sas_host_attrs *sas_host = to_sas_host_attrs(shost);\r\nmutex_lock(&sas_host->lock);\r\nlist_del(&rphy->list);\r\nmutex_unlock(&sas_host->lock);\r\nsas_bsg_remove(shost, rphy);\r\ntransport_destroy_device(dev);\r\nput_device(dev);\r\n}\r\nvoid\r\nsas_rphy_delete(struct sas_rphy *rphy)\r\n{\r\nsas_rphy_remove(rphy);\r\nsas_rphy_free(rphy);\r\n}\r\nvoid sas_rphy_unlink(struct sas_rphy *rphy)\r\n{\r\nstruct sas_port *parent = dev_to_sas_port(rphy->dev.parent);\r\nparent->rphy = NULL;\r\n}\r\nvoid\r\nsas_rphy_remove(struct sas_rphy *rphy)\r\n{\r\nstruct device *dev = &rphy->dev;\r\nswitch (rphy->identify.device_type) {\r\ncase SAS_END_DEVICE:\r\nscsi_remove_target(dev);\r\nbreak;\r\ncase SAS_EDGE_EXPANDER_DEVICE:\r\ncase SAS_FANOUT_EXPANDER_DEVICE:\r\nsas_remove_children(dev);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nsas_rphy_unlink(rphy);\r\ntransport_remove_device(dev);\r\ndevice_del(dev);\r\n}\r\nint scsi_is_sas_rphy(const struct device *dev)\r\n{\r\nreturn dev->release == sas_end_device_release ||\r\ndev->release == sas_expander_release;\r\n}\r\nstatic int sas_user_scan(struct Scsi_Host *shost, uint channel,\r\nuint id, uint lun)\r\n{\r\nstruct sas_host_attrs *sas_host = to_sas_host_attrs(shost);\r\nstruct sas_rphy *rphy;\r\nmutex_lock(&sas_host->lock);\r\nlist_for_each_entry(rphy, &sas_host->rphy_list, list) {\r\nif (rphy->identify.device_type != SAS_END_DEVICE ||\r\nrphy->scsi_target_id == -1)\r\ncontinue;\r\nif ((channel == SCAN_WILD_CARD || channel == 0) &&\r\n(id == SCAN_WILD_CARD || id == rphy->scsi_target_id)) {\r\nscsi_scan_target(&rphy->dev, 0,\r\nrphy->scsi_target_id, lun, 1);\r\n}\r\n}\r\nmutex_unlock(&sas_host->lock);\r\nreturn 0;\r\n}\r\nstruct scsi_transport_template *\r\nsas_attach_transport(struct sas_function_template *ft)\r\n{\r\nstruct sas_internal *i;\r\nint count;\r\ni = kzalloc(sizeof(struct sas_internal), GFP_KERNEL);\r\nif (!i)\r\nreturn NULL;\r\ni->t.user_scan = sas_user_scan;\r\ni->t.host_attrs.ac.attrs = &i->host_attrs[0];\r\ni->t.host_attrs.ac.class = &sas_host_class.class;\r\ni->t.host_attrs.ac.match = sas_host_match;\r\ntransport_container_register(&i->t.host_attrs);\r\ni->t.host_size = sizeof(struct sas_host_attrs);\r\ni->phy_attr_cont.ac.class = &sas_phy_class.class;\r\ni->phy_attr_cont.ac.attrs = &i->phy_attrs[0];\r\ni->phy_attr_cont.ac.match = sas_phy_match;\r\ntransport_container_register(&i->phy_attr_cont);\r\ni->port_attr_cont.ac.class = &sas_port_class.class;\r\ni->port_attr_cont.ac.attrs = &i->port_attrs[0];\r\ni->port_attr_cont.ac.match = sas_port_match;\r\ntransport_container_register(&i->port_attr_cont);\r\ni->rphy_attr_cont.ac.class = &sas_rphy_class.class;\r\ni->rphy_attr_cont.ac.attrs = &i->rphy_attrs[0];\r\ni->rphy_attr_cont.ac.match = sas_rphy_match;\r\ntransport_container_register(&i->rphy_attr_cont);\r\ni->end_dev_attr_cont.ac.class = &sas_end_dev_class.class;\r\ni->end_dev_attr_cont.ac.attrs = &i->end_dev_attrs[0];\r\ni->end_dev_attr_cont.ac.match = sas_end_dev_match;\r\ntransport_container_register(&i->end_dev_attr_cont);\r\ni->expander_attr_cont.ac.class = &sas_expander_class.class;\r\ni->expander_attr_cont.ac.attrs = &i->expander_attrs[0];\r\ni->expander_attr_cont.ac.match = sas_expander_match;\r\ntransport_container_register(&i->expander_attr_cont);\r\ni->f = ft;\r\ncount = 0;\r\nSETUP_PHY_ATTRIBUTE(initiator_port_protocols);\r\nSETUP_PHY_ATTRIBUTE(target_port_protocols);\r\nSETUP_PHY_ATTRIBUTE(device_type);\r\nSETUP_PHY_ATTRIBUTE(sas_address);\r\nSETUP_PHY_ATTRIBUTE(phy_identifier);\r\nSETUP_PHY_ATTRIBUTE(negotiated_linkrate);\r\nSETUP_PHY_ATTRIBUTE(minimum_linkrate_hw);\r\nSETUP_PHY_ATTRIBUTE_RW(minimum_linkrate);\r\nSETUP_PHY_ATTRIBUTE(maximum_linkrate_hw);\r\nSETUP_PHY_ATTRIBUTE_RW(maximum_linkrate);\r\nSETUP_PHY_ATTRIBUTE(invalid_dword_count);\r\nSETUP_PHY_ATTRIBUTE(running_disparity_error_count);\r\nSETUP_PHY_ATTRIBUTE(loss_of_dword_sync_count);\r\nSETUP_PHY_ATTRIBUTE(phy_reset_problem_count);\r\nSETUP_OPTIONAL_PHY_ATTRIBUTE_WRONLY(link_reset, phy_reset);\r\nSETUP_OPTIONAL_PHY_ATTRIBUTE_WRONLY(hard_reset, phy_reset);\r\nSETUP_OPTIONAL_PHY_ATTRIBUTE_RW(enable, phy_enable);\r\ni->phy_attrs[count] = NULL;\r\ncount = 0;\r\nSETUP_PORT_ATTRIBUTE(num_phys);\r\ni->port_attrs[count] = NULL;\r\ncount = 0;\r\nSETUP_RPORT_ATTRIBUTE(rphy_initiator_port_protocols);\r\nSETUP_RPORT_ATTRIBUTE(rphy_target_port_protocols);\r\nSETUP_RPORT_ATTRIBUTE(rphy_device_type);\r\nSETUP_RPORT_ATTRIBUTE(rphy_sas_address);\r\nSETUP_RPORT_ATTRIBUTE(rphy_phy_identifier);\r\nSETUP_OPTIONAL_RPORT_ATTRIBUTE(rphy_enclosure_identifier,\r\nget_enclosure_identifier);\r\nSETUP_OPTIONAL_RPORT_ATTRIBUTE(rphy_bay_identifier,\r\nget_bay_identifier);\r\ni->rphy_attrs[count] = NULL;\r\ncount = 0;\r\nSETUP_END_DEV_ATTRIBUTE(end_dev_ready_led_meaning);\r\nSETUP_END_DEV_ATTRIBUTE(end_dev_I_T_nexus_loss_timeout);\r\nSETUP_END_DEV_ATTRIBUTE(end_dev_initiator_response_timeout);\r\nSETUP_END_DEV_ATTRIBUTE(end_dev_tlr_supported);\r\nSETUP_END_DEV_ATTRIBUTE(end_dev_tlr_enabled);\r\ni->end_dev_attrs[count] = NULL;\r\ncount = 0;\r\nSETUP_EXPANDER_ATTRIBUTE(vendor_id);\r\nSETUP_EXPANDER_ATTRIBUTE(product_id);\r\nSETUP_EXPANDER_ATTRIBUTE(product_rev);\r\nSETUP_EXPANDER_ATTRIBUTE(component_vendor_id);\r\nSETUP_EXPANDER_ATTRIBUTE(component_id);\r\nSETUP_EXPANDER_ATTRIBUTE(component_revision_id);\r\nSETUP_EXPANDER_ATTRIBUTE(level);\r\ni->expander_attrs[count] = NULL;\r\nreturn &i->t;\r\n}\r\nvoid sas_release_transport(struct scsi_transport_template *t)\r\n{\r\nstruct sas_internal *i = to_sas_internal(t);\r\ntransport_container_unregister(&i->t.host_attrs);\r\ntransport_container_unregister(&i->phy_attr_cont);\r\ntransport_container_unregister(&i->port_attr_cont);\r\ntransport_container_unregister(&i->rphy_attr_cont);\r\ntransport_container_unregister(&i->end_dev_attr_cont);\r\ntransport_container_unregister(&i->expander_attr_cont);\r\nkfree(i);\r\n}\r\nstatic __init int sas_transport_init(void)\r\n{\r\nint error;\r\nerror = transport_class_register(&sas_host_class);\r\nif (error)\r\ngoto out;\r\nerror = transport_class_register(&sas_phy_class);\r\nif (error)\r\ngoto out_unregister_transport;\r\nerror = transport_class_register(&sas_port_class);\r\nif (error)\r\ngoto out_unregister_phy;\r\nerror = transport_class_register(&sas_rphy_class);\r\nif (error)\r\ngoto out_unregister_port;\r\nerror = transport_class_register(&sas_end_dev_class);\r\nif (error)\r\ngoto out_unregister_rphy;\r\nerror = transport_class_register(&sas_expander_class);\r\nif (error)\r\ngoto out_unregister_end_dev;\r\nreturn 0;\r\nout_unregister_end_dev:\r\ntransport_class_unregister(&sas_end_dev_class);\r\nout_unregister_rphy:\r\ntransport_class_unregister(&sas_rphy_class);\r\nout_unregister_port:\r\ntransport_class_unregister(&sas_port_class);\r\nout_unregister_phy:\r\ntransport_class_unregister(&sas_phy_class);\r\nout_unregister_transport:\r\ntransport_class_unregister(&sas_host_class);\r\nout:\r\nreturn error;\r\n}\r\nstatic void __exit sas_transport_exit(void)\r\n{\r\ntransport_class_unregister(&sas_host_class);\r\ntransport_class_unregister(&sas_phy_class);\r\ntransport_class_unregister(&sas_port_class);\r\ntransport_class_unregister(&sas_rphy_class);\r\ntransport_class_unregister(&sas_end_dev_class);\r\ntransport_class_unregister(&sas_expander_class);\r\n}
