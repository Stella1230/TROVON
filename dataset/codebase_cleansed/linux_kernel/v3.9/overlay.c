int omap_dss_get_num_overlays(void)\r\n{\r\nreturn num_overlays;\r\n}\r\nstruct omap_overlay *omap_dss_get_overlay(int num)\r\n{\r\nif (num >= num_overlays)\r\nreturn NULL;\r\nreturn &overlays[num];\r\n}\r\nvoid dss_init_overlays(struct platform_device *pdev)\r\n{\r\nint i, r;\r\nnum_overlays = dss_feat_get_num_ovls();\r\noverlays = kzalloc(sizeof(struct omap_overlay) * num_overlays,\r\nGFP_KERNEL);\r\nBUG_ON(overlays == NULL);\r\nfor (i = 0; i < num_overlays; ++i) {\r\nstruct omap_overlay *ovl = &overlays[i];\r\nswitch (i) {\r\ncase 0:\r\novl->name = "gfx";\r\novl->id = OMAP_DSS_GFX;\r\nbreak;\r\ncase 1:\r\novl->name = "vid1";\r\novl->id = OMAP_DSS_VIDEO1;\r\nbreak;\r\ncase 2:\r\novl->name = "vid2";\r\novl->id = OMAP_DSS_VIDEO2;\r\nbreak;\r\ncase 3:\r\novl->name = "vid3";\r\novl->id = OMAP_DSS_VIDEO3;\r\nbreak;\r\n}\r\novl->caps = dss_feat_get_overlay_caps(ovl->id);\r\novl->supported_modes =\r\ndss_feat_get_supported_color_modes(ovl->id);\r\nr = dss_overlay_kobj_init(ovl, pdev);\r\nif (r)\r\nDSSERR("failed to create sysfs file\n");\r\n}\r\n}\r\nvoid dss_uninit_overlays(struct platform_device *pdev)\r\n{\r\nint i;\r\nfor (i = 0; i < num_overlays; ++i) {\r\nstruct omap_overlay *ovl = &overlays[i];\r\ndss_overlay_kobj_uninit(ovl);\r\n}\r\nkfree(overlays);\r\noverlays = NULL;\r\nnum_overlays = 0;\r\n}\r\nint dss_ovl_simple_check(struct omap_overlay *ovl,\r\nconst struct omap_overlay_info *info)\r\n{\r\nif (info->paddr == 0) {\r\nDSSERR("check_overlay: paddr cannot be 0\n");\r\nreturn -EINVAL;\r\n}\r\nif ((ovl->caps & OMAP_DSS_OVL_CAP_SCALE) == 0) {\r\nif (info->out_width != 0 && info->width != info->out_width) {\r\nDSSERR("check_overlay: overlay %d doesn't support "\r\n"scaling\n", ovl->id);\r\nreturn -EINVAL;\r\n}\r\nif (info->out_height != 0 && info->height != info->out_height) {\r\nDSSERR("check_overlay: overlay %d doesn't support "\r\n"scaling\n", ovl->id);\r\nreturn -EINVAL;\r\n}\r\n}\r\nif ((ovl->supported_modes & info->color_mode) == 0) {\r\nDSSERR("check_overlay: overlay %d doesn't support mode %d\n",\r\novl->id, info->color_mode);\r\nreturn -EINVAL;\r\n}\r\nif (info->zorder >= omap_dss_get_num_overlays()) {\r\nDSSERR("check_overlay: zorder %d too high\n", info->zorder);\r\nreturn -EINVAL;\r\n}\r\nif (dss_feat_rotation_type_supported(info->rotation_type) == 0) {\r\nDSSERR("check_overlay: rotation type %d not supported\n",\r\ninfo->rotation_type);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nint dss_ovl_check(struct omap_overlay *ovl, struct omap_overlay_info *info,\r\nconst struct omap_video_timings *mgr_timings)\r\n{\r\nu16 outw, outh;\r\nu16 dw, dh;\r\ndw = mgr_timings->x_res;\r\ndh = mgr_timings->y_res;\r\nif ((ovl->caps & OMAP_DSS_OVL_CAP_SCALE) == 0) {\r\noutw = info->width;\r\nouth = info->height;\r\n} else {\r\nif (info->out_width == 0)\r\noutw = info->width;\r\nelse\r\noutw = info->out_width;\r\nif (info->out_height == 0)\r\nouth = info->height;\r\nelse\r\nouth = info->out_height;\r\n}\r\nif (dw < info->pos_x + outw) {\r\nDSSERR("overlay %d horizontally not inside the display area "\r\n"(%d + %d >= %d)\n",\r\novl->id, info->pos_x, outw, dw);\r\nreturn -EINVAL;\r\n}\r\nif (dh < info->pos_y + outh) {\r\nDSSERR("overlay %d vertically not inside the display area "\r\n"(%d + %d >= %d)\n",\r\novl->id, info->pos_y, outh, dh);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nbool dss_ovl_use_replication(struct dss_lcd_mgr_config config,\r\nenum omap_color_mode mode)\r\n{\r\nif (mode != OMAP_DSS_COLOR_RGB12U && mode != OMAP_DSS_COLOR_RGB16)\r\nreturn false;\r\nreturn config.video_port_width > 16;\r\n}
