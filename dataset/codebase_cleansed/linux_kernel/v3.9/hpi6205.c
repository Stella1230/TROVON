static void subsys_message(struct hpi_adapter_obj *pao,\r\nstruct hpi_message *phm, struct hpi_response *phr)\r\n{\r\nswitch (phm->function) {\r\ncase HPI_SUBSYS_CREATE_ADAPTER:\r\nsubsys_create_adapter(phm, phr);\r\nbreak;\r\ndefault:\r\nphr->error = HPI_ERROR_INVALID_FUNC;\r\nbreak;\r\n}\r\n}\r\nstatic void control_message(struct hpi_adapter_obj *pao,\r\nstruct hpi_message *phm, struct hpi_response *phr)\r\n{\r\nstruct hpi_hw_obj *phw = pao->priv;\r\nu16 pending_cache_error = 0;\r\nswitch (phm->function) {\r\ncase HPI_CONTROL_GET_STATE:\r\nif (pao->has_control_cache) {\r\nrmb();\r\nif (hpi_check_control_cache(phw->p_cache, phm, phr)) {\r\nbreak;\r\n} else if (phm->u.c.attribute == HPI_METER_PEAK) {\r\npending_cache_error =\r\nHPI_ERROR_CONTROL_CACHING;\r\n}\r\n}\r\nhw_message(pao, phm, phr);\r\nif (pending_cache_error && !phr->error)\r\nphr->error = pending_cache_error;\r\nbreak;\r\ncase HPI_CONTROL_GET_INFO:\r\nhw_message(pao, phm, phr);\r\nbreak;\r\ncase HPI_CONTROL_SET_STATE:\r\nhw_message(pao, phm, phr);\r\nif (pao->has_control_cache)\r\nhpi_cmn_control_cache_sync_to_msg(phw->p_cache, phm,\r\nphr);\r\nbreak;\r\ndefault:\r\nphr->error = HPI_ERROR_INVALID_FUNC;\r\nbreak;\r\n}\r\n}\r\nstatic void adapter_message(struct hpi_adapter_obj *pao,\r\nstruct hpi_message *phm, struct hpi_response *phr)\r\n{\r\nswitch (phm->function) {\r\ncase HPI_ADAPTER_DELETE:\r\nadapter_delete(pao, phm, phr);\r\nbreak;\r\ndefault:\r\nhw_message(pao, phm, phr);\r\nbreak;\r\n}\r\n}\r\nstatic void outstream_message(struct hpi_adapter_obj *pao,\r\nstruct hpi_message *phm, struct hpi_response *phr)\r\n{\r\nif (phm->obj_index >= HPI_MAX_STREAMS) {\r\nphr->error = HPI_ERROR_INVALID_OBJ_INDEX;\r\nHPI_DEBUG_LOG(WARNING,\r\n"Message referencing invalid stream %d "\r\n"on adapter index %d\n", phm->obj_index,\r\nphm->adapter_index);\r\nreturn;\r\n}\r\nswitch (phm->function) {\r\ncase HPI_OSTREAM_WRITE:\r\noutstream_write(pao, phm, phr);\r\nbreak;\r\ncase HPI_OSTREAM_GET_INFO:\r\noutstream_get_info(pao, phm, phr);\r\nbreak;\r\ncase HPI_OSTREAM_HOSTBUFFER_ALLOC:\r\noutstream_host_buffer_allocate(pao, phm, phr);\r\nbreak;\r\ncase HPI_OSTREAM_HOSTBUFFER_GET_INFO:\r\noutstream_host_buffer_get_info(pao, phm, phr);\r\nbreak;\r\ncase HPI_OSTREAM_HOSTBUFFER_FREE:\r\noutstream_host_buffer_free(pao, phm, phr);\r\nbreak;\r\ncase HPI_OSTREAM_START:\r\noutstream_start(pao, phm, phr);\r\nbreak;\r\ncase HPI_OSTREAM_OPEN:\r\noutstream_open(pao, phm, phr);\r\nbreak;\r\ncase HPI_OSTREAM_RESET:\r\noutstream_reset(pao, phm, phr);\r\nbreak;\r\ndefault:\r\nhw_message(pao, phm, phr);\r\nbreak;\r\n}\r\n}\r\nstatic void instream_message(struct hpi_adapter_obj *pao,\r\nstruct hpi_message *phm, struct hpi_response *phr)\r\n{\r\nif (phm->obj_index >= HPI_MAX_STREAMS) {\r\nphr->error = HPI_ERROR_INVALID_OBJ_INDEX;\r\nHPI_DEBUG_LOG(WARNING,\r\n"Message referencing invalid stream %d "\r\n"on adapter index %d\n", phm->obj_index,\r\nphm->adapter_index);\r\nreturn;\r\n}\r\nswitch (phm->function) {\r\ncase HPI_ISTREAM_READ:\r\ninstream_read(pao, phm, phr);\r\nbreak;\r\ncase HPI_ISTREAM_GET_INFO:\r\ninstream_get_info(pao, phm, phr);\r\nbreak;\r\ncase HPI_ISTREAM_HOSTBUFFER_ALLOC:\r\ninstream_host_buffer_allocate(pao, phm, phr);\r\nbreak;\r\ncase HPI_ISTREAM_HOSTBUFFER_GET_INFO:\r\ninstream_host_buffer_get_info(pao, phm, phr);\r\nbreak;\r\ncase HPI_ISTREAM_HOSTBUFFER_FREE:\r\ninstream_host_buffer_free(pao, phm, phr);\r\nbreak;\r\ncase HPI_ISTREAM_START:\r\ninstream_start(pao, phm, phr);\r\nbreak;\r\ndefault:\r\nhw_message(pao, phm, phr);\r\nbreak;\r\n}\r\n}\r\nstatic\r\nvoid _HPI_6205(struct hpi_adapter_obj *pao, struct hpi_message *phm,\r\nstruct hpi_response *phr)\r\n{\r\nif (pao && (pao->dsp_crashed >= 10)\r\n&& (phm->function != HPI_ADAPTER_DEBUG_READ)) {\r\nhpi_init_response(phr, phm->object, phm->function,\r\nHPI_ERROR_DSP_HARDWARE);\r\nHPI_DEBUG_LOG(WARNING, " %d,%d dsp crashed.\n", phm->object,\r\nphm->function);\r\nreturn;\r\n}\r\nif (phm->function != HPI_SUBSYS_CREATE_ADAPTER)\r\nphr->error = HPI_ERROR_PROCESSING_MESSAGE;\r\nHPI_DEBUG_LOG(VERBOSE, "start of switch\n");\r\nswitch (phm->type) {\r\ncase HPI_TYPE_REQUEST:\r\nswitch (phm->object) {\r\ncase HPI_OBJ_SUBSYSTEM:\r\nsubsys_message(pao, phm, phr);\r\nbreak;\r\ncase HPI_OBJ_ADAPTER:\r\nadapter_message(pao, phm, phr);\r\nbreak;\r\ncase HPI_OBJ_CONTROL:\r\ncontrol_message(pao, phm, phr);\r\nbreak;\r\ncase HPI_OBJ_OSTREAM:\r\noutstream_message(pao, phm, phr);\r\nbreak;\r\ncase HPI_OBJ_ISTREAM:\r\ninstream_message(pao, phm, phr);\r\nbreak;\r\ndefault:\r\nhw_message(pao, phm, phr);\r\nbreak;\r\n}\r\nbreak;\r\ndefault:\r\nphr->error = HPI_ERROR_INVALID_TYPE;\r\nbreak;\r\n}\r\n}\r\nvoid HPI_6205(struct hpi_message *phm, struct hpi_response *phr)\r\n{\r\nstruct hpi_adapter_obj *pao = NULL;\r\nif (phm->object != HPI_OBJ_SUBSYSTEM) {\r\npao = hpi_find_adapter(phm->adapter_index);\r\n} else {\r\n_HPI_6205(NULL, phm, phr);\r\nreturn;\r\n}\r\nif (pao)\r\n_HPI_6205(pao, phm, phr);\r\nelse\r\nhpi_init_response(phr, phm->object, phm->function,\r\nHPI_ERROR_BAD_ADAPTER_NUMBER);\r\n}\r\nstatic void subsys_create_adapter(struct hpi_message *phm,\r\nstruct hpi_response *phr)\r\n{\r\nstruct hpi_adapter_obj ao;\r\nu32 os_error_code;\r\nu16 err;\r\nHPI_DEBUG_LOG(DEBUG, " subsys_create_adapter\n");\r\nmemset(&ao, 0, sizeof(ao));\r\nao.priv = kzalloc(sizeof(struct hpi_hw_obj), GFP_KERNEL);\r\nif (!ao.priv) {\r\nHPI_DEBUG_LOG(ERROR, "can't get mem for adapter object\n");\r\nphr->error = HPI_ERROR_MEMORY_ALLOC;\r\nreturn;\r\n}\r\nao.pci = *phm->u.s.resource.r.pci;\r\nerr = create_adapter_obj(&ao, &os_error_code);\r\nif (err) {\r\ndelete_adapter_obj(&ao);\r\nif (err >= HPI_ERROR_BACKEND_BASE) {\r\nphr->error = HPI_ERROR_DSP_BOOTLOAD;\r\nphr->specific_error = err;\r\n} else {\r\nphr->error = err;\r\n}\r\nphr->u.s.data = os_error_code;\r\nreturn;\r\n}\r\nphr->u.s.adapter_type = ao.type;\r\nphr->u.s.adapter_index = ao.index;\r\nphr->error = 0;\r\n}\r\nstatic void adapter_delete(struct hpi_adapter_obj *pao,\r\nstruct hpi_message *phm, struct hpi_response *phr)\r\n{\r\nstruct hpi_hw_obj *phw;\r\nif (!pao) {\r\nphr->error = HPI_ERROR_INVALID_OBJ_INDEX;\r\nreturn;\r\n}\r\nphw = pao->priv;\r\nboot_loader_write_mem32(pao, 0, C6205_BAR0_TIMER1_CTL, 0);\r\niowrite32(C6205_HDCR_WARMRESET, phw->prHDCR);\r\ndelete_adapter_obj(pao);\r\nhpi_delete_adapter(pao);\r\nphr->error = 0;\r\n}\r\nstatic u16 create_adapter_obj(struct hpi_adapter_obj *pao,\r\nu32 *pos_error_code)\r\n{\r\nstruct hpi_hw_obj *phw = pao->priv;\r\nstruct bus_master_interface *interface;\r\nu32 phys_addr;\r\nint i;\r\nu16 err;\r\npao->dsp_crashed = 0;\r\nfor (i = 0; i < HPI_MAX_STREAMS; i++)\r\nphw->flag_outstream_just_reset[i] = 1;\r\nphw->prHSR =\r\npao->pci.ap_mem_base[1] +\r\nC6205_BAR1_HSR / sizeof(*pao->pci.ap_mem_base[1]);\r\nphw->prHDCR =\r\npao->pci.ap_mem_base[1] +\r\nC6205_BAR1_HDCR / sizeof(*pao->pci.ap_mem_base[1]);\r\nphw->prDSPP =\r\npao->pci.ap_mem_base[1] +\r\nC6205_BAR1_DSPP / sizeof(*pao->pci.ap_mem_base[1]);\r\npao->has_control_cache = 0;\r\nif (hpios_locked_mem_alloc(&phw->h_locked_mem,\r\nsizeof(struct bus_master_interface),\r\npao->pci.pci_dev))\r\nphw->p_interface_buffer = NULL;\r\nelse if (hpios_locked_mem_get_virt_addr(&phw->h_locked_mem,\r\n(void *)&phw->p_interface_buffer))\r\nphw->p_interface_buffer = NULL;\r\nHPI_DEBUG_LOG(DEBUG, "interface buffer address %p\n",\r\nphw->p_interface_buffer);\r\nif (phw->p_interface_buffer) {\r\nmemset((void *)phw->p_interface_buffer, 0,\r\nsizeof(struct bus_master_interface));\r\nphw->p_interface_buffer->dsp_ack = H620_HIF_UNKNOWN;\r\n}\r\nerr = adapter_boot_load_dsp(pao, pos_error_code);\r\nif (err) {\r\nHPI_DEBUG_LOG(ERROR, "DSP code load failed\n");\r\nreturn err;\r\n}\r\nHPI_DEBUG_LOG(INFO, "load DSP code OK\n");\r\nif (!phw->p_interface_buffer)\r\nreturn HPI_ERROR_MEMORY_ALLOC;\r\ninterface = phw->p_interface_buffer;\r\nif (!wait_dsp_ack(phw, H620_HIF_RESET, HPI6205_TIMEOUT * 10)) {\r\nHPI_DEBUG_LOG(ERROR, "timed out waiting reset state \n");\r\nreturn HPI6205_ERROR_6205_INIT_FAILED;\r\n}\r\nif (interface->control_cache.number_of_controls) {\r\nu8 *p_control_cache_virtual;\r\nerr = hpios_locked_mem_alloc(&phw->h_control_cache,\r\ninterface->control_cache.size_in_bytes,\r\npao->pci.pci_dev);\r\nif (!err)\r\nerr = hpios_locked_mem_get_virt_addr(&phw->\r\nh_control_cache,\r\n(void *)&p_control_cache_virtual);\r\nif (!err) {\r\nmemset(p_control_cache_virtual, 0,\r\ninterface->control_cache.size_in_bytes);\r\nphw->p_cache =\r\nhpi_alloc_control_cache(interface->\r\ncontrol_cache.number_of_controls,\r\ninterface->control_cache.size_in_bytes,\r\np_control_cache_virtual);\r\nif (!phw->p_cache)\r\nerr = HPI_ERROR_MEMORY_ALLOC;\r\n}\r\nif (!err) {\r\nerr = hpios_locked_mem_get_phys_addr(&phw->\r\nh_control_cache, &phys_addr);\r\ninterface->control_cache.physical_address32 =\r\nphys_addr;\r\n}\r\nif (!err)\r\npao->has_control_cache = 1;\r\nelse {\r\nif (hpios_locked_mem_valid(&phw->h_control_cache))\r\nhpios_locked_mem_free(&phw->h_control_cache);\r\npao->has_control_cache = 0;\r\n}\r\n}\r\nsend_dsp_command(phw, H620_HIF_IDLE);\r\n{\r\nstruct hpi_message hm;\r\nstruct hpi_response hr;\r\nu32 max_streams;\r\nHPI_DEBUG_LOG(VERBOSE, "init ADAPTER_GET_INFO\n");\r\nmemset(&hm, 0, sizeof(hm));\r\nhm.type = HPI_TYPE_REQUEST;\r\nhm.size = sizeof(hm);\r\nhm.object = HPI_OBJ_ADAPTER;\r\nhm.function = HPI_ADAPTER_GET_INFO;\r\nmemset(&hr, 0, sizeof(hr));\r\nhr.size = sizeof(hr);\r\nerr = message_response_sequence(pao, &hm, &hr);\r\nif (err) {\r\nHPI_DEBUG_LOG(ERROR, "message transport error %d\n",\r\nerr);\r\nreturn err;\r\n}\r\nif (hr.error)\r\nreturn hr.error;\r\npao->type = hr.u.ax.info.adapter_type;\r\npao->index = hr.u.ax.info.adapter_index;\r\nmax_streams =\r\nhr.u.ax.info.num_outstreams +\r\nhr.u.ax.info.num_instreams;\r\nHPI_DEBUG_LOG(VERBOSE,\r\n"got adapter info type %x index %d serial %d\n",\r\nhr.u.ax.info.adapter_type, hr.u.ax.info.adapter_index,\r\nhr.u.ax.info.serial_number);\r\n}\r\nif (phw->p_cache)\r\nphw->p_cache->adap_idx = pao->index;\r\nHPI_DEBUG_LOG(INFO, "bootload DSP OK\n");\r\nreturn hpi_add_adapter(pao);\r\n}\r\nstatic void delete_adapter_obj(struct hpi_adapter_obj *pao)\r\n{\r\nstruct hpi_hw_obj *phw = pao->priv;\r\nint i;\r\nif (hpios_locked_mem_valid(&phw->h_control_cache)) {\r\nhpios_locked_mem_free(&phw->h_control_cache);\r\nhpi_free_control_cache(phw->p_cache);\r\n}\r\nif (hpios_locked_mem_valid(&phw->h_locked_mem)) {\r\nhpios_locked_mem_free(&phw->h_locked_mem);\r\nphw->p_interface_buffer = NULL;\r\n}\r\nfor (i = 0; i < HPI_MAX_STREAMS; i++)\r\nif (hpios_locked_mem_valid(&phw->instream_host_buffers[i])) {\r\nhpios_locked_mem_free(&phw->instream_host_buffers[i]);\r\nphw->instream_host_buffer_size[i] = 0;\r\n}\r\nfor (i = 0; i < HPI_MAX_STREAMS; i++)\r\nif (hpios_locked_mem_valid(&phw->outstream_host_buffers[i])) {\r\nhpios_locked_mem_free(&phw->outstream_host_buffers\r\n[i]);\r\nphw->outstream_host_buffer_size[i] = 0;\r\n}\r\nkfree(phw);\r\n}\r\nstatic void outstream_host_buffer_allocate(struct hpi_adapter_obj *pao,\r\nstruct hpi_message *phm, struct hpi_response *phr)\r\n{\r\nu16 err = 0;\r\nu32 command = phm->u.d.u.buffer.command;\r\nstruct hpi_hw_obj *phw = pao->priv;\r\nstruct bus_master_interface *interface = phw->p_interface_buffer;\r\nhpi_init_response(phr, phm->object, phm->function, 0);\r\nif (command == HPI_BUFFER_CMD_EXTERNAL\r\n|| command == HPI_BUFFER_CMD_INTERNAL_ALLOC) {\r\nphm->u.d.u.buffer.buffer_size =\r\nroundup_pow_of_two(phm->u.d.u.buffer.buffer_size);\r\nphr->u.d.u.stream_info.data_available =\r\nphw->outstream_host_buffer_size[phm->obj_index];\r\nphr->u.d.u.stream_info.buffer_size =\r\nphm->u.d.u.buffer.buffer_size;\r\nif (phw->outstream_host_buffer_size[phm->obj_index] ==\r\nphm->u.d.u.buffer.buffer_size) {\r\nreturn;\r\n}\r\nif (hpios_locked_mem_valid(&phw->outstream_host_buffers[phm->\r\nobj_index]))\r\nhpios_locked_mem_free(&phw->outstream_host_buffers\r\n[phm->obj_index]);\r\nerr = hpios_locked_mem_alloc(&phw->outstream_host_buffers\r\n[phm->obj_index], phm->u.d.u.buffer.buffer_size,\r\npao->pci.pci_dev);\r\nif (err) {\r\nphr->error = HPI_ERROR_INVALID_DATASIZE;\r\nphw->outstream_host_buffer_size[phm->obj_index] = 0;\r\nreturn;\r\n}\r\nerr = hpios_locked_mem_get_phys_addr\r\n(&phw->outstream_host_buffers[phm->obj_index],\r\n&phm->u.d.u.buffer.pci_address);\r\nphr->u.d.u.stream_info.auxiliary_data_available =\r\nphm->u.d.u.buffer.pci_address;\r\nif (err) {\r\nhpios_locked_mem_free(&phw->outstream_host_buffers\r\n[phm->obj_index]);\r\nphw->outstream_host_buffer_size[phm->obj_index] = 0;\r\nphr->error = HPI_ERROR_MEMORY_ALLOC;\r\nreturn;\r\n}\r\n}\r\nif (command == HPI_BUFFER_CMD_EXTERNAL\r\n|| command == HPI_BUFFER_CMD_INTERNAL_GRANTADAPTER) {\r\nstruct hpi_hostbuffer_status *status;\r\nif (phm->u.d.u.buffer.buffer_size & (phm->u.d.u.buffer.\r\nbuffer_size - 1)) {\r\nHPI_DEBUG_LOG(ERROR,\r\n"Buffer size must be 2^N not %d\n",\r\nphm->u.d.u.buffer.buffer_size);\r\nphr->error = HPI_ERROR_INVALID_DATASIZE;\r\nreturn;\r\n}\r\nphw->outstream_host_buffer_size[phm->obj_index] =\r\nphm->u.d.u.buffer.buffer_size;\r\nstatus = &interface->outstream_host_buffer_status[phm->\r\nobj_index];\r\nstatus->samples_processed = 0;\r\nstatus->stream_state = HPI_STATE_STOPPED;\r\nstatus->dsp_index = 0;\r\nstatus->host_index = status->dsp_index;\r\nstatus->size_in_bytes = phm->u.d.u.buffer.buffer_size;\r\nstatus->auxiliary_data_available = 0;\r\nhw_message(pao, phm, phr);\r\nif (phr->error\r\n&& hpios_locked_mem_valid(&phw->\r\noutstream_host_buffers[phm->obj_index])) {\r\nhpios_locked_mem_free(&phw->outstream_host_buffers\r\n[phm->obj_index]);\r\nphw->outstream_host_buffer_size[phm->obj_index] = 0;\r\n}\r\n}\r\n}\r\nstatic void outstream_host_buffer_get_info(struct hpi_adapter_obj *pao,\r\nstruct hpi_message *phm, struct hpi_response *phr)\r\n{\r\nstruct hpi_hw_obj *phw = pao->priv;\r\nstruct bus_master_interface *interface = phw->p_interface_buffer;\r\nstruct hpi_hostbuffer_status *status;\r\nu8 *p_bbm_data;\r\nif (hpios_locked_mem_valid(&phw->outstream_host_buffers[phm->\r\nobj_index])) {\r\nif (hpios_locked_mem_get_virt_addr(&phw->\r\noutstream_host_buffers[phm->obj_index],\r\n(void *)&p_bbm_data)) {\r\nphr->error = HPI_ERROR_INVALID_OPERATION;\r\nreturn;\r\n}\r\nstatus = &interface->outstream_host_buffer_status[phm->\r\nobj_index];\r\nhpi_init_response(phr, HPI_OBJ_OSTREAM,\r\nHPI_OSTREAM_HOSTBUFFER_GET_INFO, 0);\r\nphr->u.d.u.hostbuffer_info.p_buffer = p_bbm_data;\r\nphr->u.d.u.hostbuffer_info.p_status = status;\r\n} else {\r\nhpi_init_response(phr, HPI_OBJ_OSTREAM,\r\nHPI_OSTREAM_HOSTBUFFER_GET_INFO,\r\nHPI_ERROR_INVALID_OPERATION);\r\n}\r\n}\r\nstatic void outstream_host_buffer_free(struct hpi_adapter_obj *pao,\r\nstruct hpi_message *phm, struct hpi_response *phr)\r\n{\r\nstruct hpi_hw_obj *phw = pao->priv;\r\nu32 command = phm->u.d.u.buffer.command;\r\nif (phw->outstream_host_buffer_size[phm->obj_index]) {\r\nif (command == HPI_BUFFER_CMD_EXTERNAL\r\n|| command == HPI_BUFFER_CMD_INTERNAL_REVOKEADAPTER) {\r\nphw->outstream_host_buffer_size[phm->obj_index] = 0;\r\nhw_message(pao, phm, phr);\r\n}\r\nif (command == HPI_BUFFER_CMD_EXTERNAL\r\n|| command == HPI_BUFFER_CMD_INTERNAL_FREE)\r\nhpios_locked_mem_free(&phw->outstream_host_buffers\r\n[phm->obj_index]);\r\n}\r\nelse\r\nhpi_init_response(phr, HPI_OBJ_OSTREAM,\r\nHPI_OSTREAM_HOSTBUFFER_FREE, 0);\r\n}\r\nstatic u32 outstream_get_space_available(struct hpi_hostbuffer_status *status)\r\n{\r\nreturn status->size_in_bytes - (status->host_index -\r\nstatus->dsp_index);\r\n}\r\nstatic void outstream_write(struct hpi_adapter_obj *pao,\r\nstruct hpi_message *phm, struct hpi_response *phr)\r\n{\r\nstruct hpi_hw_obj *phw = pao->priv;\r\nstruct bus_master_interface *interface = phw->p_interface_buffer;\r\nstruct hpi_hostbuffer_status *status;\r\nu32 space_available;\r\nif (!phw->outstream_host_buffer_size[phm->obj_index]) {\r\nhw_message(pao, phm, phr);\r\nreturn;\r\n}\r\nhpi_init_response(phr, phm->object, phm->function, 0);\r\nstatus = &interface->outstream_host_buffer_status[phm->obj_index];\r\nspace_available = outstream_get_space_available(status);\r\nif (space_available < phm->u.d.u.data.data_size) {\r\nphr->error = HPI_ERROR_INVALID_DATASIZE;\r\nreturn;\r\n}\r\nif (phm->u.d.u.data.pb_data\r\n&& hpios_locked_mem_valid(&phw->outstream_host_buffers[phm->\r\nobj_index])) {\r\nu8 *p_bbm_data;\r\nu32 l_first_write;\r\nu8 *p_app_data = (u8 *)phm->u.d.u.data.pb_data;\r\nif (hpios_locked_mem_get_virt_addr(&phw->\r\noutstream_host_buffers[phm->obj_index],\r\n(void *)&p_bbm_data)) {\r\nphr->error = HPI_ERROR_INVALID_OPERATION;\r\nreturn;\r\n}\r\nl_first_write =\r\nmin(phm->u.d.u.data.data_size,\r\nstatus->size_in_bytes -\r\n(status->host_index & (status->size_in_bytes - 1)));\r\nmemcpy(p_bbm_data +\r\n(status->host_index & (status->size_in_bytes - 1)),\r\np_app_data, l_first_write);\r\nmemcpy(p_bbm_data, p_app_data + l_first_write,\r\nphm->u.d.u.data.data_size - l_first_write);\r\n}\r\nif (phw->flag_outstream_just_reset[phm->obj_index]) {\r\nu16 function = phm->function;\r\nphw->flag_outstream_just_reset[phm->obj_index] = 0;\r\nphm->function = HPI_OSTREAM_SET_FORMAT;\r\nhw_message(pao, phm, phr);\r\nphm->function = function;\r\nif (phr->error)\r\nreturn;\r\n}\r\nstatus->host_index += phm->u.d.u.data.data_size;\r\n}\r\nstatic void outstream_get_info(struct hpi_adapter_obj *pao,\r\nstruct hpi_message *phm, struct hpi_response *phr)\r\n{\r\nstruct hpi_hw_obj *phw = pao->priv;\r\nstruct bus_master_interface *interface = phw->p_interface_buffer;\r\nstruct hpi_hostbuffer_status *status;\r\nif (!phw->outstream_host_buffer_size[phm->obj_index]) {\r\nhw_message(pao, phm, phr);\r\nreturn;\r\n}\r\nhpi_init_response(phr, phm->object, phm->function, 0);\r\nstatus = &interface->outstream_host_buffer_status[phm->obj_index];\r\nphr->u.d.u.stream_info.state = (u16)status->stream_state;\r\nphr->u.d.u.stream_info.samples_transferred =\r\nstatus->samples_processed;\r\nphr->u.d.u.stream_info.buffer_size = status->size_in_bytes;\r\nphr->u.d.u.stream_info.data_available =\r\nstatus->size_in_bytes - outstream_get_space_available(status);\r\nphr->u.d.u.stream_info.auxiliary_data_available =\r\nstatus->auxiliary_data_available;\r\n}\r\nstatic void outstream_start(struct hpi_adapter_obj *pao,\r\nstruct hpi_message *phm, struct hpi_response *phr)\r\n{\r\nhw_message(pao, phm, phr);\r\n}\r\nstatic void outstream_reset(struct hpi_adapter_obj *pao,\r\nstruct hpi_message *phm, struct hpi_response *phr)\r\n{\r\nstruct hpi_hw_obj *phw = pao->priv;\r\nphw->flag_outstream_just_reset[phm->obj_index] = 1;\r\nhw_message(pao, phm, phr);\r\n}\r\nstatic void outstream_open(struct hpi_adapter_obj *pao,\r\nstruct hpi_message *phm, struct hpi_response *phr)\r\n{\r\noutstream_reset(pao, phm, phr);\r\n}\r\nstatic void instream_host_buffer_allocate(struct hpi_adapter_obj *pao,\r\nstruct hpi_message *phm, struct hpi_response *phr)\r\n{\r\nu16 err = 0;\r\nu32 command = phm->u.d.u.buffer.command;\r\nstruct hpi_hw_obj *phw = pao->priv;\r\nstruct bus_master_interface *interface = phw->p_interface_buffer;\r\nhpi_init_response(phr, phm->object, phm->function, 0);\r\nif (command == HPI_BUFFER_CMD_EXTERNAL\r\n|| command == HPI_BUFFER_CMD_INTERNAL_ALLOC) {\r\nphm->u.d.u.buffer.buffer_size =\r\nroundup_pow_of_two(phm->u.d.u.buffer.buffer_size);\r\nphr->u.d.u.stream_info.data_available =\r\nphw->instream_host_buffer_size[phm->obj_index];\r\nphr->u.d.u.stream_info.buffer_size =\r\nphm->u.d.u.buffer.buffer_size;\r\nif (phw->instream_host_buffer_size[phm->obj_index] ==\r\nphm->u.d.u.buffer.buffer_size) {\r\nreturn;\r\n}\r\nif (hpios_locked_mem_valid(&phw->instream_host_buffers[phm->\r\nobj_index]))\r\nhpios_locked_mem_free(&phw->instream_host_buffers\r\n[phm->obj_index]);\r\nerr = hpios_locked_mem_alloc(&phw->instream_host_buffers[phm->\r\nobj_index], phm->u.d.u.buffer.buffer_size,\r\npao->pci.pci_dev);\r\nif (err) {\r\nphr->error = HPI_ERROR_INVALID_DATASIZE;\r\nphw->instream_host_buffer_size[phm->obj_index] = 0;\r\nreturn;\r\n}\r\nerr = hpios_locked_mem_get_phys_addr\r\n(&phw->instream_host_buffers[phm->obj_index],\r\n&phm->u.d.u.buffer.pci_address);\r\nphr->u.d.u.stream_info.auxiliary_data_available =\r\nphm->u.d.u.buffer.pci_address;\r\nif (err) {\r\nhpios_locked_mem_free(&phw->instream_host_buffers\r\n[phm->obj_index]);\r\nphw->instream_host_buffer_size[phm->obj_index] = 0;\r\nphr->error = HPI_ERROR_MEMORY_ALLOC;\r\nreturn;\r\n}\r\n}\r\nif (command == HPI_BUFFER_CMD_EXTERNAL\r\n|| command == HPI_BUFFER_CMD_INTERNAL_GRANTADAPTER) {\r\nstruct hpi_hostbuffer_status *status;\r\nif (phm->u.d.u.buffer.buffer_size & (phm->u.d.u.buffer.\r\nbuffer_size - 1)) {\r\nHPI_DEBUG_LOG(ERROR,\r\n"Buffer size must be 2^N not %d\n",\r\nphm->u.d.u.buffer.buffer_size);\r\nphr->error = HPI_ERROR_INVALID_DATASIZE;\r\nreturn;\r\n}\r\nphw->instream_host_buffer_size[phm->obj_index] =\r\nphm->u.d.u.buffer.buffer_size;\r\nstatus = &interface->instream_host_buffer_status[phm->\r\nobj_index];\r\nstatus->samples_processed = 0;\r\nstatus->stream_state = HPI_STATE_STOPPED;\r\nstatus->dsp_index = 0;\r\nstatus->host_index = status->dsp_index;\r\nstatus->size_in_bytes = phm->u.d.u.buffer.buffer_size;\r\nstatus->auxiliary_data_available = 0;\r\nhw_message(pao, phm, phr);\r\nif (phr->error\r\n&& hpios_locked_mem_valid(&phw->\r\ninstream_host_buffers[phm->obj_index])) {\r\nhpios_locked_mem_free(&phw->instream_host_buffers\r\n[phm->obj_index]);\r\nphw->instream_host_buffer_size[phm->obj_index] = 0;\r\n}\r\n}\r\n}\r\nstatic void instream_host_buffer_get_info(struct hpi_adapter_obj *pao,\r\nstruct hpi_message *phm, struct hpi_response *phr)\r\n{\r\nstruct hpi_hw_obj *phw = pao->priv;\r\nstruct bus_master_interface *interface = phw->p_interface_buffer;\r\nstruct hpi_hostbuffer_status *status;\r\nu8 *p_bbm_data;\r\nif (hpios_locked_mem_valid(&phw->instream_host_buffers[phm->\r\nobj_index])) {\r\nif (hpios_locked_mem_get_virt_addr(&phw->\r\ninstream_host_buffers[phm->obj_index],\r\n(void *)&p_bbm_data)) {\r\nphr->error = HPI_ERROR_INVALID_OPERATION;\r\nreturn;\r\n}\r\nstatus = &interface->instream_host_buffer_status[phm->\r\nobj_index];\r\nhpi_init_response(phr, HPI_OBJ_ISTREAM,\r\nHPI_ISTREAM_HOSTBUFFER_GET_INFO, 0);\r\nphr->u.d.u.hostbuffer_info.p_buffer = p_bbm_data;\r\nphr->u.d.u.hostbuffer_info.p_status = status;\r\n} else {\r\nhpi_init_response(phr, HPI_OBJ_ISTREAM,\r\nHPI_ISTREAM_HOSTBUFFER_GET_INFO,\r\nHPI_ERROR_INVALID_OPERATION);\r\n}\r\n}\r\nstatic void instream_host_buffer_free(struct hpi_adapter_obj *pao,\r\nstruct hpi_message *phm, struct hpi_response *phr)\r\n{\r\nstruct hpi_hw_obj *phw = pao->priv;\r\nu32 command = phm->u.d.u.buffer.command;\r\nif (phw->instream_host_buffer_size[phm->obj_index]) {\r\nif (command == HPI_BUFFER_CMD_EXTERNAL\r\n|| command == HPI_BUFFER_CMD_INTERNAL_REVOKEADAPTER) {\r\nphw->instream_host_buffer_size[phm->obj_index] = 0;\r\nhw_message(pao, phm, phr);\r\n}\r\nif (command == HPI_BUFFER_CMD_EXTERNAL\r\n|| command == HPI_BUFFER_CMD_INTERNAL_FREE)\r\nhpios_locked_mem_free(&phw->instream_host_buffers\r\n[phm->obj_index]);\r\n} else {\r\nhpi_init_response(phr, HPI_OBJ_ISTREAM,\r\nHPI_ISTREAM_HOSTBUFFER_FREE, 0);\r\n}\r\n}\r\nstatic void instream_start(struct hpi_adapter_obj *pao,\r\nstruct hpi_message *phm, struct hpi_response *phr)\r\n{\r\nhw_message(pao, phm, phr);\r\n}\r\nstatic u32 instream_get_bytes_available(struct hpi_hostbuffer_status *status)\r\n{\r\nreturn status->dsp_index - status->host_index;\r\n}\r\nstatic void instream_read(struct hpi_adapter_obj *pao,\r\nstruct hpi_message *phm, struct hpi_response *phr)\r\n{\r\nstruct hpi_hw_obj *phw = pao->priv;\r\nstruct bus_master_interface *interface = phw->p_interface_buffer;\r\nstruct hpi_hostbuffer_status *status;\r\nu32 data_available;\r\nu8 *p_bbm_data;\r\nu32 l_first_read;\r\nu8 *p_app_data = (u8 *)phm->u.d.u.data.pb_data;\r\nif (!phw->instream_host_buffer_size[phm->obj_index]) {\r\nhw_message(pao, phm, phr);\r\nreturn;\r\n}\r\nhpi_init_response(phr, phm->object, phm->function, 0);\r\nstatus = &interface->instream_host_buffer_status[phm->obj_index];\r\ndata_available = instream_get_bytes_available(status);\r\nif (data_available < phm->u.d.u.data.data_size) {\r\nphr->error = HPI_ERROR_INVALID_DATASIZE;\r\nreturn;\r\n}\r\nif (hpios_locked_mem_valid(&phw->instream_host_buffers[phm->\r\nobj_index])) {\r\nif (hpios_locked_mem_get_virt_addr(&phw->\r\ninstream_host_buffers[phm->obj_index],\r\n(void *)&p_bbm_data)) {\r\nphr->error = HPI_ERROR_INVALID_OPERATION;\r\nreturn;\r\n}\r\nl_first_read =\r\nmin(phm->u.d.u.data.data_size,\r\nstatus->size_in_bytes -\r\n(status->host_index & (status->size_in_bytes - 1)));\r\nmemcpy(p_app_data,\r\np_bbm_data +\r\n(status->host_index & (status->size_in_bytes - 1)),\r\nl_first_read);\r\nmemcpy(p_app_data + l_first_read, p_bbm_data,\r\nphm->u.d.u.data.data_size - l_first_read);\r\n}\r\nstatus->host_index += phm->u.d.u.data.data_size;\r\n}\r\nstatic void instream_get_info(struct hpi_adapter_obj *pao,\r\nstruct hpi_message *phm, struct hpi_response *phr)\r\n{\r\nstruct hpi_hw_obj *phw = pao->priv;\r\nstruct bus_master_interface *interface = phw->p_interface_buffer;\r\nstruct hpi_hostbuffer_status *status;\r\nif (!phw->instream_host_buffer_size[phm->obj_index]) {\r\nhw_message(pao, phm, phr);\r\nreturn;\r\n}\r\nstatus = &interface->instream_host_buffer_status[phm->obj_index];\r\nhpi_init_response(phr, phm->object, phm->function, 0);\r\nphr->u.d.u.stream_info.state = (u16)status->stream_state;\r\nphr->u.d.u.stream_info.samples_transferred =\r\nstatus->samples_processed;\r\nphr->u.d.u.stream_info.buffer_size = status->size_in_bytes;\r\nphr->u.d.u.stream_info.data_available =\r\ninstream_get_bytes_available(status);\r\nphr->u.d.u.stream_info.auxiliary_data_available =\r\nstatus->auxiliary_data_available;\r\n}\r\nstatic u16 adapter_boot_load_dsp(struct hpi_adapter_obj *pao,\r\nu32 *pos_error_code)\r\n{\r\nstruct hpi_hw_obj *phw = pao->priv;\r\nstruct dsp_code dsp_code;\r\nu16 boot_code_id[HPI6205_MAX_FILES_TO_LOAD];\r\nu32 temp;\r\nint dsp = 0, i = 0;\r\nu16 err = 0;\r\nboot_code_id[0] = HPI_ADAPTER_ASI(0x6205);\r\nboot_code_id[1] = pao->pci.pci_dev->subsystem_device;\r\nboot_code_id[1] = HPI_ADAPTER_FAMILY_ASI(boot_code_id[1]);\r\nswitch (boot_code_id[1]) {\r\ncase HPI_ADAPTER_FAMILY_ASI(0x5000):\r\nboot_code_id[0] = boot_code_id[1];\r\nboot_code_id[1] = 0;\r\nbreak;\r\ncase HPI_ADAPTER_FAMILY_ASI(0x5300):\r\ncase HPI_ADAPTER_FAMILY_ASI(0x5400):\r\ncase HPI_ADAPTER_FAMILY_ASI(0x6300):\r\nboot_code_id[1] = HPI_ADAPTER_FAMILY_ASI(0x6400);\r\nbreak;\r\ncase HPI_ADAPTER_FAMILY_ASI(0x5500):\r\ncase HPI_ADAPTER_FAMILY_ASI(0x5600):\r\ncase HPI_ADAPTER_FAMILY_ASI(0x6500):\r\nboot_code_id[1] = HPI_ADAPTER_FAMILY_ASI(0x6600);\r\nbreak;\r\ncase HPI_ADAPTER_FAMILY_ASI(0x8800):\r\nboot_code_id[1] = HPI_ADAPTER_FAMILY_ASI(0x8900);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\ntemp = C6205_HDCR_WARMRESET;\r\niowrite32(temp, phw->prHDCR);\r\nhpios_delay_micro_seconds(1000);\r\ntemp = ioread32(phw->prHSR);\r\nif ((temp & (C6205_HSR_CFGERR | C6205_HSR_EEREAD)) !=\r\nC6205_HSR_EEREAD)\r\nreturn HPI6205_ERROR_6205_EEPROM;\r\ntemp |= 0x04;\r\niowrite32(temp, phw->prHSR);\r\ntemp = ioread32(phw->prHDCR);\r\nif (!(temp & C6205_HDCR_PCIBOOT))\r\nreturn HPI6205_ERROR_6205_REG;\r\ntemp = 3;\r\niowrite32(temp, phw->prDSPP);\r\nif ((temp | C6205_DSPP_MAP1) != ioread32(phw->prDSPP))\r\nreturn HPI6205_ERROR_6205_DSPPAGE;\r\ntemp = 2;\r\niowrite32(temp, phw->prDSPP);\r\nif ((temp | C6205_DSPP_MAP1) != ioread32(phw->prDSPP))\r\nreturn HPI6205_ERROR_6205_DSPPAGE;\r\ntemp = 1;\r\niowrite32(temp, phw->prDSPP);\r\nif ((temp | C6205_DSPP_MAP1) != ioread32(phw->prDSPP))\r\nreturn HPI6205_ERROR_6205_DSPPAGE;\r\ntemp = 0;\r\niowrite32(temp, phw->prDSPP);\r\nif ((temp | C6205_DSPP_MAP1) != ioread32(phw->prDSPP))\r\nreturn HPI6205_ERROR_6205_DSPPAGE;\r\nphw->dsp_page = 0;\r\nif (boot_code_id[1] != 0) {\r\nboot_loader_write_mem32(pao, 0, (0x018C0024L), 0x00002202);\r\nhpios_delay_micro_seconds(100);\r\nboot_loader_write_mem32(pao, 0, C6205_BAR0_TIMER1_CTL, 0);\r\nboot_loader_read_mem32(pao, 0, 0);\r\nhpios_delay_micro_seconds(100);\r\nboot_loader_write_mem32(pao, 0, C6205_BAR0_TIMER1_CTL, 4);\r\nhpios_delay_micro_seconds(100);\r\n}\r\nfor (dsp = 0; dsp < HPI6205_MAX_FILES_TO_LOAD; dsp++) {\r\nif (boot_code_id[dsp] == 0)\r\ncontinue;\r\nerr = boot_loader_config_emif(pao, dsp);\r\nif (err)\r\nreturn err;\r\nerr = boot_loader_test_internal_memory(pao, dsp);\r\nif (err)\r\nreturn err;\r\nerr = boot_loader_test_external_memory(pao, dsp);\r\nif (err)\r\nreturn err;\r\nerr = boot_loader_test_pld(pao, dsp);\r\nif (err)\r\nreturn err;\r\nerr = hpi_dsp_code_open(boot_code_id[dsp], pao->pci.pci_dev,\r\n&dsp_code, pos_error_code);\r\nif (err)\r\nreturn err;\r\nwhile (1) {\r\nu32 length;\r\nu32 address;\r\nu32 type;\r\nu32 *pcode;\r\nerr = hpi_dsp_code_read_word(&dsp_code, &length);\r\nif (err)\r\nbreak;\r\nif (length == 0xFFFFFFFF)\r\nbreak;\r\nerr = hpi_dsp_code_read_word(&dsp_code, &address);\r\nif (err)\r\nbreak;\r\nerr = hpi_dsp_code_read_word(&dsp_code, &type);\r\nif (err)\r\nbreak;\r\nerr = hpi_dsp_code_read_block(length, &dsp_code,\r\n&pcode);\r\nif (err)\r\nbreak;\r\nfor (i = 0; i < (int)length; i++) {\r\nboot_loader_write_mem32(pao, dsp, address,\r\n*pcode);\r\nif (i % 4 == 0)\r\nboot_loader_read_mem32(pao, dsp,\r\naddress);\r\npcode++;\r\naddress += 4;\r\n}\r\n}\r\nif (err) {\r\nhpi_dsp_code_close(&dsp_code);\r\nreturn err;\r\n}\r\nhpi_dsp_code_rewind(&dsp_code);\r\nwhile (1) {\r\nu32 length = 0;\r\nu32 address = 0;\r\nu32 type = 0;\r\nu32 *pcode = NULL;\r\nu32 data = 0;\r\nhpi_dsp_code_read_word(&dsp_code, &length);\r\nif (length == 0xFFFFFFFF)\r\nbreak;\r\nhpi_dsp_code_read_word(&dsp_code, &address);\r\nhpi_dsp_code_read_word(&dsp_code, &type);\r\nhpi_dsp_code_read_block(length, &dsp_code, &pcode);\r\nfor (i = 0; i < (int)length; i++) {\r\ndata = boot_loader_read_mem32(pao, dsp,\r\naddress);\r\nif (data != *pcode) {\r\nerr = 0;\r\nbreak;\r\n}\r\npcode++;\r\naddress += 4;\r\n}\r\nif (err)\r\nbreak;\r\n}\r\nhpi_dsp_code_close(&dsp_code);\r\nif (err)\r\nreturn err;\r\n}\r\nif (phw->p_interface_buffer) {\r\nu32 physicalPC_iaddress;\r\nstruct bus_master_interface *interface =\r\nphw->p_interface_buffer;\r\nu32 host_mailbox_address_on_dsp;\r\nu32 physicalPC_iaddress_verify = 0;\r\nint time_out = 10;\r\ninterface->dsp_ack = H620_HIF_UNKNOWN;\r\nwmb();\r\nerr = hpios_locked_mem_get_phys_addr(&phw->h_locked_mem,\r\n&physicalPC_iaddress);\r\nhost_mailbox_address_on_dsp = 0x80000000;\r\nwhile ((physicalPC_iaddress != physicalPC_iaddress_verify)\r\n&& time_out--) {\r\nboot_loader_write_mem32(pao, 0,\r\nhost_mailbox_address_on_dsp,\r\nphysicalPC_iaddress);\r\nphysicalPC_iaddress_verify =\r\nboot_loader_read_mem32(pao, 0,\r\nhost_mailbox_address_on_dsp);\r\n}\r\n}\r\nHPI_DEBUG_LOG(DEBUG, "starting DS_ps running\n");\r\ntemp = ioread32(phw->prHSR);\r\ntemp &= ~(u32)C6205_HSR_INTAM;\r\niowrite32(temp, phw->prHSR);\r\ntemp = ioread32(phw->prHDCR);\r\ntemp |= (u32)C6205_HDCR_DSPINT;\r\niowrite32(temp, phw->prHDCR);\r\nhpios_delay_micro_seconds(10000);\r\nreturn err;\r\n}\r\nstatic u32 boot_loader_read_mem32(struct hpi_adapter_obj *pao, int dsp_index,\r\nu32 address)\r\n{\r\nstruct hpi_hw_obj *phw = pao->priv;\r\nu32 data = 0;\r\n__iomem u32 *p_data;\r\nif (dsp_index == 0) {\r\nif ((address >= 0x01800000) & (address < 0x02000000)) {\r\np_data = pao->pci.ap_mem_base[1] +\r\n(address & 0x007fffff) /\r\nsizeof(*pao->pci.ap_mem_base[1]);\r\n} else {\r\nu32 dw4M_page = address >> 22L;\r\nif (dw4M_page != phw->dsp_page) {\r\nphw->dsp_page = dw4M_page;\r\niowrite32(phw->dsp_page, phw->prDSPP);\r\n}\r\naddress &= 0x3fffff;\r\np_data = pao->pci.ap_mem_base[0] +\r\naddress / sizeof(u32);\r\n}\r\ndata = ioread32(p_data);\r\n} else if (dsp_index == 1) {\r\nu32 lsb;\r\nboot_loader_write_mem32(pao, 0, HPIAL_ADDR, address);\r\nboot_loader_write_mem32(pao, 0, HPIAH_ADDR, address >> 16);\r\nlsb = boot_loader_read_mem32(pao, 0, HPIDL_ADDR);\r\ndata = boot_loader_read_mem32(pao, 0, HPIDH_ADDR);\r\ndata = (data << 16) | (lsb & 0xFFFF);\r\n}\r\nreturn data;\r\n}\r\nstatic void boot_loader_write_mem32(struct hpi_adapter_obj *pao,\r\nint dsp_index, u32 address, u32 data)\r\n{\r\nstruct hpi_hw_obj *phw = pao->priv;\r\n__iomem u32 *p_data;\r\nif (dsp_index == 0) {\r\nif ((address >= 0x01800000) & (address < 0x02000000)) {\r\np_data = pao->pci.ap_mem_base[1] +\r\n(address & 0x007fffff) /\r\nsizeof(*pao->pci.ap_mem_base[1]);\r\n} else {\r\nu32 dw4M_page = address >> 22L;\r\nif (dw4M_page != phw->dsp_page) {\r\nphw->dsp_page = dw4M_page;\r\niowrite32(phw->dsp_page, phw->prDSPP);\r\n}\r\naddress &= 0x3fffff;\r\np_data = pao->pci.ap_mem_base[0] +\r\naddress / sizeof(u32);\r\n}\r\niowrite32(data, p_data);\r\n} else if (dsp_index == 1) {\r\nboot_loader_write_mem32(pao, 0, HPIAL_ADDR, address);\r\nboot_loader_write_mem32(pao, 0, HPIAH_ADDR, address >> 16);\r\nboot_loader_read_mem32(pao, 0, 0);\r\nboot_loader_write_mem32(pao, 0, HPIDL_ADDR, data);\r\nboot_loader_write_mem32(pao, 0, HPIDH_ADDR, data >> 16);\r\nboot_loader_read_mem32(pao, 0, 0);\r\n}\r\n}\r\nstatic u16 boot_loader_config_emif(struct hpi_adapter_obj *pao, int dsp_index)\r\n{\r\nif (dsp_index == 0) {\r\nu32 setting;\r\nboot_loader_write_mem32(pao, dsp_index, 0x01800000, 0x3779);\r\n#define WS_OFS 28\r\n#define WST_OFS 22\r\n#define WH_OFS 20\r\n#define RS_OFS 16\r\n#define RST_OFS 8\r\n#define MTYPE_OFS 4\r\n#define RH_OFS 0\r\nsetting = 0x00000030;\r\nboot_loader_write_mem32(pao, dsp_index, 0x01800008, setting);\r\nif (setting != boot_loader_read_mem32(pao, dsp_index,\r\n0x01800008))\r\nreturn HPI6205_ERROR_DSP_EMIF1;\r\nsetting =\r\n(1L << WS_OFS) | (63L << WST_OFS) | (1L << WH_OFS) |\r\n(1L << RS_OFS) | (63L << RST_OFS) | (1L << RH_OFS) |\r\n(2L << MTYPE_OFS);\r\nboot_loader_write_mem32(pao, dsp_index, 0x01800004, setting);\r\nif (setting != boot_loader_read_mem32(pao, dsp_index,\r\n0x01800004))\r\nreturn HPI6205_ERROR_DSP_EMIF2;\r\nsetting =\r\n(1L << WS_OFS) | (28L << WST_OFS) | (1L << WH_OFS) |\r\n(1L << RS_OFS) | (63L << RST_OFS) | (1L << RH_OFS) |\r\n(2L << MTYPE_OFS);\r\nboot_loader_write_mem32(pao, dsp_index, 0x01800010, setting);\r\nif (setting != boot_loader_read_mem32(pao, dsp_index,\r\n0x01800010))\r\nreturn HPI6205_ERROR_DSP_EMIF3;\r\nsetting =\r\n(1L << WS_OFS) | (10L << WST_OFS) | (1L << WH_OFS) |\r\n(1L << RS_OFS) | (10L << RST_OFS) | (1L << RH_OFS) |\r\n(2L << MTYPE_OFS);\r\nboot_loader_write_mem32(pao, dsp_index, 0x01800014, setting);\r\nif (setting != boot_loader_read_mem32(pao, dsp_index,\r\n0x01800014))\r\nreturn HPI6205_ERROR_DSP_EMIF4;\r\nboot_loader_write_mem32(pao, dsp_index, 0x01800018,\r\n0x07117000);\r\nboot_loader_write_mem32(pao, dsp_index, 0x0180001C,\r\n0x00000410);\r\n} else if (dsp_index == 1) {\r\nu32 write_data = 0, read_data = 0, i = 0;\r\nwrite_data = 1;\r\nboot_loader_write_mem32(pao, 0, HPICL_ADDR, write_data);\r\nboot_loader_write_mem32(pao, 0, HPICH_ADDR, write_data);\r\nread_data =\r\n0xFFF7 & boot_loader_read_mem32(pao, 0, HPICL_ADDR);\r\nif (write_data != read_data) {\r\nHPI_DEBUG_LOG(ERROR, "HPICL %x %x\n", write_data,\r\nread_data);\r\nreturn HPI6205_ERROR_C6713_HPIC;\r\n}\r\nwrite_data = 1;\r\nfor (i = 0; i < 32; i++) {\r\nboot_loader_write_mem32(pao, 0, HPIAL_ADDR,\r\nwrite_data);\r\nboot_loader_write_mem32(pao, 0, HPIAH_ADDR,\r\n(write_data >> 16));\r\nread_data =\r\n0xFFFF & boot_loader_read_mem32(pao, 0,\r\nHPIAL_ADDR);\r\nread_data =\r\nread_data | ((0xFFFF &\r\nboot_loader_read_mem32(pao, 0,\r\nHPIAH_ADDR))\r\n<< 16);\r\nif (read_data != write_data) {\r\nHPI_DEBUG_LOG(ERROR, "HPIA %x %x\n",\r\nwrite_data, read_data);\r\nreturn HPI6205_ERROR_C6713_HPIA;\r\n}\r\nwrite_data = write_data << 1;\r\n}\r\nboot_loader_write_mem32(pao, dsp_index, 0x01B7C100, 0x0000);\r\nhpios_delay_micro_seconds(1000);\r\nboot_loader_write_mem32(pao, dsp_index, 0x01B7C120, 0x8002);\r\nboot_loader_write_mem32(pao, dsp_index, 0x01B7C11C, 0x8001);\r\nboot_loader_write_mem32(pao, dsp_index, 0x01B7C118, 0x8000);\r\nhpios_delay_micro_seconds(1000);\r\nboot_loader_write_mem32(pao, 0, (0x018C0024L), 0x00002A0A);\r\nboot_loader_write_mem32(pao, dsp_index, 0x01B7C100, 0x0001);\r\nhpios_delay_micro_seconds(1000);\r\nboot_loader_write_mem32(pao, 0, (0x018C0024L), 0x00002A02);\r\nboot_loader_write_mem32(pao, 0, 0x01800004,\r\n(1L << WS_OFS) | (8L << WST_OFS) | (1L << WH_OFS) |\r\n(1L << RS_OFS) | (12L << RST_OFS) | (1L << RH_OFS) |\r\n(2L << MTYPE_OFS));\r\nhpios_delay_micro_seconds(1000);\r\nif ((boot_loader_read_mem32(pao, dsp_index, 0x01B7C100) & 0xF)\r\n!= 0x0001) {\r\nreturn HPI6205_ERROR_C6713_PLL;\r\n}\r\nboot_loader_write_mem32(pao, dsp_index, C6713_EMIF_GCTL,\r\n0x000034A8);\r\nboot_loader_write_mem32(pao, dsp_index, C6713_EMIF_CE0,\r\n0x00000030);\r\nboot_loader_write_mem32(pao, dsp_index, C6713_EMIF_SDRAMEXT,\r\n0x001BDF29);\r\nboot_loader_write_mem32(pao, dsp_index, C6713_EMIF_SDRAMCTL,\r\n0x47116000);\r\nboot_loader_write_mem32(pao, dsp_index,\r\nC6713_EMIF_SDRAMTIMING, 0x00000410);\r\nhpios_delay_micro_seconds(1000);\r\n} else if (dsp_index == 2) {\r\n}\r\nreturn 0;\r\n}\r\nstatic u16 boot_loader_test_memory(struct hpi_adapter_obj *pao, int dsp_index,\r\nu32 start_address, u32 length)\r\n{\r\nu32 i = 0, j = 0;\r\nu32 test_addr = 0;\r\nu32 test_data = 0, data = 0;\r\nlength = 1000;\r\ni = 0;\r\n{\r\ntest_addr = start_address + i * 4;\r\ntest_data = 0x00000001;\r\nfor (j = 0; j < 32; j++) {\r\nboot_loader_write_mem32(pao, dsp_index, test_addr,\r\ntest_data);\r\ndata = boot_loader_read_mem32(pao, dsp_index,\r\ntest_addr);\r\nif (data != test_data) {\r\nHPI_DEBUG_LOG(VERBOSE,\r\n"Memtest error details "\r\n"%08x %08x %08x %i\n", test_addr,\r\ntest_data, data, dsp_index);\r\nreturn 1;\r\n}\r\ntest_data = test_data << 1;\r\n}\r\n}\r\nfor (i = 0; i < 100; i++) {\r\ntest_addr = start_address + i * 4;\r\ntest_data = 0xA5A55A5A;\r\nboot_loader_write_mem32(pao, dsp_index, test_addr, test_data);\r\nboot_loader_write_mem32(pao, dsp_index, test_addr + 4, 0);\r\ndata = boot_loader_read_mem32(pao, dsp_index, test_addr);\r\nif (data != test_data) {\r\nHPI_DEBUG_LOG(VERBOSE,\r\n"Memtest error details "\r\n"%08x %08x %08x %i\n", test_addr, test_data,\r\ndata, dsp_index);\r\nreturn 1;\r\n}\r\nboot_loader_write_mem32(pao, dsp_index, test_addr, 0x0);\r\n}\r\nfor (i = 0; i < length; i++) {\r\ntest_addr = start_address + i * 4;\r\nboot_loader_write_mem32(pao, dsp_index, test_addr, 0x0);\r\n}\r\nreturn 0;\r\n}\r\nstatic u16 boot_loader_test_internal_memory(struct hpi_adapter_obj *pao,\r\nint dsp_index)\r\n{\r\nint err = 0;\r\nif (dsp_index == 0) {\r\nerr = boot_loader_test_memory(pao, dsp_index, 0x00000000,\r\n0x10000);\r\nif (!err)\r\nerr = boot_loader_test_memory(pao, dsp_index,\r\n0x80000000, 0x10000);\r\n} else if (dsp_index == 1) {\r\nerr = boot_loader_test_memory(pao, dsp_index, 0x00000000,\r\n0x30000);\r\nif (!err)\r\nerr = boot_loader_test_memory(pao, dsp_index,\r\n0x00030000, 0x10000);\r\n}\r\nif (err)\r\nreturn HPI6205_ERROR_DSP_INTMEM;\r\nelse\r\nreturn 0;\r\n}\r\nstatic u16 boot_loader_test_external_memory(struct hpi_adapter_obj *pao,\r\nint dsp_index)\r\n{\r\nu32 dRAM_start_address = 0;\r\nu32 dRAM_size = 0;\r\nif (dsp_index == 0) {\r\nif (pao->pci.pci_dev->subsystem_device == 0x5000) {\r\ndRAM_start_address = 0x00400000;\r\ndRAM_size = 0x200000;\r\n} else\r\nreturn 0;\r\n} else if (dsp_index == 1) {\r\ndRAM_start_address = 0x80000000;\r\ndRAM_size = 0x200000;\r\n}\r\nif (boot_loader_test_memory(pao, dsp_index, dRAM_start_address,\r\ndRAM_size))\r\nreturn HPI6205_ERROR_DSP_EXTMEM;\r\nreturn 0;\r\n}\r\nstatic u16 boot_loader_test_pld(struct hpi_adapter_obj *pao, int dsp_index)\r\n{\r\nu32 data = 0;\r\nif (dsp_index == 0) {\r\nif (pao->pci.pci_dev->subsystem_device == 0x5000) {\r\ndata = boot_loader_read_mem32(pao, dsp_index,\r\n0x03000008);\r\nif ((data & 0xF) != 0x5)\r\nreturn HPI6205_ERROR_DSP_PLD;\r\ndata = boot_loader_read_mem32(pao, dsp_index,\r\n0x0300000C);\r\nif ((data & 0xF) != 0xA)\r\nreturn HPI6205_ERROR_DSP_PLD;\r\n}\r\n} else if (dsp_index == 1) {\r\nif (pao->pci.pci_dev->subsystem_device == 0x8700) {\r\ndata = boot_loader_read_mem32(pao, dsp_index,\r\n0x90000010);\r\nif ((data & 0xFF) != 0xAA)\r\nreturn HPI6205_ERROR_DSP_PLD;\r\nboot_loader_write_mem32(pao, dsp_index, 0x90000000,\r\n0x02);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic short hpi6205_transfer_data(struct hpi_adapter_obj *pao, u8 *p_data,\r\nu32 data_size, int operation)\r\n{\r\nstruct hpi_hw_obj *phw = pao->priv;\r\nu32 data_transferred = 0;\r\nu16 err = 0;\r\nu32 temp2;\r\nstruct bus_master_interface *interface = phw->p_interface_buffer;\r\nif (!p_data)\r\nreturn HPI_ERROR_INVALID_DATA_POINTER;\r\ndata_size &= ~3L;\r\nif (!wait_dsp_ack(phw, H620_HIF_IDLE, HPI6205_TIMEOUT))\r\nreturn HPI_ERROR_DSP_HARDWARE;\r\nwhile (data_transferred < data_size) {\r\nu32 this_copy = data_size - data_transferred;\r\nif (this_copy > HPI6205_SIZEOF_DATA)\r\nthis_copy = HPI6205_SIZEOF_DATA;\r\nif (operation == H620_HIF_SEND_DATA)\r\nmemcpy((void *)&interface->u.b_data[0],\r\n&p_data[data_transferred], this_copy);\r\ninterface->transfer_size_in_bytes = this_copy;\r\ninterface->dsp_ack = H620_HIF_IDLE;\r\nsend_dsp_command(phw, operation);\r\ntemp2 = wait_dsp_ack(phw, operation, HPI6205_TIMEOUT);\r\nHPI_DEBUG_LOG(DEBUG, "spun %d times for data xfer of %d\n",\r\nHPI6205_TIMEOUT - temp2, this_copy);\r\nif (!temp2) {\r\nHPI_DEBUG_LOG(ERROR,\r\n"Timed out waiting for " "state %d got %d\n",\r\noperation, interface->dsp_ack);\r\nbreak;\r\n}\r\nif (operation == H620_HIF_GET_DATA)\r\nmemcpy(&p_data[data_transferred],\r\n(void *)&interface->u.b_data[0], this_copy);\r\ndata_transferred += this_copy;\r\n}\r\nif (interface->dsp_ack != operation)\r\nHPI_DEBUG_LOG(DEBUG, "interface->dsp_ack=%d, expected %d\n",\r\ninterface->dsp_ack, operation);\r\nsend_dsp_command(phw, H620_HIF_IDLE);\r\nreturn err;\r\n}\r\nstatic int wait_dsp_ack(struct hpi_hw_obj *phw, int state, int timeout_us)\r\n{\r\nstruct bus_master_interface *interface = phw->p_interface_buffer;\r\nint t = timeout_us / 4;\r\nrmb();\r\nwhile ((interface->dsp_ack != state) && --t) {\r\nhpios_delay_micro_seconds(4);\r\nrmb();\r\n}\r\nreturn t * 4;\r\n}\r\nstatic void send_dsp_command(struct hpi_hw_obj *phw, int cmd)\r\n{\r\nstruct bus_master_interface *interface = phw->p_interface_buffer;\r\nu32 r;\r\ninterface->host_cmd = cmd;\r\nwmb();\r\nr = ioread32(phw->prHDCR);\r\nr |= (u32)C6205_HDCR_DSPINT;\r\niowrite32(r, phw->prHDCR);\r\nr &= ~(u32)C6205_HDCR_DSPINT;\r\niowrite32(r, phw->prHDCR);\r\n}\r\nstatic u16 message_response_sequence(struct hpi_adapter_obj *pao,\r\nstruct hpi_message *phm, struct hpi_response *phr)\r\n{\r\nu32 time_out, time_out2;\r\nstruct hpi_hw_obj *phw = pao->priv;\r\nstruct bus_master_interface *interface = phw->p_interface_buffer;\r\nu16 err = 0;\r\nmessage_count++;\r\nif (phm->size > sizeof(interface->u.message_buffer)) {\r\nphr->error = HPI_ERROR_MESSAGE_BUFFER_TOO_SMALL;\r\nphr->specific_error = sizeof(interface->u.message_buffer);\r\nphr->size = sizeof(struct hpi_response_header);\r\nHPI_DEBUG_LOG(ERROR,\r\n"message len %d too big for buffer %zd \n", phm->size,\r\nsizeof(interface->u.message_buffer));\r\nreturn 0;\r\n}\r\nif (!wait_dsp_ack(phw, H620_HIF_IDLE, HPI6205_TIMEOUT)) {\r\nHPI_DEBUG_LOG(DEBUG, "timeout waiting for idle\n");\r\nreturn HPI6205_ERROR_MSG_RESP_IDLE_TIMEOUT;\r\n}\r\nmemcpy(&interface->u.message_buffer, phm, phm->size);\r\nsend_dsp_command(phw, H620_HIF_GET_RESP);\r\ntime_out2 = wait_dsp_ack(phw, H620_HIF_GET_RESP, HPI6205_TIMEOUT);\r\nif (!time_out2) {\r\nHPI_DEBUG_LOG(ERROR,\r\n"(%u) Timed out waiting for " "GET_RESP state [%x]\n",\r\nmessage_count, interface->dsp_ack);\r\n} else {\r\nHPI_DEBUG_LOG(VERBOSE,\r\n"(%u) transition to GET_RESP after %u\n",\r\nmessage_count, HPI6205_TIMEOUT - time_out2);\r\n}\r\ntime_out = HPI6205_TIMEOUT;\r\nif (time_out) {\r\nif (interface->u.response_buffer.response.size <= phr->size)\r\nmemcpy(phr, &interface->u.response_buffer,\r\ninterface->u.response_buffer.response.size);\r\nelse {\r\nHPI_DEBUG_LOG(ERROR,\r\n"response len %d too big for buffer %d\n",\r\ninterface->u.response_buffer.response.size,\r\nphr->size);\r\nmemcpy(phr, &interface->u.response_buffer,\r\nsizeof(struct hpi_response_header));\r\nphr->error = HPI_ERROR_RESPONSE_BUFFER_TOO_SMALL;\r\nphr->specific_error =\r\ninterface->u.response_buffer.response.size;\r\nphr->size = sizeof(struct hpi_response_header);\r\n}\r\n}\r\nsend_dsp_command(phw, H620_HIF_IDLE);\r\nif (!time_out || !time_out2) {\r\nHPI_DEBUG_LOG(DEBUG, "something timed out!\n");\r\nreturn HPI6205_ERROR_MSG_RESP_TIMEOUT;\r\n}\r\nif (phm->function == HPI_ADAPTER_CLOSE) {\r\nif (!wait_dsp_ack(phw, H620_HIF_IDLE, HPI6205_TIMEOUT)) {\r\nHPI_DEBUG_LOG(DEBUG,\r\n"Timeout waiting for idle "\r\n"(on adapter_close)\n");\r\nreturn HPI6205_ERROR_MSG_RESP_IDLE_TIMEOUT;\r\n}\r\n}\r\nerr = hpi_validate_response(phm, phr);\r\nreturn err;\r\n}\r\nstatic void hw_message(struct hpi_adapter_obj *pao, struct hpi_message *phm,\r\nstruct hpi_response *phr)\r\n{\r\nu16 err = 0;\r\nhpios_dsplock_lock(pao);\r\nerr = message_response_sequence(pao, phm, phr);\r\nif (err) {\r\nif (err >= HPI_ERROR_BACKEND_BASE) {\r\nphr->error = HPI_ERROR_DSP_COMMUNICATION;\r\nphr->specific_error = err;\r\n} else {\r\nphr->error = err;\r\n}\r\npao->dsp_crashed++;\r\nphr->size = sizeof(struct hpi_response_header);\r\ngoto err;\r\n} else\r\npao->dsp_crashed = 0;\r\nif (phr->error != 0)\r\ngoto err;\r\nswitch (phm->function) {\r\ncase HPI_OSTREAM_WRITE:\r\ncase HPI_ISTREAM_ANC_WRITE:\r\nerr = hpi6205_transfer_data(pao, phm->u.d.u.data.pb_data,\r\nphm->u.d.u.data.data_size, H620_HIF_SEND_DATA);\r\nbreak;\r\ncase HPI_ISTREAM_READ:\r\ncase HPI_OSTREAM_ANC_READ:\r\nerr = hpi6205_transfer_data(pao, phm->u.d.u.data.pb_data,\r\nphm->u.d.u.data.data_size, H620_HIF_GET_DATA);\r\nbreak;\r\n}\r\nphr->error = err;\r\nerr:\r\nhpios_dsplock_unlock(pao);\r\nreturn;\r\n}
