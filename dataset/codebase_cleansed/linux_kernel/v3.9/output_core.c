void ipv6_select_ident(struct frag_hdr *fhdr, struct rt6_info *rt)\r\n{\r\nstatic atomic_t ipv6_fragmentation_id;\r\nint old, new;\r\n#if IS_ENABLED(CONFIG_IPV6)\r\nif (rt && !(rt->dst.flags & DST_NOPEER)) {\r\nstruct inet_peer *peer;\r\nstruct net *net;\r\nnet = dev_net(rt->dst.dev);\r\npeer = inet_getpeer_v6(net->ipv6.peers, &rt->rt6i_dst.addr, 1);\r\nif (peer) {\r\nfhdr->identification = htonl(inet_getid(peer, 0));\r\ninet_putpeer(peer);\r\nreturn;\r\n}\r\n}\r\n#endif\r\ndo {\r\nold = atomic_read(&ipv6_fragmentation_id);\r\nnew = old + 1;\r\nif (!new)\r\nnew = 1;\r\n} while (atomic_cmpxchg(&ipv6_fragmentation_id, old, new) != old);\r\nfhdr->identification = htonl(new);\r\n}\r\nint ip6_find_1stfragopt(struct sk_buff *skb, u8 **nexthdr)\r\n{\r\nu16 offset = sizeof(struct ipv6hdr);\r\nstruct ipv6_opt_hdr *exthdr =\r\n(struct ipv6_opt_hdr *)(ipv6_hdr(skb) + 1);\r\nunsigned int packet_len = skb->tail - skb->network_header;\r\nint found_rhdr = 0;\r\n*nexthdr = &ipv6_hdr(skb)->nexthdr;\r\nwhile (offset + 1 <= packet_len) {\r\nswitch (**nexthdr) {\r\ncase NEXTHDR_HOP:\r\nbreak;\r\ncase NEXTHDR_ROUTING:\r\nfound_rhdr = 1;\r\nbreak;\r\ncase NEXTHDR_DEST:\r\n#if IS_ENABLED(CONFIG_IPV6_MIP6)\r\nif (ipv6_find_tlv(skb, offset, IPV6_TLV_HAO) >= 0)\r\nbreak;\r\n#endif\r\nif (found_rhdr)\r\nreturn offset;\r\nbreak;\r\ndefault :\r\nreturn offset;\r\n}\r\noffset += ipv6_optlen(exthdr);\r\n*nexthdr = &exthdr->nexthdr;\r\nexthdr = (struct ipv6_opt_hdr *)(skb_network_header(skb) +\r\noffset);\r\n}\r\nreturn offset;\r\n}
