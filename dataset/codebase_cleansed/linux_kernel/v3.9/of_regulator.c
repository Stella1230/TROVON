static void of_get_regulation_constraints(struct device_node *np,\r\nstruct regulator_init_data **init_data)\r\n{\r\nconst __be32 *min_uV, *max_uV, *uV_offset;\r\nconst __be32 *min_uA, *max_uA, *ramp_delay;\r\nstruct regulation_constraints *constraints = &(*init_data)->constraints;\r\nconstraints->name = of_get_property(np, "regulator-name", NULL);\r\nmin_uV = of_get_property(np, "regulator-min-microvolt", NULL);\r\nif (min_uV)\r\nconstraints->min_uV = be32_to_cpu(*min_uV);\r\nmax_uV = of_get_property(np, "regulator-max-microvolt", NULL);\r\nif (max_uV)\r\nconstraints->max_uV = be32_to_cpu(*max_uV);\r\nif (constraints->min_uV != constraints->max_uV)\r\nconstraints->valid_ops_mask |= REGULATOR_CHANGE_VOLTAGE;\r\nif (min_uV && max_uV && constraints->min_uV == constraints->max_uV)\r\nconstraints->apply_uV = true;\r\nuV_offset = of_get_property(np, "regulator-microvolt-offset", NULL);\r\nif (uV_offset)\r\nconstraints->uV_offset = be32_to_cpu(*uV_offset);\r\nmin_uA = of_get_property(np, "regulator-min-microamp", NULL);\r\nif (min_uA)\r\nconstraints->min_uA = be32_to_cpu(*min_uA);\r\nmax_uA = of_get_property(np, "regulator-max-microamp", NULL);\r\nif (max_uA)\r\nconstraints->max_uA = be32_to_cpu(*max_uA);\r\nif (constraints->min_uA != constraints->max_uA)\r\nconstraints->valid_ops_mask |= REGULATOR_CHANGE_CURRENT;\r\nif (of_find_property(np, "regulator-boot-on", NULL))\r\nconstraints->boot_on = true;\r\nif (of_find_property(np, "regulator-always-on", NULL))\r\nconstraints->always_on = true;\r\nelse\r\nconstraints->valid_ops_mask |= REGULATOR_CHANGE_STATUS;\r\nramp_delay = of_get_property(np, "regulator-ramp-delay", NULL);\r\nif (ramp_delay)\r\nconstraints->ramp_delay = be32_to_cpu(*ramp_delay);\r\n}\r\nstruct regulator_init_data *of_get_regulator_init_data(struct device *dev,\r\nstruct device_node *node)\r\n{\r\nstruct regulator_init_data *init_data;\r\nif (!node)\r\nreturn NULL;\r\ninit_data = devm_kzalloc(dev, sizeof(*init_data), GFP_KERNEL);\r\nif (!init_data)\r\nreturn NULL;\r\nof_get_regulation_constraints(node, &init_data);\r\nreturn init_data;\r\n}\r\nint of_regulator_match(struct device *dev, struct device_node *node,\r\nstruct of_regulator_match *matches,\r\nunsigned int num_matches)\r\n{\r\nunsigned int count = 0;\r\nunsigned int i;\r\nconst char *name;\r\nstruct device_node *child;\r\nif (!dev || !node)\r\nreturn -EINVAL;\r\nfor (i = 0; i < num_matches; i++) {\r\nstruct of_regulator_match *match = &matches[i];\r\nmatch->init_data = NULL;\r\nmatch->of_node = NULL;\r\n}\r\nfor_each_child_of_node(node, child) {\r\nname = of_get_property(child,\r\n"regulator-compatible", NULL);\r\nif (!name)\r\nname = child->name;\r\nfor (i = 0; i < num_matches; i++) {\r\nstruct of_regulator_match *match = &matches[i];\r\nif (match->of_node)\r\ncontinue;\r\nif (strcmp(match->name, name))\r\ncontinue;\r\nmatch->init_data =\r\nof_get_regulator_init_data(dev, child);\r\nif (!match->init_data) {\r\ndev_err(dev,\r\n"failed to parse DT for regulator %s\n",\r\nchild->name);\r\nreturn -EINVAL;\r\n}\r\nmatch->of_node = child;\r\ncount++;\r\nbreak;\r\n}\r\n}\r\nreturn count;\r\n}
