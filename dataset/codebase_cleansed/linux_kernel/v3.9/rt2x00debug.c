void rt2x00debug_update_crypto(struct rt2x00_dev *rt2x00dev,\r\nstruct rxdone_entry_desc *rxdesc)\r\n{\r\nstruct rt2x00debug_intf *intf = rt2x00dev->debugfs_intf;\r\nenum cipher cipher = rxdesc->cipher;\r\nenum rx_crypto status = rxdesc->cipher_status;\r\nif (cipher == CIPHER_TKIP_NO_MIC)\r\ncipher = CIPHER_TKIP;\r\nif (cipher == CIPHER_NONE || cipher >= CIPHER_MAX)\r\nreturn;\r\ncipher--;\r\nintf->crypto_stats[cipher].success += (status == RX_CRYPTO_SUCCESS);\r\nintf->crypto_stats[cipher].icv_error += (status == RX_CRYPTO_FAIL_ICV);\r\nintf->crypto_stats[cipher].mic_error += (status == RX_CRYPTO_FAIL_MIC);\r\nintf->crypto_stats[cipher].key_error += (status == RX_CRYPTO_FAIL_KEY);\r\n}\r\nvoid rt2x00debug_dump_frame(struct rt2x00_dev *rt2x00dev,\r\nenum rt2x00_dump_type type, struct sk_buff *skb)\r\n{\r\nstruct rt2x00debug_intf *intf = rt2x00dev->debugfs_intf;\r\nstruct skb_frame_desc *skbdesc = get_skb_frame_desc(skb);\r\nstruct sk_buff *skbcopy;\r\nstruct rt2x00dump_hdr *dump_hdr;\r\nstruct timeval timestamp;\r\nu32 data_len;\r\nif (likely(!test_bit(FRAME_DUMP_FILE_OPEN, &intf->frame_dump_flags)))\r\nreturn;\r\ndo_gettimeofday(&timestamp);\r\nif (skb_queue_len(&intf->frame_dump_skbqueue) > 20) {\r\nDEBUG(rt2x00dev, "txrx dump queue length exceeded.\n");\r\nreturn;\r\n}\r\ndata_len = skb->len;\r\nif (skbdesc->flags & SKBDESC_DESC_IN_SKB)\r\ndata_len -= skbdesc->desc_len;\r\nskbcopy = alloc_skb(sizeof(*dump_hdr) + skbdesc->desc_len + data_len,\r\nGFP_ATOMIC);\r\nif (!skbcopy) {\r\nDEBUG(rt2x00dev, "Failed to copy skb for dump.\n");\r\nreturn;\r\n}\r\ndump_hdr = (struct rt2x00dump_hdr *)skb_put(skbcopy, sizeof(*dump_hdr));\r\ndump_hdr->version = cpu_to_le32(DUMP_HEADER_VERSION);\r\ndump_hdr->header_length = cpu_to_le32(sizeof(*dump_hdr));\r\ndump_hdr->desc_length = cpu_to_le32(skbdesc->desc_len);\r\ndump_hdr->data_length = cpu_to_le32(data_len);\r\ndump_hdr->chip_rt = cpu_to_le16(rt2x00dev->chip.rt);\r\ndump_hdr->chip_rf = cpu_to_le16(rt2x00dev->chip.rf);\r\ndump_hdr->chip_rev = cpu_to_le16(rt2x00dev->chip.rev);\r\ndump_hdr->type = cpu_to_le16(type);\r\ndump_hdr->queue_index = skbdesc->entry->queue->qid;\r\ndump_hdr->entry_index = skbdesc->entry->entry_idx;\r\ndump_hdr->timestamp_sec = cpu_to_le32(timestamp.tv_sec);\r\ndump_hdr->timestamp_usec = cpu_to_le32(timestamp.tv_usec);\r\nif (!(skbdesc->flags & SKBDESC_DESC_IN_SKB))\r\nmemcpy(skb_put(skbcopy, skbdesc->desc_len), skbdesc->desc,\r\nskbdesc->desc_len);\r\nmemcpy(skb_put(skbcopy, skb->len), skb->data, skb->len);\r\nskb_queue_tail(&intf->frame_dump_skbqueue, skbcopy);\r\nwake_up_interruptible(&intf->frame_dump_waitqueue);\r\nif (!test_bit(FRAME_DUMP_FILE_OPEN, &intf->frame_dump_flags))\r\nskb_queue_purge(&intf->frame_dump_skbqueue);\r\n}\r\nstatic int rt2x00debug_file_open(struct inode *inode, struct file *file)\r\n{\r\nstruct rt2x00debug_intf *intf = inode->i_private;\r\nfile->private_data = inode->i_private;\r\nif (!try_module_get(intf->debug->owner))\r\nreturn -EBUSY;\r\nreturn 0;\r\n}\r\nstatic int rt2x00debug_file_release(struct inode *inode, struct file *file)\r\n{\r\nstruct rt2x00debug_intf *intf = file->private_data;\r\nmodule_put(intf->debug->owner);\r\nreturn 0;\r\n}\r\nstatic int rt2x00debug_open_queue_dump(struct inode *inode, struct file *file)\r\n{\r\nstruct rt2x00debug_intf *intf = inode->i_private;\r\nint retval;\r\nretval = rt2x00debug_file_open(inode, file);\r\nif (retval)\r\nreturn retval;\r\nif (test_and_set_bit(FRAME_DUMP_FILE_OPEN, &intf->frame_dump_flags)) {\r\nrt2x00debug_file_release(inode, file);\r\nreturn -EBUSY;\r\n}\r\nreturn 0;\r\n}\r\nstatic int rt2x00debug_release_queue_dump(struct inode *inode, struct file *file)\r\n{\r\nstruct rt2x00debug_intf *intf = inode->i_private;\r\nskb_queue_purge(&intf->frame_dump_skbqueue);\r\nclear_bit(FRAME_DUMP_FILE_OPEN, &intf->frame_dump_flags);\r\nreturn rt2x00debug_file_release(inode, file);\r\n}\r\nstatic ssize_t rt2x00debug_read_queue_dump(struct file *file,\r\nchar __user *buf,\r\nsize_t length,\r\nloff_t *offset)\r\n{\r\nstruct rt2x00debug_intf *intf = file->private_data;\r\nstruct sk_buff *skb;\r\nsize_t status;\r\nint retval;\r\nif (file->f_flags & O_NONBLOCK)\r\nreturn -EAGAIN;\r\nretval =\r\nwait_event_interruptible(intf->frame_dump_waitqueue,\r\n(skb =\r\nskb_dequeue(&intf->frame_dump_skbqueue)));\r\nif (retval)\r\nreturn retval;\r\nstatus = min((size_t)skb->len, length);\r\nif (copy_to_user(buf, skb->data, status)) {\r\nstatus = -EFAULT;\r\ngoto exit;\r\n}\r\n*offset += status;\r\nexit:\r\nkfree_skb(skb);\r\nreturn status;\r\n}\r\nstatic unsigned int rt2x00debug_poll_queue_dump(struct file *file,\r\npoll_table *wait)\r\n{\r\nstruct rt2x00debug_intf *intf = file->private_data;\r\npoll_wait(file, &intf->frame_dump_waitqueue, wait);\r\nif (!skb_queue_empty(&intf->frame_dump_skbqueue))\r\nreturn POLLOUT | POLLWRNORM;\r\nreturn 0;\r\n}\r\nstatic ssize_t rt2x00debug_read_queue_stats(struct file *file,\r\nchar __user *buf,\r\nsize_t length,\r\nloff_t *offset)\r\n{\r\nstruct rt2x00debug_intf *intf = file->private_data;\r\nstruct data_queue *queue;\r\nunsigned long irqflags;\r\nunsigned int lines = 1 + intf->rt2x00dev->data_queues;\r\nsize_t size;\r\nchar *data;\r\nchar *temp;\r\nif (*offset)\r\nreturn 0;\r\ndata = kcalloc(lines, MAX_LINE_LENGTH, GFP_KERNEL);\r\nif (!data)\r\nreturn -ENOMEM;\r\ntemp = data +\r\nsprintf(data, "qid\tflags\t\tcount\tlimit\tlength\tindex\tdma done\tdone\n");\r\nqueue_for_each(intf->rt2x00dev, queue) {\r\nspin_lock_irqsave(&queue->index_lock, irqflags);\r\ntemp += sprintf(temp, "%d\t0x%.8x\t%d\t%d\t%d\t%d\t%d\t\t%d\n",\r\nqueue->qid, (unsigned int)queue->flags,\r\nqueue->count, queue->limit, queue->length,\r\nqueue->index[Q_INDEX],\r\nqueue->index[Q_INDEX_DMA_DONE],\r\nqueue->index[Q_INDEX_DONE]);\r\nspin_unlock_irqrestore(&queue->index_lock, irqflags);\r\n}\r\nsize = strlen(data);\r\nsize = min(size, length);\r\nif (copy_to_user(buf, data, size)) {\r\nkfree(data);\r\nreturn -EFAULT;\r\n}\r\nkfree(data);\r\n*offset += size;\r\nreturn size;\r\n}\r\nstatic ssize_t rt2x00debug_read_crypto_stats(struct file *file,\r\nchar __user *buf,\r\nsize_t length,\r\nloff_t *offset)\r\n{\r\nstruct rt2x00debug_intf *intf = file->private_data;\r\nstatic const char * const name[] = { "WEP64", "WEP128", "TKIP", "AES" };\r\nchar *data;\r\nchar *temp;\r\nsize_t size;\r\nunsigned int i;\r\nif (*offset)\r\nreturn 0;\r\ndata = kzalloc((1 + CIPHER_MAX) * MAX_LINE_LENGTH, GFP_KERNEL);\r\nif (!data)\r\nreturn -ENOMEM;\r\ntemp = data;\r\ntemp += sprintf(data, "cipher\tsuccess\ticv err\tmic err\tkey err\n");\r\nfor (i = 0; i < CIPHER_MAX; i++) {\r\ntemp += sprintf(temp, "%s\t%lu\t%lu\t%lu\t%lu\n", name[i],\r\nintf->crypto_stats[i].success,\r\nintf->crypto_stats[i].icv_error,\r\nintf->crypto_stats[i].mic_error,\r\nintf->crypto_stats[i].key_error);\r\n}\r\nsize = strlen(data);\r\nsize = min(size, length);\r\nif (copy_to_user(buf, data, size)) {\r\nkfree(data);\r\nreturn -EFAULT;\r\n}\r\nkfree(data);\r\n*offset += size;\r\nreturn size;\r\n}\r\nstatic ssize_t rt2x00debug_read_dev_flags(struct file *file,\r\nchar __user *buf,\r\nsize_t length,\r\nloff_t *offset)\r\n{\r\nstruct rt2x00debug_intf *intf = file->private_data;\r\nchar line[16];\r\nsize_t size;\r\nif (*offset)\r\nreturn 0;\r\nsize = sprintf(line, "0x%.8x\n", (unsigned int)intf->rt2x00dev->flags);\r\nif (copy_to_user(buf, line, size))\r\nreturn -EFAULT;\r\n*offset += size;\r\nreturn size;\r\n}\r\nstatic ssize_t rt2x00debug_read_cap_flags(struct file *file,\r\nchar __user *buf,\r\nsize_t length,\r\nloff_t *offset)\r\n{\r\nstruct rt2x00debug_intf *intf = file->private_data;\r\nchar line[16];\r\nsize_t size;\r\nif (*offset)\r\nreturn 0;\r\nsize = sprintf(line, "0x%.8x\n", (unsigned int)intf->rt2x00dev->cap_flags);\r\nif (copy_to_user(buf, line, size))\r\nreturn -EFAULT;\r\n*offset += size;\r\nreturn size;\r\n}\r\nstatic struct dentry *rt2x00debug_create_file_driver(const char *name,\r\nstruct rt2x00debug_intf\r\n*intf,\r\nstruct debugfs_blob_wrapper\r\n*blob)\r\n{\r\nchar *data;\r\ndata = kzalloc(3 * MAX_LINE_LENGTH, GFP_KERNEL);\r\nif (!data)\r\nreturn NULL;\r\nblob->data = data;\r\ndata += sprintf(data, "driver:\t%s\n", intf->rt2x00dev->ops->name);\r\ndata += sprintf(data, "version:\t%s\n", DRV_VERSION);\r\nblob->size = strlen(blob->data);\r\nreturn debugfs_create_blob(name, S_IRUSR, intf->driver_folder, blob);\r\n}\r\nstatic struct dentry *rt2x00debug_create_file_chipset(const char *name,\r\nstruct rt2x00debug_intf\r\n*intf,\r\nstruct\r\ndebugfs_blob_wrapper\r\n*blob)\r\n{\r\nconst struct rt2x00debug *debug = intf->debug;\r\nchar *data;\r\ndata = kzalloc(9 * MAX_LINE_LENGTH, GFP_KERNEL);\r\nif (!data)\r\nreturn NULL;\r\nblob->data = data;\r\ndata += sprintf(data, "rt chip:\t%04x\n", intf->rt2x00dev->chip.rt);\r\ndata += sprintf(data, "rf chip:\t%04x\n", intf->rt2x00dev->chip.rf);\r\ndata += sprintf(data, "revision:\t%04x\n", intf->rt2x00dev->chip.rev);\r\ndata += sprintf(data, "\n");\r\ndata += sprintf(data, "register\tbase\twords\twordsize\n");\r\n#define RT2X00DEBUGFS_SPRINTF_REGISTER(__name) \\r\n{ \\r\nif(debug->__name.read) \\r\ndata += sprintf(data, __stringify(__name) \\r\n"\t%d\t%d\t%d\n", \\r\ndebug->__name.word_base, \\r\ndebug->__name.word_count, \\r\ndebug->__name.word_size); \\r\n}\r\nRT2X00DEBUGFS_SPRINTF_REGISTER(csr);\r\nRT2X00DEBUGFS_SPRINTF_REGISTER(eeprom);\r\nRT2X00DEBUGFS_SPRINTF_REGISTER(bbp);\r\nRT2X00DEBUGFS_SPRINTF_REGISTER(rf);\r\nRT2X00DEBUGFS_SPRINTF_REGISTER(rfcsr);\r\n#undef RT2X00DEBUGFS_SPRINTF_REGISTER\r\nblob->size = strlen(blob->data);\r\nreturn debugfs_create_blob(name, S_IRUSR, intf->driver_folder, blob);\r\n}\r\nvoid rt2x00debug_register(struct rt2x00_dev *rt2x00dev)\r\n{\r\nconst struct rt2x00debug *debug = rt2x00dev->ops->debugfs;\r\nstruct rt2x00debug_intf *intf;\r\nintf = kzalloc(sizeof(struct rt2x00debug_intf), GFP_KERNEL);\r\nif (!intf) {\r\nERROR(rt2x00dev, "Failed to allocate debug handler.\n");\r\nreturn;\r\n}\r\nintf->debug = debug;\r\nintf->rt2x00dev = rt2x00dev;\r\nrt2x00dev->debugfs_intf = intf;\r\nintf->driver_folder =\r\ndebugfs_create_dir(intf->rt2x00dev->ops->name,\r\nrt2x00dev->hw->wiphy->debugfsdir);\r\nif (IS_ERR(intf->driver_folder) || !intf->driver_folder)\r\ngoto exit;\r\nintf->driver_entry =\r\nrt2x00debug_create_file_driver("driver", intf, &intf->driver_blob);\r\nif (IS_ERR(intf->driver_entry) || !intf->driver_entry)\r\ngoto exit;\r\nintf->chipset_entry =\r\nrt2x00debug_create_file_chipset("chipset",\r\nintf, &intf->chipset_blob);\r\nif (IS_ERR(intf->chipset_entry) || !intf->chipset_entry)\r\ngoto exit;\r\nintf->dev_flags = debugfs_create_file("dev_flags", S_IRUSR,\r\nintf->driver_folder, intf,\r\n&rt2x00debug_fop_dev_flags);\r\nif (IS_ERR(intf->dev_flags) || !intf->dev_flags)\r\ngoto exit;\r\nintf->cap_flags = debugfs_create_file("cap_flags", S_IRUSR,\r\nintf->driver_folder, intf,\r\n&rt2x00debug_fop_cap_flags);\r\nif (IS_ERR(intf->cap_flags) || !intf->cap_flags)\r\ngoto exit;\r\nintf->register_folder =\r\ndebugfs_create_dir("register", intf->driver_folder);\r\nif (IS_ERR(intf->register_folder) || !intf->register_folder)\r\ngoto exit;\r\n#define RT2X00DEBUGFS_CREATE_REGISTER_ENTRY(__intf, __name) \\r\n({ \\r\nif(debug->__name.read) { \\r\n(__intf)->__name##_off_entry = \\r\ndebugfs_create_u32(__stringify(__name) "_offset", \\r\nS_IRUSR | S_IWUSR, \\r\n(__intf)->register_folder, \\r\n&(__intf)->offset_##__name); \\r\nif (IS_ERR((__intf)->__name##_off_entry) \\r\n|| !(__intf)->__name##_off_entry) \\r\ngoto exit; \\r\n\\r\n(__intf)->__name##_val_entry = \\r\ndebugfs_create_file(__stringify(__name) "_value", \\r\nS_IRUSR | S_IWUSR, \\r\n(__intf)->register_folder, \\r\n(__intf), &rt2x00debug_fop_##__name); \\r\nif (IS_ERR((__intf)->__name##_val_entry) \\r\n|| !(__intf)->__name##_val_entry) \\r\ngoto exit; \\r\n} \\r\n})\r\nRT2X00DEBUGFS_CREATE_REGISTER_ENTRY(intf, csr);\r\nRT2X00DEBUGFS_CREATE_REGISTER_ENTRY(intf, eeprom);\r\nRT2X00DEBUGFS_CREATE_REGISTER_ENTRY(intf, bbp);\r\nRT2X00DEBUGFS_CREATE_REGISTER_ENTRY(intf, rf);\r\nRT2X00DEBUGFS_CREATE_REGISTER_ENTRY(intf, rfcsr);\r\n#undef RT2X00DEBUGFS_CREATE_REGISTER_ENTRY\r\nintf->queue_folder =\r\ndebugfs_create_dir("queue", intf->driver_folder);\r\nif (IS_ERR(intf->queue_folder) || !intf->queue_folder)\r\ngoto exit;\r\nintf->queue_frame_dump_entry =\r\ndebugfs_create_file("dump", S_IRUSR, intf->queue_folder,\r\nintf, &rt2x00debug_fop_queue_dump);\r\nif (IS_ERR(intf->queue_frame_dump_entry)\r\n|| !intf->queue_frame_dump_entry)\r\ngoto exit;\r\nskb_queue_head_init(&intf->frame_dump_skbqueue);\r\ninit_waitqueue_head(&intf->frame_dump_waitqueue);\r\nintf->queue_stats_entry =\r\ndebugfs_create_file("queue", S_IRUSR, intf->queue_folder,\r\nintf, &rt2x00debug_fop_queue_stats);\r\n#ifdef CONFIG_RT2X00_LIB_CRYPTO\r\nif (test_bit(CAPABILITY_HW_CRYPTO, &rt2x00dev->cap_flags))\r\nintf->crypto_stats_entry =\r\ndebugfs_create_file("crypto", S_IRUGO, intf->queue_folder,\r\nintf, &rt2x00debug_fop_crypto_stats);\r\n#endif\r\nreturn;\r\nexit:\r\nrt2x00debug_deregister(rt2x00dev);\r\nERROR(rt2x00dev, "Failed to register debug handler.\n");\r\n}\r\nvoid rt2x00debug_deregister(struct rt2x00_dev *rt2x00dev)\r\n{\r\nstruct rt2x00debug_intf *intf = rt2x00dev->debugfs_intf;\r\nif (unlikely(!intf))\r\nreturn;\r\nskb_queue_purge(&intf->frame_dump_skbqueue);\r\n#ifdef CONFIG_RT2X00_LIB_CRYPTO\r\ndebugfs_remove(intf->crypto_stats_entry);\r\n#endif\r\ndebugfs_remove(intf->queue_stats_entry);\r\ndebugfs_remove(intf->queue_frame_dump_entry);\r\ndebugfs_remove(intf->queue_folder);\r\ndebugfs_remove(intf->rfcsr_val_entry);\r\ndebugfs_remove(intf->rfcsr_off_entry);\r\ndebugfs_remove(intf->rf_val_entry);\r\ndebugfs_remove(intf->rf_off_entry);\r\ndebugfs_remove(intf->bbp_val_entry);\r\ndebugfs_remove(intf->bbp_off_entry);\r\ndebugfs_remove(intf->eeprom_val_entry);\r\ndebugfs_remove(intf->eeprom_off_entry);\r\ndebugfs_remove(intf->csr_val_entry);\r\ndebugfs_remove(intf->csr_off_entry);\r\ndebugfs_remove(intf->register_folder);\r\ndebugfs_remove(intf->dev_flags);\r\ndebugfs_remove(intf->cap_flags);\r\ndebugfs_remove(intf->chipset_entry);\r\ndebugfs_remove(intf->driver_entry);\r\ndebugfs_remove(intf->driver_folder);\r\nkfree(intf->chipset_blob.data);\r\nkfree(intf->driver_blob.data);\r\nkfree(intf);\r\nrt2x00dev->debugfs_intf = NULL;\r\n}
