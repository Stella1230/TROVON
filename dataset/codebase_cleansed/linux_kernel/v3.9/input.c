static inline int is_event_supported(unsigned int code,\r\nunsigned long *bm, unsigned int max)\r\n{\r\nreturn code <= max && test_bit(code, bm);\r\n}\r\nstatic int input_defuzz_abs_event(int value, int old_val, int fuzz)\r\n{\r\nif (fuzz) {\r\nif (value > old_val - fuzz / 2 && value < old_val + fuzz / 2)\r\nreturn old_val;\r\nif (value > old_val - fuzz && value < old_val + fuzz)\r\nreturn (old_val * 3 + value) / 4;\r\nif (value > old_val - fuzz * 2 && value < old_val + fuzz * 2)\r\nreturn (old_val + value) / 2;\r\n}\r\nreturn value;\r\n}\r\nstatic void input_start_autorepeat(struct input_dev *dev, int code)\r\n{\r\nif (test_bit(EV_REP, dev->evbit) &&\r\ndev->rep[REP_PERIOD] && dev->rep[REP_DELAY] &&\r\ndev->timer.data) {\r\ndev->repeat_key = code;\r\nmod_timer(&dev->timer,\r\njiffies + msecs_to_jiffies(dev->rep[REP_DELAY]));\r\n}\r\n}\r\nstatic void input_stop_autorepeat(struct input_dev *dev)\r\n{\r\ndel_timer(&dev->timer);\r\n}\r\nstatic unsigned int input_to_handler(struct input_handle *handle,\r\nstruct input_value *vals, unsigned int count)\r\n{\r\nstruct input_handler *handler = handle->handler;\r\nstruct input_value *end = vals;\r\nstruct input_value *v;\r\nfor (v = vals; v != vals + count; v++) {\r\nif (handler->filter &&\r\nhandler->filter(handle, v->type, v->code, v->value))\r\ncontinue;\r\nif (end != v)\r\n*end = *v;\r\nend++;\r\n}\r\ncount = end - vals;\r\nif (!count)\r\nreturn 0;\r\nif (handler->events)\r\nhandler->events(handle, vals, count);\r\nelse if (handler->event)\r\nfor (v = vals; v != end; v++)\r\nhandler->event(handle, v->type, v->code, v->value);\r\nreturn count;\r\n}\r\nstatic void input_pass_values(struct input_dev *dev,\r\nstruct input_value *vals, unsigned int count)\r\n{\r\nstruct input_handle *handle;\r\nstruct input_value *v;\r\nif (!count)\r\nreturn;\r\nrcu_read_lock();\r\nhandle = rcu_dereference(dev->grab);\r\nif (handle) {\r\ncount = input_to_handler(handle, vals, count);\r\n} else {\r\nlist_for_each_entry_rcu(handle, &dev->h_list, d_node)\r\nif (handle->open)\r\ncount = input_to_handler(handle, vals, count);\r\n}\r\nrcu_read_unlock();\r\nadd_input_randomness(vals->type, vals->code, vals->value);\r\nfor (v = vals; v != vals + count; v++) {\r\nif (v->type == EV_KEY && v->value != 2) {\r\nif (v->value)\r\ninput_start_autorepeat(dev, v->code);\r\nelse\r\ninput_stop_autorepeat(dev);\r\n}\r\n}\r\n}\r\nstatic void input_pass_event(struct input_dev *dev,\r\nunsigned int type, unsigned int code, int value)\r\n{\r\nstruct input_value vals[] = { { type, code, value } };\r\ninput_pass_values(dev, vals, ARRAY_SIZE(vals));\r\n}\r\nstatic void input_repeat_key(unsigned long data)\r\n{\r\nstruct input_dev *dev = (void *) data;\r\nunsigned long flags;\r\nspin_lock_irqsave(&dev->event_lock, flags);\r\nif (test_bit(dev->repeat_key, dev->key) &&\r\nis_event_supported(dev->repeat_key, dev->keybit, KEY_MAX)) {\r\nstruct input_value vals[] = {\r\n{ EV_KEY, dev->repeat_key, 2 },\r\ninput_value_sync\r\n};\r\ninput_pass_values(dev, vals, ARRAY_SIZE(vals));\r\nif (dev->rep[REP_PERIOD])\r\nmod_timer(&dev->timer, jiffies +\r\nmsecs_to_jiffies(dev->rep[REP_PERIOD]));\r\n}\r\nspin_unlock_irqrestore(&dev->event_lock, flags);\r\n}\r\nstatic int input_handle_abs_event(struct input_dev *dev,\r\nunsigned int code, int *pval)\r\n{\r\nstruct input_mt *mt = dev->mt;\r\nbool is_mt_event;\r\nint *pold;\r\nif (code == ABS_MT_SLOT) {\r\nif (mt && *pval >= 0 && *pval < mt->num_slots)\r\nmt->slot = *pval;\r\nreturn INPUT_IGNORE_EVENT;\r\n}\r\nis_mt_event = input_is_mt_value(code);\r\nif (!is_mt_event) {\r\npold = &dev->absinfo[code].value;\r\n} else if (mt) {\r\npold = &mt->slots[mt->slot].abs[code - ABS_MT_FIRST];\r\n} else {\r\npold = NULL;\r\n}\r\nif (pold) {\r\n*pval = input_defuzz_abs_event(*pval, *pold,\r\ndev->absinfo[code].fuzz);\r\nif (*pold == *pval)\r\nreturn INPUT_IGNORE_EVENT;\r\n*pold = *pval;\r\n}\r\nif (is_mt_event && mt && mt->slot != input_abs_get_val(dev, ABS_MT_SLOT)) {\r\ninput_abs_set_val(dev, ABS_MT_SLOT, mt->slot);\r\nreturn INPUT_PASS_TO_HANDLERS | INPUT_SLOT;\r\n}\r\nreturn INPUT_PASS_TO_HANDLERS;\r\n}\r\nstatic int input_get_disposition(struct input_dev *dev,\r\nunsigned int type, unsigned int code, int value)\r\n{\r\nint disposition = INPUT_IGNORE_EVENT;\r\nswitch (type) {\r\ncase EV_SYN:\r\nswitch (code) {\r\ncase SYN_CONFIG:\r\ndisposition = INPUT_PASS_TO_ALL;\r\nbreak;\r\ncase SYN_REPORT:\r\ndisposition = INPUT_PASS_TO_HANDLERS | INPUT_FLUSH;\r\nbreak;\r\ncase SYN_MT_REPORT:\r\ndisposition = INPUT_PASS_TO_HANDLERS;\r\nbreak;\r\n}\r\nbreak;\r\ncase EV_KEY:\r\nif (is_event_supported(code, dev->keybit, KEY_MAX)) {\r\nif (value == 2) {\r\ndisposition = INPUT_PASS_TO_HANDLERS;\r\nbreak;\r\n}\r\nif (!!test_bit(code, dev->key) != !!value) {\r\n__change_bit(code, dev->key);\r\ndisposition = INPUT_PASS_TO_HANDLERS;\r\n}\r\n}\r\nbreak;\r\ncase EV_SW:\r\nif (is_event_supported(code, dev->swbit, SW_MAX) &&\r\n!!test_bit(code, dev->sw) != !!value) {\r\n__change_bit(code, dev->sw);\r\ndisposition = INPUT_PASS_TO_HANDLERS;\r\n}\r\nbreak;\r\ncase EV_ABS:\r\nif (is_event_supported(code, dev->absbit, ABS_MAX))\r\ndisposition = input_handle_abs_event(dev, code, &value);\r\nbreak;\r\ncase EV_REL:\r\nif (is_event_supported(code, dev->relbit, REL_MAX) && value)\r\ndisposition = INPUT_PASS_TO_HANDLERS;\r\nbreak;\r\ncase EV_MSC:\r\nif (is_event_supported(code, dev->mscbit, MSC_MAX))\r\ndisposition = INPUT_PASS_TO_ALL;\r\nbreak;\r\ncase EV_LED:\r\nif (is_event_supported(code, dev->ledbit, LED_MAX) &&\r\n!!test_bit(code, dev->led) != !!value) {\r\n__change_bit(code, dev->led);\r\ndisposition = INPUT_PASS_TO_ALL;\r\n}\r\nbreak;\r\ncase EV_SND:\r\nif (is_event_supported(code, dev->sndbit, SND_MAX)) {\r\nif (!!test_bit(code, dev->snd) != !!value)\r\n__change_bit(code, dev->snd);\r\ndisposition = INPUT_PASS_TO_ALL;\r\n}\r\nbreak;\r\ncase EV_REP:\r\nif (code <= REP_MAX && value >= 0 && dev->rep[code] != value) {\r\ndev->rep[code] = value;\r\ndisposition = INPUT_PASS_TO_ALL;\r\n}\r\nbreak;\r\ncase EV_FF:\r\nif (value >= 0)\r\ndisposition = INPUT_PASS_TO_ALL;\r\nbreak;\r\ncase EV_PWR:\r\ndisposition = INPUT_PASS_TO_ALL;\r\nbreak;\r\n}\r\nreturn disposition;\r\n}\r\nstatic void input_handle_event(struct input_dev *dev,\r\nunsigned int type, unsigned int code, int value)\r\n{\r\nint disposition;\r\ndisposition = input_get_disposition(dev, type, code, value);\r\nif ((disposition & INPUT_PASS_TO_DEVICE) && dev->event)\r\ndev->event(dev, type, code, value);\r\nif (!dev->vals)\r\nreturn;\r\nif (disposition & INPUT_PASS_TO_HANDLERS) {\r\nstruct input_value *v;\r\nif (disposition & INPUT_SLOT) {\r\nv = &dev->vals[dev->num_vals++];\r\nv->type = EV_ABS;\r\nv->code = ABS_MT_SLOT;\r\nv->value = dev->mt->slot;\r\n}\r\nv = &dev->vals[dev->num_vals++];\r\nv->type = type;\r\nv->code = code;\r\nv->value = value;\r\n}\r\nif (disposition & INPUT_FLUSH) {\r\nif (dev->num_vals >= 2)\r\ninput_pass_values(dev, dev->vals, dev->num_vals);\r\ndev->num_vals = 0;\r\n} else if (dev->num_vals >= dev->max_vals - 2) {\r\ndev->vals[dev->num_vals++] = input_value_sync;\r\ninput_pass_values(dev, dev->vals, dev->num_vals);\r\ndev->num_vals = 0;\r\n}\r\n}\r\nvoid input_event(struct input_dev *dev,\r\nunsigned int type, unsigned int code, int value)\r\n{\r\nunsigned long flags;\r\nif (is_event_supported(type, dev->evbit, EV_MAX)) {\r\nspin_lock_irqsave(&dev->event_lock, flags);\r\ninput_handle_event(dev, type, code, value);\r\nspin_unlock_irqrestore(&dev->event_lock, flags);\r\n}\r\n}\r\nvoid input_inject_event(struct input_handle *handle,\r\nunsigned int type, unsigned int code, int value)\r\n{\r\nstruct input_dev *dev = handle->dev;\r\nstruct input_handle *grab;\r\nunsigned long flags;\r\nif (is_event_supported(type, dev->evbit, EV_MAX)) {\r\nspin_lock_irqsave(&dev->event_lock, flags);\r\nrcu_read_lock();\r\ngrab = rcu_dereference(dev->grab);\r\nif (!grab || grab == handle)\r\ninput_handle_event(dev, type, code, value);\r\nrcu_read_unlock();\r\nspin_unlock_irqrestore(&dev->event_lock, flags);\r\n}\r\n}\r\nvoid input_alloc_absinfo(struct input_dev *dev)\r\n{\r\nif (!dev->absinfo)\r\ndev->absinfo = kcalloc(ABS_CNT, sizeof(struct input_absinfo),\r\nGFP_KERNEL);\r\nWARN(!dev->absinfo, "%s(): kcalloc() failed?\n", __func__);\r\n}\r\nvoid input_set_abs_params(struct input_dev *dev, unsigned int axis,\r\nint min, int max, int fuzz, int flat)\r\n{\r\nstruct input_absinfo *absinfo;\r\ninput_alloc_absinfo(dev);\r\nif (!dev->absinfo)\r\nreturn;\r\nabsinfo = &dev->absinfo[axis];\r\nabsinfo->minimum = min;\r\nabsinfo->maximum = max;\r\nabsinfo->fuzz = fuzz;\r\nabsinfo->flat = flat;\r\ndev->absbit[BIT_WORD(axis)] |= BIT_MASK(axis);\r\n}\r\nint input_grab_device(struct input_handle *handle)\r\n{\r\nstruct input_dev *dev = handle->dev;\r\nint retval;\r\nretval = mutex_lock_interruptible(&dev->mutex);\r\nif (retval)\r\nreturn retval;\r\nif (dev->grab) {\r\nretval = -EBUSY;\r\ngoto out;\r\n}\r\nrcu_assign_pointer(dev->grab, handle);\r\nout:\r\nmutex_unlock(&dev->mutex);\r\nreturn retval;\r\n}\r\nstatic void __input_release_device(struct input_handle *handle)\r\n{\r\nstruct input_dev *dev = handle->dev;\r\nstruct input_handle *grabber;\r\ngrabber = rcu_dereference_protected(dev->grab,\r\nlockdep_is_held(&dev->mutex));\r\nif (grabber == handle) {\r\nrcu_assign_pointer(dev->grab, NULL);\r\nsynchronize_rcu();\r\nlist_for_each_entry(handle, &dev->h_list, d_node)\r\nif (handle->open && handle->handler->start)\r\nhandle->handler->start(handle);\r\n}\r\n}\r\nvoid input_release_device(struct input_handle *handle)\r\n{\r\nstruct input_dev *dev = handle->dev;\r\nmutex_lock(&dev->mutex);\r\n__input_release_device(handle);\r\nmutex_unlock(&dev->mutex);\r\n}\r\nint input_open_device(struct input_handle *handle)\r\n{\r\nstruct input_dev *dev = handle->dev;\r\nint retval;\r\nretval = mutex_lock_interruptible(&dev->mutex);\r\nif (retval)\r\nreturn retval;\r\nif (dev->going_away) {\r\nretval = -ENODEV;\r\ngoto out;\r\n}\r\nhandle->open++;\r\nif (!dev->users++ && dev->open)\r\nretval = dev->open(dev);\r\nif (retval) {\r\ndev->users--;\r\nif (!--handle->open) {\r\nsynchronize_rcu();\r\n}\r\n}\r\nout:\r\nmutex_unlock(&dev->mutex);\r\nreturn retval;\r\n}\r\nint input_flush_device(struct input_handle *handle, struct file *file)\r\n{\r\nstruct input_dev *dev = handle->dev;\r\nint retval;\r\nretval = mutex_lock_interruptible(&dev->mutex);\r\nif (retval)\r\nreturn retval;\r\nif (dev->flush)\r\nretval = dev->flush(dev, file);\r\nmutex_unlock(&dev->mutex);\r\nreturn retval;\r\n}\r\nvoid input_close_device(struct input_handle *handle)\r\n{\r\nstruct input_dev *dev = handle->dev;\r\nmutex_lock(&dev->mutex);\r\n__input_release_device(handle);\r\nif (!--dev->users && dev->close)\r\ndev->close(dev);\r\nif (!--handle->open) {\r\nsynchronize_rcu();\r\n}\r\nmutex_unlock(&dev->mutex);\r\n}\r\nstatic void input_dev_release_keys(struct input_dev *dev)\r\n{\r\nint code;\r\nif (is_event_supported(EV_KEY, dev->evbit, EV_MAX)) {\r\nfor (code = 0; code <= KEY_MAX; code++) {\r\nif (is_event_supported(code, dev->keybit, KEY_MAX) &&\r\n__test_and_clear_bit(code, dev->key)) {\r\ninput_pass_event(dev, EV_KEY, code, 0);\r\n}\r\n}\r\ninput_pass_event(dev, EV_SYN, SYN_REPORT, 1);\r\n}\r\n}\r\nstatic void input_disconnect_device(struct input_dev *dev)\r\n{\r\nstruct input_handle *handle;\r\nmutex_lock(&dev->mutex);\r\ndev->going_away = true;\r\nmutex_unlock(&dev->mutex);\r\nspin_lock_irq(&dev->event_lock);\r\ninput_dev_release_keys(dev);\r\nlist_for_each_entry(handle, &dev->h_list, d_node)\r\nhandle->open = 0;\r\nspin_unlock_irq(&dev->event_lock);\r\n}\r\nint input_scancode_to_scalar(const struct input_keymap_entry *ke,\r\nunsigned int *scancode)\r\n{\r\nswitch (ke->len) {\r\ncase 1:\r\n*scancode = *((u8 *)ke->scancode);\r\nbreak;\r\ncase 2:\r\n*scancode = *((u16 *)ke->scancode);\r\nbreak;\r\ncase 4:\r\n*scancode = *((u32 *)ke->scancode);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic unsigned int input_fetch_keycode(struct input_dev *dev,\r\nunsigned int index)\r\n{\r\nswitch (dev->keycodesize) {\r\ncase 1:\r\nreturn ((u8 *)dev->keycode)[index];\r\ncase 2:\r\nreturn ((u16 *)dev->keycode)[index];\r\ndefault:\r\nreturn ((u32 *)dev->keycode)[index];\r\n}\r\n}\r\nstatic int input_default_getkeycode(struct input_dev *dev,\r\nstruct input_keymap_entry *ke)\r\n{\r\nunsigned int index;\r\nint error;\r\nif (!dev->keycodesize)\r\nreturn -EINVAL;\r\nif (ke->flags & INPUT_KEYMAP_BY_INDEX)\r\nindex = ke->index;\r\nelse {\r\nerror = input_scancode_to_scalar(ke, &index);\r\nif (error)\r\nreturn error;\r\n}\r\nif (index >= dev->keycodemax)\r\nreturn -EINVAL;\r\nke->keycode = input_fetch_keycode(dev, index);\r\nke->index = index;\r\nke->len = sizeof(index);\r\nmemcpy(ke->scancode, &index, sizeof(index));\r\nreturn 0;\r\n}\r\nstatic int input_default_setkeycode(struct input_dev *dev,\r\nconst struct input_keymap_entry *ke,\r\nunsigned int *old_keycode)\r\n{\r\nunsigned int index;\r\nint error;\r\nint i;\r\nif (!dev->keycodesize)\r\nreturn -EINVAL;\r\nif (ke->flags & INPUT_KEYMAP_BY_INDEX) {\r\nindex = ke->index;\r\n} else {\r\nerror = input_scancode_to_scalar(ke, &index);\r\nif (error)\r\nreturn error;\r\n}\r\nif (index >= dev->keycodemax)\r\nreturn -EINVAL;\r\nif (dev->keycodesize < sizeof(ke->keycode) &&\r\n(ke->keycode >> (dev->keycodesize * 8)))\r\nreturn -EINVAL;\r\nswitch (dev->keycodesize) {\r\ncase 1: {\r\nu8 *k = (u8 *)dev->keycode;\r\n*old_keycode = k[index];\r\nk[index] = ke->keycode;\r\nbreak;\r\n}\r\ncase 2: {\r\nu16 *k = (u16 *)dev->keycode;\r\n*old_keycode = k[index];\r\nk[index] = ke->keycode;\r\nbreak;\r\n}\r\ndefault: {\r\nu32 *k = (u32 *)dev->keycode;\r\n*old_keycode = k[index];\r\nk[index] = ke->keycode;\r\nbreak;\r\n}\r\n}\r\n__clear_bit(*old_keycode, dev->keybit);\r\n__set_bit(ke->keycode, dev->keybit);\r\nfor (i = 0; i < dev->keycodemax; i++) {\r\nif (input_fetch_keycode(dev, i) == *old_keycode) {\r\n__set_bit(*old_keycode, dev->keybit);\r\nbreak;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nint input_get_keycode(struct input_dev *dev, struct input_keymap_entry *ke)\r\n{\r\nunsigned long flags;\r\nint retval;\r\nspin_lock_irqsave(&dev->event_lock, flags);\r\nretval = dev->getkeycode(dev, ke);\r\nspin_unlock_irqrestore(&dev->event_lock, flags);\r\nreturn retval;\r\n}\r\nint input_set_keycode(struct input_dev *dev,\r\nconst struct input_keymap_entry *ke)\r\n{\r\nunsigned long flags;\r\nunsigned int old_keycode;\r\nint retval;\r\nif (ke->keycode > KEY_MAX)\r\nreturn -EINVAL;\r\nspin_lock_irqsave(&dev->event_lock, flags);\r\nretval = dev->setkeycode(dev, ke, &old_keycode);\r\nif (retval)\r\ngoto out;\r\n__clear_bit(KEY_RESERVED, dev->keybit);\r\nif (test_bit(EV_KEY, dev->evbit) &&\r\n!is_event_supported(old_keycode, dev->keybit, KEY_MAX) &&\r\n__test_and_clear_bit(old_keycode, dev->key)) {\r\nstruct input_value vals[] = {\r\n{ EV_KEY, old_keycode, 0 },\r\ninput_value_sync\r\n};\r\ninput_pass_values(dev, vals, ARRAY_SIZE(vals));\r\n}\r\nout:\r\nspin_unlock_irqrestore(&dev->event_lock, flags);\r\nreturn retval;\r\n}\r\nstatic const struct input_device_id *input_match_device(struct input_handler *handler,\r\nstruct input_dev *dev)\r\n{\r\nconst struct input_device_id *id;\r\nfor (id = handler->id_table; id->flags || id->driver_info; id++) {\r\nif (id->flags & INPUT_DEVICE_ID_MATCH_BUS)\r\nif (id->bustype != dev->id.bustype)\r\ncontinue;\r\nif (id->flags & INPUT_DEVICE_ID_MATCH_VENDOR)\r\nif (id->vendor != dev->id.vendor)\r\ncontinue;\r\nif (id->flags & INPUT_DEVICE_ID_MATCH_PRODUCT)\r\nif (id->product != dev->id.product)\r\ncontinue;\r\nif (id->flags & INPUT_DEVICE_ID_MATCH_VERSION)\r\nif (id->version != dev->id.version)\r\ncontinue;\r\nif (!bitmap_subset(id->evbit, dev->evbit, EV_MAX))\r\ncontinue;\r\nif (!bitmap_subset(id->keybit, dev->keybit, KEY_MAX))\r\ncontinue;\r\nif (!bitmap_subset(id->relbit, dev->relbit, REL_MAX))\r\ncontinue;\r\nif (!bitmap_subset(id->absbit, dev->absbit, ABS_MAX))\r\ncontinue;\r\nif (!bitmap_subset(id->mscbit, dev->mscbit, MSC_MAX))\r\ncontinue;\r\nif (!bitmap_subset(id->ledbit, dev->ledbit, LED_MAX))\r\ncontinue;\r\nif (!bitmap_subset(id->sndbit, dev->sndbit, SND_MAX))\r\ncontinue;\r\nif (!bitmap_subset(id->ffbit, dev->ffbit, FF_MAX))\r\ncontinue;\r\nif (!bitmap_subset(id->swbit, dev->swbit, SW_MAX))\r\ncontinue;\r\nif (!handler->match || handler->match(handler, dev))\r\nreturn id;\r\n}\r\nreturn NULL;\r\n}\r\nstatic int input_attach_handler(struct input_dev *dev, struct input_handler *handler)\r\n{\r\nconst struct input_device_id *id;\r\nint error;\r\nid = input_match_device(handler, dev);\r\nif (!id)\r\nreturn -ENODEV;\r\nerror = handler->connect(handler, dev, id);\r\nif (error && error != -ENODEV)\r\npr_err("failed to attach handler %s to device %s, error: %d\n",\r\nhandler->name, kobject_name(&dev->dev.kobj), error);\r\nreturn error;\r\n}\r\nstatic int input_bits_to_string(char *buf, int buf_size,\r\nunsigned long bits, bool skip_empty)\r\n{\r\nint len = 0;\r\nif (INPUT_COMPAT_TEST) {\r\nu32 dword = bits >> 32;\r\nif (dword || !skip_empty)\r\nlen += snprintf(buf, buf_size, "%x ", dword);\r\ndword = bits & 0xffffffffUL;\r\nif (dword || !skip_empty || len)\r\nlen += snprintf(buf + len, max(buf_size - len, 0),\r\n"%x", dword);\r\n} else {\r\nif (bits || !skip_empty)\r\nlen += snprintf(buf, buf_size, "%lx", bits);\r\n}\r\nreturn len;\r\n}\r\nstatic int input_bits_to_string(char *buf, int buf_size,\r\nunsigned long bits, bool skip_empty)\r\n{\r\nreturn bits || !skip_empty ?\r\nsnprintf(buf, buf_size, "%lx", bits) : 0;\r\n}\r\nstatic inline void input_wakeup_procfs_readers(void)\r\n{\r\ninput_devices_state++;\r\nwake_up(&input_devices_poll_wait);\r\n}\r\nstatic unsigned int input_proc_devices_poll(struct file *file, poll_table *wait)\r\n{\r\npoll_wait(file, &input_devices_poll_wait, wait);\r\nif (file->f_version != input_devices_state) {\r\nfile->f_version = input_devices_state;\r\nreturn POLLIN | POLLRDNORM;\r\n}\r\nreturn 0;\r\n}\r\nstatic void *input_devices_seq_start(struct seq_file *seq, loff_t *pos)\r\n{\r\nunion input_seq_state *state = (union input_seq_state *)&seq->private;\r\nint error;\r\nBUILD_BUG_ON(sizeof(union input_seq_state) != sizeof(seq->private));\r\nerror = mutex_lock_interruptible(&input_mutex);\r\nif (error) {\r\nstate->mutex_acquired = false;\r\nreturn ERR_PTR(error);\r\n}\r\nstate->mutex_acquired = true;\r\nreturn seq_list_start(&input_dev_list, *pos);\r\n}\r\nstatic void *input_devices_seq_next(struct seq_file *seq, void *v, loff_t *pos)\r\n{\r\nreturn seq_list_next(v, &input_dev_list, pos);\r\n}\r\nstatic void input_seq_stop(struct seq_file *seq, void *v)\r\n{\r\nunion input_seq_state *state = (union input_seq_state *)&seq->private;\r\nif (state->mutex_acquired)\r\nmutex_unlock(&input_mutex);\r\n}\r\nstatic void input_seq_print_bitmap(struct seq_file *seq, const char *name,\r\nunsigned long *bitmap, int max)\r\n{\r\nint i;\r\nbool skip_empty = true;\r\nchar buf[18];\r\nseq_printf(seq, "B: %s=", name);\r\nfor (i = BITS_TO_LONGS(max) - 1; i >= 0; i--) {\r\nif (input_bits_to_string(buf, sizeof(buf),\r\nbitmap[i], skip_empty)) {\r\nskip_empty = false;\r\nseq_printf(seq, "%s%s", buf, i > 0 ? " " : "");\r\n}\r\n}\r\nif (skip_empty)\r\nseq_puts(seq, "0");\r\nseq_putc(seq, '\n');\r\n}\r\nstatic int input_devices_seq_show(struct seq_file *seq, void *v)\r\n{\r\nstruct input_dev *dev = container_of(v, struct input_dev, node);\r\nconst char *path = kobject_get_path(&dev->dev.kobj, GFP_KERNEL);\r\nstruct input_handle *handle;\r\nseq_printf(seq, "I: Bus=%04x Vendor=%04x Product=%04x Version=%04x\n",\r\ndev->id.bustype, dev->id.vendor, dev->id.product, dev->id.version);\r\nseq_printf(seq, "N: Name=\"%s\"\n", dev->name ? dev->name : "");\r\nseq_printf(seq, "P: Phys=%s\n", dev->phys ? dev->phys : "");\r\nseq_printf(seq, "S: Sysfs=%s\n", path ? path : "");\r\nseq_printf(seq, "U: Uniq=%s\n", dev->uniq ? dev->uniq : "");\r\nseq_printf(seq, "H: Handlers=");\r\nlist_for_each_entry(handle, &dev->h_list, d_node)\r\nseq_printf(seq, "%s ", handle->name);\r\nseq_putc(seq, '\n');\r\ninput_seq_print_bitmap(seq, "PROP", dev->propbit, INPUT_PROP_MAX);\r\ninput_seq_print_bitmap(seq, "EV", dev->evbit, EV_MAX);\r\nif (test_bit(EV_KEY, dev->evbit))\r\ninput_seq_print_bitmap(seq, "KEY", dev->keybit, KEY_MAX);\r\nif (test_bit(EV_REL, dev->evbit))\r\ninput_seq_print_bitmap(seq, "REL", dev->relbit, REL_MAX);\r\nif (test_bit(EV_ABS, dev->evbit))\r\ninput_seq_print_bitmap(seq, "ABS", dev->absbit, ABS_MAX);\r\nif (test_bit(EV_MSC, dev->evbit))\r\ninput_seq_print_bitmap(seq, "MSC", dev->mscbit, MSC_MAX);\r\nif (test_bit(EV_LED, dev->evbit))\r\ninput_seq_print_bitmap(seq, "LED", dev->ledbit, LED_MAX);\r\nif (test_bit(EV_SND, dev->evbit))\r\ninput_seq_print_bitmap(seq, "SND", dev->sndbit, SND_MAX);\r\nif (test_bit(EV_FF, dev->evbit))\r\ninput_seq_print_bitmap(seq, "FF", dev->ffbit, FF_MAX);\r\nif (test_bit(EV_SW, dev->evbit))\r\ninput_seq_print_bitmap(seq, "SW", dev->swbit, SW_MAX);\r\nseq_putc(seq, '\n');\r\nkfree(path);\r\nreturn 0;\r\n}\r\nstatic int input_proc_devices_open(struct inode *inode, struct file *file)\r\n{\r\nreturn seq_open(file, &input_devices_seq_ops);\r\n}\r\nstatic void *input_handlers_seq_start(struct seq_file *seq, loff_t *pos)\r\n{\r\nunion input_seq_state *state = (union input_seq_state *)&seq->private;\r\nint error;\r\nBUILD_BUG_ON(sizeof(union input_seq_state) != sizeof(seq->private));\r\nerror = mutex_lock_interruptible(&input_mutex);\r\nif (error) {\r\nstate->mutex_acquired = false;\r\nreturn ERR_PTR(error);\r\n}\r\nstate->mutex_acquired = true;\r\nstate->pos = *pos;\r\nreturn seq_list_start(&input_handler_list, *pos);\r\n}\r\nstatic void *input_handlers_seq_next(struct seq_file *seq, void *v, loff_t *pos)\r\n{\r\nunion input_seq_state *state = (union input_seq_state *)&seq->private;\r\nstate->pos = *pos + 1;\r\nreturn seq_list_next(v, &input_handler_list, pos);\r\n}\r\nstatic int input_handlers_seq_show(struct seq_file *seq, void *v)\r\n{\r\nstruct input_handler *handler = container_of(v, struct input_handler, node);\r\nunion input_seq_state *state = (union input_seq_state *)&seq->private;\r\nseq_printf(seq, "N: Number=%u Name=%s", state->pos, handler->name);\r\nif (handler->filter)\r\nseq_puts(seq, " (filter)");\r\nif (handler->legacy_minors)\r\nseq_printf(seq, " Minor=%d", handler->minor);\r\nseq_putc(seq, '\n');\r\nreturn 0;\r\n}\r\nstatic int input_proc_handlers_open(struct inode *inode, struct file *file)\r\n{\r\nreturn seq_open(file, &input_handlers_seq_ops);\r\n}\r\nstatic int __init input_proc_init(void)\r\n{\r\nstruct proc_dir_entry *entry;\r\nproc_bus_input_dir = proc_mkdir("bus/input", NULL);\r\nif (!proc_bus_input_dir)\r\nreturn -ENOMEM;\r\nentry = proc_create("devices", 0, proc_bus_input_dir,\r\n&input_devices_fileops);\r\nif (!entry)\r\ngoto fail1;\r\nentry = proc_create("handlers", 0, proc_bus_input_dir,\r\n&input_handlers_fileops);\r\nif (!entry)\r\ngoto fail2;\r\nreturn 0;\r\nfail2: remove_proc_entry("devices", proc_bus_input_dir);\r\nfail1: remove_proc_entry("bus/input", NULL);\r\nreturn -ENOMEM;\r\n}\r\nstatic void input_proc_exit(void)\r\n{\r\nremove_proc_entry("devices", proc_bus_input_dir);\r\nremove_proc_entry("handlers", proc_bus_input_dir);\r\nremove_proc_entry("bus/input", NULL);\r\n}\r\nstatic inline void input_wakeup_procfs_readers(void) { }\r\nstatic inline int input_proc_init(void) { return 0; }\r\nstatic inline void input_proc_exit(void) { }\r\nstatic int input_print_modalias_bits(char *buf, int size,\r\nchar name, unsigned long *bm,\r\nunsigned int min_bit, unsigned int max_bit)\r\n{\r\nint len = 0, i;\r\nlen += snprintf(buf, max(size, 0), "%c", name);\r\nfor (i = min_bit; i < max_bit; i++)\r\nif (bm[BIT_WORD(i)] & BIT_MASK(i))\r\nlen += snprintf(buf + len, max(size - len, 0), "%X,", i);\r\nreturn len;\r\n}\r\nstatic int input_print_modalias(char *buf, int size, struct input_dev *id,\r\nint add_cr)\r\n{\r\nint len;\r\nlen = snprintf(buf, max(size, 0),\r\n"input:b%04Xv%04Xp%04Xe%04X-",\r\nid->id.bustype, id->id.vendor,\r\nid->id.product, id->id.version);\r\nlen += input_print_modalias_bits(buf + len, size - len,\r\n'e', id->evbit, 0, EV_MAX);\r\nlen += input_print_modalias_bits(buf + len, size - len,\r\n'k', id->keybit, KEY_MIN_INTERESTING, KEY_MAX);\r\nlen += input_print_modalias_bits(buf + len, size - len,\r\n'r', id->relbit, 0, REL_MAX);\r\nlen += input_print_modalias_bits(buf + len, size - len,\r\n'a', id->absbit, 0, ABS_MAX);\r\nlen += input_print_modalias_bits(buf + len, size - len,\r\n'm', id->mscbit, 0, MSC_MAX);\r\nlen += input_print_modalias_bits(buf + len, size - len,\r\n'l', id->ledbit, 0, LED_MAX);\r\nlen += input_print_modalias_bits(buf + len, size - len,\r\n's', id->sndbit, 0, SND_MAX);\r\nlen += input_print_modalias_bits(buf + len, size - len,\r\n'f', id->ffbit, 0, FF_MAX);\r\nlen += input_print_modalias_bits(buf + len, size - len,\r\n'w', id->swbit, 0, SW_MAX);\r\nif (add_cr)\r\nlen += snprintf(buf + len, max(size - len, 0), "\n");\r\nreturn len;\r\n}\r\nstatic ssize_t input_dev_show_modalias(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct input_dev *id = to_input_dev(dev);\r\nssize_t len;\r\nlen = input_print_modalias(buf, PAGE_SIZE, id, 1);\r\nreturn min_t(int, len, PAGE_SIZE);\r\n}\r\nstatic ssize_t input_dev_show_properties(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct input_dev *input_dev = to_input_dev(dev);\r\nint len = input_print_bitmap(buf, PAGE_SIZE, input_dev->propbit,\r\nINPUT_PROP_MAX, true);\r\nreturn min_t(int, len, PAGE_SIZE);\r\n}\r\nstatic int input_print_bitmap(char *buf, int buf_size, unsigned long *bitmap,\r\nint max, int add_cr)\r\n{\r\nint i;\r\nint len = 0;\r\nbool skip_empty = true;\r\nfor (i = BITS_TO_LONGS(max) - 1; i >= 0; i--) {\r\nlen += input_bits_to_string(buf + len, max(buf_size - len, 0),\r\nbitmap[i], skip_empty);\r\nif (len) {\r\nskip_empty = false;\r\nif (i > 0)\r\nlen += snprintf(buf + len, max(buf_size - len, 0), " ");\r\n}\r\n}\r\nif (len == 0)\r\nlen = snprintf(buf, buf_size, "%d", 0);\r\nif (add_cr)\r\nlen += snprintf(buf + len, max(buf_size - len, 0), "\n");\r\nreturn len;\r\n}\r\nstatic void input_dev_release(struct device *device)\r\n{\r\nstruct input_dev *dev = to_input_dev(device);\r\ninput_ff_destroy(dev);\r\ninput_mt_destroy_slots(dev);\r\nkfree(dev->absinfo);\r\nkfree(dev->vals);\r\nkfree(dev);\r\nmodule_put(THIS_MODULE);\r\n}\r\nstatic int input_add_uevent_bm_var(struct kobj_uevent_env *env,\r\nconst char *name, unsigned long *bitmap, int max)\r\n{\r\nint len;\r\nif (add_uevent_var(env, "%s", name))\r\nreturn -ENOMEM;\r\nlen = input_print_bitmap(&env->buf[env->buflen - 1],\r\nsizeof(env->buf) - env->buflen,\r\nbitmap, max, false);\r\nif (len >= (sizeof(env->buf) - env->buflen))\r\nreturn -ENOMEM;\r\nenv->buflen += len;\r\nreturn 0;\r\n}\r\nstatic int input_add_uevent_modalias_var(struct kobj_uevent_env *env,\r\nstruct input_dev *dev)\r\n{\r\nint len;\r\nif (add_uevent_var(env, "MODALIAS="))\r\nreturn -ENOMEM;\r\nlen = input_print_modalias(&env->buf[env->buflen - 1],\r\nsizeof(env->buf) - env->buflen,\r\ndev, 0);\r\nif (len >= (sizeof(env->buf) - env->buflen))\r\nreturn -ENOMEM;\r\nenv->buflen += len;\r\nreturn 0;\r\n}\r\nstatic int input_dev_uevent(struct device *device, struct kobj_uevent_env *env)\r\n{\r\nstruct input_dev *dev = to_input_dev(device);\r\nINPUT_ADD_HOTPLUG_VAR("PRODUCT=%x/%x/%x/%x",\r\ndev->id.bustype, dev->id.vendor,\r\ndev->id.product, dev->id.version);\r\nif (dev->name)\r\nINPUT_ADD_HOTPLUG_VAR("NAME=\"%s\"", dev->name);\r\nif (dev->phys)\r\nINPUT_ADD_HOTPLUG_VAR("PHYS=\"%s\"", dev->phys);\r\nif (dev->uniq)\r\nINPUT_ADD_HOTPLUG_VAR("UNIQ=\"%s\"", dev->uniq);\r\nINPUT_ADD_HOTPLUG_BM_VAR("PROP=", dev->propbit, INPUT_PROP_MAX);\r\nINPUT_ADD_HOTPLUG_BM_VAR("EV=", dev->evbit, EV_MAX);\r\nif (test_bit(EV_KEY, dev->evbit))\r\nINPUT_ADD_HOTPLUG_BM_VAR("KEY=", dev->keybit, KEY_MAX);\r\nif (test_bit(EV_REL, dev->evbit))\r\nINPUT_ADD_HOTPLUG_BM_VAR("REL=", dev->relbit, REL_MAX);\r\nif (test_bit(EV_ABS, dev->evbit))\r\nINPUT_ADD_HOTPLUG_BM_VAR("ABS=", dev->absbit, ABS_MAX);\r\nif (test_bit(EV_MSC, dev->evbit))\r\nINPUT_ADD_HOTPLUG_BM_VAR("MSC=", dev->mscbit, MSC_MAX);\r\nif (test_bit(EV_LED, dev->evbit))\r\nINPUT_ADD_HOTPLUG_BM_VAR("LED=", dev->ledbit, LED_MAX);\r\nif (test_bit(EV_SND, dev->evbit))\r\nINPUT_ADD_HOTPLUG_BM_VAR("SND=", dev->sndbit, SND_MAX);\r\nif (test_bit(EV_FF, dev->evbit))\r\nINPUT_ADD_HOTPLUG_BM_VAR("FF=", dev->ffbit, FF_MAX);\r\nif (test_bit(EV_SW, dev->evbit))\r\nINPUT_ADD_HOTPLUG_BM_VAR("SW=", dev->swbit, SW_MAX);\r\nINPUT_ADD_HOTPLUG_MODALIAS_VAR(dev);\r\nreturn 0;\r\n}\r\nstatic void input_dev_toggle(struct input_dev *dev, bool activate)\r\n{\r\nif (!dev->event)\r\nreturn;\r\nINPUT_DO_TOGGLE(dev, LED, led, activate);\r\nINPUT_DO_TOGGLE(dev, SND, snd, activate);\r\nif (activate && test_bit(EV_REP, dev->evbit)) {\r\ndev->event(dev, EV_REP, REP_PERIOD, dev->rep[REP_PERIOD]);\r\ndev->event(dev, EV_REP, REP_DELAY, dev->rep[REP_DELAY]);\r\n}\r\n}\r\nvoid input_reset_device(struct input_dev *dev)\r\n{\r\nmutex_lock(&dev->mutex);\r\nif (dev->users) {\r\ninput_dev_toggle(dev, true);\r\nspin_lock_irq(&dev->event_lock);\r\ninput_dev_release_keys(dev);\r\nspin_unlock_irq(&dev->event_lock);\r\n}\r\nmutex_unlock(&dev->mutex);\r\n}\r\nstatic int input_dev_suspend(struct device *dev)\r\n{\r\nstruct input_dev *input_dev = to_input_dev(dev);\r\nmutex_lock(&input_dev->mutex);\r\nif (input_dev->users)\r\ninput_dev_toggle(input_dev, false);\r\nmutex_unlock(&input_dev->mutex);\r\nreturn 0;\r\n}\r\nstatic int input_dev_resume(struct device *dev)\r\n{\r\nstruct input_dev *input_dev = to_input_dev(dev);\r\ninput_reset_device(input_dev);\r\nreturn 0;\r\n}\r\nstatic char *input_devnode(struct device *dev, umode_t *mode)\r\n{\r\nreturn kasprintf(GFP_KERNEL, "input/%s", dev_name(dev));\r\n}\r\nstruct input_dev *input_allocate_device(void)\r\n{\r\nstruct input_dev *dev;\r\ndev = kzalloc(sizeof(struct input_dev), GFP_KERNEL);\r\nif (dev) {\r\ndev->dev.type = &input_dev_type;\r\ndev->dev.class = &input_class;\r\ndevice_initialize(&dev->dev);\r\nmutex_init(&dev->mutex);\r\nspin_lock_init(&dev->event_lock);\r\nINIT_LIST_HEAD(&dev->h_list);\r\nINIT_LIST_HEAD(&dev->node);\r\n__module_get(THIS_MODULE);\r\n}\r\nreturn dev;\r\n}\r\nstatic int devm_input_device_match(struct device *dev, void *res, void *data)\r\n{\r\nstruct input_devres *devres = res;\r\nreturn devres->input == data;\r\n}\r\nstatic void devm_input_device_release(struct device *dev, void *res)\r\n{\r\nstruct input_devres *devres = res;\r\nstruct input_dev *input = devres->input;\r\ndev_dbg(dev, "%s: dropping reference to %s\n",\r\n__func__, dev_name(&input->dev));\r\ninput_put_device(input);\r\n}\r\nstruct input_dev *devm_input_allocate_device(struct device *dev)\r\n{\r\nstruct input_dev *input;\r\nstruct input_devres *devres;\r\ndevres = devres_alloc(devm_input_device_release,\r\nsizeof(struct input_devres), GFP_KERNEL);\r\nif (!devres)\r\nreturn NULL;\r\ninput = input_allocate_device();\r\nif (!input) {\r\ndevres_free(devres);\r\nreturn NULL;\r\n}\r\ninput->dev.parent = dev;\r\ninput->devres_managed = true;\r\ndevres->input = input;\r\ndevres_add(dev, devres);\r\nreturn input;\r\n}\r\nvoid input_free_device(struct input_dev *dev)\r\n{\r\nif (dev) {\r\nif (dev->devres_managed)\r\nWARN_ON(devres_destroy(dev->dev.parent,\r\ndevm_input_device_release,\r\ndevm_input_device_match,\r\ndev));\r\ninput_put_device(dev);\r\n}\r\n}\r\nvoid input_set_capability(struct input_dev *dev, unsigned int type, unsigned int code)\r\n{\r\nswitch (type) {\r\ncase EV_KEY:\r\n__set_bit(code, dev->keybit);\r\nbreak;\r\ncase EV_REL:\r\n__set_bit(code, dev->relbit);\r\nbreak;\r\ncase EV_ABS:\r\n__set_bit(code, dev->absbit);\r\nbreak;\r\ncase EV_MSC:\r\n__set_bit(code, dev->mscbit);\r\nbreak;\r\ncase EV_SW:\r\n__set_bit(code, dev->swbit);\r\nbreak;\r\ncase EV_LED:\r\n__set_bit(code, dev->ledbit);\r\nbreak;\r\ncase EV_SND:\r\n__set_bit(code, dev->sndbit);\r\nbreak;\r\ncase EV_FF:\r\n__set_bit(code, dev->ffbit);\r\nbreak;\r\ncase EV_PWR:\r\nbreak;\r\ndefault:\r\npr_err("input_set_capability: unknown type %u (code %u)\n",\r\ntype, code);\r\ndump_stack();\r\nreturn;\r\n}\r\n__set_bit(type, dev->evbit);\r\n}\r\nstatic unsigned int input_estimate_events_per_packet(struct input_dev *dev)\r\n{\r\nint mt_slots;\r\nint i;\r\nunsigned int events;\r\nif (dev->mt) {\r\nmt_slots = dev->mt->num_slots;\r\n} else if (test_bit(ABS_MT_TRACKING_ID, dev->absbit)) {\r\nmt_slots = dev->absinfo[ABS_MT_TRACKING_ID].maximum -\r\ndev->absinfo[ABS_MT_TRACKING_ID].minimum + 1,\r\nmt_slots = clamp(mt_slots, 2, 32);\r\n} else if (test_bit(ABS_MT_POSITION_X, dev->absbit)) {\r\nmt_slots = 2;\r\n} else {\r\nmt_slots = 0;\r\n}\r\nevents = mt_slots + 1;\r\nfor (i = 0; i < ABS_CNT; i++) {\r\nif (test_bit(i, dev->absbit)) {\r\nif (input_is_mt_axis(i))\r\nevents += mt_slots;\r\nelse\r\nevents++;\r\n}\r\n}\r\nfor (i = 0; i < REL_CNT; i++)\r\nif (test_bit(i, dev->relbit))\r\nevents++;\r\nevents += 7;\r\nreturn events;\r\n}\r\nstatic void input_cleanse_bitmasks(struct input_dev *dev)\r\n{\r\nINPUT_CLEANSE_BITMASK(dev, KEY, key);\r\nINPUT_CLEANSE_BITMASK(dev, REL, rel);\r\nINPUT_CLEANSE_BITMASK(dev, ABS, abs);\r\nINPUT_CLEANSE_BITMASK(dev, MSC, msc);\r\nINPUT_CLEANSE_BITMASK(dev, LED, led);\r\nINPUT_CLEANSE_BITMASK(dev, SND, snd);\r\nINPUT_CLEANSE_BITMASK(dev, FF, ff);\r\nINPUT_CLEANSE_BITMASK(dev, SW, sw);\r\n}\r\nstatic void __input_unregister_device(struct input_dev *dev)\r\n{\r\nstruct input_handle *handle, *next;\r\ninput_disconnect_device(dev);\r\nmutex_lock(&input_mutex);\r\nlist_for_each_entry_safe(handle, next, &dev->h_list, d_node)\r\nhandle->handler->disconnect(handle);\r\nWARN_ON(!list_empty(&dev->h_list));\r\ndel_timer_sync(&dev->timer);\r\nlist_del_init(&dev->node);\r\ninput_wakeup_procfs_readers();\r\nmutex_unlock(&input_mutex);\r\ndevice_del(&dev->dev);\r\n}\r\nstatic void devm_input_device_unregister(struct device *dev, void *res)\r\n{\r\nstruct input_devres *devres = res;\r\nstruct input_dev *input = devres->input;\r\ndev_dbg(dev, "%s: unregistering device %s\n",\r\n__func__, dev_name(&input->dev));\r\n__input_unregister_device(input);\r\n}\r\nint input_register_device(struct input_dev *dev)\r\n{\r\nstatic atomic_t input_no = ATOMIC_INIT(0);\r\nstruct input_devres *devres = NULL;\r\nstruct input_handler *handler;\r\nunsigned int packet_size;\r\nconst char *path;\r\nint error;\r\nif (dev->devres_managed) {\r\ndevres = devres_alloc(devm_input_device_unregister,\r\nsizeof(struct input_devres), GFP_KERNEL);\r\nif (!devres)\r\nreturn -ENOMEM;\r\ndevres->input = dev;\r\n}\r\n__set_bit(EV_SYN, dev->evbit);\r\n__clear_bit(KEY_RESERVED, dev->keybit);\r\ninput_cleanse_bitmasks(dev);\r\npacket_size = input_estimate_events_per_packet(dev);\r\nif (dev->hint_events_per_packet < packet_size)\r\ndev->hint_events_per_packet = packet_size;\r\ndev->max_vals = max(dev->hint_events_per_packet, packet_size) + 2;\r\ndev->vals = kcalloc(dev->max_vals, sizeof(*dev->vals), GFP_KERNEL);\r\nif (!dev->vals) {\r\nerror = -ENOMEM;\r\ngoto err_devres_free;\r\n}\r\ninit_timer(&dev->timer);\r\nif (!dev->rep[REP_DELAY] && !dev->rep[REP_PERIOD]) {\r\ndev->timer.data = (long) dev;\r\ndev->timer.function = input_repeat_key;\r\ndev->rep[REP_DELAY] = 250;\r\ndev->rep[REP_PERIOD] = 33;\r\n}\r\nif (!dev->getkeycode)\r\ndev->getkeycode = input_default_getkeycode;\r\nif (!dev->setkeycode)\r\ndev->setkeycode = input_default_setkeycode;\r\ndev_set_name(&dev->dev, "input%ld",\r\n(unsigned long) atomic_inc_return(&input_no) - 1);\r\nerror = device_add(&dev->dev);\r\nif (error)\r\ngoto err_free_vals;\r\npath = kobject_get_path(&dev->dev.kobj, GFP_KERNEL);\r\npr_info("%s as %s\n",\r\ndev->name ? dev->name : "Unspecified device",\r\npath ? path : "N/A");\r\nkfree(path);\r\nerror = mutex_lock_interruptible(&input_mutex);\r\nif (error)\r\ngoto err_device_del;\r\nlist_add_tail(&dev->node, &input_dev_list);\r\nlist_for_each_entry(handler, &input_handler_list, node)\r\ninput_attach_handler(dev, handler);\r\ninput_wakeup_procfs_readers();\r\nmutex_unlock(&input_mutex);\r\nif (dev->devres_managed) {\r\ndev_dbg(dev->dev.parent, "%s: registering %s with devres.\n",\r\n__func__, dev_name(&dev->dev));\r\ndevres_add(dev->dev.parent, devres);\r\n}\r\nreturn 0;\r\nerr_device_del:\r\ndevice_del(&dev->dev);\r\nerr_free_vals:\r\nkfree(dev->vals);\r\ndev->vals = NULL;\r\nerr_devres_free:\r\ndevres_free(devres);\r\nreturn error;\r\n}\r\nvoid input_unregister_device(struct input_dev *dev)\r\n{\r\nif (dev->devres_managed) {\r\nWARN_ON(devres_destroy(dev->dev.parent,\r\ndevm_input_device_unregister,\r\ndevm_input_device_match,\r\ndev));\r\n__input_unregister_device(dev);\r\n} else {\r\n__input_unregister_device(dev);\r\ninput_put_device(dev);\r\n}\r\n}\r\nint input_register_handler(struct input_handler *handler)\r\n{\r\nstruct input_dev *dev;\r\nint error;\r\nerror = mutex_lock_interruptible(&input_mutex);\r\nif (error)\r\nreturn error;\r\nINIT_LIST_HEAD(&handler->h_list);\r\nlist_add_tail(&handler->node, &input_handler_list);\r\nlist_for_each_entry(dev, &input_dev_list, node)\r\ninput_attach_handler(dev, handler);\r\ninput_wakeup_procfs_readers();\r\nmutex_unlock(&input_mutex);\r\nreturn 0;\r\n}\r\nvoid input_unregister_handler(struct input_handler *handler)\r\n{\r\nstruct input_handle *handle, *next;\r\nmutex_lock(&input_mutex);\r\nlist_for_each_entry_safe(handle, next, &handler->h_list, h_node)\r\nhandler->disconnect(handle);\r\nWARN_ON(!list_empty(&handler->h_list));\r\nlist_del_init(&handler->node);\r\ninput_wakeup_procfs_readers();\r\nmutex_unlock(&input_mutex);\r\n}\r\nint input_handler_for_each_handle(struct input_handler *handler, void *data,\r\nint (*fn)(struct input_handle *, void *))\r\n{\r\nstruct input_handle *handle;\r\nint retval = 0;\r\nrcu_read_lock();\r\nlist_for_each_entry_rcu(handle, &handler->h_list, h_node) {\r\nretval = fn(handle, data);\r\nif (retval)\r\nbreak;\r\n}\r\nrcu_read_unlock();\r\nreturn retval;\r\n}\r\nint input_register_handle(struct input_handle *handle)\r\n{\r\nstruct input_handler *handler = handle->handler;\r\nstruct input_dev *dev = handle->dev;\r\nint error;\r\nerror = mutex_lock_interruptible(&dev->mutex);\r\nif (error)\r\nreturn error;\r\nif (handler->filter)\r\nlist_add_rcu(&handle->d_node, &dev->h_list);\r\nelse\r\nlist_add_tail_rcu(&handle->d_node, &dev->h_list);\r\nmutex_unlock(&dev->mutex);\r\nlist_add_tail_rcu(&handle->h_node, &handler->h_list);\r\nif (handler->start)\r\nhandler->start(handle);\r\nreturn 0;\r\n}\r\nvoid input_unregister_handle(struct input_handle *handle)\r\n{\r\nstruct input_dev *dev = handle->dev;\r\nlist_del_rcu(&handle->h_node);\r\nmutex_lock(&dev->mutex);\r\nlist_del_rcu(&handle->d_node);\r\nmutex_unlock(&dev->mutex);\r\nsynchronize_rcu();\r\n}\r\nint input_get_new_minor(int legacy_base, unsigned int legacy_num,\r\nbool allow_dynamic)\r\n{\r\nif (legacy_base >= 0) {\r\nint minor = ida_simple_get(&input_ida,\r\nlegacy_base,\r\nlegacy_base + legacy_num,\r\nGFP_KERNEL);\r\nif (minor >= 0 || !allow_dynamic)\r\nreturn minor;\r\n}\r\nreturn ida_simple_get(&input_ida,\r\nINPUT_FIRST_DYNAMIC_DEV, INPUT_MAX_CHAR_DEVICES,\r\nGFP_KERNEL);\r\n}\r\nvoid input_free_minor(unsigned int minor)\r\n{\r\nida_simple_remove(&input_ida, minor);\r\n}\r\nstatic int __init input_init(void)\r\n{\r\nint err;\r\nerr = class_register(&input_class);\r\nif (err) {\r\npr_err("unable to register input_dev class\n");\r\nreturn err;\r\n}\r\nerr = input_proc_init();\r\nif (err)\r\ngoto fail1;\r\nerr = register_chrdev_region(MKDEV(INPUT_MAJOR, 0),\r\nINPUT_MAX_CHAR_DEVICES, "input");\r\nif (err) {\r\npr_err("unable to register char major %d", INPUT_MAJOR);\r\ngoto fail2;\r\n}\r\nreturn 0;\r\nfail2: input_proc_exit();\r\nfail1: class_unregister(&input_class);\r\nreturn err;\r\n}\r\nstatic void __exit input_exit(void)\r\n{\r\ninput_proc_exit();\r\nunregister_chrdev_region(MKDEV(INPUT_MAJOR, 0),\r\nINPUT_MAX_CHAR_DEVICES);\r\nclass_unregister(&input_class);\r\n}
