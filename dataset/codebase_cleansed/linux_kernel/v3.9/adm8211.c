static void adm8211_eeprom_register_read(struct eeprom_93cx6 *eeprom)\r\n{\r\nstruct adm8211_priv *priv = eeprom->data;\r\nu32 reg = ADM8211_CSR_READ(SPR);\r\neeprom->reg_data_in = reg & ADM8211_SPR_SDI;\r\neeprom->reg_data_out = reg & ADM8211_SPR_SDO;\r\neeprom->reg_data_clock = reg & ADM8211_SPR_SCLK;\r\neeprom->reg_chip_select = reg & ADM8211_SPR_SCS;\r\n}\r\nstatic void adm8211_eeprom_register_write(struct eeprom_93cx6 *eeprom)\r\n{\r\nstruct adm8211_priv *priv = eeprom->data;\r\nu32 reg = 0x4000 | ADM8211_SPR_SRS;\r\nif (eeprom->reg_data_in)\r\nreg |= ADM8211_SPR_SDI;\r\nif (eeprom->reg_data_out)\r\nreg |= ADM8211_SPR_SDO;\r\nif (eeprom->reg_data_clock)\r\nreg |= ADM8211_SPR_SCLK;\r\nif (eeprom->reg_chip_select)\r\nreg |= ADM8211_SPR_SCS;\r\nADM8211_CSR_WRITE(SPR, reg);\r\nADM8211_CSR_READ(SPR);\r\n}\r\nstatic int adm8211_read_eeprom(struct ieee80211_hw *dev)\r\n{\r\nstruct adm8211_priv *priv = dev->priv;\r\nunsigned int words, i;\r\nstruct ieee80211_chan_range chan_range;\r\nu16 cr49;\r\nstruct eeprom_93cx6 eeprom = {\r\n.data = priv,\r\n.register_read = adm8211_eeprom_register_read,\r\n.register_write = adm8211_eeprom_register_write\r\n};\r\nif (ADM8211_CSR_READ(CSR_TEST0) & ADM8211_CSR_TEST0_EPTYP) {\r\neeprom.width = PCI_EEPROM_WIDTH_93C66;\r\nwords = 256;\r\n} else {\r\neeprom.width = PCI_EEPROM_WIDTH_93C46;\r\nwords = 64;\r\n}\r\npriv->eeprom_len = words * 2;\r\npriv->eeprom = kmalloc(priv->eeprom_len, GFP_KERNEL);\r\nif (!priv->eeprom)\r\nreturn -ENOMEM;\r\neeprom_93cx6_multiread(&eeprom, 0, (__le16 *)priv->eeprom, words);\r\ncr49 = le16_to_cpu(priv->eeprom->cr49);\r\npriv->rf_type = (cr49 >> 3) & 0x7;\r\nswitch (priv->rf_type) {\r\ncase ADM8211_TYPE_INTERSIL:\r\ncase ADM8211_TYPE_RFMD:\r\ncase ADM8211_TYPE_MARVEL:\r\ncase ADM8211_TYPE_AIROHA:\r\ncase ADM8211_TYPE_ADMTEK:\r\nbreak;\r\ndefault:\r\nif (priv->pdev->revision < ADM8211_REV_CA)\r\npriv->rf_type = ADM8211_TYPE_RFMD;\r\nelse\r\npriv->rf_type = ADM8211_TYPE_AIROHA;\r\nprintk(KERN_WARNING "%s (adm8211): Unknown RFtype %d\n",\r\npci_name(priv->pdev), (cr49 >> 3) & 0x7);\r\n}\r\npriv->bbp_type = cr49 & 0x7;\r\nswitch (priv->bbp_type) {\r\ncase ADM8211_TYPE_INTERSIL:\r\ncase ADM8211_TYPE_RFMD:\r\ncase ADM8211_TYPE_MARVEL:\r\ncase ADM8211_TYPE_AIROHA:\r\ncase ADM8211_TYPE_ADMTEK:\r\nbreak;\r\ndefault:\r\nif (priv->pdev->revision < ADM8211_REV_CA)\r\npriv->bbp_type = ADM8211_TYPE_RFMD;\r\nelse\r\npriv->bbp_type = ADM8211_TYPE_ADMTEK;\r\nprintk(KERN_WARNING "%s (adm8211): Unknown BBPtype: %d\n",\r\npci_name(priv->pdev), cr49 >> 3);\r\n}\r\nif (priv->eeprom->country_code >= ARRAY_SIZE(cranges)) {\r\nprintk(KERN_WARNING "%s (adm8211): Invalid country code (%d)\n",\r\npci_name(priv->pdev), priv->eeprom->country_code);\r\nchan_range = cranges[2];\r\n} else\r\nchan_range = cranges[priv->eeprom->country_code];\r\nprintk(KERN_DEBUG "%s (adm8211): Channel range: %d - %d\n",\r\npci_name(priv->pdev), (int)chan_range.min, (int)chan_range.max);\r\nBUILD_BUG_ON(sizeof(priv->channels) != sizeof(adm8211_channels));\r\nmemcpy(priv->channels, adm8211_channels, sizeof(priv->channels));\r\npriv->band.channels = priv->channels;\r\npriv->band.n_channels = ARRAY_SIZE(adm8211_channels);\r\npriv->band.bitrates = adm8211_rates;\r\npriv->band.n_bitrates = ARRAY_SIZE(adm8211_rates);\r\nfor (i = 1; i <= ARRAY_SIZE(adm8211_channels); i++)\r\nif (i < chan_range.min || i > chan_range.max)\r\npriv->channels[i - 1].flags |= IEEE80211_CHAN_DISABLED;\r\nswitch (priv->eeprom->specific_bbptype) {\r\ncase ADM8211_BBP_RFMD3000:\r\ncase ADM8211_BBP_RFMD3002:\r\ncase ADM8211_BBP_ADM8011:\r\npriv->specific_bbptype = priv->eeprom->specific_bbptype;\r\nbreak;\r\ndefault:\r\nif (priv->pdev->revision < ADM8211_REV_CA)\r\npriv->specific_bbptype = ADM8211_BBP_RFMD3000;\r\nelse\r\npriv->specific_bbptype = ADM8211_BBP_ADM8011;\r\nprintk(KERN_WARNING "%s (adm8211): Unknown specific BBP: %d\n",\r\npci_name(priv->pdev), priv->eeprom->specific_bbptype);\r\n}\r\nswitch (priv->eeprom->specific_rftype) {\r\ncase ADM8211_RFMD2948:\r\ncase ADM8211_RFMD2958:\r\ncase ADM8211_RFMD2958_RF3000_CONTROL_POWER:\r\ncase ADM8211_MAX2820:\r\ncase ADM8211_AL2210L:\r\npriv->transceiver_type = priv->eeprom->specific_rftype;\r\nbreak;\r\ndefault:\r\nif (priv->pdev->revision == ADM8211_REV_BA)\r\npriv->transceiver_type = ADM8211_RFMD2958_RF3000_CONTROL_POWER;\r\nelse if (priv->pdev->revision == ADM8211_REV_CA)\r\npriv->transceiver_type = ADM8211_AL2210L;\r\nelse if (priv->pdev->revision == ADM8211_REV_AB)\r\npriv->transceiver_type = ADM8211_RFMD2948;\r\nprintk(KERN_WARNING "%s (adm8211): Unknown transceiver: %d\n",\r\npci_name(priv->pdev), priv->eeprom->specific_rftype);\r\nbreak;\r\n}\r\nprintk(KERN_DEBUG "%s (adm8211): RFtype=%d BBPtype=%d Specific BBP=%d "\r\n"Transceiver=%d\n", pci_name(priv->pdev), priv->rf_type,\r\npriv->bbp_type, priv->specific_bbptype, priv->transceiver_type);\r\nreturn 0;\r\n}\r\nstatic inline void adm8211_write_sram(struct ieee80211_hw *dev,\r\nu32 addr, u32 data)\r\n{\r\nstruct adm8211_priv *priv = dev->priv;\r\nADM8211_CSR_WRITE(WEPCTL, addr | ADM8211_WEPCTL_TABLE_WR |\r\n(priv->pdev->revision < ADM8211_REV_BA ?\r\n0 : ADM8211_WEPCTL_SEL_WEPTABLE ));\r\nADM8211_CSR_READ(WEPCTL);\r\nmsleep(1);\r\nADM8211_CSR_WRITE(WESK, data);\r\nADM8211_CSR_READ(WESK);\r\nmsleep(1);\r\n}\r\nstatic void adm8211_write_sram_bytes(struct ieee80211_hw *dev,\r\nunsigned int addr, u8 *buf,\r\nunsigned int len)\r\n{\r\nstruct adm8211_priv *priv = dev->priv;\r\nu32 reg = ADM8211_CSR_READ(WEPCTL);\r\nunsigned int i;\r\nif (priv->pdev->revision < ADM8211_REV_BA) {\r\nfor (i = 0; i < len; i += 2) {\r\nu16 val = buf[i] | (buf[i + 1] << 8);\r\nadm8211_write_sram(dev, addr + i / 2, val);\r\n}\r\n} else {\r\nfor (i = 0; i < len; i += 4) {\r\nu32 val = (buf[i + 0] << 0 ) | (buf[i + 1] << 8 ) |\r\n(buf[i + 2] << 16) | (buf[i + 3] << 24);\r\nadm8211_write_sram(dev, addr + i / 4, val);\r\n}\r\n}\r\nADM8211_CSR_WRITE(WEPCTL, reg);\r\n}\r\nstatic void adm8211_clear_sram(struct ieee80211_hw *dev)\r\n{\r\nstruct adm8211_priv *priv = dev->priv;\r\nu32 reg = ADM8211_CSR_READ(WEPCTL);\r\nunsigned int addr;\r\nfor (addr = 0; addr < ADM8211_SRAM_SIZE; addr++)\r\nadm8211_write_sram(dev, addr, 0);\r\nADM8211_CSR_WRITE(WEPCTL, reg);\r\n}\r\nstatic int adm8211_get_stats(struct ieee80211_hw *dev,\r\nstruct ieee80211_low_level_stats *stats)\r\n{\r\nstruct adm8211_priv *priv = dev->priv;\r\nmemcpy(stats, &priv->stats, sizeof(*stats));\r\nreturn 0;\r\n}\r\nstatic void adm8211_interrupt_tci(struct ieee80211_hw *dev)\r\n{\r\nstruct adm8211_priv *priv = dev->priv;\r\nunsigned int dirty_tx;\r\nspin_lock(&priv->lock);\r\nfor (dirty_tx = priv->dirty_tx; priv->cur_tx - dirty_tx; dirty_tx++) {\r\nunsigned int entry = dirty_tx % priv->tx_ring_size;\r\nu32 status = le32_to_cpu(priv->tx_ring[entry].status);\r\nstruct ieee80211_tx_info *txi;\r\nstruct adm8211_tx_ring_info *info;\r\nstruct sk_buff *skb;\r\nif (status & TDES0_CONTROL_OWN ||\r\n!(status & TDES0_CONTROL_DONE))\r\nbreak;\r\ninfo = &priv->tx_buffers[entry];\r\nskb = info->skb;\r\ntxi = IEEE80211_SKB_CB(skb);\r\npci_unmap_single(priv->pdev, info->mapping,\r\ninfo->skb->len, PCI_DMA_TODEVICE);\r\nieee80211_tx_info_clear_status(txi);\r\nskb_pull(skb, sizeof(struct adm8211_tx_hdr));\r\nmemcpy(skb_push(skb, info->hdrlen), skb->cb, info->hdrlen);\r\nif (!(txi->flags & IEEE80211_TX_CTL_NO_ACK) &&\r\n!(status & TDES0_STATUS_ES))\r\ntxi->flags |= IEEE80211_TX_STAT_ACK;\r\nieee80211_tx_status_irqsafe(dev, skb);\r\ninfo->skb = NULL;\r\n}\r\nif (priv->cur_tx - dirty_tx < priv->tx_ring_size - 2)\r\nieee80211_wake_queue(dev, 0);\r\npriv->dirty_tx = dirty_tx;\r\nspin_unlock(&priv->lock);\r\n}\r\nstatic void adm8211_interrupt_rci(struct ieee80211_hw *dev)\r\n{\r\nstruct adm8211_priv *priv = dev->priv;\r\nunsigned int entry = priv->cur_rx % priv->rx_ring_size;\r\nu32 status;\r\nunsigned int pktlen;\r\nstruct sk_buff *skb, *newskb;\r\nunsigned int limit = priv->rx_ring_size;\r\nu8 rssi, rate;\r\nwhile (!(priv->rx_ring[entry].status & cpu_to_le32(RDES0_STATUS_OWN))) {\r\nif (!limit--)\r\nbreak;\r\nstatus = le32_to_cpu(priv->rx_ring[entry].status);\r\nrate = (status & RDES0_STATUS_RXDR) >> 12;\r\nrssi = le32_to_cpu(priv->rx_ring[entry].length) &\r\nRDES1_STATUS_RSSI;\r\npktlen = status & RDES0_STATUS_FL;\r\nif (pktlen > RX_PKT_SIZE) {\r\nif (net_ratelimit())\r\nwiphy_debug(dev->wiphy, "frame too long (%d)\n",\r\npktlen);\r\npktlen = RX_PKT_SIZE;\r\n}\r\nif (!priv->soft_rx_crc && status & RDES0_STATUS_ES) {\r\nskb = NULL;\r\n} else if (pktlen < RX_COPY_BREAK) {\r\nskb = dev_alloc_skb(pktlen);\r\nif (skb) {\r\npci_dma_sync_single_for_cpu(\r\npriv->pdev,\r\npriv->rx_buffers[entry].mapping,\r\npktlen, PCI_DMA_FROMDEVICE);\r\nmemcpy(skb_put(skb, pktlen),\r\nskb_tail_pointer(priv->rx_buffers[entry].skb),\r\npktlen);\r\npci_dma_sync_single_for_device(\r\npriv->pdev,\r\npriv->rx_buffers[entry].mapping,\r\nRX_PKT_SIZE, PCI_DMA_FROMDEVICE);\r\n}\r\n} else {\r\nnewskb = dev_alloc_skb(RX_PKT_SIZE);\r\nif (newskb) {\r\nskb = priv->rx_buffers[entry].skb;\r\nskb_put(skb, pktlen);\r\npci_unmap_single(\r\npriv->pdev,\r\npriv->rx_buffers[entry].mapping,\r\nRX_PKT_SIZE, PCI_DMA_FROMDEVICE);\r\npriv->rx_buffers[entry].skb = newskb;\r\npriv->rx_buffers[entry].mapping =\r\npci_map_single(priv->pdev,\r\nskb_tail_pointer(newskb),\r\nRX_PKT_SIZE,\r\nPCI_DMA_FROMDEVICE);\r\n} else {\r\nskb = NULL;\r\n}\r\npriv->rx_ring[entry].buffer1 =\r\ncpu_to_le32(priv->rx_buffers[entry].mapping);\r\n}\r\npriv->rx_ring[entry].status = cpu_to_le32(RDES0_STATUS_OWN |\r\nRDES0_STATUS_SQL);\r\npriv->rx_ring[entry].length =\r\ncpu_to_le32(RX_PKT_SIZE |\r\n(entry == priv->rx_ring_size - 1 ?\r\nRDES1_CONTROL_RER : 0));\r\nif (skb) {\r\nstruct ieee80211_rx_status rx_status = {0};\r\nif (priv->pdev->revision < ADM8211_REV_CA)\r\nrx_status.signal = rssi;\r\nelse\r\nrx_status.signal = 100 - rssi;\r\nrx_status.rate_idx = rate;\r\nrx_status.freq = adm8211_channels[priv->channel - 1].center_freq;\r\nrx_status.band = IEEE80211_BAND_2GHZ;\r\nmemcpy(IEEE80211_SKB_RXCB(skb), &rx_status, sizeof(rx_status));\r\nieee80211_rx_irqsafe(dev, skb);\r\n}\r\nentry = (++priv->cur_rx) % priv->rx_ring_size;\r\n}\r\n}\r\nstatic irqreturn_t adm8211_interrupt(int irq, void *dev_id)\r\n{\r\n#define ADM8211_INT(x) \\r\ndo { \\r\nif (unlikely(stsr & ADM8211_STSR_ ## x)) \\r\nwiphy_debug(dev->wiphy, "%s\n", #x); \\r\n} while (0)\r\nstruct ieee80211_hw *dev = dev_id;\r\nstruct adm8211_priv *priv = dev->priv;\r\nu32 stsr = ADM8211_CSR_READ(STSR);\r\nADM8211_CSR_WRITE(STSR, stsr);\r\nif (stsr == 0xffffffff)\r\nreturn IRQ_HANDLED;\r\nif (!(stsr & (ADM8211_STSR_NISS | ADM8211_STSR_AISS)))\r\nreturn IRQ_HANDLED;\r\nif (stsr & ADM8211_STSR_RCI)\r\nadm8211_interrupt_rci(dev);\r\nif (stsr & ADM8211_STSR_TCI)\r\nadm8211_interrupt_tci(dev);\r\nADM8211_INT(PCF);\r\nADM8211_INT(BCNTC);\r\nADM8211_INT(GPINT);\r\nADM8211_INT(ATIMTC);\r\nADM8211_INT(TSFTF);\r\nADM8211_INT(TSCZ);\r\nADM8211_INT(SQL);\r\nADM8211_INT(WEPTD);\r\nADM8211_INT(ATIME);\r\nADM8211_INT(TEIS);\r\nADM8211_INT(FBE);\r\nADM8211_INT(REIS);\r\nADM8211_INT(GPTT);\r\nADM8211_INT(RPS);\r\nADM8211_INT(RDU);\r\nADM8211_INT(TUF);\r\nADM8211_INT(TPS);\r\nreturn IRQ_HANDLED;\r\n#undef ADM8211_INT\r\n}\r\nstatic int adm8211_write_bbp(struct ieee80211_hw *dev, u8 addr, u8 data)\r\n{\r\nstruct adm8211_priv *priv = dev->priv;\r\nunsigned int timeout;\r\nu32 reg;\r\ntimeout = 10;\r\nwhile (timeout > 0) {\r\nreg = ADM8211_CSR_READ(BBPCTL);\r\nif (!(reg & (ADM8211_BBPCTL_WR | ADM8211_BBPCTL_RD)))\r\nbreak;\r\ntimeout--;\r\nmsleep(2);\r\n}\r\nif (timeout == 0) {\r\nwiphy_debug(dev->wiphy,\r\n"adm8211_write_bbp(%d,%d) failed prewrite (reg=0x%08x)\n",\r\naddr, data, reg);\r\nreturn -ETIMEDOUT;\r\n}\r\nswitch (priv->bbp_type) {\r\ncase ADM8211_TYPE_INTERSIL:\r\nreg = ADM8211_BBPCTL_MMISEL;\r\nbreak;\r\ncase ADM8211_TYPE_RFMD:\r\nreg = (0x20 << 24) | ADM8211_BBPCTL_TXCE | ADM8211_BBPCTL_CCAP |\r\n(0x01 << 18);\r\nbreak;\r\ncase ADM8211_TYPE_ADMTEK:\r\nreg = (0x20 << 24) | ADM8211_BBPCTL_TXCE | ADM8211_BBPCTL_CCAP |\r\n(0x05 << 18);\r\nbreak;\r\n}\r\nreg |= ADM8211_BBPCTL_WR | (addr << 8) | data;\r\nADM8211_CSR_WRITE(BBPCTL, reg);\r\ntimeout = 10;\r\nwhile (timeout > 0) {\r\nreg = ADM8211_CSR_READ(BBPCTL);\r\nif (!(reg & ADM8211_BBPCTL_WR))\r\nbreak;\r\ntimeout--;\r\nmsleep(2);\r\n}\r\nif (timeout == 0) {\r\nADM8211_CSR_WRITE(BBPCTL, ADM8211_CSR_READ(BBPCTL) &\r\n~ADM8211_BBPCTL_WR);\r\nwiphy_debug(dev->wiphy,\r\n"adm8211_write_bbp(%d,%d) failed postwrite (reg=0x%08x)\n",\r\naddr, data, reg);\r\nreturn -ETIMEDOUT;\r\n}\r\nreturn 0;\r\n}\r\nstatic int adm8211_rf_set_channel(struct ieee80211_hw *dev, unsigned int chan)\r\n{\r\nstatic const u32 adm8211_rfmd2958_reg5[] =\r\n{0x22BD, 0x22D2, 0x22E8, 0x22FE, 0x2314, 0x232A, 0x2340,\r\n0x2355, 0x236B, 0x2381, 0x2397, 0x23AD, 0x23C2, 0x23F7};\r\nstatic const u32 adm8211_rfmd2958_reg6[] =\r\n{0x05D17, 0x3A2E8, 0x2E8BA, 0x22E8B, 0x1745D, 0x0BA2E, 0x00000,\r\n0x345D1, 0x28BA2, 0x1D174, 0x11745, 0x05D17, 0x3A2E8, 0x11745};\r\nstruct adm8211_priv *priv = dev->priv;\r\nu8 ant_power = priv->ant_power > 0x3F ?\r\npriv->eeprom->antenna_power[chan - 1] : priv->ant_power;\r\nu8 tx_power = priv->tx_power > 0x3F ?\r\npriv->eeprom->tx_power[chan - 1] : priv->tx_power;\r\nu8 lpf_cutoff = priv->lpf_cutoff == 0xFF ?\r\npriv->eeprom->lpf_cutoff[chan - 1] : priv->lpf_cutoff;\r\nu8 lnags_thresh = priv->lnags_threshold == 0xFF ?\r\npriv->eeprom->lnags_threshold[chan - 1] : priv->lnags_threshold;\r\nu32 reg;\r\nADM8211_IDLE();\r\nswitch (priv->transceiver_type) {\r\ncase ADM8211_RFMD2958:\r\ncase ADM8211_RFMD2958_RF3000_CONTROL_POWER:\r\nadm8211_rf_write_syn_rfmd2958(dev, 0x00, 0x04007);\r\nadm8211_rf_write_syn_rfmd2958(dev, 0x02, 0x00033);\r\nadm8211_rf_write_syn_rfmd2958(dev, 0x05,\r\nadm8211_rfmd2958_reg5[chan - 1]);\r\nadm8211_rf_write_syn_rfmd2958(dev, 0x06,\r\nadm8211_rfmd2958_reg6[chan - 1]);\r\nbreak;\r\ncase ADM8211_RFMD2948:\r\nadm8211_rf_write_syn_rfmd2948(dev, SI4126_MAIN_CONF,\r\nSI4126_MAIN_XINDIV2);\r\nadm8211_rf_write_syn_rfmd2948(dev, SI4126_POWERDOWN,\r\nSI4126_POWERDOWN_PDIB |\r\nSI4126_POWERDOWN_PDRB);\r\nadm8211_rf_write_syn_rfmd2948(dev, SI4126_PHASE_DET_GAIN, 0);\r\nadm8211_rf_write_syn_rfmd2948(dev, SI4126_RF2_N_DIV,\r\n(chan == 14 ?\r\n2110 : (2033 + (chan * 5))));\r\nadm8211_rf_write_syn_rfmd2948(dev, SI4126_IF_N_DIV, 1496);\r\nadm8211_rf_write_syn_rfmd2948(dev, SI4126_RF2_R_DIV, 44);\r\nadm8211_rf_write_syn_rfmd2948(dev, SI4126_IF_R_DIV, 44);\r\nbreak;\r\ncase ADM8211_MAX2820:\r\nadm8211_rf_write_syn_max2820(dev, 0x3,\r\n(chan == 14 ? 0x054 : (0x7 + (chan * 5))));\r\nbreak;\r\ncase ADM8211_AL2210L:\r\nadm8211_rf_write_syn_al2210l(dev, 0x0,\r\n(chan == 14 ? 0x229B4 : (0x22967 + (chan * 5))));\r\nbreak;\r\ndefault:\r\nwiphy_debug(dev->wiphy, "unsupported transceiver type %d\n",\r\npriv->transceiver_type);\r\nbreak;\r\n}\r\nif (priv->bbp_type == ADM8211_TYPE_RFMD) {\r\nif (priv->transceiver_type == ADM8211_RFMD2948) {\r\nreg = ADM8211_CSR_READ(GPIO);\r\nreg &= 0xfffc0000;\r\nreg |= ADM8211_CSR_GPIO_EN0;\r\nif (chan != 14)\r\nreg |= ADM8211_CSR_GPIO_O0;\r\nADM8211_CSR_WRITE(GPIO, reg);\r\n}\r\nif (priv->transceiver_type == ADM8211_RFMD2958) {\r\nadm8211_rf_write_syn_rfmd2958(dev, 0x0B, 0x07100);\r\nreg = le16_to_cpu(priv->eeprom->cr49);\r\nreg >>= 13;\r\nreg <<= 15;\r\nreg |= ant_power << 9;\r\nadm8211_rf_write_syn_rfmd2958(dev, 0x0A, reg);\r\nadm8211_rf_write_syn_rfmd2958(dev, 0x09, 0x00050 |\r\n(priv->pdev->revision < ADM8211_REV_CA ? tx_power : 0));\r\n} else {\r\nreg = ADM8211_CSR_READ(PLCPHD);\r\nreg &= 0xff00ffff;\r\nreg |= tx_power << 18;\r\nADM8211_CSR_WRITE(PLCPHD, reg);\r\n}\r\nADM8211_CSR_WRITE(SYNRF, ADM8211_SYNRF_SELRF |\r\nADM8211_SYNRF_PE1 | ADM8211_SYNRF_PHYRST);\r\nADM8211_CSR_READ(SYNRF);\r\nmsleep(30);\r\nif (priv->transceiver_type != ADM8211_RFMD2958)\r\nadm8211_write_bbp(dev, RF3000_TX_VAR_GAIN__TX_LEN_EXT,\r\ntx_power<<2);\r\nadm8211_write_bbp(dev, RF3000_LOW_GAIN_CALIB, lpf_cutoff);\r\nadm8211_write_bbp(dev, RF3000_HIGH_GAIN_CALIB, lnags_thresh);\r\nadm8211_write_bbp(dev, 0x1c, priv->pdev->revision == ADM8211_REV_BA ?\r\npriv->eeprom->cr28 : 0);\r\nadm8211_write_bbp(dev, 0x1d, priv->eeprom->cr29);\r\nADM8211_CSR_WRITE(SYNRF, 0);\r\n} else if (priv->bbp_type != ADM8211_TYPE_ADMTEK)\r\nwiphy_debug(dev->wiphy, "unsupported BBP type %d\n",\r\npriv->bbp_type);\r\nADM8211_RESTORE();\r\nreg = ADM8211_CSR_READ(CAP0);\r\nreg &= ~0xF;\r\nreg |= chan;\r\nADM8211_CSR_WRITE(CAP0, reg);\r\nreturn 0;\r\n}\r\nstatic void adm8211_update_mode(struct ieee80211_hw *dev)\r\n{\r\nstruct adm8211_priv *priv = dev->priv;\r\nADM8211_IDLE();\r\npriv->soft_rx_crc = 0;\r\nswitch (priv->mode) {\r\ncase NL80211_IFTYPE_STATION:\r\npriv->nar &= ~(ADM8211_NAR_PR | ADM8211_NAR_EA);\r\npriv->nar |= ADM8211_NAR_ST | ADM8211_NAR_SR;\r\nbreak;\r\ncase NL80211_IFTYPE_ADHOC:\r\npriv->nar &= ~ADM8211_NAR_PR;\r\npriv->nar |= ADM8211_NAR_EA | ADM8211_NAR_ST | ADM8211_NAR_SR;\r\nif (priv->pdev->revision >= ADM8211_REV_BA)\r\npriv->soft_rx_crc = 1;\r\nbreak;\r\ncase NL80211_IFTYPE_MONITOR:\r\npriv->nar &= ~(ADM8211_NAR_EA | ADM8211_NAR_ST);\r\npriv->nar |= ADM8211_NAR_PR | ADM8211_NAR_SR;\r\nbreak;\r\n}\r\nADM8211_RESTORE();\r\n}\r\nstatic void adm8211_hw_init_syn(struct ieee80211_hw *dev)\r\n{\r\nstruct adm8211_priv *priv = dev->priv;\r\nswitch (priv->transceiver_type) {\r\ncase ADM8211_RFMD2958:\r\ncase ADM8211_RFMD2958_RF3000_CONTROL_POWER:\r\nadm8211_rf_write_syn_rfmd2958(dev, 0x1F, 0x00000);\r\nadm8211_rf_write_syn_rfmd2958(dev, 0x0C, 0x3001F);\r\nadm8211_rf_write_syn_rfmd2958(dev, 0x01, 0x29C03);\r\nadm8211_rf_write_syn_rfmd2958(dev, 0x03, 0x1FF6F);\r\nadm8211_rf_write_syn_rfmd2958(dev, 0x04, 0x29403);\r\nadm8211_rf_write_syn_rfmd2958(dev, 0x07, 0x1456F);\r\nadm8211_rf_write_syn_rfmd2958(dev, 0x09,\r\n(priv->transceiver_type == ADM8211_RFMD2958 ?\r\n0x10050 : 0x00050));\r\nadm8211_rf_write_syn_rfmd2958(dev, 0x08, 0x3FFF8);\r\nbreak;\r\ncase ADM8211_MAX2820:\r\nadm8211_rf_write_syn_max2820(dev, 0x1, 0x01E);\r\nadm8211_rf_write_syn_max2820(dev, 0x2, 0x001);\r\nadm8211_rf_write_syn_max2820(dev, 0x3, 0x054);\r\nadm8211_rf_write_syn_max2820(dev, 0x4, 0x310);\r\nadm8211_rf_write_syn_max2820(dev, 0x5, 0x000);\r\nbreak;\r\ncase ADM8211_AL2210L:\r\nadm8211_rf_write_syn_al2210l(dev, 0x0, 0x0196C);\r\nadm8211_rf_write_syn_al2210l(dev, 0x1, 0x007CB);\r\nadm8211_rf_write_syn_al2210l(dev, 0x2, 0x3582F);\r\nadm8211_rf_write_syn_al2210l(dev, 0x3, 0x010A9);\r\nadm8211_rf_write_syn_al2210l(dev, 0x4, 0x77280);\r\nadm8211_rf_write_syn_al2210l(dev, 0x5, 0x45641);\r\nadm8211_rf_write_syn_al2210l(dev, 0x6, 0xEA130);\r\nadm8211_rf_write_syn_al2210l(dev, 0x7, 0x80000);\r\nadm8211_rf_write_syn_al2210l(dev, 0x8, 0x7850F);\r\nadm8211_rf_write_syn_al2210l(dev, 0x9, 0xF900C);\r\nadm8211_rf_write_syn_al2210l(dev, 0xA, 0x00000);\r\nadm8211_rf_write_syn_al2210l(dev, 0xB, 0x00000);\r\nbreak;\r\ncase ADM8211_RFMD2948:\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic int adm8211_hw_init_bbp(struct ieee80211_hw *dev)\r\n{\r\nstruct adm8211_priv *priv = dev->priv;\r\nu32 reg;\r\nif (priv->bbp_type == ADM8211_TYPE_INTERSIL) {\r\nADM8211_CSR_WRITE(MMIWA, 0x100E0C0A);\r\nADM8211_CSR_WRITE(MMIRD0, 0x00007C7E);\r\nADM8211_CSR_WRITE(MMIRD1, 0x00100000);\r\n} else if (priv->bbp_type == ADM8211_TYPE_RFMD ||\r\npriv->bbp_type == ADM8211_TYPE_ADMTEK) {\r\nswitch (priv->specific_bbptype) {\r\ncase ADM8211_BBP_RFMD3000:\r\ncase ADM8211_BBP_RFMD3002:\r\nADM8211_CSR_WRITE(MMIWA, 0x00009101);\r\nADM8211_CSR_WRITE(MMIRD0, 0x00000301);\r\nbreak;\r\ncase ADM8211_BBP_ADM8011:\r\nADM8211_CSR_WRITE(MMIWA, 0x00008903);\r\nADM8211_CSR_WRITE(MMIRD0, 0x00001716);\r\nreg = ADM8211_CSR_READ(BBPCTL);\r\nreg &= ~ADM8211_BBPCTL_TYPE;\r\nreg |= 0x5 << 18;\r\nADM8211_CSR_WRITE(BBPCTL, reg);\r\nbreak;\r\n}\r\nswitch (priv->pdev->revision) {\r\ncase ADM8211_REV_CA:\r\nif (priv->transceiver_type == ADM8211_RFMD2958 ||\r\npriv->transceiver_type == ADM8211_RFMD2958_RF3000_CONTROL_POWER ||\r\npriv->transceiver_type == ADM8211_RFMD2948)\r\nADM8211_CSR_WRITE(SYNCTL, 0x1 << 22);\r\nelse if (priv->transceiver_type == ADM8211_MAX2820 ||\r\npriv->transceiver_type == ADM8211_AL2210L)\r\nADM8211_CSR_WRITE(SYNCTL, 0x3 << 22);\r\nbreak;\r\ncase ADM8211_REV_BA:\r\nreg = ADM8211_CSR_READ(MMIRD1);\r\nreg &= 0x0000FFFF;\r\nreg |= 0x7e100000;\r\nADM8211_CSR_WRITE(MMIRD1, reg);\r\nbreak;\r\ncase ADM8211_REV_AB:\r\ncase ADM8211_REV_AF:\r\ndefault:\r\nADM8211_CSR_WRITE(MMIRD1, 0x7e100000);\r\nbreak;\r\n}\r\nADM8211_CSR_WRITE(MACTEST, 0x800);\r\n}\r\nadm8211_hw_init_syn(dev);\r\nADM8211_CSR_WRITE(SYNRF, ADM8211_SYNRF_SELRF |\r\nADM8211_SYNRF_PE1 | ADM8211_SYNRF_PHYRST);\r\nADM8211_CSR_READ(SYNRF);\r\nmsleep(20);\r\nif (priv->bbp_type == ADM8211_TYPE_RFMD) {\r\nadm8211_write_bbp(dev, RF3000_CCA_CTRL, 0x80);\r\nadm8211_write_bbp(dev, RF3000_DIVERSITY__RSSI, 0x80);\r\nadm8211_write_bbp(dev, RF3000_TX_VAR_GAIN__TX_LEN_EXT, 0x74);\r\nadm8211_write_bbp(dev, RF3000_LOW_GAIN_CALIB, 0x38);\r\nadm8211_write_bbp(dev, RF3000_HIGH_GAIN_CALIB, 0x40);\r\nif (priv->eeprom->major_version < 2) {\r\nadm8211_write_bbp(dev, 0x1c, 0x00);\r\nadm8211_write_bbp(dev, 0x1d, 0x80);\r\n} else {\r\nif (priv->pdev->revision == ADM8211_REV_BA)\r\nadm8211_write_bbp(dev, 0x1c, priv->eeprom->cr28);\r\nelse\r\nadm8211_write_bbp(dev, 0x1c, 0x00);\r\nadm8211_write_bbp(dev, 0x1d, priv->eeprom->cr29);\r\n}\r\n} else if (priv->bbp_type == ADM8211_TYPE_ADMTEK) {\r\nadm8211_write_bbp(dev, 0x00, 0xFF);\r\nadm8211_write_bbp(dev, 0x07, 0x0A);\r\nswitch (priv->transceiver_type) {\r\ncase ADM8211_RFMD2958:\r\ncase ADM8211_RFMD2958_RF3000_CONTROL_POWER:\r\nadm8211_write_bbp(dev, 0x00, 0x00);\r\nadm8211_write_bbp(dev, 0x01, 0x00);\r\nadm8211_write_bbp(dev, 0x02, 0x00);\r\nadm8211_write_bbp(dev, 0x03, 0x00);\r\nadm8211_write_bbp(dev, 0x06, 0x0f);\r\nadm8211_write_bbp(dev, 0x09, 0x00);\r\nadm8211_write_bbp(dev, 0x0a, 0x00);\r\nadm8211_write_bbp(dev, 0x0b, 0x00);\r\nadm8211_write_bbp(dev, 0x0c, 0x00);\r\nadm8211_write_bbp(dev, 0x0f, 0xAA);\r\nadm8211_write_bbp(dev, 0x10, 0x8c);\r\nadm8211_write_bbp(dev, 0x11, 0x43);\r\nadm8211_write_bbp(dev, 0x18, 0x40);\r\nadm8211_write_bbp(dev, 0x20, 0x23);\r\nadm8211_write_bbp(dev, 0x21, 0x02);\r\nadm8211_write_bbp(dev, 0x22, 0x28);\r\nadm8211_write_bbp(dev, 0x23, 0x30);\r\nadm8211_write_bbp(dev, 0x24, 0x2d);\r\nadm8211_write_bbp(dev, 0x28, 0x35);\r\nadm8211_write_bbp(dev, 0x2a, 0x8c);\r\nadm8211_write_bbp(dev, 0x2b, 0x81);\r\nadm8211_write_bbp(dev, 0x2c, 0x44);\r\nadm8211_write_bbp(dev, 0x2d, 0x0A);\r\nadm8211_write_bbp(dev, 0x29, 0x40);\r\nadm8211_write_bbp(dev, 0x60, 0x08);\r\nadm8211_write_bbp(dev, 0x64, 0x01);\r\nbreak;\r\ncase ADM8211_MAX2820:\r\nadm8211_write_bbp(dev, 0x00, 0x00);\r\nadm8211_write_bbp(dev, 0x01, 0x00);\r\nadm8211_write_bbp(dev, 0x02, 0x00);\r\nadm8211_write_bbp(dev, 0x03, 0x00);\r\nadm8211_write_bbp(dev, 0x06, 0x0f);\r\nadm8211_write_bbp(dev, 0x09, 0x05);\r\nadm8211_write_bbp(dev, 0x0a, 0x02);\r\nadm8211_write_bbp(dev, 0x0b, 0x00);\r\nadm8211_write_bbp(dev, 0x0c, 0x0f);\r\nadm8211_write_bbp(dev, 0x0f, 0x55);\r\nadm8211_write_bbp(dev, 0x10, 0x8d);\r\nadm8211_write_bbp(dev, 0x11, 0x43);\r\nadm8211_write_bbp(dev, 0x18, 0x4a);\r\nadm8211_write_bbp(dev, 0x20, 0x20);\r\nadm8211_write_bbp(dev, 0x21, 0x02);\r\nadm8211_write_bbp(dev, 0x22, 0x23);\r\nadm8211_write_bbp(dev, 0x23, 0x30);\r\nadm8211_write_bbp(dev, 0x24, 0x2d);\r\nadm8211_write_bbp(dev, 0x2a, 0x8c);\r\nadm8211_write_bbp(dev, 0x2b, 0x81);\r\nadm8211_write_bbp(dev, 0x2c, 0x44);\r\nadm8211_write_bbp(dev, 0x29, 0x4a);\r\nadm8211_write_bbp(dev, 0x60, 0x2b);\r\nadm8211_write_bbp(dev, 0x64, 0x01);\r\nbreak;\r\ncase ADM8211_AL2210L:\r\nadm8211_write_bbp(dev, 0x00, 0x00);\r\nadm8211_write_bbp(dev, 0x01, 0x00);\r\nadm8211_write_bbp(dev, 0x02, 0x00);\r\nadm8211_write_bbp(dev, 0x03, 0x00);\r\nadm8211_write_bbp(dev, 0x06, 0x0f);\r\nadm8211_write_bbp(dev, 0x07, 0x05);\r\nadm8211_write_bbp(dev, 0x08, 0x03);\r\nadm8211_write_bbp(dev, 0x09, 0x00);\r\nadm8211_write_bbp(dev, 0x0a, 0x00);\r\nadm8211_write_bbp(dev, 0x0b, 0x00);\r\nadm8211_write_bbp(dev, 0x0c, 0x10);\r\nadm8211_write_bbp(dev, 0x0f, 0x55);\r\nadm8211_write_bbp(dev, 0x10, 0x8d);\r\nadm8211_write_bbp(dev, 0x11, 0x43);\r\nadm8211_write_bbp(dev, 0x18, 0x4a);\r\nadm8211_write_bbp(dev, 0x20, 0x20);\r\nadm8211_write_bbp(dev, 0x21, 0x02);\r\nadm8211_write_bbp(dev, 0x22, 0x23);\r\nadm8211_write_bbp(dev, 0x23, 0x30);\r\nadm8211_write_bbp(dev, 0x24, 0x2d);\r\nadm8211_write_bbp(dev, 0x2a, 0xaa);\r\nadm8211_write_bbp(dev, 0x2b, 0x81);\r\nadm8211_write_bbp(dev, 0x2c, 0x44);\r\nadm8211_write_bbp(dev, 0x29, 0xfa);\r\nadm8211_write_bbp(dev, 0x60, 0x2d);\r\nadm8211_write_bbp(dev, 0x64, 0x01);\r\nbreak;\r\ncase ADM8211_RFMD2948:\r\nbreak;\r\ndefault:\r\nwiphy_debug(dev->wiphy, "unsupported transceiver %d\n",\r\npriv->transceiver_type);\r\nbreak;\r\n}\r\n} else\r\nwiphy_debug(dev->wiphy, "unsupported BBP %d\n", priv->bbp_type);\r\nADM8211_CSR_WRITE(SYNRF, 0);\r\nreg = ADM8211_CSR_READ(SYNCTL);\r\nreg |= ADM8211_SYNCTL_SELCAL;\r\nADM8211_CSR_WRITE(SYNCTL, reg);\r\nreturn 0;\r\n}\r\nstatic int adm8211_set_rate(struct ieee80211_hw *dev)\r\n{\r\nstruct adm8211_priv *priv = dev->priv;\r\nu32 reg;\r\nint i = 0;\r\nu8 rate_buf[12] = {0};\r\nif (priv->pdev->revision != ADM8211_REV_BA) {\r\nrate_buf[0] = ARRAY_SIZE(adm8211_rates);\r\nfor (i = 0; i < ARRAY_SIZE(adm8211_rates); i++)\r\nrate_buf[i + 1] = (adm8211_rates[i].bitrate / 5) | 0x80;\r\n} else {\r\nrate_buf[0] = 0x04;\r\nrate_buf[1] = 0x82;\r\nrate_buf[2] = 0x04;\r\nrate_buf[3] = 0x0b;\r\nrate_buf[4] = 0x16;\r\n}\r\nadm8211_write_sram_bytes(dev, ADM8211_SRAM_SUPP_RATE, rate_buf,\r\nARRAY_SIZE(adm8211_rates) + 1);\r\nreg = ADM8211_CSR_READ(PLCPHD) & 0x00FFFFFF;\r\nreg |= 1 << 15;\r\nreg |= 110 << 24;\r\nADM8211_CSR_WRITE(PLCPHD, reg);\r\nADM8211_CSR_WRITE(TXLMT, (512 << 16) | (110 << 8) | (224 << 0));\r\nreturn 0;\r\n}\r\nstatic void adm8211_hw_init(struct ieee80211_hw *dev)\r\n{\r\nstruct adm8211_priv *priv = dev->priv;\r\nu32 reg;\r\nu8 cline;\r\nreg = ADM8211_CSR_READ(PAR);\r\nreg |= ADM8211_PAR_MRLE | ADM8211_PAR_MRME;\r\nreg &= ~(ADM8211_PAR_BAR | ADM8211_PAR_CAL);\r\nif (!pci_set_mwi(priv->pdev)) {\r\nreg |= 0x1 << 24;\r\npci_read_config_byte(priv->pdev, PCI_CACHE_LINE_SIZE, &cline);\r\nswitch (cline) {\r\ncase 0x8: reg |= (0x1 << 14);\r\nbreak;\r\ncase 0x16: reg |= (0x2 << 14);\r\nbreak;\r\ncase 0x32: reg |= (0x3 << 14);\r\nbreak;\r\ndefault: reg |= (0x0 << 14);\r\nbreak;\r\n}\r\n}\r\nADM8211_CSR_WRITE(PAR, reg);\r\nreg = ADM8211_CSR_READ(CSR_TEST1);\r\nreg &= ~(0xF << 28);\r\nreg |= (1 << 28) | (1 << 31);\r\nADM8211_CSR_WRITE(CSR_TEST1, reg);\r\nreg = (0x04 << 21) | ADM8211_WCSR_TSFTWE | ADM8211_WCSR_LSOE;\r\nADM8211_CSR_WRITE(WCSR, reg);\r\nreg = ADM8211_CSR_READ(CMDR);\r\nreg &= ~(ADM8211_CMDR_APM | ADM8211_CMDR_DRT);\r\nreg |= ADM8211_CMDR_RTE | ADM8211_CMDR_DRT_SF;\r\nADM8211_CSR_WRITE(CMDR, reg);\r\nadm8211_set_rate(dev);\r\nif (priv->pdev->revision < ADM8211_REV_CA)\r\nADM8211_CSR_WRITE(TOFS2, 0x8815cd18);\r\nelse\r\nADM8211_CSR_WRITE(TOFS2, 0x8535cd16);\r\npriv->nar = ADM8211_NAR_SF | ADM8211_NAR_PB;\r\nADM8211_CSR_WRITE(NAR, priv->nar);\r\nADM8211_CSR_WRITE(SYNRF, ADM8211_SYNRF_RADIO);\r\nADM8211_CSR_READ(SYNRF);\r\nmsleep(10);\r\nADM8211_CSR_WRITE(SYNRF, 0);\r\nADM8211_CSR_READ(SYNRF);\r\nmsleep(5);\r\nreg = ADM8211_CSR_READ(CFPP);\r\nreg &= ~(0xffff << 8);\r\nreg |= 0x0010 << 8;\r\nADM8211_CSR_WRITE(CFPP, reg);\r\nADM8211_CSR_WRITE(TOFS0, (0x16 << 24) | 0x3ff);\r\nif (priv->pdev->revision < ADM8211_REV_CA)\r\nADM8211_CSR_WRITE(IFST, (20 << 23) | (110 << 15) |\r\n(50 << 9) | 100);\r\nelse\r\nADM8211_CSR_WRITE(IFST, (20 << 23) | (24 << 15) |\r\n(50 << 9) | 100);\r\nADM8211_CSR_WRITE(RMD, (1 << 16) | 18769);\r\nADM8211_CSR_WRITE(RSPT, 0xffffff00);\r\nadm8211_hw_init_bbp(dev);\r\nADM8211_CSR_WRITE(IER, 0);\r\nADM8211_CSR_WRITE(STSR, ADM8211_CSR_READ(STSR));\r\nreg = ADM8211_CSR_READ(MACTEST);\r\nreg &= ~(7 << 20);\r\nADM8211_CSR_WRITE(MACTEST, reg);\r\nreg = ADM8211_CSR_READ(WEPCTL);\r\nreg &= ~ADM8211_WEPCTL_WEPENABLE;\r\nreg |= ADM8211_WEPCTL_WEPRXBYP;\r\nADM8211_CSR_WRITE(WEPCTL, reg);\r\nADM8211_CSR_READ(LPC);\r\n}\r\nstatic int adm8211_hw_reset(struct ieee80211_hw *dev)\r\n{\r\nstruct adm8211_priv *priv = dev->priv;\r\nu32 reg, tmp;\r\nint timeout = 100;\r\nADM8211_CSR_WRITE(FRCTL, 0);\r\ntmp = ADM8211_CSR_READ(PAR);\r\nADM8211_CSR_WRITE(PAR, ADM8211_PAR_SWR);\r\nwhile ((ADM8211_CSR_READ(PAR) & ADM8211_PAR_SWR) && timeout--)\r\nmsleep(50);\r\nif (timeout <= 0)\r\nreturn -ETIMEDOUT;\r\nADM8211_CSR_WRITE(PAR, tmp);\r\nif (priv->pdev->revision == ADM8211_REV_BA &&\r\n(priv->transceiver_type == ADM8211_RFMD2958_RF3000_CONTROL_POWER ||\r\npriv->transceiver_type == ADM8211_RFMD2958)) {\r\nreg = ADM8211_CSR_READ(CSR_TEST1);\r\nreg |= (1 << 4) | (1 << 5);\r\nADM8211_CSR_WRITE(CSR_TEST1, reg);\r\n} else if (priv->pdev->revision == ADM8211_REV_CA) {\r\nreg = ADM8211_CSR_READ(CSR_TEST1);\r\nreg &= ~((1 << 4) | (1 << 5));\r\nADM8211_CSR_WRITE(CSR_TEST1, reg);\r\n}\r\nADM8211_CSR_WRITE(FRCTL, 0);\r\nreg = ADM8211_CSR_READ(CSR_TEST0);\r\nreg |= ADM8211_CSR_TEST0_EPRLD;\r\nADM8211_CSR_WRITE(CSR_TEST0, reg);\r\nadm8211_clear_sram(dev);\r\nreturn 0;\r\n}\r\nstatic u64 adm8211_get_tsft(struct ieee80211_hw *dev,\r\nstruct ieee80211_vif *vif)\r\n{\r\nstruct adm8211_priv *priv = dev->priv;\r\nu32 tsftl;\r\nu64 tsft;\r\ntsftl = ADM8211_CSR_READ(TSFTL);\r\ntsft = ADM8211_CSR_READ(TSFTH);\r\ntsft <<= 32;\r\ntsft |= tsftl;\r\nreturn tsft;\r\n}\r\nstatic void adm8211_set_interval(struct ieee80211_hw *dev,\r\nunsigned short bi, unsigned short li)\r\n{\r\nstruct adm8211_priv *priv = dev->priv;\r\nu32 reg;\r\nreg = (bi << 16) | li;\r\nADM8211_CSR_WRITE(BPLI, reg);\r\n}\r\nstatic void adm8211_set_bssid(struct ieee80211_hw *dev, const u8 *bssid)\r\n{\r\nstruct adm8211_priv *priv = dev->priv;\r\nu32 reg;\r\nADM8211_CSR_WRITE(BSSID0, le32_to_cpu(*(__le32 *)bssid));\r\nreg = ADM8211_CSR_READ(ABDA1);\r\nreg &= 0x0000ffff;\r\nreg |= (bssid[4] << 16) | (bssid[5] << 24);\r\nADM8211_CSR_WRITE(ABDA1, reg);\r\n}\r\nstatic int adm8211_config(struct ieee80211_hw *dev, u32 changed)\r\n{\r\nstruct adm8211_priv *priv = dev->priv;\r\nstruct ieee80211_conf *conf = &dev->conf;\r\nint channel = ieee80211_frequency_to_channel(conf->channel->center_freq);\r\nif (channel != priv->channel) {\r\npriv->channel = channel;\r\nadm8211_rf_set_channel(dev, priv->channel);\r\n}\r\nreturn 0;\r\n}\r\nstatic void adm8211_bss_info_changed(struct ieee80211_hw *dev,\r\nstruct ieee80211_vif *vif,\r\nstruct ieee80211_bss_conf *conf,\r\nu32 changes)\r\n{\r\nstruct adm8211_priv *priv = dev->priv;\r\nif (!(changes & BSS_CHANGED_BSSID))\r\nreturn;\r\nif (memcmp(conf->bssid, priv->bssid, ETH_ALEN)) {\r\nadm8211_set_bssid(dev, conf->bssid);\r\nmemcpy(priv->bssid, conf->bssid, ETH_ALEN);\r\n}\r\n}\r\nstatic u64 adm8211_prepare_multicast(struct ieee80211_hw *hw,\r\nstruct netdev_hw_addr_list *mc_list)\r\n{\r\nunsigned int bit_nr;\r\nu32 mc_filter[2];\r\nstruct netdev_hw_addr *ha;\r\nmc_filter[1] = mc_filter[0] = 0;\r\nnetdev_hw_addr_list_for_each(ha, mc_list) {\r\nbit_nr = ether_crc(ETH_ALEN, ha->addr) >> 26;\r\nbit_nr &= 0x3F;\r\nmc_filter[bit_nr >> 5] |= 1 << (bit_nr & 31);\r\n}\r\nreturn mc_filter[0] | ((u64)(mc_filter[1]) << 32);\r\n}\r\nstatic void adm8211_configure_filter(struct ieee80211_hw *dev,\r\nunsigned int changed_flags,\r\nunsigned int *total_flags,\r\nu64 multicast)\r\n{\r\nstatic const u8 bcast[ETH_ALEN] = { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF };\r\nstruct adm8211_priv *priv = dev->priv;\r\nunsigned int new_flags;\r\nu32 mc_filter[2];\r\nmc_filter[0] = multicast;\r\nmc_filter[1] = multicast >> 32;\r\nnew_flags = 0;\r\nif (*total_flags & FIF_PROMISC_IN_BSS) {\r\nnew_flags |= FIF_PROMISC_IN_BSS;\r\npriv->nar |= ADM8211_NAR_PR;\r\npriv->nar &= ~ADM8211_NAR_MM;\r\nmc_filter[1] = mc_filter[0] = ~0;\r\n} else if (*total_flags & FIF_ALLMULTI || multicast == ~(0ULL)) {\r\nnew_flags |= FIF_ALLMULTI;\r\npriv->nar &= ~ADM8211_NAR_PR;\r\npriv->nar |= ADM8211_NAR_MM;\r\nmc_filter[1] = mc_filter[0] = ~0;\r\n} else {\r\npriv->nar &= ~(ADM8211_NAR_MM | ADM8211_NAR_PR);\r\n}\r\nADM8211_IDLE_RX();\r\nADM8211_CSR_WRITE(MAR0, mc_filter[0]);\r\nADM8211_CSR_WRITE(MAR1, mc_filter[1]);\r\nADM8211_CSR_READ(NAR);\r\nif (priv->nar & ADM8211_NAR_PR)\r\ndev->flags |= IEEE80211_HW_RX_INCLUDES_FCS;\r\nelse\r\ndev->flags &= ~IEEE80211_HW_RX_INCLUDES_FCS;\r\nif (*total_flags & FIF_BCN_PRBRESP_PROMISC)\r\nadm8211_set_bssid(dev, bcast);\r\nelse\r\nadm8211_set_bssid(dev, priv->bssid);\r\nADM8211_RESTORE();\r\n*total_flags = new_flags;\r\n}\r\nstatic int adm8211_add_interface(struct ieee80211_hw *dev,\r\nstruct ieee80211_vif *vif)\r\n{\r\nstruct adm8211_priv *priv = dev->priv;\r\nif (priv->mode != NL80211_IFTYPE_MONITOR)\r\nreturn -EOPNOTSUPP;\r\nswitch (vif->type) {\r\ncase NL80211_IFTYPE_STATION:\r\npriv->mode = vif->type;\r\nbreak;\r\ndefault:\r\nreturn -EOPNOTSUPP;\r\n}\r\nADM8211_IDLE();\r\nADM8211_CSR_WRITE(PAR0, le32_to_cpu(*(__le32 *)vif->addr));\r\nADM8211_CSR_WRITE(PAR1, le16_to_cpu(*(__le16 *)(vif->addr + 4)));\r\nadm8211_update_mode(dev);\r\nADM8211_RESTORE();\r\nreturn 0;\r\n}\r\nstatic void adm8211_remove_interface(struct ieee80211_hw *dev,\r\nstruct ieee80211_vif *vif)\r\n{\r\nstruct adm8211_priv *priv = dev->priv;\r\npriv->mode = NL80211_IFTYPE_MONITOR;\r\n}\r\nstatic int adm8211_init_rings(struct ieee80211_hw *dev)\r\n{\r\nstruct adm8211_priv *priv = dev->priv;\r\nstruct adm8211_desc *desc = NULL;\r\nstruct adm8211_rx_ring_info *rx_info;\r\nstruct adm8211_tx_ring_info *tx_info;\r\nunsigned int i;\r\nfor (i = 0; i < priv->rx_ring_size; i++) {\r\ndesc = &priv->rx_ring[i];\r\ndesc->status = 0;\r\ndesc->length = cpu_to_le32(RX_PKT_SIZE);\r\npriv->rx_buffers[i].skb = NULL;\r\n}\r\ndesc->length |= cpu_to_le32(RDES1_CONTROL_RER);\r\nfor (i = 0; i < priv->rx_ring_size; i++) {\r\ndesc = &priv->rx_ring[i];\r\nrx_info = &priv->rx_buffers[i];\r\nrx_info->skb = dev_alloc_skb(RX_PKT_SIZE);\r\nif (rx_info->skb == NULL)\r\nbreak;\r\nrx_info->mapping = pci_map_single(priv->pdev,\r\nskb_tail_pointer(rx_info->skb),\r\nRX_PKT_SIZE,\r\nPCI_DMA_FROMDEVICE);\r\ndesc->buffer1 = cpu_to_le32(rx_info->mapping);\r\ndesc->status = cpu_to_le32(RDES0_STATUS_OWN | RDES0_STATUS_SQL);\r\n}\r\nfor (i = 0; i < priv->tx_ring_size; i++) {\r\ndesc = &priv->tx_ring[i];\r\ntx_info = &priv->tx_buffers[i];\r\ntx_info->skb = NULL;\r\ntx_info->mapping = 0;\r\ndesc->status = 0;\r\n}\r\ndesc->length = cpu_to_le32(TDES1_CONTROL_TER);\r\npriv->cur_rx = priv->cur_tx = priv->dirty_tx = 0;\r\nADM8211_CSR_WRITE(RDB, priv->rx_ring_dma);\r\nADM8211_CSR_WRITE(TDBD, priv->tx_ring_dma);\r\nreturn 0;\r\n}\r\nstatic void adm8211_free_rings(struct ieee80211_hw *dev)\r\n{\r\nstruct adm8211_priv *priv = dev->priv;\r\nunsigned int i;\r\nfor (i = 0; i < priv->rx_ring_size; i++) {\r\nif (!priv->rx_buffers[i].skb)\r\ncontinue;\r\npci_unmap_single(\r\npriv->pdev,\r\npriv->rx_buffers[i].mapping,\r\nRX_PKT_SIZE, PCI_DMA_FROMDEVICE);\r\ndev_kfree_skb(priv->rx_buffers[i].skb);\r\n}\r\nfor (i = 0; i < priv->tx_ring_size; i++) {\r\nif (!priv->tx_buffers[i].skb)\r\ncontinue;\r\npci_unmap_single(priv->pdev,\r\npriv->tx_buffers[i].mapping,\r\npriv->tx_buffers[i].skb->len,\r\nPCI_DMA_TODEVICE);\r\ndev_kfree_skb(priv->tx_buffers[i].skb);\r\n}\r\n}\r\nstatic int adm8211_start(struct ieee80211_hw *dev)\r\n{\r\nstruct adm8211_priv *priv = dev->priv;\r\nint retval;\r\nretval = adm8211_hw_reset(dev);\r\nif (retval) {\r\nwiphy_err(dev->wiphy, "hardware reset failed\n");\r\ngoto fail;\r\n}\r\nretval = adm8211_init_rings(dev);\r\nif (retval) {\r\nwiphy_err(dev->wiphy, "failed to initialize rings\n");\r\ngoto fail;\r\n}\r\nadm8211_hw_init(dev);\r\nadm8211_rf_set_channel(dev, priv->channel);\r\nretval = request_irq(priv->pdev->irq, adm8211_interrupt,\r\nIRQF_SHARED, "adm8211", dev);\r\nif (retval) {\r\nwiphy_err(dev->wiphy, "failed to register IRQ handler\n");\r\ngoto fail;\r\n}\r\nADM8211_CSR_WRITE(IER, ADM8211_IER_NIE | ADM8211_IER_AIE |\r\nADM8211_IER_RCIE | ADM8211_IER_TCIE |\r\nADM8211_IER_TDUIE | ADM8211_IER_GPTIE);\r\npriv->mode = NL80211_IFTYPE_MONITOR;\r\nadm8211_update_mode(dev);\r\nADM8211_CSR_WRITE(RDR, 0);\r\nadm8211_set_interval(dev, 100, 10);\r\nreturn 0;\r\nfail:\r\nreturn retval;\r\n}\r\nstatic void adm8211_stop(struct ieee80211_hw *dev)\r\n{\r\nstruct adm8211_priv *priv = dev->priv;\r\npriv->mode = NL80211_IFTYPE_UNSPECIFIED;\r\npriv->nar = 0;\r\nADM8211_CSR_WRITE(NAR, 0);\r\nADM8211_CSR_WRITE(IER, 0);\r\nADM8211_CSR_READ(NAR);\r\nfree_irq(priv->pdev->irq, dev);\r\nadm8211_free_rings(dev);\r\n}\r\nstatic void adm8211_calc_durations(int *dur, int *plcp, size_t payload_len, int len,\r\nint plcp_signal, int short_preamble)\r\n{\r\n#define IEEE80211_DUR_DS_LONG_PREAMBLE 144\r\n#define IEEE80211_DUR_DS_SHORT_PREAMBLE 72\r\n#define IEEE80211_DUR_DS_FAST_PLCPHDR 24\r\n#define IEEE80211_DUR_DS_SLOW_PLCPHDR 48\r\n#define IEEE80211_DUR_DS_SLOW_ACK 112\r\n#define IEEE80211_DUR_DS_FAST_ACK 56\r\n#define IEEE80211_DUR_DS_SLOW_CTS 112\r\n#define IEEE80211_DUR_DS_FAST_CTS 56\r\n#define IEEE80211_DUR_DS_SLOT 20\r\n#define IEEE80211_DUR_DS_SIFS 10\r\nint remainder;\r\n*dur = (80 * (24 + payload_len) + plcp_signal - 1)\r\n/ plcp_signal;\r\nif (plcp_signal <= PLCP_SIGNAL_2M)\r\n*dur += 3 * (IEEE80211_DUR_DS_SIFS +\r\nIEEE80211_DUR_DS_SHORT_PREAMBLE +\r\nIEEE80211_DUR_DS_FAST_PLCPHDR) +\r\nIEEE80211_DUR_DS_SLOW_CTS + IEEE80211_DUR_DS_SLOW_ACK;\r\nelse\r\n*dur += 3 * (IEEE80211_DUR_DS_SIFS +\r\nIEEE80211_DUR_DS_SHORT_PREAMBLE +\r\nIEEE80211_DUR_DS_FAST_PLCPHDR) +\r\nIEEE80211_DUR_DS_FAST_CTS + IEEE80211_DUR_DS_FAST_ACK;\r\nif (!short_preamble)\r\n*dur += 3 * (IEEE80211_DUR_DS_LONG_PREAMBLE -\r\nIEEE80211_DUR_DS_SHORT_PREAMBLE) +\r\n3 * (IEEE80211_DUR_DS_SLOW_PLCPHDR -\r\nIEEE80211_DUR_DS_FAST_PLCPHDR);\r\n*plcp = (80 * len) / plcp_signal;\r\nremainder = (80 * len) % plcp_signal;\r\nif (plcp_signal == PLCP_SIGNAL_11M &&\r\nremainder <= 30 && remainder > 0)\r\n*plcp = (*plcp | 0x8000) + 1;\r\nelse if (remainder)\r\n(*plcp)++;\r\n}\r\nstatic void adm8211_tx_raw(struct ieee80211_hw *dev, struct sk_buff *skb,\r\nu16 plcp_signal,\r\nsize_t hdrlen)\r\n{\r\nstruct adm8211_priv *priv = dev->priv;\r\nunsigned long flags;\r\ndma_addr_t mapping;\r\nunsigned int entry;\r\nu32 flag;\r\nmapping = pci_map_single(priv->pdev, skb->data, skb->len,\r\nPCI_DMA_TODEVICE);\r\nspin_lock_irqsave(&priv->lock, flags);\r\nif (priv->cur_tx - priv->dirty_tx == priv->tx_ring_size / 2)\r\nflag = TDES1_CONTROL_IC | TDES1_CONTROL_LS | TDES1_CONTROL_FS;\r\nelse\r\nflag = TDES1_CONTROL_LS | TDES1_CONTROL_FS;\r\nif (priv->cur_tx - priv->dirty_tx == priv->tx_ring_size - 2)\r\nieee80211_stop_queue(dev, 0);\r\nentry = priv->cur_tx % priv->tx_ring_size;\r\npriv->tx_buffers[entry].skb = skb;\r\npriv->tx_buffers[entry].mapping = mapping;\r\npriv->tx_buffers[entry].hdrlen = hdrlen;\r\npriv->tx_ring[entry].buffer1 = cpu_to_le32(mapping);\r\nif (entry == priv->tx_ring_size - 1)\r\nflag |= TDES1_CONTROL_TER;\r\npriv->tx_ring[entry].length = cpu_to_le32(flag | skb->len);\r\nflag = TDES0_CONTROL_OWN | (plcp_signal << 20) | 8 ;\r\npriv->tx_ring[entry].status = cpu_to_le32(flag);\r\npriv->cur_tx++;\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\nADM8211_CSR_WRITE(TDR, 0);\r\n}\r\nstatic void adm8211_tx(struct ieee80211_hw *dev,\r\nstruct ieee80211_tx_control *control,\r\nstruct sk_buff *skb)\r\n{\r\nstruct adm8211_tx_hdr *txhdr;\r\nsize_t payload_len, hdrlen;\r\nint plcp, dur, len, plcp_signal, short_preamble;\r\nstruct ieee80211_hdr *hdr;\r\nstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\r\nstruct ieee80211_rate *txrate = ieee80211_get_tx_rate(dev, info);\r\nu8 rc_flags;\r\nrc_flags = info->control.rates[0].flags;\r\nshort_preamble = !!(rc_flags & IEEE80211_TX_RC_USE_SHORT_PREAMBLE);\r\nplcp_signal = txrate->bitrate;\r\nhdr = (struct ieee80211_hdr *)skb->data;\r\nhdrlen = ieee80211_hdrlen(hdr->frame_control);\r\nmemcpy(skb->cb, skb->data, hdrlen);\r\nhdr = (struct ieee80211_hdr *)skb->cb;\r\nskb_pull(skb, hdrlen);\r\npayload_len = skb->len;\r\ntxhdr = (struct adm8211_tx_hdr *) skb_push(skb, sizeof(*txhdr));\r\nmemset(txhdr, 0, sizeof(*txhdr));\r\nmemcpy(txhdr->da, ieee80211_get_DA(hdr), ETH_ALEN);\r\ntxhdr->signal = plcp_signal;\r\ntxhdr->frame_body_size = cpu_to_le16(payload_len);\r\ntxhdr->frame_control = hdr->frame_control;\r\nlen = hdrlen + payload_len + FCS_LEN;\r\ntxhdr->frag = cpu_to_le16(0x0FFF);\r\nadm8211_calc_durations(&dur, &plcp, payload_len,\r\nlen, plcp_signal, short_preamble);\r\ntxhdr->plcp_frag_head_len = cpu_to_le16(plcp);\r\ntxhdr->plcp_frag_tail_len = cpu_to_le16(plcp);\r\ntxhdr->dur_frag_head = cpu_to_le16(dur);\r\ntxhdr->dur_frag_tail = cpu_to_le16(dur);\r\ntxhdr->header_control = cpu_to_le16(ADM8211_TXHDRCTL_ENABLE_EXTEND_HEADER);\r\nif (short_preamble)\r\ntxhdr->header_control |= cpu_to_le16(ADM8211_TXHDRCTL_SHORT_PREAMBLE);\r\nif (rc_flags & IEEE80211_TX_RC_USE_RTS_CTS)\r\ntxhdr->header_control |= cpu_to_le16(ADM8211_TXHDRCTL_ENABLE_RTS);\r\ntxhdr->retry_limit = info->control.rates[0].count;\r\nadm8211_tx_raw(dev, skb, plcp_signal, hdrlen);\r\n}\r\nstatic int adm8211_alloc_rings(struct ieee80211_hw *dev)\r\n{\r\nstruct adm8211_priv *priv = dev->priv;\r\nunsigned int ring_size;\r\npriv->rx_buffers = kmalloc(sizeof(*priv->rx_buffers) * priv->rx_ring_size +\r\nsizeof(*priv->tx_buffers) * priv->tx_ring_size, GFP_KERNEL);\r\nif (!priv->rx_buffers)\r\nreturn -ENOMEM;\r\npriv->tx_buffers = (void *)priv->rx_buffers +\r\nsizeof(*priv->rx_buffers) * priv->rx_ring_size;\r\nring_size = sizeof(struct adm8211_desc) * priv->rx_ring_size +\r\nsizeof(struct adm8211_desc) * priv->tx_ring_size;\r\npriv->rx_ring = pci_alloc_consistent(priv->pdev, ring_size,\r\n&priv->rx_ring_dma);\r\nif (!priv->rx_ring) {\r\nkfree(priv->rx_buffers);\r\npriv->rx_buffers = NULL;\r\npriv->tx_buffers = NULL;\r\nreturn -ENOMEM;\r\n}\r\npriv->tx_ring = priv->rx_ring + priv->rx_ring_size;\r\npriv->tx_ring_dma = priv->rx_ring_dma +\r\nsizeof(struct adm8211_desc) * priv->rx_ring_size;\r\nreturn 0;\r\n}\r\nstatic int adm8211_probe(struct pci_dev *pdev,\r\nconst struct pci_device_id *id)\r\n{\r\nstruct ieee80211_hw *dev;\r\nstruct adm8211_priv *priv;\r\nunsigned long mem_addr, mem_len;\r\nunsigned int io_addr, io_len;\r\nint err;\r\nu32 reg;\r\nu8 perm_addr[ETH_ALEN];\r\nerr = pci_enable_device(pdev);\r\nif (err) {\r\nprintk(KERN_ERR "%s (adm8211): Cannot enable new PCI device\n",\r\npci_name(pdev));\r\nreturn err;\r\n}\r\nio_addr = pci_resource_start(pdev, 0);\r\nio_len = pci_resource_len(pdev, 0);\r\nmem_addr = pci_resource_start(pdev, 1);\r\nmem_len = pci_resource_len(pdev, 1);\r\nif (io_len < 256 || mem_len < 1024) {\r\nprintk(KERN_ERR "%s (adm8211): Too short PCI resources\n",\r\npci_name(pdev));\r\ngoto err_disable_pdev;\r\n}\r\npci_read_config_dword(pdev, 0x80 , &reg);\r\nif (reg != ADM8211_SIG1 && reg != ADM8211_SIG2) {\r\nprintk(KERN_ERR "%s (adm8211): Invalid signature (0x%x)\n",\r\npci_name(pdev), reg);\r\ngoto err_disable_pdev;\r\n}\r\nerr = pci_request_regions(pdev, "adm8211");\r\nif (err) {\r\nprintk(KERN_ERR "%s (adm8211): Cannot obtain PCI resources\n",\r\npci_name(pdev));\r\nreturn err;\r\n}\r\nif (pci_set_dma_mask(pdev, DMA_BIT_MASK(32)) ||\r\npci_set_consistent_dma_mask(pdev, DMA_BIT_MASK(32))) {\r\nprintk(KERN_ERR "%s (adm8211): No suitable DMA available\n",\r\npci_name(pdev));\r\ngoto err_free_reg;\r\n}\r\npci_set_master(pdev);\r\ndev = ieee80211_alloc_hw(sizeof(*priv), &adm8211_ops);\r\nif (!dev) {\r\nprintk(KERN_ERR "%s (adm8211): ieee80211 alloc failed\n",\r\npci_name(pdev));\r\nerr = -ENOMEM;\r\ngoto err_free_reg;\r\n}\r\npriv = dev->priv;\r\npriv->pdev = pdev;\r\nspin_lock_init(&priv->lock);\r\nSET_IEEE80211_DEV(dev, &pdev->dev);\r\npci_set_drvdata(pdev, dev);\r\npriv->map = pci_iomap(pdev, 1, mem_len);\r\nif (!priv->map)\r\npriv->map = pci_iomap(pdev, 0, io_len);\r\nif (!priv->map) {\r\nprintk(KERN_ERR "%s (adm8211): Cannot map device memory\n",\r\npci_name(pdev));\r\ngoto err_free_dev;\r\n}\r\npriv->rx_ring_size = rx_ring_size;\r\npriv->tx_ring_size = tx_ring_size;\r\nif (adm8211_alloc_rings(dev)) {\r\nprintk(KERN_ERR "%s (adm8211): Cannot allocate TX/RX ring\n",\r\npci_name(pdev));\r\ngoto err_iounmap;\r\n}\r\n*(__le32 *)perm_addr = cpu_to_le32(ADM8211_CSR_READ(PAR0));\r\n*(__le16 *)&perm_addr[4] =\r\ncpu_to_le16(ADM8211_CSR_READ(PAR1) & 0xFFFF);\r\nif (!is_valid_ether_addr(perm_addr)) {\r\nprintk(KERN_WARNING "%s (adm8211): Invalid hwaddr in EEPROM!\n",\r\npci_name(pdev));\r\neth_random_addr(perm_addr);\r\n}\r\nSET_IEEE80211_PERM_ADDR(dev, perm_addr);\r\ndev->extra_tx_headroom = sizeof(struct adm8211_tx_hdr);\r\ndev->flags = IEEE80211_HW_SIGNAL_UNSPEC;\r\ndev->wiphy->interface_modes = BIT(NL80211_IFTYPE_STATION);\r\ndev->channel_change_time = 1000;\r\ndev->max_signal = 100;\r\ndev->queues = 1;\r\npriv->retry_limit = 3;\r\npriv->ant_power = 0x40;\r\npriv->tx_power = 0x40;\r\npriv->lpf_cutoff = 0xFF;\r\npriv->lnags_threshold = 0xFF;\r\npriv->mode = NL80211_IFTYPE_UNSPECIFIED;\r\nif (pdev->revision >= ADM8211_REV_BA) {\r\nADM8211_CSR_WRITE(FRCTL, 0);\r\nADM8211_CSR_READ(FRCTL);\r\nADM8211_CSR_WRITE(FRCTL, 1);\r\nADM8211_CSR_READ(FRCTL);\r\nmsleep(100);\r\n}\r\nerr = adm8211_read_eeprom(dev);\r\nif (err) {\r\nprintk(KERN_ERR "%s (adm8211): Can't alloc eeprom buffer\n",\r\npci_name(pdev));\r\ngoto err_free_desc;\r\n}\r\npriv->channel = 1;\r\ndev->wiphy->bands[IEEE80211_BAND_2GHZ] = &priv->band;\r\nerr = ieee80211_register_hw(dev);\r\nif (err) {\r\nprintk(KERN_ERR "%s (adm8211): Cannot register device\n",\r\npci_name(pdev));\r\ngoto err_free_eeprom;\r\n}\r\nwiphy_info(dev->wiphy, "hwaddr %pM, Rev 0x%02x\n",\r\ndev->wiphy->perm_addr, pdev->revision);\r\nreturn 0;\r\nerr_free_eeprom:\r\nkfree(priv->eeprom);\r\nerr_free_desc:\r\npci_free_consistent(pdev,\r\nsizeof(struct adm8211_desc) * priv->rx_ring_size +\r\nsizeof(struct adm8211_desc) * priv->tx_ring_size,\r\npriv->rx_ring, priv->rx_ring_dma);\r\nkfree(priv->rx_buffers);\r\nerr_iounmap:\r\npci_iounmap(pdev, priv->map);\r\nerr_free_dev:\r\npci_set_drvdata(pdev, NULL);\r\nieee80211_free_hw(dev);\r\nerr_free_reg:\r\npci_release_regions(pdev);\r\nerr_disable_pdev:\r\npci_disable_device(pdev);\r\nreturn err;\r\n}\r\nstatic void adm8211_remove(struct pci_dev *pdev)\r\n{\r\nstruct ieee80211_hw *dev = pci_get_drvdata(pdev);\r\nstruct adm8211_priv *priv;\r\nif (!dev)\r\nreturn;\r\nieee80211_unregister_hw(dev);\r\npriv = dev->priv;\r\npci_free_consistent(pdev,\r\nsizeof(struct adm8211_desc) * priv->rx_ring_size +\r\nsizeof(struct adm8211_desc) * priv->tx_ring_size,\r\npriv->rx_ring, priv->rx_ring_dma);\r\nkfree(priv->rx_buffers);\r\nkfree(priv->eeprom);\r\npci_iounmap(pdev, priv->map);\r\npci_release_regions(pdev);\r\npci_disable_device(pdev);\r\nieee80211_free_hw(dev);\r\n}\r\nstatic int adm8211_suspend(struct pci_dev *pdev, pm_message_t state)\r\n{\r\npci_save_state(pdev);\r\npci_set_power_state(pdev, pci_choose_state(pdev, state));\r\nreturn 0;\r\n}\r\nstatic int adm8211_resume(struct pci_dev *pdev)\r\n{\r\npci_set_power_state(pdev, PCI_D0);\r\npci_restore_state(pdev);\r\nreturn 0;\r\n}
