static void\r\nsmb2_hdr_assemble(struct smb2_hdr *hdr, __le16 smb2_cmd ,\r\nconst struct cifs_tcon *tcon)\r\n{\r\nstruct smb2_pdu *pdu = (struct smb2_pdu *)hdr;\r\nchar *temp = (char *)hdr;\r\n__u16 parmsize = smb2_req_struct_sizes[le16_to_cpu(smb2_cmd)];\r\nmemset(temp, 0, 256);\r\nhdr->smb2_buf_length = cpu_to_be32(parmsize + sizeof(struct smb2_hdr)\r\n- 4 );\r\nhdr->ProtocolId[0] = 0xFE;\r\nhdr->ProtocolId[1] = 'S';\r\nhdr->ProtocolId[2] = 'M';\r\nhdr->ProtocolId[3] = 'B';\r\nhdr->StructureSize = cpu_to_le16(64);\r\nhdr->Command = smb2_cmd;\r\nhdr->CreditRequest = cpu_to_le16(2);\r\nhdr->ProcessId = cpu_to_le32((__u16)current->tgid);\r\nif (!tcon)\r\ngoto out;\r\nhdr->TreeId = tcon->tid;\r\nif (tcon->ses)\r\nhdr->SessionId = tcon->ses->Suid;\r\nif (tcon->share_flags & SHI1005_FLAGS_DFS)\r\nhdr->Flags |= SMB2_FLAGS_DFS_OPERATIONS;\r\nif (tcon->ses && tcon->ses->server &&\r\n(tcon->ses->server->sec_mode & SECMODE_SIGN_REQUIRED))\r\nhdr->Flags |= SMB2_FLAGS_SIGNED;\r\nout:\r\npdu->StructureSize2 = cpu_to_le16(parmsize);\r\nreturn;\r\n}\r\nstatic int\r\nsmb2_reconnect(__le16 smb2_command, struct cifs_tcon *tcon)\r\n{\r\nint rc = 0;\r\nstruct nls_table *nls_codepage;\r\nstruct cifs_ses *ses;\r\nstruct TCP_Server_Info *server;\r\nif (tcon == NULL)\r\nreturn rc;\r\nif (smb2_command == SMB2_TREE_CONNECT)\r\nreturn rc;\r\nif (tcon->tidStatus == CifsExiting) {\r\nif ((smb2_command != SMB2_WRITE) &&\r\n(smb2_command != SMB2_CREATE) &&\r\n(smb2_command != SMB2_TREE_DISCONNECT)) {\r\ncFYI(1, "can not send cmd %d while umounting",\r\nsmb2_command);\r\nreturn -ENODEV;\r\n}\r\n}\r\nif ((!tcon->ses) || (tcon->ses->status == CifsExiting) ||\r\n(!tcon->ses->server))\r\nreturn -EIO;\r\nses = tcon->ses;\r\nserver = ses->server;\r\nwhile (server->tcpStatus == CifsNeedReconnect) {\r\nswitch (smb2_command) {\r\ncase SMB2_TREE_DISCONNECT:\r\ncase SMB2_CANCEL:\r\ncase SMB2_CLOSE:\r\ncase SMB2_OPLOCK_BREAK:\r\nreturn -EAGAIN;\r\n}\r\nwait_event_interruptible_timeout(server->response_q,\r\n(server->tcpStatus != CifsNeedReconnect), 10 * HZ);\r\nif (server->tcpStatus != CifsNeedReconnect)\r\nbreak;\r\nif (!tcon->retry) {\r\ncFYI(1, "gave up waiting on reconnect in smb_init");\r\nreturn -EHOSTDOWN;\r\n}\r\n}\r\nif (!tcon->ses->need_reconnect && !tcon->need_reconnect)\r\nreturn rc;\r\nnls_codepage = load_nls_default();\r\nmutex_lock(&tcon->ses->session_mutex);\r\nrc = cifs_negotiate_protocol(0, tcon->ses);\r\nif (!rc && tcon->ses->need_reconnect)\r\nrc = cifs_setup_session(0, tcon->ses, nls_codepage);\r\nif (rc || !tcon->need_reconnect) {\r\nmutex_unlock(&tcon->ses->session_mutex);\r\ngoto out;\r\n}\r\ncifs_mark_open_files_invalid(tcon);\r\nrc = SMB2_tcon(0, tcon->ses, tcon->treeName, tcon, nls_codepage);\r\nmutex_unlock(&tcon->ses->session_mutex);\r\ncFYI(1, "reconnect tcon rc = %d", rc);\r\nif (rc)\r\ngoto out;\r\natomic_inc(&tconInfoReconnectCount);\r\nout:\r\nswitch (smb2_command) {\r\ncase SMB2_FLUSH:\r\ncase SMB2_READ:\r\ncase SMB2_WRITE:\r\ncase SMB2_LOCK:\r\ncase SMB2_IOCTL:\r\ncase SMB2_QUERY_DIRECTORY:\r\ncase SMB2_CHANGE_NOTIFY:\r\ncase SMB2_QUERY_INFO:\r\ncase SMB2_SET_INFO:\r\nreturn -EAGAIN;\r\n}\r\nunload_nls(nls_codepage);\r\nreturn rc;\r\n}\r\nstatic int\r\nsmall_smb2_init(__le16 smb2_command, struct cifs_tcon *tcon,\r\nvoid **request_buf)\r\n{\r\nint rc = 0;\r\nrc = smb2_reconnect(smb2_command, tcon);\r\nif (rc)\r\nreturn rc;\r\n*request_buf = cifs_small_buf_get();\r\nif (*request_buf == NULL) {\r\nreturn -ENOMEM;\r\n}\r\nsmb2_hdr_assemble((struct smb2_hdr *) *request_buf, smb2_command, tcon);\r\nif (tcon != NULL) {\r\n#ifdef CONFIG_CIFS_STATS2\r\nuint16_t com_code = le16_to_cpu(smb2_command);\r\ncifs_stats_inc(&tcon->stats.smb2_stats.smb2_com_sent[com_code]);\r\n#endif\r\ncifs_stats_inc(&tcon->num_smbs_sent);\r\n}\r\nreturn rc;\r\n}\r\nstatic void\r\nfree_rsp_buf(int resp_buftype, void *rsp)\r\n{\r\nif (resp_buftype == CIFS_SMALL_BUFFER)\r\ncifs_small_buf_release(rsp);\r\nelse if (resp_buftype == CIFS_LARGE_BUFFER)\r\ncifs_buf_release(rsp);\r\n}\r\nint\r\nSMB2_negotiate(const unsigned int xid, struct cifs_ses *ses)\r\n{\r\nstruct smb2_negotiate_req *req;\r\nstruct smb2_negotiate_rsp *rsp;\r\nstruct kvec iov[1];\r\nint rc = 0;\r\nint resp_buftype;\r\nstruct TCP_Server_Info *server;\r\nunsigned int sec_flags;\r\nu16 temp = 0;\r\nint blob_offset, blob_length;\r\nchar *security_blob;\r\nint flags = CIFS_NEG_OP;\r\ncFYI(1, "Negotiate protocol");\r\nif (ses->server)\r\nserver = ses->server;\r\nelse {\r\nrc = -EIO;\r\nreturn rc;\r\n}\r\nrc = small_smb2_init(SMB2_NEGOTIATE, NULL, (void **) &req);\r\nif (rc)\r\nreturn rc;\r\nif (ses->overrideSecFlg & (~(CIFSSEC_MUST_SIGN | CIFSSEC_MUST_SEAL)))\r\nsec_flags = ses->overrideSecFlg;\r\nelse\r\nsec_flags = global_secflags | ses->overrideSecFlg;\r\ncFYI(1, "sec_flags 0x%x", sec_flags);\r\nreq->hdr.SessionId = 0;\r\nreq->Dialects[0] = cpu_to_le16(ses->server->vals->protocol_id);\r\nreq->DialectCount = cpu_to_le16(1);\r\ninc_rfc1001_len(req, 2);\r\nif ((sec_flags & CIFSSEC_MUST_SIGN) == CIFSSEC_MUST_SIGN)\r\ntemp = SMB2_NEGOTIATE_SIGNING_REQUIRED;\r\nelse if (sec_flags & CIFSSEC_MAY_SIGN)\r\ntemp = SMB2_NEGOTIATE_SIGNING_ENABLED;\r\nreq->SecurityMode = cpu_to_le16(temp);\r\nreq->Capabilities = cpu_to_le32(ses->server->vals->req_capabilities);\r\nmemcpy(req->ClientGUID, cifs_client_guid, SMB2_CLIENT_GUID_SIZE);\r\niov[0].iov_base = (char *)req;\r\niov[0].iov_len = get_rfc1002_length(req) + 4;\r\nrc = SendReceive2(xid, ses, iov, 1, &resp_buftype, flags);\r\nrsp = (struct smb2_negotiate_rsp *)iov[0].iov_base;\r\nif (rc != 0)\r\ngoto neg_exit;\r\ncFYI(1, "mode 0x%x", rsp->SecurityMode);\r\nif (rsp->DialectRevision == cpu_to_le16(SMB20_PROT_ID))\r\ncFYI(1, "negotiated smb2.0 dialect");\r\nelse if (rsp->DialectRevision == cpu_to_le16(SMB21_PROT_ID))\r\ncFYI(1, "negotiated smb2.1 dialect");\r\nelse if (rsp->DialectRevision == cpu_to_le16(SMB30_PROT_ID))\r\ncFYI(1, "negotiated smb3.0 dialect");\r\nelse {\r\ncERROR(1, "Illegal dialect returned by server %d",\r\nle16_to_cpu(rsp->DialectRevision));\r\nrc = -EIO;\r\ngoto neg_exit;\r\n}\r\nserver->dialect = le16_to_cpu(rsp->DialectRevision);\r\nserver->maxBuf = le32_to_cpu(rsp->MaxTransactSize);\r\nserver->max_read = le32_to_cpu(rsp->MaxReadSize);\r\nserver->max_write = le32_to_cpu(rsp->MaxWriteSize);\r\nserver->sec_mode = le16_to_cpu(rsp->SecurityMode);\r\nserver->capabilities = le32_to_cpu(rsp->Capabilities);\r\nserver->capabilities |= SMB2_NT_FIND | SMB2_LARGE_FILES;\r\nsecurity_blob = smb2_get_data_area_len(&blob_offset, &blob_length,\r\n&rsp->hdr);\r\nif (blob_length == 0) {\r\ncERROR(1, "missing security blob on negprot");\r\nrc = -EIO;\r\ngoto neg_exit;\r\n}\r\ncFYI(1, "sec_flags 0x%x", sec_flags);\r\nif ((sec_flags & CIFSSEC_MUST_SIGN) == CIFSSEC_MUST_SIGN) {\r\ncFYI(1, "Signing required");\r\nif (!(server->sec_mode & (SMB2_NEGOTIATE_SIGNING_REQUIRED |\r\nSMB2_NEGOTIATE_SIGNING_ENABLED))) {\r\ncERROR(1, "signing required but server lacks support");\r\nrc = -EOPNOTSUPP;\r\ngoto neg_exit;\r\n}\r\nserver->sec_mode |= SECMODE_SIGN_REQUIRED;\r\n} else if (sec_flags & CIFSSEC_MAY_SIGN) {\r\ncFYI(1, "Signing optional");\r\nif (server->sec_mode & SMB2_NEGOTIATE_SIGNING_REQUIRED) {\r\ncFYI(1, "Server requires signing");\r\nserver->sec_mode |= SECMODE_SIGN_REQUIRED;\r\n} else {\r\nserver->sec_mode &=\r\n~(SECMODE_SIGN_ENABLED | SECMODE_SIGN_REQUIRED);\r\n}\r\n} else {\r\ncFYI(1, "Signing disabled");\r\nif (server->sec_mode & SMB2_NEGOTIATE_SIGNING_REQUIRED) {\r\ncERROR(1, "Server requires packet signing to be enabled"\r\n" in /proc/fs/cifs/SecurityFlags.");\r\nrc = -EOPNOTSUPP;\r\ngoto neg_exit;\r\n}\r\nserver->sec_mode &=\r\n~(SECMODE_SIGN_ENABLED | SECMODE_SIGN_REQUIRED);\r\n}\r\n#ifdef CONFIG_SMB2_ASN1\r\nrc = decode_neg_token_init(security_blob, blob_length,\r\n&server->sec_type);\r\nif (rc == 1)\r\nrc = 0;\r\nelse if (rc == 0) {\r\nrc = -EIO;\r\ngoto neg_exit;\r\n}\r\n#endif\r\nneg_exit:\r\nfree_rsp_buf(resp_buftype, rsp);\r\nreturn rc;\r\n}\r\nint\r\nSMB2_sess_setup(const unsigned int xid, struct cifs_ses *ses,\r\nconst struct nls_table *nls_cp)\r\n{\r\nstruct smb2_sess_setup_req *req;\r\nstruct smb2_sess_setup_rsp *rsp = NULL;\r\nstruct kvec iov[2];\r\nint rc = 0;\r\nint resp_buftype;\r\n__le32 phase = NtLmNegotiate;\r\nstruct TCP_Server_Info *server;\r\nunsigned int sec_flags;\r\nu8 temp = 0;\r\nu16 blob_length = 0;\r\nchar *security_blob;\r\nchar *ntlmssp_blob = NULL;\r\nbool use_spnego = false;\r\ncFYI(1, "Session Setup");\r\nif (ses->server)\r\nserver = ses->server;\r\nelse {\r\nrc = -EIO;\r\nreturn rc;\r\n}\r\nses->ntlmssp = kmalloc(sizeof(struct ntlmssp_auth), GFP_KERNEL);\r\nif (!ses->ntlmssp)\r\nreturn -ENOMEM;\r\nses->server->secType = RawNTLMSSP;\r\nssetup_ntlmssp_authenticate:\r\nif (phase == NtLmChallenge)\r\nphase = NtLmAuthenticate;\r\nrc = small_smb2_init(SMB2_SESSION_SETUP, NULL, (void **) &req);\r\nif (rc)\r\nreturn rc;\r\nif (ses->overrideSecFlg & (~(CIFSSEC_MUST_SIGN | CIFSSEC_MUST_SEAL)))\r\nsec_flags = ses->overrideSecFlg;\r\nelse\r\nsec_flags = global_secflags | ses->overrideSecFlg;\r\ncFYI(1, "sec_flags 0x%x", sec_flags);\r\nreq->hdr.SessionId = 0;\r\nreq->VcNumber = 0;\r\nreq->hdr.CreditRequest = cpu_to_le16(3);\r\nif ((sec_flags & CIFSSEC_MUST_SIGN) == CIFSSEC_MUST_SIGN)\r\ntemp = SMB2_NEGOTIATE_SIGNING_REQUIRED;\r\nelse if (ses->server->sec_mode & SMB2_NEGOTIATE_SIGNING_REQUIRED)\r\ntemp = SMB2_NEGOTIATE_SIGNING_REQUIRED;\r\nelse if (sec_flags & CIFSSEC_MAY_SIGN)\r\ntemp = SMB2_NEGOTIATE_SIGNING_ENABLED;\r\nreq->SecurityMode = temp;\r\nreq->Capabilities = 0;\r\nreq->Channel = 0;\r\niov[0].iov_base = (char *)req;\r\niov[0].iov_len = get_rfc1002_length(req) + 4 - 1;\r\nif (phase == NtLmNegotiate) {\r\nntlmssp_blob = kmalloc(sizeof(struct _NEGOTIATE_MESSAGE),\r\nGFP_KERNEL);\r\nif (ntlmssp_blob == NULL) {\r\nrc = -ENOMEM;\r\ngoto ssetup_exit;\r\n}\r\nbuild_ntlmssp_negotiate_blob(ntlmssp_blob, ses);\r\nif (use_spnego) {\r\ncERROR(1, "spnego not supported for SMB2 yet");\r\nrc = -EOPNOTSUPP;\r\nkfree(ntlmssp_blob);\r\ngoto ssetup_exit;\r\n} else {\r\nblob_length = sizeof(struct _NEGOTIATE_MESSAGE);\r\nsecurity_blob = ntlmssp_blob;\r\n}\r\n} else if (phase == NtLmAuthenticate) {\r\nreq->hdr.SessionId = ses->Suid;\r\nntlmssp_blob = kzalloc(sizeof(struct _NEGOTIATE_MESSAGE) + 500,\r\nGFP_KERNEL);\r\nif (ntlmssp_blob == NULL) {\r\ncERROR(1, "failed to malloc ntlmssp blob");\r\nrc = -ENOMEM;\r\ngoto ssetup_exit;\r\n}\r\nrc = build_ntlmssp_auth_blob(ntlmssp_blob, &blob_length, ses,\r\nnls_cp);\r\nif (rc) {\r\ncFYI(1, "build_ntlmssp_auth_blob failed %d", rc);\r\ngoto ssetup_exit;\r\n}\r\nif (use_spnego) {\r\ncERROR(1, "spnego not supported for SMB2 yet");\r\nrc = -EOPNOTSUPP;\r\nkfree(ntlmssp_blob);\r\ngoto ssetup_exit;\r\n} else {\r\nsecurity_blob = ntlmssp_blob;\r\n}\r\n} else {\r\ncERROR(1, "illegal ntlmssp phase");\r\nrc = -EIO;\r\ngoto ssetup_exit;\r\n}\r\nreq->SecurityBufferOffset =\r\ncpu_to_le16(sizeof(struct smb2_sess_setup_req) -\r\n1 - 4 );\r\nreq->SecurityBufferLength = cpu_to_le16(blob_length);\r\niov[1].iov_base = security_blob;\r\niov[1].iov_len = blob_length;\r\ninc_rfc1001_len(req, blob_length - 1 );\r\nrc = SendReceive2(xid, ses, iov, 2, &resp_buftype,\r\nCIFS_LOG_ERROR | CIFS_NEG_OP);\r\nkfree(security_blob);\r\nrsp = (struct smb2_sess_setup_rsp *)iov[0].iov_base;\r\nif (resp_buftype != CIFS_NO_BUFFER &&\r\nrsp->hdr.Status == STATUS_MORE_PROCESSING_REQUIRED) {\r\nif (phase != NtLmNegotiate) {\r\ncERROR(1, "Unexpected more processing error");\r\ngoto ssetup_exit;\r\n}\r\nif (offsetof(struct smb2_sess_setup_rsp, Buffer) - 4 !=\r\nle16_to_cpu(rsp->SecurityBufferOffset)) {\r\ncERROR(1, "Invalid security buffer offset %d",\r\nle16_to_cpu(rsp->SecurityBufferOffset));\r\nrc = -EIO;\r\ngoto ssetup_exit;\r\n}\r\nphase = NtLmChallenge;\r\nrc = 0;\r\nses->Suid = rsp->hdr.SessionId;\r\nrc = decode_ntlmssp_challenge(rsp->Buffer,\r\nle16_to_cpu(rsp->SecurityBufferLength), ses);\r\n}\r\nif (rc != 0)\r\ngoto ssetup_exit;\r\nses->session_flags = le16_to_cpu(rsp->SessionFlags);\r\nssetup_exit:\r\nfree_rsp_buf(resp_buftype, rsp);\r\nif ((phase == NtLmChallenge) && (rc == 0))\r\ngoto ssetup_ntlmssp_authenticate;\r\nreturn rc;\r\n}\r\nint\r\nSMB2_logoff(const unsigned int xid, struct cifs_ses *ses)\r\n{\r\nstruct smb2_logoff_req *req;\r\nint rc = 0;\r\nstruct TCP_Server_Info *server;\r\ncFYI(1, "disconnect session %p", ses);\r\nif (ses && (ses->server))\r\nserver = ses->server;\r\nelse\r\nreturn -EIO;\r\nrc = small_smb2_init(SMB2_LOGOFF, NULL, (void **) &req);\r\nif (rc)\r\nreturn rc;\r\nreq->hdr.SessionId = ses->Suid;\r\nif (server->sec_mode & SECMODE_SIGN_REQUIRED)\r\nreq->hdr.Flags |= SMB2_FLAGS_SIGNED;\r\nrc = SendReceiveNoRsp(xid, ses, (char *) &req->hdr, 0);\r\nreturn rc;\r\n}\r\nstatic inline void cifs_stats_fail_inc(struct cifs_tcon *tcon, uint16_t code)\r\n{\r\ncifs_stats_inc(&tcon->stats.smb2_stats.smb2_com_failed[code]);\r\n}\r\nint\r\nSMB2_tcon(const unsigned int xid, struct cifs_ses *ses, const char *tree,\r\nstruct cifs_tcon *tcon, const struct nls_table *cp)\r\n{\r\nstruct smb2_tree_connect_req *req;\r\nstruct smb2_tree_connect_rsp *rsp = NULL;\r\nstruct kvec iov[2];\r\nint rc = 0;\r\nint resp_buftype;\r\nint unc_path_len;\r\nstruct TCP_Server_Info *server;\r\n__le16 *unc_path = NULL;\r\ncFYI(1, "TCON");\r\nif ((ses->server) && tree)\r\nserver = ses->server;\r\nelse\r\nreturn -EIO;\r\nif (tcon && tcon->bad_network_name)\r\nreturn -ENOENT;\r\nunc_path = kmalloc(MAX_SHARENAME_LENGTH * 2, GFP_KERNEL);\r\nif (unc_path == NULL)\r\nreturn -ENOMEM;\r\nunc_path_len = cifs_strtoUTF16(unc_path, tree, strlen(tree), cp) + 1;\r\nunc_path_len *= 2;\r\nif (unc_path_len < 2) {\r\nkfree(unc_path);\r\nreturn -EINVAL;\r\n}\r\nrc = small_smb2_init(SMB2_TREE_CONNECT, tcon, (void **) &req);\r\nif (rc) {\r\nkfree(unc_path);\r\nreturn rc;\r\n}\r\nif (tcon == NULL) {\r\nreq->hdr.SessionId = ses->Suid;\r\n}\r\niov[0].iov_base = (char *)req;\r\niov[0].iov_len = get_rfc1002_length(req) + 4 - 1;\r\nreq->PathOffset = cpu_to_le16(sizeof(struct smb2_tree_connect_req)\r\n- 1 - 4 );\r\nreq->PathLength = cpu_to_le16(unc_path_len - 2);\r\niov[1].iov_base = unc_path;\r\niov[1].iov_len = unc_path_len;\r\ninc_rfc1001_len(req, unc_path_len - 1 );\r\nrc = SendReceive2(xid, ses, iov, 2, &resp_buftype, 0);\r\nrsp = (struct smb2_tree_connect_rsp *)iov[0].iov_base;\r\nif (rc != 0) {\r\nif (tcon) {\r\ncifs_stats_fail_inc(tcon, SMB2_TREE_CONNECT_HE);\r\ntcon->need_reconnect = true;\r\n}\r\ngoto tcon_error_exit;\r\n}\r\nif (tcon == NULL) {\r\nses->ipc_tid = rsp->hdr.TreeId;\r\ngoto tcon_exit;\r\n}\r\nif (rsp->ShareType & SMB2_SHARE_TYPE_DISK)\r\ncFYI(1, "connection to disk share");\r\nelse if (rsp->ShareType & SMB2_SHARE_TYPE_PIPE) {\r\ntcon->ipc = true;\r\ncFYI(1, "connection to pipe share");\r\n} else if (rsp->ShareType & SMB2_SHARE_TYPE_PRINT) {\r\ntcon->print = true;\r\ncFYI(1, "connection to printer");\r\n} else {\r\ncERROR(1, "unknown share type %d", rsp->ShareType);\r\nrc = -EOPNOTSUPP;\r\ngoto tcon_error_exit;\r\n}\r\ntcon->share_flags = le32_to_cpu(rsp->ShareFlags);\r\ntcon->maximal_access = le32_to_cpu(rsp->MaximalAccess);\r\ntcon->tidStatus = CifsGood;\r\ntcon->need_reconnect = false;\r\ntcon->tid = rsp->hdr.TreeId;\r\nstrncpy(tcon->treeName, tree, MAX_TREE_SIZE);\r\nif ((rsp->Capabilities & SMB2_SHARE_CAP_DFS) &&\r\n((tcon->share_flags & SHI1005_FLAGS_DFS) == 0))\r\ncERROR(1, "DFS capability contradicts DFS flag");\r\ntcon_exit:\r\nfree_rsp_buf(resp_buftype, rsp);\r\nkfree(unc_path);\r\nreturn rc;\r\ntcon_error_exit:\r\nif (rsp->hdr.Status == STATUS_BAD_NETWORK_NAME) {\r\ncERROR(1, "BAD_NETWORK_NAME: %s", tree);\r\ntcon->bad_network_name = true;\r\n}\r\ngoto tcon_exit;\r\n}\r\nint\r\nSMB2_tdis(const unsigned int xid, struct cifs_tcon *tcon)\r\n{\r\nstruct smb2_tree_disconnect_req *req;\r\nint rc = 0;\r\nstruct TCP_Server_Info *server;\r\nstruct cifs_ses *ses = tcon->ses;\r\ncFYI(1, "Tree Disconnect");\r\nif (ses && (ses->server))\r\nserver = ses->server;\r\nelse\r\nreturn -EIO;\r\nif ((tcon->need_reconnect) || (tcon->ses->need_reconnect))\r\nreturn 0;\r\nrc = small_smb2_init(SMB2_TREE_DISCONNECT, tcon, (void **) &req);\r\nif (rc)\r\nreturn rc;\r\nrc = SendReceiveNoRsp(xid, ses, (char *)&req->hdr, 0);\r\nif (rc)\r\ncifs_stats_fail_inc(tcon, SMB2_TREE_DISCONNECT_HE);\r\nreturn rc;\r\n}\r\nstatic struct create_lease *\r\ncreate_lease_buf(u8 *lease_key, u8 oplock)\r\n{\r\nstruct create_lease *buf;\r\nbuf = kmalloc(sizeof(struct create_lease), GFP_KERNEL);\r\nif (!buf)\r\nreturn NULL;\r\nmemset(buf, 0, sizeof(struct create_lease));\r\nbuf->lcontext.LeaseKeyLow = cpu_to_le64(*((u64 *)lease_key));\r\nbuf->lcontext.LeaseKeyHigh = cpu_to_le64(*((u64 *)(lease_key + 8)));\r\nif (oplock == SMB2_OPLOCK_LEVEL_EXCLUSIVE)\r\nbuf->lcontext.LeaseState = SMB2_LEASE_WRITE_CACHING |\r\nSMB2_LEASE_READ_CACHING;\r\nelse if (oplock == SMB2_OPLOCK_LEVEL_II)\r\nbuf->lcontext.LeaseState = SMB2_LEASE_READ_CACHING;\r\nelse if (oplock == SMB2_OPLOCK_LEVEL_BATCH)\r\nbuf->lcontext.LeaseState = SMB2_LEASE_HANDLE_CACHING |\r\nSMB2_LEASE_READ_CACHING |\r\nSMB2_LEASE_WRITE_CACHING;\r\nbuf->ccontext.DataOffset = cpu_to_le16(offsetof\r\n(struct create_lease, lcontext));\r\nbuf->ccontext.DataLength = cpu_to_le32(sizeof(struct lease_context));\r\nbuf->ccontext.NameOffset = cpu_to_le16(offsetof\r\n(struct create_lease, Name));\r\nbuf->ccontext.NameLength = cpu_to_le16(4);\r\nbuf->Name[0] = 'R';\r\nbuf->Name[1] = 'q';\r\nbuf->Name[2] = 'L';\r\nbuf->Name[3] = 's';\r\nreturn buf;\r\n}\r\nstatic __u8\r\nparse_lease_state(struct smb2_create_rsp *rsp)\r\n{\r\nchar *data_offset;\r\nstruct create_lease *lc;\r\nbool found = false;\r\ndata_offset = (char *)rsp;\r\ndata_offset += 4 + le32_to_cpu(rsp->CreateContextsOffset);\r\nlc = (struct create_lease *)data_offset;\r\ndo {\r\nchar *name = le16_to_cpu(lc->ccontext.NameOffset) + (char *)lc;\r\nif (le16_to_cpu(lc->ccontext.NameLength) != 4 ||\r\nstrncmp(name, "RqLs", 4)) {\r\nlc = (struct create_lease *)((char *)lc\r\n+ le32_to_cpu(lc->ccontext.Next));\r\ncontinue;\r\n}\r\nif (lc->lcontext.LeaseFlags & SMB2_LEASE_FLAG_BREAK_IN_PROGRESS)\r\nreturn SMB2_OPLOCK_LEVEL_NOCHANGE;\r\nfound = true;\r\nbreak;\r\n} while (le32_to_cpu(lc->ccontext.Next) != 0);\r\nif (!found)\r\nreturn 0;\r\nreturn smb2_map_lease_to_oplock(lc->lcontext.LeaseState);\r\n}\r\nint\r\nSMB2_open(const unsigned int xid, struct cifs_tcon *tcon, __le16 *path,\r\nu64 *persistent_fid, u64 *volatile_fid, __u32 desired_access,\r\n__u32 create_disposition, __u32 file_attributes, __u32 create_options,\r\n__u8 *oplock, struct smb2_file_all_info *buf)\r\n{\r\nstruct smb2_create_req *req;\r\nstruct smb2_create_rsp *rsp;\r\nstruct TCP_Server_Info *server;\r\nstruct cifs_ses *ses = tcon->ses;\r\nstruct kvec iov[3];\r\nint resp_buftype;\r\nint uni_path_len;\r\n__le16 *copy_path = NULL;\r\nint copy_size;\r\nint rc = 0;\r\nint num_iovecs = 2;\r\ncFYI(1, "create/open");\r\nif (ses && (ses->server))\r\nserver = ses->server;\r\nelse\r\nreturn -EIO;\r\nrc = small_smb2_init(SMB2_CREATE, tcon, (void **) &req);\r\nif (rc)\r\nreturn rc;\r\nreq->ImpersonationLevel = IL_IMPERSONATION;\r\nreq->DesiredAccess = cpu_to_le32(desired_access);\r\nreq->FileAttributes = cpu_to_le32(file_attributes);\r\nreq->ShareAccess = FILE_SHARE_ALL_LE;\r\nreq->CreateDisposition = cpu_to_le32(create_disposition);\r\nreq->CreateOptions = cpu_to_le32(create_options);\r\nuni_path_len = (2 * UniStrnlen((wchar_t *)path, PATH_MAX)) + 2;\r\nreq->NameOffset = cpu_to_le16(sizeof(struct smb2_create_req)\r\n- 8 - 4 );\r\niov[0].iov_base = (char *)req;\r\niov[0].iov_len = get_rfc1002_length(req) + 4;\r\nif (uni_path_len >= 4) {\r\nreq->NameLength = cpu_to_le16(uni_path_len - 2);\r\niov[0].iov_len--;\r\nif (uni_path_len % 8 != 0) {\r\ncopy_size = uni_path_len / 8 * 8;\r\nif (copy_size < uni_path_len)\r\ncopy_size += 8;\r\ncopy_path = kzalloc(copy_size, GFP_KERNEL);\r\nif (!copy_path)\r\nreturn -ENOMEM;\r\nmemcpy((char *)copy_path, (const char *)path,\r\nuni_path_len);\r\nuni_path_len = copy_size;\r\npath = copy_path;\r\n}\r\niov[1].iov_len = uni_path_len;\r\niov[1].iov_base = path;\r\ninc_rfc1001_len(req, uni_path_len - 1);\r\n} else {\r\niov[0].iov_len += 7;\r\nreq->hdr.smb2_buf_length = cpu_to_be32(be32_to_cpu(\r\nreq->hdr.smb2_buf_length) + 8 - 1);\r\nnum_iovecs = 1;\r\nreq->NameLength = 0;\r\n}\r\nif (!server->oplocks)\r\n*oplock = SMB2_OPLOCK_LEVEL_NONE;\r\nif (!(tcon->ses->server->capabilities & SMB2_GLOBAL_CAP_LEASING) ||\r\n*oplock == SMB2_OPLOCK_LEVEL_NONE)\r\nreq->RequestedOplockLevel = *oplock;\r\nelse {\r\niov[num_iovecs].iov_base = create_lease_buf(oplock+1, *oplock);\r\nif (iov[num_iovecs].iov_base == NULL) {\r\ncifs_small_buf_release(req);\r\nkfree(copy_path);\r\nreturn -ENOMEM;\r\n}\r\niov[num_iovecs].iov_len = sizeof(struct create_lease);\r\nreq->RequestedOplockLevel = SMB2_OPLOCK_LEVEL_LEASE;\r\nreq->CreateContextsOffset = cpu_to_le32(\r\nsizeof(struct smb2_create_req) - 4 - 8 +\r\niov[num_iovecs-1].iov_len);\r\nreq->CreateContextsLength = cpu_to_le32(\r\nsizeof(struct create_lease));\r\ninc_rfc1001_len(&req->hdr, sizeof(struct create_lease));\r\nnum_iovecs++;\r\n}\r\nrc = SendReceive2(xid, ses, iov, num_iovecs, &resp_buftype, 0);\r\nrsp = (struct smb2_create_rsp *)iov[0].iov_base;\r\nif (rc != 0) {\r\ncifs_stats_fail_inc(tcon, SMB2_CREATE_HE);\r\ngoto creat_exit;\r\n}\r\n*persistent_fid = rsp->PersistentFileId;\r\n*volatile_fid = rsp->VolatileFileId;\r\nif (buf) {\r\nmemcpy(buf, &rsp->CreationTime, 32);\r\nbuf->AllocationSize = rsp->AllocationSize;\r\nbuf->EndOfFile = rsp->EndofFile;\r\nbuf->Attributes = rsp->FileAttributes;\r\nbuf->NumberOfLinks = cpu_to_le32(1);\r\nbuf->DeletePending = 0;\r\n}\r\nif (rsp->OplockLevel == SMB2_OPLOCK_LEVEL_LEASE)\r\n*oplock = parse_lease_state(rsp);\r\nelse\r\n*oplock = rsp->OplockLevel;\r\ncreat_exit:\r\nkfree(copy_path);\r\nfree_rsp_buf(resp_buftype, rsp);\r\nreturn rc;\r\n}\r\nint\r\nSMB2_close(const unsigned int xid, struct cifs_tcon *tcon,\r\nu64 persistent_fid, u64 volatile_fid)\r\n{\r\nstruct smb2_close_req *req;\r\nstruct smb2_close_rsp *rsp;\r\nstruct TCP_Server_Info *server;\r\nstruct cifs_ses *ses = tcon->ses;\r\nstruct kvec iov[1];\r\nint resp_buftype;\r\nint rc = 0;\r\ncFYI(1, "Close");\r\nif (ses && (ses->server))\r\nserver = ses->server;\r\nelse\r\nreturn -EIO;\r\nrc = small_smb2_init(SMB2_CLOSE, tcon, (void **) &req);\r\nif (rc)\r\nreturn rc;\r\nreq->PersistentFileId = persistent_fid;\r\nreq->VolatileFileId = volatile_fid;\r\niov[0].iov_base = (char *)req;\r\niov[0].iov_len = get_rfc1002_length(req) + 4;\r\nrc = SendReceive2(xid, ses, iov, 1, &resp_buftype, 0);\r\nrsp = (struct smb2_close_rsp *)iov[0].iov_base;\r\nif (rc != 0) {\r\nif (tcon)\r\ncifs_stats_fail_inc(tcon, SMB2_CLOSE_HE);\r\ngoto close_exit;\r\n}\r\nclose_exit:\r\nfree_rsp_buf(resp_buftype, rsp);\r\nreturn rc;\r\n}\r\nstatic int\r\nvalidate_buf(unsigned int offset, unsigned int buffer_length,\r\nstruct smb2_hdr *hdr, unsigned int min_buf_size)\r\n{\r\nunsigned int smb_len = be32_to_cpu(hdr->smb2_buf_length);\r\nchar *end_of_smb = smb_len + 4 + (char *)hdr;\r\nchar *begin_of_buf = 4 + offset + (char *)hdr;\r\nchar *end_of_buf = begin_of_buf + buffer_length;\r\nif (buffer_length < min_buf_size) {\r\ncERROR(1, "buffer length %d smaller than minimum size %d",\r\nbuffer_length, min_buf_size);\r\nreturn -EINVAL;\r\n}\r\nif ((smb_len > 0x7FFFFF) || (buffer_length > 0x7FFFFF)) {\r\ncERROR(1, "buffer length %d or smb length %d too large",\r\nbuffer_length, smb_len);\r\nreturn -EINVAL;\r\n}\r\nif ((begin_of_buf > end_of_smb) || (end_of_buf > end_of_smb)) {\r\ncERROR(1, "illegal server response, bad offset to data");\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nvalidate_and_copy_buf(unsigned int offset, unsigned int buffer_length,\r\nstruct smb2_hdr *hdr, unsigned int minbufsize,\r\nchar *data)\r\n{\r\nchar *begin_of_buf = 4 + offset + (char *)hdr;\r\nint rc;\r\nif (!data)\r\nreturn -EINVAL;\r\nrc = validate_buf(offset, buffer_length, hdr, minbufsize);\r\nif (rc)\r\nreturn rc;\r\nmemcpy(data, begin_of_buf, buffer_length);\r\nreturn 0;\r\n}\r\nstatic int\r\nquery_info(const unsigned int xid, struct cifs_tcon *tcon,\r\nu64 persistent_fid, u64 volatile_fid, u8 info_class,\r\nsize_t output_len, size_t min_len, void *data)\r\n{\r\nstruct smb2_query_info_req *req;\r\nstruct smb2_query_info_rsp *rsp = NULL;\r\nstruct kvec iov[2];\r\nint rc = 0;\r\nint resp_buftype;\r\nstruct TCP_Server_Info *server;\r\nstruct cifs_ses *ses = tcon->ses;\r\ncFYI(1, "Query Info");\r\nif (ses && (ses->server))\r\nserver = ses->server;\r\nelse\r\nreturn -EIO;\r\nrc = small_smb2_init(SMB2_QUERY_INFO, tcon, (void **) &req);\r\nif (rc)\r\nreturn rc;\r\nreq->InfoType = SMB2_O_INFO_FILE;\r\nreq->FileInfoClass = info_class;\r\nreq->PersistentFileId = persistent_fid;\r\nreq->VolatileFileId = volatile_fid;\r\nreq->InputBufferOffset =\r\ncpu_to_le16(sizeof(struct smb2_query_info_req) - 1 - 4);\r\nreq->OutputBufferLength = cpu_to_le32(output_len);\r\niov[0].iov_base = (char *)req;\r\niov[0].iov_len = get_rfc1002_length(req) + 4;\r\nrc = SendReceive2(xid, ses, iov, 1, &resp_buftype, 0);\r\nrsp = (struct smb2_query_info_rsp *)iov[0].iov_base;\r\nif (rc) {\r\ncifs_stats_fail_inc(tcon, SMB2_QUERY_INFO_HE);\r\ngoto qinf_exit;\r\n}\r\nrc = validate_and_copy_buf(le16_to_cpu(rsp->OutputBufferOffset),\r\nle32_to_cpu(rsp->OutputBufferLength),\r\n&rsp->hdr, min_len, data);\r\nqinf_exit:\r\nfree_rsp_buf(resp_buftype, rsp);\r\nreturn rc;\r\n}\r\nint\r\nSMB2_query_info(const unsigned int xid, struct cifs_tcon *tcon,\r\nu64 persistent_fid, u64 volatile_fid,\r\nstruct smb2_file_all_info *data)\r\n{\r\nreturn query_info(xid, tcon, persistent_fid, volatile_fid,\r\nFILE_ALL_INFORMATION,\r\nsizeof(struct smb2_file_all_info) + MAX_NAME * 2,\r\nsizeof(struct smb2_file_all_info), data);\r\n}\r\nint\r\nSMB2_get_srv_num(const unsigned int xid, struct cifs_tcon *tcon,\r\nu64 persistent_fid, u64 volatile_fid, __le64 *uniqueid)\r\n{\r\nreturn query_info(xid, tcon, persistent_fid, volatile_fid,\r\nFILE_INTERNAL_INFORMATION,\r\nsizeof(struct smb2_file_internal_info),\r\nsizeof(struct smb2_file_internal_info), uniqueid);\r\n}\r\nstatic void\r\nsmb2_echo_callback(struct mid_q_entry *mid)\r\n{\r\nstruct TCP_Server_Info *server = mid->callback_data;\r\nstruct smb2_echo_rsp *smb2 = (struct smb2_echo_rsp *)mid->resp_buf;\r\nunsigned int credits_received = 1;\r\nif (mid->mid_state == MID_RESPONSE_RECEIVED)\r\ncredits_received = le16_to_cpu(smb2->hdr.CreditRequest);\r\nDeleteMidQEntry(mid);\r\nadd_credits(server, credits_received, CIFS_ECHO_OP);\r\n}\r\nint\r\nSMB2_echo(struct TCP_Server_Info *server)\r\n{\r\nstruct smb2_echo_req *req;\r\nint rc = 0;\r\nstruct kvec iov;\r\nstruct smb_rqst rqst = { .rq_iov = &iov,\r\n.rq_nvec = 1 };\r\ncFYI(1, "In echo request");\r\nrc = small_smb2_init(SMB2_ECHO, NULL, (void **)&req);\r\nif (rc)\r\nreturn rc;\r\nreq->hdr.CreditRequest = cpu_to_le16(1);\r\niov.iov_base = (char *)req;\r\niov.iov_len = get_rfc1002_length(req) + 4;\r\nrc = cifs_call_async(server, &rqst, NULL, smb2_echo_callback, server,\r\nCIFS_ECHO_OP);\r\nif (rc)\r\ncFYI(1, "Echo request failed: %d", rc);\r\ncifs_small_buf_release(req);\r\nreturn rc;\r\n}\r\nint\r\nSMB2_flush(const unsigned int xid, struct cifs_tcon *tcon, u64 persistent_fid,\r\nu64 volatile_fid)\r\n{\r\nstruct smb2_flush_req *req;\r\nstruct TCP_Server_Info *server;\r\nstruct cifs_ses *ses = tcon->ses;\r\nstruct kvec iov[1];\r\nint resp_buftype;\r\nint rc = 0;\r\ncFYI(1, "Flush");\r\nif (ses && (ses->server))\r\nserver = ses->server;\r\nelse\r\nreturn -EIO;\r\nrc = small_smb2_init(SMB2_FLUSH, tcon, (void **) &req);\r\nif (rc)\r\nreturn rc;\r\nreq->PersistentFileId = persistent_fid;\r\nreq->VolatileFileId = volatile_fid;\r\niov[0].iov_base = (char *)req;\r\niov[0].iov_len = get_rfc1002_length(req) + 4;\r\nrc = SendReceive2(xid, ses, iov, 1, &resp_buftype, 0);\r\nif ((rc != 0) && tcon)\r\ncifs_stats_fail_inc(tcon, SMB2_FLUSH_HE);\r\nfree_rsp_buf(resp_buftype, iov[0].iov_base);\r\nreturn rc;\r\n}\r\nstatic int\r\nsmb2_new_read_req(struct kvec *iov, struct cifs_io_parms *io_parms,\r\nunsigned int remaining_bytes, int request_type)\r\n{\r\nint rc = -EACCES;\r\nstruct smb2_read_req *req = NULL;\r\nrc = small_smb2_init(SMB2_READ, io_parms->tcon, (void **) &req);\r\nif (rc)\r\nreturn rc;\r\nif (io_parms->tcon->ses->server == NULL)\r\nreturn -ECONNABORTED;\r\nreq->hdr.ProcessId = cpu_to_le32(io_parms->pid);\r\nreq->PersistentFileId = io_parms->persistent_fid;\r\nreq->VolatileFileId = io_parms->volatile_fid;\r\nreq->ReadChannelInfoOffset = 0;\r\nreq->ReadChannelInfoLength = 0;\r\nreq->Channel = 0;\r\nreq->MinimumCount = 0;\r\nreq->Length = cpu_to_le32(io_parms->length);\r\nreq->Offset = cpu_to_le64(io_parms->offset);\r\nif (request_type & CHAINED_REQUEST) {\r\nif (!(request_type & END_OF_CHAIN)) {\r\nreq->hdr.NextCommand =\r\ncpu_to_le32(get_rfc1002_length(req) + 4);\r\n} else\r\nreq->hdr.NextCommand = 0;\r\nif (request_type & RELATED_REQUEST) {\r\nreq->hdr.Flags |= SMB2_FLAGS_RELATED_OPERATIONS;\r\nreq->hdr.SessionId = 0xFFFFFFFF;\r\nreq->hdr.TreeId = 0xFFFFFFFF;\r\nreq->PersistentFileId = 0xFFFFFFFF;\r\nreq->VolatileFileId = 0xFFFFFFFF;\r\n}\r\n}\r\nif (remaining_bytes > io_parms->length)\r\nreq->RemainingBytes = cpu_to_le32(remaining_bytes);\r\nelse\r\nreq->RemainingBytes = 0;\r\niov[0].iov_base = (char *)req;\r\niov[0].iov_len = get_rfc1002_length(req) + 4;\r\nreturn rc;\r\n}\r\nstatic void\r\nsmb2_readv_callback(struct mid_q_entry *mid)\r\n{\r\nstruct cifs_readdata *rdata = mid->callback_data;\r\nstruct cifs_tcon *tcon = tlink_tcon(rdata->cfile->tlink);\r\nstruct TCP_Server_Info *server = tcon->ses->server;\r\nstruct smb2_hdr *buf = (struct smb2_hdr *)rdata->iov.iov_base;\r\nunsigned int credits_received = 1;\r\nstruct smb_rqst rqst = { .rq_iov = &rdata->iov,\r\n.rq_nvec = 1,\r\n.rq_pages = rdata->pages,\r\n.rq_npages = rdata->nr_pages,\r\n.rq_pagesz = rdata->pagesz,\r\n.rq_tailsz = rdata->tailsz };\r\ncFYI(1, "%s: mid=%llu state=%d result=%d bytes=%u", __func__,\r\nmid->mid, mid->mid_state, rdata->result, rdata->bytes);\r\nswitch (mid->mid_state) {\r\ncase MID_RESPONSE_RECEIVED:\r\ncredits_received = le16_to_cpu(buf->CreditRequest);\r\nif (server->sec_mode &\r\n(SECMODE_SIGN_REQUIRED | SECMODE_SIGN_ENABLED)) {\r\nint rc;\r\nrc = smb2_verify_signature(&rqst, server);\r\nif (rc)\r\ncERROR(1, "SMB signature verification returned "\r\n"error = %d", rc);\r\n}\r\ntask_io_account_read(rdata->bytes);\r\ncifs_stats_bytes_read(tcon, rdata->bytes);\r\nbreak;\r\ncase MID_REQUEST_SUBMITTED:\r\ncase MID_RETRY_NEEDED:\r\nrdata->result = -EAGAIN;\r\nbreak;\r\ndefault:\r\nif (rdata->result != -ENODATA)\r\nrdata->result = -EIO;\r\n}\r\nif (rdata->result)\r\ncifs_stats_fail_inc(tcon, SMB2_READ_HE);\r\nqueue_work(cifsiod_wq, &rdata->work);\r\nDeleteMidQEntry(mid);\r\nadd_credits(server, credits_received, 0);\r\n}\r\nint\r\nsmb2_async_readv(struct cifs_readdata *rdata)\r\n{\r\nint rc;\r\nstruct smb2_hdr *buf;\r\nstruct cifs_io_parms io_parms;\r\nstruct smb_rqst rqst = { .rq_iov = &rdata->iov,\r\n.rq_nvec = 1 };\r\ncFYI(1, "%s: offset=%llu bytes=%u", __func__,\r\nrdata->offset, rdata->bytes);\r\nio_parms.tcon = tlink_tcon(rdata->cfile->tlink);\r\nio_parms.offset = rdata->offset;\r\nio_parms.length = rdata->bytes;\r\nio_parms.persistent_fid = rdata->cfile->fid.persistent_fid;\r\nio_parms.volatile_fid = rdata->cfile->fid.volatile_fid;\r\nio_parms.pid = rdata->pid;\r\nrc = smb2_new_read_req(&rdata->iov, &io_parms, 0, 0);\r\nif (rc)\r\nreturn rc;\r\nbuf = (struct smb2_hdr *)rdata->iov.iov_base;\r\nrdata->iov.iov_len = get_rfc1002_length(rdata->iov.iov_base) + 4;\r\nkref_get(&rdata->refcount);\r\nrc = cifs_call_async(io_parms.tcon->ses->server, &rqst,\r\ncifs_readv_receive, smb2_readv_callback,\r\nrdata, 0);\r\nif (rc) {\r\nkref_put(&rdata->refcount, cifs_readdata_release);\r\ncifs_stats_fail_inc(io_parms.tcon, SMB2_READ_HE);\r\n}\r\ncifs_small_buf_release(buf);\r\nreturn rc;\r\n}\r\nint\r\nSMB2_read(const unsigned int xid, struct cifs_io_parms *io_parms,\r\nunsigned int *nbytes, char **buf, int *buf_type)\r\n{\r\nint resp_buftype, rc = -EACCES;\r\nstruct smb2_read_rsp *rsp = NULL;\r\nstruct kvec iov[1];\r\n*nbytes = 0;\r\nrc = smb2_new_read_req(iov, io_parms, 0, 0);\r\nif (rc)\r\nreturn rc;\r\nrc = SendReceive2(xid, io_parms->tcon->ses, iov, 1,\r\n&resp_buftype, CIFS_LOG_ERROR);\r\nrsp = (struct smb2_read_rsp *)iov[0].iov_base;\r\nif (rsp->hdr.Status == STATUS_END_OF_FILE) {\r\nfree_rsp_buf(resp_buftype, iov[0].iov_base);\r\nreturn 0;\r\n}\r\nif (rc) {\r\ncifs_stats_fail_inc(io_parms->tcon, SMB2_READ_HE);\r\ncERROR(1, "Send error in read = %d", rc);\r\n} else {\r\n*nbytes = le32_to_cpu(rsp->DataLength);\r\nif ((*nbytes > CIFS_MAX_MSGSIZE) ||\r\n(*nbytes > io_parms->length)) {\r\ncFYI(1, "bad length %d for count %d", *nbytes,\r\nio_parms->length);\r\nrc = -EIO;\r\n*nbytes = 0;\r\n}\r\n}\r\nif (*buf) {\r\nmemcpy(*buf, (char *)rsp->hdr.ProtocolId + rsp->DataOffset,\r\n*nbytes);\r\nfree_rsp_buf(resp_buftype, iov[0].iov_base);\r\n} else if (resp_buftype != CIFS_NO_BUFFER) {\r\n*buf = iov[0].iov_base;\r\nif (resp_buftype == CIFS_SMALL_BUFFER)\r\n*buf_type = CIFS_SMALL_BUFFER;\r\nelse if (resp_buftype == CIFS_LARGE_BUFFER)\r\n*buf_type = CIFS_LARGE_BUFFER;\r\n}\r\nreturn rc;\r\n}\r\nstatic void\r\nsmb2_writev_callback(struct mid_q_entry *mid)\r\n{\r\nstruct cifs_writedata *wdata = mid->callback_data;\r\nstruct cifs_tcon *tcon = tlink_tcon(wdata->cfile->tlink);\r\nunsigned int written;\r\nstruct smb2_write_rsp *rsp = (struct smb2_write_rsp *)mid->resp_buf;\r\nunsigned int credits_received = 1;\r\nswitch (mid->mid_state) {\r\ncase MID_RESPONSE_RECEIVED:\r\ncredits_received = le16_to_cpu(rsp->hdr.CreditRequest);\r\nwdata->result = smb2_check_receive(mid, tcon->ses->server, 0);\r\nif (wdata->result != 0)\r\nbreak;\r\nwritten = le32_to_cpu(rsp->DataLength);\r\nif (written > wdata->bytes)\r\nwritten &= 0xFFFF;\r\nif (written < wdata->bytes)\r\nwdata->result = -ENOSPC;\r\nelse\r\nwdata->bytes = written;\r\nbreak;\r\ncase MID_REQUEST_SUBMITTED:\r\ncase MID_RETRY_NEEDED:\r\nwdata->result = -EAGAIN;\r\nbreak;\r\ndefault:\r\nwdata->result = -EIO;\r\nbreak;\r\n}\r\nif (wdata->result)\r\ncifs_stats_fail_inc(tcon, SMB2_WRITE_HE);\r\nqueue_work(cifsiod_wq, &wdata->work);\r\nDeleteMidQEntry(mid);\r\nadd_credits(tcon->ses->server, credits_received, 0);\r\n}\r\nint\r\nsmb2_async_writev(struct cifs_writedata *wdata)\r\n{\r\nint rc = -EACCES;\r\nstruct smb2_write_req *req = NULL;\r\nstruct cifs_tcon *tcon = tlink_tcon(wdata->cfile->tlink);\r\nstruct kvec iov;\r\nstruct smb_rqst rqst;\r\nrc = small_smb2_init(SMB2_WRITE, tcon, (void **) &req);\r\nif (rc)\r\ngoto async_writev_out;\r\nreq->hdr.ProcessId = cpu_to_le32(wdata->cfile->pid);\r\nreq->PersistentFileId = wdata->cfile->fid.persistent_fid;\r\nreq->VolatileFileId = wdata->cfile->fid.volatile_fid;\r\nreq->WriteChannelInfoOffset = 0;\r\nreq->WriteChannelInfoLength = 0;\r\nreq->Channel = 0;\r\nreq->Offset = cpu_to_le64(wdata->offset);\r\nreq->DataOffset = cpu_to_le16(\r\noffsetof(struct smb2_write_req, Buffer) - 4);\r\nreq->RemainingBytes = 0;\r\niov.iov_len = get_rfc1002_length(req) + 4 - 1;\r\niov.iov_base = req;\r\nrqst.rq_iov = &iov;\r\nrqst.rq_nvec = 1;\r\nrqst.rq_pages = wdata->pages;\r\nrqst.rq_npages = wdata->nr_pages;\r\nrqst.rq_pagesz = wdata->pagesz;\r\nrqst.rq_tailsz = wdata->tailsz;\r\ncFYI(1, "async write at %llu %u bytes", wdata->offset, wdata->bytes);\r\nreq->Length = cpu_to_le32(wdata->bytes);\r\ninc_rfc1001_len(&req->hdr, wdata->bytes - 1 );\r\nkref_get(&wdata->refcount);\r\nrc = cifs_call_async(tcon->ses->server, &rqst, NULL,\r\nsmb2_writev_callback, wdata, 0);\r\nif (rc) {\r\nkref_put(&wdata->refcount, cifs_writedata_release);\r\ncifs_stats_fail_inc(tcon, SMB2_WRITE_HE);\r\n}\r\nasync_writev_out:\r\ncifs_small_buf_release(req);\r\nreturn rc;\r\n}\r\nint\r\nSMB2_write(const unsigned int xid, struct cifs_io_parms *io_parms,\r\nunsigned int *nbytes, struct kvec *iov, int n_vec)\r\n{\r\nint rc = 0;\r\nstruct smb2_write_req *req = NULL;\r\nstruct smb2_write_rsp *rsp = NULL;\r\nint resp_buftype;\r\n*nbytes = 0;\r\nif (n_vec < 1)\r\nreturn rc;\r\nrc = small_smb2_init(SMB2_WRITE, io_parms->tcon, (void **) &req);\r\nif (rc)\r\nreturn rc;\r\nif (io_parms->tcon->ses->server == NULL)\r\nreturn -ECONNABORTED;\r\nreq->hdr.ProcessId = cpu_to_le32(io_parms->pid);\r\nreq->PersistentFileId = io_parms->persistent_fid;\r\nreq->VolatileFileId = io_parms->volatile_fid;\r\nreq->WriteChannelInfoOffset = 0;\r\nreq->WriteChannelInfoLength = 0;\r\nreq->Channel = 0;\r\nreq->Length = cpu_to_le32(io_parms->length);\r\nreq->Offset = cpu_to_le64(io_parms->offset);\r\nreq->DataOffset = cpu_to_le16(\r\noffsetof(struct smb2_write_req, Buffer) - 4);\r\nreq->RemainingBytes = 0;\r\niov[0].iov_base = (char *)req;\r\niov[0].iov_len = get_rfc1002_length(req) + 4 - 1;\r\ninc_rfc1001_len(req, io_parms->length - 1 );\r\nrc = SendReceive2(xid, io_parms->tcon->ses, iov, n_vec + 1,\r\n&resp_buftype, 0);\r\nrsp = (struct smb2_write_rsp *)iov[0].iov_base;\r\nif (rc) {\r\ncifs_stats_fail_inc(io_parms->tcon, SMB2_WRITE_HE);\r\ncERROR(1, "Send error in write = %d", rc);\r\n} else\r\n*nbytes = le32_to_cpu(rsp->DataLength);\r\nfree_rsp_buf(resp_buftype, rsp);\r\nreturn rc;\r\n}\r\nstatic unsigned int\r\nnum_entries(char *bufstart, char *end_of_buf, char **lastentry, size_t size)\r\n{\r\nint len;\r\nunsigned int entrycount = 0;\r\nunsigned int next_offset = 0;\r\nFILE_DIRECTORY_INFO *entryptr;\r\nif (bufstart == NULL)\r\nreturn 0;\r\nentryptr = (FILE_DIRECTORY_INFO *)bufstart;\r\nwhile (1) {\r\nentryptr = (FILE_DIRECTORY_INFO *)\r\n((char *)entryptr + next_offset);\r\nif ((char *)entryptr + size > end_of_buf) {\r\ncERROR(1, "malformed search entry would overflow");\r\nbreak;\r\n}\r\nlen = le32_to_cpu(entryptr->FileNameLength);\r\nif ((char *)entryptr + len + size > end_of_buf) {\r\ncERROR(1, "directory entry name would overflow frame "\r\n"end of buf %p", end_of_buf);\r\nbreak;\r\n}\r\n*lastentry = (char *)entryptr;\r\nentrycount++;\r\nnext_offset = le32_to_cpu(entryptr->NextEntryOffset);\r\nif (!next_offset)\r\nbreak;\r\n}\r\nreturn entrycount;\r\n}\r\nint\r\nSMB2_query_directory(const unsigned int xid, struct cifs_tcon *tcon,\r\nu64 persistent_fid, u64 volatile_fid, int index,\r\nstruct cifs_search_info *srch_inf)\r\n{\r\nstruct smb2_query_directory_req *req;\r\nstruct smb2_query_directory_rsp *rsp = NULL;\r\nstruct kvec iov[2];\r\nint rc = 0;\r\nint len;\r\nint resp_buftype;\r\nunsigned char *bufptr;\r\nstruct TCP_Server_Info *server;\r\nstruct cifs_ses *ses = tcon->ses;\r\n__le16 asteriks = cpu_to_le16('*');\r\nchar *end_of_smb;\r\nunsigned int output_size = CIFSMaxBufSize;\r\nsize_t info_buf_size;\r\nif (ses && (ses->server))\r\nserver = ses->server;\r\nelse\r\nreturn -EIO;\r\nrc = small_smb2_init(SMB2_QUERY_DIRECTORY, tcon, (void **) &req);\r\nif (rc)\r\nreturn rc;\r\nswitch (srch_inf->info_level) {\r\ncase SMB_FIND_FILE_DIRECTORY_INFO:\r\nreq->FileInformationClass = FILE_DIRECTORY_INFORMATION;\r\ninfo_buf_size = sizeof(FILE_DIRECTORY_INFO) - 1;\r\nbreak;\r\ncase SMB_FIND_FILE_ID_FULL_DIR_INFO:\r\nreq->FileInformationClass = FILEID_FULL_DIRECTORY_INFORMATION;\r\ninfo_buf_size = sizeof(SEARCH_ID_FULL_DIR_INFO) - 1;\r\nbreak;\r\ndefault:\r\ncERROR(1, "info level %u isn't supported",\r\nsrch_inf->info_level);\r\nrc = -EINVAL;\r\ngoto qdir_exit;\r\n}\r\nreq->FileIndex = cpu_to_le32(index);\r\nreq->PersistentFileId = persistent_fid;\r\nreq->VolatileFileId = volatile_fid;\r\nlen = 0x2;\r\nbufptr = req->Buffer;\r\nmemcpy(bufptr, &asteriks, len);\r\nreq->FileNameOffset =\r\ncpu_to_le16(sizeof(struct smb2_query_directory_req) - 1 - 4);\r\nreq->FileNameLength = cpu_to_le16(len);\r\noutput_size = min_t(unsigned int, output_size, server->maxBuf);\r\noutput_size = min_t(unsigned int, output_size, 2 << 15);\r\nreq->OutputBufferLength = cpu_to_le32(output_size);\r\niov[0].iov_base = (char *)req;\r\niov[0].iov_len = get_rfc1002_length(req) + 4 - 1;\r\niov[1].iov_base = (char *)(req->Buffer);\r\niov[1].iov_len = len;\r\ninc_rfc1001_len(req, len - 1 );\r\nrc = SendReceive2(xid, ses, iov, 2, &resp_buftype, 0);\r\nrsp = (struct smb2_query_directory_rsp *)iov[0].iov_base;\r\nif (rc) {\r\ncifs_stats_fail_inc(tcon, SMB2_QUERY_DIRECTORY_HE);\r\ngoto qdir_exit;\r\n}\r\nrc = validate_buf(le16_to_cpu(rsp->OutputBufferOffset),\r\nle32_to_cpu(rsp->OutputBufferLength), &rsp->hdr,\r\ninfo_buf_size);\r\nif (rc)\r\ngoto qdir_exit;\r\nsrch_inf->unicode = true;\r\nif (srch_inf->ntwrk_buf_start) {\r\nif (srch_inf->smallBuf)\r\ncifs_small_buf_release(srch_inf->ntwrk_buf_start);\r\nelse\r\ncifs_buf_release(srch_inf->ntwrk_buf_start);\r\n}\r\nsrch_inf->ntwrk_buf_start = (char *)rsp;\r\nsrch_inf->srch_entries_start = srch_inf->last_entry = 4 +\r\n(char *)&rsp->hdr + le16_to_cpu(rsp->OutputBufferOffset);\r\nend_of_smb = get_rfc1002_length(rsp) + 4 + (char *)&rsp->hdr;\r\nsrch_inf->entries_in_buffer =\r\nnum_entries(srch_inf->srch_entries_start, end_of_smb,\r\n&srch_inf->last_entry, info_buf_size);\r\nsrch_inf->index_of_last_entry += srch_inf->entries_in_buffer;\r\ncFYI(1, "num entries %d last_index %lld srch start %p srch end %p",\r\nsrch_inf->entries_in_buffer, srch_inf->index_of_last_entry,\r\nsrch_inf->srch_entries_start, srch_inf->last_entry);\r\nif (resp_buftype == CIFS_LARGE_BUFFER)\r\nsrch_inf->smallBuf = false;\r\nelse if (resp_buftype == CIFS_SMALL_BUFFER)\r\nsrch_inf->smallBuf = true;\r\nelse\r\ncERROR(1, "illegal search buffer type");\r\nif (rsp->hdr.Status == STATUS_NO_MORE_FILES)\r\nsrch_inf->endOfSearch = 1;\r\nelse\r\nsrch_inf->endOfSearch = 0;\r\nreturn rc;\r\nqdir_exit:\r\nfree_rsp_buf(resp_buftype, rsp);\r\nreturn rc;\r\n}\r\nstatic int\r\nsend_set_info(const unsigned int xid, struct cifs_tcon *tcon,\r\nu64 persistent_fid, u64 volatile_fid, u32 pid, int info_class,\r\nunsigned int num, void **data, unsigned int *size)\r\n{\r\nstruct smb2_set_info_req *req;\r\nstruct smb2_set_info_rsp *rsp = NULL;\r\nstruct kvec *iov;\r\nint rc = 0;\r\nint resp_buftype;\r\nunsigned int i;\r\nstruct TCP_Server_Info *server;\r\nstruct cifs_ses *ses = tcon->ses;\r\nif (ses && (ses->server))\r\nserver = ses->server;\r\nelse\r\nreturn -EIO;\r\nif (!num)\r\nreturn -EINVAL;\r\niov = kmalloc(sizeof(struct kvec) * num, GFP_KERNEL);\r\nif (!iov)\r\nreturn -ENOMEM;\r\nrc = small_smb2_init(SMB2_SET_INFO, tcon, (void **) &req);\r\nif (rc) {\r\nkfree(iov);\r\nreturn rc;\r\n}\r\nreq->hdr.ProcessId = cpu_to_le32(pid);\r\nreq->InfoType = SMB2_O_INFO_FILE;\r\nreq->FileInfoClass = info_class;\r\nreq->PersistentFileId = persistent_fid;\r\nreq->VolatileFileId = volatile_fid;\r\nreq->BufferOffset =\r\ncpu_to_le16(sizeof(struct smb2_set_info_req) - 1 - 4);\r\nreq->BufferLength = cpu_to_le32(*size);\r\ninc_rfc1001_len(req, *size - 1 );\r\nmemcpy(req->Buffer, *data, *size);\r\niov[0].iov_base = (char *)req;\r\niov[0].iov_len = get_rfc1002_length(req) + 4;\r\nfor (i = 1; i < num; i++) {\r\ninc_rfc1001_len(req, size[i]);\r\nle32_add_cpu(&req->BufferLength, size[i]);\r\niov[i].iov_base = (char *)data[i];\r\niov[i].iov_len = size[i];\r\n}\r\nrc = SendReceive2(xid, ses, iov, num, &resp_buftype, 0);\r\nrsp = (struct smb2_set_info_rsp *)iov[0].iov_base;\r\nif (rc != 0) {\r\ncifs_stats_fail_inc(tcon, SMB2_SET_INFO_HE);\r\ngoto out;\r\n}\r\nout:\r\nfree_rsp_buf(resp_buftype, rsp);\r\nkfree(iov);\r\nreturn rc;\r\n}\r\nint\r\nSMB2_rename(const unsigned int xid, struct cifs_tcon *tcon,\r\nu64 persistent_fid, u64 volatile_fid, __le16 *target_file)\r\n{\r\nstruct smb2_file_rename_info info;\r\nvoid **data;\r\nunsigned int size[2];\r\nint rc;\r\nint len = (2 * UniStrnlen((wchar_t *)target_file, PATH_MAX));\r\ndata = kmalloc(sizeof(void *) * 2, GFP_KERNEL);\r\nif (!data)\r\nreturn -ENOMEM;\r\ninfo.ReplaceIfExists = 1;\r\ninfo.RootDirectory = 0;\r\ninfo.FileNameLength = cpu_to_le32(len);\r\ndata[0] = &info;\r\nsize[0] = sizeof(struct smb2_file_rename_info);\r\ndata[1] = target_file;\r\nsize[1] = len + 2 ;\r\nrc = send_set_info(xid, tcon, persistent_fid, volatile_fid,\r\ncurrent->tgid, FILE_RENAME_INFORMATION, 2, data,\r\nsize);\r\nkfree(data);\r\nreturn rc;\r\n}\r\nint\r\nSMB2_set_hardlink(const unsigned int xid, struct cifs_tcon *tcon,\r\nu64 persistent_fid, u64 volatile_fid, __le16 *target_file)\r\n{\r\nstruct smb2_file_link_info info;\r\nvoid **data;\r\nunsigned int size[2];\r\nint rc;\r\nint len = (2 * UniStrnlen((wchar_t *)target_file, PATH_MAX));\r\ndata = kmalloc(sizeof(void *) * 2, GFP_KERNEL);\r\nif (!data)\r\nreturn -ENOMEM;\r\ninfo.ReplaceIfExists = 0;\r\ninfo.RootDirectory = 0;\r\ninfo.FileNameLength = cpu_to_le32(len);\r\ndata[0] = &info;\r\nsize[0] = sizeof(struct smb2_file_link_info);\r\ndata[1] = target_file;\r\nsize[1] = len + 2 ;\r\nrc = send_set_info(xid, tcon, persistent_fid, volatile_fid,\r\ncurrent->tgid, FILE_LINK_INFORMATION, 2, data, size);\r\nkfree(data);\r\nreturn rc;\r\n}\r\nint\r\nSMB2_set_eof(const unsigned int xid, struct cifs_tcon *tcon, u64 persistent_fid,\r\nu64 volatile_fid, u32 pid, __le64 *eof)\r\n{\r\nstruct smb2_file_eof_info info;\r\nvoid *data;\r\nunsigned int size;\r\ninfo.EndOfFile = *eof;\r\ndata = &info;\r\nsize = sizeof(struct smb2_file_eof_info);\r\nreturn send_set_info(xid, tcon, persistent_fid, volatile_fid, pid,\r\nFILE_END_OF_FILE_INFORMATION, 1, &data, &size);\r\n}\r\nint\r\nSMB2_set_info(const unsigned int xid, struct cifs_tcon *tcon,\r\nu64 persistent_fid, u64 volatile_fid, FILE_BASIC_INFO *buf)\r\n{\r\nunsigned int size;\r\nsize = sizeof(FILE_BASIC_INFO);\r\nreturn send_set_info(xid, tcon, persistent_fid, volatile_fid,\r\ncurrent->tgid, FILE_BASIC_INFORMATION, 1,\r\n(void **)&buf, &size);\r\n}\r\nint\r\nSMB2_oplock_break(const unsigned int xid, struct cifs_tcon *tcon,\r\nconst u64 persistent_fid, const u64 volatile_fid,\r\n__u8 oplock_level)\r\n{\r\nint rc;\r\nstruct smb2_oplock_break *req = NULL;\r\ncFYI(1, "SMB2_oplock_break");\r\nrc = small_smb2_init(SMB2_OPLOCK_BREAK, tcon, (void **) &req);\r\nif (rc)\r\nreturn rc;\r\nreq->VolatileFid = volatile_fid;\r\nreq->PersistentFid = persistent_fid;\r\nreq->OplockLevel = oplock_level;\r\nreq->hdr.CreditRequest = cpu_to_le16(1);\r\nrc = SendReceiveNoRsp(xid, tcon->ses, (char *) req, CIFS_OBREAK_OP);\r\nif (rc) {\r\ncifs_stats_fail_inc(tcon, SMB2_OPLOCK_BREAK_HE);\r\ncFYI(1, "Send error in Oplock Break = %d", rc);\r\n}\r\nreturn rc;\r\n}\r\nstatic void\r\ncopy_fs_info_to_kstatfs(struct smb2_fs_full_size_info *pfs_inf,\r\nstruct kstatfs *kst)\r\n{\r\nkst->f_bsize = le32_to_cpu(pfs_inf->BytesPerSector) *\r\nle32_to_cpu(pfs_inf->SectorsPerAllocationUnit);\r\nkst->f_blocks = le64_to_cpu(pfs_inf->TotalAllocationUnits);\r\nkst->f_bfree = le64_to_cpu(pfs_inf->ActualAvailableAllocationUnits);\r\nkst->f_bavail = le64_to_cpu(pfs_inf->CallerAvailableAllocationUnits);\r\nreturn;\r\n}\r\nstatic int\r\nbuild_qfs_info_req(struct kvec *iov, struct cifs_tcon *tcon, int level,\r\nint outbuf_len, u64 persistent_fid, u64 volatile_fid)\r\n{\r\nint rc;\r\nstruct smb2_query_info_req *req;\r\ncFYI(1, "Query FSInfo level %d", level);\r\nif ((tcon->ses == NULL) || (tcon->ses->server == NULL))\r\nreturn -EIO;\r\nrc = small_smb2_init(SMB2_QUERY_INFO, tcon, (void **) &req);\r\nif (rc)\r\nreturn rc;\r\nreq->InfoType = SMB2_O_INFO_FILESYSTEM;\r\nreq->FileInfoClass = level;\r\nreq->PersistentFileId = persistent_fid;\r\nreq->VolatileFileId = volatile_fid;\r\nreq->InputBufferOffset =\r\ncpu_to_le16(sizeof(struct smb2_query_info_req) - 1 - 4);\r\nreq->OutputBufferLength = cpu_to_le32(\r\noutbuf_len + sizeof(struct smb2_query_info_rsp) - 1 - 4);\r\niov->iov_base = (char *)req;\r\niov->iov_len = get_rfc1002_length(req) + 4;\r\nreturn 0;\r\n}\r\nint\r\nSMB2_QFS_info(const unsigned int xid, struct cifs_tcon *tcon,\r\nu64 persistent_fid, u64 volatile_fid, struct kstatfs *fsdata)\r\n{\r\nstruct smb2_query_info_rsp *rsp = NULL;\r\nstruct kvec iov;\r\nint rc = 0;\r\nint resp_buftype;\r\nstruct cifs_ses *ses = tcon->ses;\r\nstruct smb2_fs_full_size_info *info = NULL;\r\nrc = build_qfs_info_req(&iov, tcon, FS_FULL_SIZE_INFORMATION,\r\nsizeof(struct smb2_fs_full_size_info),\r\npersistent_fid, volatile_fid);\r\nif (rc)\r\nreturn rc;\r\nrc = SendReceive2(xid, ses, &iov, 1, &resp_buftype, 0);\r\nif (rc) {\r\ncifs_stats_fail_inc(tcon, SMB2_QUERY_INFO_HE);\r\ngoto qinf_exit;\r\n}\r\nrsp = (struct smb2_query_info_rsp *)iov.iov_base;\r\ninfo = (struct smb2_fs_full_size_info *)(4 +\r\nle16_to_cpu(rsp->OutputBufferOffset) + (char *)&rsp->hdr);\r\nrc = validate_buf(le16_to_cpu(rsp->OutputBufferOffset),\r\nle32_to_cpu(rsp->OutputBufferLength), &rsp->hdr,\r\nsizeof(struct smb2_fs_full_size_info));\r\nif (!rc)\r\ncopy_fs_info_to_kstatfs(info, fsdata);\r\nqinf_exit:\r\nfree_rsp_buf(resp_buftype, iov.iov_base);\r\nreturn rc;\r\n}\r\nint\r\nsmb2_lockv(const unsigned int xid, struct cifs_tcon *tcon,\r\nconst __u64 persist_fid, const __u64 volatile_fid, const __u32 pid,\r\nconst __u32 num_lock, struct smb2_lock_element *buf)\r\n{\r\nint rc = 0;\r\nstruct smb2_lock_req *req = NULL;\r\nstruct kvec iov[2];\r\nint resp_buf_type;\r\nunsigned int count;\r\ncFYI(1, "smb2_lockv num lock %d", num_lock);\r\nrc = small_smb2_init(SMB2_LOCK, tcon, (void **) &req);\r\nif (rc)\r\nreturn rc;\r\nreq->hdr.ProcessId = cpu_to_le32(pid);\r\nreq->LockCount = cpu_to_le16(num_lock);\r\nreq->PersistentFileId = persist_fid;\r\nreq->VolatileFileId = volatile_fid;\r\ncount = num_lock * sizeof(struct smb2_lock_element);\r\ninc_rfc1001_len(req, count - sizeof(struct smb2_lock_element));\r\niov[0].iov_base = (char *)req;\r\niov[0].iov_len = get_rfc1002_length(req) + 4 - count;\r\niov[1].iov_base = (char *)buf;\r\niov[1].iov_len = count;\r\ncifs_stats_inc(&tcon->stats.cifs_stats.num_locks);\r\nrc = SendReceive2(xid, tcon->ses, iov, 2, &resp_buf_type, CIFS_NO_RESP);\r\nif (rc) {\r\ncFYI(1, "Send error in smb2_lockv = %d", rc);\r\ncifs_stats_fail_inc(tcon, SMB2_LOCK_HE);\r\n}\r\nreturn rc;\r\n}\r\nint\r\nSMB2_lock(const unsigned int xid, struct cifs_tcon *tcon,\r\nconst __u64 persist_fid, const __u64 volatile_fid, const __u32 pid,\r\nconst __u64 length, const __u64 offset, const __u32 lock_flags,\r\nconst bool wait)\r\n{\r\nstruct smb2_lock_element lock;\r\nlock.Offset = cpu_to_le64(offset);\r\nlock.Length = cpu_to_le64(length);\r\nlock.Flags = cpu_to_le32(lock_flags);\r\nif (!wait && lock_flags != SMB2_LOCKFLAG_UNLOCK)\r\nlock.Flags |= cpu_to_le32(SMB2_LOCKFLAG_FAIL_IMMEDIATELY);\r\nreturn smb2_lockv(xid, tcon, persist_fid, volatile_fid, pid, 1, &lock);\r\n}\r\nint\r\nSMB2_lease_break(const unsigned int xid, struct cifs_tcon *tcon,\r\n__u8 *lease_key, const __le32 lease_state)\r\n{\r\nint rc;\r\nstruct smb2_lease_ack *req = NULL;\r\ncFYI(1, "SMB2_lease_break");\r\nrc = small_smb2_init(SMB2_OPLOCK_BREAK, tcon, (void **) &req);\r\nif (rc)\r\nreturn rc;\r\nreq->hdr.CreditRequest = cpu_to_le16(1);\r\nreq->StructureSize = cpu_to_le16(36);\r\ninc_rfc1001_len(req, 12);\r\nmemcpy(req->LeaseKey, lease_key, 16);\r\nreq->LeaseState = lease_state;\r\nrc = SendReceiveNoRsp(xid, tcon->ses, (char *) req, CIFS_OBREAK_OP);\r\nif (rc) {\r\ncifs_stats_fail_inc(tcon, SMB2_OPLOCK_BREAK_HE);\r\ncFYI(1, "Send error in Lease Break = %d", rc);\r\n}\r\nreturn rc;\r\n}
