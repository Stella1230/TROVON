static int get_error(const char *errorstring)\r\n{\r\nunsigned int i;\r\nfor (i = 0; strcmp(errorstring, xsd_errors[i].errstring) != 0; i++) {\r\nif (i == ARRAY_SIZE(xsd_errors) - 1) {\r\nprintk(KERN_WARNING\r\n"XENBUS xen store gave: unknown error %s",\r\nerrorstring);\r\nreturn EINVAL;\r\n}\r\n}\r\nreturn xsd_errors[i].errnum;\r\n}\r\nstatic void *read_reply(enum xsd_sockmsg_type *type, unsigned int *len)\r\n{\r\nstruct xs_stored_msg *msg;\r\nchar *body;\r\nspin_lock(&xs_state.reply_lock);\r\nwhile (list_empty(&xs_state.reply_list)) {\r\nspin_unlock(&xs_state.reply_lock);\r\nwait_event(xs_state.reply_waitq,\r\n!list_empty(&xs_state.reply_list));\r\nspin_lock(&xs_state.reply_lock);\r\n}\r\nmsg = list_entry(xs_state.reply_list.next,\r\nstruct xs_stored_msg, list);\r\nlist_del(&msg->list);\r\nspin_unlock(&xs_state.reply_lock);\r\n*type = msg->hdr.type;\r\nif (len)\r\n*len = msg->hdr.len;\r\nbody = msg->u.reply.body;\r\nkfree(msg);\r\nreturn body;\r\n}\r\nstatic void transaction_start(void)\r\n{\r\nmutex_lock(&xs_state.transaction_mutex);\r\natomic_inc(&xs_state.transaction_count);\r\nmutex_unlock(&xs_state.transaction_mutex);\r\n}\r\nstatic void transaction_end(void)\r\n{\r\nif (atomic_dec_and_test(&xs_state.transaction_count))\r\nwake_up(&xs_state.transaction_wq);\r\n}\r\nstatic void transaction_suspend(void)\r\n{\r\nmutex_lock(&xs_state.transaction_mutex);\r\nwait_event(xs_state.transaction_wq,\r\natomic_read(&xs_state.transaction_count) == 0);\r\n}\r\nstatic void transaction_resume(void)\r\n{\r\nmutex_unlock(&xs_state.transaction_mutex);\r\n}\r\nvoid *xenbus_dev_request_and_reply(struct xsd_sockmsg *msg)\r\n{\r\nvoid *ret;\r\nstruct xsd_sockmsg req_msg = *msg;\r\nint err;\r\nif (req_msg.type == XS_TRANSACTION_START)\r\ntransaction_start();\r\nmutex_lock(&xs_state.request_mutex);\r\nerr = xb_write(msg, sizeof(*msg) + msg->len);\r\nif (err) {\r\nmsg->type = XS_ERROR;\r\nret = ERR_PTR(err);\r\n} else\r\nret = read_reply(&msg->type, &msg->len);\r\nmutex_unlock(&xs_state.request_mutex);\r\nif ((msg->type == XS_TRANSACTION_END) ||\r\n((req_msg.type == XS_TRANSACTION_START) &&\r\n(msg->type == XS_ERROR)))\r\ntransaction_end();\r\nreturn ret;\r\n}\r\nstatic void *xs_talkv(struct xenbus_transaction t,\r\nenum xsd_sockmsg_type type,\r\nconst struct kvec *iovec,\r\nunsigned int num_vecs,\r\nunsigned int *len)\r\n{\r\nstruct xsd_sockmsg msg;\r\nvoid *ret = NULL;\r\nunsigned int i;\r\nint err;\r\nmsg.tx_id = t.id;\r\nmsg.req_id = 0;\r\nmsg.type = type;\r\nmsg.len = 0;\r\nfor (i = 0; i < num_vecs; i++)\r\nmsg.len += iovec[i].iov_len;\r\nmutex_lock(&xs_state.request_mutex);\r\nerr = xb_write(&msg, sizeof(msg));\r\nif (err) {\r\nmutex_unlock(&xs_state.request_mutex);\r\nreturn ERR_PTR(err);\r\n}\r\nfor (i = 0; i < num_vecs; i++) {\r\nerr = xb_write(iovec[i].iov_base, iovec[i].iov_len);\r\nif (err) {\r\nmutex_unlock(&xs_state.request_mutex);\r\nreturn ERR_PTR(err);\r\n}\r\n}\r\nret = read_reply(&msg.type, len);\r\nmutex_unlock(&xs_state.request_mutex);\r\nif (IS_ERR(ret))\r\nreturn ret;\r\nif (msg.type == XS_ERROR) {\r\nerr = get_error(ret);\r\nkfree(ret);\r\nreturn ERR_PTR(-err);\r\n}\r\nif (msg.type != type) {\r\nif (printk_ratelimit())\r\nprintk(KERN_WARNING\r\n"XENBUS unexpected type [%d], expected [%d]\n",\r\nmsg.type, type);\r\nkfree(ret);\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nreturn ret;\r\n}\r\nstatic void *xs_single(struct xenbus_transaction t,\r\nenum xsd_sockmsg_type type,\r\nconst char *string,\r\nunsigned int *len)\r\n{\r\nstruct kvec iovec;\r\niovec.iov_base = (void *)string;\r\niovec.iov_len = strlen(string) + 1;\r\nreturn xs_talkv(t, type, &iovec, 1, len);\r\n}\r\nstatic int xs_error(char *reply)\r\n{\r\nif (IS_ERR(reply))\r\nreturn PTR_ERR(reply);\r\nkfree(reply);\r\nreturn 0;\r\n}\r\nstatic unsigned int count_strings(const char *strings, unsigned int len)\r\n{\r\nunsigned int num;\r\nconst char *p;\r\nfor (p = strings, num = 0; p < strings + len; p += strlen(p) + 1)\r\nnum++;\r\nreturn num;\r\n}\r\nstatic char *join(const char *dir, const char *name)\r\n{\r\nchar *buffer;\r\nif (strlen(name) == 0)\r\nbuffer = kasprintf(GFP_NOIO | __GFP_HIGH, "%s", dir);\r\nelse\r\nbuffer = kasprintf(GFP_NOIO | __GFP_HIGH, "%s/%s", dir, name);\r\nreturn (!buffer) ? ERR_PTR(-ENOMEM) : buffer;\r\n}\r\nstatic char **split(char *strings, unsigned int len, unsigned int *num)\r\n{\r\nchar *p, **ret;\r\n*num = count_strings(strings, len);\r\nret = kmalloc(*num * sizeof(char *) + len, GFP_NOIO | __GFP_HIGH);\r\nif (!ret) {\r\nkfree(strings);\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nmemcpy(&ret[*num], strings, len);\r\nkfree(strings);\r\nstrings = (char *)&ret[*num];\r\nfor (p = strings, *num = 0; p < strings + len; p += strlen(p) + 1)\r\nret[(*num)++] = p;\r\nreturn ret;\r\n}\r\nchar **xenbus_directory(struct xenbus_transaction t,\r\nconst char *dir, const char *node, unsigned int *num)\r\n{\r\nchar *strings, *path;\r\nunsigned int len;\r\npath = join(dir, node);\r\nif (IS_ERR(path))\r\nreturn (char **)path;\r\nstrings = xs_single(t, XS_DIRECTORY, path, &len);\r\nkfree(path);\r\nif (IS_ERR(strings))\r\nreturn (char **)strings;\r\nreturn split(strings, len, num);\r\n}\r\nint xenbus_exists(struct xenbus_transaction t,\r\nconst char *dir, const char *node)\r\n{\r\nchar **d;\r\nint dir_n;\r\nd = xenbus_directory(t, dir, node, &dir_n);\r\nif (IS_ERR(d))\r\nreturn 0;\r\nkfree(d);\r\nreturn 1;\r\n}\r\nvoid *xenbus_read(struct xenbus_transaction t,\r\nconst char *dir, const char *node, unsigned int *len)\r\n{\r\nchar *path;\r\nvoid *ret;\r\npath = join(dir, node);\r\nif (IS_ERR(path))\r\nreturn (void *)path;\r\nret = xs_single(t, XS_READ, path, len);\r\nkfree(path);\r\nreturn ret;\r\n}\r\nint xenbus_write(struct xenbus_transaction t,\r\nconst char *dir, const char *node, const char *string)\r\n{\r\nconst char *path;\r\nstruct kvec iovec[2];\r\nint ret;\r\npath = join(dir, node);\r\nif (IS_ERR(path))\r\nreturn PTR_ERR(path);\r\niovec[0].iov_base = (void *)path;\r\niovec[0].iov_len = strlen(path) + 1;\r\niovec[1].iov_base = (void *)string;\r\niovec[1].iov_len = strlen(string);\r\nret = xs_error(xs_talkv(t, XS_WRITE, iovec, ARRAY_SIZE(iovec), NULL));\r\nkfree(path);\r\nreturn ret;\r\n}\r\nint xenbus_mkdir(struct xenbus_transaction t,\r\nconst char *dir, const char *node)\r\n{\r\nchar *path;\r\nint ret;\r\npath = join(dir, node);\r\nif (IS_ERR(path))\r\nreturn PTR_ERR(path);\r\nret = xs_error(xs_single(t, XS_MKDIR, path, NULL));\r\nkfree(path);\r\nreturn ret;\r\n}\r\nint xenbus_rm(struct xenbus_transaction t, const char *dir, const char *node)\r\n{\r\nchar *path;\r\nint ret;\r\npath = join(dir, node);\r\nif (IS_ERR(path))\r\nreturn PTR_ERR(path);\r\nret = xs_error(xs_single(t, XS_RM, path, NULL));\r\nkfree(path);\r\nreturn ret;\r\n}\r\nint xenbus_transaction_start(struct xenbus_transaction *t)\r\n{\r\nchar *id_str;\r\ntransaction_start();\r\nid_str = xs_single(XBT_NIL, XS_TRANSACTION_START, "", NULL);\r\nif (IS_ERR(id_str)) {\r\ntransaction_end();\r\nreturn PTR_ERR(id_str);\r\n}\r\nt->id = simple_strtoul(id_str, NULL, 0);\r\nkfree(id_str);\r\nreturn 0;\r\n}\r\nint xenbus_transaction_end(struct xenbus_transaction t, int abort)\r\n{\r\nchar abortstr[2];\r\nint err;\r\nif (abort)\r\nstrcpy(abortstr, "F");\r\nelse\r\nstrcpy(abortstr, "T");\r\nerr = xs_error(xs_single(t, XS_TRANSACTION_END, abortstr, NULL));\r\ntransaction_end();\r\nreturn err;\r\n}\r\nint xenbus_scanf(struct xenbus_transaction t,\r\nconst char *dir, const char *node, const char *fmt, ...)\r\n{\r\nva_list ap;\r\nint ret;\r\nchar *val;\r\nval = xenbus_read(t, dir, node, NULL);\r\nif (IS_ERR(val))\r\nreturn PTR_ERR(val);\r\nva_start(ap, fmt);\r\nret = vsscanf(val, fmt, ap);\r\nva_end(ap);\r\nkfree(val);\r\nif (ret == 0)\r\nreturn -ERANGE;\r\nreturn ret;\r\n}\r\nint xenbus_printf(struct xenbus_transaction t,\r\nconst char *dir, const char *node, const char *fmt, ...)\r\n{\r\nva_list ap;\r\nint ret;\r\nchar *buf;\r\nva_start(ap, fmt);\r\nbuf = kvasprintf(GFP_NOIO | __GFP_HIGH, fmt, ap);\r\nva_end(ap);\r\nif (!buf)\r\nreturn -ENOMEM;\r\nret = xenbus_write(t, dir, node, buf);\r\nkfree(buf);\r\nreturn ret;\r\n}\r\nint xenbus_gather(struct xenbus_transaction t, const char *dir, ...)\r\n{\r\nva_list ap;\r\nconst char *name;\r\nint ret = 0;\r\nva_start(ap, dir);\r\nwhile (ret == 0 && (name = va_arg(ap, char *)) != NULL) {\r\nconst char *fmt = va_arg(ap, char *);\r\nvoid *result = va_arg(ap, void *);\r\nchar *p;\r\np = xenbus_read(t, dir, name, NULL);\r\nif (IS_ERR(p)) {\r\nret = PTR_ERR(p);\r\nbreak;\r\n}\r\nif (fmt) {\r\nif (sscanf(p, fmt, result) == 0)\r\nret = -EINVAL;\r\nkfree(p);\r\n} else\r\n*(char **)result = p;\r\n}\r\nva_end(ap);\r\nreturn ret;\r\n}\r\nstatic int xs_watch(const char *path, const char *token)\r\n{\r\nstruct kvec iov[2];\r\niov[0].iov_base = (void *)path;\r\niov[0].iov_len = strlen(path) + 1;\r\niov[1].iov_base = (void *)token;\r\niov[1].iov_len = strlen(token) + 1;\r\nreturn xs_error(xs_talkv(XBT_NIL, XS_WATCH, iov,\r\nARRAY_SIZE(iov), NULL));\r\n}\r\nstatic int xs_unwatch(const char *path, const char *token)\r\n{\r\nstruct kvec iov[2];\r\niov[0].iov_base = (char *)path;\r\niov[0].iov_len = strlen(path) + 1;\r\niov[1].iov_base = (char *)token;\r\niov[1].iov_len = strlen(token) + 1;\r\nreturn xs_error(xs_talkv(XBT_NIL, XS_UNWATCH, iov,\r\nARRAY_SIZE(iov), NULL));\r\n}\r\nstatic struct xenbus_watch *find_watch(const char *token)\r\n{\r\nstruct xenbus_watch *i, *cmp;\r\ncmp = (void *)simple_strtoul(token, NULL, 16);\r\nlist_for_each_entry(i, &watches, list)\r\nif (i == cmp)\r\nreturn i;\r\nreturn NULL;\r\n}\r\nstatic bool xen_strict_xenbus_quirk(void)\r\n{\r\n#ifdef CONFIG_X86\r\nuint32_t eax, ebx, ecx, edx, base;\r\nbase = xen_cpuid_base();\r\ncpuid(base + 1, &eax, &ebx, &ecx, &edx);\r\nif ((eax >> 16) < 4)\r\nreturn true;\r\n#endif\r\nreturn false;\r\n}\r\nstatic void xs_reset_watches(void)\r\n{\r\nint err, supported = 0;\r\nif (!xen_hvm_domain() || xen_initial_domain())\r\nreturn;\r\nif (xen_strict_xenbus_quirk())\r\nreturn;\r\nerr = xenbus_scanf(XBT_NIL, "control",\r\n"platform-feature-xs_reset_watches", "%d", &supported);\r\nif (err != 1 || !supported)\r\nreturn;\r\nerr = xs_error(xs_single(XBT_NIL, XS_RESET_WATCHES, "", NULL));\r\nif (err && err != -EEXIST)\r\nprintk(KERN_WARNING "xs_reset_watches failed: %d\n", err);\r\n}\r\nint register_xenbus_watch(struct xenbus_watch *watch)\r\n{\r\nchar token[sizeof(watch) * 2 + 1];\r\nint err;\r\nsprintf(token, "%lX", (long)watch);\r\ndown_read(&xs_state.watch_mutex);\r\nspin_lock(&watches_lock);\r\nBUG_ON(find_watch(token));\r\nlist_add(&watch->list, &watches);\r\nspin_unlock(&watches_lock);\r\nerr = xs_watch(watch->node, token);\r\nif (err) {\r\nspin_lock(&watches_lock);\r\nlist_del(&watch->list);\r\nspin_unlock(&watches_lock);\r\n}\r\nup_read(&xs_state.watch_mutex);\r\nreturn err;\r\n}\r\nvoid unregister_xenbus_watch(struct xenbus_watch *watch)\r\n{\r\nstruct xs_stored_msg *msg, *tmp;\r\nchar token[sizeof(watch) * 2 + 1];\r\nint err;\r\nsprintf(token, "%lX", (long)watch);\r\ndown_read(&xs_state.watch_mutex);\r\nspin_lock(&watches_lock);\r\nBUG_ON(!find_watch(token));\r\nlist_del(&watch->list);\r\nspin_unlock(&watches_lock);\r\nerr = xs_unwatch(watch->node, token);\r\nif (err)\r\nprintk(KERN_WARNING\r\n"XENBUS Failed to release watch %s: %i\n",\r\nwatch->node, err);\r\nup_read(&xs_state.watch_mutex);\r\nif (current->pid != xenwatch_pid)\r\nmutex_lock(&xenwatch_mutex);\r\nspin_lock(&watch_events_lock);\r\nlist_for_each_entry_safe(msg, tmp, &watch_events, list) {\r\nif (msg->u.watch.handle != watch)\r\ncontinue;\r\nlist_del(&msg->list);\r\nkfree(msg->u.watch.vec);\r\nkfree(msg);\r\n}\r\nspin_unlock(&watch_events_lock);\r\nif (current->pid != xenwatch_pid)\r\nmutex_unlock(&xenwatch_mutex);\r\n}\r\nvoid xs_suspend(void)\r\n{\r\ntransaction_suspend();\r\ndown_write(&xs_state.watch_mutex);\r\nmutex_lock(&xs_state.request_mutex);\r\nmutex_lock(&xs_state.response_mutex);\r\n}\r\nvoid xs_resume(void)\r\n{\r\nstruct xenbus_watch *watch;\r\nchar token[sizeof(watch) * 2 + 1];\r\nxb_init_comms();\r\nmutex_unlock(&xs_state.response_mutex);\r\nmutex_unlock(&xs_state.request_mutex);\r\ntransaction_resume();\r\nlist_for_each_entry(watch, &watches, list) {\r\nsprintf(token, "%lX", (long)watch);\r\nxs_watch(watch->node, token);\r\n}\r\nup_write(&xs_state.watch_mutex);\r\n}\r\nvoid xs_suspend_cancel(void)\r\n{\r\nmutex_unlock(&xs_state.response_mutex);\r\nmutex_unlock(&xs_state.request_mutex);\r\nup_write(&xs_state.watch_mutex);\r\nmutex_unlock(&xs_state.transaction_mutex);\r\n}\r\nstatic int xenwatch_thread(void *unused)\r\n{\r\nstruct list_head *ent;\r\nstruct xs_stored_msg *msg;\r\nfor (;;) {\r\nwait_event_interruptible(watch_events_waitq,\r\n!list_empty(&watch_events));\r\nif (kthread_should_stop())\r\nbreak;\r\nmutex_lock(&xenwatch_mutex);\r\nspin_lock(&watch_events_lock);\r\nent = watch_events.next;\r\nif (ent != &watch_events)\r\nlist_del(ent);\r\nspin_unlock(&watch_events_lock);\r\nif (ent != &watch_events) {\r\nmsg = list_entry(ent, struct xs_stored_msg, list);\r\nmsg->u.watch.handle->callback(\r\nmsg->u.watch.handle,\r\n(const char **)msg->u.watch.vec,\r\nmsg->u.watch.vec_size);\r\nkfree(msg->u.watch.vec);\r\nkfree(msg);\r\n}\r\nmutex_unlock(&xenwatch_mutex);\r\n}\r\nreturn 0;\r\n}\r\nstatic int process_msg(void)\r\n{\r\nstruct xs_stored_msg *msg;\r\nchar *body;\r\nint err;\r\nfor (;;) {\r\nerr = xb_wait_for_data_to_read();\r\nif (err)\r\nreturn err;\r\nmutex_lock(&xs_state.response_mutex);\r\nif (xb_data_to_read())\r\nbreak;\r\nmutex_unlock(&xs_state.response_mutex);\r\n}\r\nmsg = kmalloc(sizeof(*msg), GFP_NOIO | __GFP_HIGH);\r\nif (msg == NULL) {\r\nerr = -ENOMEM;\r\ngoto out;\r\n}\r\nerr = xb_read(&msg->hdr, sizeof(msg->hdr));\r\nif (err) {\r\nkfree(msg);\r\ngoto out;\r\n}\r\nif (msg->hdr.len > XENSTORE_PAYLOAD_MAX) {\r\nkfree(msg);\r\nerr = -EINVAL;\r\ngoto out;\r\n}\r\nbody = kmalloc(msg->hdr.len + 1, GFP_NOIO | __GFP_HIGH);\r\nif (body == NULL) {\r\nkfree(msg);\r\nerr = -ENOMEM;\r\ngoto out;\r\n}\r\nerr = xb_read(body, msg->hdr.len);\r\nif (err) {\r\nkfree(body);\r\nkfree(msg);\r\ngoto out;\r\n}\r\nbody[msg->hdr.len] = '\0';\r\nif (msg->hdr.type == XS_WATCH_EVENT) {\r\nmsg->u.watch.vec = split(body, msg->hdr.len,\r\n&msg->u.watch.vec_size);\r\nif (IS_ERR(msg->u.watch.vec)) {\r\nerr = PTR_ERR(msg->u.watch.vec);\r\nkfree(msg);\r\ngoto out;\r\n}\r\nspin_lock(&watches_lock);\r\nmsg->u.watch.handle = find_watch(\r\nmsg->u.watch.vec[XS_WATCH_TOKEN]);\r\nif (msg->u.watch.handle != NULL) {\r\nspin_lock(&watch_events_lock);\r\nlist_add_tail(&msg->list, &watch_events);\r\nwake_up(&watch_events_waitq);\r\nspin_unlock(&watch_events_lock);\r\n} else {\r\nkfree(msg->u.watch.vec);\r\nkfree(msg);\r\n}\r\nspin_unlock(&watches_lock);\r\n} else {\r\nmsg->u.reply.body = body;\r\nspin_lock(&xs_state.reply_lock);\r\nlist_add_tail(&msg->list, &xs_state.reply_list);\r\nspin_unlock(&xs_state.reply_lock);\r\nwake_up(&xs_state.reply_waitq);\r\n}\r\nout:\r\nmutex_unlock(&xs_state.response_mutex);\r\nreturn err;\r\n}\r\nstatic int xenbus_thread(void *unused)\r\n{\r\nint err;\r\nfor (;;) {\r\nerr = process_msg();\r\nif (err)\r\nprintk(KERN_WARNING "XENBUS error %d while reading "\r\n"message\n", err);\r\nif (kthread_should_stop())\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nint xs_init(void)\r\n{\r\nint err;\r\nstruct task_struct *task;\r\nINIT_LIST_HEAD(&xs_state.reply_list);\r\nspin_lock_init(&xs_state.reply_lock);\r\ninit_waitqueue_head(&xs_state.reply_waitq);\r\nmutex_init(&xs_state.request_mutex);\r\nmutex_init(&xs_state.response_mutex);\r\nmutex_init(&xs_state.transaction_mutex);\r\ninit_rwsem(&xs_state.watch_mutex);\r\natomic_set(&xs_state.transaction_count, 0);\r\ninit_waitqueue_head(&xs_state.transaction_wq);\r\nerr = xb_init_comms();\r\nif (err)\r\nreturn err;\r\ntask = kthread_run(xenwatch_thread, NULL, "xenwatch");\r\nif (IS_ERR(task))\r\nreturn PTR_ERR(task);\r\nxenwatch_pid = task->pid;\r\ntask = kthread_run(xenbus_thread, NULL, "xenbus");\r\nif (IS_ERR(task))\r\nreturn PTR_ERR(task);\r\nxs_reset_watches();\r\nreturn 0;\r\n}
