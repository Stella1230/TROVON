static inline u32 get_u32(u64 data, int index)\r\n{\r\nreturn ((u32 *)&data)[index];\r\n}\r\nu32 seccomp_bpf_load(int off)\r\n{\r\nstruct pt_regs *regs = task_pt_regs(current);\r\nif (off == BPF_DATA(nr))\r\nreturn syscall_get_nr(current, regs);\r\nif (off == BPF_DATA(arch))\r\nreturn syscall_get_arch(current, regs);\r\nif (off >= BPF_DATA(args[0]) && off < BPF_DATA(args[6])) {\r\nunsigned long value;\r\nint arg = (off - BPF_DATA(args[0])) / sizeof(u64);\r\nint index = !!(off % sizeof(u64));\r\nsyscall_get_arguments(current, regs, arg, 1, &value);\r\nreturn get_u32(value, index);\r\n}\r\nif (off == BPF_DATA(instruction_pointer))\r\nreturn get_u32(KSTK_EIP(current), 0);\r\nif (off == BPF_DATA(instruction_pointer) + sizeof(u32))\r\nreturn get_u32(KSTK_EIP(current), 1);\r\nBUG();\r\n}\r\nstatic int seccomp_check_filter(struct sock_filter *filter, unsigned int flen)\r\n{\r\nint pc;\r\nfor (pc = 0; pc < flen; pc++) {\r\nstruct sock_filter *ftest = &filter[pc];\r\nu16 code = ftest->code;\r\nu32 k = ftest->k;\r\nswitch (code) {\r\ncase BPF_S_LD_W_ABS:\r\nftest->code = BPF_S_ANC_SECCOMP_LD_W;\r\nif (k >= sizeof(struct seccomp_data) || k & 3)\r\nreturn -EINVAL;\r\ncontinue;\r\ncase BPF_S_LD_W_LEN:\r\nftest->code = BPF_S_LD_IMM;\r\nftest->k = sizeof(struct seccomp_data);\r\ncontinue;\r\ncase BPF_S_LDX_W_LEN:\r\nftest->code = BPF_S_LDX_IMM;\r\nftest->k = sizeof(struct seccomp_data);\r\ncontinue;\r\ncase BPF_S_RET_K:\r\ncase BPF_S_RET_A:\r\ncase BPF_S_ALU_ADD_K:\r\ncase BPF_S_ALU_ADD_X:\r\ncase BPF_S_ALU_SUB_K:\r\ncase BPF_S_ALU_SUB_X:\r\ncase BPF_S_ALU_MUL_K:\r\ncase BPF_S_ALU_MUL_X:\r\ncase BPF_S_ALU_DIV_X:\r\ncase BPF_S_ALU_AND_K:\r\ncase BPF_S_ALU_AND_X:\r\ncase BPF_S_ALU_OR_K:\r\ncase BPF_S_ALU_OR_X:\r\ncase BPF_S_ALU_LSH_K:\r\ncase BPF_S_ALU_LSH_X:\r\ncase BPF_S_ALU_RSH_K:\r\ncase BPF_S_ALU_RSH_X:\r\ncase BPF_S_ALU_NEG:\r\ncase BPF_S_LD_IMM:\r\ncase BPF_S_LDX_IMM:\r\ncase BPF_S_MISC_TAX:\r\ncase BPF_S_MISC_TXA:\r\ncase BPF_S_ALU_DIV_K:\r\ncase BPF_S_LD_MEM:\r\ncase BPF_S_LDX_MEM:\r\ncase BPF_S_ST:\r\ncase BPF_S_STX:\r\ncase BPF_S_JMP_JA:\r\ncase BPF_S_JMP_JEQ_K:\r\ncase BPF_S_JMP_JEQ_X:\r\ncase BPF_S_JMP_JGE_K:\r\ncase BPF_S_JMP_JGE_X:\r\ncase BPF_S_JMP_JGT_K:\r\ncase BPF_S_JMP_JGT_X:\r\ncase BPF_S_JMP_JSET_K:\r\ncase BPF_S_JMP_JSET_X:\r\ncontinue;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic u32 seccomp_run_filters(int syscall)\r\n{\r\nstruct seccomp_filter *f;\r\nu32 ret = SECCOMP_RET_ALLOW;\r\nif (WARN_ON(current->seccomp.filter == NULL))\r\nreturn SECCOMP_RET_KILL;\r\nfor (f = current->seccomp.filter; f; f = f->prev) {\r\nu32 cur_ret = sk_run_filter(NULL, f->insns);\r\nif ((cur_ret & SECCOMP_RET_ACTION) < (ret & SECCOMP_RET_ACTION))\r\nret = cur_ret;\r\n}\r\nreturn ret;\r\n}\r\nstatic long seccomp_attach_filter(struct sock_fprog *fprog)\r\n{\r\nstruct seccomp_filter *filter;\r\nunsigned long fp_size = fprog->len * sizeof(struct sock_filter);\r\nunsigned long total_insns = fprog->len;\r\nlong ret;\r\nif (fprog->len == 0 || fprog->len > BPF_MAXINSNS)\r\nreturn -EINVAL;\r\nfor (filter = current->seccomp.filter; filter; filter = filter->prev)\r\ntotal_insns += filter->len + 4;\r\nif (total_insns > MAX_INSNS_PER_PATH)\r\nreturn -ENOMEM;\r\nif (!current->no_new_privs &&\r\nsecurity_capable_noaudit(current_cred(), current_user_ns(),\r\nCAP_SYS_ADMIN) != 0)\r\nreturn -EACCES;\r\nfilter = kzalloc(sizeof(struct seccomp_filter) + fp_size,\r\nGFP_KERNEL|__GFP_NOWARN);\r\nif (!filter)\r\nreturn -ENOMEM;\r\natomic_set(&filter->usage, 1);\r\nfilter->len = fprog->len;\r\nret = -EFAULT;\r\nif (copy_from_user(filter->insns, fprog->filter, fp_size))\r\ngoto fail;\r\nret = sk_chk_filter(filter->insns, filter->len);\r\nif (ret)\r\ngoto fail;\r\nret = seccomp_check_filter(filter->insns, filter->len);\r\nif (ret)\r\ngoto fail;\r\nfilter->prev = current->seccomp.filter;\r\ncurrent->seccomp.filter = filter;\r\nreturn 0;\r\nfail:\r\nkfree(filter);\r\nreturn ret;\r\n}\r\nlong seccomp_attach_user_filter(char __user *user_filter)\r\n{\r\nstruct sock_fprog fprog;\r\nlong ret = -EFAULT;\r\n#ifdef CONFIG_COMPAT\r\nif (is_compat_task()) {\r\nstruct compat_sock_fprog fprog32;\r\nif (copy_from_user(&fprog32, user_filter, sizeof(fprog32)))\r\ngoto out;\r\nfprog.len = fprog32.len;\r\nfprog.filter = compat_ptr(fprog32.filter);\r\n} else\r\n#endif\r\nif (copy_from_user(&fprog, user_filter, sizeof(fprog)))\r\ngoto out;\r\nret = seccomp_attach_filter(&fprog);\r\nout:\r\nreturn ret;\r\n}\r\nvoid get_seccomp_filter(struct task_struct *tsk)\r\n{\r\nstruct seccomp_filter *orig = tsk->seccomp.filter;\r\nif (!orig)\r\nreturn;\r\natomic_inc(&orig->usage);\r\n}\r\nvoid put_seccomp_filter(struct task_struct *tsk)\r\n{\r\nstruct seccomp_filter *orig = tsk->seccomp.filter;\r\nwhile (orig && atomic_dec_and_test(&orig->usage)) {\r\nstruct seccomp_filter *freeme = orig;\r\norig = orig->prev;\r\nkfree(freeme);\r\n}\r\n}\r\nstatic void seccomp_send_sigsys(int syscall, int reason)\r\n{\r\nstruct siginfo info;\r\nmemset(&info, 0, sizeof(info));\r\ninfo.si_signo = SIGSYS;\r\ninfo.si_code = SYS_SECCOMP;\r\ninfo.si_call_addr = (void __user *)KSTK_EIP(current);\r\ninfo.si_errno = reason;\r\ninfo.si_arch = syscall_get_arch(current, task_pt_regs(current));\r\ninfo.si_syscall = syscall;\r\nforce_sig_info(SIGSYS, &info, current);\r\n}\r\nint __secure_computing(int this_syscall)\r\n{\r\nint mode = current->seccomp.mode;\r\nint exit_sig = 0;\r\nint *syscall;\r\nu32 ret;\r\nswitch (mode) {\r\ncase SECCOMP_MODE_STRICT:\r\nsyscall = mode1_syscalls;\r\n#ifdef CONFIG_COMPAT\r\nif (is_compat_task())\r\nsyscall = mode1_syscalls_32;\r\n#endif\r\ndo {\r\nif (*syscall == this_syscall)\r\nreturn 0;\r\n} while (*++syscall);\r\nexit_sig = SIGKILL;\r\nret = SECCOMP_RET_KILL;\r\nbreak;\r\n#ifdef CONFIG_SECCOMP_FILTER\r\ncase SECCOMP_MODE_FILTER: {\r\nint data;\r\nstruct pt_regs *regs = task_pt_regs(current);\r\nret = seccomp_run_filters(this_syscall);\r\ndata = ret & SECCOMP_RET_DATA;\r\nret &= SECCOMP_RET_ACTION;\r\nswitch (ret) {\r\ncase SECCOMP_RET_ERRNO:\r\nsyscall_set_return_value(current, regs,\r\n-data, 0);\r\ngoto skip;\r\ncase SECCOMP_RET_TRAP:\r\nsyscall_rollback(current, regs);\r\nseccomp_send_sigsys(this_syscall, data);\r\ngoto skip;\r\ncase SECCOMP_RET_TRACE:\r\nif (!ptrace_event_enabled(current, PTRACE_EVENT_SECCOMP)) {\r\nsyscall_set_return_value(current, regs,\r\n-ENOSYS, 0);\r\ngoto skip;\r\n}\r\nptrace_event(PTRACE_EVENT_SECCOMP, data);\r\nif (fatal_signal_pending(current))\r\nbreak;\r\nif (syscall_get_nr(current, regs) < 0)\r\ngoto skip;\r\nreturn 0;\r\ncase SECCOMP_RET_ALLOW:\r\nreturn 0;\r\ncase SECCOMP_RET_KILL:\r\ndefault:\r\nbreak;\r\n}\r\nexit_sig = SIGSYS;\r\nbreak;\r\n}\r\n#endif\r\ndefault:\r\nBUG();\r\n}\r\n#ifdef SECCOMP_DEBUG\r\ndump_stack();\r\n#endif\r\naudit_seccomp(this_syscall, exit_sig, ret);\r\ndo_exit(exit_sig);\r\n#ifdef CONFIG_SECCOMP_FILTER\r\nskip:\r\naudit_seccomp(this_syscall, exit_sig, ret);\r\n#endif\r\nreturn -1;\r\n}\r\nlong prctl_get_seccomp(void)\r\n{\r\nreturn current->seccomp.mode;\r\n}\r\nlong prctl_set_seccomp(unsigned long seccomp_mode, char __user *filter)\r\n{\r\nlong ret = -EINVAL;\r\nif (current->seccomp.mode &&\r\ncurrent->seccomp.mode != seccomp_mode)\r\ngoto out;\r\nswitch (seccomp_mode) {\r\ncase SECCOMP_MODE_STRICT:\r\nret = 0;\r\n#ifdef TIF_NOTSC\r\ndisable_TSC();\r\n#endif\r\nbreak;\r\n#ifdef CONFIG_SECCOMP_FILTER\r\ncase SECCOMP_MODE_FILTER:\r\nret = seccomp_attach_user_filter(filter);\r\nif (ret)\r\ngoto out;\r\nbreak;\r\n#endif\r\ndefault:\r\ngoto out;\r\n}\r\ncurrent->seccomp.mode = seccomp_mode;\r\nset_thread_flag(TIF_SECCOMP);\r\nout:\r\nreturn ret;\r\n}
