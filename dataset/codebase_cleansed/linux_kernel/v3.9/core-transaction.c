static int try_cancel_split_timeout(struct fw_transaction *t)\r\n{\r\nif (t->is_split_transaction)\r\nreturn del_timer(&t->split_timeout_timer);\r\nelse\r\nreturn 1;\r\n}\r\nstatic int close_transaction(struct fw_transaction *transaction,\r\nstruct fw_card *card, int rcode)\r\n{\r\nstruct fw_transaction *t;\r\nunsigned long flags;\r\nspin_lock_irqsave(&card->lock, flags);\r\nlist_for_each_entry(t, &card->transaction_list, link) {\r\nif (t == transaction) {\r\nif (!try_cancel_split_timeout(t)) {\r\nspin_unlock_irqrestore(&card->lock, flags);\r\ngoto timed_out;\r\n}\r\nlist_del_init(&t->link);\r\ncard->tlabel_mask &= ~(1ULL << t->tlabel);\r\nbreak;\r\n}\r\n}\r\nspin_unlock_irqrestore(&card->lock, flags);\r\nif (&t->link != &card->transaction_list) {\r\nt->callback(card, rcode, NULL, 0, t->callback_data);\r\nreturn 0;\r\n}\r\ntimed_out:\r\nreturn -ENOENT;\r\n}\r\nint fw_cancel_transaction(struct fw_card *card,\r\nstruct fw_transaction *transaction)\r\n{\r\nif (card->driver->cancel_packet(card, &transaction->packet) == 0)\r\nreturn 0;\r\nreturn close_transaction(transaction, card, RCODE_CANCELLED);\r\n}\r\nstatic void split_transaction_timeout_callback(unsigned long data)\r\n{\r\nstruct fw_transaction *t = (struct fw_transaction *)data;\r\nstruct fw_card *card = t->card;\r\nunsigned long flags;\r\nspin_lock_irqsave(&card->lock, flags);\r\nif (list_empty(&t->link)) {\r\nspin_unlock_irqrestore(&card->lock, flags);\r\nreturn;\r\n}\r\nlist_del(&t->link);\r\ncard->tlabel_mask &= ~(1ULL << t->tlabel);\r\nspin_unlock_irqrestore(&card->lock, flags);\r\nt->callback(card, RCODE_CANCELLED, NULL, 0, t->callback_data);\r\n}\r\nstatic void start_split_transaction_timeout(struct fw_transaction *t,\r\nstruct fw_card *card)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&card->lock, flags);\r\nif (list_empty(&t->link) || WARN_ON(t->is_split_transaction)) {\r\nspin_unlock_irqrestore(&card->lock, flags);\r\nreturn;\r\n}\r\nt->is_split_transaction = true;\r\nmod_timer(&t->split_timeout_timer,\r\njiffies + card->split_timeout_jiffies);\r\nspin_unlock_irqrestore(&card->lock, flags);\r\n}\r\nstatic void transmit_complete_callback(struct fw_packet *packet,\r\nstruct fw_card *card, int status)\r\n{\r\nstruct fw_transaction *t =\r\ncontainer_of(packet, struct fw_transaction, packet);\r\nswitch (status) {\r\ncase ACK_COMPLETE:\r\nclose_transaction(t, card, RCODE_COMPLETE);\r\nbreak;\r\ncase ACK_PENDING:\r\nstart_split_transaction_timeout(t, card);\r\nbreak;\r\ncase ACK_BUSY_X:\r\ncase ACK_BUSY_A:\r\ncase ACK_BUSY_B:\r\nclose_transaction(t, card, RCODE_BUSY);\r\nbreak;\r\ncase ACK_DATA_ERROR:\r\nclose_transaction(t, card, RCODE_DATA_ERROR);\r\nbreak;\r\ncase ACK_TYPE_ERROR:\r\nclose_transaction(t, card, RCODE_TYPE_ERROR);\r\nbreak;\r\ndefault:\r\nclose_transaction(t, card, status);\r\nbreak;\r\n}\r\n}\r\nstatic void fw_fill_request(struct fw_packet *packet, int tcode, int tlabel,\r\nint destination_id, int source_id, int generation, int speed,\r\nunsigned long long offset, void *payload, size_t length)\r\n{\r\nint ext_tcode;\r\nif (tcode == TCODE_STREAM_DATA) {\r\npacket->header[0] =\r\nHEADER_DATA_LENGTH(length) |\r\ndestination_id |\r\nHEADER_TCODE(TCODE_STREAM_DATA);\r\npacket->header_length = 4;\r\npacket->payload = payload;\r\npacket->payload_length = length;\r\ngoto common;\r\n}\r\nif (tcode > 0x10) {\r\next_tcode = tcode & ~0x10;\r\ntcode = TCODE_LOCK_REQUEST;\r\n} else\r\next_tcode = 0;\r\npacket->header[0] =\r\nHEADER_RETRY(RETRY_X) |\r\nHEADER_TLABEL(tlabel) |\r\nHEADER_TCODE(tcode) |\r\nHEADER_DESTINATION(destination_id);\r\npacket->header[1] =\r\nHEADER_OFFSET_HIGH(offset >> 32) | HEADER_SOURCE(source_id);\r\npacket->header[2] =\r\noffset;\r\nswitch (tcode) {\r\ncase TCODE_WRITE_QUADLET_REQUEST:\r\npacket->header[3] = *(u32 *)payload;\r\npacket->header_length = 16;\r\npacket->payload_length = 0;\r\nbreak;\r\ncase TCODE_LOCK_REQUEST:\r\ncase TCODE_WRITE_BLOCK_REQUEST:\r\npacket->header[3] =\r\nHEADER_DATA_LENGTH(length) |\r\nHEADER_EXTENDED_TCODE(ext_tcode);\r\npacket->header_length = 16;\r\npacket->payload = payload;\r\npacket->payload_length = length;\r\nbreak;\r\ncase TCODE_READ_QUADLET_REQUEST:\r\npacket->header_length = 12;\r\npacket->payload_length = 0;\r\nbreak;\r\ncase TCODE_READ_BLOCK_REQUEST:\r\npacket->header[3] =\r\nHEADER_DATA_LENGTH(length) |\r\nHEADER_EXTENDED_TCODE(ext_tcode);\r\npacket->header_length = 16;\r\npacket->payload_length = 0;\r\nbreak;\r\ndefault:\r\nWARN(1, "wrong tcode %d\n", tcode);\r\n}\r\ncommon:\r\npacket->speed = speed;\r\npacket->generation = generation;\r\npacket->ack = 0;\r\npacket->payload_mapped = false;\r\n}\r\nstatic int allocate_tlabel(struct fw_card *card)\r\n{\r\nint tlabel;\r\ntlabel = card->current_tlabel;\r\nwhile (card->tlabel_mask & (1ULL << tlabel)) {\r\ntlabel = (tlabel + 1) & 0x3f;\r\nif (tlabel == card->current_tlabel)\r\nreturn -EBUSY;\r\n}\r\ncard->current_tlabel = (tlabel + 1) & 0x3f;\r\ncard->tlabel_mask |= 1ULL << tlabel;\r\nreturn tlabel;\r\n}\r\nvoid fw_send_request(struct fw_card *card, struct fw_transaction *t, int tcode,\r\nint destination_id, int generation, int speed,\r\nunsigned long long offset, void *payload, size_t length,\r\nfw_transaction_callback_t callback, void *callback_data)\r\n{\r\nunsigned long flags;\r\nint tlabel;\r\nspin_lock_irqsave(&card->lock, flags);\r\ntlabel = allocate_tlabel(card);\r\nif (tlabel < 0) {\r\nspin_unlock_irqrestore(&card->lock, flags);\r\ncallback(card, RCODE_SEND_ERROR, NULL, 0, callback_data);\r\nreturn;\r\n}\r\nt->node_id = destination_id;\r\nt->tlabel = tlabel;\r\nt->card = card;\r\nt->is_split_transaction = false;\r\nsetup_timer(&t->split_timeout_timer,\r\nsplit_transaction_timeout_callback, (unsigned long)t);\r\nt->callback = callback;\r\nt->callback_data = callback_data;\r\nfw_fill_request(&t->packet, tcode, t->tlabel,\r\ndestination_id, card->node_id, generation,\r\nspeed, offset, payload, length);\r\nt->packet.callback = transmit_complete_callback;\r\nlist_add_tail(&t->link, &card->transaction_list);\r\nspin_unlock_irqrestore(&card->lock, flags);\r\ncard->driver->send_request(card, &t->packet);\r\n}\r\nstatic void transaction_callback(struct fw_card *card, int rcode,\r\nvoid *payload, size_t length, void *data)\r\n{\r\nstruct transaction_callback_data *d = data;\r\nif (rcode == RCODE_COMPLETE)\r\nmemcpy(d->payload, payload, length);\r\nd->rcode = rcode;\r\ncomplete(&d->done);\r\n}\r\nint fw_run_transaction(struct fw_card *card, int tcode, int destination_id,\r\nint generation, int speed, unsigned long long offset,\r\nvoid *payload, size_t length)\r\n{\r\nstruct transaction_callback_data d;\r\nstruct fw_transaction t;\r\ninit_timer_on_stack(&t.split_timeout_timer);\r\ninit_completion(&d.done);\r\nd.payload = payload;\r\nfw_send_request(card, &t, tcode, destination_id, generation, speed,\r\noffset, payload, length, transaction_callback, &d);\r\nwait_for_completion(&d.done);\r\ndestroy_timer_on_stack(&t.split_timeout_timer);\r\nreturn d.rcode;\r\n}\r\nstatic void transmit_phy_packet_callback(struct fw_packet *packet,\r\nstruct fw_card *card, int status)\r\n{\r\ncomplete(&phy_config_done);\r\n}\r\nvoid fw_send_phy_config(struct fw_card *card,\r\nint node_id, int generation, int gap_count)\r\n{\r\nlong timeout = DIV_ROUND_UP(HZ, 10);\r\nu32 data = PHY_IDENTIFIER(PHY_PACKET_CONFIG);\r\nif (node_id != FW_PHY_CONFIG_NO_NODE_ID)\r\ndata |= PHY_CONFIG_ROOT_ID(node_id);\r\nif (gap_count == FW_PHY_CONFIG_CURRENT_GAP_COUNT) {\r\ngap_count = card->driver->read_phy_reg(card, 1);\r\nif (gap_count < 0)\r\nreturn;\r\ngap_count &= 63;\r\nif (gap_count == 63)\r\nreturn;\r\n}\r\ndata |= PHY_CONFIG_GAP_COUNT(gap_count);\r\nmutex_lock(&phy_config_mutex);\r\nphy_config_packet.header[1] = data;\r\nphy_config_packet.header[2] = ~data;\r\nphy_config_packet.generation = generation;\r\nINIT_COMPLETION(phy_config_done);\r\ncard->driver->send_request(card, &phy_config_packet);\r\nwait_for_completion_timeout(&phy_config_done, timeout);\r\nmutex_unlock(&phy_config_mutex);\r\n}\r\nstatic struct fw_address_handler *lookup_overlapping_address_handler(\r\nstruct list_head *list, unsigned long long offset, size_t length)\r\n{\r\nstruct fw_address_handler *handler;\r\nlist_for_each_entry_rcu(handler, list, link) {\r\nif (handler->offset < offset + length &&\r\noffset < handler->offset + handler->length)\r\nreturn handler;\r\n}\r\nreturn NULL;\r\n}\r\nstatic bool is_enclosing_handler(struct fw_address_handler *handler,\r\nunsigned long long offset, size_t length)\r\n{\r\nreturn handler->offset <= offset &&\r\noffset + length <= handler->offset + handler->length;\r\n}\r\nstatic struct fw_address_handler *lookup_enclosing_address_handler(\r\nstruct list_head *list, unsigned long long offset, size_t length)\r\n{\r\nstruct fw_address_handler *handler;\r\nlist_for_each_entry_rcu(handler, list, link) {\r\nif (is_enclosing_handler(handler, offset, length))\r\nreturn handler;\r\n}\r\nreturn NULL;\r\n}\r\nstatic bool is_in_fcp_region(u64 offset, size_t length)\r\n{\r\nreturn offset >= (CSR_REGISTER_BASE | CSR_FCP_COMMAND) &&\r\noffset + length <= (CSR_REGISTER_BASE | CSR_FCP_END);\r\n}\r\nint fw_core_add_address_handler(struct fw_address_handler *handler,\r\nconst struct fw_address_region *region)\r\n{\r\nstruct fw_address_handler *other;\r\nint ret = -EBUSY;\r\nif (region->start & 0xffff000000000003ULL ||\r\nregion->start >= region->end ||\r\nregion->end > 0x0001000000000000ULL ||\r\nhandler->length & 3 ||\r\nhandler->length == 0)\r\nreturn -EINVAL;\r\nspin_lock(&address_handler_list_lock);\r\nhandler->offset = region->start;\r\nwhile (handler->offset + handler->length <= region->end) {\r\nif (is_in_fcp_region(handler->offset, handler->length))\r\nother = NULL;\r\nelse\r\nother = lookup_overlapping_address_handler\r\n(&address_handler_list,\r\nhandler->offset, handler->length);\r\nif (other != NULL) {\r\nhandler->offset += other->length;\r\n} else {\r\nlist_add_tail_rcu(&handler->link, &address_handler_list);\r\nret = 0;\r\nbreak;\r\n}\r\n}\r\nspin_unlock(&address_handler_list_lock);\r\nreturn ret;\r\n}\r\nvoid fw_core_remove_address_handler(struct fw_address_handler *handler)\r\n{\r\nspin_lock(&address_handler_list_lock);\r\nlist_del_rcu(&handler->link);\r\nspin_unlock(&address_handler_list_lock);\r\nsynchronize_rcu();\r\n}\r\nstatic void free_response_callback(struct fw_packet *packet,\r\nstruct fw_card *card, int status)\r\n{\r\nstruct fw_request *request;\r\nrequest = container_of(packet, struct fw_request, response);\r\nkfree(request);\r\n}\r\nint fw_get_response_length(struct fw_request *r)\r\n{\r\nint tcode, ext_tcode, data_length;\r\ntcode = HEADER_GET_TCODE(r->request_header[0]);\r\nswitch (tcode) {\r\ncase TCODE_WRITE_QUADLET_REQUEST:\r\ncase TCODE_WRITE_BLOCK_REQUEST:\r\nreturn 0;\r\ncase TCODE_READ_QUADLET_REQUEST:\r\nreturn 4;\r\ncase TCODE_READ_BLOCK_REQUEST:\r\ndata_length = HEADER_GET_DATA_LENGTH(r->request_header[3]);\r\nreturn data_length;\r\ncase TCODE_LOCK_REQUEST:\r\next_tcode = HEADER_GET_EXTENDED_TCODE(r->request_header[3]);\r\ndata_length = HEADER_GET_DATA_LENGTH(r->request_header[3]);\r\nswitch (ext_tcode) {\r\ncase EXTCODE_FETCH_ADD:\r\ncase EXTCODE_LITTLE_ADD:\r\nreturn data_length;\r\ndefault:\r\nreturn data_length / 2;\r\n}\r\ndefault:\r\nWARN(1, "wrong tcode %d\n", tcode);\r\nreturn 0;\r\n}\r\n}\r\nvoid fw_fill_response(struct fw_packet *response, u32 *request_header,\r\nint rcode, void *payload, size_t length)\r\n{\r\nint tcode, tlabel, extended_tcode, source, destination;\r\ntcode = HEADER_GET_TCODE(request_header[0]);\r\ntlabel = HEADER_GET_TLABEL(request_header[0]);\r\nsource = HEADER_GET_DESTINATION(request_header[0]);\r\ndestination = HEADER_GET_SOURCE(request_header[1]);\r\nextended_tcode = HEADER_GET_EXTENDED_TCODE(request_header[3]);\r\nresponse->header[0] =\r\nHEADER_RETRY(RETRY_1) |\r\nHEADER_TLABEL(tlabel) |\r\nHEADER_DESTINATION(destination);\r\nresponse->header[1] =\r\nHEADER_SOURCE(source) |\r\nHEADER_RCODE(rcode);\r\nresponse->header[2] = 0;\r\nswitch (tcode) {\r\ncase TCODE_WRITE_QUADLET_REQUEST:\r\ncase TCODE_WRITE_BLOCK_REQUEST:\r\nresponse->header[0] |= HEADER_TCODE(TCODE_WRITE_RESPONSE);\r\nresponse->header_length = 12;\r\nresponse->payload_length = 0;\r\nbreak;\r\ncase TCODE_READ_QUADLET_REQUEST:\r\nresponse->header[0] |=\r\nHEADER_TCODE(TCODE_READ_QUADLET_RESPONSE);\r\nif (payload != NULL)\r\nresponse->header[3] = *(u32 *)payload;\r\nelse\r\nresponse->header[3] = 0;\r\nresponse->header_length = 16;\r\nresponse->payload_length = 0;\r\nbreak;\r\ncase TCODE_READ_BLOCK_REQUEST:\r\ncase TCODE_LOCK_REQUEST:\r\nresponse->header[0] |= HEADER_TCODE(tcode + 2);\r\nresponse->header[3] =\r\nHEADER_DATA_LENGTH(length) |\r\nHEADER_EXTENDED_TCODE(extended_tcode);\r\nresponse->header_length = 16;\r\nresponse->payload = payload;\r\nresponse->payload_length = length;\r\nbreak;\r\ndefault:\r\nWARN(1, "wrong tcode %d\n", tcode);\r\n}\r\nresponse->payload_mapped = false;\r\n}\r\nstatic u32 compute_split_timeout_timestamp(struct fw_card *card,\r\nu32 request_timestamp)\r\n{\r\nunsigned int cycles;\r\nu32 timestamp;\r\ncycles = card->split_timeout_cycles;\r\ncycles += request_timestamp & 0x1fff;\r\ntimestamp = request_timestamp & ~0x1fff;\r\ntimestamp += (cycles / 8000) << 13;\r\ntimestamp |= cycles % 8000;\r\nreturn timestamp;\r\n}\r\nstatic struct fw_request *allocate_request(struct fw_card *card,\r\nstruct fw_packet *p)\r\n{\r\nstruct fw_request *request;\r\nu32 *data, length;\r\nint request_tcode;\r\nrequest_tcode = HEADER_GET_TCODE(p->header[0]);\r\nswitch (request_tcode) {\r\ncase TCODE_WRITE_QUADLET_REQUEST:\r\ndata = &p->header[3];\r\nlength = 4;\r\nbreak;\r\ncase TCODE_WRITE_BLOCK_REQUEST:\r\ncase TCODE_LOCK_REQUEST:\r\ndata = p->payload;\r\nlength = HEADER_GET_DATA_LENGTH(p->header[3]);\r\nbreak;\r\ncase TCODE_READ_QUADLET_REQUEST:\r\ndata = NULL;\r\nlength = 4;\r\nbreak;\r\ncase TCODE_READ_BLOCK_REQUEST:\r\ndata = NULL;\r\nlength = HEADER_GET_DATA_LENGTH(p->header[3]);\r\nbreak;\r\ndefault:\r\nfw_notice(card, "ERROR - corrupt request received - %08x %08x %08x\n",\r\np->header[0], p->header[1], p->header[2]);\r\nreturn NULL;\r\n}\r\nrequest = kmalloc(sizeof(*request) + length, GFP_ATOMIC);\r\nif (request == NULL)\r\nreturn NULL;\r\nrequest->response.speed = p->speed;\r\nrequest->response.timestamp =\r\ncompute_split_timeout_timestamp(card, p->timestamp);\r\nrequest->response.generation = p->generation;\r\nrequest->response.ack = 0;\r\nrequest->response.callback = free_response_callback;\r\nrequest->ack = p->ack;\r\nrequest->length = length;\r\nif (data)\r\nmemcpy(request->data, data, length);\r\nmemcpy(request->request_header, p->header, sizeof(p->header));\r\nreturn request;\r\n}\r\nvoid fw_send_response(struct fw_card *card,\r\nstruct fw_request *request, int rcode)\r\n{\r\nif (WARN_ONCE(!request, "invalid for FCP address handlers"))\r\nreturn;\r\nif (request->ack != ACK_PENDING ||\r\nHEADER_DESTINATION_IS_BROADCAST(request->request_header[0])) {\r\nkfree(request);\r\nreturn;\r\n}\r\nif (rcode == RCODE_COMPLETE)\r\nfw_fill_response(&request->response, request->request_header,\r\nrcode, request->data,\r\nfw_get_response_length(request));\r\nelse\r\nfw_fill_response(&request->response, request->request_header,\r\nrcode, NULL, 0);\r\ncard->driver->send_response(card, &request->response);\r\n}\r\nint fw_get_request_speed(struct fw_request *request)\r\n{\r\nreturn request->response.speed;\r\n}\r\nstatic void handle_exclusive_region_request(struct fw_card *card,\r\nstruct fw_packet *p,\r\nstruct fw_request *request,\r\nunsigned long long offset)\r\n{\r\nstruct fw_address_handler *handler;\r\nint tcode, destination, source;\r\ndestination = HEADER_GET_DESTINATION(p->header[0]);\r\nsource = HEADER_GET_SOURCE(p->header[1]);\r\ntcode = HEADER_GET_TCODE(p->header[0]);\r\nif (tcode == TCODE_LOCK_REQUEST)\r\ntcode = 0x10 + HEADER_GET_EXTENDED_TCODE(p->header[3]);\r\nrcu_read_lock();\r\nhandler = lookup_enclosing_address_handler(&address_handler_list,\r\noffset, request->length);\r\nif (handler)\r\nhandler->address_callback(card, request,\r\ntcode, destination, source,\r\np->generation, offset,\r\nrequest->data, request->length,\r\nhandler->callback_data);\r\nrcu_read_unlock();\r\nif (!handler)\r\nfw_send_response(card, request, RCODE_ADDRESS_ERROR);\r\n}\r\nstatic void handle_fcp_region_request(struct fw_card *card,\r\nstruct fw_packet *p,\r\nstruct fw_request *request,\r\nunsigned long long offset)\r\n{\r\nstruct fw_address_handler *handler;\r\nint tcode, destination, source;\r\nif ((offset != (CSR_REGISTER_BASE | CSR_FCP_COMMAND) &&\r\noffset != (CSR_REGISTER_BASE | CSR_FCP_RESPONSE)) ||\r\nrequest->length > 0x200) {\r\nfw_send_response(card, request, RCODE_ADDRESS_ERROR);\r\nreturn;\r\n}\r\ntcode = HEADER_GET_TCODE(p->header[0]);\r\ndestination = HEADER_GET_DESTINATION(p->header[0]);\r\nsource = HEADER_GET_SOURCE(p->header[1]);\r\nif (tcode != TCODE_WRITE_QUADLET_REQUEST &&\r\ntcode != TCODE_WRITE_BLOCK_REQUEST) {\r\nfw_send_response(card, request, RCODE_TYPE_ERROR);\r\nreturn;\r\n}\r\nrcu_read_lock();\r\nlist_for_each_entry_rcu(handler, &address_handler_list, link) {\r\nif (is_enclosing_handler(handler, offset, request->length))\r\nhandler->address_callback(card, NULL, tcode,\r\ndestination, source,\r\np->generation, offset,\r\nrequest->data,\r\nrequest->length,\r\nhandler->callback_data);\r\n}\r\nrcu_read_unlock();\r\nfw_send_response(card, request, RCODE_COMPLETE);\r\n}\r\nvoid fw_core_handle_request(struct fw_card *card, struct fw_packet *p)\r\n{\r\nstruct fw_request *request;\r\nunsigned long long offset;\r\nif (p->ack != ACK_PENDING && p->ack != ACK_COMPLETE)\r\nreturn;\r\nif (TCODE_IS_LINK_INTERNAL(HEADER_GET_TCODE(p->header[0]))) {\r\nfw_cdev_handle_phy_packet(card, p);\r\nreturn;\r\n}\r\nrequest = allocate_request(card, p);\r\nif (request == NULL) {\r\nreturn;\r\n}\r\noffset = ((u64)HEADER_GET_OFFSET_HIGH(p->header[1]) << 32) |\r\np->header[2];\r\nif (!is_in_fcp_region(offset, request->length))\r\nhandle_exclusive_region_request(card, p, request, offset);\r\nelse\r\nhandle_fcp_region_request(card, p, request, offset);\r\n}\r\nvoid fw_core_handle_response(struct fw_card *card, struct fw_packet *p)\r\n{\r\nstruct fw_transaction *t;\r\nunsigned long flags;\r\nu32 *data;\r\nsize_t data_length;\r\nint tcode, tlabel, source, rcode;\r\ntcode = HEADER_GET_TCODE(p->header[0]);\r\ntlabel = HEADER_GET_TLABEL(p->header[0]);\r\nsource = HEADER_GET_SOURCE(p->header[1]);\r\nrcode = HEADER_GET_RCODE(p->header[1]);\r\nspin_lock_irqsave(&card->lock, flags);\r\nlist_for_each_entry(t, &card->transaction_list, link) {\r\nif (t->node_id == source && t->tlabel == tlabel) {\r\nif (!try_cancel_split_timeout(t)) {\r\nspin_unlock_irqrestore(&card->lock, flags);\r\ngoto timed_out;\r\n}\r\nlist_del_init(&t->link);\r\ncard->tlabel_mask &= ~(1ULL << t->tlabel);\r\nbreak;\r\n}\r\n}\r\nspin_unlock_irqrestore(&card->lock, flags);\r\nif (&t->link == &card->transaction_list) {\r\ntimed_out:\r\nfw_notice(card, "unsolicited response (source %x, tlabel %x)\n",\r\nsource, tlabel);\r\nreturn;\r\n}\r\nswitch (tcode) {\r\ncase TCODE_READ_QUADLET_RESPONSE:\r\ndata = (u32 *) &p->header[3];\r\ndata_length = 4;\r\nbreak;\r\ncase TCODE_WRITE_RESPONSE:\r\ndata = NULL;\r\ndata_length = 0;\r\nbreak;\r\ncase TCODE_READ_BLOCK_RESPONSE:\r\ncase TCODE_LOCK_RESPONSE:\r\ndata = p->payload;\r\ndata_length = HEADER_GET_DATA_LENGTH(p->header[3]);\r\nbreak;\r\ndefault:\r\ndata = NULL;\r\ndata_length = 0;\r\nbreak;\r\n}\r\ncard->driver->cancel_packet(card, &t->packet);\r\nt->callback(card, rcode, data, data_length, t->callback_data);\r\n}\r\nconst char *fw_rcode_string(int rcode)\r\n{\r\nstatic const char *const names[] = {\r\n[RCODE_COMPLETE] = "no error",\r\n[RCODE_CONFLICT_ERROR] = "conflict error",\r\n[RCODE_DATA_ERROR] = "data error",\r\n[RCODE_TYPE_ERROR] = "type error",\r\n[RCODE_ADDRESS_ERROR] = "address error",\r\n[RCODE_SEND_ERROR] = "send error",\r\n[RCODE_CANCELLED] = "timeout",\r\n[RCODE_BUSY] = "busy",\r\n[RCODE_GENERATION] = "bus reset",\r\n[RCODE_NO_ACK] = "no ack",\r\n};\r\nif ((unsigned int)rcode < ARRAY_SIZE(names) && names[rcode])\r\nreturn names[rcode];\r\nelse\r\nreturn "unknown";\r\n}\r\nstatic void handle_topology_map(struct fw_card *card, struct fw_request *request,\r\nint tcode, int destination, int source, int generation,\r\nunsigned long long offset, void *payload, size_t length,\r\nvoid *callback_data)\r\n{\r\nint start;\r\nif (!TCODE_IS_READ_REQUEST(tcode)) {\r\nfw_send_response(card, request, RCODE_TYPE_ERROR);\r\nreturn;\r\n}\r\nif ((offset & 3) > 0 || (length & 3) > 0) {\r\nfw_send_response(card, request, RCODE_ADDRESS_ERROR);\r\nreturn;\r\n}\r\nstart = (offset - topology_map_region.start) / 4;\r\nmemcpy(payload, &card->topology_map[start], length);\r\nfw_send_response(card, request, RCODE_COMPLETE);\r\n}\r\nstatic void update_split_timeout(struct fw_card *card)\r\n{\r\nunsigned int cycles;\r\ncycles = card->split_timeout_hi * 8000 + (card->split_timeout_lo >> 19);\r\ncycles = clamp(cycles, 800u, 3u * 8000u);\r\ncard->split_timeout_cycles = cycles;\r\ncard->split_timeout_jiffies = DIV_ROUND_UP(cycles * HZ, 8000);\r\n}\r\nstatic void handle_registers(struct fw_card *card, struct fw_request *request,\r\nint tcode, int destination, int source, int generation,\r\nunsigned long long offset, void *payload, size_t length,\r\nvoid *callback_data)\r\n{\r\nint reg = offset & ~CSR_REGISTER_BASE;\r\n__be32 *data = payload;\r\nint rcode = RCODE_COMPLETE;\r\nunsigned long flags;\r\nswitch (reg) {\r\ncase CSR_PRIORITY_BUDGET:\r\nif (!card->priority_budget_implemented) {\r\nrcode = RCODE_ADDRESS_ERROR;\r\nbreak;\r\n}\r\ncase CSR_NODE_IDS:\r\ncase CSR_STATE_CLEAR:\r\ncase CSR_STATE_SET:\r\ncase CSR_CYCLE_TIME:\r\ncase CSR_BUS_TIME:\r\ncase CSR_BUSY_TIMEOUT:\r\nif (tcode == TCODE_READ_QUADLET_REQUEST)\r\n*data = cpu_to_be32(card->driver->read_csr(card, reg));\r\nelse if (tcode == TCODE_WRITE_QUADLET_REQUEST)\r\ncard->driver->write_csr(card, reg, be32_to_cpu(*data));\r\nelse\r\nrcode = RCODE_TYPE_ERROR;\r\nbreak;\r\ncase CSR_RESET_START:\r\nif (tcode == TCODE_WRITE_QUADLET_REQUEST)\r\ncard->driver->write_csr(card, CSR_STATE_CLEAR,\r\nCSR_STATE_BIT_ABDICATE);\r\nelse\r\nrcode = RCODE_TYPE_ERROR;\r\nbreak;\r\ncase CSR_SPLIT_TIMEOUT_HI:\r\nif (tcode == TCODE_READ_QUADLET_REQUEST) {\r\n*data = cpu_to_be32(card->split_timeout_hi);\r\n} else if (tcode == TCODE_WRITE_QUADLET_REQUEST) {\r\nspin_lock_irqsave(&card->lock, flags);\r\ncard->split_timeout_hi = be32_to_cpu(*data) & 7;\r\nupdate_split_timeout(card);\r\nspin_unlock_irqrestore(&card->lock, flags);\r\n} else {\r\nrcode = RCODE_TYPE_ERROR;\r\n}\r\nbreak;\r\ncase CSR_SPLIT_TIMEOUT_LO:\r\nif (tcode == TCODE_READ_QUADLET_REQUEST) {\r\n*data = cpu_to_be32(card->split_timeout_lo);\r\n} else if (tcode == TCODE_WRITE_QUADLET_REQUEST) {\r\nspin_lock_irqsave(&card->lock, flags);\r\ncard->split_timeout_lo =\r\nbe32_to_cpu(*data) & 0xfff80000;\r\nupdate_split_timeout(card);\r\nspin_unlock_irqrestore(&card->lock, flags);\r\n} else {\r\nrcode = RCODE_TYPE_ERROR;\r\n}\r\nbreak;\r\ncase CSR_MAINT_UTILITY:\r\nif (tcode == TCODE_READ_QUADLET_REQUEST)\r\n*data = card->maint_utility_register;\r\nelse if (tcode == TCODE_WRITE_QUADLET_REQUEST)\r\ncard->maint_utility_register = *data;\r\nelse\r\nrcode = RCODE_TYPE_ERROR;\r\nbreak;\r\ncase CSR_BROADCAST_CHANNEL:\r\nif (tcode == TCODE_READ_QUADLET_REQUEST)\r\n*data = cpu_to_be32(card->broadcast_channel);\r\nelse if (tcode == TCODE_WRITE_QUADLET_REQUEST)\r\ncard->broadcast_channel =\r\n(be32_to_cpu(*data) & BROADCAST_CHANNEL_VALID) |\r\nBROADCAST_CHANNEL_INITIAL;\r\nelse\r\nrcode = RCODE_TYPE_ERROR;\r\nbreak;\r\ncase CSR_BUS_MANAGER_ID:\r\ncase CSR_BANDWIDTH_AVAILABLE:\r\ncase CSR_CHANNELS_AVAILABLE_HI:\r\ncase CSR_CHANNELS_AVAILABLE_LO:\r\nBUG();\r\nbreak;\r\ndefault:\r\nrcode = RCODE_ADDRESS_ERROR;\r\nbreak;\r\n}\r\nfw_send_response(card, request, rcode);\r\n}\r\nstatic void handle_low_memory(struct fw_card *card, struct fw_request *request,\r\nint tcode, int destination, int source, int generation,\r\nunsigned long long offset, void *payload, size_t length,\r\nvoid *callback_data)\r\n{\r\nfw_send_response(card, request, RCODE_TYPE_ERROR);\r\n}\r\nstatic int __init fw_core_init(void)\r\n{\r\nint ret;\r\nfw_workqueue = alloc_workqueue("firewire",\r\nWQ_NON_REENTRANT | WQ_MEM_RECLAIM, 0);\r\nif (!fw_workqueue)\r\nreturn -ENOMEM;\r\nret = bus_register(&fw_bus_type);\r\nif (ret < 0) {\r\ndestroy_workqueue(fw_workqueue);\r\nreturn ret;\r\n}\r\nfw_cdev_major = register_chrdev(0, "firewire", &fw_device_ops);\r\nif (fw_cdev_major < 0) {\r\nbus_unregister(&fw_bus_type);\r\ndestroy_workqueue(fw_workqueue);\r\nreturn fw_cdev_major;\r\n}\r\nfw_core_add_address_handler(&topology_map, &topology_map_region);\r\nfw_core_add_address_handler(&registers, &registers_region);\r\nfw_core_add_address_handler(&low_memory, &low_memory_region);\r\nfw_core_add_descriptor(&vendor_id_descriptor);\r\nfw_core_add_descriptor(&model_id_descriptor);\r\nreturn 0;\r\n}\r\nstatic void __exit fw_core_cleanup(void)\r\n{\r\nunregister_chrdev(fw_cdev_major, "firewire");\r\nbus_unregister(&fw_bus_type);\r\ndestroy_workqueue(fw_workqueue);\r\nidr_destroy(&fw_device_idr);\r\n}
