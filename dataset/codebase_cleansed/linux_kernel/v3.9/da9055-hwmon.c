static int da9055_adc_manual_read(struct da9055_hwmon *hwmon,\r\nunsigned char channel)\r\n{\r\nint ret;\r\nunsigned short calc_data;\r\nunsigned short data;\r\nunsigned char mux_sel;\r\nstruct da9055 *da9055 = hwmon->da9055;\r\nif (channel > DA9055_ADC_TJUNC)\r\nreturn -EINVAL;\r\nmutex_lock(&hwmon->irq_lock);\r\nmux_sel = chan_mux[channel] | DA9055_ADC_MAN_CONV;\r\nret = da9055_reg_write(da9055, DA9055_REG_ADC_MAN, mux_sel);\r\nif (ret < 0)\r\ngoto err;\r\nif (!wait_for_completion_timeout(&hwmon->done,\r\nmsecs_to_jiffies(500))) {\r\ndev_err(da9055->dev,\r\n"timeout waiting for ADC conversion interrupt\n");\r\nret = -ETIMEDOUT;\r\ngoto err;\r\n}\r\nret = da9055_reg_read(da9055, DA9055_REG_ADC_RES_H);\r\nif (ret < 0)\r\ngoto err;\r\ncalc_data = (unsigned short)ret;\r\ndata = calc_data << 2;\r\nret = da9055_reg_read(da9055, DA9055_REG_ADC_RES_L);\r\nif (ret < 0)\r\ngoto err;\r\ncalc_data = (unsigned short)(ret & DA9055_ADC_LSB_MASK);\r\ndata |= calc_data;\r\nret = data;\r\nerr:\r\nmutex_unlock(&hwmon->irq_lock);\r\nreturn ret;\r\n}\r\nstatic irqreturn_t da9055_auxadc_irq(int irq, void *irq_data)\r\n{\r\nstruct da9055_hwmon *hwmon = irq_data;\r\ncomplete(&hwmon->done);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic inline int volt_reg_to_mV(int value, int channel)\r\n{\r\nif (channel == DA9055_ADC_VSYS)\r\nreturn DIV_ROUND_CLOSEST(value * 1000, DA9055_VSYS_DIV) + 2500;\r\nelse\r\nreturn DIV_ROUND_CLOSEST(value * 1000, DA9055_ADCIN_DIV);\r\n}\r\nstatic int da9055_enable_auto_mode(struct da9055 *da9055, int channel)\r\n{\r\nreturn da9055_reg_update(da9055, DA9055_REG_ADC_CONT, 1 << channel,\r\n1 << channel);\r\n}\r\nstatic int da9055_disable_auto_mode(struct da9055 *da9055, int channel)\r\n{\r\nreturn da9055_reg_update(da9055, DA9055_REG_ADC_CONT, 1 << channel, 0);\r\n}\r\nstatic ssize_t da9055_read_auto_ch(struct device *dev,\r\nstruct device_attribute *devattr, char *buf)\r\n{\r\nstruct da9055_hwmon *hwmon = dev_get_drvdata(dev);\r\nint ret, adc;\r\nint channel = to_sensor_dev_attr(devattr)->index;\r\nmutex_lock(&hwmon->hwmon_lock);\r\nret = da9055_enable_auto_mode(hwmon->da9055, channel);\r\nif (ret < 0)\r\ngoto hwmon_err;\r\nusleep_range(10000, 10500);\r\nadc = da9055_reg_read(hwmon->da9055, DA9055_REG_VSYS_RES + channel);\r\nif (adc < 0) {\r\nret = adc;\r\ngoto hwmon_err_release;\r\n}\r\nret = da9055_disable_auto_mode(hwmon->da9055, channel);\r\nif (ret < 0)\r\ngoto hwmon_err;\r\nmutex_unlock(&hwmon->hwmon_lock);\r\nreturn sprintf(buf, "%d\n", volt_reg_to_mV(adc, channel));\r\nhwmon_err_release:\r\nda9055_disable_auto_mode(hwmon->da9055, channel);\r\nhwmon_err:\r\nmutex_unlock(&hwmon->hwmon_lock);\r\nreturn ret;\r\n}\r\nstatic ssize_t da9055_read_tjunc(struct device *dev,\r\nstruct device_attribute *devattr, char *buf)\r\n{\r\nstruct da9055_hwmon *hwmon = dev_get_drvdata(dev);\r\nint tjunc;\r\nint toffset;\r\ntjunc = da9055_adc_manual_read(hwmon, DA9055_ADC_TJUNC);\r\nif (tjunc < 0)\r\nreturn tjunc;\r\ntoffset = da9055_reg_read(hwmon->da9055, DA9055_REG_T_OFFSET);\r\nif (toffset < 0)\r\nreturn toffset;\r\nreturn sprintf(buf, "%d\n", DIV_ROUND_CLOSEST(-4084 * (tjunc - toffset)\r\n+ 3076332, 10000));\r\n}\r\nstatic ssize_t da9055_hwmon_show_name(struct device *dev,\r\nstruct device_attribute *devattr,\r\nchar *buf)\r\n{\r\nreturn sprintf(buf, "da9055-hwmon\n");\r\n}\r\nstatic ssize_t show_label(struct device *dev,\r\nstruct device_attribute *devattr, char *buf)\r\n{\r\nreturn sprintf(buf, "%s\n",\r\ninput_names[to_sensor_dev_attr(devattr)->index]);\r\n}\r\nstatic int da9055_hwmon_probe(struct platform_device *pdev)\r\n{\r\nstruct da9055_hwmon *hwmon;\r\nint hwmon_irq, ret;\r\nhwmon = devm_kzalloc(&pdev->dev, sizeof(struct da9055_hwmon),\r\nGFP_KERNEL);\r\nif (!hwmon)\r\nreturn -ENOMEM;\r\nmutex_init(&hwmon->hwmon_lock);\r\nmutex_init(&hwmon->irq_lock);\r\ninit_completion(&hwmon->done);\r\nhwmon->da9055 = dev_get_drvdata(pdev->dev.parent);\r\nplatform_set_drvdata(pdev, hwmon);\r\nhwmon_irq = platform_get_irq_byname(pdev, "HWMON");\r\nif (hwmon_irq < 0)\r\nreturn hwmon_irq;\r\nhwmon_irq = regmap_irq_get_virq(hwmon->da9055->irq_data, hwmon_irq);\r\nif (hwmon_irq < 0)\r\nreturn hwmon_irq;\r\nret = devm_request_threaded_irq(&pdev->dev, hwmon_irq,\r\nNULL, da9055_auxadc_irq,\r\nIRQF_TRIGGER_HIGH | IRQF_ONESHOT,\r\n"adc-irq", hwmon);\r\nif (ret != 0) {\r\ndev_err(hwmon->da9055->dev, "DA9055 ADC IRQ failed ret=%d\n",\r\nret);\r\nreturn ret;\r\n}\r\nret = sysfs_create_group(&pdev->dev.kobj, &da9055_attr_group);\r\nif (ret)\r\nreturn ret;\r\nhwmon->class_device = hwmon_device_register(&pdev->dev);\r\nif (IS_ERR(hwmon->class_device)) {\r\nret = PTR_ERR(hwmon->class_device);\r\ngoto err;\r\n}\r\nreturn 0;\r\nerr:\r\nsysfs_remove_group(&pdev->dev.kobj, &da9055_attr_group);\r\nreturn ret;\r\n}\r\nstatic int da9055_hwmon_remove(struct platform_device *pdev)\r\n{\r\nstruct da9055_hwmon *hwmon = platform_get_drvdata(pdev);\r\nsysfs_remove_group(&pdev->dev.kobj, &da9055_attr_group);\r\nhwmon_device_unregister(hwmon->class_device);\r\nreturn 0;\r\n}
