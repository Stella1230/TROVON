static void audit_free_parent(struct audit_parent *parent)\r\n{\r\nWARN_ON(!list_empty(&parent->watches));\r\nkfree(parent);\r\n}\r\nstatic void audit_watch_free_mark(struct fsnotify_mark *entry)\r\n{\r\nstruct audit_parent *parent;\r\nparent = container_of(entry, struct audit_parent, mark);\r\naudit_free_parent(parent);\r\n}\r\nstatic void audit_get_parent(struct audit_parent *parent)\r\n{\r\nif (likely(parent))\r\nfsnotify_get_mark(&parent->mark);\r\n}\r\nstatic void audit_put_parent(struct audit_parent *parent)\r\n{\r\nif (likely(parent))\r\nfsnotify_put_mark(&parent->mark);\r\n}\r\nstatic inline struct audit_parent *audit_find_parent(struct inode *inode)\r\n{\r\nstruct audit_parent *parent = NULL;\r\nstruct fsnotify_mark *entry;\r\nentry = fsnotify_find_inode_mark(audit_watch_group, inode);\r\nif (entry)\r\nparent = container_of(entry, struct audit_parent, mark);\r\nreturn parent;\r\n}\r\nvoid audit_get_watch(struct audit_watch *watch)\r\n{\r\natomic_inc(&watch->count);\r\n}\r\nvoid audit_put_watch(struct audit_watch *watch)\r\n{\r\nif (atomic_dec_and_test(&watch->count)) {\r\nWARN_ON(watch->parent);\r\nWARN_ON(!list_empty(&watch->rules));\r\nkfree(watch->path);\r\nkfree(watch);\r\n}\r\n}\r\nstatic void audit_remove_watch(struct audit_watch *watch)\r\n{\r\nlist_del(&watch->wlist);\r\naudit_put_parent(watch->parent);\r\nwatch->parent = NULL;\r\naudit_put_watch(watch);\r\n}\r\nchar *audit_watch_path(struct audit_watch *watch)\r\n{\r\nreturn watch->path;\r\n}\r\nint audit_watch_compare(struct audit_watch *watch, unsigned long ino, dev_t dev)\r\n{\r\nreturn (watch->ino != (unsigned long)-1) &&\r\n(watch->ino == ino) &&\r\n(watch->dev == dev);\r\n}\r\nstatic struct audit_parent *audit_init_parent(struct path *path)\r\n{\r\nstruct inode *inode = path->dentry->d_inode;\r\nstruct audit_parent *parent;\r\nint ret;\r\nparent = kzalloc(sizeof(*parent), GFP_KERNEL);\r\nif (unlikely(!parent))\r\nreturn ERR_PTR(-ENOMEM);\r\nINIT_LIST_HEAD(&parent->watches);\r\nfsnotify_init_mark(&parent->mark, audit_watch_free_mark);\r\nparent->mark.mask = AUDIT_FS_WATCH;\r\nret = fsnotify_add_mark(&parent->mark, audit_watch_group, inode, NULL, 0);\r\nif (ret < 0) {\r\naudit_free_parent(parent);\r\nreturn ERR_PTR(ret);\r\n}\r\nreturn parent;\r\n}\r\nstatic struct audit_watch *audit_init_watch(char *path)\r\n{\r\nstruct audit_watch *watch;\r\nwatch = kzalloc(sizeof(*watch), GFP_KERNEL);\r\nif (unlikely(!watch))\r\nreturn ERR_PTR(-ENOMEM);\r\nINIT_LIST_HEAD(&watch->rules);\r\natomic_set(&watch->count, 1);\r\nwatch->path = path;\r\nwatch->dev = (dev_t)-1;\r\nwatch->ino = (unsigned long)-1;\r\nreturn watch;\r\n}\r\nint audit_to_watch(struct audit_krule *krule, char *path, int len, u32 op)\r\n{\r\nstruct audit_watch *watch;\r\nif (!audit_watch_group)\r\nreturn -EOPNOTSUPP;\r\nif (path[0] != '/' || path[len-1] == '/' ||\r\nkrule->listnr != AUDIT_FILTER_EXIT ||\r\nop != Audit_equal ||\r\nkrule->inode_f || krule->watch || krule->tree)\r\nreturn -EINVAL;\r\nwatch = audit_init_watch(path);\r\nif (IS_ERR(watch))\r\nreturn PTR_ERR(watch);\r\naudit_get_watch(watch);\r\nkrule->watch = watch;\r\nreturn 0;\r\n}\r\nstatic struct audit_watch *audit_dupe_watch(struct audit_watch *old)\r\n{\r\nchar *path;\r\nstruct audit_watch *new;\r\npath = kstrdup(old->path, GFP_KERNEL);\r\nif (unlikely(!path))\r\nreturn ERR_PTR(-ENOMEM);\r\nnew = audit_init_watch(path);\r\nif (IS_ERR(new)) {\r\nkfree(path);\r\ngoto out;\r\n}\r\nnew->dev = old->dev;\r\nnew->ino = old->ino;\r\naudit_get_parent(old->parent);\r\nnew->parent = old->parent;\r\nout:\r\nreturn new;\r\n}\r\nstatic void audit_watch_log_rule_change(struct audit_krule *r, struct audit_watch *w, char *op)\r\n{\r\nif (audit_enabled) {\r\nstruct audit_buffer *ab;\r\nab = audit_log_start(NULL, GFP_NOFS, AUDIT_CONFIG_CHANGE);\r\nif (unlikely(!ab))\r\nreturn;\r\naudit_log_format(ab, "auid=%u ses=%u op=",\r\nfrom_kuid(&init_user_ns, audit_get_loginuid(current)),\r\naudit_get_sessionid(current));\r\naudit_log_string(ab, op);\r\naudit_log_format(ab, " path=");\r\naudit_log_untrustedstring(ab, w->path);\r\naudit_log_key(ab, r->filterkey);\r\naudit_log_format(ab, " list=%d res=1", r->listnr);\r\naudit_log_end(ab);\r\n}\r\n}\r\nstatic void audit_update_watch(struct audit_parent *parent,\r\nconst char *dname, dev_t dev,\r\nunsigned long ino, unsigned invalidating)\r\n{\r\nstruct audit_watch *owatch, *nwatch, *nextw;\r\nstruct audit_krule *r, *nextr;\r\nstruct audit_entry *oentry, *nentry;\r\nmutex_lock(&audit_filter_mutex);\r\nlist_for_each_entry_safe(owatch, nextw, &parent->watches, wlist) {\r\nif (audit_compare_dname_path(dname, owatch->path,\r\nAUDIT_NAME_FULL))\r\ncontinue;\r\nif (invalidating && !audit_dummy_context())\r\naudit_filter_inodes(current, current->audit_context);\r\nnwatch = audit_dupe_watch(owatch);\r\nif (IS_ERR(nwatch)) {\r\nmutex_unlock(&audit_filter_mutex);\r\naudit_panic("error updating watch, skipping");\r\nreturn;\r\n}\r\nnwatch->dev = dev;\r\nnwatch->ino = ino;\r\nlist_for_each_entry_safe(r, nextr, &owatch->rules, rlist) {\r\noentry = container_of(r, struct audit_entry, rule);\r\nlist_del(&oentry->rule.rlist);\r\nlist_del_rcu(&oentry->list);\r\nnentry = audit_dupe_rule(&oentry->rule);\r\nif (IS_ERR(nentry)) {\r\nlist_del(&oentry->rule.list);\r\naudit_panic("error updating watch, removing");\r\n} else {\r\nint h = audit_hash_ino((u32)ino);\r\naudit_put_watch(nentry->rule.watch);\r\naudit_get_watch(nwatch);\r\nnentry->rule.watch = nwatch;\r\nlist_add(&nentry->rule.rlist, &nwatch->rules);\r\nlist_add_rcu(&nentry->list, &audit_inode_hash[h]);\r\nlist_replace(&oentry->rule.list,\r\n&nentry->rule.list);\r\n}\r\naudit_watch_log_rule_change(r, owatch, "updated rules");\r\ncall_rcu(&oentry->rcu, audit_free_rule_rcu);\r\n}\r\naudit_remove_watch(owatch);\r\ngoto add_watch_to_parent;\r\n}\r\nmutex_unlock(&audit_filter_mutex);\r\nreturn;\r\nadd_watch_to_parent:\r\nlist_add(&nwatch->wlist, &parent->watches);\r\nmutex_unlock(&audit_filter_mutex);\r\nreturn;\r\n}\r\nstatic void audit_remove_parent_watches(struct audit_parent *parent)\r\n{\r\nstruct audit_watch *w, *nextw;\r\nstruct audit_krule *r, *nextr;\r\nstruct audit_entry *e;\r\nmutex_lock(&audit_filter_mutex);\r\nlist_for_each_entry_safe(w, nextw, &parent->watches, wlist) {\r\nlist_for_each_entry_safe(r, nextr, &w->rules, rlist) {\r\ne = container_of(r, struct audit_entry, rule);\r\naudit_watch_log_rule_change(r, w, "remove rule");\r\nlist_del(&r->rlist);\r\nlist_del(&r->list);\r\nlist_del_rcu(&e->list);\r\ncall_rcu(&e->rcu, audit_free_rule_rcu);\r\n}\r\naudit_remove_watch(w);\r\n}\r\nmutex_unlock(&audit_filter_mutex);\r\nfsnotify_destroy_mark(&parent->mark, audit_watch_group);\r\n}\r\nstatic int audit_get_nd(struct audit_watch *watch, struct path *parent)\r\n{\r\nstruct dentry *d = kern_path_locked(watch->path, parent);\r\nif (IS_ERR(d))\r\nreturn PTR_ERR(d);\r\nmutex_unlock(&parent->dentry->d_inode->i_mutex);\r\nif (d->d_inode) {\r\nwatch->dev = d->d_inode->i_sb->s_dev;\r\nwatch->ino = d->d_inode->i_ino;\r\n}\r\ndput(d);\r\nreturn 0;\r\n}\r\nstatic void audit_add_to_parent(struct audit_krule *krule,\r\nstruct audit_parent *parent)\r\n{\r\nstruct audit_watch *w, *watch = krule->watch;\r\nint watch_found = 0;\r\nBUG_ON(!mutex_is_locked(&audit_filter_mutex));\r\nlist_for_each_entry(w, &parent->watches, wlist) {\r\nif (strcmp(watch->path, w->path))\r\ncontinue;\r\nwatch_found = 1;\r\naudit_put_watch(watch);\r\naudit_put_watch(watch);\r\naudit_get_watch(w);\r\nkrule->watch = watch = w;\r\nbreak;\r\n}\r\nif (!watch_found) {\r\naudit_get_parent(parent);\r\nwatch->parent = parent;\r\nlist_add(&watch->wlist, &parent->watches);\r\n}\r\nlist_add(&krule->rlist, &watch->rules);\r\n}\r\nint audit_add_watch(struct audit_krule *krule, struct list_head **list)\r\n{\r\nstruct audit_watch *watch = krule->watch;\r\nstruct audit_parent *parent;\r\nstruct path parent_path;\r\nint h, ret = 0;\r\nmutex_unlock(&audit_filter_mutex);\r\nret = audit_get_nd(watch, &parent_path);\r\nmutex_lock(&audit_filter_mutex);\r\nif (ret)\r\nreturn ret;\r\nparent = audit_find_parent(parent_path.dentry->d_inode);\r\nif (!parent) {\r\nparent = audit_init_parent(&parent_path);\r\nif (IS_ERR(parent)) {\r\nret = PTR_ERR(parent);\r\ngoto error;\r\n}\r\n}\r\naudit_add_to_parent(krule, parent);\r\naudit_put_parent(parent);\r\nh = audit_hash_ino((u32)watch->ino);\r\n*list = &audit_inode_hash[h];\r\nerror:\r\npath_put(&parent_path);\r\nreturn ret;\r\n}\r\nvoid audit_remove_watch_rule(struct audit_krule *krule)\r\n{\r\nstruct audit_watch *watch = krule->watch;\r\nstruct audit_parent *parent = watch->parent;\r\nlist_del(&krule->rlist);\r\nif (list_empty(&watch->rules)) {\r\naudit_remove_watch(watch);\r\nif (list_empty(&parent->watches)) {\r\naudit_get_parent(parent);\r\nfsnotify_destroy_mark(&parent->mark, audit_watch_group);\r\naudit_put_parent(parent);\r\n}\r\n}\r\n}\r\nstatic bool audit_watch_should_send_event(struct fsnotify_group *group, struct inode *inode,\r\nstruct fsnotify_mark *inode_mark,\r\nstruct fsnotify_mark *vfsmount_mark,\r\n__u32 mask, void *data, int data_type)\r\n{\r\nreturn true;\r\n}\r\nstatic int audit_watch_handle_event(struct fsnotify_group *group,\r\nstruct fsnotify_mark *inode_mark,\r\nstruct fsnotify_mark *vfsmount_mark,\r\nstruct fsnotify_event *event)\r\n{\r\nstruct inode *inode;\r\n__u32 mask = event->mask;\r\nconst char *dname = event->file_name;\r\nstruct audit_parent *parent;\r\nparent = container_of(inode_mark, struct audit_parent, mark);\r\nBUG_ON(group != audit_watch_group);\r\nswitch (event->data_type) {\r\ncase (FSNOTIFY_EVENT_PATH):\r\ninode = event->path.dentry->d_inode;\r\nbreak;\r\ncase (FSNOTIFY_EVENT_INODE):\r\ninode = event->inode;\r\nbreak;\r\ndefault:\r\nBUG();\r\ninode = NULL;\r\nbreak;\r\n};\r\nif (mask & (FS_CREATE|FS_MOVED_TO) && inode)\r\naudit_update_watch(parent, dname, inode->i_sb->s_dev, inode->i_ino, 0);\r\nelse if (mask & (FS_DELETE|FS_MOVED_FROM))\r\naudit_update_watch(parent, dname, (dev_t)-1, (unsigned long)-1, 1);\r\nelse if (mask & (FS_DELETE_SELF|FS_UNMOUNT|FS_MOVE_SELF))\r\naudit_remove_parent_watches(parent);\r\nreturn 0;\r\n}\r\nstatic int __init audit_watch_init(void)\r\n{\r\naudit_watch_group = fsnotify_alloc_group(&audit_watch_fsnotify_ops);\r\nif (IS_ERR(audit_watch_group)) {\r\naudit_watch_group = NULL;\r\naudit_panic("cannot create audit fsnotify group");\r\n}\r\nreturn 0;\r\n}
