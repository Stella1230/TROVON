static void s3c_pcm_snd_txctrl(struct s3c_pcm_info *pcm, int on)\r\n{\r\nvoid __iomem *regs = pcm->regs;\r\nu32 ctl, clkctl;\r\nclkctl = readl(regs + S3C_PCM_CLKCTL);\r\nctl = readl(regs + S3C_PCM_CTL);\r\nctl &= ~(S3C_PCM_CTL_TXDIPSTICK_MASK\r\n<< S3C_PCM_CTL_TXDIPSTICK_SHIFT);\r\nif (on) {\r\nctl |= S3C_PCM_CTL_TXDMA_EN;\r\nctl |= S3C_PCM_CTL_TXFIFO_EN;\r\nctl |= S3C_PCM_CTL_ENABLE;\r\nctl |= (0x4<<S3C_PCM_CTL_TXDIPSTICK_SHIFT);\r\nclkctl |= S3C_PCM_CLKCTL_SERCLK_EN;\r\n} else {\r\nctl &= ~S3C_PCM_CTL_TXDMA_EN;\r\nctl &= ~S3C_PCM_CTL_TXFIFO_EN;\r\nif (!(ctl & S3C_PCM_CTL_RXFIFO_EN)) {\r\nctl &= ~S3C_PCM_CTL_ENABLE;\r\nif (!pcm->idleclk)\r\nclkctl |= S3C_PCM_CLKCTL_SERCLK_EN;\r\n}\r\n}\r\nwritel(clkctl, regs + S3C_PCM_CLKCTL);\r\nwritel(ctl, regs + S3C_PCM_CTL);\r\n}\r\nstatic void s3c_pcm_snd_rxctrl(struct s3c_pcm_info *pcm, int on)\r\n{\r\nvoid __iomem *regs = pcm->regs;\r\nu32 ctl, clkctl;\r\nctl = readl(regs + S3C_PCM_CTL);\r\nclkctl = readl(regs + S3C_PCM_CLKCTL);\r\nctl &= ~(S3C_PCM_CTL_RXDIPSTICK_MASK\r\n<< S3C_PCM_CTL_RXDIPSTICK_SHIFT);\r\nif (on) {\r\nctl |= S3C_PCM_CTL_RXDMA_EN;\r\nctl |= S3C_PCM_CTL_RXFIFO_EN;\r\nctl |= S3C_PCM_CTL_ENABLE;\r\nctl |= (0x20<<S3C_PCM_CTL_RXDIPSTICK_SHIFT);\r\nclkctl |= S3C_PCM_CLKCTL_SERCLK_EN;\r\n} else {\r\nctl &= ~S3C_PCM_CTL_RXDMA_EN;\r\nctl &= ~S3C_PCM_CTL_RXFIFO_EN;\r\nif (!(ctl & S3C_PCM_CTL_TXFIFO_EN)) {\r\nctl &= ~S3C_PCM_CTL_ENABLE;\r\nif (!pcm->idleclk)\r\nclkctl |= S3C_PCM_CLKCTL_SERCLK_EN;\r\n}\r\n}\r\nwritel(clkctl, regs + S3C_PCM_CLKCTL);\r\nwritel(ctl, regs + S3C_PCM_CTL);\r\n}\r\nstatic int s3c_pcm_trigger(struct snd_pcm_substream *substream, int cmd,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\nstruct s3c_pcm_info *pcm = snd_soc_dai_get_drvdata(rtd->cpu_dai);\r\nunsigned long flags;\r\ndev_dbg(pcm->dev, "Entered %s\n", __func__);\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\ncase SNDRV_PCM_TRIGGER_RESUME:\r\ncase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\r\nspin_lock_irqsave(&pcm->lock, flags);\r\nif (substream->stream == SNDRV_PCM_STREAM_CAPTURE)\r\ns3c_pcm_snd_rxctrl(pcm, 1);\r\nelse\r\ns3c_pcm_snd_txctrl(pcm, 1);\r\nspin_unlock_irqrestore(&pcm->lock, flags);\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\ncase SNDRV_PCM_TRIGGER_SUSPEND:\r\ncase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\r\nspin_lock_irqsave(&pcm->lock, flags);\r\nif (substream->stream == SNDRV_PCM_STREAM_CAPTURE)\r\ns3c_pcm_snd_rxctrl(pcm, 0);\r\nelse\r\ns3c_pcm_snd_txctrl(pcm, 0);\r\nspin_unlock_irqrestore(&pcm->lock, flags);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int s3c_pcm_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params,\r\nstruct snd_soc_dai *socdai)\r\n{\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\nstruct s3c_pcm_info *pcm = snd_soc_dai_get_drvdata(rtd->cpu_dai);\r\nstruct s3c_dma_params *dma_data;\r\nvoid __iomem *regs = pcm->regs;\r\nstruct clk *clk;\r\nint sclk_div, sync_div;\r\nunsigned long flags;\r\nu32 clkctl;\r\ndev_dbg(pcm->dev, "Entered %s\n", __func__);\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\r\ndma_data = pcm->dma_playback;\r\nelse\r\ndma_data = pcm->dma_capture;\r\nsnd_soc_dai_set_dma_data(rtd->cpu_dai, substream, dma_data);\r\nswitch (params_format(params)) {\r\ncase SNDRV_PCM_FORMAT_S16_LE:\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nspin_lock_irqsave(&pcm->lock, flags);\r\nclkctl = readl(regs + S3C_PCM_CLKCTL);\r\nif (clkctl & S3C_PCM_CLKCTL_SERCLKSEL_PCLK)\r\nclk = pcm->pclk;\r\nelse\r\nclk = pcm->cclk;\r\nsclk_div = clk_get_rate(clk) / pcm->sclk_per_fs /\r\nparams_rate(params) / 2 - 1;\r\nclkctl &= ~(S3C_PCM_CLKCTL_SCLKDIV_MASK\r\n<< S3C_PCM_CLKCTL_SCLKDIV_SHIFT);\r\nclkctl |= ((sclk_div & S3C_PCM_CLKCTL_SCLKDIV_MASK)\r\n<< S3C_PCM_CLKCTL_SCLKDIV_SHIFT);\r\nsync_div = pcm->sclk_per_fs - 1;\r\nclkctl &= ~(S3C_PCM_CLKCTL_SYNCDIV_MASK\r\n<< S3C_PCM_CLKCTL_SYNCDIV_SHIFT);\r\nclkctl |= ((sync_div & S3C_PCM_CLKCTL_SYNCDIV_MASK)\r\n<< S3C_PCM_CLKCTL_SYNCDIV_SHIFT);\r\nwritel(clkctl, regs + S3C_PCM_CLKCTL);\r\nspin_unlock_irqrestore(&pcm->lock, flags);\r\ndev_dbg(pcm->dev, "PCMSOURCE_CLK-%lu SCLK=%ufs SCLK_DIV=%d SYNC_DIV=%d\n",\r\nclk_get_rate(clk), pcm->sclk_per_fs,\r\nsclk_div, sync_div);\r\nreturn 0;\r\n}\r\nstatic int s3c_pcm_set_fmt(struct snd_soc_dai *cpu_dai,\r\nunsigned int fmt)\r\n{\r\nstruct s3c_pcm_info *pcm = snd_soc_dai_get_drvdata(cpu_dai);\r\nvoid __iomem *regs = pcm->regs;\r\nunsigned long flags;\r\nint ret = 0;\r\nu32 ctl;\r\ndev_dbg(pcm->dev, "Entered %s\n", __func__);\r\nspin_lock_irqsave(&pcm->lock, flags);\r\nctl = readl(regs + S3C_PCM_CTL);\r\nswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\r\ncase SND_SOC_DAIFMT_IB_NF:\r\nbreak;\r\ndefault:\r\ndev_err(pcm->dev, "Unsupported clock inversion!\n");\r\nret = -EINVAL;\r\ngoto exit;\r\n}\r\nswitch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {\r\ncase SND_SOC_DAIFMT_CBS_CFS:\r\nbreak;\r\ndefault:\r\ndev_err(pcm->dev, "Unsupported master/slave format!\n");\r\nret = -EINVAL;\r\ngoto exit;\r\n}\r\nswitch (fmt & SND_SOC_DAIFMT_CLOCK_MASK) {\r\ncase SND_SOC_DAIFMT_CONT:\r\npcm->idleclk = 1;\r\nbreak;\r\ncase SND_SOC_DAIFMT_GATED:\r\npcm->idleclk = 0;\r\nbreak;\r\ndefault:\r\ndev_err(pcm->dev, "Invalid Clock gating request!\n");\r\nret = -EINVAL;\r\ngoto exit;\r\n}\r\nswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\r\ncase SND_SOC_DAIFMT_DSP_A:\r\nctl |= S3C_PCM_CTL_TXMSB_AFTER_FSYNC;\r\nctl |= S3C_PCM_CTL_RXMSB_AFTER_FSYNC;\r\nbreak;\r\ncase SND_SOC_DAIFMT_DSP_B:\r\nctl &= ~S3C_PCM_CTL_TXMSB_AFTER_FSYNC;\r\nctl &= ~S3C_PCM_CTL_RXMSB_AFTER_FSYNC;\r\nbreak;\r\ndefault:\r\ndev_err(pcm->dev, "Unsupported data format!\n");\r\nret = -EINVAL;\r\ngoto exit;\r\n}\r\nwritel(ctl, regs + S3C_PCM_CTL);\r\nexit:\r\nspin_unlock_irqrestore(&pcm->lock, flags);\r\nreturn ret;\r\n}\r\nstatic int s3c_pcm_set_clkdiv(struct snd_soc_dai *cpu_dai,\r\nint div_id, int div)\r\n{\r\nstruct s3c_pcm_info *pcm = snd_soc_dai_get_drvdata(cpu_dai);\r\nswitch (div_id) {\r\ncase S3C_PCM_SCLK_PER_FS:\r\npcm->sclk_per_fs = div;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int s3c_pcm_set_sysclk(struct snd_soc_dai *cpu_dai,\r\nint clk_id, unsigned int freq, int dir)\r\n{\r\nstruct s3c_pcm_info *pcm = snd_soc_dai_get_drvdata(cpu_dai);\r\nvoid __iomem *regs = pcm->regs;\r\nu32 clkctl = readl(regs + S3C_PCM_CLKCTL);\r\nswitch (clk_id) {\r\ncase S3C_PCM_CLKSRC_PCLK:\r\nclkctl |= S3C_PCM_CLKCTL_SERCLKSEL_PCLK;\r\nbreak;\r\ncase S3C_PCM_CLKSRC_MUX:\r\nclkctl &= ~S3C_PCM_CLKCTL_SERCLKSEL_PCLK;\r\nif (clk_get_rate(pcm->cclk) != freq)\r\nclk_set_rate(pcm->cclk, freq);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nwritel(clkctl, regs + S3C_PCM_CLKCTL);\r\nreturn 0;\r\n}\r\nstatic int s3c_pcm_dev_probe(struct platform_device *pdev)\r\n{\r\nstruct s3c_pcm_info *pcm;\r\nstruct resource *mem_res, *dmatx_res, *dmarx_res;\r\nstruct s3c_audio_pdata *pcm_pdata;\r\nint ret;\r\nif ((pdev->id < 0) || pdev->id >= ARRAY_SIZE(s3c_pcm)) {\r\ndev_err(&pdev->dev, "id %d out of range\n", pdev->id);\r\nreturn -EINVAL;\r\n}\r\npcm_pdata = pdev->dev.platform_data;\r\ndmatx_res = platform_get_resource(pdev, IORESOURCE_DMA, 0);\r\nif (!dmatx_res) {\r\ndev_err(&pdev->dev, "Unable to get PCM-TX dma resource\n");\r\nreturn -ENXIO;\r\n}\r\ndmarx_res = platform_get_resource(pdev, IORESOURCE_DMA, 1);\r\nif (!dmarx_res) {\r\ndev_err(&pdev->dev, "Unable to get PCM-RX dma resource\n");\r\nreturn -ENXIO;\r\n}\r\nmem_res = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!mem_res) {\r\ndev_err(&pdev->dev, "Unable to get register resource\n");\r\nreturn -ENXIO;\r\n}\r\nif (pcm_pdata && pcm_pdata->cfg_gpio && pcm_pdata->cfg_gpio(pdev)) {\r\ndev_err(&pdev->dev, "Unable to configure gpio\n");\r\nreturn -EINVAL;\r\n}\r\npcm = &s3c_pcm[pdev->id];\r\npcm->dev = &pdev->dev;\r\nspin_lock_init(&pcm->lock);\r\npcm->sclk_per_fs = 128;\r\npcm->cclk = clk_get(&pdev->dev, "audio-bus");\r\nif (IS_ERR(pcm->cclk)) {\r\ndev_err(&pdev->dev, "failed to get audio-bus\n");\r\nret = PTR_ERR(pcm->cclk);\r\ngoto err1;\r\n}\r\nclk_prepare_enable(pcm->cclk);\r\ndev_set_drvdata(&pdev->dev, pcm);\r\nif (!request_mem_region(mem_res->start,\r\nresource_size(mem_res), "samsung-pcm")) {\r\ndev_err(&pdev->dev, "Unable to request register region\n");\r\nret = -EBUSY;\r\ngoto err2;\r\n}\r\npcm->regs = ioremap(mem_res->start, 0x100);\r\nif (pcm->regs == NULL) {\r\ndev_err(&pdev->dev, "cannot ioremap registers\n");\r\nret = -ENXIO;\r\ngoto err3;\r\n}\r\npcm->pclk = clk_get(&pdev->dev, "pcm");\r\nif (IS_ERR(pcm->pclk)) {\r\ndev_err(&pdev->dev, "failed to get pcm_clock\n");\r\nret = -ENOENT;\r\ngoto err4;\r\n}\r\nclk_prepare_enable(pcm->pclk);\r\ns3c_pcm_stereo_in[pdev->id].dma_addr = mem_res->start\r\n+ S3C_PCM_RXFIFO;\r\ns3c_pcm_stereo_out[pdev->id].dma_addr = mem_res->start\r\n+ S3C_PCM_TXFIFO;\r\ns3c_pcm_stereo_in[pdev->id].channel = dmarx_res->start;\r\ns3c_pcm_stereo_out[pdev->id].channel = dmatx_res->start;\r\npcm->dma_capture = &s3c_pcm_stereo_in[pdev->id];\r\npcm->dma_playback = &s3c_pcm_stereo_out[pdev->id];\r\npm_runtime_enable(&pdev->dev);\r\nret = snd_soc_register_dai(&pdev->dev, &s3c_pcm_dai[pdev->id]);\r\nif (ret != 0) {\r\ndev_err(&pdev->dev, "failed to get register DAI: %d\n", ret);\r\ngoto err5;\r\n}\r\nret = asoc_dma_platform_register(&pdev->dev);\r\nif (ret) {\r\ndev_err(&pdev->dev, "failed to get register DMA: %d\n", ret);\r\ngoto err6;\r\n}\r\nreturn 0;\r\nerr6:\r\nsnd_soc_unregister_dai(&pdev->dev);\r\nerr5:\r\nclk_disable_unprepare(pcm->pclk);\r\nclk_put(pcm->pclk);\r\nerr4:\r\niounmap(pcm->regs);\r\nerr3:\r\nrelease_mem_region(mem_res->start, resource_size(mem_res));\r\nerr2:\r\nclk_disable_unprepare(pcm->cclk);\r\nclk_put(pcm->cclk);\r\nerr1:\r\nreturn ret;\r\n}\r\nstatic int s3c_pcm_dev_remove(struct platform_device *pdev)\r\n{\r\nstruct s3c_pcm_info *pcm = &s3c_pcm[pdev->id];\r\nstruct resource *mem_res;\r\nasoc_dma_platform_unregister(&pdev->dev);\r\nsnd_soc_unregister_dai(&pdev->dev);\r\npm_runtime_disable(&pdev->dev);\r\niounmap(pcm->regs);\r\nmem_res = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nrelease_mem_region(mem_res->start, resource_size(mem_res));\r\nclk_disable_unprepare(pcm->cclk);\r\nclk_disable_unprepare(pcm->pclk);\r\nclk_put(pcm->pclk);\r\nclk_put(pcm->cclk);\r\nreturn 0;\r\n}
