void ad_sd_set_comm(struct ad_sigma_delta *sigma_delta, uint8_t comm)\r\n{\r\nsigma_delta->comm = comm & AD_SD_COMM_CHAN_MASK;\r\n}\r\nint ad_sd_write_reg(struct ad_sigma_delta *sigma_delta, unsigned int reg,\r\nunsigned int size, unsigned int val)\r\n{\r\nuint8_t *data = sigma_delta->data;\r\nstruct spi_transfer t = {\r\n.tx_buf = data,\r\n.len = size + 1,\r\n.cs_change = sigma_delta->bus_locked,\r\n};\r\nstruct spi_message m;\r\nint ret;\r\ndata[0] = (reg << sigma_delta->info->addr_shift) | sigma_delta->comm;\r\nswitch (size) {\r\ncase 3:\r\ndata[1] = val >> 16;\r\ndata[2] = val >> 8;\r\ndata[3] = val;\r\nbreak;\r\ncase 2:\r\nput_unaligned_be16(val, &data[1]);\r\nbreak;\r\ncase 1:\r\ndata[1] = val;\r\nbreak;\r\ncase 0:\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nspi_message_init(&m);\r\nspi_message_add_tail(&t, &m);\r\nif (sigma_delta->bus_locked)\r\nret = spi_sync_locked(sigma_delta->spi, &m);\r\nelse\r\nret = spi_sync(sigma_delta->spi, &m);\r\nreturn ret;\r\n}\r\nstatic int ad_sd_read_reg_raw(struct ad_sigma_delta *sigma_delta,\r\nunsigned int reg, unsigned int size, uint8_t *val)\r\n{\r\nuint8_t *data = sigma_delta->data;\r\nint ret;\r\nstruct spi_transfer t[] = {\r\n{\r\n.tx_buf = data,\r\n.len = 1,\r\n}, {\r\n.rx_buf = val,\r\n.len = size,\r\n.cs_change = sigma_delta->bus_locked,\r\n},\r\n};\r\nstruct spi_message m;\r\nspi_message_init(&m);\r\nif (sigma_delta->info->has_registers) {\r\ndata[0] = reg << sigma_delta->info->addr_shift;\r\ndata[0] |= sigma_delta->info->read_mask;\r\nspi_message_add_tail(&t[0], &m);\r\n}\r\nspi_message_add_tail(&t[1], &m);\r\nif (sigma_delta->bus_locked)\r\nret = spi_sync_locked(sigma_delta->spi, &m);\r\nelse\r\nret = spi_sync(sigma_delta->spi, &m);\r\nreturn ret;\r\n}\r\nint ad_sd_read_reg(struct ad_sigma_delta *sigma_delta,\r\nunsigned int reg, unsigned int size, unsigned int *val)\r\n{\r\nint ret;\r\nret = ad_sd_read_reg_raw(sigma_delta, reg, size, sigma_delta->data);\r\nif (ret < 0)\r\ngoto out;\r\nswitch (size) {\r\ncase 4:\r\n*val = get_unaligned_be32(sigma_delta->data);\r\nbreak;\r\ncase 3:\r\n*val = (sigma_delta->data[0] << 16) |\r\n(sigma_delta->data[1] << 8) |\r\nsigma_delta->data[2];\r\nbreak;\r\ncase 2:\r\n*val = get_unaligned_be16(sigma_delta->data);\r\nbreak;\r\ncase 1:\r\n*val = sigma_delta->data[0];\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nout:\r\nreturn ret;\r\n}\r\nstatic int ad_sd_calibrate(struct ad_sigma_delta *sigma_delta,\r\nunsigned int mode, unsigned int channel)\r\n{\r\nint ret;\r\nret = ad_sigma_delta_set_channel(sigma_delta, channel);\r\nif (ret)\r\nreturn ret;\r\nspi_bus_lock(sigma_delta->spi->master);\r\nsigma_delta->bus_locked = true;\r\nINIT_COMPLETION(sigma_delta->completion);\r\nret = ad_sigma_delta_set_mode(sigma_delta, mode);\r\nif (ret < 0)\r\ngoto out;\r\nsigma_delta->irq_dis = false;\r\nenable_irq(sigma_delta->spi->irq);\r\nret = wait_for_completion_timeout(&sigma_delta->completion, 2*HZ);\r\nif (ret == 0) {\r\nsigma_delta->irq_dis = true;\r\ndisable_irq_nosync(sigma_delta->spi->irq);\r\nret = -EIO;\r\n} else {\r\nret = 0;\r\n}\r\nout:\r\nsigma_delta->bus_locked = false;\r\nspi_bus_unlock(sigma_delta->spi->master);\r\nad_sigma_delta_set_mode(sigma_delta, AD_SD_MODE_IDLE);\r\nreturn ret;\r\n}\r\nint ad_sd_calibrate_all(struct ad_sigma_delta *sigma_delta,\r\nconst struct ad_sd_calib_data *cb, unsigned int n)\r\n{\r\nunsigned int i;\r\nint ret;\r\nfor (i = 0; i < n; i++) {\r\nret = ad_sd_calibrate(sigma_delta, cb[i].mode, cb[i].channel);\r\nif (ret)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nint ad_sigma_delta_single_conversion(struct iio_dev *indio_dev,\r\nconst struct iio_chan_spec *chan, int *val)\r\n{\r\nstruct ad_sigma_delta *sigma_delta = iio_device_get_drvdata(indio_dev);\r\nunsigned int sample, raw_sample;\r\nint ret = 0;\r\nif (iio_buffer_enabled(indio_dev))\r\nreturn -EBUSY;\r\nmutex_lock(&indio_dev->mlock);\r\nad_sigma_delta_set_channel(sigma_delta, chan->address);\r\nspi_bus_lock(sigma_delta->spi->master);\r\nsigma_delta->bus_locked = true;\r\nINIT_COMPLETION(sigma_delta->completion);\r\nad_sigma_delta_set_mode(sigma_delta, AD_SD_MODE_SINGLE);\r\nsigma_delta->irq_dis = false;\r\nenable_irq(sigma_delta->spi->irq);\r\nret = wait_for_completion_interruptible_timeout(\r\n&sigma_delta->completion, HZ);\r\nsigma_delta->bus_locked = false;\r\nspi_bus_unlock(sigma_delta->spi->master);\r\nif (ret == 0)\r\nret = -EIO;\r\nif (ret < 0)\r\ngoto out;\r\nret = ad_sd_read_reg(sigma_delta, AD_SD_REG_DATA,\r\nDIV_ROUND_UP(chan->scan_type.realbits + chan->scan_type.shift, 8),\r\n&raw_sample);\r\nout:\r\nif (!sigma_delta->irq_dis) {\r\ndisable_irq_nosync(sigma_delta->spi->irq);\r\nsigma_delta->irq_dis = true;\r\n}\r\nad_sigma_delta_set_mode(sigma_delta, AD_SD_MODE_IDLE);\r\nmutex_unlock(&indio_dev->mlock);\r\nif (ret)\r\nreturn ret;\r\nsample = raw_sample >> chan->scan_type.shift;\r\nsample &= (1 << chan->scan_type.realbits) - 1;\r\n*val = sample;\r\nret = ad_sigma_delta_postprocess_sample(sigma_delta, raw_sample);\r\nif (ret)\r\nreturn ret;\r\nreturn IIO_VAL_INT;\r\n}\r\nstatic int ad_sd_buffer_postenable(struct iio_dev *indio_dev)\r\n{\r\nstruct ad_sigma_delta *sigma_delta = iio_device_get_drvdata(indio_dev);\r\nunsigned int channel;\r\nint ret;\r\nret = iio_triggered_buffer_postenable(indio_dev);\r\nif (ret < 0)\r\nreturn ret;\r\nchannel = find_first_bit(indio_dev->active_scan_mask,\r\nindio_dev->masklength);\r\nret = ad_sigma_delta_set_channel(sigma_delta,\r\nindio_dev->channels[channel].address);\r\nif (ret)\r\ngoto err_predisable;\r\nspi_bus_lock(sigma_delta->spi->master);\r\nsigma_delta->bus_locked = true;\r\nret = ad_sigma_delta_set_mode(sigma_delta, AD_SD_MODE_CONTINUOUS);\r\nif (ret)\r\ngoto err_unlock;\r\nsigma_delta->irq_dis = false;\r\nenable_irq(sigma_delta->spi->irq);\r\nreturn 0;\r\nerr_unlock:\r\nspi_bus_unlock(sigma_delta->spi->master);\r\nerr_predisable:\r\nreturn ret;\r\n}\r\nstatic int ad_sd_buffer_postdisable(struct iio_dev *indio_dev)\r\n{\r\nstruct ad_sigma_delta *sigma_delta = iio_device_get_drvdata(indio_dev);\r\nINIT_COMPLETION(sigma_delta->completion);\r\nwait_for_completion_timeout(&sigma_delta->completion, HZ);\r\nif (!sigma_delta->irq_dis) {\r\ndisable_irq_nosync(sigma_delta->spi->irq);\r\nsigma_delta->irq_dis = true;\r\n}\r\nad_sigma_delta_set_mode(sigma_delta, AD_SD_MODE_IDLE);\r\nsigma_delta->bus_locked = false;\r\nreturn spi_bus_unlock(sigma_delta->spi->master);\r\n}\r\nstatic irqreturn_t ad_sd_trigger_handler(int irq, void *p)\r\n{\r\nstruct iio_poll_func *pf = p;\r\nstruct iio_dev *indio_dev = pf->indio_dev;\r\nstruct ad_sigma_delta *sigma_delta = iio_device_get_drvdata(indio_dev);\r\nunsigned int reg_size;\r\nuint8_t data[16];\r\nint ret;\r\nmemset(data, 0x00, 16);\r\nif (indio_dev->scan_timestamp)\r\n((s64 *)data)[1] = pf->timestamp;\r\nreg_size = indio_dev->channels[0].scan_type.realbits +\r\nindio_dev->channels[0].scan_type.shift;\r\nreg_size = DIV_ROUND_UP(reg_size, 8);\r\nswitch (reg_size) {\r\ncase 4:\r\ncase 2:\r\ncase 1:\r\nret = ad_sd_read_reg_raw(sigma_delta, AD_SD_REG_DATA,\r\nreg_size, &data[0]);\r\nbreak;\r\ncase 3:\r\nret = ad_sd_read_reg_raw(sigma_delta, AD_SD_REG_DATA,\r\nreg_size, &data[1]);\r\nbreak;\r\n}\r\niio_push_to_buffers(indio_dev, (uint8_t *)data);\r\niio_trigger_notify_done(indio_dev->trig);\r\nsigma_delta->irq_dis = false;\r\nenable_irq(sigma_delta->spi->irq);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t ad_sd_data_rdy_trig_poll(int irq, void *private)\r\n{\r\nstruct ad_sigma_delta *sigma_delta = private;\r\ncomplete(&sigma_delta->completion);\r\ndisable_irq_nosync(irq);\r\nsigma_delta->irq_dis = true;\r\niio_trigger_poll(sigma_delta->trig, iio_get_time_ns());\r\nreturn IRQ_HANDLED;\r\n}\r\nint ad_sd_validate_trigger(struct iio_dev *indio_dev, struct iio_trigger *trig)\r\n{\r\nstruct ad_sigma_delta *sigma_delta = iio_device_get_drvdata(indio_dev);\r\nif (sigma_delta->trig != trig)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int ad_sd_probe_trigger(struct iio_dev *indio_dev)\r\n{\r\nstruct ad_sigma_delta *sigma_delta = iio_device_get_drvdata(indio_dev);\r\nint ret;\r\nsigma_delta->trig = iio_trigger_alloc("%s-dev%d", indio_dev->name,\r\nindio_dev->id);\r\nif (sigma_delta->trig == NULL) {\r\nret = -ENOMEM;\r\ngoto error_ret;\r\n}\r\nsigma_delta->trig->ops = &ad_sd_trigger_ops;\r\ninit_completion(&sigma_delta->completion);\r\nret = request_irq(sigma_delta->spi->irq,\r\nad_sd_data_rdy_trig_poll,\r\nIRQF_TRIGGER_LOW,\r\nindio_dev->name,\r\nsigma_delta);\r\nif (ret)\r\ngoto error_free_trig;\r\nif (!sigma_delta->irq_dis) {\r\nsigma_delta->irq_dis = true;\r\ndisable_irq_nosync(sigma_delta->spi->irq);\r\n}\r\nsigma_delta->trig->dev.parent = &sigma_delta->spi->dev;\r\nsigma_delta->trig->private_data = sigma_delta;\r\nret = iio_trigger_register(sigma_delta->trig);\r\nif (ret)\r\ngoto error_free_irq;\r\nindio_dev->trig = sigma_delta->trig;\r\nreturn 0;\r\nerror_free_irq:\r\nfree_irq(sigma_delta->spi->irq, sigma_delta);\r\nerror_free_trig:\r\niio_trigger_free(sigma_delta->trig);\r\nerror_ret:\r\nreturn ret;\r\n}\r\nstatic void ad_sd_remove_trigger(struct iio_dev *indio_dev)\r\n{\r\nstruct ad_sigma_delta *sigma_delta = iio_device_get_drvdata(indio_dev);\r\niio_trigger_unregister(sigma_delta->trig);\r\nfree_irq(sigma_delta->spi->irq, sigma_delta);\r\niio_trigger_free(sigma_delta->trig);\r\n}\r\nint ad_sd_setup_buffer_and_trigger(struct iio_dev *indio_dev)\r\n{\r\nint ret;\r\nret = iio_triggered_buffer_setup(indio_dev, &iio_pollfunc_store_time,\r\n&ad_sd_trigger_handler, &ad_sd_buffer_setup_ops);\r\nif (ret)\r\nreturn ret;\r\nret = ad_sd_probe_trigger(indio_dev);\r\nif (ret) {\r\niio_triggered_buffer_cleanup(indio_dev);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nvoid ad_sd_cleanup_buffer_and_trigger(struct iio_dev *indio_dev)\r\n{\r\nad_sd_remove_trigger(indio_dev);\r\niio_triggered_buffer_cleanup(indio_dev);\r\n}\r\nint ad_sd_init(struct ad_sigma_delta *sigma_delta, struct iio_dev *indio_dev,\r\nstruct spi_device *spi, const struct ad_sigma_delta_info *info)\r\n{\r\nsigma_delta->spi = spi;\r\nsigma_delta->info = info;\r\niio_device_set_drvdata(indio_dev, sigma_delta);\r\nreturn 0;\r\n}
