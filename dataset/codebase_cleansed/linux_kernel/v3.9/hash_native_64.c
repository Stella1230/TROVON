static inline void __tlbie(unsigned long vpn, int psize, int ssize)\r\n{\r\nunsigned long va;\r\nunsigned int penc;\r\nva = vpn << VPN_SHIFT;\r\nva &= ~(0xffffULL << 48);\r\nswitch (psize) {\r\ncase MMU_PAGE_4K:\r\nva |= ssize << 8;\r\nasm volatile(ASM_FTR_IFCLR("tlbie %0,0", PPC_TLBIE(%1,%0), %2)\r\n: : "r" (va), "r"(0), "i" (CPU_FTR_ARCH_206)\r\n: "memory");\r\nbreak;\r\ndefault:\r\npenc = mmu_psize_defs[psize].penc;\r\nva &= ~((1ul << mmu_psize_defs[psize].shift) - 1);\r\nva |= penc << 12;\r\nva |= ssize << 8;\r\nva |= 1;\r\nasm volatile(ASM_FTR_IFCLR("tlbie %0,1", PPC_TLBIE(%1,%0), %2)\r\n: : "r" (va), "r"(0), "i" (CPU_FTR_ARCH_206)\r\n: "memory");\r\nbreak;\r\n}\r\n}\r\nstatic inline void __tlbiel(unsigned long vpn, int psize, int ssize)\r\n{\r\nunsigned long va;\r\nunsigned int penc;\r\nva = vpn << VPN_SHIFT;\r\nva &= ~(0xffffULL << 48);\r\nswitch (psize) {\r\ncase MMU_PAGE_4K:\r\nva |= ssize << 8;\r\nasm volatile(".long 0x7c000224 | (%0 << 11) | (0 << 21)"\r\n: : "r"(va) : "memory");\r\nbreak;\r\ndefault:\r\npenc = mmu_psize_defs[psize].penc;\r\nva &= ~((1ul << mmu_psize_defs[psize].shift) - 1);\r\nva |= penc << 12;\r\nva |= ssize << 8;\r\nva |= 1;\r\nasm volatile(".long 0x7c000224 | (%0 << 11) | (1 << 21)"\r\n: : "r"(va) : "memory");\r\nbreak;\r\n}\r\n}\r\nstatic inline void tlbie(unsigned long vpn, int psize, int ssize, int local)\r\n{\r\nunsigned int use_local = local && mmu_has_feature(MMU_FTR_TLBIEL);\r\nint lock_tlbie = !mmu_has_feature(MMU_FTR_LOCKLESS_TLBIE);\r\nif (use_local)\r\nuse_local = mmu_psize_defs[psize].tlbiel;\r\nif (lock_tlbie && !use_local)\r\nraw_spin_lock(&native_tlbie_lock);\r\nasm volatile("ptesync": : :"memory");\r\nif (use_local) {\r\n__tlbiel(vpn, psize, ssize);\r\nasm volatile("ptesync": : :"memory");\r\n} else {\r\n__tlbie(vpn, psize, ssize);\r\nasm volatile("eieio; tlbsync; ptesync": : :"memory");\r\n}\r\nif (lock_tlbie && !use_local)\r\nraw_spin_unlock(&native_tlbie_lock);\r\n}\r\nstatic inline void native_lock_hpte(struct hash_pte *hptep)\r\n{\r\nunsigned long *word = &hptep->v;\r\nwhile (1) {\r\nif (!test_and_set_bit_lock(HPTE_LOCK_BIT, word))\r\nbreak;\r\nwhile(test_bit(HPTE_LOCK_BIT, word))\r\ncpu_relax();\r\n}\r\n}\r\nstatic inline void native_unlock_hpte(struct hash_pte *hptep)\r\n{\r\nunsigned long *word = &hptep->v;\r\nclear_bit_unlock(HPTE_LOCK_BIT, word);\r\n}\r\nstatic long native_hpte_insert(unsigned long hpte_group, unsigned long vpn,\r\nunsigned long pa, unsigned long rflags,\r\nunsigned long vflags, int psize, int ssize)\r\n{\r\nstruct hash_pte *hptep = htab_address + hpte_group;\r\nunsigned long hpte_v, hpte_r;\r\nint i;\r\nif (!(vflags & HPTE_V_BOLTED)) {\r\nDBG_LOW(" insert(group=%lx, vpn=%016lx, pa=%016lx,"\r\n" rflags=%lx, vflags=%lx, psize=%d)\n",\r\nhpte_group, vpn, pa, rflags, vflags, psize);\r\n}\r\nfor (i = 0; i < HPTES_PER_GROUP; i++) {\r\nif (! (hptep->v & HPTE_V_VALID)) {\r\nnative_lock_hpte(hptep);\r\nif (! (hptep->v & HPTE_V_VALID))\r\nbreak;\r\nnative_unlock_hpte(hptep);\r\n}\r\nhptep++;\r\n}\r\nif (i == HPTES_PER_GROUP)\r\nreturn -1;\r\nhpte_v = hpte_encode_v(vpn, psize, ssize) | vflags | HPTE_V_VALID;\r\nhpte_r = hpte_encode_r(pa, psize) | rflags;\r\nif (!(vflags & HPTE_V_BOLTED)) {\r\nDBG_LOW(" i=%x hpte_v=%016lx, hpte_r=%016lx\n",\r\ni, hpte_v, hpte_r);\r\n}\r\nhptep->r = hpte_r;\r\neieio();\r\nhptep->v = hpte_v;\r\n__asm__ __volatile__ ("ptesync" : : : "memory");\r\nreturn i | (!!(vflags & HPTE_V_SECONDARY) << 3);\r\n}\r\nstatic long native_hpte_remove(unsigned long hpte_group)\r\n{\r\nstruct hash_pte *hptep;\r\nint i;\r\nint slot_offset;\r\nunsigned long hpte_v;\r\nDBG_LOW(" remove(group=%lx)\n", hpte_group);\r\nslot_offset = mftb() & 0x7;\r\nfor (i = 0; i < HPTES_PER_GROUP; i++) {\r\nhptep = htab_address + hpte_group + slot_offset;\r\nhpte_v = hptep->v;\r\nif ((hpte_v & HPTE_V_VALID) && !(hpte_v & HPTE_V_BOLTED)) {\r\nnative_lock_hpte(hptep);\r\nhpte_v = hptep->v;\r\nif ((hpte_v & HPTE_V_VALID)\r\n&& !(hpte_v & HPTE_V_BOLTED))\r\nbreak;\r\nnative_unlock_hpte(hptep);\r\n}\r\nslot_offset++;\r\nslot_offset &= 0x7;\r\n}\r\nif (i == HPTES_PER_GROUP)\r\nreturn -1;\r\nhptep->v = 0;\r\nreturn i;\r\n}\r\nstatic long native_hpte_updatepp(unsigned long slot, unsigned long newpp,\r\nunsigned long vpn, int psize, int ssize,\r\nint local)\r\n{\r\nstruct hash_pte *hptep = htab_address + slot;\r\nunsigned long hpte_v, want_v;\r\nint ret = 0;\r\nwant_v = hpte_encode_v(vpn, psize, ssize);\r\nDBG_LOW(" update(vpn=%016lx, avpnv=%016lx, group=%lx, newpp=%lx)",\r\nvpn, want_v & HPTE_V_AVPN, slot, newpp);\r\nnative_lock_hpte(hptep);\r\nhpte_v = hptep->v;\r\nif (!HPTE_V_COMPARE(hpte_v, want_v) || !(hpte_v & HPTE_V_VALID)) {\r\nDBG_LOW(" -> miss\n");\r\nret = -1;\r\n} else {\r\nDBG_LOW(" -> hit\n");\r\nhptep->r = (hptep->r & ~(HPTE_R_PP | HPTE_R_N)) |\r\n(newpp & (HPTE_R_PP | HPTE_R_N | HPTE_R_C));\r\n}\r\nnative_unlock_hpte(hptep);\r\ntlbie(vpn, psize, ssize, local);\r\nreturn ret;\r\n}\r\nstatic long native_hpte_find(unsigned long vpn, int psize, int ssize)\r\n{\r\nstruct hash_pte *hptep;\r\nunsigned long hash;\r\nunsigned long i;\r\nlong slot;\r\nunsigned long want_v, hpte_v;\r\nhash = hpt_hash(vpn, mmu_psize_defs[psize].shift, ssize);\r\nwant_v = hpte_encode_v(vpn, psize, ssize);\r\nslot = (hash & htab_hash_mask) * HPTES_PER_GROUP;\r\nfor (i = 0; i < HPTES_PER_GROUP; i++) {\r\nhptep = htab_address + slot;\r\nhpte_v = hptep->v;\r\nif (HPTE_V_COMPARE(hpte_v, want_v) && (hpte_v & HPTE_V_VALID))\r\nreturn slot;\r\n++slot;\r\n}\r\nreturn -1;\r\n}\r\nstatic void native_hpte_updateboltedpp(unsigned long newpp, unsigned long ea,\r\nint psize, int ssize)\r\n{\r\nunsigned long vpn;\r\nunsigned long vsid;\r\nlong slot;\r\nstruct hash_pte *hptep;\r\nvsid = get_kernel_vsid(ea, ssize);\r\nvpn = hpt_vpn(ea, vsid, ssize);\r\nslot = native_hpte_find(vpn, psize, ssize);\r\nif (slot == -1)\r\npanic("could not find page to bolt\n");\r\nhptep = htab_address + slot;\r\nhptep->r = (hptep->r & ~(HPTE_R_PP | HPTE_R_N)) |\r\n(newpp & (HPTE_R_PP | HPTE_R_N));\r\ntlbie(vpn, psize, ssize, 0);\r\n}\r\nstatic void native_hpte_invalidate(unsigned long slot, unsigned long vpn,\r\nint psize, int ssize, int local)\r\n{\r\nstruct hash_pte *hptep = htab_address + slot;\r\nunsigned long hpte_v;\r\nunsigned long want_v;\r\nunsigned long flags;\r\nlocal_irq_save(flags);\r\nDBG_LOW(" invalidate(vpn=%016lx, hash: %lx)\n", vpn, slot);\r\nwant_v = hpte_encode_v(vpn, psize, ssize);\r\nnative_lock_hpte(hptep);\r\nhpte_v = hptep->v;\r\nif (!HPTE_V_COMPARE(hpte_v, want_v) || !(hpte_v & HPTE_V_VALID))\r\nnative_unlock_hpte(hptep);\r\nelse\r\nhptep->v = 0;\r\ntlbie(vpn, psize, ssize, local);\r\nlocal_irq_restore(flags);\r\n}\r\nstatic void hpte_decode(struct hash_pte *hpte, unsigned long slot,\r\nint *psize, int *ssize, unsigned long *vpn)\r\n{\r\nunsigned long avpn, pteg, vpi;\r\nunsigned long hpte_r = hpte->r;\r\nunsigned long hpte_v = hpte->v;\r\nunsigned long vsid, seg_off;\r\nint i, size, shift, penc;\r\nif (!(hpte_v & HPTE_V_LARGE))\r\nsize = MMU_PAGE_4K;\r\nelse {\r\nfor (i = 0; i < LP_BITS; i++) {\r\nif ((hpte_r & LP_MASK(i+1)) == LP_MASK(i+1))\r\nbreak;\r\n}\r\npenc = LP_MASK(i+1) >> LP_SHIFT;\r\nfor (size = 0; size < MMU_PAGE_COUNT; size++) {\r\nif (size == MMU_PAGE_4K)\r\ncontinue;\r\nif (!mmu_psize_defs[size].shift)\r\ncontinue;\r\nif (penc == mmu_psize_defs[size].penc)\r\nbreak;\r\n}\r\n}\r\n*ssize = hpte_v >> HPTE_V_SSIZE_SHIFT;\r\nshift = mmu_psize_defs[size].shift;\r\navpn = (HPTE_V_AVPN_VAL(hpte_v) & ~mmu_psize_defs[size].avpnm);\r\npteg = slot / HPTES_PER_GROUP;\r\nif (hpte_v & HPTE_V_SECONDARY)\r\npteg = ~pteg;\r\nswitch (*ssize) {\r\ncase MMU_SEGSIZE_256M:\r\nseg_off = (avpn & 0x1f) << 23;\r\nvsid = avpn >> 5;\r\nif (shift < 23) {\r\nvpi = (vsid ^ pteg) & htab_hash_mask;\r\nseg_off |= vpi << shift;\r\n}\r\n*vpn = vsid << (SID_SHIFT - VPN_SHIFT) | seg_off >> VPN_SHIFT;\r\ncase MMU_SEGSIZE_1T:\r\nseg_off = (avpn & 0x1ffff) << 23;\r\nvsid = avpn >> 17;\r\nif (shift < 23) {\r\nvpi = (vsid ^ (vsid << 25) ^ pteg) & htab_hash_mask;\r\nseg_off |= vpi << shift;\r\n}\r\n*vpn = vsid << (SID_SHIFT_1T - VPN_SHIFT) | seg_off >> VPN_SHIFT;\r\ndefault:\r\n*vpn = size = 0;\r\n}\r\n*psize = size;\r\n}\r\nstatic void native_hpte_clear(void)\r\n{\r\nunsigned long vpn = 0;\r\nunsigned long slot, slots, flags;\r\nstruct hash_pte *hptep = htab_address;\r\nunsigned long hpte_v;\r\nunsigned long pteg_count;\r\nint psize, ssize;\r\npteg_count = htab_hash_mask + 1;\r\nlocal_irq_save(flags);\r\nraw_spin_lock(&native_tlbie_lock);\r\nslots = pteg_count * HPTES_PER_GROUP;\r\nfor (slot = 0; slot < slots; slot++, hptep++) {\r\nhpte_v = hptep->v;\r\nif (hpte_v & HPTE_V_VALID) {\r\nhpte_decode(hptep, slot, &psize, &ssize, &vpn);\r\nhptep->v = 0;\r\n__tlbie(vpn, psize, ssize);\r\n}\r\n}\r\nasm volatile("eieio; tlbsync; ptesync":::"memory");\r\nraw_spin_unlock(&native_tlbie_lock);\r\nlocal_irq_restore(flags);\r\n}\r\nstatic void native_flush_hash_range(unsigned long number, int local)\r\n{\r\nunsigned long vpn;\r\nunsigned long hash, index, hidx, shift, slot;\r\nstruct hash_pte *hptep;\r\nunsigned long hpte_v;\r\nunsigned long want_v;\r\nunsigned long flags;\r\nreal_pte_t pte;\r\nstruct ppc64_tlb_batch *batch = &__get_cpu_var(ppc64_tlb_batch);\r\nunsigned long psize = batch->psize;\r\nint ssize = batch->ssize;\r\nint i;\r\nlocal_irq_save(flags);\r\nfor (i = 0; i < number; i++) {\r\nvpn = batch->vpn[i];\r\npte = batch->pte[i];\r\npte_iterate_hashed_subpages(pte, psize, vpn, index, shift) {\r\nhash = hpt_hash(vpn, shift, ssize);\r\nhidx = __rpte_to_hidx(pte, index);\r\nif (hidx & _PTEIDX_SECONDARY)\r\nhash = ~hash;\r\nslot = (hash & htab_hash_mask) * HPTES_PER_GROUP;\r\nslot += hidx & _PTEIDX_GROUP_IX;\r\nhptep = htab_address + slot;\r\nwant_v = hpte_encode_v(vpn, psize, ssize);\r\nnative_lock_hpte(hptep);\r\nhpte_v = hptep->v;\r\nif (!HPTE_V_COMPARE(hpte_v, want_v) ||\r\n!(hpte_v & HPTE_V_VALID))\r\nnative_unlock_hpte(hptep);\r\nelse\r\nhptep->v = 0;\r\n} pte_iterate_hashed_end();\r\n}\r\nif (mmu_has_feature(MMU_FTR_TLBIEL) &&\r\nmmu_psize_defs[psize].tlbiel && local) {\r\nasm volatile("ptesync":::"memory");\r\nfor (i = 0; i < number; i++) {\r\nvpn = batch->vpn[i];\r\npte = batch->pte[i];\r\npte_iterate_hashed_subpages(pte, psize,\r\nvpn, index, shift) {\r\n__tlbiel(vpn, psize, ssize);\r\n} pte_iterate_hashed_end();\r\n}\r\nasm volatile("ptesync":::"memory");\r\n} else {\r\nint lock_tlbie = !mmu_has_feature(MMU_FTR_LOCKLESS_TLBIE);\r\nif (lock_tlbie)\r\nraw_spin_lock(&native_tlbie_lock);\r\nasm volatile("ptesync":::"memory");\r\nfor (i = 0; i < number; i++) {\r\nvpn = batch->vpn[i];\r\npte = batch->pte[i];\r\npte_iterate_hashed_subpages(pte, psize,\r\nvpn, index, shift) {\r\n__tlbie(vpn, psize, ssize);\r\n} pte_iterate_hashed_end();\r\n}\r\nasm volatile("eieio; tlbsync; ptesync":::"memory");\r\nif (lock_tlbie)\r\nraw_spin_unlock(&native_tlbie_lock);\r\n}\r\nlocal_irq_restore(flags);\r\n}\r\nvoid __init hpte_init_native(void)\r\n{\r\nppc_md.hpte_invalidate = native_hpte_invalidate;\r\nppc_md.hpte_updatepp = native_hpte_updatepp;\r\nppc_md.hpte_updateboltedpp = native_hpte_updateboltedpp;\r\nppc_md.hpte_insert = native_hpte_insert;\r\nppc_md.hpte_remove = native_hpte_remove;\r\nppc_md.hpte_clear_all = native_hpte_clear;\r\nppc_md.flush_hash_range = native_flush_hash_range;\r\n}
