static unsigned long clk_cpu_recalc_rate(struct clk_hw *hwclk,\r\nunsigned long parent_rate)\r\n{\r\nstruct cpu_clk *cpuclk = to_cpu_clk(hwclk);\r\nu32 reg, div;\r\nreg = readl(cpuclk->reg_base + SYS_CTRL_CLK_DIVIDER_VALUE_OFFSET);\r\ndiv = (reg >> (cpuclk->cpu * 8)) & SYS_CTRL_CLK_DIVIDER_MASK;\r\nreturn parent_rate / div;\r\n}\r\nstatic long clk_cpu_round_rate(struct clk_hw *hwclk, unsigned long rate,\r\nunsigned long *parent_rate)\r\n{\r\nu32 div;\r\ndiv = *parent_rate / rate;\r\nif (div == 0)\r\ndiv = 1;\r\nelse if (div > 3)\r\ndiv = 3;\r\nreturn *parent_rate / div;\r\n}\r\nstatic int clk_cpu_set_rate(struct clk_hw *hwclk, unsigned long rate,\r\nunsigned long parent_rate)\r\n{\r\nstruct cpu_clk *cpuclk = to_cpu_clk(hwclk);\r\nu32 reg, div;\r\nu32 reload_mask;\r\ndiv = parent_rate / rate;\r\nreg = (readl(cpuclk->reg_base + SYS_CTRL_CLK_DIVIDER_VALUE_OFFSET)\r\n& (~(SYS_CTRL_CLK_DIVIDER_MASK << (cpuclk->cpu * 8))))\r\n| (div << (cpuclk->cpu * 8));\r\nwritel(reg, cpuclk->reg_base + SYS_CTRL_CLK_DIVIDER_VALUE_OFFSET);\r\nreload_mask = 1 << (20 + cpuclk->cpu);\r\nreg = readl(cpuclk->reg_base + SYS_CTRL_CLK_DIVIDER_CTRL_OFFSET)\r\n| reload_mask;\r\nwritel(reg, cpuclk->reg_base + SYS_CTRL_CLK_DIVIDER_CTRL_OFFSET);\r\nreg = readl(cpuclk->reg_base + SYS_CTRL_CLK_DIVIDER_CTRL_OFFSET)\r\n| 1 << 24;\r\nwritel(reg, cpuclk->reg_base + SYS_CTRL_CLK_DIVIDER_CTRL_OFFSET);\r\nudelay(1000);\r\nreg &= ~(reload_mask | 1 << 24);\r\nwritel(reg, cpuclk->reg_base + SYS_CTRL_CLK_DIVIDER_CTRL_OFFSET);\r\nudelay(1000);\r\nreturn 0;\r\n}\r\nvoid __init of_cpu_clk_setup(struct device_node *node)\r\n{\r\nstruct cpu_clk *cpuclk;\r\nvoid __iomem *clock_complex_base = of_iomap(node, 0);\r\nint ncpus = 0;\r\nstruct device_node *dn;\r\nif (clock_complex_base == NULL) {\r\npr_err("%s: clock-complex base register not set\n",\r\n__func__);\r\nreturn;\r\n}\r\nfor_each_node_by_type(dn, "cpu")\r\nncpus++;\r\ncpuclk = kzalloc(ncpus * sizeof(*cpuclk), GFP_KERNEL);\r\nif (WARN_ON(!cpuclk))\r\nreturn;\r\nclks = kzalloc(ncpus * sizeof(*clks), GFP_KERNEL);\r\nif (WARN_ON(!clks))\r\ngoto clks_out;\r\nfor_each_node_by_type(dn, "cpu") {\r\nstruct clk_init_data init;\r\nstruct clk *clk;\r\nstruct clk *parent_clk;\r\nchar *clk_name = kzalloc(5, GFP_KERNEL);\r\nint cpu, err;\r\nif (WARN_ON(!clk_name))\r\ngoto bail_out;\r\nerr = of_property_read_u32(dn, "reg", &cpu);\r\nif (WARN_ON(err))\r\ngoto bail_out;\r\nsprintf(clk_name, "cpu%d", cpu);\r\nparent_clk = of_clk_get(node, 0);\r\ncpuclk[cpu].parent_name = __clk_get_name(parent_clk);\r\ncpuclk[cpu].clk_name = clk_name;\r\ncpuclk[cpu].cpu = cpu;\r\ncpuclk[cpu].reg_base = clock_complex_base;\r\ncpuclk[cpu].hw.init = &init;\r\ninit.name = cpuclk[cpu].clk_name;\r\ninit.ops = &cpu_ops;\r\ninit.flags = 0;\r\ninit.parent_names = &cpuclk[cpu].parent_name;\r\ninit.num_parents = 1;\r\nclk = clk_register(NULL, &cpuclk[cpu].hw);\r\nif (WARN_ON(IS_ERR(clk)))\r\ngoto bail_out;\r\nclks[cpu] = clk;\r\n}\r\nclk_data.clk_num = MAX_CPU;\r\nclk_data.clks = clks;\r\nof_clk_add_provider(node, of_clk_src_onecell_get, &clk_data);\r\nreturn;\r\nbail_out:\r\nkfree(clks);\r\nwhile(ncpus--)\r\nkfree(cpuclk[ncpus].clk_name);\r\nclks_out:\r\nkfree(cpuclk);\r\n}\r\nvoid __init mvebu_cpu_clk_init(void)\r\n{\r\nof_clk_init(clk_cpu_match);\r\n}
