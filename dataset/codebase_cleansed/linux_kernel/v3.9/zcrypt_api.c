static ssize_t zcrypt_type_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct zcrypt_device *zdev = to_ap_dev(dev)->private;\r\nreturn snprintf(buf, PAGE_SIZE, "%s\n", zdev->type_string);\r\n}\r\nstatic ssize_t zcrypt_online_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct zcrypt_device *zdev = to_ap_dev(dev)->private;\r\nreturn snprintf(buf, PAGE_SIZE, "%d\n", zdev->online);\r\n}\r\nstatic ssize_t zcrypt_online_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct zcrypt_device *zdev = to_ap_dev(dev)->private;\r\nint online;\r\nif (sscanf(buf, "%d\n", &online) != 1 || online < 0 || online > 1)\r\nreturn -EINVAL;\r\nzdev->online = online;\r\nZCRYPT_DBF_DEV(DBF_INFO, zdev, "dev%04xo%dman", zdev->ap_dev->qid,\r\nzdev->online);\r\nif (!online)\r\nap_flush_queue(zdev->ap_dev);\r\nreturn count;\r\n}\r\nstatic inline int zcrypt_process_rescan(void)\r\n{\r\nif (atomic_read(&zcrypt_rescan_req)) {\r\natomic_set(&zcrypt_rescan_req, 0);\r\natomic_inc(&zcrypt_rescan_count);\r\nap_bus_force_rescan();\r\nZCRYPT_DBF_COMMON(DBF_INFO, "rescan%07d",\r\natomic_inc_return(&zcrypt_rescan_count));\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic void __zcrypt_increase_preference(struct zcrypt_device *zdev)\r\n{\r\nstruct zcrypt_device *tmp;\r\nstruct list_head *l;\r\nif (zdev->speed_rating == 0)\r\nreturn;\r\nfor (l = zdev->list.prev; l != &zcrypt_device_list; l = l->prev) {\r\ntmp = list_entry(l, struct zcrypt_device, list);\r\nif ((tmp->request_count + 1) * tmp->speed_rating <=\r\n(zdev->request_count + 1) * zdev->speed_rating &&\r\ntmp->speed_rating != 0)\r\nbreak;\r\n}\r\nif (l == zdev->list.prev)\r\nreturn;\r\nlist_move(&zdev->list, l);\r\n}\r\nstatic void __zcrypt_decrease_preference(struct zcrypt_device *zdev)\r\n{\r\nstruct zcrypt_device *tmp;\r\nstruct list_head *l;\r\nif (zdev->speed_rating == 0)\r\nreturn;\r\nfor (l = zdev->list.next; l != &zcrypt_device_list; l = l->next) {\r\ntmp = list_entry(l, struct zcrypt_device, list);\r\nif ((tmp->request_count + 1) * tmp->speed_rating >\r\n(zdev->request_count + 1) * zdev->speed_rating ||\r\ntmp->speed_rating == 0)\r\nbreak;\r\n}\r\nif (l == zdev->list.next)\r\nreturn;\r\nlist_move_tail(&zdev->list, l);\r\n}\r\nstatic void zcrypt_device_release(struct kref *kref)\r\n{\r\nstruct zcrypt_device *zdev =\r\ncontainer_of(kref, struct zcrypt_device, refcount);\r\nzcrypt_device_free(zdev);\r\n}\r\nvoid zcrypt_device_get(struct zcrypt_device *zdev)\r\n{\r\nkref_get(&zdev->refcount);\r\n}\r\nint zcrypt_device_put(struct zcrypt_device *zdev)\r\n{\r\nreturn kref_put(&zdev->refcount, zcrypt_device_release);\r\n}\r\nstruct zcrypt_device *zcrypt_device_alloc(size_t max_response_size)\r\n{\r\nstruct zcrypt_device *zdev;\r\nzdev = kzalloc(sizeof(struct zcrypt_device), GFP_KERNEL);\r\nif (!zdev)\r\nreturn NULL;\r\nzdev->reply.message = kmalloc(max_response_size, GFP_KERNEL);\r\nif (!zdev->reply.message)\r\ngoto out_free;\r\nzdev->reply.length = max_response_size;\r\nspin_lock_init(&zdev->lock);\r\nINIT_LIST_HEAD(&zdev->list);\r\nzdev->dbf_area = zcrypt_dbf_devices;\r\nreturn zdev;\r\nout_free:\r\nkfree(zdev);\r\nreturn NULL;\r\n}\r\nvoid zcrypt_device_free(struct zcrypt_device *zdev)\r\n{\r\nkfree(zdev->reply.message);\r\nkfree(zdev);\r\n}\r\nint zcrypt_device_register(struct zcrypt_device *zdev)\r\n{\r\nint rc;\r\nif (!zdev->ops)\r\nreturn -ENODEV;\r\nrc = sysfs_create_group(&zdev->ap_dev->device.kobj,\r\n&zcrypt_device_attr_group);\r\nif (rc)\r\ngoto out;\r\nget_device(&zdev->ap_dev->device);\r\nkref_init(&zdev->refcount);\r\nspin_lock_bh(&zcrypt_device_lock);\r\nzdev->online = 1;\r\nZCRYPT_DBF_DEV(DBF_INFO, zdev, "dev%04xo%dreg", zdev->ap_dev->qid,\r\nzdev->online);\r\nlist_add_tail(&zdev->list, &zcrypt_device_list);\r\n__zcrypt_increase_preference(zdev);\r\nzcrypt_device_count++;\r\nspin_unlock_bh(&zcrypt_device_lock);\r\nif (zdev->ops->rng) {\r\nrc = zcrypt_rng_device_add();\r\nif (rc)\r\ngoto out_unregister;\r\n}\r\nreturn 0;\r\nout_unregister:\r\nspin_lock_bh(&zcrypt_device_lock);\r\nzcrypt_device_count--;\r\nlist_del_init(&zdev->list);\r\nspin_unlock_bh(&zcrypt_device_lock);\r\nsysfs_remove_group(&zdev->ap_dev->device.kobj,\r\n&zcrypt_device_attr_group);\r\nput_device(&zdev->ap_dev->device);\r\nzcrypt_device_put(zdev);\r\nout:\r\nreturn rc;\r\n}\r\nvoid zcrypt_device_unregister(struct zcrypt_device *zdev)\r\n{\r\nif (zdev->ops->rng)\r\nzcrypt_rng_device_remove();\r\nspin_lock_bh(&zcrypt_device_lock);\r\nzcrypt_device_count--;\r\nlist_del_init(&zdev->list);\r\nspin_unlock_bh(&zcrypt_device_lock);\r\nsysfs_remove_group(&zdev->ap_dev->device.kobj,\r\n&zcrypt_device_attr_group);\r\nput_device(&zdev->ap_dev->device);\r\nzcrypt_device_put(zdev);\r\n}\r\nvoid zcrypt_msgtype_register(struct zcrypt_ops *zops)\r\n{\r\nif (zops->owner) {\r\nspin_lock_bh(&zcrypt_ops_list_lock);\r\nlist_add_tail(&zops->list, &zcrypt_ops_list);\r\nspin_unlock_bh(&zcrypt_ops_list_lock);\r\n}\r\n}\r\nvoid zcrypt_msgtype_unregister(struct zcrypt_ops *zops)\r\n{\r\nspin_lock_bh(&zcrypt_ops_list_lock);\r\nlist_del_init(&zops->list);\r\nspin_unlock_bh(&zcrypt_ops_list_lock);\r\n}\r\nstatic inline\r\nstruct zcrypt_ops *__ops_lookup(unsigned char *name, int variant)\r\n{\r\nstruct zcrypt_ops *zops;\r\nint found = 0;\r\nspin_lock_bh(&zcrypt_ops_list_lock);\r\nlist_for_each_entry(zops, &zcrypt_ops_list, list) {\r\nif ((zops->variant == variant) &&\r\n(!strncmp(zops->owner->name, name, MODULE_NAME_LEN))) {\r\nfound = 1;\r\nbreak;\r\n}\r\n}\r\nspin_unlock_bh(&zcrypt_ops_list_lock);\r\nif (!found)\r\nreturn NULL;\r\nreturn zops;\r\n}\r\nstruct zcrypt_ops *zcrypt_msgtype_request(unsigned char *name, int variant)\r\n{\r\nstruct zcrypt_ops *zops = NULL;\r\nzops = __ops_lookup(name, variant);\r\nif (!zops) {\r\nrequest_module(name);\r\nzops = __ops_lookup(name, variant);\r\n}\r\nif ((!zops) || (!try_module_get(zops->owner)))\r\nreturn NULL;\r\nreturn zops;\r\n}\r\nvoid zcrypt_msgtype_release(struct zcrypt_ops *zops)\r\n{\r\nif (zops)\r\nmodule_put(zops->owner);\r\n}\r\nstatic ssize_t zcrypt_read(struct file *filp, char __user *buf,\r\nsize_t count, loff_t *f_pos)\r\n{\r\nreturn -EPERM;\r\n}\r\nstatic ssize_t zcrypt_write(struct file *filp, const char __user *buf,\r\nsize_t count, loff_t *f_pos)\r\n{\r\nreturn -EPERM;\r\n}\r\nstatic int zcrypt_open(struct inode *inode, struct file *filp)\r\n{\r\natomic_inc(&zcrypt_open_count);\r\nreturn nonseekable_open(inode, filp);\r\n}\r\nstatic int zcrypt_release(struct inode *inode, struct file *filp)\r\n{\r\natomic_dec(&zcrypt_open_count);\r\nreturn 0;\r\n}\r\nstatic long zcrypt_rsa_modexpo(struct ica_rsa_modexpo *mex)\r\n{\r\nstruct zcrypt_device *zdev;\r\nint rc;\r\nif (mex->outputdatalength < mex->inputdatalength)\r\nreturn -EINVAL;\r\nmex->outputdatalength = mex->inputdatalength;\r\nspin_lock_bh(&zcrypt_device_lock);\r\nlist_for_each_entry(zdev, &zcrypt_device_list, list) {\r\nif (!zdev->online ||\r\n!zdev->ops->rsa_modexpo ||\r\nzdev->min_mod_size > mex->inputdatalength ||\r\nzdev->max_mod_size < mex->inputdatalength)\r\ncontinue;\r\nzcrypt_device_get(zdev);\r\nget_device(&zdev->ap_dev->device);\r\nzdev->request_count++;\r\n__zcrypt_decrease_preference(zdev);\r\nif (try_module_get(zdev->ap_dev->drv->driver.owner)) {\r\nspin_unlock_bh(&zcrypt_device_lock);\r\nrc = zdev->ops->rsa_modexpo(zdev, mex);\r\nspin_lock_bh(&zcrypt_device_lock);\r\nmodule_put(zdev->ap_dev->drv->driver.owner);\r\n}\r\nelse\r\nrc = -EAGAIN;\r\nzdev->request_count--;\r\n__zcrypt_increase_preference(zdev);\r\nput_device(&zdev->ap_dev->device);\r\nzcrypt_device_put(zdev);\r\nspin_unlock_bh(&zcrypt_device_lock);\r\nreturn rc;\r\n}\r\nspin_unlock_bh(&zcrypt_device_lock);\r\nreturn -ENODEV;\r\n}\r\nstatic long zcrypt_rsa_crt(struct ica_rsa_modexpo_crt *crt)\r\n{\r\nstruct zcrypt_device *zdev;\r\nunsigned long long z1, z2, z3;\r\nint rc, copied;\r\nif (crt->outputdatalength < crt->inputdatalength ||\r\n(crt->inputdatalength & 1))\r\nreturn -EINVAL;\r\ncrt->outputdatalength = crt->inputdatalength;\r\ncopied = 0;\r\nrestart:\r\nspin_lock_bh(&zcrypt_device_lock);\r\nlist_for_each_entry(zdev, &zcrypt_device_list, list) {\r\nif (!zdev->online ||\r\n!zdev->ops->rsa_modexpo_crt ||\r\nzdev->min_mod_size > crt->inputdatalength ||\r\nzdev->max_mod_size < crt->inputdatalength)\r\ncontinue;\r\nif (zdev->short_crt && crt->inputdatalength > 240) {\r\nif (copied == 0) {\r\nunsigned int len;\r\nspin_unlock_bh(&zcrypt_device_lock);\r\nif (crt->inputdatalength <= 256)\r\nlen = crt->inputdatalength / 2 - 120;\r\nelse\r\nlen = 8;\r\nif (len > sizeof(z1))\r\nreturn -EFAULT;\r\nz1 = z2 = z3 = 0;\r\nif (copy_from_user(&z1, crt->np_prime, len) ||\r\ncopy_from_user(&z2, crt->bp_key, len) ||\r\ncopy_from_user(&z3, crt->u_mult_inv, len))\r\nreturn -EFAULT;\r\nz1 = z2 = z3 = 0;\r\ncopied = 1;\r\ngoto restart;\r\n}\r\nif (z1 != 0ULL || z2 != 0ULL || z3 != 0ULL)\r\ncontinue;\r\n}\r\nzcrypt_device_get(zdev);\r\nget_device(&zdev->ap_dev->device);\r\nzdev->request_count++;\r\n__zcrypt_decrease_preference(zdev);\r\nif (try_module_get(zdev->ap_dev->drv->driver.owner)) {\r\nspin_unlock_bh(&zcrypt_device_lock);\r\nrc = zdev->ops->rsa_modexpo_crt(zdev, crt);\r\nspin_lock_bh(&zcrypt_device_lock);\r\nmodule_put(zdev->ap_dev->drv->driver.owner);\r\n}\r\nelse\r\nrc = -EAGAIN;\r\nzdev->request_count--;\r\n__zcrypt_increase_preference(zdev);\r\nput_device(&zdev->ap_dev->device);\r\nzcrypt_device_put(zdev);\r\nspin_unlock_bh(&zcrypt_device_lock);\r\nreturn rc;\r\n}\r\nspin_unlock_bh(&zcrypt_device_lock);\r\nreturn -ENODEV;\r\n}\r\nstatic long zcrypt_send_cprb(struct ica_xcRB *xcRB)\r\n{\r\nstruct zcrypt_device *zdev;\r\nint rc;\r\nspin_lock_bh(&zcrypt_device_lock);\r\nlist_for_each_entry(zdev, &zcrypt_device_list, list) {\r\nif (!zdev->online || !zdev->ops->send_cprb ||\r\n(xcRB->user_defined != AUTOSELECT &&\r\nAP_QID_DEVICE(zdev->ap_dev->qid) != xcRB->user_defined)\r\n)\r\ncontinue;\r\nzcrypt_device_get(zdev);\r\nget_device(&zdev->ap_dev->device);\r\nzdev->request_count++;\r\n__zcrypt_decrease_preference(zdev);\r\nif (try_module_get(zdev->ap_dev->drv->driver.owner)) {\r\nspin_unlock_bh(&zcrypt_device_lock);\r\nrc = zdev->ops->send_cprb(zdev, xcRB);\r\nspin_lock_bh(&zcrypt_device_lock);\r\nmodule_put(zdev->ap_dev->drv->driver.owner);\r\n}\r\nelse\r\nrc = -EAGAIN;\r\nzdev->request_count--;\r\n__zcrypt_increase_preference(zdev);\r\nput_device(&zdev->ap_dev->device);\r\nzcrypt_device_put(zdev);\r\nspin_unlock_bh(&zcrypt_device_lock);\r\nreturn rc;\r\n}\r\nspin_unlock_bh(&zcrypt_device_lock);\r\nreturn -ENODEV;\r\n}\r\nstatic long zcrypt_rng(char *buffer)\r\n{\r\nstruct zcrypt_device *zdev;\r\nint rc;\r\nspin_lock_bh(&zcrypt_device_lock);\r\nlist_for_each_entry(zdev, &zcrypt_device_list, list) {\r\nif (!zdev->online || !zdev->ops->rng)\r\ncontinue;\r\nzcrypt_device_get(zdev);\r\nget_device(&zdev->ap_dev->device);\r\nzdev->request_count++;\r\n__zcrypt_decrease_preference(zdev);\r\nif (try_module_get(zdev->ap_dev->drv->driver.owner)) {\r\nspin_unlock_bh(&zcrypt_device_lock);\r\nrc = zdev->ops->rng(zdev, buffer);\r\nspin_lock_bh(&zcrypt_device_lock);\r\nmodule_put(zdev->ap_dev->drv->driver.owner);\r\n} else\r\nrc = -EAGAIN;\r\nzdev->request_count--;\r\n__zcrypt_increase_preference(zdev);\r\nput_device(&zdev->ap_dev->device);\r\nzcrypt_device_put(zdev);\r\nspin_unlock_bh(&zcrypt_device_lock);\r\nreturn rc;\r\n}\r\nspin_unlock_bh(&zcrypt_device_lock);\r\nreturn -ENODEV;\r\n}\r\nstatic void zcrypt_status_mask(char status[AP_DEVICES])\r\n{\r\nstruct zcrypt_device *zdev;\r\nmemset(status, 0, sizeof(char) * AP_DEVICES);\r\nspin_lock_bh(&zcrypt_device_lock);\r\nlist_for_each_entry(zdev, &zcrypt_device_list, list)\r\nstatus[AP_QID_DEVICE(zdev->ap_dev->qid)] =\r\nzdev->online ? zdev->user_space_type : 0x0d;\r\nspin_unlock_bh(&zcrypt_device_lock);\r\n}\r\nstatic void zcrypt_qdepth_mask(char qdepth[AP_DEVICES])\r\n{\r\nstruct zcrypt_device *zdev;\r\nmemset(qdepth, 0, sizeof(char) * AP_DEVICES);\r\nspin_lock_bh(&zcrypt_device_lock);\r\nlist_for_each_entry(zdev, &zcrypt_device_list, list) {\r\nspin_lock(&zdev->ap_dev->lock);\r\nqdepth[AP_QID_DEVICE(zdev->ap_dev->qid)] =\r\nzdev->ap_dev->pendingq_count +\r\nzdev->ap_dev->requestq_count;\r\nspin_unlock(&zdev->ap_dev->lock);\r\n}\r\nspin_unlock_bh(&zcrypt_device_lock);\r\n}\r\nstatic void zcrypt_perdev_reqcnt(int reqcnt[AP_DEVICES])\r\n{\r\nstruct zcrypt_device *zdev;\r\nmemset(reqcnt, 0, sizeof(int) * AP_DEVICES);\r\nspin_lock_bh(&zcrypt_device_lock);\r\nlist_for_each_entry(zdev, &zcrypt_device_list, list) {\r\nspin_lock(&zdev->ap_dev->lock);\r\nreqcnt[AP_QID_DEVICE(zdev->ap_dev->qid)] =\r\nzdev->ap_dev->total_request_count;\r\nspin_unlock(&zdev->ap_dev->lock);\r\n}\r\nspin_unlock_bh(&zcrypt_device_lock);\r\n}\r\nstatic int zcrypt_pendingq_count(void)\r\n{\r\nstruct zcrypt_device *zdev;\r\nint pendingq_count = 0;\r\nspin_lock_bh(&zcrypt_device_lock);\r\nlist_for_each_entry(zdev, &zcrypt_device_list, list) {\r\nspin_lock(&zdev->ap_dev->lock);\r\npendingq_count += zdev->ap_dev->pendingq_count;\r\nspin_unlock(&zdev->ap_dev->lock);\r\n}\r\nspin_unlock_bh(&zcrypt_device_lock);\r\nreturn pendingq_count;\r\n}\r\nstatic int zcrypt_requestq_count(void)\r\n{\r\nstruct zcrypt_device *zdev;\r\nint requestq_count = 0;\r\nspin_lock_bh(&zcrypt_device_lock);\r\nlist_for_each_entry(zdev, &zcrypt_device_list, list) {\r\nspin_lock(&zdev->ap_dev->lock);\r\nrequestq_count += zdev->ap_dev->requestq_count;\r\nspin_unlock(&zdev->ap_dev->lock);\r\n}\r\nspin_unlock_bh(&zcrypt_device_lock);\r\nreturn requestq_count;\r\n}\r\nstatic int zcrypt_count_type(int type)\r\n{\r\nstruct zcrypt_device *zdev;\r\nint device_count = 0;\r\nspin_lock_bh(&zcrypt_device_lock);\r\nlist_for_each_entry(zdev, &zcrypt_device_list, list)\r\nif (zdev->user_space_type == type)\r\ndevice_count++;\r\nspin_unlock_bh(&zcrypt_device_lock);\r\nreturn device_count;\r\n}\r\nstatic long zcrypt_ica_status(struct file *filp, unsigned long arg)\r\n{\r\nstruct ica_z90_status *pstat;\r\nint ret;\r\npstat = kzalloc(sizeof(*pstat), GFP_KERNEL);\r\nif (!pstat)\r\nreturn -ENOMEM;\r\npstat->totalcount = zcrypt_device_count;\r\npstat->leedslitecount = zcrypt_count_type(ZCRYPT_PCICA);\r\npstat->leeds2count = zcrypt_count_type(ZCRYPT_PCICC);\r\npstat->requestqWaitCount = zcrypt_requestq_count();\r\npstat->pendingqWaitCount = zcrypt_pendingq_count();\r\npstat->totalOpenCount = atomic_read(&zcrypt_open_count);\r\npstat->cryptoDomain = ap_domain_index;\r\nzcrypt_status_mask(pstat->status);\r\nzcrypt_qdepth_mask(pstat->qdepth);\r\nret = 0;\r\nif (copy_to_user((void __user *) arg, pstat, sizeof(*pstat)))\r\nret = -EFAULT;\r\nkfree(pstat);\r\nreturn ret;\r\n}\r\nstatic long zcrypt_unlocked_ioctl(struct file *filp, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\nint rc;\r\nswitch (cmd) {\r\ncase ICARSAMODEXPO: {\r\nstruct ica_rsa_modexpo __user *umex = (void __user *) arg;\r\nstruct ica_rsa_modexpo mex;\r\nif (copy_from_user(&mex, umex, sizeof(mex)))\r\nreturn -EFAULT;\r\ndo {\r\nrc = zcrypt_rsa_modexpo(&mex);\r\n} while (rc == -EAGAIN);\r\nif ((rc == -ENODEV) && (zcrypt_process_rescan()))\r\ndo {\r\nrc = zcrypt_rsa_modexpo(&mex);\r\n} while (rc == -EAGAIN);\r\nif (rc)\r\nreturn rc;\r\nreturn put_user(mex.outputdatalength, &umex->outputdatalength);\r\n}\r\ncase ICARSACRT: {\r\nstruct ica_rsa_modexpo_crt __user *ucrt = (void __user *) arg;\r\nstruct ica_rsa_modexpo_crt crt;\r\nif (copy_from_user(&crt, ucrt, sizeof(crt)))\r\nreturn -EFAULT;\r\ndo {\r\nrc = zcrypt_rsa_crt(&crt);\r\n} while (rc == -EAGAIN);\r\nif ((rc == -ENODEV) && (zcrypt_process_rescan()))\r\ndo {\r\nrc = zcrypt_rsa_crt(&crt);\r\n} while (rc == -EAGAIN);\r\nif (rc)\r\nreturn rc;\r\nreturn put_user(crt.outputdatalength, &ucrt->outputdatalength);\r\n}\r\ncase ZSECSENDCPRB: {\r\nstruct ica_xcRB __user *uxcRB = (void __user *) arg;\r\nstruct ica_xcRB xcRB;\r\nif (copy_from_user(&xcRB, uxcRB, sizeof(xcRB)))\r\nreturn -EFAULT;\r\ndo {\r\nrc = zcrypt_send_cprb(&xcRB);\r\n} while (rc == -EAGAIN);\r\nif ((rc == -ENODEV) && (zcrypt_process_rescan()))\r\ndo {\r\nrc = zcrypt_send_cprb(&xcRB);\r\n} while (rc == -EAGAIN);\r\nif (copy_to_user(uxcRB, &xcRB, sizeof(xcRB)))\r\nreturn -EFAULT;\r\nreturn rc;\r\n}\r\ncase Z90STAT_STATUS_MASK: {\r\nchar status[AP_DEVICES];\r\nzcrypt_status_mask(status);\r\nif (copy_to_user((char __user *) arg, status,\r\nsizeof(char) * AP_DEVICES))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\ncase Z90STAT_QDEPTH_MASK: {\r\nchar qdepth[AP_DEVICES];\r\nzcrypt_qdepth_mask(qdepth);\r\nif (copy_to_user((char __user *) arg, qdepth,\r\nsizeof(char) * AP_DEVICES))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\ncase Z90STAT_PERDEV_REQCNT: {\r\nint reqcnt[AP_DEVICES];\r\nzcrypt_perdev_reqcnt(reqcnt);\r\nif (copy_to_user((int __user *) arg, reqcnt,\r\nsizeof(int) * AP_DEVICES))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\ncase Z90STAT_REQUESTQ_COUNT:\r\nreturn put_user(zcrypt_requestq_count(), (int __user *) arg);\r\ncase Z90STAT_PENDINGQ_COUNT:\r\nreturn put_user(zcrypt_pendingq_count(), (int __user *) arg);\r\ncase Z90STAT_TOTALOPEN_COUNT:\r\nreturn put_user(atomic_read(&zcrypt_open_count),\r\n(int __user *) arg);\r\ncase Z90STAT_DOMAIN_INDEX:\r\nreturn put_user(ap_domain_index, (int __user *) arg);\r\ncase ICAZ90STATUS:\r\nreturn zcrypt_ica_status(filp, arg);\r\ncase Z90STAT_TOTALCOUNT:\r\nreturn put_user(zcrypt_device_count, (int __user *) arg);\r\ncase Z90STAT_PCICACOUNT:\r\nreturn put_user(zcrypt_count_type(ZCRYPT_PCICA),\r\n(int __user *) arg);\r\ncase Z90STAT_PCICCCOUNT:\r\nreturn put_user(zcrypt_count_type(ZCRYPT_PCICC),\r\n(int __user *) arg);\r\ncase Z90STAT_PCIXCCMCL2COUNT:\r\nreturn put_user(zcrypt_count_type(ZCRYPT_PCIXCC_MCL2),\r\n(int __user *) arg);\r\ncase Z90STAT_PCIXCCMCL3COUNT:\r\nreturn put_user(zcrypt_count_type(ZCRYPT_PCIXCC_MCL3),\r\n(int __user *) arg);\r\ncase Z90STAT_PCIXCCCOUNT:\r\nreturn put_user(zcrypt_count_type(ZCRYPT_PCIXCC_MCL2) +\r\nzcrypt_count_type(ZCRYPT_PCIXCC_MCL3),\r\n(int __user *) arg);\r\ncase Z90STAT_CEX2CCOUNT:\r\nreturn put_user(zcrypt_count_type(ZCRYPT_CEX2C),\r\n(int __user *) arg);\r\ncase Z90STAT_CEX2ACOUNT:\r\nreturn put_user(zcrypt_count_type(ZCRYPT_CEX2A),\r\n(int __user *) arg);\r\ndefault:\r\nreturn -ENOIOCTLCMD;\r\n}\r\n}\r\nstatic long trans_modexpo32(struct file *filp, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\nstruct compat_ica_rsa_modexpo __user *umex32 = compat_ptr(arg);\r\nstruct compat_ica_rsa_modexpo mex32;\r\nstruct ica_rsa_modexpo mex64;\r\nlong rc;\r\nif (copy_from_user(&mex32, umex32, sizeof(mex32)))\r\nreturn -EFAULT;\r\nmex64.inputdata = compat_ptr(mex32.inputdata);\r\nmex64.inputdatalength = mex32.inputdatalength;\r\nmex64.outputdata = compat_ptr(mex32.outputdata);\r\nmex64.outputdatalength = mex32.outputdatalength;\r\nmex64.b_key = compat_ptr(mex32.b_key);\r\nmex64.n_modulus = compat_ptr(mex32.n_modulus);\r\ndo {\r\nrc = zcrypt_rsa_modexpo(&mex64);\r\n} while (rc == -EAGAIN);\r\nif ((rc == -ENODEV) && (zcrypt_process_rescan()))\r\ndo {\r\nrc = zcrypt_rsa_modexpo(&mex64);\r\n} while (rc == -EAGAIN);\r\nif (rc)\r\nreturn rc;\r\nreturn put_user(mex64.outputdatalength,\r\n&umex32->outputdatalength);\r\n}\r\nstatic long trans_modexpo_crt32(struct file *filp, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\nstruct compat_ica_rsa_modexpo_crt __user *ucrt32 = compat_ptr(arg);\r\nstruct compat_ica_rsa_modexpo_crt crt32;\r\nstruct ica_rsa_modexpo_crt crt64;\r\nlong rc;\r\nif (copy_from_user(&crt32, ucrt32, sizeof(crt32)))\r\nreturn -EFAULT;\r\ncrt64.inputdata = compat_ptr(crt32.inputdata);\r\ncrt64.inputdatalength = crt32.inputdatalength;\r\ncrt64.outputdata= compat_ptr(crt32.outputdata);\r\ncrt64.outputdatalength = crt32.outputdatalength;\r\ncrt64.bp_key = compat_ptr(crt32.bp_key);\r\ncrt64.bq_key = compat_ptr(crt32.bq_key);\r\ncrt64.np_prime = compat_ptr(crt32.np_prime);\r\ncrt64.nq_prime = compat_ptr(crt32.nq_prime);\r\ncrt64.u_mult_inv = compat_ptr(crt32.u_mult_inv);\r\ndo {\r\nrc = zcrypt_rsa_crt(&crt64);\r\n} while (rc == -EAGAIN);\r\nif ((rc == -ENODEV) && (zcrypt_process_rescan()))\r\ndo {\r\nrc = zcrypt_rsa_crt(&crt64);\r\n} while (rc == -EAGAIN);\r\nif (rc)\r\nreturn rc;\r\nreturn put_user(crt64.outputdatalength,\r\n&ucrt32->outputdatalength);\r\n}\r\nstatic long trans_xcRB32(struct file *filp, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\nstruct compat_ica_xcRB __user *uxcRB32 = compat_ptr(arg);\r\nstruct compat_ica_xcRB xcRB32;\r\nstruct ica_xcRB xcRB64;\r\nlong rc;\r\nif (copy_from_user(&xcRB32, uxcRB32, sizeof(xcRB32)))\r\nreturn -EFAULT;\r\nxcRB64.agent_ID = xcRB32.agent_ID;\r\nxcRB64.user_defined = xcRB32.user_defined;\r\nxcRB64.request_ID = xcRB32.request_ID;\r\nxcRB64.request_control_blk_length =\r\nxcRB32.request_control_blk_length;\r\nxcRB64.request_control_blk_addr =\r\ncompat_ptr(xcRB32.request_control_blk_addr);\r\nxcRB64.request_data_length =\r\nxcRB32.request_data_length;\r\nxcRB64.request_data_address =\r\ncompat_ptr(xcRB32.request_data_address);\r\nxcRB64.reply_control_blk_length =\r\nxcRB32.reply_control_blk_length;\r\nxcRB64.reply_control_blk_addr =\r\ncompat_ptr(xcRB32.reply_control_blk_addr);\r\nxcRB64.reply_data_length = xcRB32.reply_data_length;\r\nxcRB64.reply_data_addr =\r\ncompat_ptr(xcRB32.reply_data_addr);\r\nxcRB64.priority_window = xcRB32.priority_window;\r\nxcRB64.status = xcRB32.status;\r\ndo {\r\nrc = zcrypt_send_cprb(&xcRB64);\r\n} while (rc == -EAGAIN);\r\nif ((rc == -ENODEV) && (zcrypt_process_rescan()))\r\ndo {\r\nrc = zcrypt_send_cprb(&xcRB64);\r\n} while (rc == -EAGAIN);\r\nxcRB32.reply_control_blk_length = xcRB64.reply_control_blk_length;\r\nxcRB32.reply_data_length = xcRB64.reply_data_length;\r\nxcRB32.status = xcRB64.status;\r\nif (copy_to_user(uxcRB32, &xcRB32, sizeof(xcRB32)))\r\nreturn -EFAULT;\r\nreturn rc;\r\n}\r\nstatic long zcrypt_compat_ioctl(struct file *filp, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\nif (cmd == ICARSAMODEXPO)\r\nreturn trans_modexpo32(filp, cmd, arg);\r\nif (cmd == ICARSACRT)\r\nreturn trans_modexpo_crt32(filp, cmd, arg);\r\nif (cmd == ZSECSENDCPRB)\r\nreturn trans_xcRB32(filp, cmd, arg);\r\nreturn zcrypt_unlocked_ioctl(filp, cmd, arg);\r\n}\r\nstatic void sprintcl(struct seq_file *m, unsigned char *addr, unsigned int len)\r\n{\r\nint i;\r\nfor (i = 0; i < len; i++)\r\nseq_printf(m, "%01x", (unsigned int) addr[i]);\r\nseq_putc(m, ' ');\r\n}\r\nstatic void sprintrw(struct seq_file *m, unsigned char *addr, unsigned int len)\r\n{\r\nint inl, c, cx;\r\nseq_printf(m, " ");\r\ninl = 0;\r\nfor (c = 0; c < (len / 16); c++) {\r\nsprintcl(m, addr+inl, 16);\r\ninl += 16;\r\n}\r\ncx = len%16;\r\nif (cx) {\r\nsprintcl(m, addr+inl, cx);\r\ninl += cx;\r\n}\r\nseq_putc(m, '\n');\r\n}\r\nstatic void sprinthx(unsigned char *title, struct seq_file *m,\r\nunsigned char *addr, unsigned int len)\r\n{\r\nint inl, r, rx;\r\nseq_printf(m, "\n%s\n", title);\r\ninl = 0;\r\nfor (r = 0; r < (len / 64); r++) {\r\nsprintrw(m, addr+inl, 64);\r\ninl += 64;\r\n}\r\nrx = len % 64;\r\nif (rx) {\r\nsprintrw(m, addr+inl, rx);\r\ninl += rx;\r\n}\r\nseq_putc(m, '\n');\r\n}\r\nstatic void sprinthx4(unsigned char *title, struct seq_file *m,\r\nunsigned int *array, unsigned int len)\r\n{\r\nint r;\r\nseq_printf(m, "\n%s\n", title);\r\nfor (r = 0; r < len; r++) {\r\nif ((r % 8) == 0)\r\nseq_printf(m, " ");\r\nseq_printf(m, "%08X ", array[r]);\r\nif ((r % 8) == 7)\r\nseq_putc(m, '\n');\r\n}\r\nseq_putc(m, '\n');\r\n}\r\nstatic int zcrypt_proc_show(struct seq_file *m, void *v)\r\n{\r\nchar workarea[sizeof(int) * AP_DEVICES];\r\nseq_printf(m, "\nzcrypt version: %d.%d.%d\n",\r\nZCRYPT_VERSION, ZCRYPT_RELEASE, ZCRYPT_VARIANT);\r\nseq_printf(m, "Cryptographic domain: %d\n", ap_domain_index);\r\nseq_printf(m, "Total device count: %d\n", zcrypt_device_count);\r\nseq_printf(m, "PCICA count: %d\n", zcrypt_count_type(ZCRYPT_PCICA));\r\nseq_printf(m, "PCICC count: %d\n", zcrypt_count_type(ZCRYPT_PCICC));\r\nseq_printf(m, "PCIXCC MCL2 count: %d\n",\r\nzcrypt_count_type(ZCRYPT_PCIXCC_MCL2));\r\nseq_printf(m, "PCIXCC MCL3 count: %d\n",\r\nzcrypt_count_type(ZCRYPT_PCIXCC_MCL3));\r\nseq_printf(m, "CEX2C count: %d\n", zcrypt_count_type(ZCRYPT_CEX2C));\r\nseq_printf(m, "CEX2A count: %d\n", zcrypt_count_type(ZCRYPT_CEX2A));\r\nseq_printf(m, "CEX3C count: %d\n", zcrypt_count_type(ZCRYPT_CEX3C));\r\nseq_printf(m, "CEX3A count: %d\n", zcrypt_count_type(ZCRYPT_CEX3A));\r\nseq_printf(m, "requestq count: %d\n", zcrypt_requestq_count());\r\nseq_printf(m, "pendingq count: %d\n", zcrypt_pendingq_count());\r\nseq_printf(m, "Total open handles: %d\n\n",\r\natomic_read(&zcrypt_open_count));\r\nzcrypt_status_mask(workarea);\r\nsprinthx("Online devices: 1=PCICA 2=PCICC 3=PCIXCC(MCL2) "\r\n"4=PCIXCC(MCL3) 5=CEX2C 6=CEX2A 7=CEX3C 8=CEX3A",\r\nm, workarea, AP_DEVICES);\r\nzcrypt_qdepth_mask(workarea);\r\nsprinthx("Waiting work element counts", m, workarea, AP_DEVICES);\r\nzcrypt_perdev_reqcnt((int *) workarea);\r\nsprinthx4("Per-device successfully completed request counts",\r\nm, (unsigned int *) workarea, AP_DEVICES);\r\nreturn 0;\r\n}\r\nstatic int zcrypt_proc_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, zcrypt_proc_show, NULL);\r\n}\r\nstatic void zcrypt_disable_card(int index)\r\n{\r\nstruct zcrypt_device *zdev;\r\nspin_lock_bh(&zcrypt_device_lock);\r\nlist_for_each_entry(zdev, &zcrypt_device_list, list)\r\nif (AP_QID_DEVICE(zdev->ap_dev->qid) == index) {\r\nzdev->online = 0;\r\nap_flush_queue(zdev->ap_dev);\r\nbreak;\r\n}\r\nspin_unlock_bh(&zcrypt_device_lock);\r\n}\r\nstatic void zcrypt_enable_card(int index)\r\n{\r\nstruct zcrypt_device *zdev;\r\nspin_lock_bh(&zcrypt_device_lock);\r\nlist_for_each_entry(zdev, &zcrypt_device_list, list)\r\nif (AP_QID_DEVICE(zdev->ap_dev->qid) == index) {\r\nzdev->online = 1;\r\nbreak;\r\n}\r\nspin_unlock_bh(&zcrypt_device_lock);\r\n}\r\nstatic ssize_t zcrypt_proc_write(struct file *file, const char __user *buffer,\r\nsize_t count, loff_t *pos)\r\n{\r\nunsigned char *lbuf, *ptr;\r\nsize_t local_count;\r\nint j;\r\nif (count <= 0)\r\nreturn 0;\r\n#define LBUFSIZE 1200UL\r\nlbuf = kmalloc(LBUFSIZE, GFP_KERNEL);\r\nif (!lbuf)\r\nreturn 0;\r\nlocal_count = min(LBUFSIZE - 1, count);\r\nif (copy_from_user(lbuf, buffer, local_count) != 0) {\r\nkfree(lbuf);\r\nreturn -EFAULT;\r\n}\r\nlbuf[local_count] = '\0';\r\nptr = strstr(lbuf, "Online devices");\r\nif (!ptr)\r\ngoto out;\r\nptr = strstr(ptr, "\n");\r\nif (!ptr)\r\ngoto out;\r\nptr++;\r\nif (strstr(ptr, "Waiting work element counts") == NULL)\r\ngoto out;\r\nfor (j = 0; j < 64 && *ptr; ptr++) {\r\nif (*ptr >= '0' && *ptr <= '8')\r\nj++;\r\nelse if (*ptr == 'd' || *ptr == 'D')\r\nzcrypt_disable_card(j++);\r\nelse if (*ptr == 'e' || *ptr == 'E')\r\nzcrypt_enable_card(j++);\r\nelse if (*ptr != ' ' && *ptr != '\t')\r\nbreak;\r\n}\r\nout:\r\nkfree(lbuf);\r\nreturn count;\r\n}\r\nstatic int zcrypt_rng_data_read(struct hwrng *rng, u32 *data)\r\n{\r\nint rc;\r\nif (zcrypt_rng_buffer_index == 0) {\r\nrc = zcrypt_rng((char *) zcrypt_rng_buffer);\r\nif ((rc == -ENODEV) && (zcrypt_process_rescan()))\r\nrc = zcrypt_rng((char *) zcrypt_rng_buffer);\r\nif (rc < 0)\r\nreturn -EIO;\r\nzcrypt_rng_buffer_index = rc / sizeof *data;\r\n}\r\n*data = zcrypt_rng_buffer[--zcrypt_rng_buffer_index];\r\nreturn sizeof *data;\r\n}\r\nstatic int zcrypt_rng_device_add(void)\r\n{\r\nint rc = 0;\r\nmutex_lock(&zcrypt_rng_mutex);\r\nif (zcrypt_rng_device_count == 0) {\r\nzcrypt_rng_buffer = (u32 *) get_zeroed_page(GFP_KERNEL);\r\nif (!zcrypt_rng_buffer) {\r\nrc = -ENOMEM;\r\ngoto out;\r\n}\r\nzcrypt_rng_buffer_index = 0;\r\nrc = hwrng_register(&zcrypt_rng_dev);\r\nif (rc)\r\ngoto out_free;\r\nzcrypt_rng_device_count = 1;\r\n} else\r\nzcrypt_rng_device_count++;\r\nmutex_unlock(&zcrypt_rng_mutex);\r\nreturn 0;\r\nout_free:\r\nfree_page((unsigned long) zcrypt_rng_buffer);\r\nout:\r\nmutex_unlock(&zcrypt_rng_mutex);\r\nreturn rc;\r\n}\r\nstatic void zcrypt_rng_device_remove(void)\r\n{\r\nmutex_lock(&zcrypt_rng_mutex);\r\nzcrypt_rng_device_count--;\r\nif (zcrypt_rng_device_count == 0) {\r\nhwrng_unregister(&zcrypt_rng_dev);\r\nfree_page((unsigned long) zcrypt_rng_buffer);\r\n}\r\nmutex_unlock(&zcrypt_rng_mutex);\r\n}\r\nint __init zcrypt_debug_init(void)\r\n{\r\ndebugfs_root = debugfs_create_dir("zcrypt", NULL);\r\nzcrypt_dbf_common = debug_register("zcrypt_common", 1, 1, 16);\r\ndebug_register_view(zcrypt_dbf_common, &debug_hex_ascii_view);\r\ndebug_set_level(zcrypt_dbf_common, DBF_ERR);\r\nzcrypt_dbf_devices = debug_register("zcrypt_devices", 1, 1, 16);\r\ndebug_register_view(zcrypt_dbf_devices, &debug_hex_ascii_view);\r\ndebug_set_level(zcrypt_dbf_devices, DBF_ERR);\r\nreturn 0;\r\n}\r\nvoid zcrypt_debug_exit(void)\r\n{\r\ndebugfs_remove(debugfs_root);\r\nif (zcrypt_dbf_common)\r\ndebug_unregister(zcrypt_dbf_common);\r\nif (zcrypt_dbf_devices)\r\ndebug_unregister(zcrypt_dbf_devices);\r\n}\r\nint __init zcrypt_api_init(void)\r\n{\r\nint rc;\r\nrc = zcrypt_debug_init();\r\nif (rc)\r\ngoto out;\r\natomic_set(&zcrypt_rescan_req, 0);\r\nrc = misc_register(&zcrypt_misc_device);\r\nif (rc < 0)\r\ngoto out;\r\nzcrypt_entry = proc_create("driver/z90crypt", 0644, NULL, &zcrypt_proc_fops);\r\nif (!zcrypt_entry) {\r\nrc = -ENOMEM;\r\ngoto out_misc;\r\n}\r\nreturn 0;\r\nout_misc:\r\nmisc_deregister(&zcrypt_misc_device);\r\nout:\r\nreturn rc;\r\n}\r\nvoid zcrypt_api_exit(void)\r\n{\r\nremove_proc_entry("driver/z90crypt", NULL);\r\nmisc_deregister(&zcrypt_misc_device);\r\nzcrypt_debug_exit();\r\n}
