static inline struct ipu_flow *to_flow(struct ipu_dp *dp)\r\n{\r\nif (dp->foreground)\r\nreturn container_of(dp, struct ipu_flow, foreground);\r\nelse\r\nreturn container_of(dp, struct ipu_flow, background);\r\n}\r\nint ipu_dp_set_global_alpha(struct ipu_dp *dp, bool enable,\r\nu8 alpha, bool bg_chan)\r\n{\r\nstruct ipu_flow *flow = to_flow(dp);\r\nstruct ipu_dp_priv *priv = flow->priv;\r\nu32 reg;\r\nmutex_lock(&priv->mutex);\r\nreg = readl(flow->base + DP_COM_CONF);\r\nif (bg_chan)\r\nreg &= ~DP_COM_CONF_GWSEL;\r\nelse\r\nreg |= DP_COM_CONF_GWSEL;\r\nwritel(reg, flow->base + DP_COM_CONF);\r\nif (enable) {\r\nreg = readl(flow->base + DP_GRAPH_WIND_CTRL) & 0x00FFFFFFL;\r\nwritel(reg | ((u32) alpha << 24),\r\nflow->base + DP_GRAPH_WIND_CTRL);\r\nreg = readl(flow->base + DP_COM_CONF);\r\nwritel(reg | DP_COM_CONF_GWAM, flow->base + DP_COM_CONF);\r\n} else {\r\nreg = readl(flow->base + DP_COM_CONF);\r\nwritel(reg & ~DP_COM_CONF_GWAM, flow->base + DP_COM_CONF);\r\n}\r\nipu_srm_dp_sync_update(priv->ipu);\r\nmutex_unlock(&priv->mutex);\r\nreturn 0;\r\n}\r\nint ipu_dp_set_window_pos(struct ipu_dp *dp, u16 x_pos, u16 y_pos)\r\n{\r\nstruct ipu_flow *flow = to_flow(dp);\r\nstruct ipu_dp_priv *priv = flow->priv;\r\nwritel((x_pos << 16) | y_pos, flow->base + DP_FG_POS);\r\nipu_srm_dp_sync_update(priv->ipu);\r\nreturn 0;\r\n}\r\nstatic void ipu_dp_csc_init(struct ipu_flow *flow,\r\nenum ipu_color_space in,\r\nenum ipu_color_space out,\r\nu32 place)\r\n{\r\nu32 reg;\r\nreg = readl(flow->base + DP_COM_CONF);\r\nreg &= ~DP_COM_CONF_CSC_DEF_MASK;\r\nif (in == out) {\r\nwritel(reg, flow->base + DP_COM_CONF);\r\nreturn;\r\n}\r\nif (in == IPUV3_COLORSPACE_RGB && out == IPUV3_COLORSPACE_YUV) {\r\nwritel(0x099 | (0x12d << 16), flow->base + DP_CSC_A_0);\r\nwritel(0x03a | (0x3a9 << 16), flow->base + DP_CSC_A_1);\r\nwritel(0x356 | (0x100 << 16), flow->base + DP_CSC_A_2);\r\nwritel(0x100 | (0x329 << 16), flow->base + DP_CSC_A_3);\r\nwritel(0x3d6 | (0x0000 << 16) | (2 << 30),\r\nflow->base + DP_CSC_0);\r\nwritel(0x200 | (2 << 14) | (0x200 << 16) | (2 << 30),\r\nflow->base + DP_CSC_1);\r\n} else {\r\nwritel(0x095 | (0x000 << 16), flow->base + DP_CSC_A_0);\r\nwritel(0x0cc | (0x095 << 16), flow->base + DP_CSC_A_1);\r\nwritel(0x3ce | (0x398 << 16), flow->base + DP_CSC_A_2);\r\nwritel(0x095 | (0x0ff << 16), flow->base + DP_CSC_A_3);\r\nwritel(0x000 | (0x3e42 << 16) | (1 << 30),\r\nflow->base + DP_CSC_0);\r\nwritel(0x10a | (1 << 14) | (0x3dd6 << 16) | (1 << 30),\r\nflow->base + DP_CSC_1);\r\n}\r\nreg |= place;\r\nwritel(reg, flow->base + DP_COM_CONF);\r\n}\r\nint ipu_dp_setup_channel(struct ipu_dp *dp,\r\nenum ipu_color_space in,\r\nenum ipu_color_space out)\r\n{\r\nstruct ipu_flow *flow = to_flow(dp);\r\nstruct ipu_dp_priv *priv = flow->priv;\r\nmutex_lock(&priv->mutex);\r\ndp->in_cs = in;\r\nif (!dp->foreground)\r\nflow->out_cs = out;\r\nif (flow->foreground.in_cs == flow->background.in_cs) {\r\nipu_dp_csc_init(flow, flow->foreground.in_cs, flow->out_cs,\r\nDP_COM_CONF_CSC_DEF_BOTH);\r\n} else {\r\nif (flow->foreground.in_cs == flow->out_cs)\r\nipu_dp_csc_init(flow, flow->background.in_cs,\r\nflow->out_cs, DP_COM_CONF_CSC_DEF_BG);\r\nelse\r\nipu_dp_csc_init(flow, flow->foreground.in_cs,\r\nflow->out_cs, DP_COM_CONF_CSC_DEF_FG);\r\n}\r\nipu_srm_dp_sync_update(priv->ipu);\r\nmutex_unlock(&priv->mutex);\r\nreturn 0;\r\n}\r\nint ipu_dp_enable_channel(struct ipu_dp *dp)\r\n{\r\nstruct ipu_flow *flow = to_flow(dp);\r\nstruct ipu_dp_priv *priv = flow->priv;\r\nmutex_lock(&priv->mutex);\r\nif (!priv->use_count)\r\nipu_module_enable(priv->ipu, IPU_CONF_DP_EN);\r\npriv->use_count++;\r\nif (dp->foreground) {\r\nu32 reg;\r\nreg = readl(flow->base + DP_COM_CONF);\r\nreg |= DP_COM_CONF_FG_EN;\r\nwritel(reg, flow->base + DP_COM_CONF);\r\nipu_srm_dp_sync_update(priv->ipu);\r\n}\r\nmutex_unlock(&priv->mutex);\r\nreturn 0;\r\n}\r\nvoid ipu_dp_disable_channel(struct ipu_dp *dp)\r\n{\r\nstruct ipu_flow *flow = to_flow(dp);\r\nstruct ipu_dp_priv *priv = flow->priv;\r\nmutex_lock(&priv->mutex);\r\npriv->use_count--;\r\nif (dp->foreground) {\r\nu32 reg, csc;\r\nreg = readl(flow->base + DP_COM_CONF);\r\ncsc = reg & DP_COM_CONF_CSC_DEF_MASK;\r\nif (csc == DP_COM_CONF_CSC_DEF_FG)\r\nreg &= ~DP_COM_CONF_CSC_DEF_MASK;\r\nreg &= ~DP_COM_CONF_FG_EN;\r\nwritel(reg, flow->base + DP_COM_CONF);\r\nwritel(0, flow->base + DP_FG_POS);\r\nipu_srm_dp_sync_update(priv->ipu);\r\n}\r\nif (!priv->use_count)\r\nipu_module_disable(priv->ipu, IPU_CONF_DP_EN);\r\nif (priv->use_count < 0)\r\npriv->use_count = 0;\r\nmutex_unlock(&priv->mutex);\r\n}\r\nstruct ipu_dp *ipu_dp_get(struct ipu_soc *ipu, unsigned int flow)\r\n{\r\nstruct ipu_dp_priv *priv = ipu->dp_priv;\r\nstruct ipu_dp *dp;\r\nif (flow > 5)\r\nreturn ERR_PTR(-EINVAL);\r\nif (flow & 1)\r\ndp = &priv->flow[flow >> 1].foreground;\r\nelse\r\ndp = &priv->flow[flow >> 1].background;\r\nif (dp->in_use)\r\nreturn ERR_PTR(-EBUSY);\r\ndp->in_use = true;\r\nreturn dp;\r\n}\r\nvoid ipu_dp_put(struct ipu_dp *dp)\r\n{\r\ndp->in_use = false;\r\n}\r\nint ipu_dp_init(struct ipu_soc *ipu, struct device *dev, unsigned long base)\r\n{\r\nstruct ipu_dp_priv *priv;\r\nint i;\r\npriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\r\npriv->dev = dev;\r\npriv->ipu = ipu;\r\nipu->dp_priv = priv;\r\npriv->base = devm_ioremap(dev, base, PAGE_SIZE);\r\nif (!priv->base) {\r\nkfree(priv);\r\nreturn -ENOMEM;\r\n}\r\nmutex_init(&priv->mutex);\r\nfor (i = 0; i < 3; i++) {\r\npriv->flow[i].foreground.foreground = 1;\r\npriv->flow[i].base = priv->base + ipu_dp_flow_base[i];\r\npriv->flow[i].priv = priv;\r\n}\r\nreturn 0;\r\n}\r\nvoid ipu_dp_exit(struct ipu_soc *ipu)\r\n{\r\n}
