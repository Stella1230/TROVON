static inline void sb800_prefetch(struct ohci_hcd *ohci, int on)\r\n{\r\nreturn;\r\n}\r\nstatic int ohci_urb_enqueue (\r\nstruct usb_hcd *hcd,\r\nstruct urb *urb,\r\ngfp_t mem_flags\r\n) {\r\nstruct ohci_hcd *ohci = hcd_to_ohci (hcd);\r\nstruct ed *ed;\r\nurb_priv_t *urb_priv;\r\nunsigned int pipe = urb->pipe;\r\nint i, size = 0;\r\nunsigned long flags;\r\nint retval = 0;\r\n#ifdef OHCI_VERBOSE_DEBUG\r\nurb_print(urb, "SUB", usb_pipein(pipe), -EINPROGRESS);\r\n#endif\r\nif (! (ed = ed_get (ohci, urb->ep, urb->dev, pipe, urb->interval)))\r\nreturn -ENOMEM;\r\nswitch (ed->type) {\r\ncase PIPE_CONTROL:\r\nif (urb->transfer_buffer_length > 4096)\r\nreturn -EMSGSIZE;\r\nsize = 2;\r\ndefault:\r\nsize += urb->transfer_buffer_length / 4096;\r\nif ((urb->transfer_buffer_length % 4096) != 0)\r\nsize++;\r\nif (size == 0)\r\nsize++;\r\nelse if ((urb->transfer_flags & URB_ZERO_PACKET) != 0\r\n&& (urb->transfer_buffer_length\r\n% usb_maxpacket (urb->dev, pipe,\r\nusb_pipeout (pipe))) == 0)\r\nsize++;\r\nbreak;\r\ncase PIPE_ISOCHRONOUS:\r\nsize = urb->number_of_packets;\r\nbreak;\r\n}\r\nurb_priv = kzalloc (sizeof (urb_priv_t) + size * sizeof (struct td *),\r\nmem_flags);\r\nif (!urb_priv)\r\nreturn -ENOMEM;\r\nINIT_LIST_HEAD (&urb_priv->pending);\r\nurb_priv->length = size;\r\nurb_priv->ed = ed;\r\nfor (i = 0; i < size; i++) {\r\nurb_priv->td [i] = td_alloc (ohci, mem_flags);\r\nif (!urb_priv->td [i]) {\r\nurb_priv->length = i;\r\nurb_free_priv (ohci, urb_priv);\r\nreturn -ENOMEM;\r\n}\r\n}\r\nspin_lock_irqsave (&ohci->lock, flags);\r\nif (!HCD_HW_ACCESSIBLE(hcd)) {\r\nretval = -ENODEV;\r\ngoto fail;\r\n}\r\nif (ohci->rh_state != OHCI_RH_RUNNING) {\r\nretval = -ENODEV;\r\ngoto fail;\r\n}\r\nretval = usb_hcd_link_urb_to_ep(hcd, urb);\r\nif (retval)\r\ngoto fail;\r\nif (ed->state == ED_IDLE) {\r\nretval = ed_schedule (ohci, ed);\r\nif (retval < 0) {\r\nusb_hcd_unlink_urb_from_ep(hcd, urb);\r\ngoto fail;\r\n}\r\nif (ed->type == PIPE_ISOCHRONOUS) {\r\nu16 frame = ohci_frame_no(ohci);\r\nframe += max_t (u16, 8, ed->interval);\r\nframe &= ~(ed->interval - 1);\r\nframe |= ed->branch;\r\nurb->start_frame = frame;\r\n}\r\n} else if (ed->type == PIPE_ISOCHRONOUS) {\r\nu16 next = ohci_frame_no(ohci) + 2;\r\nu16 frame = ed->last_iso + ed->interval;\r\nif (unlikely(tick_before(frame, next))) {\r\nif (urb->transfer_flags & URB_ISO_ASAP)\r\nframe += (next - frame + ed->interval - 1) &\r\n-ed->interval;\r\nelse if (tick_before(frame + ed->interval *\r\n(urb->number_of_packets - 1), next)) {\r\nretval = -EXDEV;\r\nusb_hcd_unlink_urb_from_ep(hcd, urb);\r\ngoto fail;\r\n}\r\nurb_priv->td_cnt = DIV_ROUND_UP(next - frame,\r\ned->interval);\r\n}\r\nurb->start_frame = frame;\r\n}\r\nurb->hcpriv = urb_priv;\r\ntd_submit_urb (ohci, urb);\r\nfail:\r\nif (retval)\r\nurb_free_priv (ohci, urb_priv);\r\nspin_unlock_irqrestore (&ohci->lock, flags);\r\nreturn retval;\r\n}\r\nstatic int ohci_urb_dequeue(struct usb_hcd *hcd, struct urb *urb, int status)\r\n{\r\nstruct ohci_hcd *ohci = hcd_to_ohci (hcd);\r\nunsigned long flags;\r\nint rc;\r\n#ifdef OHCI_VERBOSE_DEBUG\r\nurb_print(urb, "UNLINK", 1, status);\r\n#endif\r\nspin_lock_irqsave (&ohci->lock, flags);\r\nrc = usb_hcd_check_unlink_urb(hcd, urb, status);\r\nif (rc) {\r\n;\r\n} else if (ohci->rh_state == OHCI_RH_RUNNING) {\r\nurb_priv_t *urb_priv;\r\nurb_priv = urb->hcpriv;\r\nif (urb_priv) {\r\nif (urb_priv->ed->state == ED_OPER)\r\nstart_ed_unlink (ohci, urb_priv->ed);\r\n}\r\n} else {\r\nif (urb->hcpriv)\r\nfinish_urb(ohci, urb, status);\r\n}\r\nspin_unlock_irqrestore (&ohci->lock, flags);\r\nreturn rc;\r\n}\r\nstatic void\r\nohci_endpoint_disable (struct usb_hcd *hcd, struct usb_host_endpoint *ep)\r\n{\r\nstruct ohci_hcd *ohci = hcd_to_ohci (hcd);\r\nunsigned long flags;\r\nstruct ed *ed = ep->hcpriv;\r\nunsigned limit = 1000;\r\nif (!ed)\r\nreturn;\r\nrescan:\r\nspin_lock_irqsave (&ohci->lock, flags);\r\nif (ohci->rh_state != OHCI_RH_RUNNING) {\r\nsanitize:\r\ned->state = ED_IDLE;\r\nif (quirk_zfmicro(ohci) && ed->type == PIPE_INTERRUPT)\r\nohci->eds_scheduled--;\r\nfinish_unlinks (ohci, 0);\r\n}\r\nswitch (ed->state) {\r\ncase ED_UNLINK:\r\nif (limit-- == 0) {\r\nohci_warn(ohci, "ED unlink timeout\n");\r\nif (quirk_zfmicro(ohci)) {\r\nohci_warn(ohci, "Attempting ZF TD recovery\n");\r\nohci->ed_to_check = ed;\r\nohci->zf_delay = 2;\r\n}\r\ngoto sanitize;\r\n}\r\nspin_unlock_irqrestore (&ohci->lock, flags);\r\nschedule_timeout_uninterruptible(1);\r\ngoto rescan;\r\ncase ED_IDLE:\r\nif (list_empty (&ed->td_list)) {\r\ntd_free (ohci, ed->dummy);\r\ned_free (ohci, ed);\r\nbreak;\r\n}\r\ndefault:\r\nohci_err (ohci, "leak ed %p (#%02x) state %d%s\n",\r\ned, ep->desc.bEndpointAddress, ed->state,\r\nlist_empty (&ed->td_list) ? "" : " (has tds)");\r\ntd_free (ohci, ed->dummy);\r\nbreak;\r\n}\r\nep->hcpriv = NULL;\r\nspin_unlock_irqrestore (&ohci->lock, flags);\r\n}\r\nstatic int ohci_get_frame (struct usb_hcd *hcd)\r\n{\r\nstruct ohci_hcd *ohci = hcd_to_ohci (hcd);\r\nreturn ohci_frame_no(ohci);\r\n}\r\nstatic void ohci_usb_reset (struct ohci_hcd *ohci)\r\n{\r\nohci->hc_control = ohci_readl (ohci, &ohci->regs->control);\r\nohci->hc_control &= OHCI_CTRL_RWC;\r\nohci_writel (ohci, ohci->hc_control, &ohci->regs->control);\r\nohci->rh_state = OHCI_RH_HALTED;\r\n}\r\nstatic void\r\nohci_shutdown (struct usb_hcd *hcd)\r\n{\r\nstruct ohci_hcd *ohci;\r\nohci = hcd_to_ohci (hcd);\r\nohci_writel(ohci, (u32) ~0, &ohci->regs->intrdisable);\r\nohci_writel(ohci, OHCI_HCR, &ohci->regs->cmdstatus);\r\nohci_readl(ohci, &ohci->regs->cmdstatus);\r\nudelay(10);\r\nohci_writel(ohci, ohci->fminterval, &ohci->regs->fminterval);\r\n}\r\nstatic int check_ed(struct ohci_hcd *ohci, struct ed *ed)\r\n{\r\nreturn (hc32_to_cpu(ohci, ed->hwINFO) & ED_IN) != 0\r\n&& (hc32_to_cpu(ohci, ed->hwHeadP) & TD_MASK)\r\n== (hc32_to_cpu(ohci, ed->hwTailP) & TD_MASK)\r\n&& !list_empty(&ed->td_list);\r\n}\r\nstatic void unlink_watchdog_func(unsigned long _ohci)\r\n{\r\nunsigned long flags;\r\nunsigned max;\r\nunsigned seen_count = 0;\r\nunsigned i;\r\nstruct ed **seen = NULL;\r\nstruct ohci_hcd *ohci = (struct ohci_hcd *) _ohci;\r\nspin_lock_irqsave(&ohci->lock, flags);\r\nmax = ohci->eds_scheduled;\r\nif (!max)\r\ngoto done;\r\nif (ohci->ed_to_check)\r\ngoto out;\r\nseen = kcalloc(max, sizeof *seen, GFP_ATOMIC);\r\nif (!seen)\r\ngoto out;\r\nfor (i = 0; i < NUM_INTS; i++) {\r\nstruct ed *ed = ohci->periodic[i];\r\nwhile (ed) {\r\nunsigned temp;\r\nfor (temp = 0; temp < seen_count; temp++) {\r\nif (seen[temp] == ed) {\r\ned = NULL;\r\nbreak;\r\n}\r\n}\r\nif (!ed)\r\nbreak;\r\nseen[seen_count++] = ed;\r\nif (!check_ed(ohci, ed)) {\r\ned = ed->ed_next;\r\ncontinue;\r\n}\r\nohci->ed_to_check = ed;\r\nohci->zf_delay = 2;\r\nohci_writel(ohci, OHCI_INTR_SF,\r\n&ohci->regs->intrstatus);\r\nohci_writel(ohci, OHCI_INTR_SF,\r\n&ohci->regs->intrenable);\r\n(void) ohci_readl(ohci, &ohci->regs->control);\r\ngoto out;\r\n}\r\n}\r\nout:\r\nkfree(seen);\r\nif (ohci->eds_scheduled)\r\nmod_timer(&ohci->unlink_watchdog, round_jiffies(jiffies + HZ));\r\ndone:\r\nspin_unlock_irqrestore(&ohci->lock, flags);\r\n}\r\nstatic int ohci_init (struct ohci_hcd *ohci)\r\n{\r\nint ret;\r\nstruct usb_hcd *hcd = ohci_to_hcd(ohci);\r\nif (distrust_firmware)\r\nohci->flags |= OHCI_QUIRK_HUB_POWER;\r\nohci->rh_state = OHCI_RH_HALTED;\r\nohci->regs = hcd->regs;\r\n#ifndef IR_DISABLE\r\nif (!no_handshake && ohci_readl (ohci,\r\n&ohci->regs->control) & OHCI_CTRL_IR) {\r\nu32 temp;\r\nohci_dbg (ohci, "USB HC TakeOver from BIOS/SMM\n");\r\ntemp = 500;\r\nohci_writel (ohci, OHCI_INTR_OC, &ohci->regs->intrenable);\r\nohci_writel (ohci, OHCI_OCR, &ohci->regs->cmdstatus);\r\nwhile (ohci_readl (ohci, &ohci->regs->control) & OHCI_CTRL_IR) {\r\nmsleep (10);\r\nif (--temp == 0) {\r\nohci_err (ohci, "USB HC takeover failed!"\r\n" (BIOS/SMM bug)\n");\r\nreturn -EBUSY;\r\n}\r\n}\r\nohci_usb_reset (ohci);\r\n}\r\n#endif\r\nohci_writel (ohci, OHCI_INTR_MIE, &ohci->regs->intrdisable);\r\nif (ohci_readl (ohci, &ohci->regs->control) & OHCI_CTRL_RWC)\r\nohci->hc_control |= OHCI_CTRL_RWC;\r\nif (ohci->num_ports == 0)\r\nohci->num_ports = roothub_a(ohci) & RH_A_NDP;\r\nif (ohci->hcca)\r\nreturn 0;\r\nohci->hcca = dma_alloc_coherent (hcd->self.controller,\r\nsizeof *ohci->hcca, &ohci->hcca_dma, 0);\r\nif (!ohci->hcca)\r\nreturn -ENOMEM;\r\nif ((ret = ohci_mem_init (ohci)) < 0)\r\nohci_stop (hcd);\r\nelse {\r\ncreate_debug_files (ohci);\r\n}\r\nreturn ret;\r\n}\r\nstatic int ohci_run (struct ohci_hcd *ohci)\r\n{\r\nu32 mask, val;\r\nint first = ohci->fminterval == 0;\r\nstruct usb_hcd *hcd = ohci_to_hcd(ohci);\r\nohci->rh_state = OHCI_RH_HALTED;\r\nif (first) {\r\nval = ohci_readl (ohci, &ohci->regs->fminterval);\r\nohci->fminterval = val & 0x3fff;\r\nif (ohci->fminterval != FI)\r\nohci_dbg (ohci, "fminterval delta %d\n",\r\nohci->fminterval - FI);\r\nohci->fminterval |= FSMP (ohci->fminterval) << 16;\r\n}\r\nif ((ohci->hc_control & OHCI_CTRL_RWC) != 0)\r\ndevice_set_wakeup_capable(hcd->self.controller, 1);\r\nswitch (ohci->hc_control & OHCI_CTRL_HCFS) {\r\ncase OHCI_USB_OPER:\r\nval = 0;\r\nbreak;\r\ncase OHCI_USB_SUSPEND:\r\ncase OHCI_USB_RESUME:\r\nohci->hc_control &= OHCI_CTRL_RWC;\r\nohci->hc_control |= OHCI_USB_RESUME;\r\nval = 10 ;\r\nbreak;\r\ndefault:\r\nohci->hc_control &= OHCI_CTRL_RWC;\r\nohci->hc_control |= OHCI_USB_RESET;\r\nval = 50 ;\r\nbreak;\r\n}\r\nohci_writel (ohci, ohci->hc_control, &ohci->regs->control);\r\n(void) ohci_readl (ohci, &ohci->regs->control);\r\nmsleep(val);\r\nmemset (ohci->hcca, 0, sizeof (struct ohci_hcca));\r\nspin_lock_irq (&ohci->lock);\r\nretry:\r\nohci_writel (ohci, OHCI_HCR, &ohci->regs->cmdstatus);\r\nval = 30;\r\nwhile ((ohci_readl (ohci, &ohci->regs->cmdstatus) & OHCI_HCR) != 0) {\r\nif (--val == 0) {\r\nspin_unlock_irq (&ohci->lock);\r\nohci_err (ohci, "USB HC reset timed out!\n");\r\nreturn -1;\r\n}\r\nudelay (1);\r\n}\r\nif (ohci->flags & OHCI_QUIRK_INITRESET) {\r\nohci_writel (ohci, ohci->hc_control, &ohci->regs->control);\r\n(void) ohci_readl (ohci, &ohci->regs->control);\r\n}\r\nohci_writel (ohci, 0, &ohci->regs->ed_controlhead);\r\nohci_writel (ohci, 0, &ohci->regs->ed_bulkhead);\r\nohci_writel (ohci, (u32) ohci->hcca_dma, &ohci->regs->hcca);\r\nperiodic_reinit (ohci);\r\nif ((ohci_readl (ohci, &ohci->regs->fminterval) & 0x3fff0000) == 0\r\n|| !ohci_readl (ohci, &ohci->regs->periodicstart)) {\r\nif (!(ohci->flags & OHCI_QUIRK_INITRESET)) {\r\nohci->flags |= OHCI_QUIRK_INITRESET;\r\nohci_dbg (ohci, "enabling initreset quirk\n");\r\ngoto retry;\r\n}\r\nspin_unlock_irq (&ohci->lock);\r\nohci_err (ohci, "init err (%08x %04x)\n",\r\nohci_readl (ohci, &ohci->regs->fminterval),\r\nohci_readl (ohci, &ohci->regs->periodicstart));\r\nreturn -EOVERFLOW;\r\n}\r\nset_bit(HCD_FLAG_POLL_RH, &hcd->flags);\r\nhcd->uses_new_polling = 1;\r\nohci->hc_control &= OHCI_CTRL_RWC;\r\nohci->hc_control |= OHCI_CONTROL_INIT | OHCI_USB_OPER;\r\nohci_writel (ohci, ohci->hc_control, &ohci->regs->control);\r\nohci->rh_state = OHCI_RH_RUNNING;\r\nohci_writel (ohci, RH_HS_DRWE, &ohci->regs->roothub.status);\r\nmask = OHCI_INTR_INIT;\r\nohci_writel (ohci, ~0, &ohci->regs->intrstatus);\r\nohci_writel (ohci, mask, &ohci->regs->intrenable);\r\nval = roothub_a (ohci);\r\nval &= ~(RH_A_PSM | RH_A_OCPM);\r\nif (ohci->flags & OHCI_QUIRK_SUPERIO) {\r\nval |= RH_A_NOCP;\r\nval &= ~(RH_A_POTPGT | RH_A_NPS);\r\nohci_writel (ohci, val, &ohci->regs->roothub.a);\r\n} else if ((ohci->flags & OHCI_QUIRK_AMD756) ||\r\n(ohci->flags & OHCI_QUIRK_HUB_POWER)) {\r\nval |= RH_A_NPS;\r\nohci_writel (ohci, val, &ohci->regs->roothub.a);\r\n}\r\nohci_writel (ohci, RH_HS_LPSC, &ohci->regs->roothub.status);\r\nohci_writel (ohci, (val & RH_A_NPS) ? 0 : RH_B_PPCM,\r\n&ohci->regs->roothub.b);\r\n(void) ohci_readl (ohci, &ohci->regs->control);\r\nohci->next_statechange = jiffies + STATECHANGE_DELAY;\r\nspin_unlock_irq (&ohci->lock);\r\nmdelay ((val >> 23) & 0x1fe);\r\nif (quirk_zfmicro(ohci)) {\r\nsetup_timer(&ohci->unlink_watchdog, unlink_watchdog_func,\r\n(unsigned long) ohci);\r\nohci->eds_scheduled = 0;\r\nohci->ed_to_check = NULL;\r\n}\r\nohci_dump (ohci, 1);\r\nreturn 0;\r\n}\r\nstatic irqreturn_t ohci_irq (struct usb_hcd *hcd)\r\n{\r\nstruct ohci_hcd *ohci = hcd_to_ohci (hcd);\r\nstruct ohci_regs __iomem *regs = ohci->regs;\r\nint ints;\r\nints = ohci_readl(ohci, &regs->intrstatus);\r\nif (ints == ~(u32)0) {\r\nohci->rh_state = OHCI_RH_HALTED;\r\nohci_dbg (ohci, "device removed!\n");\r\nusb_hc_died(hcd);\r\nreturn IRQ_HANDLED;\r\n}\r\nints &= ohci_readl(ohci, &regs->intrenable);\r\nif (ints == 0 || unlikely(ohci->rh_state == OHCI_RH_HALTED))\r\nreturn IRQ_NOTMINE;\r\nif (ints & OHCI_INTR_UE) {\r\nif (quirk_nec(ohci)) {\r\nohci_err (ohci, "OHCI Unrecoverable Error, scheduling NEC chip restart\n");\r\nohci_writel (ohci, OHCI_INTR_UE, &regs->intrdisable);\r\nschedule_work (&ohci->nec_work);\r\n} else {\r\nohci_err (ohci, "OHCI Unrecoverable Error, disabled\n");\r\nohci->rh_state = OHCI_RH_HALTED;\r\nusb_hc_died(hcd);\r\n}\r\nohci_dump (ohci, 1);\r\nohci_usb_reset (ohci);\r\n}\r\nif (ints & OHCI_INTR_RHSC) {\r\nohci_vdbg(ohci, "rhsc\n");\r\nohci->next_statechange = jiffies + STATECHANGE_DELAY;\r\nohci_writel(ohci, OHCI_INTR_RD | OHCI_INTR_RHSC,\r\n&regs->intrstatus);\r\nohci_writel(ohci, OHCI_INTR_RHSC, &regs->intrdisable);\r\nusb_hcd_poll_rh_status(hcd);\r\n}\r\nelse if (ints & OHCI_INTR_RD) {\r\nohci_vdbg(ohci, "resume detect\n");\r\nohci_writel(ohci, OHCI_INTR_RD, &regs->intrstatus);\r\nset_bit(HCD_FLAG_POLL_RH, &hcd->flags);\r\nif (ohci->autostop) {\r\nspin_lock (&ohci->lock);\r\nohci_rh_resume (ohci);\r\nspin_unlock (&ohci->lock);\r\n} else\r\nusb_hcd_resume_root_hub(hcd);\r\n}\r\nif (ints & OHCI_INTR_WDH) {\r\nspin_lock (&ohci->lock);\r\ndl_done_list (ohci);\r\nspin_unlock (&ohci->lock);\r\n}\r\nif (quirk_zfmicro(ohci) && (ints & OHCI_INTR_SF)) {\r\nspin_lock(&ohci->lock);\r\nif (ohci->ed_to_check) {\r\nstruct ed *ed = ohci->ed_to_check;\r\nif (check_ed(ohci, ed)) {\r\nif (--ohci->zf_delay == 0) {\r\nstruct td *td = list_entry(\r\ned->td_list.next,\r\nstruct td, td_list);\r\nohci_warn(ohci,\r\n"Reclaiming orphan TD %p\n",\r\ntd);\r\ntakeback_td(ohci, td);\r\nohci->ed_to_check = NULL;\r\n}\r\n} else\r\nohci->ed_to_check = NULL;\r\n}\r\nspin_unlock(&ohci->lock);\r\n}\r\nspin_lock (&ohci->lock);\r\nif (ohci->ed_rm_list)\r\nfinish_unlinks (ohci, ohci_frame_no(ohci));\r\nif ((ints & OHCI_INTR_SF) != 0\r\n&& !ohci->ed_rm_list\r\n&& !ohci->ed_to_check\r\n&& ohci->rh_state == OHCI_RH_RUNNING)\r\nohci_writel (ohci, OHCI_INTR_SF, &regs->intrdisable);\r\nspin_unlock (&ohci->lock);\r\nif (ohci->rh_state == OHCI_RH_RUNNING) {\r\nohci_writel (ohci, ints, &regs->intrstatus);\r\nohci_writel (ohci, OHCI_INTR_MIE, &regs->intrenable);\r\n(void) ohci_readl (ohci, &ohci->regs->control);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void ohci_stop (struct usb_hcd *hcd)\r\n{\r\nstruct ohci_hcd *ohci = hcd_to_ohci (hcd);\r\nohci_dump (ohci, 1);\r\nif (quirk_nec(ohci))\r\nflush_work(&ohci->nec_work);\r\nohci_usb_reset (ohci);\r\nohci_writel (ohci, OHCI_INTR_MIE, &ohci->regs->intrdisable);\r\nfree_irq(hcd->irq, hcd);\r\nhcd->irq = 0;\r\nif (quirk_zfmicro(ohci))\r\ndel_timer(&ohci->unlink_watchdog);\r\nif (quirk_amdiso(ohci))\r\nusb_amd_dev_put();\r\nremove_debug_files (ohci);\r\nohci_mem_cleanup (ohci);\r\nif (ohci->hcca) {\r\ndma_free_coherent (hcd->self.controller,\r\nsizeof *ohci->hcca,\r\nohci->hcca, ohci->hcca_dma);\r\nohci->hcca = NULL;\r\nohci->hcca_dma = 0;\r\n}\r\n}\r\nstatic int ohci_restart (struct ohci_hcd *ohci)\r\n{\r\nint temp;\r\nint i;\r\nstruct urb_priv *priv;\r\nspin_lock_irq(&ohci->lock);\r\nohci->rh_state = OHCI_RH_HALTED;\r\nif (!list_empty (&ohci->pending))\r\nohci_dbg(ohci, "abort schedule...\n");\r\nlist_for_each_entry (priv, &ohci->pending, pending) {\r\nstruct urb *urb = priv->td[0]->urb;\r\nstruct ed *ed = priv->ed;\r\nswitch (ed->state) {\r\ncase ED_OPER:\r\ned->state = ED_UNLINK;\r\ned->hwINFO |= cpu_to_hc32(ohci, ED_DEQUEUE);\r\ned_deschedule (ohci, ed);\r\ned->ed_next = ohci->ed_rm_list;\r\ned->ed_prev = NULL;\r\nohci->ed_rm_list = ed;\r\ncase ED_UNLINK:\r\nbreak;\r\ndefault:\r\nohci_dbg(ohci, "bogus ed %p state %d\n",\r\ned, ed->state);\r\n}\r\nif (!urb->unlinked)\r\nurb->unlinked = -ESHUTDOWN;\r\n}\r\nfinish_unlinks (ohci, 0);\r\nspin_unlock_irq(&ohci->lock);\r\nfor (i = 0; i < NUM_INTS; i++) ohci->load [i] = 0;\r\nfor (i = 0; i < NUM_INTS; i++) ohci->hcca->int_table [i] = 0;\r\nohci->ed_rm_list = NULL;\r\nohci->ed_controltail = NULL;\r\nohci->ed_bulktail = NULL;\r\nif ((temp = ohci_run (ohci)) < 0) {\r\nohci_err (ohci, "can't restart, %d\n", temp);\r\nreturn temp;\r\n}\r\nohci_dbg(ohci, "restart complete\n");\r\nreturn 0;\r\n}\r\nstatic int __maybe_unused ohci_suspend(struct usb_hcd *hcd, bool do_wakeup)\r\n{\r\nstruct ohci_hcd *ohci = hcd_to_ohci (hcd);\r\nunsigned long flags;\r\nspin_lock_irqsave (&ohci->lock, flags);\r\nohci_writel(ohci, OHCI_INTR_MIE, &ohci->regs->intrdisable);\r\n(void)ohci_readl(ohci, &ohci->regs->intrdisable);\r\nclear_bit(HCD_FLAG_HW_ACCESSIBLE, &hcd->flags);\r\nspin_unlock_irqrestore (&ohci->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int __maybe_unused ohci_resume(struct usb_hcd *hcd, bool hibernated)\r\n{\r\nstruct ohci_hcd *ohci = hcd_to_ohci(hcd);\r\nint port;\r\nbool need_reinit = false;\r\nset_bit(HCD_FLAG_HW_ACCESSIBLE, &hcd->flags);\r\nif (hibernated)\r\nohci_usb_reset(ohci);\r\nohci->hc_control = ohci_readl(ohci, &ohci->regs->control);\r\nif (ohci->hc_control & (OHCI_CTRL_IR | OHCI_SCHED_ENABLES)) {\r\nneed_reinit = true;\r\n} else {\r\nswitch (ohci->hc_control & OHCI_CTRL_HCFS) {\r\ncase OHCI_USB_OPER:\r\ncase OHCI_USB_RESET:\r\nneed_reinit = true;\r\n}\r\n}\r\nif (need_reinit) {\r\nspin_lock_irq(&ohci->lock);\r\nohci_rh_resume(ohci);\r\nohci_rh_suspend(ohci, 0);\r\nspin_unlock_irq(&ohci->lock);\r\n}\r\nelse {\r\nohci_dbg(ohci, "powerup ports\n");\r\nfor (port = 0; port < ohci->num_ports; port++)\r\nohci_writel(ohci, RH_PS_PPS,\r\n&ohci->regs->roothub.portstatus[port]);\r\nohci_writel(ohci, OHCI_INTR_MIE, &ohci->regs->intrenable);\r\nohci_readl(ohci, &ohci->regs->intrenable);\r\nmsleep(20);\r\n}\r\nusb_hcd_resume_root_hub(hcd);\r\nreturn 0;\r\n}\r\nstatic int __init ohci_hcd_mod_init(void)\r\n{\r\nint retval = 0;\r\nif (usb_disabled())\r\nreturn -ENODEV;\r\nprintk(KERN_INFO "%s: " DRIVER_DESC "\n", hcd_name);\r\npr_debug ("%s: block sizes: ed %Zd td %Zd\n", hcd_name,\r\nsizeof (struct ed), sizeof (struct td));\r\nset_bit(USB_OHCI_LOADED, &usb_hcds_loaded);\r\n#ifdef DEBUG\r\nohci_debug_root = debugfs_create_dir("ohci", usb_debug_root);\r\nif (!ohci_debug_root) {\r\nretval = -ENOENT;\r\ngoto error_debug;\r\n}\r\n#endif\r\n#ifdef PS3_SYSTEM_BUS_DRIVER\r\nretval = ps3_ohci_driver_register(&PS3_SYSTEM_BUS_DRIVER);\r\nif (retval < 0)\r\ngoto error_ps3;\r\n#endif\r\n#ifdef PLATFORM_DRIVER\r\nretval = platform_driver_register(&PLATFORM_DRIVER);\r\nif (retval < 0)\r\ngoto error_platform;\r\n#endif\r\n#ifdef OMAP1_PLATFORM_DRIVER\r\nretval = platform_driver_register(&OMAP1_PLATFORM_DRIVER);\r\nif (retval < 0)\r\ngoto error_omap1_platform;\r\n#endif\r\n#ifdef OMAP3_PLATFORM_DRIVER\r\nretval = platform_driver_register(&OMAP3_PLATFORM_DRIVER);\r\nif (retval < 0)\r\ngoto error_omap3_platform;\r\n#endif\r\n#ifdef OF_PLATFORM_DRIVER\r\nretval = platform_driver_register(&OF_PLATFORM_DRIVER);\r\nif (retval < 0)\r\ngoto error_of_platform;\r\n#endif\r\n#ifdef SA1111_DRIVER\r\nretval = sa1111_driver_register(&SA1111_DRIVER);\r\nif (retval < 0)\r\ngoto error_sa1111;\r\n#endif\r\n#ifdef PCI_DRIVER\r\nretval = pci_register_driver(&PCI_DRIVER);\r\nif (retval < 0)\r\ngoto error_pci;\r\n#endif\r\n#ifdef SM501_OHCI_DRIVER\r\nretval = platform_driver_register(&SM501_OHCI_DRIVER);\r\nif (retval < 0)\r\ngoto error_sm501;\r\n#endif\r\n#ifdef TMIO_OHCI_DRIVER\r\nretval = platform_driver_register(&TMIO_OHCI_DRIVER);\r\nif (retval < 0)\r\ngoto error_tmio;\r\n#endif\r\nreturn retval;\r\n#ifdef TMIO_OHCI_DRIVER\r\nplatform_driver_unregister(&TMIO_OHCI_DRIVER);\r\nerror_tmio:\r\n#endif\r\n#ifdef SM501_OHCI_DRIVER\r\nplatform_driver_unregister(&SM501_OHCI_DRIVER);\r\nerror_sm501:\r\n#endif\r\n#ifdef PCI_DRIVER\r\npci_unregister_driver(&PCI_DRIVER);\r\nerror_pci:\r\n#endif\r\n#ifdef SA1111_DRIVER\r\nsa1111_driver_unregister(&SA1111_DRIVER);\r\nerror_sa1111:\r\n#endif\r\n#ifdef OF_PLATFORM_DRIVER\r\nplatform_driver_unregister(&OF_PLATFORM_DRIVER);\r\nerror_of_platform:\r\n#endif\r\n#ifdef PLATFORM_DRIVER\r\nplatform_driver_unregister(&PLATFORM_DRIVER);\r\nerror_platform:\r\n#endif\r\n#ifdef OMAP1_PLATFORM_DRIVER\r\nplatform_driver_unregister(&OMAP1_PLATFORM_DRIVER);\r\nerror_omap1_platform:\r\n#endif\r\n#ifdef OMAP3_PLATFORM_DRIVER\r\nplatform_driver_unregister(&OMAP3_PLATFORM_DRIVER);\r\nerror_omap3_platform:\r\n#endif\r\n#ifdef PS3_SYSTEM_BUS_DRIVER\r\nps3_ohci_driver_unregister(&PS3_SYSTEM_BUS_DRIVER);\r\nerror_ps3:\r\n#endif\r\n#ifdef DEBUG\r\ndebugfs_remove(ohci_debug_root);\r\nohci_debug_root = NULL;\r\nerror_debug:\r\n#endif\r\nclear_bit(USB_OHCI_LOADED, &usb_hcds_loaded);\r\nreturn retval;\r\n}\r\nstatic void __exit ohci_hcd_mod_exit(void)\r\n{\r\n#ifdef TMIO_OHCI_DRIVER\r\nplatform_driver_unregister(&TMIO_OHCI_DRIVER);\r\n#endif\r\n#ifdef SM501_OHCI_DRIVER\r\nplatform_driver_unregister(&SM501_OHCI_DRIVER);\r\n#endif\r\n#ifdef PCI_DRIVER\r\npci_unregister_driver(&PCI_DRIVER);\r\n#endif\r\n#ifdef SA1111_DRIVER\r\nsa1111_driver_unregister(&SA1111_DRIVER);\r\n#endif\r\n#ifdef OF_PLATFORM_DRIVER\r\nplatform_driver_unregister(&OF_PLATFORM_DRIVER);\r\n#endif\r\n#ifdef PLATFORM_DRIVER\r\nplatform_driver_unregister(&PLATFORM_DRIVER);\r\n#endif\r\n#ifdef OMAP3_PLATFORM_DRIVER\r\nplatform_driver_unregister(&OMAP3_PLATFORM_DRIVER);\r\n#endif\r\n#ifdef PS3_SYSTEM_BUS_DRIVER\r\nps3_ohci_driver_unregister(&PS3_SYSTEM_BUS_DRIVER);\r\n#endif\r\n#ifdef DEBUG\r\ndebugfs_remove(ohci_debug_root);\r\n#endif\r\nclear_bit(USB_OHCI_LOADED, &usb_hcds_loaded);\r\n}
