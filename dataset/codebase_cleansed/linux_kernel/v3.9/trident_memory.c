static inline void set_tlb_bus(struct snd_trident *trident, int page,\r\nunsigned long ptr, dma_addr_t addr)\r\n{\r\npage <<= 1;\r\n__set_tlb_bus(trident, page, ptr, addr);\r\n__set_tlb_bus(trident, page+1, ptr + SNDRV_TRIDENT_PAGE_SIZE, addr + SNDRV_TRIDENT_PAGE_SIZE);\r\n}\r\nstatic inline void set_silent_tlb(struct snd_trident *trident, int page)\r\n{\r\npage <<= 1;\r\n__set_tlb_bus(trident, page, (unsigned long)trident->tlb.silent_page.area, trident->tlb.silent_page.addr);\r\n__set_tlb_bus(trident, page+1, (unsigned long)trident->tlb.silent_page.area, trident->tlb.silent_page.addr);\r\n}\r\nstatic inline void set_tlb_bus(struct snd_trident *trident, int page,\r\nunsigned long ptr, dma_addr_t addr)\r\n{\r\nint i;\r\npage *= UNIT_PAGES;\r\nfor (i = 0; i < UNIT_PAGES; i++, page++) {\r\n__set_tlb_bus(trident, page, ptr, addr);\r\nptr += SNDRV_TRIDENT_PAGE_SIZE;\r\naddr += SNDRV_TRIDENT_PAGE_SIZE;\r\n}\r\n}\r\nstatic inline void set_silent_tlb(struct snd_trident *trident, int page)\r\n{\r\nint i;\r\npage *= UNIT_PAGES;\r\nfor (i = 0; i < UNIT_PAGES; i++, page++)\r\n__set_tlb_bus(trident, page, (unsigned long)trident->tlb.silent_page.area, trident->tlb.silent_page.addr);\r\n}\r\nstatic inline void *offset_ptr(struct snd_trident *trident, int offset)\r\n{\r\nchar *ptr;\r\nptr = page_to_ptr(trident, get_aligned_page(offset));\r\nptr += offset % ALIGN_PAGE_SIZE;\r\nreturn (void*)ptr;\r\n}\r\nstatic struct snd_util_memblk *\r\nsearch_empty(struct snd_util_memhdr *hdr, int size)\r\n{\r\nstruct snd_util_memblk *blk, *prev;\r\nint page, psize;\r\nstruct list_head *p;\r\npsize = get_aligned_page(size + ALIGN_PAGE_SIZE -1);\r\nprev = NULL;\r\npage = 0;\r\nlist_for_each(p, &hdr->block) {\r\nblk = list_entry(p, struct snd_util_memblk, list);\r\nif (page + psize <= firstpg(blk))\r\ngoto __found_pages;\r\npage = lastpg(blk) + 1;\r\n}\r\nif (page + psize > MAX_ALIGN_PAGES)\r\nreturn NULL;\r\n__found_pages:\r\nblk = __snd_util_memblk_new(hdr, psize * ALIGN_PAGE_SIZE, p->prev);\r\nif (blk == NULL)\r\nreturn NULL;\r\nblk->offset = aligned_page_offset(page);\r\nfirstpg(blk) = page;\r\nlastpg(blk) = page + psize - 1;\r\nreturn blk;\r\n}\r\nstatic int is_valid_page(unsigned long ptr)\r\n{\r\nif (ptr & ~0x3fffffffUL) {\r\nsnd_printk(KERN_ERR "max memory size is 1GB!!\n");\r\nreturn 0;\r\n}\r\nif (ptr & (SNDRV_TRIDENT_PAGE_SIZE-1)) {\r\nsnd_printk(KERN_ERR "page is not aligned\n");\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nstatic struct snd_util_memblk *\r\nsnd_trident_alloc_sg_pages(struct snd_trident *trident,\r\nstruct snd_pcm_substream *substream)\r\n{\r\nstruct snd_util_memhdr *hdr;\r\nstruct snd_util_memblk *blk;\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nint idx, page;\r\nif (snd_BUG_ON(runtime->dma_bytes <= 0 ||\r\nruntime->dma_bytes > SNDRV_TRIDENT_MAX_PAGES *\r\nSNDRV_TRIDENT_PAGE_SIZE))\r\nreturn NULL;\r\nhdr = trident->tlb.memhdr;\r\nif (snd_BUG_ON(!hdr))\r\nreturn NULL;\r\nmutex_lock(&hdr->block_mutex);\r\nblk = search_empty(hdr, runtime->dma_bytes);\r\nif (blk == NULL) {\r\nmutex_unlock(&hdr->block_mutex);\r\nreturn NULL;\r\n}\r\nidx = 0;\r\nfor (page = firstpg(blk); page <= lastpg(blk); page++, idx++) {\r\nunsigned long ofs = idx << PAGE_SHIFT;\r\ndma_addr_t addr = snd_pcm_sgbuf_get_addr(substream, ofs);\r\nunsigned long ptr = (unsigned long)\r\nsnd_pcm_sgbuf_get_ptr(substream, ofs);\r\nif (! is_valid_page(addr)) {\r\n__snd_util_mem_free(hdr, blk);\r\nmutex_unlock(&hdr->block_mutex);\r\nreturn NULL;\r\n}\r\nset_tlb_bus(trident, page, ptr, addr);\r\n}\r\nmutex_unlock(&hdr->block_mutex);\r\nreturn blk;\r\n}\r\nstatic struct snd_util_memblk *\r\nsnd_trident_alloc_cont_pages(struct snd_trident *trident,\r\nstruct snd_pcm_substream *substream)\r\n{\r\nstruct snd_util_memhdr *hdr;\r\nstruct snd_util_memblk *blk;\r\nint page;\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\ndma_addr_t addr;\r\nunsigned long ptr;\r\nif (snd_BUG_ON(runtime->dma_bytes <= 0 ||\r\nruntime->dma_bytes > SNDRV_TRIDENT_MAX_PAGES *\r\nSNDRV_TRIDENT_PAGE_SIZE))\r\nreturn NULL;\r\nhdr = trident->tlb.memhdr;\r\nif (snd_BUG_ON(!hdr))\r\nreturn NULL;\r\nmutex_lock(&hdr->block_mutex);\r\nblk = search_empty(hdr, runtime->dma_bytes);\r\nif (blk == NULL) {\r\nmutex_unlock(&hdr->block_mutex);\r\nreturn NULL;\r\n}\r\naddr = runtime->dma_addr;\r\nptr = (unsigned long)runtime->dma_area;\r\nfor (page = firstpg(blk); page <= lastpg(blk); page++,\r\nptr += SNDRV_TRIDENT_PAGE_SIZE, addr += SNDRV_TRIDENT_PAGE_SIZE) {\r\nif (! is_valid_page(addr)) {\r\n__snd_util_mem_free(hdr, blk);\r\nmutex_unlock(&hdr->block_mutex);\r\nreturn NULL;\r\n}\r\nset_tlb_bus(trident, page, ptr, addr);\r\n}\r\nmutex_unlock(&hdr->block_mutex);\r\nreturn blk;\r\n}\r\nstruct snd_util_memblk *\r\nsnd_trident_alloc_pages(struct snd_trident *trident,\r\nstruct snd_pcm_substream *substream)\r\n{\r\nif (snd_BUG_ON(!trident || !substream))\r\nreturn NULL;\r\nif (substream->dma_buffer.dev.type == SNDRV_DMA_TYPE_DEV_SG)\r\nreturn snd_trident_alloc_sg_pages(trident, substream);\r\nelse\r\nreturn snd_trident_alloc_cont_pages(trident, substream);\r\n}\r\nint snd_trident_free_pages(struct snd_trident *trident,\r\nstruct snd_util_memblk *blk)\r\n{\r\nstruct snd_util_memhdr *hdr;\r\nint page;\r\nif (snd_BUG_ON(!trident || !blk))\r\nreturn -EINVAL;\r\nhdr = trident->tlb.memhdr;\r\nmutex_lock(&hdr->block_mutex);\r\nfor (page = firstpg(blk); page <= lastpg(blk); page++)\r\nset_silent_tlb(trident, page);\r\n__snd_util_mem_free(hdr, blk);\r\nmutex_unlock(&hdr->block_mutex);\r\nreturn 0;\r\n}
