static struct eeh_pe *eeh_pe_alloc(struct pci_controller *phb, int type)\r\n{\r\nstruct eeh_pe *pe;\r\npe = kzalloc(sizeof(struct eeh_pe), GFP_KERNEL);\r\nif (!pe) return NULL;\r\npe->type = type;\r\npe->phb = phb;\r\nINIT_LIST_HEAD(&pe->child_list);\r\nINIT_LIST_HEAD(&pe->child);\r\nINIT_LIST_HEAD(&pe->edevs);\r\nreturn pe;\r\n}\r\nint eeh_phb_pe_create(struct pci_controller *phb)\r\n{\r\nstruct eeh_pe *pe;\r\npe = eeh_pe_alloc(phb, EEH_PE_PHB);\r\nif (!pe) {\r\npr_err("%s: out of memory!\n", __func__);\r\nreturn -ENOMEM;\r\n}\r\neeh_lock();\r\nlist_add_tail(&pe->child, &eeh_phb_pe);\r\neeh_unlock();\r\npr_debug("EEH: Add PE for PHB#%d\n", phb->global_number);\r\nreturn 0;\r\n}\r\nstatic struct eeh_pe *eeh_phb_pe_get(struct pci_controller *phb)\r\n{\r\nstruct eeh_pe *pe;\r\nlist_for_each_entry(pe, &eeh_phb_pe, child) {\r\nif ((pe->type & EEH_PE_PHB) && pe->phb == phb)\r\nreturn pe;\r\n}\r\nreturn NULL;\r\n}\r\nstatic struct eeh_pe *eeh_pe_next(struct eeh_pe *pe,\r\nstruct eeh_pe *root)\r\n{\r\nstruct list_head *next = pe->child_list.next;\r\nif (next == &pe->child_list) {\r\nwhile (1) {\r\nif (pe == root)\r\nreturn NULL;\r\nnext = pe->child.next;\r\nif (next != &pe->parent->child_list)\r\nbreak;\r\npe = pe->parent;\r\n}\r\n}\r\nreturn list_entry(next, struct eeh_pe, child);\r\n}\r\nstatic void *eeh_pe_traverse(struct eeh_pe *root,\r\neeh_traverse_func fn, void *flag)\r\n{\r\nstruct eeh_pe *pe;\r\nvoid *ret;\r\nfor (pe = root; pe; pe = eeh_pe_next(pe, root)) {\r\nret = fn(pe, flag);\r\nif (ret) return ret;\r\n}\r\nreturn NULL;\r\n}\r\nvoid *eeh_pe_dev_traverse(struct eeh_pe *root,\r\neeh_traverse_func fn, void *flag)\r\n{\r\nstruct eeh_pe *pe;\r\nstruct eeh_dev *edev;\r\nvoid *ret;\r\nif (!root) {\r\npr_warning("%s: Invalid PE %p\n", __func__, root);\r\nreturn NULL;\r\n}\r\neeh_lock();\r\nfor (pe = root; pe; pe = eeh_pe_next(pe, root)) {\r\neeh_pe_for_each_dev(pe, edev) {\r\nret = fn(edev, flag);\r\nif (ret) {\r\neeh_unlock();\r\nreturn ret;\r\n}\r\n}\r\n}\r\neeh_unlock();\r\nreturn NULL;\r\n}\r\nstatic void *__eeh_pe_get(void *data, void *flag)\r\n{\r\nstruct eeh_pe *pe = (struct eeh_pe *)data;\r\nstruct eeh_dev *edev = (struct eeh_dev *)flag;\r\nif (pe->type & EEH_PE_PHB)\r\nreturn NULL;\r\nif (edev->pe_config_addr &&\r\n(edev->pe_config_addr == pe->addr))\r\nreturn pe;\r\nif (edev->pe_config_addr &&\r\n(edev->config_addr == pe->config_addr))\r\nreturn pe;\r\nreturn NULL;\r\n}\r\nstatic struct eeh_pe *eeh_pe_get(struct eeh_dev *edev)\r\n{\r\nstruct eeh_pe *root = eeh_phb_pe_get(edev->phb);\r\nstruct eeh_pe *pe;\r\npe = eeh_pe_traverse(root, __eeh_pe_get, edev);\r\nreturn pe;\r\n}\r\nstatic struct eeh_pe *eeh_pe_get_parent(struct eeh_dev *edev)\r\n{\r\nstruct device_node *dn;\r\nstruct eeh_dev *parent;\r\ndn = edev->dn->parent;\r\nwhile (dn) {\r\nif (!PCI_DN(dn)) return NULL;\r\nparent = of_node_to_eeh_dev(dn);\r\nif (!parent) return NULL;\r\nif (parent->pe)\r\nreturn parent->pe;\r\ndn = dn->parent;\r\n}\r\nreturn NULL;\r\n}\r\nint eeh_add_to_parent_pe(struct eeh_dev *edev)\r\n{\r\nstruct eeh_pe *pe, *parent;\r\neeh_lock();\r\npe = eeh_pe_get(edev);\r\nif (pe && !(pe->type & EEH_PE_INVALID)) {\r\nif (!edev->pe_config_addr) {\r\neeh_unlock();\r\npr_err("%s: PE with addr 0x%x already exists\n",\r\n__func__, edev->config_addr);\r\nreturn -EEXIST;\r\n}\r\npe->type = EEH_PE_BUS;\r\nedev->pe = pe;\r\nlist_add_tail(&edev->list, &pe->edevs);\r\neeh_unlock();\r\npr_debug("EEH: Add %s to Bus PE#%x\n",\r\nedev->dn->full_name, pe->addr);\r\nreturn 0;\r\n} else if (pe && (pe->type & EEH_PE_INVALID)) {\r\nlist_add_tail(&edev->list, &pe->edevs);\r\nedev->pe = pe;\r\nparent = pe;\r\nwhile (parent) {\r\nif (!(parent->type & EEH_PE_INVALID))\r\nbreak;\r\nparent->type &= ~EEH_PE_INVALID;\r\nparent = parent->parent;\r\n}\r\neeh_unlock();\r\npr_debug("EEH: Add %s to Device PE#%x, Parent PE#%x\n",\r\nedev->dn->full_name, pe->addr, pe->parent->addr);\r\nreturn 0;\r\n}\r\npe = eeh_pe_alloc(edev->phb, EEH_PE_DEVICE);\r\nif (!pe) {\r\neeh_unlock();\r\npr_err("%s: out of memory!\n", __func__);\r\nreturn -ENOMEM;\r\n}\r\npe->addr = edev->pe_config_addr;\r\npe->config_addr = edev->config_addr;\r\nparent = eeh_pe_get_parent(edev);\r\nif (!parent) {\r\nparent = eeh_phb_pe_get(edev->phb);\r\nif (!parent) {\r\neeh_unlock();\r\npr_err("%s: No PHB PE is found (PHB Domain=%d)\n",\r\n__func__, edev->phb->global_number);\r\nedev->pe = NULL;\r\nkfree(pe);\r\nreturn -EEXIST;\r\n}\r\n}\r\npe->parent = parent;\r\nlist_add_tail(&pe->child, &parent->child_list);\r\nlist_add_tail(&edev->list, &pe->edevs);\r\nedev->pe = pe;\r\neeh_unlock();\r\npr_debug("EEH: Add %s to Device PE#%x, Parent PE#%x\n",\r\nedev->dn->full_name, pe->addr, pe->parent->addr);\r\nreturn 0;\r\n}\r\nint eeh_rmv_from_parent_pe(struct eeh_dev *edev, int purge_pe)\r\n{\r\nstruct eeh_pe *pe, *parent, *child;\r\nint cnt;\r\nif (!edev->pe) {\r\npr_warning("%s: No PE found for EEH device %s\n",\r\n__func__, edev->dn->full_name);\r\nreturn -EEXIST;\r\n}\r\neeh_lock();\r\npe = edev->pe;\r\nedev->pe = NULL;\r\nlist_del(&edev->list);\r\nwhile (1) {\r\nparent = pe->parent;\r\nif (pe->type & EEH_PE_PHB)\r\nbreak;\r\nif (purge_pe) {\r\nif (list_empty(&pe->edevs) &&\r\nlist_empty(&pe->child_list)) {\r\nlist_del(&pe->child);\r\nkfree(pe);\r\n} else {\r\nbreak;\r\n}\r\n} else {\r\nif (list_empty(&pe->edevs)) {\r\ncnt = 0;\r\nlist_for_each_entry(child, &pe->child_list, child) {\r\nif (!(child->type & EEH_PE_INVALID)) {\r\ncnt++;\r\nbreak;\r\n}\r\n}\r\nif (!cnt)\r\npe->type |= EEH_PE_INVALID;\r\nelse\r\nbreak;\r\n}\r\n}\r\npe = parent;\r\n}\r\neeh_unlock();\r\nreturn 0;\r\n}\r\nstatic void *__eeh_pe_state_mark(void *data, void *flag)\r\n{\r\nstruct eeh_pe *pe = (struct eeh_pe *)data;\r\nint state = *((int *)flag);\r\nstruct eeh_dev *tmp;\r\nstruct pci_dev *pdev;\r\npe->state |= state;\r\neeh_pe_for_each_dev(pe, tmp) {\r\npdev = eeh_dev_to_pci_dev(tmp);\r\nif (pdev)\r\npdev->error_state = pci_channel_io_frozen;\r\n}\r\nreturn NULL;\r\n}\r\nvoid eeh_pe_state_mark(struct eeh_pe *pe, int state)\r\n{\r\neeh_lock();\r\neeh_pe_traverse(pe, __eeh_pe_state_mark, &state);\r\neeh_unlock();\r\n}\r\nstatic void *__eeh_pe_state_clear(void *data, void *flag)\r\n{\r\nstruct eeh_pe *pe = (struct eeh_pe *)data;\r\nint state = *((int *)flag);\r\npe->state &= ~state;\r\npe->check_count = 0;\r\nreturn NULL;\r\n}\r\nvoid eeh_pe_state_clear(struct eeh_pe *pe, int state)\r\n{\r\neeh_lock();\r\neeh_pe_traverse(pe, __eeh_pe_state_clear, &state);\r\neeh_unlock();\r\n}\r\nstatic void *eeh_restore_one_device_bars(void *data, void *flag)\r\n{\r\nint i;\r\nu32 cmd;\r\nstruct eeh_dev *edev = (struct eeh_dev *)data;\r\nstruct device_node *dn = eeh_dev_to_of_node(edev);\r\nfor (i = 4; i < 10; i++)\r\neeh_ops->write_config(dn, i*4, 4, edev->config_space[i]);\r\neeh_ops->write_config(dn, 12*4, 4, edev->config_space[12]);\r\n#define BYTE_SWAP(OFF) (8*((OFF)/4)+3-(OFF))\r\n#define SAVED_BYTE(OFF) (((u8 *)(edev->config_space))[BYTE_SWAP(OFF)])\r\neeh_ops->write_config(dn, PCI_CACHE_LINE_SIZE, 1,\r\nSAVED_BYTE(PCI_CACHE_LINE_SIZE));\r\neeh_ops->write_config(dn, PCI_LATENCY_TIMER, 1,\r\nSAVED_BYTE(PCI_LATENCY_TIMER));\r\neeh_ops->write_config(dn, 15*4, 4, edev->config_space[15]);\r\neeh_ops->read_config(dn, PCI_COMMAND, 4, &cmd);\r\nif (edev->config_space[1] & PCI_COMMAND_PARITY)\r\ncmd |= PCI_COMMAND_PARITY;\r\nelse\r\ncmd &= ~PCI_COMMAND_PARITY;\r\nif (edev->config_space[1] & PCI_COMMAND_SERR)\r\ncmd |= PCI_COMMAND_SERR;\r\nelse\r\ncmd &= ~PCI_COMMAND_SERR;\r\neeh_ops->write_config(dn, PCI_COMMAND, 4, cmd);\r\nreturn NULL;\r\n}\r\nvoid eeh_pe_restore_bars(struct eeh_pe *pe)\r\n{\r\neeh_pe_dev_traverse(pe, eeh_restore_one_device_bars, NULL);\r\n}\r\nstruct pci_bus *eeh_pe_bus_get(struct eeh_pe *pe)\r\n{\r\nstruct pci_bus *bus = NULL;\r\nstruct eeh_dev *edev;\r\nstruct pci_dev *pdev;\r\neeh_lock();\r\nif (pe->type & EEH_PE_PHB) {\r\nbus = pe->phb->bus;\r\n} else if (pe->type & EEH_PE_BUS) {\r\nedev = list_first_entry(&pe->edevs, struct eeh_dev, list);\r\npdev = eeh_dev_to_pci_dev(edev);\r\nif (pdev)\r\nbus = pdev->bus;\r\n}\r\neeh_unlock();\r\nreturn bus;\r\n}
