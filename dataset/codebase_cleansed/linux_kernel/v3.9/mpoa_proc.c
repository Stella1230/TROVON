static const char *ingress_state_string(int state)\r\n{\r\nswitch (state) {\r\ncase INGRESS_RESOLVING:\r\nreturn "resolving ";\r\ncase INGRESS_RESOLVED:\r\nreturn "resolved ";\r\ncase INGRESS_INVALID:\r\nreturn "invalid ";\r\ncase INGRESS_REFRESHING:\r\nreturn "refreshing ";\r\n}\r\nreturn "";\r\n}\r\nstatic const char *egress_state_string(int state)\r\n{\r\nswitch (state) {\r\ncase EGRESS_RESOLVED:\r\nreturn "resolved ";\r\ncase EGRESS_PURGE:\r\nreturn "purge ";\r\ncase EGRESS_INVALID:\r\nreturn "invalid ";\r\n}\r\nreturn "";\r\n}\r\nstatic void *mpc_start(struct seq_file *m, loff_t *pos)\r\n{\r\nloff_t l = *pos;\r\nstruct mpoa_client *mpc;\r\nif (!l--)\r\nreturn SEQ_START_TOKEN;\r\nfor (mpc = mpcs; mpc; mpc = mpc->next)\r\nif (!l--)\r\nreturn mpc;\r\nreturn NULL;\r\n}\r\nstatic void *mpc_next(struct seq_file *m, void *v, loff_t *pos)\r\n{\r\nstruct mpoa_client *p = v;\r\n(*pos)++;\r\nreturn v == SEQ_START_TOKEN ? mpcs : p->next;\r\n}\r\nstatic void mpc_stop(struct seq_file *m, void *v)\r\n{\r\n}\r\nstatic int mpc_show(struct seq_file *m, void *v)\r\n{\r\nstruct mpoa_client *mpc = v;\r\nint i;\r\nin_cache_entry *in_entry;\r\neg_cache_entry *eg_entry;\r\nstruct timeval now;\r\nunsigned char ip_string[16];\r\nif (v == SEQ_START_TOKEN) {\r\natm_mpoa_disp_qos(m);\r\nreturn 0;\r\n}\r\nseq_printf(m, "\nInterface %d:\n\n", mpc->dev_num);\r\nseq_printf(m, "Ingress Entries:\nIP address State Holding time Packets fwded VPI VCI\n");\r\ndo_gettimeofday(&now);\r\nfor (in_entry = mpc->in_cache; in_entry; in_entry = in_entry->next) {\r\nsprintf(ip_string, "%pI4", &in_entry->ctrl_info.in_dst_ip);\r\nseq_printf(m, "%-16s%s%-14lu%-12u",\r\nip_string,\r\ningress_state_string(in_entry->entry_state),\r\nin_entry->ctrl_info.holding_time -\r\n(now.tv_sec-in_entry->tv.tv_sec),\r\nin_entry->packets_fwded);\r\nif (in_entry->shortcut)\r\nseq_printf(m, " %-3d %-3d",\r\nin_entry->shortcut->vpi,\r\nin_entry->shortcut->vci);\r\nseq_printf(m, "\n");\r\n}\r\nseq_printf(m, "\n");\r\nseq_printf(m, "Egress Entries:\nIngress MPC ATM addr\nCache-id State Holding time Packets recvd Latest IP addr VPI VCI\n");\r\nfor (eg_entry = mpc->eg_cache; eg_entry; eg_entry = eg_entry->next) {\r\nunsigned char *p = eg_entry->ctrl_info.in_MPC_data_ATM_addr;\r\nfor (i = 0; i < ATM_ESA_LEN; i++)\r\nseq_printf(m, "%02x", p[i]);\r\nseq_printf(m, "\n%-16lu%s%-14lu%-15u",\r\n(unsigned long)ntohl(eg_entry->ctrl_info.cache_id),\r\negress_state_string(eg_entry->entry_state),\r\n(eg_entry->ctrl_info.holding_time -\r\n(now.tv_sec-eg_entry->tv.tv_sec)),\r\neg_entry->packets_rcvd);\r\nsprintf(ip_string, "%pI4", &eg_entry->latest_ip_addr);\r\nseq_printf(m, "%-16s", ip_string);\r\nif (eg_entry->shortcut)\r\nseq_printf(m, " %-3d %-3d",\r\neg_entry->shortcut->vpi,\r\neg_entry->shortcut->vci);\r\nseq_printf(m, "\n");\r\n}\r\nseq_printf(m, "\n");\r\nreturn 0;\r\n}\r\nstatic int proc_mpc_open(struct inode *inode, struct file *file)\r\n{\r\nreturn seq_open(file, &mpc_op);\r\n}\r\nstatic ssize_t proc_mpc_write(struct file *file, const char __user *buff,\r\nsize_t nbytes, loff_t *ppos)\r\n{\r\nchar *page, *p;\r\nunsigned int len;\r\nif (nbytes == 0)\r\nreturn 0;\r\nif (nbytes >= PAGE_SIZE)\r\nnbytes = PAGE_SIZE-1;\r\npage = (char *)__get_free_page(GFP_KERNEL);\r\nif (!page)\r\nreturn -ENOMEM;\r\nfor (p = page, len = 0; len < nbytes; p++, len++) {\r\nif (get_user(*p, buff++)) {\r\nfree_page((unsigned long)page);\r\nreturn -EFAULT;\r\n}\r\nif (*p == '\0' || *p == '\n')\r\nbreak;\r\n}\r\n*p = '\0';\r\nif (!parse_qos(page))\r\nprintk("mpoa: proc_mpc_write: could not parse '%s'\n", page);\r\nfree_page((unsigned long)page);\r\nreturn len;\r\n}\r\nstatic int parse_qos(const char *buff)\r\n{\r\nunsigned char ip[4];\r\nint tx_pcr, tx_sdu, rx_pcr, rx_sdu;\r\n__be32 ipaddr;\r\nstruct atm_qos qos;\r\nmemset(&qos, 0, sizeof(struct atm_qos));\r\nif (sscanf(buff, "del %hhu.%hhu.%hhu.%hhu",\r\nip, ip+1, ip+2, ip+3) == 4) {\r\nipaddr = *(__be32 *)ip;\r\nreturn atm_mpoa_delete_qos(atm_mpoa_search_qos(ipaddr));\r\n}\r\nif (sscanf(buff, "add %hhu.%hhu.%hhu.%hhu tx=%d,%d rx=tx",\r\nip, ip+1, ip+2, ip+3, &tx_pcr, &tx_sdu) == 6) {\r\nrx_pcr = tx_pcr;\r\nrx_sdu = tx_sdu;\r\n} else if (sscanf(buff, "add %hhu.%hhu.%hhu.%hhu tx=%d,%d rx=%d,%d",\r\nip, ip+1, ip+2, ip+3, &tx_pcr, &tx_sdu, &rx_pcr, &rx_sdu) != 8)\r\nreturn 0;\r\nipaddr = *(__be32 *)ip;\r\nqos.txtp.traffic_class = ATM_CBR;\r\nqos.txtp.max_pcr = tx_pcr;\r\nqos.txtp.max_sdu = tx_sdu;\r\nqos.rxtp.traffic_class = ATM_CBR;\r\nqos.rxtp.max_pcr = rx_pcr;\r\nqos.rxtp.max_sdu = rx_sdu;\r\nqos.aal = ATM_AAL5;\r\ndprintk("parse_qos(): setting qos paramameters to tx=%d,%d rx=%d,%d\n",\r\nqos.txtp.max_pcr, qos.txtp.max_sdu,\r\nqos.rxtp.max_pcr, qos.rxtp.max_sdu);\r\natm_mpoa_add_qos(ipaddr, &qos);\r\nreturn 1;\r\n}\r\nint mpc_proc_init(void)\r\n{\r\nstruct proc_dir_entry *p;\r\np = proc_create(STAT_FILE_NAME, 0, atm_proc_root, &mpc_file_operations);\r\nif (!p) {\r\npr_err("Unable to initialize /proc/atm/%s\n", STAT_FILE_NAME);\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}\r\nvoid mpc_proc_clean(void)\r\n{\r\nremove_proc_entry(STAT_FILE_NAME, atm_proc_root);\r\n}
