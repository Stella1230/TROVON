static int ad5449_write(struct iio_dev *indio_dev, unsigned int addr,\r\nunsigned int val)\r\n{\r\nstruct ad5449 *st = iio_priv(indio_dev);\r\nint ret;\r\nmutex_lock(&indio_dev->mlock);\r\nst->data[0] = cpu_to_be16((addr << 12) | val);\r\nret = spi_write(st->spi, st->data, 2);\r\nmutex_unlock(&indio_dev->mlock);\r\nreturn ret;\r\n}\r\nstatic int ad5449_read(struct iio_dev *indio_dev, unsigned int addr,\r\nunsigned int *val)\r\n{\r\nstruct ad5449 *st = iio_priv(indio_dev);\r\nint ret;\r\nstruct spi_message msg;\r\nstruct spi_transfer t[] = {\r\n{\r\n.tx_buf = &st->data[0],\r\n.len = 2,\r\n.cs_change = 1,\r\n}, {\r\n.tx_buf = &st->data[1],\r\n.rx_buf = &st->data[1],\r\n.len = 2,\r\n},\r\n};\r\nspi_message_init(&msg);\r\nspi_message_add_tail(&t[0], &msg);\r\nspi_message_add_tail(&t[1], &msg);\r\nmutex_lock(&indio_dev->mlock);\r\nst->data[0] = cpu_to_be16(addr << 12);\r\nst->data[1] = cpu_to_be16(AD5449_CMD_NOOP);\r\nret = spi_sync(st->spi, &msg);\r\nif (ret < 0)\r\ngoto out_unlock;\r\n*val = be16_to_cpu(st->data[1]);\r\nout_unlock:\r\nmutex_unlock(&indio_dev->mlock);\r\nreturn ret;\r\n}\r\nstatic int ad5449_read_raw(struct iio_dev *indio_dev,\r\nstruct iio_chan_spec const *chan, int *val, int *val2, long info)\r\n{\r\nstruct ad5449 *st = iio_priv(indio_dev);\r\nstruct regulator_bulk_data *reg;\r\nint scale_uv;\r\nint ret;\r\nswitch (info) {\r\ncase IIO_CHAN_INFO_RAW:\r\nif (st->has_sdo) {\r\nret = ad5449_read(indio_dev,\r\nAD5449_CMD_READ(chan->address), val);\r\nif (ret)\r\nreturn ret;\r\n*val &= 0xfff;\r\n} else {\r\n*val = st->dac_cache[chan->address];\r\n}\r\nreturn IIO_VAL_INT;\r\ncase IIO_CHAN_INFO_SCALE:\r\nreg = &st->vref_reg[chan->channel];\r\nscale_uv = regulator_get_voltage(reg->consumer);\r\nif (scale_uv < 0)\r\nreturn scale_uv;\r\n*val = scale_uv / 1000;\r\n*val2 = chan->scan_type.realbits;\r\nreturn IIO_VAL_FRACTIONAL_LOG2;\r\ndefault:\r\nbreak;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int ad5449_write_raw(struct iio_dev *indio_dev,\r\nstruct iio_chan_spec const *chan, int val, int val2, long info)\r\n{\r\nstruct ad5449 *st = iio_priv(indio_dev);\r\nint ret;\r\nswitch (info) {\r\ncase IIO_CHAN_INFO_RAW:\r\nif (val < 0 || val >= (1 << chan->scan_type.realbits))\r\nreturn -EINVAL;\r\nret = ad5449_write(indio_dev,\r\nAD5449_CMD_LOAD_AND_UPDATE(chan->address),\r\nval << chan->scan_type.shift);\r\nif (ret == 0)\r\nst->dac_cache[chan->address] = val;\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\n}\r\nreturn ret;\r\n}\r\nstatic const char *ad5449_vref_name(struct ad5449 *st, int n)\r\n{\r\nif (st->chip_info->num_channels == 1)\r\nreturn "VREF";\r\nif (n == 0)\r\nreturn "VREFA";\r\nelse\r\nreturn "VREFB";\r\n}\r\nstatic int ad5449_spi_probe(struct spi_device *spi)\r\n{\r\nstruct ad5449_platform_data *pdata = spi->dev.platform_data;\r\nconst struct spi_device_id *id = spi_get_device_id(spi);\r\nstruct iio_dev *indio_dev;\r\nstruct ad5449 *st;\r\nunsigned int i;\r\nint ret;\r\nindio_dev = iio_device_alloc(sizeof(*st));\r\nif (indio_dev == NULL)\r\nreturn -ENOMEM;\r\nst = iio_priv(indio_dev);\r\nspi_set_drvdata(spi, indio_dev);\r\nst->chip_info = &ad5449_chip_info[id->driver_data];\r\nst->spi = spi;\r\nfor (i = 0; i < st->chip_info->num_channels; ++i)\r\nst->vref_reg[i].supply = ad5449_vref_name(st, i);\r\nret = regulator_bulk_get(&spi->dev, st->chip_info->num_channels,\r\nst->vref_reg);\r\nif (ret)\r\ngoto error_free;\r\nret = regulator_bulk_enable(st->chip_info->num_channels, st->vref_reg);\r\nif (ret)\r\ngoto error_free_reg;\r\nindio_dev->dev.parent = &spi->dev;\r\nindio_dev->name = id->name;\r\nindio_dev->info = &ad5449_info;\r\nindio_dev->modes = INDIO_DIRECT_MODE;\r\nindio_dev->channels = st->chip_info->channels;\r\nindio_dev->num_channels = st->chip_info->num_channels;\r\nif (st->chip_info->has_ctrl) {\r\nunsigned int ctrl = 0x00;\r\nif (pdata) {\r\nif (pdata->hardware_clear_to_midscale)\r\nctrl |= AD5449_CTRL_HCLR_TO_MIDSCALE;\r\nctrl |= pdata->sdo_mode << AD5449_CTRL_SDO_OFFSET;\r\nst->has_sdo = pdata->sdo_mode != AD5449_SDO_DISABLED;\r\n} else {\r\nst->has_sdo = true;\r\n}\r\nad5449_write(indio_dev, AD5449_CMD_CTRL, ctrl);\r\n}\r\nret = iio_device_register(indio_dev);\r\nif (ret)\r\ngoto error_disable_reg;\r\nreturn 0;\r\nerror_disable_reg:\r\nregulator_bulk_disable(st->chip_info->num_channels, st->vref_reg);\r\nerror_free_reg:\r\nregulator_bulk_free(st->chip_info->num_channels, st->vref_reg);\r\nerror_free:\r\niio_device_free(indio_dev);\r\nreturn ret;\r\n}\r\nstatic int ad5449_spi_remove(struct spi_device *spi)\r\n{\r\nstruct iio_dev *indio_dev = spi_get_drvdata(spi);\r\nstruct ad5449 *st = iio_priv(indio_dev);\r\niio_device_unregister(indio_dev);\r\nregulator_bulk_disable(st->chip_info->num_channels, st->vref_reg);\r\nregulator_bulk_free(st->chip_info->num_channels, st->vref_reg);\r\niio_device_free(indio_dev);\r\nreturn 0;\r\n}
