static int ext4_sync_parent(struct inode *inode)\r\n{\r\nstruct dentry *dentry = NULL;\r\nstruct inode *next;\r\nint ret = 0;\r\nif (!ext4_test_inode_state(inode, EXT4_STATE_NEWENTRY))\r\nreturn 0;\r\ninode = igrab(inode);\r\nwhile (ext4_test_inode_state(inode, EXT4_STATE_NEWENTRY)) {\r\next4_clear_inode_state(inode, EXT4_STATE_NEWENTRY);\r\ndentry = d_find_any_alias(inode);\r\nif (!dentry)\r\nbreak;\r\nnext = igrab(dentry->d_parent->d_inode);\r\ndput(dentry);\r\nif (!next)\r\nbreak;\r\niput(inode);\r\ninode = next;\r\nret = sync_mapping_buffers(inode->i_mapping);\r\nif (ret)\r\nbreak;\r\nret = sync_inode_metadata(inode, 1);\r\nif (ret)\r\nbreak;\r\n}\r\niput(inode);\r\nreturn ret;\r\n}\r\nstatic int __sync_inode(struct inode *inode, int datasync)\r\n{\r\nint err;\r\nint ret;\r\nret = sync_mapping_buffers(inode->i_mapping);\r\nif (!(inode->i_state & I_DIRTY))\r\nreturn ret;\r\nif (datasync && !(inode->i_state & I_DIRTY_DATASYNC))\r\nreturn ret;\r\nerr = sync_inode_metadata(inode, 1);\r\nif (ret == 0)\r\nret = err;\r\nreturn ret;\r\n}\r\nint ext4_sync_file(struct file *file, loff_t start, loff_t end, int datasync)\r\n{\r\nstruct inode *inode = file->f_mapping->host;\r\nstruct ext4_inode_info *ei = EXT4_I(inode);\r\njournal_t *journal = EXT4_SB(inode->i_sb)->s_journal;\r\nint ret, err;\r\ntid_t commit_tid;\r\nbool needs_barrier = false;\r\nJ_ASSERT(ext4_journal_current_handle() == NULL);\r\ntrace_ext4_sync_file_enter(file, datasync);\r\nret = filemap_write_and_wait_range(inode->i_mapping, start, end);\r\nif (ret)\r\nreturn ret;\r\nmutex_lock(&inode->i_mutex);\r\nif (inode->i_sb->s_flags & MS_RDONLY)\r\ngoto out;\r\nret = ext4_flush_unwritten_io(inode);\r\nif (ret < 0)\r\ngoto out;\r\nif (!journal) {\r\nret = __sync_inode(inode, datasync);\r\nif (!ret && !hlist_empty(&inode->i_dentry))\r\nret = ext4_sync_parent(inode);\r\ngoto out;\r\n}\r\nif (ext4_should_journal_data(inode)) {\r\nret = ext4_force_commit(inode->i_sb);\r\ngoto out;\r\n}\r\ncommit_tid = datasync ? ei->i_datasync_tid : ei->i_sync_tid;\r\nif (journal->j_flags & JBD2_BARRIER &&\r\n!jbd2_trans_will_send_data_barrier(journal, commit_tid))\r\nneeds_barrier = true;\r\njbd2_log_start_commit(journal, commit_tid);\r\nret = jbd2_log_wait_commit(journal, commit_tid);\r\nif (needs_barrier) {\r\nerr = blkdev_issue_flush(inode->i_sb->s_bdev, GFP_KERNEL, NULL);\r\nif (!ret)\r\nret = err;\r\n}\r\nout:\r\nmutex_unlock(&inode->i_mutex);\r\ntrace_ext4_sync_file_exit(inode, ret);\r\nreturn ret;\r\n}
