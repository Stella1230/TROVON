static int clear_epp_timeout(struct parport *pb)\r\n{\r\nunsigned char r;\r\nif (!(parport_gsc_read_status(pb) & 0x01))\r\nreturn 1;\r\nparport_gsc_read_status(pb);\r\nr = parport_gsc_read_status(pb);\r\nparport_writeb (r | 0x01, STATUS (pb));\r\nparport_writeb (r & 0xfe, STATUS (pb));\r\nr = parport_gsc_read_status(pb);\r\nreturn !(r & 0x01);\r\n}\r\nvoid parport_gsc_init_state(struct pardevice *dev, struct parport_state *s)\r\n{\r\ns->u.pc.ctr = 0xc | (dev->irq_func ? 0x10 : 0x0);\r\n}\r\nvoid parport_gsc_save_state(struct parport *p, struct parport_state *s)\r\n{\r\ns->u.pc.ctr = parport_readb (CONTROL (p));\r\n}\r\nvoid parport_gsc_restore_state(struct parport *p, struct parport_state *s)\r\n{\r\nparport_writeb (s->u.pc.ctr, CONTROL (p));\r\n}\r\nstatic int parport_SPP_supported(struct parport *pb)\r\n{\r\nunsigned char r, w;\r\nclear_epp_timeout(pb);\r\nw = 0xc;\r\nparport_writeb (w, CONTROL (pb));\r\nr = parport_readb (CONTROL (pb));\r\nif ((r & 0xf) == w) {\r\nw = 0xe;\r\nparport_writeb (w, CONTROL (pb));\r\nr = parport_readb (CONTROL (pb));\r\nparport_writeb (0xc, CONTROL (pb));\r\nif ((r & 0xf) == w)\r\nreturn PARPORT_MODE_PCSPP;\r\n}\r\nw = 0xaa;\r\nparport_gsc_write_data (pb, w);\r\nr = parport_gsc_read_data (pb);\r\nif (r == w) {\r\nw = 0x55;\r\nparport_gsc_write_data (pb, w);\r\nr = parport_gsc_read_data (pb);\r\nif (r == w)\r\nreturn PARPORT_MODE_PCSPP;\r\n}\r\nreturn 0;\r\n}\r\nstatic int parport_PS2_supported(struct parport *pb)\r\n{\r\nint ok = 0;\r\nclear_epp_timeout(pb);\r\nparport_gsc_data_reverse (pb);\r\nparport_gsc_write_data(pb, 0x55);\r\nif (parport_gsc_read_data(pb) != 0x55) ok++;\r\nparport_gsc_write_data(pb, 0xaa);\r\nif (parport_gsc_read_data(pb) != 0xaa) ok++;\r\nparport_gsc_data_forward (pb);\r\nif (ok) {\r\npb->modes |= PARPORT_MODE_TRISTATE;\r\n} else {\r\nstruct parport_gsc_private *priv = pb->private_data;\r\npriv->ctr_writable &= ~0x20;\r\n}\r\nreturn ok;\r\n}\r\nstruct parport *parport_gsc_probe_port(unsigned long base,\r\nunsigned long base_hi, int irq,\r\nint dma, struct pci_dev *dev)\r\n{\r\nstruct parport_gsc_private *priv;\r\nstruct parport_operations *ops;\r\nstruct parport tmp;\r\nstruct parport *p = &tmp;\r\npriv = kzalloc (sizeof (struct parport_gsc_private), GFP_KERNEL);\r\nif (!priv) {\r\nprintk (KERN_DEBUG "parport (0x%lx): no memory!\n", base);\r\nreturn NULL;\r\n}\r\nops = kmalloc (sizeof (struct parport_operations), GFP_KERNEL);\r\nif (!ops) {\r\nprintk (KERN_DEBUG "parport (0x%lx): no memory for ops!\n",\r\nbase);\r\nkfree (priv);\r\nreturn NULL;\r\n}\r\nmemcpy (ops, &parport_gsc_ops, sizeof (struct parport_operations));\r\npriv->ctr = 0xc;\r\npriv->ctr_writable = 0xff;\r\npriv->dma_buf = 0;\r\npriv->dma_handle = 0;\r\npriv->dev = dev;\r\np->base = base;\r\np->base_hi = base_hi;\r\np->irq = irq;\r\np->dma = dma;\r\np->modes = PARPORT_MODE_PCSPP | PARPORT_MODE_SAFEININT;\r\np->ops = ops;\r\np->private_data = priv;\r\np->physport = p;\r\nif (!parport_SPP_supported (p)) {\r\nkfree (priv);\r\nkfree(ops);\r\nreturn NULL;\r\n}\r\nparport_PS2_supported (p);\r\nif (!(p = parport_register_port(base, PARPORT_IRQ_NONE,\r\nPARPORT_DMA_NONE, ops))) {\r\nkfree (priv);\r\nkfree (ops);\r\nreturn NULL;\r\n}\r\np->base_hi = base_hi;\r\np->modes = tmp.modes;\r\np->size = (p->modes & PARPORT_MODE_EPP)?8:3;\r\np->private_data = priv;\r\nprintk(KERN_INFO "%s: PC-style at 0x%lx", p->name, p->base);\r\np->irq = irq;\r\nif (p->irq == PARPORT_IRQ_AUTO) {\r\np->irq = PARPORT_IRQ_NONE;\r\n}\r\nif (p->irq != PARPORT_IRQ_NONE) {\r\nprintk(", irq %d", p->irq);\r\nif (p->dma == PARPORT_DMA_AUTO) {\r\np->dma = PARPORT_DMA_NONE;\r\n}\r\n}\r\nif (p->dma == PARPORT_DMA_AUTO)\r\np->dma = PARPORT_DMA_NONE;\r\nprintk(" [");\r\n#define printmode(x) {if(p->modes&PARPORT_MODE_##x){printk("%s%s",f?",":"",#x);f++;}}\r\n{\r\nint f = 0;\r\nprintmode(PCSPP);\r\nprintmode(TRISTATE);\r\nprintmode(COMPAT)\r\nprintmode(EPP);\r\n}\r\n#undef printmode\r\nprintk("]\n");\r\nif (p->irq != PARPORT_IRQ_NONE) {\r\nif (request_irq (p->irq, parport_irq_handler,\r\n0, p->name, p)) {\r\nprintk (KERN_WARNING "%s: irq %d in use, "\r\n"resorting to polled operation\n",\r\np->name, p->irq);\r\np->irq = PARPORT_IRQ_NONE;\r\np->dma = PARPORT_DMA_NONE;\r\n}\r\n}\r\nparport_gsc_write_data(p, 0);\r\nparport_gsc_data_forward (p);\r\nparport_announce_port (p);\r\nreturn p;\r\n}\r\nstatic int parport_init_chip(struct parisc_device *dev)\r\n{\r\nstruct parport *p;\r\nunsigned long port;\r\nif (!dev->irq) {\r\nprintk(KERN_WARNING "IRQ not found for parallel device at 0x%llx\n",\r\n(unsigned long long)dev->hpa.start);\r\nreturn -ENODEV;\r\n}\r\nport = dev->hpa.start + PARPORT_GSC_OFFSET;\r\nif (boot_cpu_data.cpu_type > pcxt && !pdc_add_valid(port+4)) {\r\nprintk("%s: initialize bidirectional-mode.\n", __func__);\r\nparport_writeb ( (0x10 + 0x20), port + 4);\r\n} else {\r\nprintk("%s: enhanced parport-modes not supported.\n", __func__);\r\n}\r\np = parport_gsc_probe_port(port, 0, dev->irq,\r\nPARPORT_DMA_NONE, NULL);\r\nif (p)\r\nparport_count++;\r\ndev_set_drvdata(&dev->dev, p);\r\nreturn 0;\r\n}\r\nstatic int parport_remove_chip(struct parisc_device *dev)\r\n{\r\nstruct parport *p = dev_get_drvdata(&dev->dev);\r\nif (p) {\r\nstruct parport_gsc_private *priv = p->private_data;\r\nstruct parport_operations *ops = p->ops;\r\nparport_remove_port(p);\r\nif (p->dma != PARPORT_DMA_NONE)\r\nfree_dma(p->dma);\r\nif (p->irq != PARPORT_IRQ_NONE)\r\nfree_irq(p->irq, p);\r\nif (priv->dma_buf)\r\npci_free_consistent(priv->dev, PAGE_SIZE,\r\npriv->dma_buf,\r\npriv->dma_handle);\r\nkfree (p->private_data);\r\nparport_put_port(p);\r\nkfree (ops);\r\n}\r\nreturn 0;\r\n}\r\nint parport_gsc_init(void)\r\n{\r\nreturn register_parisc_driver(&parport_driver);\r\n}\r\nstatic void parport_gsc_exit(void)\r\n{\r\nunregister_parisc_driver(&parport_driver);\r\n}
