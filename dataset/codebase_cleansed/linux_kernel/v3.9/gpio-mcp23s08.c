static int mcp23008_read(struct mcp23s08 *mcp, unsigned reg)\r\n{\r\nreturn i2c_smbus_read_byte_data(mcp->data, reg);\r\n}\r\nstatic int mcp23008_write(struct mcp23s08 *mcp, unsigned reg, unsigned val)\r\n{\r\nreturn i2c_smbus_write_byte_data(mcp->data, reg, val);\r\n}\r\nstatic int\r\nmcp23008_read_regs(struct mcp23s08 *mcp, unsigned reg, u16 *vals, unsigned n)\r\n{\r\nwhile (n--) {\r\nint ret = mcp23008_read(mcp, reg++);\r\nif (ret < 0)\r\nreturn ret;\r\n*vals++ = ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int mcp23017_read(struct mcp23s08 *mcp, unsigned reg)\r\n{\r\nreturn i2c_smbus_read_word_data(mcp->data, reg << 1);\r\n}\r\nstatic int mcp23017_write(struct mcp23s08 *mcp, unsigned reg, unsigned val)\r\n{\r\nreturn i2c_smbus_write_word_data(mcp->data, reg << 1, val);\r\n}\r\nstatic int\r\nmcp23017_read_regs(struct mcp23s08 *mcp, unsigned reg, u16 *vals, unsigned n)\r\n{\r\nwhile (n--) {\r\nint ret = mcp23017_read(mcp, reg++);\r\nif (ret < 0)\r\nreturn ret;\r\n*vals++ = ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int mcp23s08_read(struct mcp23s08 *mcp, unsigned reg)\r\n{\r\nu8 tx[2], rx[1];\r\nint status;\r\ntx[0] = mcp->addr | 0x01;\r\ntx[1] = reg;\r\nstatus = spi_write_then_read(mcp->data, tx, sizeof tx, rx, sizeof rx);\r\nreturn (status < 0) ? status : rx[0];\r\n}\r\nstatic int mcp23s08_write(struct mcp23s08 *mcp, unsigned reg, unsigned val)\r\n{\r\nu8 tx[3];\r\ntx[0] = mcp->addr;\r\ntx[1] = reg;\r\ntx[2] = val;\r\nreturn spi_write_then_read(mcp->data, tx, sizeof tx, NULL, 0);\r\n}\r\nstatic int\r\nmcp23s08_read_regs(struct mcp23s08 *mcp, unsigned reg, u16 *vals, unsigned n)\r\n{\r\nu8 tx[2], *tmp;\r\nint status;\r\nif ((n + reg) > sizeof mcp->cache)\r\nreturn -EINVAL;\r\ntx[0] = mcp->addr | 0x01;\r\ntx[1] = reg;\r\ntmp = (u8 *)vals;\r\nstatus = spi_write_then_read(mcp->data, tx, sizeof tx, tmp, n);\r\nif (status >= 0) {\r\nwhile (n--)\r\nvals[n] = tmp[n];\r\n}\r\nreturn status;\r\n}\r\nstatic int mcp23s17_read(struct mcp23s08 *mcp, unsigned reg)\r\n{\r\nu8 tx[2], rx[2];\r\nint status;\r\ntx[0] = mcp->addr | 0x01;\r\ntx[1] = reg << 1;\r\nstatus = spi_write_then_read(mcp->data, tx, sizeof tx, rx, sizeof rx);\r\nreturn (status < 0) ? status : (rx[0] | (rx[1] << 8));\r\n}\r\nstatic int mcp23s17_write(struct mcp23s08 *mcp, unsigned reg, unsigned val)\r\n{\r\nu8 tx[4];\r\ntx[0] = mcp->addr;\r\ntx[1] = reg << 1;\r\ntx[2] = val;\r\ntx[3] = val >> 8;\r\nreturn spi_write_then_read(mcp->data, tx, sizeof tx, NULL, 0);\r\n}\r\nstatic int\r\nmcp23s17_read_regs(struct mcp23s08 *mcp, unsigned reg, u16 *vals, unsigned n)\r\n{\r\nu8 tx[2];\r\nint status;\r\nif ((n + reg) > sizeof mcp->cache)\r\nreturn -EINVAL;\r\ntx[0] = mcp->addr | 0x01;\r\ntx[1] = reg << 1;\r\nstatus = spi_write_then_read(mcp->data, tx, sizeof tx,\r\n(u8 *)vals, n * 2);\r\nif (status >= 0) {\r\nwhile (n--)\r\nvals[n] = __le16_to_cpu((__le16)vals[n]);\r\n}\r\nreturn status;\r\n}\r\nstatic int mcp23s08_direction_input(struct gpio_chip *chip, unsigned offset)\r\n{\r\nstruct mcp23s08 *mcp = container_of(chip, struct mcp23s08, chip);\r\nint status;\r\nmutex_lock(&mcp->lock);\r\nmcp->cache[MCP_IODIR] |= (1 << offset);\r\nstatus = mcp->ops->write(mcp, MCP_IODIR, mcp->cache[MCP_IODIR]);\r\nmutex_unlock(&mcp->lock);\r\nreturn status;\r\n}\r\nstatic int mcp23s08_get(struct gpio_chip *chip, unsigned offset)\r\n{\r\nstruct mcp23s08 *mcp = container_of(chip, struct mcp23s08, chip);\r\nint status;\r\nmutex_lock(&mcp->lock);\r\nstatus = mcp->ops->read(mcp, MCP_GPIO);\r\nif (status < 0)\r\nstatus = 0;\r\nelse {\r\nmcp->cache[MCP_GPIO] = status;\r\nstatus = !!(status & (1 << offset));\r\n}\r\nmutex_unlock(&mcp->lock);\r\nreturn status;\r\n}\r\nstatic int __mcp23s08_set(struct mcp23s08 *mcp, unsigned mask, int value)\r\n{\r\nunsigned olat = mcp->cache[MCP_OLAT];\r\nif (value)\r\nolat |= mask;\r\nelse\r\nolat &= ~mask;\r\nmcp->cache[MCP_OLAT] = olat;\r\nreturn mcp->ops->write(mcp, MCP_OLAT, olat);\r\n}\r\nstatic void mcp23s08_set(struct gpio_chip *chip, unsigned offset, int value)\r\n{\r\nstruct mcp23s08 *mcp = container_of(chip, struct mcp23s08, chip);\r\nunsigned mask = 1 << offset;\r\nmutex_lock(&mcp->lock);\r\n__mcp23s08_set(mcp, mask, value);\r\nmutex_unlock(&mcp->lock);\r\n}\r\nstatic int\r\nmcp23s08_direction_output(struct gpio_chip *chip, unsigned offset, int value)\r\n{\r\nstruct mcp23s08 *mcp = container_of(chip, struct mcp23s08, chip);\r\nunsigned mask = 1 << offset;\r\nint status;\r\nmutex_lock(&mcp->lock);\r\nstatus = __mcp23s08_set(mcp, mask, value);\r\nif (status == 0) {\r\nmcp->cache[MCP_IODIR] &= ~mask;\r\nstatus = mcp->ops->write(mcp, MCP_IODIR, mcp->cache[MCP_IODIR]);\r\n}\r\nmutex_unlock(&mcp->lock);\r\nreturn status;\r\n}\r\nstatic void mcp23s08_dbg_show(struct seq_file *s, struct gpio_chip *chip)\r\n{\r\nstruct mcp23s08 *mcp;\r\nchar bank;\r\nint t;\r\nunsigned mask;\r\nmcp = container_of(chip, struct mcp23s08, chip);\r\nbank = '0' + ((mcp->addr >> 1) & 0x7);\r\nmutex_lock(&mcp->lock);\r\nt = mcp->ops->read_regs(mcp, 0, mcp->cache, ARRAY_SIZE(mcp->cache));\r\nif (t < 0) {\r\nseq_printf(s, " I/O ERROR %d\n", t);\r\ngoto done;\r\n}\r\nfor (t = 0, mask = 1; t < chip->ngpio; t++, mask <<= 1) {\r\nconst char *label;\r\nlabel = gpiochip_is_requested(chip, t);\r\nif (!label)\r\ncontinue;\r\nseq_printf(s, " gpio-%-3d P%c.%d (%-12s) %s %s %s",\r\nchip->base + t, bank, t, label,\r\n(mcp->cache[MCP_IODIR] & mask) ? "in " : "out",\r\n(mcp->cache[MCP_GPIO] & mask) ? "hi" : "lo",\r\n(mcp->cache[MCP_GPPU] & mask) ? "up" : " ");\r\nseq_printf(s, "\n");\r\n}\r\ndone:\r\nmutex_unlock(&mcp->lock);\r\n}\r\nstatic int mcp23s08_probe_one(struct mcp23s08 *mcp, struct device *dev,\r\nvoid *data, unsigned addr,\r\nunsigned type, unsigned base, unsigned pullups)\r\n{\r\nint status;\r\nmutex_init(&mcp->lock);\r\nmcp->data = data;\r\nmcp->addr = addr;\r\nmcp->chip.direction_input = mcp23s08_direction_input;\r\nmcp->chip.get = mcp23s08_get;\r\nmcp->chip.direction_output = mcp23s08_direction_output;\r\nmcp->chip.set = mcp23s08_set;\r\nmcp->chip.dbg_show = mcp23s08_dbg_show;\r\nswitch (type) {\r\n#ifdef CONFIG_SPI_MASTER\r\ncase MCP_TYPE_S08:\r\nmcp->ops = &mcp23s08_ops;\r\nmcp->chip.ngpio = 8;\r\nmcp->chip.label = "mcp23s08";\r\nbreak;\r\ncase MCP_TYPE_S17:\r\nmcp->ops = &mcp23s17_ops;\r\nmcp->chip.ngpio = 16;\r\nmcp->chip.label = "mcp23s17";\r\nbreak;\r\n#endif\r\n#if IS_ENABLED(CONFIG_I2C)\r\ncase MCP_TYPE_008:\r\nmcp->ops = &mcp23008_ops;\r\nmcp->chip.ngpio = 8;\r\nmcp->chip.label = "mcp23008";\r\nbreak;\r\ncase MCP_TYPE_017:\r\nmcp->ops = &mcp23017_ops;\r\nmcp->chip.ngpio = 16;\r\nmcp->chip.label = "mcp23017";\r\nbreak;\r\n#endif\r\ndefault:\r\ndev_err(dev, "invalid device type (%d)\n", type);\r\nreturn -EINVAL;\r\n}\r\nmcp->chip.base = base;\r\nmcp->chip.can_sleep = 1;\r\nmcp->chip.dev = dev;\r\nmcp->chip.owner = THIS_MODULE;\r\nstatus = mcp->ops->read(mcp, MCP_IOCON);\r\nif (status < 0)\r\ngoto fail;\r\nif ((status & IOCON_SEQOP) || !(status & IOCON_HAEN)) {\r\nstatus &= ~(IOCON_SEQOP | (IOCON_SEQOP << 8));\r\nstatus |= IOCON_HAEN | (IOCON_HAEN << 8);\r\nstatus = mcp->ops->write(mcp, MCP_IOCON, status);\r\nif (status < 0)\r\ngoto fail;\r\n}\r\nstatus = mcp->ops->write(mcp, MCP_GPPU, pullups);\r\nif (status < 0)\r\ngoto fail;\r\nstatus = mcp->ops->read_regs(mcp, 0, mcp->cache, ARRAY_SIZE(mcp->cache));\r\nif (status < 0)\r\ngoto fail;\r\nif (mcp->cache[MCP_IPOL] != 0) {\r\nmcp->cache[MCP_IPOL] = 0;\r\nstatus = mcp->ops->write(mcp, MCP_IPOL, 0);\r\nif (status < 0)\r\ngoto fail;\r\n}\r\nif (mcp->cache[MCP_GPINTEN] != 0) {\r\nmcp->cache[MCP_GPINTEN] = 0;\r\nstatus = mcp->ops->write(mcp, MCP_GPINTEN, 0);\r\nif (status < 0)\r\ngoto fail;\r\n}\r\nstatus = gpiochip_add(&mcp->chip);\r\nfail:\r\nif (status < 0)\r\ndev_dbg(dev, "can't setup chip %d, --> %d\n",\r\naddr, status);\r\nreturn status;\r\n}\r\nstatic int mcp230xx_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct mcp23s08_platform_data *pdata;\r\nstruct mcp23s08 *mcp;\r\nint status;\r\npdata = client->dev.platform_data;\r\nif (!pdata || !gpio_is_valid(pdata->base)) {\r\ndev_dbg(&client->dev, "invalid or missing platform data\n");\r\nreturn -EINVAL;\r\n}\r\nmcp = kzalloc(sizeof *mcp, GFP_KERNEL);\r\nif (!mcp)\r\nreturn -ENOMEM;\r\nstatus = mcp23s08_probe_one(mcp, &client->dev, client, client->addr,\r\nid->driver_data, pdata->base,\r\npdata->chip[0].pullups);\r\nif (status)\r\ngoto fail;\r\ni2c_set_clientdata(client, mcp);\r\nreturn 0;\r\nfail:\r\nkfree(mcp);\r\nreturn status;\r\n}\r\nstatic int mcp230xx_remove(struct i2c_client *client)\r\n{\r\nstruct mcp23s08 *mcp = i2c_get_clientdata(client);\r\nint status;\r\nstatus = gpiochip_remove(&mcp->chip);\r\nif (status == 0)\r\nkfree(mcp);\r\nreturn status;\r\n}\r\nstatic int __init mcp23s08_i2c_init(void)\r\n{\r\nreturn i2c_add_driver(&mcp230xx_driver);\r\n}\r\nstatic void mcp23s08_i2c_exit(void)\r\n{\r\ni2c_del_driver(&mcp230xx_driver);\r\n}\r\nstatic int __init mcp23s08_i2c_init(void) { return 0; }\r\nstatic void mcp23s08_i2c_exit(void) { }\r\nstatic int mcp23s08_probe(struct spi_device *spi)\r\n{\r\nstruct mcp23s08_platform_data *pdata;\r\nunsigned addr;\r\nunsigned chips = 0;\r\nstruct mcp23s08_driver_data *data;\r\nint status, type;\r\nunsigned base;\r\ntype = spi_get_device_id(spi)->driver_data;\r\npdata = spi->dev.platform_data;\r\nif (!pdata || !gpio_is_valid(pdata->base)) {\r\ndev_dbg(&spi->dev, "invalid or missing platform data\n");\r\nreturn -EINVAL;\r\n}\r\nfor (addr = 0; addr < ARRAY_SIZE(pdata->chip); addr++) {\r\nif (!pdata->chip[addr].is_present)\r\ncontinue;\r\nchips++;\r\nif ((type == MCP_TYPE_S08) && (addr > 3)) {\r\ndev_err(&spi->dev,\r\n"mcp23s08 only supports address 0..3\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\nif (!chips)\r\nreturn -ENODEV;\r\ndata = kzalloc(sizeof *data + chips * sizeof(struct mcp23s08),\r\nGFP_KERNEL);\r\nif (!data)\r\nreturn -ENOMEM;\r\nspi_set_drvdata(spi, data);\r\nbase = pdata->base;\r\nfor (addr = 0; addr < ARRAY_SIZE(pdata->chip); addr++) {\r\nif (!pdata->chip[addr].is_present)\r\ncontinue;\r\nchips--;\r\ndata->mcp[addr] = &data->chip[chips];\r\nstatus = mcp23s08_probe_one(data->mcp[addr], &spi->dev, spi,\r\n0x40 | (addr << 1), type, base,\r\npdata->chip[addr].pullups);\r\nif (status < 0)\r\ngoto fail;\r\nbase += (type == MCP_TYPE_S17) ? 16 : 8;\r\n}\r\ndata->ngpio = base - pdata->base;\r\nreturn 0;\r\nfail:\r\nfor (addr = 0; addr < ARRAY_SIZE(data->mcp); addr++) {\r\nint tmp;\r\nif (!data->mcp[addr])\r\ncontinue;\r\ntmp = gpiochip_remove(&data->mcp[addr]->chip);\r\nif (tmp < 0)\r\ndev_err(&spi->dev, "%s --> %d\n", "remove", tmp);\r\n}\r\nkfree(data);\r\nreturn status;\r\n}\r\nstatic int mcp23s08_remove(struct spi_device *spi)\r\n{\r\nstruct mcp23s08_driver_data *data = spi_get_drvdata(spi);\r\nunsigned addr;\r\nint status = 0;\r\nfor (addr = 0; addr < ARRAY_SIZE(data->mcp); addr++) {\r\nint tmp;\r\nif (!data->mcp[addr])\r\ncontinue;\r\ntmp = gpiochip_remove(&data->mcp[addr]->chip);\r\nif (tmp < 0) {\r\ndev_err(&spi->dev, "%s --> %d\n", "remove", tmp);\r\nstatus = tmp;\r\n}\r\n}\r\nif (status == 0)\r\nkfree(data);\r\nreturn status;\r\n}\r\nstatic int __init mcp23s08_spi_init(void)\r\n{\r\nreturn spi_register_driver(&mcp23s08_driver);\r\n}\r\nstatic void mcp23s08_spi_exit(void)\r\n{\r\nspi_unregister_driver(&mcp23s08_driver);\r\n}\r\nstatic int __init mcp23s08_spi_init(void) { return 0; }\r\nstatic void mcp23s08_spi_exit(void) { }\r\nstatic int __init mcp23s08_init(void)\r\n{\r\nint ret;\r\nret = mcp23s08_spi_init();\r\nif (ret)\r\ngoto spi_fail;\r\nret = mcp23s08_i2c_init();\r\nif (ret)\r\ngoto i2c_fail;\r\nreturn 0;\r\ni2c_fail:\r\nmcp23s08_spi_exit();\r\nspi_fail:\r\nreturn ret;\r\n}\r\nstatic void __exit mcp23s08_exit(void)\r\n{\r\nmcp23s08_spi_exit();\r\nmcp23s08_i2c_exit();\r\n}
