static struct btrfs_dir_item *insert_with_overflow(struct btrfs_trans_handle\r\n*trans,\r\nstruct btrfs_root *root,\r\nstruct btrfs_path *path,\r\nstruct btrfs_key *cpu_key,\r\nu32 data_size,\r\nconst char *name,\r\nint name_len)\r\n{\r\nint ret;\r\nchar *ptr;\r\nstruct btrfs_item *item;\r\nstruct extent_buffer *leaf;\r\nret = btrfs_insert_empty_item(trans, root, path, cpu_key, data_size);\r\nif (ret == -EEXIST) {\r\nstruct btrfs_dir_item *di;\r\ndi = btrfs_match_dir_item_name(root, path, name, name_len);\r\nif (di)\r\nreturn ERR_PTR(-EEXIST);\r\nbtrfs_extend_item(trans, root, path, data_size);\r\n} else if (ret < 0)\r\nreturn ERR_PTR(ret);\r\nWARN_ON(ret > 0);\r\nleaf = path->nodes[0];\r\nitem = btrfs_item_nr(leaf, path->slots[0]);\r\nptr = btrfs_item_ptr(leaf, path->slots[0], char);\r\nBUG_ON(data_size > btrfs_item_size(leaf, item));\r\nptr += btrfs_item_size(leaf, item) - data_size;\r\nreturn (struct btrfs_dir_item *)ptr;\r\n}\r\nint btrfs_insert_xattr_item(struct btrfs_trans_handle *trans,\r\nstruct btrfs_root *root,\r\nstruct btrfs_path *path, u64 objectid,\r\nconst char *name, u16 name_len,\r\nconst void *data, u16 data_len)\r\n{\r\nint ret = 0;\r\nstruct btrfs_dir_item *dir_item;\r\nunsigned long name_ptr, data_ptr;\r\nstruct btrfs_key key, location;\r\nstruct btrfs_disk_key disk_key;\r\nstruct extent_buffer *leaf;\r\nu32 data_size;\r\nBUG_ON(name_len + data_len > BTRFS_MAX_XATTR_SIZE(root));\r\nkey.objectid = objectid;\r\nbtrfs_set_key_type(&key, BTRFS_XATTR_ITEM_KEY);\r\nkey.offset = btrfs_name_hash(name, name_len);\r\ndata_size = sizeof(*dir_item) + name_len + data_len;\r\ndir_item = insert_with_overflow(trans, root, path, &key, data_size,\r\nname, name_len);\r\nif (IS_ERR(dir_item))\r\nreturn PTR_ERR(dir_item);\r\nmemset(&location, 0, sizeof(location));\r\nleaf = path->nodes[0];\r\nbtrfs_cpu_key_to_disk(&disk_key, &location);\r\nbtrfs_set_dir_item_key(leaf, dir_item, &disk_key);\r\nbtrfs_set_dir_type(leaf, dir_item, BTRFS_FT_XATTR);\r\nbtrfs_set_dir_name_len(leaf, dir_item, name_len);\r\nbtrfs_set_dir_transid(leaf, dir_item, trans->transid);\r\nbtrfs_set_dir_data_len(leaf, dir_item, data_len);\r\nname_ptr = (unsigned long)(dir_item + 1);\r\ndata_ptr = (unsigned long)((char *)name_ptr + name_len);\r\nwrite_extent_buffer(leaf, name, name_ptr, name_len);\r\nwrite_extent_buffer(leaf, data, data_ptr, data_len);\r\nbtrfs_mark_buffer_dirty(path->nodes[0]);\r\nreturn ret;\r\n}\r\nint btrfs_insert_dir_item(struct btrfs_trans_handle *trans, struct btrfs_root\r\n*root, const char *name, int name_len,\r\nstruct inode *dir, struct btrfs_key *location,\r\nu8 type, u64 index)\r\n{\r\nint ret = 0;\r\nint ret2 = 0;\r\nstruct btrfs_path *path;\r\nstruct btrfs_dir_item *dir_item;\r\nstruct extent_buffer *leaf;\r\nunsigned long name_ptr;\r\nstruct btrfs_key key;\r\nstruct btrfs_disk_key disk_key;\r\nu32 data_size;\r\nkey.objectid = btrfs_ino(dir);\r\nbtrfs_set_key_type(&key, BTRFS_DIR_ITEM_KEY);\r\nkey.offset = btrfs_name_hash(name, name_len);\r\npath = btrfs_alloc_path();\r\nif (!path)\r\nreturn -ENOMEM;\r\npath->leave_spinning = 1;\r\nbtrfs_cpu_key_to_disk(&disk_key, location);\r\ndata_size = sizeof(*dir_item) + name_len;\r\ndir_item = insert_with_overflow(trans, root, path, &key, data_size,\r\nname, name_len);\r\nif (IS_ERR(dir_item)) {\r\nret = PTR_ERR(dir_item);\r\nif (ret == -EEXIST)\r\ngoto second_insert;\r\ngoto out_free;\r\n}\r\nleaf = path->nodes[0];\r\nbtrfs_set_dir_item_key(leaf, dir_item, &disk_key);\r\nbtrfs_set_dir_type(leaf, dir_item, type);\r\nbtrfs_set_dir_data_len(leaf, dir_item, 0);\r\nbtrfs_set_dir_name_len(leaf, dir_item, name_len);\r\nbtrfs_set_dir_transid(leaf, dir_item, trans->transid);\r\nname_ptr = (unsigned long)(dir_item + 1);\r\nwrite_extent_buffer(leaf, name, name_ptr, name_len);\r\nbtrfs_mark_buffer_dirty(leaf);\r\nsecond_insert:\r\nif (root == root->fs_info->tree_root) {\r\nret = 0;\r\ngoto out_free;\r\n}\r\nbtrfs_release_path(path);\r\nret2 = btrfs_insert_delayed_dir_index(trans, root, name, name_len, dir,\r\n&disk_key, type, index);\r\nout_free:\r\nbtrfs_free_path(path);\r\nif (ret)\r\nreturn ret;\r\nif (ret2)\r\nreturn ret2;\r\nreturn 0;\r\n}\r\nstruct btrfs_dir_item *btrfs_lookup_dir_item(struct btrfs_trans_handle *trans,\r\nstruct btrfs_root *root,\r\nstruct btrfs_path *path, u64 dir,\r\nconst char *name, int name_len,\r\nint mod)\r\n{\r\nint ret;\r\nstruct btrfs_key key;\r\nint ins_len = mod < 0 ? -1 : 0;\r\nint cow = mod != 0;\r\nkey.objectid = dir;\r\nbtrfs_set_key_type(&key, BTRFS_DIR_ITEM_KEY);\r\nkey.offset = btrfs_name_hash(name, name_len);\r\nret = btrfs_search_slot(trans, root, &key, path, ins_len, cow);\r\nif (ret < 0)\r\nreturn ERR_PTR(ret);\r\nif (ret > 0)\r\nreturn NULL;\r\nreturn btrfs_match_dir_item_name(root, path, name, name_len);\r\n}\r\nint btrfs_check_dir_item_collision(struct btrfs_root *root, u64 dir,\r\nconst char *name, int name_len)\r\n{\r\nint ret;\r\nstruct btrfs_key key;\r\nstruct btrfs_dir_item *di;\r\nint data_size;\r\nstruct extent_buffer *leaf;\r\nint slot;\r\nstruct btrfs_path *path;\r\npath = btrfs_alloc_path();\r\nif (!path)\r\nreturn -ENOMEM;\r\nkey.objectid = dir;\r\nbtrfs_set_key_type(&key, BTRFS_DIR_ITEM_KEY);\r\nkey.offset = btrfs_name_hash(name, name_len);\r\nret = btrfs_search_slot(NULL, root, &key, path, 0, 0);\r\nif (ret < 0)\r\ngoto out;\r\nif (ret > 0) {\r\nret = 0;\r\ngoto out;\r\n}\r\ndi = btrfs_match_dir_item_name(root, path, name, name_len);\r\nif (di) {\r\nret = -EEXIST;\r\ngoto out;\r\n}\r\ndata_size = sizeof(*di) + name_len + sizeof(struct btrfs_item);\r\nleaf = path->nodes[0];\r\nslot = path->slots[0];\r\nif (data_size + btrfs_item_size_nr(leaf, slot) +\r\nsizeof(struct btrfs_item) > BTRFS_LEAF_DATA_SIZE(root)) {\r\nret = -EOVERFLOW;\r\n} else {\r\nret = 0;\r\n}\r\nout:\r\nbtrfs_free_path(path);\r\nreturn ret;\r\n}\r\nstruct btrfs_dir_item *\r\nbtrfs_lookup_dir_index_item(struct btrfs_trans_handle *trans,\r\nstruct btrfs_root *root,\r\nstruct btrfs_path *path, u64 dir,\r\nu64 objectid, const char *name, int name_len,\r\nint mod)\r\n{\r\nint ret;\r\nstruct btrfs_key key;\r\nint ins_len = mod < 0 ? -1 : 0;\r\nint cow = mod != 0;\r\nkey.objectid = dir;\r\nbtrfs_set_key_type(&key, BTRFS_DIR_INDEX_KEY);\r\nkey.offset = objectid;\r\nret = btrfs_search_slot(trans, root, &key, path, ins_len, cow);\r\nif (ret < 0)\r\nreturn ERR_PTR(ret);\r\nif (ret > 0)\r\nreturn ERR_PTR(-ENOENT);\r\nreturn btrfs_match_dir_item_name(root, path, name, name_len);\r\n}\r\nstruct btrfs_dir_item *\r\nbtrfs_search_dir_index_item(struct btrfs_root *root,\r\nstruct btrfs_path *path, u64 dirid,\r\nconst char *name, int name_len)\r\n{\r\nstruct extent_buffer *leaf;\r\nstruct btrfs_dir_item *di;\r\nstruct btrfs_key key;\r\nu32 nritems;\r\nint ret;\r\nkey.objectid = dirid;\r\nkey.type = BTRFS_DIR_INDEX_KEY;\r\nkey.offset = 0;\r\nret = btrfs_search_slot(NULL, root, &key, path, 0, 0);\r\nif (ret < 0)\r\nreturn ERR_PTR(ret);\r\nleaf = path->nodes[0];\r\nnritems = btrfs_header_nritems(leaf);\r\nwhile (1) {\r\nif (path->slots[0] >= nritems) {\r\nret = btrfs_next_leaf(root, path);\r\nif (ret < 0)\r\nreturn ERR_PTR(ret);\r\nif (ret > 0)\r\nbreak;\r\nleaf = path->nodes[0];\r\nnritems = btrfs_header_nritems(leaf);\r\ncontinue;\r\n}\r\nbtrfs_item_key_to_cpu(leaf, &key, path->slots[0]);\r\nif (key.objectid != dirid || key.type != BTRFS_DIR_INDEX_KEY)\r\nbreak;\r\ndi = btrfs_match_dir_item_name(root, path, name, name_len);\r\nif (di)\r\nreturn di;\r\npath->slots[0]++;\r\n}\r\nreturn NULL;\r\n}\r\nstruct btrfs_dir_item *btrfs_lookup_xattr(struct btrfs_trans_handle *trans,\r\nstruct btrfs_root *root,\r\nstruct btrfs_path *path, u64 dir,\r\nconst char *name, u16 name_len,\r\nint mod)\r\n{\r\nint ret;\r\nstruct btrfs_key key;\r\nint ins_len = mod < 0 ? -1 : 0;\r\nint cow = mod != 0;\r\nkey.objectid = dir;\r\nbtrfs_set_key_type(&key, BTRFS_XATTR_ITEM_KEY);\r\nkey.offset = btrfs_name_hash(name, name_len);\r\nret = btrfs_search_slot(trans, root, &key, path, ins_len, cow);\r\nif (ret < 0)\r\nreturn ERR_PTR(ret);\r\nif (ret > 0)\r\nreturn NULL;\r\nreturn btrfs_match_dir_item_name(root, path, name, name_len);\r\n}\r\nstruct btrfs_dir_item *btrfs_match_dir_item_name(struct btrfs_root *root,\r\nstruct btrfs_path *path,\r\nconst char *name, int name_len)\r\n{\r\nstruct btrfs_dir_item *dir_item;\r\nunsigned long name_ptr;\r\nu32 total_len;\r\nu32 cur = 0;\r\nu32 this_len;\r\nstruct extent_buffer *leaf;\r\nleaf = path->nodes[0];\r\ndir_item = btrfs_item_ptr(leaf, path->slots[0], struct btrfs_dir_item);\r\nif (verify_dir_item(root, leaf, dir_item))\r\nreturn NULL;\r\ntotal_len = btrfs_item_size_nr(leaf, path->slots[0]);\r\nwhile (cur < total_len) {\r\nthis_len = sizeof(*dir_item) +\r\nbtrfs_dir_name_len(leaf, dir_item) +\r\nbtrfs_dir_data_len(leaf, dir_item);\r\nname_ptr = (unsigned long)(dir_item + 1);\r\nif (btrfs_dir_name_len(leaf, dir_item) == name_len &&\r\nmemcmp_extent_buffer(leaf, name, name_ptr, name_len) == 0)\r\nreturn dir_item;\r\ncur += this_len;\r\ndir_item = (struct btrfs_dir_item *)((char *)dir_item +\r\nthis_len);\r\n}\r\nreturn NULL;\r\n}\r\nint btrfs_delete_one_dir_name(struct btrfs_trans_handle *trans,\r\nstruct btrfs_root *root,\r\nstruct btrfs_path *path,\r\nstruct btrfs_dir_item *di)\r\n{\r\nstruct extent_buffer *leaf;\r\nu32 sub_item_len;\r\nu32 item_len;\r\nint ret = 0;\r\nleaf = path->nodes[0];\r\nsub_item_len = sizeof(*di) + btrfs_dir_name_len(leaf, di) +\r\nbtrfs_dir_data_len(leaf, di);\r\nitem_len = btrfs_item_size_nr(leaf, path->slots[0]);\r\nif (sub_item_len == item_len) {\r\nret = btrfs_del_item(trans, root, path);\r\n} else {\r\nunsigned long ptr = (unsigned long)di;\r\nunsigned long start;\r\nstart = btrfs_item_ptr_offset(leaf, path->slots[0]);\r\nmemmove_extent_buffer(leaf, ptr, ptr + sub_item_len,\r\nitem_len - (ptr + sub_item_len - start));\r\nbtrfs_truncate_item(trans, root, path,\r\nitem_len - sub_item_len, 1);\r\n}\r\nreturn ret;\r\n}\r\nint verify_dir_item(struct btrfs_root *root,\r\nstruct extent_buffer *leaf,\r\nstruct btrfs_dir_item *dir_item)\r\n{\r\nu16 namelen = BTRFS_NAME_LEN;\r\nu8 type = btrfs_dir_type(leaf, dir_item);\r\nif (type >= BTRFS_FT_MAX) {\r\nprintk(KERN_CRIT "btrfs: invalid dir item type: %d\n",\r\n(int)type);\r\nreturn 1;\r\n}\r\nif (type == BTRFS_FT_XATTR)\r\nnamelen = XATTR_NAME_MAX;\r\nif (btrfs_dir_name_len(leaf, dir_item) > namelen) {\r\nprintk(KERN_CRIT "btrfs: invalid dir item name len: %u\n",\r\n(unsigned)btrfs_dir_data_len(leaf, dir_item));\r\nreturn 1;\r\n}\r\nif (btrfs_dir_data_len(leaf, dir_item) > BTRFS_MAX_XATTR_SIZE(root)) {\r\nprintk(KERN_CRIT "btrfs: invalid dir item data len: %u\n",\r\n(unsigned)btrfs_dir_data_len(leaf, dir_item));\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}
