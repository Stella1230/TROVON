static inline u32 PM3_READ_REG(struct pm3_par *par, s32 off)\r\n{\r\nreturn fb_readl(par->v_regs + off);\r\n}\r\nstatic inline void PM3_WRITE_REG(struct pm3_par *par, s32 off, u32 v)\r\n{\r\nfb_writel(v, par->v_regs + off);\r\n}\r\nstatic inline void PM3_WAIT(struct pm3_par *par, u32 n)\r\n{\r\nwhile (PM3_READ_REG(par, PM3InFIFOSpace) < n)\r\ncpu_relax();\r\n}\r\nstatic inline void PM3_WRITE_DAC_REG(struct pm3_par *par, unsigned r, u8 v)\r\n{\r\nPM3_WAIT(par, 3);\r\nPM3_WRITE_REG(par, PM3RD_IndexHigh, (r >> 8) & 0xff);\r\nPM3_WRITE_REG(par, PM3RD_IndexLow, r & 0xff);\r\nwmb();\r\nPM3_WRITE_REG(par, PM3RD_IndexedData, v);\r\nwmb();\r\n}\r\nstatic inline void pm3fb_set_color(struct pm3_par *par, unsigned char regno,\r\nunsigned char r, unsigned char g, unsigned char b)\r\n{\r\nPM3_WAIT(par, 4);\r\nPM3_WRITE_REG(par, PM3RD_PaletteWriteAddress, regno);\r\nwmb();\r\nPM3_WRITE_REG(par, PM3RD_PaletteData, r);\r\nwmb();\r\nPM3_WRITE_REG(par, PM3RD_PaletteData, g);\r\nwmb();\r\nPM3_WRITE_REG(par, PM3RD_PaletteData, b);\r\nwmb();\r\n}\r\nstatic void pm3fb_clear_colormap(struct pm3_par *par,\r\nunsigned char r, unsigned char g, unsigned char b)\r\n{\r\nint i;\r\nfor (i = 0; i < 256 ; i++)\r\npm3fb_set_color(par, i, r, g, b);\r\n}\r\nstatic void pm3fb_calculate_clock(unsigned long reqclock,\r\nunsigned char *prescale,\r\nunsigned char *feedback,\r\nunsigned char *postscale)\r\n{\r\nint f, pre, post;\r\nunsigned long freq;\r\nlong freqerr = 1000;\r\nlong currerr;\r\nfor (f = 1; f < 256; f++) {\r\nfor (pre = 1; pre < 256; pre++) {\r\nfor (post = 0; post < 5; post++) {\r\nfreq = ((2*PM3_REF_CLOCK * f) >> post) / pre;\r\ncurrerr = (reqclock > freq)\r\n? reqclock - freq\r\n: freq - reqclock;\r\nif (currerr < freqerr) {\r\nfreqerr = currerr;\r\n*feedback = f;\r\n*prescale = pre;\r\n*postscale = post;\r\n}\r\n}\r\n}\r\n}\r\n}\r\nstatic inline int pm3fb_depth(const struct fb_var_screeninfo *var)\r\n{\r\nif (var->bits_per_pixel == 16)\r\nreturn var->red.length + var->green.length\r\n+ var->blue.length;\r\nreturn var->bits_per_pixel;\r\n}\r\nstatic inline int pm3fb_shift_bpp(unsigned bpp, int v)\r\n{\r\nswitch (bpp) {\r\ncase 8:\r\nreturn (v >> 4);\r\ncase 16:\r\nreturn (v >> 3);\r\ncase 32:\r\nreturn (v >> 2);\r\n}\r\nDPRINTK("Unsupported depth %u\n", bpp);\r\nreturn 0;\r\n}\r\nstatic int pm3fb_sync(struct fb_info *info)\r\n{\r\nstruct pm3_par *par = info->par;\r\nPM3_WAIT(par, 2);\r\nPM3_WRITE_REG(par, PM3FilterMode, PM3FilterModeSync);\r\nPM3_WRITE_REG(par, PM3Sync, 0);\r\nmb();\r\ndo {\r\nwhile ((PM3_READ_REG(par, PM3OutFIFOWords)) == 0)\r\ncpu_relax();\r\n} while ((PM3_READ_REG(par, PM3OutputFifo)) != PM3Sync_Tag);\r\nreturn 0;\r\n}\r\nstatic void pm3fb_init_engine(struct fb_info *info)\r\n{\r\nstruct pm3_par *par = info->par;\r\nconst u32 width = (info->var.xres_virtual + 7) & ~7;\r\nPM3_WAIT(par, 50);\r\nPM3_WRITE_REG(par, PM3FilterMode, PM3FilterModeSync);\r\nPM3_WRITE_REG(par, PM3StatisticMode, 0x0);\r\nPM3_WRITE_REG(par, PM3DeltaMode, 0x0);\r\nPM3_WRITE_REG(par, PM3RasterizerMode, 0x0);\r\nPM3_WRITE_REG(par, PM3ScissorMode, 0x0);\r\nPM3_WRITE_REG(par, PM3LineStippleMode, 0x0);\r\nPM3_WRITE_REG(par, PM3AreaStippleMode, 0x0);\r\nPM3_WRITE_REG(par, PM3GIDMode, 0x0);\r\nPM3_WRITE_REG(par, PM3DepthMode, 0x0);\r\nPM3_WRITE_REG(par, PM3StencilMode, 0x0);\r\nPM3_WRITE_REG(par, PM3StencilData, 0x0);\r\nPM3_WRITE_REG(par, PM3ColorDDAMode, 0x0);\r\nPM3_WRITE_REG(par, PM3TextureCoordMode, 0x0);\r\nPM3_WRITE_REG(par, PM3TextureIndexMode0, 0x0);\r\nPM3_WRITE_REG(par, PM3TextureIndexMode1, 0x0);\r\nPM3_WRITE_REG(par, PM3TextureReadMode, 0x0);\r\nPM3_WRITE_REG(par, PM3LUTMode, 0x0);\r\nPM3_WRITE_REG(par, PM3TextureFilterMode, 0x0);\r\nPM3_WRITE_REG(par, PM3TextureCompositeMode, 0x0);\r\nPM3_WRITE_REG(par, PM3TextureApplicationMode, 0x0);\r\nPM3_WRITE_REG(par, PM3TextureCompositeColorMode1, 0x0);\r\nPM3_WRITE_REG(par, PM3TextureCompositeAlphaMode1, 0x0);\r\nPM3_WRITE_REG(par, PM3TextureCompositeColorMode0, 0x0);\r\nPM3_WRITE_REG(par, PM3TextureCompositeAlphaMode0, 0x0);\r\nPM3_WRITE_REG(par, PM3FogMode, 0x0);\r\nPM3_WRITE_REG(par, PM3ChromaTestMode, 0x0);\r\nPM3_WRITE_REG(par, PM3AlphaTestMode, 0x0);\r\nPM3_WRITE_REG(par, PM3AntialiasMode, 0x0);\r\nPM3_WRITE_REG(par, PM3YUVMode, 0x0);\r\nPM3_WRITE_REG(par, PM3AlphaBlendColorMode, 0x0);\r\nPM3_WRITE_REG(par, PM3AlphaBlendAlphaMode, 0x0);\r\nPM3_WRITE_REG(par, PM3DitherMode, 0x0);\r\nPM3_WRITE_REG(par, PM3LogicalOpMode, 0x0);\r\nPM3_WRITE_REG(par, PM3RouterMode, 0x0);\r\nPM3_WRITE_REG(par, PM3Window, 0x0);\r\nPM3_WRITE_REG(par, PM3Config2D, 0x0);\r\nPM3_WRITE_REG(par, PM3SpanColorMask, 0xffffffff);\r\nPM3_WRITE_REG(par, PM3XBias, 0x0);\r\nPM3_WRITE_REG(par, PM3YBias, 0x0);\r\nPM3_WRITE_REG(par, PM3DeltaControl, 0x0);\r\nPM3_WRITE_REG(par, PM3BitMaskPattern, 0xffffffff);\r\nPM3_WRITE_REG(par, PM3FBDestReadEnables,\r\nPM3FBDestReadEnables_E(0xff) |\r\nPM3FBDestReadEnables_R(0xff) |\r\nPM3FBDestReadEnables_ReferenceAlpha(0xff));\r\nPM3_WRITE_REG(par, PM3FBDestReadBufferAddr0, 0x0);\r\nPM3_WRITE_REG(par, PM3FBDestReadBufferOffset0, 0x0);\r\nPM3_WRITE_REG(par, PM3FBDestReadBufferWidth0,\r\nPM3FBDestReadBufferWidth_Width(width));\r\nPM3_WRITE_REG(par, PM3FBDestReadMode,\r\nPM3FBDestReadMode_ReadEnable |\r\nPM3FBDestReadMode_Enable0);\r\nPM3_WRITE_REG(par, PM3FBSourceReadBufferAddr, 0x0);\r\nPM3_WRITE_REG(par, PM3FBSourceReadBufferOffset, 0x0);\r\nPM3_WRITE_REG(par, PM3FBSourceReadBufferWidth,\r\nPM3FBSourceReadBufferWidth_Width(width));\r\nPM3_WRITE_REG(par, PM3FBSourceReadMode,\r\nPM3FBSourceReadMode_Blocking |\r\nPM3FBSourceReadMode_ReadEnable);\r\nPM3_WAIT(par, 2);\r\n{\r\nunsigned long rm = 1 | (3 << 7);\r\nswitch (info->var.bits_per_pixel) {\r\ncase 8:\r\nPM3_WRITE_REG(par, PM3PixelSize,\r\nPM3PixelSize_GLOBAL_8BIT);\r\n#ifdef __BIG_ENDIAN\r\nrm |= 3 << 15;\r\n#endif\r\nbreak;\r\ncase 16:\r\nPM3_WRITE_REG(par, PM3PixelSize,\r\nPM3PixelSize_GLOBAL_16BIT);\r\n#ifdef __BIG_ENDIAN\r\nrm |= 2 << 15;\r\n#endif\r\nbreak;\r\ncase 32:\r\nPM3_WRITE_REG(par, PM3PixelSize,\r\nPM3PixelSize_GLOBAL_32BIT);\r\nbreak;\r\ndefault:\r\nDPRINTK(1, "Unsupported depth %d\n",\r\ninfo->var.bits_per_pixel);\r\nbreak;\r\n}\r\nPM3_WRITE_REG(par, PM3RasterizerMode, rm);\r\n}\r\nPM3_WAIT(par, 20);\r\nPM3_WRITE_REG(par, PM3FBSoftwareWriteMask, 0xffffffff);\r\nPM3_WRITE_REG(par, PM3FBHardwareWriteMask, 0xffffffff);\r\nPM3_WRITE_REG(par, PM3FBWriteMode,\r\nPM3FBWriteMode_WriteEnable |\r\nPM3FBWriteMode_OpaqueSpan |\r\nPM3FBWriteMode_Enable0);\r\nPM3_WRITE_REG(par, PM3FBWriteBufferAddr0, 0x0);\r\nPM3_WRITE_REG(par, PM3FBWriteBufferOffset0, 0x0);\r\nPM3_WRITE_REG(par, PM3FBWriteBufferWidth0,\r\nPM3FBWriteBufferWidth_Width(width));\r\nPM3_WRITE_REG(par, PM3SizeOfFramebuffer, 0x0);\r\n{\r\nunsigned long sofb = info->screen_size /\r\ninfo->fix.line_length;\r\nif (sofb > 4095)\r\nPM3_WRITE_REG(par, PM3SizeOfFramebuffer, 4095);\r\nelse\r\nPM3_WRITE_REG(par, PM3SizeOfFramebuffer, sofb);\r\nswitch (info->var.bits_per_pixel) {\r\ncase 8:\r\nPM3_WRITE_REG(par, PM3DitherMode,\r\n(1 << 10) | (2 << 3));\r\nbreak;\r\ncase 16:\r\nPM3_WRITE_REG(par, PM3DitherMode,\r\n(1 << 10) | (1 << 3));\r\nbreak;\r\ncase 32:\r\nPM3_WRITE_REG(par, PM3DitherMode,\r\n(1 << 10) | (0 << 3));\r\nbreak;\r\ndefault:\r\nDPRINTK(1, "Unsupported depth %d\n",\r\ninfo->current_par->depth);\r\nbreak;\r\n}\r\n}\r\nPM3_WRITE_REG(par, PM3dXDom, 0x0);\r\nPM3_WRITE_REG(par, PM3dXSub, 0x0);\r\nPM3_WRITE_REG(par, PM3dY, 1 << 16);\r\nPM3_WRITE_REG(par, PM3StartXDom, 0x0);\r\nPM3_WRITE_REG(par, PM3StartXSub, 0x0);\r\nPM3_WRITE_REG(par, PM3StartY, 0x0);\r\nPM3_WRITE_REG(par, PM3Count, 0x0);\r\nPM3_WRITE_REG(par, PM3LBDestReadMode, 0x0);\r\nPM3_WRITE_REG(par, PM3LBDestReadEnables, 0x0);\r\nPM3_WRITE_REG(par, PM3LBSourceReadMode, 0x0);\r\nPM3_WRITE_REG(par, PM3LBWriteMode, 0x0);\r\npm3fb_sync(info);\r\n}\r\nstatic void pm3fb_fillrect(struct fb_info *info,\r\nconst struct fb_fillrect *region)\r\n{\r\nstruct pm3_par *par = info->par;\r\nstruct fb_fillrect modded;\r\nint vxres, vyres;\r\nint rop;\r\nu32 color = (info->fix.visual == FB_VISUAL_TRUECOLOR) ?\r\n((u32 *)info->pseudo_palette)[region->color] : region->color;\r\nif (info->state != FBINFO_STATE_RUNNING)\r\nreturn;\r\nif (info->flags & FBINFO_HWACCEL_DISABLED) {\r\ncfb_fillrect(info, region);\r\nreturn;\r\n}\r\nif (region->rop == ROP_COPY )\r\nrop = PM3Config2D_ForegroundROP(0x3);\r\nelse\r\nrop = PM3Config2D_ForegroundROP(0x6) |\r\nPM3Config2D_FBDestReadEnable;\r\nvxres = info->var.xres_virtual;\r\nvyres = info->var.yres_virtual;\r\nmemcpy(&modded, region, sizeof(struct fb_fillrect));\r\nif (!modded.width || !modded.height ||\r\nmodded.dx >= vxres || modded.dy >= vyres)\r\nreturn;\r\nif (modded.dx + modded.width > vxres)\r\nmodded.width = vxres - modded.dx;\r\nif (modded.dy + modded.height > vyres)\r\nmodded.height = vyres - modded.dy;\r\nif (info->var.bits_per_pixel == 8)\r\ncolor |= color << 8;\r\nif (info->var.bits_per_pixel <= 16)\r\ncolor |= color << 16;\r\nPM3_WAIT(par, 4);\r\nPM3_WRITE_REG(par, PM3Config2D,\r\nPM3Config2D_UseConstantSource |\r\nPM3Config2D_ForegroundROPEnable |\r\nrop |\r\nPM3Config2D_FBWriteEnable);\r\nPM3_WRITE_REG(par, PM3ForegroundColor, color);\r\nPM3_WRITE_REG(par, PM3RectanglePosition,\r\nPM3RectanglePosition_XOffset(modded.dx) |\r\nPM3RectanglePosition_YOffset(modded.dy));\r\nPM3_WRITE_REG(par, PM3Render2D,\r\nPM3Render2D_XPositive |\r\nPM3Render2D_YPositive |\r\nPM3Render2D_Operation_Normal |\r\nPM3Render2D_SpanOperation |\r\nPM3Render2D_Width(modded.width) |\r\nPM3Render2D_Height(modded.height));\r\n}\r\nstatic void pm3fb_copyarea(struct fb_info *info,\r\nconst struct fb_copyarea *area)\r\n{\r\nstruct pm3_par *par = info->par;\r\nstruct fb_copyarea modded;\r\nu32 vxres, vyres;\r\nint x_align, o_x, o_y;\r\nif (info->state != FBINFO_STATE_RUNNING)\r\nreturn;\r\nif (info->flags & FBINFO_HWACCEL_DISABLED) {\r\ncfb_copyarea(info, area);\r\nreturn;\r\n}\r\nmemcpy(&modded, area, sizeof(struct fb_copyarea));\r\nvxres = info->var.xres_virtual;\r\nvyres = info->var.yres_virtual;\r\nif (!modded.width || !modded.height ||\r\nmodded.sx >= vxres || modded.sy >= vyres ||\r\nmodded.dx >= vxres || modded.dy >= vyres)\r\nreturn;\r\nif (modded.sx + modded.width > vxres)\r\nmodded.width = vxres - modded.sx;\r\nif (modded.dx + modded.width > vxres)\r\nmodded.width = vxres - modded.dx;\r\nif (modded.sy + modded.height > vyres)\r\nmodded.height = vyres - modded.sy;\r\nif (modded.dy + modded.height > vyres)\r\nmodded.height = vyres - modded.dy;\r\no_x = modded.sx - modded.dx;\r\no_y = modded.sy - modded.dy;\r\nx_align = (modded.sx & 0x1f);\r\nPM3_WAIT(par, 6);\r\nPM3_WRITE_REG(par, PM3Config2D,\r\nPM3Config2D_UserScissorEnable |\r\nPM3Config2D_ForegroundROPEnable |\r\nPM3Config2D_Blocking |\r\nPM3Config2D_ForegroundROP(0x3) |\r\nPM3Config2D_FBWriteEnable);\r\nPM3_WRITE_REG(par, PM3ScissorMinXY,\r\n((modded.dy & 0x0fff) << 16) | (modded.dx & 0x0fff));\r\nPM3_WRITE_REG(par, PM3ScissorMaxXY,\r\n(((modded.dy + modded.height) & 0x0fff) << 16) |\r\n((modded.dx + modded.width) & 0x0fff));\r\nPM3_WRITE_REG(par, PM3FBSourceReadBufferOffset,\r\nPM3FBSourceReadBufferOffset_XOffset(o_x) |\r\nPM3FBSourceReadBufferOffset_YOffset(o_y));\r\nPM3_WRITE_REG(par, PM3RectanglePosition,\r\nPM3RectanglePosition_XOffset(modded.dx - x_align) |\r\nPM3RectanglePosition_YOffset(modded.dy));\r\nPM3_WRITE_REG(par, PM3Render2D,\r\n((modded.sx > modded.dx) ? PM3Render2D_XPositive : 0) |\r\n((modded.sy > modded.dy) ? PM3Render2D_YPositive : 0) |\r\nPM3Render2D_Operation_Normal |\r\nPM3Render2D_SpanOperation |\r\nPM3Render2D_FBSourceReadEnable |\r\nPM3Render2D_Width(modded.width + x_align) |\r\nPM3Render2D_Height(modded.height));\r\n}\r\nstatic void pm3fb_imageblit(struct fb_info *info, const struct fb_image *image)\r\n{\r\nstruct pm3_par *par = info->par;\r\nu32 height = image->height;\r\nu32 fgx, bgx;\r\nconst u32 *src = (const u32 *)image->data;\r\nif (info->state != FBINFO_STATE_RUNNING)\r\nreturn;\r\nif (info->flags & FBINFO_HWACCEL_DISABLED) {\r\ncfb_imageblit(info, image);\r\nreturn;\r\n}\r\nswitch (info->fix.visual) {\r\ncase FB_VISUAL_PSEUDOCOLOR:\r\nfgx = image->fg_color;\r\nbgx = image->bg_color;\r\nbreak;\r\ncase FB_VISUAL_TRUECOLOR:\r\ndefault:\r\nfgx = par->palette[image->fg_color];\r\nbgx = par->palette[image->bg_color];\r\nbreak;\r\n}\r\nif (image->depth != 1) {\r\ncfb_imageblit(info, image);\r\nreturn;\r\n}\r\nif (info->var.bits_per_pixel == 8) {\r\nfgx |= fgx << 8;\r\nbgx |= bgx << 8;\r\n}\r\nif (info->var.bits_per_pixel <= 16) {\r\nfgx |= fgx << 16;\r\nbgx |= bgx << 16;\r\n}\r\nPM3_WAIT(par, 7);\r\nPM3_WRITE_REG(par, PM3ForegroundColor, fgx);\r\nPM3_WRITE_REG(par, PM3BackgroundColor, bgx);\r\nPM3_WRITE_REG(par, PM3Config2D,\r\nPM3Config2D_UserScissorEnable |\r\nPM3Config2D_UseConstantSource |\r\nPM3Config2D_ForegroundROPEnable |\r\nPM3Config2D_ForegroundROP(0x3) |\r\nPM3Config2D_OpaqueSpan |\r\nPM3Config2D_FBWriteEnable);\r\nPM3_WRITE_REG(par, PM3ScissorMinXY,\r\n((image->dy & 0x0fff) << 16) | (image->dx & 0x0fff));\r\nPM3_WRITE_REG(par, PM3ScissorMaxXY,\r\n(((image->dy + image->height) & 0x0fff) << 16) |\r\n((image->dx + image->width) & 0x0fff));\r\nPM3_WRITE_REG(par, PM3RectanglePosition,\r\nPM3RectanglePosition_XOffset(image->dx) |\r\nPM3RectanglePosition_YOffset(image->dy));\r\nPM3_WRITE_REG(par, PM3Render2D,\r\nPM3Render2D_XPositive |\r\nPM3Render2D_YPositive |\r\nPM3Render2D_Operation_SyncOnBitMask |\r\nPM3Render2D_SpanOperation |\r\nPM3Render2D_Width(image->width) |\r\nPM3Render2D_Height(image->height));\r\nwhile (height--) {\r\nint width = ((image->width + 7) >> 3)\r\n+ info->pixmap.scan_align - 1;\r\nwidth >>= 2;\r\nwhile (width >= PM3_FIFO_SIZE) {\r\nint i = PM3_FIFO_SIZE - 1;\r\nPM3_WAIT(par, PM3_FIFO_SIZE);\r\nwhile (i--) {\r\nPM3_WRITE_REG(par, PM3BitMaskPattern, *src);\r\nsrc++;\r\n}\r\nwidth -= PM3_FIFO_SIZE - 1;\r\n}\r\nPM3_WAIT(par, width + 1);\r\nwhile (width--) {\r\nPM3_WRITE_REG(par, PM3BitMaskPattern, *src);\r\nsrc++;\r\n}\r\n}\r\n}\r\nstatic int pm3fb_cursor(struct fb_info *info, struct fb_cursor *cursor)\r\n{\r\nstruct pm3_par *par = info->par;\r\nu8 mode;\r\nif (!hwcursor)\r\nreturn -EINVAL;\r\nif (cursor->image.width > 64 ||\r\ncursor->image.height > 64 ||\r\ncursor->image.depth > 1)\r\nreturn -EINVAL;\r\nmode = PM3RD_CursorMode_TYPE_X;\r\nif (cursor->enable)\r\nmode |= PM3RD_CursorMode_CURSOR_ENABLE;\r\nPM3_WRITE_DAC_REG(par, PM3RD_CursorMode, mode);\r\nif (!cursor->set)\r\nreturn 0;\r\nif (cursor->set & FB_CUR_SETPOS) {\r\nint x = cursor->image.dx - info->var.xoffset;\r\nint y = cursor->image.dy - info->var.yoffset;\r\nPM3_WRITE_DAC_REG(par, PM3RD_CursorXLow, x & 0xff);\r\nPM3_WRITE_DAC_REG(par, PM3RD_CursorXHigh, (x >> 8) & 0xf);\r\nPM3_WRITE_DAC_REG(par, PM3RD_CursorYLow, y & 0xff);\r\nPM3_WRITE_DAC_REG(par, PM3RD_CursorYHigh, (y >> 8) & 0xf);\r\n}\r\nif (cursor->set & FB_CUR_SETHOT) {\r\nPM3_WRITE_DAC_REG(par, PM3RD_CursorHotSpotX,\r\ncursor->hot.x & 0x3f);\r\nPM3_WRITE_DAC_REG(par, PM3RD_CursorHotSpotY,\r\ncursor->hot.y & 0x3f);\r\n}\r\nif (cursor->set & FB_CUR_SETCMAP) {\r\nu32 fg_idx = cursor->image.fg_color;\r\nu32 bg_idx = cursor->image.bg_color;\r\nstruct fb_cmap cmap = info->cmap;\r\nPM3_WRITE_DAC_REG(par, PM3RD_CursorPalette(39),\r\ncmap.red[fg_idx] >> 8 );\r\nPM3_WRITE_DAC_REG(par, PM3RD_CursorPalette(40),\r\ncmap.green[fg_idx] >> 8 );\r\nPM3_WRITE_DAC_REG(par, PM3RD_CursorPalette(41),\r\ncmap.blue[fg_idx] >> 8 );\r\nPM3_WRITE_DAC_REG(par, PM3RD_CursorPalette(42),\r\ncmap.red[bg_idx] >> 8 );\r\nPM3_WRITE_DAC_REG(par, PM3RD_CursorPalette(43),\r\ncmap.green[bg_idx] >> 8 );\r\nPM3_WRITE_DAC_REG(par, PM3RD_CursorPalette(44),\r\ncmap.blue[bg_idx] >> 8 );\r\n}\r\nif (cursor->set & (FB_CUR_SETSHAPE | FB_CUR_SETIMAGE)) {\r\nu8 *bitmap = (u8 *)cursor->image.data;\r\nu8 *mask = (u8 *)cursor->mask;\r\nint i;\r\nint pos = PM3RD_CursorPattern(0);\r\nfor (i = 0; i < cursor->image.height; i++) {\r\nint j = (cursor->image.width + 7) >> 3;\r\nint k = 8 - j;\r\nfor (; j > 0; j--) {\r\nu8 data = *bitmap ^ *mask;\r\nif (cursor->rop == ROP_COPY)\r\ndata = *mask & *bitmap;\r\nPM3_WRITE_DAC_REG(par, pos++,\r\ncursor_bits_lookup[data >> 4] |\r\n(cursor_bits_lookup[*mask >> 4] << 1));\r\nPM3_WRITE_DAC_REG(par, pos++,\r\ncursor_bits_lookup[data & 0xf] |\r\n(cursor_bits_lookup[*mask & 0xf] << 1));\r\nbitmap++;\r\nmask++;\r\n}\r\nfor (; k > 0; k--) {\r\nPM3_WRITE_DAC_REG(par, pos++, 0);\r\nPM3_WRITE_DAC_REG(par, pos++, 0);\r\n}\r\n}\r\nwhile (pos < PM3RD_CursorPattern(1024))\r\nPM3_WRITE_DAC_REG(par, pos++, 0);\r\n}\r\nreturn 0;\r\n}\r\nstatic void pm3fb_write_mode(struct fb_info *info)\r\n{\r\nstruct pm3_par *par = info->par;\r\nchar tempsync = 0x00;\r\nchar tempmisc = 0x00;\r\nconst u32 hsstart = info->var.right_margin;\r\nconst u32 hsend = hsstart + info->var.hsync_len;\r\nconst u32 hbend = hsend + info->var.left_margin;\r\nconst u32 xres = (info->var.xres + 31) & ~31;\r\nconst u32 htotal = xres + hbend;\r\nconst u32 vsstart = info->var.lower_margin;\r\nconst u32 vsend = vsstart + info->var.vsync_len;\r\nconst u32 vbend = vsend + info->var.upper_margin;\r\nconst u32 vtotal = info->var.yres + vbend;\r\nconst u32 width = (info->var.xres_virtual + 7) & ~7;\r\nconst unsigned bpp = info->var.bits_per_pixel;\r\nPM3_WAIT(par, 20);\r\nPM3_WRITE_REG(par, PM3MemBypassWriteMask, 0xffffffff);\r\nPM3_WRITE_REG(par, PM3Aperture0, 0x00000000);\r\nPM3_WRITE_REG(par, PM3Aperture1, 0x00000000);\r\nPM3_WRITE_REG(par, PM3FIFODis, 0x00000007);\r\nPM3_WRITE_REG(par, PM3HTotal,\r\npm3fb_shift_bpp(bpp, htotal - 1));\r\nPM3_WRITE_REG(par, PM3HsEnd,\r\npm3fb_shift_bpp(bpp, hsend));\r\nPM3_WRITE_REG(par, PM3HsStart,\r\npm3fb_shift_bpp(bpp, hsstart));\r\nPM3_WRITE_REG(par, PM3HbEnd,\r\npm3fb_shift_bpp(bpp, hbend));\r\nPM3_WRITE_REG(par, PM3HgEnd,\r\npm3fb_shift_bpp(bpp, hbend));\r\nPM3_WRITE_REG(par, PM3ScreenStride,\r\npm3fb_shift_bpp(bpp, width));\r\nPM3_WRITE_REG(par, PM3VTotal, vtotal - 1);\r\nPM3_WRITE_REG(par, PM3VsEnd, vsend - 1);\r\nPM3_WRITE_REG(par, PM3VsStart, vsstart - 1);\r\nPM3_WRITE_REG(par, PM3VbEnd, vbend);\r\nswitch (bpp) {\r\ncase 8:\r\nPM3_WRITE_REG(par, PM3ByAperture1Mode,\r\nPM3ByApertureMode_PIXELSIZE_8BIT);\r\nPM3_WRITE_REG(par, PM3ByAperture2Mode,\r\nPM3ByApertureMode_PIXELSIZE_8BIT);\r\nbreak;\r\ncase 16:\r\n#ifndef __BIG_ENDIAN\r\nPM3_WRITE_REG(par, PM3ByAperture1Mode,\r\nPM3ByApertureMode_PIXELSIZE_16BIT);\r\nPM3_WRITE_REG(par, PM3ByAperture2Mode,\r\nPM3ByApertureMode_PIXELSIZE_16BIT);\r\n#else\r\nPM3_WRITE_REG(par, PM3ByAperture1Mode,\r\nPM3ByApertureMode_PIXELSIZE_16BIT |\r\nPM3ByApertureMode_BYTESWAP_BADC);\r\nPM3_WRITE_REG(par, PM3ByAperture2Mode,\r\nPM3ByApertureMode_PIXELSIZE_16BIT |\r\nPM3ByApertureMode_BYTESWAP_BADC);\r\n#endif\r\nbreak;\r\ncase 32:\r\n#ifndef __BIG_ENDIAN\r\nPM3_WRITE_REG(par, PM3ByAperture1Mode,\r\nPM3ByApertureMode_PIXELSIZE_32BIT);\r\nPM3_WRITE_REG(par, PM3ByAperture2Mode,\r\nPM3ByApertureMode_PIXELSIZE_32BIT);\r\n#else\r\nPM3_WRITE_REG(par, PM3ByAperture1Mode,\r\nPM3ByApertureMode_PIXELSIZE_32BIT |\r\nPM3ByApertureMode_BYTESWAP_DCBA);\r\nPM3_WRITE_REG(par, PM3ByAperture2Mode,\r\nPM3ByApertureMode_PIXELSIZE_32BIT |\r\nPM3ByApertureMode_BYTESWAP_DCBA);\r\n#endif\r\nbreak;\r\ndefault:\r\nDPRINTK("Unsupported depth %d\n", bpp);\r\nbreak;\r\n}\r\n{\r\nunsigned int video = par->video;\r\nvideo &= ~(PM3VideoControl_HSYNC_MASK |\r\nPM3VideoControl_VSYNC_MASK);\r\nvideo |= PM3VideoControl_HSYNC_ACTIVE_HIGH |\r\nPM3VideoControl_VSYNC_ACTIVE_HIGH;\r\nPM3_WRITE_REG(par, PM3VideoControl, video);\r\n}\r\nPM3_WRITE_REG(par, PM3VClkCtl,\r\n(PM3_READ_REG(par, PM3VClkCtl) & 0xFFFFFFFC));\r\nPM3_WRITE_REG(par, PM3ScreenBase, par->base);\r\nPM3_WRITE_REG(par, PM3ChipConfig,\r\n(PM3_READ_REG(par, PM3ChipConfig) & 0xFFFFFFFD));\r\nwmb();\r\n{\r\nunsigned char uninitialized_var(m);\r\nunsigned char uninitialized_var(n);\r\nunsigned char uninitialized_var(p);\r\nunsigned long pixclock = PICOS2KHZ(info->var.pixclock);\r\n(void)pm3fb_calculate_clock(pixclock, &m, &n, &p);\r\nDPRINTK("Pixclock: %ld, Pre: %d, Feedback: %d, Post: %d\n",\r\npixclock, (int) m, (int) n, (int) p);\r\nPM3_WRITE_DAC_REG(par, PM3RD_DClk0PreScale, m);\r\nPM3_WRITE_DAC_REG(par, PM3RD_DClk0FeedbackScale, n);\r\nPM3_WRITE_DAC_REG(par, PM3RD_DClk0PostScale, p);\r\n}\r\nif ((par->video & PM3VideoControl_HSYNC_MASK) ==\r\nPM3VideoControl_HSYNC_ACTIVE_HIGH)\r\ntempsync |= PM3RD_SyncControl_HSYNC_ACTIVE_HIGH;\r\nif ((par->video & PM3VideoControl_VSYNC_MASK) ==\r\nPM3VideoControl_VSYNC_ACTIVE_HIGH)\r\ntempsync |= PM3RD_SyncControl_VSYNC_ACTIVE_HIGH;\r\nPM3_WRITE_DAC_REG(par, PM3RD_SyncControl, tempsync);\r\nDPRINTK("PM3RD_SyncControl: %d\n", tempsync);\r\nPM3_WRITE_DAC_REG(par, PM3RD_DACControl, 0x00);\r\nswitch (pm3fb_depth(&info->var)) {\r\ncase 8:\r\nPM3_WRITE_DAC_REG(par, PM3RD_PixelSize,\r\nPM3RD_PixelSize_8_BIT_PIXELS);\r\nPM3_WRITE_DAC_REG(par, PM3RD_ColorFormat,\r\nPM3RD_ColorFormat_CI8_COLOR |\r\nPM3RD_ColorFormat_COLOR_ORDER_BLUE_LOW);\r\ntempmisc |= PM3RD_MiscControl_HIGHCOLOR_RES_ENABLE;\r\nbreak;\r\ncase 12:\r\nPM3_WRITE_DAC_REG(par, PM3RD_PixelSize,\r\nPM3RD_PixelSize_16_BIT_PIXELS);\r\nPM3_WRITE_DAC_REG(par, PM3RD_ColorFormat,\r\nPM3RD_ColorFormat_4444_COLOR |\r\nPM3RD_ColorFormat_COLOR_ORDER_BLUE_LOW |\r\nPM3RD_ColorFormat_LINEAR_COLOR_EXT_ENABLE);\r\ntempmisc |= PM3RD_MiscControl_DIRECTCOLOR_ENABLE |\r\nPM3RD_MiscControl_HIGHCOLOR_RES_ENABLE;\r\nbreak;\r\ncase 15:\r\nPM3_WRITE_DAC_REG(par, PM3RD_PixelSize,\r\nPM3RD_PixelSize_16_BIT_PIXELS);\r\nPM3_WRITE_DAC_REG(par, PM3RD_ColorFormat,\r\nPM3RD_ColorFormat_5551_FRONT_COLOR |\r\nPM3RD_ColorFormat_COLOR_ORDER_BLUE_LOW |\r\nPM3RD_ColorFormat_LINEAR_COLOR_EXT_ENABLE);\r\ntempmisc |= PM3RD_MiscControl_DIRECTCOLOR_ENABLE |\r\nPM3RD_MiscControl_HIGHCOLOR_RES_ENABLE;\r\nbreak;\r\ncase 16:\r\nPM3_WRITE_DAC_REG(par, PM3RD_PixelSize,\r\nPM3RD_PixelSize_16_BIT_PIXELS);\r\nPM3_WRITE_DAC_REG(par, PM3RD_ColorFormat,\r\nPM3RD_ColorFormat_565_FRONT_COLOR |\r\nPM3RD_ColorFormat_COLOR_ORDER_BLUE_LOW |\r\nPM3RD_ColorFormat_LINEAR_COLOR_EXT_ENABLE);\r\ntempmisc |= PM3RD_MiscControl_DIRECTCOLOR_ENABLE |\r\nPM3RD_MiscControl_HIGHCOLOR_RES_ENABLE;\r\nbreak;\r\ncase 32:\r\nPM3_WRITE_DAC_REG(par, PM3RD_PixelSize,\r\nPM3RD_PixelSize_32_BIT_PIXELS);\r\nPM3_WRITE_DAC_REG(par, PM3RD_ColorFormat,\r\nPM3RD_ColorFormat_8888_COLOR |\r\nPM3RD_ColorFormat_COLOR_ORDER_BLUE_LOW);\r\ntempmisc |= PM3RD_MiscControl_DIRECTCOLOR_ENABLE |\r\nPM3RD_MiscControl_HIGHCOLOR_RES_ENABLE;\r\nbreak;\r\n}\r\nPM3_WRITE_DAC_REG(par, PM3RD_MiscControl, tempmisc);\r\n}\r\nstatic int pm3fb_check_var(struct fb_var_screeninfo *var, struct fb_info *info)\r\n{\r\nu32 lpitch;\r\nunsigned bpp = var->red.length + var->green.length\r\n+ var->blue.length + var->transp.length;\r\nif (bpp != var->bits_per_pixel) {\r\nswitch (var->bits_per_pixel) {\r\ncase 8:\r\nvar->red.length = 8;\r\nvar->green.length = 8;\r\nvar->blue.length = 8;\r\nvar->red.offset = 0;\r\nvar->green.offset = 0;\r\nvar->blue.offset = 0;\r\nvar->transp.offset = 0;\r\nvar->transp.length = 0;\r\nbreak;\r\ncase 16:\r\nvar->red.length = 5;\r\nvar->blue.length = 5;\r\nvar->green.length = 6;\r\nvar->transp.length = 0;\r\nbreak;\r\ncase 32:\r\nvar->red.length = 8;\r\nvar->green.length = 8;\r\nvar->blue.length = 8;\r\nvar->transp.length = 8;\r\nbreak;\r\ndefault:\r\nDPRINTK("depth not supported: %u\n",\r\nvar->bits_per_pixel);\r\nreturn -EINVAL;\r\n}\r\n}\r\nif (var->bits_per_pixel > 8 ) {\r\nvar->blue.offset = 0;\r\nvar->green.offset = var->blue.length;\r\nvar->red.offset = var->green.offset + var->green.length;\r\nvar->transp.offset = var->red.offset + var->red.length;\r\n}\r\nvar->height = -1;\r\nvar->width = -1;\r\nif (var->xres != var->xres_virtual) {\r\nDPRINTK("virtual x resolution != "\r\n"physical x resolution not supported\n");\r\nreturn -EINVAL;\r\n}\r\nif (var->yres > var->yres_virtual) {\r\nDPRINTK("virtual y resolution < "\r\n"physical y resolution not possible\n");\r\nreturn -EINVAL;\r\n}\r\nif (var->xoffset) {\r\nDPRINTK("xoffset not supported\n");\r\nreturn -EINVAL;\r\n}\r\nif ((var->vmode & FB_VMODE_MASK) == FB_VMODE_INTERLACED) {\r\nDPRINTK("interlace not supported\n");\r\nreturn -EINVAL;\r\n}\r\nvar->xres = (var->xres + 31) & ~31;\r\nlpitch = var->xres * ((var->bits_per_pixel + 7) >> 3);\r\nif (var->xres < 200 || var->xres > 2048) {\r\nDPRINTK("width not supported: %u\n", var->xres);\r\nreturn -EINVAL;\r\n}\r\nif (var->yres < 200 || var->yres > 4095) {\r\nDPRINTK("height not supported: %u\n", var->yres);\r\nreturn -EINVAL;\r\n}\r\nif (lpitch * var->yres_virtual > info->fix.smem_len) {\r\nDPRINTK("no memory for screen (%ux%ux%u)\n",\r\nvar->xres, var->yres_virtual, var->bits_per_pixel);\r\nreturn -EINVAL;\r\n}\r\nif (PICOS2KHZ(var->pixclock) > PM3_MAX_PIXCLOCK) {\r\nDPRINTK("pixclock too high (%ldKHz)\n",\r\nPICOS2KHZ(var->pixclock));\r\nreturn -EINVAL;\r\n}\r\nvar->accel_flags = 0;\r\nDPRINTK("Checking graphics mode at %dx%d depth %d\n",\r\nvar->xres, var->yres, var->bits_per_pixel);\r\nreturn 0;\r\n}\r\nstatic int pm3fb_set_par(struct fb_info *info)\r\n{\r\nstruct pm3_par *par = info->par;\r\nconst u32 xres = (info->var.xres + 31) & ~31;\r\nconst unsigned bpp = info->var.bits_per_pixel;\r\npar->base = pm3fb_shift_bpp(bpp, (info->var.yoffset * xres)\r\n+ info->var.xoffset);\r\npar->video = 0;\r\nif (info->var.sync & FB_SYNC_HOR_HIGH_ACT)\r\npar->video |= PM3VideoControl_HSYNC_ACTIVE_HIGH;\r\nelse\r\npar->video |= PM3VideoControl_HSYNC_ACTIVE_LOW;\r\nif (info->var.sync & FB_SYNC_VERT_HIGH_ACT)\r\npar->video |= PM3VideoControl_VSYNC_ACTIVE_HIGH;\r\nelse\r\npar->video |= PM3VideoControl_VSYNC_ACTIVE_LOW;\r\nif ((info->var.vmode & FB_VMODE_MASK) == FB_VMODE_DOUBLE)\r\npar->video |= PM3VideoControl_LINE_DOUBLE_ON;\r\nif ((info->var.activate & FB_ACTIVATE_MASK) == FB_ACTIVATE_NOW)\r\npar->video |= PM3VideoControl_ENABLE;\r\nelse\r\nDPRINTK("PM3Video disabled\n");\r\nswitch (bpp) {\r\ncase 8:\r\npar->video |= PM3VideoControl_PIXELSIZE_8BIT;\r\nbreak;\r\ncase 16:\r\npar->video |= PM3VideoControl_PIXELSIZE_16BIT;\r\nbreak;\r\ncase 32:\r\npar->video |= PM3VideoControl_PIXELSIZE_32BIT;\r\nbreak;\r\ndefault:\r\nDPRINTK("Unsupported depth\n");\r\nbreak;\r\n}\r\ninfo->fix.visual =\r\n(bpp == 8) ? FB_VISUAL_PSEUDOCOLOR : FB_VISUAL_TRUECOLOR;\r\ninfo->fix.line_length = ((info->var.xres_virtual + 7) >> 3) * bpp;\r\npm3fb_clear_colormap(par, 0, 0, 0);\r\nPM3_WRITE_DAC_REG(par, PM3RD_CursorMode, 0);\r\npm3fb_init_engine(info);\r\npm3fb_write_mode(info);\r\nreturn 0;\r\n}\r\nstatic int pm3fb_setcolreg(unsigned regno, unsigned red, unsigned green,\r\nunsigned blue, unsigned transp,\r\nstruct fb_info *info)\r\n{\r\nstruct pm3_par *par = info->par;\r\nif (regno >= 256)\r\nreturn -EINVAL;\r\nif (info->var.grayscale)\r\nred = green = blue = (red * 77 + green * 151 + blue * 28) >> 8;\r\n#define CNVT_TOHW(val, width) ((((val) << (width)) + 0x7FFF - (val)) >> 16)\r\nred = CNVT_TOHW(red, info->var.red.length);\r\ngreen = CNVT_TOHW(green, info->var.green.length);\r\nblue = CNVT_TOHW(blue, info->var.blue.length);\r\ntransp = CNVT_TOHW(transp, info->var.transp.length);\r\n#undef CNVT_TOHW\r\nif (info->fix.visual == FB_VISUAL_TRUECOLOR ||\r\ninfo->fix.visual == FB_VISUAL_DIRECTCOLOR) {\r\nu32 v;\r\nif (regno >= 16)\r\nreturn -EINVAL;\r\nv = (red << info->var.red.offset) |\r\n(green << info->var.green.offset) |\r\n(blue << info->var.blue.offset) |\r\n(transp << info->var.transp.offset);\r\nswitch (info->var.bits_per_pixel) {\r\ncase 8:\r\nbreak;\r\ncase 16:\r\ncase 32:\r\n((u32 *)(info->pseudo_palette))[regno] = v;\r\nbreak;\r\n}\r\nreturn 0;\r\n} else if (info->fix.visual == FB_VISUAL_PSEUDOCOLOR)\r\npm3fb_set_color(par, regno, red, green, blue);\r\nreturn 0;\r\n}\r\nstatic int pm3fb_pan_display(struct fb_var_screeninfo *var,\r\nstruct fb_info *info)\r\n{\r\nstruct pm3_par *par = info->par;\r\nconst u32 xres = (info->var.xres + 31) & ~31;\r\npar->base = pm3fb_shift_bpp(info->var.bits_per_pixel,\r\n(var->yoffset * xres)\r\n+ var->xoffset);\r\nPM3_WAIT(par, 1);\r\nPM3_WRITE_REG(par, PM3ScreenBase, par->base);\r\nreturn 0;\r\n}\r\nstatic int pm3fb_blank(int blank_mode, struct fb_info *info)\r\n{\r\nstruct pm3_par *par = info->par;\r\nu32 video = par->video;\r\nvideo &= ~(PM3VideoControl_HSYNC_MASK |\r\nPM3VideoControl_VSYNC_MASK);\r\nvideo |= PM3VideoControl_HSYNC_ACTIVE_HIGH |\r\nPM3VideoControl_VSYNC_ACTIVE_HIGH;\r\nswitch (blank_mode) {\r\ncase FB_BLANK_UNBLANK:\r\nvideo |= PM3VideoControl_ENABLE;\r\nbreak;\r\ncase FB_BLANK_NORMAL:\r\nvideo &= ~PM3VideoControl_ENABLE;\r\nbreak;\r\ncase FB_BLANK_HSYNC_SUSPEND:\r\nvideo &= ~(PM3VideoControl_HSYNC_MASK |\r\nPM3VideoControl_BLANK_ACTIVE_LOW);\r\nbreak;\r\ncase FB_BLANK_VSYNC_SUSPEND:\r\nvideo &= ~(PM3VideoControl_VSYNC_MASK |\r\nPM3VideoControl_BLANK_ACTIVE_LOW);\r\nbreak;\r\ncase FB_BLANK_POWERDOWN:\r\nvideo &= ~(PM3VideoControl_HSYNC_MASK |\r\nPM3VideoControl_VSYNC_MASK |\r\nPM3VideoControl_BLANK_ACTIVE_LOW);\r\nbreak;\r\ndefault:\r\nDPRINTK("Unsupported blanking %d\n", blank_mode);\r\nreturn 1;\r\n}\r\nPM3_WAIT(par, 1);\r\nPM3_WRITE_REG(par, PM3VideoControl, video);\r\nreturn 0;\r\n}\r\nstatic unsigned long pm3fb_size_memory(struct pm3_par *par)\r\n{\r\nunsigned long memsize = 0;\r\nunsigned long tempBypass, i, temp1, temp2;\r\nunsigned char __iomem *screen_mem;\r\npm3fb_fix.smem_len = 64 * 1024l * 1024;\r\nif (!request_mem_region(pm3fb_fix.smem_start, pm3fb_fix.smem_len,\r\n"pm3fb smem")) {\r\nprintk(KERN_WARNING "pm3fb: Can't reserve smem.\n");\r\nreturn 0;\r\n}\r\nscreen_mem =\r\nioremap_nocache(pm3fb_fix.smem_start, pm3fb_fix.smem_len);\r\nif (!screen_mem) {\r\nprintk(KERN_WARNING "pm3fb: Can't ioremap smem area.\n");\r\nrelease_mem_region(pm3fb_fix.smem_start, pm3fb_fix.smem_len);\r\nreturn 0;\r\n}\r\ntempBypass = PM3_READ_REG(par, PM3MemBypassWriteMask);\r\nDPRINTK("PM3MemBypassWriteMask was: 0x%08lx\n", tempBypass);\r\nPM3_WAIT(par, 1);\r\nPM3_WRITE_REG(par, PM3MemBypassWriteMask, 0xFFFFFFFF);\r\nfor (i = 0; i < 32; i++) {\r\nfb_writel(i * 0x00345678,\r\n(screen_mem + (i * 1048576)));\r\nmb();\r\ntemp1 = fb_readl((screen_mem + (i * 1048576)));\r\nif (temp1 == (i * 0x00345678))\r\nmemsize = i;\r\nelse\r\nbreak;\r\n}\r\nDPRINTK("First detect pass already got %ld MB\n", memsize + 1);\r\nif (memsize + 1 == i) {\r\nfor (i = 0; i < 32; i++) {\r\nwritel(0x0000000, (screen_mem + (i * 1048576)));\r\n}\r\nwmb();\r\nfor (i = 32; i < 64; i++) {\r\nfb_writel(i * 0x00345678,\r\n(screen_mem + (i * 1048576)));\r\nmb();\r\ntemp1 =\r\nfb_readl((screen_mem + (i * 1048576)));\r\ntemp2 =\r\nfb_readl((screen_mem + ((i - 32) * 1048576)));\r\nif ((temp1 == (i * 0x00345678)) && (temp2 == 0))\r\nmemsize = i;\r\nelse\r\nbreak;\r\n}\r\n}\r\nDPRINTK("Second detect pass got %ld MB\n", memsize + 1);\r\nPM3_WAIT(par, 1);\r\nPM3_WRITE_REG(par, PM3MemBypassWriteMask, tempBypass);\r\niounmap(screen_mem);\r\nrelease_mem_region(pm3fb_fix.smem_start, pm3fb_fix.smem_len);\r\nmemsize = 1048576 * (memsize + 1);\r\nDPRINTK("Returning 0x%08lx bytes\n", memsize);\r\nreturn memsize;\r\n}\r\nstatic int pm3fb_probe(struct pci_dev *dev, const struct pci_device_id *ent)\r\n{\r\nstruct fb_info *info;\r\nstruct pm3_par *par;\r\nstruct device *device = &dev->dev;\r\nint err;\r\nint retval = -ENXIO;\r\nerr = pci_enable_device(dev);\r\nif (err) {\r\nprintk(KERN_WARNING "pm3fb: Can't enable PCI dev: %d\n", err);\r\nreturn err;\r\n}\r\ninfo = framebuffer_alloc(sizeof(struct pm3_par), device);\r\nif (!info)\r\nreturn -ENOMEM;\r\npar = info->par;\r\npm3fb_fix.mmio_start = pci_resource_start(dev, 0);\r\npm3fb_fix.mmio_len = PM3_REGS_SIZE;\r\n#if defined(__BIG_ENDIAN)\r\npm3fb_fix.mmio_start += PM3_REGS_SIZE;\r\nDPRINTK("Adjusting register base for big-endian.\n");\r\n#endif\r\nif (!request_mem_region(pm3fb_fix.mmio_start, pm3fb_fix.mmio_len,\r\n"pm3fb regbase")) {\r\nprintk(KERN_WARNING "pm3fb: Can't reserve regbase.\n");\r\ngoto err_exit_neither;\r\n}\r\npar->v_regs =\r\nioremap_nocache(pm3fb_fix.mmio_start, pm3fb_fix.mmio_len);\r\nif (!par->v_regs) {\r\nprintk(KERN_WARNING "pm3fb: Can't remap %s register area.\n",\r\npm3fb_fix.id);\r\nrelease_mem_region(pm3fb_fix.mmio_start, pm3fb_fix.mmio_len);\r\ngoto err_exit_neither;\r\n}\r\npm3fb_fix.smem_start = pci_resource_start(dev, 1);\r\npm3fb_fix.smem_len = pm3fb_size_memory(par);\r\nif (!pm3fb_fix.smem_len) {\r\nprintk(KERN_WARNING "pm3fb: Can't find memory on board.\n");\r\ngoto err_exit_mmio;\r\n}\r\nif (!request_mem_region(pm3fb_fix.smem_start, pm3fb_fix.smem_len,\r\n"pm3fb smem")) {\r\nprintk(KERN_WARNING "pm3fb: Can't reserve smem.\n");\r\ngoto err_exit_mmio;\r\n}\r\ninfo->screen_base =\r\nioremap_nocache(pm3fb_fix.smem_start, pm3fb_fix.smem_len);\r\nif (!info->screen_base) {\r\nprintk(KERN_WARNING "pm3fb: Can't ioremap smem area.\n");\r\nrelease_mem_region(pm3fb_fix.smem_start, pm3fb_fix.smem_len);\r\ngoto err_exit_mmio;\r\n}\r\ninfo->screen_size = pm3fb_fix.smem_len;\r\n#ifdef CONFIG_MTRR\r\nif (!nomtrr)\r\npar->mtrr_handle = mtrr_add(pm3fb_fix.smem_start,\r\npm3fb_fix.smem_len,\r\nMTRR_TYPE_WRCOMB, 1);\r\n#endif\r\ninfo->fbops = &pm3fb_ops;\r\npar->video = PM3_READ_REG(par, PM3VideoControl);\r\ninfo->fix = pm3fb_fix;\r\ninfo->pseudo_palette = par->palette;\r\ninfo->flags = FBINFO_DEFAULT |\r\nFBINFO_HWACCEL_XPAN |\r\nFBINFO_HWACCEL_YPAN |\r\nFBINFO_HWACCEL_COPYAREA |\r\nFBINFO_HWACCEL_IMAGEBLIT |\r\nFBINFO_HWACCEL_FILLRECT;\r\nif (noaccel) {\r\nprintk(KERN_DEBUG "disabling acceleration\n");\r\ninfo->flags |= FBINFO_HWACCEL_DISABLED;\r\n}\r\ninfo->pixmap.addr = kmalloc(PM3_PIXMAP_SIZE, GFP_KERNEL);\r\nif (!info->pixmap.addr) {\r\nretval = -ENOMEM;\r\ngoto err_exit_pixmap;\r\n}\r\ninfo->pixmap.size = PM3_PIXMAP_SIZE;\r\ninfo->pixmap.buf_align = 4;\r\ninfo->pixmap.scan_align = 4;\r\ninfo->pixmap.access_align = 32;\r\ninfo->pixmap.flags = FB_PIXMAP_SYSTEM;\r\nif (!mode_option)\r\nmode_option = "640x480@60";\r\nretval = fb_find_mode(&info->var, info, mode_option, NULL, 0, NULL, 8);\r\nif (!retval || retval == 4) {\r\nretval = -EINVAL;\r\ngoto err_exit_both;\r\n}\r\nif (fb_alloc_cmap(&info->cmap, 256, 0) < 0) {\r\nretval = -ENOMEM;\r\ngoto err_exit_both;\r\n}\r\npm3fb_check_var(&info->var, info);\r\nif (register_framebuffer(info) < 0) {\r\nretval = -EINVAL;\r\ngoto err_exit_all;\r\n}\r\nprintk(KERN_INFO "fb%d: %s frame buffer device\n", info->node,\r\ninfo->fix.id);\r\npci_set_drvdata(dev, info);\r\nreturn 0;\r\nerr_exit_all:\r\nfb_dealloc_cmap(&info->cmap);\r\nerr_exit_both:\r\nkfree(info->pixmap.addr);\r\nerr_exit_pixmap:\r\niounmap(info->screen_base);\r\nrelease_mem_region(pm3fb_fix.smem_start, pm3fb_fix.smem_len);\r\nerr_exit_mmio:\r\niounmap(par->v_regs);\r\nrelease_mem_region(pm3fb_fix.mmio_start, pm3fb_fix.mmio_len);\r\nerr_exit_neither:\r\nframebuffer_release(info);\r\nreturn retval;\r\n}\r\nstatic void pm3fb_remove(struct pci_dev *dev)\r\n{\r\nstruct fb_info *info = pci_get_drvdata(dev);\r\nif (info) {\r\nstruct fb_fix_screeninfo *fix = &info->fix;\r\nstruct pm3_par *par = info->par;\r\nunregister_framebuffer(info);\r\nfb_dealloc_cmap(&info->cmap);\r\n#ifdef CONFIG_MTRR\r\nif (par->mtrr_handle >= 0)\r\nmtrr_del(par->mtrr_handle, info->fix.smem_start,\r\ninfo->fix.smem_len);\r\n#endif\r\niounmap(info->screen_base);\r\nrelease_mem_region(fix->smem_start, fix->smem_len);\r\niounmap(par->v_regs);\r\nrelease_mem_region(fix->mmio_start, fix->mmio_len);\r\npci_set_drvdata(dev, NULL);\r\nkfree(info->pixmap.addr);\r\nframebuffer_release(info);\r\n}\r\n}\r\nstatic int __init pm3fb_setup(char *options)\r\n{\r\nchar *this_opt;\r\nif (!options || !*options)\r\nreturn 0;\r\nwhile ((this_opt = strsep(&options, ",")) != NULL) {\r\nif (!*this_opt)\r\ncontinue;\r\nelse if (!strncmp(this_opt, "noaccel", 7))\r\nnoaccel = 1;\r\nelse if (!strncmp(this_opt, "hwcursor=", 9))\r\nhwcursor = simple_strtoul(this_opt + 9, NULL, 0);\r\n#ifdef CONFIG_MTRR\r\nelse if (!strncmp(this_opt, "nomtrr", 6))\r\nnomtrr = 1;\r\n#endif\r\nelse\r\nmode_option = this_opt;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init pm3fb_init(void)\r\n{\r\n#ifndef MODULE\r\nchar *option = NULL;\r\nif (fb_get_options("pm3fb", &option))\r\nreturn -ENODEV;\r\npm3fb_setup(option);\r\n#endif\r\nreturn pci_register_driver(&pm3fb_driver);\r\n}\r\nstatic void __exit pm3fb_exit(void)\r\n{\r\npci_unregister_driver(&pm3fb_driver);\r\n}
