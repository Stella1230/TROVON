static int zfcp_scsi_change_queue_depth(struct scsi_device *sdev, int depth,\r\nint reason)\r\n{\r\nswitch (reason) {\r\ncase SCSI_QDEPTH_DEFAULT:\r\nscsi_adjust_queue_depth(sdev, scsi_get_tag_type(sdev), depth);\r\nbreak;\r\ncase SCSI_QDEPTH_QFULL:\r\nscsi_track_queue_full(sdev, depth);\r\nbreak;\r\ncase SCSI_QDEPTH_RAMP_UP:\r\nscsi_adjust_queue_depth(sdev, scsi_get_tag_type(sdev), depth);\r\nbreak;\r\ndefault:\r\nreturn -EOPNOTSUPP;\r\n}\r\nreturn sdev->queue_depth;\r\n}\r\nstatic void zfcp_scsi_slave_destroy(struct scsi_device *sdev)\r\n{\r\nstruct zfcp_scsi_dev *zfcp_sdev = sdev_to_zfcp(sdev);\r\nif (!zfcp_sdev->port)\r\nreturn;\r\nzfcp_erp_lun_shutdown_wait(sdev, "scssd_1");\r\nput_device(&zfcp_sdev->port->dev);\r\n}\r\nstatic int zfcp_scsi_slave_configure(struct scsi_device *sdp)\r\n{\r\nif (sdp->tagged_supported)\r\nscsi_adjust_queue_depth(sdp, MSG_SIMPLE_TAG, default_depth);\r\nelse\r\nscsi_adjust_queue_depth(sdp, 0, 1);\r\nreturn 0;\r\n}\r\nstatic void zfcp_scsi_command_fail(struct scsi_cmnd *scpnt, int result)\r\n{\r\nset_host_byte(scpnt, result);\r\nzfcp_dbf_scsi_fail_send(scpnt);\r\nscpnt->scsi_done(scpnt);\r\n}\r\nstatic\r\nint zfcp_scsi_queuecommand(struct Scsi_Host *shost, struct scsi_cmnd *scpnt)\r\n{\r\nstruct zfcp_scsi_dev *zfcp_sdev = sdev_to_zfcp(scpnt->device);\r\nstruct fc_rport *rport = starget_to_rport(scsi_target(scpnt->device));\r\nint status, scsi_result, ret;\r\nscpnt->result = 0;\r\nscpnt->host_scribble = NULL;\r\nscsi_result = fc_remote_port_chkready(rport);\r\nif (unlikely(scsi_result)) {\r\nscpnt->result = scsi_result;\r\nzfcp_dbf_scsi_fail_send(scpnt);\r\nscpnt->scsi_done(scpnt);\r\nreturn 0;\r\n}\r\nstatus = atomic_read(&zfcp_sdev->status);\r\nif (unlikely(status & ZFCP_STATUS_COMMON_ERP_FAILED) &&\r\n!(atomic_read(&zfcp_sdev->port->status) &\r\nZFCP_STATUS_COMMON_ERP_FAILED)) {\r\nzfcp_scsi_command_fail(scpnt, DID_ERROR);\r\nreturn 0;\r\n}\r\nif (unlikely(!(status & ZFCP_STATUS_COMMON_UNBLOCKED))) {\r\nzfcp_scsi_command_fail(scpnt, DID_IMM_RETRY);\r\nreturn 0;\r\n}\r\nret = zfcp_fsf_fcp_cmnd(scpnt);\r\nif (unlikely(ret == -EBUSY))\r\nreturn SCSI_MLQUEUE_DEVICE_BUSY;\r\nelse if (unlikely(ret < 0))\r\nreturn SCSI_MLQUEUE_HOST_BUSY;\r\nreturn ret;\r\n}\r\nstatic int zfcp_scsi_slave_alloc(struct scsi_device *sdev)\r\n{\r\nstruct fc_rport *rport = starget_to_rport(scsi_target(sdev));\r\nstruct zfcp_adapter *adapter =\r\n(struct zfcp_adapter *) sdev->host->hostdata[0];\r\nstruct zfcp_scsi_dev *zfcp_sdev = sdev_to_zfcp(sdev);\r\nstruct zfcp_port *port;\r\nstruct zfcp_unit *unit;\r\nint npiv = adapter->connection_features & FSF_FEATURE_NPIV_MODE;\r\nport = zfcp_get_port_by_wwpn(adapter, rport->port_name);\r\nif (!port)\r\nreturn -ENXIO;\r\nunit = zfcp_unit_find(port, zfcp_scsi_dev_lun(sdev));\r\nif (unit)\r\nput_device(&unit->dev);\r\nif (!unit && !(allow_lun_scan && npiv)) {\r\nput_device(&port->dev);\r\nreturn -ENXIO;\r\n}\r\nzfcp_sdev->port = port;\r\nzfcp_sdev->latencies.write.channel.min = 0xFFFFFFFF;\r\nzfcp_sdev->latencies.write.fabric.min = 0xFFFFFFFF;\r\nzfcp_sdev->latencies.read.channel.min = 0xFFFFFFFF;\r\nzfcp_sdev->latencies.read.fabric.min = 0xFFFFFFFF;\r\nzfcp_sdev->latencies.cmd.channel.min = 0xFFFFFFFF;\r\nzfcp_sdev->latencies.cmd.fabric.min = 0xFFFFFFFF;\r\nspin_lock_init(&zfcp_sdev->latencies.lock);\r\nzfcp_erp_set_lun_status(sdev, ZFCP_STATUS_COMMON_RUNNING);\r\nzfcp_erp_lun_reopen(sdev, 0, "scsla_1");\r\nzfcp_erp_wait(port->adapter);\r\nreturn 0;\r\n}\r\nstatic int zfcp_scsi_eh_abort_handler(struct scsi_cmnd *scpnt)\r\n{\r\nstruct Scsi_Host *scsi_host = scpnt->device->host;\r\nstruct zfcp_adapter *adapter =\r\n(struct zfcp_adapter *) scsi_host->hostdata[0];\r\nstruct zfcp_fsf_req *old_req, *abrt_req;\r\nunsigned long flags;\r\nunsigned long old_reqid = (unsigned long) scpnt->host_scribble;\r\nint retval = SUCCESS, ret;\r\nint retry = 3;\r\nchar *dbf_tag;\r\nwrite_lock_irqsave(&adapter->abort_lock, flags);\r\nold_req = zfcp_reqlist_find(adapter->req_list, old_reqid);\r\nif (!old_req) {\r\nwrite_unlock_irqrestore(&adapter->abort_lock, flags);\r\nzfcp_dbf_scsi_abort("abrt_or", scpnt, NULL);\r\nreturn FAILED;\r\n}\r\nold_req->data = NULL;\r\nwrite_unlock_irqrestore(&adapter->abort_lock, flags);\r\nwhile (retry--) {\r\nabrt_req = zfcp_fsf_abort_fcp_cmnd(scpnt);\r\nif (abrt_req)\r\nbreak;\r\nzfcp_erp_wait(adapter);\r\nret = fc_block_scsi_eh(scpnt);\r\nif (ret) {\r\nzfcp_dbf_scsi_abort("abrt_bl", scpnt, NULL);\r\nreturn ret;\r\n}\r\nif (!(atomic_read(&adapter->status) &\r\nZFCP_STATUS_COMMON_RUNNING)) {\r\nzfcp_dbf_scsi_abort("abrt_ru", scpnt, NULL);\r\nreturn SUCCESS;\r\n}\r\n}\r\nif (!abrt_req) {\r\nzfcp_dbf_scsi_abort("abrt_ar", scpnt, NULL);\r\nreturn FAILED;\r\n}\r\nwait_for_completion(&abrt_req->completion);\r\nif (abrt_req->status & ZFCP_STATUS_FSFREQ_ABORTSUCCEEDED)\r\ndbf_tag = "abrt_ok";\r\nelse if (abrt_req->status & ZFCP_STATUS_FSFREQ_ABORTNOTNEEDED)\r\ndbf_tag = "abrt_nn";\r\nelse {\r\ndbf_tag = "abrt_fa";\r\nretval = FAILED;\r\n}\r\nzfcp_dbf_scsi_abort(dbf_tag, scpnt, abrt_req);\r\nzfcp_fsf_req_free(abrt_req);\r\nreturn retval;\r\n}\r\nstatic int zfcp_task_mgmt_function(struct scsi_cmnd *scpnt, u8 tm_flags)\r\n{\r\nstruct zfcp_scsi_dev *zfcp_sdev = sdev_to_zfcp(scpnt->device);\r\nstruct zfcp_adapter *adapter = zfcp_sdev->port->adapter;\r\nstruct zfcp_fsf_req *fsf_req = NULL;\r\nint retval = SUCCESS, ret;\r\nint retry = 3;\r\nwhile (retry--) {\r\nfsf_req = zfcp_fsf_fcp_task_mgmt(scpnt, tm_flags);\r\nif (fsf_req)\r\nbreak;\r\nzfcp_erp_wait(adapter);\r\nret = fc_block_scsi_eh(scpnt);\r\nif (ret)\r\nreturn ret;\r\nif (!(atomic_read(&adapter->status) &\r\nZFCP_STATUS_COMMON_RUNNING)) {\r\nzfcp_dbf_scsi_devreset("nres", scpnt, tm_flags);\r\nreturn SUCCESS;\r\n}\r\n}\r\nif (!fsf_req)\r\nreturn FAILED;\r\nwait_for_completion(&fsf_req->completion);\r\nif (fsf_req->status & ZFCP_STATUS_FSFREQ_TMFUNCFAILED) {\r\nzfcp_dbf_scsi_devreset("fail", scpnt, tm_flags);\r\nretval = FAILED;\r\n} else\r\nzfcp_dbf_scsi_devreset("okay", scpnt, tm_flags);\r\nzfcp_fsf_req_free(fsf_req);\r\nreturn retval;\r\n}\r\nstatic int zfcp_scsi_eh_device_reset_handler(struct scsi_cmnd *scpnt)\r\n{\r\nreturn zfcp_task_mgmt_function(scpnt, FCP_TMF_LUN_RESET);\r\n}\r\nstatic int zfcp_scsi_eh_target_reset_handler(struct scsi_cmnd *scpnt)\r\n{\r\nreturn zfcp_task_mgmt_function(scpnt, FCP_TMF_TGT_RESET);\r\n}\r\nstatic int zfcp_scsi_eh_host_reset_handler(struct scsi_cmnd *scpnt)\r\n{\r\nstruct zfcp_scsi_dev *zfcp_sdev = sdev_to_zfcp(scpnt->device);\r\nstruct zfcp_adapter *adapter = zfcp_sdev->port->adapter;\r\nint ret;\r\nzfcp_erp_adapter_reopen(adapter, 0, "schrh_1");\r\nzfcp_erp_wait(adapter);\r\nret = fc_block_scsi_eh(scpnt);\r\nif (ret)\r\nreturn ret;\r\nreturn SUCCESS;\r\n}\r\nint zfcp_scsi_adapter_register(struct zfcp_adapter *adapter)\r\n{\r\nstruct ccw_dev_id dev_id;\r\nif (adapter->scsi_host)\r\nreturn 0;\r\nccw_device_get_id(adapter->ccw_device, &dev_id);\r\nadapter->scsi_host = scsi_host_alloc(&zfcp_scsi_host_template,\r\nsizeof (struct zfcp_adapter *));\r\nif (!adapter->scsi_host) {\r\ndev_err(&adapter->ccw_device->dev,\r\n"Registering the FCP device with the "\r\n"SCSI stack failed\n");\r\nreturn -EIO;\r\n}\r\nadapter->scsi_host->max_id = 511;\r\nadapter->scsi_host->max_lun = 0xFFFFFFFF;\r\nadapter->scsi_host->max_channel = 0;\r\nadapter->scsi_host->unique_id = dev_id.devno;\r\nadapter->scsi_host->max_cmd_len = 16;\r\nadapter->scsi_host->transportt = zfcp_scsi_transport_template;\r\nadapter->scsi_host->hostdata[0] = (unsigned long) adapter;\r\nif (scsi_add_host(adapter->scsi_host, &adapter->ccw_device->dev)) {\r\nscsi_host_put(adapter->scsi_host);\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nvoid zfcp_scsi_adapter_unregister(struct zfcp_adapter *adapter)\r\n{\r\nstruct Scsi_Host *shost;\r\nstruct zfcp_port *port;\r\nshost = adapter->scsi_host;\r\nif (!shost)\r\nreturn;\r\nread_lock_irq(&adapter->port_list_lock);\r\nlist_for_each_entry(port, &adapter->port_list, list)\r\nport->rport = NULL;\r\nread_unlock_irq(&adapter->port_list_lock);\r\nfc_remove_host(shost);\r\nscsi_remove_host(shost);\r\nscsi_host_put(shost);\r\nadapter->scsi_host = NULL;\r\n}\r\nstatic struct fc_host_statistics*\r\nzfcp_init_fc_host_stats(struct zfcp_adapter *adapter)\r\n{\r\nstruct fc_host_statistics *fc_stats;\r\nif (!adapter->fc_stats) {\r\nfc_stats = kmalloc(sizeof(*fc_stats), GFP_KERNEL);\r\nif (!fc_stats)\r\nreturn NULL;\r\nadapter->fc_stats = fc_stats;\r\n}\r\nmemset(adapter->fc_stats, 0, sizeof(*adapter->fc_stats));\r\nreturn adapter->fc_stats;\r\n}\r\nstatic void zfcp_adjust_fc_host_stats(struct fc_host_statistics *fc_stats,\r\nstruct fsf_qtcb_bottom_port *data,\r\nstruct fsf_qtcb_bottom_port *old)\r\n{\r\nfc_stats->seconds_since_last_reset =\r\ndata->seconds_since_last_reset - old->seconds_since_last_reset;\r\nfc_stats->tx_frames = data->tx_frames - old->tx_frames;\r\nfc_stats->tx_words = data->tx_words - old->tx_words;\r\nfc_stats->rx_frames = data->rx_frames - old->rx_frames;\r\nfc_stats->rx_words = data->rx_words - old->rx_words;\r\nfc_stats->lip_count = data->lip - old->lip;\r\nfc_stats->nos_count = data->nos - old->nos;\r\nfc_stats->error_frames = data->error_frames - old->error_frames;\r\nfc_stats->dumped_frames = data->dumped_frames - old->dumped_frames;\r\nfc_stats->link_failure_count = data->link_failure - old->link_failure;\r\nfc_stats->loss_of_sync_count = data->loss_of_sync - old->loss_of_sync;\r\nfc_stats->loss_of_signal_count =\r\ndata->loss_of_signal - old->loss_of_signal;\r\nfc_stats->prim_seq_protocol_err_count =\r\ndata->psp_error_counts - old->psp_error_counts;\r\nfc_stats->invalid_tx_word_count =\r\ndata->invalid_tx_words - old->invalid_tx_words;\r\nfc_stats->invalid_crc_count = data->invalid_crcs - old->invalid_crcs;\r\nfc_stats->fcp_input_requests =\r\ndata->input_requests - old->input_requests;\r\nfc_stats->fcp_output_requests =\r\ndata->output_requests - old->output_requests;\r\nfc_stats->fcp_control_requests =\r\ndata->control_requests - old->control_requests;\r\nfc_stats->fcp_input_megabytes = data->input_mb - old->input_mb;\r\nfc_stats->fcp_output_megabytes = data->output_mb - old->output_mb;\r\n}\r\nstatic void zfcp_set_fc_host_stats(struct fc_host_statistics *fc_stats,\r\nstruct fsf_qtcb_bottom_port *data)\r\n{\r\nfc_stats->seconds_since_last_reset = data->seconds_since_last_reset;\r\nfc_stats->tx_frames = data->tx_frames;\r\nfc_stats->tx_words = data->tx_words;\r\nfc_stats->rx_frames = data->rx_frames;\r\nfc_stats->rx_words = data->rx_words;\r\nfc_stats->lip_count = data->lip;\r\nfc_stats->nos_count = data->nos;\r\nfc_stats->error_frames = data->error_frames;\r\nfc_stats->dumped_frames = data->dumped_frames;\r\nfc_stats->link_failure_count = data->link_failure;\r\nfc_stats->loss_of_sync_count = data->loss_of_sync;\r\nfc_stats->loss_of_signal_count = data->loss_of_signal;\r\nfc_stats->prim_seq_protocol_err_count = data->psp_error_counts;\r\nfc_stats->invalid_tx_word_count = data->invalid_tx_words;\r\nfc_stats->invalid_crc_count = data->invalid_crcs;\r\nfc_stats->fcp_input_requests = data->input_requests;\r\nfc_stats->fcp_output_requests = data->output_requests;\r\nfc_stats->fcp_control_requests = data->control_requests;\r\nfc_stats->fcp_input_megabytes = data->input_mb;\r\nfc_stats->fcp_output_megabytes = data->output_mb;\r\n}\r\nstatic struct fc_host_statistics *zfcp_get_fc_host_stats(struct Scsi_Host *host)\r\n{\r\nstruct zfcp_adapter *adapter;\r\nstruct fc_host_statistics *fc_stats;\r\nstruct fsf_qtcb_bottom_port *data;\r\nint ret;\r\nadapter = (struct zfcp_adapter *)host->hostdata[0];\r\nfc_stats = zfcp_init_fc_host_stats(adapter);\r\nif (!fc_stats)\r\nreturn NULL;\r\ndata = kzalloc(sizeof(*data), GFP_KERNEL);\r\nif (!data)\r\nreturn NULL;\r\nret = zfcp_fsf_exchange_port_data_sync(adapter->qdio, data);\r\nif (ret) {\r\nkfree(data);\r\nreturn NULL;\r\n}\r\nif (adapter->stats_reset &&\r\n((jiffies/HZ - adapter->stats_reset) <\r\ndata->seconds_since_last_reset))\r\nzfcp_adjust_fc_host_stats(fc_stats, data,\r\nadapter->stats_reset_data);\r\nelse\r\nzfcp_set_fc_host_stats(fc_stats, data);\r\nkfree(data);\r\nreturn fc_stats;\r\n}\r\nstatic void zfcp_reset_fc_host_stats(struct Scsi_Host *shost)\r\n{\r\nstruct zfcp_adapter *adapter;\r\nstruct fsf_qtcb_bottom_port *data;\r\nint ret;\r\nadapter = (struct zfcp_adapter *)shost->hostdata[0];\r\ndata = kzalloc(sizeof(*data), GFP_KERNEL);\r\nif (!data)\r\nreturn;\r\nret = zfcp_fsf_exchange_port_data_sync(adapter->qdio, data);\r\nif (ret)\r\nkfree(data);\r\nelse {\r\nadapter->stats_reset = jiffies/HZ;\r\nkfree(adapter->stats_reset_data);\r\nadapter->stats_reset_data = data;\r\n}\r\n}\r\nstatic void zfcp_get_host_port_state(struct Scsi_Host *shost)\r\n{\r\nstruct zfcp_adapter *adapter =\r\n(struct zfcp_adapter *)shost->hostdata[0];\r\nint status = atomic_read(&adapter->status);\r\nif ((status & ZFCP_STATUS_COMMON_RUNNING) &&\r\n!(status & ZFCP_STATUS_ADAPTER_LINK_UNPLUGGED))\r\nfc_host_port_state(shost) = FC_PORTSTATE_ONLINE;\r\nelse if (status & ZFCP_STATUS_ADAPTER_LINK_UNPLUGGED)\r\nfc_host_port_state(shost) = FC_PORTSTATE_LINKDOWN;\r\nelse if (status & ZFCP_STATUS_COMMON_ERP_FAILED)\r\nfc_host_port_state(shost) = FC_PORTSTATE_ERROR;\r\nelse\r\nfc_host_port_state(shost) = FC_PORTSTATE_UNKNOWN;\r\n}\r\nstatic void zfcp_set_rport_dev_loss_tmo(struct fc_rport *rport, u32 timeout)\r\n{\r\nrport->dev_loss_tmo = timeout;\r\n}\r\nstatic void zfcp_scsi_terminate_rport_io(struct fc_rport *rport)\r\n{\r\nstruct zfcp_port *port;\r\nstruct Scsi_Host *shost = rport_to_shost(rport);\r\nstruct zfcp_adapter *adapter =\r\n(struct zfcp_adapter *)shost->hostdata[0];\r\nport = zfcp_get_port_by_wwpn(adapter, rport->port_name);\r\nif (port) {\r\nzfcp_erp_port_forced_reopen(port, 0, "sctrpi1");\r\nput_device(&port->dev);\r\n}\r\n}\r\nstatic void zfcp_scsi_rport_register(struct zfcp_port *port)\r\n{\r\nstruct fc_rport_identifiers ids;\r\nstruct fc_rport *rport;\r\nif (port->rport)\r\nreturn;\r\nids.node_name = port->wwnn;\r\nids.port_name = port->wwpn;\r\nids.port_id = port->d_id;\r\nids.roles = FC_RPORT_ROLE_FCP_TARGET;\r\nrport = fc_remote_port_add(port->adapter->scsi_host, 0, &ids);\r\nif (!rport) {\r\ndev_err(&port->adapter->ccw_device->dev,\r\n"Registering port 0x%016Lx failed\n",\r\n(unsigned long long)port->wwpn);\r\nreturn;\r\n}\r\nrport->maxframe_size = port->maxframe_size;\r\nrport->supported_classes = port->supported_classes;\r\nport->rport = rport;\r\nport->starget_id = rport->scsi_target_id;\r\nzfcp_unit_queue_scsi_scan(port);\r\n}\r\nstatic void zfcp_scsi_rport_block(struct zfcp_port *port)\r\n{\r\nstruct fc_rport *rport = port->rport;\r\nif (rport) {\r\nfc_remote_port_delete(rport);\r\nport->rport = NULL;\r\n}\r\n}\r\nvoid zfcp_scsi_schedule_rport_register(struct zfcp_port *port)\r\n{\r\nget_device(&port->dev);\r\nport->rport_task = RPORT_ADD;\r\nif (!queue_work(port->adapter->work_queue, &port->rport_work))\r\nput_device(&port->dev);\r\n}\r\nvoid zfcp_scsi_schedule_rport_block(struct zfcp_port *port)\r\n{\r\nget_device(&port->dev);\r\nport->rport_task = RPORT_DEL;\r\nif (port->rport && queue_work(port->adapter->work_queue,\r\n&port->rport_work))\r\nreturn;\r\nput_device(&port->dev);\r\n}\r\nvoid zfcp_scsi_schedule_rports_block(struct zfcp_adapter *adapter)\r\n{\r\nunsigned long flags;\r\nstruct zfcp_port *port;\r\nread_lock_irqsave(&adapter->port_list_lock, flags);\r\nlist_for_each_entry(port, &adapter->port_list, list)\r\nzfcp_scsi_schedule_rport_block(port);\r\nread_unlock_irqrestore(&adapter->port_list_lock, flags);\r\n}\r\nvoid zfcp_scsi_rport_work(struct work_struct *work)\r\n{\r\nstruct zfcp_port *port = container_of(work, struct zfcp_port,\r\nrport_work);\r\nwhile (port->rport_task) {\r\nif (port->rport_task == RPORT_ADD) {\r\nport->rport_task = RPORT_NONE;\r\nzfcp_scsi_rport_register(port);\r\n} else {\r\nport->rport_task = RPORT_NONE;\r\nzfcp_scsi_rport_block(port);\r\n}\r\n}\r\nput_device(&port->dev);\r\n}\r\nvoid zfcp_scsi_set_prot(struct zfcp_adapter *adapter)\r\n{\r\nunsigned int mask = 0;\r\nunsigned int data_div;\r\nstruct Scsi_Host *shost = adapter->scsi_host;\r\ndata_div = atomic_read(&adapter->status) &\r\nZFCP_STATUS_ADAPTER_DATA_DIV_ENABLED;\r\nif (enable_dif &&\r\nadapter->adapter_features & FSF_FEATURE_DIF_PROT_TYPE1)\r\nmask |= SHOST_DIF_TYPE1_PROTECTION;\r\nif (enable_dif && data_div &&\r\nadapter->adapter_features & FSF_FEATURE_DIX_PROT_TCPIP) {\r\nmask |= SHOST_DIX_TYPE1_PROTECTION;\r\nscsi_host_set_guard(shost, SHOST_DIX_GUARD_IP);\r\nshost->sg_prot_tablesize = adapter->qdio->max_sbale_per_req / 2;\r\nshost->sg_tablesize = adapter->qdio->max_sbale_per_req / 2;\r\nshost->max_sectors = shost->sg_tablesize * 8;\r\n}\r\nscsi_host_set_prot(shost, mask);\r\n}\r\nvoid zfcp_scsi_dif_sense_error(struct scsi_cmnd *scmd, int ascq)\r\n{\r\nscsi_build_sense_buffer(1, scmd->sense_buffer,\r\nILLEGAL_REQUEST, 0x10, ascq);\r\nset_driver_byte(scmd, DRIVER_SENSE);\r\nscmd->result |= SAM_STAT_CHECK_CONDITION;\r\nset_host_byte(scmd, DID_SOFT_ERROR);\r\n}
