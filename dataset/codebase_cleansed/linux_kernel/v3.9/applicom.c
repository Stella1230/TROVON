static int ac_register_board(unsigned long physloc, void __iomem *loc,\r\nunsigned char boardno)\r\n{\r\nvolatile unsigned char byte_reset_it;\r\nif((readb(loc + CONF_END_TEST) != 0x00) ||\r\n(readb(loc + CONF_END_TEST + 1) != 0x55) ||\r\n(readb(loc + CONF_END_TEST + 2) != 0xAA) ||\r\n(readb(loc + CONF_END_TEST + 3) != 0xFF))\r\nreturn 0;\r\nif (!boardno)\r\nboardno = readb(loc + NUMCARD_OWNER_TO_PC);\r\nif (!boardno || boardno > MAX_BOARD) {\r\nprintk(KERN_WARNING "Board #%d (at 0x%lx) is out of range (1 <= x <= %d).\n",\r\nboardno, physloc, MAX_BOARD);\r\nreturn 0;\r\n}\r\nif (apbs[boardno - 1].RamIO) {\r\nprintk(KERN_WARNING "Board #%d (at 0x%lx) conflicts with previous board #%d (at 0x%lx)\n",\r\nboardno, physloc, boardno, apbs[boardno-1].PhysIO);\r\nreturn 0;\r\n}\r\nboardno--;\r\napbs[boardno].PhysIO = physloc;\r\napbs[boardno].RamIO = loc;\r\ninit_waitqueue_head(&apbs[boardno].FlagSleepSend);\r\nspin_lock_init(&apbs[boardno].mutex);\r\nbyte_reset_it = readb(loc + RAM_IT_TO_PC);\r\nnumboards++;\r\nreturn boardno + 1;\r\n}\r\nstatic void __exit applicom_exit(void)\r\n{\r\nunsigned int i;\r\nmisc_deregister(&ac_miscdev);\r\nfor (i = 0; i < MAX_BOARD; i++) {\r\nif (!apbs[i].RamIO)\r\ncontinue;\r\nif (apbs[i].irq)\r\nfree_irq(apbs[i].irq, &dummy);\r\niounmap(apbs[i].RamIO);\r\n}\r\n}\r\nstatic int __init applicom_init(void)\r\n{\r\nint i, numisa = 0;\r\nstruct pci_dev *dev = NULL;\r\nvoid __iomem *RamIO;\r\nint boardno, ret;\r\nprintk(KERN_INFO "Applicom driver: $Id: ac.c,v 1.30 2000/03/22 16:03:57 dwmw2 Exp $\n");\r\nwhile ( (dev = pci_get_class(PCI_CLASS_OTHERS << 16, dev))) {\r\nif (!pci_match_id(applicom_pci_tbl, dev))\r\ncontinue;\r\nif (pci_enable_device(dev))\r\nreturn -EIO;\r\nRamIO = ioremap_nocache(pci_resource_start(dev, 0), LEN_RAM_IO);\r\nif (!RamIO) {\r\nprintk(KERN_INFO "ac.o: Failed to ioremap PCI memory "\r\n"space at 0x%llx\n",\r\n(unsigned long long)pci_resource_start(dev, 0));\r\npci_disable_device(dev);\r\nreturn -EIO;\r\n}\r\nprintk(KERN_INFO "Applicom %s found at mem 0x%llx, irq %d\n",\r\napplicom_pci_devnames[dev->device-1],\r\n(unsigned long long)pci_resource_start(dev, 0),\r\ndev->irq);\r\nboardno = ac_register_board(pci_resource_start(dev, 0),\r\nRamIO, 0);\r\nif (!boardno) {\r\nprintk(KERN_INFO "ac.o: PCI Applicom device doesn't have correct signature.\n");\r\niounmap(RamIO);\r\npci_disable_device(dev);\r\ncontinue;\r\n}\r\nif (request_irq(dev->irq, &ac_interrupt, IRQF_SHARED, "Applicom PCI", &dummy)) {\r\nprintk(KERN_INFO "Could not allocate IRQ %d for PCI Applicom device.\n", dev->irq);\r\niounmap(RamIO);\r\npci_disable_device(dev);\r\napbs[boardno - 1].RamIO = NULL;\r\ncontinue;\r\n}\r\nwriteb(0x40, apbs[boardno - 1].RamIO + RAM_IT_FROM_PC);\r\napbs[boardno - 1].irq = dev->irq;\r\n}\r\nif (!mem || !irq) {\r\nif (numboards)\r\ngoto fin;\r\nelse {\r\nprintk(KERN_INFO "ac.o: No PCI boards found.\n");\r\nprintk(KERN_INFO "ac.o: For an ISA board you must supply memory and irq parameters.\n");\r\nreturn -ENXIO;\r\n}\r\n}\r\nfor (i = 0; i < MAX_ISA_BOARD; i++) {\r\nRamIO = ioremap_nocache(mem + (LEN_RAM_IO * i), LEN_RAM_IO);\r\nif (!RamIO) {\r\nprintk(KERN_INFO "ac.o: Failed to ioremap the ISA card's memory space (slot #%d)\n", i + 1);\r\ncontinue;\r\n}\r\nif (!(boardno = ac_register_board((unsigned long)mem+ (LEN_RAM_IO*i),\r\nRamIO,i+1))) {\r\niounmap(RamIO);\r\ncontinue;\r\n}\r\nprintk(KERN_NOTICE "Applicom ISA card found at mem 0x%lx, irq %d\n", mem + (LEN_RAM_IO*i), irq);\r\nif (!numisa) {\r\nif (request_irq(irq, &ac_interrupt, IRQF_SHARED, "Applicom ISA", &dummy)) {\r\nprintk(KERN_WARNING "Could not allocate IRQ %d for ISA Applicom device.\n", irq);\r\niounmap(RamIO);\r\napbs[boardno - 1].RamIO = NULL;\r\n}\r\nelse\r\napbs[boardno - 1].irq = irq;\r\n}\r\nelse\r\napbs[boardno - 1].irq = 0;\r\nnumisa++;\r\n}\r\nif (!numisa)\r\nprintk(KERN_WARNING "ac.o: No valid ISA Applicom boards found "\r\n"at mem 0x%lx\n", mem);\r\nfin:\r\ninit_waitqueue_head(&FlagSleepRec);\r\nWriteErrorCount = 0;\r\nReadErrorCount = 0;\r\nDeviceErrorCount = 0;\r\nif (numboards) {\r\nret = misc_register(&ac_miscdev);\r\nif (ret) {\r\nprintk(KERN_WARNING "ac.o: Unable to register misc device\n");\r\ngoto out;\r\n}\r\nfor (i = 0; i < MAX_BOARD; i++) {\r\nint serial;\r\nchar boardname[(SERIAL_NUMBER - TYPE_CARD) + 1];\r\nif (!apbs[i].RamIO)\r\ncontinue;\r\nfor (serial = 0; serial < SERIAL_NUMBER - TYPE_CARD; serial++)\r\nboardname[serial] = readb(apbs[i].RamIO + TYPE_CARD + serial);\r\nboardname[serial] = 0;\r\nprintk(KERN_INFO "Applicom board %d: %s, PROM V%d.%d",\r\ni+1, boardname,\r\n(int)(readb(apbs[i].RamIO + VERS) >> 4),\r\n(int)(readb(apbs[i].RamIO + VERS) & 0xF));\r\nserial = (readb(apbs[i].RamIO + SERIAL_NUMBER) << 16) +\r\n(readb(apbs[i].RamIO + SERIAL_NUMBER + 1) << 8) +\r\n(readb(apbs[i].RamIO + SERIAL_NUMBER + 2) );\r\nif (serial != 0)\r\nprintk(" S/N %d\n", serial);\r\nelse\r\nprintk("\n");\r\n}\r\nreturn 0;\r\n}\r\nelse\r\nreturn -ENXIO;\r\nout:\r\nfor (i = 0; i < MAX_BOARD; i++) {\r\nif (!apbs[i].RamIO)\r\ncontinue;\r\nif (apbs[i].irq)\r\nfree_irq(apbs[i].irq, &dummy);\r\niounmap(apbs[i].RamIO);\r\n}\r\npci_disable_device(dev);\r\nreturn ret;\r\n}\r\nstatic ssize_t ac_write(struct file *file, const char __user *buf, size_t count, loff_t * ppos)\r\n{\r\nunsigned int NumCard;\r\nunsigned int IndexCard;\r\nunsigned char TicCard;\r\nunsigned long flags;\r\nstruct st_ram_io st_loc;\r\nstruct mailbox tmpmailbox;\r\n#ifdef DEBUG\r\nint c;\r\n#endif\r\nDECLARE_WAITQUEUE(wait, current);\r\nif (count != sizeof(struct st_ram_io) + sizeof(struct mailbox)) {\r\nstatic int warncount = 5;\r\nif (warncount) {\r\nprintk(KERN_INFO "Hmmm. write() of Applicom card, length %zd != expected %zd\n",\r\ncount, sizeof(struct st_ram_io) + sizeof(struct mailbox));\r\nwarncount--;\r\n}\r\nreturn -EINVAL;\r\n}\r\nif(copy_from_user(&st_loc, buf, sizeof(struct st_ram_io)))\r\nreturn -EFAULT;\r\nif(copy_from_user(&tmpmailbox, &buf[sizeof(struct st_ram_io)],\r\nsizeof(struct mailbox)))\r\nreturn -EFAULT;\r\nNumCard = st_loc.num_card;\r\nTicCard = st_loc.tic_des_from_pc;\r\nIndexCard = NumCard - 1;\r\nif((NumCard < 1) || (NumCard > MAX_BOARD) || !apbs[IndexCard].RamIO)\r\nreturn -EINVAL;\r\n#ifdef DEBUG\r\nprintk("Write to applicom card #%d. struct st_ram_io follows:",\r\nIndexCard+1);\r\nfor (c = 0; c < sizeof(struct st_ram_io);) {\r\nprintk("\n%5.5X: %2.2X", c, ((unsigned char *) &st_loc)[c]);\r\nfor (c++; c % 8 && c < sizeof(struct st_ram_io); c++) {\r\nprintk(" %2.2X", ((unsigned char *) &st_loc)[c]);\r\n}\r\n}\r\nprintk("\nstruct mailbox follows:");\r\nfor (c = 0; c < sizeof(struct mailbox);) {\r\nprintk("\n%5.5X: %2.2X", c, ((unsigned char *) &tmpmailbox)[c]);\r\nfor (c++; c % 8 && c < sizeof(struct mailbox); c++) {\r\nprintk(" %2.2X", ((unsigned char *) &tmpmailbox)[c]);\r\n}\r\n}\r\nprintk("\n");\r\n#endif\r\nspin_lock_irqsave(&apbs[IndexCard].mutex, flags);\r\nif(readb(apbs[IndexCard].RamIO + DATA_FROM_PC_READY) > 2) {\r\nDummy = readb(apbs[IndexCard].RamIO + VERS);\r\nspin_unlock_irqrestore(&apbs[IndexCard].mutex, flags);\r\nprintk(KERN_WARNING "APPLICOM driver write error board %d, DataFromPcReady = %d\n",\r\nIndexCard,(int)readb(apbs[IndexCard].RamIO + DATA_FROM_PC_READY));\r\nDeviceErrorCount++;\r\nreturn -EIO;\r\n}\r\nset_current_state(TASK_INTERRUPTIBLE);\r\nadd_wait_queue(&apbs[IndexCard].FlagSleepSend, &wait);\r\nwhile (readb(apbs[IndexCard].RamIO + DATA_FROM_PC_READY) != 0) {\r\nDummy = readb(apbs[IndexCard].RamIO + VERS);\r\nspin_unlock_irqrestore(&apbs[IndexCard].mutex, flags);\r\nschedule();\r\nif (signal_pending(current)) {\r\nremove_wait_queue(&apbs[IndexCard].FlagSleepSend,\r\n&wait);\r\nreturn -EINTR;\r\n}\r\nspin_lock_irqsave(&apbs[IndexCard].mutex, flags);\r\nset_current_state(TASK_INTERRUPTIBLE);\r\n}\r\nset_current_state(TASK_RUNNING);\r\nremove_wait_queue(&apbs[IndexCard].FlagSleepSend, &wait);\r\nwriteb(1, apbs[IndexCard].RamIO + DATA_FROM_PC_READY);\r\n{\r\nunsigned char *from = (unsigned char *) &tmpmailbox;\r\nvoid __iomem *to = apbs[IndexCard].RamIO + RAM_FROM_PC;\r\nint c;\r\nfor (c = 0; c < sizeof(struct mailbox); c++)\r\nwriteb(*(from++), to++);\r\n}\r\nwriteb(0x20, apbs[IndexCard].RamIO + TIC_OWNER_FROM_PC);\r\nwriteb(0xff, apbs[IndexCard].RamIO + NUMCARD_OWNER_FROM_PC);\r\nwriteb(TicCard, apbs[IndexCard].RamIO + TIC_DES_FROM_PC);\r\nwriteb(NumCard, apbs[IndexCard].RamIO + NUMCARD_DES_FROM_PC);\r\nwriteb(2, apbs[IndexCard].RamIO + DATA_FROM_PC_READY);\r\nwriteb(1, apbs[IndexCard].RamIO + RAM_IT_FROM_PC);\r\nDummy = readb(apbs[IndexCard].RamIO + VERS);\r\nspin_unlock_irqrestore(&apbs[IndexCard].mutex, flags);\r\nreturn 0;\r\n}\r\nstatic int do_ac_read(int IndexCard, char __user *buf,\r\nstruct st_ram_io *st_loc, struct mailbox *mailbox)\r\n{\r\nvoid __iomem *from = apbs[IndexCard].RamIO + RAM_TO_PC;\r\nunsigned char *to = (unsigned char *)mailbox;\r\n#ifdef DEBUG\r\nint c;\r\n#endif\r\nst_loc->tic_owner_to_pc = readb(apbs[IndexCard].RamIO + TIC_OWNER_TO_PC);\r\nst_loc->numcard_owner_to_pc = readb(apbs[IndexCard].RamIO + NUMCARD_OWNER_TO_PC);\r\n{\r\nint c;\r\nfor (c = 0; c < sizeof(struct mailbox); c++)\r\n*(to++) = readb(from++);\r\n}\r\nwriteb(1, apbs[IndexCard].RamIO + ACK_FROM_PC_READY);\r\nwriteb(1, apbs[IndexCard].RamIO + TYP_ACK_FROM_PC);\r\nwriteb(IndexCard+1, apbs[IndexCard].RamIO + NUMCARD_ACK_FROM_PC);\r\nwriteb(readb(apbs[IndexCard].RamIO + TIC_OWNER_TO_PC),\r\napbs[IndexCard].RamIO + TIC_ACK_FROM_PC);\r\nwriteb(2, apbs[IndexCard].RamIO + ACK_FROM_PC_READY);\r\nwriteb(0, apbs[IndexCard].RamIO + DATA_TO_PC_READY);\r\nwriteb(2, apbs[IndexCard].RamIO + RAM_IT_FROM_PC);\r\nDummy = readb(apbs[IndexCard].RamIO + VERS);\r\n#ifdef DEBUG\r\nprintk("Read from applicom card #%d. struct st_ram_io follows:", NumCard);\r\nfor (c = 0; c < sizeof(struct st_ram_io);) {\r\nprintk("\n%5.5X: %2.2X", c, ((unsigned char *)st_loc)[c]);\r\nfor (c++; c % 8 && c < sizeof(struct st_ram_io); c++) {\r\nprintk(" %2.2X", ((unsigned char *)st_loc)[c]);\r\n}\r\n}\r\nprintk("\nstruct mailbox follows:");\r\nfor (c = 0; c < sizeof(struct mailbox);) {\r\nprintk("\n%5.5X: %2.2X", c, ((unsigned char *)mailbox)[c]);\r\nfor (c++; c % 8 && c < sizeof(struct mailbox); c++) {\r\nprintk(" %2.2X", ((unsigned char *)mailbox)[c]);\r\n}\r\n}\r\nprintk("\n");\r\n#endif\r\nreturn (sizeof(struct st_ram_io) + sizeof(struct mailbox));\r\n}\r\nstatic ssize_t ac_read (struct file *filp, char __user *buf, size_t count, loff_t *ptr)\r\n{\r\nunsigned long flags;\r\nunsigned int i;\r\nunsigned char tmp;\r\nint ret = 0;\r\nDECLARE_WAITQUEUE(wait, current);\r\n#ifdef DEBUG\r\nint loopcount=0;\r\n#endif\r\nif (count != sizeof(struct st_ram_io) + sizeof(struct mailbox)) {\r\nprintk( KERN_WARNING "Hmmm. read() of Applicom card, length %zd != expected %zd\n",\r\ncount,sizeof(struct st_ram_io) + sizeof(struct mailbox));\r\nreturn -EINVAL;\r\n}\r\nwhile(1) {\r\nset_current_state(TASK_INTERRUPTIBLE);\r\nadd_wait_queue(&FlagSleepRec, &wait);\r\nfor (i=0; i < MAX_BOARD; i++) {\r\nif (!apbs[i].RamIO)\r\ncontinue;\r\nspin_lock_irqsave(&apbs[i].mutex, flags);\r\ntmp = readb(apbs[i].RamIO + DATA_TO_PC_READY);\r\nif (tmp == 2) {\r\nstruct st_ram_io st_loc;\r\nstruct mailbox mailbox;\r\nmemset(&st_loc, 0, sizeof(st_loc));\r\nret = do_ac_read(i, buf, &st_loc, &mailbox);\r\nspin_unlock_irqrestore(&apbs[i].mutex, flags);\r\nset_current_state(TASK_RUNNING);\r\nremove_wait_queue(&FlagSleepRec, &wait);\r\nif (copy_to_user(buf, &st_loc, sizeof(st_loc)))\r\nreturn -EFAULT;\r\nif (copy_to_user(buf + sizeof(st_loc), &mailbox, sizeof(mailbox)))\r\nreturn -EFAULT;\r\nreturn tmp;\r\n}\r\nif (tmp > 2) {\r\nDummy = readb(apbs[i].RamIO + VERS);\r\nspin_unlock_irqrestore(&apbs[i].mutex, flags);\r\nset_current_state(TASK_RUNNING);\r\nremove_wait_queue(&FlagSleepRec, &wait);\r\nprintk(KERN_WARNING "APPLICOM driver read error board %d, DataToPcReady = %d\n",\r\ni,(int)readb(apbs[i].RamIO + DATA_TO_PC_READY));\r\nDeviceErrorCount++;\r\nreturn -EIO;\r\n}\r\nDummy = readb(apbs[i].RamIO + VERS);\r\nspin_unlock_irqrestore(&apbs[i].mutex, flags);\r\n}\r\nschedule();\r\nremove_wait_queue(&FlagSleepRec, &wait);\r\nif (signal_pending(current))\r\nreturn -EINTR;\r\n#ifdef DEBUG\r\nif (loopcount++ > 2) {\r\nprintk(KERN_DEBUG "Looping in ac_read. loopcount %d\n", loopcount);\r\n}\r\n#endif\r\n}\r\n}\r\nstatic irqreturn_t ac_interrupt(int vec, void *dev_instance)\r\n{\r\nunsigned int i;\r\nunsigned int FlagInt;\r\nunsigned int LoopCount;\r\nint handled = 0;\r\nLoopCount = 0;\r\ndo {\r\nFlagInt = 0;\r\nfor (i = 0; i < MAX_BOARD; i++) {\r\nif (!apbs[i].RamIO)\r\ncontinue;\r\nspin_lock(&apbs[i].mutex);\r\nif(readb(apbs[i].RamIO + RAM_IT_TO_PC) == 0) {\r\nspin_unlock(&apbs[i].mutex);\r\ncontinue;\r\n}\r\nhandled = 1;\r\nFlagInt = 1;\r\nwriteb(0, apbs[i].RamIO + RAM_IT_TO_PC);\r\nif (readb(apbs[i].RamIO + DATA_TO_PC_READY) > 2) {\r\nprintk(KERN_WARNING "APPLICOM driver interrupt err board %d, DataToPcReady = %d\n",\r\ni+1,(int)readb(apbs[i].RamIO + DATA_TO_PC_READY));\r\nDeviceErrorCount++;\r\n}\r\nif((readb(apbs[i].RamIO + DATA_FROM_PC_READY) > 2) &&\r\n(readb(apbs[i].RamIO + DATA_FROM_PC_READY) != 6)) {\r\nprintk(KERN_WARNING "APPLICOM driver interrupt err board %d, DataFromPcReady = %d\n",\r\ni+1,(int)readb(apbs[i].RamIO + DATA_FROM_PC_READY));\r\nDeviceErrorCount++;\r\n}\r\nif (readb(apbs[i].RamIO + DATA_TO_PC_READY) == 2) {\r\nif (waitqueue_active(&FlagSleepRec)) {\r\nwake_up_interruptible(&FlagSleepRec);\r\n}\r\n}\r\nif (readb(apbs[i].RamIO + DATA_FROM_PC_READY) == 0) {\r\nif (waitqueue_active(&apbs[i].FlagSleepSend)) {\r\nwake_up_interruptible(&apbs[i].FlagSleepSend);\r\n}\r\n}\r\nDummy = readb(apbs[i].RamIO + VERS);\r\nif(readb(apbs[i].RamIO + RAM_IT_TO_PC)) {\r\nspin_unlock(&apbs[i].mutex);\r\ni--;\r\n} else {\r\nspin_unlock(&apbs[i].mutex);\r\n}\r\n}\r\nif (FlagInt)\r\nLoopCount = 0;\r\nelse\r\nLoopCount++;\r\n} while(LoopCount < 2);\r\nreturn IRQ_RETVAL(handled);\r\n}\r\nstatic long ac_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\r\n{\r\nint i;\r\nunsigned char IndexCard;\r\nvoid __iomem *pmem;\r\nint ret = 0;\r\nvolatile unsigned char byte_reset_it;\r\nstruct st_ram_io *adgl;\r\nvoid __user *argp = (void __user *)arg;\r\nadgl = memdup_user(argp, sizeof(struct st_ram_io));\r\nif (IS_ERR(adgl))\r\nreturn PTR_ERR(adgl);\r\nmutex_lock(&ac_mutex);\r\nIndexCard = adgl->num_card-1;\r\nif(cmd != 6 && ((IndexCard >= MAX_BOARD) || !apbs[IndexCard].RamIO)) {\r\nstatic int warncount = 10;\r\nif (warncount) {\r\nprintk( KERN_WARNING "APPLICOM driver IOCTL, bad board number %d\n",(int)IndexCard+1);\r\nwarncount--;\r\n}\r\nkfree(adgl);\r\nmutex_unlock(&ac_mutex);\r\nreturn -EINVAL;\r\n}\r\nswitch (cmd) {\r\ncase 0:\r\npmem = apbs[IndexCard].RamIO;\r\nfor (i = 0; i < sizeof(struct st_ram_io); i++)\r\n((unsigned char *)adgl)[i]=readb(pmem++);\r\nif (copy_to_user(argp, adgl, sizeof(struct st_ram_io)))\r\nret = -EFAULT;\r\nbreak;\r\ncase 1:\r\npmem = apbs[IndexCard].RamIO + CONF_END_TEST;\r\nfor (i = 0; i < 4; i++)\r\nadgl->conf_end_test[i] = readb(pmem++);\r\nfor (i = 0; i < 2; i++)\r\nadgl->error_code[i] = readb(pmem++);\r\nfor (i = 0; i < 4; i++)\r\nadgl->parameter_error[i] = readb(pmem++);\r\npmem = apbs[IndexCard].RamIO + VERS;\r\nadgl->vers = readb(pmem);\r\npmem = apbs[IndexCard].RamIO + TYPE_CARD;\r\nfor (i = 0; i < 20; i++)\r\nadgl->reserv1[i] = readb(pmem++);\r\n*(int *)&adgl->reserv1[20] =\r\n(readb(apbs[IndexCard].RamIO + SERIAL_NUMBER) << 16) +\r\n(readb(apbs[IndexCard].RamIO + SERIAL_NUMBER + 1) << 8) +\r\n(readb(apbs[IndexCard].RamIO + SERIAL_NUMBER + 2) );\r\nif (copy_to_user(argp, adgl, sizeof(struct st_ram_io)))\r\nret = -EFAULT;\r\nbreak;\r\ncase 2:\r\npmem = apbs[IndexCard].RamIO + CONF_END_TEST;\r\nfor (i = 0; i < 10; i++)\r\nwriteb(0xff, pmem++);\r\nwriteb(adgl->data_from_pc_ready,\r\napbs[IndexCard].RamIO + DATA_FROM_PC_READY);\r\nwriteb(1, apbs[IndexCard].RamIO + RAM_IT_FROM_PC);\r\nfor (i = 0; i < MAX_BOARD; i++) {\r\nif (apbs[i].RamIO) {\r\nbyte_reset_it = readb(apbs[i].RamIO + RAM_IT_TO_PC);\r\n}\r\n}\r\nbreak;\r\ncase 3:\r\npmem = apbs[IndexCard].RamIO + TIC_DES_FROM_PC;\r\nwriteb(adgl->tic_des_from_pc, pmem);\r\nbreak;\r\ncase 4:\r\npmem = apbs[IndexCard].RamIO + TIC_OWNER_TO_PC;\r\nadgl->tic_owner_to_pc = readb(pmem++);\r\nadgl->numcard_owner_to_pc = readb(pmem);\r\nif (copy_to_user(argp, adgl,sizeof(struct st_ram_io)))\r\nret = -EFAULT;\r\nbreak;\r\ncase 5:\r\nwriteb(adgl->num_card, apbs[IndexCard].RamIO + NUMCARD_OWNER_TO_PC);\r\nwriteb(adgl->num_card, apbs[IndexCard].RamIO + NUMCARD_DES_FROM_PC);\r\nwriteb(adgl->num_card, apbs[IndexCard].RamIO + NUMCARD_ACK_FROM_PC);\r\nwriteb(4, apbs[IndexCard].RamIO + DATA_FROM_PC_READY);\r\nwriteb(1, apbs[IndexCard].RamIO + RAM_IT_FROM_PC);\r\nbreak;\r\ncase 6:\r\nprintk(KERN_INFO "APPLICOM driver release .... V2.8.0 ($Revision: 1.30 $)\n");\r\nprintk(KERN_INFO "Number of installed boards . %d\n", (int) numboards);\r\nprintk(KERN_INFO "Segment of board ........... %X\n", (int) mem);\r\nprintk(KERN_INFO "Interrupt IRQ number ....... %d\n", (int) irq);\r\nfor (i = 0; i < MAX_BOARD; i++) {\r\nint serial;\r\nchar boardname[(SERIAL_NUMBER - TYPE_CARD) + 1];\r\nif (!apbs[i].RamIO)\r\ncontinue;\r\nfor (serial = 0; serial < SERIAL_NUMBER - TYPE_CARD; serial++)\r\nboardname[serial] = readb(apbs[i].RamIO + TYPE_CARD + serial);\r\nboardname[serial] = 0;\r\nprintk(KERN_INFO "Prom version board %d ....... V%d.%d %s",\r\ni+1,\r\n(int)(readb(apbs[IndexCard].RamIO + VERS) >> 4),\r\n(int)(readb(apbs[IndexCard].RamIO + VERS) & 0xF),\r\nboardname);\r\nserial = (readb(apbs[i].RamIO + SERIAL_NUMBER) << 16) +\r\n(readb(apbs[i].RamIO + SERIAL_NUMBER + 1) << 8) +\r\n(readb(apbs[i].RamIO + SERIAL_NUMBER + 2) );\r\nif (serial != 0)\r\nprintk(" S/N %d\n", serial);\r\nelse\r\nprintk("\n");\r\n}\r\nif (DeviceErrorCount != 0)\r\nprintk(KERN_INFO "DeviceErrorCount ........... %d\n", DeviceErrorCount);\r\nif (ReadErrorCount != 0)\r\nprintk(KERN_INFO "ReadErrorCount ............. %d\n", ReadErrorCount);\r\nif (WriteErrorCount != 0)\r\nprintk(KERN_INFO "WriteErrorCount ............ %d\n", WriteErrorCount);\r\nif (waitqueue_active(&FlagSleepRec))\r\nprintk(KERN_INFO "Process in read pending\n");\r\nfor (i = 0; i < MAX_BOARD; i++) {\r\nif (apbs[i].RamIO && waitqueue_active(&apbs[i].FlagSleepSend))\r\nprintk(KERN_INFO "Process in write pending board %d\n",i+1);\r\n}\r\nbreak;\r\ndefault:\r\nret = -ENOTTY;\r\nbreak;\r\n}\r\nDummy = readb(apbs[IndexCard].RamIO + VERS);\r\nkfree(adgl);\r\nmutex_unlock(&ac_mutex);\r\nreturn 0;\r\n}
