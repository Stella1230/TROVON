static void jz4740_mmc_set_irq_enabled(struct jz4740_mmc_host *host,\r\nunsigned int irq, bool enabled)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&host->lock, flags);\r\nif (enabled)\r\nhost->irq_mask &= ~irq;\r\nelse\r\nhost->irq_mask |= irq;\r\nspin_unlock_irqrestore(&host->lock, flags);\r\nwritew(host->irq_mask, host->base + JZ_REG_MMC_IMASK);\r\n}\r\nstatic void jz4740_mmc_clock_enable(struct jz4740_mmc_host *host,\r\nbool start_transfer)\r\n{\r\nuint16_t val = JZ_MMC_STRPCL_CLOCK_START;\r\nif (start_transfer)\r\nval |= JZ_MMC_STRPCL_START_OP;\r\nwritew(val, host->base + JZ_REG_MMC_STRPCL);\r\n}\r\nstatic void jz4740_mmc_clock_disable(struct jz4740_mmc_host *host)\r\n{\r\nuint32_t status;\r\nunsigned int timeout = 1000;\r\nwritew(JZ_MMC_STRPCL_CLOCK_STOP, host->base + JZ_REG_MMC_STRPCL);\r\ndo {\r\nstatus = readl(host->base + JZ_REG_MMC_STATUS);\r\n} while (status & JZ_MMC_STATUS_CLK_EN && --timeout);\r\n}\r\nstatic void jz4740_mmc_reset(struct jz4740_mmc_host *host)\r\n{\r\nuint32_t status;\r\nunsigned int timeout = 1000;\r\nwritew(JZ_MMC_STRPCL_RESET, host->base + JZ_REG_MMC_STRPCL);\r\nudelay(10);\r\ndo {\r\nstatus = readl(host->base + JZ_REG_MMC_STATUS);\r\n} while (status & JZ_MMC_STATUS_IS_RESETTING && --timeout);\r\n}\r\nstatic void jz4740_mmc_request_done(struct jz4740_mmc_host *host)\r\n{\r\nstruct mmc_request *req;\r\nreq = host->req;\r\nhost->req = NULL;\r\nmmc_request_done(host->mmc, req);\r\n}\r\nstatic unsigned int jz4740_mmc_poll_irq(struct jz4740_mmc_host *host,\r\nunsigned int irq)\r\n{\r\nunsigned int timeout = 0x800;\r\nuint16_t status;\r\ndo {\r\nstatus = readw(host->base + JZ_REG_MMC_IREG);\r\n} while (!(status & irq) && --timeout);\r\nif (timeout == 0) {\r\nset_bit(0, &host->waiting);\r\nmod_timer(&host->timeout_timer, jiffies + 5*HZ);\r\njz4740_mmc_set_irq_enabled(host, irq, true);\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic void jz4740_mmc_transfer_check_state(struct jz4740_mmc_host *host,\r\nstruct mmc_data *data)\r\n{\r\nint status;\r\nstatus = readl(host->base + JZ_REG_MMC_STATUS);\r\nif (status & JZ_MMC_STATUS_WRITE_ERROR_MASK) {\r\nif (status & (JZ_MMC_STATUS_TIMEOUT_WRITE)) {\r\nhost->req->cmd->error = -ETIMEDOUT;\r\ndata->error = -ETIMEDOUT;\r\n} else {\r\nhost->req->cmd->error = -EIO;\r\ndata->error = -EIO;\r\n}\r\n}\r\n}\r\nstatic bool jz4740_mmc_write_data(struct jz4740_mmc_host *host,\r\nstruct mmc_data *data)\r\n{\r\nstruct sg_mapping_iter *miter = &host->miter;\r\nvoid __iomem *fifo_addr = host->base + JZ_REG_MMC_TXFIFO;\r\nuint32_t *buf;\r\nbool timeout;\r\nsize_t i, j;\r\nwhile (sg_miter_next(miter)) {\r\nbuf = miter->addr;\r\ni = miter->length / 4;\r\nj = i / 8;\r\ni = i & 0x7;\r\nwhile (j) {\r\ntimeout = jz4740_mmc_poll_irq(host, JZ_MMC_IRQ_TXFIFO_WR_REQ);\r\nif (unlikely(timeout))\r\ngoto poll_timeout;\r\nwritel(buf[0], fifo_addr);\r\nwritel(buf[1], fifo_addr);\r\nwritel(buf[2], fifo_addr);\r\nwritel(buf[3], fifo_addr);\r\nwritel(buf[4], fifo_addr);\r\nwritel(buf[5], fifo_addr);\r\nwritel(buf[6], fifo_addr);\r\nwritel(buf[7], fifo_addr);\r\nbuf += 8;\r\n--j;\r\n}\r\nif (unlikely(i)) {\r\ntimeout = jz4740_mmc_poll_irq(host, JZ_MMC_IRQ_TXFIFO_WR_REQ);\r\nif (unlikely(timeout))\r\ngoto poll_timeout;\r\nwhile (i) {\r\nwritel(*buf, fifo_addr);\r\n++buf;\r\n--i;\r\n}\r\n}\r\ndata->bytes_xfered += miter->length;\r\n}\r\nsg_miter_stop(miter);\r\nreturn false;\r\npoll_timeout:\r\nmiter->consumed = (void *)buf - miter->addr;\r\ndata->bytes_xfered += miter->consumed;\r\nsg_miter_stop(miter);\r\nreturn true;\r\n}\r\nstatic bool jz4740_mmc_read_data(struct jz4740_mmc_host *host,\r\nstruct mmc_data *data)\r\n{\r\nstruct sg_mapping_iter *miter = &host->miter;\r\nvoid __iomem *fifo_addr = host->base + JZ_REG_MMC_RXFIFO;\r\nuint32_t *buf;\r\nuint32_t d;\r\nuint16_t status;\r\nsize_t i, j;\r\nunsigned int timeout;\r\nwhile (sg_miter_next(miter)) {\r\nbuf = miter->addr;\r\ni = miter->length;\r\nj = i / 32;\r\ni = i & 0x1f;\r\nwhile (j) {\r\ntimeout = jz4740_mmc_poll_irq(host, JZ_MMC_IRQ_RXFIFO_RD_REQ);\r\nif (unlikely(timeout))\r\ngoto poll_timeout;\r\nbuf[0] = readl(fifo_addr);\r\nbuf[1] = readl(fifo_addr);\r\nbuf[2] = readl(fifo_addr);\r\nbuf[3] = readl(fifo_addr);\r\nbuf[4] = readl(fifo_addr);\r\nbuf[5] = readl(fifo_addr);\r\nbuf[6] = readl(fifo_addr);\r\nbuf[7] = readl(fifo_addr);\r\nbuf += 8;\r\n--j;\r\n}\r\nif (unlikely(i)) {\r\ntimeout = jz4740_mmc_poll_irq(host, JZ_MMC_IRQ_RXFIFO_RD_REQ);\r\nif (unlikely(timeout))\r\ngoto poll_timeout;\r\nwhile (i >= 4) {\r\n*buf++ = readl(fifo_addr);\r\ni -= 4;\r\n}\r\nif (unlikely(i > 0)) {\r\nd = readl(fifo_addr);\r\nmemcpy(buf, &d, i);\r\n}\r\n}\r\ndata->bytes_xfered += miter->length;\r\nflush_dcache_page(miter->page);\r\n}\r\nsg_miter_stop(miter);\r\ntimeout = 1000;\r\nstatus = readl(host->base + JZ_REG_MMC_STATUS);\r\nwhile (!(status & JZ_MMC_STATUS_DATA_FIFO_EMPTY) && --timeout) {\r\nd = readl(fifo_addr);\r\nstatus = readl(host->base + JZ_REG_MMC_STATUS);\r\n}\r\nreturn false;\r\npoll_timeout:\r\nmiter->consumed = (void *)buf - miter->addr;\r\ndata->bytes_xfered += miter->consumed;\r\nsg_miter_stop(miter);\r\nreturn true;\r\n}\r\nstatic void jz4740_mmc_timeout(unsigned long data)\r\n{\r\nstruct jz4740_mmc_host *host = (struct jz4740_mmc_host *)data;\r\nif (!test_and_clear_bit(0, &host->waiting))\r\nreturn;\r\njz4740_mmc_set_irq_enabled(host, JZ_MMC_IRQ_END_CMD_RES, false);\r\nhost->req->cmd->error = -ETIMEDOUT;\r\njz4740_mmc_request_done(host);\r\n}\r\nstatic void jz4740_mmc_read_response(struct jz4740_mmc_host *host,\r\nstruct mmc_command *cmd)\r\n{\r\nint i;\r\nuint16_t tmp;\r\nvoid __iomem *fifo_addr = host->base + JZ_REG_MMC_RESP_FIFO;\r\nif (cmd->flags & MMC_RSP_136) {\r\ntmp = readw(fifo_addr);\r\nfor (i = 0; i < 4; ++i) {\r\ncmd->resp[i] = tmp << 24;\r\ntmp = readw(fifo_addr);\r\ncmd->resp[i] |= tmp << 8;\r\ntmp = readw(fifo_addr);\r\ncmd->resp[i] |= tmp >> 8;\r\n}\r\n} else {\r\ncmd->resp[0] = readw(fifo_addr) << 24;\r\ncmd->resp[0] |= readw(fifo_addr) << 8;\r\ncmd->resp[0] |= readw(fifo_addr) & 0xff;\r\n}\r\n}\r\nstatic void jz4740_mmc_send_command(struct jz4740_mmc_host *host,\r\nstruct mmc_command *cmd)\r\n{\r\nuint32_t cmdat = host->cmdat;\r\nhost->cmdat &= ~JZ_MMC_CMDAT_INIT;\r\njz4740_mmc_clock_disable(host);\r\nhost->cmd = cmd;\r\nif (cmd->flags & MMC_RSP_BUSY)\r\ncmdat |= JZ_MMC_CMDAT_BUSY;\r\nswitch (mmc_resp_type(cmd)) {\r\ncase MMC_RSP_R1B:\r\ncase MMC_RSP_R1:\r\ncmdat |= JZ_MMC_CMDAT_RSP_R1;\r\nbreak;\r\ncase MMC_RSP_R2:\r\ncmdat |= JZ_MMC_CMDAT_RSP_R2;\r\nbreak;\r\ncase MMC_RSP_R3:\r\ncmdat |= JZ_MMC_CMDAT_RSP_R3;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif (cmd->data) {\r\ncmdat |= JZ_MMC_CMDAT_DATA_EN;\r\nif (cmd->data->flags & MMC_DATA_WRITE)\r\ncmdat |= JZ_MMC_CMDAT_WRITE;\r\nif (cmd->data->flags & MMC_DATA_STREAM)\r\ncmdat |= JZ_MMC_CMDAT_STREAM;\r\nwritew(cmd->data->blksz, host->base + JZ_REG_MMC_BLKLEN);\r\nwritew(cmd->data->blocks, host->base + JZ_REG_MMC_NOB);\r\n}\r\nwriteb(cmd->opcode, host->base + JZ_REG_MMC_CMD);\r\nwritel(cmd->arg, host->base + JZ_REG_MMC_ARG);\r\nwritel(cmdat, host->base + JZ_REG_MMC_CMDAT);\r\njz4740_mmc_clock_enable(host, 1);\r\n}\r\nstatic void jz_mmc_prepare_data_transfer(struct jz4740_mmc_host *host)\r\n{\r\nstruct mmc_command *cmd = host->req->cmd;\r\nstruct mmc_data *data = cmd->data;\r\nint direction;\r\nif (data->flags & MMC_DATA_READ)\r\ndirection = SG_MITER_TO_SG;\r\nelse\r\ndirection = SG_MITER_FROM_SG;\r\nsg_miter_start(&host->miter, data->sg, data->sg_len, direction);\r\n}\r\nstatic irqreturn_t jz_mmc_irq_worker(int irq, void *devid)\r\n{\r\nstruct jz4740_mmc_host *host = (struct jz4740_mmc_host *)devid;\r\nstruct mmc_command *cmd = host->req->cmd;\r\nstruct mmc_request *req = host->req;\r\nbool timeout = false;\r\nif (cmd->error)\r\nhost->state = JZ4740_MMC_STATE_DONE;\r\nswitch (host->state) {\r\ncase JZ4740_MMC_STATE_READ_RESPONSE:\r\nif (cmd->flags & MMC_RSP_PRESENT)\r\njz4740_mmc_read_response(host, cmd);\r\nif (!cmd->data)\r\nbreak;\r\njz_mmc_prepare_data_transfer(host);\r\ncase JZ4740_MMC_STATE_TRANSFER_DATA:\r\nif (cmd->data->flags & MMC_DATA_READ)\r\ntimeout = jz4740_mmc_read_data(host, cmd->data);\r\nelse\r\ntimeout = jz4740_mmc_write_data(host, cmd->data);\r\nif (unlikely(timeout)) {\r\nhost->state = JZ4740_MMC_STATE_TRANSFER_DATA;\r\nbreak;\r\n}\r\njz4740_mmc_transfer_check_state(host, cmd->data);\r\ntimeout = jz4740_mmc_poll_irq(host, JZ_MMC_IRQ_DATA_TRAN_DONE);\r\nif (unlikely(timeout)) {\r\nhost->state = JZ4740_MMC_STATE_SEND_STOP;\r\nbreak;\r\n}\r\nwritew(JZ_MMC_IRQ_DATA_TRAN_DONE, host->base + JZ_REG_MMC_IREG);\r\ncase JZ4740_MMC_STATE_SEND_STOP:\r\nif (!req->stop)\r\nbreak;\r\njz4740_mmc_send_command(host, req->stop);\r\ntimeout = jz4740_mmc_poll_irq(host, JZ_MMC_IRQ_PRG_DONE);\r\nif (timeout) {\r\nhost->state = JZ4740_MMC_STATE_DONE;\r\nbreak;\r\n}\r\ncase JZ4740_MMC_STATE_DONE:\r\nbreak;\r\n}\r\nif (!timeout)\r\njz4740_mmc_request_done(host);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t jz_mmc_irq(int irq, void *devid)\r\n{\r\nstruct jz4740_mmc_host *host = devid;\r\nstruct mmc_command *cmd = host->cmd;\r\nuint16_t irq_reg, status, tmp;\r\nirq_reg = readw(host->base + JZ_REG_MMC_IREG);\r\ntmp = irq_reg;\r\nirq_reg &= ~host->irq_mask;\r\ntmp &= ~(JZ_MMC_IRQ_TXFIFO_WR_REQ | JZ_MMC_IRQ_RXFIFO_RD_REQ |\r\nJZ_MMC_IRQ_PRG_DONE | JZ_MMC_IRQ_DATA_TRAN_DONE);\r\nif (tmp != irq_reg)\r\nwritew(tmp & ~irq_reg, host->base + JZ_REG_MMC_IREG);\r\nif (irq_reg & JZ_MMC_IRQ_SDIO) {\r\nwritew(JZ_MMC_IRQ_SDIO, host->base + JZ_REG_MMC_IREG);\r\nmmc_signal_sdio_irq(host->mmc);\r\nirq_reg &= ~JZ_MMC_IRQ_SDIO;\r\n}\r\nif (host->req && cmd && irq_reg) {\r\nif (test_and_clear_bit(0, &host->waiting)) {\r\ndel_timer(&host->timeout_timer);\r\nstatus = readl(host->base + JZ_REG_MMC_STATUS);\r\nif (status & JZ_MMC_STATUS_TIMEOUT_RES) {\r\ncmd->error = -ETIMEDOUT;\r\n} else if (status & JZ_MMC_STATUS_CRC_RES_ERR) {\r\ncmd->error = -EIO;\r\n} else if (status & (JZ_MMC_STATUS_CRC_READ_ERROR |\r\nJZ_MMC_STATUS_CRC_WRITE_ERROR)) {\r\nif (cmd->data)\r\ncmd->data->error = -EIO;\r\ncmd->error = -EIO;\r\n} else if (status & (JZ_MMC_STATUS_CRC_READ_ERROR |\r\nJZ_MMC_STATUS_CRC_WRITE_ERROR)) {\r\nif (cmd->data)\r\ncmd->data->error = -EIO;\r\ncmd->error = -EIO;\r\n}\r\njz4740_mmc_set_irq_enabled(host, irq_reg, false);\r\nwritew(irq_reg, host->base + JZ_REG_MMC_IREG);\r\nreturn IRQ_WAKE_THREAD;\r\n}\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int jz4740_mmc_set_clock_rate(struct jz4740_mmc_host *host, int rate)\r\n{\r\nint div = 0;\r\nint real_rate;\r\njz4740_mmc_clock_disable(host);\r\nclk_set_rate(host->clk, JZ_MMC_CLK_RATE);\r\nreal_rate = clk_get_rate(host->clk);\r\nwhile (real_rate > rate && div < 7) {\r\n++div;\r\nreal_rate >>= 1;\r\n}\r\nwritew(div, host->base + JZ_REG_MMC_CLKRT);\r\nreturn real_rate;\r\n}\r\nstatic void jz4740_mmc_request(struct mmc_host *mmc, struct mmc_request *req)\r\n{\r\nstruct jz4740_mmc_host *host = mmc_priv(mmc);\r\nhost->req = req;\r\nwritew(0xffff, host->base + JZ_REG_MMC_IREG);\r\nwritew(JZ_MMC_IRQ_END_CMD_RES, host->base + JZ_REG_MMC_IREG);\r\njz4740_mmc_set_irq_enabled(host, JZ_MMC_IRQ_END_CMD_RES, true);\r\nhost->state = JZ4740_MMC_STATE_READ_RESPONSE;\r\nset_bit(0, &host->waiting);\r\nmod_timer(&host->timeout_timer, jiffies + 5*HZ);\r\njz4740_mmc_send_command(host, req->cmd);\r\n}\r\nstatic void jz4740_mmc_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)\r\n{\r\nstruct jz4740_mmc_host *host = mmc_priv(mmc);\r\nif (ios->clock)\r\njz4740_mmc_set_clock_rate(host, ios->clock);\r\nswitch (ios->power_mode) {\r\ncase MMC_POWER_UP:\r\njz4740_mmc_reset(host);\r\nif (gpio_is_valid(host->pdata->gpio_power))\r\ngpio_set_value(host->pdata->gpio_power,\r\n!host->pdata->power_active_low);\r\nhost->cmdat |= JZ_MMC_CMDAT_INIT;\r\nclk_enable(host->clk);\r\nbreak;\r\ncase MMC_POWER_ON:\r\nbreak;\r\ndefault:\r\nif (gpio_is_valid(host->pdata->gpio_power))\r\ngpio_set_value(host->pdata->gpio_power,\r\nhost->pdata->power_active_low);\r\nclk_disable(host->clk);\r\nbreak;\r\n}\r\nswitch (ios->bus_width) {\r\ncase MMC_BUS_WIDTH_1:\r\nhost->cmdat &= ~JZ_MMC_CMDAT_BUS_WIDTH_4BIT;\r\nbreak;\r\ncase MMC_BUS_WIDTH_4:\r\nhost->cmdat |= JZ_MMC_CMDAT_BUS_WIDTH_4BIT;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic int jz4740_mmc_get_ro(struct mmc_host *mmc)\r\n{\r\nstruct jz4740_mmc_host *host = mmc_priv(mmc);\r\nif (!gpio_is_valid(host->pdata->gpio_read_only))\r\nreturn -ENOSYS;\r\nreturn gpio_get_value(host->pdata->gpio_read_only) ^\r\nhost->pdata->read_only_active_low;\r\n}\r\nstatic int jz4740_mmc_get_cd(struct mmc_host *mmc)\r\n{\r\nstruct jz4740_mmc_host *host = mmc_priv(mmc);\r\nif (!gpio_is_valid(host->pdata->gpio_card_detect))\r\nreturn -ENOSYS;\r\nreturn gpio_get_value(host->pdata->gpio_card_detect) ^\r\nhost->pdata->card_detect_active_low;\r\n}\r\nstatic irqreturn_t jz4740_mmc_card_detect_irq(int irq, void *devid)\r\n{\r\nstruct jz4740_mmc_host *host = devid;\r\nmmc_detect_change(host->mmc, HZ / 2);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void jz4740_mmc_enable_sdio_irq(struct mmc_host *mmc, int enable)\r\n{\r\nstruct jz4740_mmc_host *host = mmc_priv(mmc);\r\njz4740_mmc_set_irq_enabled(host, JZ_MMC_IRQ_SDIO, enable);\r\n}\r\nstatic int jz4740_mmc_request_gpio(struct device *dev, int gpio,\r\nconst char *name, bool output, int value)\r\n{\r\nint ret;\r\nif (!gpio_is_valid(gpio))\r\nreturn 0;\r\nret = gpio_request(gpio, name);\r\nif (ret) {\r\ndev_err(dev, "Failed to request %s gpio: %d\n", name, ret);\r\nreturn ret;\r\n}\r\nif (output)\r\ngpio_direction_output(gpio, value);\r\nelse\r\ngpio_direction_input(gpio);\r\nreturn 0;\r\n}\r\nstatic int jz4740_mmc_request_gpios(struct platform_device *pdev)\r\n{\r\nint ret;\r\nstruct jz4740_mmc_platform_data *pdata = pdev->dev.platform_data;\r\nif (!pdata)\r\nreturn 0;\r\nret = jz4740_mmc_request_gpio(&pdev->dev, pdata->gpio_card_detect,\r\n"MMC detect change", false, 0);\r\nif (ret)\r\ngoto err;\r\nret = jz4740_mmc_request_gpio(&pdev->dev, pdata->gpio_read_only,\r\n"MMC read only", false, 0);\r\nif (ret)\r\ngoto err_free_gpio_card_detect;\r\nret = jz4740_mmc_request_gpio(&pdev->dev, pdata->gpio_power,\r\n"MMC read only", true, pdata->power_active_low);\r\nif (ret)\r\ngoto err_free_gpio_read_only;\r\nreturn 0;\r\nerr_free_gpio_read_only:\r\nif (gpio_is_valid(pdata->gpio_read_only))\r\ngpio_free(pdata->gpio_read_only);\r\nerr_free_gpio_card_detect:\r\nif (gpio_is_valid(pdata->gpio_card_detect))\r\ngpio_free(pdata->gpio_card_detect);\r\nerr:\r\nreturn ret;\r\n}\r\nstatic int jz4740_mmc_request_cd_irq(struct platform_device *pdev,\r\nstruct jz4740_mmc_host *host)\r\n{\r\nstruct jz4740_mmc_platform_data *pdata = pdev->dev.platform_data;\r\nif (!gpio_is_valid(pdata->gpio_card_detect))\r\nreturn 0;\r\nhost->card_detect_irq = gpio_to_irq(pdata->gpio_card_detect);\r\nif (host->card_detect_irq < 0) {\r\ndev_warn(&pdev->dev, "Failed to get card detect irq\n");\r\nreturn 0;\r\n}\r\nreturn request_irq(host->card_detect_irq, jz4740_mmc_card_detect_irq,\r\nIRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING,\r\n"MMC card detect", host);\r\n}\r\nstatic void jz4740_mmc_free_gpios(struct platform_device *pdev)\r\n{\r\nstruct jz4740_mmc_platform_data *pdata = pdev->dev.platform_data;\r\nif (!pdata)\r\nreturn;\r\nif (gpio_is_valid(pdata->gpio_power))\r\ngpio_free(pdata->gpio_power);\r\nif (gpio_is_valid(pdata->gpio_read_only))\r\ngpio_free(pdata->gpio_read_only);\r\nif (gpio_is_valid(pdata->gpio_card_detect))\r\ngpio_free(pdata->gpio_card_detect);\r\n}\r\nstatic inline size_t jz4740_mmc_num_pins(struct jz4740_mmc_host *host)\r\n{\r\nsize_t num_pins = ARRAY_SIZE(jz4740_mmc_pins);\r\nif (host->pdata && host->pdata->data_1bit)\r\nnum_pins -= 3;\r\nreturn num_pins;\r\n}\r\nstatic int jz4740_mmc_probe(struct platform_device* pdev)\r\n{\r\nint ret;\r\nstruct mmc_host *mmc;\r\nstruct jz4740_mmc_host *host;\r\nstruct jz4740_mmc_platform_data *pdata;\r\npdata = pdev->dev.platform_data;\r\nmmc = mmc_alloc_host(sizeof(struct jz4740_mmc_host), &pdev->dev);\r\nif (!mmc) {\r\ndev_err(&pdev->dev, "Failed to alloc mmc host structure\n");\r\nreturn -ENOMEM;\r\n}\r\nhost = mmc_priv(mmc);\r\nhost->pdata = pdata;\r\nhost->irq = platform_get_irq(pdev, 0);\r\nif (host->irq < 0) {\r\nret = host->irq;\r\ndev_err(&pdev->dev, "Failed to get platform irq: %d\n", ret);\r\ngoto err_free_host;\r\n}\r\nhost->clk = clk_get(&pdev->dev, "mmc");\r\nif (IS_ERR(host->clk)) {\r\nret = PTR_ERR(host->clk);\r\ndev_err(&pdev->dev, "Failed to get mmc clock\n");\r\ngoto err_free_host;\r\n}\r\nhost->mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!host->mem) {\r\nret = -ENOENT;\r\ndev_err(&pdev->dev, "Failed to get base platform memory\n");\r\ngoto err_clk_put;\r\n}\r\nhost->mem = request_mem_region(host->mem->start,\r\nresource_size(host->mem), pdev->name);\r\nif (!host->mem) {\r\nret = -EBUSY;\r\ndev_err(&pdev->dev, "Failed to request base memory region\n");\r\ngoto err_clk_put;\r\n}\r\nhost->base = ioremap_nocache(host->mem->start, resource_size(host->mem));\r\nif (!host->base) {\r\nret = -EBUSY;\r\ndev_err(&pdev->dev, "Failed to ioremap base memory\n");\r\ngoto err_release_mem_region;\r\n}\r\nret = jz_gpio_bulk_request(jz4740_mmc_pins, jz4740_mmc_num_pins(host));\r\nif (ret) {\r\ndev_err(&pdev->dev, "Failed to request mmc pins: %d\n", ret);\r\ngoto err_iounmap;\r\n}\r\nret = jz4740_mmc_request_gpios(pdev);\r\nif (ret)\r\ngoto err_gpio_bulk_free;\r\nmmc->ops = &jz4740_mmc_ops;\r\nmmc->f_min = JZ_MMC_CLK_RATE / 128;\r\nmmc->f_max = JZ_MMC_CLK_RATE;\r\nmmc->ocr_avail = MMC_VDD_32_33 | MMC_VDD_33_34;\r\nmmc->caps = (pdata && pdata->data_1bit) ? 0 : MMC_CAP_4_BIT_DATA;\r\nmmc->caps |= MMC_CAP_SDIO_IRQ;\r\nmmc->max_blk_size = (1 << 10) - 1;\r\nmmc->max_blk_count = (1 << 15) - 1;\r\nmmc->max_req_size = mmc->max_blk_size * mmc->max_blk_count;\r\nmmc->max_segs = 128;\r\nmmc->max_seg_size = mmc->max_req_size;\r\nhost->mmc = mmc;\r\nhost->pdev = pdev;\r\nspin_lock_init(&host->lock);\r\nhost->irq_mask = 0xffff;\r\nret = jz4740_mmc_request_cd_irq(pdev, host);\r\nif (ret) {\r\ndev_err(&pdev->dev, "Failed to request card detect irq\n");\r\ngoto err_free_gpios;\r\n}\r\nret = request_threaded_irq(host->irq, jz_mmc_irq, jz_mmc_irq_worker, 0,\r\ndev_name(&pdev->dev), host);\r\nif (ret) {\r\ndev_err(&pdev->dev, "Failed to request irq: %d\n", ret);\r\ngoto err_free_card_detect_irq;\r\n}\r\njz4740_mmc_reset(host);\r\njz4740_mmc_clock_disable(host);\r\nsetup_timer(&host->timeout_timer, jz4740_mmc_timeout,\r\n(unsigned long)host);\r\nset_timer_slack(&host->timeout_timer, HZ);\r\nplatform_set_drvdata(pdev, host);\r\nret = mmc_add_host(mmc);\r\nif (ret) {\r\ndev_err(&pdev->dev, "Failed to add mmc host: %d\n", ret);\r\ngoto err_free_irq;\r\n}\r\ndev_info(&pdev->dev, "JZ SD/MMC card driver registered\n");\r\nreturn 0;\r\nerr_free_irq:\r\nfree_irq(host->irq, host);\r\nerr_free_card_detect_irq:\r\nif (host->card_detect_irq >= 0)\r\nfree_irq(host->card_detect_irq, host);\r\nerr_free_gpios:\r\njz4740_mmc_free_gpios(pdev);\r\nerr_gpio_bulk_free:\r\njz_gpio_bulk_free(jz4740_mmc_pins, jz4740_mmc_num_pins(host));\r\nerr_iounmap:\r\niounmap(host->base);\r\nerr_release_mem_region:\r\nrelease_mem_region(host->mem->start, resource_size(host->mem));\r\nerr_clk_put:\r\nclk_put(host->clk);\r\nerr_free_host:\r\nplatform_set_drvdata(pdev, NULL);\r\nmmc_free_host(mmc);\r\nreturn ret;\r\n}\r\nstatic int jz4740_mmc_remove(struct platform_device *pdev)\r\n{\r\nstruct jz4740_mmc_host *host = platform_get_drvdata(pdev);\r\ndel_timer_sync(&host->timeout_timer);\r\njz4740_mmc_set_irq_enabled(host, 0xff, false);\r\njz4740_mmc_reset(host);\r\nmmc_remove_host(host->mmc);\r\nfree_irq(host->irq, host);\r\nif (host->card_detect_irq >= 0)\r\nfree_irq(host->card_detect_irq, host);\r\njz4740_mmc_free_gpios(pdev);\r\njz_gpio_bulk_free(jz4740_mmc_pins, jz4740_mmc_num_pins(host));\r\niounmap(host->base);\r\nrelease_mem_region(host->mem->start, resource_size(host->mem));\r\nclk_put(host->clk);\r\nplatform_set_drvdata(pdev, NULL);\r\nmmc_free_host(host->mmc);\r\nreturn 0;\r\n}\r\nstatic int jz4740_mmc_suspend(struct device *dev)\r\n{\r\nstruct jz4740_mmc_host *host = dev_get_drvdata(dev);\r\nmmc_suspend_host(host->mmc);\r\njz_gpio_bulk_suspend(jz4740_mmc_pins, jz4740_mmc_num_pins(host));\r\nreturn 0;\r\n}\r\nstatic int jz4740_mmc_resume(struct device *dev)\r\n{\r\nstruct jz4740_mmc_host *host = dev_get_drvdata(dev);\r\njz_gpio_bulk_resume(jz4740_mmc_pins, jz4740_mmc_num_pins(host));\r\nmmc_resume_host(host->mmc);\r\nreturn 0;\r\n}
