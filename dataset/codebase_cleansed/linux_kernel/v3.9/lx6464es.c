static int lx_hardware_open(struct lx6464es *chip,\r\nstruct snd_pcm_substream *substream)\r\n{\r\nint err = 0;\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nint channels = runtime->channels;\r\nint is_capture = (substream->stream == SNDRV_PCM_STREAM_CAPTURE);\r\nsnd_pcm_uframes_t period_size = runtime->period_size;\r\nsnd_printd(LXP "allocating pipe for %d channels\n", channels);\r\nerr = lx_pipe_allocate(chip, 0, is_capture, channels);\r\nif (err < 0) {\r\nsnd_printk(KERN_ERR LXP "allocating pipe failed\n");\r\nreturn err;\r\n}\r\nerr = lx_set_granularity(chip, period_size);\r\nif (err < 0) {\r\nsnd_printk(KERN_ERR LXP "setting granularity to %ld failed\n",\r\nperiod_size);\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic int lx_hardware_start(struct lx6464es *chip,\r\nstruct snd_pcm_substream *substream)\r\n{\r\nint err = 0;\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nint is_capture = (substream->stream == SNDRV_PCM_STREAM_CAPTURE);\r\nsnd_printd(LXP "setting stream format\n");\r\nerr = lx_stream_set_format(chip, runtime, 0, is_capture);\r\nif (err < 0) {\r\nsnd_printk(KERN_ERR LXP "setting stream format failed\n");\r\nreturn err;\r\n}\r\nsnd_printd(LXP "starting pipe\n");\r\nerr = lx_pipe_start(chip, 0, is_capture);\r\nif (err < 0) {\r\nsnd_printk(KERN_ERR LXP "starting pipe failed\n");\r\nreturn err;\r\n}\r\nsnd_printd(LXP "waiting for pipe to start\n");\r\nerr = lx_pipe_wait_for_start(chip, 0, is_capture);\r\nif (err < 0) {\r\nsnd_printk(KERN_ERR LXP "waiting for pipe failed\n");\r\nreturn err;\r\n}\r\nreturn err;\r\n}\r\nstatic int lx_hardware_stop(struct lx6464es *chip,\r\nstruct snd_pcm_substream *substream)\r\n{\r\nint err = 0;\r\nint is_capture = (substream->stream == SNDRV_PCM_STREAM_CAPTURE);\r\nsnd_printd(LXP "pausing pipe\n");\r\nerr = lx_pipe_pause(chip, 0, is_capture);\r\nif (err < 0) {\r\nsnd_printk(KERN_ERR LXP "pausing pipe failed\n");\r\nreturn err;\r\n}\r\nsnd_printd(LXP "waiting for pipe to become idle\n");\r\nerr = lx_pipe_wait_for_idle(chip, 0, is_capture);\r\nif (err < 0) {\r\nsnd_printk(KERN_ERR LXP "waiting for pipe failed\n");\r\nreturn err;\r\n}\r\nsnd_printd(LXP "stopping pipe\n");\r\nerr = lx_pipe_stop(chip, 0, is_capture);\r\nif (err < 0) {\r\nsnd_printk(LXP "stopping pipe failed\n");\r\nreturn err;\r\n}\r\nreturn err;\r\n}\r\nstatic int lx_hardware_close(struct lx6464es *chip,\r\nstruct snd_pcm_substream *substream)\r\n{\r\nint err = 0;\r\nint is_capture = (substream->stream == SNDRV_PCM_STREAM_CAPTURE);\r\nsnd_printd(LXP "releasing pipe\n");\r\nerr = lx_pipe_release(chip, 0, is_capture);\r\nif (err < 0) {\r\nsnd_printk(LXP "releasing pipe failed\n");\r\nreturn err;\r\n}\r\nreturn err;\r\n}\r\nstatic int lx_pcm_open(struct snd_pcm_substream *substream)\r\n{\r\nstruct lx6464es *chip = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nint err = 0;\r\nint board_rate;\r\nsnd_printdd("->lx_pcm_open\n");\r\nmutex_lock(&chip->setup_mutex);\r\nruntime->hw = lx_caps;\r\n#if 0\r\nerr = snd_pcm_hw_constraint_integer(runtime,\r\nSNDRV_PCM_HW_PARAM_PERIODS);\r\nif (err < 0) {\r\nsnd_printk(KERN_WARNING LXP "could not constrain periods\n");\r\ngoto exit;\r\n}\r\n#endif\r\nboard_rate = chip->board_sample_rate;\r\nerr = snd_pcm_hw_constraint_minmax(runtime, SNDRV_PCM_HW_PARAM_RATE,\r\nboard_rate, board_rate);\r\nif (err < 0) {\r\nsnd_printk(KERN_WARNING LXP "could not constrain periods\n");\r\ngoto exit;\r\n}\r\nerr = snd_pcm_hw_constraint_minmax(runtime,\r\nSNDRV_PCM_HW_PARAM_PERIOD_SIZE,\r\nMICROBLAZE_IBL_MIN,\r\nMICROBLAZE_IBL_MAX);\r\nif (err < 0) {\r\nsnd_printk(KERN_WARNING LXP\r\n"could not constrain period size\n");\r\ngoto exit;\r\n}\r\nsnd_pcm_hw_constraint_step(runtime, 0,\r\nSNDRV_PCM_HW_PARAM_BUFFER_SIZE, 32);\r\nsnd_pcm_set_sync(substream);\r\nerr = 0;\r\nexit:\r\nruntime->private_data = chip;\r\nmutex_unlock(&chip->setup_mutex);\r\nsnd_printdd("<-lx_pcm_open, %d\n", err);\r\nreturn err;\r\n}\r\nstatic int lx_pcm_close(struct snd_pcm_substream *substream)\r\n{\r\nint err = 0;\r\nsnd_printdd("->lx_pcm_close\n");\r\nreturn err;\r\n}\r\nstatic snd_pcm_uframes_t lx_pcm_stream_pointer(struct snd_pcm_substream\r\n*substream)\r\n{\r\nstruct lx6464es *chip = snd_pcm_substream_chip(substream);\r\nsnd_pcm_uframes_t pos;\r\nunsigned long flags;\r\nint is_capture = (substream->stream == SNDRV_PCM_STREAM_CAPTURE);\r\nstruct lx_stream *lx_stream = is_capture ? &chip->capture_stream :\r\n&chip->playback_stream;\r\nsnd_printdd("->lx_pcm_stream_pointer\n");\r\nspin_lock_irqsave(&chip->lock, flags);\r\npos = lx_stream->frame_pos * substream->runtime->period_size;\r\nspin_unlock_irqrestore(&chip->lock, flags);\r\nsnd_printdd(LXP "stream_pointer at %ld\n", pos);\r\nreturn pos;\r\n}\r\nstatic int lx_pcm_prepare(struct snd_pcm_substream *substream)\r\n{\r\nstruct lx6464es *chip = snd_pcm_substream_chip(substream);\r\nint err = 0;\r\nconst int is_capture = (substream->stream == SNDRV_PCM_STREAM_CAPTURE);\r\nsnd_printdd("->lx_pcm_prepare\n");\r\nmutex_lock(&chip->setup_mutex);\r\nif (chip->hardware_running[is_capture]) {\r\nerr = lx_hardware_stop(chip, substream);\r\nif (err < 0) {\r\nsnd_printk(KERN_ERR LXP "failed to stop hardware. "\r\n"Error code %d\n", err);\r\ngoto exit;\r\n}\r\nerr = lx_hardware_close(chip, substream);\r\nif (err < 0) {\r\nsnd_printk(KERN_ERR LXP "failed to close hardware. "\r\n"Error code %d\n", err);\r\ngoto exit;\r\n}\r\n}\r\nsnd_printd(LXP "opening hardware\n");\r\nerr = lx_hardware_open(chip, substream);\r\nif (err < 0) {\r\nsnd_printk(KERN_ERR LXP "failed to open hardware. "\r\n"Error code %d\n", err);\r\ngoto exit;\r\n}\r\nerr = lx_hardware_start(chip, substream);\r\nif (err < 0) {\r\nsnd_printk(KERN_ERR LXP "failed to start hardware. "\r\n"Error code %d\n", err);\r\ngoto exit;\r\n}\r\nchip->hardware_running[is_capture] = 1;\r\nif (chip->board_sample_rate != substream->runtime->rate) {\r\nif (!err)\r\nchip->board_sample_rate = substream->runtime->rate;\r\n}\r\nexit:\r\nmutex_unlock(&chip->setup_mutex);\r\nreturn err;\r\n}\r\nstatic int lx_pcm_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *hw_params, int is_capture)\r\n{\r\nstruct lx6464es *chip = snd_pcm_substream_chip(substream);\r\nint err = 0;\r\nsnd_printdd("->lx_pcm_hw_params\n");\r\nmutex_lock(&chip->setup_mutex);\r\nerr = snd_pcm_lib_malloc_pages(substream,\r\nparams_buffer_bytes(hw_params));\r\nif (is_capture)\r\nchip->capture_stream.stream = substream;\r\nelse\r\nchip->playback_stream.stream = substream;\r\nmutex_unlock(&chip->setup_mutex);\r\nreturn err;\r\n}\r\nstatic int lx_pcm_hw_params_playback(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *hw_params)\r\n{\r\nreturn lx_pcm_hw_params(substream, hw_params, 0);\r\n}\r\nstatic int lx_pcm_hw_params_capture(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *hw_params)\r\n{\r\nreturn lx_pcm_hw_params(substream, hw_params, 1);\r\n}\r\nstatic int lx_pcm_hw_free(struct snd_pcm_substream *substream)\r\n{\r\nstruct lx6464es *chip = snd_pcm_substream_chip(substream);\r\nint err = 0;\r\nint is_capture = (substream->stream == SNDRV_PCM_STREAM_CAPTURE);\r\nsnd_printdd("->lx_pcm_hw_free\n");\r\nmutex_lock(&chip->setup_mutex);\r\nif (chip->hardware_running[is_capture]) {\r\nerr = lx_hardware_stop(chip, substream);\r\nif (err < 0) {\r\nsnd_printk(KERN_ERR LXP "failed to stop hardware. "\r\n"Error code %d\n", err);\r\ngoto exit;\r\n}\r\nerr = lx_hardware_close(chip, substream);\r\nif (err < 0) {\r\nsnd_printk(KERN_ERR LXP "failed to close hardware. "\r\n"Error code %d\n", err);\r\ngoto exit;\r\n}\r\nchip->hardware_running[is_capture] = 0;\r\n}\r\nerr = snd_pcm_lib_free_pages(substream);\r\nif (is_capture)\r\nchip->capture_stream.stream = 0;\r\nelse\r\nchip->playback_stream.stream = 0;\r\nexit:\r\nmutex_unlock(&chip->setup_mutex);\r\nreturn err;\r\n}\r\nstatic void lx_trigger_start(struct lx6464es *chip, struct lx_stream *lx_stream)\r\n{\r\nstruct snd_pcm_substream *substream = lx_stream->stream;\r\nconst unsigned int is_capture = lx_stream->is_capture;\r\nint err;\r\nconst u32 channels = substream->runtime->channels;\r\nconst u32 bytes_per_frame = channels * 3;\r\nconst u32 period_size = substream->runtime->period_size;\r\nconst u32 periods = substream->runtime->periods;\r\nconst u32 period_bytes = period_size * bytes_per_frame;\r\ndma_addr_t buf = substream->dma_buffer.addr;\r\nint i;\r\nu32 needed, freed;\r\nu32 size_array[5];\r\nfor (i = 0; i != periods; ++i) {\r\nu32 buffer_index = 0;\r\nerr = lx_buffer_ask(chip, 0, is_capture, &needed, &freed,\r\nsize_array);\r\nsnd_printdd(LXP "starting: needed %d, freed %d\n",\r\nneeded, freed);\r\nerr = lx_buffer_give(chip, 0, is_capture, period_bytes,\r\nlower_32_bits(buf), upper_32_bits(buf),\r\n&buffer_index);\r\nsnd_printdd(LXP "starting: buffer index %x on %p (%d bytes)\n",\r\nbuffer_index, (void *)buf, period_bytes);\r\nbuf += period_bytes;\r\n}\r\nerr = lx_buffer_ask(chip, 0, is_capture, &needed, &freed, size_array);\r\nsnd_printdd(LXP "starting: needed %d, freed %d\n", needed, freed);\r\nsnd_printd(LXP "starting: starting stream\n");\r\nerr = lx_stream_start(chip, 0, is_capture);\r\nif (err < 0)\r\nsnd_printk(KERN_ERR LXP "couldn't start stream\n");\r\nelse\r\nlx_stream->status = LX_STREAM_STATUS_RUNNING;\r\nlx_stream->frame_pos = 0;\r\n}\r\nstatic void lx_trigger_stop(struct lx6464es *chip, struct lx_stream *lx_stream)\r\n{\r\nconst unsigned int is_capture = lx_stream->is_capture;\r\nint err;\r\nsnd_printd(LXP "stopping: stopping stream\n");\r\nerr = lx_stream_stop(chip, 0, is_capture);\r\nif (err < 0)\r\nsnd_printk(KERN_ERR LXP "couldn't stop stream\n");\r\nelse\r\nlx_stream->status = LX_STREAM_STATUS_FREE;\r\n}\r\nstatic void lx_trigger_tasklet_dispatch_stream(struct lx6464es *chip,\r\nstruct lx_stream *lx_stream)\r\n{\r\nswitch (lx_stream->status) {\r\ncase LX_STREAM_STATUS_SCHEDULE_RUN:\r\nlx_trigger_start(chip, lx_stream);\r\nbreak;\r\ncase LX_STREAM_STATUS_SCHEDULE_STOP:\r\nlx_trigger_stop(chip, lx_stream);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic void lx_trigger_tasklet(unsigned long data)\r\n{\r\nstruct lx6464es *chip = (struct lx6464es *)data;\r\nunsigned long flags;\r\nsnd_printdd("->lx_trigger_tasklet\n");\r\nspin_lock_irqsave(&chip->lock, flags);\r\nlx_trigger_tasklet_dispatch_stream(chip, &chip->capture_stream);\r\nlx_trigger_tasklet_dispatch_stream(chip, &chip->playback_stream);\r\nspin_unlock_irqrestore(&chip->lock, flags);\r\n}\r\nstatic int lx_pcm_trigger_dispatch(struct lx6464es *chip,\r\nstruct lx_stream *lx_stream, int cmd)\r\n{\r\nint err = 0;\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\nlx_stream->status = LX_STREAM_STATUS_SCHEDULE_RUN;\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\nlx_stream->status = LX_STREAM_STATUS_SCHEDULE_STOP;\r\nbreak;\r\ndefault:\r\nerr = -EINVAL;\r\ngoto exit;\r\n}\r\ntasklet_schedule(&chip->trigger_tasklet);\r\nexit:\r\nreturn err;\r\n}\r\nstatic int lx_pcm_trigger(struct snd_pcm_substream *substream, int cmd)\r\n{\r\nstruct lx6464es *chip = snd_pcm_substream_chip(substream);\r\nconst int is_capture = (substream->stream == SNDRV_PCM_STREAM_CAPTURE);\r\nstruct lx_stream *stream = is_capture ? &chip->capture_stream :\r\n&chip->playback_stream;\r\nsnd_printdd("->lx_pcm_trigger\n");\r\nreturn lx_pcm_trigger_dispatch(chip, stream, cmd);\r\n}\r\nstatic int snd_lx6464es_free(struct lx6464es *chip)\r\n{\r\nsnd_printdd("->snd_lx6464es_free\n");\r\nlx_irq_disable(chip);\r\nif (chip->irq >= 0)\r\nfree_irq(chip->irq, chip);\r\niounmap(chip->port_dsp_bar);\r\nioport_unmap(chip->port_plx_remapped);\r\npci_release_regions(chip->pci);\r\npci_disable_device(chip->pci);\r\nkfree(chip);\r\nreturn 0;\r\n}\r\nstatic int snd_lx6464es_dev_free(struct snd_device *device)\r\n{\r\nreturn snd_lx6464es_free(device->device_data);\r\n}\r\nstatic int lx_init_xilinx_reset(struct lx6464es *chip)\r\n{\r\nint i;\r\nu32 plx_reg = lx_plx_reg_read(chip, ePLX_CHIPSC);\r\nsnd_printdd("->lx_init_xilinx_reset\n");\r\nplx_reg &= ~CHIPSC_RESET_XILINX;\r\nlx_plx_reg_write(chip, ePLX_CHIPSC, plx_reg);\r\nmsleep(1);\r\nlx_plx_reg_write(chip, ePLX_MBOX3, 0);\r\nmsleep(1);\r\nplx_reg |= CHIPSC_RESET_XILINX;\r\nlx_plx_reg_write(chip, ePLX_CHIPSC, plx_reg);\r\nfor (i = 0; i != 100; ++i) {\r\nu32 reg_mbox3;\r\nmsleep(10);\r\nreg_mbox3 = lx_plx_reg_read(chip, ePLX_MBOX3);\r\nif (reg_mbox3) {\r\nsnd_printd(LXP "xilinx reset done\n");\r\nsnd_printdd(LXP "xilinx took %d loops\n", i);\r\nbreak;\r\n}\r\n}\r\nlx_dsp_reg_write(chip, eReg_CSM, 0);\r\nmsleep(600);\r\nreturn 0;\r\n}\r\nstatic int lx_init_xilinx_test(struct lx6464es *chip)\r\n{\r\nu32 reg;\r\nsnd_printdd("->lx_init_xilinx_test\n");\r\nlx_dsp_reg_write(chip, eReg_CSM, 0);\r\nreg = lx_dsp_reg_read(chip, eReg_CSM);\r\nif (reg) {\r\nsnd_printk(KERN_ERR LXP "Problem: Reg_CSM %x.\n", reg);\r\nlx_plx_reg_write(chip, ePLX_PCICR, 1);\r\nreg = lx_dsp_reg_read(chip, eReg_CSM);\r\nif (reg) {\r\nsnd_printk(KERN_ERR LXP "Error: Reg_CSM %x.\n", reg);\r\nreturn -EAGAIN;\r\n}\r\n}\r\nsnd_printd(LXP "Xilinx/MicroBlaze access test successful\n");\r\nreturn 0;\r\n}\r\nstatic int lx_init_ethersound_config(struct lx6464es *chip)\r\n{\r\nint i;\r\nu32 orig_conf_es = lx_dsp_reg_read(chip, eReg_CONFES);\r\nu32 conf_es = (orig_conf_es & CONFES_READ_PART_MASK) |\r\n(64 << IOCR_INPUTS_OFFSET) |\r\n(64 << IOCR_OUTPUTS_OFFSET) |\r\n(FREQ_RATIO_SINGLE_MODE << FREQ_RATIO_OFFSET);\r\nsnd_printdd("->lx_init_ethersound\n");\r\nchip->freq_ratio = FREQ_RATIO_SINGLE_MODE;\r\nlx_dsp_reg_write(chip, eReg_CONFES, conf_es);\r\nfor (i = 0; i != 1000; ++i) {\r\nif (lx_dsp_reg_read(chip, eReg_CSES) & 4) {\r\nsnd_printd(LXP "ethersound initialized after %dms\n",\r\ni);\r\ngoto ethersound_initialized;\r\n}\r\nmsleep(1);\r\n}\r\nsnd_printk(KERN_WARNING LXP\r\n"ethersound could not be initialized after %dms\n", i);\r\nreturn -ETIMEDOUT;\r\nethersound_initialized:\r\nsnd_printd(LXP "ethersound initialized\n");\r\nreturn 0;\r\n}\r\nstatic int lx_init_get_version_features(struct lx6464es *chip)\r\n{\r\nu32 dsp_version;\r\nint err;\r\nsnd_printdd("->lx_init_get_version_features\n");\r\nerr = lx_dsp_get_version(chip, &dsp_version);\r\nif (err == 0) {\r\nu32 freq;\r\nsnd_printk(LXP "DSP version: V%02d.%02d #%d\n",\r\n(dsp_version>>16) & 0xff, (dsp_version>>8) & 0xff,\r\ndsp_version & 0xff);\r\nerr = lx_dsp_get_clock_frequency(chip, &freq);\r\nif (err == 0)\r\nchip->board_sample_rate = freq;\r\nsnd_printd(LXP "actual clock frequency %d\n", freq);\r\n} else {\r\nsnd_printk(KERN_ERR LXP "DSP corrupted \n");\r\nerr = -EAGAIN;\r\n}\r\nreturn err;\r\n}\r\nstatic int lx_set_granularity(struct lx6464es *chip, u32 gran)\r\n{\r\nint err = 0;\r\nu32 snapped_gran = MICROBLAZE_IBL_MIN;\r\nsnd_printdd("->lx_set_granularity\n");\r\nwhile ((snapped_gran < gran) &&\r\n(snapped_gran < MICROBLAZE_IBL_MAX)) {\r\nsnapped_gran *= 2;\r\n}\r\nif (snapped_gran == chip->pcm_granularity)\r\nreturn 0;\r\nerr = lx_dsp_set_granularity(chip, snapped_gran);\r\nif (err < 0) {\r\nsnd_printk(KERN_WARNING LXP "could not set granularity\n");\r\nerr = -EAGAIN;\r\n}\r\nif (snapped_gran != gran)\r\nsnd_printk(LXP "snapped blocksize to %d\n", snapped_gran);\r\nsnd_printd(LXP "set blocksize on board %d\n", snapped_gran);\r\nchip->pcm_granularity = snapped_gran;\r\nreturn err;\r\n}\r\nstatic int lx_init_dsp(struct lx6464es *chip)\r\n{\r\nint err;\r\nint i;\r\nsnd_printdd("->lx_init_dsp\n");\r\nsnd_printd(LXP "initialize board\n");\r\nerr = lx_init_xilinx_reset(chip);\r\nif (err)\r\nreturn err;\r\nsnd_printd(LXP "testing board\n");\r\nerr = lx_init_xilinx_test(chip);\r\nif (err)\r\nreturn err;\r\nsnd_printd(LXP "initialize ethersound configuration\n");\r\nerr = lx_init_ethersound_config(chip);\r\nif (err)\r\nreturn err;\r\nlx_irq_enable(chip);\r\nfor (i = 0; i != 1000; ++i) {\r\nerr = lx_dsp_get_mac(chip);\r\nif (err)\r\nreturn err;\r\nif (chip->mac_address[0] || chip->mac_address[1] || chip->mac_address[2] ||\r\nchip->mac_address[3] || chip->mac_address[4] || chip->mac_address[5])\r\ngoto mac_ready;\r\nmsleep(1);\r\n}\r\nreturn -ETIMEDOUT;\r\nmac_ready:\r\nsnd_printd(LXP "mac address ready read after: %dms\n", i);\r\nsnd_printk(LXP "mac address: %02X.%02X.%02X.%02X.%02X.%02X\n",\r\nchip->mac_address[0], chip->mac_address[1], chip->mac_address[2],\r\nchip->mac_address[3], chip->mac_address[4], chip->mac_address[5]);\r\nerr = lx_init_get_version_features(chip);\r\nif (err)\r\nreturn err;\r\nlx_set_granularity(chip, MICROBLAZE_IBL_DEFAULT);\r\nchip->playback_mute = 0;\r\nreturn err;\r\n}\r\nstatic int lx_pcm_create(struct lx6464es *chip)\r\n{\r\nint err;\r\nstruct snd_pcm *pcm;\r\nu32 size = 64 *\r\n3 *\r\nMAX_STREAM_BUFFER *\r\nMICROBLAZE_IBL_MAX *\r\n2;\r\nsize = PAGE_ALIGN(size);\r\nerr = snd_pcm_new(chip->card, (char *)card_name, 0,\r\n1, 1, &pcm);\r\nif (err < 0)\r\nreturn err;\r\npcm->private_data = chip;\r\nsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &lx_ops_playback);\r\nsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &lx_ops_capture);\r\npcm->info_flags = 0;\r\nstrcpy(pcm->name, card_name);\r\nerr = snd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_DEV,\r\nsnd_dma_pci_data(chip->pci),\r\nsize, size);\r\nif (err < 0)\r\nreturn err;\r\nchip->pcm = pcm;\r\nchip->capture_stream.is_capture = 1;\r\nreturn 0;\r\n}\r\nstatic int lx_control_playback_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;\r\nuinfo->count = 1;\r\nuinfo->value.integer.min = 0;\r\nuinfo->value.integer.max = 1;\r\nreturn 0;\r\n}\r\nstatic int lx_control_playback_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct lx6464es *chip = snd_kcontrol_chip(kcontrol);\r\nucontrol->value.integer.value[0] = chip->playback_mute;\r\nreturn 0;\r\n}\r\nstatic int lx_control_playback_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct lx6464es *chip = snd_kcontrol_chip(kcontrol);\r\nint changed = 0;\r\nint current_value = chip->playback_mute;\r\nif (current_value != ucontrol->value.integer.value[0]) {\r\nlx_level_unmute(chip, 0, !current_value);\r\nchip->playback_mute = !current_value;\r\nchanged = 1;\r\n}\r\nreturn changed;\r\n}\r\nstatic void lx_proc_levels_read(struct snd_info_entry *entry,\r\nstruct snd_info_buffer *buffer)\r\n{\r\nu32 levels[64];\r\nint err;\r\nint i, j;\r\nstruct lx6464es *chip = entry->private_data;\r\nsnd_iprintf(buffer, "capture levels:\n");\r\nerr = lx_level_peaks(chip, 1, 64, levels);\r\nif (err < 0)\r\nreturn;\r\nfor (i = 0; i != 8; ++i) {\r\nfor (j = 0; j != 8; ++j)\r\nsnd_iprintf(buffer, "%08x ", levels[i*8+j]);\r\nsnd_iprintf(buffer, "\n");\r\n}\r\nsnd_iprintf(buffer, "\nplayback levels:\n");\r\nerr = lx_level_peaks(chip, 0, 64, levels);\r\nif (err < 0)\r\nreturn;\r\nfor (i = 0; i != 8; ++i) {\r\nfor (j = 0; j != 8; ++j)\r\nsnd_iprintf(buffer, "%08x ", levels[i*8+j]);\r\nsnd_iprintf(buffer, "\n");\r\n}\r\nsnd_iprintf(buffer, "\n");\r\n}\r\nstatic int lx_proc_create(struct snd_card *card, struct lx6464es *chip)\r\n{\r\nstruct snd_info_entry *entry;\r\nint err = snd_card_proc_new(card, "levels", &entry);\r\nif (err < 0)\r\nreturn err;\r\nsnd_info_set_text_ops(entry, chip, lx_proc_levels_read);\r\nreturn 0;\r\n}\r\nstatic int snd_lx6464es_create(struct snd_card *card,\r\nstruct pci_dev *pci,\r\nstruct lx6464es **rchip)\r\n{\r\nstruct lx6464es *chip;\r\nint err;\r\nstatic struct snd_device_ops ops = {\r\n.dev_free = snd_lx6464es_dev_free,\r\n};\r\nsnd_printdd("->snd_lx6464es_create\n");\r\n*rchip = NULL;\r\nerr = pci_enable_device(pci);\r\nif (err < 0)\r\nreturn err;\r\npci_set_master(pci);\r\nerr = pci_set_dma_mask(pci, DMA_BIT_MASK(32));\r\nif (err < 0) {\r\nsnd_printk(KERN_ERR "architecture does not support "\r\n"32bit PCI busmaster DMA\n");\r\npci_disable_device(pci);\r\nreturn -ENXIO;\r\n}\r\nchip = kzalloc(sizeof(*chip), GFP_KERNEL);\r\nif (chip == NULL) {\r\nerr = -ENOMEM;\r\ngoto alloc_failed;\r\n}\r\nchip->card = card;\r\nchip->pci = pci;\r\nchip->irq = -1;\r\nspin_lock_init(&chip->lock);\r\nspin_lock_init(&chip->msg_lock);\r\nmutex_init(&chip->setup_mutex);\r\ntasklet_init(&chip->trigger_tasklet, lx_trigger_tasklet,\r\n(unsigned long)chip);\r\ntasklet_init(&chip->tasklet_capture, lx_tasklet_capture,\r\n(unsigned long)chip);\r\ntasklet_init(&chip->tasklet_playback, lx_tasklet_playback,\r\n(unsigned long)chip);\r\nerr = pci_request_regions(pci, card_name);\r\nif (err < 0)\r\ngoto request_regions_failed;\r\nchip->port_plx = pci_resource_start(pci, 1);\r\nchip->port_plx_remapped = ioport_map(chip->port_plx,\r\npci_resource_len(pci, 1));\r\nchip->port_dsp_bar = pci_ioremap_bar(pci, 2);\r\nerr = request_irq(pci->irq, lx_interrupt, IRQF_SHARED,\r\nKBUILD_MODNAME, chip);\r\nif (err) {\r\nsnd_printk(KERN_ERR LXP "unable to grab IRQ %d\n", pci->irq);\r\ngoto request_irq_failed;\r\n}\r\nchip->irq = pci->irq;\r\nerr = snd_device_new(card, SNDRV_DEV_LOWLEVEL, chip, &ops);\r\nif (err < 0)\r\ngoto device_new_failed;\r\nerr = lx_init_dsp(chip);\r\nif (err < 0) {\r\nsnd_printk(KERN_ERR LXP "error during DSP initialization\n");\r\nreturn err;\r\n}\r\nerr = lx_pcm_create(chip);\r\nif (err < 0)\r\nreturn err;\r\nerr = lx_proc_create(card, chip);\r\nif (err < 0)\r\nreturn err;\r\nerr = snd_ctl_add(card, snd_ctl_new1(&lx_control_playback_switch,\r\nchip));\r\nif (err < 0)\r\nreturn err;\r\nsnd_card_set_dev(card, &pci->dev);\r\n*rchip = chip;\r\nreturn 0;\r\ndevice_new_failed:\r\nfree_irq(pci->irq, chip);\r\nrequest_irq_failed:\r\npci_release_regions(pci);\r\nrequest_regions_failed:\r\nkfree(chip);\r\nalloc_failed:\r\npci_disable_device(pci);\r\nreturn err;\r\n}\r\nstatic int snd_lx6464es_probe(struct pci_dev *pci,\r\nconst struct pci_device_id *pci_id)\r\n{\r\nstatic int dev;\r\nstruct snd_card *card;\r\nstruct lx6464es *chip;\r\nint err;\r\nsnd_printdd("->snd_lx6464es_probe\n");\r\nif (dev >= SNDRV_CARDS)\r\nreturn -ENODEV;\r\nif (!enable[dev]) {\r\ndev++;\r\nreturn -ENOENT;\r\n}\r\nerr = snd_card_create(index[dev], id[dev], THIS_MODULE, 0, &card);\r\nif (err < 0)\r\nreturn err;\r\nerr = snd_lx6464es_create(card, pci, &chip);\r\nif (err < 0) {\r\nsnd_printk(KERN_ERR LXP "error during snd_lx6464es_create\n");\r\ngoto out_free;\r\n}\r\nstrcpy(card->driver, "LX6464ES");\r\nsprintf(card->id, "LX6464ES_%02X%02X%02X",\r\nchip->mac_address[3], chip->mac_address[4], chip->mac_address[5]);\r\nsprintf(card->shortname, "LX6464ES %02X.%02X.%02X.%02X.%02X.%02X",\r\nchip->mac_address[0], chip->mac_address[1], chip->mac_address[2],\r\nchip->mac_address[3], chip->mac_address[4], chip->mac_address[5]);\r\nsprintf(card->longname, "%s at 0x%lx, 0x%p, irq %i",\r\ncard->shortname, chip->port_plx,\r\nchip->port_dsp_bar, chip->irq);\r\nerr = snd_card_register(card);\r\nif (err < 0)\r\ngoto out_free;\r\nsnd_printdd(LXP "initialization successful\n");\r\npci_set_drvdata(pci, card);\r\ndev++;\r\nreturn 0;\r\nout_free:\r\nsnd_card_free(card);\r\nreturn err;\r\n}\r\nstatic void snd_lx6464es_remove(struct pci_dev *pci)\r\n{\r\nsnd_card_free(pci_get_drvdata(pci));\r\npci_set_drvdata(pci, NULL);\r\n}
