static void spu_write_wait(void)\r\n{\r\nint time_count;\r\ntime_count = 0;\r\nwhile (1) {\r\nif (!(readl(G2_FIFO) & 0x11))\r\nbreak;\r\ntime_count++;\r\nif (time_count > 0x10000) {\r\nsnd_printk\r\n("WARNING: G2 FIFO appears to be blocked.\n");\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic void spu_memset(u32 toi, u32 what, int length)\r\n{\r\nint i;\r\nunsigned long flags;\r\nif (snd_BUG_ON(length % 4))\r\nreturn;\r\nfor (i = 0; i < length; i++) {\r\nif (!(i % 8))\r\nspu_write_wait();\r\nlocal_irq_save(flags);\r\nwritel(what, toi + SPU_MEMORY_BASE);\r\nlocal_irq_restore(flags);\r\ntoi++;\r\n}\r\n}\r\nstatic void spu_memload(u32 toi, void *from, int length)\r\n{\r\nunsigned long flags;\r\nu32 *froml = from;\r\nu32 __iomem *to = (u32 __iomem *) (SPU_MEMORY_BASE + toi);\r\nint i;\r\nu32 val;\r\nlength = DIV_ROUND_UP(length, 4);\r\nspu_write_wait();\r\nfor (i = 0; i < length; i++) {\r\nif (!(i % 8))\r\nspu_write_wait();\r\nval = *froml;\r\nlocal_irq_save(flags);\r\nwritel(val, to);\r\nlocal_irq_restore(flags);\r\nfroml++;\r\nto++;\r\n}\r\n}\r\nstatic void spu_disable(void)\r\n{\r\nint i;\r\nunsigned long flags;\r\nu32 regval;\r\nspu_write_wait();\r\nregval = readl(ARM_RESET_REGISTER);\r\nregval |= 1;\r\nspu_write_wait();\r\nlocal_irq_save(flags);\r\nwritel(regval, ARM_RESET_REGISTER);\r\nlocal_irq_restore(flags);\r\nfor (i = 0; i < 64; i++) {\r\nspu_write_wait();\r\nregval = readl(SPU_REGISTER_BASE + (i * 0x80));\r\nregval = (regval & ~0x4000) | 0x8000;\r\nspu_write_wait();\r\nlocal_irq_save(flags);\r\nwritel(regval, SPU_REGISTER_BASE + (i * 0x80));\r\nlocal_irq_restore(flags);\r\n}\r\n}\r\nstatic void spu_enable(void)\r\n{\r\nunsigned long flags;\r\nu32 regval = readl(ARM_RESET_REGISTER);\r\nregval &= ~1;\r\nspu_write_wait();\r\nlocal_irq_save(flags);\r\nwritel(regval, ARM_RESET_REGISTER);\r\nlocal_irq_restore(flags);\r\n}\r\nstatic void spu_reset(void)\r\n{\r\nunsigned long flags;\r\nspu_disable();\r\nspu_memset(0, 0, 0x200000 / 4);\r\nlocal_irq_save(flags);\r\n__raw_writel(0xea000002, SPU_MEMORY_BASE);\r\nlocal_irq_restore(flags);\r\nspu_enable();\r\n}\r\nstatic void aica_chn_start(void)\r\n{\r\nunsigned long flags;\r\nspu_write_wait();\r\nlocal_irq_save(flags);\r\nwritel(AICA_CMD_KICK | AICA_CMD_START, (u32 *) AICA_CONTROL_POINT);\r\nlocal_irq_restore(flags);\r\n}\r\nstatic void aica_chn_halt(void)\r\n{\r\nunsigned long flags;\r\nspu_write_wait();\r\nlocal_irq_save(flags);\r\nwritel(AICA_CMD_KICK | AICA_CMD_STOP, (u32 *) AICA_CONTROL_POINT);\r\nlocal_irq_restore(flags);\r\n}\r\nstatic int aica_dma_transfer(int channels, int buffer_size,\r\nstruct snd_pcm_substream *substream)\r\n{\r\nint q, err, period_offset;\r\nstruct snd_card_aica *dreamcastcard;\r\nstruct snd_pcm_runtime *runtime;\r\nunsigned long flags;\r\nerr = 0;\r\ndreamcastcard = substream->pcm->private_data;\r\nperiod_offset = dreamcastcard->clicks;\r\nperiod_offset %= (AICA_PERIOD_NUMBER / channels);\r\nruntime = substream->runtime;\r\nfor (q = 0; q < channels; q++) {\r\nlocal_irq_save(flags);\r\nerr = dma_xfer(AICA_DMA_CHANNEL,\r\n(unsigned long) (runtime->dma_area +\r\n(AICA_BUFFER_SIZE * q) /\r\nchannels +\r\nAICA_PERIOD_SIZE *\r\nperiod_offset),\r\nAICA_CHANNEL0_OFFSET + q * CHANNEL_OFFSET +\r\nAICA_PERIOD_SIZE * period_offset,\r\nbuffer_size / channels, AICA_DMA_MODE);\r\nif (unlikely(err < 0)) {\r\nlocal_irq_restore(flags);\r\nbreak;\r\n}\r\ndma_wait_for_completion(AICA_DMA_CHANNEL);\r\nlocal_irq_restore(flags);\r\n}\r\nreturn err;\r\n}\r\nstatic void startup_aica(struct snd_card_aica *dreamcastcard)\r\n{\r\nspu_memload(AICA_CHANNEL0_CONTROL_OFFSET,\r\ndreamcastcard->channel, sizeof(struct aica_channel));\r\naica_chn_start();\r\n}\r\nstatic void run_spu_dma(struct work_struct *work)\r\n{\r\nint buffer_size;\r\nstruct snd_pcm_runtime *runtime;\r\nstruct snd_card_aica *dreamcastcard;\r\ndreamcastcard =\r\ncontainer_of(work, struct snd_card_aica, spu_dma_work);\r\nruntime = dreamcastcard->substream->runtime;\r\nif (unlikely(dreamcastcard->dma_check == 0)) {\r\nbuffer_size =\r\nframes_to_bytes(runtime, runtime->buffer_size);\r\nif (runtime->channels > 1)\r\ndreamcastcard->channel->flags |= 0x01;\r\naica_dma_transfer(runtime->channels, buffer_size,\r\ndreamcastcard->substream);\r\nstartup_aica(dreamcastcard);\r\ndreamcastcard->clicks =\r\nbuffer_size / (AICA_PERIOD_SIZE * runtime->channels);\r\nreturn;\r\n} else {\r\naica_dma_transfer(runtime->channels,\r\nAICA_PERIOD_SIZE * runtime->channels,\r\ndreamcastcard->substream);\r\nsnd_pcm_period_elapsed(dreamcastcard->substream);\r\ndreamcastcard->clicks++;\r\nif (unlikely(dreamcastcard->clicks >= AICA_PERIOD_NUMBER))\r\ndreamcastcard->clicks %= AICA_PERIOD_NUMBER;\r\nmod_timer(&dreamcastcard->timer, jiffies + 1);\r\n}\r\n}\r\nstatic void aica_period_elapsed(unsigned long timer_var)\r\n{\r\nint play_period;\r\nstruct snd_pcm_runtime *runtime;\r\nstruct snd_pcm_substream *substream;\r\nstruct snd_card_aica *dreamcastcard;\r\nsubstream = (struct snd_pcm_substream *) timer_var;\r\nruntime = substream->runtime;\r\ndreamcastcard = substream->pcm->private_data;\r\nplay_period =\r\nframes_to_bytes(runtime,\r\nreadl\r\n(AICA_CONTROL_CHANNEL_SAMPLE_NUMBER)) /\r\nAICA_PERIOD_SIZE;\r\nif (play_period == dreamcastcard->current_period) {\r\nmod_timer(&(dreamcastcard->timer), jiffies + 1);\r\nreturn;\r\n}\r\nif (runtime->channels > 1)\r\ndreamcastcard->current_period = play_period;\r\nif (unlikely(dreamcastcard->dma_check == 0))\r\ndreamcastcard->dma_check = 1;\r\nqueue_work(aica_queue, &(dreamcastcard->spu_dma_work));\r\n}\r\nstatic void spu_begin_dma(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_card_aica *dreamcastcard;\r\nstruct snd_pcm_runtime *runtime;\r\nruntime = substream->runtime;\r\ndreamcastcard = substream->pcm->private_data;\r\nqueue_work(aica_queue, &(dreamcastcard->spu_dma_work));\r\nif (unlikely(dreamcastcard->timer.data)) {\r\nmod_timer(&dreamcastcard->timer, jiffies + 4);\r\nreturn;\r\n}\r\ninit_timer(&(dreamcastcard->timer));\r\ndreamcastcard->timer.data = (unsigned long) substream;\r\ndreamcastcard->timer.function = aica_period_elapsed;\r\ndreamcastcard->timer.expires = jiffies + 4;\r\nadd_timer(&(dreamcastcard->timer));\r\n}\r\nstatic int snd_aicapcm_pcm_open(struct snd_pcm_substream\r\n*substream)\r\n{\r\nstruct snd_pcm_runtime *runtime;\r\nstruct aica_channel *channel;\r\nstruct snd_card_aica *dreamcastcard;\r\nif (!enable)\r\nreturn -ENOENT;\r\ndreamcastcard = substream->pcm->private_data;\r\nchannel = kmalloc(sizeof(struct aica_channel), GFP_KERNEL);\r\nif (!channel)\r\nreturn -ENOMEM;\r\nchannel->sfmt = SM_8BIT;\r\nchannel->cmd = AICA_CMD_START;\r\nchannel->vol = dreamcastcard->master_volume;\r\nchannel->pan = 0x80;\r\nchannel->pos = 0;\r\nchannel->flags = 0;\r\ndreamcastcard->channel = channel;\r\nruntime = substream->runtime;\r\nruntime->hw = snd_pcm_aica_playback_hw;\r\nspu_enable();\r\ndreamcastcard->clicks = 0;\r\ndreamcastcard->current_period = 0;\r\ndreamcastcard->dma_check = 0;\r\nreturn 0;\r\n}\r\nstatic int snd_aicapcm_pcm_close(struct snd_pcm_substream\r\n*substream)\r\n{\r\nstruct snd_card_aica *dreamcastcard = substream->pcm->private_data;\r\nflush_workqueue(aica_queue);\r\nif (dreamcastcard->timer.data)\r\ndel_timer(&dreamcastcard->timer);\r\nkfree(dreamcastcard->channel);\r\nspu_disable();\r\nreturn 0;\r\n}\r\nstatic int snd_aicapcm_pcm_hw_free(struct snd_pcm_substream\r\n*substream)\r\n{\r\nreturn snd_pcm_lib_free_pages(substream);\r\n}\r\nstatic int snd_aicapcm_pcm_hw_params(struct snd_pcm_substream\r\n*substream, struct snd_pcm_hw_params\r\n*hw_params)\r\n{\r\nreturn\r\nsnd_pcm_lib_malloc_pages(substream,\r\nparams_buffer_bytes(hw_params));\r\n}\r\nstatic int snd_aicapcm_pcm_prepare(struct snd_pcm_substream\r\n*substream)\r\n{\r\nstruct snd_card_aica *dreamcastcard = substream->pcm->private_data;\r\nif ((substream->runtime)->format == SNDRV_PCM_FORMAT_S16_LE)\r\ndreamcastcard->channel->sfmt = SM_16BIT;\r\ndreamcastcard->channel->freq = substream->runtime->rate;\r\ndreamcastcard->substream = substream;\r\nreturn 0;\r\n}\r\nstatic int snd_aicapcm_pcm_trigger(struct snd_pcm_substream\r\n*substream, int cmd)\r\n{\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\nspu_begin_dma(substream);\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\naica_chn_halt();\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic unsigned long snd_aicapcm_pcm_pointer(struct snd_pcm_substream\r\n*substream)\r\n{\r\nreturn readl(AICA_CONTROL_CHANNEL_SAMPLE_NUMBER);\r\n}\r\nstatic int __init snd_aicapcmchip(struct snd_card_aica\r\n*dreamcastcard, int pcm_index)\r\n{\r\nstruct snd_pcm *pcm;\r\nint err;\r\nerr =\r\nsnd_pcm_new(dreamcastcard->card, "AICA PCM", pcm_index, 1, 0,\r\n&pcm);\r\nif (unlikely(err < 0))\r\nreturn err;\r\npcm->private_data = dreamcastcard;\r\nstrcpy(pcm->name, "AICA PCM");\r\nsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK,\r\n&snd_aicapcm_playback_ops);\r\nerr =\r\nsnd_pcm_lib_preallocate_pages_for_all(pcm,\r\nSNDRV_DMA_TYPE_CONTINUOUS,\r\nsnd_dma_continuous_data\r\n(GFP_KERNEL),\r\nAICA_BUFFER_SIZE,\r\nAICA_BUFFER_SIZE);\r\nreturn err;\r\n}\r\nstatic int aica_pcmswitch_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nucontrol->value.integer.value[0] = 1;\r\nreturn 0;\r\n}\r\nstatic int aica_pcmswitch_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nif (ucontrol->value.integer.value[0] == 1)\r\nreturn 0;\r\nelse\r\naica_chn_halt();\r\nreturn 0;\r\n}\r\nstatic int aica_pcmvolume_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\r\nuinfo->count = 1;\r\nuinfo->value.integer.min = 0;\r\nuinfo->value.integer.max = 0xFF;\r\nreturn 0;\r\n}\r\nstatic int aica_pcmvolume_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_card_aica *dreamcastcard;\r\ndreamcastcard = kcontrol->private_data;\r\nif (unlikely(!dreamcastcard->channel))\r\nreturn -ETXTBSY;\r\nucontrol->value.integer.value[0] = dreamcastcard->channel->vol;\r\nreturn 0;\r\n}\r\nstatic int aica_pcmvolume_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_card_aica *dreamcastcard;\r\nunsigned int vol;\r\ndreamcastcard = kcontrol->private_data;\r\nif (unlikely(!dreamcastcard->channel))\r\nreturn -ETXTBSY;\r\nvol = ucontrol->value.integer.value[0];\r\nif (vol > 0xff)\r\nreturn -EINVAL;\r\nif (unlikely(dreamcastcard->channel->vol == vol))\r\nreturn 0;\r\ndreamcastcard->channel->vol = ucontrol->value.integer.value[0];\r\ndreamcastcard->master_volume = ucontrol->value.integer.value[0];\r\nspu_memload(AICA_CHANNEL0_CONTROL_OFFSET,\r\ndreamcastcard->channel, sizeof(struct aica_channel));\r\nreturn 1;\r\n}\r\nstatic int load_aica_firmware(void)\r\n{\r\nint err;\r\nconst struct firmware *fw_entry;\r\nspu_reset();\r\nerr = request_firmware(&fw_entry, "aica_firmware.bin", &pd->dev);\r\nif (unlikely(err))\r\nreturn err;\r\nspu_disable();\r\nspu_memload(0, fw_entry->data, fw_entry->size);\r\nspu_enable();\r\nrelease_firmware(fw_entry);\r\nreturn err;\r\n}\r\nstatic int add_aicamixer_controls(struct snd_card_aica *dreamcastcard)\r\n{\r\nint err;\r\nerr = snd_ctl_add\r\n(dreamcastcard->card,\r\nsnd_ctl_new1(&snd_aica_pcmvolume_control, dreamcastcard));\r\nif (unlikely(err < 0))\r\nreturn err;\r\nerr = snd_ctl_add\r\n(dreamcastcard->card,\r\nsnd_ctl_new1(&snd_aica_pcmswitch_control, dreamcastcard));\r\nif (unlikely(err < 0))\r\nreturn err;\r\nreturn 0;\r\n}\r\nstatic int snd_aica_remove(struct platform_device *devptr)\r\n{\r\nstruct snd_card_aica *dreamcastcard;\r\ndreamcastcard = platform_get_drvdata(devptr);\r\nif (unlikely(!dreamcastcard))\r\nreturn -ENODEV;\r\nsnd_card_free(dreamcastcard->card);\r\nkfree(dreamcastcard);\r\nplatform_set_drvdata(devptr, NULL);\r\nreturn 0;\r\n}\r\nstatic int snd_aica_probe(struct platform_device *devptr)\r\n{\r\nint err;\r\nstruct snd_card_aica *dreamcastcard;\r\ndreamcastcard = kmalloc(sizeof(struct snd_card_aica), GFP_KERNEL);\r\nif (unlikely(!dreamcastcard))\r\nreturn -ENOMEM;\r\nerr = snd_card_create(index, SND_AICA_DRIVER, THIS_MODULE, 0,\r\n&dreamcastcard->card);\r\nif (unlikely(err < 0)) {\r\nkfree(dreamcastcard);\r\nreturn err;\r\n}\r\nstrcpy(dreamcastcard->card->driver, "snd_aica");\r\nstrcpy(dreamcastcard->card->shortname, SND_AICA_DRIVER);\r\nstrcpy(dreamcastcard->card->longname,\r\n"Yamaha AICA Super Intelligent Sound Processor for SEGA Dreamcast");\r\nINIT_WORK(&(dreamcastcard->spu_dma_work), run_spu_dma);\r\nerr = snd_aicapcmchip(dreamcastcard, 0);\r\nif (unlikely(err < 0))\r\ngoto freedreamcast;\r\nsnd_card_set_dev(dreamcastcard->card, &devptr->dev);\r\ndreamcastcard->timer.data = 0;\r\ndreamcastcard->channel = NULL;\r\nerr = add_aicamixer_controls(dreamcastcard);\r\nif (unlikely(err < 0))\r\ngoto freedreamcast;\r\nerr = snd_card_register(dreamcastcard->card);\r\nif (unlikely(err < 0))\r\ngoto freedreamcast;\r\nplatform_set_drvdata(devptr, dreamcastcard);\r\naica_queue = create_workqueue(CARD_NAME);\r\nif (unlikely(!aica_queue))\r\ngoto freedreamcast;\r\nsnd_printk\r\n("ALSA Driver for Yamaha AICA Super Intelligent Sound Processor\n");\r\nreturn 0;\r\nfreedreamcast:\r\nsnd_card_free(dreamcastcard->card);\r\nkfree(dreamcastcard);\r\nreturn err;\r\n}\r\nstatic int __init aica_init(void)\r\n{\r\nint err;\r\nerr = platform_driver_register(&snd_aica_driver);\r\nif (unlikely(err < 0))\r\nreturn err;\r\npd = platform_device_register_simple(SND_AICA_DRIVER, -1,\r\naica_memory_space, 2);\r\nif (IS_ERR(pd)) {\r\nplatform_driver_unregister(&snd_aica_driver);\r\nreturn PTR_ERR(pd);\r\n}\r\nreturn load_aica_firmware();\r\n}\r\nstatic void __exit aica_exit(void)\r\n{\r\nif (likely(aica_queue))\r\ndestroy_workqueue(aica_queue);\r\nplatform_device_unregister(pd);\r\nplatform_driver_unregister(&snd_aica_driver);\r\nspu_reset();\r\n}
