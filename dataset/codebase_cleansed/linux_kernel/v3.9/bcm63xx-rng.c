static int bcm63xx_rng_init(struct hwrng *rng)\r\n{\r\nstruct bcm63xx_rng_priv *priv = to_rng_priv(rng);\r\nu32 val;\r\nval = bcm_readl(priv->regs + RNG_CTRL);\r\nval |= RNG_EN;\r\nbcm_writel(val, priv->regs + RNG_CTRL);\r\nreturn 0;\r\n}\r\nstatic void bcm63xx_rng_cleanup(struct hwrng *rng)\r\n{\r\nstruct bcm63xx_rng_priv *priv = to_rng_priv(rng);\r\nu32 val;\r\nval = bcm_readl(priv->regs + RNG_CTRL);\r\nval &= ~RNG_EN;\r\nbcm_writel(val, priv->regs + RNG_CTRL);\r\n}\r\nstatic int bcm63xx_rng_data_present(struct hwrng *rng, int wait)\r\n{\r\nstruct bcm63xx_rng_priv *priv = to_rng_priv(rng);\r\nreturn bcm_readl(priv->regs + RNG_STAT) & RNG_AVAIL_MASK;\r\n}\r\nstatic int bcm63xx_rng_data_read(struct hwrng *rng, u32 *data)\r\n{\r\nstruct bcm63xx_rng_priv *priv = to_rng_priv(rng);\r\n*data = bcm_readl(priv->regs + RNG_DATA);\r\nreturn 4;\r\n}\r\nstatic int bcm63xx_rng_probe(struct platform_device *pdev)\r\n{\r\nstruct resource *r;\r\nstruct clk *clk;\r\nint ret;\r\nstruct bcm63xx_rng_priv *priv;\r\nstruct hwrng *rng;\r\nr = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!r) {\r\ndev_err(&pdev->dev, "no iomem resource\n");\r\nret = -ENXIO;\r\ngoto out;\r\n}\r\npriv = kzalloc(sizeof(*priv), GFP_KERNEL);\r\nif (!priv) {\r\ndev_err(&pdev->dev, "no memory for private structure\n");\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nrng = kzalloc(sizeof(*rng), GFP_KERNEL);\r\nif (!rng) {\r\ndev_err(&pdev->dev, "no memory for rng structure\n");\r\nret = -ENOMEM;\r\ngoto out_free_priv;\r\n}\r\nplatform_set_drvdata(pdev, rng);\r\nrng->priv = (unsigned long)priv;\r\nrng->name = pdev->name;\r\nrng->init = bcm63xx_rng_init;\r\nrng->cleanup = bcm63xx_rng_cleanup;\r\nrng->data_present = bcm63xx_rng_data_present;\r\nrng->data_read = bcm63xx_rng_data_read;\r\nclk = clk_get(&pdev->dev, "ipsec");\r\nif (IS_ERR(clk)) {\r\ndev_err(&pdev->dev, "no clock for device\n");\r\nret = PTR_ERR(clk);\r\ngoto out_free_rng;\r\n}\r\npriv->clk = clk;\r\nif (!devm_request_mem_region(&pdev->dev, r->start,\r\nresource_size(r), pdev->name)) {\r\ndev_err(&pdev->dev, "request mem failed");\r\nret = -ENOMEM;\r\ngoto out_free_rng;\r\n}\r\npriv->regs = devm_ioremap_nocache(&pdev->dev, r->start,\r\nresource_size(r));\r\nif (!priv->regs) {\r\ndev_err(&pdev->dev, "ioremap failed");\r\nret = -ENOMEM;\r\ngoto out_free_rng;\r\n}\r\nclk_enable(clk);\r\nret = hwrng_register(rng);\r\nif (ret) {\r\ndev_err(&pdev->dev, "failed to register rng device\n");\r\ngoto out_clk_disable;\r\n}\r\ndev_info(&pdev->dev, "registered RNG driver\n");\r\nreturn 0;\r\nout_clk_disable:\r\nclk_disable(clk);\r\nout_free_rng:\r\nplatform_set_drvdata(pdev, NULL);\r\nkfree(rng);\r\nout_free_priv:\r\nkfree(priv);\r\nout:\r\nreturn ret;\r\n}\r\nstatic int bcm63xx_rng_remove(struct platform_device *pdev)\r\n{\r\nstruct hwrng *rng = platform_get_drvdata(pdev);\r\nstruct bcm63xx_rng_priv *priv = to_rng_priv(rng);\r\nhwrng_unregister(rng);\r\nclk_disable(priv->clk);\r\nkfree(priv);\r\nkfree(rng);\r\nplatform_set_drvdata(pdev, NULL);\r\nreturn 0;\r\n}
