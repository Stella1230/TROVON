static unsigned int tscadc_readl(struct ti_tscadc_dev *tsadc, unsigned int reg)\r\n{\r\nunsigned int val;\r\nregmap_read(tsadc->regmap_tscadc, reg, &val);\r\nreturn val;\r\n}\r\nstatic void tscadc_writel(struct ti_tscadc_dev *tsadc, unsigned int reg,\r\nunsigned int val)\r\n{\r\nregmap_write(tsadc->regmap_tscadc, reg, val);\r\n}\r\nstatic void tscadc_idle_config(struct ti_tscadc_dev *config)\r\n{\r\nunsigned int idleconfig;\r\nidleconfig = STEPCONFIG_YNN | STEPCONFIG_INM_ADCREFM |\r\nSTEPCONFIG_INP_ADCREFM | STEPCONFIG_YPN;\r\ntscadc_writel(config, REG_IDLECONFIG, idleconfig);\r\n}\r\nstatic int ti_tscadc_probe(struct platform_device *pdev)\r\n{\r\nstruct ti_tscadc_dev *tscadc;\r\nstruct resource *res;\r\nstruct clk *clk;\r\nstruct mfd_tscadc_board *pdata = pdev->dev.platform_data;\r\nstruct mfd_cell *cell;\r\nint err, ctrl;\r\nint clk_value, clock_rate;\r\nint tsc_wires, adc_channels = 0, total_channels;\r\nif (!pdata) {\r\ndev_err(&pdev->dev, "Could not find platform data\n");\r\nreturn -EINVAL;\r\n}\r\nif (pdata->adc_init)\r\nadc_channels = pdata->adc_init->adc_channels;\r\ntsc_wires = pdata->tsc_init->wires;\r\ntotal_channels = tsc_wires + adc_channels;\r\nif (total_channels > 8) {\r\ndev_err(&pdev->dev, "Number of i/p channels more than 8\n");\r\nreturn -EINVAL;\r\n}\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!res) {\r\ndev_err(&pdev->dev, "no memory resource defined.\n");\r\nreturn -EINVAL;\r\n}\r\ntscadc = devm_kzalloc(&pdev->dev,\r\nsizeof(struct ti_tscadc_dev), GFP_KERNEL);\r\nif (!tscadc) {\r\ndev_err(&pdev->dev, "failed to allocate memory.\n");\r\nreturn -ENOMEM;\r\n}\r\ntscadc->dev = &pdev->dev;\r\nerr = platform_get_irq(pdev, 0);\r\nif (err < 0) {\r\ndev_err(&pdev->dev, "no irq ID is specified.\n");\r\ngoto ret;\r\n} else\r\ntscadc->irq = err;\r\nres = devm_request_mem_region(&pdev->dev,\r\nres->start, resource_size(res), pdev->name);\r\nif (!res) {\r\ndev_err(&pdev->dev, "failed to reserve registers.\n");\r\nreturn -EBUSY;\r\n}\r\ntscadc->tscadc_base = devm_ioremap(&pdev->dev,\r\nres->start, resource_size(res));\r\nif (!tscadc->tscadc_base) {\r\ndev_err(&pdev->dev, "failed to map registers.\n");\r\nreturn -ENOMEM;\r\n}\r\ntscadc->regmap_tscadc = devm_regmap_init_mmio(&pdev->dev,\r\ntscadc->tscadc_base, &tscadc_regmap_config);\r\nif (IS_ERR(tscadc->regmap_tscadc)) {\r\ndev_err(&pdev->dev, "regmap init failed\n");\r\nerr = PTR_ERR(tscadc->regmap_tscadc);\r\ngoto ret;\r\n}\r\npm_runtime_enable(&pdev->dev);\r\npm_runtime_get_sync(&pdev->dev);\r\nclk = clk_get(&pdev->dev, "adc_tsc_fck");\r\nif (IS_ERR(clk)) {\r\ndev_err(&pdev->dev, "failed to get TSC fck\n");\r\nerr = PTR_ERR(clk);\r\ngoto err_disable_clk;\r\n}\r\nclock_rate = clk_get_rate(clk);\r\nclk_put(clk);\r\nclk_value = clock_rate / ADC_CLK;\r\nif (clk_value < MAX_CLK_DIV) {\r\ndev_err(&pdev->dev, "clock input less than min clock requirement\n");\r\nerr = -EINVAL;\r\ngoto err_disable_clk;\r\n}\r\nclk_value = clk_value - 1;\r\ntscadc_writel(tscadc, REG_CLKDIV, clk_value);\r\nctrl = CNTRLREG_STEPCONFIGWRT |\r\nCNTRLREG_TSCENB |\r\nCNTRLREG_STEPID |\r\nCNTRLREG_4WIRE;\r\ntscadc_writel(tscadc, REG_CTRL, ctrl);\r\ntscadc_idle_config(tscadc);\r\nctrl = tscadc_readl(tscadc, REG_CTRL);\r\nctrl |= CNTRLREG_TSCSSENB;\r\ntscadc_writel(tscadc, REG_CTRL, ctrl);\r\ncell = &tscadc->cells[TSC_CELL];\r\ncell->name = "tsc";\r\ncell->platform_data = tscadc;\r\ncell->pdata_size = sizeof(*tscadc);\r\ncell = &tscadc->cells[ADC_CELL];\r\ncell->name = "tiadc";\r\ncell->platform_data = tscadc;\r\ncell->pdata_size = sizeof(*tscadc);\r\nerr = mfd_add_devices(&pdev->dev, pdev->id, tscadc->cells,\r\nTSCADC_CELLS, NULL, 0, NULL);\r\nif (err < 0)\r\ngoto err_disable_clk;\r\ndevice_init_wakeup(&pdev->dev, true);\r\nplatform_set_drvdata(pdev, tscadc);\r\nreturn 0;\r\nerr_disable_clk:\r\npm_runtime_put_sync(&pdev->dev);\r\npm_runtime_disable(&pdev->dev);\r\nret:\r\nreturn err;\r\n}\r\nstatic int ti_tscadc_remove(struct platform_device *pdev)\r\n{\r\nstruct ti_tscadc_dev *tscadc = platform_get_drvdata(pdev);\r\ntscadc_writel(tscadc, REG_SE, 0x00);\r\npm_runtime_put_sync(&pdev->dev);\r\npm_runtime_disable(&pdev->dev);\r\nmfd_remove_devices(tscadc->dev);\r\nreturn 0;\r\n}\r\nstatic int tscadc_suspend(struct device *dev)\r\n{\r\nstruct ti_tscadc_dev *tscadc_dev = dev_get_drvdata(dev);\r\ntscadc_writel(tscadc_dev, REG_SE, 0x00);\r\npm_runtime_put_sync(dev);\r\nreturn 0;\r\n}\r\nstatic int tscadc_resume(struct device *dev)\r\n{\r\nstruct ti_tscadc_dev *tscadc_dev = dev_get_drvdata(dev);\r\nunsigned int restore, ctrl;\r\npm_runtime_get_sync(dev);\r\nctrl = CNTRLREG_STEPCONFIGWRT | CNTRLREG_TSCENB |\r\nCNTRLREG_STEPID | CNTRLREG_4WIRE;\r\ntscadc_writel(tscadc_dev, REG_CTRL, ctrl);\r\ntscadc_idle_config(tscadc_dev);\r\ntscadc_writel(tscadc_dev, REG_SE, STPENB_STEPENB);\r\nrestore = tscadc_readl(tscadc_dev, REG_CTRL);\r\ntscadc_writel(tscadc_dev, REG_CTRL,\r\n(restore | CNTRLREG_TSCSSENB));\r\nreturn 0;\r\n}
