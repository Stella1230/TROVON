bool ipv6_ext_hdr(u8 nexthdr)\r\n{\r\nreturn (nexthdr == NEXTHDR_HOP) ||\r\n(nexthdr == NEXTHDR_ROUTING) ||\r\n(nexthdr == NEXTHDR_FRAGMENT) ||\r\n(nexthdr == NEXTHDR_AUTH) ||\r\n(nexthdr == NEXTHDR_NONE) ||\r\n(nexthdr == NEXTHDR_DEST);\r\n}\r\nint ipv6_skip_exthdr(const struct sk_buff *skb, int start, u8 *nexthdrp,\r\n__be16 *frag_offp)\r\n{\r\nu8 nexthdr = *nexthdrp;\r\n*frag_offp = 0;\r\nwhile (ipv6_ext_hdr(nexthdr)) {\r\nstruct ipv6_opt_hdr _hdr, *hp;\r\nint hdrlen;\r\nif (nexthdr == NEXTHDR_NONE)\r\nreturn -1;\r\nhp = skb_header_pointer(skb, start, sizeof(_hdr), &_hdr);\r\nif (hp == NULL)\r\nreturn -1;\r\nif (nexthdr == NEXTHDR_FRAGMENT) {\r\n__be16 _frag_off, *fp;\r\nfp = skb_header_pointer(skb,\r\nstart+offsetof(struct frag_hdr,\r\nfrag_off),\r\nsizeof(_frag_off),\r\n&_frag_off);\r\nif (fp == NULL)\r\nreturn -1;\r\n*frag_offp = *fp;\r\nif (ntohs(*frag_offp) & ~0x7)\r\nbreak;\r\nhdrlen = 8;\r\n} else if (nexthdr == NEXTHDR_AUTH)\r\nhdrlen = (hp->hdrlen+2)<<2;\r\nelse\r\nhdrlen = ipv6_optlen(hp);\r\nnexthdr = hp->nexthdr;\r\nstart += hdrlen;\r\n}\r\n*nexthdrp = nexthdr;\r\nreturn start;\r\n}\r\nint ipv6_find_tlv(struct sk_buff *skb, int offset, int type)\r\n{\r\nconst unsigned char *nh = skb_network_header(skb);\r\nint packet_len = skb->tail - skb->network_header;\r\nstruct ipv6_opt_hdr *hdr;\r\nint len;\r\nif (offset + 2 > packet_len)\r\ngoto bad;\r\nhdr = (struct ipv6_opt_hdr *)(nh + offset);\r\nlen = ((hdr->hdrlen + 1) << 3);\r\nif (offset + len > packet_len)\r\ngoto bad;\r\noffset += 2;\r\nlen -= 2;\r\nwhile (len > 0) {\r\nint opttype = nh[offset];\r\nint optlen;\r\nif (opttype == type)\r\nreturn offset;\r\nswitch (opttype) {\r\ncase IPV6_TLV_PAD1:\r\noptlen = 1;\r\nbreak;\r\ndefault:\r\noptlen = nh[offset + 1] + 2;\r\nif (optlen > len)\r\ngoto bad;\r\nbreak;\r\n}\r\noffset += optlen;\r\nlen -= optlen;\r\n}\r\nbad:\r\nreturn -1;\r\n}\r\nint ipv6_find_hdr(const struct sk_buff *skb, unsigned int *offset,\r\nint target, unsigned short *fragoff, int *flags)\r\n{\r\nunsigned int start = skb_network_offset(skb) + sizeof(struct ipv6hdr);\r\nu8 nexthdr = ipv6_hdr(skb)->nexthdr;\r\nunsigned int len;\r\nbool found;\r\nif (fragoff)\r\n*fragoff = 0;\r\nif (*offset) {\r\nstruct ipv6hdr _ip6, *ip6;\r\nip6 = skb_header_pointer(skb, *offset, sizeof(_ip6), &_ip6);\r\nif (!ip6 || (ip6->version != 6)) {\r\nprintk(KERN_ERR "IPv6 header not found\n");\r\nreturn -EBADMSG;\r\n}\r\nstart = *offset + sizeof(struct ipv6hdr);\r\nnexthdr = ip6->nexthdr;\r\n}\r\nlen = skb->len - start;\r\ndo {\r\nstruct ipv6_opt_hdr _hdr, *hp;\r\nunsigned int hdrlen;\r\nfound = (nexthdr == target);\r\nif ((!ipv6_ext_hdr(nexthdr)) || nexthdr == NEXTHDR_NONE) {\r\nif (target < 0)\r\nbreak;\r\nreturn -ENOENT;\r\n}\r\nhp = skb_header_pointer(skb, start, sizeof(_hdr), &_hdr);\r\nif (hp == NULL)\r\nreturn -EBADMSG;\r\nif (nexthdr == NEXTHDR_ROUTING) {\r\nstruct ipv6_rt_hdr _rh, *rh;\r\nrh = skb_header_pointer(skb, start, sizeof(_rh),\r\n&_rh);\r\nif (rh == NULL)\r\nreturn -EBADMSG;\r\nif (flags && (*flags & IP6_FH_F_SKIP_RH) &&\r\nrh->segments_left == 0)\r\nfound = false;\r\n}\r\nif (nexthdr == NEXTHDR_FRAGMENT) {\r\nunsigned short _frag_off;\r\n__be16 *fp;\r\nif (flags)\r\n*flags |= IP6_FH_F_FRAG;\r\nfp = skb_header_pointer(skb,\r\nstart+offsetof(struct frag_hdr,\r\nfrag_off),\r\nsizeof(_frag_off),\r\n&_frag_off);\r\nif (fp == NULL)\r\nreturn -EBADMSG;\r\n_frag_off = ntohs(*fp) & ~0x7;\r\nif (_frag_off) {\r\nif (target < 0 &&\r\n((!ipv6_ext_hdr(hp->nexthdr)) ||\r\nhp->nexthdr == NEXTHDR_NONE)) {\r\nif (fragoff)\r\n*fragoff = _frag_off;\r\nreturn hp->nexthdr;\r\n}\r\nreturn -ENOENT;\r\n}\r\nhdrlen = 8;\r\n} else if (nexthdr == NEXTHDR_AUTH) {\r\nif (flags && (*flags & IP6_FH_F_AUTH) && (target < 0))\r\nbreak;\r\nhdrlen = (hp->hdrlen + 2) << 2;\r\n} else\r\nhdrlen = ipv6_optlen(hp);\r\nif (!found) {\r\nnexthdr = hp->nexthdr;\r\nlen -= hdrlen;\r\nstart += hdrlen;\r\n}\r\n} while (!found);\r\n*offset = start;\r\nreturn nexthdr;\r\n}
