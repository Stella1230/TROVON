static int dlm_should_cancel_bast(struct dlm_ctxt *dlm, struct dlm_lock *lock)\r\n{\r\nassert_spin_locked(&dlm->ast_lock);\r\nassert_spin_locked(&lock->spinlock);\r\nif (lock->ml.highest_blocked == LKM_IVMODE)\r\nreturn 0;\r\nBUG_ON(lock->ml.highest_blocked == LKM_NLMODE);\r\nif (lock->bast_pending &&\r\nlist_empty(&lock->bast_list))\r\nreturn 0;\r\nif (lock->ml.type == LKM_EXMODE)\r\nreturn 0;\r\nelse if (lock->ml.type == LKM_NLMODE)\r\nreturn 1;\r\nelse if (lock->ml.highest_blocked != LKM_EXMODE)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nvoid __dlm_queue_ast(struct dlm_ctxt *dlm, struct dlm_lock *lock)\r\n{\r\nstruct dlm_lock_resource *res;\r\nBUG_ON(!dlm);\r\nBUG_ON(!lock);\r\nres = lock->lockres;\r\nassert_spin_locked(&dlm->ast_lock);\r\nif (!list_empty(&lock->ast_list)) {\r\nmlog(ML_ERROR, "%s: res %.*s, lock %u:%llu, "\r\n"AST list not empty, pending %d, newlevel %d\n",\r\ndlm->name, res->lockname.len, res->lockname.name,\r\ndlm_get_lock_cookie_node(be64_to_cpu(lock->ml.cookie)),\r\ndlm_get_lock_cookie_seq(be64_to_cpu(lock->ml.cookie)),\r\nlock->ast_pending, lock->ml.type);\r\nBUG();\r\n}\r\nif (lock->ast_pending)\r\nmlog(0, "%s: res %.*s, lock %u:%llu, AST getting flushed\n",\r\ndlm->name, res->lockname.len, res->lockname.name,\r\ndlm_get_lock_cookie_node(be64_to_cpu(lock->ml.cookie)),\r\ndlm_get_lock_cookie_seq(be64_to_cpu(lock->ml.cookie)));\r\ndlm_lock_get(lock);\r\nspin_lock(&lock->spinlock);\r\nif (dlm_should_cancel_bast(dlm, lock)) {\r\nmlog(0, "%s: res %.*s, lock %u:%llu, Cancelling BAST\n",\r\ndlm->name, res->lockname.len, res->lockname.name,\r\ndlm_get_lock_cookie_node(be64_to_cpu(lock->ml.cookie)),\r\ndlm_get_lock_cookie_seq(be64_to_cpu(lock->ml.cookie)));\r\nlock->bast_pending = 0;\r\nlist_del_init(&lock->bast_list);\r\nlock->ml.highest_blocked = LKM_IVMODE;\r\ndlm_lock_put(lock);\r\ndlm_lockres_release_ast(dlm, res);\r\n}\r\nlist_add_tail(&lock->ast_list, &dlm->pending_asts);\r\nlock->ast_pending = 1;\r\nspin_unlock(&lock->spinlock);\r\n}\r\nvoid dlm_queue_ast(struct dlm_ctxt *dlm, struct dlm_lock *lock)\r\n{\r\nBUG_ON(!dlm);\r\nBUG_ON(!lock);\r\nspin_lock(&dlm->ast_lock);\r\n__dlm_queue_ast(dlm, lock);\r\nspin_unlock(&dlm->ast_lock);\r\n}\r\nvoid __dlm_queue_bast(struct dlm_ctxt *dlm, struct dlm_lock *lock)\r\n{\r\nstruct dlm_lock_resource *res;\r\nBUG_ON(!dlm);\r\nBUG_ON(!lock);\r\nassert_spin_locked(&dlm->ast_lock);\r\nres = lock->lockres;\r\nBUG_ON(!list_empty(&lock->bast_list));\r\nif (lock->bast_pending)\r\nmlog(0, "%s: res %.*s, lock %u:%llu, BAST getting flushed\n",\r\ndlm->name, res->lockname.len, res->lockname.name,\r\ndlm_get_lock_cookie_node(be64_to_cpu(lock->ml.cookie)),\r\ndlm_get_lock_cookie_seq(be64_to_cpu(lock->ml.cookie)));\r\ndlm_lock_get(lock);\r\nspin_lock(&lock->spinlock);\r\nlist_add_tail(&lock->bast_list, &dlm->pending_basts);\r\nlock->bast_pending = 1;\r\nspin_unlock(&lock->spinlock);\r\n}\r\nvoid dlm_queue_bast(struct dlm_ctxt *dlm, struct dlm_lock *lock)\r\n{\r\nBUG_ON(!dlm);\r\nBUG_ON(!lock);\r\nspin_lock(&dlm->ast_lock);\r\n__dlm_queue_bast(dlm, lock);\r\nspin_unlock(&dlm->ast_lock);\r\n}\r\nstatic void dlm_update_lvb(struct dlm_ctxt *dlm, struct dlm_lock_resource *res,\r\nstruct dlm_lock *lock)\r\n{\r\nstruct dlm_lockstatus *lksb = lock->lksb;\r\nBUG_ON(!lksb);\r\nspin_lock(&res->spinlock);\r\nif (res->owner == dlm->node_num) {\r\nif (lksb->flags & DLM_LKSB_GET_LVB) {\r\nmlog(0, "getting lvb from lockres for %s node\n",\r\nlock->ml.node == dlm->node_num ? "master" :\r\n"remote");\r\nmemcpy(lksb->lvb, res->lvb, DLM_LVB_LEN);\r\n}\r\n}\r\nspin_unlock(&res->spinlock);\r\nlksb->flags &= ~(DLM_LKSB_PUT_LVB|DLM_LKSB_GET_LVB);\r\n}\r\nvoid dlm_do_local_ast(struct dlm_ctxt *dlm, struct dlm_lock_resource *res,\r\nstruct dlm_lock *lock)\r\n{\r\ndlm_astlockfunc_t *fn;\r\nstruct dlm_lockstatus *lksb;\r\nmlog(0, "%s: res %.*s, lock %u:%llu, Local AST\n", dlm->name,\r\nres->lockname.len, res->lockname.name,\r\ndlm_get_lock_cookie_node(be64_to_cpu(lock->ml.cookie)),\r\ndlm_get_lock_cookie_seq(be64_to_cpu(lock->ml.cookie)));\r\nlksb = lock->lksb;\r\nfn = lock->ast;\r\nBUG_ON(lock->ml.node != dlm->node_num);\r\ndlm_update_lvb(dlm, res, lock);\r\n(*fn)(lock->astdata);\r\n}\r\nint dlm_do_remote_ast(struct dlm_ctxt *dlm, struct dlm_lock_resource *res,\r\nstruct dlm_lock *lock)\r\n{\r\nint ret;\r\nstruct dlm_lockstatus *lksb;\r\nint lksbflags;\r\nmlog(0, "%s: res %.*s, lock %u:%llu, Remote AST\n", dlm->name,\r\nres->lockname.len, res->lockname.name,\r\ndlm_get_lock_cookie_node(be64_to_cpu(lock->ml.cookie)),\r\ndlm_get_lock_cookie_seq(be64_to_cpu(lock->ml.cookie)));\r\nlksb = lock->lksb;\r\nBUG_ON(lock->ml.node == dlm->node_num);\r\nlksbflags = lksb->flags;\r\ndlm_update_lvb(dlm, res, lock);\r\nret = dlm_send_proxy_ast(dlm, res, lock, lksbflags);\r\nreturn ret;\r\n}\r\nvoid dlm_do_local_bast(struct dlm_ctxt *dlm, struct dlm_lock_resource *res,\r\nstruct dlm_lock *lock, int blocked_type)\r\n{\r\ndlm_bastlockfunc_t *fn = lock->bast;\r\nBUG_ON(lock->ml.node != dlm->node_num);\r\nmlog(0, "%s: res %.*s, lock %u:%llu, Local BAST, blocked %d\n",\r\ndlm->name, res->lockname.len, res->lockname.name,\r\ndlm_get_lock_cookie_node(be64_to_cpu(lock->ml.cookie)),\r\ndlm_get_lock_cookie_seq(be64_to_cpu(lock->ml.cookie)),\r\nblocked_type);\r\n(*fn)(lock->astdata, blocked_type);\r\n}\r\nint dlm_proxy_ast_handler(struct o2net_msg *msg, u32 len, void *data,\r\nvoid **ret_data)\r\n{\r\nint ret;\r\nunsigned int locklen;\r\nstruct dlm_ctxt *dlm = data;\r\nstruct dlm_lock_resource *res = NULL;\r\nstruct dlm_lock *lock = NULL;\r\nstruct dlm_proxy_ast *past = (struct dlm_proxy_ast *) msg->buf;\r\nchar *name;\r\nstruct list_head *iter, *head=NULL;\r\n__be64 cookie;\r\nu32 flags;\r\nu8 node;\r\nif (!dlm_grab(dlm)) {\r\ndlm_error(DLM_REJECTED);\r\nreturn DLM_REJECTED;\r\n}\r\nmlog_bug_on_msg(!dlm_domain_fully_joined(dlm),\r\n"Domain %s not fully joined!\n", dlm->name);\r\nname = past->name;\r\nlocklen = past->namelen;\r\ncookie = past->cookie;\r\nflags = be32_to_cpu(past->flags);\r\nnode = past->node_idx;\r\nif (locklen > DLM_LOCKID_NAME_MAX) {\r\nret = DLM_IVBUFLEN;\r\nmlog(ML_ERROR, "Invalid name length (%d) in proxy ast "\r\n"handler!\n", locklen);\r\ngoto leave;\r\n}\r\nif ((flags & (LKM_PUT_LVB|LKM_GET_LVB)) ==\r\n(LKM_PUT_LVB|LKM_GET_LVB)) {\r\nmlog(ML_ERROR, "Both PUT and GET lvb specified, (0x%x)\n",\r\nflags);\r\nret = DLM_BADARGS;\r\ngoto leave;\r\n}\r\nmlog(0, "lvb: %s\n", flags & LKM_PUT_LVB ? "put lvb" :\r\n(flags & LKM_GET_LVB ? "get lvb" : "none"));\r\nmlog(0, "type=%d, blocked_type=%d\n", past->type, past->blocked_type);\r\nif (past->type != DLM_AST &&\r\npast->type != DLM_BAST) {\r\nmlog(ML_ERROR, "Unknown ast type! %d, cookie=%u:%llu"\r\n"name=%.*s, node=%u\n", past->type,\r\ndlm_get_lock_cookie_node(be64_to_cpu(cookie)),\r\ndlm_get_lock_cookie_seq(be64_to_cpu(cookie)),\r\nlocklen, name, node);\r\nret = DLM_IVLOCKID;\r\ngoto leave;\r\n}\r\nres = dlm_lookup_lockres(dlm, name, locklen);\r\nif (!res) {\r\nmlog(0, "Got %sast for unknown lockres! cookie=%u:%llu, "\r\n"name=%.*s, node=%u\n", (past->type == DLM_AST ? "" : "b"),\r\ndlm_get_lock_cookie_node(be64_to_cpu(cookie)),\r\ndlm_get_lock_cookie_seq(be64_to_cpu(cookie)),\r\nlocklen, name, node);\r\nret = DLM_IVLOCKID;\r\ngoto leave;\r\n}\r\nBUG_ON(res->owner == dlm->node_num);\r\nmlog(0, "%s: res %.*s\n", dlm->name, res->lockname.len,\r\nres->lockname.name);\r\nspin_lock(&res->spinlock);\r\nif (res->state & DLM_LOCK_RES_RECOVERING) {\r\nmlog(0, "Responding with DLM_RECOVERING!\n");\r\nret = DLM_RECOVERING;\r\ngoto unlock_out;\r\n}\r\nif (res->state & DLM_LOCK_RES_MIGRATING) {\r\nmlog(0, "Responding with DLM_MIGRATING!\n");\r\nret = DLM_MIGRATING;\r\ngoto unlock_out;\r\n}\r\nhead = &res->converting;\r\nlock = NULL;\r\nlist_for_each(iter, head) {\r\nlock = list_entry (iter, struct dlm_lock, list);\r\nif (lock->ml.cookie == cookie)\r\ngoto do_ast;\r\n}\r\nif (past->type == DLM_AST)\r\nhead = &res->blocked;\r\nelse\r\nhead = &res->granted;\r\nlist_for_each(iter, head) {\r\nlock = list_entry (iter, struct dlm_lock, list);\r\nif (lock->ml.cookie == cookie)\r\ngoto do_ast;\r\n}\r\nmlog(0, "Got %sast for unknown lock! cookie=%u:%llu, name=%.*s, "\r\n"node=%u\n", past->type == DLM_AST ? "" : "b",\r\ndlm_get_lock_cookie_node(be64_to_cpu(cookie)),\r\ndlm_get_lock_cookie_seq(be64_to_cpu(cookie)),\r\nlocklen, name, node);\r\nret = DLM_NORMAL;\r\nunlock_out:\r\nspin_unlock(&res->spinlock);\r\ngoto leave;\r\ndo_ast:\r\nret = DLM_NORMAL;\r\nif (past->type == DLM_AST) {\r\nlist_move_tail(&lock->list, &res->granted);\r\nmlog(0, "%s: res %.*s, lock %u:%llu, Granted type %d => %d\n",\r\ndlm->name, res->lockname.len, res->lockname.name,\r\ndlm_get_lock_cookie_node(be64_to_cpu(cookie)),\r\ndlm_get_lock_cookie_seq(be64_to_cpu(cookie)),\r\nlock->ml.type, lock->ml.convert_type);\r\nif (lock->ml.convert_type != LKM_IVMODE) {\r\nlock->ml.type = lock->ml.convert_type;\r\nlock->ml.convert_type = LKM_IVMODE;\r\n} else {\r\n}\r\nlock->lksb->status = DLM_NORMAL;\r\nif (flags & LKM_GET_LVB) {\r\nBUG_ON(!(lock->lksb->flags & DLM_LKSB_GET_LVB));\r\nmemcpy(lock->lksb->lvb, past->lvb, DLM_LVB_LEN);\r\n}\r\n}\r\nspin_unlock(&res->spinlock);\r\nif (past->type == DLM_AST)\r\ndlm_do_local_ast(dlm, res, lock);\r\nelse\r\ndlm_do_local_bast(dlm, res, lock, past->blocked_type);\r\nleave:\r\nif (res)\r\ndlm_lockres_put(res);\r\ndlm_put(dlm);\r\nreturn ret;\r\n}\r\nint dlm_send_proxy_ast_msg(struct dlm_ctxt *dlm, struct dlm_lock_resource *res,\r\nstruct dlm_lock *lock, int msg_type,\r\nint blocked_type, int flags)\r\n{\r\nint ret = 0;\r\nstruct dlm_proxy_ast past;\r\nstruct kvec vec[2];\r\nsize_t veclen = 1;\r\nint status;\r\nmlog(0, "%s: res %.*s, to %u, type %d, blocked_type %d\n", dlm->name,\r\nres->lockname.len, res->lockname.name, lock->ml.node, msg_type,\r\nblocked_type);\r\nmemset(&past, 0, sizeof(struct dlm_proxy_ast));\r\npast.node_idx = dlm->node_num;\r\npast.type = msg_type;\r\npast.blocked_type = blocked_type;\r\npast.namelen = res->lockname.len;\r\nmemcpy(past.name, res->lockname.name, past.namelen);\r\npast.cookie = lock->ml.cookie;\r\nvec[0].iov_len = sizeof(struct dlm_proxy_ast);\r\nvec[0].iov_base = &past;\r\nif (flags & DLM_LKSB_GET_LVB) {\r\nbe32_add_cpu(&past.flags, LKM_GET_LVB);\r\nvec[1].iov_len = DLM_LVB_LEN;\r\nvec[1].iov_base = lock->lksb->lvb;\r\nveclen++;\r\n}\r\nret = o2net_send_message_vec(DLM_PROXY_AST_MSG, dlm->key, vec, veclen,\r\nlock->ml.node, &status);\r\nif (ret < 0)\r\nmlog(ML_ERROR, "%s: res %.*s, error %d send AST to node %u\n",\r\ndlm->name, res->lockname.len, res->lockname.name, ret,\r\nlock->ml.node);\r\nelse {\r\nif (status == DLM_RECOVERING) {\r\nmlog(ML_ERROR, "sent AST to node %u, it thinks this "\r\n"node is dead!\n", lock->ml.node);\r\nBUG();\r\n} else if (status == DLM_MIGRATING) {\r\nmlog(ML_ERROR, "sent AST to node %u, it returned "\r\n"DLM_MIGRATING!\n", lock->ml.node);\r\nBUG();\r\n} else if (status != DLM_NORMAL && status != DLM_IVLOCKID) {\r\nmlog(ML_ERROR, "AST to node %u returned %d!\n",\r\nlock->ml.node, status);\r\n}\r\nret = 0;\r\n}\r\nreturn ret;\r\n}
