static int build_via_table(struct viadev *dev, struct snd_pcm_substream *substream,\r\nstruct pci_dev *pci,\r\nunsigned int periods, unsigned int fragsize)\r\n{\r\nunsigned int i, idx, ofs, rest;\r\nstruct via82xx_modem *chip = snd_pcm_substream_chip(substream);\r\nif (dev->table.area == NULL) {\r\nif (snd_dma_alloc_pages(SNDRV_DMA_TYPE_DEV, snd_dma_pci_data(chip->pci),\r\nPAGE_ALIGN(VIA_TABLE_SIZE * 2 * 8),\r\n&dev->table) < 0)\r\nreturn -ENOMEM;\r\n}\r\nif (! dev->idx_table) {\r\ndev->idx_table = kmalloc(sizeof(*dev->idx_table) * VIA_TABLE_SIZE, GFP_KERNEL);\r\nif (! dev->idx_table)\r\nreturn -ENOMEM;\r\n}\r\nidx = 0;\r\nofs = 0;\r\nfor (i = 0; i < periods; i++) {\r\nrest = fragsize;\r\ndo {\r\nunsigned int r;\r\nunsigned int flag;\r\nunsigned int addr;\r\nif (idx >= VIA_TABLE_SIZE) {\r\nsnd_printk(KERN_ERR "via82xx: too much table size!\n");\r\nreturn -EINVAL;\r\n}\r\naddr = snd_pcm_sgbuf_get_addr(substream, ofs);\r\n((u32 *)dev->table.area)[idx << 1] = cpu_to_le32(addr);\r\nr = PAGE_SIZE - (ofs % PAGE_SIZE);\r\nif (rest < r)\r\nr = rest;\r\nrest -= r;\r\nif (! rest) {\r\nif (i == periods - 1)\r\nflag = VIA_TBL_BIT_EOL;\r\nelse\r\nflag = VIA_TBL_BIT_FLAG;\r\n} else\r\nflag = 0;\r\n((u32 *)dev->table.area)[(idx<<1) + 1] = cpu_to_le32(r | flag);\r\ndev->idx_table[idx].offset = ofs;\r\ndev->idx_table[idx].size = r;\r\nofs += r;\r\nidx++;\r\n} while (rest > 0);\r\n}\r\ndev->tbl_entries = idx;\r\ndev->bufsize = periods * fragsize;\r\ndev->bufsize2 = dev->bufsize / 2;\r\nreturn 0;\r\n}\r\nstatic int clean_via_table(struct viadev *dev, struct snd_pcm_substream *substream,\r\nstruct pci_dev *pci)\r\n{\r\nif (dev->table.area) {\r\nsnd_dma_free_pages(&dev->table);\r\ndev->table.area = NULL;\r\n}\r\nkfree(dev->idx_table);\r\ndev->idx_table = NULL;\r\nreturn 0;\r\n}\r\nstatic inline unsigned int snd_via82xx_codec_xread(struct via82xx_modem *chip)\r\n{\r\nreturn inl(VIAREG(chip, AC97));\r\n}\r\nstatic inline void snd_via82xx_codec_xwrite(struct via82xx_modem *chip, unsigned int val)\r\n{\r\noutl(val, VIAREG(chip, AC97));\r\n}\r\nstatic int snd_via82xx_codec_ready(struct via82xx_modem *chip, int secondary)\r\n{\r\nunsigned int timeout = 1000;\r\nunsigned int val;\r\nwhile (timeout-- > 0) {\r\nudelay(1);\r\nif (!((val = snd_via82xx_codec_xread(chip)) & VIA_REG_AC97_BUSY))\r\nreturn val & 0xffff;\r\n}\r\nsnd_printk(KERN_ERR "codec_ready: codec %i is not ready [0x%x]\n",\r\nsecondary, snd_via82xx_codec_xread(chip));\r\nreturn -EIO;\r\n}\r\nstatic int snd_via82xx_codec_valid(struct via82xx_modem *chip, int secondary)\r\n{\r\nunsigned int timeout = 1000;\r\nunsigned int val, val1;\r\nunsigned int stat = !secondary ? VIA_REG_AC97_PRIMARY_VALID :\r\nVIA_REG_AC97_SECONDARY_VALID;\r\nwhile (timeout-- > 0) {\r\nval = snd_via82xx_codec_xread(chip);\r\nval1 = val & (VIA_REG_AC97_BUSY | stat);\r\nif (val1 == stat)\r\nreturn val & 0xffff;\r\nudelay(1);\r\n}\r\nreturn -EIO;\r\n}\r\nstatic void snd_via82xx_codec_wait(struct snd_ac97 *ac97)\r\n{\r\nstruct via82xx_modem *chip = ac97->private_data;\r\nint err;\r\nerr = snd_via82xx_codec_ready(chip, ac97->num);\r\nmsleep(500);\r\n}\r\nstatic void snd_via82xx_codec_write(struct snd_ac97 *ac97,\r\nunsigned short reg,\r\nunsigned short val)\r\n{\r\nstruct via82xx_modem *chip = ac97->private_data;\r\nunsigned int xval;\r\nif(reg == AC97_GPIO_STATUS) {\r\noutl(val, VIAREG(chip, GPI_STATUS));\r\nreturn;\r\n}\r\nxval = !ac97->num ? VIA_REG_AC97_CODEC_ID_PRIMARY : VIA_REG_AC97_CODEC_ID_SECONDARY;\r\nxval <<= VIA_REG_AC97_CODEC_ID_SHIFT;\r\nxval |= reg << VIA_REG_AC97_CMD_SHIFT;\r\nxval |= val << VIA_REG_AC97_DATA_SHIFT;\r\nsnd_via82xx_codec_xwrite(chip, xval);\r\nsnd_via82xx_codec_ready(chip, ac97->num);\r\n}\r\nstatic unsigned short snd_via82xx_codec_read(struct snd_ac97 *ac97, unsigned short reg)\r\n{\r\nstruct via82xx_modem *chip = ac97->private_data;\r\nunsigned int xval, val = 0xffff;\r\nint again = 0;\r\nxval = ac97->num << VIA_REG_AC97_CODEC_ID_SHIFT;\r\nxval |= ac97->num ? VIA_REG_AC97_SECONDARY_VALID : VIA_REG_AC97_PRIMARY_VALID;\r\nxval |= VIA_REG_AC97_READ;\r\nxval |= (reg & 0x7f) << VIA_REG_AC97_CMD_SHIFT;\r\nwhile (1) {\r\nif (again++ > 3) {\r\nsnd_printk(KERN_ERR "codec_read: codec %i is not valid [0x%x]\n",\r\nac97->num, snd_via82xx_codec_xread(chip));\r\nreturn 0xffff;\r\n}\r\nsnd_via82xx_codec_xwrite(chip, xval);\r\nudelay (20);\r\nif (snd_via82xx_codec_valid(chip, ac97->num) >= 0) {\r\nudelay(25);\r\nval = snd_via82xx_codec_xread(chip);\r\nbreak;\r\n}\r\n}\r\nreturn val & 0xffff;\r\n}\r\nstatic void snd_via82xx_channel_reset(struct via82xx_modem *chip, struct viadev *viadev)\r\n{\r\noutb(VIA_REG_CTRL_PAUSE | VIA_REG_CTRL_TERMINATE | VIA_REG_CTRL_RESET,\r\nVIADEV_REG(viadev, OFFSET_CONTROL));\r\ninb(VIADEV_REG(viadev, OFFSET_CONTROL));\r\nudelay(50);\r\noutb(0x00, VIADEV_REG(viadev, OFFSET_CONTROL));\r\noutb(0x03, VIADEV_REG(viadev, OFFSET_STATUS));\r\noutb(0x00, VIADEV_REG(viadev, OFFSET_TYPE));\r\nviadev->lastpos = 0;\r\n}\r\nstatic irqreturn_t snd_via82xx_interrupt(int irq, void *dev_id)\r\n{\r\nstruct via82xx_modem *chip = dev_id;\r\nunsigned int status;\r\nunsigned int i;\r\nstatus = inl(VIAREG(chip, SGD_SHADOW));\r\nif (! (status & chip->intr_mask)) {\r\nreturn IRQ_NONE;\r\n}\r\nspin_lock(&chip->reg_lock);\r\nfor (i = 0; i < chip->num_devs; i++) {\r\nstruct viadev *viadev = &chip->devs[i];\r\nunsigned char c_status = inb(VIADEV_REG(viadev, OFFSET_STATUS));\r\nc_status &= (VIA_REG_STAT_EOL|VIA_REG_STAT_FLAG|VIA_REG_STAT_STOPPED);\r\nif (! c_status)\r\ncontinue;\r\nif (viadev->substream && viadev->running) {\r\nspin_unlock(&chip->reg_lock);\r\nsnd_pcm_period_elapsed(viadev->substream);\r\nspin_lock(&chip->reg_lock);\r\n}\r\noutb(c_status, VIADEV_REG(viadev, OFFSET_STATUS));\r\n}\r\nspin_unlock(&chip->reg_lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int snd_via82xx_pcm_trigger(struct snd_pcm_substream *substream, int cmd)\r\n{\r\nstruct via82xx_modem *chip = snd_pcm_substream_chip(substream);\r\nstruct viadev *viadev = substream->runtime->private_data;\r\nunsigned char val = 0;\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\ncase SNDRV_PCM_TRIGGER_SUSPEND:\r\nval |= VIA_REG_CTRL_START;\r\nviadev->running = 1;\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\nval = VIA_REG_CTRL_TERMINATE;\r\nviadev->running = 0;\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\r\nval |= VIA_REG_CTRL_PAUSE;\r\nviadev->running = 0;\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\r\nviadev->running = 1;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\noutb(val, VIADEV_REG(viadev, OFFSET_CONTROL));\r\nif (cmd == SNDRV_PCM_TRIGGER_STOP)\r\nsnd_via82xx_channel_reset(chip, viadev);\r\nreturn 0;\r\n}\r\nstatic inline unsigned int calc_linear_pos(struct viadev *viadev, unsigned int idx,\r\nunsigned int count)\r\n{\r\nunsigned int size, res;\r\nsize = viadev->idx_table[idx].size;\r\nres = viadev->idx_table[idx].offset + size - count;\r\nif (size < count) {\r\nsnd_printd(KERN_ERR "invalid via82xx_cur_ptr (size = %d, count = %d)\n",\r\n(int)size, (int)count);\r\nres = viadev->lastpos;\r\n} else if (check_invalid_pos(viadev, res)) {\r\n#ifdef POINTER_DEBUG\r\nprintk(KERN_DEBUG "fail: idx = %i/%i, lastpos = 0x%x, "\r\n"bufsize2 = 0x%x, offsize = 0x%x, size = 0x%x, "\r\n"count = 0x%x\n", idx, viadev->tbl_entries, viadev->lastpos,\r\nviadev->bufsize2, viadev->idx_table[idx].offset,\r\nviadev->idx_table[idx].size, count);\r\n#endif\r\nif (count && size < count) {\r\nsnd_printd(KERN_ERR "invalid via82xx_cur_ptr, "\r\n"using last valid pointer\n");\r\nres = viadev->lastpos;\r\n} else {\r\nif (! count)\r\nres = viadev->idx_table[idx].offset;\r\nelse\r\nres = viadev->idx_table[idx].offset + size;\r\nif (check_invalid_pos(viadev, res)) {\r\nsnd_printd(KERN_ERR "invalid via82xx_cur_ptr (2), "\r\n"using last valid pointer\n");\r\nres = viadev->lastpos;\r\n}\r\n}\r\n}\r\nviadev->lastpos = res;\r\nif (res >= viadev->bufsize)\r\nres -= viadev->bufsize;\r\nreturn res;\r\n}\r\nstatic snd_pcm_uframes_t snd_via686_pcm_pointer(struct snd_pcm_substream *substream)\r\n{\r\nstruct via82xx_modem *chip = snd_pcm_substream_chip(substream);\r\nstruct viadev *viadev = substream->runtime->private_data;\r\nunsigned int idx, ptr, count, res;\r\nif (snd_BUG_ON(!viadev->tbl_entries))\r\nreturn 0;\r\nif (!(inb(VIADEV_REG(viadev, OFFSET_STATUS)) & VIA_REG_STAT_ACTIVE))\r\nreturn 0;\r\nspin_lock(&chip->reg_lock);\r\ncount = inl(VIADEV_REG(viadev, OFFSET_CURR_COUNT)) & 0xffffff;\r\nptr = inl(VIADEV_REG(viadev, OFFSET_CURR_PTR));\r\nif (ptr <= (unsigned int)viadev->table.addr)\r\nidx = 0;\r\nelse\r\nidx = ((ptr - (unsigned int)viadev->table.addr) / 8 - 1) %\r\nviadev->tbl_entries;\r\nres = calc_linear_pos(viadev, idx, count);\r\nspin_unlock(&chip->reg_lock);\r\nreturn bytes_to_frames(substream->runtime, res);\r\n}\r\nstatic int snd_via82xx_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *hw_params)\r\n{\r\nstruct via82xx_modem *chip = snd_pcm_substream_chip(substream);\r\nstruct viadev *viadev = substream->runtime->private_data;\r\nint err;\r\nerr = snd_pcm_lib_malloc_pages(substream, params_buffer_bytes(hw_params));\r\nif (err < 0)\r\nreturn err;\r\nerr = build_via_table(viadev, substream, chip->pci,\r\nparams_periods(hw_params),\r\nparams_period_bytes(hw_params));\r\nif (err < 0)\r\nreturn err;\r\nsnd_ac97_write(chip->ac97, AC97_LINE1_RATE, params_rate(hw_params));\r\nsnd_ac97_write(chip->ac97, AC97_LINE1_LEVEL, 0);\r\nreturn 0;\r\n}\r\nstatic int snd_via82xx_hw_free(struct snd_pcm_substream *substream)\r\n{\r\nstruct via82xx_modem *chip = snd_pcm_substream_chip(substream);\r\nstruct viadev *viadev = substream->runtime->private_data;\r\nclean_via_table(viadev, substream, chip->pci);\r\nsnd_pcm_lib_free_pages(substream);\r\nreturn 0;\r\n}\r\nstatic void snd_via82xx_set_table_ptr(struct via82xx_modem *chip, struct viadev *viadev)\r\n{\r\nsnd_via82xx_codec_ready(chip, chip->ac97_secondary);\r\noutl((u32)viadev->table.addr, VIADEV_REG(viadev, OFFSET_TABLE_PTR));\r\nudelay(20);\r\nsnd_via82xx_codec_ready(chip, chip->ac97_secondary);\r\n}\r\nstatic int snd_via82xx_pcm_prepare(struct snd_pcm_substream *substream)\r\n{\r\nstruct via82xx_modem *chip = snd_pcm_substream_chip(substream);\r\nstruct viadev *viadev = substream->runtime->private_data;\r\nsnd_via82xx_channel_reset(chip, viadev);\r\nsnd_via82xx_set_table_ptr(chip, viadev);\r\noutb(VIA_REG_TYPE_AUTOSTART|VIA_REG_TYPE_INT_EOL|VIA_REG_TYPE_INT_FLAG,\r\nVIADEV_REG(viadev, OFFSET_TYPE));\r\nreturn 0;\r\n}\r\nstatic int snd_via82xx_modem_pcm_open(struct via82xx_modem *chip, struct viadev *viadev,\r\nstruct snd_pcm_substream *substream)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nint err;\r\nstatic unsigned int rates[] = { 8000, 9600, 12000, 16000 };\r\nstatic struct snd_pcm_hw_constraint_list hw_constraints_rates = {\r\n.count = ARRAY_SIZE(rates),\r\n.list = rates,\r\n.mask = 0,\r\n};\r\nruntime->hw = snd_via82xx_hw;\r\nif ((err = snd_pcm_hw_constraint_list(runtime, 0, SNDRV_PCM_HW_PARAM_RATE,\r\n&hw_constraints_rates)) < 0)\r\nreturn err;\r\nif ((err = snd_pcm_hw_constraint_integer(runtime, SNDRV_PCM_HW_PARAM_PERIODS)) < 0)\r\nreturn err;\r\nruntime->private_data = viadev;\r\nviadev->substream = substream;\r\nreturn 0;\r\n}\r\nstatic int snd_via82xx_playback_open(struct snd_pcm_substream *substream)\r\n{\r\nstruct via82xx_modem *chip = snd_pcm_substream_chip(substream);\r\nstruct viadev *viadev = &chip->devs[chip->playback_devno + substream->number];\r\nreturn snd_via82xx_modem_pcm_open(chip, viadev, substream);\r\n}\r\nstatic int snd_via82xx_capture_open(struct snd_pcm_substream *substream)\r\n{\r\nstruct via82xx_modem *chip = snd_pcm_substream_chip(substream);\r\nstruct viadev *viadev = &chip->devs[chip->capture_devno + substream->pcm->device];\r\nreturn snd_via82xx_modem_pcm_open(chip, viadev, substream);\r\n}\r\nstatic int snd_via82xx_pcm_close(struct snd_pcm_substream *substream)\r\n{\r\nstruct viadev *viadev = substream->runtime->private_data;\r\nviadev->substream = NULL;\r\nreturn 0;\r\n}\r\nstatic void init_viadev(struct via82xx_modem *chip, int idx, unsigned int reg_offset,\r\nint direction)\r\n{\r\nchip->devs[idx].reg_offset = reg_offset;\r\nchip->devs[idx].direction = direction;\r\nchip->devs[idx].port = chip->port + reg_offset;\r\n}\r\nstatic int snd_via686_pcm_new(struct via82xx_modem *chip)\r\n{\r\nstruct snd_pcm *pcm;\r\nint err;\r\nchip->playback_devno = 0;\r\nchip->capture_devno = 1;\r\nchip->num_devs = 2;\r\nchip->intr_mask = 0x330000;\r\nerr = snd_pcm_new(chip->card, chip->card->shortname, 0, 1, 1, &pcm);\r\nif (err < 0)\r\nreturn err;\r\nsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &snd_via686_playback_ops);\r\nsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &snd_via686_capture_ops);\r\npcm->dev_class = SNDRV_PCM_CLASS_MODEM;\r\npcm->private_data = chip;\r\nstrcpy(pcm->name, chip->card->shortname);\r\nchip->pcms[0] = pcm;\r\ninit_viadev(chip, 0, VIA_REG_MO_STATUS, 0);\r\ninit_viadev(chip, 1, VIA_REG_MI_STATUS, 1);\r\nif ((err = snd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_DEV_SG,\r\nsnd_dma_pci_data(chip->pci),\r\n64*1024, 128*1024)) < 0)\r\nreturn err;\r\nreturn 0;\r\n}\r\nstatic void snd_via82xx_mixer_free_ac97_bus(struct snd_ac97_bus *bus)\r\n{\r\nstruct via82xx_modem *chip = bus->private_data;\r\nchip->ac97_bus = NULL;\r\n}\r\nstatic void snd_via82xx_mixer_free_ac97(struct snd_ac97 *ac97)\r\n{\r\nstruct via82xx_modem *chip = ac97->private_data;\r\nchip->ac97 = NULL;\r\n}\r\nstatic int snd_via82xx_mixer_new(struct via82xx_modem *chip)\r\n{\r\nstruct snd_ac97_template ac97;\r\nint err;\r\nstatic struct snd_ac97_bus_ops ops = {\r\n.write = snd_via82xx_codec_write,\r\n.read = snd_via82xx_codec_read,\r\n.wait = snd_via82xx_codec_wait,\r\n};\r\nif ((err = snd_ac97_bus(chip->card, 0, &ops, chip, &chip->ac97_bus)) < 0)\r\nreturn err;\r\nchip->ac97_bus->private_free = snd_via82xx_mixer_free_ac97_bus;\r\nchip->ac97_bus->clock = chip->ac97_clock;\r\nmemset(&ac97, 0, sizeof(ac97));\r\nac97.private_data = chip;\r\nac97.private_free = snd_via82xx_mixer_free_ac97;\r\nac97.pci = chip->pci;\r\nac97.scaps = AC97_SCAP_SKIP_AUDIO | AC97_SCAP_POWER_SAVE;\r\nac97.num = chip->ac97_secondary;\r\nif ((err = snd_ac97_mixer(chip->ac97_bus, &ac97, &chip->ac97)) < 0)\r\nreturn err;\r\nreturn 0;\r\n}\r\nstatic void snd_via82xx_proc_read(struct snd_info_entry *entry, struct snd_info_buffer *buffer)\r\n{\r\nstruct via82xx_modem *chip = entry->private_data;\r\nint i;\r\nsnd_iprintf(buffer, "%s\n\n", chip->card->longname);\r\nfor (i = 0; i < 0xa0; i += 4) {\r\nsnd_iprintf(buffer, "%02x: %08x\n", i, inl(chip->port + i));\r\n}\r\n}\r\nstatic void snd_via82xx_proc_init(struct via82xx_modem *chip)\r\n{\r\nstruct snd_info_entry *entry;\r\nif (! snd_card_proc_new(chip->card, "via82xx", &entry))\r\nsnd_info_set_text_ops(entry, chip, snd_via82xx_proc_read);\r\n}\r\nstatic int snd_via82xx_chip_init(struct via82xx_modem *chip)\r\n{\r\nunsigned int val;\r\nunsigned long end_time;\r\nunsigned char pval;\r\npci_read_config_byte(chip->pci, VIA_MC97_CTRL, &pval);\r\nif((pval & VIA_MC97_CTRL_INIT) != VIA_MC97_CTRL_INIT) {\r\npci_write_config_byte(chip->pci, 0x44, pval|VIA_MC97_CTRL_INIT);\r\nudelay(100);\r\n}\r\npci_read_config_byte(chip->pci, VIA_ACLINK_STAT, &pval);\r\nif (! (pval & VIA_ACLINK_C00_READY)) {\r\npci_write_config_byte(chip->pci, VIA_ACLINK_CTRL,\r\nVIA_ACLINK_CTRL_ENABLE |\r\nVIA_ACLINK_CTRL_RESET |\r\nVIA_ACLINK_CTRL_SYNC);\r\nudelay(100);\r\n#if 1\r\npci_write_config_byte(chip->pci, VIA_ACLINK_CTRL, 0x00);\r\nudelay(100);\r\n#else\r\npci_write_config_byte(chip->pci, VIA_ACLINK_CTRL,\r\nVIA_ACLINK_CTRL_RESET|VIA_ACLINK_CTRL_SYNC);\r\nudelay(2);\r\n#endif\r\npci_write_config_byte(chip->pci, VIA_ACLINK_CTRL, VIA_ACLINK_CTRL_INIT);\r\nudelay(100);\r\n}\r\npci_read_config_byte(chip->pci, VIA_ACLINK_CTRL, &pval);\r\nif ((pval & VIA_ACLINK_CTRL_INIT) != VIA_ACLINK_CTRL_INIT) {\r\npci_write_config_byte(chip->pci, VIA_ACLINK_CTRL, VIA_ACLINK_CTRL_INIT);\r\nudelay(100);\r\n}\r\nend_time = jiffies + msecs_to_jiffies(750);\r\ndo {\r\npci_read_config_byte(chip->pci, VIA_ACLINK_STAT, &pval);\r\nif (pval & VIA_ACLINK_C00_READY)\r\nbreak;\r\nschedule_timeout_uninterruptible(1);\r\n} while (time_before(jiffies, end_time));\r\nif ((val = snd_via82xx_codec_xread(chip)) & VIA_REG_AC97_BUSY)\r\nsnd_printk(KERN_ERR "AC'97 codec is not ready [0x%x]\n", val);\r\nsnd_via82xx_codec_xwrite(chip, VIA_REG_AC97_READ |\r\nVIA_REG_AC97_SECONDARY_VALID |\r\n(VIA_REG_AC97_CODEC_ID_SECONDARY << VIA_REG_AC97_CODEC_ID_SHIFT));\r\nend_time = jiffies + msecs_to_jiffies(750);\r\nsnd_via82xx_codec_xwrite(chip, VIA_REG_AC97_READ |\r\nVIA_REG_AC97_SECONDARY_VALID |\r\n(VIA_REG_AC97_CODEC_ID_SECONDARY << VIA_REG_AC97_CODEC_ID_SHIFT));\r\ndo {\r\nif ((val = snd_via82xx_codec_xread(chip)) & VIA_REG_AC97_SECONDARY_VALID) {\r\nchip->ac97_secondary = 1;\r\ngoto __ac97_ok2;\r\n}\r\nschedule_timeout_uninterruptible(1);\r\n} while (time_before(jiffies, end_time));\r\n__ac97_ok2:\r\noutl(0, VIAREG(chip, GPI_INTR));\r\nreturn 0;\r\n}\r\nstatic int snd_via82xx_suspend(struct device *dev)\r\n{\r\nstruct pci_dev *pci = to_pci_dev(dev);\r\nstruct snd_card *card = dev_get_drvdata(dev);\r\nstruct via82xx_modem *chip = card->private_data;\r\nint i;\r\nsnd_power_change_state(card, SNDRV_CTL_POWER_D3hot);\r\nfor (i = 0; i < 2; i++)\r\nsnd_pcm_suspend_all(chip->pcms[i]);\r\nfor (i = 0; i < chip->num_devs; i++)\r\nsnd_via82xx_channel_reset(chip, &chip->devs[i]);\r\nsynchronize_irq(chip->irq);\r\nsnd_ac97_suspend(chip->ac97);\r\npci_disable_device(pci);\r\npci_save_state(pci);\r\npci_set_power_state(pci, PCI_D3hot);\r\nreturn 0;\r\n}\r\nstatic int snd_via82xx_resume(struct device *dev)\r\n{\r\nstruct pci_dev *pci = to_pci_dev(dev);\r\nstruct snd_card *card = dev_get_drvdata(dev);\r\nstruct via82xx_modem *chip = card->private_data;\r\nint i;\r\npci_set_power_state(pci, PCI_D0);\r\npci_restore_state(pci);\r\nif (pci_enable_device(pci) < 0) {\r\nprintk(KERN_ERR "via82xx-modem: pci_enable_device failed, "\r\n"disabling device\n");\r\nsnd_card_disconnect(card);\r\nreturn -EIO;\r\n}\r\npci_set_master(pci);\r\nsnd_via82xx_chip_init(chip);\r\nsnd_ac97_resume(chip->ac97);\r\nfor (i = 0; i < chip->num_devs; i++)\r\nsnd_via82xx_channel_reset(chip, &chip->devs[i]);\r\nsnd_power_change_state(card, SNDRV_CTL_POWER_D0);\r\nreturn 0;\r\n}\r\nstatic int snd_via82xx_free(struct via82xx_modem *chip)\r\n{\r\nunsigned int i;\r\nif (chip->irq < 0)\r\ngoto __end_hw;\r\nfor (i = 0; i < chip->num_devs; i++)\r\nsnd_via82xx_channel_reset(chip, &chip->devs[i]);\r\n__end_hw:\r\nif (chip->irq >= 0)\r\nfree_irq(chip->irq, chip);\r\npci_release_regions(chip->pci);\r\npci_disable_device(chip->pci);\r\nkfree(chip);\r\nreturn 0;\r\n}\r\nstatic int snd_via82xx_dev_free(struct snd_device *device)\r\n{\r\nstruct via82xx_modem *chip = device->device_data;\r\nreturn snd_via82xx_free(chip);\r\n}\r\nstatic int snd_via82xx_create(struct snd_card *card,\r\nstruct pci_dev *pci,\r\nint chip_type,\r\nint revision,\r\nunsigned int ac97_clock,\r\nstruct via82xx_modem **r_via)\r\n{\r\nstruct via82xx_modem *chip;\r\nint err;\r\nstatic struct snd_device_ops ops = {\r\n.dev_free = snd_via82xx_dev_free,\r\n};\r\nif ((err = pci_enable_device(pci)) < 0)\r\nreturn err;\r\nif ((chip = kzalloc(sizeof(*chip), GFP_KERNEL)) == NULL) {\r\npci_disable_device(pci);\r\nreturn -ENOMEM;\r\n}\r\nspin_lock_init(&chip->reg_lock);\r\nchip->card = card;\r\nchip->pci = pci;\r\nchip->irq = -1;\r\nif ((err = pci_request_regions(pci, card->driver)) < 0) {\r\nkfree(chip);\r\npci_disable_device(pci);\r\nreturn err;\r\n}\r\nchip->port = pci_resource_start(pci, 0);\r\nif (request_irq(pci->irq, snd_via82xx_interrupt, IRQF_SHARED,\r\nKBUILD_MODNAME, chip)) {\r\nsnd_printk(KERN_ERR "unable to grab IRQ %d\n", pci->irq);\r\nsnd_via82xx_free(chip);\r\nreturn -EBUSY;\r\n}\r\nchip->irq = pci->irq;\r\nif (ac97_clock >= 8000 && ac97_clock <= 48000)\r\nchip->ac97_clock = ac97_clock;\r\nsynchronize_irq(chip->irq);\r\nif ((err = snd_via82xx_chip_init(chip)) < 0) {\r\nsnd_via82xx_free(chip);\r\nreturn err;\r\n}\r\nif ((err = snd_device_new(card, SNDRV_DEV_LOWLEVEL, chip, &ops)) < 0) {\r\nsnd_via82xx_free(chip);\r\nreturn err;\r\n}\r\npci_set_master(pci);\r\nsnd_card_set_dev(card, &pci->dev);\r\n*r_via = chip;\r\nreturn 0;\r\n}\r\nstatic int snd_via82xx_probe(struct pci_dev *pci,\r\nconst struct pci_device_id *pci_id)\r\n{\r\nstruct snd_card *card;\r\nstruct via82xx_modem *chip;\r\nint chip_type = 0, card_type;\r\nunsigned int i;\r\nint err;\r\nerr = snd_card_create(index, id, THIS_MODULE, 0, &card);\r\nif (err < 0)\r\nreturn err;\r\ncard_type = pci_id->driver_data;\r\nswitch (card_type) {\r\ncase TYPE_CARD_VIA82XX_MODEM:\r\nstrcpy(card->driver, "VIA82XX-MODEM");\r\nsprintf(card->shortname, "VIA 82XX modem");\r\nbreak;\r\ndefault:\r\nsnd_printk(KERN_ERR "invalid card type %d\n", card_type);\r\nerr = -EINVAL;\r\ngoto __error;\r\n}\r\nif ((err = snd_via82xx_create(card, pci, chip_type, pci->revision,\r\nac97_clock, &chip)) < 0)\r\ngoto __error;\r\ncard->private_data = chip;\r\nif ((err = snd_via82xx_mixer_new(chip)) < 0)\r\ngoto __error;\r\nif ((err = snd_via686_pcm_new(chip)) < 0 )\r\ngoto __error;\r\nfor (i = 0; i < chip->num_devs; i++)\r\nsnd_via82xx_channel_reset(chip, &chip->devs[i]);\r\nsprintf(card->longname, "%s at 0x%lx, irq %d",\r\ncard->shortname, chip->port, chip->irq);\r\nsnd_via82xx_proc_init(chip);\r\nif ((err = snd_card_register(card)) < 0) {\r\nsnd_card_free(card);\r\nreturn err;\r\n}\r\npci_set_drvdata(pci, card);\r\nreturn 0;\r\n__error:\r\nsnd_card_free(card);\r\nreturn err;\r\n}\r\nstatic void snd_via82xx_remove(struct pci_dev *pci)\r\n{\r\nsnd_card_free(pci_get_drvdata(pci));\r\npci_set_drvdata(pci, NULL);\r\n}
