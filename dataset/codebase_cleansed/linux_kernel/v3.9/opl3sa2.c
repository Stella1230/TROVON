static unsigned char __snd_opl3sa2_read(struct snd_opl3sa2 *chip, unsigned char reg)\r\n{\r\nunsigned char result;\r\n#if 0\r\noutb(0x1d, port);\r\nprintk(KERN_DEBUG "read [0x%lx] = 0x%x\n", port, inb(port));\r\n#endif\r\noutb(reg, chip->port);\r\nresult = inb(chip->port + 1);\r\n#if 0\r\nprintk(KERN_DEBUG "read [0x%lx] = 0x%x [0x%x]\n",\r\nport, result, inb(port));\r\n#endif\r\nreturn result;\r\n}\r\nstatic unsigned char snd_opl3sa2_read(struct snd_opl3sa2 *chip, unsigned char reg)\r\n{\r\nunsigned long flags;\r\nunsigned char result;\r\nspin_lock_irqsave(&chip->reg_lock, flags);\r\nresult = __snd_opl3sa2_read(chip, reg);\r\nspin_unlock_irqrestore(&chip->reg_lock, flags);\r\nreturn result;\r\n}\r\nstatic void __snd_opl3sa2_write(struct snd_opl3sa2 *chip, unsigned char reg, unsigned char value)\r\n{\r\n#if 0\r\noutb(0x1d, port);\r\n#endif\r\noutb(reg, chip->port);\r\noutb(value, chip->port + 1);\r\nchip->ctlregs[reg] = value;\r\n}\r\nstatic void snd_opl3sa2_write(struct snd_opl3sa2 *chip, unsigned char reg, unsigned char value)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&chip->reg_lock, flags);\r\n__snd_opl3sa2_write(chip, reg, value);\r\nspin_unlock_irqrestore(&chip->reg_lock, flags);\r\n}\r\nstatic int snd_opl3sa2_detect(struct snd_card *card)\r\n{\r\nstruct snd_opl3sa2 *chip = card->private_data;\r\nunsigned long port;\r\nunsigned char tmp, tmp1;\r\nchar str[2];\r\nport = chip->port;\r\nif ((chip->res_port = request_region(port, 2, "OPL3-SA control")) == NULL) {\r\nsnd_printk(KERN_ERR PFX "can't grab port 0x%lx\n", port);\r\nreturn -EBUSY;\r\n}\r\nchip->version = 0;\r\ntmp = snd_opl3sa2_read(chip, OPL3SA2_MISC);\r\nif (tmp == 0xff) {\r\nsnd_printd("OPL3-SA [0x%lx] detect = 0x%x\n", port, tmp);\r\nreturn -ENODEV;\r\n}\r\nswitch (tmp & 0x07) {\r\ncase 0x01:\r\nchip->version = 2;\r\nbreak;\r\ndefault:\r\nchip->version = 3;\r\nbreak;\r\n}\r\nstr[0] = chip->version + '0';\r\nstr[1] = 0;\r\nstrcat(card->shortname, str);\r\nsnd_opl3sa2_write(chip, OPL3SA2_MISC, tmp ^ 7);\r\nif ((tmp1 = snd_opl3sa2_read(chip, OPL3SA2_MISC)) != tmp) {\r\nsnd_printd("OPL3-SA [0x%lx] detect (1) = 0x%x (0x%x)\n", port, tmp, tmp1);\r\nreturn -ENODEV;\r\n}\r\ntmp = snd_opl3sa2_read(chip, OPL3SA2_MIC);\r\nsnd_opl3sa2_write(chip, OPL3SA2_MIC, 0x8a);\r\nif (((tmp1 = snd_opl3sa2_read(chip, OPL3SA2_MIC)) & 0x9f) != 0x8a) {\r\nsnd_printd("OPL3-SA [0x%lx] detect (2) = 0x%x (0x%x)\n", port, tmp, tmp1);\r\nreturn -ENODEV;\r\n}\r\nsnd_opl3sa2_write(chip, OPL3SA2_MIC, 0x9f);\r\nsnd_opl3sa2_write(chip, OPL3SA2_PM_CTRL, OPL3SA2_PM_D0);\r\nif (chip->version > 2) {\r\nsnd_opl3sa2_write(chip, OPL3SA2_SYS_CTRL, (chip->ymode << 4));\r\n} else {\r\nsnd_opl3sa2_write(chip, OPL3SA2_SYS_CTRL, 0x00);\r\n}\r\nsnd_opl3sa2_write(chip, OPL3SA2_IRQ_CONFIG, 0x0d);\r\nif (chip->single_dma) {\r\nsnd_opl3sa2_write(chip, OPL3SA2_DMA_CONFIG, 0x03);\r\n} else {\r\nsnd_opl3sa2_write(chip, OPL3SA2_DMA_CONFIG, 0x21);\r\n}\r\nsnd_opl3sa2_write(chip, OPL3SA2_MISC, 0x80 | (tmp & 7));\r\nif (chip->version > 2) {\r\nsnd_opl3sa2_write(chip, OPL3SA3_DGTL_DOWN, 0x00);\r\nsnd_opl3sa2_write(chip, OPL3SA3_ANLG_DOWN, 0x00);\r\n}\r\nreturn 0;\r\n}\r\nstatic irqreturn_t snd_opl3sa2_interrupt(int irq, void *dev_id)\r\n{\r\nunsigned short status;\r\nstruct snd_card *card = dev_id;\r\nstruct snd_opl3sa2 *chip;\r\nint handled = 0;\r\nif (card == NULL)\r\nreturn IRQ_NONE;\r\nchip = card->private_data;\r\nstatus = snd_opl3sa2_read(chip, OPL3SA2_IRQ_STATUS);\r\nif (status & 0x20) {\r\nhandled = 1;\r\nsnd_opl3_interrupt(chip->synth);\r\n}\r\nif ((status & 0x10) && chip->rmidi != NULL) {\r\nhandled = 1;\r\nsnd_mpu401_uart_interrupt(irq, chip->rmidi->private_data);\r\n}\r\nif (status & 0x07) {\r\nhandled = 1;\r\nsnd_wss_interrupt(irq, chip->wss);\r\n}\r\nif (status & 0x40) {\r\nhandled = 1;\r\nsnd_opl3sa2_read(chip, OPL3SA2_MASTER_RIGHT);\r\nsnd_opl3sa2_read(chip, OPL3SA2_MASTER_LEFT);\r\nif (chip->master_switch && chip->master_volume) {\r\nsnd_ctl_notify(card, SNDRV_CTL_EVENT_MASK_VALUE,\r\n&chip->master_switch->id);\r\nsnd_ctl_notify(card, SNDRV_CTL_EVENT_MASK_VALUE,\r\n&chip->master_volume->id);\r\n}\r\n}\r\nreturn IRQ_RETVAL(handled);\r\n}\r\nstatic int snd_opl3sa2_get_single(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_opl3sa2 *chip = snd_kcontrol_chip(kcontrol);\r\nunsigned long flags;\r\nint reg = kcontrol->private_value & 0xff;\r\nint shift = (kcontrol->private_value >> 8) & 0xff;\r\nint mask = (kcontrol->private_value >> 16) & 0xff;\r\nint invert = (kcontrol->private_value >> 24) & 0xff;\r\nspin_lock_irqsave(&chip->reg_lock, flags);\r\nucontrol->value.integer.value[0] = (chip->ctlregs[reg] >> shift) & mask;\r\nspin_unlock_irqrestore(&chip->reg_lock, flags);\r\nif (invert)\r\nucontrol->value.integer.value[0] = mask - ucontrol->value.integer.value[0];\r\nreturn 0;\r\n}\r\nstatic int snd_opl3sa2_put_single(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_opl3sa2 *chip = snd_kcontrol_chip(kcontrol);\r\nunsigned long flags;\r\nint reg = kcontrol->private_value & 0xff;\r\nint shift = (kcontrol->private_value >> 8) & 0xff;\r\nint mask = (kcontrol->private_value >> 16) & 0xff;\r\nint invert = (kcontrol->private_value >> 24) & 0xff;\r\nint change;\r\nunsigned short val, oval;\r\nval = (ucontrol->value.integer.value[0] & mask);\r\nif (invert)\r\nval = mask - val;\r\nval <<= shift;\r\nspin_lock_irqsave(&chip->reg_lock, flags);\r\noval = chip->ctlregs[reg];\r\nval = (oval & ~(mask << shift)) | val;\r\nchange = val != oval;\r\n__snd_opl3sa2_write(chip, reg, val);\r\nspin_unlock_irqrestore(&chip->reg_lock, flags);\r\nreturn change;\r\n}\r\nstatic int snd_opl3sa2_get_double(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_opl3sa2 *chip = snd_kcontrol_chip(kcontrol);\r\nunsigned long flags;\r\nint left_reg = kcontrol->private_value & 0xff;\r\nint right_reg = (kcontrol->private_value >> 8) & 0xff;\r\nint shift_left = (kcontrol->private_value >> 16) & 0x07;\r\nint shift_right = (kcontrol->private_value >> 19) & 0x07;\r\nint mask = (kcontrol->private_value >> 24) & 0xff;\r\nint invert = (kcontrol->private_value >> 22) & 1;\r\nspin_lock_irqsave(&chip->reg_lock, flags);\r\nucontrol->value.integer.value[0] = (chip->ctlregs[left_reg] >> shift_left) & mask;\r\nucontrol->value.integer.value[1] = (chip->ctlregs[right_reg] >> shift_right) & mask;\r\nspin_unlock_irqrestore(&chip->reg_lock, flags);\r\nif (invert) {\r\nucontrol->value.integer.value[0] = mask - ucontrol->value.integer.value[0];\r\nucontrol->value.integer.value[1] = mask - ucontrol->value.integer.value[1];\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_opl3sa2_put_double(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_opl3sa2 *chip = snd_kcontrol_chip(kcontrol);\r\nunsigned long flags;\r\nint left_reg = kcontrol->private_value & 0xff;\r\nint right_reg = (kcontrol->private_value >> 8) & 0xff;\r\nint shift_left = (kcontrol->private_value >> 16) & 0x07;\r\nint shift_right = (kcontrol->private_value >> 19) & 0x07;\r\nint mask = (kcontrol->private_value >> 24) & 0xff;\r\nint invert = (kcontrol->private_value >> 22) & 1;\r\nint change;\r\nunsigned short val1, val2, oval1, oval2;\r\nval1 = ucontrol->value.integer.value[0] & mask;\r\nval2 = ucontrol->value.integer.value[1] & mask;\r\nif (invert) {\r\nval1 = mask - val1;\r\nval2 = mask - val2;\r\n}\r\nval1 <<= shift_left;\r\nval2 <<= shift_right;\r\nspin_lock_irqsave(&chip->reg_lock, flags);\r\nif (left_reg != right_reg) {\r\noval1 = chip->ctlregs[left_reg];\r\noval2 = chip->ctlregs[right_reg];\r\nval1 = (oval1 & ~(mask << shift_left)) | val1;\r\nval2 = (oval2 & ~(mask << shift_right)) | val2;\r\nchange = val1 != oval1 || val2 != oval2;\r\n__snd_opl3sa2_write(chip, left_reg, val1);\r\n__snd_opl3sa2_write(chip, right_reg, val2);\r\n} else {\r\noval1 = chip->ctlregs[left_reg];\r\nval1 = (oval1 & ~((mask << shift_left) | (mask << shift_right))) | val1 | val2;\r\nchange = val1 != oval1;\r\n__snd_opl3sa2_write(chip, left_reg, val1);\r\n}\r\nspin_unlock_irqrestore(&chip->reg_lock, flags);\r\nreturn change;\r\n}\r\nstatic void snd_opl3sa2_master_free(struct snd_kcontrol *kcontrol)\r\n{\r\nstruct snd_opl3sa2 *chip = snd_kcontrol_chip(kcontrol);\r\nchip->master_switch = NULL;\r\nchip->master_volume = NULL;\r\n}\r\nstatic int snd_opl3sa2_mixer(struct snd_card *card)\r\n{\r\nstruct snd_opl3sa2 *chip = card->private_data;\r\nstruct snd_ctl_elem_id id1, id2;\r\nstruct snd_kcontrol *kctl;\r\nunsigned int idx;\r\nint err;\r\nmemset(&id1, 0, sizeof(id1));\r\nmemset(&id2, 0, sizeof(id2));\r\nid1.iface = id2.iface = SNDRV_CTL_ELEM_IFACE_MIXER;\r\nstrcpy(id1.name, "Aux Playback Switch");\r\nstrcpy(id2.name, "CD Playback Switch");\r\nif ((err = snd_ctl_rename_id(card, &id1, &id2)) < 0) {\r\nsnd_printk(KERN_ERR "Cannot rename opl3sa2 control\n");\r\nreturn err;\r\n}\r\nstrcpy(id1.name, "Aux Playback Volume");\r\nstrcpy(id2.name, "CD Playback Volume");\r\nif ((err = snd_ctl_rename_id(card, &id1, &id2)) < 0) {\r\nsnd_printk(KERN_ERR "Cannot rename opl3sa2 control\n");\r\nreturn err;\r\n}\r\nstrcpy(id1.name, "Aux Playback Switch"); id1.index = 1;\r\nstrcpy(id2.name, "FM Playback Switch");\r\nif ((err = snd_ctl_rename_id(card, &id1, &id2)) < 0) {\r\nsnd_printk(KERN_ERR "Cannot rename opl3sa2 control\n");\r\nreturn err;\r\n}\r\nstrcpy(id1.name, "Aux Playback Volume");\r\nstrcpy(id2.name, "FM Playback Volume");\r\nif ((err = snd_ctl_rename_id(card, &id1, &id2)) < 0) {\r\nsnd_printk(KERN_ERR "Cannot rename opl3sa2 control\n");\r\nreturn err;\r\n}\r\nfor (idx = 0; idx < ARRAY_SIZE(snd_opl3sa2_controls); idx++) {\r\nif ((err = snd_ctl_add(card, kctl = snd_ctl_new1(&snd_opl3sa2_controls[idx], chip))) < 0)\r\nreturn err;\r\nswitch (idx) {\r\ncase 0: chip->master_switch = kctl; kctl->private_free = snd_opl3sa2_master_free; break;\r\ncase 1: chip->master_volume = kctl; kctl->private_free = snd_opl3sa2_master_free; break;\r\n}\r\n}\r\nif (chip->version > 2) {\r\nfor (idx = 0; idx < ARRAY_SIZE(snd_opl3sa2_tone_controls); idx++)\r\nif ((err = snd_ctl_add(card, snd_ctl_new1(&snd_opl3sa2_tone_controls[idx], chip))) < 0)\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_opl3sa2_suspend(struct snd_card *card, pm_message_t state)\r\n{\r\nif (card) {\r\nstruct snd_opl3sa2 *chip = card->private_data;\r\nsnd_power_change_state(card, SNDRV_CTL_POWER_D3hot);\r\nchip->wss->suspend(chip->wss);\r\nsnd_opl3sa2_write(chip, OPL3SA2_PM_CTRL, OPL3SA2_PM_D3);\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_opl3sa2_resume(struct snd_card *card)\r\n{\r\nstruct snd_opl3sa2 *chip;\r\nint i;\r\nif (!card)\r\nreturn 0;\r\nchip = card->private_data;\r\nsnd_opl3sa2_write(chip, OPL3SA2_PM_CTRL, OPL3SA2_PM_D0);\r\nfor (i = 2; i <= 0x0a; i++) {\r\nif (i != OPL3SA2_IRQ_STATUS)\r\nsnd_opl3sa2_write(chip, i, chip->ctlregs[i]);\r\n}\r\nif (chip->version > 2) {\r\nfor (i = 0x12; i <= 0x16; i++)\r\nsnd_opl3sa2_write(chip, i, chip->ctlregs[i]);\r\n}\r\nchip->wss->resume(chip->wss);\r\nsnd_power_change_state(card, SNDRV_CTL_POWER_D0);\r\nreturn 0;\r\n}\r\nstatic int snd_opl3sa2_pnp(int dev, struct snd_opl3sa2 *chip,\r\nstruct pnp_dev *pdev)\r\n{\r\nif (pnp_activate_dev(pdev) < 0) {\r\nsnd_printk(KERN_ERR "PnP configure failure (out of resources?)\n");\r\nreturn -EBUSY;\r\n}\r\nsb_port[dev] = pnp_port_start(pdev, 0);\r\nwss_port[dev] = pnp_port_start(pdev, 1);\r\nfm_port[dev] = pnp_port_start(pdev, 2);\r\nmidi_port[dev] = pnp_port_start(pdev, 3);\r\nport[dev] = pnp_port_start(pdev, 4);\r\ndma1[dev] = pnp_dma(pdev, 0);\r\ndma2[dev] = pnp_dma(pdev, 1);\r\nirq[dev] = pnp_irq(pdev, 0);\r\nsnd_printdd("%sPnP OPL3-SA: sb port=0x%lx, wss port=0x%lx, fm port=0x%lx, midi port=0x%lx\n",\r\npnp_device_is_pnpbios(pdev) ? "BIOS" : "ISA", sb_port[dev], wss_port[dev], fm_port[dev], midi_port[dev]);\r\nsnd_printdd("%sPnP OPL3-SA: control port=0x%lx, dma1=%i, dma2=%i, irq=%i\n",\r\npnp_device_is_pnpbios(pdev) ? "BIOS" : "ISA", port[dev], dma1[dev], dma2[dev], irq[dev]);\r\nreturn 0;\r\n}\r\nstatic void snd_opl3sa2_free(struct snd_card *card)\r\n{\r\nstruct snd_opl3sa2 *chip = card->private_data;\r\nif (chip->irq >= 0)\r\nfree_irq(chip->irq, card);\r\nrelease_and_free_resource(chip->res_port);\r\n}\r\nstatic int snd_opl3sa2_card_new(int dev, struct snd_card **cardp)\r\n{\r\nstruct snd_card *card;\r\nstruct snd_opl3sa2 *chip;\r\nint err;\r\nerr = snd_card_create(index[dev], id[dev], THIS_MODULE,\r\nsizeof(struct snd_opl3sa2), &card);\r\nif (err < 0)\r\nreturn err;\r\nstrcpy(card->driver, "OPL3SA2");\r\nstrcpy(card->shortname, "Yamaha OPL3-SA");\r\nchip = card->private_data;\r\nspin_lock_init(&chip->reg_lock);\r\nchip->irq = -1;\r\ncard->private_free = snd_opl3sa2_free;\r\n*cardp = card;\r\nreturn 0;\r\n}\r\nstatic int snd_opl3sa2_probe(struct snd_card *card, int dev)\r\n{\r\nint xirq, xdma1, xdma2;\r\nstruct snd_opl3sa2 *chip;\r\nstruct snd_wss *wss;\r\nstruct snd_opl3 *opl3;\r\nint err;\r\nchip = card->private_data;\r\nchip->ymode = opl3sa3_ymode[dev] & 0x03 ;\r\nchip->port = port[dev];\r\nxirq = irq[dev];\r\nxdma1 = dma1[dev];\r\nxdma2 = dma2[dev];\r\nif (xdma2 < 0)\r\nchip->single_dma = 1;\r\nerr = snd_opl3sa2_detect(card);\r\nif (err < 0)\r\nreturn err;\r\nerr = request_irq(xirq, snd_opl3sa2_interrupt, 0,\r\n"OPL3-SA2", card);\r\nif (err) {\r\nsnd_printk(KERN_ERR PFX "can't grab IRQ %d\n", xirq);\r\nreturn -ENODEV;\r\n}\r\nchip->irq = xirq;\r\nerr = snd_wss_create(card,\r\nwss_port[dev] + 4, -1,\r\nxirq, xdma1, xdma2,\r\nWSS_HW_OPL3SA2, WSS_HWSHARE_IRQ, &wss);\r\nif (err < 0) {\r\nsnd_printd("Oops, WSS not detected at 0x%lx\n", wss_port[dev] + 4);\r\nreturn err;\r\n}\r\nchip->wss = wss;\r\nerr = snd_wss_pcm(wss, 0, NULL);\r\nif (err < 0)\r\nreturn err;\r\nerr = snd_wss_mixer(wss);\r\nif (err < 0)\r\nreturn err;\r\nerr = snd_opl3sa2_mixer(card);\r\nif (err < 0)\r\nreturn err;\r\nerr = snd_wss_timer(wss, 0, NULL);\r\nif (err < 0)\r\nreturn err;\r\nif (fm_port[dev] >= 0x340 && fm_port[dev] < 0x400) {\r\nif ((err = snd_opl3_create(card, fm_port[dev],\r\nfm_port[dev] + 2,\r\nOPL3_HW_OPL3, 0, &opl3)) < 0)\r\nreturn err;\r\nif ((err = snd_opl3_timer_new(opl3, 1, 2)) < 0)\r\nreturn err;\r\nif ((err = snd_opl3_hwdep_new(opl3, 0, 1, &chip->synth)) < 0)\r\nreturn err;\r\n}\r\nif (midi_port[dev] >= 0x300 && midi_port[dev] < 0x340) {\r\nif ((err = snd_mpu401_uart_new(card, 0, MPU401_HW_OPL3SA2,\r\nmidi_port[dev],\r\nMPU401_INFO_IRQ_HOOK, -1,\r\n&chip->rmidi)) < 0)\r\nreturn err;\r\n}\r\nsprintf(card->longname, "%s at 0x%lx, irq %d, dma %d",\r\ncard->shortname, chip->port, xirq, xdma1);\r\nif (xdma2 >= 0)\r\nsprintf(card->longname + strlen(card->longname), "&%d", xdma2);\r\nreturn snd_card_register(card);\r\n}\r\nstatic int snd_opl3sa2_pnp_detect(struct pnp_dev *pdev,\r\nconst struct pnp_device_id *id)\r\n{\r\nstatic int dev;\r\nint err;\r\nstruct snd_card *card;\r\nif (pnp_device_is_isapnp(pdev))\r\nreturn -ENOENT;\r\nfor (; dev < SNDRV_CARDS; dev++) {\r\nif (enable[dev] && isapnp[dev])\r\nbreak;\r\n}\r\nif (dev >= SNDRV_CARDS)\r\nreturn -ENODEV;\r\nerr = snd_opl3sa2_card_new(dev, &card);\r\nif (err < 0)\r\nreturn err;\r\nif ((err = snd_opl3sa2_pnp(dev, card->private_data, pdev)) < 0) {\r\nsnd_card_free(card);\r\nreturn err;\r\n}\r\nsnd_card_set_dev(card, &pdev->dev);\r\nif ((err = snd_opl3sa2_probe(card, dev)) < 0) {\r\nsnd_card_free(card);\r\nreturn err;\r\n}\r\npnp_set_drvdata(pdev, card);\r\ndev++;\r\nreturn 0;\r\n}\r\nstatic void snd_opl3sa2_pnp_remove(struct pnp_dev *pdev)\r\n{\r\nsnd_card_free(pnp_get_drvdata(pdev));\r\npnp_set_drvdata(pdev, NULL);\r\n}\r\nstatic int snd_opl3sa2_pnp_suspend(struct pnp_dev *pdev, pm_message_t state)\r\n{\r\nreturn snd_opl3sa2_suspend(pnp_get_drvdata(pdev), state);\r\n}\r\nstatic int snd_opl3sa2_pnp_resume(struct pnp_dev *pdev)\r\n{\r\nreturn snd_opl3sa2_resume(pnp_get_drvdata(pdev));\r\n}\r\nstatic int snd_opl3sa2_pnp_cdetect(struct pnp_card_link *pcard,\r\nconst struct pnp_card_device_id *id)\r\n{\r\nstatic int dev;\r\nstruct pnp_dev *pdev;\r\nint err;\r\nstruct snd_card *card;\r\npdev = pnp_request_card_device(pcard, id->devs[0].id, NULL);\r\nif (pdev == NULL) {\r\nsnd_printk(KERN_ERR PFX "can't get pnp device from id '%s'\n",\r\nid->devs[0].id);\r\nreturn -EBUSY;\r\n}\r\nfor (; dev < SNDRV_CARDS; dev++) {\r\nif (enable[dev] && isapnp[dev])\r\nbreak;\r\n}\r\nif (dev >= SNDRV_CARDS)\r\nreturn -ENODEV;\r\nerr = snd_opl3sa2_card_new(dev, &card);\r\nif (err < 0)\r\nreturn err;\r\nif ((err = snd_opl3sa2_pnp(dev, card->private_data, pdev)) < 0) {\r\nsnd_card_free(card);\r\nreturn err;\r\n}\r\nsnd_card_set_dev(card, &pdev->dev);\r\nif ((err = snd_opl3sa2_probe(card, dev)) < 0) {\r\nsnd_card_free(card);\r\nreturn err;\r\n}\r\npnp_set_card_drvdata(pcard, card);\r\ndev++;\r\nreturn 0;\r\n}\r\nstatic void snd_opl3sa2_pnp_cremove(struct pnp_card_link *pcard)\r\n{\r\nsnd_card_free(pnp_get_card_drvdata(pcard));\r\npnp_set_card_drvdata(pcard, NULL);\r\n}\r\nstatic int snd_opl3sa2_pnp_csuspend(struct pnp_card_link *pcard, pm_message_t state)\r\n{\r\nreturn snd_opl3sa2_suspend(pnp_get_card_drvdata(pcard), state);\r\n}\r\nstatic int snd_opl3sa2_pnp_cresume(struct pnp_card_link *pcard)\r\n{\r\nreturn snd_opl3sa2_resume(pnp_get_card_drvdata(pcard));\r\n}\r\nstatic int snd_opl3sa2_isa_match(struct device *pdev,\r\nunsigned int dev)\r\n{\r\nif (!enable[dev])\r\nreturn 0;\r\n#ifdef CONFIG_PNP\r\nif (isapnp[dev])\r\nreturn 0;\r\n#endif\r\nif (port[dev] == SNDRV_AUTO_PORT) {\r\nsnd_printk(KERN_ERR PFX "specify port\n");\r\nreturn 0;\r\n}\r\nif (wss_port[dev] == SNDRV_AUTO_PORT) {\r\nsnd_printk(KERN_ERR PFX "specify wss_port\n");\r\nreturn 0;\r\n}\r\nif (fm_port[dev] == SNDRV_AUTO_PORT) {\r\nsnd_printk(KERN_ERR PFX "specify fm_port\n");\r\nreturn 0;\r\n}\r\nif (midi_port[dev] == SNDRV_AUTO_PORT) {\r\nsnd_printk(KERN_ERR PFX "specify midi_port\n");\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nstatic int snd_opl3sa2_isa_probe(struct device *pdev,\r\nunsigned int dev)\r\n{\r\nstruct snd_card *card;\r\nint err;\r\nerr = snd_opl3sa2_card_new(dev, &card);\r\nif (err < 0)\r\nreturn err;\r\nsnd_card_set_dev(card, pdev);\r\nif ((err = snd_opl3sa2_probe(card, dev)) < 0) {\r\nsnd_card_free(card);\r\nreturn err;\r\n}\r\ndev_set_drvdata(pdev, card);\r\nreturn 0;\r\n}\r\nstatic int snd_opl3sa2_isa_remove(struct device *devptr,\r\nunsigned int dev)\r\n{\r\nsnd_card_free(dev_get_drvdata(devptr));\r\ndev_set_drvdata(devptr, NULL);\r\nreturn 0;\r\n}\r\nstatic int snd_opl3sa2_isa_suspend(struct device *dev, unsigned int n,\r\npm_message_t state)\r\n{\r\nreturn snd_opl3sa2_suspend(dev_get_drvdata(dev), state);\r\n}\r\nstatic int snd_opl3sa2_isa_resume(struct device *dev, unsigned int n)\r\n{\r\nreturn snd_opl3sa2_resume(dev_get_drvdata(dev));\r\n}\r\nstatic int __init alsa_card_opl3sa2_init(void)\r\n{\r\nint err;\r\nerr = isa_register_driver(&snd_opl3sa2_isa_driver, SNDRV_CARDS);\r\n#ifdef CONFIG_PNP\r\nif (!err)\r\nisa_registered = 1;\r\nerr = pnp_register_driver(&opl3sa2_pnp_driver);\r\nif (!err)\r\npnp_registered = 1;\r\nerr = pnp_register_card_driver(&opl3sa2_pnpc_driver);\r\nif (!err)\r\npnpc_registered = 1;\r\nif (isa_registered || pnp_registered)\r\nerr = 0;\r\n#endif\r\nreturn err;\r\n}\r\nstatic void __exit alsa_card_opl3sa2_exit(void)\r\n{\r\n#ifdef CONFIG_PNP\r\nif (pnpc_registered)\r\npnp_unregister_card_driver(&opl3sa2_pnpc_driver);\r\nif (pnp_registered)\r\npnp_unregister_driver(&opl3sa2_pnp_driver);\r\nif (isa_registered)\r\n#endif\r\nisa_unregister_driver(&snd_opl3sa2_isa_driver);\r\n}
