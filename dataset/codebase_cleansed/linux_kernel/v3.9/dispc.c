static inline void dispc_write_reg(const u16 idx, u32 val)\r\n{\r\n__raw_writel(val, dispc.base + idx);\r\n}\r\nstatic inline u32 dispc_read_reg(const u16 idx)\r\n{\r\nreturn __raw_readl(dispc.base + idx);\r\n}\r\nstatic u32 mgr_fld_read(enum omap_channel channel, enum mgr_reg_fields regfld)\r\n{\r\nconst struct reg_field rfld = mgr_desc[channel].reg_desc[regfld];\r\nreturn REG_GET(rfld.reg, rfld.high, rfld.low);\r\n}\r\nstatic void mgr_fld_write(enum omap_channel channel,\r\nenum mgr_reg_fields regfld, int val) {\r\nconst struct reg_field rfld = mgr_desc[channel].reg_desc[regfld];\r\nREG_FLD_MOD(rfld.reg, val, rfld.high, rfld.low);\r\n}\r\nstatic void dispc_save_context(void)\r\n{\r\nint i, j;\r\nDSSDBG("dispc_save_context\n");\r\nSR(IRQENABLE);\r\nSR(CONTROL);\r\nSR(CONFIG);\r\nSR(LINE_NUMBER);\r\nif (dss_has_feature(FEAT_ALPHA_FIXED_ZORDER) ||\r\ndss_has_feature(FEAT_ALPHA_FREE_ZORDER))\r\nSR(GLOBAL_ALPHA);\r\nif (dss_has_feature(FEAT_MGR_LCD2)) {\r\nSR(CONTROL2);\r\nSR(CONFIG2);\r\n}\r\nif (dss_has_feature(FEAT_MGR_LCD3)) {\r\nSR(CONTROL3);\r\nSR(CONFIG3);\r\n}\r\nfor (i = 0; i < dss_feat_get_num_mgrs(); i++) {\r\nSR(DEFAULT_COLOR(i));\r\nSR(TRANS_COLOR(i));\r\nSR(SIZE_MGR(i));\r\nif (i == OMAP_DSS_CHANNEL_DIGIT)\r\ncontinue;\r\nSR(TIMING_H(i));\r\nSR(TIMING_V(i));\r\nSR(POL_FREQ(i));\r\nSR(DIVISORo(i));\r\nSR(DATA_CYCLE1(i));\r\nSR(DATA_CYCLE2(i));\r\nSR(DATA_CYCLE3(i));\r\nif (dss_has_feature(FEAT_CPR)) {\r\nSR(CPR_COEF_R(i));\r\nSR(CPR_COEF_G(i));\r\nSR(CPR_COEF_B(i));\r\n}\r\n}\r\nfor (i = 0; i < dss_feat_get_num_ovls(); i++) {\r\nSR(OVL_BA0(i));\r\nSR(OVL_BA1(i));\r\nSR(OVL_POSITION(i));\r\nSR(OVL_SIZE(i));\r\nSR(OVL_ATTRIBUTES(i));\r\nSR(OVL_FIFO_THRESHOLD(i));\r\nSR(OVL_ROW_INC(i));\r\nSR(OVL_PIXEL_INC(i));\r\nif (dss_has_feature(FEAT_PRELOAD))\r\nSR(OVL_PRELOAD(i));\r\nif (i == OMAP_DSS_GFX) {\r\nSR(OVL_WINDOW_SKIP(i));\r\nSR(OVL_TABLE_BA(i));\r\ncontinue;\r\n}\r\nSR(OVL_FIR(i));\r\nSR(OVL_PICTURE_SIZE(i));\r\nSR(OVL_ACCU0(i));\r\nSR(OVL_ACCU1(i));\r\nfor (j = 0; j < 8; j++)\r\nSR(OVL_FIR_COEF_H(i, j));\r\nfor (j = 0; j < 8; j++)\r\nSR(OVL_FIR_COEF_HV(i, j));\r\nfor (j = 0; j < 5; j++)\r\nSR(OVL_CONV_COEF(i, j));\r\nif (dss_has_feature(FEAT_FIR_COEF_V)) {\r\nfor (j = 0; j < 8; j++)\r\nSR(OVL_FIR_COEF_V(i, j));\r\n}\r\nif (dss_has_feature(FEAT_HANDLE_UV_SEPARATE)) {\r\nSR(OVL_BA0_UV(i));\r\nSR(OVL_BA1_UV(i));\r\nSR(OVL_FIR2(i));\r\nSR(OVL_ACCU2_0(i));\r\nSR(OVL_ACCU2_1(i));\r\nfor (j = 0; j < 8; j++)\r\nSR(OVL_FIR_COEF_H2(i, j));\r\nfor (j = 0; j < 8; j++)\r\nSR(OVL_FIR_COEF_HV2(i, j));\r\nfor (j = 0; j < 8; j++)\r\nSR(OVL_FIR_COEF_V2(i, j));\r\n}\r\nif (dss_has_feature(FEAT_ATTR2))\r\nSR(OVL_ATTRIBUTES2(i));\r\n}\r\nif (dss_has_feature(FEAT_CORE_CLK_DIV))\r\nSR(DIVISOR);\r\ndispc.ctx_loss_cnt = dss_get_ctx_loss_count();\r\ndispc.ctx_valid = true;\r\nDSSDBG("context saved, ctx_loss_count %d\n", dispc.ctx_loss_cnt);\r\n}\r\nstatic void dispc_restore_context(void)\r\n{\r\nint i, j, ctx;\r\nDSSDBG("dispc_restore_context\n");\r\nif (!dispc.ctx_valid)\r\nreturn;\r\nctx = dss_get_ctx_loss_count();\r\nif (ctx >= 0 && ctx == dispc.ctx_loss_cnt)\r\nreturn;\r\nDSSDBG("ctx_loss_count: saved %d, current %d\n",\r\ndispc.ctx_loss_cnt, ctx);\r\nRR(CONFIG);\r\nRR(LINE_NUMBER);\r\nif (dss_has_feature(FEAT_ALPHA_FIXED_ZORDER) ||\r\ndss_has_feature(FEAT_ALPHA_FREE_ZORDER))\r\nRR(GLOBAL_ALPHA);\r\nif (dss_has_feature(FEAT_MGR_LCD2))\r\nRR(CONFIG2);\r\nif (dss_has_feature(FEAT_MGR_LCD3))\r\nRR(CONFIG3);\r\nfor (i = 0; i < dss_feat_get_num_mgrs(); i++) {\r\nRR(DEFAULT_COLOR(i));\r\nRR(TRANS_COLOR(i));\r\nRR(SIZE_MGR(i));\r\nif (i == OMAP_DSS_CHANNEL_DIGIT)\r\ncontinue;\r\nRR(TIMING_H(i));\r\nRR(TIMING_V(i));\r\nRR(POL_FREQ(i));\r\nRR(DIVISORo(i));\r\nRR(DATA_CYCLE1(i));\r\nRR(DATA_CYCLE2(i));\r\nRR(DATA_CYCLE3(i));\r\nif (dss_has_feature(FEAT_CPR)) {\r\nRR(CPR_COEF_R(i));\r\nRR(CPR_COEF_G(i));\r\nRR(CPR_COEF_B(i));\r\n}\r\n}\r\nfor (i = 0; i < dss_feat_get_num_ovls(); i++) {\r\nRR(OVL_BA0(i));\r\nRR(OVL_BA1(i));\r\nRR(OVL_POSITION(i));\r\nRR(OVL_SIZE(i));\r\nRR(OVL_ATTRIBUTES(i));\r\nRR(OVL_FIFO_THRESHOLD(i));\r\nRR(OVL_ROW_INC(i));\r\nRR(OVL_PIXEL_INC(i));\r\nif (dss_has_feature(FEAT_PRELOAD))\r\nRR(OVL_PRELOAD(i));\r\nif (i == OMAP_DSS_GFX) {\r\nRR(OVL_WINDOW_SKIP(i));\r\nRR(OVL_TABLE_BA(i));\r\ncontinue;\r\n}\r\nRR(OVL_FIR(i));\r\nRR(OVL_PICTURE_SIZE(i));\r\nRR(OVL_ACCU0(i));\r\nRR(OVL_ACCU1(i));\r\nfor (j = 0; j < 8; j++)\r\nRR(OVL_FIR_COEF_H(i, j));\r\nfor (j = 0; j < 8; j++)\r\nRR(OVL_FIR_COEF_HV(i, j));\r\nfor (j = 0; j < 5; j++)\r\nRR(OVL_CONV_COEF(i, j));\r\nif (dss_has_feature(FEAT_FIR_COEF_V)) {\r\nfor (j = 0; j < 8; j++)\r\nRR(OVL_FIR_COEF_V(i, j));\r\n}\r\nif (dss_has_feature(FEAT_HANDLE_UV_SEPARATE)) {\r\nRR(OVL_BA0_UV(i));\r\nRR(OVL_BA1_UV(i));\r\nRR(OVL_FIR2(i));\r\nRR(OVL_ACCU2_0(i));\r\nRR(OVL_ACCU2_1(i));\r\nfor (j = 0; j < 8; j++)\r\nRR(OVL_FIR_COEF_H2(i, j));\r\nfor (j = 0; j < 8; j++)\r\nRR(OVL_FIR_COEF_HV2(i, j));\r\nfor (j = 0; j < 8; j++)\r\nRR(OVL_FIR_COEF_V2(i, j));\r\n}\r\nif (dss_has_feature(FEAT_ATTR2))\r\nRR(OVL_ATTRIBUTES2(i));\r\n}\r\nif (dss_has_feature(FEAT_CORE_CLK_DIV))\r\nRR(DIVISOR);\r\nRR(CONTROL);\r\nif (dss_has_feature(FEAT_MGR_LCD2))\r\nRR(CONTROL2);\r\nif (dss_has_feature(FEAT_MGR_LCD3))\r\nRR(CONTROL3);\r\ndispc_clear_irqstatus(DISPC_IRQ_SYNC_LOST_DIGIT);\r\nRR(IRQENABLE);\r\nDSSDBG("context restored\n");\r\n}\r\nint dispc_runtime_get(void)\r\n{\r\nint r;\r\nDSSDBG("dispc_runtime_get\n");\r\nr = pm_runtime_get_sync(&dispc.pdev->dev);\r\nWARN_ON(r < 0);\r\nreturn r < 0 ? r : 0;\r\n}\r\nvoid dispc_runtime_put(void)\r\n{\r\nint r;\r\nDSSDBG("dispc_runtime_put\n");\r\nr = pm_runtime_put_sync(&dispc.pdev->dev);\r\nWARN_ON(r < 0 && r != -ENOSYS);\r\n}\r\nu32 dispc_mgr_get_vsync_irq(enum omap_channel channel)\r\n{\r\nreturn mgr_desc[channel].vsync_irq;\r\n}\r\nu32 dispc_mgr_get_framedone_irq(enum omap_channel channel)\r\n{\r\nif (channel == OMAP_DSS_CHANNEL_DIGIT && dispc.feat->no_framedone_tv)\r\nreturn 0;\r\nreturn mgr_desc[channel].framedone_irq;\r\n}\r\nu32 dispc_mgr_get_sync_lost_irq(enum omap_channel channel)\r\n{\r\nreturn mgr_desc[channel].sync_lost_irq;\r\n}\r\nu32 dispc_wb_get_framedone_irq(void)\r\n{\r\nreturn DISPC_IRQ_FRAMEDONEWB;\r\n}\r\nbool dispc_mgr_go_busy(enum omap_channel channel)\r\n{\r\nreturn mgr_fld_read(channel, DISPC_MGR_FLD_GO) == 1;\r\n}\r\nvoid dispc_mgr_go(enum omap_channel channel)\r\n{\r\nWARN_ON(dispc_mgr_is_enabled(channel) == false);\r\nWARN_ON(dispc_mgr_go_busy(channel));\r\nDSSDBG("GO %s\n", mgr_desc[channel].name);\r\nmgr_fld_write(channel, DISPC_MGR_FLD_GO, 1);\r\n}\r\nbool dispc_wb_go_busy(void)\r\n{\r\nreturn REG_GET(DISPC_CONTROL2, 6, 6) == 1;\r\n}\r\nvoid dispc_wb_go(void)\r\n{\r\nenum omap_plane plane = OMAP_DSS_WB;\r\nbool enable, go;\r\nenable = REG_GET(DISPC_OVL_ATTRIBUTES(plane), 0, 0) == 1;\r\nif (!enable)\r\nreturn;\r\ngo = REG_GET(DISPC_CONTROL2, 6, 6) == 1;\r\nif (go) {\r\nDSSERR("GO bit not down for WB\n");\r\nreturn;\r\n}\r\nREG_FLD_MOD(DISPC_CONTROL2, 1, 6, 6);\r\n}\r\nstatic void dispc_ovl_write_firh_reg(enum omap_plane plane, int reg, u32 value)\r\n{\r\ndispc_write_reg(DISPC_OVL_FIR_COEF_H(plane, reg), value);\r\n}\r\nstatic void dispc_ovl_write_firhv_reg(enum omap_plane plane, int reg, u32 value)\r\n{\r\ndispc_write_reg(DISPC_OVL_FIR_COEF_HV(plane, reg), value);\r\n}\r\nstatic void dispc_ovl_write_firv_reg(enum omap_plane plane, int reg, u32 value)\r\n{\r\ndispc_write_reg(DISPC_OVL_FIR_COEF_V(plane, reg), value);\r\n}\r\nstatic void dispc_ovl_write_firh2_reg(enum omap_plane plane, int reg, u32 value)\r\n{\r\nBUG_ON(plane == OMAP_DSS_GFX);\r\ndispc_write_reg(DISPC_OVL_FIR_COEF_H2(plane, reg), value);\r\n}\r\nstatic void dispc_ovl_write_firhv2_reg(enum omap_plane plane, int reg,\r\nu32 value)\r\n{\r\nBUG_ON(plane == OMAP_DSS_GFX);\r\ndispc_write_reg(DISPC_OVL_FIR_COEF_HV2(plane, reg), value);\r\n}\r\nstatic void dispc_ovl_write_firv2_reg(enum omap_plane plane, int reg, u32 value)\r\n{\r\nBUG_ON(plane == OMAP_DSS_GFX);\r\ndispc_write_reg(DISPC_OVL_FIR_COEF_V2(plane, reg), value);\r\n}\r\nstatic void dispc_ovl_set_scale_coef(enum omap_plane plane, int fir_hinc,\r\nint fir_vinc, int five_taps,\r\nenum omap_color_component color_comp)\r\n{\r\nconst struct dispc_coef *h_coef, *v_coef;\r\nint i;\r\nh_coef = dispc_ovl_get_scale_coef(fir_hinc, true);\r\nv_coef = dispc_ovl_get_scale_coef(fir_vinc, five_taps);\r\nfor (i = 0; i < 8; i++) {\r\nu32 h, hv;\r\nh = FLD_VAL(h_coef[i].hc0_vc00, 7, 0)\r\n| FLD_VAL(h_coef[i].hc1_vc0, 15, 8)\r\n| FLD_VAL(h_coef[i].hc2_vc1, 23, 16)\r\n| FLD_VAL(h_coef[i].hc3_vc2, 31, 24);\r\nhv = FLD_VAL(h_coef[i].hc4_vc22, 7, 0)\r\n| FLD_VAL(v_coef[i].hc1_vc0, 15, 8)\r\n| FLD_VAL(v_coef[i].hc2_vc1, 23, 16)\r\n| FLD_VAL(v_coef[i].hc3_vc2, 31, 24);\r\nif (color_comp == DISPC_COLOR_COMPONENT_RGB_Y) {\r\ndispc_ovl_write_firh_reg(plane, i, h);\r\ndispc_ovl_write_firhv_reg(plane, i, hv);\r\n} else {\r\ndispc_ovl_write_firh2_reg(plane, i, h);\r\ndispc_ovl_write_firhv2_reg(plane, i, hv);\r\n}\r\n}\r\nif (five_taps) {\r\nfor (i = 0; i < 8; i++) {\r\nu32 v;\r\nv = FLD_VAL(v_coef[i].hc0_vc00, 7, 0)\r\n| FLD_VAL(v_coef[i].hc4_vc22, 15, 8);\r\nif (color_comp == DISPC_COLOR_COMPONENT_RGB_Y)\r\ndispc_ovl_write_firv_reg(plane, i, v);\r\nelse\r\ndispc_ovl_write_firv2_reg(plane, i, v);\r\n}\r\n}\r\n}\r\nstatic void dispc_ovl_write_color_conv_coef(enum omap_plane plane,\r\nconst struct color_conv_coef *ct)\r\n{\r\n#define CVAL(x, y) (FLD_VAL(x, 26, 16) | FLD_VAL(y, 10, 0))\r\ndispc_write_reg(DISPC_OVL_CONV_COEF(plane, 0), CVAL(ct->rcr, ct->ry));\r\ndispc_write_reg(DISPC_OVL_CONV_COEF(plane, 1), CVAL(ct->gy, ct->rcb));\r\ndispc_write_reg(DISPC_OVL_CONV_COEF(plane, 2), CVAL(ct->gcb, ct->gcr));\r\ndispc_write_reg(DISPC_OVL_CONV_COEF(plane, 3), CVAL(ct->bcr, ct->by));\r\ndispc_write_reg(DISPC_OVL_CONV_COEF(plane, 4), CVAL(0, ct->bcb));\r\nREG_FLD_MOD(DISPC_OVL_ATTRIBUTES(plane), ct->full_range, 11, 11);\r\n#undef CVAL\r\n}\r\nstatic void dispc_setup_color_conv_coef(void)\r\n{\r\nint i;\r\nint num_ovl = dss_feat_get_num_ovls();\r\nint num_wb = dss_feat_get_num_wbs();\r\nconst struct color_conv_coef ctbl_bt601_5_ovl = {\r\n298, 409, 0, 298, -208, -100, 298, 0, 517, 0,\r\n};\r\nconst struct color_conv_coef ctbl_bt601_5_wb = {\r\n66, 112, -38, 129, -94, -74, 25, -18, 112, 0,\r\n};\r\nfor (i = 1; i < num_ovl; i++)\r\ndispc_ovl_write_color_conv_coef(i, &ctbl_bt601_5_ovl);\r\nfor (; i < num_wb; i++)\r\ndispc_ovl_write_color_conv_coef(i, &ctbl_bt601_5_wb);\r\n}\r\nstatic void dispc_ovl_set_ba0(enum omap_plane plane, u32 paddr)\r\n{\r\ndispc_write_reg(DISPC_OVL_BA0(plane), paddr);\r\n}\r\nstatic void dispc_ovl_set_ba1(enum omap_plane plane, u32 paddr)\r\n{\r\ndispc_write_reg(DISPC_OVL_BA1(plane), paddr);\r\n}\r\nstatic void dispc_ovl_set_ba0_uv(enum omap_plane plane, u32 paddr)\r\n{\r\ndispc_write_reg(DISPC_OVL_BA0_UV(plane), paddr);\r\n}\r\nstatic void dispc_ovl_set_ba1_uv(enum omap_plane plane, u32 paddr)\r\n{\r\ndispc_write_reg(DISPC_OVL_BA1_UV(plane), paddr);\r\n}\r\nstatic void dispc_ovl_set_pos(enum omap_plane plane,\r\nenum omap_overlay_caps caps, int x, int y)\r\n{\r\nu32 val;\r\nif ((caps & OMAP_DSS_OVL_CAP_POS) == 0)\r\nreturn;\r\nval = FLD_VAL(y, 26, 16) | FLD_VAL(x, 10, 0);\r\ndispc_write_reg(DISPC_OVL_POSITION(plane), val);\r\n}\r\nstatic void dispc_ovl_set_input_size(enum omap_plane plane, int width,\r\nint height)\r\n{\r\nu32 val = FLD_VAL(height - 1, 26, 16) | FLD_VAL(width - 1, 10, 0);\r\nif (plane == OMAP_DSS_GFX || plane == OMAP_DSS_WB)\r\ndispc_write_reg(DISPC_OVL_SIZE(plane), val);\r\nelse\r\ndispc_write_reg(DISPC_OVL_PICTURE_SIZE(plane), val);\r\n}\r\nstatic void dispc_ovl_set_output_size(enum omap_plane plane, int width,\r\nint height)\r\n{\r\nu32 val;\r\nBUG_ON(plane == OMAP_DSS_GFX);\r\nval = FLD_VAL(height - 1, 26, 16) | FLD_VAL(width - 1, 10, 0);\r\nif (plane == OMAP_DSS_WB)\r\ndispc_write_reg(DISPC_OVL_PICTURE_SIZE(plane), val);\r\nelse\r\ndispc_write_reg(DISPC_OVL_SIZE(plane), val);\r\n}\r\nstatic void dispc_ovl_set_zorder(enum omap_plane plane,\r\nenum omap_overlay_caps caps, u8 zorder)\r\n{\r\nif ((caps & OMAP_DSS_OVL_CAP_ZORDER) == 0)\r\nreturn;\r\nREG_FLD_MOD(DISPC_OVL_ATTRIBUTES(plane), zorder, 27, 26);\r\n}\r\nstatic void dispc_ovl_enable_zorder_planes(void)\r\n{\r\nint i;\r\nif (!dss_has_feature(FEAT_ALPHA_FREE_ZORDER))\r\nreturn;\r\nfor (i = 0; i < dss_feat_get_num_ovls(); i++)\r\nREG_FLD_MOD(DISPC_OVL_ATTRIBUTES(i), 1, 25, 25);\r\n}\r\nstatic void dispc_ovl_set_pre_mult_alpha(enum omap_plane plane,\r\nenum omap_overlay_caps caps, bool enable)\r\n{\r\nif ((caps & OMAP_DSS_OVL_CAP_PRE_MULT_ALPHA) == 0)\r\nreturn;\r\nREG_FLD_MOD(DISPC_OVL_ATTRIBUTES(plane), enable ? 1 : 0, 28, 28);\r\n}\r\nstatic void dispc_ovl_setup_global_alpha(enum omap_plane plane,\r\nenum omap_overlay_caps caps, u8 global_alpha)\r\n{\r\nstatic const unsigned shifts[] = { 0, 8, 16, 24, };\r\nint shift;\r\nif ((caps & OMAP_DSS_OVL_CAP_GLOBAL_ALPHA) == 0)\r\nreturn;\r\nshift = shifts[plane];\r\nREG_FLD_MOD(DISPC_GLOBAL_ALPHA, global_alpha, shift + 7, shift);\r\n}\r\nstatic void dispc_ovl_set_pix_inc(enum omap_plane plane, s32 inc)\r\n{\r\ndispc_write_reg(DISPC_OVL_PIXEL_INC(plane), inc);\r\n}\r\nstatic void dispc_ovl_set_row_inc(enum omap_plane plane, s32 inc)\r\n{\r\ndispc_write_reg(DISPC_OVL_ROW_INC(plane), inc);\r\n}\r\nstatic void dispc_ovl_set_color_mode(enum omap_plane plane,\r\nenum omap_color_mode color_mode)\r\n{\r\nu32 m = 0;\r\nif (plane != OMAP_DSS_GFX) {\r\nswitch (color_mode) {\r\ncase OMAP_DSS_COLOR_NV12:\r\nm = 0x0; break;\r\ncase OMAP_DSS_COLOR_RGBX16:\r\nm = 0x1; break;\r\ncase OMAP_DSS_COLOR_RGBA16:\r\nm = 0x2; break;\r\ncase OMAP_DSS_COLOR_RGB12U:\r\nm = 0x4; break;\r\ncase OMAP_DSS_COLOR_ARGB16:\r\nm = 0x5; break;\r\ncase OMAP_DSS_COLOR_RGB16:\r\nm = 0x6; break;\r\ncase OMAP_DSS_COLOR_ARGB16_1555:\r\nm = 0x7; break;\r\ncase OMAP_DSS_COLOR_RGB24U:\r\nm = 0x8; break;\r\ncase OMAP_DSS_COLOR_RGB24P:\r\nm = 0x9; break;\r\ncase OMAP_DSS_COLOR_YUV2:\r\nm = 0xa; break;\r\ncase OMAP_DSS_COLOR_UYVY:\r\nm = 0xb; break;\r\ncase OMAP_DSS_COLOR_ARGB32:\r\nm = 0xc; break;\r\ncase OMAP_DSS_COLOR_RGBA32:\r\nm = 0xd; break;\r\ncase OMAP_DSS_COLOR_RGBX32:\r\nm = 0xe; break;\r\ncase OMAP_DSS_COLOR_XRGB16_1555:\r\nm = 0xf; break;\r\ndefault:\r\nBUG(); return;\r\n}\r\n} else {\r\nswitch (color_mode) {\r\ncase OMAP_DSS_COLOR_CLUT1:\r\nm = 0x0; break;\r\ncase OMAP_DSS_COLOR_CLUT2:\r\nm = 0x1; break;\r\ncase OMAP_DSS_COLOR_CLUT4:\r\nm = 0x2; break;\r\ncase OMAP_DSS_COLOR_CLUT8:\r\nm = 0x3; break;\r\ncase OMAP_DSS_COLOR_RGB12U:\r\nm = 0x4; break;\r\ncase OMAP_DSS_COLOR_ARGB16:\r\nm = 0x5; break;\r\ncase OMAP_DSS_COLOR_RGB16:\r\nm = 0x6; break;\r\ncase OMAP_DSS_COLOR_ARGB16_1555:\r\nm = 0x7; break;\r\ncase OMAP_DSS_COLOR_RGB24U:\r\nm = 0x8; break;\r\ncase OMAP_DSS_COLOR_RGB24P:\r\nm = 0x9; break;\r\ncase OMAP_DSS_COLOR_RGBX16:\r\nm = 0xa; break;\r\ncase OMAP_DSS_COLOR_RGBA16:\r\nm = 0xb; break;\r\ncase OMAP_DSS_COLOR_ARGB32:\r\nm = 0xc; break;\r\ncase OMAP_DSS_COLOR_RGBA32:\r\nm = 0xd; break;\r\ncase OMAP_DSS_COLOR_RGBX32:\r\nm = 0xe; break;\r\ncase OMAP_DSS_COLOR_XRGB16_1555:\r\nm = 0xf; break;\r\ndefault:\r\nBUG(); return;\r\n}\r\n}\r\nREG_FLD_MOD(DISPC_OVL_ATTRIBUTES(plane), m, 4, 1);\r\n}\r\nstatic void dispc_ovl_configure_burst_type(enum omap_plane plane,\r\nenum omap_dss_rotation_type rotation_type)\r\n{\r\nif (dss_has_feature(FEAT_BURST_2D) == 0)\r\nreturn;\r\nif (rotation_type == OMAP_DSS_ROT_TILER)\r\nREG_FLD_MOD(DISPC_OVL_ATTRIBUTES(plane), 1, 29, 29);\r\nelse\r\nREG_FLD_MOD(DISPC_OVL_ATTRIBUTES(plane), 0, 29, 29);\r\n}\r\nvoid dispc_ovl_set_channel_out(enum omap_plane plane, enum omap_channel channel)\r\n{\r\nint shift;\r\nu32 val;\r\nint chan = 0, chan2 = 0;\r\nswitch (plane) {\r\ncase OMAP_DSS_GFX:\r\nshift = 8;\r\nbreak;\r\ncase OMAP_DSS_VIDEO1:\r\ncase OMAP_DSS_VIDEO2:\r\ncase OMAP_DSS_VIDEO3:\r\nshift = 16;\r\nbreak;\r\ndefault:\r\nBUG();\r\nreturn;\r\n}\r\nval = dispc_read_reg(DISPC_OVL_ATTRIBUTES(plane));\r\nif (dss_has_feature(FEAT_MGR_LCD2)) {\r\nswitch (channel) {\r\ncase OMAP_DSS_CHANNEL_LCD:\r\nchan = 0;\r\nchan2 = 0;\r\nbreak;\r\ncase OMAP_DSS_CHANNEL_DIGIT:\r\nchan = 1;\r\nchan2 = 0;\r\nbreak;\r\ncase OMAP_DSS_CHANNEL_LCD2:\r\nchan = 0;\r\nchan2 = 1;\r\nbreak;\r\ncase OMAP_DSS_CHANNEL_LCD3:\r\nif (dss_has_feature(FEAT_MGR_LCD3)) {\r\nchan = 0;\r\nchan2 = 2;\r\n} else {\r\nBUG();\r\nreturn;\r\n}\r\nbreak;\r\ndefault:\r\nBUG();\r\nreturn;\r\n}\r\nval = FLD_MOD(val, chan, shift, shift);\r\nval = FLD_MOD(val, chan2, 31, 30);\r\n} else {\r\nval = FLD_MOD(val, channel, shift, shift);\r\n}\r\ndispc_write_reg(DISPC_OVL_ATTRIBUTES(plane), val);\r\n}\r\nstatic enum omap_channel dispc_ovl_get_channel_out(enum omap_plane plane)\r\n{\r\nint shift;\r\nu32 val;\r\nenum omap_channel channel;\r\nswitch (plane) {\r\ncase OMAP_DSS_GFX:\r\nshift = 8;\r\nbreak;\r\ncase OMAP_DSS_VIDEO1:\r\ncase OMAP_DSS_VIDEO2:\r\ncase OMAP_DSS_VIDEO3:\r\nshift = 16;\r\nbreak;\r\ndefault:\r\nBUG();\r\nreturn 0;\r\n}\r\nval = dispc_read_reg(DISPC_OVL_ATTRIBUTES(plane));\r\nif (dss_has_feature(FEAT_MGR_LCD3)) {\r\nif (FLD_GET(val, 31, 30) == 0)\r\nchannel = FLD_GET(val, shift, shift);\r\nelse if (FLD_GET(val, 31, 30) == 1)\r\nchannel = OMAP_DSS_CHANNEL_LCD2;\r\nelse\r\nchannel = OMAP_DSS_CHANNEL_LCD3;\r\n} else if (dss_has_feature(FEAT_MGR_LCD2)) {\r\nif (FLD_GET(val, 31, 30) == 0)\r\nchannel = FLD_GET(val, shift, shift);\r\nelse\r\nchannel = OMAP_DSS_CHANNEL_LCD2;\r\n} else {\r\nchannel = FLD_GET(val, shift, shift);\r\n}\r\nreturn channel;\r\n}\r\nvoid dispc_wb_set_channel_in(enum dss_writeback_channel channel)\r\n{\r\nenum omap_plane plane = OMAP_DSS_WB;\r\nREG_FLD_MOD(DISPC_OVL_ATTRIBUTES(plane), channel, 18, 16);\r\n}\r\nstatic void dispc_ovl_set_burst_size(enum omap_plane plane,\r\nenum omap_burst_size burst_size)\r\n{\r\nstatic const unsigned shifts[] = { 6, 14, 14, 14, 14, };\r\nint shift;\r\nshift = shifts[plane];\r\nREG_FLD_MOD(DISPC_OVL_ATTRIBUTES(plane), burst_size, shift + 1, shift);\r\n}\r\nstatic void dispc_configure_burst_sizes(void)\r\n{\r\nint i;\r\nconst int burst_size = BURST_SIZE_X8;\r\nfor (i = 0; i < dss_feat_get_num_ovls(); ++i)\r\ndispc_ovl_set_burst_size(i, burst_size);\r\n}\r\nstatic u32 dispc_ovl_get_burst_size(enum omap_plane plane)\r\n{\r\nunsigned unit = dss_feat_get_burst_size_unit();\r\nreturn unit * 8;\r\n}\r\nvoid dispc_enable_gamma_table(bool enable)\r\n{\r\nif (enable) {\r\nDSSWARN("Gamma table enabling for TV not yet supported");\r\nreturn;\r\n}\r\nREG_FLD_MOD(DISPC_CONFIG, enable, 9, 9);\r\n}\r\nstatic void dispc_mgr_enable_cpr(enum omap_channel channel, bool enable)\r\n{\r\nif (channel == OMAP_DSS_CHANNEL_DIGIT)\r\nreturn;\r\nmgr_fld_write(channel, DISPC_MGR_FLD_CPR, enable);\r\n}\r\nstatic void dispc_mgr_set_cpr_coef(enum omap_channel channel,\r\nconst struct omap_dss_cpr_coefs *coefs)\r\n{\r\nu32 coef_r, coef_g, coef_b;\r\nif (!dss_mgr_is_lcd(channel))\r\nreturn;\r\ncoef_r = FLD_VAL(coefs->rr, 31, 22) | FLD_VAL(coefs->rg, 20, 11) |\r\nFLD_VAL(coefs->rb, 9, 0);\r\ncoef_g = FLD_VAL(coefs->gr, 31, 22) | FLD_VAL(coefs->gg, 20, 11) |\r\nFLD_VAL(coefs->gb, 9, 0);\r\ncoef_b = FLD_VAL(coefs->br, 31, 22) | FLD_VAL(coefs->bg, 20, 11) |\r\nFLD_VAL(coefs->bb, 9, 0);\r\ndispc_write_reg(DISPC_CPR_COEF_R(channel), coef_r);\r\ndispc_write_reg(DISPC_CPR_COEF_G(channel), coef_g);\r\ndispc_write_reg(DISPC_CPR_COEF_B(channel), coef_b);\r\n}\r\nstatic void dispc_ovl_set_vid_color_conv(enum omap_plane plane, bool enable)\r\n{\r\nu32 val;\r\nBUG_ON(plane == OMAP_DSS_GFX);\r\nval = dispc_read_reg(DISPC_OVL_ATTRIBUTES(plane));\r\nval = FLD_MOD(val, enable, 9, 9);\r\ndispc_write_reg(DISPC_OVL_ATTRIBUTES(plane), val);\r\n}\r\nstatic void dispc_ovl_enable_replication(enum omap_plane plane,\r\nenum omap_overlay_caps caps, bool enable)\r\n{\r\nstatic const unsigned shifts[] = { 5, 10, 10, 10 };\r\nint shift;\r\nif ((caps & OMAP_DSS_OVL_CAP_REPLICATION) == 0)\r\nreturn;\r\nshift = shifts[plane];\r\nREG_FLD_MOD(DISPC_OVL_ATTRIBUTES(plane), enable, shift, shift);\r\n}\r\nstatic void dispc_mgr_set_size(enum omap_channel channel, u16 width,\r\nu16 height)\r\n{\r\nu32 val;\r\nval = FLD_VAL(height - 1, dispc.feat->mgr_height_start, 16) |\r\nFLD_VAL(width - 1, dispc.feat->mgr_width_start, 0);\r\ndispc_write_reg(DISPC_SIZE_MGR(channel), val);\r\n}\r\nstatic void dispc_init_fifos(void)\r\n{\r\nu32 size;\r\nint fifo;\r\nu8 start, end;\r\nu32 unit;\r\nunit = dss_feat_get_buffer_size_unit();\r\ndss_feat_get_reg_field(FEAT_REG_FIFOSIZE, &start, &end);\r\nfor (fifo = 0; fifo < dispc.feat->num_fifos; ++fifo) {\r\nsize = REG_GET(DISPC_OVL_FIFO_SIZE_STATUS(fifo), start, end);\r\nsize *= unit;\r\ndispc.fifo_size[fifo] = size;\r\ndispc.fifo_assignment[fifo] = fifo;\r\n}\r\nif (dispc.feat->gfx_fifo_workaround) {\r\nu32 v;\r\nv = dispc_read_reg(DISPC_GLOBAL_BUFFER);\r\nv = FLD_MOD(v, 4, 2, 0);\r\nv = FLD_MOD(v, 4, 5, 3);\r\nv = FLD_MOD(v, 0, 26, 24);\r\nv = FLD_MOD(v, 0, 29, 27);\r\ndispc_write_reg(DISPC_GLOBAL_BUFFER, v);\r\ndispc.fifo_assignment[OMAP_DSS_GFX] = OMAP_DSS_WB;\r\ndispc.fifo_assignment[OMAP_DSS_WB] = OMAP_DSS_GFX;\r\n}\r\n}\r\nstatic u32 dispc_ovl_get_fifo_size(enum omap_plane plane)\r\n{\r\nint fifo;\r\nu32 size = 0;\r\nfor (fifo = 0; fifo < dispc.feat->num_fifos; ++fifo) {\r\nif (dispc.fifo_assignment[fifo] == plane)\r\nsize += dispc.fifo_size[fifo];\r\n}\r\nreturn size;\r\n}\r\nvoid dispc_ovl_set_fifo_threshold(enum omap_plane plane, u32 low, u32 high)\r\n{\r\nu8 hi_start, hi_end, lo_start, lo_end;\r\nu32 unit;\r\nunit = dss_feat_get_buffer_size_unit();\r\nWARN_ON(low % unit != 0);\r\nWARN_ON(high % unit != 0);\r\nlow /= unit;\r\nhigh /= unit;\r\ndss_feat_get_reg_field(FEAT_REG_FIFOHIGHTHRESHOLD, &hi_start, &hi_end);\r\ndss_feat_get_reg_field(FEAT_REG_FIFOLOWTHRESHOLD, &lo_start, &lo_end);\r\nDSSDBG("fifo(%d) threshold (bytes), old %u/%u, new %u/%u\n",\r\nplane,\r\nREG_GET(DISPC_OVL_FIFO_THRESHOLD(plane),\r\nlo_start, lo_end) * unit,\r\nREG_GET(DISPC_OVL_FIFO_THRESHOLD(plane),\r\nhi_start, hi_end) * unit,\r\nlow * unit, high * unit);\r\ndispc_write_reg(DISPC_OVL_FIFO_THRESHOLD(plane),\r\nFLD_VAL(high, hi_start, hi_end) |\r\nFLD_VAL(low, lo_start, lo_end));\r\n}\r\nvoid dispc_enable_fifomerge(bool enable)\r\n{\r\nif (!dss_has_feature(FEAT_FIFO_MERGE)) {\r\nWARN_ON(enable);\r\nreturn;\r\n}\r\nDSSDBG("FIFO merge %s\n", enable ? "enabled" : "disabled");\r\nREG_FLD_MOD(DISPC_CONFIG, enable ? 1 : 0, 14, 14);\r\n}\r\nvoid dispc_ovl_compute_fifo_thresholds(enum omap_plane plane,\r\nu32 *fifo_low, u32 *fifo_high, bool use_fifomerge,\r\nbool manual_update)\r\n{\r\nunsigned buf_unit = dss_feat_get_buffer_size_unit();\r\nunsigned ovl_fifo_size, total_fifo_size, burst_size;\r\nint i;\r\nburst_size = dispc_ovl_get_burst_size(plane);\r\novl_fifo_size = dispc_ovl_get_fifo_size(plane);\r\nif (use_fifomerge) {\r\ntotal_fifo_size = 0;\r\nfor (i = 0; i < dss_feat_get_num_ovls(); ++i)\r\ntotal_fifo_size += dispc_ovl_get_fifo_size(i);\r\n} else {\r\ntotal_fifo_size = ovl_fifo_size;\r\n}\r\nif (manual_update && dss_has_feature(FEAT_OMAP3_DSI_FIFO_BUG)) {\r\n*fifo_low = ovl_fifo_size - burst_size * 2;\r\n*fifo_high = total_fifo_size - burst_size;\r\n} else if (plane == OMAP_DSS_WB) {\r\n*fifo_low = 0;\r\n*fifo_high = burst_size;\r\n} else {\r\n*fifo_low = ovl_fifo_size - burst_size;\r\n*fifo_high = total_fifo_size - buf_unit;\r\n}\r\n}\r\nstatic void dispc_ovl_set_fir(enum omap_plane plane,\r\nint hinc, int vinc,\r\nenum omap_color_component color_comp)\r\n{\r\nu32 val;\r\nif (color_comp == DISPC_COLOR_COMPONENT_RGB_Y) {\r\nu8 hinc_start, hinc_end, vinc_start, vinc_end;\r\ndss_feat_get_reg_field(FEAT_REG_FIRHINC,\r\n&hinc_start, &hinc_end);\r\ndss_feat_get_reg_field(FEAT_REG_FIRVINC,\r\n&vinc_start, &vinc_end);\r\nval = FLD_VAL(vinc, vinc_start, vinc_end) |\r\nFLD_VAL(hinc, hinc_start, hinc_end);\r\ndispc_write_reg(DISPC_OVL_FIR(plane), val);\r\n} else {\r\nval = FLD_VAL(vinc, 28, 16) | FLD_VAL(hinc, 12, 0);\r\ndispc_write_reg(DISPC_OVL_FIR2(plane), val);\r\n}\r\n}\r\nstatic void dispc_ovl_set_vid_accu0(enum omap_plane plane, int haccu, int vaccu)\r\n{\r\nu32 val;\r\nu8 hor_start, hor_end, vert_start, vert_end;\r\ndss_feat_get_reg_field(FEAT_REG_HORIZONTALACCU, &hor_start, &hor_end);\r\ndss_feat_get_reg_field(FEAT_REG_VERTICALACCU, &vert_start, &vert_end);\r\nval = FLD_VAL(vaccu, vert_start, vert_end) |\r\nFLD_VAL(haccu, hor_start, hor_end);\r\ndispc_write_reg(DISPC_OVL_ACCU0(plane), val);\r\n}\r\nstatic void dispc_ovl_set_vid_accu1(enum omap_plane plane, int haccu, int vaccu)\r\n{\r\nu32 val;\r\nu8 hor_start, hor_end, vert_start, vert_end;\r\ndss_feat_get_reg_field(FEAT_REG_HORIZONTALACCU, &hor_start, &hor_end);\r\ndss_feat_get_reg_field(FEAT_REG_VERTICALACCU, &vert_start, &vert_end);\r\nval = FLD_VAL(vaccu, vert_start, vert_end) |\r\nFLD_VAL(haccu, hor_start, hor_end);\r\ndispc_write_reg(DISPC_OVL_ACCU1(plane), val);\r\n}\r\nstatic void dispc_ovl_set_vid_accu2_0(enum omap_plane plane, int haccu,\r\nint vaccu)\r\n{\r\nu32 val;\r\nval = FLD_VAL(vaccu, 26, 16) | FLD_VAL(haccu, 10, 0);\r\ndispc_write_reg(DISPC_OVL_ACCU2_0(plane), val);\r\n}\r\nstatic void dispc_ovl_set_vid_accu2_1(enum omap_plane plane, int haccu,\r\nint vaccu)\r\n{\r\nu32 val;\r\nval = FLD_VAL(vaccu, 26, 16) | FLD_VAL(haccu, 10, 0);\r\ndispc_write_reg(DISPC_OVL_ACCU2_1(plane), val);\r\n}\r\nstatic void dispc_ovl_set_scale_param(enum omap_plane plane,\r\nu16 orig_width, u16 orig_height,\r\nu16 out_width, u16 out_height,\r\nbool five_taps, u8 rotation,\r\nenum omap_color_component color_comp)\r\n{\r\nint fir_hinc, fir_vinc;\r\nfir_hinc = 1024 * orig_width / out_width;\r\nfir_vinc = 1024 * orig_height / out_height;\r\ndispc_ovl_set_scale_coef(plane, fir_hinc, fir_vinc, five_taps,\r\ncolor_comp);\r\ndispc_ovl_set_fir(plane, fir_hinc, fir_vinc, color_comp);\r\n}\r\nstatic void dispc_ovl_set_accu_uv(enum omap_plane plane,\r\nu16 orig_width, u16 orig_height, u16 out_width, u16 out_height,\r\nbool ilace, enum omap_color_mode color_mode, u8 rotation)\r\n{\r\nint h_accu2_0, h_accu2_1;\r\nint v_accu2_0, v_accu2_1;\r\nint chroma_hinc, chroma_vinc;\r\nint idx;\r\nstruct accu {\r\ns8 h0_m, h0_n;\r\ns8 h1_m, h1_n;\r\ns8 v0_m, v0_n;\r\ns8 v1_m, v1_n;\r\n};\r\nconst struct accu *accu_table;\r\nconst struct accu *accu_val;\r\nstatic const struct accu accu_nv12[4] = {\r\n{ 0, 1, 0, 1 , -1, 2, 0, 1 },\r\n{ 1, 2, -3, 4 , 0, 1, 0, 1 },\r\n{ -1, 1, 0, 1 , -1, 2, 0, 1 },\r\n{ -1, 2, -1, 2 , -1, 1, 0, 1 },\r\n};\r\nstatic const struct accu accu_nv12_ilace[4] = {\r\n{ 0, 1, 0, 1 , -3, 4, -1, 4 },\r\n{ -1, 4, -3, 4 , 0, 1, 0, 1 },\r\n{ -1, 1, 0, 1 , -1, 4, -3, 4 },\r\n{ -3, 4, -3, 4 , -1, 1, 0, 1 },\r\n};\r\nstatic const struct accu accu_yuv[4] = {\r\n{ 0, 1, 0, 1, 0, 1, 0, 1 },\r\n{ 0, 1, 0, 1, 0, 1, 0, 1 },\r\n{ -1, 1, 0, 1, 0, 1, 0, 1 },\r\n{ 0, 1, 0, 1, -1, 1, 0, 1 },\r\n};\r\nswitch (rotation) {\r\ncase OMAP_DSS_ROT_0:\r\nidx = 0;\r\nbreak;\r\ncase OMAP_DSS_ROT_90:\r\nidx = 1;\r\nbreak;\r\ncase OMAP_DSS_ROT_180:\r\nidx = 2;\r\nbreak;\r\ncase OMAP_DSS_ROT_270:\r\nidx = 3;\r\nbreak;\r\ndefault:\r\nBUG();\r\nreturn;\r\n}\r\nswitch (color_mode) {\r\ncase OMAP_DSS_COLOR_NV12:\r\nif (ilace)\r\naccu_table = accu_nv12_ilace;\r\nelse\r\naccu_table = accu_nv12;\r\nbreak;\r\ncase OMAP_DSS_COLOR_YUV2:\r\ncase OMAP_DSS_COLOR_UYVY:\r\naccu_table = accu_yuv;\r\nbreak;\r\ndefault:\r\nBUG();\r\nreturn;\r\n}\r\naccu_val = &accu_table[idx];\r\nchroma_hinc = 1024 * orig_width / out_width;\r\nchroma_vinc = 1024 * orig_height / out_height;\r\nh_accu2_0 = (accu_val->h0_m * chroma_hinc / accu_val->h0_n) % 1024;\r\nh_accu2_1 = (accu_val->h1_m * chroma_hinc / accu_val->h1_n) % 1024;\r\nv_accu2_0 = (accu_val->v0_m * chroma_vinc / accu_val->v0_n) % 1024;\r\nv_accu2_1 = (accu_val->v1_m * chroma_vinc / accu_val->v1_n) % 1024;\r\ndispc_ovl_set_vid_accu2_0(plane, h_accu2_0, v_accu2_0);\r\ndispc_ovl_set_vid_accu2_1(plane, h_accu2_1, v_accu2_1);\r\n}\r\nstatic void dispc_ovl_set_scaling_common(enum omap_plane plane,\r\nu16 orig_width, u16 orig_height,\r\nu16 out_width, u16 out_height,\r\nbool ilace, bool five_taps,\r\nbool fieldmode, enum omap_color_mode color_mode,\r\nu8 rotation)\r\n{\r\nint accu0 = 0;\r\nint accu1 = 0;\r\nu32 l;\r\ndispc_ovl_set_scale_param(plane, orig_width, orig_height,\r\nout_width, out_height, five_taps,\r\nrotation, DISPC_COLOR_COMPONENT_RGB_Y);\r\nl = dispc_read_reg(DISPC_OVL_ATTRIBUTES(plane));\r\nl &= ~((0x3 << 5) | (0x1 << 21));\r\nl |= (orig_width != out_width) ? (1 << 5) : 0;\r\nl |= (orig_height != out_height) ? (1 << 6) : 0;\r\nl |= five_taps ? (1 << 21) : 0;\r\nif (dss_has_feature(FEAT_RESIZECONF)) {\r\nl &= ~(0x3 << 7);\r\nl |= (orig_width <= out_width) ? 0 : (1 << 7);\r\nl |= (orig_height <= out_height) ? 0 : (1 << 8);\r\n}\r\nif (dss_has_feature(FEAT_LINEBUFFERSPLIT)) {\r\nl &= ~(0x1 << 22);\r\nl |= five_taps ? (1 << 22) : 0;\r\n}\r\ndispc_write_reg(DISPC_OVL_ATTRIBUTES(plane), l);\r\nif (ilace && !fieldmode) {\r\naccu1 = 0;\r\naccu0 = ((1024 * orig_height / out_height) / 2) & 0x3ff;\r\nif (accu0 >= 1024/2) {\r\naccu1 = 1024/2;\r\naccu0 -= accu1;\r\n}\r\n}\r\ndispc_ovl_set_vid_accu0(plane, 0, accu0);\r\ndispc_ovl_set_vid_accu1(plane, 0, accu1);\r\n}\r\nstatic void dispc_ovl_set_scaling_uv(enum omap_plane plane,\r\nu16 orig_width, u16 orig_height,\r\nu16 out_width, u16 out_height,\r\nbool ilace, bool five_taps,\r\nbool fieldmode, enum omap_color_mode color_mode,\r\nu8 rotation)\r\n{\r\nint scale_x = out_width != orig_width;\r\nint scale_y = out_height != orig_height;\r\nbool chroma_upscale = plane != OMAP_DSS_WB ? true : false;\r\nif (!dss_has_feature(FEAT_HANDLE_UV_SEPARATE))\r\nreturn;\r\nif ((color_mode != OMAP_DSS_COLOR_YUV2 &&\r\ncolor_mode != OMAP_DSS_COLOR_UYVY &&\r\ncolor_mode != OMAP_DSS_COLOR_NV12)) {\r\nif (plane != OMAP_DSS_WB)\r\nREG_FLD_MOD(DISPC_OVL_ATTRIBUTES2(plane), 0, 8, 8);\r\nreturn;\r\n}\r\ndispc_ovl_set_accu_uv(plane, orig_width, orig_height, out_width,\r\nout_height, ilace, color_mode, rotation);\r\nswitch (color_mode) {\r\ncase OMAP_DSS_COLOR_NV12:\r\nif (chroma_upscale) {\r\norig_height >>= 1;\r\norig_width >>= 1;\r\n} else {\r\norig_height <<= 1;\r\norig_width <<= 1;\r\n}\r\nbreak;\r\ncase OMAP_DSS_COLOR_YUV2:\r\ncase OMAP_DSS_COLOR_UYVY:\r\nif (rotation == OMAP_DSS_ROT_0 ||\r\nrotation == OMAP_DSS_ROT_180) {\r\nif (chroma_upscale)\r\norig_width >>= 1;\r\nelse\r\norig_width <<= 1;\r\n}\r\nif (rotation != OMAP_DSS_ROT_0)\r\nscale_x = scale_y = true;\r\nbreak;\r\ndefault:\r\nBUG();\r\nreturn;\r\n}\r\nif (out_width != orig_width)\r\nscale_x = true;\r\nif (out_height != orig_height)\r\nscale_y = true;\r\ndispc_ovl_set_scale_param(plane, orig_width, orig_height,\r\nout_width, out_height, five_taps,\r\nrotation, DISPC_COLOR_COMPONENT_UV);\r\nif (plane != OMAP_DSS_WB)\r\nREG_FLD_MOD(DISPC_OVL_ATTRIBUTES2(plane),\r\n(scale_x || scale_y) ? 1 : 0, 8, 8);\r\nREG_FLD_MOD(DISPC_OVL_ATTRIBUTES(plane), scale_x ? 1 : 0, 5, 5);\r\nREG_FLD_MOD(DISPC_OVL_ATTRIBUTES(plane), scale_y ? 1 : 0, 6, 6);\r\n}\r\nstatic void dispc_ovl_set_scaling(enum omap_plane plane,\r\nu16 orig_width, u16 orig_height,\r\nu16 out_width, u16 out_height,\r\nbool ilace, bool five_taps,\r\nbool fieldmode, enum omap_color_mode color_mode,\r\nu8 rotation)\r\n{\r\nBUG_ON(plane == OMAP_DSS_GFX);\r\ndispc_ovl_set_scaling_common(plane,\r\norig_width, orig_height,\r\nout_width, out_height,\r\nilace, five_taps,\r\nfieldmode, color_mode,\r\nrotation);\r\ndispc_ovl_set_scaling_uv(plane,\r\norig_width, orig_height,\r\nout_width, out_height,\r\nilace, five_taps,\r\nfieldmode, color_mode,\r\nrotation);\r\n}\r\nstatic void dispc_ovl_set_rotation_attrs(enum omap_plane plane, u8 rotation,\r\nbool mirroring, enum omap_color_mode color_mode)\r\n{\r\nbool row_repeat = false;\r\nint vidrot = 0;\r\nif (color_mode == OMAP_DSS_COLOR_YUV2 ||\r\ncolor_mode == OMAP_DSS_COLOR_UYVY) {\r\nif (mirroring) {\r\nswitch (rotation) {\r\ncase OMAP_DSS_ROT_0:\r\nvidrot = 2;\r\nbreak;\r\ncase OMAP_DSS_ROT_90:\r\nvidrot = 1;\r\nbreak;\r\ncase OMAP_DSS_ROT_180:\r\nvidrot = 0;\r\nbreak;\r\ncase OMAP_DSS_ROT_270:\r\nvidrot = 3;\r\nbreak;\r\n}\r\n} else {\r\nswitch (rotation) {\r\ncase OMAP_DSS_ROT_0:\r\nvidrot = 0;\r\nbreak;\r\ncase OMAP_DSS_ROT_90:\r\nvidrot = 1;\r\nbreak;\r\ncase OMAP_DSS_ROT_180:\r\nvidrot = 2;\r\nbreak;\r\ncase OMAP_DSS_ROT_270:\r\nvidrot = 3;\r\nbreak;\r\n}\r\n}\r\nif (rotation == OMAP_DSS_ROT_90 || rotation == OMAP_DSS_ROT_270)\r\nrow_repeat = true;\r\nelse\r\nrow_repeat = false;\r\n}\r\nREG_FLD_MOD(DISPC_OVL_ATTRIBUTES(plane), vidrot, 13, 12);\r\nif (dss_has_feature(FEAT_ROWREPEATENABLE))\r\nREG_FLD_MOD(DISPC_OVL_ATTRIBUTES(plane),\r\nrow_repeat ? 1 : 0, 18, 18);\r\n}\r\nstatic int color_mode_to_bpp(enum omap_color_mode color_mode)\r\n{\r\nswitch (color_mode) {\r\ncase OMAP_DSS_COLOR_CLUT1:\r\nreturn 1;\r\ncase OMAP_DSS_COLOR_CLUT2:\r\nreturn 2;\r\ncase OMAP_DSS_COLOR_CLUT4:\r\nreturn 4;\r\ncase OMAP_DSS_COLOR_CLUT8:\r\ncase OMAP_DSS_COLOR_NV12:\r\nreturn 8;\r\ncase OMAP_DSS_COLOR_RGB12U:\r\ncase OMAP_DSS_COLOR_RGB16:\r\ncase OMAP_DSS_COLOR_ARGB16:\r\ncase OMAP_DSS_COLOR_YUV2:\r\ncase OMAP_DSS_COLOR_UYVY:\r\ncase OMAP_DSS_COLOR_RGBA16:\r\ncase OMAP_DSS_COLOR_RGBX16:\r\ncase OMAP_DSS_COLOR_ARGB16_1555:\r\ncase OMAP_DSS_COLOR_XRGB16_1555:\r\nreturn 16;\r\ncase OMAP_DSS_COLOR_RGB24P:\r\nreturn 24;\r\ncase OMAP_DSS_COLOR_RGB24U:\r\ncase OMAP_DSS_COLOR_ARGB32:\r\ncase OMAP_DSS_COLOR_RGBA32:\r\ncase OMAP_DSS_COLOR_RGBX32:\r\nreturn 32;\r\ndefault:\r\nBUG();\r\nreturn 0;\r\n}\r\n}\r\nstatic s32 pixinc(int pixels, u8 ps)\r\n{\r\nif (pixels == 1)\r\nreturn 1;\r\nelse if (pixels > 1)\r\nreturn 1 + (pixels - 1) * ps;\r\nelse if (pixels < 0)\r\nreturn 1 - (-pixels + 1) * ps;\r\nelse\r\nBUG();\r\nreturn 0;\r\n}\r\nstatic void calc_vrfb_rotation_offset(u8 rotation, bool mirror,\r\nu16 screen_width,\r\nu16 width, u16 height,\r\nenum omap_color_mode color_mode, bool fieldmode,\r\nunsigned int field_offset,\r\nunsigned *offset0, unsigned *offset1,\r\ns32 *row_inc, s32 *pix_inc, int x_predecim, int y_predecim)\r\n{\r\nu8 ps;\r\nswitch (color_mode) {\r\ncase OMAP_DSS_COLOR_CLUT1:\r\ncase OMAP_DSS_COLOR_CLUT2:\r\ncase OMAP_DSS_COLOR_CLUT4:\r\ncase OMAP_DSS_COLOR_CLUT8:\r\nBUG();\r\nreturn;\r\ncase OMAP_DSS_COLOR_YUV2:\r\ncase OMAP_DSS_COLOR_UYVY:\r\nps = 4;\r\nbreak;\r\ndefault:\r\nps = color_mode_to_bpp(color_mode) / 8;\r\nbreak;\r\n}\r\nDSSDBG("calc_rot(%d): scrw %d, %dx%d\n", rotation, screen_width,\r\nwidth, height);\r\nswitch (rotation + mirror * 4) {\r\ncase OMAP_DSS_ROT_0:\r\ncase OMAP_DSS_ROT_180:\r\nif (color_mode == OMAP_DSS_COLOR_YUV2 ||\r\ncolor_mode == OMAP_DSS_COLOR_UYVY)\r\nwidth = width >> 1;\r\ncase OMAP_DSS_ROT_90:\r\ncase OMAP_DSS_ROT_270:\r\n*offset1 = 0;\r\nif (field_offset)\r\n*offset0 = field_offset * screen_width * ps;\r\nelse\r\n*offset0 = 0;\r\n*row_inc = pixinc(1 +\r\n(y_predecim * screen_width - x_predecim * width) +\r\n(fieldmode ? screen_width : 0), ps);\r\n*pix_inc = pixinc(x_predecim, ps);\r\nbreak;\r\ncase OMAP_DSS_ROT_0 + 4:\r\ncase OMAP_DSS_ROT_180 + 4:\r\nif (color_mode == OMAP_DSS_COLOR_YUV2 ||\r\ncolor_mode == OMAP_DSS_COLOR_UYVY)\r\nwidth = width >> 1;\r\ncase OMAP_DSS_ROT_90 + 4:\r\ncase OMAP_DSS_ROT_270 + 4:\r\n*offset1 = 0;\r\nif (field_offset)\r\n*offset0 = field_offset * screen_width * ps;\r\nelse\r\n*offset0 = 0;\r\n*row_inc = pixinc(1 -\r\n(y_predecim * screen_width + x_predecim * width) -\r\n(fieldmode ? screen_width : 0), ps);\r\n*pix_inc = pixinc(x_predecim, ps);\r\nbreak;\r\ndefault:\r\nBUG();\r\nreturn;\r\n}\r\n}\r\nstatic void calc_dma_rotation_offset(u8 rotation, bool mirror,\r\nu16 screen_width,\r\nu16 width, u16 height,\r\nenum omap_color_mode color_mode, bool fieldmode,\r\nunsigned int field_offset,\r\nunsigned *offset0, unsigned *offset1,\r\ns32 *row_inc, s32 *pix_inc, int x_predecim, int y_predecim)\r\n{\r\nu8 ps;\r\nu16 fbw, fbh;\r\nswitch (color_mode) {\r\ncase OMAP_DSS_COLOR_CLUT1:\r\ncase OMAP_DSS_COLOR_CLUT2:\r\ncase OMAP_DSS_COLOR_CLUT4:\r\ncase OMAP_DSS_COLOR_CLUT8:\r\nBUG();\r\nreturn;\r\ndefault:\r\nps = color_mode_to_bpp(color_mode) / 8;\r\nbreak;\r\n}\r\nDSSDBG("calc_rot(%d): scrw %d, %dx%d\n", rotation, screen_width,\r\nwidth, height);\r\nif (rotation == OMAP_DSS_ROT_0 || rotation == OMAP_DSS_ROT_180) {\r\nfbw = width;\r\nfbh = height;\r\n} else {\r\nfbw = height;\r\nfbh = width;\r\n}\r\nswitch (rotation + mirror * 4) {\r\ncase OMAP_DSS_ROT_0:\r\n*offset1 = 0;\r\nif (field_offset)\r\n*offset0 = *offset1 + field_offset * screen_width * ps;\r\nelse\r\n*offset0 = *offset1;\r\n*row_inc = pixinc(1 +\r\n(y_predecim * screen_width - fbw * x_predecim) +\r\n(fieldmode ? screen_width : 0), ps);\r\nif (color_mode == OMAP_DSS_COLOR_YUV2 ||\r\ncolor_mode == OMAP_DSS_COLOR_UYVY)\r\n*pix_inc = pixinc(x_predecim, 2 * ps);\r\nelse\r\n*pix_inc = pixinc(x_predecim, ps);\r\nbreak;\r\ncase OMAP_DSS_ROT_90:\r\n*offset1 = screen_width * (fbh - 1) * ps;\r\nif (field_offset)\r\n*offset0 = *offset1 + field_offset * ps;\r\nelse\r\n*offset0 = *offset1;\r\n*row_inc = pixinc(screen_width * (fbh * x_predecim - 1) +\r\ny_predecim + (fieldmode ? 1 : 0), ps);\r\n*pix_inc = pixinc(-x_predecim * screen_width, ps);\r\nbreak;\r\ncase OMAP_DSS_ROT_180:\r\n*offset1 = (screen_width * (fbh - 1) + fbw - 1) * ps;\r\nif (field_offset)\r\n*offset0 = *offset1 - field_offset * screen_width * ps;\r\nelse\r\n*offset0 = *offset1;\r\n*row_inc = pixinc(-1 -\r\n(y_predecim * screen_width - fbw * x_predecim) -\r\n(fieldmode ? screen_width : 0), ps);\r\nif (color_mode == OMAP_DSS_COLOR_YUV2 ||\r\ncolor_mode == OMAP_DSS_COLOR_UYVY)\r\n*pix_inc = pixinc(-x_predecim, 2 * ps);\r\nelse\r\n*pix_inc = pixinc(-x_predecim, ps);\r\nbreak;\r\ncase OMAP_DSS_ROT_270:\r\n*offset1 = (fbw - 1) * ps;\r\nif (field_offset)\r\n*offset0 = *offset1 - field_offset * ps;\r\nelse\r\n*offset0 = *offset1;\r\n*row_inc = pixinc(-screen_width * (fbh * x_predecim - 1) -\r\ny_predecim - (fieldmode ? 1 : 0), ps);\r\n*pix_inc = pixinc(x_predecim * screen_width, ps);\r\nbreak;\r\ncase OMAP_DSS_ROT_0 + 4:\r\n*offset1 = (fbw - 1) * ps;\r\nif (field_offset)\r\n*offset0 = *offset1 + field_offset * screen_width * ps;\r\nelse\r\n*offset0 = *offset1;\r\n*row_inc = pixinc(y_predecim * screen_width * 2 - 1 +\r\n(fieldmode ? screen_width : 0),\r\nps);\r\nif (color_mode == OMAP_DSS_COLOR_YUV2 ||\r\ncolor_mode == OMAP_DSS_COLOR_UYVY)\r\n*pix_inc = pixinc(-x_predecim, 2 * ps);\r\nelse\r\n*pix_inc = pixinc(-x_predecim, ps);\r\nbreak;\r\ncase OMAP_DSS_ROT_90 + 4:\r\n*offset1 = 0;\r\nif (field_offset)\r\n*offset0 = *offset1 + field_offset * ps;\r\nelse\r\n*offset0 = *offset1;\r\n*row_inc = pixinc(-screen_width * (fbh * x_predecim - 1) +\r\ny_predecim + (fieldmode ? 1 : 0),\r\nps);\r\n*pix_inc = pixinc(x_predecim * screen_width, ps);\r\nbreak;\r\ncase OMAP_DSS_ROT_180 + 4:\r\n*offset1 = screen_width * (fbh - 1) * ps;\r\nif (field_offset)\r\n*offset0 = *offset1 - field_offset * screen_width * ps;\r\nelse\r\n*offset0 = *offset1;\r\n*row_inc = pixinc(1 - y_predecim * screen_width * 2 -\r\n(fieldmode ? screen_width : 0),\r\nps);\r\nif (color_mode == OMAP_DSS_COLOR_YUV2 ||\r\ncolor_mode == OMAP_DSS_COLOR_UYVY)\r\n*pix_inc = pixinc(x_predecim, 2 * ps);\r\nelse\r\n*pix_inc = pixinc(x_predecim, ps);\r\nbreak;\r\ncase OMAP_DSS_ROT_270 + 4:\r\n*offset1 = (screen_width * (fbh - 1) + fbw - 1) * ps;\r\nif (field_offset)\r\n*offset0 = *offset1 - field_offset * ps;\r\nelse\r\n*offset0 = *offset1;\r\n*row_inc = pixinc(screen_width * (fbh * x_predecim - 1) -\r\ny_predecim - (fieldmode ? 1 : 0),\r\nps);\r\n*pix_inc = pixinc(-x_predecim * screen_width, ps);\r\nbreak;\r\ndefault:\r\nBUG();\r\nreturn;\r\n}\r\n}\r\nstatic void calc_tiler_rotation_offset(u16 screen_width, u16 width,\r\nenum omap_color_mode color_mode, bool fieldmode,\r\nunsigned int field_offset, unsigned *offset0, unsigned *offset1,\r\ns32 *row_inc, s32 *pix_inc, int x_predecim, int y_predecim)\r\n{\r\nu8 ps;\r\nswitch (color_mode) {\r\ncase OMAP_DSS_COLOR_CLUT1:\r\ncase OMAP_DSS_COLOR_CLUT2:\r\ncase OMAP_DSS_COLOR_CLUT4:\r\ncase OMAP_DSS_COLOR_CLUT8:\r\nBUG();\r\nreturn;\r\ndefault:\r\nps = color_mode_to_bpp(color_mode) / 8;\r\nbreak;\r\n}\r\nDSSDBG("scrw %d, width %d\n", screen_width, width);\r\n*offset1 = 0;\r\nif (field_offset)\r\n*offset0 = *offset1 + field_offset * screen_width * ps;\r\nelse\r\n*offset0 = *offset1;\r\n*row_inc = pixinc(1 + (y_predecim * screen_width - width * x_predecim) +\r\n(fieldmode ? screen_width : 0), ps);\r\nif (color_mode == OMAP_DSS_COLOR_YUV2 ||\r\ncolor_mode == OMAP_DSS_COLOR_UYVY)\r\n*pix_inc = pixinc(x_predecim, 2 * ps);\r\nelse\r\n*pix_inc = pixinc(x_predecim, ps);\r\n}\r\nstatic int check_horiz_timing_omap3(unsigned long pclk, unsigned long lclk,\r\nconst struct omap_video_timings *t, u16 pos_x,\r\nu16 width, u16 height, u16 out_width, u16 out_height)\r\n{\r\nconst int ds = DIV_ROUND_UP(height, out_height);\r\nunsigned long nonactive;\r\nstatic const u8 limits[3] = { 8, 10, 20 };\r\nu64 val, blank;\r\nint i;\r\nnonactive = t->x_res + t->hfp + t->hsw + t->hbp - out_width;\r\ni = 0;\r\nif (out_height < height)\r\ni++;\r\nif (out_width < width)\r\ni++;\r\nblank = div_u64((u64)(t->hbp + t->hsw + t->hfp) * lclk, pclk);\r\nDSSDBG("blanking period + ppl = %llu (limit = %u)\n", blank, limits[i]);\r\nif (blank <= limits[i])\r\nreturn -EINVAL;\r\nval = div_u64((u64)(nonactive - pos_x) * lclk, pclk);\r\nDSSDBG("(nonactive - pos_x) * pcd = %llu max(0, DS - 2) * width = %d\n",\r\nval, max(0, ds - 2) * width);\r\nif (val < max(0, ds - 2) * width)\r\nreturn -EINVAL;\r\nval = div_u64((u64)nonactive * lclk, pclk);\r\nDSSDBG("nonactive * pcd = %llu, max(0, DS - 1) * width = %d\n",\r\nval, max(0, ds - 1) * width);\r\nif (val < max(0, ds - 1) * width)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic unsigned long calc_core_clk_five_taps(unsigned long pclk,\r\nconst struct omap_video_timings *mgr_timings, u16 width,\r\nu16 height, u16 out_width, u16 out_height,\r\nenum omap_color_mode color_mode)\r\n{\r\nu32 core_clk = 0;\r\nu64 tmp;\r\nif (height <= out_height && width <= out_width)\r\nreturn (unsigned long) pclk;\r\nif (height > out_height) {\r\nunsigned int ppl = mgr_timings->x_res;\r\ntmp = pclk * height * out_width;\r\ndo_div(tmp, 2 * out_height * ppl);\r\ncore_clk = tmp;\r\nif (height > 2 * out_height) {\r\nif (ppl == out_width)\r\nreturn 0;\r\ntmp = pclk * (height - 2 * out_height) * out_width;\r\ndo_div(tmp, 2 * out_height * (ppl - out_width));\r\ncore_clk = max_t(u32, core_clk, tmp);\r\n}\r\n}\r\nif (width > out_width) {\r\ntmp = pclk * width;\r\ndo_div(tmp, out_width);\r\ncore_clk = max_t(u32, core_clk, tmp);\r\nif (color_mode == OMAP_DSS_COLOR_RGB24U)\r\ncore_clk <<= 1;\r\n}\r\nreturn core_clk;\r\n}\r\nstatic unsigned long calc_core_clk_24xx(unsigned long pclk, u16 width,\r\nu16 height, u16 out_width, u16 out_height, bool mem_to_mem)\r\n{\r\nif (height > out_height && width > out_width)\r\nreturn pclk * 4;\r\nelse\r\nreturn pclk * 2;\r\n}\r\nstatic unsigned long calc_core_clk_34xx(unsigned long pclk, u16 width,\r\nu16 height, u16 out_width, u16 out_height, bool mem_to_mem)\r\n{\r\nunsigned int hf, vf;\r\nif (width > 3 * out_width)\r\nhf = 4;\r\nelse if (width > 2 * out_width)\r\nhf = 3;\r\nelse if (width > out_width)\r\nhf = 2;\r\nelse\r\nhf = 1;\r\nif (height > out_height)\r\nvf = 2;\r\nelse\r\nvf = 1;\r\nreturn pclk * vf * hf;\r\n}\r\nstatic unsigned long calc_core_clk_44xx(unsigned long pclk, u16 width,\r\nu16 height, u16 out_width, u16 out_height, bool mem_to_mem)\r\n{\r\nif (mem_to_mem)\r\nreturn 1;\r\nif (width > out_width)\r\nreturn DIV_ROUND_UP(pclk, out_width) * width;\r\nelse\r\nreturn pclk;\r\n}\r\nstatic int dispc_ovl_calc_scaling_24xx(unsigned long pclk, unsigned long lclk,\r\nconst struct omap_video_timings *mgr_timings,\r\nu16 width, u16 height, u16 out_width, u16 out_height,\r\nenum omap_color_mode color_mode, bool *five_taps,\r\nint *x_predecim, int *y_predecim, int *decim_x, int *decim_y,\r\nu16 pos_x, unsigned long *core_clk, bool mem_to_mem)\r\n{\r\nint error;\r\nu16 in_width, in_height;\r\nint min_factor = min(*decim_x, *decim_y);\r\nconst int maxsinglelinewidth =\r\ndss_feat_get_param_max(FEAT_PARAM_LINEWIDTH);\r\n*five_taps = false;\r\ndo {\r\nin_height = DIV_ROUND_UP(height, *decim_y);\r\nin_width = DIV_ROUND_UP(width, *decim_x);\r\n*core_clk = dispc.feat->calc_core_clk(pclk, in_width,\r\nin_height, out_width, out_height, mem_to_mem);\r\nerror = (in_width > maxsinglelinewidth || !*core_clk ||\r\n*core_clk > dispc_core_clk_rate());\r\nif (error) {\r\nif (*decim_x == *decim_y) {\r\n*decim_x = min_factor;\r\n++*decim_y;\r\n} else {\r\nswap(*decim_x, *decim_y);\r\nif (*decim_x < *decim_y)\r\n++*decim_x;\r\n}\r\n}\r\n} while (*decim_x <= *x_predecim && *decim_y <= *y_predecim && error);\r\nif (in_width > maxsinglelinewidth) {\r\nDSSERR("Cannot scale max input width exceeded");\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int dispc_ovl_calc_scaling_34xx(unsigned long pclk, unsigned long lclk,\r\nconst struct omap_video_timings *mgr_timings,\r\nu16 width, u16 height, u16 out_width, u16 out_height,\r\nenum omap_color_mode color_mode, bool *five_taps,\r\nint *x_predecim, int *y_predecim, int *decim_x, int *decim_y,\r\nu16 pos_x, unsigned long *core_clk, bool mem_to_mem)\r\n{\r\nint error;\r\nu16 in_width, in_height;\r\nint min_factor = min(*decim_x, *decim_y);\r\nconst int maxsinglelinewidth =\r\ndss_feat_get_param_max(FEAT_PARAM_LINEWIDTH);\r\ndo {\r\nin_height = DIV_ROUND_UP(height, *decim_y);\r\nin_width = DIV_ROUND_UP(width, *decim_x);\r\n*core_clk = calc_core_clk_five_taps(pclk, mgr_timings,\r\nin_width, in_height, out_width, out_height, color_mode);\r\nerror = check_horiz_timing_omap3(pclk, lclk, mgr_timings,\r\npos_x, in_width, in_height, out_width,\r\nout_height);\r\nif (in_width > maxsinglelinewidth)\r\nif (in_height > out_height &&\r\nin_height < out_height * 2)\r\n*five_taps = false;\r\nif (!*five_taps)\r\n*core_clk = dispc.feat->calc_core_clk(pclk, in_width,\r\nin_height, out_width, out_height,\r\nmem_to_mem);\r\nerror = (error || in_width > maxsinglelinewidth * 2 ||\r\n(in_width > maxsinglelinewidth && *five_taps) ||\r\n!*core_clk || *core_clk > dispc_core_clk_rate());\r\nif (error) {\r\nif (*decim_x == *decim_y) {\r\n*decim_x = min_factor;\r\n++*decim_y;\r\n} else {\r\nswap(*decim_x, *decim_y);\r\nif (*decim_x < *decim_y)\r\n++*decim_x;\r\n}\r\n}\r\n} while (*decim_x <= *x_predecim && *decim_y <= *y_predecim && error);\r\nif (check_horiz_timing_omap3(pclk, lclk, mgr_timings, pos_x, width,\r\nheight, out_width, out_height)){\r\nDSSERR("horizontal timing too tight\n");\r\nreturn -EINVAL;\r\n}\r\nif (in_width > (maxsinglelinewidth * 2)) {\r\nDSSERR("Cannot setup scaling");\r\nDSSERR("width exceeds maximum width possible");\r\nreturn -EINVAL;\r\n}\r\nif (in_width > maxsinglelinewidth && *five_taps) {\r\nDSSERR("cannot setup scaling with five taps");\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int dispc_ovl_calc_scaling_44xx(unsigned long pclk, unsigned long lclk,\r\nconst struct omap_video_timings *mgr_timings,\r\nu16 width, u16 height, u16 out_width, u16 out_height,\r\nenum omap_color_mode color_mode, bool *five_taps,\r\nint *x_predecim, int *y_predecim, int *decim_x, int *decim_y,\r\nu16 pos_x, unsigned long *core_clk, bool mem_to_mem)\r\n{\r\nu16 in_width, in_width_max;\r\nint decim_x_min = *decim_x;\r\nu16 in_height = DIV_ROUND_UP(height, *decim_y);\r\nconst int maxsinglelinewidth =\r\ndss_feat_get_param_max(FEAT_PARAM_LINEWIDTH);\r\nconst int maxdownscale = dss_feat_get_param_max(FEAT_PARAM_DOWNSCALE);\r\nif (mem_to_mem) {\r\nin_width_max = out_width * maxdownscale;\r\n} else {\r\nin_width_max = dispc_core_clk_rate() /\r\nDIV_ROUND_UP(pclk, out_width);\r\n}\r\n*decim_x = DIV_ROUND_UP(width, in_width_max);\r\n*decim_x = *decim_x > decim_x_min ? *decim_x : decim_x_min;\r\nif (*decim_x > *x_predecim)\r\nreturn -EINVAL;\r\ndo {\r\nin_width = DIV_ROUND_UP(width, *decim_x);\r\n} while (*decim_x <= *x_predecim &&\r\nin_width > maxsinglelinewidth && ++*decim_x);\r\nif (in_width > maxsinglelinewidth) {\r\nDSSERR("Cannot scale width exceeds max line width");\r\nreturn -EINVAL;\r\n}\r\n*core_clk = dispc.feat->calc_core_clk(pclk, in_width, in_height,\r\nout_width, out_height, mem_to_mem);\r\nreturn 0;\r\n}\r\nstatic int dispc_ovl_calc_scaling(unsigned long pclk, unsigned long lclk,\r\nenum omap_overlay_caps caps,\r\nconst struct omap_video_timings *mgr_timings,\r\nu16 width, u16 height, u16 out_width, u16 out_height,\r\nenum omap_color_mode color_mode, bool *five_taps,\r\nint *x_predecim, int *y_predecim, u16 pos_x,\r\nenum omap_dss_rotation_type rotation_type, bool mem_to_mem)\r\n{\r\nconst int maxdownscale = dss_feat_get_param_max(FEAT_PARAM_DOWNSCALE);\r\nconst int max_decim_limit = 16;\r\nunsigned long core_clk = 0;\r\nint decim_x, decim_y, ret;\r\nif (width == out_width && height == out_height)\r\nreturn 0;\r\nif ((caps & OMAP_DSS_OVL_CAP_SCALE) == 0)\r\nreturn -EINVAL;\r\nif (mem_to_mem) {\r\n*x_predecim = *y_predecim = 1;\r\n} else {\r\n*x_predecim = max_decim_limit;\r\n*y_predecim = (rotation_type == OMAP_DSS_ROT_TILER &&\r\ndss_has_feature(FEAT_BURST_2D)) ?\r\n2 : max_decim_limit;\r\n}\r\nif (color_mode == OMAP_DSS_COLOR_CLUT1 ||\r\ncolor_mode == OMAP_DSS_COLOR_CLUT2 ||\r\ncolor_mode == OMAP_DSS_COLOR_CLUT4 ||\r\ncolor_mode == OMAP_DSS_COLOR_CLUT8) {\r\n*x_predecim = 1;\r\n*y_predecim = 1;\r\n*five_taps = false;\r\nreturn 0;\r\n}\r\ndecim_x = DIV_ROUND_UP(DIV_ROUND_UP(width, out_width), maxdownscale);\r\ndecim_y = DIV_ROUND_UP(DIV_ROUND_UP(height, out_height), maxdownscale);\r\nif (decim_x > *x_predecim || out_width > width * 8)\r\nreturn -EINVAL;\r\nif (decim_y > *y_predecim || out_height > height * 8)\r\nreturn -EINVAL;\r\nret = dispc.feat->calc_scaling(pclk, lclk, mgr_timings, width, height,\r\nout_width, out_height, color_mode, five_taps,\r\nx_predecim, y_predecim, &decim_x, &decim_y, pos_x, &core_clk,\r\nmem_to_mem);\r\nif (ret)\r\nreturn ret;\r\nDSSDBG("required core clk rate = %lu Hz\n", core_clk);\r\nDSSDBG("current core clk rate = %lu Hz\n", dispc_core_clk_rate());\r\nif (!core_clk || core_clk > dispc_core_clk_rate()) {\r\nDSSERR("failed to set up scaling, "\r\n"required core clk rate = %lu Hz, "\r\n"current core clk rate = %lu Hz\n",\r\ncore_clk, dispc_core_clk_rate());\r\nreturn -EINVAL;\r\n}\r\n*x_predecim = decim_x;\r\n*y_predecim = decim_y;\r\nreturn 0;\r\n}\r\nint dispc_ovl_check(enum omap_plane plane, enum omap_channel channel,\r\nconst struct omap_overlay_info *oi,\r\nconst struct omap_video_timings *timings,\r\nint *x_predecim, int *y_predecim)\r\n{\r\nenum omap_overlay_caps caps = dss_feat_get_overlay_caps(plane);\r\nbool five_taps = true;\r\nbool fieldmode = 0;\r\nu16 in_height = oi->height;\r\nu16 in_width = oi->width;\r\nbool ilace = timings->interlace;\r\nu16 out_width, out_height;\r\nint pos_x = oi->pos_x;\r\nunsigned long pclk = dispc_mgr_pclk_rate(channel);\r\nunsigned long lclk = dispc_mgr_lclk_rate(channel);\r\nout_width = oi->out_width == 0 ? oi->width : oi->out_width;\r\nout_height = oi->out_height == 0 ? oi->height : oi->out_height;\r\nif (ilace && oi->height == out_height)\r\nfieldmode = 1;\r\nif (ilace) {\r\nif (fieldmode)\r\nin_height /= 2;\r\nout_height /= 2;\r\nDSSDBG("adjusting for ilace: height %d, out_height %d\n",\r\nin_height, out_height);\r\n}\r\nif (!dss_feat_color_mode_supported(plane, oi->color_mode))\r\nreturn -EINVAL;\r\nreturn dispc_ovl_calc_scaling(pclk, lclk, caps, timings, in_width,\r\nin_height, out_width, out_height, oi->color_mode,\r\n&five_taps, x_predecim, y_predecim, pos_x,\r\noi->rotation_type, false);\r\n}\r\nstatic int dispc_ovl_setup_common(enum omap_plane plane,\r\nenum omap_overlay_caps caps, u32 paddr, u32 p_uv_addr,\r\nu16 screen_width, int pos_x, int pos_y, u16 width, u16 height,\r\nu16 out_width, u16 out_height, enum omap_color_mode color_mode,\r\nu8 rotation, bool mirror, u8 zorder, u8 pre_mult_alpha,\r\nu8 global_alpha, enum omap_dss_rotation_type rotation_type,\r\nbool replication, const struct omap_video_timings *mgr_timings,\r\nbool mem_to_mem)\r\n{\r\nbool five_taps = true;\r\nbool fieldmode = 0;\r\nint r, cconv = 0;\r\nunsigned offset0, offset1;\r\ns32 row_inc;\r\ns32 pix_inc;\r\nu16 frame_width, frame_height;\r\nunsigned int field_offset = 0;\r\nu16 in_height = height;\r\nu16 in_width = width;\r\nint x_predecim = 1, y_predecim = 1;\r\nbool ilace = mgr_timings->interlace;\r\nunsigned long pclk = dispc_plane_pclk_rate(plane);\r\nunsigned long lclk = dispc_plane_lclk_rate(plane);\r\nif (paddr == 0)\r\nreturn -EINVAL;\r\nout_width = out_width == 0 ? width : out_width;\r\nout_height = out_height == 0 ? height : out_height;\r\nif (ilace && height == out_height)\r\nfieldmode = 1;\r\nif (ilace) {\r\nif (fieldmode)\r\nin_height /= 2;\r\npos_y /= 2;\r\nout_height /= 2;\r\nDSSDBG("adjusting for ilace: height %d, pos_y %d, "\r\n"out_height %d\n", in_height, pos_y,\r\nout_height);\r\n}\r\nif (!dss_feat_color_mode_supported(plane, color_mode))\r\nreturn -EINVAL;\r\nr = dispc_ovl_calc_scaling(pclk, lclk, caps, mgr_timings, in_width,\r\nin_height, out_width, out_height, color_mode,\r\n&five_taps, &x_predecim, &y_predecim, pos_x,\r\nrotation_type, mem_to_mem);\r\nif (r)\r\nreturn r;\r\nin_width = DIV_ROUND_UP(in_width, x_predecim);\r\nin_height = DIV_ROUND_UP(in_height, y_predecim);\r\nif (color_mode == OMAP_DSS_COLOR_YUV2 ||\r\ncolor_mode == OMAP_DSS_COLOR_UYVY ||\r\ncolor_mode == OMAP_DSS_COLOR_NV12)\r\ncconv = 1;\r\nif (ilace && !fieldmode) {\r\nif (!in_height || in_height == out_height)\r\nfield_offset = 0;\r\nelse\r\nfield_offset = in_height / out_height / 2;\r\n}\r\nif (fieldmode)\r\nfield_offset = 1;\r\noffset0 = 0;\r\noffset1 = 0;\r\nrow_inc = 0;\r\npix_inc = 0;\r\nif (plane == OMAP_DSS_WB) {\r\nframe_width = out_width;\r\nframe_height = out_height;\r\n} else {\r\nframe_width = in_width;\r\nframe_height = height;\r\n}\r\nif (rotation_type == OMAP_DSS_ROT_TILER)\r\ncalc_tiler_rotation_offset(screen_width, frame_width,\r\ncolor_mode, fieldmode, field_offset,\r\n&offset0, &offset1, &row_inc, &pix_inc,\r\nx_predecim, y_predecim);\r\nelse if (rotation_type == OMAP_DSS_ROT_DMA)\r\ncalc_dma_rotation_offset(rotation, mirror, screen_width,\r\nframe_width, frame_height,\r\ncolor_mode, fieldmode, field_offset,\r\n&offset0, &offset1, &row_inc, &pix_inc,\r\nx_predecim, y_predecim);\r\nelse\r\ncalc_vrfb_rotation_offset(rotation, mirror,\r\nscreen_width, frame_width, frame_height,\r\ncolor_mode, fieldmode, field_offset,\r\n&offset0, &offset1, &row_inc, &pix_inc,\r\nx_predecim, y_predecim);\r\nDSSDBG("offset0 %u, offset1 %u, row_inc %d, pix_inc %d\n",\r\noffset0, offset1, row_inc, pix_inc);\r\ndispc_ovl_set_color_mode(plane, color_mode);\r\ndispc_ovl_configure_burst_type(plane, rotation_type);\r\ndispc_ovl_set_ba0(plane, paddr + offset0);\r\ndispc_ovl_set_ba1(plane, paddr + offset1);\r\nif (OMAP_DSS_COLOR_NV12 == color_mode) {\r\ndispc_ovl_set_ba0_uv(plane, p_uv_addr + offset0);\r\ndispc_ovl_set_ba1_uv(plane, p_uv_addr + offset1);\r\n}\r\ndispc_ovl_set_row_inc(plane, row_inc);\r\ndispc_ovl_set_pix_inc(plane, pix_inc);\r\nDSSDBG("%d,%d %dx%d -> %dx%d\n", pos_x, pos_y, in_width,\r\nin_height, out_width, out_height);\r\ndispc_ovl_set_pos(plane, caps, pos_x, pos_y);\r\ndispc_ovl_set_input_size(plane, in_width, in_height);\r\nif (caps & OMAP_DSS_OVL_CAP_SCALE) {\r\ndispc_ovl_set_scaling(plane, in_width, in_height, out_width,\r\nout_height, ilace, five_taps, fieldmode,\r\ncolor_mode, rotation);\r\ndispc_ovl_set_output_size(plane, out_width, out_height);\r\ndispc_ovl_set_vid_color_conv(plane, cconv);\r\n}\r\ndispc_ovl_set_rotation_attrs(plane, rotation, mirror, color_mode);\r\ndispc_ovl_set_zorder(plane, caps, zorder);\r\ndispc_ovl_set_pre_mult_alpha(plane, caps, pre_mult_alpha);\r\ndispc_ovl_setup_global_alpha(plane, caps, global_alpha);\r\ndispc_ovl_enable_replication(plane, caps, replication);\r\nreturn 0;\r\n}\r\nint dispc_ovl_setup(enum omap_plane plane, const struct omap_overlay_info *oi,\r\nbool replication, const struct omap_video_timings *mgr_timings,\r\nbool mem_to_mem)\r\n{\r\nint r;\r\nenum omap_overlay_caps caps = dss_feat_get_overlay_caps(plane);\r\nenum omap_channel channel;\r\nchannel = dispc_ovl_get_channel_out(plane);\r\nDSSDBG("dispc_ovl_setup %d, pa %x, pa_uv %x, sw %d, %d,%d, %dx%d -> "\r\n"%dx%d, cmode %x, rot %d, mir %d, chan %d repl %d\n",\r\nplane, oi->paddr, oi->p_uv_addr, oi->screen_width, oi->pos_x,\r\noi->pos_y, oi->width, oi->height, oi->out_width, oi->out_height,\r\noi->color_mode, oi->rotation, oi->mirror, channel, replication);\r\nr = dispc_ovl_setup_common(plane, caps, oi->paddr, oi->p_uv_addr,\r\noi->screen_width, oi->pos_x, oi->pos_y, oi->width, oi->height,\r\noi->out_width, oi->out_height, oi->color_mode, oi->rotation,\r\noi->mirror, oi->zorder, oi->pre_mult_alpha, oi->global_alpha,\r\noi->rotation_type, replication, mgr_timings, mem_to_mem);\r\nreturn r;\r\n}\r\nint dispc_wb_setup(const struct omap_dss_writeback_info *wi,\r\nbool mem_to_mem, const struct omap_video_timings *mgr_timings)\r\n{\r\nint r;\r\nu32 l;\r\nenum omap_plane plane = OMAP_DSS_WB;\r\nconst int pos_x = 0, pos_y = 0;\r\nconst u8 zorder = 0, global_alpha = 0;\r\nconst bool replication = false;\r\nbool truncation;\r\nint in_width = mgr_timings->x_res;\r\nint in_height = mgr_timings->y_res;\r\nenum omap_overlay_caps caps =\r\nOMAP_DSS_OVL_CAP_SCALE | OMAP_DSS_OVL_CAP_PRE_MULT_ALPHA;\r\nDSSDBG("dispc_wb_setup, pa %x, pa_uv %x, %d,%d -> %dx%d, cmode %x, "\r\n"rot %d, mir %d\n", wi->paddr, wi->p_uv_addr, in_width,\r\nin_height, wi->width, wi->height, wi->color_mode, wi->rotation,\r\nwi->mirror);\r\nr = dispc_ovl_setup_common(plane, caps, wi->paddr, wi->p_uv_addr,\r\nwi->buf_width, pos_x, pos_y, in_width, in_height, wi->width,\r\nwi->height, wi->color_mode, wi->rotation, wi->mirror, zorder,\r\nwi->pre_mult_alpha, global_alpha, wi->rotation_type,\r\nreplication, mgr_timings, mem_to_mem);\r\nswitch (wi->color_mode) {\r\ncase OMAP_DSS_COLOR_RGB16:\r\ncase OMAP_DSS_COLOR_RGB24P:\r\ncase OMAP_DSS_COLOR_ARGB16:\r\ncase OMAP_DSS_COLOR_RGBA16:\r\ncase OMAP_DSS_COLOR_RGB12U:\r\ncase OMAP_DSS_COLOR_ARGB16_1555:\r\ncase OMAP_DSS_COLOR_XRGB16_1555:\r\ncase OMAP_DSS_COLOR_RGBX16:\r\ntruncation = true;\r\nbreak;\r\ndefault:\r\ntruncation = false;\r\nbreak;\r\n}\r\nl = dispc_read_reg(DISPC_OVL_ATTRIBUTES(plane));\r\nl = FLD_MOD(l, truncation, 10, 10);\r\nl = FLD_MOD(l, mem_to_mem, 19, 19);\r\ndispc_write_reg(DISPC_OVL_ATTRIBUTES(plane), l);\r\nreturn r;\r\n}\r\nint dispc_ovl_enable(enum omap_plane plane, bool enable)\r\n{\r\nDSSDBG("dispc_enable_plane %d, %d\n", plane, enable);\r\nREG_FLD_MOD(DISPC_OVL_ATTRIBUTES(plane), enable ? 1 : 0, 0, 0);\r\nreturn 0;\r\n}\r\nbool dispc_ovl_enabled(enum omap_plane plane)\r\n{\r\nreturn REG_GET(DISPC_OVL_ATTRIBUTES(plane), 0, 0);\r\n}\r\nvoid dispc_mgr_enable(enum omap_channel channel, bool enable)\r\n{\r\nmgr_fld_write(channel, DISPC_MGR_FLD_ENABLE, enable);\r\nmgr_fld_read(channel, DISPC_MGR_FLD_ENABLE);\r\n}\r\nbool dispc_mgr_is_enabled(enum omap_channel channel)\r\n{\r\nreturn !!mgr_fld_read(channel, DISPC_MGR_FLD_ENABLE);\r\n}\r\nvoid dispc_wb_enable(bool enable)\r\n{\r\ndispc_ovl_enable(OMAP_DSS_WB, enable);\r\n}\r\nbool dispc_wb_is_enabled(void)\r\n{\r\nreturn dispc_ovl_enabled(OMAP_DSS_WB);\r\n}\r\nstatic void dispc_lcd_enable_signal_polarity(bool act_high)\r\n{\r\nif (!dss_has_feature(FEAT_LCDENABLEPOL))\r\nreturn;\r\nREG_FLD_MOD(DISPC_CONTROL, act_high ? 1 : 0, 29, 29);\r\n}\r\nvoid dispc_lcd_enable_signal(bool enable)\r\n{\r\nif (!dss_has_feature(FEAT_LCDENABLESIGNAL))\r\nreturn;\r\nREG_FLD_MOD(DISPC_CONTROL, enable ? 1 : 0, 28, 28);\r\n}\r\nvoid dispc_pck_free_enable(bool enable)\r\n{\r\nif (!dss_has_feature(FEAT_PCKFREEENABLE))\r\nreturn;\r\nREG_FLD_MOD(DISPC_CONTROL, enable ? 1 : 0, 27, 27);\r\n}\r\nstatic void dispc_mgr_enable_fifohandcheck(enum omap_channel channel, bool enable)\r\n{\r\nmgr_fld_write(channel, DISPC_MGR_FLD_FIFOHANDCHECK, enable);\r\n}\r\nstatic void dispc_mgr_set_lcd_type_tft(enum omap_channel channel)\r\n{\r\nmgr_fld_write(channel, DISPC_MGR_FLD_STNTFT, 1);\r\n}\r\nvoid dispc_set_loadmode(enum omap_dss_load_mode mode)\r\n{\r\nREG_FLD_MOD(DISPC_CONFIG, mode, 2, 1);\r\n}\r\nstatic void dispc_mgr_set_default_color(enum omap_channel channel, u32 color)\r\n{\r\ndispc_write_reg(DISPC_DEFAULT_COLOR(channel), color);\r\n}\r\nstatic void dispc_mgr_set_trans_key(enum omap_channel ch,\r\nenum omap_dss_trans_key_type type,\r\nu32 trans_key)\r\n{\r\nmgr_fld_write(ch, DISPC_MGR_FLD_TCKSELECTION, type);\r\ndispc_write_reg(DISPC_TRANS_COLOR(ch), trans_key);\r\n}\r\nstatic void dispc_mgr_enable_trans_key(enum omap_channel ch, bool enable)\r\n{\r\nmgr_fld_write(ch, DISPC_MGR_FLD_TCKENABLE, enable);\r\n}\r\nstatic void dispc_mgr_enable_alpha_fixed_zorder(enum omap_channel ch,\r\nbool enable)\r\n{\r\nif (!dss_has_feature(FEAT_ALPHA_FIXED_ZORDER))\r\nreturn;\r\nif (ch == OMAP_DSS_CHANNEL_LCD)\r\nREG_FLD_MOD(DISPC_CONFIG, enable, 18, 18);\r\nelse if (ch == OMAP_DSS_CHANNEL_DIGIT)\r\nREG_FLD_MOD(DISPC_CONFIG, enable, 19, 19);\r\n}\r\nvoid dispc_mgr_setup(enum omap_channel channel,\r\nconst struct omap_overlay_manager_info *info)\r\n{\r\ndispc_mgr_set_default_color(channel, info->default_color);\r\ndispc_mgr_set_trans_key(channel, info->trans_key_type, info->trans_key);\r\ndispc_mgr_enable_trans_key(channel, info->trans_enabled);\r\ndispc_mgr_enable_alpha_fixed_zorder(channel,\r\ninfo->partial_alpha_enabled);\r\nif (dss_has_feature(FEAT_CPR)) {\r\ndispc_mgr_enable_cpr(channel, info->cpr_enable);\r\ndispc_mgr_set_cpr_coef(channel, &info->cpr_coefs);\r\n}\r\n}\r\nstatic void dispc_mgr_set_tft_data_lines(enum omap_channel channel, u8 data_lines)\r\n{\r\nint code;\r\nswitch (data_lines) {\r\ncase 12:\r\ncode = 0;\r\nbreak;\r\ncase 16:\r\ncode = 1;\r\nbreak;\r\ncase 18:\r\ncode = 2;\r\nbreak;\r\ncase 24:\r\ncode = 3;\r\nbreak;\r\ndefault:\r\nBUG();\r\nreturn;\r\n}\r\nmgr_fld_write(channel, DISPC_MGR_FLD_TFTDATALINES, code);\r\n}\r\nstatic void dispc_mgr_set_io_pad_mode(enum dss_io_pad_mode mode)\r\n{\r\nu32 l;\r\nint gpout0, gpout1;\r\nswitch (mode) {\r\ncase DSS_IO_PAD_MODE_RESET:\r\ngpout0 = 0;\r\ngpout1 = 0;\r\nbreak;\r\ncase DSS_IO_PAD_MODE_RFBI:\r\ngpout0 = 1;\r\ngpout1 = 0;\r\nbreak;\r\ncase DSS_IO_PAD_MODE_BYPASS:\r\ngpout0 = 1;\r\ngpout1 = 1;\r\nbreak;\r\ndefault:\r\nBUG();\r\nreturn;\r\n}\r\nl = dispc_read_reg(DISPC_CONTROL);\r\nl = FLD_MOD(l, gpout0, 15, 15);\r\nl = FLD_MOD(l, gpout1, 16, 16);\r\ndispc_write_reg(DISPC_CONTROL, l);\r\n}\r\nstatic void dispc_mgr_enable_stallmode(enum omap_channel channel, bool enable)\r\n{\r\nmgr_fld_write(channel, DISPC_MGR_FLD_STALLMODE, enable);\r\n}\r\nvoid dispc_mgr_set_lcd_config(enum omap_channel channel,\r\nconst struct dss_lcd_mgr_config *config)\r\n{\r\ndispc_mgr_set_io_pad_mode(config->io_pad_mode);\r\ndispc_mgr_enable_stallmode(channel, config->stallmode);\r\ndispc_mgr_enable_fifohandcheck(channel, config->fifohandcheck);\r\ndispc_mgr_set_clock_div(channel, &config->clock_info);\r\ndispc_mgr_set_tft_data_lines(channel, config->video_port_width);\r\ndispc_lcd_enable_signal_polarity(config->lcden_sig_polarity);\r\ndispc_mgr_set_lcd_type_tft(channel);\r\n}\r\nstatic bool _dispc_mgr_size_ok(u16 width, u16 height)\r\n{\r\nreturn width <= dispc.feat->mgr_width_max &&\r\nheight <= dispc.feat->mgr_height_max;\r\n}\r\nstatic bool _dispc_lcd_timings_ok(int hsw, int hfp, int hbp,\r\nint vsw, int vfp, int vbp)\r\n{\r\nif (hsw < 1 || hsw > dispc.feat->sw_max ||\r\nhfp < 1 || hfp > dispc.feat->hp_max ||\r\nhbp < 1 || hbp > dispc.feat->hp_max ||\r\nvsw < 1 || vsw > dispc.feat->sw_max ||\r\nvfp < 0 || vfp > dispc.feat->vp_max ||\r\nvbp < 0 || vbp > dispc.feat->vp_max)\r\nreturn false;\r\nreturn true;\r\n}\r\nbool dispc_mgr_timings_ok(enum omap_channel channel,\r\nconst struct omap_video_timings *timings)\r\n{\r\nbool timings_ok;\r\ntimings_ok = _dispc_mgr_size_ok(timings->x_res, timings->y_res);\r\nif (dss_mgr_is_lcd(channel))\r\ntimings_ok = timings_ok && _dispc_lcd_timings_ok(timings->hsw,\r\ntimings->hfp, timings->hbp,\r\ntimings->vsw, timings->vfp,\r\ntimings->vbp);\r\nreturn timings_ok;\r\n}\r\nstatic void _dispc_mgr_set_lcd_timings(enum omap_channel channel, int hsw,\r\nint hfp, int hbp, int vsw, int vfp, int vbp,\r\nenum omap_dss_signal_level vsync_level,\r\nenum omap_dss_signal_level hsync_level,\r\nenum omap_dss_signal_edge data_pclk_edge,\r\nenum omap_dss_signal_level de_level,\r\nenum omap_dss_signal_edge sync_pclk_edge)\r\n{\r\nu32 timing_h, timing_v, l;\r\nbool onoff, rf, ipc;\r\ntiming_h = FLD_VAL(hsw-1, dispc.feat->sw_start, 0) |\r\nFLD_VAL(hfp-1, dispc.feat->fp_start, 8) |\r\nFLD_VAL(hbp-1, dispc.feat->bp_start, 20);\r\ntiming_v = FLD_VAL(vsw-1, dispc.feat->sw_start, 0) |\r\nFLD_VAL(vfp, dispc.feat->fp_start, 8) |\r\nFLD_VAL(vbp, dispc.feat->bp_start, 20);\r\ndispc_write_reg(DISPC_TIMING_H(channel), timing_h);\r\ndispc_write_reg(DISPC_TIMING_V(channel), timing_v);\r\nswitch (data_pclk_edge) {\r\ncase OMAPDSS_DRIVE_SIG_RISING_EDGE:\r\nipc = false;\r\nbreak;\r\ncase OMAPDSS_DRIVE_SIG_FALLING_EDGE:\r\nipc = true;\r\nbreak;\r\ncase OMAPDSS_DRIVE_SIG_OPPOSITE_EDGES:\r\ndefault:\r\nBUG();\r\n}\r\nswitch (sync_pclk_edge) {\r\ncase OMAPDSS_DRIVE_SIG_OPPOSITE_EDGES:\r\nonoff = false;\r\nrf = false;\r\nbreak;\r\ncase OMAPDSS_DRIVE_SIG_FALLING_EDGE:\r\nonoff = true;\r\nrf = false;\r\nbreak;\r\ncase OMAPDSS_DRIVE_SIG_RISING_EDGE:\r\nonoff = true;\r\nrf = true;\r\nbreak;\r\ndefault:\r\nBUG();\r\n};\r\nl = dispc_read_reg(DISPC_POL_FREQ(channel));\r\nl |= FLD_VAL(onoff, 17, 17);\r\nl |= FLD_VAL(rf, 16, 16);\r\nl |= FLD_VAL(de_level, 15, 15);\r\nl |= FLD_VAL(ipc, 14, 14);\r\nl |= FLD_VAL(hsync_level, 13, 13);\r\nl |= FLD_VAL(vsync_level, 12, 12);\r\ndispc_write_reg(DISPC_POL_FREQ(channel), l);\r\n}\r\nvoid dispc_mgr_set_timings(enum omap_channel channel,\r\nconst struct omap_video_timings *timings)\r\n{\r\nunsigned xtot, ytot;\r\nunsigned long ht, vt;\r\nstruct omap_video_timings t = *timings;\r\nDSSDBG("channel %d xres %u yres %u\n", channel, t.x_res, t.y_res);\r\nif (!dispc_mgr_timings_ok(channel, &t)) {\r\nBUG();\r\nreturn;\r\n}\r\nif (dss_mgr_is_lcd(channel)) {\r\n_dispc_mgr_set_lcd_timings(channel, t.hsw, t.hfp, t.hbp, t.vsw,\r\nt.vfp, t.vbp, t.vsync_level, t.hsync_level,\r\nt.data_pclk_edge, t.de_level, t.sync_pclk_edge);\r\nxtot = t.x_res + t.hfp + t.hsw + t.hbp;\r\nytot = t.y_res + t.vfp + t.vsw + t.vbp;\r\nht = (timings->pixel_clock * 1000) / xtot;\r\nvt = (timings->pixel_clock * 1000) / xtot / ytot;\r\nDSSDBG("pck %u\n", timings->pixel_clock);\r\nDSSDBG("hsw %d hfp %d hbp %d vsw %d vfp %d vbp %d\n",\r\nt.hsw, t.hfp, t.hbp, t.vsw, t.vfp, t.vbp);\r\nDSSDBG("vsync_level %d hsync_level %d data_pclk_edge %d de_level %d sync_pclk_edge %d\n",\r\nt.vsync_level, t.hsync_level, t.data_pclk_edge,\r\nt.de_level, t.sync_pclk_edge);\r\nDSSDBG("hsync %luHz, vsync %luHz\n", ht, vt);\r\n} else {\r\nif (t.interlace == true)\r\nt.y_res /= 2;\r\n}\r\ndispc_mgr_set_size(channel, t.x_res, t.y_res);\r\n}\r\nstatic void dispc_mgr_set_lcd_divisor(enum omap_channel channel, u16 lck_div,\r\nu16 pck_div)\r\n{\r\nBUG_ON(lck_div < 1);\r\nBUG_ON(pck_div < 1);\r\ndispc_write_reg(DISPC_DIVISORo(channel),\r\nFLD_VAL(lck_div, 23, 16) | FLD_VAL(pck_div, 7, 0));\r\n}\r\nstatic void dispc_mgr_get_lcd_divisor(enum omap_channel channel, int *lck_div,\r\nint *pck_div)\r\n{\r\nu32 l;\r\nl = dispc_read_reg(DISPC_DIVISORo(channel));\r\n*lck_div = FLD_GET(l, 23, 16);\r\n*pck_div = FLD_GET(l, 7, 0);\r\n}\r\nunsigned long dispc_fclk_rate(void)\r\n{\r\nstruct platform_device *dsidev;\r\nunsigned long r = 0;\r\nswitch (dss_get_dispc_clk_source()) {\r\ncase OMAP_DSS_CLK_SRC_FCK:\r\nr = dss_get_dispc_clk_rate();\r\nbreak;\r\ncase OMAP_DSS_CLK_SRC_DSI_PLL_HSDIV_DISPC:\r\ndsidev = dsi_get_dsidev_from_id(0);\r\nr = dsi_get_pll_hsdiv_dispc_rate(dsidev);\r\nbreak;\r\ncase OMAP_DSS_CLK_SRC_DSI2_PLL_HSDIV_DISPC:\r\ndsidev = dsi_get_dsidev_from_id(1);\r\nr = dsi_get_pll_hsdiv_dispc_rate(dsidev);\r\nbreak;\r\ndefault:\r\nBUG();\r\nreturn 0;\r\n}\r\nreturn r;\r\n}\r\nunsigned long dispc_mgr_lclk_rate(enum omap_channel channel)\r\n{\r\nstruct platform_device *dsidev;\r\nint lcd;\r\nunsigned long r;\r\nu32 l;\r\nif (dss_mgr_is_lcd(channel)) {\r\nl = dispc_read_reg(DISPC_DIVISORo(channel));\r\nlcd = FLD_GET(l, 23, 16);\r\nswitch (dss_get_lcd_clk_source(channel)) {\r\ncase OMAP_DSS_CLK_SRC_FCK:\r\nr = dss_get_dispc_clk_rate();\r\nbreak;\r\ncase OMAP_DSS_CLK_SRC_DSI_PLL_HSDIV_DISPC:\r\ndsidev = dsi_get_dsidev_from_id(0);\r\nr = dsi_get_pll_hsdiv_dispc_rate(dsidev);\r\nbreak;\r\ncase OMAP_DSS_CLK_SRC_DSI2_PLL_HSDIV_DISPC:\r\ndsidev = dsi_get_dsidev_from_id(1);\r\nr = dsi_get_pll_hsdiv_dispc_rate(dsidev);\r\nbreak;\r\ndefault:\r\nBUG();\r\nreturn 0;\r\n}\r\nreturn r / lcd;\r\n} else {\r\nreturn dispc_fclk_rate();\r\n}\r\n}\r\nunsigned long dispc_mgr_pclk_rate(enum omap_channel channel)\r\n{\r\nunsigned long r;\r\nif (dss_mgr_is_lcd(channel)) {\r\nint pcd;\r\nu32 l;\r\nl = dispc_read_reg(DISPC_DIVISORo(channel));\r\npcd = FLD_GET(l, 7, 0);\r\nr = dispc_mgr_lclk_rate(channel);\r\nreturn r / pcd;\r\n} else {\r\nenum dss_hdmi_venc_clk_source_select source;\r\nsource = dss_get_hdmi_venc_clk_source();\r\nswitch (source) {\r\ncase DSS_VENC_TV_CLK:\r\nreturn venc_get_pixel_clock();\r\ncase DSS_HDMI_M_PCLK:\r\nreturn hdmi_get_pixel_clock();\r\ndefault:\r\nBUG();\r\nreturn 0;\r\n}\r\n}\r\n}\r\nunsigned long dispc_core_clk_rate(void)\r\n{\r\nint lcd;\r\nunsigned long fclk = dispc_fclk_rate();\r\nif (dss_has_feature(FEAT_CORE_CLK_DIV))\r\nlcd = REG_GET(DISPC_DIVISOR, 23, 16);\r\nelse\r\nlcd = REG_GET(DISPC_DIVISORo(OMAP_DSS_CHANNEL_LCD), 23, 16);\r\nreturn fclk / lcd;\r\n}\r\nstatic unsigned long dispc_plane_pclk_rate(enum omap_plane plane)\r\n{\r\nenum omap_channel channel;\r\nif (plane == OMAP_DSS_WB)\r\nreturn 0;\r\nchannel = dispc_ovl_get_channel_out(plane);\r\nreturn dispc_mgr_pclk_rate(channel);\r\n}\r\nstatic unsigned long dispc_plane_lclk_rate(enum omap_plane plane)\r\n{\r\nenum omap_channel channel;\r\nif (plane == OMAP_DSS_WB)\r\nreturn 0;\r\nchannel = dispc_ovl_get_channel_out(plane);\r\nreturn dispc_mgr_lclk_rate(channel);\r\n}\r\nstatic void dispc_dump_clocks_channel(struct seq_file *s, enum omap_channel channel)\r\n{\r\nint lcd, pcd;\r\nenum omap_dss_clk_source lcd_clk_src;\r\nseq_printf(s, "- %s -\n", mgr_desc[channel].name);\r\nlcd_clk_src = dss_get_lcd_clk_source(channel);\r\nseq_printf(s, "%s clk source = %s (%s)\n", mgr_desc[channel].name,\r\ndss_get_generic_clk_source_name(lcd_clk_src),\r\ndss_feat_get_clk_source_name(lcd_clk_src));\r\ndispc_mgr_get_lcd_divisor(channel, &lcd, &pcd);\r\nseq_printf(s, "lck\t\t%-16lulck div\t%u\n",\r\ndispc_mgr_lclk_rate(channel), lcd);\r\nseq_printf(s, "pck\t\t%-16lupck div\t%u\n",\r\ndispc_mgr_pclk_rate(channel), pcd);\r\n}\r\nvoid dispc_dump_clocks(struct seq_file *s)\r\n{\r\nint lcd;\r\nu32 l;\r\nenum omap_dss_clk_source dispc_clk_src = dss_get_dispc_clk_source();\r\nif (dispc_runtime_get())\r\nreturn;\r\nseq_printf(s, "- DISPC -\n");\r\nseq_printf(s, "dispc fclk source = %s (%s)\n",\r\ndss_get_generic_clk_source_name(dispc_clk_src),\r\ndss_feat_get_clk_source_name(dispc_clk_src));\r\nseq_printf(s, "fck\t\t%-16lu\n", dispc_fclk_rate());\r\nif (dss_has_feature(FEAT_CORE_CLK_DIV)) {\r\nseq_printf(s, "- DISPC-CORE-CLK -\n");\r\nl = dispc_read_reg(DISPC_DIVISOR);\r\nlcd = FLD_GET(l, 23, 16);\r\nseq_printf(s, "lck\t\t%-16lulck div\t%u\n",\r\n(dispc_fclk_rate()/lcd), lcd);\r\n}\r\ndispc_dump_clocks_channel(s, OMAP_DSS_CHANNEL_LCD);\r\nif (dss_has_feature(FEAT_MGR_LCD2))\r\ndispc_dump_clocks_channel(s, OMAP_DSS_CHANNEL_LCD2);\r\nif (dss_has_feature(FEAT_MGR_LCD3))\r\ndispc_dump_clocks_channel(s, OMAP_DSS_CHANNEL_LCD3);\r\ndispc_runtime_put();\r\n}\r\nstatic void dispc_dump_regs(struct seq_file *s)\r\n{\r\nint i, j;\r\nconst char *mgr_names[] = {\r\n[OMAP_DSS_CHANNEL_LCD] = "LCD",\r\n[OMAP_DSS_CHANNEL_DIGIT] = "TV",\r\n[OMAP_DSS_CHANNEL_LCD2] = "LCD2",\r\n[OMAP_DSS_CHANNEL_LCD3] = "LCD3",\r\n};\r\nconst char *ovl_names[] = {\r\n[OMAP_DSS_GFX] = "GFX",\r\n[OMAP_DSS_VIDEO1] = "VID1",\r\n[OMAP_DSS_VIDEO2] = "VID2",\r\n[OMAP_DSS_VIDEO3] = "VID3",\r\n};\r\nconst char **p_names;\r\n#define DUMPREG(r) seq_printf(s, "%-50s %08x\n", #r, dispc_read_reg(r))\r\nif (dispc_runtime_get())\r\nreturn;\r\nDUMPREG(DISPC_REVISION);\r\nDUMPREG(DISPC_SYSCONFIG);\r\nDUMPREG(DISPC_SYSSTATUS);\r\nDUMPREG(DISPC_IRQSTATUS);\r\nDUMPREG(DISPC_IRQENABLE);\r\nDUMPREG(DISPC_CONTROL);\r\nDUMPREG(DISPC_CONFIG);\r\nDUMPREG(DISPC_CAPABLE);\r\nDUMPREG(DISPC_LINE_STATUS);\r\nDUMPREG(DISPC_LINE_NUMBER);\r\nif (dss_has_feature(FEAT_ALPHA_FIXED_ZORDER) ||\r\ndss_has_feature(FEAT_ALPHA_FREE_ZORDER))\r\nDUMPREG(DISPC_GLOBAL_ALPHA);\r\nif (dss_has_feature(FEAT_MGR_LCD2)) {\r\nDUMPREG(DISPC_CONTROL2);\r\nDUMPREG(DISPC_CONFIG2);\r\n}\r\nif (dss_has_feature(FEAT_MGR_LCD3)) {\r\nDUMPREG(DISPC_CONTROL3);\r\nDUMPREG(DISPC_CONFIG3);\r\n}\r\n#undef DUMPREG\r\n#define DISPC_REG(i, name) name(i)\r\n#define DUMPREG(i, r) seq_printf(s, "%s(%s)%*s %08x\n", #r, p_names[i], \\r\n(int)(48 - strlen(#r) - strlen(p_names[i])), " ", \\r\ndispc_read_reg(DISPC_REG(i, r)))\r\np_names = mgr_names;\r\nfor (i = 0; i < dss_feat_get_num_mgrs(); i++) {\r\nDUMPREG(i, DISPC_DEFAULT_COLOR);\r\nDUMPREG(i, DISPC_TRANS_COLOR);\r\nDUMPREG(i, DISPC_SIZE_MGR);\r\nif (i == OMAP_DSS_CHANNEL_DIGIT)\r\ncontinue;\r\nDUMPREG(i, DISPC_DEFAULT_COLOR);\r\nDUMPREG(i, DISPC_TRANS_COLOR);\r\nDUMPREG(i, DISPC_TIMING_H);\r\nDUMPREG(i, DISPC_TIMING_V);\r\nDUMPREG(i, DISPC_POL_FREQ);\r\nDUMPREG(i, DISPC_DIVISORo);\r\nDUMPREG(i, DISPC_SIZE_MGR);\r\nDUMPREG(i, DISPC_DATA_CYCLE1);\r\nDUMPREG(i, DISPC_DATA_CYCLE2);\r\nDUMPREG(i, DISPC_DATA_CYCLE3);\r\nif (dss_has_feature(FEAT_CPR)) {\r\nDUMPREG(i, DISPC_CPR_COEF_R);\r\nDUMPREG(i, DISPC_CPR_COEF_G);\r\nDUMPREG(i, DISPC_CPR_COEF_B);\r\n}\r\n}\r\np_names = ovl_names;\r\nfor (i = 0; i < dss_feat_get_num_ovls(); i++) {\r\nDUMPREG(i, DISPC_OVL_BA0);\r\nDUMPREG(i, DISPC_OVL_BA1);\r\nDUMPREG(i, DISPC_OVL_POSITION);\r\nDUMPREG(i, DISPC_OVL_SIZE);\r\nDUMPREG(i, DISPC_OVL_ATTRIBUTES);\r\nDUMPREG(i, DISPC_OVL_FIFO_THRESHOLD);\r\nDUMPREG(i, DISPC_OVL_FIFO_SIZE_STATUS);\r\nDUMPREG(i, DISPC_OVL_ROW_INC);\r\nDUMPREG(i, DISPC_OVL_PIXEL_INC);\r\nif (dss_has_feature(FEAT_PRELOAD))\r\nDUMPREG(i, DISPC_OVL_PRELOAD);\r\nif (i == OMAP_DSS_GFX) {\r\nDUMPREG(i, DISPC_OVL_WINDOW_SKIP);\r\nDUMPREG(i, DISPC_OVL_TABLE_BA);\r\ncontinue;\r\n}\r\nDUMPREG(i, DISPC_OVL_FIR);\r\nDUMPREG(i, DISPC_OVL_PICTURE_SIZE);\r\nDUMPREG(i, DISPC_OVL_ACCU0);\r\nDUMPREG(i, DISPC_OVL_ACCU1);\r\nif (dss_has_feature(FEAT_HANDLE_UV_SEPARATE)) {\r\nDUMPREG(i, DISPC_OVL_BA0_UV);\r\nDUMPREG(i, DISPC_OVL_BA1_UV);\r\nDUMPREG(i, DISPC_OVL_FIR2);\r\nDUMPREG(i, DISPC_OVL_ACCU2_0);\r\nDUMPREG(i, DISPC_OVL_ACCU2_1);\r\n}\r\nif (dss_has_feature(FEAT_ATTR2))\r\nDUMPREG(i, DISPC_OVL_ATTRIBUTES2);\r\nif (dss_has_feature(FEAT_PRELOAD))\r\nDUMPREG(i, DISPC_OVL_PRELOAD);\r\n}\r\n#undef DISPC_REG\r\n#undef DUMPREG\r\n#define DISPC_REG(plane, name, i) name(plane, i)\r\n#define DUMPREG(plane, name, i) \\r\nseq_printf(s, "%s_%d(%s)%*s %08x\n", #name, i, p_names[plane], \\r\n(int)(46 - strlen(#name) - strlen(p_names[plane])), " ", \\r\ndispc_read_reg(DISPC_REG(plane, name, i)))\r\nfor (i = 1; i < dss_feat_get_num_ovls(); i++) {\r\nfor (j = 0; j < 8; j++)\r\nDUMPREG(i, DISPC_OVL_FIR_COEF_H, j);\r\nfor (j = 0; j < 8; j++)\r\nDUMPREG(i, DISPC_OVL_FIR_COEF_HV, j);\r\nfor (j = 0; j < 5; j++)\r\nDUMPREG(i, DISPC_OVL_CONV_COEF, j);\r\nif (dss_has_feature(FEAT_FIR_COEF_V)) {\r\nfor (j = 0; j < 8; j++)\r\nDUMPREG(i, DISPC_OVL_FIR_COEF_V, j);\r\n}\r\nif (dss_has_feature(FEAT_HANDLE_UV_SEPARATE)) {\r\nfor (j = 0; j < 8; j++)\r\nDUMPREG(i, DISPC_OVL_FIR_COEF_H2, j);\r\nfor (j = 0; j < 8; j++)\r\nDUMPREG(i, DISPC_OVL_FIR_COEF_HV2, j);\r\nfor (j = 0; j < 8; j++)\r\nDUMPREG(i, DISPC_OVL_FIR_COEF_V2, j);\r\n}\r\n}\r\ndispc_runtime_put();\r\n#undef DISPC_REG\r\n#undef DUMPREG\r\n}\r\nvoid dispc_find_clk_divs(unsigned long req_pck, unsigned long fck,\r\nstruct dispc_clock_info *cinfo)\r\n{\r\nu16 pcd_min, pcd_max;\r\nunsigned long best_pck;\r\nu16 best_ld, cur_ld;\r\nu16 best_pd, cur_pd;\r\npcd_min = dss_feat_get_param_min(FEAT_PARAM_DSS_PCD);\r\npcd_max = dss_feat_get_param_max(FEAT_PARAM_DSS_PCD);\r\nbest_pck = 0;\r\nbest_ld = 0;\r\nbest_pd = 0;\r\nfor (cur_ld = 1; cur_ld <= 255; ++cur_ld) {\r\nunsigned long lck = fck / cur_ld;\r\nfor (cur_pd = pcd_min; cur_pd <= pcd_max; ++cur_pd) {\r\nunsigned long pck = lck / cur_pd;\r\nlong old_delta = abs(best_pck - req_pck);\r\nlong new_delta = abs(pck - req_pck);\r\nif (best_pck == 0 || new_delta < old_delta) {\r\nbest_pck = pck;\r\nbest_ld = cur_ld;\r\nbest_pd = cur_pd;\r\nif (pck == req_pck)\r\ngoto found;\r\n}\r\nif (pck < req_pck)\r\nbreak;\r\n}\r\nif (lck / pcd_min < req_pck)\r\nbreak;\r\n}\r\nfound:\r\ncinfo->lck_div = best_ld;\r\ncinfo->pck_div = best_pd;\r\ncinfo->lck = fck / cinfo->lck_div;\r\ncinfo->pck = cinfo->lck / cinfo->pck_div;\r\n}\r\nint dispc_calc_clock_rates(unsigned long dispc_fclk_rate,\r\nstruct dispc_clock_info *cinfo)\r\n{\r\nif (cinfo->lck_div > 255 || cinfo->lck_div == 0)\r\nreturn -EINVAL;\r\nif (cinfo->pck_div < 1 || cinfo->pck_div > 255)\r\nreturn -EINVAL;\r\ncinfo->lck = dispc_fclk_rate / cinfo->lck_div;\r\ncinfo->pck = cinfo->lck / cinfo->pck_div;\r\nreturn 0;\r\n}\r\nvoid dispc_mgr_set_clock_div(enum omap_channel channel,\r\nconst struct dispc_clock_info *cinfo)\r\n{\r\nDSSDBG("lck = %lu (%u)\n", cinfo->lck, cinfo->lck_div);\r\nDSSDBG("pck = %lu (%u)\n", cinfo->pck, cinfo->pck_div);\r\ndispc_mgr_set_lcd_divisor(channel, cinfo->lck_div, cinfo->pck_div);\r\n}\r\nint dispc_mgr_get_clock_div(enum omap_channel channel,\r\nstruct dispc_clock_info *cinfo)\r\n{\r\nunsigned long fck;\r\nfck = dispc_fclk_rate();\r\ncinfo->lck_div = REG_GET(DISPC_DIVISORo(channel), 23, 16);\r\ncinfo->pck_div = REG_GET(DISPC_DIVISORo(channel), 7, 0);\r\ncinfo->lck = fck / cinfo->lck_div;\r\ncinfo->pck = cinfo->lck / cinfo->pck_div;\r\nreturn 0;\r\n}\r\nu32 dispc_read_irqstatus(void)\r\n{\r\nreturn dispc_read_reg(DISPC_IRQSTATUS);\r\n}\r\nvoid dispc_clear_irqstatus(u32 mask)\r\n{\r\ndispc_write_reg(DISPC_IRQSTATUS, mask);\r\n}\r\nu32 dispc_read_irqenable(void)\r\n{\r\nreturn dispc_read_reg(DISPC_IRQENABLE);\r\n}\r\nvoid dispc_write_irqenable(u32 mask)\r\n{\r\nu32 old_mask = dispc_read_reg(DISPC_IRQENABLE);\r\ndispc_clear_irqstatus((mask ^ old_mask) & mask);\r\ndispc_write_reg(DISPC_IRQENABLE, mask);\r\n}\r\nvoid dispc_enable_sidle(void)\r\n{\r\nREG_FLD_MOD(DISPC_SYSCONFIG, 2, 4, 3);\r\n}\r\nvoid dispc_disable_sidle(void)\r\n{\r\nREG_FLD_MOD(DISPC_SYSCONFIG, 1, 4, 3);\r\n}\r\nstatic void _omap_dispc_initial_config(void)\r\n{\r\nu32 l;\r\nif (dss_has_feature(FEAT_CORE_CLK_DIV)) {\r\nl = dispc_read_reg(DISPC_DIVISOR);\r\nl = FLD_MOD(l, 1, 0, 0);\r\nl = FLD_MOD(l, 1, 23, 16);\r\ndispc_write_reg(DISPC_DIVISOR, l);\r\n}\r\nif (dss_has_feature(FEAT_FUNCGATED))\r\nREG_FLD_MOD(DISPC_CONFIG, 1, 9, 9);\r\ndispc_setup_color_conv_coef();\r\ndispc_set_loadmode(OMAP_DSS_LOAD_FRAME_ONLY);\r\ndispc_init_fifos();\r\ndispc_configure_burst_sizes();\r\ndispc_ovl_enable_zorder_planes();\r\n}\r\nstatic int __init dispc_init_features(struct platform_device *pdev)\r\n{\r\nconst struct dispc_features *src;\r\nstruct dispc_features *dst;\r\ndst = devm_kzalloc(&pdev->dev, sizeof(*dst), GFP_KERNEL);\r\nif (!dst) {\r\ndev_err(&pdev->dev, "Failed to allocate DISPC Features\n");\r\nreturn -ENOMEM;\r\n}\r\nswitch (omapdss_get_version()) {\r\ncase OMAPDSS_VER_OMAP24xx:\r\nsrc = &omap24xx_dispc_feats;\r\nbreak;\r\ncase OMAPDSS_VER_OMAP34xx_ES1:\r\nsrc = &omap34xx_rev1_0_dispc_feats;\r\nbreak;\r\ncase OMAPDSS_VER_OMAP34xx_ES3:\r\ncase OMAPDSS_VER_OMAP3630:\r\ncase OMAPDSS_VER_AM35xx:\r\nsrc = &omap34xx_rev3_0_dispc_feats;\r\nbreak;\r\ncase OMAPDSS_VER_OMAP4430_ES1:\r\ncase OMAPDSS_VER_OMAP4430_ES2:\r\ncase OMAPDSS_VER_OMAP4:\r\nsrc = &omap44xx_dispc_feats;\r\nbreak;\r\ncase OMAPDSS_VER_OMAP5:\r\nsrc = &omap54xx_dispc_feats;\r\nbreak;\r\ndefault:\r\nreturn -ENODEV;\r\n}\r\nmemcpy(dst, src, sizeof(*dst));\r\ndispc.feat = dst;\r\nreturn 0;\r\n}\r\nint dispc_request_irq(irq_handler_t handler, void *dev_id)\r\n{\r\nreturn devm_request_irq(&dispc.pdev->dev, dispc.irq, handler,\r\nIRQF_SHARED, "OMAP DISPC", dev_id);\r\n}\r\nvoid dispc_free_irq(void *dev_id)\r\n{\r\ndevm_free_irq(&dispc.pdev->dev, dispc.irq, dev_id);\r\n}\r\nstatic int __init omap_dispchw_probe(struct platform_device *pdev)\r\n{\r\nu32 rev;\r\nint r = 0;\r\nstruct resource *dispc_mem;\r\ndispc.pdev = pdev;\r\nr = dispc_init_features(dispc.pdev);\r\nif (r)\r\nreturn r;\r\ndispc_mem = platform_get_resource(dispc.pdev, IORESOURCE_MEM, 0);\r\nif (!dispc_mem) {\r\nDSSERR("can't get IORESOURCE_MEM DISPC\n");\r\nreturn -EINVAL;\r\n}\r\ndispc.base = devm_ioremap(&pdev->dev, dispc_mem->start,\r\nresource_size(dispc_mem));\r\nif (!dispc.base) {\r\nDSSERR("can't ioremap DISPC\n");\r\nreturn -ENOMEM;\r\n}\r\ndispc.irq = platform_get_irq(dispc.pdev, 0);\r\nif (dispc.irq < 0) {\r\nDSSERR("platform_get_irq failed\n");\r\nreturn -ENODEV;\r\n}\r\npm_runtime_enable(&pdev->dev);\r\nr = dispc_runtime_get();\r\nif (r)\r\ngoto err_runtime_get;\r\n_omap_dispc_initial_config();\r\nrev = dispc_read_reg(DISPC_REVISION);\r\ndev_dbg(&pdev->dev, "OMAP DISPC rev %d.%d\n",\r\nFLD_GET(rev, 7, 4), FLD_GET(rev, 3, 0));\r\ndispc_runtime_put();\r\ndss_debugfs_create_file("dispc", dispc_dump_regs);\r\nreturn 0;\r\nerr_runtime_get:\r\npm_runtime_disable(&pdev->dev);\r\nreturn r;\r\n}\r\nstatic int __exit omap_dispchw_remove(struct platform_device *pdev)\r\n{\r\npm_runtime_disable(&pdev->dev);\r\nreturn 0;\r\n}\r\nstatic int dispc_runtime_suspend(struct device *dev)\r\n{\r\ndispc_save_context();\r\nreturn 0;\r\n}\r\nstatic int dispc_runtime_resume(struct device *dev)\r\n{\r\ndispc_restore_context();\r\nreturn 0;\r\n}\r\nint __init dispc_init_platform_driver(void)\r\n{\r\nreturn platform_driver_probe(&omap_dispchw_driver, omap_dispchw_probe);\r\n}\r\nvoid __exit dispc_uninit_platform_driver(void)\r\n{\r\nplatform_driver_unregister(&omap_dispchw_driver);\r\n}
