static void gpio_error(unsigned gpio)\r\n{\r\nprintk(KERN_ERR "bfin-gpio: GPIO %d wasn't requested!\n", gpio);\r\n}\r\nstatic void set_label(unsigned short ident, const char *label)\r\n{\r\nif (label) {\r\nstrncpy(str_ident[ident].name, label,\r\nRESOURCE_LABEL_SIZE);\r\nstr_ident[ident].name[RESOURCE_LABEL_SIZE - 1] = 0;\r\n}\r\n}\r\nstatic char *get_label(unsigned short ident)\r\n{\r\nreturn (*str_ident[ident].name ? str_ident[ident].name : "UNKNOWN");\r\n}\r\nstatic int cmp_label(unsigned short ident, const char *label)\r\n{\r\nif (label == NULL) {\r\ndump_stack();\r\nprintk(KERN_ERR "Please provide none-null label\n");\r\n}\r\nif (label)\r\nreturn strcmp(str_ident[ident].name, label);\r\nelse\r\nreturn -EINVAL;\r\n}\r\ninline int check_gpio(unsigned gpio)\r\n{\r\n#if defined(CONFIG_BF54x)\r\nif (gpio == GPIO_PB15 || gpio == GPIO_PC14 || gpio == GPIO_PC15\r\n|| gpio == GPIO_PH14 || gpio == GPIO_PH15\r\n|| gpio == GPIO_PJ14 || gpio == GPIO_PJ15)\r\nreturn -EINVAL;\r\n#endif\r\nif (gpio >= MAX_BLACKFIN_GPIOS)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic void port_setup(unsigned gpio, unsigned short usage)\r\n{\r\n#if defined(BF538_FAMILY)\r\nif (gpio < MAX_BLACKFIN_GPIOS || gpio >= MAX_RESOURCES)\r\nreturn;\r\ngpio -= MAX_BLACKFIN_GPIOS;\r\nif (usage == GPIO_USAGE)\r\n*port_fer[gpio_bank(gpio)] |= gpio_bit(gpio);\r\nelse\r\n*port_fer[gpio_bank(gpio)] &= ~gpio_bit(gpio);\r\nSSYNC();\r\nreturn;\r\n#endif\r\nif (check_gpio(gpio))\r\nreturn;\r\n#if defined(CONFIG_BF52x) || defined(BF537_FAMILY) || defined(CONFIG_BF51x)\r\nif (usage == GPIO_USAGE)\r\n*port_fer[gpio_bank(gpio)] &= ~gpio_bit(gpio);\r\nelse\r\n*port_fer[gpio_bank(gpio)] |= gpio_bit(gpio);\r\nSSYNC();\r\n#elif defined(CONFIG_BF54x) || defined(CONFIG_BF60x)\r\nif (usage == GPIO_USAGE)\r\ngpio_array[gpio_bank(gpio)]->port_fer &= ~gpio_bit(gpio);\r\nelse\r\ngpio_array[gpio_bank(gpio)]->port_fer |= gpio_bit(gpio);\r\nSSYNC();\r\n#endif\r\n}\r\nstatic int portmux_group_check(unsigned short per)\r\n{\r\nu16 ident = P_IDENT(per);\r\nu16 function = P_FUNCT2MUX(per);\r\ns8 offset = port_mux[ident];\r\nu16 m, pmux, pfunc;\r\nif (offset < 0)\r\nreturn 0;\r\npmux = bfin_read_PORT_MUX();\r\nfor (m = 0; m < ARRAY_SIZE(port_mux); ++m) {\r\nif (m == ident)\r\ncontinue;\r\nif (port_mux[m] != offset)\r\ncontinue;\r\nif (!is_reserved(peri, m, 1))\r\ncontinue;\r\nif (offset == 1)\r\npfunc = (pmux >> offset) & 3;\r\nelse\r\npfunc = (pmux >> offset) & 1;\r\nif (pfunc != function) {\r\npr_err("pin group conflict! request pin %d func %d conflict with pin %d func %d\n",\r\nident, function, m, pfunc);\r\nreturn -EINVAL;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void portmux_setup(unsigned short per)\r\n{\r\nu16 ident = P_IDENT(per);\r\nu16 function = P_FUNCT2MUX(per);\r\ns8 offset = port_mux[ident];\r\nu16 pmux;\r\nif (offset == -1)\r\nreturn;\r\npmux = bfin_read_PORT_MUX();\r\nif (offset != 1)\r\npmux &= ~(1 << offset);\r\nelse\r\npmux &= ~(3 << 1);\r\npmux |= (function << offset);\r\nbfin_write_PORT_MUX(pmux);\r\n}\r\ninline void portmux_setup(unsigned short per)\r\n{\r\nu16 ident = P_IDENT(per);\r\nu16 function = P_FUNCT2MUX(per);\r\nu32 pmux;\r\npmux = gpio_array[gpio_bank(ident)]->port_mux;\r\npmux &= ~(0x3 << (2 * gpio_sub_n(ident)));\r\npmux |= (function & 0x3) << (2 * gpio_sub_n(ident));\r\ngpio_array[gpio_bank(ident)]->port_mux = pmux;\r\n}\r\ninline u16 get_portmux(unsigned short per)\r\n{\r\nu16 ident = P_IDENT(per);\r\nu32 pmux = gpio_array[gpio_bank(ident)]->port_mux;\r\nreturn (pmux >> (2 * gpio_sub_n(ident)) & 0x3);\r\n}\r\nstatic int portmux_group_check(unsigned short per)\r\n{\r\nreturn 0;\r\n}\r\nstatic int portmux_group_check(unsigned short per)\r\n{\r\nu16 ident = P_IDENT(per);\r\nu16 function = P_FUNCT2MUX(per);\r\nu8 offset = pmux_offset[gpio_bank(ident)][gpio_sub_n(ident)];\r\nu16 pin, gpiopin, pfunc;\r\nfor (pin = 0; pin < GPIO_BANKSIZE; ++pin) {\r\nif (offset != pmux_offset[gpio_bank(ident)][pin])\r\ncontinue;\r\ngpiopin = gpio_bank(ident) * GPIO_BANKSIZE + pin;\r\nif (gpiopin == ident)\r\ncontinue;\r\nif (!is_reserved(peri, gpiopin, 1))\r\ncontinue;\r\npfunc = *port_mux[gpio_bank(ident)];\r\npfunc = (pfunc >> offset) & 3;\r\nif (pfunc != function) {\r\npr_err("pin group conflict! request pin %d func %d conflict with pin %d func %d\n",\r\nident, function, gpiopin, pfunc);\r\nreturn -EINVAL;\r\n}\r\n}\r\nreturn 0;\r\n}\r\ninline void portmux_setup(unsigned short per)\r\n{\r\nu16 ident = P_IDENT(per);\r\nu16 function = P_FUNCT2MUX(per);\r\nu8 offset = pmux_offset[gpio_bank(ident)][gpio_sub_n(ident)];\r\nu16 pmux;\r\npmux = *port_mux[gpio_bank(ident)];\r\nif (((pmux >> offset) & 3) == function)\r\nreturn;\r\npmux &= ~(3 << offset);\r\npmux |= (function & 3) << offset;\r\n*port_mux[gpio_bank(ident)] = pmux;\r\nSSYNC();\r\n}\r\nstatic int portmux_group_check(unsigned short per)\r\n{\r\nreturn 0;\r\n}\r\nvoid set_gpio_toggle(unsigned gpio)\r\n{\r\nunsigned long flags;\r\nif (ANOMALY_05000311 || ANOMALY_05000323)\r\nflags = hard_local_irq_save();\r\ngpio_array[gpio_bank(gpio)]->toggle = gpio_bit(gpio);\r\nif (ANOMALY_05000311 || ANOMALY_05000323) {\r\nAWA_DUMMY_READ(toggle);\r\nhard_local_irq_restore(flags);\r\n}\r\n}\r\nint gpio_pm_wakeup_ctrl(unsigned gpio, unsigned ctrl)\r\n{\r\nunsigned long flags;\r\nif (check_gpio(gpio) < 0)\r\nreturn -EINVAL;\r\nflags = hard_local_irq_save();\r\nif (ctrl)\r\nreserve(wakeup, gpio);\r\nelse\r\nunreserve(wakeup, gpio);\r\nset_gpio_maskb(gpio, ctrl);\r\nhard_local_irq_restore(flags);\r\nreturn 0;\r\n}\r\nint bfin_pm_standby_ctrl(unsigned ctrl)\r\n{\r\nu16 bank, mask, i;\r\nfor (i = 0; i < MAX_BLACKFIN_GPIOS; i += GPIO_BANKSIZE) {\r\nmask = map_entry(wakeup, i);\r\nbank = gpio_bank(i);\r\nif (mask)\r\nbfin_internal_set_wake(sic_iwr_irqs[bank], ctrl);\r\n}\r\nreturn 0;\r\n}\r\nvoid bfin_gpio_pm_hibernate_suspend(void)\r\n{\r\nint i, bank;\r\n#ifdef BF538_FAMILY\r\nfor (i = 0; i < ARRAY_SIZE(port_fer_saved); ++i)\r\nport_fer_saved[i] = *port_fer[i];\r\n#endif\r\nfor (i = 0; i < MAX_BLACKFIN_GPIOS; i += GPIO_BANKSIZE) {\r\nbank = gpio_bank(i);\r\n#if defined(CONFIG_BF52x) || defined(BF537_FAMILY) || defined(CONFIG_BF51x)\r\ngpio_bank_saved[bank].fer = *port_fer[bank];\r\n#if defined(CONFIG_BF52x) || defined(CONFIG_BF51x)\r\ngpio_bank_saved[bank].mux = *port_mux[bank];\r\n#else\r\nif (bank == 0)\r\ngpio_bank_saved[bank].mux = bfin_read_PORT_MUX();\r\n#endif\r\n#endif\r\ngpio_bank_saved[bank].data = gpio_array[bank]->data;\r\ngpio_bank_saved[bank].inen = gpio_array[bank]->inen;\r\ngpio_bank_saved[bank].polar = gpio_array[bank]->polar;\r\ngpio_bank_saved[bank].dir = gpio_array[bank]->dir;\r\ngpio_bank_saved[bank].edge = gpio_array[bank]->edge;\r\ngpio_bank_saved[bank].both = gpio_array[bank]->both;\r\ngpio_bank_saved[bank].maska = gpio_array[bank]->maska;\r\n}\r\n#ifdef BFIN_SPECIAL_GPIO_BANKS\r\nbfin_special_gpio_pm_hibernate_suspend();\r\n#endif\r\nAWA_DUMMY_READ(maska);\r\n}\r\nvoid bfin_gpio_pm_hibernate_restore(void)\r\n{\r\nint i, bank;\r\n#ifdef BF538_FAMILY\r\nfor (i = 0; i < ARRAY_SIZE(port_fer_saved); ++i)\r\n*port_fer[i] = port_fer_saved[i];\r\n#endif\r\nfor (i = 0; i < MAX_BLACKFIN_GPIOS; i += GPIO_BANKSIZE) {\r\nbank = gpio_bank(i);\r\n#if defined(CONFIG_BF52x) || defined(BF537_FAMILY) || defined(CONFIG_BF51x)\r\n#if defined(CONFIG_BF52x) || defined(CONFIG_BF51x)\r\n*port_mux[bank] = gpio_bank_saved[bank].mux;\r\n#else\r\nif (bank == 0)\r\nbfin_write_PORT_MUX(gpio_bank_saved[bank].mux);\r\n#endif\r\n*port_fer[bank] = gpio_bank_saved[bank].fer;\r\n#endif\r\ngpio_array[bank]->inen = gpio_bank_saved[bank].inen;\r\ngpio_array[bank]->data_set = gpio_bank_saved[bank].data\r\n& gpio_bank_saved[bank].dir;\r\ngpio_array[bank]->dir = gpio_bank_saved[bank].dir;\r\ngpio_array[bank]->polar = gpio_bank_saved[bank].polar;\r\ngpio_array[bank]->edge = gpio_bank_saved[bank].edge;\r\ngpio_array[bank]->both = gpio_bank_saved[bank].both;\r\ngpio_array[bank]->maska = gpio_bank_saved[bank].maska;\r\n}\r\n#ifdef BFIN_SPECIAL_GPIO_BANKS\r\nbfin_special_gpio_pm_hibernate_restore();\r\n#endif\r\nAWA_DUMMY_READ(maska);\r\n}\r\nint bfin_pm_standby_ctrl(unsigned ctrl)\r\n{\r\nreturn 0;\r\n}\r\nvoid bfin_gpio_pm_hibernate_suspend(void)\r\n{\r\nint i, bank;\r\nfor (i = 0; i < MAX_BLACKFIN_GPIOS; i += GPIO_BANKSIZE) {\r\nbank = gpio_bank(i);\r\ngpio_bank_saved[bank].fer = gpio_array[bank]->port_fer;\r\ngpio_bank_saved[bank].mux = gpio_array[bank]->port_mux;\r\ngpio_bank_saved[bank].data = gpio_array[bank]->data;\r\ngpio_bank_saved[bank].inen = gpio_array[bank]->inen;\r\ngpio_bank_saved[bank].dir = gpio_array[bank]->dir_set;\r\n}\r\n}\r\nvoid bfin_gpio_pm_hibernate_restore(void)\r\n{\r\nint i, bank;\r\nfor (i = 0; i < MAX_BLACKFIN_GPIOS; i += GPIO_BANKSIZE) {\r\nbank = gpio_bank(i);\r\ngpio_array[bank]->port_mux = gpio_bank_saved[bank].mux;\r\ngpio_array[bank]->port_fer = gpio_bank_saved[bank].fer;\r\ngpio_array[bank]->inen = gpio_bank_saved[bank].inen;\r\ngpio_array[bank]->data_set = gpio_bank_saved[bank].data\r\n& gpio_bank_saved[bank].dir;\r\ngpio_array[bank]->dir_set = gpio_bank_saved[bank].dir;\r\n}\r\n}\r\nunsigned short get_gpio_dir(unsigned gpio)\r\n{\r\nreturn (0x01 & (gpio_array[gpio_bank(gpio)]->dir_clear >> gpio_sub_n(gpio)));\r\n}\r\nint peripheral_request_list(const unsigned short per[], const char *label)\r\n{\r\nu16 cnt;\r\nint ret;\r\nfor (cnt = 0; per[cnt] != 0; cnt++) {\r\nret = peripheral_request(per[cnt], label);\r\nif (ret < 0) {\r\nfor ( ; cnt > 0; cnt--)\r\nperipheral_free(per[cnt - 1]);\r\nreturn ret;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nvoid peripheral_free(unsigned short per)\r\n{\r\nunsigned long flags;\r\nunsigned short ident = P_IDENT(per);\r\nif (per & P_DONTCARE)\r\nreturn;\r\nif (!(per & P_DEFINED))\r\nreturn;\r\nflags = hard_local_irq_save();\r\nif (unlikely(!is_reserved(peri, ident, 0))) {\r\nhard_local_irq_restore(flags);\r\nreturn;\r\n}\r\nif (!(per & P_MAYSHARE))\r\nport_setup(ident, GPIO_USAGE);\r\nunreserve(peri, ident);\r\nset_label(ident, "free");\r\nhard_local_irq_restore(flags);\r\n}\r\nvoid peripheral_free_list(const unsigned short per[])\r\n{\r\nu16 cnt;\r\nfor (cnt = 0; per[cnt] != 0; cnt++)\r\nperipheral_free(per[cnt]);\r\n}\r\nint bfin_gpio_request(unsigned gpio, const char *label)\r\n{\r\nunsigned long flags;\r\nif (check_gpio(gpio) < 0)\r\nreturn -EINVAL;\r\nflags = hard_local_irq_save();\r\nif (cmp_label(gpio, label) == 0) {\r\nhard_local_irq_restore(flags);\r\nreturn 0;\r\n}\r\nif (unlikely(is_reserved(gpio, gpio, 1))) {\r\nif (system_state == SYSTEM_BOOTING)\r\ndump_stack();\r\nprintk(KERN_ERR "bfin-gpio: GPIO %d is already reserved by %s !\n",\r\ngpio, get_label(gpio));\r\nhard_local_irq_restore(flags);\r\nreturn -EBUSY;\r\n}\r\nif (unlikely(is_reserved(peri, gpio, 1))) {\r\nif (system_state == SYSTEM_BOOTING)\r\ndump_stack();\r\nprintk(KERN_ERR\r\n"bfin-gpio: GPIO %d is already reserved as Peripheral by %s !\n",\r\ngpio, get_label(gpio));\r\nhard_local_irq_restore(flags);\r\nreturn -EBUSY;\r\n}\r\nif (unlikely(is_reserved(gpio_irq, gpio, 1))) {\r\nprintk(KERN_NOTICE "bfin-gpio: GPIO %d is already reserved as gpio-irq!"\r\n" (Documentation/blackfin/bfin-gpio-notes.txt)\n", gpio);\r\n}\r\n#if !(defined(CONFIG_BF54x) || defined(CONFIG_BF60x))\r\nelse {\r\nset_gpio_polar(gpio, 0);\r\n}\r\n#endif\r\nreserve(gpio, gpio);\r\nset_label(gpio, label);\r\nhard_local_irq_restore(flags);\r\nport_setup(gpio, GPIO_USAGE);\r\nreturn 0;\r\n}\r\nvoid bfin_gpio_free(unsigned gpio)\r\n{\r\nunsigned long flags;\r\nif (check_gpio(gpio) < 0)\r\nreturn;\r\nmight_sleep();\r\nflags = hard_local_irq_save();\r\nif (unlikely(!is_reserved(gpio, gpio, 0))) {\r\nif (system_state == SYSTEM_BOOTING)\r\ndump_stack();\r\ngpio_error(gpio);\r\nhard_local_irq_restore(flags);\r\nreturn;\r\n}\r\nunreserve(gpio, gpio);\r\nset_label(gpio, "free");\r\nhard_local_irq_restore(flags);\r\n}\r\nint bfin_special_gpio_request(unsigned gpio, const char *label)\r\n{\r\nunsigned long flags;\r\nflags = hard_local_irq_save();\r\nif (cmp_label(gpio, label) == 0) {\r\nhard_local_irq_restore(flags);\r\nreturn 0;\r\n}\r\nif (unlikely(is_reserved(special_gpio, gpio, 1))) {\r\nhard_local_irq_restore(flags);\r\nprintk(KERN_ERR "bfin-gpio: GPIO %d is already reserved by %s !\n",\r\ngpio, get_label(gpio));\r\nreturn -EBUSY;\r\n}\r\nif (unlikely(is_reserved(peri, gpio, 1))) {\r\nhard_local_irq_restore(flags);\r\nprintk(KERN_ERR\r\n"bfin-gpio: GPIO %d is already reserved as Peripheral by %s !\n",\r\ngpio, get_label(gpio));\r\nreturn -EBUSY;\r\n}\r\nreserve(special_gpio, gpio);\r\nreserve(peri, gpio);\r\nset_label(gpio, label);\r\nhard_local_irq_restore(flags);\r\nport_setup(gpio, GPIO_USAGE);\r\nreturn 0;\r\n}\r\nvoid bfin_special_gpio_free(unsigned gpio)\r\n{\r\nunsigned long flags;\r\nmight_sleep();\r\nflags = hard_local_irq_save();\r\nif (unlikely(!is_reserved(special_gpio, gpio, 0))) {\r\ngpio_error(gpio);\r\nhard_local_irq_restore(flags);\r\nreturn;\r\n}\r\nunreserve(special_gpio, gpio);\r\nunreserve(peri, gpio);\r\nset_label(gpio, "free");\r\nhard_local_irq_restore(flags);\r\n}\r\nint bfin_gpio_irq_request(unsigned gpio, const char *label)\r\n{\r\nunsigned long flags;\r\nif (check_gpio(gpio) < 0)\r\nreturn -EINVAL;\r\nflags = hard_local_irq_save();\r\nif (unlikely(is_reserved(peri, gpio, 1))) {\r\nif (system_state == SYSTEM_BOOTING)\r\ndump_stack();\r\nprintk(KERN_ERR\r\n"bfin-gpio: GPIO %d is already reserved as Peripheral by %s !\n",\r\ngpio, get_label(gpio));\r\nhard_local_irq_restore(flags);\r\nreturn -EBUSY;\r\n}\r\nif (unlikely(is_reserved(gpio, gpio, 1)))\r\nprintk(KERN_NOTICE "bfin-gpio: GPIO %d is already reserved by %s! "\r\n"(Documentation/blackfin/bfin-gpio-notes.txt)\n",\r\ngpio, get_label(gpio));\r\nreserve(gpio_irq, gpio);\r\nset_label(gpio, label);\r\nhard_local_irq_restore(flags);\r\nport_setup(gpio, GPIO_USAGE);\r\nreturn 0;\r\n}\r\nvoid bfin_gpio_irq_free(unsigned gpio)\r\n{\r\nunsigned long flags;\r\nif (check_gpio(gpio) < 0)\r\nreturn;\r\nflags = hard_local_irq_save();\r\nif (unlikely(!is_reserved(gpio_irq, gpio, 0))) {\r\nif (system_state == SYSTEM_BOOTING)\r\ndump_stack();\r\ngpio_error(gpio);\r\nhard_local_irq_restore(flags);\r\nreturn;\r\n}\r\nunreserve(gpio_irq, gpio);\r\nset_label(gpio, "free");\r\nhard_local_irq_restore(flags);\r\n}\r\nstatic inline void __bfin_gpio_direction_input(unsigned gpio)\r\n{\r\n#if defined(CONFIG_BF54x) || defined(CONFIG_BF60x)\r\ngpio_array[gpio_bank(gpio)]->dir_clear = gpio_bit(gpio);\r\n#else\r\ngpio_array[gpio_bank(gpio)]->dir &= ~gpio_bit(gpio);\r\n#endif\r\ngpio_array[gpio_bank(gpio)]->inen |= gpio_bit(gpio);\r\n}\r\nint bfin_gpio_direction_input(unsigned gpio)\r\n{\r\nunsigned long flags;\r\nif (unlikely(!is_reserved(gpio, gpio, 0))) {\r\ngpio_error(gpio);\r\nreturn -EINVAL;\r\n}\r\nflags = hard_local_irq_save();\r\n__bfin_gpio_direction_input(gpio);\r\nAWA_DUMMY_READ(inen);\r\nhard_local_irq_restore(flags);\r\nreturn 0;\r\n}\r\nvoid bfin_gpio_irq_prepare(unsigned gpio)\r\n{\r\n#if defined(CONFIG_BF54x) || defined(CONFIG_BF60x)\r\nunsigned long flags;\r\n#endif\r\nport_setup(gpio, GPIO_USAGE);\r\n#if defined(CONFIG_BF54x) || defined(CONFIG_BF60x)\r\nflags = hard_local_irq_save();\r\n__bfin_gpio_direction_input(gpio);\r\nhard_local_irq_restore(flags);\r\n#endif\r\n}\r\nvoid bfin_gpio_set_value(unsigned gpio, int arg)\r\n{\r\nif (arg)\r\ngpio_array[gpio_bank(gpio)]->data_set = gpio_bit(gpio);\r\nelse\r\ngpio_array[gpio_bank(gpio)]->data_clear = gpio_bit(gpio);\r\n}\r\nint bfin_gpio_direction_output(unsigned gpio, int value)\r\n{\r\nunsigned long flags;\r\nif (unlikely(!is_reserved(gpio, gpio, 0))) {\r\ngpio_error(gpio);\r\nreturn -EINVAL;\r\n}\r\nflags = hard_local_irq_save();\r\ngpio_array[gpio_bank(gpio)]->inen &= ~gpio_bit(gpio);\r\ngpio_set_value(gpio, value);\r\n#if defined(CONFIG_BF54x) || defined(CONFIG_BF60x)\r\ngpio_array[gpio_bank(gpio)]->dir_set = gpio_bit(gpio);\r\n#else\r\ngpio_array[gpio_bank(gpio)]->dir |= gpio_bit(gpio);\r\n#endif\r\nAWA_DUMMY_READ(dir);\r\nhard_local_irq_restore(flags);\r\nreturn 0;\r\n}\r\nint bfin_gpio_get_value(unsigned gpio)\r\n{\r\n#if defined(CONFIG_BF54x) || defined(CONFIG_BF60x)\r\nreturn (1 & (gpio_array[gpio_bank(gpio)]->data >> gpio_sub_n(gpio)));\r\n#else\r\nunsigned long flags;\r\nif (unlikely(get_gpio_edge(gpio))) {\r\nint ret;\r\nflags = hard_local_irq_save();\r\nset_gpio_edge(gpio, 0);\r\nret = get_gpio_data(gpio);\r\nset_gpio_edge(gpio, 1);\r\nhard_local_irq_restore(flags);\r\nreturn ret;\r\n} else\r\nreturn get_gpio_data(gpio);\r\n#endif\r\n}\r\nvoid bfin_reset_boot_spi_cs(unsigned short pin)\r\n{\r\nunsigned short gpio = P_IDENT(pin);\r\nport_setup(gpio, GPIO_USAGE);\r\ngpio_array[gpio_bank(gpio)]->data_set = gpio_bit(gpio);\r\nAWA_DUMMY_READ(data_set);\r\nudelay(1);\r\n}\r\nstatic int gpio_proc_show(struct seq_file *m, void *v)\r\n{\r\nint c, irq, gpio;\r\nfor (c = 0; c < MAX_RESOURCES; c++) {\r\nirq = is_reserved(gpio_irq, c, 1);\r\ngpio = is_reserved(gpio, c, 1);\r\nif (!check_gpio(c) && (gpio || irq))\r\nseq_printf(m, "GPIO_%d: \t%s%s \t\tGPIO %s\n", c,\r\nget_label(c), (gpio && irq) ? " *" : "",\r\nget_gpio_dir(c) ? "OUTPUT" : "INPUT");\r\nelse if (is_reserved(peri, c, 1))\r\nseq_printf(m, "GPIO_%d: \t%s \t\tPeripheral\n", c, get_label(c));\r\nelse\r\ncontinue;\r\n}\r\nreturn 0;\r\n}\r\nstatic int gpio_proc_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, gpio_proc_show, NULL);\r\n}\r\nstatic __init int gpio_register_proc(void)\r\n{\r\nstruct proc_dir_entry *proc_gpio;\r\nproc_gpio = proc_create("gpio", 0, NULL, &gpio_proc_ops);\r\nreturn proc_gpio == NULL;\r\n}\r\nstatic int bfin_gpiolib_direction_input(struct gpio_chip *chip, unsigned gpio)\r\n{\r\nreturn bfin_gpio_direction_input(gpio);\r\n}\r\nstatic int bfin_gpiolib_direction_output(struct gpio_chip *chip, unsigned gpio, int level)\r\n{\r\nreturn bfin_gpio_direction_output(gpio, level);\r\n}\r\nstatic int bfin_gpiolib_get_value(struct gpio_chip *chip, unsigned gpio)\r\n{\r\nreturn bfin_gpio_get_value(gpio);\r\n}\r\nstatic void bfin_gpiolib_set_value(struct gpio_chip *chip, unsigned gpio, int value)\r\n{\r\nreturn bfin_gpio_set_value(gpio, value);\r\n}\r\nstatic int bfin_gpiolib_gpio_request(struct gpio_chip *chip, unsigned gpio)\r\n{\r\nreturn bfin_gpio_request(gpio, chip->label);\r\n}\r\nstatic void bfin_gpiolib_gpio_free(struct gpio_chip *chip, unsigned gpio)\r\n{\r\nreturn bfin_gpio_free(gpio);\r\n}\r\nstatic int bfin_gpiolib_gpio_to_irq(struct gpio_chip *chip, unsigned gpio)\r\n{\r\nreturn gpio + GPIO_IRQ_BASE;\r\n}\r\nstatic int __init bfin_gpiolib_setup(void)\r\n{\r\nreturn gpiochip_add(&bfin_chip);\r\n}
