static int lpc32xx_rtc_read_time(struct device *dev, struct rtc_time *time)\r\n{\r\nunsigned long elapsed_sec;\r\nstruct lpc32xx_rtc *rtc = dev_get_drvdata(dev);\r\nelapsed_sec = rtc_readl(rtc, LPC32XX_RTC_UCOUNT);\r\nrtc_time_to_tm(elapsed_sec, time);\r\nreturn rtc_valid_tm(time);\r\n}\r\nstatic int lpc32xx_rtc_set_mmss(struct device *dev, unsigned long secs)\r\n{\r\nstruct lpc32xx_rtc *rtc = dev_get_drvdata(dev);\r\nu32 tmp;\r\nspin_lock_irq(&rtc->lock);\r\ntmp = rtc_readl(rtc, LPC32XX_RTC_CTRL);\r\nrtc_writel(rtc, LPC32XX_RTC_CTRL, tmp | LPC32XX_RTC_CTRL_CNTR_DIS);\r\nrtc_writel(rtc, LPC32XX_RTC_UCOUNT, secs);\r\nrtc_writel(rtc, LPC32XX_RTC_DCOUNT, 0xFFFFFFFF - secs);\r\nrtc_writel(rtc, LPC32XX_RTC_CTRL, tmp &= ~LPC32XX_RTC_CTRL_CNTR_DIS);\r\nspin_unlock_irq(&rtc->lock);\r\nreturn 0;\r\n}\r\nstatic int lpc32xx_rtc_read_alarm(struct device *dev,\r\nstruct rtc_wkalrm *wkalrm)\r\n{\r\nstruct lpc32xx_rtc *rtc = dev_get_drvdata(dev);\r\nrtc_time_to_tm(rtc_readl(rtc, LPC32XX_RTC_MATCH0), &wkalrm->time);\r\nwkalrm->enabled = rtc->alarm_enabled;\r\nwkalrm->pending = !!(rtc_readl(rtc, LPC32XX_RTC_INTSTAT) &\r\nLPC32XX_RTC_INTSTAT_MATCH0);\r\nreturn rtc_valid_tm(&wkalrm->time);\r\n}\r\nstatic int lpc32xx_rtc_set_alarm(struct device *dev,\r\nstruct rtc_wkalrm *wkalrm)\r\n{\r\nstruct lpc32xx_rtc *rtc = dev_get_drvdata(dev);\r\nunsigned long alarmsecs;\r\nu32 tmp;\r\nint ret;\r\nret = rtc_tm_to_time(&wkalrm->time, &alarmsecs);\r\nif (ret < 0) {\r\ndev_warn(dev, "Failed to convert time: %d\n", ret);\r\nreturn ret;\r\n}\r\nspin_lock_irq(&rtc->lock);\r\ntmp = rtc_readl(rtc, LPC32XX_RTC_CTRL);\r\nrtc_writel(rtc, LPC32XX_RTC_CTRL, tmp & ~LPC32XX_RTC_CTRL_MATCH0);\r\nrtc_writel(rtc, LPC32XX_RTC_MATCH0, alarmsecs);\r\nrtc->alarm_enabled = wkalrm->enabled;\r\nif (wkalrm->enabled) {\r\nrtc_writel(rtc, LPC32XX_RTC_INTSTAT,\r\nLPC32XX_RTC_INTSTAT_MATCH0);\r\nrtc_writel(rtc, LPC32XX_RTC_CTRL, tmp |\r\nLPC32XX_RTC_CTRL_MATCH0);\r\n}\r\nspin_unlock_irq(&rtc->lock);\r\nreturn 0;\r\n}\r\nstatic int lpc32xx_rtc_alarm_irq_enable(struct device *dev,\r\nunsigned int enabled)\r\n{\r\nstruct lpc32xx_rtc *rtc = dev_get_drvdata(dev);\r\nu32 tmp;\r\nspin_lock_irq(&rtc->lock);\r\ntmp = rtc_readl(rtc, LPC32XX_RTC_CTRL);\r\nif (enabled) {\r\nrtc->alarm_enabled = 1;\r\ntmp |= LPC32XX_RTC_CTRL_MATCH0;\r\n} else {\r\nrtc->alarm_enabled = 0;\r\ntmp &= ~LPC32XX_RTC_CTRL_MATCH0;\r\n}\r\nrtc_writel(rtc, LPC32XX_RTC_CTRL, tmp);\r\nspin_unlock_irq(&rtc->lock);\r\nreturn 0;\r\n}\r\nstatic irqreturn_t lpc32xx_rtc_alarm_interrupt(int irq, void *dev)\r\n{\r\nstruct lpc32xx_rtc *rtc = dev;\r\nspin_lock(&rtc->lock);\r\nrtc_writel(rtc, LPC32XX_RTC_CTRL,\r\nrtc_readl(rtc, LPC32XX_RTC_CTRL) &\r\n~LPC32XX_RTC_CTRL_MATCH0);\r\nrtc->alarm_enabled = 0;\r\nrtc_writel(rtc, LPC32XX_RTC_MATCH0, 0xFFFFFFFF);\r\nrtc_writel(rtc, LPC32XX_RTC_INTSTAT, LPC32XX_RTC_INTSTAT_MATCH0);\r\nspin_unlock(&rtc->lock);\r\nrtc_update_irq(rtc->rtc, 1, RTC_IRQF | RTC_AF);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int lpc32xx_rtc_probe(struct platform_device *pdev)\r\n{\r\nstruct resource *res;\r\nstruct lpc32xx_rtc *rtc;\r\nresource_size_t size;\r\nint rtcirq;\r\nu32 tmp;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!res) {\r\ndev_err(&pdev->dev, "Can't get memory resource\n");\r\nreturn -ENOENT;\r\n}\r\nrtcirq = platform_get_irq(pdev, 0);\r\nif (rtcirq < 0 || rtcirq >= NR_IRQS) {\r\ndev_warn(&pdev->dev, "Can't get interrupt resource\n");\r\nrtcirq = -1;\r\n}\r\nrtc = devm_kzalloc(&pdev->dev, sizeof(*rtc), GFP_KERNEL);\r\nif (unlikely(!rtc)) {\r\ndev_err(&pdev->dev, "Can't allocate memory\n");\r\nreturn -ENOMEM;\r\n}\r\nrtc->irq = rtcirq;\r\nsize = resource_size(res);\r\nif (!devm_request_mem_region(&pdev->dev, res->start, size,\r\npdev->name)) {\r\ndev_err(&pdev->dev, "RTC registers are not free\n");\r\nreturn -EBUSY;\r\n}\r\nrtc->rtc_base = devm_ioremap(&pdev->dev, res->start, size);\r\nif (!rtc->rtc_base) {\r\ndev_err(&pdev->dev, "Can't map memory\n");\r\nreturn -ENOMEM;\r\n}\r\nspin_lock_init(&rtc->lock);\r\ntmp = rtc_readl(rtc, LPC32XX_RTC_CTRL);\r\nif (rtc_readl(rtc, LPC32XX_RTC_KEY) != LPC32XX_RTC_KEY_ONSW_LOADVAL) {\r\ntmp &= ~(LPC32XX_RTC_CTRL_SW_RESET |\r\nLPC32XX_RTC_CTRL_CNTR_DIS |\r\nLPC32XX_RTC_CTRL_MATCH0 |\r\nLPC32XX_RTC_CTRL_MATCH1 |\r\nLPC32XX_RTC_CTRL_ONSW_MATCH0 |\r\nLPC32XX_RTC_CTRL_ONSW_MATCH1 |\r\nLPC32XX_RTC_CTRL_ONSW_FORCE_HI);\r\nrtc_writel(rtc, LPC32XX_RTC_CTRL, tmp);\r\nrtc_writel(rtc, LPC32XX_RTC_MATCH0, 0xFFFFFFFF);\r\nrtc_writel(rtc, LPC32XX_RTC_INTSTAT,\r\nLPC32XX_RTC_INTSTAT_MATCH0 |\r\nLPC32XX_RTC_INTSTAT_MATCH1 |\r\nLPC32XX_RTC_INTSTAT_ONSW);\r\nrtc_writel(rtc, LPC32XX_RTC_KEY,\r\nLPC32XX_RTC_KEY_ONSW_LOADVAL);\r\n} else {\r\nrtc_writel(rtc, LPC32XX_RTC_CTRL,\r\ntmp & ~LPC32XX_RTC_CTRL_MATCH0);\r\n}\r\nplatform_set_drvdata(pdev, rtc);\r\nrtc->rtc = rtc_device_register(RTC_NAME, &pdev->dev, &lpc32xx_rtc_ops,\r\nTHIS_MODULE);\r\nif (IS_ERR(rtc->rtc)) {\r\ndev_err(&pdev->dev, "Can't get RTC\n");\r\nplatform_set_drvdata(pdev, NULL);\r\nreturn PTR_ERR(rtc->rtc);\r\n}\r\nif (rtc->irq >= 0) {\r\nif (devm_request_irq(&pdev->dev, rtc->irq,\r\nlpc32xx_rtc_alarm_interrupt,\r\n0, pdev->name, rtc) < 0) {\r\ndev_warn(&pdev->dev, "Can't request interrupt.\n");\r\nrtc->irq = -1;\r\n} else {\r\ndevice_init_wakeup(&pdev->dev, 1);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int lpc32xx_rtc_remove(struct platform_device *pdev)\r\n{\r\nstruct lpc32xx_rtc *rtc = platform_get_drvdata(pdev);\r\nif (rtc->irq >= 0)\r\ndevice_init_wakeup(&pdev->dev, 0);\r\nplatform_set_drvdata(pdev, NULL);\r\nrtc_device_unregister(rtc->rtc);\r\nreturn 0;\r\n}\r\nstatic int lpc32xx_rtc_suspend(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct lpc32xx_rtc *rtc = platform_get_drvdata(pdev);\r\nif (rtc->irq >= 0) {\r\nif (device_may_wakeup(&pdev->dev))\r\nenable_irq_wake(rtc->irq);\r\nelse\r\ndisable_irq_wake(rtc->irq);\r\n}\r\nreturn 0;\r\n}\r\nstatic int lpc32xx_rtc_resume(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct lpc32xx_rtc *rtc = platform_get_drvdata(pdev);\r\nif (rtc->irq >= 0 && device_may_wakeup(&pdev->dev))\r\ndisable_irq_wake(rtc->irq);\r\nreturn 0;\r\n}\r\nstatic int lpc32xx_rtc_freeze(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct lpc32xx_rtc *rtc = platform_get_drvdata(pdev);\r\nspin_lock_irq(&rtc->lock);\r\nrtc_writel(rtc, LPC32XX_RTC_CTRL,\r\nrtc_readl(rtc, LPC32XX_RTC_CTRL) &\r\n~LPC32XX_RTC_CTRL_MATCH0);\r\nspin_unlock_irq(&rtc->lock);\r\nreturn 0;\r\n}\r\nstatic int lpc32xx_rtc_thaw(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct lpc32xx_rtc *rtc = platform_get_drvdata(pdev);\r\nif (rtc->alarm_enabled) {\r\nspin_lock_irq(&rtc->lock);\r\nrtc_writel(rtc, LPC32XX_RTC_CTRL,\r\nrtc_readl(rtc, LPC32XX_RTC_CTRL) |\r\nLPC32XX_RTC_CTRL_MATCH0);\r\nspin_unlock_irq(&rtc->lock);\r\n}\r\nreturn 0;\r\n}
