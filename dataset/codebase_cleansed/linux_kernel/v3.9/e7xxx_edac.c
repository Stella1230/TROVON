static inline int e7xxx_find_channel(u16 syndrome)\r\n{\r\nedac_dbg(3, "\n");\r\nif ((syndrome & 0xff00) == 0)\r\nreturn 0;\r\nif ((syndrome & 0x00ff) == 0)\r\nreturn 1;\r\nif ((syndrome & 0xf000) == 0 || (syndrome & 0x0f00) == 0)\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic unsigned long ctl_page_to_phys(struct mem_ctl_info *mci,\r\nunsigned long page)\r\n{\r\nu32 remap;\r\nstruct e7xxx_pvt *pvt = (struct e7xxx_pvt *)mci->pvt_info;\r\nedac_dbg(3, "\n");\r\nif ((page < pvt->tolm) ||\r\n((page >= 0x100000) && (page < pvt->remapbase)))\r\nreturn page;\r\nremap = (page - pvt->tolm) + pvt->remapbase;\r\nif (remap < pvt->remaplimit)\r\nreturn remap;\r\ne7xxx_printk(KERN_ERR, "Invalid page %lx - out of range\n", page);\r\nreturn pvt->tolm - 1;\r\n}\r\nstatic void process_ce(struct mem_ctl_info *mci, struct e7xxx_error_info *info)\r\n{\r\nu32 error_1b, page;\r\nu16 syndrome;\r\nint row;\r\nint channel;\r\nedac_dbg(3, "\n");\r\nerror_1b = info->dram_celog_add;\r\npage = error_1b >> 6;\r\nsyndrome = info->dram_celog_syndrome;\r\nrow = edac_mc_find_csrow_by_page(mci, page);\r\nchannel = e7xxx_find_channel(syndrome);\r\nedac_mc_handle_error(HW_EVENT_ERR_CORRECTED, mci, 1, page, 0, syndrome,\r\nrow, channel, -1, "e7xxx CE", "");\r\n}\r\nstatic void process_ce_no_info(struct mem_ctl_info *mci)\r\n{\r\nedac_dbg(3, "\n");\r\nedac_mc_handle_error(HW_EVENT_ERR_UNCORRECTED, mci, 1, 0, 0, 0, -1, -1, -1,\r\n"e7xxx CE log register overflow", "");\r\n}\r\nstatic void process_ue(struct mem_ctl_info *mci, struct e7xxx_error_info *info)\r\n{\r\nu32 error_2b, block_page;\r\nint row;\r\nedac_dbg(3, "\n");\r\nerror_2b = info->dram_uelog_add;\r\nblock_page = error_2b >> 6;\r\nrow = edac_mc_find_csrow_by_page(mci, block_page);\r\nedac_mc_handle_error(HW_EVENT_ERR_UNCORRECTED, mci, 1, block_page, 0, 0,\r\nrow, -1, -1, "e7xxx UE", "");\r\n}\r\nstatic void process_ue_no_info(struct mem_ctl_info *mci)\r\n{\r\nedac_dbg(3, "\n");\r\nedac_mc_handle_error(HW_EVENT_ERR_UNCORRECTED, mci, 1, 0, 0, 0, -1, -1, -1,\r\n"e7xxx UE log register overflow", "");\r\n}\r\nstatic void e7xxx_get_error_info(struct mem_ctl_info *mci,\r\nstruct e7xxx_error_info *info)\r\n{\r\nstruct e7xxx_pvt *pvt;\r\npvt = (struct e7xxx_pvt *)mci->pvt_info;\r\npci_read_config_byte(pvt->bridge_ck, E7XXX_DRAM_FERR, &info->dram_ferr);\r\npci_read_config_byte(pvt->bridge_ck, E7XXX_DRAM_NERR, &info->dram_nerr);\r\nif ((info->dram_ferr & 1) || (info->dram_nerr & 1)) {\r\npci_read_config_dword(pvt->bridge_ck, E7XXX_DRAM_CELOG_ADD,\r\n&info->dram_celog_add);\r\npci_read_config_word(pvt->bridge_ck,\r\nE7XXX_DRAM_CELOG_SYNDROME,\r\n&info->dram_celog_syndrome);\r\n}\r\nif ((info->dram_ferr & 2) || (info->dram_nerr & 2))\r\npci_read_config_dword(pvt->bridge_ck, E7XXX_DRAM_UELOG_ADD,\r\n&info->dram_uelog_add);\r\nif (info->dram_ferr & 3)\r\npci_write_bits8(pvt->bridge_ck, E7XXX_DRAM_FERR, 0x03, 0x03);\r\nif (info->dram_nerr & 3)\r\npci_write_bits8(pvt->bridge_ck, E7XXX_DRAM_NERR, 0x03, 0x03);\r\n}\r\nstatic int e7xxx_process_error_info(struct mem_ctl_info *mci,\r\nstruct e7xxx_error_info *info,\r\nint handle_errors)\r\n{\r\nint error_found;\r\nerror_found = 0;\r\nif (info->dram_ferr & 1) {\r\nerror_found = 1;\r\nif (handle_errors)\r\nprocess_ce(mci, info);\r\n}\r\nif (info->dram_ferr & 2) {\r\nerror_found = 1;\r\nif (handle_errors)\r\nprocess_ue(mci, info);\r\n}\r\nif (info->dram_nerr & 1) {\r\nerror_found = 1;\r\nif (handle_errors) {\r\nif (info->dram_ferr & 1)\r\nprocess_ce_no_info(mci);\r\nelse\r\nprocess_ce(mci, info);\r\n}\r\n}\r\nif (info->dram_nerr & 2) {\r\nerror_found = 1;\r\nif (handle_errors) {\r\nif (info->dram_ferr & 2)\r\nprocess_ue_no_info(mci);\r\nelse\r\nprocess_ue(mci, info);\r\n}\r\n}\r\nreturn error_found;\r\n}\r\nstatic void e7xxx_check(struct mem_ctl_info *mci)\r\n{\r\nstruct e7xxx_error_info info;\r\nedac_dbg(3, "\n");\r\ne7xxx_get_error_info(mci, &info);\r\ne7xxx_process_error_info(mci, &info, 1);\r\n}\r\nstatic inline int dual_channel_active(u32 drc, int dev_idx)\r\n{\r\nreturn (dev_idx == E7501) ? ((drc >> 22) & 0x1) : 1;\r\n}\r\nstatic inline int drb_granularity(u32 drc, int dev_idx)\r\n{\r\nreturn (dev_idx == E7501) ? ((drc >> 18) & 0x3) : 1;\r\n}\r\nstatic void e7xxx_init_csrows(struct mem_ctl_info *mci, struct pci_dev *pdev,\r\nint dev_idx, u32 drc)\r\n{\r\nunsigned long last_cumul_size;\r\nint index, j;\r\nu8 value;\r\nu32 dra, cumul_size, nr_pages;\r\nint drc_chan, drc_drbg, drc_ddim, mem_dev;\r\nstruct csrow_info *csrow;\r\nstruct dimm_info *dimm;\r\nenum edac_type edac_mode;\r\npci_read_config_dword(pdev, E7XXX_DRA, &dra);\r\ndrc_chan = dual_channel_active(drc, dev_idx);\r\ndrc_drbg = drb_granularity(drc, dev_idx);\r\ndrc_ddim = (drc >> 20) & 0x3;\r\nlast_cumul_size = 0;\r\nfor (index = 0; index < mci->nr_csrows; index++) {\r\nmem_dev = (dra >> (index * 4 + 3)) & 0x1;\r\ncsrow = mci->csrows[index];\r\npci_read_config_byte(pdev, E7XXX_DRB + index, &value);\r\ncumul_size = value << (25 + drc_drbg - PAGE_SHIFT);\r\nedac_dbg(3, "(%d) cumul_size 0x%x\n", index, cumul_size);\r\nif (cumul_size == last_cumul_size)\r\ncontinue;\r\ncsrow->first_page = last_cumul_size;\r\ncsrow->last_page = cumul_size - 1;\r\nnr_pages = cumul_size - last_cumul_size;\r\nlast_cumul_size = cumul_size;\r\nif (drc_ddim) {\r\nif (drc_chan && mem_dev) {\r\nedac_mode = EDAC_S4ECD4ED;\r\nmci->edac_cap |= EDAC_FLAG_S4ECD4ED;\r\n} else {\r\nedac_mode = EDAC_SECDED;\r\nmci->edac_cap |= EDAC_FLAG_SECDED;\r\n}\r\n} else\r\nedac_mode = EDAC_NONE;\r\nfor (j = 0; j < drc_chan + 1; j++) {\r\ndimm = csrow->channels[j]->dimm;\r\ndimm->nr_pages = nr_pages / (drc_chan + 1);\r\ndimm->grain = 1 << 12;\r\ndimm->mtype = MEM_RDDR;\r\ndimm->dtype = mem_dev ? DEV_X4 : DEV_X8;\r\ndimm->edac_mode = edac_mode;\r\n}\r\n}\r\n}\r\nstatic int e7xxx_probe1(struct pci_dev *pdev, int dev_idx)\r\n{\r\nu16 pci_data;\r\nstruct mem_ctl_info *mci = NULL;\r\nstruct edac_mc_layer layers[2];\r\nstruct e7xxx_pvt *pvt = NULL;\r\nu32 drc;\r\nint drc_chan;\r\nstruct e7xxx_error_info discard;\r\nedac_dbg(0, "mci\n");\r\npci_read_config_dword(pdev, E7XXX_DRC, &drc);\r\ndrc_chan = dual_channel_active(drc, dev_idx);\r\nlayers[0].type = EDAC_MC_LAYER_CHIP_SELECT;\r\nlayers[0].size = E7XXX_NR_CSROWS;\r\nlayers[0].is_virt_csrow = true;\r\nlayers[1].type = EDAC_MC_LAYER_CHANNEL;\r\nlayers[1].size = drc_chan + 1;\r\nlayers[1].is_virt_csrow = false;\r\nmci = edac_mc_alloc(0, ARRAY_SIZE(layers), layers, sizeof(*pvt));\r\nif (mci == NULL)\r\nreturn -ENOMEM;\r\nedac_dbg(3, "init mci\n");\r\nmci->mtype_cap = MEM_FLAG_RDDR;\r\nmci->edac_ctl_cap = EDAC_FLAG_NONE | EDAC_FLAG_SECDED |\r\nEDAC_FLAG_S4ECD4ED;\r\nmci->mod_name = EDAC_MOD_STR;\r\nmci->mod_ver = E7XXX_REVISION;\r\nmci->pdev = &pdev->dev;\r\nedac_dbg(3, "init pvt\n");\r\npvt = (struct e7xxx_pvt *)mci->pvt_info;\r\npvt->dev_info = &e7xxx_devs[dev_idx];\r\npvt->bridge_ck = pci_get_device(PCI_VENDOR_ID_INTEL,\r\npvt->dev_info->err_dev, pvt->bridge_ck);\r\nif (!pvt->bridge_ck) {\r\ne7xxx_printk(KERN_ERR, "error reporting device not found:"\r\n"vendor %x device 0x%x (broken BIOS?)\n",\r\nPCI_VENDOR_ID_INTEL, e7xxx_devs[dev_idx].err_dev);\r\ngoto fail0;\r\n}\r\nedac_dbg(3, "more mci init\n");\r\nmci->ctl_name = pvt->dev_info->ctl_name;\r\nmci->dev_name = pci_name(pdev);\r\nmci->edac_check = e7xxx_check;\r\nmci->ctl_page_to_phys = ctl_page_to_phys;\r\ne7xxx_init_csrows(mci, pdev, dev_idx, drc);\r\nmci->edac_cap |= EDAC_FLAG_NONE;\r\nedac_dbg(3, "tolm, remapbase, remaplimit\n");\r\npci_read_config_word(pdev, E7XXX_TOLM, &pci_data);\r\npvt->tolm = ((u32) pci_data) << 4;\r\npci_read_config_word(pdev, E7XXX_REMAPBASE, &pci_data);\r\npvt->remapbase = ((u32) pci_data) << 14;\r\npci_read_config_word(pdev, E7XXX_REMAPLIMIT, &pci_data);\r\npvt->remaplimit = ((u32) pci_data) << 14;\r\ne7xxx_printk(KERN_INFO,\r\n"tolm = %x, remapbase = %x, remaplimit = %x\n", pvt->tolm,\r\npvt->remapbase, pvt->remaplimit);\r\ne7xxx_get_error_info(mci, &discard);\r\nif (edac_mc_add_mc(mci)) {\r\nedac_dbg(3, "failed edac_mc_add_mc()\n");\r\ngoto fail1;\r\n}\r\ne7xxx_pci = edac_pci_create_generic_ctl(&pdev->dev, EDAC_MOD_STR);\r\nif (!e7xxx_pci) {\r\nprintk(KERN_WARNING\r\n"%s(): Unable to create PCI control\n",\r\n__func__);\r\nprintk(KERN_WARNING\r\n"%s(): PCI error report via EDAC not setup\n",\r\n__func__);\r\n}\r\nedac_dbg(3, "success\n");\r\nreturn 0;\r\nfail1:\r\npci_dev_put(pvt->bridge_ck);\r\nfail0:\r\nedac_mc_free(mci);\r\nreturn -ENODEV;\r\n}\r\nstatic int e7xxx_init_one(struct pci_dev *pdev, const struct pci_device_id *ent)\r\n{\r\nedac_dbg(0, "\n");\r\nreturn pci_enable_device(pdev) ?\r\n-EIO : e7xxx_probe1(pdev, ent->driver_data);\r\n}\r\nstatic void e7xxx_remove_one(struct pci_dev *pdev)\r\n{\r\nstruct mem_ctl_info *mci;\r\nstruct e7xxx_pvt *pvt;\r\nedac_dbg(0, "\n");\r\nif (e7xxx_pci)\r\nedac_pci_release_generic_ctl(e7xxx_pci);\r\nif ((mci = edac_mc_del_mc(&pdev->dev)) == NULL)\r\nreturn;\r\npvt = (struct e7xxx_pvt *)mci->pvt_info;\r\npci_dev_put(pvt->bridge_ck);\r\nedac_mc_free(mci);\r\n}\r\nstatic int __init e7xxx_init(void)\r\n{\r\nopstate_init();\r\nreturn pci_register_driver(&e7xxx_driver);\r\n}\r\nstatic void __exit e7xxx_exit(void)\r\n{\r\npci_unregister_driver(&e7xxx_driver);\r\n}
