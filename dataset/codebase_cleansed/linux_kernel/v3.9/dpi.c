static struct platform_device *dpi_get_dsidev(enum omap_channel channel)\r\n{\r\nswitch (omapdss_get_version()) {\r\ncase OMAPDSS_VER_OMAP24xx:\r\ncase OMAPDSS_VER_OMAP34xx_ES1:\r\ncase OMAPDSS_VER_OMAP34xx_ES3:\r\ncase OMAPDSS_VER_OMAP3630:\r\ncase OMAPDSS_VER_AM35xx:\r\nreturn NULL;\r\ndefault:\r\nbreak;\r\n}\r\nswitch (channel) {\r\ncase OMAP_DSS_CHANNEL_LCD:\r\nreturn dsi_get_dsidev_from_id(0);\r\ncase OMAP_DSS_CHANNEL_LCD2:\r\nreturn dsi_get_dsidev_from_id(1);\r\ndefault:\r\nreturn NULL;\r\n}\r\n}\r\nstatic enum omap_dss_clk_source dpi_get_alt_clk_src(enum omap_channel channel)\r\n{\r\nswitch (channel) {\r\ncase OMAP_DSS_CHANNEL_LCD:\r\nreturn OMAP_DSS_CLK_SRC_DSI_PLL_HSDIV_DISPC;\r\ncase OMAP_DSS_CHANNEL_LCD2:\r\nreturn OMAP_DSS_CLK_SRC_DSI2_PLL_HSDIV_DISPC;\r\ndefault:\r\nWARN_ON(1);\r\nreturn OMAP_DSS_CLK_SRC_FCK;\r\n}\r\n}\r\nstatic int dpi_set_dsi_clk(struct omap_dss_device *dssdev,\r\nunsigned long pck_req, unsigned long *fck, int *lck_div,\r\nint *pck_div)\r\n{\r\nstruct omap_overlay_manager *mgr = dssdev->output->manager;\r\nstruct dsi_clock_info dsi_cinfo;\r\nstruct dispc_clock_info dispc_cinfo;\r\nint r;\r\nr = dsi_pll_calc_clock_div_pck(dpi.dsidev, pck_req, &dsi_cinfo,\r\n&dispc_cinfo);\r\nif (r)\r\nreturn r;\r\nr = dsi_pll_set_clock_div(dpi.dsidev, &dsi_cinfo);\r\nif (r)\r\nreturn r;\r\ndss_select_lcd_clk_source(mgr->id,\r\ndpi_get_alt_clk_src(mgr->id));\r\ndpi.mgr_config.clock_info = dispc_cinfo;\r\n*fck = dsi_cinfo.dsi_pll_hsdiv_dispc_clk;\r\n*lck_div = dispc_cinfo.lck_div;\r\n*pck_div = dispc_cinfo.pck_div;\r\nreturn 0;\r\n}\r\nstatic int dpi_set_dispc_clk(struct omap_dss_device *dssdev,\r\nunsigned long pck_req, unsigned long *fck, int *lck_div,\r\nint *pck_div)\r\n{\r\nstruct dss_clock_info dss_cinfo;\r\nstruct dispc_clock_info dispc_cinfo;\r\nint r;\r\nr = dss_calc_clock_div(pck_req, &dss_cinfo, &dispc_cinfo);\r\nif (r)\r\nreturn r;\r\nr = dss_set_clock_div(&dss_cinfo);\r\nif (r)\r\nreturn r;\r\ndpi.mgr_config.clock_info = dispc_cinfo;\r\n*fck = dss_cinfo.fck;\r\n*lck_div = dispc_cinfo.lck_div;\r\n*pck_div = dispc_cinfo.pck_div;\r\nreturn 0;\r\n}\r\nstatic int dpi_set_mode(struct omap_dss_device *dssdev)\r\n{\r\nstruct omap_video_timings *t = &dpi.timings;\r\nstruct omap_overlay_manager *mgr = dssdev->output->manager;\r\nint lck_div = 0, pck_div = 0;\r\nunsigned long fck = 0;\r\nunsigned long pck;\r\nint r = 0;\r\nif (dpi.dsidev)\r\nr = dpi_set_dsi_clk(dssdev, t->pixel_clock * 1000, &fck,\r\n&lck_div, &pck_div);\r\nelse\r\nr = dpi_set_dispc_clk(dssdev, t->pixel_clock * 1000, &fck,\r\n&lck_div, &pck_div);\r\nif (r)\r\nreturn r;\r\npck = fck / lck_div / pck_div / 1000;\r\nif (pck != t->pixel_clock) {\r\nDSSWARN("Could not find exact pixel clock. "\r\n"Requested %d kHz, got %lu kHz\n",\r\nt->pixel_clock, pck);\r\nt->pixel_clock = pck;\r\n}\r\ndss_mgr_set_timings(mgr, t);\r\nreturn 0;\r\n}\r\nstatic void dpi_config_lcd_manager(struct omap_dss_device *dssdev)\r\n{\r\nstruct omap_overlay_manager *mgr = dssdev->output->manager;\r\ndpi.mgr_config.io_pad_mode = DSS_IO_PAD_MODE_BYPASS;\r\ndpi.mgr_config.stallmode = false;\r\ndpi.mgr_config.fifohandcheck = false;\r\ndpi.mgr_config.video_port_width = dpi.data_lines;\r\ndpi.mgr_config.lcden_sig_polarity = 0;\r\ndss_mgr_set_lcd_config(mgr, &dpi.mgr_config);\r\n}\r\nint omapdss_dpi_display_enable(struct omap_dss_device *dssdev)\r\n{\r\nstruct omap_dss_output *out = dssdev->output;\r\nint r;\r\nmutex_lock(&dpi.lock);\r\nif (dss_has_feature(FEAT_DPI_USES_VDDS_DSI) && !dpi.vdds_dsi_reg) {\r\nDSSERR("no VDSS_DSI regulator\n");\r\nr = -ENODEV;\r\ngoto err_no_reg;\r\n}\r\nif (out == NULL || out->manager == NULL) {\r\nDSSERR("failed to enable display: no output/manager\n");\r\nr = -ENODEV;\r\ngoto err_no_out_mgr;\r\n}\r\nr = omap_dss_start_device(dssdev);\r\nif (r) {\r\nDSSERR("failed to start device\n");\r\ngoto err_start_dev;\r\n}\r\nif (dss_has_feature(FEAT_DPI_USES_VDDS_DSI)) {\r\nr = regulator_enable(dpi.vdds_dsi_reg);\r\nif (r)\r\ngoto err_reg_enable;\r\n}\r\nr = dispc_runtime_get();\r\nif (r)\r\ngoto err_get_dispc;\r\nr = dss_dpi_select_source(dssdev->channel);\r\nif (r)\r\ngoto err_src_sel;\r\nif (dpi.dsidev) {\r\nr = dsi_runtime_get(dpi.dsidev);\r\nif (r)\r\ngoto err_get_dsi;\r\nr = dsi_pll_init(dpi.dsidev, 0, 1);\r\nif (r)\r\ngoto err_dsi_pll_init;\r\n}\r\nr = dpi_set_mode(dssdev);\r\nif (r)\r\ngoto err_set_mode;\r\ndpi_config_lcd_manager(dssdev);\r\nmdelay(2);\r\nr = dss_mgr_enable(out->manager);\r\nif (r)\r\ngoto err_mgr_enable;\r\nmutex_unlock(&dpi.lock);\r\nreturn 0;\r\nerr_mgr_enable:\r\nerr_set_mode:\r\nif (dpi.dsidev)\r\ndsi_pll_uninit(dpi.dsidev, true);\r\nerr_dsi_pll_init:\r\nif (dpi.dsidev)\r\ndsi_runtime_put(dpi.dsidev);\r\nerr_get_dsi:\r\nerr_src_sel:\r\ndispc_runtime_put();\r\nerr_get_dispc:\r\nif (dss_has_feature(FEAT_DPI_USES_VDDS_DSI))\r\nregulator_disable(dpi.vdds_dsi_reg);\r\nerr_reg_enable:\r\nomap_dss_stop_device(dssdev);\r\nerr_start_dev:\r\nerr_no_out_mgr:\r\nerr_no_reg:\r\nmutex_unlock(&dpi.lock);\r\nreturn r;\r\n}\r\nvoid omapdss_dpi_display_disable(struct omap_dss_device *dssdev)\r\n{\r\nstruct omap_overlay_manager *mgr = dssdev->output->manager;\r\nmutex_lock(&dpi.lock);\r\ndss_mgr_disable(mgr);\r\nif (dpi.dsidev) {\r\ndss_select_lcd_clk_source(mgr->id, OMAP_DSS_CLK_SRC_FCK);\r\ndsi_pll_uninit(dpi.dsidev, true);\r\ndsi_runtime_put(dpi.dsidev);\r\n}\r\ndispc_runtime_put();\r\nif (dss_has_feature(FEAT_DPI_USES_VDDS_DSI))\r\nregulator_disable(dpi.vdds_dsi_reg);\r\nomap_dss_stop_device(dssdev);\r\nmutex_unlock(&dpi.lock);\r\n}\r\nvoid omapdss_dpi_set_timings(struct omap_dss_device *dssdev,\r\nstruct omap_video_timings *timings)\r\n{\r\nDSSDBG("dpi_set_timings\n");\r\nmutex_lock(&dpi.lock);\r\ndpi.timings = *timings;\r\nmutex_unlock(&dpi.lock);\r\n}\r\nint dpi_check_timings(struct omap_dss_device *dssdev,\r\nstruct omap_video_timings *timings)\r\n{\r\nint r;\r\nstruct omap_overlay_manager *mgr = dssdev->output->manager;\r\nint lck_div, pck_div;\r\nunsigned long fck;\r\nunsigned long pck;\r\nstruct dispc_clock_info dispc_cinfo;\r\nif (mgr && !dispc_mgr_timings_ok(mgr->id, timings))\r\nreturn -EINVAL;\r\nif (timings->pixel_clock == 0)\r\nreturn -EINVAL;\r\nif (dpi.dsidev) {\r\nstruct dsi_clock_info dsi_cinfo;\r\nr = dsi_pll_calc_clock_div_pck(dpi.dsidev,\r\ntimings->pixel_clock * 1000,\r\n&dsi_cinfo, &dispc_cinfo);\r\nif (r)\r\nreturn r;\r\nfck = dsi_cinfo.dsi_pll_hsdiv_dispc_clk;\r\n} else {\r\nstruct dss_clock_info dss_cinfo;\r\nr = dss_calc_clock_div(timings->pixel_clock * 1000,\r\n&dss_cinfo, &dispc_cinfo);\r\nif (r)\r\nreturn r;\r\nfck = dss_cinfo.fck;\r\n}\r\nlck_div = dispc_cinfo.lck_div;\r\npck_div = dispc_cinfo.pck_div;\r\npck = fck / lck_div / pck_div / 1000;\r\ntimings->pixel_clock = pck;\r\nreturn 0;\r\n}\r\nvoid omapdss_dpi_set_data_lines(struct omap_dss_device *dssdev, int data_lines)\r\n{\r\nmutex_lock(&dpi.lock);\r\ndpi.data_lines = data_lines;\r\nmutex_unlock(&dpi.lock);\r\n}\r\nstatic int __init dpi_verify_dsi_pll(struct platform_device *dsidev)\r\n{\r\nint r;\r\nr = dsi_runtime_get(dsidev);\r\nif (r)\r\nreturn r;\r\nr = dsi_pll_init(dsidev, 0, 1);\r\nif (r) {\r\ndsi_runtime_put(dsidev);\r\nreturn r;\r\n}\r\ndsi_pll_uninit(dsidev, true);\r\ndsi_runtime_put(dsidev);\r\nreturn 0;\r\n}\r\nstatic int __init dpi_init_display(struct omap_dss_device *dssdev)\r\n{\r\nstruct platform_device *dsidev;\r\nDSSDBG("init_display\n");\r\nif (dss_has_feature(FEAT_DPI_USES_VDDS_DSI) &&\r\ndpi.vdds_dsi_reg == NULL) {\r\nstruct regulator *vdds_dsi;\r\nvdds_dsi = dss_get_vdds_dsi();\r\nif (IS_ERR(vdds_dsi)) {\r\nDSSERR("can't get VDDS_DSI regulator\n");\r\nreturn PTR_ERR(vdds_dsi);\r\n}\r\ndpi.vdds_dsi_reg = vdds_dsi;\r\n}\r\ndsidev = dpi_get_dsidev(dssdev->channel);\r\nif (dsidev && dpi_verify_dsi_pll(dsidev)) {\r\ndsidev = NULL;\r\nDSSWARN("DSI PLL not operational\n");\r\n}\r\nif (dsidev)\r\nDSSDBG("using DSI PLL for DPI clock\n");\r\ndpi.dsidev = dsidev;\r\nreturn 0;\r\n}\r\nstatic struct omap_dss_device * __init dpi_find_dssdev(struct platform_device *pdev)\r\n{\r\nstruct omap_dss_board_info *pdata = pdev->dev.platform_data;\r\nconst char *def_disp_name = omapdss_get_default_display_name();\r\nstruct omap_dss_device *def_dssdev;\r\nint i;\r\ndef_dssdev = NULL;\r\nfor (i = 0; i < pdata->num_devices; ++i) {\r\nstruct omap_dss_device *dssdev = pdata->devices[i];\r\nif (dssdev->type != OMAP_DISPLAY_TYPE_DPI)\r\ncontinue;\r\nif (def_dssdev == NULL)\r\ndef_dssdev = dssdev;\r\nif (def_disp_name != NULL &&\r\nstrcmp(dssdev->name, def_disp_name) == 0) {\r\ndef_dssdev = dssdev;\r\nbreak;\r\n}\r\n}\r\nreturn def_dssdev;\r\n}\r\nstatic void __init dpi_probe_pdata(struct platform_device *dpidev)\r\n{\r\nstruct omap_dss_device *plat_dssdev;\r\nstruct omap_dss_device *dssdev;\r\nint r;\r\nplat_dssdev = dpi_find_dssdev(dpidev);\r\nif (!plat_dssdev)\r\nreturn;\r\ndssdev = dss_alloc_and_init_device(&dpidev->dev);\r\nif (!dssdev)\r\nreturn;\r\ndss_copy_device_pdata(dssdev, plat_dssdev);\r\nr = dpi_init_display(dssdev);\r\nif (r) {\r\nDSSERR("device %s init failed: %d\n", dssdev->name, r);\r\ndss_put_device(dssdev);\r\nreturn;\r\n}\r\nr = omapdss_output_set_device(&dpi.output, dssdev);\r\nif (r) {\r\nDSSERR("failed to connect output to new device: %s\n",\r\ndssdev->name);\r\ndss_put_device(dssdev);\r\nreturn;\r\n}\r\nr = dss_add_device(dssdev);\r\nif (r) {\r\nDSSERR("device %s register failed: %d\n", dssdev->name, r);\r\nomapdss_output_unset_device(&dpi.output);\r\ndss_put_device(dssdev);\r\nreturn;\r\n}\r\n}\r\nstatic void __init dpi_init_output(struct platform_device *pdev)\r\n{\r\nstruct omap_dss_output *out = &dpi.output;\r\nout->pdev = pdev;\r\nout->id = OMAP_DSS_OUTPUT_DPI;\r\nout->type = OMAP_DISPLAY_TYPE_DPI;\r\ndss_register_output(out);\r\n}\r\nstatic void __exit dpi_uninit_output(struct platform_device *pdev)\r\n{\r\nstruct omap_dss_output *out = &dpi.output;\r\ndss_unregister_output(out);\r\n}\r\nstatic int __init omap_dpi_probe(struct platform_device *pdev)\r\n{\r\nmutex_init(&dpi.lock);\r\ndpi_init_output(pdev);\r\ndpi_probe_pdata(pdev);\r\nreturn 0;\r\n}\r\nstatic int __exit omap_dpi_remove(struct platform_device *pdev)\r\n{\r\ndss_unregister_child_devices(&pdev->dev);\r\ndpi_uninit_output(pdev);\r\nreturn 0;\r\n}\r\nint __init dpi_init_platform_driver(void)\r\n{\r\nreturn platform_driver_probe(&omap_dpi_driver, omap_dpi_probe);\r\n}\r\nvoid __exit dpi_uninit_platform_driver(void)\r\n{\r\nplatform_driver_unregister(&omap_dpi_driver);\r\n}
