static long native_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\r\n{\r\nlong ret = -ENOIOCTLCMD;\r\nif (file->f_op->unlocked_ioctl)\r\nret = file->f_op->unlocked_ioctl(file, cmd, arg);\r\nreturn ret;\r\n}\r\nstatic int get_v4l2_window32(struct v4l2_window *kp, struct v4l2_window32 __user *up)\r\n{\r\nif (!access_ok(VERIFY_READ, up, sizeof(struct v4l2_window32)) ||\r\ncopy_from_user(&kp->w, &up->w, sizeof(up->w)) ||\r\nget_user(kp->field, &up->field) ||\r\nget_user(kp->chromakey, &up->chromakey) ||\r\nget_user(kp->clipcount, &up->clipcount))\r\nreturn -EFAULT;\r\nif (kp->clipcount > 2048)\r\nreturn -EINVAL;\r\nif (kp->clipcount) {\r\nstruct v4l2_clip32 __user *uclips;\r\nstruct v4l2_clip __user *kclips;\r\nint n = kp->clipcount;\r\ncompat_caddr_t p;\r\nif (get_user(p, &up->clips))\r\nreturn -EFAULT;\r\nuclips = compat_ptr(p);\r\nkclips = compat_alloc_user_space(n * sizeof(struct v4l2_clip));\r\nkp->clips = kclips;\r\nwhile (--n >= 0) {\r\nif (copy_in_user(&kclips->c, &uclips->c, sizeof(uclips->c)))\r\nreturn -EFAULT;\r\nif (put_user(n ? kclips + 1 : NULL, &kclips->next))\r\nreturn -EFAULT;\r\nuclips += 1;\r\nkclips += 1;\r\n}\r\n} else\r\nkp->clips = NULL;\r\nreturn 0;\r\n}\r\nstatic int put_v4l2_window32(struct v4l2_window *kp, struct v4l2_window32 __user *up)\r\n{\r\nif (copy_to_user(&up->w, &kp->w, sizeof(kp->w)) ||\r\nput_user(kp->field, &up->field) ||\r\nput_user(kp->chromakey, &up->chromakey) ||\r\nput_user(kp->clipcount, &up->clipcount))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic inline int get_v4l2_pix_format(struct v4l2_pix_format *kp, struct v4l2_pix_format __user *up)\r\n{\r\nif (copy_from_user(kp, up, sizeof(struct v4l2_pix_format)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic inline int get_v4l2_pix_format_mplane(struct v4l2_pix_format_mplane *kp,\r\nstruct v4l2_pix_format_mplane __user *up)\r\n{\r\nif (copy_from_user(kp, up, sizeof(struct v4l2_pix_format_mplane)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic inline int put_v4l2_pix_format(struct v4l2_pix_format *kp, struct v4l2_pix_format __user *up)\r\n{\r\nif (copy_to_user(up, kp, sizeof(struct v4l2_pix_format)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic inline int put_v4l2_pix_format_mplane(struct v4l2_pix_format_mplane *kp,\r\nstruct v4l2_pix_format_mplane __user *up)\r\n{\r\nif (copy_to_user(up, kp, sizeof(struct v4l2_pix_format_mplane)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic inline int get_v4l2_vbi_format(struct v4l2_vbi_format *kp, struct v4l2_vbi_format __user *up)\r\n{\r\nif (copy_from_user(kp, up, sizeof(struct v4l2_vbi_format)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic inline int put_v4l2_vbi_format(struct v4l2_vbi_format *kp, struct v4l2_vbi_format __user *up)\r\n{\r\nif (copy_to_user(up, kp, sizeof(struct v4l2_vbi_format)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic inline int get_v4l2_sliced_vbi_format(struct v4l2_sliced_vbi_format *kp, struct v4l2_sliced_vbi_format __user *up)\r\n{\r\nif (copy_from_user(kp, up, sizeof(struct v4l2_sliced_vbi_format)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic inline int put_v4l2_sliced_vbi_format(struct v4l2_sliced_vbi_format *kp, struct v4l2_sliced_vbi_format __user *up)\r\n{\r\nif (copy_to_user(up, kp, sizeof(struct v4l2_sliced_vbi_format)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int __get_v4l2_format32(struct v4l2_format *kp, struct v4l2_format32 __user *up)\r\n{\r\nswitch (kp->type) {\r\ncase V4L2_BUF_TYPE_VIDEO_CAPTURE:\r\ncase V4L2_BUF_TYPE_VIDEO_OUTPUT:\r\nreturn get_v4l2_pix_format(&kp->fmt.pix, &up->fmt.pix);\r\ncase V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE:\r\ncase V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE:\r\nreturn get_v4l2_pix_format_mplane(&kp->fmt.pix_mp,\r\n&up->fmt.pix_mp);\r\ncase V4L2_BUF_TYPE_VIDEO_OVERLAY:\r\ncase V4L2_BUF_TYPE_VIDEO_OUTPUT_OVERLAY:\r\nreturn get_v4l2_window32(&kp->fmt.win, &up->fmt.win);\r\ncase V4L2_BUF_TYPE_VBI_CAPTURE:\r\ncase V4L2_BUF_TYPE_VBI_OUTPUT:\r\nreturn get_v4l2_vbi_format(&kp->fmt.vbi, &up->fmt.vbi);\r\ncase V4L2_BUF_TYPE_SLICED_VBI_CAPTURE:\r\ncase V4L2_BUF_TYPE_SLICED_VBI_OUTPUT:\r\nreturn get_v4l2_sliced_vbi_format(&kp->fmt.sliced, &up->fmt.sliced);\r\ndefault:\r\nprintk(KERN_INFO "compat_ioctl32: unexpected VIDIOC_FMT type %d\n",\r\nkp->type);\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic int get_v4l2_format32(struct v4l2_format *kp, struct v4l2_format32 __user *up)\r\n{\r\nif (!access_ok(VERIFY_READ, up, sizeof(struct v4l2_format32)) ||\r\nget_user(kp->type, &up->type))\r\nreturn -EFAULT;\r\nreturn __get_v4l2_format32(kp, up);\r\n}\r\nstatic int get_v4l2_create32(struct v4l2_create_buffers *kp, struct v4l2_create_buffers32 __user *up)\r\n{\r\nif (!access_ok(VERIFY_READ, up, sizeof(struct v4l2_create_buffers32)) ||\r\ncopy_from_user(kp, up, offsetof(struct v4l2_create_buffers32, format.fmt)))\r\nreturn -EFAULT;\r\nreturn __get_v4l2_format32(&kp->format, &up->format);\r\n}\r\nstatic int __put_v4l2_format32(struct v4l2_format *kp, struct v4l2_format32 __user *up)\r\n{\r\nswitch (kp->type) {\r\ncase V4L2_BUF_TYPE_VIDEO_CAPTURE:\r\ncase V4L2_BUF_TYPE_VIDEO_OUTPUT:\r\nreturn put_v4l2_pix_format(&kp->fmt.pix, &up->fmt.pix);\r\ncase V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE:\r\ncase V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE:\r\nreturn put_v4l2_pix_format_mplane(&kp->fmt.pix_mp,\r\n&up->fmt.pix_mp);\r\ncase V4L2_BUF_TYPE_VIDEO_OVERLAY:\r\ncase V4L2_BUF_TYPE_VIDEO_OUTPUT_OVERLAY:\r\nreturn put_v4l2_window32(&kp->fmt.win, &up->fmt.win);\r\ncase V4L2_BUF_TYPE_VBI_CAPTURE:\r\ncase V4L2_BUF_TYPE_VBI_OUTPUT:\r\nreturn put_v4l2_vbi_format(&kp->fmt.vbi, &up->fmt.vbi);\r\ncase V4L2_BUF_TYPE_SLICED_VBI_CAPTURE:\r\ncase V4L2_BUF_TYPE_SLICED_VBI_OUTPUT:\r\nreturn put_v4l2_sliced_vbi_format(&kp->fmt.sliced, &up->fmt.sliced);\r\ndefault:\r\nprintk(KERN_INFO "compat_ioctl32: unexpected VIDIOC_FMT type %d\n",\r\nkp->type);\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic int put_v4l2_format32(struct v4l2_format *kp, struct v4l2_format32 __user *up)\r\n{\r\nif (!access_ok(VERIFY_WRITE, up, sizeof(struct v4l2_format32)) ||\r\nput_user(kp->type, &up->type))\r\nreturn -EFAULT;\r\nreturn __put_v4l2_format32(kp, up);\r\n}\r\nstatic int put_v4l2_create32(struct v4l2_create_buffers *kp, struct v4l2_create_buffers32 __user *up)\r\n{\r\nif (!access_ok(VERIFY_WRITE, up, sizeof(struct v4l2_create_buffers32)) ||\r\ncopy_to_user(up, kp, offsetof(struct v4l2_create_buffers32, format.fmt)))\r\nreturn -EFAULT;\r\nreturn __put_v4l2_format32(&kp->format, &up->format);\r\n}\r\nstatic int get_v4l2_standard32(struct v4l2_standard *kp, struct v4l2_standard32 __user *up)\r\n{\r\nif (!access_ok(VERIFY_READ, up, sizeof(struct v4l2_standard32)) ||\r\nget_user(kp->index, &up->index))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int put_v4l2_standard32(struct v4l2_standard *kp, struct v4l2_standard32 __user *up)\r\n{\r\nif (!access_ok(VERIFY_WRITE, up, sizeof(struct v4l2_standard32)) ||\r\nput_user(kp->index, &up->index) ||\r\ncopy_to_user(up->id, &kp->id, sizeof(__u64)) ||\r\ncopy_to_user(up->name, kp->name, 24) ||\r\ncopy_to_user(&up->frameperiod, &kp->frameperiod, sizeof(kp->frameperiod)) ||\r\nput_user(kp->framelines, &up->framelines) ||\r\ncopy_to_user(up->reserved, kp->reserved, 4 * sizeof(__u32)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int get_v4l2_plane32(struct v4l2_plane *up, struct v4l2_plane32 *up32,\r\nenum v4l2_memory memory)\r\n{\r\nvoid __user *up_pln;\r\ncompat_long_t p;\r\nif (copy_in_user(up, up32, 2 * sizeof(__u32)) ||\r\ncopy_in_user(&up->data_offset, &up32->data_offset,\r\nsizeof(__u32)))\r\nreturn -EFAULT;\r\nif (memory == V4L2_MEMORY_USERPTR) {\r\nif (get_user(p, &up32->m.userptr))\r\nreturn -EFAULT;\r\nup_pln = compat_ptr(p);\r\nif (put_user((unsigned long)up_pln, &up->m.userptr))\r\nreturn -EFAULT;\r\n} else if (memory == V4L2_MEMORY_DMABUF) {\r\nif (copy_in_user(&up->m.fd, &up32->m.fd, sizeof(int)))\r\nreturn -EFAULT;\r\n} else {\r\nif (copy_in_user(&up->m.mem_offset, &up32->m.mem_offset,\r\nsizeof(__u32)))\r\nreturn -EFAULT;\r\n}\r\nreturn 0;\r\n}\r\nstatic int put_v4l2_plane32(struct v4l2_plane *up, struct v4l2_plane32 *up32,\r\nenum v4l2_memory memory)\r\n{\r\nif (copy_in_user(up32, up, 2 * sizeof(__u32)) ||\r\ncopy_in_user(&up32->data_offset, &up->data_offset,\r\nsizeof(__u32)))\r\nreturn -EFAULT;\r\nif (memory == V4L2_MEMORY_MMAP)\r\nif (copy_in_user(&up32->m.mem_offset, &up->m.mem_offset,\r\nsizeof(__u32)))\r\nreturn -EFAULT;\r\nif (memory == V4L2_MEMORY_DMABUF)\r\nif (copy_in_user(&up32->m.fd, &up->m.fd,\r\nsizeof(int)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int get_v4l2_buffer32(struct v4l2_buffer *kp, struct v4l2_buffer32 __user *up)\r\n{\r\nstruct v4l2_plane32 __user *uplane32;\r\nstruct v4l2_plane __user *uplane;\r\ncompat_caddr_t p;\r\nint num_planes;\r\nint ret;\r\nif (!access_ok(VERIFY_READ, up, sizeof(struct v4l2_buffer32)) ||\r\nget_user(kp->index, &up->index) ||\r\nget_user(kp->type, &up->type) ||\r\nget_user(kp->flags, &up->flags) ||\r\nget_user(kp->memory, &up->memory))\r\nreturn -EFAULT;\r\nif (V4L2_TYPE_IS_OUTPUT(kp->type))\r\nif (get_user(kp->bytesused, &up->bytesused) ||\r\nget_user(kp->field, &up->field) ||\r\nget_user(kp->timestamp.tv_sec, &up->timestamp.tv_sec) ||\r\nget_user(kp->timestamp.tv_usec,\r\n&up->timestamp.tv_usec))\r\nreturn -EFAULT;\r\nif (V4L2_TYPE_IS_MULTIPLANAR(kp->type)) {\r\nif (get_user(kp->length, &up->length))\r\nreturn -EFAULT;\r\nnum_planes = kp->length;\r\nif (num_planes == 0) {\r\nkp->m.planes = NULL;\r\nreturn 0;\r\n}\r\nif (get_user(p, &up->m.planes))\r\nreturn -EFAULT;\r\nuplane32 = compat_ptr(p);\r\nif (!access_ok(VERIFY_READ, uplane32,\r\nnum_planes * sizeof(struct v4l2_plane32)))\r\nreturn -EFAULT;\r\nuplane = compat_alloc_user_space(num_planes *\r\nsizeof(struct v4l2_plane));\r\nkp->m.planes = uplane;\r\nwhile (--num_planes >= 0) {\r\nret = get_v4l2_plane32(uplane, uplane32, kp->memory);\r\nif (ret)\r\nreturn ret;\r\n++uplane;\r\n++uplane32;\r\n}\r\n} else {\r\nswitch (kp->memory) {\r\ncase V4L2_MEMORY_MMAP:\r\nif (get_user(kp->length, &up->length) ||\r\nget_user(kp->m.offset, &up->m.offset))\r\nreturn -EFAULT;\r\nbreak;\r\ncase V4L2_MEMORY_USERPTR:\r\n{\r\ncompat_long_t tmp;\r\nif (get_user(kp->length, &up->length) ||\r\nget_user(tmp, &up->m.userptr))\r\nreturn -EFAULT;\r\nkp->m.userptr = (unsigned long)compat_ptr(tmp);\r\n}\r\nbreak;\r\ncase V4L2_MEMORY_OVERLAY:\r\nif (get_user(kp->m.offset, &up->m.offset))\r\nreturn -EFAULT;\r\nbreak;\r\ncase V4L2_MEMORY_DMABUF:\r\nif (get_user(kp->m.fd, &up->m.fd))\r\nreturn -EFAULT;\r\nbreak;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int put_v4l2_buffer32(struct v4l2_buffer *kp, struct v4l2_buffer32 __user *up)\r\n{\r\nstruct v4l2_plane32 __user *uplane32;\r\nstruct v4l2_plane __user *uplane;\r\ncompat_caddr_t p;\r\nint num_planes;\r\nint ret;\r\nif (!access_ok(VERIFY_WRITE, up, sizeof(struct v4l2_buffer32)) ||\r\nput_user(kp->index, &up->index) ||\r\nput_user(kp->type, &up->type) ||\r\nput_user(kp->flags, &up->flags) ||\r\nput_user(kp->memory, &up->memory))\r\nreturn -EFAULT;\r\nif (put_user(kp->bytesused, &up->bytesused) ||\r\nput_user(kp->field, &up->field) ||\r\nput_user(kp->timestamp.tv_sec, &up->timestamp.tv_sec) ||\r\nput_user(kp->timestamp.tv_usec, &up->timestamp.tv_usec) ||\r\ncopy_to_user(&up->timecode, &kp->timecode, sizeof(struct v4l2_timecode)) ||\r\nput_user(kp->sequence, &up->sequence) ||\r\nput_user(kp->reserved2, &up->reserved2) ||\r\nput_user(kp->reserved, &up->reserved))\r\nreturn -EFAULT;\r\nif (V4L2_TYPE_IS_MULTIPLANAR(kp->type)) {\r\nnum_planes = kp->length;\r\nif (num_planes == 0)\r\nreturn 0;\r\nuplane = kp->m.planes;\r\nif (get_user(p, &up->m.planes))\r\nreturn -EFAULT;\r\nuplane32 = compat_ptr(p);\r\nwhile (--num_planes >= 0) {\r\nret = put_v4l2_plane32(uplane, uplane32, kp->memory);\r\nif (ret)\r\nreturn ret;\r\n++uplane;\r\n++uplane32;\r\n}\r\n} else {\r\nswitch (kp->memory) {\r\ncase V4L2_MEMORY_MMAP:\r\nif (put_user(kp->length, &up->length) ||\r\nput_user(kp->m.offset, &up->m.offset))\r\nreturn -EFAULT;\r\nbreak;\r\ncase V4L2_MEMORY_USERPTR:\r\nif (put_user(kp->length, &up->length) ||\r\nput_user(kp->m.userptr, &up->m.userptr))\r\nreturn -EFAULT;\r\nbreak;\r\ncase V4L2_MEMORY_OVERLAY:\r\nif (put_user(kp->m.offset, &up->m.offset))\r\nreturn -EFAULT;\r\nbreak;\r\ncase V4L2_MEMORY_DMABUF:\r\nif (put_user(kp->m.fd, &up->m.fd))\r\nreturn -EFAULT;\r\nbreak;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int get_v4l2_framebuffer32(struct v4l2_framebuffer *kp, struct v4l2_framebuffer32 __user *up)\r\n{\r\nu32 tmp;\r\nif (!access_ok(VERIFY_READ, up, sizeof(struct v4l2_framebuffer32)) ||\r\nget_user(tmp, &up->base) ||\r\nget_user(kp->capability, &up->capability) ||\r\nget_user(kp->flags, &up->flags))\r\nreturn -EFAULT;\r\nkp->base = compat_ptr(tmp);\r\nget_v4l2_pix_format(&kp->fmt, &up->fmt);\r\nreturn 0;\r\n}\r\nstatic int put_v4l2_framebuffer32(struct v4l2_framebuffer *kp, struct v4l2_framebuffer32 __user *up)\r\n{\r\nu32 tmp = (u32)((unsigned long)kp->base);\r\nif (!access_ok(VERIFY_WRITE, up, sizeof(struct v4l2_framebuffer32)) ||\r\nput_user(tmp, &up->base) ||\r\nput_user(kp->capability, &up->capability) ||\r\nput_user(kp->flags, &up->flags))\r\nreturn -EFAULT;\r\nput_v4l2_pix_format(&kp->fmt, &up->fmt);\r\nreturn 0;\r\n}\r\nstatic inline int get_v4l2_input32(struct v4l2_input *kp, struct v4l2_input32 __user *up)\r\n{\r\nif (copy_from_user(kp, up, sizeof(struct v4l2_input32)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic inline int put_v4l2_input32(struct v4l2_input *kp, struct v4l2_input32 __user *up)\r\n{\r\nif (copy_to_user(up, kp, sizeof(struct v4l2_input32)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic inline int ctrl_is_pointer(u32 id)\r\n{\r\nswitch (id) {\r\ncase V4L2_CID_RDS_TX_PS_NAME:\r\ncase V4L2_CID_RDS_TX_RADIO_TEXT:\r\nreturn 1;\r\ndefault:\r\nreturn 0;\r\n}\r\n}\r\nstatic int get_v4l2_ext_controls32(struct v4l2_ext_controls *kp, struct v4l2_ext_controls32 __user *up)\r\n{\r\nstruct v4l2_ext_control32 __user *ucontrols;\r\nstruct v4l2_ext_control __user *kcontrols;\r\nint n;\r\ncompat_caddr_t p;\r\nif (!access_ok(VERIFY_READ, up, sizeof(struct v4l2_ext_controls32)) ||\r\nget_user(kp->ctrl_class, &up->ctrl_class) ||\r\nget_user(kp->count, &up->count) ||\r\nget_user(kp->error_idx, &up->error_idx) ||\r\ncopy_from_user(kp->reserved, up->reserved, sizeof(kp->reserved)))\r\nreturn -EFAULT;\r\nn = kp->count;\r\nif (n == 0) {\r\nkp->controls = NULL;\r\nreturn 0;\r\n}\r\nif (get_user(p, &up->controls))\r\nreturn -EFAULT;\r\nucontrols = compat_ptr(p);\r\nif (!access_ok(VERIFY_READ, ucontrols,\r\nn * sizeof(struct v4l2_ext_control32)))\r\nreturn -EFAULT;\r\nkcontrols = compat_alloc_user_space(n * sizeof(struct v4l2_ext_control));\r\nkp->controls = kcontrols;\r\nwhile (--n >= 0) {\r\nif (copy_in_user(kcontrols, ucontrols, sizeof(*ucontrols)))\r\nreturn -EFAULT;\r\nif (ctrl_is_pointer(kcontrols->id)) {\r\nvoid __user *s;\r\nif (get_user(p, &ucontrols->string))\r\nreturn -EFAULT;\r\ns = compat_ptr(p);\r\nif (put_user(s, &kcontrols->string))\r\nreturn -EFAULT;\r\n}\r\nucontrols++;\r\nkcontrols++;\r\n}\r\nreturn 0;\r\n}\r\nstatic int put_v4l2_ext_controls32(struct v4l2_ext_controls *kp, struct v4l2_ext_controls32 __user *up)\r\n{\r\nstruct v4l2_ext_control32 __user *ucontrols;\r\nstruct v4l2_ext_control __user *kcontrols = kp->controls;\r\nint n = kp->count;\r\ncompat_caddr_t p;\r\nif (!access_ok(VERIFY_WRITE, up, sizeof(struct v4l2_ext_controls32)) ||\r\nput_user(kp->ctrl_class, &up->ctrl_class) ||\r\nput_user(kp->count, &up->count) ||\r\nput_user(kp->error_idx, &up->error_idx) ||\r\ncopy_to_user(up->reserved, kp->reserved, sizeof(up->reserved)))\r\nreturn -EFAULT;\r\nif (!kp->count)\r\nreturn 0;\r\nif (get_user(p, &up->controls))\r\nreturn -EFAULT;\r\nucontrols = compat_ptr(p);\r\nif (!access_ok(VERIFY_WRITE, ucontrols,\r\nn * sizeof(struct v4l2_ext_control32)))\r\nreturn -EFAULT;\r\nwhile (--n >= 0) {\r\nunsigned size = sizeof(*ucontrols);\r\nif (ctrl_is_pointer(kcontrols->id))\r\nsize -= sizeof(ucontrols->value64);\r\nif (copy_in_user(ucontrols, kcontrols, size))\r\nreturn -EFAULT;\r\nucontrols++;\r\nkcontrols++;\r\n}\r\nreturn 0;\r\n}\r\nstatic int put_v4l2_event32(struct v4l2_event *kp, struct v4l2_event32 __user *up)\r\n{\r\nif (!access_ok(VERIFY_WRITE, up, sizeof(struct v4l2_event32)) ||\r\nput_user(kp->type, &up->type) ||\r\ncopy_to_user(&up->u, &kp->u, sizeof(kp->u)) ||\r\nput_user(kp->pending, &up->pending) ||\r\nput_user(kp->sequence, &up->sequence) ||\r\nput_compat_timespec(&kp->timestamp, &up->timestamp) ||\r\nput_user(kp->id, &up->id) ||\r\ncopy_to_user(up->reserved, kp->reserved, 8 * sizeof(__u32)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int get_v4l2_subdev_edid32(struct v4l2_subdev_edid *kp, struct v4l2_subdev_edid32 __user *up)\r\n{\r\nu32 tmp;\r\nif (!access_ok(VERIFY_READ, up, sizeof(struct v4l2_subdev_edid32)) ||\r\nget_user(kp->pad, &up->pad) ||\r\nget_user(kp->start_block, &up->start_block) ||\r\nget_user(kp->blocks, &up->blocks) ||\r\nget_user(tmp, &up->edid) ||\r\ncopy_from_user(kp->reserved, up->reserved, sizeof(kp->reserved)))\r\nreturn -EFAULT;\r\nkp->edid = compat_ptr(tmp);\r\nreturn 0;\r\n}\r\nstatic int put_v4l2_subdev_edid32(struct v4l2_subdev_edid *kp, struct v4l2_subdev_edid32 __user *up)\r\n{\r\nu32 tmp = (u32)((unsigned long)kp->edid);\r\nif (!access_ok(VERIFY_WRITE, up, sizeof(struct v4l2_subdev_edid32)) ||\r\nput_user(kp->pad, &up->pad) ||\r\nput_user(kp->start_block, &up->start_block) ||\r\nput_user(kp->blocks, &up->blocks) ||\r\nput_user(tmp, &up->edid) ||\r\ncopy_to_user(kp->reserved, up->reserved, sizeof(kp->reserved)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic long do_video_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\r\n{\r\nunion {\r\nstruct v4l2_format v2f;\r\nstruct v4l2_buffer v2b;\r\nstruct v4l2_framebuffer v2fb;\r\nstruct v4l2_input v2i;\r\nstruct v4l2_standard v2s;\r\nstruct v4l2_ext_controls v2ecs;\r\nstruct v4l2_event v2ev;\r\nstruct v4l2_create_buffers v2crt;\r\nstruct v4l2_subdev_edid v2edid;\r\nunsigned long vx;\r\nint vi;\r\n} karg;\r\nvoid __user *up = compat_ptr(arg);\r\nint compatible_arg = 1;\r\nlong err = 0;\r\nswitch (cmd) {\r\ncase VIDIOC_G_FMT32: cmd = VIDIOC_G_FMT; break;\r\ncase VIDIOC_S_FMT32: cmd = VIDIOC_S_FMT; break;\r\ncase VIDIOC_QUERYBUF32: cmd = VIDIOC_QUERYBUF; break;\r\ncase VIDIOC_G_FBUF32: cmd = VIDIOC_G_FBUF; break;\r\ncase VIDIOC_S_FBUF32: cmd = VIDIOC_S_FBUF; break;\r\ncase VIDIOC_QBUF32: cmd = VIDIOC_QBUF; break;\r\ncase VIDIOC_DQBUF32: cmd = VIDIOC_DQBUF; break;\r\ncase VIDIOC_ENUMSTD32: cmd = VIDIOC_ENUMSTD; break;\r\ncase VIDIOC_ENUMINPUT32: cmd = VIDIOC_ENUMINPUT; break;\r\ncase VIDIOC_TRY_FMT32: cmd = VIDIOC_TRY_FMT; break;\r\ncase VIDIOC_G_EXT_CTRLS32: cmd = VIDIOC_G_EXT_CTRLS; break;\r\ncase VIDIOC_S_EXT_CTRLS32: cmd = VIDIOC_S_EXT_CTRLS; break;\r\ncase VIDIOC_TRY_EXT_CTRLS32: cmd = VIDIOC_TRY_EXT_CTRLS; break;\r\ncase VIDIOC_DQEVENT32: cmd = VIDIOC_DQEVENT; break;\r\ncase VIDIOC_OVERLAY32: cmd = VIDIOC_OVERLAY; break;\r\ncase VIDIOC_STREAMON32: cmd = VIDIOC_STREAMON; break;\r\ncase VIDIOC_STREAMOFF32: cmd = VIDIOC_STREAMOFF; break;\r\ncase VIDIOC_G_INPUT32: cmd = VIDIOC_G_INPUT; break;\r\ncase VIDIOC_S_INPUT32: cmd = VIDIOC_S_INPUT; break;\r\ncase VIDIOC_G_OUTPUT32: cmd = VIDIOC_G_OUTPUT; break;\r\ncase VIDIOC_S_OUTPUT32: cmd = VIDIOC_S_OUTPUT; break;\r\ncase VIDIOC_CREATE_BUFS32: cmd = VIDIOC_CREATE_BUFS; break;\r\ncase VIDIOC_PREPARE_BUF32: cmd = VIDIOC_PREPARE_BUF; break;\r\ncase VIDIOC_SUBDEV_G_EDID32: cmd = VIDIOC_SUBDEV_G_EDID; break;\r\ncase VIDIOC_SUBDEV_S_EDID32: cmd = VIDIOC_SUBDEV_S_EDID; break;\r\n}\r\nswitch (cmd) {\r\ncase VIDIOC_OVERLAY:\r\ncase VIDIOC_STREAMON:\r\ncase VIDIOC_STREAMOFF:\r\ncase VIDIOC_S_INPUT:\r\ncase VIDIOC_S_OUTPUT:\r\nerr = get_user(karg.vi, (s32 __user *)up);\r\ncompatible_arg = 0;\r\nbreak;\r\ncase VIDIOC_G_INPUT:\r\ncase VIDIOC_G_OUTPUT:\r\ncompatible_arg = 0;\r\nbreak;\r\ncase VIDIOC_SUBDEV_G_EDID:\r\ncase VIDIOC_SUBDEV_S_EDID:\r\nerr = get_v4l2_subdev_edid32(&karg.v2edid, up);\r\ncompatible_arg = 0;\r\nbreak;\r\ncase VIDIOC_G_FMT:\r\ncase VIDIOC_S_FMT:\r\ncase VIDIOC_TRY_FMT:\r\nerr = get_v4l2_format32(&karg.v2f, up);\r\ncompatible_arg = 0;\r\nbreak;\r\ncase VIDIOC_CREATE_BUFS:\r\nerr = get_v4l2_create32(&karg.v2crt, up);\r\ncompatible_arg = 0;\r\nbreak;\r\ncase VIDIOC_PREPARE_BUF:\r\ncase VIDIOC_QUERYBUF:\r\ncase VIDIOC_QBUF:\r\ncase VIDIOC_DQBUF:\r\nerr = get_v4l2_buffer32(&karg.v2b, up);\r\ncompatible_arg = 0;\r\nbreak;\r\ncase VIDIOC_S_FBUF:\r\nerr = get_v4l2_framebuffer32(&karg.v2fb, up);\r\ncompatible_arg = 0;\r\nbreak;\r\ncase VIDIOC_G_FBUF:\r\ncompatible_arg = 0;\r\nbreak;\r\ncase VIDIOC_ENUMSTD:\r\nerr = get_v4l2_standard32(&karg.v2s, up);\r\ncompatible_arg = 0;\r\nbreak;\r\ncase VIDIOC_ENUMINPUT:\r\nerr = get_v4l2_input32(&karg.v2i, up);\r\ncompatible_arg = 0;\r\nbreak;\r\ncase VIDIOC_G_EXT_CTRLS:\r\ncase VIDIOC_S_EXT_CTRLS:\r\ncase VIDIOC_TRY_EXT_CTRLS:\r\nerr = get_v4l2_ext_controls32(&karg.v2ecs, up);\r\ncompatible_arg = 0;\r\nbreak;\r\ncase VIDIOC_DQEVENT:\r\ncompatible_arg = 0;\r\nbreak;\r\n}\r\nif (err)\r\nreturn err;\r\nif (compatible_arg)\r\nerr = native_ioctl(file, cmd, (unsigned long)up);\r\nelse {\r\nmm_segment_t old_fs = get_fs();\r\nset_fs(KERNEL_DS);\r\nerr = native_ioctl(file, cmd, (unsigned long)&karg);\r\nset_fs(old_fs);\r\n}\r\nswitch (cmd) {\r\ncase VIDIOC_G_EXT_CTRLS:\r\ncase VIDIOC_S_EXT_CTRLS:\r\ncase VIDIOC_TRY_EXT_CTRLS:\r\nif (put_v4l2_ext_controls32(&karg.v2ecs, up))\r\nerr = -EFAULT;\r\nbreak;\r\n}\r\nif (err)\r\nreturn err;\r\nswitch (cmd) {\r\ncase VIDIOC_S_INPUT:\r\ncase VIDIOC_S_OUTPUT:\r\ncase VIDIOC_G_INPUT:\r\ncase VIDIOC_G_OUTPUT:\r\nerr = put_user(((s32)karg.vi), (s32 __user *)up);\r\nbreak;\r\ncase VIDIOC_G_FBUF:\r\nerr = put_v4l2_framebuffer32(&karg.v2fb, up);\r\nbreak;\r\ncase VIDIOC_DQEVENT:\r\nerr = put_v4l2_event32(&karg.v2ev, up);\r\nbreak;\r\ncase VIDIOC_SUBDEV_G_EDID:\r\ncase VIDIOC_SUBDEV_S_EDID:\r\nerr = put_v4l2_subdev_edid32(&karg.v2edid, up);\r\nbreak;\r\ncase VIDIOC_G_FMT:\r\ncase VIDIOC_S_FMT:\r\ncase VIDIOC_TRY_FMT:\r\nerr = put_v4l2_format32(&karg.v2f, up);\r\nbreak;\r\ncase VIDIOC_CREATE_BUFS:\r\nerr = put_v4l2_create32(&karg.v2crt, up);\r\nbreak;\r\ncase VIDIOC_QUERYBUF:\r\ncase VIDIOC_QBUF:\r\ncase VIDIOC_DQBUF:\r\nerr = put_v4l2_buffer32(&karg.v2b, up);\r\nbreak;\r\ncase VIDIOC_ENUMSTD:\r\nerr = put_v4l2_standard32(&karg.v2s, up);\r\nbreak;\r\ncase VIDIOC_ENUMINPUT:\r\nerr = put_v4l2_input32(&karg.v2i, up);\r\nbreak;\r\n}\r\nreturn err;\r\n}\r\nlong v4l2_compat_ioctl32(struct file *file, unsigned int cmd, unsigned long arg)\r\n{\r\nstruct video_device *vdev = video_devdata(file);\r\nlong ret = -ENOIOCTLCMD;\r\nif (!file->f_op->unlocked_ioctl)\r\nreturn ret;\r\nswitch (cmd) {\r\ncase VIDIOC_QUERYCAP:\r\ncase VIDIOC_RESERVED:\r\ncase VIDIOC_ENUM_FMT:\r\ncase VIDIOC_G_FMT32:\r\ncase VIDIOC_S_FMT32:\r\ncase VIDIOC_REQBUFS:\r\ncase VIDIOC_QUERYBUF32:\r\ncase VIDIOC_G_FBUF32:\r\ncase VIDIOC_S_FBUF32:\r\ncase VIDIOC_OVERLAY32:\r\ncase VIDIOC_QBUF32:\r\ncase VIDIOC_EXPBUF:\r\ncase VIDIOC_DQBUF32:\r\ncase VIDIOC_STREAMON32:\r\ncase VIDIOC_STREAMOFF32:\r\ncase VIDIOC_G_PARM:\r\ncase VIDIOC_S_PARM:\r\ncase VIDIOC_G_STD:\r\ncase VIDIOC_S_STD:\r\ncase VIDIOC_ENUMSTD32:\r\ncase VIDIOC_ENUMINPUT32:\r\ncase VIDIOC_G_CTRL:\r\ncase VIDIOC_S_CTRL:\r\ncase VIDIOC_G_TUNER:\r\ncase VIDIOC_S_TUNER:\r\ncase VIDIOC_G_AUDIO:\r\ncase VIDIOC_S_AUDIO:\r\ncase VIDIOC_QUERYCTRL:\r\ncase VIDIOC_QUERYMENU:\r\ncase VIDIOC_G_INPUT32:\r\ncase VIDIOC_S_INPUT32:\r\ncase VIDIOC_G_OUTPUT32:\r\ncase VIDIOC_S_OUTPUT32:\r\ncase VIDIOC_ENUMOUTPUT:\r\ncase VIDIOC_G_AUDOUT:\r\ncase VIDIOC_S_AUDOUT:\r\ncase VIDIOC_G_MODULATOR:\r\ncase VIDIOC_S_MODULATOR:\r\ncase VIDIOC_S_FREQUENCY:\r\ncase VIDIOC_G_FREQUENCY:\r\ncase VIDIOC_CROPCAP:\r\ncase VIDIOC_G_CROP:\r\ncase VIDIOC_S_CROP:\r\ncase VIDIOC_G_SELECTION:\r\ncase VIDIOC_S_SELECTION:\r\ncase VIDIOC_G_JPEGCOMP:\r\ncase VIDIOC_S_JPEGCOMP:\r\ncase VIDIOC_QUERYSTD:\r\ncase VIDIOC_TRY_FMT32:\r\ncase VIDIOC_ENUMAUDIO:\r\ncase VIDIOC_ENUMAUDOUT:\r\ncase VIDIOC_G_PRIORITY:\r\ncase VIDIOC_S_PRIORITY:\r\ncase VIDIOC_G_SLICED_VBI_CAP:\r\ncase VIDIOC_LOG_STATUS:\r\ncase VIDIOC_G_EXT_CTRLS32:\r\ncase VIDIOC_S_EXT_CTRLS32:\r\ncase VIDIOC_TRY_EXT_CTRLS32:\r\ncase VIDIOC_ENUM_FRAMESIZES:\r\ncase VIDIOC_ENUM_FRAMEINTERVALS:\r\ncase VIDIOC_G_ENC_INDEX:\r\ncase VIDIOC_ENCODER_CMD:\r\ncase VIDIOC_TRY_ENCODER_CMD:\r\ncase VIDIOC_DECODER_CMD:\r\ncase VIDIOC_TRY_DECODER_CMD:\r\ncase VIDIOC_DBG_S_REGISTER:\r\ncase VIDIOC_DBG_G_REGISTER:\r\ncase VIDIOC_DBG_G_CHIP_IDENT:\r\ncase VIDIOC_S_HW_FREQ_SEEK:\r\ncase VIDIOC_ENUM_DV_PRESETS:\r\ncase VIDIOC_S_DV_PRESET:\r\ncase VIDIOC_G_DV_PRESET:\r\ncase VIDIOC_QUERY_DV_PRESET:\r\ncase VIDIOC_S_DV_TIMINGS:\r\ncase VIDIOC_G_DV_TIMINGS:\r\ncase VIDIOC_DQEVENT:\r\ncase VIDIOC_DQEVENT32:\r\ncase VIDIOC_SUBSCRIBE_EVENT:\r\ncase VIDIOC_UNSUBSCRIBE_EVENT:\r\ncase VIDIOC_CREATE_BUFS32:\r\ncase VIDIOC_PREPARE_BUF32:\r\ncase VIDIOC_ENUM_DV_TIMINGS:\r\ncase VIDIOC_QUERY_DV_TIMINGS:\r\ncase VIDIOC_DV_TIMINGS_CAP:\r\ncase VIDIOC_ENUM_FREQ_BANDS:\r\ncase VIDIOC_SUBDEV_G_EDID32:\r\ncase VIDIOC_SUBDEV_S_EDID32:\r\nret = do_video_ioctl(file, cmd, arg);\r\nbreak;\r\ndefault:\r\nif (vdev->fops->compat_ioctl32)\r\nret = vdev->fops->compat_ioctl32(file, cmd, arg);\r\nif (ret == -ENOIOCTLCMD)\r\nprintk(KERN_WARNING "compat_ioctl32: "\r\n"unknown ioctl '%c', dir=%d, #%d (0x%08x)\n",\r\n_IOC_TYPE(cmd), _IOC_DIR(cmd), _IOC_NR(cmd),\r\ncmd);\r\nbreak;\r\n}\r\nreturn ret;\r\n}
