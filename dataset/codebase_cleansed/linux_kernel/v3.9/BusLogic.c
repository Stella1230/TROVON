static void BusLogic_AnnounceDriver(struct BusLogic_HostAdapter *HostAdapter)\r\n{\r\nBusLogic_Announce("***** BusLogic SCSI Driver Version " BusLogic_DriverVersion " of " BusLogic_DriverDate " *****\n", HostAdapter);\r\nBusLogic_Announce("Copyright 1995-1998 by Leonard N. Zubkoff " "<lnz@dandelion.com>\n", HostAdapter);\r\n}\r\nstatic const char *BusLogic_DriverInfo(struct Scsi_Host *Host)\r\n{\r\nstruct BusLogic_HostAdapter *HostAdapter = (struct BusLogic_HostAdapter *) Host->hostdata;\r\nreturn HostAdapter->FullModelName;\r\n}\r\nstatic void BusLogic_InitializeCCBs(struct BusLogic_HostAdapter *HostAdapter, void *BlockPointer, int BlockSize, dma_addr_t BlockPointerHandle)\r\n{\r\nstruct BusLogic_CCB *CCB = (struct BusLogic_CCB *) BlockPointer;\r\nunsigned int offset = 0;\r\nmemset(BlockPointer, 0, BlockSize);\r\nCCB->AllocationGroupHead = BlockPointerHandle;\r\nCCB->AllocationGroupSize = BlockSize;\r\nwhile ((BlockSize -= sizeof(struct BusLogic_CCB)) >= 0) {\r\nCCB->Status = BusLogic_CCB_Free;\r\nCCB->HostAdapter = HostAdapter;\r\nCCB->DMA_Handle = (u32) BlockPointerHandle + offset;\r\nif (BusLogic_FlashPointHostAdapterP(HostAdapter)) {\r\nCCB->CallbackFunction = BusLogic_QueueCompletedCCB;\r\nCCB->BaseAddress = HostAdapter->FlashPointInfo.BaseAddress;\r\n}\r\nCCB->Next = HostAdapter->Free_CCBs;\r\nCCB->NextAll = HostAdapter->All_CCBs;\r\nHostAdapter->Free_CCBs = CCB;\r\nHostAdapter->All_CCBs = CCB;\r\nHostAdapter->AllocatedCCBs++;\r\nCCB++;\r\noffset += sizeof(struct BusLogic_CCB);\r\n}\r\n}\r\nstatic bool __init BusLogic_CreateInitialCCBs(struct BusLogic_HostAdapter *HostAdapter)\r\n{\r\nint BlockSize = BusLogic_CCB_AllocationGroupSize * sizeof(struct BusLogic_CCB);\r\nvoid *BlockPointer;\r\ndma_addr_t BlockPointerHandle;\r\nwhile (HostAdapter->AllocatedCCBs < HostAdapter->InitialCCBs) {\r\nBlockPointer = pci_alloc_consistent(HostAdapter->PCI_Device, BlockSize, &BlockPointerHandle);\r\nif (BlockPointer == NULL) {\r\nBusLogic_Error("UNABLE TO ALLOCATE CCB GROUP - DETACHING\n", HostAdapter);\r\nreturn false;\r\n}\r\nBusLogic_InitializeCCBs(HostAdapter, BlockPointer, BlockSize, BlockPointerHandle);\r\n}\r\nreturn true;\r\n}\r\nstatic void BusLogic_DestroyCCBs(struct BusLogic_HostAdapter *HostAdapter)\r\n{\r\nstruct BusLogic_CCB *NextCCB = HostAdapter->All_CCBs, *CCB, *Last_CCB = NULL;\r\nHostAdapter->All_CCBs = NULL;\r\nHostAdapter->Free_CCBs = NULL;\r\nwhile ((CCB = NextCCB) != NULL) {\r\nNextCCB = CCB->NextAll;\r\nif (CCB->AllocationGroupHead) {\r\nif (Last_CCB)\r\npci_free_consistent(HostAdapter->PCI_Device, Last_CCB->AllocationGroupSize, Last_CCB, Last_CCB->AllocationGroupHead);\r\nLast_CCB = CCB;\r\n}\r\n}\r\nif (Last_CCB)\r\npci_free_consistent(HostAdapter->PCI_Device, Last_CCB->AllocationGroupSize, Last_CCB, Last_CCB->AllocationGroupHead);\r\n}\r\nstatic void BusLogic_CreateAdditionalCCBs(struct BusLogic_HostAdapter *HostAdapter, int AdditionalCCBs, bool SuccessMessageP)\r\n{\r\nint BlockSize = BusLogic_CCB_AllocationGroupSize * sizeof(struct BusLogic_CCB);\r\nint PreviouslyAllocated = HostAdapter->AllocatedCCBs;\r\nvoid *BlockPointer;\r\ndma_addr_t BlockPointerHandle;\r\nif (AdditionalCCBs <= 0)\r\nreturn;\r\nwhile (HostAdapter->AllocatedCCBs - PreviouslyAllocated < AdditionalCCBs) {\r\nBlockPointer = pci_alloc_consistent(HostAdapter->PCI_Device, BlockSize, &BlockPointerHandle);\r\nif (BlockPointer == NULL)\r\nbreak;\r\nBusLogic_InitializeCCBs(HostAdapter, BlockPointer, BlockSize, BlockPointerHandle);\r\n}\r\nif (HostAdapter->AllocatedCCBs > PreviouslyAllocated) {\r\nif (SuccessMessageP)\r\nBusLogic_Notice("Allocated %d additional CCBs (total now %d)\n", HostAdapter, HostAdapter->AllocatedCCBs - PreviouslyAllocated, HostAdapter->AllocatedCCBs);\r\nreturn;\r\n}\r\nBusLogic_Notice("Failed to allocate additional CCBs\n", HostAdapter);\r\nif (HostAdapter->DriverQueueDepth > HostAdapter->AllocatedCCBs - HostAdapter->TargetDeviceCount) {\r\nHostAdapter->DriverQueueDepth = HostAdapter->AllocatedCCBs - HostAdapter->TargetDeviceCount;\r\nHostAdapter->SCSI_Host->can_queue = HostAdapter->DriverQueueDepth;\r\n}\r\n}\r\nstatic struct BusLogic_CCB *BusLogic_AllocateCCB(struct BusLogic_HostAdapter\r\n*HostAdapter)\r\n{\r\nstatic unsigned long SerialNumber = 0;\r\nstruct BusLogic_CCB *CCB;\r\nCCB = HostAdapter->Free_CCBs;\r\nif (CCB != NULL) {\r\nCCB->SerialNumber = ++SerialNumber;\r\nHostAdapter->Free_CCBs = CCB->Next;\r\nCCB->Next = NULL;\r\nif (HostAdapter->Free_CCBs == NULL)\r\nBusLogic_CreateAdditionalCCBs(HostAdapter, HostAdapter->IncrementalCCBs, true);\r\nreturn CCB;\r\n}\r\nBusLogic_CreateAdditionalCCBs(HostAdapter, HostAdapter->IncrementalCCBs, true);\r\nCCB = HostAdapter->Free_CCBs;\r\nif (CCB == NULL)\r\nreturn NULL;\r\nCCB->SerialNumber = ++SerialNumber;\r\nHostAdapter->Free_CCBs = CCB->Next;\r\nCCB->Next = NULL;\r\nreturn CCB;\r\n}\r\nstatic void BusLogic_DeallocateCCB(struct BusLogic_CCB *CCB)\r\n{\r\nstruct BusLogic_HostAdapter *HostAdapter = CCB->HostAdapter;\r\nscsi_dma_unmap(CCB->Command);\r\npci_unmap_single(HostAdapter->PCI_Device, CCB->SenseDataPointer,\r\nCCB->SenseDataLength, PCI_DMA_FROMDEVICE);\r\nCCB->Command = NULL;\r\nCCB->Status = BusLogic_CCB_Free;\r\nCCB->Next = HostAdapter->Free_CCBs;\r\nHostAdapter->Free_CCBs = CCB;\r\n}\r\nstatic int BusLogic_Command(struct BusLogic_HostAdapter *HostAdapter, enum BusLogic_OperationCode OperationCode, void *ParameterData, int ParameterLength, void *ReplyData, int ReplyLength)\r\n{\r\nunsigned char *ParameterPointer = (unsigned char *) ParameterData;\r\nunsigned char *ReplyPointer = (unsigned char *) ReplyData;\r\nunion BusLogic_StatusRegister StatusRegister;\r\nunion BusLogic_InterruptRegister InterruptRegister;\r\nunsigned long ProcessorFlags = 0;\r\nint ReplyBytes = 0, Result;\r\nlong TimeoutCounter;\r\nif (ReplyLength > 0)\r\nmemset(ReplyData, 0, ReplyLength);\r\nif (!HostAdapter->IRQ_ChannelAcquired)\r\nlocal_irq_save(ProcessorFlags);\r\nTimeoutCounter = 10000;\r\nwhile (--TimeoutCounter >= 0) {\r\nStatusRegister.All = BusLogic_ReadStatusRegister(HostAdapter);\r\nif (StatusRegister.sr.HostAdapterReady && !StatusRegister.sr.CommandParameterRegisterBusy)\r\nbreak;\r\nudelay(100);\r\n}\r\nif (TimeoutCounter < 0) {\r\nBusLogic_CommandFailureReason = "Timeout waiting for Host Adapter Ready";\r\nResult = -2;\r\ngoto Done;\r\n}\r\nHostAdapter->HostAdapterCommandCompleted = false;\r\nBusLogic_WriteCommandParameterRegister(HostAdapter, OperationCode);\r\nTimeoutCounter = 10000;\r\nwhile (ParameterLength > 0 && --TimeoutCounter >= 0) {\r\nudelay(100);\r\nInterruptRegister.All = BusLogic_ReadInterruptRegister(HostAdapter);\r\nStatusRegister.All = BusLogic_ReadStatusRegister(HostAdapter);\r\nif (InterruptRegister.ir.CommandComplete)\r\nbreak;\r\nif (HostAdapter->HostAdapterCommandCompleted)\r\nbreak;\r\nif (StatusRegister.sr.DataInRegisterReady)\r\nbreak;\r\nif (StatusRegister.sr.CommandParameterRegisterBusy)\r\ncontinue;\r\nBusLogic_WriteCommandParameterRegister(HostAdapter, *ParameterPointer++);\r\nParameterLength--;\r\n}\r\nif (TimeoutCounter < 0) {\r\nBusLogic_CommandFailureReason = "Timeout waiting for Parameter Acceptance";\r\nResult = -2;\r\ngoto Done;\r\n}\r\nif (OperationCode == BusLogic_ModifyIOAddress) {\r\nStatusRegister.All = BusLogic_ReadStatusRegister(HostAdapter);\r\nif (StatusRegister.sr.CommandInvalid) {\r\nBusLogic_CommandFailureReason = "Modify I/O Address Invalid";\r\nResult = -1;\r\ngoto Done;\r\n}\r\nif (BusLogic_GlobalOptions.TraceConfiguration)\r\nBusLogic_Notice("BusLogic_Command(%02X) Status = %02X: " "(Modify I/O Address)\n", HostAdapter, OperationCode, StatusRegister.All);\r\nResult = 0;\r\ngoto Done;\r\n}\r\nswitch (OperationCode) {\r\ncase BusLogic_InquireInstalledDevicesID0to7:\r\ncase BusLogic_InquireInstalledDevicesID8to15:\r\ncase BusLogic_InquireTargetDevices:\r\nTimeoutCounter = 60 * 10000;\r\nbreak;\r\ndefault:\r\nTimeoutCounter = 10000;\r\nbreak;\r\n}\r\nwhile (--TimeoutCounter >= 0) {\r\nInterruptRegister.All = BusLogic_ReadInterruptRegister(HostAdapter);\r\nStatusRegister.All = BusLogic_ReadStatusRegister(HostAdapter);\r\nif (InterruptRegister.ir.CommandComplete)\r\nbreak;\r\nif (HostAdapter->HostAdapterCommandCompleted)\r\nbreak;\r\nif (StatusRegister.sr.DataInRegisterReady) {\r\nif (++ReplyBytes <= ReplyLength)\r\n*ReplyPointer++ = BusLogic_ReadDataInRegister(HostAdapter);\r\nelse\r\nBusLogic_ReadDataInRegister(HostAdapter);\r\n}\r\nif (OperationCode == BusLogic_FetchHostAdapterLocalRAM && StatusRegister.sr.HostAdapterReady)\r\nbreak;\r\nudelay(100);\r\n}\r\nif (TimeoutCounter < 0) {\r\nBusLogic_CommandFailureReason = "Timeout waiting for Command Complete";\r\nResult = -2;\r\ngoto Done;\r\n}\r\nBusLogic_InterruptReset(HostAdapter);\r\nif (BusLogic_GlobalOptions.TraceConfiguration) {\r\nint i;\r\nBusLogic_Notice("BusLogic_Command(%02X) Status = %02X: %2d ==> %2d:", HostAdapter, OperationCode, StatusRegister.All, ReplyLength, ReplyBytes);\r\nif (ReplyLength > ReplyBytes)\r\nReplyLength = ReplyBytes;\r\nfor (i = 0; i < ReplyLength; i++)\r\nBusLogic_Notice(" %02X", HostAdapter, ((unsigned char *) ReplyData)[i]);\r\nBusLogic_Notice("\n", HostAdapter);\r\n}\r\nif (StatusRegister.sr.CommandInvalid) {\r\nudelay(1000);\r\nStatusRegister.All = BusLogic_ReadStatusRegister(HostAdapter);\r\nif (StatusRegister.sr.CommandInvalid ||\r\nStatusRegister.sr.Reserved ||\r\nStatusRegister.sr.DataInRegisterReady ||\r\nStatusRegister.sr.CommandParameterRegisterBusy || !StatusRegister.sr.HostAdapterReady || !StatusRegister.sr.InitializationRequired || StatusRegister.sr.DiagnosticActive || StatusRegister.sr.DiagnosticFailure) {\r\nBusLogic_SoftReset(HostAdapter);\r\nudelay(1000);\r\n}\r\nBusLogic_CommandFailureReason = "Command Invalid";\r\nResult = -1;\r\ngoto Done;\r\n}\r\nif (ParameterLength > 0) {\r\nBusLogic_CommandFailureReason = "Excess Parameters Supplied";\r\nResult = -1;\r\ngoto Done;\r\n}\r\nBusLogic_CommandFailureReason = NULL;\r\nResult = ReplyBytes;\r\nDone:\r\nif (!HostAdapter->IRQ_ChannelAcquired)\r\nlocal_irq_restore(ProcessorFlags);\r\nreturn Result;\r\n}\r\nstatic void __init BusLogic_AppendProbeAddressISA(unsigned long IO_Address)\r\n{\r\nstruct BusLogic_ProbeInfo *ProbeInfo;\r\nif (BusLogic_ProbeInfoCount >= BusLogic_MaxHostAdapters)\r\nreturn;\r\nProbeInfo = &BusLogic_ProbeInfoList[BusLogic_ProbeInfoCount++];\r\nProbeInfo->HostAdapterType = BusLogic_MultiMaster;\r\nProbeInfo->HostAdapterBusType = BusLogic_ISA_Bus;\r\nProbeInfo->IO_Address = IO_Address;\r\nProbeInfo->PCI_Device = NULL;\r\n}\r\nstatic void __init BusLogic_InitializeProbeInfoListISA(struct BusLogic_HostAdapter\r\n*PrototypeHostAdapter)\r\n{\r\nif (BusLogic_ProbeOptions.NoProbeISA)\r\nreturn;\r\nif (!BusLogic_ProbeOptions.LimitedProbeISA || BusLogic_ProbeOptions.Probe330)\r\nBusLogic_AppendProbeAddressISA(0x330);\r\nif (!BusLogic_ProbeOptions.LimitedProbeISA || BusLogic_ProbeOptions.Probe334)\r\nBusLogic_AppendProbeAddressISA(0x334);\r\nif (!BusLogic_ProbeOptions.LimitedProbeISA || BusLogic_ProbeOptions.Probe230)\r\nBusLogic_AppendProbeAddressISA(0x230);\r\nif (!BusLogic_ProbeOptions.LimitedProbeISA || BusLogic_ProbeOptions.Probe234)\r\nBusLogic_AppendProbeAddressISA(0x234);\r\nif (!BusLogic_ProbeOptions.LimitedProbeISA || BusLogic_ProbeOptions.Probe130)\r\nBusLogic_AppendProbeAddressISA(0x130);\r\nif (!BusLogic_ProbeOptions.LimitedProbeISA || BusLogic_ProbeOptions.Probe134)\r\nBusLogic_AppendProbeAddressISA(0x134);\r\n}\r\nstatic void __init BusLogic_SortProbeInfo(struct BusLogic_ProbeInfo *ProbeInfoList, int ProbeInfoCount)\r\n{\r\nint LastInterchange = ProbeInfoCount - 1, Bound, j;\r\nwhile (LastInterchange > 0) {\r\nBound = LastInterchange;\r\nLastInterchange = 0;\r\nfor (j = 0; j < Bound; j++) {\r\nstruct BusLogic_ProbeInfo *ProbeInfo1 = &ProbeInfoList[j];\r\nstruct BusLogic_ProbeInfo *ProbeInfo2 = &ProbeInfoList[j + 1];\r\nif (ProbeInfo1->Bus > ProbeInfo2->Bus || (ProbeInfo1->Bus == ProbeInfo2->Bus && (ProbeInfo1->Device > ProbeInfo2->Device))) {\r\nstruct BusLogic_ProbeInfo TempProbeInfo;\r\nmemcpy(&TempProbeInfo, ProbeInfo1, sizeof(struct BusLogic_ProbeInfo));\r\nmemcpy(ProbeInfo1, ProbeInfo2, sizeof(struct BusLogic_ProbeInfo));\r\nmemcpy(ProbeInfo2, &TempProbeInfo, sizeof(struct BusLogic_ProbeInfo));\r\nLastInterchange = j;\r\n}\r\n}\r\n}\r\n}\r\nstatic int __init BusLogic_InitializeMultiMasterProbeInfo(struct BusLogic_HostAdapter\r\n*PrototypeHostAdapter)\r\n{\r\nstruct BusLogic_ProbeInfo *PrimaryProbeInfo = &BusLogic_ProbeInfoList[BusLogic_ProbeInfoCount];\r\nint NonPrimaryPCIMultiMasterIndex = BusLogic_ProbeInfoCount + 1;\r\nint NonPrimaryPCIMultiMasterCount = 0, PCIMultiMasterCount = 0;\r\nbool ForceBusDeviceScanningOrder = false;\r\nbool ForceBusDeviceScanningOrderChecked = false;\r\nbool StandardAddressSeen[6];\r\nstruct pci_dev *PCI_Device = NULL;\r\nint i;\r\nif (BusLogic_ProbeInfoCount >= BusLogic_MaxHostAdapters)\r\nreturn 0;\r\nBusLogic_ProbeInfoCount++;\r\nfor (i = 0; i < 6; i++)\r\nStandardAddressSeen[i] = false;\r\nPrimaryProbeInfo->IO_Address = 0;\r\nwhile ((PCI_Device = pci_get_device(PCI_VENDOR_ID_BUSLOGIC, PCI_DEVICE_ID_BUSLOGIC_MULTIMASTER, PCI_Device)) != NULL) {\r\nstruct BusLogic_HostAdapter *HostAdapter = PrototypeHostAdapter;\r\nstruct BusLogic_PCIHostAdapterInformation PCIHostAdapterInformation;\r\nenum BusLogic_ISACompatibleIOPort ModifyIOAddressRequest;\r\nunsigned char Bus;\r\nunsigned char Device;\r\nunsigned int IRQ_Channel;\r\nunsigned long BaseAddress0;\r\nunsigned long BaseAddress1;\r\nunsigned long IO_Address;\r\nunsigned long PCI_Address;\r\nif (pci_enable_device(PCI_Device))\r\ncontinue;\r\nif (pci_set_dma_mask(PCI_Device, DMA_BIT_MASK(32) ))\r\ncontinue;\r\nBus = PCI_Device->bus->number;\r\nDevice = PCI_Device->devfn >> 3;\r\nIRQ_Channel = PCI_Device->irq;\r\nIO_Address = BaseAddress0 = pci_resource_start(PCI_Device, 0);\r\nPCI_Address = BaseAddress1 = pci_resource_start(PCI_Device, 1);\r\nif (pci_resource_flags(PCI_Device, 0) & IORESOURCE_MEM) {\r\nBusLogic_Error("BusLogic: Base Address0 0x%X not I/O for " "MultiMaster Host Adapter\n", NULL, BaseAddress0);\r\nBusLogic_Error("at PCI Bus %d Device %d I/O Address 0x%X\n", NULL, Bus, Device, IO_Address);\r\ncontinue;\r\n}\r\nif (pci_resource_flags(PCI_Device, 1) & IORESOURCE_IO) {\r\nBusLogic_Error("BusLogic: Base Address1 0x%X not Memory for " "MultiMaster Host Adapter\n", NULL, BaseAddress1);\r\nBusLogic_Error("at PCI Bus %d Device %d PCI Address 0x%X\n", NULL, Bus, Device, PCI_Address);\r\ncontinue;\r\n}\r\nif (IRQ_Channel == 0) {\r\nBusLogic_Error("BusLogic: IRQ Channel %d invalid for " "MultiMaster Host Adapter\n", NULL, IRQ_Channel);\r\nBusLogic_Error("at PCI Bus %d Device %d I/O Address 0x%X\n", NULL, Bus, Device, IO_Address);\r\ncontinue;\r\n}\r\nif (BusLogic_GlobalOptions.TraceProbe) {\r\nBusLogic_Notice("BusLogic: PCI MultiMaster Host Adapter " "detected at\n", NULL);\r\nBusLogic_Notice("BusLogic: PCI Bus %d Device %d I/O Address " "0x%X PCI Address 0x%X\n", NULL, Bus, Device, IO_Address, PCI_Address);\r\n}\r\nHostAdapter->IO_Address = IO_Address;\r\nBusLogic_InterruptReset(HostAdapter);\r\nif (BusLogic_Command(HostAdapter, BusLogic_InquirePCIHostAdapterInformation, NULL, 0, &PCIHostAdapterInformation, sizeof(PCIHostAdapterInformation))\r\n== sizeof(PCIHostAdapterInformation)) {\r\nif (PCIHostAdapterInformation.ISACompatibleIOPort < 6)\r\nStandardAddressSeen[PCIHostAdapterInformation.ISACompatibleIOPort] = true;\r\n} else\r\nPCIHostAdapterInformation.ISACompatibleIOPort = BusLogic_IO_Disable;\r\nModifyIOAddressRequest = BusLogic_IO_Disable;\r\nBusLogic_Command(HostAdapter, BusLogic_ModifyIOAddress, &ModifyIOAddressRequest, sizeof(ModifyIOAddressRequest), NULL, 0);\r\nif (!ForceBusDeviceScanningOrderChecked) {\r\nstruct BusLogic_FetchHostAdapterLocalRAMRequest FetchHostAdapterLocalRAMRequest;\r\nstruct BusLogic_AutoSCSIByte45 AutoSCSIByte45;\r\nstruct BusLogic_BoardID BoardID;\r\nFetchHostAdapterLocalRAMRequest.ByteOffset = BusLogic_AutoSCSI_BaseOffset + 45;\r\nFetchHostAdapterLocalRAMRequest.ByteCount = sizeof(AutoSCSIByte45);\r\nBusLogic_Command(HostAdapter, BusLogic_FetchHostAdapterLocalRAM, &FetchHostAdapterLocalRAMRequest, sizeof(FetchHostAdapterLocalRAMRequest), &AutoSCSIByte45, sizeof(AutoSCSIByte45));\r\nBusLogic_Command(HostAdapter, BusLogic_InquireBoardID, NULL, 0, &BoardID, sizeof(BoardID));\r\nif (BoardID.FirmwareVersion1stDigit == '5')\r\nForceBusDeviceScanningOrder = AutoSCSIByte45.ForceBusDeviceScanningOrder;\r\nForceBusDeviceScanningOrderChecked = true;\r\n}\r\nif (PCIHostAdapterInformation.ISACompatibleIOPort == BusLogic_IO_330) {\r\nPrimaryProbeInfo->HostAdapterType = BusLogic_MultiMaster;\r\nPrimaryProbeInfo->HostAdapterBusType = BusLogic_PCI_Bus;\r\nPrimaryProbeInfo->IO_Address = IO_Address;\r\nPrimaryProbeInfo->PCI_Address = PCI_Address;\r\nPrimaryProbeInfo->Bus = Bus;\r\nPrimaryProbeInfo->Device = Device;\r\nPrimaryProbeInfo->IRQ_Channel = IRQ_Channel;\r\nPrimaryProbeInfo->PCI_Device = pci_dev_get(PCI_Device);\r\nPCIMultiMasterCount++;\r\n} else if (BusLogic_ProbeInfoCount < BusLogic_MaxHostAdapters) {\r\nstruct BusLogic_ProbeInfo *ProbeInfo = &BusLogic_ProbeInfoList[BusLogic_ProbeInfoCount++];\r\nProbeInfo->HostAdapterType = BusLogic_MultiMaster;\r\nProbeInfo->HostAdapterBusType = BusLogic_PCI_Bus;\r\nProbeInfo->IO_Address = IO_Address;\r\nProbeInfo->PCI_Address = PCI_Address;\r\nProbeInfo->Bus = Bus;\r\nProbeInfo->Device = Device;\r\nProbeInfo->IRQ_Channel = IRQ_Channel;\r\nProbeInfo->PCI_Device = pci_dev_get(PCI_Device);\r\nNonPrimaryPCIMultiMasterCount++;\r\nPCIMultiMasterCount++;\r\n} else\r\nBusLogic_Warning("BusLogic: Too many Host Adapters " "detected\n", NULL);\r\n}\r\nif (ForceBusDeviceScanningOrder)\r\nBusLogic_SortProbeInfo(&BusLogic_ProbeInfoList[NonPrimaryPCIMultiMasterIndex], NonPrimaryPCIMultiMasterCount);\r\nif (!BusLogic_ProbeOptions.NoProbeISA)\r\nif (PrimaryProbeInfo->IO_Address == 0 &&\r\n(!BusLogic_ProbeOptions.LimitedProbeISA ||\r\nBusLogic_ProbeOptions.Probe330)) {\r\nPrimaryProbeInfo->HostAdapterType = BusLogic_MultiMaster;\r\nPrimaryProbeInfo->HostAdapterBusType = BusLogic_ISA_Bus;\r\nPrimaryProbeInfo->IO_Address = 0x330;\r\n}\r\nif (!BusLogic_ProbeOptions.NoProbeISA) {\r\nif (!StandardAddressSeen[1] &&\r\n(!BusLogic_ProbeOptions.LimitedProbeISA ||\r\nBusLogic_ProbeOptions.Probe334))\r\nBusLogic_AppendProbeAddressISA(0x334);\r\nif (!StandardAddressSeen[2] &&\r\n(!BusLogic_ProbeOptions.LimitedProbeISA ||\r\nBusLogic_ProbeOptions.Probe230))\r\nBusLogic_AppendProbeAddressISA(0x230);\r\nif (!StandardAddressSeen[3] &&\r\n(!BusLogic_ProbeOptions.LimitedProbeISA ||\r\nBusLogic_ProbeOptions.Probe234))\r\nBusLogic_AppendProbeAddressISA(0x234);\r\nif (!StandardAddressSeen[4] &&\r\n(!BusLogic_ProbeOptions.LimitedProbeISA ||\r\nBusLogic_ProbeOptions.Probe130))\r\nBusLogic_AppendProbeAddressISA(0x130);\r\nif (!StandardAddressSeen[5] &&\r\n(!BusLogic_ProbeOptions.LimitedProbeISA ||\r\nBusLogic_ProbeOptions.Probe134))\r\nBusLogic_AppendProbeAddressISA(0x134);\r\n}\r\nPCI_Device = NULL;\r\nwhile ((PCI_Device = pci_get_device(PCI_VENDOR_ID_BUSLOGIC, PCI_DEVICE_ID_BUSLOGIC_MULTIMASTER_NC, PCI_Device)) != NULL) {\r\nunsigned char Bus;\r\nunsigned char Device;\r\nunsigned int IRQ_Channel;\r\nunsigned long IO_Address;\r\nif (pci_enable_device(PCI_Device))\r\ncontinue;\r\nif (pci_set_dma_mask(PCI_Device, DMA_BIT_MASK(32)))\r\ncontinue;\r\nBus = PCI_Device->bus->number;\r\nDevice = PCI_Device->devfn >> 3;\r\nIRQ_Channel = PCI_Device->irq;\r\nIO_Address = pci_resource_start(PCI_Device, 0);\r\nif (IO_Address == 0 || IRQ_Channel == 0)\r\ncontinue;\r\nfor (i = 0; i < BusLogic_ProbeInfoCount; i++) {\r\nstruct BusLogic_ProbeInfo *ProbeInfo = &BusLogic_ProbeInfoList[i];\r\nif (ProbeInfo->IO_Address == IO_Address && ProbeInfo->HostAdapterType == BusLogic_MultiMaster) {\r\nProbeInfo->HostAdapterBusType = BusLogic_PCI_Bus;\r\nProbeInfo->PCI_Address = 0;\r\nProbeInfo->Bus = Bus;\r\nProbeInfo->Device = Device;\r\nProbeInfo->IRQ_Channel = IRQ_Channel;\r\nProbeInfo->PCI_Device = pci_dev_get(PCI_Device);\r\nbreak;\r\n}\r\n}\r\n}\r\nreturn PCIMultiMasterCount;\r\n}\r\nstatic int __init BusLogic_InitializeFlashPointProbeInfo(struct BusLogic_HostAdapter\r\n*PrototypeHostAdapter)\r\n{\r\nint FlashPointIndex = BusLogic_ProbeInfoCount, FlashPointCount = 0;\r\nstruct pci_dev *PCI_Device = NULL;\r\nwhile ((PCI_Device = pci_get_device(PCI_VENDOR_ID_BUSLOGIC, PCI_DEVICE_ID_BUSLOGIC_FLASHPOINT, PCI_Device)) != NULL) {\r\nunsigned char Bus;\r\nunsigned char Device;\r\nunsigned int IRQ_Channel;\r\nunsigned long BaseAddress0;\r\nunsigned long BaseAddress1;\r\nunsigned long IO_Address;\r\nunsigned long PCI_Address;\r\nif (pci_enable_device(PCI_Device))\r\ncontinue;\r\nif (pci_set_dma_mask(PCI_Device, DMA_BIT_MASK(32)))\r\ncontinue;\r\nBus = PCI_Device->bus->number;\r\nDevice = PCI_Device->devfn >> 3;\r\nIRQ_Channel = PCI_Device->irq;\r\nIO_Address = BaseAddress0 = pci_resource_start(PCI_Device, 0);\r\nPCI_Address = BaseAddress1 = pci_resource_start(PCI_Device, 1);\r\n#ifdef CONFIG_SCSI_FLASHPOINT\r\nif (pci_resource_flags(PCI_Device, 0) & IORESOURCE_MEM) {\r\nBusLogic_Error("BusLogic: Base Address0 0x%X not I/O for " "FlashPoint Host Adapter\n", NULL, BaseAddress0);\r\nBusLogic_Error("at PCI Bus %d Device %d I/O Address 0x%X\n", NULL, Bus, Device, IO_Address);\r\ncontinue;\r\n}\r\nif (pci_resource_flags(PCI_Device, 1) & IORESOURCE_IO) {\r\nBusLogic_Error("BusLogic: Base Address1 0x%X not Memory for " "FlashPoint Host Adapter\n", NULL, BaseAddress1);\r\nBusLogic_Error("at PCI Bus %d Device %d PCI Address 0x%X\n", NULL, Bus, Device, PCI_Address);\r\ncontinue;\r\n}\r\nif (IRQ_Channel == 0) {\r\nBusLogic_Error("BusLogic: IRQ Channel %d invalid for " "FlashPoint Host Adapter\n", NULL, IRQ_Channel);\r\nBusLogic_Error("at PCI Bus %d Device %d I/O Address 0x%X\n", NULL, Bus, Device, IO_Address);\r\ncontinue;\r\n}\r\nif (BusLogic_GlobalOptions.TraceProbe) {\r\nBusLogic_Notice("BusLogic: FlashPoint Host Adapter " "detected at\n", NULL);\r\nBusLogic_Notice("BusLogic: PCI Bus %d Device %d I/O Address " "0x%X PCI Address 0x%X\n", NULL, Bus, Device, IO_Address, PCI_Address);\r\n}\r\nif (BusLogic_ProbeInfoCount < BusLogic_MaxHostAdapters) {\r\nstruct BusLogic_ProbeInfo *ProbeInfo = &BusLogic_ProbeInfoList[BusLogic_ProbeInfoCount++];\r\nProbeInfo->HostAdapterType = BusLogic_FlashPoint;\r\nProbeInfo->HostAdapterBusType = BusLogic_PCI_Bus;\r\nProbeInfo->IO_Address = IO_Address;\r\nProbeInfo->PCI_Address = PCI_Address;\r\nProbeInfo->Bus = Bus;\r\nProbeInfo->Device = Device;\r\nProbeInfo->IRQ_Channel = IRQ_Channel;\r\nProbeInfo->PCI_Device = pci_dev_get(PCI_Device);\r\nFlashPointCount++;\r\n} else\r\nBusLogic_Warning("BusLogic: Too many Host Adapters " "detected\n", NULL);\r\n#else\r\nBusLogic_Error("BusLogic: FlashPoint Host Adapter detected at " "PCI Bus %d Device %d\n", NULL, Bus, Device);\r\nBusLogic_Error("BusLogic: I/O Address 0x%X PCI Address 0x%X, irq %d, " "but FlashPoint\n", NULL, IO_Address, PCI_Address, IRQ_Channel);\r\nBusLogic_Error("BusLogic: support was omitted in this kernel " "configuration.\n", NULL);\r\n#endif\r\n}\r\nBusLogic_SortProbeInfo(&BusLogic_ProbeInfoList[FlashPointIndex], FlashPointCount);\r\nreturn FlashPointCount;\r\n}\r\nstatic void __init BusLogic_InitializeProbeInfoList(struct BusLogic_HostAdapter\r\n*PrototypeHostAdapter)\r\n{\r\nif (!BusLogic_ProbeOptions.NoProbePCI) {\r\nif (BusLogic_ProbeOptions.MultiMasterFirst) {\r\nBusLogic_InitializeMultiMasterProbeInfo(PrototypeHostAdapter);\r\nBusLogic_InitializeFlashPointProbeInfo(PrototypeHostAdapter);\r\n} else if (BusLogic_ProbeOptions.FlashPointFirst) {\r\nBusLogic_InitializeFlashPointProbeInfo(PrototypeHostAdapter);\r\nBusLogic_InitializeMultiMasterProbeInfo(PrototypeHostAdapter);\r\n} else {\r\nint FlashPointCount = BusLogic_InitializeFlashPointProbeInfo(PrototypeHostAdapter);\r\nint PCIMultiMasterCount = BusLogic_InitializeMultiMasterProbeInfo(PrototypeHostAdapter);\r\nif (FlashPointCount > 0 && PCIMultiMasterCount > 0) {\r\nstruct BusLogic_ProbeInfo *ProbeInfo = &BusLogic_ProbeInfoList[FlashPointCount];\r\nstruct BusLogic_HostAdapter *HostAdapter = PrototypeHostAdapter;\r\nstruct BusLogic_FetchHostAdapterLocalRAMRequest FetchHostAdapterLocalRAMRequest;\r\nstruct BusLogic_BIOSDriveMapByte Drive0MapByte;\r\nwhile (ProbeInfo->HostAdapterBusType != BusLogic_PCI_Bus)\r\nProbeInfo++;\r\nHostAdapter->IO_Address = ProbeInfo->IO_Address;\r\nFetchHostAdapterLocalRAMRequest.ByteOffset = BusLogic_BIOS_BaseOffset + BusLogic_BIOS_DriveMapOffset + 0;\r\nFetchHostAdapterLocalRAMRequest.ByteCount = sizeof(Drive0MapByte);\r\nBusLogic_Command(HostAdapter, BusLogic_FetchHostAdapterLocalRAM, &FetchHostAdapterLocalRAMRequest, sizeof(FetchHostAdapterLocalRAMRequest), &Drive0MapByte, sizeof(Drive0MapByte));\r\nif (Drive0MapByte.DiskGeometry != BusLogic_BIOS_Disk_Not_Installed) {\r\nstruct BusLogic_ProbeInfo SavedProbeInfo[BusLogic_MaxHostAdapters];\r\nint MultiMasterCount = BusLogic_ProbeInfoCount - FlashPointCount;\r\nmemcpy(SavedProbeInfo, BusLogic_ProbeInfoList, BusLogic_ProbeInfoCount * sizeof(struct BusLogic_ProbeInfo));\r\nmemcpy(&BusLogic_ProbeInfoList[0], &SavedProbeInfo[FlashPointCount], MultiMasterCount * sizeof(struct BusLogic_ProbeInfo));\r\nmemcpy(&BusLogic_ProbeInfoList[MultiMasterCount], &SavedProbeInfo[0], FlashPointCount * sizeof(struct BusLogic_ProbeInfo));\r\n}\r\n}\r\n}\r\n} else\r\nBusLogic_InitializeProbeInfoListISA(PrototypeHostAdapter);\r\n}\r\nstatic bool BusLogic_Failure(struct BusLogic_HostAdapter *HostAdapter, char *ErrorMessage)\r\n{\r\nBusLogic_AnnounceDriver(HostAdapter);\r\nif (HostAdapter->HostAdapterBusType == BusLogic_PCI_Bus) {\r\nBusLogic_Error("While configuring BusLogic PCI Host Adapter at\n", HostAdapter);\r\nBusLogic_Error("Bus %d Device %d I/O Address 0x%X PCI Address 0x%X:\n", HostAdapter, HostAdapter->Bus, HostAdapter->Device, HostAdapter->IO_Address, HostAdapter->PCI_Address);\r\n} else\r\nBusLogic_Error("While configuring BusLogic Host Adapter at " "I/O Address 0x%X:\n", HostAdapter, HostAdapter->IO_Address);\r\nBusLogic_Error("%s FAILED - DETACHING\n", HostAdapter, ErrorMessage);\r\nif (BusLogic_CommandFailureReason != NULL)\r\nBusLogic_Error("ADDITIONAL FAILURE INFO - %s\n", HostAdapter, BusLogic_CommandFailureReason);\r\nreturn false;\r\n}\r\nstatic bool __init BusLogic_ProbeHostAdapter(struct BusLogic_HostAdapter *HostAdapter)\r\n{\r\nunion BusLogic_StatusRegister StatusRegister;\r\nunion BusLogic_InterruptRegister InterruptRegister;\r\nunion BusLogic_GeometryRegister GeometryRegister;\r\nif (BusLogic_FlashPointHostAdapterP(HostAdapter)) {\r\nstruct FlashPoint_Info *FlashPointInfo = &HostAdapter->FlashPointInfo;\r\nFlashPointInfo->BaseAddress = (u32) HostAdapter->IO_Address;\r\nFlashPointInfo->IRQ_Channel = HostAdapter->IRQ_Channel;\r\nFlashPointInfo->Present = false;\r\nif (!(FlashPoint_ProbeHostAdapter(FlashPointInfo) == 0 && FlashPointInfo->Present)) {\r\nBusLogic_Error("BusLogic: FlashPoint Host Adapter detected at " "PCI Bus %d Device %d\n", HostAdapter, HostAdapter->Bus, HostAdapter->Device);\r\nBusLogic_Error("BusLogic: I/O Address 0x%X PCI Address 0x%X, " "but FlashPoint\n", HostAdapter, HostAdapter->IO_Address, HostAdapter->PCI_Address);\r\nBusLogic_Error("BusLogic: Probe Function failed to validate it.\n", HostAdapter);\r\nreturn false;\r\n}\r\nif (BusLogic_GlobalOptions.TraceProbe)\r\nBusLogic_Notice("BusLogic_Probe(0x%X): FlashPoint Found\n", HostAdapter, HostAdapter->IO_Address);\r\nreturn true;\r\n}\r\nStatusRegister.All = BusLogic_ReadStatusRegister(HostAdapter);\r\nInterruptRegister.All = BusLogic_ReadInterruptRegister(HostAdapter);\r\nGeometryRegister.All = BusLogic_ReadGeometryRegister(HostAdapter);\r\nif (BusLogic_GlobalOptions.TraceProbe)\r\nBusLogic_Notice("BusLogic_Probe(0x%X): Status 0x%02X, Interrupt 0x%02X, " "Geometry 0x%02X\n", HostAdapter, HostAdapter->IO_Address, StatusRegister.All, InterruptRegister.All, GeometryRegister.All);\r\nif (StatusRegister.All == 0 || StatusRegister.sr.DiagnosticActive || StatusRegister.sr.CommandParameterRegisterBusy || StatusRegister.sr.Reserved || StatusRegister.sr.CommandInvalid || InterruptRegister.ir.Reserved != 0)\r\nreturn false;\r\nif (GeometryRegister.All == 0xFF)\r\nreturn false;\r\nreturn true;\r\n}\r\nstatic bool BusLogic_HardwareResetHostAdapter(struct BusLogic_HostAdapter\r\n*HostAdapter, bool HardReset)\r\n{\r\nunion BusLogic_StatusRegister StatusRegister;\r\nint TimeoutCounter;\r\nif (BusLogic_FlashPointHostAdapterP(HostAdapter)) {\r\nstruct FlashPoint_Info *FlashPointInfo = &HostAdapter->FlashPointInfo;\r\nFlashPointInfo->HostSoftReset = !HardReset;\r\nFlashPointInfo->ReportDataUnderrun = true;\r\nHostAdapter->CardHandle = FlashPoint_HardwareResetHostAdapter(FlashPointInfo);\r\nif (HostAdapter->CardHandle == FlashPoint_BadCardHandle)\r\nreturn false;\r\nreturn true;\r\n}\r\nif (HardReset)\r\nBusLogic_HardReset(HostAdapter);\r\nelse\r\nBusLogic_SoftReset(HostAdapter);\r\nTimeoutCounter = 5 * 10000;\r\nwhile (--TimeoutCounter >= 0) {\r\nStatusRegister.All = BusLogic_ReadStatusRegister(HostAdapter);\r\nif (StatusRegister.sr.DiagnosticActive)\r\nbreak;\r\nudelay(100);\r\n}\r\nif (BusLogic_GlobalOptions.TraceHardwareReset)\r\nBusLogic_Notice("BusLogic_HardwareReset(0x%X): Diagnostic Active, " "Status 0x%02X\n", HostAdapter, HostAdapter->IO_Address, StatusRegister.All);\r\nif (TimeoutCounter < 0)\r\nreturn false;\r\nudelay(100);\r\nTimeoutCounter = 10 * 10000;\r\nwhile (--TimeoutCounter >= 0) {\r\nStatusRegister.All = BusLogic_ReadStatusRegister(HostAdapter);\r\nif (!StatusRegister.sr.DiagnosticActive)\r\nbreak;\r\nudelay(100);\r\n}\r\nif (BusLogic_GlobalOptions.TraceHardwareReset)\r\nBusLogic_Notice("BusLogic_HardwareReset(0x%X): Diagnostic Completed, " "Status 0x%02X\n", HostAdapter, HostAdapter->IO_Address, StatusRegister.All);\r\nif (TimeoutCounter < 0)\r\nreturn false;\r\nTimeoutCounter = 10000;\r\nwhile (--TimeoutCounter >= 0) {\r\nStatusRegister.All = BusLogic_ReadStatusRegister(HostAdapter);\r\nif (StatusRegister.sr.DiagnosticFailure || StatusRegister.sr.HostAdapterReady || StatusRegister.sr.DataInRegisterReady)\r\nbreak;\r\nudelay(100);\r\n}\r\nif (BusLogic_GlobalOptions.TraceHardwareReset)\r\nBusLogic_Notice("BusLogic_HardwareReset(0x%X): Host Adapter Ready, " "Status 0x%02X\n", HostAdapter, HostAdapter->IO_Address, StatusRegister.All);\r\nif (TimeoutCounter < 0)\r\nreturn false;\r\nif (StatusRegister.sr.DiagnosticFailure || !StatusRegister.sr.HostAdapterReady) {\r\nBusLogic_CommandFailureReason = NULL;\r\nBusLogic_Failure(HostAdapter, "HARD RESET DIAGNOSTICS");\r\nBusLogic_Error("HOST ADAPTER STATUS REGISTER = %02X\n", HostAdapter, StatusRegister.All);\r\nif (StatusRegister.sr.DataInRegisterReady) {\r\nunsigned char ErrorCode = BusLogic_ReadDataInRegister(HostAdapter);\r\nBusLogic_Error("HOST ADAPTER ERROR CODE = %d\n", HostAdapter, ErrorCode);\r\n}\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\nstatic bool __init BusLogic_CheckHostAdapter(struct BusLogic_HostAdapter *HostAdapter)\r\n{\r\nstruct BusLogic_ExtendedSetupInformation ExtendedSetupInformation;\r\nunsigned char RequestedReplyLength;\r\nbool Result = true;\r\nif (BusLogic_FlashPointHostAdapterP(HostAdapter))\r\nreturn true;\r\nRequestedReplyLength = sizeof(ExtendedSetupInformation);\r\nif (BusLogic_Command(HostAdapter, BusLogic_InquireExtendedSetupInformation, &RequestedReplyLength, sizeof(RequestedReplyLength), &ExtendedSetupInformation, sizeof(ExtendedSetupInformation))\r\n!= sizeof(ExtendedSetupInformation))\r\nResult = false;\r\nif (BusLogic_GlobalOptions.TraceProbe)\r\nBusLogic_Notice("BusLogic_Check(0x%X): MultiMaster %s\n", HostAdapter, HostAdapter->IO_Address, (Result ? "Found" : "Not Found"));\r\nreturn Result;\r\n}\r\nstatic bool __init BusLogic_ReadHostAdapterConfiguration(struct BusLogic_HostAdapter\r\n*HostAdapter)\r\n{\r\nstruct BusLogic_BoardID BoardID;\r\nstruct BusLogic_Configuration Configuration;\r\nstruct BusLogic_SetupInformation SetupInformation;\r\nstruct BusLogic_ExtendedSetupInformation ExtendedSetupInformation;\r\nunsigned char HostAdapterModelNumber[5];\r\nunsigned char FirmwareVersion3rdDigit;\r\nunsigned char FirmwareVersionLetter;\r\nstruct BusLogic_PCIHostAdapterInformation PCIHostAdapterInformation;\r\nstruct BusLogic_FetchHostAdapterLocalRAMRequest FetchHostAdapterLocalRAMRequest;\r\nstruct BusLogic_AutoSCSIData AutoSCSIData;\r\nunion BusLogic_GeometryRegister GeometryRegister;\r\nunsigned char RequestedReplyLength;\r\nunsigned char *TargetPointer, Character;\r\nint TargetID, i;\r\nif (BusLogic_FlashPointHostAdapterP(HostAdapter)) {\r\nstruct FlashPoint_Info *FlashPointInfo = &HostAdapter->FlashPointInfo;\r\nTargetPointer = HostAdapter->ModelName;\r\n*TargetPointer++ = 'B';\r\n*TargetPointer++ = 'T';\r\n*TargetPointer++ = '-';\r\nfor (i = 0; i < sizeof(FlashPointInfo->ModelNumber); i++)\r\n*TargetPointer++ = FlashPointInfo->ModelNumber[i];\r\n*TargetPointer++ = '\0';\r\nstrcpy(HostAdapter->FirmwareVersion, FlashPoint_FirmwareVersion);\r\nHostAdapter->SCSI_ID = FlashPointInfo->SCSI_ID;\r\nHostAdapter->ExtendedTranslationEnabled = FlashPointInfo->ExtendedTranslationEnabled;\r\nHostAdapter->ParityCheckingEnabled = FlashPointInfo->ParityCheckingEnabled;\r\nHostAdapter->BusResetEnabled = !FlashPointInfo->HostSoftReset;\r\nHostAdapter->LevelSensitiveInterrupt = true;\r\nHostAdapter->HostWideSCSI = FlashPointInfo->HostWideSCSI;\r\nHostAdapter->HostDifferentialSCSI = false;\r\nHostAdapter->HostSupportsSCAM = true;\r\nHostAdapter->HostUltraSCSI = true;\r\nHostAdapter->ExtendedLUNSupport = true;\r\nHostAdapter->TerminationInfoValid = true;\r\nHostAdapter->LowByteTerminated = FlashPointInfo->LowByteTerminated;\r\nHostAdapter->HighByteTerminated = FlashPointInfo->HighByteTerminated;\r\nHostAdapter->SCAM_Enabled = FlashPointInfo->SCAM_Enabled;\r\nHostAdapter->SCAM_Level2 = FlashPointInfo->SCAM_Level2;\r\nHostAdapter->DriverScatterGatherLimit = BusLogic_ScatterGatherLimit;\r\nHostAdapter->MaxTargetDevices = (HostAdapter->HostWideSCSI ? 16 : 8);\r\nHostAdapter->MaxLogicalUnits = 32;\r\nHostAdapter->InitialCCBs = 4 * BusLogic_CCB_AllocationGroupSize;\r\nHostAdapter->IncrementalCCBs = BusLogic_CCB_AllocationGroupSize;\r\nHostAdapter->DriverQueueDepth = 255;\r\nHostAdapter->HostAdapterQueueDepth = HostAdapter->DriverQueueDepth;\r\nHostAdapter->SynchronousPermitted = FlashPointInfo->SynchronousPermitted;\r\nHostAdapter->FastPermitted = FlashPointInfo->FastPermitted;\r\nHostAdapter->UltraPermitted = FlashPointInfo->UltraPermitted;\r\nHostAdapter->WidePermitted = FlashPointInfo->WidePermitted;\r\nHostAdapter->DisconnectPermitted = FlashPointInfo->DisconnectPermitted;\r\nHostAdapter->TaggedQueuingPermitted = 0xFFFF;\r\ngoto Common;\r\n}\r\nif (BusLogic_Command(HostAdapter, BusLogic_InquireBoardID, NULL, 0, &BoardID, sizeof(BoardID)) != sizeof(BoardID))\r\nreturn BusLogic_Failure(HostAdapter, "INQUIRE BOARD ID");\r\nif (BusLogic_Command(HostAdapter, BusLogic_InquireConfiguration, NULL, 0, &Configuration, sizeof(Configuration))\r\n!= sizeof(Configuration))\r\nreturn BusLogic_Failure(HostAdapter, "INQUIRE CONFIGURATION");\r\nRequestedReplyLength = sizeof(SetupInformation);\r\nif (BusLogic_Command(HostAdapter, BusLogic_InquireSetupInformation, &RequestedReplyLength, sizeof(RequestedReplyLength), &SetupInformation, sizeof(SetupInformation))\r\n!= sizeof(SetupInformation))\r\nreturn BusLogic_Failure(HostAdapter, "INQUIRE SETUP INFORMATION");\r\nRequestedReplyLength = sizeof(ExtendedSetupInformation);\r\nif (BusLogic_Command(HostAdapter, BusLogic_InquireExtendedSetupInformation, &RequestedReplyLength, sizeof(RequestedReplyLength), &ExtendedSetupInformation, sizeof(ExtendedSetupInformation))\r\n!= sizeof(ExtendedSetupInformation))\r\nreturn BusLogic_Failure(HostAdapter, "INQUIRE EXTENDED SETUP INFORMATION");\r\nFirmwareVersion3rdDigit = '\0';\r\nif (BoardID.FirmwareVersion1stDigit > '0')\r\nif (BusLogic_Command(HostAdapter, BusLogic_InquireFirmwareVersion3rdDigit, NULL, 0, &FirmwareVersion3rdDigit, sizeof(FirmwareVersion3rdDigit))\r\n!= sizeof(FirmwareVersion3rdDigit))\r\nreturn BusLogic_Failure(HostAdapter, "INQUIRE FIRMWARE 3RD DIGIT");\r\nif (ExtendedSetupInformation.BusType == 'A' && BoardID.FirmwareVersion1stDigit == '2')\r\nstrcpy(HostAdapterModelNumber, "542B");\r\nelse if (ExtendedSetupInformation.BusType == 'E' && BoardID.FirmwareVersion1stDigit == '2' && (BoardID.FirmwareVersion2ndDigit <= '1' || (BoardID.FirmwareVersion2ndDigit == '2' && FirmwareVersion3rdDigit == '0')))\r\nstrcpy(HostAdapterModelNumber, "742A");\r\nelse if (ExtendedSetupInformation.BusType == 'E' && BoardID.FirmwareVersion1stDigit == '0')\r\nstrcpy(HostAdapterModelNumber, "747A");\r\nelse {\r\nRequestedReplyLength = sizeof(HostAdapterModelNumber);\r\nif (BusLogic_Command(HostAdapter, BusLogic_InquireHostAdapterModelNumber, &RequestedReplyLength, sizeof(RequestedReplyLength), &HostAdapterModelNumber, sizeof(HostAdapterModelNumber))\r\n!= sizeof(HostAdapterModelNumber))\r\nreturn BusLogic_Failure(HostAdapter, "INQUIRE HOST ADAPTER MODEL NUMBER");\r\n}\r\nTargetPointer = HostAdapter->ModelName;\r\n*TargetPointer++ = 'B';\r\n*TargetPointer++ = 'T';\r\n*TargetPointer++ = '-';\r\nfor (i = 0; i < sizeof(HostAdapterModelNumber); i++) {\r\nCharacter = HostAdapterModelNumber[i];\r\nif (Character == ' ' || Character == '\0')\r\nbreak;\r\n*TargetPointer++ = Character;\r\n}\r\n*TargetPointer++ = '\0';\r\nTargetPointer = HostAdapter->FirmwareVersion;\r\n*TargetPointer++ = BoardID.FirmwareVersion1stDigit;\r\n*TargetPointer++ = '.';\r\n*TargetPointer++ = BoardID.FirmwareVersion2ndDigit;\r\nif (FirmwareVersion3rdDigit != ' ' && FirmwareVersion3rdDigit != '\0')\r\n*TargetPointer++ = FirmwareVersion3rdDigit;\r\n*TargetPointer = '\0';\r\nif (strcmp(HostAdapter->FirmwareVersion, "3.3") >= 0) {\r\nif (BusLogic_Command(HostAdapter, BusLogic_InquireFirmwareVersionLetter, NULL, 0, &FirmwareVersionLetter, sizeof(FirmwareVersionLetter))\r\n!= sizeof(FirmwareVersionLetter))\r\nreturn BusLogic_Failure(HostAdapter, "INQUIRE FIRMWARE VERSION LETTER");\r\nif (FirmwareVersionLetter != ' ' && FirmwareVersionLetter != '\0')\r\n*TargetPointer++ = FirmwareVersionLetter;\r\n*TargetPointer = '\0';\r\n}\r\nHostAdapter->SCSI_ID = Configuration.HostAdapterID;\r\nHostAdapter->HostAdapterBusType = BusLogic_HostAdapterBusTypes[HostAdapter->ModelName[3] - '4'];\r\nif (HostAdapter->IRQ_Channel == 0) {\r\nif (Configuration.IRQ_Channel9)\r\nHostAdapter->IRQ_Channel = 9;\r\nelse if (Configuration.IRQ_Channel10)\r\nHostAdapter->IRQ_Channel = 10;\r\nelse if (Configuration.IRQ_Channel11)\r\nHostAdapter->IRQ_Channel = 11;\r\nelse if (Configuration.IRQ_Channel12)\r\nHostAdapter->IRQ_Channel = 12;\r\nelse if (Configuration.IRQ_Channel14)\r\nHostAdapter->IRQ_Channel = 14;\r\nelse if (Configuration.IRQ_Channel15)\r\nHostAdapter->IRQ_Channel = 15;\r\n}\r\nif (HostAdapter->HostAdapterBusType == BusLogic_ISA_Bus) {\r\nif (Configuration.DMA_Channel5)\r\nHostAdapter->DMA_Channel = 5;\r\nelse if (Configuration.DMA_Channel6)\r\nHostAdapter->DMA_Channel = 6;\r\nelse if (Configuration.DMA_Channel7)\r\nHostAdapter->DMA_Channel = 7;\r\n}\r\nGeometryRegister.All = BusLogic_ReadGeometryRegister(HostAdapter);\r\nHostAdapter->ExtendedTranslationEnabled = GeometryRegister.gr.ExtendedTranslationEnabled;\r\nHostAdapter->HostAdapterScatterGatherLimit = ExtendedSetupInformation.ScatterGatherLimit;\r\nHostAdapter->DriverScatterGatherLimit = HostAdapter->HostAdapterScatterGatherLimit;\r\nif (HostAdapter->HostAdapterScatterGatherLimit > BusLogic_ScatterGatherLimit)\r\nHostAdapter->DriverScatterGatherLimit = BusLogic_ScatterGatherLimit;\r\nif (ExtendedSetupInformation.Misc.LevelSensitiveInterrupt)\r\nHostAdapter->LevelSensitiveInterrupt = true;\r\nHostAdapter->HostWideSCSI = ExtendedSetupInformation.HostWideSCSI;\r\nHostAdapter->HostDifferentialSCSI = ExtendedSetupInformation.HostDifferentialSCSI;\r\nHostAdapter->HostSupportsSCAM = ExtendedSetupInformation.HostSupportsSCAM;\r\nHostAdapter->HostUltraSCSI = ExtendedSetupInformation.HostUltraSCSI;\r\nif (HostAdapter->FirmwareVersion[0] == '5' || (HostAdapter->FirmwareVersion[0] == '4' && HostAdapter->HostWideSCSI))\r\nHostAdapter->ExtendedLUNSupport = true;\r\nif (HostAdapter->FirmwareVersion[0] == '5') {\r\nif (BusLogic_Command(HostAdapter, BusLogic_InquirePCIHostAdapterInformation, NULL, 0, &PCIHostAdapterInformation, sizeof(PCIHostAdapterInformation))\r\n!= sizeof(PCIHostAdapterInformation))\r\nreturn BusLogic_Failure(HostAdapter, "INQUIRE PCI HOST ADAPTER INFORMATION");\r\nif (PCIHostAdapterInformation.GenericInfoValid) {\r\nHostAdapter->TerminationInfoValid = true;\r\nHostAdapter->LowByteTerminated = PCIHostAdapterInformation.LowByteTerminated;\r\nHostAdapter->HighByteTerminated = PCIHostAdapterInformation.HighByteTerminated;\r\n}\r\n}\r\nif (HostAdapter->FirmwareVersion[0] >= '4') {\r\nFetchHostAdapterLocalRAMRequest.ByteOffset = BusLogic_AutoSCSI_BaseOffset;\r\nFetchHostAdapterLocalRAMRequest.ByteCount = sizeof(AutoSCSIData);\r\nif (BusLogic_Command(HostAdapter, BusLogic_FetchHostAdapterLocalRAM, &FetchHostAdapterLocalRAMRequest, sizeof(FetchHostAdapterLocalRAMRequest), &AutoSCSIData, sizeof(AutoSCSIData))\r\n!= sizeof(AutoSCSIData))\r\nreturn BusLogic_Failure(HostAdapter, "FETCH HOST ADAPTER LOCAL RAM");\r\nHostAdapter->ParityCheckingEnabled = AutoSCSIData.ParityCheckingEnabled;\r\nHostAdapter->BusResetEnabled = AutoSCSIData.BusResetEnabled;\r\nif (HostAdapter->FirmwareVersion[0] == '4') {\r\nHostAdapter->TerminationInfoValid = true;\r\nHostAdapter->LowByteTerminated = AutoSCSIData.LowByteTerminated;\r\nHostAdapter->HighByteTerminated = AutoSCSIData.HighByteTerminated;\r\n}\r\nHostAdapter->WidePermitted = AutoSCSIData.WidePermitted;\r\nHostAdapter->FastPermitted = AutoSCSIData.FastPermitted;\r\nHostAdapter->SynchronousPermitted = AutoSCSIData.SynchronousPermitted;\r\nHostAdapter->DisconnectPermitted = AutoSCSIData.DisconnectPermitted;\r\nif (HostAdapter->HostUltraSCSI)\r\nHostAdapter->UltraPermitted = AutoSCSIData.UltraPermitted;\r\nif (HostAdapter->HostSupportsSCAM) {\r\nHostAdapter->SCAM_Enabled = AutoSCSIData.SCAM_Enabled;\r\nHostAdapter->SCAM_Level2 = AutoSCSIData.SCAM_Level2;\r\n}\r\n}\r\nif (HostAdapter->FirmwareVersion[0] < '4') {\r\nif (SetupInformation.SynchronousInitiationEnabled) {\r\nHostAdapter->SynchronousPermitted = 0xFF;\r\nif (HostAdapter->HostAdapterBusType == BusLogic_EISA_Bus) {\r\nif (ExtendedSetupInformation.Misc.FastOnEISA)\r\nHostAdapter->FastPermitted = 0xFF;\r\nif (strcmp(HostAdapter->ModelName, "BT-757") == 0)\r\nHostAdapter->WidePermitted = 0xFF;\r\n}\r\n}\r\nHostAdapter->DisconnectPermitted = 0xFF;\r\nHostAdapter->ParityCheckingEnabled = SetupInformation.ParityCheckingEnabled;\r\nHostAdapter->BusResetEnabled = true;\r\n}\r\nHostAdapter->MaxTargetDevices = (HostAdapter->HostWideSCSI ? 16 : 8);\r\nHostAdapter->MaxLogicalUnits = (HostAdapter->ExtendedLUNSupport ? 32 : 8);\r\nif (HostAdapter->FirmwareVersion[0] == '5')\r\nHostAdapter->HostAdapterQueueDepth = 192;\r\nelse if (HostAdapter->FirmwareVersion[0] == '4')\r\nHostAdapter->HostAdapterQueueDepth = (HostAdapter->HostAdapterBusType != BusLogic_ISA_Bus ? 100 : 50);\r\nelse\r\nHostAdapter->HostAdapterQueueDepth = 30;\r\nif (strcmp(HostAdapter->FirmwareVersion, "3.31") >= 0) {\r\nHostAdapter->StrictRoundRobinModeSupport = true;\r\nHostAdapter->MailboxCount = BusLogic_MaxMailboxes;\r\n} else {\r\nHostAdapter->StrictRoundRobinModeSupport = false;\r\nHostAdapter->MailboxCount = 32;\r\n}\r\nHostAdapter->DriverQueueDepth = HostAdapter->MailboxCount;\r\nHostAdapter->InitialCCBs = 4 * BusLogic_CCB_AllocationGroupSize;\r\nHostAdapter->IncrementalCCBs = BusLogic_CCB_AllocationGroupSize;\r\nHostAdapter->TaggedQueuingPermitted = 0;\r\nswitch (HostAdapter->FirmwareVersion[0]) {\r\ncase '5':\r\nHostAdapter->TaggedQueuingPermitted = 0xFFFF;\r\nbreak;\r\ncase '4':\r\nif (strcmp(HostAdapter->FirmwareVersion, "4.22") >= 0)\r\nHostAdapter->TaggedQueuingPermitted = 0xFFFF;\r\nbreak;\r\ncase '3':\r\nif (strcmp(HostAdapter->FirmwareVersion, "3.35") >= 0)\r\nHostAdapter->TaggedQueuingPermitted = 0xFFFF;\r\nbreak;\r\n}\r\nHostAdapter->BIOS_Address = ExtendedSetupInformation.BIOS_Address << 12;\r\nif (HostAdapter->HostAdapterBusType == BusLogic_ISA_Bus && (void *) high_memory > (void *) MAX_DMA_ADDRESS)\r\nHostAdapter->BounceBuffersRequired = true;\r\nif (HostAdapter->BIOS_Address > 0 && strcmp(HostAdapter->ModelName, "BT-445S") == 0 && strcmp(HostAdapter->FirmwareVersion, "3.37") < 0 && (void *) high_memory > (void *) MAX_DMA_ADDRESS)\r\nHostAdapter->BounceBuffersRequired = true;\r\nCommon:\r\nstrcpy(HostAdapter->FullModelName, "BusLogic ");\r\nstrcat(HostAdapter->FullModelName, HostAdapter->ModelName);\r\nfor (TargetID = 0; TargetID < BusLogic_MaxTargetDevices; TargetID++) {\r\nunsigned char QueueDepth = 0;\r\nif (HostAdapter->DriverOptions != NULL && HostAdapter->DriverOptions->QueueDepth[TargetID] > 0)\r\nQueueDepth = HostAdapter->DriverOptions->QueueDepth[TargetID];\r\nelse if (HostAdapter->BounceBuffersRequired)\r\nQueueDepth = BusLogic_TaggedQueueDepthBB;\r\nHostAdapter->QueueDepth[TargetID] = QueueDepth;\r\n}\r\nif (HostAdapter->BounceBuffersRequired)\r\nHostAdapter->UntaggedQueueDepth = BusLogic_UntaggedQueueDepthBB;\r\nelse\r\nHostAdapter->UntaggedQueueDepth = BusLogic_UntaggedQueueDepth;\r\nif (HostAdapter->DriverOptions != NULL)\r\nHostAdapter->CommonQueueDepth = HostAdapter->DriverOptions->CommonQueueDepth;\r\nif (HostAdapter->CommonQueueDepth > 0 && HostAdapter->CommonQueueDepth < HostAdapter->UntaggedQueueDepth)\r\nHostAdapter->UntaggedQueueDepth = HostAdapter->CommonQueueDepth;\r\nHostAdapter->TaggedQueuingPermitted &= HostAdapter->DisconnectPermitted;\r\nif (HostAdapter->DriverOptions != NULL)\r\nHostAdapter->TaggedQueuingPermitted =\r\n(HostAdapter->DriverOptions->TaggedQueuingPermitted & HostAdapter->DriverOptions->TaggedQueuingPermittedMask) | (HostAdapter->TaggedQueuingPermitted & ~HostAdapter->DriverOptions->TaggedQueuingPermittedMask);\r\nif (HostAdapter->DriverOptions != NULL && HostAdapter->DriverOptions->BusSettleTime > 0)\r\nHostAdapter->BusSettleTime = HostAdapter->DriverOptions->BusSettleTime;\r\nelse\r\nHostAdapter->BusSettleTime = BusLogic_DefaultBusSettleTime;\r\nreturn true;\r\n}\r\nstatic bool __init BusLogic_ReportHostAdapterConfiguration(struct BusLogic_HostAdapter\r\n*HostAdapter)\r\n{\r\nunsigned short AllTargetsMask = (1 << HostAdapter->MaxTargetDevices) - 1;\r\nunsigned short SynchronousPermitted, FastPermitted;\r\nunsigned short UltraPermitted, WidePermitted;\r\nunsigned short DisconnectPermitted, TaggedQueuingPermitted;\r\nbool CommonSynchronousNegotiation, CommonTaggedQueueDepth;\r\nchar SynchronousString[BusLogic_MaxTargetDevices + 1];\r\nchar WideString[BusLogic_MaxTargetDevices + 1];\r\nchar DisconnectString[BusLogic_MaxTargetDevices + 1];\r\nchar TaggedQueuingString[BusLogic_MaxTargetDevices + 1];\r\nchar *SynchronousMessage = SynchronousString;\r\nchar *WideMessage = WideString;\r\nchar *DisconnectMessage = DisconnectString;\r\nchar *TaggedQueuingMessage = TaggedQueuingString;\r\nint TargetID;\r\nBusLogic_Info("Configuring BusLogic Model %s %s%s%s%s SCSI Host Adapter\n",\r\nHostAdapter, HostAdapter->ModelName,\r\nBusLogic_HostAdapterBusNames[HostAdapter->HostAdapterBusType], (HostAdapter->HostWideSCSI ? " Wide" : ""), (HostAdapter->HostDifferentialSCSI ? " Differential" : ""), (HostAdapter->HostUltraSCSI ? " Ultra" : ""));\r\nBusLogic_Info(" Firmware Version: %s, I/O Address: 0x%X, " "IRQ Channel: %d/%s\n", HostAdapter, HostAdapter->FirmwareVersion, HostAdapter->IO_Address, HostAdapter->IRQ_Channel, (HostAdapter->LevelSensitiveInterrupt ? "Level" : "Edge"));\r\nif (HostAdapter->HostAdapterBusType != BusLogic_PCI_Bus) {\r\nBusLogic_Info(" DMA Channel: ", HostAdapter);\r\nif (HostAdapter->DMA_Channel > 0)\r\nBusLogic_Info("%d, ", HostAdapter, HostAdapter->DMA_Channel);\r\nelse\r\nBusLogic_Info("None, ", HostAdapter);\r\nif (HostAdapter->BIOS_Address > 0)\r\nBusLogic_Info("BIOS Address: 0x%X, ", HostAdapter, HostAdapter->BIOS_Address);\r\nelse\r\nBusLogic_Info("BIOS Address: None, ", HostAdapter);\r\n} else {\r\nBusLogic_Info(" PCI Bus: %d, Device: %d, Address: ", HostAdapter, HostAdapter->Bus, HostAdapter->Device);\r\nif (HostAdapter->PCI_Address > 0)\r\nBusLogic_Info("0x%X, ", HostAdapter, HostAdapter->PCI_Address);\r\nelse\r\nBusLogic_Info("Unassigned, ", HostAdapter);\r\n}\r\nBusLogic_Info("Host Adapter SCSI ID: %d\n", HostAdapter, HostAdapter->SCSI_ID);\r\nBusLogic_Info(" Parity Checking: %s, Extended Translation: %s\n", HostAdapter, (HostAdapter->ParityCheckingEnabled ? "Enabled" : "Disabled"), (HostAdapter->ExtendedTranslationEnabled ? "Enabled" : "Disabled"));\r\nAllTargetsMask &= ~(1 << HostAdapter->SCSI_ID);\r\nSynchronousPermitted = HostAdapter->SynchronousPermitted & AllTargetsMask;\r\nFastPermitted = HostAdapter->FastPermitted & AllTargetsMask;\r\nUltraPermitted = HostAdapter->UltraPermitted & AllTargetsMask;\r\nif ((BusLogic_MultiMasterHostAdapterP(HostAdapter) && (HostAdapter->FirmwareVersion[0] >= '4' || HostAdapter->HostAdapterBusType == BusLogic_EISA_Bus)) || BusLogic_FlashPointHostAdapterP(HostAdapter)) {\r\nCommonSynchronousNegotiation = false;\r\nif (SynchronousPermitted == 0) {\r\nSynchronousMessage = "Disabled";\r\nCommonSynchronousNegotiation = true;\r\n} else if (SynchronousPermitted == AllTargetsMask) {\r\nif (FastPermitted == 0) {\r\nSynchronousMessage = "Slow";\r\nCommonSynchronousNegotiation = true;\r\n} else if (FastPermitted == AllTargetsMask) {\r\nif (UltraPermitted == 0) {\r\nSynchronousMessage = "Fast";\r\nCommonSynchronousNegotiation = true;\r\n} else if (UltraPermitted == AllTargetsMask) {\r\nSynchronousMessage = "Ultra";\r\nCommonSynchronousNegotiation = true;\r\n}\r\n}\r\n}\r\nif (!CommonSynchronousNegotiation) {\r\nfor (TargetID = 0; TargetID < HostAdapter->MaxTargetDevices; TargetID++)\r\nSynchronousString[TargetID] = ((!(SynchronousPermitted & (1 << TargetID))) ? 'N' : (!(FastPermitted & (1 << TargetID)) ? 'S' : (!(UltraPermitted & (1 << TargetID)) ? 'F' : 'U')));\r\nSynchronousString[HostAdapter->SCSI_ID] = '#';\r\nSynchronousString[HostAdapter->MaxTargetDevices] = '\0';\r\n}\r\n} else\r\nSynchronousMessage = (SynchronousPermitted == 0 ? "Disabled" : "Enabled");\r\nWidePermitted = HostAdapter->WidePermitted & AllTargetsMask;\r\nif (WidePermitted == 0)\r\nWideMessage = "Disabled";\r\nelse if (WidePermitted == AllTargetsMask)\r\nWideMessage = "Enabled";\r\nelse {\r\nfor (TargetID = 0; TargetID < HostAdapter->MaxTargetDevices; TargetID++)\r\nWideString[TargetID] = ((WidePermitted & (1 << TargetID)) ? 'Y' : 'N');\r\nWideString[HostAdapter->SCSI_ID] = '#';\r\nWideString[HostAdapter->MaxTargetDevices] = '\0';\r\n}\r\nDisconnectPermitted = HostAdapter->DisconnectPermitted & AllTargetsMask;\r\nif (DisconnectPermitted == 0)\r\nDisconnectMessage = "Disabled";\r\nelse if (DisconnectPermitted == AllTargetsMask)\r\nDisconnectMessage = "Enabled";\r\nelse {\r\nfor (TargetID = 0; TargetID < HostAdapter->MaxTargetDevices; TargetID++)\r\nDisconnectString[TargetID] = ((DisconnectPermitted & (1 << TargetID)) ? 'Y' : 'N');\r\nDisconnectString[HostAdapter->SCSI_ID] = '#';\r\nDisconnectString[HostAdapter->MaxTargetDevices] = '\0';\r\n}\r\nTaggedQueuingPermitted = HostAdapter->TaggedQueuingPermitted & AllTargetsMask;\r\nif (TaggedQueuingPermitted == 0)\r\nTaggedQueuingMessage = "Disabled";\r\nelse if (TaggedQueuingPermitted == AllTargetsMask)\r\nTaggedQueuingMessage = "Enabled";\r\nelse {\r\nfor (TargetID = 0; TargetID < HostAdapter->MaxTargetDevices; TargetID++)\r\nTaggedQueuingString[TargetID] = ((TaggedQueuingPermitted & (1 << TargetID)) ? 'Y' : 'N');\r\nTaggedQueuingString[HostAdapter->SCSI_ID] = '#';\r\nTaggedQueuingString[HostAdapter->MaxTargetDevices] = '\0';\r\n}\r\nBusLogic_Info(" Synchronous Negotiation: %s, Wide Negotiation: %s\n", HostAdapter, SynchronousMessage, WideMessage);\r\nBusLogic_Info(" Disconnect/Reconnect: %s, Tagged Queuing: %s\n", HostAdapter, DisconnectMessage, TaggedQueuingMessage);\r\nif (BusLogic_MultiMasterHostAdapterP(HostAdapter)) {\r\nBusLogic_Info(" Scatter/Gather Limit: %d of %d segments, " "Mailboxes: %d\n", HostAdapter, HostAdapter->DriverScatterGatherLimit, HostAdapter->HostAdapterScatterGatherLimit, HostAdapter->MailboxCount);\r\nBusLogic_Info(" Driver Queue Depth: %d, " "Host Adapter Queue Depth: %d\n", HostAdapter, HostAdapter->DriverQueueDepth, HostAdapter->HostAdapterQueueDepth);\r\n} else\r\nBusLogic_Info(" Driver Queue Depth: %d, " "Scatter/Gather Limit: %d segments\n", HostAdapter, HostAdapter->DriverQueueDepth, HostAdapter->DriverScatterGatherLimit);\r\nBusLogic_Info(" Tagged Queue Depth: ", HostAdapter);\r\nCommonTaggedQueueDepth = true;\r\nfor (TargetID = 1; TargetID < HostAdapter->MaxTargetDevices; TargetID++)\r\nif (HostAdapter->QueueDepth[TargetID] != HostAdapter->QueueDepth[0]) {\r\nCommonTaggedQueueDepth = false;\r\nbreak;\r\n}\r\nif (CommonTaggedQueueDepth) {\r\nif (HostAdapter->QueueDepth[0] > 0)\r\nBusLogic_Info("%d", HostAdapter, HostAdapter->QueueDepth[0]);\r\nelse\r\nBusLogic_Info("Automatic", HostAdapter);\r\n} else\r\nBusLogic_Info("Individual", HostAdapter);\r\nBusLogic_Info(", Untagged Queue Depth: %d\n", HostAdapter, HostAdapter->UntaggedQueueDepth);\r\nif (HostAdapter->TerminationInfoValid) {\r\nif (HostAdapter->HostWideSCSI)\r\nBusLogic_Info(" SCSI Bus Termination: %s", HostAdapter, (HostAdapter->LowByteTerminated ? (HostAdapter->HighByteTerminated ? "Both Enabled" : "Low Enabled")\r\n: (HostAdapter->HighByteTerminated ? "High Enabled" : "Both Disabled")));\r\nelse\r\nBusLogic_Info(" SCSI Bus Termination: %s", HostAdapter, (HostAdapter->LowByteTerminated ? "Enabled" : "Disabled"));\r\nif (HostAdapter->HostSupportsSCAM)\r\nBusLogic_Info(", SCAM: %s", HostAdapter, (HostAdapter->SCAM_Enabled ? (HostAdapter->SCAM_Level2 ? "Enabled, Level 2" : "Enabled, Level 1")\r\n: "Disabled"));\r\nBusLogic_Info("\n", HostAdapter);\r\n}\r\nreturn true;\r\n}\r\nstatic bool __init BusLogic_AcquireResources(struct BusLogic_HostAdapter *HostAdapter)\r\n{\r\nif (HostAdapter->IRQ_Channel == 0) {\r\nBusLogic_Error("NO LEGAL INTERRUPT CHANNEL ASSIGNED - DETACHING\n", HostAdapter);\r\nreturn false;\r\n}\r\nif (request_irq(HostAdapter->IRQ_Channel, BusLogic_InterruptHandler, IRQF_SHARED, HostAdapter->FullModelName, HostAdapter) < 0) {\r\nBusLogic_Error("UNABLE TO ACQUIRE IRQ CHANNEL %d - DETACHING\n", HostAdapter, HostAdapter->IRQ_Channel);\r\nreturn false;\r\n}\r\nHostAdapter->IRQ_ChannelAcquired = true;\r\nif (HostAdapter->DMA_Channel > 0) {\r\nif (request_dma(HostAdapter->DMA_Channel, HostAdapter->FullModelName) < 0) {\r\nBusLogic_Error("UNABLE TO ACQUIRE DMA CHANNEL %d - DETACHING\n", HostAdapter, HostAdapter->DMA_Channel);\r\nreturn false;\r\n}\r\nset_dma_mode(HostAdapter->DMA_Channel, DMA_MODE_CASCADE);\r\nenable_dma(HostAdapter->DMA_Channel);\r\nHostAdapter->DMA_ChannelAcquired = true;\r\n}\r\nreturn true;\r\n}\r\nstatic void BusLogic_ReleaseResources(struct BusLogic_HostAdapter *HostAdapter)\r\n{\r\nif (HostAdapter->IRQ_ChannelAcquired)\r\nfree_irq(HostAdapter->IRQ_Channel, HostAdapter);\r\nif (HostAdapter->DMA_ChannelAcquired)\r\nfree_dma(HostAdapter->DMA_Channel);\r\nif (HostAdapter->MailboxSpace)\r\npci_free_consistent(HostAdapter->PCI_Device, HostAdapter->MailboxSize, HostAdapter->MailboxSpace, HostAdapter->MailboxSpaceHandle);\r\npci_dev_put(HostAdapter->PCI_Device);\r\nHostAdapter->MailboxSpace = NULL;\r\nHostAdapter->MailboxSpaceHandle = 0;\r\nHostAdapter->MailboxSize = 0;\r\n}\r\nstatic bool BusLogic_InitializeHostAdapter(struct BusLogic_HostAdapter\r\n*HostAdapter)\r\n{\r\nstruct BusLogic_ExtendedMailboxRequest ExtendedMailboxRequest;\r\nenum BusLogic_RoundRobinModeRequest RoundRobinModeRequest;\r\nenum BusLogic_SetCCBFormatRequest SetCCBFormatRequest;\r\nint TargetID;\r\nHostAdapter->FirstCompletedCCB = NULL;\r\nHostAdapter->LastCompletedCCB = NULL;\r\nfor (TargetID = 0; TargetID < HostAdapter->MaxTargetDevices; TargetID++) {\r\nHostAdapter->BusDeviceResetPendingCCB[TargetID] = NULL;\r\nHostAdapter->TargetFlags[TargetID].TaggedQueuingActive = false;\r\nHostAdapter->TargetFlags[TargetID].CommandSuccessfulFlag = false;\r\nHostAdapter->ActiveCommands[TargetID] = 0;\r\nHostAdapter->CommandsSinceReset[TargetID] = 0;\r\n}\r\nif (BusLogic_FlashPointHostAdapterP(HostAdapter))\r\ngoto Done;\r\nHostAdapter->MailboxSize = HostAdapter->MailboxCount * (sizeof(struct BusLogic_OutgoingMailbox) + sizeof(struct BusLogic_IncomingMailbox));\r\nHostAdapter->MailboxSpace = pci_alloc_consistent(HostAdapter->PCI_Device, HostAdapter->MailboxSize, &HostAdapter->MailboxSpaceHandle);\r\nif (HostAdapter->MailboxSpace == NULL)\r\nreturn BusLogic_Failure(HostAdapter, "MAILBOX ALLOCATION");\r\nHostAdapter->FirstOutgoingMailbox = (struct BusLogic_OutgoingMailbox *) HostAdapter->MailboxSpace;\r\nHostAdapter->LastOutgoingMailbox = HostAdapter->FirstOutgoingMailbox + HostAdapter->MailboxCount - 1;\r\nHostAdapter->NextOutgoingMailbox = HostAdapter->FirstOutgoingMailbox;\r\nHostAdapter->FirstIncomingMailbox = (struct BusLogic_IncomingMailbox *) (HostAdapter->LastOutgoingMailbox + 1);\r\nHostAdapter->LastIncomingMailbox = HostAdapter->FirstIncomingMailbox + HostAdapter->MailboxCount - 1;\r\nHostAdapter->NextIncomingMailbox = HostAdapter->FirstIncomingMailbox;\r\nmemset(HostAdapter->FirstOutgoingMailbox, 0, HostAdapter->MailboxCount * sizeof(struct BusLogic_OutgoingMailbox));\r\nmemset(HostAdapter->FirstIncomingMailbox, 0, HostAdapter->MailboxCount * sizeof(struct BusLogic_IncomingMailbox));\r\nExtendedMailboxRequest.MailboxCount = HostAdapter->MailboxCount;\r\nExtendedMailboxRequest.BaseMailboxAddress = (u32) HostAdapter->MailboxSpaceHandle;\r\nif (BusLogic_Command(HostAdapter, BusLogic_InitializeExtendedMailbox, &ExtendedMailboxRequest, sizeof(ExtendedMailboxRequest), NULL, 0) < 0)\r\nreturn BusLogic_Failure(HostAdapter, "MAILBOX INITIALIZATION");\r\nif (HostAdapter->StrictRoundRobinModeSupport) {\r\nRoundRobinModeRequest = BusLogic_StrictRoundRobinMode;\r\nif (BusLogic_Command(HostAdapter, BusLogic_EnableStrictRoundRobinMode, &RoundRobinModeRequest, sizeof(RoundRobinModeRequest), NULL, 0) < 0)\r\nreturn BusLogic_Failure(HostAdapter, "ENABLE STRICT ROUND ROBIN MODE");\r\n}\r\nif (HostAdapter->ExtendedLUNSupport) {\r\nSetCCBFormatRequest = BusLogic_ExtendedLUNFormatCCB;\r\nif (BusLogic_Command(HostAdapter, BusLogic_SetCCBFormat, &SetCCBFormatRequest, sizeof(SetCCBFormatRequest), NULL, 0) < 0)\r\nreturn BusLogic_Failure(HostAdapter, "SET CCB FORMAT");\r\n}\r\nDone:\r\nif (!HostAdapter->HostAdapterInitialized) {\r\nBusLogic_Info("*** %s Initialized Successfully ***\n", HostAdapter, HostAdapter->FullModelName);\r\nBusLogic_Info("\n", HostAdapter);\r\n} else\r\nBusLogic_Warning("*** %s Initialized Successfully ***\n", HostAdapter, HostAdapter->FullModelName);\r\nHostAdapter->HostAdapterInitialized = true;\r\nreturn true;\r\n}\r\nstatic bool __init BusLogic_TargetDeviceInquiry(struct BusLogic_HostAdapter\r\n*HostAdapter)\r\n{\r\nu16 InstalledDevices;\r\nu8 InstalledDevicesID0to7[8];\r\nstruct BusLogic_SetupInformation SetupInformation;\r\nu8 SynchronousPeriod[BusLogic_MaxTargetDevices];\r\nunsigned char RequestedReplyLength;\r\nint TargetID;\r\nBusLogic_Delay(HostAdapter->BusSettleTime);\r\nif (BusLogic_FlashPointHostAdapterP(HostAdapter))\r\nreturn true;\r\nif (HostAdapter->DriverOptions != NULL && HostAdapter->DriverOptions->LocalOptions.InhibitTargetInquiry)\r\nreturn true;\r\nif (strcmp(HostAdapter->FirmwareVersion, "4.25") >= 0) {\r\nif (BusLogic_Command(HostAdapter, BusLogic_InquireTargetDevices, NULL, 0, &InstalledDevices, sizeof(InstalledDevices))\r\n!= sizeof(InstalledDevices))\r\nreturn BusLogic_Failure(HostAdapter, "INQUIRE TARGET DEVICES");\r\nfor (TargetID = 0; TargetID < HostAdapter->MaxTargetDevices; TargetID++)\r\nHostAdapter->TargetFlags[TargetID].TargetExists = (InstalledDevices & (1 << TargetID) ? true : false);\r\n} else {\r\nif (BusLogic_Command(HostAdapter, BusLogic_InquireInstalledDevicesID0to7, NULL, 0, &InstalledDevicesID0to7, sizeof(InstalledDevicesID0to7))\r\n!= sizeof(InstalledDevicesID0to7))\r\nreturn BusLogic_Failure(HostAdapter, "INQUIRE INSTALLED DEVICES ID 0 TO 7");\r\nfor (TargetID = 0; TargetID < 8; TargetID++)\r\nHostAdapter->TargetFlags[TargetID].TargetExists = (InstalledDevicesID0to7[TargetID] != 0 ? true : false);\r\n}\r\nRequestedReplyLength = sizeof(SetupInformation);\r\nif (BusLogic_Command(HostAdapter, BusLogic_InquireSetupInformation, &RequestedReplyLength, sizeof(RequestedReplyLength), &SetupInformation, sizeof(SetupInformation))\r\n!= sizeof(SetupInformation))\r\nreturn BusLogic_Failure(HostAdapter, "INQUIRE SETUP INFORMATION");\r\nfor (TargetID = 0; TargetID < HostAdapter->MaxTargetDevices; TargetID++)\r\nHostAdapter->SynchronousOffset[TargetID] = (TargetID < 8 ? SetupInformation.SynchronousValuesID0to7[TargetID].Offset : SetupInformation.SynchronousValuesID8to15[TargetID - 8].Offset);\r\nif (strcmp(HostAdapter->FirmwareVersion, "5.06L") >= 0)\r\nfor (TargetID = 0; TargetID < HostAdapter->MaxTargetDevices; TargetID++)\r\nHostAdapter->TargetFlags[TargetID].WideTransfersActive = (TargetID < 8 ? (SetupInformation.WideTransfersActiveID0to7 & (1 << TargetID)\r\n? true : false)\r\n: (SetupInformation.WideTransfersActiveID8to15 & (1 << (TargetID - 8))\r\n? true : false));\r\nif (HostAdapter->FirmwareVersion[0] >= '3') {\r\nRequestedReplyLength = sizeof(SynchronousPeriod);\r\nif (BusLogic_Command(HostAdapter, BusLogic_InquireSynchronousPeriod, &RequestedReplyLength, sizeof(RequestedReplyLength), &SynchronousPeriod, sizeof(SynchronousPeriod))\r\n!= sizeof(SynchronousPeriod))\r\nreturn BusLogic_Failure(HostAdapter, "INQUIRE SYNCHRONOUS PERIOD");\r\nfor (TargetID = 0; TargetID < HostAdapter->MaxTargetDevices; TargetID++)\r\nHostAdapter->SynchronousPeriod[TargetID] = SynchronousPeriod[TargetID];\r\n} else\r\nfor (TargetID = 0; TargetID < HostAdapter->MaxTargetDevices; TargetID++)\r\nif (SetupInformation.SynchronousValuesID0to7[TargetID].Offset > 0)\r\nHostAdapter->SynchronousPeriod[TargetID] = 20 + 5 * SetupInformation.SynchronousValuesID0to7[TargetID]\r\n.TransferPeriod;\r\nreturn true;\r\n}\r\nstatic void __init BusLogic_InitializeHostStructure(struct BusLogic_HostAdapter\r\n*HostAdapter, struct Scsi_Host *Host)\r\n{\r\nHost->max_id = HostAdapter->MaxTargetDevices;\r\nHost->max_lun = HostAdapter->MaxLogicalUnits;\r\nHost->max_channel = 0;\r\nHost->unique_id = HostAdapter->IO_Address;\r\nHost->this_id = HostAdapter->SCSI_ID;\r\nHost->can_queue = HostAdapter->DriverQueueDepth;\r\nHost->sg_tablesize = HostAdapter->DriverScatterGatherLimit;\r\nHost->unchecked_isa_dma = HostAdapter->BounceBuffersRequired;\r\nHost->cmd_per_lun = HostAdapter->UntaggedQueueDepth;\r\n}\r\nstatic int BusLogic_SlaveConfigure(struct scsi_device *Device)\r\n{\r\nstruct BusLogic_HostAdapter *HostAdapter = (struct BusLogic_HostAdapter *) Device->host->hostdata;\r\nint TargetID = Device->id;\r\nint QueueDepth = HostAdapter->QueueDepth[TargetID];\r\nif (HostAdapter->TargetFlags[TargetID].TaggedQueuingSupported && (HostAdapter->TaggedQueuingPermitted & (1 << TargetID))) {\r\nif (QueueDepth == 0)\r\nQueueDepth = BusLogic_MaxAutomaticTaggedQueueDepth;\r\nHostAdapter->QueueDepth[TargetID] = QueueDepth;\r\nscsi_adjust_queue_depth(Device, MSG_SIMPLE_TAG, QueueDepth);\r\n} else {\r\nHostAdapter->TaggedQueuingPermitted &= ~(1 << TargetID);\r\nQueueDepth = HostAdapter->UntaggedQueueDepth;\r\nHostAdapter->QueueDepth[TargetID] = QueueDepth;\r\nscsi_adjust_queue_depth(Device, 0, QueueDepth);\r\n}\r\nQueueDepth = 0;\r\nfor (TargetID = 0; TargetID < HostAdapter->MaxTargetDevices; TargetID++)\r\nif (HostAdapter->TargetFlags[TargetID].TargetExists) {\r\nQueueDepth += HostAdapter->QueueDepth[TargetID];\r\n}\r\nif (QueueDepth > HostAdapter->AllocatedCCBs)\r\nBusLogic_CreateAdditionalCCBs(HostAdapter, QueueDepth - HostAdapter->AllocatedCCBs, false);\r\nreturn 0;\r\n}\r\nstatic int __init BusLogic_init(void)\r\n{\r\nint BusLogicHostAdapterCount = 0, DriverOptionsIndex = 0, ProbeIndex;\r\nstruct BusLogic_HostAdapter *PrototypeHostAdapter;\r\nint ret = 0;\r\n#ifdef MODULE\r\nif (BusLogic)\r\nBusLogic_Setup(BusLogic);\r\n#endif\r\nif (BusLogic_ProbeOptions.NoProbe)\r\nreturn -ENODEV;\r\nBusLogic_ProbeInfoList =\r\nkzalloc(BusLogic_MaxHostAdapters * sizeof(struct BusLogic_ProbeInfo), GFP_KERNEL);\r\nif (BusLogic_ProbeInfoList == NULL) {\r\nBusLogic_Error("BusLogic: Unable to allocate Probe Info List\n", NULL);\r\nreturn -ENOMEM;\r\n}\r\nPrototypeHostAdapter =\r\nkzalloc(sizeof(struct BusLogic_HostAdapter), GFP_KERNEL);\r\nif (PrototypeHostAdapter == NULL) {\r\nkfree(BusLogic_ProbeInfoList);\r\nBusLogic_Error("BusLogic: Unable to allocate Prototype " "Host Adapter\n", NULL);\r\nreturn -ENOMEM;\r\n}\r\n#ifdef MODULE\r\nif (BusLogic != NULL)\r\nBusLogic_Setup(BusLogic);\r\n#endif\r\nBusLogic_InitializeProbeInfoList(PrototypeHostAdapter);\r\nfor (ProbeIndex = 0; ProbeIndex < BusLogic_ProbeInfoCount; ProbeIndex++) {\r\nstruct BusLogic_ProbeInfo *ProbeInfo = &BusLogic_ProbeInfoList[ProbeIndex];\r\nstruct BusLogic_HostAdapter *HostAdapter = PrototypeHostAdapter;\r\nstruct Scsi_Host *Host;\r\nif (ProbeInfo->IO_Address == 0)\r\ncontinue;\r\nmemset(HostAdapter, 0, sizeof(struct BusLogic_HostAdapter));\r\nHostAdapter->HostAdapterType = ProbeInfo->HostAdapterType;\r\nHostAdapter->HostAdapterBusType = ProbeInfo->HostAdapterBusType;\r\nHostAdapter->IO_Address = ProbeInfo->IO_Address;\r\nHostAdapter->PCI_Address = ProbeInfo->PCI_Address;\r\nHostAdapter->Bus = ProbeInfo->Bus;\r\nHostAdapter->Device = ProbeInfo->Device;\r\nHostAdapter->PCI_Device = ProbeInfo->PCI_Device;\r\nHostAdapter->IRQ_Channel = ProbeInfo->IRQ_Channel;\r\nHostAdapter->AddressCount = BusLogic_HostAdapterAddressCount[HostAdapter->HostAdapterType];\r\nif (!request_region(HostAdapter->IO_Address, HostAdapter->AddressCount,\r\n"BusLogic"))\r\ncontinue;\r\nif (!BusLogic_ProbeHostAdapter(HostAdapter)) {\r\nrelease_region(HostAdapter->IO_Address, HostAdapter->AddressCount);\r\ncontinue;\r\n}\r\nif (!BusLogic_HardwareResetHostAdapter(HostAdapter, true)) {\r\nrelease_region(HostAdapter->IO_Address, HostAdapter->AddressCount);\r\ncontinue;\r\n}\r\nif (!BusLogic_CheckHostAdapter(HostAdapter)) {\r\nrelease_region(HostAdapter->IO_Address, HostAdapter->AddressCount);\r\ncontinue;\r\n}\r\nif (DriverOptionsIndex < BusLogic_DriverOptionsCount)\r\nHostAdapter->DriverOptions = &BusLogic_DriverOptions[DriverOptionsIndex++];\r\nBusLogic_AnnounceDriver(HostAdapter);\r\nHost = scsi_host_alloc(&Bus_Logic_template, sizeof(struct BusLogic_HostAdapter));\r\nif (Host == NULL) {\r\nrelease_region(HostAdapter->IO_Address, HostAdapter->AddressCount);\r\ncontinue;\r\n}\r\nHostAdapter = (struct BusLogic_HostAdapter *) Host->hostdata;\r\nmemcpy(HostAdapter, PrototypeHostAdapter, sizeof(struct BusLogic_HostAdapter));\r\nHostAdapter->SCSI_Host = Host;\r\nHostAdapter->HostNumber = Host->host_no;\r\nlist_add_tail(&HostAdapter->host_list, &BusLogic_host_list);\r\nif (BusLogic_ReadHostAdapterConfiguration(HostAdapter) &&\r\nBusLogic_ReportHostAdapterConfiguration(HostAdapter) &&\r\nBusLogic_AcquireResources(HostAdapter) &&\r\nBusLogic_CreateInitialCCBs(HostAdapter) &&\r\nBusLogic_InitializeHostAdapter(HostAdapter) &&\r\nBusLogic_TargetDeviceInquiry(HostAdapter)) {\r\nrelease_region(HostAdapter->IO_Address,\r\nHostAdapter->AddressCount);\r\nif (!request_region(HostAdapter->IO_Address,\r\nHostAdapter->AddressCount,\r\nHostAdapter->FullModelName)) {\r\nprintk(KERN_WARNING\r\n"BusLogic: Release and re-register of "\r\n"port 0x%04lx failed \n",\r\n(unsigned long)HostAdapter->IO_Address);\r\nBusLogic_DestroyCCBs(HostAdapter);\r\nBusLogic_ReleaseResources(HostAdapter);\r\nlist_del(&HostAdapter->host_list);\r\nscsi_host_put(Host);\r\nret = -ENOMEM;\r\n} else {\r\nBusLogic_InitializeHostStructure(HostAdapter,\r\nHost);\r\nif (scsi_add_host(Host, HostAdapter->PCI_Device\r\n? &HostAdapter->PCI_Device->dev\r\n: NULL)) {\r\nprintk(KERN_WARNING\r\n"BusLogic: scsi_add_host()"\r\n"failed!\n");\r\nBusLogic_DestroyCCBs(HostAdapter);\r\nBusLogic_ReleaseResources(HostAdapter);\r\nlist_del(&HostAdapter->host_list);\r\nscsi_host_put(Host);\r\nret = -ENODEV;\r\n} else {\r\nscsi_scan_host(Host);\r\nBusLogicHostAdapterCount++;\r\n}\r\n}\r\n} else {\r\nBusLogic_DestroyCCBs(HostAdapter);\r\nBusLogic_ReleaseResources(HostAdapter);\r\nlist_del(&HostAdapter->host_list);\r\nscsi_host_put(Host);\r\nret = -ENODEV;\r\n}\r\n}\r\nkfree(PrototypeHostAdapter);\r\nkfree(BusLogic_ProbeInfoList);\r\nBusLogic_ProbeInfoList = NULL;\r\nreturn ret;\r\n}\r\nstatic int __exit BusLogic_ReleaseHostAdapter(struct BusLogic_HostAdapter *HostAdapter)\r\n{\r\nstruct Scsi_Host *Host = HostAdapter->SCSI_Host;\r\nscsi_remove_host(Host);\r\nif (BusLogic_FlashPointHostAdapterP(HostAdapter))\r\nFlashPoint_ReleaseHostAdapter(HostAdapter->CardHandle);\r\nBusLogic_DestroyCCBs(HostAdapter);\r\nBusLogic_ReleaseResources(HostAdapter);\r\nrelease_region(HostAdapter->IO_Address, HostAdapter->AddressCount);\r\nlist_del(&HostAdapter->host_list);\r\nscsi_host_put(Host);\r\nreturn 0;\r\n}\r\nstatic void BusLogic_QueueCompletedCCB(struct BusLogic_CCB *CCB)\r\n{\r\nstruct BusLogic_HostAdapter *HostAdapter = CCB->HostAdapter;\r\nCCB->Status = BusLogic_CCB_Completed;\r\nCCB->Next = NULL;\r\nif (HostAdapter->FirstCompletedCCB == NULL) {\r\nHostAdapter->FirstCompletedCCB = CCB;\r\nHostAdapter->LastCompletedCCB = CCB;\r\n} else {\r\nHostAdapter->LastCompletedCCB->Next = CCB;\r\nHostAdapter->LastCompletedCCB = CCB;\r\n}\r\nHostAdapter->ActiveCommands[CCB->TargetID]--;\r\n}\r\nstatic int BusLogic_ComputeResultCode(struct BusLogic_HostAdapter *HostAdapter, enum BusLogic_HostAdapterStatus HostAdapterStatus, enum BusLogic_TargetDeviceStatus TargetDeviceStatus)\r\n{\r\nint HostStatus;\r\nswitch (HostAdapterStatus) {\r\ncase BusLogic_CommandCompletedNormally:\r\ncase BusLogic_LinkedCommandCompleted:\r\ncase BusLogic_LinkedCommandCompletedWithFlag:\r\nHostStatus = DID_OK;\r\nbreak;\r\ncase BusLogic_SCSISelectionTimeout:\r\nHostStatus = DID_TIME_OUT;\r\nbreak;\r\ncase BusLogic_InvalidOutgoingMailboxActionCode:\r\ncase BusLogic_InvalidCommandOperationCode:\r\ncase BusLogic_InvalidCommandParameter:\r\nBusLogic_Warning("BusLogic Driver Protocol Error 0x%02X\n", HostAdapter, HostAdapterStatus);\r\ncase BusLogic_DataUnderRun:\r\ncase BusLogic_DataOverRun:\r\ncase BusLogic_UnexpectedBusFree:\r\ncase BusLogic_LinkedCCBhasInvalidLUN:\r\ncase BusLogic_AutoRequestSenseFailed:\r\ncase BusLogic_TaggedQueuingMessageRejected:\r\ncase BusLogic_UnsupportedMessageReceived:\r\ncase BusLogic_HostAdapterHardwareFailed:\r\ncase BusLogic_TargetDeviceReconnectedImproperly:\r\ncase BusLogic_AbortQueueGenerated:\r\ncase BusLogic_HostAdapterSoftwareError:\r\ncase BusLogic_HostAdapterHardwareTimeoutError:\r\ncase BusLogic_SCSIParityErrorDetected:\r\nHostStatus = DID_ERROR;\r\nbreak;\r\ncase BusLogic_InvalidBusPhaseRequested:\r\ncase BusLogic_TargetFailedResponseToATN:\r\ncase BusLogic_HostAdapterAssertedRST:\r\ncase BusLogic_OtherDeviceAssertedRST:\r\ncase BusLogic_HostAdapterAssertedBusDeviceReset:\r\nHostStatus = DID_RESET;\r\nbreak;\r\ndefault:\r\nBusLogic_Warning("Unknown Host Adapter Status 0x%02X\n", HostAdapter, HostAdapterStatus);\r\nHostStatus = DID_ERROR;\r\nbreak;\r\n}\r\nreturn (HostStatus << 16) | TargetDeviceStatus;\r\n}\r\nstatic void BusLogic_ScanIncomingMailboxes(struct BusLogic_HostAdapter *HostAdapter)\r\n{\r\nstruct BusLogic_IncomingMailbox *NextIncomingMailbox = HostAdapter->NextIncomingMailbox;\r\nenum BusLogic_CompletionCode CompletionCode;\r\nwhile ((CompletionCode = NextIncomingMailbox->CompletionCode) != BusLogic_IncomingMailboxFree) {\r\nstruct BusLogic_CCB *CCB = (struct BusLogic_CCB *) Bus_to_Virtual(NextIncomingMailbox->CCB);\r\nif (CompletionCode != BusLogic_AbortedCommandNotFound) {\r\nif (CCB->Status == BusLogic_CCB_Active || CCB->Status == BusLogic_CCB_Reset) {\r\nCCB->CompletionCode = CompletionCode;\r\nBusLogic_QueueCompletedCCB(CCB);\r\n} else {\r\nBusLogic_Warning("Illegal CCB #%ld status %d in " "Incoming Mailbox\n", HostAdapter, CCB->SerialNumber, CCB->Status);\r\n}\r\n}\r\nNextIncomingMailbox->CompletionCode = BusLogic_IncomingMailboxFree;\r\nif (++NextIncomingMailbox > HostAdapter->LastIncomingMailbox)\r\nNextIncomingMailbox = HostAdapter->FirstIncomingMailbox;\r\n}\r\nHostAdapter->NextIncomingMailbox = NextIncomingMailbox;\r\n}\r\nstatic void BusLogic_ProcessCompletedCCBs(struct BusLogic_HostAdapter *HostAdapter)\r\n{\r\nif (HostAdapter->ProcessCompletedCCBsActive)\r\nreturn;\r\nHostAdapter->ProcessCompletedCCBsActive = true;\r\nwhile (HostAdapter->FirstCompletedCCB != NULL) {\r\nstruct BusLogic_CCB *CCB = HostAdapter->FirstCompletedCCB;\r\nstruct scsi_cmnd *Command = CCB->Command;\r\nHostAdapter->FirstCompletedCCB = CCB->Next;\r\nif (HostAdapter->FirstCompletedCCB == NULL)\r\nHostAdapter->LastCompletedCCB = NULL;\r\nif (CCB->Opcode == BusLogic_BusDeviceReset) {\r\nint TargetID = CCB->TargetID;\r\nBusLogic_Warning("Bus Device Reset CCB #%ld to Target " "%d Completed\n", HostAdapter, CCB->SerialNumber, TargetID);\r\nBusLogic_IncrementErrorCounter(&HostAdapter->TargetStatistics[TargetID].BusDeviceResetsCompleted);\r\nHostAdapter->TargetFlags[TargetID].TaggedQueuingActive = false;\r\nHostAdapter->CommandsSinceReset[TargetID] = 0;\r\nHostAdapter->LastResetCompleted[TargetID] = jiffies;\r\nBusLogic_DeallocateCCB(CCB);\r\n#if 0\r\nwhile (Command != NULL) {\r\nstruct scsi_cmnd *NextCommand = Command->reset_chain;\r\nCommand->reset_chain = NULL;\r\nCommand->result = DID_RESET << 16;\r\nCommand->scsi_done(Command);\r\nCommand = NextCommand;\r\n}\r\n#endif\r\nfor (CCB = HostAdapter->All_CCBs; CCB != NULL; CCB = CCB->NextAll)\r\nif (CCB->Status == BusLogic_CCB_Reset && CCB->TargetID == TargetID) {\r\nCommand = CCB->Command;\r\nBusLogic_DeallocateCCB(CCB);\r\nHostAdapter->ActiveCommands[TargetID]--;\r\nCommand->result = DID_RESET << 16;\r\nCommand->scsi_done(Command);\r\n}\r\nHostAdapter->BusDeviceResetPendingCCB[TargetID] = NULL;\r\n} else {\r\nswitch (CCB->CompletionCode) {\r\ncase BusLogic_IncomingMailboxFree:\r\ncase BusLogic_AbortedCommandNotFound:\r\ncase BusLogic_InvalidCCB:\r\nBusLogic_Warning("CCB #%ld to Target %d Impossible State\n", HostAdapter, CCB->SerialNumber, CCB->TargetID);\r\nbreak;\r\ncase BusLogic_CommandCompletedWithoutError:\r\nHostAdapter->TargetStatistics[CCB->TargetID]\r\n.CommandsCompleted++;\r\nHostAdapter->TargetFlags[CCB->TargetID]\r\n.CommandSuccessfulFlag = true;\r\nCommand->result = DID_OK << 16;\r\nbreak;\r\ncase BusLogic_CommandAbortedAtHostRequest:\r\nBusLogic_Warning("CCB #%ld to Target %d Aborted\n", HostAdapter, CCB->SerialNumber, CCB->TargetID);\r\nBusLogic_IncrementErrorCounter(&HostAdapter->TargetStatistics[CCB->TargetID]\r\n.CommandAbortsCompleted);\r\nCommand->result = DID_ABORT << 16;\r\nbreak;\r\ncase BusLogic_CommandCompletedWithError:\r\nCommand->result = BusLogic_ComputeResultCode(HostAdapter, CCB->HostAdapterStatus, CCB->TargetDeviceStatus);\r\nif (CCB->HostAdapterStatus != BusLogic_SCSISelectionTimeout) {\r\nHostAdapter->TargetStatistics[CCB->TargetID]\r\n.CommandsCompleted++;\r\nif (BusLogic_GlobalOptions.TraceErrors) {\r\nint i;\r\nBusLogic_Notice("CCB #%ld Target %d: Result %X Host "\r\n"Adapter Status %02X " "Target Status %02X\n", HostAdapter, CCB->SerialNumber, CCB->TargetID, Command->result, CCB->HostAdapterStatus, CCB->TargetDeviceStatus);\r\nBusLogic_Notice("CDB ", HostAdapter);\r\nfor (i = 0; i < CCB->CDB_Length; i++)\r\nBusLogic_Notice(" %02X", HostAdapter, CCB->CDB[i]);\r\nBusLogic_Notice("\n", HostAdapter);\r\nBusLogic_Notice("Sense ", HostAdapter);\r\nfor (i = 0; i < CCB->SenseDataLength; i++)\r\nBusLogic_Notice(" %02X", HostAdapter, Command->sense_buffer[i]);\r\nBusLogic_Notice("\n", HostAdapter);\r\n}\r\n}\r\nbreak;\r\n}\r\nif (CCB->CDB[0] == INQUIRY && CCB->CDB[1] == 0 && CCB->HostAdapterStatus == BusLogic_CommandCompletedNormally) {\r\nstruct BusLogic_TargetFlags *TargetFlags = &HostAdapter->TargetFlags[CCB->TargetID];\r\nstruct SCSI_Inquiry *InquiryResult =\r\n(struct SCSI_Inquiry *) scsi_sglist(Command);\r\nTargetFlags->TargetExists = true;\r\nTargetFlags->TaggedQueuingSupported = InquiryResult->CmdQue;\r\nTargetFlags->WideTransfersSupported = InquiryResult->WBus16;\r\n}\r\nBusLogic_DeallocateCCB(CCB);\r\nCommand->scsi_done(Command);\r\n}\r\n}\r\nHostAdapter->ProcessCompletedCCBsActive = false;\r\n}\r\nstatic irqreturn_t BusLogic_InterruptHandler(int IRQ_Channel, void *DeviceIdentifier)\r\n{\r\nstruct BusLogic_HostAdapter *HostAdapter = (struct BusLogic_HostAdapter *) DeviceIdentifier;\r\nunsigned long ProcessorFlags;\r\nspin_lock_irqsave(HostAdapter->SCSI_Host->host_lock, ProcessorFlags);\r\nif (BusLogic_MultiMasterHostAdapterP(HostAdapter)) {\r\nunion BusLogic_InterruptRegister InterruptRegister;\r\nInterruptRegister.All = BusLogic_ReadInterruptRegister(HostAdapter);\r\nif (InterruptRegister.ir.InterruptValid) {\r\nBusLogic_InterruptReset(HostAdapter);\r\nif (InterruptRegister.ir.ExternalBusReset)\r\nHostAdapter->HostAdapterExternalReset = true;\r\nelse if (InterruptRegister.ir.IncomingMailboxLoaded)\r\nBusLogic_ScanIncomingMailboxes(HostAdapter);\r\nelse if (InterruptRegister.ir.CommandComplete)\r\nHostAdapter->HostAdapterCommandCompleted = true;\r\n}\r\n} else {\r\nif (FlashPoint_InterruptPending(HostAdapter->CardHandle))\r\nswitch (FlashPoint_HandleInterrupt(HostAdapter->CardHandle)) {\r\ncase FlashPoint_NormalInterrupt:\r\nbreak;\r\ncase FlashPoint_ExternalBusReset:\r\nHostAdapter->HostAdapterExternalReset = true;\r\nbreak;\r\ncase FlashPoint_InternalError:\r\nBusLogic_Warning("Internal FlashPoint Error detected" " - Resetting Host Adapter\n", HostAdapter);\r\nHostAdapter->HostAdapterInternalError = true;\r\nbreak;\r\n}\r\n}\r\nif (HostAdapter->FirstCompletedCCB != NULL)\r\nBusLogic_ProcessCompletedCCBs(HostAdapter);\r\nif (HostAdapter->HostAdapterExternalReset) {\r\nBusLogic_Warning("Resetting %s due to External SCSI Bus Reset\n", HostAdapter, HostAdapter->FullModelName);\r\nBusLogic_IncrementErrorCounter(&HostAdapter->ExternalHostAdapterResets);\r\nBusLogic_ResetHostAdapter(HostAdapter, false);\r\nHostAdapter->HostAdapterExternalReset = false;\r\n} else if (HostAdapter->HostAdapterInternalError) {\r\nBusLogic_Warning("Resetting %s due to Host Adapter Internal Error\n", HostAdapter, HostAdapter->FullModelName);\r\nBusLogic_IncrementErrorCounter(&HostAdapter->HostAdapterInternalErrors);\r\nBusLogic_ResetHostAdapter(HostAdapter, true);\r\nHostAdapter->HostAdapterInternalError = false;\r\n}\r\nspin_unlock_irqrestore(HostAdapter->SCSI_Host->host_lock, ProcessorFlags);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic bool BusLogic_WriteOutgoingMailbox(struct BusLogic_HostAdapter\r\n*HostAdapter, enum BusLogic_ActionCode ActionCode, struct BusLogic_CCB *CCB)\r\n{\r\nstruct BusLogic_OutgoingMailbox *NextOutgoingMailbox;\r\nNextOutgoingMailbox = HostAdapter->NextOutgoingMailbox;\r\nif (NextOutgoingMailbox->ActionCode == BusLogic_OutgoingMailboxFree) {\r\nCCB->Status = BusLogic_CCB_Active;\r\nNextOutgoingMailbox->CCB = CCB->DMA_Handle;\r\nNextOutgoingMailbox->ActionCode = ActionCode;\r\nBusLogic_StartMailboxCommand(HostAdapter);\r\nif (++NextOutgoingMailbox > HostAdapter->LastOutgoingMailbox)\r\nNextOutgoingMailbox = HostAdapter->FirstOutgoingMailbox;\r\nHostAdapter->NextOutgoingMailbox = NextOutgoingMailbox;\r\nif (ActionCode == BusLogic_MailboxStartCommand) {\r\nHostAdapter->ActiveCommands[CCB->TargetID]++;\r\nif (CCB->Opcode != BusLogic_BusDeviceReset)\r\nHostAdapter->TargetStatistics[CCB->TargetID].CommandsAttempted++;\r\n}\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic int BusLogic_host_reset(struct scsi_cmnd * SCpnt)\r\n{\r\nstruct BusLogic_HostAdapter *HostAdapter = (struct BusLogic_HostAdapter *) SCpnt->device->host->hostdata;\r\nunsigned int id = SCpnt->device->id;\r\nstruct BusLogic_TargetStatistics *stats = &HostAdapter->TargetStatistics[id];\r\nint rc;\r\nspin_lock_irq(SCpnt->device->host->host_lock);\r\nBusLogic_IncrementErrorCounter(&stats->HostAdapterResetsRequested);\r\nrc = BusLogic_ResetHostAdapter(HostAdapter, false);\r\nspin_unlock_irq(SCpnt->device->host->host_lock);\r\nreturn rc;\r\n}\r\nstatic int BusLogic_QueueCommand_lck(struct scsi_cmnd *Command, void (*CompletionRoutine) (struct scsi_cmnd *))\r\n{\r\nstruct BusLogic_HostAdapter *HostAdapter = (struct BusLogic_HostAdapter *) Command->device->host->hostdata;\r\nstruct BusLogic_TargetFlags *TargetFlags = &HostAdapter->TargetFlags[Command->device->id];\r\nstruct BusLogic_TargetStatistics *TargetStatistics = HostAdapter->TargetStatistics;\r\nunsigned char *CDB = Command->cmnd;\r\nint CDB_Length = Command->cmd_len;\r\nint TargetID = Command->device->id;\r\nint LogicalUnit = Command->device->lun;\r\nint BufferLength = scsi_bufflen(Command);\r\nint Count;\r\nstruct BusLogic_CCB *CCB;\r\nif (CDB[0] == REQUEST_SENSE && Command->sense_buffer[0] != 0) {\r\nCommand->result = DID_OK << 16;\r\nCompletionRoutine(Command);\r\nreturn 0;\r\n}\r\nCCB = BusLogic_AllocateCCB(HostAdapter);\r\nif (CCB == NULL) {\r\nspin_unlock_irq(HostAdapter->SCSI_Host->host_lock);\r\nBusLogic_Delay(1);\r\nspin_lock_irq(HostAdapter->SCSI_Host->host_lock);\r\nCCB = BusLogic_AllocateCCB(HostAdapter);\r\nif (CCB == NULL) {\r\nCommand->result = DID_ERROR << 16;\r\nCompletionRoutine(Command);\r\nreturn 0;\r\n}\r\n}\r\nCount = scsi_dma_map(Command);\r\nBUG_ON(Count < 0);\r\nif (Count) {\r\nstruct scatterlist *sg;\r\nint i;\r\nCCB->Opcode = BusLogic_InitiatorCCB_ScatterGather;\r\nCCB->DataLength = Count * sizeof(struct BusLogic_ScatterGatherSegment);\r\nif (BusLogic_MultiMasterHostAdapterP(HostAdapter))\r\nCCB->DataPointer = (unsigned int) CCB->DMA_Handle + ((unsigned long) &CCB->ScatterGatherList - (unsigned long) CCB);\r\nelse\r\nCCB->DataPointer = Virtual_to_32Bit_Virtual(CCB->ScatterGatherList);\r\nscsi_for_each_sg(Command, sg, Count, i) {\r\nCCB->ScatterGatherList[i].SegmentByteCount =\r\nsg_dma_len(sg);\r\nCCB->ScatterGatherList[i].SegmentDataPointer =\r\nsg_dma_address(sg);\r\n}\r\n} else if (!Count) {\r\nCCB->Opcode = BusLogic_InitiatorCCB;\r\nCCB->DataLength = BufferLength;\r\nCCB->DataPointer = 0;\r\n}\r\nswitch (CDB[0]) {\r\ncase READ_6:\r\ncase READ_10:\r\nCCB->DataDirection = BusLogic_DataInLengthChecked;\r\nTargetStatistics[TargetID].ReadCommands++;\r\nBusLogic_IncrementByteCounter(&TargetStatistics[TargetID].TotalBytesRead, BufferLength);\r\nBusLogic_IncrementSizeBucket(TargetStatistics[TargetID].ReadCommandSizeBuckets, BufferLength);\r\nbreak;\r\ncase WRITE_6:\r\ncase WRITE_10:\r\nCCB->DataDirection = BusLogic_DataOutLengthChecked;\r\nTargetStatistics[TargetID].WriteCommands++;\r\nBusLogic_IncrementByteCounter(&TargetStatistics[TargetID].TotalBytesWritten, BufferLength);\r\nBusLogic_IncrementSizeBucket(TargetStatistics[TargetID].WriteCommandSizeBuckets, BufferLength);\r\nbreak;\r\ndefault:\r\nCCB->DataDirection = BusLogic_UncheckedDataTransfer;\r\nbreak;\r\n}\r\nCCB->CDB_Length = CDB_Length;\r\nCCB->HostAdapterStatus = 0;\r\nCCB->TargetDeviceStatus = 0;\r\nCCB->TargetID = TargetID;\r\nCCB->LogicalUnit = LogicalUnit;\r\nCCB->TagEnable = false;\r\nCCB->LegacyTagEnable = false;\r\nif (HostAdapter->CommandsSinceReset[TargetID]++ >=\r\nBusLogic_MaxTaggedQueueDepth && !TargetFlags->TaggedQueuingActive && HostAdapter->ActiveCommands[TargetID] == 0 && TargetFlags->TaggedQueuingSupported && (HostAdapter->TaggedQueuingPermitted & (1 << TargetID))) {\r\nTargetFlags->TaggedQueuingActive = true;\r\nBusLogic_Notice("Tagged Queuing now active for Target %d\n", HostAdapter, TargetID);\r\n}\r\nif (TargetFlags->TaggedQueuingActive) {\r\nenum BusLogic_QueueTag QueueTag = BusLogic_SimpleQueueTag;\r\nif (HostAdapter->ActiveCommands[TargetID] == 0)\r\nHostAdapter->LastSequencePoint[TargetID] = jiffies;\r\nelse if (time_after(jiffies, HostAdapter->LastSequencePoint[TargetID] + 4 * HZ)) {\r\nHostAdapter->LastSequencePoint[TargetID] = jiffies;\r\nQueueTag = BusLogic_OrderedQueueTag;\r\n}\r\nif (HostAdapter->ExtendedLUNSupport) {\r\nCCB->TagEnable = true;\r\nCCB->QueueTag = QueueTag;\r\n} else {\r\nCCB->LegacyTagEnable = true;\r\nCCB->LegacyQueueTag = QueueTag;\r\n}\r\n}\r\nmemcpy(CCB->CDB, CDB, CDB_Length);\r\nCCB->SenseDataLength = SCSI_SENSE_BUFFERSIZE;\r\nCCB->SenseDataPointer = pci_map_single(HostAdapter->PCI_Device, Command->sense_buffer, CCB->SenseDataLength, PCI_DMA_FROMDEVICE);\r\nCCB->Command = Command;\r\nCommand->scsi_done = CompletionRoutine;\r\nif (BusLogic_MultiMasterHostAdapterP(HostAdapter)) {\r\nif (!BusLogic_WriteOutgoingMailbox(HostAdapter, BusLogic_MailboxStartCommand, CCB)) {\r\nspin_unlock_irq(HostAdapter->SCSI_Host->host_lock);\r\nBusLogic_Warning("Unable to write Outgoing Mailbox - " "Pausing for 1 second\n", HostAdapter);\r\nBusLogic_Delay(1);\r\nspin_lock_irq(HostAdapter->SCSI_Host->host_lock);\r\nif (!BusLogic_WriteOutgoingMailbox(HostAdapter, BusLogic_MailboxStartCommand, CCB)) {\r\nBusLogic_Warning("Still unable to write Outgoing Mailbox - " "Host Adapter Dead?\n", HostAdapter);\r\nBusLogic_DeallocateCCB(CCB);\r\nCommand->result = DID_ERROR << 16;\r\nCommand->scsi_done(Command);\r\n}\r\n}\r\n} else {\r\nCCB->Status = BusLogic_CCB_Active;\r\nHostAdapter->ActiveCommands[TargetID]++;\r\nTargetStatistics[TargetID].CommandsAttempted++;\r\nFlashPoint_StartCCB(HostAdapter->CardHandle, CCB);\r\nif (CCB->Status == BusLogic_CCB_Completed)\r\nBusLogic_ProcessCompletedCCBs(HostAdapter);\r\n}\r\nreturn 0;\r\n}\r\nint BusLogic_BIOSDiskParameters(struct scsi_device *sdev, struct block_device *Device, sector_t capacity, int *Parameters)\r\n{\r\nstruct BusLogic_HostAdapter *HostAdapter = (struct BusLogic_HostAdapter *) sdev->host->hostdata;\r\nstruct BIOS_DiskParameters *DiskParameters = (struct BIOS_DiskParameters *) Parameters;\r\nunsigned char *buf;\r\nif (HostAdapter->ExtendedTranslationEnabled && capacity >= 2 * 1024 * 1024 ) {\r\nif (capacity >= 4 * 1024 * 1024 ) {\r\nDiskParameters->Heads = 255;\r\nDiskParameters->Sectors = 63;\r\n} else {\r\nDiskParameters->Heads = 128;\r\nDiskParameters->Sectors = 32;\r\n}\r\n} else {\r\nDiskParameters->Heads = 64;\r\nDiskParameters->Sectors = 32;\r\n}\r\nDiskParameters->Cylinders = (unsigned long) capacity / (DiskParameters->Heads * DiskParameters->Sectors);\r\nbuf = scsi_bios_ptable(Device);\r\nif (buf == NULL)\r\nreturn 0;\r\nif (*(unsigned short *) (buf + 64) == 0xAA55) {\r\nstruct partition *FirstPartitionEntry = (struct partition *) buf;\r\nstruct partition *PartitionEntry = FirstPartitionEntry;\r\nint SavedCylinders = DiskParameters->Cylinders, PartitionNumber;\r\nunsigned char PartitionEntryEndHead = 0, PartitionEntryEndSector = 0;\r\nfor (PartitionNumber = 0; PartitionNumber < 4; PartitionNumber++) {\r\nPartitionEntryEndHead = PartitionEntry->end_head;\r\nPartitionEntryEndSector = PartitionEntry->end_sector & 0x3F;\r\nif (PartitionEntryEndHead == 64 - 1) {\r\nDiskParameters->Heads = 64;\r\nDiskParameters->Sectors = 32;\r\nbreak;\r\n} else if (PartitionEntryEndHead == 128 - 1) {\r\nDiskParameters->Heads = 128;\r\nDiskParameters->Sectors = 32;\r\nbreak;\r\n} else if (PartitionEntryEndHead == 255 - 1) {\r\nDiskParameters->Heads = 255;\r\nDiskParameters->Sectors = 63;\r\nbreak;\r\n}\r\nPartitionEntry++;\r\n}\r\nif (PartitionNumber == 4) {\r\nPartitionEntryEndHead = FirstPartitionEntry->end_head;\r\nPartitionEntryEndSector = FirstPartitionEntry->end_sector & 0x3F;\r\n}\r\nDiskParameters->Cylinders = (unsigned long) capacity / (DiskParameters->Heads * DiskParameters->Sectors);\r\nif (PartitionNumber < 4 && PartitionEntryEndSector == DiskParameters->Sectors) {\r\nif (DiskParameters->Cylinders != SavedCylinders)\r\nBusLogic_Warning("Adopting Geometry %d/%d from Partition Table\n", HostAdapter, DiskParameters->Heads, DiskParameters->Sectors);\r\n} else if (PartitionEntryEndHead > 0 || PartitionEntryEndSector > 0) {\r\nBusLogic_Warning("Warning: Partition Table appears to " "have Geometry %d/%d which is\n", HostAdapter, PartitionEntryEndHead + 1, PartitionEntryEndSector);\r\nBusLogic_Warning("not compatible with current BusLogic " "Host Adapter Geometry %d/%d\n", HostAdapter, DiskParameters->Heads, DiskParameters->Sectors);\r\n}\r\n}\r\nkfree(buf);\r\nreturn 0;\r\n}\r\nstatic int BusLogic_ProcDirectoryInfo(struct Scsi_Host *shost, char *ProcBuffer, char **StartPointer, off_t Offset, int BytesAvailable, int WriteFlag)\r\n{\r\nstruct BusLogic_HostAdapter *HostAdapter = (struct BusLogic_HostAdapter *) shost->hostdata;\r\nstruct BusLogic_TargetStatistics *TargetStatistics;\r\nint TargetID, Length;\r\nchar *Buffer;\r\nTargetStatistics = HostAdapter->TargetStatistics;\r\nif (WriteFlag) {\r\nHostAdapter->ExternalHostAdapterResets = 0;\r\nHostAdapter->HostAdapterInternalErrors = 0;\r\nmemset(TargetStatistics, 0, BusLogic_MaxTargetDevices * sizeof(struct BusLogic_TargetStatistics));\r\nreturn 0;\r\n}\r\nBuffer = HostAdapter->MessageBuffer;\r\nLength = HostAdapter->MessageBufferLength;\r\nLength += sprintf(&Buffer[Length], "\n\\r\nCurrent Driver Queue Depth: %d\n\\r\nCurrently Allocated CCBs: %d\n", HostAdapter->DriverQueueDepth, HostAdapter->AllocatedCCBs);\r\nLength += sprintf(&Buffer[Length], "\n\n\\r\nDATA TRANSFER STATISTICS\n\\r\n\n\\r\nTarget Tagged Queuing Queue Depth Active Attempted Completed\n\\r\n====== ============== =========== ====== ========= =========\n");\r\nfor (TargetID = 0; TargetID < HostAdapter->MaxTargetDevices; TargetID++) {\r\nstruct BusLogic_TargetFlags *TargetFlags = &HostAdapter->TargetFlags[TargetID];\r\nif (!TargetFlags->TargetExists)\r\ncontinue;\r\nLength += sprintf(&Buffer[Length], " %2d %s", TargetID, (TargetFlags->TaggedQueuingSupported ? (TargetFlags->TaggedQueuingActive ? " Active" : (HostAdapter->TaggedQueuingPermitted & (1 << TargetID)\r\n? " Permitted" : " Disabled"))\r\n: "Not Supported"));\r\nLength += sprintf(&Buffer[Length],\r\n" %3d %3u %9u %9u\n", HostAdapter->QueueDepth[TargetID], HostAdapter->ActiveCommands[TargetID], TargetStatistics[TargetID].CommandsAttempted, TargetStatistics[TargetID].CommandsCompleted);\r\n}\r\nLength += sprintf(&Buffer[Length], "\n\\r\nTarget Read Commands Write Commands Total Bytes Read Total Bytes Written\n\\r\n====== ============= ============== =================== ===================\n");\r\nfor (TargetID = 0; TargetID < HostAdapter->MaxTargetDevices; TargetID++) {\r\nstruct BusLogic_TargetFlags *TargetFlags = &HostAdapter->TargetFlags[TargetID];\r\nif (!TargetFlags->TargetExists)\r\ncontinue;\r\nLength += sprintf(&Buffer[Length], " %2d %9u %9u", TargetID, TargetStatistics[TargetID].ReadCommands, TargetStatistics[TargetID].WriteCommands);\r\nif (TargetStatistics[TargetID].TotalBytesRead.Billions > 0)\r\nLength += sprintf(&Buffer[Length], " %9u%09u", TargetStatistics[TargetID].TotalBytesRead.Billions, TargetStatistics[TargetID].TotalBytesRead.Units);\r\nelse\r\nLength += sprintf(&Buffer[Length], " %9u", TargetStatistics[TargetID].TotalBytesRead.Units);\r\nif (TargetStatistics[TargetID].TotalBytesWritten.Billions > 0)\r\nLength += sprintf(&Buffer[Length], " %9u%09u\n", TargetStatistics[TargetID].TotalBytesWritten.Billions, TargetStatistics[TargetID].TotalBytesWritten.Units);\r\nelse\r\nLength += sprintf(&Buffer[Length], " %9u\n", TargetStatistics[TargetID].TotalBytesWritten.Units);\r\n}\r\nLength += sprintf(&Buffer[Length], "\n\\r\nTarget Command 0-1KB 1-2KB 2-4KB 4-8KB 8-16KB\n\\r\n====== ======= ========= ========= ========= ========= =========\n");\r\nfor (TargetID = 0; TargetID < HostAdapter->MaxTargetDevices; TargetID++) {\r\nstruct BusLogic_TargetFlags *TargetFlags = &HostAdapter->TargetFlags[TargetID];\r\nif (!TargetFlags->TargetExists)\r\ncontinue;\r\nLength +=\r\nsprintf(&Buffer[Length],\r\n" %2d Read %9u %9u %9u %9u %9u\n", TargetID,\r\nTargetStatistics[TargetID].ReadCommandSizeBuckets[0],\r\nTargetStatistics[TargetID].ReadCommandSizeBuckets[1], TargetStatistics[TargetID].ReadCommandSizeBuckets[2], TargetStatistics[TargetID].ReadCommandSizeBuckets[3], TargetStatistics[TargetID].ReadCommandSizeBuckets[4]);\r\nLength +=\r\nsprintf(&Buffer[Length],\r\n" %2d Write %9u %9u %9u %9u %9u\n", TargetID,\r\nTargetStatistics[TargetID].WriteCommandSizeBuckets[0],\r\nTargetStatistics[TargetID].WriteCommandSizeBuckets[1], TargetStatistics[TargetID].WriteCommandSizeBuckets[2], TargetStatistics[TargetID].WriteCommandSizeBuckets[3], TargetStatistics[TargetID].WriteCommandSizeBuckets[4]);\r\n}\r\nLength += sprintf(&Buffer[Length], "\n\\r\nTarget Command 16-32KB 32-64KB 64-128KB 128-256KB 256KB+\n\\r\n====== ======= ========= ========= ========= ========= =========\n");\r\nfor (TargetID = 0; TargetID < HostAdapter->MaxTargetDevices; TargetID++) {\r\nstruct BusLogic_TargetFlags *TargetFlags = &HostAdapter->TargetFlags[TargetID];\r\nif (!TargetFlags->TargetExists)\r\ncontinue;\r\nLength +=\r\nsprintf(&Buffer[Length],\r\n" %2d Read %9u %9u %9u %9u %9u\n", TargetID,\r\nTargetStatistics[TargetID].ReadCommandSizeBuckets[5],\r\nTargetStatistics[TargetID].ReadCommandSizeBuckets[6], TargetStatistics[TargetID].ReadCommandSizeBuckets[7], TargetStatistics[TargetID].ReadCommandSizeBuckets[8], TargetStatistics[TargetID].ReadCommandSizeBuckets[9]);\r\nLength +=\r\nsprintf(&Buffer[Length],\r\n" %2d Write %9u %9u %9u %9u %9u\n", TargetID,\r\nTargetStatistics[TargetID].WriteCommandSizeBuckets[5],\r\nTargetStatistics[TargetID].WriteCommandSizeBuckets[6], TargetStatistics[TargetID].WriteCommandSizeBuckets[7], TargetStatistics[TargetID].WriteCommandSizeBuckets[8], TargetStatistics[TargetID].WriteCommandSizeBuckets[9]);\r\n}\r\nLength += sprintf(&Buffer[Length], "\n\n\\r\nERROR RECOVERY STATISTICS\n\\r\n\n\\r\nCommand Aborts Bus Device Resets Host Adapter Resets\n\\r\nTarget Requested Completed Requested Completed Requested Completed\n\\r\nID \\\\\\\\ Attempted //// \\\\\\\\ Attempted //// \\\\\\\\ Attempted ////\n\\r\n====== ===== ===== ===== ===== ===== ===== ===== ===== =====\n");\r\nfor (TargetID = 0; TargetID < HostAdapter->MaxTargetDevices; TargetID++) {\r\nstruct BusLogic_TargetFlags *TargetFlags = &HostAdapter->TargetFlags[TargetID];\r\nif (!TargetFlags->TargetExists)\r\ncontinue;\r\nLength += sprintf(&Buffer[Length], "\\r\n%2d %5d %5d %5d %5d %5d %5d %5d %5d %5d\n", TargetID, TargetStatistics[TargetID].CommandAbortsRequested, TargetStatistics[TargetID].CommandAbortsAttempted, TargetStatistics[TargetID].CommandAbortsCompleted, TargetStatistics[TargetID].BusDeviceResetsRequested, TargetStatistics[TargetID].BusDeviceResetsAttempted, TargetStatistics[TargetID].BusDeviceResetsCompleted, TargetStatistics[TargetID].HostAdapterResetsRequested, TargetStatistics[TargetID].HostAdapterResetsAttempted, TargetStatistics[TargetID].HostAdapterResetsCompleted);\r\n}\r\nLength += sprintf(&Buffer[Length], "\nExternal Host Adapter Resets: %d\n", HostAdapter->ExternalHostAdapterResets);\r\nLength += sprintf(&Buffer[Length], "Host Adapter Internal Errors: %d\n", HostAdapter->HostAdapterInternalErrors);\r\nif (Length >= BusLogic_MessageBufferSize)\r\nBusLogic_Error("Message Buffer length %d exceeds size %d\n", HostAdapter, Length, BusLogic_MessageBufferSize);\r\nif ((Length -= Offset) <= 0)\r\nreturn 0;\r\nif (Length >= BytesAvailable)\r\nLength = BytesAvailable;\r\nmemcpy(ProcBuffer, HostAdapter->MessageBuffer + Offset, Length);\r\n*StartPointer = ProcBuffer;\r\nreturn Length;\r\n}\r\nstatic void BusLogic_Message(enum BusLogic_MessageLevel MessageLevel, char *Format, struct BusLogic_HostAdapter *HostAdapter, ...)\r\n{\r\nstatic char Buffer[BusLogic_LineBufferSize];\r\nstatic bool BeginningOfLine = true;\r\nva_list Arguments;\r\nint Length = 0;\r\nva_start(Arguments, HostAdapter);\r\nLength = vsprintf(Buffer, Format, Arguments);\r\nva_end(Arguments);\r\nif (MessageLevel == BusLogic_AnnounceLevel) {\r\nstatic int AnnouncementLines = 0;\r\nstrcpy(&HostAdapter->MessageBuffer[HostAdapter->MessageBufferLength], Buffer);\r\nHostAdapter->MessageBufferLength += Length;\r\nif (++AnnouncementLines <= 2)\r\nprintk("%sscsi: %s", BusLogic_MessageLevelMap[MessageLevel], Buffer);\r\n} else if (MessageLevel == BusLogic_InfoLevel) {\r\nstrcpy(&HostAdapter->MessageBuffer[HostAdapter->MessageBufferLength], Buffer);\r\nHostAdapter->MessageBufferLength += Length;\r\nif (BeginningOfLine) {\r\nif (Buffer[0] != '\n' || Length > 1)\r\nprintk("%sscsi%d: %s", BusLogic_MessageLevelMap[MessageLevel], HostAdapter->HostNumber, Buffer);\r\n} else\r\nprintk("%s", Buffer);\r\n} else {\r\nif (BeginningOfLine) {\r\nif (HostAdapter != NULL && HostAdapter->HostAdapterInitialized)\r\nprintk("%sscsi%d: %s", BusLogic_MessageLevelMap[MessageLevel], HostAdapter->HostNumber, Buffer);\r\nelse\r\nprintk("%s%s", BusLogic_MessageLevelMap[MessageLevel], Buffer);\r\n} else\r\nprintk("%s", Buffer);\r\n}\r\nBeginningOfLine = (Buffer[Length - 1] == '\n');\r\n}\r\nstatic bool __init BusLogic_ParseKeyword(char **StringPointer, char *Keyword)\r\n{\r\nchar *Pointer = *StringPointer;\r\nwhile (*Keyword != '\0') {\r\nchar StringChar = *Pointer++;\r\nchar KeywordChar = *Keyword++;\r\nif (StringChar >= 'A' && StringChar <= 'Z')\r\nStringChar += 'a' - 'Z';\r\nif (KeywordChar >= 'A' && KeywordChar <= 'Z')\r\nKeywordChar += 'a' - 'Z';\r\nif (StringChar != KeywordChar)\r\nreturn false;\r\n}\r\n*StringPointer = Pointer;\r\nreturn true;\r\n}\r\nstatic int __init BusLogic_ParseDriverOptions(char *OptionsString)\r\n{\r\nwhile (true) {\r\nstruct BusLogic_DriverOptions *DriverOptions = &BusLogic_DriverOptions[BusLogic_DriverOptionsCount++];\r\nint TargetID;\r\nmemset(DriverOptions, 0, sizeof(struct BusLogic_DriverOptions));\r\nwhile (*OptionsString != '\0' && *OptionsString != ';') {\r\nif (BusLogic_ParseKeyword(&OptionsString, "IO:")) {\r\nunsigned long IO_Address = simple_strtoul(OptionsString, &OptionsString, 0);\r\nBusLogic_ProbeOptions.LimitedProbeISA = true;\r\nswitch (IO_Address) {\r\ncase 0x330:\r\nBusLogic_ProbeOptions.Probe330 = true;\r\nbreak;\r\ncase 0x334:\r\nBusLogic_ProbeOptions.Probe334 = true;\r\nbreak;\r\ncase 0x230:\r\nBusLogic_ProbeOptions.Probe230 = true;\r\nbreak;\r\ncase 0x234:\r\nBusLogic_ProbeOptions.Probe234 = true;\r\nbreak;\r\ncase 0x130:\r\nBusLogic_ProbeOptions.Probe130 = true;\r\nbreak;\r\ncase 0x134:\r\nBusLogic_ProbeOptions.Probe134 = true;\r\nbreak;\r\ndefault:\r\nBusLogic_Error("BusLogic: Invalid Driver Options " "(invalid I/O Address 0x%X)\n", NULL, IO_Address);\r\nreturn 0;\r\n}\r\n} else if (BusLogic_ParseKeyword(&OptionsString, "NoProbeISA"))\r\nBusLogic_ProbeOptions.NoProbeISA = true;\r\nelse if (BusLogic_ParseKeyword(&OptionsString, "NoProbePCI"))\r\nBusLogic_ProbeOptions.NoProbePCI = true;\r\nelse if (BusLogic_ParseKeyword(&OptionsString, "NoProbe"))\r\nBusLogic_ProbeOptions.NoProbe = true;\r\nelse if (BusLogic_ParseKeyword(&OptionsString, "NoSortPCI"))\r\nBusLogic_ProbeOptions.NoSortPCI = true;\r\nelse if (BusLogic_ParseKeyword(&OptionsString, "MultiMasterFirst"))\r\nBusLogic_ProbeOptions.MultiMasterFirst = true;\r\nelse if (BusLogic_ParseKeyword(&OptionsString, "FlashPointFirst"))\r\nBusLogic_ProbeOptions.FlashPointFirst = true;\r\nelse if (BusLogic_ParseKeyword(&OptionsString, "QueueDepth:[") || BusLogic_ParseKeyword(&OptionsString, "QD:[")) {\r\nfor (TargetID = 0; TargetID < BusLogic_MaxTargetDevices; TargetID++) {\r\nunsigned short QueueDepth = simple_strtoul(OptionsString, &OptionsString, 0);\r\nif (QueueDepth > BusLogic_MaxTaggedQueueDepth) {\r\nBusLogic_Error("BusLogic: Invalid Driver Options " "(invalid Queue Depth %d)\n", NULL, QueueDepth);\r\nreturn 0;\r\n}\r\nDriverOptions->QueueDepth[TargetID] = QueueDepth;\r\nif (*OptionsString == ',')\r\nOptionsString++;\r\nelse if (*OptionsString == ']')\r\nbreak;\r\nelse {\r\nBusLogic_Error("BusLogic: Invalid Driver Options " "(',' or ']' expected at '%s')\n", NULL, OptionsString);\r\nreturn 0;\r\n}\r\n}\r\nif (*OptionsString != ']') {\r\nBusLogic_Error("BusLogic: Invalid Driver Options " "(']' expected at '%s')\n", NULL, OptionsString);\r\nreturn 0;\r\n} else\r\nOptionsString++;\r\n} else if (BusLogic_ParseKeyword(&OptionsString, "QueueDepth:") || BusLogic_ParseKeyword(&OptionsString, "QD:")) {\r\nunsigned short QueueDepth = simple_strtoul(OptionsString, &OptionsString, 0);\r\nif (QueueDepth == 0 || QueueDepth > BusLogic_MaxTaggedQueueDepth) {\r\nBusLogic_Error("BusLogic: Invalid Driver Options " "(invalid Queue Depth %d)\n", NULL, QueueDepth);\r\nreturn 0;\r\n}\r\nDriverOptions->CommonQueueDepth = QueueDepth;\r\nfor (TargetID = 0; TargetID < BusLogic_MaxTargetDevices; TargetID++)\r\nDriverOptions->QueueDepth[TargetID] = QueueDepth;\r\n} else if (BusLogic_ParseKeyword(&OptionsString, "TaggedQueuing:") || BusLogic_ParseKeyword(&OptionsString, "TQ:")) {\r\nif (BusLogic_ParseKeyword(&OptionsString, "Default")) {\r\nDriverOptions->TaggedQueuingPermitted = 0x0000;\r\nDriverOptions->TaggedQueuingPermittedMask = 0x0000;\r\n} else if (BusLogic_ParseKeyword(&OptionsString, "Enable")) {\r\nDriverOptions->TaggedQueuingPermitted = 0xFFFF;\r\nDriverOptions->TaggedQueuingPermittedMask = 0xFFFF;\r\n} else if (BusLogic_ParseKeyword(&OptionsString, "Disable")) {\r\nDriverOptions->TaggedQueuingPermitted = 0x0000;\r\nDriverOptions->TaggedQueuingPermittedMask = 0xFFFF;\r\n} else {\r\nunsigned short TargetBit;\r\nfor (TargetID = 0, TargetBit = 1; TargetID < BusLogic_MaxTargetDevices; TargetID++, TargetBit <<= 1)\r\nswitch (*OptionsString++) {\r\ncase 'Y':\r\nDriverOptions->TaggedQueuingPermitted |= TargetBit;\r\nDriverOptions->TaggedQueuingPermittedMask |= TargetBit;\r\nbreak;\r\ncase 'N':\r\nDriverOptions->TaggedQueuingPermitted &= ~TargetBit;\r\nDriverOptions->TaggedQueuingPermittedMask |= TargetBit;\r\nbreak;\r\ncase 'X':\r\nbreak;\r\ndefault:\r\nOptionsString--;\r\nTargetID = BusLogic_MaxTargetDevices;\r\nbreak;\r\n}\r\n}\r\n}\r\nelse if (BusLogic_ParseKeyword(&OptionsString, "BusSettleTime:") || BusLogic_ParseKeyword(&OptionsString, "BST:")) {\r\nunsigned short BusSettleTime = simple_strtoul(OptionsString, &OptionsString, 0);\r\nif (BusSettleTime > 5 * 60) {\r\nBusLogic_Error("BusLogic: Invalid Driver Options " "(invalid Bus Settle Time %d)\n", NULL, BusSettleTime);\r\nreturn 0;\r\n}\r\nDriverOptions->BusSettleTime = BusSettleTime;\r\n} else if (BusLogic_ParseKeyword(&OptionsString, "InhibitTargetInquiry"))\r\nDriverOptions->LocalOptions.InhibitTargetInquiry = true;\r\nelse if (BusLogic_ParseKeyword(&OptionsString, "TraceProbe"))\r\nBusLogic_GlobalOptions.TraceProbe = true;\r\nelse if (BusLogic_ParseKeyword(&OptionsString, "TraceHardwareReset"))\r\nBusLogic_GlobalOptions.TraceHardwareReset = true;\r\nelse if (BusLogic_ParseKeyword(&OptionsString, "TraceConfiguration"))\r\nBusLogic_GlobalOptions.TraceConfiguration = true;\r\nelse if (BusLogic_ParseKeyword(&OptionsString, "TraceErrors"))\r\nBusLogic_GlobalOptions.TraceErrors = true;\r\nelse if (BusLogic_ParseKeyword(&OptionsString, "Debug")) {\r\nBusLogic_GlobalOptions.TraceProbe = true;\r\nBusLogic_GlobalOptions.TraceHardwareReset = true;\r\nBusLogic_GlobalOptions.TraceConfiguration = true;\r\nBusLogic_GlobalOptions.TraceErrors = true;\r\n}\r\nif (*OptionsString == ',')\r\nOptionsString++;\r\nelse if (*OptionsString != ';' && *OptionsString != '\0') {\r\nBusLogic_Error("BusLogic: Unexpected Driver Option '%s' " "ignored\n", NULL, OptionsString);\r\n*OptionsString = '\0';\r\n}\r\n}\r\nif (!(BusLogic_DriverOptionsCount == 0 || BusLogic_ProbeInfoCount == 0 || BusLogic_DriverOptionsCount == BusLogic_ProbeInfoCount)) {\r\nBusLogic_Error("BusLogic: Invalid Driver Options " "(all or no I/O Addresses must be specified)\n", NULL);\r\nreturn 0;\r\n}\r\nfor (TargetID = 0; TargetID < BusLogic_MaxTargetDevices; TargetID++)\r\nif (DriverOptions->QueueDepth[TargetID] == 1) {\r\nunsigned short TargetBit = 1 << TargetID;\r\nDriverOptions->TaggedQueuingPermitted &= ~TargetBit;\r\nDriverOptions->TaggedQueuingPermittedMask |= TargetBit;\r\n}\r\nif (*OptionsString == ';')\r\nOptionsString++;\r\nif (*OptionsString == '\0')\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nstatic int __init BusLogic_Setup(char *str)\r\n{\r\nint ints[3];\r\n(void) get_options(str, ARRAY_SIZE(ints), ints);\r\nif (ints[0] != 0) {\r\nBusLogic_Error("BusLogic: Obsolete Command Line Entry " "Format Ignored\n", NULL);\r\nreturn 0;\r\n}\r\nif (str == NULL || *str == '\0')\r\nreturn 0;\r\nreturn BusLogic_ParseDriverOptions(str);\r\n}\r\nstatic void __exit BusLogic_exit(void)\r\n{\r\nstruct BusLogic_HostAdapter *ha, *next;\r\nlist_for_each_entry_safe(ha, next, &BusLogic_host_list, host_list)\r\nBusLogic_ReleaseHostAdapter(ha);\r\n}
