static void cdv_disable_vga(struct drm_device *dev)\r\n{\r\nu8 sr1;\r\nu32 vga_reg;\r\nvga_reg = VGACNTRL;\r\noutb(1, VGA_SR_INDEX);\r\nsr1 = inb(VGA_SR_DATA);\r\noutb(sr1 | 1<<5, VGA_SR_DATA);\r\nudelay(300);\r\nREG_WRITE(vga_reg, VGA_DISP_DISABLE);\r\nREG_READ(vga_reg);\r\n}\r\nstatic int cdv_output_init(struct drm_device *dev)\r\n{\r\nstruct drm_psb_private *dev_priv = dev->dev_private;\r\ndrm_mode_create_scaling_mode_property(dev);\r\ncdv_disable_vga(dev);\r\ncdv_intel_crt_init(dev, &dev_priv->mode_dev);\r\ncdv_intel_lvds_init(dev, &dev_priv->mode_dev);\r\nif (REG_READ(SDVOB) & SDVO_DETECTED) {\r\ncdv_hdmi_init(dev, &dev_priv->mode_dev, SDVOB);\r\nif (REG_READ(DP_B) & DP_DETECTED)\r\ncdv_intel_dp_init(dev, &dev_priv->mode_dev, DP_B);\r\n}\r\nif (REG_READ(SDVOC) & SDVO_DETECTED) {\r\ncdv_hdmi_init(dev, &dev_priv->mode_dev, SDVOC);\r\nif (REG_READ(DP_C) & DP_DETECTED)\r\ncdv_intel_dp_init(dev, &dev_priv->mode_dev, DP_C);\r\n}\r\nreturn 0;\r\n}\r\nstatic int cdv_backlight_combination_mode(struct drm_device *dev)\r\n{\r\nreturn REG_READ(BLC_PWM_CTL2) & PWM_LEGACY_MODE;\r\n}\r\nstatic u32 cdv_get_max_backlight(struct drm_device *dev)\r\n{\r\nu32 max = REG_READ(BLC_PWM_CTL);\r\nif (max == 0) {\r\nDRM_DEBUG_KMS("LVDS Panel PWM value is 0!\n");\r\nreturn 1;\r\n}\r\nmax >>= 16;\r\nif (cdv_backlight_combination_mode(dev))\r\nmax *= 0xff;\r\nreturn max;\r\n}\r\nstatic int cdv_get_brightness(struct backlight_device *bd)\r\n{\r\nstruct drm_device *dev = bl_get_data(bd);\r\nu32 val = REG_READ(BLC_PWM_CTL) & BACKLIGHT_DUTY_CYCLE_MASK;\r\nif (cdv_backlight_combination_mode(dev)) {\r\nu8 lbpc;\r\nval &= ~1;\r\npci_read_config_byte(dev->pdev, 0xF4, &lbpc);\r\nval *= lbpc;\r\n}\r\nreturn (val * 100)/cdv_get_max_backlight(dev);\r\n}\r\nstatic int cdv_set_brightness(struct backlight_device *bd)\r\n{\r\nstruct drm_device *dev = bl_get_data(bd);\r\nint level = bd->props.brightness;\r\nu32 blc_pwm_ctl;\r\nif (level < 1)\r\nlevel = 1;\r\nlevel *= cdv_get_max_backlight(dev);\r\nlevel /= 100;\r\nif (cdv_backlight_combination_mode(dev)) {\r\nu32 max = cdv_get_max_backlight(dev);\r\nu8 lbpc;\r\nlbpc = level * 0xfe / max + 1;\r\nlevel /= lbpc;\r\npci_write_config_byte(dev->pdev, 0xF4, lbpc);\r\n}\r\nblc_pwm_ctl = REG_READ(BLC_PWM_CTL) & ~BACKLIGHT_DUTY_CYCLE_MASK;\r\nREG_WRITE(BLC_PWM_CTL, (blc_pwm_ctl |\r\n(level << BACKLIGHT_DUTY_CYCLE_SHIFT)));\r\nreturn 0;\r\n}\r\nstatic int cdv_backlight_init(struct drm_device *dev)\r\n{\r\nstruct drm_psb_private *dev_priv = dev->dev_private;\r\nstruct backlight_properties props;\r\nmemset(&props, 0, sizeof(struct backlight_properties));\r\nprops.max_brightness = 100;\r\nprops.type = BACKLIGHT_PLATFORM;\r\ncdv_backlight_device = backlight_device_register("psb-bl",\r\nNULL, (void *)dev, &cdv_ops, &props);\r\nif (IS_ERR(cdv_backlight_device))\r\nreturn PTR_ERR(cdv_backlight_device);\r\ncdv_backlight_device->props.brightness =\r\ncdv_get_brightness(cdv_backlight_device);\r\nbacklight_update_status(cdv_backlight_device);\r\ndev_priv->backlight_device = cdv_backlight_device;\r\ndev_priv->backlight_enabled = true;\r\nreturn 0;\r\n}\r\nstatic inline u32 CDV_MSG_READ32(uint port, uint offset)\r\n{\r\nint mcr = (0x10<<24) | (port << 16) | (offset << 8);\r\nuint32_t ret_val = 0;\r\nstruct pci_dev *pci_root = pci_get_bus_and_slot(0, 0);\r\npci_write_config_dword(pci_root, 0xD0, mcr);\r\npci_read_config_dword(pci_root, 0xD4, &ret_val);\r\npci_dev_put(pci_root);\r\nreturn ret_val;\r\n}\r\nstatic inline void CDV_MSG_WRITE32(uint port, uint offset, u32 value)\r\n{\r\nint mcr = (0x11<<24) | (port << 16) | (offset << 8) | 0xF0;\r\nstruct pci_dev *pci_root = pci_get_bus_and_slot(0, 0);\r\npci_write_config_dword(pci_root, 0xD4, value);\r\npci_write_config_dword(pci_root, 0xD0, mcr);\r\npci_dev_put(pci_root);\r\n}\r\nstatic void cdv_init_pm(struct drm_device *dev)\r\n{\r\nstruct drm_psb_private *dev_priv = dev->dev_private;\r\nu32 pwr_cnt;\r\nint i;\r\ndev_priv->apm_base = CDV_MSG_READ32(PSB_PUNIT_PORT,\r\nPSB_APMBA) & 0xFFFF;\r\ndev_priv->ospm_base = CDV_MSG_READ32(PSB_PUNIT_PORT,\r\nPSB_OSPMBA) & 0xFFFF;\r\npwr_cnt = inl(dev_priv->apm_base + PSB_APM_CMD);\r\npwr_cnt &= ~PSB_PWRGT_GFX_MASK;\r\npwr_cnt |= PSB_PWRGT_GFX_ON;\r\noutl(pwr_cnt, dev_priv->apm_base + PSB_APM_CMD);\r\nfor (i = 0; i < 5; i++) {\r\nu32 pwr_sts = inl(dev_priv->apm_base + PSB_APM_STS);\r\nif ((pwr_sts & PSB_PWRGT_GFX_MASK) == 0)\r\nreturn;\r\nudelay(10);\r\n}\r\ndev_err(dev->dev, "GPU: power management timed out.\n");\r\n}\r\nstatic void cdv_errata(struct drm_device *dev)\r\n{\r\nCDV_MSG_WRITE32(3, 0x30, 0x08027108);\r\n}\r\nstatic int cdv_save_display_registers(struct drm_device *dev)\r\n{\r\nstruct drm_psb_private *dev_priv = dev->dev_private;\r\nstruct psb_save_area *regs = &dev_priv->regs;\r\nstruct drm_connector *connector;\r\ndev_dbg(dev->dev, "Saving GPU registers.\n");\r\npci_read_config_byte(dev->pdev, 0xF4, &regs->cdv.saveLBB);\r\nregs->cdv.saveDSPCLK_GATE_D = REG_READ(DSPCLK_GATE_D);\r\nregs->cdv.saveRAMCLK_GATE_D = REG_READ(RAMCLK_GATE_D);\r\nregs->cdv.saveDSPARB = REG_READ(DSPARB);\r\nregs->cdv.saveDSPFW[0] = REG_READ(DSPFW1);\r\nregs->cdv.saveDSPFW[1] = REG_READ(DSPFW2);\r\nregs->cdv.saveDSPFW[2] = REG_READ(DSPFW3);\r\nregs->cdv.saveDSPFW[3] = REG_READ(DSPFW4);\r\nregs->cdv.saveDSPFW[4] = REG_READ(DSPFW5);\r\nregs->cdv.saveDSPFW[5] = REG_READ(DSPFW6);\r\nregs->cdv.saveADPA = REG_READ(ADPA);\r\nregs->cdv.savePP_CONTROL = REG_READ(PP_CONTROL);\r\nregs->cdv.savePFIT_PGM_RATIOS = REG_READ(PFIT_PGM_RATIOS);\r\nregs->saveBLC_PWM_CTL = REG_READ(BLC_PWM_CTL);\r\nregs->saveBLC_PWM_CTL2 = REG_READ(BLC_PWM_CTL2);\r\nregs->cdv.saveLVDS = REG_READ(LVDS);\r\nregs->cdv.savePFIT_CONTROL = REG_READ(PFIT_CONTROL);\r\nregs->cdv.savePP_ON_DELAYS = REG_READ(PP_ON_DELAYS);\r\nregs->cdv.savePP_OFF_DELAYS = REG_READ(PP_OFF_DELAYS);\r\nregs->cdv.savePP_CYCLE = REG_READ(PP_CYCLE);\r\nregs->cdv.saveVGACNTRL = REG_READ(VGACNTRL);\r\nregs->cdv.saveIER = REG_READ(PSB_INT_ENABLE_R);\r\nregs->cdv.saveIMR = REG_READ(PSB_INT_MASK_R);\r\nlist_for_each_entry(connector, &dev->mode_config.connector_list, head)\r\nconnector->funcs->dpms(connector, DRM_MODE_DPMS_OFF);\r\nreturn 0;\r\n}\r\nstatic int cdv_restore_display_registers(struct drm_device *dev)\r\n{\r\nstruct drm_psb_private *dev_priv = dev->dev_private;\r\nstruct psb_save_area *regs = &dev_priv->regs;\r\nstruct drm_connector *connector;\r\nu32 temp;\r\npci_write_config_byte(dev->pdev, 0xF4, regs->cdv.saveLBB);\r\nREG_WRITE(DSPCLK_GATE_D, regs->cdv.saveDSPCLK_GATE_D);\r\nREG_WRITE(RAMCLK_GATE_D, regs->cdv.saveRAMCLK_GATE_D);\r\nREG_WRITE(DPIO_CFG, 0);\r\nREG_WRITE(DPIO_CFG, DPIO_MODE_SELECT_0 | DPIO_CMN_RESET_N);\r\ntemp = REG_READ(DPLL_A);\r\nif ((temp & DPLL_SYNCLOCK_ENABLE) == 0) {\r\nREG_WRITE(DPLL_A, temp | DPLL_SYNCLOCK_ENABLE);\r\nREG_READ(DPLL_A);\r\n}\r\ntemp = REG_READ(DPLL_B);\r\nif ((temp & DPLL_SYNCLOCK_ENABLE) == 0) {\r\nREG_WRITE(DPLL_B, temp | DPLL_SYNCLOCK_ENABLE);\r\nREG_READ(DPLL_B);\r\n}\r\nudelay(500);\r\nREG_WRITE(DSPFW1, regs->cdv.saveDSPFW[0]);\r\nREG_WRITE(DSPFW2, regs->cdv.saveDSPFW[1]);\r\nREG_WRITE(DSPFW3, regs->cdv.saveDSPFW[2]);\r\nREG_WRITE(DSPFW4, regs->cdv.saveDSPFW[3]);\r\nREG_WRITE(DSPFW5, regs->cdv.saveDSPFW[4]);\r\nREG_WRITE(DSPFW6, regs->cdv.saveDSPFW[5]);\r\nREG_WRITE(DSPARB, regs->cdv.saveDSPARB);\r\nREG_WRITE(ADPA, regs->cdv.saveADPA);\r\nREG_WRITE(BLC_PWM_CTL2, regs->saveBLC_PWM_CTL2);\r\nREG_WRITE(LVDS, regs->cdv.saveLVDS);\r\nREG_WRITE(PFIT_CONTROL, regs->cdv.savePFIT_CONTROL);\r\nREG_WRITE(PFIT_PGM_RATIOS, regs->cdv.savePFIT_PGM_RATIOS);\r\nREG_WRITE(BLC_PWM_CTL, regs->saveBLC_PWM_CTL);\r\nREG_WRITE(PP_ON_DELAYS, regs->cdv.savePP_ON_DELAYS);\r\nREG_WRITE(PP_OFF_DELAYS, regs->cdv.savePP_OFF_DELAYS);\r\nREG_WRITE(PP_CYCLE, regs->cdv.savePP_CYCLE);\r\nREG_WRITE(PP_CONTROL, regs->cdv.savePP_CONTROL);\r\nREG_WRITE(VGACNTRL, regs->cdv.saveVGACNTRL);\r\nREG_WRITE(PSB_INT_ENABLE_R, regs->cdv.saveIER);\r\nREG_WRITE(PSB_INT_MASK_R, regs->cdv.saveIMR);\r\ncdv_errata(dev);\r\ndrm_mode_config_reset(dev);\r\nlist_for_each_entry(connector, &dev->mode_config.connector_list, head)\r\nconnector->funcs->dpms(connector, DRM_MODE_DPMS_ON);\r\ndrm_helper_resume_force_mode(dev);\r\nreturn 0;\r\n}\r\nstatic int cdv_power_down(struct drm_device *dev)\r\n{\r\nstruct drm_psb_private *dev_priv = dev->dev_private;\r\nu32 pwr_cnt, pwr_mask, pwr_sts;\r\nint tries = 5;\r\npwr_cnt = inl(dev_priv->apm_base + PSB_APM_CMD);\r\npwr_cnt &= ~PSB_PWRGT_GFX_MASK;\r\npwr_cnt |= PSB_PWRGT_GFX_OFF;\r\npwr_mask = PSB_PWRGT_GFX_MASK;\r\noutl(pwr_cnt, dev_priv->apm_base + PSB_APM_CMD);\r\nwhile (tries--) {\r\npwr_sts = inl(dev_priv->apm_base + PSB_APM_STS);\r\nif ((pwr_sts & pwr_mask) == PSB_PWRGT_GFX_D3)\r\nreturn 0;\r\nudelay(10);\r\n}\r\nreturn 0;\r\n}\r\nstatic int cdv_power_up(struct drm_device *dev)\r\n{\r\nstruct drm_psb_private *dev_priv = dev->dev_private;\r\nu32 pwr_cnt, pwr_mask, pwr_sts;\r\nint tries = 5;\r\npwr_cnt = inl(dev_priv->apm_base + PSB_APM_CMD);\r\npwr_cnt &= ~PSB_PWRGT_GFX_MASK;\r\npwr_cnt |= PSB_PWRGT_GFX_ON;\r\npwr_mask = PSB_PWRGT_GFX_MASK;\r\noutl(pwr_cnt, dev_priv->apm_base + PSB_APM_CMD);\r\nwhile (tries--) {\r\npwr_sts = inl(dev_priv->apm_base + PSB_APM_STS);\r\nif ((pwr_sts & pwr_mask) == PSB_PWRGT_GFX_D0)\r\nreturn 0;\r\nudelay(10);\r\n}\r\nreturn 0;\r\n}\r\nstatic void cdv_get_core_freq(struct drm_device *dev)\r\n{\r\nuint32_t clock;\r\nstruct pci_dev *pci_root = pci_get_bus_and_slot(0, 0);\r\nstruct drm_psb_private *dev_priv = dev->dev_private;\r\npci_write_config_dword(pci_root, 0xD0, 0xD0050300);\r\npci_read_config_dword(pci_root, 0xD4, &clock);\r\npci_dev_put(pci_root);\r\nswitch (clock & 0x07) {\r\ncase 0:\r\ndev_priv->core_freq = 100;\r\nbreak;\r\ncase 1:\r\ndev_priv->core_freq = 133;\r\nbreak;\r\ncase 2:\r\ndev_priv->core_freq = 150;\r\nbreak;\r\ncase 3:\r\ndev_priv->core_freq = 178;\r\nbreak;\r\ncase 4:\r\ndev_priv->core_freq = 200;\r\nbreak;\r\ncase 5:\r\ncase 6:\r\ncase 7:\r\ndev_priv->core_freq = 266;\r\nbreak;\r\ndefault:\r\ndev_priv->core_freq = 0;\r\n}\r\n}\r\nstatic void cdv_hotplug_work_func(struct work_struct *work)\r\n{\r\nstruct drm_psb_private *dev_priv = container_of(work, struct drm_psb_private,\r\nhotplug_work);\r\nstruct drm_device *dev = dev_priv->dev;\r\ndrm_helper_hpd_irq_event(dev);\r\n}\r\nstatic int cdv_hotplug_event(struct drm_device *dev)\r\n{\r\nstruct drm_psb_private *dev_priv = dev->dev_private;\r\nschedule_work(&dev_priv->hotplug_work);\r\nREG_WRITE(PORT_HOTPLUG_STAT, REG_READ(PORT_HOTPLUG_STAT));\r\nreturn 1;\r\n}\r\nstatic void cdv_hotplug_enable(struct drm_device *dev, bool on)\r\n{\r\nif (on) {\r\nu32 hotplug = REG_READ(PORT_HOTPLUG_EN);\r\nhotplug |= HDMIB_HOTPLUG_INT_EN | HDMIC_HOTPLUG_INT_EN |\r\nHDMID_HOTPLUG_INT_EN | CRT_HOTPLUG_INT_EN;\r\nREG_WRITE(PORT_HOTPLUG_EN, hotplug);\r\n} else {\r\nREG_WRITE(PORT_HOTPLUG_EN, 0);\r\nREG_WRITE(PORT_HOTPLUG_STAT, REG_READ(PORT_HOTPLUG_STAT));\r\n}\r\n}\r\nvoid cdv_intel_attach_force_audio_property(struct drm_connector *connector)\r\n{\r\nstruct drm_device *dev = connector->dev;\r\nstruct drm_psb_private *dev_priv = dev->dev_private;\r\nstruct drm_property *prop;\r\nint i;\r\nprop = dev_priv->force_audio_property;\r\nif (prop == NULL) {\r\nprop = drm_property_create(dev, DRM_MODE_PROP_ENUM,\r\n"audio",\r\nARRAY_SIZE(force_audio_names));\r\nif (prop == NULL)\r\nreturn;\r\nfor (i = 0; i < ARRAY_SIZE(force_audio_names); i++)\r\ndrm_property_add_enum(prop, i, i-1, force_audio_names[i]);\r\ndev_priv->force_audio_property = prop;\r\n}\r\ndrm_object_attach_property(&connector->base, prop, 0);\r\n}\r\nvoid cdv_intel_attach_broadcast_rgb_property(struct drm_connector *connector)\r\n{\r\nstruct drm_device *dev = connector->dev;\r\nstruct drm_psb_private *dev_priv = dev->dev_private;\r\nstruct drm_property *prop;\r\nint i;\r\nprop = dev_priv->broadcast_rgb_property;\r\nif (prop == NULL) {\r\nprop = drm_property_create(dev, DRM_MODE_PROP_ENUM,\r\n"Broadcast RGB",\r\nARRAY_SIZE(broadcast_rgb_names));\r\nif (prop == NULL)\r\nreturn;\r\nfor (i = 0; i < ARRAY_SIZE(broadcast_rgb_names); i++)\r\ndrm_property_add_enum(prop, i, i, broadcast_rgb_names[i]);\r\ndev_priv->broadcast_rgb_property = prop;\r\n}\r\ndrm_object_attach_property(&connector->base, prop, 0);\r\n}\r\nstatic int cdv_chip_setup(struct drm_device *dev)\r\n{\r\nstruct drm_psb_private *dev_priv = dev->dev_private;\r\nINIT_WORK(&dev_priv->hotplug_work, cdv_hotplug_work_func);\r\nif (pci_enable_msi(dev->pdev))\r\ndev_warn(dev->dev, "Enabling MSI failed!\n");\r\ndev_priv->regmap = cdv_regmap;\r\ncdv_get_core_freq(dev);\r\npsb_intel_opregion_init(dev);\r\npsb_intel_init_bios(dev);\r\ncdv_hotplug_enable(dev, false);\r\nreturn 0;\r\n}
