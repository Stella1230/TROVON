static void print_overflow_msg(const char *func, const struct xdr_stream *xdr)\r\n{\r\ndprintk("NFS: %s prematurely hit the end of our receive buffer. "\r\n"Remaining buffer length is %tu words.\n",\r\nfunc, xdr->end - xdr->p);\r\n}\r\nstatic __be32 *xdr_encode_empty_array(__be32 *p)\r\n{\r\n*p++ = xdr_zero;\r\nreturn p;\r\n}\r\nstatic void encode_nfs_cb_opnum4(struct xdr_stream *xdr, enum nfs_cb_opnum4 op)\r\n{\r\n__be32 *p;\r\np = xdr_reserve_space(xdr, 4);\r\n*p = cpu_to_be32(op);\r\n}\r\nstatic void encode_nfs_fh4(struct xdr_stream *xdr, const struct knfsd_fh *fh)\r\n{\r\nu32 length = fh->fh_size;\r\n__be32 *p;\r\nBUG_ON(length > NFS4_FHSIZE);\r\np = xdr_reserve_space(xdr, 4 + length);\r\nxdr_encode_opaque(p, &fh->fh_base, length);\r\n}\r\nstatic void encode_stateid4(struct xdr_stream *xdr, const stateid_t *sid)\r\n{\r\n__be32 *p;\r\np = xdr_reserve_space(xdr, NFS4_STATEID_SIZE);\r\n*p++ = cpu_to_be32(sid->si_generation);\r\nxdr_encode_opaque_fixed(p, &sid->si_opaque, NFS4_STATEID_OTHER_SIZE);\r\n}\r\nstatic void encode_sessionid4(struct xdr_stream *xdr,\r\nconst struct nfsd4_session *session)\r\n{\r\n__be32 *p;\r\np = xdr_reserve_space(xdr, NFS4_MAX_SESSIONID_LEN);\r\nxdr_encode_opaque_fixed(p, session->se_sessionid.data,\r\nNFS4_MAX_SESSIONID_LEN);\r\n}\r\nstatic int nfs_cb_stat_to_errno(int status)\r\n{\r\nint i;\r\nfor (i = 0; nfs_cb_errtbl[i].stat != -1; i++) {\r\nif (nfs_cb_errtbl[i].stat == status)\r\nreturn nfs_cb_errtbl[i].errno;\r\n}\r\ndprintk("NFSD: Unrecognized NFS CB status value: %u\n", status);\r\nreturn -status;\r\n}\r\nstatic int decode_cb_op_status(struct xdr_stream *xdr, enum nfs_opnum4 expected,\r\nenum nfsstat4 *status)\r\n{\r\n__be32 *p;\r\nu32 op;\r\np = xdr_inline_decode(xdr, 4 + 4);\r\nif (unlikely(p == NULL))\r\ngoto out_overflow;\r\nop = be32_to_cpup(p++);\r\nif (unlikely(op != expected))\r\ngoto out_unexpected;\r\n*status = be32_to_cpup(p);\r\nreturn 0;\r\nout_overflow:\r\nprint_overflow_msg(__func__, xdr);\r\nreturn -EIO;\r\nout_unexpected:\r\ndprintk("NFSD: Callback server returned operation %d but "\r\n"we issued a request for %d\n", op, expected);\r\nreturn -EIO;\r\n}\r\nstatic void encode_cb_compound4args(struct xdr_stream *xdr,\r\nstruct nfs4_cb_compound_hdr *hdr)\r\n{\r\n__be32 * p;\r\np = xdr_reserve_space(xdr, 4 + 4 + 4 + 4);\r\np = xdr_encode_empty_array(p);\r\n*p++ = cpu_to_be32(hdr->minorversion);\r\n*p++ = cpu_to_be32(hdr->ident);\r\nhdr->nops_p = p;\r\n*p = cpu_to_be32(hdr->nops);\r\n}\r\nstatic void encode_cb_nops(struct nfs4_cb_compound_hdr *hdr)\r\n{\r\nBUG_ON(hdr->nops > NFS4_MAX_BACK_CHANNEL_OPS);\r\n*hdr->nops_p = cpu_to_be32(hdr->nops);\r\n}\r\nstatic int decode_cb_compound4res(struct xdr_stream *xdr,\r\nstruct nfs4_cb_compound_hdr *hdr)\r\n{\r\nu32 length;\r\n__be32 *p;\r\np = xdr_inline_decode(xdr, 4 + 4);\r\nif (unlikely(p == NULL))\r\ngoto out_overflow;\r\nhdr->status = be32_to_cpup(p++);\r\nlength = be32_to_cpup(p++);\r\np = xdr_inline_decode(xdr, length + 4);\r\nif (unlikely(p == NULL))\r\ngoto out_overflow;\r\nhdr->nops = be32_to_cpup(p);\r\nreturn 0;\r\nout_overflow:\r\nprint_overflow_msg(__func__, xdr);\r\nreturn -EIO;\r\n}\r\nstatic void encode_cb_recall4args(struct xdr_stream *xdr,\r\nconst struct nfs4_delegation *dp,\r\nstruct nfs4_cb_compound_hdr *hdr)\r\n{\r\n__be32 *p;\r\nencode_nfs_cb_opnum4(xdr, OP_CB_RECALL);\r\nencode_stateid4(xdr, &dp->dl_stid.sc_stateid);\r\np = xdr_reserve_space(xdr, 4);\r\n*p++ = xdr_zero;\r\nencode_nfs_fh4(xdr, &dp->dl_fh);\r\nhdr->nops++;\r\n}\r\nstatic void encode_cb_sequence4args(struct xdr_stream *xdr,\r\nconst struct nfsd4_callback *cb,\r\nstruct nfs4_cb_compound_hdr *hdr)\r\n{\r\nstruct nfsd4_session *session = cb->cb_clp->cl_cb_session;\r\n__be32 *p;\r\nif (hdr->minorversion == 0)\r\nreturn;\r\nencode_nfs_cb_opnum4(xdr, OP_CB_SEQUENCE);\r\nencode_sessionid4(xdr, session);\r\np = xdr_reserve_space(xdr, 4 + 4 + 4 + 4 + 4);\r\n*p++ = cpu_to_be32(session->se_cb_seq_nr);\r\n*p++ = xdr_zero;\r\n*p++ = xdr_zero;\r\n*p++ = xdr_zero;\r\nxdr_encode_empty_array(p);\r\nhdr->nops++;\r\n}\r\nstatic int decode_cb_sequence4resok(struct xdr_stream *xdr,\r\nstruct nfsd4_callback *cb)\r\n{\r\nstruct nfsd4_session *session = cb->cb_clp->cl_cb_session;\r\nstruct nfs4_sessionid id;\r\nint status;\r\n__be32 *p;\r\nu32 dummy;\r\nstatus = -ESERVERFAULT;\r\np = xdr_inline_decode(xdr, NFS4_MAX_SESSIONID_LEN + 4 + 4 + 4 + 4);\r\nif (unlikely(p == NULL))\r\ngoto out_overflow;\r\nmemcpy(id.data, p, NFS4_MAX_SESSIONID_LEN);\r\nif (memcmp(id.data, session->se_sessionid.data,\r\nNFS4_MAX_SESSIONID_LEN) != 0) {\r\ndprintk("NFS: %s Invalid session id\n", __func__);\r\ngoto out;\r\n}\r\np += XDR_QUADLEN(NFS4_MAX_SESSIONID_LEN);\r\ndummy = be32_to_cpup(p++);\r\nif (dummy != session->se_cb_seq_nr) {\r\ndprintk("NFS: %s Invalid sequence number\n", __func__);\r\ngoto out;\r\n}\r\ndummy = be32_to_cpup(p++);\r\nif (dummy != 0) {\r\ndprintk("NFS: %s Invalid slotid\n", __func__);\r\ngoto out;\r\n}\r\nstatus = 0;\r\nout:\r\nif (status)\r\nnfsd4_mark_cb_fault(cb->cb_clp, status);\r\nreturn status;\r\nout_overflow:\r\nprint_overflow_msg(__func__, xdr);\r\nreturn -EIO;\r\n}\r\nstatic int decode_cb_sequence4res(struct xdr_stream *xdr,\r\nstruct nfsd4_callback *cb)\r\n{\r\nenum nfsstat4 nfserr;\r\nint status;\r\nif (cb->cb_minorversion == 0)\r\nreturn 0;\r\nstatus = decode_cb_op_status(xdr, OP_CB_SEQUENCE, &nfserr);\r\nif (unlikely(status))\r\ngoto out;\r\nif (unlikely(nfserr != NFS4_OK))\r\ngoto out_default;\r\nstatus = decode_cb_sequence4resok(xdr, cb);\r\nout:\r\nreturn status;\r\nout_default:\r\nreturn nfs_cb_stat_to_errno(nfserr);\r\n}\r\nstatic void nfs4_xdr_enc_cb_null(struct rpc_rqst *req, struct xdr_stream *xdr,\r\nvoid *__unused)\r\n{\r\nxdr_reserve_space(xdr, 0);\r\n}\r\nstatic void nfs4_xdr_enc_cb_recall(struct rpc_rqst *req, struct xdr_stream *xdr,\r\nconst struct nfsd4_callback *cb)\r\n{\r\nconst struct nfs4_delegation *args = cb->cb_op;\r\nstruct nfs4_cb_compound_hdr hdr = {\r\n.ident = cb->cb_clp->cl_cb_ident,\r\n.minorversion = cb->cb_minorversion,\r\n};\r\nencode_cb_compound4args(xdr, &hdr);\r\nencode_cb_sequence4args(xdr, cb, &hdr);\r\nencode_cb_recall4args(xdr, args, &hdr);\r\nencode_cb_nops(&hdr);\r\n}\r\nstatic int nfs4_xdr_dec_cb_null(struct rpc_rqst *req, struct xdr_stream *xdr,\r\nvoid *__unused)\r\n{\r\nreturn 0;\r\n}\r\nstatic int nfs4_xdr_dec_cb_recall(struct rpc_rqst *rqstp,\r\nstruct xdr_stream *xdr,\r\nstruct nfsd4_callback *cb)\r\n{\r\nstruct nfs4_cb_compound_hdr hdr;\r\nenum nfsstat4 nfserr;\r\nint status;\r\nstatus = decode_cb_compound4res(xdr, &hdr);\r\nif (unlikely(status))\r\ngoto out;\r\nif (cb != NULL) {\r\nstatus = decode_cb_sequence4res(xdr, cb);\r\nif (unlikely(status))\r\ngoto out;\r\n}\r\nstatus = decode_cb_op_status(xdr, OP_CB_RECALL, &nfserr);\r\nif (unlikely(status))\r\ngoto out;\r\nif (unlikely(nfserr != NFS4_OK))\r\nstatus = nfs_cb_stat_to_errno(nfserr);\r\nout:\r\nreturn status;\r\n}\r\nstatic int max_cb_time(struct net *net)\r\n{\r\nstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\r\nreturn max(nn->nfsd4_lease/10, (time_t)1) * HZ;\r\n}\r\nint set_callback_cred(void)\r\n{\r\nif (callback_cred)\r\nreturn 0;\r\ncallback_cred = rpc_lookup_machine_cred("nfs");\r\nif (!callback_cred)\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nstatic struct rpc_cred *get_backchannel_cred(struct nfs4_client *clp, struct rpc_clnt *client, struct nfsd4_session *ses)\r\n{\r\nif (clp->cl_minorversion == 0) {\r\nreturn get_rpccred(callback_cred);\r\n} else {\r\nstruct rpc_auth *auth = client->cl_auth;\r\nstruct auth_cred acred = {};\r\nacred.uid = ses->se_cb_sec.uid;\r\nacred.gid = ses->se_cb_sec.gid;\r\nreturn auth->au_ops->lookup_cred(client->cl_auth, &acred, 0);\r\n}\r\n}\r\nstatic int setup_callback_client(struct nfs4_client *clp, struct nfs4_cb_conn *conn, struct nfsd4_session *ses)\r\n{\r\nstruct rpc_timeout timeparms = {\r\n.to_initval = max_cb_time(clp->net),\r\n.to_retries = 0,\r\n};\r\nstruct rpc_create_args args = {\r\n.net = clp->net,\r\n.address = (struct sockaddr *) &conn->cb_addr,\r\n.addrsize = conn->cb_addrlen,\r\n.saddress = (struct sockaddr *) &conn->cb_saddr,\r\n.timeout = &timeparms,\r\n.program = &cb_program,\r\n.version = 0,\r\n.flags = (RPC_CLNT_CREATE_NOPING | RPC_CLNT_CREATE_QUIET),\r\n};\r\nstruct rpc_clnt *client;\r\nstruct rpc_cred *cred;\r\nif (clp->cl_minorversion == 0) {\r\nif (!clp->cl_cred.cr_principal &&\r\n(clp->cl_cred.cr_flavor >= RPC_AUTH_GSS_KRB5))\r\nreturn -EINVAL;\r\nargs.client_name = clp->cl_cred.cr_principal;\r\nargs.prognumber = conn->cb_prog,\r\nargs.protocol = XPRT_TRANSPORT_TCP;\r\nargs.authflavor = clp->cl_cred.cr_flavor;\r\nclp->cl_cb_ident = conn->cb_ident;\r\n} else {\r\nif (!conn->cb_xprt)\r\nreturn -EINVAL;\r\nclp->cl_cb_conn.cb_xprt = conn->cb_xprt;\r\nclp->cl_cb_session = ses;\r\nargs.bc_xprt = conn->cb_xprt;\r\nargs.prognumber = clp->cl_cb_session->se_cb_prog;\r\nargs.protocol = XPRT_TRANSPORT_BC_TCP;\r\nargs.authflavor = ses->se_cb_sec.flavor;\r\n}\r\nclient = rpc_create(&args);\r\nif (IS_ERR(client)) {\r\ndprintk("NFSD: couldn't create callback client: %ld\n",\r\nPTR_ERR(client));\r\nreturn PTR_ERR(client);\r\n}\r\ncred = get_backchannel_cred(clp, client, ses);\r\nif (IS_ERR(cred)) {\r\nrpc_shutdown_client(client);\r\nreturn PTR_ERR(cred);\r\n}\r\nclp->cl_cb_client = client;\r\nclp->cl_cb_cred = cred;\r\nreturn 0;\r\n}\r\nstatic void warn_no_callback_path(struct nfs4_client *clp, int reason)\r\n{\r\ndprintk("NFSD: warning: no callback path to client %.*s: error %d\n",\r\n(int)clp->cl_name.len, clp->cl_name.data, reason);\r\n}\r\nstatic void nfsd4_mark_cb_down(struct nfs4_client *clp, int reason)\r\n{\r\nclp->cl_cb_state = NFSD4_CB_DOWN;\r\nwarn_no_callback_path(clp, reason);\r\n}\r\nstatic void nfsd4_mark_cb_fault(struct nfs4_client *clp, int reason)\r\n{\r\nclp->cl_cb_state = NFSD4_CB_FAULT;\r\nwarn_no_callback_path(clp, reason);\r\n}\r\nstatic void nfsd4_cb_probe_done(struct rpc_task *task, void *calldata)\r\n{\r\nstruct nfs4_client *clp = container_of(calldata, struct nfs4_client, cl_cb_null);\r\nif (task->tk_status)\r\nnfsd4_mark_cb_down(clp, task->tk_status);\r\nelse\r\nclp->cl_cb_state = NFSD4_CB_UP;\r\n}\r\nstatic void run_nfsd4_cb(struct nfsd4_callback *cb)\r\n{\r\nqueue_work(callback_wq, &cb->cb_work);\r\n}\r\nstatic void do_probe_callback(struct nfs4_client *clp)\r\n{\r\nstruct nfsd4_callback *cb = &clp->cl_cb_null;\r\ncb->cb_op = NULL;\r\ncb->cb_clp = clp;\r\ncb->cb_msg.rpc_proc = &nfs4_cb_procedures[NFSPROC4_CLNT_CB_NULL];\r\ncb->cb_msg.rpc_argp = NULL;\r\ncb->cb_msg.rpc_resp = NULL;\r\ncb->cb_ops = &nfsd4_cb_probe_ops;\r\nrun_nfsd4_cb(cb);\r\n}\r\nvoid nfsd4_probe_callback(struct nfs4_client *clp)\r\n{\r\nclp->cl_cb_state = NFSD4_CB_UNKNOWN;\r\nset_bit(NFSD4_CLIENT_CB_UPDATE, &clp->cl_flags);\r\ndo_probe_callback(clp);\r\n}\r\nvoid nfsd4_probe_callback_sync(struct nfs4_client *clp)\r\n{\r\nnfsd4_probe_callback(clp);\r\nflush_workqueue(callback_wq);\r\n}\r\nvoid nfsd4_change_callback(struct nfs4_client *clp, struct nfs4_cb_conn *conn)\r\n{\r\nclp->cl_cb_state = NFSD4_CB_UNKNOWN;\r\nspin_lock(&clp->cl_lock);\r\nmemcpy(&clp->cl_cb_conn, conn, sizeof(struct nfs4_cb_conn));\r\nspin_unlock(&clp->cl_lock);\r\n}\r\nstatic bool nfsd41_cb_get_slot(struct nfs4_client *clp, struct rpc_task *task)\r\n{\r\nif (test_and_set_bit(0, &clp->cl_cb_slot_busy) != 0) {\r\nrpc_sleep_on(&clp->cl_cb_waitq, task, NULL);\r\ndprintk("%s slot is busy\n", __func__);\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\nstatic void nfsd4_cb_prepare(struct rpc_task *task, void *calldata)\r\n{\r\nstruct nfsd4_callback *cb = calldata;\r\nstruct nfs4_delegation *dp = container_of(cb, struct nfs4_delegation, dl_recall);\r\nstruct nfs4_client *clp = dp->dl_stid.sc_client;\r\nu32 minorversion = clp->cl_minorversion;\r\ncb->cb_minorversion = minorversion;\r\nif (minorversion) {\r\nif (!nfsd41_cb_get_slot(clp, task))\r\nreturn;\r\n}\r\nspin_lock(&clp->cl_lock);\r\nif (list_empty(&cb->cb_per_client)) {\r\ncb->cb_done = false;\r\nlist_add(&cb->cb_per_client, &clp->cl_callbacks);\r\n}\r\nspin_unlock(&clp->cl_lock);\r\nrpc_call_start(task);\r\n}\r\nstatic void nfsd4_cb_done(struct rpc_task *task, void *calldata)\r\n{\r\nstruct nfsd4_callback *cb = calldata;\r\nstruct nfs4_delegation *dp = container_of(cb, struct nfs4_delegation, dl_recall);\r\nstruct nfs4_client *clp = dp->dl_stid.sc_client;\r\ndprintk("%s: minorversion=%d\n", __func__,\r\nclp->cl_minorversion);\r\nif (clp->cl_minorversion) {\r\n++clp->cl_cb_session->se_cb_seq_nr;\r\nclear_bit(0, &clp->cl_cb_slot_busy);\r\nrpc_wake_up_next(&clp->cl_cb_waitq);\r\ndprintk("%s: freed slot, new seqid=%d\n", __func__,\r\nclp->cl_cb_session->se_cb_seq_nr);\r\ntask->tk_msg.rpc_resp = NULL;\r\n}\r\n}\r\nstatic void nfsd4_cb_recall_done(struct rpc_task *task, void *calldata)\r\n{\r\nstruct nfsd4_callback *cb = calldata;\r\nstruct nfs4_delegation *dp = container_of(cb, struct nfs4_delegation, dl_recall);\r\nstruct nfs4_client *clp = dp->dl_stid.sc_client;\r\nstruct rpc_clnt *current_rpc_client = clp->cl_cb_client;\r\nnfsd4_cb_done(task, calldata);\r\nif (current_rpc_client != task->tk_client) {\r\nreturn;\r\n}\r\nif (cb->cb_done)\r\nreturn;\r\nswitch (task->tk_status) {\r\ncase 0:\r\ncb->cb_done = true;\r\nreturn;\r\ncase -EBADHANDLE:\r\ncase -NFS4ERR_BAD_STATEID:\r\nbreak;\r\ndefault:\r\nnfsd4_mark_cb_down(clp, task->tk_status);\r\n}\r\nif (dp->dl_retries--) {\r\nrpc_delay(task, 2*HZ);\r\ntask->tk_status = 0;\r\nrpc_restart_call_prepare(task);\r\nreturn;\r\n}\r\nnfsd4_mark_cb_down(clp, task->tk_status);\r\ncb->cb_done = true;\r\n}\r\nstatic void nfsd4_cb_recall_release(void *calldata)\r\n{\r\nstruct nfsd4_callback *cb = calldata;\r\nstruct nfs4_client *clp = cb->cb_clp;\r\nstruct nfs4_delegation *dp = container_of(cb, struct nfs4_delegation, dl_recall);\r\nif (cb->cb_done) {\r\nspin_lock(&clp->cl_lock);\r\nlist_del(&cb->cb_per_client);\r\nspin_unlock(&clp->cl_lock);\r\nnfs4_put_delegation(dp);\r\n}\r\n}\r\nint nfsd4_create_callback_queue(void)\r\n{\r\ncallback_wq = create_singlethread_workqueue("nfsd4_callbacks");\r\nif (!callback_wq)\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nvoid nfsd4_destroy_callback_queue(void)\r\n{\r\ndestroy_workqueue(callback_wq);\r\n}\r\nvoid nfsd4_shutdown_callback(struct nfs4_client *clp)\r\n{\r\nset_bit(NFSD4_CLIENT_CB_KILL, &clp->cl_flags);\r\ndo_probe_callback(clp);\r\nflush_workqueue(callback_wq);\r\n}\r\nstatic void nfsd4_release_cb(struct nfsd4_callback *cb)\r\n{\r\nif (cb->cb_ops->rpc_release)\r\ncb->cb_ops->rpc_release(cb);\r\n}\r\nstatic struct nfsd4_conn * __nfsd4_find_backchannel(struct nfs4_client *clp)\r\n{\r\nstruct nfsd4_session *s;\r\nstruct nfsd4_conn *c;\r\nlist_for_each_entry(s, &clp->cl_sessions, se_perclnt) {\r\nlist_for_each_entry(c, &s->se_conns, cn_persession) {\r\nif (c->cn_flags & NFS4_CDFC4_BACK)\r\nreturn c;\r\n}\r\n}\r\nreturn NULL;\r\n}\r\nstatic void nfsd4_process_cb_update(struct nfsd4_callback *cb)\r\n{\r\nstruct nfs4_cb_conn conn;\r\nstruct nfs4_client *clp = cb->cb_clp;\r\nstruct nfsd4_session *ses = NULL;\r\nstruct nfsd4_conn *c;\r\nint err;\r\nif (clp->cl_cb_client) {\r\nrpc_shutdown_client(clp->cl_cb_client);\r\nclp->cl_cb_client = NULL;\r\nput_rpccred(clp->cl_cb_cred);\r\nclp->cl_cb_cred = NULL;\r\n}\r\nif (clp->cl_cb_conn.cb_xprt) {\r\nsvc_xprt_put(clp->cl_cb_conn.cb_xprt);\r\nclp->cl_cb_conn.cb_xprt = NULL;\r\n}\r\nif (test_bit(NFSD4_CLIENT_CB_KILL, &clp->cl_flags))\r\nreturn;\r\nspin_lock(&clp->cl_lock);\r\nBUG_ON(!(clp->cl_flags & NFSD4_CLIENT_CB_FLAG_MASK));\r\nclear_bit(NFSD4_CLIENT_CB_UPDATE, &clp->cl_flags);\r\nmemcpy(&conn, &cb->cb_clp->cl_cb_conn, sizeof(struct nfs4_cb_conn));\r\nc = __nfsd4_find_backchannel(clp);\r\nif (c) {\r\nsvc_xprt_get(c->cn_xprt);\r\nconn.cb_xprt = c->cn_xprt;\r\nses = c->cn_session;\r\n}\r\nspin_unlock(&clp->cl_lock);\r\nerr = setup_callback_client(clp, &conn, ses);\r\nif (err) {\r\nnfsd4_mark_cb_down(clp, err);\r\nreturn;\r\n}\r\nlist_for_each_entry(cb, &clp->cl_callbacks, cb_per_client)\r\nrun_nfsd4_cb(cb);\r\n}\r\nstatic void nfsd4_do_callback_rpc(struct work_struct *w)\r\n{\r\nstruct nfsd4_callback *cb = container_of(w, struct nfsd4_callback, cb_work);\r\nstruct nfs4_client *clp = cb->cb_clp;\r\nstruct rpc_clnt *clnt;\r\nif (clp->cl_flags & NFSD4_CLIENT_CB_FLAG_MASK)\r\nnfsd4_process_cb_update(cb);\r\nclnt = clp->cl_cb_client;\r\nif (!clnt) {\r\nnfsd4_release_cb(cb);\r\nreturn;\r\n}\r\ncb->cb_msg.rpc_cred = clp->cl_cb_cred;\r\nrpc_call_async(clnt, &cb->cb_msg, RPC_TASK_SOFT | RPC_TASK_SOFTCONN,\r\ncb->cb_ops, cb);\r\n}\r\nvoid nfsd4_init_callback(struct nfsd4_callback *cb)\r\n{\r\nINIT_WORK(&cb->cb_work, nfsd4_do_callback_rpc);\r\n}\r\nvoid nfsd4_cb_recall(struct nfs4_delegation *dp)\r\n{\r\nstruct nfsd4_callback *cb = &dp->dl_recall;\r\nstruct nfs4_client *clp = dp->dl_stid.sc_client;\r\ndp->dl_retries = 1;\r\ncb->cb_op = dp;\r\ncb->cb_clp = clp;\r\ncb->cb_msg.rpc_proc = &nfs4_cb_procedures[NFSPROC4_CLNT_CB_RECALL];\r\ncb->cb_msg.rpc_argp = cb;\r\ncb->cb_msg.rpc_resp = cb;\r\ncb->cb_ops = &nfsd4_cb_recall_ops;\r\nINIT_LIST_HEAD(&cb->cb_per_client);\r\ncb->cb_done = true;\r\nrun_nfsd4_cb(&dp->dl_recall);\r\n}
