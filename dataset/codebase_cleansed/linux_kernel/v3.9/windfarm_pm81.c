static void wf_smu_create_sys_fans(void)\r\n{\r\nstruct wf_smu_sys_fans_param *param = NULL;\r\nstruct wf_pid_param pid_param;\r\nint i;\r\nfor (i = 0; i < WF_SMU_SYS_FANS_NUM_CONFIGS; i++)\r\nif (wf_smu_sys_all_params[i].model_id == wf_smu_mach_model) {\r\nparam = &wf_smu_sys_all_params[i];\r\nbreak;\r\n}\r\nif (param == NULL) {\r\nprintk(KERN_WARNING "windfarm: System fan config not found "\r\n"for this machine model, max fan speed\n");\r\ngoto fail;\r\n}\r\nwf_smu_sys_fans = kmalloc(sizeof(struct wf_smu_sys_fans_state),\r\nGFP_KERNEL);\r\nif (wf_smu_sys_fans == NULL) {\r\nprintk(KERN_WARNING "windfarm: Memory allocation error"\r\n" max fan speed\n");\r\ngoto fail;\r\n}\r\nwf_smu_sys_fans->ticks = 1;\r\nwf_smu_sys_fans->scale0 = param->scale0;\r\nwf_smu_sys_fans->offset0 = param->offset0;\r\nwf_smu_sys_fans->scale1 = param->scale1;\r\nwf_smu_sys_fans->offset1 = param->offset1;\r\npid_param.gd = param->gd;\r\npid_param.gp = param->gp;\r\npid_param.gr = param->gr;\r\npid_param.interval = WF_SMU_SYS_FANS_INTERVAL;\r\npid_param.history_len = WF_SMU_SYS_FANS_HISTORY_SIZE;\r\npid_param.itarget = param->itarget;\r\npid_param.min = wf_control_get_min(fan_system);\r\npid_param.max = wf_control_get_max(fan_system);\r\nif (fan_hd) {\r\npid_param.min =\r\nmax(pid_param.min, wf_control_get_min(fan_hd));\r\npid_param.max =\r\nmin(pid_param.max, wf_control_get_max(fan_hd));\r\n}\r\nwf_pid_init(&wf_smu_sys_fans->pid, &pid_param);\r\nDBG("wf: System Fan control initialized.\n");\r\nDBG(" itarged=%d.%03d, min=%d RPM, max=%d RPM\n",\r\nFIX32TOPRINT(pid_param.itarget), pid_param.min, pid_param.max);\r\nreturn;\r\nfail:\r\nif (fan_system)\r\nwf_control_set_max(fan_system);\r\nif (fan_hd)\r\nwf_control_set_max(fan_hd);\r\n}\r\nstatic void wf_smu_sys_fans_tick(struct wf_smu_sys_fans_state *st)\r\n{\r\ns32 new_setpoint, temp, scaled, cputarget;\r\nint rc;\r\nif (--st->ticks != 0) {\r\nif (wf_smu_readjust)\r\ngoto readjust;\r\nreturn;\r\n}\r\nst->ticks = WF_SMU_SYS_FANS_INTERVAL;\r\nrc = wf_sensor_get(sensor_hd_temp, &temp);\r\nif (rc) {\r\nprintk(KERN_WARNING "windfarm: HD temp sensor error %d\n",\r\nrc);\r\nwf_smu_failure_state |= FAILURE_SENSOR;\r\nreturn;\r\n}\r\nDBG("wf_smu: System Fans tick ! HD temp: %d.%03d\n",\r\nFIX32TOPRINT(temp));\r\nif (temp > (st->pid.param.itarget + 0x50000))\r\nwf_smu_failure_state |= FAILURE_OVERTEMP;\r\nnew_setpoint = wf_pid_run(&st->pid, temp);\r\nDBG("wf_smu: new_setpoint: %d RPM\n", (int)new_setpoint);\r\nscaled = ((((s64)new_setpoint) * (s64)st->scale0) >> 12) + st->offset0;\r\nDBG("wf_smu: scaled setpoint: %d RPM\n", (int)scaled);\r\ncputarget = wf_smu_cpu_fans ? wf_smu_cpu_fans->pid.target : 0;\r\ncputarget = ((((s64)cputarget) * (s64)st->scale1) >> 12) + st->offset1;\r\nscaled = max(scaled, cputarget);\r\nscaled = max(scaled, st->pid.param.min);\r\nscaled = min(scaled, st->pid.param.max);\r\nDBG("wf_smu: adjusted setpoint: %d RPM\n", (int)scaled);\r\nif (st->sys_setpoint == scaled && new_setpoint == st->hd_setpoint)\r\nreturn;\r\nst->sys_setpoint = scaled;\r\nst->hd_setpoint = new_setpoint;\r\nreadjust:\r\nif (fan_system && wf_smu_failure_state == 0) {\r\nrc = wf_control_set(fan_system, st->sys_setpoint);\r\nif (rc) {\r\nprintk(KERN_WARNING "windfarm: Sys fan error %d\n",\r\nrc);\r\nwf_smu_failure_state |= FAILURE_FAN;\r\n}\r\n}\r\nif (fan_hd && wf_smu_failure_state == 0) {\r\nrc = wf_control_set(fan_hd, st->hd_setpoint);\r\nif (rc) {\r\nprintk(KERN_WARNING "windfarm: HD fan error %d\n",\r\nrc);\r\nwf_smu_failure_state |= FAILURE_FAN;\r\n}\r\n}\r\n}\r\nstatic void wf_smu_create_cpu_fans(void)\r\n{\r\nstruct wf_cpu_pid_param pid_param;\r\nconst struct smu_sdbp_header *hdr;\r\nstruct smu_sdbp_cpupiddata *piddata;\r\nstruct smu_sdbp_fvt *fvt;\r\ns32 tmax, tdelta, maxpow, powadj;\r\nhdr = smu_get_sdb_partition(SMU_SDB_CPUPIDDATA_ID, NULL);\r\nif (hdr == 0) {\r\nprintk(KERN_WARNING "windfarm: CPU PID fan config not found "\r\n"max fan speed\n");\r\ngoto fail;\r\n}\r\npiddata = (struct smu_sdbp_cpupiddata *)&hdr[1];\r\nhdr = smu_get_sdb_partition(SMU_SDB_FVT_ID, NULL);\r\nif (hdr) {\r\nfvt = (struct smu_sdbp_fvt *)&hdr[1];\r\ntmax = ((s32)fvt->maxtemp) << 16;\r\n} else\r\ntmax = 0x5e0000;\r\nwf_smu_cpu_fans = kmalloc(sizeof(struct wf_smu_cpu_fans_state),\r\nGFP_KERNEL);\r\nif (wf_smu_cpu_fans == NULL)\r\ngoto fail;\r\nwf_smu_cpu_fans->ticks = 1;\r\nwf_smu_cpu_fans->scale = WF_SMU_CPU_FANS_SIBLING_SCALE;\r\nwf_smu_cpu_fans->offset = WF_SMU_CPU_FANS_SIBLING_OFFSET;\r\npid_param.interval = WF_SMU_CPU_FANS_INTERVAL;\r\npid_param.history_len = piddata->history_len;\r\nif (pid_param.history_len > WF_CPU_PID_MAX_HISTORY) {\r\nprintk(KERN_WARNING "windfarm: History size overflow on "\r\n"CPU control loop (%d)\n", piddata->history_len);\r\npid_param.history_len = WF_CPU_PID_MAX_HISTORY;\r\n}\r\npid_param.gd = piddata->gd;\r\npid_param.gp = piddata->gp;\r\npid_param.gr = piddata->gr / pid_param.history_len;\r\ntdelta = ((s32)piddata->target_temp_delta) << 16;\r\nmaxpow = ((s32)piddata->max_power) << 16;\r\npowadj = ((s32)piddata->power_adj) << 16;\r\npid_param.tmax = tmax;\r\npid_param.ttarget = tmax - tdelta;\r\npid_param.pmaxadj = maxpow - powadj;\r\npid_param.min = wf_control_get_min(fan_cpu_main);\r\npid_param.max = wf_control_get_max(fan_cpu_main);\r\nwf_cpu_pid_init(&wf_smu_cpu_fans->pid, &pid_param);\r\nDBG("wf: CPU Fan control initialized.\n");\r\nDBG(" ttarged=%d.%03d, tmax=%d.%03d, min=%d RPM, max=%d RPM\n",\r\nFIX32TOPRINT(pid_param.ttarget), FIX32TOPRINT(pid_param.tmax),\r\npid_param.min, pid_param.max);\r\nreturn;\r\nfail:\r\nprintk(KERN_WARNING "windfarm: CPU fan config not found\n"\r\n"for this machine model, max fan speed\n");\r\nif (cpufreq_clamp)\r\nwf_control_set_max(cpufreq_clamp);\r\nif (fan_cpu_main)\r\nwf_control_set_max(fan_cpu_main);\r\n}\r\nstatic void wf_smu_cpu_fans_tick(struct wf_smu_cpu_fans_state *st)\r\n{\r\ns32 new_setpoint, temp, power, systarget;\r\nint rc;\r\nif (--st->ticks != 0) {\r\nif (wf_smu_readjust)\r\ngoto readjust;\r\nreturn;\r\n}\r\nst->ticks = WF_SMU_CPU_FANS_INTERVAL;\r\nrc = wf_sensor_get(sensor_cpu_temp, &temp);\r\nif (rc) {\r\nprintk(KERN_WARNING "windfarm: CPU temp sensor error %d\n",\r\nrc);\r\nwf_smu_failure_state |= FAILURE_SENSOR;\r\nreturn;\r\n}\r\nrc = wf_sensor_get(sensor_cpu_power, &power);\r\nif (rc) {\r\nprintk(KERN_WARNING "windfarm: CPU power sensor error %d\n",\r\nrc);\r\nwf_smu_failure_state |= FAILURE_SENSOR;\r\nreturn;\r\n}\r\nDBG("wf_smu: CPU Fans tick ! CPU temp: %d.%03d, power: %d.%03d\n",\r\nFIX32TOPRINT(temp), FIX32TOPRINT(power));\r\n#ifdef HACKED_OVERTEMP\r\nif (temp > 0x4a0000)\r\nwf_smu_failure_state |= FAILURE_OVERTEMP;\r\n#else\r\nif (temp > st->pid.param.tmax)\r\nwf_smu_failure_state |= FAILURE_OVERTEMP;\r\n#endif\r\nnew_setpoint = wf_cpu_pid_run(&st->pid, power, temp);\r\nDBG("wf_smu: new_setpoint: %d RPM\n", (int)new_setpoint);\r\nsystarget = wf_smu_sys_fans ? wf_smu_sys_fans->pid.target : 0;\r\nsystarget = ((((s64)systarget) * (s64)st->scale) >> 12)\r\n+ st->offset;\r\nnew_setpoint = max(new_setpoint, systarget);\r\nnew_setpoint = max(new_setpoint, st->pid.param.min);\r\nnew_setpoint = min(new_setpoint, st->pid.param.max);\r\nDBG("wf_smu: adjusted setpoint: %d RPM\n", (int)new_setpoint);\r\nif (st->cpu_setpoint == new_setpoint)\r\nreturn;\r\nst->cpu_setpoint = new_setpoint;\r\nreadjust:\r\nif (fan_cpu_main && wf_smu_failure_state == 0) {\r\nrc = wf_control_set(fan_cpu_main, st->cpu_setpoint);\r\nif (rc) {\r\nprintk(KERN_WARNING "windfarm: CPU main fan"\r\n" error %d\n", rc);\r\nwf_smu_failure_state |= FAILURE_FAN;\r\n}\r\n}\r\n}\r\nstatic void wf_smu_tick(void)\r\n{\r\nunsigned int last_failure = wf_smu_failure_state;\r\nunsigned int new_failure;\r\nif (!wf_smu_started) {\r\nDBG("wf: creating control loops !\n");\r\nwf_smu_create_sys_fans();\r\nwf_smu_create_cpu_fans();\r\nwf_smu_started = 1;\r\n}\r\nif (wf_smu_skipping && --wf_smu_skipping)\r\nreturn;\r\nwf_smu_failure_state = 0;\r\nif (wf_smu_sys_fans)\r\nwf_smu_sys_fans_tick(wf_smu_sys_fans);\r\nif (wf_smu_cpu_fans)\r\nwf_smu_cpu_fans_tick(wf_smu_cpu_fans);\r\nwf_smu_readjust = 0;\r\nnew_failure = wf_smu_failure_state & ~last_failure;\r\nif (wf_smu_failure_state && !last_failure) {\r\nif (cpufreq_clamp)\r\nwf_control_set_max(cpufreq_clamp);\r\nif (fan_system)\r\nwf_control_set_max(fan_system);\r\nif (fan_cpu_main)\r\nwf_control_set_max(fan_cpu_main);\r\nif (fan_hd)\r\nwf_control_set_max(fan_hd);\r\n}\r\nif (!wf_smu_failure_state && last_failure) {\r\nif (cpufreq_clamp)\r\nwf_control_set_min(cpufreq_clamp);\r\nwf_smu_readjust = 1;\r\n}\r\nif (new_failure & FAILURE_OVERTEMP) {\r\nwf_set_overtemp();\r\nwf_smu_skipping = 2;\r\n}\r\nif (new_failure == 0 && last_failure & FAILURE_OVERTEMP)\r\nwf_clear_overtemp();\r\n}\r\nstatic void wf_smu_new_control(struct wf_control *ct)\r\n{\r\nif (wf_smu_all_controls_ok)\r\nreturn;\r\nif (fan_cpu_main == NULL && !strcmp(ct->name, "cpu-fan")) {\r\nif (wf_get_control(ct) == 0)\r\nfan_cpu_main = ct;\r\n}\r\nif (fan_system == NULL && !strcmp(ct->name, "system-fan")) {\r\nif (wf_get_control(ct) == 0)\r\nfan_system = ct;\r\n}\r\nif (cpufreq_clamp == NULL && !strcmp(ct->name, "cpufreq-clamp")) {\r\nif (wf_get_control(ct) == 0)\r\ncpufreq_clamp = ct;\r\n}\r\nif (wf_smu_mach_model > 3) {\r\nif (fan_system && fan_cpu_main && cpufreq_clamp)\r\nwf_smu_all_controls_ok = 1;\r\nreturn;\r\n}\r\nif (fan_hd == NULL && !strcmp(ct->name, "drive-bay-fan")) {\r\nif (wf_get_control(ct) == 0)\r\nfan_hd = ct;\r\n}\r\nif (fan_system && fan_hd && fan_cpu_main && cpufreq_clamp)\r\nwf_smu_all_controls_ok = 1;\r\n}\r\nstatic void wf_smu_new_sensor(struct wf_sensor *sr)\r\n{\r\nif (wf_smu_all_sensors_ok)\r\nreturn;\r\nif (sensor_cpu_power == NULL && !strcmp(sr->name, "cpu-power")) {\r\nif (wf_get_sensor(sr) == 0)\r\nsensor_cpu_power = sr;\r\n}\r\nif (sensor_cpu_temp == NULL && !strcmp(sr->name, "cpu-temp")) {\r\nif (wf_get_sensor(sr) == 0)\r\nsensor_cpu_temp = sr;\r\n}\r\nif (sensor_hd_temp == NULL && !strcmp(sr->name, "hd-temp")) {\r\nif (wf_get_sensor(sr) == 0)\r\nsensor_hd_temp = sr;\r\n}\r\nif (sensor_cpu_power && sensor_cpu_temp && sensor_hd_temp)\r\nwf_smu_all_sensors_ok = 1;\r\n}\r\nstatic int wf_smu_notify(struct notifier_block *self,\r\nunsigned long event, void *data)\r\n{\r\nswitch(event) {\r\ncase WF_EVENT_NEW_CONTROL:\r\nDBG("wf: new control %s detected\n",\r\n((struct wf_control *)data)->name);\r\nwf_smu_new_control(data);\r\nwf_smu_readjust = 1;\r\nbreak;\r\ncase WF_EVENT_NEW_SENSOR:\r\nDBG("wf: new sensor %s detected\n",\r\n((struct wf_sensor *)data)->name);\r\nwf_smu_new_sensor(data);\r\nbreak;\r\ncase WF_EVENT_TICK:\r\nif (wf_smu_all_controls_ok && wf_smu_all_sensors_ok)\r\nwf_smu_tick();\r\n}\r\nreturn 0;\r\n}\r\nstatic int wf_init_pm(void)\r\n{\r\nconst struct smu_sdbp_header *hdr;\r\nhdr = smu_get_sdb_partition(SMU_SDB_SENSORTREE_ID, NULL);\r\nif (hdr != 0) {\r\nstruct smu_sdbp_sensortree *st =\r\n(struct smu_sdbp_sensortree *)&hdr[1];\r\nwf_smu_mach_model = st->model_id;\r\n}\r\nprintk(KERN_INFO "windfarm: Initializing for iMacG5 model ID %d\n",\r\nwf_smu_mach_model);\r\nreturn 0;\r\n}\r\nstatic int wf_smu_probe(struct platform_device *ddev)\r\n{\r\nwf_register_client(&wf_smu_events);\r\nreturn 0;\r\n}\r\nstatic int wf_smu_remove(struct platform_device *ddev)\r\n{\r\nwf_unregister_client(&wf_smu_events);\r\nmsleep(1000);\r\nif (sensor_cpu_power)\r\nwf_put_sensor(sensor_cpu_power);\r\nif (sensor_cpu_temp)\r\nwf_put_sensor(sensor_cpu_temp);\r\nif (sensor_hd_temp)\r\nwf_put_sensor(sensor_hd_temp);\r\nif (fan_cpu_main)\r\nwf_put_control(fan_cpu_main);\r\nif (fan_hd)\r\nwf_put_control(fan_hd);\r\nif (fan_system)\r\nwf_put_control(fan_system);\r\nif (cpufreq_clamp)\r\nwf_put_control(cpufreq_clamp);\r\nkfree(wf_smu_sys_fans);\r\nkfree(wf_smu_cpu_fans);\r\nreturn 0;\r\n}\r\nstatic int __init wf_smu_init(void)\r\n{\r\nint rc = -ENODEV;\r\nif (of_machine_is_compatible("PowerMac8,1") ||\r\nof_machine_is_compatible("PowerMac8,2"))\r\nrc = wf_init_pm();\r\nif (rc == 0) {\r\n#ifdef MODULE\r\nrequest_module("windfarm_smu_controls");\r\nrequest_module("windfarm_smu_sensors");\r\nrequest_module("windfarm_lm75_sensor");\r\nrequest_module("windfarm_cpufreq_clamp");\r\n#endif\r\nplatform_driver_register(&wf_smu_driver);\r\n}\r\nreturn rc;\r\n}\r\nstatic void __exit wf_smu_exit(void)\r\n{\r\nplatform_driver_unregister(&wf_smu_driver);\r\n}
