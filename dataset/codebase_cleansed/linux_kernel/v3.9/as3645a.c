static int as3645a_write(struct as3645a *flash, u8 addr, u8 val)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(&flash->subdev);\r\nint rval;\r\nrval = i2c_smbus_write_byte_data(client, addr, val);\r\ndev_dbg(&client->dev, "Write Addr:%02X Val:%02X %s\n", addr, val,\r\nrval < 0 ? "fail" : "ok");\r\nreturn rval;\r\n}\r\nstatic int as3645a_read(struct as3645a *flash, u8 addr)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(&flash->subdev);\r\nint rval;\r\nrval = i2c_smbus_read_byte_data(client, addr);\r\ndev_dbg(&client->dev, "Read Addr:%02X Val:%02X %s\n", addr, rval,\r\nrval < 0 ? "fail" : "ok");\r\nreturn rval;\r\n}\r\nstatic int as3645a_set_config(struct as3645a *flash)\r\n{\r\nint ret;\r\nu8 val;\r\nval = (flash->flash_current << AS_CURRENT_FLASH_CURRENT_SHIFT)\r\n| (flash->assist_current << AS_CURRENT_ASSIST_LIGHT_SHIFT)\r\n| AS_CURRENT_LED_DET_ON;\r\nret = as3645a_write(flash, AS_CURRENT_SET_REG, val);\r\nif (ret < 0)\r\nreturn ret;\r\nval = AS_TIMER_MS_TO_CODE(flash->timeout / 1000)\r\n<< AS_INDICATOR_AND_TIMER_TIMEOUT_SHIFT;\r\nval |= (flash->pdata->vref << AS_INDICATOR_AND_TIMER_VREF_SHIFT)\r\n| ((flash->indicator_current ? flash->indicator_current - 1 : 0)\r\n<< AS_INDICATOR_AND_TIMER_INDICATOR_SHIFT);\r\nreturn as3645a_write(flash, AS_INDICATOR_AND_TIMER_REG, val);\r\n}\r\nstatic int\r\nas3645a_set_control(struct as3645a *flash, enum as_mode mode, bool on)\r\n{\r\nu8 reg;\r\nreg = (flash->pdata->peak << AS_CONTROL_COIL_PEAK_SHIFT)\r\n| (on ? AS_CONTROL_OUT_ON : 0)\r\n| mode;\r\nif (flash->led_mode == V4L2_FLASH_LED_MODE_FLASH &&\r\nflash->strobe_source == V4L2_FLASH_STROBE_SOURCE_EXTERNAL) {\r\nreg |= AS_CONTROL_STROBE_TYPE_LEVEL\r\n| AS_CONTROL_STROBE_ON;\r\n}\r\nreturn as3645a_write(flash, AS_CONTROL_REG, reg);\r\n}\r\nstatic int as3645a_set_output(struct as3645a *flash, bool strobe)\r\n{\r\nenum as_mode mode;\r\nbool on;\r\nswitch (flash->led_mode) {\r\ncase V4L2_FLASH_LED_MODE_NONE:\r\non = flash->indicator_current != 0;\r\nmode = AS_MODE_INDICATOR;\r\nbreak;\r\ncase V4L2_FLASH_LED_MODE_TORCH:\r\non = true;\r\nmode = AS_MODE_ASSIST;\r\nbreak;\r\ncase V4L2_FLASH_LED_MODE_FLASH:\r\non = strobe;\r\nmode = AS_MODE_FLASH;\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\nreturn as3645a_set_control(flash, mode, on);\r\n}\r\nstatic int as3645a_is_active(struct as3645a *flash)\r\n{\r\nint ret;\r\nret = as3645a_read(flash, AS_CONTROL_REG);\r\nreturn ret < 0 ? ret : !!(ret & AS_CONTROL_OUT_ON);\r\n}\r\nstatic int as3645a_read_fault(struct as3645a *flash)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(&flash->subdev);\r\nint rval;\r\nrval = as3645a_read(flash, AS_FAULT_INFO_REG);\r\nif (rval < 0)\r\nreturn rval;\r\nif (rval & AS_FAULT_INFO_INDUCTOR_PEAK_LIMIT)\r\ndev_dbg(&client->dev, "Inductor Peak limit fault\n");\r\nif (rval & AS_FAULT_INFO_INDICATOR_LED)\r\ndev_dbg(&client->dev, "Indicator LED fault: "\r\n"Short circuit or open loop\n");\r\ndev_dbg(&client->dev, "%u connected LEDs\n",\r\nrval & AS_FAULT_INFO_LED_AMOUNT ? 2 : 1);\r\nif (rval & AS_FAULT_INFO_TIMEOUT)\r\ndev_dbg(&client->dev, "Timeout fault\n");\r\nif (rval & AS_FAULT_INFO_OVER_TEMPERATURE)\r\ndev_dbg(&client->dev, "Over temperature fault\n");\r\nif (rval & AS_FAULT_INFO_SHORT_CIRCUIT)\r\ndev_dbg(&client->dev, "Short circuit fault\n");\r\nif (rval & AS_FAULT_INFO_OVER_VOLTAGE)\r\ndev_dbg(&client->dev, "Over voltage fault: "\r\n"Indicates missing capacitor or open connection\n");\r\nreturn rval;\r\n}\r\nstatic int as3645a_get_ctrl(struct v4l2_ctrl *ctrl)\r\n{\r\nstruct as3645a *flash =\r\ncontainer_of(ctrl->handler, struct as3645a, ctrls);\r\nstruct i2c_client *client = v4l2_get_subdevdata(&flash->subdev);\r\nint value;\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_FLASH_FAULT:\r\nvalue = as3645a_read_fault(flash);\r\nif (value < 0)\r\nreturn value;\r\nctrl->cur.val = 0;\r\nif (value & AS_FAULT_INFO_SHORT_CIRCUIT)\r\nctrl->cur.val |= V4L2_FLASH_FAULT_SHORT_CIRCUIT;\r\nif (value & AS_FAULT_INFO_OVER_TEMPERATURE)\r\nctrl->cur.val |= V4L2_FLASH_FAULT_OVER_TEMPERATURE;\r\nif (value & AS_FAULT_INFO_TIMEOUT)\r\nctrl->cur.val |= V4L2_FLASH_FAULT_TIMEOUT;\r\nif (value & AS_FAULT_INFO_OVER_VOLTAGE)\r\nctrl->cur.val |= V4L2_FLASH_FAULT_OVER_VOLTAGE;\r\nif (value & AS_FAULT_INFO_INDUCTOR_PEAK_LIMIT)\r\nctrl->cur.val |= V4L2_FLASH_FAULT_OVER_CURRENT;\r\nif (value & AS_FAULT_INFO_INDICATOR_LED)\r\nctrl->cur.val |= V4L2_FLASH_FAULT_INDICATOR;\r\nbreak;\r\ncase V4L2_CID_FLASH_STROBE_STATUS:\r\nif (flash->led_mode != V4L2_FLASH_LED_MODE_FLASH) {\r\nctrl->cur.val = 0;\r\nbreak;\r\n}\r\nvalue = as3645a_is_active(flash);\r\nif (value < 0)\r\nreturn value;\r\nctrl->cur.val = value;\r\nbreak;\r\n}\r\ndev_dbg(&client->dev, "G_CTRL %08x:%d\n", ctrl->id, ctrl->cur.val);\r\nreturn 0;\r\n}\r\nstatic int as3645a_set_ctrl(struct v4l2_ctrl *ctrl)\r\n{\r\nstruct as3645a *flash =\r\ncontainer_of(ctrl->handler, struct as3645a, ctrls);\r\nstruct i2c_client *client = v4l2_get_subdevdata(&flash->subdev);\r\nint ret;\r\ndev_dbg(&client->dev, "S_CTRL %08x:%d\n", ctrl->id, ctrl->val);\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_FLASH_LED_MODE:\r\nif (flash->indicator_current)\r\nreturn -EBUSY;\r\nret = as3645a_set_config(flash);\r\nif (ret < 0)\r\nreturn ret;\r\nflash->led_mode = ctrl->val;\r\nreturn as3645a_set_output(flash, false);\r\ncase V4L2_CID_FLASH_STROBE_SOURCE:\r\nflash->strobe_source = ctrl->val;\r\nif (flash->led_mode != V4L2_FLASH_LED_MODE_FLASH)\r\nbreak;\r\nreturn as3645a_set_output(flash, false);\r\ncase V4L2_CID_FLASH_STROBE:\r\nif (flash->led_mode != V4L2_FLASH_LED_MODE_FLASH)\r\nreturn -EBUSY;\r\nreturn as3645a_set_output(flash, true);\r\ncase V4L2_CID_FLASH_STROBE_STOP:\r\nif (flash->led_mode != V4L2_FLASH_LED_MODE_FLASH)\r\nreturn -EBUSY;\r\nreturn as3645a_set_output(flash, false);\r\ncase V4L2_CID_FLASH_TIMEOUT:\r\nflash->timeout = ctrl->val;\r\nif (flash->led_mode != V4L2_FLASH_LED_MODE_FLASH)\r\nbreak;\r\nreturn as3645a_set_config(flash);\r\ncase V4L2_CID_FLASH_INTENSITY:\r\nflash->flash_current = (ctrl->val - AS3645A_FLASH_INTENSITY_MIN)\r\n/ AS3645A_FLASH_INTENSITY_STEP;\r\nif (flash->led_mode != V4L2_FLASH_LED_MODE_FLASH)\r\nbreak;\r\nreturn as3645a_set_config(flash);\r\ncase V4L2_CID_FLASH_TORCH_INTENSITY:\r\nflash->assist_current =\r\n(ctrl->val - AS3645A_TORCH_INTENSITY_MIN)\r\n/ AS3645A_TORCH_INTENSITY_STEP;\r\nif (flash->led_mode != V4L2_FLASH_LED_MODE_TORCH)\r\nbreak;\r\nreturn as3645a_set_config(flash);\r\ncase V4L2_CID_FLASH_INDICATOR_INTENSITY:\r\nif (flash->led_mode != V4L2_FLASH_LED_MODE_NONE)\r\nreturn -EBUSY;\r\nflash->indicator_current =\r\n(ctrl->val - AS3645A_INDICATOR_INTENSITY_MIN)\r\n/ AS3645A_INDICATOR_INTENSITY_STEP;\r\nret = as3645a_set_config(flash);\r\nif (ret < 0)\r\nreturn ret;\r\nif ((ctrl->val == 0) == (ctrl->cur.val == 0))\r\nbreak;\r\nreturn as3645a_set_output(flash, false);\r\n}\r\nreturn 0;\r\n}\r\nstatic int as3645a_setup(struct as3645a *flash)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(&flash->subdev);\r\nint ret;\r\nret = as3645a_read(flash, AS_FAULT_INFO_REG);\r\nif (ret < 0)\r\nreturn ret;\r\ndev_dbg(&client->dev, "Fault info: %02x\n", ret);\r\nret = as3645a_set_config(flash);\r\nif (ret < 0)\r\nreturn ret;\r\nret = as3645a_set_output(flash, false);\r\nif (ret < 0)\r\nreturn ret;\r\nret = as3645a_read_fault(flash);\r\nif (ret < 0)\r\nreturn ret;\r\ndev_dbg(&client->dev, "AS_INDICATOR_AND_TIMER_REG: %02x\n",\r\nas3645a_read(flash, AS_INDICATOR_AND_TIMER_REG));\r\ndev_dbg(&client->dev, "AS_CURRENT_SET_REG: %02x\n",\r\nas3645a_read(flash, AS_CURRENT_SET_REG));\r\ndev_dbg(&client->dev, "AS_CONTROL_REG: %02x\n",\r\nas3645a_read(flash, AS_CONTROL_REG));\r\nreturn ret & ~AS_FAULT_INFO_LED_AMOUNT ? -EIO : 0;\r\n}\r\nstatic int __as3645a_set_power(struct as3645a *flash, int on)\r\n{\r\nint ret;\r\nif (!on)\r\nas3645a_set_control(flash, AS_MODE_EXT_TORCH, false);\r\nif (flash->pdata->set_power) {\r\nret = flash->pdata->set_power(&flash->subdev, on);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nif (!on)\r\nreturn 0;\r\nret = as3645a_setup(flash);\r\nif (ret < 0) {\r\nif (flash->pdata->set_power)\r\nflash->pdata->set_power(&flash->subdev, 0);\r\n}\r\nreturn ret;\r\n}\r\nstatic int as3645a_set_power(struct v4l2_subdev *sd, int on)\r\n{\r\nstruct as3645a *flash = to_as3645a(sd);\r\nint ret = 0;\r\nmutex_lock(&flash->power_lock);\r\nif (flash->power_count == !on) {\r\nret = __as3645a_set_power(flash, !!on);\r\nif (ret < 0)\r\ngoto done;\r\n}\r\nflash->power_count += on ? 1 : -1;\r\nWARN_ON(flash->power_count < 0);\r\ndone:\r\nmutex_unlock(&flash->power_lock);\r\nreturn ret;\r\n}\r\nstatic int as3645a_registered(struct v4l2_subdev *sd)\r\n{\r\nstruct as3645a *flash = to_as3645a(sd);\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nint rval, man, model, rfu, version;\r\nconst char *vendor;\r\nrval = as3645a_set_power(&flash->subdev, 1);\r\nif (rval < 0)\r\nreturn rval;\r\nrval = as3645a_read(flash, AS_DESIGN_INFO_REG);\r\nif (rval < 0)\r\ngoto power_off;\r\nman = AS_DESIGN_INFO_FACTORY(rval);\r\nmodel = AS_DESIGN_INFO_MODEL(rval);\r\nrval = as3645a_read(flash, AS_VERSION_CONTROL_REG);\r\nif (rval < 0)\r\ngoto power_off;\r\nrfu = AS_VERSION_CONTROL_RFU(rval);\r\nversion = AS_VERSION_CONTROL_VERSION(rval);\r\nif (model != 0x01 || rfu != 0x00) {\r\ndev_err(&client->dev, "AS3645A not detected "\r\n"(model %d rfu %d)\n", model, rfu);\r\nrval = -ENODEV;\r\ngoto power_off;\r\n}\r\nswitch (man) {\r\ncase 1:\r\nvendor = "AMS, Austria Micro Systems";\r\nbreak;\r\ncase 2:\r\nvendor = "ADI, Analog Devices Inc.";\r\nbreak;\r\ncase 3:\r\nvendor = "NSC, National Semiconductor";\r\nbreak;\r\ncase 4:\r\nvendor = "NXP";\r\nbreak;\r\ncase 5:\r\nvendor = "TI, Texas Instrument";\r\nbreak;\r\ndefault:\r\nvendor = "Unknown";\r\n}\r\ndev_info(&client->dev, "Chip vendor: %s (%d) Version: %d\n", vendor,\r\nman, version);\r\nrval = as3645a_write(flash, AS_PASSWORD_REG, AS_PASSWORD_UNLOCK_VALUE);\r\nif (rval < 0)\r\ngoto power_off;\r\nrval = as3645a_write(flash, AS_BOOST_REG, AS_BOOST_CURRENT_DISABLE);\r\nif (rval < 0)\r\ngoto power_off;\r\nrval = as3645a_setup(flash);\r\npower_off:\r\nas3645a_set_power(&flash->subdev, 0);\r\nreturn rval;\r\n}\r\nstatic int as3645a_open(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh)\r\n{\r\nreturn as3645a_set_power(sd, 1);\r\n}\r\nstatic int as3645a_close(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh)\r\n{\r\nreturn as3645a_set_power(sd, 0);\r\n}\r\nstatic int as3645a_suspend(struct device *dev)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct v4l2_subdev *subdev = i2c_get_clientdata(client);\r\nstruct as3645a *flash = to_as3645a(subdev);\r\nint rval;\r\nif (flash->power_count == 0)\r\nreturn 0;\r\nrval = __as3645a_set_power(flash, 0);\r\ndev_dbg(&client->dev, "Suspend %s\n", rval < 0 ? "failed" : "ok");\r\nreturn rval;\r\n}\r\nstatic int as3645a_resume(struct device *dev)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct v4l2_subdev *subdev = i2c_get_clientdata(client);\r\nstruct as3645a *flash = to_as3645a(subdev);\r\nint rval;\r\nif (flash->power_count == 0)\r\nreturn 0;\r\nrval = __as3645a_set_power(flash, 1);\r\ndev_dbg(&client->dev, "Resume %s\n", rval < 0 ? "fail" : "ok");\r\nreturn rval;\r\n}\r\nstatic int as3645a_init_controls(struct as3645a *flash)\r\n{\r\nconst struct as3645a_platform_data *pdata = flash->pdata;\r\nstruct v4l2_ctrl *ctrl;\r\nint maximum;\r\nv4l2_ctrl_handler_init(&flash->ctrls, 10);\r\nv4l2_ctrl_new_std_menu(&flash->ctrls, &as3645a_ctrl_ops,\r\nV4L2_CID_FLASH_LED_MODE, 2, ~7,\r\nV4L2_FLASH_LED_MODE_NONE);\r\nv4l2_ctrl_new_std_menu(&flash->ctrls, &as3645a_ctrl_ops,\r\nV4L2_CID_FLASH_STROBE_SOURCE,\r\npdata->ext_strobe ? 1 : 0,\r\npdata->ext_strobe ? ~3 : ~1,\r\nV4L2_FLASH_STROBE_SOURCE_SOFTWARE);\r\nflash->strobe_source = V4L2_FLASH_STROBE_SOURCE_SOFTWARE;\r\nv4l2_ctrl_new_std(&flash->ctrls, &as3645a_ctrl_ops,\r\nV4L2_CID_FLASH_STROBE, 0, 0, 0, 0);\r\nv4l2_ctrl_new_std(&flash->ctrls, &as3645a_ctrl_ops,\r\nV4L2_CID_FLASH_STROBE_STOP, 0, 0, 0, 0);\r\nctrl = v4l2_ctrl_new_std(&flash->ctrls, &as3645a_ctrl_ops,\r\nV4L2_CID_FLASH_STROBE_STATUS, 0, 1, 1, 1);\r\nif (ctrl != NULL)\r\nctrl->flags |= V4L2_CTRL_FLAG_VOLATILE;\r\nmaximum = pdata->timeout_max;\r\nv4l2_ctrl_new_std(&flash->ctrls, &as3645a_ctrl_ops,\r\nV4L2_CID_FLASH_TIMEOUT, AS3645A_FLASH_TIMEOUT_MIN,\r\nmaximum, AS3645A_FLASH_TIMEOUT_STEP, maximum);\r\nflash->timeout = maximum;\r\nmaximum = pdata->flash_max_current;\r\nv4l2_ctrl_new_std(&flash->ctrls, &as3645a_ctrl_ops,\r\nV4L2_CID_FLASH_INTENSITY, AS3645A_FLASH_INTENSITY_MIN,\r\nmaximum, AS3645A_FLASH_INTENSITY_STEP, maximum);\r\nflash->flash_current = (maximum - AS3645A_FLASH_INTENSITY_MIN)\r\n/ AS3645A_FLASH_INTENSITY_STEP;\r\nmaximum = pdata->torch_max_current;\r\nv4l2_ctrl_new_std(&flash->ctrls, &as3645a_ctrl_ops,\r\nV4L2_CID_FLASH_TORCH_INTENSITY,\r\nAS3645A_TORCH_INTENSITY_MIN, maximum,\r\nAS3645A_TORCH_INTENSITY_STEP,\r\nAS3645A_TORCH_INTENSITY_MIN);\r\nflash->assist_current = 0;\r\nv4l2_ctrl_new_std(&flash->ctrls, &as3645a_ctrl_ops,\r\nV4L2_CID_FLASH_INDICATOR_INTENSITY,\r\nAS3645A_INDICATOR_INTENSITY_MIN,\r\nAS3645A_INDICATOR_INTENSITY_MAX,\r\nAS3645A_INDICATOR_INTENSITY_STEP,\r\nAS3645A_INDICATOR_INTENSITY_MIN);\r\nflash->indicator_current = 0;\r\nctrl = v4l2_ctrl_new_std(&flash->ctrls, &as3645a_ctrl_ops,\r\nV4L2_CID_FLASH_FAULT, 0,\r\nV4L2_FLASH_FAULT_OVER_VOLTAGE |\r\nV4L2_FLASH_FAULT_TIMEOUT |\r\nV4L2_FLASH_FAULT_OVER_TEMPERATURE |\r\nV4L2_FLASH_FAULT_SHORT_CIRCUIT, 0, 0);\r\nif (ctrl != NULL)\r\nctrl->flags |= V4L2_CTRL_FLAG_VOLATILE;\r\nflash->subdev.ctrl_handler = &flash->ctrls;\r\nreturn flash->ctrls.error;\r\n}\r\nstatic int as3645a_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *devid)\r\n{\r\nstruct as3645a *flash;\r\nint ret;\r\nif (client->dev.platform_data == NULL)\r\nreturn -ENODEV;\r\nflash = kzalloc(sizeof(*flash), GFP_KERNEL);\r\nif (flash == NULL)\r\nreturn -ENOMEM;\r\nflash->pdata = client->dev.platform_data;\r\nv4l2_i2c_subdev_init(&flash->subdev, client, &as3645a_ops);\r\nflash->subdev.internal_ops = &as3645a_internal_ops;\r\nflash->subdev.flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;\r\nret = as3645a_init_controls(flash);\r\nif (ret < 0)\r\ngoto done;\r\nret = media_entity_init(&flash->subdev.entity, 0, NULL, 0);\r\nif (ret < 0)\r\ngoto done;\r\nflash->subdev.entity.type = MEDIA_ENT_T_V4L2_SUBDEV_FLASH;\r\nmutex_init(&flash->power_lock);\r\nflash->led_mode = V4L2_FLASH_LED_MODE_NONE;\r\ndone:\r\nif (ret < 0) {\r\nv4l2_ctrl_handler_free(&flash->ctrls);\r\nkfree(flash);\r\n}\r\nreturn ret;\r\n}\r\nstatic int as3645a_remove(struct i2c_client *client)\r\n{\r\nstruct v4l2_subdev *subdev = i2c_get_clientdata(client);\r\nstruct as3645a *flash = to_as3645a(subdev);\r\nv4l2_device_unregister_subdev(subdev);\r\nv4l2_ctrl_handler_free(&flash->ctrls);\r\nmedia_entity_cleanup(&flash->subdev.entity);\r\nmutex_destroy(&flash->power_lock);\r\nkfree(flash);\r\nreturn 0;\r\n}
