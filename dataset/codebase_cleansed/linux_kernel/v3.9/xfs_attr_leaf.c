static void\r\nxfs_attr_leaf_verify(\r\nstruct xfs_buf *bp)\r\n{\r\nstruct xfs_mount *mp = bp->b_target->bt_mount;\r\nstruct xfs_attr_leaf_hdr *hdr = bp->b_addr;\r\nint block_ok = 0;\r\nblock_ok = hdr->info.magic == cpu_to_be16(XFS_ATTR_LEAF_MAGIC);\r\nif (!block_ok) {\r\nXFS_CORRUPTION_ERROR(__func__, XFS_ERRLEVEL_LOW, mp, hdr);\r\nxfs_buf_ioerror(bp, EFSCORRUPTED);\r\n}\r\n}\r\nstatic void\r\nxfs_attr_leaf_read_verify(\r\nstruct xfs_buf *bp)\r\n{\r\nxfs_attr_leaf_verify(bp);\r\n}\r\nstatic void\r\nxfs_attr_leaf_write_verify(\r\nstruct xfs_buf *bp)\r\n{\r\nxfs_attr_leaf_verify(bp);\r\n}\r\nint\r\nxfs_attr_leaf_read(\r\nstruct xfs_trans *tp,\r\nstruct xfs_inode *dp,\r\nxfs_dablk_t bno,\r\nxfs_daddr_t mappedbno,\r\nstruct xfs_buf **bpp)\r\n{\r\nreturn xfs_da_read_buf(tp, dp, bno, mappedbno, bpp,\r\nXFS_ATTR_FORK, &xfs_attr_leaf_buf_ops);\r\n}\r\nSTATIC int\r\nxfs_attr_namesp_match(int arg_flags, int ondisk_flags)\r\n{\r\nreturn XFS_ATTR_NSP_ONDISK(ondisk_flags) == XFS_ATTR_NSP_ARGS_TO_ONDISK(arg_flags);\r\n}\r\nint\r\nxfs_attr_shortform_bytesfit(xfs_inode_t *dp, int bytes)\r\n{\r\nint offset;\r\nint minforkoff;\r\nint maxforkoff;\r\nint dsize;\r\nxfs_mount_t *mp = dp->i_mount;\r\noffset = (XFS_LITINO(mp) - bytes) >> 3;\r\nswitch (dp->i_d.di_format) {\r\ncase XFS_DINODE_FMT_DEV:\r\nminforkoff = roundup(sizeof(xfs_dev_t), 8) >> 3;\r\nreturn (offset >= minforkoff) ? minforkoff : 0;\r\ncase XFS_DINODE_FMT_UUID:\r\nminforkoff = roundup(sizeof(uuid_t), 8) >> 3;\r\nreturn (offset >= minforkoff) ? minforkoff : 0;\r\n}\r\nif (bytes <= XFS_IFORK_ASIZE(dp))\r\nreturn dp->i_d.di_forkoff;\r\nif (!(mp->m_flags & XFS_MOUNT_ATTR2))\r\nreturn 0;\r\ndsize = dp->i_df.if_bytes;\r\nswitch (dp->i_d.di_format) {\r\ncase XFS_DINODE_FMT_EXTENTS:\r\nif (!dp->i_d.di_forkoff && dp->i_df.if_bytes >\r\nxfs_default_attroffset(dp))\r\ndsize = XFS_BMDR_SPACE_CALC(MINDBTPTRS);\r\nbreak;\r\ncase XFS_DINODE_FMT_BTREE:\r\nif (dp->i_d.di_forkoff) {\r\nif (offset < dp->i_d.di_forkoff)\r\nreturn 0;\r\nreturn dp->i_d.di_forkoff;\r\n}\r\ndsize = XFS_BMAP_BROOT_SPACE(dp->i_df.if_broot);\r\nbreak;\r\n}\r\nminforkoff = MAX(dsize, XFS_BMDR_SPACE_CALC(MINDBTPTRS));\r\nminforkoff = roundup(minforkoff, 8) >> 3;\r\nmaxforkoff = XFS_LITINO(mp) - XFS_BMDR_SPACE_CALC(MINABTPTRS);\r\nmaxforkoff = maxforkoff >> 3;\r\nif (offset >= maxforkoff)\r\nreturn maxforkoff;\r\nif (offset >= minforkoff)\r\nreturn offset;\r\nreturn 0;\r\n}\r\nSTATIC void\r\nxfs_sbversion_add_attr2(xfs_mount_t *mp, xfs_trans_t *tp)\r\n{\r\nif ((mp->m_flags & XFS_MOUNT_ATTR2) &&\r\n!(xfs_sb_version_hasattr2(&mp->m_sb))) {\r\nspin_lock(&mp->m_sb_lock);\r\nif (!xfs_sb_version_hasattr2(&mp->m_sb)) {\r\nxfs_sb_version_addattr2(&mp->m_sb);\r\nspin_unlock(&mp->m_sb_lock);\r\nxfs_mod_sb(tp, XFS_SB_VERSIONNUM | XFS_SB_FEATURES2);\r\n} else\r\nspin_unlock(&mp->m_sb_lock);\r\n}\r\n}\r\nvoid\r\nxfs_attr_shortform_create(xfs_da_args_t *args)\r\n{\r\nxfs_attr_sf_hdr_t *hdr;\r\nxfs_inode_t *dp;\r\nxfs_ifork_t *ifp;\r\ntrace_xfs_attr_sf_create(args);\r\ndp = args->dp;\r\nASSERT(dp != NULL);\r\nifp = dp->i_afp;\r\nASSERT(ifp != NULL);\r\nASSERT(ifp->if_bytes == 0);\r\nif (dp->i_d.di_aformat == XFS_DINODE_FMT_EXTENTS) {\r\nifp->if_flags &= ~XFS_IFEXTENTS;\r\ndp->i_d.di_aformat = XFS_DINODE_FMT_LOCAL;\r\nifp->if_flags |= XFS_IFINLINE;\r\n} else {\r\nASSERT(ifp->if_flags & XFS_IFINLINE);\r\n}\r\nxfs_idata_realloc(dp, sizeof(*hdr), XFS_ATTR_FORK);\r\nhdr = (xfs_attr_sf_hdr_t *)ifp->if_u1.if_data;\r\nhdr->count = 0;\r\nhdr->totsize = cpu_to_be16(sizeof(*hdr));\r\nxfs_trans_log_inode(args->trans, dp, XFS_ILOG_CORE | XFS_ILOG_ADATA);\r\n}\r\nvoid\r\nxfs_attr_shortform_add(xfs_da_args_t *args, int forkoff)\r\n{\r\nxfs_attr_shortform_t *sf;\r\nxfs_attr_sf_entry_t *sfe;\r\nint i, offset, size;\r\nxfs_mount_t *mp;\r\nxfs_inode_t *dp;\r\nxfs_ifork_t *ifp;\r\ntrace_xfs_attr_sf_add(args);\r\ndp = args->dp;\r\nmp = dp->i_mount;\r\ndp->i_d.di_forkoff = forkoff;\r\nifp = dp->i_afp;\r\nASSERT(ifp->if_flags & XFS_IFINLINE);\r\nsf = (xfs_attr_shortform_t *)ifp->if_u1.if_data;\r\nsfe = &sf->list[0];\r\nfor (i = 0; i < sf->hdr.count; sfe = XFS_ATTR_SF_NEXTENTRY(sfe), i++) {\r\n#ifdef DEBUG\r\nif (sfe->namelen != args->namelen)\r\ncontinue;\r\nif (memcmp(args->name, sfe->nameval, args->namelen) != 0)\r\ncontinue;\r\nif (!xfs_attr_namesp_match(args->flags, sfe->flags))\r\ncontinue;\r\nASSERT(0);\r\n#endif\r\n}\r\noffset = (char *)sfe - (char *)sf;\r\nsize = XFS_ATTR_SF_ENTSIZE_BYNAME(args->namelen, args->valuelen);\r\nxfs_idata_realloc(dp, size, XFS_ATTR_FORK);\r\nsf = (xfs_attr_shortform_t *)ifp->if_u1.if_data;\r\nsfe = (xfs_attr_sf_entry_t *)((char *)sf + offset);\r\nsfe->namelen = args->namelen;\r\nsfe->valuelen = args->valuelen;\r\nsfe->flags = XFS_ATTR_NSP_ARGS_TO_ONDISK(args->flags);\r\nmemcpy(sfe->nameval, args->name, args->namelen);\r\nmemcpy(&sfe->nameval[args->namelen], args->value, args->valuelen);\r\nsf->hdr.count++;\r\nbe16_add_cpu(&sf->hdr.totsize, size);\r\nxfs_trans_log_inode(args->trans, dp, XFS_ILOG_CORE | XFS_ILOG_ADATA);\r\nxfs_sbversion_add_attr2(mp, args->trans);\r\n}\r\nSTATIC void\r\nxfs_attr_fork_reset(\r\nstruct xfs_inode *ip,\r\nstruct xfs_trans *tp)\r\n{\r\nxfs_idestroy_fork(ip, XFS_ATTR_FORK);\r\nip->i_d.di_forkoff = 0;\r\nip->i_d.di_aformat = XFS_DINODE_FMT_EXTENTS;\r\nASSERT(ip->i_d.di_anextents == 0);\r\nASSERT(ip->i_afp == NULL);\r\nxfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);\r\n}\r\nint\r\nxfs_attr_shortform_remove(xfs_da_args_t *args)\r\n{\r\nxfs_attr_shortform_t *sf;\r\nxfs_attr_sf_entry_t *sfe;\r\nint base, size=0, end, totsize, i;\r\nxfs_mount_t *mp;\r\nxfs_inode_t *dp;\r\ntrace_xfs_attr_sf_remove(args);\r\ndp = args->dp;\r\nmp = dp->i_mount;\r\nbase = sizeof(xfs_attr_sf_hdr_t);\r\nsf = (xfs_attr_shortform_t *)dp->i_afp->if_u1.if_data;\r\nsfe = &sf->list[0];\r\nend = sf->hdr.count;\r\nfor (i = 0; i < end; sfe = XFS_ATTR_SF_NEXTENTRY(sfe),\r\nbase += size, i++) {\r\nsize = XFS_ATTR_SF_ENTSIZE(sfe);\r\nif (sfe->namelen != args->namelen)\r\ncontinue;\r\nif (memcmp(sfe->nameval, args->name, args->namelen) != 0)\r\ncontinue;\r\nif (!xfs_attr_namesp_match(args->flags, sfe->flags))\r\ncontinue;\r\nbreak;\r\n}\r\nif (i == end)\r\nreturn(XFS_ERROR(ENOATTR));\r\nend = base + size;\r\ntotsize = be16_to_cpu(sf->hdr.totsize);\r\nif (end != totsize)\r\nmemmove(&((char *)sf)[base], &((char *)sf)[end], totsize - end);\r\nsf->hdr.count--;\r\nbe16_add_cpu(&sf->hdr.totsize, -size);\r\ntotsize -= size;\r\nif (totsize == sizeof(xfs_attr_sf_hdr_t) &&\r\n(mp->m_flags & XFS_MOUNT_ATTR2) &&\r\n(dp->i_d.di_format != XFS_DINODE_FMT_BTREE) &&\r\n!(args->op_flags & XFS_DA_OP_ADDNAME)) {\r\nxfs_attr_fork_reset(dp, args->trans);\r\n} else {\r\nxfs_idata_realloc(dp, -size, XFS_ATTR_FORK);\r\ndp->i_d.di_forkoff = xfs_attr_shortform_bytesfit(dp, totsize);\r\nASSERT(dp->i_d.di_forkoff);\r\nASSERT(totsize > sizeof(xfs_attr_sf_hdr_t) ||\r\n(args->op_flags & XFS_DA_OP_ADDNAME) ||\r\n!(mp->m_flags & XFS_MOUNT_ATTR2) ||\r\ndp->i_d.di_format == XFS_DINODE_FMT_BTREE);\r\nxfs_trans_log_inode(args->trans, dp,\r\nXFS_ILOG_CORE | XFS_ILOG_ADATA);\r\n}\r\nxfs_sbversion_add_attr2(mp, args->trans);\r\nreturn(0);\r\n}\r\nint\r\nxfs_attr_shortform_lookup(xfs_da_args_t *args)\r\n{\r\nxfs_attr_shortform_t *sf;\r\nxfs_attr_sf_entry_t *sfe;\r\nint i;\r\nxfs_ifork_t *ifp;\r\ntrace_xfs_attr_sf_lookup(args);\r\nifp = args->dp->i_afp;\r\nASSERT(ifp->if_flags & XFS_IFINLINE);\r\nsf = (xfs_attr_shortform_t *)ifp->if_u1.if_data;\r\nsfe = &sf->list[0];\r\nfor (i = 0; i < sf->hdr.count;\r\nsfe = XFS_ATTR_SF_NEXTENTRY(sfe), i++) {\r\nif (sfe->namelen != args->namelen)\r\ncontinue;\r\nif (memcmp(args->name, sfe->nameval, args->namelen) != 0)\r\ncontinue;\r\nif (!xfs_attr_namesp_match(args->flags, sfe->flags))\r\ncontinue;\r\nreturn(XFS_ERROR(EEXIST));\r\n}\r\nreturn(XFS_ERROR(ENOATTR));\r\n}\r\nint\r\nxfs_attr_shortform_getvalue(xfs_da_args_t *args)\r\n{\r\nxfs_attr_shortform_t *sf;\r\nxfs_attr_sf_entry_t *sfe;\r\nint i;\r\nASSERT(args->dp->i_d.di_aformat == XFS_IFINLINE);\r\nsf = (xfs_attr_shortform_t *)args->dp->i_afp->if_u1.if_data;\r\nsfe = &sf->list[0];\r\nfor (i = 0; i < sf->hdr.count;\r\nsfe = XFS_ATTR_SF_NEXTENTRY(sfe), i++) {\r\nif (sfe->namelen != args->namelen)\r\ncontinue;\r\nif (memcmp(args->name, sfe->nameval, args->namelen) != 0)\r\ncontinue;\r\nif (!xfs_attr_namesp_match(args->flags, sfe->flags))\r\ncontinue;\r\nif (args->flags & ATTR_KERNOVAL) {\r\nargs->valuelen = sfe->valuelen;\r\nreturn(XFS_ERROR(EEXIST));\r\n}\r\nif (args->valuelen < sfe->valuelen) {\r\nargs->valuelen = sfe->valuelen;\r\nreturn(XFS_ERROR(ERANGE));\r\n}\r\nargs->valuelen = sfe->valuelen;\r\nmemcpy(args->value, &sfe->nameval[args->namelen],\r\nargs->valuelen);\r\nreturn(XFS_ERROR(EEXIST));\r\n}\r\nreturn(XFS_ERROR(ENOATTR));\r\n}\r\nint\r\nxfs_attr_shortform_to_leaf(xfs_da_args_t *args)\r\n{\r\nxfs_inode_t *dp;\r\nxfs_attr_shortform_t *sf;\r\nxfs_attr_sf_entry_t *sfe;\r\nxfs_da_args_t nargs;\r\nchar *tmpbuffer;\r\nint error, i, size;\r\nxfs_dablk_t blkno;\r\nstruct xfs_buf *bp;\r\nxfs_ifork_t *ifp;\r\ntrace_xfs_attr_sf_to_leaf(args);\r\ndp = args->dp;\r\nifp = dp->i_afp;\r\nsf = (xfs_attr_shortform_t *)ifp->if_u1.if_data;\r\nsize = be16_to_cpu(sf->hdr.totsize);\r\ntmpbuffer = kmem_alloc(size, KM_SLEEP);\r\nASSERT(tmpbuffer != NULL);\r\nmemcpy(tmpbuffer, ifp->if_u1.if_data, size);\r\nsf = (xfs_attr_shortform_t *)tmpbuffer;\r\nxfs_idata_realloc(dp, -size, XFS_ATTR_FORK);\r\nbp = NULL;\r\nerror = xfs_da_grow_inode(args, &blkno);\r\nif (error) {\r\nif (error == EIO)\r\ngoto out;\r\nxfs_idata_realloc(dp, size, XFS_ATTR_FORK);\r\nmemcpy(ifp->if_u1.if_data, tmpbuffer, size);\r\ngoto out;\r\n}\r\nASSERT(blkno == 0);\r\nerror = xfs_attr_leaf_create(args, blkno, &bp);\r\nif (error) {\r\nerror = xfs_da_shrink_inode(args, 0, bp);\r\nbp = NULL;\r\nif (error)\r\ngoto out;\r\nxfs_idata_realloc(dp, size, XFS_ATTR_FORK);\r\nmemcpy(ifp->if_u1.if_data, tmpbuffer, size);\r\ngoto out;\r\n}\r\nmemset((char *)&nargs, 0, sizeof(nargs));\r\nnargs.dp = dp;\r\nnargs.firstblock = args->firstblock;\r\nnargs.flist = args->flist;\r\nnargs.total = args->total;\r\nnargs.whichfork = XFS_ATTR_FORK;\r\nnargs.trans = args->trans;\r\nnargs.op_flags = XFS_DA_OP_OKNOENT;\r\nsfe = &sf->list[0];\r\nfor (i = 0; i < sf->hdr.count; i++) {\r\nnargs.name = sfe->nameval;\r\nnargs.namelen = sfe->namelen;\r\nnargs.value = &sfe->nameval[nargs.namelen];\r\nnargs.valuelen = sfe->valuelen;\r\nnargs.hashval = xfs_da_hashname(sfe->nameval,\r\nsfe->namelen);\r\nnargs.flags = XFS_ATTR_NSP_ONDISK_TO_ARGS(sfe->flags);\r\nerror = xfs_attr_leaf_lookup_int(bp, &nargs);\r\nASSERT(error == ENOATTR);\r\nerror = xfs_attr_leaf_add(bp, &nargs);\r\nASSERT(error != ENOSPC);\r\nif (error)\r\ngoto out;\r\nsfe = XFS_ATTR_SF_NEXTENTRY(sfe);\r\n}\r\nerror = 0;\r\nout:\r\nkmem_free(tmpbuffer);\r\nreturn(error);\r\n}\r\nSTATIC int\r\nxfs_attr_shortform_compare(const void *a, const void *b)\r\n{\r\nxfs_attr_sf_sort_t *sa, *sb;\r\nsa = (xfs_attr_sf_sort_t *)a;\r\nsb = (xfs_attr_sf_sort_t *)b;\r\nif (sa->hash < sb->hash) {\r\nreturn(-1);\r\n} else if (sa->hash > sb->hash) {\r\nreturn(1);\r\n} else {\r\nreturn(sa->entno - sb->entno);\r\n}\r\n}\r\nint\r\nxfs_attr_shortform_list(xfs_attr_list_context_t *context)\r\n{\r\nattrlist_cursor_kern_t *cursor;\r\nxfs_attr_sf_sort_t *sbuf, *sbp;\r\nxfs_attr_shortform_t *sf;\r\nxfs_attr_sf_entry_t *sfe;\r\nxfs_inode_t *dp;\r\nint sbsize, nsbuf, count, i;\r\nint error;\r\nASSERT(context != NULL);\r\ndp = context->dp;\r\nASSERT(dp != NULL);\r\nASSERT(dp->i_afp != NULL);\r\nsf = (xfs_attr_shortform_t *)dp->i_afp->if_u1.if_data;\r\nASSERT(sf != NULL);\r\nif (!sf->hdr.count)\r\nreturn(0);\r\ncursor = context->cursor;\r\nASSERT(cursor != NULL);\r\ntrace_xfs_attr_list_sf(context);\r\nif (context->bufsize == 0 ||\r\n(XFS_ISRESET_CURSOR(cursor) &&\r\n(dp->i_afp->if_bytes + sf->hdr.count * 16) < context->bufsize)) {\r\nfor (i = 0, sfe = &sf->list[0]; i < sf->hdr.count; i++) {\r\nerror = context->put_listent(context,\r\nsfe->flags,\r\nsfe->nameval,\r\n(int)sfe->namelen,\r\n(int)sfe->valuelen,\r\n&sfe->nameval[sfe->namelen]);\r\nif (context->seen_enough)\r\nbreak;\r\nif (error)\r\nreturn error;\r\nsfe = XFS_ATTR_SF_NEXTENTRY(sfe);\r\n}\r\ntrace_xfs_attr_list_sf_all(context);\r\nreturn(0);\r\n}\r\nif (context->bufsize == 0)\r\nreturn 0;\r\nsbsize = sf->hdr.count * sizeof(*sbuf);\r\nsbp = sbuf = kmem_alloc(sbsize, KM_SLEEP | KM_NOFS);\r\nnsbuf = 0;\r\nfor (i = 0, sfe = &sf->list[0]; i < sf->hdr.count; i++) {\r\nif (unlikely(\r\n((char *)sfe < (char *)sf) ||\r\n((char *)sfe >= ((char *)sf + dp->i_afp->if_bytes)))) {\r\nXFS_CORRUPTION_ERROR("xfs_attr_shortform_list",\r\nXFS_ERRLEVEL_LOW,\r\ncontext->dp->i_mount, sfe);\r\nkmem_free(sbuf);\r\nreturn XFS_ERROR(EFSCORRUPTED);\r\n}\r\nsbp->entno = i;\r\nsbp->hash = xfs_da_hashname(sfe->nameval, sfe->namelen);\r\nsbp->name = sfe->nameval;\r\nsbp->namelen = sfe->namelen;\r\nsbp->valuelen = sfe->valuelen;\r\nsbp->flags = sfe->flags;\r\nsfe = XFS_ATTR_SF_NEXTENTRY(sfe);\r\nsbp++;\r\nnsbuf++;\r\n}\r\nxfs_sort(sbuf, nsbuf, sizeof(*sbuf), xfs_attr_shortform_compare);\r\ncount = 0;\r\ncursor->initted = 1;\r\ncursor->blkno = 0;\r\nfor (sbp = sbuf, i = 0; i < nsbuf; i++, sbp++) {\r\nif (sbp->hash == cursor->hashval) {\r\nif (cursor->offset == count) {\r\nbreak;\r\n}\r\ncount++;\r\n} else if (sbp->hash > cursor->hashval) {\r\nbreak;\r\n}\r\n}\r\nif (i == nsbuf) {\r\nkmem_free(sbuf);\r\nreturn(0);\r\n}\r\nfor ( ; i < nsbuf; i++, sbp++) {\r\nif (cursor->hashval != sbp->hash) {\r\ncursor->hashval = sbp->hash;\r\ncursor->offset = 0;\r\n}\r\nerror = context->put_listent(context,\r\nsbp->flags,\r\nsbp->name,\r\nsbp->namelen,\r\nsbp->valuelen,\r\n&sbp->name[sbp->namelen]);\r\nif (error)\r\nreturn error;\r\nif (context->seen_enough)\r\nbreak;\r\ncursor->offset++;\r\n}\r\nkmem_free(sbuf);\r\nreturn(0);\r\n}\r\nint\r\nxfs_attr_shortform_allfit(\r\nstruct xfs_buf *bp,\r\nstruct xfs_inode *dp)\r\n{\r\nxfs_attr_leafblock_t *leaf;\r\nxfs_attr_leaf_entry_t *entry;\r\nxfs_attr_leaf_name_local_t *name_loc;\r\nint bytes, i;\r\nleaf = bp->b_addr;\r\nASSERT(leaf->hdr.info.magic == cpu_to_be16(XFS_ATTR_LEAF_MAGIC));\r\nentry = &leaf->entries[0];\r\nbytes = sizeof(struct xfs_attr_sf_hdr);\r\nfor (i = 0; i < be16_to_cpu(leaf->hdr.count); entry++, i++) {\r\nif (entry->flags & XFS_ATTR_INCOMPLETE)\r\ncontinue;\r\nif (!(entry->flags & XFS_ATTR_LOCAL))\r\nreturn(0);\r\nname_loc = xfs_attr_leaf_name_local(leaf, i);\r\nif (name_loc->namelen >= XFS_ATTR_SF_ENTSIZE_MAX)\r\nreturn(0);\r\nif (be16_to_cpu(name_loc->valuelen) >= XFS_ATTR_SF_ENTSIZE_MAX)\r\nreturn(0);\r\nbytes += sizeof(struct xfs_attr_sf_entry)-1\r\n+ name_loc->namelen\r\n+ be16_to_cpu(name_loc->valuelen);\r\n}\r\nif ((dp->i_mount->m_flags & XFS_MOUNT_ATTR2) &&\r\n(dp->i_d.di_format != XFS_DINODE_FMT_BTREE) &&\r\n(bytes == sizeof(struct xfs_attr_sf_hdr)))\r\nreturn(-1);\r\nreturn(xfs_attr_shortform_bytesfit(dp, bytes));\r\n}\r\nint\r\nxfs_attr_leaf_to_shortform(\r\nstruct xfs_buf *bp,\r\nxfs_da_args_t *args,\r\nint forkoff)\r\n{\r\nxfs_attr_leafblock_t *leaf;\r\nxfs_attr_leaf_entry_t *entry;\r\nxfs_attr_leaf_name_local_t *name_loc;\r\nxfs_da_args_t nargs;\r\nxfs_inode_t *dp;\r\nchar *tmpbuffer;\r\nint error, i;\r\ntrace_xfs_attr_leaf_to_sf(args);\r\ndp = args->dp;\r\ntmpbuffer = kmem_alloc(XFS_LBSIZE(dp->i_mount), KM_SLEEP);\r\nASSERT(tmpbuffer != NULL);\r\nASSERT(bp != NULL);\r\nmemcpy(tmpbuffer, bp->b_addr, XFS_LBSIZE(dp->i_mount));\r\nleaf = (xfs_attr_leafblock_t *)tmpbuffer;\r\nASSERT(leaf->hdr.info.magic == cpu_to_be16(XFS_ATTR_LEAF_MAGIC));\r\nmemset(bp->b_addr, 0, XFS_LBSIZE(dp->i_mount));\r\nerror = xfs_da_shrink_inode(args, 0, bp);\r\nif (error)\r\ngoto out;\r\nif (forkoff == -1) {\r\nASSERT(dp->i_mount->m_flags & XFS_MOUNT_ATTR2);\r\nASSERT(dp->i_d.di_format != XFS_DINODE_FMT_BTREE);\r\nxfs_attr_fork_reset(dp, args->trans);\r\ngoto out;\r\n}\r\nxfs_attr_shortform_create(args);\r\nmemset((char *)&nargs, 0, sizeof(nargs));\r\nnargs.dp = dp;\r\nnargs.firstblock = args->firstblock;\r\nnargs.flist = args->flist;\r\nnargs.total = args->total;\r\nnargs.whichfork = XFS_ATTR_FORK;\r\nnargs.trans = args->trans;\r\nnargs.op_flags = XFS_DA_OP_OKNOENT;\r\nentry = &leaf->entries[0];\r\nfor (i = 0; i < be16_to_cpu(leaf->hdr.count); entry++, i++) {\r\nif (entry->flags & XFS_ATTR_INCOMPLETE)\r\ncontinue;\r\nif (!entry->nameidx)\r\ncontinue;\r\nASSERT(entry->flags & XFS_ATTR_LOCAL);\r\nname_loc = xfs_attr_leaf_name_local(leaf, i);\r\nnargs.name = name_loc->nameval;\r\nnargs.namelen = name_loc->namelen;\r\nnargs.value = &name_loc->nameval[nargs.namelen];\r\nnargs.valuelen = be16_to_cpu(name_loc->valuelen);\r\nnargs.hashval = be32_to_cpu(entry->hashval);\r\nnargs.flags = XFS_ATTR_NSP_ONDISK_TO_ARGS(entry->flags);\r\nxfs_attr_shortform_add(&nargs, forkoff);\r\n}\r\nerror = 0;\r\nout:\r\nkmem_free(tmpbuffer);\r\nreturn(error);\r\n}\r\nint\r\nxfs_attr_leaf_to_node(xfs_da_args_t *args)\r\n{\r\nxfs_attr_leafblock_t *leaf;\r\nxfs_da_intnode_t *node;\r\nxfs_inode_t *dp;\r\nstruct xfs_buf *bp1, *bp2;\r\nxfs_dablk_t blkno;\r\nint error;\r\ntrace_xfs_attr_leaf_to_node(args);\r\ndp = args->dp;\r\nbp1 = bp2 = NULL;\r\nerror = xfs_da_grow_inode(args, &blkno);\r\nif (error)\r\ngoto out;\r\nerror = xfs_attr_leaf_read(args->trans, args->dp, 0, -1, &bp1);\r\nif (error)\r\ngoto out;\r\nbp2 = NULL;\r\nerror = xfs_da_get_buf(args->trans, args->dp, blkno, -1, &bp2,\r\nXFS_ATTR_FORK);\r\nif (error)\r\ngoto out;\r\nbp2->b_ops = bp1->b_ops;\r\nmemcpy(bp2->b_addr, bp1->b_addr, XFS_LBSIZE(dp->i_mount));\r\nbp1 = NULL;\r\nxfs_trans_log_buf(args->trans, bp2, 0, XFS_LBSIZE(dp->i_mount) - 1);\r\nerror = xfs_da_node_create(args, 0, 1, &bp1, XFS_ATTR_FORK);\r\nif (error)\r\ngoto out;\r\nnode = bp1->b_addr;\r\nleaf = bp2->b_addr;\r\nASSERT(leaf->hdr.info.magic == cpu_to_be16(XFS_ATTR_LEAF_MAGIC));\r\nnode->btree[0].hashval =\r\nleaf->entries[be16_to_cpu(leaf->hdr.count)-1 ].hashval;\r\nnode->btree[0].before = cpu_to_be32(blkno);\r\nnode->hdr.count = cpu_to_be16(1);\r\nxfs_trans_log_buf(args->trans, bp1, 0, XFS_LBSIZE(dp->i_mount) - 1);\r\nerror = 0;\r\nout:\r\nreturn(error);\r\n}\r\nSTATIC int\r\nxfs_attr_leaf_create(\r\nxfs_da_args_t *args,\r\nxfs_dablk_t blkno,\r\nstruct xfs_buf **bpp)\r\n{\r\nxfs_attr_leafblock_t *leaf;\r\nxfs_attr_leaf_hdr_t *hdr;\r\nxfs_inode_t *dp;\r\nstruct xfs_buf *bp;\r\nint error;\r\ntrace_xfs_attr_leaf_create(args);\r\ndp = args->dp;\r\nASSERT(dp != NULL);\r\nerror = xfs_da_get_buf(args->trans, args->dp, blkno, -1, &bp,\r\nXFS_ATTR_FORK);\r\nif (error)\r\nreturn(error);\r\nbp->b_ops = &xfs_attr_leaf_buf_ops;\r\nleaf = bp->b_addr;\r\nmemset((char *)leaf, 0, XFS_LBSIZE(dp->i_mount));\r\nhdr = &leaf->hdr;\r\nhdr->info.magic = cpu_to_be16(XFS_ATTR_LEAF_MAGIC);\r\nhdr->firstused = cpu_to_be16(XFS_LBSIZE(dp->i_mount));\r\nif (!hdr->firstused) {\r\nhdr->firstused = cpu_to_be16(\r\nXFS_LBSIZE(dp->i_mount) - XFS_ATTR_LEAF_NAME_ALIGN);\r\n}\r\nhdr->freemap[0].base = cpu_to_be16(sizeof(xfs_attr_leaf_hdr_t));\r\nhdr->freemap[0].size = cpu_to_be16(be16_to_cpu(hdr->firstused) -\r\nsizeof(xfs_attr_leaf_hdr_t));\r\nxfs_trans_log_buf(args->trans, bp, 0, XFS_LBSIZE(dp->i_mount) - 1);\r\n*bpp = bp;\r\nreturn(0);\r\n}\r\nint\r\nxfs_attr_leaf_split(xfs_da_state_t *state, xfs_da_state_blk_t *oldblk,\r\nxfs_da_state_blk_t *newblk)\r\n{\r\nxfs_dablk_t blkno;\r\nint error;\r\ntrace_xfs_attr_leaf_split(state->args);\r\nASSERT(oldblk->magic == XFS_ATTR_LEAF_MAGIC);\r\nerror = xfs_da_grow_inode(state->args, &blkno);\r\nif (error)\r\nreturn(error);\r\nerror = xfs_attr_leaf_create(state->args, blkno, &newblk->bp);\r\nif (error)\r\nreturn(error);\r\nnewblk->blkno = blkno;\r\nnewblk->magic = XFS_ATTR_LEAF_MAGIC;\r\nxfs_attr_leaf_rebalance(state, oldblk, newblk);\r\nerror = xfs_da_blk_link(state, oldblk, newblk);\r\nif (error)\r\nreturn(error);\r\nif (state->inleaf) {\r\ntrace_xfs_attr_leaf_add_old(state->args);\r\nerror = xfs_attr_leaf_add(oldblk->bp, state->args);\r\n} else {\r\ntrace_xfs_attr_leaf_add_new(state->args);\r\nerror = xfs_attr_leaf_add(newblk->bp, state->args);\r\n}\r\noldblk->hashval = xfs_attr_leaf_lasthash(oldblk->bp, NULL);\r\nnewblk->hashval = xfs_attr_leaf_lasthash(newblk->bp, NULL);\r\nreturn(error);\r\n}\r\nint\r\nxfs_attr_leaf_add(\r\nstruct xfs_buf *bp,\r\nstruct xfs_da_args *args)\r\n{\r\nxfs_attr_leafblock_t *leaf;\r\nxfs_attr_leaf_hdr_t *hdr;\r\nxfs_attr_leaf_map_t *map;\r\nint tablesize, entsize, sum, tmp, i;\r\ntrace_xfs_attr_leaf_add(args);\r\nleaf = bp->b_addr;\r\nASSERT(leaf->hdr.info.magic == cpu_to_be16(XFS_ATTR_LEAF_MAGIC));\r\nASSERT((args->index >= 0)\r\n&& (args->index <= be16_to_cpu(leaf->hdr.count)));\r\nhdr = &leaf->hdr;\r\nentsize = xfs_attr_leaf_newentsize(args->namelen, args->valuelen,\r\nargs->trans->t_mountp->m_sb.sb_blocksize, NULL);\r\ntablesize = (be16_to_cpu(hdr->count) + 1)\r\n* sizeof(xfs_attr_leaf_entry_t)\r\n+ sizeof(xfs_attr_leaf_hdr_t);\r\nmap = &hdr->freemap[XFS_ATTR_LEAF_MAPSIZE-1];\r\nfor (sum = 0, i = XFS_ATTR_LEAF_MAPSIZE-1; i >= 0; map--, i--) {\r\nif (tablesize > be16_to_cpu(hdr->firstused)) {\r\nsum += be16_to_cpu(map->size);\r\ncontinue;\r\n}\r\nif (!map->size)\r\ncontinue;\r\ntmp = entsize;\r\nif (be16_to_cpu(map->base) < be16_to_cpu(hdr->firstused))\r\ntmp += sizeof(xfs_attr_leaf_entry_t);\r\nif (be16_to_cpu(map->size) >= tmp) {\r\ntmp = xfs_attr_leaf_add_work(bp, args, i);\r\nreturn(tmp);\r\n}\r\nsum += be16_to_cpu(map->size);\r\n}\r\nif (!hdr->holes && (sum < entsize))\r\nreturn(XFS_ERROR(ENOSPC));\r\nxfs_attr_leaf_compact(args, bp);\r\nif (be16_to_cpu(hdr->freemap[0].size)\r\n< (entsize + sizeof(xfs_attr_leaf_entry_t)))\r\nreturn(XFS_ERROR(ENOSPC));\r\nreturn(xfs_attr_leaf_add_work(bp, args, 0));\r\n}\r\nSTATIC int\r\nxfs_attr_leaf_add_work(\r\nstruct xfs_buf *bp,\r\nxfs_da_args_t *args,\r\nint mapindex)\r\n{\r\nxfs_attr_leafblock_t *leaf;\r\nxfs_attr_leaf_hdr_t *hdr;\r\nxfs_attr_leaf_entry_t *entry;\r\nxfs_attr_leaf_name_local_t *name_loc;\r\nxfs_attr_leaf_name_remote_t *name_rmt;\r\nxfs_attr_leaf_map_t *map;\r\nxfs_mount_t *mp;\r\nint tmp, i;\r\ntrace_xfs_attr_leaf_add_work(args);\r\nleaf = bp->b_addr;\r\nASSERT(leaf->hdr.info.magic == cpu_to_be16(XFS_ATTR_LEAF_MAGIC));\r\nhdr = &leaf->hdr;\r\nASSERT((mapindex >= 0) && (mapindex < XFS_ATTR_LEAF_MAPSIZE));\r\nASSERT((args->index >= 0) && (args->index <= be16_to_cpu(hdr->count)));\r\nentry = &leaf->entries[args->index];\r\nif (args->index < be16_to_cpu(hdr->count)) {\r\ntmp = be16_to_cpu(hdr->count) - args->index;\r\ntmp *= sizeof(xfs_attr_leaf_entry_t);\r\nmemmove((char *)(entry+1), (char *)entry, tmp);\r\nxfs_trans_log_buf(args->trans, bp,\r\nXFS_DA_LOGRANGE(leaf, entry, tmp + sizeof(*entry)));\r\n}\r\nbe16_add_cpu(&hdr->count, 1);\r\nmap = &hdr->freemap[mapindex];\r\nmp = args->trans->t_mountp;\r\nASSERT(be16_to_cpu(map->base) < XFS_LBSIZE(mp));\r\nASSERT((be16_to_cpu(map->base) & 0x3) == 0);\r\nASSERT(be16_to_cpu(map->size) >=\r\nxfs_attr_leaf_newentsize(args->namelen, args->valuelen,\r\nmp->m_sb.sb_blocksize, NULL));\r\nASSERT(be16_to_cpu(map->size) < XFS_LBSIZE(mp));\r\nASSERT((be16_to_cpu(map->size) & 0x3) == 0);\r\nbe16_add_cpu(&map->size,\r\n-xfs_attr_leaf_newentsize(args->namelen, args->valuelen,\r\nmp->m_sb.sb_blocksize, &tmp));\r\nentry->nameidx = cpu_to_be16(be16_to_cpu(map->base) +\r\nbe16_to_cpu(map->size));\r\nentry->hashval = cpu_to_be32(args->hashval);\r\nentry->flags = tmp ? XFS_ATTR_LOCAL : 0;\r\nentry->flags |= XFS_ATTR_NSP_ARGS_TO_ONDISK(args->flags);\r\nif (args->op_flags & XFS_DA_OP_RENAME) {\r\nentry->flags |= XFS_ATTR_INCOMPLETE;\r\nif ((args->blkno2 == args->blkno) &&\r\n(args->index2 <= args->index)) {\r\nargs->index2++;\r\n}\r\n}\r\nxfs_trans_log_buf(args->trans, bp,\r\nXFS_DA_LOGRANGE(leaf, entry, sizeof(*entry)));\r\nASSERT((args->index == 0) ||\r\n(be32_to_cpu(entry->hashval) >= be32_to_cpu((entry-1)->hashval)));\r\nASSERT((args->index == be16_to_cpu(hdr->count)-1) ||\r\n(be32_to_cpu(entry->hashval) <= be32_to_cpu((entry+1)->hashval)));\r\nif (entry->flags & XFS_ATTR_LOCAL) {\r\nname_loc = xfs_attr_leaf_name_local(leaf, args->index);\r\nname_loc->namelen = args->namelen;\r\nname_loc->valuelen = cpu_to_be16(args->valuelen);\r\nmemcpy((char *)name_loc->nameval, args->name, args->namelen);\r\nmemcpy((char *)&name_loc->nameval[args->namelen], args->value,\r\nbe16_to_cpu(name_loc->valuelen));\r\n} else {\r\nname_rmt = xfs_attr_leaf_name_remote(leaf, args->index);\r\nname_rmt->namelen = args->namelen;\r\nmemcpy((char *)name_rmt->name, args->name, args->namelen);\r\nentry->flags |= XFS_ATTR_INCOMPLETE;\r\nname_rmt->valuelen = 0;\r\nname_rmt->valueblk = 0;\r\nargs->rmtblkno = 1;\r\nargs->rmtblkcnt = XFS_B_TO_FSB(mp, args->valuelen);\r\n}\r\nxfs_trans_log_buf(args->trans, bp,\r\nXFS_DA_LOGRANGE(leaf, xfs_attr_leaf_name(leaf, args->index),\r\nxfs_attr_leaf_entsize(leaf, args->index)));\r\nif (be16_to_cpu(entry->nameidx) < be16_to_cpu(hdr->firstused)) {\r\nhdr->firstused = entry->nameidx;\r\n}\r\nASSERT(be16_to_cpu(hdr->firstused) >=\r\n((be16_to_cpu(hdr->count) * sizeof(*entry)) + sizeof(*hdr)));\r\ntmp = (be16_to_cpu(hdr->count)-1) * sizeof(xfs_attr_leaf_entry_t)\r\n+ sizeof(xfs_attr_leaf_hdr_t);\r\nmap = &hdr->freemap[0];\r\nfor (i = 0; i < XFS_ATTR_LEAF_MAPSIZE; map++, i++) {\r\nif (be16_to_cpu(map->base) == tmp) {\r\nbe16_add_cpu(&map->base, sizeof(xfs_attr_leaf_entry_t));\r\nbe16_add_cpu(&map->size,\r\n-((int)sizeof(xfs_attr_leaf_entry_t)));\r\n}\r\n}\r\nbe16_add_cpu(&hdr->usedbytes, xfs_attr_leaf_entsize(leaf, args->index));\r\nxfs_trans_log_buf(args->trans, bp,\r\nXFS_DA_LOGRANGE(leaf, hdr, sizeof(*hdr)));\r\nreturn(0);\r\n}\r\nSTATIC void\r\nxfs_attr_leaf_compact(\r\nstruct xfs_da_args *args,\r\nstruct xfs_buf *bp)\r\n{\r\nxfs_attr_leafblock_t *leaf_s, *leaf_d;\r\nxfs_attr_leaf_hdr_t *hdr_s, *hdr_d;\r\nstruct xfs_trans *trans = args->trans;\r\nstruct xfs_mount *mp = trans->t_mountp;\r\nchar *tmpbuffer;\r\ntrace_xfs_attr_leaf_compact(args);\r\ntmpbuffer = kmem_alloc(XFS_LBSIZE(mp), KM_SLEEP);\r\nASSERT(tmpbuffer != NULL);\r\nmemcpy(tmpbuffer, bp->b_addr, XFS_LBSIZE(mp));\r\nmemset(bp->b_addr, 0, XFS_LBSIZE(mp));\r\nleaf_s = (xfs_attr_leafblock_t *)tmpbuffer;\r\nleaf_d = bp->b_addr;\r\nhdr_s = &leaf_s->hdr;\r\nhdr_d = &leaf_d->hdr;\r\nhdr_d->info = hdr_s->info;\r\nhdr_d->firstused = cpu_to_be16(XFS_LBSIZE(mp));\r\nif (!hdr_d->firstused) {\r\nhdr_d->firstused = cpu_to_be16(\r\nXFS_LBSIZE(mp) - XFS_ATTR_LEAF_NAME_ALIGN);\r\n}\r\nhdr_d->usedbytes = 0;\r\nhdr_d->count = 0;\r\nhdr_d->holes = 0;\r\nhdr_d->freemap[0].base = cpu_to_be16(sizeof(xfs_attr_leaf_hdr_t));\r\nhdr_d->freemap[0].size = cpu_to_be16(be16_to_cpu(hdr_d->firstused) -\r\nsizeof(xfs_attr_leaf_hdr_t));\r\nxfs_attr_leaf_moveents(leaf_s, 0, leaf_d, 0,\r\nbe16_to_cpu(hdr_s->count), mp);\r\nxfs_trans_log_buf(trans, bp, 0, XFS_LBSIZE(mp) - 1);\r\nkmem_free(tmpbuffer);\r\n}\r\nSTATIC void\r\nxfs_attr_leaf_rebalance(xfs_da_state_t *state, xfs_da_state_blk_t *blk1,\r\nxfs_da_state_blk_t *blk2)\r\n{\r\nxfs_da_args_t *args;\r\nxfs_da_state_blk_t *tmp_blk;\r\nxfs_attr_leafblock_t *leaf1, *leaf2;\r\nxfs_attr_leaf_hdr_t *hdr1, *hdr2;\r\nint count, totallen, max, space, swap;\r\nASSERT(blk1->magic == XFS_ATTR_LEAF_MAGIC);\r\nASSERT(blk2->magic == XFS_ATTR_LEAF_MAGIC);\r\nleaf1 = blk1->bp->b_addr;\r\nleaf2 = blk2->bp->b_addr;\r\nASSERT(leaf1->hdr.info.magic == cpu_to_be16(XFS_ATTR_LEAF_MAGIC));\r\nASSERT(leaf2->hdr.info.magic == cpu_to_be16(XFS_ATTR_LEAF_MAGIC));\r\nASSERT(leaf2->hdr.count == 0);\r\nargs = state->args;\r\ntrace_xfs_attr_leaf_rebalance(args);\r\nswap = 0;\r\nif (xfs_attr_leaf_order(blk1->bp, blk2->bp)) {\r\ntmp_blk = blk1;\r\nblk1 = blk2;\r\nblk2 = tmp_blk;\r\nleaf1 = blk1->bp->b_addr;\r\nleaf2 = blk2->bp->b_addr;\r\nswap = 1;\r\n}\r\nhdr1 = &leaf1->hdr;\r\nhdr2 = &leaf2->hdr;\r\nstate->inleaf = xfs_attr_leaf_figure_balance(state, blk1, blk2,\r\n&count, &totallen);\r\nif (swap)\r\nstate->inleaf = !state->inleaf;\r\nif (count < be16_to_cpu(hdr1->count)) {\r\ncount = be16_to_cpu(hdr1->count) - count;\r\nspace = be16_to_cpu(hdr1->usedbytes) - totallen;\r\nspace += count * sizeof(xfs_attr_leaf_entry_t);\r\nmax = be16_to_cpu(hdr2->firstused)\r\n- sizeof(xfs_attr_leaf_hdr_t);\r\nmax -= be16_to_cpu(hdr2->count) * sizeof(xfs_attr_leaf_entry_t);\r\nif (space > max)\r\nxfs_attr_leaf_compact(args, blk2->bp);\r\nxfs_attr_leaf_moveents(leaf1, be16_to_cpu(hdr1->count) - count,\r\nleaf2, 0, count, state->mp);\r\nxfs_trans_log_buf(args->trans, blk1->bp, 0, state->blocksize-1);\r\nxfs_trans_log_buf(args->trans, blk2->bp, 0, state->blocksize-1);\r\n} else if (count > be16_to_cpu(hdr1->count)) {\r\nASSERT(0);\r\ncount -= be16_to_cpu(hdr1->count);\r\nspace = totallen - be16_to_cpu(hdr1->usedbytes);\r\nspace += count * sizeof(xfs_attr_leaf_entry_t);\r\nmax = be16_to_cpu(hdr1->firstused)\r\n- sizeof(xfs_attr_leaf_hdr_t);\r\nmax -= be16_to_cpu(hdr1->count) * sizeof(xfs_attr_leaf_entry_t);\r\nif (space > max)\r\nxfs_attr_leaf_compact(args, blk1->bp);\r\nxfs_attr_leaf_moveents(leaf2, 0, leaf1,\r\nbe16_to_cpu(hdr1->count), count, state->mp);\r\nxfs_trans_log_buf(args->trans, blk1->bp, 0, state->blocksize-1);\r\nxfs_trans_log_buf(args->trans, blk2->bp, 0, state->blocksize-1);\r\n}\r\nblk1->hashval = be32_to_cpu(\r\nleaf1->entries[be16_to_cpu(leaf1->hdr.count)-1].hashval);\r\nblk2->hashval = be32_to_cpu(\r\nleaf2->entries[be16_to_cpu(leaf2->hdr.count)-1].hashval);\r\nif (blk1->index > be16_to_cpu(leaf1->hdr.count)) {\r\nASSERT(state->inleaf == 0);\r\nblk2->index = blk1->index - be16_to_cpu(leaf1->hdr.count);\r\nargs->index = args->index2 = blk2->index;\r\nargs->blkno = args->blkno2 = blk2->blkno;\r\n} else if (blk1->index == be16_to_cpu(leaf1->hdr.count)) {\r\nif (state->inleaf) {\r\nargs->index = blk1->index;\r\nargs->blkno = blk1->blkno;\r\nargs->index2 = 0;\r\nargs->blkno2 = blk2->blkno;\r\n} else {\r\nblk2->index = blk1->index\r\n- be16_to_cpu(leaf1->hdr.count);\r\nargs->index = blk2->index;\r\nargs->blkno = blk2->blkno;\r\nif (!state->extravalid) {\r\nargs->index2 = blk2->index;\r\nargs->blkno2 = blk2->blkno;\r\n}\r\n}\r\n} else {\r\nASSERT(state->inleaf == 1);\r\nargs->index = args->index2 = blk1->index;\r\nargs->blkno = args->blkno2 = blk1->blkno;\r\n}\r\n}\r\nSTATIC int\r\nxfs_attr_leaf_figure_balance(xfs_da_state_t *state,\r\nxfs_da_state_blk_t *blk1,\r\nxfs_da_state_blk_t *blk2,\r\nint *countarg, int *usedbytesarg)\r\n{\r\nxfs_attr_leafblock_t *leaf1, *leaf2;\r\nxfs_attr_leaf_hdr_t *hdr1, *hdr2;\r\nxfs_attr_leaf_entry_t *entry;\r\nint count, max, index, totallen, half;\r\nint lastdelta, foundit, tmp;\r\nleaf1 = blk1->bp->b_addr;\r\nleaf2 = blk2->bp->b_addr;\r\nhdr1 = &leaf1->hdr;\r\nhdr2 = &leaf2->hdr;\r\nfoundit = 0;\r\ntotallen = 0;\r\nmax = be16_to_cpu(hdr1->count) + be16_to_cpu(hdr2->count);\r\nhalf = (max+1) * sizeof(*entry);\r\nhalf += be16_to_cpu(hdr1->usedbytes) +\r\nbe16_to_cpu(hdr2->usedbytes) +\r\nxfs_attr_leaf_newentsize(\r\nstate->args->namelen,\r\nstate->args->valuelen,\r\nstate->blocksize, NULL);\r\nhalf /= 2;\r\nlastdelta = state->blocksize;\r\nentry = &leaf1->entries[0];\r\nfor (count = index = 0; count < max; entry++, index++, count++) {\r\n#define XFS_ATTR_ABS(A) (((A) < 0) ? -(A) : (A))\r\nif (count == blk1->index) {\r\ntmp = totallen + sizeof(*entry) +\r\nxfs_attr_leaf_newentsize(\r\nstate->args->namelen,\r\nstate->args->valuelen,\r\nstate->blocksize, NULL);\r\nif (XFS_ATTR_ABS(half - tmp) > lastdelta)\r\nbreak;\r\nlastdelta = XFS_ATTR_ABS(half - tmp);\r\ntotallen = tmp;\r\nfoundit = 1;\r\n}\r\nif (count == be16_to_cpu(hdr1->count)) {\r\nleaf1 = leaf2;\r\nentry = &leaf1->entries[0];\r\nindex = 0;\r\n}\r\ntmp = totallen + sizeof(*entry) + xfs_attr_leaf_entsize(leaf1,\r\nindex);\r\nif (XFS_ATTR_ABS(half - tmp) > lastdelta)\r\nbreak;\r\nlastdelta = XFS_ATTR_ABS(half - tmp);\r\ntotallen = tmp;\r\n#undef XFS_ATTR_ABS\r\n}\r\ntotallen -= count * sizeof(*entry);\r\nif (foundit) {\r\ntotallen -= sizeof(*entry) +\r\nxfs_attr_leaf_newentsize(\r\nstate->args->namelen,\r\nstate->args->valuelen,\r\nstate->blocksize, NULL);\r\n}\r\n*countarg = count;\r\n*usedbytesarg = totallen;\r\nreturn(foundit);\r\n}\r\nint\r\nxfs_attr_leaf_toosmall(xfs_da_state_t *state, int *action)\r\n{\r\nxfs_attr_leafblock_t *leaf;\r\nxfs_da_state_blk_t *blk;\r\nxfs_da_blkinfo_t *info;\r\nint count, bytes, forward, error, retval, i;\r\nxfs_dablk_t blkno;\r\nstruct xfs_buf *bp;\r\ntrace_xfs_attr_leaf_toosmall(state->args);\r\nblk = &state->path.blk[ state->path.active-1 ];\r\ninfo = blk->bp->b_addr;\r\nASSERT(info->magic == cpu_to_be16(XFS_ATTR_LEAF_MAGIC));\r\nleaf = (xfs_attr_leafblock_t *)info;\r\ncount = be16_to_cpu(leaf->hdr.count);\r\nbytes = sizeof(xfs_attr_leaf_hdr_t) +\r\ncount * sizeof(xfs_attr_leaf_entry_t) +\r\nbe16_to_cpu(leaf->hdr.usedbytes);\r\nif (bytes > (state->blocksize >> 1)) {\r\n*action = 0;\r\nreturn(0);\r\n}\r\nif (count == 0) {\r\nforward = (info->forw != 0);\r\nmemcpy(&state->altpath, &state->path, sizeof(state->path));\r\nerror = xfs_da_path_shift(state, &state->altpath, forward,\r\n0, &retval);\r\nif (error)\r\nreturn(error);\r\nif (retval) {\r\n*action = 0;\r\n} else {\r\n*action = 2;\r\n}\r\nreturn(0);\r\n}\r\nforward = (be32_to_cpu(info->forw) < be32_to_cpu(info->back));\r\nfor (i = 0; i < 2; forward = !forward, i++) {\r\nif (forward)\r\nblkno = be32_to_cpu(info->forw);\r\nelse\r\nblkno = be32_to_cpu(info->back);\r\nif (blkno == 0)\r\ncontinue;\r\nerror = xfs_attr_leaf_read(state->args->trans, state->args->dp,\r\nblkno, -1, &bp);\r\nif (error)\r\nreturn(error);\r\nleaf = (xfs_attr_leafblock_t *)info;\r\ncount = be16_to_cpu(leaf->hdr.count);\r\nbytes = state->blocksize - (state->blocksize>>2);\r\nbytes -= be16_to_cpu(leaf->hdr.usedbytes);\r\nleaf = bp->b_addr;\r\ncount += be16_to_cpu(leaf->hdr.count);\r\nbytes -= be16_to_cpu(leaf->hdr.usedbytes);\r\nbytes -= count * sizeof(xfs_attr_leaf_entry_t);\r\nbytes -= sizeof(xfs_attr_leaf_hdr_t);\r\nxfs_trans_brelse(state->args->trans, bp);\r\nif (bytes >= 0)\r\nbreak;\r\n}\r\nif (i >= 2) {\r\n*action = 0;\r\nreturn(0);\r\n}\r\nmemcpy(&state->altpath, &state->path, sizeof(state->path));\r\nif (blkno < blk->blkno) {\r\nerror = xfs_da_path_shift(state, &state->altpath, forward,\r\n0, &retval);\r\n} else {\r\nerror = xfs_da_path_shift(state, &state->path, forward,\r\n0, &retval);\r\n}\r\nif (error)\r\nreturn(error);\r\nif (retval) {\r\n*action = 0;\r\n} else {\r\n*action = 1;\r\n}\r\nreturn(0);\r\n}\r\nint\r\nxfs_attr_leaf_remove(\r\nstruct xfs_buf *bp,\r\nxfs_da_args_t *args)\r\n{\r\nxfs_attr_leafblock_t *leaf;\r\nxfs_attr_leaf_hdr_t *hdr;\r\nxfs_attr_leaf_map_t *map;\r\nxfs_attr_leaf_entry_t *entry;\r\nint before, after, smallest, entsize;\r\nint tablesize, tmp, i;\r\nxfs_mount_t *mp;\r\ntrace_xfs_attr_leaf_remove(args);\r\nleaf = bp->b_addr;\r\nASSERT(leaf->hdr.info.magic == cpu_to_be16(XFS_ATTR_LEAF_MAGIC));\r\nhdr = &leaf->hdr;\r\nmp = args->trans->t_mountp;\r\nASSERT((be16_to_cpu(hdr->count) > 0)\r\n&& (be16_to_cpu(hdr->count) < (XFS_LBSIZE(mp)/8)));\r\nASSERT((args->index >= 0)\r\n&& (args->index < be16_to_cpu(hdr->count)));\r\nASSERT(be16_to_cpu(hdr->firstused) >=\r\n((be16_to_cpu(hdr->count) * sizeof(*entry)) + sizeof(*hdr)));\r\nentry = &leaf->entries[args->index];\r\nASSERT(be16_to_cpu(entry->nameidx) >= be16_to_cpu(hdr->firstused));\r\nASSERT(be16_to_cpu(entry->nameidx) < XFS_LBSIZE(mp));\r\ntablesize = be16_to_cpu(hdr->count) * sizeof(xfs_attr_leaf_entry_t)\r\n+ sizeof(xfs_attr_leaf_hdr_t);\r\nmap = &hdr->freemap[0];\r\ntmp = be16_to_cpu(map->size);\r\nbefore = after = -1;\r\nsmallest = XFS_ATTR_LEAF_MAPSIZE - 1;\r\nentsize = xfs_attr_leaf_entsize(leaf, args->index);\r\nfor (i = 0; i < XFS_ATTR_LEAF_MAPSIZE; map++, i++) {\r\nASSERT(be16_to_cpu(map->base) < XFS_LBSIZE(mp));\r\nASSERT(be16_to_cpu(map->size) < XFS_LBSIZE(mp));\r\nif (be16_to_cpu(map->base) == tablesize) {\r\nbe16_add_cpu(&map->base,\r\n-((int)sizeof(xfs_attr_leaf_entry_t)));\r\nbe16_add_cpu(&map->size, sizeof(xfs_attr_leaf_entry_t));\r\n}\r\nif ((be16_to_cpu(map->base) + be16_to_cpu(map->size))\r\n== be16_to_cpu(entry->nameidx)) {\r\nbefore = i;\r\n} else if (be16_to_cpu(map->base)\r\n== (be16_to_cpu(entry->nameidx) + entsize)) {\r\nafter = i;\r\n} else if (be16_to_cpu(map->size) < tmp) {\r\ntmp = be16_to_cpu(map->size);\r\nsmallest = i;\r\n}\r\n}\r\nif ((before >= 0) || (after >= 0)) {\r\nif ((before >= 0) && (after >= 0)) {\r\nmap = &hdr->freemap[before];\r\nbe16_add_cpu(&map->size, entsize);\r\nbe16_add_cpu(&map->size,\r\nbe16_to_cpu(hdr->freemap[after].size));\r\nhdr->freemap[after].base = 0;\r\nhdr->freemap[after].size = 0;\r\n} else if (before >= 0) {\r\nmap = &hdr->freemap[before];\r\nbe16_add_cpu(&map->size, entsize);\r\n} else {\r\nmap = &hdr->freemap[after];\r\nmap->base = entry->nameidx;\r\nbe16_add_cpu(&map->size, entsize);\r\n}\r\n} else {\r\nmap = &hdr->freemap[smallest];\r\nif (be16_to_cpu(map->size) < entsize) {\r\nmap->base = cpu_to_be16(be16_to_cpu(entry->nameidx));\r\nmap->size = cpu_to_be16(entsize);\r\n}\r\n}\r\nif (be16_to_cpu(entry->nameidx) == be16_to_cpu(hdr->firstused))\r\nsmallest = 1;\r\nelse\r\nsmallest = 0;\r\nmemset(xfs_attr_leaf_name(leaf, args->index), 0, entsize);\r\nbe16_add_cpu(&hdr->usedbytes, -entsize);\r\nxfs_trans_log_buf(args->trans, bp,\r\nXFS_DA_LOGRANGE(leaf, xfs_attr_leaf_name(leaf, args->index),\r\nentsize));\r\ntmp = (be16_to_cpu(hdr->count) - args->index)\r\n* sizeof(xfs_attr_leaf_entry_t);\r\nmemmove((char *)entry, (char *)(entry+1), tmp);\r\nbe16_add_cpu(&hdr->count, -1);\r\nxfs_trans_log_buf(args->trans, bp,\r\nXFS_DA_LOGRANGE(leaf, entry, tmp + sizeof(*entry)));\r\nentry = &leaf->entries[be16_to_cpu(hdr->count)];\r\nmemset((char *)entry, 0, sizeof(xfs_attr_leaf_entry_t));\r\nif (smallest) {\r\ntmp = XFS_LBSIZE(mp);\r\nentry = &leaf->entries[0];\r\nfor (i = be16_to_cpu(hdr->count)-1; i >= 0; entry++, i--) {\r\nASSERT(be16_to_cpu(entry->nameidx) >=\r\nbe16_to_cpu(hdr->firstused));\r\nASSERT(be16_to_cpu(entry->nameidx) < XFS_LBSIZE(mp));\r\nif (be16_to_cpu(entry->nameidx) < tmp)\r\ntmp = be16_to_cpu(entry->nameidx);\r\n}\r\nhdr->firstused = cpu_to_be16(tmp);\r\nif (!hdr->firstused) {\r\nhdr->firstused = cpu_to_be16(\r\ntmp - XFS_ATTR_LEAF_NAME_ALIGN);\r\n}\r\n} else {\r\nhdr->holes = 1;\r\n}\r\nxfs_trans_log_buf(args->trans, bp,\r\nXFS_DA_LOGRANGE(leaf, hdr, sizeof(*hdr)));\r\ntmp = sizeof(xfs_attr_leaf_hdr_t);\r\ntmp += be16_to_cpu(leaf->hdr.count) * sizeof(xfs_attr_leaf_entry_t);\r\ntmp += be16_to_cpu(leaf->hdr.usedbytes);\r\nreturn(tmp < mp->m_attr_magicpct);\r\n}\r\nvoid\r\nxfs_attr_leaf_unbalance(xfs_da_state_t *state, xfs_da_state_blk_t *drop_blk,\r\nxfs_da_state_blk_t *save_blk)\r\n{\r\nxfs_attr_leafblock_t *drop_leaf, *save_leaf, *tmp_leaf;\r\nxfs_attr_leaf_hdr_t *drop_hdr, *save_hdr, *tmp_hdr;\r\nxfs_mount_t *mp;\r\nchar *tmpbuffer;\r\ntrace_xfs_attr_leaf_unbalance(state->args);\r\nmp = state->mp;\r\nASSERT(drop_blk->magic == XFS_ATTR_LEAF_MAGIC);\r\nASSERT(save_blk->magic == XFS_ATTR_LEAF_MAGIC);\r\ndrop_leaf = drop_blk->bp->b_addr;\r\nsave_leaf = save_blk->bp->b_addr;\r\nASSERT(drop_leaf->hdr.info.magic == cpu_to_be16(XFS_ATTR_LEAF_MAGIC));\r\nASSERT(save_leaf->hdr.info.magic == cpu_to_be16(XFS_ATTR_LEAF_MAGIC));\r\ndrop_hdr = &drop_leaf->hdr;\r\nsave_hdr = &save_leaf->hdr;\r\ndrop_blk->hashval = be32_to_cpu(\r\ndrop_leaf->entries[be16_to_cpu(drop_leaf->hdr.count)-1].hashval);\r\nif (save_hdr->holes == 0) {\r\nif (xfs_attr_leaf_order(save_blk->bp, drop_blk->bp)) {\r\nxfs_attr_leaf_moveents(drop_leaf, 0, save_leaf, 0,\r\nbe16_to_cpu(drop_hdr->count), mp);\r\n} else {\r\nxfs_attr_leaf_moveents(drop_leaf, 0, save_leaf,\r\nbe16_to_cpu(save_hdr->count),\r\nbe16_to_cpu(drop_hdr->count), mp);\r\n}\r\n} else {\r\ntmpbuffer = kmem_alloc(state->blocksize, KM_SLEEP);\r\nASSERT(tmpbuffer != NULL);\r\nmemset(tmpbuffer, 0, state->blocksize);\r\ntmp_leaf = (xfs_attr_leafblock_t *)tmpbuffer;\r\ntmp_hdr = &tmp_leaf->hdr;\r\ntmp_hdr->info = save_hdr->info;\r\ntmp_hdr->count = 0;\r\ntmp_hdr->firstused = cpu_to_be16(state->blocksize);\r\nif (!tmp_hdr->firstused) {\r\ntmp_hdr->firstused = cpu_to_be16(\r\nstate->blocksize - XFS_ATTR_LEAF_NAME_ALIGN);\r\n}\r\ntmp_hdr->usedbytes = 0;\r\nif (xfs_attr_leaf_order(save_blk->bp, drop_blk->bp)) {\r\nxfs_attr_leaf_moveents(drop_leaf, 0, tmp_leaf, 0,\r\nbe16_to_cpu(drop_hdr->count), mp);\r\nxfs_attr_leaf_moveents(save_leaf, 0, tmp_leaf,\r\nbe16_to_cpu(tmp_leaf->hdr.count),\r\nbe16_to_cpu(save_hdr->count), mp);\r\n} else {\r\nxfs_attr_leaf_moveents(save_leaf, 0, tmp_leaf, 0,\r\nbe16_to_cpu(save_hdr->count), mp);\r\nxfs_attr_leaf_moveents(drop_leaf, 0, tmp_leaf,\r\nbe16_to_cpu(tmp_leaf->hdr.count),\r\nbe16_to_cpu(drop_hdr->count), mp);\r\n}\r\nmemcpy((char *)save_leaf, (char *)tmp_leaf, state->blocksize);\r\nkmem_free(tmpbuffer);\r\n}\r\nxfs_trans_log_buf(state->args->trans, save_blk->bp, 0,\r\nstate->blocksize - 1);\r\nsave_blk->hashval = be32_to_cpu(\r\nsave_leaf->entries[be16_to_cpu(save_leaf->hdr.count)-1].hashval);\r\n}\r\nint\r\nxfs_attr_leaf_lookup_int(\r\nstruct xfs_buf *bp,\r\nxfs_da_args_t *args)\r\n{\r\nxfs_attr_leafblock_t *leaf;\r\nxfs_attr_leaf_entry_t *entry;\r\nxfs_attr_leaf_name_local_t *name_loc;\r\nxfs_attr_leaf_name_remote_t *name_rmt;\r\nint probe, span;\r\nxfs_dahash_t hashval;\r\ntrace_xfs_attr_leaf_lookup(args);\r\nleaf = bp->b_addr;\r\nASSERT(leaf->hdr.info.magic == cpu_to_be16(XFS_ATTR_LEAF_MAGIC));\r\nASSERT(be16_to_cpu(leaf->hdr.count)\r\n< (XFS_LBSIZE(args->dp->i_mount)/8));\r\nhashval = args->hashval;\r\nprobe = span = be16_to_cpu(leaf->hdr.count) / 2;\r\nfor (entry = &leaf->entries[probe]; span > 4;\r\nentry = &leaf->entries[probe]) {\r\nspan /= 2;\r\nif (be32_to_cpu(entry->hashval) < hashval)\r\nprobe += span;\r\nelse if (be32_to_cpu(entry->hashval) > hashval)\r\nprobe -= span;\r\nelse\r\nbreak;\r\n}\r\nASSERT((probe >= 0) &&\r\n(!leaf->hdr.count\r\n|| (probe < be16_to_cpu(leaf->hdr.count))));\r\nASSERT((span <= 4) || (be32_to_cpu(entry->hashval) == hashval));\r\nwhile ((probe > 0) && (be32_to_cpu(entry->hashval) >= hashval)) {\r\nentry--;\r\nprobe--;\r\n}\r\nwhile ((probe < be16_to_cpu(leaf->hdr.count)) &&\r\n(be32_to_cpu(entry->hashval) < hashval)) {\r\nentry++;\r\nprobe++;\r\n}\r\nif ((probe == be16_to_cpu(leaf->hdr.count)) ||\r\n(be32_to_cpu(entry->hashval) != hashval)) {\r\nargs->index = probe;\r\nreturn(XFS_ERROR(ENOATTR));\r\n}\r\nfor ( ; (probe < be16_to_cpu(leaf->hdr.count)) &&\r\n(be32_to_cpu(entry->hashval) == hashval);\r\nentry++, probe++) {\r\nif ((args->flags & XFS_ATTR_INCOMPLETE) !=\r\n(entry->flags & XFS_ATTR_INCOMPLETE)) {\r\ncontinue;\r\n}\r\nif (entry->flags & XFS_ATTR_LOCAL) {\r\nname_loc = xfs_attr_leaf_name_local(leaf, probe);\r\nif (name_loc->namelen != args->namelen)\r\ncontinue;\r\nif (memcmp(args->name, (char *)name_loc->nameval, args->namelen) != 0)\r\ncontinue;\r\nif (!xfs_attr_namesp_match(args->flags, entry->flags))\r\ncontinue;\r\nargs->index = probe;\r\nreturn(XFS_ERROR(EEXIST));\r\n} else {\r\nname_rmt = xfs_attr_leaf_name_remote(leaf, probe);\r\nif (name_rmt->namelen != args->namelen)\r\ncontinue;\r\nif (memcmp(args->name, (char *)name_rmt->name,\r\nargs->namelen) != 0)\r\ncontinue;\r\nif (!xfs_attr_namesp_match(args->flags, entry->flags))\r\ncontinue;\r\nargs->index = probe;\r\nargs->rmtblkno = be32_to_cpu(name_rmt->valueblk);\r\nargs->rmtblkcnt = XFS_B_TO_FSB(args->dp->i_mount,\r\nbe32_to_cpu(name_rmt->valuelen));\r\nreturn(XFS_ERROR(EEXIST));\r\n}\r\n}\r\nargs->index = probe;\r\nreturn(XFS_ERROR(ENOATTR));\r\n}\r\nint\r\nxfs_attr_leaf_getvalue(\r\nstruct xfs_buf *bp,\r\nxfs_da_args_t *args)\r\n{\r\nint valuelen;\r\nxfs_attr_leafblock_t *leaf;\r\nxfs_attr_leaf_entry_t *entry;\r\nxfs_attr_leaf_name_local_t *name_loc;\r\nxfs_attr_leaf_name_remote_t *name_rmt;\r\nleaf = bp->b_addr;\r\nASSERT(leaf->hdr.info.magic == cpu_to_be16(XFS_ATTR_LEAF_MAGIC));\r\nASSERT(be16_to_cpu(leaf->hdr.count)\r\n< (XFS_LBSIZE(args->dp->i_mount)/8));\r\nASSERT(args->index < be16_to_cpu(leaf->hdr.count));\r\nentry = &leaf->entries[args->index];\r\nif (entry->flags & XFS_ATTR_LOCAL) {\r\nname_loc = xfs_attr_leaf_name_local(leaf, args->index);\r\nASSERT(name_loc->namelen == args->namelen);\r\nASSERT(memcmp(args->name, name_loc->nameval, args->namelen) == 0);\r\nvaluelen = be16_to_cpu(name_loc->valuelen);\r\nif (args->flags & ATTR_KERNOVAL) {\r\nargs->valuelen = valuelen;\r\nreturn(0);\r\n}\r\nif (args->valuelen < valuelen) {\r\nargs->valuelen = valuelen;\r\nreturn(XFS_ERROR(ERANGE));\r\n}\r\nargs->valuelen = valuelen;\r\nmemcpy(args->value, &name_loc->nameval[args->namelen], valuelen);\r\n} else {\r\nname_rmt = xfs_attr_leaf_name_remote(leaf, args->index);\r\nASSERT(name_rmt->namelen == args->namelen);\r\nASSERT(memcmp(args->name, name_rmt->name, args->namelen) == 0);\r\nvaluelen = be32_to_cpu(name_rmt->valuelen);\r\nargs->rmtblkno = be32_to_cpu(name_rmt->valueblk);\r\nargs->rmtblkcnt = XFS_B_TO_FSB(args->dp->i_mount, valuelen);\r\nif (args->flags & ATTR_KERNOVAL) {\r\nargs->valuelen = valuelen;\r\nreturn(0);\r\n}\r\nif (args->valuelen < valuelen) {\r\nargs->valuelen = valuelen;\r\nreturn(XFS_ERROR(ERANGE));\r\n}\r\nargs->valuelen = valuelen;\r\n}\r\nreturn(0);\r\n}\r\nSTATIC void\r\nxfs_attr_leaf_moveents(xfs_attr_leafblock_t *leaf_s, int start_s,\r\nxfs_attr_leafblock_t *leaf_d, int start_d,\r\nint count, xfs_mount_t *mp)\r\n{\r\nxfs_attr_leaf_hdr_t *hdr_s, *hdr_d;\r\nxfs_attr_leaf_entry_t *entry_s, *entry_d;\r\nint desti, tmp, i;\r\nif (count == 0)\r\nreturn;\r\nASSERT(leaf_s->hdr.info.magic == cpu_to_be16(XFS_ATTR_LEAF_MAGIC));\r\nASSERT(leaf_d->hdr.info.magic == cpu_to_be16(XFS_ATTR_LEAF_MAGIC));\r\nhdr_s = &leaf_s->hdr;\r\nhdr_d = &leaf_d->hdr;\r\nASSERT((be16_to_cpu(hdr_s->count) > 0) &&\r\n(be16_to_cpu(hdr_s->count) < (XFS_LBSIZE(mp)/8)));\r\nASSERT(be16_to_cpu(hdr_s->firstused) >=\r\n((be16_to_cpu(hdr_s->count)\r\n* sizeof(*entry_s))+sizeof(*hdr_s)));\r\nASSERT(be16_to_cpu(hdr_d->count) < (XFS_LBSIZE(mp)/8));\r\nASSERT(be16_to_cpu(hdr_d->firstused) >=\r\n((be16_to_cpu(hdr_d->count)\r\n* sizeof(*entry_d))+sizeof(*hdr_d)));\r\nASSERT(start_s < be16_to_cpu(hdr_s->count));\r\nASSERT(start_d <= be16_to_cpu(hdr_d->count));\r\nASSERT(count <= be16_to_cpu(hdr_s->count));\r\nif (start_d < be16_to_cpu(hdr_d->count)) {\r\ntmp = be16_to_cpu(hdr_d->count) - start_d;\r\ntmp *= sizeof(xfs_attr_leaf_entry_t);\r\nentry_s = &leaf_d->entries[start_d];\r\nentry_d = &leaf_d->entries[start_d + count];\r\nmemmove((char *)entry_d, (char *)entry_s, tmp);\r\n}\r\nentry_s = &leaf_s->entries[start_s];\r\nentry_d = &leaf_d->entries[start_d];\r\ndesti = start_d;\r\nfor (i = 0; i < count; entry_s++, entry_d++, desti++, i++) {\r\nASSERT(be16_to_cpu(entry_s->nameidx)\r\n>= be16_to_cpu(hdr_s->firstused));\r\ntmp = xfs_attr_leaf_entsize(leaf_s, start_s + i);\r\n#ifdef GROT\r\nif (entry_s->flags & XFS_ATTR_INCOMPLETE) {\r\nmemset(xfs_attr_leaf_name(leaf_s, start_s + i), 0, tmp);\r\nbe16_add_cpu(&hdr_s->usedbytes, -tmp);\r\nbe16_add_cpu(&hdr_s->count, -1);\r\nentry_d--;\r\ndesti--;\r\nif ((start_s + i) < offset)\r\nresult++;\r\n} else {\r\n#endif\r\nbe16_add_cpu(&hdr_d->firstused, -tmp);\r\nentry_d->hashval = entry_s->hashval;\r\nentry_d->nameidx = hdr_d->firstused;\r\nentry_d->flags = entry_s->flags;\r\nASSERT(be16_to_cpu(entry_d->nameidx) + tmp\r\n<= XFS_LBSIZE(mp));\r\nmemmove(xfs_attr_leaf_name(leaf_d, desti),\r\nxfs_attr_leaf_name(leaf_s, start_s + i), tmp);\r\nASSERT(be16_to_cpu(entry_s->nameidx) + tmp\r\n<= XFS_LBSIZE(mp));\r\nmemset(xfs_attr_leaf_name(leaf_s, start_s + i), 0, tmp);\r\nbe16_add_cpu(&hdr_s->usedbytes, -tmp);\r\nbe16_add_cpu(&hdr_d->usedbytes, tmp);\r\nbe16_add_cpu(&hdr_s->count, -1);\r\nbe16_add_cpu(&hdr_d->count, 1);\r\ntmp = be16_to_cpu(hdr_d->count)\r\n* sizeof(xfs_attr_leaf_entry_t)\r\n+ sizeof(xfs_attr_leaf_hdr_t);\r\nASSERT(be16_to_cpu(hdr_d->firstused) >= tmp);\r\n#ifdef GROT\r\n}\r\n#endif\r\n}\r\nif (start_s == be16_to_cpu(hdr_s->count)) {\r\ntmp = count * sizeof(xfs_attr_leaf_entry_t);\r\nentry_s = &leaf_s->entries[start_s];\r\nASSERT(((char *)entry_s + tmp) <=\r\n((char *)leaf_s + XFS_LBSIZE(mp)));\r\nmemset((char *)entry_s, 0, tmp);\r\n} else {\r\ntmp = be16_to_cpu(hdr_s->count) - count;\r\ntmp *= sizeof(xfs_attr_leaf_entry_t);\r\nentry_s = &leaf_s->entries[start_s + count];\r\nentry_d = &leaf_s->entries[start_s];\r\nmemmove((char *)entry_d, (char *)entry_s, tmp);\r\ntmp = count * sizeof(xfs_attr_leaf_entry_t);\r\nentry_s = &leaf_s->entries[be16_to_cpu(hdr_s->count)];\r\nASSERT(((char *)entry_s + tmp) <=\r\n((char *)leaf_s + XFS_LBSIZE(mp)));\r\nmemset((char *)entry_s, 0, tmp);\r\n}\r\nhdr_d->freemap[0].base = cpu_to_be16(sizeof(xfs_attr_leaf_hdr_t));\r\nbe16_add_cpu(&hdr_d->freemap[0].base, be16_to_cpu(hdr_d->count) *\r\nsizeof(xfs_attr_leaf_entry_t));\r\nhdr_d->freemap[0].size = cpu_to_be16(be16_to_cpu(hdr_d->firstused)\r\n- be16_to_cpu(hdr_d->freemap[0].base));\r\nhdr_d->freemap[1].base = 0;\r\nhdr_d->freemap[2].base = 0;\r\nhdr_d->freemap[1].size = 0;\r\nhdr_d->freemap[2].size = 0;\r\nhdr_s->holes = 1;\r\n}\r\nint\r\nxfs_attr_leaf_order(\r\nstruct xfs_buf *leaf1_bp,\r\nstruct xfs_buf *leaf2_bp)\r\n{\r\nxfs_attr_leafblock_t *leaf1, *leaf2;\r\nleaf1 = leaf1_bp->b_addr;\r\nleaf2 = leaf2_bp->b_addr;\r\nASSERT((leaf1->hdr.info.magic == cpu_to_be16(XFS_ATTR_LEAF_MAGIC)) &&\r\n(leaf2->hdr.info.magic == cpu_to_be16(XFS_ATTR_LEAF_MAGIC)));\r\nif ((be16_to_cpu(leaf1->hdr.count) > 0) &&\r\n(be16_to_cpu(leaf2->hdr.count) > 0) &&\r\n((be32_to_cpu(leaf2->entries[0].hashval) <\r\nbe32_to_cpu(leaf1->entries[0].hashval)) ||\r\n(be32_to_cpu(leaf2->entries[\r\nbe16_to_cpu(leaf2->hdr.count)-1].hashval) <\r\nbe32_to_cpu(leaf1->entries[\r\nbe16_to_cpu(leaf1->hdr.count)-1].hashval)))) {\r\nreturn(1);\r\n}\r\nreturn(0);\r\n}\r\nxfs_dahash_t\r\nxfs_attr_leaf_lasthash(\r\nstruct xfs_buf *bp,\r\nint *count)\r\n{\r\nxfs_attr_leafblock_t *leaf;\r\nleaf = bp->b_addr;\r\nASSERT(leaf->hdr.info.magic == cpu_to_be16(XFS_ATTR_LEAF_MAGIC));\r\nif (count)\r\n*count = be16_to_cpu(leaf->hdr.count);\r\nif (!leaf->hdr.count)\r\nreturn(0);\r\nreturn be32_to_cpu(leaf->entries[be16_to_cpu(leaf->hdr.count)-1].hashval);\r\n}\r\nSTATIC int\r\nxfs_attr_leaf_entsize(xfs_attr_leafblock_t *leaf, int index)\r\n{\r\nxfs_attr_leaf_name_local_t *name_loc;\r\nxfs_attr_leaf_name_remote_t *name_rmt;\r\nint size;\r\nASSERT(leaf->hdr.info.magic == cpu_to_be16(XFS_ATTR_LEAF_MAGIC));\r\nif (leaf->entries[index].flags & XFS_ATTR_LOCAL) {\r\nname_loc = xfs_attr_leaf_name_local(leaf, index);\r\nsize = xfs_attr_leaf_entsize_local(name_loc->namelen,\r\nbe16_to_cpu(name_loc->valuelen));\r\n} else {\r\nname_rmt = xfs_attr_leaf_name_remote(leaf, index);\r\nsize = xfs_attr_leaf_entsize_remote(name_rmt->namelen);\r\n}\r\nreturn(size);\r\n}\r\nint\r\nxfs_attr_leaf_newentsize(int namelen, int valuelen, int blocksize, int *local)\r\n{\r\nint size;\r\nsize = xfs_attr_leaf_entsize_local(namelen, valuelen);\r\nif (size < xfs_attr_leaf_entsize_local_max(blocksize)) {\r\nif (local) {\r\n*local = 1;\r\n}\r\n} else {\r\nsize = xfs_attr_leaf_entsize_remote(namelen);\r\nif (local) {\r\n*local = 0;\r\n}\r\n}\r\nreturn(size);\r\n}\r\nint\r\nxfs_attr_leaf_list_int(\r\nstruct xfs_buf *bp,\r\nxfs_attr_list_context_t *context)\r\n{\r\nattrlist_cursor_kern_t *cursor;\r\nxfs_attr_leafblock_t *leaf;\r\nxfs_attr_leaf_entry_t *entry;\r\nint retval, i;\r\nASSERT(bp != NULL);\r\nleaf = bp->b_addr;\r\ncursor = context->cursor;\r\ncursor->initted = 1;\r\ntrace_xfs_attr_list_leaf(context);\r\nif (context->resynch) {\r\nentry = &leaf->entries[0];\r\nfor (i = 0; i < be16_to_cpu(leaf->hdr.count); entry++, i++) {\r\nif (be32_to_cpu(entry->hashval) == cursor->hashval) {\r\nif (cursor->offset == context->dupcnt) {\r\ncontext->dupcnt = 0;\r\nbreak;\r\n}\r\ncontext->dupcnt++;\r\n} else if (be32_to_cpu(entry->hashval) >\r\ncursor->hashval) {\r\ncontext->dupcnt = 0;\r\nbreak;\r\n}\r\n}\r\nif (i == be16_to_cpu(leaf->hdr.count)) {\r\ntrace_xfs_attr_list_notfound(context);\r\nreturn(0);\r\n}\r\n} else {\r\nentry = &leaf->entries[0];\r\ni = 0;\r\n}\r\ncontext->resynch = 0;\r\nretval = 0;\r\nfor ( ; (i < be16_to_cpu(leaf->hdr.count)); entry++, i++) {\r\nif (be32_to_cpu(entry->hashval) != cursor->hashval) {\r\ncursor->hashval = be32_to_cpu(entry->hashval);\r\ncursor->offset = 0;\r\n}\r\nif (entry->flags & XFS_ATTR_INCOMPLETE)\r\ncontinue;\r\nif (entry->flags & XFS_ATTR_LOCAL) {\r\nxfs_attr_leaf_name_local_t *name_loc =\r\nxfs_attr_leaf_name_local(leaf, i);\r\nretval = context->put_listent(context,\r\nentry->flags,\r\nname_loc->nameval,\r\n(int)name_loc->namelen,\r\nbe16_to_cpu(name_loc->valuelen),\r\n&name_loc->nameval[name_loc->namelen]);\r\nif (retval)\r\nreturn retval;\r\n} else {\r\nxfs_attr_leaf_name_remote_t *name_rmt =\r\nxfs_attr_leaf_name_remote(leaf, i);\r\nint valuelen = be32_to_cpu(name_rmt->valuelen);\r\nif (context->put_value) {\r\nxfs_da_args_t args;\r\nmemset((char *)&args, 0, sizeof(args));\r\nargs.dp = context->dp;\r\nargs.whichfork = XFS_ATTR_FORK;\r\nargs.valuelen = valuelen;\r\nargs.value = kmem_alloc(valuelen, KM_SLEEP | KM_NOFS);\r\nargs.rmtblkno = be32_to_cpu(name_rmt->valueblk);\r\nargs.rmtblkcnt = XFS_B_TO_FSB(args.dp->i_mount, valuelen);\r\nretval = xfs_attr_rmtval_get(&args);\r\nif (retval)\r\nreturn retval;\r\nretval = context->put_listent(context,\r\nentry->flags,\r\nname_rmt->name,\r\n(int)name_rmt->namelen,\r\nvaluelen,\r\nargs.value);\r\nkmem_free(args.value);\r\n} else {\r\nretval = context->put_listent(context,\r\nentry->flags,\r\nname_rmt->name,\r\n(int)name_rmt->namelen,\r\nvaluelen,\r\nNULL);\r\n}\r\nif (retval)\r\nreturn retval;\r\n}\r\nif (context->seen_enough)\r\nbreak;\r\ncursor->offset++;\r\n}\r\ntrace_xfs_attr_list_leaf_end(context);\r\nreturn(retval);\r\n}\r\nint\r\nxfs_attr_leaf_clearflag(xfs_da_args_t *args)\r\n{\r\nxfs_attr_leafblock_t *leaf;\r\nxfs_attr_leaf_entry_t *entry;\r\nxfs_attr_leaf_name_remote_t *name_rmt;\r\nstruct xfs_buf *bp;\r\nint error;\r\n#ifdef DEBUG\r\nxfs_attr_leaf_name_local_t *name_loc;\r\nint namelen;\r\nchar *name;\r\n#endif\r\ntrace_xfs_attr_leaf_clearflag(args);\r\nerror = xfs_attr_leaf_read(args->trans, args->dp, args->blkno, -1, &bp);\r\nif (error)\r\nreturn(error);\r\nleaf = bp->b_addr;\r\nASSERT(args->index < be16_to_cpu(leaf->hdr.count));\r\nASSERT(args->index >= 0);\r\nentry = &leaf->entries[ args->index ];\r\nASSERT(entry->flags & XFS_ATTR_INCOMPLETE);\r\n#ifdef DEBUG\r\nif (entry->flags & XFS_ATTR_LOCAL) {\r\nname_loc = xfs_attr_leaf_name_local(leaf, args->index);\r\nnamelen = name_loc->namelen;\r\nname = (char *)name_loc->nameval;\r\n} else {\r\nname_rmt = xfs_attr_leaf_name_remote(leaf, args->index);\r\nnamelen = name_rmt->namelen;\r\nname = (char *)name_rmt->name;\r\n}\r\nASSERT(be32_to_cpu(entry->hashval) == args->hashval);\r\nASSERT(namelen == args->namelen);\r\nASSERT(memcmp(name, args->name, namelen) == 0);\r\n#endif\r\nentry->flags &= ~XFS_ATTR_INCOMPLETE;\r\nxfs_trans_log_buf(args->trans, bp,\r\nXFS_DA_LOGRANGE(leaf, entry, sizeof(*entry)));\r\nif (args->rmtblkno) {\r\nASSERT((entry->flags & XFS_ATTR_LOCAL) == 0);\r\nname_rmt = xfs_attr_leaf_name_remote(leaf, args->index);\r\nname_rmt->valueblk = cpu_to_be32(args->rmtblkno);\r\nname_rmt->valuelen = cpu_to_be32(args->valuelen);\r\nxfs_trans_log_buf(args->trans, bp,\r\nXFS_DA_LOGRANGE(leaf, name_rmt, sizeof(*name_rmt)));\r\n}\r\nreturn xfs_trans_roll(&args->trans, args->dp);\r\n}\r\nint\r\nxfs_attr_leaf_setflag(xfs_da_args_t *args)\r\n{\r\nxfs_attr_leafblock_t *leaf;\r\nxfs_attr_leaf_entry_t *entry;\r\nxfs_attr_leaf_name_remote_t *name_rmt;\r\nstruct xfs_buf *bp;\r\nint error;\r\ntrace_xfs_attr_leaf_setflag(args);\r\nerror = xfs_attr_leaf_read(args->trans, args->dp, args->blkno, -1, &bp);\r\nif (error)\r\nreturn(error);\r\nleaf = bp->b_addr;\r\nASSERT(args->index < be16_to_cpu(leaf->hdr.count));\r\nASSERT(args->index >= 0);\r\nentry = &leaf->entries[ args->index ];\r\nASSERT((entry->flags & XFS_ATTR_INCOMPLETE) == 0);\r\nentry->flags |= XFS_ATTR_INCOMPLETE;\r\nxfs_trans_log_buf(args->trans, bp,\r\nXFS_DA_LOGRANGE(leaf, entry, sizeof(*entry)));\r\nif ((entry->flags & XFS_ATTR_LOCAL) == 0) {\r\nname_rmt = xfs_attr_leaf_name_remote(leaf, args->index);\r\nname_rmt->valueblk = 0;\r\nname_rmt->valuelen = 0;\r\nxfs_trans_log_buf(args->trans, bp,\r\nXFS_DA_LOGRANGE(leaf, name_rmt, sizeof(*name_rmt)));\r\n}\r\nreturn xfs_trans_roll(&args->trans, args->dp);\r\n}\r\nint\r\nxfs_attr_leaf_flipflags(xfs_da_args_t *args)\r\n{\r\nxfs_attr_leafblock_t *leaf1, *leaf2;\r\nxfs_attr_leaf_entry_t *entry1, *entry2;\r\nxfs_attr_leaf_name_remote_t *name_rmt;\r\nstruct xfs_buf *bp1, *bp2;\r\nint error;\r\n#ifdef DEBUG\r\nxfs_attr_leaf_name_local_t *name_loc;\r\nint namelen1, namelen2;\r\nchar *name1, *name2;\r\n#endif\r\ntrace_xfs_attr_leaf_flipflags(args);\r\nerror = xfs_attr_leaf_read(args->trans, args->dp, args->blkno, -1, &bp1);\r\nif (error)\r\nreturn error;\r\nif (args->blkno2 != args->blkno) {\r\nerror = xfs_attr_leaf_read(args->trans, args->dp, args->blkno2,\r\n-1, &bp2);\r\nif (error)\r\nreturn error;\r\n} else {\r\nbp2 = bp1;\r\n}\r\nleaf1 = bp1->b_addr;\r\nASSERT(args->index < be16_to_cpu(leaf1->hdr.count));\r\nASSERT(args->index >= 0);\r\nentry1 = &leaf1->entries[ args->index ];\r\nleaf2 = bp2->b_addr;\r\nASSERT(args->index2 < be16_to_cpu(leaf2->hdr.count));\r\nASSERT(args->index2 >= 0);\r\nentry2 = &leaf2->entries[ args->index2 ];\r\n#ifdef DEBUG\r\nif (entry1->flags & XFS_ATTR_LOCAL) {\r\nname_loc = xfs_attr_leaf_name_local(leaf1, args->index);\r\nnamelen1 = name_loc->namelen;\r\nname1 = (char *)name_loc->nameval;\r\n} else {\r\nname_rmt = xfs_attr_leaf_name_remote(leaf1, args->index);\r\nnamelen1 = name_rmt->namelen;\r\nname1 = (char *)name_rmt->name;\r\n}\r\nif (entry2->flags & XFS_ATTR_LOCAL) {\r\nname_loc = xfs_attr_leaf_name_local(leaf2, args->index2);\r\nnamelen2 = name_loc->namelen;\r\nname2 = (char *)name_loc->nameval;\r\n} else {\r\nname_rmt = xfs_attr_leaf_name_remote(leaf2, args->index2);\r\nnamelen2 = name_rmt->namelen;\r\nname2 = (char *)name_rmt->name;\r\n}\r\nASSERT(be32_to_cpu(entry1->hashval) == be32_to_cpu(entry2->hashval));\r\nASSERT(namelen1 == namelen2);\r\nASSERT(memcmp(name1, name2, namelen1) == 0);\r\n#endif\r\nASSERT(entry1->flags & XFS_ATTR_INCOMPLETE);\r\nASSERT((entry2->flags & XFS_ATTR_INCOMPLETE) == 0);\r\nentry1->flags &= ~XFS_ATTR_INCOMPLETE;\r\nxfs_trans_log_buf(args->trans, bp1,\r\nXFS_DA_LOGRANGE(leaf1, entry1, sizeof(*entry1)));\r\nif (args->rmtblkno) {\r\nASSERT((entry1->flags & XFS_ATTR_LOCAL) == 0);\r\nname_rmt = xfs_attr_leaf_name_remote(leaf1, args->index);\r\nname_rmt->valueblk = cpu_to_be32(args->rmtblkno);\r\nname_rmt->valuelen = cpu_to_be32(args->valuelen);\r\nxfs_trans_log_buf(args->trans, bp1,\r\nXFS_DA_LOGRANGE(leaf1, name_rmt, sizeof(*name_rmt)));\r\n}\r\nentry2->flags |= XFS_ATTR_INCOMPLETE;\r\nxfs_trans_log_buf(args->trans, bp2,\r\nXFS_DA_LOGRANGE(leaf2, entry2, sizeof(*entry2)));\r\nif ((entry2->flags & XFS_ATTR_LOCAL) == 0) {\r\nname_rmt = xfs_attr_leaf_name_remote(leaf2, args->index2);\r\nname_rmt->valueblk = 0;\r\nname_rmt->valuelen = 0;\r\nxfs_trans_log_buf(args->trans, bp2,\r\nXFS_DA_LOGRANGE(leaf2, name_rmt, sizeof(*name_rmt)));\r\n}\r\nerror = xfs_trans_roll(&args->trans, args->dp);\r\nreturn(error);\r\n}\r\nint\r\nxfs_attr_root_inactive(xfs_trans_t **trans, xfs_inode_t *dp)\r\n{\r\nxfs_da_blkinfo_t *info;\r\nxfs_daddr_t blkno;\r\nstruct xfs_buf *bp;\r\nint error;\r\nerror = xfs_da_node_read(*trans, dp, 0, -1, &bp, XFS_ATTR_FORK);\r\nif (error)\r\nreturn(error);\r\nblkno = XFS_BUF_ADDR(bp);\r\ninfo = bp->b_addr;\r\nif (info->magic == cpu_to_be16(XFS_DA_NODE_MAGIC)) {\r\nerror = xfs_attr_node_inactive(trans, dp, bp, 1);\r\n} else if (info->magic == cpu_to_be16(XFS_ATTR_LEAF_MAGIC)) {\r\nerror = xfs_attr_leaf_inactive(trans, dp, bp);\r\n} else {\r\nerror = XFS_ERROR(EIO);\r\nxfs_trans_brelse(*trans, bp);\r\n}\r\nif (error)\r\nreturn(error);\r\nerror = xfs_da_get_buf(*trans, dp, 0, blkno, &bp, XFS_ATTR_FORK);\r\nif (error)\r\nreturn(error);\r\nxfs_trans_binval(*trans, bp);\r\nerror = xfs_trans_roll(trans, dp);\r\nreturn (error);\r\n}\r\nSTATIC int\r\nxfs_attr_node_inactive(\r\nstruct xfs_trans **trans,\r\nstruct xfs_inode *dp,\r\nstruct xfs_buf *bp,\r\nint level)\r\n{\r\nxfs_da_blkinfo_t *info;\r\nxfs_da_intnode_t *node;\r\nxfs_dablk_t child_fsb;\r\nxfs_daddr_t parent_blkno, child_blkno;\r\nint error, count, i;\r\nstruct xfs_buf *child_bp;\r\nif (level > XFS_DA_NODE_MAXDEPTH) {\r\nxfs_trans_brelse(*trans, bp);\r\nreturn(XFS_ERROR(EIO));\r\n}\r\nnode = bp->b_addr;\r\nASSERT(node->hdr.info.magic == cpu_to_be16(XFS_DA_NODE_MAGIC));\r\nparent_blkno = XFS_BUF_ADDR(bp);\r\ncount = be16_to_cpu(node->hdr.count);\r\nif (!count) {\r\nxfs_trans_brelse(*trans, bp);\r\nreturn(0);\r\n}\r\nchild_fsb = be32_to_cpu(node->btree[0].before);\r\nxfs_trans_brelse(*trans, bp);\r\nfor (i = 0; i < count; i++) {\r\nerror = xfs_da_node_read(*trans, dp, child_fsb, -2, &child_bp,\r\nXFS_ATTR_FORK);\r\nif (error)\r\nreturn(error);\r\nif (child_bp) {\r\nchild_blkno = XFS_BUF_ADDR(child_bp);\r\ninfo = child_bp->b_addr;\r\nif (info->magic == cpu_to_be16(XFS_DA_NODE_MAGIC)) {\r\nerror = xfs_attr_node_inactive(trans, dp,\r\nchild_bp, level+1);\r\n} else if (info->magic == cpu_to_be16(XFS_ATTR_LEAF_MAGIC)) {\r\nerror = xfs_attr_leaf_inactive(trans, dp,\r\nchild_bp);\r\n} else {\r\nerror = XFS_ERROR(EIO);\r\nxfs_trans_brelse(*trans, child_bp);\r\n}\r\nif (error)\r\nreturn(error);\r\nerror = xfs_da_get_buf(*trans, dp, 0, child_blkno,\r\n&child_bp, XFS_ATTR_FORK);\r\nif (error)\r\nreturn(error);\r\nxfs_trans_binval(*trans, child_bp);\r\n}\r\nif ((i+1) < count) {\r\nerror = xfs_da_node_read(*trans, dp, 0, parent_blkno,\r\n&bp, XFS_ATTR_FORK);\r\nif (error)\r\nreturn(error);\r\nchild_fsb = be32_to_cpu(node->btree[i+1].before);\r\nxfs_trans_brelse(*trans, bp);\r\n}\r\nerror = xfs_trans_roll(trans, dp);\r\nif (error)\r\nreturn (error);\r\n}\r\nreturn(0);\r\n}\r\nSTATIC int\r\nxfs_attr_leaf_inactive(\r\nstruct xfs_trans **trans,\r\nstruct xfs_inode *dp,\r\nstruct xfs_buf *bp)\r\n{\r\nxfs_attr_leafblock_t *leaf;\r\nxfs_attr_leaf_entry_t *entry;\r\nxfs_attr_leaf_name_remote_t *name_rmt;\r\nxfs_attr_inactive_list_t *list, *lp;\r\nint error, count, size, tmp, i;\r\nleaf = bp->b_addr;\r\nASSERT(leaf->hdr.info.magic == cpu_to_be16(XFS_ATTR_LEAF_MAGIC));\r\ncount = 0;\r\nentry = &leaf->entries[0];\r\nfor (i = 0; i < be16_to_cpu(leaf->hdr.count); entry++, i++) {\r\nif (be16_to_cpu(entry->nameidx) &&\r\n((entry->flags & XFS_ATTR_LOCAL) == 0)) {\r\nname_rmt = xfs_attr_leaf_name_remote(leaf, i);\r\nif (name_rmt->valueblk)\r\ncount++;\r\n}\r\n}\r\nif (count == 0) {\r\nxfs_trans_brelse(*trans, bp);\r\nreturn(0);\r\n}\r\nsize = count * sizeof(xfs_attr_inactive_list_t);\r\nlist = (xfs_attr_inactive_list_t *)kmem_alloc(size, KM_SLEEP);\r\nlp = list;\r\nentry = &leaf->entries[0];\r\nfor (i = 0; i < be16_to_cpu(leaf->hdr.count); entry++, i++) {\r\nif (be16_to_cpu(entry->nameidx) &&\r\n((entry->flags & XFS_ATTR_LOCAL) == 0)) {\r\nname_rmt = xfs_attr_leaf_name_remote(leaf, i);\r\nif (name_rmt->valueblk) {\r\nlp->valueblk = be32_to_cpu(name_rmt->valueblk);\r\nlp->valuelen = XFS_B_TO_FSB(dp->i_mount,\r\nbe32_to_cpu(name_rmt->valuelen));\r\nlp++;\r\n}\r\n}\r\n}\r\nxfs_trans_brelse(*trans, bp);\r\nerror = 0;\r\nfor (lp = list, i = 0; i < count; i++, lp++) {\r\ntmp = xfs_attr_leaf_freextent(trans, dp,\r\nlp->valueblk, lp->valuelen);\r\nif (error == 0)\r\nerror = tmp;\r\n}\r\nkmem_free((xfs_caddr_t)list);\r\nreturn(error);\r\n}\r\nSTATIC int\r\nxfs_attr_leaf_freextent(xfs_trans_t **trans, xfs_inode_t *dp,\r\nxfs_dablk_t blkno, int blkcnt)\r\n{\r\nxfs_bmbt_irec_t map;\r\nxfs_dablk_t tblkno;\r\nint tblkcnt, dblkcnt, nmap, error;\r\nxfs_daddr_t dblkno;\r\nxfs_buf_t *bp;\r\ntblkno = blkno;\r\ntblkcnt = blkcnt;\r\nwhile (tblkcnt > 0) {\r\nnmap = 1;\r\nerror = xfs_bmapi_read(dp, (xfs_fileoff_t)tblkno, tblkcnt,\r\n&map, &nmap, XFS_BMAPI_ATTRFORK);\r\nif (error) {\r\nreturn(error);\r\n}\r\nASSERT(nmap == 1);\r\nASSERT(map.br_startblock != DELAYSTARTBLOCK);\r\nif (map.br_startblock != HOLESTARTBLOCK) {\r\ndblkno = XFS_FSB_TO_DADDR(dp->i_mount,\r\nmap.br_startblock);\r\ndblkcnt = XFS_FSB_TO_BB(dp->i_mount,\r\nmap.br_blockcount);\r\nbp = xfs_trans_get_buf(*trans,\r\ndp->i_mount->m_ddev_targp,\r\ndblkno, dblkcnt, 0);\r\nif (!bp)\r\nreturn ENOMEM;\r\nxfs_trans_binval(*trans, bp);\r\nerror = xfs_trans_roll(trans, dp);\r\nif (error)\r\nreturn (error);\r\n}\r\ntblkno += map.br_blockcount;\r\ntblkcnt -= map.br_blockcount;\r\n}\r\nreturn(0);\r\n}
