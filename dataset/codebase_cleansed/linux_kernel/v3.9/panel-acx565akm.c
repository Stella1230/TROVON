static void acx565akm_transfer(struct acx565akm_device *md, int cmd,\r\nconst u8 *wbuf, int wlen, u8 *rbuf, int rlen)\r\n{\r\nstruct spi_message m;\r\nstruct spi_transfer *x, xfer[5];\r\nint r;\r\nBUG_ON(md->spi == NULL);\r\nspi_message_init(&m);\r\nmemset(xfer, 0, sizeof(xfer));\r\nx = &xfer[0];\r\ncmd &= 0xff;\r\nx->tx_buf = &cmd;\r\nx->bits_per_word = 9;\r\nx->len = 2;\r\nif (rlen > 1 && wlen == 0) {\r\nx->bits_per_word = 10;\r\ncmd <<= 1;\r\n}\r\nspi_message_add_tail(x, &m);\r\nif (wlen) {\r\nx++;\r\nx->tx_buf = wbuf;\r\nx->len = wlen;\r\nx->bits_per_word = 9;\r\nspi_message_add_tail(x, &m);\r\n}\r\nif (rlen) {\r\nx++;\r\nx->rx_buf = rbuf;\r\nx->len = rlen;\r\nspi_message_add_tail(x, &m);\r\n}\r\nr = spi_sync(md->spi, &m);\r\nif (r < 0)\r\ndev_dbg(&md->spi->dev, "spi_sync %d\n", r);\r\n}\r\nstatic inline void acx565akm_cmd(struct acx565akm_device *md, int cmd)\r\n{\r\nacx565akm_transfer(md, cmd, NULL, 0, NULL, 0);\r\n}\r\nstatic inline void acx565akm_write(struct acx565akm_device *md,\r\nint reg, const u8 *buf, int len)\r\n{\r\nacx565akm_transfer(md, reg, buf, len, NULL, 0);\r\n}\r\nstatic inline void acx565akm_read(struct acx565akm_device *md,\r\nint reg, u8 *buf, int len)\r\n{\r\nacx565akm_transfer(md, reg, NULL, 0, buf, len);\r\n}\r\nstatic void hw_guard_start(struct acx565akm_device *md, int guard_msec)\r\n{\r\nmd->hw_guard_wait = msecs_to_jiffies(guard_msec);\r\nmd->hw_guard_end = jiffies + md->hw_guard_wait;\r\n}\r\nstatic void hw_guard_wait(struct acx565akm_device *md)\r\n{\r\nunsigned long wait = md->hw_guard_end - jiffies;\r\nif ((long)wait > 0 && wait <= md->hw_guard_wait) {\r\nset_current_state(TASK_UNINTERRUPTIBLE);\r\nschedule_timeout(wait);\r\n}\r\n}\r\nstatic void set_sleep_mode(struct acx565akm_device *md, int on)\r\n{\r\nint cmd;\r\nif (on)\r\ncmd = MIPID_CMD_SLEEP_IN;\r\nelse\r\ncmd = MIPID_CMD_SLEEP_OUT;\r\nhw_guard_wait(md);\r\nacx565akm_cmd(md, cmd);\r\nhw_guard_start(md, 120);\r\n}\r\nstatic void set_display_state(struct acx565akm_device *md, int enabled)\r\n{\r\nint cmd = enabled ? MIPID_CMD_DISP_ON : MIPID_CMD_DISP_OFF;\r\nacx565akm_cmd(md, cmd);\r\n}\r\nstatic int panel_enabled(struct acx565akm_device *md)\r\n{\r\nu32 disp_status;\r\nint enabled;\r\nacx565akm_read(md, MIPID_CMD_READ_DISP_STATUS, (u8 *)&disp_status, 4);\r\ndisp_status = __be32_to_cpu(disp_status);\r\nenabled = (disp_status & (1 << 17)) && (disp_status & (1 << 10));\r\ndev_dbg(&md->spi->dev,\r\n"LCD panel %senabled by bootloader (status 0x%04x)\n",\r\nenabled ? "" : "not ", disp_status);\r\nreturn enabled;\r\n}\r\nstatic int panel_detect(struct acx565akm_device *md)\r\n{\r\nacx565akm_read(md, MIPID_CMD_READ_DISP_ID, md->display_id, 3);\r\ndev_dbg(&md->spi->dev, "MIPI display ID: %02x%02x%02x\n",\r\nmd->display_id[0], md->display_id[1], md->display_id[2]);\r\nswitch (md->display_id[0]) {\r\ncase 0x10:\r\nmd->model = MIPID_VER_ACX565AKM;\r\nmd->name = "acx565akm";\r\nmd->has_bc = 1;\r\nmd->has_cabc = 1;\r\nbreak;\r\ncase 0x29:\r\nmd->model = MIPID_VER_L4F00311;\r\nmd->name = "l4f00311";\r\nbreak;\r\ncase 0x45:\r\nmd->model = MIPID_VER_LPH8923;\r\nmd->name = "lph8923";\r\nbreak;\r\ncase 0x83:\r\nmd->model = MIPID_VER_LS041Y3;\r\nmd->name = "ls041y3";\r\nbreak;\r\ndefault:\r\nmd->name = "unknown";\r\ndev_err(&md->spi->dev, "invalid display ID\n");\r\nreturn -ENODEV;\r\n}\r\nmd->revision = md->display_id[1];\r\ndev_info(&md->spi->dev, "omapfb: %s rev %02x LCD detected\n",\r\nmd->name, md->revision);\r\nreturn 0;\r\n}\r\nstatic void enable_backlight_ctrl(struct acx565akm_device *md, int enable)\r\n{\r\nu16 ctrl;\r\nacx565akm_read(md, MIPID_CMD_READ_CTRL_DISP, (u8 *)&ctrl, 1);\r\nif (enable) {\r\nctrl |= CTRL_DISP_BRIGHTNESS_CTRL_ON |\r\nCTRL_DISP_BACKLIGHT_ON;\r\n} else {\r\nctrl &= ~(CTRL_DISP_BRIGHTNESS_CTRL_ON |\r\nCTRL_DISP_BACKLIGHT_ON);\r\n}\r\nctrl |= 1 << 8;\r\nacx565akm_write(md, MIPID_CMD_WRITE_CTRL_DISP, (u8 *)&ctrl, 2);\r\n}\r\nstatic void set_cabc_mode(struct acx565akm_device *md, unsigned mode)\r\n{\r\nu16 cabc_ctrl;\r\nmd->cabc_mode = mode;\r\nif (!md->enabled)\r\nreturn;\r\ncabc_ctrl = 0;\r\nacx565akm_read(md, MIPID_CMD_READ_CABC, (u8 *)&cabc_ctrl, 1);\r\ncabc_ctrl &= ~3;\r\ncabc_ctrl |= (1 << 8) | (mode & 3);\r\nacx565akm_write(md, MIPID_CMD_WRITE_CABC, (u8 *)&cabc_ctrl, 2);\r\n}\r\nstatic unsigned get_cabc_mode(struct acx565akm_device *md)\r\n{\r\nreturn md->cabc_mode;\r\n}\r\nstatic unsigned get_hw_cabc_mode(struct acx565akm_device *md)\r\n{\r\nu8 cabc_ctrl;\r\nacx565akm_read(md, MIPID_CMD_READ_CABC, &cabc_ctrl, 1);\r\nreturn cabc_ctrl & 3;\r\n}\r\nstatic void acx565akm_set_brightness(struct acx565akm_device *md, int level)\r\n{\r\nint bv;\r\nbv = level | (1 << 8);\r\nacx565akm_write(md, MIPID_CMD_WRITE_DISP_BRIGHTNESS, (u8 *)&bv, 2);\r\nif (level)\r\nenable_backlight_ctrl(md, 1);\r\nelse\r\nenable_backlight_ctrl(md, 0);\r\n}\r\nstatic int acx565akm_get_actual_brightness(struct acx565akm_device *md)\r\n{\r\nu8 bv;\r\nacx565akm_read(md, MIPID_CMD_READ_DISP_BRIGHTNESS, &bv, 1);\r\nreturn bv;\r\n}\r\nstatic int acx565akm_bl_update_status(struct backlight_device *dev)\r\n{\r\nstruct acx565akm_device *md = dev_get_drvdata(&dev->dev);\r\nint r;\r\nint level;\r\ndev_dbg(&md->spi->dev, "%s\n", __func__);\r\nmutex_lock(&md->mutex);\r\nif (dev->props.fb_blank == FB_BLANK_UNBLANK &&\r\ndev->props.power == FB_BLANK_UNBLANK)\r\nlevel = dev->props.brightness;\r\nelse\r\nlevel = 0;\r\nr = 0;\r\nif (md->has_bc)\r\nacx565akm_set_brightness(md, level);\r\nelse if (md->dssdev->set_backlight)\r\nr = md->dssdev->set_backlight(md->dssdev, level);\r\nelse\r\nr = -ENODEV;\r\nmutex_unlock(&md->mutex);\r\nreturn r;\r\n}\r\nstatic int acx565akm_bl_get_intensity(struct backlight_device *dev)\r\n{\r\nstruct acx565akm_device *md = dev_get_drvdata(&dev->dev);\r\ndev_dbg(&dev->dev, "%s\n", __func__);\r\nif (!md->has_bc && md->dssdev->set_backlight == NULL)\r\nreturn -ENODEV;\r\nif (dev->props.fb_blank == FB_BLANK_UNBLANK &&\r\ndev->props.power == FB_BLANK_UNBLANK) {\r\nif (md->has_bc)\r\nreturn acx565akm_get_actual_brightness(md);\r\nelse\r\nreturn dev->props.brightness;\r\n}\r\nreturn 0;\r\n}\r\nstatic ssize_t show_cabc_mode(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct acx565akm_device *md = dev_get_drvdata(dev);\r\nconst char *mode_str;\r\nint mode;\r\nint len;\r\nif (!md->has_cabc)\r\nmode = 0;\r\nelse\r\nmode = get_cabc_mode(md);\r\nmode_str = "unknown";\r\nif (mode >= 0 && mode < ARRAY_SIZE(cabc_modes))\r\nmode_str = cabc_modes[mode];\r\nlen = snprintf(buf, PAGE_SIZE, "%s\n", mode_str);\r\nreturn len < PAGE_SIZE - 1 ? len : PAGE_SIZE - 1;\r\n}\r\nstatic ssize_t store_cabc_mode(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct acx565akm_device *md = dev_get_drvdata(dev);\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(cabc_modes); i++) {\r\nconst char *mode_str = cabc_modes[i];\r\nint cmp_len = strlen(mode_str);\r\nif (count > 0 && buf[count - 1] == '\n')\r\ncount--;\r\nif (count != cmp_len)\r\ncontinue;\r\nif (strncmp(buf, mode_str, cmp_len) == 0)\r\nbreak;\r\n}\r\nif (i == ARRAY_SIZE(cabc_modes))\r\nreturn -EINVAL;\r\nif (!md->has_cabc && i != 0)\r\nreturn -EINVAL;\r\nmutex_lock(&md->mutex);\r\nset_cabc_mode(md, i);\r\nmutex_unlock(&md->mutex);\r\nreturn count;\r\n}\r\nstatic ssize_t show_cabc_available_modes(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct acx565akm_device *md = dev_get_drvdata(dev);\r\nint len;\r\nint i;\r\nif (!md->has_cabc)\r\nreturn snprintf(buf, PAGE_SIZE, "%s\n", cabc_modes[0]);\r\nfor (i = 0, len = 0;\r\nlen < PAGE_SIZE && i < ARRAY_SIZE(cabc_modes); i++)\r\nlen += snprintf(&buf[len], PAGE_SIZE - len, "%s%s%s",\r\ni ? " " : "", cabc_modes[i],\r\ni == ARRAY_SIZE(cabc_modes) - 1 ? "\n" : "");\r\nreturn len < PAGE_SIZE ? len : PAGE_SIZE - 1;\r\n}\r\nstatic int acx_get_recommended_bpp(struct omap_dss_device *dssdev)\r\n{\r\nreturn 16;\r\n}\r\nstatic int acx_panel_probe(struct omap_dss_device *dssdev)\r\n{\r\nint r;\r\nstruct acx565akm_device *md = &acx_dev;\r\nstruct backlight_device *bldev;\r\nint max_brightness, brightness;\r\nstruct backlight_properties props;\r\ndev_dbg(&dssdev->dev, "%s\n", __func__);\r\ndssdev->panel.timings = acx_panel_timings;\r\nif (dssdev->platform_enable)\r\ndssdev->platform_enable(dssdev);\r\nmsleep(5);\r\nmd->enabled = panel_enabled(md);\r\nr = panel_detect(md);\r\nif (r) {\r\ndev_err(&dssdev->dev, "%s panel detect error\n", __func__);\r\nif (!md->enabled && dssdev->platform_disable)\r\ndssdev->platform_disable(dssdev);\r\nreturn r;\r\n}\r\nmutex_lock(&acx_dev.mutex);\r\nacx_dev.dssdev = dssdev;\r\nmutex_unlock(&acx_dev.mutex);\r\nif (!md->enabled) {\r\nif (dssdev->platform_disable)\r\ndssdev->platform_disable(dssdev);\r\n}\r\nmemset(&props, 0, sizeof(props));\r\nprops.fb_blank = FB_BLANK_UNBLANK;\r\nprops.power = FB_BLANK_UNBLANK;\r\nprops.type = BACKLIGHT_RAW;\r\nbldev = backlight_device_register("acx565akm", &md->spi->dev,\r\nmd, &acx565akm_bl_ops, &props);\r\nmd->bl_dev = bldev;\r\nif (md->has_cabc) {\r\nr = sysfs_create_group(&bldev->dev.kobj, &bldev_attr_group);\r\nif (r) {\r\ndev_err(&bldev->dev,\r\n"%s failed to create sysfs files\n", __func__);\r\nbacklight_device_unregister(bldev);\r\nreturn r;\r\n}\r\nmd->cabc_mode = get_hw_cabc_mode(md);\r\n}\r\nif (md->has_bc)\r\nmax_brightness = 255;\r\nelse\r\nmax_brightness = dssdev->max_backlight_level;\r\nif (md->has_bc)\r\nbrightness = acx565akm_get_actual_brightness(md);\r\nelse if (dssdev->get_backlight)\r\nbrightness = dssdev->get_backlight(dssdev);\r\nelse\r\nbrightness = 0;\r\nbldev->props.max_brightness = max_brightness;\r\nbldev->props.brightness = brightness;\r\nacx565akm_bl_update_status(bldev);\r\nreturn 0;\r\n}\r\nstatic void acx_panel_remove(struct omap_dss_device *dssdev)\r\n{\r\nstruct acx565akm_device *md = &acx_dev;\r\ndev_dbg(&dssdev->dev, "%s\n", __func__);\r\nsysfs_remove_group(&md->bl_dev->dev.kobj, &bldev_attr_group);\r\nbacklight_device_unregister(md->bl_dev);\r\nmutex_lock(&acx_dev.mutex);\r\nacx_dev.dssdev = NULL;\r\nmutex_unlock(&acx_dev.mutex);\r\n}\r\nstatic int acx_panel_power_on(struct omap_dss_device *dssdev)\r\n{\r\nstruct acx565akm_device *md = &acx_dev;\r\nint r;\r\ndev_dbg(&dssdev->dev, "%s\n", __func__);\r\nif (dssdev->state == OMAP_DSS_DISPLAY_ACTIVE)\r\nreturn 0;\r\nmutex_lock(&md->mutex);\r\nomapdss_sdi_set_timings(dssdev, &dssdev->panel.timings);\r\nomapdss_sdi_set_datapairs(dssdev, dssdev->phy.sdi.datapairs);\r\nr = omapdss_sdi_display_enable(dssdev);\r\nif (r) {\r\npr_err("%s sdi enable failed\n", __func__);\r\ngoto fail_unlock;\r\n}\r\nmsleep(50);\r\nif (dssdev->platform_enable) {\r\nr = dssdev->platform_enable(dssdev);\r\nif (r)\r\ngoto fail;\r\n}\r\nif (md->enabled) {\r\ndev_dbg(&md->spi->dev, "panel already enabled\n");\r\nmutex_unlock(&md->mutex);\r\nreturn 0;\r\n}\r\nmsleep(120);\r\nset_sleep_mode(md, 0);\r\nmd->enabled = 1;\r\nmsleep(5);\r\nset_display_state(md, 1);\r\nset_cabc_mode(md, md->cabc_mode);\r\nmutex_unlock(&md->mutex);\r\nreturn acx565akm_bl_update_status(md->bl_dev);\r\nfail:\r\nomapdss_sdi_display_disable(dssdev);\r\nfail_unlock:\r\nmutex_unlock(&md->mutex);\r\nreturn r;\r\n}\r\nstatic void acx_panel_power_off(struct omap_dss_device *dssdev)\r\n{\r\nstruct acx565akm_device *md = &acx_dev;\r\ndev_dbg(&dssdev->dev, "%s\n", __func__);\r\nif (dssdev->state != OMAP_DSS_DISPLAY_ACTIVE)\r\nreturn;\r\nmutex_lock(&md->mutex);\r\nif (!md->enabled) {\r\nmutex_unlock(&md->mutex);\r\nreturn;\r\n}\r\nset_display_state(md, 0);\r\nset_sleep_mode(md, 1);\r\nmd->enabled = 0;\r\nmsleep(50);\r\nif (dssdev->platform_disable)\r\ndssdev->platform_disable(dssdev);\r\nmsleep(100);\r\nomapdss_sdi_display_disable(dssdev);\r\nmutex_unlock(&md->mutex);\r\n}\r\nstatic int acx_panel_enable(struct omap_dss_device *dssdev)\r\n{\r\nint r;\r\ndev_dbg(&dssdev->dev, "%s\n", __func__);\r\nr = acx_panel_power_on(dssdev);\r\nif (r)\r\nreturn r;\r\ndssdev->state = OMAP_DSS_DISPLAY_ACTIVE;\r\nreturn 0;\r\n}\r\nstatic void acx_panel_disable(struct omap_dss_device *dssdev)\r\n{\r\ndev_dbg(&dssdev->dev, "%s\n", __func__);\r\nacx_panel_power_off(dssdev);\r\ndssdev->state = OMAP_DSS_DISPLAY_DISABLED;\r\n}\r\nstatic void acx_panel_set_timings(struct omap_dss_device *dssdev,\r\nstruct omap_video_timings *timings)\r\n{\r\nomapdss_sdi_set_timings(dssdev, timings);\r\ndssdev->panel.timings = *timings;\r\n}\r\nstatic int acx_panel_check_timings(struct omap_dss_device *dssdev,\r\nstruct omap_video_timings *timings)\r\n{\r\nreturn 0;\r\n}\r\nstatic int acx565akm_spi_probe(struct spi_device *spi)\r\n{\r\nstruct acx565akm_device *md = &acx_dev;\r\ndev_dbg(&spi->dev, "%s\n", __func__);\r\nspi->mode = SPI_MODE_3;\r\nmd->spi = spi;\r\nmutex_init(&md->mutex);\r\ndev_set_drvdata(&spi->dev, md);\r\nomap_dss_register_driver(&acx_panel_driver);\r\nreturn 0;\r\n}\r\nstatic int acx565akm_spi_remove(struct spi_device *spi)\r\n{\r\nstruct acx565akm_device *md = dev_get_drvdata(&spi->dev);\r\ndev_dbg(&md->spi->dev, "%s\n", __func__);\r\nomap_dss_unregister_driver(&acx_panel_driver);\r\nreturn 0;\r\n}
