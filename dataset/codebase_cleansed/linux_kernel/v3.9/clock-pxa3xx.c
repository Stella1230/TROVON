unsigned int pxa3xx_get_clk_frequency_khz(int info)\r\n{\r\nunsigned long acsr, xclkcfg;\r\nunsigned int t, xl, xn, hss, ro, XL, XN, CLK, HSS;\r\n__asm__ __volatile__("mrc\tp14, 0, %0, c6, c0, 0" : "=r"(xclkcfg));\r\nt = xclkcfg & 0x1;\r\nacsr = ACSR;\r\nxl = acsr & 0x1f;\r\nxn = (acsr >> 8) & 0x7;\r\nhss = (acsr >> 14) & 0x3;\r\nXL = xl * BASE_CLK;\r\nXN = xn * XL;\r\nro = acsr & ACCR_D0CS;\r\nCLK = (ro) ? RO_CLK : ((t) ? XN : XL);\r\nHSS = (ro) ? RO_CLK : hss_mult[hss] * BASE_CLK;\r\nif (info) {\r\npr_info("RO Mode clock: %d.%02dMHz (%sactive)\n",\r\nRO_CLK / 1000000, (RO_CLK % 1000000) / 10000,\r\n(ro) ? "" : "in");\r\npr_info("Run Mode clock: %d.%02dMHz (*%d)\n",\r\nXL / 1000000, (XL % 1000000) / 10000, xl);\r\npr_info("Turbo Mode clock: %d.%02dMHz (*%d, %sactive)\n",\r\nXN / 1000000, (XN % 1000000) / 10000, xn,\r\n(t) ? "" : "in");\r\npr_info("HSIO bus clock: %d.%02dMHz\n",\r\nHSS / 1000000, (HSS % 1000000) / 10000);\r\n}\r\nreturn CLK / 1000;\r\n}\r\nstatic unsigned long clk_pxa3xx_ac97_getrate(struct clk *clk)\r\n{\r\nunsigned long rate = 312000000;\r\nunsigned long ac97_div;\r\nac97_div = AC97_DIV;\r\nrate /= (ac97_div >> 12) & 0x7fff;\r\nrate *= (ac97_div & 0xfff);\r\nreturn rate;\r\n}\r\nstatic unsigned long clk_pxa3xx_hsio_getrate(struct clk *clk)\r\n{\r\nunsigned long acsr;\r\nunsigned int hss, hsio_clk;\r\nacsr = ACSR;\r\nhss = (acsr >> 14) & 0x3;\r\nhsio_clk = (acsr & ACCR_D0CS) ? RO_CLK : hss_mult[hss] * BASE_CLK;\r\nreturn hsio_clk;\r\n}\r\nstatic unsigned long clk_pxa3xx_smemc_getrate(struct clk *clk)\r\n{\r\nunsigned long acsr = ACSR;\r\nunsigned long memclkcfg = __raw_readl(MEMCLKCFG);\r\nreturn BASE_CLK * smcfs_mult[(acsr >> 23) & 0x7] /\r\ndf_clkdiv[(memclkcfg >> 16) & 0x3];\r\n}\r\nvoid clk_pxa3xx_cken_enable(struct clk *clk)\r\n{\r\nunsigned long mask = 1ul << (clk->cken & 0x1f);\r\nif (clk->cken < 32)\r\nCKENA |= mask;\r\nelse if (clk->cken < 64)\r\nCKENB |= mask;\r\nelse\r\nCKENC |= mask;\r\n}\r\nvoid clk_pxa3xx_cken_disable(struct clk *clk)\r\n{\r\nunsigned long mask = 1ul << (clk->cken & 0x1f);\r\nif (clk->cken < 32)\r\nCKENA &= ~mask;\r\nelse if (clk->cken < 64)\r\nCKENB &= ~mask;\r\nelse\r\nCKENC &= ~mask;\r\n}\r\nstatic void clk_pout_enable(struct clk *clk)\r\n{\r\nOSCC |= OSCC_PEN;\r\n}\r\nstatic void clk_pout_disable(struct clk *clk)\r\n{\r\nOSCC &= ~OSCC_PEN;\r\n}\r\nstatic int pxa3xx_clock_suspend(void)\r\n{\r\ncken[0] = CKENA;\r\ncken[1] = CKENB;\r\naccr = ACCR;\r\nreturn 0;\r\n}\r\nstatic void pxa3xx_clock_resume(void)\r\n{\r\nACCR = accr;\r\nCKENA = cken[0];\r\nCKENB = cken[1];\r\n}
