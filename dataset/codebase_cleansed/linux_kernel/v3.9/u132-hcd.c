static inline struct u132 *udev_to_u132(struct u132_udev *udev)\r\n{\r\nu8 udev_number = udev->udev_number;\r\nreturn container_of(udev, struct u132, udev[udev_number]);\r\n}\r\nstatic inline struct u132 *hcd_to_u132(struct usb_hcd *hcd)\r\n{\r\nreturn (struct u132 *)(hcd->hcd_priv);\r\n}\r\nstatic inline struct usb_hcd *u132_to_hcd(struct u132 *u132)\r\n{\r\nreturn container_of((void *)u132, struct usb_hcd, hcd_priv);\r\n}\r\nstatic inline void u132_disable(struct u132 *u132)\r\n{\r\nu132_to_hcd(u132)->state = HC_STATE_HALT;\r\n}\r\nstatic void u132_hcd_delete(struct kref *kref)\r\n{\r\nstruct u132 *u132 = kref_to_u132(kref);\r\nstruct platform_device *pdev = u132->platform_dev;\r\nstruct usb_hcd *hcd = u132_to_hcd(u132);\r\nu132->going += 1;\r\nmutex_lock(&u132_module_lock);\r\nlist_del_init(&u132->u132_list);\r\nu132_instances -= 1;\r\nmutex_unlock(&u132_module_lock);\r\ndev_warn(&u132->platform_dev->dev, "FREEING the hcd=%p and thus the u13"\r\n"2=%p going=%d pdev=%p\n", hcd, u132, u132->going, pdev);\r\nusb_put_hcd(hcd);\r\n}\r\nstatic inline void u132_u132_put_kref(struct u132 *u132)\r\n{\r\nkref_put(&u132->kref, u132_hcd_delete);\r\n}\r\nstatic inline void u132_u132_init_kref(struct u132 *u132)\r\n{\r\nkref_init(&u132->kref);\r\n}\r\nstatic void u132_udev_delete(struct kref *kref)\r\n{\r\nstruct u132_udev *udev = kref_to_u132_udev(kref);\r\nudev->udev_number = 0;\r\nudev->usb_device = NULL;\r\nudev->usb_addr = 0;\r\nudev->enumeration = 0;\r\n}\r\nstatic inline void u132_udev_put_kref(struct u132 *u132, struct u132_udev *udev)\r\n{\r\nkref_put(&udev->kref, u132_udev_delete);\r\n}\r\nstatic inline void u132_udev_get_kref(struct u132 *u132, struct u132_udev *udev)\r\n{\r\nkref_get(&udev->kref);\r\n}\r\nstatic inline void u132_udev_init_kref(struct u132 *u132,\r\nstruct u132_udev *udev)\r\n{\r\nkref_init(&udev->kref);\r\n}\r\nstatic inline void u132_ring_put_kref(struct u132 *u132, struct u132_ring *ring)\r\n{\r\nkref_put(&u132->kref, u132_hcd_delete);\r\n}\r\nstatic void u132_ring_requeue_work(struct u132 *u132, struct u132_ring *ring,\r\nunsigned int delta)\r\n{\r\nif (delta > 0) {\r\nif (queue_delayed_work(workqueue, &ring->scheduler, delta))\r\nreturn;\r\n} else if (queue_delayed_work(workqueue, &ring->scheduler, 0))\r\nreturn;\r\nkref_put(&u132->kref, u132_hcd_delete);\r\n}\r\nstatic void u132_ring_queue_work(struct u132 *u132, struct u132_ring *ring,\r\nunsigned int delta)\r\n{\r\nkref_get(&u132->kref);\r\nu132_ring_requeue_work(u132, ring, delta);\r\n}\r\nstatic void u132_ring_cancel_work(struct u132 *u132, struct u132_ring *ring)\r\n{\r\nif (cancel_delayed_work(&ring->scheduler))\r\nkref_put(&u132->kref, u132_hcd_delete);\r\n}\r\nstatic void u132_endp_delete(struct kref *kref)\r\n{\r\nstruct u132_endp *endp = kref_to_u132_endp(kref);\r\nstruct u132 *u132 = endp->u132;\r\nu8 usb_addr = endp->usb_addr;\r\nu8 usb_endp = endp->usb_endp;\r\nu8 address = u132->addr[usb_addr].address;\r\nstruct u132_udev *udev = &u132->udev[address];\r\nu8 endp_number = endp->endp_number;\r\nstruct usb_host_endpoint *hep = endp->hep;\r\nstruct u132_ring *ring = endp->ring;\r\nstruct list_head *head = &endp->endp_ring;\r\nring->length -= 1;\r\nif (endp == ring->curr_endp) {\r\nif (list_empty(head)) {\r\nring->curr_endp = NULL;\r\nlist_del(head);\r\n} else {\r\nstruct u132_endp *next_endp = list_entry(head->next,\r\nstruct u132_endp, endp_ring);\r\nring->curr_endp = next_endp;\r\nlist_del(head);\r\n}\r\n} else\r\nlist_del(head);\r\nif (endp->input) {\r\nudev->endp_number_in[usb_endp] = 0;\r\nu132_udev_put_kref(u132, udev);\r\n}\r\nif (endp->output) {\r\nudev->endp_number_out[usb_endp] = 0;\r\nu132_udev_put_kref(u132, udev);\r\n}\r\nu132->endp[endp_number - 1] = NULL;\r\nhep->hcpriv = NULL;\r\nkfree(endp);\r\nu132_u132_put_kref(u132);\r\n}\r\nstatic inline void u132_endp_put_kref(struct u132 *u132, struct u132_endp *endp)\r\n{\r\nkref_put(&endp->kref, u132_endp_delete);\r\n}\r\nstatic inline void u132_endp_get_kref(struct u132 *u132, struct u132_endp *endp)\r\n{\r\nkref_get(&endp->kref);\r\n}\r\nstatic inline void u132_endp_init_kref(struct u132 *u132,\r\nstruct u132_endp *endp)\r\n{\r\nkref_init(&endp->kref);\r\nkref_get(&u132->kref);\r\n}\r\nstatic void u132_endp_queue_work(struct u132 *u132, struct u132_endp *endp,\r\nunsigned int delta)\r\n{\r\nif (queue_delayed_work(workqueue, &endp->scheduler, delta))\r\nkref_get(&endp->kref);\r\n}\r\nstatic void u132_endp_cancel_work(struct u132 *u132, struct u132_endp *endp)\r\n{\r\nif (cancel_delayed_work(&endp->scheduler))\r\nkref_put(&endp->kref, u132_endp_delete);\r\n}\r\nstatic inline void u132_monitor_put_kref(struct u132 *u132)\r\n{\r\nkref_put(&u132->kref, u132_hcd_delete);\r\n}\r\nstatic void u132_monitor_queue_work(struct u132 *u132, unsigned int delta)\r\n{\r\nif (queue_delayed_work(workqueue, &u132->monitor, delta))\r\nkref_get(&u132->kref);\r\n}\r\nstatic void u132_monitor_requeue_work(struct u132 *u132, unsigned int delta)\r\n{\r\nif (!queue_delayed_work(workqueue, &u132->monitor, delta))\r\nkref_put(&u132->kref, u132_hcd_delete);\r\n}\r\nstatic void u132_monitor_cancel_work(struct u132 *u132)\r\n{\r\nif (cancel_delayed_work(&u132->monitor))\r\nkref_put(&u132->kref, u132_hcd_delete);\r\n}\r\nstatic int read_roothub_info(struct u132 *u132)\r\n{\r\nu32 revision;\r\nint retval;\r\nretval = u132_read_pcimem(u132, revision, &revision);\r\nif (retval) {\r\ndev_err(&u132->platform_dev->dev, "error %d accessing device co"\r\n"ntrol\n", retval);\r\nreturn retval;\r\n} else if ((revision & 0xFF) == 0x10) {\r\n} else if ((revision & 0xFF) == 0x11) {\r\n} else {\r\ndev_err(&u132->platform_dev->dev, "device revision is not valid"\r\n" %08X\n", revision);\r\nreturn -ENODEV;\r\n}\r\nretval = u132_read_pcimem(u132, control, &u132->hc_control);\r\nif (retval) {\r\ndev_err(&u132->platform_dev->dev, "error %d accessing device co"\r\n"ntrol\n", retval);\r\nreturn retval;\r\n}\r\nretval = u132_read_pcimem(u132, roothub.status,\r\n&u132->hc_roothub_status);\r\nif (retval) {\r\ndev_err(&u132->platform_dev->dev, "error %d accessing device re"\r\n"g roothub.status\n", retval);\r\nreturn retval;\r\n}\r\nretval = u132_read_pcimem(u132, roothub.a, &u132->hc_roothub_a);\r\nif (retval) {\r\ndev_err(&u132->platform_dev->dev, "error %d accessing device re"\r\n"g roothub.a\n", retval);\r\nreturn retval;\r\n}\r\n{\r\nint I = u132->num_ports;\r\nint i = 0;\r\nwhile (I-- > 0) {\r\nretval = u132_read_pcimem(u132, roothub.portstatus[i],\r\n&u132->hc_roothub_portstatus[i]);\r\nif (retval) {\r\ndev_err(&u132->platform_dev->dev, "error %d acc"\r\n"essing device roothub.portstatus[%d]\n"\r\n, retval, i);\r\nreturn retval;\r\n} else\r\ni += 1;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void u132_hcd_monitor_work(struct work_struct *work)\r\n{\r\nstruct u132 *u132 = container_of(work, struct u132, monitor.work);\r\nif (u132->going > 1) {\r\ndev_err(&u132->platform_dev->dev, "device has been removed %d\n"\r\n, u132->going);\r\nu132_monitor_put_kref(u132);\r\nreturn;\r\n} else if (u132->going > 0) {\r\ndev_err(&u132->platform_dev->dev, "device is being removed\n");\r\nu132_monitor_put_kref(u132);\r\nreturn;\r\n} else {\r\nint retval;\r\nmutex_lock(&u132->sw_lock);\r\nretval = read_roothub_info(u132);\r\nif (retval) {\r\nstruct usb_hcd *hcd = u132_to_hcd(u132);\r\nu132_disable(u132);\r\nu132->going = 1;\r\nmutex_unlock(&u132->sw_lock);\r\nusb_hc_died(hcd);\r\nftdi_elan_gone_away(u132->platform_dev);\r\nu132_monitor_put_kref(u132);\r\nreturn;\r\n} else {\r\nu132_monitor_requeue_work(u132, 500);\r\nmutex_unlock(&u132->sw_lock);\r\nreturn;\r\n}\r\n}\r\n}\r\nstatic void u132_hcd_giveback_urb(struct u132 *u132, struct u132_endp *endp,\r\nstruct urb *urb, int status)\r\n{\r\nstruct u132_ring *ring;\r\nunsigned long irqs;\r\nstruct usb_hcd *hcd = u132_to_hcd(u132);\r\nurb->error_count = 0;\r\nspin_lock_irqsave(&endp->queue_lock.slock, irqs);\r\nusb_hcd_unlink_urb_from_ep(hcd, urb);\r\nendp->queue_next += 1;\r\nif (ENDP_QUEUE_SIZE > --endp->queue_size) {\r\nendp->active = 0;\r\nspin_unlock_irqrestore(&endp->queue_lock.slock, irqs);\r\n} else {\r\nstruct list_head *next = endp->urb_more.next;\r\nstruct u132_urbq *urbq = list_entry(next, struct u132_urbq,\r\nurb_more);\r\nlist_del(next);\r\nendp->urb_list[ENDP_QUEUE_MASK & endp->queue_last++] =\r\nurbq->urb;\r\nendp->active = 0;\r\nspin_unlock_irqrestore(&endp->queue_lock.slock, irqs);\r\nkfree(urbq);\r\n}\r\nmutex_lock(&u132->scheduler_lock);\r\nring = endp->ring;\r\nring->in_use = 0;\r\nu132_ring_cancel_work(u132, ring);\r\nu132_ring_queue_work(u132, ring, 0);\r\nmutex_unlock(&u132->scheduler_lock);\r\nu132_endp_put_kref(u132, endp);\r\nusb_hcd_giveback_urb(hcd, urb, status);\r\n}\r\nstatic void u132_hcd_forget_urb(struct u132 *u132, struct u132_endp *endp,\r\nstruct urb *urb, int status)\r\n{\r\nu132_endp_put_kref(u132, endp);\r\n}\r\nstatic void u132_hcd_abandon_urb(struct u132 *u132, struct u132_endp *endp,\r\nstruct urb *urb, int status)\r\n{\r\nunsigned long irqs;\r\nstruct usb_hcd *hcd = u132_to_hcd(u132);\r\nurb->error_count = 0;\r\nspin_lock_irqsave(&endp->queue_lock.slock, irqs);\r\nusb_hcd_unlink_urb_from_ep(hcd, urb);\r\nendp->queue_next += 1;\r\nif (ENDP_QUEUE_SIZE > --endp->queue_size) {\r\nendp->active = 0;\r\nspin_unlock_irqrestore(&endp->queue_lock.slock, irqs);\r\n} else {\r\nstruct list_head *next = endp->urb_more.next;\r\nstruct u132_urbq *urbq = list_entry(next, struct u132_urbq,\r\nurb_more);\r\nlist_del(next);\r\nendp->urb_list[ENDP_QUEUE_MASK & endp->queue_last++] =\r\nurbq->urb;\r\nendp->active = 0;\r\nspin_unlock_irqrestore(&endp->queue_lock.slock, irqs);\r\nkfree(urbq);\r\n}\r\nusb_hcd_giveback_urb(hcd, urb, status);\r\n}\r\nstatic inline int edset_input(struct u132 *u132, struct u132_ring *ring,\r\nstruct u132_endp *endp, struct urb *urb, u8 address, u8 toggle_bits,\r\nvoid (*callback) (void *endp, struct urb *urb, u8 *buf, int len,\r\nint toggle_bits, int error_count, int condition_code, int repeat_number,\r\nint halted, int skipped, int actual, int non_null))\r\n{\r\nreturn usb_ftdi_elan_edset_input(u132->platform_dev, ring->number, endp,\r\nurb, address, endp->usb_endp, toggle_bits, callback);\r\n}\r\nstatic inline int edset_setup(struct u132 *u132, struct u132_ring *ring,\r\nstruct u132_endp *endp, struct urb *urb, u8 address, u8 toggle_bits,\r\nvoid (*callback) (void *endp, struct urb *urb, u8 *buf, int len,\r\nint toggle_bits, int error_count, int condition_code, int repeat_number,\r\nint halted, int skipped, int actual, int non_null))\r\n{\r\nreturn usb_ftdi_elan_edset_setup(u132->platform_dev, ring->number, endp,\r\nurb, address, endp->usb_endp, toggle_bits, callback);\r\n}\r\nstatic inline int edset_single(struct u132 *u132, struct u132_ring *ring,\r\nstruct u132_endp *endp, struct urb *urb, u8 address, u8 toggle_bits,\r\nvoid (*callback) (void *endp, struct urb *urb, u8 *buf, int len,\r\nint toggle_bits, int error_count, int condition_code, int repeat_number,\r\nint halted, int skipped, int actual, int non_null))\r\n{\r\nreturn usb_ftdi_elan_edset_single(u132->platform_dev, ring->number,\r\nendp, urb, address, endp->usb_endp, toggle_bits, callback);\r\n}\r\nstatic inline int edset_output(struct u132 *u132, struct u132_ring *ring,\r\nstruct u132_endp *endp, struct urb *urb, u8 address, u8 toggle_bits,\r\nvoid (*callback) (void *endp, struct urb *urb, u8 *buf, int len,\r\nint toggle_bits, int error_count, int condition_code, int repeat_number,\r\nint halted, int skipped, int actual, int non_null))\r\n{\r\nreturn usb_ftdi_elan_edset_output(u132->platform_dev, ring->number,\r\nendp, urb, address, endp->usb_endp, toggle_bits, callback);\r\n}\r\nstatic void u132_hcd_interrupt_recv(void *data, struct urb *urb, u8 *buf,\r\nint len, int toggle_bits, int error_count, int condition_code,\r\nint repeat_number, int halted, int skipped, int actual, int non_null)\r\n{\r\nstruct u132_endp *endp = data;\r\nstruct u132 *u132 = endp->u132;\r\nu8 address = u132->addr[endp->usb_addr].address;\r\nstruct u132_udev *udev = &u132->udev[address];\r\nmutex_lock(&u132->scheduler_lock);\r\nif (u132->going > 1) {\r\ndev_err(&u132->platform_dev->dev, "device has been removed %d\n"\r\n, u132->going);\r\nmutex_unlock(&u132->scheduler_lock);\r\nu132_hcd_forget_urb(u132, endp, urb, -ENODEV);\r\nreturn;\r\n} else if (endp->dequeueing) {\r\nendp->dequeueing = 0;\r\nmutex_unlock(&u132->scheduler_lock);\r\nu132_hcd_giveback_urb(u132, endp, urb, -EINTR);\r\nreturn;\r\n} else if (u132->going > 0) {\r\ndev_err(&u132->platform_dev->dev, "device is being removed "\r\n"urb=%p\n", urb);\r\nmutex_unlock(&u132->scheduler_lock);\r\nu132_hcd_giveback_urb(u132, endp, urb, -ENODEV);\r\nreturn;\r\n} else if (!urb->unlinked) {\r\nstruct u132_ring *ring = endp->ring;\r\nu8 *u = urb->transfer_buffer + urb->actual_length;\r\nu8 *b = buf;\r\nint L = len;\r\nwhile (L-- > 0)\r\n*u++ = *b++;\r\nurb->actual_length += len;\r\nif ((condition_code == TD_CC_NOERROR) &&\r\n(urb->transfer_buffer_length > urb->actual_length)) {\r\nendp->toggle_bits = toggle_bits;\r\nusb_settoggle(udev->usb_device, endp->usb_endp, 0,\r\n1 & toggle_bits);\r\nif (urb->actual_length > 0) {\r\nint retval;\r\nmutex_unlock(&u132->scheduler_lock);\r\nretval = edset_single(u132, ring, endp, urb,\r\naddress, endp->toggle_bits,\r\nu132_hcd_interrupt_recv);\r\nif (retval != 0)\r\nu132_hcd_giveback_urb(u132, endp, urb,\r\nretval);\r\n} else {\r\nring->in_use = 0;\r\nendp->active = 0;\r\nendp->jiffies = jiffies +\r\nmsecs_to_jiffies(urb->interval);\r\nu132_ring_cancel_work(u132, ring);\r\nu132_ring_queue_work(u132, ring, 0);\r\nmutex_unlock(&u132->scheduler_lock);\r\nu132_endp_put_kref(u132, endp);\r\n}\r\nreturn;\r\n} else if ((condition_code == TD_DATAUNDERRUN) &&\r\n((urb->transfer_flags & URB_SHORT_NOT_OK) == 0)) {\r\nendp->toggle_bits = toggle_bits;\r\nusb_settoggle(udev->usb_device, endp->usb_endp, 0,\r\n1 & toggle_bits);\r\nmutex_unlock(&u132->scheduler_lock);\r\nu132_hcd_giveback_urb(u132, endp, urb, 0);\r\nreturn;\r\n} else {\r\nif (condition_code == TD_CC_NOERROR) {\r\nendp->toggle_bits = toggle_bits;\r\nusb_settoggle(udev->usb_device, endp->usb_endp,\r\n0, 1 & toggle_bits);\r\n} else if (condition_code == TD_CC_STALL) {\r\nendp->toggle_bits = 0x2;\r\nusb_settoggle(udev->usb_device, endp->usb_endp,\r\n0, 0);\r\n} else {\r\nendp->toggle_bits = 0x2;\r\nusb_settoggle(udev->usb_device, endp->usb_endp,\r\n0, 0);\r\ndev_err(&u132->platform_dev->dev, "urb=%p givin"\r\n"g back INTERRUPT %s\n", urb,\r\ncc_to_text[condition_code]);\r\n}\r\nmutex_unlock(&u132->scheduler_lock);\r\nu132_hcd_giveback_urb(u132, endp, urb,\r\ncc_to_error[condition_code]);\r\nreturn;\r\n}\r\n} else {\r\ndev_err(&u132->platform_dev->dev, "CALLBACK called urb=%p "\r\n"unlinked=%d\n", urb, urb->unlinked);\r\nmutex_unlock(&u132->scheduler_lock);\r\nu132_hcd_giveback_urb(u132, endp, urb, 0);\r\nreturn;\r\n}\r\n}\r\nstatic void u132_hcd_bulk_output_sent(void *data, struct urb *urb, u8 *buf,\r\nint len, int toggle_bits, int error_count, int condition_code,\r\nint repeat_number, int halted, int skipped, int actual, int non_null)\r\n{\r\nstruct u132_endp *endp = data;\r\nstruct u132 *u132 = endp->u132;\r\nu8 address = u132->addr[endp->usb_addr].address;\r\nmutex_lock(&u132->scheduler_lock);\r\nif (u132->going > 1) {\r\ndev_err(&u132->platform_dev->dev, "device has been removed %d\n"\r\n, u132->going);\r\nmutex_unlock(&u132->scheduler_lock);\r\nu132_hcd_forget_urb(u132, endp, urb, -ENODEV);\r\nreturn;\r\n} else if (endp->dequeueing) {\r\nendp->dequeueing = 0;\r\nmutex_unlock(&u132->scheduler_lock);\r\nu132_hcd_giveback_urb(u132, endp, urb, -EINTR);\r\nreturn;\r\n} else if (u132->going > 0) {\r\ndev_err(&u132->platform_dev->dev, "device is being removed "\r\n"urb=%p\n", urb);\r\nmutex_unlock(&u132->scheduler_lock);\r\nu132_hcd_giveback_urb(u132, endp, urb, -ENODEV);\r\nreturn;\r\n} else if (!urb->unlinked) {\r\nstruct u132_ring *ring = endp->ring;\r\nurb->actual_length += len;\r\nendp->toggle_bits = toggle_bits;\r\nif (urb->transfer_buffer_length > urb->actual_length) {\r\nint retval;\r\nmutex_unlock(&u132->scheduler_lock);\r\nretval = edset_output(u132, ring, endp, urb, address,\r\nendp->toggle_bits, u132_hcd_bulk_output_sent);\r\nif (retval != 0)\r\nu132_hcd_giveback_urb(u132, endp, urb, retval);\r\nreturn;\r\n} else {\r\nmutex_unlock(&u132->scheduler_lock);\r\nu132_hcd_giveback_urb(u132, endp, urb, 0);\r\nreturn;\r\n}\r\n} else {\r\ndev_err(&u132->platform_dev->dev, "CALLBACK called urb=%p "\r\n"unlinked=%d\n", urb, urb->unlinked);\r\nmutex_unlock(&u132->scheduler_lock);\r\nu132_hcd_giveback_urb(u132, endp, urb, 0);\r\nreturn;\r\n}\r\n}\r\nstatic void u132_hcd_bulk_input_recv(void *data, struct urb *urb, u8 *buf,\r\nint len, int toggle_bits, int error_count, int condition_code,\r\nint repeat_number, int halted, int skipped, int actual, int non_null)\r\n{\r\nstruct u132_endp *endp = data;\r\nstruct u132 *u132 = endp->u132;\r\nu8 address = u132->addr[endp->usb_addr].address;\r\nstruct u132_udev *udev = &u132->udev[address];\r\nmutex_lock(&u132->scheduler_lock);\r\nif (u132->going > 1) {\r\ndev_err(&u132->platform_dev->dev, "device has been removed %d\n"\r\n, u132->going);\r\nmutex_unlock(&u132->scheduler_lock);\r\nu132_hcd_forget_urb(u132, endp, urb, -ENODEV);\r\nreturn;\r\n} else if (endp->dequeueing) {\r\nendp->dequeueing = 0;\r\nmutex_unlock(&u132->scheduler_lock);\r\nu132_hcd_giveback_urb(u132, endp, urb, -EINTR);\r\nreturn;\r\n} else if (u132->going > 0) {\r\ndev_err(&u132->platform_dev->dev, "device is being removed "\r\n"urb=%p\n", urb);\r\nmutex_unlock(&u132->scheduler_lock);\r\nu132_hcd_giveback_urb(u132, endp, urb, -ENODEV);\r\nreturn;\r\n} else if (!urb->unlinked) {\r\nstruct u132_ring *ring = endp->ring;\r\nu8 *u = urb->transfer_buffer + urb->actual_length;\r\nu8 *b = buf;\r\nint L = len;\r\nwhile (L-- > 0)\r\n*u++ = *b++;\r\nurb->actual_length += len;\r\nif ((condition_code == TD_CC_NOERROR) &&\r\n(urb->transfer_buffer_length > urb->actual_length)) {\r\nint retval;\r\nendp->toggle_bits = toggle_bits;\r\nusb_settoggle(udev->usb_device, endp->usb_endp, 0,\r\n1 & toggle_bits);\r\nmutex_unlock(&u132->scheduler_lock);\r\nretval = usb_ftdi_elan_edset_input(u132->platform_dev,\r\nring->number, endp, urb, address,\r\nendp->usb_endp, endp->toggle_bits,\r\nu132_hcd_bulk_input_recv);\r\nif (retval != 0)\r\nu132_hcd_giveback_urb(u132, endp, urb, retval);\r\nreturn;\r\n} else if (condition_code == TD_CC_NOERROR) {\r\nendp->toggle_bits = toggle_bits;\r\nusb_settoggle(udev->usb_device, endp->usb_endp, 0,\r\n1 & toggle_bits);\r\nmutex_unlock(&u132->scheduler_lock);\r\nu132_hcd_giveback_urb(u132, endp, urb,\r\ncc_to_error[condition_code]);\r\nreturn;\r\n} else if ((condition_code == TD_DATAUNDERRUN) &&\r\n((urb->transfer_flags & URB_SHORT_NOT_OK) == 0)) {\r\nendp->toggle_bits = toggle_bits;\r\nusb_settoggle(udev->usb_device, endp->usb_endp, 0,\r\n1 & toggle_bits);\r\nmutex_unlock(&u132->scheduler_lock);\r\nu132_hcd_giveback_urb(u132, endp, urb, 0);\r\nreturn;\r\n} else if (condition_code == TD_DATAUNDERRUN) {\r\nendp->toggle_bits = toggle_bits;\r\nusb_settoggle(udev->usb_device, endp->usb_endp, 0,\r\n1 & toggle_bits);\r\ndev_warn(&u132->platform_dev->dev, "urb=%p(SHORT NOT OK"\r\n") giving back BULK IN %s\n", urb,\r\ncc_to_text[condition_code]);\r\nmutex_unlock(&u132->scheduler_lock);\r\nu132_hcd_giveback_urb(u132, endp, urb, 0);\r\nreturn;\r\n} else if (condition_code == TD_CC_STALL) {\r\nendp->toggle_bits = 0x2;\r\nusb_settoggle(udev->usb_device, endp->usb_endp, 0, 0);\r\nmutex_unlock(&u132->scheduler_lock);\r\nu132_hcd_giveback_urb(u132, endp, urb,\r\ncc_to_error[condition_code]);\r\nreturn;\r\n} else {\r\nendp->toggle_bits = 0x2;\r\nusb_settoggle(udev->usb_device, endp->usb_endp, 0, 0);\r\ndev_err(&u132->platform_dev->dev, "urb=%p giving back B"\r\n"ULK IN code=%d %s\n", urb, condition_code,\r\ncc_to_text[condition_code]);\r\nmutex_unlock(&u132->scheduler_lock);\r\nu132_hcd_giveback_urb(u132, endp, urb,\r\ncc_to_error[condition_code]);\r\nreturn;\r\n}\r\n} else {\r\ndev_err(&u132->platform_dev->dev, "CALLBACK called urb=%p "\r\n"unlinked=%d\n", urb, urb->unlinked);\r\nmutex_unlock(&u132->scheduler_lock);\r\nu132_hcd_giveback_urb(u132, endp, urb, 0);\r\nreturn;\r\n}\r\n}\r\nstatic void u132_hcd_configure_empty_sent(void *data, struct urb *urb, u8 *buf,\r\nint len, int toggle_bits, int error_count, int condition_code,\r\nint repeat_number, int halted, int skipped, int actual, int non_null)\r\n{\r\nstruct u132_endp *endp = data;\r\nstruct u132 *u132 = endp->u132;\r\nmutex_lock(&u132->scheduler_lock);\r\nif (u132->going > 1) {\r\ndev_err(&u132->platform_dev->dev, "device has been removed %d\n"\r\n, u132->going);\r\nmutex_unlock(&u132->scheduler_lock);\r\nu132_hcd_forget_urb(u132, endp, urb, -ENODEV);\r\nreturn;\r\n} else if (endp->dequeueing) {\r\nendp->dequeueing = 0;\r\nmutex_unlock(&u132->scheduler_lock);\r\nu132_hcd_giveback_urb(u132, endp, urb, -EINTR);\r\nreturn;\r\n} else if (u132->going > 0) {\r\ndev_err(&u132->platform_dev->dev, "device is being removed "\r\n"urb=%p\n", urb);\r\nmutex_unlock(&u132->scheduler_lock);\r\nu132_hcd_giveback_urb(u132, endp, urb, -ENODEV);\r\nreturn;\r\n} else if (!urb->unlinked) {\r\nmutex_unlock(&u132->scheduler_lock);\r\nu132_hcd_giveback_urb(u132, endp, urb, 0);\r\nreturn;\r\n} else {\r\ndev_err(&u132->platform_dev->dev, "CALLBACK called urb=%p "\r\n"unlinked=%d\n", urb, urb->unlinked);\r\nmutex_unlock(&u132->scheduler_lock);\r\nu132_hcd_giveback_urb(u132, endp, urb, 0);\r\nreturn;\r\n}\r\n}\r\nstatic void u132_hcd_configure_input_recv(void *data, struct urb *urb, u8 *buf,\r\nint len, int toggle_bits, int error_count, int condition_code,\r\nint repeat_number, int halted, int skipped, int actual, int non_null)\r\n{\r\nstruct u132_endp *endp = data;\r\nstruct u132 *u132 = endp->u132;\r\nu8 address = u132->addr[endp->usb_addr].address;\r\nmutex_lock(&u132->scheduler_lock);\r\nif (u132->going > 1) {\r\ndev_err(&u132->platform_dev->dev, "device has been removed %d\n"\r\n, u132->going);\r\nmutex_unlock(&u132->scheduler_lock);\r\nu132_hcd_forget_urb(u132, endp, urb, -ENODEV);\r\nreturn;\r\n} else if (endp->dequeueing) {\r\nendp->dequeueing = 0;\r\nmutex_unlock(&u132->scheduler_lock);\r\nu132_hcd_giveback_urb(u132, endp, urb, -EINTR);\r\nreturn;\r\n} else if (u132->going > 0) {\r\ndev_err(&u132->platform_dev->dev, "device is being removed "\r\n"urb=%p\n", urb);\r\nmutex_unlock(&u132->scheduler_lock);\r\nu132_hcd_giveback_urb(u132, endp, urb, -ENODEV);\r\nreturn;\r\n} else if (!urb->unlinked) {\r\nstruct u132_ring *ring = endp->ring;\r\nu8 *u = urb->transfer_buffer;\r\nu8 *b = buf;\r\nint L = len;\r\nwhile (L-- > 0)\r\n*u++ = *b++;\r\nurb->actual_length = len;\r\nif ((condition_code == TD_CC_NOERROR) || ((condition_code ==\r\nTD_DATAUNDERRUN) && ((urb->transfer_flags &\r\nURB_SHORT_NOT_OK) == 0))) {\r\nint retval;\r\nmutex_unlock(&u132->scheduler_lock);\r\nretval = usb_ftdi_elan_edset_empty(u132->platform_dev,\r\nring->number, endp, urb, address,\r\nendp->usb_endp, 0x3,\r\nu132_hcd_configure_empty_sent);\r\nif (retval != 0)\r\nu132_hcd_giveback_urb(u132, endp, urb, retval);\r\nreturn;\r\n} else if (condition_code == TD_CC_STALL) {\r\nmutex_unlock(&u132->scheduler_lock);\r\ndev_warn(&u132->platform_dev->dev, "giving back SETUP I"\r\n"NPUT STALL urb %p\n", urb);\r\nu132_hcd_giveback_urb(u132, endp, urb,\r\ncc_to_error[condition_code]);\r\nreturn;\r\n} else {\r\nmutex_unlock(&u132->scheduler_lock);\r\ndev_err(&u132->platform_dev->dev, "giving back SETUP IN"\r\n"PUT %s urb %p\n", cc_to_text[condition_code],\r\nurb);\r\nu132_hcd_giveback_urb(u132, endp, urb,\r\ncc_to_error[condition_code]);\r\nreturn;\r\n}\r\n} else {\r\ndev_err(&u132->platform_dev->dev, "CALLBACK called urb=%p "\r\n"unlinked=%d\n", urb, urb->unlinked);\r\nmutex_unlock(&u132->scheduler_lock);\r\nu132_hcd_giveback_urb(u132, endp, urb, 0);\r\nreturn;\r\n}\r\n}\r\nstatic void u132_hcd_configure_empty_recv(void *data, struct urb *urb, u8 *buf,\r\nint len, int toggle_bits, int error_count, int condition_code,\r\nint repeat_number, int halted, int skipped, int actual, int non_null)\r\n{\r\nstruct u132_endp *endp = data;\r\nstruct u132 *u132 = endp->u132;\r\nmutex_lock(&u132->scheduler_lock);\r\nif (u132->going > 1) {\r\ndev_err(&u132->platform_dev->dev, "device has been removed %d\n"\r\n, u132->going);\r\nmutex_unlock(&u132->scheduler_lock);\r\nu132_hcd_forget_urb(u132, endp, urb, -ENODEV);\r\nreturn;\r\n} else if (endp->dequeueing) {\r\nendp->dequeueing = 0;\r\nmutex_unlock(&u132->scheduler_lock);\r\nu132_hcd_giveback_urb(u132, endp, urb, -EINTR);\r\nreturn;\r\n} else if (u132->going > 0) {\r\ndev_err(&u132->platform_dev->dev, "device is being removed "\r\n"urb=%p\n", urb);\r\nmutex_unlock(&u132->scheduler_lock);\r\nu132_hcd_giveback_urb(u132, endp, urb, -ENODEV);\r\nreturn;\r\n} else if (!urb->unlinked) {\r\nmutex_unlock(&u132->scheduler_lock);\r\nu132_hcd_giveback_urb(u132, endp, urb, 0);\r\nreturn;\r\n} else {\r\ndev_err(&u132->platform_dev->dev, "CALLBACK called urb=%p "\r\n"unlinked=%d\n", urb, urb->unlinked);\r\nmutex_unlock(&u132->scheduler_lock);\r\nu132_hcd_giveback_urb(u132, endp, urb, 0);\r\nreturn;\r\n}\r\n}\r\nstatic void u132_hcd_configure_setup_sent(void *data, struct urb *urb, u8 *buf,\r\nint len, int toggle_bits, int error_count, int condition_code,\r\nint repeat_number, int halted, int skipped, int actual, int non_null)\r\n{\r\nstruct u132_endp *endp = data;\r\nstruct u132 *u132 = endp->u132;\r\nu8 address = u132->addr[endp->usb_addr].address;\r\nmutex_lock(&u132->scheduler_lock);\r\nif (u132->going > 1) {\r\ndev_err(&u132->platform_dev->dev, "device has been removed %d\n"\r\n, u132->going);\r\nmutex_unlock(&u132->scheduler_lock);\r\nu132_hcd_forget_urb(u132, endp, urb, -ENODEV);\r\nreturn;\r\n} else if (endp->dequeueing) {\r\nendp->dequeueing = 0;\r\nmutex_unlock(&u132->scheduler_lock);\r\nu132_hcd_giveback_urb(u132, endp, urb, -EINTR);\r\nreturn;\r\n} else if (u132->going > 0) {\r\ndev_err(&u132->platform_dev->dev, "device is being removed "\r\n"urb=%p\n", urb);\r\nmutex_unlock(&u132->scheduler_lock);\r\nu132_hcd_giveback_urb(u132, endp, urb, -ENODEV);\r\nreturn;\r\n} else if (!urb->unlinked) {\r\nif (usb_pipein(urb->pipe)) {\r\nint retval;\r\nstruct u132_ring *ring = endp->ring;\r\nmutex_unlock(&u132->scheduler_lock);\r\nretval = usb_ftdi_elan_edset_input(u132->platform_dev,\r\nring->number, endp, urb, address,\r\nendp->usb_endp, 0,\r\nu132_hcd_configure_input_recv);\r\nif (retval != 0)\r\nu132_hcd_giveback_urb(u132, endp, urb, retval);\r\nreturn;\r\n} else {\r\nint retval;\r\nstruct u132_ring *ring = endp->ring;\r\nmutex_unlock(&u132->scheduler_lock);\r\nretval = usb_ftdi_elan_edset_input(u132->platform_dev,\r\nring->number, endp, urb, address,\r\nendp->usb_endp, 0,\r\nu132_hcd_configure_empty_recv);\r\nif (retval != 0)\r\nu132_hcd_giveback_urb(u132, endp, urb, retval);\r\nreturn;\r\n}\r\n} else {\r\ndev_err(&u132->platform_dev->dev, "CALLBACK called urb=%p "\r\n"unlinked=%d\n", urb, urb->unlinked);\r\nmutex_unlock(&u132->scheduler_lock);\r\nu132_hcd_giveback_urb(u132, endp, urb, 0);\r\nreturn;\r\n}\r\n}\r\nstatic void u132_hcd_enumeration_empty_recv(void *data, struct urb *urb,\r\nu8 *buf, int len, int toggle_bits, int error_count, int condition_code,\r\nint repeat_number, int halted, int skipped, int actual, int non_null)\r\n{\r\nstruct u132_endp *endp = data;\r\nstruct u132 *u132 = endp->u132;\r\nu8 address = u132->addr[endp->usb_addr].address;\r\nstruct u132_udev *udev = &u132->udev[address];\r\nmutex_lock(&u132->scheduler_lock);\r\nif (u132->going > 1) {\r\ndev_err(&u132->platform_dev->dev, "device has been removed %d\n"\r\n, u132->going);\r\nmutex_unlock(&u132->scheduler_lock);\r\nu132_hcd_forget_urb(u132, endp, urb, -ENODEV);\r\nreturn;\r\n} else if (endp->dequeueing) {\r\nendp->dequeueing = 0;\r\nmutex_unlock(&u132->scheduler_lock);\r\nu132_hcd_giveback_urb(u132, endp, urb, -EINTR);\r\nreturn;\r\n} else if (u132->going > 0) {\r\ndev_err(&u132->platform_dev->dev, "device is being removed "\r\n"urb=%p\n", urb);\r\nmutex_unlock(&u132->scheduler_lock);\r\nu132_hcd_giveback_urb(u132, endp, urb, -ENODEV);\r\nreturn;\r\n} else if (!urb->unlinked) {\r\nu132->addr[0].address = 0;\r\nendp->usb_addr = udev->usb_addr;\r\nmutex_unlock(&u132->scheduler_lock);\r\nu132_hcd_giveback_urb(u132, endp, urb, 0);\r\nreturn;\r\n} else {\r\ndev_err(&u132->platform_dev->dev, "CALLBACK called urb=%p "\r\n"unlinked=%d\n", urb, urb->unlinked);\r\nmutex_unlock(&u132->scheduler_lock);\r\nu132_hcd_giveback_urb(u132, endp, urb, 0);\r\nreturn;\r\n}\r\n}\r\nstatic void u132_hcd_enumeration_address_sent(void *data, struct urb *urb,\r\nu8 *buf, int len, int toggle_bits, int error_count, int condition_code,\r\nint repeat_number, int halted, int skipped, int actual, int non_null)\r\n{\r\nstruct u132_endp *endp = data;\r\nstruct u132 *u132 = endp->u132;\r\nmutex_lock(&u132->scheduler_lock);\r\nif (u132->going > 1) {\r\ndev_err(&u132->platform_dev->dev, "device has been removed %d\n"\r\n, u132->going);\r\nmutex_unlock(&u132->scheduler_lock);\r\nu132_hcd_forget_urb(u132, endp, urb, -ENODEV);\r\nreturn;\r\n} else if (endp->dequeueing) {\r\nendp->dequeueing = 0;\r\nmutex_unlock(&u132->scheduler_lock);\r\nu132_hcd_giveback_urb(u132, endp, urb, -EINTR);\r\nreturn;\r\n} else if (u132->going > 0) {\r\ndev_err(&u132->platform_dev->dev, "device is being removed "\r\n"urb=%p\n", urb);\r\nmutex_unlock(&u132->scheduler_lock);\r\nu132_hcd_giveback_urb(u132, endp, urb, -ENODEV);\r\nreturn;\r\n} else if (!urb->unlinked) {\r\nint retval;\r\nstruct u132_ring *ring = endp->ring;\r\nmutex_unlock(&u132->scheduler_lock);\r\nretval = usb_ftdi_elan_edset_input(u132->platform_dev,\r\nring->number, endp, urb, 0, endp->usb_endp, 0,\r\nu132_hcd_enumeration_empty_recv);\r\nif (retval != 0)\r\nu132_hcd_giveback_urb(u132, endp, urb, retval);\r\nreturn;\r\n} else {\r\ndev_err(&u132->platform_dev->dev, "CALLBACK called urb=%p "\r\n"unlinked=%d\n", urb, urb->unlinked);\r\nmutex_unlock(&u132->scheduler_lock);\r\nu132_hcd_giveback_urb(u132, endp, urb, 0);\r\nreturn;\r\n}\r\n}\r\nstatic void u132_hcd_initial_empty_sent(void *data, struct urb *urb, u8 *buf,\r\nint len, int toggle_bits, int error_count, int condition_code,\r\nint repeat_number, int halted, int skipped, int actual, int non_null)\r\n{\r\nstruct u132_endp *endp = data;\r\nstruct u132 *u132 = endp->u132;\r\nmutex_lock(&u132->scheduler_lock);\r\nif (u132->going > 1) {\r\ndev_err(&u132->platform_dev->dev, "device has been removed %d\n"\r\n, u132->going);\r\nmutex_unlock(&u132->scheduler_lock);\r\nu132_hcd_forget_urb(u132, endp, urb, -ENODEV);\r\nreturn;\r\n} else if (endp->dequeueing) {\r\nendp->dequeueing = 0;\r\nmutex_unlock(&u132->scheduler_lock);\r\nu132_hcd_giveback_urb(u132, endp, urb, -EINTR);\r\nreturn;\r\n} else if (u132->going > 0) {\r\ndev_err(&u132->platform_dev->dev, "device is being removed "\r\n"urb=%p\n", urb);\r\nmutex_unlock(&u132->scheduler_lock);\r\nu132_hcd_giveback_urb(u132, endp, urb, -ENODEV);\r\nreturn;\r\n} else if (!urb->unlinked) {\r\nmutex_unlock(&u132->scheduler_lock);\r\nu132_hcd_giveback_urb(u132, endp, urb, 0);\r\nreturn;\r\n} else {\r\ndev_err(&u132->platform_dev->dev, "CALLBACK called urb=%p "\r\n"unlinked=%d\n", urb, urb->unlinked);\r\nmutex_unlock(&u132->scheduler_lock);\r\nu132_hcd_giveback_urb(u132, endp, urb, 0);\r\nreturn;\r\n}\r\n}\r\nstatic void u132_hcd_initial_input_recv(void *data, struct urb *urb, u8 *buf,\r\nint len, int toggle_bits, int error_count, int condition_code,\r\nint repeat_number, int halted, int skipped, int actual, int non_null)\r\n{\r\nstruct u132_endp *endp = data;\r\nstruct u132 *u132 = endp->u132;\r\nu8 address = u132->addr[endp->usb_addr].address;\r\nmutex_lock(&u132->scheduler_lock);\r\nif (u132->going > 1) {\r\ndev_err(&u132->platform_dev->dev, "device has been removed %d\n"\r\n, u132->going);\r\nmutex_unlock(&u132->scheduler_lock);\r\nu132_hcd_forget_urb(u132, endp, urb, -ENODEV);\r\nreturn;\r\n} else if (endp->dequeueing) {\r\nendp->dequeueing = 0;\r\nmutex_unlock(&u132->scheduler_lock);\r\nu132_hcd_giveback_urb(u132, endp, urb, -EINTR);\r\nreturn;\r\n} else if (u132->going > 0) {\r\ndev_err(&u132->platform_dev->dev, "device is being removed "\r\n"urb=%p\n", urb);\r\nmutex_unlock(&u132->scheduler_lock);\r\nu132_hcd_giveback_urb(u132, endp, urb, -ENODEV);\r\nreturn;\r\n} else if (!urb->unlinked) {\r\nint retval;\r\nstruct u132_ring *ring = endp->ring;\r\nu8 *u = urb->transfer_buffer;\r\nu8 *b = buf;\r\nint L = len;\r\nwhile (L-- > 0)\r\n*u++ = *b++;\r\nurb->actual_length = len;\r\nmutex_unlock(&u132->scheduler_lock);\r\nretval = usb_ftdi_elan_edset_empty(u132->platform_dev,\r\nring->number, endp, urb, address, endp->usb_endp, 0x3,\r\nu132_hcd_initial_empty_sent);\r\nif (retval != 0)\r\nu132_hcd_giveback_urb(u132, endp, urb, retval);\r\nreturn;\r\n} else {\r\ndev_err(&u132->platform_dev->dev, "CALLBACK called urb=%p "\r\n"unlinked=%d\n", urb, urb->unlinked);\r\nmutex_unlock(&u132->scheduler_lock);\r\nu132_hcd_giveback_urb(u132, endp, urb, 0);\r\nreturn;\r\n}\r\n}\r\nstatic void u132_hcd_initial_setup_sent(void *data, struct urb *urb, u8 *buf,\r\nint len, int toggle_bits, int error_count, int condition_code,\r\nint repeat_number, int halted, int skipped, int actual, int non_null)\r\n{\r\nstruct u132_endp *endp = data;\r\nstruct u132 *u132 = endp->u132;\r\nu8 address = u132->addr[endp->usb_addr].address;\r\nmutex_lock(&u132->scheduler_lock);\r\nif (u132->going > 1) {\r\ndev_err(&u132->platform_dev->dev, "device has been removed %d\n"\r\n, u132->going);\r\nmutex_unlock(&u132->scheduler_lock);\r\nu132_hcd_forget_urb(u132, endp, urb, -ENODEV);\r\nreturn;\r\n} else if (endp->dequeueing) {\r\nendp->dequeueing = 0;\r\nmutex_unlock(&u132->scheduler_lock);\r\nu132_hcd_giveback_urb(u132, endp, urb, -EINTR);\r\nreturn;\r\n} else if (u132->going > 0) {\r\ndev_err(&u132->platform_dev->dev, "device is being removed "\r\n"urb=%p\n", urb);\r\nmutex_unlock(&u132->scheduler_lock);\r\nu132_hcd_giveback_urb(u132, endp, urb, -ENODEV);\r\nreturn;\r\n} else if (!urb->unlinked) {\r\nint retval;\r\nstruct u132_ring *ring = endp->ring;\r\nmutex_unlock(&u132->scheduler_lock);\r\nretval = usb_ftdi_elan_edset_input(u132->platform_dev,\r\nring->number, endp, urb, address, endp->usb_endp, 0,\r\nu132_hcd_initial_input_recv);\r\nif (retval != 0)\r\nu132_hcd_giveback_urb(u132, endp, urb, retval);\r\nreturn;\r\n} else {\r\ndev_err(&u132->platform_dev->dev, "CALLBACK called urb=%p "\r\n"unlinked=%d\n", urb, urb->unlinked);\r\nmutex_unlock(&u132->scheduler_lock);\r\nu132_hcd_giveback_urb(u132, endp, urb, 0);\r\nreturn;\r\n}\r\n}\r\nstatic void u132_hcd_ring_work_scheduler(struct work_struct *work)\r\n{\r\nstruct u132_ring *ring =\r\ncontainer_of(work, struct u132_ring, scheduler.work);\r\nstruct u132 *u132 = ring->u132;\r\nmutex_lock(&u132->scheduler_lock);\r\nif (ring->in_use) {\r\nmutex_unlock(&u132->scheduler_lock);\r\nu132_ring_put_kref(u132, ring);\r\nreturn;\r\n} else if (ring->curr_endp) {\r\nstruct u132_endp *last_endp = ring->curr_endp;\r\nstruct list_head *scan;\r\nstruct list_head *head = &last_endp->endp_ring;\r\nunsigned long wakeup = 0;\r\nlist_for_each(scan, head) {\r\nstruct u132_endp *endp = list_entry(scan,\r\nstruct u132_endp, endp_ring);\r\nif (endp->queue_next == endp->queue_last) {\r\n} else if ((endp->delayed == 0)\r\n|| time_after_eq(jiffies, endp->jiffies)) {\r\nring->curr_endp = endp;\r\nu132_endp_cancel_work(u132, last_endp);\r\nu132_endp_queue_work(u132, last_endp, 0);\r\nmutex_unlock(&u132->scheduler_lock);\r\nu132_ring_put_kref(u132, ring);\r\nreturn;\r\n} else {\r\nunsigned long delta = endp->jiffies - jiffies;\r\nif (delta > wakeup)\r\nwakeup = delta;\r\n}\r\n}\r\nif (last_endp->queue_next == last_endp->queue_last) {\r\n} else if ((last_endp->delayed == 0) || time_after_eq(jiffies,\r\nlast_endp->jiffies)) {\r\nu132_endp_cancel_work(u132, last_endp);\r\nu132_endp_queue_work(u132, last_endp, 0);\r\nmutex_unlock(&u132->scheduler_lock);\r\nu132_ring_put_kref(u132, ring);\r\nreturn;\r\n} else {\r\nunsigned long delta = last_endp->jiffies - jiffies;\r\nif (delta > wakeup)\r\nwakeup = delta;\r\n}\r\nif (wakeup > 0) {\r\nu132_ring_requeue_work(u132, ring, wakeup);\r\nmutex_unlock(&u132->scheduler_lock);\r\nreturn;\r\n} else {\r\nmutex_unlock(&u132->scheduler_lock);\r\nu132_ring_put_kref(u132, ring);\r\nreturn;\r\n}\r\n} else {\r\nmutex_unlock(&u132->scheduler_lock);\r\nu132_ring_put_kref(u132, ring);\r\nreturn;\r\n}\r\n}\r\nstatic void u132_hcd_endp_work_scheduler(struct work_struct *work)\r\n{\r\nstruct u132_ring *ring;\r\nstruct u132_endp *endp =\r\ncontainer_of(work, struct u132_endp, scheduler.work);\r\nstruct u132 *u132 = endp->u132;\r\nmutex_lock(&u132->scheduler_lock);\r\nring = endp->ring;\r\nif (endp->edset_flush) {\r\nendp->edset_flush = 0;\r\nif (endp->dequeueing)\r\nusb_ftdi_elan_edset_flush(u132->platform_dev,\r\nring->number, endp);\r\nmutex_unlock(&u132->scheduler_lock);\r\nu132_endp_put_kref(u132, endp);\r\nreturn;\r\n} else if (endp->active) {\r\nmutex_unlock(&u132->scheduler_lock);\r\nu132_endp_put_kref(u132, endp);\r\nreturn;\r\n} else if (ring->in_use) {\r\nmutex_unlock(&u132->scheduler_lock);\r\nu132_endp_put_kref(u132, endp);\r\nreturn;\r\n} else if (endp->queue_next == endp->queue_last) {\r\nmutex_unlock(&u132->scheduler_lock);\r\nu132_endp_put_kref(u132, endp);\r\nreturn;\r\n} else if (endp->pipetype == PIPE_INTERRUPT) {\r\nu8 address = u132->addr[endp->usb_addr].address;\r\nif (ring->in_use) {\r\nmutex_unlock(&u132->scheduler_lock);\r\nu132_endp_put_kref(u132, endp);\r\nreturn;\r\n} else {\r\nint retval;\r\nstruct urb *urb = endp->urb_list[ENDP_QUEUE_MASK &\r\nendp->queue_next];\r\nendp->active = 1;\r\nring->curr_endp = endp;\r\nring->in_use = 1;\r\nmutex_unlock(&u132->scheduler_lock);\r\nretval = edset_single(u132, ring, endp, urb, address,\r\nendp->toggle_bits, u132_hcd_interrupt_recv);\r\nif (retval != 0)\r\nu132_hcd_giveback_urb(u132, endp, urb, retval);\r\nreturn;\r\n}\r\n} else if (endp->pipetype == PIPE_CONTROL) {\r\nu8 address = u132->addr[endp->usb_addr].address;\r\nif (ring->in_use) {\r\nmutex_unlock(&u132->scheduler_lock);\r\nu132_endp_put_kref(u132, endp);\r\nreturn;\r\n} else if (address == 0) {\r\nint retval;\r\nstruct urb *urb = endp->urb_list[ENDP_QUEUE_MASK &\r\nendp->queue_next];\r\nendp->active = 1;\r\nring->curr_endp = endp;\r\nring->in_use = 1;\r\nmutex_unlock(&u132->scheduler_lock);\r\nretval = edset_setup(u132, ring, endp, urb, address,\r\n0x2, u132_hcd_initial_setup_sent);\r\nif (retval != 0)\r\nu132_hcd_giveback_urb(u132, endp, urb, retval);\r\nreturn;\r\n} else if (endp->usb_addr == 0) {\r\nint retval;\r\nstruct urb *urb = endp->urb_list[ENDP_QUEUE_MASK &\r\nendp->queue_next];\r\nendp->active = 1;\r\nring->curr_endp = endp;\r\nring->in_use = 1;\r\nmutex_unlock(&u132->scheduler_lock);\r\nretval = edset_setup(u132, ring, endp, urb, 0, 0x2,\r\nu132_hcd_enumeration_address_sent);\r\nif (retval != 0)\r\nu132_hcd_giveback_urb(u132, endp, urb, retval);\r\nreturn;\r\n} else {\r\nint retval;\r\nstruct urb *urb = endp->urb_list[ENDP_QUEUE_MASK &\r\nendp->queue_next];\r\naddress = u132->addr[endp->usb_addr].address;\r\nendp->active = 1;\r\nring->curr_endp = endp;\r\nring->in_use = 1;\r\nmutex_unlock(&u132->scheduler_lock);\r\nretval = edset_setup(u132, ring, endp, urb, address,\r\n0x2, u132_hcd_configure_setup_sent);\r\nif (retval != 0)\r\nu132_hcd_giveback_urb(u132, endp, urb, retval);\r\nreturn;\r\n}\r\n} else {\r\nif (endp->input) {\r\nu8 address = u132->addr[endp->usb_addr].address;\r\nif (ring->in_use) {\r\nmutex_unlock(&u132->scheduler_lock);\r\nu132_endp_put_kref(u132, endp);\r\nreturn;\r\n} else {\r\nint retval;\r\nstruct urb *urb = endp->urb_list[\r\nENDP_QUEUE_MASK & endp->queue_next];\r\nendp->active = 1;\r\nring->curr_endp = endp;\r\nring->in_use = 1;\r\nmutex_unlock(&u132->scheduler_lock);\r\nretval = edset_input(u132, ring, endp, urb,\r\naddress, endp->toggle_bits,\r\nu132_hcd_bulk_input_recv);\r\nif (retval == 0) {\r\n} else\r\nu132_hcd_giveback_urb(u132, endp, urb,\r\nretval);\r\nreturn;\r\n}\r\n} else {\r\nu8 address = u132->addr[endp->usb_addr].address;\r\nif (ring->in_use) {\r\nmutex_unlock(&u132->scheduler_lock);\r\nu132_endp_put_kref(u132, endp);\r\nreturn;\r\n} else {\r\nint retval;\r\nstruct urb *urb = endp->urb_list[\r\nENDP_QUEUE_MASK & endp->queue_next];\r\nendp->active = 1;\r\nring->curr_endp = endp;\r\nring->in_use = 1;\r\nmutex_unlock(&u132->scheduler_lock);\r\nretval = edset_output(u132, ring, endp, urb,\r\naddress, endp->toggle_bits,\r\nu132_hcd_bulk_output_sent);\r\nif (retval == 0) {\r\n} else\r\nu132_hcd_giveback_urb(u132, endp, urb,\r\nretval);\r\nreturn;\r\n}\r\n}\r\n}\r\n}\r\nstatic void port_power(struct u132 *u132, int pn, int is_on)\r\n{\r\nu132->port[pn].power = is_on;\r\n}\r\nstatic void u132_power(struct u132 *u132, int is_on)\r\n{\r\nstruct usb_hcd *hcd = u132_to_hcd(u132)\r\n;\r\nif (is_on) {\r\nif (u132->power)\r\nreturn;\r\nu132->power = 1;\r\n} else {\r\nu132->power = 0;\r\nhcd->state = HC_STATE_HALT;\r\n}\r\n}\r\nstatic int u132_periodic_reinit(struct u132 *u132)\r\n{\r\nint retval;\r\nu32 fi = u132->hc_fminterval & 0x03fff;\r\nu32 fit;\r\nu32 fminterval;\r\nretval = u132_read_pcimem(u132, fminterval, &fminterval);\r\nif (retval)\r\nreturn retval;\r\nfit = fminterval & FIT;\r\nretval = u132_write_pcimem(u132, fminterval,\r\n(fit ^ FIT) | u132->hc_fminterval);\r\nif (retval)\r\nreturn retval;\r\nretval = u132_write_pcimem(u132, periodicstart,\r\n((9 * fi) / 10) & 0x3fff);\r\nif (retval)\r\nreturn retval;\r\nreturn 0;\r\n}\r\nstatic char *hcfs2string(int state)\r\n{\r\nswitch (state) {\r\ncase OHCI_USB_RESET:\r\nreturn "reset";\r\ncase OHCI_USB_RESUME:\r\nreturn "resume";\r\ncase OHCI_USB_OPER:\r\nreturn "operational";\r\ncase OHCI_USB_SUSPEND:\r\nreturn "suspend";\r\n}\r\nreturn "?";\r\n}\r\nstatic int u132_init(struct u132 *u132)\r\n{\r\nint retval;\r\nu32 control;\r\nu132_disable(u132);\r\nu132->next_statechange = jiffies;\r\nretval = u132_write_pcimem(u132, intrdisable, OHCI_INTR_MIE);\r\nif (retval)\r\nreturn retval;\r\nretval = u132_read_pcimem(u132, control, &control);\r\nif (retval)\r\nreturn retval;\r\nif (u132->num_ports == 0) {\r\nu32 rh_a = -1;\r\nretval = u132_read_pcimem(u132, roothub.a, &rh_a);\r\nif (retval)\r\nreturn retval;\r\nu132->num_ports = rh_a & RH_A_NDP;\r\nretval = read_roothub_info(u132);\r\nif (retval)\r\nreturn retval;\r\n}\r\nif (u132->num_ports > MAX_U132_PORTS)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int u132_run(struct u132 *u132)\r\n{\r\nint retval;\r\nu32 control;\r\nu32 status;\r\nu32 fminterval;\r\nu32 periodicstart;\r\nu32 cmdstatus;\r\nu32 roothub_a;\r\nint mask = OHCI_INTR_INIT;\r\nint first = u132->hc_fminterval == 0;\r\nint sleep_time = 0;\r\nint reset_timeout = 30;\r\nu132_disable(u132);\r\nif (first) {\r\nu32 temp;\r\nretval = u132_read_pcimem(u132, fminterval, &temp);\r\nif (retval)\r\nreturn retval;\r\nu132->hc_fminterval = temp & 0x3fff;\r\nu132->hc_fminterval |= FSMP(u132->hc_fminterval) << 16;\r\n}\r\nretval = u132_read_pcimem(u132, control, &u132->hc_control);\r\nif (retval)\r\nreturn retval;\r\ndev_info(&u132->platform_dev->dev, "resetting from state '%s', control "\r\n"= %08X\n", hcfs2string(u132->hc_control & OHCI_CTRL_HCFS),\r\nu132->hc_control);\r\nswitch (u132->hc_control & OHCI_CTRL_HCFS) {\r\ncase OHCI_USB_OPER:\r\nsleep_time = 0;\r\nbreak;\r\ncase OHCI_USB_SUSPEND:\r\ncase OHCI_USB_RESUME:\r\nu132->hc_control &= OHCI_CTRL_RWC;\r\nu132->hc_control |= OHCI_USB_RESUME;\r\nsleep_time = 10;\r\nbreak;\r\ndefault:\r\nu132->hc_control &= OHCI_CTRL_RWC;\r\nu132->hc_control |= OHCI_USB_RESET;\r\nsleep_time = 50;\r\nbreak;\r\n}\r\nretval = u132_write_pcimem(u132, control, u132->hc_control);\r\nif (retval)\r\nreturn retval;\r\nretval = u132_read_pcimem(u132, control, &control);\r\nif (retval)\r\nreturn retval;\r\nmsleep(sleep_time);\r\nretval = u132_read_pcimem(u132, roothub.a, &roothub_a);\r\nif (retval)\r\nreturn retval;\r\nif (!(roothub_a & RH_A_NPS)) {\r\nint temp;\r\nfor (temp = 0; temp < u132->num_ports; temp++) {\r\nretval = u132_write_pcimem(u132,\r\nroothub.portstatus[temp], RH_PS_LSDA);\r\nif (retval)\r\nreturn retval;\r\n}\r\n}\r\nretval = u132_read_pcimem(u132, control, &control);\r\nif (retval)\r\nreturn retval;\r\nretry:\r\nretval = u132_read_pcimem(u132, cmdstatus, &status);\r\nif (retval)\r\nreturn retval;\r\nretval = u132_write_pcimem(u132, cmdstatus, OHCI_HCR);\r\nif (retval)\r\nreturn retval;\r\nextra: {\r\nretval = u132_read_pcimem(u132, cmdstatus, &status);\r\nif (retval)\r\nreturn retval;\r\nif (0 != (status & OHCI_HCR)) {\r\nif (--reset_timeout == 0) {\r\ndev_err(&u132->platform_dev->dev, "USB HC reset"\r\n" timed out!\n");\r\nreturn -ENODEV;\r\n} else {\r\nmsleep(5);\r\ngoto extra;\r\n}\r\n}\r\n}\r\nif (u132->flags & OHCI_QUIRK_INITRESET) {\r\nretval = u132_write_pcimem(u132, control, u132->hc_control);\r\nif (retval)\r\nreturn retval;\r\nretval = u132_read_pcimem(u132, control, &control);\r\nif (retval)\r\nreturn retval;\r\n}\r\nretval = u132_write_pcimem(u132, ed_controlhead, 0x00000000);\r\nif (retval)\r\nreturn retval;\r\nretval = u132_write_pcimem(u132, ed_bulkhead, 0x11000000);\r\nif (retval)\r\nreturn retval;\r\nretval = u132_write_pcimem(u132, hcca, 0x00000000);\r\nif (retval)\r\nreturn retval;\r\nretval = u132_periodic_reinit(u132);\r\nif (retval)\r\nreturn retval;\r\nretval = u132_read_pcimem(u132, fminterval, &fminterval);\r\nif (retval)\r\nreturn retval;\r\nretval = u132_read_pcimem(u132, periodicstart, &periodicstart);\r\nif (retval)\r\nreturn retval;\r\nif (0 == (fminterval & 0x3fff0000) || 0 == periodicstart) {\r\nif (!(u132->flags & OHCI_QUIRK_INITRESET)) {\r\nu132->flags |= OHCI_QUIRK_INITRESET;\r\ngoto retry;\r\n} else\r\ndev_err(&u132->platform_dev->dev, "init err(%08x %04x)"\r\n"\n", fminterval, periodicstart);\r\n}\r\nu132->hc_control &= OHCI_CTRL_RWC;\r\nu132->hc_control |= OHCI_CONTROL_INIT | OHCI_CTRL_BLE | OHCI_USB_OPER;\r\nretval = u132_write_pcimem(u132, control, u132->hc_control);\r\nif (retval)\r\nreturn retval;\r\nretval = u132_write_pcimem(u132, cmdstatus, OHCI_BLF);\r\nif (retval)\r\nreturn retval;\r\nretval = u132_read_pcimem(u132, cmdstatus, &cmdstatus);\r\nif (retval)\r\nreturn retval;\r\nretval = u132_read_pcimem(u132, control, &control);\r\nif (retval)\r\nreturn retval;\r\nu132_to_hcd(u132)->state = HC_STATE_RUNNING;\r\nretval = u132_write_pcimem(u132, roothub.status, RH_HS_DRWE);\r\nif (retval)\r\nreturn retval;\r\nretval = u132_write_pcimem(u132, intrstatus, mask);\r\nif (retval)\r\nreturn retval;\r\nretval = u132_write_pcimem(u132, intrdisable,\r\nOHCI_INTR_MIE | OHCI_INTR_OC | OHCI_INTR_RHSC | OHCI_INTR_FNO |\r\nOHCI_INTR_UE | OHCI_INTR_RD | OHCI_INTR_SF | OHCI_INTR_WDH |\r\nOHCI_INTR_SO);\r\nif (retval)\r\nreturn retval;\r\nretval = u132_read_pcimem(u132, roothub.a, &roothub_a);\r\nif (retval)\r\nreturn retval;\r\nroothub_a &= ~(RH_A_PSM | RH_A_OCPM);\r\nif (u132->flags & OHCI_QUIRK_SUPERIO) {\r\nroothub_a |= RH_A_NOCP;\r\nroothub_a &= ~(RH_A_POTPGT | RH_A_NPS);\r\nretval = u132_write_pcimem(u132, roothub.a, roothub_a);\r\nif (retval)\r\nreturn retval;\r\n} else if ((u132->flags & OHCI_QUIRK_AMD756) || distrust_firmware) {\r\nroothub_a |= RH_A_NPS;\r\nretval = u132_write_pcimem(u132, roothub.a, roothub_a);\r\nif (retval)\r\nreturn retval;\r\n}\r\nretval = u132_write_pcimem(u132, roothub.status, RH_HS_LPSC);\r\nif (retval)\r\nreturn retval;\r\nretval = u132_write_pcimem(u132, roothub.b,\r\n(roothub_a & RH_A_NPS) ? 0 : RH_B_PPCM);\r\nif (retval)\r\nreturn retval;\r\nretval = u132_read_pcimem(u132, control, &control);\r\nif (retval)\r\nreturn retval;\r\nmdelay((roothub_a >> 23) & 0x1fe);\r\nu132_to_hcd(u132)->state = HC_STATE_RUNNING;\r\nreturn 0;\r\n}\r\nstatic void u132_hcd_stop(struct usb_hcd *hcd)\r\n{\r\nstruct u132 *u132 = hcd_to_u132(hcd);\r\nif (u132->going > 1) {\r\ndev_err(&u132->platform_dev->dev, "u132 device %p(hcd=%p) has b"\r\n"een removed %d\n", u132, hcd, u132->going);\r\n} else if (u132->going > 0) {\r\ndev_err(&u132->platform_dev->dev, "device hcd=%p is being remov"\r\n"ed\n", hcd);\r\n} else {\r\nmutex_lock(&u132->sw_lock);\r\nmsleep(100);\r\nu132_power(u132, 0);\r\nmutex_unlock(&u132->sw_lock);\r\n}\r\n}\r\nstatic int u132_hcd_start(struct usb_hcd *hcd)\r\n{\r\nstruct u132 *u132 = hcd_to_u132(hcd);\r\nif (u132->going > 1) {\r\ndev_err(&u132->platform_dev->dev, "device has been removed %d\n"\r\n, u132->going);\r\nreturn -ENODEV;\r\n} else if (u132->going > 0) {\r\ndev_err(&u132->platform_dev->dev, "device is being removed\n");\r\nreturn -ESHUTDOWN;\r\n} else if (hcd->self.controller) {\r\nint retval;\r\nstruct platform_device *pdev =\r\nto_platform_device(hcd->self.controller);\r\nu16 vendor = ((struct u132_platform_data *)\r\n(pdev->dev.platform_data))->vendor;\r\nu16 device = ((struct u132_platform_data *)\r\n(pdev->dev.platform_data))->device;\r\nmutex_lock(&u132->sw_lock);\r\nmsleep(10);\r\nif (vendor == PCI_VENDOR_ID_AMD && device == 0x740c) {\r\nu132->flags = OHCI_QUIRK_AMD756;\r\n} else if (vendor == PCI_VENDOR_ID_OPTI && device == 0xc861) {\r\ndev_err(&u132->platform_dev->dev, "WARNING: OPTi workar"\r\n"ounds unavailable\n");\r\n} else if (vendor == PCI_VENDOR_ID_COMPAQ && device == 0xa0f8)\r\nu132->flags |= OHCI_QUIRK_ZFMICRO;\r\nretval = u132_run(u132);\r\nif (retval) {\r\nu132_disable(u132);\r\nu132->going = 1;\r\n}\r\nmsleep(100);\r\nmutex_unlock(&u132->sw_lock);\r\nreturn retval;\r\n} else {\r\ndev_err(&u132->platform_dev->dev, "platform_device missing\n");\r\nreturn -ENODEV;\r\n}\r\n}\r\nstatic int u132_hcd_reset(struct usb_hcd *hcd)\r\n{\r\nstruct u132 *u132 = hcd_to_u132(hcd);\r\nif (u132->going > 1) {\r\ndev_err(&u132->platform_dev->dev, "device has been removed %d\n"\r\n, u132->going);\r\nreturn -ENODEV;\r\n} else if (u132->going > 0) {\r\ndev_err(&u132->platform_dev->dev, "device is being removed\n");\r\nreturn -ESHUTDOWN;\r\n} else {\r\nint retval;\r\nmutex_lock(&u132->sw_lock);\r\nretval = u132_init(u132);\r\nif (retval) {\r\nu132_disable(u132);\r\nu132->going = 1;\r\n}\r\nmutex_unlock(&u132->sw_lock);\r\nreturn retval;\r\n}\r\n}\r\nstatic int create_endpoint_and_queue_int(struct u132 *u132,\r\nstruct u132_udev *udev, struct urb *urb,\r\nstruct usb_device *usb_dev, u8 usb_addr, u8 usb_endp, u8 address,\r\ngfp_t mem_flags)\r\n{\r\nstruct u132_ring *ring;\r\nunsigned long irqs;\r\nint rc;\r\nu8 endp_number;\r\nstruct u132_endp *endp = kmalloc(sizeof(struct u132_endp), mem_flags);\r\nif (!endp)\r\nreturn -ENOMEM;\r\nspin_lock_init(&endp->queue_lock.slock);\r\nspin_lock_irqsave(&endp->queue_lock.slock, irqs);\r\nrc = usb_hcd_link_urb_to_ep(u132_to_hcd(u132), urb);\r\nif (rc) {\r\nspin_unlock_irqrestore(&endp->queue_lock.slock, irqs);\r\nkfree(endp);\r\nreturn rc;\r\n}\r\nendp_number = ++u132->num_endpoints;\r\nurb->ep->hcpriv = u132->endp[endp_number - 1] = endp;\r\nINIT_DELAYED_WORK(&endp->scheduler, u132_hcd_endp_work_scheduler);\r\nINIT_LIST_HEAD(&endp->urb_more);\r\nring = endp->ring = &u132->ring[0];\r\nif (ring->curr_endp) {\r\nlist_add_tail(&endp->endp_ring, &ring->curr_endp->endp_ring);\r\n} else {\r\nINIT_LIST_HEAD(&endp->endp_ring);\r\nring->curr_endp = endp;\r\n}\r\nring->length += 1;\r\nendp->dequeueing = 0;\r\nendp->edset_flush = 0;\r\nendp->active = 0;\r\nendp->delayed = 0;\r\nendp->endp_number = endp_number;\r\nendp->u132 = u132;\r\nendp->hep = urb->ep;\r\nendp->pipetype = usb_pipetype(urb->pipe);\r\nu132_endp_init_kref(u132, endp);\r\nif (usb_pipein(urb->pipe)) {\r\nendp->toggle_bits = 0x2;\r\nusb_settoggle(udev->usb_device, usb_endp, 0, 0);\r\nendp->input = 1;\r\nendp->output = 0;\r\nudev->endp_number_in[usb_endp] = endp_number;\r\nu132_udev_get_kref(u132, udev);\r\n} else {\r\nendp->toggle_bits = 0x2;\r\nusb_settoggle(udev->usb_device, usb_endp, 1, 0);\r\nendp->input = 0;\r\nendp->output = 1;\r\nudev->endp_number_out[usb_endp] = endp_number;\r\nu132_udev_get_kref(u132, udev);\r\n}\r\nurb->hcpriv = u132;\r\nendp->delayed = 1;\r\nendp->jiffies = jiffies + msecs_to_jiffies(urb->interval);\r\nendp->udev_number = address;\r\nendp->usb_addr = usb_addr;\r\nendp->usb_endp = usb_endp;\r\nendp->queue_size = 1;\r\nendp->queue_last = 0;\r\nendp->queue_next = 0;\r\nendp->urb_list[ENDP_QUEUE_MASK & endp->queue_last++] = urb;\r\nspin_unlock_irqrestore(&endp->queue_lock.slock, irqs);\r\nu132_endp_queue_work(u132, endp, msecs_to_jiffies(urb->interval));\r\nreturn 0;\r\n}\r\nstatic int queue_int_on_old_endpoint(struct u132 *u132,\r\nstruct u132_udev *udev, struct urb *urb,\r\nstruct usb_device *usb_dev, struct u132_endp *endp, u8 usb_addr,\r\nu8 usb_endp, u8 address)\r\n{\r\nurb->hcpriv = u132;\r\nendp->delayed = 1;\r\nendp->jiffies = jiffies + msecs_to_jiffies(urb->interval);\r\nif (endp->queue_size++ < ENDP_QUEUE_SIZE) {\r\nendp->urb_list[ENDP_QUEUE_MASK & endp->queue_last++] = urb;\r\n} else {\r\nstruct u132_urbq *urbq = kmalloc(sizeof(struct u132_urbq),\r\nGFP_ATOMIC);\r\nif (urbq == NULL) {\r\nendp->queue_size -= 1;\r\nreturn -ENOMEM;\r\n} else {\r\nlist_add_tail(&urbq->urb_more, &endp->urb_more);\r\nurbq->urb = urb;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int create_endpoint_and_queue_bulk(struct u132 *u132,\r\nstruct u132_udev *udev, struct urb *urb,\r\nstruct usb_device *usb_dev, u8 usb_addr, u8 usb_endp, u8 address,\r\ngfp_t mem_flags)\r\n{\r\nint ring_number;\r\nstruct u132_ring *ring;\r\nunsigned long irqs;\r\nint rc;\r\nu8 endp_number;\r\nstruct u132_endp *endp = kmalloc(sizeof(struct u132_endp), mem_flags);\r\nif (!endp)\r\nreturn -ENOMEM;\r\nspin_lock_init(&endp->queue_lock.slock);\r\nspin_lock_irqsave(&endp->queue_lock.slock, irqs);\r\nrc = usb_hcd_link_urb_to_ep(u132_to_hcd(u132), urb);\r\nif (rc) {\r\nspin_unlock_irqrestore(&endp->queue_lock.slock, irqs);\r\nkfree(endp);\r\nreturn rc;\r\n}\r\nendp_number = ++u132->num_endpoints;\r\nurb->ep->hcpriv = u132->endp[endp_number - 1] = endp;\r\nINIT_DELAYED_WORK(&endp->scheduler, u132_hcd_endp_work_scheduler);\r\nINIT_LIST_HEAD(&endp->urb_more);\r\nendp->dequeueing = 0;\r\nendp->edset_flush = 0;\r\nendp->active = 0;\r\nendp->delayed = 0;\r\nendp->endp_number = endp_number;\r\nendp->u132 = u132;\r\nendp->hep = urb->ep;\r\nendp->pipetype = usb_pipetype(urb->pipe);\r\nu132_endp_init_kref(u132, endp);\r\nif (usb_pipein(urb->pipe)) {\r\nendp->toggle_bits = 0x2;\r\nusb_settoggle(udev->usb_device, usb_endp, 0, 0);\r\nring_number = 3;\r\nendp->input = 1;\r\nendp->output = 0;\r\nudev->endp_number_in[usb_endp] = endp_number;\r\nu132_udev_get_kref(u132, udev);\r\n} else {\r\nendp->toggle_bits = 0x2;\r\nusb_settoggle(udev->usb_device, usb_endp, 1, 0);\r\nring_number = 2;\r\nendp->input = 0;\r\nendp->output = 1;\r\nudev->endp_number_out[usb_endp] = endp_number;\r\nu132_udev_get_kref(u132, udev);\r\n}\r\nring = endp->ring = &u132->ring[ring_number - 1];\r\nif (ring->curr_endp) {\r\nlist_add_tail(&endp->endp_ring, &ring->curr_endp->endp_ring);\r\n} else {\r\nINIT_LIST_HEAD(&endp->endp_ring);\r\nring->curr_endp = endp;\r\n}\r\nring->length += 1;\r\nurb->hcpriv = u132;\r\nendp->udev_number = address;\r\nendp->usb_addr = usb_addr;\r\nendp->usb_endp = usb_endp;\r\nendp->queue_size = 1;\r\nendp->queue_last = 0;\r\nendp->queue_next = 0;\r\nendp->urb_list[ENDP_QUEUE_MASK & endp->queue_last++] = urb;\r\nspin_unlock_irqrestore(&endp->queue_lock.slock, irqs);\r\nu132_endp_queue_work(u132, endp, 0);\r\nreturn 0;\r\n}\r\nstatic int queue_bulk_on_old_endpoint(struct u132 *u132, struct u132_udev *udev,\r\nstruct urb *urb,\r\nstruct usb_device *usb_dev, struct u132_endp *endp, u8 usb_addr,\r\nu8 usb_endp, u8 address)\r\n{\r\nurb->hcpriv = u132;\r\nif (endp->queue_size++ < ENDP_QUEUE_SIZE) {\r\nendp->urb_list[ENDP_QUEUE_MASK & endp->queue_last++] = urb;\r\n} else {\r\nstruct u132_urbq *urbq = kmalloc(sizeof(struct u132_urbq),\r\nGFP_ATOMIC);\r\nif (urbq == NULL) {\r\nendp->queue_size -= 1;\r\nreturn -ENOMEM;\r\n} else {\r\nlist_add_tail(&urbq->urb_more, &endp->urb_more);\r\nurbq->urb = urb;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int create_endpoint_and_queue_control(struct u132 *u132,\r\nstruct urb *urb,\r\nstruct usb_device *usb_dev, u8 usb_addr, u8 usb_endp,\r\ngfp_t mem_flags)\r\n{\r\nstruct u132_ring *ring;\r\nunsigned long irqs;\r\nint rc;\r\nu8 endp_number;\r\nstruct u132_endp *endp = kmalloc(sizeof(struct u132_endp), mem_flags);\r\nif (!endp)\r\nreturn -ENOMEM;\r\nspin_lock_init(&endp->queue_lock.slock);\r\nspin_lock_irqsave(&endp->queue_lock.slock, irqs);\r\nrc = usb_hcd_link_urb_to_ep(u132_to_hcd(u132), urb);\r\nif (rc) {\r\nspin_unlock_irqrestore(&endp->queue_lock.slock, irqs);\r\nkfree(endp);\r\nreturn rc;\r\n}\r\nendp_number = ++u132->num_endpoints;\r\nurb->ep->hcpriv = u132->endp[endp_number - 1] = endp;\r\nINIT_DELAYED_WORK(&endp->scheduler, u132_hcd_endp_work_scheduler);\r\nINIT_LIST_HEAD(&endp->urb_more);\r\nring = endp->ring = &u132->ring[0];\r\nif (ring->curr_endp) {\r\nlist_add_tail(&endp->endp_ring, &ring->curr_endp->endp_ring);\r\n} else {\r\nINIT_LIST_HEAD(&endp->endp_ring);\r\nring->curr_endp = endp;\r\n}\r\nring->length += 1;\r\nendp->dequeueing = 0;\r\nendp->edset_flush = 0;\r\nendp->active = 0;\r\nendp->delayed = 0;\r\nendp->endp_number = endp_number;\r\nendp->u132 = u132;\r\nendp->hep = urb->ep;\r\nu132_endp_init_kref(u132, endp);\r\nu132_endp_get_kref(u132, endp);\r\nif (usb_addr == 0) {\r\nu8 address = u132->addr[usb_addr].address;\r\nstruct u132_udev *udev = &u132->udev[address];\r\nendp->udev_number = address;\r\nendp->usb_addr = usb_addr;\r\nendp->usb_endp = usb_endp;\r\nendp->input = 1;\r\nendp->output = 1;\r\nendp->pipetype = usb_pipetype(urb->pipe);\r\nu132_udev_init_kref(u132, udev);\r\nu132_udev_get_kref(u132, udev);\r\nudev->endp_number_in[usb_endp] = endp_number;\r\nudev->endp_number_out[usb_endp] = endp_number;\r\nurb->hcpriv = u132;\r\nendp->queue_size = 1;\r\nendp->queue_last = 0;\r\nendp->queue_next = 0;\r\nendp->urb_list[ENDP_QUEUE_MASK & endp->queue_last++] = urb;\r\nspin_unlock_irqrestore(&endp->queue_lock.slock, irqs);\r\nu132_endp_queue_work(u132, endp, 0);\r\nreturn 0;\r\n} else {\r\nu8 address = u132->addr[usb_addr].address;\r\nstruct u132_udev *udev = &u132->udev[address];\r\nendp->udev_number = address;\r\nendp->usb_addr = usb_addr;\r\nendp->usb_endp = usb_endp;\r\nendp->input = 1;\r\nendp->output = 1;\r\nendp->pipetype = usb_pipetype(urb->pipe);\r\nu132_udev_get_kref(u132, udev);\r\nudev->enumeration = 2;\r\nudev->endp_number_in[usb_endp] = endp_number;\r\nudev->endp_number_out[usb_endp] = endp_number;\r\nurb->hcpriv = u132;\r\nendp->queue_size = 1;\r\nendp->queue_last = 0;\r\nendp->queue_next = 0;\r\nendp->urb_list[ENDP_QUEUE_MASK & endp->queue_last++] = urb;\r\nspin_unlock_irqrestore(&endp->queue_lock.slock, irqs);\r\nu132_endp_queue_work(u132, endp, 0);\r\nreturn 0;\r\n}\r\n}\r\nstatic int queue_control_on_old_endpoint(struct u132 *u132,\r\nstruct urb *urb,\r\nstruct usb_device *usb_dev, struct u132_endp *endp, u8 usb_addr,\r\nu8 usb_endp)\r\n{\r\nif (usb_addr == 0) {\r\nif (usb_pipein(urb->pipe)) {\r\nurb->hcpriv = u132;\r\nif (endp->queue_size++ < ENDP_QUEUE_SIZE) {\r\nendp->urb_list[ENDP_QUEUE_MASK &\r\nendp->queue_last++] = urb;\r\n} else {\r\nstruct u132_urbq *urbq =\r\nkmalloc(sizeof(struct u132_urbq),\r\nGFP_ATOMIC);\r\nif (urbq == NULL) {\r\nendp->queue_size -= 1;\r\nreturn -ENOMEM;\r\n} else {\r\nlist_add_tail(&urbq->urb_more,\r\n&endp->urb_more);\r\nurbq->urb = urb;\r\n}\r\n}\r\nreturn 0;\r\n} else {\r\nstruct u132_addr *addr = &u132->addr[usb_dev->devnum];\r\nint I = MAX_U132_UDEVS;\r\nint i = 0;\r\nwhile (--I > 0) {\r\nstruct u132_udev *udev = &u132->udev[++i];\r\nif (udev->usb_device) {\r\ncontinue;\r\n} else {\r\nudev->enumeration = 1;\r\nu132->addr[0].address = i;\r\nendp->udev_number = i;\r\nudev->udev_number = i;\r\nudev->usb_addr = usb_dev->devnum;\r\nu132_udev_init_kref(u132, udev);\r\nudev->endp_number_in[usb_endp] =\r\nendp->endp_number;\r\nu132_udev_get_kref(u132, udev);\r\nudev->endp_number_out[usb_endp] =\r\nendp->endp_number;\r\nudev->usb_device = usb_dev;\r\n((u8 *) (urb->setup_packet))[2] =\r\naddr->address = i;\r\nu132_udev_get_kref(u132, udev);\r\nbreak;\r\n}\r\n}\r\nif (I == 0) {\r\ndev_err(&u132->platform_dev->dev, "run out of d"\r\n"evice space\n");\r\nreturn -EINVAL;\r\n}\r\nurb->hcpriv = u132;\r\nif (endp->queue_size++ < ENDP_QUEUE_SIZE) {\r\nendp->urb_list[ENDP_QUEUE_MASK &\r\nendp->queue_last++] = urb;\r\n} else {\r\nstruct u132_urbq *urbq =\r\nkmalloc(sizeof(struct u132_urbq),\r\nGFP_ATOMIC);\r\nif (urbq == NULL) {\r\nendp->queue_size -= 1;\r\nreturn -ENOMEM;\r\n} else {\r\nlist_add_tail(&urbq->urb_more,\r\n&endp->urb_more);\r\nurbq->urb = urb;\r\n}\r\n}\r\nreturn 0;\r\n}\r\n} else {\r\nu8 address = u132->addr[usb_addr].address;\r\nstruct u132_udev *udev = &u132->udev[address];\r\nurb->hcpriv = u132;\r\nif (udev->enumeration != 2)\r\nudev->enumeration = 2;\r\nif (endp->queue_size++ < ENDP_QUEUE_SIZE) {\r\nendp->urb_list[ENDP_QUEUE_MASK & endp->queue_last++] =\r\nurb;\r\n} else {\r\nstruct u132_urbq *urbq =\r\nkmalloc(sizeof(struct u132_urbq), GFP_ATOMIC);\r\nif (urbq == NULL) {\r\nendp->queue_size -= 1;\r\nreturn -ENOMEM;\r\n} else {\r\nlist_add_tail(&urbq->urb_more, &endp->urb_more);\r\nurbq->urb = urb;\r\n}\r\n}\r\nreturn 0;\r\n}\r\n}\r\nstatic int u132_urb_enqueue(struct usb_hcd *hcd, struct urb *urb,\r\ngfp_t mem_flags)\r\n{\r\nstruct u132 *u132 = hcd_to_u132(hcd);\r\nif (irqs_disabled()) {\r\nif (__GFP_WAIT & mem_flags) {\r\nprintk(KERN_ERR "invalid context for function that migh"\r\n"t sleep\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\nif (u132->going > 1) {\r\ndev_err(&u132->platform_dev->dev, "device has been removed %d\n"\r\n, u132->going);\r\nreturn -ENODEV;\r\n} else if (u132->going > 0) {\r\ndev_err(&u132->platform_dev->dev, "device is being removed "\r\n"urb=%p\n", urb);\r\nreturn -ESHUTDOWN;\r\n} else {\r\nu8 usb_addr = usb_pipedevice(urb->pipe);\r\nu8 usb_endp = usb_pipeendpoint(urb->pipe);\r\nstruct usb_device *usb_dev = urb->dev;\r\nif (usb_pipetype(urb->pipe) == PIPE_INTERRUPT) {\r\nu8 address = u132->addr[usb_addr].address;\r\nstruct u132_udev *udev = &u132->udev[address];\r\nstruct u132_endp *endp = urb->ep->hcpriv;\r\nurb->actual_length = 0;\r\nif (endp) {\r\nunsigned long irqs;\r\nint retval;\r\nspin_lock_irqsave(&endp->queue_lock.slock,\r\nirqs);\r\nretval = usb_hcd_link_urb_to_ep(hcd, urb);\r\nif (retval == 0) {\r\nretval = queue_int_on_old_endpoint(\r\nu132, udev, urb,\r\nusb_dev, endp,\r\nusb_addr, usb_endp,\r\naddress);\r\nif (retval)\r\nusb_hcd_unlink_urb_from_ep(\r\nhcd, urb);\r\n}\r\nspin_unlock_irqrestore(&endp->queue_lock.slock,\r\nirqs);\r\nif (retval) {\r\nreturn retval;\r\n} else {\r\nu132_endp_queue_work(u132, endp,\r\nmsecs_to_jiffies(urb->interval))\r\n;\r\nreturn 0;\r\n}\r\n} else if (u132->num_endpoints == MAX_U132_ENDPS) {\r\nreturn -EINVAL;\r\n} else {\r\nreturn create_endpoint_and_queue_int(u132, udev,\r\nurb, usb_dev, usb_addr,\r\nusb_endp, address, mem_flags);\r\n}\r\n} else if (usb_pipetype(urb->pipe) == PIPE_ISOCHRONOUS) {\r\ndev_err(&u132->platform_dev->dev, "the hardware does no"\r\n"t support PIPE_ISOCHRONOUS\n");\r\nreturn -EINVAL;\r\n} else if (usb_pipetype(urb->pipe) == PIPE_BULK) {\r\nu8 address = u132->addr[usb_addr].address;\r\nstruct u132_udev *udev = &u132->udev[address];\r\nstruct u132_endp *endp = urb->ep->hcpriv;\r\nurb->actual_length = 0;\r\nif (endp) {\r\nunsigned long irqs;\r\nint retval;\r\nspin_lock_irqsave(&endp->queue_lock.slock,\r\nirqs);\r\nretval = usb_hcd_link_urb_to_ep(hcd, urb);\r\nif (retval == 0) {\r\nretval = queue_bulk_on_old_endpoint(\r\nu132, udev, urb,\r\nusb_dev, endp,\r\nusb_addr, usb_endp,\r\naddress);\r\nif (retval)\r\nusb_hcd_unlink_urb_from_ep(\r\nhcd, urb);\r\n}\r\nspin_unlock_irqrestore(&endp->queue_lock.slock,\r\nirqs);\r\nif (retval) {\r\nreturn retval;\r\n} else {\r\nu132_endp_queue_work(u132, endp, 0);\r\nreturn 0;\r\n}\r\n} else if (u132->num_endpoints == MAX_U132_ENDPS) {\r\nreturn -EINVAL;\r\n} else\r\nreturn create_endpoint_and_queue_bulk(u132,\r\nudev, urb, usb_dev, usb_addr,\r\nusb_endp, address, mem_flags);\r\n} else {\r\nstruct u132_endp *endp = urb->ep->hcpriv;\r\nu16 urb_size = 8;\r\nu8 *b = urb->setup_packet;\r\nint i = 0;\r\nchar data[30 * 3 + 4];\r\nchar *d = data;\r\nint m = (sizeof(data) - 1) / 3;\r\nint l = 0;\r\ndata[0] = 0;\r\nwhile (urb_size-- > 0) {\r\nif (i > m) {\r\n} else if (i++ < m) {\r\nint w = sprintf(d, " %02X", *b++);\r\nd += w;\r\nl += w;\r\n} else\r\nd += sprintf(d, " ..");\r\n}\r\nif (endp) {\r\nunsigned long irqs;\r\nint retval;\r\nspin_lock_irqsave(&endp->queue_lock.slock,\r\nirqs);\r\nretval = usb_hcd_link_urb_to_ep(hcd, urb);\r\nif (retval == 0) {\r\nretval = queue_control_on_old_endpoint(\r\nu132, urb, usb_dev,\r\nendp, usb_addr,\r\nusb_endp);\r\nif (retval)\r\nusb_hcd_unlink_urb_from_ep(\r\nhcd, urb);\r\n}\r\nspin_unlock_irqrestore(&endp->queue_lock.slock,\r\nirqs);\r\nif (retval) {\r\nreturn retval;\r\n} else {\r\nu132_endp_queue_work(u132, endp, 0);\r\nreturn 0;\r\n}\r\n} else if (u132->num_endpoints == MAX_U132_ENDPS) {\r\nreturn -EINVAL;\r\n} else\r\nreturn create_endpoint_and_queue_control(u132,\r\nurb, usb_dev, usb_addr, usb_endp,\r\nmem_flags);\r\n}\r\n}\r\n}\r\nstatic int dequeue_from_overflow_chain(struct u132 *u132,\r\nstruct u132_endp *endp, struct urb *urb)\r\n{\r\nstruct list_head *scan;\r\nstruct list_head *head = &endp->urb_more;\r\nlist_for_each(scan, head) {\r\nstruct u132_urbq *urbq = list_entry(scan, struct u132_urbq,\r\nurb_more);\r\nif (urbq->urb == urb) {\r\nstruct usb_hcd *hcd = u132_to_hcd(u132);\r\nlist_del(scan);\r\nendp->queue_size -= 1;\r\nurb->error_count = 0;\r\nusb_hcd_giveback_urb(hcd, urb, 0);\r\nreturn 0;\r\n} else\r\ncontinue;\r\n}\r\ndev_err(&u132->platform_dev->dev, "urb=%p not found in endp[%d]=%p ring"\r\n"[%d] %c%c usb_endp=%d usb_addr=%d size=%d next=%04X last=%04X"\r\n"\n", urb, endp->endp_number, endp, endp->ring->number,\r\nendp->input ? 'I' : ' ', endp->output ? 'O' : ' ',\r\nendp->usb_endp, endp->usb_addr, endp->queue_size,\r\nendp->queue_next, endp->queue_last);\r\nreturn -EINVAL;\r\n}\r\nstatic int u132_endp_urb_dequeue(struct u132 *u132, struct u132_endp *endp,\r\nstruct urb *urb, int status)\r\n{\r\nunsigned long irqs;\r\nint rc;\r\nspin_lock_irqsave(&endp->queue_lock.slock, irqs);\r\nrc = usb_hcd_check_unlink_urb(u132_to_hcd(u132), urb, status);\r\nif (rc) {\r\nspin_unlock_irqrestore(&endp->queue_lock.slock, irqs);\r\nreturn rc;\r\n}\r\nif (endp->queue_size == 0) {\r\ndev_err(&u132->platform_dev->dev, "urb=%p not found in endp[%d]"\r\n"=%p ring[%d] %c%c usb_endp=%d usb_addr=%d\n", urb,\r\nendp->endp_number, endp, endp->ring->number,\r\nendp->input ? 'I' : ' ', endp->output ? 'O' : ' ',\r\nendp->usb_endp, endp->usb_addr);\r\nspin_unlock_irqrestore(&endp->queue_lock.slock, irqs);\r\nreturn -EINVAL;\r\n}\r\nif (urb == endp->urb_list[ENDP_QUEUE_MASK & endp->queue_next]) {\r\nif (endp->active) {\r\nendp->dequeueing = 1;\r\nendp->edset_flush = 1;\r\nu132_endp_queue_work(u132, endp, 0);\r\nspin_unlock_irqrestore(&endp->queue_lock.slock, irqs);\r\nreturn 0;\r\n} else {\r\nspin_unlock_irqrestore(&endp->queue_lock.slock, irqs);\r\nu132_hcd_abandon_urb(u132, endp, urb, status);\r\nreturn 0;\r\n}\r\n} else {\r\nu16 queue_list = 0;\r\nu16 queue_size = endp->queue_size;\r\nu16 queue_scan = endp->queue_next;\r\nstruct urb **urb_slot = NULL;\r\nwhile (++queue_list < ENDP_QUEUE_SIZE && --queue_size > 0) {\r\nif (urb == endp->urb_list[ENDP_QUEUE_MASK &\r\n++queue_scan]) {\r\nurb_slot = &endp->urb_list[ENDP_QUEUE_MASK &\r\nqueue_scan];\r\nbreak;\r\n} else\r\ncontinue;\r\n}\r\nwhile (++queue_list < ENDP_QUEUE_SIZE && --queue_size > 0) {\r\n*urb_slot = endp->urb_list[ENDP_QUEUE_MASK &\r\n++queue_scan];\r\nurb_slot = &endp->urb_list[ENDP_QUEUE_MASK &\r\nqueue_scan];\r\n}\r\nif (urb_slot) {\r\nstruct usb_hcd *hcd = u132_to_hcd(u132);\r\nusb_hcd_unlink_urb_from_ep(hcd, urb);\r\nendp->queue_size -= 1;\r\nif (list_empty(&endp->urb_more)) {\r\nspin_unlock_irqrestore(&endp->queue_lock.slock,\r\nirqs);\r\n} else {\r\nstruct list_head *next = endp->urb_more.next;\r\nstruct u132_urbq *urbq = list_entry(next,\r\nstruct u132_urbq, urb_more);\r\nlist_del(next);\r\n*urb_slot = urbq->urb;\r\nspin_unlock_irqrestore(&endp->queue_lock.slock,\r\nirqs);\r\nkfree(urbq);\r\n} urb->error_count = 0;\r\nusb_hcd_giveback_urb(hcd, urb, status);\r\nreturn 0;\r\n} else if (list_empty(&endp->urb_more)) {\r\ndev_err(&u132->platform_dev->dev, "urb=%p not found in "\r\n"endp[%d]=%p ring[%d] %c%c usb_endp=%d usb_addr"\r\n"=%d size=%d next=%04X last=%04X\n", urb,\r\nendp->endp_number, endp, endp->ring->number,\r\nendp->input ? 'I' : ' ',\r\nendp->output ? 'O' : ' ', endp->usb_endp,\r\nendp->usb_addr, endp->queue_size,\r\nendp->queue_next, endp->queue_last);\r\nspin_unlock_irqrestore(&endp->queue_lock.slock, irqs);\r\nreturn -EINVAL;\r\n} else {\r\nint retval;\r\nusb_hcd_unlink_urb_from_ep(u132_to_hcd(u132), urb);\r\nretval = dequeue_from_overflow_chain(u132, endp,\r\nurb);\r\nspin_unlock_irqrestore(&endp->queue_lock.slock, irqs);\r\nreturn retval;\r\n}\r\n}\r\n}\r\nstatic int u132_urb_dequeue(struct usb_hcd *hcd, struct urb *urb, int status)\r\n{\r\nstruct u132 *u132 = hcd_to_u132(hcd);\r\nif (u132->going > 2) {\r\ndev_err(&u132->platform_dev->dev, "device has been removed %d\n"\r\n, u132->going);\r\nreturn -ENODEV;\r\n} else {\r\nu8 usb_addr = usb_pipedevice(urb->pipe);\r\nu8 usb_endp = usb_pipeendpoint(urb->pipe);\r\nu8 address = u132->addr[usb_addr].address;\r\nstruct u132_udev *udev = &u132->udev[address];\r\nif (usb_pipein(urb->pipe)) {\r\nu8 endp_number = udev->endp_number_in[usb_endp];\r\nstruct u132_endp *endp = u132->endp[endp_number - 1];\r\nreturn u132_endp_urb_dequeue(u132, endp, urb, status);\r\n} else {\r\nu8 endp_number = udev->endp_number_out[usb_endp];\r\nstruct u132_endp *endp = u132->endp[endp_number - 1];\r\nreturn u132_endp_urb_dequeue(u132, endp, urb, status);\r\n}\r\n}\r\n}\r\nstatic void u132_endpoint_disable(struct usb_hcd *hcd,\r\nstruct usb_host_endpoint *hep)\r\n{\r\nstruct u132 *u132 = hcd_to_u132(hcd);\r\nif (u132->going > 2) {\r\ndev_err(&u132->platform_dev->dev, "u132 device %p(hcd=%p hep=%p"\r\n") has been removed %d\n", u132, hcd, hep,\r\nu132->going);\r\n} else {\r\nstruct u132_endp *endp = hep->hcpriv;\r\nif (endp)\r\nu132_endp_put_kref(u132, endp);\r\n}\r\n}\r\nstatic int u132_get_frame(struct usb_hcd *hcd)\r\n{\r\nstruct u132 *u132 = hcd_to_u132(hcd);\r\nif (u132->going > 1) {\r\ndev_err(&u132->platform_dev->dev, "device has been removed %d\n"\r\n, u132->going);\r\nreturn -ENODEV;\r\n} else if (u132->going > 0) {\r\ndev_err(&u132->platform_dev->dev, "device is being removed\n");\r\nreturn -ESHUTDOWN;\r\n} else {\r\nint frame = 0;\r\ndev_err(&u132->platform_dev->dev, "TODO: u132_get_frame\n");\r\nmsleep(100);\r\nreturn frame;\r\n}\r\n}\r\nstatic int u132_roothub_descriptor(struct u132 *u132,\r\nstruct usb_hub_descriptor *desc)\r\n{\r\nint retval;\r\nu16 temp;\r\nu32 rh_a = -1;\r\nu32 rh_b = -1;\r\nretval = u132_read_pcimem(u132, roothub.a, &rh_a);\r\nif (retval)\r\nreturn retval;\r\ndesc->bDescriptorType = 0x29;\r\ndesc->bPwrOn2PwrGood = (rh_a & RH_A_POTPGT) >> 24;\r\ndesc->bHubContrCurrent = 0;\r\ndesc->bNbrPorts = u132->num_ports;\r\ntemp = 1 + (u132->num_ports / 8);\r\ndesc->bDescLength = 7 + 2 * temp;\r\ntemp = 0;\r\nif (rh_a & RH_A_NPS)\r\ntemp |= 0x0002;\r\nif (rh_a & RH_A_PSM)\r\ntemp |= 0x0001;\r\nif (rh_a & RH_A_NOCP)\r\ntemp |= 0x0010;\r\nelse if (rh_a & RH_A_OCPM)\r\ntemp |= 0x0008;\r\ndesc->wHubCharacteristics = cpu_to_le16(temp);\r\nretval = u132_read_pcimem(u132, roothub.b, &rh_b);\r\nif (retval)\r\nreturn retval;\r\nmemset(desc->u.hs.DeviceRemovable, 0xff,\r\nsizeof(desc->u.hs.DeviceRemovable));\r\ndesc->u.hs.DeviceRemovable[0] = rh_b & RH_B_DR;\r\nif (u132->num_ports > 7) {\r\ndesc->u.hs.DeviceRemovable[1] = (rh_b & RH_B_DR) >> 8;\r\ndesc->u.hs.DeviceRemovable[2] = 0xff;\r\n} else\r\ndesc->u.hs.DeviceRemovable[1] = 0xff;\r\nreturn 0;\r\n}\r\nstatic int u132_roothub_status(struct u132 *u132, __le32 *desc)\r\n{\r\nu32 rh_status = -1;\r\nint ret_status = u132_read_pcimem(u132, roothub.status, &rh_status);\r\n*desc = cpu_to_le32(rh_status);\r\nreturn ret_status;\r\n}\r\nstatic int u132_roothub_portstatus(struct u132 *u132, __le32 *desc, u16 wIndex)\r\n{\r\nif (wIndex == 0 || wIndex > u132->num_ports) {\r\nreturn -EINVAL;\r\n} else {\r\nint port = wIndex - 1;\r\nu32 rh_portstatus = -1;\r\nint ret_portstatus = u132_read_pcimem(u132,\r\nroothub.portstatus[port], &rh_portstatus);\r\n*desc = cpu_to_le32(rh_portstatus);\r\nif (*(u16 *) (desc + 2)) {\r\ndev_info(&u132->platform_dev->dev, "Port %d Status Chan"\r\n"ge = %08X\n", port, *desc);\r\n}\r\nreturn ret_portstatus;\r\n}\r\n}\r\nstatic int u132_roothub_portreset(struct u132 *u132, int port_index)\r\n{\r\nint retval;\r\nu32 fmnumber;\r\nu16 now;\r\nu16 reset_done;\r\nretval = u132_read_pcimem(u132, fmnumber, &fmnumber);\r\nif (retval)\r\nreturn retval;\r\nnow = fmnumber;\r\nreset_done = now + PORT_RESET_MSEC;\r\ndo {\r\nu32 portstat;\r\ndo {\r\nretval = u132_read_pcimem(u132,\r\nroothub.portstatus[port_index], &portstat);\r\nif (retval)\r\nreturn retval;\r\nif (RH_PS_PRS & portstat)\r\ncontinue;\r\nelse\r\nbreak;\r\n} while (tick_before(now, reset_done));\r\nif (RH_PS_PRS & portstat)\r\nreturn -ENODEV;\r\nif (RH_PS_CCS & portstat) {\r\nif (RH_PS_PRSC & portstat) {\r\nretval = u132_write_pcimem(u132,\r\nroothub.portstatus[port_index],\r\nRH_PS_PRSC);\r\nif (retval)\r\nreturn retval;\r\n}\r\n} else\r\nbreak;\r\nretval = u132_write_pcimem(u132, roothub.portstatus[port_index],\r\nRH_PS_PRS);\r\nif (retval)\r\nreturn retval;\r\nmsleep(PORT_RESET_HW_MSEC);\r\nretval = u132_read_pcimem(u132, fmnumber, &fmnumber);\r\nif (retval)\r\nreturn retval;\r\nnow = fmnumber;\r\n} while (tick_before(now, reset_done));\r\nreturn 0;\r\n}\r\nstatic int u132_roothub_setportfeature(struct u132 *u132, u16 wValue,\r\nu16 wIndex)\r\n{\r\nif (wIndex == 0 || wIndex > u132->num_ports) {\r\nreturn -EINVAL;\r\n} else {\r\nint retval;\r\nint port_index = wIndex - 1;\r\nstruct u132_port *port = &u132->port[port_index];\r\nport->Status &= ~(1 << wValue);\r\nswitch (wValue) {\r\ncase USB_PORT_FEAT_SUSPEND:\r\nretval = u132_write_pcimem(u132,\r\nroothub.portstatus[port_index], RH_PS_PSS);\r\nif (retval)\r\nreturn retval;\r\nreturn 0;\r\ncase USB_PORT_FEAT_POWER:\r\nretval = u132_write_pcimem(u132,\r\nroothub.portstatus[port_index], RH_PS_PPS);\r\nif (retval)\r\nreturn retval;\r\nreturn 0;\r\ncase USB_PORT_FEAT_RESET:\r\nretval = u132_roothub_portreset(u132, port_index);\r\nif (retval)\r\nreturn retval;\r\nreturn 0;\r\ndefault:\r\nreturn -EPIPE;\r\n}\r\n}\r\n}\r\nstatic int u132_roothub_clearportfeature(struct u132 *u132, u16 wValue,\r\nu16 wIndex)\r\n{\r\nif (wIndex == 0 || wIndex > u132->num_ports) {\r\nreturn -EINVAL;\r\n} else {\r\nint port_index = wIndex - 1;\r\nu32 temp;\r\nint retval;\r\nstruct u132_port *port = &u132->port[port_index];\r\nport->Status &= ~(1 << wValue);\r\nswitch (wValue) {\r\ncase USB_PORT_FEAT_ENABLE:\r\ntemp = RH_PS_CCS;\r\nbreak;\r\ncase USB_PORT_FEAT_C_ENABLE:\r\ntemp = RH_PS_PESC;\r\nbreak;\r\ncase USB_PORT_FEAT_SUSPEND:\r\ntemp = RH_PS_POCI;\r\nif ((u132->hc_control & OHCI_CTRL_HCFS)\r\n!= OHCI_USB_OPER) {\r\ndev_err(&u132->platform_dev->dev, "TODO resume_"\r\n"root_hub\n");\r\n}\r\nbreak;\r\ncase USB_PORT_FEAT_C_SUSPEND:\r\ntemp = RH_PS_PSSC;\r\nbreak;\r\ncase USB_PORT_FEAT_POWER:\r\ntemp = RH_PS_LSDA;\r\nbreak;\r\ncase USB_PORT_FEAT_C_CONNECTION:\r\ntemp = RH_PS_CSC;\r\nbreak;\r\ncase USB_PORT_FEAT_C_OVER_CURRENT:\r\ntemp = RH_PS_OCIC;\r\nbreak;\r\ncase USB_PORT_FEAT_C_RESET:\r\ntemp = RH_PS_PRSC;\r\nbreak;\r\ndefault:\r\nreturn -EPIPE;\r\n}\r\nretval = u132_write_pcimem(u132, roothub.portstatus[port_index],\r\ntemp);\r\nif (retval)\r\nreturn retval;\r\nreturn 0;\r\n}\r\n}\r\nstatic int u132_hub_status_data(struct usb_hcd *hcd, char *buf)\r\n{\r\nstruct u132 *u132 = hcd_to_u132(hcd);\r\nif (u132->going > 1) {\r\ndev_err(&u132->platform_dev->dev, "device hcd=%p has been remov"\r\n"ed %d\n", hcd, u132->going);\r\nreturn -ENODEV;\r\n} else if (u132->going > 0) {\r\ndev_err(&u132->platform_dev->dev, "device hcd=%p is being remov"\r\n"ed\n", hcd);\r\nreturn -ESHUTDOWN;\r\n} else {\r\nint i, changed = 0, length = 1;\r\nif (u132->flags & OHCI_QUIRK_AMD756) {\r\nif ((u132->hc_roothub_a & RH_A_NDP) > MAX_ROOT_PORTS) {\r\ndev_err(&u132->platform_dev->dev, "bogus NDP, r"\r\n"ereads as NDP=%d\n",\r\nu132->hc_roothub_a & RH_A_NDP);\r\ngoto done;\r\n}\r\n}\r\nif (u132->hc_roothub_status & (RH_HS_LPSC | RH_HS_OCIC))\r\nbuf[0] = changed = 1;\r\nelse\r\nbuf[0] = 0;\r\nif (u132->num_ports > 7) {\r\nbuf[1] = 0;\r\nlength++;\r\n}\r\nfor (i = 0; i < u132->num_ports; i++) {\r\nif (u132->hc_roothub_portstatus[i] & (RH_PS_CSC |\r\nRH_PS_PESC | RH_PS_PSSC | RH_PS_OCIC |\r\nRH_PS_PRSC)) {\r\nchanged = 1;\r\nif (i < 7)\r\nbuf[0] |= 1 << (i + 1);\r\nelse\r\nbuf[1] |= 1 << (i - 7);\r\ncontinue;\r\n}\r\nif (!(u132->hc_roothub_portstatus[i] & RH_PS_CCS))\r\ncontinue;\r\nif ((u132->hc_roothub_portstatus[i] & RH_PS_PSS))\r\ncontinue;\r\n}\r\ndone:\r\nreturn changed ? length : 0;\r\n}\r\n}\r\nstatic int u132_hub_control(struct usb_hcd *hcd, u16 typeReq, u16 wValue,\r\nu16 wIndex, char *buf, u16 wLength)\r\n{\r\nstruct u132 *u132 = hcd_to_u132(hcd);\r\nif (u132->going > 1) {\r\ndev_err(&u132->platform_dev->dev, "device has been removed %d\n"\r\n, u132->going);\r\nreturn -ENODEV;\r\n} else if (u132->going > 0) {\r\ndev_err(&u132->platform_dev->dev, "device is being removed\n");\r\nreturn -ESHUTDOWN;\r\n} else {\r\nint retval = 0;\r\nmutex_lock(&u132->sw_lock);\r\nswitch (typeReq) {\r\ncase ClearHubFeature:\r\nswitch (wValue) {\r\ncase C_HUB_OVER_CURRENT:\r\ncase C_HUB_LOCAL_POWER:\r\nbreak;\r\ndefault:\r\ngoto stall;\r\n}\r\nbreak;\r\ncase SetHubFeature:\r\nswitch (wValue) {\r\ncase C_HUB_OVER_CURRENT:\r\ncase C_HUB_LOCAL_POWER:\r\nbreak;\r\ndefault:\r\ngoto stall;\r\n}\r\nbreak;\r\ncase ClearPortFeature:{\r\nretval = u132_roothub_clearportfeature(u132,\r\nwValue, wIndex);\r\nif (retval)\r\ngoto error;\r\nbreak;\r\n}\r\ncase GetHubDescriptor:{\r\nretval = u132_roothub_descriptor(u132,\r\n(struct usb_hub_descriptor *)buf);\r\nif (retval)\r\ngoto error;\r\nbreak;\r\n}\r\ncase GetHubStatus:{\r\nretval = u132_roothub_status(u132,\r\n(__le32 *) buf);\r\nif (retval)\r\ngoto error;\r\nbreak;\r\n}\r\ncase GetPortStatus:{\r\nretval = u132_roothub_portstatus(u132,\r\n(__le32 *) buf, wIndex);\r\nif (retval)\r\ngoto error;\r\nbreak;\r\n}\r\ncase SetPortFeature:{\r\nretval = u132_roothub_setportfeature(u132,\r\nwValue, wIndex);\r\nif (retval)\r\ngoto error;\r\nbreak;\r\n}\r\ndefault:\r\ngoto stall;\r\nerror:\r\nu132_disable(u132);\r\nu132->going = 1;\r\nbreak;\r\nstall:\r\nretval = -EPIPE;\r\nbreak;\r\n}\r\nmutex_unlock(&u132->sw_lock);\r\nreturn retval;\r\n}\r\n}\r\nstatic int u132_start_port_reset(struct usb_hcd *hcd, unsigned port_num)\r\n{\r\nstruct u132 *u132 = hcd_to_u132(hcd);\r\nif (u132->going > 1) {\r\ndev_err(&u132->platform_dev->dev, "device has been removed %d\n"\r\n, u132->going);\r\nreturn -ENODEV;\r\n} else if (u132->going > 0) {\r\ndev_err(&u132->platform_dev->dev, "device is being removed\n");\r\nreturn -ESHUTDOWN;\r\n} else\r\nreturn 0;\r\n}\r\nstatic int u132_bus_suspend(struct usb_hcd *hcd)\r\n{\r\nstruct u132 *u132 = hcd_to_u132(hcd);\r\nif (u132->going > 1) {\r\ndev_err(&u132->platform_dev->dev, "device has been removed %d\n"\r\n, u132->going);\r\nreturn -ENODEV;\r\n} else if (u132->going > 0) {\r\ndev_err(&u132->platform_dev->dev, "device is being removed\n");\r\nreturn -ESHUTDOWN;\r\n} else\r\nreturn 0;\r\n}\r\nstatic int u132_bus_resume(struct usb_hcd *hcd)\r\n{\r\nstruct u132 *u132 = hcd_to_u132(hcd);\r\nif (u132->going > 1) {\r\ndev_err(&u132->platform_dev->dev, "device has been removed %d\n"\r\n, u132->going);\r\nreturn -ENODEV;\r\n} else if (u132->going > 0) {\r\ndev_err(&u132->platform_dev->dev, "device is being removed\n");\r\nreturn -ESHUTDOWN;\r\n} else\r\nreturn 0;\r\n}\r\nstatic int u132_remove(struct platform_device *pdev)\r\n{\r\nstruct usb_hcd *hcd = platform_get_drvdata(pdev);\r\nif (hcd) {\r\nstruct u132 *u132 = hcd_to_u132(hcd);\r\nif (u132->going++ > 1) {\r\ndev_err(&u132->platform_dev->dev, "already being remove"\r\n"d\n");\r\nreturn -ENODEV;\r\n} else {\r\nint rings = MAX_U132_RINGS;\r\nint endps = MAX_U132_ENDPS;\r\ndev_err(&u132->platform_dev->dev, "removing device u132"\r\n".%d\n", u132->sequence_num);\r\nmsleep(100);\r\nmutex_lock(&u132->sw_lock);\r\nu132_monitor_cancel_work(u132);\r\nwhile (rings-- > 0) {\r\nstruct u132_ring *ring = &u132->ring[rings];\r\nu132_ring_cancel_work(u132, ring);\r\n} while (endps-- > 0) {\r\nstruct u132_endp *endp = u132->endp[endps];\r\nif (endp)\r\nu132_endp_cancel_work(u132, endp);\r\n}\r\nu132->going += 1;\r\nprintk(KERN_INFO "removing device u132.%d\n",\r\nu132->sequence_num);\r\nmutex_unlock(&u132->sw_lock);\r\nusb_remove_hcd(hcd);\r\nu132_u132_put_kref(u132);\r\nreturn 0;\r\n}\r\n} else\r\nreturn 0;\r\n}\r\nstatic void u132_initialise(struct u132 *u132, struct platform_device *pdev)\r\n{\r\nint rings = MAX_U132_RINGS;\r\nint ports = MAX_U132_PORTS;\r\nint addrs = MAX_U132_ADDRS;\r\nint udevs = MAX_U132_UDEVS;\r\nint endps = MAX_U132_ENDPS;\r\nu132->board = pdev->dev.platform_data;\r\nu132->platform_dev = pdev;\r\nu132->power = 0;\r\nu132->reset = 0;\r\nmutex_init(&u132->sw_lock);\r\nmutex_init(&u132->scheduler_lock);\r\nwhile (rings-- > 0) {\r\nstruct u132_ring *ring = &u132->ring[rings];\r\nring->u132 = u132;\r\nring->number = rings + 1;\r\nring->length = 0;\r\nring->curr_endp = NULL;\r\nINIT_DELAYED_WORK(&ring->scheduler,\r\nu132_hcd_ring_work_scheduler);\r\n}\r\nmutex_lock(&u132->sw_lock);\r\nINIT_DELAYED_WORK(&u132->monitor, u132_hcd_monitor_work);\r\nwhile (ports-- > 0) {\r\nstruct u132_port *port = &u132->port[ports];\r\nport->u132 = u132;\r\nport->reset = 0;\r\nport->enable = 0;\r\nport->power = 0;\r\nport->Status = 0;\r\n}\r\nwhile (addrs-- > 0) {\r\nstruct u132_addr *addr = &u132->addr[addrs];\r\naddr->address = 0;\r\n}\r\nwhile (udevs-- > 0) {\r\nstruct u132_udev *udev = &u132->udev[udevs];\r\nint i = ARRAY_SIZE(udev->endp_number_in);\r\nint o = ARRAY_SIZE(udev->endp_number_out);\r\nudev->usb_device = NULL;\r\nudev->udev_number = 0;\r\nudev->usb_addr = 0;\r\nudev->portnumber = 0;\r\nwhile (i-- > 0)\r\nudev->endp_number_in[i] = 0;\r\nwhile (o-- > 0)\r\nudev->endp_number_out[o] = 0;\r\n}\r\nwhile (endps-- > 0)\r\nu132->endp[endps] = NULL;\r\nmutex_unlock(&u132->sw_lock);\r\n}\r\nstatic int u132_probe(struct platform_device *pdev)\r\n{\r\nstruct usb_hcd *hcd;\r\nint retval;\r\nu32 control;\r\nu32 rh_a = -1;\r\nu32 num_ports;\r\nmsleep(100);\r\nif (u132_exiting > 0)\r\nreturn -ENODEV;\r\nretval = ftdi_write_pcimem(pdev, intrdisable, OHCI_INTR_MIE);\r\nif (retval)\r\nreturn retval;\r\nretval = ftdi_read_pcimem(pdev, control, &control);\r\nif (retval)\r\nreturn retval;\r\nretval = ftdi_read_pcimem(pdev, roothub.a, &rh_a);\r\nif (retval)\r\nreturn retval;\r\nnum_ports = rh_a & RH_A_NDP;\r\nif (pdev->dev.dma_mask)\r\nreturn -EINVAL;\r\nhcd = usb_create_hcd(&u132_hc_driver, &pdev->dev, dev_name(&pdev->dev));\r\nif (!hcd) {\r\nprintk(KERN_ERR "failed to create the usb hcd struct for U132\n"\r\n);\r\nftdi_elan_gone_away(pdev);\r\nreturn -ENOMEM;\r\n} else {\r\nstruct u132 *u132 = hcd_to_u132(hcd);\r\nretval = 0;\r\nhcd->rsrc_start = 0;\r\nmutex_lock(&u132_module_lock);\r\nlist_add_tail(&u132->u132_list, &u132_static_list);\r\nu132->sequence_num = ++u132_instances;\r\nmutex_unlock(&u132_module_lock);\r\nu132_u132_init_kref(u132);\r\nu132_initialise(u132, pdev);\r\nhcd->product_desc = "ELAN U132 Host Controller";\r\nretval = usb_add_hcd(hcd, 0, 0);\r\nif (retval != 0) {\r\ndev_err(&u132->platform_dev->dev, "init error %d\n",\r\nretval);\r\nu132_u132_put_kref(u132);\r\nreturn retval;\r\n} else {\r\nu132_monitor_queue_work(u132, 100);\r\nreturn 0;\r\n}\r\n}\r\n}\r\nstatic int u132_suspend(struct platform_device *pdev, pm_message_t state)\r\n{\r\nstruct usb_hcd *hcd = platform_get_drvdata(pdev);\r\nstruct u132 *u132 = hcd_to_u132(hcd);\r\nif (u132->going > 1) {\r\ndev_err(&u132->platform_dev->dev, "device has been removed %d\n"\r\n, u132->going);\r\nreturn -ENODEV;\r\n} else if (u132->going > 0) {\r\ndev_err(&u132->platform_dev->dev, "device is being removed\n");\r\nreturn -ESHUTDOWN;\r\n} else {\r\nint retval = 0, ports;\r\nswitch (state.event) {\r\ncase PM_EVENT_FREEZE:\r\nretval = u132_bus_suspend(hcd);\r\nbreak;\r\ncase PM_EVENT_SUSPEND:\r\ncase PM_EVENT_HIBERNATE:\r\nports = MAX_U132_PORTS;\r\nwhile (ports-- > 0) {\r\nport_power(u132, ports, 0);\r\n}\r\nbreak;\r\n}\r\nreturn retval;\r\n}\r\n}\r\nstatic int u132_resume(struct platform_device *pdev)\r\n{\r\nstruct usb_hcd *hcd = platform_get_drvdata(pdev);\r\nstruct u132 *u132 = hcd_to_u132(hcd);\r\nif (u132->going > 1) {\r\ndev_err(&u132->platform_dev->dev, "device has been removed %d\n"\r\n, u132->going);\r\nreturn -ENODEV;\r\n} else if (u132->going > 0) {\r\ndev_err(&u132->platform_dev->dev, "device is being removed\n");\r\nreturn -ESHUTDOWN;\r\n} else {\r\nint retval = 0;\r\nif (!u132->port[0].power) {\r\nint ports = MAX_U132_PORTS;\r\nwhile (ports-- > 0) {\r\nport_power(u132, ports, 1);\r\n}\r\nretval = 0;\r\n} else {\r\nretval = u132_bus_resume(hcd);\r\n}\r\nreturn retval;\r\n}\r\n}\r\nstatic int __init u132_hcd_init(void)\r\n{\r\nint retval;\r\nINIT_LIST_HEAD(&u132_static_list);\r\nu132_instances = 0;\r\nu132_exiting = 0;\r\nmutex_init(&u132_module_lock);\r\nif (usb_disabled())\r\nreturn -ENODEV;\r\nprintk(KERN_INFO "driver %s\n", hcd_name);\r\nworkqueue = create_singlethread_workqueue("u132");\r\nretval = platform_driver_register(&u132_platform_driver);\r\nreturn retval;\r\n}\r\nstatic void __exit u132_hcd_exit(void)\r\n{\r\nstruct u132 *u132;\r\nstruct u132 *temp;\r\nmutex_lock(&u132_module_lock);\r\nu132_exiting += 1;\r\nmutex_unlock(&u132_module_lock);\r\nlist_for_each_entry_safe(u132, temp, &u132_static_list, u132_list) {\r\nplatform_device_unregister(u132->platform_dev);\r\n}\r\nplatform_driver_unregister(&u132_platform_driver);\r\nprintk(KERN_INFO "u132-hcd driver deregistered\n");\r\nwait_event(u132_hcd_wait, u132_instances == 0);\r\nflush_workqueue(workqueue);\r\ndestroy_workqueue(workqueue);\r\n}
