STATIC int\r\nxfs_trim_extents(\r\nstruct xfs_mount *mp,\r\nxfs_agnumber_t agno,\r\nxfs_daddr_t start,\r\nxfs_daddr_t end,\r\nxfs_daddr_t minlen,\r\n__uint64_t *blocks_trimmed)\r\n{\r\nstruct block_device *bdev = mp->m_ddev_targp->bt_bdev;\r\nstruct xfs_btree_cur *cur;\r\nstruct xfs_buf *agbp;\r\nstruct xfs_perag *pag;\r\nint error;\r\nint i;\r\npag = xfs_perag_get(mp, agno);\r\nerror = xfs_alloc_read_agf(mp, NULL, agno, 0, &agbp);\r\nif (error || !agbp)\r\ngoto out_put_perag;\r\ncur = xfs_allocbt_init_cursor(mp, NULL, agbp, agno, XFS_BTNUM_CNT);\r\nxfs_log_force(mp, XFS_LOG_SYNC);\r\nerror = xfs_alloc_lookup_ge(cur, 0,\r\nbe32_to_cpu(XFS_BUF_TO_AGF(agbp)->agf_longest), &i);\r\nif (error)\r\ngoto out_del_cursor;\r\nwhile (i) {\r\nxfs_agblock_t fbno;\r\nxfs_extlen_t flen;\r\nxfs_daddr_t dbno;\r\nxfs_extlen_t dlen;\r\nerror = xfs_alloc_get_rec(cur, &fbno, &flen, &i);\r\nif (error)\r\ngoto out_del_cursor;\r\nXFS_WANT_CORRUPTED_GOTO(i == 1, out_del_cursor);\r\nASSERT(flen <= be32_to_cpu(XFS_BUF_TO_AGF(agbp)->agf_longest));\r\ndbno = XFS_AGB_TO_DADDR(mp, agno, fbno);\r\ndlen = XFS_FSB_TO_BB(mp, flen);\r\nif (dlen < minlen) {\r\ntrace_xfs_discard_toosmall(mp, agno, fbno, flen);\r\ngoto out_del_cursor;\r\n}\r\nif (dbno + dlen < start || dbno > end) {\r\ntrace_xfs_discard_exclude(mp, agno, fbno, flen);\r\ngoto next_extent;\r\n}\r\nif (xfs_extent_busy_search(mp, agno, fbno, flen)) {\r\ntrace_xfs_discard_busy(mp, agno, fbno, flen);\r\ngoto next_extent;\r\n}\r\ntrace_xfs_discard_extent(mp, agno, fbno, flen);\r\nerror = -blkdev_issue_discard(bdev, dbno, dlen, GFP_NOFS, 0);\r\nif (error)\r\ngoto out_del_cursor;\r\n*blocks_trimmed += flen;\r\nnext_extent:\r\nerror = xfs_btree_decrement(cur, 0, &i);\r\nif (error)\r\ngoto out_del_cursor;\r\n}\r\nout_del_cursor:\r\nxfs_btree_del_cursor(cur, error ? XFS_BTREE_ERROR : XFS_BTREE_NOERROR);\r\nxfs_buf_relse(agbp);\r\nout_put_perag:\r\nxfs_perag_put(pag);\r\nreturn error;\r\n}\r\nint\r\nxfs_ioc_trim(\r\nstruct xfs_mount *mp,\r\nstruct fstrim_range __user *urange)\r\n{\r\nstruct request_queue *q = mp->m_ddev_targp->bt_bdev->bd_disk->queue;\r\nunsigned int granularity = q->limits.discard_granularity;\r\nstruct fstrim_range range;\r\nxfs_daddr_t start, end, minlen;\r\nxfs_agnumber_t start_agno, end_agno, agno;\r\n__uint64_t blocks_trimmed = 0;\r\nint error, last_error = 0;\r\nif (!capable(CAP_SYS_ADMIN))\r\nreturn -XFS_ERROR(EPERM);\r\nif (!blk_queue_discard(q))\r\nreturn -XFS_ERROR(EOPNOTSUPP);\r\nif (copy_from_user(&range, urange, sizeof(range)))\r\nreturn -XFS_ERROR(EFAULT);\r\nif (range.start >= XFS_FSB_TO_B(mp, mp->m_sb.sb_dblocks) ||\r\nrange.minlen > XFS_FSB_TO_B(mp, XFS_ALLOC_AG_MAX_USABLE(mp)))\r\nreturn -XFS_ERROR(EINVAL);\r\nstart = BTOBB(range.start);\r\nend = start + BTOBBT(range.len) - 1;\r\nminlen = BTOBB(max_t(u64, granularity, range.minlen));\r\nif (end > XFS_FSB_TO_BB(mp, mp->m_sb.sb_dblocks) - 1)\r\nend = XFS_FSB_TO_BB(mp, mp->m_sb.sb_dblocks)- 1;\r\nstart_agno = xfs_daddr_to_agno(mp, start);\r\nend_agno = xfs_daddr_to_agno(mp, end);\r\nfor (agno = start_agno; agno <= end_agno; agno++) {\r\nerror = -xfs_trim_extents(mp, agno, start, end, minlen,\r\n&blocks_trimmed);\r\nif (error)\r\nlast_error = error;\r\n}\r\nif (last_error)\r\nreturn last_error;\r\nrange.len = XFS_FSB_TO_B(mp, blocks_trimmed);\r\nif (copy_to_user(urange, &range, sizeof(range)))\r\nreturn -XFS_ERROR(EFAULT);\r\nreturn 0;\r\n}\r\nint\r\nxfs_discard_extents(\r\nstruct xfs_mount *mp,\r\nstruct list_head *list)\r\n{\r\nstruct xfs_extent_busy *busyp;\r\nint error = 0;\r\nlist_for_each_entry(busyp, list, list) {\r\ntrace_xfs_discard_extent(mp, busyp->agno, busyp->bno,\r\nbusyp->length);\r\nerror = -blkdev_issue_discard(mp->m_ddev_targp->bt_bdev,\r\nXFS_AGB_TO_DADDR(mp, busyp->agno, busyp->bno),\r\nXFS_FSB_TO_BB(mp, busyp->length),\r\nGFP_NOFS, 0);\r\nif (error && error != EOPNOTSUPP) {\r\nxfs_info(mp,\r\n"discard failed for extent [0x%llu,%u], error %d",\r\n(unsigned long long)busyp->bno,\r\nbusyp->length,\r\nerror);\r\nreturn error;\r\n}\r\n}\r\nreturn 0;\r\n}
