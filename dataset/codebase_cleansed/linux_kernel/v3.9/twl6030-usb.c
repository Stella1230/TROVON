static inline int twl6030_writeb(struct twl6030_usb *twl, u8 module,\r\nu8 data, u8 address)\r\n{\r\nint ret = 0;\r\nret = twl_i2c_write_u8(module, data, address);\r\nif (ret < 0)\r\ndev_err(twl->dev,\r\n"Write[0x%x] Error %d\n", address, ret);\r\nreturn ret;\r\n}\r\nstatic inline u8 twl6030_readb(struct twl6030_usb *twl, u8 module, u8 address)\r\n{\r\nu8 data, ret = 0;\r\nret = twl_i2c_read_u8(module, &data, address);\r\nif (ret >= 0)\r\nret = data;\r\nelse\r\ndev_err(twl->dev,\r\n"readb[0x%x,0x%x] Error %d\n",\r\nmodule, address, ret);\r\nreturn ret;\r\n}\r\nstatic int twl6030_start_srp(struct phy_companion *comparator)\r\n{\r\nstruct twl6030_usb *twl = comparator_to_twl(comparator);\r\ntwl6030_writeb(twl, TWL_MODULE_USB, 0x24, USB_VBUS_CTRL_SET);\r\ntwl6030_writeb(twl, TWL_MODULE_USB, 0x84, USB_VBUS_CTRL_SET);\r\nmdelay(100);\r\ntwl6030_writeb(twl, TWL_MODULE_USB, 0xa0, USB_VBUS_CTRL_CLR);\r\nreturn 0;\r\n}\r\nstatic int twl6030_usb_ldo_init(struct twl6030_usb *twl)\r\n{\r\ntwl6030_writeb(twl, TWL6030_MODULE_ID0 , 0x1, TWL6030_BACKUP_REG);\r\ntwl6030_writeb(twl, TWL6030_MODULE_ID0 , 0x1, TWL6030_CFG_LDO_PD2);\r\ntwl6030_writeb(twl, TWL6030_MODULE_ID0 , 0x10, TWL6030_MISC2);\r\ntwl->usb3v3 = regulator_get(twl->dev, twl->regulator);\r\nif (IS_ERR(twl->usb3v3))\r\nreturn -ENODEV;\r\ntwl6030_writeb(twl, TWL_MODULE_USB, 0x4, USB_VBUS_CTRL_SET);\r\ntwl6030_writeb(twl, TWL_MODULE_USB, 0x14, USB_ID_CTRL_SET);\r\nreturn 0;\r\n}\r\nstatic ssize_t twl6030_usb_vbus_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct twl6030_usb *twl = dev_get_drvdata(dev);\r\nunsigned long flags;\r\nint ret = -EINVAL;\r\nspin_lock_irqsave(&twl->lock, flags);\r\nswitch (twl->linkstat) {\r\ncase OMAP_MUSB_VBUS_VALID:\r\nret = snprintf(buf, PAGE_SIZE, "vbus\n");\r\nbreak;\r\ncase OMAP_MUSB_ID_GROUND:\r\nret = snprintf(buf, PAGE_SIZE, "id\n");\r\nbreak;\r\ncase OMAP_MUSB_VBUS_OFF:\r\nret = snprintf(buf, PAGE_SIZE, "none\n");\r\nbreak;\r\ndefault:\r\nret = snprintf(buf, PAGE_SIZE, "UNKNOWN\n");\r\n}\r\nspin_unlock_irqrestore(&twl->lock, flags);\r\nreturn ret;\r\n}\r\nstatic irqreturn_t twl6030_usb_irq(int irq, void *_twl)\r\n{\r\nstruct twl6030_usb *twl = _twl;\r\nenum omap_musb_vbus_id_status status = OMAP_MUSB_UNKNOWN;\r\nu8 vbus_state, hw_state;\r\nhw_state = twl6030_readb(twl, TWL6030_MODULE_ID0, STS_HW_CONDITIONS);\r\nvbus_state = twl6030_readb(twl, TWL_MODULE_MAIN_CHARGE,\r\nCONTROLLER_STAT1);\r\nif (!(hw_state & STS_USB_ID)) {\r\nif (vbus_state & VBUS_DET) {\r\nregulator_enable(twl->usb3v3);\r\ntwl->asleep = 1;\r\nstatus = OMAP_MUSB_VBUS_VALID;\r\ntwl->linkstat = status;\r\nomap_musb_mailbox(status);\r\n} else {\r\nif (twl->linkstat != OMAP_MUSB_UNKNOWN) {\r\nstatus = OMAP_MUSB_VBUS_OFF;\r\ntwl->linkstat = status;\r\nomap_musb_mailbox(status);\r\nif (twl->asleep) {\r\nregulator_disable(twl->usb3v3);\r\ntwl->asleep = 0;\r\n}\r\n}\r\n}\r\n}\r\nsysfs_notify(&twl->dev->kobj, NULL, "vbus");\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t twl6030_usbotg_irq(int irq, void *_twl)\r\n{\r\nstruct twl6030_usb *twl = _twl;\r\nenum omap_musb_vbus_id_status status = OMAP_MUSB_UNKNOWN;\r\nu8 hw_state;\r\nhw_state = twl6030_readb(twl, TWL6030_MODULE_ID0, STS_HW_CONDITIONS);\r\nif (hw_state & STS_USB_ID) {\r\nregulator_enable(twl->usb3v3);\r\ntwl->asleep = 1;\r\ntwl6030_writeb(twl, TWL_MODULE_USB, 0x1, USB_ID_INT_EN_HI_CLR);\r\ntwl6030_writeb(twl, TWL_MODULE_USB, 0x10, USB_ID_INT_EN_HI_SET);\r\nstatus = OMAP_MUSB_ID_GROUND;\r\ntwl->linkstat = status;\r\nomap_musb_mailbox(status);\r\n} else {\r\ntwl6030_writeb(twl, TWL_MODULE_USB, 0x10, USB_ID_INT_EN_HI_CLR);\r\ntwl6030_writeb(twl, TWL_MODULE_USB, 0x1, USB_ID_INT_EN_HI_SET);\r\n}\r\ntwl6030_writeb(twl, TWL_MODULE_USB, status, USB_ID_INT_LATCH_CLR);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int twl6030_enable_irq(struct twl6030_usb *twl)\r\n{\r\ntwl6030_writeb(twl, TWL_MODULE_USB, 0x1, USB_ID_INT_EN_HI_SET);\r\ntwl6030_interrupt_unmask(0x05, REG_INT_MSK_LINE_C);\r\ntwl6030_interrupt_unmask(0x05, REG_INT_MSK_STS_C);\r\ntwl6030_interrupt_unmask(TWL6030_CHARGER_CTRL_INT_MASK,\r\nREG_INT_MSK_LINE_C);\r\ntwl6030_interrupt_unmask(TWL6030_CHARGER_CTRL_INT_MASK,\r\nREG_INT_MSK_STS_C);\r\ntwl6030_usb_irq(twl->irq2, twl);\r\ntwl6030_usbotg_irq(twl->irq1, twl);\r\nreturn 0;\r\n}\r\nstatic void otg_set_vbus_work(struct work_struct *data)\r\n{\r\nstruct twl6030_usb *twl = container_of(data, struct twl6030_usb,\r\nset_vbus_work);\r\nif (twl->vbus_enable)\r\ntwl6030_writeb(twl, TWL_MODULE_MAIN_CHARGE , 0x40,\r\nCHARGERUSB_CTRL1);\r\nelse\r\ntwl6030_writeb(twl, TWL_MODULE_MAIN_CHARGE , 0x00,\r\nCHARGERUSB_CTRL1);\r\n}\r\nstatic int twl6030_set_vbus(struct phy_companion *comparator, bool enabled)\r\n{\r\nstruct twl6030_usb *twl = comparator_to_twl(comparator);\r\ntwl->vbus_enable = enabled;\r\nschedule_work(&twl->set_vbus_work);\r\nreturn 0;\r\n}\r\nstatic int twl6030_usb_probe(struct platform_device *pdev)\r\n{\r\nu32 ret;\r\nstruct twl6030_usb *twl;\r\nint status, err;\r\nstruct device_node *np = pdev->dev.of_node;\r\nstruct device *dev = &pdev->dev;\r\nstruct twl4030_usb_data *pdata = dev->platform_data;\r\ntwl = devm_kzalloc(dev, sizeof *twl, GFP_KERNEL);\r\nif (!twl)\r\nreturn -ENOMEM;\r\ntwl->dev = &pdev->dev;\r\ntwl->irq1 = platform_get_irq(pdev, 0);\r\ntwl->irq2 = platform_get_irq(pdev, 1);\r\ntwl->linkstat = OMAP_MUSB_UNKNOWN;\r\ntwl->comparator.set_vbus = twl6030_set_vbus;\r\ntwl->comparator.start_srp = twl6030_start_srp;\r\nret = omap_usb2_set_comparator(&twl->comparator);\r\nif (ret == -ENODEV) {\r\ndev_info(&pdev->dev, "phy not ready, deferring probe");\r\nreturn -EPROBE_DEFER;\r\n}\r\nif (np) {\r\ntwl->regulator = "usb";\r\n} else if (pdata) {\r\nif (pdata->features & TWL6025_SUBCLASS)\r\ntwl->regulator = "ldousb";\r\nelse\r\ntwl->regulator = "vusb";\r\n} else {\r\ndev_err(&pdev->dev, "twl6030 initialized without pdata\n");\r\nreturn -EINVAL;\r\n}\r\nspin_lock_init(&twl->lock);\r\nerr = twl6030_usb_ldo_init(twl);\r\nif (err) {\r\ndev_err(&pdev->dev, "ldo init failed\n");\r\nreturn err;\r\n}\r\nplatform_set_drvdata(pdev, twl);\r\nif (device_create_file(&pdev->dev, &dev_attr_vbus))\r\ndev_warn(&pdev->dev, "could not create sysfs file\n");\r\nINIT_WORK(&twl->set_vbus_work, otg_set_vbus_work);\r\ntwl->irq_enabled = true;\r\nstatus = request_threaded_irq(twl->irq1, NULL, twl6030_usbotg_irq,\r\nIRQF_TRIGGER_FALLING | IRQF_TRIGGER_RISING | IRQF_ONESHOT,\r\n"twl6030_usb", twl);\r\nif (status < 0) {\r\ndev_err(&pdev->dev, "can't get IRQ %d, err %d\n",\r\ntwl->irq1, status);\r\ndevice_remove_file(twl->dev, &dev_attr_vbus);\r\nreturn status;\r\n}\r\nstatus = request_threaded_irq(twl->irq2, NULL, twl6030_usb_irq,\r\nIRQF_TRIGGER_FALLING | IRQF_TRIGGER_RISING | IRQF_ONESHOT,\r\n"twl6030_usb", twl);\r\nif (status < 0) {\r\ndev_err(&pdev->dev, "can't get IRQ %d, err %d\n",\r\ntwl->irq2, status);\r\nfree_irq(twl->irq1, twl);\r\ndevice_remove_file(twl->dev, &dev_attr_vbus);\r\nreturn status;\r\n}\r\ntwl->asleep = 0;\r\ntwl6030_enable_irq(twl);\r\ndev_info(&pdev->dev, "Initialized TWL6030 USB module\n");\r\nreturn 0;\r\n}\r\nstatic int __exit twl6030_usb_remove(struct platform_device *pdev)\r\n{\r\nstruct twl6030_usb *twl = platform_get_drvdata(pdev);\r\ntwl6030_interrupt_mask(TWL6030_USBOTG_INT_MASK,\r\nREG_INT_MSK_LINE_C);\r\ntwl6030_interrupt_mask(TWL6030_USBOTG_INT_MASK,\r\nREG_INT_MSK_STS_C);\r\nfree_irq(twl->irq1, twl);\r\nfree_irq(twl->irq2, twl);\r\nregulator_put(twl->usb3v3);\r\ndevice_remove_file(twl->dev, &dev_attr_vbus);\r\ncancel_work_sync(&twl->set_vbus_work);\r\nreturn 0;\r\n}\r\nstatic int __init twl6030_usb_init(void)\r\n{\r\nreturn platform_driver_register(&twl6030_usb_driver);\r\n}\r\nstatic void __exit twl6030_usb_exit(void)\r\n{\r\nplatform_driver_unregister(&twl6030_usb_driver);\r\n}
