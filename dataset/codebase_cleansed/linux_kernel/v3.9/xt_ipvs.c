static bool ipvs_mt_addrcmp(const union nf_inet_addr *kaddr,\r\nconst union nf_inet_addr *uaddr,\r\nconst union nf_inet_addr *umask,\r\nunsigned int l3proto)\r\n{\r\nif (l3proto == NFPROTO_IPV4)\r\nreturn ((kaddr->ip ^ uaddr->ip) & umask->ip) == 0;\r\n#ifdef CONFIG_IP_VS_IPV6\r\nelse if (l3proto == NFPROTO_IPV6)\r\nreturn ipv6_masked_addr_cmp(&kaddr->in6, &umask->in6,\r\n&uaddr->in6) == 0;\r\n#endif\r\nelse\r\nreturn false;\r\n}\r\nstatic bool\r\nipvs_mt(const struct sk_buff *skb, struct xt_action_param *par)\r\n{\r\nconst struct xt_ipvs_mtinfo *data = par->matchinfo;\r\nconst u_int8_t family = par->family;\r\nstruct ip_vs_iphdr iph;\r\nstruct ip_vs_protocol *pp;\r\nstruct ip_vs_conn *cp;\r\nbool match = true;\r\nif (data->bitmask == XT_IPVS_IPVS_PROPERTY) {\r\nmatch = skb->ipvs_property ^\r\n!!(data->invert & XT_IPVS_IPVS_PROPERTY);\r\ngoto out;\r\n}\r\nif (!skb->ipvs_property) {\r\nmatch = false;\r\ngoto out;\r\n}\r\nip_vs_fill_iph_skb(family, skb, &iph);\r\nif (data->bitmask & XT_IPVS_PROTO)\r\nif ((iph.protocol == data->l4proto) ^\r\n!(data->invert & XT_IPVS_PROTO)) {\r\nmatch = false;\r\ngoto out;\r\n}\r\npp = ip_vs_proto_get(iph.protocol);\r\nif (unlikely(!pp)) {\r\nmatch = false;\r\ngoto out;\r\n}\r\ncp = pp->conn_out_get(family, skb, &iph, 1 );\r\nif (unlikely(cp == NULL)) {\r\nmatch = false;\r\ngoto out;\r\n}\r\nif (data->bitmask & XT_IPVS_VPORT)\r\nif ((cp->vport == data->vport) ^\r\n!(data->invert & XT_IPVS_VPORT)) {\r\nmatch = false;\r\ngoto out_put_cp;\r\n}\r\nif (data->bitmask & XT_IPVS_VPORTCTL)\r\nif ((cp->control != NULL &&\r\ncp->control->vport == data->vportctl) ^\r\n!(data->invert & XT_IPVS_VPORTCTL)) {\r\nmatch = false;\r\ngoto out_put_cp;\r\n}\r\nif (data->bitmask & XT_IPVS_DIR) {\r\nenum ip_conntrack_info ctinfo;\r\nstruct nf_conn *ct = nf_ct_get(skb, &ctinfo);\r\nif (ct == NULL || nf_ct_is_untracked(ct)) {\r\nmatch = false;\r\ngoto out_put_cp;\r\n}\r\nif ((ctinfo >= IP_CT_IS_REPLY) ^\r\n!!(data->invert & XT_IPVS_DIR)) {\r\nmatch = false;\r\ngoto out_put_cp;\r\n}\r\n}\r\nif (data->bitmask & XT_IPVS_METHOD)\r\nif (((cp->flags & IP_VS_CONN_F_FWD_MASK) == data->fwd_method) ^\r\n!(data->invert & XT_IPVS_METHOD)) {\r\nmatch = false;\r\ngoto out_put_cp;\r\n}\r\nif (data->bitmask & XT_IPVS_VADDR) {\r\nif (ipvs_mt_addrcmp(&cp->vaddr, &data->vaddr,\r\n&data->vmask, family) ^\r\n!(data->invert & XT_IPVS_VADDR)) {\r\nmatch = false;\r\ngoto out_put_cp;\r\n}\r\n}\r\nout_put_cp:\r\n__ip_vs_conn_put(cp);\r\nout:\r\npr_debug("match=%d\n", match);\r\nreturn match;\r\n}\r\nstatic int ipvs_mt_check(const struct xt_mtchk_param *par)\r\n{\r\nif (par->family != NFPROTO_IPV4\r\n#ifdef CONFIG_IP_VS_IPV6\r\n&& par->family != NFPROTO_IPV6\r\n#endif\r\n) {\r\npr_info("protocol family %u not supported\n", par->family);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init ipvs_mt_init(void)\r\n{\r\nreturn xt_register_match(&xt_ipvs_mt_reg);\r\n}\r\nstatic void __exit ipvs_mt_exit(void)\r\n{\r\nxt_unregister_match(&xt_ipvs_mt_reg);\r\n}
