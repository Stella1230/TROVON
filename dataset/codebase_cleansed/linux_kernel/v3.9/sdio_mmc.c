static CsrResult\r\nConvertSdioToCsrSdioResult(int r)\r\n{\r\nCsrResult csrResult = CSR_RESULT_FAILURE;\r\nswitch (r) {\r\ncase 0:\r\ncsrResult = CSR_RESULT_SUCCESS;\r\nbreak;\r\ncase -EIO:\r\ncase -EILSEQ:\r\ncsrResult = CSR_SDIO_RESULT_CRC_ERROR;\r\nbreak;\r\ncase -ETIMEDOUT:\r\ncase -EBUSY:\r\ncsrResult = CSR_SDIO_RESULT_TIMEOUT;\r\nbreak;\r\ncase -ENODEV:\r\ncase -ENOMEDIUM:\r\ncsrResult = CSR_SDIO_RESULT_NO_DEVICE;\r\nbreak;\r\ncase -EINVAL:\r\ncsrResult = CSR_SDIO_RESULT_INVALID_VALUE;\r\nbreak;\r\ncase -ENOMEM:\r\ncase -ENOSYS:\r\ncase -ERANGE:\r\ncase -ENXIO:\r\ncsrResult = CSR_RESULT_FAILURE;\r\nbreak;\r\ndefault:\r\nunifi_warning(NULL, "Unrecognised SDIO error code: %d\n", r);\r\nbreak;\r\n}\r\nreturn csrResult;\r\n}\r\nstatic int\r\ncsr_io_rw_direct(struct mmc_card *card, int write, uint8_t fn,\r\nuint32_t addr, uint8_t in, uint8_t* out)\r\n{\r\nstruct mmc_command cmd;\r\nint err;\r\nBUG_ON(!card);\r\nBUG_ON(fn > 7);\r\nmemset(&cmd, 0, sizeof(struct mmc_command));\r\ncmd.opcode = SD_IO_RW_DIRECT;\r\ncmd.arg = write ? 0x80000000 : 0x00000000;\r\ncmd.arg |= fn << 28;\r\ncmd.arg |= (write && out) ? 0x08000000 : 0x00000000;\r\ncmd.arg |= addr << 9;\r\ncmd.arg |= in;\r\ncmd.flags = MMC_RSP_SPI_R5 | MMC_RSP_R5 | MMC_CMD_AC;\r\nerr = mmc_wait_for_cmd(card->host, &cmd, 0);\r\nif (err)\r\nreturn err;\r\nif (0) {\r\n} else {\r\nif (cmd.resp[0] & R5_ERROR) {\r\nprintk(KERN_ERR "%s: r5 error 0x%02x\n",\r\n__FUNCTION__, cmd.resp[0]);\r\nreturn -EIO;\r\n}\r\nif (cmd.resp[0] & R5_FUNCTION_NUMBER)\r\nreturn -EINVAL;\r\nif (cmd.resp[0] & R5_OUT_OF_RANGE)\r\nreturn -ERANGE;\r\n}\r\nif (out) {\r\nif (0) {\r\n*out = (cmd.resp[0] >> 8) & 0xFF;\r\n}\r\nelse {\r\n*out = cmd.resp[0] & 0xFF;\r\n}\r\n}\r\nreturn CSR_RESULT_SUCCESS;\r\n}\r\nCsrResult\r\nCsrSdioRead8(CsrSdioFunction *function, u32 address, u8 *data)\r\n{\r\nstruct sdio_func *func = (struct sdio_func *)function->priv;\r\nint err = 0;\r\n_sdio_claim_host(func);\r\n*data = sdio_readb(func, address, &err);\r\n_sdio_release_host(func);\r\nif (err) {\r\nreturn ConvertSdioToCsrSdioResult(err);\r\n}\r\nreturn CSR_RESULT_SUCCESS;\r\n}\r\nCsrResult\r\nCsrSdioWrite8(CsrSdioFunction *function, u32 address, u8 data)\r\n{\r\nstruct sdio_func *func = (struct sdio_func *)function->priv;\r\nint err = 0;\r\n_sdio_claim_host(func);\r\nsdio_writeb(func, data, address, &err);\r\n_sdio_release_host(func);\r\nif (err) {\r\nreturn ConvertSdioToCsrSdioResult(err);\r\n}\r\nreturn CSR_RESULT_SUCCESS;\r\n}\r\nCsrResult\r\nCsrSdioRead16(CsrSdioFunction *function, u32 address, u16 *data)\r\n{\r\nstruct sdio_func *func = (struct sdio_func *)function->priv;\r\nint err;\r\nuint8_t b0, b1;\r\n_sdio_claim_host(func);\r\nb0 = sdio_readb(func, address, &err);\r\nif (err) {\r\n_sdio_release_host(func);\r\nreturn ConvertSdioToCsrSdioResult(err);\r\n}\r\nb1 = sdio_readb(func, address+1, &err);\r\nif (err) {\r\n_sdio_release_host(func);\r\nreturn ConvertSdioToCsrSdioResult(err);\r\n}\r\n_sdio_release_host(func);\r\n*data = ((uint16_t)b1 << 8) | b0;\r\nreturn CSR_RESULT_SUCCESS;\r\n}\r\nCsrResult\r\nCsrSdioWrite16(CsrSdioFunction *function, u32 address, u16 data)\r\n{\r\nstruct sdio_func *func = (struct sdio_func *)function->priv;\r\nint err;\r\nuint8_t b0, b1;\r\n_sdio_claim_host(func);\r\nb1 = (data >> 8) & 0xFF;\r\nsdio_writeb(func, b1, address+1, &err);\r\nif (err) {\r\n_sdio_release_host(func);\r\nreturn ConvertSdioToCsrSdioResult(err);\r\n}\r\nb0 = data & 0xFF;\r\nsdio_writeb(func, b0, address, &err);\r\nif (err) {\r\n_sdio_release_host(func);\r\nreturn ConvertSdioToCsrSdioResult(err);\r\n}\r\n_sdio_release_host(func);\r\nreturn CSR_RESULT_SUCCESS;\r\n}\r\nCsrResult\r\nCsrSdioF0Read8(CsrSdioFunction *function, u32 address, u8 *data)\r\n{\r\nstruct sdio_func *func = (struct sdio_func *)function->priv;\r\nint err = 0;\r\n_sdio_claim_host(func);\r\n#ifdef MMC_QUIRK_LENIENT_FN0\r\n*data = sdio_f0_readb(func, address, &err);\r\n#else\r\nerr = csr_io_rw_direct(func->card, 0, 0, address, 0, data);\r\n#endif\r\n_sdio_release_host(func);\r\nif (err) {\r\nreturn ConvertSdioToCsrSdioResult(err);\r\n}\r\nreturn CSR_RESULT_SUCCESS;\r\n}\r\nCsrResult\r\nCsrSdioF0Write8(CsrSdioFunction *function, u32 address, u8 data)\r\n{\r\nstruct sdio_func *func = (struct sdio_func *)function->priv;\r\nint err = 0;\r\n_sdio_claim_host(func);\r\n#ifdef MMC_QUIRK_LENIENT_FN0\r\nsdio_f0_writeb(func, data, address, &err);\r\n#else\r\nerr = csr_io_rw_direct(func->card, 1, 0, address, data, NULL);\r\n#endif\r\n_sdio_release_host(func);\r\nif (err) {\r\nreturn ConvertSdioToCsrSdioResult(err);\r\n}\r\nreturn CSR_RESULT_SUCCESS;\r\n}\r\nCsrResult\r\nCsrSdioRead(CsrSdioFunction *function, u32 address, void *data, u32 length)\r\n{\r\nstruct sdio_func *func = (struct sdio_func *)function->priv;\r\nint err;\r\n_sdio_claim_host(func);\r\nerr = sdio_readsb(func, data, address, length);\r\n_sdio_release_host(func);\r\nif (err) {\r\nreturn ConvertSdioToCsrSdioResult(err);\r\n}\r\nreturn CSR_RESULT_SUCCESS;\r\n}\r\nCsrResult\r\nCsrSdioWrite(CsrSdioFunction *function, u32 address, const void *data, u32 length)\r\n{\r\nstruct sdio_func *func = (struct sdio_func *)function->priv;\r\nint err;\r\n_sdio_claim_host(func);\r\nerr = sdio_writesb(func, address, (void*)data, length);\r\n_sdio_release_host(func);\r\nif (err) {\r\nreturn ConvertSdioToCsrSdioResult(err);\r\n}\r\nreturn CSR_RESULT_SUCCESS;\r\n}\r\nstatic int\r\ncsr_sdio_enable_hs(struct mmc_card *card)\r\n{\r\nint ret;\r\nu8 speed;\r\nif (!(card->host->caps & MMC_CAP_SD_HIGHSPEED)) {\r\nprintk(KERN_INFO "unifi: request HS but not MMC_CAP_SD_HIGHSPEED");\r\nreturn 0;\r\n}\r\nif (!card->cccr.high_speed)\r\nreturn 0;\r\n#if 1\r\nret = csr_io_rw_direct(card, 0, 0, SDIO_CCCR_SPEED, 0, &speed);\r\nif (ret)\r\nreturn ret;\r\nspeed |= SDIO_SPEED_EHS;\r\n#else\r\nspeed = SDIO_SPEED_EHS | SDIO_SPEED_SHS;\r\n#endif\r\nret = csr_io_rw_direct(card, 1, 0, SDIO_CCCR_SPEED, speed, NULL);\r\nif (ret)\r\nreturn ret;\r\nmmc_card_set_highspeed(card);\r\ncard->host->ios.timing = MMC_TIMING_SD_HS;\r\ncard->host->ops->set_ios(card->host, &card->host->ios);\r\nreturn 0;\r\n}\r\nstatic int\r\ncsr_sdio_disable_hs(struct mmc_card *card)\r\n{\r\nint ret;\r\nu8 speed;\r\nif (!(card->host->caps & MMC_CAP_SD_HIGHSPEED))\r\nreturn 0;\r\nif (!card->cccr.high_speed)\r\nreturn 0;\r\n#if 1\r\nret = csr_io_rw_direct(card, 0, 0, SDIO_CCCR_SPEED, 0, &speed);\r\nif (ret)\r\nreturn ret;\r\nspeed &= ~SDIO_SPEED_EHS;\r\n#else\r\nspeed = SDIO_SPEED_SHS;\r\n#endif\r\nret = csr_io_rw_direct(card, 1, 0, SDIO_CCCR_SPEED, speed, NULL);\r\nif (ret)\r\nreturn ret;\r\ncard->state &= ~MMC_STATE_HIGHSPEED;\r\ncard->host->ios.timing = MMC_TIMING_LEGACY;\r\ncard->host->ops->set_ios(card->host, &card->host->ios);\r\nreturn 0;\r\n}\r\nCsrResult\r\nCsrSdioMaxBusClockFrequencySet(CsrSdioFunction *function, u32 maxFrequency)\r\n{\r\nstruct sdio_func *func = (struct sdio_func *)function->priv;\r\nstruct mmc_host *host = func->card->host;\r\nstruct mmc_ios *ios = &host->ios;\r\nunsigned int max_hz;\r\nint err;\r\nu32 max_khz = maxFrequency/1000;\r\nif (!max_khz || max_khz > sdio_clock) {\r\nmax_khz = sdio_clock;\r\n}\r\n_sdio_claim_host(func);\r\nmax_hz = 1000 * max_khz;\r\nif (max_hz > host->f_max) {\r\nmax_hz = host->f_max;\r\n}\r\nif (max_hz > 25000000) {\r\nerr = csr_sdio_enable_hs(func->card);\r\n} else {\r\nerr = csr_sdio_disable_hs(func->card);\r\n}\r\nif (err) {\r\nprintk(KERN_ERR "SDIO warning: Failed to configure SDIO clock mode\n");\r\n_sdio_release_host(func);\r\nreturn CSR_RESULT_SUCCESS;\r\n}\r\nios->clock = max_hz;\r\nhost->ops->set_ios(host, ios);\r\n_sdio_release_host(func);\r\nreturn CSR_RESULT_SUCCESS;\r\n}\r\nCsrResult\r\nCsrSdioInterruptEnable(CsrSdioFunction *function)\r\n{\r\nstruct sdio_func *func = (struct sdio_func *)function->priv;\r\nint err = 0;\r\n#ifdef CSR_CONFIG_MMC_INT_BYPASS_KSOFTIRQD\r\nsdio_unblock_card_irq(func);\r\n#else\r\n_sdio_claim_host(func);\r\n#ifdef MMC_QUIRK_LENIENT_FN0\r\nsdio_f0_writeb(func, 0x3, SDIO_CCCR_IENx, &err);\r\n#else\r\nerr = csr_io_rw_direct(func->card, 1, 0, SDIO_CCCR_IENx, 0x03, NULL);\r\n#endif\r\n_sdio_release_host(func);\r\nif (err) {\r\nprintk(KERN_ERR "unifi: %s: error %d writing IENx\n", __FUNCTION__, err);\r\nreturn ConvertSdioToCsrSdioResult(err);\r\n}\r\n#endif\r\nreturn CSR_RESULT_SUCCESS;\r\n}\r\nCsrResult\r\nCsrSdioInterruptDisable(CsrSdioFunction *function)\r\n{\r\nstruct sdio_func *func = (struct sdio_func *)function->priv;\r\nint err = 0;\r\n#ifdef CSR_CONFIG_MMC_INT_BYPASS_KSOFTIRQD\r\nsdio_block_card_irq(func);\r\n#else\r\n_sdio_claim_host(func);\r\n#ifdef MMC_QUIRK_LENIENT_FN0\r\nsdio_f0_writeb(func, 0, SDIO_CCCR_IENx, &err);\r\n#else\r\nerr = csr_io_rw_direct(func->card, 1, 0, SDIO_CCCR_IENx, 0x00, NULL);\r\n#endif\r\n_sdio_release_host(func);\r\nif (err) {\r\nprintk(KERN_ERR "unifi: %s: error %d writing IENx\n", __FUNCTION__, err);\r\nreturn ConvertSdioToCsrSdioResult(err);\r\n}\r\n#endif\r\nreturn CSR_RESULT_SUCCESS;\r\n}\r\nvoid CsrSdioInterruptAcknowledge(CsrSdioFunction *function)\r\n{\r\n}\r\nCsrResult\r\nCsrSdioFunctionEnable(CsrSdioFunction *function)\r\n{\r\nstruct sdio_func *func = (struct sdio_func *)function->priv;\r\nint err;\r\n_sdio_claim_host(func);\r\nerr = sdio_enable_func(func);\r\n_sdio_release_host(func);\r\nif (err) {\r\nunifi_error(NULL, "Failed to enable SDIO function %d\n", func->num);\r\n}\r\nreturn ConvertSdioToCsrSdioResult(err);\r\n}\r\nCsrResult\r\nCsrSdioFunctionDisable(CsrSdioFunction *function)\r\n{\r\nstruct sdio_func *func = (struct sdio_func *)function->priv;\r\nint err;\r\n_sdio_claim_host(func);\r\nerr = sdio_disable_func(func);\r\n_sdio_release_host(func);\r\nif (err) {\r\nunifi_error(NULL, "Failed to disable SDIO function %d\n", func->num);\r\n}\r\nreturn ConvertSdioToCsrSdioResult(err);\r\n}\r\nvoid\r\nCsrSdioFunctionActive(CsrSdioFunction *function)\r\n{\r\n}\r\nvoid\r\nCsrSdioFunctionIdle(CsrSdioFunction *function)\r\n{\r\n}\r\nCsrResult\r\nCsrSdioPowerOn(CsrSdioFunction *function)\r\n{\r\nstruct sdio_func *func = (struct sdio_func *)function->priv;\r\nstruct mmc_host *host = func->card->host;\r\n_sdio_claim_host(func);\r\nif (!card_is_powered) {\r\nmmc_power_restore_host(host);\r\ncard_is_powered = 1;\r\n} else {\r\nprintk(KERN_INFO "SDIO: Skip power on; card is already powered.\n");\r\n}\r\n_sdio_release_host(func);\r\nreturn CSR_RESULT_SUCCESS;\r\n}\r\nvoid\r\nCsrSdioPowerOff(CsrSdioFunction *function)\r\n{\r\nstruct sdio_func *func = (struct sdio_func *)function->priv;\r\nstruct mmc_host *host = func->card->host;\r\n_sdio_claim_host(func);\r\nif (card_is_powered) {\r\nmmc_power_save_host(host);\r\ncard_is_powered = 0;\r\n} else {\r\nprintk(KERN_INFO "SDIO: Skip power off; card is already powered off.\n");\r\n}\r\n_sdio_release_host(func);\r\n}\r\nstatic int\r\nsdio_set_block_size_ignore_first_error(struct sdio_func *func, unsigned blksz)\r\n{\r\nint ret;\r\nif (blksz > func->card->host->max_blk_size)\r\nreturn -EINVAL;\r\nif (blksz == 0) {\r\nblksz = min(func->max_blksize, func->card->host->max_blk_size);\r\nblksz = min(blksz, 512u);\r\n}\r\nret = csr_io_rw_direct(func->card, 1, 0,\r\nSDIO_FBR_BASE(func->num) + SDIO_FBR_BLKSIZE,\r\nblksz & 0xff, NULL);\r\nif (ret && ret != -ERANGE)\r\nreturn ret;\r\nret = csr_io_rw_direct(func->card, 1, 0,\r\nSDIO_FBR_BASE(func->num) + SDIO_FBR_BLKSIZE + 1,\r\n(blksz >> 8) & 0xff, NULL);\r\nif (ret)\r\nreturn ret;\r\nfunc->cur_blksize = blksz;\r\nreturn 0;\r\n}\r\nCsrResult\r\nCsrSdioBlockSizeSet(CsrSdioFunction *function, u16 blockSize)\r\n{\r\nstruct sdio_func *func = (struct sdio_func *)function->priv;\r\nint r = 0;\r\nif (sdio_block_size > -1) {\r\nblockSize = sdio_block_size;\r\n}\r\nunifi_trace(NULL, UDBG1, "Set SDIO function block size to %d\n",\r\nblockSize);\r\n_sdio_claim_host(func);\r\nr = sdio_set_block_size(func, blockSize);\r\n_sdio_release_host(func);\r\nif (r == -ERANGE) {\r\n_sdio_claim_host(func);\r\nr = sdio_set_block_size_ignore_first_error(func, blockSize);\r\n_sdio_release_host(func);\r\n}\r\nif (r) {\r\nunifi_error(NULL, "Error %d setting block size\n", r);\r\n}\r\nfunction->blockSize = func->cur_blksize;\r\nreturn ConvertSdioToCsrSdioResult(r);\r\n}\r\nCsrResult\r\nCsrSdioHardReset(CsrSdioFunction *function)\r\n{\r\nreturn CSR_RESULT_FAILURE;\r\n}\r\nstatic void\r\nuf_glue_sdio_int_handler(struct sdio_func *func)\r\n{\r\nCsrSdioFunction *sdio_ctx;\r\nCsrSdioInterruptDsrCallback func_dsr_callback;\r\nint r;\r\nsdio_ctx = sdio_get_drvdata(func);\r\nif (!sdio_ctx) {\r\nreturn;\r\n}\r\n#ifndef CSR_CONFIG_MMC_INT_BYPASS_KSOFTIRQD\r\n#ifdef MMC_QUIRK_LENIENT_FN0\r\nsdio_f0_writeb(func, 0, SDIO_CCCR_IENx, &r);\r\n#else\r\nr = csr_io_rw_direct(func->card, 1, 0, SDIO_CCCR_IENx, 0x00, NULL);\r\n#endif\r\nif (r) {\r\nprintk(KERN_ERR "UniFi MMC Int handler: Failed to disable interrupts %d\n", r);\r\n}\r\n#endif\r\nif (sdio_func_drv && sdio_func_drv->intr) {\r\nfunc_dsr_callback = sdio_func_drv->intr(sdio_ctx);\r\nif (func_dsr_callback) {\r\nfunc_dsr_callback(sdio_ctx);\r\n}\r\n}\r\n}\r\nint csr_sdio_linux_remove_irq(CsrSdioFunction *function)\r\n{\r\nstruct sdio_func *func = (struct sdio_func *)function->priv;\r\nint r;\r\nunifi_trace(NULL, UDBG1, "csr_sdio_linux_remove_irq\n");\r\nsdio_claim_host(func);\r\nr = sdio_release_irq(func);\r\nsdio_release_host(func);\r\nreturn r;\r\n}\r\nint csr_sdio_linux_install_irq(CsrSdioFunction *function)\r\n{\r\nstruct sdio_func *func = (struct sdio_func *)function->priv;\r\nint r;\r\nunifi_trace(NULL, UDBG1, "csr_sdio_linux_install_irq\n");\r\nsdio_claim_host(func);\r\nr = sdio_claim_irq(func, uf_glue_sdio_int_handler);\r\nsdio_release_host(func);\r\nif (r == -EBUSY)\r\nr = 0;\r\nreturn r;\r\n}\r\nstatic struct uf_sdio_mmc_pm_notifier *\r\nuf_sdio_mmc_register_pm_notifier(CsrSdioFunction *sdio_ctx)\r\n{\r\nstruct uf_sdio_mmc_pm_notifier *notifier_ctx = kmalloc(sizeof(struct uf_sdio_mmc_pm_notifier), GFP_KERNEL);\r\nif (notifier_ctx)\r\n{\r\nnotifier_ctx->sdio_ctx = sdio_ctx;\r\nnotifier_ctx->pm_notifier.notifier_call = uf_sdio_mmc_power_event;\r\nlist_add(&notifier_ctx->list, &uf_sdio_mmc_pm_notifiers.list);\r\nif (register_pm_notifier(&notifier_ctx->pm_notifier)) {\r\nprintk(KERN_ERR "unifi: register_pm_notifier failed\n");\r\n}\r\n}\r\nreturn notifier_ctx;\r\n}\r\nstatic void\r\nuf_sdio_mmc_unregister_pm_notifier(CsrSdioFunction *sdio_ctx)\r\n{\r\nstruct uf_sdio_mmc_pm_notifier *notifier_ctx;\r\nstruct list_head *node, *q;\r\nlist_for_each_safe(node, q, &uf_sdio_mmc_pm_notifiers.list) {\r\nnotifier_ctx = list_entry(node, struct uf_sdio_mmc_pm_notifier, list);\r\nif (notifier_ctx && notifier_ctx->sdio_ctx == sdio_ctx)\r\n{\r\nif (unregister_pm_notifier(&notifier_ctx->pm_notifier)) {\r\nprintk(KERN_ERR "unifi: unregister_pm_notifier failed\n");\r\n}\r\nnotifier_ctx->sdio_ctx = NULL;\r\nlist_del(node);\r\nkfree(notifier_ctx);\r\n}\r\n}\r\n}\r\nstatic int\r\nuf_sdio_mmc_power_event(struct notifier_block *this, unsigned long event, void *ptr)\r\n{\r\nstruct uf_sdio_mmc_pm_notifier *notifier_ctx = container_of(this,\r\nstruct uf_sdio_mmc_pm_notifier,\r\npm_notifier);\r\nswitch (event) {\r\ncase PM_POST_HIBERNATION:\r\ncase PM_POST_SUSPEND:\r\nprintk(KERN_INFO "%s:%d resume\n", __FUNCTION__, __LINE__ );\r\nif (sdio_func_drv && sdio_func_drv->resume) {\r\nsdio_func_drv->resume(notifier_ctx->sdio_ctx);\r\n}\r\nbreak;\r\ncase PM_HIBERNATION_PREPARE:\r\ncase PM_SUSPEND_PREPARE:\r\nprintk(KERN_INFO "%s:%d suspend\n", __FUNCTION__, __LINE__ );\r\nif (sdio_func_drv && sdio_func_drv->suspend) {\r\nsdio_func_drv->suspend(notifier_ctx->sdio_ctx);\r\n}\r\nbreak;\r\n}\r\nreturn NOTIFY_DONE;\r\n}\r\nstatic int\r\nuf_glue_sdio_probe(struct sdio_func *func,\r\nconst struct sdio_device_id *id)\r\n{\r\nint instance;\r\nCsrSdioFunction *sdio_ctx;\r\nsdio_claim_host(func);\r\ncard_is_powered = 1;\r\ninstance = func->card->host->index;\r\nprintk("sdio bus_id: %16s - UniFi card 0x%X inserted\n",\r\nsdio_func_id(func), instance);\r\nsdio_ctx = (CsrSdioFunction *)kmalloc(sizeof(CsrSdioFunction),\r\nGFP_KERNEL);\r\nif (sdio_ctx == NULL) {\r\nsdio_release_host(func);\r\nreturn -ENOMEM;\r\n}\r\nsdio_ctx->sdioId.manfId = func->vendor;\r\nsdio_ctx->sdioId.cardId = func->device;\r\nsdio_ctx->sdioId.sdioFunction = func->num;\r\nsdio_ctx->sdioId.sdioInterface = func->class;\r\nsdio_ctx->blockSize = func->cur_blksize;\r\nsdio_ctx->priv = (void *)func;\r\nsdio_ctx->features = 0;\r\nif (sdio_byte_mode) {\r\nsdio_ctx->features |= CSR_SDIO_FEATURE_BYTE_MODE;\r\n}\r\nif (func->card->host->caps & MMC_CAP_SD_HIGHSPEED) {\r\nunifi_trace(NULL, UDBG1, "MMC_CAP_SD_HIGHSPEED is available\n");\r\n}\r\n#ifdef MMC_QUIRK_LENIENT_FN0\r\nfunc->card->quirks |= MMC_QUIRK_LENIENT_FN0;\r\n#endif\r\nsdio_set_drvdata(func, sdio_ctx);\r\n#ifdef CONFIG_PM\r\nif (uf_sdio_mmc_register_pm_notifier(sdio_ctx) == NULL) {\r\nunifi_error(NULL, "%s: Failed to register for PM events\n", __FUNCTION__);\r\n}\r\n#endif\r\nif (sdio_func_drv && sdio_func_drv->inserted) {\r\nuf_add_os_device(instance, &func->dev);\r\nsdio_func_drv->inserted(sdio_ctx);\r\n}\r\nsdio_release_host(func);\r\n#ifdef ANDROID_BUILD\r\nunifi_trace(NULL, UDBG1, "probe: take wake lock\n");\r\nwake_lock(&unifi_sdio_wake_lock);\r\n#endif\r\nreturn 0;\r\n}\r\nstatic void\r\nuf_glue_sdio_remove(struct sdio_func *func)\r\n{\r\nCsrSdioFunction *sdio_ctx;\r\nsdio_ctx = sdio_get_drvdata(func);\r\nif (!sdio_ctx) {\r\nreturn;\r\n}\r\nunifi_info(NULL, "UniFi card removed\n");\r\nif (sdio_func_drv && sdio_func_drv->removed) {\r\nuf_remove_os_device(func->card->host->index);\r\nsdio_func_drv->removed(sdio_ctx);\r\n}\r\n#ifdef CONFIG_PM\r\nuf_sdio_mmc_unregister_pm_notifier(sdio_ctx);\r\n#endif\r\nkfree(sdio_ctx);\r\n}\r\nstatic int\r\nuf_glue_sdio_suspend(struct device *dev)\r\n{\r\nunifi_trace(NULL, UDBG1, "uf_glue_sdio_suspend");\r\nreturn 0;\r\n}\r\nstatic int\r\nuf_glue_sdio_resume(struct device *dev)\r\n{\r\nunifi_trace(NULL, UDBG1, "uf_glue_sdio_resume");\r\n#ifdef ANDROID_BUILD\r\nunifi_trace(NULL, UDBG1, "resume: take wakelock\n");\r\nwake_lock(&unifi_sdio_wake_lock);\r\n#endif\r\nreturn 0;\r\n}\r\nCsrResult\r\nCsrSdioFunctionDriverRegister(CsrSdioFunctionDriver *sdio_drv)\r\n{\r\nint r;\r\nprintk("UniFi: Using native Linux MMC driver for SDIO.\n");\r\nif (sdio_func_drv) {\r\nunifi_error(NULL, "sdio_mmc: UniFi driver already registered\n");\r\nreturn CSR_SDIO_RESULT_INVALID_VALUE;\r\n}\r\n#ifdef ANDROID_BUILD\r\nwake_lock_init(&unifi_sdio_wake_lock, WAKE_LOCK_SUSPEND, "unifi_sdio_work");\r\n#endif\r\nsdio_func_drv = sdio_drv;\r\n#ifdef CONFIG_PM\r\nINIT_LIST_HEAD(&uf_sdio_mmc_pm_notifiers.list);\r\n#endif\r\nr = sdio_register_driver(&unifi_driver);\r\nif (r) {\r\nprintk(KERN_ERR "unifi_sdio: Failed to register UniFi SDIO driver: %d\n", r);\r\nreturn ConvertSdioToCsrSdioResult(r);\r\n}\r\nreturn CSR_RESULT_SUCCESS;\r\n}\r\nvoid\r\nCsrSdioFunctionDriverUnregister(CsrSdioFunctionDriver *sdio_drv)\r\n{\r\nprintk(KERN_INFO "UniFi: unregister from MMC sdio\n");\r\n#ifdef ANDROID_BUILD\r\nwake_lock_destroy(&unifi_sdio_wake_lock);\r\n#endif\r\nsdio_unregister_driver(&unifi_driver);\r\nsdio_func_drv = NULL;\r\n}
