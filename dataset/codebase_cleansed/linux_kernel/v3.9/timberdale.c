static ssize_t show_fw_ver(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct pci_dev *pdev = to_pci_dev(dev);\r\nstruct timberdale_device *priv = pci_get_drvdata(pdev);\r\nreturn sprintf(buf, "%d.%d.%d\n", priv->fw.major, priv->fw.minor,\r\npriv->fw.config);\r\n}\r\nstatic int timb_probe(struct pci_dev *dev,\r\nconst struct pci_device_id *id)\r\n{\r\nstruct timberdale_device *priv;\r\nint err, i;\r\nresource_size_t mapbase;\r\nstruct msix_entry *msix_entries = NULL;\r\nu8 ip_setup;\r\npriv = kzalloc(sizeof(*priv), GFP_KERNEL);\r\nif (!priv)\r\nreturn -ENOMEM;\r\npci_set_drvdata(dev, priv);\r\nerr = pci_enable_device(dev);\r\nif (err)\r\ngoto err_enable;\r\nmapbase = pci_resource_start(dev, 0);\r\nif (!mapbase) {\r\ndev_err(&dev->dev, "No resource\n");\r\ngoto err_start;\r\n}\r\npriv->ctl_mapbase = mapbase + CHIPCTLOFFSET;\r\nif (!request_mem_region(priv->ctl_mapbase, CHIPCTLSIZE, "timb-ctl")) {\r\ndev_err(&dev->dev, "Failed to request ctl mem\n");\r\ngoto err_request;\r\n}\r\npriv->ctl_membase = ioremap(priv->ctl_mapbase, CHIPCTLSIZE);\r\nif (!priv->ctl_membase) {\r\ndev_err(&dev->dev, "ioremap failed for ctl mem\n");\r\ngoto err_ioremap;\r\n}\r\npriv->fw.major = ioread32(priv->ctl_membase + TIMB_REV_MAJOR);\r\npriv->fw.minor = ioread32(priv->ctl_membase + TIMB_REV_MINOR);\r\npriv->fw.config = ioread32(priv->ctl_membase + TIMB_HW_CONFIG);\r\nif (priv->fw.major > TIMB_SUPPORTED_MAJOR) {\r\ndev_err(&dev->dev, "The driver supports an older "\r\n"version of the FPGA, please update the driver to "\r\n"support %d.%d\n", priv->fw.major, priv->fw.minor);\r\ngoto err_config;\r\n}\r\nif (priv->fw.major < TIMB_SUPPORTED_MAJOR ||\r\npriv->fw.minor < TIMB_REQUIRED_MINOR) {\r\ndev_err(&dev->dev, "The FPGA image is too old (%d.%d), "\r\n"please upgrade the FPGA to at least: %d.%d\n",\r\npriv->fw.major, priv->fw.minor,\r\nTIMB_SUPPORTED_MAJOR, TIMB_REQUIRED_MINOR);\r\ngoto err_config;\r\n}\r\nmsix_entries = kzalloc(TIMBERDALE_NR_IRQS * sizeof(*msix_entries),\r\nGFP_KERNEL);\r\nif (!msix_entries)\r\ngoto err_config;\r\nfor (i = 0; i < TIMBERDALE_NR_IRQS; i++)\r\nmsix_entries[i].entry = i;\r\nerr = pci_enable_msix(dev, msix_entries, TIMBERDALE_NR_IRQS);\r\nif (err) {\r\ndev_err(&dev->dev,\r\n"MSI-X init failed: %d, expected entries: %d\n",\r\nerr, TIMBERDALE_NR_IRQS);\r\ngoto err_msix;\r\n}\r\nerr = device_create_file(&dev->dev, &dev_attr_fw_ver);\r\nif (err)\r\ngoto err_create_file;\r\niowrite32(0x1, priv->ctl_membase + TIMB_SW_RST);\r\nfor (i = 0; i < ARRAY_SIZE(timberdale_i2c_board_info); i++)\r\ntimberdale_i2c_board_info[i].irq =\r\nmsix_entries[timberdale_i2c_board_info[i].irq].vector;\r\nif (priv->fw.config & TIMB_HW_CONFIG_SPI_8BIT) {\r\ntimberdale_xspi_platform_data.bits_per_word = 8;\r\ntimberdale_xspi_platform_data.devices =\r\ntimberdale_spi_8bit_board_info;\r\ntimberdale_xspi_platform_data.num_devices =\r\nARRAY_SIZE(timberdale_spi_8bit_board_info);\r\n} else {\r\ntimberdale_xspi_platform_data.bits_per_word = 16;\r\ntimberdale_xspi_platform_data.devices =\r\ntimberdale_spi_16bit_board_info;\r\ntimberdale_xspi_platform_data.num_devices =\r\nARRAY_SIZE(timberdale_spi_16bit_board_info);\r\n}\r\nip_setup = priv->fw.config & TIMB_HW_VER_MASK;\r\nswitch (ip_setup) {\r\ncase TIMB_HW_VER0:\r\nerr = mfd_add_devices(&dev->dev, -1,\r\ntimberdale_cells_bar0_cfg0,\r\nARRAY_SIZE(timberdale_cells_bar0_cfg0),\r\n&dev->resource[0], msix_entries[0].vector, NULL);\r\nbreak;\r\ncase TIMB_HW_VER1:\r\nerr = mfd_add_devices(&dev->dev, -1,\r\ntimberdale_cells_bar0_cfg1,\r\nARRAY_SIZE(timberdale_cells_bar0_cfg1),\r\n&dev->resource[0], msix_entries[0].vector, NULL);\r\nbreak;\r\ncase TIMB_HW_VER2:\r\nerr = mfd_add_devices(&dev->dev, -1,\r\ntimberdale_cells_bar0_cfg2,\r\nARRAY_SIZE(timberdale_cells_bar0_cfg2),\r\n&dev->resource[0], msix_entries[0].vector, NULL);\r\nbreak;\r\ncase TIMB_HW_VER3:\r\nerr = mfd_add_devices(&dev->dev, -1,\r\ntimberdale_cells_bar0_cfg3,\r\nARRAY_SIZE(timberdale_cells_bar0_cfg3),\r\n&dev->resource[0], msix_entries[0].vector, NULL);\r\nbreak;\r\ndefault:\r\ndev_err(&dev->dev, "Uknown IP setup: %d.%d.%d\n",\r\npriv->fw.major, priv->fw.minor, ip_setup);\r\nerr = -ENODEV;\r\ngoto err_mfd;\r\nbreak;\r\n}\r\nif (err) {\r\ndev_err(&dev->dev, "mfd_add_devices failed: %d\n", err);\r\ngoto err_mfd;\r\n}\r\nerr = mfd_add_devices(&dev->dev, 0,\r\ntimberdale_cells_bar1, ARRAY_SIZE(timberdale_cells_bar1),\r\n&dev->resource[1], msix_entries[0].vector, NULL);\r\nif (err) {\r\ndev_err(&dev->dev, "mfd_add_devices failed: %d\n", err);\r\ngoto err_mfd2;\r\n}\r\nif (((priv->fw.config & TIMB_HW_VER_MASK) == TIMB_HW_VER0) ||\r\n((priv->fw.config & TIMB_HW_VER_MASK) == TIMB_HW_VER3)) {\r\nerr = mfd_add_devices(&dev->dev, 1, timberdale_cells_bar2,\r\nARRAY_SIZE(timberdale_cells_bar2),\r\n&dev->resource[2], msix_entries[0].vector, NULL);\r\nif (err) {\r\ndev_err(&dev->dev, "mfd_add_devices failed: %d\n", err);\r\ngoto err_mfd2;\r\n}\r\n}\r\nkfree(msix_entries);\r\ndev_info(&dev->dev,\r\n"Found Timberdale Card. Rev: %d.%d, HW config: 0x%02x\n",\r\npriv->fw.major, priv->fw.minor, priv->fw.config);\r\nreturn 0;\r\nerr_mfd2:\r\nmfd_remove_devices(&dev->dev);\r\nerr_mfd:\r\ndevice_remove_file(&dev->dev, &dev_attr_fw_ver);\r\nerr_create_file:\r\npci_disable_msix(dev);\r\nerr_msix:\r\nkfree(msix_entries);\r\nerr_config:\r\niounmap(priv->ctl_membase);\r\nerr_ioremap:\r\nrelease_mem_region(priv->ctl_mapbase, CHIPCTLSIZE);\r\nerr_request:\r\npci_set_drvdata(dev, NULL);\r\nerr_start:\r\npci_disable_device(dev);\r\nerr_enable:\r\nkfree(priv);\r\npci_set_drvdata(dev, NULL);\r\nreturn -ENODEV;\r\n}\r\nstatic void timb_remove(struct pci_dev *dev)\r\n{\r\nstruct timberdale_device *priv = pci_get_drvdata(dev);\r\nmfd_remove_devices(&dev->dev);\r\ndevice_remove_file(&dev->dev, &dev_attr_fw_ver);\r\niounmap(priv->ctl_membase);\r\nrelease_mem_region(priv->ctl_mapbase, CHIPCTLSIZE);\r\npci_disable_msix(dev);\r\npci_disable_device(dev);\r\npci_set_drvdata(dev, NULL);\r\nkfree(priv);\r\n}\r\nstatic int __init timberdale_init(void)\r\n{\r\nint err;\r\nerr = pci_register_driver(&timberdale_pci_driver);\r\nif (err < 0) {\r\nprintk(KERN_ERR\r\n"Failed to register PCI driver for %s device.\n",\r\ntimberdale_pci_driver.name);\r\nreturn -ENODEV;\r\n}\r\nprintk(KERN_INFO "Driver for %s has been successfully registered.\n",\r\ntimberdale_pci_driver.name);\r\nreturn 0;\r\n}\r\nstatic void __exit timberdale_exit(void)\r\n{\r\npci_unregister_driver(&timberdale_pci_driver);\r\nprintk(KERN_INFO "Driver for %s has been successfully unregistered.\n",\r\ntimberdale_pci_driver.name);\r\n}
