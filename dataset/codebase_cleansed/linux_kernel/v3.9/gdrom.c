static bool gdrom_is_busy(void)\r\n{\r\nreturn (__raw_readb(GDROM_ALTSTATUS_REG) & 0x80) != 0;\r\n}\r\nstatic bool gdrom_data_request(void)\r\n{\r\nreturn (__raw_readb(GDROM_ALTSTATUS_REG) & 0x88) == 8;\r\n}\r\nstatic bool gdrom_wait_clrbusy(void)\r\n{\r\nunsigned long timeout = jiffies + GDROM_DEFAULT_TIMEOUT;\r\nwhile ((__raw_readb(GDROM_ALTSTATUS_REG) & 0x80) &&\r\n(time_before(jiffies, timeout)))\r\ncpu_relax();\r\nreturn time_before(jiffies, timeout + 1);\r\n}\r\nstatic bool gdrom_wait_busy_sleeps(void)\r\n{\r\nunsigned long timeout;\r\ntimeout = jiffies + GDROM_DEFAULT_TIMEOUT;\r\nwhile (!gdrom_is_busy() && time_before(jiffies, timeout))\r\ncpu_relax();\r\nreturn gdrom_wait_clrbusy();\r\n}\r\nstatic void gdrom_identifydevice(void *buf)\r\n{\r\nint c;\r\nshort *data = buf;\r\nif (!gdrom_wait_clrbusy()) {\r\ngdrom_getsense(NULL);\r\nreturn;\r\n}\r\n__raw_writeb(GDROM_COM_IDDEV, GDROM_STATUSCOMMAND_REG);\r\nif (!gdrom_wait_busy_sleeps()) {\r\ngdrom_getsense(NULL);\r\nreturn;\r\n}\r\nfor (c = 0; c < 40; c++)\r\ndata[c] = __raw_readw(GDROM_DATA_REG);\r\n}\r\nstatic void gdrom_spicommand(void *spi_string, int buflen)\r\n{\r\nshort *cmd = spi_string;\r\nunsigned long timeout;\r\n__raw_writeb(0x08, GDROM_ALTSTATUS_REG);\r\n__raw_writeb(buflen & 0xFF, GDROM_BCL_REG);\r\n__raw_writeb((buflen >> 8) & 0xFF, GDROM_BCH_REG);\r\n__raw_writeb(0, GDROM_INTSEC_REG);\r\n__raw_writeb(0, GDROM_SECNUM_REG);\r\n__raw_writeb(0, GDROM_ERROR_REG);\r\nif (!gdrom_wait_clrbusy()) {\r\ngdrom_getsense(NULL);\r\nreturn;\r\n}\r\ntimeout = jiffies + GDROM_DEFAULT_TIMEOUT;\r\n__raw_writeb(GDROM_COM_PACKET, GDROM_STATUSCOMMAND_REG);\r\nwhile (!gdrom_data_request() && time_before(jiffies, timeout))\r\ncpu_relax();\r\nif (!time_before(jiffies, timeout + 1)) {\r\ngdrom_getsense(NULL);\r\nreturn;\r\n}\r\noutsw(GDROM_DATA_REG, cmd, 6);\r\n}\r\nstatic char gdrom_execute_diagnostic(void)\r\n{\r\ngdrom_hardreset(gd.cd_info);\r\nif (!gdrom_wait_clrbusy())\r\nreturn 0;\r\n__raw_writeb(GDROM_COM_EXECDIAG, GDROM_STATUSCOMMAND_REG);\r\nif (!gdrom_wait_busy_sleeps())\r\nreturn 0;\r\nreturn __raw_readb(GDROM_ERROR_REG);\r\n}\r\nstatic int gdrom_preparedisk_cmd(void)\r\n{\r\nstruct packet_command *spin_command;\r\nspin_command = kzalloc(sizeof(struct packet_command), GFP_KERNEL);\r\nif (!spin_command)\r\nreturn -ENOMEM;\r\nspin_command->cmd[0] = 0x70;\r\nspin_command->cmd[2] = 0x1f;\r\nspin_command->buflen = 0;\r\ngd.pending = 1;\r\ngdrom_packetcommand(gd.cd_info, spin_command);\r\nwait_event_interruptible_timeout(command_queue, gd.pending == 0,\r\nGDROM_DEFAULT_TIMEOUT);\r\ngd.pending = 0;\r\nkfree(spin_command);\r\nif (gd.status & 0x01) {\r\ngdrom_getsense(NULL);\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic int gdrom_readtoc_cmd(struct gdromtoc *toc, int session)\r\n{\r\nint tocsize;\r\nstruct packet_command *toc_command;\r\nint err = 0;\r\ntoc_command = kzalloc(sizeof(struct packet_command), GFP_KERNEL);\r\nif (!toc_command)\r\nreturn -ENOMEM;\r\ntocsize = sizeof(struct gdromtoc);\r\ntoc_command->cmd[0] = 0x14;\r\ntoc_command->cmd[1] = session;\r\ntoc_command->cmd[3] = tocsize >> 8;\r\ntoc_command->cmd[4] = tocsize & 0xff;\r\ntoc_command->buflen = tocsize;\r\nif (gd.pending) {\r\nerr = -EBUSY;\r\ngoto cleanup_readtoc_final;\r\n}\r\ngd.pending = 1;\r\ngdrom_packetcommand(gd.cd_info, toc_command);\r\nwait_event_interruptible_timeout(command_queue, gd.pending == 0,\r\nGDROM_DEFAULT_TIMEOUT);\r\nif (gd.pending) {\r\nerr = -EINVAL;\r\ngoto cleanup_readtoc;\r\n}\r\ninsw(GDROM_DATA_REG, toc, tocsize/2);\r\nif (gd.status & 0x01)\r\nerr = -EINVAL;\r\ncleanup_readtoc:\r\ngd.pending = 0;\r\ncleanup_readtoc_final:\r\nkfree(toc_command);\r\nreturn err;\r\n}\r\nstatic int get_entry_lba(int track)\r\n{\r\nreturn (cpu_to_be32(track & 0xffffff00) - GD_SESSION_OFFSET);\r\n}\r\nstatic int get_entry_q_ctrl(int track)\r\n{\r\nreturn (track & 0x000000f0) >> 4;\r\n}\r\nstatic int get_entry_track(int track)\r\n{\r\nreturn (track & 0x0000ff00) >> 8;\r\n}\r\nstatic int gdrom_get_last_session(struct cdrom_device_info *cd_info,\r\nstruct cdrom_multisession *ms_info)\r\n{\r\nint fentry, lentry, track, data, tocuse, err;\r\nif (!gd.toc)\r\nreturn -ENOMEM;\r\ntocuse = 1;\r\nerr = gdrom_readtoc_cmd(gd.toc, 1);\r\nif (err) {\r\ntocuse = 0;\r\nerr = gdrom_readtoc_cmd(gd.toc, 0);\r\nif (err) {\r\npr_info("Could not get CD table of contents\n");\r\nreturn -ENXIO;\r\n}\r\n}\r\nfentry = get_entry_track(gd.toc->first);\r\nlentry = get_entry_track(gd.toc->last);\r\ntrack = get_entry_track(gd.toc->last);\r\ndo {\r\ndata = gd.toc->entry[track - 1];\r\nif (get_entry_q_ctrl(data))\r\nbreak;\r\ntrack--;\r\n} while (track >= fentry);\r\nif ((track > 100) || (track < get_entry_track(gd.toc->first))) {\r\npr_info("No data on the last session of the CD\n");\r\ngdrom_getsense(NULL);\r\nreturn -ENXIO;\r\n}\r\nms_info->addr_format = CDROM_LBA;\r\nms_info->addr.lba = get_entry_lba(data);\r\nms_info->xa_flag = 1;\r\nreturn 0;\r\n}\r\nstatic int gdrom_open(struct cdrom_device_info *cd_info, int purpose)\r\n{\r\nreturn gdrom_preparedisk_cmd();\r\n}\r\nstatic void gdrom_release(struct cdrom_device_info *cd_info)\r\n{\r\n}\r\nstatic int gdrom_drivestatus(struct cdrom_device_info *cd_info, int ignore)\r\n{\r\nchar sense = __raw_readb(GDROM_ERROR_REG);\r\nsense &= 0xF0;\r\nif (sense == 0)\r\nreturn CDS_DISC_OK;\r\nif (sense == 0x20)\r\nreturn CDS_DRIVE_NOT_READY;\r\nreturn CDS_NO_INFO;\r\n}\r\nstatic unsigned int gdrom_check_events(struct cdrom_device_info *cd_info,\r\nunsigned int clearing, int ignore)\r\n{\r\nreturn (__raw_readb(GDROM_ERROR_REG) & 0xF0) == 0x60 ?\r\nDISK_EVENT_MEDIA_CHANGE : 0;\r\n}\r\nstatic int gdrom_hardreset(struct cdrom_device_info *cd_info)\r\n{\r\nint count;\r\n__raw_writel(0x1fffff, GDROM_RESET_REG);\r\nfor (count = 0xa0000000; count < 0xa0200000; count += 4)\r\n__raw_readl(count);\r\nreturn 0;\r\n}\r\nstatic int gdrom_packetcommand(struct cdrom_device_info *cd_info,\r\nstruct packet_command *command)\r\n{\r\ngdrom_spicommand(&command->cmd, command->buflen);\r\nreturn 0;\r\n}\r\nstatic int gdrom_getsense(short *bufstring)\r\n{\r\nstruct packet_command *sense_command;\r\nshort sense[5];\r\nint sense_key;\r\nint err = -EIO;\r\nsense_command = kzalloc(sizeof(struct packet_command), GFP_KERNEL);\r\nif (!sense_command)\r\nreturn -ENOMEM;\r\nsense_command->cmd[0] = 0x13;\r\nsense_command->cmd[4] = 10;\r\nsense_command->buflen = 10;\r\nif (gd.pending && !gdrom_wait_clrbusy()) {\r\nerr = -EBUSY;\r\ngoto cleanup_sense_final;\r\n}\r\ngd.pending = 1;\r\ngdrom_packetcommand(gd.cd_info, sense_command);\r\nwait_event_interruptible_timeout(command_queue, gd.pending == 0,\r\nGDROM_DEFAULT_TIMEOUT);\r\nif (gd.pending)\r\ngoto cleanup_sense;\r\ninsw(GDROM_DATA_REG, &sense, sense_command->buflen/2);\r\nif (sense[1] & 40) {\r\npr_info("Drive not ready - command aborted\n");\r\ngoto cleanup_sense;\r\n}\r\nsense_key = sense[1] & 0x0F;\r\nif (sense_key < ARRAY_SIZE(sense_texts))\r\npr_info("%s\n", sense_texts[sense_key].text);\r\nelse\r\npr_err("Unknown sense key: %d\n", sense_key);\r\nif (bufstring)\r\nmemcpy(bufstring, &sense[4], 2);\r\nif (sense_key < 2)\r\nerr = 0;\r\ncleanup_sense:\r\ngd.pending = 0;\r\ncleanup_sense_final:\r\nkfree(sense_command);\r\nreturn err;\r\n}\r\nstatic int gdrom_audio_ioctl(struct cdrom_device_info *cdi, unsigned int cmd,\r\nvoid *arg)\r\n{\r\nreturn -EINVAL;\r\n}\r\nstatic int gdrom_bdops_open(struct block_device *bdev, fmode_t mode)\r\n{\r\nint ret;\r\nmutex_lock(&gdrom_mutex);\r\nret = cdrom_open(gd.cd_info, bdev, mode);\r\nmutex_unlock(&gdrom_mutex);\r\nreturn ret;\r\n}\r\nstatic int gdrom_bdops_release(struct gendisk *disk, fmode_t mode)\r\n{\r\nmutex_lock(&gdrom_mutex);\r\ncdrom_release(gd.cd_info, mode);\r\nmutex_unlock(&gdrom_mutex);\r\nreturn 0;\r\n}\r\nstatic unsigned int gdrom_bdops_check_events(struct gendisk *disk,\r\nunsigned int clearing)\r\n{\r\nreturn cdrom_check_events(gd.cd_info, clearing);\r\n}\r\nstatic int gdrom_bdops_ioctl(struct block_device *bdev, fmode_t mode,\r\nunsigned cmd, unsigned long arg)\r\n{\r\nint ret;\r\nmutex_lock(&gdrom_mutex);\r\nret = cdrom_ioctl(gd.cd_info, bdev, mode, cmd, arg);\r\nmutex_unlock(&gdrom_mutex);\r\nreturn ret;\r\n}\r\nstatic irqreturn_t gdrom_command_interrupt(int irq, void *dev_id)\r\n{\r\ngd.status = __raw_readb(GDROM_STATUSCOMMAND_REG);\r\nif (gd.pending != 1)\r\nreturn IRQ_HANDLED;\r\ngd.pending = 0;\r\nwake_up_interruptible(&command_queue);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t gdrom_dma_interrupt(int irq, void *dev_id)\r\n{\r\ngd.status = __raw_readb(GDROM_STATUSCOMMAND_REG);\r\nif (gd.transfer != 1)\r\nreturn IRQ_HANDLED;\r\ngd.transfer = 0;\r\nwake_up_interruptible(&request_queue);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int gdrom_set_interrupt_handlers(void)\r\n{\r\nint err;\r\nerr = request_irq(HW_EVENT_GDROM_CMD, gdrom_command_interrupt,\r\nIRQF_DISABLED, "gdrom_command", &gd);\r\nif (err)\r\nreturn err;\r\nerr = request_irq(HW_EVENT_GDROM_DMA, gdrom_dma_interrupt,\r\nIRQF_DISABLED, "gdrom_dma", &gd);\r\nif (err)\r\nfree_irq(HW_EVENT_GDROM_CMD, &gd);\r\nreturn err;\r\n}\r\nstatic void gdrom_readdisk_dma(struct work_struct *work)\r\n{\r\nint err, block, block_cnt;\r\nstruct packet_command *read_command;\r\nstruct list_head *elem, *next;\r\nstruct request *req;\r\nunsigned long timeout;\r\nif (list_empty(&gdrom_deferred))\r\nreturn;\r\nread_command = kzalloc(sizeof(struct packet_command), GFP_KERNEL);\r\nif (!read_command)\r\nreturn;\r\nread_command->cmd[0] = 0x30;\r\nread_command->cmd[1] = 0x20;\r\nspin_lock(&gdrom_lock);\r\nlist_for_each_safe(elem, next, &gdrom_deferred) {\r\nreq = list_entry(elem, struct request, queuelist);\r\nspin_unlock(&gdrom_lock);\r\nblock = blk_rq_pos(req)/GD_TO_BLK + GD_SESSION_OFFSET;\r\nblock_cnt = blk_rq_sectors(req)/GD_TO_BLK;\r\n__raw_writel(virt_to_phys(req->buffer), GDROM_DMA_STARTADDR_REG);\r\n__raw_writel(block_cnt * GDROM_HARD_SECTOR, GDROM_DMA_LENGTH_REG);\r\n__raw_writel(1, GDROM_DMA_DIRECTION_REG);\r\n__raw_writel(1, GDROM_DMA_ENABLE_REG);\r\nread_command->cmd[2] = (block >> 16) & 0xFF;\r\nread_command->cmd[3] = (block >> 8) & 0xFF;\r\nread_command->cmd[4] = block & 0xFF;\r\nread_command->cmd[8] = (block_cnt >> 16) & 0xFF;\r\nread_command->cmd[9] = (block_cnt >> 8) & 0xFF;\r\nread_command->cmd[10] = block_cnt & 0xFF;\r\n__raw_writeb(1, GDROM_ERROR_REG);\r\n__raw_writeb(0, GDROM_SECNUM_REG);\r\n__raw_writeb(0, GDROM_BCL_REG);\r\n__raw_writeb(0, GDROM_BCH_REG);\r\n__raw_writeb(0, GDROM_DSEL_REG);\r\n__raw_writeb(0, GDROM_INTSEC_REG);\r\ntimeout = jiffies + HZ / 2;\r\nwhile (gdrom_is_busy() && time_before(jiffies, timeout))\r\ncpu_relax();\r\n__raw_writeb(GDROM_COM_PACKET, GDROM_STATUSCOMMAND_REG);\r\ntimeout = jiffies + HZ / 2;\r\nwhile (gdrom_is_busy() && time_before(jiffies, timeout))\r\ncpu_relax();\r\ngd.pending = 1;\r\ngd.transfer = 1;\r\noutsw(GDROM_DATA_REG, &read_command->cmd, 6);\r\ntimeout = jiffies + HZ / 2;\r\nwhile (__raw_readb(GDROM_DMA_STATUS_REG) &&\r\ntime_before(jiffies, timeout))\r\ncpu_relax();\r\n__raw_writeb(1, GDROM_DMA_STATUS_REG);\r\nwait_event_interruptible_timeout(request_queue,\r\ngd.transfer == 0, GDROM_DEFAULT_TIMEOUT);\r\nerr = gd.transfer ? -EIO : 0;\r\ngd.transfer = 0;\r\ngd.pending = 0;\r\nspin_lock(&gdrom_lock);\r\nlist_del_init(&req->queuelist);\r\n__blk_end_request_all(req, err);\r\n}\r\nspin_unlock(&gdrom_lock);\r\nkfree(read_command);\r\n}\r\nstatic void gdrom_request(struct request_queue *rq)\r\n{\r\nstruct request *req;\r\nwhile ((req = blk_fetch_request(rq)) != NULL) {\r\nif (req->cmd_type != REQ_TYPE_FS) {\r\nprintk(KERN_DEBUG "gdrom: Non-fs request ignored\n");\r\n__blk_end_request_all(req, -EIO);\r\ncontinue;\r\n}\r\nif (rq_data_dir(req) != READ) {\r\npr_notice("Read only device - write request ignored\n");\r\n__blk_end_request_all(req, -EIO);\r\ncontinue;\r\n}\r\nlist_add_tail(&req->queuelist, &gdrom_deferred);\r\nschedule_work(&work);\r\n}\r\n}\r\nstatic int gdrom_outputversion(void)\r\n{\r\nstruct gdrom_id *id;\r\nchar *model_name, *manuf_name, *firmw_ver;\r\nint err = -ENOMEM;\r\nid = kzalloc(sizeof(struct gdrom_id), GFP_KERNEL);\r\nif (!id)\r\nreturn err;\r\ngdrom_identifydevice(id);\r\nmodel_name = kstrndup(id->modname, 16, GFP_KERNEL);\r\nif (!model_name)\r\ngoto free_id;\r\nmanuf_name = kstrndup(id->mname, 16, GFP_KERNEL);\r\nif (!manuf_name)\r\ngoto free_model_name;\r\nfirmw_ver = kstrndup(id->firmver, 16, GFP_KERNEL);\r\nif (!firmw_ver)\r\ngoto free_manuf_name;\r\npr_info("%s from %s with firmware %s\n",\r\nmodel_name, manuf_name, firmw_ver);\r\nerr = 0;\r\nkfree(firmw_ver);\r\nfree_manuf_name:\r\nkfree(manuf_name);\r\nfree_model_name:\r\nkfree(model_name);\r\nfree_id:\r\nkfree(id);\r\nreturn err;\r\n}\r\nstatic int gdrom_init_dma_mode(void)\r\n{\r\n__raw_writeb(0x13, GDROM_ERROR_REG);\r\n__raw_writeb(0x22, GDROM_INTSEC_REG);\r\nif (!gdrom_wait_clrbusy())\r\nreturn -EBUSY;\r\n__raw_writeb(0xEF, GDROM_STATUSCOMMAND_REG);\r\nif (!gdrom_wait_busy_sleeps())\r\nreturn -EBUSY;\r\n__raw_writel(0x8843407F, GDROM_DMA_ACCESS_CTRL_REG);\r\n__raw_writel(9, GDROM_DMA_WAIT_REG);\r\nreturn 0;\r\n}\r\nstatic void probe_gdrom_setupcd(void)\r\n{\r\ngd.cd_info->ops = &gdrom_ops;\r\ngd.cd_info->capacity = 1;\r\nstrcpy(gd.cd_info->name, GDROM_DEV_NAME);\r\ngd.cd_info->mask = CDC_CLOSE_TRAY|CDC_OPEN_TRAY|CDC_LOCK|\r\nCDC_SELECT_DISC;\r\n}\r\nstatic void probe_gdrom_setupdisk(void)\r\n{\r\ngd.disk->major = gdrom_major;\r\ngd.disk->first_minor = 1;\r\ngd.disk->minors = 1;\r\nstrcpy(gd.disk->disk_name, GDROM_DEV_NAME);\r\n}\r\nstatic int probe_gdrom_setupqueue(void)\r\n{\r\nblk_queue_logical_block_size(gd.gdrom_rq, GDROM_HARD_SECTOR);\r\nblk_queue_max_segments(gd.gdrom_rq, 1);\r\nblk_queue_max_segment_size(gd.gdrom_rq, 0x40000);\r\ngd.disk->queue = gd.gdrom_rq;\r\nreturn gdrom_init_dma_mode();\r\n}\r\nstatic int probe_gdrom(struct platform_device *devptr)\r\n{\r\nint err;\r\nif (gdrom_execute_diagnostic() != 1) {\r\npr_warning("ATA Probe for GDROM failed\n");\r\nreturn -ENODEV;\r\n}\r\nif (gdrom_outputversion())\r\nreturn -ENOMEM;\r\ngdrom_major = register_blkdev(0, GDROM_DEV_NAME);\r\nif (gdrom_major <= 0)\r\nreturn gdrom_major;\r\npr_info("Registered with major number %d\n",\r\ngdrom_major);\r\ngd.cd_info = kzalloc(sizeof(struct cdrom_device_info), GFP_KERNEL);\r\nif (!gd.cd_info) {\r\nerr = -ENOMEM;\r\ngoto probe_fail_no_mem;\r\n}\r\nprobe_gdrom_setupcd();\r\ngd.disk = alloc_disk(1);\r\nif (!gd.disk) {\r\nerr = -ENODEV;\r\ngoto probe_fail_no_disk;\r\n}\r\nprobe_gdrom_setupdisk();\r\nif (register_cdrom(gd.cd_info)) {\r\nerr = -ENODEV;\r\ngoto probe_fail_cdrom_register;\r\n}\r\ngd.disk->fops = &gdrom_bdops;\r\nerr = gdrom_set_interrupt_handlers();\r\nif (err)\r\ngoto probe_fail_cmdirq_register;\r\ngd.gdrom_rq = blk_init_queue(gdrom_request, &gdrom_lock);\r\nif (!gd.gdrom_rq)\r\ngoto probe_fail_requestq;\r\nerr = probe_gdrom_setupqueue();\r\nif (err)\r\ngoto probe_fail_toc;\r\ngd.toc = kzalloc(sizeof(struct gdromtoc), GFP_KERNEL);\r\nif (!gd.toc)\r\ngoto probe_fail_toc;\r\nadd_disk(gd.disk);\r\nreturn 0;\r\nprobe_fail_toc:\r\nblk_cleanup_queue(gd.gdrom_rq);\r\nprobe_fail_requestq:\r\nfree_irq(HW_EVENT_GDROM_DMA, &gd);\r\nfree_irq(HW_EVENT_GDROM_CMD, &gd);\r\nprobe_fail_cmdirq_register:\r\nprobe_fail_cdrom_register:\r\ndel_gendisk(gd.disk);\r\nprobe_fail_no_disk:\r\nkfree(gd.cd_info);\r\nunregister_blkdev(gdrom_major, GDROM_DEV_NAME);\r\ngdrom_major = 0;\r\nprobe_fail_no_mem:\r\npr_warning("Probe failed - error is 0x%X\n", err);\r\nreturn err;\r\n}\r\nstatic int remove_gdrom(struct platform_device *devptr)\r\n{\r\nflush_work(&work);\r\nblk_cleanup_queue(gd.gdrom_rq);\r\nfree_irq(HW_EVENT_GDROM_CMD, &gd);\r\nfree_irq(HW_EVENT_GDROM_DMA, &gd);\r\ndel_gendisk(gd.disk);\r\nif (gdrom_major)\r\nunregister_blkdev(gdrom_major, GDROM_DEV_NAME);\r\nunregister_cdrom(gd.cd_info);\r\nreturn 0;\r\n}\r\nstatic int __init init_gdrom(void)\r\n{\r\nint rc;\r\ngd.toc = NULL;\r\nrc = platform_driver_register(&gdrom_driver);\r\nif (rc)\r\nreturn rc;\r\npd = platform_device_register_simple(GDROM_DEV_NAME, -1, NULL, 0);\r\nif (IS_ERR(pd)) {\r\nplatform_driver_unregister(&gdrom_driver);\r\nreturn PTR_ERR(pd);\r\n}\r\nreturn 0;\r\n}\r\nstatic void __exit exit_gdrom(void)\r\n{\r\nplatform_device_unregister(pd);\r\nplatform_driver_unregister(&gdrom_driver);\r\nkfree(gd.toc);\r\n}
