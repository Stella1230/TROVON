static struct pktcdvd_kobj* pkt_kobj_create(struct pktcdvd_device *pd,\r\nconst char* name,\r\nstruct kobject* parent,\r\nstruct kobj_type* ktype)\r\n{\r\nstruct pktcdvd_kobj *p;\r\nint error;\r\np = kzalloc(sizeof(*p), GFP_KERNEL);\r\nif (!p)\r\nreturn NULL;\r\np->pd = pd;\r\nerror = kobject_init_and_add(&p->kobj, ktype, parent, "%s", name);\r\nif (error) {\r\nkobject_put(&p->kobj);\r\nreturn NULL;\r\n}\r\nkobject_uevent(&p->kobj, KOBJ_ADD);\r\nreturn p;\r\n}\r\nstatic void pkt_kobj_remove(struct pktcdvd_kobj *p)\r\n{\r\nif (p)\r\nkobject_put(&p->kobj);\r\n}\r\nstatic void pkt_kobj_release(struct kobject *kobj)\r\n{\r\nkfree(to_pktcdvdkobj(kobj));\r\n}\r\nstatic ssize_t kobj_pkt_show(struct kobject *kobj,\r\nstruct attribute *attr, char *data)\r\n{\r\nstruct pktcdvd_device *pd = to_pktcdvdkobj(kobj)->pd;\r\nint n = 0;\r\nint v;\r\nif (strcmp(attr->name, "packets_started") == 0) {\r\nn = sprintf(data, "%lu\n", pd->stats.pkt_started);\r\n} else if (strcmp(attr->name, "packets_finished") == 0) {\r\nn = sprintf(data, "%lu\n", pd->stats.pkt_ended);\r\n} else if (strcmp(attr->name, "kb_written") == 0) {\r\nn = sprintf(data, "%lu\n", pd->stats.secs_w >> 1);\r\n} else if (strcmp(attr->name, "kb_read") == 0) {\r\nn = sprintf(data, "%lu\n", pd->stats.secs_r >> 1);\r\n} else if (strcmp(attr->name, "kb_read_gather") == 0) {\r\nn = sprintf(data, "%lu\n", pd->stats.secs_rg >> 1);\r\n} else if (strcmp(attr->name, "size") == 0) {\r\nspin_lock(&pd->lock);\r\nv = pd->bio_queue_size;\r\nspin_unlock(&pd->lock);\r\nn = sprintf(data, "%d\n", v);\r\n} else if (strcmp(attr->name, "congestion_off") == 0) {\r\nspin_lock(&pd->lock);\r\nv = pd->write_congestion_off;\r\nspin_unlock(&pd->lock);\r\nn = sprintf(data, "%d\n", v);\r\n} else if (strcmp(attr->name, "congestion_on") == 0) {\r\nspin_lock(&pd->lock);\r\nv = pd->write_congestion_on;\r\nspin_unlock(&pd->lock);\r\nn = sprintf(data, "%d\n", v);\r\n}\r\nreturn n;\r\n}\r\nstatic void init_write_congestion_marks(int* lo, int* hi)\r\n{\r\nif (*hi > 0) {\r\n*hi = max(*hi, 500);\r\n*hi = min(*hi, 1000000);\r\nif (*lo <= 0)\r\n*lo = *hi - 100;\r\nelse {\r\n*lo = min(*lo, *hi - 100);\r\n*lo = max(*lo, 100);\r\n}\r\n} else {\r\n*hi = -1;\r\n*lo = -1;\r\n}\r\n}\r\nstatic ssize_t kobj_pkt_store(struct kobject *kobj,\r\nstruct attribute *attr,\r\nconst char *data, size_t len)\r\n{\r\nstruct pktcdvd_device *pd = to_pktcdvdkobj(kobj)->pd;\r\nint val;\r\nif (strcmp(attr->name, "reset") == 0 && len > 0) {\r\npd->stats.pkt_started = 0;\r\npd->stats.pkt_ended = 0;\r\npd->stats.secs_w = 0;\r\npd->stats.secs_rg = 0;\r\npd->stats.secs_r = 0;\r\n} else if (strcmp(attr->name, "congestion_off") == 0\r\n&& sscanf(data, "%d", &val) == 1) {\r\nspin_lock(&pd->lock);\r\npd->write_congestion_off = val;\r\ninit_write_congestion_marks(&pd->write_congestion_off,\r\n&pd->write_congestion_on);\r\nspin_unlock(&pd->lock);\r\n} else if (strcmp(attr->name, "congestion_on") == 0\r\n&& sscanf(data, "%d", &val) == 1) {\r\nspin_lock(&pd->lock);\r\npd->write_congestion_on = val;\r\ninit_write_congestion_marks(&pd->write_congestion_off,\r\n&pd->write_congestion_on);\r\nspin_unlock(&pd->lock);\r\n}\r\nreturn len;\r\n}\r\nstatic void pkt_sysfs_dev_new(struct pktcdvd_device *pd)\r\n{\r\nif (class_pktcdvd) {\r\npd->dev = device_create(class_pktcdvd, NULL, MKDEV(0, 0), NULL,\r\n"%s", pd->name);\r\nif (IS_ERR(pd->dev))\r\npd->dev = NULL;\r\n}\r\nif (pd->dev) {\r\npd->kobj_stat = pkt_kobj_create(pd, "stat",\r\n&pd->dev->kobj,\r\n&kobj_pkt_type_stat);\r\npd->kobj_wqueue = pkt_kobj_create(pd, "write_queue",\r\n&pd->dev->kobj,\r\n&kobj_pkt_type_wqueue);\r\n}\r\n}\r\nstatic void pkt_sysfs_dev_remove(struct pktcdvd_device *pd)\r\n{\r\npkt_kobj_remove(pd->kobj_stat);\r\npkt_kobj_remove(pd->kobj_wqueue);\r\nif (class_pktcdvd)\r\ndevice_unregister(pd->dev);\r\n}\r\nstatic void class_pktcdvd_release(struct class *cls)\r\n{\r\nkfree(cls);\r\n}\r\nstatic ssize_t class_pktcdvd_show_map(struct class *c,\r\nstruct class_attribute *attr,\r\nchar *data)\r\n{\r\nint n = 0;\r\nint idx;\r\nmutex_lock_nested(&ctl_mutex, SINGLE_DEPTH_NESTING);\r\nfor (idx = 0; idx < MAX_WRITERS; idx++) {\r\nstruct pktcdvd_device *pd = pkt_devs[idx];\r\nif (!pd)\r\ncontinue;\r\nn += sprintf(data+n, "%s %u:%u %u:%u\n",\r\npd->name,\r\nMAJOR(pd->pkt_dev), MINOR(pd->pkt_dev),\r\nMAJOR(pd->bdev->bd_dev),\r\nMINOR(pd->bdev->bd_dev));\r\n}\r\nmutex_unlock(&ctl_mutex);\r\nreturn n;\r\n}\r\nstatic ssize_t class_pktcdvd_store_add(struct class *c,\r\nstruct class_attribute *attr,\r\nconst char *buf,\r\nsize_t count)\r\n{\r\nunsigned int major, minor;\r\nif (sscanf(buf, "%u:%u", &major, &minor) == 2) {\r\nif (!try_module_get(THIS_MODULE))\r\nreturn -ENODEV;\r\npkt_setup_dev(MKDEV(major, minor), NULL);\r\nmodule_put(THIS_MODULE);\r\nreturn count;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic ssize_t class_pktcdvd_store_remove(struct class *c,\r\nstruct class_attribute *attr,\r\nconst char *buf,\r\nsize_t count)\r\n{\r\nunsigned int major, minor;\r\nif (sscanf(buf, "%u:%u", &major, &minor) == 2) {\r\npkt_remove_dev(MKDEV(major, minor));\r\nreturn count;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int pkt_sysfs_init(void)\r\n{\r\nint ret = 0;\r\nclass_pktcdvd = kzalloc(sizeof(*class_pktcdvd), GFP_KERNEL);\r\nif (!class_pktcdvd)\r\nreturn -ENOMEM;\r\nclass_pktcdvd->name = DRIVER_NAME;\r\nclass_pktcdvd->owner = THIS_MODULE;\r\nclass_pktcdvd->class_release = class_pktcdvd_release;\r\nclass_pktcdvd->class_attrs = class_pktcdvd_attrs;\r\nret = class_register(class_pktcdvd);\r\nif (ret) {\r\nkfree(class_pktcdvd);\r\nclass_pktcdvd = NULL;\r\nprintk(DRIVER_NAME": failed to create class pktcdvd\n");\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic void pkt_sysfs_cleanup(void)\r\n{\r\nif (class_pktcdvd)\r\nclass_destroy(class_pktcdvd);\r\nclass_pktcdvd = NULL;\r\n}\r\nstatic int pkt_debugfs_seq_show(struct seq_file *m, void *p)\r\n{\r\nreturn pkt_seq_show(m, p);\r\n}\r\nstatic int pkt_debugfs_fops_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, pkt_debugfs_seq_show, inode->i_private);\r\n}\r\nstatic void pkt_debugfs_dev_new(struct pktcdvd_device *pd)\r\n{\r\nif (!pkt_debugfs_root)\r\nreturn;\r\npd->dfs_f_info = NULL;\r\npd->dfs_d_root = debugfs_create_dir(pd->name, pkt_debugfs_root);\r\nif (IS_ERR(pd->dfs_d_root)) {\r\npd->dfs_d_root = NULL;\r\nreturn;\r\n}\r\npd->dfs_f_info = debugfs_create_file("info", S_IRUGO,\r\npd->dfs_d_root, pd, &debug_fops);\r\nif (IS_ERR(pd->dfs_f_info)) {\r\npd->dfs_f_info = NULL;\r\nreturn;\r\n}\r\n}\r\nstatic void pkt_debugfs_dev_remove(struct pktcdvd_device *pd)\r\n{\r\nif (!pkt_debugfs_root)\r\nreturn;\r\nif (pd->dfs_f_info)\r\ndebugfs_remove(pd->dfs_f_info);\r\npd->dfs_f_info = NULL;\r\nif (pd->dfs_d_root)\r\ndebugfs_remove(pd->dfs_d_root);\r\npd->dfs_d_root = NULL;\r\n}\r\nstatic void pkt_debugfs_init(void)\r\n{\r\npkt_debugfs_root = debugfs_create_dir(DRIVER_NAME, NULL);\r\nif (IS_ERR(pkt_debugfs_root)) {\r\npkt_debugfs_root = NULL;\r\nreturn;\r\n}\r\n}\r\nstatic void pkt_debugfs_cleanup(void)\r\n{\r\nif (!pkt_debugfs_root)\r\nreturn;\r\ndebugfs_remove(pkt_debugfs_root);\r\npkt_debugfs_root = NULL;\r\n}\r\nstatic void pkt_bio_finished(struct pktcdvd_device *pd)\r\n{\r\nBUG_ON(atomic_read(&pd->cdrw.pending_bios) <= 0);\r\nif (atomic_dec_and_test(&pd->cdrw.pending_bios)) {\r\nVPRINTK(DRIVER_NAME": queue empty\n");\r\natomic_set(&pd->iosched.attention, 1);\r\nwake_up(&pd->wqueue);\r\n}\r\n}\r\nstatic struct packet_data *pkt_alloc_packet_data(int frames)\r\n{\r\nint i;\r\nstruct packet_data *pkt;\r\npkt = kzalloc(sizeof(struct packet_data), GFP_KERNEL);\r\nif (!pkt)\r\ngoto no_pkt;\r\npkt->frames = frames;\r\npkt->w_bio = bio_kmalloc(GFP_KERNEL, frames);\r\nif (!pkt->w_bio)\r\ngoto no_bio;\r\nfor (i = 0; i < frames / FRAMES_PER_PAGE; i++) {\r\npkt->pages[i] = alloc_page(GFP_KERNEL|__GFP_ZERO);\r\nif (!pkt->pages[i])\r\ngoto no_page;\r\n}\r\nspin_lock_init(&pkt->lock);\r\nbio_list_init(&pkt->orig_bios);\r\nfor (i = 0; i < frames; i++) {\r\nstruct bio *bio = bio_kmalloc(GFP_KERNEL, 1);\r\nif (!bio)\r\ngoto no_rd_bio;\r\npkt->r_bios[i] = bio;\r\n}\r\nreturn pkt;\r\nno_rd_bio:\r\nfor (i = 0; i < frames; i++) {\r\nstruct bio *bio = pkt->r_bios[i];\r\nif (bio)\r\nbio_put(bio);\r\n}\r\nno_page:\r\nfor (i = 0; i < frames / FRAMES_PER_PAGE; i++)\r\nif (pkt->pages[i])\r\n__free_page(pkt->pages[i]);\r\nbio_put(pkt->w_bio);\r\nno_bio:\r\nkfree(pkt);\r\nno_pkt:\r\nreturn NULL;\r\n}\r\nstatic void pkt_free_packet_data(struct packet_data *pkt)\r\n{\r\nint i;\r\nfor (i = 0; i < pkt->frames; i++) {\r\nstruct bio *bio = pkt->r_bios[i];\r\nif (bio)\r\nbio_put(bio);\r\n}\r\nfor (i = 0; i < pkt->frames / FRAMES_PER_PAGE; i++)\r\n__free_page(pkt->pages[i]);\r\nbio_put(pkt->w_bio);\r\nkfree(pkt);\r\n}\r\nstatic void pkt_shrink_pktlist(struct pktcdvd_device *pd)\r\n{\r\nstruct packet_data *pkt, *next;\r\nBUG_ON(!list_empty(&pd->cdrw.pkt_active_list));\r\nlist_for_each_entry_safe(pkt, next, &pd->cdrw.pkt_free_list, list) {\r\npkt_free_packet_data(pkt);\r\n}\r\nINIT_LIST_HEAD(&pd->cdrw.pkt_free_list);\r\n}\r\nstatic int pkt_grow_pktlist(struct pktcdvd_device *pd, int nr_packets)\r\n{\r\nstruct packet_data *pkt;\r\nBUG_ON(!list_empty(&pd->cdrw.pkt_free_list));\r\nwhile (nr_packets > 0) {\r\npkt = pkt_alloc_packet_data(pd->settings.size >> 2);\r\nif (!pkt) {\r\npkt_shrink_pktlist(pd);\r\nreturn 0;\r\n}\r\npkt->id = nr_packets;\r\npkt->pd = pd;\r\nlist_add(&pkt->list, &pd->cdrw.pkt_free_list);\r\nnr_packets--;\r\n}\r\nreturn 1;\r\n}\r\nstatic inline struct pkt_rb_node *pkt_rbtree_next(struct pkt_rb_node *node)\r\n{\r\nstruct rb_node *n = rb_next(&node->rb_node);\r\nif (!n)\r\nreturn NULL;\r\nreturn rb_entry(n, struct pkt_rb_node, rb_node);\r\n}\r\nstatic void pkt_rbtree_erase(struct pktcdvd_device *pd, struct pkt_rb_node *node)\r\n{\r\nrb_erase(&node->rb_node, &pd->bio_queue);\r\nmempool_free(node, pd->rb_pool);\r\npd->bio_queue_size--;\r\nBUG_ON(pd->bio_queue_size < 0);\r\n}\r\nstatic struct pkt_rb_node *pkt_rbtree_find(struct pktcdvd_device *pd, sector_t s)\r\n{\r\nstruct rb_node *n = pd->bio_queue.rb_node;\r\nstruct rb_node *next;\r\nstruct pkt_rb_node *tmp;\r\nif (!n) {\r\nBUG_ON(pd->bio_queue_size > 0);\r\nreturn NULL;\r\n}\r\nfor (;;) {\r\ntmp = rb_entry(n, struct pkt_rb_node, rb_node);\r\nif (s <= tmp->bio->bi_sector)\r\nnext = n->rb_left;\r\nelse\r\nnext = n->rb_right;\r\nif (!next)\r\nbreak;\r\nn = next;\r\n}\r\nif (s > tmp->bio->bi_sector) {\r\ntmp = pkt_rbtree_next(tmp);\r\nif (!tmp)\r\nreturn NULL;\r\n}\r\nBUG_ON(s > tmp->bio->bi_sector);\r\nreturn tmp;\r\n}\r\nstatic void pkt_rbtree_insert(struct pktcdvd_device *pd, struct pkt_rb_node *node)\r\n{\r\nstruct rb_node **p = &pd->bio_queue.rb_node;\r\nstruct rb_node *parent = NULL;\r\nsector_t s = node->bio->bi_sector;\r\nstruct pkt_rb_node *tmp;\r\nwhile (*p) {\r\nparent = *p;\r\ntmp = rb_entry(parent, struct pkt_rb_node, rb_node);\r\nif (s < tmp->bio->bi_sector)\r\np = &(*p)->rb_left;\r\nelse\r\np = &(*p)->rb_right;\r\n}\r\nrb_link_node(&node->rb_node, parent, p);\r\nrb_insert_color(&node->rb_node, &pd->bio_queue);\r\npd->bio_queue_size++;\r\n}\r\nstatic int pkt_generic_packet(struct pktcdvd_device *pd, struct packet_command *cgc)\r\n{\r\nstruct request_queue *q = bdev_get_queue(pd->bdev);\r\nstruct request *rq;\r\nint ret = 0;\r\nrq = blk_get_request(q, (cgc->data_direction == CGC_DATA_WRITE) ?\r\nWRITE : READ, __GFP_WAIT);\r\nif (cgc->buflen) {\r\nif (blk_rq_map_kern(q, rq, cgc->buffer, cgc->buflen, __GFP_WAIT))\r\ngoto out;\r\n}\r\nrq->cmd_len = COMMAND_SIZE(cgc->cmd[0]);\r\nmemcpy(rq->cmd, cgc->cmd, CDROM_PACKET_SIZE);\r\nrq->timeout = 60*HZ;\r\nrq->cmd_type = REQ_TYPE_BLOCK_PC;\r\nif (cgc->quiet)\r\nrq->cmd_flags |= REQ_QUIET;\r\nblk_execute_rq(rq->q, pd->bdev->bd_disk, rq, 0);\r\nif (rq->errors)\r\nret = -EIO;\r\nout:\r\nblk_put_request(rq);\r\nreturn ret;\r\n}\r\nstatic void pkt_dump_sense(struct packet_command *cgc)\r\n{\r\nstatic char *info[9] = { "No sense", "Recovered error", "Not ready",\r\n"Medium error", "Hardware error", "Illegal request",\r\n"Unit attention", "Data protect", "Blank check" };\r\nint i;\r\nstruct request_sense *sense = cgc->sense;\r\nprintk(DRIVER_NAME":");\r\nfor (i = 0; i < CDROM_PACKET_SIZE; i++)\r\nprintk(" %02x", cgc->cmd[i]);\r\nprintk(" - ");\r\nif (sense == NULL) {\r\nprintk("no sense\n");\r\nreturn;\r\n}\r\nprintk("sense %02x.%02x.%02x", sense->sense_key, sense->asc, sense->ascq);\r\nif (sense->sense_key > 8) {\r\nprintk(" (INVALID)\n");\r\nreturn;\r\n}\r\nprintk(" (%s)\n", info[sense->sense_key]);\r\n}\r\nstatic int pkt_flush_cache(struct pktcdvd_device *pd)\r\n{\r\nstruct packet_command cgc;\r\ninit_cdrom_command(&cgc, NULL, 0, CGC_DATA_NONE);\r\ncgc.cmd[0] = GPCMD_FLUSH_CACHE;\r\ncgc.quiet = 1;\r\n#if 0\r\ncgc.cmd[1] = 1 << 1;\r\n#endif\r\nreturn pkt_generic_packet(pd, &cgc);\r\n}\r\nstatic noinline_for_stack int pkt_set_speed(struct pktcdvd_device *pd,\r\nunsigned write_speed, unsigned read_speed)\r\n{\r\nstruct packet_command cgc;\r\nstruct request_sense sense;\r\nint ret;\r\ninit_cdrom_command(&cgc, NULL, 0, CGC_DATA_NONE);\r\ncgc.sense = &sense;\r\ncgc.cmd[0] = GPCMD_SET_SPEED;\r\ncgc.cmd[2] = (read_speed >> 8) & 0xff;\r\ncgc.cmd[3] = read_speed & 0xff;\r\ncgc.cmd[4] = (write_speed >> 8) & 0xff;\r\ncgc.cmd[5] = write_speed & 0xff;\r\nif ((ret = pkt_generic_packet(pd, &cgc)))\r\npkt_dump_sense(&cgc);\r\nreturn ret;\r\n}\r\nstatic void pkt_queue_bio(struct pktcdvd_device *pd, struct bio *bio)\r\n{\r\nspin_lock(&pd->iosched.lock);\r\nif (bio_data_dir(bio) == READ)\r\nbio_list_add(&pd->iosched.read_queue, bio);\r\nelse\r\nbio_list_add(&pd->iosched.write_queue, bio);\r\nspin_unlock(&pd->iosched.lock);\r\natomic_set(&pd->iosched.attention, 1);\r\nwake_up(&pd->wqueue);\r\n}\r\nstatic void pkt_iosched_process_queue(struct pktcdvd_device *pd)\r\n{\r\nif (atomic_read(&pd->iosched.attention) == 0)\r\nreturn;\r\natomic_set(&pd->iosched.attention, 0);\r\nfor (;;) {\r\nstruct bio *bio;\r\nint reads_queued, writes_queued;\r\nspin_lock(&pd->iosched.lock);\r\nreads_queued = !bio_list_empty(&pd->iosched.read_queue);\r\nwrites_queued = !bio_list_empty(&pd->iosched.write_queue);\r\nspin_unlock(&pd->iosched.lock);\r\nif (!reads_queued && !writes_queued)\r\nbreak;\r\nif (pd->iosched.writing) {\r\nint need_write_seek = 1;\r\nspin_lock(&pd->iosched.lock);\r\nbio = bio_list_peek(&pd->iosched.write_queue);\r\nspin_unlock(&pd->iosched.lock);\r\nif (bio && (bio->bi_sector == pd->iosched.last_write))\r\nneed_write_seek = 0;\r\nif (need_write_seek && reads_queued) {\r\nif (atomic_read(&pd->cdrw.pending_bios) > 0) {\r\nVPRINTK(DRIVER_NAME": write, waiting\n");\r\nbreak;\r\n}\r\npkt_flush_cache(pd);\r\npd->iosched.writing = 0;\r\n}\r\n} else {\r\nif (!reads_queued && writes_queued) {\r\nif (atomic_read(&pd->cdrw.pending_bios) > 0) {\r\nVPRINTK(DRIVER_NAME": read, waiting\n");\r\nbreak;\r\n}\r\npd->iosched.writing = 1;\r\n}\r\n}\r\nspin_lock(&pd->iosched.lock);\r\nif (pd->iosched.writing)\r\nbio = bio_list_pop(&pd->iosched.write_queue);\r\nelse\r\nbio = bio_list_pop(&pd->iosched.read_queue);\r\nspin_unlock(&pd->iosched.lock);\r\nif (!bio)\r\ncontinue;\r\nif (bio_data_dir(bio) == READ)\r\npd->iosched.successive_reads += bio->bi_size >> 10;\r\nelse {\r\npd->iosched.successive_reads = 0;\r\npd->iosched.last_write = bio->bi_sector + bio_sectors(bio);\r\n}\r\nif (pd->iosched.successive_reads >= HI_SPEED_SWITCH) {\r\nif (pd->read_speed == pd->write_speed) {\r\npd->read_speed = MAX_SPEED;\r\npkt_set_speed(pd, pd->write_speed, pd->read_speed);\r\n}\r\n} else {\r\nif (pd->read_speed != pd->write_speed) {\r\npd->read_speed = pd->write_speed;\r\npkt_set_speed(pd, pd->write_speed, pd->read_speed);\r\n}\r\n}\r\natomic_inc(&pd->cdrw.pending_bios);\r\ngeneric_make_request(bio);\r\n}\r\n}\r\nstatic int pkt_set_segment_merging(struct pktcdvd_device *pd, struct request_queue *q)\r\n{\r\nif ((pd->settings.size << 9) / CD_FRAMESIZE\r\n<= queue_max_segments(q)) {\r\nclear_bit(PACKET_MERGE_SEGS, &pd->flags);\r\nreturn 0;\r\n} else if ((pd->settings.size << 9) / PAGE_SIZE\r\n<= queue_max_segments(q)) {\r\nset_bit(PACKET_MERGE_SEGS, &pd->flags);\r\nreturn 0;\r\n} else {\r\nprintk(DRIVER_NAME": cdrom max_phys_segments too small\n");\r\nreturn -EIO;\r\n}\r\n}\r\nstatic void pkt_copy_bio_data(struct bio *src_bio, int seg, int offs, struct page *dst_page, int dst_offs)\r\n{\r\nunsigned int copy_size = CD_FRAMESIZE;\r\nwhile (copy_size > 0) {\r\nstruct bio_vec *src_bvl = bio_iovec_idx(src_bio, seg);\r\nvoid *vfrom = kmap_atomic(src_bvl->bv_page) +\r\nsrc_bvl->bv_offset + offs;\r\nvoid *vto = page_address(dst_page) + dst_offs;\r\nint len = min_t(int, copy_size, src_bvl->bv_len - offs);\r\nBUG_ON(len < 0);\r\nmemcpy(vto, vfrom, len);\r\nkunmap_atomic(vfrom);\r\nseg++;\r\noffs = 0;\r\ndst_offs += len;\r\ncopy_size -= len;\r\n}\r\n}\r\nstatic void pkt_make_local_copy(struct packet_data *pkt, struct bio_vec *bvec)\r\n{\r\nint f, p, offs;\r\np = 0;\r\noffs = 0;\r\nfor (f = 0; f < pkt->frames; f++) {\r\nif (bvec[f].bv_page != pkt->pages[p]) {\r\nvoid *vfrom = kmap_atomic(bvec[f].bv_page) + bvec[f].bv_offset;\r\nvoid *vto = page_address(pkt->pages[p]) + offs;\r\nmemcpy(vto, vfrom, CD_FRAMESIZE);\r\nkunmap_atomic(vfrom);\r\nbvec[f].bv_page = pkt->pages[p];\r\nbvec[f].bv_offset = offs;\r\n} else {\r\nBUG_ON(bvec[f].bv_offset != offs);\r\n}\r\noffs += CD_FRAMESIZE;\r\nif (offs >= PAGE_SIZE) {\r\noffs = 0;\r\np++;\r\n}\r\n}\r\n}\r\nstatic void pkt_end_io_read(struct bio *bio, int err)\r\n{\r\nstruct packet_data *pkt = bio->bi_private;\r\nstruct pktcdvd_device *pd = pkt->pd;\r\nBUG_ON(!pd);\r\nVPRINTK("pkt_end_io_read: bio=%p sec0=%llx sec=%llx err=%d\n", bio,\r\n(unsigned long long)pkt->sector, (unsigned long long)bio->bi_sector, err);\r\nif (err)\r\natomic_inc(&pkt->io_errors);\r\nif (atomic_dec_and_test(&pkt->io_wait)) {\r\natomic_inc(&pkt->run_sm);\r\nwake_up(&pd->wqueue);\r\n}\r\npkt_bio_finished(pd);\r\n}\r\nstatic void pkt_end_io_packet_write(struct bio *bio, int err)\r\n{\r\nstruct packet_data *pkt = bio->bi_private;\r\nstruct pktcdvd_device *pd = pkt->pd;\r\nBUG_ON(!pd);\r\nVPRINTK("pkt_end_io_packet_write: id=%d, err=%d\n", pkt->id, err);\r\npd->stats.pkt_ended++;\r\npkt_bio_finished(pd);\r\natomic_dec(&pkt->io_wait);\r\natomic_inc(&pkt->run_sm);\r\nwake_up(&pd->wqueue);\r\n}\r\nstatic void pkt_gather_data(struct pktcdvd_device *pd, struct packet_data *pkt)\r\n{\r\nint frames_read = 0;\r\nstruct bio *bio;\r\nint f;\r\nchar written[PACKET_MAX_SIZE];\r\nBUG_ON(bio_list_empty(&pkt->orig_bios));\r\natomic_set(&pkt->io_wait, 0);\r\natomic_set(&pkt->io_errors, 0);\r\nmemset(written, 0, sizeof(written));\r\nspin_lock(&pkt->lock);\r\nbio_list_for_each(bio, &pkt->orig_bios) {\r\nint first_frame = (bio->bi_sector - pkt->sector) / (CD_FRAMESIZE >> 9);\r\nint num_frames = bio->bi_size / CD_FRAMESIZE;\r\npd->stats.secs_w += num_frames * (CD_FRAMESIZE >> 9);\r\nBUG_ON(first_frame < 0);\r\nBUG_ON(first_frame + num_frames > pkt->frames);\r\nfor (f = first_frame; f < first_frame + num_frames; f++)\r\nwritten[f] = 1;\r\n}\r\nspin_unlock(&pkt->lock);\r\nif (pkt->cache_valid) {\r\nVPRINTK("pkt_gather_data: zone %llx cached\n",\r\n(unsigned long long)pkt->sector);\r\ngoto out_account;\r\n}\r\nfor (f = 0; f < pkt->frames; f++) {\r\nint p, offset;\r\nif (written[f])\r\ncontinue;\r\nbio = pkt->r_bios[f];\r\nbio_reset(bio);\r\nbio->bi_sector = pkt->sector + f * (CD_FRAMESIZE >> 9);\r\nbio->bi_bdev = pd->bdev;\r\nbio->bi_end_io = pkt_end_io_read;\r\nbio->bi_private = pkt;\r\np = (f * CD_FRAMESIZE) / PAGE_SIZE;\r\noffset = (f * CD_FRAMESIZE) % PAGE_SIZE;\r\nVPRINTK("pkt_gather_data: Adding frame %d, page:%p offs:%d\n",\r\nf, pkt->pages[p], offset);\r\nif (!bio_add_page(bio, pkt->pages[p], CD_FRAMESIZE, offset))\r\nBUG();\r\natomic_inc(&pkt->io_wait);\r\nbio->bi_rw = READ;\r\npkt_queue_bio(pd, bio);\r\nframes_read++;\r\n}\r\nout_account:\r\nVPRINTK("pkt_gather_data: need %d frames for zone %llx\n",\r\nframes_read, (unsigned long long)pkt->sector);\r\npd->stats.pkt_started++;\r\npd->stats.secs_rg += frames_read * (CD_FRAMESIZE >> 9);\r\n}\r\nstatic struct packet_data *pkt_get_packet_data(struct pktcdvd_device *pd, int zone)\r\n{\r\nstruct packet_data *pkt;\r\nlist_for_each_entry(pkt, &pd->cdrw.pkt_free_list, list) {\r\nif (pkt->sector == zone || pkt->list.next == &pd->cdrw.pkt_free_list) {\r\nlist_del_init(&pkt->list);\r\nif (pkt->sector != zone)\r\npkt->cache_valid = 0;\r\nreturn pkt;\r\n}\r\n}\r\nBUG();\r\nreturn NULL;\r\n}\r\nstatic void pkt_put_packet_data(struct pktcdvd_device *pd, struct packet_data *pkt)\r\n{\r\nif (pkt->cache_valid) {\r\nlist_add(&pkt->list, &pd->cdrw.pkt_free_list);\r\n} else {\r\nlist_add_tail(&pkt->list, &pd->cdrw.pkt_free_list);\r\n}\r\n}\r\nstatic int pkt_start_recovery(struct packet_data *pkt)\r\n{\r\nreturn 0;\r\n#if 0\r\nstruct request *rq = pkt->rq;\r\nstruct pktcdvd_device *pd = rq->rq_disk->private_data;\r\nstruct block_device *pkt_bdev;\r\nstruct super_block *sb = NULL;\r\nunsigned long old_block, new_block;\r\nsector_t new_sector;\r\npkt_bdev = bdget(kdev_t_to_nr(pd->pkt_dev));\r\nif (pkt_bdev) {\r\nsb = get_super(pkt_bdev);\r\nbdput(pkt_bdev);\r\n}\r\nif (!sb)\r\nreturn 0;\r\nif (!sb->s_op->relocate_blocks)\r\ngoto out;\r\nold_block = pkt->sector / (CD_FRAMESIZE >> 9);\r\nif (sb->s_op->relocate_blocks(sb, old_block, &new_block))\r\ngoto out;\r\nnew_sector = new_block * (CD_FRAMESIZE >> 9);\r\npkt->sector = new_sector;\r\npkt->bio->bi_sector = new_sector;\r\npkt->bio->bi_next = NULL;\r\npkt->bio->bi_flags = 1 << BIO_UPTODATE;\r\npkt->bio->bi_idx = 0;\r\nBUG_ON(pkt->bio->bi_rw != REQ_WRITE);\r\nBUG_ON(pkt->bio->bi_vcnt != pkt->frames);\r\nBUG_ON(pkt->bio->bi_size != pkt->frames * CD_FRAMESIZE);\r\nBUG_ON(pkt->bio->bi_end_io != pkt_end_io_packet_write);\r\nBUG_ON(pkt->bio->bi_private != pkt);\r\ndrop_super(sb);\r\nreturn 1;\r\nout:\r\ndrop_super(sb);\r\nreturn 0;\r\n#endif\r\n}\r\nstatic inline void pkt_set_state(struct packet_data *pkt, enum packet_data_state state)\r\n{\r\n#if PACKET_DEBUG > 1\r\nstatic const char *state_name[] = {\r\n"IDLE", "WAITING", "READ_WAIT", "WRITE_WAIT", "RECOVERY", "FINISHED"\r\n};\r\nenum packet_data_state old_state = pkt->state;\r\nVPRINTK("pkt %2d : s=%6llx %s -> %s\n", pkt->id, (unsigned long long)pkt->sector,\r\nstate_name[old_state], state_name[state]);\r\n#endif\r\npkt->state = state;\r\n}\r\nstatic int pkt_handle_queue(struct pktcdvd_device *pd)\r\n{\r\nstruct packet_data *pkt, *p;\r\nstruct bio *bio = NULL;\r\nsector_t zone = 0;\r\nstruct pkt_rb_node *node, *first_node;\r\nstruct rb_node *n;\r\nint wakeup;\r\nVPRINTK("handle_queue\n");\r\natomic_set(&pd->scan_queue, 0);\r\nif (list_empty(&pd->cdrw.pkt_free_list)) {\r\nVPRINTK("handle_queue: no pkt\n");\r\nreturn 0;\r\n}\r\nspin_lock(&pd->lock);\r\nfirst_node = pkt_rbtree_find(pd, pd->current_sector);\r\nif (!first_node) {\r\nn = rb_first(&pd->bio_queue);\r\nif (n)\r\nfirst_node = rb_entry(n, struct pkt_rb_node, rb_node);\r\n}\r\nnode = first_node;\r\nwhile (node) {\r\nbio = node->bio;\r\nzone = ZONE(bio->bi_sector, pd);\r\nlist_for_each_entry(p, &pd->cdrw.pkt_active_list, list) {\r\nif (p->sector == zone) {\r\nbio = NULL;\r\ngoto try_next_bio;\r\n}\r\n}\r\nbreak;\r\ntry_next_bio:\r\nnode = pkt_rbtree_next(node);\r\nif (!node) {\r\nn = rb_first(&pd->bio_queue);\r\nif (n)\r\nnode = rb_entry(n, struct pkt_rb_node, rb_node);\r\n}\r\nif (node == first_node)\r\nnode = NULL;\r\n}\r\nspin_unlock(&pd->lock);\r\nif (!bio) {\r\nVPRINTK("handle_queue: no bio\n");\r\nreturn 0;\r\n}\r\npkt = pkt_get_packet_data(pd, zone);\r\npd->current_sector = zone + pd->settings.size;\r\npkt->sector = zone;\r\nBUG_ON(pkt->frames != pd->settings.size >> 2);\r\npkt->write_size = 0;\r\nspin_lock(&pd->lock);\r\nVPRINTK("pkt_handle_queue: looking for zone %llx\n", (unsigned long long)zone);\r\nwhile ((node = pkt_rbtree_find(pd, zone)) != NULL) {\r\nbio = node->bio;\r\nVPRINTK("pkt_handle_queue: found zone=%llx\n",\r\n(unsigned long long)ZONE(bio->bi_sector, pd));\r\nif (ZONE(bio->bi_sector, pd) != zone)\r\nbreak;\r\npkt_rbtree_erase(pd, node);\r\nspin_lock(&pkt->lock);\r\nbio_list_add(&pkt->orig_bios, bio);\r\npkt->write_size += bio->bi_size / CD_FRAMESIZE;\r\nspin_unlock(&pkt->lock);\r\n}\r\nwakeup = (pd->write_congestion_on > 0\r\n&& pd->bio_queue_size <= pd->write_congestion_off);\r\nspin_unlock(&pd->lock);\r\nif (wakeup) {\r\nclear_bdi_congested(&pd->disk->queue->backing_dev_info,\r\nBLK_RW_ASYNC);\r\n}\r\npkt->sleep_time = max(PACKET_WAIT_TIME, 1);\r\npkt_set_state(pkt, PACKET_WAITING_STATE);\r\natomic_set(&pkt->run_sm, 1);\r\nspin_lock(&pd->cdrw.active_list_lock);\r\nlist_add(&pkt->list, &pd->cdrw.pkt_active_list);\r\nspin_unlock(&pd->cdrw.active_list_lock);\r\nreturn 1;\r\n}\r\nstatic void pkt_start_write(struct pktcdvd_device *pd, struct packet_data *pkt)\r\n{\r\nstruct bio *bio;\r\nint f;\r\nint frames_write;\r\nstruct bio_vec *bvec = pkt->w_bio->bi_io_vec;\r\nfor (f = 0; f < pkt->frames; f++) {\r\nbvec[f].bv_page = pkt->pages[(f * CD_FRAMESIZE) / PAGE_SIZE];\r\nbvec[f].bv_offset = (f * CD_FRAMESIZE) % PAGE_SIZE;\r\n}\r\nframes_write = 0;\r\nspin_lock(&pkt->lock);\r\nbio_list_for_each(bio, &pkt->orig_bios) {\r\nint segment = bio->bi_idx;\r\nint src_offs = 0;\r\nint first_frame = (bio->bi_sector - pkt->sector) / (CD_FRAMESIZE >> 9);\r\nint num_frames = bio->bi_size / CD_FRAMESIZE;\r\nBUG_ON(first_frame < 0);\r\nBUG_ON(first_frame + num_frames > pkt->frames);\r\nfor (f = first_frame; f < first_frame + num_frames; f++) {\r\nstruct bio_vec *src_bvl = bio_iovec_idx(bio, segment);\r\nwhile (src_offs >= src_bvl->bv_len) {\r\nsrc_offs -= src_bvl->bv_len;\r\nsegment++;\r\nBUG_ON(segment >= bio->bi_vcnt);\r\nsrc_bvl = bio_iovec_idx(bio, segment);\r\n}\r\nif (src_bvl->bv_len - src_offs >= CD_FRAMESIZE) {\r\nbvec[f].bv_page = src_bvl->bv_page;\r\nbvec[f].bv_offset = src_bvl->bv_offset + src_offs;\r\n} else {\r\npkt_copy_bio_data(bio, segment, src_offs,\r\nbvec[f].bv_page, bvec[f].bv_offset);\r\n}\r\nsrc_offs += CD_FRAMESIZE;\r\nframes_write++;\r\n}\r\n}\r\npkt_set_state(pkt, PACKET_WRITE_WAIT_STATE);\r\nspin_unlock(&pkt->lock);\r\nVPRINTK("pkt_start_write: Writing %d frames for zone %llx\n",\r\nframes_write, (unsigned long long)pkt->sector);\r\nBUG_ON(frames_write != pkt->write_size);\r\nif (test_bit(PACKET_MERGE_SEGS, &pd->flags) || (pkt->write_size < pkt->frames)) {\r\npkt_make_local_copy(pkt, bvec);\r\npkt->cache_valid = 1;\r\n} else {\r\npkt->cache_valid = 0;\r\n}\r\nbio_reset(pkt->w_bio);\r\npkt->w_bio->bi_sector = pkt->sector;\r\npkt->w_bio->bi_bdev = pd->bdev;\r\npkt->w_bio->bi_end_io = pkt_end_io_packet_write;\r\npkt->w_bio->bi_private = pkt;\r\nfor (f = 0; f < pkt->frames; f++)\r\nif (!bio_add_page(pkt->w_bio, bvec[f].bv_page, CD_FRAMESIZE, bvec[f].bv_offset))\r\nBUG();\r\nVPRINTK(DRIVER_NAME": vcnt=%d\n", pkt->w_bio->bi_vcnt);\r\natomic_set(&pkt->io_wait, 1);\r\npkt->w_bio->bi_rw = WRITE;\r\npkt_queue_bio(pd, pkt->w_bio);\r\n}\r\nstatic void pkt_finish_packet(struct packet_data *pkt, int uptodate)\r\n{\r\nstruct bio *bio;\r\nif (!uptodate)\r\npkt->cache_valid = 0;\r\nwhile ((bio = bio_list_pop(&pkt->orig_bios)))\r\nbio_endio(bio, uptodate ? 0 : -EIO);\r\n}\r\nstatic void pkt_run_state_machine(struct pktcdvd_device *pd, struct packet_data *pkt)\r\n{\r\nint uptodate;\r\nVPRINTK("run_state_machine: pkt %d\n", pkt->id);\r\nfor (;;) {\r\nswitch (pkt->state) {\r\ncase PACKET_WAITING_STATE:\r\nif ((pkt->write_size < pkt->frames) && (pkt->sleep_time > 0))\r\nreturn;\r\npkt->sleep_time = 0;\r\npkt_gather_data(pd, pkt);\r\npkt_set_state(pkt, PACKET_READ_WAIT_STATE);\r\nbreak;\r\ncase PACKET_READ_WAIT_STATE:\r\nif (atomic_read(&pkt->io_wait) > 0)\r\nreturn;\r\nif (atomic_read(&pkt->io_errors) > 0) {\r\npkt_set_state(pkt, PACKET_RECOVERY_STATE);\r\n} else {\r\npkt_start_write(pd, pkt);\r\n}\r\nbreak;\r\ncase PACKET_WRITE_WAIT_STATE:\r\nif (atomic_read(&pkt->io_wait) > 0)\r\nreturn;\r\nif (test_bit(BIO_UPTODATE, &pkt->w_bio->bi_flags)) {\r\npkt_set_state(pkt, PACKET_FINISHED_STATE);\r\n} else {\r\npkt_set_state(pkt, PACKET_RECOVERY_STATE);\r\n}\r\nbreak;\r\ncase PACKET_RECOVERY_STATE:\r\nif (pkt_start_recovery(pkt)) {\r\npkt_start_write(pd, pkt);\r\n} else {\r\nVPRINTK("No recovery possible\n");\r\npkt_set_state(pkt, PACKET_FINISHED_STATE);\r\n}\r\nbreak;\r\ncase PACKET_FINISHED_STATE:\r\nuptodate = test_bit(BIO_UPTODATE, &pkt->w_bio->bi_flags);\r\npkt_finish_packet(pkt, uptodate);\r\nreturn;\r\ndefault:\r\nBUG();\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic void pkt_handle_packets(struct pktcdvd_device *pd)\r\n{\r\nstruct packet_data *pkt, *next;\r\nVPRINTK("pkt_handle_packets\n");\r\nlist_for_each_entry(pkt, &pd->cdrw.pkt_active_list, list) {\r\nif (atomic_read(&pkt->run_sm) > 0) {\r\natomic_set(&pkt->run_sm, 0);\r\npkt_run_state_machine(pd, pkt);\r\n}\r\n}\r\nspin_lock(&pd->cdrw.active_list_lock);\r\nlist_for_each_entry_safe(pkt, next, &pd->cdrw.pkt_active_list, list) {\r\nif (pkt->state == PACKET_FINISHED_STATE) {\r\nlist_del(&pkt->list);\r\npkt_put_packet_data(pd, pkt);\r\npkt_set_state(pkt, PACKET_IDLE_STATE);\r\natomic_set(&pd->scan_queue, 1);\r\n}\r\n}\r\nspin_unlock(&pd->cdrw.active_list_lock);\r\n}\r\nstatic void pkt_count_states(struct pktcdvd_device *pd, int *states)\r\n{\r\nstruct packet_data *pkt;\r\nint i;\r\nfor (i = 0; i < PACKET_NUM_STATES; i++)\r\nstates[i] = 0;\r\nspin_lock(&pd->cdrw.active_list_lock);\r\nlist_for_each_entry(pkt, &pd->cdrw.pkt_active_list, list) {\r\nstates[pkt->state]++;\r\n}\r\nspin_unlock(&pd->cdrw.active_list_lock);\r\n}\r\nstatic int kcdrwd(void *foobar)\r\n{\r\nstruct pktcdvd_device *pd = foobar;\r\nstruct packet_data *pkt;\r\nlong min_sleep_time, residue;\r\nset_user_nice(current, -20);\r\nset_freezable();\r\nfor (;;) {\r\nDECLARE_WAITQUEUE(wait, current);\r\nadd_wait_queue(&pd->wqueue, &wait);\r\nfor (;;) {\r\nset_current_state(TASK_INTERRUPTIBLE);\r\nif (atomic_read(&pd->scan_queue) > 0)\r\ngoto work_to_do;\r\nlist_for_each_entry(pkt, &pd->cdrw.pkt_active_list, list) {\r\nif (atomic_read(&pkt->run_sm) > 0)\r\ngoto work_to_do;\r\n}\r\nif (atomic_read(&pd->iosched.attention) != 0)\r\ngoto work_to_do;\r\nif (PACKET_DEBUG > 1) {\r\nint states[PACKET_NUM_STATES];\r\npkt_count_states(pd, states);\r\nVPRINTK("kcdrwd: i:%d ow:%d rw:%d ww:%d rec:%d fin:%d\n",\r\nstates[0], states[1], states[2], states[3],\r\nstates[4], states[5]);\r\n}\r\nmin_sleep_time = MAX_SCHEDULE_TIMEOUT;\r\nlist_for_each_entry(pkt, &pd->cdrw.pkt_active_list, list) {\r\nif (pkt->sleep_time && pkt->sleep_time < min_sleep_time)\r\nmin_sleep_time = pkt->sleep_time;\r\n}\r\nVPRINTK("kcdrwd: sleeping\n");\r\nresidue = schedule_timeout(min_sleep_time);\r\nVPRINTK("kcdrwd: wake up\n");\r\ntry_to_freeze();\r\nlist_for_each_entry(pkt, &pd->cdrw.pkt_active_list, list) {\r\nif (!pkt->sleep_time)\r\ncontinue;\r\npkt->sleep_time -= min_sleep_time - residue;\r\nif (pkt->sleep_time <= 0) {\r\npkt->sleep_time = 0;\r\natomic_inc(&pkt->run_sm);\r\n}\r\n}\r\nif (kthread_should_stop())\r\nbreak;\r\n}\r\nwork_to_do:\r\nset_current_state(TASK_RUNNING);\r\nremove_wait_queue(&pd->wqueue, &wait);\r\nif (kthread_should_stop())\r\nbreak;\r\nwhile (pkt_handle_queue(pd))\r\n;\r\npkt_handle_packets(pd);\r\npkt_iosched_process_queue(pd);\r\n}\r\nreturn 0;\r\n}\r\nstatic void pkt_print_settings(struct pktcdvd_device *pd)\r\n{\r\nprintk(DRIVER_NAME": %s packets, ", pd->settings.fp ? "Fixed" : "Variable");\r\nprintk("%u blocks, ", pd->settings.size >> 2);\r\nprintk("Mode-%c disc\n", pd->settings.block_mode == 8 ? '1' : '2');\r\n}\r\nstatic int pkt_mode_sense(struct pktcdvd_device *pd, struct packet_command *cgc, int page_code, int page_control)\r\n{\r\nmemset(cgc->cmd, 0, sizeof(cgc->cmd));\r\ncgc->cmd[0] = GPCMD_MODE_SENSE_10;\r\ncgc->cmd[2] = page_code | (page_control << 6);\r\ncgc->cmd[7] = cgc->buflen >> 8;\r\ncgc->cmd[8] = cgc->buflen & 0xff;\r\ncgc->data_direction = CGC_DATA_READ;\r\nreturn pkt_generic_packet(pd, cgc);\r\n}\r\nstatic int pkt_mode_select(struct pktcdvd_device *pd, struct packet_command *cgc)\r\n{\r\nmemset(cgc->cmd, 0, sizeof(cgc->cmd));\r\nmemset(cgc->buffer, 0, 2);\r\ncgc->cmd[0] = GPCMD_MODE_SELECT_10;\r\ncgc->cmd[1] = 0x10;\r\ncgc->cmd[7] = cgc->buflen >> 8;\r\ncgc->cmd[8] = cgc->buflen & 0xff;\r\ncgc->data_direction = CGC_DATA_WRITE;\r\nreturn pkt_generic_packet(pd, cgc);\r\n}\r\nstatic int pkt_get_disc_info(struct pktcdvd_device *pd, disc_information *di)\r\n{\r\nstruct packet_command cgc;\r\nint ret;\r\ninit_cdrom_command(&cgc, di, sizeof(*di), CGC_DATA_READ);\r\ncgc.cmd[0] = GPCMD_READ_DISC_INFO;\r\ncgc.cmd[8] = cgc.buflen = 2;\r\ncgc.quiet = 1;\r\nif ((ret = pkt_generic_packet(pd, &cgc)))\r\nreturn ret;\r\ncgc.buflen = be16_to_cpu(di->disc_information_length) +\r\nsizeof(di->disc_information_length);\r\nif (cgc.buflen > sizeof(disc_information))\r\ncgc.buflen = sizeof(disc_information);\r\ncgc.cmd[8] = cgc.buflen;\r\nreturn pkt_generic_packet(pd, &cgc);\r\n}\r\nstatic int pkt_get_track_info(struct pktcdvd_device *pd, __u16 track, __u8 type, track_information *ti)\r\n{\r\nstruct packet_command cgc;\r\nint ret;\r\ninit_cdrom_command(&cgc, ti, 8, CGC_DATA_READ);\r\ncgc.cmd[0] = GPCMD_READ_TRACK_RZONE_INFO;\r\ncgc.cmd[1] = type & 3;\r\ncgc.cmd[4] = (track & 0xff00) >> 8;\r\ncgc.cmd[5] = track & 0xff;\r\ncgc.cmd[8] = 8;\r\ncgc.quiet = 1;\r\nif ((ret = pkt_generic_packet(pd, &cgc)))\r\nreturn ret;\r\ncgc.buflen = be16_to_cpu(ti->track_information_length) +\r\nsizeof(ti->track_information_length);\r\nif (cgc.buflen > sizeof(track_information))\r\ncgc.buflen = sizeof(track_information);\r\ncgc.cmd[8] = cgc.buflen;\r\nreturn pkt_generic_packet(pd, &cgc);\r\n}\r\nstatic noinline_for_stack int pkt_get_last_written(struct pktcdvd_device *pd,\r\nlong *last_written)\r\n{\r\ndisc_information di;\r\ntrack_information ti;\r\n__u32 last_track;\r\nint ret = -1;\r\nif ((ret = pkt_get_disc_info(pd, &di)))\r\nreturn ret;\r\nlast_track = (di.last_track_msb << 8) | di.last_track_lsb;\r\nif ((ret = pkt_get_track_info(pd, last_track, 1, &ti)))\r\nreturn ret;\r\nif (ti.blank) {\r\nlast_track--;\r\nif ((ret = pkt_get_track_info(pd, last_track, 1, &ti)))\r\nreturn ret;\r\n}\r\nif (ti.lra_v) {\r\n*last_written = be32_to_cpu(ti.last_rec_address);\r\n} else {\r\n*last_written = be32_to_cpu(ti.track_start) +\r\nbe32_to_cpu(ti.track_size);\r\nif (ti.free_blocks)\r\n*last_written -= (be32_to_cpu(ti.free_blocks) + 7);\r\n}\r\nreturn 0;\r\n}\r\nstatic noinline_for_stack int pkt_set_write_settings(struct pktcdvd_device *pd)\r\n{\r\nstruct packet_command cgc;\r\nstruct request_sense sense;\r\nwrite_param_page *wp;\r\nchar buffer[128];\r\nint ret, size;\r\nif ((pd->mmc3_profile == 0x1a) || (pd->mmc3_profile == 0x12))\r\nreturn 0;\r\nmemset(buffer, 0, sizeof(buffer));\r\ninit_cdrom_command(&cgc, buffer, sizeof(*wp), CGC_DATA_READ);\r\ncgc.sense = &sense;\r\nif ((ret = pkt_mode_sense(pd, &cgc, GPMODE_WRITE_PARMS_PAGE, 0))) {\r\npkt_dump_sense(&cgc);\r\nreturn ret;\r\n}\r\nsize = 2 + ((buffer[0] << 8) | (buffer[1] & 0xff));\r\npd->mode_offset = (buffer[6] << 8) | (buffer[7] & 0xff);\r\nif (size > sizeof(buffer))\r\nsize = sizeof(buffer);\r\ninit_cdrom_command(&cgc, buffer, size, CGC_DATA_READ);\r\ncgc.sense = &sense;\r\nif ((ret = pkt_mode_sense(pd, &cgc, GPMODE_WRITE_PARMS_PAGE, 0))) {\r\npkt_dump_sense(&cgc);\r\nreturn ret;\r\n}\r\nwp = (write_param_page *) &buffer[sizeof(struct mode_page_header) + pd->mode_offset];\r\nwp->fp = pd->settings.fp;\r\nwp->track_mode = pd->settings.track_mode;\r\nwp->write_type = pd->settings.write_type;\r\nwp->data_block_type = pd->settings.block_mode;\r\nwp->multi_session = 0;\r\n#ifdef PACKET_USE_LS\r\nwp->link_size = 7;\r\nwp->ls_v = 1;\r\n#endif\r\nif (wp->data_block_type == PACKET_BLOCK_MODE1) {\r\nwp->session_format = 0;\r\nwp->subhdr2 = 0x20;\r\n} else if (wp->data_block_type == PACKET_BLOCK_MODE2) {\r\nwp->session_format = 0x20;\r\nwp->subhdr2 = 8;\r\n#if 0\r\nwp->mcn[0] = 0x80;\r\nmemcpy(&wp->mcn[1], PACKET_MCN, sizeof(wp->mcn) - 1);\r\n#endif\r\n} else {\r\nprintk(DRIVER_NAME": write mode wrong %d\n", wp->data_block_type);\r\nreturn 1;\r\n}\r\nwp->packet_size = cpu_to_be32(pd->settings.size >> 2);\r\ncgc.buflen = cgc.cmd[8] = size;\r\nif ((ret = pkt_mode_select(pd, &cgc))) {\r\npkt_dump_sense(&cgc);\r\nreturn ret;\r\n}\r\npkt_print_settings(pd);\r\nreturn 0;\r\n}\r\nstatic int pkt_writable_track(struct pktcdvd_device *pd, track_information *ti)\r\n{\r\nswitch (pd->mmc3_profile) {\r\ncase 0x1a:\r\ncase 0x12:\r\nreturn 1;\r\ndefault:\r\nbreak;\r\n}\r\nif (!ti->packet || !ti->fp)\r\nreturn 0;\r\nif (ti->rt == 0 && ti->blank == 0)\r\nreturn 1;\r\nif (ti->rt == 0 && ti->blank == 1)\r\nreturn 1;\r\nif (ti->rt == 1 && ti->blank == 0)\r\nreturn 1;\r\nprintk(DRIVER_NAME": bad state %d-%d-%d\n", ti->rt, ti->blank, ti->packet);\r\nreturn 0;\r\n}\r\nstatic int pkt_writable_disc(struct pktcdvd_device *pd, disc_information *di)\r\n{\r\nswitch (pd->mmc3_profile) {\r\ncase 0x0a:\r\ncase 0xffff:\r\nbreak;\r\ncase 0x1a:\r\ncase 0x13:\r\ncase 0x12:\r\nreturn 1;\r\ndefault:\r\nVPRINTK(DRIVER_NAME": Wrong disc profile (%x)\n", pd->mmc3_profile);\r\nreturn 0;\r\n}\r\nif (di->disc_type == 0xff) {\r\nprintk(DRIVER_NAME": Unknown disc. No track?\n");\r\nreturn 0;\r\n}\r\nif (di->disc_type != 0x20 && di->disc_type != 0) {\r\nprintk(DRIVER_NAME": Wrong disc type (%x)\n", di->disc_type);\r\nreturn 0;\r\n}\r\nif (di->erasable == 0) {\r\nprintk(DRIVER_NAME": Disc not erasable\n");\r\nreturn 0;\r\n}\r\nif (di->border_status == PACKET_SESSION_RESERVED) {\r\nprintk(DRIVER_NAME": Can't write to last track (reserved)\n");\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nstatic noinline_for_stack int pkt_probe_settings(struct pktcdvd_device *pd)\r\n{\r\nstruct packet_command cgc;\r\nunsigned char buf[12];\r\ndisc_information di;\r\ntrack_information ti;\r\nint ret, track;\r\ninit_cdrom_command(&cgc, buf, sizeof(buf), CGC_DATA_READ);\r\ncgc.cmd[0] = GPCMD_GET_CONFIGURATION;\r\ncgc.cmd[8] = 8;\r\nret = pkt_generic_packet(pd, &cgc);\r\npd->mmc3_profile = ret ? 0xffff : buf[6] << 8 | buf[7];\r\nmemset(&di, 0, sizeof(disc_information));\r\nmemset(&ti, 0, sizeof(track_information));\r\nif ((ret = pkt_get_disc_info(pd, &di))) {\r\nprintk("failed get_disc\n");\r\nreturn ret;\r\n}\r\nif (!pkt_writable_disc(pd, &di))\r\nreturn -EROFS;\r\npd->type = di.erasable ? PACKET_CDRW : PACKET_CDR;\r\ntrack = 1;\r\nif ((ret = pkt_get_track_info(pd, track, 1, &ti))) {\r\nprintk(DRIVER_NAME": failed get_track\n");\r\nreturn ret;\r\n}\r\nif (!pkt_writable_track(pd, &ti)) {\r\nprintk(DRIVER_NAME": can't write to this track\n");\r\nreturn -EROFS;\r\n}\r\npd->settings.size = be32_to_cpu(ti.fixed_packet_size) << 2;\r\nif (pd->settings.size == 0) {\r\nprintk(DRIVER_NAME": detected zero packet size!\n");\r\nreturn -ENXIO;\r\n}\r\nif (pd->settings.size > PACKET_MAX_SECTORS) {\r\nprintk(DRIVER_NAME": packet size is too big\n");\r\nreturn -EROFS;\r\n}\r\npd->settings.fp = ti.fp;\r\npd->offset = (be32_to_cpu(ti.track_start) << 2) & (pd->settings.size - 1);\r\nif (ti.nwa_v) {\r\npd->nwa = be32_to_cpu(ti.next_writable);\r\nset_bit(PACKET_NWA_VALID, &pd->flags);\r\n}\r\nif (ti.lra_v) {\r\npd->lra = be32_to_cpu(ti.last_rec_address);\r\nset_bit(PACKET_LRA_VALID, &pd->flags);\r\n} else {\r\npd->lra = 0xffffffff;\r\nset_bit(PACKET_LRA_VALID, &pd->flags);\r\n}\r\npd->settings.link_loss = 7;\r\npd->settings.write_type = 0;\r\npd->settings.track_mode = ti.track_mode;\r\nswitch (ti.data_mode) {\r\ncase PACKET_MODE1:\r\npd->settings.block_mode = PACKET_BLOCK_MODE1;\r\nbreak;\r\ncase PACKET_MODE2:\r\npd->settings.block_mode = PACKET_BLOCK_MODE2;\r\nbreak;\r\ndefault:\r\nprintk(DRIVER_NAME": unknown data mode\n");\r\nreturn -EROFS;\r\n}\r\nreturn 0;\r\n}\r\nstatic noinline_for_stack int pkt_write_caching(struct pktcdvd_device *pd,\r\nint set)\r\n{\r\nstruct packet_command cgc;\r\nstruct request_sense sense;\r\nunsigned char buf[64];\r\nint ret;\r\ninit_cdrom_command(&cgc, buf, sizeof(buf), CGC_DATA_READ);\r\ncgc.sense = &sense;\r\ncgc.buflen = pd->mode_offset + 12;\r\ncgc.quiet = 1;\r\nif ((ret = pkt_mode_sense(pd, &cgc, GPMODE_WCACHING_PAGE, 0)))\r\nreturn ret;\r\nbuf[pd->mode_offset + 10] |= (!!set << 2);\r\ncgc.buflen = cgc.cmd[8] = 2 + ((buf[0] << 8) | (buf[1] & 0xff));\r\nret = pkt_mode_select(pd, &cgc);\r\nif (ret) {\r\nprintk(DRIVER_NAME": write caching control failed\n");\r\npkt_dump_sense(&cgc);\r\n} else if (!ret && set)\r\nprintk(DRIVER_NAME": enabled write caching on %s\n", pd->name);\r\nreturn ret;\r\n}\r\nstatic int pkt_lock_door(struct pktcdvd_device *pd, int lockflag)\r\n{\r\nstruct packet_command cgc;\r\ninit_cdrom_command(&cgc, NULL, 0, CGC_DATA_NONE);\r\ncgc.cmd[0] = GPCMD_PREVENT_ALLOW_MEDIUM_REMOVAL;\r\ncgc.cmd[4] = lockflag ? 1 : 0;\r\nreturn pkt_generic_packet(pd, &cgc);\r\n}\r\nstatic noinline_for_stack int pkt_get_max_speed(struct pktcdvd_device *pd,\r\nunsigned *write_speed)\r\n{\r\nstruct packet_command cgc;\r\nstruct request_sense sense;\r\nunsigned char buf[256+18];\r\nunsigned char *cap_buf;\r\nint ret, offset;\r\ncap_buf = &buf[sizeof(struct mode_page_header) + pd->mode_offset];\r\ninit_cdrom_command(&cgc, buf, sizeof(buf), CGC_DATA_UNKNOWN);\r\ncgc.sense = &sense;\r\nret = pkt_mode_sense(pd, &cgc, GPMODE_CAPABILITIES_PAGE, 0);\r\nif (ret) {\r\ncgc.buflen = pd->mode_offset + cap_buf[1] + 2 +\r\nsizeof(struct mode_page_header);\r\nret = pkt_mode_sense(pd, &cgc, GPMODE_CAPABILITIES_PAGE, 0);\r\nif (ret) {\r\npkt_dump_sense(&cgc);\r\nreturn ret;\r\n}\r\n}\r\noffset = 20;\r\nif (cap_buf[1] >= 28)\r\noffset = 28;\r\nif (cap_buf[1] >= 30) {\r\nint num_spdb = (cap_buf[30] << 8) + cap_buf[31];\r\nif (num_spdb > 0)\r\noffset = 34;\r\n}\r\n*write_speed = (cap_buf[offset] << 8) | cap_buf[offset + 1];\r\nreturn 0;\r\n}\r\nstatic noinline_for_stack int pkt_media_speed(struct pktcdvd_device *pd,\r\nunsigned *speed)\r\n{\r\nstruct packet_command cgc;\r\nstruct request_sense sense;\r\nunsigned char buf[64];\r\nunsigned int size, st, sp;\r\nint ret;\r\ninit_cdrom_command(&cgc, buf, 2, CGC_DATA_READ);\r\ncgc.sense = &sense;\r\ncgc.cmd[0] = GPCMD_READ_TOC_PMA_ATIP;\r\ncgc.cmd[1] = 2;\r\ncgc.cmd[2] = 4;\r\ncgc.cmd[8] = 2;\r\nret = pkt_generic_packet(pd, &cgc);\r\nif (ret) {\r\npkt_dump_sense(&cgc);\r\nreturn ret;\r\n}\r\nsize = ((unsigned int) buf[0]<<8) + buf[1] + 2;\r\nif (size > sizeof(buf))\r\nsize = sizeof(buf);\r\ninit_cdrom_command(&cgc, buf, size, CGC_DATA_READ);\r\ncgc.sense = &sense;\r\ncgc.cmd[0] = GPCMD_READ_TOC_PMA_ATIP;\r\ncgc.cmd[1] = 2;\r\ncgc.cmd[2] = 4;\r\ncgc.cmd[8] = size;\r\nret = pkt_generic_packet(pd, &cgc);\r\nif (ret) {\r\npkt_dump_sense(&cgc);\r\nreturn ret;\r\n}\r\nif (!(buf[6] & 0x40)) {\r\nprintk(DRIVER_NAME": Disc type is not CD-RW\n");\r\nreturn 1;\r\n}\r\nif (!(buf[6] & 0x4)) {\r\nprintk(DRIVER_NAME": A1 values on media are not valid, maybe not CDRW?\n");\r\nreturn 1;\r\n}\r\nst = (buf[6] >> 3) & 0x7;\r\nsp = buf[16] & 0xf;\r\nswitch (st) {\r\ncase 0:\r\n*speed = clv_to_speed[sp];\r\nbreak;\r\ncase 1:\r\n*speed = hs_clv_to_speed[sp];\r\nbreak;\r\ncase 2:\r\n*speed = us_clv_to_speed[sp];\r\nbreak;\r\ndefault:\r\nprintk(DRIVER_NAME": Unknown disc sub-type %d\n",st);\r\nreturn 1;\r\n}\r\nif (*speed) {\r\nprintk(DRIVER_NAME": Max. media speed: %d\n",*speed);\r\nreturn 0;\r\n} else {\r\nprintk(DRIVER_NAME": Unknown speed %d for sub-type %d\n",sp,st);\r\nreturn 1;\r\n}\r\n}\r\nstatic noinline_for_stack int pkt_perform_opc(struct pktcdvd_device *pd)\r\n{\r\nstruct packet_command cgc;\r\nstruct request_sense sense;\r\nint ret;\r\nVPRINTK(DRIVER_NAME": Performing OPC\n");\r\ninit_cdrom_command(&cgc, NULL, 0, CGC_DATA_NONE);\r\ncgc.sense = &sense;\r\ncgc.timeout = 60*HZ;\r\ncgc.cmd[0] = GPCMD_SEND_OPC;\r\ncgc.cmd[1] = 1;\r\nif ((ret = pkt_generic_packet(pd, &cgc)))\r\npkt_dump_sense(&cgc);\r\nreturn ret;\r\n}\r\nstatic int pkt_open_write(struct pktcdvd_device *pd)\r\n{\r\nint ret;\r\nunsigned int write_speed, media_write_speed, read_speed;\r\nif ((ret = pkt_probe_settings(pd))) {\r\nVPRINTK(DRIVER_NAME": %s failed probe\n", pd->name);\r\nreturn ret;\r\n}\r\nif ((ret = pkt_set_write_settings(pd))) {\r\nDPRINTK(DRIVER_NAME": %s failed saving write settings\n", pd->name);\r\nreturn -EIO;\r\n}\r\npkt_write_caching(pd, USE_WCACHING);\r\nif ((ret = pkt_get_max_speed(pd, &write_speed)))\r\nwrite_speed = 16 * 177;\r\nswitch (pd->mmc3_profile) {\r\ncase 0x13:\r\ncase 0x1a:\r\ncase 0x12:\r\nDPRINTK(DRIVER_NAME": write speed %ukB/s\n", write_speed);\r\nbreak;\r\ndefault:\r\nif ((ret = pkt_media_speed(pd, &media_write_speed)))\r\nmedia_write_speed = 16;\r\nwrite_speed = min(write_speed, media_write_speed * 177);\r\nDPRINTK(DRIVER_NAME": write speed %ux\n", write_speed / 176);\r\nbreak;\r\n}\r\nread_speed = write_speed;\r\nif ((ret = pkt_set_speed(pd, write_speed, read_speed))) {\r\nDPRINTK(DRIVER_NAME": %s couldn't set write speed\n", pd->name);\r\nreturn -EIO;\r\n}\r\npd->write_speed = write_speed;\r\npd->read_speed = read_speed;\r\nif ((ret = pkt_perform_opc(pd))) {\r\nDPRINTK(DRIVER_NAME": %s Optimum Power Calibration failed\n", pd->name);\r\n}\r\nreturn 0;\r\n}\r\nstatic int pkt_open_dev(struct pktcdvd_device *pd, fmode_t write)\r\n{\r\nint ret;\r\nlong lba;\r\nstruct request_queue *q;\r\nbdget(pd->bdev->bd_dev);\r\nif ((ret = blkdev_get(pd->bdev, FMODE_READ | FMODE_EXCL, pd)))\r\ngoto out;\r\nif ((ret = pkt_get_last_written(pd, &lba))) {\r\nprintk(DRIVER_NAME": pkt_get_last_written failed\n");\r\ngoto out_putdev;\r\n}\r\nset_capacity(pd->disk, lba << 2);\r\nset_capacity(pd->bdev->bd_disk, lba << 2);\r\nbd_set_size(pd->bdev, (loff_t)lba << 11);\r\nq = bdev_get_queue(pd->bdev);\r\nif (write) {\r\nif ((ret = pkt_open_write(pd)))\r\ngoto out_putdev;\r\nspin_lock_irq(q->queue_lock);\r\nblk_queue_max_hw_sectors(q, pd->settings.size);\r\nspin_unlock_irq(q->queue_lock);\r\nset_bit(PACKET_WRITABLE, &pd->flags);\r\n} else {\r\npkt_set_speed(pd, MAX_SPEED, MAX_SPEED);\r\nclear_bit(PACKET_WRITABLE, &pd->flags);\r\n}\r\nif ((ret = pkt_set_segment_merging(pd, q)))\r\ngoto out_putdev;\r\nif (write) {\r\nif (!pkt_grow_pktlist(pd, CONFIG_CDROM_PKTCDVD_BUFFERS)) {\r\nprintk(DRIVER_NAME": not enough memory for buffers\n");\r\nret = -ENOMEM;\r\ngoto out_putdev;\r\n}\r\nprintk(DRIVER_NAME": %lukB available on disc\n", lba << 1);\r\n}\r\nreturn 0;\r\nout_putdev:\r\nblkdev_put(pd->bdev, FMODE_READ | FMODE_EXCL);\r\nout:\r\nreturn ret;\r\n}\r\nstatic void pkt_release_dev(struct pktcdvd_device *pd, int flush)\r\n{\r\nif (flush && pkt_flush_cache(pd))\r\nDPRINTK(DRIVER_NAME": %s not flushing cache\n", pd->name);\r\npkt_lock_door(pd, 0);\r\npkt_set_speed(pd, MAX_SPEED, MAX_SPEED);\r\nblkdev_put(pd->bdev, FMODE_READ | FMODE_EXCL);\r\npkt_shrink_pktlist(pd);\r\n}\r\nstatic struct pktcdvd_device *pkt_find_dev_from_minor(unsigned int dev_minor)\r\n{\r\nif (dev_minor >= MAX_WRITERS)\r\nreturn NULL;\r\nreturn pkt_devs[dev_minor];\r\n}\r\nstatic int pkt_open(struct block_device *bdev, fmode_t mode)\r\n{\r\nstruct pktcdvd_device *pd = NULL;\r\nint ret;\r\nVPRINTK(DRIVER_NAME": entering open\n");\r\nmutex_lock(&pktcdvd_mutex);\r\nmutex_lock(&ctl_mutex);\r\npd = pkt_find_dev_from_minor(MINOR(bdev->bd_dev));\r\nif (!pd) {\r\nret = -ENODEV;\r\ngoto out;\r\n}\r\nBUG_ON(pd->refcnt < 0);\r\npd->refcnt++;\r\nif (pd->refcnt > 1) {\r\nif ((mode & FMODE_WRITE) &&\r\n!test_bit(PACKET_WRITABLE, &pd->flags)) {\r\nret = -EBUSY;\r\ngoto out_dec;\r\n}\r\n} else {\r\nret = pkt_open_dev(pd, mode & FMODE_WRITE);\r\nif (ret)\r\ngoto out_dec;\r\nset_blocksize(bdev, CD_FRAMESIZE);\r\n}\r\nmutex_unlock(&ctl_mutex);\r\nmutex_unlock(&pktcdvd_mutex);\r\nreturn 0;\r\nout_dec:\r\npd->refcnt--;\r\nout:\r\nVPRINTK(DRIVER_NAME": failed open (%d)\n", ret);\r\nmutex_unlock(&ctl_mutex);\r\nmutex_unlock(&pktcdvd_mutex);\r\nreturn ret;\r\n}\r\nstatic int pkt_close(struct gendisk *disk, fmode_t mode)\r\n{\r\nstruct pktcdvd_device *pd = disk->private_data;\r\nint ret = 0;\r\nmutex_lock(&pktcdvd_mutex);\r\nmutex_lock(&ctl_mutex);\r\npd->refcnt--;\r\nBUG_ON(pd->refcnt < 0);\r\nif (pd->refcnt == 0) {\r\nint flush = test_bit(PACKET_WRITABLE, &pd->flags);\r\npkt_release_dev(pd, flush);\r\n}\r\nmutex_unlock(&ctl_mutex);\r\nmutex_unlock(&pktcdvd_mutex);\r\nreturn ret;\r\n}\r\nstatic void pkt_end_io_read_cloned(struct bio *bio, int err)\r\n{\r\nstruct packet_stacked_data *psd = bio->bi_private;\r\nstruct pktcdvd_device *pd = psd->pd;\r\nbio_put(bio);\r\nbio_endio(psd->bio, err);\r\nmempool_free(psd, psd_pool);\r\npkt_bio_finished(pd);\r\n}\r\nstatic void pkt_make_request(struct request_queue *q, struct bio *bio)\r\n{\r\nstruct pktcdvd_device *pd;\r\nchar b[BDEVNAME_SIZE];\r\nsector_t zone;\r\nstruct packet_data *pkt;\r\nint was_empty, blocked_bio;\r\nstruct pkt_rb_node *node;\r\npd = q->queuedata;\r\nif (!pd) {\r\nprintk(DRIVER_NAME": %s incorrect request queue\n", bdevname(bio->bi_bdev, b));\r\ngoto end_io;\r\n}\r\nif (bio_data_dir(bio) == READ) {\r\nstruct bio *cloned_bio = bio_clone(bio, GFP_NOIO);\r\nstruct packet_stacked_data *psd = mempool_alloc(psd_pool, GFP_NOIO);\r\npsd->pd = pd;\r\npsd->bio = bio;\r\ncloned_bio->bi_bdev = pd->bdev;\r\ncloned_bio->bi_private = psd;\r\ncloned_bio->bi_end_io = pkt_end_io_read_cloned;\r\npd->stats.secs_r += bio->bi_size >> 9;\r\npkt_queue_bio(pd, cloned_bio);\r\nreturn;\r\n}\r\nif (!test_bit(PACKET_WRITABLE, &pd->flags)) {\r\nprintk(DRIVER_NAME": WRITE for ro device %s (%llu)\n",\r\npd->name, (unsigned long long)bio->bi_sector);\r\ngoto end_io;\r\n}\r\nif (!bio->bi_size || (bio->bi_size % CD_FRAMESIZE)) {\r\nprintk(DRIVER_NAME": wrong bio size\n");\r\ngoto end_io;\r\n}\r\nblk_queue_bounce(q, &bio);\r\nzone = ZONE(bio->bi_sector, pd);\r\nVPRINTK("pkt_make_request: start = %6llx stop = %6llx\n",\r\n(unsigned long long)bio->bi_sector,\r\n(unsigned long long)(bio->bi_sector + bio_sectors(bio)));\r\n{\r\nstruct bio_pair *bp;\r\nsector_t last_zone;\r\nint first_sectors;\r\nlast_zone = ZONE(bio->bi_sector + bio_sectors(bio) - 1, pd);\r\nif (last_zone != zone) {\r\nBUG_ON(last_zone != zone + pd->settings.size);\r\nfirst_sectors = last_zone - bio->bi_sector;\r\nbp = bio_split(bio, first_sectors);\r\nBUG_ON(!bp);\r\npkt_make_request(q, &bp->bio1);\r\npkt_make_request(q, &bp->bio2);\r\nbio_pair_release(bp);\r\nreturn;\r\n}\r\n}\r\nspin_lock(&pd->cdrw.active_list_lock);\r\nblocked_bio = 0;\r\nlist_for_each_entry(pkt, &pd->cdrw.pkt_active_list, list) {\r\nif (pkt->sector == zone) {\r\nspin_lock(&pkt->lock);\r\nif ((pkt->state == PACKET_WAITING_STATE) ||\r\n(pkt->state == PACKET_READ_WAIT_STATE)) {\r\nbio_list_add(&pkt->orig_bios, bio);\r\npkt->write_size += bio->bi_size / CD_FRAMESIZE;\r\nif ((pkt->write_size >= pkt->frames) &&\r\n(pkt->state == PACKET_WAITING_STATE)) {\r\natomic_inc(&pkt->run_sm);\r\nwake_up(&pd->wqueue);\r\n}\r\nspin_unlock(&pkt->lock);\r\nspin_unlock(&pd->cdrw.active_list_lock);\r\nreturn;\r\n} else {\r\nblocked_bio = 1;\r\n}\r\nspin_unlock(&pkt->lock);\r\n}\r\n}\r\nspin_unlock(&pd->cdrw.active_list_lock);\r\nspin_lock(&pd->lock);\r\nif (pd->write_congestion_on > 0\r\n&& pd->bio_queue_size >= pd->write_congestion_on) {\r\nset_bdi_congested(&q->backing_dev_info, BLK_RW_ASYNC);\r\ndo {\r\nspin_unlock(&pd->lock);\r\ncongestion_wait(BLK_RW_ASYNC, HZ);\r\nspin_lock(&pd->lock);\r\n} while(pd->bio_queue_size > pd->write_congestion_off);\r\n}\r\nspin_unlock(&pd->lock);\r\nnode = mempool_alloc(pd->rb_pool, GFP_NOIO);\r\nnode->bio = bio;\r\nspin_lock(&pd->lock);\r\nBUG_ON(pd->bio_queue_size < 0);\r\nwas_empty = (pd->bio_queue_size == 0);\r\npkt_rbtree_insert(pd, node);\r\nspin_unlock(&pd->lock);\r\natomic_set(&pd->scan_queue, 1);\r\nif (was_empty) {\r\nwake_up(&pd->wqueue);\r\n} else if (!list_empty(&pd->cdrw.pkt_free_list) && !blocked_bio) {\r\nwake_up(&pd->wqueue);\r\n}\r\nreturn;\r\nend_io:\r\nbio_io_error(bio);\r\n}\r\nstatic int pkt_merge_bvec(struct request_queue *q, struct bvec_merge_data *bmd,\r\nstruct bio_vec *bvec)\r\n{\r\nstruct pktcdvd_device *pd = q->queuedata;\r\nsector_t zone = ZONE(bmd->bi_sector, pd);\r\nint used = ((bmd->bi_sector - zone) << 9) + bmd->bi_size;\r\nint remaining = (pd->settings.size << 9) - used;\r\nint remaining2;\r\nremaining2 = PAGE_SIZE - bmd->bi_size;\r\nremaining = max(remaining, remaining2);\r\nBUG_ON(remaining < 0);\r\nreturn remaining;\r\n}\r\nstatic void pkt_init_queue(struct pktcdvd_device *pd)\r\n{\r\nstruct request_queue *q = pd->disk->queue;\r\nblk_queue_make_request(q, pkt_make_request);\r\nblk_queue_logical_block_size(q, CD_FRAMESIZE);\r\nblk_queue_max_hw_sectors(q, PACKET_MAX_SECTORS);\r\nblk_queue_merge_bvec(q, pkt_merge_bvec);\r\nq->queuedata = pd;\r\n}\r\nstatic int pkt_seq_show(struct seq_file *m, void *p)\r\n{\r\nstruct pktcdvd_device *pd = m->private;\r\nchar *msg;\r\nchar bdev_buf[BDEVNAME_SIZE];\r\nint states[PACKET_NUM_STATES];\r\nseq_printf(m, "Writer %s mapped to %s:\n", pd->name,\r\nbdevname(pd->bdev, bdev_buf));\r\nseq_printf(m, "\nSettings:\n");\r\nseq_printf(m, "\tpacket size:\t\t%dkB\n", pd->settings.size / 2);\r\nif (pd->settings.write_type == 0)\r\nmsg = "Packet";\r\nelse\r\nmsg = "Unknown";\r\nseq_printf(m, "\twrite type:\t\t%s\n", msg);\r\nseq_printf(m, "\tpacket type:\t\t%s\n", pd->settings.fp ? "Fixed" : "Variable");\r\nseq_printf(m, "\tlink loss:\t\t%d\n", pd->settings.link_loss);\r\nseq_printf(m, "\ttrack mode:\t\t%d\n", pd->settings.track_mode);\r\nif (pd->settings.block_mode == PACKET_BLOCK_MODE1)\r\nmsg = "Mode 1";\r\nelse if (pd->settings.block_mode == PACKET_BLOCK_MODE2)\r\nmsg = "Mode 2";\r\nelse\r\nmsg = "Unknown";\r\nseq_printf(m, "\tblock mode:\t\t%s\n", msg);\r\nseq_printf(m, "\nStatistics:\n");\r\nseq_printf(m, "\tpackets started:\t%lu\n", pd->stats.pkt_started);\r\nseq_printf(m, "\tpackets ended:\t\t%lu\n", pd->stats.pkt_ended);\r\nseq_printf(m, "\twritten:\t\t%lukB\n", pd->stats.secs_w >> 1);\r\nseq_printf(m, "\tread gather:\t\t%lukB\n", pd->stats.secs_rg >> 1);\r\nseq_printf(m, "\tread:\t\t\t%lukB\n", pd->stats.secs_r >> 1);\r\nseq_printf(m, "\nMisc:\n");\r\nseq_printf(m, "\treference count:\t%d\n", pd->refcnt);\r\nseq_printf(m, "\tflags:\t\t\t0x%lx\n", pd->flags);\r\nseq_printf(m, "\tread speed:\t\t%ukB/s\n", pd->read_speed);\r\nseq_printf(m, "\twrite speed:\t\t%ukB/s\n", pd->write_speed);\r\nseq_printf(m, "\tstart offset:\t\t%lu\n", pd->offset);\r\nseq_printf(m, "\tmode page offset:\t%u\n", pd->mode_offset);\r\nseq_printf(m, "\nQueue state:\n");\r\nseq_printf(m, "\tbios queued:\t\t%d\n", pd->bio_queue_size);\r\nseq_printf(m, "\tbios pending:\t\t%d\n", atomic_read(&pd->cdrw.pending_bios));\r\nseq_printf(m, "\tcurrent sector:\t\t0x%llx\n", (unsigned long long)pd->current_sector);\r\npkt_count_states(pd, states);\r\nseq_printf(m, "\tstate:\t\t\ti:%d ow:%d rw:%d ww:%d rec:%d fin:%d\n",\r\nstates[0], states[1], states[2], states[3], states[4], states[5]);\r\nseq_printf(m, "\twrite congestion marks:\toff=%d on=%d\n",\r\npd->write_congestion_off,\r\npd->write_congestion_on);\r\nreturn 0;\r\n}\r\nstatic int pkt_seq_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, pkt_seq_show, PDE(inode)->data);\r\n}\r\nstatic int pkt_new_dev(struct pktcdvd_device *pd, dev_t dev)\r\n{\r\nint i;\r\nint ret = 0;\r\nchar b[BDEVNAME_SIZE];\r\nstruct block_device *bdev;\r\nif (pd->pkt_dev == dev) {\r\nprintk(DRIVER_NAME": Recursive setup not allowed\n");\r\nreturn -EBUSY;\r\n}\r\nfor (i = 0; i < MAX_WRITERS; i++) {\r\nstruct pktcdvd_device *pd2 = pkt_devs[i];\r\nif (!pd2)\r\ncontinue;\r\nif (pd2->bdev->bd_dev == dev) {\r\nprintk(DRIVER_NAME": %s already setup\n", bdevname(pd2->bdev, b));\r\nreturn -EBUSY;\r\n}\r\nif (pd2->pkt_dev == dev) {\r\nprintk(DRIVER_NAME": Can't chain pktcdvd devices\n");\r\nreturn -EBUSY;\r\n}\r\n}\r\nbdev = bdget(dev);\r\nif (!bdev)\r\nreturn -ENOMEM;\r\nret = blkdev_get(bdev, FMODE_READ | FMODE_NDELAY, NULL);\r\nif (ret)\r\nreturn ret;\r\n__module_get(THIS_MODULE);\r\npd->bdev = bdev;\r\nset_blocksize(bdev, CD_FRAMESIZE);\r\npkt_init_queue(pd);\r\natomic_set(&pd->cdrw.pending_bios, 0);\r\npd->cdrw.thread = kthread_run(kcdrwd, pd, "%s", pd->name);\r\nif (IS_ERR(pd->cdrw.thread)) {\r\nprintk(DRIVER_NAME": can't start kernel thread\n");\r\nret = -ENOMEM;\r\ngoto out_mem;\r\n}\r\nproc_create_data(pd->name, 0, pkt_proc, &pkt_proc_fops, pd);\r\nDPRINTK(DRIVER_NAME": writer %s mapped to %s\n", pd->name, bdevname(bdev, b));\r\nreturn 0;\r\nout_mem:\r\nblkdev_put(bdev, FMODE_READ | FMODE_NDELAY);\r\nmodule_put(THIS_MODULE);\r\nreturn ret;\r\n}\r\nstatic int pkt_ioctl(struct block_device *bdev, fmode_t mode, unsigned int cmd, unsigned long arg)\r\n{\r\nstruct pktcdvd_device *pd = bdev->bd_disk->private_data;\r\nint ret;\r\nVPRINTK("pkt_ioctl: cmd %x, dev %d:%d\n", cmd,\r\nMAJOR(bdev->bd_dev), MINOR(bdev->bd_dev));\r\nmutex_lock(&pktcdvd_mutex);\r\nswitch (cmd) {\r\ncase CDROMEJECT:\r\nif (pd->refcnt == 1)\r\npkt_lock_door(pd, 0);\r\ncase CDROMMULTISESSION:\r\ncase CDROMREADTOCENTRY:\r\ncase CDROM_LAST_WRITTEN:\r\ncase CDROM_SEND_PACKET:\r\ncase SCSI_IOCTL_SEND_COMMAND:\r\nret = __blkdev_driver_ioctl(pd->bdev, mode, cmd, arg);\r\nbreak;\r\ndefault:\r\nVPRINTK(DRIVER_NAME": Unknown ioctl for %s (%x)\n", pd->name, cmd);\r\nret = -ENOTTY;\r\n}\r\nmutex_unlock(&pktcdvd_mutex);\r\nreturn ret;\r\n}\r\nstatic unsigned int pkt_check_events(struct gendisk *disk,\r\nunsigned int clearing)\r\n{\r\nstruct pktcdvd_device *pd = disk->private_data;\r\nstruct gendisk *attached_disk;\r\nif (!pd)\r\nreturn 0;\r\nif (!pd->bdev)\r\nreturn 0;\r\nattached_disk = pd->bdev->bd_disk;\r\nif (!attached_disk || !attached_disk->fops->check_events)\r\nreturn 0;\r\nreturn attached_disk->fops->check_events(attached_disk, clearing);\r\n}\r\nstatic char *pktcdvd_devnode(struct gendisk *gd, umode_t *mode)\r\n{\r\nreturn kasprintf(GFP_KERNEL, "pktcdvd/%s", gd->disk_name);\r\n}\r\nstatic int pkt_setup_dev(dev_t dev, dev_t* pkt_dev)\r\n{\r\nint idx;\r\nint ret = -ENOMEM;\r\nstruct pktcdvd_device *pd;\r\nstruct gendisk *disk;\r\nmutex_lock_nested(&ctl_mutex, SINGLE_DEPTH_NESTING);\r\nfor (idx = 0; idx < MAX_WRITERS; idx++)\r\nif (!pkt_devs[idx])\r\nbreak;\r\nif (idx == MAX_WRITERS) {\r\nprintk(DRIVER_NAME": max %d writers supported\n", MAX_WRITERS);\r\nret = -EBUSY;\r\ngoto out_mutex;\r\n}\r\npd = kzalloc(sizeof(struct pktcdvd_device), GFP_KERNEL);\r\nif (!pd)\r\ngoto out_mutex;\r\npd->rb_pool = mempool_create_kmalloc_pool(PKT_RB_POOL_SIZE,\r\nsizeof(struct pkt_rb_node));\r\nif (!pd->rb_pool)\r\ngoto out_mem;\r\nINIT_LIST_HEAD(&pd->cdrw.pkt_free_list);\r\nINIT_LIST_HEAD(&pd->cdrw.pkt_active_list);\r\nspin_lock_init(&pd->cdrw.active_list_lock);\r\nspin_lock_init(&pd->lock);\r\nspin_lock_init(&pd->iosched.lock);\r\nbio_list_init(&pd->iosched.read_queue);\r\nbio_list_init(&pd->iosched.write_queue);\r\nsprintf(pd->name, DRIVER_NAME"%d", idx);\r\ninit_waitqueue_head(&pd->wqueue);\r\npd->bio_queue = RB_ROOT;\r\npd->write_congestion_on = write_congestion_on;\r\npd->write_congestion_off = write_congestion_off;\r\ndisk = alloc_disk(1);\r\nif (!disk)\r\ngoto out_mem;\r\npd->disk = disk;\r\ndisk->major = pktdev_major;\r\ndisk->first_minor = idx;\r\ndisk->fops = &pktcdvd_ops;\r\ndisk->flags = GENHD_FL_REMOVABLE;\r\nstrcpy(disk->disk_name, pd->name);\r\ndisk->devnode = pktcdvd_devnode;\r\ndisk->private_data = pd;\r\ndisk->queue = blk_alloc_queue(GFP_KERNEL);\r\nif (!disk->queue)\r\ngoto out_mem2;\r\npd->pkt_dev = MKDEV(pktdev_major, idx);\r\nret = pkt_new_dev(pd, dev);\r\nif (ret)\r\ngoto out_new_dev;\r\ndisk->events = pd->bdev->bd_disk->events;\r\ndisk->async_events = pd->bdev->bd_disk->async_events;\r\nadd_disk(disk);\r\npkt_sysfs_dev_new(pd);\r\npkt_debugfs_dev_new(pd);\r\npkt_devs[idx] = pd;\r\nif (pkt_dev)\r\n*pkt_dev = pd->pkt_dev;\r\nmutex_unlock(&ctl_mutex);\r\nreturn 0;\r\nout_new_dev:\r\nblk_cleanup_queue(disk->queue);\r\nout_mem2:\r\nput_disk(disk);\r\nout_mem:\r\nif (pd->rb_pool)\r\nmempool_destroy(pd->rb_pool);\r\nkfree(pd);\r\nout_mutex:\r\nmutex_unlock(&ctl_mutex);\r\nprintk(DRIVER_NAME": setup of pktcdvd device failed\n");\r\nreturn ret;\r\n}\r\nstatic int pkt_remove_dev(dev_t pkt_dev)\r\n{\r\nstruct pktcdvd_device *pd;\r\nint idx;\r\nint ret = 0;\r\nmutex_lock_nested(&ctl_mutex, SINGLE_DEPTH_NESTING);\r\nfor (idx = 0; idx < MAX_WRITERS; idx++) {\r\npd = pkt_devs[idx];\r\nif (pd && (pd->pkt_dev == pkt_dev))\r\nbreak;\r\n}\r\nif (idx == MAX_WRITERS) {\r\nDPRINTK(DRIVER_NAME": dev not setup\n");\r\nret = -ENXIO;\r\ngoto out;\r\n}\r\nif (pd->refcnt > 0) {\r\nret = -EBUSY;\r\ngoto out;\r\n}\r\nif (!IS_ERR(pd->cdrw.thread))\r\nkthread_stop(pd->cdrw.thread);\r\npkt_devs[idx] = NULL;\r\npkt_debugfs_dev_remove(pd);\r\npkt_sysfs_dev_remove(pd);\r\nblkdev_put(pd->bdev, FMODE_READ | FMODE_NDELAY);\r\nremove_proc_entry(pd->name, pkt_proc);\r\nDPRINTK(DRIVER_NAME": writer %s unmapped\n", pd->name);\r\ndel_gendisk(pd->disk);\r\nblk_cleanup_queue(pd->disk->queue);\r\nput_disk(pd->disk);\r\nmempool_destroy(pd->rb_pool);\r\nkfree(pd);\r\nmodule_put(THIS_MODULE);\r\nout:\r\nmutex_unlock(&ctl_mutex);\r\nreturn ret;\r\n}\r\nstatic void pkt_get_status(struct pkt_ctrl_command *ctrl_cmd)\r\n{\r\nstruct pktcdvd_device *pd;\r\nmutex_lock_nested(&ctl_mutex, SINGLE_DEPTH_NESTING);\r\npd = pkt_find_dev_from_minor(ctrl_cmd->dev_index);\r\nif (pd) {\r\nctrl_cmd->dev = new_encode_dev(pd->bdev->bd_dev);\r\nctrl_cmd->pkt_dev = new_encode_dev(pd->pkt_dev);\r\n} else {\r\nctrl_cmd->dev = 0;\r\nctrl_cmd->pkt_dev = 0;\r\n}\r\nctrl_cmd->num_devices = MAX_WRITERS;\r\nmutex_unlock(&ctl_mutex);\r\n}\r\nstatic long pkt_ctl_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\r\n{\r\nvoid __user *argp = (void __user *)arg;\r\nstruct pkt_ctrl_command ctrl_cmd;\r\nint ret = 0;\r\ndev_t pkt_dev = 0;\r\nif (cmd != PACKET_CTRL_CMD)\r\nreturn -ENOTTY;\r\nif (copy_from_user(&ctrl_cmd, argp, sizeof(struct pkt_ctrl_command)))\r\nreturn -EFAULT;\r\nswitch (ctrl_cmd.command) {\r\ncase PKT_CTRL_CMD_SETUP:\r\nif (!capable(CAP_SYS_ADMIN))\r\nreturn -EPERM;\r\nret = pkt_setup_dev(new_decode_dev(ctrl_cmd.dev), &pkt_dev);\r\nctrl_cmd.pkt_dev = new_encode_dev(pkt_dev);\r\nbreak;\r\ncase PKT_CTRL_CMD_TEARDOWN:\r\nif (!capable(CAP_SYS_ADMIN))\r\nreturn -EPERM;\r\nret = pkt_remove_dev(new_decode_dev(ctrl_cmd.pkt_dev));\r\nbreak;\r\ncase PKT_CTRL_CMD_STATUS:\r\npkt_get_status(&ctrl_cmd);\r\nbreak;\r\ndefault:\r\nreturn -ENOTTY;\r\n}\r\nif (copy_to_user(argp, &ctrl_cmd, sizeof(struct pkt_ctrl_command)))\r\nreturn -EFAULT;\r\nreturn ret;\r\n}\r\nstatic long pkt_ctl_compat_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\r\n{\r\nreturn pkt_ctl_ioctl(file, cmd, (unsigned long)compat_ptr(arg));\r\n}\r\nstatic int __init pkt_init(void)\r\n{\r\nint ret;\r\nmutex_init(&ctl_mutex);\r\npsd_pool = mempool_create_kmalloc_pool(PSD_POOL_SIZE,\r\nsizeof(struct packet_stacked_data));\r\nif (!psd_pool)\r\nreturn -ENOMEM;\r\nret = register_blkdev(pktdev_major, DRIVER_NAME);\r\nif (ret < 0) {\r\nprintk(DRIVER_NAME": Unable to register block device\n");\r\ngoto out2;\r\n}\r\nif (!pktdev_major)\r\npktdev_major = ret;\r\nret = pkt_sysfs_init();\r\nif (ret)\r\ngoto out;\r\npkt_debugfs_init();\r\nret = misc_register(&pkt_misc);\r\nif (ret) {\r\nprintk(DRIVER_NAME": Unable to register misc device\n");\r\ngoto out_misc;\r\n}\r\npkt_proc = proc_mkdir("driver/"DRIVER_NAME, NULL);\r\nreturn 0;\r\nout_misc:\r\npkt_debugfs_cleanup();\r\npkt_sysfs_cleanup();\r\nout:\r\nunregister_blkdev(pktdev_major, DRIVER_NAME);\r\nout2:\r\nmempool_destroy(psd_pool);\r\nreturn ret;\r\n}\r\nstatic void __exit pkt_exit(void)\r\n{\r\nremove_proc_entry("driver/"DRIVER_NAME, NULL);\r\nmisc_deregister(&pkt_misc);\r\npkt_debugfs_cleanup();\r\npkt_sysfs_cleanup();\r\nunregister_blkdev(pktdev_major, DRIVER_NAME);\r\nmempool_destroy(psd_pool);\r\n}
