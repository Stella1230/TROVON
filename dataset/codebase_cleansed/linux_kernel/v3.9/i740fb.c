static inline void i740outb(struct i740fb_par *par, u16 port, u8 val)\r\n{\r\nvga_mm_w(par->regs, port, val);\r\n}\r\nstatic inline u8 i740inb(struct i740fb_par *par, u16 port)\r\n{\r\nreturn vga_mm_r(par->regs, port);\r\n}\r\nstatic inline void i740outreg(struct i740fb_par *par, u16 port, u8 reg, u8 val)\r\n{\r\nvga_mm_w_fast(par->regs, port, reg, val);\r\n}\r\nstatic inline u8 i740inreg(struct i740fb_par *par, u16 port, u8 reg)\r\n{\r\nvga_mm_w(par->regs, port, reg);\r\nreturn vga_mm_r(par->regs, port+1);\r\n}\r\nstatic inline void i740outreg_mask(struct i740fb_par *par, u16 port, u8 reg,\r\nu8 val, u8 mask)\r\n{\r\nvga_mm_w_fast(par->regs, port, reg, (val & mask)\r\n| (i740inreg(par, port, reg) & ~mask));\r\n}\r\nstatic void i740fb_ddc_setscl(void *data, int val)\r\n{\r\nstruct i740fb_par *par = data;\r\ni740outreg_mask(par, XRX, REG_DDC_DRIVE, DDC_SCL, DDC_SCL);\r\ni740outreg_mask(par, XRX, REG_DDC_STATE, val ? DDC_SCL : 0, DDC_SCL);\r\n}\r\nstatic void i740fb_ddc_setsda(void *data, int val)\r\n{\r\nstruct i740fb_par *par = data;\r\ni740outreg_mask(par, XRX, REG_DDC_DRIVE, DDC_SDA, DDC_SDA);\r\ni740outreg_mask(par, XRX, REG_DDC_STATE, val ? DDC_SDA : 0, DDC_SDA);\r\n}\r\nstatic int i740fb_ddc_getscl(void *data)\r\n{\r\nstruct i740fb_par *par = data;\r\ni740outreg_mask(par, XRX, REG_DDC_DRIVE, 0, DDC_SCL);\r\nreturn !!(i740inreg(par, XRX, REG_DDC_STATE) & DDC_SCL);\r\n}\r\nstatic int i740fb_ddc_getsda(void *data)\r\n{\r\nstruct i740fb_par *par = data;\r\ni740outreg_mask(par, XRX, REG_DDC_DRIVE, 0, DDC_SDA);\r\nreturn !!(i740inreg(par, XRX, REG_DDC_STATE) & DDC_SDA);\r\n}\r\nstatic int i740fb_setup_ddc_bus(struct fb_info *info)\r\n{\r\nstruct i740fb_par *par = info->par;\r\nstrlcpy(par->ddc_adapter.name, info->fix.id,\r\nsizeof(par->ddc_adapter.name));\r\npar->ddc_adapter.owner = THIS_MODULE;\r\npar->ddc_adapter.class = I2C_CLASS_DDC;\r\npar->ddc_adapter.algo_data = &par->ddc_algo;\r\npar->ddc_adapter.dev.parent = info->device;\r\npar->ddc_algo.setsda = i740fb_ddc_setsda;\r\npar->ddc_algo.setscl = i740fb_ddc_setscl;\r\npar->ddc_algo.getsda = i740fb_ddc_getsda;\r\npar->ddc_algo.getscl = i740fb_ddc_getscl;\r\npar->ddc_algo.udelay = 10;\r\npar->ddc_algo.timeout = 20;\r\npar->ddc_algo.data = par;\r\ni2c_set_adapdata(&par->ddc_adapter, par);\r\nreturn i2c_bit_add_bus(&par->ddc_adapter);\r\n}\r\nstatic int i740fb_open(struct fb_info *info, int user)\r\n{\r\nstruct i740fb_par *par = info->par;\r\nmutex_lock(&(par->open_lock));\r\npar->ref_count++;\r\nmutex_unlock(&(par->open_lock));\r\nreturn 0;\r\n}\r\nstatic int i740fb_release(struct fb_info *info, int user)\r\n{\r\nstruct i740fb_par *par = info->par;\r\nmutex_lock(&(par->open_lock));\r\nif (par->ref_count == 0) {\r\nprintk(KERN_ERR "fb%d: release called with zero refcount\n",\r\ninfo->node);\r\nmutex_unlock(&(par->open_lock));\r\nreturn -EINVAL;\r\n}\r\npar->ref_count--;\r\nmutex_unlock(&(par->open_lock));\r\nreturn 0;\r\n}\r\nstatic u32 i740_calc_fifo(struct i740fb_par *par, u32 freq, int bpp)\r\n{\r\nu32 wm;\r\nswitch (bpp) {\r\ncase 8:\r\nif (freq > 200)\r\nwm = 0x18120000;\r\nelse if (freq > 175)\r\nwm = 0x16110000;\r\nelse if (freq > 135)\r\nwm = 0x120E0000;\r\nelse\r\nwm = 0x100D0000;\r\nbreak;\r\ncase 15:\r\ncase 16:\r\nif (par->has_sgram) {\r\nif (freq > 140)\r\nwm = 0x2C1D0000;\r\nelse if (freq > 120)\r\nwm = 0x2C180000;\r\nelse if (freq > 100)\r\nwm = 0x24160000;\r\nelse if (freq > 90)\r\nwm = 0x18120000;\r\nelse if (freq > 50)\r\nwm = 0x16110000;\r\nelse if (freq > 32)\r\nwm = 0x13100000;\r\nelse\r\nwm = 0x120E0000;\r\n} else {\r\nif (freq > 160)\r\nwm = 0x28200000;\r\nelse if (freq > 140)\r\nwm = 0x2A1E0000;\r\nelse if (freq > 130)\r\nwm = 0x2B1A0000;\r\nelse if (freq > 120)\r\nwm = 0x2C180000;\r\nelse if (freq > 100)\r\nwm = 0x24180000;\r\nelse if (freq > 90)\r\nwm = 0x18120000;\r\nelse if (freq > 50)\r\nwm = 0x16110000;\r\nelse if (freq > 32)\r\nwm = 0x13100000;\r\nelse\r\nwm = 0x120E0000;\r\n}\r\nbreak;\r\ncase 24:\r\nif (par->has_sgram) {\r\nif (freq > 130)\r\nwm = 0x31200000;\r\nelse if (freq > 120)\r\nwm = 0x2E200000;\r\nelse if (freq > 100)\r\nwm = 0x2C1D0000;\r\nelse if (freq > 80)\r\nwm = 0x25180000;\r\nelse if (freq > 64)\r\nwm = 0x24160000;\r\nelse if (freq > 49)\r\nwm = 0x18120000;\r\nelse if (freq > 32)\r\nwm = 0x16110000;\r\nelse\r\nwm = 0x13100000;\r\n} else {\r\nif (freq > 120)\r\nwm = 0x311F0000;\r\nelse if (freq > 100)\r\nwm = 0x2C1D0000;\r\nelse if (freq > 80)\r\nwm = 0x25180000;\r\nelse if (freq > 64)\r\nwm = 0x24160000;\r\nelse if (freq > 49)\r\nwm = 0x18120000;\r\nelse if (freq > 32)\r\nwm = 0x16110000;\r\nelse\r\nwm = 0x13100000;\r\n}\r\nbreak;\r\ncase 32:\r\nif (par->has_sgram) {\r\nif (freq > 80)\r\nwm = 0x2A200000;\r\nelse if (freq > 60)\r\nwm = 0x281A0000;\r\nelse if (freq > 49)\r\nwm = 0x25180000;\r\nelse if (freq > 32)\r\nwm = 0x18120000;\r\nelse\r\nwm = 0x16110000;\r\n} else {\r\nif (freq > 80)\r\nwm = 0x29200000;\r\nelse if (freq > 60)\r\nwm = 0x281A0000;\r\nelse if (freq > 49)\r\nwm = 0x25180000;\r\nelse if (freq > 32)\r\nwm = 0x18120000;\r\nelse\r\nwm = 0x16110000;\r\n}\r\nbreak;\r\n}\r\nreturn wm;\r\n}\r\nstatic void i740_calc_vclk(u32 freq, struct i740fb_par *par)\r\n{\r\nconst u32 err_max = freq / (200 * I740_RFREQ / I740_FFIX);\r\nconst u32 err_target = freq / (1000 * I740_RFREQ / I740_FFIX);\r\nu32 err_best = 512 * I740_FFIX;\r\nu32 f_err, f_vco;\r\nint m_best = 0, n_best = 0, p_best = 0, d_best = 0;\r\nint m, n;\r\np_best = min(15, ilog2(I740_MAX_VCO_FREQ / (freq / I740_RFREQ_FIX)));\r\nd_best = 0;\r\nf_vco = (freq * (1 << p_best)) / I740_RFREQ_FIX;\r\nfreq = freq / I740_RFREQ_FIX;\r\nn = 2;\r\ndo {\r\nn++;\r\nm = ((f_vco * n) / I740_REF_FREQ + 2) / 4;\r\nif (m < 3)\r\nm = 3;\r\n{\r\nu32 f_out = (((m * I740_REF_FREQ * (4 << 2 * d_best))\r\n/ n) + ((1 << p_best) / 2)) / (1 << p_best);\r\nf_err = (freq - f_out);\r\nif (abs(f_err) < err_max) {\r\nm_best = m;\r\nn_best = n;\r\nerr_best = f_err;\r\n}\r\n}\r\n} while ((abs(f_err) >= err_target) &&\r\n((n <= TARGET_MAX_N) || (abs(err_best) > err_max)));\r\nif (abs(f_err) < err_target) {\r\nm_best = m;\r\nn_best = n;\r\n}\r\npar->video_clk2_m = (m_best - 2) & 0xFF;\r\npar->video_clk2_n = (n_best - 2) & 0xFF;\r\npar->video_clk2_mn_msbs = ((((n_best - 2) >> 4) & VCO_N_MSBS)\r\n| (((m_best - 2) >> 8) & VCO_M_MSBS));\r\npar->video_clk2_div_sel =\r\n((p_best << 4) | (d_best ? 4 : 0) | REF_DIV_1);\r\n}\r\nstatic int i740fb_decode_var(const struct fb_var_screeninfo *var,\r\nstruct i740fb_par *par, struct fb_info *info)\r\n{\r\nu32 xres, right, hslen, left, xtotal;\r\nu32 yres, lower, vslen, upper, ytotal;\r\nu32 vxres, xoffset, vyres, yoffset;\r\nu32 bpp, base, dacspeed24, mem;\r\nu8 r7;\r\nint i;\r\ndev_dbg(info->device, "decode_var: xres: %i, yres: %i, xres_v: %i, xres_v: %i\n",\r\nvar->xres, var->yres, var->xres_virtual, var->xres_virtual);\r\ndev_dbg(info->device, " xoff: %i, yoff: %i, bpp: %i, graysc: %i\n",\r\nvar->xoffset, var->yoffset, var->bits_per_pixel,\r\nvar->grayscale);\r\ndev_dbg(info->device, " activate: %i, nonstd: %i, vmode: %i\n",\r\nvar->activate, var->nonstd, var->vmode);\r\ndev_dbg(info->device, " pixclock: %i, hsynclen:%i, vsynclen:%i\n",\r\nvar->pixclock, var->hsync_len, var->vsync_len);\r\ndev_dbg(info->device, " left: %i, right: %i, up:%i, lower:%i\n",\r\nvar->left_margin, var->right_margin, var->upper_margin,\r\nvar->lower_margin);\r\nbpp = var->bits_per_pixel;\r\nswitch (bpp) {\r\ncase 1 ... 8:\r\nbpp = 8;\r\nif ((1000000 / var->pixclock) > DACSPEED8) {\r\ndev_err(info->device, "requested pixclock %i MHz out of range (max. %i MHz at 8bpp)\n",\r\n1000000 / var->pixclock, DACSPEED8);\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ncase 9 ... 15:\r\nbpp = 15;\r\ncase 16:\r\nif ((1000000 / var->pixclock) > DACSPEED16) {\r\ndev_err(info->device, "requested pixclock %i MHz out of range (max. %i MHz at 15/16bpp)\n",\r\n1000000 / var->pixclock, DACSPEED16);\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ncase 17 ... 24:\r\nbpp = 24;\r\ndacspeed24 = par->has_sgram ? DACSPEED24_SG : DACSPEED24_SD;\r\nif ((1000000 / var->pixclock) > dacspeed24) {\r\ndev_err(info->device, "requested pixclock %i MHz out of range (max. %i MHz at 24bpp)\n",\r\n1000000 / var->pixclock, dacspeed24);\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ncase 25 ... 32:\r\nbpp = 32;\r\nif ((1000000 / var->pixclock) > DACSPEED32) {\r\ndev_err(info->device, "requested pixclock %i MHz out of range (max. %i MHz at 32bpp)\n",\r\n1000000 / var->pixclock, DACSPEED32);\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nxres = ALIGN(var->xres, 8);\r\nvxres = ALIGN(var->xres_virtual, 16);\r\nif (vxres < xres)\r\nvxres = xres;\r\nxoffset = ALIGN(var->xoffset, 8);\r\nif (xres + xoffset > vxres)\r\nxoffset = vxres - xres;\r\nleft = ALIGN(var->left_margin, 8);\r\nright = ALIGN(var->right_margin, 8);\r\nhslen = ALIGN(var->hsync_len, 8);\r\nyres = var->yres;\r\nvyres = var->yres_virtual;\r\nif (yres > vyres)\r\nvyres = yres;\r\nyoffset = var->yoffset;\r\nif (yres + yoffset > vyres)\r\nyoffset = vyres - yres;\r\nlower = var->lower_margin;\r\nvslen = var->vsync_len;\r\nupper = var->upper_margin;\r\nmem = vxres * vyres * ((bpp + 1) / 8);\r\nif (mem > info->screen_size) {\r\ndev_err(info->device, "not enough video memory (%d KB requested, %ld KB available)\n",\r\nmem >> 10, info->screen_size >> 10);\r\nreturn -ENOMEM;\r\n}\r\nif (yoffset + yres > vyres)\r\nyoffset = vyres - yres;\r\nxtotal = xres + right + hslen + left;\r\nytotal = yres + lower + vslen + upper;\r\npar->crtc[VGA_CRTC_H_TOTAL] = (xtotal >> 3) - 5;\r\npar->crtc[VGA_CRTC_H_DISP] = (xres >> 3) - 1;\r\npar->crtc[VGA_CRTC_H_BLANK_START] = ((xres + right) >> 3) - 1;\r\npar->crtc[VGA_CRTC_H_SYNC_START] = (xres + right) >> 3;\r\npar->crtc[VGA_CRTC_H_SYNC_END] = (((xres + right + hslen) >> 3) & 0x1F)\r\n| ((((xres + right + hslen) >> 3) & 0x20) << 2);\r\npar->crtc[VGA_CRTC_H_BLANK_END] = ((xres + right + hslen) >> 3 & 0x1F)\r\n| 0x80;\r\npar->crtc[VGA_CRTC_V_TOTAL] = ytotal - 2;\r\nr7 = 0x10;\r\nif (ytotal & 0x100)\r\nr7 |= 0x01;\r\nif (ytotal & 0x200)\r\nr7 |= 0x20;\r\npar->crtc[VGA_CRTC_PRESET_ROW] = 0;\r\npar->crtc[VGA_CRTC_MAX_SCAN] = 0x40;\r\nif (var->vmode & FB_VMODE_DOUBLE)\r\npar->crtc[VGA_CRTC_MAX_SCAN] |= 0x80;\r\npar->crtc[VGA_CRTC_CURSOR_START] = 0x00;\r\npar->crtc[VGA_CRTC_CURSOR_END] = 0x00;\r\npar->crtc[VGA_CRTC_CURSOR_HI] = 0x00;\r\npar->crtc[VGA_CRTC_CURSOR_LO] = 0x00;\r\npar->crtc[VGA_CRTC_V_DISP_END] = yres-1;\r\nif ((yres-1) & 0x100)\r\nr7 |= 0x02;\r\nif ((yres-1) & 0x200)\r\nr7 |= 0x40;\r\npar->crtc[VGA_CRTC_V_BLANK_START] = yres + lower - 1;\r\npar->crtc[VGA_CRTC_V_SYNC_START] = yres + lower - 1;\r\nif ((yres + lower - 1) & 0x100)\r\nr7 |= 0x0C;\r\nif ((yres + lower - 1) & 0x200) {\r\npar->crtc[VGA_CRTC_MAX_SCAN] |= 0x20;\r\nr7 |= 0x80;\r\n}\r\npar->crtc[VGA_CRTC_V_SYNC_END] =\r\n((yres + lower - 1 + vslen) & 0x0F) & ~0x10;\r\npar->crtc[VGA_CRTC_V_BLANK_END] = (yres + lower - 1 + vslen) & 0xFF;\r\npar->crtc[VGA_CRTC_UNDERLINE] = 0x00;\r\npar->crtc[VGA_CRTC_MODE] = 0xC3 ;\r\npar->crtc[VGA_CRTC_LINE_COMPARE] = 0xFF;\r\npar->crtc[VGA_CRTC_OVERFLOW] = r7;\r\npar->vss = 0x00;\r\nfor (i = 0x00; i < 0x10; i++)\r\npar->atc[i] = i;\r\npar->atc[VGA_ATC_MODE] = 0x81;\r\npar->atc[VGA_ATC_OVERSCAN] = 0x00;\r\npar->atc[VGA_ATC_PLANE_ENABLE] = 0x0F;\r\npar->atc[VGA_ATC_COLOR_PAGE] = 0x00;\r\npar->misc = 0xC3;\r\nif (var->sync & FB_SYNC_HOR_HIGH_ACT)\r\npar->misc &= ~0x40;\r\nif (var->sync & FB_SYNC_VERT_HIGH_ACT)\r\npar->misc &= ~0x80;\r\npar->seq[VGA_SEQ_CLOCK_MODE] = 0x01;\r\npar->seq[VGA_SEQ_PLANE_WRITE] = 0x0F;\r\npar->seq[VGA_SEQ_CHARACTER_MAP] = 0x00;\r\npar->seq[VGA_SEQ_MEMORY_MODE] = 0x06;\r\npar->gdc[VGA_GFX_SR_VALUE] = 0x00;\r\npar->gdc[VGA_GFX_SR_ENABLE] = 0x00;\r\npar->gdc[VGA_GFX_COMPARE_VALUE] = 0x00;\r\npar->gdc[VGA_GFX_DATA_ROTATE] = 0x00;\r\npar->gdc[VGA_GFX_PLANE_READ] = 0;\r\npar->gdc[VGA_GFX_MODE] = 0x02;\r\npar->gdc[VGA_GFX_MISC] = 0x05;\r\npar->gdc[VGA_GFX_COMPARE_MASK] = 0x0F;\r\npar->gdc[VGA_GFX_BIT_MASK] = 0xFF;\r\nbase = (yoffset * vxres + (xoffset & ~7)) >> 2;\r\nswitch (bpp) {\r\ncase 8:\r\npar->crtc[VGA_CRTC_OFFSET] = vxres >> 3;\r\npar->ext_offset = vxres >> 11;\r\npar->pixelpipe_cfg1 = DISPLAY_8BPP_MODE;\r\npar->bitblt_cntl = COLEXP_8BPP;\r\nbreak;\r\ncase 15:\r\ncase 16:\r\npar->pixelpipe_cfg1 = (var->green.length == 6) ?\r\nDISPLAY_16BPP_MODE : DISPLAY_15BPP_MODE;\r\npar->crtc[VGA_CRTC_OFFSET] = vxres >> 2;\r\npar->ext_offset = vxres >> 10;\r\npar->bitblt_cntl = COLEXP_16BPP;\r\nbase *= 2;\r\nbreak;\r\ncase 24:\r\npar->crtc[VGA_CRTC_OFFSET] = (vxres * 3) >> 3;\r\npar->ext_offset = (vxres * 3) >> 11;\r\npar->pixelpipe_cfg1 = DISPLAY_24BPP_MODE;\r\npar->bitblt_cntl = COLEXP_24BPP;\r\nbase &= 0xFFFFFFFE;\r\nbase *= 3;\r\nbreak;\r\ncase 32:\r\npar->crtc[VGA_CRTC_OFFSET] = vxres >> 1;\r\npar->ext_offset = vxres >> 9;\r\npar->pixelpipe_cfg1 = DISPLAY_32BPP_MODE;\r\npar->bitblt_cntl = COLEXP_RESERVED;\r\nbase *= 4;\r\nbreak;\r\n}\r\npar->crtc[VGA_CRTC_START_LO] = base & 0x000000FF;\r\npar->crtc[VGA_CRTC_START_HI] = (base & 0x0000FF00) >> 8;\r\npar->ext_start_addr =\r\n((base & 0x003F0000) >> 16) | EXT_START_ADDR_ENABLE;\r\npar->ext_start_addr_hi = (base & 0x3FC00000) >> 22;\r\npar->pixelpipe_cfg0 = DAC_8_BIT;\r\npar->pixelpipe_cfg2 = DISPLAY_GAMMA_ENABLE | OVERLAY_GAMMA_ENABLE;\r\npar->io_cntl = EXTENDED_CRTC_CNTL;\r\npar->address_mapping = LINEAR_MODE_ENABLE | PAGE_MAPPING_ENABLE;\r\npar->display_cntl = HIRES_MODE;\r\npar->pll_cntl = PLL_MEMCLK_100000KHZ;\r\npar->ext_vert_total = (ytotal - 2) >> 8;\r\npar->ext_vert_disp_end = (yres - 1) >> 8;\r\npar->ext_vert_sync_start = (yres + lower) >> 8;\r\npar->ext_vert_blank_start = (yres + lower) >> 8;\r\npar->ext_horiz_total = ((xtotal >> 3) - 5) >> 8;\r\npar->ext_horiz_blank = (((xres + right) >> 3) & 0x40) >> 6;\r\npar->interlace_cntl = INTERLACE_DISABLE;\r\npar->atc[VGA_ATC_OVERSCAN] = 0;\r\ni740_calc_vclk((((u32)1e9) / var->pixclock) * (u32)(1e3), par);\r\npar->misc |= 0x0C;\r\npar->lmi_fifo_watermark =\r\ni740_calc_fifo(par, 1000000 / var->pixclock, bpp);\r\nreturn 0;\r\n}\r\nstatic int i740fb_check_var(struct fb_var_screeninfo *var, struct fb_info *info)\r\n{\r\nswitch (var->bits_per_pixel) {\r\ncase 8:\r\nvar->red.offset = var->green.offset = var->blue.offset = 0;\r\nvar->red.length = var->green.length = var->blue.length = 8;\r\nbreak;\r\ncase 16:\r\nswitch (var->green.length) {\r\ndefault:\r\ncase 5:\r\nvar->red.offset = 10;\r\nvar->green.offset = 5;\r\nvar->blue.offset = 0;\r\nvar->red.length = 5;\r\nvar->green.length = 5;\r\nvar->blue.length = 5;\r\nbreak;\r\ncase 6:\r\nvar->red.offset = 11;\r\nvar->green.offset = 5;\r\nvar->blue.offset = 0;\r\nvar->red.length = var->blue.length = 5;\r\nbreak;\r\n}\r\nbreak;\r\ncase 24:\r\nvar->red.offset = 16;\r\nvar->green.offset = 8;\r\nvar->blue.offset = 0;\r\nvar->red.length = var->green.length = var->blue.length = 8;\r\nbreak;\r\ncase 32:\r\nvar->transp.offset = 24;\r\nvar->red.offset = 16;\r\nvar->green.offset = 8;\r\nvar->blue.offset = 0;\r\nvar->transp.length = 8;\r\nvar->red.length = var->green.length = var->blue.length = 8;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (var->xres > var->xres_virtual)\r\nvar->xres_virtual = var->xres;\r\nif (var->yres > var->yres_virtual)\r\nvar->yres_virtual = var->yres;\r\nif (info->monspecs.hfmax && info->monspecs.vfmax &&\r\ninfo->monspecs.dclkmax && fb_validate_mode(var, info) < 0)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic void vga_protect(struct i740fb_par *par)\r\n{\r\ni740outreg_mask(par, VGA_SEQ_I, VGA_SEQ_CLOCK_MODE, 0x20, 0x20);\r\ni740inb(par, 0x3DA);\r\ni740outb(par, VGA_ATT_W, 0x00);\r\n}\r\nstatic void vga_unprotect(struct i740fb_par *par)\r\n{\r\ni740outreg_mask(par, VGA_SEQ_I, VGA_SEQ_CLOCK_MODE, 0, 0x20);\r\ni740inb(par, 0x3DA);\r\ni740outb(par, VGA_ATT_W, 0x20);\r\n}\r\nstatic int i740fb_set_par(struct fb_info *info)\r\n{\r\nstruct i740fb_par *par = info->par;\r\nu32 itemp;\r\nint i;\r\ni = i740fb_decode_var(&info->var, par, info);\r\nif (i)\r\nreturn i;\r\nmemset(info->screen_base, 0, info->screen_size);\r\nvga_protect(par);\r\ni740outreg(par, XRX, DRAM_EXT_CNTL, DRAM_REFRESH_DISABLE);\r\nmdelay(1);\r\ni740outreg(par, XRX, VCLK2_VCO_M, par->video_clk2_m);\r\ni740outreg(par, XRX, VCLK2_VCO_N, par->video_clk2_n);\r\ni740outreg(par, XRX, VCLK2_VCO_MN_MSBS, par->video_clk2_mn_msbs);\r\ni740outreg(par, XRX, VCLK2_VCO_DIV_SEL, par->video_clk2_div_sel);\r\ni740outreg_mask(par, XRX, PIXPIPE_CONFIG_0,\r\npar->pixelpipe_cfg0 & DAC_8_BIT, 0x80);\r\ni740inb(par, 0x3DA);\r\ni740outb(par, 0x3C0, 0x00);\r\ni740outb(par, VGA_MIS_W, par->misc | 0x01);\r\ni740outreg(par, VGA_SEQ_I, VGA_SEQ_RESET, 0x01);\r\ni740outreg(par, VGA_SEQ_I, VGA_SEQ_CLOCK_MODE,\r\npar->seq[VGA_SEQ_CLOCK_MODE] | 0x20);\r\nfor (i = 2; i < VGA_SEQ_C; i++)\r\ni740outreg(par, VGA_SEQ_I, i, par->seq[i]);\r\ni740outreg(par, VGA_SEQ_I, VGA_SEQ_RESET, 0x03);\r\ni740outreg(par, VGA_CRT_IC, VGA_CRTC_V_SYNC_END,\r\npar->crtc[VGA_CRTC_V_SYNC_END]);\r\nfor (i = 0; i < VGA_CRT_C; i++)\r\ni740outreg(par, VGA_CRT_IC, i, par->crtc[i]);\r\nfor (i = 0; i < VGA_GFX_C; i++)\r\ni740outreg(par, VGA_GFX_I, i, par->gdc[i]);\r\nfor (i = 0; i < VGA_ATT_C; i++) {\r\ni740inb(par, VGA_IS1_RC);\r\ni740outb(par, VGA_ATT_IW, i);\r\ni740outb(par, VGA_ATT_IW, par->atc[i]);\r\n}\r\ni740inb(par, VGA_IS1_RC);\r\ni740outb(par, VGA_ATT_IW, 0x20);\r\ni740outreg(par, VGA_CRT_IC, EXT_VERT_TOTAL, par->ext_vert_total);\r\ni740outreg(par, VGA_CRT_IC, EXT_VERT_DISPLAY, par->ext_vert_disp_end);\r\ni740outreg(par, VGA_CRT_IC, EXT_VERT_SYNC_START,\r\npar->ext_vert_sync_start);\r\ni740outreg(par, VGA_CRT_IC, EXT_VERT_BLANK_START,\r\npar->ext_vert_blank_start);\r\ni740outreg(par, VGA_CRT_IC, EXT_HORIZ_TOTAL, par->ext_horiz_total);\r\ni740outreg(par, VGA_CRT_IC, EXT_HORIZ_BLANK, par->ext_horiz_blank);\r\ni740outreg(par, VGA_CRT_IC, EXT_OFFSET, par->ext_offset);\r\ni740outreg(par, VGA_CRT_IC, EXT_START_ADDR_HI, par->ext_start_addr_hi);\r\ni740outreg(par, VGA_CRT_IC, EXT_START_ADDR, par->ext_start_addr);\r\ni740outreg_mask(par, VGA_CRT_IC, INTERLACE_CNTL,\r\npar->interlace_cntl, INTERLACE_ENABLE);\r\ni740outreg_mask(par, XRX, ADDRESS_MAPPING, par->address_mapping, 0x1F);\r\ni740outreg_mask(par, XRX, BITBLT_CNTL, par->bitblt_cntl, COLEXP_MODE);\r\ni740outreg_mask(par, XRX, DISPLAY_CNTL,\r\npar->display_cntl, VGA_WRAP_MODE | GUI_MODE);\r\ni740outreg_mask(par, XRX, PIXPIPE_CONFIG_0, par->pixelpipe_cfg0, 0x9B);\r\ni740outreg_mask(par, XRX, PIXPIPE_CONFIG_2, par->pixelpipe_cfg2, 0x0C);\r\ni740outreg(par, XRX, PLL_CNTL, par->pll_cntl);\r\ni740outreg_mask(par, XRX, PIXPIPE_CONFIG_1,\r\npar->pixelpipe_cfg1, DISPLAY_COLOR_MODE);\r\nitemp = readl(par->regs + FWATER_BLC);\r\nitemp &= ~(LMI_BURST_LENGTH | LMI_FIFO_WATERMARK);\r\nitemp |= par->lmi_fifo_watermark;\r\nwritel(itemp, par->regs + FWATER_BLC);\r\ni740outreg(par, XRX, DRAM_EXT_CNTL, DRAM_REFRESH_60HZ);\r\ni740outreg_mask(par, MRX, COL_KEY_CNTL_1, 0, BLANK_DISP_OVERLAY);\r\ni740outreg_mask(par, XRX, IO_CTNL,\r\npar->io_cntl, EXTENDED_ATTR_CNTL | EXTENDED_CRTC_CNTL);\r\nif (par->pixelpipe_cfg1 != DISPLAY_8BPP_MODE) {\r\ni740outb(par, VGA_PEL_MSK, 0xFF);\r\ni740outb(par, VGA_PEL_IW, 0x00);\r\nfor (i = 0; i < 256; i++) {\r\nitemp = (par->pixelpipe_cfg0 & DAC_8_BIT) ? i : i >> 2;\r\ni740outb(par, VGA_PEL_D, itemp);\r\ni740outb(par, VGA_PEL_D, itemp);\r\ni740outb(par, VGA_PEL_D, itemp);\r\n}\r\n}\r\nmdelay(50);\r\nvga_unprotect(par);\r\ninfo->fix.line_length =\r\ninfo->var.xres_virtual * info->var.bits_per_pixel / 8;\r\nif (info->var.bits_per_pixel == 8)\r\ninfo->fix.visual = FB_VISUAL_PSEUDOCOLOR;\r\nelse\r\ninfo->fix.visual = FB_VISUAL_TRUECOLOR;\r\nreturn 0;\r\n}\r\nstatic int i740fb_setcolreg(unsigned regno, unsigned red, unsigned green,\r\nunsigned blue, unsigned transp,\r\nstruct fb_info *info)\r\n{\r\nu32 r, g, b;\r\ndev_dbg(info->device, "setcolreg: regno: %i, red=%d, green=%d, blue=%d, transp=%d, bpp=%d\n",\r\nregno, red, green, blue, transp, info->var.bits_per_pixel);\r\nswitch (info->fix.visual) {\r\ncase FB_VISUAL_PSEUDOCOLOR:\r\nif (regno >= 256)\r\nreturn -EINVAL;\r\ni740outb(info->par, VGA_PEL_IW, regno);\r\ni740outb(info->par, VGA_PEL_D, red >> 8);\r\ni740outb(info->par, VGA_PEL_D, green >> 8);\r\ni740outb(info->par, VGA_PEL_D, blue >> 8);\r\nbreak;\r\ncase FB_VISUAL_TRUECOLOR:\r\nif (regno >= 16)\r\nreturn -EINVAL;\r\nr = (red >> (16 - info->var.red.length))\r\n<< info->var.red.offset;\r\nb = (blue >> (16 - info->var.blue.length))\r\n<< info->var.blue.offset;\r\ng = (green >> (16 - info->var.green.length))\r\n<< info->var.green.offset;\r\n((u32 *) info->pseudo_palette)[regno] = r | g | b;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int i740fb_pan_display(struct fb_var_screeninfo *var,\r\nstruct fb_info *info)\r\n{\r\nstruct i740fb_par *par = info->par;\r\nu32 base = (var->yoffset * info->var.xres_virtual\r\n+ (var->xoffset & ~7)) >> 2;\r\ndev_dbg(info->device, "pan_display: xoffset: %i yoffset: %i base: %i\n",\r\nvar->xoffset, var->yoffset, base);\r\nswitch (info->var.bits_per_pixel) {\r\ncase 8:\r\nbreak;\r\ncase 15:\r\ncase 16:\r\nbase *= 2;\r\nbreak;\r\ncase 24:\r\nbase &= 0xFFFFFFFE;\r\nbase *= 3;\r\nbreak;\r\ncase 32:\r\nbase *= 4;\r\nbreak;\r\n}\r\npar->crtc[VGA_CRTC_START_LO] = base & 0x000000FF;\r\npar->crtc[VGA_CRTC_START_HI] = (base & 0x0000FF00) >> 8;\r\npar->ext_start_addr_hi = (base & 0x3FC00000) >> 22;\r\npar->ext_start_addr =\r\n((base & 0x003F0000) >> 16) | EXT_START_ADDR_ENABLE;\r\ni740outreg(par, VGA_CRT_IC, VGA_CRTC_START_LO, base & 0x000000FF);\r\ni740outreg(par, VGA_CRT_IC, VGA_CRTC_START_HI,\r\n(base & 0x0000FF00) >> 8);\r\ni740outreg(par, VGA_CRT_IC, EXT_START_ADDR_HI,\r\n(base & 0x3FC00000) >> 22);\r\ni740outreg(par, VGA_CRT_IC, EXT_START_ADDR,\r\n((base & 0x003F0000) >> 16) | EXT_START_ADDR_ENABLE);\r\nreturn 0;\r\n}\r\nstatic int i740fb_blank(int blank_mode, struct fb_info *info)\r\n{\r\nstruct i740fb_par *par = info->par;\r\nunsigned char SEQ01;\r\nint DPMSSyncSelect;\r\nswitch (blank_mode) {\r\ncase FB_BLANK_UNBLANK:\r\ncase FB_BLANK_NORMAL:\r\nSEQ01 = 0x00;\r\nDPMSSyncSelect = HSYNC_ON | VSYNC_ON;\r\nbreak;\r\ncase FB_BLANK_VSYNC_SUSPEND:\r\nSEQ01 = 0x20;\r\nDPMSSyncSelect = HSYNC_ON | VSYNC_OFF;\r\nbreak;\r\ncase FB_BLANK_HSYNC_SUSPEND:\r\nSEQ01 = 0x20;\r\nDPMSSyncSelect = HSYNC_OFF | VSYNC_ON;\r\nbreak;\r\ncase FB_BLANK_POWERDOWN:\r\nSEQ01 = 0x20;\r\nDPMSSyncSelect = HSYNC_OFF | VSYNC_OFF;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\ni740outb(par, SRX, 0x01);\r\nSEQ01 |= i740inb(par, SRX + 1) & ~0x20;\r\ni740outb(par, SRX, 0x01);\r\ni740outb(par, SRX + 1, SEQ01);\r\ni740outreg(par, XRX, DPMS_SYNC_SELECT, DPMSSyncSelect);\r\nreturn (blank_mode == FB_BLANK_NORMAL) ? 1 : 0;\r\n}\r\nstatic int i740fb_probe(struct pci_dev *dev, const struct pci_device_id *ent)\r\n{\r\nstruct fb_info *info;\r\nstruct i740fb_par *par;\r\nint ret, tmp;\r\nbool found = false;\r\nu8 *edid;\r\ninfo = framebuffer_alloc(sizeof(struct i740fb_par), &(dev->dev));\r\nif (!info) {\r\ndev_err(&(dev->dev), "cannot allocate framebuffer\n");\r\nreturn -ENOMEM;\r\n}\r\npar = info->par;\r\nmutex_init(&par->open_lock);\r\ninfo->var.activate = FB_ACTIVATE_NOW;\r\ninfo->var.bits_per_pixel = 8;\r\ninfo->fbops = &i740fb_ops;\r\ninfo->pseudo_palette = par->pseudo_palette;\r\nret = pci_enable_device(dev);\r\nif (ret) {\r\ndev_err(info->device, "cannot enable PCI device\n");\r\ngoto err_enable_device;\r\n}\r\nret = pci_request_regions(dev, info->fix.id);\r\nif (ret) {\r\ndev_err(info->device, "error requesting regions\n");\r\ngoto err_request_regions;\r\n}\r\ninfo->screen_base = pci_ioremap_bar(dev, 0);\r\nif (!info->screen_base) {\r\ndev_err(info->device, "error remapping base\n");\r\nret = -ENOMEM;\r\ngoto err_ioremap_1;\r\n}\r\npar->regs = pci_ioremap_bar(dev, 1);\r\nif (!par->regs) {\r\ndev_err(info->device, "error remapping MMIO\n");\r\nret = -ENOMEM;\r\ngoto err_ioremap_2;\r\n}\r\nif ((i740inreg(par, XRX, DRAM_ROW_TYPE) & DRAM_ROW_1)\r\n== DRAM_ROW_1_SDRAM)\r\ni740outb(par, XRX, DRAM_ROW_BNDRY_1);\r\nelse\r\ni740outb(par, XRX, DRAM_ROW_BNDRY_0);\r\ninfo->screen_size = i740inb(par, XRX + 1) * 1024 * 1024;\r\ntmp = i740inreg(par, XRX, DRAM_ROW_CNTL_LO);\r\npar->has_sgram = !((tmp & DRAM_RAS_TIMING) ||\r\n(tmp & DRAM_RAS_PRECHARGE));\r\nprintk(KERN_INFO "fb%d: Intel740 on %s, %ld KB %s\n", info->node,\r\npci_name(dev), info->screen_size >> 10,\r\npar->has_sgram ? "SGRAM" : "SDRAM");\r\ninfo->fix = i740fb_fix;\r\ninfo->fix.mmio_start = pci_resource_start(dev, 1);\r\ninfo->fix.mmio_len = pci_resource_len(dev, 1);\r\ninfo->fix.smem_start = pci_resource_start(dev, 0);\r\ninfo->fix.smem_len = info->screen_size;\r\ninfo->flags = FBINFO_DEFAULT | FBINFO_HWACCEL_YPAN;\r\nif (i740fb_setup_ddc_bus(info) == 0) {\r\npar->ddc_registered = true;\r\nedid = fb_ddc_read(&par->ddc_adapter);\r\nif (edid) {\r\nfb_edid_to_monspecs(edid, &info->monspecs);\r\nkfree(edid);\r\nif (!info->monspecs.modedb)\r\ndev_err(info->device,\r\n"error getting mode database\n");\r\nelse {\r\nconst struct fb_videomode *m;\r\nfb_videomode_to_modelist(\r\ninfo->monspecs.modedb,\r\ninfo->monspecs.modedb_len,\r\n&info->modelist);\r\nm = fb_find_best_display(&info->monspecs,\r\n&info->modelist);\r\nif (m) {\r\nfb_videomode_to_var(&info->var, m);\r\nif (!i740fb_check_var(&info->var, info))\r\nfound = true;\r\n}\r\n}\r\n}\r\n}\r\nif (!mode_option && !found)\r\nmode_option = "640x480-8@60";\r\nif (mode_option) {\r\nret = fb_find_mode(&info->var, info, mode_option,\r\ninfo->monspecs.modedb,\r\ninfo->monspecs.modedb_len,\r\nNULL, info->var.bits_per_pixel);\r\nif (!ret || ret == 4) {\r\ndev_err(info->device, "mode %s not found\n",\r\nmode_option);\r\nret = -EINVAL;\r\n}\r\n}\r\nfb_destroy_modedb(info->monspecs.modedb);\r\ninfo->monspecs.modedb = NULL;\r\ninfo->var.yres_virtual = info->fix.smem_len * 8 /\r\n(info->var.bits_per_pixel * info->var.xres_virtual);\r\nif (ret == -EINVAL)\r\ngoto err_find_mode;\r\nret = fb_alloc_cmap(&info->cmap, 256, 0);\r\nif (ret) {\r\ndev_err(info->device, "cannot allocate colormap\n");\r\ngoto err_alloc_cmap;\r\n}\r\nret = register_framebuffer(info);\r\nif (ret) {\r\ndev_err(info->device, "error registering framebuffer\n");\r\ngoto err_reg_framebuffer;\r\n}\r\nprintk(KERN_INFO "fb%d: %s frame buffer device\n",\r\ninfo->node, info->fix.id);\r\npci_set_drvdata(dev, info);\r\n#ifdef CONFIG_MTRR\r\nif (mtrr) {\r\npar->mtrr_reg = -1;\r\npar->mtrr_reg = mtrr_add(info->fix.smem_start,\r\ninfo->fix.smem_len, MTRR_TYPE_WRCOMB, 1);\r\n}\r\n#endif\r\nreturn 0;\r\nerr_reg_framebuffer:\r\nfb_dealloc_cmap(&info->cmap);\r\nerr_alloc_cmap:\r\nerr_find_mode:\r\nif (par->ddc_registered)\r\ni2c_del_adapter(&par->ddc_adapter);\r\npci_iounmap(dev, par->regs);\r\nerr_ioremap_2:\r\npci_iounmap(dev, info->screen_base);\r\nerr_ioremap_1:\r\npci_release_regions(dev);\r\nerr_request_regions:\r\nerr_enable_device:\r\nframebuffer_release(info);\r\nreturn ret;\r\n}\r\nstatic void i740fb_remove(struct pci_dev *dev)\r\n{\r\nstruct fb_info *info = pci_get_drvdata(dev);\r\nif (info) {\r\nstruct i740fb_par *par = info->par;\r\n#ifdef CONFIG_MTRR\r\nif (par->mtrr_reg >= 0) {\r\nmtrr_del(par->mtrr_reg, 0, 0);\r\npar->mtrr_reg = -1;\r\n}\r\n#endif\r\nunregister_framebuffer(info);\r\nfb_dealloc_cmap(&info->cmap);\r\nif (par->ddc_registered)\r\ni2c_del_adapter(&par->ddc_adapter);\r\npci_iounmap(dev, par->regs);\r\npci_iounmap(dev, info->screen_base);\r\npci_release_regions(dev);\r\npci_set_drvdata(dev, NULL);\r\nframebuffer_release(info);\r\n}\r\n}\r\nstatic int i740fb_suspend(struct pci_dev *dev, pm_message_t state)\r\n{\r\nstruct fb_info *info = pci_get_drvdata(dev);\r\nstruct i740fb_par *par = info->par;\r\nif (state.event == PM_EVENT_FREEZE || state.event == PM_EVENT_PRETHAW)\r\nreturn 0;\r\nconsole_lock();\r\nmutex_lock(&(par->open_lock));\r\nif (par->ref_count == 0) {\r\nmutex_unlock(&(par->open_lock));\r\nconsole_unlock();\r\nreturn 0;\r\n}\r\nfb_set_suspend(info, 1);\r\npci_save_state(dev);\r\npci_disable_device(dev);\r\npci_set_power_state(dev, pci_choose_state(dev, state));\r\nmutex_unlock(&(par->open_lock));\r\nconsole_unlock();\r\nreturn 0;\r\n}\r\nstatic int i740fb_resume(struct pci_dev *dev)\r\n{\r\nstruct fb_info *info = pci_get_drvdata(dev);\r\nstruct i740fb_par *par = info->par;\r\nconsole_lock();\r\nmutex_lock(&(par->open_lock));\r\nif (par->ref_count == 0)\r\ngoto fail;\r\npci_set_power_state(dev, PCI_D0);\r\npci_restore_state(dev);\r\nif (pci_enable_device(dev))\r\ngoto fail;\r\ni740fb_set_par(info);\r\nfb_set_suspend(info, 0);\r\nfail:\r\nmutex_unlock(&(par->open_lock));\r\nconsole_unlock();\r\nreturn 0;\r\n}\r\nstatic int __init i740fb_setup(char *options)\r\n{\r\nchar *opt;\r\nif (!options || !*options)\r\nreturn 0;\r\nwhile ((opt = strsep(&options, ",")) != NULL) {\r\nif (!*opt)\r\ncontinue;\r\n#ifdef CONFIG_MTRR\r\nelse if (!strncmp(opt, "mtrr:", 5))\r\nmtrr = simple_strtoul(opt + 5, NULL, 0);\r\n#endif\r\nelse\r\nmode_option = opt;\r\n}\r\nreturn 0;\r\n}\r\nint __init i740fb_init(void)\r\n{\r\n#ifndef MODULE\r\nchar *option = NULL;\r\nif (fb_get_options("i740fb", &option))\r\nreturn -ENODEV;\r\ni740fb_setup(option);\r\n#endif\r\nreturn pci_register_driver(&i740fb_driver);\r\n}\r\nstatic void __exit i740fb_exit(void)\r\n{\r\npci_unregister_driver(&i740fb_driver);\r\n}
