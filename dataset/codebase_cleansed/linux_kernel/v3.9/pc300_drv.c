static void tx_dma_buf_pt_init(pc300_t * card, int ch)\r\n{\r\nint i;\r\nint ch_factor = ch * N_DMA_TX_BUF;\r\nvolatile pcsca_bd_t __iomem *ptdescr = (card->hw.rambase\r\n+ DMA_TX_BD_BASE + ch_factor * sizeof(pcsca_bd_t));\r\nfor (i = 0; i < N_DMA_TX_BUF; i++, ptdescr++) {\r\ncpc_writel(&ptdescr->next, (u32)(DMA_TX_BD_BASE +\r\n(ch_factor + ((i + 1) & (N_DMA_TX_BUF - 1))) * sizeof(pcsca_bd_t)));\r\ncpc_writel(&ptdescr->ptbuf,\r\n(u32)(DMA_TX_BASE + (ch_factor + i) * BD_DEF_LEN));\r\n}\r\n}\r\nstatic void tx_dma_buf_init(pc300_t * card, int ch)\r\n{\r\nint i;\r\nint ch_factor = ch * N_DMA_TX_BUF;\r\nvolatile pcsca_bd_t __iomem *ptdescr = (card->hw.rambase\r\n+ DMA_TX_BD_BASE + ch_factor * sizeof(pcsca_bd_t));\r\nfor (i = 0; i < N_DMA_TX_BUF; i++, ptdescr++) {\r\nmemset_io(ptdescr, 0, sizeof(pcsca_bd_t));\r\ncpc_writew(&ptdescr->len, 0);\r\ncpc_writeb(&ptdescr->status, DST_OSB);\r\n}\r\ntx_dma_buf_pt_init(card, ch);\r\n}\r\nstatic void rx_dma_buf_pt_init(pc300_t * card, int ch)\r\n{\r\nint i;\r\nint ch_factor = ch * N_DMA_RX_BUF;\r\nvolatile pcsca_bd_t __iomem *ptdescr = (card->hw.rambase\r\n+ DMA_RX_BD_BASE + ch_factor * sizeof(pcsca_bd_t));\r\nfor (i = 0; i < N_DMA_RX_BUF; i++, ptdescr++) {\r\ncpc_writel(&ptdescr->next, (u32)(DMA_RX_BD_BASE +\r\n(ch_factor + ((i + 1) & (N_DMA_RX_BUF - 1))) * sizeof(pcsca_bd_t)));\r\ncpc_writel(&ptdescr->ptbuf,\r\n(u32)(DMA_RX_BASE + (ch_factor + i) * BD_DEF_LEN));\r\n}\r\n}\r\nstatic void rx_dma_buf_init(pc300_t * card, int ch)\r\n{\r\nint i;\r\nint ch_factor = ch * N_DMA_RX_BUF;\r\nvolatile pcsca_bd_t __iomem *ptdescr = (card->hw.rambase\r\n+ DMA_RX_BD_BASE + ch_factor * sizeof(pcsca_bd_t));\r\nfor (i = 0; i < N_DMA_RX_BUF; i++, ptdescr++) {\r\nmemset_io(ptdescr, 0, sizeof(pcsca_bd_t));\r\ncpc_writew(&ptdescr->len, 0);\r\ncpc_writeb(&ptdescr->status, 0);\r\n}\r\nrx_dma_buf_pt_init(card, ch);\r\n}\r\nstatic void tx_dma_buf_check(pc300_t * card, int ch)\r\n{\r\nvolatile pcsca_bd_t __iomem *ptdescr;\r\nint i;\r\nu16 first_bd = card->chan[ch].tx_first_bd;\r\nu16 next_bd = card->chan[ch].tx_next_bd;\r\nprintk("#CH%d: f_bd = %d(0x%08zx), n_bd = %d(0x%08zx)\n", ch,\r\nfirst_bd, TX_BD_ADDR(ch, first_bd),\r\nnext_bd, TX_BD_ADDR(ch, next_bd));\r\nfor (i = first_bd,\r\nptdescr = (card->hw.rambase + TX_BD_ADDR(ch, first_bd));\r\ni != ((next_bd + 1) & (N_DMA_TX_BUF - 1));\r\ni = (i + 1) & (N_DMA_TX_BUF - 1),\r\nptdescr = (card->hw.rambase + TX_BD_ADDR(ch, i))) {\r\nprintk("\n CH%d TX%d: next=0x%x, ptbuf=0x%x, ST=0x%x, len=%d",\r\nch, i, cpc_readl(&ptdescr->next),\r\ncpc_readl(&ptdescr->ptbuf),\r\ncpc_readb(&ptdescr->status), cpc_readw(&ptdescr->len));\r\n}\r\nprintk("\n");\r\n}\r\nstatic void tx1_dma_buf_check(pc300_t * card, int ch)\r\n{\r\nvolatile pcsca_bd_t __iomem *ptdescr;\r\nint i;\r\nu16 first_bd = card->chan[ch].tx_first_bd;\r\nu16 next_bd = card->chan[ch].tx_next_bd;\r\nu32 scabase = card->hw.scabase;\r\nprintk ("\nnfree_tx_bd = %d\n", card->chan[ch].nfree_tx_bd);\r\nprintk("#CH%d: f_bd = %d(0x%08x), n_bd = %d(0x%08x)\n", ch,\r\nfirst_bd, TX_BD_ADDR(ch, first_bd),\r\nnext_bd, TX_BD_ADDR(ch, next_bd));\r\nprintk("TX_CDA=0x%08x, TX_EDA=0x%08x\n",\r\ncpc_readl(scabase + DTX_REG(CDAL, ch)),\r\ncpc_readl(scabase + DTX_REG(EDAL, ch)));\r\nfor (i = 0; i < N_DMA_TX_BUF; i++) {\r\nptdescr = (card->hw.rambase + TX_BD_ADDR(ch, i));\r\nprintk("\n CH%d TX%d: next=0x%x, ptbuf=0x%x, ST=0x%x, len=%d",\r\nch, i, cpc_readl(&ptdescr->next),\r\ncpc_readl(&ptdescr->ptbuf),\r\ncpc_readb(&ptdescr->status), cpc_readw(&ptdescr->len));\r\n}\r\nprintk("\n");\r\n}\r\nstatic void rx_dma_buf_check(pc300_t * card, int ch)\r\n{\r\nvolatile pcsca_bd_t __iomem *ptdescr;\r\nint i;\r\nu16 first_bd = card->chan[ch].rx_first_bd;\r\nu16 last_bd = card->chan[ch].rx_last_bd;\r\nint ch_factor;\r\nch_factor = ch * N_DMA_RX_BUF;\r\nprintk("#CH%d: f_bd = %d, l_bd = %d\n", ch, first_bd, last_bd);\r\nfor (i = 0, ptdescr = (card->hw.rambase +\r\nDMA_RX_BD_BASE + ch_factor * sizeof(pcsca_bd_t));\r\ni < N_DMA_RX_BUF; i++, ptdescr++) {\r\nif (cpc_readb(&ptdescr->status) & DST_OSB)\r\nprintk ("\n CH%d RX%d: next=0x%x, ptbuf=0x%x, ST=0x%x, len=%d",\r\nch, i, cpc_readl(&ptdescr->next),\r\ncpc_readl(&ptdescr->ptbuf),\r\ncpc_readb(&ptdescr->status),\r\ncpc_readw(&ptdescr->len));\r\n}\r\nprintk("\n");\r\n}\r\nstatic int dma_get_rx_frame_size(pc300_t * card, int ch)\r\n{\r\nvolatile pcsca_bd_t __iomem *ptdescr;\r\nu16 first_bd = card->chan[ch].rx_first_bd;\r\nint rcvd = 0;\r\nvolatile u8 status;\r\nptdescr = (card->hw.rambase + RX_BD_ADDR(ch, first_bd));\r\nwhile ((status = cpc_readb(&ptdescr->status)) & DST_OSB) {\r\nrcvd += cpc_readw(&ptdescr->len);\r\nfirst_bd = (first_bd + 1) & (N_DMA_RX_BUF - 1);\r\nif ((status & DST_EOM) || (first_bd == card->chan[ch].rx_last_bd)) {\r\nreturn rcvd;\r\n}\r\nptdescr = (card->hw.rambase + cpc_readl(&ptdescr->next));\r\n}\r\nreturn -1;\r\n}\r\nstatic int dma_buf_write(pc300_t *card, int ch, u8 *ptdata, int len)\r\n{\r\nint i, nchar;\r\nvolatile pcsca_bd_t __iomem *ptdescr;\r\nint tosend = len;\r\nu8 nbuf = ((len - 1) / BD_DEF_LEN) + 1;\r\nif (nbuf >= card->chan[ch].nfree_tx_bd) {\r\nreturn -ENOMEM;\r\n}\r\nfor (i = 0; i < nbuf; i++) {\r\nptdescr = (card->hw.rambase +\r\nTX_BD_ADDR(ch, card->chan[ch].tx_next_bd));\r\nnchar = cpc_min(BD_DEF_LEN, tosend);\r\nif (cpc_readb(&ptdescr->status) & DST_OSB) {\r\nmemcpy_toio((card->hw.rambase + cpc_readl(&ptdescr->ptbuf)),\r\n&ptdata[len - tosend], nchar);\r\ncpc_writew(&ptdescr->len, nchar);\r\ncard->chan[ch].nfree_tx_bd--;\r\nif ((i + 1) == nbuf) {\r\ncpc_writeb(&ptdescr->status, DST_EOM);\r\n} else {\r\ncpc_writeb(&ptdescr->status, 0);\r\n}\r\n} else {\r\nreturn -ENOMEM;\r\n}\r\ntosend -= nchar;\r\ncard->chan[ch].tx_next_bd =\r\n(card->chan[ch].tx_next_bd + 1) & (N_DMA_TX_BUF - 1);\r\n}\r\nreturn 0;\r\n}\r\nstatic int dma_buf_read(pc300_t * card, int ch, struct sk_buff *skb)\r\n{\r\nint nchar;\r\npc300ch_t *chan = (pc300ch_t *) & card->chan[ch];\r\nvolatile pcsca_bd_t __iomem *ptdescr;\r\nint rcvd = 0;\r\nvolatile u8 status;\r\nptdescr = (card->hw.rambase +\r\nRX_BD_ADDR(ch, chan->rx_first_bd));\r\nwhile ((status = cpc_readb(&ptdescr->status)) & DST_OSB) {\r\nnchar = cpc_readw(&ptdescr->len);\r\nif ((status & (DST_OVR | DST_CRC | DST_RBIT | DST_SHRT | DST_ABT)) ||\r\n(nchar > BD_DEF_LEN)) {\r\nif (nchar > BD_DEF_LEN)\r\nstatus |= DST_RBIT;\r\nrcvd = -status;\r\nwhile (chan->rx_first_bd != chan->rx_last_bd) {\r\ncpc_writeb(&ptdescr->status, 0);\r\nchan->rx_first_bd = (chan->rx_first_bd+1) & (N_DMA_RX_BUF-1);\r\nif (status & DST_EOM)\r\nbreak;\r\nptdescr = (card->hw.rambase +\r\ncpc_readl(&ptdescr->next));\r\nstatus = cpc_readb(&ptdescr->status);\r\n}\r\nbreak;\r\n}\r\nif (nchar != 0) {\r\nif (skb) {\r\nmemcpy_fromio(skb_put(skb, nchar),\r\n(card->hw.rambase+cpc_readl(&ptdescr->ptbuf)),nchar);\r\n}\r\nrcvd += nchar;\r\n}\r\ncpc_writeb(&ptdescr->status, 0);\r\ncpc_writeb(&ptdescr->len, 0);\r\nchan->rx_first_bd = (chan->rx_first_bd + 1) & (N_DMA_RX_BUF - 1);\r\nif (status & DST_EOM)\r\nbreak;\r\nptdescr = (card->hw.rambase + cpc_readl(&ptdescr->next));\r\n}\r\nif (rcvd != 0) {\r\nchan->rx_last_bd = (chan->rx_first_bd - 1) & (N_DMA_RX_BUF - 1);\r\ncpc_writel(card->hw.scabase + DRX_REG(EDAL, ch),\r\nRX_BD_ADDR(ch, chan->rx_last_bd));\r\n}\r\nreturn rcvd;\r\n}\r\nstatic void tx_dma_stop(pc300_t * card, int ch)\r\n{\r\nvoid __iomem *scabase = card->hw.scabase;\r\nu8 drr_ena_bit = 1 << (5 + 2 * ch);\r\nu8 drr_rst_bit = 1 << (1 + 2 * ch);\r\ncpc_writeb(scabase + DRR, drr_ena_bit);\r\ncpc_writeb(scabase + DRR, drr_rst_bit & ~drr_ena_bit);\r\n}\r\nstatic void rx_dma_stop(pc300_t * card, int ch)\r\n{\r\nvoid __iomem *scabase = card->hw.scabase;\r\nu8 drr_ena_bit = 1 << (4 + 2 * ch);\r\nu8 drr_rst_bit = 1 << (2 * ch);\r\ncpc_writeb(scabase + DRR, drr_ena_bit);\r\ncpc_writeb(scabase + DRR, drr_rst_bit & ~drr_ena_bit);\r\n}\r\nstatic void rx_dma_start(pc300_t * card, int ch)\r\n{\r\nvoid __iomem *scabase = card->hw.scabase;\r\npc300ch_t *chan = (pc300ch_t *) & card->chan[ch];\r\ncpc_writel(scabase + DRX_REG(CDAL, ch),\r\nRX_BD_ADDR(ch, chan->rx_first_bd));\r\nif (cpc_readl(scabase + DRX_REG(CDAL,ch)) !=\r\nRX_BD_ADDR(ch, chan->rx_first_bd)) {\r\ncpc_writel(scabase + DRX_REG(CDAL, ch),\r\nRX_BD_ADDR(ch, chan->rx_first_bd));\r\n}\r\ncpc_writel(scabase + DRX_REG(EDAL, ch),\r\nRX_BD_ADDR(ch, chan->rx_last_bd));\r\ncpc_writew(scabase + DRX_REG(BFLL, ch), BD_DEF_LEN);\r\ncpc_writeb(scabase + DSR_RX(ch), DSR_DE);\r\nif (!(cpc_readb(scabase + DSR_RX(ch)) & DSR_DE)) {\r\ncpc_writeb(scabase + DSR_RX(ch), DSR_DE);\r\n}\r\n}\r\nstatic void falc_issue_cmd(pc300_t *card, int ch, u8 cmd)\r\n{\r\nvoid __iomem *falcbase = card->hw.falcbase;\r\nunsigned long i = 0;\r\nwhile (cpc_readb(falcbase + F_REG(SIS, ch)) & SIS_CEC) {\r\nif (i++ >= PC300_FALC_MAXLOOP) {\r\nprintk("%s: FALC command locked(cmd=0x%x).\n",\r\ncard->chan[ch].d.name, cmd);\r\nbreak;\r\n}\r\n}\r\ncpc_writeb(falcbase + F_REG(CMDR, ch), cmd);\r\n}\r\nstatic void falc_intr_enable(pc300_t * card, int ch)\r\n{\r\npc300ch_t *chan = (pc300ch_t *) & card->chan[ch];\r\npc300chconf_t *conf = (pc300chconf_t *) & chan->conf;\r\nfalc_t *pfalc = (falc_t *) & chan->falc;\r\nvoid __iomem *falcbase = card->hw.falcbase;\r\ncpc_writeb(falcbase + F_REG(IPC, ch),\r\ncpc_readb(falcbase + F_REG(IPC, ch)) & ~IPC_IC0);\r\ncpc_writeb(falcbase + F_REG(FMR1, ch),\r\ncpc_readb(falcbase + F_REG(FMR1, ch)) | FMR1_ECM);\r\ncpc_writeb(falcbase + F_REG(IMR3, ch),\r\ncpc_readb(falcbase + F_REG(IMR3, ch)) & ~(IMR3_SEC | IMR3_ES));\r\nif (conf->fr_mode == PC300_FR_UNFRAMED) {\r\ncpc_writeb(falcbase + F_REG(IMR4, ch),\r\ncpc_readb(falcbase + F_REG(IMR4, ch)) & ~(IMR4_LOS));\r\n} else {\r\ncpc_writeb(falcbase + F_REG(IMR4, ch),\r\ncpc_readb(falcbase + F_REG(IMR4, ch)) &\r\n~(IMR4_LFA | IMR4_AIS | IMR4_LOS | IMR4_SLIP));\r\n}\r\nif (conf->media == IF_IFACE_T1) {\r\ncpc_writeb(falcbase + F_REG(IMR3, ch),\r\ncpc_readb(falcbase + F_REG(IMR3, ch)) & ~IMR3_LLBSC);\r\n} else {\r\ncpc_writeb(falcbase + F_REG(IPC, ch),\r\ncpc_readb(falcbase + F_REG(IPC, ch)) | IPC_SCI);\r\nif (conf->fr_mode == PC300_FR_UNFRAMED) {\r\ncpc_writeb(falcbase + F_REG(IMR2, ch),\r\ncpc_readb(falcbase + F_REG(IMR2, ch)) & ~(IMR2_LOS));\r\n} else {\r\ncpc_writeb(falcbase + F_REG(IMR2, ch),\r\ncpc_readb(falcbase + F_REG(IMR2, ch)) &\r\n~(IMR2_FAR | IMR2_LFA | IMR2_AIS | IMR2_LOS));\r\nif (pfalc->multiframe_mode) {\r\ncpc_writeb(falcbase + F_REG(IMR2, ch),\r\ncpc_readb(falcbase + F_REG(IMR2, ch)) &\r\n~(IMR2_T400MS | IMR2_MFAR));\r\n} else {\r\ncpc_writeb(falcbase + F_REG(IMR2, ch),\r\ncpc_readb(falcbase + F_REG(IMR2, ch)) |\r\nIMR2_T400MS | IMR2_MFAR);\r\n}\r\n}\r\n}\r\n}\r\nstatic void falc_open_timeslot(pc300_t * card, int ch, int timeslot)\r\n{\r\nvoid __iomem *falcbase = card->hw.falcbase;\r\nu8 tshf = card->chan[ch].falc.offset;\r\ncpc_writeb(falcbase + F_REG((ICB1 + (timeslot - tshf) / 8), ch),\r\ncpc_readb(falcbase + F_REG((ICB1 + (timeslot - tshf) / 8), ch)) &\r\n~(0x80 >> ((timeslot - tshf) & 0x07)));\r\ncpc_writeb(falcbase + F_REG((TTR1 + timeslot / 8), ch),\r\ncpc_readb(falcbase + F_REG((TTR1 + timeslot / 8), ch)) |\r\n(0x80 >> (timeslot & 0x07)));\r\ncpc_writeb(falcbase + F_REG((RTR1 + timeslot / 8), ch),\r\ncpc_readb(falcbase + F_REG((RTR1 + timeslot / 8), ch)) |\r\n(0x80 >> (timeslot & 0x07)));\r\n}\r\nstatic void falc_close_timeslot(pc300_t * card, int ch, int timeslot)\r\n{\r\nvoid __iomem *falcbase = card->hw.falcbase;\r\nu8 tshf = card->chan[ch].falc.offset;\r\ncpc_writeb(falcbase + F_REG((ICB1 + (timeslot - tshf) / 8), ch),\r\ncpc_readb(falcbase + F_REG((ICB1 + (timeslot - tshf) / 8), ch)) |\r\n(0x80 >> ((timeslot - tshf) & 0x07)));\r\ncpc_writeb(falcbase + F_REG((TTR1 + timeslot / 8), ch),\r\ncpc_readb(falcbase + F_REG((TTR1 + timeslot / 8), ch)) &\r\n~(0x80 >> (timeslot & 0x07)));\r\ncpc_writeb(falcbase + F_REG((RTR1 + timeslot / 8), ch),\r\ncpc_readb(falcbase + F_REG((RTR1 + timeslot / 8), ch)) &\r\n~(0x80 >> (timeslot & 0x07)));\r\n}\r\nstatic void falc_close_all_timeslots(pc300_t * card, int ch)\r\n{\r\npc300ch_t *chan = (pc300ch_t *) & card->chan[ch];\r\npc300chconf_t *conf = (pc300chconf_t *) & chan->conf;\r\nvoid __iomem *falcbase = card->hw.falcbase;\r\ncpc_writeb(falcbase + F_REG(ICB1, ch), 0xff);\r\ncpc_writeb(falcbase + F_REG(TTR1, ch), 0);\r\ncpc_writeb(falcbase + F_REG(RTR1, ch), 0);\r\ncpc_writeb(falcbase + F_REG(ICB2, ch), 0xff);\r\ncpc_writeb(falcbase + F_REG(TTR2, ch), 0);\r\ncpc_writeb(falcbase + F_REG(RTR2, ch), 0);\r\ncpc_writeb(falcbase + F_REG(ICB3, ch), 0xff);\r\ncpc_writeb(falcbase + F_REG(TTR3, ch), 0);\r\ncpc_writeb(falcbase + F_REG(RTR3, ch), 0);\r\nif (conf->media == IF_IFACE_E1) {\r\ncpc_writeb(falcbase + F_REG(ICB4, ch), 0xff);\r\ncpc_writeb(falcbase + F_REG(TTR4, ch), 0);\r\ncpc_writeb(falcbase + F_REG(RTR4, ch), 0);\r\n}\r\n}\r\nstatic void falc_open_all_timeslots(pc300_t * card, int ch)\r\n{\r\npc300ch_t *chan = (pc300ch_t *) & card->chan[ch];\r\npc300chconf_t *conf = (pc300chconf_t *) & chan->conf;\r\nvoid __iomem *falcbase = card->hw.falcbase;\r\ncpc_writeb(falcbase + F_REG(ICB1, ch), 0);\r\nif (conf->fr_mode == PC300_FR_UNFRAMED) {\r\ncpc_writeb(falcbase + F_REG(TTR1, ch), 0xff);\r\ncpc_writeb(falcbase + F_REG(RTR1, ch), 0xff);\r\n} else {\r\ncpc_writeb(falcbase + F_REG(TTR1, ch), 0x7f);\r\ncpc_writeb(falcbase + F_REG(RTR1, ch), 0x7f);\r\n}\r\ncpc_writeb(falcbase + F_REG(ICB2, ch), 0);\r\ncpc_writeb(falcbase + F_REG(TTR2, ch), 0xff);\r\ncpc_writeb(falcbase + F_REG(RTR2, ch), 0xff);\r\ncpc_writeb(falcbase + F_REG(ICB3, ch), 0);\r\ncpc_writeb(falcbase + F_REG(TTR3, ch), 0xff);\r\ncpc_writeb(falcbase + F_REG(RTR3, ch), 0xff);\r\nif (conf->media == IF_IFACE_E1) {\r\ncpc_writeb(falcbase + F_REG(ICB4, ch), 0);\r\ncpc_writeb(falcbase + F_REG(TTR4, ch), 0xff);\r\ncpc_writeb(falcbase + F_REG(RTR4, ch), 0xff);\r\n} else {\r\ncpc_writeb(falcbase + F_REG(ICB4, ch), 0xff);\r\ncpc_writeb(falcbase + F_REG(TTR4, ch), 0x80);\r\ncpc_writeb(falcbase + F_REG(RTR4, ch), 0x80);\r\n}\r\n}\r\nstatic void falc_init_timeslot(pc300_t * card, int ch)\r\n{\r\npc300ch_t *chan = (pc300ch_t *) & card->chan[ch];\r\npc300chconf_t *conf = (pc300chconf_t *) & chan->conf;\r\nfalc_t *pfalc = (falc_t *) & chan->falc;\r\nint tslot;\r\nfor (tslot = 0; tslot < pfalc->num_channels; tslot++) {\r\nif (conf->tslot_bitmap & (1 << tslot)) {\r\nfalc_open_timeslot(card, ch, tslot + 1);\r\n} else {\r\nfalc_close_timeslot(card, ch, tslot + 1);\r\n}\r\n}\r\n}\r\nstatic void falc_enable_comm(pc300_t * card, int ch)\r\n{\r\npc300ch_t *chan = (pc300ch_t *) & card->chan[ch];\r\nfalc_t *pfalc = (falc_t *) & chan->falc;\r\nif (pfalc->full_bandwidth) {\r\nfalc_open_all_timeslots(card, ch);\r\n} else {\r\nfalc_init_timeslot(card, ch);\r\n}\r\ncpc_writeb(card->hw.falcbase + card->hw.cpld_reg1,\r\ncpc_readb(card->hw.falcbase + card->hw.cpld_reg1) &\r\n~((CPLD_REG1_FALC_DCD | CPLD_REG1_FALC_CTS) << (2 * ch)));\r\n}\r\nstatic void falc_disable_comm(pc300_t * card, int ch)\r\n{\r\npc300ch_t *chan = (pc300ch_t *) & card->chan[ch];\r\nfalc_t *pfalc = (falc_t *) & chan->falc;\r\nif (pfalc->loop_active != 2) {\r\nfalc_close_all_timeslots(card, ch);\r\n}\r\ncpc_writeb(card->hw.falcbase + card->hw.cpld_reg1,\r\ncpc_readb(card->hw.falcbase + card->hw.cpld_reg1) |\r\n((CPLD_REG1_FALC_DCD | CPLD_REG1_FALC_CTS) << (2 * ch)));\r\n}\r\nstatic void falc_init_t1(pc300_t * card, int ch)\r\n{\r\npc300ch_t *chan = (pc300ch_t *) & card->chan[ch];\r\npc300chconf_t *conf = (pc300chconf_t *) & chan->conf;\r\nfalc_t *pfalc = (falc_t *) & chan->falc;\r\nvoid __iomem *falcbase = card->hw.falcbase;\r\nu8 dja = (ch ? (LIM2_DJA2 | LIM2_DJA1) : 0);\r\ncpc_writeb(falcbase + F_REG(FMR1, ch), FMR1_PMOD);\r\nudelay(20);\r\ncpc_writeb(falcbase + F_REG(SIC1, ch), SIC1_XBS0);\r\nif (conf->phys_settings.clock_type == CLOCK_INT) {\r\ncpc_writeb(falcbase + F_REG(LIM0, ch),\r\ncpc_readb(falcbase + F_REG(LIM0, ch)) | LIM0_MAS);\r\n} else {\r\ncpc_writeb(falcbase + F_REG(LIM0, ch),\r\ncpc_readb(falcbase + F_REG(LIM0, ch)) & ~LIM0_MAS);\r\ncpc_writeb(falcbase + F_REG(LOOP, ch),\r\ncpc_readb(falcbase + F_REG(LOOP, ch)) & ~LOOP_RTM);\r\n}\r\ncpc_writeb(falcbase + F_REG(IPC, ch), IPC_SCI);\r\ncpc_writeb(falcbase + F_REG(FMR0, ch),\r\ncpc_readb(falcbase + F_REG(FMR0, ch)) &\r\n~(FMR0_XC0 | FMR0_XC1 | FMR0_RC0 | FMR0_RC1));\r\nswitch (conf->lcode) {\r\ncase PC300_LC_AMI:\r\ncpc_writeb(falcbase + F_REG(FMR0, ch),\r\ncpc_readb(falcbase + F_REG(FMR0, ch)) |\r\nFMR0_XC1 | FMR0_RC1);\r\ncpc_writeb(falcbase + F_REG(CCB1, ch), 0xff);\r\ncpc_writeb(falcbase + F_REG(CCB2, ch), 0xff);\r\ncpc_writeb(falcbase + F_REG(CCB3, ch), 0xff);\r\nbreak;\r\ncase PC300_LC_B8ZS:\r\ncpc_writeb(falcbase + F_REG(FMR0, ch),\r\ncpc_readb(falcbase + F_REG(FMR0, ch)) |\r\nFMR0_XC0 | FMR0_XC1 | FMR0_RC0 | FMR0_RC1);\r\nbreak;\r\ncase PC300_LC_NRZ:\r\ncpc_writeb(falcbase + F_REG(FMR0, ch),\r\ncpc_readb(falcbase + F_REG(FMR0, ch)) | 0x00);\r\nbreak;\r\n}\r\ncpc_writeb(falcbase + F_REG(LIM0, ch),\r\ncpc_readb(falcbase + F_REG(LIM0, ch)) | LIM0_ELOS);\r\ncpc_writeb(falcbase + F_REG(LIM0, ch),\r\ncpc_readb(falcbase + F_REG(LIM0, ch)) & ~(LIM0_SCL1 | LIM0_SCL0));\r\ncpc_writeb(falcbase + F_REG(FMR1, ch),\r\ncpc_readb(falcbase + F_REG(FMR1, ch)) | FMR1_IMOD);\r\nswitch (conf->fr_mode) {\r\ncase PC300_FR_ESF:\r\npfalc->multiframe_mode = 0;\r\ncpc_writeb(falcbase + F_REG(FMR4, ch),\r\ncpc_readb(falcbase + F_REG(FMR4, ch)) | FMR4_FM1);\r\ncpc_writeb(falcbase + F_REG(FMR1, ch),\r\ncpc_readb(falcbase + F_REG(FMR1, ch)) |\r\nFMR1_CRC | FMR1_EDL);\r\ncpc_writeb(falcbase + F_REG(XDL1, ch), 0);\r\ncpc_writeb(falcbase + F_REG(XDL2, ch), 0);\r\ncpc_writeb(falcbase + F_REG(XDL3, ch), 0);\r\ncpc_writeb(falcbase + F_REG(FMR0, ch),\r\ncpc_readb(falcbase + F_REG(FMR0, ch)) & ~FMR0_SRAF);\r\ncpc_writeb(falcbase + F_REG(FMR2, ch),\r\ncpc_readb(falcbase + F_REG(FMR2,ch)) | FMR2_MCSP | FMR2_SSP);\r\nbreak;\r\ncase PC300_FR_D4:\r\npfalc->multiframe_mode = 1;\r\ncpc_writeb(falcbase + F_REG(FMR4, ch),\r\ncpc_readb(falcbase + F_REG(FMR4, ch)) &\r\n~(FMR4_FM1 | FMR4_FM0));\r\ncpc_writeb(falcbase + F_REG(FMR0, ch),\r\ncpc_readb(falcbase + F_REG(FMR0, ch)) | FMR0_SRAF);\r\ncpc_writeb(falcbase + F_REG(FMR2, ch),\r\ncpc_readb(falcbase + F_REG(FMR2, ch)) & ~FMR2_SSP);\r\nbreak;\r\n}\r\ncpc_writeb(falcbase + F_REG(FMR4, ch),\r\ncpc_readb(falcbase + F_REG(FMR4, ch)) | FMR4_AUTO);\r\ncpc_writeb(falcbase + F_REG(FMR2, ch),\r\ncpc_readb(falcbase + F_REG(FMR2, ch)) | FMR2_AXRA);\r\ncpc_writeb(falcbase + F_REG(FMR1, ch),\r\ncpc_readb(falcbase + F_REG(FMR1, ch)) | FMR1_CTM);\r\ncpc_writeb(falcbase + F_REG(FMR1, ch),\r\ncpc_readb(falcbase + F_REG(FMR1, ch)) & ~FMR1_SIGM);\r\ncpc_writeb(falcbase + F_REG(FMR5, ch),\r\ncpc_readb(falcbase + F_REG(FMR5, ch)) &\r\n~(FMR5_EIBR | FMR5_SRS));\r\ncpc_writeb(falcbase + F_REG(CCR1, ch), 0);\r\ncpc_writeb(falcbase + F_REG(LIM1, ch),\r\ncpc_readb(falcbase + F_REG(LIM1, ch)) | LIM1_RIL0 | LIM1_RIL1);\r\nswitch (conf->lbo) {\r\ncase PC300_LBO_0_DB:\r\ncpc_writeb(falcbase + F_REG(LIM2, ch), (LIM2_LOS1 | dja));\r\ncpc_writeb(falcbase + F_REG(XPM0, ch), 0x5a);\r\ncpc_writeb(falcbase + F_REG(XPM1, ch), 0x8f);\r\ncpc_writeb(falcbase + F_REG(XPM2, ch), 0x20);\r\nbreak;\r\ncase PC300_LBO_7_5_DB:\r\ncpc_writeb(falcbase + F_REG(LIM2, ch), (0x40 | LIM2_LOS1 | dja));\r\ncpc_writeb(falcbase + F_REG(XPM0, ch), 0x11);\r\ncpc_writeb(falcbase + F_REG(XPM1, ch), 0x02);\r\ncpc_writeb(falcbase + F_REG(XPM2, ch), 0x20);\r\nbreak;\r\ncase PC300_LBO_15_DB:\r\ncpc_writeb(falcbase + F_REG(LIM2, ch), (0x80 | LIM2_LOS1 | dja));\r\ncpc_writeb(falcbase + F_REG(XPM0, ch), 0x8e);\r\ncpc_writeb(falcbase + F_REG(XPM1, ch), 0x01);\r\ncpc_writeb(falcbase + F_REG(XPM2, ch), 0x20);\r\nbreak;\r\ncase PC300_LBO_22_5_DB:\r\ncpc_writeb(falcbase + F_REG(LIM2, ch), (0xc0 | LIM2_LOS1 | dja));\r\ncpc_writeb(falcbase + F_REG(XPM0, ch), 0x09);\r\ncpc_writeb(falcbase + F_REG(XPM1, ch), 0x01);\r\ncpc_writeb(falcbase + F_REG(XPM2, ch), 0x20);\r\nbreak;\r\n}\r\ncpc_writeb(falcbase + F_REG(XC0, ch),\r\ncpc_readb(falcbase + F_REG(XC0, ch)) | 0x01);\r\ncpc_writeb(falcbase + F_REG(XC1, ch), 0x3e);\r\ncpc_writeb(falcbase + F_REG(RC0, ch), 0x05);\r\ncpc_writeb(falcbase + F_REG(RC1, ch), 0x00);\r\ncpc_writeb(falcbase + F_REG(PCDR, ch), 0x0a);\r\ncpc_writeb(falcbase + F_REG(PCRR, ch), 0x15);\r\ncpc_writeb(falcbase + F_REG(IDLE, ch), 0x7f);\r\nif (conf->fr_mode == PC300_FR_ESF_JAPAN) {\r\ncpc_writeb(falcbase + F_REG(RC1, ch),\r\ncpc_readb(falcbase + F_REG(RC1, ch)) | 0x80);\r\n}\r\nfalc_close_all_timeslots(card, ch);\r\n}\r\nstatic void falc_init_e1(pc300_t * card, int ch)\r\n{\r\npc300ch_t *chan = (pc300ch_t *) & card->chan[ch];\r\npc300chconf_t *conf = (pc300chconf_t *) & chan->conf;\r\nfalc_t *pfalc = (falc_t *) & chan->falc;\r\nvoid __iomem *falcbase = card->hw.falcbase;\r\nu8 dja = (ch ? (LIM2_DJA2 | LIM2_DJA1) : 0);\r\ncpc_writeb(falcbase + F_REG(FMR1, ch),\r\ncpc_readb(falcbase + F_REG(FMR1, ch)) & ~FMR1_PMOD);\r\nif (conf->phys_settings.clock_type == CLOCK_INT) {\r\ncpc_writeb(falcbase + F_REG(LIM0, ch),\r\ncpc_readb(falcbase + F_REG(LIM0, ch)) | LIM0_MAS);\r\n} else {\r\ncpc_writeb(falcbase + F_REG(LIM0, ch),\r\ncpc_readb(falcbase + F_REG(LIM0, ch)) & ~LIM0_MAS);\r\n}\r\ncpc_writeb(falcbase + F_REG(LOOP, ch),\r\ncpc_readb(falcbase + F_REG(LOOP, ch)) & ~LOOP_SFM);\r\ncpc_writeb(falcbase + F_REG(IPC, ch), IPC_SCI);\r\ncpc_writeb(falcbase + F_REG(FMR0, ch),\r\ncpc_readb(falcbase + F_REG(FMR0, ch)) &\r\n~(FMR0_XC0 | FMR0_XC1 | FMR0_RC0 | FMR0_RC1));\r\nswitch (conf->lcode) {\r\ncase PC300_LC_AMI:\r\ncpc_writeb(falcbase + F_REG(FMR0, ch),\r\ncpc_readb(falcbase + F_REG(FMR0, ch)) |\r\nFMR0_XC1 | FMR0_RC1);\r\nbreak;\r\ncase PC300_LC_HDB3:\r\ncpc_writeb(falcbase + F_REG(FMR0, ch),\r\ncpc_readb(falcbase + F_REG(FMR0, ch)) |\r\nFMR0_XC0 | FMR0_XC1 | FMR0_RC0 | FMR0_RC1);\r\nbreak;\r\ncase PC300_LC_NRZ:\r\nbreak;\r\n}\r\ncpc_writeb(falcbase + F_REG(LIM0, ch),\r\ncpc_readb(falcbase + F_REG(LIM0, ch)) & ~(LIM0_SCL1 | LIM0_SCL0));\r\ncpc_writeb(falcbase + F_REG(FMR1, ch),\r\ncpc_readb(falcbase + F_REG(FMR1, ch)) | FMR1_IMOD);\r\ncpc_writeb(falcbase + F_REG(XPM0, ch), 0x18);\r\ncpc_writeb(falcbase + F_REG(XPM1, ch), 0x03);\r\ncpc_writeb(falcbase + F_REG(XPM2, ch), 0x00);\r\nswitch (conf->fr_mode) {\r\ncase PC300_FR_MF_CRC4:\r\npfalc->multiframe_mode = 1;\r\ncpc_writeb(falcbase + F_REG(FMR1, ch),\r\ncpc_readb(falcbase + F_REG(FMR1, ch)) | FMR1_XFS);\r\ncpc_writeb(falcbase + F_REG(FMR2, ch),\r\ncpc_readb(falcbase + F_REG(FMR2, ch)) | FMR2_RFS1);\r\ncpc_writeb(falcbase + F_REG(FMR2, ch),\r\ncpc_readb(falcbase + F_REG(FMR2, ch)) & ~FMR2_RFS0);\r\ncpc_writeb(falcbase + F_REG(FMR3, ch),\r\ncpc_readb(falcbase + F_REG(FMR3, ch)) & ~FMR3_EXTIW);\r\ncpc_writeb(falcbase + F_REG(FMR1, ch),\r\ncpc_readb(falcbase + F_REG(FMR1, ch)) | FMR1_MFCS);\r\ncpc_writeb(falcbase + F_REG(FMR2, ch),\r\ncpc_readb(falcbase + F_REG(FMR2, ch)) | FMR2_ALMF);\r\ncpc_writeb(falcbase + F_REG(XSP, ch),\r\ncpc_readb(falcbase + F_REG(XSP, ch)) & ~XSP_AXS);\r\ncpc_writeb(falcbase + F_REG(XSP, ch),\r\ncpc_readb(falcbase + F_REG(XSP, ch)) | XSP_EBP);\r\ncpc_writeb(falcbase + F_REG(XSP, ch),\r\ncpc_readb(falcbase + F_REG(XSP, ch)) | XSP_XS13 | XSP_XS15);\r\ncpc_writeb(falcbase + F_REG(FMR1, ch),\r\ncpc_readb(falcbase + F_REG(FMR1, ch)) | FMR1_AFR);\r\ncpc_writeb(falcbase + F_REG(FMR2, ch),\r\ncpc_readb(falcbase + F_REG(FMR2, ch)) | FMR2_AXRA);\r\ncpc_writeb(falcbase + F_REG(XSW, ch),\r\ncpc_readb(falcbase + F_REG(XSW, ch)) |\r\nXSW_XY0 | XSW_XY1 | XSW_XY2 | XSW_XY3 | XSW_XY4);\r\nbreak;\r\ncase PC300_FR_MF_NON_CRC4:\r\ncase PC300_FR_D4:\r\npfalc->multiframe_mode = 0;\r\ncpc_writeb(falcbase + F_REG(FMR1, ch),\r\ncpc_readb(falcbase + F_REG(FMR1, ch)) & ~FMR1_XFS);\r\ncpc_writeb(falcbase + F_REG(FMR2, ch),\r\ncpc_readb(falcbase + F_REG(FMR2, ch)) &\r\n~(FMR2_RFS1 | FMR2_RFS0));\r\ncpc_writeb(falcbase + F_REG(XSW, ch),\r\ncpc_readb(falcbase + F_REG(XSW, ch)) | XSW_XSIS);\r\ncpc_writeb(falcbase + F_REG(XSP, ch),\r\ncpc_readb(falcbase + F_REG(XSP, ch)) | XSP_XSIF);\r\ncpc_writeb(falcbase + F_REG(FMR1, ch),\r\ncpc_readb(falcbase + F_REG(FMR1, ch)) | FMR1_AFR);\r\ncpc_writeb(falcbase + F_REG(FMR2, ch),\r\ncpc_readb(falcbase + F_REG(FMR2, ch)) | FMR2_AXRA);\r\ncpc_writeb(falcbase + F_REG(XSW, ch),\r\ncpc_readb(falcbase + F_REG(XSW, ch)) |\r\nXSW_XY0 | XSW_XY1 | XSW_XY2 | XSW_XY3 | XSW_XY4);\r\nbreak;\r\ncase PC300_FR_UNFRAMED:\r\npfalc->multiframe_mode = 0;\r\ncpc_writeb(falcbase + F_REG(FMR1, ch),\r\ncpc_readb(falcbase + F_REG(FMR1, ch)) & ~FMR1_XFS);\r\ncpc_writeb(falcbase + F_REG(FMR2, ch),\r\ncpc_readb(falcbase + F_REG(FMR2, ch)) &\r\n~(FMR2_RFS1 | FMR2_RFS0));\r\ncpc_writeb(falcbase + F_REG(XSP, ch),\r\ncpc_readb(falcbase + F_REG(XSP, ch)) | XSP_TT0);\r\ncpc_writeb(falcbase + F_REG(XSW, ch),\r\ncpc_readb(falcbase + F_REG(XSW, ch)) &\r\n~(XSW_XTM|XSW_XY0|XSW_XY1|XSW_XY2|XSW_XY3|XSW_XY4));\r\ncpc_writeb(falcbase + F_REG(TSWM, ch), 0xff);\r\ncpc_writeb(falcbase + F_REG(FMR2, ch),\r\ncpc_readb(falcbase + F_REG(FMR2, ch)) |\r\n(FMR2_RTM | FMR2_DAIS));\r\ncpc_writeb(falcbase + F_REG(FMR2, ch),\r\ncpc_readb(falcbase + F_REG(FMR2, ch)) & ~FMR2_AXRA);\r\ncpc_writeb(falcbase + F_REG(FMR1, ch),\r\ncpc_readb(falcbase + F_REG(FMR1, ch)) & ~FMR1_AFR);\r\npfalc->sync = 1;\r\ncpc_writeb(falcbase + card->hw.cpld_reg2,\r\ncpc_readb(falcbase + card->hw.cpld_reg2) |\r\n(CPLD_REG2_FALC_LED2 << (2 * ch)));\r\nbreak;\r\n}\r\ncpc_writeb(falcbase + F_REG(XSP, ch),\r\ncpc_readb(falcbase + F_REG(XSP, ch)) & ~XSP_CASEN);\r\ncpc_writeb(falcbase + F_REG(CCR1, ch), 0);\r\ncpc_writeb(falcbase + F_REG(LIM1, ch),\r\ncpc_readb(falcbase + F_REG(LIM1, ch)) | LIM1_RIL0 | LIM1_RIL1);\r\ncpc_writeb(falcbase + F_REG(LIM2, ch), (LIM2_LOS1 | dja));\r\ncpc_writeb(falcbase + F_REG(XC0, ch),\r\ncpc_readb(falcbase + F_REG(XC0, ch)) | 0x01);\r\ncpc_writeb(falcbase + F_REG(XC1, ch), 0x3e);\r\ncpc_writeb(falcbase + F_REG(RC0, ch), 0x05);\r\ncpc_writeb(falcbase + F_REG(RC1, ch), 0x00);\r\ncpc_writeb(falcbase + F_REG(PCDR, ch), 0x0a);\r\ncpc_writeb(falcbase + F_REG(PCRR, ch), 0x15);\r\ncpc_writeb(falcbase + F_REG(IDLE, ch), 0x7f);\r\nfalc_close_all_timeslots(card, ch);\r\n}\r\nstatic void falc_init_hdlc(pc300_t * card, int ch)\r\n{\r\nvoid __iomem *falcbase = card->hw.falcbase;\r\npc300ch_t *chan = (pc300ch_t *) & card->chan[ch];\r\npc300chconf_t *conf = (pc300chconf_t *) & chan->conf;\r\nif (conf->fr_mode == PC300_FR_UNFRAMED) {\r\ncpc_writeb(falcbase + F_REG(MODE, ch), 0);\r\n} else {\r\ncpc_writeb(falcbase + F_REG(MODE, ch),\r\ncpc_readb(falcbase + F_REG(MODE, ch)) |\r\n(MODE_HRAC | MODE_MDS2));\r\ncpc_writeb(falcbase + F_REG(RAH2, ch), 0xff);\r\ncpc_writeb(falcbase + F_REG(RAH1, ch), 0xff);\r\ncpc_writeb(falcbase + F_REG(RAL2, ch), 0xff);\r\ncpc_writeb(falcbase + F_REG(RAL1, ch), 0xff);\r\n}\r\nfalc_issue_cmd(card, ch, CMDR_RRES | CMDR_XRES | CMDR_SRES);\r\nfalc_intr_enable(card, ch);\r\n}\r\nstatic void te_config(pc300_t * card, int ch)\r\n{\r\npc300ch_t *chan = (pc300ch_t *) & card->chan[ch];\r\npc300chconf_t *conf = (pc300chconf_t *) & chan->conf;\r\nfalc_t *pfalc = (falc_t *) & chan->falc;\r\nvoid __iomem *falcbase = card->hw.falcbase;\r\nu8 dummy;\r\nunsigned long flags;\r\nmemset(pfalc, 0, sizeof(falc_t));\r\nswitch (conf->media) {\r\ncase IF_IFACE_T1:\r\npfalc->num_channels = NUM_OF_T1_CHANNELS;\r\npfalc->offset = 1;\r\nbreak;\r\ncase IF_IFACE_E1:\r\npfalc->num_channels = NUM_OF_E1_CHANNELS;\r\npfalc->offset = 0;\r\nbreak;\r\n}\r\nif (conf->tslot_bitmap == 0xffffffffUL)\r\npfalc->full_bandwidth = 1;\r\nelse\r\npfalc->full_bandwidth = 0;\r\nCPC_LOCK(card, flags);\r\ncpc_writeb(card->hw.falcbase + card->hw.cpld_reg1,\r\ncpc_readb(card->hw.falcbase + card->hw.cpld_reg1) |\r\n(CPLD_REG1_FALC_RESET << (2 * ch)));\r\nudelay(10000);\r\ncpc_writeb(card->hw.falcbase + card->hw.cpld_reg1,\r\ncpc_readb(card->hw.falcbase + card->hw.cpld_reg1) &\r\n~(CPLD_REG1_FALC_RESET << (2 * ch)));\r\nif (conf->media == IF_IFACE_T1) {\r\nfalc_init_t1(card, ch);\r\n} else {\r\nfalc_init_e1(card, ch);\r\n}\r\nfalc_init_hdlc(card, ch);\r\nif (conf->rx_sens == PC300_RX_SENS_SH) {\r\ncpc_writeb(falcbase + F_REG(LIM0, ch),\r\ncpc_readb(falcbase + F_REG(LIM0, ch)) & ~LIM0_EQON);\r\n} else {\r\ncpc_writeb(falcbase + F_REG(LIM0, ch),\r\ncpc_readb(falcbase + F_REG(LIM0, ch)) | LIM0_EQON);\r\n}\r\ncpc_writeb(card->hw.falcbase + card->hw.cpld_reg2,\r\ncpc_readb(card->hw.falcbase + card->hw.cpld_reg2) |\r\n((CPLD_REG2_FALC_TX_CLK | CPLD_REG2_FALC_RX_CLK) << (2 * ch)));\r\ndummy = cpc_readb(falcbase + F_REG(FISR0, ch)) +\r\ncpc_readb(falcbase + F_REG(FISR1, ch)) +\r\ncpc_readb(falcbase + F_REG(FISR2, ch)) +\r\ncpc_readb(falcbase + F_REG(FISR3, ch));\r\nCPC_UNLOCK(card, flags);\r\n}\r\nstatic void falc_check_status(pc300_t * card, int ch, unsigned char frs0)\r\n{\r\npc300ch_t *chan = (pc300ch_t *) & card->chan[ch];\r\npc300chconf_t *conf = (pc300chconf_t *) & chan->conf;\r\nfalc_t *pfalc = (falc_t *) & chan->falc;\r\nvoid __iomem *falcbase = card->hw.falcbase;\r\nif (frs0 & FRS0_LOS) {\r\nif (!pfalc->red_alarm) {\r\npfalc->red_alarm = 1;\r\npfalc->los++;\r\nif (!pfalc->blue_alarm) {\r\nif (conf->media == IF_IFACE_T1) {\r\ncpc_writeb(falcbase + F_REG(IMR0, ch),\r\ncpc_readb(falcbase + F_REG(IMR0, ch))\r\n| IMR0_PDEN);\r\n}\r\nfalc_disable_comm(card, ch);\r\n}\r\n}\r\n} else {\r\nif (pfalc->red_alarm) {\r\npfalc->red_alarm = 0;\r\npfalc->losr++;\r\n}\r\n}\r\nif (conf->fr_mode != PC300_FR_UNFRAMED) {\r\nif (frs0 & FRS0_AIS) {\r\nif (!pfalc->blue_alarm) {\r\npfalc->blue_alarm = 1;\r\npfalc->ais++;\r\nif (conf->media == IF_IFACE_T1) {\r\ncpc_writeb(falcbase + F_REG(IMR0, ch),\r\ncpc_readb(falcbase + F_REG(IMR0, ch)) | IMR0_PDEN);\r\n}\r\nfalc_disable_comm(card, ch);\r\n}\r\n} else {\r\npfalc->blue_alarm = 0;\r\n}\r\nif (frs0 & FRS0_LFA) {\r\nif (!pfalc->loss_fa) {\r\npfalc->loss_fa = 1;\r\npfalc->lfa++;\r\nif (!pfalc->blue_alarm && !pfalc->red_alarm) {\r\nif (conf->media == IF_IFACE_T1) {\r\ncpc_writeb(falcbase + F_REG(IMR0, ch),\r\ncpc_readb(falcbase + F_REG(IMR0, ch))\r\n| IMR0_PDEN);\r\n}\r\nfalc_disable_comm(card, ch);\r\n}\r\n}\r\n} else {\r\nif (pfalc->loss_fa) {\r\npfalc->loss_fa = 0;\r\npfalc->farec++;\r\n}\r\n}\r\nif (pfalc->multiframe_mode && (frs0 & FRS0_LMFA)) {\r\nif (!pfalc->loss_mfa) {\r\npfalc->loss_mfa = 1;\r\npfalc->lmfa++;\r\nif (!pfalc->blue_alarm && !pfalc->red_alarm &&\r\n!pfalc->loss_fa) {\r\nif (conf->media == IF_IFACE_T1) {\r\ncpc_writeb(falcbase + F_REG(IMR0, ch),\r\ncpc_readb(falcbase + F_REG(IMR0, ch))\r\n| IMR0_PDEN);\r\n}\r\nfalc_disable_comm(card, ch);\r\n}\r\n}\r\n} else {\r\npfalc->loss_mfa = 0;\r\n}\r\nif (frs0 & FRS0_RRA) {\r\nif (!pfalc->yellow_alarm) {\r\npfalc->yellow_alarm = 1;\r\npfalc->rai++;\r\nif (pfalc->sync) {\r\nfalc_disable_comm(card, ch);\r\n}\r\n}\r\n} else {\r\npfalc->yellow_alarm = 0;\r\n}\r\n}\r\nif (pfalc->red_alarm || pfalc->loss_fa ||\r\npfalc->loss_mfa || pfalc->blue_alarm) {\r\nif (pfalc->sync) {\r\npfalc->sync = 0;\r\nchan->d.line_off++;\r\ncpc_writeb(falcbase + card->hw.cpld_reg2,\r\ncpc_readb(falcbase + card->hw.cpld_reg2) &\r\n~(CPLD_REG2_FALC_LED2 << (2 * ch)));\r\n}\r\n} else {\r\nif (!pfalc->sync) {\r\npfalc->sync = 1;\r\nchan->d.line_on++;\r\ncpc_writeb(falcbase + card->hw.cpld_reg2,\r\ncpc_readb(falcbase + card->hw.cpld_reg2) |\r\n(CPLD_REG2_FALC_LED2 << (2 * ch)));\r\n}\r\n}\r\nif (pfalc->sync && !pfalc->yellow_alarm) {\r\nif (!pfalc->active) {\r\nif (pfalc->loop_active) {\r\nreturn;\r\n}\r\nif (conf->media == IF_IFACE_T1) {\r\ncpc_writeb(falcbase + F_REG(IMR0, ch),\r\ncpc_readb(falcbase + F_REG(IMR0, ch)) & ~IMR0_PDEN);\r\n}\r\nfalc_enable_comm(card, ch);\r\npfalc->active = 1;\r\n}\r\n} else {\r\nif (pfalc->active) {\r\npfalc->active = 0;\r\n}\r\n}\r\n}\r\nstatic void falc_update_stats(pc300_t * card, int ch)\r\n{\r\npc300ch_t *chan = (pc300ch_t *) & card->chan[ch];\r\npc300chconf_t *conf = (pc300chconf_t *) & chan->conf;\r\nfalc_t *pfalc = (falc_t *) & chan->falc;\r\nvoid __iomem *falcbase = card->hw.falcbase;\r\nu16 counter;\r\ncounter = cpc_readb(falcbase + F_REG(FECL, ch));\r\ncounter |= cpc_readb(falcbase + F_REG(FECH, ch)) << 8;\r\npfalc->fec += counter;\r\ncounter = cpc_readb(falcbase + F_REG(CVCL, ch));\r\ncounter |= cpc_readb(falcbase + F_REG(CVCH, ch)) << 8;\r\npfalc->cvc += counter;\r\ncounter = cpc_readb(falcbase + F_REG(CECL, ch));\r\ncounter |= cpc_readb(falcbase + F_REG(CECH, ch)) << 8;\r\npfalc->cec += counter;\r\ncounter = cpc_readb(falcbase + F_REG(EBCL, ch));\r\ncounter |= cpc_readb(falcbase + F_REG(EBCH, ch)) << 8;\r\npfalc->ebc += counter;\r\nif (cpc_readb(falcbase + F_REG(LCR1, ch)) & LCR1_EPRM) {\r\nmdelay(10);\r\ncounter = cpc_readb(falcbase + F_REG(BECL, ch));\r\ncounter |= cpc_readb(falcbase + F_REG(BECH, ch)) << 8;\r\npfalc->bec += counter;\r\nif (((conf->media == IF_IFACE_T1) &&\r\n(cpc_readb(falcbase + F_REG(FRS1, ch)) & FRS1_LLBAD) &&\r\n(!(cpc_readb(falcbase + F_REG(FRS1, ch)) & FRS1_PDEN))) ||\r\n((conf->media == IF_IFACE_E1) &&\r\n(cpc_readb(falcbase + F_REG(RSP, ch)) & RSP_LLBAD))) {\r\npfalc->prbs = 2;\r\n} else {\r\npfalc->prbs = 1;\r\n}\r\n}\r\n}\r\nstatic void falc_remote_loop(pc300_t * card, int ch, int loop_on)\r\n{\r\npc300ch_t *chan = (pc300ch_t *) & card->chan[ch];\r\npc300chconf_t *conf = (pc300chconf_t *) & chan->conf;\r\nfalc_t *pfalc = (falc_t *) & chan->falc;\r\nvoid __iomem *falcbase = card->hw.falcbase;\r\nif (loop_on) {\r\nif (conf->media == IF_IFACE_T1) {\r\ncpc_writeb(falcbase + F_REG(IMR0, ch),\r\ncpc_readb(falcbase + F_REG(IMR0, ch)) | IMR0_PDEN);\r\n}\r\nfalc_disable_comm(card, ch);\r\ncpc_writeb(falcbase + F_REG(LIM1, ch),\r\ncpc_readb(falcbase + F_REG(LIM1, ch)) | LIM1_RL);\r\npfalc->loop_active = 1;\r\n} else {\r\ncpc_writeb(falcbase + F_REG(LIM1, ch),\r\ncpc_readb(falcbase + F_REG(LIM1, ch)) & ~LIM1_RL);\r\npfalc->sync = 0;\r\ncpc_writeb(falcbase + card->hw.cpld_reg2,\r\ncpc_readb(falcbase + card->hw.cpld_reg2) &\r\n~(CPLD_REG2_FALC_LED2 << (2 * ch)));\r\npfalc->active = 0;\r\nfalc_issue_cmd(card, ch, CMDR_XRES);\r\npfalc->loop_active = 0;\r\n}\r\n}\r\nstatic void falc_local_loop(pc300_t * card, int ch, int loop_on)\r\n{\r\npc300ch_t *chan = (pc300ch_t *) & card->chan[ch];\r\nfalc_t *pfalc = (falc_t *) & chan->falc;\r\nvoid __iomem *falcbase = card->hw.falcbase;\r\nif (loop_on) {\r\ncpc_writeb(falcbase + F_REG(LIM0, ch),\r\ncpc_readb(falcbase + F_REG(LIM0, ch)) | LIM0_LL);\r\npfalc->loop_active = 1;\r\n} else {\r\ncpc_writeb(falcbase + F_REG(LIM0, ch),\r\ncpc_readb(falcbase + F_REG(LIM0, ch)) & ~LIM0_LL);\r\npfalc->loop_active = 0;\r\n}\r\n}\r\nstatic void falc_payload_loop(pc300_t * card, int ch, int loop_on)\r\n{\r\npc300ch_t *chan = (pc300ch_t *) & card->chan[ch];\r\npc300chconf_t *conf = (pc300chconf_t *) & chan->conf;\r\nfalc_t *pfalc = (falc_t *) & chan->falc;\r\nvoid __iomem *falcbase = card->hw.falcbase;\r\nif (loop_on) {\r\nif (conf->media == IF_IFACE_T1) {\r\ncpc_writeb(falcbase + F_REG(IMR0, ch),\r\ncpc_readb(falcbase + F_REG(IMR0, ch)) | IMR0_PDEN);\r\n}\r\nfalc_disable_comm(card, ch);\r\ncpc_writeb(falcbase + F_REG(FMR2, ch),\r\ncpc_readb(falcbase + F_REG(FMR2, ch)) | FMR2_PLB);\r\nif (conf->media == IF_IFACE_T1) {\r\ncpc_writeb(falcbase + F_REG(FMR4, ch),\r\ncpc_readb(falcbase + F_REG(FMR4, ch)) | FMR4_TM);\r\n} else {\r\ncpc_writeb(falcbase + F_REG(FMR5, ch),\r\ncpc_readb(falcbase + F_REG(FMR5, ch)) | XSP_TT0);\r\n}\r\nfalc_open_all_timeslots(card, ch);\r\npfalc->loop_active = 2;\r\n} else {\r\ncpc_writeb(falcbase + F_REG(FMR2, ch),\r\ncpc_readb(falcbase + F_REG(FMR2, ch)) & ~FMR2_PLB);\r\nif (conf->media == IF_IFACE_T1) {\r\ncpc_writeb(falcbase + F_REG(FMR4, ch),\r\ncpc_readb(falcbase + F_REG(FMR4, ch)) & ~FMR4_TM);\r\n} else {\r\ncpc_writeb(falcbase + F_REG(FMR5, ch),\r\ncpc_readb(falcbase + F_REG(FMR5, ch)) & ~XSP_TT0);\r\n}\r\npfalc->sync = 0;\r\ncpc_writeb(falcbase + card->hw.cpld_reg2,\r\ncpc_readb(falcbase + card->hw.cpld_reg2) &\r\n~(CPLD_REG2_FALC_LED2 << (2 * ch)));\r\npfalc->active = 0;\r\nfalc_issue_cmd(card, ch, CMDR_XRES);\r\npfalc->loop_active = 0;\r\n}\r\n}\r\nstatic void turn_off_xlu(pc300_t * card, int ch)\r\n{\r\npc300ch_t *chan = (pc300ch_t *) & card->chan[ch];\r\npc300chconf_t *conf = (pc300chconf_t *) & chan->conf;\r\nvoid __iomem *falcbase = card->hw.falcbase;\r\nif (conf->media == IF_IFACE_T1) {\r\ncpc_writeb(falcbase + F_REG(FMR5, ch),\r\ncpc_readb(falcbase + F_REG(FMR5, ch)) & ~FMR5_XLU);\r\n} else {\r\ncpc_writeb(falcbase + F_REG(FMR3, ch),\r\ncpc_readb(falcbase + F_REG(FMR3, ch)) & ~FMR3_XLU);\r\n}\r\n}\r\nstatic void turn_off_xld(pc300_t * card, int ch)\r\n{\r\npc300ch_t *chan = (pc300ch_t *) & card->chan[ch];\r\npc300chconf_t *conf = (pc300chconf_t *) & chan->conf;\r\nvoid __iomem *falcbase = card->hw.falcbase;\r\nif (conf->media == IF_IFACE_T1) {\r\ncpc_writeb(falcbase + F_REG(FMR5, ch),\r\ncpc_readb(falcbase + F_REG(FMR5, ch)) & ~FMR5_XLD);\r\n} else {\r\ncpc_writeb(falcbase + F_REG(FMR3, ch),\r\ncpc_readb(falcbase + F_REG(FMR3, ch)) & ~FMR3_XLD);\r\n}\r\n}\r\nstatic void falc_generate_loop_up_code(pc300_t * card, int ch)\r\n{\r\npc300ch_t *chan = (pc300ch_t *) & card->chan[ch];\r\npc300chconf_t *conf = (pc300chconf_t *) & chan->conf;\r\nfalc_t *pfalc = (falc_t *) & chan->falc;\r\nvoid __iomem *falcbase = card->hw.falcbase;\r\nif (conf->media == IF_IFACE_T1) {\r\ncpc_writeb(falcbase + F_REG(FMR5, ch),\r\ncpc_readb(falcbase + F_REG(FMR5, ch)) | FMR5_XLU);\r\n} else {\r\ncpc_writeb(falcbase + F_REG(FMR3, ch),\r\ncpc_readb(falcbase + F_REG(FMR3, ch)) | FMR3_XLU);\r\n}\r\nif (conf->media == IF_IFACE_T1) {\r\ncpc_writeb(falcbase + F_REG(IMR0, ch),\r\ncpc_readb(falcbase + F_REG(IMR0, ch)) | IMR0_PDEN);\r\n}\r\nfalc_disable_comm(card, ch);\r\npfalc->loop_gen = 1;\r\n}\r\nstatic void falc_generate_loop_down_code(pc300_t * card, int ch)\r\n{\r\npc300ch_t *chan = (pc300ch_t *) & card->chan[ch];\r\npc300chconf_t *conf = (pc300chconf_t *) & chan->conf;\r\nfalc_t *pfalc = (falc_t *) & chan->falc;\r\nvoid __iomem *falcbase = card->hw.falcbase;\r\nif (conf->media == IF_IFACE_T1) {\r\ncpc_writeb(falcbase + F_REG(FMR5, ch),\r\ncpc_readb(falcbase + F_REG(FMR5, ch)) | FMR5_XLD);\r\n} else {\r\ncpc_writeb(falcbase + F_REG(FMR3, ch),\r\ncpc_readb(falcbase + F_REG(FMR3, ch)) | FMR3_XLD);\r\n}\r\npfalc->sync = 0;\r\ncpc_writeb(falcbase + card->hw.cpld_reg2,\r\ncpc_readb(falcbase + card->hw.cpld_reg2) &\r\n~(CPLD_REG2_FALC_LED2 << (2 * ch)));\r\npfalc->active = 0;\r\npfalc->loop_gen = 0;\r\n}\r\nstatic void falc_pattern_test(pc300_t * card, int ch, unsigned int activate)\r\n{\r\npc300ch_t *chan = (pc300ch_t *) & card->chan[ch];\r\npc300chconf_t *conf = (pc300chconf_t *) & chan->conf;\r\nfalc_t *pfalc = (falc_t *) & chan->falc;\r\nvoid __iomem *falcbase = card->hw.falcbase;\r\nif (activate) {\r\npfalc->prbs = 1;\r\npfalc->bec = 0;\r\nif (conf->media == IF_IFACE_T1) {\r\ncpc_writeb(falcbase + F_REG(IMR3, ch),\r\ncpc_readb(falcbase + F_REG(IMR3, ch)) | IMR3_LLBSC);\r\n} else {\r\ncpc_writeb(falcbase + F_REG(IMR1, ch),\r\ncpc_readb(falcbase + F_REG(IMR1, ch)) | IMR1_LLBSC);\r\n}\r\ncpc_writeb(falcbase + F_REG(LCR1, ch),\r\ncpc_readb(falcbase + F_REG(LCR1, ch)) | LCR1_EPRM | LCR1_XPRBS);\r\n} else {\r\npfalc->prbs = 0;\r\ncpc_writeb(falcbase + F_REG(LCR1, ch),\r\ncpc_readb(falcbase+F_REG(LCR1,ch)) & ~(LCR1_EPRM | LCR1_XPRBS));\r\nif (conf->media == IF_IFACE_T1) {\r\ncpc_writeb(falcbase + F_REG(IMR3, ch),\r\ncpc_readb(falcbase + F_REG(IMR3, ch)) & ~IMR3_LLBSC);\r\n} else {\r\ncpc_writeb(falcbase + F_REG(IMR1, ch),\r\ncpc_readb(falcbase + F_REG(IMR1, ch)) & ~IMR1_LLBSC);\r\n}\r\n}\r\n}\r\nstatic u16 falc_pattern_test_error(pc300_t * card, int ch)\r\n{\r\npc300ch_t *chan = (pc300ch_t *) & card->chan[ch];\r\nfalc_t *pfalc = (falc_t *) & chan->falc;\r\nreturn pfalc->bec;\r\n}\r\nstatic void\r\ncpc_trace(struct net_device *dev, struct sk_buff *skb_main, char rx_tx)\r\n{\r\nstruct sk_buff *skb;\r\nif ((skb = dev_alloc_skb(10 + skb_main->len)) == NULL) {\r\nprintk("%s: out of memory\n", dev->name);\r\nreturn;\r\n}\r\nskb_put(skb, 10 + skb_main->len);\r\nskb->dev = dev;\r\nskb->protocol = htons(ETH_P_CUST);\r\nskb_reset_mac_header(skb);\r\nskb->pkt_type = PACKET_HOST;\r\nskb->len = 10 + skb_main->len;\r\nskb_copy_to_linear_data(skb, dev->name, 5);\r\nskb->data[5] = '[';\r\nskb->data[6] = rx_tx;\r\nskb->data[7] = ']';\r\nskb->data[8] = ':';\r\nskb->data[9] = ' ';\r\nskb_copy_from_linear_data(skb_main, &skb->data[10], skb_main->len);\r\nnetif_rx(skb);\r\n}\r\nstatic void cpc_tx_timeout(struct net_device *dev)\r\n{\r\npc300dev_t *d = (pc300dev_t *) dev_to_hdlc(dev)->priv;\r\npc300ch_t *chan = (pc300ch_t *) d->chan;\r\npc300_t *card = (pc300_t *) chan->card;\r\nint ch = chan->channel;\r\nunsigned long flags;\r\nu8 ilar;\r\ndev->stats.tx_errors++;\r\ndev->stats.tx_aborted_errors++;\r\nCPC_LOCK(card, flags);\r\nif ((ilar = cpc_readb(card->hw.scabase + ILAR)) != 0) {\r\nprintk("%s: ILAR=0x%x\n", dev->name, ilar);\r\ncpc_writeb(card->hw.scabase + ILAR, ilar);\r\ncpc_writeb(card->hw.scabase + DMER, 0x80);\r\n}\r\nif (card->hw.type == PC300_TE) {\r\ncpc_writeb(card->hw.falcbase + card->hw.cpld_reg2,\r\ncpc_readb(card->hw.falcbase + card->hw.cpld_reg2) &\r\n~(CPLD_REG2_FALC_LED1 << (2 * ch)));\r\n}\r\ndev->trans_start = jiffies;\r\nCPC_UNLOCK(card, flags);\r\nnetif_wake_queue(dev);\r\n}\r\nstatic int cpc_queue_xmit(struct sk_buff *skb, struct net_device *dev)\r\n{\r\npc300dev_t *d = (pc300dev_t *) dev_to_hdlc(dev)->priv;\r\npc300ch_t *chan = (pc300ch_t *) d->chan;\r\npc300_t *card = (pc300_t *) chan->card;\r\nint ch = chan->channel;\r\nunsigned long flags;\r\n#ifdef PC300_DEBUG_TX\r\nint i;\r\n#endif\r\nif (!netif_carrier_ok(dev)) {\r\ndev_kfree_skb(skb);\r\ndev->stats.tx_errors++;\r\ndev->stats.tx_carrier_errors++;\r\nreturn 0;\r\n} else if (cpc_readb(card->hw.scabase + M_REG(ST3, ch)) & ST3_DCD) {\r\nprintk("%s: DCD is OFF. Going administrative down.\n", dev->name);\r\ndev->stats.tx_errors++;\r\ndev->stats.tx_carrier_errors++;\r\ndev_kfree_skb(skb);\r\nnetif_carrier_off(dev);\r\nCPC_LOCK(card, flags);\r\ncpc_writeb(card->hw.scabase + M_REG(CMD, ch), CMD_TX_BUF_CLR);\r\nif (card->hw.type == PC300_TE) {\r\ncpc_writeb(card->hw.falcbase + card->hw.cpld_reg2,\r\ncpc_readb(card->hw.falcbase + card->hw.cpld_reg2) &\r\n~(CPLD_REG2_FALC_LED1 << (2 * ch)));\r\n}\r\nCPC_UNLOCK(card, flags);\r\nnetif_wake_queue(dev);\r\nreturn 0;\r\n}\r\nif (dma_buf_write(card, ch, (u8 *)skb->data, skb->len) != 0) {\r\nnetif_stop_queue(dev);\r\ndev_kfree_skb(skb);\r\ndev->stats.tx_errors++;\r\ndev->stats.tx_dropped++;\r\nreturn 0;\r\n}\r\n#ifdef PC300_DEBUG_TX\r\nprintk("%s T:", dev->name);\r\nfor (i = 0; i < skb->len; i++)\r\nprintk(" %02x", *(skb->data + i));\r\nprintk("\n");\r\n#endif\r\nif (d->trace_on) {\r\ncpc_trace(dev, skb, 'T');\r\n}\r\nCPC_LOCK(card, flags);\r\nif (card->chan[ch].nfree_tx_bd <= 1) {\r\nnetif_stop_queue(dev);\r\n}\r\ncpc_writel(card->hw.scabase + DTX_REG(EDAL, ch),\r\nTX_BD_ADDR(ch, chan->tx_next_bd));\r\ncpc_writeb(card->hw.scabase + M_REG(CMD, ch), CMD_TX_ENA);\r\ncpc_writeb(card->hw.scabase + DSR_TX(ch), DSR_DE);\r\nif (card->hw.type == PC300_TE) {\r\ncpc_writeb(card->hw.falcbase + card->hw.cpld_reg2,\r\ncpc_readb(card->hw.falcbase + card->hw.cpld_reg2) |\r\n(CPLD_REG2_FALC_LED1 << (2 * ch)));\r\n}\r\nCPC_UNLOCK(card, flags);\r\ndev_kfree_skb(skb);\r\nreturn 0;\r\n}\r\nstatic void cpc_net_rx(struct net_device *dev)\r\n{\r\npc300dev_t *d = (pc300dev_t *) dev_to_hdlc(dev)->priv;\r\npc300ch_t *chan = (pc300ch_t *) d->chan;\r\npc300_t *card = (pc300_t *) chan->card;\r\nint ch = chan->channel;\r\n#ifdef PC300_DEBUG_RX\r\nint i;\r\n#endif\r\nint rxb;\r\nstruct sk_buff *skb;\r\nwhile (1) {\r\nif ((rxb = dma_get_rx_frame_size(card, ch)) == -1)\r\nreturn;\r\nif (!netif_carrier_ok(dev)) {\r\nprintk("%s : DCD is OFF - drop %d rx bytes\n", dev->name, rxb);\r\nskb = NULL;\r\n} else {\r\nif (rxb > (dev->mtu + 40)) {\r\nprintk("%s : MTU exceeded %d\n", dev->name, rxb);\r\nskb = NULL;\r\n} else {\r\nskb = dev_alloc_skb(rxb);\r\nif (skb == NULL) {\r\nprintk("%s: Memory squeeze!!\n", dev->name);\r\nreturn;\r\n}\r\nskb->dev = dev;\r\n}\r\n}\r\nif (((rxb = dma_buf_read(card, ch, skb)) <= 0) || (skb == NULL)) {\r\n#ifdef PC300_DEBUG_RX\r\nprintk("%s: rxb = %x\n", dev->name, rxb);\r\n#endif\r\nif ((skb == NULL) && (rxb > 0)) {\r\ndev->stats.rx_errors++;\r\ndev->stats.rx_length_errors++;\r\ncontinue;\r\n}\r\nif (rxb < 0) {\r\nrxb = -rxb;\r\nif (rxb & DST_OVR) {\r\ndev->stats.rx_errors++;\r\ndev->stats.rx_fifo_errors++;\r\n}\r\nif (rxb & DST_CRC) {\r\ndev->stats.rx_errors++;\r\ndev->stats.rx_crc_errors++;\r\n}\r\nif (rxb & (DST_RBIT | DST_SHRT | DST_ABT)) {\r\ndev->stats.rx_errors++;\r\ndev->stats.rx_frame_errors++;\r\n}\r\n}\r\nif (skb) {\r\ndev_kfree_skb_irq(skb);\r\n}\r\ncontinue;\r\n}\r\ndev->stats.rx_bytes += rxb;\r\n#ifdef PC300_DEBUG_RX\r\nprintk("%s R:", dev->name);\r\nfor (i = 0; i < skb->len; i++)\r\nprintk(" %02x", *(skb->data + i));\r\nprintk("\n");\r\n#endif\r\nif (d->trace_on) {\r\ncpc_trace(dev, skb, 'R');\r\n}\r\ndev->stats.rx_packets++;\r\nskb->protocol = hdlc_type_trans(skb, dev);\r\nnetif_rx(skb);\r\n}\r\n}\r\nstatic void sca_tx_intr(pc300dev_t *dev)\r\n{\r\npc300ch_t *chan = (pc300ch_t *)dev->chan;\r\npc300_t *card = (pc300_t *)chan->card;\r\nint ch = chan->channel;\r\nvolatile pcsca_bd_t __iomem * ptdescr;\r\nptdescr = (card->hw.rambase +\r\nTX_BD_ADDR(ch,chan->tx_first_bd));\r\nwhile ((cpc_readl(card->hw.scabase + DTX_REG(CDAL,ch)) !=\r\nTX_BD_ADDR(ch,chan->tx_first_bd)) &&\r\n(cpc_readb(&ptdescr->status) & DST_OSB)) {\r\ndev->dev->stats.tx_packets++;\r\ndev->dev->stats.tx_bytes += cpc_readw(&ptdescr->len);\r\ncpc_writeb(&ptdescr->status, DST_OSB);\r\ncpc_writew(&ptdescr->len, 0);\r\nchan->nfree_tx_bd++;\r\nchan->tx_first_bd = (chan->tx_first_bd + 1) & (N_DMA_TX_BUF - 1);\r\nptdescr = (card->hw.rambase + TX_BD_ADDR(ch,chan->tx_first_bd));\r\n}\r\n#ifdef CONFIG_PC300_MLPPP\r\nif (chan->conf.proto == PC300_PROTO_MLPPP) {\r\ncpc_tty_trigger_poll(dev);\r\n} else {\r\n#endif\r\nnetif_wake_queue(dev->dev);\r\n#ifdef CONFIG_PC300_MLPPP\r\n}\r\n#endif\r\n}\r\nstatic void sca_intr(pc300_t * card)\r\n{\r\nvoid __iomem *scabase = card->hw.scabase;\r\nvolatile u32 status;\r\nint ch;\r\nint intr_count = 0;\r\nunsigned char dsr_rx;\r\nwhile ((status = cpc_readl(scabase + ISR0)) != 0) {\r\nfor (ch = 0; ch < card->hw.nchan; ch++) {\r\npc300ch_t *chan = &card->chan[ch];\r\npc300dev_t *d = &chan->d;\r\nstruct net_device *dev = d->dev;\r\nspin_lock(&card->card_lock);\r\nif (status & IR0_DRX((IR0_DMIA | IR0_DMIB), ch)) {\r\nu8 drx_stat = cpc_readb(scabase + DSR_RX(ch));\r\ncpc_writeb(scabase + DSR_RX(ch), drx_stat | DSR_DWE);\r\n#ifdef PC300_DEBUG_INTR\r\nprintk ("sca_intr: RX intr chan[%d] (st=0x%08lx, dsr=0x%02x)\n",\r\nch, status, drx_stat);\r\n#endif\r\nif (status & IR0_DRX(IR0_DMIA, ch)) {\r\nif (drx_stat & DSR_BOF) {\r\n#ifdef CONFIG_PC300_MLPPP\r\nif (chan->conf.proto == PC300_PROTO_MLPPP) {\r\nif ((cpc_readb(scabase + DSR_RX(ch)) & DSR_DE)) {\r\nrx_dma_stop(card, ch);\r\n}\r\ncpc_tty_receive(d);\r\nrx_dma_start(card, ch);\r\n} else\r\n#endif\r\n{\r\nif ((cpc_readb(scabase + DSR_RX(ch)) & DSR_DE)) {\r\nrx_dma_stop(card, ch);\r\n}\r\ncpc_net_rx(dev);\r\ndev->stats.rx_errors++;\r\ndev->stats.rx_over_errors++;\r\nchan->rx_first_bd = 0;\r\nchan->rx_last_bd = N_DMA_RX_BUF - 1;\r\nrx_dma_start(card, ch);\r\n}\r\n}\r\n}\r\nif (status & IR0_DRX(IR0_DMIB, ch)) {\r\nif (drx_stat & DSR_EOM) {\r\nif (card->hw.type == PC300_TE) {\r\ncpc_writeb(card->hw.falcbase +\r\ncard->hw.cpld_reg2,\r\ncpc_readb (card->hw.falcbase +\r\ncard->hw.cpld_reg2) |\r\n(CPLD_REG2_FALC_LED1 << (2 * ch)));\r\n}\r\n#ifdef CONFIG_PC300_MLPPP\r\nif (chan->conf.proto == PC300_PROTO_MLPPP) {\r\ncpc_tty_receive(d);\r\n} else {\r\ncpc_net_rx(dev);\r\n}\r\n#else\r\ncpc_net_rx(dev);\r\n#endif\r\nif (card->hw.type == PC300_TE) {\r\ncpc_writeb(card->hw.falcbase +\r\ncard->hw.cpld_reg2,\r\ncpc_readb (card->hw.falcbase +\r\ncard->hw.cpld_reg2) &\r\n~ (CPLD_REG2_FALC_LED1 << (2 * ch)));\r\n}\r\n}\r\n}\r\nif (!(dsr_rx = cpc_readb(scabase + DSR_RX(ch)) & DSR_DE)) {\r\n#ifdef PC300_DEBUG_INTR\r\nprintk("%s: RX intr chan[%d] (st=0x%08lx, dsr=0x%02x, dsr2=0x%02x)\n",\r\ndev->name, ch, status, drx_stat, dsr_rx);\r\n#endif\r\ncpc_writeb(scabase + DSR_RX(ch), (dsr_rx | DSR_DE) & 0xfe);\r\n}\r\n}\r\nif (status & IR0_DTX((IR0_EFT | IR0_DMIA | IR0_DMIB), ch)) {\r\nu8 dtx_stat = cpc_readb(scabase + DSR_TX(ch));\r\ncpc_writeb(scabase + DSR_TX(ch), dtx_stat | DSR_DWE);\r\n#ifdef PC300_DEBUG_INTR\r\nprintk ("sca_intr: TX intr chan[%d] (st=0x%08lx, dsr=0x%02x)\n",\r\nch, status, dtx_stat);\r\n#endif\r\nif (status & IR0_DTX(IR0_EFT, ch)) {\r\nif (dtx_stat & DSR_UDRF) {\r\nif (cpc_readb (scabase + M_REG(TBN, ch)) != 0) {\r\ncpc_writeb(scabase + M_REG(CMD,ch), CMD_TX_BUF_CLR);\r\n}\r\nif (card->hw.type == PC300_TE) {\r\ncpc_writeb(card->hw.falcbase + card->hw.cpld_reg2,\r\ncpc_readb (card->hw.falcbase +\r\ncard->hw.cpld_reg2) &\r\n~ (CPLD_REG2_FALC_LED1 << (2 * ch)));\r\n}\r\ndev->stats.tx_errors++;\r\ndev->stats.tx_fifo_errors++;\r\nsca_tx_intr(d);\r\n}\r\n}\r\nif (status & IR0_DTX(IR0_DMIA, ch)) {\r\nif (dtx_stat & DSR_BOF) {\r\n}\r\n}\r\nif (status & IR0_DTX(IR0_DMIB, ch)) {\r\nif (dtx_stat & DSR_EOM) {\r\nif (card->hw.type == PC300_TE) {\r\ncpc_writeb(card->hw.falcbase + card->hw.cpld_reg2,\r\ncpc_readb (card->hw.falcbase +\r\ncard->hw.cpld_reg2) &\r\n~ (CPLD_REG2_FALC_LED1 << (2 * ch)));\r\n}\r\nsca_tx_intr(d);\r\n}\r\n}\r\n}\r\nif (status & IR0_M(IR0_RXINTA, ch)) {\r\nu8 st1 = cpc_readb(scabase + M_REG(ST1, ch));\r\ncpc_writeb(scabase + M_REG(ST1, ch), st1);\r\n#ifdef PC300_DEBUG_INTR\r\nprintk("sca_intr: MSCI intr chan[%d] (st=0x%08lx, st1=0x%02x)\n",\r\nch, status, st1);\r\n#endif\r\nif (st1 & ST1_CDCD) {\r\nif (cpc_readb(scabase + M_REG(ST3, ch)) & ST3_DCD) {\r\nprintk ("%s: DCD is OFF. Going administrative down.\n",\r\ndev->name);\r\n#ifdef CONFIG_PC300_MLPPP\r\nif (chan->conf.proto != PC300_PROTO_MLPPP) {\r\nnetif_carrier_off(dev);\r\n}\r\n#else\r\nnetif_carrier_off(dev);\r\n#endif\r\ncard->chan[ch].d.line_off++;\r\n} else {\r\nprintk ("%s: DCD is ON. Going administrative up.\n",\r\ndev->name);\r\n#ifdef CONFIG_PC300_MLPPP\r\nif (chan->conf.proto != PC300_PROTO_MLPPP)\r\n#endif\r\nnetif_carrier_on(dev);\r\ncard->chan[ch].d.line_on++;\r\n}\r\n}\r\n}\r\nspin_unlock(&card->card_lock);\r\n}\r\nif (++intr_count == 10)\r\nbreak;\r\n}\r\n}\r\nstatic void falc_t1_loop_detection(pc300_t *card, int ch, u8 frs1)\r\n{\r\npc300ch_t *chan = (pc300ch_t *) & card->chan[ch];\r\nfalc_t *pfalc = (falc_t *) & chan->falc;\r\nvoid __iomem *falcbase = card->hw.falcbase;\r\nif (((cpc_readb(falcbase + F_REG(LCR1, ch)) & LCR1_XPRBS) == 0) &&\r\n!pfalc->loop_gen) {\r\nif (frs1 & FRS1_LLBDD) {\r\nif (pfalc->loop_active) {\r\nfalc_remote_loop(card, ch, 0);\r\n}\r\n} else {\r\nif ((frs1 & FRS1_LLBAD) &&\r\n((cpc_readb(falcbase + F_REG(LCR1, ch)) & LCR1_EPRM) == 0)) {\r\nif (!pfalc->loop_active) {\r\nfalc_remote_loop(card, ch, 1);\r\n}\r\n}\r\n}\r\n}\r\n}\r\nstatic void falc_e1_loop_detection(pc300_t *card, int ch, u8 rsp)\r\n{\r\npc300ch_t *chan = (pc300ch_t *) & card->chan[ch];\r\nfalc_t *pfalc = (falc_t *) & chan->falc;\r\nvoid __iomem *falcbase = card->hw.falcbase;\r\nif (((cpc_readb(falcbase + F_REG(LCR1, ch)) & LCR1_XPRBS) == 0) &&\r\n!pfalc->loop_gen) {\r\nif (rsp & RSP_LLBDD) {\r\nif (pfalc->loop_active) {\r\nfalc_remote_loop(card, ch, 0);\r\n}\r\n} else {\r\nif ((rsp & RSP_LLBAD) &&\r\n((cpc_readb(falcbase + F_REG(LCR1, ch)) & LCR1_EPRM) == 0)) {\r\nif (!pfalc->loop_active) {\r\nfalc_remote_loop(card, ch, 1);\r\n}\r\n}\r\n}\r\n}\r\n}\r\nstatic void falc_t1_intr(pc300_t * card, int ch)\r\n{\r\npc300ch_t *chan = (pc300ch_t *) & card->chan[ch];\r\nfalc_t *pfalc = (falc_t *) & chan->falc;\r\nvoid __iomem *falcbase = card->hw.falcbase;\r\nu8 isr0, isr3, gis;\r\nu8 dummy;\r\nwhile ((gis = cpc_readb(falcbase + F_REG(GIS, ch))) != 0) {\r\nif (gis & GIS_ISR0) {\r\nisr0 = cpc_readb(falcbase + F_REG(FISR0, ch));\r\nif (isr0 & FISR0_PDEN) {\r\nif (cpc_readb(falcbase + F_REG(FRS1, ch)) &\r\nFRS1_PDEN) {\r\npfalc->pden++;\r\n}\r\n}\r\n}\r\nif (gis & GIS_ISR1) {\r\ndummy = cpc_readb(falcbase + F_REG(FISR1, ch));\r\n}\r\nif (gis & GIS_ISR2) {\r\ndummy = cpc_readb(falcbase + F_REG(FISR2, ch));\r\n}\r\nif (gis & GIS_ISR3) {\r\nisr3 = cpc_readb(falcbase + F_REG(FISR3, ch));\r\nif (isr3 & FISR3_SEC) {\r\npfalc->sec++;\r\nfalc_update_stats(card, ch);\r\nfalc_check_status(card, ch,\r\ncpc_readb(falcbase + F_REG(FRS0, ch)));\r\n}\r\nif (isr3 & FISR3_ES) {\r\npfalc->es++;\r\n}\r\nif (isr3 & FISR3_LLBSC) {\r\nfalc_t1_loop_detection(card, ch,\r\ncpc_readb(falcbase + F_REG(FRS1, ch)));\r\n}\r\n}\r\n}\r\n}\r\nstatic void falc_e1_intr(pc300_t * card, int ch)\r\n{\r\npc300ch_t *chan = (pc300ch_t *) & card->chan[ch];\r\nfalc_t *pfalc = (falc_t *) & chan->falc;\r\nvoid __iomem *falcbase = card->hw.falcbase;\r\nu8 isr1, isr2, isr3, gis, rsp;\r\nu8 dummy;\r\nwhile ((gis = cpc_readb(falcbase + F_REG(GIS, ch))) != 0) {\r\nrsp = cpc_readb(falcbase + F_REG(RSP, ch));\r\nif (gis & GIS_ISR0) {\r\ndummy = cpc_readb(falcbase + F_REG(FISR0, ch));\r\n}\r\nif (gis & GIS_ISR1) {\r\nisr1 = cpc_readb(falcbase + F_REG(FISR1, ch));\r\nif (isr1 & FISR1_XMB) {\r\nif ((pfalc->xmb_cause & 2) &&\r\npfalc->multiframe_mode) {\r\nif (cpc_readb (falcbase + F_REG(FRS0, ch)) &\r\n(FRS0_LOS | FRS0_AIS | FRS0_LFA)) {\r\ncpc_writeb(falcbase + F_REG(XSP, ch),\r\ncpc_readb(falcbase + F_REG(XSP, ch))\r\n& ~XSP_AXS);\r\n} else {\r\ncpc_writeb(falcbase + F_REG(XSP, ch),\r\ncpc_readb(falcbase + F_REG(XSP, ch))\r\n| XSP_AXS);\r\n}\r\n}\r\npfalc->xmb_cause = 0;\r\ncpc_writeb(falcbase + F_REG(IMR1, ch),\r\ncpc_readb(falcbase + F_REG(IMR1, ch)) | IMR1_XMB);\r\n}\r\nif (isr1 & FISR1_LLBSC) {\r\nfalc_e1_loop_detection(card, ch, rsp);\r\n}\r\n}\r\nif (gis & GIS_ISR2) {\r\nisr2 = cpc_readb(falcbase + F_REG(FISR2, ch));\r\nif (isr2 & FISR2_T400MS) {\r\ncpc_writeb(falcbase + F_REG(XSW, ch),\r\ncpc_readb(falcbase + F_REG(XSW, ch)) | XSW_XRA);\r\n}\r\nif (isr2 & FISR2_MFAR) {\r\ncpc_writeb(falcbase + F_REG(XSW, ch),\r\ncpc_readb(falcbase + F_REG(XSW, ch)) & ~XSW_XRA);\r\n}\r\nif (isr2 & (FISR2_FAR | FISR2_LFA | FISR2_AIS | FISR2_LOS)) {\r\npfalc->xmb_cause |= 2;\r\ncpc_writeb(falcbase + F_REG(IMR1, ch),\r\ncpc_readb(falcbase + F_REG(IMR1, ch)) & ~IMR1_XMB);\r\n}\r\n}\r\nif (gis & GIS_ISR3) {\r\nisr3 = cpc_readb(falcbase + F_REG(FISR3, ch));\r\nif (isr3 & FISR3_SEC) {\r\npfalc->sec++;\r\nfalc_update_stats(card, ch);\r\nfalc_check_status(card, ch,\r\ncpc_readb(falcbase + F_REG(FRS0, ch)));\r\n}\r\nif (isr3 & FISR3_ES) {\r\npfalc->es++;\r\n}\r\n}\r\n}\r\n}\r\nstatic void falc_intr(pc300_t * card)\r\n{\r\nint ch;\r\nfor (ch = 0; ch < card->hw.nchan; ch++) {\r\npc300ch_t *chan = &card->chan[ch];\r\npc300chconf_t *conf = (pc300chconf_t *) & chan->conf;\r\nif (conf->media == IF_IFACE_T1) {\r\nfalc_t1_intr(card, ch);\r\n} else {\r\nfalc_e1_intr(card, ch);\r\n}\r\n}\r\n}\r\nstatic irqreturn_t cpc_intr(int irq, void *dev_id)\r\n{\r\npc300_t *card = dev_id;\r\nvolatile u8 plx_status;\r\nif (!card) {\r\n#ifdef PC300_DEBUG_INTR\r\nprintk("cpc_intr: spurious intr %d\n", irq);\r\n#endif\r\nreturn IRQ_NONE;\r\n}\r\nif (!card->hw.rambase) {\r\n#ifdef PC300_DEBUG_INTR\r\nprintk("cpc_intr: spurious intr2 %d\n", irq);\r\n#endif\r\nreturn IRQ_NONE;\r\n}\r\nswitch (card->hw.type) {\r\ncase PC300_RSV:\r\ncase PC300_X21:\r\nsca_intr(card);\r\nbreak;\r\ncase PC300_TE:\r\nwhile ( (plx_status = (cpc_readb(card->hw.plxbase + card->hw.intctl_reg) &\r\n(PLX_9050_LINT1_STATUS | PLX_9050_LINT2_STATUS))) != 0) {\r\nif (plx_status & PLX_9050_LINT1_STATUS) {\r\nsca_intr(card);\r\n}\r\nif (plx_status & PLX_9050_LINT2_STATUS) {\r\nfalc_intr(card);\r\n}\r\n}\r\nbreak;\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void cpc_sca_status(pc300_t * card, int ch)\r\n{\r\nu8 ilar;\r\nvoid __iomem *scabase = card->hw.scabase;\r\nunsigned long flags;\r\ntx_dma_buf_check(card, ch);\r\nrx_dma_buf_check(card, ch);\r\nilar = cpc_readb(scabase + ILAR);\r\nprintk ("ILAR=0x%02x, WCRL=0x%02x, PCR=0x%02x, BTCR=0x%02x, BOLR=0x%02x\n",\r\nilar, cpc_readb(scabase + WCRL), cpc_readb(scabase + PCR),\r\ncpc_readb(scabase + BTCR), cpc_readb(scabase + BOLR));\r\nprintk("TX_CDA=0x%08x, TX_EDA=0x%08x\n",\r\ncpc_readl(scabase + DTX_REG(CDAL, ch)),\r\ncpc_readl(scabase + DTX_REG(EDAL, ch)));\r\nprintk("RX_CDA=0x%08x, RX_EDA=0x%08x, BFL=0x%04x\n",\r\ncpc_readl(scabase + DRX_REG(CDAL, ch)),\r\ncpc_readl(scabase + DRX_REG(EDAL, ch)),\r\ncpc_readw(scabase + DRX_REG(BFLL, ch)));\r\nprintk("DMER=0x%02x, DSR_TX=0x%02x, DSR_RX=0x%02x\n",\r\ncpc_readb(scabase + DMER), cpc_readb(scabase + DSR_TX(ch)),\r\ncpc_readb(scabase + DSR_RX(ch)));\r\nprintk("DMR_TX=0x%02x, DMR_RX=0x%02x, DIR_TX=0x%02x, DIR_RX=0x%02x\n",\r\ncpc_readb(scabase + DMR_TX(ch)), cpc_readb(scabase + DMR_RX(ch)),\r\ncpc_readb(scabase + DIR_TX(ch)),\r\ncpc_readb(scabase + DIR_RX(ch)));\r\nprintk("DCR_TX=0x%02x, DCR_RX=0x%02x, FCT_TX=0x%02x, FCT_RX=0x%02x\n",\r\ncpc_readb(scabase + DCR_TX(ch)), cpc_readb(scabase + DCR_RX(ch)),\r\ncpc_readb(scabase + FCT_TX(ch)),\r\ncpc_readb(scabase + FCT_RX(ch)));\r\nprintk("MD0=0x%02x, MD1=0x%02x, MD2=0x%02x, MD3=0x%02x, IDL=0x%02x\n",\r\ncpc_readb(scabase + M_REG(MD0, ch)),\r\ncpc_readb(scabase + M_REG(MD1, ch)),\r\ncpc_readb(scabase + M_REG(MD2, ch)),\r\ncpc_readb(scabase + M_REG(MD3, ch)),\r\ncpc_readb(scabase + M_REG(IDL, ch)));\r\nprintk("CMD=0x%02x, SA0=0x%02x, SA1=0x%02x, TFN=0x%02x, CTL=0x%02x\n",\r\ncpc_readb(scabase + M_REG(CMD, ch)),\r\ncpc_readb(scabase + M_REG(SA0, ch)),\r\ncpc_readb(scabase + M_REG(SA1, ch)),\r\ncpc_readb(scabase + M_REG(TFN, ch)),\r\ncpc_readb(scabase + M_REG(CTL, ch)));\r\nprintk("ST0=0x%02x, ST1=0x%02x, ST2=0x%02x, ST3=0x%02x, ST4=0x%02x\n",\r\ncpc_readb(scabase + M_REG(ST0, ch)),\r\ncpc_readb(scabase + M_REG(ST1, ch)),\r\ncpc_readb(scabase + M_REG(ST2, ch)),\r\ncpc_readb(scabase + M_REG(ST3, ch)),\r\ncpc_readb(scabase + M_REG(ST4, ch)));\r\nprintk ("CST0=0x%02x, CST1=0x%02x, CST2=0x%02x, CST3=0x%02x, FST=0x%02x\n",\r\ncpc_readb(scabase + M_REG(CST0, ch)),\r\ncpc_readb(scabase + M_REG(CST1, ch)),\r\ncpc_readb(scabase + M_REG(CST2, ch)),\r\ncpc_readb(scabase + M_REG(CST3, ch)),\r\ncpc_readb(scabase + M_REG(FST, ch)));\r\nprintk("TRC0=0x%02x, TRC1=0x%02x, RRC=0x%02x, TBN=0x%02x, RBN=0x%02x\n",\r\ncpc_readb(scabase + M_REG(TRC0, ch)),\r\ncpc_readb(scabase + M_REG(TRC1, ch)),\r\ncpc_readb(scabase + M_REG(RRC, ch)),\r\ncpc_readb(scabase + M_REG(TBN, ch)),\r\ncpc_readb(scabase + M_REG(RBN, ch)));\r\nprintk("TFS=0x%02x, TNR0=0x%02x, TNR1=0x%02x, RNR=0x%02x\n",\r\ncpc_readb(scabase + M_REG(TFS, ch)),\r\ncpc_readb(scabase + M_REG(TNR0, ch)),\r\ncpc_readb(scabase + M_REG(TNR1, ch)),\r\ncpc_readb(scabase + M_REG(RNR, ch)));\r\nprintk("TCR=0x%02x, RCR=0x%02x, TNR1=0x%02x, RNR=0x%02x\n",\r\ncpc_readb(scabase + M_REG(TCR, ch)),\r\ncpc_readb(scabase + M_REG(RCR, ch)),\r\ncpc_readb(scabase + M_REG(TNR1, ch)),\r\ncpc_readb(scabase + M_REG(RNR, ch)));\r\nprintk("TXS=0x%02x, RXS=0x%02x, EXS=0x%02x, TMCT=0x%02x, TMCR=0x%02x\n",\r\ncpc_readb(scabase + M_REG(TXS, ch)),\r\ncpc_readb(scabase + M_REG(RXS, ch)),\r\ncpc_readb(scabase + M_REG(EXS, ch)),\r\ncpc_readb(scabase + M_REG(TMCT, ch)),\r\ncpc_readb(scabase + M_REG(TMCR, ch)));\r\nprintk("IE0=0x%02x, IE1=0x%02x, IE2=0x%02x, IE4=0x%02x, FIE=0x%02x\n",\r\ncpc_readb(scabase + M_REG(IE0, ch)),\r\ncpc_readb(scabase + M_REG(IE1, ch)),\r\ncpc_readb(scabase + M_REG(IE2, ch)),\r\ncpc_readb(scabase + M_REG(IE4, ch)),\r\ncpc_readb(scabase + M_REG(FIE, ch)));\r\nprintk("IER0=0x%08x\n", cpc_readl(scabase + IER0));\r\nif (ilar != 0) {\r\nCPC_LOCK(card, flags);\r\ncpc_writeb(scabase + ILAR, ilar);\r\ncpc_writeb(scabase + DMER, 0x80);\r\nCPC_UNLOCK(card, flags);\r\n}\r\n}\r\nstatic void cpc_falc_status(pc300_t * card, int ch)\r\n{\r\npc300ch_t *chan = &card->chan[ch];\r\nfalc_t *pfalc = (falc_t *) & chan->falc;\r\nunsigned long flags;\r\nCPC_LOCK(card, flags);\r\nprintk("CH%d: %s %s %d channels\n",\r\nch, (pfalc->sync ? "SYNC" : ""), (pfalc->active ? "ACTIVE" : ""),\r\npfalc->num_channels);\r\nprintk(" pden=%d, los=%d, losr=%d, lfa=%d, farec=%d\n",\r\npfalc->pden, pfalc->los, pfalc->losr, pfalc->lfa, pfalc->farec);\r\nprintk(" lmfa=%d, ais=%d, sec=%d, es=%d, rai=%d\n",\r\npfalc->lmfa, pfalc->ais, pfalc->sec, pfalc->es, pfalc->rai);\r\nprintk(" bec=%d, fec=%d, cvc=%d, cec=%d, ebc=%d\n",\r\npfalc->bec, pfalc->fec, pfalc->cvc, pfalc->cec, pfalc->ebc);\r\nprintk("\n");\r\nprintk(" STATUS: %s %s %s %s %s %s\n",\r\n(pfalc->red_alarm ? "RED" : ""),\r\n(pfalc->blue_alarm ? "BLU" : ""),\r\n(pfalc->yellow_alarm ? "YEL" : ""),\r\n(pfalc->loss_fa ? "LFA" : ""),\r\n(pfalc->loss_mfa ? "LMF" : ""), (pfalc->prbs ? "PRB" : ""));\r\nCPC_UNLOCK(card, flags);\r\n}\r\nstatic int cpc_change_mtu(struct net_device *dev, int new_mtu)\r\n{\r\nif ((new_mtu < 128) || (new_mtu > PC300_DEF_MTU))\r\nreturn -EINVAL;\r\ndev->mtu = new_mtu;\r\nreturn 0;\r\n}\r\nstatic int cpc_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)\r\n{\r\npc300dev_t *d = (pc300dev_t *) dev_to_hdlc(dev)->priv;\r\npc300ch_t *chan = (pc300ch_t *) d->chan;\r\npc300_t *card = (pc300_t *) chan->card;\r\npc300conf_t conf_aux;\r\npc300chconf_t *conf = (pc300chconf_t *) & chan->conf;\r\nint ch = chan->channel;\r\nvoid __user *arg = ifr->ifr_data;\r\nstruct if_settings *settings = &ifr->ifr_settings;\r\nvoid __iomem *scabase = card->hw.scabase;\r\nif (!capable(CAP_NET_ADMIN))\r\nreturn -EPERM;\r\nswitch (cmd) {\r\ncase SIOCGPC300CONF:\r\n#ifdef CONFIG_PC300_MLPPP\r\nif (conf->proto != PC300_PROTO_MLPPP) {\r\nconf->proto = 0;\r\n}\r\n#else\r\nconf->proto = 0;\r\n#endif\r\nmemcpy(&conf_aux.conf, conf, sizeof(pc300chconf_t));\r\nmemcpy(&conf_aux.hw, &card->hw, sizeof(pc300hw_t));\r\nif (!arg ||\r\ncopy_to_user(arg, &conf_aux, sizeof(pc300conf_t)))\r\nreturn -EINVAL;\r\nreturn 0;\r\ncase SIOCSPC300CONF:\r\nif (!capable(CAP_NET_ADMIN))\r\nreturn -EPERM;\r\nif (!arg ||\r\ncopy_from_user(&conf_aux.conf, arg, sizeof(pc300chconf_t)))\r\nreturn -EINVAL;\r\nif (card->hw.cpld_id < 0x02 &&\r\nconf_aux.conf.fr_mode == PC300_FR_UNFRAMED) {\r\nreturn -EINVAL;\r\n}\r\n#ifdef CONFIG_PC300_MLPPP\r\nif (conf_aux.conf.proto == PC300_PROTO_MLPPP) {\r\nif (conf->proto != PC300_PROTO_MLPPP) {\r\nmemcpy(conf, &conf_aux.conf, sizeof(pc300chconf_t));\r\ncpc_tty_init(d);\r\n}\r\n} else {\r\nif (conf_aux.conf.proto == 0xffff) {\r\nif (conf->proto == PC300_PROTO_MLPPP){\r\ncpc_close(dev);\r\n}\r\n} else {\r\nmemcpy(conf, &conf_aux.conf, sizeof(pc300chconf_t));\r\n}\r\n}\r\n#else\r\nmemcpy(conf, &conf_aux.conf, sizeof(pc300chconf_t));\r\n#endif\r\nreturn 0;\r\ncase SIOCGPC300STATUS:\r\ncpc_sca_status(card, ch);\r\nreturn 0;\r\ncase SIOCGPC300FALCSTATUS:\r\ncpc_falc_status(card, ch);\r\nreturn 0;\r\ncase SIOCGPC300UTILSTATS:\r\n{\r\nif (!arg) {\r\nmemset(&dev->stats, 0, sizeof(dev->stats));\r\nif (card->hw.type == PC300_TE) {\r\nmemset(&chan->falc, 0, sizeof(falc_t));\r\n}\r\n} else {\r\npc300stats_t pc300stats;\r\nmemset(&pc300stats, 0, sizeof(pc300stats_t));\r\npc300stats.hw_type = card->hw.type;\r\npc300stats.line_on = card->chan[ch].d.line_on;\r\npc300stats.line_off = card->chan[ch].d.line_off;\r\nmemcpy(&pc300stats.gen_stats, &dev->stats,\r\nsizeof(dev->stats));\r\nif (card->hw.type == PC300_TE)\r\nmemcpy(&pc300stats.te_stats,&chan->falc,sizeof(falc_t));\r\nif (copy_to_user(arg, &pc300stats, sizeof(pc300stats_t)))\r\nreturn -EFAULT;\r\n}\r\nreturn 0;\r\n}\r\ncase SIOCGPC300UTILSTATUS:\r\n{\r\nstruct pc300status pc300status;\r\npc300status.hw_type = card->hw.type;\r\nif (card->hw.type == PC300_TE) {\r\npc300status.te_status.sync = chan->falc.sync;\r\npc300status.te_status.red_alarm = chan->falc.red_alarm;\r\npc300status.te_status.blue_alarm = chan->falc.blue_alarm;\r\npc300status.te_status.loss_fa = chan->falc.loss_fa;\r\npc300status.te_status.yellow_alarm =chan->falc.yellow_alarm;\r\npc300status.te_status.loss_mfa = chan->falc.loss_mfa;\r\npc300status.te_status.prbs = chan->falc.prbs;\r\n} else {\r\npc300status.gen_status.dcd =\r\n!(cpc_readb (scabase + M_REG(ST3, ch)) & ST3_DCD);\r\npc300status.gen_status.cts =\r\n!(cpc_readb (scabase + M_REG(ST3, ch)) & ST3_CTS);\r\npc300status.gen_status.rts =\r\n!(cpc_readb (scabase + M_REG(CTL, ch)) & CTL_RTS);\r\npc300status.gen_status.dtr =\r\n!(cpc_readb (scabase + M_REG(CTL, ch)) & CTL_DTR);\r\n}\r\nif (!arg ||\r\ncopy_to_user(arg, &pc300status, sizeof(pc300status_t)))\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\ncase SIOCSPC300TRACE:\r\nif (!arg || copy_from_user(&d->trace_on, arg,sizeof(unsigned char)))\r\nreturn -EINVAL;\r\nreturn 0;\r\ncase SIOCSPC300LOOPBACK:\r\n{\r\nstruct pc300loopback pc300loop;\r\nif (card->hw.type != PC300_TE)\r\nreturn -EINVAL;\r\nif (!arg ||\r\ncopy_from_user(&pc300loop, arg, sizeof(pc300loopback_t)))\r\nreturn -EINVAL;\r\nswitch (pc300loop.loop_type) {\r\ncase PC300LOCLOOP:\r\nfalc_local_loop(card, ch, pc300loop.loop_on);\r\nreturn 0;\r\ncase PC300REMLOOP:\r\nfalc_remote_loop(card, ch, pc300loop.loop_on);\r\nreturn 0;\r\ncase PC300PAYLOADLOOP:\r\nfalc_payload_loop(card, ch, pc300loop.loop_on);\r\nreturn 0;\r\ncase PC300GENLOOPUP:\r\nif (pc300loop.loop_on) {\r\nfalc_generate_loop_up_code (card, ch);\r\n} else {\r\nturn_off_xlu(card, ch);\r\n}\r\nreturn 0;\r\ncase PC300GENLOOPDOWN:\r\nif (pc300loop.loop_on) {\r\nfalc_generate_loop_down_code (card, ch);\r\n} else {\r\nturn_off_xld(card, ch);\r\n}\r\nreturn 0;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\ncase SIOCSPC300PATTERNTEST:\r\n{\r\nstruct pc300patterntst pc300patrntst;\r\nif (card->hw.type != PC300_TE)\r\nreturn -EINVAL;\r\nif (card->hw.cpld_id < 0x02) {\r\nreturn -EINVAL;\r\n}\r\nif (!arg ||\r\ncopy_from_user(&pc300patrntst,arg,sizeof(pc300patterntst_t)))\r\nreturn -EINVAL;\r\nif (pc300patrntst.patrntst_on == 2) {\r\nif (chan->falc.prbs == 0) {\r\nfalc_pattern_test(card, ch, 1);\r\n}\r\npc300patrntst.num_errors =\r\nfalc_pattern_test_error(card, ch);\r\nif (copy_to_user(arg, &pc300patrntst,\r\nsizeof(pc300patterntst_t)))\r\nreturn -EINVAL;\r\n} else {\r\nfalc_pattern_test(card, ch, pc300patrntst.patrntst_on);\r\n}\r\nreturn 0;\r\n}\r\ncase SIOCWANDEV:\r\nswitch (ifr->ifr_settings.type) {\r\ncase IF_GET_IFACE:\r\n{\r\nconst size_t size = sizeof(sync_serial_settings);\r\nifr->ifr_settings.type = conf->media;\r\nif (ifr->ifr_settings.size < size) {\r\nifr->ifr_settings.size = size;\r\nreturn -ENOBUFS;\r\n}\r\nif (copy_to_user(settings->ifs_ifsu.sync,\r\n&conf->phys_settings, size)) {\r\nreturn -EFAULT;\r\n}\r\nreturn 0;\r\n}\r\ncase IF_IFACE_V35:\r\ncase IF_IFACE_V24:\r\ncase IF_IFACE_X21:\r\n{\r\nconst size_t size = sizeof(sync_serial_settings);\r\nif (!capable(CAP_NET_ADMIN)) {\r\nreturn -EPERM;\r\n}\r\nif (ifr->ifr_settings.size != size) {\r\nreturn -ENOBUFS;\r\n}\r\nif (copy_from_user(&conf->phys_settings,\r\nsettings->ifs_ifsu.sync, size)) {\r\nreturn -EFAULT;\r\n}\r\nif (conf->phys_settings.loopback) {\r\ncpc_writeb(card->hw.scabase + M_REG(MD2, ch),\r\ncpc_readb(card->hw.scabase + M_REG(MD2, ch)) |\r\nMD2_LOOP_MIR);\r\n}\r\nconf->media = ifr->ifr_settings.type;\r\nreturn 0;\r\n}\r\ncase IF_IFACE_T1:\r\ncase IF_IFACE_E1:\r\n{\r\nconst size_t te_size = sizeof(te1_settings);\r\nconst size_t size = sizeof(sync_serial_settings);\r\nif (!capable(CAP_NET_ADMIN)) {\r\nreturn -EPERM;\r\n}\r\nif (ifr->ifr_settings.size != te_size) {\r\nreturn -ENOBUFS;\r\n}\r\nif (copy_from_user(&conf->phys_settings,\r\nsettings->ifs_ifsu.te1, size)) {\r\nreturn -EFAULT;\r\n}\r\nif (conf->phys_settings.loopback) {\r\ncpc_writeb(card->hw.scabase + M_REG(MD2, ch),\r\ncpc_readb(card->hw.scabase + M_REG(MD2, ch)) |\r\nMD2_LOOP_MIR);\r\n}\r\nconf->media = ifr->ifr_settings.type;\r\nreturn 0;\r\n}\r\ndefault:\r\nreturn hdlc_ioctl(dev, ifr, cmd);\r\n}\r\ndefault:\r\nreturn hdlc_ioctl(dev, ifr, cmd);\r\n}\r\n}\r\nstatic int clock_rate_calc(u32 rate, u32 clock, int *br_io)\r\n{\r\nint br, tc;\r\nint br_pwr, error;\r\n*br_io = 0;\r\nif (rate == 0)\r\nreturn 0;\r\nfor (br = 0, br_pwr = 1; br <= 9; br++, br_pwr <<= 1) {\r\nif ((tc = clock / br_pwr / rate) <= 0xff) {\r\n*br_io = br;\r\nbreak;\r\n}\r\n}\r\nif (tc <= 0xff) {\r\nerror = ((rate - (clock / br_pwr / rate)) / rate) * 1000;\r\nif (error < -10 || error > 10)\r\nreturn -1;\r\nelse\r\nreturn tc;\r\n} else {\r\nreturn -1;\r\n}\r\n}\r\nstatic int ch_config(pc300dev_t * d)\r\n{\r\npc300ch_t *chan = (pc300ch_t *) d->chan;\r\npc300chconf_t *conf = (pc300chconf_t *) & chan->conf;\r\npc300_t *card = (pc300_t *) chan->card;\r\nvoid __iomem *scabase = card->hw.scabase;\r\nvoid __iomem *plxbase = card->hw.plxbase;\r\nint ch = chan->channel;\r\nu32 clkrate = chan->conf.phys_settings.clock_rate;\r\nu32 clktype = chan->conf.phys_settings.clock_type;\r\nu16 encoding = chan->conf.proto_settings.encoding;\r\nu16 parity = chan->conf.proto_settings.parity;\r\nu8 md0, md2;\r\ncpc_writeb(scabase + M_REG(CMD, ch), CMD_CH_RST);\r\nswitch (parity) {\r\ncase PARITY_NONE:\r\nmd0 = MD0_BIT_SYNC;\r\nbreak;\r\ncase PARITY_CRC16_PR0:\r\nmd0 = MD0_CRC16_0|MD0_CRCC0|MD0_BIT_SYNC;\r\nbreak;\r\ncase PARITY_CRC16_PR1:\r\nmd0 = MD0_CRC16_1|MD0_CRCC0|MD0_BIT_SYNC;\r\nbreak;\r\ncase PARITY_CRC32_PR1_CCITT:\r\nmd0 = MD0_CRC32|MD0_CRCC0|MD0_BIT_SYNC;\r\nbreak;\r\ncase PARITY_CRC16_PR1_CCITT:\r\ndefault:\r\nmd0 = MD0_CRC_CCITT|MD0_CRCC0|MD0_BIT_SYNC;\r\nbreak;\r\n}\r\nswitch (encoding) {\r\ncase ENCODING_NRZI:\r\nmd2 = MD2_F_DUPLEX|MD2_ADPLL_X8|MD2_NRZI;\r\nbreak;\r\ncase ENCODING_FM_MARK:\r\nmd2 = MD2_F_DUPLEX|MD2_ADPLL_X8|MD2_FM|MD2_FM1;\r\nbreak;\r\ncase ENCODING_FM_SPACE:\r\nmd2 = MD2_F_DUPLEX|MD2_ADPLL_X8|MD2_FM|MD2_FM0;\r\nbreak;\r\ncase ENCODING_MANCHESTER:\r\nmd2 = MD2_F_DUPLEX|MD2_ADPLL_X8|MD2_FM|MD2_MANCH;\r\nbreak;\r\ncase ENCODING_NRZ:\r\ndefault:\r\nmd2 = MD2_F_DUPLEX|MD2_ADPLL_X8|MD2_NRZ;\r\nbreak;\r\n}\r\ncpc_writeb(scabase + M_REG(MD0, ch), md0);\r\ncpc_writeb(scabase + M_REG(MD1, ch), 0);\r\ncpc_writeb(scabase + M_REG(MD2, ch), md2);\r\ncpc_writeb(scabase + M_REG(IDL, ch), 0x7e);\r\ncpc_writeb(scabase + M_REG(CTL, ch), CTL_URSKP | CTL_IDLC);\r\nswitch (card->hw.type) {\r\ncase PC300_RSV:\r\nif (conf->media == IF_IFACE_V35) {\r\ncpc_writel((plxbase + card->hw.gpioc_reg),\r\ncpc_readl(plxbase + card->hw.gpioc_reg) | PC300_CHMEDIA_MASK(ch));\r\n} else {\r\ncpc_writel((plxbase + card->hw.gpioc_reg),\r\ncpc_readl(plxbase + card->hw.gpioc_reg) & ~PC300_CHMEDIA_MASK(ch));\r\n}\r\nbreak;\r\ncase PC300_X21:\r\nbreak;\r\ncase PC300_TE:\r\nte_config(card, ch);\r\nbreak;\r\n}\r\nswitch (card->hw.type) {\r\ncase PC300_RSV:\r\ncase PC300_X21:\r\nif (clktype == CLOCK_INT || clktype == CLOCK_TXINT) {\r\nint tmc, br;\r\ntmc = clock_rate_calc(clkrate, card->hw.clock, &br);\r\nif (tmc < 0)\r\nreturn -EIO;\r\ncpc_writeb(scabase + M_REG(TMCT, ch), tmc);\r\ncpc_writeb(scabase + M_REG(TXS, ch),\r\n(TXS_DTRXC | TXS_IBRG | br));\r\nif (clktype == CLOCK_INT) {\r\ncpc_writeb(scabase + M_REG(TMCR, ch), tmc);\r\ncpc_writeb(scabase + M_REG(RXS, ch),\r\n(RXS_IBRG | br));\r\n} else {\r\ncpc_writeb(scabase + M_REG(TMCR, ch), 1);\r\ncpc_writeb(scabase + M_REG(RXS, ch), 0);\r\n}\r\nif (card->hw.type == PC300_X21) {\r\ncpc_writeb(scabase + M_REG(GPO, ch), 1);\r\ncpc_writeb(scabase + M_REG(EXS, ch), EXS_TES1 | EXS_RES1);\r\n} else {\r\ncpc_writeb(scabase + M_REG(EXS, ch), EXS_TES1);\r\n}\r\n} else {\r\ncpc_writeb(scabase + M_REG(TMCT, ch), 1);\r\nif (clktype == CLOCK_EXT) {\r\ncpc_writeb(scabase + M_REG(TXS, ch),\r\nTXS_DTRXC);\r\n} else {\r\ncpc_writeb(scabase + M_REG(TXS, ch),\r\nTXS_DTRXC|TXS_RCLK);\r\n}\r\ncpc_writeb(scabase + M_REG(TMCR, ch), 1);\r\ncpc_writeb(scabase + M_REG(RXS, ch), 0);\r\nif (card->hw.type == PC300_X21) {\r\ncpc_writeb(scabase + M_REG(GPO, ch), 0);\r\ncpc_writeb(scabase + M_REG(EXS, ch), EXS_TES1 | EXS_RES1);\r\n} else {\r\ncpc_writeb(scabase + M_REG(EXS, ch), EXS_TES1);\r\n}\r\n}\r\nbreak;\r\ncase PC300_TE:\r\ncpc_writeb(scabase + M_REG(TMCT, ch), 1);\r\ncpc_writeb(scabase + M_REG(TXS, ch), 0);\r\ncpc_writeb(scabase + M_REG(TMCR, ch), 1);\r\ncpc_writeb(scabase + M_REG(RXS, ch), 0);\r\ncpc_writeb(scabase + M_REG(EXS, ch), 0);\r\nbreak;\r\n}\r\ncpc_writel(scabase + IER0,\r\ncpc_readl(scabase + IER0) |\r\nIR0_M(IR0_RXINTA, ch) |\r\nIR0_DRX(IR0_EFT | IR0_DMIA | IR0_DMIB, ch) |\r\nIR0_DTX(IR0_EFT | IR0_DMIA | IR0_DMIB, ch));\r\ncpc_writeb(scabase + M_REG(IE0, ch),\r\ncpc_readl(scabase + M_REG(IE0, ch)) | IE0_RXINTA);\r\ncpc_writeb(scabase + M_REG(IE1, ch),\r\ncpc_readl(scabase + M_REG(IE1, ch)) | IE1_CDCD);\r\nreturn 0;\r\n}\r\nstatic int rx_config(pc300dev_t * d)\r\n{\r\npc300ch_t *chan = (pc300ch_t *) d->chan;\r\npc300_t *card = (pc300_t *) chan->card;\r\nvoid __iomem *scabase = card->hw.scabase;\r\nint ch = chan->channel;\r\ncpc_writeb(scabase + DSR_RX(ch), 0);\r\ncpc_writeb(scabase + M_REG(RRC, ch), 0);\r\ncpc_writeb(scabase + M_REG(RNR, ch), 16);\r\ncpc_writeb(scabase + M_REG(CMD, ch), CMD_RX_CRC_INIT);\r\ncpc_writeb(scabase + M_REG(CMD, ch), CMD_RX_ENA);\r\nchan->rx_first_bd = 0;\r\nchan->rx_last_bd = N_DMA_RX_BUF - 1;\r\nrx_dma_buf_init(card, ch);\r\ncpc_writeb(scabase + DCR_RX(ch), DCR_FCT_CLR);\r\ncpc_writeb(scabase + DMR_RX(ch), (DMR_TMOD | DMR_NF));\r\ncpc_writeb(scabase + DIR_RX(ch), (DIR_EOM | DIR_BOF));\r\nrx_dma_start(card, ch);\r\nreturn 0;\r\n}\r\nstatic int tx_config(pc300dev_t * d)\r\n{\r\npc300ch_t *chan = (pc300ch_t *) d->chan;\r\npc300_t *card = (pc300_t *) chan->card;\r\nvoid __iomem *scabase = card->hw.scabase;\r\nint ch = chan->channel;\r\ncpc_writeb(scabase + DSR_TX(ch), 0);\r\ncpc_writeb(scabase + M_REG(TRC0, ch), 0);\r\ncpc_writeb(scabase + M_REG(TFS, ch), 32);\r\ncpc_writeb(scabase + M_REG(TNR0, ch), 20);\r\ncpc_writeb(scabase + M_REG(TNR1, ch), 48);\r\ncpc_writeb(scabase + M_REG(TCR, ch), 8);\r\ncpc_writeb(scabase + M_REG(CMD, ch), CMD_TX_CRC_INIT);\r\nchan->tx_first_bd = 0;\r\nchan->tx_next_bd = 0;\r\ntx_dma_buf_init(card, ch);\r\ncpc_writeb(scabase + DCR_TX(ch), DCR_FCT_CLR);\r\ncpc_writeb(scabase + DMR_TX(ch), (DMR_TMOD | DMR_NF));\r\ncpc_writeb(scabase + DIR_TX(ch), (DIR_EOM | DIR_BOF | DIR_UDRF));\r\ncpc_writel(scabase + DTX_REG(CDAL, ch), TX_BD_ADDR(ch, chan->tx_first_bd));\r\ncpc_writel(scabase + DTX_REG(EDAL, ch), TX_BD_ADDR(ch, chan->tx_next_bd));\r\nreturn 0;\r\n}\r\nstatic int cpc_attach(struct net_device *dev, unsigned short encoding,\r\nunsigned short parity)\r\n{\r\npc300dev_t *d = (pc300dev_t *)dev_to_hdlc(dev)->priv;\r\npc300ch_t *chan = (pc300ch_t *)d->chan;\r\npc300_t *card = (pc300_t *)chan->card;\r\npc300chconf_t *conf = (pc300chconf_t *)&chan->conf;\r\nif (card->hw.type == PC300_TE) {\r\nif (encoding != ENCODING_NRZ && encoding != ENCODING_NRZI) {\r\nreturn -EINVAL;\r\n}\r\n} else {\r\nif (encoding != ENCODING_NRZ && encoding != ENCODING_NRZI &&\r\nencoding != ENCODING_FM_MARK && encoding != ENCODING_FM_SPACE) {\r\nreturn -EINVAL;\r\n}\r\n}\r\nif (parity != PARITY_NONE && parity != PARITY_CRC16_PR0 &&\r\nparity != PARITY_CRC16_PR1 && parity != PARITY_CRC32_PR1_CCITT &&\r\nparity != PARITY_CRC16_PR1_CCITT) {\r\nreturn -EINVAL;\r\n}\r\nconf->proto_settings.encoding = encoding;\r\nconf->proto_settings.parity = parity;\r\nreturn 0;\r\n}\r\nstatic int cpc_opench(pc300dev_t * d)\r\n{\r\npc300ch_t *chan = (pc300ch_t *) d->chan;\r\npc300_t *card = (pc300_t *) chan->card;\r\nint ch = chan->channel, rc;\r\nvoid __iomem *scabase = card->hw.scabase;\r\nrc = ch_config(d);\r\nif (rc)\r\nreturn rc;\r\nrx_config(d);\r\ntx_config(d);\r\ncpc_writeb(scabase + M_REG(CTL, ch),\r\ncpc_readb(scabase + M_REG(CTL, ch)) & ~(CTL_RTS | CTL_DTR));\r\nreturn 0;\r\n}\r\nstatic void cpc_closech(pc300dev_t * d)\r\n{\r\npc300ch_t *chan = (pc300ch_t *) d->chan;\r\npc300_t *card = (pc300_t *) chan->card;\r\nfalc_t *pfalc = (falc_t *) & chan->falc;\r\nint ch = chan->channel;\r\ncpc_writeb(card->hw.scabase + M_REG(CMD, ch), CMD_CH_RST);\r\nrx_dma_stop(card, ch);\r\ntx_dma_stop(card, ch);\r\nif (card->hw.type == PC300_TE) {\r\nmemset(pfalc, 0, sizeof(falc_t));\r\ncpc_writeb(card->hw.falcbase + card->hw.cpld_reg2,\r\ncpc_readb(card->hw.falcbase + card->hw.cpld_reg2) &\r\n~((CPLD_REG2_FALC_TX_CLK | CPLD_REG2_FALC_RX_CLK |\r\nCPLD_REG2_FALC_LED2) << (2 * ch)));\r\ncpc_writeb(card->hw.falcbase + card->hw.cpld_reg1,\r\ncpc_readb(card->hw.falcbase + card->hw.cpld_reg1) |\r\n(CPLD_REG1_FALC_RESET << (2 * ch)));\r\nudelay(10000);\r\ncpc_writeb(card->hw.falcbase + card->hw.cpld_reg1,\r\ncpc_readb(card->hw.falcbase + card->hw.cpld_reg1) &\r\n~(CPLD_REG1_FALC_RESET << (2 * ch)));\r\n}\r\n}\r\nint cpc_open(struct net_device *dev)\r\n{\r\npc300dev_t *d = (pc300dev_t *) dev_to_hdlc(dev)->priv;\r\nstruct ifreq ifr;\r\nint result;\r\n#ifdef PC300_DEBUG_OTHER\r\nprintk("pc300: cpc_open");\r\n#endif\r\nresult = hdlc_open(dev);\r\nif (result)\r\nreturn result;\r\nsprintf(ifr.ifr_name, "%s", dev->name);\r\nresult = cpc_opench(d);\r\nif (result)\r\ngoto err_out;\r\nnetif_start_queue(dev);\r\nreturn 0;\r\nerr_out:\r\nhdlc_close(dev);\r\nreturn result;\r\n}\r\nstatic int cpc_close(struct net_device *dev)\r\n{\r\npc300dev_t *d = (pc300dev_t *) dev_to_hdlc(dev)->priv;\r\npc300ch_t *chan = (pc300ch_t *) d->chan;\r\npc300_t *card = (pc300_t *) chan->card;\r\nunsigned long flags;\r\n#ifdef PC300_DEBUG_OTHER\r\nprintk("pc300: cpc_close");\r\n#endif\r\nnetif_stop_queue(dev);\r\nCPC_LOCK(card, flags);\r\ncpc_closech(d);\r\nCPC_UNLOCK(card, flags);\r\nhdlc_close(dev);\r\n#ifdef CONFIG_PC300_MLPPP\r\nif (chan->conf.proto == PC300_PROTO_MLPPP) {\r\ncpc_tty_unregister_service(d);\r\nchan->conf.proto = 0xffff;\r\n}\r\n#endif\r\nreturn 0;\r\n}\r\nstatic u32 detect_ram(pc300_t * card)\r\n{\r\nu32 i;\r\nu8 data;\r\nvoid __iomem *rambase = card->hw.rambase;\r\ncard->hw.ramsize = PC300_RAMSIZE;\r\nfor (i = 0; i < card->hw.ramsize; i++) {\r\ndata = (u8)(i & 0xff);\r\ncpc_writeb(rambase + i, data);\r\nif (cpc_readb(rambase + i) != data) {\r\nbreak;\r\n}\r\n}\r\nreturn i;\r\n}\r\nstatic void plx_init(pc300_t * card)\r\n{\r\nstruct RUNTIME_9050 __iomem *plx_ctl = card->hw.plxbase;\r\ncpc_writel(&plx_ctl->init_ctrl,\r\ncpc_readl(&plx_ctl->init_ctrl) | 0x40000000);\r\nudelay(10000L);\r\ncpc_writel(&plx_ctl->init_ctrl,\r\ncpc_readl(&plx_ctl->init_ctrl) & ~0x40000000);\r\ncpc_writel(&plx_ctl->init_ctrl,\r\ncpc_readl(&plx_ctl->init_ctrl) | 0x20000000);\r\nudelay(10000L);\r\ncpc_writel(&plx_ctl->init_ctrl,\r\ncpc_readl(&plx_ctl->init_ctrl) & ~0x20000000);\r\n}\r\nstatic void show_version(void)\r\n{\r\nchar *rcsvers, *rcsdate, *tmp;\r\nrcsvers = strchr(rcsid, ' ');\r\nrcsvers++;\r\ntmp = strchr(rcsvers, ' ');\r\n*tmp++ = '\0';\r\nrcsdate = strchr(tmp, ' ');\r\nrcsdate++;\r\ntmp = strrchr(rcsdate, ' ');\r\n*tmp = '\0';\r\npr_info("Cyclades-PC300 driver %s %s\n", rcsvers, rcsdate);\r\n}\r\nstatic void cpc_init_card(pc300_t * card)\r\n{\r\nint i, devcount = 0;\r\nstatic int board_nbr = 1;\r\nplx_init(card);\r\ncpc_writew(card->hw.plxbase + card->hw.intctl_reg,\r\ncpc_readw(card->hw.plxbase + card->hw.intctl_reg) | 0x0040);\r\n#ifdef USE_PCI_CLOCK\r\ncpc_writel(card->hw.plxbase + card->hw.gpioc_reg,\r\ncpc_readl(card->hw.plxbase + card->hw.gpioc_reg) | 0x00000004UL);\r\ncard->hw.clock = PC300_PCI_CLOCK;\r\n#else\r\ncpc_writel(card->hw.plxbase + card->hw.gpioc_reg,\r\ncpc_readl(card->hw.plxbase + card->hw.gpioc_reg) & ~0x00000004UL);\r\ncard->hw.clock = PC300_OSC_CLOCK;\r\n#endif\r\ncard->hw.ramsize = detect_ram(card);\r\ncpc_writeb(card->hw.scabase + PCR, PCR_PR2);\r\ncpc_writeb(card->hw.scabase + BTCR, 0x10);\r\ncpc_writeb(card->hw.scabase + WCRL, 0);\r\ncpc_writeb(card->hw.scabase + DMER, 0x80);\r\nif (card->hw.type == PC300_TE) {\r\nu8 reg1;\r\nreg1 = cpc_readb(card->hw.falcbase + CPLD_REG1);\r\ncpc_writeb(card->hw.falcbase + CPLD_REG1, (reg1 + 0x5a));\r\nif (cpc_readb(card->hw.falcbase + CPLD_REG1) == reg1) {\r\ncard->hw.cpld_id = cpc_readb(card->hw.falcbase + CPLD_ID_REG);\r\ncard->hw.cpld_reg1 = CPLD_V2_REG1;\r\ncard->hw.cpld_reg2 = CPLD_V2_REG2;\r\n} else {\r\ncard->hw.cpld_id = 0;\r\ncard->hw.cpld_reg1 = CPLD_REG1;\r\ncard->hw.cpld_reg2 = CPLD_REG2;\r\ncpc_writeb(card->hw.falcbase + CPLD_REG1, reg1);\r\n}\r\ncpc_writeb(card->hw.falcbase + card->hw.cpld_reg1,\r\ncpc_readb(card->hw.falcbase + card->hw.cpld_reg1) |\r\nCPLD_REG1_GLOBAL_CLK);\r\n}\r\nfor (i = 0; i < card->hw.nchan; i++) {\r\npc300ch_t *chan = &card->chan[i];\r\npc300dev_t *d = &chan->d;\r\nhdlc_device *hdlc;\r\nstruct net_device *dev;\r\nchan->card = card;\r\nchan->channel = i;\r\nchan->conf.phys_settings.clock_rate = 0;\r\nchan->conf.phys_settings.clock_type = CLOCK_EXT;\r\nchan->conf.proto_settings.encoding = ENCODING_NRZ;\r\nchan->conf.proto_settings.parity = PARITY_CRC16_PR1_CCITT;\r\nswitch (card->hw.type) {\r\ncase PC300_TE:\r\nchan->conf.media = IF_IFACE_T1;\r\nchan->conf.lcode = PC300_LC_B8ZS;\r\nchan->conf.fr_mode = PC300_FR_ESF;\r\nchan->conf.lbo = PC300_LBO_0_DB;\r\nchan->conf.rx_sens = PC300_RX_SENS_SH;\r\nchan->conf.tslot_bitmap = 0xffffffffUL;\r\nbreak;\r\ncase PC300_X21:\r\nchan->conf.media = IF_IFACE_X21;\r\nbreak;\r\ncase PC300_RSV:\r\ndefault:\r\nchan->conf.media = IF_IFACE_V35;\r\nbreak;\r\n}\r\nchan->conf.proto = IF_PROTO_PPP;\r\nchan->tx_first_bd = 0;\r\nchan->tx_next_bd = 0;\r\nchan->rx_first_bd = 0;\r\nchan->rx_last_bd = N_DMA_RX_BUF - 1;\r\nchan->nfree_tx_bd = N_DMA_TX_BUF;\r\nd->chan = chan;\r\nd->trace_on = 0;\r\nd->line_on = 0;\r\nd->line_off = 0;\r\ndev = alloc_hdlcdev(d);\r\nif (dev == NULL)\r\ncontinue;\r\nhdlc = dev_to_hdlc(dev);\r\nhdlc->xmit = cpc_queue_xmit;\r\nhdlc->attach = cpc_attach;\r\nd->dev = dev;\r\ndev->mem_start = card->hw.ramphys;\r\ndev->mem_end = card->hw.ramphys + card->hw.ramsize - 1;\r\ndev->irq = card->hw.irq;\r\ndev->tx_queue_len = PC300_TX_QUEUE_LEN;\r\ndev->mtu = PC300_DEF_MTU;\r\ndev->netdev_ops = &cpc_netdev_ops;\r\ndev->watchdog_timeo = PC300_TX_TIMEOUT;\r\nif (register_hdlc_device(dev) == 0) {\r\nprintk("%s: Cyclades-PC300/", dev->name);\r\nswitch (card->hw.type) {\r\ncase PC300_TE:\r\nif (card->hw.bus == PC300_PMC) {\r\nprintk("TE-M");\r\n} else {\r\nprintk("TE ");\r\n}\r\nbreak;\r\ncase PC300_X21:\r\nprintk("X21 ");\r\nbreak;\r\ncase PC300_RSV:\r\ndefault:\r\nprintk("RSV ");\r\nbreak;\r\n}\r\nprintk (" #%d, %dKB of RAM at 0x%08x, IRQ%d, channel %d.\n",\r\nboard_nbr, card->hw.ramsize / 1024,\r\ncard->hw.ramphys, card->hw.irq, i + 1);\r\ndevcount++;\r\n} else {\r\nprintk ("Dev%d on card(0x%08x): unable to allocate i/f name.\n",\r\ni + 1, card->hw.ramphys);\r\nfree_netdev(dev);\r\ncontinue;\r\n}\r\n}\r\nspin_lock_init(&card->card_lock);\r\nboard_nbr++;\r\n}\r\nstatic int\r\ncpc_init_one(struct pci_dev *pdev, const struct pci_device_id *ent)\r\n{\r\nint err, eeprom_outdated = 0;\r\nu16 device_id;\r\npc300_t *card;\r\nif ((err = pci_enable_device(pdev)) < 0)\r\nreturn err;\r\ncard = kzalloc(sizeof(pc300_t), GFP_KERNEL);\r\nif (card == NULL) {\r\nprintk("PC300 found at RAM 0x%016llx, "\r\n"but could not allocate card structure.\n",\r\n(unsigned long long)pci_resource_start(pdev, 3));\r\nerr = -ENOMEM;\r\ngoto err_disable_dev;\r\n}\r\nerr = -ENODEV;\r\ndevice_id = ent->device;\r\ncard->hw.irq = pdev->irq;\r\ncard->hw.iophys = pci_resource_start(pdev, 1);\r\ncard->hw.iosize = pci_resource_len(pdev, 1);\r\ncard->hw.scaphys = pci_resource_start(pdev, 2);\r\ncard->hw.scasize = pci_resource_len(pdev, 2);\r\ncard->hw.ramphys = pci_resource_start(pdev, 3);\r\ncard->hw.alloc_ramsize = pci_resource_len(pdev, 3);\r\ncard->hw.falcphys = pci_resource_start(pdev, 4);\r\ncard->hw.falcsize = pci_resource_len(pdev, 4);\r\ncard->hw.plxphys = pci_resource_start(pdev, 5);\r\ncard->hw.plxsize = pci_resource_len(pdev, 5);\r\nswitch (device_id) {\r\ncase PCI_DEVICE_ID_PC300_RX_1:\r\ncase PCI_DEVICE_ID_PC300_TE_1:\r\ncase PCI_DEVICE_ID_PC300_TE_M_1:\r\ncard->hw.nchan = 1;\r\nbreak;\r\ncase PCI_DEVICE_ID_PC300_RX_2:\r\ncase PCI_DEVICE_ID_PC300_TE_2:\r\ncase PCI_DEVICE_ID_PC300_TE_M_2:\r\ndefault:\r\ncard->hw.nchan = PC300_MAXCHAN;\r\nbreak;\r\n}\r\n#ifdef PC300_DEBUG_PCI\r\nprintk("cpc (bus=0x0%x,pci_id=0x%x,", pdev->bus->number, pdev->devfn);\r\nprintk("rev_id=%d) IRQ%d\n", pdev->revision, card->hw.irq);\r\nprintk("cpc:found ramaddr=0x%08lx plxaddr=0x%08lx "\r\n"ctladdr=0x%08lx falcaddr=0x%08lx\n",\r\ncard->hw.ramphys, card->hw.plxphys, card->hw.scaphys,\r\ncard->hw.falcphys);\r\n#endif\r\nif (!request_region(card->hw.iophys, card->hw.iosize, "PLX Registers")) {\r\nprintk("WARNING: couldn't allocate I/O region for PC300 board "\r\n"at 0x%08x!\n", card->hw.ramphys);\r\n}\r\nif (card->hw.plxphys) {\r\npci_write_config_dword(pdev, PCI_BASE_ADDRESS_0, card->hw.plxphys);\r\n} else {\r\neeprom_outdated = 1;\r\ncard->hw.plxphys = pci_resource_start(pdev, 0);\r\ncard->hw.plxsize = pci_resource_len(pdev, 0);\r\n}\r\nif (!request_mem_region(card->hw.plxphys, card->hw.plxsize,\r\n"PLX Registers")) {\r\nprintk("PC300 found at RAM 0x%08x, "\r\n"but could not allocate PLX mem region.\n",\r\ncard->hw.ramphys);\r\ngoto err_release_io;\r\n}\r\nif (!request_mem_region(card->hw.ramphys, card->hw.alloc_ramsize,\r\n"On-board RAM")) {\r\nprintk("PC300 found at RAM 0x%08x, "\r\n"but could not allocate RAM mem region.\n",\r\ncard->hw.ramphys);\r\ngoto err_release_plx;\r\n}\r\nif (!request_mem_region(card->hw.scaphys, card->hw.scasize,\r\n"SCA-II Registers")) {\r\nprintk("PC300 found at RAM 0x%08x, "\r\n"but could not allocate SCA mem region.\n",\r\ncard->hw.ramphys);\r\ngoto err_release_ram;\r\n}\r\ncard->hw.plxbase = ioremap(card->hw.plxphys, card->hw.plxsize);\r\ncard->hw.rambase = ioremap(card->hw.ramphys, card->hw.alloc_ramsize);\r\ncard->hw.scabase = ioremap(card->hw.scaphys, card->hw.scasize);\r\nswitch (device_id) {\r\ncase PCI_DEVICE_ID_PC300_TE_1:\r\ncase PCI_DEVICE_ID_PC300_TE_2:\r\ncase PCI_DEVICE_ID_PC300_TE_M_1:\r\ncase PCI_DEVICE_ID_PC300_TE_M_2:\r\nrequest_mem_region(card->hw.falcphys, card->hw.falcsize,\r\n"FALC Registers");\r\ncard->hw.falcbase = ioremap(card->hw.falcphys, card->hw.falcsize);\r\nbreak;\r\ncase PCI_DEVICE_ID_PC300_RX_1:\r\ncase PCI_DEVICE_ID_PC300_RX_2:\r\ndefault:\r\ncard->hw.falcbase = NULL;\r\nbreak;\r\n}\r\n#ifdef PC300_DEBUG_PCI\r\nprintk("cpc: relocate ramaddr=0x%08lx plxaddr=0x%08lx "\r\n"ctladdr=0x%08lx falcaddr=0x%08lx\n",\r\ncard->hw.rambase, card->hw.plxbase, card->hw.scabase,\r\ncard->hw.falcbase);\r\n#endif\r\npci_set_drvdata(pdev, card);\r\nswitch (device_id) {\r\ncase PCI_DEVICE_ID_PC300_TE_1:\r\ncase PCI_DEVICE_ID_PC300_TE_2:\r\ncase PCI_DEVICE_ID_PC300_TE_M_1:\r\ncase PCI_DEVICE_ID_PC300_TE_M_2:\r\ncard->hw.type = PC300_TE;\r\nif ((device_id == PCI_DEVICE_ID_PC300_TE_M_1) ||\r\n(device_id == PCI_DEVICE_ID_PC300_TE_M_2)) {\r\ncard->hw.bus = PC300_PMC;\r\ncard->hw.gpioc_reg = 0x54;\r\ncard->hw.intctl_reg = 0x4c;\r\n} else {\r\ncard->hw.bus = PC300_PCI;\r\ncard->hw.gpioc_reg = 0x50;\r\ncard->hw.intctl_reg = 0x4c;\r\n}\r\nbreak;\r\ncase PCI_DEVICE_ID_PC300_RX_1:\r\ncase PCI_DEVICE_ID_PC300_RX_2:\r\ndefault:\r\ncard->hw.bus = PC300_PCI;\r\ncard->hw.gpioc_reg = 0x50;\r\ncard->hw.intctl_reg = 0x4c;\r\nif ((cpc_readl(card->hw.plxbase + card->hw.gpioc_reg) & PC300_CTYPE_MASK)) {\r\ncard->hw.type = PC300_X21;\r\n} else {\r\ncard->hw.type = PC300_RSV;\r\n}\r\nbreak;\r\n}\r\nif (request_irq(card->hw.irq, cpc_intr, IRQF_SHARED, "Cyclades-PC300", card)) {\r\nprintk ("PC300 found at RAM 0x%08x, but could not allocate IRQ%d.\n",\r\ncard->hw.ramphys, card->hw.irq);\r\ngoto err_io_unmap;\r\n}\r\ncpc_init_card(card);\r\nif (eeprom_outdated)\r\nprintk("WARNING: PC300 with outdated EEPROM.\n");\r\nreturn 0;\r\nerr_io_unmap:\r\niounmap(card->hw.plxbase);\r\niounmap(card->hw.scabase);\r\niounmap(card->hw.rambase);\r\nif (card->hw.type == PC300_TE) {\r\niounmap(card->hw.falcbase);\r\nrelease_mem_region(card->hw.falcphys, card->hw.falcsize);\r\n}\r\nrelease_mem_region(card->hw.scaphys, card->hw.scasize);\r\nerr_release_ram:\r\nrelease_mem_region(card->hw.ramphys, card->hw.alloc_ramsize);\r\nerr_release_plx:\r\nrelease_mem_region(card->hw.plxphys, card->hw.plxsize);\r\nerr_release_io:\r\nrelease_region(card->hw.iophys, card->hw.iosize);\r\nkfree(card);\r\nerr_disable_dev:\r\npci_disable_device(pdev);\r\nreturn err;\r\n}\r\nstatic void cpc_remove_one(struct pci_dev *pdev)\r\n{\r\npc300_t *card = pci_get_drvdata(pdev);\r\nif (card->hw.rambase) {\r\nint i;\r\ncpc_writew(card->hw.plxbase + card->hw.intctl_reg,\r\ncpc_readw(card->hw.plxbase + card->hw.intctl_reg) & ~(0x0040));\r\nfor (i = 0; i < card->hw.nchan; i++) {\r\nunregister_hdlc_device(card->chan[i].d.dev);\r\n}\r\niounmap(card->hw.plxbase);\r\niounmap(card->hw.scabase);\r\niounmap(card->hw.rambase);\r\nrelease_mem_region(card->hw.plxphys, card->hw.plxsize);\r\nrelease_mem_region(card->hw.ramphys, card->hw.alloc_ramsize);\r\nrelease_mem_region(card->hw.scaphys, card->hw.scasize);\r\nrelease_region(card->hw.iophys, card->hw.iosize);\r\nif (card->hw.type == PC300_TE) {\r\niounmap(card->hw.falcbase);\r\nrelease_mem_region(card->hw.falcphys, card->hw.falcsize);\r\n}\r\nfor (i = 0; i < card->hw.nchan; i++)\r\nif (card->chan[i].d.dev)\r\nfree_netdev(card->chan[i].d.dev);\r\nif (card->hw.irq)\r\nfree_irq(card->hw.irq, card);\r\nkfree(card);\r\npci_disable_device(pdev);\r\n}\r\n}\r\nstatic int __init cpc_init(void)\r\n{\r\nshow_version();\r\nreturn pci_register_driver(&cpc_driver);\r\n}\r\nstatic void __exit cpc_cleanup_module(void)\r\n{\r\npci_unregister_driver(&cpc_driver);\r\n}
