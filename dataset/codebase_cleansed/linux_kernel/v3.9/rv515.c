void rv515_debugfs(struct radeon_device *rdev)\r\n{\r\nif (r100_debugfs_rbbm_init(rdev)) {\r\nDRM_ERROR("Failed to register debugfs file for RBBM !\n");\r\n}\r\nif (rv515_debugfs_pipes_info_init(rdev)) {\r\nDRM_ERROR("Failed to register debugfs file for pipes !\n");\r\n}\r\nif (rv515_debugfs_ga_info_init(rdev)) {\r\nDRM_ERROR("Failed to register debugfs file for pipes !\n");\r\n}\r\n}\r\nvoid rv515_ring_start(struct radeon_device *rdev, struct radeon_ring *ring)\r\n{\r\nint r;\r\nr = radeon_ring_lock(rdev, ring, 64);\r\nif (r) {\r\nreturn;\r\n}\r\nradeon_ring_write(ring, PACKET0(ISYNC_CNTL, 0));\r\nradeon_ring_write(ring,\r\nISYNC_ANY2D_IDLE3D |\r\nISYNC_ANY3D_IDLE2D |\r\nISYNC_WAIT_IDLEGUI |\r\nISYNC_CPSCRATCH_IDLEGUI);\r\nradeon_ring_write(ring, PACKET0(WAIT_UNTIL, 0));\r\nradeon_ring_write(ring, WAIT_2D_IDLECLEAN | WAIT_3D_IDLECLEAN);\r\nradeon_ring_write(ring, PACKET0(R300_DST_PIPE_CONFIG, 0));\r\nradeon_ring_write(ring, R300_PIPE_AUTO_CONFIG);\r\nradeon_ring_write(ring, PACKET0(GB_SELECT, 0));\r\nradeon_ring_write(ring, 0);\r\nradeon_ring_write(ring, PACKET0(GB_ENABLE, 0));\r\nradeon_ring_write(ring, 0);\r\nradeon_ring_write(ring, PACKET0(R500_SU_REG_DEST, 0));\r\nradeon_ring_write(ring, (1 << rdev->num_gb_pipes) - 1);\r\nradeon_ring_write(ring, PACKET0(VAP_INDEX_OFFSET, 0));\r\nradeon_ring_write(ring, 0);\r\nradeon_ring_write(ring, PACKET0(RB3D_DSTCACHE_CTLSTAT, 0));\r\nradeon_ring_write(ring, RB3D_DC_FLUSH | RB3D_DC_FREE);\r\nradeon_ring_write(ring, PACKET0(ZB_ZCACHE_CTLSTAT, 0));\r\nradeon_ring_write(ring, ZC_FLUSH | ZC_FREE);\r\nradeon_ring_write(ring, PACKET0(WAIT_UNTIL, 0));\r\nradeon_ring_write(ring, WAIT_2D_IDLECLEAN | WAIT_3D_IDLECLEAN);\r\nradeon_ring_write(ring, PACKET0(GB_AA_CONFIG, 0));\r\nradeon_ring_write(ring, 0);\r\nradeon_ring_write(ring, PACKET0(RB3D_DSTCACHE_CTLSTAT, 0));\r\nradeon_ring_write(ring, RB3D_DC_FLUSH | RB3D_DC_FREE);\r\nradeon_ring_write(ring, PACKET0(ZB_ZCACHE_CTLSTAT, 0));\r\nradeon_ring_write(ring, ZC_FLUSH | ZC_FREE);\r\nradeon_ring_write(ring, PACKET0(GB_MSPOS0, 0));\r\nradeon_ring_write(ring,\r\n((6 << MS_X0_SHIFT) |\r\n(6 << MS_Y0_SHIFT) |\r\n(6 << MS_X1_SHIFT) |\r\n(6 << MS_Y1_SHIFT) |\r\n(6 << MS_X2_SHIFT) |\r\n(6 << MS_Y2_SHIFT) |\r\n(6 << MSBD0_Y_SHIFT) |\r\n(6 << MSBD0_X_SHIFT)));\r\nradeon_ring_write(ring, PACKET0(GB_MSPOS1, 0));\r\nradeon_ring_write(ring,\r\n((6 << MS_X3_SHIFT) |\r\n(6 << MS_Y3_SHIFT) |\r\n(6 << MS_X4_SHIFT) |\r\n(6 << MS_Y4_SHIFT) |\r\n(6 << MS_X5_SHIFT) |\r\n(6 << MS_Y5_SHIFT) |\r\n(6 << MSBD1_SHIFT)));\r\nradeon_ring_write(ring, PACKET0(GA_ENHANCE, 0));\r\nradeon_ring_write(ring, GA_DEADLOCK_CNTL | GA_FASTSYNC_CNTL);\r\nradeon_ring_write(ring, PACKET0(GA_POLY_MODE, 0));\r\nradeon_ring_write(ring, FRONT_PTYPE_TRIANGE | BACK_PTYPE_TRIANGE);\r\nradeon_ring_write(ring, PACKET0(GA_ROUND_MODE, 0));\r\nradeon_ring_write(ring, GEOMETRY_ROUND_NEAREST | COLOR_ROUND_NEAREST);\r\nradeon_ring_write(ring, PACKET0(0x20C8, 0));\r\nradeon_ring_write(ring, 0);\r\nradeon_ring_unlock_commit(rdev, ring);\r\n}\r\nint rv515_mc_wait_for_idle(struct radeon_device *rdev)\r\n{\r\nunsigned i;\r\nuint32_t tmp;\r\nfor (i = 0; i < rdev->usec_timeout; i++) {\r\ntmp = RREG32_MC(MC_STATUS);\r\nif (tmp & MC_STATUS_IDLE) {\r\nreturn 0;\r\n}\r\nDRM_UDELAY(1);\r\n}\r\nreturn -1;\r\n}\r\nvoid rv515_vga_render_disable(struct radeon_device *rdev)\r\n{\r\nWREG32(R_000300_VGA_RENDER_CONTROL,\r\nRREG32(R_000300_VGA_RENDER_CONTROL) & C_000300_VGA_VSTATUS_CNTL);\r\n}\r\nstatic void rv515_gpu_init(struct radeon_device *rdev)\r\n{\r\nunsigned pipe_select_current, gb_pipe_select, tmp;\r\nif (r100_gui_wait_for_idle(rdev)) {\r\nprintk(KERN_WARNING "Failed to wait GUI idle while "\r\n"resetting GPU. Bad things might happen.\n");\r\n}\r\nrv515_vga_render_disable(rdev);\r\nr420_pipes_init(rdev);\r\ngb_pipe_select = RREG32(R400_GB_PIPE_SELECT);\r\ntmp = RREG32(R300_DST_PIPE_CONFIG);\r\npipe_select_current = (tmp >> 2) & 3;\r\ntmp = (1 << pipe_select_current) |\r\n(((gb_pipe_select >> 8) & 0xF) << 4);\r\nWREG32_PLL(0x000D, tmp);\r\nif (r100_gui_wait_for_idle(rdev)) {\r\nprintk(KERN_WARNING "Failed to wait GUI idle while "\r\n"resetting GPU. Bad things might happen.\n");\r\n}\r\nif (rv515_mc_wait_for_idle(rdev)) {\r\nprintk(KERN_WARNING "Failed to wait MC idle while "\r\n"programming pipes. Bad things might happen.\n");\r\n}\r\n}\r\nstatic void rv515_vram_get_type(struct radeon_device *rdev)\r\n{\r\nuint32_t tmp;\r\nrdev->mc.vram_width = 128;\r\nrdev->mc.vram_is_ddr = true;\r\ntmp = RREG32_MC(RV515_MC_CNTL) & MEM_NUM_CHANNELS_MASK;\r\nswitch (tmp) {\r\ncase 0:\r\nrdev->mc.vram_width = 64;\r\nbreak;\r\ncase 1:\r\nrdev->mc.vram_width = 128;\r\nbreak;\r\ndefault:\r\nrdev->mc.vram_width = 128;\r\nbreak;\r\n}\r\n}\r\nstatic void rv515_mc_init(struct radeon_device *rdev)\r\n{\r\nrv515_vram_get_type(rdev);\r\nr100_vram_init_sizes(rdev);\r\nradeon_vram_location(rdev, &rdev->mc, 0);\r\nrdev->mc.gtt_base_align = 0;\r\nif (!(rdev->flags & RADEON_IS_AGP))\r\nradeon_gtt_location(rdev, &rdev->mc);\r\nradeon_update_bandwidth_info(rdev);\r\n}\r\nuint32_t rv515_mc_rreg(struct radeon_device *rdev, uint32_t reg)\r\n{\r\nuint32_t r;\r\nWREG32(MC_IND_INDEX, 0x7f0000 | (reg & 0xffff));\r\nr = RREG32(MC_IND_DATA);\r\nWREG32(MC_IND_INDEX, 0);\r\nreturn r;\r\n}\r\nvoid rv515_mc_wreg(struct radeon_device *rdev, uint32_t reg, uint32_t v)\r\n{\r\nWREG32(MC_IND_INDEX, 0xff0000 | ((reg) & 0xffff));\r\nWREG32(MC_IND_DATA, (v));\r\nWREG32(MC_IND_INDEX, 0);\r\n}\r\nstatic int rv515_debugfs_pipes_info(struct seq_file *m, void *data)\r\n{\r\nstruct drm_info_node *node = (struct drm_info_node *) m->private;\r\nstruct drm_device *dev = node->minor->dev;\r\nstruct radeon_device *rdev = dev->dev_private;\r\nuint32_t tmp;\r\ntmp = RREG32(GB_PIPE_SELECT);\r\nseq_printf(m, "GB_PIPE_SELECT 0x%08x\n", tmp);\r\ntmp = RREG32(SU_REG_DEST);\r\nseq_printf(m, "SU_REG_DEST 0x%08x\n", tmp);\r\ntmp = RREG32(GB_TILE_CONFIG);\r\nseq_printf(m, "GB_TILE_CONFIG 0x%08x\n", tmp);\r\ntmp = RREG32(DST_PIPE_CONFIG);\r\nseq_printf(m, "DST_PIPE_CONFIG 0x%08x\n", tmp);\r\nreturn 0;\r\n}\r\nstatic int rv515_debugfs_ga_info(struct seq_file *m, void *data)\r\n{\r\nstruct drm_info_node *node = (struct drm_info_node *) m->private;\r\nstruct drm_device *dev = node->minor->dev;\r\nstruct radeon_device *rdev = dev->dev_private;\r\nuint32_t tmp;\r\ntmp = RREG32(0x2140);\r\nseq_printf(m, "VAP_CNTL_STATUS 0x%08x\n", tmp);\r\nradeon_asic_reset(rdev);\r\ntmp = RREG32(0x425C);\r\nseq_printf(m, "GA_IDLE 0x%08x\n", tmp);\r\nreturn 0;\r\n}\r\nstatic int rv515_debugfs_pipes_info_init(struct radeon_device *rdev)\r\n{\r\n#if defined(CONFIG_DEBUG_FS)\r\nreturn radeon_debugfs_add_files(rdev, rv515_pipes_info_list, 1);\r\n#else\r\nreturn 0;\r\n#endif\r\n}\r\nstatic int rv515_debugfs_ga_info_init(struct radeon_device *rdev)\r\n{\r\n#if defined(CONFIG_DEBUG_FS)\r\nreturn radeon_debugfs_add_files(rdev, rv515_ga_info_list, 1);\r\n#else\r\nreturn 0;\r\n#endif\r\n}\r\nvoid rv515_mc_stop(struct radeon_device *rdev, struct rv515_mc_save *save)\r\n{\r\nu32 crtc_enabled, tmp, frame_count, blackout;\r\nint i, j;\r\nsave->vga_render_control = RREG32(R_000300_VGA_RENDER_CONTROL);\r\nsave->vga_hdp_control = RREG32(R_000328_VGA_HDP_CONTROL);\r\nWREG32(R_000300_VGA_RENDER_CONTROL, 0);\r\nfor (i = 0; i < rdev->num_crtc; i++) {\r\ncrtc_enabled = RREG32(AVIVO_D1CRTC_CONTROL + crtc_offsets[i]) & AVIVO_CRTC_EN;\r\nif (crtc_enabled) {\r\nsave->crtc_enabled[i] = true;\r\ntmp = RREG32(AVIVO_D1CRTC_CONTROL + crtc_offsets[i]);\r\nif (!(tmp & AVIVO_CRTC_DISP_READ_REQUEST_DISABLE)) {\r\nradeon_wait_for_vblank(rdev, i);\r\ntmp |= AVIVO_CRTC_DISP_READ_REQUEST_DISABLE;\r\nWREG32(AVIVO_D1CRTC_CONTROL + crtc_offsets[i], tmp);\r\n}\r\nframe_count = radeon_get_vblank_counter(rdev, i);\r\nfor (j = 0; j < rdev->usec_timeout; j++) {\r\nif (radeon_get_vblank_counter(rdev, i) != frame_count)\r\nbreak;\r\nudelay(1);\r\n}\r\n} else {\r\nsave->crtc_enabled[i] = false;\r\n}\r\n}\r\nradeon_mc_wait_for_idle(rdev);\r\nif (rdev->family >= CHIP_R600) {\r\nif (rdev->family >= CHIP_RV770)\r\nblackout = RREG32(R700_MC_CITF_CNTL);\r\nelse\r\nblackout = RREG32(R600_CITF_CNTL);\r\nif ((blackout & R600_BLACKOUT_MASK) != R600_BLACKOUT_MASK) {\r\nWREG32(R600_BIF_FB_EN, 0);\r\nblackout |= R600_BLACKOUT_MASK;\r\nif (rdev->family >= CHIP_RV770)\r\nWREG32(R700_MC_CITF_CNTL, blackout);\r\nelse\r\nWREG32(R600_CITF_CNTL, blackout);\r\n}\r\n}\r\nudelay(100);\r\n}\r\nvoid rv515_mc_resume(struct radeon_device *rdev, struct rv515_mc_save *save)\r\n{\r\nu32 tmp, frame_count;\r\nint i, j;\r\nfor (i = 0; i < rdev->num_crtc; i++) {\r\nif (rdev->family >= CHIP_RV770) {\r\nif (i == 1) {\r\nWREG32(R700_D1GRPH_PRIMARY_SURFACE_ADDRESS_HIGH,\r\nupper_32_bits(rdev->mc.vram_start));\r\nWREG32(R700_D1GRPH_SECONDARY_SURFACE_ADDRESS_HIGH,\r\nupper_32_bits(rdev->mc.vram_start));\r\n} else {\r\nWREG32(R700_D2GRPH_PRIMARY_SURFACE_ADDRESS_HIGH,\r\nupper_32_bits(rdev->mc.vram_start));\r\nWREG32(R700_D2GRPH_SECONDARY_SURFACE_ADDRESS_HIGH,\r\nupper_32_bits(rdev->mc.vram_start));\r\n}\r\n}\r\nWREG32(R_006110_D1GRPH_PRIMARY_SURFACE_ADDRESS + crtc_offsets[i],\r\n(u32)rdev->mc.vram_start);\r\nWREG32(R_006118_D1GRPH_SECONDARY_SURFACE_ADDRESS + crtc_offsets[i],\r\n(u32)rdev->mc.vram_start);\r\n}\r\nWREG32(R_000310_VGA_MEMORY_BASE_ADDRESS, (u32)rdev->mc.vram_start);\r\nif (rdev->family >= CHIP_R600) {\r\nif (rdev->family >= CHIP_RV770)\r\ntmp = RREG32(R700_MC_CITF_CNTL);\r\nelse\r\ntmp = RREG32(R600_CITF_CNTL);\r\ntmp &= ~R600_BLACKOUT_MASK;\r\nif (rdev->family >= CHIP_RV770)\r\nWREG32(R700_MC_CITF_CNTL, tmp);\r\nelse\r\nWREG32(R600_CITF_CNTL, tmp);\r\nWREG32(R600_BIF_FB_EN, R600_FB_READ_EN | R600_FB_WRITE_EN);\r\n}\r\nfor (i = 0; i < rdev->num_crtc; i++) {\r\nif (save->crtc_enabled[i]) {\r\ntmp = RREG32(AVIVO_D1CRTC_CONTROL + crtc_offsets[i]);\r\ntmp &= ~AVIVO_CRTC_DISP_READ_REQUEST_DISABLE;\r\nWREG32(AVIVO_D1CRTC_CONTROL + crtc_offsets[i], tmp);\r\nframe_count = radeon_get_vblank_counter(rdev, i);\r\nfor (j = 0; j < rdev->usec_timeout; j++) {\r\nif (radeon_get_vblank_counter(rdev, i) != frame_count)\r\nbreak;\r\nudelay(1);\r\n}\r\n}\r\n}\r\nWREG32(R_000328_VGA_HDP_CONTROL, save->vga_hdp_control);\r\nmdelay(1);\r\nWREG32(R_000300_VGA_RENDER_CONTROL, save->vga_render_control);\r\n}\r\nstatic void rv515_mc_program(struct radeon_device *rdev)\r\n{\r\nstruct rv515_mc_save save;\r\nrv515_mc_stop(rdev, &save);\r\nif (rv515_mc_wait_for_idle(rdev))\r\ndev_warn(rdev->dev, "Wait MC idle timeout before updating MC.\n");\r\nWREG32(R_0000F8_CONFIG_MEMSIZE, rdev->mc.real_vram_size);\r\nWREG32_MC(R_000001_MC_FB_LOCATION,\r\nS_000001_MC_FB_START(rdev->mc.vram_start >> 16) |\r\nS_000001_MC_FB_TOP(rdev->mc.vram_end >> 16));\r\nWREG32(R_000134_HDP_FB_LOCATION,\r\nS_000134_HDP_FB_START(rdev->mc.vram_start >> 16));\r\nif (rdev->flags & RADEON_IS_AGP) {\r\nWREG32_MC(R_000002_MC_AGP_LOCATION,\r\nS_000002_MC_AGP_START(rdev->mc.gtt_start >> 16) |\r\nS_000002_MC_AGP_TOP(rdev->mc.gtt_end >> 16));\r\nWREG32_MC(R_000003_MC_AGP_BASE, lower_32_bits(rdev->mc.agp_base));\r\nWREG32_MC(R_000004_MC_AGP_BASE_2,\r\nS_000004_AGP_BASE_ADDR_2(upper_32_bits(rdev->mc.agp_base)));\r\n} else {\r\nWREG32_MC(R_000002_MC_AGP_LOCATION, 0xFFFFFFFF);\r\nWREG32_MC(R_000003_MC_AGP_BASE, 0);\r\nWREG32_MC(R_000004_MC_AGP_BASE_2, 0);\r\n}\r\nrv515_mc_resume(rdev, &save);\r\n}\r\nvoid rv515_clock_startup(struct radeon_device *rdev)\r\n{\r\nif (radeon_dynclks != -1 && radeon_dynclks)\r\nradeon_atom_set_clock_gating(rdev, 1);\r\nWREG32_PLL(R_00000F_CP_DYN_CNTL,\r\nRREG32_PLL(R_00000F_CP_DYN_CNTL) | S_00000F_CP_FORCEON(1));\r\nWREG32_PLL(R_000011_E2_DYN_CNTL,\r\nRREG32_PLL(R_000011_E2_DYN_CNTL) | S_000011_E2_FORCEON(1));\r\nWREG32_PLL(R_000013_IDCT_DYN_CNTL,\r\nRREG32_PLL(R_000013_IDCT_DYN_CNTL) | S_000013_IDCT_FORCEON(1));\r\n}\r\nstatic int rv515_startup(struct radeon_device *rdev)\r\n{\r\nint r;\r\nrv515_mc_program(rdev);\r\nrv515_clock_startup(rdev);\r\nrv515_gpu_init(rdev);\r\nif (rdev->flags & RADEON_IS_PCIE) {\r\nr = rv370_pcie_gart_enable(rdev);\r\nif (r)\r\nreturn r;\r\n}\r\nr = radeon_wb_init(rdev);\r\nif (r)\r\nreturn r;\r\nr = radeon_fence_driver_start_ring(rdev, RADEON_RING_TYPE_GFX_INDEX);\r\nif (r) {\r\ndev_err(rdev->dev, "failed initializing CP fences (%d).\n", r);\r\nreturn r;\r\n}\r\nrs600_irq_set(rdev);\r\nrdev->config.r300.hdp_cntl = RREG32(RADEON_HOST_PATH_CNTL);\r\nr = r100_cp_init(rdev, 1024 * 1024);\r\nif (r) {\r\ndev_err(rdev->dev, "failed initializing CP (%d).\n", r);\r\nreturn r;\r\n}\r\nr = radeon_ib_pool_init(rdev);\r\nif (r) {\r\ndev_err(rdev->dev, "IB initialization failed (%d).\n", r);\r\nreturn r;\r\n}\r\nreturn 0;\r\n}\r\nint rv515_resume(struct radeon_device *rdev)\r\n{\r\nint r;\r\nif (rdev->flags & RADEON_IS_PCIE)\r\nrv370_pcie_gart_disable(rdev);\r\nrv515_clock_startup(rdev);\r\nif (radeon_asic_reset(rdev)) {\r\ndev_warn(rdev->dev, "GPU reset failed ! (0xE40=0x%08X, 0x7C0=0x%08X)\n",\r\nRREG32(R_000E40_RBBM_STATUS),\r\nRREG32(R_0007C0_CP_STAT));\r\n}\r\natom_asic_init(rdev->mode_info.atom_context);\r\nrv515_clock_startup(rdev);\r\nradeon_surface_init(rdev);\r\nrdev->accel_working = true;\r\nr = rv515_startup(rdev);\r\nif (r) {\r\nrdev->accel_working = false;\r\n}\r\nreturn r;\r\n}\r\nint rv515_suspend(struct radeon_device *rdev)\r\n{\r\nr100_cp_disable(rdev);\r\nradeon_wb_disable(rdev);\r\nrs600_irq_disable(rdev);\r\nif (rdev->flags & RADEON_IS_PCIE)\r\nrv370_pcie_gart_disable(rdev);\r\nreturn 0;\r\n}\r\nvoid rv515_set_safe_registers(struct radeon_device *rdev)\r\n{\r\nrdev->config.r300.reg_safe_bm = rv515_reg_safe_bm;\r\nrdev->config.r300.reg_safe_bm_size = ARRAY_SIZE(rv515_reg_safe_bm);\r\n}\r\nvoid rv515_fini(struct radeon_device *rdev)\r\n{\r\nr100_cp_fini(rdev);\r\nradeon_wb_fini(rdev);\r\nradeon_ib_pool_fini(rdev);\r\nradeon_gem_fini(rdev);\r\nrv370_pcie_gart_fini(rdev);\r\nradeon_agp_fini(rdev);\r\nradeon_irq_kms_fini(rdev);\r\nradeon_fence_driver_fini(rdev);\r\nradeon_bo_fini(rdev);\r\nradeon_atombios_fini(rdev);\r\nkfree(rdev->bios);\r\nrdev->bios = NULL;\r\n}\r\nint rv515_init(struct radeon_device *rdev)\r\n{\r\nint r;\r\nradeon_scratch_init(rdev);\r\nradeon_surface_init(rdev);\r\nr100_restore_sanity(rdev);\r\nif (!radeon_get_bios(rdev)) {\r\nif (ASIC_IS_AVIVO(rdev))\r\nreturn -EINVAL;\r\n}\r\nif (rdev->is_atom_bios) {\r\nr = radeon_atombios_init(rdev);\r\nif (r)\r\nreturn r;\r\n} else {\r\ndev_err(rdev->dev, "Expecting atombios for RV515 GPU\n");\r\nreturn -EINVAL;\r\n}\r\nif (radeon_asic_reset(rdev)) {\r\ndev_warn(rdev->dev,\r\n"GPU reset failed ! (0xE40=0x%08X, 0x7C0=0x%08X)\n",\r\nRREG32(R_000E40_RBBM_STATUS),\r\nRREG32(R_0007C0_CP_STAT));\r\n}\r\nif (radeon_boot_test_post_card(rdev) == false)\r\nreturn -EINVAL;\r\nradeon_get_clock_info(rdev->ddev);\r\nif (rdev->flags & RADEON_IS_AGP) {\r\nr = radeon_agp_init(rdev);\r\nif (r) {\r\nradeon_agp_disable(rdev);\r\n}\r\n}\r\nrv515_mc_init(rdev);\r\nrv515_debugfs(rdev);\r\nr = radeon_fence_driver_init(rdev);\r\nif (r)\r\nreturn r;\r\nr = radeon_irq_kms_init(rdev);\r\nif (r)\r\nreturn r;\r\nr = radeon_bo_init(rdev);\r\nif (r)\r\nreturn r;\r\nr = rv370_pcie_gart_init(rdev);\r\nif (r)\r\nreturn r;\r\nrv515_set_safe_registers(rdev);\r\nrdev->accel_working = true;\r\nr = rv515_startup(rdev);\r\nif (r) {\r\ndev_err(rdev->dev, "Disabling GPU acceleration\n");\r\nr100_cp_fini(rdev);\r\nradeon_wb_fini(rdev);\r\nradeon_ib_pool_fini(rdev);\r\nradeon_irq_kms_fini(rdev);\r\nrv370_pcie_gart_fini(rdev);\r\nradeon_agp_fini(rdev);\r\nrdev->accel_working = false;\r\n}\r\nreturn 0;\r\n}\r\nvoid atom_rv515_force_tv_scaler(struct radeon_device *rdev, struct radeon_crtc *crtc)\r\n{\r\nint index_reg = 0x6578 + crtc->crtc_offset;\r\nint data_reg = 0x657c + crtc->crtc_offset;\r\nWREG32(0x659C + crtc->crtc_offset, 0x0);\r\nWREG32(0x6594 + crtc->crtc_offset, 0x705);\r\nWREG32(0x65A4 + crtc->crtc_offset, 0x10001);\r\nWREG32(0x65D8 + crtc->crtc_offset, 0x0);\r\nWREG32(0x65B0 + crtc->crtc_offset, 0x0);\r\nWREG32(0x65C0 + crtc->crtc_offset, 0x0);\r\nWREG32(0x65D4 + crtc->crtc_offset, 0x0);\r\nWREG32(index_reg, 0x0);\r\nWREG32(data_reg, 0x841880A8);\r\nWREG32(index_reg, 0x1);\r\nWREG32(data_reg, 0x84208680);\r\nWREG32(index_reg, 0x2);\r\nWREG32(data_reg, 0xBFF880B0);\r\nWREG32(index_reg, 0x100);\r\nWREG32(data_reg, 0x83D88088);\r\nWREG32(index_reg, 0x101);\r\nWREG32(data_reg, 0x84608680);\r\nWREG32(index_reg, 0x102);\r\nWREG32(data_reg, 0xBFF080D0);\r\nWREG32(index_reg, 0x200);\r\nWREG32(data_reg, 0x83988068);\r\nWREG32(index_reg, 0x201);\r\nWREG32(data_reg, 0x84A08680);\r\nWREG32(index_reg, 0x202);\r\nWREG32(data_reg, 0xBFF080F8);\r\nWREG32(index_reg, 0x300);\r\nWREG32(data_reg, 0x83588058);\r\nWREG32(index_reg, 0x301);\r\nWREG32(data_reg, 0x84E08660);\r\nWREG32(index_reg, 0x302);\r\nWREG32(data_reg, 0xBFF88120);\r\nWREG32(index_reg, 0x400);\r\nWREG32(data_reg, 0x83188040);\r\nWREG32(index_reg, 0x401);\r\nWREG32(data_reg, 0x85008660);\r\nWREG32(index_reg, 0x402);\r\nWREG32(data_reg, 0xBFF88150);\r\nWREG32(index_reg, 0x500);\r\nWREG32(data_reg, 0x82D88030);\r\nWREG32(index_reg, 0x501);\r\nWREG32(data_reg, 0x85408640);\r\nWREG32(index_reg, 0x502);\r\nWREG32(data_reg, 0xBFF88180);\r\nWREG32(index_reg, 0x600);\r\nWREG32(data_reg, 0x82A08018);\r\nWREG32(index_reg, 0x601);\r\nWREG32(data_reg, 0x85808620);\r\nWREG32(index_reg, 0x602);\r\nWREG32(data_reg, 0xBFF081B8);\r\nWREG32(index_reg, 0x700);\r\nWREG32(data_reg, 0x82608010);\r\nWREG32(index_reg, 0x701);\r\nWREG32(data_reg, 0x85A08600);\r\nWREG32(index_reg, 0x702);\r\nWREG32(data_reg, 0x800081F0);\r\nWREG32(index_reg, 0x800);\r\nWREG32(data_reg, 0x8228BFF8);\r\nWREG32(index_reg, 0x801);\r\nWREG32(data_reg, 0x85E085E0);\r\nWREG32(index_reg, 0x802);\r\nWREG32(data_reg, 0xBFF88228);\r\nWREG32(index_reg, 0x10000);\r\nWREG32(data_reg, 0x82A8BF00);\r\nWREG32(index_reg, 0x10001);\r\nWREG32(data_reg, 0x82A08CC0);\r\nWREG32(index_reg, 0x10002);\r\nWREG32(data_reg, 0x8008BEF8);\r\nWREG32(index_reg, 0x10100);\r\nWREG32(data_reg, 0x81F0BF28);\r\nWREG32(index_reg, 0x10101);\r\nWREG32(data_reg, 0x83608CA0);\r\nWREG32(index_reg, 0x10102);\r\nWREG32(data_reg, 0x8018BED0);\r\nWREG32(index_reg, 0x10200);\r\nWREG32(data_reg, 0x8148BF38);\r\nWREG32(index_reg, 0x10201);\r\nWREG32(data_reg, 0x84408C80);\r\nWREG32(index_reg, 0x10202);\r\nWREG32(data_reg, 0x8008BEB8);\r\nWREG32(index_reg, 0x10300);\r\nWREG32(data_reg, 0x80B0BF78);\r\nWREG32(index_reg, 0x10301);\r\nWREG32(data_reg, 0x85008C20);\r\nWREG32(index_reg, 0x10302);\r\nWREG32(data_reg, 0x8020BEA0);\r\nWREG32(index_reg, 0x10400);\r\nWREG32(data_reg, 0x8028BF90);\r\nWREG32(index_reg, 0x10401);\r\nWREG32(data_reg, 0x85E08BC0);\r\nWREG32(index_reg, 0x10402);\r\nWREG32(data_reg, 0x8018BE90);\r\nWREG32(index_reg, 0x10500);\r\nWREG32(data_reg, 0xBFB8BFB0);\r\nWREG32(index_reg, 0x10501);\r\nWREG32(data_reg, 0x86C08B40);\r\nWREG32(index_reg, 0x10502);\r\nWREG32(data_reg, 0x8010BE90);\r\nWREG32(index_reg, 0x10600);\r\nWREG32(data_reg, 0xBF58BFC8);\r\nWREG32(index_reg, 0x10601);\r\nWREG32(data_reg, 0x87A08AA0);\r\nWREG32(index_reg, 0x10602);\r\nWREG32(data_reg, 0x8010BE98);\r\nWREG32(index_reg, 0x10700);\r\nWREG32(data_reg, 0xBF10BFF0);\r\nWREG32(index_reg, 0x10701);\r\nWREG32(data_reg, 0x886089E0);\r\nWREG32(index_reg, 0x10702);\r\nWREG32(data_reg, 0x8018BEB0);\r\nWREG32(index_reg, 0x10800);\r\nWREG32(data_reg, 0xBED8BFE8);\r\nWREG32(index_reg, 0x10801);\r\nWREG32(data_reg, 0x89408940);\r\nWREG32(index_reg, 0x10802);\r\nWREG32(data_reg, 0xBFE8BED8);\r\nWREG32(index_reg, 0x20000);\r\nWREG32(data_reg, 0x80008000);\r\nWREG32(index_reg, 0x20001);\r\nWREG32(data_reg, 0x90008000);\r\nWREG32(index_reg, 0x20002);\r\nWREG32(data_reg, 0x80008000);\r\nWREG32(index_reg, 0x20003);\r\nWREG32(data_reg, 0x80008000);\r\nWREG32(index_reg, 0x20100);\r\nWREG32(data_reg, 0x80108000);\r\nWREG32(index_reg, 0x20101);\r\nWREG32(data_reg, 0x8FE0BF70);\r\nWREG32(index_reg, 0x20102);\r\nWREG32(data_reg, 0xBFE880C0);\r\nWREG32(index_reg, 0x20103);\r\nWREG32(data_reg, 0x80008000);\r\nWREG32(index_reg, 0x20200);\r\nWREG32(data_reg, 0x8018BFF8);\r\nWREG32(index_reg, 0x20201);\r\nWREG32(data_reg, 0x8F80BF08);\r\nWREG32(index_reg, 0x20202);\r\nWREG32(data_reg, 0xBFD081A0);\r\nWREG32(index_reg, 0x20203);\r\nWREG32(data_reg, 0xBFF88000);\r\nWREG32(index_reg, 0x20300);\r\nWREG32(data_reg, 0x80188000);\r\nWREG32(index_reg, 0x20301);\r\nWREG32(data_reg, 0x8EE0BEC0);\r\nWREG32(index_reg, 0x20302);\r\nWREG32(data_reg, 0xBFB082A0);\r\nWREG32(index_reg, 0x20303);\r\nWREG32(data_reg, 0x80008000);\r\nWREG32(index_reg, 0x20400);\r\nWREG32(data_reg, 0x80188000);\r\nWREG32(index_reg, 0x20401);\r\nWREG32(data_reg, 0x8E00BEA0);\r\nWREG32(index_reg, 0x20402);\r\nWREG32(data_reg, 0xBF8883C0);\r\nWREG32(index_reg, 0x20403);\r\nWREG32(data_reg, 0x80008000);\r\nWREG32(index_reg, 0x20500);\r\nWREG32(data_reg, 0x80188000);\r\nWREG32(index_reg, 0x20501);\r\nWREG32(data_reg, 0x8D00BE90);\r\nWREG32(index_reg, 0x20502);\r\nWREG32(data_reg, 0xBF588500);\r\nWREG32(index_reg, 0x20503);\r\nWREG32(data_reg, 0x80008008);\r\nWREG32(index_reg, 0x20600);\r\nWREG32(data_reg, 0x80188000);\r\nWREG32(index_reg, 0x20601);\r\nWREG32(data_reg, 0x8BC0BE98);\r\nWREG32(index_reg, 0x20602);\r\nWREG32(data_reg, 0xBF308660);\r\nWREG32(index_reg, 0x20603);\r\nWREG32(data_reg, 0x80008008);\r\nWREG32(index_reg, 0x20700);\r\nWREG32(data_reg, 0x80108000);\r\nWREG32(index_reg, 0x20701);\r\nWREG32(data_reg, 0x8A80BEB0);\r\nWREG32(index_reg, 0x20702);\r\nWREG32(data_reg, 0xBF0087C0);\r\nWREG32(index_reg, 0x20703);\r\nWREG32(data_reg, 0x80008008);\r\nWREG32(index_reg, 0x20800);\r\nWREG32(data_reg, 0x80108000);\r\nWREG32(index_reg, 0x20801);\r\nWREG32(data_reg, 0x8920BED0);\r\nWREG32(index_reg, 0x20802);\r\nWREG32(data_reg, 0xBED08920);\r\nWREG32(index_reg, 0x20803);\r\nWREG32(data_reg, 0x80008010);\r\nWREG32(index_reg, 0x30000);\r\nWREG32(data_reg, 0x90008000);\r\nWREG32(index_reg, 0x30001);\r\nWREG32(data_reg, 0x80008000);\r\nWREG32(index_reg, 0x30100);\r\nWREG32(data_reg, 0x8FE0BF90);\r\nWREG32(index_reg, 0x30101);\r\nWREG32(data_reg, 0xBFF880A0);\r\nWREG32(index_reg, 0x30200);\r\nWREG32(data_reg, 0x8F60BF40);\r\nWREG32(index_reg, 0x30201);\r\nWREG32(data_reg, 0xBFE88180);\r\nWREG32(index_reg, 0x30300);\r\nWREG32(data_reg, 0x8EC0BF00);\r\nWREG32(index_reg, 0x30301);\r\nWREG32(data_reg, 0xBFC88280);\r\nWREG32(index_reg, 0x30400);\r\nWREG32(data_reg, 0x8DE0BEE0);\r\nWREG32(index_reg, 0x30401);\r\nWREG32(data_reg, 0xBFA083A0);\r\nWREG32(index_reg, 0x30500);\r\nWREG32(data_reg, 0x8CE0BED0);\r\nWREG32(index_reg, 0x30501);\r\nWREG32(data_reg, 0xBF7884E0);\r\nWREG32(index_reg, 0x30600);\r\nWREG32(data_reg, 0x8BA0BED8);\r\nWREG32(index_reg, 0x30601);\r\nWREG32(data_reg, 0xBF508640);\r\nWREG32(index_reg, 0x30700);\r\nWREG32(data_reg, 0x8A60BEE8);\r\nWREG32(index_reg, 0x30701);\r\nWREG32(data_reg, 0xBF2087A0);\r\nWREG32(index_reg, 0x30800);\r\nWREG32(data_reg, 0x8900BF00);\r\nWREG32(index_reg, 0x30801);\r\nWREG32(data_reg, 0xBF008900);\r\n}\r\nstatic void rv515_crtc_bandwidth_compute(struct radeon_device *rdev,\r\nstruct radeon_crtc *crtc,\r\nstruct rv515_watermark *wm)\r\n{\r\nstruct drm_display_mode *mode = &crtc->base.mode;\r\nfixed20_12 a, b, c;\r\nfixed20_12 pclk, request_fifo_depth, tolerable_latency, estimated_width;\r\nfixed20_12 consumption_time, line_time, chunk_time, read_delay_latency;\r\nif (!crtc->base.enabled) {\r\nwm->lb_request_fifo_depth = 4;\r\nreturn;\r\n}\r\nif (crtc->vsc.full > dfixed_const(2))\r\nwm->num_line_pair.full = dfixed_const(2);\r\nelse\r\nwm->num_line_pair.full = dfixed_const(1);\r\nb.full = dfixed_const(mode->crtc_hdisplay);\r\nc.full = dfixed_const(256);\r\na.full = dfixed_div(b, c);\r\nrequest_fifo_depth.full = dfixed_mul(a, wm->num_line_pair);\r\nrequest_fifo_depth.full = dfixed_ceil(request_fifo_depth);\r\nif (a.full < dfixed_const(4)) {\r\nwm->lb_request_fifo_depth = 4;\r\n} else {\r\nwm->lb_request_fifo_depth = dfixed_trunc(request_fifo_depth);\r\n}\r\na.full = dfixed_const(mode->clock);\r\nb.full = dfixed_const(1000);\r\na.full = dfixed_div(a, b);\r\npclk.full = dfixed_div(b, a);\r\nif (crtc->rmx_type != RMX_OFF) {\r\nb.full = dfixed_const(2);\r\nif (crtc->vsc.full > b.full)\r\nb.full = crtc->vsc.full;\r\nb.full = dfixed_mul(b, crtc->hsc);\r\nc.full = dfixed_const(2);\r\nb.full = dfixed_div(b, c);\r\nconsumption_time.full = dfixed_div(pclk, b);\r\n} else {\r\nconsumption_time.full = pclk.full;\r\n}\r\na.full = dfixed_const(1);\r\nwm->consumption_rate.full = dfixed_div(a, consumption_time);\r\na.full = dfixed_const(crtc->base.mode.crtc_htotal);\r\nline_time.full = dfixed_mul(a, pclk);\r\na.full = dfixed_const(crtc->base.mode.crtc_htotal);\r\nb.full = dfixed_const(crtc->base.mode.crtc_hdisplay);\r\nwm->active_time.full = dfixed_mul(line_time, b);\r\nwm->active_time.full = dfixed_div(wm->active_time, a);\r\na.full = dfixed_const(600 * 1000);\r\nchunk_time.full = dfixed_div(a, rdev->pm.sclk);\r\nread_delay_latency.full = dfixed_const(1000);\r\nif (dfixed_trunc(wm->num_line_pair) > 1) {\r\na.full = dfixed_const(3);\r\nwm->worst_case_latency.full = dfixed_mul(a, chunk_time);\r\nwm->worst_case_latency.full += read_delay_latency.full;\r\n} else {\r\nwm->worst_case_latency.full = chunk_time.full + read_delay_latency.full;\r\n}\r\nif ((2+wm->lb_request_fifo_depth) >= dfixed_trunc(request_fifo_depth)) {\r\ntolerable_latency.full = line_time.full;\r\n} else {\r\ntolerable_latency.full = dfixed_const(wm->lb_request_fifo_depth - 2);\r\ntolerable_latency.full = request_fifo_depth.full - tolerable_latency.full;\r\ntolerable_latency.full = dfixed_mul(tolerable_latency, chunk_time);\r\ntolerable_latency.full = line_time.full - tolerable_latency.full;\r\n}\r\nwm->dbpp.full = dfixed_const(2 * 16);\r\na.full = dfixed_const(16);\r\nwm->priority_mark_max.full = dfixed_const(crtc->base.mode.crtc_hdisplay);\r\nwm->priority_mark_max.full = dfixed_div(wm->priority_mark_max, a);\r\nwm->priority_mark_max.full = dfixed_ceil(wm->priority_mark_max);\r\nestimated_width.full = tolerable_latency.full - wm->worst_case_latency.full;\r\nestimated_width.full = dfixed_div(estimated_width, consumption_time);\r\nif (dfixed_trunc(estimated_width) > crtc->base.mode.crtc_hdisplay) {\r\nwm->priority_mark.full = wm->priority_mark_max.full;\r\n} else {\r\na.full = dfixed_const(16);\r\nwm->priority_mark.full = dfixed_div(estimated_width, a);\r\nwm->priority_mark.full = dfixed_ceil(wm->priority_mark);\r\nwm->priority_mark.full = wm->priority_mark_max.full - wm->priority_mark.full;\r\n}\r\n}\r\nvoid rv515_bandwidth_avivo_update(struct radeon_device *rdev)\r\n{\r\nstruct drm_display_mode *mode0 = NULL;\r\nstruct drm_display_mode *mode1 = NULL;\r\nstruct rv515_watermark wm0;\r\nstruct rv515_watermark wm1;\r\nu32 tmp;\r\nu32 d1mode_priority_a_cnt = MODE_PRIORITY_OFF;\r\nu32 d2mode_priority_a_cnt = MODE_PRIORITY_OFF;\r\nfixed20_12 priority_mark02, priority_mark12, fill_rate;\r\nfixed20_12 a, b;\r\nif (rdev->mode_info.crtcs[0]->base.enabled)\r\nmode0 = &rdev->mode_info.crtcs[0]->base.mode;\r\nif (rdev->mode_info.crtcs[1]->base.enabled)\r\nmode1 = &rdev->mode_info.crtcs[1]->base.mode;\r\nrs690_line_buffer_adjust(rdev, mode0, mode1);\r\nrv515_crtc_bandwidth_compute(rdev, rdev->mode_info.crtcs[0], &wm0);\r\nrv515_crtc_bandwidth_compute(rdev, rdev->mode_info.crtcs[1], &wm1);\r\ntmp = wm0.lb_request_fifo_depth;\r\ntmp |= wm1.lb_request_fifo_depth << 16;\r\nWREG32(LB_MAX_REQ_OUTSTANDING, tmp);\r\nif (mode0 && mode1) {\r\nif (dfixed_trunc(wm0.dbpp) > 64)\r\na.full = dfixed_div(wm0.dbpp, wm0.num_line_pair);\r\nelse\r\na.full = wm0.num_line_pair.full;\r\nif (dfixed_trunc(wm1.dbpp) > 64)\r\nb.full = dfixed_div(wm1.dbpp, wm1.num_line_pair);\r\nelse\r\nb.full = wm1.num_line_pair.full;\r\na.full += b.full;\r\nfill_rate.full = dfixed_div(wm0.sclk, a);\r\nif (wm0.consumption_rate.full > fill_rate.full) {\r\nb.full = wm0.consumption_rate.full - fill_rate.full;\r\nb.full = dfixed_mul(b, wm0.active_time);\r\na.full = dfixed_const(16);\r\nb.full = dfixed_div(b, a);\r\na.full = dfixed_mul(wm0.worst_case_latency,\r\nwm0.consumption_rate);\r\npriority_mark02.full = a.full + b.full;\r\n} else {\r\na.full = dfixed_mul(wm0.worst_case_latency,\r\nwm0.consumption_rate);\r\nb.full = dfixed_const(16 * 1000);\r\npriority_mark02.full = dfixed_div(a, b);\r\n}\r\nif (wm1.consumption_rate.full > fill_rate.full) {\r\nb.full = wm1.consumption_rate.full - fill_rate.full;\r\nb.full = dfixed_mul(b, wm1.active_time);\r\na.full = dfixed_const(16);\r\nb.full = dfixed_div(b, a);\r\na.full = dfixed_mul(wm1.worst_case_latency,\r\nwm1.consumption_rate);\r\npriority_mark12.full = a.full + b.full;\r\n} else {\r\na.full = dfixed_mul(wm1.worst_case_latency,\r\nwm1.consumption_rate);\r\nb.full = dfixed_const(16 * 1000);\r\npriority_mark12.full = dfixed_div(a, b);\r\n}\r\nif (wm0.priority_mark.full > priority_mark02.full)\r\npriority_mark02.full = wm0.priority_mark.full;\r\nif (dfixed_trunc(priority_mark02) < 0)\r\npriority_mark02.full = 0;\r\nif (wm0.priority_mark_max.full > priority_mark02.full)\r\npriority_mark02.full = wm0.priority_mark_max.full;\r\nif (wm1.priority_mark.full > priority_mark12.full)\r\npriority_mark12.full = wm1.priority_mark.full;\r\nif (dfixed_trunc(priority_mark12) < 0)\r\npriority_mark12.full = 0;\r\nif (wm1.priority_mark_max.full > priority_mark12.full)\r\npriority_mark12.full = wm1.priority_mark_max.full;\r\nd1mode_priority_a_cnt = dfixed_trunc(priority_mark02);\r\nd2mode_priority_a_cnt = dfixed_trunc(priority_mark12);\r\nif (rdev->disp_priority == 2) {\r\nd1mode_priority_a_cnt |= MODE_PRIORITY_ALWAYS_ON;\r\nd2mode_priority_a_cnt |= MODE_PRIORITY_ALWAYS_ON;\r\n}\r\n} else if (mode0) {\r\nif (dfixed_trunc(wm0.dbpp) > 64)\r\na.full = dfixed_div(wm0.dbpp, wm0.num_line_pair);\r\nelse\r\na.full = wm0.num_line_pair.full;\r\nfill_rate.full = dfixed_div(wm0.sclk, a);\r\nif (wm0.consumption_rate.full > fill_rate.full) {\r\nb.full = wm0.consumption_rate.full - fill_rate.full;\r\nb.full = dfixed_mul(b, wm0.active_time);\r\na.full = dfixed_const(16);\r\nb.full = dfixed_div(b, a);\r\na.full = dfixed_mul(wm0.worst_case_latency,\r\nwm0.consumption_rate);\r\npriority_mark02.full = a.full + b.full;\r\n} else {\r\na.full = dfixed_mul(wm0.worst_case_latency,\r\nwm0.consumption_rate);\r\nb.full = dfixed_const(16);\r\npriority_mark02.full = dfixed_div(a, b);\r\n}\r\nif (wm0.priority_mark.full > priority_mark02.full)\r\npriority_mark02.full = wm0.priority_mark.full;\r\nif (dfixed_trunc(priority_mark02) < 0)\r\npriority_mark02.full = 0;\r\nif (wm0.priority_mark_max.full > priority_mark02.full)\r\npriority_mark02.full = wm0.priority_mark_max.full;\r\nd1mode_priority_a_cnt = dfixed_trunc(priority_mark02);\r\nif (rdev->disp_priority == 2)\r\nd1mode_priority_a_cnt |= MODE_PRIORITY_ALWAYS_ON;\r\n} else if (mode1) {\r\nif (dfixed_trunc(wm1.dbpp) > 64)\r\na.full = dfixed_div(wm1.dbpp, wm1.num_line_pair);\r\nelse\r\na.full = wm1.num_line_pair.full;\r\nfill_rate.full = dfixed_div(wm1.sclk, a);\r\nif (wm1.consumption_rate.full > fill_rate.full) {\r\nb.full = wm1.consumption_rate.full - fill_rate.full;\r\nb.full = dfixed_mul(b, wm1.active_time);\r\na.full = dfixed_const(16);\r\nb.full = dfixed_div(b, a);\r\na.full = dfixed_mul(wm1.worst_case_latency,\r\nwm1.consumption_rate);\r\npriority_mark12.full = a.full + b.full;\r\n} else {\r\na.full = dfixed_mul(wm1.worst_case_latency,\r\nwm1.consumption_rate);\r\nb.full = dfixed_const(16 * 1000);\r\npriority_mark12.full = dfixed_div(a, b);\r\n}\r\nif (wm1.priority_mark.full > priority_mark12.full)\r\npriority_mark12.full = wm1.priority_mark.full;\r\nif (dfixed_trunc(priority_mark12) < 0)\r\npriority_mark12.full = 0;\r\nif (wm1.priority_mark_max.full > priority_mark12.full)\r\npriority_mark12.full = wm1.priority_mark_max.full;\r\nd2mode_priority_a_cnt = dfixed_trunc(priority_mark12);\r\nif (rdev->disp_priority == 2)\r\nd2mode_priority_a_cnt |= MODE_PRIORITY_ALWAYS_ON;\r\n}\r\nWREG32(D1MODE_PRIORITY_A_CNT, d1mode_priority_a_cnt);\r\nWREG32(D1MODE_PRIORITY_B_CNT, d1mode_priority_a_cnt);\r\nWREG32(D2MODE_PRIORITY_A_CNT, d2mode_priority_a_cnt);\r\nWREG32(D2MODE_PRIORITY_B_CNT, d2mode_priority_a_cnt);\r\n}\r\nvoid rv515_bandwidth_update(struct radeon_device *rdev)\r\n{\r\nuint32_t tmp;\r\nstruct drm_display_mode *mode0 = NULL;\r\nstruct drm_display_mode *mode1 = NULL;\r\nradeon_update_display_priority(rdev);\r\nif (rdev->mode_info.crtcs[0]->base.enabled)\r\nmode0 = &rdev->mode_info.crtcs[0]->base.mode;\r\nif (rdev->mode_info.crtcs[1]->base.enabled)\r\nmode1 = &rdev->mode_info.crtcs[1]->base.mode;\r\nif ((rdev->disp_priority == 2) &&\r\n(rdev->family == CHIP_RV515)) {\r\ntmp = RREG32_MC(MC_MISC_LAT_TIMER);\r\ntmp &= ~MC_DISP1R_INIT_LAT_MASK;\r\ntmp &= ~MC_DISP0R_INIT_LAT_MASK;\r\nif (mode1)\r\ntmp |= (1 << MC_DISP1R_INIT_LAT_SHIFT);\r\nif (mode0)\r\ntmp |= (1 << MC_DISP0R_INIT_LAT_SHIFT);\r\nWREG32_MC(MC_MISC_LAT_TIMER, tmp);\r\n}\r\nrv515_bandwidth_avivo_update(rdev);\r\n}
