void fscache_enqueue_operation(struct fscache_operation *op)\r\n{\r\n_enter("{OBJ%x OP%x,%u}",\r\nop->object->debug_id, op->debug_id, atomic_read(&op->usage));\r\nASSERT(list_empty(&op->pend_link));\r\nASSERT(op->processor != NULL);\r\nASSERTCMP(op->object->state, >=, FSCACHE_OBJECT_AVAILABLE);\r\nASSERTCMP(atomic_read(&op->usage), >, 0);\r\nASSERTCMP(op->state, ==, FSCACHE_OP_ST_IN_PROGRESS);\r\nfscache_stat(&fscache_n_op_enqueue);\r\nswitch (op->flags & FSCACHE_OP_TYPE) {\r\ncase FSCACHE_OP_ASYNC:\r\n_debug("queue async");\r\natomic_inc(&op->usage);\r\nif (!queue_work(fscache_op_wq, &op->work))\r\nfscache_put_operation(op);\r\nbreak;\r\ncase FSCACHE_OP_MYTHREAD:\r\n_debug("queue for caller's attention");\r\nbreak;\r\ndefault:\r\nprintk(KERN_ERR "FS-Cache: Unexpected op type %lx",\r\nop->flags);\r\nBUG();\r\nbreak;\r\n}\r\n}\r\nstatic void fscache_run_op(struct fscache_object *object,\r\nstruct fscache_operation *op)\r\n{\r\nASSERTCMP(op->state, ==, FSCACHE_OP_ST_PENDING);\r\nop->state = FSCACHE_OP_ST_IN_PROGRESS;\r\nobject->n_in_progress++;\r\nif (test_and_clear_bit(FSCACHE_OP_WAITING, &op->flags))\r\nwake_up_bit(&op->flags, FSCACHE_OP_WAITING);\r\nif (op->processor)\r\nfscache_enqueue_operation(op);\r\nfscache_stat(&fscache_n_op_run);\r\n}\r\nint fscache_submit_exclusive_op(struct fscache_object *object,\r\nstruct fscache_operation *op)\r\n{\r\nint ret;\r\n_enter("{OBJ%x OP%x},", object->debug_id, op->debug_id);\r\nASSERTCMP(op->state, ==, FSCACHE_OP_ST_INITIALISED);\r\nASSERTCMP(atomic_read(&op->usage), >, 0);\r\nspin_lock(&object->lock);\r\nASSERTCMP(object->n_ops, >=, object->n_in_progress);\r\nASSERTCMP(object->n_ops, >=, object->n_exclusive);\r\nASSERT(list_empty(&op->pend_link));\r\nop->state = FSCACHE_OP_ST_PENDING;\r\nif (fscache_object_is_active(object)) {\r\nop->object = object;\r\nobject->n_ops++;\r\nobject->n_exclusive++;\r\nif (object->n_in_progress > 0) {\r\natomic_inc(&op->usage);\r\nlist_add_tail(&op->pend_link, &object->pending_ops);\r\nfscache_stat(&fscache_n_op_pend);\r\n} else if (!list_empty(&object->pending_ops)) {\r\natomic_inc(&op->usage);\r\nlist_add_tail(&op->pend_link, &object->pending_ops);\r\nfscache_stat(&fscache_n_op_pend);\r\nfscache_start_operations(object);\r\n} else {\r\nASSERTCMP(object->n_in_progress, ==, 0);\r\nfscache_run_op(object, op);\r\n}\r\nclear_bit(FSCACHE_OBJECT_PENDING_WRITE, &object->flags);\r\nret = 0;\r\n} else if (object->state == FSCACHE_OBJECT_CREATING) {\r\nop->object = object;\r\nobject->n_ops++;\r\nobject->n_exclusive++;\r\natomic_inc(&op->usage);\r\nlist_add_tail(&op->pend_link, &object->pending_ops);\r\nfscache_stat(&fscache_n_op_pend);\r\nret = 0;\r\n} else {\r\nASSERT(test_bit(FSCACHE_IOERROR, &object->cache->flags));\r\nret = -EIO;\r\n}\r\nspin_unlock(&object->lock);\r\nreturn ret;\r\n}\r\nstatic void fscache_report_unexpected_submission(struct fscache_object *object,\r\nstruct fscache_operation *op,\r\nunsigned long ostate)\r\n{\r\nstatic bool once_only;\r\nstruct fscache_operation *p;\r\nunsigned n;\r\nif (once_only)\r\nreturn;\r\nonce_only = true;\r\nkdebug("unexpected submission OP%x [OBJ%x %s]",\r\nop->debug_id, object->debug_id,\r\nfscache_object_states[object->state]);\r\nkdebug("objstate=%s [%s]",\r\nfscache_object_states[object->state],\r\nfscache_object_states[ostate]);\r\nkdebug("objflags=%lx", object->flags);\r\nkdebug("objevent=%lx [%lx]", object->events, object->event_mask);\r\nkdebug("ops=%u inp=%u exc=%u",\r\nobject->n_ops, object->n_in_progress, object->n_exclusive);\r\nif (!list_empty(&object->pending_ops)) {\r\nn = 0;\r\nlist_for_each_entry(p, &object->pending_ops, pend_link) {\r\nASSERTCMP(p->object, ==, object);\r\nkdebug("%p %p", op->processor, op->release);\r\nn++;\r\n}\r\nkdebug("n=%u", n);\r\n}\r\ndump_stack();\r\n}\r\nint fscache_submit_op(struct fscache_object *object,\r\nstruct fscache_operation *op)\r\n{\r\nunsigned long ostate;\r\nint ret;\r\n_enter("{OBJ%x OP%x},{%u}",\r\nobject->debug_id, op->debug_id, atomic_read(&op->usage));\r\nASSERTCMP(op->state, ==, FSCACHE_OP_ST_INITIALISED);\r\nASSERTCMP(atomic_read(&op->usage), >, 0);\r\nspin_lock(&object->lock);\r\nASSERTCMP(object->n_ops, >=, object->n_in_progress);\r\nASSERTCMP(object->n_ops, >=, object->n_exclusive);\r\nASSERT(list_empty(&op->pend_link));\r\nostate = object->state;\r\nsmp_rmb();\r\nop->state = FSCACHE_OP_ST_PENDING;\r\nif (fscache_object_is_active(object)) {\r\nop->object = object;\r\nobject->n_ops++;\r\nif (object->n_exclusive > 0) {\r\natomic_inc(&op->usage);\r\nlist_add_tail(&op->pend_link, &object->pending_ops);\r\nfscache_stat(&fscache_n_op_pend);\r\n} else if (!list_empty(&object->pending_ops)) {\r\natomic_inc(&op->usage);\r\nlist_add_tail(&op->pend_link, &object->pending_ops);\r\nfscache_stat(&fscache_n_op_pend);\r\nfscache_start_operations(object);\r\n} else {\r\nASSERTCMP(object->n_exclusive, ==, 0);\r\nfscache_run_op(object, op);\r\n}\r\nret = 0;\r\n} else if (object->state == FSCACHE_OBJECT_CREATING) {\r\nop->object = object;\r\nobject->n_ops++;\r\natomic_inc(&op->usage);\r\nlist_add_tail(&op->pend_link, &object->pending_ops);\r\nfscache_stat(&fscache_n_op_pend);\r\nret = 0;\r\n} else if (object->state == FSCACHE_OBJECT_DYING ||\r\nobject->state == FSCACHE_OBJECT_LC_DYING ||\r\nobject->state == FSCACHE_OBJECT_WITHDRAWING) {\r\nfscache_stat(&fscache_n_op_rejected);\r\nop->state = FSCACHE_OP_ST_CANCELLED;\r\nret = -ENOBUFS;\r\n} else if (!test_bit(FSCACHE_IOERROR, &object->cache->flags)) {\r\nfscache_report_unexpected_submission(object, op, ostate);\r\nASSERT(!fscache_object_is_active(object));\r\nop->state = FSCACHE_OP_ST_CANCELLED;\r\nret = -ENOBUFS;\r\n} else {\r\nop->state = FSCACHE_OP_ST_CANCELLED;\r\nret = -ENOBUFS;\r\n}\r\nspin_unlock(&object->lock);\r\nreturn ret;\r\n}\r\nvoid fscache_abort_object(struct fscache_object *object)\r\n{\r\n_enter("{OBJ%x}", object->debug_id);\r\nfscache_raise_event(object, FSCACHE_OBJECT_EV_ERROR);\r\n}\r\nvoid fscache_start_operations(struct fscache_object *object)\r\n{\r\nstruct fscache_operation *op;\r\nbool stop = false;\r\nwhile (!list_empty(&object->pending_ops) && !stop) {\r\nop = list_entry(object->pending_ops.next,\r\nstruct fscache_operation, pend_link);\r\nif (test_bit(FSCACHE_OP_EXCLUSIVE, &op->flags)) {\r\nif (object->n_in_progress > 0)\r\nbreak;\r\nstop = true;\r\n}\r\nlist_del_init(&op->pend_link);\r\nfscache_run_op(object, op);\r\nfscache_put_operation(op);\r\n}\r\nASSERTCMP(object->n_in_progress, <=, object->n_ops);\r\n_debug("woke %d ops on OBJ%x",\r\nobject->n_in_progress, object->debug_id);\r\n}\r\nint fscache_cancel_op(struct fscache_operation *op,\r\nvoid (*do_cancel)(struct fscache_operation *))\r\n{\r\nstruct fscache_object *object = op->object;\r\nint ret;\r\n_enter("OBJ%x OP%x}", op->object->debug_id, op->debug_id);\r\nASSERTCMP(op->state, >=, FSCACHE_OP_ST_PENDING);\r\nASSERTCMP(op->state, !=, FSCACHE_OP_ST_CANCELLED);\r\nASSERTCMP(atomic_read(&op->usage), >, 0);\r\nspin_lock(&object->lock);\r\nret = -EBUSY;\r\nif (op->state == FSCACHE_OP_ST_PENDING) {\r\nASSERT(!list_empty(&op->pend_link));\r\nfscache_stat(&fscache_n_op_cancelled);\r\nlist_del_init(&op->pend_link);\r\nif (do_cancel)\r\ndo_cancel(op);\r\nop->state = FSCACHE_OP_ST_CANCELLED;\r\nif (test_bit(FSCACHE_OP_EXCLUSIVE, &op->flags))\r\nobject->n_exclusive--;\r\nif (test_and_clear_bit(FSCACHE_OP_WAITING, &op->flags))\r\nwake_up_bit(&op->flags, FSCACHE_OP_WAITING);\r\nfscache_put_operation(op);\r\nret = 0;\r\n}\r\nspin_unlock(&object->lock);\r\n_leave(" = %d", ret);\r\nreturn ret;\r\n}\r\nvoid fscache_cancel_all_ops(struct fscache_object *object)\r\n{\r\nstruct fscache_operation *op;\r\n_enter("OBJ%x", object->debug_id);\r\nspin_lock(&object->lock);\r\nwhile (!list_empty(&object->pending_ops)) {\r\nop = list_entry(object->pending_ops.next,\r\nstruct fscache_operation, pend_link);\r\nfscache_stat(&fscache_n_op_cancelled);\r\nlist_del_init(&op->pend_link);\r\nASSERTCMP(op->state, ==, FSCACHE_OP_ST_PENDING);\r\nop->state = FSCACHE_OP_ST_CANCELLED;\r\nif (test_bit(FSCACHE_OP_EXCLUSIVE, &op->flags))\r\nobject->n_exclusive--;\r\nif (test_and_clear_bit(FSCACHE_OP_WAITING, &op->flags))\r\nwake_up_bit(&op->flags, FSCACHE_OP_WAITING);\r\nfscache_put_operation(op);\r\ncond_resched_lock(&object->lock);\r\n}\r\nspin_unlock(&object->lock);\r\n_leave("");\r\n}\r\nvoid fscache_op_complete(struct fscache_operation *op, bool cancelled)\r\n{\r\nstruct fscache_object *object = op->object;\r\n_enter("OBJ%x", object->debug_id);\r\nASSERTCMP(op->state, ==, FSCACHE_OP_ST_IN_PROGRESS);\r\nASSERTCMP(object->n_in_progress, >, 0);\r\nASSERTIFCMP(test_bit(FSCACHE_OP_EXCLUSIVE, &op->flags),\r\nobject->n_exclusive, >, 0);\r\nASSERTIFCMP(test_bit(FSCACHE_OP_EXCLUSIVE, &op->flags),\r\nobject->n_in_progress, ==, 1);\r\nspin_lock(&object->lock);\r\nop->state = cancelled ?\r\nFSCACHE_OP_ST_CANCELLED : FSCACHE_OP_ST_COMPLETE;\r\nif (test_bit(FSCACHE_OP_EXCLUSIVE, &op->flags))\r\nobject->n_exclusive--;\r\nobject->n_in_progress--;\r\nif (object->n_in_progress == 0)\r\nfscache_start_operations(object);\r\nspin_unlock(&object->lock);\r\n_leave("");\r\n}\r\nvoid fscache_put_operation(struct fscache_operation *op)\r\n{\r\nstruct fscache_object *object;\r\nstruct fscache_cache *cache;\r\n_enter("{OBJ%x OP%x,%d}",\r\nop->object->debug_id, op->debug_id, atomic_read(&op->usage));\r\nASSERTCMP(atomic_read(&op->usage), >, 0);\r\nif (!atomic_dec_and_test(&op->usage))\r\nreturn;\r\n_debug("PUT OP");\r\nASSERTIFCMP(op->state != FSCACHE_OP_ST_COMPLETE,\r\nop->state, ==, FSCACHE_OP_ST_CANCELLED);\r\nop->state = FSCACHE_OP_ST_DEAD;\r\nfscache_stat(&fscache_n_op_release);\r\nif (op->release) {\r\nop->release(op);\r\nop->release = NULL;\r\n}\r\nobject = op->object;\r\nif (test_bit(FSCACHE_OP_DEC_READ_CNT, &op->flags)) {\r\nif (atomic_dec_and_test(&object->n_reads)) {\r\nclear_bit(FSCACHE_COOKIE_WAITING_ON_READS,\r\n&object->cookie->flags);\r\nwake_up_bit(&object->cookie->flags,\r\nFSCACHE_COOKIE_WAITING_ON_READS);\r\n}\r\n}\r\nif (!spin_trylock(&object->lock)) {\r\n_debug("defer put");\r\nfscache_stat(&fscache_n_op_deferred_release);\r\ncache = object->cache;\r\nspin_lock(&cache->op_gc_list_lock);\r\nlist_add_tail(&op->pend_link, &cache->op_gc_list);\r\nspin_unlock(&cache->op_gc_list_lock);\r\nschedule_work(&cache->op_gc);\r\n_leave(" [defer]");\r\nreturn;\r\n}\r\nASSERTCMP(object->n_ops, >, 0);\r\nobject->n_ops--;\r\nif (object->n_ops == 0)\r\nfscache_raise_event(object, FSCACHE_OBJECT_EV_CLEARED);\r\nspin_unlock(&object->lock);\r\nkfree(op);\r\n_leave(" [done]");\r\n}\r\nvoid fscache_operation_gc(struct work_struct *work)\r\n{\r\nstruct fscache_operation *op;\r\nstruct fscache_object *object;\r\nstruct fscache_cache *cache =\r\ncontainer_of(work, struct fscache_cache, op_gc);\r\nint count = 0;\r\n_enter("");\r\ndo {\r\nspin_lock(&cache->op_gc_list_lock);\r\nif (list_empty(&cache->op_gc_list)) {\r\nspin_unlock(&cache->op_gc_list_lock);\r\nbreak;\r\n}\r\nop = list_entry(cache->op_gc_list.next,\r\nstruct fscache_operation, pend_link);\r\nlist_del(&op->pend_link);\r\nspin_unlock(&cache->op_gc_list_lock);\r\nobject = op->object;\r\nspin_lock(&object->lock);\r\n_debug("GC DEFERRED REL OBJ%x OP%x",\r\nobject->debug_id, op->debug_id);\r\nfscache_stat(&fscache_n_op_gc);\r\nASSERTCMP(atomic_read(&op->usage), ==, 0);\r\nASSERTCMP(op->state, ==, FSCACHE_OP_ST_DEAD);\r\nASSERTCMP(object->n_ops, >, 0);\r\nobject->n_ops--;\r\nif (object->n_ops == 0)\r\nfscache_raise_event(object, FSCACHE_OBJECT_EV_CLEARED);\r\nspin_unlock(&object->lock);\r\nkfree(op);\r\n} while (count++ < 20);\r\nif (!list_empty(&cache->op_gc_list))\r\nschedule_work(&cache->op_gc);\r\n_leave("");\r\n}\r\nvoid fscache_op_work_func(struct work_struct *work)\r\n{\r\nstruct fscache_operation *op =\r\ncontainer_of(work, struct fscache_operation, work);\r\nunsigned long start;\r\n_enter("{OBJ%x OP%x,%d}",\r\nop->object->debug_id, op->debug_id, atomic_read(&op->usage));\r\nASSERT(op->processor != NULL);\r\nstart = jiffies;\r\nop->processor(op);\r\nfscache_hist(fscache_ops_histogram, start);\r\nfscache_put_operation(op);\r\n_leave("");\r\n}
