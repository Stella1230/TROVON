phys_addr_t v_mapped_by_bats(unsigned long va)\r\n{\r\nint b;\r\nfor (b = 0; b < 4; ++b)\r\nif (va >= bat_addrs[b].start && va < bat_addrs[b].limit)\r\nreturn bat_addrs[b].phys + (va - bat_addrs[b].start);\r\nreturn 0;\r\n}\r\nunsigned long p_mapped_by_bats(phys_addr_t pa)\r\n{\r\nint b;\r\nfor (b = 0; b < 4; ++b)\r\nif (pa >= bat_addrs[b].phys\r\n&& pa < (bat_addrs[b].limit-bat_addrs[b].start)\r\n+bat_addrs[b].phys)\r\nreturn bat_addrs[b].start+(pa-bat_addrs[b].phys);\r\nreturn 0;\r\n}\r\nunsigned long __init mmu_mapin_ram(unsigned long top)\r\n{\r\nunsigned long tot, bl, done;\r\nunsigned long max_size = (256<<20);\r\nif (__map_without_bats) {\r\nprintk(KERN_DEBUG "RAM mapped without BATs\n");\r\nreturn 0;\r\n}\r\ntot = top;\r\nfor (bl = 128<<10; bl < max_size; bl <<= 1) {\r\nif (bl * 2 > tot)\r\nbreak;\r\n}\r\nsetbat(2, PAGE_OFFSET, 0, bl, PAGE_KERNEL_X);\r\ndone = (unsigned long)bat_addrs[2].limit - PAGE_OFFSET + 1;\r\nif ((done < tot) && !bat_addrs[3].limit) {\r\ntot -= done;\r\nfor (bl = 128<<10; bl < max_size; bl <<= 1)\r\nif (bl * 2 > tot)\r\nbreak;\r\nsetbat(3, PAGE_OFFSET+done, done, bl, PAGE_KERNEL_X);\r\ndone = (unsigned long)bat_addrs[3].limit - PAGE_OFFSET + 1;\r\n}\r\nreturn done;\r\n}\r\nvoid __init setbat(int index, unsigned long virt, phys_addr_t phys,\r\nunsigned int size, int flags)\r\n{\r\nunsigned int bl;\r\nint wimgxpp;\r\nstruct ppc_bat *bat = BATS[index];\r\nif ((flags & _PAGE_NO_CACHE) ||\r\n(cpu_has_feature(CPU_FTR_NEED_COHERENT) == 0))\r\nflags &= ~_PAGE_COHERENT;\r\nbl = (size >> 17) - 1;\r\nif (PVR_VER(mfspr(SPRN_PVR)) != 1) {\r\nwimgxpp = flags & (_PAGE_WRITETHRU | _PAGE_NO_CACHE\r\n| _PAGE_COHERENT | _PAGE_GUARDED);\r\nwimgxpp |= (flags & _PAGE_RW)? BPP_RW: BPP_RX;\r\nbat[1].batu = virt | (bl << 2) | 2;\r\nbat[1].batl = BAT_PHYS_ADDR(phys) | wimgxpp;\r\nif (flags & _PAGE_USER)\r\nbat[1].batu |= 1;\r\nif (flags & _PAGE_GUARDED) {\r\nbat[0].batu = bat[0].batl = 0;\r\n} else {\r\nbat[0] = bat[1];\r\n}\r\n} else {\r\nif (bl > BL_8M)\r\nbl = BL_8M;\r\nwimgxpp = flags & (_PAGE_WRITETHRU | _PAGE_NO_CACHE\r\n| _PAGE_COHERENT);\r\nwimgxpp |= (flags & _PAGE_RW)?\r\n((flags & _PAGE_USER)? PP_RWRW: PP_RWXX): PP_RXRX;\r\nbat->batu = virt | wimgxpp | 4;\r\nbat->batl = phys | bl | 0x40;\r\n}\r\nbat_addrs[index].start = virt;\r\nbat_addrs[index].limit = virt + ((bl + 1) << 17) - 1;\r\nbat_addrs[index].phys = phys;\r\n}\r\nvoid hash_preload(struct mm_struct *mm, unsigned long ea,\r\nunsigned long access, unsigned long trap)\r\n{\r\npmd_t *pmd;\r\nif (Hash == 0)\r\nreturn;\r\npmd = pmd_offset(pud_offset(pgd_offset(mm, ea), ea), ea);\r\nif (!pmd_none(*pmd))\r\nadd_hash_page(mm->context.id, ea, pmd_val(*pmd));\r\n}\r\nvoid __init MMU_init_hw(void)\r\n{\r\nunsigned int hmask, mb, mb2;\r\nunsigned int n_hpteg, lg_n_hpteg;\r\nextern unsigned int hash_page_patch_A[];\r\nextern unsigned int hash_page_patch_B[], hash_page_patch_C[];\r\nextern unsigned int hash_page[];\r\nextern unsigned int flush_hash_patch_A[], flush_hash_patch_B[];\r\nif (!mmu_has_feature(MMU_FTR_HPTE_TABLE)) {\r\nhash_page[0] = 0x4e800020;\r\nflush_icache_range((unsigned long) &hash_page[0],\r\n(unsigned long) &hash_page[1]);\r\nreturn;\r\n}\r\nif ( ppc_md.progress ) ppc_md.progress("hash:enter", 0x105);\r\n#define LG_HPTEG_SIZE 6\r\n#define SDR1_LOW_BITS ((n_hpteg - 1) >> 10)\r\n#define MIN_N_HPTEG 1024\r\nn_hpteg = total_memory / (PAGE_SIZE * 8);\r\nif (n_hpteg < MIN_N_HPTEG)\r\nn_hpteg = MIN_N_HPTEG;\r\nlg_n_hpteg = __ilog2(n_hpteg);\r\nif (n_hpteg & (n_hpteg - 1)) {\r\n++lg_n_hpteg;\r\nn_hpteg = 1 << lg_n_hpteg;\r\n}\r\nHash_size = n_hpteg << LG_HPTEG_SIZE;\r\nif ( ppc_md.progress ) ppc_md.progress("hash:find piece", 0x322);\r\nHash = __va(memblock_alloc(Hash_size, Hash_size));\r\ncacheable_memzero(Hash, Hash_size);\r\n_SDR1 = __pa(Hash) | SDR1_LOW_BITS;\r\nHash_end = (struct hash_pte *) ((unsigned long)Hash + Hash_size);\r\nprintk("Total memory = %lldMB; using %ldkB for hash table (at %p)\n",\r\n(unsigned long long)(total_memory >> 20), Hash_size >> 10, Hash);\r\nif ( ppc_md.progress ) ppc_md.progress("hash:patch", 0x345);\r\nHash_mask = n_hpteg - 1;\r\nhmask = Hash_mask >> (16 - LG_HPTEG_SIZE);\r\nmb2 = mb = 32 - LG_HPTEG_SIZE - lg_n_hpteg;\r\nif (lg_n_hpteg > 16)\r\nmb2 = 16 - LG_HPTEG_SIZE;\r\nhash_page_patch_A[0] = (hash_page_patch_A[0] & ~0xffff)\r\n| ((unsigned int)(Hash) >> 16);\r\nhash_page_patch_A[1] = (hash_page_patch_A[1] & ~0x7c0) | (mb << 6);\r\nhash_page_patch_A[2] = (hash_page_patch_A[2] & ~0x7c0) | (mb2 << 6);\r\nhash_page_patch_B[0] = (hash_page_patch_B[0] & ~0xffff) | hmask;\r\nhash_page_patch_C[0] = (hash_page_patch_C[0] & ~0xffff) | hmask;\r\nflush_icache_range((unsigned long) &hash_page_patch_A[0],\r\n(unsigned long) &hash_page_patch_C[1]);\r\nflush_hash_patch_A[0] = (flush_hash_patch_A[0] & ~0xffff)\r\n| ((unsigned int)(Hash) >> 16);\r\nflush_hash_patch_A[1] = (flush_hash_patch_A[1] & ~0x7c0) | (mb << 6);\r\nflush_hash_patch_A[2] = (flush_hash_patch_A[2] & ~0x7c0) | (mb2 << 6);\r\nflush_hash_patch_B[0] = (flush_hash_patch_B[0] & ~0xffff) | hmask;\r\nflush_icache_range((unsigned long) &flush_hash_patch_A[0],\r\n(unsigned long) &flush_hash_patch_B[1]);\r\nif ( ppc_md.progress ) ppc_md.progress("hash:done", 0x205);\r\n}\r\nvoid setup_initial_memory_limit(phys_addr_t first_memblock_base,\r\nphys_addr_t first_memblock_size)\r\n{\r\nBUG_ON(first_memblock_base != 0);\r\nif (PVR_VER(mfspr(SPRN_PVR)) == 1)\r\nmemblock_set_current_limit(min_t(u64, first_memblock_size, 0x01000000));\r\nelse\r\nmemblock_set_current_limit(min_t(u64, first_memblock_size, 0x10000000));\r\n}
