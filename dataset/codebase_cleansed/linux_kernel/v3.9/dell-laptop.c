static int dmi_matched(const struct dmi_system_id *dmi)\r\n{\r\nquirks = dmi->driver_data;\r\nreturn 1;\r\n}\r\nstatic void get_buffer(void)\r\n{\r\nmutex_lock(&buffer_mutex);\r\nmemset(buffer, 0, sizeof(struct calling_interface_buffer));\r\n}\r\nstatic void release_buffer(void)\r\n{\r\nmutex_unlock(&buffer_mutex);\r\n}\r\nstatic void __init parse_da_table(const struct dmi_header *dm)\r\n{\r\nint tokens = (dm->length-11)/sizeof(struct calling_interface_token)-1;\r\nstruct calling_interface_structure *table =\r\ncontainer_of(dm, struct calling_interface_structure, header);\r\nif (dm->length < 17)\r\nreturn;\r\nda_command_address = table->cmdIOAddress;\r\nda_command_code = table->cmdIOCode;\r\nda_tokens = krealloc(da_tokens, (da_num_tokens + tokens) *\r\nsizeof(struct calling_interface_token),\r\nGFP_KERNEL);\r\nif (!da_tokens)\r\nreturn;\r\nmemcpy(da_tokens+da_num_tokens, table->tokens,\r\nsizeof(struct calling_interface_token) * tokens);\r\nda_num_tokens += tokens;\r\n}\r\nstatic void __init find_tokens(const struct dmi_header *dm, void *dummy)\r\n{\r\nswitch (dm->type) {\r\ncase 0xd4:\r\ncase 0xd5:\r\ncase 0xd6:\r\nbreak;\r\ncase 0xda:\r\nparse_da_table(dm);\r\nbreak;\r\n}\r\n}\r\nstatic int find_token_location(int tokenid)\r\n{\r\nint i;\r\nfor (i = 0; i < da_num_tokens; i++) {\r\nif (da_tokens[i].tokenID == tokenid)\r\nreturn da_tokens[i].location;\r\n}\r\nreturn -1;\r\n}\r\nstatic struct calling_interface_buffer *\r\ndell_send_request(struct calling_interface_buffer *buffer, int class,\r\nint select)\r\n{\r\nstruct smi_cmd command;\r\ncommand.magic = SMI_CMD_MAGIC;\r\ncommand.command_address = da_command_address;\r\ncommand.command_code = da_command_code;\r\ncommand.ebx = virt_to_phys(buffer);\r\ncommand.ecx = 0x42534931;\r\nbuffer->class = class;\r\nbuffer->select = select;\r\ndcdbas_smi_request(&command);\r\nreturn buffer;\r\n}\r\nstatic int dell_debugfs_show(struct seq_file *s, void *data)\r\n{\r\nint status;\r\nget_buffer();\r\ndell_send_request(buffer, 17, 11);\r\nstatus = buffer->output[1];\r\nrelease_buffer();\r\nseq_printf(s, "status:\t0x%X\n", status);\r\nseq_printf(s, "Bit 0 : Hardware switch supported: %lu\n",\r\nstatus & BIT(0));\r\nseq_printf(s, "Bit 1 : Wifi locator supported: %lu\n",\r\n(status & BIT(1)) >> 1);\r\nseq_printf(s, "Bit 2 : Wifi is supported: %lu\n",\r\n(status & BIT(2)) >> 2);\r\nseq_printf(s, "Bit 3 : Bluetooth is supported: %lu\n",\r\n(status & BIT(3)) >> 3);\r\nseq_printf(s, "Bit 4 : WWAN is supported: %lu\n",\r\n(status & BIT(4)) >> 4);\r\nseq_printf(s, "Bit 5 : Wireless keyboard supported: %lu\n",\r\n(status & BIT(5)) >> 5);\r\nseq_printf(s, "Bit 8 : Wifi is installed: %lu\n",\r\n(status & BIT(8)) >> 8);\r\nseq_printf(s, "Bit 9 : Bluetooth is installed: %lu\n",\r\n(status & BIT(9)) >> 9);\r\nseq_printf(s, "Bit 10: WWAN is installed: %lu\n",\r\n(status & BIT(10)) >> 10);\r\nseq_printf(s, "Bit 16: Hardware switch is on: %lu\n",\r\n(status & BIT(16)) >> 16);\r\nseq_printf(s, "Bit 17: Wifi is blocked: %lu\n",\r\n(status & BIT(17)) >> 17);\r\nseq_printf(s, "Bit 18: Bluetooth is blocked: %lu\n",\r\n(status & BIT(18)) >> 18);\r\nseq_printf(s, "Bit 19: WWAN is blocked: %lu\n",\r\n(status & BIT(19)) >> 19);\r\nseq_printf(s, "\nhwswitch_state:\t0x%X\n", hwswitch_state);\r\nseq_printf(s, "Bit 0 : Wifi controlled by switch: %lu\n",\r\nhwswitch_state & BIT(0));\r\nseq_printf(s, "Bit 1 : Bluetooth controlled by switch: %lu\n",\r\n(hwswitch_state & BIT(1)) >> 1);\r\nseq_printf(s, "Bit 2 : WWAN controlled by switch: %lu\n",\r\n(hwswitch_state & BIT(2)) >> 2);\r\nseq_printf(s, "Bit 7 : Wireless switch config locked: %lu\n",\r\n(hwswitch_state & BIT(7)) >> 7);\r\nseq_printf(s, "Bit 8 : Wifi locator enabled: %lu\n",\r\n(hwswitch_state & BIT(8)) >> 8);\r\nseq_printf(s, "Bit 15: Wifi locator setting locked: %lu\n",\r\n(hwswitch_state & BIT(15)) >> 15);\r\nreturn 0;\r\n}\r\nstatic int dell_debugfs_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, dell_debugfs_show, inode->i_private);\r\n}\r\nstatic int dell_send_intensity(struct backlight_device *bd)\r\n{\r\nint ret = 0;\r\nget_buffer();\r\nbuffer->input[0] = find_token_location(BRIGHTNESS_TOKEN);\r\nbuffer->input[1] = bd->props.brightness;\r\nif (buffer->input[0] == -1) {\r\nret = -ENODEV;\r\ngoto out;\r\n}\r\nif (power_supply_is_system_supplied() > 0)\r\ndell_send_request(buffer, 1, 2);\r\nelse\r\ndell_send_request(buffer, 1, 1);\r\nout:\r\nrelease_buffer();\r\nreturn 0;\r\n}\r\nstatic int dell_get_intensity(struct backlight_device *bd)\r\n{\r\nint ret = 0;\r\nget_buffer();\r\nbuffer->input[0] = find_token_location(BRIGHTNESS_TOKEN);\r\nif (buffer->input[0] == -1) {\r\nret = -ENODEV;\r\ngoto out;\r\n}\r\nif (power_supply_is_system_supplied() > 0)\r\ndell_send_request(buffer, 0, 2);\r\nelse\r\ndell_send_request(buffer, 0, 1);\r\nret = buffer->output[1];\r\nout:\r\nrelease_buffer();\r\nreturn ret;\r\n}\r\nstatic void touchpad_led_on(void)\r\n{\r\nint command = 0x97;\r\nchar data = 1;\r\ni8042_command(&data, command | 1 << 12);\r\n}\r\nstatic void touchpad_led_off(void)\r\n{\r\nint command = 0x97;\r\nchar data = 2;\r\ni8042_command(&data, command | 1 << 12);\r\n}\r\nstatic void touchpad_led_set(struct led_classdev *led_cdev,\r\nenum led_brightness value)\r\n{\r\nif (value > 0)\r\ntouchpad_led_on();\r\nelse\r\ntouchpad_led_off();\r\n}\r\nstatic int touchpad_led_init(struct device *dev)\r\n{\r\nreturn led_classdev_register(dev, &touchpad_led);\r\n}\r\nstatic void touchpad_led_exit(void)\r\n{\r\nled_classdev_unregister(&touchpad_led);\r\n}\r\nstatic int __init dell_init(void)\r\n{\r\nint max_intensity = 0;\r\nint ret;\r\nif (!dmi_check_system(dell_device_table))\r\nreturn -ENODEV;\r\nquirks = NULL;\r\ndmi_check_system(dell_quirks);\r\ndmi_walk(find_tokens, NULL);\r\nif (!da_tokens) {\r\npr_info("Unable to find dmi tokens\n");\r\nreturn -ENODEV;\r\n}\r\nret = platform_driver_register(&platform_driver);\r\nif (ret)\r\ngoto fail_platform_driver;\r\nplatform_device = platform_device_alloc("dell-laptop", -1);\r\nif (!platform_device) {\r\nret = -ENOMEM;\r\ngoto fail_platform_device1;\r\n}\r\nret = platform_device_add(platform_device);\r\nif (ret)\r\ngoto fail_platform_device2;\r\nbufferpage = alloc_page(GFP_KERNEL | GFP_DMA32);\r\nif (!bufferpage)\r\ngoto fail_buffer;\r\nbuffer = page_address(bufferpage);\r\nif (quirks && quirks->touchpad_led)\r\ntouchpad_led_init(&platform_device->dev);\r\ndell_laptop_dir = debugfs_create_dir("dell_laptop", NULL);\r\n#ifdef CONFIG_ACPI\r\nif (acpi_video_backlight_support())\r\nreturn 0;\r\n#endif\r\nget_buffer();\r\nbuffer->input[0] = find_token_location(BRIGHTNESS_TOKEN);\r\nif (buffer->input[0] != -1) {\r\ndell_send_request(buffer, 0, 2);\r\nmax_intensity = buffer->output[3];\r\n}\r\nrelease_buffer();\r\nif (max_intensity) {\r\nstruct backlight_properties props;\r\nmemset(&props, 0, sizeof(struct backlight_properties));\r\nprops.type = BACKLIGHT_PLATFORM;\r\nprops.max_brightness = max_intensity;\r\ndell_backlight_device = backlight_device_register("dell_backlight",\r\n&platform_device->dev,\r\nNULL,\r\n&dell_ops,\r\n&props);\r\nif (IS_ERR(dell_backlight_device)) {\r\nret = PTR_ERR(dell_backlight_device);\r\ndell_backlight_device = NULL;\r\ngoto fail_backlight;\r\n}\r\ndell_backlight_device->props.brightness =\r\ndell_get_intensity(dell_backlight_device);\r\nbacklight_update_status(dell_backlight_device);\r\n}\r\nreturn 0;\r\nfail_backlight:\r\nfree_page((unsigned long)bufferpage);\r\nfail_buffer:\r\nplatform_device_del(platform_device);\r\nfail_platform_device2:\r\nplatform_device_put(platform_device);\r\nfail_platform_device1:\r\nplatform_driver_unregister(&platform_driver);\r\nfail_platform_driver:\r\nkfree(da_tokens);\r\nreturn ret;\r\n}\r\nstatic void __exit dell_exit(void)\r\n{\r\ndebugfs_remove_recursive(dell_laptop_dir);\r\nif (quirks && quirks->touchpad_led)\r\ntouchpad_led_exit();\r\nbacklight_device_unregister(dell_backlight_device);\r\nif (platform_device) {\r\nplatform_device_unregister(platform_device);\r\nplatform_driver_unregister(&platform_driver);\r\n}\r\nkfree(da_tokens);\r\nfree_page((unsigned long)buffer);\r\n}
