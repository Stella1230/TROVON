static int iscsi_sw_tcp_recv(read_descriptor_t *rd_desc, struct sk_buff *skb,\r\nunsigned int offset, size_t len)\r\n{\r\nstruct iscsi_conn *conn = rd_desc->arg.data;\r\nunsigned int consumed, total_consumed = 0;\r\nint status;\r\nISCSI_SW_TCP_DBG(conn, "in %d bytes\n", skb->len - offset);\r\ndo {\r\nstatus = 0;\r\nconsumed = iscsi_tcp_recv_skb(conn, skb, offset, 0, &status);\r\noffset += consumed;\r\ntotal_consumed += consumed;\r\n} while (consumed != 0 && status != ISCSI_TCP_SKB_DONE);\r\nISCSI_SW_TCP_DBG(conn, "read %d bytes status %d\n",\r\nskb->len - offset, status);\r\nreturn total_consumed;\r\n}\r\nstatic inline int iscsi_sw_sk_state_check(struct sock *sk)\r\n{\r\nstruct iscsi_conn *conn = sk->sk_user_data;\r\nif ((sk->sk_state == TCP_CLOSE_WAIT || sk->sk_state == TCP_CLOSE) &&\r\n!atomic_read(&sk->sk_rmem_alloc)) {\r\nISCSI_SW_TCP_DBG(conn, "TCP_CLOSE|TCP_CLOSE_WAIT\n");\r\niscsi_conn_failure(conn, ISCSI_ERR_TCP_CONN_CLOSE);\r\nreturn -ECONNRESET;\r\n}\r\nreturn 0;\r\n}\r\nstatic void iscsi_sw_tcp_data_ready(struct sock *sk, int flag)\r\n{\r\nstruct iscsi_conn *conn;\r\nstruct iscsi_tcp_conn *tcp_conn;\r\nread_descriptor_t rd_desc;\r\nread_lock(&sk->sk_callback_lock);\r\nconn = sk->sk_user_data;\r\nif (!conn) {\r\nread_unlock(&sk->sk_callback_lock);\r\nreturn;\r\n}\r\ntcp_conn = conn->dd_data;\r\nrd_desc.arg.data = conn;\r\nrd_desc.count = 1;\r\ntcp_read_sock(sk, &rd_desc, iscsi_sw_tcp_recv);\r\niscsi_sw_sk_state_check(sk);\r\niscsi_tcp_segment_unmap(&tcp_conn->in.segment);\r\nread_unlock(&sk->sk_callback_lock);\r\n}\r\nstatic void iscsi_sw_tcp_state_change(struct sock *sk)\r\n{\r\nstruct iscsi_tcp_conn *tcp_conn;\r\nstruct iscsi_sw_tcp_conn *tcp_sw_conn;\r\nstruct iscsi_conn *conn;\r\nstruct iscsi_session *session;\r\nvoid (*old_state_change)(struct sock *);\r\nread_lock(&sk->sk_callback_lock);\r\nconn = sk->sk_user_data;\r\nif (!conn) {\r\nread_unlock(&sk->sk_callback_lock);\r\nreturn;\r\n}\r\nsession = conn->session;\r\niscsi_sw_sk_state_check(sk);\r\ntcp_conn = conn->dd_data;\r\ntcp_sw_conn = tcp_conn->dd_data;\r\nold_state_change = tcp_sw_conn->old_state_change;\r\nread_unlock(&sk->sk_callback_lock);\r\nold_state_change(sk);\r\n}\r\nstatic void iscsi_sw_tcp_write_space(struct sock *sk)\r\n{\r\nstruct iscsi_conn *conn;\r\nstruct iscsi_tcp_conn *tcp_conn;\r\nstruct iscsi_sw_tcp_conn *tcp_sw_conn;\r\nvoid (*old_write_space)(struct sock *);\r\nread_lock_bh(&sk->sk_callback_lock);\r\nconn = sk->sk_user_data;\r\nif (!conn) {\r\nread_unlock_bh(&sk->sk_callback_lock);\r\nreturn;\r\n}\r\ntcp_conn = conn->dd_data;\r\ntcp_sw_conn = tcp_conn->dd_data;\r\nold_write_space = tcp_sw_conn->old_write_space;\r\nread_unlock_bh(&sk->sk_callback_lock);\r\nold_write_space(sk);\r\nISCSI_SW_TCP_DBG(conn, "iscsi_write_space\n");\r\niscsi_conn_queue_work(conn);\r\n}\r\nstatic void iscsi_sw_tcp_conn_set_callbacks(struct iscsi_conn *conn)\r\n{\r\nstruct iscsi_tcp_conn *tcp_conn = conn->dd_data;\r\nstruct iscsi_sw_tcp_conn *tcp_sw_conn = tcp_conn->dd_data;\r\nstruct sock *sk = tcp_sw_conn->sock->sk;\r\nwrite_lock_bh(&sk->sk_callback_lock);\r\nsk->sk_user_data = conn;\r\ntcp_sw_conn->old_data_ready = sk->sk_data_ready;\r\ntcp_sw_conn->old_state_change = sk->sk_state_change;\r\ntcp_sw_conn->old_write_space = sk->sk_write_space;\r\nsk->sk_data_ready = iscsi_sw_tcp_data_ready;\r\nsk->sk_state_change = iscsi_sw_tcp_state_change;\r\nsk->sk_write_space = iscsi_sw_tcp_write_space;\r\nwrite_unlock_bh(&sk->sk_callback_lock);\r\n}\r\nstatic void\r\niscsi_sw_tcp_conn_restore_callbacks(struct iscsi_conn *conn)\r\n{\r\nstruct iscsi_tcp_conn *tcp_conn = conn->dd_data;\r\nstruct iscsi_sw_tcp_conn *tcp_sw_conn = tcp_conn->dd_data;\r\nstruct sock *sk = tcp_sw_conn->sock->sk;\r\nwrite_lock_bh(&sk->sk_callback_lock);\r\nsk->sk_user_data = NULL;\r\nsk->sk_data_ready = tcp_sw_conn->old_data_ready;\r\nsk->sk_state_change = tcp_sw_conn->old_state_change;\r\nsk->sk_write_space = tcp_sw_conn->old_write_space;\r\nsk->sk_no_check = 0;\r\nwrite_unlock_bh(&sk->sk_callback_lock);\r\n}\r\nstatic int iscsi_sw_tcp_xmit_segment(struct iscsi_tcp_conn *tcp_conn,\r\nstruct iscsi_segment *segment)\r\n{\r\nstruct iscsi_sw_tcp_conn *tcp_sw_conn = tcp_conn->dd_data;\r\nstruct socket *sk = tcp_sw_conn->sock;\r\nunsigned int copied = 0;\r\nint r = 0;\r\nwhile (!iscsi_tcp_segment_done(tcp_conn, segment, 0, r)) {\r\nstruct scatterlist *sg;\r\nunsigned int offset, copy;\r\nint flags = 0;\r\nr = 0;\r\noffset = segment->copied;\r\ncopy = segment->size - offset;\r\nif (segment->total_copied + segment->size < segment->total_size)\r\nflags |= MSG_MORE;\r\nif (!segment->data) {\r\nsg = segment->sg;\r\noffset += segment->sg_offset + sg->offset;\r\nr = tcp_sw_conn->sendpage(sk, sg_page(sg), offset,\r\ncopy, flags);\r\n} else {\r\nstruct msghdr msg = { .msg_flags = flags };\r\nstruct kvec iov = {\r\n.iov_base = segment->data + offset,\r\n.iov_len = copy\r\n};\r\nr = kernel_sendmsg(sk, &msg, &iov, 1, copy);\r\n}\r\nif (r < 0) {\r\niscsi_tcp_segment_unmap(segment);\r\nreturn r;\r\n}\r\ncopied += r;\r\n}\r\nreturn copied;\r\n}\r\nstatic int iscsi_sw_tcp_xmit(struct iscsi_conn *conn)\r\n{\r\nstruct iscsi_tcp_conn *tcp_conn = conn->dd_data;\r\nstruct iscsi_sw_tcp_conn *tcp_sw_conn = tcp_conn->dd_data;\r\nstruct iscsi_segment *segment = &tcp_sw_conn->out.segment;\r\nunsigned int consumed = 0;\r\nint rc = 0;\r\nwhile (1) {\r\nrc = iscsi_sw_tcp_xmit_segment(tcp_conn, segment);\r\nif (rc == -EAGAIN)\r\nreturn rc;\r\nelse if (rc < 0) {\r\nrc = ISCSI_ERR_XMIT_FAILED;\r\ngoto error;\r\n} else if (rc == 0)\r\nbreak;\r\nconsumed += rc;\r\nif (segment->total_copied >= segment->total_size) {\r\nif (segment->done != NULL) {\r\nrc = segment->done(tcp_conn, segment);\r\nif (rc != 0)\r\ngoto error;\r\n}\r\n}\r\n}\r\nISCSI_SW_TCP_DBG(conn, "xmit %d bytes\n", consumed);\r\nconn->txdata_octets += consumed;\r\nreturn consumed;\r\nerror:\r\nISCSI_SW_TCP_DBG(conn, "Error sending PDU, errno=%d\n", rc);\r\niscsi_conn_failure(conn, rc);\r\nreturn -EIO;\r\n}\r\nstatic inline int iscsi_sw_tcp_xmit_qlen(struct iscsi_conn *conn)\r\n{\r\nstruct iscsi_tcp_conn *tcp_conn = conn->dd_data;\r\nstruct iscsi_sw_tcp_conn *tcp_sw_conn = tcp_conn->dd_data;\r\nstruct iscsi_segment *segment = &tcp_sw_conn->out.segment;\r\nreturn segment->total_copied - segment->total_size;\r\n}\r\nstatic int iscsi_sw_tcp_pdu_xmit(struct iscsi_task *task)\r\n{\r\nstruct iscsi_conn *conn = task->conn;\r\nint rc;\r\nwhile (iscsi_sw_tcp_xmit_qlen(conn)) {\r\nrc = iscsi_sw_tcp_xmit(conn);\r\nif (rc == 0)\r\nreturn -EAGAIN;\r\nif (rc < 0)\r\nreturn rc;\r\n}\r\nreturn 0;\r\n}\r\nstatic int iscsi_sw_tcp_send_hdr_done(struct iscsi_tcp_conn *tcp_conn,\r\nstruct iscsi_segment *segment)\r\n{\r\nstruct iscsi_sw_tcp_conn *tcp_sw_conn = tcp_conn->dd_data;\r\ntcp_sw_conn->out.segment = tcp_sw_conn->out.data_segment;\r\nISCSI_SW_TCP_DBG(tcp_conn->iscsi_conn,\r\n"Header done. Next segment size %u total_size %u\n",\r\ntcp_sw_conn->out.segment.size,\r\ntcp_sw_conn->out.segment.total_size);\r\nreturn 0;\r\n}\r\nstatic void iscsi_sw_tcp_send_hdr_prep(struct iscsi_conn *conn, void *hdr,\r\nsize_t hdrlen)\r\n{\r\nstruct iscsi_tcp_conn *tcp_conn = conn->dd_data;\r\nstruct iscsi_sw_tcp_conn *tcp_sw_conn = tcp_conn->dd_data;\r\nISCSI_SW_TCP_DBG(conn, "%s\n", conn->hdrdgst_en ?\r\n"digest enabled" : "digest disabled");\r\nmemset(&tcp_sw_conn->out.data_segment, 0,\r\nsizeof(struct iscsi_segment));\r\nif (conn->hdrdgst_en) {\r\niscsi_tcp_dgst_header(&tcp_sw_conn->tx_hash, hdr, hdrlen,\r\nhdr + hdrlen);\r\nhdrlen += ISCSI_DIGEST_SIZE;\r\n}\r\ntcp_sw_conn->out.hdr = hdr;\r\niscsi_segment_init_linear(&tcp_sw_conn->out.segment, hdr, hdrlen,\r\niscsi_sw_tcp_send_hdr_done, NULL);\r\n}\r\nstatic int\r\niscsi_sw_tcp_send_data_prep(struct iscsi_conn *conn, struct scatterlist *sg,\r\nunsigned int count, unsigned int offset,\r\nunsigned int len)\r\n{\r\nstruct iscsi_tcp_conn *tcp_conn = conn->dd_data;\r\nstruct iscsi_sw_tcp_conn *tcp_sw_conn = tcp_conn->dd_data;\r\nstruct hash_desc *tx_hash = NULL;\r\nunsigned int hdr_spec_len;\r\nISCSI_SW_TCP_DBG(conn, "offset=%d, datalen=%d %s\n", offset, len,\r\nconn->datadgst_en ?\r\n"digest enabled" : "digest disabled");\r\nhdr_spec_len = ntoh24(tcp_sw_conn->out.hdr->dlength);\r\nWARN_ON(iscsi_padded(len) != iscsi_padded(hdr_spec_len));\r\nif (conn->datadgst_en)\r\ntx_hash = &tcp_sw_conn->tx_hash;\r\nreturn iscsi_segment_seek_sg(&tcp_sw_conn->out.data_segment,\r\nsg, count, offset, len,\r\nNULL, tx_hash);\r\n}\r\nstatic void\r\niscsi_sw_tcp_send_linear_data_prep(struct iscsi_conn *conn, void *data,\r\nsize_t len)\r\n{\r\nstruct iscsi_tcp_conn *tcp_conn = conn->dd_data;\r\nstruct iscsi_sw_tcp_conn *tcp_sw_conn = tcp_conn->dd_data;\r\nstruct hash_desc *tx_hash = NULL;\r\nunsigned int hdr_spec_len;\r\nISCSI_SW_TCP_DBG(conn, "datalen=%zd %s\n", len, conn->datadgst_en ?\r\n"digest enabled" : "digest disabled");\r\nhdr_spec_len = ntoh24(tcp_sw_conn->out.hdr->dlength);\r\nWARN_ON(iscsi_padded(len) != iscsi_padded(hdr_spec_len));\r\nif (conn->datadgst_en)\r\ntx_hash = &tcp_sw_conn->tx_hash;\r\niscsi_segment_init_linear(&tcp_sw_conn->out.data_segment,\r\ndata, len, NULL, tx_hash);\r\n}\r\nstatic int iscsi_sw_tcp_pdu_init(struct iscsi_task *task,\r\nunsigned int offset, unsigned int count)\r\n{\r\nstruct iscsi_conn *conn = task->conn;\r\nint err = 0;\r\niscsi_sw_tcp_send_hdr_prep(conn, task->hdr, task->hdr_len);\r\nif (!count)\r\nreturn 0;\r\nif (!task->sc)\r\niscsi_sw_tcp_send_linear_data_prep(conn, task->data, count);\r\nelse {\r\nstruct scsi_data_buffer *sdb = scsi_out(task->sc);\r\nerr = iscsi_sw_tcp_send_data_prep(conn, sdb->table.sgl,\r\nsdb->table.nents, offset,\r\ncount);\r\n}\r\nif (err) {\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic int iscsi_sw_tcp_pdu_alloc(struct iscsi_task *task, uint8_t opcode)\r\n{\r\nstruct iscsi_tcp_task *tcp_task = task->dd_data;\r\ntask->hdr = task->dd_data + sizeof(*tcp_task);\r\ntask->hdr_max = sizeof(struct iscsi_sw_tcp_hdrbuf) - ISCSI_DIGEST_SIZE;\r\nreturn 0;\r\n}\r\nstatic struct iscsi_cls_conn *\r\niscsi_sw_tcp_conn_create(struct iscsi_cls_session *cls_session,\r\nuint32_t conn_idx)\r\n{\r\nstruct iscsi_conn *conn;\r\nstruct iscsi_cls_conn *cls_conn;\r\nstruct iscsi_tcp_conn *tcp_conn;\r\nstruct iscsi_sw_tcp_conn *tcp_sw_conn;\r\ncls_conn = iscsi_tcp_conn_setup(cls_session, sizeof(*tcp_sw_conn),\r\nconn_idx);\r\nif (!cls_conn)\r\nreturn NULL;\r\nconn = cls_conn->dd_data;\r\ntcp_conn = conn->dd_data;\r\ntcp_sw_conn = tcp_conn->dd_data;\r\ntcp_sw_conn->tx_hash.tfm = crypto_alloc_hash("crc32c", 0,\r\nCRYPTO_ALG_ASYNC);\r\ntcp_sw_conn->tx_hash.flags = 0;\r\nif (IS_ERR(tcp_sw_conn->tx_hash.tfm))\r\ngoto free_conn;\r\ntcp_sw_conn->rx_hash.tfm = crypto_alloc_hash("crc32c", 0,\r\nCRYPTO_ALG_ASYNC);\r\ntcp_sw_conn->rx_hash.flags = 0;\r\nif (IS_ERR(tcp_sw_conn->rx_hash.tfm))\r\ngoto free_tx_tfm;\r\ntcp_conn->rx_hash = &tcp_sw_conn->rx_hash;\r\nreturn cls_conn;\r\nfree_tx_tfm:\r\ncrypto_free_hash(tcp_sw_conn->tx_hash.tfm);\r\nfree_conn:\r\niscsi_conn_printk(KERN_ERR, conn,\r\n"Could not create connection due to crc32c "\r\n"loading error. Make sure the crc32c "\r\n"module is built as a module or into the "\r\n"kernel\n");\r\niscsi_tcp_conn_teardown(cls_conn);\r\nreturn NULL;\r\n}\r\nstatic void iscsi_sw_tcp_release_conn(struct iscsi_conn *conn)\r\n{\r\nstruct iscsi_session *session = conn->session;\r\nstruct iscsi_tcp_conn *tcp_conn = conn->dd_data;\r\nstruct iscsi_sw_tcp_conn *tcp_sw_conn = tcp_conn->dd_data;\r\nstruct socket *sock = tcp_sw_conn->sock;\r\nif (!sock)\r\nreturn;\r\nsock_hold(sock->sk);\r\niscsi_sw_tcp_conn_restore_callbacks(conn);\r\nsock_put(sock->sk);\r\nspin_lock_bh(&session->lock);\r\ntcp_sw_conn->sock = NULL;\r\nspin_unlock_bh(&session->lock);\r\nsockfd_put(sock);\r\n}\r\nstatic void iscsi_sw_tcp_conn_destroy(struct iscsi_cls_conn *cls_conn)\r\n{\r\nstruct iscsi_conn *conn = cls_conn->dd_data;\r\nstruct iscsi_tcp_conn *tcp_conn = conn->dd_data;\r\nstruct iscsi_sw_tcp_conn *tcp_sw_conn = tcp_conn->dd_data;\r\niscsi_sw_tcp_release_conn(conn);\r\nif (tcp_sw_conn->tx_hash.tfm)\r\ncrypto_free_hash(tcp_sw_conn->tx_hash.tfm);\r\nif (tcp_sw_conn->rx_hash.tfm)\r\ncrypto_free_hash(tcp_sw_conn->rx_hash.tfm);\r\niscsi_tcp_conn_teardown(cls_conn);\r\n}\r\nstatic void iscsi_sw_tcp_conn_stop(struct iscsi_cls_conn *cls_conn, int flag)\r\n{\r\nstruct iscsi_conn *conn = cls_conn->dd_data;\r\nstruct iscsi_tcp_conn *tcp_conn = conn->dd_data;\r\nstruct iscsi_sw_tcp_conn *tcp_sw_conn = tcp_conn->dd_data;\r\nstruct socket *sock = tcp_sw_conn->sock;\r\nif (!sock)\r\nreturn;\r\nsock->sk->sk_err = EIO;\r\nwake_up_interruptible(sk_sleep(sock->sk));\r\niscsi_suspend_tx(conn);\r\niscsi_sw_tcp_release_conn(conn);\r\niscsi_conn_stop(cls_conn, flag);\r\n}\r\nstatic int\r\niscsi_sw_tcp_conn_bind(struct iscsi_cls_session *cls_session,\r\nstruct iscsi_cls_conn *cls_conn, uint64_t transport_eph,\r\nint is_leading)\r\n{\r\nstruct iscsi_session *session = cls_session->dd_data;\r\nstruct iscsi_conn *conn = cls_conn->dd_data;\r\nstruct iscsi_tcp_conn *tcp_conn = conn->dd_data;\r\nstruct iscsi_sw_tcp_conn *tcp_sw_conn = tcp_conn->dd_data;\r\nstruct sock *sk;\r\nstruct socket *sock;\r\nint err;\r\nsock = sockfd_lookup((int)transport_eph, &err);\r\nif (!sock) {\r\niscsi_conn_printk(KERN_ERR, conn,\r\n"sockfd_lookup failed %d\n", err);\r\nreturn -EEXIST;\r\n}\r\nerr = iscsi_conn_bind(cls_session, cls_conn, is_leading);\r\nif (err)\r\ngoto free_socket;\r\nspin_lock_bh(&session->lock);\r\ntcp_sw_conn->sock = sock;\r\nspin_unlock_bh(&session->lock);\r\nsk = sock->sk;\r\nsk->sk_reuse = SK_CAN_REUSE;\r\nsk->sk_sndtimeo = 15 * HZ;\r\nsk->sk_allocation = GFP_ATOMIC;\r\niscsi_sw_tcp_conn_set_callbacks(conn);\r\ntcp_sw_conn->sendpage = tcp_sw_conn->sock->ops->sendpage;\r\niscsi_tcp_hdr_recv_prep(tcp_conn);\r\nreturn 0;\r\nfree_socket:\r\nsockfd_put(sock);\r\nreturn err;\r\n}\r\nstatic int iscsi_sw_tcp_conn_set_param(struct iscsi_cls_conn *cls_conn,\r\nenum iscsi_param param, char *buf,\r\nint buflen)\r\n{\r\nstruct iscsi_conn *conn = cls_conn->dd_data;\r\nstruct iscsi_tcp_conn *tcp_conn = conn->dd_data;\r\nstruct iscsi_sw_tcp_conn *tcp_sw_conn = tcp_conn->dd_data;\r\nswitch(param) {\r\ncase ISCSI_PARAM_HDRDGST_EN:\r\niscsi_set_param(cls_conn, param, buf, buflen);\r\nbreak;\r\ncase ISCSI_PARAM_DATADGST_EN:\r\niscsi_set_param(cls_conn, param, buf, buflen);\r\ntcp_sw_conn->sendpage = conn->datadgst_en ?\r\nsock_no_sendpage : tcp_sw_conn->sock->ops->sendpage;\r\nbreak;\r\ncase ISCSI_PARAM_MAX_R2T:\r\nreturn iscsi_tcp_set_max_r2t(conn, buf);\r\ndefault:\r\nreturn iscsi_set_param(cls_conn, param, buf, buflen);\r\n}\r\nreturn 0;\r\n}\r\nstatic int iscsi_sw_tcp_conn_get_param(struct iscsi_cls_conn *cls_conn,\r\nenum iscsi_param param, char *buf)\r\n{\r\nstruct iscsi_conn *conn = cls_conn->dd_data;\r\nstruct iscsi_tcp_conn *tcp_conn = conn->dd_data;\r\nstruct iscsi_sw_tcp_conn *tcp_sw_conn = tcp_conn->dd_data;\r\nstruct sockaddr_in6 addr;\r\nint rc, len;\r\nswitch(param) {\r\ncase ISCSI_PARAM_CONN_PORT:\r\ncase ISCSI_PARAM_CONN_ADDRESS:\r\nspin_lock_bh(&conn->session->lock);\r\nif (!tcp_sw_conn || !tcp_sw_conn->sock) {\r\nspin_unlock_bh(&conn->session->lock);\r\nreturn -ENOTCONN;\r\n}\r\nrc = kernel_getpeername(tcp_sw_conn->sock,\r\n(struct sockaddr *)&addr, &len);\r\nspin_unlock_bh(&conn->session->lock);\r\nif (rc)\r\nreturn rc;\r\nreturn iscsi_conn_get_addr_param((struct sockaddr_storage *)\r\n&addr, param, buf);\r\ndefault:\r\nreturn iscsi_conn_get_param(cls_conn, param, buf);\r\n}\r\nreturn 0;\r\n}\r\nstatic int iscsi_sw_tcp_host_get_param(struct Scsi_Host *shost,\r\nenum iscsi_host_param param, char *buf)\r\n{\r\nstruct iscsi_sw_tcp_host *tcp_sw_host = iscsi_host_priv(shost);\r\nstruct iscsi_session *session = tcp_sw_host->session;\r\nstruct iscsi_conn *conn;\r\nstruct iscsi_tcp_conn *tcp_conn;\r\nstruct iscsi_sw_tcp_conn *tcp_sw_conn;\r\nstruct sockaddr_in6 addr;\r\nint rc, len;\r\nswitch (param) {\r\ncase ISCSI_HOST_PARAM_IPADDRESS:\r\nspin_lock_bh(&session->lock);\r\nconn = session->leadconn;\r\nif (!conn) {\r\nspin_unlock_bh(&session->lock);\r\nreturn -ENOTCONN;\r\n}\r\ntcp_conn = conn->dd_data;\r\ntcp_sw_conn = tcp_conn->dd_data;\r\nif (!tcp_sw_conn->sock) {\r\nspin_unlock_bh(&session->lock);\r\nreturn -ENOTCONN;\r\n}\r\nrc = kernel_getsockname(tcp_sw_conn->sock,\r\n(struct sockaddr *)&addr, &len);\r\nspin_unlock_bh(&session->lock);\r\nif (rc)\r\nreturn rc;\r\nreturn iscsi_conn_get_addr_param((struct sockaddr_storage *)\r\n&addr, param, buf);\r\ndefault:\r\nreturn iscsi_host_get_param(shost, param, buf);\r\n}\r\nreturn 0;\r\n}\r\nstatic void\r\niscsi_sw_tcp_conn_get_stats(struct iscsi_cls_conn *cls_conn,\r\nstruct iscsi_stats *stats)\r\n{\r\nstruct iscsi_conn *conn = cls_conn->dd_data;\r\nstruct iscsi_tcp_conn *tcp_conn = conn->dd_data;\r\nstruct iscsi_sw_tcp_conn *tcp_sw_conn = tcp_conn->dd_data;\r\nstats->custom_length = 3;\r\nstrcpy(stats->custom[0].desc, "tx_sendpage_failures");\r\nstats->custom[0].value = tcp_sw_conn->sendpage_failures_cnt;\r\nstrcpy(stats->custom[1].desc, "rx_discontiguous_hdr");\r\nstats->custom[1].value = tcp_sw_conn->discontiguous_hdr_cnt;\r\nstrcpy(stats->custom[2].desc, "eh_abort_cnt");\r\nstats->custom[2].value = conn->eh_abort_cnt;\r\niscsi_tcp_conn_get_stats(cls_conn, stats);\r\n}\r\nstatic struct iscsi_cls_session *\r\niscsi_sw_tcp_session_create(struct iscsi_endpoint *ep, uint16_t cmds_max,\r\nuint16_t qdepth, uint32_t initial_cmdsn)\r\n{\r\nstruct iscsi_cls_session *cls_session;\r\nstruct iscsi_session *session;\r\nstruct iscsi_sw_tcp_host *tcp_sw_host;\r\nstruct Scsi_Host *shost;\r\nif (ep) {\r\nprintk(KERN_ERR "iscsi_tcp: invalid ep %p.\n", ep);\r\nreturn NULL;\r\n}\r\nshost = iscsi_host_alloc(&iscsi_sw_tcp_sht,\r\nsizeof(struct iscsi_sw_tcp_host), 1);\r\nif (!shost)\r\nreturn NULL;\r\nshost->transportt = iscsi_sw_tcp_scsi_transport;\r\nshost->cmd_per_lun = qdepth;\r\nshost->max_lun = iscsi_max_lun;\r\nshost->max_id = 0;\r\nshost->max_channel = 0;\r\nshost->max_cmd_len = SCSI_MAX_VARLEN_CDB_SIZE;\r\nif (iscsi_host_add(shost, NULL))\r\ngoto free_host;\r\ncls_session = iscsi_session_setup(&iscsi_sw_tcp_transport, shost,\r\ncmds_max, 0,\r\nsizeof(struct iscsi_tcp_task) +\r\nsizeof(struct iscsi_sw_tcp_hdrbuf),\r\ninitial_cmdsn, 0);\r\nif (!cls_session)\r\ngoto remove_host;\r\nsession = cls_session->dd_data;\r\ntcp_sw_host = iscsi_host_priv(shost);\r\ntcp_sw_host->session = session;\r\nshost->can_queue = session->scsi_cmds_max;\r\nif (iscsi_tcp_r2tpool_alloc(session))\r\ngoto remove_session;\r\nreturn cls_session;\r\nremove_session:\r\niscsi_session_teardown(cls_session);\r\nremove_host:\r\niscsi_host_remove(shost);\r\nfree_host:\r\niscsi_host_free(shost);\r\nreturn NULL;\r\n}\r\nstatic void iscsi_sw_tcp_session_destroy(struct iscsi_cls_session *cls_session)\r\n{\r\nstruct Scsi_Host *shost = iscsi_session_to_shost(cls_session);\r\niscsi_tcp_r2tpool_free(cls_session->dd_data);\r\niscsi_session_teardown(cls_session);\r\niscsi_host_remove(shost);\r\niscsi_host_free(shost);\r\n}\r\nstatic umode_t iscsi_sw_tcp_attr_is_visible(int param_type, int param)\r\n{\r\nswitch (param_type) {\r\ncase ISCSI_HOST_PARAM:\r\nswitch (param) {\r\ncase ISCSI_HOST_PARAM_NETDEV_NAME:\r\ncase ISCSI_HOST_PARAM_HWADDRESS:\r\ncase ISCSI_HOST_PARAM_IPADDRESS:\r\ncase ISCSI_HOST_PARAM_INITIATOR_NAME:\r\nreturn S_IRUGO;\r\ndefault:\r\nreturn 0;\r\n}\r\ncase ISCSI_PARAM:\r\nswitch (param) {\r\ncase ISCSI_PARAM_MAX_RECV_DLENGTH:\r\ncase ISCSI_PARAM_MAX_XMIT_DLENGTH:\r\ncase ISCSI_PARAM_HDRDGST_EN:\r\ncase ISCSI_PARAM_DATADGST_EN:\r\ncase ISCSI_PARAM_CONN_ADDRESS:\r\ncase ISCSI_PARAM_CONN_PORT:\r\ncase ISCSI_PARAM_EXP_STATSN:\r\ncase ISCSI_PARAM_PERSISTENT_ADDRESS:\r\ncase ISCSI_PARAM_PERSISTENT_PORT:\r\ncase ISCSI_PARAM_PING_TMO:\r\ncase ISCSI_PARAM_RECV_TMO:\r\ncase ISCSI_PARAM_INITIAL_R2T_EN:\r\ncase ISCSI_PARAM_MAX_R2T:\r\ncase ISCSI_PARAM_IMM_DATA_EN:\r\ncase ISCSI_PARAM_FIRST_BURST:\r\ncase ISCSI_PARAM_MAX_BURST:\r\ncase ISCSI_PARAM_PDU_INORDER_EN:\r\ncase ISCSI_PARAM_DATASEQ_INORDER_EN:\r\ncase ISCSI_PARAM_ERL:\r\ncase ISCSI_PARAM_TARGET_NAME:\r\ncase ISCSI_PARAM_TPGT:\r\ncase ISCSI_PARAM_USERNAME:\r\ncase ISCSI_PARAM_PASSWORD:\r\ncase ISCSI_PARAM_USERNAME_IN:\r\ncase ISCSI_PARAM_PASSWORD_IN:\r\ncase ISCSI_PARAM_FAST_ABORT:\r\ncase ISCSI_PARAM_ABORT_TMO:\r\ncase ISCSI_PARAM_LU_RESET_TMO:\r\ncase ISCSI_PARAM_TGT_RESET_TMO:\r\ncase ISCSI_PARAM_IFACE_NAME:\r\ncase ISCSI_PARAM_INITIATOR_NAME:\r\nreturn S_IRUGO;\r\ndefault:\r\nreturn 0;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int iscsi_sw_tcp_slave_alloc(struct scsi_device *sdev)\r\n{\r\nset_bit(QUEUE_FLAG_BIDI, &sdev->request_queue->queue_flags);\r\nreturn 0;\r\n}\r\nstatic int iscsi_sw_tcp_slave_configure(struct scsi_device *sdev)\r\n{\r\nblk_queue_bounce_limit(sdev->request_queue, BLK_BOUNCE_ANY);\r\nblk_queue_dma_alignment(sdev->request_queue, 0);\r\nreturn 0;\r\n}\r\nstatic int __init iscsi_sw_tcp_init(void)\r\n{\r\nif (iscsi_max_lun < 1) {\r\nprintk(KERN_ERR "iscsi_tcp: Invalid max_lun value of %u\n",\r\niscsi_max_lun);\r\nreturn -EINVAL;\r\n}\r\niscsi_sw_tcp_scsi_transport = iscsi_register_transport(\r\n&iscsi_sw_tcp_transport);\r\nif (!iscsi_sw_tcp_scsi_transport)\r\nreturn -ENODEV;\r\nreturn 0;\r\n}\r\nstatic void __exit iscsi_sw_tcp_exit(void)\r\n{\r\niscsi_unregister_transport(&iscsi_sw_tcp_transport);\r\n}
