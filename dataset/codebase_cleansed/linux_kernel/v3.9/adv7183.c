static inline struct adv7183 *to_adv7183(struct v4l2_subdev *sd)\r\n{\r\nreturn container_of(sd, struct adv7183, sd);\r\n}\r\nstatic inline struct v4l2_subdev *to_sd(struct v4l2_ctrl *ctrl)\r\n{\r\nreturn &container_of(ctrl->handler, struct adv7183, hdl)->sd;\r\n}\r\nstatic inline int adv7183_read(struct v4l2_subdev *sd, unsigned char reg)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nreturn i2c_smbus_read_byte_data(client, reg);\r\n}\r\nstatic inline int adv7183_write(struct v4l2_subdev *sd, unsigned char reg,\r\nunsigned char value)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nreturn i2c_smbus_write_byte_data(client, reg, value);\r\n}\r\nstatic int adv7183_writeregs(struct v4l2_subdev *sd,\r\nconst unsigned char *regs, unsigned int num)\r\n{\r\nunsigned char reg, data;\r\nunsigned int cnt = 0;\r\nif (num & 0x1) {\r\nv4l2_err(sd, "invalid regs array\n");\r\nreturn -1;\r\n}\r\nwhile (cnt < num) {\r\nreg = *regs++;\r\ndata = *regs++;\r\ncnt += 2;\r\nadv7183_write(sd, reg, data);\r\n}\r\nreturn 0;\r\n}\r\nstatic int adv7183_log_status(struct v4l2_subdev *sd)\r\n{\r\nstruct adv7183 *decoder = to_adv7183(sd);\r\nv4l2_info(sd, "adv7183: Input control = 0x%02x\n",\r\nadv7183_read(sd, ADV7183_IN_CTRL));\r\nv4l2_info(sd, "adv7183: Video selection = 0x%02x\n",\r\nadv7183_read(sd, ADV7183_VD_SEL));\r\nv4l2_info(sd, "adv7183: Output control = 0x%02x\n",\r\nadv7183_read(sd, ADV7183_OUT_CTRL));\r\nv4l2_info(sd, "adv7183: Extended output control = 0x%02x\n",\r\nadv7183_read(sd, ADV7183_EXT_OUT_CTRL));\r\nv4l2_info(sd, "adv7183: Autodetect enable = 0x%02x\n",\r\nadv7183_read(sd, ADV7183_AUTO_DET_EN));\r\nv4l2_info(sd, "adv7183: Contrast = 0x%02x\n",\r\nadv7183_read(sd, ADV7183_CONTRAST));\r\nv4l2_info(sd, "adv7183: Brightness = 0x%02x\n",\r\nadv7183_read(sd, ADV7183_BRIGHTNESS));\r\nv4l2_info(sd, "adv7183: Hue = 0x%02x\n",\r\nadv7183_read(sd, ADV7183_HUE));\r\nv4l2_info(sd, "adv7183: Default value Y = 0x%02x\n",\r\nadv7183_read(sd, ADV7183_DEF_Y));\r\nv4l2_info(sd, "adv7183: Default value C = 0x%02x\n",\r\nadv7183_read(sd, ADV7183_DEF_C));\r\nv4l2_info(sd, "adv7183: ADI control = 0x%02x\n",\r\nadv7183_read(sd, ADV7183_ADI_CTRL));\r\nv4l2_info(sd, "adv7183: Power Management = 0x%02x\n",\r\nadv7183_read(sd, ADV7183_POW_MANAGE));\r\nv4l2_info(sd, "adv7183: Status 1 2 and 3 = 0x%02x 0x%02x 0x%02x\n",\r\nadv7183_read(sd, ADV7183_STATUS_1),\r\nadv7183_read(sd, ADV7183_STATUS_2),\r\nadv7183_read(sd, ADV7183_STATUS_3));\r\nv4l2_info(sd, "adv7183: Ident = 0x%02x\n",\r\nadv7183_read(sd, ADV7183_IDENT));\r\nv4l2_info(sd, "adv7183: Analog clamp control = 0x%02x\n",\r\nadv7183_read(sd, ADV7183_ANAL_CLAMP_CTRL));\r\nv4l2_info(sd, "adv7183: Digital clamp control 1 = 0x%02x\n",\r\nadv7183_read(sd, ADV7183_DIGI_CLAMP_CTRL_1));\r\nv4l2_info(sd, "adv7183: Shaping filter control 1 and 2 = 0x%02x 0x%02x\n",\r\nadv7183_read(sd, ADV7183_SHAP_FILT_CTRL),\r\nadv7183_read(sd, ADV7183_SHAP_FILT_CTRL_2));\r\nv4l2_info(sd, "adv7183: Comb filter control = 0x%02x\n",\r\nadv7183_read(sd, ADV7183_COMB_FILT_CTRL));\r\nv4l2_info(sd, "adv7183: ADI control 2 = 0x%02x\n",\r\nadv7183_read(sd, ADV7183_ADI_CTRL_2));\r\nv4l2_info(sd, "adv7183: Pixel delay control = 0x%02x\n",\r\nadv7183_read(sd, ADV7183_PIX_DELAY_CTRL));\r\nv4l2_info(sd, "adv7183: Misc gain control = 0x%02x\n",\r\nadv7183_read(sd, ADV7183_MISC_GAIN_CTRL));\r\nv4l2_info(sd, "adv7183: AGC mode control = 0x%02x\n",\r\nadv7183_read(sd, ADV7183_AGC_MODE_CTRL));\r\nv4l2_info(sd, "adv7183: Chroma gain control 1 and 2 = 0x%02x 0x%02x\n",\r\nadv7183_read(sd, ADV7183_CHRO_GAIN_CTRL_1),\r\nadv7183_read(sd, ADV7183_CHRO_GAIN_CTRL_2));\r\nv4l2_info(sd, "adv7183: Luma gain control 1 and 2 = 0x%02x 0x%02x\n",\r\nadv7183_read(sd, ADV7183_LUMA_GAIN_CTRL_1),\r\nadv7183_read(sd, ADV7183_LUMA_GAIN_CTRL_2));\r\nv4l2_info(sd, "adv7183: Vsync field control 1 2 and 3 = 0x%02x 0x%02x 0x%02x\n",\r\nadv7183_read(sd, ADV7183_VS_FIELD_CTRL_1),\r\nadv7183_read(sd, ADV7183_VS_FIELD_CTRL_2),\r\nadv7183_read(sd, ADV7183_VS_FIELD_CTRL_3));\r\nv4l2_info(sd, "adv7183: Hsync positon control 1 2 and 3 = 0x%02x 0x%02x 0x%02x\n",\r\nadv7183_read(sd, ADV7183_HS_POS_CTRL_1),\r\nadv7183_read(sd, ADV7183_HS_POS_CTRL_2),\r\nadv7183_read(sd, ADV7183_HS_POS_CTRL_3));\r\nv4l2_info(sd, "adv7183: Polarity = 0x%02x\n",\r\nadv7183_read(sd, ADV7183_POLARITY));\r\nv4l2_info(sd, "adv7183: ADC control = 0x%02x\n",\r\nadv7183_read(sd, ADV7183_ADC_CTRL));\r\nv4l2_info(sd, "adv7183: SD offset Cb and Cr = 0x%02x 0x%02x\n",\r\nadv7183_read(sd, ADV7183_SD_OFFSET_CB),\r\nadv7183_read(sd, ADV7183_SD_OFFSET_CR));\r\nv4l2_info(sd, "adv7183: SD saturation Cb and Cr = 0x%02x 0x%02x\n",\r\nadv7183_read(sd, ADV7183_SD_SATURATION_CB),\r\nadv7183_read(sd, ADV7183_SD_SATURATION_CR));\r\nv4l2_info(sd, "adv7183: Drive strength = 0x%02x\n",\r\nadv7183_read(sd, ADV7183_DRIVE_STR));\r\nv4l2_ctrl_handler_log_status(&decoder->hdl, sd->name);\r\nreturn 0;\r\n}\r\nstatic int adv7183_g_std(struct v4l2_subdev *sd, v4l2_std_id *std)\r\n{\r\nstruct adv7183 *decoder = to_adv7183(sd);\r\n*std = decoder->std;\r\nreturn 0;\r\n}\r\nstatic int adv7183_s_std(struct v4l2_subdev *sd, v4l2_std_id std)\r\n{\r\nstruct adv7183 *decoder = to_adv7183(sd);\r\nint reg;\r\nreg = adv7183_read(sd, ADV7183_IN_CTRL) & 0xF;\r\nif (std == V4L2_STD_PAL_60)\r\nreg |= 0x60;\r\nelse if (std == V4L2_STD_NTSC_443)\r\nreg |= 0x70;\r\nelse if (std == V4L2_STD_PAL_N)\r\nreg |= 0x90;\r\nelse if (std == V4L2_STD_PAL_M)\r\nreg |= 0xA0;\r\nelse if (std == V4L2_STD_PAL_Nc)\r\nreg |= 0xC0;\r\nelse if (std & V4L2_STD_PAL)\r\nreg |= 0x80;\r\nelse if (std & V4L2_STD_NTSC)\r\nreg |= 0x50;\r\nelse if (std & V4L2_STD_SECAM)\r\nreg |= 0xE0;\r\nelse\r\nreturn -EINVAL;\r\nadv7183_write(sd, ADV7183_IN_CTRL, reg);\r\ndecoder->std = std;\r\nreturn 0;\r\n}\r\nstatic int adv7183_reset(struct v4l2_subdev *sd, u32 val)\r\n{\r\nint reg;\r\nreg = adv7183_read(sd, ADV7183_POW_MANAGE) | 0x80;\r\nadv7183_write(sd, ADV7183_POW_MANAGE, reg);\r\nusleep_range(5000, 10000);\r\nreturn 0;\r\n}\r\nstatic int adv7183_s_routing(struct v4l2_subdev *sd,\r\nu32 input, u32 output, u32 config)\r\n{\r\nstruct adv7183 *decoder = to_adv7183(sd);\r\nint reg;\r\nif ((input > ADV7183_COMPONENT1) || (output > ADV7183_16BIT_OUT))\r\nreturn -EINVAL;\r\nif (input != decoder->input) {\r\ndecoder->input = input;\r\nreg = adv7183_read(sd, ADV7183_IN_CTRL) & 0xF0;\r\nswitch (input) {\r\ncase ADV7183_COMPOSITE1:\r\nreg |= 0x1;\r\nbreak;\r\ncase ADV7183_COMPOSITE2:\r\nreg |= 0x2;\r\nbreak;\r\ncase ADV7183_COMPOSITE3:\r\nreg |= 0x3;\r\nbreak;\r\ncase ADV7183_COMPOSITE4:\r\nreg |= 0x4;\r\nbreak;\r\ncase ADV7183_COMPOSITE5:\r\nreg |= 0x5;\r\nbreak;\r\ncase ADV7183_COMPOSITE6:\r\nreg |= 0xB;\r\nbreak;\r\ncase ADV7183_COMPOSITE7:\r\nreg |= 0xC;\r\nbreak;\r\ncase ADV7183_COMPOSITE8:\r\nreg |= 0xD;\r\nbreak;\r\ncase ADV7183_COMPOSITE9:\r\nreg |= 0xE;\r\nbreak;\r\ncase ADV7183_COMPOSITE10:\r\nreg |= 0xF;\r\nbreak;\r\ncase ADV7183_SVIDEO0:\r\nreg |= 0x6;\r\nbreak;\r\ncase ADV7183_SVIDEO1:\r\nreg |= 0x7;\r\nbreak;\r\ncase ADV7183_SVIDEO2:\r\nreg |= 0x8;\r\nbreak;\r\ncase ADV7183_COMPONENT0:\r\nreg |= 0x9;\r\nbreak;\r\ncase ADV7183_COMPONENT1:\r\nreg |= 0xA;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nadv7183_write(sd, ADV7183_IN_CTRL, reg);\r\n}\r\nif (output != decoder->output) {\r\ndecoder->output = output;\r\nreg = adv7183_read(sd, ADV7183_OUT_CTRL) & 0xC0;\r\nswitch (output) {\r\ncase ADV7183_16BIT_OUT:\r\nreg |= 0x9;\r\nbreak;\r\ndefault:\r\nreg |= 0xC;\r\nbreak;\r\n}\r\nadv7183_write(sd, ADV7183_OUT_CTRL, reg);\r\n}\r\nreturn 0;\r\n}\r\nstatic int adv7183_s_ctrl(struct v4l2_ctrl *ctrl)\r\n{\r\nstruct v4l2_subdev *sd = to_sd(ctrl);\r\nint val = ctrl->val;\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_BRIGHTNESS:\r\nif (val < 0)\r\nval = 127 - val;\r\nadv7183_write(sd, ADV7183_BRIGHTNESS, val);\r\nbreak;\r\ncase V4L2_CID_CONTRAST:\r\nadv7183_write(sd, ADV7183_CONTRAST, val);\r\nbreak;\r\ncase V4L2_CID_SATURATION:\r\nadv7183_write(sd, ADV7183_SD_SATURATION_CB, val >> 8);\r\nadv7183_write(sd, ADV7183_SD_SATURATION_CR, (val & 0xFF));\r\nbreak;\r\ncase V4L2_CID_HUE:\r\nadv7183_write(sd, ADV7183_SD_OFFSET_CB, val >> 8);\r\nadv7183_write(sd, ADV7183_SD_OFFSET_CR, (val & 0xFF));\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int adv7183_querystd(struct v4l2_subdev *sd, v4l2_std_id *std)\r\n{\r\nstruct adv7183 *decoder = to_adv7183(sd);\r\nint reg;\r\nreg = adv7183_read(sd, ADV7183_IN_CTRL) & 0xF;\r\nadv7183_write(sd, ADV7183_IN_CTRL, reg);\r\nmdelay(10);\r\nreg = adv7183_read(sd, ADV7183_STATUS_1);\r\nswitch ((reg >> 0x4) & 0x7) {\r\ncase 0:\r\n*std = V4L2_STD_NTSC;\r\nbreak;\r\ncase 1:\r\n*std = V4L2_STD_NTSC_443;\r\nbreak;\r\ncase 2:\r\n*std = V4L2_STD_PAL_M;\r\nbreak;\r\ncase 3:\r\n*std = V4L2_STD_PAL_60;\r\nbreak;\r\ncase 4:\r\n*std = V4L2_STD_PAL;\r\nbreak;\r\ncase 5:\r\n*std = V4L2_STD_SECAM;\r\nbreak;\r\ncase 6:\r\n*std = V4L2_STD_PAL_Nc;\r\nbreak;\r\ncase 7:\r\n*std = V4L2_STD_SECAM;\r\nbreak;\r\ndefault:\r\n*std = V4L2_STD_UNKNOWN;\r\nbreak;\r\n}\r\nadv7183_s_std(sd, decoder->std);\r\nreturn 0;\r\n}\r\nstatic int adv7183_g_input_status(struct v4l2_subdev *sd, u32 *status)\r\n{\r\nint reg;\r\n*status = V4L2_IN_ST_NO_SIGNAL;\r\nreg = adv7183_read(sd, ADV7183_STATUS_1);\r\nif (reg < 0)\r\nreturn reg;\r\nif (reg & 0x1)\r\n*status = 0;\r\nreturn 0;\r\n}\r\nstatic int adv7183_enum_mbus_fmt(struct v4l2_subdev *sd, unsigned index,\r\nenum v4l2_mbus_pixelcode *code)\r\n{\r\nif (index > 0)\r\nreturn -EINVAL;\r\n*code = V4L2_MBUS_FMT_UYVY8_2X8;\r\nreturn 0;\r\n}\r\nstatic int adv7183_try_mbus_fmt(struct v4l2_subdev *sd,\r\nstruct v4l2_mbus_framefmt *fmt)\r\n{\r\nstruct adv7183 *decoder = to_adv7183(sd);\r\nfmt->code = V4L2_MBUS_FMT_UYVY8_2X8;\r\nfmt->colorspace = V4L2_COLORSPACE_SMPTE170M;\r\nif (decoder->std & V4L2_STD_525_60) {\r\nfmt->field = V4L2_FIELD_SEQ_TB;\r\nfmt->width = 720;\r\nfmt->height = 480;\r\n} else {\r\nfmt->field = V4L2_FIELD_SEQ_BT;\r\nfmt->width = 720;\r\nfmt->height = 576;\r\n}\r\nreturn 0;\r\n}\r\nstatic int adv7183_s_mbus_fmt(struct v4l2_subdev *sd,\r\nstruct v4l2_mbus_framefmt *fmt)\r\n{\r\nstruct adv7183 *decoder = to_adv7183(sd);\r\nadv7183_try_mbus_fmt(sd, fmt);\r\ndecoder->fmt = *fmt;\r\nreturn 0;\r\n}\r\nstatic int adv7183_g_mbus_fmt(struct v4l2_subdev *sd,\r\nstruct v4l2_mbus_framefmt *fmt)\r\n{\r\nstruct adv7183 *decoder = to_adv7183(sd);\r\n*fmt = decoder->fmt;\r\nreturn 0;\r\n}\r\nstatic int adv7183_s_stream(struct v4l2_subdev *sd, int enable)\r\n{\r\nstruct adv7183 *decoder = to_adv7183(sd);\r\nif (enable)\r\ngpio_direction_output(decoder->oe_pin, 0);\r\nelse\r\ngpio_direction_output(decoder->oe_pin, 1);\r\nudelay(1);\r\nreturn 0;\r\n}\r\nstatic int adv7183_g_chip_ident(struct v4l2_subdev *sd,\r\nstruct v4l2_dbg_chip_ident *chip)\r\n{\r\nint rev;\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nrev = adv7183_read(sd, ADV7183_IDENT);\r\nreturn v4l2_chip_ident_i2c_client(client, chip, V4L2_IDENT_ADV7183, rev);\r\n}\r\nstatic int adv7183_g_register(struct v4l2_subdev *sd, struct v4l2_dbg_register *reg)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nif (!v4l2_chip_match_i2c_client(client, &reg->match))\r\nreturn -EINVAL;\r\nif (!capable(CAP_SYS_ADMIN))\r\nreturn -EPERM;\r\nreg->val = adv7183_read(sd, reg->reg & 0xff);\r\nreg->size = 1;\r\nreturn 0;\r\n}\r\nstatic int adv7183_s_register(struct v4l2_subdev *sd, struct v4l2_dbg_register *reg)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nif (!v4l2_chip_match_i2c_client(client, &reg->match))\r\nreturn -EINVAL;\r\nif (!capable(CAP_SYS_ADMIN))\r\nreturn -EPERM;\r\nadv7183_write(sd, reg->reg & 0xff, reg->val & 0xff);\r\nreturn 0;\r\n}\r\nstatic int adv7183_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct adv7183 *decoder;\r\nstruct v4l2_subdev *sd;\r\nstruct v4l2_ctrl_handler *hdl;\r\nint ret;\r\nstruct v4l2_mbus_framefmt fmt;\r\nconst unsigned *pin_array;\r\nif (!i2c_check_functionality(client->adapter, I2C_FUNC_SMBUS_BYTE_DATA))\r\nreturn -EIO;\r\nv4l_info(client, "chip found @ 0x%02x (%s)\n",\r\nclient->addr << 1, client->adapter->name);\r\npin_array = client->dev.platform_data;\r\nif (pin_array == NULL)\r\nreturn -EINVAL;\r\ndecoder = kzalloc(sizeof(struct adv7183), GFP_KERNEL);\r\nif (decoder == NULL)\r\nreturn -ENOMEM;\r\ndecoder->reset_pin = pin_array[0];\r\ndecoder->oe_pin = pin_array[1];\r\nif (gpio_request(decoder->reset_pin, "ADV7183 Reset")) {\r\nv4l_err(client, "failed to request GPIO %d\n", decoder->reset_pin);\r\nret = -EBUSY;\r\ngoto err_free_decoder;\r\n}\r\nif (gpio_request(decoder->oe_pin, "ADV7183 Output Enable")) {\r\nv4l_err(client, "failed to request GPIO %d\n", decoder->oe_pin);\r\nret = -EBUSY;\r\ngoto err_free_reset;\r\n}\r\nsd = &decoder->sd;\r\nv4l2_i2c_subdev_init(sd, client, &adv7183_ops);\r\nhdl = &decoder->hdl;\r\nv4l2_ctrl_handler_init(hdl, 4);\r\nv4l2_ctrl_new_std(hdl, &adv7183_ctrl_ops,\r\nV4L2_CID_BRIGHTNESS, -128, 127, 1, 0);\r\nv4l2_ctrl_new_std(hdl, &adv7183_ctrl_ops,\r\nV4L2_CID_CONTRAST, 0, 0xFF, 1, 0x80);\r\nv4l2_ctrl_new_std(hdl, &adv7183_ctrl_ops,\r\nV4L2_CID_SATURATION, 0, 0xFFFF, 1, 0x8080);\r\nv4l2_ctrl_new_std(hdl, &adv7183_ctrl_ops,\r\nV4L2_CID_HUE, 0, 0xFFFF, 1, 0x8080);\r\nsd->ctrl_handler = hdl;\r\nif (hdl->error) {\r\nret = hdl->error;\r\nv4l2_ctrl_handler_free(hdl);\r\ngoto err_free_oe;\r\n}\r\ndecoder->std = V4L2_STD_PAL;\r\ndecoder->input = ADV7183_COMPOSITE4;\r\ndecoder->output = ADV7183_8BIT_OUT;\r\ngpio_direction_output(decoder->oe_pin, 1);\r\ngpio_direction_output(decoder->reset_pin, 0);\r\nmdelay(10);\r\ngpio_direction_output(decoder->reset_pin, 1);\r\nmdelay(5);\r\nadv7183_writeregs(sd, adv7183_init_regs, ARRAY_SIZE(adv7183_init_regs));\r\nadv7183_s_std(sd, decoder->std);\r\nfmt.width = 720;\r\nfmt.height = 576;\r\nadv7183_s_mbus_fmt(sd, &fmt);\r\nret = v4l2_ctrl_handler_setup(hdl);\r\nif (ret) {\r\nv4l2_ctrl_handler_free(hdl);\r\ngoto err_free_oe;\r\n}\r\nreturn 0;\r\nerr_free_oe:\r\ngpio_free(decoder->oe_pin);\r\nerr_free_reset:\r\ngpio_free(decoder->reset_pin);\r\nerr_free_decoder:\r\nkfree(decoder);\r\nreturn ret;\r\n}\r\nstatic int adv7183_remove(struct i2c_client *client)\r\n{\r\nstruct v4l2_subdev *sd = i2c_get_clientdata(client);\r\nstruct adv7183 *decoder = to_adv7183(sd);\r\nv4l2_device_unregister_subdev(sd);\r\nv4l2_ctrl_handler_free(sd->ctrl_handler);\r\ngpio_free(decoder->oe_pin);\r\ngpio_free(decoder->reset_pin);\r\nkfree(decoder);\r\nreturn 0;\r\n}
