unsigned int pxa25x_get_clk_frequency_khz(int info)\r\n{\r\nunsigned long cccr, turbo;\r\nunsigned int l, L, m, M, n2, N;\r\ncccr = CCCR;\r\nasm( "mrc\tp14, 0, %0, c6, c0, 0" : "=r" (turbo) );\r\nl = L_clk_mult[(cccr >> 0) & 0x1f];\r\nm = M_clk_mult[(cccr >> 5) & 0x03];\r\nn2 = N2_clk_mult[(cccr >> 7) & 0x07];\r\nL = l * BASE_CLK;\r\nM = m * L;\r\nN = n2 * M / 2;\r\nif(info)\r\n{\r\nL += 5000;\r\nprintk( KERN_INFO "Memory clock: %d.%02dMHz (*%d)\n",\r\nL / 1000000, (L % 1000000) / 10000, l );\r\nM += 5000;\r\nprintk( KERN_INFO "Run Mode clock: %d.%02dMHz (*%d)\n",\r\nM / 1000000, (M % 1000000) / 10000, m );\r\nN += 5000;\r\nprintk( KERN_INFO "Turbo Mode clock: %d.%02dMHz (*%d.%d, %sactive)\n",\r\nN / 1000000, (N % 1000000) / 10000, n2 / 2, (n2 % 2) * 5,\r\n(turbo & 1) ? "" : "in" );\r\n}\r\nreturn (turbo & 1) ? (N/1000) : (M/1000);\r\n}\r\nstatic unsigned long clk_pxa25x_mem_getrate(struct clk *clk)\r\n{\r\nreturn L_clk_mult[(CCCR >> 0) & 0x1f] * BASE_CLK;\r\n}\r\nstatic void clk_gpio12_enable(struct clk *clk)\r\n{\r\npxa2xx_mfp_config(gpio12_config_32k, 1);\r\n}\r\nstatic void clk_gpio12_disable(struct clk *clk)\r\n{\r\npxa2xx_mfp_config(gpio12_config_gpio, 1);\r\n}\r\nstatic void clk_gpio11_enable(struct clk *clk)\r\n{\r\npxa2xx_mfp_config(gpio11_config_3m6, 1);\r\n}\r\nstatic void clk_gpio11_disable(struct clk *clk)\r\n{\r\npxa2xx_mfp_config(gpio11_config_gpio, 1);\r\n}\r\nstatic void pxa25x_cpu_pm_save(unsigned long *sleep_save)\r\n{\r\nSAVE(PSTR);\r\n}\r\nstatic void pxa25x_cpu_pm_restore(unsigned long *sleep_save)\r\n{\r\nRESTORE(PSTR);\r\n}\r\nstatic void pxa25x_cpu_pm_enter(suspend_state_t state)\r\n{\r\nRCSR = RCSR_HWR | RCSR_WDR | RCSR_SMR | RCSR_GPR;\r\nswitch (state) {\r\ncase PM_SUSPEND_MEM:\r\ncpu_suspend(PWRMODE_SLEEP, pxa25x_finish_suspend);\r\nbreak;\r\n}\r\n}\r\nstatic int pxa25x_cpu_pm_prepare(void)\r\n{\r\nPSPR = virt_to_phys(cpu_resume);\r\nreturn 0;\r\n}\r\nstatic void pxa25x_cpu_pm_finish(void)\r\n{\r\nPSPR = 0;\r\n}\r\nstatic void __init pxa25x_init_pm(void)\r\n{\r\npxa_cpu_pm_fns = &pxa25x_cpu_pm_fns;\r\n}\r\nstatic inline void pxa25x_init_pm(void) {}\r\nstatic int pxa25x_set_wake(struct irq_data *d, unsigned int on)\r\n{\r\nint gpio = pxa_irq_to_gpio(d->irq);\r\nuint32_t mask = 0;\r\nif (gpio >= 0 && gpio < 85)\r\nreturn gpio_set_wake(gpio, on);\r\nif (d->irq == IRQ_RTCAlrm) {\r\nmask = PWER_RTC;\r\ngoto set_pwer;\r\n}\r\nreturn -EINVAL;\r\nset_pwer:\r\nif (on)\r\nPWER |= mask;\r\nelse\r\nPWER &=~mask;\r\nreturn 0;\r\n}\r\nvoid __init pxa25x_init_irq(void)\r\n{\r\npxa_init_irq(32, pxa25x_set_wake);\r\n}\r\nvoid __init pxa26x_init_irq(void)\r\n{\r\npxa_init_irq(32, pxa25x_set_wake);\r\n}\r\nvoid __init pxa25x_map_io(void)\r\n{\r\npxa_map_io();\r\niotable_init(ARRAY_AND_SIZE(pxa25x_io_desc));\r\npxa25x_get_clk_frequency_khz(1);\r\n}\r\nstatic int __init pxa25x_init(void)\r\n{\r\nint ret = 0;\r\nif (cpu_is_pxa25x()) {\r\nreset_status = RCSR;\r\nclkdev_add_table(pxa25x_clkregs, ARRAY_SIZE(pxa25x_clkregs));\r\nif ((ret = pxa_init_dma(IRQ_DMA, 16)))\r\nreturn ret;\r\npxa25x_init_pm();\r\nregister_syscore_ops(&pxa_irq_syscore_ops);\r\nregister_syscore_ops(&pxa2xx_mfp_syscore_ops);\r\nregister_syscore_ops(&pxa2xx_clock_syscore_ops);\r\npxa_register_device(&pxa_device_gpio, &pxa25x_gpio_info);\r\nret = platform_add_devices(pxa25x_devices,\r\nARRAY_SIZE(pxa25x_devices));\r\nif (ret)\r\nreturn ret;\r\n}\r\nif (cpu_is_pxa255())\r\nclkdev_add(&pxa25x_hwuart_clkreg);\r\nreturn ret;\r\n}
