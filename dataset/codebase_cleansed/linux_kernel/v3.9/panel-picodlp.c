static inline struct picodlp_panel_data\r\n*get_panel_data(const struct omap_dss_device *dssdev)\r\n{\r\nreturn (struct picodlp_panel_data *) dssdev->data;\r\n}\r\nstatic u32 picodlp_i2c_read(struct i2c_client *client, u8 reg)\r\n{\r\nu8 read_cmd[] = {READ_REG_SELECT, reg}, data[4];\r\nstruct picodlp_i2c_data *picodlp_i2c_data = i2c_get_clientdata(client);\r\nstruct i2c_msg msg[2];\r\nmutex_lock(&picodlp_i2c_data->xfer_lock);\r\nmsg[0].addr = client->addr;\r\nmsg[0].flags = 0;\r\nmsg[0].len = 2;\r\nmsg[0].buf = read_cmd;\r\nmsg[1].addr = client->addr;\r\nmsg[1].flags = I2C_M_RD;\r\nmsg[1].len = 4;\r\nmsg[1].buf = data;\r\ni2c_transfer(client->adapter, msg, 2);\r\nmutex_unlock(&picodlp_i2c_data->xfer_lock);\r\nreturn (data[3] | (data[2] << 8) | (data[1] << 16) | (data[0] << 24));\r\n}\r\nstatic int picodlp_i2c_write_block(struct i2c_client *client,\r\nu8 *data, int len)\r\n{\r\nstruct i2c_msg msg;\r\nint i, r, msg_count = 1;\r\nstruct picodlp_i2c_data *picodlp_i2c_data = i2c_get_clientdata(client);\r\nif (len < 1 || len > 32) {\r\ndev_err(&client->dev,\r\n"too long syn_write_block len %d\n", len);\r\nreturn -EIO;\r\n}\r\nmutex_lock(&picodlp_i2c_data->xfer_lock);\r\nmsg.addr = client->addr;\r\nmsg.flags = 0;\r\nmsg.len = len;\r\nmsg.buf = data;\r\nr = i2c_transfer(client->adapter, &msg, msg_count);\r\nmutex_unlock(&picodlp_i2c_data->xfer_lock);\r\nif (r != msg_count)\r\ngoto err;\r\nfor (i = 0; i < len; i++)\r\ndev_dbg(&client->dev,\r\n"addr %x bw 0x%02x[%d]: 0x%02x\n",\r\nclient->addr, data[0] + i, i, data[i]);\r\nreturn 0;\r\nerr:\r\ndev_err(&client->dev, "picodlp_i2c_write error\n");\r\nreturn r;\r\n}\r\nstatic int picodlp_i2c_write(struct i2c_client *client, u8 reg, u32 value)\r\n{\r\nu8 data[5];\r\nint i;\r\ndata[0] = reg;\r\nfor (i = 1; i < 5; i++)\r\ndata[i] = (value >> (32 - (i) * 8)) & 0xFF;\r\nreturn picodlp_i2c_write_block(client, data, 5);\r\n}\r\nstatic int picodlp_i2c_write_array(struct i2c_client *client,\r\nconst struct picodlp_i2c_command commands[],\r\nint count)\r\n{\r\nint i, r = 0;\r\nfor (i = 0; i < count; i++) {\r\nr = picodlp_i2c_write(client, commands[i].reg,\r\ncommands[i].value);\r\nif (r)\r\nreturn r;\r\n}\r\nreturn r;\r\n}\r\nstatic int picodlp_wait_for_dma_done(struct i2c_client *client)\r\n{\r\nu8 trial = 100;\r\ndo {\r\nmsleep(1);\r\nif (!trial--)\r\nreturn -ETIMEDOUT;\r\n} while (picodlp_i2c_read(client, MAIN_STATUS) & DMA_STATUS);\r\nreturn 0;\r\n}\r\nstatic int picodlp_i2c_init(struct i2c_client *client)\r\n{\r\nint r;\r\nstatic const struct picodlp_i2c_command init_cmd_set1[] = {\r\n{SOFT_RESET, 1},\r\n{DMD_PARK_TRIGGER, 1},\r\n{MISC_REG, 5},\r\n{SEQ_CONTROL, 0},\r\n{SEQ_VECTOR, 0x100},\r\n{DMD_BLOCK_COUNT, 7},\r\n{DMD_VCC_CONTROL, 0x109},\r\n{DMD_PARK_PULSE_COUNT, 0xA},\r\n{DMD_PARK_PULSE_WIDTH, 0xB},\r\n{DMD_PARK_DELAY, 0x2ED},\r\n{DMD_SHADOW_ENABLE, 0},\r\n{FLASH_OPCODE, 0xB},\r\n{FLASH_DUMMY_BYTES, 1},\r\n{FLASH_ADDR_BYTES, 3},\r\n{PBC_CONTROL, 0},\r\n{FLASH_START_ADDR, CMT_LUT_0_START_ADDR},\r\n{FLASH_READ_BYTES, CMT_LUT_0_SIZE},\r\n{CMT_SPLASH_LUT_START_ADDR, 0},\r\n{CMT_SPLASH_LUT_DEST_SELECT, CMT_LUT_ALL},\r\n{PBC_CONTROL, 1},\r\n};\r\nstatic const struct picodlp_i2c_command init_cmd_set2[] = {\r\n{PBC_CONTROL, 0},\r\n{CMT_SPLASH_LUT_DEST_SELECT, 0},\r\n{PBC_CONTROL, 0},\r\n{FLASH_START_ADDR, SEQUENCE_0_START_ADDR},\r\n{FLASH_READ_BYTES, SEQUENCE_0_SIZE},\r\n{SEQ_RESET_LUT_START_ADDR, 0},\r\n{SEQ_RESET_LUT_DEST_SELECT, SEQ_SEQ_LUT},\r\n{PBC_CONTROL, 1},\r\n};\r\nstatic const struct picodlp_i2c_command init_cmd_set3[] = {\r\n{PBC_CONTROL, 0},\r\n{SEQ_RESET_LUT_DEST_SELECT, 0},\r\n{PBC_CONTROL, 0},\r\n{FLASH_START_ADDR, DRC_TABLE_0_START_ADDR},\r\n{FLASH_READ_BYTES, DRC_TABLE_0_SIZE},\r\n{SEQ_RESET_LUT_START_ADDR, 0},\r\n{SEQ_RESET_LUT_DEST_SELECT, SEQ_DRC_LUT_ALL},\r\n{PBC_CONTROL, 1},\r\n};\r\nstatic const struct picodlp_i2c_command init_cmd_set4[] = {\r\n{PBC_CONTROL, 0},\r\n{SEQ_RESET_LUT_DEST_SELECT, 0},\r\n{SDC_ENABLE, 1},\r\n{AGC_CTRL, 7},\r\n{CCA_C1A, 0x100},\r\n{CCA_C1B, 0x0},\r\n{CCA_C1C, 0x0},\r\n{CCA_C2A, 0x0},\r\n{CCA_C2B, 0x100},\r\n{CCA_C2C, 0x0},\r\n{CCA_C3A, 0x0},\r\n{CCA_C3B, 0x0},\r\n{CCA_C3C, 0x100},\r\n{CCA_C7A, 0x100},\r\n{CCA_C7B, 0x100},\r\n{CCA_C7C, 0x100},\r\n{CCA_ENABLE, 1},\r\n{CPU_IF_MODE, 1},\r\n{SHORT_FLIP, 1},\r\n{CURTAIN_CONTROL, 0},\r\n{DMD_PARK_TRIGGER, 0},\r\n{R_DRIVE_CURRENT, 0x298},\r\n{G_DRIVE_CURRENT, 0x298},\r\n{B_DRIVE_CURRENT, 0x298},\r\n{RGB_DRIVER_ENABLE, 7},\r\n{SEQ_CONTROL, 0},\r\n{ACTGEN_CONTROL, 0x10},\r\n{SEQUENCE_MODE, SEQ_LOCK},\r\n{DATA_FORMAT, RGB888},\r\n{INPUT_RESOLUTION, WVGA_864_LANDSCAPE},\r\n{INPUT_SOURCE, PARALLEL_RGB},\r\n{CPU_IF_SYNC_METHOD, 1},\r\n{SEQ_CONTROL, 1}\r\n};\r\nr = picodlp_i2c_write_array(client, init_cmd_set1,\r\nARRAY_SIZE(init_cmd_set1));\r\nif (r)\r\nreturn r;\r\nr = picodlp_wait_for_dma_done(client);\r\nif (r)\r\nreturn r;\r\nr = picodlp_i2c_write_array(client, init_cmd_set2,\r\nARRAY_SIZE(init_cmd_set2));\r\nif (r)\r\nreturn r;\r\nr = picodlp_wait_for_dma_done(client);\r\nif (r)\r\nreturn r;\r\nr = picodlp_i2c_write_array(client, init_cmd_set3,\r\nARRAY_SIZE(init_cmd_set3));\r\nif (r)\r\nreturn r;\r\nr = picodlp_wait_for_dma_done(client);\r\nif (r)\r\nreturn r;\r\nr = picodlp_i2c_write_array(client, init_cmd_set4,\r\nARRAY_SIZE(init_cmd_set4));\r\nif (r)\r\nreturn r;\r\nreturn 0;\r\n}\r\nstatic int picodlp_i2c_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct picodlp_i2c_data *picodlp_i2c_data;\r\npicodlp_i2c_data = kzalloc(sizeof(struct picodlp_i2c_data), GFP_KERNEL);\r\nif (!picodlp_i2c_data)\r\nreturn -ENOMEM;\r\nmutex_init(&picodlp_i2c_data->xfer_lock);\r\ni2c_set_clientdata(client, picodlp_i2c_data);\r\nreturn 0;\r\n}\r\nstatic int picodlp_i2c_remove(struct i2c_client *client)\r\n{\r\nstruct picodlp_i2c_data *picodlp_i2c_data =\r\ni2c_get_clientdata(client);\r\nkfree(picodlp_i2c_data);\r\nreturn 0;\r\n}\r\nstatic int picodlp_panel_power_on(struct omap_dss_device *dssdev)\r\n{\r\nint r, trial = 100;\r\nstruct picodlp_data *picod = dev_get_drvdata(&dssdev->dev);\r\nstruct picodlp_panel_data *picodlp_pdata = get_panel_data(dssdev);\r\nif (dssdev->platform_enable) {\r\nr = dssdev->platform_enable(dssdev);\r\nif (r)\r\nreturn r;\r\n}\r\ngpio_set_value(picodlp_pdata->pwrgood_gpio, 0);\r\nmsleep(1);\r\ngpio_set_value(picodlp_pdata->pwrgood_gpio, 1);\r\nwhile (!gpio_get_value(picodlp_pdata->emu_done_gpio)) {\r\nif (!trial--) {\r\ndev_err(&dssdev->dev, "emu_done signal not"\r\n" going high\n");\r\nreturn -ETIMEDOUT;\r\n}\r\nmsleep(5);\r\n}\r\nmsleep(1000);\r\nomapdss_dpi_set_timings(dssdev, &dssdev->panel.timings);\r\nomapdss_dpi_set_data_lines(dssdev, dssdev->phy.dpi.data_lines);\r\nr = omapdss_dpi_display_enable(dssdev);\r\nif (r) {\r\ndev_err(&dssdev->dev, "failed to enable DPI\n");\r\ngoto err1;\r\n}\r\nr = picodlp_i2c_init(picod->picodlp_i2c_client);\r\nif (r)\r\ngoto err;\r\ndssdev->state = OMAP_DSS_DISPLAY_ACTIVE;\r\nreturn r;\r\nerr:\r\nomapdss_dpi_display_disable(dssdev);\r\nerr1:\r\nif (dssdev->platform_disable)\r\ndssdev->platform_disable(dssdev);\r\nreturn r;\r\n}\r\nstatic void picodlp_panel_power_off(struct omap_dss_device *dssdev)\r\n{\r\nstruct picodlp_panel_data *picodlp_pdata = get_panel_data(dssdev);\r\nomapdss_dpi_display_disable(dssdev);\r\ngpio_set_value(picodlp_pdata->emu_done_gpio, 0);\r\ngpio_set_value(picodlp_pdata->pwrgood_gpio, 0);\r\nif (dssdev->platform_disable)\r\ndssdev->platform_disable(dssdev);\r\n}\r\nstatic int picodlp_panel_probe(struct omap_dss_device *dssdev)\r\n{\r\nstruct picodlp_data *picod;\r\nstruct picodlp_panel_data *picodlp_pdata = get_panel_data(dssdev);\r\nstruct i2c_adapter *adapter;\r\nstruct i2c_client *picodlp_i2c_client;\r\nint r = 0, picodlp_adapter_id;\r\ndssdev->panel.timings = pico_ls_timings;\r\npicod = kzalloc(sizeof(struct picodlp_data), GFP_KERNEL);\r\nif (!picod)\r\nreturn -ENOMEM;\r\nmutex_init(&picod->lock);\r\npicodlp_adapter_id = picodlp_pdata->picodlp_adapter_id;\r\nadapter = i2c_get_adapter(picodlp_adapter_id);\r\nif (!adapter) {\r\ndev_err(&dssdev->dev, "can't get i2c adapter\n");\r\nr = -ENODEV;\r\ngoto err;\r\n}\r\npicodlp_i2c_client = i2c_new_device(adapter, &picodlp_i2c_board_info);\r\nif (!picodlp_i2c_client) {\r\ndev_err(&dssdev->dev, "can't add i2c device::"\r\n" picodlp_i2c_client is NULL\n");\r\nr = -ENODEV;\r\ngoto err;\r\n}\r\npicod->picodlp_i2c_client = picodlp_i2c_client;\r\ndev_set_drvdata(&dssdev->dev, picod);\r\nreturn r;\r\nerr:\r\nkfree(picod);\r\nreturn r;\r\n}\r\nstatic void picodlp_panel_remove(struct omap_dss_device *dssdev)\r\n{\r\nstruct picodlp_data *picod = dev_get_drvdata(&dssdev->dev);\r\ni2c_unregister_device(picod->picodlp_i2c_client);\r\ndev_set_drvdata(&dssdev->dev, NULL);\r\ndev_dbg(&dssdev->dev, "removing picodlp panel\n");\r\nkfree(picod);\r\n}\r\nstatic int picodlp_panel_enable(struct omap_dss_device *dssdev)\r\n{\r\nstruct picodlp_data *picod = dev_get_drvdata(&dssdev->dev);\r\nint r;\r\ndev_dbg(&dssdev->dev, "enabling picodlp panel\n");\r\nmutex_lock(&picod->lock);\r\nif (dssdev->state != OMAP_DSS_DISPLAY_DISABLED) {\r\nmutex_unlock(&picod->lock);\r\nreturn -EINVAL;\r\n}\r\nr = picodlp_panel_power_on(dssdev);\r\nmutex_unlock(&picod->lock);\r\nreturn r;\r\n}\r\nstatic void picodlp_panel_disable(struct omap_dss_device *dssdev)\r\n{\r\nstruct picodlp_data *picod = dev_get_drvdata(&dssdev->dev);\r\nmutex_lock(&picod->lock);\r\nif (dssdev->state == OMAP_DSS_DISPLAY_ACTIVE)\r\npicodlp_panel_power_off(dssdev);\r\ndssdev->state = OMAP_DSS_DISPLAY_DISABLED;\r\nmutex_unlock(&picod->lock);\r\ndev_dbg(&dssdev->dev, "disabling picodlp panel\n");\r\n}\r\nstatic void picodlp_get_resolution(struct omap_dss_device *dssdev,\r\nu16 *xres, u16 *yres)\r\n{\r\n*xres = dssdev->panel.timings.x_res;\r\n*yres = dssdev->panel.timings.y_res;\r\n}\r\nstatic int __init picodlp_init(void)\r\n{\r\nint r = 0;\r\nr = i2c_add_driver(&picodlp_i2c_driver);\r\nif (r) {\r\nprintk(KERN_WARNING "picodlp_i2c_driver" \\r\n" registration failed\n");\r\nreturn r;\r\n}\r\nr = omap_dss_register_driver(&picodlp_driver);\r\nif (r)\r\ni2c_del_driver(&picodlp_i2c_driver);\r\nreturn r;\r\n}\r\nstatic void __exit picodlp_exit(void)\r\n{\r\ni2c_del_driver(&picodlp_i2c_driver);\r\nomap_dss_unregister_driver(&picodlp_driver);\r\n}
