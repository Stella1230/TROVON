static inline struct IsdnCardState *\r\nhisax_findcard(int driverid)\r\n{\r\nint i;\r\nfor (i = 0; i < nrcards; i++)\r\nif (cards[i].cs)\r\nif (cards[i].cs->myid == driverid)\r\nreturn (cards[i].cs);\r\nreturn (struct IsdnCardState *) 0;\r\n}\r\nstatic inline void\r\nHL_LL(struct Channel *chanp, int command)\r\n{\r\nisdn_ctrl ic;\r\nic.driver = chanp->cs->myid;\r\nic.command = command;\r\nic.arg = chanp->chan;\r\nchanp->cs->iif.statcallb(&ic);\r\n}\r\nstatic inline void\r\nlli_deliver_cause(struct Channel *chanp)\r\n{\r\nisdn_ctrl ic;\r\nif (!chanp->proc)\r\nreturn;\r\nif (chanp->proc->para.cause == NO_CAUSE)\r\nreturn;\r\nic.driver = chanp->cs->myid;\r\nic.command = ISDN_STAT_CAUSE;\r\nic.arg = chanp->chan;\r\nif (chanp->cs->protocol == ISDN_PTYPE_EURO)\r\nsprintf(ic.parm.num, "E%02X%02X", chanp->proc->para.loc & 0x7f,\r\nchanp->proc->para.cause & 0x7f);\r\nelse\r\nsprintf(ic.parm.num, "%02X%02X", chanp->proc->para.loc & 0x7f,\r\nchanp->proc->para.cause & 0x7f);\r\nchanp->cs->iif.statcallb(&ic);\r\n}\r\nstatic inline void\r\nlli_close(struct FsmInst *fi)\r\n{\r\nstruct Channel *chanp = fi->userdata;\r\nFsmChangeState(fi, ST_NULL);\r\nchanp->Flags = 0;\r\nchanp->cs->cardmsg(chanp->cs, MDL_INFO_REL, (void *) (long)chanp->chan);\r\n}\r\nstatic void\r\nlli_leased_in(struct FsmInst *fi, int event, void *arg)\r\n{\r\nstruct Channel *chanp = fi->userdata;\r\nisdn_ctrl ic;\r\nint ret;\r\nif (!chanp->leased)\r\nreturn;\r\nchanp->cs->cardmsg(chanp->cs, MDL_INFO_SETUP, (void *) (long)chanp->chan);\r\nFsmChangeState(fi, ST_IN_WAIT_LL);\r\nif (chanp->debug & 1)\r\nlink_debug(chanp, 0, "STAT_ICALL_LEASED");\r\nic.driver = chanp->cs->myid;\r\nic.command = ((chanp->chan < 2) ? ISDN_STAT_ICALL : ISDN_STAT_ICALLW);\r\nic.arg = chanp->chan;\r\nic.parm.setup.si1 = 7;\r\nic.parm.setup.si2 = 0;\r\nic.parm.setup.plan = 0;\r\nic.parm.setup.screen = 0;\r\nsprintf(ic.parm.setup.eazmsn, "%d", chanp->chan + 1);\r\nsprintf(ic.parm.setup.phone, "LEASED%d", chanp->cs->myid);\r\nret = chanp->cs->iif.statcallb(&ic);\r\nif (chanp->debug & 1)\r\nlink_debug(chanp, 1, "statcallb ret=%d", ret);\r\nif (!ret) {\r\nchanp->cs->cardmsg(chanp->cs, MDL_INFO_REL, (void *) (long)chanp->chan);\r\nFsmChangeState(fi, ST_NULL);\r\n}\r\n}\r\nstatic void\r\nlli_init_bchan_out(struct FsmInst *fi, int event, void *arg)\r\n{\r\nstruct Channel *chanp = fi->userdata;\r\nFsmChangeState(fi, ST_WAIT_BCONN);\r\nif (chanp->debug & 1)\r\nlink_debug(chanp, 0, "STAT_DCONN");\r\nHL_LL(chanp, ISDN_STAT_DCONN);\r\ninit_b_st(chanp, 0);\r\nchanp->b_st->lli.l4l3(chanp->b_st, DL_ESTABLISH | REQUEST, NULL);\r\n}\r\nstatic void\r\nlli_prep_dialout(struct FsmInst *fi, int event, void *arg)\r\n{\r\nstruct Channel *chanp = fi->userdata;\r\nFsmDelTimer(&chanp->drel_timer, 60);\r\nFsmDelTimer(&chanp->dial_timer, 73);\r\nchanp->l2_active_protocol = chanp->l2_protocol;\r\nchanp->incoming = 0;\r\nchanp->cs->cardmsg(chanp->cs, MDL_INFO_SETUP, (void *) (long)chanp->chan);\r\nif (chanp->leased) {\r\nlli_init_bchan_out(fi, event, arg);\r\n} else {\r\nFsmChangeState(fi, ST_OUT_DIAL);\r\nchanp->d_st->lli.l4l3(chanp->d_st, CC_SETUP | REQUEST, chanp);\r\n}\r\n}\r\nstatic void\r\nlli_resume(struct FsmInst *fi, int event, void *arg)\r\n{\r\nstruct Channel *chanp = fi->userdata;\r\nFsmDelTimer(&chanp->drel_timer, 60);\r\nFsmDelTimer(&chanp->dial_timer, 73);\r\nchanp->l2_active_protocol = chanp->l2_protocol;\r\nchanp->incoming = 0;\r\nchanp->cs->cardmsg(chanp->cs, MDL_INFO_SETUP, (void *) (long)chanp->chan);\r\nif (chanp->leased) {\r\nlli_init_bchan_out(fi, event, arg);\r\n} else {\r\nFsmChangeState(fi, ST_OUT_DIAL);\r\nchanp->d_st->lli.l4l3(chanp->d_st, CC_RESUME | REQUEST, chanp);\r\n}\r\n}\r\nstatic void\r\nlli_go_active(struct FsmInst *fi, int event, void *arg)\r\n{\r\nstruct Channel *chanp = fi->userdata;\r\nisdn_ctrl ic;\r\nFsmChangeState(fi, ST_ACTIVE);\r\nchanp->data_open = !0;\r\nif (chanp->bcs->conmsg)\r\nstrcpy(ic.parm.num, chanp->bcs->conmsg);\r\nelse\r\nic.parm.num[0] = 0;\r\nif (chanp->debug & 1)\r\nlink_debug(chanp, 0, "STAT_BCONN %s", ic.parm.num);\r\nic.driver = chanp->cs->myid;\r\nic.command = ISDN_STAT_BCONN;\r\nic.arg = chanp->chan;\r\nchanp->cs->iif.statcallb(&ic);\r\nchanp->cs->cardmsg(chanp->cs, MDL_INFO_CONN, (void *) (long)chanp->chan);\r\n}\r\nstatic void\r\nlli_deliver_call(struct FsmInst *fi, int event, void *arg)\r\n{\r\nstruct Channel *chanp = fi->userdata;\r\nisdn_ctrl ic;\r\nint ret;\r\nchanp->cs->cardmsg(chanp->cs, MDL_INFO_SETUP, (void *) (long)chanp->chan);\r\nif (1) {\r\nFsmChangeState(fi, ST_IN_WAIT_LL);\r\nif (chanp->debug & 1)\r\nlink_debug(chanp, 0, (chanp->chan < 2) ? "STAT_ICALL" : "STAT_ICALLW");\r\nic.driver = chanp->cs->myid;\r\nic.command = ((chanp->chan < 2) ? ISDN_STAT_ICALL : ISDN_STAT_ICALLW);\r\nic.arg = chanp->chan;\r\nmemcpy(&ic.parm.setup, &chanp->proc->para.setup, sizeof(setup_parm));\r\nret = chanp->cs->iif.statcallb(&ic);\r\nif (chanp->debug & 1)\r\nlink_debug(chanp, 1, "statcallb ret=%d", ret);\r\nswitch (ret) {\r\ncase 1:\r\nFsmDelTimer(&chanp->drel_timer, 61);\r\nFsmChangeState(fi, ST_IN_ALERT_SENT);\r\nchanp->d_st->lli.l4l3(chanp->d_st, CC_ALERTING | REQUEST, chanp->proc);\r\nbreak;\r\ncase 5:\r\ncase 4:\r\nFsmDelTimer(&chanp->drel_timer, 61);\r\nFsmChangeState(fi, ST_IN_PROCEED_SEND);\r\nchanp->d_st->lli.l4l3(chanp->d_st, CC_PROCEED_SEND | REQUEST, chanp->proc);\r\nif (ret == 5) {\r\nmemcpy(&chanp->setup, &ic.parm.setup, sizeof(setup_parm));\r\nchanp->d_st->lli.l4l3(chanp->d_st, CC_REDIR | REQUEST, chanp->proc);\r\n}\r\nbreak;\r\ncase 2:\r\nbreak;\r\ncase 3:\r\nFsmDelTimer(&chanp->drel_timer, 61);\r\nchanp->d_st->lli.l4l3(chanp->d_st, CC_MORE_INFO | REQUEST, chanp->proc);\r\nbreak;\r\ncase 0:\r\ndefault:\r\nchanp->d_st->lli.l4l3(chanp->d_st, CC_IGNORE | REQUEST, chanp->proc);\r\nchanp->cs->cardmsg(chanp->cs, MDL_INFO_REL, (void *) (long)chanp->chan);\r\nFsmChangeState(fi, ST_NULL);\r\nbreak;\r\n}\r\n} else {\r\nchanp->d_st->lli.l4l3(chanp->d_st, CC_IGNORE | REQUEST, chanp->proc);\r\nchanp->cs->cardmsg(chanp->cs, MDL_INFO_REL, (void *) (long)chanp->chan);\r\n}\r\n}\r\nstatic void\r\nlli_send_dconnect(struct FsmInst *fi, int event, void *arg)\r\n{\r\nstruct Channel *chanp = fi->userdata;\r\nFsmChangeState(fi, ST_IN_WAIT_CONN_ACK);\r\nchanp->d_st->lli.l4l3(chanp->d_st, CC_SETUP | RESPONSE, chanp->proc);\r\n}\r\nstatic void\r\nlli_send_alert(struct FsmInst *fi, int event, void *arg)\r\n{\r\nstruct Channel *chanp = fi->userdata;\r\nFsmChangeState(fi, ST_IN_ALERT_SENT);\r\nchanp->d_st->lli.l4l3(chanp->d_st, CC_ALERTING | REQUEST, chanp->proc);\r\n}\r\nstatic void\r\nlli_send_redir(struct FsmInst *fi, int event, void *arg)\r\n{\r\nstruct Channel *chanp = fi->userdata;\r\nchanp->d_st->lli.l4l3(chanp->d_st, CC_REDIR | REQUEST, chanp->proc);\r\n}\r\nstatic void\r\nlli_init_bchan_in(struct FsmInst *fi, int event, void *arg)\r\n{\r\nstruct Channel *chanp = fi->userdata;\r\nFsmChangeState(fi, ST_WAIT_BCONN);\r\nif (chanp->debug & 1)\r\nlink_debug(chanp, 0, "STAT_DCONN");\r\nHL_LL(chanp, ISDN_STAT_DCONN);\r\nchanp->l2_active_protocol = chanp->l2_protocol;\r\nchanp->incoming = !0;\r\ninit_b_st(chanp, !0);\r\nchanp->b_st->lli.l4l3(chanp->b_st, DL_ESTABLISH | REQUEST, NULL);\r\n}\r\nstatic void\r\nlli_setup_rsp(struct FsmInst *fi, int event, void *arg)\r\n{\r\nstruct Channel *chanp = fi->userdata;\r\nif (chanp->leased) {\r\nlli_init_bchan_in(fi, event, arg);\r\n} else {\r\nFsmChangeState(fi, ST_IN_WAIT_CONN_ACK);\r\n#ifdef WANT_ALERT\r\nchanp->d_st->lli.l4l3(chanp->d_st, CC_ALERTING | REQUEST, chanp->proc);\r\n#endif\r\nchanp->d_st->lli.l4l3(chanp->d_st, CC_SETUP | RESPONSE, chanp->proc);\r\n}\r\n}\r\nstatic void\r\nlli_suspend(struct FsmInst *fi, int event, void *arg)\r\n{\r\nstruct Channel *chanp = fi->userdata;\r\nchanp->d_st->lli.l4l3(chanp->d_st, CC_SUSPEND | REQUEST, chanp->proc);\r\n}\r\nstatic void\r\nlli_leased_hup(struct FsmInst *fi, struct Channel *chanp)\r\n{\r\nisdn_ctrl ic;\r\nic.driver = chanp->cs->myid;\r\nic.command = ISDN_STAT_CAUSE;\r\nic.arg = chanp->chan;\r\nsprintf(ic.parm.num, "L0010");\r\nchanp->cs->iif.statcallb(&ic);\r\nif (chanp->debug & 1)\r\nlink_debug(chanp, 0, "STAT_DHUP");\r\nHL_LL(chanp, ISDN_STAT_DHUP);\r\nlli_close(fi);\r\n}\r\nstatic void\r\nlli_disconnect_req(struct FsmInst *fi, int event, void *arg)\r\n{\r\nstruct Channel *chanp = fi->userdata;\r\nif (chanp->leased) {\r\nlli_leased_hup(fi, chanp);\r\n} else {\r\nFsmChangeState(fi, ST_WAIT_DRELEASE);\r\nif (chanp->proc)\r\nchanp->proc->para.cause = 0x10;\r\nchanp->d_st->lli.l4l3(chanp->d_st, CC_DISCONNECT | REQUEST,\r\nchanp->proc);\r\n}\r\n}\r\nstatic void\r\nlli_disconnect_reject(struct FsmInst *fi, int event, void *arg)\r\n{\r\nstruct Channel *chanp = fi->userdata;\r\nif (chanp->leased) {\r\nlli_leased_hup(fi, chanp);\r\n} else {\r\nFsmChangeState(fi, ST_WAIT_DRELEASE);\r\nif (chanp->proc)\r\nchanp->proc->para.cause = 0x15;\r\nchanp->d_st->lli.l4l3(chanp->d_st, CC_DISCONNECT | REQUEST,\r\nchanp->proc);\r\n}\r\n}\r\nstatic void\r\nlli_dhup_close(struct FsmInst *fi, int event, void *arg)\r\n{\r\nstruct Channel *chanp = fi->userdata;\r\nif (chanp->leased) {\r\nlli_leased_hup(fi, chanp);\r\n} else {\r\nif (chanp->debug & 1)\r\nlink_debug(chanp, 0, "STAT_DHUP");\r\nlli_deliver_cause(chanp);\r\nHL_LL(chanp, ISDN_STAT_DHUP);\r\nlli_close(fi);\r\n}\r\n}\r\nstatic void\r\nlli_reject_req(struct FsmInst *fi, int event, void *arg)\r\n{\r\nstruct Channel *chanp = fi->userdata;\r\nif (chanp->leased) {\r\nlli_leased_hup(fi, chanp);\r\nreturn;\r\n}\r\n#ifndef ALERT_REJECT\r\nif (chanp->proc)\r\nchanp->proc->para.cause = 0x15;\r\nchanp->d_st->lli.l4l3(chanp->d_st, CC_REJECT | REQUEST, chanp->proc);\r\nlli_dhup_close(fi, event, arg);\r\n#else\r\nFsmRestartTimer(&chanp->drel_timer, 40, EV_HANGUP, NULL, 63);\r\nFsmChangeState(fi, ST_IN_ALERT_SENT);\r\nchanp->d_st->lli.l4l3(chanp->d_st, CC_ALERTING | REQUEST, chanp->proc);\r\n#endif\r\n}\r\nstatic void\r\nlli_disconn_bchan(struct FsmInst *fi, int event, void *arg)\r\n{\r\nstruct Channel *chanp = fi->userdata;\r\nchanp->data_open = 0;\r\nFsmChangeState(fi, ST_WAIT_BRELEASE);\r\nchanp->b_st->lli.l4l3(chanp->b_st, DL_RELEASE | REQUEST, NULL);\r\n}\r\nstatic void\r\nlli_start_disc(struct FsmInst *fi, int event, void *arg)\r\n{\r\nstruct Channel *chanp = fi->userdata;\r\nif (chanp->leased) {\r\nlli_leased_hup(fi, chanp);\r\n} else {\r\nlli_disconnect_req(fi, event, arg);\r\n}\r\n}\r\nstatic void\r\nlli_rel_b_disc(struct FsmInst *fi, int event, void *arg)\r\n{\r\nstruct Channel *chanp = fi->userdata;\r\nrelease_b_st(chanp);\r\nlli_start_disc(fi, event, arg);\r\n}\r\nstatic void\r\nlli_bhup_disc(struct FsmInst *fi, int event, void *arg)\r\n{\r\nstruct Channel *chanp = fi->userdata;\r\nif (chanp->debug & 1)\r\nlink_debug(chanp, 0, "STAT_BHUP");\r\nHL_LL(chanp, ISDN_STAT_BHUP);\r\nlli_rel_b_disc(fi, event, arg);\r\n}\r\nstatic void\r\nlli_bhup_rel_b(struct FsmInst *fi, int event, void *arg)\r\n{\r\nstruct Channel *chanp = fi->userdata;\r\nFsmChangeState(fi, ST_WAIT_DCOMMAND);\r\nchanp->data_open = 0;\r\nif (chanp->debug & 1)\r\nlink_debug(chanp, 0, "STAT_BHUP");\r\nHL_LL(chanp, ISDN_STAT_BHUP);\r\nrelease_b_st(chanp);\r\n}\r\nstatic void\r\nlli_release_bchan(struct FsmInst *fi, int event, void *arg)\r\n{\r\nstruct Channel *chanp = fi->userdata;\r\nchanp->data_open = 0;\r\nFsmChangeState(fi, ST_WAIT_BREL_DISC);\r\nchanp->b_st->lli.l4l3(chanp->b_st, DL_RELEASE | REQUEST, NULL);\r\n}\r\nstatic void\r\nlli_rel_b_dhup(struct FsmInst *fi, int event, void *arg)\r\n{\r\nstruct Channel *chanp = fi->userdata;\r\nrelease_b_st(chanp);\r\nlli_dhup_close(fi, event, arg);\r\n}\r\nstatic void\r\nlli_bhup_dhup(struct FsmInst *fi, int event, void *arg)\r\n{\r\nstruct Channel *chanp = fi->userdata;\r\nif (chanp->debug & 1)\r\nlink_debug(chanp, 0, "STAT_BHUP");\r\nHL_LL(chanp, ISDN_STAT_BHUP);\r\nlli_rel_b_dhup(fi, event, arg);\r\n}\r\nstatic void\r\nlli_abort(struct FsmInst *fi, int event, void *arg)\r\n{\r\nstruct Channel *chanp = fi->userdata;\r\nchanp->data_open = 0;\r\nchanp->b_st->lli.l4l3(chanp->b_st, DL_RELEASE | REQUEST, NULL);\r\nlli_bhup_dhup(fi, event, arg);\r\n}\r\nstatic void\r\nlli_release_req(struct FsmInst *fi, int event, void *arg)\r\n{\r\nstruct Channel *chanp = fi->userdata;\r\nif (chanp->leased) {\r\nlli_leased_hup(fi, chanp);\r\n} else {\r\nFsmChangeState(fi, ST_WAIT_D_REL_CNF);\r\nchanp->d_st->lli.l4l3(chanp->d_st, CC_RELEASE | REQUEST,\r\nchanp->proc);\r\n}\r\n}\r\nstatic void\r\nlli_rel_b_release_req(struct FsmInst *fi, int event, void *arg)\r\n{\r\nstruct Channel *chanp = fi->userdata;\r\nrelease_b_st(chanp);\r\nlli_release_req(fi, event, arg);\r\n}\r\nstatic void\r\nlli_bhup_release_req(struct FsmInst *fi, int event, void *arg)\r\n{\r\nstruct Channel *chanp = fi->userdata;\r\nif (chanp->debug & 1)\r\nlink_debug(chanp, 0, "STAT_BHUP");\r\nHL_LL(chanp, ISDN_STAT_BHUP);\r\nlli_rel_b_release_req(fi, event, arg);\r\n}\r\nstatic void\r\nlli_charge_info(struct FsmInst *fi, int event, void *arg)\r\n{\r\nstruct Channel *chanp = fi->userdata;\r\nisdn_ctrl ic;\r\nic.driver = chanp->cs->myid;\r\nic.command = ISDN_STAT_CINF;\r\nic.arg = chanp->chan;\r\nsprintf(ic.parm.num, "%d", chanp->proc->para.chargeinfo);\r\nchanp->cs->iif.statcallb(&ic);\r\n}\r\nstatic void\r\nlli_dchan_not_ready(struct FsmInst *fi, int event, void *arg)\r\n{\r\nstruct Channel *chanp = fi->userdata;\r\nif (chanp->debug & 1)\r\nlink_debug(chanp, 0, "STAT_DHUP");\r\nHL_LL(chanp, ISDN_STAT_DHUP);\r\n}\r\nstatic void\r\nlli_no_setup_rsp(struct FsmInst *fi, int event, void *arg)\r\n{\r\nstruct Channel *chanp = fi->userdata;\r\nif (chanp->debug & 1)\r\nlink_debug(chanp, 0, "STAT_DHUP");\r\nHL_LL(chanp, ISDN_STAT_DHUP);\r\nlli_close(fi);\r\n}\r\nstatic void\r\nlli_error(struct FsmInst *fi, int event, void *arg)\r\n{\r\nFsmChangeState(fi, ST_WAIT_DRELEASE);\r\n}\r\nstatic void\r\nlli_failure_l(struct FsmInst *fi, int event, void *arg)\r\n{\r\nstruct Channel *chanp = fi->userdata;\r\nisdn_ctrl ic;\r\nFsmChangeState(fi, ST_NULL);\r\nic.driver = chanp->cs->myid;\r\nic.command = ISDN_STAT_CAUSE;\r\nic.arg = chanp->chan;\r\nsprintf(ic.parm.num, "L%02X%02X", 0, 0x2f);\r\nchanp->cs->iif.statcallb(&ic);\r\nHL_LL(chanp, ISDN_STAT_DHUP);\r\nchanp->Flags = 0;\r\nchanp->cs->cardmsg(chanp->cs, MDL_INFO_REL, (void *) (long)chanp->chan);\r\n}\r\nstatic void\r\nlli_rel_b_fail(struct FsmInst *fi, int event, void *arg)\r\n{\r\nstruct Channel *chanp = fi->userdata;\r\nrelease_b_st(chanp);\r\nlli_failure_l(fi, event, arg);\r\n}\r\nstatic void\r\nlli_bhup_fail(struct FsmInst *fi, int event, void *arg)\r\n{\r\nstruct Channel *chanp = fi->userdata;\r\nif (chanp->debug & 1)\r\nlink_debug(chanp, 0, "STAT_BHUP");\r\nHL_LL(chanp, ISDN_STAT_BHUP);\r\nlli_rel_b_fail(fi, event, arg);\r\n}\r\nstatic void\r\nlli_failure_a(struct FsmInst *fi, int event, void *arg)\r\n{\r\nstruct Channel *chanp = fi->userdata;\r\nchanp->data_open = 0;\r\nchanp->b_st->lli.l4l3(chanp->b_st, DL_RELEASE | REQUEST, NULL);\r\nlli_bhup_fail(fi, event, arg);\r\n}\r\nint __init\r\nCallcNew(void)\r\n{\r\ncallcfsm.state_count = STATE_COUNT;\r\ncallcfsm.event_count = EVENT_COUNT;\r\ncallcfsm.strEvent = strEvent;\r\ncallcfsm.strState = strState;\r\nreturn FsmNew(&callcfsm, fnlist, ARRAY_SIZE(fnlist));\r\n}\r\nvoid\r\nCallcFree(void)\r\n{\r\nFsmFree(&callcfsm);\r\n}\r\nstatic void\r\nrelease_b_st(struct Channel *chanp)\r\n{\r\nstruct PStack *st = chanp->b_st;\r\nif (test_and_clear_bit(FLG_START_B, &chanp->Flags)) {\r\nchanp->bcs->BC_Close(chanp->bcs);\r\nswitch (chanp->l2_active_protocol) {\r\ncase (ISDN_PROTO_L2_X75I):\r\nreleasestack_isdnl2(st);\r\nbreak;\r\ncase (ISDN_PROTO_L2_HDLC):\r\ncase (ISDN_PROTO_L2_HDLC_56K):\r\ncase (ISDN_PROTO_L2_TRANS):\r\ncase (ISDN_PROTO_L2_MODEM):\r\ncase (ISDN_PROTO_L2_FAX):\r\nreleasestack_transl2(st);\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic struct Channel\r\n*selectfreechannel(struct PStack *st, int bch)\r\n{\r\nstruct IsdnCardState *cs = st->l1.hardware;\r\nstruct Channel *chanp = st->lli.userdata;\r\nint i;\r\nif (test_bit(FLG_TWO_DCHAN, &cs->HW_Flags))\r\ni = 1;\r\nelse\r\ni = 0;\r\nif (!bch) {\r\ni = 2;\r\nchanp += 2;\r\n}\r\nwhile (i < ((bch) ? cs->chanlimit : (2 + MAX_WAITING_CALLS))) {\r\nif (chanp->fi.state == ST_NULL)\r\nreturn (chanp);\r\nchanp++;\r\ni++;\r\n}\r\nif (bch) {\r\ni = 2;\r\nchanp = st->lli.userdata;\r\nchanp += i;\r\nwhile (i < (2 + MAX_WAITING_CALLS)) {\r\nif (chanp->fi.state == ST_NULL)\r\nreturn (chanp);\r\nchanp++;\r\ni++;\r\n}\r\n}\r\nreturn (NULL);\r\n}\r\nstatic void stat_redir_result(struct IsdnCardState *cs, int chan, ulong result)\r\n{ isdn_ctrl ic;\r\nic.driver = cs->myid;\r\nic.command = ISDN_STAT_REDIR;\r\nic.arg = chan;\r\nic.parm.num[0] = result;\r\ncs->iif.statcallb(&ic);\r\n}\r\nstatic void\r\ndchan_l3l4(struct PStack *st, int pr, void *arg)\r\n{\r\nstruct l3_process *pc = arg;\r\nstruct IsdnCardState *cs = st->l1.hardware;\r\nstruct Channel *chanp;\r\nif (!pc)\r\nreturn;\r\nif (pr == (CC_SETUP | INDICATION)) {\r\nif (!(chanp = selectfreechannel(pc->st, pc->para.bchannel))) {\r\npc->para.cause = 0x11;\r\npc->st->lli.l4l3(pc->st, CC_REJECT | REQUEST, pc);\r\n} else {\r\nchanp->proc = pc;\r\npc->chan = chanp;\r\nFsmEvent(&chanp->fi, EV_SETUP_IND, NULL);\r\n}\r\nreturn;\r\n}\r\nif (!(chanp = pc->chan))\r\nreturn;\r\nswitch (pr) {\r\ncase (CC_MORE_INFO | INDICATION):\r\nFsmEvent(&chanp->fi, EV_SETUP_IND, NULL);\r\nbreak;\r\ncase (CC_DISCONNECT | INDICATION):\r\nFsmEvent(&chanp->fi, EV_DISCONNECT_IND, NULL);\r\nbreak;\r\ncase (CC_RELEASE | CONFIRM):\r\nFsmEvent(&chanp->fi, EV_RELEASE, NULL);\r\nbreak;\r\ncase (CC_SUSPEND | CONFIRM):\r\nFsmEvent(&chanp->fi, EV_RELEASE, NULL);\r\nbreak;\r\ncase (CC_RESUME | CONFIRM):\r\nFsmEvent(&chanp->fi, EV_SETUP_CNF, NULL);\r\nbreak;\r\ncase (CC_RESUME_ERR):\r\nFsmEvent(&chanp->fi, EV_RELEASE, NULL);\r\nbreak;\r\ncase (CC_RELEASE | INDICATION):\r\nFsmEvent(&chanp->fi, EV_RELEASE, NULL);\r\nbreak;\r\ncase (CC_SETUP_COMPL | INDICATION):\r\nFsmEvent(&chanp->fi, EV_SETUP_CMPL_IND, NULL);\r\nbreak;\r\ncase (CC_SETUP | CONFIRM):\r\nFsmEvent(&chanp->fi, EV_SETUP_CNF, NULL);\r\nbreak;\r\ncase (CC_CHARGE | INDICATION):\r\nFsmEvent(&chanp->fi, EV_CINF, NULL);\r\nbreak;\r\ncase (CC_NOSETUP_RSP):\r\nFsmEvent(&chanp->fi, EV_NOSETUP_RSP, NULL);\r\nbreak;\r\ncase (CC_SETUP_ERR):\r\nFsmEvent(&chanp->fi, EV_SETUP_ERR, NULL);\r\nbreak;\r\ncase (CC_CONNECT_ERR):\r\nFsmEvent(&chanp->fi, EV_CONNECT_ERR, NULL);\r\nbreak;\r\ncase (CC_RELEASE_ERR):\r\nFsmEvent(&chanp->fi, EV_RELEASE, NULL);\r\nbreak;\r\ncase (CC_PROCEED_SEND | INDICATION):\r\ncase (CC_PROCEEDING | INDICATION):\r\ncase (CC_ALERTING | INDICATION):\r\ncase (CC_PROGRESS | INDICATION):\r\ncase (CC_NOTIFY | INDICATION):\r\nbreak;\r\ncase (CC_REDIR | INDICATION):\r\nstat_redir_result(cs, chanp->chan, pc->redir_result);\r\nbreak;\r\ndefault:\r\nif (chanp->debug & 0x800) {\r\nHiSax_putstatus(chanp->cs, "Ch",\r\n"%d L3->L4 unknown primitiv %#x",\r\nchanp->chan, pr);\r\n}\r\n}\r\n}\r\nstatic void\r\ndummy_pstack(struct PStack *st, int pr, void *arg) {\r\nprintk(KERN_WARNING"call to dummy_pstack pr=%04x arg %lx\n", pr, (long)arg);\r\n}\r\nstatic int\r\ninit_PStack(struct PStack **stp) {\r\n*stp = kmalloc(sizeof(struct PStack), GFP_ATOMIC);\r\nif (!*stp)\r\nreturn -ENOMEM;\r\n(*stp)->next = NULL;\r\n(*stp)->l1.l1l2 = dummy_pstack;\r\n(*stp)->l1.l1hw = dummy_pstack;\r\n(*stp)->l1.l1tei = dummy_pstack;\r\n(*stp)->l2.l2tei = dummy_pstack;\r\n(*stp)->l2.l2l1 = dummy_pstack;\r\n(*stp)->l2.l2l3 = dummy_pstack;\r\n(*stp)->l3.l3l2 = dummy_pstack;\r\n(*stp)->l3.l3ml3 = dummy_pstack;\r\n(*stp)->l3.l3l4 = dummy_pstack;\r\n(*stp)->lli.l4l3 = dummy_pstack;\r\n(*stp)->ma.layer = dummy_pstack;\r\nreturn 0;\r\n}\r\nstatic int\r\ninit_d_st(struct Channel *chanp)\r\n{\r\nstruct PStack *st;\r\nstruct IsdnCardState *cs = chanp->cs;\r\nchar tmp[16];\r\nint err;\r\nerr = init_PStack(&chanp->d_st);\r\nif (err)\r\nreturn err;\r\nst = chanp->d_st;\r\nst->next = NULL;\r\nHiSax_addlist(cs, st);\r\nsetstack_HiSax(st, cs);\r\nst->l2.sap = 0;\r\nst->l2.tei = -1;\r\nst->l2.flag = 0;\r\ntest_and_set_bit(FLG_MOD128, &st->l2.flag);\r\ntest_and_set_bit(FLG_LAPD, &st->l2.flag);\r\ntest_and_set_bit(FLG_ORIG, &st->l2.flag);\r\nst->l2.maxlen = MAX_DFRAME_LEN;\r\nst->l2.window = 1;\r\nst->l2.T200 = 1000;\r\nst->l2.N200 = 3;\r\nst->l2.T203 = 10000;\r\nif (test_bit(FLG_TWO_DCHAN, &cs->HW_Flags))\r\nsprintf(tmp, "DCh%d Q.921 ", chanp->chan);\r\nelse\r\nsprintf(tmp, "DCh Q.921 ");\r\nsetstack_isdnl2(st, tmp);\r\nsetstack_l3dc(st, chanp);\r\nst->lli.userdata = chanp;\r\nst->l3.l3l4 = dchan_l3l4;\r\nreturn 0;\r\n}\r\nstatic void\r\nrelease_d_st(struct Channel *chanp)\r\n{\r\nstruct PStack *st = chanp->d_st;\r\nif (!st)\r\nreturn;\r\nreleasestack_isdnl2(st);\r\nreleasestack_isdnl3(st);\r\nHiSax_rmlist(st->l1.hardware, st);\r\nkfree(st);\r\nchanp->d_st = NULL;\r\n}\r\nvoid\r\nCallcFreeChan(struct IsdnCardState *csta)\r\n{\r\nint i;\r\nfor (i = 0; i < 2; i++) {\r\nFsmDelTimer(&csta->channel[i].drel_timer, 74);\r\nFsmDelTimer(&csta->channel[i].dial_timer, 75);\r\nif (i || test_bit(FLG_TWO_DCHAN, &csta->HW_Flags))\r\nrelease_d_st(csta->channel + i);\r\nif (csta->channel[i].b_st) {\r\nrelease_b_st(csta->channel + i);\r\nkfree(csta->channel[i].b_st);\r\ncsta->channel[i].b_st = NULL;\r\n} else\r\nprintk(KERN_WARNING "CallcFreeChan b_st ch%d already freed\n", i);\r\nif (i || test_bit(FLG_TWO_DCHAN, &csta->HW_Flags)) {\r\nrelease_d_st(csta->channel + i);\r\n} else\r\ncsta->channel[i].d_st = NULL;\r\n}\r\n}\r\nstatic void\r\nlldata_handler(struct PStack *st, int pr, void *arg)\r\n{\r\nstruct Channel *chanp = (struct Channel *) st->lli.userdata;\r\nstruct sk_buff *skb = arg;\r\nswitch (pr) {\r\ncase (DL_DATA | INDICATION):\r\nif (chanp->data_open) {\r\nif (chanp->debug & 0x800)\r\nlink_debug(chanp, 0, "lldata: %d", skb->len);\r\nchanp->cs->iif.rcvcallb_skb(chanp->cs->myid, chanp->chan, skb);\r\n} else {\r\nlink_debug(chanp, 0, "lldata: channel not open");\r\ndev_kfree_skb(skb);\r\n}\r\nbreak;\r\ncase (DL_ESTABLISH | INDICATION):\r\ncase (DL_ESTABLISH | CONFIRM):\r\nFsmEvent(&chanp->fi, EV_BC_EST, NULL);\r\nbreak;\r\ncase (DL_RELEASE | INDICATION):\r\ncase (DL_RELEASE | CONFIRM):\r\nFsmEvent(&chanp->fi, EV_BC_REL, NULL);\r\nbreak;\r\ndefault:\r\nprintk(KERN_WARNING "lldata_handler unknown primitive %#x\n",\r\npr);\r\nbreak;\r\n}\r\n}\r\nstatic void\r\nlltrans_handler(struct PStack *st, int pr, void *arg)\r\n{\r\nstruct Channel *chanp = (struct Channel *) st->lli.userdata;\r\nstruct sk_buff *skb = arg;\r\nswitch (pr) {\r\ncase (PH_DATA | INDICATION):\r\nif (chanp->data_open) {\r\nif (chanp->debug & 0x800)\r\nlink_debug(chanp, 0, "lltrans: %d", skb->len);\r\nchanp->cs->iif.rcvcallb_skb(chanp->cs->myid, chanp->chan, skb);\r\n} else {\r\nlink_debug(chanp, 0, "lltrans: channel not open");\r\ndev_kfree_skb(skb);\r\n}\r\nbreak;\r\ncase (PH_ACTIVATE | INDICATION):\r\ncase (PH_ACTIVATE | CONFIRM):\r\nFsmEvent(&chanp->fi, EV_BC_EST, NULL);\r\nbreak;\r\ncase (PH_DEACTIVATE | INDICATION):\r\ncase (PH_DEACTIVATE | CONFIRM):\r\nFsmEvent(&chanp->fi, EV_BC_REL, NULL);\r\nbreak;\r\ndefault:\r\nprintk(KERN_WARNING "lltrans_handler unknown primitive %#x\n",\r\npr);\r\nbreak;\r\n}\r\n}\r\nvoid\r\nlli_writewakeup(struct PStack *st, int len)\r\n{\r\nstruct Channel *chanp = st->lli.userdata;\r\nisdn_ctrl ic;\r\nif (chanp->debug & 0x800)\r\nlink_debug(chanp, 0, "llwakeup: %d", len);\r\nic.driver = chanp->cs->myid;\r\nic.command = ISDN_STAT_BSENT;\r\nic.arg = chanp->chan;\r\nic.parm.length = len;\r\nchanp->cs->iif.statcallb(&ic);\r\n}\r\nstatic int\r\ninit_b_st(struct Channel *chanp, int incoming)\r\n{\r\nstruct PStack *st = chanp->b_st;\r\nstruct IsdnCardState *cs = chanp->cs;\r\nchar tmp[16];\r\nst->l1.hardware = cs;\r\nif (chanp->leased)\r\nst->l1.bc = chanp->chan & 1;\r\nelse\r\nst->l1.bc = chanp->proc->para.bchannel - 1;\r\nswitch (chanp->l2_active_protocol) {\r\ncase (ISDN_PROTO_L2_X75I):\r\ncase (ISDN_PROTO_L2_HDLC):\r\nst->l1.mode = L1_MODE_HDLC;\r\nbreak;\r\ncase (ISDN_PROTO_L2_HDLC_56K):\r\nst->l1.mode = L1_MODE_HDLC_56K;\r\nbreak;\r\ncase (ISDN_PROTO_L2_TRANS):\r\nst->l1.mode = L1_MODE_TRANS;\r\nbreak;\r\ncase (ISDN_PROTO_L2_MODEM):\r\nst->l1.mode = L1_MODE_V32;\r\nbreak;\r\ncase (ISDN_PROTO_L2_FAX):\r\nst->l1.mode = L1_MODE_FAX;\r\nbreak;\r\n}\r\nchanp->bcs->conmsg = NULL;\r\nif (chanp->bcs->BC_SetStack(st, chanp->bcs))\r\nreturn (-1);\r\nst->l2.flag = 0;\r\ntest_and_set_bit(FLG_LAPB, &st->l2.flag);\r\nst->l2.maxlen = MAX_DATA_SIZE;\r\nif (!incoming)\r\ntest_and_set_bit(FLG_ORIG, &st->l2.flag);\r\nst->l2.T200 = 1000;\r\nst->l2.window = 7;\r\nst->l2.N200 = 4;\r\nst->l2.T203 = 5000;\r\nst->l3.debug = 0;\r\nswitch (chanp->l2_active_protocol) {\r\ncase (ISDN_PROTO_L2_X75I):\r\nsprintf(tmp, "Ch%d X.75", chanp->chan);\r\nsetstack_isdnl2(st, tmp);\r\nsetstack_l3bc(st, chanp);\r\nst->l2.l2l3 = lldata_handler;\r\nst->lli.userdata = chanp;\r\ntest_and_clear_bit(FLG_LLI_L1WAKEUP, &st->lli.flag);\r\ntest_and_set_bit(FLG_LLI_L2WAKEUP, &st->lli.flag);\r\nst->l2.l2m.debug = chanp->debug & 16;\r\nst->l2.debug = chanp->debug & 64;\r\nbreak;\r\ncase (ISDN_PROTO_L2_HDLC):\r\ncase (ISDN_PROTO_L2_HDLC_56K):\r\ncase (ISDN_PROTO_L2_TRANS):\r\ncase (ISDN_PROTO_L2_MODEM):\r\ncase (ISDN_PROTO_L2_FAX):\r\nst->l1.l1l2 = lltrans_handler;\r\nst->lli.userdata = chanp;\r\ntest_and_set_bit(FLG_LLI_L1WAKEUP, &st->lli.flag);\r\ntest_and_clear_bit(FLG_LLI_L2WAKEUP, &st->lli.flag);\r\nsetstack_transl2(st);\r\nsetstack_l3bc(st, chanp);\r\nbreak;\r\n}\r\ntest_and_set_bit(FLG_START_B, &chanp->Flags);\r\nreturn (0);\r\n}\r\nstatic void\r\nleased_l4l3(struct PStack *st, int pr, void *arg)\r\n{\r\nstruct Channel *chanp = (struct Channel *) st->lli.userdata;\r\nstruct sk_buff *skb = arg;\r\nswitch (pr) {\r\ncase (DL_DATA | REQUEST):\r\nlink_debug(chanp, 0, "leased line d-channel DATA");\r\ndev_kfree_skb(skb);\r\nbreak;\r\ncase (DL_ESTABLISH | REQUEST):\r\nst->l2.l2l1(st, PH_ACTIVATE | REQUEST, NULL);\r\nbreak;\r\ncase (DL_RELEASE | REQUEST):\r\nbreak;\r\ndefault:\r\nprintk(KERN_WARNING "transd_l4l3 unknown primitive %#x\n",\r\npr);\r\nbreak;\r\n}\r\n}\r\nstatic void\r\nleased_l1l2(struct PStack *st, int pr, void *arg)\r\n{\r\nstruct Channel *chanp = (struct Channel *) st->lli.userdata;\r\nstruct sk_buff *skb = arg;\r\nint i, event = EV_LEASED_REL;\r\nswitch (pr) {\r\ncase (PH_DATA | INDICATION):\r\nlink_debug(chanp, 0, "leased line d-channel DATA");\r\ndev_kfree_skb(skb);\r\nbreak;\r\ncase (PH_ACTIVATE | INDICATION):\r\ncase (PH_ACTIVATE | CONFIRM):\r\nevent = EV_LEASED;\r\ncase (PH_DEACTIVATE | INDICATION):\r\ncase (PH_DEACTIVATE | CONFIRM):\r\nif (test_bit(FLG_TWO_DCHAN, &chanp->cs->HW_Flags))\r\ni = 1;\r\nelse\r\ni = 0;\r\nwhile (i < 2) {\r\nFsmEvent(&chanp->fi, event, NULL);\r\nchanp++;\r\ni++;\r\n}\r\nbreak;\r\ndefault:\r\nprintk(KERN_WARNING\r\n"transd_l1l2 unknown primitive %#x\n", pr);\r\nbreak;\r\n}\r\n}\r\nstatic void\r\ndistr_debug(struct IsdnCardState *csta, int debugflags)\r\n{\r\nint i;\r\nstruct Channel *chanp = csta->channel;\r\nfor (i = 0; i < (2 + MAX_WAITING_CALLS); i++) {\r\nchanp[i].debug = debugflags;\r\nchanp[i].fi.debug = debugflags & 2;\r\nchanp[i].d_st->l2.l2m.debug = debugflags & 8;\r\nchanp[i].b_st->l2.l2m.debug = debugflags & 0x10;\r\nchanp[i].d_st->l2.debug = debugflags & 0x20;\r\nchanp[i].b_st->l2.debug = debugflags & 0x40;\r\nchanp[i].d_st->l3.l3m.debug = debugflags & 0x80;\r\nchanp[i].b_st->l3.l3m.debug = debugflags & 0x100;\r\nchanp[i].b_st->ma.tei_m.debug = debugflags & 0x200;\r\nchanp[i].b_st->ma.debug = debugflags & 0x200;\r\nchanp[i].d_st->l1.l1m.debug = debugflags & 0x1000;\r\nchanp[i].b_st->l1.l1m.debug = debugflags & 0x2000;\r\n}\r\nif (debugflags & 4)\r\ncsta->debug |= DEB_DLOG_HEX;\r\nelse\r\ncsta->debug &= ~DEB_DLOG_HEX;\r\n}\r\nstatic void\r\ncapi_debug(struct Channel *chanp, capi_msg *cm)\r\n{\r\nchar *t = tmpbuf;\r\nt += QuickHex(t, (u_char *)cm, (cm->Length > 50) ? 50 : cm->Length);\r\nt--;\r\n*t = 0;\r\nHiSax_putstatus(chanp->cs, "Ch", "%d CAPIMSG %s", chanp->chan, tmpbuf);\r\n}\r\nstatic void\r\nlli_got_fac_req(struct Channel *chanp, capi_msg *cm) {\r\nif ((cm->para[0] != 3) || (cm->para[1] != 0))\r\nreturn;\r\nif (cm->para[2] < 3)\r\nreturn;\r\nif (cm->para[4] != 0)\r\nreturn;\r\nswitch (cm->para[3]) {\r\ncase 4:\r\nstrncpy(chanp->setup.phone, &cm->para[5], cm->para[5] + 1);\r\nFsmEvent(&chanp->fi, EV_SUSPEND, cm);\r\nbreak;\r\ncase 5:\r\nstrncpy(chanp->setup.phone, &cm->para[5], cm->para[5] + 1);\r\nif (chanp->fi.state == ST_NULL) {\r\nFsmEvent(&chanp->fi, EV_RESUME, cm);\r\n} else {\r\nFsmDelTimer(&chanp->dial_timer, 72);\r\nFsmAddTimer(&chanp->dial_timer, 80, EV_RESUME, cm, 73);\r\n}\r\nbreak;\r\n}\r\n}\r\nstatic void\r\nlli_got_manufacturer(struct Channel *chanp, struct IsdnCardState *cs, capi_msg *cm) {\r\nif ((cs->typ == ISDN_CTYPE_ELSA) || (cs->typ == ISDN_CTYPE_ELSA_PNP) ||\r\n(cs->typ == ISDN_CTYPE_ELSA_PCI)) {\r\nif (cs->hw.elsa.MFlag) {\r\ncs->cardmsg(cs, CARD_AUX_IND, cm->para);\r\n}\r\n}\r\n}\r\nstatic int\r\nset_channel_limit(struct IsdnCardState *cs, int chanmax)\r\n{\r\nisdn_ctrl ic;\r\nint i, ii;\r\nif ((chanmax < 0) || (chanmax > 2))\r\nreturn (-EINVAL);\r\ncs->chanlimit = 0;\r\nfor (ii = 0; ii < 2; ii++) {\r\nic.driver = cs->myid;\r\nic.command = ISDN_STAT_DISCH;\r\nic.arg = ii;\r\nif (ii >= chanmax)\r\nic.parm.num[0] = 0;\r\nelse\r\nic.parm.num[0] = 1;\r\ni = cs->iif.statcallb(&ic);\r\nif (i) return (-EINVAL);\r\nif (ii < chanmax)\r\ncs->chanlimit++;\r\n}\r\nreturn (0);\r\n}\r\nint\r\nHiSax_command(isdn_ctrl *ic)\r\n{\r\nstruct IsdnCardState *csta = hisax_findcard(ic->driver);\r\nstruct PStack *st;\r\nstruct Channel *chanp;\r\nint i;\r\nu_int num;\r\nif (!csta) {\r\nprintk(KERN_ERR\r\n"HiSax: if_command %d called with invalid driverId %d!\n",\r\nic->command, ic->driver);\r\nreturn -ENODEV;\r\n}\r\nswitch (ic->command) {\r\ncase (ISDN_CMD_SETEAZ):\r\nchanp = csta->channel + ic->arg;\r\nbreak;\r\ncase (ISDN_CMD_SETL2):\r\nchanp = csta->channel + (ic->arg & 0xff);\r\nif (chanp->debug & 1)\r\nlink_debug(chanp, 1, "SETL2 card %d %ld",\r\ncsta->cardnr + 1, ic->arg >> 8);\r\nchanp->l2_protocol = ic->arg >> 8;\r\nbreak;\r\ncase (ISDN_CMD_SETL3):\r\nchanp = csta->channel + (ic->arg & 0xff);\r\nif (chanp->debug & 1)\r\nlink_debug(chanp, 1, "SETL3 card %d %ld",\r\ncsta->cardnr + 1, ic->arg >> 8);\r\nchanp->l3_protocol = ic->arg >> 8;\r\nbreak;\r\ncase (ISDN_CMD_DIAL):\r\nchanp = csta->channel + (ic->arg & 0xff);\r\nif (chanp->debug & 1)\r\nlink_debug(chanp, 1, "DIAL %s -> %s (%d,%d)",\r\nic->parm.setup.eazmsn, ic->parm.setup.phone,\r\nic->parm.setup.si1, ic->parm.setup.si2);\r\nmemcpy(&chanp->setup, &ic->parm.setup, sizeof(setup_parm));\r\nif (!strcmp(chanp->setup.eazmsn, "0"))\r\nchanp->setup.eazmsn[0] = '\0';\r\nif (chanp->fi.state == ST_NULL) {\r\nFsmEvent(&chanp->fi, EV_DIAL, NULL);\r\n} else {\r\nFsmDelTimer(&chanp->dial_timer, 70);\r\nFsmAddTimer(&chanp->dial_timer, 50, EV_DIAL, NULL, 71);\r\n}\r\nbreak;\r\ncase (ISDN_CMD_ACCEPTB):\r\nchanp = csta->channel + ic->arg;\r\nif (chanp->debug & 1)\r\nlink_debug(chanp, 1, "ACCEPTB");\r\nFsmEvent(&chanp->fi, EV_ACCEPTB, NULL);\r\nbreak;\r\ncase (ISDN_CMD_ACCEPTD):\r\nchanp = csta->channel + ic->arg;\r\nmemcpy(&chanp->setup, &ic->parm.setup, sizeof(setup_parm));\r\nif (chanp->debug & 1)\r\nlink_debug(chanp, 1, "ACCEPTD");\r\nFsmEvent(&chanp->fi, EV_ACCEPTD, NULL);\r\nbreak;\r\ncase (ISDN_CMD_HANGUP):\r\nchanp = csta->channel + ic->arg;\r\nif (chanp->debug & 1)\r\nlink_debug(chanp, 1, "HANGUP");\r\nFsmEvent(&chanp->fi, EV_HANGUP, NULL);\r\nbreak;\r\ncase (CAPI_PUT_MESSAGE):\r\nchanp = csta->channel + ic->arg;\r\nif (chanp->debug & 1)\r\ncapi_debug(chanp, &ic->parm.cmsg);\r\nif (ic->parm.cmsg.Length < 8)\r\nbreak;\r\nswitch (ic->parm.cmsg.Command) {\r\ncase CAPI_FACILITY:\r\nif (ic->parm.cmsg.Subcommand == CAPI_REQ)\r\nlli_got_fac_req(chanp, &ic->parm.cmsg);\r\nbreak;\r\ncase CAPI_MANUFACTURER:\r\nif (ic->parm.cmsg.Subcommand == CAPI_REQ)\r\nlli_got_manufacturer(chanp, csta, &ic->parm.cmsg);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nbreak;\r\ncase (ISDN_CMD_IOCTL):\r\nswitch (ic->arg) {\r\ncase (0):\r\nnum = *(unsigned int *) ic->parm.num;\r\nHiSax_reportcard(csta->cardnr, num);\r\nbreak;\r\ncase (1):\r\nnum = *(unsigned int *) ic->parm.num;\r\ndistr_debug(csta, num);\r\nprintk(KERN_DEBUG "HiSax: debugging flags card %d set to %x\n",\r\ncsta->cardnr + 1, num);\r\nHiSax_putstatus(csta, "debugging flags ",\r\n"card %d set to %x", csta->cardnr + 1, num);\r\nbreak;\r\ncase (2):\r\nnum = *(unsigned int *) ic->parm.num;\r\ncsta->channel[0].b_st->l1.delay = num;\r\ncsta->channel[1].b_st->l1.delay = num;\r\nHiSax_putstatus(csta, "delay ", "card %d set to %d ms",\r\ncsta->cardnr + 1, num);\r\nprintk(KERN_DEBUG "HiSax: delay card %d set to %d ms\n",\r\ncsta->cardnr + 1, num);\r\nbreak;\r\ncase (5):\r\nnum = *(unsigned int *) ic->parm.num;\r\nif ((num < 1) || (num > 2)) {\r\nHiSax_putstatus(csta, "Set LEASED ",\r\n"wrong channel %d", num);\r\nprintk(KERN_WARNING "HiSax: Set LEASED wrong channel %d\n",\r\nnum);\r\n} else {\r\nnum--;\r\nchanp = csta->channel + num;\r\nchanp->leased = 1;\r\nHiSax_putstatus(csta, "Card",\r\n"%d channel %d set leased mode\n",\r\ncsta->cardnr + 1, num + 1);\r\nchanp->d_st->l1.l1l2 = leased_l1l2;\r\nchanp->d_st->lli.l4l3 = leased_l4l3;\r\nchanp->d_st->lli.l4l3(chanp->d_st,\r\nDL_ESTABLISH | REQUEST, NULL);\r\n}\r\nbreak;\r\ncase (6):\r\nnum = *(unsigned int *) ic->parm.num;\r\nif (csta->stlist)\r\ncsta->stlist->l2.l2l1(csta->stlist,\r\nPH_TESTLOOP | REQUEST, (void *) (long)num);\r\nbreak;\r\ncase (7):\r\nnum = *(unsigned int *) ic->parm.num;\r\nif (test_bit(FLG_TWO_DCHAN, &csta->HW_Flags)) {\r\nprintk(KERN_ERR "HiSax PTP mode only with one TEI possible\n");\r\n} else if (num) {\r\ntest_and_set_bit(FLG_PTP, &csta->channel[0].d_st->l2.flag);\r\ntest_and_set_bit(FLG_FIXED_TEI, &csta->channel[0].d_st->l2.flag);\r\ncsta->channel[0].d_st->l2.tei = 0;\r\nHiSax_putstatus(csta, "set card ", "in PTP mode");\r\nprintk(KERN_DEBUG "HiSax: set card in PTP mode\n");\r\nprintk(KERN_INFO "LAYER2 WATCHING ESTABLISH\n");\r\ncsta->channel[0].d_st->lli.l4l3(csta->channel[0].d_st,\r\nDL_ESTABLISH | REQUEST, NULL);\r\n} else {\r\ntest_and_clear_bit(FLG_PTP, &csta->channel[0].d_st->l2.flag);\r\ntest_and_clear_bit(FLG_FIXED_TEI, &csta->channel[0].d_st->l2.flag);\r\nHiSax_putstatus(csta, "set card ", "in PTMP mode");\r\nprintk(KERN_DEBUG "HiSax: set card in PTMP mode\n");\r\n}\r\nbreak;\r\ncase (8):\r\nnum = *(unsigned int *)ic->parm.num;\r\nchanp = csta->channel + (num & 1);\r\nnum = num >> 1;\r\nif (num == 127) {\r\ntest_and_clear_bit(FLG_FIXED_TEI, &chanp->d_st->l2.flag);\r\nchanp->d_st->l2.tei = -1;\r\nHiSax_putstatus(csta, "set card ", "in VAR TEI mode");\r\nprintk(KERN_DEBUG "HiSax: set card in VAR TEI mode\n");\r\n} else {\r\ntest_and_set_bit(FLG_FIXED_TEI, &chanp->d_st->l2.flag);\r\nchanp->d_st->l2.tei = num;\r\nHiSax_putstatus(csta, "set card ", "in FIXED TEI (%d) mode", num);\r\nprintk(KERN_DEBUG "HiSax: set card in FIXED TEI (%d) mode\n",\r\nnum);\r\n}\r\nchanp->d_st->lli.l4l3(chanp->d_st,\r\nDL_ESTABLISH | REQUEST, NULL);\r\nbreak;\r\ncase (11):\r\nnum = csta->debug & DEB_DLOG_HEX;\r\ncsta->debug = *(unsigned int *) ic->parm.num;\r\ncsta->debug |= num;\r\nHiSax_putstatus(cards[0].cs, "l1 debugging ",\r\n"flags card %d set to %x",\r\ncsta->cardnr + 1, csta->debug);\r\nprintk(KERN_DEBUG "HiSax: l1 debugging flags card %d set to %x\n",\r\ncsta->cardnr + 1, csta->debug);\r\nbreak;\r\ncase (13):\r\ncsta->channel[0].d_st->l3.debug = *(unsigned int *) ic->parm.num;\r\ncsta->channel[1].d_st->l3.debug = *(unsigned int *) ic->parm.num;\r\nHiSax_putstatus(cards[0].cs, "l3 debugging ",\r\n"flags card %d set to %x\n", csta->cardnr + 1,\r\n*(unsigned int *) ic->parm.num);\r\nprintk(KERN_DEBUG "HiSax: l3 debugging flags card %d set to %x\n",\r\ncsta->cardnr + 1, *(unsigned int *) ic->parm.num);\r\nbreak;\r\ncase (10):\r\ni = *(unsigned int *) ic->parm.num;\r\nreturn (set_channel_limit(csta, i));\r\ndefault:\r\nif (csta->auxcmd)\r\nreturn (csta->auxcmd(csta, ic));\r\nprintk(KERN_DEBUG "HiSax: invalid ioctl %d\n",\r\n(int) ic->arg);\r\nreturn (-EINVAL);\r\n}\r\nbreak;\r\ncase (ISDN_CMD_PROCEED):\r\nchanp = csta->channel + ic->arg;\r\nif (chanp->debug & 1)\r\nlink_debug(chanp, 1, "PROCEED");\r\nFsmEvent(&chanp->fi, EV_PROCEED, NULL);\r\nbreak;\r\ncase (ISDN_CMD_ALERT):\r\nchanp = csta->channel + ic->arg;\r\nif (chanp->debug & 1)\r\nlink_debug(chanp, 1, "ALERT");\r\nFsmEvent(&chanp->fi, EV_ALERT, NULL);\r\nbreak;\r\ncase (ISDN_CMD_REDIR):\r\nchanp = csta->channel + ic->arg;\r\nif (chanp->debug & 1)\r\nlink_debug(chanp, 1, "REDIR");\r\nmemcpy(&chanp->setup, &ic->parm.setup, sizeof(setup_parm));\r\nFsmEvent(&chanp->fi, EV_REDIR, NULL);\r\nbreak;\r\ncase (ISDN_CMD_PROT_IO):\r\nfor (st = csta->stlist; st; st = st->next)\r\nif (st->protocol == (ic->arg & 0xFF))\r\nreturn (st->lli.l4l3_proto(st, ic));\r\nreturn (-EINVAL);\r\nbreak;\r\ndefault:\r\nif (csta->auxcmd)\r\nreturn (csta->auxcmd(csta, ic));\r\nreturn (-EINVAL);\r\n}\r\nreturn (0);\r\n}\r\nint\r\nHiSax_writebuf_skb(int id, int chan, int ack, struct sk_buff *skb)\r\n{\r\nstruct IsdnCardState *csta = hisax_findcard(id);\r\nstruct Channel *chanp;\r\nstruct PStack *st;\r\nint len = skb->len;\r\nstruct sk_buff *nskb;\r\nif (!csta) {\r\nprintk(KERN_ERR\r\n"HiSax: if_sendbuf called with invalid driverId!\n");\r\nreturn -ENODEV;\r\n}\r\nchanp = csta->channel + chan;\r\nst = chanp->b_st;\r\nif (!chanp->data_open) {\r\nlink_debug(chanp, 1, "writebuf: channel not open");\r\nreturn -EIO;\r\n}\r\nif (len > MAX_DATA_SIZE) {\r\nlink_debug(chanp, 1, "writebuf: packet too large (%d bytes)", len);\r\nprintk(KERN_WARNING "HiSax_writebuf: packet too large (%d bytes) !\n",\r\nlen);\r\nreturn -EINVAL;\r\n}\r\nif (len) {\r\nif ((len + chanp->bcs->tx_cnt) > MAX_DATA_MEM) {\r\nif (chanp->debug & 0x800)\r\nlink_debug(chanp, 1, "writebuf: no buffers for %d bytes", len);\r\nreturn 0;\r\n} else if (chanp->debug & 0x800)\r\nlink_debug(chanp, 1, "writebuf %d/%d/%d", len, chanp->bcs->tx_cnt, MAX_DATA_MEM);\r\nnskb = skb_clone(skb, GFP_ATOMIC);\r\nif (nskb) {\r\nnskb->truesize = nskb->len;\r\nif (!ack)\r\nnskb->pkt_type = PACKET_NOACK;\r\nif (chanp->l2_active_protocol == ISDN_PROTO_L2_X75I)\r\nst->l3.l3l2(st, DL_DATA | REQUEST, nskb);\r\nelse {\r\nchanp->bcs->tx_cnt += len;\r\nst->l2.l2l1(st, PH_DATA | REQUEST, nskb);\r\n}\r\ndev_kfree_skb(skb);\r\n} else\r\nlen = 0;\r\n}\r\nreturn (len);\r\n}
