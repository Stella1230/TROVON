static inline void xor_64(u8 *a, const u8 *b)\r\n{\r\n((u32 *)a)[0] ^= ((u32 *)b)[0];\r\n((u32 *)a)[1] ^= ((u32 *)b)[1];\r\n}\r\nstatic inline void xor_128(u8 *a, const u8 *b)\r\n{\r\n((u32 *)a)[0] ^= ((u32 *)b)[0];\r\n((u32 *)a)[1] ^= ((u32 *)b)[1];\r\n((u32 *)a)[2] ^= ((u32 *)b)[2];\r\n((u32 *)a)[3] ^= ((u32 *)b)[3];\r\n}\r\nstatic int crypt(struct crypto_tfm *tfm,\r\nstruct scatterlist *dst,\r\nstruct scatterlist *src,\r\nunsigned int nbytes, cryptfn_t crfn,\r\nprocfn_t prfn, int enc, void *info)\r\n{\r\nstruct scatter_walk walk_in, walk_out;\r\nconst unsigned int bsize = crypto_tfm_alg_blocksize(tfm);\r\nu8 tmp_src[bsize];\r\nu8 tmp_dst[bsize];\r\nif (!nbytes)\r\nreturn 0;\r\nif (nbytes % bsize) {\r\ntfm->crt_flags |= CRYPTO_TFM_RES_BAD_BLOCK_LEN;\r\nreturn -EINVAL;\r\n}\r\nscatterwalk_start(&walk_in, src);\r\nscatterwalk_start(&walk_out, dst);\r\nfor(;;) {\r\nu8 *src_p, *dst_p;\r\nint in_place;\r\nscatterwalk_map(&walk_in);\r\nscatterwalk_map(&walk_out);\r\nsrc_p = scatterwalk_whichbuf(&walk_in, bsize, tmp_src);\r\ndst_p = scatterwalk_whichbuf(&walk_out, bsize, tmp_dst);\r\nin_place = scatterwalk_samebuf(&walk_in, &walk_out,\r\nsrc_p, dst_p);\r\nnbytes -= bsize;\r\nscatterwalk_copychunks(src_p, &walk_in, bsize, 0);\r\nprfn(tfm, dst_p, src_p, crfn, enc, info, in_place);\r\nscatterwalk_done(&walk_in, nbytes);\r\nscatterwalk_copychunks(dst_p, &walk_out, bsize, 1);\r\nscatterwalk_done(&walk_out, nbytes);\r\nif (!nbytes)\r\nreturn 0;\r\ncrypto_yield(tfm);\r\n}\r\n}\r\nstatic void cbc_process(struct crypto_tfm *tfm, u8 *dst, u8 *src,\r\ncryptfn_t fn, int enc, void *info, int in_place)\r\n{\r\nu8 *iv = info;\r\nif (!iv)\r\nreturn;\r\nif (enc) {\r\ntfm->crt_u.cipher.cit_xor_block(iv, src);\r\nfn(crypto_tfm_ctx(tfm), dst, iv);\r\nmemcpy(iv, dst, crypto_tfm_alg_blocksize(tfm));\r\n} else {\r\nu8 stack[in_place ? crypto_tfm_alg_blocksize(tfm) : 0];\r\nu8 *buf = in_place ? stack : dst;\r\nfn(crypto_tfm_ctx(tfm), buf, src);\r\ntfm->crt_u.cipher.cit_xor_block(buf, iv);\r\nmemcpy(iv, src, crypto_tfm_alg_blocksize(tfm));\r\nif (buf != dst)\r\nmemcpy(dst, buf, crypto_tfm_alg_blocksize(tfm));\r\n}\r\n}\r\nstatic void ecb_process(struct crypto_tfm *tfm, u8 *dst, u8 *src,\r\ncryptfn_t fn, int enc, void *info, int in_place)\r\n{\r\nfn(crypto_tfm_ctx(tfm), dst, src);\r\n}\r\nstatic int setkey(struct crypto_tfm *tfm, const u8 *key, unsigned int keylen)\r\n{\r\nstruct cipher_alg *cia = &tfm->__crt_alg->cra_cipher;\r\nif (keylen < cia->cia_min_keysize || keylen > cia->cia_max_keysize) {\r\ntfm->crt_flags |= CRYPTO_TFM_RES_BAD_KEY_LEN;\r\nreturn -EINVAL;\r\n} else\r\nreturn cia->cia_setkey(crypto_tfm_ctx(tfm), key, keylen,\r\n&tfm->crt_flags);\r\n}\r\nstatic int ecb_encrypt(struct crypto_tfm *tfm,\r\nstruct scatterlist *dst,\r\nstruct scatterlist *src, unsigned int nbytes)\r\n{\r\nreturn crypt(tfm, dst, src, nbytes,\r\ntfm->__crt_alg->cra_cipher.cia_encrypt,\r\necb_process, 1, NULL);\r\n}\r\nstatic int ecb_decrypt(struct crypto_tfm *tfm,\r\nstruct scatterlist *dst,\r\nstruct scatterlist *src,\r\nunsigned int nbytes)\r\n{\r\nreturn crypt(tfm, dst, src, nbytes,\r\ntfm->__crt_alg->cra_cipher.cia_decrypt,\r\necb_process, 1, NULL);\r\n}\r\nstatic int cbc_encrypt(struct crypto_tfm *tfm,\r\nstruct scatterlist *dst,\r\nstruct scatterlist *src,\r\nunsigned int nbytes)\r\n{\r\nreturn crypt(tfm, dst, src, nbytes,\r\ntfm->__crt_alg->cra_cipher.cia_encrypt,\r\ncbc_process, 1, tfm->crt_cipher.cit_iv);\r\n}\r\nstatic int cbc_encrypt_iv(struct crypto_tfm *tfm,\r\nstruct scatterlist *dst,\r\nstruct scatterlist *src,\r\nunsigned int nbytes, u8 *iv)\r\n{\r\nreturn crypt(tfm, dst, src, nbytes,\r\ntfm->__crt_alg->cra_cipher.cia_encrypt,\r\ncbc_process, 1, iv);\r\n}\r\nstatic int cbc_decrypt(struct crypto_tfm *tfm,\r\nstruct scatterlist *dst,\r\nstruct scatterlist *src,\r\nunsigned int nbytes)\r\n{\r\nreturn crypt(tfm, dst, src, nbytes,\r\ntfm->__crt_alg->cra_cipher.cia_decrypt,\r\ncbc_process, 0, tfm->crt_cipher.cit_iv);\r\n}\r\nstatic int cbc_decrypt_iv(struct crypto_tfm *tfm,\r\nstruct scatterlist *dst,\r\nstruct scatterlist *src,\r\nunsigned int nbytes, u8 *iv)\r\n{\r\nreturn crypt(tfm, dst, src, nbytes,\r\ntfm->__crt_alg->cra_cipher.cia_decrypt,\r\ncbc_process, 0, iv);\r\n}\r\nstatic int nocrypt(struct crypto_tfm *tfm,\r\nstruct scatterlist *dst,\r\nstruct scatterlist *src,\r\nunsigned int nbytes)\r\n{\r\nreturn -ENOSYS;\r\n}\r\nstatic int nocrypt_iv(struct crypto_tfm *tfm,\r\nstruct scatterlist *dst,\r\nstruct scatterlist *src,\r\nunsigned int nbytes, u8 *iv)\r\n{\r\nreturn -ENOSYS;\r\n}\r\nint crypto_init_cipher_flags(struct crypto_tfm *tfm, u32 flags)\r\n{\r\nu32 mode = flags & CRYPTO_TFM_MODE_MASK;\r\ntfm->crt_cipher.cit_mode = mode ? mode : CRYPTO_TFM_MODE_ECB;\r\nif (flags & CRYPTO_TFM_REQ_WEAK_KEY)\r\ntfm->crt_flags = CRYPTO_TFM_REQ_WEAK_KEY;\r\nreturn 0;\r\n}\r\nint crypto_init_cipher_ops(struct crypto_tfm *tfm)\r\n{\r\nint ret = 0;\r\nstruct cipher_tfm *ops = &tfm->crt_cipher;\r\nops->cit_setkey = setkey;\r\nswitch (tfm->crt_cipher.cit_mode) {\r\ncase CRYPTO_TFM_MODE_ECB:\r\nops->cit_encrypt = ecb_encrypt;\r\nops->cit_decrypt = ecb_decrypt;\r\nbreak;\r\ncase CRYPTO_TFM_MODE_CBC:\r\nops->cit_encrypt = cbc_encrypt;\r\nops->cit_decrypt = cbc_decrypt;\r\nops->cit_encrypt_iv = cbc_encrypt_iv;\r\nops->cit_decrypt_iv = cbc_decrypt_iv;\r\nbreak;\r\ncase CRYPTO_TFM_MODE_CFB:\r\nops->cit_encrypt = nocrypt;\r\nops->cit_decrypt = nocrypt;\r\nops->cit_encrypt_iv = nocrypt_iv;\r\nops->cit_decrypt_iv = nocrypt_iv;\r\nbreak;\r\ncase CRYPTO_TFM_MODE_CTR:\r\nops->cit_encrypt = nocrypt;\r\nops->cit_decrypt = nocrypt;\r\nops->cit_encrypt_iv = nocrypt_iv;\r\nops->cit_decrypt_iv = nocrypt_iv;\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\nif (ops->cit_mode == CRYPTO_TFM_MODE_CBC) {\r\nswitch (crypto_tfm_alg_blocksize(tfm)) {\r\ncase 8:\r\nops->cit_xor_block = xor_64;\r\nbreak;\r\ncase 16:\r\nops->cit_xor_block = xor_128;\r\nbreak;\r\ndefault:\r\nprintk(KERN_WARNING "%s: block size %u not supported\n",\r\ncrypto_tfm_alg_name(tfm),\r\ncrypto_tfm_alg_blocksize(tfm));\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nops->cit_ivsize = crypto_tfm_alg_blocksize(tfm);\r\nops->cit_iv = kmalloc(ops->cit_ivsize, GFP_KERNEL);\r\nif (ops->cit_iv == NULL)\r\nret = -ENOMEM;\r\n}\r\nout:\r\nreturn ret;\r\n}\r\nvoid crypto_exit_cipher_ops(struct crypto_tfm *tfm)\r\n{\r\nkfree(tfm->crt_cipher.cit_iv);\r\n}
