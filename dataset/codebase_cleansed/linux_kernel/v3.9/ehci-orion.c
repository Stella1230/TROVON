static void orion_usb_phy_v1_setup(struct usb_hcd *hcd)\r\n{\r\nwrl(USB_CAUSE, 0);\r\nwrl(USB_MASK, 0);\r\nwrl(USB_CMD, rdl(USB_CMD) | 0x2);\r\nwhile (rdl(USB_CMD) & 0x2);\r\nwrl(USB_IPG, (rdl(USB_IPG) & ~0x7f00) | 0xc00);\r\nwrl(USB_PHY_PWR_CTRL, (rdl(USB_PHY_PWR_CTRL) & ~0xc0)| 0x40);\r\nwrl(USB_PHY_TX_CTRL, (rdl(USB_PHY_TX_CTRL) & ~0x78) | 0x202040);\r\nwrl(USB_PHY_RX_CTRL, (rdl(USB_PHY_RX_CTRL) & ~0xc2003f0) | 0xc0000010);\r\nwrl(USB_PHY_IVREF_CTRL, (rdl(USB_PHY_IVREF_CTRL) & ~0x80003 ) | 0x32);\r\nwrl(USB_PHY_TST_GRP_CTRL, rdl(USB_PHY_TST_GRP_CTRL) & ~0x8000);\r\nwrl(USB_CMD, rdl(USB_CMD) & ~0x1);\r\nwrl(USB_CMD, rdl(USB_CMD) | 0x2);\r\nwhile (rdl(USB_CMD) & 0x2);\r\nwrl(USB_MODE, 0x13);\r\n}\r\nstatic void\r\nehci_orion_conf_mbus_windows(struct usb_hcd *hcd,\r\nconst struct mbus_dram_target_info *dram)\r\n{\r\nint i;\r\nfor (i = 0; i < 4; i++) {\r\nwrl(USB_WINDOW_CTRL(i), 0);\r\nwrl(USB_WINDOW_BASE(i), 0);\r\n}\r\nfor (i = 0; i < dram->num_cs; i++) {\r\nconst struct mbus_dram_window *cs = dram->cs + i;\r\nwrl(USB_WINDOW_CTRL(i), ((cs->size - 1) & 0xffff0000) |\r\n(cs->mbus_attr << 8) |\r\n(dram->mbus_dram_target_id << 4) | 1);\r\nwrl(USB_WINDOW_BASE(i), cs->base);\r\n}\r\n}\r\nstatic int ehci_orion_drv_probe(struct platform_device *pdev)\r\n{\r\nstruct orion_ehci_data *pd = pdev->dev.platform_data;\r\nconst struct mbus_dram_target_info *dram;\r\nstruct resource *res;\r\nstruct usb_hcd *hcd;\r\nstruct ehci_hcd *ehci;\r\nstruct clk *clk;\r\nvoid __iomem *regs;\r\nint irq, err;\r\nenum orion_ehci_phy_ver phy_version;\r\nif (usb_disabled())\r\nreturn -ENODEV;\r\npr_debug("Initializing Orion-SoC USB Host Controller\n");\r\nif (pdev->dev.of_node)\r\nirq = irq_of_parse_and_map(pdev->dev.of_node, 0);\r\nelse\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq <= 0) {\r\ndev_err(&pdev->dev,\r\n"Found HC with no IRQ. Check %s setup!\n",\r\ndev_name(&pdev->dev));\r\nerr = -ENODEV;\r\ngoto err1;\r\n}\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!res) {\r\ndev_err(&pdev->dev,\r\n"Found HC with no register addr. Check %s setup!\n",\r\ndev_name(&pdev->dev));\r\nerr = -ENODEV;\r\ngoto err1;\r\n}\r\nif (!pdev->dev.dma_mask)\r\npdev->dev.dma_mask = &ehci_orion_dma_mask;\r\nif (!request_mem_region(res->start, resource_size(res),\r\nehci_orion_hc_driver.description)) {\r\ndev_dbg(&pdev->dev, "controller already in use\n");\r\nerr = -EBUSY;\r\ngoto err1;\r\n}\r\nregs = ioremap(res->start, resource_size(res));\r\nif (regs == NULL) {\r\ndev_dbg(&pdev->dev, "error mapping memory\n");\r\nerr = -EFAULT;\r\ngoto err2;\r\n}\r\nclk = clk_get(&pdev->dev, NULL);\r\nif (!IS_ERR(clk)) {\r\nclk_prepare_enable(clk);\r\nclk_put(clk);\r\n}\r\nhcd = usb_create_hcd(&ehci_orion_hc_driver,\r\n&pdev->dev, dev_name(&pdev->dev));\r\nif (!hcd) {\r\nerr = -ENOMEM;\r\ngoto err3;\r\n}\r\nhcd->rsrc_start = res->start;\r\nhcd->rsrc_len = resource_size(res);\r\nhcd->regs = regs;\r\nehci = hcd_to_ehci(hcd);\r\nehci->caps = hcd->regs + 0x100;\r\nhcd->has_tt = 1;\r\ndram = mv_mbus_dram_info();\r\nif (dram)\r\nehci_orion_conf_mbus_windows(hcd, dram);\r\nif (pdev->dev.of_node)\r\nphy_version = EHCI_PHY_NA;\r\nelse\r\nphy_version = pd->phy_version;\r\nswitch (phy_version) {\r\ncase EHCI_PHY_NA:\r\nbreak;\r\ncase EHCI_PHY_ORION:\r\norion_usb_phy_v1_setup(hcd);\r\nbreak;\r\ncase EHCI_PHY_DD:\r\ncase EHCI_PHY_KW:\r\ndefault:\r\nprintk(KERN_WARNING "Orion ehci -USB phy version isn't supported.\n");\r\n}\r\nerr = usb_add_hcd(hcd, irq, IRQF_SHARED);\r\nif (err)\r\ngoto err4;\r\nreturn 0;\r\nerr4:\r\nusb_put_hcd(hcd);\r\nerr3:\r\nif (!IS_ERR(clk)) {\r\nclk_disable_unprepare(clk);\r\nclk_put(clk);\r\n}\r\niounmap(regs);\r\nerr2:\r\nrelease_mem_region(res->start, resource_size(res));\r\nerr1:\r\ndev_err(&pdev->dev, "init %s fail, %d\n",\r\ndev_name(&pdev->dev), err);\r\nreturn err;\r\n}\r\nstatic int __exit ehci_orion_drv_remove(struct platform_device *pdev)\r\n{\r\nstruct usb_hcd *hcd = platform_get_drvdata(pdev);\r\nstruct clk *clk;\r\nusb_remove_hcd(hcd);\r\niounmap(hcd->regs);\r\nrelease_mem_region(hcd->rsrc_start, hcd->rsrc_len);\r\nusb_put_hcd(hcd);\r\nclk = clk_get(&pdev->dev, NULL);\r\nif (!IS_ERR(clk)) {\r\nclk_disable_unprepare(clk);\r\nclk_put(clk);\r\n}\r\nreturn 0;\r\n}
