static void ida_procinit(int i) {}\r\nstatic inline drv_info_t *get_drv(struct gendisk *disk)\r\n{\r\nreturn disk->private_data;\r\n}\r\nstatic inline ctlr_info_t *get_host(struct gendisk *disk)\r\n{\r\nreturn disk->queue->queuedata;\r\n}\r\nstatic void __init ida_procinit(int i)\r\n{\r\nif (proc_array == NULL) {\r\nproc_array = proc_mkdir("driver/cpqarray", NULL);\r\nif (!proc_array) return;\r\n}\r\nproc_create_data(hba[i]->devname, 0, proc_array, &ida_proc_fops, hba[i]);\r\n}\r\nstatic int ida_proc_show(struct seq_file *m, void *v)\r\n{\r\nint i, ctlr;\r\nctlr_info_t *h = (ctlr_info_t*)m->private;\r\ndrv_info_t *drv;\r\n#ifdef CPQ_PROC_PRINT_QUEUES\r\ncmdlist_t *c;\r\nunsigned long flags;\r\n#endif\r\nctlr = h->ctlr;\r\nseq_printf(m, "%s: Compaq %s Controller\n"\r\n" Board ID: 0x%08lx\n"\r\n" Firmware Revision: %c%c%c%c\n"\r\n" Controller Sig: 0x%08lx\n"\r\n" Memory Address: 0x%08lx\n"\r\n" I/O Port: 0x%04x\n"\r\n" IRQ: %d\n"\r\n" Logical drives: %d\n"\r\n" Physical drives: %d\n\n"\r\n" Current Q depth: %d\n"\r\n" Max Q depth since init: %d\n\n",\r\nh->devname,\r\nh->product_name,\r\n(unsigned long)h->board_id,\r\nh->firm_rev[0], h->firm_rev[1], h->firm_rev[2], h->firm_rev[3],\r\n(unsigned long)h->ctlr_sig, (unsigned long)h->vaddr,\r\n(unsigned int) h->io_mem_addr, (unsigned int)h->intr,\r\nh->log_drives, h->phys_drives,\r\nh->Qdepth, h->maxQsinceinit);\r\nseq_puts(m, "Logical Drive Info:\n");\r\nfor(i=0; i<h->log_drives; i++) {\r\ndrv = &h->drv[i];\r\nseq_printf(m, "ida/c%dd%d: blksz=%d nr_blks=%d\n",\r\nctlr, i, drv->blk_size, drv->nr_blks);\r\n}\r\n#ifdef CPQ_PROC_PRINT_QUEUES\r\nspin_lock_irqsave(IDA_LOCK(h->ctlr), flags);\r\nseq_puts(m, "\nCurrent Queues:\n");\r\nc = h->reqQ;\r\nseq_printf(m, "reqQ = %p", c);\r\nif (c) c=c->next;\r\nwhile(c && c != h->reqQ) {\r\nseq_printf(m, "->%p", c);\r\nc=c->next;\r\n}\r\nc = h->cmpQ;\r\nseq_printf(m, "\ncmpQ = %p", c);\r\nif (c) c=c->next;\r\nwhile(c && c != h->cmpQ) {\r\nseq_printf(m, "->%p", c);\r\nc=c->next;\r\n}\r\nseq_putc(m, '\n');\r\nspin_unlock_irqrestore(IDA_LOCK(h->ctlr), flags);\r\n#endif\r\nseq_printf(m, "nr_allocs = %d\nnr_frees = %d\n",\r\nh->nr_allocs, h->nr_frees);\r\nreturn 0;\r\n}\r\nstatic int ida_proc_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, ida_proc_show, PDE(inode)->data);\r\n}\r\nstatic void release_io_mem(ctlr_info_t *c)\r\n{\r\nif( c->io_mem_addr == 0)\r\nreturn;\r\nrelease_region(c->io_mem_addr, c->io_mem_length);\r\nc->io_mem_addr = 0;\r\nc->io_mem_length = 0;\r\n}\r\nstatic void cpqarray_remove_one(int i)\r\n{\r\nint j;\r\nchar buff[4];\r\nif( sendcmd(FLUSH_CACHE, i, buff, 4, 0, 0, 0))\r\n{\r\nprintk(KERN_WARNING "Unable to flush cache on controller %d\n",\r\ni);\r\n}\r\nfree_irq(hba[i]->intr, hba[i]);\r\niounmap(hba[i]->vaddr);\r\nunregister_blkdev(COMPAQ_SMART2_MAJOR+i, hba[i]->devname);\r\ndel_timer(&hba[i]->timer);\r\nremove_proc_entry(hba[i]->devname, proc_array);\r\npci_free_consistent(hba[i]->pci_dev,\r\nNR_CMDS * sizeof(cmdlist_t), (hba[i]->cmd_pool),\r\nhba[i]->cmd_pool_dhandle);\r\nkfree(hba[i]->cmd_pool_bits);\r\nfor(j = 0; j < NWD; j++) {\r\nif (ida_gendisk[i][j]->flags & GENHD_FL_UP)\r\ndel_gendisk(ida_gendisk[i][j]);\r\nput_disk(ida_gendisk[i][j]);\r\n}\r\nblk_cleanup_queue(hba[i]->queue);\r\nrelease_io_mem(hba[i]);\r\nfree_hba(i);\r\n}\r\nstatic void cpqarray_remove_one_pci(struct pci_dev *pdev)\r\n{\r\nint i;\r\nctlr_info_t *tmp_ptr;\r\nif (pci_get_drvdata(pdev) == NULL) {\r\nprintk( KERN_ERR "cpqarray: Unable to remove device \n");\r\nreturn;\r\n}\r\ntmp_ptr = pci_get_drvdata(pdev);\r\ni = tmp_ptr->ctlr;\r\nif (hba[i] == NULL) {\r\nprintk(KERN_ERR "cpqarray: controller %d appears to have"\r\n"already been removed \n", i);\r\nreturn;\r\n}\r\npci_set_drvdata(pdev, NULL);\r\ncpqarray_remove_one(i);\r\n}\r\nstatic void cpqarray_remove_one_eisa(int i)\r\n{\r\nif (hba[i] == NULL) {\r\nprintk(KERN_ERR "cpqarray: controller %d appears to have"\r\n"already been removed \n", i);\r\nreturn;\r\n}\r\ncpqarray_remove_one(i);\r\n}\r\nstatic int cpqarray_register_ctlr(int i, struct pci_dev *pdev)\r\n{\r\nstruct request_queue *q;\r\nint j;\r\nif (register_blkdev(COMPAQ_SMART2_MAJOR+i, hba[i]->devname)) {\r\ngoto Enomem4;\r\n}\r\nhba[i]->access.set_intr_mask(hba[i], 0);\r\nif (request_irq(hba[i]->intr, do_ida_intr,\r\nIRQF_DISABLED|IRQF_SHARED, hba[i]->devname, hba[i]))\r\n{\r\nprintk(KERN_ERR "cpqarray: Unable to get irq %d for %s\n",\r\nhba[i]->intr, hba[i]->devname);\r\ngoto Enomem3;\r\n}\r\nfor (j=0; j<NWD; j++) {\r\nida_gendisk[i][j] = alloc_disk(1 << NWD_SHIFT);\r\nif (!ida_gendisk[i][j])\r\ngoto Enomem2;\r\n}\r\nhba[i]->cmd_pool = pci_alloc_consistent(\r\nhba[i]->pci_dev, NR_CMDS * sizeof(cmdlist_t),\r\n&(hba[i]->cmd_pool_dhandle));\r\nhba[i]->cmd_pool_bits = kcalloc(\r\nDIV_ROUND_UP(NR_CMDS, BITS_PER_LONG), sizeof(unsigned long),\r\nGFP_KERNEL);\r\nif (!hba[i]->cmd_pool_bits || !hba[i]->cmd_pool)\r\ngoto Enomem1;\r\nmemset(hba[i]->cmd_pool, 0, NR_CMDS * sizeof(cmdlist_t));\r\nprintk(KERN_INFO "cpqarray: Finding drives on %s",\r\nhba[i]->devname);\r\nspin_lock_init(&hba[i]->lock);\r\nq = blk_init_queue(do_ida_request, &hba[i]->lock);\r\nif (!q)\r\ngoto Enomem1;\r\nhba[i]->queue = q;\r\nq->queuedata = hba[i];\r\ngetgeometry(i);\r\nstart_fwbk(i);\r\nida_procinit(i);\r\nif (pdev)\r\nblk_queue_bounce_limit(q, hba[i]->pci_dev->dma_mask);\r\nblk_queue_max_segments(q, SG_MAX);\r\ninit_timer(&hba[i]->timer);\r\nhba[i]->timer.expires = jiffies + IDA_TIMER;\r\nhba[i]->timer.data = (unsigned long)hba[i];\r\nhba[i]->timer.function = ida_timer;\r\nadd_timer(&hba[i]->timer);\r\nhba[i]->access.set_intr_mask(hba[i], FIFO_NOT_EMPTY);\r\nfor(j=0; j<NWD; j++) {\r\nstruct gendisk *disk = ida_gendisk[i][j];\r\ndrv_info_t *drv = &hba[i]->drv[j];\r\nsprintf(disk->disk_name, "ida/c%dd%d", i, j);\r\ndisk->major = COMPAQ_SMART2_MAJOR + i;\r\ndisk->first_minor = j<<NWD_SHIFT;\r\ndisk->fops = &ida_fops;\r\nif (j && !drv->nr_blks)\r\ncontinue;\r\nblk_queue_logical_block_size(hba[i]->queue, drv->blk_size);\r\nset_capacity(disk, drv->nr_blks);\r\ndisk->queue = hba[i]->queue;\r\ndisk->private_data = drv;\r\nadd_disk(disk);\r\n}\r\nreturn(i);\r\nEnomem1:\r\nnr_ctlr = i;\r\nkfree(hba[i]->cmd_pool_bits);\r\nif (hba[i]->cmd_pool)\r\npci_free_consistent(hba[i]->pci_dev, NR_CMDS*sizeof(cmdlist_t),\r\nhba[i]->cmd_pool, hba[i]->cmd_pool_dhandle);\r\nEnomem2:\r\nwhile (j--) {\r\nput_disk(ida_gendisk[i][j]);\r\nida_gendisk[i][j] = NULL;\r\n}\r\nfree_irq(hba[i]->intr, hba[i]);\r\nEnomem3:\r\nunregister_blkdev(COMPAQ_SMART2_MAJOR+i, hba[i]->devname);\r\nEnomem4:\r\nif (pdev)\r\npci_set_drvdata(pdev, NULL);\r\nrelease_io_mem(hba[i]);\r\nfree_hba(i);\r\nprintk( KERN_ERR "cpqarray: out of memory");\r\nreturn -1;\r\n}\r\nstatic int cpqarray_init_one(struct pci_dev *pdev,\r\nconst struct pci_device_id *ent)\r\n{\r\nint i;\r\nprintk(KERN_DEBUG "cpqarray: Device 0x%x has been found at"\r\n" bus %d dev %d func %d\n",\r\npdev->device, pdev->bus->number, PCI_SLOT(pdev->devfn),\r\nPCI_FUNC(pdev->devfn));\r\ni = alloc_cpqarray_hba();\r\nif( i < 0 )\r\nreturn (-1);\r\nmemset(hba[i], 0, sizeof(ctlr_info_t));\r\nsprintf(hba[i]->devname, "ida%d", i);\r\nhba[i]->ctlr = i;\r\npci_set_drvdata(pdev, hba[i]);\r\nif (cpqarray_pci_init(hba[i], pdev) != 0) {\r\npci_set_drvdata(pdev, NULL);\r\nrelease_io_mem(hba[i]);\r\nfree_hba(i);\r\nreturn -1;\r\n}\r\nreturn (cpqarray_register_ctlr(i, pdev));\r\n}\r\nstatic int __init cpqarray_init(void)\r\n{\r\nint num_cntlrs_reg = 0;\r\nint i;\r\nint rc = 0;\r\nprintk(DRIVER_NAME "\n");\r\nrc = pci_register_driver(&cpqarray_pci_driver);\r\nif (rc)\r\nreturn rc;\r\ncpqarray_eisa_detect();\r\nfor (i=0; i < MAX_CTLR; i++) {\r\nif (hba[i] != NULL)\r\nnum_cntlrs_reg++;\r\n}\r\nif (num_cntlrs_reg)\r\nreturn 0;\r\nelse {\r\npci_unregister_driver(&cpqarray_pci_driver);\r\nreturn -ENODEV;\r\n}\r\n}\r\nstatic int alloc_cpqarray_hba(void)\r\n{\r\nint i;\r\nfor(i=0; i< MAX_CTLR; i++) {\r\nif (hba[i] == NULL) {\r\nhba[i] = kmalloc(sizeof(ctlr_info_t), GFP_KERNEL);\r\nif(hba[i]==NULL) {\r\nprintk(KERN_ERR "cpqarray: out of memory.\n");\r\nreturn (-1);\r\n}\r\nreturn (i);\r\n}\r\n}\r\nprintk(KERN_WARNING "cpqarray: This driver supports a maximum"\r\n" of 8 controllers.\n");\r\nreturn(-1);\r\n}\r\nstatic void free_hba(int i)\r\n{\r\nkfree(hba[i]);\r\nhba[i]=NULL;\r\n}\r\nstatic int cpqarray_pci_init(ctlr_info_t *c, struct pci_dev *pdev)\r\n{\r\nushort vendor_id, device_id, command;\r\nunchar cache_line_size, latency_timer;\r\nunchar irq, revision;\r\nunsigned long addr[6];\r\n__u32 board_id;\r\nint i;\r\nc->pci_dev = pdev;\r\npci_set_master(pdev);\r\nif (pci_enable_device(pdev)) {\r\nprintk(KERN_ERR "cpqarray: Unable to Enable PCI device\n");\r\nreturn -1;\r\n}\r\nvendor_id = pdev->vendor;\r\ndevice_id = pdev->device;\r\nrevision = pdev->revision;\r\nirq = pdev->irq;\r\nfor(i=0; i<6; i++)\r\naddr[i] = pci_resource_start(pdev, i);\r\nif (pci_set_dma_mask(pdev, CPQARRAY_DMA_MASK) != 0)\r\n{\r\nprintk(KERN_ERR "cpqarray: Unable to set DMA mask\n");\r\nreturn -1;\r\n}\r\npci_read_config_word(pdev, PCI_COMMAND, &command);\r\npci_read_config_byte(pdev, PCI_CACHE_LINE_SIZE, &cache_line_size);\r\npci_read_config_byte(pdev, PCI_LATENCY_TIMER, &latency_timer);\r\npci_read_config_dword(pdev, 0x2c, &board_id);\r\nif(!(command & 0x02)) {\r\nprintk(KERN_WARNING\r\n"cpqarray: controller appears to be disabled\n");\r\nreturn(-1);\r\n}\r\nDBGINFO(\r\nprintk("vendor_id = %x\n", vendor_id);\r\nprintk("device_id = %x\n", device_id);\r\nprintk("command = %x\n", command);\r\nfor(i=0; i<6; i++)\r\nprintk("addr[%d] = %lx\n", i, addr[i]);\r\nprintk("revision = %x\n", revision);\r\nprintk("irq = %x\n", irq);\r\nprintk("cache_line_size = %x\n", cache_line_size);\r\nprintk("latency_timer = %x\n", latency_timer);\r\nprintk("board_id = %x\n", board_id);\r\n);\r\nc->intr = irq;\r\nfor(i=0; i<6; i++) {\r\nif (pci_resource_flags(pdev, i) & PCI_BASE_ADDRESS_SPACE_IO)\r\n{\r\nc->io_mem_addr = addr[i];\r\nc->io_mem_length = pci_resource_end(pdev, i)\r\n- pci_resource_start(pdev, i) + 1;\r\nif(!request_region( c->io_mem_addr, c->io_mem_length,\r\n"cpqarray"))\r\n{\r\nprintk( KERN_WARNING "cpqarray I/O memory range already in use addr %lx length = %ld\n", c->io_mem_addr, c->io_mem_length);\r\nc->io_mem_addr = 0;\r\nc->io_mem_length = 0;\r\n}\r\nbreak;\r\n}\r\n}\r\nc->paddr = 0;\r\nfor(i=0; i<6; i++)\r\nif (!(pci_resource_flags(pdev, i) &\r\nPCI_BASE_ADDRESS_SPACE_IO)) {\r\nc->paddr = pci_resource_start (pdev, i);\r\nbreak;\r\n}\r\nif (!c->paddr)\r\nreturn -1;\r\nc->vaddr = remap_pci_mem(c->paddr, 128);\r\nif (!c->vaddr)\r\nreturn -1;\r\nc->board_id = board_id;\r\nfor(i=0; i<NR_PRODUCTS; i++) {\r\nif (board_id == products[i].board_id) {\r\nc->product_name = products[i].product_name;\r\nc->access = *(products[i].access);\r\nbreak;\r\n}\r\n}\r\nif (i == NR_PRODUCTS) {\r\nprintk(KERN_WARNING "cpqarray: Sorry, I don't know how"\r\n" to access the SMART Array controller %08lx\n",\r\n(unsigned long)board_id);\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic void __iomem *remap_pci_mem(ulong base, ulong size)\r\n{\r\nulong page_base = ((ulong) base) & PAGE_MASK;\r\nulong page_offs = ((ulong) base) - page_base;\r\nvoid __iomem *page_remapped = ioremap(page_base, page_offs+size);\r\nreturn (page_remapped ? (page_remapped + page_offs) : NULL);\r\n}\r\nstatic int cpqarray_setup(char *str)\r\n{\r\nint i, ints[9];\r\n(void)get_options(str, ARRAY_SIZE(ints), ints);\r\nfor(i=0; i<ints[0] && i<8; i++)\r\neisa[i] = ints[i+1];\r\nreturn 1;\r\n}\r\nstatic int cpqarray_eisa_detect(void)\r\n{\r\nint i=0, j;\r\n__u32 board_id;\r\nint intr;\r\nint ctlr;\r\nint num_ctlr = 0;\r\nwhile(i<8 && eisa[i]) {\r\nctlr = alloc_cpqarray_hba();\r\nif(ctlr == -1)\r\nbreak;\r\nboard_id = inl(eisa[i]+0xC80);\r\nfor(j=0; j < NR_PRODUCTS; j++)\r\nif (board_id == products[j].board_id)\r\nbreak;\r\nif (j == NR_PRODUCTS) {\r\nprintk(KERN_WARNING "cpqarray: Sorry, I don't know how"\r\n" to access the SMART Array controller %08lx\n", (unsigned long)board_id);\r\ncontinue;\r\n}\r\nmemset(hba[ctlr], 0, sizeof(ctlr_info_t));\r\nhba[ctlr]->io_mem_addr = eisa[i];\r\nhba[ctlr]->io_mem_length = 0x7FF;\r\nif(!request_region(hba[ctlr]->io_mem_addr,\r\nhba[ctlr]->io_mem_length,\r\n"cpqarray"))\r\n{\r\nprintk(KERN_WARNING "cpqarray: I/O range already in "\r\n"use addr = %lx length = %ld\n",\r\nhba[ctlr]->io_mem_addr,\r\nhba[ctlr]->io_mem_length);\r\nfree_hba(ctlr);\r\ncontinue;\r\n}\r\nintr = inb(eisa[i]+0xCC0) >> 4;\r\nif (intr & 1) intr = 11;\r\nelse if (intr & 2) intr = 10;\r\nelse if (intr & 4) intr = 14;\r\nelse if (intr & 8) intr = 15;\r\nhba[ctlr]->intr = intr;\r\nsprintf(hba[ctlr]->devname, "ida%d", nr_ctlr);\r\nhba[ctlr]->product_name = products[j].product_name;\r\nhba[ctlr]->access = *(products[j].access);\r\nhba[ctlr]->ctlr = ctlr;\r\nhba[ctlr]->board_id = board_id;\r\nhba[ctlr]->pci_dev = NULL;\r\nDBGINFO(\r\nprintk("i = %d, j = %d\n", i, j);\r\nprintk("irq = %x\n", intr);\r\nprintk("product name = %s\n", products[j].product_name);\r\nprintk("board_id = %x\n", board_id);\r\n);\r\nnum_ctlr++;\r\ni++;\r\nif (cpqarray_register_ctlr(ctlr, NULL) == -1)\r\nprintk(KERN_WARNING\r\n"cpqarray: Can't register EISA controller %d\n",\r\nctlr);\r\n}\r\nreturn num_ctlr;\r\n}\r\nstatic int ida_open(struct block_device *bdev, fmode_t mode)\r\n{\r\ndrv_info_t *drv = get_drv(bdev->bd_disk);\r\nctlr_info_t *host = get_host(bdev->bd_disk);\r\nDBGINFO(printk("ida_open %s\n", bdev->bd_disk->disk_name));\r\nif (!drv->nr_blks) {\r\nif (!capable(CAP_SYS_RAWIO))\r\nreturn -ENXIO;\r\nif (!capable(CAP_SYS_ADMIN) && drv != host->drv)\r\nreturn -ENXIO;\r\n}\r\nhost->usage_count++;\r\nreturn 0;\r\n}\r\nstatic int ida_unlocked_open(struct block_device *bdev, fmode_t mode)\r\n{\r\nint ret;\r\nmutex_lock(&cpqarray_mutex);\r\nret = ida_open(bdev, mode);\r\nmutex_unlock(&cpqarray_mutex);\r\nreturn ret;\r\n}\r\nstatic int ida_release(struct gendisk *disk, fmode_t mode)\r\n{\r\nctlr_info_t *host;\r\nmutex_lock(&cpqarray_mutex);\r\nhost = get_host(disk);\r\nhost->usage_count--;\r\nmutex_unlock(&cpqarray_mutex);\r\nreturn 0;\r\n}\r\nstatic inline void addQ(cmdlist_t **Qptr, cmdlist_t *c)\r\n{\r\nif (*Qptr == NULL) {\r\n*Qptr = c;\r\nc->next = c->prev = c;\r\n} else {\r\nc->prev = (*Qptr)->prev;\r\nc->next = (*Qptr);\r\n(*Qptr)->prev->next = c;\r\n(*Qptr)->prev = c;\r\n}\r\n}\r\nstatic inline cmdlist_t *removeQ(cmdlist_t **Qptr, cmdlist_t *c)\r\n{\r\nif (c && c->next != c) {\r\nif (*Qptr == c) *Qptr = c->next;\r\nc->prev->next = c->next;\r\nc->next->prev = c->prev;\r\n} else {\r\n*Qptr = NULL;\r\n}\r\nreturn c;\r\n}\r\nstatic void do_ida_request(struct request_queue *q)\r\n{\r\nctlr_info_t *h = q->queuedata;\r\ncmdlist_t *c;\r\nstruct request *creq;\r\nstruct scatterlist tmp_sg[SG_MAX];\r\nint i, dir, seg;\r\nqueue_next:\r\ncreq = blk_peek_request(q);\r\nif (!creq)\r\ngoto startio;\r\nBUG_ON(creq->nr_phys_segments > SG_MAX);\r\nif ((c = cmd_alloc(h,1)) == NULL)\r\ngoto startio;\r\nblk_start_request(creq);\r\nc->ctlr = h->ctlr;\r\nc->hdr.unit = (drv_info_t *)(creq->rq_disk->private_data) - h->drv;\r\nc->hdr.size = sizeof(rblk_t) >> 2;\r\nc->size += sizeof(rblk_t);\r\nc->req.hdr.blk = blk_rq_pos(creq);\r\nc->rq = creq;\r\nDBGPX(\r\nprintk("sector=%d, nr_sectors=%u\n",\r\nblk_rq_pos(creq), blk_rq_sectors(creq));\r\n);\r\nsg_init_table(tmp_sg, SG_MAX);\r\nseg = blk_rq_map_sg(q, creq, tmp_sg);\r\nif (rq_data_dir(creq) == READ)\r\ndir = PCI_DMA_FROMDEVICE;\r\nelse\r\ndir = PCI_DMA_TODEVICE;\r\nfor( i=0; i < seg; i++)\r\n{\r\nc->req.sg[i].size = tmp_sg[i].length;\r\nc->req.sg[i].addr = (__u32) pci_map_page(h->pci_dev,\r\nsg_page(&tmp_sg[i]),\r\ntmp_sg[i].offset,\r\ntmp_sg[i].length, dir);\r\n}\r\nDBGPX( printk("Submitting %u sectors in %d segments\n", blk_rq_sectors(creq), seg); );\r\nc->req.hdr.sg_cnt = seg;\r\nc->req.hdr.blk_cnt = blk_rq_sectors(creq);\r\nc->req.hdr.cmd = (rq_data_dir(creq) == READ) ? IDA_READ : IDA_WRITE;\r\nc->type = CMD_RWREQ;\r\naddQ(&h->reqQ, c);\r\nh->Qdepth++;\r\nif (h->Qdepth > h->maxQsinceinit)\r\nh->maxQsinceinit = h->Qdepth;\r\ngoto queue_next;\r\nstartio:\r\nstart_io(h);\r\n}\r\nstatic void start_io(ctlr_info_t *h)\r\n{\r\ncmdlist_t *c;\r\nwhile((c = h->reqQ) != NULL) {\r\nif (h->access.fifo_full(h) == 0)\r\nreturn;\r\nremoveQ(&h->reqQ, c);\r\nh->Qdepth--;\r\nh->access.submit_command(h, c);\r\naddQ(&h->cmpQ, c);\r\n}\r\n}\r\nstatic inline void complete_command(cmdlist_t *cmd, int timeout)\r\n{\r\nstruct request *rq = cmd->rq;\r\nint error = 0;\r\nint i, ddir;\r\nif (cmd->req.hdr.rcode & RCODE_NONFATAL &&\r\n(hba[cmd->ctlr]->misc_tflags & MISC_NONFATAL_WARN) == 0) {\r\nprintk(KERN_NOTICE "Non Fatal error on ida/c%dd%d\n",\r\ncmd->ctlr, cmd->hdr.unit);\r\nhba[cmd->ctlr]->misc_tflags |= MISC_NONFATAL_WARN;\r\n}\r\nif (cmd->req.hdr.rcode & RCODE_FATAL) {\r\nprintk(KERN_WARNING "Fatal error on ida/c%dd%d\n",\r\ncmd->ctlr, cmd->hdr.unit);\r\nerror = -EIO;\r\n}\r\nif (cmd->req.hdr.rcode & RCODE_INVREQ) {\r\nprintk(KERN_WARNING "Invalid request on ida/c%dd%d = (cmd=%x sect=%d cnt=%d sg=%d ret=%x)\n",\r\ncmd->ctlr, cmd->hdr.unit, cmd->req.hdr.cmd,\r\ncmd->req.hdr.blk, cmd->req.hdr.blk_cnt,\r\ncmd->req.hdr.sg_cnt, cmd->req.hdr.rcode);\r\nerror = -EIO;\r\n}\r\nif (timeout)\r\nerror = -EIO;\r\nif (cmd->req.hdr.cmd == IDA_READ)\r\nddir = PCI_DMA_FROMDEVICE;\r\nelse\r\nddir = PCI_DMA_TODEVICE;\r\nfor(i=0; i<cmd->req.hdr.sg_cnt; i++)\r\npci_unmap_page(hba[cmd->ctlr]->pci_dev, cmd->req.sg[i].addr,\r\ncmd->req.sg[i].size, ddir);\r\nDBGPX(printk("Done with %p\n", rq););\r\n__blk_end_request_all(rq, error);\r\n}\r\nstatic irqreturn_t do_ida_intr(int irq, void *dev_id)\r\n{\r\nctlr_info_t *h = dev_id;\r\ncmdlist_t *c;\r\nunsigned long istat;\r\nunsigned long flags;\r\n__u32 a,a1;\r\nistat = h->access.intr_pending(h);\r\nif (istat == 0)\r\nreturn IRQ_NONE;\r\nspin_lock_irqsave(IDA_LOCK(h->ctlr), flags);\r\nif (istat & FIFO_NOT_EMPTY) {\r\nwhile((a = h->access.command_completed(h))) {\r\na1 = a; a &= ~3;\r\nif ((c = h->cmpQ) == NULL)\r\n{\r\nprintk(KERN_WARNING "cpqarray: Completion of %08lx ignored\n", (unsigned long)a1);\r\ncontinue;\r\n}\r\nwhile(c->busaddr != a) {\r\nc = c->next;\r\nif (c == h->cmpQ)\r\nbreak;\r\n}\r\nif (c->busaddr == a) {\r\nremoveQ(&h->cmpQ, c);\r\nif((a1 & 0x03) && (c->req.hdr.rcode == 0))\r\n{\r\nc->req.hdr.rcode = RCODE_INVREQ;\r\n}\r\nif (c->type == CMD_RWREQ) {\r\ncomplete_command(c, 0);\r\ncmd_free(h, c, 1);\r\n} else if (c->type == CMD_IOCTL_PEND) {\r\nc->type = CMD_IOCTL_DONE;\r\n}\r\ncontinue;\r\n}\r\n}\r\n}\r\ndo_ida_request(h->queue);\r\nspin_unlock_irqrestore(IDA_LOCK(h->ctlr), flags);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void ida_timer(unsigned long tdata)\r\n{\r\nctlr_info_t *h = (ctlr_info_t*)tdata;\r\nh->timer.expires = jiffies + IDA_TIMER;\r\nadd_timer(&h->timer);\r\nh->misc_tflags = 0;\r\n}\r\nstatic int ida_getgeo(struct block_device *bdev, struct hd_geometry *geo)\r\n{\r\ndrv_info_t *drv = get_drv(bdev->bd_disk);\r\nif (drv->cylinders) {\r\ngeo->heads = drv->heads;\r\ngeo->sectors = drv->sectors;\r\ngeo->cylinders = drv->cylinders;\r\n} else {\r\ngeo->heads = 0xff;\r\ngeo->sectors = 0x3f;\r\ngeo->cylinders = drv->nr_blks / (0xff*0x3f);\r\n}\r\nreturn 0;\r\n}\r\nstatic int ida_locked_ioctl(struct block_device *bdev, fmode_t mode, unsigned int cmd, unsigned long arg)\r\n{\r\ndrv_info_t *drv = get_drv(bdev->bd_disk);\r\nctlr_info_t *host = get_host(bdev->bd_disk);\r\nint error;\r\nida_ioctl_t __user *io = (ida_ioctl_t __user *)arg;\r\nida_ioctl_t *my_io;\r\nswitch(cmd) {\r\ncase IDAGETDRVINFO:\r\nif (copy_to_user(&io->c.drv, drv, sizeof(drv_info_t)))\r\nreturn -EFAULT;\r\nreturn 0;\r\ncase IDAPASSTHRU:\r\nif (!capable(CAP_SYS_RAWIO))\r\nreturn -EPERM;\r\nmy_io = kmalloc(sizeof(ida_ioctl_t), GFP_KERNEL);\r\nif (!my_io)\r\nreturn -ENOMEM;\r\nerror = -EFAULT;\r\nif (copy_from_user(my_io, io, sizeof(*my_io)))\r\ngoto out_passthru;\r\nerror = ida_ctlr_ioctl(host, drv - host->drv, my_io);\r\nif (error)\r\ngoto out_passthru;\r\nerror = -EFAULT;\r\nif (copy_to_user(io, my_io, sizeof(*my_io)))\r\ngoto out_passthru;\r\nerror = 0;\r\nout_passthru:\r\nkfree(my_io);\r\nreturn error;\r\ncase IDAGETCTLRSIG:\r\nif (!arg) return -EINVAL;\r\nif (put_user(host->ctlr_sig, (int __user *)arg))\r\nreturn -EFAULT;\r\nreturn 0;\r\ncase IDAREVALIDATEVOLS:\r\nif (MINOR(bdev->bd_dev) != 0)\r\nreturn -ENXIO;\r\nreturn revalidate_allvol(host);\r\ncase IDADRIVERVERSION:\r\nif (!arg) return -EINVAL;\r\nif (put_user(DRIVER_VERSION, (unsigned long __user *)arg))\r\nreturn -EFAULT;\r\nreturn 0;\r\ncase IDAGETPCIINFO:\r\n{\r\nida_pci_info_struct pciinfo;\r\nif (!arg) return -EINVAL;\r\npciinfo.bus = host->pci_dev->bus->number;\r\npciinfo.dev_fn = host->pci_dev->devfn;\r\npciinfo.board_id = host->board_id;\r\nif(copy_to_user((void __user *) arg, &pciinfo,\r\nsizeof( ida_pci_info_struct)))\r\nreturn -EFAULT;\r\nreturn(0);\r\n}\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic int ida_ioctl(struct block_device *bdev, fmode_t mode,\r\nunsigned int cmd, unsigned long param)\r\n{\r\nint ret;\r\nmutex_lock(&cpqarray_mutex);\r\nret = ida_locked_ioctl(bdev, mode, cmd, param);\r\nmutex_unlock(&cpqarray_mutex);\r\nreturn ret;\r\n}\r\nstatic int ida_ctlr_ioctl(ctlr_info_t *h, int dsk, ida_ioctl_t *io)\r\n{\r\nint ctlr = h->ctlr;\r\ncmdlist_t *c;\r\nvoid *p = NULL;\r\nunsigned long flags;\r\nint error;\r\nif ((c = cmd_alloc(h, 0)) == NULL)\r\nreturn -ENOMEM;\r\nc->ctlr = ctlr;\r\nc->hdr.unit = (io->unit & UNITVALID) ? (io->unit & ~UNITVALID) : dsk;\r\nc->hdr.size = sizeof(rblk_t) >> 2;\r\nc->size += sizeof(rblk_t);\r\nc->req.hdr.cmd = io->cmd;\r\nc->req.hdr.blk = io->blk;\r\nc->req.hdr.blk_cnt = io->blk_cnt;\r\nc->type = CMD_IOCTL_PEND;\r\nswitch(io->cmd) {\r\ncase PASSTHRU_A:\r\np = memdup_user(io->sg[0].addr, io->sg[0].size);\r\nif (IS_ERR(p)) {\r\nerror = PTR_ERR(p);\r\ncmd_free(h, c, 0);\r\nreturn error;\r\n}\r\nc->req.hdr.blk = pci_map_single(h->pci_dev, &(io->c),\r\nsizeof(ida_ioctl_t),\r\nPCI_DMA_BIDIRECTIONAL);\r\nc->req.sg[0].size = io->sg[0].size;\r\nc->req.sg[0].addr = pci_map_single(h->pci_dev, p,\r\nc->req.sg[0].size, PCI_DMA_BIDIRECTIONAL);\r\nc->req.hdr.sg_cnt = 1;\r\nbreak;\r\ncase IDA_READ:\r\ncase READ_FLASH_ROM:\r\ncase SENSE_CONTROLLER_PERFORMANCE:\r\np = kmalloc(io->sg[0].size, GFP_KERNEL);\r\nif (!p)\r\n{\r\nerror = -ENOMEM;\r\ncmd_free(h, c, 0);\r\nreturn(error);\r\n}\r\nc->req.sg[0].size = io->sg[0].size;\r\nc->req.sg[0].addr = pci_map_single(h->pci_dev, p,\r\nc->req.sg[0].size, PCI_DMA_BIDIRECTIONAL);\r\nc->req.hdr.sg_cnt = 1;\r\nbreak;\r\ncase IDA_WRITE:\r\ncase IDA_WRITE_MEDIA:\r\ncase DIAG_PASS_THRU:\r\ncase COLLECT_BUFFER:\r\ncase WRITE_FLASH_ROM:\r\np = memdup_user(io->sg[0].addr, io->sg[0].size);\r\nif (IS_ERR(p)) {\r\nerror = PTR_ERR(p);\r\ncmd_free(h, c, 0);\r\nreturn error;\r\n}\r\nc->req.sg[0].size = io->sg[0].size;\r\nc->req.sg[0].addr = pci_map_single(h->pci_dev, p,\r\nc->req.sg[0].size, PCI_DMA_BIDIRECTIONAL);\r\nc->req.hdr.sg_cnt = 1;\r\nbreak;\r\ndefault:\r\nc->req.sg[0].size = sizeof(io->c);\r\nc->req.sg[0].addr = pci_map_single(h->pci_dev,&io->c,\r\nc->req.sg[0].size, PCI_DMA_BIDIRECTIONAL);\r\nc->req.hdr.sg_cnt = 1;\r\n}\r\nspin_lock_irqsave(IDA_LOCK(ctlr), flags);\r\naddQ(&h->reqQ, c);\r\nh->Qdepth++;\r\nstart_io(h);\r\nspin_unlock_irqrestore(IDA_LOCK(ctlr), flags);\r\nwhile(c->type != CMD_IOCTL_DONE)\r\nschedule();\r\npci_unmap_single(h->pci_dev, c->req.sg[0].addr, c->req.sg[0].size,\r\nPCI_DMA_BIDIRECTIONAL);\r\nswitch(io->cmd) {\r\ncase PASSTHRU_A:\r\npci_unmap_single(h->pci_dev, c->req.hdr.blk,\r\nsizeof(ida_ioctl_t),\r\nPCI_DMA_BIDIRECTIONAL);\r\ncase IDA_READ:\r\ncase DIAG_PASS_THRU:\r\ncase SENSE_CONTROLLER_PERFORMANCE:\r\ncase READ_FLASH_ROM:\r\nif (copy_to_user(io->sg[0].addr, p, io->sg[0].size)) {\r\nkfree(p);\r\nreturn -EFAULT;\r\n}\r\ncase IDA_WRITE:\r\ncase IDA_WRITE_MEDIA:\r\ncase COLLECT_BUFFER:\r\ncase WRITE_FLASH_ROM:\r\nkfree(p);\r\nbreak;\r\ndefault:;\r\n}\r\nio->rcode = c->req.hdr.rcode;\r\ncmd_free(h, c, 0);\r\nreturn(0);\r\n}\r\nstatic cmdlist_t * cmd_alloc(ctlr_info_t *h, int get_from_pool)\r\n{\r\ncmdlist_t * c;\r\nint i;\r\ndma_addr_t cmd_dhandle;\r\nif (!get_from_pool) {\r\nc = (cmdlist_t*)pci_alloc_consistent(h->pci_dev,\r\nsizeof(cmdlist_t), &cmd_dhandle);\r\nif(c==NULL)\r\nreturn NULL;\r\n} else {\r\ndo {\r\ni = find_first_zero_bit(h->cmd_pool_bits, NR_CMDS);\r\nif (i == NR_CMDS)\r\nreturn NULL;\r\n} while(test_and_set_bit(i&(BITS_PER_LONG-1), h->cmd_pool_bits+(i/BITS_PER_LONG)) != 0);\r\nc = h->cmd_pool + i;\r\ncmd_dhandle = h->cmd_pool_dhandle + i*sizeof(cmdlist_t);\r\nh->nr_allocs++;\r\n}\r\nmemset(c, 0, sizeof(cmdlist_t));\r\nc->busaddr = cmd_dhandle;\r\nreturn c;\r\n}\r\nstatic void cmd_free(ctlr_info_t *h, cmdlist_t *c, int got_from_pool)\r\n{\r\nint i;\r\nif (!got_from_pool) {\r\npci_free_consistent(h->pci_dev, sizeof(cmdlist_t), c,\r\nc->busaddr);\r\n} else {\r\ni = c - h->cmd_pool;\r\nclear_bit(i&(BITS_PER_LONG-1), h->cmd_pool_bits+(i/BITS_PER_LONG));\r\nh->nr_frees++;\r\n}\r\n}\r\nstatic int sendcmd(\r\n__u8 cmd,\r\nint ctlr,\r\nvoid *buff,\r\nsize_t size,\r\nunsigned int blk,\r\nunsigned int blkcnt,\r\nunsigned int log_unit )\r\n{\r\ncmdlist_t *c;\r\nint complete;\r\nunsigned long temp;\r\nunsigned long i;\r\nctlr_info_t *info_p = hba[ctlr];\r\nc = cmd_alloc(info_p, 1);\r\nif(!c)\r\nreturn IO_ERROR;\r\nc->ctlr = ctlr;\r\nc->hdr.unit = log_unit;\r\nc->hdr.prio = 0;\r\nc->hdr.size = sizeof(rblk_t) >> 2;\r\nc->size += sizeof(rblk_t);\r\nc->req.hdr.next = 0;\r\nc->req.hdr.rcode = 0;\r\nc->req.bp = 0;\r\nc->req.hdr.sg_cnt = 1;\r\nc->req.hdr.reserved = 0;\r\nif (size == 0)\r\nc->req.sg[0].size = 512;\r\nelse\r\nc->req.sg[0].size = size;\r\nc->req.hdr.blk = blk;\r\nc->req.hdr.blk_cnt = blkcnt;\r\nc->req.hdr.cmd = (unsigned char) cmd;\r\nc->req.sg[0].addr = (__u32) pci_map_single(info_p->pci_dev,\r\nbuff, c->req.sg[0].size, PCI_DMA_BIDIRECTIONAL);\r\ninfo_p->access.set_intr_mask(info_p, 0);\r\nfor (i = 200000; i > 0; i--) {\r\ntemp = info_p->access.fifo_full(info_p);\r\nif (temp != 0) {\r\nbreak;\r\n}\r\nudelay(10);\r\nDBG(\r\nprintk(KERN_WARNING "cpqarray ida%d: idaSendPciCmd FIFO full,"\r\n" waiting!\n", ctlr);\r\n);\r\n}\r\ninfo_p->access.submit_command(info_p, c);\r\ncomplete = pollcomplete(ctlr);\r\npci_unmap_single(info_p->pci_dev, (dma_addr_t) c->req.sg[0].addr,\r\nc->req.sg[0].size, PCI_DMA_BIDIRECTIONAL);\r\nif (complete != 1) {\r\nif (complete != c->busaddr) {\r\nprintk( KERN_WARNING\r\n"cpqarray ida%d: idaSendPciCmd "\r\n"Invalid command list address returned! (%08lx)\n",\r\nctlr, (unsigned long)complete);\r\ncmd_free(info_p, c, 1);\r\nreturn (IO_ERROR);\r\n}\r\n} else {\r\nprintk( KERN_WARNING\r\n"cpqarray ida%d: idaSendPciCmd Timeout out, "\r\n"No command list address returned!\n",\r\nctlr);\r\ncmd_free(info_p, c, 1);\r\nreturn (IO_ERROR);\r\n}\r\nif (c->req.hdr.rcode & 0x00FE) {\r\nif (!(c->req.hdr.rcode & BIG_PROBLEM)) {\r\nprintk( KERN_WARNING\r\n"cpqarray ida%d: idaSendPciCmd, error: "\r\n"Controller failed at init time "\r\n"cmd: 0x%x, return code = 0x%x\n",\r\nctlr, c->req.hdr.cmd, c->req.hdr.rcode);\r\ncmd_free(info_p, c, 1);\r\nreturn (IO_ERROR);\r\n}\r\n}\r\ncmd_free(info_p, c, 1);\r\nreturn (IO_OK);\r\n}\r\nstatic int revalidate_allvol(ctlr_info_t *host)\r\n{\r\nint ctlr = host->ctlr;\r\nint i;\r\nunsigned long flags;\r\nspin_lock_irqsave(IDA_LOCK(ctlr), flags);\r\nif (host->usage_count > 1) {\r\nspin_unlock_irqrestore(IDA_LOCK(ctlr), flags);\r\nprintk(KERN_WARNING "cpqarray: Device busy for volume"\r\n" revalidation (usage=%d)\n", host->usage_count);\r\nreturn -EBUSY;\r\n}\r\nhost->usage_count++;\r\nspin_unlock_irqrestore(IDA_LOCK(ctlr), flags);\r\nset_capacity(ida_gendisk[ctlr][0], 0);\r\nfor (i = 1; i < NWD; i++) {\r\nstruct gendisk *disk = ida_gendisk[ctlr][i];\r\nif (disk->flags & GENHD_FL_UP)\r\ndel_gendisk(disk);\r\n}\r\nmemset(host->drv, 0, sizeof(drv_info_t)*NWD);\r\nhost->access.set_intr_mask(host, 0);\r\ngetgeometry(ctlr);\r\nhost->access.set_intr_mask(host, FIFO_NOT_EMPTY);\r\nfor(i=0; i<NWD; i++) {\r\nstruct gendisk *disk = ida_gendisk[ctlr][i];\r\ndrv_info_t *drv = &host->drv[i];\r\nif (i && !drv->nr_blks)\r\ncontinue;\r\nblk_queue_logical_block_size(host->queue, drv->blk_size);\r\nset_capacity(disk, drv->nr_blks);\r\ndisk->queue = host->queue;\r\ndisk->private_data = drv;\r\nif (i)\r\nadd_disk(disk);\r\n}\r\nhost->usage_count--;\r\nreturn 0;\r\n}\r\nstatic int ida_revalidate(struct gendisk *disk)\r\n{\r\ndrv_info_t *drv = disk->private_data;\r\nset_capacity(disk, drv->nr_blks);\r\nreturn 0;\r\n}\r\nstatic int pollcomplete(int ctlr)\r\n{\r\nint done;\r\nint i;\r\nfor (i = 200000; i > 0; i--) {\r\ndone = hba[ctlr]->access.command_completed(hba[ctlr]);\r\nif (done == 0) {\r\nudelay(10);\r\n} else\r\nreturn (done);\r\n}\r\nreturn 1;\r\n}\r\nstatic void start_fwbk(int ctlr)\r\n{\r\nid_ctlr_t *id_ctlr_buf;\r\nint ret_code;\r\nif( (hba[ctlr]->board_id != 0x40400E11)\r\n&& (hba[ctlr]->board_id != 0x40480E11) )\r\nreturn;\r\nprintk(KERN_DEBUG "cpqarray: Starting firmware's background"\r\n" processing\n");\r\nid_ctlr_buf = kmalloc(sizeof(id_ctlr_t), GFP_KERNEL);\r\nif(id_ctlr_buf==NULL)\r\n{\r\nprintk(KERN_WARNING "cpqarray: Out of memory. "\r\n"Unable to start background processing.\n");\r\nreturn;\r\n}\r\nret_code = sendcmd(RESUME_BACKGROUND_ACTIVITY, ctlr,\r\nid_ctlr_buf, 0, 0, 0, 0);\r\nif(ret_code != IO_OK)\r\nprintk(KERN_WARNING "cpqarray: Unable to start"\r\n" background processing\n");\r\nkfree(id_ctlr_buf);\r\n}\r\nstatic void getgeometry(int ctlr)\r\n{\r\nid_log_drv_t *id_ldrive;\r\nid_ctlr_t *id_ctlr_buf;\r\nsense_log_drv_stat_t *id_lstatus_buf;\r\nconfig_t *sense_config_buf;\r\nunsigned int log_unit, log_index;\r\nint ret_code, size;\r\ndrv_info_t *drv;\r\nctlr_info_t *info_p = hba[ctlr];\r\nint i;\r\ninfo_p->log_drv_map = 0;\r\nid_ldrive = kzalloc(sizeof(id_log_drv_t), GFP_KERNEL);\r\nif (!id_ldrive) {\r\nprintk( KERN_ERR "cpqarray: out of memory.\n");\r\ngoto err_0;\r\n}\r\nid_ctlr_buf = kzalloc(sizeof(id_ctlr_t), GFP_KERNEL);\r\nif (!id_ctlr_buf) {\r\nprintk( KERN_ERR "cpqarray: out of memory.\n");\r\ngoto err_1;\r\n}\r\nid_lstatus_buf = kzalloc(sizeof(sense_log_drv_stat_t), GFP_KERNEL);\r\nif (!id_lstatus_buf) {\r\nprintk( KERN_ERR "cpqarray: out of memory.\n");\r\ngoto err_2;\r\n}\r\nsense_config_buf = kzalloc(sizeof(config_t), GFP_KERNEL);\r\nif (!sense_config_buf) {\r\nprintk( KERN_ERR "cpqarray: out of memory.\n");\r\ngoto err_3;\r\n}\r\ninfo_p->phys_drives = 0;\r\ninfo_p->log_drv_map = 0;\r\ninfo_p->drv_assign_map = 0;\r\ninfo_p->drv_spare_map = 0;\r\ninfo_p->mp_failed_drv_map = 0;\r\nret_code = sendcmd(ID_CTLR, ctlr, id_ctlr_buf, 0, 0, 0, 0);\r\nif (ret_code == IO_ERROR) {\r\nprintk(KERN_ERR "cpqarray: error sending ID controller\n");\r\ngoto err_4;\r\n}\r\ninfo_p->log_drives = id_ctlr_buf->nr_drvs;\r\nfor(i=0;i<4;i++)\r\ninfo_p->firm_rev[i] = id_ctlr_buf->firm_rev[i];\r\ninfo_p->ctlr_sig = id_ctlr_buf->cfg_sig;\r\nprintk(" (%s)\n", info_p->product_name);\r\nlog_index = 0;\r\nif (id_ctlr_buf->nr_drvs > 16)\r\nprintk(KERN_WARNING "cpqarray ida%d: This driver supports "\r\n"16 logical drives per controller.\n. "\r\n" Additional drives will not be "\r\n"detected\n", ctlr);\r\nfor (log_unit = 0;\r\n(log_index < id_ctlr_buf->nr_drvs)\r\n&& (log_unit < NWD);\r\nlog_unit++) {\r\nsize = sizeof(sense_log_drv_stat_t);\r\nret_code = sendcmd(SENSE_LOG_DRV_STAT,\r\nctlr, id_lstatus_buf, size, 0, 0, log_unit);\r\nif (ret_code == IO_ERROR) {\r\ninfo_p->log_drv_map = 0;\r\nprintk( KERN_WARNING\r\n"cpqarray ida%d: idaGetGeometry - Controller"\r\n" failed to report status of logical drive %d\n"\r\n"Access to this controller has been disabled\n",\r\nctlr, log_unit);\r\ngoto err_4;\r\n}\r\nif (id_lstatus_buf->status != LOG_NOT_CONF) {\r\nret_code = sendcmd(ID_LOG_DRV, ctlr, id_ldrive,\r\nsizeof(id_log_drv_t), 0, 0, log_unit);\r\nif (ret_code != IO_ERROR) {\r\ndrv = &info_p->drv[log_unit];\r\ndrv->blk_size = id_ldrive->blk_size;\r\ndrv->nr_blks = id_ldrive->nr_blks;\r\ndrv->cylinders = id_ldrive->drv.cyl;\r\ndrv->heads = id_ldrive->drv.heads;\r\ndrv->sectors = id_ldrive->drv.sect_per_track;\r\ninfo_p->log_drv_map |= (1 << log_unit);\r\nprintk(KERN_INFO "cpqarray ida/c%dd%d: blksz=%d nr_blks=%d\n",\r\nctlr, log_unit, drv->blk_size, drv->nr_blks);\r\nret_code = sendcmd(SENSE_CONFIG,\r\nctlr, sense_config_buf,\r\nsizeof(config_t), 0, 0, log_unit);\r\nif (ret_code == IO_ERROR) {\r\ninfo_p->log_drv_map = 0;\r\nprintk(KERN_ERR "cpqarray: error sending sense config\n");\r\ngoto err_4;\r\n}\r\ninfo_p->phys_drives =\r\nsense_config_buf->ctlr_phys_drv;\r\ninfo_p->drv_assign_map\r\n|= sense_config_buf->drv_asgn_map;\r\ninfo_p->drv_assign_map\r\n|= sense_config_buf->spare_asgn_map;\r\ninfo_p->drv_spare_map\r\n|= sense_config_buf->spare_asgn_map;\r\n}\r\nlog_index = log_index + 1;\r\n}\r\n}\r\nerr_4:\r\nkfree(sense_config_buf);\r\nerr_3:\r\nkfree(id_lstatus_buf);\r\nerr_2:\r\nkfree(id_ctlr_buf);\r\nerr_1:\r\nkfree(id_ldrive);\r\nerr_0:\r\nreturn;\r\n}\r\nstatic void __exit cpqarray_exit(void)\r\n{\r\nint i;\r\npci_unregister_driver(&cpqarray_pci_driver);\r\nfor(i=0; i<MAX_CTLR; i++) {\r\nif (hba[i] != NULL) {\r\nprintk(KERN_WARNING "cpqarray: Removing EISA "\r\n"controller %d\n", i);\r\ncpqarray_remove_one_eisa(i);\r\n}\r\n}\r\nremove_proc_entry("driver/cpqarray", NULL);\r\n}
