static int find_name_in_backref(struct btrfs_path *path, const char *name,\r\nint name_len, struct btrfs_inode_ref **ref_ret)\r\n{\r\nstruct extent_buffer *leaf;\r\nstruct btrfs_inode_ref *ref;\r\nunsigned long ptr;\r\nunsigned long name_ptr;\r\nu32 item_size;\r\nu32 cur_offset = 0;\r\nint len;\r\nleaf = path->nodes[0];\r\nitem_size = btrfs_item_size_nr(leaf, path->slots[0]);\r\nptr = btrfs_item_ptr_offset(leaf, path->slots[0]);\r\nwhile (cur_offset < item_size) {\r\nref = (struct btrfs_inode_ref *)(ptr + cur_offset);\r\nlen = btrfs_inode_ref_name_len(leaf, ref);\r\nname_ptr = (unsigned long)(ref + 1);\r\ncur_offset += len + sizeof(*ref);\r\nif (len != name_len)\r\ncontinue;\r\nif (memcmp_extent_buffer(leaf, name, name_ptr, name_len) == 0) {\r\n*ref_ret = ref;\r\nreturn 1;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nint btrfs_find_name_in_ext_backref(struct btrfs_path *path, u64 ref_objectid,\r\nconst char *name, int name_len,\r\nstruct btrfs_inode_extref **extref_ret)\r\n{\r\nstruct extent_buffer *leaf;\r\nstruct btrfs_inode_extref *extref;\r\nunsigned long ptr;\r\nunsigned long name_ptr;\r\nu32 item_size;\r\nu32 cur_offset = 0;\r\nint ref_name_len;\r\nleaf = path->nodes[0];\r\nitem_size = btrfs_item_size_nr(leaf, path->slots[0]);\r\nptr = btrfs_item_ptr_offset(leaf, path->slots[0]);\r\nwhile (cur_offset < item_size) {\r\nextref = (struct btrfs_inode_extref *) (ptr + cur_offset);\r\nname_ptr = (unsigned long)(&extref->name);\r\nref_name_len = btrfs_inode_extref_name_len(leaf, extref);\r\nif (ref_name_len == name_len &&\r\nbtrfs_inode_extref_parent(leaf, extref) == ref_objectid &&\r\n(memcmp_extent_buffer(leaf, name, name_ptr, name_len) == 0)) {\r\nif (extref_ret)\r\n*extref_ret = extref;\r\nreturn 1;\r\n}\r\ncur_offset += ref_name_len + sizeof(*extref);\r\n}\r\nreturn 0;\r\n}\r\nstatic struct btrfs_inode_ref *\r\nbtrfs_lookup_inode_ref(struct btrfs_trans_handle *trans,\r\nstruct btrfs_root *root,\r\nstruct btrfs_path *path,\r\nconst char *name, int name_len,\r\nu64 inode_objectid, u64 ref_objectid, int ins_len,\r\nint cow)\r\n{\r\nint ret;\r\nstruct btrfs_key key;\r\nstruct btrfs_inode_ref *ref;\r\nkey.objectid = inode_objectid;\r\nkey.type = BTRFS_INODE_REF_KEY;\r\nkey.offset = ref_objectid;\r\nret = btrfs_search_slot(trans, root, &key, path, ins_len, cow);\r\nif (ret < 0)\r\nreturn ERR_PTR(ret);\r\nif (ret > 0)\r\nreturn NULL;\r\nif (!find_name_in_backref(path, name, name_len, &ref))\r\nreturn NULL;\r\nreturn ref;\r\n}\r\nstruct btrfs_inode_extref *\r\nbtrfs_lookup_inode_extref(struct btrfs_trans_handle *trans,\r\nstruct btrfs_root *root,\r\nstruct btrfs_path *path,\r\nconst char *name, int name_len,\r\nu64 inode_objectid, u64 ref_objectid, int ins_len,\r\nint cow)\r\n{\r\nint ret;\r\nstruct btrfs_key key;\r\nstruct btrfs_inode_extref *extref;\r\nkey.objectid = inode_objectid;\r\nkey.type = BTRFS_INODE_EXTREF_KEY;\r\nkey.offset = btrfs_extref_hash(ref_objectid, name, name_len);\r\nret = btrfs_search_slot(trans, root, &key, path, ins_len, cow);\r\nif (ret < 0)\r\nreturn ERR_PTR(ret);\r\nif (ret > 0)\r\nreturn NULL;\r\nif (!btrfs_find_name_in_ext_backref(path, ref_objectid, name, name_len, &extref))\r\nreturn NULL;\r\nreturn extref;\r\n}\r\nint btrfs_get_inode_ref_index(struct btrfs_trans_handle *trans,\r\nstruct btrfs_root *root,\r\nstruct btrfs_path *path,\r\nconst char *name, int name_len,\r\nu64 inode_objectid, u64 ref_objectid, int mod,\r\nu64 *ret_index)\r\n{\r\nstruct btrfs_inode_ref *ref;\r\nstruct btrfs_inode_extref *extref;\r\nint ins_len = mod < 0 ? -1 : 0;\r\nint cow = mod != 0;\r\nref = btrfs_lookup_inode_ref(trans, root, path, name, name_len,\r\ninode_objectid, ref_objectid, ins_len,\r\ncow);\r\nif (IS_ERR(ref))\r\nreturn PTR_ERR(ref);\r\nif (ref != NULL) {\r\n*ret_index = btrfs_inode_ref_index(path->nodes[0], ref);\r\nreturn 0;\r\n}\r\nbtrfs_release_path(path);\r\nextref = btrfs_lookup_inode_extref(trans, root, path, name,\r\nname_len, inode_objectid,\r\nref_objectid, ins_len, cow);\r\nif (IS_ERR(extref))\r\nreturn PTR_ERR(extref);\r\nif (extref) {\r\n*ret_index = btrfs_inode_extref_index(path->nodes[0], extref);\r\nreturn 0;\r\n}\r\nreturn -ENOENT;\r\n}\r\nint btrfs_del_inode_extref(struct btrfs_trans_handle *trans,\r\nstruct btrfs_root *root,\r\nconst char *name, int name_len,\r\nu64 inode_objectid, u64 ref_objectid, u64 *index)\r\n{\r\nstruct btrfs_path *path;\r\nstruct btrfs_key key;\r\nstruct btrfs_inode_extref *extref;\r\nstruct extent_buffer *leaf;\r\nint ret;\r\nint del_len = name_len + sizeof(*extref);\r\nunsigned long ptr;\r\nunsigned long item_start;\r\nu32 item_size;\r\nkey.objectid = inode_objectid;\r\nbtrfs_set_key_type(&key, BTRFS_INODE_EXTREF_KEY);\r\nkey.offset = btrfs_extref_hash(ref_objectid, name, name_len);\r\npath = btrfs_alloc_path();\r\nif (!path)\r\nreturn -ENOMEM;\r\npath->leave_spinning = 1;\r\nret = btrfs_search_slot(trans, root, &key, path, -1, 1);\r\nif (ret > 0)\r\nret = -ENOENT;\r\nif (ret < 0)\r\ngoto out;\r\nif (!btrfs_find_name_in_ext_backref(path, ref_objectid,\r\nname, name_len, &extref)) {\r\nbtrfs_std_error(root->fs_info, -ENOENT);\r\nret = -EROFS;\r\ngoto out;\r\n}\r\nleaf = path->nodes[0];\r\nitem_size = btrfs_item_size_nr(leaf, path->slots[0]);\r\nif (index)\r\n*index = btrfs_inode_extref_index(leaf, extref);\r\nif (del_len == item_size) {\r\nret = btrfs_del_item(trans, root, path);\r\ngoto out;\r\n}\r\nptr = (unsigned long)extref;\r\nitem_start = btrfs_item_ptr_offset(leaf, path->slots[0]);\r\nmemmove_extent_buffer(leaf, ptr, ptr + del_len,\r\nitem_size - (ptr + del_len - item_start));\r\nbtrfs_truncate_item(trans, root, path, item_size - del_len, 1);\r\nout:\r\nbtrfs_free_path(path);\r\nreturn ret;\r\n}\r\nint btrfs_del_inode_ref(struct btrfs_trans_handle *trans,\r\nstruct btrfs_root *root,\r\nconst char *name, int name_len,\r\nu64 inode_objectid, u64 ref_objectid, u64 *index)\r\n{\r\nstruct btrfs_path *path;\r\nstruct btrfs_key key;\r\nstruct btrfs_inode_ref *ref;\r\nstruct extent_buffer *leaf;\r\nunsigned long ptr;\r\nunsigned long item_start;\r\nu32 item_size;\r\nu32 sub_item_len;\r\nint ret;\r\nint search_ext_refs = 0;\r\nint del_len = name_len + sizeof(*ref);\r\nkey.objectid = inode_objectid;\r\nkey.offset = ref_objectid;\r\nbtrfs_set_key_type(&key, BTRFS_INODE_REF_KEY);\r\npath = btrfs_alloc_path();\r\nif (!path)\r\nreturn -ENOMEM;\r\npath->leave_spinning = 1;\r\nret = btrfs_search_slot(trans, root, &key, path, -1, 1);\r\nif (ret > 0) {\r\nret = -ENOENT;\r\nsearch_ext_refs = 1;\r\ngoto out;\r\n} else if (ret < 0) {\r\ngoto out;\r\n}\r\nif (!find_name_in_backref(path, name, name_len, &ref)) {\r\nret = -ENOENT;\r\nsearch_ext_refs = 1;\r\ngoto out;\r\n}\r\nleaf = path->nodes[0];\r\nitem_size = btrfs_item_size_nr(leaf, path->slots[0]);\r\nif (index)\r\n*index = btrfs_inode_ref_index(leaf, ref);\r\nif (del_len == item_size) {\r\nret = btrfs_del_item(trans, root, path);\r\ngoto out;\r\n}\r\nptr = (unsigned long)ref;\r\nsub_item_len = name_len + sizeof(*ref);\r\nitem_start = btrfs_item_ptr_offset(leaf, path->slots[0]);\r\nmemmove_extent_buffer(leaf, ptr, ptr + sub_item_len,\r\nitem_size - (ptr + sub_item_len - item_start));\r\nbtrfs_truncate_item(trans, root, path, item_size - sub_item_len, 1);\r\nout:\r\nbtrfs_free_path(path);\r\nif (search_ext_refs) {\r\nreturn btrfs_del_inode_extref(trans, root, name, name_len,\r\ninode_objectid, ref_objectid, index);\r\n}\r\nreturn ret;\r\n}\r\nstatic int btrfs_insert_inode_extref(struct btrfs_trans_handle *trans,\r\nstruct btrfs_root *root,\r\nconst char *name, int name_len,\r\nu64 inode_objectid, u64 ref_objectid, u64 index)\r\n{\r\nstruct btrfs_inode_extref *extref;\r\nint ret;\r\nint ins_len = name_len + sizeof(*extref);\r\nunsigned long ptr;\r\nstruct btrfs_path *path;\r\nstruct btrfs_key key;\r\nstruct extent_buffer *leaf;\r\nstruct btrfs_item *item;\r\nkey.objectid = inode_objectid;\r\nkey.type = BTRFS_INODE_EXTREF_KEY;\r\nkey.offset = btrfs_extref_hash(ref_objectid, name, name_len);\r\npath = btrfs_alloc_path();\r\nif (!path)\r\nreturn -ENOMEM;\r\npath->leave_spinning = 1;\r\nret = btrfs_insert_empty_item(trans, root, path, &key,\r\nins_len);\r\nif (ret == -EEXIST) {\r\nif (btrfs_find_name_in_ext_backref(path, ref_objectid,\r\nname, name_len, NULL))\r\ngoto out;\r\nbtrfs_extend_item(trans, root, path, ins_len);\r\nret = 0;\r\n}\r\nif (ret < 0)\r\ngoto out;\r\nleaf = path->nodes[0];\r\nitem = btrfs_item_nr(leaf, path->slots[0]);\r\nptr = (unsigned long)btrfs_item_ptr(leaf, path->slots[0], char);\r\nptr += btrfs_item_size(leaf, item) - ins_len;\r\nextref = (struct btrfs_inode_extref *)ptr;\r\nbtrfs_set_inode_extref_name_len(path->nodes[0], extref, name_len);\r\nbtrfs_set_inode_extref_index(path->nodes[0], extref, index);\r\nbtrfs_set_inode_extref_parent(path->nodes[0], extref, ref_objectid);\r\nptr = (unsigned long)&extref->name;\r\nwrite_extent_buffer(path->nodes[0], name, ptr, name_len);\r\nbtrfs_mark_buffer_dirty(path->nodes[0]);\r\nout:\r\nbtrfs_free_path(path);\r\nreturn ret;\r\n}\r\nint btrfs_insert_inode_ref(struct btrfs_trans_handle *trans,\r\nstruct btrfs_root *root,\r\nconst char *name, int name_len,\r\nu64 inode_objectid, u64 ref_objectid, u64 index)\r\n{\r\nstruct btrfs_path *path;\r\nstruct btrfs_key key;\r\nstruct btrfs_inode_ref *ref;\r\nunsigned long ptr;\r\nint ret;\r\nint ins_len = name_len + sizeof(*ref);\r\nkey.objectid = inode_objectid;\r\nkey.offset = ref_objectid;\r\nbtrfs_set_key_type(&key, BTRFS_INODE_REF_KEY);\r\npath = btrfs_alloc_path();\r\nif (!path)\r\nreturn -ENOMEM;\r\npath->leave_spinning = 1;\r\nret = btrfs_insert_empty_item(trans, root, path, &key,\r\nins_len);\r\nif (ret == -EEXIST) {\r\nu32 old_size;\r\nif (find_name_in_backref(path, name, name_len, &ref))\r\ngoto out;\r\nold_size = btrfs_item_size_nr(path->nodes[0], path->slots[0]);\r\nbtrfs_extend_item(trans, root, path, ins_len);\r\nref = btrfs_item_ptr(path->nodes[0], path->slots[0],\r\nstruct btrfs_inode_ref);\r\nref = (struct btrfs_inode_ref *)((unsigned long)ref + old_size);\r\nbtrfs_set_inode_ref_name_len(path->nodes[0], ref, name_len);\r\nbtrfs_set_inode_ref_index(path->nodes[0], ref, index);\r\nptr = (unsigned long)(ref + 1);\r\nret = 0;\r\n} else if (ret < 0) {\r\nif (ret == -EOVERFLOW)\r\nret = -EMLINK;\r\ngoto out;\r\n} else {\r\nref = btrfs_item_ptr(path->nodes[0], path->slots[0],\r\nstruct btrfs_inode_ref);\r\nbtrfs_set_inode_ref_name_len(path->nodes[0], ref, name_len);\r\nbtrfs_set_inode_ref_index(path->nodes[0], ref, index);\r\nptr = (unsigned long)(ref + 1);\r\n}\r\nwrite_extent_buffer(path->nodes[0], name, ptr, name_len);\r\nbtrfs_mark_buffer_dirty(path->nodes[0]);\r\nout:\r\nbtrfs_free_path(path);\r\nif (ret == -EMLINK) {\r\nstruct btrfs_super_block *disk_super = root->fs_info->super_copy;\r\nif (btrfs_super_incompat_flags(disk_super)\r\n& BTRFS_FEATURE_INCOMPAT_EXTENDED_IREF)\r\nret = btrfs_insert_inode_extref(trans, root, name,\r\nname_len,\r\ninode_objectid,\r\nref_objectid, index);\r\n}\r\nreturn ret;\r\n}\r\nint btrfs_insert_empty_inode(struct btrfs_trans_handle *trans,\r\nstruct btrfs_root *root,\r\nstruct btrfs_path *path, u64 objectid)\r\n{\r\nstruct btrfs_key key;\r\nint ret;\r\nkey.objectid = objectid;\r\nbtrfs_set_key_type(&key, BTRFS_INODE_ITEM_KEY);\r\nkey.offset = 0;\r\nret = btrfs_insert_empty_item(trans, root, path, &key,\r\nsizeof(struct btrfs_inode_item));\r\nreturn ret;\r\n}\r\nint btrfs_lookup_inode(struct btrfs_trans_handle *trans, struct btrfs_root\r\n*root, struct btrfs_path *path,\r\nstruct btrfs_key *location, int mod)\r\n{\r\nint ins_len = mod < 0 ? -1 : 0;\r\nint cow = mod != 0;\r\nint ret;\r\nint slot;\r\nstruct extent_buffer *leaf;\r\nstruct btrfs_key found_key;\r\nret = btrfs_search_slot(trans, root, location, path, ins_len, cow);\r\nif (ret > 0 && btrfs_key_type(location) == BTRFS_ROOT_ITEM_KEY &&\r\nlocation->offset == (u64)-1 && path->slots[0] != 0) {\r\nslot = path->slots[0] - 1;\r\nleaf = path->nodes[0];\r\nbtrfs_item_key_to_cpu(leaf, &found_key, slot);\r\nif (found_key.objectid == location->objectid &&\r\nbtrfs_key_type(&found_key) == btrfs_key_type(location)) {\r\npath->slots[0]--;\r\nreturn 0;\r\n}\r\n}\r\nreturn ret;\r\n}
