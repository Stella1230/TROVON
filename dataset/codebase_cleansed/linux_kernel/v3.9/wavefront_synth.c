static const char *\r\nwavefront_errorstr (int errnum)\r\n{\r\nint i;\r\nfor (i = 0; wavefront_errors[i].errstr; i++) {\r\nif (wavefront_errors[i].errno == errnum) {\r\nreturn wavefront_errors[i].errstr;\r\n}\r\n}\r\nreturn "Unknown WaveFront error";\r\n}\r\nstatic struct wavefront_command *\r\nwavefront_get_command (int cmd)\r\n{\r\nint i;\r\nfor (i = 0; wavefront_commands[i].cmd != 0; i++) {\r\nif (cmd == wavefront_commands[i].cmd) {\r\nreturn &wavefront_commands[i];\r\n}\r\n}\r\nreturn NULL;\r\n}\r\nstatic inline int\r\nwavefront_status (snd_wavefront_t *dev)\r\n{\r\nreturn inb (dev->status_port);\r\n}\r\nstatic int\r\nwavefront_sleep (int limit)\r\n{\r\nschedule_timeout_interruptible(limit);\r\nreturn signal_pending(current);\r\n}\r\nstatic int\r\nwavefront_wait (snd_wavefront_t *dev, int mask)\r\n{\r\nint i;\r\nfor (i = 0; i < wait_usecs; i += 5) {\r\nif (wavefront_status (dev) & mask) {\r\nreturn 1;\r\n}\r\nudelay(5);\r\n}\r\nfor (i = 0; i < sleep_tries; i++) {\r\nif (wavefront_status (dev) & mask) {\r\nreturn 1;\r\n}\r\nif (wavefront_sleep (HZ/sleep_interval)) {\r\nreturn (0);\r\n}\r\n}\r\nreturn (0);\r\n}\r\nstatic int\r\nwavefront_read (snd_wavefront_t *dev)\r\n{\r\nif (wavefront_wait (dev, STAT_CAN_READ))\r\nreturn inb (dev->data_port);\r\nDPRINT (WF_DEBUG_DATA, "read timeout.\n");\r\nreturn -1;\r\n}\r\nstatic int\r\nwavefront_write (snd_wavefront_t *dev, unsigned char data)\r\n{\r\nif (wavefront_wait (dev, STAT_CAN_WRITE)) {\r\noutb (data, dev->data_port);\r\nreturn 0;\r\n}\r\nDPRINT (WF_DEBUG_DATA, "write timeout.\n");\r\nreturn -1;\r\n}\r\nint\r\nsnd_wavefront_cmd (snd_wavefront_t *dev,\r\nint cmd, unsigned char *rbuf, unsigned char *wbuf)\r\n{\r\nint ack;\r\nunsigned int i;\r\nint c;\r\nstruct wavefront_command *wfcmd;\r\nif ((wfcmd = wavefront_get_command (cmd)) == NULL) {\r\nsnd_printk ("command 0x%x not supported.\n",\r\ncmd);\r\nreturn 1;\r\n}\r\nif (cmd == WFC_DOWNLOAD_MULTISAMPLE) {\r\nwfcmd->write_cnt = (unsigned long) rbuf;\r\nrbuf = NULL;\r\n}\r\nDPRINT (WF_DEBUG_CMD, "0x%x [%s] (%d,%d,%d)\n",\r\ncmd, wfcmd->action, wfcmd->read_cnt,\r\nwfcmd->write_cnt, wfcmd->need_ack);\r\nif (wavefront_write (dev, cmd)) {\r\nDPRINT ((WF_DEBUG_IO|WF_DEBUG_CMD), "cannot request "\r\n"0x%x [%s].\n",\r\ncmd, wfcmd->action);\r\nreturn 1;\r\n}\r\nif (wfcmd->write_cnt > 0) {\r\nDPRINT (WF_DEBUG_DATA, "writing %d bytes "\r\n"for 0x%x\n",\r\nwfcmd->write_cnt, cmd);\r\nfor (i = 0; i < wfcmd->write_cnt; i++) {\r\nif (wavefront_write (dev, wbuf[i])) {\r\nDPRINT (WF_DEBUG_IO, "bad write for byte "\r\n"%d of 0x%x [%s].\n",\r\ni, cmd, wfcmd->action);\r\nreturn 1;\r\n}\r\nDPRINT (WF_DEBUG_DATA, "write[%d] = 0x%x\n",\r\ni, wbuf[i]);\r\n}\r\n}\r\nif (wfcmd->read_cnt > 0) {\r\nDPRINT (WF_DEBUG_DATA, "reading %d ints "\r\n"for 0x%x\n",\r\nwfcmd->read_cnt, cmd);\r\nfor (i = 0; i < wfcmd->read_cnt; i++) {\r\nif ((c = wavefront_read (dev)) == -1) {\r\nDPRINT (WF_DEBUG_IO, "bad read for byte "\r\n"%d of 0x%x [%s].\n",\r\ni, cmd, wfcmd->action);\r\nreturn 1;\r\n}\r\nif (c == 0xff) {\r\nif ((c = wavefront_read (dev)) == -1) {\r\nDPRINT (WF_DEBUG_IO, "bad read for "\r\n"error byte at "\r\n"read byte %d "\r\n"of 0x%x [%s].\n",\r\ni, cmd,\r\nwfcmd->action);\r\nreturn 1;\r\n}\r\nif (c == 1 &&\r\nwfcmd->cmd == WFC_IDENTIFY_SAMPLE_TYPE) {\r\nrbuf[0] = WF_ST_EMPTY;\r\nreturn (0);\r\n} else if (c == 3 &&\r\nwfcmd->cmd == WFC_UPLOAD_PATCH) {\r\nreturn 3;\r\n} else if (c == 1 &&\r\nwfcmd->cmd == WFC_UPLOAD_PROGRAM) {\r\nreturn 1;\r\n} else {\r\nDPRINT (WF_DEBUG_IO, "error %d (%s) "\r\n"during "\r\n"read for byte "\r\n"%d of 0x%x "\r\n"[%s].\n",\r\nc,\r\nwavefront_errorstr (c),\r\ni, cmd,\r\nwfcmd->action);\r\nreturn 1;\r\n}\r\n} else {\r\nrbuf[i] = c;\r\n}\r\nDPRINT (WF_DEBUG_DATA, "read[%d] = 0x%x\n",i, rbuf[i]);\r\n}\r\n}\r\nif ((wfcmd->read_cnt == 0 && wfcmd->write_cnt == 0) || wfcmd->need_ack) {\r\nDPRINT (WF_DEBUG_CMD, "reading ACK for 0x%x\n", cmd);\r\nif ((ack = wavefront_read (dev)) == 0) {\r\nack = WF_ACK;\r\n}\r\nif (ack != WF_ACK) {\r\nif (ack == -1) {\r\nDPRINT (WF_DEBUG_IO, "cannot read ack for "\r\n"0x%x [%s].\n",\r\ncmd, wfcmd->action);\r\nreturn 1;\r\n} else {\r\nint err = -1;\r\nif (ack == 0xff) {\r\nif ((err = wavefront_read (dev)) == -1) {\r\nDPRINT (WF_DEBUG_DATA,\r\n"cannot read err "\r\n"for 0x%x [%s].\n",\r\ncmd, wfcmd->action);\r\n}\r\n}\r\nDPRINT (WF_DEBUG_IO, "0x%x [%s] "\r\n"failed (0x%x, 0x%x, %s)\n",\r\ncmd, wfcmd->action, ack, err,\r\nwavefront_errorstr (err));\r\nreturn -err;\r\n}\r\n}\r\nDPRINT (WF_DEBUG_DATA, "ack received "\r\n"for 0x%x [%s]\n",\r\ncmd, wfcmd->action);\r\n} else {\r\nDPRINT (WF_DEBUG_CMD, "0x%x [%s] does not need "\r\n"ACK (%d,%d,%d)\n",\r\ncmd, wfcmd->action, wfcmd->read_cnt,\r\nwfcmd->write_cnt, wfcmd->need_ack);\r\n}\r\nreturn 0;\r\n}\r\nstatic unsigned char *\r\nmunge_int32 (unsigned int src,\r\nunsigned char *dst,\r\nunsigned int dst_size)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < dst_size; i++) {\r\n*dst = src & 0x7F;\r\nsrc = src >> 7;\r\ndst++;\r\n}\r\nreturn dst;\r\n}\r\nstatic int\r\ndemunge_int32 (unsigned char* src, int src_size)\r\n{\r\nint i;\r\nint outval = 0;\r\nfor (i = src_size - 1; i >= 0; i--) {\r\noutval=(outval<<7)+src[i];\r\n}\r\nreturn outval;\r\n}\r\nstatic\r\nunsigned char *\r\nmunge_buf (unsigned char *src, unsigned char *dst, unsigned int dst_size)\r\n{\r\nunsigned int i;\r\nunsigned int last = dst_size / 2;\r\nfor (i = 0; i < last; i++) {\r\n*dst++ = src[i] & 0x7f;\r\n*dst++ = src[i] >> 7;\r\n}\r\nreturn dst;\r\n}\r\nstatic\r\nunsigned char *\r\ndemunge_buf (unsigned char *src, unsigned char *dst, unsigned int src_bytes)\r\n{\r\nint i;\r\nunsigned char *end = src + src_bytes;\r\nend = src + src_bytes;\r\nfor (i = 0; src != end; i++) {\r\ndst[i] = *src++;\r\ndst[i] |= (*src++)<<7;\r\n}\r\nreturn dst;\r\n}\r\nstatic int\r\nwavefront_delete_sample (snd_wavefront_t *dev, int sample_num)\r\n{\r\nunsigned char wbuf[2];\r\nint x;\r\nwbuf[0] = sample_num & 0x7f;\r\nwbuf[1] = sample_num >> 7;\r\nif ((x = snd_wavefront_cmd (dev, WFC_DELETE_SAMPLE, NULL, wbuf)) == 0) {\r\ndev->sample_status[sample_num] = WF_ST_EMPTY;\r\n}\r\nreturn x;\r\n}\r\nstatic int\r\nwavefront_get_sample_status (snd_wavefront_t *dev, int assume_rom)\r\n{\r\nint i;\r\nunsigned char rbuf[32], wbuf[32];\r\nunsigned int sc_real, sc_alias, sc_multi;\r\nif (snd_wavefront_cmd (dev, WFC_GET_NSAMPLES, rbuf, wbuf)) {\r\nsnd_printk ("cannot request sample count.\n");\r\nreturn -1;\r\n}\r\nsc_real = sc_alias = sc_multi = dev->samples_used = 0;\r\nfor (i = 0; i < WF_MAX_SAMPLE; i++) {\r\nwbuf[0] = i & 0x7f;\r\nwbuf[1] = i >> 7;\r\nif (snd_wavefront_cmd (dev, WFC_IDENTIFY_SAMPLE_TYPE, rbuf, wbuf)) {\r\nsnd_printk(KERN_WARNING "cannot identify sample "\r\n"type of slot %d\n", i);\r\ndev->sample_status[i] = WF_ST_EMPTY;\r\ncontinue;\r\n}\r\ndev->sample_status[i] = (WF_SLOT_FILLED|rbuf[0]);\r\nif (assume_rom) {\r\ndev->sample_status[i] |= WF_SLOT_ROM;\r\n}\r\nswitch (rbuf[0] & WF_ST_MASK) {\r\ncase WF_ST_SAMPLE:\r\nsc_real++;\r\nbreak;\r\ncase WF_ST_MULTISAMPLE:\r\nsc_multi++;\r\nbreak;\r\ncase WF_ST_ALIAS:\r\nsc_alias++;\r\nbreak;\r\ncase WF_ST_EMPTY:\r\nbreak;\r\ndefault:\r\nsnd_printk ("unknown sample type for "\r\n"slot %d (0x%x)\n",\r\ni, rbuf[0]);\r\n}\r\nif (rbuf[0] != WF_ST_EMPTY) {\r\ndev->samples_used++;\r\n}\r\n}\r\nsnd_printk ("%d samples used (%d real, %d aliases, %d multi), "\r\n"%d empty\n", dev->samples_used, sc_real, sc_alias, sc_multi,\r\nWF_MAX_SAMPLE - dev->samples_used);\r\nreturn (0);\r\n}\r\nstatic int\r\nwavefront_get_patch_status (snd_wavefront_t *dev)\r\n{\r\nunsigned char patchbuf[WF_PATCH_BYTES];\r\nunsigned char patchnum[2];\r\nwavefront_patch *p;\r\nint i, x, cnt, cnt2;\r\nfor (i = 0; i < WF_MAX_PATCH; i++) {\r\npatchnum[0] = i & 0x7f;\r\npatchnum[1] = i >> 7;\r\nif ((x = snd_wavefront_cmd (dev, WFC_UPLOAD_PATCH, patchbuf,\r\npatchnum)) == 0) {\r\ndev->patch_status[i] |= WF_SLOT_FILLED;\r\np = (wavefront_patch *) patchbuf;\r\ndev->sample_status\r\n[p->sample_number|(p->sample_msb<<7)] |=\r\nWF_SLOT_USED;\r\n} else if (x == 3) {\r\ndev->patch_status[i] = 0;\r\n} else {\r\nsnd_printk ("upload patch "\r\n"error 0x%x\n", x);\r\ndev->patch_status[i] = 0;\r\nreturn 1;\r\n}\r\n}\r\nfor (i = 0, cnt = 0, cnt2 = 0; i < WF_MAX_PATCH; i++) {\r\nif (dev->patch_status[i] & WF_SLOT_FILLED) {\r\ncnt++;\r\n}\r\nif (dev->patch_status[i] & WF_SLOT_USED) {\r\ncnt2++;\r\n}\r\n}\r\nsnd_printk ("%d patch slots filled, %d in use\n", cnt, cnt2);\r\nreturn (0);\r\n}\r\nstatic int\r\nwavefront_get_program_status (snd_wavefront_t *dev)\r\n{\r\nunsigned char progbuf[WF_PROGRAM_BYTES];\r\nwavefront_program prog;\r\nunsigned char prognum;\r\nint i, x, l, cnt;\r\nfor (i = 0; i < WF_MAX_PROGRAM; i++) {\r\nprognum = i;\r\nif ((x = snd_wavefront_cmd (dev, WFC_UPLOAD_PROGRAM, progbuf,\r\n&prognum)) == 0) {\r\ndev->prog_status[i] |= WF_SLOT_USED;\r\ndemunge_buf (progbuf, (unsigned char *) &prog,\r\nWF_PROGRAM_BYTES);\r\nfor (l = 0; l < WF_NUM_LAYERS; l++) {\r\nif (prog.layer[l].mute) {\r\ndev->patch_status\r\n[prog.layer[l].patch_number] |=\r\nWF_SLOT_USED;\r\n}\r\n}\r\n} else if (x == 1) {\r\ndev->prog_status[i] = 0;\r\n} else {\r\nsnd_printk ("upload program "\r\n"error 0x%x\n", x);\r\ndev->prog_status[i] = 0;\r\n}\r\n}\r\nfor (i = 0, cnt = 0; i < WF_MAX_PROGRAM; i++) {\r\nif (dev->prog_status[i]) {\r\ncnt++;\r\n}\r\n}\r\nsnd_printk ("%d programs slots in use\n", cnt);\r\nreturn (0);\r\n}\r\nstatic int\r\nwavefront_send_patch (snd_wavefront_t *dev, wavefront_patch_info *header)\r\n{\r\nunsigned char buf[WF_PATCH_BYTES+2];\r\nunsigned char *bptr;\r\nDPRINT (WF_DEBUG_LOAD_PATCH, "downloading patch %d\n",\r\nheader->number);\r\ndev->patch_status[header->number] |= WF_SLOT_FILLED;\r\nbptr = buf;\r\nbptr = munge_int32 (header->number, buf, 2);\r\nmunge_buf ((unsigned char *)&header->hdr.p, bptr, WF_PATCH_BYTES);\r\nif (snd_wavefront_cmd (dev, WFC_DOWNLOAD_PATCH, NULL, buf)) {\r\nsnd_printk ("download patch failed\n");\r\nreturn -(EIO);\r\n}\r\nreturn (0);\r\n}\r\nstatic int\r\nwavefront_send_program (snd_wavefront_t *dev, wavefront_patch_info *header)\r\n{\r\nunsigned char buf[WF_PROGRAM_BYTES+1];\r\nint i;\r\nDPRINT (WF_DEBUG_LOAD_PATCH, "downloading program %d\n",\r\nheader->number);\r\ndev->prog_status[header->number] = WF_SLOT_USED;\r\nfor (i = 0; i < WF_NUM_LAYERS; i++) {\r\nif (header->hdr.pr.layer[i].mute) {\r\ndev->patch_status[header->hdr.pr.layer[i].patch_number] |=\r\nWF_SLOT_USED;\r\n}\r\n}\r\nbuf[0] = header->number;\r\nmunge_buf ((unsigned char *)&header->hdr.pr, &buf[1], WF_PROGRAM_BYTES);\r\nif (snd_wavefront_cmd (dev, WFC_DOWNLOAD_PROGRAM, NULL, buf)) {\r\nsnd_printk ("download patch failed\n");\r\nreturn -(EIO);\r\n}\r\nreturn (0);\r\n}\r\nstatic int\r\nwavefront_freemem (snd_wavefront_t *dev)\r\n{\r\nchar rbuf[8];\r\nif (snd_wavefront_cmd (dev, WFC_REPORT_FREE_MEMORY, rbuf, NULL)) {\r\nsnd_printk ("can't get memory stats.\n");\r\nreturn -1;\r\n} else {\r\nreturn demunge_int32 (rbuf, 4);\r\n}\r\n}\r\nstatic int\r\nwavefront_send_sample (snd_wavefront_t *dev,\r\nwavefront_patch_info *header,\r\nu16 __user *dataptr,\r\nint data_is_unsigned)\r\n{\r\nu16 sample_short = 0;\r\nu32 length;\r\nu16 __user *data_end = NULL;\r\nunsigned int i;\r\nconst unsigned int max_blksize = 4096/2;\r\nunsigned int written;\r\nunsigned int blocksize;\r\nint dma_ack;\r\nint blocknum;\r\nunsigned char sample_hdr[WF_SAMPLE_HDR_BYTES];\r\nunsigned char *shptr;\r\nint skip = 0;\r\nint initial_skip = 0;\r\nDPRINT (WF_DEBUG_LOAD_PATCH, "sample %sdownload for slot %d, "\r\n"type %d, %d bytes from 0x%lx\n",\r\nheader->size ? "" : "header ",\r\nheader->number, header->subkey,\r\nheader->size,\r\n(unsigned long) header->dataptr);\r\nif (header->number == WAVEFRONT_FIND_FREE_SAMPLE_SLOT) {\r\nint x;\r\nif ((x = wavefront_find_free_sample (dev)) < 0) {\r\nreturn -ENOMEM;\r\n}\r\nsnd_printk ("unspecified sample => %d\n", x);\r\nheader->number = x;\r\n}\r\nif (header->size) {\r\nif (dev->rom_samples_rdonly) {\r\nif (dev->sample_status[header->number] & WF_SLOT_ROM) {\r\nsnd_printk ("sample slot %d "\r\n"write protected\n",\r\nheader->number);\r\nreturn -EACCES;\r\n}\r\n}\r\nwavefront_delete_sample (dev, header->number);\r\n}\r\nif (header->size) {\r\ndev->freemem = wavefront_freemem (dev);\r\nif (dev->freemem < (int)header->size) {\r\nsnd_printk ("insufficient memory to "\r\n"load %d byte sample.\n",\r\nheader->size);\r\nreturn -ENOMEM;\r\n}\r\n}\r\nskip = WF_GET_CHANNEL(&header->hdr.s);\r\nif (skip > 0 && header->hdr.s.SampleResolution != LINEAR_16BIT) {\r\nsnd_printk ("channel selection only "\r\n"possible on 16-bit samples");\r\nreturn -(EINVAL);\r\n}\r\nswitch (skip) {\r\ncase 0:\r\ninitial_skip = 0;\r\nskip = 1;\r\nbreak;\r\ncase 1:\r\ninitial_skip = 0;\r\nskip = 2;\r\nbreak;\r\ncase 2:\r\ninitial_skip = 1;\r\nskip = 2;\r\nbreak;\r\ncase 3:\r\ninitial_skip = 2;\r\nskip = 3;\r\nbreak;\r\ncase 4:\r\ninitial_skip = 3;\r\nskip = 4;\r\nbreak;\r\ncase 5:\r\ninitial_skip = 4;\r\nskip = 5;\r\nbreak;\r\ncase 6:\r\ninitial_skip = 5;\r\nskip = 6;\r\nbreak;\r\n}\r\nDPRINT (WF_DEBUG_LOAD_PATCH, "channel selection: %d => "\r\n"initial skip = %d, skip = %d\n",\r\nWF_GET_CHANNEL (&header->hdr.s),\r\ninitial_skip, skip);\r\nWF_SET_CHANNEL(&header->hdr.s, 0);\r\nlength = header->size / 2;\r\nshptr = &sample_hdr[0];\r\nshptr = munge_int32 (header->number, shptr, 2);\r\nif (header->size) {\r\nshptr = munge_int32 (length, shptr, 4);\r\n}\r\nshptr = munge_int32 (*((u32 *) &header->hdr.s.sampleStartOffset),\r\nshptr, 4);\r\nshptr = munge_int32 (*((u32 *) &header->hdr.s.loopStartOffset),\r\nshptr, 4);\r\nshptr = munge_int32 (*((u32 *) &header->hdr.s.loopEndOffset),\r\nshptr, 4);\r\nshptr = munge_int32 (*((u32 *) &header->hdr.s.sampleEndOffset),\r\nshptr, 4);\r\nshptr = munge_int32 (header->hdr.s.FrequencyBias, shptr, 3);\r\nshptr = munge_int32 (*(&header->hdr.s.FrequencyBias+1),\r\nshptr, 2);\r\nif (snd_wavefront_cmd (dev,\r\nheader->size ?\r\nWFC_DOWNLOAD_SAMPLE : WFC_DOWNLOAD_SAMPLE_HEADER,\r\nNULL, sample_hdr)) {\r\nsnd_printk ("sample %sdownload refused.\n",\r\nheader->size ? "" : "header ");\r\nreturn -(EIO);\r\n}\r\nif (header->size == 0) {\r\ngoto sent;\r\n}\r\ndata_end = dataptr + length;\r\ndataptr += initial_skip;\r\nfor (written = 0, blocknum = 0;\r\nwritten < length; written += max_blksize, blocknum++) {\r\nif ((length - written) > max_blksize) {\r\nblocksize = max_blksize;\r\n} else {\r\nblocksize = ALIGN(length - written, 8);\r\n}\r\nif (snd_wavefront_cmd (dev, WFC_DOWNLOAD_BLOCK, NULL, NULL)) {\r\nsnd_printk ("download block "\r\n"request refused.\n");\r\nreturn -(EIO);\r\n}\r\nfor (i = 0; i < blocksize; i++) {\r\nif (dataptr < data_end) {\r\n__get_user (sample_short, dataptr);\r\ndataptr += skip;\r\nif (data_is_unsigned) {\r\nif (WF_SAMPLE_IS_8BIT(&header->hdr.s)) {\r\n((unsigned char*)\r\n&sample_short)[0] += 0x7f;\r\n((unsigned char*)\r\n&sample_short)[1] += 0x7f;\r\n} else {\r\nsample_short += 0x7fff;\r\n}\r\n}\r\n} else {\r\n}\r\nif (i < blocksize - 1) {\r\noutw (sample_short, dev->block_port);\r\n} else {\r\noutw (sample_short, dev->last_block_port);\r\n}\r\n}\r\nif ((dma_ack = wavefront_read (dev)) != WF_DMA_ACK) {\r\nif (dma_ack == -1) {\r\nsnd_printk ("upload sample "\r\n"DMA ack timeout\n");\r\nreturn -(EIO);\r\n} else {\r\nsnd_printk ("upload sample "\r\n"DMA ack error 0x%x\n",\r\ndma_ack);\r\nreturn -(EIO);\r\n}\r\n}\r\n}\r\ndev->sample_status[header->number] = (WF_SLOT_FILLED|WF_ST_SAMPLE);\r\nsent:\r\nreturn (0);\r\n}\r\nstatic int\r\nwavefront_send_alias (snd_wavefront_t *dev, wavefront_patch_info *header)\r\n{\r\nunsigned char alias_hdr[WF_ALIAS_BYTES];\r\nDPRINT (WF_DEBUG_LOAD_PATCH, "download alias, %d is "\r\n"alias for %d\n",\r\nheader->number,\r\nheader->hdr.a.OriginalSample);\r\nmunge_int32 (header->number, &alias_hdr[0], 2);\r\nmunge_int32 (header->hdr.a.OriginalSample, &alias_hdr[2], 2);\r\nmunge_int32 (*((unsigned int *)&header->hdr.a.sampleStartOffset),\r\n&alias_hdr[4], 4);\r\nmunge_int32 (*((unsigned int *)&header->hdr.a.loopStartOffset),\r\n&alias_hdr[8], 4);\r\nmunge_int32 (*((unsigned int *)&header->hdr.a.loopEndOffset),\r\n&alias_hdr[12], 4);\r\nmunge_int32 (*((unsigned int *)&header->hdr.a.sampleEndOffset),\r\n&alias_hdr[16], 4);\r\nmunge_int32 (header->hdr.a.FrequencyBias, &alias_hdr[20], 3);\r\nmunge_int32 (*(&header->hdr.a.FrequencyBias+1), &alias_hdr[23], 2);\r\nif (snd_wavefront_cmd (dev, WFC_DOWNLOAD_SAMPLE_ALIAS, NULL, alias_hdr)) {\r\nsnd_printk ("download alias failed.\n");\r\nreturn -(EIO);\r\n}\r\ndev->sample_status[header->number] = (WF_SLOT_FILLED|WF_ST_ALIAS);\r\nreturn (0);\r\n}\r\nstatic int\r\nwavefront_send_multisample (snd_wavefront_t *dev, wavefront_patch_info *header)\r\n{\r\nint i;\r\nint num_samples;\r\nunsigned char *msample_hdr;\r\nmsample_hdr = kmalloc(sizeof(WF_MSAMPLE_BYTES), GFP_KERNEL);\r\nif (! msample_hdr)\r\nreturn -ENOMEM;\r\nmunge_int32 (header->number, &msample_hdr[0], 2);\r\nnum_samples = (1<<(header->hdr.ms.NumberOfSamples&7));\r\nmsample_hdr[2] = (unsigned char) header->hdr.ms.NumberOfSamples;\r\nDPRINT (WF_DEBUG_LOAD_PATCH, "multi %d with %d=%d samples\n",\r\nheader->number,\r\nheader->hdr.ms.NumberOfSamples,\r\nnum_samples);\r\nfor (i = 0; i < num_samples; i++) {\r\nDPRINT(WF_DEBUG_LOAD_PATCH|WF_DEBUG_DATA, "sample[%d] = %d\n",\r\ni, header->hdr.ms.SampleNumber[i]);\r\nmunge_int32 (header->hdr.ms.SampleNumber[i],\r\n&msample_hdr[3+(i*2)], 2);\r\n}\r\nif (snd_wavefront_cmd (dev, WFC_DOWNLOAD_MULTISAMPLE,\r\n(unsigned char *) (long) ((num_samples*2)+3),\r\nmsample_hdr)) {\r\nsnd_printk ("download of multisample failed.\n");\r\nkfree(msample_hdr);\r\nreturn -(EIO);\r\n}\r\ndev->sample_status[header->number] = (WF_SLOT_FILLED|WF_ST_MULTISAMPLE);\r\nkfree(msample_hdr);\r\nreturn (0);\r\n}\r\nstatic int\r\nwavefront_fetch_multisample (snd_wavefront_t *dev,\r\nwavefront_patch_info *header)\r\n{\r\nint i;\r\nunsigned char log_ns[1];\r\nunsigned char number[2];\r\nint num_samples;\r\nmunge_int32 (header->number, number, 2);\r\nif (snd_wavefront_cmd (dev, WFC_UPLOAD_MULTISAMPLE, log_ns, number)) {\r\nsnd_printk ("upload multisample failed.\n");\r\nreturn -(EIO);\r\n}\r\nDPRINT (WF_DEBUG_DATA, "msample %d has %d samples\n",\r\nheader->number, log_ns[0]);\r\nheader->hdr.ms.NumberOfSamples = log_ns[0];\r\nnum_samples = (1 << log_ns[0]);\r\nfor (i = 0; i < num_samples; i++) {\r\nchar d[2];\r\nint val;\r\nif ((val = wavefront_read (dev)) == -1) {\r\nsnd_printk ("upload multisample failed "\r\n"during sample loop.\n");\r\nreturn -(EIO);\r\n}\r\nd[0] = val;\r\nif ((val = wavefront_read (dev)) == -1) {\r\nsnd_printk ("upload multisample failed "\r\n"during sample loop.\n");\r\nreturn -(EIO);\r\n}\r\nd[1] = val;\r\nheader->hdr.ms.SampleNumber[i] =\r\ndemunge_int32 ((unsigned char *) d, 2);\r\nDPRINT (WF_DEBUG_DATA, "msample sample[%d] = %d\n",\r\ni, header->hdr.ms.SampleNumber[i]);\r\n}\r\nreturn (0);\r\n}\r\nstatic int\r\nwavefront_send_drum (snd_wavefront_t *dev, wavefront_patch_info *header)\r\n{\r\nunsigned char drumbuf[WF_DRUM_BYTES];\r\nwavefront_drum *drum = &header->hdr.d;\r\nint i;\r\nDPRINT (WF_DEBUG_LOAD_PATCH, "downloading edrum for MIDI "\r\n"note %d, patch = %d\n",\r\nheader->number, drum->PatchNumber);\r\ndrumbuf[0] = header->number & 0x7f;\r\nfor (i = 0; i < 4; i++) {\r\nmunge_int32 (((unsigned char *)drum)[i], &drumbuf[1+(i*2)], 2);\r\n}\r\nif (snd_wavefront_cmd (dev, WFC_DOWNLOAD_EDRUM_PROGRAM, NULL, drumbuf)) {\r\nsnd_printk ("download drum failed.\n");\r\nreturn -(EIO);\r\n}\r\nreturn (0);\r\n}\r\nstatic int\r\nwavefront_find_free_sample (snd_wavefront_t *dev)\r\n{\r\nint i;\r\nfor (i = 0; i < WF_MAX_SAMPLE; i++) {\r\nif (!(dev->sample_status[i] & WF_SLOT_FILLED)) {\r\nreturn i;\r\n}\r\n}\r\nsnd_printk ("no free sample slots!\n");\r\nreturn -1;\r\n}\r\nstatic int\r\nwavefront_load_patch (snd_wavefront_t *dev, const char __user *addr)\r\n{\r\nwavefront_patch_info *header;\r\nint err;\r\nheader = kmalloc(sizeof(*header), GFP_KERNEL);\r\nif (! header)\r\nreturn -ENOMEM;\r\nif (copy_from_user (header, addr, sizeof(wavefront_patch_info) -\r\nsizeof(wavefront_any))) {\r\nsnd_printk ("bad address for load patch.\n");\r\nerr = -EFAULT;\r\ngoto __error;\r\n}\r\nDPRINT (WF_DEBUG_LOAD_PATCH, "download "\r\n"Sample type: %d "\r\n"Sample number: %d "\r\n"Sample size: %d\n",\r\nheader->subkey,\r\nheader->number,\r\nheader->size);\r\nswitch (header->subkey) {\r\ncase WF_ST_SAMPLE:\r\nif (copy_from_user (&header->hdr.s, header->hdrptr,\r\nsizeof (wavefront_sample))) {\r\nerr = -EFAULT;\r\nbreak;\r\n}\r\nerr = wavefront_send_sample (dev, header, header->dataptr, 0);\r\nbreak;\r\ncase WF_ST_MULTISAMPLE:\r\nif (copy_from_user (&header->hdr.s, header->hdrptr,\r\nsizeof (wavefront_multisample))) {\r\nerr = -EFAULT;\r\nbreak;\r\n}\r\nerr = wavefront_send_multisample (dev, header);\r\nbreak;\r\ncase WF_ST_ALIAS:\r\nif (copy_from_user (&header->hdr.a, header->hdrptr,\r\nsizeof (wavefront_alias))) {\r\nerr = -EFAULT;\r\nbreak;\r\n}\r\nerr = wavefront_send_alias (dev, header);\r\nbreak;\r\ncase WF_ST_DRUM:\r\nif (copy_from_user (&header->hdr.d, header->hdrptr,\r\nsizeof (wavefront_drum))) {\r\nerr = -EFAULT;\r\nbreak;\r\n}\r\nerr = wavefront_send_drum (dev, header);\r\nbreak;\r\ncase WF_ST_PATCH:\r\nif (copy_from_user (&header->hdr.p, header->hdrptr,\r\nsizeof (wavefront_patch))) {\r\nerr = -EFAULT;\r\nbreak;\r\n}\r\nerr = wavefront_send_patch (dev, header);\r\nbreak;\r\ncase WF_ST_PROGRAM:\r\nif (copy_from_user (&header->hdr.pr, header->hdrptr,\r\nsizeof (wavefront_program))) {\r\nerr = -EFAULT;\r\nbreak;\r\n}\r\nerr = wavefront_send_program (dev, header);\r\nbreak;\r\ndefault:\r\nsnd_printk ("unknown patch type %d.\n",\r\nheader->subkey);\r\nerr = -EINVAL;\r\nbreak;\r\n}\r\n__error:\r\nkfree(header);\r\nreturn err;\r\n}\r\nstatic void\r\nprocess_sample_hdr (u8 *buf)\r\n{\r\nwavefront_sample s;\r\nu8 *ptr;\r\nptr = buf;\r\n*((u32 *) &s.sampleStartOffset) = demunge_int32 (ptr, 4); ptr += 4;\r\n*((u32 *) &s.loopStartOffset) = demunge_int32 (ptr, 4); ptr += 4;\r\n*((u32 *) &s.loopEndOffset) = demunge_int32 (ptr, 4); ptr += 4;\r\n*((u32 *) &s.sampleEndOffset) = demunge_int32 (ptr, 4); ptr += 4;\r\n*((u32 *) &s.FrequencyBias) = demunge_int32 (ptr, 3); ptr += 3;\r\ns.SampleResolution = *ptr & 0x3;\r\ns.Loop = *ptr & 0x8;\r\ns.Bidirectional = *ptr & 0x10;\r\ns.Reverse = *ptr & 0x40;\r\nmemcpy (buf, (unsigned char *) &s, sizeof (wavefront_sample));\r\n}\r\nstatic int\r\nwavefront_synth_control (snd_wavefront_card_t *acard,\r\nwavefront_control *wc)\r\n{\r\nsnd_wavefront_t *dev = &acard->wavefront;\r\nunsigned char patchnumbuf[2];\r\nint i;\r\nDPRINT (WF_DEBUG_CMD, "synth control with "\r\n"cmd 0x%x\n", wc->cmd);\r\nswitch (wc->cmd) {\r\ncase WFC_DISABLE_INTERRUPTS:\r\nsnd_printk ("interrupts disabled.\n");\r\noutb (0x80|0x20, dev->control_port);\r\ndev->interrupts_are_midi = 1;\r\nreturn 0;\r\ncase WFC_ENABLE_INTERRUPTS:\r\nsnd_printk ("interrupts enabled.\n");\r\noutb (0x80|0x40|0x20, dev->control_port);\r\ndev->interrupts_are_midi = 1;\r\nreturn 0;\r\ncase WFC_INTERRUPT_STATUS:\r\nwc->rbuf[0] = dev->interrupts_are_midi;\r\nreturn 0;\r\ncase WFC_ROMSAMPLES_RDONLY:\r\ndev->rom_samples_rdonly = wc->wbuf[0];\r\nwc->status = 0;\r\nreturn 0;\r\ncase WFC_IDENTIFY_SLOT_TYPE:\r\ni = wc->wbuf[0] | (wc->wbuf[1] << 7);\r\nif (i <0 || i >= WF_MAX_SAMPLE) {\r\nsnd_printk ("invalid slot ID %d\n",\r\ni);\r\nwc->status = EINVAL;\r\nreturn -EINVAL;\r\n}\r\nwc->rbuf[0] = dev->sample_status[i];\r\nwc->status = 0;\r\nreturn 0;\r\ncase WFC_DEBUG_DRIVER:\r\ndev->debug = wc->wbuf[0];\r\nsnd_printk ("debug = 0x%x\n", dev->debug);\r\nreturn 0;\r\ncase WFC_UPLOAD_PATCH:\r\nmunge_int32 (*((u32 *) wc->wbuf), patchnumbuf, 2);\r\nmemcpy (wc->wbuf, patchnumbuf, 2);\r\nbreak;\r\ncase WFC_UPLOAD_MULTISAMPLE:\r\nwc->status = wavefront_fetch_multisample\r\n(dev, (wavefront_patch_info *) wc->rbuf);\r\nreturn 0;\r\ncase WFC_UPLOAD_SAMPLE_ALIAS:\r\nsnd_printk ("support for sample alias upload "\r\n"being considered.\n");\r\nwc->status = EINVAL;\r\nreturn -EINVAL;\r\n}\r\nwc->status = snd_wavefront_cmd (dev, wc->cmd, wc->rbuf, wc->wbuf);\r\nif (wc->status == 0) {\r\nswitch (wc->cmd) {\r\ncase WFC_REPORT_FREE_MEMORY:\r\ndev->freemem = demunge_int32 (wc->rbuf, 4);\r\nbreak;\r\ncase WFC_UPLOAD_PATCH:\r\ndemunge_buf (wc->rbuf, wc->rbuf, WF_PATCH_BYTES);\r\nbreak;\r\ncase WFC_UPLOAD_PROGRAM:\r\ndemunge_buf (wc->rbuf, wc->rbuf, WF_PROGRAM_BYTES);\r\nbreak;\r\ncase WFC_UPLOAD_EDRUM_PROGRAM:\r\ndemunge_buf (wc->rbuf, wc->rbuf, WF_DRUM_BYTES - 1);\r\nbreak;\r\ncase WFC_UPLOAD_SAMPLE_HEADER:\r\nprocess_sample_hdr (wc->rbuf);\r\nbreak;\r\ncase WFC_UPLOAD_SAMPLE_ALIAS:\r\nsnd_printk ("support for "\r\n"sample aliases still "\r\n"being considered.\n");\r\nbreak;\r\ncase WFC_VMIDI_OFF:\r\nsnd_wavefront_midi_disable_virtual (acard);\r\nbreak;\r\ncase WFC_VMIDI_ON:\r\nsnd_wavefront_midi_enable_virtual (acard);\r\nbreak;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nint\r\nsnd_wavefront_synth_open (struct snd_hwdep *hw, struct file *file)\r\n{\r\nif (!try_module_get(hw->card->module))\r\nreturn -EFAULT;\r\nfile->private_data = hw;\r\nreturn 0;\r\n}\r\nint\r\nsnd_wavefront_synth_release (struct snd_hwdep *hw, struct file *file)\r\n{\r\nmodule_put(hw->card->module);\r\nreturn 0;\r\n}\r\nint\r\nsnd_wavefront_synth_ioctl (struct snd_hwdep *hw, struct file *file,\r\nunsigned int cmd, unsigned long arg)\r\n{\r\nstruct snd_card *card;\r\nsnd_wavefront_t *dev;\r\nsnd_wavefront_card_t *acard;\r\nwavefront_control *wc;\r\nvoid __user *argp = (void __user *)arg;\r\nint err;\r\ncard = (struct snd_card *) hw->card;\r\nif (snd_BUG_ON(!card))\r\nreturn -ENODEV;\r\nif (snd_BUG_ON(!card->private_data))\r\nreturn -ENODEV;\r\nacard = card->private_data;\r\ndev = &acard->wavefront;\r\nswitch (cmd) {\r\ncase WFCTL_LOAD_SPP:\r\nif (wavefront_load_patch (dev, argp) != 0) {\r\nreturn -EIO;\r\n}\r\nbreak;\r\ncase WFCTL_WFCMD:\r\nwc = memdup_user(argp, sizeof(*wc));\r\nif (IS_ERR(wc))\r\nreturn PTR_ERR(wc);\r\nif (wavefront_synth_control (acard, wc) < 0)\r\nerr = -EIO;\r\nelse if (copy_to_user (argp, wc, sizeof (*wc)))\r\nerr = -EFAULT;\r\nelse\r\nerr = 0;\r\nkfree(wc);\r\nreturn err;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nvoid\r\nsnd_wavefront_internal_interrupt (snd_wavefront_card_t *card)\r\n{\r\nsnd_wavefront_t *dev = &card->wavefront;\r\nif ((wavefront_status(dev) & (STAT_INTR_READ|STAT_INTR_WRITE)) == 0) {\r\nreturn;\r\n}\r\nspin_lock(&dev->irq_lock);\r\ndev->irq_ok = 1;\r\ndev->irq_cnt++;\r\nspin_unlock(&dev->irq_lock);\r\nwake_up(&dev->interrupt_sleeper);\r\n}\r\nstatic int\r\nsnd_wavefront_interrupt_bits (int irq)\r\n{\r\nint bits;\r\nswitch (irq) {\r\ncase 9:\r\nbits = 0x00;\r\nbreak;\r\ncase 5:\r\nbits = 0x08;\r\nbreak;\r\ncase 12:\r\nbits = 0x10;\r\nbreak;\r\ncase 15:\r\nbits = 0x18;\r\nbreak;\r\ndefault:\r\nsnd_printk ("invalid IRQ %d\n", irq);\r\nbits = -1;\r\n}\r\nreturn bits;\r\n}\r\nstatic void\r\nwavefront_should_cause_interrupt (snd_wavefront_t *dev,\r\nint val, int port, unsigned long timeout)\r\n{\r\nwait_queue_t wait;\r\ninit_waitqueue_entry(&wait, current);\r\nspin_lock_irq(&dev->irq_lock);\r\nadd_wait_queue(&dev->interrupt_sleeper, &wait);\r\ndev->irq_ok = 0;\r\noutb (val,port);\r\nspin_unlock_irq(&dev->irq_lock);\r\nwhile (!dev->irq_ok && time_before(jiffies, timeout)) {\r\nschedule_timeout_uninterruptible(1);\r\nbarrier();\r\n}\r\n}\r\nstatic int\r\nwavefront_reset_to_cleanliness (snd_wavefront_t *dev)\r\n{\r\nint bits;\r\nint hwv[2];\r\nbits = snd_wavefront_interrupt_bits (dev->irq);\r\noutb (0x0, dev->control_port);\r\noutb (0x80 | 0x40 | bits, dev->data_port);\r\nwavefront_should_cause_interrupt(dev, 0x80|0x40|0x10|0x1,\r\ndev->control_port,\r\n(reset_time*HZ)/100);\r\nif (!dev->irq_ok) {\r\nsnd_printk ("intr not received after h/w un-reset.\n");\r\ngoto gone_bad;\r\n}\r\nwavefront_should_cause_interrupt(dev, WFC_HARDWARE_VERSION,\r\ndev->data_port, ramcheck_time*HZ);\r\nif (!dev->irq_ok) {\r\nsnd_printk ("post-RAM-check interrupt not received.\n");\r\ngoto gone_bad;\r\n}\r\nif (!wavefront_wait (dev, STAT_CAN_READ)) {\r\nsnd_printk ("no response to HW version cmd.\n");\r\ngoto gone_bad;\r\n}\r\nif ((hwv[0] = wavefront_read (dev)) == -1) {\r\nsnd_printk ("board not responding correctly.\n");\r\ngoto gone_bad;\r\n}\r\nif (hwv[0] == 0xFF) {\r\nif ((hwv[0] = wavefront_read (dev)) == -1) {\r\nsnd_printk ("on-board RAM test failed "\r\n"(bad error code).\n");\r\n} else {\r\nsnd_printk ("on-board RAM test failed "\r\n"(error code: 0x%x).\n",\r\nhwv[0]);\r\n}\r\ngoto gone_bad;\r\n}\r\nif ((hwv[1] = wavefront_read (dev)) == -1) {\r\nsnd_printk ("incorrect h/w response.\n");\r\ngoto gone_bad;\r\n}\r\nsnd_printk ("hardware version %d.%d\n",\r\nhwv[0], hwv[1]);\r\nreturn 0;\r\ngone_bad:\r\nreturn (1);\r\n}\r\nstatic int\r\nwavefront_download_firmware (snd_wavefront_t *dev, char *path)\r\n{\r\nconst unsigned char *buf;\r\nint len, err;\r\nint section_cnt_downloaded = 0;\r\nconst struct firmware *firmware;\r\nerr = request_firmware(&firmware, path, dev->card->dev);\r\nif (err < 0) {\r\nsnd_printk(KERN_ERR "firmware (%s) download failed!!!\n", path);\r\nreturn 1;\r\n}\r\nlen = 0;\r\nbuf = firmware->data;\r\nfor (;;) {\r\nint section_length = *(signed char *)buf;\r\nif (section_length == 0)\r\nbreak;\r\nif (section_length < 0 || section_length > WF_SECTION_MAX) {\r\nsnd_printk(KERN_ERR\r\n"invalid firmware section length %d\n",\r\nsection_length);\r\ngoto failure;\r\n}\r\nbuf++;\r\nlen++;\r\nif (firmware->size < len + section_length) {\r\nsnd_printk(KERN_ERR "firmware section read error.\n");\r\ngoto failure;\r\n}\r\nif (wavefront_write(dev, WFC_DOWNLOAD_OS))\r\ngoto failure;\r\nfor (; section_length; section_length--) {\r\nif (wavefront_write(dev, *buf))\r\ngoto failure;\r\nbuf++;\r\nlen++;\r\n}\r\nif (!wavefront_wait(dev, STAT_CAN_READ)) {\r\nsnd_printk(KERN_ERR "time out for firmware ACK.\n");\r\ngoto failure;\r\n}\r\nerr = inb(dev->data_port);\r\nif (err != WF_ACK) {\r\nsnd_printk(KERN_ERR\r\n"download of section #%d not "\r\n"acknowledged, ack = 0x%x\n",\r\nsection_cnt_downloaded + 1, err);\r\ngoto failure;\r\n}\r\nsection_cnt_downloaded++;\r\n}\r\nrelease_firmware(firmware);\r\nreturn 0;\r\nfailure:\r\nrelease_firmware(firmware);\r\nsnd_printk(KERN_ERR "firmware download failed!!!\n");\r\nreturn 1;\r\n}\r\nstatic int\r\nwavefront_do_reset (snd_wavefront_t *dev)\r\n{\r\nchar voices[1];\r\nif (wavefront_reset_to_cleanliness (dev)) {\r\nsnd_printk ("hw reset failed.\n");\r\ngoto gone_bad;\r\n}\r\nif (dev->israw) {\r\nif (wavefront_download_firmware (dev, ospath)) {\r\ngoto gone_bad;\r\n}\r\ndev->israw = 0;\r\nwavefront_should_cause_interrupt (dev, WFC_NOOP,\r\ndev->data_port,\r\n(osrun_time*HZ));\r\nif (!dev->irq_ok) {\r\nsnd_printk ("no post-OS interrupt.\n");\r\ngoto gone_bad;\r\n}\r\nwavefront_should_cause_interrupt (dev, WFC_NOOP,\r\ndev->data_port, (10*HZ));\r\nif (!dev->irq_ok) {\r\nsnd_printk ("no post-OS interrupt(2).\n");\r\ngoto gone_bad;\r\n}\r\noutb (0x80|0x40, dev->control_port);\r\n}\r\nif ((dev->freemem = wavefront_freemem (dev)) < 0) {\r\ngoto gone_bad;\r\n}\r\nsnd_printk ("available DRAM %dk\n", dev->freemem / 1024);\r\nif (wavefront_write (dev, 0xf0) ||\r\nwavefront_write (dev, 1) ||\r\n(wavefront_read (dev) < 0)) {\r\ndev->debug = 0;\r\nsnd_printk ("MPU emulation mode not set.\n");\r\ngoto gone_bad;\r\n}\r\nvoices[0] = 32;\r\nif (snd_wavefront_cmd (dev, WFC_SET_NVOICES, NULL, voices)) {\r\nsnd_printk ("cannot set number of voices to 32.\n");\r\ngoto gone_bad;\r\n}\r\nreturn 0;\r\ngone_bad:\r\noutb (0x0, dev->control_port);\r\ndev->interrupts_are_midi = 0;\r\nreturn 1;\r\n}\r\nint\r\nsnd_wavefront_start (snd_wavefront_t *dev)\r\n{\r\nint samples_are_from_rom;\r\nif (dev->israw) {\r\nsamples_are_from_rom = 1;\r\n} else {\r\nsamples_are_from_rom = 0;\r\n}\r\nif (dev->israw || fx_raw) {\r\nif (wavefront_do_reset (dev)) {\r\nreturn -1;\r\n}\r\n}\r\ndev->has_fx = (snd_wavefront_fx_detect (dev) == 0);\r\nif (dev->has_fx && fx_raw) {\r\nsnd_wavefront_fx_start (dev);\r\n}\r\nwavefront_get_sample_status (dev, samples_are_from_rom);\r\nwavefront_get_program_status (dev);\r\nwavefront_get_patch_status (dev);\r\noutb (0x80|0x40|0x20, dev->control_port);\r\nreturn (0);\r\n}\r\nint\r\nsnd_wavefront_detect (snd_wavefront_card_t *card)\r\n{\r\nunsigned char rbuf[4], wbuf[4];\r\nsnd_wavefront_t *dev = &card->wavefront;\r\ndev->israw = 0;\r\ndev->has_fx = 0;\r\ndev->debug = debug_default;\r\ndev->interrupts_are_midi = 0;\r\ndev->irq_cnt = 0;\r\ndev->rom_samples_rdonly = 1;\r\nif (snd_wavefront_cmd (dev, WFC_FIRMWARE_VERSION, rbuf, wbuf) == 0) {\r\ndev->fw_version[0] = rbuf[0];\r\ndev->fw_version[1] = rbuf[1];\r\nsnd_printk ("firmware %d.%d already loaded.\n",\r\nrbuf[0], rbuf[1]);\r\nif (snd_wavefront_cmd (dev, WFC_HARDWARE_VERSION,\r\nrbuf, wbuf) == 0) {\r\ndev->hw_version[0] = rbuf[0];\r\ndev->hw_version[1] = rbuf[1];\r\n} else {\r\nsnd_printk ("not raw, but no "\r\n"hardware version!\n");\r\nreturn -1;\r\n}\r\nif (!wf_raw) {\r\nreturn 0;\r\n} else {\r\nsnd_printk ("reloading firmware as you requested.\n");\r\ndev->israw = 1;\r\n}\r\n} else {\r\ndev->israw = 1;\r\nsnd_printk ("no response to firmware probe, assume raw.\n");\r\n}\r\nreturn 0;\r\n}
