static void usb_hcd_tdi_set_mode(struct ehci_hcd *ehci)\r\n{\r\nu8 *base;\r\nu8 *statreg;\r\nu8 *fiforeg;\r\nu32 val;\r\nstruct ehci_regs *reg_base = ehci->regs;\r\nbase = (u8 *)reg_base + USB_EHCI_REG_USB_MODE;\r\nstatreg = (u8 *)reg_base + USB_EHCI_REG_USB_STATUS;\r\nfiforeg = (u8 *)reg_base + USB_EHCI_REG_USB_FIFO;\r\nval = ehci_readl(ehci, (u32 *)base);\r\nehci_writel(ehci, (val | USB_CTRL_MODE_STREAM_DISABLE),\r\n(u32 *)base);\r\nval = ehci_readl(ehci, (u32 *)statreg);\r\nval = val & ~USB_EHCI_REG_BIT_STAT_STS;\r\nehci_writel(ehci, val, (u32 *)statreg);\r\nehci_writel(ehci, USB_CTRL_FIFO_THRESH, (u32 *)fiforeg);\r\ngpio_direction_output(MSP_PIN_USB0_HOST_DEV, 1);\r\n#ifdef CONFIG_MSP_HAS_DUAL_USB\r\ngpio_direction_output(MSP_PIN_USB1_HOST_DEV, 1);\r\n#endif\r\n}\r\nstatic int ehci_msp_setup(struct usb_hcd *hcd)\r\n{\r\nstruct ehci_hcd *ehci = hcd_to_ehci(hcd);\r\nint retval;\r\nehci->big_endian_mmio = 1;\r\nehci->big_endian_desc = 1;\r\nehci->caps = hcd->regs;\r\nhcd->has_tt = 1;\r\nretval = ehci_setup(hcd);\r\nif (retval)\r\nreturn retval;\r\nusb_hcd_tdi_set_mode(ehci);\r\nreturn retval;\r\n}\r\nstatic int usb_hcd_msp_map_regs(struct mspusb_device *dev)\r\n{\r\nstruct resource *res;\r\nstruct platform_device *pdev = &dev->dev;\r\nu32 res_len;\r\nint retval;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 1);\r\nif (res == NULL)\r\nreturn -ENOMEM;\r\nres_len = resource_size(res);\r\nif (!request_mem_region(res->start, res_len, "mab regs"))\r\nreturn -EBUSY;\r\ndev->mab_regs = ioremap_nocache(res->start, res_len);\r\nif (dev->mab_regs == NULL) {\r\nretval = -ENOMEM;\r\ngoto err1;\r\n}\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 2);\r\nif (res == NULL) {\r\nretval = -ENOMEM;\r\ngoto err2;\r\n}\r\nres_len = resource_size(res);\r\nif (!request_mem_region(res->start, res_len, "usbid regs")) {\r\nretval = -EBUSY;\r\ngoto err2;\r\n}\r\ndev->usbid_regs = ioremap_nocache(res->start, res_len);\r\nif (dev->usbid_regs == NULL) {\r\nretval = -ENOMEM;\r\ngoto err3;\r\n}\r\nreturn 0;\r\nerr3:\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 2);\r\nres_len = resource_size(res);\r\nrelease_mem_region(res->start, res_len);\r\nerr2:\r\niounmap(dev->mab_regs);\r\nerr1:\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 1);\r\nres_len = resource_size(res);\r\nrelease_mem_region(res->start, res_len);\r\ndev_err(&pdev->dev, "Failed to map non-EHCI regs.\n");\r\nreturn retval;\r\n}\r\nint usb_hcd_msp_probe(const struct hc_driver *driver,\r\nstruct platform_device *dev)\r\n{\r\nint retval;\r\nstruct usb_hcd *hcd;\r\nstruct resource *res;\r\nstruct ehci_hcd *ehci ;\r\nhcd = usb_create_hcd(driver, &dev->dev, "pmcmsp");\r\nif (!hcd)\r\nreturn -ENOMEM;\r\nres = platform_get_resource(dev, IORESOURCE_MEM, 0);\r\nif (res == NULL) {\r\npr_debug("No IOMEM resource info for %s.\n", dev->name);\r\nretval = -ENOMEM;\r\ngoto err1;\r\n}\r\nhcd->rsrc_start = res->start;\r\nhcd->rsrc_len = resource_size(res);\r\nif (!request_mem_region(hcd->rsrc_start, hcd->rsrc_len, dev->name)) {\r\nretval = -EBUSY;\r\ngoto err1;\r\n}\r\nhcd->regs = ioremap_nocache(hcd->rsrc_start, hcd->rsrc_len);\r\nif (!hcd->regs) {\r\npr_debug("ioremap failed");\r\nretval = -ENOMEM;\r\ngoto err2;\r\n}\r\nres = platform_get_resource(dev, IORESOURCE_IRQ, 0);\r\nif (res == NULL) {\r\ndev_err(&dev->dev, "No IRQ resource info for %s.\n", dev->name);\r\nretval = -ENOMEM;\r\ngoto err3;\r\n}\r\nretval = usb_hcd_msp_map_regs(to_mspusb_device(dev));\r\nif (retval != 0)\r\ngoto err3;\r\nehci = hcd_to_ehci(hcd);\r\nehci->big_endian_mmio = 1;\r\nehci->big_endian_desc = 1;\r\nretval = usb_add_hcd(hcd, res->start, IRQF_SHARED);\r\nif (retval == 0)\r\nreturn 0;\r\nusb_remove_hcd(hcd);\r\nerr3:\r\niounmap(hcd->regs);\r\nerr2:\r\nrelease_mem_region(hcd->rsrc_start, hcd->rsrc_len);\r\nerr1:\r\nusb_put_hcd(hcd);\r\nreturn retval;\r\n}\r\nvoid usb_hcd_msp_remove(struct usb_hcd *hcd, struct platform_device *dev)\r\n{\r\nusb_remove_hcd(hcd);\r\niounmap(hcd->regs);\r\nrelease_mem_region(hcd->rsrc_start, hcd->rsrc_len);\r\nusb_put_hcd(hcd);\r\n}\r\nstatic irqreturn_t ehci_msp_irq(struct usb_hcd *hcd)\r\n{\r\nu32 int_src;\r\nstruct device *dev = hcd->self.controller;\r\nstruct platform_device *pdev;\r\nstruct mspusb_device *mdev;\r\nstruct ehci_hcd *ehci = hcd_to_ehci(hcd);\r\npdev = to_platform_device(dev);\r\nmdev = to_mspusb_device(pdev);\r\nint_src = ehci_readl(ehci, &mdev->mab_regs->int_stat);\r\nif (int_src & (1 << pdev->id))\r\nreturn ehci_irq(hcd);\r\nreturn IRQ_NONE;\r\n}\r\nstatic int ehci_hcd_msp_drv_probe(struct platform_device *pdev)\r\n{\r\nint ret;\r\npr_debug("In ehci_hcd_msp_drv_probe");\r\nif (usb_disabled())\r\nreturn -ENODEV;\r\ngpio_request(MSP_PIN_USB0_HOST_DEV, "USB0_HOST_DEV_GPIO");\r\n#ifdef CONFIG_MSP_HAS_DUAL_USB\r\ngpio_request(MSP_PIN_USB1_HOST_DEV, "USB1_HOST_DEV_GPIO");\r\n#endif\r\nret = usb_hcd_msp_probe(&ehci_msp_hc_driver, pdev);\r\nreturn ret;\r\n}\r\nstatic int ehci_hcd_msp_drv_remove(struct platform_device *pdev)\r\n{\r\nstruct usb_hcd *hcd = platform_get_drvdata(pdev);\r\nusb_hcd_msp_remove(hcd, pdev);\r\ngpio_free(MSP_PIN_USB0_HOST_DEV);\r\n#ifdef CONFIG_MSP_HAS_DUAL_USB\r\ngpio_free(MSP_PIN_USB1_HOST_DEV);\r\n#endif\r\nreturn 0;\r\n}
