void pt_regs_to_gdb_regs(unsigned long *gdb_regs, struct pt_regs *regs)\r\n{\r\nstruct reg_window *win;\r\nint i;\r\ngdb_regs[GDB_G0] = 0;\r\nfor (i = 0; i < 15; i++)\r\ngdb_regs[GDB_G1 + i] = regs->u_regs[UREG_G1 + i];\r\nwin = (struct reg_window *) (regs->u_regs[UREG_FP] + STACK_BIAS);\r\nfor (i = 0; i < 8; i++)\r\ngdb_regs[GDB_L0 + i] = win->locals[i];\r\nfor (i = 0; i < 8; i++)\r\ngdb_regs[GDB_I0 + i] = win->ins[i];\r\nfor (i = GDB_F0; i <= GDB_F62; i++)\r\ngdb_regs[i] = 0;\r\ngdb_regs[GDB_PC] = regs->tpc;\r\ngdb_regs[GDB_NPC] = regs->tnpc;\r\ngdb_regs[GDB_STATE] = regs->tstate;\r\ngdb_regs[GDB_FSR] = 0;\r\ngdb_regs[GDB_FPRS] = 0;\r\ngdb_regs[GDB_Y] = regs->y;\r\n}\r\nvoid sleeping_thread_to_gdb_regs(unsigned long *gdb_regs, struct task_struct *p)\r\n{\r\nstruct thread_info *t = task_thread_info(p);\r\nextern unsigned int switch_to_pc;\r\nextern unsigned int ret_from_syscall;\r\nstruct reg_window *win;\r\nunsigned long pc, cwp;\r\nint i;\r\nfor (i = GDB_G0; i < GDB_G6; i++)\r\ngdb_regs[i] = 0;\r\ngdb_regs[GDB_G6] = (unsigned long) t;\r\ngdb_regs[GDB_G7] = (unsigned long) p;\r\nfor (i = GDB_O0; i < GDB_SP; i++)\r\ngdb_regs[i] = 0;\r\ngdb_regs[GDB_SP] = t->ksp;\r\ngdb_regs[GDB_O7] = 0;\r\nwin = (struct reg_window *) (t->ksp + STACK_BIAS);\r\nfor (i = 0; i < 8; i++)\r\ngdb_regs[GDB_L0 + i] = win->locals[i];\r\nfor (i = 0; i < 8; i++)\r\ngdb_regs[GDB_I0 + i] = win->ins[i];\r\nfor (i = GDB_F0; i <= GDB_F62; i++)\r\ngdb_regs[i] = 0;\r\nif (t->new_child)\r\npc = (unsigned long) &ret_from_syscall;\r\nelse\r\npc = (unsigned long) &switch_to_pc;\r\ngdb_regs[GDB_PC] = pc;\r\ngdb_regs[GDB_NPC] = pc + 4;\r\ncwp = __thread_flag_byte_ptr(t)[TI_FLAG_BYTE_CWP];\r\ngdb_regs[GDB_STATE] = (TSTATE_PRIV | TSTATE_IE | cwp);\r\ngdb_regs[GDB_FSR] = 0;\r\ngdb_regs[GDB_FPRS] = 0;\r\ngdb_regs[GDB_Y] = 0;\r\n}\r\nvoid gdb_regs_to_pt_regs(unsigned long *gdb_regs, struct pt_regs *regs)\r\n{\r\nstruct reg_window *win;\r\nint i;\r\nfor (i = 0; i < 15; i++)\r\nregs->u_regs[UREG_G1 + i] = gdb_regs[GDB_G1 + i];\r\nif (regs->tstate != gdb_regs[GDB_STATE]) {\r\nunsigned long cwp = regs->tstate & TSTATE_CWP;\r\nregs->tstate = (gdb_regs[GDB_STATE] & ~TSTATE_CWP) | cwp;\r\n}\r\nregs->tpc = gdb_regs[GDB_PC];\r\nregs->tnpc = gdb_regs[GDB_NPC];\r\nregs->y = gdb_regs[GDB_Y];\r\nwin = (struct reg_window *) (regs->u_regs[UREG_FP] + STACK_BIAS);\r\nfor (i = 0; i < 8; i++)\r\nwin->locals[i] = gdb_regs[GDB_L0 + i];\r\nfor (i = 0; i < 8; i++)\r\nwin->ins[i] = gdb_regs[GDB_I0 + i];\r\n}\r\nvoid __irq_entry smp_kgdb_capture_client(int irq, struct pt_regs *regs)\r\n{\r\nunsigned long flags;\r\n__asm__ __volatile__("rdpr %%pstate, %0\n\t"\r\n"wrpr %0, %1, %%pstate"\r\n: "=r" (flags)\r\n: "i" (PSTATE_IE));\r\nflushw_all();\r\nif (atomic_read(&kgdb_active) != -1)\r\nkgdb_nmicallback(raw_smp_processor_id(), regs);\r\n__asm__ __volatile__("wrpr %0, 0, %%pstate"\r\n: : "r" (flags));\r\n}\r\nint kgdb_arch_handle_exception(int e_vector, int signo, int err_code,\r\nchar *remcomInBuffer, char *remcomOutBuffer,\r\nstruct pt_regs *linux_regs)\r\n{\r\nunsigned long addr;\r\nchar *ptr;\r\nswitch (remcomInBuffer[0]) {\r\ncase 'c':\r\nptr = &remcomInBuffer[1];\r\nif (kgdb_hex2long(&ptr, &addr)) {\r\nlinux_regs->tpc = addr;\r\nlinux_regs->tnpc = addr + 4;\r\n}\r\ncase 'D':\r\ncase 'k':\r\nif (linux_regs->tpc == (unsigned long) arch_kgdb_breakpoint) {\r\nlinux_regs->tpc = linux_regs->tnpc;\r\nlinux_regs->tnpc += 4;\r\n}\r\nreturn 0;\r\n}\r\nreturn -1;\r\n}\r\nasmlinkage void kgdb_trap(unsigned long trap_level, struct pt_regs *regs)\r\n{\r\nunsigned long flags;\r\nif (user_mode(regs)) {\r\nbad_trap(regs, trap_level);\r\nreturn;\r\n}\r\nflushw_all();\r\nlocal_irq_save(flags);\r\nkgdb_handle_exception(0x172, SIGTRAP, 0, regs);\r\nlocal_irq_restore(flags);\r\n}\r\nint kgdb_arch_init(void)\r\n{\r\nreturn 0;\r\n}\r\nvoid kgdb_arch_exit(void)\r\n{\r\n}\r\nvoid kgdb_arch_set_pc(struct pt_regs *regs, unsigned long ip)\r\n{\r\nregs->tpc = ip;\r\nregs->tnpc = regs->tpc + 4;\r\n}
