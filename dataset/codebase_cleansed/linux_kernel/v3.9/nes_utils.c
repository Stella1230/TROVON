static u32 nes_set_pau(struct nes_device *nesdev)\r\n{\r\nu32 ret = 0;\r\nu32 counter;\r\nnes_write_indexed(nesdev, NES_IDX_GPR2, NES_ENABLE_PAU);\r\nnes_write_indexed(nesdev, NES_IDX_GPR_TRIGGER, 1);\r\nfor (counter = 0; counter < NES_PAU_COUNTER; counter++) {\r\nudelay(30);\r\nif (!nes_read_indexed(nesdev, NES_IDX_GPR2)) {\r\nprintk(KERN_INFO PFX "PAU is supported.\n");\r\nbreak;\r\n}\r\nnes_write_indexed(nesdev, NES_IDX_GPR_TRIGGER, 1);\r\n}\r\nif (counter == NES_PAU_COUNTER) {\r\nprintk(KERN_INFO PFX "PAU is not supported.\n");\r\nreturn -EPERM;\r\n}\r\nreturn ret;\r\n}\r\nint nes_read_eeprom_values(struct nes_device *nesdev, struct nes_adapter *nesadapter)\r\n{\r\nu32 mac_addr_low;\r\nu16 mac_addr_high;\r\nu16 eeprom_data;\r\nu16 eeprom_offset;\r\nu16 next_section_address;\r\nu16 sw_section_ver;\r\nu8 major_ver = 0;\r\nu8 minor_ver = 0;\r\nif (nesadapter->firmware_eeprom_offset == 0) {\r\neeprom_data = nes_read16_eeprom(nesdev->regs, 0);\r\nnes_debug(NES_DBG_HW, "EEPROM Offset 0 = 0x%04X\n", eeprom_data);\r\neeprom_offset = 2 + (((eeprom_data & 0x007f) << 3) <<\r\n((eeprom_data & 0x0080) >> 7));\r\nnes_debug(NES_DBG_HW, "Firmware Offset = 0x%04X\n", eeprom_offset);\r\nnesadapter->firmware_eeprom_offset = eeprom_offset;\r\neeprom_data = nes_read16_eeprom(nesdev->regs, eeprom_offset + 4);\r\nif (eeprom_data != 0x5746) {\r\nnes_debug(NES_DBG_HW, "Not a valid Firmware Image = 0x%04X\n", eeprom_data);\r\nreturn -1;\r\n}\r\neeprom_data = nes_read16_eeprom(nesdev->regs, eeprom_offset + 2);\r\nnes_debug(NES_DBG_HW, "EEPROM Offset %u = 0x%04X\n",\r\neeprom_offset + 2, eeprom_data);\r\neeprom_offset += ((eeprom_data & 0x00ff) << 3) << ((eeprom_data & 0x0100) >> 8);\r\nnes_debug(NES_DBG_HW, "Software Offset = 0x%04X\n", eeprom_offset);\r\nnesadapter->software_eeprom_offset = eeprom_offset;\r\neeprom_data = nes_read16_eeprom(nesdev->regs, eeprom_offset + 4);\r\nif (eeprom_data != 0x5753) {\r\nprintk("Not a valid Software Image = 0x%04X\n", eeprom_data);\r\nreturn -1;\r\n}\r\nsw_section_ver = nes_read16_eeprom(nesdev->regs, nesadapter->software_eeprom_offset + 6);\r\nnes_debug(NES_DBG_HW, "Software section version number = 0x%04X\n",\r\nsw_section_ver);\r\neeprom_data = nes_read16_eeprom(nesdev->regs, eeprom_offset + 2);\r\nnes_debug(NES_DBG_HW, "EEPROM Offset %u (next section) = 0x%04X\n",\r\neeprom_offset + 2, eeprom_data);\r\nnext_section_address = eeprom_offset + (((eeprom_data & 0x00ff) << 3) <<\r\n((eeprom_data & 0x0100) >> 8));\r\neeprom_data = nes_read16_eeprom(nesdev->regs, next_section_address + 4);\r\nif (eeprom_data != 0x414d) {\r\nnes_debug(NES_DBG_HW, "EEPROM Changed offset should be 0x414d but was 0x%04X\n",\r\neeprom_data);\r\ngoto no_fw_rev;\r\n}\r\neeprom_offset = next_section_address;\r\neeprom_data = nes_read16_eeprom(nesdev->regs, eeprom_offset + 2);\r\nnes_debug(NES_DBG_HW, "EEPROM Offset %u (next section) = 0x%04X\n",\r\neeprom_offset + 2, eeprom_data);\r\nnext_section_address = eeprom_offset + (((eeprom_data & 0x00ff) << 3) <<\r\n((eeprom_data & 0x0100) >> 8));\r\neeprom_data = nes_read16_eeprom(nesdev->regs, next_section_address + 4);\r\nif (eeprom_data != 0x4f52) {\r\nnes_debug(NES_DBG_HW, "EEPROM Changed offset should be 0x4f52 but was 0x%04X\n",\r\neeprom_data);\r\ngoto no_fw_rev;\r\n}\r\neeprom_offset = next_section_address;\r\neeprom_data = nes_read16_eeprom(nesdev->regs, eeprom_offset + 2);\r\nnes_debug(NES_DBG_HW, "EEPROM Offset %u (next section) = 0x%04X\n",\r\neeprom_offset + 2, eeprom_data);\r\nnext_section_address = eeprom_offset + ((eeprom_data & 0x00ff) << 3);\r\neeprom_data = nes_read16_eeprom(nesdev->regs, next_section_address + 4);\r\nif (eeprom_data != 0x5746) {\r\nnes_debug(NES_DBG_HW, "EEPROM Changed offset should be 0x5746 but was 0x%04X\n",\r\neeprom_data);\r\ngoto no_fw_rev;\r\n}\r\neeprom_offset = next_section_address;\r\neeprom_data = nes_read16_eeprom(nesdev->regs, eeprom_offset + 2);\r\nnes_debug(NES_DBG_HW, "EEPROM Offset %u (next section) = 0x%04X\n",\r\neeprom_offset + 2, eeprom_data);\r\nnext_section_address = eeprom_offset + ((eeprom_data & 0x00ff) << 3);\r\neeprom_data = nes_read16_eeprom(nesdev->regs, next_section_address + 4);\r\nif (eeprom_data != 0x5753) {\r\nnes_debug(NES_DBG_HW, "EEPROM Changed offset should be 0x5753 but was 0x%04X\n",\r\neeprom_data);\r\ngoto no_fw_rev;\r\n}\r\neeprom_offset = next_section_address;\r\neeprom_data = nes_read16_eeprom(nesdev->regs, eeprom_offset + 2);\r\nnes_debug(NES_DBG_HW, "EEPROM Offset %u (next section) = 0x%04X\n",\r\neeprom_offset + 2, eeprom_data);\r\nnext_section_address = eeprom_offset + ((eeprom_data & 0x00ff) << 3);\r\neeprom_data = nes_read16_eeprom(nesdev->regs, next_section_address + 4);\r\nif (eeprom_data != 0x414d) {\r\nnes_debug(NES_DBG_HW, "EEPROM Changed offset should be 0x414d but was 0x%04X\n",\r\neeprom_data);\r\ngoto no_fw_rev;\r\n}\r\neeprom_offset = next_section_address;\r\neeprom_data = nes_read16_eeprom(nesdev->regs, eeprom_offset + 2);\r\nnes_debug(NES_DBG_HW, "EEPROM Offset %u (next section) = 0x%04X\n",\r\neeprom_offset + 2, eeprom_data);\r\nnext_section_address = eeprom_offset + ((eeprom_data & 0x00ff) << 3);\r\neeprom_data = nes_read16_eeprom(nesdev->regs, next_section_address + 4);\r\nif (eeprom_data != 0x464e) {\r\nnes_debug(NES_DBG_HW, "EEPROM Changed offset should be 0x464e but was 0x%04X\n",\r\neeprom_data);\r\ngoto no_fw_rev;\r\n}\r\neeprom_data = nes_read16_eeprom(nesdev->regs, next_section_address + 8);\r\nprintk(PFX "Firmware version %u.%u\n", (u8)(eeprom_data>>8), (u8)eeprom_data);\r\nmajor_ver = (u8)(eeprom_data >> 8);\r\nminor_ver = (u8)(eeprom_data);\r\nif (nes_drv_opt & NES_DRV_OPT_DISABLE_VIRT_WQ) {\r\nnes_debug(NES_DBG_HW, "Virtual WQs have been disabled\n");\r\n} else if (((major_ver == 2) && (minor_ver > 21)) || ((major_ver > 2) && (major_ver != 255))) {\r\nnesadapter->virtwq = 1;\r\n}\r\nif (((major_ver == 3) && (minor_ver >= 16)) || (major_ver > 3))\r\nnesadapter->send_term_ok = 1;\r\nif (nes_drv_opt & NES_DRV_OPT_ENABLE_PAU) {\r\nif (!nes_set_pau(nesdev))\r\nnesadapter->allow_unaligned_fpdus = 1;\r\n}\r\nnesadapter->firmware_version = (((u32)(u8)(eeprom_data>>8)) << 16) +\r\n(u32)((u8)eeprom_data);\r\neeprom_data = nes_read16_eeprom(nesdev->regs, next_section_address + 10);\r\nprintk(PFX "EEPROM version %u.%u\n", (u8)(eeprom_data>>8), (u8)eeprom_data);\r\nnesadapter->eeprom_version = (((u32)(u8)(eeprom_data>>8)) << 16) +\r\n(u32)((u8)eeprom_data);\r\nno_fw_rev:\r\neeprom_offset = nesadapter->software_eeprom_offset;\r\neeprom_offset += 8;\r\nnesadapter->netdev_max = (u8)nes_read16_eeprom(nesdev->regs, eeprom_offset);\r\neeprom_offset += 2;\r\nmac_addr_high = nes_read16_eeprom(nesdev->regs, eeprom_offset);\r\neeprom_offset += 2;\r\nmac_addr_low = (u32)nes_read16_eeprom(nesdev->regs, eeprom_offset);\r\neeprom_offset += 2;\r\nmac_addr_low <<= 16;\r\nmac_addr_low += (u32)nes_read16_eeprom(nesdev->regs, eeprom_offset);\r\nnes_debug(NES_DBG_HW, "Base MAC Address = 0x%04X%08X\n",\r\nmac_addr_high, mac_addr_low);\r\nnes_debug(NES_DBG_HW, "MAC Address count = %u\n", nesadapter->netdev_max);\r\nnesadapter->mac_addr_low = mac_addr_low;\r\nnesadapter->mac_addr_high = mac_addr_high;\r\neeprom_offset += 10;\r\neeprom_data = nes_read16_eeprom(nesdev->regs, eeprom_offset);\r\nnesadapter->phy_type[0] = (u8)(eeprom_data >> 8);\r\nnesadapter->phy_type[1] = (u8)eeprom_data;\r\neeprom_offset += 2;\r\neeprom_data = nes_read16_eeprom(nesdev->regs, eeprom_offset);\r\nnesadapter->phy_type[2] = (u8)(eeprom_data >> 8);\r\nnesadapter->phy_type[3] = (u8)eeprom_data;\r\nnes_debug(NES_DBG_HW, "port_count = %u, port 0 -> %u, port 1 -> %u,"\r\n" port 2 -> %u, port 3 -> %u\n",\r\nnesadapter->port_count,\r\nnesadapter->phy_type[0], nesadapter->phy_type[1],\r\nnesadapter->phy_type[2], nesadapter->phy_type[3]);\r\neeprom_offset += 10;\r\neeprom_data = nes_read16_eeprom(nesdev->regs, eeprom_offset);\r\nnesadapter->pd_config_size[0] = eeprom_data;\r\neeprom_offset += 2;\r\neeprom_data = nes_read16_eeprom(nesdev->regs, eeprom_offset);\r\nnesadapter->pd_config_base[0] = eeprom_data;\r\nnes_debug(NES_DBG_HW, "PD0 config, size=0x%04x, base=0x%04x\n",\r\nnesadapter->pd_config_size[0], nesadapter->pd_config_base[0]);\r\neeprom_offset += 2;\r\neeprom_data = nes_read16_eeprom(nesdev->regs, eeprom_offset);\r\nnesadapter->pd_config_size[1] = eeprom_data;\r\neeprom_offset += 2;\r\neeprom_data = nes_read16_eeprom(nesdev->regs, eeprom_offset);\r\nnesadapter->pd_config_base[1] = eeprom_data;\r\nnes_debug(NES_DBG_HW, "PD1 config, size=0x%04x, base=0x%04x\n",\r\nnesadapter->pd_config_size[1], nesadapter->pd_config_base[1]);\r\neeprom_offset += 2;\r\neeprom_data = nes_read16_eeprom(nesdev->regs, eeprom_offset);\r\nnesadapter->pd_config_size[2] = eeprom_data;\r\neeprom_offset += 2;\r\neeprom_data = nes_read16_eeprom(nesdev->regs, eeprom_offset);\r\nnesadapter->pd_config_base[2] = eeprom_data;\r\nnes_debug(NES_DBG_HW, "PD2 config, size=0x%04x, base=0x%04x\n",\r\nnesadapter->pd_config_size[2], nesadapter->pd_config_base[2]);\r\neeprom_offset += 2;\r\neeprom_data = nes_read16_eeprom(nesdev->regs, eeprom_offset);\r\nnesadapter->pd_config_size[3] = eeprom_data;\r\neeprom_offset += 2;\r\neeprom_data = nes_read16_eeprom(nesdev->regs, eeprom_offset);\r\nnesadapter->pd_config_base[3] = eeprom_data;\r\nnes_debug(NES_DBG_HW, "PD3 config, size=0x%04x, base=0x%04x\n",\r\nnesadapter->pd_config_size[3], nesadapter->pd_config_base[3]);\r\neeprom_offset += 22;\r\neeprom_data = nes_read16_eeprom(nesdev->regs, eeprom_offset);\r\neeprom_offset += 2;\r\nnesadapter->rx_pool_size = (((u32)eeprom_data) << 16) +\r\nnes_read16_eeprom(nesdev->regs, eeprom_offset);\r\nnes_debug(NES_DBG_HW, "rx_pool_size = 0x%08X\n", nesadapter->rx_pool_size);\r\neeprom_offset += 2;\r\neeprom_data = nes_read16_eeprom(nesdev->regs, eeprom_offset);\r\neeprom_offset += 2;\r\nnesadapter->tx_pool_size = (((u32)eeprom_data) << 16) +\r\nnes_read16_eeprom(nesdev->regs, eeprom_offset);\r\nnes_debug(NES_DBG_HW, "tx_pool_size = 0x%08X\n", nesadapter->tx_pool_size);\r\neeprom_offset += 2;\r\neeprom_data = nes_read16_eeprom(nesdev->regs, eeprom_offset);\r\neeprom_offset += 2;\r\nnesadapter->rx_threshold = (((u32)eeprom_data) << 16) +\r\nnes_read16_eeprom(nesdev->regs, eeprom_offset);\r\nnes_debug(NES_DBG_HW, "rx_threshold = 0x%08X\n", nesadapter->rx_threshold);\r\neeprom_offset += 2;\r\neeprom_data = nes_read16_eeprom(nesdev->regs, eeprom_offset);\r\neeprom_offset += 2;\r\nnesadapter->tcp_timer_core_clk_divisor = (((u32)eeprom_data) << 16) +\r\nnes_read16_eeprom(nesdev->regs, eeprom_offset);\r\nnes_debug(NES_DBG_HW, "tcp_timer_core_clk_divisor = 0x%08X\n",\r\nnesadapter->tcp_timer_core_clk_divisor);\r\neeprom_offset += 2;\r\neeprom_data = nes_read16_eeprom(nesdev->regs, eeprom_offset);\r\neeprom_offset += 2;\r\nnesadapter->iwarp_config = (((u32)eeprom_data) << 16) +\r\nnes_read16_eeprom(nesdev->regs, eeprom_offset);\r\nnes_debug(NES_DBG_HW, "iwarp_config = 0x%08X\n", nesadapter->iwarp_config);\r\neeprom_offset += 2;\r\neeprom_data = nes_read16_eeprom(nesdev->regs, eeprom_offset);\r\neeprom_offset += 2;\r\nnesadapter->cm_config = (((u32)eeprom_data) << 16) +\r\nnes_read16_eeprom(nesdev->regs, eeprom_offset);\r\nnes_debug(NES_DBG_HW, "cm_config = 0x%08X\n", nesadapter->cm_config);\r\neeprom_offset += 2;\r\neeprom_data = nes_read16_eeprom(nesdev->regs, eeprom_offset);\r\neeprom_offset += 2;\r\nnesadapter->sws_timer_config = (((u32)eeprom_data) << 16) +\r\nnes_read16_eeprom(nesdev->regs, eeprom_offset);\r\nnes_debug(NES_DBG_HW, "sws_timer_config = 0x%08X\n", nesadapter->sws_timer_config);\r\neeprom_offset += 2;\r\neeprom_data = nes_read16_eeprom(nesdev->regs, eeprom_offset);\r\neeprom_offset += 2;\r\nnesadapter->tcp_config1 = (((u32)eeprom_data) << 16) +\r\nnes_read16_eeprom(nesdev->regs, eeprom_offset);\r\nnes_debug(NES_DBG_HW, "tcp_config1 = 0x%08X\n", nesadapter->tcp_config1);\r\neeprom_offset += 2;\r\neeprom_data = nes_read16_eeprom(nesdev->regs, eeprom_offset);\r\neeprom_offset += 2;\r\nnesadapter->wqm_wat = (((u32)eeprom_data) << 16) +\r\nnes_read16_eeprom(nesdev->regs, eeprom_offset);\r\nnes_debug(NES_DBG_HW, "wqm_wat = 0x%08X\n", nesadapter->wqm_wat);\r\neeprom_offset += 2;\r\neeprom_data = nes_read16_eeprom(nesdev->regs, eeprom_offset);\r\neeprom_offset += 2;\r\nnesadapter->core_clock = (((u32)eeprom_data) << 16) +\r\nnes_read16_eeprom(nesdev->regs, eeprom_offset);\r\nnes_debug(NES_DBG_HW, "core_clock = 0x%08X\n", nesadapter->core_clock);\r\nif ((sw_section_ver) && (nesadapter->hw_rev != NE020_REV)) {\r\neeprom_offset += 2;\r\neeprom_data = nes_read16_eeprom(nesdev->regs, eeprom_offset);\r\nnesadapter->phy_index[0] = (eeprom_data & 0xff00)>>8;\r\nnesadapter->phy_index[1] = eeprom_data & 0x00ff;\r\neeprom_offset += 2;\r\neeprom_data = nes_read16_eeprom(nesdev->regs, eeprom_offset);\r\nnesadapter->phy_index[2] = (eeprom_data & 0xff00)>>8;\r\nnesadapter->phy_index[3] = eeprom_data & 0x00ff;\r\n} else {\r\nnesadapter->phy_index[0] = 4;\r\nnesadapter->phy_index[1] = 5;\r\nnesadapter->phy_index[2] = 6;\r\nnesadapter->phy_index[3] = 7;\r\n}\r\nnes_debug(NES_DBG_HW, "Phy address map = 0 > %u, 1 > %u, 2 > %u, 3 > %u\n",\r\nnesadapter->phy_index[0],nesadapter->phy_index[1],\r\nnesadapter->phy_index[2],nesadapter->phy_index[3]);\r\n}\r\nreturn 0;\r\n}\r\nstatic u16 nes_read16_eeprom(void __iomem *addr, u16 offset)\r\n{\r\nwritel(NES_EEPROM_READ_REQUEST + (offset >> 1),\r\n(void __iomem *)addr + NES_EEPROM_COMMAND);\r\ndo {\r\n} while (readl((void __iomem *)addr + NES_EEPROM_COMMAND) &\r\nNES_EEPROM_READ_REQUEST);\r\nreturn readw((void __iomem *)addr + NES_EEPROM_DATA);\r\n}\r\nvoid nes_write_1G_phy_reg(struct nes_device *nesdev, u8 phy_reg, u8 phy_addr, u16 data)\r\n{\r\nu32 u32temp;\r\nu32 counter;\r\nnes_write_indexed(nesdev, NES_IDX_MAC_MDIO_CONTROL,\r\n0x50020000 | data | ((u32)phy_reg << 18) | ((u32)phy_addr << 23));\r\nfor (counter = 0; counter < 100 ; counter++) {\r\nudelay(30);\r\nu32temp = nes_read_indexed(nesdev, NES_IDX_MAC_INT_STATUS);\r\nif (u32temp & 1) {\r\nnes_write_indexed(nesdev, NES_IDX_MAC_INT_STATUS, 1);\r\nbreak;\r\n}\r\n}\r\nif (!(u32temp & 1))\r\nnes_debug(NES_DBG_PHY, "Phy is not responding. interrupt status = 0x%X.\n",\r\nu32temp);\r\n}\r\nvoid nes_read_1G_phy_reg(struct nes_device *nesdev, u8 phy_reg, u8 phy_addr, u16 *data)\r\n{\r\nu32 u32temp;\r\nu32 counter;\r\nnes_write_indexed(nesdev, NES_IDX_MAC_MDIO_CONTROL,\r\n0x60020000 | ((u32)phy_reg << 18) | ((u32)phy_addr << 23));\r\nfor (counter = 0; counter < 100 ; counter++) {\r\nudelay(30);\r\nu32temp = nes_read_indexed(nesdev, NES_IDX_MAC_INT_STATUS);\r\nif (u32temp & 1) {\r\nnes_write_indexed(nesdev, NES_IDX_MAC_INT_STATUS, 1);\r\nbreak;\r\n}\r\n}\r\nif (!(u32temp & 1)) {\r\nnes_debug(NES_DBG_PHY, "Phy is not responding. interrupt status = 0x%X.\n",\r\nu32temp);\r\n*data = 0xffff;\r\n} else {\r\n*data = (u16)nes_read_indexed(nesdev, NES_IDX_MAC_MDIO_CONTROL);\r\n}\r\n}\r\nvoid nes_write_10G_phy_reg(struct nes_device *nesdev, u16 phy_addr, u8 dev_addr, u16 phy_reg,\r\nu16 data)\r\n{\r\nu32 port_addr;\r\nu32 u32temp;\r\nu32 counter;\r\nport_addr = phy_addr;\r\nnes_write_indexed(nesdev, NES_IDX_MAC_MDIO_CONTROL,\r\n0x00020000 | (u32)phy_reg | (((u32)dev_addr) << 18) | (((u32)port_addr) << 23));\r\nfor (counter = 0; counter < 100 ; counter++) {\r\nudelay(30);\r\nu32temp = nes_read_indexed(nesdev, NES_IDX_MAC_INT_STATUS);\r\nif (u32temp & 1) {\r\nnes_write_indexed(nesdev, NES_IDX_MAC_INT_STATUS, 1);\r\nbreak;\r\n}\r\n}\r\nif (!(u32temp & 1))\r\nnes_debug(NES_DBG_PHY, "Phy is not responding. interrupt status = 0x%X.\n",\r\nu32temp);\r\nnes_write_indexed(nesdev, NES_IDX_MAC_MDIO_CONTROL,\r\n0x10020000 | (u32)data | (((u32)dev_addr) << 18) | (((u32)port_addr) << 23));\r\nfor (counter = 0; counter < 100 ; counter++) {\r\nudelay(30);\r\nu32temp = nes_read_indexed(nesdev, NES_IDX_MAC_INT_STATUS);\r\nif (u32temp & 1) {\r\nnes_write_indexed(nesdev, NES_IDX_MAC_INT_STATUS, 1);\r\nbreak;\r\n}\r\n}\r\nif (!(u32temp & 1))\r\nnes_debug(NES_DBG_PHY, "Phy is not responding. interrupt status = 0x%X.\n",\r\nu32temp);\r\n}\r\nvoid nes_read_10G_phy_reg(struct nes_device *nesdev, u8 phy_addr, u8 dev_addr, u16 phy_reg)\r\n{\r\nu32 port_addr;\r\nu32 u32temp;\r\nu32 counter;\r\nport_addr = phy_addr;\r\nnes_write_indexed(nesdev, NES_IDX_MAC_MDIO_CONTROL,\r\n0x00020000 | (u32)phy_reg | (((u32)dev_addr) << 18) | (((u32)port_addr) << 23));\r\nfor (counter = 0; counter < 100 ; counter++) {\r\nudelay(30);\r\nu32temp = nes_read_indexed(nesdev, NES_IDX_MAC_INT_STATUS);\r\nif (u32temp & 1) {\r\nnes_write_indexed(nesdev, NES_IDX_MAC_INT_STATUS, 1);\r\nbreak;\r\n}\r\n}\r\nif (!(u32temp & 1))\r\nnes_debug(NES_DBG_PHY, "Phy is not responding. interrupt status = 0x%X.\n",\r\nu32temp);\r\nnes_write_indexed(nesdev, NES_IDX_MAC_MDIO_CONTROL,\r\n0x30020000 | (((u32)dev_addr) << 18) | (((u32)port_addr) << 23));\r\nfor (counter = 0; counter < 100 ; counter++) {\r\nudelay(30);\r\nu32temp = nes_read_indexed(nesdev, NES_IDX_MAC_INT_STATUS);\r\nif (u32temp & 1) {\r\nnes_write_indexed(nesdev, NES_IDX_MAC_INT_STATUS, 1);\r\nbreak;\r\n}\r\n}\r\nif (!(u32temp & 1))\r\nnes_debug(NES_DBG_PHY, "Phy is not responding. interrupt status = 0x%X.\n",\r\nu32temp);\r\n}\r\nstruct nes_cqp_request *nes_get_cqp_request(struct nes_device *nesdev)\r\n{\r\nunsigned long flags;\r\nstruct nes_cqp_request *cqp_request = NULL;\r\nif (!list_empty(&nesdev->cqp_avail_reqs)) {\r\nspin_lock_irqsave(&nesdev->cqp.lock, flags);\r\nif (!list_empty(&nesdev->cqp_avail_reqs)) {\r\ncqp_request = list_entry(nesdev->cqp_avail_reqs.next,\r\nstruct nes_cqp_request, list);\r\nlist_del_init(&cqp_request->list);\r\n}\r\nspin_unlock_irqrestore(&nesdev->cqp.lock, flags);\r\n}\r\nif (cqp_request == NULL) {\r\ncqp_request = kzalloc(sizeof(struct nes_cqp_request), GFP_ATOMIC);\r\nif (cqp_request) {\r\ncqp_request->dynamic = 1;\r\nINIT_LIST_HEAD(&cqp_request->list);\r\n}\r\n}\r\nif (cqp_request) {\r\ninit_waitqueue_head(&cqp_request->waitq);\r\ncqp_request->waiting = 0;\r\ncqp_request->request_done = 0;\r\ncqp_request->callback = 0;\r\ninit_waitqueue_head(&cqp_request->waitq);\r\nnes_debug(NES_DBG_CQP, "Got cqp request %p from the available list \n",\r\ncqp_request);\r\n} else\r\nprintk(KERN_ERR PFX "%s: Could not allocated a CQP request.\n",\r\n__func__);\r\nreturn cqp_request;\r\n}\r\nvoid nes_free_cqp_request(struct nes_device *nesdev,\r\nstruct nes_cqp_request *cqp_request)\r\n{\r\nunsigned long flags;\r\nnes_debug(NES_DBG_CQP, "CQP request %p (opcode 0x%02X) freed.\n",\r\ncqp_request,\r\nle32_to_cpu(cqp_request->cqp_wqe.wqe_words[NES_CQP_WQE_OPCODE_IDX]) & 0x3f);\r\nif (cqp_request->dynamic) {\r\nkfree(cqp_request);\r\n} else {\r\nspin_lock_irqsave(&nesdev->cqp.lock, flags);\r\nlist_add_tail(&cqp_request->list, &nesdev->cqp_avail_reqs);\r\nspin_unlock_irqrestore(&nesdev->cqp.lock, flags);\r\n}\r\n}\r\nvoid nes_put_cqp_request(struct nes_device *nesdev,\r\nstruct nes_cqp_request *cqp_request)\r\n{\r\nif (atomic_dec_and_test(&cqp_request->refcount))\r\nnes_free_cqp_request(nesdev, cqp_request);\r\n}\r\nvoid nes_post_cqp_request(struct nes_device *nesdev,\r\nstruct nes_cqp_request *cqp_request)\r\n{\r\nstruct nes_hw_cqp_wqe *cqp_wqe;\r\nunsigned long flags;\r\nu32 cqp_head;\r\nu64 u64temp;\r\nu32 opcode;\r\nint ctx_index = NES_CQP_WQE_COMP_CTX_LOW_IDX;\r\nspin_lock_irqsave(&nesdev->cqp.lock, flags);\r\nif (((((nesdev->cqp.sq_tail+(nesdev->cqp.sq_size*2))-nesdev->cqp.sq_head) &\r\n(nesdev->cqp.sq_size - 1)) != 1)\r\n&& (list_empty(&nesdev->cqp_pending_reqs))) {\r\ncqp_head = nesdev->cqp.sq_head++;\r\nnesdev->cqp.sq_head &= nesdev->cqp.sq_size-1;\r\ncqp_wqe = &nesdev->cqp.sq_vbase[cqp_head];\r\nmemcpy(cqp_wqe, &cqp_request->cqp_wqe, sizeof(*cqp_wqe));\r\nopcode = le32_to_cpu(cqp_wqe->wqe_words[NES_CQP_WQE_OPCODE_IDX]);\r\nif ((opcode & NES_CQP_OPCODE_MASK) == NES_CQP_DOWNLOAD_SEGMENT)\r\nctx_index = NES_CQP_WQE_DL_COMP_CTX_LOW_IDX;\r\nbarrier();\r\nu64temp = (unsigned long)cqp_request;\r\nset_wqe_64bit_value(cqp_wqe->wqe_words, ctx_index, u64temp);\r\nnes_debug(NES_DBG_CQP, "CQP request (opcode 0x%02X), line 1 = 0x%08X put on CQPs SQ,"\r\n" request = %p, cqp_head = %u, cqp_tail = %u, cqp_size = %u,"\r\n" waiting = %d, refcount = %d.\n",\r\nopcode & NES_CQP_OPCODE_MASK,\r\nle32_to_cpu(cqp_wqe->wqe_words[NES_CQP_WQE_ID_IDX]), cqp_request,\r\nnesdev->cqp.sq_head, nesdev->cqp.sq_tail, nesdev->cqp.sq_size,\r\ncqp_request->waiting, atomic_read(&cqp_request->refcount));\r\nbarrier();\r\nnes_write32(nesdev->regs+NES_WQE_ALLOC, 0x01800000 | nesdev->cqp.qp_id);\r\nbarrier();\r\n} else {\r\nnes_debug(NES_DBG_CQP, "CQP request %p (opcode 0x%02X), line 1 = 0x%08X"\r\n" put on the pending queue.\n",\r\ncqp_request,\r\nle32_to_cpu(cqp_request->cqp_wqe.wqe_words[NES_CQP_WQE_OPCODE_IDX])&0x3f,\r\nle32_to_cpu(cqp_request->cqp_wqe.wqe_words[NES_CQP_WQE_ID_IDX]));\r\nlist_add_tail(&cqp_request->list, &nesdev->cqp_pending_reqs);\r\n}\r\nspin_unlock_irqrestore(&nesdev->cqp.lock, flags);\r\nreturn;\r\n}\r\nint nes_arp_table(struct nes_device *nesdev, u32 ip_addr, u8 *mac_addr, u32 action)\r\n{\r\nstruct nes_adapter *nesadapter = nesdev->nesadapter;\r\nint arp_index;\r\nint err = 0;\r\n__be32 tmp_addr;\r\nfor (arp_index = 0; (u32) arp_index < nesadapter->arp_table_size; arp_index++) {\r\nif (nesadapter->arp_table[arp_index].ip_addr == ip_addr)\r\nbreak;\r\n}\r\nif (action == NES_ARP_ADD) {\r\nif (arp_index != nesadapter->arp_table_size) {\r\nreturn -1;\r\n}\r\narp_index = 0;\r\nerr = nes_alloc_resource(nesadapter, nesadapter->allocated_arps,\r\nnesadapter->arp_table_size, (u32 *)&arp_index, &nesadapter->next_arp_index, NES_RESOURCE_ARP);\r\nif (err) {\r\nnes_debug(NES_DBG_NETDEV, "nes_alloc_resource returned error = %u\n", err);\r\nreturn err;\r\n}\r\nnes_debug(NES_DBG_NETDEV, "ADD, arp_index=%d\n", arp_index);\r\nnesadapter->arp_table[arp_index].ip_addr = ip_addr;\r\nmemcpy(nesadapter->arp_table[arp_index].mac_addr, mac_addr, ETH_ALEN);\r\nreturn arp_index;\r\n}\r\nif (arp_index == nesadapter->arp_table_size) {\r\ntmp_addr = cpu_to_be32(ip_addr);\r\nnes_debug(NES_DBG_NETDEV, "MAC for %pI4 not in ARP table - cannot %s\n",\r\n&tmp_addr, action == NES_ARP_RESOLVE ? "resolve" : "delete");\r\nreturn -1;\r\n}\r\nif (action == NES_ARP_RESOLVE) {\r\nnes_debug(NES_DBG_NETDEV, "RESOLVE, arp_index=%d\n", arp_index);\r\nreturn arp_index;\r\n}\r\nif (action == NES_ARP_DELETE) {\r\nnes_debug(NES_DBG_NETDEV, "DELETE, arp_index=%d\n", arp_index);\r\nnesadapter->arp_table[arp_index].ip_addr = 0;\r\nmemset(nesadapter->arp_table[arp_index].mac_addr, 0x00, ETH_ALEN);\r\nnes_free_resource(nesadapter, nesadapter->allocated_arps, arp_index);\r\nreturn arp_index;\r\n}\r\nreturn -1;\r\n}\r\nvoid nes_mh_fix(unsigned long parm)\r\n{\r\nunsigned long flags;\r\nstruct nes_device *nesdev = (struct nes_device *)parm;\r\nstruct nes_adapter *nesadapter = nesdev->nesadapter;\r\nstruct nes_vnic *nesvnic;\r\nu32 used_chunks_tx;\r\nu32 temp_used_chunks_tx;\r\nu32 temp_last_used_chunks_tx;\r\nu32 used_chunks_mask;\r\nu32 mac_tx_frames_low;\r\nu32 mac_tx_frames_high;\r\nu32 mac_tx_pauses;\r\nu32 serdes_status;\r\nu32 reset_value;\r\nu32 tx_control;\r\nu32 tx_config;\r\nu32 tx_pause_quanta;\r\nu32 rx_control;\r\nu32 rx_config;\r\nu32 mac_exact_match;\r\nu32 mpp_debug;\r\nu32 i=0;\r\nu32 chunks_tx_progress = 0;\r\nspin_lock_irqsave(&nesadapter->phy_lock, flags);\r\nif ((nesadapter->mac_sw_state[0] != NES_MAC_SW_IDLE) || (nesadapter->mac_link_down[0])) {\r\nspin_unlock_irqrestore(&nesadapter->phy_lock, flags);\r\ngoto no_mh_work;\r\n}\r\nnesadapter->mac_sw_state[0] = NES_MAC_SW_MH;\r\nspin_unlock_irqrestore(&nesadapter->phy_lock, flags);\r\ndo {\r\nmac_tx_frames_low = nes_read_indexed(nesdev, NES_IDX_MAC_TX_FRAMES_LOW);\r\nmac_tx_frames_high = nes_read_indexed(nesdev, NES_IDX_MAC_TX_FRAMES_HIGH);\r\nmac_tx_pauses = nes_read_indexed(nesdev, NES_IDX_MAC_TX_PAUSE_FRAMES);\r\nused_chunks_tx = nes_read_indexed(nesdev, NES_IDX_USED_CHUNKS_TX);\r\nnesdev->mac_pause_frames_sent += mac_tx_pauses;\r\nused_chunks_mask = 0;\r\ntemp_used_chunks_tx = used_chunks_tx;\r\ntemp_last_used_chunks_tx = nesdev->last_used_chunks_tx;\r\nif (nesdev->netdev[0]) {\r\nnesvnic = netdev_priv(nesdev->netdev[0]);\r\n} else {\r\nbreak;\r\n}\r\nfor (i=0; i<4; i++) {\r\nused_chunks_mask <<= 8;\r\nif (nesvnic->qp_nic_index[i] != 0xff) {\r\nused_chunks_mask |= 0xff;\r\nif ((temp_used_chunks_tx&0xff)<(temp_last_used_chunks_tx&0xff)) {\r\nchunks_tx_progress = 1;\r\n}\r\n}\r\ntemp_used_chunks_tx >>= 8;\r\ntemp_last_used_chunks_tx >>= 8;\r\n}\r\nif ((mac_tx_frames_low) || (mac_tx_frames_high) ||\r\n(!(used_chunks_tx&used_chunks_mask)) ||\r\n(!(nesdev->last_used_chunks_tx&used_chunks_mask)) ||\r\n(chunks_tx_progress) ) {\r\nnesdev->last_used_chunks_tx = used_chunks_tx;\r\nbreak;\r\n}\r\nnesdev->last_used_chunks_tx = used_chunks_tx;\r\nbarrier();\r\nnes_write_indexed(nesdev, NES_IDX_MAC_TX_CONTROL, 0x00000005);\r\nmh_pauses_sent++;\r\nmac_tx_pauses = nes_read_indexed(nesdev, NES_IDX_MAC_TX_PAUSE_FRAMES);\r\nif (mac_tx_pauses) {\r\nnesdev->mac_pause_frames_sent += mac_tx_pauses;\r\nbreak;\r\n}\r\ntx_control = nes_read_indexed(nesdev, NES_IDX_MAC_TX_CONTROL);\r\ntx_config = nes_read_indexed(nesdev, NES_IDX_MAC_TX_CONFIG);\r\ntx_pause_quanta = nes_read_indexed(nesdev, NES_IDX_MAC_TX_PAUSE_QUANTA);\r\nrx_control = nes_read_indexed(nesdev, NES_IDX_MAC_RX_CONTROL);\r\nrx_config = nes_read_indexed(nesdev, NES_IDX_MAC_RX_CONFIG);\r\nmac_exact_match = nes_read_indexed(nesdev, NES_IDX_MAC_EXACT_MATCH_BOTTOM);\r\nmpp_debug = nes_read_indexed(nesdev, NES_IDX_MPP_DEBUG);\r\nmac_tx_pauses = nes_read_indexed(nesdev, NES_IDX_MAC_TX_PAUSE_FRAMES);\r\nif (mac_tx_pauses) {\r\nnesdev->last_mac_tx_pauses = nesdev->mac_pause_frames_sent;\r\nnes_debug(NES_DBG_HW, "failsafe caught slow outbound pause\n");\r\nbreak;\r\n}\r\nmh_detected++;\r\nnes_write_indexed(nesdev, NES_IDX_MAC_TX_CONTROL, 0x00000000);\r\nnes_write_indexed(nesdev, NES_IDX_MAC_TX_CONFIG, 0x00000000);\r\nreset_value = nes_read32(nesdev->regs+NES_SOFTWARE_RESET);\r\nnes_write32(nesdev->regs+NES_SOFTWARE_RESET, reset_value | 0x0000001d);\r\nwhile (((nes_read32(nesdev->regs+NES_SOFTWARE_RESET)\r\n& 0x00000040) != 0x00000040) && (i++ < 5000)) {\r\n}\r\nnes_write_indexed(nesdev, NES_IDX_ETH_SERDES_COMMON_CONTROL0, 0x00000008);\r\nserdes_status = nes_read_indexed(nesdev, NES_IDX_ETH_SERDES_COMMON_STATUS0);\r\nnes_write_indexed(nesdev, NES_IDX_ETH_SERDES_TX_EMP0, 0x000bdef7);\r\nnes_write_indexed(nesdev, NES_IDX_ETH_SERDES_TX_DRIVE0, 0x9ce73000);\r\nnes_write_indexed(nesdev, NES_IDX_ETH_SERDES_RX_MODE0, 0x0ff00000);\r\nnes_write_indexed(nesdev, NES_IDX_ETH_SERDES_RX_SIGDET0, 0x00000000);\r\nnes_write_indexed(nesdev, NES_IDX_ETH_SERDES_BYPASS0, 0x00000000);\r\nnes_write_indexed(nesdev, NES_IDX_ETH_SERDES_LOOPBACK_CONTROL0, 0x00000000);\r\nif (nesadapter->OneG_Mode) {\r\nnes_write_indexed(nesdev, NES_IDX_ETH_SERDES_RX_EQ_CONTROL0, 0xf0182222);\r\n} else {\r\nnes_write_indexed(nesdev, NES_IDX_ETH_SERDES_RX_EQ_CONTROL0, 0xf0042222);\r\n}\r\nserdes_status = nes_read_indexed(nesdev, NES_IDX_ETH_SERDES_RX_EQ_STATUS0);\r\nnes_write_indexed(nesdev, NES_IDX_ETH_SERDES_CDR_CONTROL0, 0x000000ff);\r\nnes_write_indexed(nesdev, NES_IDX_MAC_TX_CONTROL, tx_control);\r\nnes_write_indexed(nesdev, NES_IDX_MAC_TX_CONFIG, tx_config);\r\nnes_write_indexed(nesdev, NES_IDX_MAC_TX_PAUSE_QUANTA, tx_pause_quanta);\r\nnes_write_indexed(nesdev, NES_IDX_MAC_RX_CONTROL, rx_control);\r\nnes_write_indexed(nesdev, NES_IDX_MAC_RX_CONFIG, rx_config);\r\nnes_write_indexed(nesdev, NES_IDX_MAC_EXACT_MATCH_BOTTOM, mac_exact_match);\r\nnes_write_indexed(nesdev, NES_IDX_MPP_DEBUG, mpp_debug);\r\n} while (0);\r\nnesadapter->mac_sw_state[0] = NES_MAC_SW_IDLE;\r\nno_mh_work:\r\nnesdev->nesadapter->mh_timer.expires = jiffies + (HZ/5);\r\nadd_timer(&nesdev->nesadapter->mh_timer);\r\n}\r\nvoid nes_clc(unsigned long parm)\r\n{\r\nunsigned long flags;\r\nstruct nes_device *nesdev = (struct nes_device *)parm;\r\nstruct nes_adapter *nesadapter = nesdev->nesadapter;\r\nspin_lock_irqsave(&nesadapter->phy_lock, flags);\r\nnesadapter->link_interrupt_count[0] = 0;\r\nnesadapter->link_interrupt_count[1] = 0;\r\nnesadapter->link_interrupt_count[2] = 0;\r\nnesadapter->link_interrupt_count[3] = 0;\r\nspin_unlock_irqrestore(&nesadapter->phy_lock, flags);\r\nnesadapter->lc_timer.expires = jiffies + 3600 * HZ;\r\nadd_timer(&nesadapter->lc_timer);\r\n}\r\nvoid nes_dump_mem(unsigned int dump_debug_level, void *addr, int length)\r\n{\r\nchar xlate[] = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9',\r\n'a', 'b', 'c', 'd', 'e', 'f'};\r\nchar *ptr;\r\nchar hex_buf[80];\r\nchar ascii_buf[20];\r\nint num_char;\r\nint num_ascii;\r\nint num_hex;\r\nif (!(nes_debug_level & dump_debug_level)) {\r\nreturn;\r\n}\r\nptr = addr;\r\nif (length > 0x100) {\r\nnes_debug(dump_debug_level, "Length truncated from %x to %x\n", length, 0x100);\r\nlength = 0x100;\r\n}\r\nnes_debug(dump_debug_level, "Address=0x%p, length=0x%x (%d)\n", ptr, length, length);\r\nmemset(ascii_buf, 0, 20);\r\nmemset(hex_buf, 0, 80);\r\nnum_ascii = 0;\r\nnum_hex = 0;\r\nfor (num_char = 0; num_char < length; num_char++) {\r\nif (num_ascii == 8) {\r\nascii_buf[num_ascii++] = ' ';\r\nhex_buf[num_hex++] = '-';\r\nhex_buf[num_hex++] = ' ';\r\n}\r\nif (*ptr < 0x20 || *ptr > 0x7e)\r\nascii_buf[num_ascii++] = '.';\r\nelse\r\nascii_buf[num_ascii++] = *ptr;\r\nhex_buf[num_hex++] = xlate[((*ptr & 0xf0) >> 4)];\r\nhex_buf[num_hex++] = xlate[*ptr & 0x0f];\r\nhex_buf[num_hex++] = ' ';\r\nptr++;\r\nif (num_ascii >= 17) {\r\nnes_debug(dump_debug_level, " %s | %s\n", hex_buf, ascii_buf);\r\nmemset(ascii_buf, 0, 20);\r\nmemset(hex_buf, 0, 80);\r\nnum_ascii = 0;\r\nnum_hex = 0;\r\n}\r\n}\r\nif (num_ascii) {\r\nwhile (num_ascii < 17) {\r\nif (num_ascii == 8) {\r\nhex_buf[num_hex++] = ' ';\r\nhex_buf[num_hex++] = ' ';\r\n}\r\nhex_buf[num_hex++] = ' ';\r\nhex_buf[num_hex++] = ' ';\r\nhex_buf[num_hex++] = ' ';\r\nnum_ascii++;\r\n}\r\nnes_debug(dump_debug_level, " %s | %s\n", hex_buf, ascii_buf);\r\n}\r\n}
