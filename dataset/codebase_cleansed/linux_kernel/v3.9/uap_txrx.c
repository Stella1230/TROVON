static void mwifiex_uap_queue_bridged_pkt(struct mwifiex_private *priv,\r\nstruct sk_buff *skb)\r\n{\r\nstruct mwifiex_adapter *adapter = priv->adapter;\r\nstruct uap_rxpd *uap_rx_pd;\r\nstruct rx_packet_hdr *rx_pkt_hdr;\r\nstruct sk_buff *new_skb;\r\nstruct mwifiex_txinfo *tx_info;\r\nint hdr_chop;\r\nstruct timeval tv;\r\nu8 rfc1042_eth_hdr[ETH_ALEN] = { 0xaa, 0xaa, 0x03, 0x00, 0x00, 0x00 };\r\nuap_rx_pd = (struct uap_rxpd *)(skb->data);\r\nrx_pkt_hdr = (void *)uap_rx_pd + le16_to_cpu(uap_rx_pd->rx_pkt_offset);\r\nif ((atomic_read(&adapter->pending_bridged_pkts) >=\r\nMWIFIEX_BRIDGED_PKTS_THRESHOLD)) {\r\ndev_err(priv->adapter->dev,\r\n"Tx: Bridge packet limit reached. Drop packet!\n");\r\nkfree_skb(skb);\r\nreturn;\r\n}\r\nif (!memcmp(&rx_pkt_hdr->rfc1042_hdr,\r\nrfc1042_eth_hdr, sizeof(rfc1042_eth_hdr)))\r\nhdr_chop = (u8 *)eth_hdr - (u8 *)uap_rx_pd;\r\nelse\r\nhdr_chop = (u8 *)&rx_pkt_hdr->eth803_hdr - (u8 *)uap_rx_pd;\r\nskb_pull(skb, hdr_chop);\r\nif (skb_headroom(skb) < MWIFIEX_MIN_DATA_HEADER_LEN) {\r\ndev_dbg(priv->adapter->dev,\r\n"data: Tx: insufficient skb headroom %d\n",\r\nskb_headroom(skb));\r\nnew_skb =\r\nskb_realloc_headroom(skb, MWIFIEX_MIN_DATA_HEADER_LEN);\r\nif (unlikely(!new_skb)) {\r\ndev_err(priv->adapter->dev,\r\n"Tx: cannot allocate new_skb\n");\r\nkfree_skb(skb);\r\npriv->stats.tx_dropped++;\r\nreturn;\r\n}\r\nkfree_skb(skb);\r\nskb = new_skb;\r\ndev_dbg(priv->adapter->dev, "info: new skb headroom %d\n",\r\nskb_headroom(skb));\r\n}\r\ntx_info = MWIFIEX_SKB_TXCB(skb);\r\ntx_info->bss_num = priv->bss_num;\r\ntx_info->bss_type = priv->bss_type;\r\ntx_info->flags |= MWIFIEX_BUF_FLAG_BRIDGED_PKT;\r\ndo_gettimeofday(&tv);\r\nskb->tstamp = timeval_to_ktime(tv);\r\nmwifiex_wmm_add_buf_txqueue(priv, skb);\r\natomic_inc(&adapter->tx_pending);\r\natomic_inc(&adapter->pending_bridged_pkts);\r\nif ((atomic_read(&adapter->tx_pending) >= MAX_TX_PENDING)) {\r\nmwifiex_set_trans_start(priv->netdev);\r\nmwifiex_stop_net_dev_queue(priv->netdev, priv->adapter);\r\n}\r\nreturn;\r\n}\r\nint mwifiex_handle_uap_rx_forward(struct mwifiex_private *priv,\r\nstruct sk_buff *skb)\r\n{\r\nstruct mwifiex_adapter *adapter = priv->adapter;\r\nstruct uap_rxpd *uap_rx_pd;\r\nstruct rx_packet_hdr *rx_pkt_hdr;\r\nu8 ra[ETH_ALEN];\r\nstruct sk_buff *skb_uap;\r\nuap_rx_pd = (struct uap_rxpd *)(skb->data);\r\nrx_pkt_hdr = (void *)uap_rx_pd + le16_to_cpu(uap_rx_pd->rx_pkt_offset);\r\nif (!priv->media_connected) {\r\ndev_err(adapter->dev, "drop packet in disconnected state.\n");\r\ndev_kfree_skb_any(skb);\r\nreturn 0;\r\n}\r\nmemcpy(ra, rx_pkt_hdr->eth803_hdr.h_dest, ETH_ALEN);\r\nif (is_multicast_ether_addr(ra)) {\r\nskb_uap = skb_copy(skb, GFP_ATOMIC);\r\nmwifiex_uap_queue_bridged_pkt(priv, skb_uap);\r\n} else {\r\nif (mwifiex_get_sta_entry(priv, ra)) {\r\nmwifiex_uap_queue_bridged_pkt(priv, skb);\r\nreturn 0;\r\n}\r\n}\r\nreturn mwifiex_process_rx_packet(priv, skb);\r\n}\r\nint mwifiex_process_uap_rx_packet(struct mwifiex_private *priv,\r\nstruct sk_buff *skb)\r\n{\r\nstruct mwifiex_adapter *adapter = priv->adapter;\r\nint ret;\r\nstruct uap_rxpd *uap_rx_pd;\r\nstruct rx_packet_hdr *rx_pkt_hdr;\r\nu16 rx_pkt_type;\r\nu8 ta[ETH_ALEN], pkt_type;\r\nstruct mwifiex_sta_node *node;\r\nuap_rx_pd = (struct uap_rxpd *)(skb->data);\r\nrx_pkt_type = le16_to_cpu(uap_rx_pd->rx_pkt_type);\r\nrx_pkt_hdr = (void *)uap_rx_pd + le16_to_cpu(uap_rx_pd->rx_pkt_offset);\r\nif ((le16_to_cpu(uap_rx_pd->rx_pkt_offset) +\r\nle16_to_cpu(uap_rx_pd->rx_pkt_length)) > (u16) skb->len) {\r\ndev_err(adapter->dev,\r\n"wrong rx packet: len=%d, offset=%d, length=%d\n",\r\nskb->len, le16_to_cpu(uap_rx_pd->rx_pkt_offset),\r\nle16_to_cpu(uap_rx_pd->rx_pkt_length));\r\npriv->stats.rx_dropped++;\r\nif (adapter->if_ops.data_complete)\r\nadapter->if_ops.data_complete(adapter, skb);\r\nelse\r\ndev_kfree_skb_any(skb);\r\nreturn 0;\r\n}\r\nif (le16_to_cpu(uap_rx_pd->rx_pkt_type) == PKT_TYPE_AMSDU) {\r\nstruct sk_buff_head list;\r\nstruct sk_buff *rx_skb;\r\n__skb_queue_head_init(&list);\r\nskb_pull(skb, le16_to_cpu(uap_rx_pd->rx_pkt_offset));\r\nskb_trim(skb, le16_to_cpu(uap_rx_pd->rx_pkt_length));\r\nieee80211_amsdu_to_8023s(skb, &list, priv->curr_addr,\r\npriv->wdev->iftype, 0, false);\r\nwhile (!skb_queue_empty(&list)) {\r\nrx_skb = __skb_dequeue(&list);\r\nret = mwifiex_recv_packet(priv, rx_skb);\r\nif (ret)\r\ndev_err(adapter->dev,\r\n"AP:Rx A-MSDU failed");\r\n}\r\nreturn 0;\r\n} else if (rx_pkt_type == PKT_TYPE_MGMT) {\r\nret = mwifiex_process_mgmt_packet(priv, skb);\r\nif (ret)\r\ndev_err(adapter->dev, "Rx of mgmt packet failed");\r\ndev_kfree_skb_any(skb);\r\nreturn ret;\r\n}\r\nmemcpy(ta, rx_pkt_hdr->eth803_hdr.h_source, ETH_ALEN);\r\nif (rx_pkt_type != PKT_TYPE_BAR && uap_rx_pd->priority < MAX_NUM_TID) {\r\nnode = mwifiex_get_sta_entry(priv, ta);\r\nif (node)\r\nnode->rx_seq[uap_rx_pd->priority] =\r\nle16_to_cpu(uap_rx_pd->seq_num);\r\n}\r\nif (!priv->ap_11n_enabled ||\r\n(!mwifiex_11n_get_rx_reorder_tbl(priv, uap_rx_pd->priority, ta) &&\r\n(le16_to_cpu(uap_rx_pd->rx_pkt_type) != PKT_TYPE_AMSDU))) {\r\nret = mwifiex_handle_uap_rx_forward(priv, skb);\r\nreturn ret;\r\n}\r\npkt_type = (u8)le16_to_cpu(uap_rx_pd->rx_pkt_type);\r\nret = mwifiex_11n_rx_reorder_pkt(priv, le16_to_cpu(uap_rx_pd->seq_num),\r\nuap_rx_pd->priority, ta, pkt_type,\r\nskb);\r\nif (ret || (rx_pkt_type == PKT_TYPE_BAR)) {\r\nif (adapter->if_ops.data_complete)\r\nadapter->if_ops.data_complete(adapter, skb);\r\nelse\r\ndev_kfree_skb_any(skb);\r\n}\r\nif (ret)\r\npriv->stats.rx_dropped++;\r\nreturn ret;\r\n}\r\nvoid *mwifiex_process_uap_txpd(struct mwifiex_private *priv,\r\nstruct sk_buff *skb)\r\n{\r\nstruct mwifiex_adapter *adapter = priv->adapter;\r\nstruct uap_txpd *txpd;\r\nstruct mwifiex_txinfo *tx_info = MWIFIEX_SKB_TXCB(skb);\r\nint pad, len;\r\nu16 pkt_type;\r\nif (!skb->len) {\r\ndev_err(adapter->dev, "Tx: bad packet length: %d\n", skb->len);\r\ntx_info->status_code = -1;\r\nreturn skb->data;\r\n}\r\npkt_type = mwifiex_is_skb_mgmt_frame(skb) ? PKT_TYPE_MGMT : 0;\r\npad = (4 - (((void *)skb->data - NULL) & 0x3)) % 4;\r\nlen = sizeof(*txpd) + pad;\r\nBUG_ON(skb_headroom(skb) < len + INTF_HEADER_LEN);\r\nskb_push(skb, len);\r\ntxpd = (struct uap_txpd *)skb->data;\r\nmemset(txpd, 0, sizeof(*txpd));\r\ntxpd->bss_num = priv->bss_num;\r\ntxpd->bss_type = priv->bss_type;\r\ntxpd->tx_pkt_length = cpu_to_le16((u16)(skb->len - len));\r\ntxpd->priority = (u8)skb->priority;\r\ntxpd->pkt_delay_2ms = mwifiex_wmm_compute_drv_pkt_delay(priv, skb);\r\nif (txpd->priority < ARRAY_SIZE(priv->wmm.user_pri_pkt_tx_ctrl))\r\ntxpd->tx_control =\r\ncpu_to_le32(priv->wmm.user_pri_pkt_tx_ctrl[txpd->priority]);\r\nif (pkt_type == PKT_TYPE_MGMT) {\r\ntxpd->tx_pkt_type = cpu_to_le16(pkt_type);\r\nlen += MWIFIEX_MGMT_FRAME_HEADER_SIZE;\r\n}\r\ntxpd->tx_pkt_offset = cpu_to_le16(len);\r\nskb_push(skb, INTF_HEADER_LEN);\r\nif (!txpd->tx_control)\r\ntxpd->tx_control = cpu_to_le32(priv->pkt_tx_ctrl);\r\nreturn skb->data;\r\n}
