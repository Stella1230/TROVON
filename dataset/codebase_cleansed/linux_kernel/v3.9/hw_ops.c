static int spu_hw_mbox_read(struct spu_context *ctx, u32 * data)\r\n{\r\nstruct spu *spu = ctx->spu;\r\nstruct spu_problem __iomem *prob = spu->problem;\r\nu32 mbox_stat;\r\nint ret = 0;\r\nspin_lock_irq(&spu->register_lock);\r\nmbox_stat = in_be32(&prob->mb_stat_R);\r\nif (mbox_stat & 0x0000ff) {\r\n*data = in_be32(&prob->pu_mb_R);\r\nret = 4;\r\n}\r\nspin_unlock_irq(&spu->register_lock);\r\nreturn ret;\r\n}\r\nstatic u32 spu_hw_mbox_stat_read(struct spu_context *ctx)\r\n{\r\nreturn in_be32(&ctx->spu->problem->mb_stat_R);\r\n}\r\nstatic unsigned int spu_hw_mbox_stat_poll(struct spu_context *ctx,\r\nunsigned int events)\r\n{\r\nstruct spu *spu = ctx->spu;\r\nint ret = 0;\r\nu32 stat;\r\nspin_lock_irq(&spu->register_lock);\r\nstat = in_be32(&spu->problem->mb_stat_R);\r\nif (events & (POLLIN | POLLRDNORM)) {\r\nif (stat & 0xff0000)\r\nret |= POLLIN | POLLRDNORM;\r\nelse {\r\nspu_int_stat_clear(spu, 2, CLASS2_MAILBOX_INTR);\r\nspu_int_mask_or(spu, 2, CLASS2_ENABLE_MAILBOX_INTR);\r\n}\r\n}\r\nif (events & (POLLOUT | POLLWRNORM)) {\r\nif (stat & 0x00ff00)\r\nret = POLLOUT | POLLWRNORM;\r\nelse {\r\nspu_int_stat_clear(spu, 2,\r\nCLASS2_MAILBOX_THRESHOLD_INTR);\r\nspu_int_mask_or(spu, 2,\r\nCLASS2_ENABLE_MAILBOX_THRESHOLD_INTR);\r\n}\r\n}\r\nspin_unlock_irq(&spu->register_lock);\r\nreturn ret;\r\n}\r\nstatic int spu_hw_ibox_read(struct spu_context *ctx, u32 * data)\r\n{\r\nstruct spu *spu = ctx->spu;\r\nstruct spu_problem __iomem *prob = spu->problem;\r\nstruct spu_priv2 __iomem *priv2 = spu->priv2;\r\nint ret;\r\nspin_lock_irq(&spu->register_lock);\r\nif (in_be32(&prob->mb_stat_R) & 0xff0000) {\r\n*data = in_be64(&priv2->puint_mb_R);\r\nret = 4;\r\n} else {\r\nspu_int_mask_or(spu, 2, CLASS2_ENABLE_MAILBOX_INTR);\r\nret = 0;\r\n}\r\nspin_unlock_irq(&spu->register_lock);\r\nreturn ret;\r\n}\r\nstatic int spu_hw_wbox_write(struct spu_context *ctx, u32 data)\r\n{\r\nstruct spu *spu = ctx->spu;\r\nstruct spu_problem __iomem *prob = spu->problem;\r\nint ret;\r\nspin_lock_irq(&spu->register_lock);\r\nif (in_be32(&prob->mb_stat_R) & 0x00ff00) {\r\nout_be32(&prob->spu_mb_W, data);\r\nret = 4;\r\n} else {\r\nspu_int_mask_or(spu, 2, CLASS2_ENABLE_MAILBOX_THRESHOLD_INTR);\r\nret = 0;\r\n}\r\nspin_unlock_irq(&spu->register_lock);\r\nreturn ret;\r\n}\r\nstatic void spu_hw_signal1_write(struct spu_context *ctx, u32 data)\r\n{\r\nout_be32(&ctx->spu->problem->signal_notify1, data);\r\n}\r\nstatic void spu_hw_signal2_write(struct spu_context *ctx, u32 data)\r\n{\r\nout_be32(&ctx->spu->problem->signal_notify2, data);\r\n}\r\nstatic void spu_hw_signal1_type_set(struct spu_context *ctx, u64 val)\r\n{\r\nstruct spu *spu = ctx->spu;\r\nstruct spu_priv2 __iomem *priv2 = spu->priv2;\r\nu64 tmp;\r\nspin_lock_irq(&spu->register_lock);\r\ntmp = in_be64(&priv2->spu_cfg_RW);\r\nif (val)\r\ntmp |= 1;\r\nelse\r\ntmp &= ~1;\r\nout_be64(&priv2->spu_cfg_RW, tmp);\r\nspin_unlock_irq(&spu->register_lock);\r\n}\r\nstatic u64 spu_hw_signal1_type_get(struct spu_context *ctx)\r\n{\r\nreturn ((in_be64(&ctx->spu->priv2->spu_cfg_RW) & 1) != 0);\r\n}\r\nstatic void spu_hw_signal2_type_set(struct spu_context *ctx, u64 val)\r\n{\r\nstruct spu *spu = ctx->spu;\r\nstruct spu_priv2 __iomem *priv2 = spu->priv2;\r\nu64 tmp;\r\nspin_lock_irq(&spu->register_lock);\r\ntmp = in_be64(&priv2->spu_cfg_RW);\r\nif (val)\r\ntmp |= 2;\r\nelse\r\ntmp &= ~2;\r\nout_be64(&priv2->spu_cfg_RW, tmp);\r\nspin_unlock_irq(&spu->register_lock);\r\n}\r\nstatic u64 spu_hw_signal2_type_get(struct spu_context *ctx)\r\n{\r\nreturn ((in_be64(&ctx->spu->priv2->spu_cfg_RW) & 2) != 0);\r\n}\r\nstatic u32 spu_hw_npc_read(struct spu_context *ctx)\r\n{\r\nreturn in_be32(&ctx->spu->problem->spu_npc_RW);\r\n}\r\nstatic void spu_hw_npc_write(struct spu_context *ctx, u32 val)\r\n{\r\nout_be32(&ctx->spu->problem->spu_npc_RW, val);\r\n}\r\nstatic u32 spu_hw_status_read(struct spu_context *ctx)\r\n{\r\nreturn in_be32(&ctx->spu->problem->spu_status_R);\r\n}\r\nstatic char *spu_hw_get_ls(struct spu_context *ctx)\r\n{\r\nreturn ctx->spu->local_store;\r\n}\r\nstatic void spu_hw_privcntl_write(struct spu_context *ctx, u64 val)\r\n{\r\nout_be64(&ctx->spu->priv2->spu_privcntl_RW, val);\r\n}\r\nstatic u32 spu_hw_runcntl_read(struct spu_context *ctx)\r\n{\r\nreturn in_be32(&ctx->spu->problem->spu_runcntl_RW);\r\n}\r\nstatic void spu_hw_runcntl_write(struct spu_context *ctx, u32 val)\r\n{\r\nspin_lock_irq(&ctx->spu->register_lock);\r\nif (val & SPU_RUNCNTL_ISOLATE)\r\nspu_hw_privcntl_write(ctx,\r\nSPU_PRIVCNT_LOAD_REQUEST_ENABLE_MASK);\r\nout_be32(&ctx->spu->problem->spu_runcntl_RW, val);\r\nspin_unlock_irq(&ctx->spu->register_lock);\r\n}\r\nstatic void spu_hw_runcntl_stop(struct spu_context *ctx)\r\n{\r\nspin_lock_irq(&ctx->spu->register_lock);\r\nout_be32(&ctx->spu->problem->spu_runcntl_RW, SPU_RUNCNTL_STOP);\r\nwhile (in_be32(&ctx->spu->problem->spu_status_R) & SPU_STATUS_RUNNING)\r\ncpu_relax();\r\nspin_unlock_irq(&ctx->spu->register_lock);\r\n}\r\nstatic void spu_hw_master_start(struct spu_context *ctx)\r\n{\r\nstruct spu *spu = ctx->spu;\r\nu64 sr1;\r\nspin_lock_irq(&spu->register_lock);\r\nsr1 = spu_mfc_sr1_get(spu) | MFC_STATE1_MASTER_RUN_CONTROL_MASK;\r\nspu_mfc_sr1_set(spu, sr1);\r\nspin_unlock_irq(&spu->register_lock);\r\n}\r\nstatic void spu_hw_master_stop(struct spu_context *ctx)\r\n{\r\nstruct spu *spu = ctx->spu;\r\nu64 sr1;\r\nspin_lock_irq(&spu->register_lock);\r\nsr1 = spu_mfc_sr1_get(spu) & ~MFC_STATE1_MASTER_RUN_CONTROL_MASK;\r\nspu_mfc_sr1_set(spu, sr1);\r\nspin_unlock_irq(&spu->register_lock);\r\n}\r\nstatic int spu_hw_set_mfc_query(struct spu_context * ctx, u32 mask, u32 mode)\r\n{\r\nstruct spu_problem __iomem *prob = ctx->spu->problem;\r\nint ret;\r\nspin_lock_irq(&ctx->spu->register_lock);\r\nret = -EAGAIN;\r\nif (in_be32(&prob->dma_querytype_RW))\r\ngoto out;\r\nret = 0;\r\nout_be32(&prob->dma_querymask_RW, mask);\r\nout_be32(&prob->dma_querytype_RW, mode);\r\nout:\r\nspin_unlock_irq(&ctx->spu->register_lock);\r\nreturn ret;\r\n}\r\nstatic u32 spu_hw_read_mfc_tagstatus(struct spu_context * ctx)\r\n{\r\nreturn in_be32(&ctx->spu->problem->dma_tagstatus_R);\r\n}\r\nstatic u32 spu_hw_get_mfc_free_elements(struct spu_context *ctx)\r\n{\r\nreturn in_be32(&ctx->spu->problem->dma_qstatus_R);\r\n}\r\nstatic int spu_hw_send_mfc_command(struct spu_context *ctx,\r\nstruct mfc_dma_command *cmd)\r\n{\r\nu32 status;\r\nstruct spu_problem __iomem *prob = ctx->spu->problem;\r\nspin_lock_irq(&ctx->spu->register_lock);\r\nout_be32(&prob->mfc_lsa_W, cmd->lsa);\r\nout_be64(&prob->mfc_ea_W, cmd->ea);\r\nout_be32(&prob->mfc_union_W.by32.mfc_size_tag32,\r\ncmd->size << 16 | cmd->tag);\r\nout_be32(&prob->mfc_union_W.by32.mfc_class_cmd32,\r\ncmd->class << 16 | cmd->cmd);\r\nstatus = in_be32(&prob->mfc_union_W.by32.mfc_class_cmd32);\r\nspin_unlock_irq(&ctx->spu->register_lock);\r\nswitch (status & 0xffff) {\r\ncase 0:\r\nreturn 0;\r\ncase 2:\r\nreturn -EAGAIN;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic void spu_hw_restart_dma(struct spu_context *ctx)\r\n{\r\nstruct spu_priv2 __iomem *priv2 = ctx->spu->priv2;\r\nif (!test_bit(SPU_CONTEXT_SWITCH_PENDING, &ctx->spu->flags))\r\nout_be64(&priv2->mfc_control_RW, MFC_CNTL_RESTART_DMA_COMMAND);\r\n}
