static void __iomem *request_and_map(struct device *dev,\r\nconst struct resource *res)\r\n{\r\nvoid __iomem *ptr;\r\nif (!devm_request_mem_region(dev, res->start, resource_size(res),\r\n"denali-dt")) {\r\ndev_err(dev, "unable to request %s\n", res->name);\r\nreturn NULL;\r\n}\r\nptr = devm_ioremap_nocache(dev, res->start, resource_size(res));\r\nif (!res)\r\ndev_err(dev, "ioremap_nocache of %s failed!", res->name);\r\nreturn ptr;\r\n}\r\nstatic int denali_dt_probe(struct platform_device *ofdev)\r\n{\r\nstruct resource *denali_reg, *nand_data;\r\nstruct denali_dt *dt;\r\nstruct denali_nand_info *denali;\r\nint ret;\r\nconst struct of_device_id *of_id;\r\nof_id = of_match_device(denali_nand_dt_ids, &ofdev->dev);\r\nif (of_id) {\r\nofdev->id_entry = of_id->data;\r\n} else {\r\npr_err("Failed to find the right device id.\n");\r\nreturn -ENOMEM;\r\n}\r\ndt = devm_kzalloc(&ofdev->dev, sizeof(*dt), GFP_KERNEL);\r\nif (!dt)\r\nreturn -ENOMEM;\r\ndenali = &dt->denali;\r\ndenali_reg = platform_get_resource_byname(ofdev, IORESOURCE_MEM, "denali_reg");\r\nnand_data = platform_get_resource_byname(ofdev, IORESOURCE_MEM, "nand_data");\r\nif (!denali_reg || !nand_data) {\r\ndev_err(&ofdev->dev, "resources not completely defined\n");\r\nreturn -EINVAL;\r\n}\r\ndenali->platform = DT;\r\ndenali->dev = &ofdev->dev;\r\ndenali->irq = platform_get_irq(ofdev, 0);\r\nif (denali->irq < 0) {\r\ndev_err(&ofdev->dev, "no irq defined\n");\r\nreturn -ENXIO;\r\n}\r\ndenali->flash_reg = request_and_map(&ofdev->dev, denali_reg);\r\nif (!denali->flash_reg)\r\nreturn -ENOMEM;\r\ndenali->flash_mem = request_and_map(&ofdev->dev, nand_data);\r\nif (!denali->flash_mem)\r\nreturn -ENOMEM;\r\nif (!of_property_read_u32(ofdev->dev.of_node,\r\n"dma-mask", (u32 *)&denali_dma_mask)) {\r\ndenali->dev->dma_mask = &denali_dma_mask;\r\n} else {\r\ndenali->dev->dma_mask = NULL;\r\n}\r\ndt->clk = clk_get(&ofdev->dev, NULL);\r\nif (IS_ERR(dt->clk)) {\r\ndev_err(&ofdev->dev, "no clk available\n");\r\nreturn PTR_ERR(dt->clk);\r\n}\r\nclk_prepare_enable(dt->clk);\r\nret = denali_init(denali);\r\nif (ret)\r\ngoto out_disable_clk;\r\nplatform_set_drvdata(ofdev, dt);\r\nreturn 0;\r\nout_disable_clk:\r\nclk_disable_unprepare(dt->clk);\r\nclk_put(dt->clk);\r\nreturn ret;\r\n}\r\nstatic int denali_dt_remove(struct platform_device *ofdev)\r\n{\r\nstruct denali_dt *dt = platform_get_drvdata(ofdev);\r\ndenali_remove(&dt->denali);\r\nclk_disable(dt->clk);\r\nclk_put(dt->clk);\r\nreturn 0;\r\n}\r\nstatic int __init denali_init_dt(void)\r\n{\r\nreturn platform_driver_register(&denali_dt_driver);\r\n}\r\nstatic void __exit denali_exit_dt(void)\r\n{\r\nplatform_driver_unregister(&denali_dt_driver);\r\n}
