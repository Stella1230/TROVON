int usbmisc_set_ops(const struct usbmisc_ops *ops)\r\n{\r\nif (usbmisc_ops)\r\nreturn -EBUSY;\r\nusbmisc_ops = ops;\r\nreturn 0;\r\n}\r\nvoid usbmisc_unset_ops(const struct usbmisc_ops *ops)\r\n{\r\nusbmisc_ops = NULL;\r\n}\r\nint usbmisc_get_init_data(struct device *dev, struct usbmisc_usb_device *usbdev)\r\n{\r\nstruct device_node *np = dev->of_node;\r\nstruct of_phandle_args args;\r\nint ret;\r\nusbdev->dev = dev;\r\nret = of_parse_phandle_with_args(np, "fsl,usbmisc", "#index-cells",\r\n0, &args);\r\nif (ret) {\r\ndev_err(dev, "Failed to parse property fsl,usbmisc, errno %d\n",\r\nret);\r\nmemset(usbdev, 0, sizeof(*usbdev));\r\nreturn ret;\r\n}\r\nusbdev->index = args.args[0];\r\nof_node_put(args.np);\r\nif (of_find_property(np, "disable-over-current", NULL))\r\nusbdev->disable_oc = 1;\r\nreturn 0;\r\n}\r\nstatic int ci13xxx_imx_probe(struct platform_device *pdev)\r\n{\r\nstruct ci13xxx_imx_data *data;\r\nstruct platform_device *plat_ci, *phy_pdev;\r\nstruct device_node *phy_np;\r\nstruct resource *res;\r\nstruct regulator *reg_vbus;\r\nstruct pinctrl *pinctrl;\r\nint ret;\r\nif (of_find_property(pdev->dev.of_node, "fsl,usbmisc", NULL)\r\n&& !usbmisc_ops)\r\nreturn -EPROBE_DEFER;\r\ndata = devm_kzalloc(&pdev->dev, sizeof(*data), GFP_KERNEL);\r\nif (!data) {\r\ndev_err(&pdev->dev, "Failed to allocate CI13xxx-IMX data!\n");\r\nreturn -ENOMEM;\r\n}\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!res) {\r\ndev_err(&pdev->dev, "Can't get device resources!\n");\r\nreturn -ENOENT;\r\n}\r\npinctrl = devm_pinctrl_get_select_default(&pdev->dev);\r\nif (IS_ERR(pinctrl))\r\ndev_warn(&pdev->dev, "pinctrl get/select failed, err=%ld\n",\r\nPTR_ERR(pinctrl));\r\ndata->clk = devm_clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(data->clk)) {\r\ndev_err(&pdev->dev,\r\n"Failed to get clock, err=%ld\n", PTR_ERR(data->clk));\r\nreturn PTR_ERR(data->clk);\r\n}\r\nret = clk_prepare_enable(data->clk);\r\nif (ret) {\r\ndev_err(&pdev->dev,\r\n"Failed to prepare or enable clock, err=%d\n", ret);\r\nreturn ret;\r\n}\r\nphy_np = of_parse_phandle(pdev->dev.of_node, "fsl,usbphy", 0);\r\nif (phy_np) {\r\ndata->phy_np = phy_np;\r\nphy_pdev = of_find_device_by_node(phy_np);\r\nif (phy_pdev) {\r\nstruct usb_phy *phy;\r\nphy = pdev_to_phy(phy_pdev);\r\nif (phy &&\r\ntry_module_get(phy_pdev->dev.driver->owner)) {\r\nusb_phy_init(phy);\r\ndata->phy = phy;\r\n}\r\n}\r\n}\r\nreg_vbus = devm_regulator_get(&pdev->dev, "vbus");\r\nif (!IS_ERR(reg_vbus)) {\r\nret = regulator_enable(reg_vbus);\r\nif (ret) {\r\ndev_err(&pdev->dev,\r\n"Failed to enable vbus regulator, err=%d\n",\r\nret);\r\ngoto put_np;\r\n}\r\ndata->reg_vbus = reg_vbus;\r\n} else {\r\nreg_vbus = NULL;\r\n}\r\nci13xxx_imx_platdata.phy = data->phy;\r\nif (!pdev->dev.dma_mask) {\r\npdev->dev.dma_mask = devm_kzalloc(&pdev->dev,\r\nsizeof(*pdev->dev.dma_mask), GFP_KERNEL);\r\nif (!pdev->dev.dma_mask) {\r\nret = -ENOMEM;\r\ndev_err(&pdev->dev, "Failed to alloc dma_mask!\n");\r\ngoto err;\r\n}\r\n*pdev->dev.dma_mask = DMA_BIT_MASK(32);\r\ndma_set_coherent_mask(&pdev->dev, *pdev->dev.dma_mask);\r\n}\r\nif (usbmisc_ops && usbmisc_ops->init) {\r\nret = usbmisc_ops->init(&pdev->dev);\r\nif (ret) {\r\ndev_err(&pdev->dev,\r\n"usbmisc init failed, ret=%d\n", ret);\r\ngoto err;\r\n}\r\n}\r\nplat_ci = ci13xxx_add_device(&pdev->dev,\r\npdev->resource, pdev->num_resources,\r\n&ci13xxx_imx_platdata);\r\nif (IS_ERR(plat_ci)) {\r\nret = PTR_ERR(plat_ci);\r\ndev_err(&pdev->dev,\r\n"Can't register ci_hdrc platform device, err=%d\n",\r\nret);\r\ngoto err;\r\n}\r\ndata->ci_pdev = plat_ci;\r\nplatform_set_drvdata(pdev, data);\r\npm_runtime_no_callbacks(&pdev->dev);\r\npm_runtime_enable(&pdev->dev);\r\nreturn 0;\r\nerr:\r\nif (reg_vbus)\r\nregulator_disable(reg_vbus);\r\nput_np:\r\nif (phy_np)\r\nof_node_put(phy_np);\r\nclk_disable_unprepare(data->clk);\r\nreturn ret;\r\n}\r\nstatic int ci13xxx_imx_remove(struct platform_device *pdev)\r\n{\r\nstruct ci13xxx_imx_data *data = platform_get_drvdata(pdev);\r\npm_runtime_disable(&pdev->dev);\r\nci13xxx_remove_device(data->ci_pdev);\r\nif (data->reg_vbus)\r\nregulator_disable(data->reg_vbus);\r\nif (data->phy) {\r\nusb_phy_shutdown(data->phy);\r\nmodule_put(data->phy->dev->driver->owner);\r\n}\r\nof_node_put(data->phy_np);\r\nclk_disable_unprepare(data->clk);\r\nplatform_set_drvdata(pdev, NULL);\r\nreturn 0;\r\n}
