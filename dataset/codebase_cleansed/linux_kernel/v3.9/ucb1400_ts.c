static void ucb1400_ts_mode_int(struct ucb1400_ts *ucb)\r\n{\r\nucb1400_reg_write(ucb->ac97, UCB_TS_CR,\r\nUCB_TS_CR_TSMX_POW | UCB_TS_CR_TSPX_POW |\r\nUCB_TS_CR_TSMY_GND | UCB_TS_CR_TSPY_GND |\r\nUCB_TS_CR_MODE_INT);\r\n}\r\nstatic unsigned int ucb1400_ts_read_pressure(struct ucb1400_ts *ucb)\r\n{\r\nucb1400_reg_write(ucb->ac97, UCB_TS_CR,\r\nUCB_TS_CR_TSMX_POW | UCB_TS_CR_TSPX_POW |\r\nUCB_TS_CR_TSMY_GND | UCB_TS_CR_TSPY_GND |\r\nUCB_TS_CR_MODE_PRES | UCB_TS_CR_BIAS_ENA);\r\nudelay(ts_delay_pressure);\r\nreturn ucb1400_adc_read(ucb->ac97, UCB_ADC_INP_TSPY, adcsync);\r\n}\r\nstatic unsigned int ucb1400_ts_read_xpos(struct ucb1400_ts *ucb)\r\n{\r\nucb1400_reg_write(ucb->ac97, UCB_TS_CR,\r\nUCB_TS_CR_TSMX_GND | UCB_TS_CR_TSPX_POW |\r\nUCB_TS_CR_MODE_PRES | UCB_TS_CR_BIAS_ENA);\r\nucb1400_reg_write(ucb->ac97, UCB_TS_CR,\r\nUCB_TS_CR_TSMX_GND | UCB_TS_CR_TSPX_POW |\r\nUCB_TS_CR_MODE_PRES | UCB_TS_CR_BIAS_ENA);\r\nucb1400_reg_write(ucb->ac97, UCB_TS_CR,\r\nUCB_TS_CR_TSMX_GND | UCB_TS_CR_TSPX_POW |\r\nUCB_TS_CR_MODE_POS | UCB_TS_CR_BIAS_ENA);\r\nudelay(ts_delay);\r\nreturn ucb1400_adc_read(ucb->ac97, UCB_ADC_INP_TSPY, adcsync);\r\n}\r\nstatic int ucb1400_ts_read_ypos(struct ucb1400_ts *ucb)\r\n{\r\nucb1400_reg_write(ucb->ac97, UCB_TS_CR,\r\nUCB_TS_CR_TSMY_GND | UCB_TS_CR_TSPY_POW |\r\nUCB_TS_CR_MODE_PRES | UCB_TS_CR_BIAS_ENA);\r\nucb1400_reg_write(ucb->ac97, UCB_TS_CR,\r\nUCB_TS_CR_TSMY_GND | UCB_TS_CR_TSPY_POW |\r\nUCB_TS_CR_MODE_PRES | UCB_TS_CR_BIAS_ENA);\r\nucb1400_reg_write(ucb->ac97, UCB_TS_CR,\r\nUCB_TS_CR_TSMY_GND | UCB_TS_CR_TSPY_POW |\r\nUCB_TS_CR_MODE_POS | UCB_TS_CR_BIAS_ENA);\r\nudelay(ts_delay);\r\nreturn ucb1400_adc_read(ucb->ac97, UCB_ADC_INP_TSPX, adcsync);\r\n}\r\nstatic unsigned int ucb1400_ts_read_xres(struct ucb1400_ts *ucb)\r\n{\r\nucb1400_reg_write(ucb->ac97, UCB_TS_CR,\r\nUCB_TS_CR_TSMX_GND | UCB_TS_CR_TSPX_POW |\r\nUCB_TS_CR_MODE_PRES | UCB_TS_CR_BIAS_ENA);\r\nreturn ucb1400_adc_read(ucb->ac97, 0, adcsync);\r\n}\r\nstatic unsigned int ucb1400_ts_read_yres(struct ucb1400_ts *ucb)\r\n{\r\nucb1400_reg_write(ucb->ac97, UCB_TS_CR,\r\nUCB_TS_CR_TSMY_GND | UCB_TS_CR_TSPY_POW |\r\nUCB_TS_CR_MODE_PRES | UCB_TS_CR_BIAS_ENA);\r\nreturn ucb1400_adc_read(ucb->ac97, 0, adcsync);\r\n}\r\nstatic int ucb1400_ts_pen_up(struct ucb1400_ts *ucb)\r\n{\r\nunsigned short val = ucb1400_reg_read(ucb->ac97, UCB_TS_CR);\r\nreturn val & (UCB_TS_CR_TSPX_LOW | UCB_TS_CR_TSMX_LOW);\r\n}\r\nstatic void ucb1400_ts_irq_enable(struct ucb1400_ts *ucb)\r\n{\r\nucb1400_reg_write(ucb->ac97, UCB_IE_CLEAR, UCB_IE_TSPX);\r\nucb1400_reg_write(ucb->ac97, UCB_IE_CLEAR, 0);\r\nucb1400_reg_write(ucb->ac97, UCB_IE_FAL, UCB_IE_TSPX);\r\n}\r\nstatic void ucb1400_ts_irq_disable(struct ucb1400_ts *ucb)\r\n{\r\nucb1400_reg_write(ucb->ac97, UCB_IE_FAL, 0);\r\n}\r\nstatic void ucb1400_ts_report_event(struct input_dev *idev, u16 pressure, u16 x, u16 y)\r\n{\r\ninput_report_abs(idev, ABS_X, x);\r\ninput_report_abs(idev, ABS_Y, y);\r\ninput_report_abs(idev, ABS_PRESSURE, pressure);\r\ninput_report_key(idev, BTN_TOUCH, 1);\r\ninput_sync(idev);\r\n}\r\nstatic void ucb1400_ts_event_release(struct input_dev *idev)\r\n{\r\ninput_report_abs(idev, ABS_PRESSURE, 0);\r\ninput_report_key(idev, BTN_TOUCH, 0);\r\ninput_sync(idev);\r\n}\r\nstatic void ucb1400_clear_pending_irq(struct ucb1400_ts *ucb)\r\n{\r\nunsigned int isr;\r\nisr = ucb1400_reg_read(ucb->ac97, UCB_IE_STATUS);\r\nucb1400_reg_write(ucb->ac97, UCB_IE_CLEAR, isr);\r\nucb1400_reg_write(ucb->ac97, UCB_IE_CLEAR, 0);\r\nif (isr & UCB_IE_TSPX)\r\nucb1400_ts_irq_disable(ucb);\r\nelse\r\ndev_dbg(&ucb->ts_idev->dev,\r\n"ucb1400: unexpected IE_STATUS = %#x\n", isr);\r\n}\r\nstatic irqreturn_t ucb1400_irq(int irqnr, void *devid)\r\n{\r\nstruct ucb1400_ts *ucb = devid;\r\nunsigned int x, y, p;\r\nbool penup;\r\nif (unlikely(irqnr != ucb->irq))\r\nreturn IRQ_NONE;\r\nucb1400_clear_pending_irq(ucb);\r\nmsleep(UCB1400_TS_POLL_PERIOD);\r\nwhile (!ucb->stopped && !(penup = ucb1400_ts_pen_up(ucb))) {\r\nucb1400_adc_enable(ucb->ac97);\r\nx = ucb1400_ts_read_xpos(ucb);\r\ny = ucb1400_ts_read_ypos(ucb);\r\np = ucb1400_ts_read_pressure(ucb);\r\nucb1400_adc_disable(ucb->ac97);\r\nucb1400_ts_report_event(ucb->ts_idev, p, x, y);\r\nwait_event_timeout(ucb->ts_wait, ucb->stopped,\r\nmsecs_to_jiffies(UCB1400_TS_POLL_PERIOD));\r\n}\r\nucb1400_ts_event_release(ucb->ts_idev);\r\nif (!ucb->stopped) {\r\nucb1400_ts_mode_int(ucb);\r\nucb1400_ts_irq_enable(ucb);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void ucb1400_ts_stop(struct ucb1400_ts *ucb)\r\n{\r\nucb->stopped = true;\r\nmb();\r\nwake_up(&ucb->ts_wait);\r\ndisable_irq(ucb->irq);\r\nucb1400_ts_irq_disable(ucb);\r\nucb1400_reg_write(ucb->ac97, UCB_TS_CR, 0);\r\n}\r\nstatic void ucb1400_ts_start(struct ucb1400_ts *ucb)\r\n{\r\nucb->stopped = false;\r\nmb();\r\nucb1400_ts_mode_int(ucb);\r\nucb1400_ts_irq_enable(ucb);\r\nenable_irq(ucb->irq);\r\n}\r\nstatic int ucb1400_ts_open(struct input_dev *idev)\r\n{\r\nstruct ucb1400_ts *ucb = input_get_drvdata(idev);\r\nucb1400_ts_start(ucb);\r\nreturn 0;\r\n}\r\nstatic void ucb1400_ts_close(struct input_dev *idev)\r\n{\r\nstruct ucb1400_ts *ucb = input_get_drvdata(idev);\r\nucb1400_ts_stop(ucb);\r\n}\r\nstatic int ucb1400_ts_detect_irq(struct ucb1400_ts *ucb,\r\nstruct platform_device *pdev)\r\n{\r\nunsigned long mask, timeout;\r\nmask = probe_irq_on();\r\nucb1400_reg_write(ucb->ac97, UCB_IE_RIS, UCB_IE_ADC);\r\nucb1400_reg_write(ucb->ac97, UCB_IE_FAL, UCB_IE_ADC);\r\nucb1400_reg_write(ucb->ac97, UCB_IE_CLEAR, 0xffff);\r\nucb1400_reg_write(ucb->ac97, UCB_IE_CLEAR, 0);\r\nucb1400_reg_write(ucb->ac97, UCB_ADC_CR, UCB_ADC_ENA);\r\nucb1400_reg_write(ucb->ac97, UCB_ADC_CR, UCB_ADC_ENA | UCB_ADC_START);\r\ntimeout = jiffies + HZ/2;\r\nwhile (!(ucb1400_reg_read(ucb->ac97, UCB_ADC_DATA) &\r\nUCB_ADC_DAT_VALID)) {\r\ncpu_relax();\r\nif (time_after(jiffies, timeout)) {\r\ndev_err(&pdev->dev, "timed out in IRQ probe\n");\r\nprobe_irq_off(mask);\r\nreturn -ENODEV;\r\n}\r\n}\r\nucb1400_reg_write(ucb->ac97, UCB_ADC_CR, 0);\r\nucb1400_reg_write(ucb->ac97, UCB_IE_RIS, 0);\r\nucb1400_reg_write(ucb->ac97, UCB_IE_FAL, 0);\r\nucb1400_reg_write(ucb->ac97, UCB_IE_CLEAR, 0xffff);\r\nucb1400_reg_write(ucb->ac97, UCB_IE_CLEAR, 0);\r\nucb->irq = probe_irq_off(mask);\r\nif (ucb->irq < 0 || ucb->irq == NO_IRQ)\r\nreturn -ENODEV;\r\nreturn 0;\r\n}\r\nstatic int ucb1400_ts_probe(struct platform_device *pdev)\r\n{\r\nstruct ucb1400_ts *ucb = pdev->dev.platform_data;\r\nint error, x_res, y_res;\r\nu16 fcsr;\r\nucb->ts_idev = input_allocate_device();\r\nif (!ucb->ts_idev) {\r\nerror = -ENOMEM;\r\ngoto err;\r\n}\r\nif (ucb->irq < 0) {\r\nerror = ucb1400_ts_detect_irq(ucb, pdev);\r\nif (error) {\r\ndev_err(&pdev->dev, "IRQ probe failed\n");\r\ngoto err_free_devs;\r\n}\r\n}\r\ndev_dbg(&pdev->dev, "found IRQ %d\n", ucb->irq);\r\ninit_waitqueue_head(&ucb->ts_wait);\r\ninput_set_drvdata(ucb->ts_idev, ucb);\r\nucb->ts_idev->dev.parent = &pdev->dev;\r\nucb->ts_idev->name = "UCB1400 touchscreen interface";\r\nucb->ts_idev->id.vendor = ucb1400_reg_read(ucb->ac97,\r\nAC97_VENDOR_ID1);\r\nucb->ts_idev->id.product = ucb->id;\r\nucb->ts_idev->open = ucb1400_ts_open;\r\nucb->ts_idev->close = ucb1400_ts_close;\r\nucb->ts_idev->evbit[0] = BIT_MASK(EV_ABS) | BIT_MASK(EV_KEY);\r\nucb->ts_idev->keybit[BIT_WORD(BTN_TOUCH)] = BIT_MASK(BTN_TOUCH);\r\nfcsr = ucb1400_reg_read(ucb->ac97, UCB_FCSR);\r\nucb1400_reg_write(ucb->ac97, UCB_FCSR, fcsr | UCB_FCSR_AVE);\r\nucb1400_adc_enable(ucb->ac97);\r\nx_res = ucb1400_ts_read_xres(ucb);\r\ny_res = ucb1400_ts_read_yres(ucb);\r\nucb1400_adc_disable(ucb->ac97);\r\ndev_dbg(&pdev->dev, "x/y = %d/%d\n", x_res, y_res);\r\ninput_set_abs_params(ucb->ts_idev, ABS_X, 0, x_res, 0, 0);\r\ninput_set_abs_params(ucb->ts_idev, ABS_Y, 0, y_res, 0, 0);\r\ninput_set_abs_params(ucb->ts_idev, ABS_PRESSURE, 0, 0, 0, 0);\r\nucb1400_ts_stop(ucb);\r\nerror = request_threaded_irq(ucb->irq, NULL, ucb1400_irq,\r\nIRQF_TRIGGER_RISING | IRQF_ONESHOT,\r\n"UCB1400", ucb);\r\nif (error) {\r\ndev_err(&pdev->dev,\r\n"unable to grab irq%d: %d\n", ucb->irq, error);\r\ngoto err_free_devs;\r\n}\r\nerror = input_register_device(ucb->ts_idev);\r\nif (error)\r\ngoto err_free_irq;\r\nreturn 0;\r\nerr_free_irq:\r\nfree_irq(ucb->irq, ucb);\r\nerr_free_devs:\r\ninput_free_device(ucb->ts_idev);\r\nerr:\r\nreturn error;\r\n}\r\nstatic int ucb1400_ts_remove(struct platform_device *pdev)\r\n{\r\nstruct ucb1400_ts *ucb = pdev->dev.platform_data;\r\nfree_irq(ucb->irq, ucb);\r\ninput_unregister_device(ucb->ts_idev);\r\nreturn 0;\r\n}\r\nstatic int ucb1400_ts_suspend(struct device *dev)\r\n{\r\nstruct ucb1400_ts *ucb = dev->platform_data;\r\nstruct input_dev *idev = ucb->ts_idev;\r\nmutex_lock(&idev->mutex);\r\nif (idev->users)\r\nucb1400_ts_start(ucb);\r\nmutex_unlock(&idev->mutex);\r\nreturn 0;\r\n}\r\nstatic int ucb1400_ts_resume(struct device *dev)\r\n{\r\nstruct ucb1400_ts *ucb = dev->platform_data;\r\nstruct input_dev *idev = ucb->ts_idev;\r\nmutex_lock(&idev->mutex);\r\nif (idev->users)\r\nucb1400_ts_stop(ucb);\r\nmutex_unlock(&idev->mutex);\r\nreturn 0;\r\n}
