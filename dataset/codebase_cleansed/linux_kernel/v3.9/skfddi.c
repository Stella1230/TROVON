static int skfp_init_one(struct pci_dev *pdev,\r\nconst struct pci_device_id *ent)\r\n{\r\nstruct net_device *dev;\r\nstruct s_smc *smc;\r\nvoid __iomem *mem;\r\nint err;\r\npr_debug("entering skfp_init_one\n");\r\nif (num_boards == 0)\r\nprintk("%s\n", boot_msg);\r\nerr = pci_enable_device(pdev);\r\nif (err)\r\nreturn err;\r\nerr = pci_request_regions(pdev, "skfddi");\r\nif (err)\r\ngoto err_out1;\r\npci_set_master(pdev);\r\n#ifdef MEM_MAPPED_IO\r\nif (!(pci_resource_flags(pdev, 0) & IORESOURCE_MEM)) {\r\nprintk(KERN_ERR "skfp: region is not an MMIO resource\n");\r\nerr = -EIO;\r\ngoto err_out2;\r\n}\r\nmem = ioremap(pci_resource_start(pdev, 0), 0x4000);\r\n#else\r\nif (!(pci_resource_flags(pdev, 1) & IO_RESOURCE_IO)) {\r\nprintk(KERN_ERR "skfp: region is not PIO resource\n");\r\nerr = -EIO;\r\ngoto err_out2;\r\n}\r\nmem = ioport_map(pci_resource_start(pdev, 1), FP_IO_LEN);\r\n#endif\r\nif (!mem) {\r\nprintk(KERN_ERR "skfp: Unable to map register, "\r\n"FDDI adapter will be disabled.\n");\r\nerr = -EIO;\r\ngoto err_out2;\r\n}\r\ndev = alloc_fddidev(sizeof(struct s_smc));\r\nif (!dev) {\r\nprintk(KERN_ERR "skfp: Unable to allocate fddi device, "\r\n"FDDI adapter will be disabled.\n");\r\nerr = -ENOMEM;\r\ngoto err_out3;\r\n}\r\ndev->irq = pdev->irq;\r\ndev->netdev_ops = &skfp_netdev_ops;\r\nSET_NETDEV_DEV(dev, &pdev->dev);\r\nsmc = netdev_priv(dev);\r\nsmc->os.dev = dev;\r\nsmc->os.bus_type = SK_BUS_TYPE_PCI;\r\nsmc->os.pdev = *pdev;\r\nsmc->os.QueueSkb = MAX_TX_QUEUE_LEN;\r\nsmc->os.MaxFrameSize = MAX_FRAME_SIZE;\r\nsmc->os.dev = dev;\r\nsmc->hw.slot = -1;\r\nsmc->hw.iop = mem;\r\nsmc->os.ResetRequested = FALSE;\r\nskb_queue_head_init(&smc->os.SendSkbQueue);\r\ndev->base_addr = (unsigned long)mem;\r\nerr = skfp_driver_init(dev);\r\nif (err)\r\ngoto err_out4;\r\nerr = register_netdev(dev);\r\nif (err)\r\ngoto err_out5;\r\n++num_boards;\r\npci_set_drvdata(pdev, dev);\r\nif ((pdev->subsystem_device & 0xff00) == 0x5500 ||\r\n(pdev->subsystem_device & 0xff00) == 0x5800)\r\nprintk("%s: SysKonnect FDDI PCI adapter"\r\n" found (SK-%04X)\n", dev->name,\r\npdev->subsystem_device);\r\nelse\r\nprintk("%s: FDDI PCI adapter found\n", dev->name);\r\nreturn 0;\r\nerr_out5:\r\nif (smc->os.SharedMemAddr)\r\npci_free_consistent(pdev, smc->os.SharedMemSize,\r\nsmc->os.SharedMemAddr,\r\nsmc->os.SharedMemDMA);\r\npci_free_consistent(pdev, MAX_FRAME_SIZE,\r\nsmc->os.LocalRxBuffer, smc->os.LocalRxBufferDMA);\r\nerr_out4:\r\nfree_netdev(dev);\r\nerr_out3:\r\n#ifdef MEM_MAPPED_IO\r\niounmap(mem);\r\n#else\r\nioport_unmap(mem);\r\n#endif\r\nerr_out2:\r\npci_release_regions(pdev);\r\nerr_out1:\r\npci_disable_device(pdev);\r\nreturn err;\r\n}\r\nstatic void skfp_remove_one(struct pci_dev *pdev)\r\n{\r\nstruct net_device *p = pci_get_drvdata(pdev);\r\nstruct s_smc *lp = netdev_priv(p);\r\nunregister_netdev(p);\r\nif (lp->os.SharedMemAddr) {\r\npci_free_consistent(&lp->os.pdev,\r\nlp->os.SharedMemSize,\r\nlp->os.SharedMemAddr,\r\nlp->os.SharedMemDMA);\r\nlp->os.SharedMemAddr = NULL;\r\n}\r\nif (lp->os.LocalRxBuffer) {\r\npci_free_consistent(&lp->os.pdev,\r\nMAX_FRAME_SIZE,\r\nlp->os.LocalRxBuffer,\r\nlp->os.LocalRxBufferDMA);\r\nlp->os.LocalRxBuffer = NULL;\r\n}\r\n#ifdef MEM_MAPPED_IO\r\niounmap(lp->hw.iop);\r\n#else\r\nioport_unmap(lp->hw.iop);\r\n#endif\r\npci_release_regions(pdev);\r\nfree_netdev(p);\r\npci_disable_device(pdev);\r\npci_set_drvdata(pdev, NULL);\r\n}\r\nstatic int skfp_driver_init(struct net_device *dev)\r\n{\r\nstruct s_smc *smc = netdev_priv(dev);\r\nskfddi_priv *bp = &smc->os;\r\nint err = -EIO;\r\npr_debug("entering skfp_driver_init\n");\r\nbp->base_addr = dev->base_addr;\r\nsmc->hw.irq = dev->irq;\r\nspin_lock_init(&bp->DriverLock);\r\nbp->LocalRxBuffer = pci_alloc_consistent(&bp->pdev, MAX_FRAME_SIZE, &bp->LocalRxBufferDMA);\r\nif (!bp->LocalRxBuffer) {\r\nprintk("could not allocate mem for ");\r\nprintk("LocalRxBuffer: %d byte\n", MAX_FRAME_SIZE);\r\ngoto fail;\r\n}\r\nbp->SharedMemSize = mac_drv_check_space();\r\npr_debug("Memory for HWM: %ld\n", bp->SharedMemSize);\r\nif (bp->SharedMemSize > 0) {\r\nbp->SharedMemSize += 16;\r\nbp->SharedMemAddr = pci_alloc_consistent(&bp->pdev,\r\nbp->SharedMemSize,\r\n&bp->SharedMemDMA);\r\nif (!bp->SharedMemAddr) {\r\nprintk("could not allocate mem for ");\r\nprintk("hardware module: %ld byte\n",\r\nbp->SharedMemSize);\r\ngoto fail;\r\n}\r\nbp->SharedMemHeap = 0;\r\n} else {\r\nbp->SharedMemAddr = NULL;\r\nbp->SharedMemHeap = 0;\r\n}\r\nmemset(bp->SharedMemAddr, 0, bp->SharedMemSize);\r\ncard_stop(smc);\r\npr_debug("mac_drv_init()..\n");\r\nif (mac_drv_init(smc) != 0) {\r\npr_debug("mac_drv_init() failed\n");\r\ngoto fail;\r\n}\r\nread_address(smc, NULL);\r\npr_debug("HW-Addr: %pMF\n", smc->hw.fddi_canon_addr.a);\r\nmemcpy(dev->dev_addr, smc->hw.fddi_canon_addr.a, 6);\r\nsmt_reset_defaults(smc, 0);\r\nreturn 0;\r\nfail:\r\nif (bp->SharedMemAddr) {\r\npci_free_consistent(&bp->pdev,\r\nbp->SharedMemSize,\r\nbp->SharedMemAddr,\r\nbp->SharedMemDMA);\r\nbp->SharedMemAddr = NULL;\r\n}\r\nif (bp->LocalRxBuffer) {\r\npci_free_consistent(&bp->pdev, MAX_FRAME_SIZE,\r\nbp->LocalRxBuffer, bp->LocalRxBufferDMA);\r\nbp->LocalRxBuffer = NULL;\r\n}\r\nreturn err;\r\n}\r\nstatic int skfp_open(struct net_device *dev)\r\n{\r\nstruct s_smc *smc = netdev_priv(dev);\r\nint err;\r\npr_debug("entering skfp_open\n");\r\nerr = request_irq(dev->irq, skfp_interrupt, IRQF_SHARED,\r\ndev->name, dev);\r\nif (err)\r\nreturn err;\r\nread_address(smc, NULL);\r\nmemcpy(dev->dev_addr, smc->hw.fddi_canon_addr.a, 6);\r\ninit_smt(smc, NULL);\r\nsmt_online(smc, 1);\r\nSTI_FBI();\r\nmac_clear_multicast(smc);\r\nmac_drv_rx_mode(smc, RX_DISABLE_PROMISC);\r\nnetif_start_queue(dev);\r\nreturn 0;\r\n}\r\nstatic int skfp_close(struct net_device *dev)\r\n{\r\nstruct s_smc *smc = netdev_priv(dev);\r\nskfddi_priv *bp = &smc->os;\r\nCLI_FBI();\r\nsmt_reset_defaults(smc, 1);\r\ncard_stop(smc);\r\nmac_drv_clear_tx_queue(smc);\r\nmac_drv_clear_rx_queue(smc);\r\nnetif_stop_queue(dev);\r\nfree_irq(dev->irq, dev);\r\nskb_queue_purge(&bp->SendSkbQueue);\r\nbp->QueueSkb = MAX_TX_QUEUE_LEN;\r\nreturn 0;\r\n}\r\nstatic irqreturn_t skfp_interrupt(int irq, void *dev_id)\r\n{\r\nstruct net_device *dev = dev_id;\r\nstruct s_smc *smc;\r\nskfddi_priv *bp;\r\nsmc = netdev_priv(dev);\r\nbp = &smc->os;\r\nif (inpd(ADDR(B0_IMSK)) == 0) {\r\nreturn IRQ_NONE;\r\n}\r\nif ((inpd(ISR_A) & smc->hw.is_imask) == 0) {\r\nreturn IRQ_NONE;\r\n}\r\nCLI_FBI();\r\nspin_lock(&bp->DriverLock);\r\nfddi_isr(smc);\r\nif (smc->os.ResetRequested) {\r\nResetAdapter(smc);\r\nsmc->os.ResetRequested = FALSE;\r\n}\r\nspin_unlock(&bp->DriverLock);\r\nSTI_FBI();\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic struct net_device_stats *skfp_ctl_get_stats(struct net_device *dev)\r\n{\r\nstruct s_smc *bp = netdev_priv(dev);\r\nbp->os.MacStat.port_bs_flag[0] = 0x1234;\r\nbp->os.MacStat.port_bs_flag[1] = 0x5678;\r\n#if 0\r\nmemcpy(bp->stats.smt_station_id, &bp->cmd_rsp_virt->smt_mib_get.smt_station_id, sizeof(bp->cmd_rsp_virt->smt_mib_get.smt_station_id));\r\nbp->stats.smt_op_version_id = bp->cmd_rsp_virt->smt_mib_get.smt_op_version_id;\r\nbp->stats.smt_hi_version_id = bp->cmd_rsp_virt->smt_mib_get.smt_hi_version_id;\r\nbp->stats.smt_lo_version_id = bp->cmd_rsp_virt->smt_mib_get.smt_lo_version_id;\r\nmemcpy(bp->stats.smt_user_data, &bp->cmd_rsp_virt->smt_mib_get.smt_user_data, sizeof(bp->cmd_rsp_virt->smt_mib_get.smt_user_data));\r\nbp->stats.smt_mib_version_id = bp->cmd_rsp_virt->smt_mib_get.smt_mib_version_id;\r\nbp->stats.smt_mac_cts = bp->cmd_rsp_virt->smt_mib_get.smt_mac_ct;\r\nbp->stats.smt_non_master_cts = bp->cmd_rsp_virt->smt_mib_get.smt_non_master_ct;\r\nbp->stats.smt_master_cts = bp->cmd_rsp_virt->smt_mib_get.smt_master_ct;\r\nbp->stats.smt_available_paths = bp->cmd_rsp_virt->smt_mib_get.smt_available_paths;\r\nbp->stats.smt_config_capabilities = bp->cmd_rsp_virt->smt_mib_get.smt_config_capabilities;\r\nbp->stats.smt_config_policy = bp->cmd_rsp_virt->smt_mib_get.smt_config_policy;\r\nbp->stats.smt_connection_policy = bp->cmd_rsp_virt->smt_mib_get.smt_connection_policy;\r\nbp->stats.smt_t_notify = bp->cmd_rsp_virt->smt_mib_get.smt_t_notify;\r\nbp->stats.smt_stat_rpt_policy = bp->cmd_rsp_virt->smt_mib_get.smt_stat_rpt_policy;\r\nbp->stats.smt_trace_max_expiration = bp->cmd_rsp_virt->smt_mib_get.smt_trace_max_expiration;\r\nbp->stats.smt_bypass_present = bp->cmd_rsp_virt->smt_mib_get.smt_bypass_present;\r\nbp->stats.smt_ecm_state = bp->cmd_rsp_virt->smt_mib_get.smt_ecm_state;\r\nbp->stats.smt_cf_state = bp->cmd_rsp_virt->smt_mib_get.smt_cf_state;\r\nbp->stats.smt_remote_disconnect_flag = bp->cmd_rsp_virt->smt_mib_get.smt_remote_disconnect_flag;\r\nbp->stats.smt_station_status = bp->cmd_rsp_virt->smt_mib_get.smt_station_status;\r\nbp->stats.smt_peer_wrap_flag = bp->cmd_rsp_virt->smt_mib_get.smt_peer_wrap_flag;\r\nbp->stats.smt_time_stamp = bp->cmd_rsp_virt->smt_mib_get.smt_msg_time_stamp.ls;\r\nbp->stats.smt_transition_time_stamp = bp->cmd_rsp_virt->smt_mib_get.smt_transition_time_stamp.ls;\r\nbp->stats.mac_frame_status_functions = bp->cmd_rsp_virt->smt_mib_get.mac_frame_status_functions;\r\nbp->stats.mac_t_max_capability = bp->cmd_rsp_virt->smt_mib_get.mac_t_max_capability;\r\nbp->stats.mac_tvx_capability = bp->cmd_rsp_virt->smt_mib_get.mac_tvx_capability;\r\nbp->stats.mac_available_paths = bp->cmd_rsp_virt->smt_mib_get.mac_available_paths;\r\nbp->stats.mac_current_path = bp->cmd_rsp_virt->smt_mib_get.mac_current_path;\r\nmemcpy(bp->stats.mac_upstream_nbr, &bp->cmd_rsp_virt->smt_mib_get.mac_upstream_nbr, FDDI_K_ALEN);\r\nmemcpy(bp->stats.mac_downstream_nbr, &bp->cmd_rsp_virt->smt_mib_get.mac_downstream_nbr, FDDI_K_ALEN);\r\nmemcpy(bp->stats.mac_old_upstream_nbr, &bp->cmd_rsp_virt->smt_mib_get.mac_old_upstream_nbr, FDDI_K_ALEN);\r\nmemcpy(bp->stats.mac_old_downstream_nbr, &bp->cmd_rsp_virt->smt_mib_get.mac_old_downstream_nbr, FDDI_K_ALEN);\r\nbp->stats.mac_dup_address_test = bp->cmd_rsp_virt->smt_mib_get.mac_dup_address_test;\r\nbp->stats.mac_requested_paths = bp->cmd_rsp_virt->smt_mib_get.mac_requested_paths;\r\nbp->stats.mac_downstream_port_type = bp->cmd_rsp_virt->smt_mib_get.mac_downstream_port_type;\r\nmemcpy(bp->stats.mac_smt_address, &bp->cmd_rsp_virt->smt_mib_get.mac_smt_address, FDDI_K_ALEN);\r\nbp->stats.mac_t_req = bp->cmd_rsp_virt->smt_mib_get.mac_t_req;\r\nbp->stats.mac_t_neg = bp->cmd_rsp_virt->smt_mib_get.mac_t_neg;\r\nbp->stats.mac_t_max = bp->cmd_rsp_virt->smt_mib_get.mac_t_max;\r\nbp->stats.mac_tvx_value = bp->cmd_rsp_virt->smt_mib_get.mac_tvx_value;\r\nbp->stats.mac_frame_error_threshold = bp->cmd_rsp_virt->smt_mib_get.mac_frame_error_threshold;\r\nbp->stats.mac_frame_error_ratio = bp->cmd_rsp_virt->smt_mib_get.mac_frame_error_ratio;\r\nbp->stats.mac_rmt_state = bp->cmd_rsp_virt->smt_mib_get.mac_rmt_state;\r\nbp->stats.mac_da_flag = bp->cmd_rsp_virt->smt_mib_get.mac_da_flag;\r\nbp->stats.mac_una_da_flag = bp->cmd_rsp_virt->smt_mib_get.mac_unda_flag;\r\nbp->stats.mac_frame_error_flag = bp->cmd_rsp_virt->smt_mib_get.mac_frame_error_flag;\r\nbp->stats.mac_ma_unitdata_available = bp->cmd_rsp_virt->smt_mib_get.mac_ma_unitdata_available;\r\nbp->stats.mac_hardware_present = bp->cmd_rsp_virt->smt_mib_get.mac_hardware_present;\r\nbp->stats.mac_ma_unitdata_enable = bp->cmd_rsp_virt->smt_mib_get.mac_ma_unitdata_enable;\r\nbp->stats.path_tvx_lower_bound = bp->cmd_rsp_virt->smt_mib_get.path_tvx_lower_bound;\r\nbp->stats.path_t_max_lower_bound = bp->cmd_rsp_virt->smt_mib_get.path_t_max_lower_bound;\r\nbp->stats.path_max_t_req = bp->cmd_rsp_virt->smt_mib_get.path_max_t_req;\r\nmemcpy(bp->stats.path_configuration, &bp->cmd_rsp_virt->smt_mib_get.path_configuration, sizeof(bp->cmd_rsp_virt->smt_mib_get.path_configuration));\r\nbp->stats.port_my_type[0] = bp->cmd_rsp_virt->smt_mib_get.port_my_type[0];\r\nbp->stats.port_my_type[1] = bp->cmd_rsp_virt->smt_mib_get.port_my_type[1];\r\nbp->stats.port_neighbor_type[0] = bp->cmd_rsp_virt->smt_mib_get.port_neighbor_type[0];\r\nbp->stats.port_neighbor_type[1] = bp->cmd_rsp_virt->smt_mib_get.port_neighbor_type[1];\r\nbp->stats.port_connection_policies[0] = bp->cmd_rsp_virt->smt_mib_get.port_connection_policies[0];\r\nbp->stats.port_connection_policies[1] = bp->cmd_rsp_virt->smt_mib_get.port_connection_policies[1];\r\nbp->stats.port_mac_indicated[0] = bp->cmd_rsp_virt->smt_mib_get.port_mac_indicated[0];\r\nbp->stats.port_mac_indicated[1] = bp->cmd_rsp_virt->smt_mib_get.port_mac_indicated[1];\r\nbp->stats.port_current_path[0] = bp->cmd_rsp_virt->smt_mib_get.port_current_path[0];\r\nbp->stats.port_current_path[1] = bp->cmd_rsp_virt->smt_mib_get.port_current_path[1];\r\nmemcpy(&bp->stats.port_requested_paths[0 * 3], &bp->cmd_rsp_virt->smt_mib_get.port_requested_paths[0], 3);\r\nmemcpy(&bp->stats.port_requested_paths[1 * 3], &bp->cmd_rsp_virt->smt_mib_get.port_requested_paths[1], 3);\r\nbp->stats.port_mac_placement[0] = bp->cmd_rsp_virt->smt_mib_get.port_mac_placement[0];\r\nbp->stats.port_mac_placement[1] = bp->cmd_rsp_virt->smt_mib_get.port_mac_placement[1];\r\nbp->stats.port_available_paths[0] = bp->cmd_rsp_virt->smt_mib_get.port_available_paths[0];\r\nbp->stats.port_available_paths[1] = bp->cmd_rsp_virt->smt_mib_get.port_available_paths[1];\r\nbp->stats.port_pmd_class[0] = bp->cmd_rsp_virt->smt_mib_get.port_pmd_class[0];\r\nbp->stats.port_pmd_class[1] = bp->cmd_rsp_virt->smt_mib_get.port_pmd_class[1];\r\nbp->stats.port_connection_capabilities[0] = bp->cmd_rsp_virt->smt_mib_get.port_connection_capabilities[0];\r\nbp->stats.port_connection_capabilities[1] = bp->cmd_rsp_virt->smt_mib_get.port_connection_capabilities[1];\r\nbp->stats.port_bs_flag[0] = bp->cmd_rsp_virt->smt_mib_get.port_bs_flag[0];\r\nbp->stats.port_bs_flag[1] = bp->cmd_rsp_virt->smt_mib_get.port_bs_flag[1];\r\nbp->stats.port_ler_estimate[0] = bp->cmd_rsp_virt->smt_mib_get.port_ler_estimate[0];\r\nbp->stats.port_ler_estimate[1] = bp->cmd_rsp_virt->smt_mib_get.port_ler_estimate[1];\r\nbp->stats.port_ler_cutoff[0] = bp->cmd_rsp_virt->smt_mib_get.port_ler_cutoff[0];\r\nbp->stats.port_ler_cutoff[1] = bp->cmd_rsp_virt->smt_mib_get.port_ler_cutoff[1];\r\nbp->stats.port_ler_alarm[0] = bp->cmd_rsp_virt->smt_mib_get.port_ler_alarm[0];\r\nbp->stats.port_ler_alarm[1] = bp->cmd_rsp_virt->smt_mib_get.port_ler_alarm[1];\r\nbp->stats.port_connect_state[0] = bp->cmd_rsp_virt->smt_mib_get.port_connect_state[0];\r\nbp->stats.port_connect_state[1] = bp->cmd_rsp_virt->smt_mib_get.port_connect_state[1];\r\nbp->stats.port_pcm_state[0] = bp->cmd_rsp_virt->smt_mib_get.port_pcm_state[0];\r\nbp->stats.port_pcm_state[1] = bp->cmd_rsp_virt->smt_mib_get.port_pcm_state[1];\r\nbp->stats.port_pc_withhold[0] = bp->cmd_rsp_virt->smt_mib_get.port_pc_withhold[0];\r\nbp->stats.port_pc_withhold[1] = bp->cmd_rsp_virt->smt_mib_get.port_pc_withhold[1];\r\nbp->stats.port_ler_flag[0] = bp->cmd_rsp_virt->smt_mib_get.port_ler_flag[0];\r\nbp->stats.port_ler_flag[1] = bp->cmd_rsp_virt->smt_mib_get.port_ler_flag[1];\r\nbp->stats.port_hardware_present[0] = bp->cmd_rsp_virt->smt_mib_get.port_hardware_present[0];\r\nbp->stats.port_hardware_present[1] = bp->cmd_rsp_virt->smt_mib_get.port_hardware_present[1];\r\nbp->stats.mac_frame_cts = bp->cmd_rsp_virt->cntrs_get.cntrs.frame_cnt.ls;\r\nbp->stats.mac_copied_cts = bp->cmd_rsp_virt->cntrs_get.cntrs.copied_cnt.ls;\r\nbp->stats.mac_transmit_cts = bp->cmd_rsp_virt->cntrs_get.cntrs.transmit_cnt.ls;\r\nbp->stats.mac_error_cts = bp->cmd_rsp_virt->cntrs_get.cntrs.error_cnt.ls;\r\nbp->stats.mac_lost_cts = bp->cmd_rsp_virt->cntrs_get.cntrs.lost_cnt.ls;\r\nbp->stats.port_lct_fail_cts[0] = bp->cmd_rsp_virt->cntrs_get.cntrs.lct_rejects[0].ls;\r\nbp->stats.port_lct_fail_cts[1] = bp->cmd_rsp_virt->cntrs_get.cntrs.lct_rejects[1].ls;\r\nbp->stats.port_lem_reject_cts[0] = bp->cmd_rsp_virt->cntrs_get.cntrs.lem_rejects[0].ls;\r\nbp->stats.port_lem_reject_cts[1] = bp->cmd_rsp_virt->cntrs_get.cntrs.lem_rejects[1].ls;\r\nbp->stats.port_lem_cts[0] = bp->cmd_rsp_virt->cntrs_get.cntrs.link_errors[0].ls;\r\nbp->stats.port_lem_cts[1] = bp->cmd_rsp_virt->cntrs_get.cntrs.link_errors[1].ls;\r\n#endif\r\nreturn (struct net_device_stats *)&bp->os.MacStat;\r\n}\r\nstatic void skfp_ctl_set_multicast_list(struct net_device *dev)\r\n{\r\nstruct s_smc *smc = netdev_priv(dev);\r\nskfddi_priv *bp = &smc->os;\r\nunsigned long Flags;\r\nspin_lock_irqsave(&bp->DriverLock, Flags);\r\nskfp_ctl_set_multicast_list_wo_lock(dev);\r\nspin_unlock_irqrestore(&bp->DriverLock, Flags);\r\n}\r\nstatic void skfp_ctl_set_multicast_list_wo_lock(struct net_device *dev)\r\n{\r\nstruct s_smc *smc = netdev_priv(dev);\r\nstruct netdev_hw_addr *ha;\r\nif (dev->flags & IFF_PROMISC) {\r\nmac_drv_rx_mode(smc, RX_ENABLE_PROMISC);\r\npr_debug("PROMISCUOUS MODE ENABLED\n");\r\n}\r\nelse {\r\nmac_drv_rx_mode(smc, RX_DISABLE_PROMISC);\r\npr_debug("PROMISCUOUS MODE DISABLED\n");\r\nmac_clear_multicast(smc);\r\nmac_drv_rx_mode(smc, RX_DISABLE_ALLMULTI);\r\nif (dev->flags & IFF_ALLMULTI) {\r\nmac_drv_rx_mode(smc, RX_ENABLE_ALLMULTI);\r\npr_debug("ENABLE ALL MC ADDRESSES\n");\r\n} else if (!netdev_mc_empty(dev)) {\r\nif (netdev_mc_count(dev) <= FPMAX_MULTICAST) {\r\nnetdev_for_each_mc_addr(ha, dev) {\r\nmac_add_multicast(smc,\r\n(struct fddi_addr *)ha->addr,\r\n1);\r\npr_debug("ENABLE MC ADDRESS: %pMF\n",\r\nha->addr);\r\n}\r\n} else {\r\nmac_drv_rx_mode(smc, RX_ENABLE_ALLMULTI);\r\npr_debug("ENABLE ALL MC ADDRESSES\n");\r\n}\r\n} else {\r\npr_debug("DISABLE ALL MC ADDRESSES\n");\r\n}\r\nmac_update_multicast(smc);\r\n}\r\n}\r\nstatic int skfp_ctl_set_mac_address(struct net_device *dev, void *addr)\r\n{\r\nstruct s_smc *smc = netdev_priv(dev);\r\nstruct sockaddr *p_sockaddr = (struct sockaddr *) addr;\r\nskfddi_priv *bp = &smc->os;\r\nunsigned long Flags;\r\nmemcpy(dev->dev_addr, p_sockaddr->sa_data, FDDI_K_ALEN);\r\nspin_lock_irqsave(&bp->DriverLock, Flags);\r\nResetAdapter(smc);\r\nspin_unlock_irqrestore(&bp->DriverLock, Flags);\r\nreturn 0;\r\n}\r\nstatic int skfp_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)\r\n{\r\nstruct s_smc *smc = netdev_priv(dev);\r\nskfddi_priv *lp = &smc->os;\r\nstruct s_skfp_ioctl ioc;\r\nint status = 0;\r\nif (copy_from_user(&ioc, rq->ifr_data, sizeof(struct s_skfp_ioctl)))\r\nreturn -EFAULT;\r\nswitch (ioc.cmd) {\r\ncase SKFP_GET_STATS:\r\nioc.len = sizeof(lp->MacStat);\r\nstatus = copy_to_user(ioc.data, skfp_ctl_get_stats(dev), ioc.len)\r\n? -EFAULT : 0;\r\nbreak;\r\ncase SKFP_CLR_STATS:\r\nif (!capable(CAP_NET_ADMIN)) {\r\nstatus = -EPERM;\r\n} else {\r\nmemset(&lp->MacStat, 0, sizeof(lp->MacStat));\r\n}\r\nbreak;\r\ndefault:\r\nprintk("ioctl for %s: unknown cmd: %04x\n", dev->name, ioc.cmd);\r\nstatus = -EOPNOTSUPP;\r\n}\r\nreturn status;\r\n}\r\nstatic netdev_tx_t skfp_send_pkt(struct sk_buff *skb,\r\nstruct net_device *dev)\r\n{\r\nstruct s_smc *smc = netdev_priv(dev);\r\nskfddi_priv *bp = &smc->os;\r\npr_debug("skfp_send_pkt\n");\r\nif (!(skb->len >= FDDI_K_LLC_ZLEN && skb->len <= FDDI_K_LLC_LEN)) {\r\nbp->MacStat.gen.tx_errors++;\r\nnetif_start_queue(dev);\r\ndev_kfree_skb(skb);\r\nreturn NETDEV_TX_OK;\r\n}\r\nif (bp->QueueSkb == 0) {\r\nnetif_stop_queue(dev);\r\nreturn NETDEV_TX_BUSY;\r\n}\r\nbp->QueueSkb--;\r\nskb_queue_tail(&bp->SendSkbQueue, skb);\r\nsend_queued_packets(netdev_priv(dev));\r\nif (bp->QueueSkb == 0) {\r\nnetif_stop_queue(dev);\r\n}\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic void send_queued_packets(struct s_smc *smc)\r\n{\r\nskfddi_priv *bp = &smc->os;\r\nstruct sk_buff *skb;\r\nunsigned char fc;\r\nint queue;\r\nstruct s_smt_fp_txd *txd;\r\ndma_addr_t dma_address;\r\nunsigned long Flags;\r\nint frame_status;\r\npr_debug("send queued packets\n");\r\nfor (;;) {\r\nskb = skb_dequeue(&bp->SendSkbQueue);\r\nif (!skb) {\r\npr_debug("queue empty\n");\r\nreturn;\r\n}\r\nspin_lock_irqsave(&bp->DriverLock, Flags);\r\nfc = skb->data[0];\r\nqueue = (fc & FC_SYNC_BIT) ? QUEUE_S : QUEUE_A0;\r\n#ifdef ESS\r\nif ((fc & ~(FC_SYNC_BIT | FC_LLC_PRIOR)) == FC_ASYNC_LLC) {\r\nif (!smc->ess.sync_bw_available)\r\nfc &= ~FC_SYNC_BIT;\r\nelse {\r\nif (smc->mib.fddiESSSynchTxMode) {\r\nfc |= FC_SYNC_BIT;\r\n}\r\n}\r\n}\r\n#endif\r\nframe_status = hwm_tx_init(smc, fc, 1, skb->len, queue);\r\nif ((frame_status & (LOC_TX | LAN_TX)) == 0) {\r\nif ((frame_status & RING_DOWN) != 0) {\r\npr_debug("Tx attempt while ring down.\n");\r\n} else if ((frame_status & OUT_OF_TXD) != 0) {\r\npr_debug("%s: out of TXDs.\n", bp->dev->name);\r\n} else {\r\npr_debug("%s: out of transmit resources",\r\nbp->dev->name);\r\n}\r\nskb_queue_head(&bp->SendSkbQueue, skb);\r\nspin_unlock_irqrestore(&bp->DriverLock, Flags);\r\nreturn;\r\n}\r\nbp->QueueSkb++;\r\nCheckSourceAddress(skb->data, smc->hw.fddi_canon_addr.a);\r\ntxd = (struct s_smt_fp_txd *) HWM_GET_CURR_TXD(smc, queue);\r\ndma_address = pci_map_single(&bp->pdev, skb->data,\r\nskb->len, PCI_DMA_TODEVICE);\r\nif (frame_status & LAN_TX) {\r\ntxd->txd_os.skb = skb;\r\ntxd->txd_os.dma_addr = dma_address;\r\n}\r\nhwm_tx_frag(smc, skb->data, dma_address, skb->len,\r\nframe_status | FIRST_FRAG | LAST_FRAG | EN_IRQ_EOF);\r\nif (!(frame_status & LAN_TX)) {\r\npci_unmap_single(&bp->pdev, dma_address,\r\nskb->len, PCI_DMA_TODEVICE);\r\ndev_kfree_skb_irq(skb);\r\n}\r\nspin_unlock_irqrestore(&bp->DriverLock, Flags);\r\n}\r\nreturn;\r\n}\r\nstatic void CheckSourceAddress(unsigned char *frame, unsigned char *hw_addr)\r\n{\r\nunsigned char SRBit;\r\nif ((((unsigned long) frame[1 + 6]) & ~0x01) != 0)\r\nreturn;\r\nif ((unsigned short) frame[1 + 10] != 0)\r\nreturn;\r\nSRBit = frame[1 + 6] & 0x01;\r\nmemcpy(&frame[1 + 6], hw_addr, 6);\r\nframe[8] |= SRBit;\r\n}\r\nstatic void ResetAdapter(struct s_smc *smc)\r\n{\r\npr_debug("[fddi: ResetAdapter]\n");\r\ncard_stop(smc);\r\nmac_drv_clear_tx_queue(smc);\r\nmac_drv_clear_rx_queue(smc);\r\nsmt_reset_defaults(smc, 1);\r\ninit_smt(smc, (smc->os.dev)->dev_addr);\r\nsmt_online(smc, 1);\r\nSTI_FBI();\r\nskfp_ctl_set_multicast_list_wo_lock(smc->os.dev);\r\n}\r\nvoid llc_restart_tx(struct s_smc *smc)\r\n{\r\nskfddi_priv *bp = &smc->os;\r\npr_debug("[llc_restart_tx]\n");\r\nspin_unlock(&bp->DriverLock);\r\nsend_queued_packets(smc);\r\nspin_lock(&bp->DriverLock);\r\nnetif_start_queue(bp->dev);\r\n}\r\nvoid *mac_drv_get_space(struct s_smc *smc, unsigned int size)\r\n{\r\nvoid *virt;\r\npr_debug("mac_drv_get_space (%d bytes), ", size);\r\nvirt = (void *) (smc->os.SharedMemAddr + smc->os.SharedMemHeap);\r\nif ((smc->os.SharedMemHeap + size) > smc->os.SharedMemSize) {\r\nprintk("Unexpected SMT memory size requested: %d\n", size);\r\nreturn NULL;\r\n}\r\nsmc->os.SharedMemHeap += size;\r\npr_debug("mac_drv_get_space end\n");\r\npr_debug("virt addr: %lx\n", (ulong) virt);\r\npr_debug("bus addr: %lx\n", (ulong)\r\n(smc->os.SharedMemDMA +\r\n((char *) virt - (char *)smc->os.SharedMemAddr)));\r\nreturn virt;\r\n}\r\nvoid *mac_drv_get_desc_mem(struct s_smc *smc, unsigned int size)\r\n{\r\nchar *virt;\r\npr_debug("mac_drv_get_desc_mem\n");\r\nvirt = mac_drv_get_space(smc, size);\r\nsize = (u_int) (16 - (((unsigned long) virt) & 15UL));\r\nsize = size % 16;\r\npr_debug("Allocate %u bytes alignment gap ", size);\r\npr_debug("for descriptor memory.\n");\r\nif (!mac_drv_get_space(smc, size)) {\r\nprintk("fddi: Unable to align descriptor memory.\n");\r\nreturn NULL;\r\n}\r\nreturn virt + size;\r\n}\r\nunsigned long mac_drv_virt2phys(struct s_smc *smc, void *virt)\r\n{\r\nreturn smc->os.SharedMemDMA +\r\n((char *) virt - (char *)smc->os.SharedMemAddr);\r\n}\r\nu_long dma_master(struct s_smc * smc, void *virt, int len, int flag)\r\n{\r\nreturn smc->os.SharedMemDMA +\r\n((char *) virt - (char *)smc->os.SharedMemAddr);\r\n}\r\nvoid dma_complete(struct s_smc *smc, volatile union s_fp_descr *descr, int flag)\r\n{\r\nif (flag & DMA_WR) {\r\nskfddi_priv *bp = &smc->os;\r\nvolatile struct s_smt_fp_rxd *r = &descr->r;\r\nif (r->rxd_os.skb && r->rxd_os.dma_addr) {\r\nint MaxFrameSize = bp->MaxFrameSize;\r\npci_unmap_single(&bp->pdev, r->rxd_os.dma_addr,\r\nMaxFrameSize, PCI_DMA_FROMDEVICE);\r\nr->rxd_os.dma_addr = 0;\r\n}\r\n}\r\n}\r\nvoid mac_drv_tx_complete(struct s_smc *smc, volatile struct s_smt_fp_txd *txd)\r\n{\r\nstruct sk_buff *skb;\r\npr_debug("entering mac_drv_tx_complete\n");\r\nif (!(skb = txd->txd_os.skb)) {\r\npr_debug("TXD with no skb assigned.\n");\r\nreturn;\r\n}\r\ntxd->txd_os.skb = NULL;\r\npci_unmap_single(&smc->os.pdev, txd->txd_os.dma_addr,\r\nskb->len, PCI_DMA_TODEVICE);\r\ntxd->txd_os.dma_addr = 0;\r\nsmc->os.MacStat.gen.tx_packets++;\r\nsmc->os.MacStat.gen.tx_bytes+=skb->len;\r\ndev_kfree_skb_irq(skb);\r\npr_debug("leaving mac_drv_tx_complete\n");\r\n}\r\nvoid dump_data(unsigned char *Data, int length)\r\n{\r\nint i, j;\r\nunsigned char s[255], sh[10];\r\nif (length > 64) {\r\nlength = 64;\r\n}\r\nprintk(KERN_INFO "---Packet start---\n");\r\nfor (i = 0, j = 0; i < length / 8; i++, j += 8)\r\nprintk(KERN_INFO "%02x %02x %02x %02x %02x %02x %02x %02x\n",\r\nData[j + 0], Data[j + 1], Data[j + 2], Data[j + 3],\r\nData[j + 4], Data[j + 5], Data[j + 6], Data[j + 7]);\r\nstrcpy(s, "");\r\nfor (i = 0; i < length % 8; i++) {\r\nsprintf(sh, "%02x ", Data[j + i]);\r\nstrcat(s, sh);\r\n}\r\nprintk(KERN_INFO "%s\n", s);\r\nprintk(KERN_INFO "------------------\n");\r\n}\r\nvoid mac_drv_rx_complete(struct s_smc *smc, volatile struct s_smt_fp_rxd *rxd,\r\nint frag_count, int len)\r\n{\r\nskfddi_priv *bp = &smc->os;\r\nstruct sk_buff *skb;\r\nunsigned char *virt, *cp;\r\nunsigned short ri;\r\nu_int RifLength;\r\npr_debug("entering mac_drv_rx_complete (len=%d)\n", len);\r\nif (frag_count != 1) {\r\nprintk("fddi: Multi-fragment receive!\n");\r\ngoto RequeueRxd;\r\n}\r\nskb = rxd->rxd_os.skb;\r\nif (!skb) {\r\npr_debug("No skb in rxd\n");\r\nsmc->os.MacStat.gen.rx_errors++;\r\ngoto RequeueRxd;\r\n}\r\nvirt = skb->data;\r\ndump_data(skb->data, len);\r\nif ((virt[1 + 6] & FDDI_RII) == 0)\r\nRifLength = 0;\r\nelse {\r\nint n;\r\npr_debug("RIF found\n");\r\ncp = virt + FDDI_MAC_HDR_LEN;\r\nri = ntohs(*((__be16 *) cp));\r\nRifLength = ri & FDDI_RCF_LEN_MASK;\r\nif (len < (int) (FDDI_MAC_HDR_LEN + RifLength)) {\r\nprintk("fddi: Invalid RIF.\n");\r\ngoto RequeueRxd;\r\n}\r\nvirt[1 + 6] &= ~FDDI_RII;\r\nvirt = cp + RifLength;\r\nfor (n = FDDI_MAC_HDR_LEN; n; n--)\r\n*--virt = *--cp;\r\nskb_pull(skb, RifLength);\r\nlen -= RifLength;\r\nRifLength = 0;\r\n}\r\nsmc->os.MacStat.gen.rx_packets++;\r\nsmc->os.MacStat.gen.rx_bytes+=len;\r\nif (virt[1] & 0x01) {\r\nsmc->os.MacStat.gen.multicast++;\r\n}\r\nrxd->rxd_os.skb = NULL;\r\nskb_trim(skb, len);\r\nskb->protocol = fddi_type_trans(skb, bp->dev);\r\nnetif_rx(skb);\r\nHWM_RX_CHECK(smc, RX_LOW_WATERMARK);\r\nreturn;\r\nRequeueRxd:\r\npr_debug("Rx: re-queue RXD.\n");\r\nmac_drv_requeue_rxd(smc, rxd, frag_count);\r\nsmc->os.MacStat.gen.rx_errors++;\r\n}\r\nvoid mac_drv_requeue_rxd(struct s_smc *smc, volatile struct s_smt_fp_rxd *rxd,\r\nint frag_count)\r\n{\r\nvolatile struct s_smt_fp_rxd *next_rxd;\r\nvolatile struct s_smt_fp_rxd *src_rxd;\r\nstruct sk_buff *skb;\r\nint MaxFrameSize;\r\nunsigned char *v_addr;\r\ndma_addr_t b_addr;\r\nif (frag_count != 1)\r\nprintk("fddi: Multi-fragment requeue!\n");\r\nMaxFrameSize = smc->os.MaxFrameSize;\r\nsrc_rxd = rxd;\r\nfor (; frag_count > 0; frag_count--) {\r\nnext_rxd = src_rxd->rxd_next;\r\nrxd = HWM_GET_CURR_RXD(smc);\r\nskb = src_rxd->rxd_os.skb;\r\nif (skb == NULL) {\r\npr_debug("Requeue with no skb in rxd!\n");\r\nskb = alloc_skb(MaxFrameSize + 3, GFP_ATOMIC);\r\nif (skb) {\r\nrxd->rxd_os.skb = skb;\r\nskb_reserve(skb, 3);\r\nskb_put(skb, MaxFrameSize);\r\nv_addr = skb->data;\r\nb_addr = pci_map_single(&smc->os.pdev,\r\nv_addr,\r\nMaxFrameSize,\r\nPCI_DMA_FROMDEVICE);\r\nrxd->rxd_os.dma_addr = b_addr;\r\n} else {\r\npr_debug("Queueing invalid buffer!\n");\r\nrxd->rxd_os.skb = NULL;\r\nv_addr = smc->os.LocalRxBuffer;\r\nb_addr = smc->os.LocalRxBufferDMA;\r\n}\r\n} else {\r\nrxd->rxd_os.skb = skb;\r\nv_addr = skb->data;\r\nb_addr = pci_map_single(&smc->os.pdev,\r\nv_addr,\r\nMaxFrameSize,\r\nPCI_DMA_FROMDEVICE);\r\nrxd->rxd_os.dma_addr = b_addr;\r\n}\r\nhwm_rx_frag(smc, v_addr, b_addr, MaxFrameSize,\r\nFIRST_FRAG | LAST_FRAG);\r\nsrc_rxd = next_rxd;\r\n}\r\n}\r\nvoid mac_drv_fill_rxd(struct s_smc *smc)\r\n{\r\nint MaxFrameSize;\r\nunsigned char *v_addr;\r\nunsigned long b_addr;\r\nstruct sk_buff *skb;\r\nvolatile struct s_smt_fp_rxd *rxd;\r\npr_debug("entering mac_drv_fill_rxd\n");\r\nMaxFrameSize = smc->os.MaxFrameSize;\r\nwhile (HWM_GET_RX_FREE(smc) > 0) {\r\npr_debug(".\n");\r\nrxd = HWM_GET_CURR_RXD(smc);\r\nskb = alloc_skb(MaxFrameSize + 3, GFP_ATOMIC);\r\nif (skb) {\r\nskb_reserve(skb, 3);\r\nskb_put(skb, MaxFrameSize);\r\nv_addr = skb->data;\r\nb_addr = pci_map_single(&smc->os.pdev,\r\nv_addr,\r\nMaxFrameSize,\r\nPCI_DMA_FROMDEVICE);\r\nrxd->rxd_os.dma_addr = b_addr;\r\n} else {\r\npr_debug("Queueing invalid buffer!\n");\r\nv_addr = smc->os.LocalRxBuffer;\r\nb_addr = smc->os.LocalRxBufferDMA;\r\n}\r\nrxd->rxd_os.skb = skb;\r\nhwm_rx_frag(smc, v_addr, b_addr, MaxFrameSize,\r\nFIRST_FRAG | LAST_FRAG);\r\n}\r\npr_debug("leaving mac_drv_fill_rxd\n");\r\n}\r\nvoid mac_drv_clear_rxd(struct s_smc *smc, volatile struct s_smt_fp_rxd *rxd,\r\nint frag_count)\r\n{\r\nstruct sk_buff *skb;\r\npr_debug("entering mac_drv_clear_rxd\n");\r\nif (frag_count != 1)\r\nprintk("fddi: Multi-fragment clear!\n");\r\nfor (; frag_count > 0; frag_count--) {\r\nskb = rxd->rxd_os.skb;\r\nif (skb != NULL) {\r\nskfddi_priv *bp = &smc->os;\r\nint MaxFrameSize = bp->MaxFrameSize;\r\npci_unmap_single(&bp->pdev, rxd->rxd_os.dma_addr,\r\nMaxFrameSize, PCI_DMA_FROMDEVICE);\r\ndev_kfree_skb(skb);\r\nrxd->rxd_os.skb = NULL;\r\n}\r\nrxd = rxd->rxd_next;\r\n}\r\n}\r\nint mac_drv_rx_init(struct s_smc *smc, int len, int fc,\r\nchar *look_ahead, int la_len)\r\n{\r\nstruct sk_buff *skb;\r\npr_debug("entering mac_drv_rx_init(len=%d)\n", len);\r\nif (len != la_len || len < FDDI_MAC_HDR_LEN || !look_ahead) {\r\npr_debug("fddi: Discard invalid local SMT frame\n");\r\npr_debug(" len=%d, la_len=%d, (ULONG) look_ahead=%08lXh.\n",\r\nlen, la_len, (unsigned long) look_ahead);\r\nreturn 0;\r\n}\r\nskb = alloc_skb(len + 3, GFP_ATOMIC);\r\nif (!skb) {\r\npr_debug("fddi: Local SMT: skb memory exhausted.\n");\r\nreturn 0;\r\n}\r\nskb_reserve(skb, 3);\r\nskb_put(skb, len);\r\nskb_copy_to_linear_data(skb, look_ahead, len);\r\nskb->protocol = fddi_type_trans(skb, smc->os.dev);\r\nnetif_rx(skb);\r\nreturn 0;\r\n}\r\nvoid smt_timer_poll(struct s_smc *smc)\r\n{\r\n}\r\nvoid ring_status_indication(struct s_smc *smc, u_long status)\r\n{\r\npr_debug("ring_status_indication( ");\r\nif (status & RS_RES15)\r\npr_debug("RS_RES15 ");\r\nif (status & RS_HARDERROR)\r\npr_debug("RS_HARDERROR ");\r\nif (status & RS_SOFTERROR)\r\npr_debug("RS_SOFTERROR ");\r\nif (status & RS_BEACON)\r\npr_debug("RS_BEACON ");\r\nif (status & RS_PATHTEST)\r\npr_debug("RS_PATHTEST ");\r\nif (status & RS_SELFTEST)\r\npr_debug("RS_SELFTEST ");\r\nif (status & RS_RES9)\r\npr_debug("RS_RES9 ");\r\nif (status & RS_DISCONNECT)\r\npr_debug("RS_DISCONNECT ");\r\nif (status & RS_RES7)\r\npr_debug("RS_RES7 ");\r\nif (status & RS_DUPADDR)\r\npr_debug("RS_DUPADDR ");\r\nif (status & RS_NORINGOP)\r\npr_debug("RS_NORINGOP ");\r\nif (status & RS_VERSION)\r\npr_debug("RS_VERSION ");\r\nif (status & RS_STUCKBYPASSS)\r\npr_debug("RS_STUCKBYPASSS ");\r\nif (status & RS_EVENT)\r\npr_debug("RS_EVENT ");\r\nif (status & RS_RINGOPCHANGE)\r\npr_debug("RS_RINGOPCHANGE ");\r\nif (status & RS_RES0)\r\npr_debug("RS_RES0 ");\r\npr_debug("]\n");\r\n}\r\nunsigned long smt_get_time(void)\r\n{\r\nreturn jiffies;\r\n}\r\nvoid smt_stat_counter(struct s_smc *smc, int stat)\r\n{\r\npr_debug("smt_stat_counter\n");\r\nswitch (stat) {\r\ncase 0:\r\npr_debug("Ring operational change.\n");\r\nbreak;\r\ncase 1:\r\npr_debug("Receive fifo overflow.\n");\r\nsmc->os.MacStat.gen.rx_errors++;\r\nbreak;\r\ndefault:\r\npr_debug("Unknown status (%d).\n", stat);\r\nbreak;\r\n}\r\n}\r\nvoid cfm_state_change(struct s_smc *smc, int c_state)\r\n{\r\n#ifdef DRIVERDEBUG\r\nchar *s;\r\nswitch (c_state) {\r\ncase SC0_ISOLATED:\r\ns = "SC0_ISOLATED";\r\nbreak;\r\ncase SC1_WRAP_A:\r\ns = "SC1_WRAP_A";\r\nbreak;\r\ncase SC2_WRAP_B:\r\ns = "SC2_WRAP_B";\r\nbreak;\r\ncase SC4_THRU_A:\r\ns = "SC4_THRU_A";\r\nbreak;\r\ncase SC5_THRU_B:\r\ns = "SC5_THRU_B";\r\nbreak;\r\ncase SC7_WRAP_S:\r\ns = "SC7_WRAP_S";\r\nbreak;\r\ncase SC9_C_WRAP_A:\r\ns = "SC9_C_WRAP_A";\r\nbreak;\r\ncase SC10_C_WRAP_B:\r\ns = "SC10_C_WRAP_B";\r\nbreak;\r\ncase SC11_C_WRAP_S:\r\ns = "SC11_C_WRAP_S";\r\nbreak;\r\ndefault:\r\npr_debug("cfm_state_change: unknown %d\n", c_state);\r\nreturn;\r\n}\r\npr_debug("cfm_state_change: %s\n", s);\r\n#endif\r\n}\r\nvoid ecm_state_change(struct s_smc *smc, int e_state)\r\n{\r\n#ifdef DRIVERDEBUG\r\nchar *s;\r\nswitch (e_state) {\r\ncase EC0_OUT:\r\ns = "EC0_OUT";\r\nbreak;\r\ncase EC1_IN:\r\ns = "EC1_IN";\r\nbreak;\r\ncase EC2_TRACE:\r\ns = "EC2_TRACE";\r\nbreak;\r\ncase EC3_LEAVE:\r\ns = "EC3_LEAVE";\r\nbreak;\r\ncase EC4_PATH_TEST:\r\ns = "EC4_PATH_TEST";\r\nbreak;\r\ncase EC5_INSERT:\r\ns = "EC5_INSERT";\r\nbreak;\r\ncase EC6_CHECK:\r\ns = "EC6_CHECK";\r\nbreak;\r\ncase EC7_DEINSERT:\r\ns = "EC7_DEINSERT";\r\nbreak;\r\ndefault:\r\ns = "unknown";\r\nbreak;\r\n}\r\npr_debug("ecm_state_change: %s\n", s);\r\n#endif\r\n}\r\nvoid rmt_state_change(struct s_smc *smc, int r_state)\r\n{\r\n#ifdef DRIVERDEBUG\r\nchar *s;\r\nswitch (r_state) {\r\ncase RM0_ISOLATED:\r\ns = "RM0_ISOLATED";\r\nbreak;\r\ncase RM1_NON_OP:\r\ns = "RM1_NON_OP - not operational";\r\nbreak;\r\ncase RM2_RING_OP:\r\ns = "RM2_RING_OP - ring operational";\r\nbreak;\r\ncase RM3_DETECT:\r\ns = "RM3_DETECT - detect dupl addresses";\r\nbreak;\r\ncase RM4_NON_OP_DUP:\r\ns = "RM4_NON_OP_DUP - dupl. addr detected";\r\nbreak;\r\ncase RM5_RING_OP_DUP:\r\ns = "RM5_RING_OP_DUP - ring oper. with dupl. addr";\r\nbreak;\r\ncase RM6_DIRECTED:\r\ns = "RM6_DIRECTED - sending directed beacons";\r\nbreak;\r\ncase RM7_TRACE:\r\ns = "RM7_TRACE - trace initiated";\r\nbreak;\r\ndefault:\r\ns = "unknown";\r\nbreak;\r\n}\r\npr_debug("[rmt_state_change: %s]\n", s);\r\n#endif\r\n}\r\nvoid drv_reset_indication(struct s_smc *smc)\r\n{\r\npr_debug("entering drv_reset_indication\n");\r\nsmc->os.ResetRequested = TRUE;\r\n}\r\nstatic int __init skfd_init(void)\r\n{\r\nreturn pci_register_driver(&skfddi_pci_driver);\r\n}\r\nstatic void __exit skfd_exit(void)\r\n{\r\npci_unregister_driver(&skfddi_pci_driver);\r\n}
