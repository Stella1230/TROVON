static int snd_es18xx_dsp_command(struct snd_es18xx *chip, unsigned char val)\r\n{\r\nint i;\r\nfor(i = MILLISECOND; i; i--)\r\nif ((inb(chip->port + 0x0C) & 0x80) == 0) {\r\noutb(val, chip->port + 0x0C);\r\nreturn 0;\r\n}\r\nsnd_printk(KERN_ERR "dsp_command: timeout (0x%x)\n", val);\r\nreturn -EINVAL;\r\n}\r\nstatic int snd_es18xx_dsp_get_byte(struct snd_es18xx *chip)\r\n{\r\nint i;\r\nfor(i = MILLISECOND/10; i; i--)\r\nif (inb(chip->port + 0x0C) & 0x40)\r\nreturn inb(chip->port + 0x0A);\r\nsnd_printk(KERN_ERR "dsp_get_byte failed: 0x%lx = 0x%x!!!\n",\r\nchip->port + 0x0A, inb(chip->port + 0x0A));\r\nreturn -ENODEV;\r\n}\r\nstatic int snd_es18xx_write(struct snd_es18xx *chip,\r\nunsigned char reg, unsigned char data)\r\n{\r\nunsigned long flags;\r\nint ret;\r\nspin_lock_irqsave(&chip->reg_lock, flags);\r\nret = snd_es18xx_dsp_command(chip, reg);\r\nif (ret < 0)\r\ngoto end;\r\nret = snd_es18xx_dsp_command(chip, data);\r\nend:\r\nspin_unlock_irqrestore(&chip->reg_lock, flags);\r\n#ifdef REG_DEBUG\r\nsnd_printk(KERN_DEBUG "Reg %02x set to %02x\n", reg, data);\r\n#endif\r\nreturn ret;\r\n}\r\nstatic int snd_es18xx_read(struct snd_es18xx *chip, unsigned char reg)\r\n{\r\nunsigned long flags;\r\nint ret, data;\r\nspin_lock_irqsave(&chip->reg_lock, flags);\r\nret = snd_es18xx_dsp_command(chip, 0xC0);\r\nif (ret < 0)\r\ngoto end;\r\nret = snd_es18xx_dsp_command(chip, reg);\r\nif (ret < 0)\r\ngoto end;\r\ndata = snd_es18xx_dsp_get_byte(chip);\r\nret = data;\r\n#ifdef REG_DEBUG\r\nsnd_printk(KERN_DEBUG "Reg %02x now is %02x (%d)\n", reg, data, ret);\r\n#endif\r\nend:\r\nspin_unlock_irqrestore(&chip->reg_lock, flags);\r\nreturn ret;\r\n}\r\nstatic int snd_es18xx_bits(struct snd_es18xx *chip, unsigned char reg,\r\nunsigned char mask, unsigned char val)\r\n{\r\nint ret;\r\nunsigned char old, new, oval;\r\nunsigned long flags;\r\nspin_lock_irqsave(&chip->reg_lock, flags);\r\nret = snd_es18xx_dsp_command(chip, 0xC0);\r\nif (ret < 0)\r\ngoto end;\r\nret = snd_es18xx_dsp_command(chip, reg);\r\nif (ret < 0)\r\ngoto end;\r\nret = snd_es18xx_dsp_get_byte(chip);\r\nif (ret < 0) {\r\ngoto end;\r\n}\r\nold = ret;\r\noval = old & mask;\r\nif (val != oval) {\r\nret = snd_es18xx_dsp_command(chip, reg);\r\nif (ret < 0)\r\ngoto end;\r\nnew = (old & ~mask) | (val & mask);\r\nret = snd_es18xx_dsp_command(chip, new);\r\nif (ret < 0)\r\ngoto end;\r\n#ifdef REG_DEBUG\r\nsnd_printk(KERN_DEBUG "Reg %02x was %02x, set to %02x (%d)\n",\r\nreg, old, new, ret);\r\n#endif\r\n}\r\nret = oval;\r\nend:\r\nspin_unlock_irqrestore(&chip->reg_lock, flags);\r\nreturn ret;\r\n}\r\nstatic inline void snd_es18xx_mixer_write(struct snd_es18xx *chip,\r\nunsigned char reg, unsigned char data)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&chip->mixer_lock, flags);\r\noutb(reg, chip->port + 0x04);\r\noutb(data, chip->port + 0x05);\r\nspin_unlock_irqrestore(&chip->mixer_lock, flags);\r\n#ifdef REG_DEBUG\r\nsnd_printk(KERN_DEBUG "Mixer reg %02x set to %02x\n", reg, data);\r\n#endif\r\n}\r\nstatic inline int snd_es18xx_mixer_read(struct snd_es18xx *chip, unsigned char reg)\r\n{\r\nunsigned long flags;\r\nint data;\r\nspin_lock_irqsave(&chip->mixer_lock, flags);\r\noutb(reg, chip->port + 0x04);\r\ndata = inb(chip->port + 0x05);\r\nspin_unlock_irqrestore(&chip->mixer_lock, flags);\r\n#ifdef REG_DEBUG\r\nsnd_printk(KERN_DEBUG "Mixer reg %02x now is %02x\n", reg, data);\r\n#endif\r\nreturn data;\r\n}\r\nstatic inline int snd_es18xx_mixer_bits(struct snd_es18xx *chip, unsigned char reg,\r\nunsigned char mask, unsigned char val)\r\n{\r\nunsigned char old, new, oval;\r\nunsigned long flags;\r\nspin_lock_irqsave(&chip->mixer_lock, flags);\r\noutb(reg, chip->port + 0x04);\r\nold = inb(chip->port + 0x05);\r\noval = old & mask;\r\nif (val != oval) {\r\nnew = (old & ~mask) | (val & mask);\r\noutb(new, chip->port + 0x05);\r\n#ifdef REG_DEBUG\r\nsnd_printk(KERN_DEBUG "Mixer reg %02x was %02x, set to %02x\n",\r\nreg, old, new);\r\n#endif\r\n}\r\nspin_unlock_irqrestore(&chip->mixer_lock, flags);\r\nreturn oval;\r\n}\r\nstatic inline int snd_es18xx_mixer_writable(struct snd_es18xx *chip, unsigned char reg,\r\nunsigned char mask)\r\n{\r\nint old, expected, new;\r\nunsigned long flags;\r\nspin_lock_irqsave(&chip->mixer_lock, flags);\r\noutb(reg, chip->port + 0x04);\r\nold = inb(chip->port + 0x05);\r\nexpected = old ^ mask;\r\noutb(expected, chip->port + 0x05);\r\nnew = inb(chip->port + 0x05);\r\nspin_unlock_irqrestore(&chip->mixer_lock, flags);\r\n#ifdef REG_DEBUG\r\nsnd_printk(KERN_DEBUG "Mixer reg %02x was %02x, set to %02x, now is %02x\n",\r\nreg, old, expected, new);\r\n#endif\r\nreturn expected == new;\r\n}\r\nstatic int snd_es18xx_reset(struct snd_es18xx *chip)\r\n{\r\nint i;\r\noutb(0x03, chip->port + 0x06);\r\ninb(chip->port + 0x06);\r\noutb(0x00, chip->port + 0x06);\r\nfor(i = 0; i < MILLISECOND && !(inb(chip->port + 0x0E) & 0x80); i++);\r\nif (inb(chip->port + 0x0A) != 0xAA)\r\nreturn -1;\r\nreturn 0;\r\n}\r\nstatic int snd_es18xx_reset_fifo(struct snd_es18xx *chip)\r\n{\r\noutb(0x02, chip->port + 0x06);\r\ninb(chip->port + 0x06);\r\noutb(0x00, chip->port + 0x06);\r\nreturn 0;\r\n}\r\nstatic void snd_es18xx_rate_set(struct snd_es18xx *chip,\r\nstruct snd_pcm_substream *substream,\r\nint mode)\r\n{\r\nunsigned int bits, div0;\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nif (chip->caps & ES18XX_NEW_RATE) {\r\nif (runtime->rate_num == new_clocks[0].num)\r\nbits = 128 - runtime->rate_den;\r\nelse\r\nbits = 256 - runtime->rate_den;\r\n} else {\r\nif (runtime->rate_num == old_clocks[0].num)\r\nbits = 256 - runtime->rate_den;\r\nelse\r\nbits = 128 - runtime->rate_den;\r\n}\r\ndiv0 = 256 - 7160000*20/(8*82*runtime->rate);\r\nif ((chip->caps & ES18XX_PCM2) && mode == DAC2) {\r\nsnd_es18xx_mixer_write(chip, 0x70, bits);\r\nsnd_es18xx_write(chip, 0xA2, div0);\r\nsnd_es18xx_mixer_write(chip, 0x72, div0);\r\n} else {\r\nsnd_es18xx_write(chip, 0xA1, bits);\r\nsnd_es18xx_write(chip, 0xA2, div0);\r\n}\r\n}\r\nstatic int snd_es18xx_playback_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *hw_params)\r\n{\r\nstruct snd_es18xx *chip = snd_pcm_substream_chip(substream);\r\nint shift, err;\r\nshift = 0;\r\nif (params_channels(hw_params) == 2)\r\nshift++;\r\nif (snd_pcm_format_width(params_format(hw_params)) == 16)\r\nshift++;\r\nif (substream->number == 0 && (chip->caps & ES18XX_PCM2)) {\r\nif ((chip->caps & ES18XX_DUPLEX_MONO) &&\r\n(chip->capture_a_substream) &&\r\nparams_channels(hw_params) != 1) {\r\n_snd_pcm_hw_param_setempty(hw_params, SNDRV_PCM_HW_PARAM_CHANNELS);\r\nreturn -EBUSY;\r\n}\r\nchip->dma2_shift = shift;\r\n} else {\r\nchip->dma1_shift = shift;\r\n}\r\nif ((err = snd_pcm_lib_malloc_pages(substream, params_buffer_bytes(hw_params))) < 0)\r\nreturn err;\r\nreturn 0;\r\n}\r\nstatic int snd_es18xx_pcm_hw_free(struct snd_pcm_substream *substream)\r\n{\r\nreturn snd_pcm_lib_free_pages(substream);\r\n}\r\nstatic int snd_es18xx_playback1_prepare(struct snd_es18xx *chip,\r\nstruct snd_pcm_substream *substream)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nunsigned int size = snd_pcm_lib_buffer_bytes(substream);\r\nunsigned int count = snd_pcm_lib_period_bytes(substream);\r\nsnd_es18xx_rate_set(chip, substream, DAC2);\r\ncount = 0x10000 - count;\r\nsnd_es18xx_mixer_write(chip, 0x74, count & 0xff);\r\nsnd_es18xx_mixer_write(chip, 0x76, count >> 8);\r\nsnd_es18xx_mixer_bits(chip, 0x7A, 0x07,\r\n((runtime->channels == 1) ? 0x00 : 0x02) |\r\n(snd_pcm_format_width(runtime->format) == 16 ? 0x01 : 0x00) |\r\n(snd_pcm_format_unsigned(runtime->format) ? 0x00 : 0x04));\r\nsnd_dma_program(chip->dma2, runtime->dma_addr, size, DMA_MODE_WRITE | DMA_AUTOINIT);\r\nreturn 0;\r\n}\r\nstatic int snd_es18xx_playback1_trigger(struct snd_es18xx *chip,\r\nstruct snd_pcm_substream *substream,\r\nint cmd)\r\n{\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\ncase SNDRV_PCM_TRIGGER_RESUME:\r\nif (chip->active & DAC2)\r\nreturn 0;\r\nchip->active |= DAC2;\r\nif (chip->dma2 >= 4)\r\nsnd_es18xx_mixer_write(chip, 0x78, 0xb3);\r\nelse\r\nsnd_es18xx_mixer_write(chip, 0x78, 0x93);\r\n#ifdef AVOID_POPS\r\nudelay(100000);\r\nif (chip->caps & ES18XX_PCM2)\r\nsnd_es18xx_mixer_write(chip, 0x7C, chip->audio2_vol);\r\nelse\r\nsnd_es18xx_dsp_command(chip, 0xD1);\r\n#endif\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\ncase SNDRV_PCM_TRIGGER_SUSPEND:\r\nif (!(chip->active & DAC2))\r\nreturn 0;\r\nchip->active &= ~DAC2;\r\nsnd_es18xx_mixer_write(chip, 0x78, 0x00);\r\n#ifdef AVOID_POPS\r\nudelay(25000);\r\nif (chip->caps & ES18XX_PCM2)\r\nsnd_es18xx_mixer_write(chip, 0x7C, 0);\r\nelse\r\nsnd_es18xx_dsp_command(chip, 0xD3);\r\n#endif\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_es18xx_capture_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *hw_params)\r\n{\r\nstruct snd_es18xx *chip = snd_pcm_substream_chip(substream);\r\nint shift, err;\r\nshift = 0;\r\nif ((chip->caps & ES18XX_DUPLEX_MONO) &&\r\nchip->playback_a_substream &&\r\nparams_channels(hw_params) != 1) {\r\n_snd_pcm_hw_param_setempty(hw_params, SNDRV_PCM_HW_PARAM_CHANNELS);\r\nreturn -EBUSY;\r\n}\r\nif (params_channels(hw_params) == 2)\r\nshift++;\r\nif (snd_pcm_format_width(params_format(hw_params)) == 16)\r\nshift++;\r\nchip->dma1_shift = shift;\r\nif ((err = snd_pcm_lib_malloc_pages(substream, params_buffer_bytes(hw_params))) < 0)\r\nreturn err;\r\nreturn 0;\r\n}\r\nstatic int snd_es18xx_capture_prepare(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_es18xx *chip = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nunsigned int size = snd_pcm_lib_buffer_bytes(substream);\r\nunsigned int count = snd_pcm_lib_period_bytes(substream);\r\nsnd_es18xx_reset_fifo(chip);\r\nsnd_es18xx_bits(chip, 0xA8, 0x03, runtime->channels == 1 ? 0x02 : 0x01);\r\nsnd_es18xx_rate_set(chip, substream, ADC1);\r\ncount = 0x10000 - count;\r\nsnd_es18xx_write(chip, 0xA4, count & 0xff);\r\nsnd_es18xx_write(chip, 0xA5, count >> 8);\r\n#ifdef AVOID_POPS\r\nudelay(100000);\r\n#endif\r\nsnd_es18xx_write(chip, 0xB7,\r\nsnd_pcm_format_unsigned(runtime->format) ? 0x51 : 0x71);\r\nsnd_es18xx_write(chip, 0xB7, 0x90 |\r\n((runtime->channels == 1) ? 0x40 : 0x08) |\r\n(snd_pcm_format_width(runtime->format) == 16 ? 0x04 : 0x00) |\r\n(snd_pcm_format_unsigned(runtime->format) ? 0x00 : 0x20));\r\nsnd_dma_program(chip->dma1, runtime->dma_addr, size, DMA_MODE_READ | DMA_AUTOINIT);\r\nreturn 0;\r\n}\r\nstatic int snd_es18xx_capture_trigger(struct snd_pcm_substream *substream,\r\nint cmd)\r\n{\r\nstruct snd_es18xx *chip = snd_pcm_substream_chip(substream);\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\ncase SNDRV_PCM_TRIGGER_RESUME:\r\nif (chip->active & ADC1)\r\nreturn 0;\r\nchip->active |= ADC1;\r\nsnd_es18xx_write(chip, 0xB8, 0x0f);\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\ncase SNDRV_PCM_TRIGGER_SUSPEND:\r\nif (!(chip->active & ADC1))\r\nreturn 0;\r\nchip->active &= ~ADC1;\r\nsnd_es18xx_write(chip, 0xB8, 0x00);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_es18xx_playback2_prepare(struct snd_es18xx *chip,\r\nstruct snd_pcm_substream *substream)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nunsigned int size = snd_pcm_lib_buffer_bytes(substream);\r\nunsigned int count = snd_pcm_lib_period_bytes(substream);\r\nsnd_es18xx_reset_fifo(chip);\r\nsnd_es18xx_bits(chip, 0xA8, 0x03, runtime->channels == 1 ? 0x02 : 0x01);\r\nsnd_es18xx_rate_set(chip, substream, DAC1);\r\ncount = 0x10000 - count;\r\nsnd_es18xx_write(chip, 0xA4, count & 0xff);\r\nsnd_es18xx_write(chip, 0xA5, count >> 8);\r\nsnd_es18xx_write(chip, 0xB6,\r\nsnd_pcm_format_unsigned(runtime->format) ? 0x80 : 0x00);\r\nsnd_es18xx_write(chip, 0xB7,\r\nsnd_pcm_format_unsigned(runtime->format) ? 0x51 : 0x71);\r\nsnd_es18xx_write(chip, 0xB7, 0x90 |\r\n(runtime->channels == 1 ? 0x40 : 0x08) |\r\n(snd_pcm_format_width(runtime->format) == 16 ? 0x04 : 0x00) |\r\n(snd_pcm_format_unsigned(runtime->format) ? 0x00 : 0x20));\r\nsnd_dma_program(chip->dma1, runtime->dma_addr, size, DMA_MODE_WRITE | DMA_AUTOINIT);\r\nreturn 0;\r\n}\r\nstatic int snd_es18xx_playback2_trigger(struct snd_es18xx *chip,\r\nstruct snd_pcm_substream *substream,\r\nint cmd)\r\n{\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\ncase SNDRV_PCM_TRIGGER_RESUME:\r\nif (chip->active & DAC1)\r\nreturn 0;\r\nchip->active |= DAC1;\r\nsnd_es18xx_write(chip, 0xB8, 0x05);\r\n#ifdef AVOID_POPS\r\nudelay(100000);\r\nsnd_es18xx_dsp_command(chip, 0xD1);\r\n#endif\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\ncase SNDRV_PCM_TRIGGER_SUSPEND:\r\nif (!(chip->active & DAC1))\r\nreturn 0;\r\nchip->active &= ~DAC1;\r\nsnd_es18xx_write(chip, 0xB8, 0x00);\r\n#ifdef AVOID_POPS\r\nudelay(25000);\r\nsnd_es18xx_dsp_command(chip, 0xD3);\r\n#endif\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_es18xx_playback_prepare(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_es18xx *chip = snd_pcm_substream_chip(substream);\r\nif (substream->number == 0 && (chip->caps & ES18XX_PCM2))\r\nreturn snd_es18xx_playback1_prepare(chip, substream);\r\nelse\r\nreturn snd_es18xx_playback2_prepare(chip, substream);\r\n}\r\nstatic int snd_es18xx_playback_trigger(struct snd_pcm_substream *substream,\r\nint cmd)\r\n{\r\nstruct snd_es18xx *chip = snd_pcm_substream_chip(substream);\r\nif (substream->number == 0 && (chip->caps & ES18XX_PCM2))\r\nreturn snd_es18xx_playback1_trigger(chip, substream, cmd);\r\nelse\r\nreturn snd_es18xx_playback2_trigger(chip, substream, cmd);\r\n}\r\nstatic irqreturn_t snd_es18xx_interrupt(int irq, void *dev_id)\r\n{\r\nstruct snd_card *card = dev_id;\r\nstruct snd_es18xx *chip = card->private_data;\r\nunsigned char status;\r\nif (chip->caps & ES18XX_CONTROL) {\r\nstatus = inb(chip->ctrl_port + 6);\r\n} else {\r\nstatus = snd_es18xx_mixer_read(chip, 0x7f) >> 4;\r\n}\r\n#if 0\r\nelse {\r\nstatus = 0;\r\nif (inb(chip->port + 0x0C) & 0x01)\r\nstatus |= AUDIO1_IRQ;\r\nif (snd_es18xx_mixer_read(chip, 0x7A) & 0x80)\r\nstatus |= AUDIO2_IRQ;\r\nif ((chip->caps & ES18XX_HWV) &&\r\nsnd_es18xx_mixer_read(chip, 0x64) & 0x10)\r\nstatus |= HWV_IRQ;\r\n}\r\n#endif\r\nif (status & AUDIO2_IRQ) {\r\nif (chip->active & DAC2)\r\nsnd_pcm_period_elapsed(chip->playback_a_substream);\r\nsnd_es18xx_mixer_bits(chip, 0x7A, 0x80, 0x00);\r\n}\r\nif (status & AUDIO1_IRQ) {\r\nif (chip->active & ADC1)\r\nsnd_pcm_period_elapsed(chip->capture_a_substream);\r\nelse if (chip->active & DAC1)\r\nsnd_pcm_period_elapsed(chip->playback_b_substream);\r\ninb(chip->port + 0x0E);\r\n}\r\nif ((status & MPU_IRQ) && chip->rmidi)\r\nsnd_mpu401_uart_interrupt(irq, chip->rmidi->private_data);\r\nif (status & HWV_IRQ) {\r\nint split = 0;\r\nif (chip->caps & ES18XX_HWV) {\r\nsplit = snd_es18xx_mixer_read(chip, 0x64) & 0x80;\r\nsnd_ctl_notify(card, SNDRV_CTL_EVENT_MASK_VALUE,\r\n&chip->hw_switch->id);\r\nsnd_ctl_notify(card, SNDRV_CTL_EVENT_MASK_VALUE,\r\n&chip->hw_volume->id);\r\n}\r\nif (!split) {\r\nsnd_ctl_notify(card, SNDRV_CTL_EVENT_MASK_VALUE,\r\n&chip->master_switch->id);\r\nsnd_ctl_notify(card, SNDRV_CTL_EVENT_MASK_VALUE,\r\n&chip->master_volume->id);\r\n}\r\nsnd_es18xx_mixer_write(chip, 0x66, 0x00);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic snd_pcm_uframes_t snd_es18xx_playback_pointer(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_es18xx *chip = snd_pcm_substream_chip(substream);\r\nunsigned int size = snd_pcm_lib_buffer_bytes(substream);\r\nint pos;\r\nif (substream->number == 0 && (chip->caps & ES18XX_PCM2)) {\r\nif (!(chip->active & DAC2))\r\nreturn 0;\r\npos = snd_dma_pointer(chip->dma2, size);\r\nreturn pos >> chip->dma2_shift;\r\n} else {\r\nif (!(chip->active & DAC1))\r\nreturn 0;\r\npos = snd_dma_pointer(chip->dma1, size);\r\nreturn pos >> chip->dma1_shift;\r\n}\r\n}\r\nstatic snd_pcm_uframes_t snd_es18xx_capture_pointer(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_es18xx *chip = snd_pcm_substream_chip(substream);\r\nunsigned int size = snd_pcm_lib_buffer_bytes(substream);\r\nint pos;\r\nif (!(chip->active & ADC1))\r\nreturn 0;\r\npos = snd_dma_pointer(chip->dma1, size);\r\nreturn pos >> chip->dma1_shift;\r\n}\r\nstatic int snd_es18xx_playback_open(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct snd_es18xx *chip = snd_pcm_substream_chip(substream);\r\nif (substream->number == 0 && (chip->caps & ES18XX_PCM2)) {\r\nif ((chip->caps & ES18XX_DUPLEX_MONO) &&\r\nchip->capture_a_substream &&\r\nchip->capture_a_substream->runtime->channels != 1)\r\nreturn -EAGAIN;\r\nchip->playback_a_substream = substream;\r\n} else if (substream->number <= 1) {\r\nif (chip->capture_a_substream)\r\nreturn -EAGAIN;\r\nchip->playback_b_substream = substream;\r\n} else {\r\nsnd_BUG();\r\nreturn -EINVAL;\r\n}\r\nsubstream->runtime->hw = snd_es18xx_playback;\r\nsnd_pcm_hw_constraint_ratnums(runtime, 0, SNDRV_PCM_HW_PARAM_RATE,\r\n(chip->caps & ES18XX_NEW_RATE) ? &new_hw_constraints_clocks : &old_hw_constraints_clocks);\r\nreturn 0;\r\n}\r\nstatic int snd_es18xx_capture_open(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct snd_es18xx *chip = snd_pcm_substream_chip(substream);\r\nif (chip->playback_b_substream)\r\nreturn -EAGAIN;\r\nif ((chip->caps & ES18XX_DUPLEX_MONO) &&\r\nchip->playback_a_substream &&\r\nchip->playback_a_substream->runtime->channels != 1)\r\nreturn -EAGAIN;\r\nchip->capture_a_substream = substream;\r\nsubstream->runtime->hw = snd_es18xx_capture;\r\nsnd_pcm_hw_constraint_ratnums(runtime, 0, SNDRV_PCM_HW_PARAM_RATE,\r\n(chip->caps & ES18XX_NEW_RATE) ? &new_hw_constraints_clocks : &old_hw_constraints_clocks);\r\nreturn 0;\r\n}\r\nstatic int snd_es18xx_playback_close(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_es18xx *chip = snd_pcm_substream_chip(substream);\r\nif (substream->number == 0 && (chip->caps & ES18XX_PCM2))\r\nchip->playback_a_substream = NULL;\r\nelse\r\nchip->playback_b_substream = NULL;\r\nsnd_pcm_lib_free_pages(substream);\r\nreturn 0;\r\n}\r\nstatic int snd_es18xx_capture_close(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_es18xx *chip = snd_pcm_substream_chip(substream);\r\nchip->capture_a_substream = NULL;\r\nsnd_pcm_lib_free_pages(substream);\r\nreturn 0;\r\n}\r\nstatic int snd_es18xx_info_mux(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\r\n{\r\nstatic char *texts5Source[5] = {\r\n"Mic", "CD", "Line", "Master", "Mix"\r\n};\r\nstatic char *texts8Source[8] = {\r\n"Mic", "Mic Master", "CD", "AOUT",\r\n"Mic1", "Mix", "Line", "Master"\r\n};\r\nstruct snd_es18xx *chip = snd_kcontrol_chip(kcontrol);\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;\r\nuinfo->count = 1;\r\nswitch (chip->version) {\r\ncase 0x1868:\r\ncase 0x1878:\r\nuinfo->value.enumerated.items = 4;\r\nif (uinfo->value.enumerated.item > 3)\r\nuinfo->value.enumerated.item = 3;\r\nstrcpy(uinfo->value.enumerated.name,\r\ntexts5Source[uinfo->value.enumerated.item]);\r\nbreak;\r\ncase 0x1887:\r\ncase 0x1888:\r\nuinfo->value.enumerated.items = 5;\r\nif (uinfo->value.enumerated.item > 4)\r\nuinfo->value.enumerated.item = 4;\r\nstrcpy(uinfo->value.enumerated.name, texts5Source[uinfo->value.enumerated.item]);\r\nbreak;\r\ncase 0x1869:\r\ncase 0x1879:\r\nuinfo->value.enumerated.items = 8;\r\nif (uinfo->value.enumerated.item > 7)\r\nuinfo->value.enumerated.item = 7;\r\nstrcpy(uinfo->value.enumerated.name, texts8Source[uinfo->value.enumerated.item]);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_es18xx_get_mux(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstatic unsigned char invMap4Source[8] = {0, 0, 1, 1, 0, 0, 2, 3};\r\nstruct snd_es18xx *chip = snd_kcontrol_chip(kcontrol);\r\nint muxSource = snd_es18xx_mixer_read(chip, 0x1c) & 0x07;\r\nif (!(chip->version == 0x1869 || chip->version == 0x1879)) {\r\nmuxSource = invMap4Source[muxSource];\r\nif (muxSource==3 &&\r\n(chip->version == 0x1887 || chip->version == 0x1888) &&\r\n(snd_es18xx_mixer_read(chip, 0x7a) & 0x08)\r\n)\r\nmuxSource = 4;\r\n}\r\nucontrol->value.enumerated.item[0] = muxSource;\r\nreturn 0;\r\n}\r\nstatic int snd_es18xx_put_mux(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstatic unsigned char map4Source[4] = {0, 2, 6, 7};\r\nstruct snd_es18xx *chip = snd_kcontrol_chip(kcontrol);\r\nunsigned char val = ucontrol->value.enumerated.item[0];\r\nunsigned char retVal = 0;\r\nswitch (chip->version) {\r\ncase 0x1887:\r\ncase 0x1888:\r\nif (val > 4)\r\nreturn -EINVAL;\r\nif (val == 4) {\r\nretVal = snd_es18xx_mixer_bits(chip, 0x7a, 0x08, 0x08) != 0x08;\r\nval = 3;\r\n} else\r\nretVal = snd_es18xx_mixer_bits(chip, 0x7a, 0x08, 0x00) != 0x00;\r\ncase 0x1868:\r\ncase 0x1878:\r\nif (val > 3)\r\nreturn -EINVAL;\r\nval = map4Source[val];\r\nbreak;\r\ncase 0x1869:\r\ncase 0x1879:\r\nif (val > 7)\r\nreturn -EINVAL;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn (snd_es18xx_mixer_bits(chip, 0x1c, 0x07, val) != val) || retVal;\r\n}\r\nstatic int snd_es18xx_get_spatializer_enable(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_es18xx *chip = snd_kcontrol_chip(kcontrol);\r\nunsigned char val = snd_es18xx_mixer_read(chip, 0x50);\r\nucontrol->value.integer.value[0] = !!(val & 8);\r\nreturn 0;\r\n}\r\nstatic int snd_es18xx_put_spatializer_enable(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_es18xx *chip = snd_kcontrol_chip(kcontrol);\r\nunsigned char oval, nval;\r\nint change;\r\nnval = ucontrol->value.integer.value[0] ? 0x0c : 0x04;\r\noval = snd_es18xx_mixer_read(chip, 0x50) & 0x0c;\r\nchange = nval != oval;\r\nif (change) {\r\nsnd_es18xx_mixer_write(chip, 0x50, nval & ~0x04);\r\nsnd_es18xx_mixer_write(chip, 0x50, nval);\r\n}\r\nreturn change;\r\n}\r\nstatic int snd_es18xx_info_hw_volume(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\r\n{\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\r\nuinfo->count = 2;\r\nuinfo->value.integer.min = 0;\r\nuinfo->value.integer.max = 63;\r\nreturn 0;\r\n}\r\nstatic int snd_es18xx_get_hw_volume(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_es18xx *chip = snd_kcontrol_chip(kcontrol);\r\nucontrol->value.integer.value[0] = snd_es18xx_mixer_read(chip, 0x61) & 0x3f;\r\nucontrol->value.integer.value[1] = snd_es18xx_mixer_read(chip, 0x63) & 0x3f;\r\nreturn 0;\r\n}\r\nstatic int snd_es18xx_get_hw_switch(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_es18xx *chip = snd_kcontrol_chip(kcontrol);\r\nucontrol->value.integer.value[0] = !(snd_es18xx_mixer_read(chip, 0x61) & 0x40);\r\nucontrol->value.integer.value[1] = !(snd_es18xx_mixer_read(chip, 0x63) & 0x40);\r\nreturn 0;\r\n}\r\nstatic void snd_es18xx_hwv_free(struct snd_kcontrol *kcontrol)\r\n{\r\nstruct snd_es18xx *chip = snd_kcontrol_chip(kcontrol);\r\nchip->master_volume = NULL;\r\nchip->master_switch = NULL;\r\nchip->hw_volume = NULL;\r\nchip->hw_switch = NULL;\r\n}\r\nstatic int snd_es18xx_reg_bits(struct snd_es18xx *chip, unsigned char reg,\r\nunsigned char mask, unsigned char val)\r\n{\r\nif (reg < 0xa0)\r\nreturn snd_es18xx_mixer_bits(chip, reg, mask, val);\r\nelse\r\nreturn snd_es18xx_bits(chip, reg, mask, val);\r\n}\r\nstatic int snd_es18xx_reg_read(struct snd_es18xx *chip, unsigned char reg)\r\n{\r\nif (reg < 0xa0)\r\nreturn snd_es18xx_mixer_read(chip, reg);\r\nelse\r\nreturn snd_es18xx_read(chip, reg);\r\n}\r\nstatic int snd_es18xx_info_single(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\r\n{\r\nint mask = (kcontrol->private_value >> 16) & 0xff;\r\nuinfo->type = mask == 1 ? SNDRV_CTL_ELEM_TYPE_BOOLEAN : SNDRV_CTL_ELEM_TYPE_INTEGER;\r\nuinfo->count = 1;\r\nuinfo->value.integer.min = 0;\r\nuinfo->value.integer.max = mask;\r\nreturn 0;\r\n}\r\nstatic int snd_es18xx_get_single(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_es18xx *chip = snd_kcontrol_chip(kcontrol);\r\nint reg = kcontrol->private_value & 0xff;\r\nint shift = (kcontrol->private_value >> 8) & 0xff;\r\nint mask = (kcontrol->private_value >> 16) & 0xff;\r\nint invert = (kcontrol->private_value >> 24) & 0xff;\r\nint val;\r\nval = snd_es18xx_reg_read(chip, reg);\r\nucontrol->value.integer.value[0] = (val >> shift) & mask;\r\nif (invert)\r\nucontrol->value.integer.value[0] = mask - ucontrol->value.integer.value[0];\r\nreturn 0;\r\n}\r\nstatic int snd_es18xx_put_single(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_es18xx *chip = snd_kcontrol_chip(kcontrol);\r\nint reg = kcontrol->private_value & 0xff;\r\nint shift = (kcontrol->private_value >> 8) & 0xff;\r\nint mask = (kcontrol->private_value >> 16) & 0xff;\r\nint invert = (kcontrol->private_value >> 24) & 0xff;\r\nunsigned char val;\r\nval = (ucontrol->value.integer.value[0] & mask);\r\nif (invert)\r\nval = mask - val;\r\nmask <<= shift;\r\nval <<= shift;\r\nreturn snd_es18xx_reg_bits(chip, reg, mask, val) != val;\r\n}\r\nstatic int snd_es18xx_info_double(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\r\n{\r\nint mask = (kcontrol->private_value >> 24) & 0xff;\r\nuinfo->type = mask == 1 ? SNDRV_CTL_ELEM_TYPE_BOOLEAN : SNDRV_CTL_ELEM_TYPE_INTEGER;\r\nuinfo->count = 2;\r\nuinfo->value.integer.min = 0;\r\nuinfo->value.integer.max = mask;\r\nreturn 0;\r\n}\r\nstatic int snd_es18xx_get_double(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_es18xx *chip = snd_kcontrol_chip(kcontrol);\r\nint left_reg = kcontrol->private_value & 0xff;\r\nint right_reg = (kcontrol->private_value >> 8) & 0xff;\r\nint shift_left = (kcontrol->private_value >> 16) & 0x07;\r\nint shift_right = (kcontrol->private_value >> 19) & 0x07;\r\nint mask = (kcontrol->private_value >> 24) & 0xff;\r\nint invert = (kcontrol->private_value >> 22) & 1;\r\nunsigned char left, right;\r\nleft = snd_es18xx_reg_read(chip, left_reg);\r\nif (left_reg != right_reg)\r\nright = snd_es18xx_reg_read(chip, right_reg);\r\nelse\r\nright = left;\r\nucontrol->value.integer.value[0] = (left >> shift_left) & mask;\r\nucontrol->value.integer.value[1] = (right >> shift_right) & mask;\r\nif (invert) {\r\nucontrol->value.integer.value[0] = mask - ucontrol->value.integer.value[0];\r\nucontrol->value.integer.value[1] = mask - ucontrol->value.integer.value[1];\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_es18xx_put_double(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_es18xx *chip = snd_kcontrol_chip(kcontrol);\r\nint left_reg = kcontrol->private_value & 0xff;\r\nint right_reg = (kcontrol->private_value >> 8) & 0xff;\r\nint shift_left = (kcontrol->private_value >> 16) & 0x07;\r\nint shift_right = (kcontrol->private_value >> 19) & 0x07;\r\nint mask = (kcontrol->private_value >> 24) & 0xff;\r\nint invert = (kcontrol->private_value >> 22) & 1;\r\nint change;\r\nunsigned char val1, val2, mask1, mask2;\r\nval1 = ucontrol->value.integer.value[0] & mask;\r\nval2 = ucontrol->value.integer.value[1] & mask;\r\nif (invert) {\r\nval1 = mask - val1;\r\nval2 = mask - val2;\r\n}\r\nval1 <<= shift_left;\r\nval2 <<= shift_right;\r\nmask1 = mask << shift_left;\r\nmask2 = mask << shift_right;\r\nif (left_reg != right_reg) {\r\nchange = 0;\r\nif (snd_es18xx_reg_bits(chip, left_reg, mask1, val1) != val1)\r\nchange = 1;\r\nif (snd_es18xx_reg_bits(chip, right_reg, mask2, val2) != val2)\r\nchange = 1;\r\n} else {\r\nchange = (snd_es18xx_reg_bits(chip, left_reg, mask1 | mask2,\r\nval1 | val2) != (val1 | val2));\r\n}\r\nreturn change;\r\n}\r\nstatic int snd_es18xx_config_read(struct snd_es18xx *chip, unsigned char reg)\r\n{\r\nint data;\r\noutb(reg, chip->ctrl_port);\r\ndata = inb(chip->ctrl_port + 1);\r\nreturn data;\r\n}\r\nstatic void snd_es18xx_config_write(struct snd_es18xx *chip,\r\nunsigned char reg, unsigned char data)\r\n{\r\noutb(reg, chip->ctrl_port);\r\noutb(data, chip->ctrl_port + 1);\r\n#ifdef REG_DEBUG\r\nsnd_printk(KERN_DEBUG "Config reg %02x set to %02x\n", reg, data);\r\n#endif\r\n}\r\nstatic int snd_es18xx_initialize(struct snd_es18xx *chip,\r\nunsigned long mpu_port,\r\nunsigned long fm_port)\r\n{\r\nint mask = 0;\r\nsnd_es18xx_dsp_command(chip, 0xC6);\r\nsnd_es18xx_mixer_write(chip, 0x00, 0x00);\r\nsnd_es18xx_write(chip, 0xB9, 2);\r\nif (chip->caps & ES18XX_CONTROL) {\r\nsnd_es18xx_config_write(chip, 0x27, chip->irq);\r\nif (fm_port > 0 && fm_port != SNDRV_AUTO_PORT) {\r\nsnd_es18xx_config_write(chip, 0x62, fm_port >> 8);\r\nsnd_es18xx_config_write(chip, 0x63, fm_port & 0xff);\r\n}\r\nif (mpu_port > 0 && mpu_port != SNDRV_AUTO_PORT) {\r\nsnd_es18xx_config_write(chip, 0x64, mpu_port >> 8);\r\nsnd_es18xx_config_write(chip, 0x65, mpu_port & 0xff);\r\nsnd_es18xx_config_write(chip, 0x28, chip->irq);\r\n}\r\nsnd_es18xx_config_write(chip, 0x70, chip->irq);\r\nsnd_es18xx_config_write(chip, 0x72, chip->irq);\r\nsnd_es18xx_config_write(chip, 0x74, chip->dma1);\r\nsnd_es18xx_config_write(chip, 0x75, chip->dma2);\r\nsnd_es18xx_write(chip, 0xB1, 0x50);\r\nsnd_es18xx_mixer_write(chip, 0x7A, 0x40);\r\nsnd_es18xx_write(chip, 0xB2, 0x50);\r\nsnd_es18xx_mixer_write(chip, 0x64, 0x42);\r\nsnd_es18xx_mixer_bits(chip, 0x48, 0x10, 0x10);\r\n}\r\nelse {\r\nint irqmask, dma1mask, dma2mask;\r\nswitch (chip->irq) {\r\ncase 2:\r\ncase 9:\r\nirqmask = 0;\r\nbreak;\r\ncase 5:\r\nirqmask = 1;\r\nbreak;\r\ncase 7:\r\nirqmask = 2;\r\nbreak;\r\ncase 10:\r\nirqmask = 3;\r\nbreak;\r\ndefault:\r\nsnd_printk(KERN_ERR "invalid irq %d\n", chip->irq);\r\nreturn -ENODEV;\r\n}\r\nswitch (chip->dma1) {\r\ncase 0:\r\ndma1mask = 1;\r\nbreak;\r\ncase 1:\r\ndma1mask = 2;\r\nbreak;\r\ncase 3:\r\ndma1mask = 3;\r\nbreak;\r\ndefault:\r\nsnd_printk(KERN_ERR "invalid dma1 %d\n", chip->dma1);\r\nreturn -ENODEV;\r\n}\r\nswitch (chip->dma2) {\r\ncase 0:\r\ndma2mask = 0;\r\nbreak;\r\ncase 1:\r\ndma2mask = 1;\r\nbreak;\r\ncase 3:\r\ndma2mask = 2;\r\nbreak;\r\ncase 5:\r\ndma2mask = 3;\r\nbreak;\r\ndefault:\r\nsnd_printk(KERN_ERR "invalid dma2 %d\n", chip->dma2);\r\nreturn -ENODEV;\r\n}\r\nsnd_es18xx_write(chip, 0xB1, 0x50 | (irqmask << 2));\r\nsnd_es18xx_write(chip, 0xB2, 0x50 | (dma1mask << 2));\r\nsnd_es18xx_mixer_bits(chip, 0x7d, 0x07, 0x04 | dma2mask);\r\nsnd_es18xx_mixer_write(chip, 0x7A, 0x68);\r\nsnd_es18xx_mixer_write(chip, 0x64, 0x06);\r\nif (mpu_port > 0 && mpu_port != SNDRV_AUTO_PORT) {\r\nsnd_es18xx_mixer_write(chip, 0x40,\r\n0x43 | (mpu_port & 0xf0) >> 1);\r\n}\r\nsnd_es18xx_mixer_write(chip, 0x7f, ((irqmask + 1) << 1) | 0x01);\r\n}\r\nif (chip->caps & ES18XX_NEW_RATE) {\r\nsnd_es18xx_mixer_write(chip, 0x71, 0x32);\r\n}\r\nif (!(chip->caps & ES18XX_PCM2)) {\r\nsnd_es18xx_write(chip, 0xB7, 0x80);\r\n}\r\nif (chip->caps & ES18XX_SPATIALIZER) {\r\nsnd_es18xx_mixer_write(chip, 0x54, 0x8f);\r\nsnd_es18xx_mixer_write(chip, 0x56, 0x95);\r\nsnd_es18xx_mixer_write(chip, 0x58, 0x94);\r\nsnd_es18xx_mixer_write(chip, 0x5a, 0x80);\r\n}\r\nswitch (chip->version) {\r\ncase 0x1879:\r\ncase 0x1878:\r\nsnd_es18xx_config_write(chip, 0x29, snd_es18xx_config_read(chip, 0x29) | 0x40);\r\nbreak;\r\n}\r\nif (chip->caps & ES18XX_MUTEREC)\r\nmask = 0x10;\r\nif (chip->caps & ES18XX_RECMIX)\r\nsnd_es18xx_mixer_write(chip, 0x1c, 0x05 | mask);\r\nelse {\r\nsnd_es18xx_mixer_write(chip, 0x1c, 0x00 | mask);\r\nsnd_es18xx_write(chip, 0xb4, 0x00);\r\n}\r\n#ifndef AVOID_POPS\r\nsnd_es18xx_dsp_command(chip, 0xD1);\r\n#endif\r\nreturn 0;\r\n}\r\nstatic int snd_es18xx_identify(struct snd_es18xx *chip)\r\n{\r\nint hi,lo;\r\nif (snd_es18xx_reset(chip) < 0) {\r\nsnd_printk(KERN_ERR "reset at 0x%lx failed!!!\n", chip->port);\r\nreturn -ENODEV;\r\n}\r\nsnd_es18xx_dsp_command(chip, 0xe7);\r\nhi = snd_es18xx_dsp_get_byte(chip);\r\nif (hi < 0) {\r\nreturn hi;\r\n}\r\nlo = snd_es18xx_dsp_get_byte(chip);\r\nif ((lo & 0xf0) != 0x80) {\r\nreturn -ENODEV;\r\n}\r\nif (hi == 0x48) {\r\nchip->version = 0x488;\r\nreturn 0;\r\n}\r\nif (hi != 0x68) {\r\nreturn -ENODEV;\r\n}\r\nif ((lo & 0x0f) < 8) {\r\nchip->version = 0x688;\r\nreturn 0;\r\n}\r\noutb(0x40, chip->port + 0x04);\r\nudelay(10);\r\nhi = inb(chip->port + 0x05);\r\nudelay(10);\r\nlo = inb(chip->port + 0x05);\r\nif (hi != lo) {\r\nchip->version = hi << 8 | lo;\r\nchip->ctrl_port = inb(chip->port + 0x05) << 8;\r\nudelay(10);\r\nchip->ctrl_port += inb(chip->port + 0x05);\r\nif ((chip->res_ctrl_port = request_region(chip->ctrl_port, 8, "ES18xx - CTRL")) == NULL) {\r\nsnd_printk(KERN_ERR PFX "unable go grab port 0x%lx\n", chip->ctrl_port);\r\nreturn -EBUSY;\r\n}\r\nreturn 0;\r\n}\r\nif (snd_es18xx_mixer_writable(chip, 0x64, 0x04)) {\r\nif (snd_es18xx_mixer_writable(chip, 0x70, 0x7f)) {\r\nif (snd_es18xx_mixer_writable(chip, 0x64, 0x20)) {\r\nchip->version = 0x1887;\r\n} else {\r\nchip->version = 0x1888;\r\n}\r\n} else {\r\nchip->version = 0x1788;\r\n}\r\n}\r\nelse\r\nchip->version = 0x1688;\r\nreturn 0;\r\n}\r\nstatic int snd_es18xx_probe(struct snd_es18xx *chip,\r\nunsigned long mpu_port,\r\nunsigned long fm_port)\r\n{\r\nif (snd_es18xx_identify(chip) < 0) {\r\nsnd_printk(KERN_ERR PFX "[0x%lx] ESS chip not found\n", chip->port);\r\nreturn -ENODEV;\r\n}\r\nswitch (chip->version) {\r\ncase 0x1868:\r\nchip->caps = ES18XX_DUPLEX_MONO | ES18XX_DUPLEX_SAME | ES18XX_CONTROL;\r\nbreak;\r\ncase 0x1869:\r\nchip->caps = ES18XX_PCM2 | ES18XX_SPATIALIZER | ES18XX_RECMIX | ES18XX_NEW_RATE | ES18XX_AUXB | ES18XX_MONO | ES18XX_MUTEREC | ES18XX_CONTROL | ES18XX_HWV;\r\nbreak;\r\ncase 0x1878:\r\nchip->caps = ES18XX_DUPLEX_MONO | ES18XX_DUPLEX_SAME | ES18XX_I2S | ES18XX_CONTROL;\r\nbreak;\r\ncase 0x1879:\r\nchip->caps = ES18XX_PCM2 | ES18XX_SPATIALIZER | ES18XX_RECMIX | ES18XX_NEW_RATE | ES18XX_AUXB | ES18XX_I2S | ES18XX_CONTROL | ES18XX_HWV;\r\nbreak;\r\ncase 0x1887:\r\ncase 0x1888:\r\nchip->caps = ES18XX_PCM2 | ES18XX_RECMIX | ES18XX_AUXB | ES18XX_DUPLEX_SAME;\r\nbreak;\r\ndefault:\r\nsnd_printk(KERN_ERR "[0x%lx] unsupported chip ES%x\n",\r\nchip->port, chip->version);\r\nreturn -ENODEV;\r\n}\r\nsnd_printd("[0x%lx] ESS%x chip found\n", chip->port, chip->version);\r\nif (chip->dma1 == chip->dma2)\r\nchip->caps &= ~(ES18XX_PCM2 | ES18XX_DUPLEX_SAME);\r\nreturn snd_es18xx_initialize(chip, mpu_port, fm_port);\r\n}\r\nstatic int snd_es18xx_pcm(struct snd_card *card, int device,\r\nstruct snd_pcm **rpcm)\r\n{\r\nstruct snd_es18xx *chip = card->private_data;\r\nstruct snd_pcm *pcm;\r\nchar str[16];\r\nint err;\r\nif (rpcm)\r\n*rpcm = NULL;\r\nsprintf(str, "ES%x", chip->version);\r\nif (chip->caps & ES18XX_PCM2)\r\nerr = snd_pcm_new(card, str, device, 2, 1, &pcm);\r\nelse\r\nerr = snd_pcm_new(card, str, device, 1, 1, &pcm);\r\nif (err < 0)\r\nreturn err;\r\nsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &snd_es18xx_playback_ops);\r\nsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &snd_es18xx_capture_ops);\r\npcm->private_data = chip;\r\npcm->info_flags = 0;\r\nif (chip->caps & ES18XX_DUPLEX_SAME)\r\npcm->info_flags |= SNDRV_PCM_INFO_JOINT_DUPLEX;\r\nif (! (chip->caps & ES18XX_PCM2))\r\npcm->info_flags |= SNDRV_PCM_INFO_HALF_DUPLEX;\r\nsprintf(pcm->name, "ESS AudioDrive ES%x", chip->version);\r\nchip->pcm = pcm;\r\nsnd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_DEV,\r\nsnd_dma_isa_data(),\r\n64*1024,\r\nchip->dma1 > 3 || chip->dma2 > 3 ? 128*1024 : 64*1024);\r\nif (rpcm)\r\n*rpcm = pcm;\r\nreturn 0;\r\n}\r\nstatic int snd_es18xx_suspend(struct snd_card *card, pm_message_t state)\r\n{\r\nstruct snd_es18xx *chip = card->private_data;\r\nsnd_power_change_state(card, SNDRV_CTL_POWER_D3hot);\r\nsnd_pcm_suspend_all(chip->pcm);\r\nchip->pm_reg = (unsigned char)snd_es18xx_read(chip, ES18XX_PM);\r\nchip->pm_reg |= (ES18XX_PM_FM | ES18XX_PM_SUS);\r\nsnd_es18xx_write(chip, ES18XX_PM, chip->pm_reg);\r\nsnd_es18xx_write(chip, ES18XX_PM, chip->pm_reg ^= ES18XX_PM_SUS);\r\nreturn 0;\r\n}\r\nstatic int snd_es18xx_resume(struct snd_card *card)\r\n{\r\nstruct snd_es18xx *chip = card->private_data;\r\nsnd_es18xx_write(chip, ES18XX_PM, chip->pm_reg ^= ES18XX_PM_FM);\r\nsnd_power_change_state(card, SNDRV_CTL_POWER_D0);\r\nreturn 0;\r\n}\r\nstatic int snd_es18xx_free(struct snd_card *card)\r\n{\r\nstruct snd_es18xx *chip = card->private_data;\r\nrelease_and_free_resource(chip->res_port);\r\nrelease_and_free_resource(chip->res_ctrl_port);\r\nrelease_and_free_resource(chip->res_mpu_port);\r\nif (chip->irq >= 0)\r\nfree_irq(chip->irq, (void *) card);\r\nif (chip->dma1 >= 0) {\r\ndisable_dma(chip->dma1);\r\nfree_dma(chip->dma1);\r\n}\r\nif (chip->dma2 >= 0 && chip->dma1 != chip->dma2) {\r\ndisable_dma(chip->dma2);\r\nfree_dma(chip->dma2);\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_es18xx_dev_free(struct snd_device *device)\r\n{\r\nreturn snd_es18xx_free(device->card);\r\n}\r\nstatic int snd_es18xx_new_device(struct snd_card *card,\r\nunsigned long port,\r\nunsigned long mpu_port,\r\nunsigned long fm_port,\r\nint irq, int dma1, int dma2)\r\n{\r\nstruct snd_es18xx *chip = card->private_data;\r\nstatic struct snd_device_ops ops = {\r\n.dev_free = snd_es18xx_dev_free,\r\n};\r\nint err;\r\nspin_lock_init(&chip->reg_lock);\r\nspin_lock_init(&chip->mixer_lock);\r\nchip->port = port;\r\nchip->irq = -1;\r\nchip->dma1 = -1;\r\nchip->dma2 = -1;\r\nchip->audio2_vol = 0x00;\r\nchip->active = 0;\r\nchip->res_port = request_region(port, 16, "ES18xx");\r\nif (chip->res_port == NULL) {\r\nsnd_es18xx_free(card);\r\nsnd_printk(KERN_ERR PFX "unable to grap ports 0x%lx-0x%lx\n", port, port + 16 - 1);\r\nreturn -EBUSY;\r\n}\r\nif (request_irq(irq, snd_es18xx_interrupt, 0, "ES18xx",\r\n(void *) card)) {\r\nsnd_es18xx_free(card);\r\nsnd_printk(KERN_ERR PFX "unable to grap IRQ %d\n", irq);\r\nreturn -EBUSY;\r\n}\r\nchip->irq = irq;\r\nif (request_dma(dma1, "ES18xx DMA 1")) {\r\nsnd_es18xx_free(card);\r\nsnd_printk(KERN_ERR PFX "unable to grap DMA1 %d\n", dma1);\r\nreturn -EBUSY;\r\n}\r\nchip->dma1 = dma1;\r\nif (dma2 != dma1 && request_dma(dma2, "ES18xx DMA 2")) {\r\nsnd_es18xx_free(card);\r\nsnd_printk(KERN_ERR PFX "unable to grap DMA2 %d\n", dma2);\r\nreturn -EBUSY;\r\n}\r\nchip->dma2 = dma2;\r\nif (snd_es18xx_probe(chip, mpu_port, fm_port) < 0) {\r\nsnd_es18xx_free(card);\r\nreturn -ENODEV;\r\n}\r\nerr = snd_device_new(card, SNDRV_DEV_LOWLEVEL, chip, &ops);\r\nif (err < 0) {\r\nsnd_es18xx_free(card);\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_es18xx_mixer(struct snd_card *card)\r\n{\r\nstruct snd_es18xx *chip = card->private_data;\r\nint err;\r\nunsigned int idx;\r\nstrcpy(card->mixername, chip->pcm->name);\r\nfor (idx = 0; idx < ARRAY_SIZE(snd_es18xx_base_controls); idx++) {\r\nstruct snd_kcontrol *kctl;\r\nkctl = snd_ctl_new1(&snd_es18xx_base_controls[idx], chip);\r\nif (chip->caps & ES18XX_HWV) {\r\nswitch (idx) {\r\ncase 0:\r\nchip->master_volume = kctl;\r\nkctl->private_free = snd_es18xx_hwv_free;\r\nbreak;\r\ncase 1:\r\nchip->master_switch = kctl;\r\nkctl->private_free = snd_es18xx_hwv_free;\r\nbreak;\r\n}\r\n}\r\nif ((err = snd_ctl_add(card, kctl)) < 0)\r\nreturn err;\r\n}\r\nif (chip->caps & ES18XX_PCM2) {\r\nfor (idx = 0; idx < ARRAY_SIZE(snd_es18xx_pcm2_controls); idx++) {\r\nif ((err = snd_ctl_add(card, snd_ctl_new1(&snd_es18xx_pcm2_controls[idx], chip))) < 0)\r\nreturn err;\r\n}\r\n} else {\r\nfor (idx = 0; idx < ARRAY_SIZE(snd_es18xx_pcm1_controls); idx++) {\r\nif ((err = snd_ctl_add(card, snd_ctl_new1(&snd_es18xx_pcm1_controls[idx], chip))) < 0)\r\nreturn err;\r\n}\r\n}\r\nif (chip->caps & ES18XX_RECMIX) {\r\nfor (idx = 0; idx < ARRAY_SIZE(snd_es18xx_recmix_controls); idx++) {\r\nif ((err = snd_ctl_add(card, snd_ctl_new1(&snd_es18xx_recmix_controls[idx], chip))) < 0)\r\nreturn err;\r\n}\r\n}\r\nswitch (chip->version) {\r\ndefault:\r\nif ((err = snd_ctl_add(card, snd_ctl_new1(&snd_es18xx_micpre1_control, chip))) < 0)\r\nreturn err;\r\nbreak;\r\ncase 0x1869:\r\ncase 0x1879:\r\nif ((err = snd_ctl_add(card, snd_ctl_new1(&snd_es18xx_micpre2_control, chip))) < 0)\r\nreturn err;\r\nbreak;\r\n}\r\nif (chip->caps & ES18XX_SPATIALIZER) {\r\nfor (idx = 0; idx < ARRAY_SIZE(snd_es18xx_spatializer_controls); idx++) {\r\nif ((err = snd_ctl_add(card, snd_ctl_new1(&snd_es18xx_spatializer_controls[idx], chip))) < 0)\r\nreturn err;\r\n}\r\n}\r\nif (chip->caps & ES18XX_HWV) {\r\nfor (idx = 0; idx < ARRAY_SIZE(snd_es18xx_hw_volume_controls); idx++) {\r\nstruct snd_kcontrol *kctl;\r\nkctl = snd_ctl_new1(&snd_es18xx_hw_volume_controls[idx], chip);\r\nif (idx == 0)\r\nchip->hw_volume = kctl;\r\nelse\r\nchip->hw_switch = kctl;\r\nkctl->private_free = snd_es18xx_hwv_free;\r\nif ((err = snd_ctl_add(card, kctl)) < 0)\r\nreturn err;\r\n}\r\n}\r\nif (chip->version != 0x1868) {\r\nerr = snd_ctl_add(card, snd_ctl_new1(&snd_es18xx_opt_speaker,\r\nchip));\r\nif (err < 0)\r\nreturn err;\r\n}\r\nif (chip->version == 0x1869) {\r\nfor (idx = 0; idx < ARRAY_SIZE(snd_es18xx_opt_1869); idx++) {\r\nerr = snd_ctl_add(card,\r\nsnd_ctl_new1(&snd_es18xx_opt_1869[idx],\r\nchip));\r\nif (err < 0)\r\nreturn err;\r\n}\r\n} else if (chip->version == 0x1878) {\r\nerr = snd_ctl_add(card, snd_ctl_new1(&snd_es18xx_opt_1878,\r\nchip));\r\nif (err < 0)\r\nreturn err;\r\n} else if (chip->version == 0x1879) {\r\nfor (idx = 0; idx < ARRAY_SIZE(snd_es18xx_opt_1879); idx++) {\r\nerr = snd_ctl_add(card,\r\nsnd_ctl_new1(&snd_es18xx_opt_1879[idx],\r\nchip));\r\nif (err < 0)\r\nreturn err;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_audiodrive_pnp_init_main(int dev, struct pnp_dev *pdev)\r\n{\r\nif (pnp_activate_dev(pdev) < 0) {\r\nsnd_printk(KERN_ERR PFX "PnP configure failure (out of resources?)\n");\r\nreturn -EBUSY;\r\n}\r\nif (pnp_device_is_isapnp(pdev)) {\r\nisapnp_cfg_begin(isapnp_card_number(pdev), isapnp_csn_number(pdev));\r\nisapnp_write_byte(0x27, pnp_irq(pdev, 0));\r\nif (mpu_port[dev] != SNDRV_AUTO_PORT)\r\nisapnp_write_byte(0x28, pnp_irq(pdev, 0));\r\nisapnp_write_byte(0x72, pnp_irq(pdev, 0));\r\nisapnp_cfg_end();\r\n}\r\nport[dev] = pnp_port_start(pdev, 0);\r\nfm_port[dev] = pnp_port_start(pdev, 1);\r\nmpu_port[dev] = pnp_port_start(pdev, 2);\r\ndma1[dev] = pnp_dma(pdev, 0);\r\ndma2[dev] = pnp_dma(pdev, 1);\r\nirq[dev] = pnp_irq(pdev, 0);\r\nsnd_printdd("PnP ES18xx: port=0x%lx, fm port=0x%lx, mpu port=0x%lx\n", port[dev], fm_port[dev], mpu_port[dev]);\r\nsnd_printdd("PnP ES18xx: dma1=%i, dma2=%i, irq=%i\n", dma1[dev], dma2[dev], irq[dev]);\r\nreturn 0;\r\n}\r\nstatic int snd_audiodrive_pnp(int dev, struct snd_es18xx *chip,\r\nstruct pnp_dev *pdev)\r\n{\r\nchip->dev = pdev;\r\nif (snd_audiodrive_pnp_init_main(dev, chip->dev) < 0)\r\nreturn -EBUSY;\r\nreturn 0;\r\n}\r\nstatic int snd_audiodrive_pnpc(int dev, struct snd_es18xx *chip,\r\nstruct pnp_card_link *card,\r\nconst struct pnp_card_device_id *id)\r\n{\r\nchip->dev = pnp_request_card_device(card, id->devs[0].id, NULL);\r\nif (chip->dev == NULL)\r\nreturn -EBUSY;\r\nchip->devc = pnp_request_card_device(card, id->devs[1].id, NULL);\r\nif (chip->devc == NULL)\r\nreturn -EBUSY;\r\nif (pnp_activate_dev(chip->devc) < 0) {\r\nsnd_printk(KERN_ERR PFX "PnP control configure failure (out of resources?)\n");\r\nreturn -EAGAIN;\r\n}\r\nsnd_printdd("pnp: port=0x%llx\n",\r\n(unsigned long long)pnp_port_start(chip->devc, 0));\r\nif (snd_audiodrive_pnp_init_main(dev, chip->dev) < 0)\r\nreturn -EBUSY;\r\nreturn 0;\r\n}\r\nstatic int snd_es18xx_card_new(int dev, struct snd_card **cardp)\r\n{\r\nreturn snd_card_create(index[dev], id[dev], THIS_MODULE,\r\nsizeof(struct snd_es18xx), cardp);\r\n}\r\nstatic int snd_audiodrive_probe(struct snd_card *card, int dev)\r\n{\r\nstruct snd_es18xx *chip = card->private_data;\r\nstruct snd_opl3 *opl3;\r\nint err;\r\nerr = snd_es18xx_new_device(card,\r\nport[dev], mpu_port[dev], fm_port[dev],\r\nirq[dev], dma1[dev], dma2[dev]);\r\nif (err < 0)\r\nreturn err;\r\nsprintf(card->driver, "ES%x", chip->version);\r\nsprintf(card->shortname, "ESS AudioDrive ES%x", chip->version);\r\nif (dma1[dev] != dma2[dev])\r\nsprintf(card->longname, "%s at 0x%lx, irq %d, dma1 %d, dma2 %d",\r\ncard->shortname,\r\nchip->port,\r\nirq[dev], dma1[dev], dma2[dev]);\r\nelse\r\nsprintf(card->longname, "%s at 0x%lx, irq %d, dma %d",\r\ncard->shortname,\r\nchip->port,\r\nirq[dev], dma1[dev]);\r\nerr = snd_es18xx_pcm(card, 0, NULL);\r\nif (err < 0)\r\nreturn err;\r\nerr = snd_es18xx_mixer(card);\r\nif (err < 0)\r\nreturn err;\r\nif (fm_port[dev] > 0 && fm_port[dev] != SNDRV_AUTO_PORT) {\r\nif (snd_opl3_create(card, fm_port[dev], fm_port[dev] + 2,\r\nOPL3_HW_OPL3, 0, &opl3) < 0) {\r\nsnd_printk(KERN_WARNING PFX\r\n"opl3 not detected at 0x%lx\n",\r\nfm_port[dev]);\r\n} else {\r\nerr = snd_opl3_hwdep_new(opl3, 0, 1, NULL);\r\nif (err < 0)\r\nreturn err;\r\n}\r\n}\r\nif (mpu_port[dev] > 0 && mpu_port[dev] != SNDRV_AUTO_PORT) {\r\nerr = snd_mpu401_uart_new(card, 0, MPU401_HW_ES18XX,\r\nmpu_port[dev], MPU401_INFO_IRQ_HOOK,\r\n-1, &chip->rmidi);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nreturn snd_card_register(card);\r\n}\r\nstatic int snd_es18xx_isa_match(struct device *pdev, unsigned int dev)\r\n{\r\nreturn enable[dev] && !is_isapnp_selected(dev);\r\n}\r\nstatic int snd_es18xx_isa_probe1(int dev, struct device *devptr)\r\n{\r\nstruct snd_card *card;\r\nint err;\r\nerr = snd_es18xx_card_new(dev, &card);\r\nif (err < 0)\r\nreturn err;\r\nsnd_card_set_dev(card, devptr);\r\nif ((err = snd_audiodrive_probe(card, dev)) < 0) {\r\nsnd_card_free(card);\r\nreturn err;\r\n}\r\ndev_set_drvdata(devptr, card);\r\nreturn 0;\r\n}\r\nstatic int snd_es18xx_isa_probe(struct device *pdev, unsigned int dev)\r\n{\r\nint err;\r\nstatic int possible_irqs[] = {5, 9, 10, 7, 11, 12, -1};\r\nstatic int possible_dmas[] = {1, 0, 3, 5, -1};\r\nif (irq[dev] == SNDRV_AUTO_IRQ) {\r\nif ((irq[dev] = snd_legacy_find_free_irq(possible_irqs)) < 0) {\r\nsnd_printk(KERN_ERR PFX "unable to find a free IRQ\n");\r\nreturn -EBUSY;\r\n}\r\n}\r\nif (dma1[dev] == SNDRV_AUTO_DMA) {\r\nif ((dma1[dev] = snd_legacy_find_free_dma(possible_dmas)) < 0) {\r\nsnd_printk(KERN_ERR PFX "unable to find a free DMA1\n");\r\nreturn -EBUSY;\r\n}\r\n}\r\nif (dma2[dev] == SNDRV_AUTO_DMA) {\r\nif ((dma2[dev] = snd_legacy_find_free_dma(possible_dmas)) < 0) {\r\nsnd_printk(KERN_ERR PFX "unable to find a free DMA2\n");\r\nreturn -EBUSY;\r\n}\r\n}\r\nif (port[dev] != SNDRV_AUTO_PORT) {\r\nreturn snd_es18xx_isa_probe1(dev, pdev);\r\n} else {\r\nstatic unsigned long possible_ports[] = {0x220, 0x240, 0x260, 0x280};\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(possible_ports); i++) {\r\nport[dev] = possible_ports[i];\r\nerr = snd_es18xx_isa_probe1(dev, pdev);\r\nif (! err)\r\nreturn 0;\r\n}\r\nreturn err;\r\n}\r\n}\r\nstatic int snd_es18xx_isa_remove(struct device *devptr,\r\nunsigned int dev)\r\n{\r\nsnd_card_free(dev_get_drvdata(devptr));\r\ndev_set_drvdata(devptr, NULL);\r\nreturn 0;\r\n}\r\nstatic int snd_es18xx_isa_suspend(struct device *dev, unsigned int n,\r\npm_message_t state)\r\n{\r\nreturn snd_es18xx_suspend(dev_get_drvdata(dev), state);\r\n}\r\nstatic int snd_es18xx_isa_resume(struct device *dev, unsigned int n)\r\n{\r\nreturn snd_es18xx_resume(dev_get_drvdata(dev));\r\n}\r\nstatic int snd_audiodrive_pnp_detect(struct pnp_dev *pdev,\r\nconst struct pnp_device_id *id)\r\n{\r\nstatic int dev;\r\nint err;\r\nstruct snd_card *card;\r\nif (pnp_device_is_isapnp(pdev))\r\nreturn -ENOENT;\r\nfor (; dev < SNDRV_CARDS; dev++) {\r\nif (enable[dev] && isapnp[dev])\r\nbreak;\r\n}\r\nif (dev >= SNDRV_CARDS)\r\nreturn -ENODEV;\r\nerr = snd_es18xx_card_new(dev, &card);\r\nif (err < 0)\r\nreturn err;\r\nif ((err = snd_audiodrive_pnp(dev, card->private_data, pdev)) < 0) {\r\nsnd_card_free(card);\r\nreturn err;\r\n}\r\nsnd_card_set_dev(card, &pdev->dev);\r\nif ((err = snd_audiodrive_probe(card, dev)) < 0) {\r\nsnd_card_free(card);\r\nreturn err;\r\n}\r\npnp_set_drvdata(pdev, card);\r\ndev++;\r\nreturn 0;\r\n}\r\nstatic void snd_audiodrive_pnp_remove(struct pnp_dev *pdev)\r\n{\r\nsnd_card_free(pnp_get_drvdata(pdev));\r\npnp_set_drvdata(pdev, NULL);\r\n}\r\nstatic int snd_audiodrive_pnp_suspend(struct pnp_dev *pdev, pm_message_t state)\r\n{\r\nreturn snd_es18xx_suspend(pnp_get_drvdata(pdev), state);\r\n}\r\nstatic int snd_audiodrive_pnp_resume(struct pnp_dev *pdev)\r\n{\r\nreturn snd_es18xx_resume(pnp_get_drvdata(pdev));\r\n}\r\nstatic int snd_audiodrive_pnpc_detect(struct pnp_card_link *pcard,\r\nconst struct pnp_card_device_id *pid)\r\n{\r\nstatic int dev;\r\nstruct snd_card *card;\r\nint res;\r\nfor ( ; dev < SNDRV_CARDS; dev++) {\r\nif (enable[dev] && isapnp[dev])\r\nbreak;\r\n}\r\nif (dev >= SNDRV_CARDS)\r\nreturn -ENODEV;\r\nres = snd_es18xx_card_new(dev, &card);\r\nif (res < 0)\r\nreturn res;\r\nif ((res = snd_audiodrive_pnpc(dev, card->private_data, pcard, pid)) < 0) {\r\nsnd_card_free(card);\r\nreturn res;\r\n}\r\nsnd_card_set_dev(card, &pcard->card->dev);\r\nif ((res = snd_audiodrive_probe(card, dev)) < 0) {\r\nsnd_card_free(card);\r\nreturn res;\r\n}\r\npnp_set_card_drvdata(pcard, card);\r\ndev++;\r\nreturn 0;\r\n}\r\nstatic void snd_audiodrive_pnpc_remove(struct pnp_card_link *pcard)\r\n{\r\nsnd_card_free(pnp_get_card_drvdata(pcard));\r\npnp_set_card_drvdata(pcard, NULL);\r\n}\r\nstatic int snd_audiodrive_pnpc_suspend(struct pnp_card_link *pcard, pm_message_t state)\r\n{\r\nreturn snd_es18xx_suspend(pnp_get_card_drvdata(pcard), state);\r\n}\r\nstatic int snd_audiodrive_pnpc_resume(struct pnp_card_link *pcard)\r\n{\r\nreturn snd_es18xx_resume(pnp_get_card_drvdata(pcard));\r\n}\r\nstatic int __init alsa_card_es18xx_init(void)\r\n{\r\nint err;\r\nerr = isa_register_driver(&snd_es18xx_isa_driver, SNDRV_CARDS);\r\n#ifdef CONFIG_PNP\r\nif (!err)\r\nisa_registered = 1;\r\nerr = pnp_register_driver(&es18xx_pnp_driver);\r\nif (!err)\r\npnp_registered = 1;\r\nerr = pnp_register_card_driver(&es18xx_pnpc_driver);\r\nif (!err)\r\npnpc_registered = 1;\r\nif (isa_registered || pnp_registered)\r\nerr = 0;\r\n#endif\r\nreturn err;\r\n}\r\nstatic void __exit alsa_card_es18xx_exit(void)\r\n{\r\n#ifdef CONFIG_PNP\r\nif (pnpc_registered)\r\npnp_unregister_card_driver(&es18xx_pnpc_driver);\r\nif (pnp_registered)\r\npnp_unregister_driver(&es18xx_pnp_driver);\r\nif (isa_registered)\r\n#endif\r\nisa_unregister_driver(&snd_es18xx_isa_driver);\r\n}
