static int wm899x_outpga_put_volsw_vu(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);\r\nint reg = kcontrol->private_value & 0xff;\r\nint ret;\r\nu16 val;\r\nret = snd_soc_put_volsw(kcontrol, ucontrol);\r\nif (ret < 0)\r\nreturn ret;\r\nval = snd_soc_read(codec, reg);\r\nreturn snd_soc_write(codec, reg, val | 0x0100);\r\n}\r\nstatic int inmixer_event(struct snd_soc_dapm_widget *w,\r\nstruct snd_kcontrol *kcontrol, int event)\r\n{\r\nu16 reg, fakepower;\r\nreg = snd_soc_read(w->codec, WM8991_POWER_MANAGEMENT_2);\r\nfakepower = snd_soc_read(w->codec, WM8991_INTDRIVBITS);\r\nif (fakepower & ((1 << WM8991_INMIXL_PWR_BIT) |\r\n(1 << WM8991_AINLMUX_PWR_BIT)))\r\nreg |= WM8991_AINL_ENA;\r\nelse\r\nreg &= ~WM8991_AINL_ENA;\r\nif (fakepower & ((1 << WM8991_INMIXR_PWR_BIT) |\r\n(1 << WM8991_AINRMUX_PWR_BIT)))\r\nreg |= WM8991_AINR_ENA;\r\nelse\r\nreg &= ~WM8991_AINR_ENA;\r\nsnd_soc_write(w->codec, WM8991_POWER_MANAGEMENT_2, reg);\r\nreturn 0;\r\n}\r\nstatic int outmixer_event(struct snd_soc_dapm_widget *w,\r\nstruct snd_kcontrol *kcontrol, int event)\r\n{\r\nu32 reg_shift = kcontrol->private_value & 0xfff;\r\nint ret = 0;\r\nu16 reg;\r\nswitch (reg_shift) {\r\ncase WM8991_SPEAKER_MIXER | (WM8991_LDSPK_BIT << 8):\r\nreg = snd_soc_read(w->codec, WM8991_OUTPUT_MIXER1);\r\nif (reg & WM8991_LDLO) {\r\nprintk(KERN_WARNING\r\n"Cannot set as Output Mixer 1 LDLO Set\n");\r\nret = -1;\r\n}\r\nbreak;\r\ncase WM8991_SPEAKER_MIXER | (WM8991_RDSPK_BIT << 8):\r\nreg = snd_soc_read(w->codec, WM8991_OUTPUT_MIXER2);\r\nif (reg & WM8991_RDRO) {\r\nprintk(KERN_WARNING\r\n"Cannot set as Output Mixer 2 RDRO Set\n");\r\nret = -1;\r\n}\r\nbreak;\r\ncase WM8991_OUTPUT_MIXER1 | (WM8991_LDLO_BIT << 8):\r\nreg = snd_soc_read(w->codec, WM8991_SPEAKER_MIXER);\r\nif (reg & WM8991_LDSPK) {\r\nprintk(KERN_WARNING\r\n"Cannot set as Speaker Mixer LDSPK Set\n");\r\nret = -1;\r\n}\r\nbreak;\r\ncase WM8991_OUTPUT_MIXER2 | (WM8991_RDRO_BIT << 8):\r\nreg = snd_soc_read(w->codec, WM8991_SPEAKER_MIXER);\r\nif (reg & WM8991_RDSPK) {\r\nprintk(KERN_WARNING\r\n"Cannot set as Speaker Mixer RDSPK Set\n");\r\nret = -1;\r\n}\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic void pll_factors(struct _pll_div *pll_div, unsigned int target,\r\nunsigned int source)\r\n{\r\nu64 Kpart;\r\nunsigned int K, Ndiv, Nmod;\r\nNdiv = target / source;\r\nif (Ndiv < 6) {\r\nsource >>= 1;\r\npll_div->div2 = 1;\r\nNdiv = target / source;\r\n} else\r\npll_div->div2 = 0;\r\nif ((Ndiv < 6) || (Ndiv > 12))\r\nprintk(KERN_WARNING\r\n"WM8991 N value outwith recommended range! N = %d\n", Ndiv);\r\npll_div->n = Ndiv;\r\nNmod = target % source;\r\nKpart = FIXED_PLL_SIZE * (long long)Nmod;\r\ndo_div(Kpart, source);\r\nK = Kpart & 0xFFFFFFFF;\r\nif ((K % 10) >= 5)\r\nK += 5;\r\nK /= 10;\r\npll_div->k = K;\r\n}\r\nstatic int wm8991_set_dai_pll(struct snd_soc_dai *codec_dai,\r\nint pll_id, int src, unsigned int freq_in, unsigned int freq_out)\r\n{\r\nu16 reg;\r\nstruct snd_soc_codec *codec = codec_dai->codec;\r\nstruct _pll_div pll_div;\r\nif (freq_in && freq_out) {\r\npll_factors(&pll_div, freq_out * 4, freq_in);\r\nreg = snd_soc_read(codec, WM8991_POWER_MANAGEMENT_2);\r\nreg |= WM8991_PLL_ENA;\r\nsnd_soc_write(codec, WM8991_POWER_MANAGEMENT_2, reg);\r\nreg = snd_soc_read(codec, WM8991_CLOCKING_2);\r\nsnd_soc_write(codec, WM8991_CLOCKING_2, reg | WM8991_SYSCLK_SRC);\r\nsnd_soc_write(codec, WM8991_PLL1, pll_div.n | WM8991_SDM |\r\n(pll_div.div2 ? WM8991_PRESCALE : 0));\r\nsnd_soc_write(codec, WM8991_PLL2, (u8)(pll_div.k>>8));\r\nsnd_soc_write(codec, WM8991_PLL3, (u8)(pll_div.k & 0xFF));\r\n} else {\r\nreg = snd_soc_read(codec, WM8991_POWER_MANAGEMENT_2);\r\nreg &= ~WM8991_PLL_ENA;\r\nsnd_soc_write(codec, WM8991_POWER_MANAGEMENT_2, reg);\r\n}\r\nreturn 0;\r\n}\r\nstatic int wm8991_set_dai_fmt(struct snd_soc_dai *codec_dai,\r\nunsigned int fmt)\r\n{\r\nstruct snd_soc_codec *codec = codec_dai->codec;\r\nu16 audio1, audio3;\r\naudio1 = snd_soc_read(codec, WM8991_AUDIO_INTERFACE_1);\r\naudio3 = snd_soc_read(codec, WM8991_AUDIO_INTERFACE_3);\r\nswitch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {\r\ncase SND_SOC_DAIFMT_CBS_CFS:\r\naudio3 &= ~WM8991_AIF_MSTR1;\r\nbreak;\r\ncase SND_SOC_DAIFMT_CBM_CFM:\r\naudio3 |= WM8991_AIF_MSTR1;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\naudio1 &= ~WM8991_AIF_FMT_MASK;\r\nswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\r\ncase SND_SOC_DAIFMT_I2S:\r\naudio1 |= WM8991_AIF_TMF_I2S;\r\naudio1 &= ~WM8991_AIF_LRCLK_INV;\r\nbreak;\r\ncase SND_SOC_DAIFMT_RIGHT_J:\r\naudio1 |= WM8991_AIF_TMF_RIGHTJ;\r\naudio1 &= ~WM8991_AIF_LRCLK_INV;\r\nbreak;\r\ncase SND_SOC_DAIFMT_LEFT_J:\r\naudio1 |= WM8991_AIF_TMF_LEFTJ;\r\naudio1 &= ~WM8991_AIF_LRCLK_INV;\r\nbreak;\r\ncase SND_SOC_DAIFMT_DSP_A:\r\naudio1 |= WM8991_AIF_TMF_DSP;\r\naudio1 &= ~WM8991_AIF_LRCLK_INV;\r\nbreak;\r\ncase SND_SOC_DAIFMT_DSP_B:\r\naudio1 |= WM8991_AIF_TMF_DSP | WM8991_AIF_LRCLK_INV;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nsnd_soc_write(codec, WM8991_AUDIO_INTERFACE_1, audio1);\r\nsnd_soc_write(codec, WM8991_AUDIO_INTERFACE_3, audio3);\r\nreturn 0;\r\n}\r\nstatic int wm8991_set_dai_clkdiv(struct snd_soc_dai *codec_dai,\r\nint div_id, int div)\r\n{\r\nstruct snd_soc_codec *codec = codec_dai->codec;\r\nu16 reg;\r\nswitch (div_id) {\r\ncase WM8991_MCLK_DIV:\r\nreg = snd_soc_read(codec, WM8991_CLOCKING_2) &\r\n~WM8991_MCLK_DIV_MASK;\r\nsnd_soc_write(codec, WM8991_CLOCKING_2, reg | div);\r\nbreak;\r\ncase WM8991_DACCLK_DIV:\r\nreg = snd_soc_read(codec, WM8991_CLOCKING_2) &\r\n~WM8991_DAC_CLKDIV_MASK;\r\nsnd_soc_write(codec, WM8991_CLOCKING_2, reg | div);\r\nbreak;\r\ncase WM8991_ADCCLK_DIV:\r\nreg = snd_soc_read(codec, WM8991_CLOCKING_2) &\r\n~WM8991_ADC_CLKDIV_MASK;\r\nsnd_soc_write(codec, WM8991_CLOCKING_2, reg | div);\r\nbreak;\r\ncase WM8991_BCLK_DIV:\r\nreg = snd_soc_read(codec, WM8991_CLOCKING_1) &\r\n~WM8991_BCLK_DIV_MASK;\r\nsnd_soc_write(codec, WM8991_CLOCKING_1, reg | div);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int wm8991_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nu16 audio1 = snd_soc_read(codec, WM8991_AUDIO_INTERFACE_1);\r\naudio1 &= ~WM8991_AIF_WL_MASK;\r\nswitch (params_format(params)) {\r\ncase SNDRV_PCM_FORMAT_S16_LE:\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S20_3LE:\r\naudio1 |= WM8991_AIF_WL_20BITS;\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S24_LE:\r\naudio1 |= WM8991_AIF_WL_24BITS;\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S32_LE:\r\naudio1 |= WM8991_AIF_WL_32BITS;\r\nbreak;\r\n}\r\nsnd_soc_write(codec, WM8991_AUDIO_INTERFACE_1, audio1);\r\nreturn 0;\r\n}\r\nstatic int wm8991_mute(struct snd_soc_dai *dai, int mute)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nu16 val;\r\nval = snd_soc_read(codec, WM8991_DAC_CTRL) & ~WM8991_DAC_MUTE;\r\nif (mute)\r\nsnd_soc_write(codec, WM8991_DAC_CTRL, val | WM8991_DAC_MUTE);\r\nelse\r\nsnd_soc_write(codec, WM8991_DAC_CTRL, val);\r\nreturn 0;\r\n}\r\nstatic int wm8991_set_bias_level(struct snd_soc_codec *codec,\r\nenum snd_soc_bias_level level)\r\n{\r\nu16 val;\r\nswitch (level) {\r\ncase SND_SOC_BIAS_ON:\r\nbreak;\r\ncase SND_SOC_BIAS_PREPARE:\r\nval = snd_soc_read(codec, WM8991_POWER_MANAGEMENT_1) &\r\n~WM8991_VMID_MODE_MASK;\r\nsnd_soc_write(codec, WM8991_POWER_MANAGEMENT_1, val | 0x2);\r\nbreak;\r\ncase SND_SOC_BIAS_STANDBY:\r\nif (codec->dapm.bias_level == SND_SOC_BIAS_OFF) {\r\nsnd_soc_cache_sync(codec);\r\nsnd_soc_write(codec, WM8991_ANTIPOP1, WM8991_DIS_LLINE |\r\nWM8991_DIS_RLINE | WM8991_DIS_OUT3 |\r\nWM8991_DIS_OUT4 | WM8991_DIS_LOUT |\r\nWM8991_DIS_ROUT);\r\nsnd_soc_write(codec, WM8991_ANTIPOP2, WM8991_SOFTST |\r\nWM8991_BUFDCOPEN | WM8991_POBCTRL |\r\nWM8991_VMIDTOG);\r\nmsleep(300);\r\nsnd_soc_write(codec, WM8991_ANTIPOP2, WM8991_SOFTST |\r\nWM8991_BUFDCOPEN | WM8991_POBCTRL);\r\nsnd_soc_write(codec, WM8991_ANTIPOP1, 0);\r\nsnd_soc_write(codec, WM8991_POWER_MANAGEMENT_1, 0x1b00);\r\nmsleep(50);\r\nsnd_soc_write(codec, WM8991_POWER_MANAGEMENT_1, 0x1f02);\r\nmsleep(100);\r\nsnd_soc_write(codec, WM8991_POWER_MANAGEMENT_1, 0x1f03);\r\nmsleep(600);\r\nsnd_soc_write(codec, WM8991_ANTIPOP2, WM8991_SOFTST |\r\nWM8991_BUFDCOPEN | WM8991_POBCTRL |\r\nWM8991_BUFIOEN);\r\nsnd_soc_write(codec, WM8991_POWER_MANAGEMENT_1, 0x3);\r\nsnd_soc_write(codec, WM8991_ANTIPOP2, WM8991_BUFIOEN);\r\n}\r\nval = snd_soc_read(codec, WM8991_POWER_MANAGEMENT_1) &\r\n~WM8991_VMID_MODE_MASK;\r\nsnd_soc_write(codec, WM8991_POWER_MANAGEMENT_1, val | 0x4);\r\nbreak;\r\ncase SND_SOC_BIAS_OFF:\r\nsnd_soc_write(codec, WM8991_ANTIPOP2, WM8991_SOFTST |\r\nWM8991_POBCTRL | WM8991_BUFIOEN);\r\nsnd_soc_write(codec, WM8991_ANTIPOP2, WM8991_SOFTST |\r\nWM8991_BUFDCOPEN | WM8991_POBCTRL |\r\nWM8991_BUFIOEN);\r\nval = snd_soc_read(codec, WM8991_DAC_CTRL);\r\nsnd_soc_write(codec, WM8991_DAC_CTRL, val | WM8991_DAC_MUTE);\r\nsnd_soc_write(codec, WM8991_POWER_MANAGEMENT_1, 0x1f03);\r\nsnd_soc_write(codec, WM8991_POWER_MANAGEMENT_1, 0x1f01);\r\nmsleep(300);\r\nsnd_soc_write(codec, WM8991_ANTIPOP1, WM8991_DIS_LLINE |\r\nWM8991_DIS_RLINE | WM8991_DIS_OUT3 |\r\nWM8991_DIS_OUT4 | WM8991_DIS_LOUT |\r\nWM8991_DIS_ROUT);\r\nsnd_soc_write(codec, WM8991_POWER_MANAGEMENT_1, 0x0);\r\nsnd_soc_write(codec, WM8991_ANTIPOP2, 0x0);\r\ncodec->cache_sync = 1;\r\nbreak;\r\n}\r\ncodec->dapm.bias_level = level;\r\nreturn 0;\r\n}\r\nstatic int wm8991_suspend(struct snd_soc_codec *codec)\r\n{\r\nwm8991_set_bias_level(codec, SND_SOC_BIAS_OFF);\r\nreturn 0;\r\n}\r\nstatic int wm8991_resume(struct snd_soc_codec *codec)\r\n{\r\nwm8991_set_bias_level(codec, SND_SOC_BIAS_STANDBY);\r\nreturn 0;\r\n}\r\nstatic int wm8991_remove(struct snd_soc_codec *codec)\r\n{\r\nwm8991_set_bias_level(codec, SND_SOC_BIAS_OFF);\r\nreturn 0;\r\n}\r\nstatic int wm8991_probe(struct snd_soc_codec *codec)\r\n{\r\nstruct wm8991_priv *wm8991;\r\nint ret;\r\nwm8991 = snd_soc_codec_get_drvdata(codec);\r\nret = snd_soc_codec_set_cache_io(codec, 8, 16, wm8991->control_type);\r\nif (ret < 0) {\r\ndev_err(codec->dev, "Failed to set cache i/o: %d\n", ret);\r\nreturn ret;\r\n}\r\nret = wm8991_reset(codec);\r\nif (ret < 0) {\r\ndev_err(codec->dev, "Failed to issue reset\n");\r\nreturn ret;\r\n}\r\nwm8991_set_bias_level(codec, SND_SOC_BIAS_STANDBY);\r\nsnd_soc_update_bits(codec, WM8991_AUDIO_INTERFACE_4,\r\nWM8991_ALRCGPIO1, WM8991_ALRCGPIO1);\r\nsnd_soc_update_bits(codec, WM8991_GPIO1_GPIO2,\r\nWM8991_GPIO1_SEL_MASK, 1);\r\nsnd_soc_update_bits(codec, WM8991_POWER_MANAGEMENT_1,\r\nWM8991_VREF_ENA | WM8991_VMID_MODE_MASK,\r\nWM8991_VREF_ENA | WM8991_VMID_MODE_MASK);\r\nsnd_soc_update_bits(codec, WM8991_POWER_MANAGEMENT_2,\r\nWM8991_OPCLK_ENA, WM8991_OPCLK_ENA);\r\nsnd_soc_write(codec, WM8991_DAC_CTRL, 0);\r\nsnd_soc_write(codec, WM8991_LEFT_OUTPUT_VOLUME, 0x50 | (1<<8));\r\nsnd_soc_write(codec, WM8991_RIGHT_OUTPUT_VOLUME, 0x50 | (1<<8));\r\nsnd_soc_add_codec_controls(codec, wm8991_snd_controls,\r\nARRAY_SIZE(wm8991_snd_controls));\r\nsnd_soc_dapm_new_controls(&codec->dapm, wm8991_dapm_widgets,\r\nARRAY_SIZE(wm8991_dapm_widgets));\r\nsnd_soc_dapm_add_routes(&codec->dapm, audio_map,\r\nARRAY_SIZE(audio_map));\r\nreturn 0;\r\n}\r\nstatic int wm8991_i2c_probe(struct i2c_client *i2c,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct wm8991_priv *wm8991;\r\nint ret;\r\nwm8991 = devm_kzalloc(&i2c->dev, sizeof(*wm8991), GFP_KERNEL);\r\nif (!wm8991)\r\nreturn -ENOMEM;\r\nwm8991->control_type = SND_SOC_I2C;\r\ni2c_set_clientdata(i2c, wm8991);\r\nret = snd_soc_register_codec(&i2c->dev,\r\n&soc_codec_dev_wm8991, &wm8991_dai, 1);\r\nreturn ret;\r\n}\r\nstatic int wm8991_i2c_remove(struct i2c_client *client)\r\n{\r\nsnd_soc_unregister_codec(&client->dev);\r\nreturn 0;\r\n}
