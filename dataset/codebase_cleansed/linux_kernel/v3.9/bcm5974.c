static const struct bcm5974_config *bcm5974_get_config(struct usb_device *udev)\r\n{\r\nu16 id = le16_to_cpu(udev->descriptor.idProduct);\r\nconst struct bcm5974_config *cfg;\r\nfor (cfg = bcm5974_config_table; cfg->ansi; ++cfg)\r\nif (cfg->ansi == id || cfg->iso == id || cfg->jis == id)\r\nreturn cfg;\r\nreturn bcm5974_config_table;\r\n}\r\nstatic inline int raw2int(__le16 x)\r\n{\r\nreturn (signed short)le16_to_cpu(x);\r\n}\r\nstatic void set_abs(struct input_dev *input, unsigned int code,\r\nconst struct bcm5974_param *p)\r\n{\r\nint fuzz = p->snratio ? (p->max - p->min) / p->snratio : 0;\r\ninput_set_abs_params(input, code, p->min, p->max, fuzz, 0);\r\n}\r\nstatic void setup_events_to_report(struct input_dev *input_dev,\r\nconst struct bcm5974_config *cfg)\r\n{\r\n__set_bit(EV_ABS, input_dev->evbit);\r\ninput_set_abs_params(input_dev, ABS_PRESSURE, 0, 256, 5, 0);\r\ninput_set_abs_params(input_dev, ABS_TOOL_WIDTH, 0, 16, 0, 0);\r\nset_abs(input_dev, ABS_MT_TOUCH_MAJOR, &cfg->w);\r\nset_abs(input_dev, ABS_MT_TOUCH_MINOR, &cfg->w);\r\nset_abs(input_dev, ABS_MT_WIDTH_MAJOR, &cfg->w);\r\nset_abs(input_dev, ABS_MT_WIDTH_MINOR, &cfg->w);\r\nset_abs(input_dev, ABS_MT_ORIENTATION, &cfg->o);\r\nset_abs(input_dev, ABS_MT_POSITION_X, &cfg->x);\r\nset_abs(input_dev, ABS_MT_POSITION_Y, &cfg->y);\r\n__set_bit(EV_KEY, input_dev->evbit);\r\n__set_bit(BTN_LEFT, input_dev->keybit);\r\nif (cfg->caps & HAS_INTEGRATED_BUTTON)\r\n__set_bit(INPUT_PROP_BUTTONPAD, input_dev->propbit);\r\ninput_mt_init_slots(input_dev, MAX_FINGERS,\r\nINPUT_MT_POINTER | INPUT_MT_DROP_UNUSED | INPUT_MT_TRACK);\r\n}\r\nstatic int report_bt_state(struct bcm5974 *dev, int size)\r\n{\r\nif (size != sizeof(struct bt_data))\r\nreturn -EIO;\r\ndprintk(7,\r\n"bcm5974: button data: %x %x %x %x\n",\r\ndev->bt_data->unknown1, dev->bt_data->button,\r\ndev->bt_data->rel_x, dev->bt_data->rel_y);\r\ninput_report_key(dev->input, BTN_LEFT, dev->bt_data->button);\r\ninput_sync(dev->input);\r\nreturn 0;\r\n}\r\nstatic void report_finger_data(struct input_dev *input, int slot,\r\nconst struct input_mt_pos *pos,\r\nconst struct tp_finger *f)\r\n{\r\ninput_mt_slot(input, slot);\r\ninput_mt_report_slot_state(input, MT_TOOL_FINGER, true);\r\ninput_report_abs(input, ABS_MT_TOUCH_MAJOR,\r\nraw2int(f->touch_major) << 1);\r\ninput_report_abs(input, ABS_MT_TOUCH_MINOR,\r\nraw2int(f->touch_minor) << 1);\r\ninput_report_abs(input, ABS_MT_WIDTH_MAJOR,\r\nraw2int(f->tool_major) << 1);\r\ninput_report_abs(input, ABS_MT_WIDTH_MINOR,\r\nraw2int(f->tool_minor) << 1);\r\ninput_report_abs(input, ABS_MT_ORIENTATION,\r\nMAX_FINGER_ORIENTATION - raw2int(f->orientation));\r\ninput_report_abs(input, ABS_MT_POSITION_X, pos->x);\r\ninput_report_abs(input, ABS_MT_POSITION_Y, pos->y);\r\n}\r\nstatic void report_synaptics_data(struct input_dev *input,\r\nconst struct bcm5974_config *cfg,\r\nconst struct tp_finger *f, int raw_n)\r\n{\r\nint abs_p = 0, abs_w = 0;\r\nif (raw_n) {\r\nint p = raw2int(f->touch_major);\r\nint w = raw2int(f->tool_major);\r\nif (p > 0 && raw2int(f->origin)) {\r\nabs_p = clamp_val(256 * p / cfg->p.max, 0, 255);\r\nabs_w = clamp_val(16 * w / cfg->w.max, 0, 15);\r\n}\r\n}\r\ninput_report_abs(input, ABS_PRESSURE, abs_p);\r\ninput_report_abs(input, ABS_TOOL_WIDTH, abs_w);\r\n}\r\nstatic int report_tp_state(struct bcm5974 *dev, int size)\r\n{\r\nconst struct bcm5974_config *c = &dev->cfg;\r\nconst struct tp_finger *f;\r\nstruct input_dev *input = dev->input;\r\nint raw_n, i, n = 0;\r\nif (size < c->tp_offset || (size - c->tp_offset) % SIZEOF_FINGER != 0)\r\nreturn -EIO;\r\nf = (const struct tp_finger *)(dev->tp_data + c->tp_offset);\r\nraw_n = (size - c->tp_offset) / SIZEOF_FINGER;\r\nfor (i = 0; i < raw_n; i++) {\r\nif (raw2int(f[i].touch_major) == 0)\r\ncontinue;\r\ndev->pos[n].x = raw2int(f[i].abs_x);\r\ndev->pos[n].y = c->y.min + c->y.max - raw2int(f[i].abs_y);\r\ndev->index[n++] = &f[i];\r\n}\r\ninput_mt_assign_slots(input, dev->slots, dev->pos, n);\r\nfor (i = 0; i < n; i++)\r\nreport_finger_data(input, dev->slots[i],\r\n&dev->pos[i], dev->index[i]);\r\ninput_mt_sync_frame(input);\r\nreport_synaptics_data(input, c, f, raw_n);\r\nif (c->tp_type == TYPE2) {\r\nint ibt = raw2int(dev->tp_data[BUTTON_TYPE2]);\r\ninput_report_key(input, BTN_LEFT, ibt);\r\n}\r\ninput_sync(input);\r\nreturn 0;\r\n}\r\nstatic int bcm5974_wellspring_mode(struct bcm5974 *dev, bool on)\r\n{\r\nchar *data = kmalloc(8, GFP_KERNEL);\r\nint retval = 0, size;\r\nif (!data) {\r\ndev_err(&dev->intf->dev, "out of memory\n");\r\nretval = -ENOMEM;\r\ngoto out;\r\n}\r\nsize = usb_control_msg(dev->udev, usb_rcvctrlpipe(dev->udev, 0),\r\nBCM5974_WELLSPRING_MODE_READ_REQUEST_ID,\r\nUSB_DIR_IN | USB_TYPE_CLASS | USB_RECIP_INTERFACE,\r\nBCM5974_WELLSPRING_MODE_REQUEST_VALUE,\r\nBCM5974_WELLSPRING_MODE_REQUEST_INDEX, data, 8, 5000);\r\nif (size != 8) {\r\ndev_err(&dev->intf->dev, "could not read from device\n");\r\nretval = -EIO;\r\ngoto out;\r\n}\r\ndata[0] = on ?\r\nBCM5974_WELLSPRING_MODE_VENDOR_VALUE :\r\nBCM5974_WELLSPRING_MODE_NORMAL_VALUE;\r\nsize = usb_control_msg(dev->udev, usb_sndctrlpipe(dev->udev, 0),\r\nBCM5974_WELLSPRING_MODE_WRITE_REQUEST_ID,\r\nUSB_DIR_OUT | USB_TYPE_CLASS | USB_RECIP_INTERFACE,\r\nBCM5974_WELLSPRING_MODE_REQUEST_VALUE,\r\nBCM5974_WELLSPRING_MODE_REQUEST_INDEX, data, 8, 5000);\r\nif (size != 8) {\r\ndev_err(&dev->intf->dev, "could not write to device\n");\r\nretval = -EIO;\r\ngoto out;\r\n}\r\ndprintk(2, "bcm5974: switched to %s mode.\n",\r\non ? "wellspring" : "normal");\r\nout:\r\nkfree(data);\r\nreturn retval;\r\n}\r\nstatic void bcm5974_irq_button(struct urb *urb)\r\n{\r\nstruct bcm5974 *dev = urb->context;\r\nstruct usb_interface *intf = dev->intf;\r\nint error;\r\nswitch (urb->status) {\r\ncase 0:\r\nbreak;\r\ncase -EOVERFLOW:\r\ncase -ECONNRESET:\r\ncase -ENOENT:\r\ncase -ESHUTDOWN:\r\ndev_dbg(&intf->dev, "button urb shutting down: %d\n",\r\nurb->status);\r\nreturn;\r\ndefault:\r\ndev_dbg(&intf->dev, "button urb status: %d\n", urb->status);\r\ngoto exit;\r\n}\r\nif (report_bt_state(dev, dev->bt_urb->actual_length))\r\ndprintk(1, "bcm5974: bad button package, length: %d\n",\r\ndev->bt_urb->actual_length);\r\nexit:\r\nerror = usb_submit_urb(dev->bt_urb, GFP_ATOMIC);\r\nif (error)\r\ndev_err(&intf->dev, "button urb failed: %d\n", error);\r\n}\r\nstatic void bcm5974_irq_trackpad(struct urb *urb)\r\n{\r\nstruct bcm5974 *dev = urb->context;\r\nstruct usb_interface *intf = dev->intf;\r\nint error;\r\nswitch (urb->status) {\r\ncase 0:\r\nbreak;\r\ncase -EOVERFLOW:\r\ncase -ECONNRESET:\r\ncase -ENOENT:\r\ncase -ESHUTDOWN:\r\ndev_dbg(&intf->dev, "trackpad urb shutting down: %d\n",\r\nurb->status);\r\nreturn;\r\ndefault:\r\ndev_dbg(&intf->dev, "trackpad urb status: %d\n", urb->status);\r\ngoto exit;\r\n}\r\nif (dev->tp_urb->actual_length == 2)\r\ngoto exit;\r\nif (report_tp_state(dev, dev->tp_urb->actual_length))\r\ndprintk(1, "bcm5974: bad trackpad package, length: %d\n",\r\ndev->tp_urb->actual_length);\r\nexit:\r\nerror = usb_submit_urb(dev->tp_urb, GFP_ATOMIC);\r\nif (error)\r\ndev_err(&intf->dev, "trackpad urb failed: %d\n", error);\r\n}\r\nstatic int bcm5974_start_traffic(struct bcm5974 *dev)\r\n{\r\nint error;\r\nerror = bcm5974_wellspring_mode(dev, true);\r\nif (error) {\r\ndprintk(1, "bcm5974: mode switch failed\n");\r\ngoto err_out;\r\n}\r\nif (dev->bt_urb) {\r\nerror = usb_submit_urb(dev->bt_urb, GFP_KERNEL);\r\nif (error)\r\ngoto err_reset_mode;\r\n}\r\nerror = usb_submit_urb(dev->tp_urb, GFP_KERNEL);\r\nif (error)\r\ngoto err_kill_bt;\r\nreturn 0;\r\nerr_kill_bt:\r\nusb_kill_urb(dev->bt_urb);\r\nerr_reset_mode:\r\nbcm5974_wellspring_mode(dev, false);\r\nerr_out:\r\nreturn error;\r\n}\r\nstatic void bcm5974_pause_traffic(struct bcm5974 *dev)\r\n{\r\nusb_kill_urb(dev->tp_urb);\r\nusb_kill_urb(dev->bt_urb);\r\nbcm5974_wellspring_mode(dev, false);\r\n}\r\nstatic int bcm5974_open(struct input_dev *input)\r\n{\r\nstruct bcm5974 *dev = input_get_drvdata(input);\r\nint error;\r\nerror = usb_autopm_get_interface(dev->intf);\r\nif (error)\r\nreturn error;\r\nmutex_lock(&dev->pm_mutex);\r\nerror = bcm5974_start_traffic(dev);\r\nif (!error)\r\ndev->opened = 1;\r\nmutex_unlock(&dev->pm_mutex);\r\nif (error)\r\nusb_autopm_put_interface(dev->intf);\r\nreturn error;\r\n}\r\nstatic void bcm5974_close(struct input_dev *input)\r\n{\r\nstruct bcm5974 *dev = input_get_drvdata(input);\r\nmutex_lock(&dev->pm_mutex);\r\nbcm5974_pause_traffic(dev);\r\ndev->opened = 0;\r\nmutex_unlock(&dev->pm_mutex);\r\nusb_autopm_put_interface(dev->intf);\r\n}\r\nstatic int bcm5974_suspend(struct usb_interface *iface, pm_message_t message)\r\n{\r\nstruct bcm5974 *dev = usb_get_intfdata(iface);\r\nmutex_lock(&dev->pm_mutex);\r\nif (dev->opened)\r\nbcm5974_pause_traffic(dev);\r\nmutex_unlock(&dev->pm_mutex);\r\nreturn 0;\r\n}\r\nstatic int bcm5974_resume(struct usb_interface *iface)\r\n{\r\nstruct bcm5974 *dev = usb_get_intfdata(iface);\r\nint error = 0;\r\nmutex_lock(&dev->pm_mutex);\r\nif (dev->opened)\r\nerror = bcm5974_start_traffic(dev);\r\nmutex_unlock(&dev->pm_mutex);\r\nreturn error;\r\n}\r\nstatic int bcm5974_probe(struct usb_interface *iface,\r\nconst struct usb_device_id *id)\r\n{\r\nstruct usb_device *udev = interface_to_usbdev(iface);\r\nconst struct bcm5974_config *cfg;\r\nstruct bcm5974 *dev;\r\nstruct input_dev *input_dev;\r\nint error = -ENOMEM;\r\ncfg = bcm5974_get_config(udev);\r\ndev = kzalloc(sizeof(struct bcm5974), GFP_KERNEL);\r\ninput_dev = input_allocate_device();\r\nif (!dev || !input_dev) {\r\ndev_err(&iface->dev, "out of memory\n");\r\ngoto err_free_devs;\r\n}\r\ndev->udev = udev;\r\ndev->intf = iface;\r\ndev->input = input_dev;\r\ndev->cfg = *cfg;\r\nmutex_init(&dev->pm_mutex);\r\nif (cfg->tp_type == TYPE1) {\r\ndev->bt_urb = usb_alloc_urb(0, GFP_KERNEL);\r\nif (!dev->bt_urb)\r\ngoto err_free_devs;\r\n}\r\ndev->tp_urb = usb_alloc_urb(0, GFP_KERNEL);\r\nif (!dev->tp_urb)\r\ngoto err_free_bt_urb;\r\nif (dev->bt_urb) {\r\ndev->bt_data = usb_alloc_coherent(dev->udev,\r\ndev->cfg.bt_datalen, GFP_KERNEL,\r\n&dev->bt_urb->transfer_dma);\r\nif (!dev->bt_data)\r\ngoto err_free_urb;\r\n}\r\ndev->tp_data = usb_alloc_coherent(dev->udev,\r\ndev->cfg.tp_datalen, GFP_KERNEL,\r\n&dev->tp_urb->transfer_dma);\r\nif (!dev->tp_data)\r\ngoto err_free_bt_buffer;\r\nif (dev->bt_urb)\r\nusb_fill_int_urb(dev->bt_urb, udev,\r\nusb_rcvintpipe(udev, cfg->bt_ep),\r\ndev->bt_data, dev->cfg.bt_datalen,\r\nbcm5974_irq_button, dev, 1);\r\nusb_fill_int_urb(dev->tp_urb, udev,\r\nusb_rcvintpipe(udev, cfg->tp_ep),\r\ndev->tp_data, dev->cfg.tp_datalen,\r\nbcm5974_irq_trackpad, dev, 1);\r\nusb_make_path(udev, dev->phys, sizeof(dev->phys));\r\nstrlcat(dev->phys, "/input0", sizeof(dev->phys));\r\ninput_dev->name = "bcm5974";\r\ninput_dev->phys = dev->phys;\r\nusb_to_input_id(dev->udev, &input_dev->id);\r\ninput_dev->id.version = cfg->caps;\r\ninput_dev->dev.parent = &iface->dev;\r\ninput_set_drvdata(input_dev, dev);\r\ninput_dev->open = bcm5974_open;\r\ninput_dev->close = bcm5974_close;\r\nsetup_events_to_report(input_dev, cfg);\r\nerror = input_register_device(dev->input);\r\nif (error)\r\ngoto err_free_buffer;\r\nusb_set_intfdata(iface, dev);\r\nreturn 0;\r\nerr_free_buffer:\r\nusb_free_coherent(dev->udev, dev->cfg.tp_datalen,\r\ndev->tp_data, dev->tp_urb->transfer_dma);\r\nerr_free_bt_buffer:\r\nif (dev->bt_urb)\r\nusb_free_coherent(dev->udev, dev->cfg.bt_datalen,\r\ndev->bt_data, dev->bt_urb->transfer_dma);\r\nerr_free_urb:\r\nusb_free_urb(dev->tp_urb);\r\nerr_free_bt_urb:\r\nusb_free_urb(dev->bt_urb);\r\nerr_free_devs:\r\nusb_set_intfdata(iface, NULL);\r\ninput_free_device(input_dev);\r\nkfree(dev);\r\nreturn error;\r\n}\r\nstatic void bcm5974_disconnect(struct usb_interface *iface)\r\n{\r\nstruct bcm5974 *dev = usb_get_intfdata(iface);\r\nusb_set_intfdata(iface, NULL);\r\ninput_unregister_device(dev->input);\r\nusb_free_coherent(dev->udev, dev->cfg.tp_datalen,\r\ndev->tp_data, dev->tp_urb->transfer_dma);\r\nif (dev->bt_urb)\r\nusb_free_coherent(dev->udev, dev->cfg.bt_datalen,\r\ndev->bt_data, dev->bt_urb->transfer_dma);\r\nusb_free_urb(dev->tp_urb);\r\nusb_free_urb(dev->bt_urb);\r\nkfree(dev);\r\n}
