static int ir_sony_decode(struct rc_dev *dev, struct ir_raw_event ev)\r\n{\r\nstruct sony_dec *data = &dev->raw->sony;\r\nu32 scancode;\r\nu8 device, subdevice, function;\r\nif (!(dev->raw->enabled_protocols &\r\n(RC_BIT_SONY12 | RC_BIT_SONY15 | RC_BIT_SONY20)))\r\nreturn 0;\r\nif (!is_timing_event(ev)) {\r\nif (ev.reset)\r\ndata->state = STATE_INACTIVE;\r\nreturn 0;\r\n}\r\nif (!geq_margin(ev.duration, SONY_UNIT, SONY_UNIT / 2))\r\ngoto out;\r\nIR_dprintk(2, "Sony decode started at state %d (%uus %s)\n",\r\ndata->state, TO_US(ev.duration), TO_STR(ev.pulse));\r\nswitch (data->state) {\r\ncase STATE_INACTIVE:\r\nif (!ev.pulse)\r\nbreak;\r\nif (!eq_margin(ev.duration, SONY_HEADER_PULSE, SONY_UNIT / 2))\r\nbreak;\r\ndata->count = 0;\r\ndata->state = STATE_HEADER_SPACE;\r\nreturn 0;\r\ncase STATE_HEADER_SPACE:\r\nif (ev.pulse)\r\nbreak;\r\nif (!eq_margin(ev.duration, SONY_HEADER_SPACE, SONY_UNIT / 2))\r\nbreak;\r\ndata->state = STATE_BIT_PULSE;\r\nreturn 0;\r\ncase STATE_BIT_PULSE:\r\nif (!ev.pulse)\r\nbreak;\r\ndata->bits <<= 1;\r\nif (eq_margin(ev.duration, SONY_BIT_1_PULSE, SONY_UNIT / 2))\r\ndata->bits |= 1;\r\nelse if (!eq_margin(ev.duration, SONY_BIT_0_PULSE, SONY_UNIT / 2))\r\nbreak;\r\ndata->count++;\r\ndata->state = STATE_BIT_SPACE;\r\nreturn 0;\r\ncase STATE_BIT_SPACE:\r\nif (ev.pulse)\r\nbreak;\r\nif (!geq_margin(ev.duration, SONY_BIT_SPACE, SONY_UNIT / 2))\r\nbreak;\r\ndecrease_duration(&ev, SONY_BIT_SPACE);\r\nif (!geq_margin(ev.duration, SONY_UNIT, SONY_UNIT / 2)) {\r\ndata->state = STATE_BIT_PULSE;\r\nreturn 0;\r\n}\r\ndata->state = STATE_FINISHED;\r\ncase STATE_FINISHED:\r\nif (ev.pulse)\r\nbreak;\r\nif (!geq_margin(ev.duration, SONY_TRAILER_SPACE, SONY_UNIT / 2))\r\nbreak;\r\nswitch (data->count) {\r\ncase 12:\r\nif (!(dev->raw->enabled_protocols & RC_BIT_SONY12)) {\r\ndata->state = STATE_INACTIVE;\r\nreturn 0;\r\n}\r\ndevice = bitrev8((data->bits << 3) & 0xF8);\r\nsubdevice = 0;\r\nfunction = bitrev8((data->bits >> 4) & 0xFE);\r\nbreak;\r\ncase 15:\r\nif (!(dev->raw->enabled_protocols & RC_BIT_SONY15)) {\r\ndata->state = STATE_INACTIVE;\r\nreturn 0;\r\n}\r\ndevice = bitrev8((data->bits >> 0) & 0xFF);\r\nsubdevice = 0;\r\nfunction = bitrev8((data->bits >> 7) & 0xFE);\r\nbreak;\r\ncase 20:\r\nif (!(dev->raw->enabled_protocols & RC_BIT_SONY20)) {\r\ndata->state = STATE_INACTIVE;\r\nreturn 0;\r\n}\r\ndevice = bitrev8((data->bits >> 5) & 0xF8);\r\nsubdevice = bitrev8((data->bits >> 0) & 0xFF);\r\nfunction = bitrev8((data->bits >> 12) & 0xFE);\r\nbreak;\r\ndefault:\r\nIR_dprintk(1, "Sony invalid bitcount %u\n", data->count);\r\ngoto out;\r\n}\r\nscancode = device << 16 | subdevice << 8 | function;\r\nIR_dprintk(1, "Sony(%u) scancode 0x%05x\n", data->count, scancode);\r\nrc_keydown(dev, scancode, 0);\r\ndata->state = STATE_INACTIVE;\r\nreturn 0;\r\n}\r\nout:\r\nIR_dprintk(1, "Sony decode failed at state %d (%uus %s)\n",\r\ndata->state, TO_US(ev.duration), TO_STR(ev.pulse));\r\ndata->state = STATE_INACTIVE;\r\nreturn -EINVAL;\r\n}\r\nstatic int __init ir_sony_decode_init(void)\r\n{\r\nir_raw_handler_register(&sony_handler);\r\nprintk(KERN_INFO "IR Sony protocol handler initialized\n");\r\nreturn 0;\r\n}\r\nstatic void __exit ir_sony_decode_exit(void)\r\n{\r\nir_raw_handler_unregister(&sony_handler);\r\n}
