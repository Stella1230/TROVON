static u32 __cpuinit power2(u32 x)\r\n{\r\nu32 s = 1;\r\nwhile (s <= x)\r\ns <<= 1;\r\nreturn s >>= 1;\r\n}\r\nstatic void __cpuinit centaur_mcr_insert(int reg, u32 base, u32 size, int key)\r\n{\r\nu32 lo, hi;\r\nhi = base & ~0xFFF;\r\nlo = ~(size-1);\r\nlo &= ~0xFFF;\r\nlo |= key;\r\nwrmsr(reg+MSR_IDT_MCR0, lo, hi);\r\nmtrr_centaur_report_mcr(reg, lo, hi);\r\n}\r\nstatic u32 __cpuinit ramtop(void)\r\n{\r\nu32 clip = 0xFFFFFFFFUL;\r\nu32 top = 0;\r\nint i;\r\nfor (i = 0; i < e820.nr_map; i++) {\r\nunsigned long start, end;\r\nif (e820.map[i].addr > 0xFFFFFFFFUL)\r\ncontinue;\r\nif (e820.map[i].type == E820_RESERVED) {\r\nif (e820.map[i].addr >= 0x100000UL &&\r\ne820.map[i].addr < clip)\r\nclip = e820.map[i].addr;\r\ncontinue;\r\n}\r\nstart = e820.map[i].addr;\r\nend = e820.map[i].addr + e820.map[i].size;\r\nif (start >= end)\r\ncontinue;\r\nif (end > top)\r\ntop = end;\r\n}\r\nif (top > clip)\r\ntop = clip;\r\nreturn top;\r\n}\r\nstatic int __cpuinit centaur_mcr_compute(int nr, int key)\r\n{\r\nu32 mem = ramtop();\r\nu32 root = power2(mem);\r\nu32 base = root;\r\nu32 top = root;\r\nu32 floor = 0;\r\nint ct = 0;\r\nwhile (ct < nr) {\r\nu32 fspace = 0;\r\nu32 high;\r\nu32 low;\r\nhigh = power2(mem-top);\r\nlow = base/2;\r\nif (base <= 1024*1024)\r\nlow = 0;\r\nif (floor == 0)\r\nfspace = 512*1024;\r\nelse if (floor == 512*1024)\r\nfspace = 128*1024;\r\nif (fspace > high && fspace > low) {\r\ncentaur_mcr_insert(ct, floor, fspace, key);\r\nfloor += fspace;\r\n} else if (high > low) {\r\ncentaur_mcr_insert(ct, top, high, key);\r\ntop += high;\r\n} else if (low > 0) {\r\nbase -= low;\r\ncentaur_mcr_insert(ct, base, low, key);\r\n} else\r\nbreak;\r\nct++;\r\n}\r\nreturn ct;\r\n}\r\nstatic void __cpuinit centaur_create_optimal_mcr(void)\r\n{\r\nint used;\r\nint i;\r\nused = centaur_mcr_compute(6, 31);\r\nfor (i = used; i < 8; i++)\r\nwrmsr(MSR_IDT_MCR0+i, 0, 0);\r\n}\r\nstatic void __cpuinit winchip2_create_optimal_mcr(void)\r\n{\r\nu32 lo, hi;\r\nint used;\r\nint i;\r\nused = centaur_mcr_compute(6, 25);\r\nrdmsr(MSR_IDT_MCR_CTRL, lo, hi);\r\nfor (i = 0; i < used; i++)\r\nlo |= 1<<(9+i);\r\nwrmsr(MSR_IDT_MCR_CTRL, lo, hi);\r\nfor (i = used; i < 8; i++)\r\nwrmsr(MSR_IDT_MCR0+i, 0, 0);\r\n}\r\nstatic void __cpuinit winchip2_unprotect_mcr(void)\r\n{\r\nu32 lo, hi;\r\nu32 key;\r\nrdmsr(MSR_IDT_MCR_CTRL, lo, hi);\r\nlo &= ~0x1C0;\r\nkey = (lo>>17) & 7;\r\nlo |= key<<6;\r\nwrmsr(MSR_IDT_MCR_CTRL, lo, hi);\r\n}\r\nstatic void __cpuinit winchip2_protect_mcr(void)\r\n{\r\nu32 lo, hi;\r\nrdmsr(MSR_IDT_MCR_CTRL, lo, hi);\r\nlo &= ~0x1C0;\r\nwrmsr(MSR_IDT_MCR_CTRL, lo, hi);\r\n}\r\nstatic void __cpuinit init_c3(struct cpuinfo_x86 *c)\r\n{\r\nu32 lo, hi;\r\nif (cpuid_eax(0xC0000000) >= 0xC0000001) {\r\nu32 tmp = cpuid_edx(0xC0000001);\r\nif ((tmp & (ACE_PRESENT | ACE_ENABLED)) == ACE_PRESENT) {\r\nrdmsr(MSR_VIA_FCR, lo, hi);\r\nlo |= ACE_FCR;\r\nwrmsr(MSR_VIA_FCR, lo, hi);\r\nprintk(KERN_INFO "CPU: Enabled ACE h/w crypto\n");\r\n}\r\nif ((tmp & (RNG_PRESENT | RNG_ENABLED)) == RNG_PRESENT) {\r\nrdmsr(MSR_VIA_RNG, lo, hi);\r\nlo |= RNG_ENABLE;\r\nwrmsr(MSR_VIA_RNG, lo, hi);\r\nprintk(KERN_INFO "CPU: Enabled h/w RNG\n");\r\n}\r\nc->x86_capability[5] = cpuid_edx(0xC0000001);\r\n}\r\n#ifdef CONFIG_X86_32\r\nif (c->x86_model >= 6 && c->x86_model <= 13) {\r\nrdmsr(MSR_VIA_FCR, lo, hi);\r\nlo |= (1<<1 | 1<<7);\r\nwrmsr(MSR_VIA_FCR, lo, hi);\r\nset_cpu_cap(c, X86_FEATURE_CX8);\r\n}\r\nif (c->x86_model >= 6 && c->x86_model < 9)\r\nset_cpu_cap(c, X86_FEATURE_3DNOW);\r\n#endif\r\nif (c->x86 == 0x6 && c->x86_model >= 0xf) {\r\nc->x86_cache_alignment = c->x86_clflush_size * 2;\r\nset_cpu_cap(c, X86_FEATURE_REP_GOOD);\r\n}\r\ncpu_detect_cache_sizes(c);\r\n}\r\nstatic void __cpuinit early_init_centaur(struct cpuinfo_x86 *c)\r\n{\r\nswitch (c->x86) {\r\n#ifdef CONFIG_X86_32\r\ncase 5:\r\nset_cpu_cap(c, X86_FEATURE_CENTAUR_MCR);\r\nbreak;\r\n#endif\r\ncase 6:\r\nif (c->x86_model >= 0xf)\r\nset_cpu_cap(c, X86_FEATURE_CONSTANT_TSC);\r\nbreak;\r\n}\r\n#ifdef CONFIG_X86_64\r\nset_cpu_cap(c, X86_FEATURE_SYSENTER32);\r\n#endif\r\n}\r\nstatic void __cpuinit init_centaur(struct cpuinfo_x86 *c)\r\n{\r\n#ifdef CONFIG_X86_32\r\nchar *name;\r\nu32 fcr_set = 0;\r\nu32 fcr_clr = 0;\r\nu32 lo, hi, newlo;\r\nu32 aa, bb, cc, dd;\r\nclear_cpu_cap(c, 0*32+31);\r\n#endif\r\nearly_init_centaur(c);\r\nswitch (c->x86) {\r\n#ifdef CONFIG_X86_32\r\ncase 5:\r\nswitch (c->x86_model) {\r\ncase 4:\r\nname = "C6";\r\nfcr_set = ECX8|DSMC|EDCTLB|EMMX|ERETSTK;\r\nfcr_clr = DPDC;\r\nprintk(KERN_NOTICE "Disabling bugged TSC.\n");\r\nclear_cpu_cap(c, X86_FEATURE_TSC);\r\n#ifdef CONFIG_X86_OOSTORE\r\ncentaur_create_optimal_mcr();\r\nwrmsr(MSR_IDT_MCR_CTRL, 0x01F0001F, 0);\r\n#endif\r\nbreak;\r\ncase 8:\r\nswitch (c->x86_mask) {\r\ndefault:\r\nname = "2";\r\nbreak;\r\ncase 7 ... 9:\r\nname = "2A";\r\nbreak;\r\ncase 10 ... 15:\r\nname = "2B";\r\nbreak;\r\n}\r\nfcr_set = ECX8|DSMC|DTLOCK|EMMX|EBRPRED|ERETSTK|\r\nE2MMX|EAMD3D;\r\nfcr_clr = DPDC;\r\n#ifdef CONFIG_X86_OOSTORE\r\nwinchip2_unprotect_mcr();\r\nwinchip2_create_optimal_mcr();\r\nrdmsr(MSR_IDT_MCR_CTRL, lo, hi);\r\nlo |= 31;\r\nwrmsr(MSR_IDT_MCR_CTRL, lo, hi);\r\nwinchip2_protect_mcr();\r\n#endif\r\nbreak;\r\ncase 9:\r\nname = "3";\r\nfcr_set = ECX8|DSMC|DTLOCK|EMMX|EBRPRED|ERETSTK|\r\nE2MMX|EAMD3D;\r\nfcr_clr = DPDC;\r\n#ifdef CONFIG_X86_OOSTORE\r\nwinchip2_unprotect_mcr();\r\nwinchip2_create_optimal_mcr();\r\nrdmsr(MSR_IDT_MCR_CTRL, lo, hi);\r\nlo |= 31;\r\nwrmsr(MSR_IDT_MCR_CTRL, lo, hi);\r\nwinchip2_protect_mcr();\r\n#endif\r\nbreak;\r\ndefault:\r\nname = "??";\r\n}\r\nrdmsr(MSR_IDT_FCR1, lo, hi);\r\nnewlo = (lo|fcr_set) & (~fcr_clr);\r\nif (newlo != lo) {\r\nprintk(KERN_INFO "Centaur FCR was 0x%X now 0x%X\n",\r\nlo, newlo);\r\nwrmsr(MSR_IDT_FCR1, newlo, hi);\r\n} else {\r\nprintk(KERN_INFO "Centaur FCR is 0x%X\n", lo);\r\n}\r\nset_cpu_cap(c, X86_FEATURE_CENTAUR_MCR);\r\nset_cpu_cap(c, X86_FEATURE_CX8);\r\nif (c->x86_model >= 8)\r\nset_cpu_cap(c, X86_FEATURE_3DNOW);\r\nif (cpuid_eax(0x80000000) >= 0x80000005) {\r\ncpuid(0x80000005, &aa, &bb, &cc, &dd);\r\nc->x86_cache_size = (cc>>24)+(dd>>24);\r\n}\r\nsprintf(c->x86_model_id, "WinChip %s", name);\r\nbreak;\r\n#endif\r\ncase 6:\r\ninit_c3(c);\r\nbreak;\r\n}\r\n#ifdef CONFIG_X86_64\r\nset_cpu_cap(c, X86_FEATURE_LFENCE_RDTSC);\r\n#endif\r\n}\r\nstatic unsigned int __cpuinit\r\ncentaur_size_cache(struct cpuinfo_x86 *c, unsigned int size)\r\n{\r\n#ifdef CONFIG_X86_32\r\nif ((c->x86 == 6) && ((c->x86_model == 7) || (c->x86_model == 8)))\r\nsize >>= 8;\r\nif ((c->x86 == 6) && (c->x86_model == 9) &&\r\n(c->x86_mask == 1) && (size == 65))\r\nsize -= 1;\r\n#endif\r\nreturn size;\r\n}
