static int seq_show(struct seq_file *m, void *v)\r\n{\r\nstruct files_struct *files = NULL;\r\nint f_flags = 0, ret = -ENOENT;\r\nstruct file *file = NULL;\r\nstruct task_struct *task;\r\ntask = get_proc_task(m->private);\r\nif (!task)\r\nreturn -ENOENT;\r\nfiles = get_files_struct(task);\r\nput_task_struct(task);\r\nif (files) {\r\nint fd = proc_fd(m->private);\r\nspin_lock(&files->file_lock);\r\nfile = fcheck_files(files, fd);\r\nif (file) {\r\nstruct fdtable *fdt = files_fdtable(files);\r\nf_flags = file->f_flags;\r\nif (close_on_exec(fd, fdt))\r\nf_flags |= O_CLOEXEC;\r\nget_file(file);\r\nret = 0;\r\n}\r\nspin_unlock(&files->file_lock);\r\nput_files_struct(files);\r\n}\r\nif (!ret) {\r\nseq_printf(m, "pos:\t%lli\nflags:\t0%o\n",\r\n(long long)file->f_pos, f_flags);\r\nif (file->f_op->show_fdinfo)\r\nret = file->f_op->show_fdinfo(m, file);\r\nfput(file);\r\n}\r\nreturn ret;\r\n}\r\nstatic int seq_fdinfo_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, seq_show, inode);\r\n}\r\nstatic int tid_fd_revalidate(struct dentry *dentry, unsigned int flags)\r\n{\r\nstruct files_struct *files;\r\nstruct task_struct *task;\r\nconst struct cred *cred;\r\nstruct inode *inode;\r\nint fd;\r\nif (flags & LOOKUP_RCU)\r\nreturn -ECHILD;\r\ninode = dentry->d_inode;\r\ntask = get_proc_task(inode);\r\nfd = proc_fd(inode);\r\nif (task) {\r\nfiles = get_files_struct(task);\r\nif (files) {\r\nstruct file *file;\r\nrcu_read_lock();\r\nfile = fcheck_files(files, fd);\r\nif (file) {\r\nunsigned f_mode = file->f_mode;\r\nrcu_read_unlock();\r\nput_files_struct(files);\r\nif (task_dumpable(task)) {\r\nrcu_read_lock();\r\ncred = __task_cred(task);\r\ninode->i_uid = cred->euid;\r\ninode->i_gid = cred->egid;\r\nrcu_read_unlock();\r\n} else {\r\ninode->i_uid = GLOBAL_ROOT_UID;\r\ninode->i_gid = GLOBAL_ROOT_GID;\r\n}\r\nif (S_ISLNK(inode->i_mode)) {\r\nunsigned i_mode = S_IFLNK;\r\nif (f_mode & FMODE_READ)\r\ni_mode |= S_IRUSR | S_IXUSR;\r\nif (f_mode & FMODE_WRITE)\r\ni_mode |= S_IWUSR | S_IXUSR;\r\ninode->i_mode = i_mode;\r\n}\r\nsecurity_task_to_inode(task, inode);\r\nput_task_struct(task);\r\nreturn 1;\r\n}\r\nrcu_read_unlock();\r\nput_files_struct(files);\r\n}\r\nput_task_struct(task);\r\n}\r\nd_drop(dentry);\r\nreturn 0;\r\n}\r\nstatic int proc_fd_link(struct dentry *dentry, struct path *path)\r\n{\r\nstruct files_struct *files = NULL;\r\nstruct task_struct *task;\r\nint ret = -ENOENT;\r\ntask = get_proc_task(dentry->d_inode);\r\nif (task) {\r\nfiles = get_files_struct(task);\r\nput_task_struct(task);\r\n}\r\nif (files) {\r\nint fd = proc_fd(dentry->d_inode);\r\nstruct file *fd_file;\r\nspin_lock(&files->file_lock);\r\nfd_file = fcheck_files(files, fd);\r\nif (fd_file) {\r\n*path = fd_file->f_path;\r\npath_get(&fd_file->f_path);\r\nret = 0;\r\n}\r\nspin_unlock(&files->file_lock);\r\nput_files_struct(files);\r\n}\r\nreturn ret;\r\n}\r\nstatic struct dentry *\r\nproc_fd_instantiate(struct inode *dir, struct dentry *dentry,\r\nstruct task_struct *task, const void *ptr)\r\n{\r\nstruct dentry *error = ERR_PTR(-ENOENT);\r\nunsigned fd = (unsigned long)ptr;\r\nstruct proc_inode *ei;\r\nstruct inode *inode;\r\ninode = proc_pid_make_inode(dir->i_sb, task);\r\nif (!inode)\r\ngoto out;\r\nei = PROC_I(inode);\r\nei->fd = fd;\r\ninode->i_mode = S_IFLNK;\r\ninode->i_op = &proc_pid_link_inode_operations;\r\ninode->i_size = 64;\r\nei->op.proc_get_link = proc_fd_link;\r\nd_set_d_op(dentry, &tid_fd_dentry_operations);\r\nd_add(dentry, inode);\r\nif (tid_fd_revalidate(dentry, 0))\r\nerror = NULL;\r\nout:\r\nreturn error;\r\n}\r\nstatic struct dentry *proc_lookupfd_common(struct inode *dir,\r\nstruct dentry *dentry,\r\ninstantiate_t instantiate)\r\n{\r\nstruct task_struct *task = get_proc_task(dir);\r\nstruct dentry *result = ERR_PTR(-ENOENT);\r\nunsigned fd = name_to_int(dentry);\r\nif (!task)\r\ngoto out_no_task;\r\nif (fd == ~0U)\r\ngoto out;\r\nresult = instantiate(dir, dentry, task, (void *)(unsigned long)fd);\r\nout:\r\nput_task_struct(task);\r\nout_no_task:\r\nreturn result;\r\n}\r\nstatic int proc_readfd_common(struct file * filp, void * dirent,\r\nfilldir_t filldir, instantiate_t instantiate)\r\n{\r\nstruct dentry *dentry = filp->f_path.dentry;\r\nstruct inode *inode = dentry->d_inode;\r\nstruct task_struct *p = get_proc_task(inode);\r\nstruct files_struct *files;\r\nunsigned int fd, ino;\r\nint retval;\r\nretval = -ENOENT;\r\nif (!p)\r\ngoto out_no_task;\r\nretval = 0;\r\nfd = filp->f_pos;\r\nswitch (fd) {\r\ncase 0:\r\nif (filldir(dirent, ".", 1, 0, inode->i_ino, DT_DIR) < 0)\r\ngoto out;\r\nfilp->f_pos++;\r\ncase 1:\r\nino = parent_ino(dentry);\r\nif (filldir(dirent, "..", 2, 1, ino, DT_DIR) < 0)\r\ngoto out;\r\nfilp->f_pos++;\r\ndefault:\r\nfiles = get_files_struct(p);\r\nif (!files)\r\ngoto out;\r\nrcu_read_lock();\r\nfor (fd = filp->f_pos - 2;\r\nfd < files_fdtable(files)->max_fds;\r\nfd++, filp->f_pos++) {\r\nchar name[PROC_NUMBUF];\r\nint len;\r\nint rv;\r\nif (!fcheck_files(files, fd))\r\ncontinue;\r\nrcu_read_unlock();\r\nlen = snprintf(name, sizeof(name), "%d", fd);\r\nrv = proc_fill_cache(filp, dirent, filldir,\r\nname, len, instantiate, p,\r\n(void *)(unsigned long)fd);\r\nif (rv < 0)\r\ngoto out_fd_loop;\r\nrcu_read_lock();\r\n}\r\nrcu_read_unlock();\r\nout_fd_loop:\r\nput_files_struct(files);\r\n}\r\nout:\r\nput_task_struct(p);\r\nout_no_task:\r\nreturn retval;\r\n}\r\nstatic int proc_readfd(struct file *filp, void *dirent, filldir_t filldir)\r\n{\r\nreturn proc_readfd_common(filp, dirent, filldir, proc_fd_instantiate);\r\n}\r\nstatic struct dentry *proc_lookupfd(struct inode *dir, struct dentry *dentry,\r\nunsigned int flags)\r\n{\r\nreturn proc_lookupfd_common(dir, dentry, proc_fd_instantiate);\r\n}\r\nint proc_fd_permission(struct inode *inode, int mask)\r\n{\r\nint rv = generic_permission(inode, mask);\r\nif (rv == 0)\r\nreturn 0;\r\nif (task_pid(current) == proc_pid(inode))\r\nrv = 0;\r\nreturn rv;\r\n}\r\nstatic struct dentry *\r\nproc_fdinfo_instantiate(struct inode *dir, struct dentry *dentry,\r\nstruct task_struct *task, const void *ptr)\r\n{\r\nstruct dentry *error = ERR_PTR(-ENOENT);\r\nunsigned fd = (unsigned long)ptr;\r\nstruct proc_inode *ei;\r\nstruct inode *inode;\r\ninode = proc_pid_make_inode(dir->i_sb, task);\r\nif (!inode)\r\ngoto out;\r\nei = PROC_I(inode);\r\nei->fd = fd;\r\ninode->i_mode = S_IFREG | S_IRUSR;\r\ninode->i_fop = &proc_fdinfo_file_operations;\r\nd_set_d_op(dentry, &tid_fd_dentry_operations);\r\nd_add(dentry, inode);\r\nif (tid_fd_revalidate(dentry, 0))\r\nerror = NULL;\r\nout:\r\nreturn error;\r\n}\r\nstatic struct dentry *\r\nproc_lookupfdinfo(struct inode *dir, struct dentry *dentry, unsigned int flags)\r\n{\r\nreturn proc_lookupfd_common(dir, dentry, proc_fdinfo_instantiate);\r\n}\r\nstatic int proc_readfdinfo(struct file *filp, void *dirent, filldir_t filldir)\r\n{\r\nreturn proc_readfd_common(filp, dirent, filldir,\r\nproc_fdinfo_instantiate);\r\n}
