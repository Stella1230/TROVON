static char *getrev(const char *revision)\r\n{\r\nchar *rev;\r\nchar *p;\r\nif ((p = strchr(revision, ':'))) {\r\nrev = p + 2;\r\np = strchr(rev, '$');\r\n*--p = 0;\r\n} else\r\nrev = "1.0";\r\nreturn rev;\r\n}\r\nvoid diva_log_info(unsigned char *format, ...)\r\n{\r\nva_list args;\r\nunsigned char line[160];\r\nva_start(args, format);\r\nvsnprintf(line, sizeof(line), format, args);\r\nva_end(args);\r\nprintk(KERN_INFO "%s: %s\n", DRIVERLNAME, line);\r\n}\r\nvoid divas_get_version(char *p)\r\n{\r\nchar tmprev[32];\r\nstrcpy(tmprev, main_revision);\r\nsprintf(p, "%s: %s(%s) %s(%s) major=%d\n", DRIVERLNAME, DRIVERRELEASE_DIVAS,\r\ngetrev(tmprev), diva_xdi_common_code_build, DIVA_BUILD, major);\r\n}\r\nbyte diva_os_get_pci_bus(void *pci_dev_handle)\r\n{\r\nstruct pci_dev *pdev = (struct pci_dev *) pci_dev_handle;\r\nreturn ((byte) pdev->bus->number);\r\n}\r\nbyte diva_os_get_pci_func(void *pci_dev_handle)\r\n{\r\nstruct pci_dev *pdev = (struct pci_dev *) pci_dev_handle;\r\nreturn ((byte) pdev->devfn);\r\n}\r\nunsigned long divasa_get_pci_irq(unsigned char bus, unsigned char func,\r\nvoid *pci_dev_handle)\r\n{\r\nunsigned char irq = 0;\r\nstruct pci_dev *dev = (struct pci_dev *) pci_dev_handle;\r\nirq = dev->irq;\r\nreturn ((unsigned long) irq);\r\n}\r\nunsigned long divasa_get_pci_bar(unsigned char bus, unsigned char func,\r\nint bar, void *pci_dev_handle)\r\n{\r\nunsigned long ret = 0;\r\nstruct pci_dev *dev = (struct pci_dev *) pci_dev_handle;\r\nif (bar < 6) {\r\nret = dev->resource[bar].start;\r\n}\r\nDBG_TRC(("GOT BAR[%d]=%08x", bar, ret));\r\n{\r\nunsigned long type = (ret & 0x00000001);\r\nif (type & PCI_BASE_ADDRESS_SPACE_IO) {\r\nDBG_TRC((" I/O"));\r\nret &= PCI_BASE_ADDRESS_IO_MASK;\r\n} else {\r\nDBG_TRC((" memory"));\r\nret &= PCI_BASE_ADDRESS_MEM_MASK;\r\n}\r\nDBG_TRC((" final=%08x", ret));\r\n}\r\nreturn (ret);\r\n}\r\nvoid PCIwrite(byte bus, byte func, int offset, void *data, int length,\r\nvoid *pci_dev_handle)\r\n{\r\nstruct pci_dev *dev = (struct pci_dev *) pci_dev_handle;\r\nswitch (length) {\r\ncase 1:\r\npci_write_config_byte(dev, offset,\r\n*(unsigned char *) data);\r\nbreak;\r\ncase 2:\r\npci_write_config_word(dev, offset,\r\n*(unsigned short *) data);\r\nbreak;\r\ncase 4:\r\npci_write_config_dword(dev, offset,\r\n*(unsigned int *) data);\r\nbreak;\r\ndefault:\r\nif (!(length % 4) && !(length & 0x03)) {\r\ndword *p = (dword *) data;\r\nlength /= 4;\r\nwhile (length--) {\r\npci_write_config_dword(dev, offset,\r\n*(unsigned int *)\r\np++);\r\n}\r\n} else {\r\nbyte *p = (byte *) data;\r\nwhile (length--) {\r\npci_write_config_byte(dev, offset,\r\n*(unsigned char *)\r\np++);\r\n}\r\n}\r\n}\r\n}\r\nvoid PCIread(byte bus, byte func, int offset, void *data, int length,\r\nvoid *pci_dev_handle)\r\n{\r\nstruct pci_dev *dev = (struct pci_dev *) pci_dev_handle;\r\nswitch (length) {\r\ncase 1:\r\npci_read_config_byte(dev, offset, (unsigned char *) data);\r\nbreak;\r\ncase 2:\r\npci_read_config_word(dev, offset, (unsigned short *) data);\r\nbreak;\r\ncase 4:\r\npci_read_config_dword(dev, offset, (unsigned int *) data);\r\nbreak;\r\ndefault:\r\nif (!(length % 4) && !(length & 0x03)) {\r\ndword *p = (dword *) data;\r\nlength /= 4;\r\nwhile (length--) {\r\npci_read_config_dword(dev, offset,\r\n(unsigned int *)\r\np++);\r\n}\r\n} else {\r\nbyte *p = (byte *) data;\r\nwhile (length--) {\r\npci_read_config_byte(dev, offset,\r\n(unsigned char *)\r\np++);\r\n}\r\n}\r\n}\r\n}\r\nstatic void *diva_pci_alloc_consistent(struct pci_dev *hwdev,\r\nsize_t size,\r\ndma_addr_t *dma_handle,\r\nvoid **addr_handle)\r\n{\r\nvoid *addr = pci_alloc_consistent(hwdev, size, dma_handle);\r\n*addr_handle = addr;\r\nreturn (addr);\r\n}\r\nvoid diva_init_dma_map(void *hdev,\r\nstruct _diva_dma_map_entry **ppmap, int nentries)\r\n{\r\nstruct pci_dev *pdev = (struct pci_dev *) hdev;\r\nstruct _diva_dma_map_entry *pmap =\r\ndiva_alloc_dma_map(hdev, nentries);\r\nif (pmap) {\r\nint i;\r\ndma_addr_t dma_handle;\r\nvoid *cpu_addr;\r\nvoid *addr_handle;\r\nfor (i = 0; i < nentries; i++) {\r\nif (!(cpu_addr = diva_pci_alloc_consistent(pdev,\r\nPAGE_SIZE,\r\n&dma_handle,\r\n&addr_handle)))\r\n{\r\nbreak;\r\n}\r\ndiva_init_dma_map_entry(pmap, i, cpu_addr,\r\n(dword) dma_handle,\r\naddr_handle);\r\nDBG_TRC(("dma map alloc [%d]=(%08lx:%08x:%08lx)",\r\ni, (unsigned long) cpu_addr,\r\n(dword) dma_handle,\r\n(unsigned long) addr_handle))}\r\n}\r\n*ppmap = pmap;\r\n}\r\nvoid diva_free_dma_map(void *hdev, struct _diva_dma_map_entry *pmap)\r\n{\r\nstruct pci_dev *pdev = (struct pci_dev *) hdev;\r\nint i;\r\ndword phys_addr;\r\nvoid *cpu_addr;\r\ndma_addr_t dma_handle;\r\nvoid *addr_handle;\r\nfor (i = 0; (pmap != NULL); i++) {\r\ndiva_get_dma_map_entry(pmap, i, &cpu_addr, &phys_addr);\r\nif (!cpu_addr) {\r\nbreak;\r\n}\r\naddr_handle = diva_get_entry_handle(pmap, i);\r\ndma_handle = (dma_addr_t) phys_addr;\r\npci_free_consistent(pdev, PAGE_SIZE, addr_handle,\r\ndma_handle);\r\nDBG_TRC(("dma map free [%d]=(%08lx:%08x:%08lx)", i,\r\n(unsigned long) cpu_addr, (dword) dma_handle,\r\n(unsigned long) addr_handle))\r\n}\r\ndiva_free_dma_mapping(pmap);\r\n}\r\nint\r\ndiva_os_register_io_port(void *adapter, int on, unsigned long port,\r\nunsigned long length, const char *name, int id)\r\n{\r\nif (on) {\r\nif (!request_region(port, length, name)) {\r\nDBG_ERR(("A: I/O: can't register port=%08x", port))\r\nreturn (-1);\r\n}\r\n} else {\r\nrelease_region(port, length);\r\n}\r\nreturn (0);\r\n}\r\nvoid __iomem *divasa_remap_pci_bar(diva_os_xdi_adapter_t *a, int id, unsigned long bar, unsigned long area_length)\r\n{\r\nvoid __iomem *ret = ioremap(bar, area_length);\r\nDBG_TRC(("remap(%08x)->%p", bar, ret));\r\nreturn (ret);\r\n}\r\nvoid divasa_unmap_pci_bar(void __iomem *bar)\r\n{\r\nif (bar) {\r\niounmap(bar);\r\n}\r\n}\r\nbyte __inline__ inpp(void __iomem *addr)\r\n{\r\nreturn (inb((unsigned long) addr));\r\n}\r\nword __inline__ inppw(void __iomem *addr)\r\n{\r\nreturn (inw((unsigned long) addr));\r\n}\r\nvoid __inline__ inppw_buffer(void __iomem *addr, void *P, int length)\r\n{\r\ninsw((unsigned long) addr, (word *) P, length >> 1);\r\n}\r\nvoid __inline__ outppw_buffer(void __iomem *addr, void *P, int length)\r\n{\r\noutsw((unsigned long) addr, (word *) P, length >> 1);\r\n}\r\nvoid __inline__ outppw(void __iomem *addr, word w)\r\n{\r\noutw(w, (unsigned long) addr);\r\n}\r\nvoid __inline__ outpp(void __iomem *addr, word p)\r\n{\r\noutb(p, (unsigned long) addr);\r\n}\r\nint diva_os_register_irq(void *context, byte irq, const char *name)\r\n{\r\nint result = request_irq(irq, diva_os_irq_wrapper,\r\nIRQF_DISABLED | IRQF_SHARED, name, context);\r\nreturn (result);\r\n}\r\nvoid diva_os_remove_irq(void *context, byte irq)\r\n{\r\nfree_irq(irq, context);\r\n}\r\nstatic void diva_os_dpc_proc(unsigned long context)\r\n{\r\ndiva_os_thread_dpc_t *psoft_isr = (diva_os_thread_dpc_t *) context;\r\ndiva_os_soft_isr_t *pisr = psoft_isr->psoft_isr;\r\n(*(pisr->callback)) (pisr, pisr->callback_context);\r\n}\r\nint diva_os_initialize_soft_isr(diva_os_soft_isr_t *psoft_isr,\r\ndiva_os_soft_isr_callback_t callback,\r\nvoid *callback_context)\r\n{\r\ndiva_os_thread_dpc_t *pdpc;\r\npdpc = (diva_os_thread_dpc_t *) diva_os_malloc(0, sizeof(*pdpc));\r\nif (!(psoft_isr->object = pdpc)) {\r\nreturn (-1);\r\n}\r\nmemset(pdpc, 0x00, sizeof(*pdpc));\r\npsoft_isr->callback = callback;\r\npsoft_isr->callback_context = callback_context;\r\npdpc->psoft_isr = psoft_isr;\r\ntasklet_init(&pdpc->divas_task, diva_os_dpc_proc, (unsigned long)pdpc);\r\nreturn (0);\r\n}\r\nint diva_os_schedule_soft_isr(diva_os_soft_isr_t *psoft_isr)\r\n{\r\nif (psoft_isr && psoft_isr->object) {\r\ndiva_os_thread_dpc_t *pdpc =\r\n(diva_os_thread_dpc_t *) psoft_isr->object;\r\ntasklet_schedule(&pdpc->divas_task);\r\n}\r\nreturn (1);\r\n}\r\nint diva_os_cancel_soft_isr(diva_os_soft_isr_t *psoft_isr)\r\n{\r\nreturn (0);\r\n}\r\nvoid diva_os_remove_soft_isr(diva_os_soft_isr_t *psoft_isr)\r\n{\r\nif (psoft_isr && psoft_isr->object) {\r\ndiva_os_thread_dpc_t *pdpc =\r\n(diva_os_thread_dpc_t *) psoft_isr->object;\r\nvoid *mem;\r\ntasklet_kill(&pdpc->divas_task);\r\nmem = psoft_isr->object;\r\npsoft_isr->object = NULL;\r\ndiva_os_free(0, mem);\r\n}\r\n}\r\nstatic int\r\nxdi_copy_to_user(void *os_handle, void __user *dst, const void *src, int length)\r\n{\r\nif (copy_to_user(dst, src, length)) {\r\nreturn (-EFAULT);\r\n}\r\nreturn (length);\r\n}\r\nstatic int\r\nxdi_copy_from_user(void *os_handle, void *dst, const void __user *src, int length)\r\n{\r\nif (copy_from_user(dst, src, length)) {\r\nreturn (-EFAULT);\r\n}\r\nreturn (length);\r\n}\r\nstatic int divas_open(struct inode *inode, struct file *file)\r\n{\r\nreturn (0);\r\n}\r\nstatic int divas_release(struct inode *inode, struct file *file)\r\n{\r\nif (file->private_data) {\r\ndiva_xdi_close_adapter(file->private_data, file);\r\n}\r\nreturn (0);\r\n}\r\nstatic ssize_t divas_write(struct file *file, const char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nint ret = -EINVAL;\r\nif (!file->private_data) {\r\nfile->private_data = diva_xdi_open_adapter(file, buf,\r\ncount,\r\nxdi_copy_from_user);\r\n}\r\nif (!file->private_data) {\r\nreturn (-ENODEV);\r\n}\r\nret = diva_xdi_write(file->private_data, file,\r\nbuf, count, xdi_copy_from_user);\r\nswitch (ret) {\r\ncase -1:\r\nret = -EBUSY;\r\nbreak;\r\ncase -2:\r\nret = -ENOMEM;\r\nbreak;\r\ncase -3:\r\nret = -ENXIO;\r\nbreak;\r\n}\r\nDBG_TRC(("write: ret %d", ret));\r\nreturn (ret);\r\n}\r\nstatic ssize_t divas_read(struct file *file, char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nint ret = -EINVAL;\r\nif (!file->private_data) {\r\nfile->private_data = diva_xdi_open_adapter(file, buf,\r\ncount,\r\nxdi_copy_from_user);\r\n}\r\nif (!file->private_data) {\r\nreturn (-ENODEV);\r\n}\r\nret = diva_xdi_read(file->private_data, file,\r\nbuf, count, xdi_copy_to_user);\r\nswitch (ret) {\r\ncase -1:\r\nret = -EAGAIN;\r\nbreak;\r\ncase -2:\r\nret = -ENOMEM;\r\nbreak;\r\ncase -3:\r\nret = -EFAULT;\r\nbreak;\r\n}\r\nDBG_TRC(("read: ret %d", ret));\r\nreturn (ret);\r\n}\r\nstatic unsigned int divas_poll(struct file *file, poll_table *wait)\r\n{\r\nif (!file->private_data) {\r\nreturn (POLLERR);\r\n}\r\nreturn (POLLIN | POLLRDNORM);\r\n}\r\nstatic void divas_unregister_chrdev(void)\r\n{\r\nunregister_chrdev(major, DEVNAME);\r\n}\r\nstatic int __init divas_register_chrdev(void)\r\n{\r\nif ((major = register_chrdev(0, DEVNAME, &divas_fops)) < 0)\r\n{\r\nprintk(KERN_ERR "%s: failed to create /dev entry.\n",\r\nDRIVERLNAME);\r\nreturn (0);\r\n}\r\nreturn (1);\r\n}\r\nstatic int divas_init_one(struct pci_dev *pdev, const struct pci_device_id *ent)\r\n{\r\nvoid *pdiva = NULL;\r\nu8 pci_latency;\r\nu8 new_latency = 32;\r\nDBG_TRC(("%s bus: %08x fn: %08x insertion.\n",\r\nCardProperties[ent->driver_data].Name,\r\npdev->bus->number, pdev->devfn))\r\nprintk(KERN_INFO "%s: %s bus: %08x fn: %08x insertion.\n",\r\nDRIVERLNAME, CardProperties[ent->driver_data].Name,\r\npdev->bus->number, pdev->devfn);\r\nif (pci_enable_device(pdev)) {\r\nDBG_TRC(("%s: %s bus: %08x fn: %08x device init failed.\n",\r\nDRIVERLNAME,\r\nCardProperties[ent->driver_data].Name,\r\npdev->bus->number,\r\npdev->devfn))\r\nprintk(KERN_ERR\r\n"%s: %s bus: %08x fn: %08x device init failed.\n",\r\nDRIVERLNAME,\r\nCardProperties[ent->driver_data].\r\nName, pdev->bus->number,\r\npdev->devfn);\r\nreturn (-EIO);\r\n}\r\npci_set_master(pdev);\r\npci_read_config_byte(pdev, PCI_LATENCY_TIMER, &pci_latency);\r\nif (!pci_latency) {\r\nDBG_TRC(("%s: bus: %08x fn: %08x fix latency.\n",\r\nDRIVERLNAME, pdev->bus->number, pdev->devfn))\r\nprintk(KERN_INFO\r\n"%s: bus: %08x fn: %08x fix latency.\n",\r\nDRIVERLNAME, pdev->bus->number, pdev->devfn);\r\npci_write_config_byte(pdev, PCI_LATENCY_TIMER, new_latency);\r\n}\r\nif (!(pdiva = diva_driver_add_card(pdev, ent->driver_data))) {\r\nDBG_TRC(("%s: %s bus: %08x fn: %08x card init failed.\n",\r\nDRIVERLNAME,\r\nCardProperties[ent->driver_data].Name,\r\npdev->bus->number,\r\npdev->devfn))\r\nprintk(KERN_ERR\r\n"%s: %s bus: %08x fn: %08x card init failed.\n",\r\nDRIVERLNAME,\r\nCardProperties[ent->driver_data].\r\nName, pdev->bus->number,\r\npdev->devfn);\r\nreturn (-EIO);\r\n}\r\npci_set_drvdata(pdev, pdiva);\r\nreturn (0);\r\n}\r\nstatic void divas_remove_one(struct pci_dev *pdev)\r\n{\r\nvoid *pdiva = pci_get_drvdata(pdev);\r\nDBG_TRC(("bus: %08x fn: %08x removal.\n",\r\npdev->bus->number, pdev->devfn))\r\nprintk(KERN_INFO "%s: bus: %08x fn: %08x removal.\n",\r\nDRIVERLNAME, pdev->bus->number, pdev->devfn);\r\nif (pdiva) {\r\ndiva_driver_remove_card(pdiva);\r\n}\r\n}\r\nstatic int __init divas_init(void)\r\n{\r\nchar tmprev[50];\r\nint ret = 0;\r\nprintk(KERN_INFO "%s\n", DRIVERNAME);\r\nprintk(KERN_INFO "%s: Rel:%s Rev:", DRIVERLNAME, DRIVERRELEASE_DIVAS);\r\nstrcpy(tmprev, main_revision);\r\nprintk("%s Build: %s(%s)\n", getrev(tmprev),\r\ndiva_xdi_common_code_build, DIVA_BUILD);\r\nprintk(KERN_INFO "%s: support for: ", DRIVERLNAME);\r\n#ifdef CONFIG_ISDN_DIVAS_BRIPCI\r\nprintk("BRI/PCI ");\r\n#endif\r\n#ifdef CONFIG_ISDN_DIVAS_PRIPCI\r\nprintk("PRI/PCI ");\r\n#endif\r\nprintk("adapters\n");\r\nif (!divasfunc_init(dbgmask)) {\r\nprintk(KERN_ERR "%s: failed to connect to DIDD.\n",\r\nDRIVERLNAME);\r\nret = -EIO;\r\ngoto out;\r\n}\r\nif (!divas_register_chrdev()) {\r\n#ifdef MODULE\r\ndivasfunc_exit();\r\n#endif\r\nret = -EIO;\r\ngoto out;\r\n}\r\nif (!create_divas_proc()) {\r\n#ifdef MODULE\r\ndivas_unregister_chrdev();\r\ndivasfunc_exit();\r\n#endif\r\nprintk(KERN_ERR "%s: failed to create proc entry.\n",\r\nDRIVERLNAME);\r\nret = -EIO;\r\ngoto out;\r\n}\r\nif ((ret = pci_register_driver(&diva_pci_driver))) {\r\n#ifdef MODULE\r\nremove_divas_proc();\r\ndivas_unregister_chrdev();\r\ndivasfunc_exit();\r\n#endif\r\nprintk(KERN_ERR "%s: failed to init pci driver.\n",\r\nDRIVERLNAME);\r\ngoto out;\r\n}\r\nprintk(KERN_INFO "%s: started with major %d\n", DRIVERLNAME, major);\r\nout:\r\nreturn (ret);\r\n}\r\nstatic void __exit divas_exit(void)\r\n{\r\npci_unregister_driver(&diva_pci_driver);\r\nremove_divas_proc();\r\ndivas_unregister_chrdev();\r\ndivasfunc_exit();\r\nprintk(KERN_INFO "%s: module unloaded.\n", DRIVERLNAME);\r\n}
