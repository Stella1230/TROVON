static inline void rmw(volatile char __iomem *p)\r\n{\r\nreadb(p);\r\nwriteb(1, p);\r\n}\r\nstatic inline int setmode(int mode)\r\n{\r\nint oldmode;\r\noldmode = vga_io_rgfx(VGA_GFX_MODE);\r\nvga_io_w(VGA_GFX_D, mode);\r\nreturn oldmode;\r\n}\r\nstatic inline int selectmask(void)\r\n{\r\nreturn vga_io_rgfx(VGA_GFX_BIT_MASK);\r\n}\r\nstatic inline void setmask(int mask)\r\n{\r\nvga_io_w(VGA_GFX_D, mask);\r\n}\r\nstatic inline int setop(int op)\r\n{\r\nint oldop;\r\noldop = vga_io_rgfx(VGA_GFX_DATA_ROTATE);\r\nvga_io_w(VGA_GFX_D, op);\r\nreturn oldop;\r\n}\r\nstatic inline int setsr(int sr)\r\n{\r\nint oldsr;\r\noldsr = vga_io_rgfx(VGA_GFX_SR_ENABLE);\r\nvga_io_w(VGA_GFX_D, sr);\r\nreturn oldsr;\r\n}\r\nstatic inline int setcolor(int color)\r\n{\r\nint oldcolor;\r\noldcolor = vga_io_rgfx(VGA_GFX_SR_VALUE);\r\nvga_io_w(VGA_GFX_D, color);\r\nreturn oldcolor;\r\n}\r\nstatic inline int getindex(void)\r\n{\r\nreturn vga_io_r(VGA_GFX_I);\r\n}\r\nstatic inline void setindex(int index)\r\n{\r\nvga_io_w(VGA_GFX_I, index);\r\n}\r\nstatic void vga16fb_pan_var(struct fb_info *info,\r\nstruct fb_var_screeninfo *var)\r\n{\r\nstruct vga16fb_par *par = info->par;\r\nu32 xoffset, pos;\r\nxoffset = var->xoffset;\r\nif (info->var.bits_per_pixel == 8) {\r\npos = (info->var.xres_virtual * var->yoffset + xoffset) >> 2;\r\n} else if (par->mode & MODE_TEXT) {\r\nint fh = 16;\r\npos = (info->var.xres_virtual * (var->yoffset / fh) + xoffset) >> 3;\r\n} else {\r\nif (info->var.nonstd)\r\nxoffset--;\r\npos = (info->var.xres_virtual * var->yoffset + xoffset) >> 3;\r\n}\r\nvga_io_wcrt(VGA_CRTC_START_HI, pos >> 8);\r\nvga_io_wcrt(VGA_CRTC_START_LO, pos & 0xFF);\r\nvga_io_r(VGA_IS1_RC);\r\nvga_io_w(VGA_ATT_IW, VGA_ATC_PEL);\r\nif (info->var.bits_per_pixel == 8)\r\nvga_io_w(VGA_ATT_IW, (xoffset & 3) << 1);\r\nelse\r\nvga_io_w(VGA_ATT_IW, xoffset & 7);\r\nvga_io_r(VGA_IS1_RC);\r\nvga_io_w(VGA_ATT_IW, 0x20);\r\n}\r\nstatic void vga16fb_update_fix(struct fb_info *info)\r\n{\r\nif (info->var.bits_per_pixel == 4) {\r\nif (info->var.nonstd) {\r\ninfo->fix.type = FB_TYPE_PACKED_PIXELS;\r\ninfo->fix.line_length = info->var.xres_virtual / 2;\r\n} else {\r\ninfo->fix.type = FB_TYPE_VGA_PLANES;\r\ninfo->fix.type_aux = FB_AUX_VGA_PLANES_VGA4;\r\ninfo->fix.line_length = info->var.xres_virtual / 8;\r\n}\r\n} else if (info->var.bits_per_pixel == 0) {\r\ninfo->fix.type = FB_TYPE_TEXT;\r\ninfo->fix.type_aux = FB_AUX_TEXT_CGA;\r\ninfo->fix.line_length = info->var.xres_virtual / 4;\r\n} else {\r\nif (info->var.nonstd) {\r\ninfo->fix.type = FB_TYPE_VGA_PLANES;\r\ninfo->fix.type_aux = FB_AUX_VGA_PLANES_CFB8;\r\ninfo->fix.line_length = info->var.xres_virtual / 4;\r\n} else {\r\ninfo->fix.type = FB_TYPE_PACKED_PIXELS;\r\ninfo->fix.line_length = info->var.xres_virtual;\r\n}\r\n}\r\n}\r\nstatic void vga16fb_clock_chip(struct vga16fb_par *par,\r\nunsigned int pixclock,\r\nconst struct fb_info *info,\r\nint mul, int div)\r\n{\r\nstatic const struct {\r\nu32 pixclock;\r\nu8 misc;\r\nu8 seq_clock_mode;\r\n} *ptr, *best, vgaclocks[] = {\r\n{ 79442 , 0x00, 0x08},\r\n{ 70616 , 0x04, 0x08},\r\n{ 39721 , 0x00, 0x00},\r\n{ 35308 , 0x04, 0x00},\r\n{ 0 , 0x00, 0x00}};\r\nint err;\r\npixclock = (pixclock * mul) / div;\r\nbest = vgaclocks;\r\nerr = pixclock - best->pixclock;\r\nif (err < 0) err = -err;\r\nfor (ptr = vgaclocks + 1; ptr->pixclock; ptr++) {\r\nint tmp;\r\ntmp = pixclock - ptr->pixclock;\r\nif (tmp < 0) tmp = -tmp;\r\nif (tmp < err) {\r\nerr = tmp;\r\nbest = ptr;\r\n}\r\n}\r\npar->misc |= best->misc;\r\npar->clkdiv = best->seq_clock_mode;\r\npixclock = (best->pixclock * div) / mul;\r\n}\r\nstatic int vga16fb_open(struct fb_info *info, int user)\r\n{\r\nstruct vga16fb_par *par = info->par;\r\nif (!par->ref_count) {\r\nmemset(&par->state, 0, sizeof(struct vgastate));\r\npar->state.flags = VGA_SAVE_FONTS | VGA_SAVE_MODE |\r\nVGA_SAVE_CMAP;\r\nsave_vga(&par->state);\r\n}\r\npar->ref_count++;\r\nreturn 0;\r\n}\r\nstatic int vga16fb_release(struct fb_info *info, int user)\r\n{\r\nstruct vga16fb_par *par = info->par;\r\nif (!par->ref_count)\r\nreturn -EINVAL;\r\nif (par->ref_count == 1)\r\nrestore_vga(&par->state);\r\npar->ref_count--;\r\nreturn 0;\r\n}\r\nstatic int vga16fb_check_var(struct fb_var_screeninfo *var,\r\nstruct fb_info *info)\r\n{\r\nstruct vga16fb_par *par = info->par;\r\nu32 xres, right, hslen, left, xtotal;\r\nu32 yres, lower, vslen, upper, ytotal;\r\nu32 vxres, xoffset, vyres, yoffset;\r\nu32 pos;\r\nu8 r7, rMode;\r\nint shift;\r\nint mode;\r\nu32 maxmem;\r\npar->pel_msk = 0xFF;\r\nif (var->bits_per_pixel == 4) {\r\nif (var->nonstd) {\r\nif (!par->isVGA)\r\nreturn -EINVAL;\r\nshift = 3;\r\nmode = MODE_SKIP4 | MODE_CFB;\r\nmaxmem = 16384;\r\npar->pel_msk = 0x0F;\r\n} else {\r\nshift = 3;\r\nmode = 0;\r\nmaxmem = 65536;\r\n}\r\n} else if (var->bits_per_pixel == 8) {\r\nif (!par->isVGA)\r\nreturn -EINVAL;\r\nshift = 2;\r\nif (var->nonstd) {\r\nmode = MODE_8BPP | MODE_CFB;\r\nmaxmem = 65536;\r\n} else {\r\nmode = MODE_SKIP4 | MODE_8BPP | MODE_CFB;\r\nmaxmem = 16384;\r\n}\r\n} else\r\nreturn -EINVAL;\r\nxres = (var->xres + 7) & ~7;\r\nvxres = (var->xres_virtual + 0xF) & ~0xF;\r\nxoffset = (var->xoffset + 7) & ~7;\r\nleft = (var->left_margin + 7) & ~7;\r\nright = (var->right_margin + 7) & ~7;\r\nhslen = (var->hsync_len + 7) & ~7;\r\nif (vxres < xres)\r\nvxres = xres;\r\nif (xres + xoffset > vxres)\r\nxoffset = vxres - xres;\r\nvar->xres = xres;\r\nvar->right_margin = right;\r\nvar->hsync_len = hslen;\r\nvar->left_margin = left;\r\nvar->xres_virtual = vxres;\r\nvar->xoffset = xoffset;\r\nxres >>= shift;\r\nright >>= shift;\r\nhslen >>= shift;\r\nleft >>= shift;\r\nvxres >>= shift;\r\nxtotal = xres + right + hslen + left;\r\nif (xtotal >= 256)\r\nFAIL("xtotal too big");\r\nif (hslen > 32)\r\nFAIL("hslen too big");\r\nif (right + hslen + left > 64)\r\nFAIL("hblank too big");\r\npar->crtc[VGA_CRTC_H_TOTAL] = xtotal - 5;\r\npar->crtc[VGA_CRTC_H_BLANK_START] = xres - 1;\r\npar->crtc[VGA_CRTC_H_DISP] = xres - 1;\r\npos = xres + right;\r\npar->crtc[VGA_CRTC_H_SYNC_START] = pos;\r\npos += hslen;\r\npar->crtc[VGA_CRTC_H_SYNC_END] = pos & 0x1F;\r\npos += left - 2;\r\npar->crtc[VGA_CRTC_H_BLANK_END] = (pos & 0x1F) | 0x80;\r\nif (pos & 0x20)\r\npar->crtc[VGA_CRTC_H_SYNC_END] |= 0x80;\r\nyres = var->yres;\r\nlower = var->lower_margin;\r\nvslen = var->vsync_len;\r\nupper = var->upper_margin;\r\nvyres = var->yres_virtual;\r\nyoffset = var->yoffset;\r\nif (yres > vyres)\r\nvyres = yres;\r\nif (vxres * vyres > maxmem) {\r\nvyres = maxmem / vxres;\r\nif (vyres < yres)\r\nreturn -ENOMEM;\r\n}\r\nif (yoffset + yres > vyres)\r\nyoffset = vyres - yres;\r\nvar->yres = yres;\r\nvar->lower_margin = lower;\r\nvar->vsync_len = vslen;\r\nvar->upper_margin = upper;\r\nvar->yres_virtual = vyres;\r\nvar->yoffset = yoffset;\r\nif (var->vmode & FB_VMODE_DOUBLE) {\r\nyres <<= 1;\r\nlower <<= 1;\r\nvslen <<= 1;\r\nupper <<= 1;\r\n}\r\nytotal = yres + lower + vslen + upper;\r\nif (ytotal > 1024) {\r\nytotal >>= 1;\r\nyres >>= 1;\r\nlower >>= 1;\r\nvslen >>= 1;\r\nupper >>= 1;\r\nrMode = 0x04;\r\n} else\r\nrMode = 0x00;\r\nif (ytotal > 1024)\r\nFAIL("ytotal too big");\r\nif (vslen > 16)\r\nFAIL("vslen too big");\r\npar->crtc[VGA_CRTC_V_TOTAL] = ytotal - 2;\r\nr7 = 0x10;\r\nif (ytotal & 0x100) r7 |= 0x01;\r\nif (ytotal & 0x200) r7 |= 0x20;\r\npar->crtc[VGA_CRTC_PRESET_ROW] = 0;\r\npar->crtc[VGA_CRTC_MAX_SCAN] = 0x40;\r\nif (var->vmode & FB_VMODE_DOUBLE)\r\npar->crtc[VGA_CRTC_MAX_SCAN] |= 0x80;\r\npar->crtc[VGA_CRTC_CURSOR_START] = 0x20;\r\npar->crtc[VGA_CRTC_CURSOR_END] = 0x00;\r\nif ((mode & (MODE_CFB | MODE_8BPP)) == MODE_CFB)\r\nxoffset--;\r\npos = yoffset * vxres + (xoffset >> shift);\r\npar->crtc[VGA_CRTC_START_HI] = pos >> 8;\r\npar->crtc[VGA_CRTC_START_LO] = pos & 0xFF;\r\npar->crtc[VGA_CRTC_CURSOR_HI] = 0x00;\r\npar->crtc[VGA_CRTC_CURSOR_LO] = 0x00;\r\npos = yres - 1;\r\npar->crtc[VGA_CRTC_V_DISP_END] = pos & 0xFF;\r\npar->crtc[VGA_CRTC_V_BLANK_START] = pos & 0xFF;\r\nif (pos & 0x100)\r\nr7 |= 0x0A;\r\nif (pos & 0x200) {\r\nr7 |= 0x40;\r\npar->crtc[VGA_CRTC_MAX_SCAN] |= 0x20;\r\n}\r\npos += lower;\r\npar->crtc[VGA_CRTC_V_SYNC_START] = pos & 0xFF;\r\nif (pos & 0x100)\r\nr7 |= 0x04;\r\nif (pos & 0x200)\r\nr7 |= 0x80;\r\npos += vslen;\r\npar->crtc[VGA_CRTC_V_SYNC_END] = (pos & 0x0F) & ~0x10;\r\npos += upper - 1;\r\npar->crtc[VGA_CRTC_V_BLANK_END] = pos & 0xFF;\r\nif (vxres >= 512)\r\nFAIL("vxres too long");\r\npar->crtc[VGA_CRTC_OFFSET] = vxres >> 1;\r\nif (mode & MODE_SKIP4)\r\npar->crtc[VGA_CRTC_UNDERLINE] = 0x5F;\r\nelse\r\npar->crtc[VGA_CRTC_UNDERLINE] = 0x1F;\r\npar->crtc[VGA_CRTC_MODE] = rMode | ((mode & MODE_TEXT) ? 0xA3 : 0xE3);\r\npar->crtc[VGA_CRTC_LINE_COMPARE] = 0xFF;\r\npar->crtc[VGA_CRTC_OVERFLOW] = r7;\r\npar->vss = 0x00;\r\npar->misc = 0xE3;\r\nif (var->sync & FB_SYNC_HOR_HIGH_ACT)\r\npar->misc &= ~0x40;\r\nif (var->sync & FB_SYNC_VERT_HIGH_ACT)\r\npar->misc &= ~0x80;\r\npar->mode = mode;\r\nif (mode & MODE_8BPP)\r\nvga16fb_clock_chip(par, var->pixclock, info, 1, 2);\r\nelse\r\nvga16fb_clock_chip(par, var->pixclock, info, 1, 1);\r\nvar->red.offset = var->green.offset = var->blue.offset =\r\nvar->transp.offset = 0;\r\nvar->red.length = var->green.length = var->blue.length =\r\n(par->isVGA) ? 6 : 2;\r\nvar->transp.length = 0;\r\nvar->activate = FB_ACTIVATE_NOW;\r\nvar->height = -1;\r\nvar->width = -1;\r\nvar->accel_flags = 0;\r\nreturn 0;\r\n}\r\nstatic int vga16fb_set_par(struct fb_info *info)\r\n{\r\nstruct vga16fb_par *par = info->par;\r\nu8 gdc[VGA_GFX_C];\r\nu8 seq[VGA_SEQ_C];\r\nu8 atc[VGA_ATT_C];\r\nint fh, i;\r\nseq[VGA_SEQ_CLOCK_MODE] = 0x01 | par->clkdiv;\r\nif (par->mode & MODE_TEXT)\r\nseq[VGA_SEQ_PLANE_WRITE] = 0x03;\r\nelse\r\nseq[VGA_SEQ_PLANE_WRITE] = 0x0F;\r\nseq[VGA_SEQ_CHARACTER_MAP] = 0x00;\r\nif (par->mode & MODE_TEXT)\r\nseq[VGA_SEQ_MEMORY_MODE] = 0x03;\r\nelse if (par->mode & MODE_SKIP4)\r\nseq[VGA_SEQ_MEMORY_MODE] = 0x0E;\r\nelse\r\nseq[VGA_SEQ_MEMORY_MODE] = 0x06;\r\ngdc[VGA_GFX_SR_VALUE] = 0x00;\r\ngdc[VGA_GFX_SR_ENABLE] = 0x00;\r\ngdc[VGA_GFX_COMPARE_VALUE] = 0x00;\r\ngdc[VGA_GFX_DATA_ROTATE] = 0x00;\r\ngdc[VGA_GFX_PLANE_READ] = 0;\r\nif (par->mode & MODE_TEXT) {\r\ngdc[VGA_GFX_MODE] = 0x10;\r\ngdc[VGA_GFX_MISC] = 0x06;\r\n} else {\r\nif (par->mode & MODE_CFB)\r\ngdc[VGA_GFX_MODE] = 0x40;\r\nelse\r\ngdc[VGA_GFX_MODE] = 0x00;\r\ngdc[VGA_GFX_MISC] = 0x05;\r\n}\r\ngdc[VGA_GFX_COMPARE_MASK] = 0x0F;\r\ngdc[VGA_GFX_BIT_MASK] = 0xFF;\r\nfor (i = 0x00; i < 0x10; i++)\r\natc[i] = i;\r\nif (par->mode & MODE_TEXT)\r\natc[VGA_ATC_MODE] = 0x04;\r\nelse if (par->mode & MODE_8BPP)\r\natc[VGA_ATC_MODE] = 0x41;\r\nelse\r\natc[VGA_ATC_MODE] = 0x81;\r\natc[VGA_ATC_OVERSCAN] = 0x00;\r\natc[VGA_ATC_PLANE_ENABLE] = 0x0F;\r\nif (par->mode & MODE_8BPP)\r\natc[VGA_ATC_PEL] = (info->var.xoffset & 3) << 1;\r\nelse\r\natc[VGA_ATC_PEL] = info->var.xoffset & 7;\r\natc[VGA_ATC_COLOR_PAGE] = 0x00;\r\nif (par->mode & MODE_TEXT) {\r\nfh = 16;\r\npar->crtc[VGA_CRTC_MAX_SCAN] = (par->crtc[VGA_CRTC_MAX_SCAN]\r\n& ~0x1F) | (fh - 1);\r\n}\r\nvga_io_w(VGA_MIS_W, vga_io_r(VGA_MIS_R) | 0x01);\r\nif (!par->isVGA) {\r\nvga_io_w(EGA_GFX_E0, 0x00);\r\nvga_io_w(EGA_GFX_E1, 0x01);\r\n}\r\nvga_io_w(VGA_MIS_W, par->misc);\r\nvga_io_wseq(0x00, 0x01);\r\nif (par->isVGA)\r\nvga_io_w(VGA_PEL_MSK, par->pel_msk);\r\nvga_io_wseq(VGA_SEQ_CLOCK_MODE, seq[VGA_SEQ_CLOCK_MODE] | 0x20);\r\nfor (i = 2; i < VGA_SEQ_C; i++) {\r\nvga_io_wseq(i, seq[i]);\r\n}\r\nvga_io_wseq(0x00, 0x03);\r\nvga_io_wcrt(VGA_CRTC_V_SYNC_END, par->crtc[VGA_CRTC_V_SYNC_END]);\r\nfor (i = 0; i < VGA_CRTC_REGS; i++) {\r\nvga_io_wcrt(i, par->crtc[i]);\r\n}\r\nfor (i = 0; i < VGA_GFX_C; i++) {\r\nvga_io_wgfx(i, gdc[i]);\r\n}\r\nfor (i = 0; i < VGA_ATT_C; i++) {\r\nvga_io_r(VGA_IS1_RC);\r\nvga_io_wattr(i, atc[i]);\r\n}\r\nmdelay(50);\r\nvga_io_wseq(VGA_SEQ_CLOCK_MODE, seq[VGA_SEQ_CLOCK_MODE]);\r\nvga_io_r(VGA_IS1_RC);\r\nvga_io_w(VGA_ATT_IW, 0x20);\r\nvga16fb_update_fix(info);\r\nreturn 0;\r\n}\r\nstatic void ega16_setpalette(int regno, unsigned red, unsigned green, unsigned blue)\r\n{\r\nstatic const unsigned char map[] = { 000, 001, 010, 011 };\r\nint val;\r\nif (regno >= 16)\r\nreturn;\r\nval = map[red>>14] | ((map[green>>14]) << 1) | ((map[blue>>14]) << 2);\r\nvga_io_r(VGA_IS1_RC);\r\nvga_io_wattr(regno, val);\r\nvga_io_r(VGA_IS1_RC);\r\nvga_io_w(VGA_ATT_IW, 0x20);\r\n}\r\nstatic void vga16_setpalette(int regno, unsigned red, unsigned green, unsigned blue)\r\n{\r\noutb(regno, VGA_PEL_IW);\r\noutb(red >> 10, VGA_PEL_D);\r\noutb(green >> 10, VGA_PEL_D);\r\noutb(blue >> 10, VGA_PEL_D);\r\n}\r\nstatic int vga16fb_setcolreg(unsigned regno, unsigned red, unsigned green,\r\nunsigned blue, unsigned transp,\r\nstruct fb_info *info)\r\n{\r\nstruct vga16fb_par *par = info->par;\r\nint gray;\r\nif (regno >= 256)\r\nreturn 1;\r\ngray = info->var.grayscale;\r\nif (gray) {\r\nred = green = blue = (red * 77 + green * 151 + blue * 28) >> 8;\r\n}\r\nif (par->isVGA)\r\nvga16_setpalette(regno,red,green,blue);\r\nelse\r\nega16_setpalette(regno,red,green,blue);\r\nreturn 0;\r\n}\r\nstatic int vga16fb_pan_display(struct fb_var_screeninfo *var,\r\nstruct fb_info *info)\r\n{\r\nvga16fb_pan_var(info, var);\r\nreturn 0;\r\n}\r\nstatic void vga_vesa_blank(struct vga16fb_par *par, int mode)\r\n{\r\nunsigned char SeqCtrlIndex = vga_io_r(VGA_SEQ_I);\r\nunsigned char CrtCtrlIndex = vga_io_r(VGA_CRT_IC);\r\nif(!par->vesa_blanked) {\r\npar->vga_state.CrtMiscIO = vga_io_r(VGA_MIS_R);\r\npar->vga_state.HorizontalTotal = vga_io_rcrt(0x00);\r\npar->vga_state.HorizDisplayEnd = vga_io_rcrt(0x01);\r\npar->vga_state.StartHorizRetrace = vga_io_rcrt(0x04);\r\npar->vga_state.EndHorizRetrace = vga_io_rcrt(0x05);\r\npar->vga_state.Overflow = vga_io_rcrt(0x07);\r\npar->vga_state.StartVertRetrace = vga_io_rcrt(0x10);\r\npar->vga_state.EndVertRetrace = vga_io_rcrt(0x11);\r\npar->vga_state.ModeControl = vga_io_rcrt(0x17);\r\npar->vga_state.ClockingMode = vga_io_rseq(0x01);\r\n}\r\nvga_io_wseq(0x01, par->vga_state.ClockingMode | 0x20);\r\nif ((par->vga_state.CrtMiscIO & 0x80) == 0x80)\r\nvga_io_w(VGA_MIS_W, par->vga_state.CrtMiscIO & 0xef);\r\nif (mode & FB_BLANK_VSYNC_SUSPEND) {\r\nvga_io_wcrt(VGA_CRTC_V_SYNC_START, 0xff);\r\nvga_io_wcrt(VGA_CRTC_V_SYNC_END, 0x40);\r\nvga_io_wcrt(VGA_CRTC_OVERFLOW, par->vga_state.Overflow | 0x84);\r\n}\r\nif (mode & FB_BLANK_HSYNC_SUSPEND) {\r\nvga_io_wcrt(VGA_CRTC_H_SYNC_START, 0xff);\r\nvga_io_wcrt(VGA_CRTC_H_SYNC_END, 0x00);\r\n}\r\noutb_p(SeqCtrlIndex, VGA_SEQ_I);\r\noutb_p(CrtCtrlIndex, VGA_CRT_IC);\r\n}\r\nstatic void vga_vesa_unblank(struct vga16fb_par *par)\r\n{\r\nunsigned char SeqCtrlIndex = vga_io_r(VGA_SEQ_I);\r\nunsigned char CrtCtrlIndex = vga_io_r(VGA_CRT_IC);\r\nvga_io_w(VGA_MIS_W, par->vga_state.CrtMiscIO);\r\nvga_io_wcrt(0x00, par->vga_state.HorizontalTotal);\r\nvga_io_wcrt(0x01, par->vga_state.HorizDisplayEnd);\r\nvga_io_wcrt(0x04, par->vga_state.StartHorizRetrace);\r\nvga_io_wcrt(0x05, par->vga_state.EndHorizRetrace);\r\nvga_io_wcrt(0x07, par->vga_state.Overflow);\r\nvga_io_wcrt(0x10, par->vga_state.StartVertRetrace);\r\nvga_io_wcrt(0x11, par->vga_state.EndVertRetrace);\r\nvga_io_wcrt(0x17, par->vga_state.ModeControl);\r\nvga_io_wseq(0x01, par->vga_state.ClockingMode);\r\nvga_io_w(VGA_SEQ_I, SeqCtrlIndex);\r\nvga_io_w(VGA_CRT_IC, CrtCtrlIndex);\r\n}\r\nstatic void vga_pal_blank(void)\r\n{\r\nint i;\r\nfor (i=0; i<16; i++) {\r\noutb_p(i, VGA_PEL_IW);\r\noutb_p(0, VGA_PEL_D);\r\noutb_p(0, VGA_PEL_D);\r\noutb_p(0, VGA_PEL_D);\r\n}\r\n}\r\nstatic int vga16fb_blank(int blank, struct fb_info *info)\r\n{\r\nstruct vga16fb_par *par = info->par;\r\nswitch (blank) {\r\ncase FB_BLANK_UNBLANK:\r\nif (par->vesa_blanked) {\r\nvga_vesa_unblank(par);\r\npar->vesa_blanked = 0;\r\n}\r\nif (par->palette_blanked) {\r\npar->palette_blanked = 0;\r\n}\r\nbreak;\r\ncase FB_BLANK_NORMAL:\r\nvga_pal_blank();\r\npar->palette_blanked = 1;\r\nbreak;\r\ndefault:\r\nvga_vesa_blank(par, blank);\r\npar->vesa_blanked = 1;\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic void vga_8planes_fillrect(struct fb_info *info, const struct fb_fillrect *rect)\r\n{\r\nu32 dx = rect->dx, width = rect->width;\r\nchar oldindex = getindex();\r\nchar oldmode = setmode(0x40);\r\nchar oldmask = selectmask();\r\nint line_ofs, height;\r\nchar oldop, oldsr;\r\nchar __iomem *where;\r\ndx /= 4;\r\nwhere = info->screen_base + dx + rect->dy * info->fix.line_length;\r\nif (rect->rop == ROP_COPY) {\r\noldop = setop(0);\r\noldsr = setsr(0);\r\nwidth /= 4;\r\nline_ofs = info->fix.line_length - width;\r\nsetmask(0xff);\r\nheight = rect->height;\r\nwhile (height--) {\r\nint x;\r\nfor (x = width; x > 0; --x) {\r\nwriteb(rect->color, where);\r\nwhere++;\r\n}\r\nwhere += line_ofs;\r\n}\r\n} else {\r\nchar oldcolor = setcolor(0xf);\r\nint y;\r\noldop = setop(0x18);\r\noldsr = setsr(0xf);\r\nsetmask(0x0F);\r\nfor (y = 0; y < rect->height; y++) {\r\nrmw(where);\r\nrmw(where+1);\r\nwhere += info->fix.line_length;\r\n}\r\nsetcolor(oldcolor);\r\n}\r\nsetmask(oldmask);\r\nsetsr(oldsr);\r\nsetop(oldop);\r\nsetmode(oldmode);\r\nsetindex(oldindex);\r\n}\r\nstatic void vga16fb_fillrect(struct fb_info *info, const struct fb_fillrect *rect)\r\n{\r\nint x, x2, y2, vxres, vyres, width, height, line_ofs;\r\nchar __iomem *dst;\r\nvxres = info->var.xres_virtual;\r\nvyres = info->var.yres_virtual;\r\nif (!rect->width || !rect->height || rect->dx > vxres || rect->dy > vyres)\r\nreturn;\r\nx2 = rect->dx + rect->width;\r\ny2 = rect->dy + rect->height;\r\nx2 = x2 < vxres ? x2 : vxres;\r\ny2 = y2 < vyres ? y2 : vyres;\r\nwidth = x2 - rect->dx;\r\nswitch (info->fix.type) {\r\ncase FB_TYPE_VGA_PLANES:\r\nif (info->fix.type_aux == FB_AUX_VGA_PLANES_VGA4) {\r\nheight = y2 - rect->dy;\r\nwidth = rect->width/8;\r\nline_ofs = info->fix.line_length - width;\r\ndst = info->screen_base + (rect->dx/8) + rect->dy * info->fix.line_length;\r\nswitch (rect->rop) {\r\ncase ROP_COPY:\r\nsetmode(0);\r\nsetop(0);\r\nsetsr(0xf);\r\nsetcolor(rect->color);\r\nselectmask();\r\nsetmask(0xff);\r\nwhile (height--) {\r\nfor (x = 0; x < width; x++) {\r\nwriteb(0, dst);\r\ndst++;\r\n}\r\ndst += line_ofs;\r\n}\r\nbreak;\r\ncase ROP_XOR:\r\nsetmode(0);\r\nsetop(0x18);\r\nsetsr(0xf);\r\nsetcolor(0xf);\r\nselectmask();\r\nsetmask(0xff);\r\nwhile (height--) {\r\nfor (x = 0; x < width; x++) {\r\nrmw(dst);\r\ndst++;\r\n}\r\ndst += line_ofs;\r\n}\r\nbreak;\r\n}\r\n} else\r\nvga_8planes_fillrect(info, rect);\r\nbreak;\r\ncase FB_TYPE_PACKED_PIXELS:\r\ndefault:\r\ncfb_fillrect(info, rect);\r\nbreak;\r\n}\r\n}\r\nstatic void vga_8planes_copyarea(struct fb_info *info, const struct fb_copyarea *area)\r\n{\r\nchar oldindex = getindex();\r\nchar oldmode = setmode(0x41);\r\nchar oldop = setop(0);\r\nchar oldsr = setsr(0xf);\r\nint height, line_ofs, x;\r\nu32 sx, dx, width;\r\nchar __iomem *dest;\r\nchar __iomem *src;\r\nheight = area->height;\r\nsx = area->sx / 4;\r\ndx = area->dx / 4;\r\nwidth = area->width / 4;\r\nif (area->dy < area->sy || (area->dy == area->sy && dx < sx)) {\r\nline_ofs = info->fix.line_length - width;\r\ndest = info->screen_base + dx + area->dy * info->fix.line_length;\r\nsrc = info->screen_base + sx + area->sy * info->fix.line_length;\r\nwhile (height--) {\r\nfor (x = 0; x < width; x++) {\r\nreadb(src);\r\nwriteb(0, dest);\r\nsrc++;\r\ndest++;\r\n}\r\nsrc += line_ofs;\r\ndest += line_ofs;\r\n}\r\n} else {\r\nline_ofs = info->fix.line_length - width;\r\ndest = info->screen_base + dx + width +\r\n(area->dy + height - 1) * info->fix.line_length;\r\nsrc = info->screen_base + sx + width +\r\n(area->sy + height - 1) * info->fix.line_length;\r\nwhile (height--) {\r\nfor (x = 0; x < width; x++) {\r\n--src;\r\n--dest;\r\nreadb(src);\r\nwriteb(0, dest);\r\n}\r\nsrc -= line_ofs;\r\ndest -= line_ofs;\r\n}\r\n}\r\nsetsr(oldsr);\r\nsetop(oldop);\r\nsetmode(oldmode);\r\nsetindex(oldindex);\r\n}\r\nstatic void vga16fb_copyarea(struct fb_info *info, const struct fb_copyarea *area)\r\n{\r\nu32 dx = area->dx, dy = area->dy, sx = area->sx, sy = area->sy;\r\nint x, x2, y2, old_dx, old_dy, vxres, vyres;\r\nint height, width, line_ofs;\r\nchar __iomem *dst = NULL;\r\nchar __iomem *src = NULL;\r\nvxres = info->var.xres_virtual;\r\nvyres = info->var.yres_virtual;\r\nif (area->dx > vxres || area->sx > vxres || area->dy > vyres ||\r\narea->sy > vyres)\r\nreturn;\r\nold_dx = area->dx;\r\nold_dy = area->dy;\r\nx2 = area->dx + area->width;\r\ny2 = area->dy + area->height;\r\ndx = area->dx > 0 ? area->dx : 0;\r\ndy = area->dy > 0 ? area->dy : 0;\r\nx2 = x2 < vxres ? x2 : vxres;\r\ny2 = y2 < vyres ? y2 : vyres;\r\nwidth = x2 - dx;\r\nheight = y2 - dy;\r\nif (sx + dx < old_dx || sy + dy < old_dy)\r\nreturn;\r\nsx += (dx - old_dx);\r\nsy += (dy - old_dy);\r\nif (sx + width > vxres || sy + height > vyres)\r\nreturn;\r\nswitch (info->fix.type) {\r\ncase FB_TYPE_VGA_PLANES:\r\nif (info->fix.type_aux == FB_AUX_VGA_PLANES_VGA4) {\r\nwidth = width/8;\r\nheight = height;\r\nline_ofs = info->fix.line_length - width;\r\nsetmode(1);\r\nsetop(0);\r\nsetsr(0xf);\r\nif (dy < sy || (dy == sy && dx < sx)) {\r\ndst = info->screen_base + (dx/8) + dy * info->fix.line_length;\r\nsrc = info->screen_base + (sx/8) + sy * info->fix.line_length;\r\nwhile (height--) {\r\nfor (x = 0; x < width; x++) {\r\nreadb(src);\r\nwriteb(0, dst);\r\ndst++;\r\nsrc++;\r\n}\r\nsrc += line_ofs;\r\ndst += line_ofs;\r\n}\r\n} else {\r\ndst = info->screen_base + (dx/8) + width +\r\n(dy + height - 1) * info->fix.line_length;\r\nsrc = info->screen_base + (sx/8) + width +\r\n(sy + height - 1) * info->fix.line_length;\r\nwhile (height--) {\r\nfor (x = 0; x < width; x++) {\r\ndst--;\r\nsrc--;\r\nreadb(src);\r\nwriteb(0, dst);\r\n}\r\nsrc -= line_ofs;\r\ndst -= line_ofs;\r\n}\r\n}\r\n} else\r\nvga_8planes_copyarea(info, area);\r\nbreak;\r\ncase FB_TYPE_PACKED_PIXELS:\r\ndefault:\r\ncfb_copyarea(info, area);\r\nbreak;\r\n}\r\n}\r\nstatic void vga_8planes_imageblit(struct fb_info *info, const struct fb_image *image)\r\n{\r\nchar oldindex = getindex();\r\nchar oldmode = setmode(0x40);\r\nchar oldop = setop(0);\r\nchar oldsr = setsr(0);\r\nchar oldmask = selectmask();\r\nconst char *cdat = image->data;\r\nu32 dx = image->dx;\r\nchar __iomem *where;\r\nint y;\r\ndx /= 4;\r\nwhere = info->screen_base + dx + image->dy * info->fix.line_length;\r\nsetmask(0xff);\r\nwriteb(image->bg_color, where);\r\nreadb(where);\r\nselectmask();\r\nsetmask(image->fg_color ^ image->bg_color);\r\nsetmode(0x42);\r\nsetop(0x18);\r\nfor (y = 0; y < image->height; y++, where += info->fix.line_length)\r\nwritew(transl_h[cdat[y]&0xF] | transl_l[cdat[y] >> 4], where);\r\nsetmask(oldmask);\r\nsetsr(oldsr);\r\nsetop(oldop);\r\nsetmode(oldmode);\r\nsetindex(oldindex);\r\n}\r\nstatic void vga_imageblit_expand(struct fb_info *info, const struct fb_image *image)\r\n{\r\nchar __iomem *where = info->screen_base + (image->dx/8) +\r\nimage->dy * info->fix.line_length;\r\nstruct vga16fb_par *par = info->par;\r\nchar *cdat = (char *) image->data;\r\nchar __iomem *dst;\r\nint x, y;\r\nswitch (info->fix.type) {\r\ncase FB_TYPE_VGA_PLANES:\r\nif (info->fix.type_aux == FB_AUX_VGA_PLANES_VGA4) {\r\nif (par->isVGA) {\r\nsetmode(2);\r\nsetop(0);\r\nsetsr(0xf);\r\nsetcolor(image->fg_color);\r\nselectmask();\r\nsetmask(0xff);\r\nwriteb(image->bg_color, where);\r\nrmb();\r\nreadb(where);\r\nsetmode(3);\r\nwmb();\r\nfor (y = 0; y < image->height; y++) {\r\ndst = where;\r\nfor (x = image->width/8; x--;)\r\nwriteb(*cdat++, dst++);\r\nwhere += info->fix.line_length;\r\n}\r\nwmb();\r\n} else {\r\nsetmode(0);\r\nsetop(0);\r\nsetsr(0xf);\r\nsetcolor(image->bg_color);\r\nselectmask();\r\nsetmask(0xff);\r\nfor (y = 0; y < image->height; y++) {\r\ndst = where;\r\nfor (x=image->width/8; x--;){\r\nrmw(dst);\r\nsetcolor(image->fg_color);\r\nselectmask();\r\nif (*cdat) {\r\nsetmask(*cdat++);\r\nrmw(dst++);\r\n}\r\n}\r\nwhere += info->fix.line_length;\r\n}\r\n}\r\n} else\r\nvga_8planes_imageblit(info, image);\r\nbreak;\r\ncase FB_TYPE_PACKED_PIXELS:\r\ndefault:\r\ncfb_imageblit(info, image);\r\nbreak;\r\n}\r\n}\r\nstatic void vga_imageblit_color(struct fb_info *info, const struct fb_image *image)\r\n{\r\nstruct vga16fb_par *par = info->par;\r\nchar __iomem *where =\r\ninfo->screen_base + image->dy * info->fix.line_length +\r\nimage->dx/8;\r\nconst char *cdat = image->data;\r\nchar __iomem *dst;\r\nint x, y;\r\nswitch (info->fix.type) {\r\ncase FB_TYPE_VGA_PLANES:\r\nif (info->fix.type_aux == FB_AUX_VGA_PLANES_VGA4 &&\r\npar->isVGA) {\r\nsetsr(0xf);\r\nsetop(0);\r\nsetmode(0);\r\nfor (y = 0; y < image->height; y++) {\r\nfor (x = 0; x < image->width; x++) {\r\ndst = where + x/8;\r\nsetcolor(*cdat);\r\nselectmask();\r\nsetmask(1 << (7 - (x % 8)));\r\nfb_readb(dst);\r\nfb_writeb(0, dst);\r\ncdat++;\r\n}\r\nwhere += info->fix.line_length;\r\n}\r\n}\r\nbreak;\r\ncase FB_TYPE_PACKED_PIXELS:\r\ncfb_imageblit(info, image);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic void vga16fb_imageblit(struct fb_info *info, const struct fb_image *image)\r\n{\r\nif (image->depth == 1)\r\nvga_imageblit_expand(info, image);\r\nelse\r\nvga_imageblit_color(info, image);\r\n}\r\nstatic void vga16fb_destroy(struct fb_info *info)\r\n{\r\nstruct platform_device *dev = container_of(info->device, struct platform_device, dev);\r\niounmap(info->screen_base);\r\nfb_dealloc_cmap(&info->cmap);\r\nplatform_set_drvdata(dev, NULL);\r\nframebuffer_release(info);\r\n}\r\nstatic int __init vga16fb_setup(char *options)\r\n{\r\nchar *this_opt;\r\nif (!options || !*options)\r\nreturn 0;\r\nwhile ((this_opt = strsep(&options, ",")) != NULL) {\r\nif (!*this_opt) continue;\r\n}\r\nreturn 0;\r\n}\r\nstatic int vga16fb_probe(struct platform_device *dev)\r\n{\r\nstruct fb_info *info;\r\nstruct vga16fb_par *par;\r\nint i;\r\nint ret = 0;\r\nprintk(KERN_DEBUG "vga16fb: initializing\n");\r\ninfo = framebuffer_alloc(sizeof(struct vga16fb_par), &dev->dev);\r\nif (!info) {\r\nret = -ENOMEM;\r\ngoto err_fb_alloc;\r\n}\r\ninfo->apertures = alloc_apertures(1);\r\nif (!info->apertures) {\r\nret = -ENOMEM;\r\ngoto err_ioremap;\r\n}\r\ninfo->screen_base = (void __iomem *)VGA_MAP_MEM(VGA_FB_PHYS, 0);\r\nif (!info->screen_base) {\r\nprintk(KERN_ERR "vga16fb: unable to map device\n");\r\nret = -ENOMEM;\r\ngoto err_ioremap;\r\n}\r\nprintk(KERN_INFO "vga16fb: mapped to 0x%p\n", info->screen_base);\r\npar = info->par;\r\npar->isVGA = screen_info.orig_video_isVGA;\r\npar->palette_blanked = 0;\r\npar->vesa_blanked = 0;\r\ni = par->isVGA? 6 : 2;\r\nvga16fb_defined.red.length = i;\r\nvga16fb_defined.green.length = i;\r\nvga16fb_defined.blue.length = i;\r\ninfo->fbops = &vga16fb_ops;\r\ninfo->var = vga16fb_defined;\r\ninfo->fix = vga16fb_fix;\r\ninfo->pixmap.blit_x = 1 << 7 | 1 << 15 | 1 << 23 | 1 << 31;\r\ninfo->flags = FBINFO_FLAG_DEFAULT | FBINFO_MISC_FIRMWARE |\r\nFBINFO_HWACCEL_YPAN;\r\ni = (info->var.bits_per_pixel == 8) ? 256 : 16;\r\nret = fb_alloc_cmap(&info->cmap, i, 0);\r\nif (ret) {\r\nprintk(KERN_ERR "vga16fb: unable to allocate colormap\n");\r\nret = -ENOMEM;\r\ngoto err_alloc_cmap;\r\n}\r\nif (vga16fb_check_var(&info->var, info)) {\r\nprintk(KERN_ERR "vga16fb: unable to validate variable\n");\r\nret = -EINVAL;\r\ngoto err_check_var;\r\n}\r\nvga16fb_update_fix(info);\r\ninfo->apertures->ranges[0].base = VGA_FB_PHYS;\r\ninfo->apertures->ranges[0].size = VGA_FB_PHYS_LEN;\r\nif (register_framebuffer(info) < 0) {\r\nprintk(KERN_ERR "vga16fb: unable to register framebuffer\n");\r\nret = -EINVAL;\r\ngoto err_check_var;\r\n}\r\nprintk(KERN_INFO "fb%d: %s frame buffer device\n",\r\ninfo->node, info->fix.id);\r\nplatform_set_drvdata(dev, info);\r\nreturn 0;\r\nerr_check_var:\r\nfb_dealloc_cmap(&info->cmap);\r\nerr_alloc_cmap:\r\niounmap(info->screen_base);\r\nerr_ioremap:\r\nframebuffer_release(info);\r\nerr_fb_alloc:\r\nreturn ret;\r\n}\r\nstatic int vga16fb_remove(struct platform_device *dev)\r\n{\r\nstruct fb_info *info = platform_get_drvdata(dev);\r\nif (info)\r\nunregister_framebuffer(info);\r\nreturn 0;\r\n}\r\nstatic int __init vga16fb_init(void)\r\n{\r\nint ret;\r\n#ifndef MODULE\r\nchar *option = NULL;\r\nif (fb_get_options("vga16fb", &option))\r\nreturn -ENODEV;\r\nvga16fb_setup(option);\r\n#endif\r\nret = platform_driver_register(&vga16fb_driver);\r\nif (!ret) {\r\nvga16fb_device = platform_device_alloc("vga16fb", 0);\r\nif (vga16fb_device)\r\nret = platform_device_add(vga16fb_device);\r\nelse\r\nret = -ENOMEM;\r\nif (ret) {\r\nplatform_device_put(vga16fb_device);\r\nplatform_driver_unregister(&vga16fb_driver);\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic void __exit vga16fb_exit(void)\r\n{\r\nplatform_device_unregister(vga16fb_device);\r\nplatform_driver_unregister(&vga16fb_driver);\r\n}
