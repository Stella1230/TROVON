static int fan53555_set_suspend_voltage(struct regulator_dev *rdev, int uV)\r\n{\r\nstruct fan53555_device_info *di = rdev_get_drvdata(rdev);\r\nint ret;\r\nif (di->sleep_vol_cache == uV)\r\nreturn 0;\r\nret = regulator_map_voltage_linear(rdev, uV, uV);\r\nif (ret < 0)\r\nreturn -EINVAL;\r\nret = regmap_update_bits(di->regmap, di->sleep_reg,\r\nVSEL_NSEL_MASK, ret);\r\nif (ret < 0)\r\nreturn -EINVAL;\r\ndi->sleep_vol_cache = uV;\r\nreturn 0;\r\n}\r\nstatic int fan53555_set_mode(struct regulator_dev *rdev, unsigned int mode)\r\n{\r\nstruct fan53555_device_info *di = rdev_get_drvdata(rdev);\r\nswitch (mode) {\r\ncase REGULATOR_MODE_FAST:\r\nregmap_update_bits(di->regmap, di->vol_reg,\r\nVSEL_MODE, VSEL_MODE);\r\nbreak;\r\ncase REGULATOR_MODE_NORMAL:\r\nregmap_update_bits(di->regmap, di->vol_reg, VSEL_MODE, 0);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic unsigned int fan53555_get_mode(struct regulator_dev *rdev)\r\n{\r\nstruct fan53555_device_info *di = rdev_get_drvdata(rdev);\r\nunsigned int val;\r\nint ret = 0;\r\nret = regmap_read(di->regmap, di->vol_reg, &val);\r\nif (ret < 0)\r\nreturn ret;\r\nif (val & VSEL_MODE)\r\nreturn REGULATOR_MODE_FAST;\r\nelse\r\nreturn REGULATOR_MODE_NORMAL;\r\n}\r\nstatic int fan53555_device_setup(struct fan53555_device_info *di,\r\nstruct fan53555_platform_data *pdata)\r\n{\r\nunsigned int reg, data, mask;\r\nswitch (pdata->sleep_vsel_id) {\r\ncase FAN53555_VSEL_ID_0:\r\ndi->sleep_reg = FAN53555_VSEL0;\r\ndi->vol_reg = FAN53555_VSEL1;\r\nbreak;\r\ncase FAN53555_VSEL_ID_1:\r\ndi->sleep_reg = FAN53555_VSEL1;\r\ndi->vol_reg = FAN53555_VSEL0;\r\nbreak;\r\ndefault:\r\ndev_err(di->dev, "Invalid VSEL ID!\n");\r\nreturn -EINVAL;\r\n}\r\nswitch (di->chip_id) {\r\ncase FAN53555_CHIP_ID_00:\r\ncase FAN53555_CHIP_ID_01:\r\ncase FAN53555_CHIP_ID_03:\r\ncase FAN53555_CHIP_ID_05:\r\ndi->vsel_min = 600000;\r\ndi->vsel_step = 10000;\r\nbreak;\r\ncase FAN53555_CHIP_ID_04:\r\ndi->vsel_min = 603000;\r\ndi->vsel_step = 12826;\r\nbreak;\r\ndefault:\r\ndev_err(di->dev,\r\n"Chip ID[%d]\n not supported!\n", di->chip_id);\r\nreturn -EINVAL;\r\n}\r\nif (pdata->slew_rate & 0x7)\r\ndi->slew_rate = pdata->slew_rate;\r\nelse\r\ndi->slew_rate = FAN53555_SLEW_RATE_64MV;\r\nreg = FAN53555_CONTROL;\r\ndata = di->slew_rate << CTL_SLEW_SHIFT;\r\nmask = CTL_SLEW_MASK;\r\nreturn regmap_update_bits(di->regmap, reg, mask, data);\r\n}\r\nstatic int fan53555_regulator_register(struct fan53555_device_info *di,\r\nstruct regulator_config *config)\r\n{\r\nstruct regulator_desc *rdesc = &di->desc;\r\nrdesc->name = "fan53555-reg";\r\nrdesc->ops = &fan53555_regulator_ops;\r\nrdesc->type = REGULATOR_VOLTAGE;\r\nrdesc->n_voltages = FAN53555_NVOLTAGES;\r\nrdesc->enable_reg = di->vol_reg;\r\nrdesc->enable_mask = VSEL_BUCK_EN;\r\nrdesc->min_uV = di->vsel_min;\r\nrdesc->uV_step = di->vsel_step;\r\nrdesc->vsel_reg = di->vol_reg;\r\nrdesc->vsel_mask = VSEL_NSEL_MASK;\r\nrdesc->owner = THIS_MODULE;\r\ndi->rdev = regulator_register(&di->desc, config);\r\nif (IS_ERR(di->rdev))\r\nreturn PTR_ERR(di->rdev);\r\nreturn 0;\r\n}\r\nstatic int fan53555_regulator_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct fan53555_device_info *di;\r\nstruct fan53555_platform_data *pdata;\r\nstruct regulator_config config = { };\r\nunsigned int val;\r\nint ret;\r\npdata = client->dev.platform_data;\r\nif (!pdata || !pdata->regulator) {\r\ndev_err(&client->dev, "Platform data not found!\n");\r\nreturn -ENODEV;\r\n}\r\ndi = devm_kzalloc(&client->dev, sizeof(struct fan53555_device_info),\r\nGFP_KERNEL);\r\nif (!di) {\r\ndev_err(&client->dev, "Failed to allocate device info data!\n");\r\nreturn -ENOMEM;\r\n}\r\ndi->regmap = devm_regmap_init_i2c(client, &fan53555_regmap_config);\r\nif (IS_ERR(di->regmap)) {\r\ndev_err(&client->dev, "Failed to allocate regmap!\n");\r\nreturn PTR_ERR(di->regmap);\r\n}\r\ndi->dev = &client->dev;\r\ndi->regulator = pdata->regulator;\r\ni2c_set_clientdata(client, di);\r\nret = regmap_read(di->regmap, FAN53555_ID1, &val);\r\nif (ret < 0) {\r\ndev_err(&client->dev, "Failed to get chip ID!\n");\r\nreturn -ENODEV;\r\n}\r\ndi->chip_id = val & DIE_ID;\r\nret = regmap_read(di->regmap, FAN53555_ID2, &val);\r\nif (ret < 0) {\r\ndev_err(&client->dev, "Failed to get chip Rev!\n");\r\nreturn -ENODEV;\r\n}\r\ndi->chip_rev = val & DIE_REV;\r\ndev_info(&client->dev, "FAN53555 Option[%d] Rev[%d] Detected!\n",\r\ndi->chip_id, di->chip_rev);\r\nret = fan53555_device_setup(di, pdata);\r\nif (ret < 0) {\r\ndev_err(&client->dev, "Failed to setup device!\n");\r\nreturn ret;\r\n}\r\nconfig.dev = di->dev;\r\nconfig.init_data = di->regulator;\r\nconfig.regmap = di->regmap;\r\nconfig.driver_data = di;\r\nret = fan53555_regulator_register(di, &config);\r\nif (ret < 0)\r\ndev_err(&client->dev, "Failed to register regulator!\n");\r\nreturn ret;\r\n}\r\nstatic int fan53555_regulator_remove(struct i2c_client *client)\r\n{\r\nstruct fan53555_device_info *di = i2c_get_clientdata(client);\r\nregulator_unregister(di->rdev);\r\nreturn 0;\r\n}
