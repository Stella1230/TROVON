static uint list_size(struct list_head *list)\r\n{\r\nstruct list_head *tmp;\r\nuint count = 0;\r\nlist_for_each(tmp, list) {\r\ncount++;\r\n}\r\nreturn count;\r\n}\r\nstatic void hdpvr_read_bulk_callback(struct urb *urb)\r\n{\r\nstruct hdpvr_buffer *buf = (struct hdpvr_buffer *)urb->context;\r\nstruct hdpvr_device *dev = buf->dev;\r\nbuf->status = BUFSTAT_READY;\r\nwake_up_interruptible(&dev->wait_data);\r\n}\r\nint hdpvr_cancel_queue(struct hdpvr_device *dev)\r\n{\r\nstruct hdpvr_buffer *buf;\r\nlist_for_each_entry(buf, &dev->rec_buff_list, buff_list) {\r\nusb_kill_urb(buf->urb);\r\nbuf->status = BUFSTAT_AVAILABLE;\r\n}\r\nlist_splice_init(&dev->rec_buff_list, dev->free_buff_list.prev);\r\nreturn 0;\r\n}\r\nstatic int hdpvr_free_queue(struct list_head *q)\r\n{\r\nstruct list_head *tmp;\r\nstruct list_head *p;\r\nstruct hdpvr_buffer *buf;\r\nstruct urb *urb;\r\nfor (p = q->next; p != q;) {\r\nbuf = list_entry(p, struct hdpvr_buffer, buff_list);\r\nurb = buf->urb;\r\nusb_free_coherent(urb->dev, urb->transfer_buffer_length,\r\nurb->transfer_buffer, urb->transfer_dma);\r\nusb_free_urb(urb);\r\ntmp = p->next;\r\nlist_del(p);\r\nkfree(buf);\r\np = tmp;\r\n}\r\nreturn 0;\r\n}\r\nint hdpvr_free_buffers(struct hdpvr_device *dev)\r\n{\r\nhdpvr_cancel_queue(dev);\r\nhdpvr_free_queue(&dev->free_buff_list);\r\nhdpvr_free_queue(&dev->rec_buff_list);\r\nreturn 0;\r\n}\r\nint hdpvr_alloc_buffers(struct hdpvr_device *dev, uint count)\r\n{\r\nuint i;\r\nint retval = -ENOMEM;\r\nu8 *mem;\r\nstruct hdpvr_buffer *buf;\r\nstruct urb *urb;\r\nv4l2_dbg(MSG_INFO, hdpvr_debug, &dev->v4l2_dev,\r\n"allocating %u buffers\n", count);\r\nfor (i = 0; i < count; i++) {\r\nbuf = kzalloc(sizeof(struct hdpvr_buffer), GFP_KERNEL);\r\nif (!buf) {\r\nv4l2_err(&dev->v4l2_dev, "cannot allocate buffer\n");\r\ngoto exit;\r\n}\r\nbuf->dev = dev;\r\nurb = usb_alloc_urb(0, GFP_KERNEL);\r\nif (!urb) {\r\nv4l2_err(&dev->v4l2_dev, "cannot allocate urb\n");\r\ngoto exit_urb;\r\n}\r\nbuf->urb = urb;\r\nmem = usb_alloc_coherent(dev->udev, dev->bulk_in_size, GFP_KERNEL,\r\n&urb->transfer_dma);\r\nif (!mem) {\r\nv4l2_err(&dev->v4l2_dev,\r\n"cannot allocate usb transfer buffer\n");\r\ngoto exit_urb_buffer;\r\n}\r\nusb_fill_bulk_urb(buf->urb, dev->udev,\r\nusb_rcvbulkpipe(dev->udev,\r\ndev->bulk_in_endpointAddr),\r\nmem, dev->bulk_in_size,\r\nhdpvr_read_bulk_callback, buf);\r\nbuf->urb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\r\nbuf->status = BUFSTAT_AVAILABLE;\r\nlist_add_tail(&buf->buff_list, &dev->free_buff_list);\r\n}\r\nreturn 0;\r\nexit_urb_buffer:\r\nusb_free_urb(urb);\r\nexit_urb:\r\nkfree(buf);\r\nexit:\r\nhdpvr_free_buffers(dev);\r\nreturn retval;\r\n}\r\nstatic int hdpvr_submit_buffers(struct hdpvr_device *dev)\r\n{\r\nstruct hdpvr_buffer *buf;\r\nstruct urb *urb;\r\nint ret = 0, err_count = 0;\r\nmutex_lock(&dev->io_mutex);\r\nwhile (dev->status == STATUS_STREAMING &&\r\n!list_empty(&dev->free_buff_list)) {\r\nbuf = list_entry(dev->free_buff_list.next, struct hdpvr_buffer,\r\nbuff_list);\r\nif (buf->status != BUFSTAT_AVAILABLE) {\r\nv4l2_err(&dev->v4l2_dev,\r\n"buffer not marked as available\n");\r\nret = -EFAULT;\r\ngoto err;\r\n}\r\nurb = buf->urb;\r\nurb->status = 0;\r\nurb->actual_length = 0;\r\nret = usb_submit_urb(urb, GFP_KERNEL);\r\nif (ret) {\r\nv4l2_err(&dev->v4l2_dev,\r\n"usb_submit_urb in %s returned %d\n",\r\n__func__, ret);\r\nif (++err_count > 2)\r\nbreak;\r\ncontinue;\r\n}\r\nbuf->status = BUFSTAT_INPROGRESS;\r\nlist_move_tail(&buf->buff_list, &dev->rec_buff_list);\r\n}\r\nerr:\r\nprint_buffer_status();\r\nmutex_unlock(&dev->io_mutex);\r\nreturn ret;\r\n}\r\nstatic struct hdpvr_buffer *hdpvr_get_next_buffer(struct hdpvr_device *dev)\r\n{\r\nstruct hdpvr_buffer *buf;\r\nmutex_lock(&dev->io_mutex);\r\nif (list_empty(&dev->rec_buff_list)) {\r\nmutex_unlock(&dev->io_mutex);\r\nreturn NULL;\r\n}\r\nbuf = list_entry(dev->rec_buff_list.next, struct hdpvr_buffer,\r\nbuff_list);\r\nmutex_unlock(&dev->io_mutex);\r\nreturn buf;\r\n}\r\nstatic void hdpvr_transmit_buffers(struct work_struct *work)\r\n{\r\nstruct hdpvr_device *dev = container_of(work, struct hdpvr_device,\r\nworker);\r\nwhile (dev->status == STATUS_STREAMING) {\r\nif (hdpvr_submit_buffers(dev)) {\r\nv4l2_err(&dev->v4l2_dev, "couldn't submit buffers\n");\r\ngoto error;\r\n}\r\nif (wait_event_interruptible(dev->wait_buffer,\r\n!list_empty(&dev->free_buff_list) ||\r\ndev->status != STATUS_STREAMING))\r\ngoto error;\r\n}\r\nv4l2_dbg(MSG_INFO, hdpvr_debug, &dev->v4l2_dev,\r\n"transmit worker exited\n");\r\nreturn;\r\nerror:\r\nv4l2_dbg(MSG_INFO, hdpvr_debug, &dev->v4l2_dev,\r\n"transmit buffers errored\n");\r\ndev->status = STATUS_ERROR;\r\n}\r\nstatic int hdpvr_start_streaming(struct hdpvr_device *dev)\r\n{\r\nint ret;\r\nstruct hdpvr_video_info *vidinf;\r\nif (dev->status == STATUS_STREAMING)\r\nreturn 0;\r\nelse if (dev->status != STATUS_IDLE)\r\nreturn -EAGAIN;\r\nvidinf = get_video_info(dev);\r\nif (vidinf) {\r\nv4l2_dbg(MSG_BUFFER, hdpvr_debug, &dev->v4l2_dev,\r\n"video signal: %dx%d@%dhz\n", vidinf->width,\r\nvidinf->height, vidinf->fps);\r\nkfree(vidinf);\r\nret = usb_control_msg(dev->udev,\r\nusb_sndctrlpipe(dev->udev, 0),\r\n0xb8, 0x38, 0x1, 0, NULL, 0, 8000);\r\nv4l2_dbg(MSG_BUFFER, hdpvr_debug, &dev->v4l2_dev,\r\n"encoder start control request returned %d\n", ret);\r\nhdpvr_config_call(dev, CTRL_START_STREAMING_VALUE, 0x00);\r\ndev->status = STATUS_STREAMING;\r\nINIT_WORK(&dev->worker, hdpvr_transmit_buffers);\r\nqueue_work(dev->workqueue, &dev->worker);\r\nv4l2_dbg(MSG_BUFFER, hdpvr_debug, &dev->v4l2_dev,\r\n"streaming started\n");\r\nreturn 0;\r\n}\r\nmsleep(250);\r\nv4l2_dbg(MSG_INFO, hdpvr_debug, &dev->v4l2_dev,\r\n"no video signal at input %d\n", dev->options.video_input);\r\nreturn -EAGAIN;\r\n}\r\nstatic int hdpvr_stop_streaming(struct hdpvr_device *dev)\r\n{\r\nint actual_length;\r\nuint c = 0;\r\nu8 *buf;\r\nif (dev->status == STATUS_IDLE)\r\nreturn 0;\r\nelse if (dev->status != STATUS_STREAMING)\r\nreturn -EAGAIN;\r\nbuf = kmalloc(dev->bulk_in_size, GFP_KERNEL);\r\nif (!buf)\r\nv4l2_err(&dev->v4l2_dev, "failed to allocate temporary buffer "\r\n"for emptying the internal device buffer. "\r\n"Next capture start will be slow\n");\r\ndev->status = STATUS_SHUTTING_DOWN;\r\nhdpvr_config_call(dev, CTRL_STOP_STREAMING_VALUE, 0x00);\r\nmutex_unlock(&dev->io_mutex);\r\nwake_up_interruptible(&dev->wait_buffer);\r\nmsleep(50);\r\nflush_workqueue(dev->workqueue);\r\nmutex_lock(&dev->io_mutex);\r\nhdpvr_cancel_queue(dev);\r\nwhile (buf && ++c < 500 &&\r\n!usb_bulk_msg(dev->udev,\r\nusb_rcvbulkpipe(dev->udev,\r\ndev->bulk_in_endpointAddr),\r\nbuf, dev->bulk_in_size, &actual_length,\r\nBULK_URB_TIMEOUT)) {\r\nv4l2_dbg(MSG_BUFFER, hdpvr_debug, &dev->v4l2_dev,\r\n"%2d: got %d bytes\n", c, actual_length);\r\n}\r\nkfree(buf);\r\nv4l2_dbg(MSG_BUFFER, hdpvr_debug, &dev->v4l2_dev,\r\n"used %d urbs to empty device buffers\n", c-1);\r\nmsleep(10);\r\ndev->status = STATUS_IDLE;\r\nreturn 0;\r\n}\r\nstatic int hdpvr_open(struct file *file)\r\n{\r\nstruct hdpvr_device *dev;\r\nstruct hdpvr_fh *fh;\r\nint retval = -ENOMEM;\r\ndev = (struct hdpvr_device *)video_get_drvdata(video_devdata(file));\r\nif (!dev) {\r\npr_err("open failing with with ENODEV\n");\r\nretval = -ENODEV;\r\ngoto err;\r\n}\r\nfh = kzalloc(sizeof(struct hdpvr_fh), GFP_KERNEL);\r\nif (!fh) {\r\nv4l2_err(&dev->v4l2_dev, "Out of memory\n");\r\ngoto err;\r\n}\r\nmutex_lock(&dev->io_mutex);\r\ndev->open_count++;\r\nmutex_unlock(&dev->io_mutex);\r\nfh->dev = dev;\r\nfile->private_data = fh;\r\nretval = 0;\r\nerr:\r\nreturn retval;\r\n}\r\nstatic int hdpvr_release(struct file *file)\r\n{\r\nstruct hdpvr_fh *fh = file->private_data;\r\nstruct hdpvr_device *dev = fh->dev;\r\nif (!dev)\r\nreturn -ENODEV;\r\nmutex_lock(&dev->io_mutex);\r\nif (!(--dev->open_count) && dev->status == STATUS_STREAMING)\r\nhdpvr_stop_streaming(dev);\r\nmutex_unlock(&dev->io_mutex);\r\nreturn 0;\r\n}\r\nstatic ssize_t hdpvr_read(struct file *file, char __user *buffer, size_t count,\r\nloff_t *pos)\r\n{\r\nstruct hdpvr_fh *fh = file->private_data;\r\nstruct hdpvr_device *dev = fh->dev;\r\nstruct hdpvr_buffer *buf = NULL;\r\nstruct urb *urb;\r\nunsigned int ret = 0;\r\nint rem, cnt;\r\nif (*pos)\r\nreturn -ESPIPE;\r\nif (!dev)\r\nreturn -ENODEV;\r\nmutex_lock(&dev->io_mutex);\r\nif (dev->status == STATUS_IDLE) {\r\nif (hdpvr_start_streaming(dev)) {\r\nv4l2_dbg(MSG_INFO, hdpvr_debug, &dev->v4l2_dev,\r\n"start_streaming failed\n");\r\nret = -EIO;\r\nmsleep(200);\r\ndev->status = STATUS_IDLE;\r\nmutex_unlock(&dev->io_mutex);\r\ngoto err;\r\n}\r\nprint_buffer_status();\r\n}\r\nmutex_unlock(&dev->io_mutex);\r\nif (!(file->f_flags & O_NONBLOCK)) {\r\nif (wait_event_interruptible(dev->wait_data,\r\nhdpvr_get_next_buffer(dev)))\r\nreturn -ERESTARTSYS;\r\n}\r\nbuf = hdpvr_get_next_buffer(dev);\r\nwhile (count > 0 && buf) {\r\nif (buf->status != BUFSTAT_READY &&\r\ndev->status != STATUS_DISCONNECTED) {\r\nif (file->f_flags & O_NONBLOCK) {\r\nif (!ret)\r\nret = -EAGAIN;\r\ngoto err;\r\n}\r\nif (wait_event_interruptible(dev->wait_data,\r\nbuf->status == BUFSTAT_READY)) {\r\nret = -ERESTARTSYS;\r\ngoto err;\r\n}\r\n}\r\nif (buf->status != BUFSTAT_READY)\r\nbreak;\r\nurb = buf->urb;\r\nrem = urb->actual_length - buf->pos;\r\ncnt = rem > count ? count : rem;\r\nif (copy_to_user(buffer, urb->transfer_buffer + buf->pos,\r\ncnt)) {\r\nv4l2_err(&dev->v4l2_dev, "read: copy_to_user failed\n");\r\nif (!ret)\r\nret = -EFAULT;\r\ngoto err;\r\n}\r\nbuf->pos += cnt;\r\ncount -= cnt;\r\nbuffer += cnt;\r\nret += cnt;\r\nif (buf->pos == urb->actual_length) {\r\nmutex_lock(&dev->io_mutex);\r\nbuf->pos = 0;\r\nbuf->status = BUFSTAT_AVAILABLE;\r\nlist_move_tail(&buf->buff_list, &dev->free_buff_list);\r\nprint_buffer_status();\r\nmutex_unlock(&dev->io_mutex);\r\nwake_up_interruptible(&dev->wait_buffer);\r\nbuf = hdpvr_get_next_buffer(dev);\r\n}\r\n}\r\nerr:\r\nif (!ret && !buf)\r\nret = -EAGAIN;\r\nreturn ret;\r\n}\r\nstatic unsigned int hdpvr_poll(struct file *filp, poll_table *wait)\r\n{\r\nstruct hdpvr_buffer *buf = NULL;\r\nstruct hdpvr_fh *fh = filp->private_data;\r\nstruct hdpvr_device *dev = fh->dev;\r\nunsigned int mask = 0;\r\nmutex_lock(&dev->io_mutex);\r\nif (!video_is_registered(dev->video_dev)) {\r\nmutex_unlock(&dev->io_mutex);\r\nreturn -EIO;\r\n}\r\nif (dev->status == STATUS_IDLE) {\r\nif (hdpvr_start_streaming(dev)) {\r\nv4l2_dbg(MSG_BUFFER, hdpvr_debug, &dev->v4l2_dev,\r\n"start_streaming failed\n");\r\ndev->status = STATUS_IDLE;\r\n}\r\nprint_buffer_status();\r\n}\r\nmutex_unlock(&dev->io_mutex);\r\nbuf = hdpvr_get_next_buffer(dev);\r\nif (!buf || buf->status != BUFSTAT_READY) {\r\npoll_wait(filp, &dev->wait_data, wait);\r\nbuf = hdpvr_get_next_buffer(dev);\r\n}\r\nif (buf && buf->status == BUFSTAT_READY)\r\nmask |= POLLIN | POLLRDNORM;\r\nreturn mask;\r\n}\r\nstatic int vidioc_querycap(struct file *file, void *priv,\r\nstruct v4l2_capability *cap)\r\n{\r\nstruct hdpvr_device *dev = video_drvdata(file);\r\nstrcpy(cap->driver, "hdpvr");\r\nstrcpy(cap->card, "Hauppauge HD PVR");\r\nusb_make_path(dev->udev, cap->bus_info, sizeof(cap->bus_info));\r\ncap->capabilities = V4L2_CAP_VIDEO_CAPTURE |\r\nV4L2_CAP_AUDIO |\r\nV4L2_CAP_READWRITE;\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_std(struct file *file, void *private_data,\r\nv4l2_std_id *std)\r\n{\r\nstruct hdpvr_fh *fh = file->private_data;\r\nstruct hdpvr_device *dev = fh->dev;\r\nu8 std_type = 1;\r\nif (*std & (V4L2_STD_NTSC | V4L2_STD_PAL_60))\r\nstd_type = 0;\r\nreturn hdpvr_config_call(dev, CTRL_VIDEO_STD_TYPE, std_type);\r\n}\r\nstatic int vidioc_enum_input(struct file *file, void *priv,\r\nstruct v4l2_input *i)\r\n{\r\nstruct hdpvr_fh *fh = file->private_data;\r\nstruct hdpvr_device *dev = fh->dev;\r\nunsigned int n;\r\nn = i->index;\r\nif (n >= HDPVR_VIDEO_INPUTS)\r\nreturn -EINVAL;\r\ni->type = V4L2_INPUT_TYPE_CAMERA;\r\nstrncpy(i->name, iname[n], sizeof(i->name) - 1);\r\ni->name[sizeof(i->name) - 1] = '\0';\r\ni->audioset = 1<<HDPVR_RCA_FRONT | 1<<HDPVR_RCA_BACK | 1<<HDPVR_SPDIF;\r\ni->std = dev->video_dev->tvnorms;\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_input(struct file *file, void *private_data,\r\nunsigned int index)\r\n{\r\nstruct hdpvr_fh *fh = file->private_data;\r\nstruct hdpvr_device *dev = fh->dev;\r\nint retval;\r\nif (index >= HDPVR_VIDEO_INPUTS)\r\nreturn -EINVAL;\r\nif (dev->status != STATUS_IDLE)\r\nreturn -EAGAIN;\r\nretval = hdpvr_config_call(dev, CTRL_VIDEO_INPUT_VALUE, index+1);\r\nif (!retval)\r\ndev->options.video_input = index;\r\nreturn retval;\r\n}\r\nstatic int vidioc_g_input(struct file *file, void *private_data,\r\nunsigned int *index)\r\n{\r\nstruct hdpvr_fh *fh = file->private_data;\r\nstruct hdpvr_device *dev = fh->dev;\r\n*index = dev->options.video_input;\r\nreturn 0;\r\n}\r\nstatic int vidioc_enumaudio(struct file *file, void *priv,\r\nstruct v4l2_audio *audio)\r\n{\r\nunsigned int n;\r\nn = audio->index;\r\nif (n >= HDPVR_AUDIO_INPUTS)\r\nreturn -EINVAL;\r\naudio->capability = V4L2_AUDCAP_STEREO;\r\nstrncpy(audio->name, audio_iname[n], sizeof(audio->name) - 1);\r\naudio->name[sizeof(audio->name) - 1] = '\0';\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_audio(struct file *file, void *private_data,\r\nconst struct v4l2_audio *audio)\r\n{\r\nstruct hdpvr_fh *fh = file->private_data;\r\nstruct hdpvr_device *dev = fh->dev;\r\nint retval;\r\nif (audio->index >= HDPVR_AUDIO_INPUTS)\r\nreturn -EINVAL;\r\nif (dev->status != STATUS_IDLE)\r\nreturn -EAGAIN;\r\nretval = hdpvr_set_audio(dev, audio->index+1, dev->options.audio_codec);\r\nif (!retval)\r\ndev->options.audio_input = audio->index;\r\nreturn retval;\r\n}\r\nstatic int vidioc_g_audio(struct file *file, void *private_data,\r\nstruct v4l2_audio *audio)\r\n{\r\nstruct hdpvr_fh *fh = file->private_data;\r\nstruct hdpvr_device *dev = fh->dev;\r\naudio->index = dev->options.audio_input;\r\naudio->capability = V4L2_AUDCAP_STEREO;\r\nstrncpy(audio->name, audio_iname[audio->index], sizeof(audio->name));\r\naudio->name[sizeof(audio->name) - 1] = '\0';\r\nreturn 0;\r\n}\r\nstatic int fill_queryctrl(struct hdpvr_options *opt, struct v4l2_queryctrl *qc,\r\nint ac3, int fw_ver)\r\n{\r\nint err;\r\nif (fw_ver > 0x15) {\r\nswitch (qc->id) {\r\ncase V4L2_CID_BRIGHTNESS:\r\nreturn v4l2_ctrl_query_fill(qc, 0x0, 0xff, 1, 0x80);\r\ncase V4L2_CID_CONTRAST:\r\nreturn v4l2_ctrl_query_fill(qc, 0x0, 0xff, 1, 0x40);\r\ncase V4L2_CID_SATURATION:\r\nreturn v4l2_ctrl_query_fill(qc, 0x0, 0xff, 1, 0x40);\r\ncase V4L2_CID_HUE:\r\nreturn v4l2_ctrl_query_fill(qc, 0x0, 0x1e, 1, 0xf);\r\ncase V4L2_CID_SHARPNESS:\r\nreturn v4l2_ctrl_query_fill(qc, 0x0, 0xff, 1, 0x80);\r\n}\r\n} else {\r\nswitch (qc->id) {\r\ncase V4L2_CID_BRIGHTNESS:\r\nreturn v4l2_ctrl_query_fill(qc, 0x0, 0xff, 1, 0x86);\r\ncase V4L2_CID_CONTRAST:\r\nreturn v4l2_ctrl_query_fill(qc, 0x0, 0xff, 1, 0x80);\r\ncase V4L2_CID_SATURATION:\r\nreturn v4l2_ctrl_query_fill(qc, 0x0, 0xff, 1, 0x80);\r\ncase V4L2_CID_HUE:\r\nreturn v4l2_ctrl_query_fill(qc, 0x0, 0xff, 1, 0x80);\r\ncase V4L2_CID_SHARPNESS:\r\nreturn v4l2_ctrl_query_fill(qc, 0x0, 0xff, 1, 0x80);\r\n}\r\n}\r\nswitch (qc->id) {\r\ncase V4L2_CID_MPEG_AUDIO_ENCODING:\r\nreturn v4l2_ctrl_query_fill(\r\nqc, V4L2_MPEG_AUDIO_ENCODING_AAC,\r\nac3 ? V4L2_MPEG_AUDIO_ENCODING_AC3\r\n: V4L2_MPEG_AUDIO_ENCODING_AAC,\r\n1, V4L2_MPEG_AUDIO_ENCODING_AAC);\r\ncase V4L2_CID_MPEG_VIDEO_ENCODING:\r\nreturn v4l2_ctrl_query_fill(\r\nqc, V4L2_MPEG_VIDEO_ENCODING_MPEG_4_AVC,\r\nV4L2_MPEG_VIDEO_ENCODING_MPEG_4_AVC, 1,\r\nV4L2_MPEG_VIDEO_ENCODING_MPEG_4_AVC);\r\ncase V4L2_CID_MPEG_VIDEO_BITRATE_MODE:\r\nreturn v4l2_ctrl_query_fill(\r\nqc, V4L2_MPEG_VIDEO_BITRATE_MODE_VBR,\r\nV4L2_MPEG_VIDEO_BITRATE_MODE_CBR, 1,\r\nV4L2_MPEG_VIDEO_BITRATE_MODE_CBR);\r\ncase V4L2_CID_MPEG_VIDEO_BITRATE:\r\nreturn v4l2_ctrl_query_fill(qc, 1000000, 13500000, 100000,\r\n6500000);\r\ncase V4L2_CID_MPEG_VIDEO_BITRATE_PEAK:\r\nerr = v4l2_ctrl_query_fill(qc, 1100000, 20200000, 100000,\r\n9000000);\r\nif (!err && opt->bitrate_mode == HDPVR_CONSTANT)\r\nqc->flags |= V4L2_CTRL_FLAG_INACTIVE;\r\nreturn err;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic int vidioc_queryctrl(struct file *file, void *private_data,\r\nstruct v4l2_queryctrl *qc)\r\n{\r\nstruct hdpvr_fh *fh = file->private_data;\r\nstruct hdpvr_device *dev = fh->dev;\r\nint i, next;\r\nu32 id = qc->id;\r\nmemset(qc, 0, sizeof(*qc));\r\nnext = !!(id & V4L2_CTRL_FLAG_NEXT_CTRL);\r\nqc->id = id & ~V4L2_CTRL_FLAG_NEXT_CTRL;\r\nfor (i = 0; i < ARRAY_SIZE(supported_v4l2_ctrls); i++) {\r\nif (next) {\r\nif (qc->id < supported_v4l2_ctrls[i])\r\nqc->id = supported_v4l2_ctrls[i];\r\nelse\r\ncontinue;\r\n}\r\nif (qc->id == supported_v4l2_ctrls[i])\r\nreturn fill_queryctrl(&dev->options, qc,\r\ndev->flags & HDPVR_FLAG_AC3_CAP,\r\ndev->fw_ver);\r\nif (qc->id < supported_v4l2_ctrls[i])\r\nbreak;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int vidioc_g_ctrl(struct file *file, void *private_data,\r\nstruct v4l2_control *ctrl)\r\n{\r\nstruct hdpvr_fh *fh = file->private_data;\r\nstruct hdpvr_device *dev = fh->dev;\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_BRIGHTNESS:\r\nctrl->value = dev->options.brightness;\r\nbreak;\r\ncase V4L2_CID_CONTRAST:\r\nctrl->value = dev->options.contrast;\r\nbreak;\r\ncase V4L2_CID_SATURATION:\r\nctrl->value = dev->options.saturation;\r\nbreak;\r\ncase V4L2_CID_HUE:\r\nctrl->value = dev->options.hue;\r\nbreak;\r\ncase V4L2_CID_SHARPNESS:\r\nctrl->value = dev->options.sharpness;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_ctrl(struct file *file, void *private_data,\r\nstruct v4l2_control *ctrl)\r\n{\r\nstruct hdpvr_fh *fh = file->private_data;\r\nstruct hdpvr_device *dev = fh->dev;\r\nint retval;\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_BRIGHTNESS:\r\nretval = hdpvr_config_call(dev, CTRL_BRIGHTNESS, ctrl->value);\r\nif (!retval)\r\ndev->options.brightness = ctrl->value;\r\nbreak;\r\ncase V4L2_CID_CONTRAST:\r\nretval = hdpvr_config_call(dev, CTRL_CONTRAST, ctrl->value);\r\nif (!retval)\r\ndev->options.contrast = ctrl->value;\r\nbreak;\r\ncase V4L2_CID_SATURATION:\r\nretval = hdpvr_config_call(dev, CTRL_SATURATION, ctrl->value);\r\nif (!retval)\r\ndev->options.saturation = ctrl->value;\r\nbreak;\r\ncase V4L2_CID_HUE:\r\nretval = hdpvr_config_call(dev, CTRL_HUE, ctrl->value);\r\nif (!retval)\r\ndev->options.hue = ctrl->value;\r\nbreak;\r\ncase V4L2_CID_SHARPNESS:\r\nretval = hdpvr_config_call(dev, CTRL_SHARPNESS, ctrl->value);\r\nif (!retval)\r\ndev->options.sharpness = ctrl->value;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn retval;\r\n}\r\nstatic int hdpvr_get_ctrl(struct hdpvr_options *opt,\r\nstruct v4l2_ext_control *ctrl)\r\n{\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_MPEG_AUDIO_ENCODING:\r\nctrl->value = opt->audio_codec;\r\nbreak;\r\ncase V4L2_CID_MPEG_VIDEO_ENCODING:\r\nctrl->value = V4L2_MPEG_VIDEO_ENCODING_MPEG_4_AVC;\r\nbreak;\r\ncase V4L2_CID_MPEG_VIDEO_BITRATE_MODE:\r\nctrl->value = opt->bitrate_mode == HDPVR_CONSTANT\r\n? V4L2_MPEG_VIDEO_BITRATE_MODE_CBR\r\n: V4L2_MPEG_VIDEO_BITRATE_MODE_VBR;\r\nbreak;\r\ncase V4L2_CID_MPEG_VIDEO_BITRATE:\r\nctrl->value = opt->bitrate * 100000;\r\nbreak;\r\ncase V4L2_CID_MPEG_VIDEO_BITRATE_PEAK:\r\nctrl->value = opt->peak_bitrate * 100000;\r\nbreak;\r\ncase V4L2_CID_MPEG_STREAM_TYPE:\r\nctrl->value = V4L2_MPEG_STREAM_TYPE_MPEG2_TS;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int vidioc_g_ext_ctrls(struct file *file, void *priv,\r\nstruct v4l2_ext_controls *ctrls)\r\n{\r\nstruct hdpvr_fh *fh = file->private_data;\r\nstruct hdpvr_device *dev = fh->dev;\r\nint i, err = 0;\r\nif (ctrls->ctrl_class == V4L2_CTRL_CLASS_MPEG) {\r\nfor (i = 0; i < ctrls->count; i++) {\r\nstruct v4l2_ext_control *ctrl = ctrls->controls + i;\r\nerr = hdpvr_get_ctrl(&dev->options, ctrl);\r\nif (err) {\r\nctrls->error_idx = i;\r\nbreak;\r\n}\r\n}\r\nreturn err;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int hdpvr_try_ctrl(struct v4l2_ext_control *ctrl, int ac3)\r\n{\r\nint ret = -EINVAL;\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_MPEG_AUDIO_ENCODING:\r\nif (ctrl->value == V4L2_MPEG_AUDIO_ENCODING_AAC ||\r\n(ac3 && ctrl->value == V4L2_MPEG_AUDIO_ENCODING_AC3))\r\nret = 0;\r\nbreak;\r\ncase V4L2_CID_MPEG_VIDEO_ENCODING:\r\nif (ctrl->value == V4L2_MPEG_VIDEO_ENCODING_MPEG_4_AVC)\r\nret = 0;\r\nbreak;\r\ncase V4L2_CID_MPEG_VIDEO_BITRATE_MODE:\r\nif (ctrl->value == V4L2_MPEG_VIDEO_BITRATE_MODE_CBR ||\r\nctrl->value == V4L2_MPEG_VIDEO_BITRATE_MODE_VBR)\r\nret = 0;\r\nbreak;\r\ncase V4L2_CID_MPEG_VIDEO_BITRATE:\r\n{\r\nuint bitrate = ctrl->value / 100000;\r\nif (bitrate >= 10 && bitrate <= 135)\r\nret = 0;\r\nbreak;\r\n}\r\ncase V4L2_CID_MPEG_VIDEO_BITRATE_PEAK:\r\n{\r\nuint peak_bitrate = ctrl->value / 100000;\r\nif (peak_bitrate >= 10 && peak_bitrate <= 202)\r\nret = 0;\r\nbreak;\r\n}\r\ncase V4L2_CID_MPEG_STREAM_TYPE:\r\nif (ctrl->value == V4L2_MPEG_STREAM_TYPE_MPEG2_TS)\r\nret = 0;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn ret;\r\n}\r\nstatic int vidioc_try_ext_ctrls(struct file *file, void *priv,\r\nstruct v4l2_ext_controls *ctrls)\r\n{\r\nstruct hdpvr_fh *fh = file->private_data;\r\nstruct hdpvr_device *dev = fh->dev;\r\nint i, err = 0;\r\nif (ctrls->ctrl_class == V4L2_CTRL_CLASS_MPEG) {\r\nfor (i = 0; i < ctrls->count; i++) {\r\nstruct v4l2_ext_control *ctrl = ctrls->controls + i;\r\nerr = hdpvr_try_ctrl(ctrl,\r\ndev->flags & HDPVR_FLAG_AC3_CAP);\r\nif (err) {\r\nctrls->error_idx = i;\r\nbreak;\r\n}\r\n}\r\nreturn err;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int hdpvr_set_ctrl(struct hdpvr_device *dev,\r\nstruct v4l2_ext_control *ctrl)\r\n{\r\nstruct hdpvr_options *opt = &dev->options;\r\nint ret = 0;\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_MPEG_AUDIO_ENCODING:\r\nif (dev->flags & HDPVR_FLAG_AC3_CAP) {\r\nopt->audio_codec = ctrl->value;\r\nret = hdpvr_set_audio(dev, opt->audio_input,\r\nopt->audio_codec);\r\n}\r\nbreak;\r\ncase V4L2_CID_MPEG_VIDEO_ENCODING:\r\nbreak;\r\ncase V4L2_CID_MPEG_VIDEO_BITRATE_MODE:\r\nif (ctrl->value == V4L2_MPEG_VIDEO_BITRATE_MODE_CBR &&\r\nopt->bitrate_mode != HDPVR_CONSTANT) {\r\nopt->bitrate_mode = HDPVR_CONSTANT;\r\nhdpvr_config_call(dev, CTRL_BITRATE_MODE_VALUE,\r\nopt->bitrate_mode);\r\n}\r\nif (ctrl->value == V4L2_MPEG_VIDEO_BITRATE_MODE_VBR &&\r\nopt->bitrate_mode == HDPVR_CONSTANT) {\r\nopt->bitrate_mode = HDPVR_VARIABLE_AVERAGE;\r\nhdpvr_config_call(dev, CTRL_BITRATE_MODE_VALUE,\r\nopt->bitrate_mode);\r\n}\r\nbreak;\r\ncase V4L2_CID_MPEG_VIDEO_BITRATE: {\r\nuint bitrate = ctrl->value / 100000;\r\nopt->bitrate = bitrate;\r\nif (bitrate >= opt->peak_bitrate)\r\nopt->peak_bitrate = bitrate+1;\r\nhdpvr_set_bitrate(dev);\r\nbreak;\r\n}\r\ncase V4L2_CID_MPEG_VIDEO_BITRATE_PEAK: {\r\nuint peak_bitrate = ctrl->value / 100000;\r\nif (opt->bitrate_mode == HDPVR_CONSTANT)\r\nbreak;\r\nif (opt->bitrate < peak_bitrate) {\r\nopt->peak_bitrate = peak_bitrate;\r\nhdpvr_set_bitrate(dev);\r\n} else\r\nret = -EINVAL;\r\nbreak;\r\n}\r\ncase V4L2_CID_MPEG_STREAM_TYPE:\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn ret;\r\n}\r\nstatic int vidioc_s_ext_ctrls(struct file *file, void *priv,\r\nstruct v4l2_ext_controls *ctrls)\r\n{\r\nstruct hdpvr_fh *fh = file->private_data;\r\nstruct hdpvr_device *dev = fh->dev;\r\nint i, err = 0;\r\nif (ctrls->ctrl_class == V4L2_CTRL_CLASS_MPEG) {\r\nfor (i = 0; i < ctrls->count; i++) {\r\nstruct v4l2_ext_control *ctrl = ctrls->controls + i;\r\nerr = hdpvr_try_ctrl(ctrl,\r\ndev->flags & HDPVR_FLAG_AC3_CAP);\r\nif (err) {\r\nctrls->error_idx = i;\r\nbreak;\r\n}\r\nerr = hdpvr_set_ctrl(dev, ctrl);\r\nif (err) {\r\nctrls->error_idx = i;\r\nbreak;\r\n}\r\n}\r\nreturn err;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int vidioc_enum_fmt_vid_cap(struct file *file, void *private_data,\r\nstruct v4l2_fmtdesc *f)\r\n{\r\nif (f->index != 0 || f->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)\r\nreturn -EINVAL;\r\nf->flags = V4L2_FMT_FLAG_COMPRESSED;\r\nstrncpy(f->description, "MPEG2-TS with AVC/AAC streams", 32);\r\nf->pixelformat = V4L2_PIX_FMT_MPEG;\r\nreturn 0;\r\n}\r\nstatic int vidioc_g_fmt_vid_cap(struct file *file, void *private_data,\r\nstruct v4l2_format *f)\r\n{\r\nstruct hdpvr_fh *fh = file->private_data;\r\nstruct hdpvr_device *dev = fh->dev;\r\nstruct hdpvr_video_info *vid_info;\r\nif (!dev)\r\nreturn -ENODEV;\r\nvid_info = get_video_info(dev);\r\nif (!vid_info)\r\nreturn -EFAULT;\r\nf->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\r\nf->fmt.pix.pixelformat = V4L2_PIX_FMT_MPEG;\r\nf->fmt.pix.width = vid_info->width;\r\nf->fmt.pix.height = vid_info->height;\r\nf->fmt.pix.sizeimage = dev->bulk_in_size;\r\nf->fmt.pix.colorspace = 0;\r\nf->fmt.pix.bytesperline = 0;\r\nf->fmt.pix.field = V4L2_FIELD_ANY;\r\nkfree(vid_info);\r\nreturn 0;\r\n}\r\nstatic int vidioc_encoder_cmd(struct file *filp, void *priv,\r\nstruct v4l2_encoder_cmd *a)\r\n{\r\nstruct hdpvr_fh *fh = filp->private_data;\r\nstruct hdpvr_device *dev = fh->dev;\r\nint res;\r\nmutex_lock(&dev->io_mutex);\r\nmemset(&a->raw, 0, sizeof(a->raw));\r\nswitch (a->cmd) {\r\ncase V4L2_ENC_CMD_START:\r\na->flags = 0;\r\nres = hdpvr_start_streaming(dev);\r\nbreak;\r\ncase V4L2_ENC_CMD_STOP:\r\nres = hdpvr_stop_streaming(dev);\r\nbreak;\r\ndefault:\r\nv4l2_dbg(MSG_INFO, hdpvr_debug, &dev->v4l2_dev,\r\n"Unsupported encoder cmd %d\n", a->cmd);\r\nres = -EINVAL;\r\n}\r\nmutex_unlock(&dev->io_mutex);\r\nreturn res;\r\n}\r\nstatic int vidioc_try_encoder_cmd(struct file *filp, void *priv,\r\nstruct v4l2_encoder_cmd *a)\r\n{\r\nswitch (a->cmd) {\r\ncase V4L2_ENC_CMD_START:\r\ncase V4L2_ENC_CMD_STOP:\r\nreturn 0;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic void hdpvr_device_release(struct video_device *vdev)\r\n{\r\nstruct hdpvr_device *dev = video_get_drvdata(vdev);\r\nhdpvr_delete(dev);\r\nmutex_lock(&dev->io_mutex);\r\ndestroy_workqueue(dev->workqueue);\r\nmutex_unlock(&dev->io_mutex);\r\nv4l2_device_unregister(&dev->v4l2_dev);\r\n#if defined(CONFIG_I2C) || (CONFIG_I2C_MODULE)\r\nmutex_lock(&dev->i2c_mutex);\r\ni2c_del_adapter(&dev->i2c_adapter);\r\nmutex_unlock(&dev->i2c_mutex);\r\n#endif\r\nkfree(dev->usbc_buf);\r\nkfree(dev);\r\n}\r\nint hdpvr_register_videodev(struct hdpvr_device *dev, struct device *parent,\r\nint devnum)\r\n{\r\ndev->video_dev = video_device_alloc();\r\nif (!dev->video_dev) {\r\nv4l2_err(&dev->v4l2_dev, "video_device_alloc() failed\n");\r\ngoto error;\r\n}\r\n*(dev->video_dev) = hdpvr_video_template;\r\nstrcpy(dev->video_dev->name, "Hauppauge HD PVR");\r\ndev->video_dev->parent = parent;\r\nvideo_set_drvdata(dev->video_dev, dev);\r\nif (video_register_device(dev->video_dev, VFL_TYPE_GRABBER, devnum)) {\r\nv4l2_err(&dev->v4l2_dev, "video_device registration failed\n");\r\ngoto error;\r\n}\r\nreturn 0;\r\nerror:\r\nreturn -ENOMEM;\r\n}
