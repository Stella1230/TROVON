void\r\nNVWriteVgaSeq(struct drm_device *dev, int head, uint8_t index, uint8_t value)\r\n{\r\nNVWritePRMVIO(dev, head, NV_PRMVIO_SRX, index);\r\nNVWritePRMVIO(dev, head, NV_PRMVIO_SR, value);\r\n}\r\nuint8_t\r\nNVReadVgaSeq(struct drm_device *dev, int head, uint8_t index)\r\n{\r\nNVWritePRMVIO(dev, head, NV_PRMVIO_SRX, index);\r\nreturn NVReadPRMVIO(dev, head, NV_PRMVIO_SR);\r\n}\r\nvoid\r\nNVWriteVgaGr(struct drm_device *dev, int head, uint8_t index, uint8_t value)\r\n{\r\nNVWritePRMVIO(dev, head, NV_PRMVIO_GRX, index);\r\nNVWritePRMVIO(dev, head, NV_PRMVIO_GX, value);\r\n}\r\nuint8_t\r\nNVReadVgaGr(struct drm_device *dev, int head, uint8_t index)\r\n{\r\nNVWritePRMVIO(dev, head, NV_PRMVIO_GRX, index);\r\nreturn NVReadPRMVIO(dev, head, NV_PRMVIO_GX);\r\n}\r\nvoid\r\nNVSetOwner(struct drm_device *dev, int owner)\r\n{\r\nstruct nouveau_drm *drm = nouveau_drm(dev);\r\nif (owner == 1)\r\nowner *= 3;\r\nif (nv_device(drm->device)->chipset == 0x11) {\r\nNVReadVgaCrtc(dev, 0, NV_CIO_SR_LOCK_INDEX);\r\nNVReadVgaCrtc(dev, 1, NV_CIO_SR_LOCK_INDEX);\r\n}\r\nNVWriteVgaCrtc(dev, 0, NV_CIO_CRE_44, owner);\r\nif (nv_device(drm->device)->chipset == 0x11) {\r\nNVWriteVgaCrtc(dev, 0, NV_CIO_CRE_2E, owner);\r\nNVWriteVgaCrtc(dev, 0, NV_CIO_CRE_2E, owner);\r\n}\r\n}\r\nvoid\r\nNVBlankScreen(struct drm_device *dev, int head, bool blank)\r\n{\r\nunsigned char seq1;\r\nif (nv_two_heads(dev))\r\nNVSetOwner(dev, head);\r\nseq1 = NVReadVgaSeq(dev, head, NV_VIO_SR_CLOCK_INDEX);\r\nNVVgaSeqReset(dev, head, true);\r\nif (blank)\r\nNVWriteVgaSeq(dev, head, NV_VIO_SR_CLOCK_INDEX, seq1 | 0x20);\r\nelse\r\nNVWriteVgaSeq(dev, head, NV_VIO_SR_CLOCK_INDEX, seq1 & ~0x20);\r\nNVVgaSeqReset(dev, head, false);\r\n}\r\nstatic void\r\nnouveau_hw_decode_pll(struct drm_device *dev, uint32_t reg1, uint32_t pll1,\r\nuint32_t pll2, struct nouveau_pll_vals *pllvals)\r\n{\r\nstruct nouveau_drm *drm = nouveau_drm(dev);\r\npllvals->log2P = (pll1 >> 16) & 0x7;\r\npllvals->N2 = pllvals->M2 = 1;\r\nif (reg1 <= 0x405c) {\r\npllvals->NM1 = pll2 & 0xffff;\r\nif (!(pll1 & 0x1100))\r\npllvals->NM2 = pll2 >> 16;\r\n} else {\r\npllvals->NM1 = pll1 & 0xffff;\r\nif (nv_two_reg_pll(dev) && pll2 & NV31_RAMDAC_ENABLE_VCO2)\r\npllvals->NM2 = pll2 & 0xffff;\r\nelse if (nv_device(drm->device)->chipset == 0x30 || nv_device(drm->device)->chipset == 0x35) {\r\npllvals->M1 &= 0xf;\r\nif (pll1 & NV30_RAMDAC_ENABLE_VCO2) {\r\npllvals->M2 = (pll1 >> 4) & 0x7;\r\npllvals->N2 = ((pll1 >> 21) & 0x18) |\r\n((pll1 >> 19) & 0x7);\r\n}\r\n}\r\n}\r\n}\r\nint\r\nnouveau_hw_get_pllvals(struct drm_device *dev, enum nvbios_pll_type plltype,\r\nstruct nouveau_pll_vals *pllvals)\r\n{\r\nstruct nouveau_drm *drm = nouveau_drm(dev);\r\nstruct nouveau_device *device = nv_device(drm->device);\r\nstruct nouveau_bios *bios = nouveau_bios(device);\r\nuint32_t reg1, pll1, pll2 = 0;\r\nstruct nvbios_pll pll_lim;\r\nint ret;\r\nret = nvbios_pll_parse(bios, plltype, &pll_lim);\r\nif (ret || !(reg1 = pll_lim.reg))\r\nreturn -ENOENT;\r\npll1 = nv_rd32(device, reg1);\r\nif (reg1 <= 0x405c)\r\npll2 = nv_rd32(device, reg1 + 4);\r\nelse if (nv_two_reg_pll(dev)) {\r\nuint32_t reg2 = reg1 + (reg1 == NV_RAMDAC_VPLL2 ? 0x5c : 0x70);\r\npll2 = nv_rd32(device, reg2);\r\n}\r\nif (nv_device(drm->device)->card_type == 0x40 && reg1 >= NV_PRAMDAC_VPLL_COEFF) {\r\nuint32_t ramdac580 = NVReadRAMDAC(dev, 0, NV_PRAMDAC_580);\r\nif (reg1 == NV_PRAMDAC_VPLL_COEFF) {\r\nif (ramdac580 & NV_RAMDAC_580_VPLL1_ACTIVE)\r\npll2 = 0;\r\n} else\r\nif (ramdac580 & NV_RAMDAC_580_VPLL2_ACTIVE)\r\npll2 = 0;\r\n}\r\nnouveau_hw_decode_pll(dev, reg1, pll1, pll2, pllvals);\r\npllvals->refclk = pll_lim.refclk;\r\nreturn 0;\r\n}\r\nint\r\nnouveau_hw_pllvals_to_clk(struct nouveau_pll_vals *pv)\r\n{\r\nif (!pv->M1 || !pv->M2)\r\nreturn 0;\r\nreturn pv->N1 * pv->N2 * pv->refclk / (pv->M1 * pv->M2) >> pv->log2P;\r\n}\r\nint\r\nnouveau_hw_get_clock(struct drm_device *dev, enum nvbios_pll_type plltype)\r\n{\r\nstruct nouveau_pll_vals pllvals;\r\nint ret;\r\nif (plltype == PLL_MEMORY &&\r\n(dev->pci_device & 0x0ff0) == CHIPSET_NFORCE) {\r\nuint32_t mpllP;\r\npci_read_config_dword(pci_get_bus_and_slot(0, 3), 0x6c, &mpllP);\r\nif (!mpllP)\r\nmpllP = 4;\r\nreturn 400000 / mpllP;\r\n} else\r\nif (plltype == PLL_MEMORY &&\r\n(dev->pci_device & 0xff0) == CHIPSET_NFORCE2) {\r\nuint32_t clock;\r\npci_read_config_dword(pci_get_bus_and_slot(0, 5), 0x4c, &clock);\r\nreturn clock;\r\n}\r\nret = nouveau_hw_get_pllvals(dev, plltype, &pllvals);\r\nif (ret)\r\nreturn ret;\r\nreturn nouveau_hw_pllvals_to_clk(&pllvals);\r\n}\r\nstatic void\r\nnouveau_hw_fix_bad_vpll(struct drm_device *dev, int head)\r\n{\r\nstruct nouveau_drm *drm = nouveau_drm(dev);\r\nstruct nouveau_device *device = nv_device(drm->device);\r\nstruct nouveau_clock *clk = nouveau_clock(device);\r\nstruct nouveau_bios *bios = nouveau_bios(device);\r\nstruct nvbios_pll pll_lim;\r\nstruct nouveau_pll_vals pv;\r\nenum nvbios_pll_type pll = head ? PLL_VPLL1 : PLL_VPLL0;\r\nif (nvbios_pll_parse(bios, pll, &pll_lim))\r\nreturn;\r\nnouveau_hw_get_pllvals(dev, pll, &pv);\r\nif (pv.M1 >= pll_lim.vco1.min_m && pv.M1 <= pll_lim.vco1.max_m &&\r\npv.N1 >= pll_lim.vco1.min_n && pv.N1 <= pll_lim.vco1.max_n &&\r\npv.log2P <= pll_lim.max_p)\r\nreturn;\r\nNV_WARN(drm, "VPLL %d outwith limits, attempting to fix\n", head + 1);\r\npv.M1 = pll_lim.vco1.max_m;\r\npv.N1 = pll_lim.vco1.min_n;\r\npv.log2P = pll_lim.max_p_usable;\r\nclk->pll_prog(clk, pll_lim.reg, &pv);\r\n}\r\nstatic void nouveau_vga_font_io(struct drm_device *dev,\r\nvoid __iomem *iovram,\r\nbool save, unsigned plane)\r\n{\r\nunsigned i;\r\nNVWriteVgaSeq(dev, 0, NV_VIO_SR_PLANE_MASK_INDEX, 1 << plane);\r\nNVWriteVgaGr(dev, 0, NV_VIO_GX_READ_MAP_INDEX, plane);\r\nfor (i = 0; i < 16384; i++) {\r\nif (save) {\r\nnv04_display(dev)->saved_vga_font[plane][i] =\r\nioread32_native(iovram + i * 4);\r\n} else {\r\niowrite32_native(nv04_display(dev)->saved_vga_font[plane][i],\r\niovram + i * 4);\r\n}\r\n}\r\n}\r\nvoid\r\nnouveau_hw_save_vga_fonts(struct drm_device *dev, bool save)\r\n{\r\nstruct nouveau_drm *drm = nouveau_drm(dev);\r\nuint8_t misc, gr4, gr5, gr6, seq2, seq4;\r\nbool graphicsmode;\r\nunsigned plane;\r\nvoid __iomem *iovram;\r\nif (nv_two_heads(dev))\r\nNVSetOwner(dev, 0);\r\nNVSetEnablePalette(dev, 0, true);\r\ngraphicsmode = NVReadVgaAttr(dev, 0, NV_CIO_AR_MODE_INDEX) & 1;\r\nNVSetEnablePalette(dev, 0, false);\r\nif (graphicsmode)\r\nreturn;\r\nNV_INFO(drm, "%sing VGA fonts\n", save ? "Sav" : "Restor");\r\niovram = ioremap(pci_resource_start(dev->pdev, 1), 65536);\r\nif (!iovram) {\r\nNV_ERROR(drm, "Failed to map VRAM, "\r\n"cannot save/restore VGA fonts.\n");\r\nreturn;\r\n}\r\nif (nv_two_heads(dev))\r\nNVBlankScreen(dev, 1, true);\r\nNVBlankScreen(dev, 0, true);\r\nmisc = NVReadPRMVIO(dev, 0, NV_PRMVIO_MISC__READ);\r\nseq2 = NVReadVgaSeq(dev, 0, NV_VIO_SR_PLANE_MASK_INDEX);\r\nseq4 = NVReadVgaSeq(dev, 0, NV_VIO_SR_MEM_MODE_INDEX);\r\ngr4 = NVReadVgaGr(dev, 0, NV_VIO_GX_READ_MAP_INDEX);\r\ngr5 = NVReadVgaGr(dev, 0, NV_VIO_GX_MODE_INDEX);\r\ngr6 = NVReadVgaGr(dev, 0, NV_VIO_GX_MISC_INDEX);\r\nNVWritePRMVIO(dev, 0, NV_PRMVIO_MISC__WRITE, 0x67);\r\nNVWriteVgaSeq(dev, 0, NV_VIO_SR_MEM_MODE_INDEX, 0x6);\r\nNVWriteVgaGr(dev, 0, NV_VIO_GX_MODE_INDEX, 0x0);\r\nNVWriteVgaGr(dev, 0, NV_VIO_GX_MISC_INDEX, 0x5);\r\nfor (plane = 0; plane < 4; plane++)\r\nnouveau_vga_font_io(dev, iovram, save, plane);\r\nNVWritePRMVIO(dev, 0, NV_PRMVIO_MISC__WRITE, misc);\r\nNVWriteVgaGr(dev, 0, NV_VIO_GX_READ_MAP_INDEX, gr4);\r\nNVWriteVgaGr(dev, 0, NV_VIO_GX_MODE_INDEX, gr5);\r\nNVWriteVgaGr(dev, 0, NV_VIO_GX_MISC_INDEX, gr6);\r\nNVWriteVgaSeq(dev, 0, NV_VIO_SR_PLANE_MASK_INDEX, seq2);\r\nNVWriteVgaSeq(dev, 0, NV_VIO_SR_MEM_MODE_INDEX, seq4);\r\nif (nv_two_heads(dev))\r\nNVBlankScreen(dev, 1, false);\r\nNVBlankScreen(dev, 0, false);\r\niounmap(iovram);\r\n}\r\nstatic void\r\nrd_cio_state(struct drm_device *dev, int head,\r\nstruct nv04_crtc_reg *crtcstate, int index)\r\n{\r\ncrtcstate->CRTC[index] = NVReadVgaCrtc(dev, head, index);\r\n}\r\nstatic void\r\nwr_cio_state(struct drm_device *dev, int head,\r\nstruct nv04_crtc_reg *crtcstate, int index)\r\n{\r\nNVWriteVgaCrtc(dev, head, index, crtcstate->CRTC[index]);\r\n}\r\nstatic void\r\nnv_save_state_ramdac(struct drm_device *dev, int head,\r\nstruct nv04_mode_state *state)\r\n{\r\nstruct nouveau_drm *drm = nouveau_drm(dev);\r\nstruct nv04_crtc_reg *regp = &state->crtc_reg[head];\r\nint i;\r\nif (nv_device(drm->device)->card_type >= NV_10)\r\nregp->nv10_cursync = NVReadRAMDAC(dev, head, NV_RAMDAC_NV10_CURSYNC);\r\nnouveau_hw_get_pllvals(dev, head ? PLL_VPLL1 : PLL_VPLL0, &regp->pllvals);\r\nstate->pllsel = NVReadRAMDAC(dev, 0, NV_PRAMDAC_PLL_COEFF_SELECT);\r\nif (nv_two_heads(dev))\r\nstate->sel_clk = NVReadRAMDAC(dev, 0, NV_PRAMDAC_SEL_CLK);\r\nif (nv_device(drm->device)->chipset == 0x11)\r\nregp->dither = NVReadRAMDAC(dev, head, NV_RAMDAC_DITHER_NV11);\r\nregp->ramdac_gen_ctrl = NVReadRAMDAC(dev, head, NV_PRAMDAC_GENERAL_CONTROL);\r\nif (nv_gf4_disp_arch(dev))\r\nregp->ramdac_630 = NVReadRAMDAC(dev, head, NV_PRAMDAC_630);\r\nif (nv_device(drm->device)->chipset >= 0x30)\r\nregp->ramdac_634 = NVReadRAMDAC(dev, head, NV_PRAMDAC_634);\r\nregp->tv_setup = NVReadRAMDAC(dev, head, NV_PRAMDAC_TV_SETUP);\r\nregp->tv_vtotal = NVReadRAMDAC(dev, head, NV_PRAMDAC_TV_VTOTAL);\r\nregp->tv_vskew = NVReadRAMDAC(dev, head, NV_PRAMDAC_TV_VSKEW);\r\nregp->tv_vsync_delay = NVReadRAMDAC(dev, head, NV_PRAMDAC_TV_VSYNC_DELAY);\r\nregp->tv_htotal = NVReadRAMDAC(dev, head, NV_PRAMDAC_TV_HTOTAL);\r\nregp->tv_hskew = NVReadRAMDAC(dev, head, NV_PRAMDAC_TV_HSKEW);\r\nregp->tv_hsync_delay = NVReadRAMDAC(dev, head, NV_PRAMDAC_TV_HSYNC_DELAY);\r\nregp->tv_hsync_delay2 = NVReadRAMDAC(dev, head, NV_PRAMDAC_TV_HSYNC_DELAY2);\r\nfor (i = 0; i < 7; i++) {\r\nuint32_t ramdac_reg = NV_PRAMDAC_FP_VDISPLAY_END + (i * 4);\r\nregp->fp_vert_regs[i] = NVReadRAMDAC(dev, head, ramdac_reg);\r\nregp->fp_horiz_regs[i] = NVReadRAMDAC(dev, head, ramdac_reg + 0x20);\r\n}\r\nif (nv_gf4_disp_arch(dev)) {\r\nregp->dither = NVReadRAMDAC(dev, head, NV_RAMDAC_FP_DITHER);\r\nfor (i = 0; i < 3; i++) {\r\nregp->dither_regs[i] = NVReadRAMDAC(dev, head, NV_PRAMDAC_850 + i * 4);\r\nregp->dither_regs[i + 3] = NVReadRAMDAC(dev, head, NV_PRAMDAC_85C + i * 4);\r\n}\r\n}\r\nregp->fp_control = NVReadRAMDAC(dev, head, NV_PRAMDAC_FP_TG_CONTROL);\r\nregp->fp_debug_0 = NVReadRAMDAC(dev, head, NV_PRAMDAC_FP_DEBUG_0);\r\nif (!nv_gf4_disp_arch(dev) && head == 0) {\r\nNVWriteRAMDAC(dev, 0, NV_PRAMDAC_FP_DEBUG_0, regp->fp_debug_0 &\r\n~NV_PRAMDAC_FP_DEBUG_0_PWRDOWN_FPCLK);\r\n}\r\nregp->fp_debug_1 = NVReadRAMDAC(dev, head, NV_PRAMDAC_FP_DEBUG_1);\r\nregp->fp_debug_2 = NVReadRAMDAC(dev, head, NV_PRAMDAC_FP_DEBUG_2);\r\nregp->fp_margin_color = NVReadRAMDAC(dev, head, NV_PRAMDAC_FP_MARGIN_COLOR);\r\nif (nv_gf4_disp_arch(dev))\r\nregp->ramdac_8c0 = NVReadRAMDAC(dev, head, NV_PRAMDAC_8C0);\r\nif (nv_device(drm->device)->card_type == NV_40) {\r\nregp->ramdac_a20 = NVReadRAMDAC(dev, head, NV_PRAMDAC_A20);\r\nregp->ramdac_a24 = NVReadRAMDAC(dev, head, NV_PRAMDAC_A24);\r\nregp->ramdac_a34 = NVReadRAMDAC(dev, head, NV_PRAMDAC_A34);\r\nfor (i = 0; i < 38; i++)\r\nregp->ctv_regs[i] = NVReadRAMDAC(dev, head,\r\nNV_PRAMDAC_CTV + 4*i);\r\n}\r\n}\r\nstatic void\r\nnv_load_state_ramdac(struct drm_device *dev, int head,\r\nstruct nv04_mode_state *state)\r\n{\r\nstruct nouveau_drm *drm = nouveau_drm(dev);\r\nstruct nouveau_clock *clk = nouveau_clock(drm->device);\r\nstruct nv04_crtc_reg *regp = &state->crtc_reg[head];\r\nuint32_t pllreg = head ? NV_RAMDAC_VPLL2 : NV_PRAMDAC_VPLL_COEFF;\r\nint i;\r\nif (nv_device(drm->device)->card_type >= NV_10)\r\nNVWriteRAMDAC(dev, head, NV_RAMDAC_NV10_CURSYNC, regp->nv10_cursync);\r\nclk->pll_prog(clk, pllreg, &regp->pllvals);\r\nNVWriteRAMDAC(dev, 0, NV_PRAMDAC_PLL_COEFF_SELECT, state->pllsel);\r\nif (nv_two_heads(dev))\r\nNVWriteRAMDAC(dev, 0, NV_PRAMDAC_SEL_CLK, state->sel_clk);\r\nif (nv_device(drm->device)->chipset == 0x11)\r\nNVWriteRAMDAC(dev, head, NV_RAMDAC_DITHER_NV11, regp->dither);\r\nNVWriteRAMDAC(dev, head, NV_PRAMDAC_GENERAL_CONTROL, regp->ramdac_gen_ctrl);\r\nif (nv_gf4_disp_arch(dev))\r\nNVWriteRAMDAC(dev, head, NV_PRAMDAC_630, regp->ramdac_630);\r\nif (nv_device(drm->device)->chipset >= 0x30)\r\nNVWriteRAMDAC(dev, head, NV_PRAMDAC_634, regp->ramdac_634);\r\nNVWriteRAMDAC(dev, head, NV_PRAMDAC_TV_SETUP, regp->tv_setup);\r\nNVWriteRAMDAC(dev, head, NV_PRAMDAC_TV_VTOTAL, regp->tv_vtotal);\r\nNVWriteRAMDAC(dev, head, NV_PRAMDAC_TV_VSKEW, regp->tv_vskew);\r\nNVWriteRAMDAC(dev, head, NV_PRAMDAC_TV_VSYNC_DELAY, regp->tv_vsync_delay);\r\nNVWriteRAMDAC(dev, head, NV_PRAMDAC_TV_HTOTAL, regp->tv_htotal);\r\nNVWriteRAMDAC(dev, head, NV_PRAMDAC_TV_HSKEW, regp->tv_hskew);\r\nNVWriteRAMDAC(dev, head, NV_PRAMDAC_TV_HSYNC_DELAY, regp->tv_hsync_delay);\r\nNVWriteRAMDAC(dev, head, NV_PRAMDAC_TV_HSYNC_DELAY2, regp->tv_hsync_delay2);\r\nfor (i = 0; i < 7; i++) {\r\nuint32_t ramdac_reg = NV_PRAMDAC_FP_VDISPLAY_END + (i * 4);\r\nNVWriteRAMDAC(dev, head, ramdac_reg, regp->fp_vert_regs[i]);\r\nNVWriteRAMDAC(dev, head, ramdac_reg + 0x20, regp->fp_horiz_regs[i]);\r\n}\r\nif (nv_gf4_disp_arch(dev)) {\r\nNVWriteRAMDAC(dev, head, NV_RAMDAC_FP_DITHER, regp->dither);\r\nfor (i = 0; i < 3; i++) {\r\nNVWriteRAMDAC(dev, head, NV_PRAMDAC_850 + i * 4, regp->dither_regs[i]);\r\nNVWriteRAMDAC(dev, head, NV_PRAMDAC_85C + i * 4, regp->dither_regs[i + 3]);\r\n}\r\n}\r\nNVWriteRAMDAC(dev, head, NV_PRAMDAC_FP_TG_CONTROL, regp->fp_control);\r\nNVWriteRAMDAC(dev, head, NV_PRAMDAC_FP_DEBUG_0, regp->fp_debug_0);\r\nNVWriteRAMDAC(dev, head, NV_PRAMDAC_FP_DEBUG_1, regp->fp_debug_1);\r\nNVWriteRAMDAC(dev, head, NV_PRAMDAC_FP_DEBUG_2, regp->fp_debug_2);\r\nNVWriteRAMDAC(dev, head, NV_PRAMDAC_FP_MARGIN_COLOR, regp->fp_margin_color);\r\nif (nv_gf4_disp_arch(dev))\r\nNVWriteRAMDAC(dev, head, NV_PRAMDAC_8C0, regp->ramdac_8c0);\r\nif (nv_device(drm->device)->card_type == NV_40) {\r\nNVWriteRAMDAC(dev, head, NV_PRAMDAC_A20, regp->ramdac_a20);\r\nNVWriteRAMDAC(dev, head, NV_PRAMDAC_A24, regp->ramdac_a24);\r\nNVWriteRAMDAC(dev, head, NV_PRAMDAC_A34, regp->ramdac_a34);\r\nfor (i = 0; i < 38; i++)\r\nNVWriteRAMDAC(dev, head,\r\nNV_PRAMDAC_CTV + 4*i, regp->ctv_regs[i]);\r\n}\r\n}\r\nstatic void\r\nnv_save_state_vga(struct drm_device *dev, int head,\r\nstruct nv04_mode_state *state)\r\n{\r\nstruct nv04_crtc_reg *regp = &state->crtc_reg[head];\r\nint i;\r\nregp->MiscOutReg = NVReadPRMVIO(dev, head, NV_PRMVIO_MISC__READ);\r\nfor (i = 0; i < 25; i++)\r\nrd_cio_state(dev, head, regp, i);\r\nNVSetEnablePalette(dev, head, true);\r\nfor (i = 0; i < 21; i++)\r\nregp->Attribute[i] = NVReadVgaAttr(dev, head, i);\r\nNVSetEnablePalette(dev, head, false);\r\nfor (i = 0; i < 9; i++)\r\nregp->Graphics[i] = NVReadVgaGr(dev, head, i);\r\nfor (i = 0; i < 5; i++)\r\nregp->Sequencer[i] = NVReadVgaSeq(dev, head, i);\r\n}\r\nstatic void\r\nnv_load_state_vga(struct drm_device *dev, int head,\r\nstruct nv04_mode_state *state)\r\n{\r\nstruct nv04_crtc_reg *regp = &state->crtc_reg[head];\r\nint i;\r\nNVWritePRMVIO(dev, head, NV_PRMVIO_MISC__WRITE, regp->MiscOutReg);\r\nfor (i = 0; i < 5; i++)\r\nNVWriteVgaSeq(dev, head, i, regp->Sequencer[i]);\r\nnv_lock_vga_crtc_base(dev, head, false);\r\nfor (i = 0; i < 25; i++)\r\nwr_cio_state(dev, head, regp, i);\r\nnv_lock_vga_crtc_base(dev, head, true);\r\nfor (i = 0; i < 9; i++)\r\nNVWriteVgaGr(dev, head, i, regp->Graphics[i]);\r\nNVSetEnablePalette(dev, head, true);\r\nfor (i = 0; i < 21; i++)\r\nNVWriteVgaAttr(dev, head, i, regp->Attribute[i]);\r\nNVSetEnablePalette(dev, head, false);\r\n}\r\nstatic void\r\nnv_save_state_ext(struct drm_device *dev, int head,\r\nstruct nv04_mode_state *state)\r\n{\r\nstruct nouveau_drm *drm = nouveau_drm(dev);\r\nstruct nv04_crtc_reg *regp = &state->crtc_reg[head];\r\nint i;\r\nrd_cio_state(dev, head, regp, NV_CIO_CRE_LCD__INDEX);\r\nrd_cio_state(dev, head, regp, NV_CIO_CRE_RPC0_INDEX);\r\nrd_cio_state(dev, head, regp, NV_CIO_CRE_RPC1_INDEX);\r\nrd_cio_state(dev, head, regp, NV_CIO_CRE_LSR_INDEX);\r\nrd_cio_state(dev, head, regp, NV_CIO_CRE_PIXEL_INDEX);\r\nrd_cio_state(dev, head, regp, NV_CIO_CRE_HEB__INDEX);\r\nrd_cio_state(dev, head, regp, NV_CIO_CRE_ENH_INDEX);\r\nrd_cio_state(dev, head, regp, NV_CIO_CRE_FF_INDEX);\r\nrd_cio_state(dev, head, regp, NV_CIO_CRE_FFLWM__INDEX);\r\nrd_cio_state(dev, head, regp, NV_CIO_CRE_21);\r\nif (nv_device(drm->device)->card_type >= NV_20)\r\nrd_cio_state(dev, head, regp, NV_CIO_CRE_47);\r\nif (nv_device(drm->device)->card_type >= NV_30)\r\nrd_cio_state(dev, head, regp, 0x9f);\r\nrd_cio_state(dev, head, regp, NV_CIO_CRE_49);\r\nrd_cio_state(dev, head, regp, NV_CIO_CRE_HCUR_ADDR0_INDEX);\r\nrd_cio_state(dev, head, regp, NV_CIO_CRE_HCUR_ADDR1_INDEX);\r\nrd_cio_state(dev, head, regp, NV_CIO_CRE_HCUR_ADDR2_INDEX);\r\nrd_cio_state(dev, head, regp, NV_CIO_CRE_ILACE__INDEX);\r\nif (nv_device(drm->device)->card_type >= NV_10) {\r\nregp->crtc_830 = NVReadCRTC(dev, head, NV_PCRTC_830);\r\nregp->crtc_834 = NVReadCRTC(dev, head, NV_PCRTC_834);\r\nif (nv_device(drm->device)->card_type >= NV_30)\r\nregp->gpio_ext = NVReadCRTC(dev, head, NV_PCRTC_GPIO_EXT);\r\nif (nv_device(drm->device)->card_type == NV_40)\r\nregp->crtc_850 = NVReadCRTC(dev, head, NV_PCRTC_850);\r\nif (nv_two_heads(dev))\r\nregp->crtc_eng_ctrl = NVReadCRTC(dev, head, NV_PCRTC_ENGINE_CTRL);\r\nregp->cursor_cfg = NVReadCRTC(dev, head, NV_PCRTC_CURSOR_CONFIG);\r\n}\r\nregp->crtc_cfg = NVReadCRTC(dev, head, NV_PCRTC_CONFIG);\r\nrd_cio_state(dev, head, regp, NV_CIO_CRE_SCRATCH3__INDEX);\r\nrd_cio_state(dev, head, regp, NV_CIO_CRE_SCRATCH4__INDEX);\r\nif (nv_device(drm->device)->card_type >= NV_10) {\r\nrd_cio_state(dev, head, regp, NV_CIO_CRE_EBR_INDEX);\r\nrd_cio_state(dev, head, regp, NV_CIO_CRE_CSB);\r\nrd_cio_state(dev, head, regp, NV_CIO_CRE_4B);\r\nrd_cio_state(dev, head, regp, NV_CIO_CRE_TVOUT_LATENCY);\r\n}\r\nif (nv_gf4_disp_arch(dev)) {\r\nrd_cio_state(dev, head, regp, NV_CIO_CRE_42);\r\nrd_cio_state(dev, head, regp, NV_CIO_CRE_53);\r\nrd_cio_state(dev, head, regp, NV_CIO_CRE_54);\r\nfor (i = 0; i < 0x10; i++)\r\nregp->CR58[i] = NVReadVgaCrtc5758(dev, head, i);\r\nrd_cio_state(dev, head, regp, NV_CIO_CRE_59);\r\nrd_cio_state(dev, head, regp, NV_CIO_CRE_5B);\r\nrd_cio_state(dev, head, regp, NV_CIO_CRE_85);\r\nrd_cio_state(dev, head, regp, NV_CIO_CRE_86);\r\n}\r\nregp->fb_start = NVReadCRTC(dev, head, NV_PCRTC_START);\r\n}\r\nstatic void\r\nnv_load_state_ext(struct drm_device *dev, int head,\r\nstruct nv04_mode_state *state)\r\n{\r\nstruct nouveau_drm *drm = nouveau_drm(dev);\r\nstruct nouveau_device *device = nv_device(drm->device);\r\nstruct nouveau_timer *ptimer = nouveau_timer(device);\r\nstruct nv04_crtc_reg *regp = &state->crtc_reg[head];\r\nuint32_t reg900;\r\nint i;\r\nif (nv_device(drm->device)->card_type >= NV_10) {\r\nif (nv_two_heads(dev))\r\nNVWriteCRTC(dev, head, NV_PCRTC_ENGINE_CTRL, regp->crtc_eng_ctrl);\r\nnv_wr32(device, NV_PVIDEO_STOP, 1);\r\nnv_wr32(device, NV_PVIDEO_INTR_EN, 0);\r\nnv_wr32(device, NV_PVIDEO_OFFSET_BUFF(0), 0);\r\nnv_wr32(device, NV_PVIDEO_OFFSET_BUFF(1), 0);\r\nnv_wr32(device, NV_PVIDEO_LIMIT(0), 0);\r\nnv_wr32(device, NV_PVIDEO_LIMIT(1), 0);\r\nnv_wr32(device, NV_PVIDEO_UVPLANE_LIMIT(0), 0);\r\nnv_wr32(device, NV_PVIDEO_UVPLANE_LIMIT(1), 0);\r\nnv_wr32(device, NV_PBUS_POWERCTRL_2, 0);\r\nNVWriteCRTC(dev, head, NV_PCRTC_CURSOR_CONFIG, regp->cursor_cfg);\r\nNVWriteCRTC(dev, head, NV_PCRTC_830, regp->crtc_830);\r\nNVWriteCRTC(dev, head, NV_PCRTC_834, regp->crtc_834);\r\nif (nv_device(drm->device)->card_type >= NV_30)\r\nNVWriteCRTC(dev, head, NV_PCRTC_GPIO_EXT, regp->gpio_ext);\r\nif (nv_device(drm->device)->card_type == NV_40) {\r\nNVWriteCRTC(dev, head, NV_PCRTC_850, regp->crtc_850);\r\nreg900 = NVReadRAMDAC(dev, head, NV_PRAMDAC_900);\r\nif (regp->crtc_cfg == NV10_PCRTC_CONFIG_START_ADDRESS_HSYNC)\r\nNVWriteRAMDAC(dev, head, NV_PRAMDAC_900, reg900 | 0x10000);\r\nelse\r\nNVWriteRAMDAC(dev, head, NV_PRAMDAC_900, reg900 & ~0x10000);\r\n}\r\n}\r\nNVWriteCRTC(dev, head, NV_PCRTC_CONFIG, regp->crtc_cfg);\r\nwr_cio_state(dev, head, regp, NV_CIO_CRE_RPC0_INDEX);\r\nwr_cio_state(dev, head, regp, NV_CIO_CRE_RPC1_INDEX);\r\nwr_cio_state(dev, head, regp, NV_CIO_CRE_LSR_INDEX);\r\nwr_cio_state(dev, head, regp, NV_CIO_CRE_PIXEL_INDEX);\r\nwr_cio_state(dev, head, regp, NV_CIO_CRE_LCD__INDEX);\r\nwr_cio_state(dev, head, regp, NV_CIO_CRE_HEB__INDEX);\r\nwr_cio_state(dev, head, regp, NV_CIO_CRE_ENH_INDEX);\r\nwr_cio_state(dev, head, regp, NV_CIO_CRE_FF_INDEX);\r\nwr_cio_state(dev, head, regp, NV_CIO_CRE_FFLWM__INDEX);\r\nif (nv_device(drm->device)->card_type >= NV_20)\r\nwr_cio_state(dev, head, regp, NV_CIO_CRE_47);\r\nif (nv_device(drm->device)->card_type >= NV_30)\r\nwr_cio_state(dev, head, regp, 0x9f);\r\nwr_cio_state(dev, head, regp, NV_CIO_CRE_49);\r\nwr_cio_state(dev, head, regp, NV_CIO_CRE_HCUR_ADDR0_INDEX);\r\nwr_cio_state(dev, head, regp, NV_CIO_CRE_HCUR_ADDR1_INDEX);\r\nwr_cio_state(dev, head, regp, NV_CIO_CRE_HCUR_ADDR2_INDEX);\r\nif (nv_device(drm->device)->card_type == NV_40)\r\nnv_fix_nv40_hw_cursor(dev, head);\r\nwr_cio_state(dev, head, regp, NV_CIO_CRE_ILACE__INDEX);\r\nwr_cio_state(dev, head, regp, NV_CIO_CRE_SCRATCH3__INDEX);\r\nwr_cio_state(dev, head, regp, NV_CIO_CRE_SCRATCH4__INDEX);\r\nif (nv_device(drm->device)->card_type >= NV_10) {\r\nwr_cio_state(dev, head, regp, NV_CIO_CRE_EBR_INDEX);\r\nwr_cio_state(dev, head, regp, NV_CIO_CRE_CSB);\r\nwr_cio_state(dev, head, regp, NV_CIO_CRE_4B);\r\nwr_cio_state(dev, head, regp, NV_CIO_CRE_TVOUT_LATENCY);\r\n}\r\nif (nv_gf4_disp_arch(dev)) {\r\nif (nv_device(drm->device)->card_type == NV_10) {\r\nnouveau_timer_wait_eq(ptimer, 650000000, NV_PRMCIO_INP0__COLOR, 0x8, 0x8);\r\nnouveau_timer_wait_eq(ptimer, 650000000, NV_PRMCIO_INP0__COLOR, 0x8, 0x0);\r\n}\r\nwr_cio_state(dev, head, regp, NV_CIO_CRE_42);\r\nwr_cio_state(dev, head, regp, NV_CIO_CRE_53);\r\nwr_cio_state(dev, head, regp, NV_CIO_CRE_54);\r\nfor (i = 0; i < 0x10; i++)\r\nNVWriteVgaCrtc5758(dev, head, i, regp->CR58[i]);\r\nwr_cio_state(dev, head, regp, NV_CIO_CRE_59);\r\nwr_cio_state(dev, head, regp, NV_CIO_CRE_5B);\r\nwr_cio_state(dev, head, regp, NV_CIO_CRE_85);\r\nwr_cio_state(dev, head, regp, NV_CIO_CRE_86);\r\n}\r\nNVWriteCRTC(dev, head, NV_PCRTC_START, regp->fb_start);\r\n}\r\nstatic void\r\nnv_save_state_palette(struct drm_device *dev, int head,\r\nstruct nv04_mode_state *state)\r\n{\r\nstruct nouveau_device *device = nouveau_dev(dev);\r\nint head_offset = head * NV_PRMDIO_SIZE, i;\r\nnv_wr08(device, NV_PRMDIO_PIXEL_MASK + head_offset,\r\nNV_PRMDIO_PIXEL_MASK_MASK);\r\nnv_wr08(device, NV_PRMDIO_READ_MODE_ADDRESS + head_offset, 0x0);\r\nfor (i = 0; i < 768; i++) {\r\nstate->crtc_reg[head].DAC[i] = nv_rd08(device,\r\nNV_PRMDIO_PALETTE_DATA + head_offset);\r\n}\r\nNVSetEnablePalette(dev, head, false);\r\n}\r\nvoid\r\nnouveau_hw_load_state_palette(struct drm_device *dev, int head,\r\nstruct nv04_mode_state *state)\r\n{\r\nstruct nouveau_device *device = nouveau_dev(dev);\r\nint head_offset = head * NV_PRMDIO_SIZE, i;\r\nnv_wr08(device, NV_PRMDIO_PIXEL_MASK + head_offset,\r\nNV_PRMDIO_PIXEL_MASK_MASK);\r\nnv_wr08(device, NV_PRMDIO_WRITE_MODE_ADDRESS + head_offset, 0x0);\r\nfor (i = 0; i < 768; i++) {\r\nnv_wr08(device, NV_PRMDIO_PALETTE_DATA + head_offset,\r\nstate->crtc_reg[head].DAC[i]);\r\n}\r\nNVSetEnablePalette(dev, head, false);\r\n}\r\nvoid nouveau_hw_save_state(struct drm_device *dev, int head,\r\nstruct nv04_mode_state *state)\r\n{\r\nstruct nouveau_drm *drm = nouveau_drm(dev);\r\nif (nv_device(drm->device)->chipset == 0x11)\r\nnouveau_hw_fix_bad_vpll(dev, head);\r\nnv_save_state_ramdac(dev, head, state);\r\nnv_save_state_vga(dev, head, state);\r\nnv_save_state_palette(dev, head, state);\r\nnv_save_state_ext(dev, head, state);\r\n}\r\nvoid nouveau_hw_load_state(struct drm_device *dev, int head,\r\nstruct nv04_mode_state *state)\r\n{\r\nNVVgaProtect(dev, head, true);\r\nnv_load_state_ramdac(dev, head, state);\r\nnv_load_state_ext(dev, head, state);\r\nnouveau_hw_load_state_palette(dev, head, state);\r\nnv_load_state_vga(dev, head, state);\r\nNVVgaProtect(dev, head, false);\r\n}
