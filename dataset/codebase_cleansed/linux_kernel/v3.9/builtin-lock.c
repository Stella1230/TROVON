static struct thread_stat *thread_stat_find(u32 tid)\r\n{\r\nstruct rb_node *node;\r\nstruct thread_stat *st;\r\nnode = thread_stats.rb_node;\r\nwhile (node) {\r\nst = container_of(node, struct thread_stat, rb);\r\nif (st->tid == tid)\r\nreturn st;\r\nelse if (tid < st->tid)\r\nnode = node->rb_left;\r\nelse\r\nnode = node->rb_right;\r\n}\r\nreturn NULL;\r\n}\r\nstatic void thread_stat_insert(struct thread_stat *new)\r\n{\r\nstruct rb_node **rb = &thread_stats.rb_node;\r\nstruct rb_node *parent = NULL;\r\nstruct thread_stat *p;\r\nwhile (*rb) {\r\np = container_of(*rb, struct thread_stat, rb);\r\nparent = *rb;\r\nif (new->tid < p->tid)\r\nrb = &(*rb)->rb_left;\r\nelse if (new->tid > p->tid)\r\nrb = &(*rb)->rb_right;\r\nelse\r\nBUG_ON("inserting invalid thread_stat\n");\r\n}\r\nrb_link_node(&new->rb, parent, rb);\r\nrb_insert_color(&new->rb, &thread_stats);\r\n}\r\nstatic struct thread_stat *thread_stat_findnew_after_first(u32 tid)\r\n{\r\nstruct thread_stat *st;\r\nst = thread_stat_find(tid);\r\nif (st)\r\nreturn st;\r\nst = zalloc(sizeof(struct thread_stat));\r\nif (!st) {\r\npr_err("memory allocation failed\n");\r\nreturn NULL;\r\n}\r\nst->tid = tid;\r\nINIT_LIST_HEAD(&st->seq_list);\r\nthread_stat_insert(st);\r\nreturn st;\r\n}\r\nstatic struct thread_stat *thread_stat_findnew_first(u32 tid)\r\n{\r\nstruct thread_stat *st;\r\nst = zalloc(sizeof(struct thread_stat));\r\nif (!st) {\r\npr_err("memory allocation failed\n");\r\nreturn NULL;\r\n}\r\nst->tid = tid;\r\nINIT_LIST_HEAD(&st->seq_list);\r\nrb_link_node(&st->rb, NULL, &thread_stats.rb_node);\r\nrb_insert_color(&st->rb, &thread_stats);\r\nthread_stat_findnew = thread_stat_findnew_after_first;\r\nreturn st;\r\n}\r\nstatic int lock_stat_key_wait_time_min(struct lock_stat *one,\r\nstruct lock_stat *two)\r\n{\r\nu64 s1 = one->wait_time_min;\r\nu64 s2 = two->wait_time_min;\r\nif (s1 == ULLONG_MAX)\r\ns1 = 0;\r\nif (s2 == ULLONG_MAX)\r\ns2 = 0;\r\nreturn s1 > s2;\r\n}\r\nstatic int select_key(void)\r\n{\r\nint i;\r\nfor (i = 0; keys[i].name; i++) {\r\nif (!strcmp(keys[i].name, sort_key)) {\r\ncompare = keys[i].key;\r\nreturn 0;\r\n}\r\n}\r\npr_err("Unknown compare key: %s\n", sort_key);\r\nreturn -1;\r\n}\r\nstatic void insert_to_result(struct lock_stat *st,\r\nint (*bigger)(struct lock_stat *, struct lock_stat *))\r\n{\r\nstruct rb_node **rb = &result.rb_node;\r\nstruct rb_node *parent = NULL;\r\nstruct lock_stat *p;\r\nwhile (*rb) {\r\np = container_of(*rb, struct lock_stat, rb);\r\nparent = *rb;\r\nif (bigger(st, p))\r\nrb = &(*rb)->rb_left;\r\nelse\r\nrb = &(*rb)->rb_right;\r\n}\r\nrb_link_node(&st->rb, parent, rb);\r\nrb_insert_color(&st->rb, &result);\r\n}\r\nstatic struct lock_stat *pop_from_result(void)\r\n{\r\nstruct rb_node *node = result.rb_node;\r\nif (!node)\r\nreturn NULL;\r\nwhile (node->rb_left)\r\nnode = node->rb_left;\r\nrb_erase(node, &result);\r\nreturn container_of(node, struct lock_stat, rb);\r\n}\r\nstatic struct lock_stat *lock_stat_findnew(void *addr, const char *name)\r\n{\r\nstruct list_head *entry = lockhashentry(addr);\r\nstruct lock_stat *ret, *new;\r\nlist_for_each_entry(ret, entry, hash_entry) {\r\nif (ret->addr == addr)\r\nreturn ret;\r\n}\r\nnew = zalloc(sizeof(struct lock_stat));\r\nif (!new)\r\ngoto alloc_failed;\r\nnew->addr = addr;\r\nnew->name = zalloc(sizeof(char) * strlen(name) + 1);\r\nif (!new->name)\r\ngoto alloc_failed;\r\nstrcpy(new->name, name);\r\nnew->wait_time_min = ULLONG_MAX;\r\nlist_add(&new->hash_entry, entry);\r\nreturn new;\r\nalloc_failed:\r\npr_err("memory allocation failed\n");\r\nreturn NULL;\r\n}\r\nstatic struct lock_seq_stat *get_seq(struct thread_stat *ts, void *addr)\r\n{\r\nstruct lock_seq_stat *seq;\r\nlist_for_each_entry(seq, &ts->seq_list, list) {\r\nif (seq->addr == addr)\r\nreturn seq;\r\n}\r\nseq = zalloc(sizeof(struct lock_seq_stat));\r\nif (!seq) {\r\npr_err("memory allocation failed\n");\r\nreturn NULL;\r\n}\r\nseq->state = SEQ_STATE_UNINITIALIZED;\r\nseq->addr = addr;\r\nlist_add(&seq->list, &ts->seq_list);\r\nreturn seq;\r\n}\r\nstatic int report_lock_acquire_event(struct perf_evsel *evsel,\r\nstruct perf_sample *sample)\r\n{\r\nvoid *addr;\r\nstruct lock_stat *ls;\r\nstruct thread_stat *ts;\r\nstruct lock_seq_stat *seq;\r\nconst char *name = perf_evsel__strval(evsel, sample, "name");\r\nu64 tmp = perf_evsel__intval(evsel, sample, "lockdep_addr");\r\nint flag = perf_evsel__intval(evsel, sample, "flag");\r\nmemcpy(&addr, &tmp, sizeof(void *));\r\nls = lock_stat_findnew(addr, name);\r\nif (!ls)\r\nreturn -1;\r\nif (ls->discard)\r\nreturn 0;\r\nts = thread_stat_findnew(sample->tid);\r\nif (!ts)\r\nreturn -1;\r\nseq = get_seq(ts, addr);\r\nif (!seq)\r\nreturn -1;\r\nswitch (seq->state) {\r\ncase SEQ_STATE_UNINITIALIZED:\r\ncase SEQ_STATE_RELEASED:\r\nif (!flag) {\r\nseq->state = SEQ_STATE_ACQUIRING;\r\n} else {\r\nif (flag & TRY_LOCK)\r\nls->nr_trylock++;\r\nif (flag & READ_LOCK)\r\nls->nr_readlock++;\r\nseq->state = SEQ_STATE_READ_ACQUIRED;\r\nseq->read_count = 1;\r\nls->nr_acquired++;\r\n}\r\nbreak;\r\ncase SEQ_STATE_READ_ACQUIRED:\r\nif (flag & READ_LOCK) {\r\nseq->read_count++;\r\nls->nr_acquired++;\r\ngoto end;\r\n} else {\r\ngoto broken;\r\n}\r\nbreak;\r\ncase SEQ_STATE_ACQUIRED:\r\ncase SEQ_STATE_ACQUIRING:\r\ncase SEQ_STATE_CONTENDED:\r\nbroken:\r\nls->discard = 1;\r\nbad_hist[BROKEN_ACQUIRE]++;\r\nlist_del(&seq->list);\r\nfree(seq);\r\ngoto end;\r\nbreak;\r\ndefault:\r\nBUG_ON("Unknown state of lock sequence found!\n");\r\nbreak;\r\n}\r\nls->nr_acquire++;\r\nseq->prev_event_time = sample->time;\r\nend:\r\nreturn 0;\r\n}\r\nstatic int report_lock_acquired_event(struct perf_evsel *evsel,\r\nstruct perf_sample *sample)\r\n{\r\nvoid *addr;\r\nstruct lock_stat *ls;\r\nstruct thread_stat *ts;\r\nstruct lock_seq_stat *seq;\r\nu64 contended_term;\r\nconst char *name = perf_evsel__strval(evsel, sample, "name");\r\nu64 tmp = perf_evsel__intval(evsel, sample, "lockdep_addr");\r\nmemcpy(&addr, &tmp, sizeof(void *));\r\nls = lock_stat_findnew(addr, name);\r\nif (!ls)\r\nreturn -1;\r\nif (ls->discard)\r\nreturn 0;\r\nts = thread_stat_findnew(sample->tid);\r\nif (!ts)\r\nreturn -1;\r\nseq = get_seq(ts, addr);\r\nif (!seq)\r\nreturn -1;\r\nswitch (seq->state) {\r\ncase SEQ_STATE_UNINITIALIZED:\r\nreturn 0;\r\ncase SEQ_STATE_ACQUIRING:\r\nbreak;\r\ncase SEQ_STATE_CONTENDED:\r\ncontended_term = sample->time - seq->prev_event_time;\r\nls->wait_time_total += contended_term;\r\nif (contended_term < ls->wait_time_min)\r\nls->wait_time_min = contended_term;\r\nif (ls->wait_time_max < contended_term)\r\nls->wait_time_max = contended_term;\r\nbreak;\r\ncase SEQ_STATE_RELEASED:\r\ncase SEQ_STATE_ACQUIRED:\r\ncase SEQ_STATE_READ_ACQUIRED:\r\nls->discard = 1;\r\nbad_hist[BROKEN_ACQUIRED]++;\r\nlist_del(&seq->list);\r\nfree(seq);\r\ngoto end;\r\nbreak;\r\ndefault:\r\nBUG_ON("Unknown state of lock sequence found!\n");\r\nbreak;\r\n}\r\nseq->state = SEQ_STATE_ACQUIRED;\r\nls->nr_acquired++;\r\nseq->prev_event_time = sample->time;\r\nend:\r\nreturn 0;\r\n}\r\nstatic int report_lock_contended_event(struct perf_evsel *evsel,\r\nstruct perf_sample *sample)\r\n{\r\nvoid *addr;\r\nstruct lock_stat *ls;\r\nstruct thread_stat *ts;\r\nstruct lock_seq_stat *seq;\r\nconst char *name = perf_evsel__strval(evsel, sample, "name");\r\nu64 tmp = perf_evsel__intval(evsel, sample, "lockdep_addr");\r\nmemcpy(&addr, &tmp, sizeof(void *));\r\nls = lock_stat_findnew(addr, name);\r\nif (!ls)\r\nreturn -1;\r\nif (ls->discard)\r\nreturn 0;\r\nts = thread_stat_findnew(sample->tid);\r\nif (!ts)\r\nreturn -1;\r\nseq = get_seq(ts, addr);\r\nif (!seq)\r\nreturn -1;\r\nswitch (seq->state) {\r\ncase SEQ_STATE_UNINITIALIZED:\r\nreturn 0;\r\ncase SEQ_STATE_ACQUIRING:\r\nbreak;\r\ncase SEQ_STATE_RELEASED:\r\ncase SEQ_STATE_ACQUIRED:\r\ncase SEQ_STATE_READ_ACQUIRED:\r\ncase SEQ_STATE_CONTENDED:\r\nls->discard = 1;\r\nbad_hist[BROKEN_CONTENDED]++;\r\nlist_del(&seq->list);\r\nfree(seq);\r\ngoto end;\r\nbreak;\r\ndefault:\r\nBUG_ON("Unknown state of lock sequence found!\n");\r\nbreak;\r\n}\r\nseq->state = SEQ_STATE_CONTENDED;\r\nls->nr_contended++;\r\nseq->prev_event_time = sample->time;\r\nend:\r\nreturn 0;\r\n}\r\nstatic int report_lock_release_event(struct perf_evsel *evsel,\r\nstruct perf_sample *sample)\r\n{\r\nvoid *addr;\r\nstruct lock_stat *ls;\r\nstruct thread_stat *ts;\r\nstruct lock_seq_stat *seq;\r\nconst char *name = perf_evsel__strval(evsel, sample, "name");\r\nu64 tmp = perf_evsel__intval(evsel, sample, "lockdep_addr");\r\nmemcpy(&addr, &tmp, sizeof(void *));\r\nls = lock_stat_findnew(addr, name);\r\nif (!ls)\r\nreturn -1;\r\nif (ls->discard)\r\nreturn 0;\r\nts = thread_stat_findnew(sample->tid);\r\nif (!ts)\r\nreturn -1;\r\nseq = get_seq(ts, addr);\r\nif (!seq)\r\nreturn -1;\r\nswitch (seq->state) {\r\ncase SEQ_STATE_UNINITIALIZED:\r\ngoto end;\r\nbreak;\r\ncase SEQ_STATE_ACQUIRED:\r\nbreak;\r\ncase SEQ_STATE_READ_ACQUIRED:\r\nseq->read_count--;\r\nBUG_ON(seq->read_count < 0);\r\nif (!seq->read_count) {\r\nls->nr_release++;\r\ngoto end;\r\n}\r\nbreak;\r\ncase SEQ_STATE_ACQUIRING:\r\ncase SEQ_STATE_CONTENDED:\r\ncase SEQ_STATE_RELEASED:\r\nls->discard = 1;\r\nbad_hist[BROKEN_RELEASE]++;\r\ngoto free_seq;\r\nbreak;\r\ndefault:\r\nBUG_ON("Unknown state of lock sequence found!\n");\r\nbreak;\r\n}\r\nls->nr_release++;\r\nfree_seq:\r\nlist_del(&seq->list);\r\nfree(seq);\r\nend:\r\nreturn 0;\r\n}\r\nstatic int perf_evsel__process_lock_acquire(struct perf_evsel *evsel,\r\nstruct perf_sample *sample)\r\n{\r\nif (trace_handler->acquire_event)\r\nreturn trace_handler->acquire_event(evsel, sample);\r\nreturn 0;\r\n}\r\nstatic int perf_evsel__process_lock_acquired(struct perf_evsel *evsel,\r\nstruct perf_sample *sample)\r\n{\r\nif (trace_handler->acquired_event)\r\nreturn trace_handler->acquired_event(evsel, sample);\r\nreturn 0;\r\n}\r\nstatic int perf_evsel__process_lock_contended(struct perf_evsel *evsel,\r\nstruct perf_sample *sample)\r\n{\r\nif (trace_handler->contended_event)\r\nreturn trace_handler->contended_event(evsel, sample);\r\nreturn 0;\r\n}\r\nstatic int perf_evsel__process_lock_release(struct perf_evsel *evsel,\r\nstruct perf_sample *sample)\r\n{\r\nif (trace_handler->release_event)\r\nreturn trace_handler->release_event(evsel, sample);\r\nreturn 0;\r\n}\r\nstatic void print_bad_events(int bad, int total)\r\n{\r\nint i;\r\nconst char *name[4] =\r\n{ "acquire", "acquired", "contended", "release" };\r\npr_info("\n=== output for debug===\n\n");\r\npr_info("bad: %d, total: %d\n", bad, total);\r\npr_info("bad rate: %f %%\n", (double)bad / (double)total * 100);\r\npr_info("histogram of events caused bad sequence\n");\r\nfor (i = 0; i < BROKEN_MAX; i++)\r\npr_info(" %10s: %d\n", name[i], bad_hist[i]);\r\n}\r\nstatic void print_result(void)\r\n{\r\nstruct lock_stat *st;\r\nchar cut_name[20];\r\nint bad, total;\r\npr_info("%20s ", "Name");\r\npr_info("%10s ", "acquired");\r\npr_info("%10s ", "contended");\r\npr_info("%15s ", "total wait (ns)");\r\npr_info("%15s ", "max wait (ns)");\r\npr_info("%15s ", "min wait (ns)");\r\npr_info("\n\n");\r\nbad = total = 0;\r\nwhile ((st = pop_from_result())) {\r\ntotal++;\r\nif (st->discard) {\r\nbad++;\r\ncontinue;\r\n}\r\nbzero(cut_name, 20);\r\nif (strlen(st->name) < 16) {\r\npr_info("%20s ", st->name);\r\n} else {\r\nstrncpy(cut_name, st->name, 16);\r\ncut_name[16] = '.';\r\ncut_name[17] = '.';\r\ncut_name[18] = '.';\r\ncut_name[19] = '\0';\r\npr_info("%20s ", cut_name);\r\n}\r\npr_info("%10u ", st->nr_acquired);\r\npr_info("%10u ", st->nr_contended);\r\npr_info("%15" PRIu64 " ", st->wait_time_total);\r\npr_info("%15" PRIu64 " ", st->wait_time_max);\r\npr_info("%15" PRIu64 " ", st->wait_time_min == ULLONG_MAX ?\r\n0 : st->wait_time_min);\r\npr_info("\n");\r\n}\r\nprint_bad_events(bad, total);\r\n}\r\nstatic void dump_threads(void)\r\n{\r\nstruct thread_stat *st;\r\nstruct rb_node *node;\r\nstruct thread *t;\r\npr_info("%10s: comm\n", "Thread ID");\r\nnode = rb_first(&thread_stats);\r\nwhile (node) {\r\nst = container_of(node, struct thread_stat, rb);\r\nt = perf_session__findnew(session, st->tid);\r\npr_info("%10d: %s\n", st->tid, t->comm);\r\nnode = rb_next(node);\r\n};\r\n}\r\nstatic void dump_map(void)\r\n{\r\nunsigned int i;\r\nstruct lock_stat *st;\r\npr_info("Address of instance: name of class\n");\r\nfor (i = 0; i < LOCKHASH_SIZE; i++) {\r\nlist_for_each_entry(st, &lockhash_table[i], hash_entry) {\r\npr_info(" %p: %s\n", st->addr, st->name);\r\n}\r\n}\r\n}\r\nstatic int dump_info(void)\r\n{\r\nint rc = 0;\r\nif (info_threads)\r\ndump_threads();\r\nelse if (info_map)\r\ndump_map();\r\nelse {\r\nrc = -1;\r\npr_err("Unknown type of information\n");\r\n}\r\nreturn rc;\r\n}\r\nstatic int process_sample_event(struct perf_tool *tool __maybe_unused,\r\nunion perf_event *event,\r\nstruct perf_sample *sample,\r\nstruct perf_evsel *evsel,\r\nstruct machine *machine)\r\n{\r\nstruct thread *thread = machine__findnew_thread(machine, sample->tid);\r\nif (thread == NULL) {\r\npr_debug("problem processing %d event, skipping it.\n",\r\nevent->header.type);\r\nreturn -1;\r\n}\r\nif (evsel->handler.func != NULL) {\r\ntracepoint_handler f = evsel->handler.func;\r\nreturn f(evsel, sample);\r\n}\r\nreturn 0;\r\n}\r\nstatic int read_events(void)\r\n{\r\nstruct perf_tool eops = {\r\n.sample = process_sample_event,\r\n.comm = perf_event__process_comm,\r\n.ordered_samples = true,\r\n};\r\nsession = perf_session__new(input_name, O_RDONLY, 0, false, &eops);\r\nif (!session) {\r\npr_err("Initializing perf session failed\n");\r\nreturn -1;\r\n}\r\nif (perf_session__set_tracepoints_handlers(session, lock_tracepoints)) {\r\npr_err("Initializing perf session tracepoint handlers failed\n");\r\nreturn -1;\r\n}\r\nreturn perf_session__process_events(session, &eops);\r\n}\r\nstatic void sort_result(void)\r\n{\r\nunsigned int i;\r\nstruct lock_stat *st;\r\nfor (i = 0; i < LOCKHASH_SIZE; i++) {\r\nlist_for_each_entry(st, &lockhash_table[i], hash_entry) {\r\ninsert_to_result(st, compare);\r\n}\r\n}\r\n}\r\nstatic int __cmd_report(void)\r\n{\r\nsetup_pager();\r\nif ((select_key() != 0) ||\r\n(read_events() != 0))\r\nreturn -1;\r\nsort_result();\r\nprint_result();\r\nreturn 0;\r\n}\r\nstatic int __cmd_record(int argc, const char **argv)\r\n{\r\nconst char *record_args[] = {\r\n"record", "-R", "-f", "-m", "1024", "-c", "1",\r\n};\r\nunsigned int rec_argc, i, j;\r\nconst char **rec_argv;\r\nfor (i = 0; i < ARRAY_SIZE(lock_tracepoints); i++) {\r\nif (!is_valid_tracepoint(lock_tracepoints[i].name)) {\r\npr_err("tracepoint %s is not enabled. "\r\n"Are CONFIG_LOCKDEP and CONFIG_LOCK_STAT enabled?\n",\r\nlock_tracepoints[i].name);\r\nreturn 1;\r\n}\r\n}\r\nrec_argc = ARRAY_SIZE(record_args) + argc - 1;\r\nrec_argc += 2 * ARRAY_SIZE(lock_tracepoints);\r\nrec_argv = calloc(rec_argc + 1, sizeof(char *));\r\nif (rec_argv == NULL)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < ARRAY_SIZE(record_args); i++)\r\nrec_argv[i] = strdup(record_args[i]);\r\nfor (j = 0; j < ARRAY_SIZE(lock_tracepoints); j++) {\r\nrec_argv[i++] = "-e";\r\nrec_argv[i++] = strdup(lock_tracepoints[j].name);\r\n}\r\nfor (j = 1; j < (unsigned int)argc; j++, i++)\r\nrec_argv[i] = argv[j];\r\nBUG_ON(i != rec_argc);\r\nreturn cmd_record(i, rec_argv, NULL);\r\n}\r\nint cmd_lock(int argc, const char **argv, const char *prefix __maybe_unused)\r\n{\r\nconst struct option info_options[] = {\r\nOPT_BOOLEAN('t', "threads", &info_threads,\r\n"dump thread list in perf.data"),\r\nOPT_BOOLEAN('m', "map", &info_map,\r\n"map of lock instances (address:name table)"),\r\nOPT_END()\r\n};\r\nconst struct option lock_options[] = {\r\nOPT_STRING('i', "input", &input_name, "file", "input file name"),\r\nOPT_INCR('v', "verbose", &verbose, "be more verbose (show symbol address, etc)"),\r\nOPT_BOOLEAN('D', "dump-raw-trace", &dump_trace, "dump raw trace in ASCII"),\r\nOPT_END()\r\n};\r\nconst struct option report_options[] = {\r\nOPT_STRING('k', "key", &sort_key, "acquired",\r\n"key for sorting (acquired / contended / wait_total / wait_max / wait_min)"),\r\nOPT_END()\r\n};\r\nconst char * const info_usage[] = {\r\n"perf lock info [<options>]",\r\nNULL\r\n};\r\nconst char * const lock_usage[] = {\r\n"perf lock [<options>] {record|report|script|info}",\r\nNULL\r\n};\r\nconst char * const report_usage[] = {\r\n"perf lock report [<options>]",\r\nNULL\r\n};\r\nunsigned int i;\r\nint rc = 0;\r\nsymbol__init();\r\nfor (i = 0; i < LOCKHASH_SIZE; i++)\r\nINIT_LIST_HEAD(lockhash_table + i);\r\nargc = parse_options(argc, argv, lock_options, lock_usage,\r\nPARSE_OPT_STOP_AT_NON_OPTION);\r\nif (!argc)\r\nusage_with_options(lock_usage, lock_options);\r\nif (!strncmp(argv[0], "rec", 3)) {\r\nreturn __cmd_record(argc, argv);\r\n} else if (!strncmp(argv[0], "report", 6)) {\r\ntrace_handler = &report_lock_ops;\r\nif (argc) {\r\nargc = parse_options(argc, argv,\r\nreport_options, report_usage, 0);\r\nif (argc)\r\nusage_with_options(report_usage, report_options);\r\n}\r\n__cmd_report();\r\n} else if (!strcmp(argv[0], "script")) {\r\nreturn cmd_script(argc, argv, prefix);\r\n} else if (!strcmp(argv[0], "info")) {\r\nif (argc) {\r\nargc = parse_options(argc, argv,\r\ninfo_options, info_usage, 0);\r\nif (argc)\r\nusage_with_options(info_usage, info_options);\r\n}\r\ntrace_handler = &report_lock_ops;\r\nsetup_pager();\r\nif (read_events() != 0)\r\nrc = -1;\r\nelse\r\nrc = dump_info();\r\n} else {\r\nusage_with_options(lock_usage, lock_options);\r\n}\r\nreturn rc;\r\n}
