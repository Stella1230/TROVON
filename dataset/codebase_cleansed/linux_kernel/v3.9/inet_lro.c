static int lro_tcp_ip_check(const struct iphdr *iph, const struct tcphdr *tcph,\r\nint len, const struct net_lro_desc *lro_desc)\r\n{\r\nif (ntohs(iph->tot_len) != len)\r\nreturn -1;\r\nif (TCP_PAYLOAD_LENGTH(iph, tcph) == 0)\r\nreturn -1;\r\nif (iph->ihl != IPH_LEN_WO_OPTIONS)\r\nreturn -1;\r\nif (tcph->cwr || tcph->ece || tcph->urg || !tcph->ack ||\r\ntcph->rst || tcph->syn || tcph->fin)\r\nreturn -1;\r\nif (INET_ECN_is_ce(ipv4_get_dsfield(iph)))\r\nreturn -1;\r\nif (tcph->doff != TCPH_LEN_WO_OPTIONS &&\r\ntcph->doff != TCPH_LEN_W_TIMESTAMP)\r\nreturn -1;\r\nif (tcph->doff == TCPH_LEN_W_TIMESTAMP) {\r\n__be32 *topt = (__be32 *)(tcph + 1);\r\nif (*topt != htonl((TCPOPT_NOP << 24) | (TCPOPT_NOP << 16)\r\n| (TCPOPT_TIMESTAMP << 8)\r\n| TCPOLEN_TIMESTAMP))\r\nreturn -1;\r\ntopt++;\r\nif (lro_desc && after(ntohl(lro_desc->tcp_rcv_tsval),\r\nntohl(*topt)))\r\nreturn -1;\r\ntopt++;\r\nif (*topt == 0)\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic void lro_update_tcp_ip_header(struct net_lro_desc *lro_desc)\r\n{\r\nstruct iphdr *iph = lro_desc->iph;\r\nstruct tcphdr *tcph = lro_desc->tcph;\r\n__be32 *p;\r\n__wsum tcp_hdr_csum;\r\ntcph->ack_seq = lro_desc->tcp_ack;\r\ntcph->window = lro_desc->tcp_window;\r\nif (lro_desc->tcp_saw_tstamp) {\r\np = (__be32 *)(tcph + 1);\r\n*(p+2) = lro_desc->tcp_rcv_tsecr;\r\n}\r\niph->tot_len = htons(lro_desc->ip_tot_len);\r\niph->check = 0;\r\niph->check = ip_fast_csum((u8 *)lro_desc->iph, iph->ihl);\r\ntcph->check = 0;\r\ntcp_hdr_csum = csum_partial(tcph, TCP_HDR_LEN(tcph), 0);\r\nlro_desc->data_csum = csum_add(lro_desc->data_csum, tcp_hdr_csum);\r\ntcph->check = csum_tcpudp_magic(iph->saddr, iph->daddr,\r\nlro_desc->ip_tot_len -\r\nIP_HDR_LEN(iph), IPPROTO_TCP,\r\nlro_desc->data_csum);\r\n}\r\nstatic __wsum lro_tcp_data_csum(struct iphdr *iph, struct tcphdr *tcph, int len)\r\n{\r\n__wsum tcp_csum;\r\n__wsum tcp_hdr_csum;\r\n__wsum tcp_ps_hdr_csum;\r\ntcp_csum = ~csum_unfold(tcph->check);\r\ntcp_hdr_csum = csum_partial(tcph, TCP_HDR_LEN(tcph), tcp_csum);\r\ntcp_ps_hdr_csum = csum_tcpudp_nofold(iph->saddr, iph->daddr,\r\nlen + TCP_HDR_LEN(tcph),\r\nIPPROTO_TCP, 0);\r\nreturn csum_sub(csum_sub(tcp_csum, tcp_hdr_csum),\r\ntcp_ps_hdr_csum);\r\n}\r\nstatic void lro_init_desc(struct net_lro_desc *lro_desc, struct sk_buff *skb,\r\nstruct iphdr *iph, struct tcphdr *tcph)\r\n{\r\nint nr_frags;\r\n__be32 *ptr;\r\nu32 tcp_data_len = TCP_PAYLOAD_LENGTH(iph, tcph);\r\nnr_frags = skb_shinfo(skb)->nr_frags;\r\nlro_desc->parent = skb;\r\nlro_desc->next_frag = &(skb_shinfo(skb)->frags[nr_frags]);\r\nlro_desc->iph = iph;\r\nlro_desc->tcph = tcph;\r\nlro_desc->tcp_next_seq = ntohl(tcph->seq) + tcp_data_len;\r\nlro_desc->tcp_ack = tcph->ack_seq;\r\nlro_desc->tcp_window = tcph->window;\r\nlro_desc->pkt_aggr_cnt = 1;\r\nlro_desc->ip_tot_len = ntohs(iph->tot_len);\r\nif (tcph->doff == 8) {\r\nptr = (__be32 *)(tcph+1);\r\nlro_desc->tcp_saw_tstamp = 1;\r\nlro_desc->tcp_rcv_tsval = *(ptr+1);\r\nlro_desc->tcp_rcv_tsecr = *(ptr+2);\r\n}\r\nlro_desc->mss = tcp_data_len;\r\nlro_desc->active = 1;\r\nlro_desc->data_csum = lro_tcp_data_csum(iph, tcph,\r\ntcp_data_len);\r\n}\r\nstatic inline void lro_clear_desc(struct net_lro_desc *lro_desc)\r\n{\r\nmemset(lro_desc, 0, sizeof(struct net_lro_desc));\r\n}\r\nstatic void lro_add_common(struct net_lro_desc *lro_desc, struct iphdr *iph,\r\nstruct tcphdr *tcph, int tcp_data_len)\r\n{\r\nstruct sk_buff *parent = lro_desc->parent;\r\n__be32 *topt;\r\nlro_desc->pkt_aggr_cnt++;\r\nlro_desc->ip_tot_len += tcp_data_len;\r\nlro_desc->tcp_next_seq += tcp_data_len;\r\nlro_desc->tcp_window = tcph->window;\r\nlro_desc->tcp_ack = tcph->ack_seq;\r\nif (lro_desc->tcp_saw_tstamp) {\r\ntopt = (__be32 *) (tcph + 1);\r\nlro_desc->tcp_rcv_tsecr = *(topt + 2);\r\n}\r\nlro_desc->data_csum = csum_block_add(lro_desc->data_csum,\r\nlro_tcp_data_csum(iph, tcph,\r\ntcp_data_len),\r\nparent->len);\r\nparent->len += tcp_data_len;\r\nparent->data_len += tcp_data_len;\r\nif (tcp_data_len > lro_desc->mss)\r\nlro_desc->mss = tcp_data_len;\r\n}\r\nstatic void lro_add_packet(struct net_lro_desc *lro_desc, struct sk_buff *skb,\r\nstruct iphdr *iph, struct tcphdr *tcph)\r\n{\r\nstruct sk_buff *parent = lro_desc->parent;\r\nint tcp_data_len = TCP_PAYLOAD_LENGTH(iph, tcph);\r\nlro_add_common(lro_desc, iph, tcph, tcp_data_len);\r\nskb_pull(skb, (skb->len - tcp_data_len));\r\nparent->truesize += skb->truesize;\r\nif (lro_desc->last_skb)\r\nlro_desc->last_skb->next = skb;\r\nelse\r\nskb_shinfo(parent)->frag_list = skb;\r\nlro_desc->last_skb = skb;\r\n}\r\nstatic void lro_add_frags(struct net_lro_desc *lro_desc,\r\nint len, int hlen, int truesize,\r\nstruct skb_frag_struct *skb_frags,\r\nstruct iphdr *iph, struct tcphdr *tcph)\r\n{\r\nstruct sk_buff *skb = lro_desc->parent;\r\nint tcp_data_len = TCP_PAYLOAD_LENGTH(iph, tcph);\r\nlro_add_common(lro_desc, iph, tcph, tcp_data_len);\r\nskb->truesize += truesize;\r\nskb_frags[0].page_offset += hlen;\r\nskb_frag_size_sub(&skb_frags[0], hlen);\r\nwhile (tcp_data_len > 0) {\r\n*(lro_desc->next_frag) = *skb_frags;\r\ntcp_data_len -= skb_frag_size(skb_frags);\r\nlro_desc->next_frag++;\r\nskb_frags++;\r\nskb_shinfo(skb)->nr_frags++;\r\n}\r\n}\r\nstatic int lro_check_tcp_conn(struct net_lro_desc *lro_desc,\r\nstruct iphdr *iph,\r\nstruct tcphdr *tcph)\r\n{\r\nif ((lro_desc->iph->saddr != iph->saddr) ||\r\n(lro_desc->iph->daddr != iph->daddr) ||\r\n(lro_desc->tcph->source != tcph->source) ||\r\n(lro_desc->tcph->dest != tcph->dest))\r\nreturn -1;\r\nreturn 0;\r\n}\r\nstatic struct net_lro_desc *lro_get_desc(struct net_lro_mgr *lro_mgr,\r\nstruct net_lro_desc *lro_arr,\r\nstruct iphdr *iph,\r\nstruct tcphdr *tcph)\r\n{\r\nstruct net_lro_desc *lro_desc = NULL;\r\nstruct net_lro_desc *tmp;\r\nint max_desc = lro_mgr->max_desc;\r\nint i;\r\nfor (i = 0; i < max_desc; i++) {\r\ntmp = &lro_arr[i];\r\nif (tmp->active)\r\nif (!lro_check_tcp_conn(tmp, iph, tcph)) {\r\nlro_desc = tmp;\r\ngoto out;\r\n}\r\n}\r\nfor (i = 0; i < max_desc; i++) {\r\nif (!lro_arr[i].active) {\r\nlro_desc = &lro_arr[i];\r\ngoto out;\r\n}\r\n}\r\nLRO_INC_STATS(lro_mgr, no_desc);\r\nout:\r\nreturn lro_desc;\r\n}\r\nstatic void lro_flush(struct net_lro_mgr *lro_mgr,\r\nstruct net_lro_desc *lro_desc)\r\n{\r\nif (lro_desc->pkt_aggr_cnt > 1)\r\nlro_update_tcp_ip_header(lro_desc);\r\nskb_shinfo(lro_desc->parent)->gso_size = lro_desc->mss;\r\nif (lro_mgr->features & LRO_F_NAPI)\r\nnetif_receive_skb(lro_desc->parent);\r\nelse\r\nnetif_rx(lro_desc->parent);\r\nLRO_INC_STATS(lro_mgr, flushed);\r\nlro_clear_desc(lro_desc);\r\n}\r\nstatic int __lro_proc_skb(struct net_lro_mgr *lro_mgr, struct sk_buff *skb,\r\nvoid *priv)\r\n{\r\nstruct net_lro_desc *lro_desc;\r\nstruct iphdr *iph;\r\nstruct tcphdr *tcph;\r\nu64 flags;\r\nint vlan_hdr_len = 0;\r\nif (!lro_mgr->get_skb_header ||\r\nlro_mgr->get_skb_header(skb, (void *)&iph, (void *)&tcph,\r\n&flags, priv))\r\ngoto out;\r\nif (!(flags & LRO_IPV4) || !(flags & LRO_TCP))\r\ngoto out;\r\nlro_desc = lro_get_desc(lro_mgr, lro_mgr->lro_arr, iph, tcph);\r\nif (!lro_desc)\r\ngoto out;\r\nif ((skb->protocol == htons(ETH_P_8021Q)) &&\r\n!(lro_mgr->features & LRO_F_EXTRACT_VLAN_ID))\r\nvlan_hdr_len = VLAN_HLEN;\r\nif (!lro_desc->active) {\r\nif (lro_tcp_ip_check(iph, tcph, skb->len - vlan_hdr_len, NULL))\r\ngoto out;\r\nskb->ip_summed = lro_mgr->ip_summed_aggr;\r\nlro_init_desc(lro_desc, skb, iph, tcph);\r\nLRO_INC_STATS(lro_mgr, aggregated);\r\nreturn 0;\r\n}\r\nif (lro_desc->tcp_next_seq != ntohl(tcph->seq))\r\ngoto out2;\r\nif (lro_tcp_ip_check(iph, tcph, skb->len, lro_desc))\r\ngoto out2;\r\nlro_add_packet(lro_desc, skb, iph, tcph);\r\nLRO_INC_STATS(lro_mgr, aggregated);\r\nif ((lro_desc->pkt_aggr_cnt >= lro_mgr->max_aggr) ||\r\nlro_desc->parent->len > (0xFFFF - lro_mgr->dev->mtu))\r\nlro_flush(lro_mgr, lro_desc);\r\nreturn 0;\r\nout2:\r\nlro_flush(lro_mgr, lro_desc);\r\nout:\r\nreturn 1;\r\n}\r\nstatic struct sk_buff *lro_gen_skb(struct net_lro_mgr *lro_mgr,\r\nstruct skb_frag_struct *frags,\r\nint len, int true_size,\r\nvoid *mac_hdr,\r\nint hlen, __wsum sum,\r\nu32 ip_summed)\r\n{\r\nstruct sk_buff *skb;\r\nstruct skb_frag_struct *skb_frags;\r\nint data_len = len;\r\nint hdr_len = min(len, hlen);\r\nskb = netdev_alloc_skb(lro_mgr->dev, hlen + lro_mgr->frag_align_pad);\r\nif (!skb)\r\nreturn NULL;\r\nskb_reserve(skb, lro_mgr->frag_align_pad);\r\nskb->len = len;\r\nskb->data_len = len - hdr_len;\r\nskb->truesize += true_size;\r\nskb->tail += hdr_len;\r\nmemcpy(skb->data, mac_hdr, hdr_len);\r\nskb_frags = skb_shinfo(skb)->frags;\r\nwhile (data_len > 0) {\r\n*skb_frags = *frags;\r\ndata_len -= skb_frag_size(frags);\r\nskb_frags++;\r\nfrags++;\r\nskb_shinfo(skb)->nr_frags++;\r\n}\r\nskb_shinfo(skb)->frags[0].page_offset += hdr_len;\r\nskb_frag_size_sub(&skb_shinfo(skb)->frags[0], hdr_len);\r\nskb->ip_summed = ip_summed;\r\nskb->csum = sum;\r\nskb->protocol = eth_type_trans(skb, lro_mgr->dev);\r\nreturn skb;\r\n}\r\nstatic struct sk_buff *__lro_proc_segment(struct net_lro_mgr *lro_mgr,\r\nstruct skb_frag_struct *frags,\r\nint len, int true_size,\r\nvoid *priv, __wsum sum)\r\n{\r\nstruct net_lro_desc *lro_desc;\r\nstruct iphdr *iph;\r\nstruct tcphdr *tcph;\r\nstruct sk_buff *skb;\r\nu64 flags;\r\nvoid *mac_hdr;\r\nint mac_hdr_len;\r\nint hdr_len = LRO_MAX_PG_HLEN;\r\nint vlan_hdr_len = 0;\r\nif (!lro_mgr->get_frag_header ||\r\nlro_mgr->get_frag_header(frags, (void *)&mac_hdr, (void *)&iph,\r\n(void *)&tcph, &flags, priv)) {\r\nmac_hdr = skb_frag_address(frags);\r\ngoto out1;\r\n}\r\nif (!(flags & LRO_IPV4) || !(flags & LRO_TCP))\r\ngoto out1;\r\nhdr_len = (int)((void *)(tcph) + TCP_HDR_LEN(tcph) - mac_hdr);\r\nmac_hdr_len = (int)((void *)(iph) - mac_hdr);\r\nlro_desc = lro_get_desc(lro_mgr, lro_mgr->lro_arr, iph, tcph);\r\nif (!lro_desc)\r\ngoto out1;\r\nif (!lro_desc->active) {\r\nif (lro_tcp_ip_check(iph, tcph, len - mac_hdr_len, NULL))\r\ngoto out1;\r\nskb = lro_gen_skb(lro_mgr, frags, len, true_size, mac_hdr,\r\nhdr_len, 0, lro_mgr->ip_summed_aggr);\r\nif (!skb)\r\ngoto out;\r\nif ((skb->protocol == htons(ETH_P_8021Q)) &&\r\n!(lro_mgr->features & LRO_F_EXTRACT_VLAN_ID))\r\nvlan_hdr_len = VLAN_HLEN;\r\niph = (void *)(skb->data + vlan_hdr_len);\r\ntcph = (void *)((u8 *)skb->data + vlan_hdr_len\r\n+ IP_HDR_LEN(iph));\r\nlro_init_desc(lro_desc, skb, iph, tcph);\r\nLRO_INC_STATS(lro_mgr, aggregated);\r\nreturn NULL;\r\n}\r\nif (lro_desc->tcp_next_seq != ntohl(tcph->seq))\r\ngoto out2;\r\nif (lro_tcp_ip_check(iph, tcph, len - mac_hdr_len, lro_desc))\r\ngoto out2;\r\nlro_add_frags(lro_desc, len, hdr_len, true_size, frags, iph, tcph);\r\nLRO_INC_STATS(lro_mgr, aggregated);\r\nif ((skb_shinfo(lro_desc->parent)->nr_frags >= lro_mgr->max_aggr) ||\r\nlro_desc->parent->len > (0xFFFF - lro_mgr->dev->mtu))\r\nlro_flush(lro_mgr, lro_desc);\r\nreturn NULL;\r\nout2:\r\nlro_flush(lro_mgr, lro_desc);\r\nout1:\r\nskb = lro_gen_skb(lro_mgr, frags, len, true_size, mac_hdr,\r\nhdr_len, sum, lro_mgr->ip_summed);\r\nout:\r\nreturn skb;\r\n}\r\nvoid lro_receive_skb(struct net_lro_mgr *lro_mgr,\r\nstruct sk_buff *skb,\r\nvoid *priv)\r\n{\r\nif (__lro_proc_skb(lro_mgr, skb, priv)) {\r\nif (lro_mgr->features & LRO_F_NAPI)\r\nnetif_receive_skb(skb);\r\nelse\r\nnetif_rx(skb);\r\n}\r\n}\r\nvoid lro_receive_frags(struct net_lro_mgr *lro_mgr,\r\nstruct skb_frag_struct *frags,\r\nint len, int true_size, void *priv, __wsum sum)\r\n{\r\nstruct sk_buff *skb;\r\nskb = __lro_proc_segment(lro_mgr, frags, len, true_size, priv, sum);\r\nif (!skb)\r\nreturn;\r\nif (lro_mgr->features & LRO_F_NAPI)\r\nnetif_receive_skb(skb);\r\nelse\r\nnetif_rx(skb);\r\n}\r\nvoid lro_flush_all(struct net_lro_mgr *lro_mgr)\r\n{\r\nint i;\r\nstruct net_lro_desc *lro_desc = lro_mgr->lro_arr;\r\nfor (i = 0; i < lro_mgr->max_desc; i++) {\r\nif (lro_desc[i].active)\r\nlro_flush(lro_mgr, &lro_desc[i]);\r\n}\r\n}\r\nvoid lro_flush_pkt(struct net_lro_mgr *lro_mgr,\r\nstruct iphdr *iph, struct tcphdr *tcph)\r\n{\r\nstruct net_lro_desc *lro_desc;\r\nlro_desc = lro_get_desc(lro_mgr, lro_mgr->lro_arr, iph, tcph);\r\nif (lro_desc->active)\r\nlro_flush(lro_mgr, lro_desc);\r\n}
