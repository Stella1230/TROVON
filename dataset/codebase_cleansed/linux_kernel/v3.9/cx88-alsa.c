static int _cx88_start_audio_dma(snd_cx88_card_t *chip)\r\n{\r\nstruct cx88_audio_buffer *buf = chip->buf;\r\nstruct cx88_core *core=chip->core;\r\nconst struct sram_channel *audio_ch = &cx88_sram_channels[SRAM_CH25];\r\ncx_clear(MO_AUD_DMACNTRL, 0x11);\r\ncx88_sram_channel_setup(chip->core, audio_ch, buf->bpl, buf->risc.dma);\r\ncx_write(MO_AUDD_LNGTH, buf->bpl);\r\ncx_write(MO_AUDD_GPCNTRL, GP_COUNT_CONTROL_RESET);\r\natomic_set(&chip->count, 0);\r\ndprintk(1, "Start audio DMA, %d B/line, %d lines/FIFO, %d periods, %d "\r\n"byte buffer\n", buf->bpl, cx_read(audio_ch->cmds_start + 8)>>1,\r\nchip->num_periods, buf->bpl * chip->num_periods);\r\ncx_write(MO_AUD_INTMSK, AUD_INT_OPC_ERR | AUD_INT_DN_SYNC |\r\nAUD_INT_DN_RISCI2 | AUD_INT_DN_RISCI1);\r\ncx_write(MO_AUD_INTSTAT, ~0);\r\ncx_set(MO_PCI_INTMSK, chip->core->pci_irqmask | PCI_INT_AUDINT);\r\ncx_set(MO_DEV_CNTRL2, (1<<5));\r\ncx_set(MO_AUD_DMACNTRL, 0x11);\r\nif (debug)\r\ncx88_sram_channel_dump(chip->core, audio_ch);\r\nreturn 0;\r\n}\r\nstatic int _cx88_stop_audio_dma(snd_cx88_card_t *chip)\r\n{\r\nstruct cx88_core *core=chip->core;\r\ndprintk(1, "Stopping audio DMA\n");\r\ncx_clear(MO_AUD_DMACNTRL, 0x11);\r\ncx_clear(MO_PCI_INTMSK, PCI_INT_AUDINT);\r\ncx_clear(MO_AUD_INTMSK, AUD_INT_OPC_ERR | AUD_INT_DN_SYNC |\r\nAUD_INT_DN_RISCI2 | AUD_INT_DN_RISCI1);\r\nif (debug)\r\ncx88_sram_channel_dump(chip->core, &cx88_sram_channels[SRAM_CH25]);\r\nreturn 0;\r\n}\r\nstatic void cx8801_aud_irq(snd_cx88_card_t *chip)\r\n{\r\nstruct cx88_core *core = chip->core;\r\nu32 status, mask;\r\nstatus = cx_read(MO_AUD_INTSTAT);\r\nmask = cx_read(MO_AUD_INTMSK);\r\nif (0 == (status & mask))\r\nreturn;\r\ncx_write(MO_AUD_INTSTAT, status);\r\nif (debug > 1 || (status & mask & ~0xff))\r\ncx88_print_irqbits(core->name, "irq aud",\r\ncx88_aud_irqs, ARRAY_SIZE(cx88_aud_irqs),\r\nstatus, mask);\r\nif (status & AUD_INT_OPC_ERR) {\r\nprintk(KERN_WARNING "%s/1: Audio risc op code error\n",core->name);\r\ncx_clear(MO_AUD_DMACNTRL, 0x11);\r\ncx88_sram_channel_dump(core, &cx88_sram_channels[SRAM_CH25]);\r\n}\r\nif (status & AUD_INT_DN_SYNC) {\r\ndprintk(1, "Downstream sync error\n");\r\ncx_write(MO_AUDD_GPCNTRL, GP_COUNT_CONTROL_RESET);\r\nreturn;\r\n}\r\nif (status & AUD_INT_DN_RISCI1) {\r\natomic_set(&chip->count, cx_read(MO_AUDD_GPCNT));\r\nsnd_pcm_period_elapsed(chip->substream);\r\n}\r\n}\r\nstatic irqreturn_t cx8801_irq(int irq, void *dev_id)\r\n{\r\nsnd_cx88_card_t *chip = dev_id;\r\nstruct cx88_core *core = chip->core;\r\nu32 status;\r\nint loop, handled = 0;\r\nfor (loop = 0; loop < MAX_IRQ_LOOP; loop++) {\r\nstatus = cx_read(MO_PCI_INTSTAT) &\r\n(core->pci_irqmask | PCI_INT_AUDINT);\r\nif (0 == status)\r\ngoto out;\r\ndprintk(3, "cx8801_irq loop %d/%d, status %x\n",\r\nloop, MAX_IRQ_LOOP, status);\r\nhandled = 1;\r\ncx_write(MO_PCI_INTSTAT, status);\r\nif (status & core->pci_irqmask)\r\ncx88_core_irq(core, status);\r\nif (status & PCI_INT_AUDINT)\r\ncx8801_aud_irq(chip);\r\n}\r\nif (MAX_IRQ_LOOP == loop) {\r\nprintk(KERN_ERR\r\n"%s/1: IRQ loop detected, disabling interrupts\n",\r\ncore->name);\r\ncx_clear(MO_PCI_INTMSK, PCI_INT_AUDINT);\r\n}\r\nout:\r\nreturn IRQ_RETVAL(handled);\r\n}\r\nstatic int dsp_buffer_free(snd_cx88_card_t *chip)\r\n{\r\nBUG_ON(!chip->dma_size);\r\ndprintk(2,"Freeing buffer\n");\r\nvideobuf_dma_unmap(&chip->pci->dev, chip->dma_risc);\r\nvideobuf_dma_free(chip->dma_risc);\r\nbtcx_riscmem_free(chip->pci,&chip->buf->risc);\r\nkfree(chip->buf);\r\nchip->dma_risc = NULL;\r\nchip->dma_size = 0;\r\nreturn 0;\r\n}\r\nstatic int snd_cx88_pcm_open(struct snd_pcm_substream *substream)\r\n{\r\nsnd_cx88_card_t *chip = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nint err;\r\nif (!chip) {\r\nprintk(KERN_ERR "BUG: cx88 can't find device struct."\r\n" Can't proceed with open\n");\r\nreturn -ENODEV;\r\n}\r\nerr = snd_pcm_hw_constraint_pow2(runtime, 0, SNDRV_PCM_HW_PARAM_PERIODS);\r\nif (err < 0)\r\ngoto _error;\r\nchip->substream = substream;\r\nruntime->hw = snd_cx88_digital_hw;\r\nif (cx88_sram_channels[SRAM_CH25].fifo_size != DEFAULT_FIFO_SIZE) {\r\nunsigned int bpl = cx88_sram_channels[SRAM_CH25].fifo_size / 4;\r\nbpl &= ~7;\r\nruntime->hw.period_bytes_min = bpl;\r\nruntime->hw.period_bytes_max = bpl;\r\n}\r\nreturn 0;\r\n_error:\r\ndprintk(1,"Error opening PCM!\n");\r\nreturn err;\r\n}\r\nstatic int snd_cx88_close(struct snd_pcm_substream *substream)\r\n{\r\nreturn 0;\r\n}\r\nstatic int snd_cx88_hw_params(struct snd_pcm_substream * substream,\r\nstruct snd_pcm_hw_params * hw_params)\r\n{\r\nsnd_cx88_card_t *chip = snd_pcm_substream_chip(substream);\r\nstruct videobuf_dmabuf *dma;\r\nstruct cx88_audio_buffer *buf;\r\nint ret;\r\nif (substream->runtime->dma_area) {\r\ndsp_buffer_free(chip);\r\nsubstream->runtime->dma_area = NULL;\r\n}\r\nchip->period_size = params_period_bytes(hw_params);\r\nchip->num_periods = params_periods(hw_params);\r\nchip->dma_size = chip->period_size * params_periods(hw_params);\r\nBUG_ON(!chip->dma_size);\r\nBUG_ON(chip->num_periods & (chip->num_periods-1));\r\nbuf = kzalloc(sizeof(*buf), GFP_KERNEL);\r\nif (NULL == buf)\r\nreturn -ENOMEM;\r\nbuf->bpl = chip->period_size;\r\ndma = &buf->dma;\r\nvideobuf_dma_init(dma);\r\nret = videobuf_dma_init_kernel(dma, PCI_DMA_FROMDEVICE,\r\n(PAGE_ALIGN(chip->dma_size) >> PAGE_SHIFT));\r\nif (ret < 0)\r\ngoto error;\r\nret = videobuf_dma_map(&chip->pci->dev, dma);\r\nif (ret < 0)\r\ngoto error;\r\nret = cx88_risc_databuffer(chip->pci, &buf->risc, dma->sglist,\r\nchip->period_size, chip->num_periods, 1);\r\nif (ret < 0)\r\ngoto error;\r\nbuf->risc.jmp[0] = cpu_to_le32(RISC_JUMP|RISC_IRQ1|RISC_CNT_INC);\r\nbuf->risc.jmp[1] = cpu_to_le32(buf->risc.dma);\r\nchip->buf = buf;\r\nchip->dma_risc = dma;\r\nsubstream->runtime->dma_area = chip->dma_risc->vaddr;\r\nsubstream->runtime->dma_bytes = chip->dma_size;\r\nsubstream->runtime->dma_addr = 0;\r\nreturn 0;\r\nerror:\r\nkfree(buf);\r\nreturn ret;\r\n}\r\nstatic int snd_cx88_hw_free(struct snd_pcm_substream * substream)\r\n{\r\nsnd_cx88_card_t *chip = snd_pcm_substream_chip(substream);\r\nif (substream->runtime->dma_area) {\r\ndsp_buffer_free(chip);\r\nsubstream->runtime->dma_area = NULL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_cx88_prepare(struct snd_pcm_substream *substream)\r\n{\r\nreturn 0;\r\n}\r\nstatic int snd_cx88_card_trigger(struct snd_pcm_substream *substream, int cmd)\r\n{\r\nsnd_cx88_card_t *chip = snd_pcm_substream_chip(substream);\r\nint err;\r\nspin_lock(&chip->reg_lock);\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\nerr=_cx88_start_audio_dma(chip);\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\nerr=_cx88_stop_audio_dma(chip);\r\nbreak;\r\ndefault:\r\nerr=-EINVAL;\r\nbreak;\r\n}\r\nspin_unlock(&chip->reg_lock);\r\nreturn err;\r\n}\r\nstatic snd_pcm_uframes_t snd_cx88_pointer(struct snd_pcm_substream *substream)\r\n{\r\nsnd_cx88_card_t *chip = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nu16 count;\r\ncount = atomic_read(&chip->count);\r\nreturn runtime->period_size * (count & (runtime->periods-1));\r\n}\r\nstatic struct page *snd_cx88_page(struct snd_pcm_substream *substream,\r\nunsigned long offset)\r\n{\r\nvoid *pageptr = substream->runtime->dma_area + offset;\r\nreturn vmalloc_to_page(pageptr);\r\n}\r\nstatic int snd_cx88_pcm(snd_cx88_card_t *chip, int device, const char *name)\r\n{\r\nint err;\r\nstruct snd_pcm *pcm;\r\nerr = snd_pcm_new(chip->card, name, device, 0, 1, &pcm);\r\nif (err < 0)\r\nreturn err;\r\npcm->private_data = chip;\r\nstrcpy(pcm->name, name);\r\nsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &snd_cx88_pcm_ops);\r\nreturn 0;\r\n}\r\nstatic int snd_cx88_volume_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *info)\r\n{\r\ninfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\r\ninfo->count = 2;\r\ninfo->value.integer.min = 0;\r\ninfo->value.integer.max = 0x3f;\r\nreturn 0;\r\n}\r\nstatic int snd_cx88_volume_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *value)\r\n{\r\nsnd_cx88_card_t *chip = snd_kcontrol_chip(kcontrol);\r\nstruct cx88_core *core=chip->core;\r\nint vol = 0x3f - (cx_read(AUD_VOL_CTL) & 0x3f),\r\nbal = cx_read(AUD_BAL_CTL);\r\nvalue->value.integer.value[(bal & 0x40) ? 0 : 1] = vol;\r\nvol -= (bal & 0x3f);\r\nvalue->value.integer.value[(bal & 0x40) ? 1 : 0] = vol < 0 ? 0 : vol;\r\nreturn 0;\r\n}\r\nstatic void snd_cx88_wm8775_volume_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *value)\r\n{\r\nsnd_cx88_card_t *chip = snd_kcontrol_chip(kcontrol);\r\nstruct cx88_core *core = chip->core;\r\nint left = value->value.integer.value[0];\r\nint right = value->value.integer.value[1];\r\nint v, b;\r\nif (left >= right) {\r\nv = left << 10;\r\nb = left ? (0x8000 * right) / left : 0x8000;\r\n} else {\r\nv = right << 10;\r\nb = right ? 0xffff - (0x8000 * left) / right : 0x8000;\r\n}\r\nwm8775_s_ctrl(core, V4L2_CID_AUDIO_VOLUME, v);\r\nwm8775_s_ctrl(core, V4L2_CID_AUDIO_BALANCE, b);\r\n}\r\nstatic int snd_cx88_volume_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *value)\r\n{\r\nsnd_cx88_card_t *chip = snd_kcontrol_chip(kcontrol);\r\nstruct cx88_core *core=chip->core;\r\nint left, right, v, b;\r\nint changed = 0;\r\nu32 old;\r\nif (core->board.audio_chip == V4L2_IDENT_WM8775)\r\nsnd_cx88_wm8775_volume_put(kcontrol, value);\r\nleft = value->value.integer.value[0] & 0x3f;\r\nright = value->value.integer.value[1] & 0x3f;\r\nb = right - left;\r\nif (b < 0) {\r\nv = 0x3f - left;\r\nb = (-b) | 0x40;\r\n} else {\r\nv = 0x3f - right;\r\n}\r\nspin_lock_irq(&chip->reg_lock);\r\nold = cx_read(AUD_VOL_CTL);\r\nif (v != (old & 0x3f)) {\r\ncx_swrite(SHADOW_AUD_VOL_CTL, AUD_VOL_CTL, (old & ~0x3f) | v);\r\nchanged = 1;\r\n}\r\nif ((cx_read(AUD_BAL_CTL) & 0x7f) != b) {\r\ncx_write(AUD_BAL_CTL, b);\r\nchanged = 1;\r\n}\r\nspin_unlock_irq(&chip->reg_lock);\r\nreturn changed;\r\n}\r\nstatic int snd_cx88_switch_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *value)\r\n{\r\nsnd_cx88_card_t *chip = snd_kcontrol_chip(kcontrol);\r\nstruct cx88_core *core = chip->core;\r\nu32 bit = kcontrol->private_value;\r\nvalue->value.integer.value[0] = !(cx_read(AUD_VOL_CTL) & bit);\r\nreturn 0;\r\n}\r\nstatic int snd_cx88_switch_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *value)\r\n{\r\nsnd_cx88_card_t *chip = snd_kcontrol_chip(kcontrol);\r\nstruct cx88_core *core = chip->core;\r\nu32 bit = kcontrol->private_value;\r\nint ret = 0;\r\nu32 vol;\r\nspin_lock_irq(&chip->reg_lock);\r\nvol = cx_read(AUD_VOL_CTL);\r\nif (value->value.integer.value[0] != !(vol & bit)) {\r\nvol ^= bit;\r\ncx_swrite(SHADOW_AUD_VOL_CTL, AUD_VOL_CTL, vol);\r\nif ((core->board.audio_chip == V4L2_IDENT_WM8775) &&\r\n((1<<6) == bit))\r\nwm8775_s_ctrl(core, V4L2_CID_AUDIO_MUTE, 0 != (vol & bit));\r\nret = 1;\r\n}\r\nspin_unlock_irq(&chip->reg_lock);\r\nreturn ret;\r\n}\r\nstatic int snd_cx88_alc_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *value)\r\n{\r\nsnd_cx88_card_t *chip = snd_kcontrol_chip(kcontrol);\r\nstruct cx88_core *core = chip->core;\r\ns32 val;\r\nval = wm8775_g_ctrl(core, V4L2_CID_AUDIO_LOUDNESS);\r\nvalue->value.integer.value[0] = val ? 1 : 0;\r\nreturn 0;\r\n}\r\nstatic int snd_cx88_alc_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *value)\r\n{\r\nsnd_cx88_card_t *chip = snd_kcontrol_chip(kcontrol);\r\nstruct cx88_core *core = chip->core;\r\nstruct v4l2_control client_ctl;\r\nmemset(&client_ctl, 0, sizeof(client_ctl));\r\nclient_ctl.value = 0 != value->value.integer.value[0];\r\nclient_ctl.id = V4L2_CID_AUDIO_LOUDNESS;\r\ncall_hw(core, WM8775_GID, core, s_ctrl, &client_ctl);\r\nreturn 0;\r\n}\r\nstatic int snd_cx88_free(snd_cx88_card_t *chip)\r\n{\r\nif (chip->irq >= 0)\r\nfree_irq(chip->irq, chip);\r\ncx88_core_put(chip->core,chip->pci);\r\npci_disable_device(chip->pci);\r\nreturn 0;\r\n}\r\nstatic void snd_cx88_dev_free(struct snd_card * card)\r\n{\r\nsnd_cx88_card_t *chip = card->private_data;\r\nsnd_cx88_free(chip);\r\n}\r\nstatic int snd_cx88_create(struct snd_card *card, struct pci_dev *pci,\r\nsnd_cx88_card_t **rchip,\r\nstruct cx88_core **core_ptr)\r\n{\r\nsnd_cx88_card_t *chip;\r\nstruct cx88_core *core;\r\nint err;\r\nunsigned char pci_lat;\r\n*rchip = NULL;\r\nerr = pci_enable_device(pci);\r\nif (err < 0)\r\nreturn err;\r\npci_set_master(pci);\r\nchip = card->private_data;\r\ncore = cx88_core_get(pci);\r\nif (NULL == core) {\r\nerr = -EINVAL;\r\nreturn err;\r\n}\r\nif (!pci_dma_supported(pci,DMA_BIT_MASK(32))) {\r\ndprintk(0, "%s/1: Oops: no 32bit PCI DMA ???\n",core->name);\r\nerr = -EIO;\r\ncx88_core_put(core, pci);\r\nreturn err;\r\n}\r\nchip->card = card;\r\nchip->pci = pci;\r\nchip->irq = -1;\r\nspin_lock_init(&chip->reg_lock);\r\nchip->core = core;\r\nerr = request_irq(chip->pci->irq, cx8801_irq,\r\nIRQF_SHARED | IRQF_DISABLED, chip->core->name, chip);\r\nif (err < 0) {\r\ndprintk(0, "%s: can't get IRQ %d\n",\r\nchip->core->name, chip->pci->irq);\r\nreturn err;\r\n}\r\npci_read_config_byte(pci, PCI_LATENCY_TIMER, &pci_lat);\r\ndprintk(1,"ALSA %s/%i: found at %s, rev: %d, irq: %d, "\r\n"latency: %d, mmio: 0x%llx\n", core->name, devno,\r\npci_name(pci), pci->revision, pci->irq,\r\npci_lat, (unsigned long long)pci_resource_start(pci,0));\r\nchip->irq = pci->irq;\r\nsynchronize_irq(chip->irq);\r\nsnd_card_set_dev(card, &pci->dev);\r\n*rchip = chip;\r\n*core_ptr = core;\r\nreturn 0;\r\n}\r\nstatic int cx88_audio_initdev(struct pci_dev *pci,\r\nconst struct pci_device_id *pci_id)\r\n{\r\nstruct snd_card *card;\r\nsnd_cx88_card_t *chip;\r\nstruct cx88_core *core = NULL;\r\nint err;\r\nif (devno >= SNDRV_CARDS)\r\nreturn (-ENODEV);\r\nif (!enable[devno]) {\r\n++devno;\r\nreturn (-ENOENT);\r\n}\r\nerr = snd_card_create(index[devno], id[devno], THIS_MODULE,\r\nsizeof(snd_cx88_card_t), &card);\r\nif (err < 0)\r\nreturn err;\r\ncard->private_free = snd_cx88_dev_free;\r\nerr = snd_cx88_create(card, pci, &chip, &core);\r\nif (err < 0)\r\ngoto error;\r\nerr = snd_cx88_pcm(chip, 0, "CX88 Digital");\r\nif (err < 0)\r\ngoto error;\r\nerr = snd_ctl_add(card, snd_ctl_new1(&snd_cx88_volume, chip));\r\nif (err < 0)\r\ngoto error;\r\nerr = snd_ctl_add(card, snd_ctl_new1(&snd_cx88_dac_switch, chip));\r\nif (err < 0)\r\ngoto error;\r\nerr = snd_ctl_add(card, snd_ctl_new1(&snd_cx88_source_switch, chip));\r\nif (err < 0)\r\ngoto error;\r\nif (core->board.audio_chip == V4L2_IDENT_WM8775)\r\nsnd_ctl_add(card, snd_ctl_new1(&snd_cx88_alc_switch, chip));\r\nstrcpy (card->driver, "CX88x");\r\nsprintf(card->shortname, "Conexant CX%x", pci->device);\r\nsprintf(card->longname, "%s at %#llx",\r\ncard->shortname,(unsigned long long)pci_resource_start(pci, 0));\r\nstrcpy (card->mixername, "CX88");\r\ndprintk (0, "%s/%i: ALSA support for cx2388x boards\n",\r\ncard->driver,devno);\r\nerr = snd_card_register(card);\r\nif (err < 0)\r\ngoto error;\r\npci_set_drvdata(pci,card);\r\ndevno++;\r\nreturn 0;\r\nerror:\r\nsnd_card_free(card);\r\nreturn err;\r\n}\r\nstatic void cx88_audio_finidev(struct pci_dev *pci)\r\n{\r\nstruct cx88_audio_dev *card = pci_get_drvdata(pci);\r\nsnd_card_free((void *)card);\r\npci_set_drvdata(pci, NULL);\r\ndevno--;\r\n}\r\nstatic int __init cx88_audio_init(void)\r\n{\r\nprintk(KERN_INFO "cx2388x alsa driver version %s loaded\n",\r\nCX88_VERSION);\r\nreturn pci_register_driver(&cx88_audio_pci_driver);\r\n}\r\nstatic void __exit cx88_audio_fini(void)\r\n{\r\npci_unregister_driver(&cx88_audio_pci_driver);\r\n}
