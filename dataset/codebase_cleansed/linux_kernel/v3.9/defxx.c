static inline void dfx_writel(DFX_board_t *bp, int offset, u32 data)\r\n{\r\nwritel(data, bp->base.mem + offset);\r\nmb();\r\n}\r\nstatic inline void dfx_outl(DFX_board_t *bp, int offset, u32 data)\r\n{\r\noutl(data, bp->base.port + offset);\r\n}\r\nstatic void dfx_port_write_long(DFX_board_t *bp, int offset, u32 data)\r\n{\r\nstruct device __maybe_unused *bdev = bp->bus_dev;\r\nint dfx_bus_tc = DFX_BUS_TC(bdev);\r\nint dfx_use_mmio = DFX_MMIO || dfx_bus_tc;\r\nif (dfx_use_mmio)\r\ndfx_writel(bp, offset, data);\r\nelse\r\ndfx_outl(bp, offset, data);\r\n}\r\nstatic inline void dfx_readl(DFX_board_t *bp, int offset, u32 *data)\r\n{\r\nmb();\r\n*data = readl(bp->base.mem + offset);\r\n}\r\nstatic inline void dfx_inl(DFX_board_t *bp, int offset, u32 *data)\r\n{\r\n*data = inl(bp->base.port + offset);\r\n}\r\nstatic void dfx_port_read_long(DFX_board_t *bp, int offset, u32 *data)\r\n{\r\nstruct device __maybe_unused *bdev = bp->bus_dev;\r\nint dfx_bus_tc = DFX_BUS_TC(bdev);\r\nint dfx_use_mmio = DFX_MMIO || dfx_bus_tc;\r\nif (dfx_use_mmio)\r\ndfx_readl(bp, offset, data);\r\nelse\r\ndfx_inl(bp, offset, data);\r\n}\r\nstatic void dfx_get_bars(struct device *bdev,\r\nresource_size_t *bar_start, resource_size_t *bar_len)\r\n{\r\nint dfx_bus_pci = DFX_BUS_PCI(bdev);\r\nint dfx_bus_eisa = DFX_BUS_EISA(bdev);\r\nint dfx_bus_tc = DFX_BUS_TC(bdev);\r\nint dfx_use_mmio = DFX_MMIO || dfx_bus_tc;\r\nif (dfx_bus_pci) {\r\nint num = dfx_use_mmio ? 0 : 1;\r\n*bar_start = pci_resource_start(to_pci_dev(bdev), num);\r\n*bar_len = pci_resource_len(to_pci_dev(bdev), num);\r\n}\r\nif (dfx_bus_eisa) {\r\nunsigned long base_addr = to_eisa_device(bdev)->base_addr;\r\nresource_size_t bar;\r\nif (dfx_use_mmio) {\r\nbar = inb(base_addr + PI_ESIC_K_MEM_ADD_CMP_2);\r\nbar <<= 8;\r\nbar |= inb(base_addr + PI_ESIC_K_MEM_ADD_CMP_1);\r\nbar <<= 8;\r\nbar |= inb(base_addr + PI_ESIC_K_MEM_ADD_CMP_0);\r\nbar <<= 16;\r\n*bar_start = bar;\r\nbar = inb(base_addr + PI_ESIC_K_MEM_ADD_MASK_2);\r\nbar <<= 8;\r\nbar |= inb(base_addr + PI_ESIC_K_MEM_ADD_MASK_1);\r\nbar <<= 8;\r\nbar |= inb(base_addr + PI_ESIC_K_MEM_ADD_MASK_0);\r\nbar <<= 16;\r\n*bar_len = (bar | PI_MEM_ADD_MASK_M) + 1;\r\n} else {\r\n*bar_start = base_addr;\r\n*bar_len = PI_ESIC_K_CSR_IO_LEN;\r\n}\r\n}\r\nif (dfx_bus_tc) {\r\n*bar_start = to_tc_dev(bdev)->resource.start +\r\nPI_TC_K_CSR_OFFSET;\r\n*bar_len = PI_TC_K_CSR_LEN;\r\n}\r\n}\r\nstatic int dfx_register(struct device *bdev)\r\n{\r\nstatic int version_disp;\r\nint dfx_bus_pci = DFX_BUS_PCI(bdev);\r\nint dfx_bus_tc = DFX_BUS_TC(bdev);\r\nint dfx_use_mmio = DFX_MMIO || dfx_bus_tc;\r\nconst char *print_name = dev_name(bdev);\r\nstruct net_device *dev;\r\nDFX_board_t *bp;\r\nresource_size_t bar_start = 0;\r\nresource_size_t bar_len = 0;\r\nint alloc_size;\r\nstruct resource *region;\r\nint err = 0;\r\nif (!version_disp) {\r\nversion_disp = 1;\r\nprintk(version);\r\n}\r\ndev = alloc_fddidev(sizeof(*bp));\r\nif (!dev) {\r\nprintk(KERN_ERR "%s: Unable to allocate fddidev, aborting\n",\r\nprint_name);\r\nreturn -ENOMEM;\r\n}\r\nif (dfx_bus_pci && pci_enable_device(to_pci_dev(bdev))) {\r\nprintk(KERN_ERR "%s: Cannot enable PCI device, aborting\n",\r\nprint_name);\r\ngoto err_out;\r\n}\r\nSET_NETDEV_DEV(dev, bdev);\r\nbp = netdev_priv(dev);\r\nbp->bus_dev = bdev;\r\ndev_set_drvdata(bdev, dev);\r\ndfx_get_bars(bdev, &bar_start, &bar_len);\r\nif (dfx_use_mmio)\r\nregion = request_mem_region(bar_start, bar_len, print_name);\r\nelse\r\nregion = request_region(bar_start, bar_len, print_name);\r\nif (!region) {\r\nprintk(KERN_ERR "%s: Cannot reserve I/O resource "\r\n"0x%lx @ 0x%lx, aborting\n",\r\nprint_name, (long)bar_len, (long)bar_start);\r\nerr = -EBUSY;\r\ngoto err_out_disable;\r\n}\r\nif (dfx_use_mmio) {\r\nbp->base.mem = ioremap_nocache(bar_start, bar_len);\r\nif (!bp->base.mem) {\r\nprintk(KERN_ERR "%s: Cannot map MMIO\n", print_name);\r\nerr = -ENOMEM;\r\ngoto err_out_region;\r\n}\r\n} else {\r\nbp->base.port = bar_start;\r\ndev->base_addr = bar_start;\r\n}\r\ndev->netdev_ops = &dfx_netdev_ops;\r\nif (dfx_bus_pci)\r\npci_set_master(to_pci_dev(bdev));\r\nif (dfx_driver_init(dev, print_name, bar_start) != DFX_K_SUCCESS) {\r\nerr = -ENODEV;\r\ngoto err_out_unmap;\r\n}\r\nerr = register_netdev(dev);\r\nif (err)\r\ngoto err_out_kfree;\r\nprintk("%s: registered as %s\n", print_name, dev->name);\r\nreturn 0;\r\nerr_out_kfree:\r\nalloc_size = sizeof(PI_DESCR_BLOCK) +\r\nPI_CMD_REQ_K_SIZE_MAX + PI_CMD_RSP_K_SIZE_MAX +\r\n#ifndef DYNAMIC_BUFFERS\r\n(bp->rcv_bufs_to_post * PI_RCV_DATA_K_SIZE_MAX) +\r\n#endif\r\nsizeof(PI_CONSUMER_BLOCK) +\r\n(PI_ALIGN_K_DESC_BLK - 1);\r\nif (bp->kmalloced)\r\ndma_free_coherent(bdev, alloc_size,\r\nbp->kmalloced, bp->kmalloced_dma);\r\nerr_out_unmap:\r\nif (dfx_use_mmio)\r\niounmap(bp->base.mem);\r\nerr_out_region:\r\nif (dfx_use_mmio)\r\nrelease_mem_region(bar_start, bar_len);\r\nelse\r\nrelease_region(bar_start, bar_len);\r\nerr_out_disable:\r\nif (dfx_bus_pci)\r\npci_disable_device(to_pci_dev(bdev));\r\nerr_out:\r\nfree_netdev(dev);\r\nreturn err;\r\n}\r\nstatic void dfx_bus_init(struct net_device *dev)\r\n{\r\nDFX_board_t *bp = netdev_priv(dev);\r\nstruct device *bdev = bp->bus_dev;\r\nint dfx_bus_pci = DFX_BUS_PCI(bdev);\r\nint dfx_bus_eisa = DFX_BUS_EISA(bdev);\r\nint dfx_bus_tc = DFX_BUS_TC(bdev);\r\nint dfx_use_mmio = DFX_MMIO || dfx_bus_tc;\r\nu8 val;\r\nDBG_printk("In dfx_bus_init...\n");\r\nbp->dev = dev;\r\nif (dfx_bus_tc)\r\ndev->irq = to_tc_dev(bdev)->interrupt;\r\nif (dfx_bus_eisa) {\r\nunsigned long base_addr = to_eisa_device(bdev)->base_addr;\r\nval = inb(base_addr + PI_ESIC_K_IO_CONFIG_STAT_0);\r\nval &= PI_CONFIG_STAT_0_M_IRQ;\r\nval >>= PI_CONFIG_STAT_0_V_IRQ;\r\nswitch (val) {\r\ncase PI_CONFIG_STAT_0_IRQ_K_9:\r\ndev->irq = 9;\r\nbreak;\r\ncase PI_CONFIG_STAT_0_IRQ_K_10:\r\ndev->irq = 10;\r\nbreak;\r\ncase PI_CONFIG_STAT_0_IRQ_K_11:\r\ndev->irq = 11;\r\nbreak;\r\ncase PI_CONFIG_STAT_0_IRQ_K_15:\r\ndev->irq = 15;\r\nbreak;\r\n}\r\nval = ((bp->base.port >> 12) << PI_IO_CMP_V_SLOT);\r\noutb(base_addr + PI_ESIC_K_IO_ADD_CMP_0_1, val);\r\noutb(base_addr + PI_ESIC_K_IO_ADD_CMP_0_0, 0);\r\noutb(base_addr + PI_ESIC_K_IO_ADD_CMP_1_1, val);\r\noutb(base_addr + PI_ESIC_K_IO_ADD_CMP_1_0, 0);\r\nval = PI_ESIC_K_CSR_IO_LEN - 1;\r\noutb(base_addr + PI_ESIC_K_IO_ADD_MASK_0_1, (val >> 8) & 0xff);\r\noutb(base_addr + PI_ESIC_K_IO_ADD_MASK_0_0, val & 0xff);\r\noutb(base_addr + PI_ESIC_K_IO_ADD_MASK_1_1, (val >> 8) & 0xff);\r\noutb(base_addr + PI_ESIC_K_IO_ADD_MASK_1_0, val & 0xff);\r\nval = PI_FUNCTION_CNTRL_M_IOCS1 | PI_FUNCTION_CNTRL_M_IOCS0;\r\nif (dfx_use_mmio)\r\nval |= PI_FUNCTION_CNTRL_M_MEMCS0;\r\noutb(base_addr + PI_ESIC_K_FUNCTION_CNTRL, val);\r\nval = PI_SLOT_CNTRL_M_ENB;\r\noutb(base_addr + PI_ESIC_K_SLOT_CNTRL, val);\r\nval = inb(base_addr + PI_DEFEA_K_BURST_HOLDOFF);\r\nif (dfx_use_mmio)\r\nval |= PI_BURST_HOLDOFF_V_MEM_MAP;\r\nelse\r\nval &= ~PI_BURST_HOLDOFF_V_MEM_MAP;\r\noutb(base_addr + PI_DEFEA_K_BURST_HOLDOFF, val);\r\nval = inb(base_addr + PI_ESIC_K_IO_CONFIG_STAT_0);\r\nval |= PI_CONFIG_STAT_0_M_INT_ENB;\r\noutb(base_addr + PI_ESIC_K_IO_CONFIG_STAT_0, val);\r\n}\r\nif (dfx_bus_pci) {\r\nstruct pci_dev *pdev = to_pci_dev(bdev);\r\ndev->irq = pdev->irq;\r\npci_read_config_byte(pdev, PCI_LATENCY_TIMER, &val);\r\nif (val < PFI_K_LAT_TIMER_MIN) {\r\nval = PFI_K_LAT_TIMER_DEF;\r\npci_write_config_byte(pdev, PCI_LATENCY_TIMER, val);\r\n}\r\nval = PFI_MODE_M_PDQ_INT_ENB | PFI_MODE_M_DMA_ENB;\r\ndfx_port_write_long(bp, PFI_K_REG_MODE_CTRL, val);\r\n}\r\n}\r\nstatic void dfx_bus_uninit(struct net_device *dev)\r\n{\r\nDFX_board_t *bp = netdev_priv(dev);\r\nstruct device *bdev = bp->bus_dev;\r\nint dfx_bus_pci = DFX_BUS_PCI(bdev);\r\nint dfx_bus_eisa = DFX_BUS_EISA(bdev);\r\nu8 val;\r\nDBG_printk("In dfx_bus_uninit...\n");\r\nif (dfx_bus_eisa) {\r\nunsigned long base_addr = to_eisa_device(bdev)->base_addr;\r\nval = inb(base_addr + PI_ESIC_K_IO_CONFIG_STAT_0);\r\nval &= ~PI_CONFIG_STAT_0_M_INT_ENB;\r\noutb(base_addr + PI_ESIC_K_IO_CONFIG_STAT_0, val);\r\n}\r\nif (dfx_bus_pci) {\r\ndfx_port_write_long(bp, PFI_K_REG_MODE_CTRL, 0);\r\n}\r\n}\r\nstatic void dfx_bus_config_check(DFX_board_t *bp)\r\n{\r\nstruct device __maybe_unused *bdev = bp->bus_dev;\r\nint dfx_bus_eisa = DFX_BUS_EISA(bdev);\r\nint status;\r\nu32 host_data;\r\nDBG_printk("In dfx_bus_config_check...\n");\r\nif (dfx_bus_eisa) {\r\nif (to_eisa_device(bdev)->id.driver_data == DEFEA_PROD_ID_2) {\r\nstatus = dfx_hw_port_ctrl_req(bp,\r\nPI_PCTRL_M_SUB_CMD,\r\nPI_SUB_CMD_K_PDQ_REV_GET,\r\n0,\r\n&host_data);\r\nif ((status != DFX_K_SUCCESS) || (host_data == 2))\r\n{\r\nswitch (bp->burst_size)\r\n{\r\ncase PI_PDATA_B_DMA_BURST_SIZE_32:\r\ncase PI_PDATA_B_DMA_BURST_SIZE_16:\r\nbp->burst_size = PI_PDATA_B_DMA_BURST_SIZE_8;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nbp->full_duplex_enb = PI_SNMP_K_FALSE;\r\n}\r\n}\r\n}\r\n}\r\nstatic int dfx_driver_init(struct net_device *dev, const char *print_name,\r\nresource_size_t bar_start)\r\n{\r\nDFX_board_t *bp = netdev_priv(dev);\r\nstruct device *bdev = bp->bus_dev;\r\nint dfx_bus_pci = DFX_BUS_PCI(bdev);\r\nint dfx_bus_eisa = DFX_BUS_EISA(bdev);\r\nint dfx_bus_tc = DFX_BUS_TC(bdev);\r\nint dfx_use_mmio = DFX_MMIO || dfx_bus_tc;\r\nint alloc_size;\r\nchar *top_v, *curr_v;\r\ndma_addr_t top_p, curr_p;\r\nu32 data;\r\n__le32 le32;\r\nchar *board_name = NULL;\r\nDBG_printk("In dfx_driver_init...\n");\r\ndfx_bus_init(dev);\r\nbp->full_duplex_enb = PI_SNMP_K_FALSE;\r\nbp->req_ttrt = 8 * 12500;\r\nbp->burst_size = PI_PDATA_B_DMA_BURST_SIZE_DEF;\r\nbp->rcv_bufs_to_post = RCV_BUFS_DEF;\r\ndfx_bus_config_check(bp);\r\ndfx_port_write_long(bp, PI_PDQ_K_REG_HOST_INT_ENB, PI_HOST_INT_K_DISABLE_ALL_INTS);\r\n(void) dfx_hw_dma_uninit(bp, PI_PDATA_A_RESET_M_SKIP_ST);\r\nif (dfx_hw_port_ctrl_req(bp, PI_PCTRL_M_MLA, PI_PDATA_A_MLA_K_LO, 0,\r\n&data) != DFX_K_SUCCESS) {\r\nprintk("%s: Could not read adapter factory MAC address!\n",\r\nprint_name);\r\nreturn DFX_K_FAILURE;\r\n}\r\nle32 = cpu_to_le32(data);\r\nmemcpy(&bp->factory_mac_addr[0], &le32, sizeof(u32));\r\nif (dfx_hw_port_ctrl_req(bp, PI_PCTRL_M_MLA, PI_PDATA_A_MLA_K_HI, 0,\r\n&data) != DFX_K_SUCCESS) {\r\nprintk("%s: Could not read adapter factory MAC address!\n",\r\nprint_name);\r\nreturn DFX_K_FAILURE;\r\n}\r\nle32 = cpu_to_le32(data);\r\nmemcpy(&bp->factory_mac_addr[4], &le32, sizeof(u16));\r\nmemcpy(dev->dev_addr, bp->factory_mac_addr, FDDI_K_ALEN);\r\nif (dfx_bus_tc)\r\nboard_name = "DEFTA";\r\nif (dfx_bus_eisa)\r\nboard_name = "DEFEA";\r\nif (dfx_bus_pci)\r\nboard_name = "DEFPA";\r\npr_info("%s: %s at %saddr = 0x%llx, IRQ = %d, Hardware addr = %pMF\n",\r\nprint_name, board_name, dfx_use_mmio ? "" : "I/O ",\r\n(long long)bar_start, dev->irq, dev->dev_addr);\r\nalloc_size = sizeof(PI_DESCR_BLOCK) +\r\nPI_CMD_REQ_K_SIZE_MAX +\r\nPI_CMD_RSP_K_SIZE_MAX +\r\n#ifndef DYNAMIC_BUFFERS\r\n(bp->rcv_bufs_to_post * PI_RCV_DATA_K_SIZE_MAX) +\r\n#endif\r\nsizeof(PI_CONSUMER_BLOCK) +\r\n(PI_ALIGN_K_DESC_BLK - 1);\r\nbp->kmalloced = top_v = dma_alloc_coherent(bp->bus_dev, alloc_size,\r\n&bp->kmalloced_dma,\r\nGFP_ATOMIC);\r\nif (top_v == NULL) {\r\nprintk("%s: Could not allocate memory for host buffers "\r\n"and structures!\n", print_name);\r\nreturn DFX_K_FAILURE;\r\n}\r\nmemset(top_v, 0, alloc_size);\r\ntop_p = bp->kmalloced_dma;\r\ncurr_p = ALIGN(top_p, PI_ALIGN_K_DESC_BLK);\r\ncurr_v = top_v + (curr_p - top_p);\r\nbp->descr_block_virt = (PI_DESCR_BLOCK *) curr_v;\r\nbp->descr_block_phys = curr_p;\r\ncurr_v += sizeof(PI_DESCR_BLOCK);\r\ncurr_p += sizeof(PI_DESCR_BLOCK);\r\nbp->cmd_req_virt = (PI_DMA_CMD_REQ *) curr_v;\r\nbp->cmd_req_phys = curr_p;\r\ncurr_v += PI_CMD_REQ_K_SIZE_MAX;\r\ncurr_p += PI_CMD_REQ_K_SIZE_MAX;\r\nbp->cmd_rsp_virt = (PI_DMA_CMD_RSP *) curr_v;\r\nbp->cmd_rsp_phys = curr_p;\r\ncurr_v += PI_CMD_RSP_K_SIZE_MAX;\r\ncurr_p += PI_CMD_RSP_K_SIZE_MAX;\r\nbp->rcv_block_virt = curr_v;\r\nbp->rcv_block_phys = curr_p;\r\n#ifndef DYNAMIC_BUFFERS\r\ncurr_v += (bp->rcv_bufs_to_post * PI_RCV_DATA_K_SIZE_MAX);\r\ncurr_p += (bp->rcv_bufs_to_post * PI_RCV_DATA_K_SIZE_MAX);\r\n#endif\r\nbp->cons_block_virt = (PI_CONSUMER_BLOCK *) curr_v;\r\nbp->cons_block_phys = curr_p;\r\nDBG_printk("%s: Descriptor block virt = %0lX, phys = %0X\n",\r\nprint_name,\r\n(long)bp->descr_block_virt, bp->descr_block_phys);\r\nDBG_printk("%s: Command Request buffer virt = %0lX, phys = %0X\n",\r\nprint_name, (long)bp->cmd_req_virt, bp->cmd_req_phys);\r\nDBG_printk("%s: Command Response buffer virt = %0lX, phys = %0X\n",\r\nprint_name, (long)bp->cmd_rsp_virt, bp->cmd_rsp_phys);\r\nDBG_printk("%s: Receive buffer block virt = %0lX, phys = %0X\n",\r\nprint_name, (long)bp->rcv_block_virt, bp->rcv_block_phys);\r\nDBG_printk("%s: Consumer block virt = %0lX, phys = %0X\n",\r\nprint_name, (long)bp->cons_block_virt, bp->cons_block_phys);\r\nreturn DFX_K_SUCCESS;\r\n}\r\nstatic int dfx_adap_init(DFX_board_t *bp, int get_buffers)\r\n{\r\nDBG_printk("In dfx_adap_init...\n");\r\ndfx_port_write_long(bp, PI_PDQ_K_REG_HOST_INT_ENB, PI_HOST_INT_K_DISABLE_ALL_INTS);\r\nif (dfx_hw_dma_uninit(bp, bp->reset_type) != DFX_K_SUCCESS)\r\n{\r\nprintk("%s: Could not uninitialize/reset adapter!\n", bp->dev->name);\r\nreturn DFX_K_FAILURE;\r\n}\r\ndfx_port_write_long(bp, PI_PDQ_K_REG_TYPE_0_STATUS, PI_HOST_INT_K_ACK_ALL_TYPE_0);\r\nbp->cmd_req_reg.lword = 0;\r\nbp->cmd_rsp_reg.lword = 0;\r\nbp->rcv_xmt_reg.lword = 0;\r\nmemset(bp->cons_block_virt, 0, sizeof(PI_CONSUMER_BLOCK));\r\nif (dfx_hw_port_ctrl_req(bp,\r\nPI_PCTRL_M_SUB_CMD,\r\nPI_SUB_CMD_K_BURST_SIZE_SET,\r\nbp->burst_size,\r\nNULL) != DFX_K_SUCCESS)\r\n{\r\nprintk("%s: Could not set adapter burst size!\n", bp->dev->name);\r\nreturn DFX_K_FAILURE;\r\n}\r\nif (dfx_hw_port_ctrl_req(bp,\r\nPI_PCTRL_M_CONS_BLOCK,\r\nbp->cons_block_phys,\r\n0,\r\nNULL) != DFX_K_SUCCESS)\r\n{\r\nprintk("%s: Could not set consumer block address!\n", bp->dev->name);\r\nreturn DFX_K_FAILURE;\r\n}\r\nif (dfx_hw_port_ctrl_req(bp, PI_PCTRL_M_INIT,\r\n(u32)(bp->descr_block_phys |\r\nPI_PDATA_A_INIT_M_BSWAP_INIT),\r\n0, NULL) != DFX_K_SUCCESS) {\r\nprintk("%s: Could not set descriptor block address!\n",\r\nbp->dev->name);\r\nreturn DFX_K_FAILURE;\r\n}\r\nbp->cmd_req_virt->cmd_type = PI_CMD_K_CHARS_SET;\r\nbp->cmd_req_virt->char_set.item[0].item_code = PI_ITEM_K_FLUSH_TIME;\r\nbp->cmd_req_virt->char_set.item[0].value = 3;\r\nbp->cmd_req_virt->char_set.item[0].item_index = 0;\r\nbp->cmd_req_virt->char_set.item[1].item_code = PI_ITEM_K_EOL;\r\nif (dfx_hw_dma_cmd_req(bp) != DFX_K_SUCCESS)\r\n{\r\nprintk("%s: DMA command request failed!\n", bp->dev->name);\r\nreturn DFX_K_FAILURE;\r\n}\r\nbp->cmd_req_virt->cmd_type = PI_CMD_K_SNMP_SET;\r\nbp->cmd_req_virt->snmp_set.item[0].item_code = PI_ITEM_K_FDX_ENB_DIS;\r\nbp->cmd_req_virt->snmp_set.item[0].value = bp->full_duplex_enb;\r\nbp->cmd_req_virt->snmp_set.item[0].item_index = 0;\r\nbp->cmd_req_virt->snmp_set.item[1].item_code = PI_ITEM_K_MAC_T_REQ;\r\nbp->cmd_req_virt->snmp_set.item[1].value = bp->req_ttrt;\r\nbp->cmd_req_virt->snmp_set.item[1].item_index = 0;\r\nbp->cmd_req_virt->snmp_set.item[2].item_code = PI_ITEM_K_EOL;\r\nif (dfx_hw_dma_cmd_req(bp) != DFX_K_SUCCESS)\r\n{\r\nprintk("%s: DMA command request failed!\n", bp->dev->name);\r\nreturn DFX_K_FAILURE;\r\n}\r\nif (dfx_ctl_update_cam(bp) != DFX_K_SUCCESS)\r\n{\r\nprintk("%s: Adapter CAM update failed!\n", bp->dev->name);\r\nreturn DFX_K_FAILURE;\r\n}\r\nif (dfx_ctl_update_filters(bp) != DFX_K_SUCCESS)\r\n{\r\nprintk("%s: Adapter filters update failed!\n", bp->dev->name);\r\nreturn DFX_K_FAILURE;\r\n}\r\nif (get_buffers)\r\ndfx_rcv_flush(bp);\r\nif (dfx_rcv_init(bp, get_buffers))\r\n{\r\nprintk("%s: Receive buffer allocation failed\n", bp->dev->name);\r\nif (get_buffers)\r\ndfx_rcv_flush(bp);\r\nreturn DFX_K_FAILURE;\r\n}\r\nbp->cmd_req_virt->cmd_type = PI_CMD_K_START;\r\nif (dfx_hw_dma_cmd_req(bp) != DFX_K_SUCCESS)\r\n{\r\nprintk("%s: Start command failed\n", bp->dev->name);\r\nif (get_buffers)\r\ndfx_rcv_flush(bp);\r\nreturn DFX_K_FAILURE;\r\n}\r\ndfx_port_write_long(bp, PI_PDQ_K_REG_HOST_INT_ENB, PI_HOST_INT_K_ENABLE_DEF_INTS);\r\nreturn DFX_K_SUCCESS;\r\n}\r\nstatic int dfx_open(struct net_device *dev)\r\n{\r\nDFX_board_t *bp = netdev_priv(dev);\r\nint ret;\r\nDBG_printk("In dfx_open...\n");\r\nret = request_irq(dev->irq, dfx_interrupt, IRQF_SHARED, dev->name,\r\ndev);\r\nif (ret) {\r\nprintk(KERN_ERR "%s: Requested IRQ %d is busy\n", dev->name, dev->irq);\r\nreturn ret;\r\n}\r\nmemcpy(dev->dev_addr, bp->factory_mac_addr, FDDI_K_ALEN);\r\nmemset(bp->uc_table, 0, sizeof(bp->uc_table));\r\nmemset(bp->mc_table, 0, sizeof(bp->mc_table));\r\nbp->uc_count = 0;\r\nbp->mc_count = 0;\r\nbp->ind_group_prom = PI_FSTATE_K_BLOCK;\r\nbp->group_prom = PI_FSTATE_K_BLOCK;\r\nspin_lock_init(&bp->lock);\r\nbp->reset_type = PI_PDATA_A_RESET_M_SKIP_ST;\r\nif (dfx_adap_init(bp, 1) != DFX_K_SUCCESS)\r\n{\r\nprintk(KERN_ERR "%s: Adapter open failed!\n", dev->name);\r\nfree_irq(dev->irq, dev);\r\nreturn -EAGAIN;\r\n}\r\nnetif_start_queue(dev);\r\nreturn 0;\r\n}\r\nstatic int dfx_close(struct net_device *dev)\r\n{\r\nDFX_board_t *bp = netdev_priv(dev);\r\nDBG_printk("In dfx_close...\n");\r\ndfx_port_write_long(bp, PI_PDQ_K_REG_HOST_INT_ENB, PI_HOST_INT_K_DISABLE_ALL_INTS);\r\n(void) dfx_hw_dma_uninit(bp, PI_PDATA_A_RESET_M_SKIP_ST);\r\ndfx_xmt_flush(bp);\r\nbp->cmd_req_reg.lword = 0;\r\nbp->cmd_rsp_reg.lword = 0;\r\nbp->rcv_xmt_reg.lword = 0;\r\nmemset(bp->cons_block_virt, 0, sizeof(PI_CONSUMER_BLOCK));\r\ndfx_rcv_flush(bp);\r\nnetif_stop_queue(dev);\r\nfree_irq(dev->irq, dev);\r\nreturn 0;\r\n}\r\nstatic void dfx_int_pr_halt_id(DFX_board_t *bp)\r\n{\r\nPI_UINT32 port_status;\r\nPI_UINT32 halt_id;\r\ndfx_port_read_long(bp, PI_PDQ_K_REG_PORT_STATUS, &port_status);\r\nhalt_id = (port_status & PI_PSTATUS_M_HALT_ID) >> PI_PSTATUS_V_HALT_ID;\r\nswitch (halt_id)\r\n{\r\ncase PI_HALT_ID_K_SELFTEST_TIMEOUT:\r\nprintk("%s: Halt ID: Selftest Timeout\n", bp->dev->name);\r\nbreak;\r\ncase PI_HALT_ID_K_PARITY_ERROR:\r\nprintk("%s: Halt ID: Host Bus Parity Error\n", bp->dev->name);\r\nbreak;\r\ncase PI_HALT_ID_K_HOST_DIR_HALT:\r\nprintk("%s: Halt ID: Host-Directed Halt\n", bp->dev->name);\r\nbreak;\r\ncase PI_HALT_ID_K_SW_FAULT:\r\nprintk("%s: Halt ID: Adapter Software Fault\n", bp->dev->name);\r\nbreak;\r\ncase PI_HALT_ID_K_HW_FAULT:\r\nprintk("%s: Halt ID: Adapter Hardware Fault\n", bp->dev->name);\r\nbreak;\r\ncase PI_HALT_ID_K_PC_TRACE:\r\nprintk("%s: Halt ID: FDDI Network PC Trace Path Test\n", bp->dev->name);\r\nbreak;\r\ncase PI_HALT_ID_K_DMA_ERROR:\r\nprintk("%s: Halt ID: Adapter DMA Error\n", bp->dev->name);\r\nbreak;\r\ncase PI_HALT_ID_K_IMAGE_CRC_ERROR:\r\nprintk("%s: Halt ID: Firmware Image CRC Error\n", bp->dev->name);\r\nbreak;\r\ncase PI_HALT_ID_K_BUS_EXCEPTION:\r\nprintk("%s: Halt ID: 68000 Bus Exception\n", bp->dev->name);\r\nbreak;\r\ndefault:\r\nprintk("%s: Halt ID: Unknown (code = %X)\n", bp->dev->name, halt_id);\r\nbreak;\r\n}\r\n}\r\nstatic void dfx_int_type_0_process(DFX_board_t *bp)\r\n{\r\nPI_UINT32 type_0_status;\r\nPI_UINT32 state;\r\ndfx_port_read_long(bp, PI_PDQ_K_REG_TYPE_0_STATUS, &type_0_status);\r\ndfx_port_write_long(bp, PI_PDQ_K_REG_TYPE_0_STATUS, type_0_status);\r\nif (type_0_status & (PI_TYPE_0_STAT_M_NXM |\r\nPI_TYPE_0_STAT_M_PM_PAR_ERR |\r\nPI_TYPE_0_STAT_M_BUS_PAR_ERR))\r\n{\r\nif (type_0_status & PI_TYPE_0_STAT_M_NXM)\r\nprintk("%s: Non-Existent Memory Access Error\n", bp->dev->name);\r\nif (type_0_status & PI_TYPE_0_STAT_M_PM_PAR_ERR)\r\nprintk("%s: Packet Memory Parity Error\n", bp->dev->name);\r\nif (type_0_status & PI_TYPE_0_STAT_M_BUS_PAR_ERR)\r\nprintk("%s: Host Bus Parity Error\n", bp->dev->name);\r\nbp->link_available = PI_K_FALSE;\r\nbp->reset_type = 0;\r\nprintk("%s: Resetting adapter...\n", bp->dev->name);\r\nif (dfx_adap_init(bp, 0) != DFX_K_SUCCESS)\r\n{\r\nprintk("%s: Adapter reset failed! Disabling adapter interrupts.\n", bp->dev->name);\r\ndfx_port_write_long(bp, PI_PDQ_K_REG_HOST_INT_ENB, PI_HOST_INT_K_DISABLE_ALL_INTS);\r\nreturn;\r\n}\r\nprintk("%s: Adapter reset successful!\n", bp->dev->name);\r\nreturn;\r\n}\r\nif (type_0_status & PI_TYPE_0_STAT_M_XMT_FLUSH)\r\n{\r\nbp->link_available = PI_K_FALSE;\r\ndfx_xmt_flush(bp);\r\n(void) dfx_hw_port_ctrl_req(bp,\r\nPI_PCTRL_M_XMT_DATA_FLUSH_DONE,\r\n0,\r\n0,\r\nNULL);\r\n}\r\nif (type_0_status & PI_TYPE_0_STAT_M_STATE_CHANGE)\r\n{\r\nstate = dfx_hw_adap_state_rd(bp);\r\nif (state == PI_STATE_K_HALTED)\r\n{\r\nprintk("%s: Controller has transitioned to HALTED state!\n", bp->dev->name);\r\ndfx_int_pr_halt_id(bp);\r\nbp->link_available = PI_K_FALSE;\r\nbp->reset_type = 0;\r\nprintk("%s: Resetting adapter...\n", bp->dev->name);\r\nif (dfx_adap_init(bp, 0) != DFX_K_SUCCESS)\r\n{\r\nprintk("%s: Adapter reset failed! Disabling adapter interrupts.\n", bp->dev->name);\r\ndfx_port_write_long(bp, PI_PDQ_K_REG_HOST_INT_ENB, PI_HOST_INT_K_DISABLE_ALL_INTS);\r\nreturn;\r\n}\r\nprintk("%s: Adapter reset successful!\n", bp->dev->name);\r\n}\r\nelse if (state == PI_STATE_K_LINK_AVAIL)\r\n{\r\nbp->link_available = PI_K_TRUE;\r\n}\r\n}\r\n}\r\nstatic void dfx_int_common(struct net_device *dev)\r\n{\r\nDFX_board_t *bp = netdev_priv(dev);\r\nPI_UINT32 port_status;\r\nif(dfx_xmt_done(bp))\r\nnetif_wake_queue(dev);\r\ndfx_rcv_queue_process(bp);\r\ndfx_port_write_long(bp, PI_PDQ_K_REG_TYPE_2_PROD, bp->rcv_xmt_reg.lword);\r\ndfx_port_read_long(bp, PI_PDQ_K_REG_PORT_STATUS, &port_status);\r\nif (port_status & PI_PSTATUS_M_TYPE_0_PENDING)\r\ndfx_int_type_0_process(bp);\r\n}\r\nstatic irqreturn_t dfx_interrupt(int irq, void *dev_id)\r\n{\r\nstruct net_device *dev = dev_id;\r\nDFX_board_t *bp = netdev_priv(dev);\r\nstruct device *bdev = bp->bus_dev;\r\nint dfx_bus_pci = DFX_BUS_PCI(bdev);\r\nint dfx_bus_eisa = DFX_BUS_EISA(bdev);\r\nint dfx_bus_tc = DFX_BUS_TC(bdev);\r\nif (dfx_bus_pci) {\r\nu32 status;\r\ndfx_port_read_long(bp, PFI_K_REG_STATUS, &status);\r\nif (!(status & PFI_STATUS_M_PDQ_INT))\r\nreturn IRQ_NONE;\r\nspin_lock(&bp->lock);\r\ndfx_port_write_long(bp, PFI_K_REG_MODE_CTRL,\r\nPFI_MODE_M_DMA_ENB);\r\ndfx_int_common(dev);\r\ndfx_port_write_long(bp, PFI_K_REG_STATUS,\r\nPFI_STATUS_M_PDQ_INT);\r\ndfx_port_write_long(bp, PFI_K_REG_MODE_CTRL,\r\n(PFI_MODE_M_PDQ_INT_ENB |\r\nPFI_MODE_M_DMA_ENB));\r\nspin_unlock(&bp->lock);\r\n}\r\nif (dfx_bus_eisa) {\r\nunsigned long base_addr = to_eisa_device(bdev)->base_addr;\r\nu8 status;\r\nstatus = inb(base_addr + PI_ESIC_K_IO_CONFIG_STAT_0);\r\nif (!(status & PI_CONFIG_STAT_0_M_PEND))\r\nreturn IRQ_NONE;\r\nspin_lock(&bp->lock);\r\nstatus &= ~PI_CONFIG_STAT_0_M_INT_ENB;\r\noutb(base_addr + PI_ESIC_K_IO_CONFIG_STAT_0, status);\r\ndfx_int_common(dev);\r\nstatus = inb(base_addr + PI_ESIC_K_IO_CONFIG_STAT_0);\r\nstatus |= PI_CONFIG_STAT_0_M_INT_ENB;\r\noutb(base_addr + PI_ESIC_K_IO_CONFIG_STAT_0, status);\r\nspin_unlock(&bp->lock);\r\n}\r\nif (dfx_bus_tc) {\r\nu32 status;\r\ndfx_port_read_long(bp, PI_PDQ_K_REG_PORT_STATUS, &status);\r\nif (!(status & (PI_PSTATUS_M_RCV_DATA_PENDING |\r\nPI_PSTATUS_M_XMT_DATA_PENDING |\r\nPI_PSTATUS_M_SMT_HOST_PENDING |\r\nPI_PSTATUS_M_UNSOL_PENDING |\r\nPI_PSTATUS_M_CMD_RSP_PENDING |\r\nPI_PSTATUS_M_CMD_REQ_PENDING |\r\nPI_PSTATUS_M_TYPE_0_PENDING)))\r\nreturn IRQ_NONE;\r\nspin_lock(&bp->lock);\r\ndfx_int_common(dev);\r\nspin_unlock(&bp->lock);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic struct net_device_stats *dfx_ctl_get_stats(struct net_device *dev)\r\n{\r\nDFX_board_t *bp = netdev_priv(dev);\r\nbp->stats.gen.rx_packets = bp->rcv_total_frames;\r\nbp->stats.gen.tx_packets = bp->xmt_total_frames;\r\nbp->stats.gen.rx_bytes = bp->rcv_total_bytes;\r\nbp->stats.gen.tx_bytes = bp->xmt_total_bytes;\r\nbp->stats.gen.rx_errors = bp->rcv_crc_errors +\r\nbp->rcv_frame_status_errors +\r\nbp->rcv_length_errors;\r\nbp->stats.gen.tx_errors = bp->xmt_length_errors;\r\nbp->stats.gen.rx_dropped = bp->rcv_discards;\r\nbp->stats.gen.tx_dropped = bp->xmt_discards;\r\nbp->stats.gen.multicast = bp->rcv_multicast_frames;\r\nbp->stats.gen.collisions = 0;\r\nbp->cmd_req_virt->cmd_type = PI_CMD_K_SMT_MIB_GET;\r\nif (dfx_hw_dma_cmd_req(bp) != DFX_K_SUCCESS)\r\nreturn (struct net_device_stats *)&bp->stats;\r\nmemcpy(bp->stats.smt_station_id, &bp->cmd_rsp_virt->smt_mib_get.smt_station_id, sizeof(bp->cmd_rsp_virt->smt_mib_get.smt_station_id));\r\nbp->stats.smt_op_version_id = bp->cmd_rsp_virt->smt_mib_get.smt_op_version_id;\r\nbp->stats.smt_hi_version_id = bp->cmd_rsp_virt->smt_mib_get.smt_hi_version_id;\r\nbp->stats.smt_lo_version_id = bp->cmd_rsp_virt->smt_mib_get.smt_lo_version_id;\r\nmemcpy(bp->stats.smt_user_data, &bp->cmd_rsp_virt->smt_mib_get.smt_user_data, sizeof(bp->cmd_rsp_virt->smt_mib_get.smt_user_data));\r\nbp->stats.smt_mib_version_id = bp->cmd_rsp_virt->smt_mib_get.smt_mib_version_id;\r\nbp->stats.smt_mac_cts = bp->cmd_rsp_virt->smt_mib_get.smt_mac_ct;\r\nbp->stats.smt_non_master_cts = bp->cmd_rsp_virt->smt_mib_get.smt_non_master_ct;\r\nbp->stats.smt_master_cts = bp->cmd_rsp_virt->smt_mib_get.smt_master_ct;\r\nbp->stats.smt_available_paths = bp->cmd_rsp_virt->smt_mib_get.smt_available_paths;\r\nbp->stats.smt_config_capabilities = bp->cmd_rsp_virt->smt_mib_get.smt_config_capabilities;\r\nbp->stats.smt_config_policy = bp->cmd_rsp_virt->smt_mib_get.smt_config_policy;\r\nbp->stats.smt_connection_policy = bp->cmd_rsp_virt->smt_mib_get.smt_connection_policy;\r\nbp->stats.smt_t_notify = bp->cmd_rsp_virt->smt_mib_get.smt_t_notify;\r\nbp->stats.smt_stat_rpt_policy = bp->cmd_rsp_virt->smt_mib_get.smt_stat_rpt_policy;\r\nbp->stats.smt_trace_max_expiration = bp->cmd_rsp_virt->smt_mib_get.smt_trace_max_expiration;\r\nbp->stats.smt_bypass_present = bp->cmd_rsp_virt->smt_mib_get.smt_bypass_present;\r\nbp->stats.smt_ecm_state = bp->cmd_rsp_virt->smt_mib_get.smt_ecm_state;\r\nbp->stats.smt_cf_state = bp->cmd_rsp_virt->smt_mib_get.smt_cf_state;\r\nbp->stats.smt_remote_disconnect_flag = bp->cmd_rsp_virt->smt_mib_get.smt_remote_disconnect_flag;\r\nbp->stats.smt_station_status = bp->cmd_rsp_virt->smt_mib_get.smt_station_status;\r\nbp->stats.smt_peer_wrap_flag = bp->cmd_rsp_virt->smt_mib_get.smt_peer_wrap_flag;\r\nbp->stats.smt_time_stamp = bp->cmd_rsp_virt->smt_mib_get.smt_msg_time_stamp.ls;\r\nbp->stats.smt_transition_time_stamp = bp->cmd_rsp_virt->smt_mib_get.smt_transition_time_stamp.ls;\r\nbp->stats.mac_frame_status_functions = bp->cmd_rsp_virt->smt_mib_get.mac_frame_status_functions;\r\nbp->stats.mac_t_max_capability = bp->cmd_rsp_virt->smt_mib_get.mac_t_max_capability;\r\nbp->stats.mac_tvx_capability = bp->cmd_rsp_virt->smt_mib_get.mac_tvx_capability;\r\nbp->stats.mac_available_paths = bp->cmd_rsp_virt->smt_mib_get.mac_available_paths;\r\nbp->stats.mac_current_path = bp->cmd_rsp_virt->smt_mib_get.mac_current_path;\r\nmemcpy(bp->stats.mac_upstream_nbr, &bp->cmd_rsp_virt->smt_mib_get.mac_upstream_nbr, FDDI_K_ALEN);\r\nmemcpy(bp->stats.mac_downstream_nbr, &bp->cmd_rsp_virt->smt_mib_get.mac_downstream_nbr, FDDI_K_ALEN);\r\nmemcpy(bp->stats.mac_old_upstream_nbr, &bp->cmd_rsp_virt->smt_mib_get.mac_old_upstream_nbr, FDDI_K_ALEN);\r\nmemcpy(bp->stats.mac_old_downstream_nbr, &bp->cmd_rsp_virt->smt_mib_get.mac_old_downstream_nbr, FDDI_K_ALEN);\r\nbp->stats.mac_dup_address_test = bp->cmd_rsp_virt->smt_mib_get.mac_dup_address_test;\r\nbp->stats.mac_requested_paths = bp->cmd_rsp_virt->smt_mib_get.mac_requested_paths;\r\nbp->stats.mac_downstream_port_type = bp->cmd_rsp_virt->smt_mib_get.mac_downstream_port_type;\r\nmemcpy(bp->stats.mac_smt_address, &bp->cmd_rsp_virt->smt_mib_get.mac_smt_address, FDDI_K_ALEN);\r\nbp->stats.mac_t_req = bp->cmd_rsp_virt->smt_mib_get.mac_t_req;\r\nbp->stats.mac_t_neg = bp->cmd_rsp_virt->smt_mib_get.mac_t_neg;\r\nbp->stats.mac_t_max = bp->cmd_rsp_virt->smt_mib_get.mac_t_max;\r\nbp->stats.mac_tvx_value = bp->cmd_rsp_virt->smt_mib_get.mac_tvx_value;\r\nbp->stats.mac_frame_error_threshold = bp->cmd_rsp_virt->smt_mib_get.mac_frame_error_threshold;\r\nbp->stats.mac_frame_error_ratio = bp->cmd_rsp_virt->smt_mib_get.mac_frame_error_ratio;\r\nbp->stats.mac_rmt_state = bp->cmd_rsp_virt->smt_mib_get.mac_rmt_state;\r\nbp->stats.mac_da_flag = bp->cmd_rsp_virt->smt_mib_get.mac_da_flag;\r\nbp->stats.mac_una_da_flag = bp->cmd_rsp_virt->smt_mib_get.mac_unda_flag;\r\nbp->stats.mac_frame_error_flag = bp->cmd_rsp_virt->smt_mib_get.mac_frame_error_flag;\r\nbp->stats.mac_ma_unitdata_available = bp->cmd_rsp_virt->smt_mib_get.mac_ma_unitdata_available;\r\nbp->stats.mac_hardware_present = bp->cmd_rsp_virt->smt_mib_get.mac_hardware_present;\r\nbp->stats.mac_ma_unitdata_enable = bp->cmd_rsp_virt->smt_mib_get.mac_ma_unitdata_enable;\r\nbp->stats.path_tvx_lower_bound = bp->cmd_rsp_virt->smt_mib_get.path_tvx_lower_bound;\r\nbp->stats.path_t_max_lower_bound = bp->cmd_rsp_virt->smt_mib_get.path_t_max_lower_bound;\r\nbp->stats.path_max_t_req = bp->cmd_rsp_virt->smt_mib_get.path_max_t_req;\r\nmemcpy(bp->stats.path_configuration, &bp->cmd_rsp_virt->smt_mib_get.path_configuration, sizeof(bp->cmd_rsp_virt->smt_mib_get.path_configuration));\r\nbp->stats.port_my_type[0] = bp->cmd_rsp_virt->smt_mib_get.port_my_type[0];\r\nbp->stats.port_my_type[1] = bp->cmd_rsp_virt->smt_mib_get.port_my_type[1];\r\nbp->stats.port_neighbor_type[0] = bp->cmd_rsp_virt->smt_mib_get.port_neighbor_type[0];\r\nbp->stats.port_neighbor_type[1] = bp->cmd_rsp_virt->smt_mib_get.port_neighbor_type[1];\r\nbp->stats.port_connection_policies[0] = bp->cmd_rsp_virt->smt_mib_get.port_connection_policies[0];\r\nbp->stats.port_connection_policies[1] = bp->cmd_rsp_virt->smt_mib_get.port_connection_policies[1];\r\nbp->stats.port_mac_indicated[0] = bp->cmd_rsp_virt->smt_mib_get.port_mac_indicated[0];\r\nbp->stats.port_mac_indicated[1] = bp->cmd_rsp_virt->smt_mib_get.port_mac_indicated[1];\r\nbp->stats.port_current_path[0] = bp->cmd_rsp_virt->smt_mib_get.port_current_path[0];\r\nbp->stats.port_current_path[1] = bp->cmd_rsp_virt->smt_mib_get.port_current_path[1];\r\nmemcpy(&bp->stats.port_requested_paths[0*3], &bp->cmd_rsp_virt->smt_mib_get.port_requested_paths[0], 3);\r\nmemcpy(&bp->stats.port_requested_paths[1*3], &bp->cmd_rsp_virt->smt_mib_get.port_requested_paths[1], 3);\r\nbp->stats.port_mac_placement[0] = bp->cmd_rsp_virt->smt_mib_get.port_mac_placement[0];\r\nbp->stats.port_mac_placement[1] = bp->cmd_rsp_virt->smt_mib_get.port_mac_placement[1];\r\nbp->stats.port_available_paths[0] = bp->cmd_rsp_virt->smt_mib_get.port_available_paths[0];\r\nbp->stats.port_available_paths[1] = bp->cmd_rsp_virt->smt_mib_get.port_available_paths[1];\r\nbp->stats.port_pmd_class[0] = bp->cmd_rsp_virt->smt_mib_get.port_pmd_class[0];\r\nbp->stats.port_pmd_class[1] = bp->cmd_rsp_virt->smt_mib_get.port_pmd_class[1];\r\nbp->stats.port_connection_capabilities[0] = bp->cmd_rsp_virt->smt_mib_get.port_connection_capabilities[0];\r\nbp->stats.port_connection_capabilities[1] = bp->cmd_rsp_virt->smt_mib_get.port_connection_capabilities[1];\r\nbp->stats.port_bs_flag[0] = bp->cmd_rsp_virt->smt_mib_get.port_bs_flag[0];\r\nbp->stats.port_bs_flag[1] = bp->cmd_rsp_virt->smt_mib_get.port_bs_flag[1];\r\nbp->stats.port_ler_estimate[0] = bp->cmd_rsp_virt->smt_mib_get.port_ler_estimate[0];\r\nbp->stats.port_ler_estimate[1] = bp->cmd_rsp_virt->smt_mib_get.port_ler_estimate[1];\r\nbp->stats.port_ler_cutoff[0] = bp->cmd_rsp_virt->smt_mib_get.port_ler_cutoff[0];\r\nbp->stats.port_ler_cutoff[1] = bp->cmd_rsp_virt->smt_mib_get.port_ler_cutoff[1];\r\nbp->stats.port_ler_alarm[0] = bp->cmd_rsp_virt->smt_mib_get.port_ler_alarm[0];\r\nbp->stats.port_ler_alarm[1] = bp->cmd_rsp_virt->smt_mib_get.port_ler_alarm[1];\r\nbp->stats.port_connect_state[0] = bp->cmd_rsp_virt->smt_mib_get.port_connect_state[0];\r\nbp->stats.port_connect_state[1] = bp->cmd_rsp_virt->smt_mib_get.port_connect_state[1];\r\nbp->stats.port_pcm_state[0] = bp->cmd_rsp_virt->smt_mib_get.port_pcm_state[0];\r\nbp->stats.port_pcm_state[1] = bp->cmd_rsp_virt->smt_mib_get.port_pcm_state[1];\r\nbp->stats.port_pc_withhold[0] = bp->cmd_rsp_virt->smt_mib_get.port_pc_withhold[0];\r\nbp->stats.port_pc_withhold[1] = bp->cmd_rsp_virt->smt_mib_get.port_pc_withhold[1];\r\nbp->stats.port_ler_flag[0] = bp->cmd_rsp_virt->smt_mib_get.port_ler_flag[0];\r\nbp->stats.port_ler_flag[1] = bp->cmd_rsp_virt->smt_mib_get.port_ler_flag[1];\r\nbp->stats.port_hardware_present[0] = bp->cmd_rsp_virt->smt_mib_get.port_hardware_present[0];\r\nbp->stats.port_hardware_present[1] = bp->cmd_rsp_virt->smt_mib_get.port_hardware_present[1];\r\nbp->cmd_req_virt->cmd_type = PI_CMD_K_CNTRS_GET;\r\nif (dfx_hw_dma_cmd_req(bp) != DFX_K_SUCCESS)\r\nreturn (struct net_device_stats *)&bp->stats;\r\nbp->stats.mac_frame_cts = bp->cmd_rsp_virt->cntrs_get.cntrs.frame_cnt.ls;\r\nbp->stats.mac_copied_cts = bp->cmd_rsp_virt->cntrs_get.cntrs.copied_cnt.ls;\r\nbp->stats.mac_transmit_cts = bp->cmd_rsp_virt->cntrs_get.cntrs.transmit_cnt.ls;\r\nbp->stats.mac_error_cts = bp->cmd_rsp_virt->cntrs_get.cntrs.error_cnt.ls;\r\nbp->stats.mac_lost_cts = bp->cmd_rsp_virt->cntrs_get.cntrs.lost_cnt.ls;\r\nbp->stats.port_lct_fail_cts[0] = bp->cmd_rsp_virt->cntrs_get.cntrs.lct_rejects[0].ls;\r\nbp->stats.port_lct_fail_cts[1] = bp->cmd_rsp_virt->cntrs_get.cntrs.lct_rejects[1].ls;\r\nbp->stats.port_lem_reject_cts[0] = bp->cmd_rsp_virt->cntrs_get.cntrs.lem_rejects[0].ls;\r\nbp->stats.port_lem_reject_cts[1] = bp->cmd_rsp_virt->cntrs_get.cntrs.lem_rejects[1].ls;\r\nbp->stats.port_lem_cts[0] = bp->cmd_rsp_virt->cntrs_get.cntrs.link_errors[0].ls;\r\nbp->stats.port_lem_cts[1] = bp->cmd_rsp_virt->cntrs_get.cntrs.link_errors[1].ls;\r\nreturn (struct net_device_stats *)&bp->stats;\r\n}\r\nstatic void dfx_ctl_set_multicast_list(struct net_device *dev)\r\n{\r\nDFX_board_t *bp = netdev_priv(dev);\r\nint i;\r\nstruct netdev_hw_addr *ha;\r\nif (dev->flags & IFF_PROMISC)\r\nbp->ind_group_prom = PI_FSTATE_K_PASS;\r\nelse\r\n{\r\nbp->ind_group_prom = PI_FSTATE_K_BLOCK;\r\nif (netdev_mc_count(dev) > (PI_CMD_ADDR_FILTER_K_SIZE - bp->uc_count))\r\n{\r\nbp->group_prom = PI_FSTATE_K_PASS;\r\nbp->mc_count = 0;\r\n}\r\nelse\r\n{\r\nbp->group_prom = PI_FSTATE_K_BLOCK;\r\nbp->mc_count = netdev_mc_count(dev);\r\n}\r\ni = 0;\r\nnetdev_for_each_mc_addr(ha, dev)\r\nmemcpy(&bp->mc_table[i++ * FDDI_K_ALEN],\r\nha->addr, FDDI_K_ALEN);\r\nif (dfx_ctl_update_cam(bp) != DFX_K_SUCCESS)\r\n{\r\nDBG_printk("%s: Could not update multicast address table!\n", dev->name);\r\n}\r\nelse\r\n{\r\nDBG_printk("%s: Multicast address table updated! Added %d addresses.\n", dev->name, bp->mc_count);\r\n}\r\n}\r\nif (dfx_ctl_update_filters(bp) != DFX_K_SUCCESS)\r\n{\r\nDBG_printk("%s: Could not update adapter filters!\n", dev->name);\r\n}\r\nelse\r\n{\r\nDBG_printk("%s: Adapter filters updated!\n", dev->name);\r\n}\r\n}\r\nstatic int dfx_ctl_set_mac_address(struct net_device *dev, void *addr)\r\n{\r\nstruct sockaddr *p_sockaddr = (struct sockaddr *)addr;\r\nDFX_board_t *bp = netdev_priv(dev);\r\nmemcpy(dev->dev_addr, p_sockaddr->sa_data, FDDI_K_ALEN);\r\nmemcpy(&bp->uc_table[0], p_sockaddr->sa_data, FDDI_K_ALEN);\r\nbp->uc_count = 1;\r\nif ((bp->uc_count + bp->mc_count) > PI_CMD_ADDR_FILTER_K_SIZE)\r\n{\r\nbp->group_prom = PI_FSTATE_K_PASS;\r\nbp->mc_count = 0;\r\nif (dfx_ctl_update_filters(bp) != DFX_K_SUCCESS)\r\n{\r\nDBG_printk("%s: Could not update adapter filters!\n", dev->name);\r\n}\r\nelse\r\n{\r\nDBG_printk("%s: Adapter filters updated!\n", dev->name);\r\n}\r\n}\r\nif (dfx_ctl_update_cam(bp) != DFX_K_SUCCESS)\r\n{\r\nDBG_printk("%s: Could not set new MAC address!\n", dev->name);\r\n}\r\nelse\r\n{\r\nDBG_printk("%s: Adapter CAM updated with new MAC address\n", dev->name);\r\n}\r\nreturn 0;\r\n}\r\nstatic int dfx_ctl_update_cam(DFX_board_t *bp)\r\n{\r\nint i;\r\nPI_LAN_ADDR *p_addr;\r\nmemset(bp->cmd_req_virt, 0, PI_CMD_REQ_K_SIZE_MAX);\r\nbp->cmd_req_virt->cmd_type = PI_CMD_K_ADDR_FILTER_SET;\r\np_addr = &bp->cmd_req_virt->addr_filter_set.entry[0];\r\nfor (i=0; i < (int)bp->uc_count; i++)\r\n{\r\nif (i < PI_CMD_ADDR_FILTER_K_SIZE)\r\n{\r\nmemcpy(p_addr, &bp->uc_table[i*FDDI_K_ALEN], FDDI_K_ALEN);\r\np_addr++;\r\n}\r\n}\r\nfor (i=0; i < (int)bp->mc_count; i++)\r\n{\r\nif ((i + bp->uc_count) < PI_CMD_ADDR_FILTER_K_SIZE)\r\n{\r\nmemcpy(p_addr, &bp->mc_table[i*FDDI_K_ALEN], FDDI_K_ALEN);\r\np_addr++;\r\n}\r\n}\r\nif (dfx_hw_dma_cmd_req(bp) != DFX_K_SUCCESS)\r\nreturn DFX_K_FAILURE;\r\nreturn DFX_K_SUCCESS;\r\n}\r\nstatic int dfx_ctl_update_filters(DFX_board_t *bp)\r\n{\r\nint i = 0;\r\nbp->cmd_req_virt->cmd_type = PI_CMD_K_FILTERS_SET;\r\nbp->cmd_req_virt->filter_set.item[i].item_code = PI_ITEM_K_BROADCAST;\r\nbp->cmd_req_virt->filter_set.item[i++].value = PI_FSTATE_K_PASS;\r\nbp->cmd_req_virt->filter_set.item[i].item_code = PI_ITEM_K_IND_GROUP_PROM;\r\nbp->cmd_req_virt->filter_set.item[i++].value = bp->ind_group_prom;\r\nbp->cmd_req_virt->filter_set.item[i].item_code = PI_ITEM_K_GROUP_PROM;\r\nbp->cmd_req_virt->filter_set.item[i++].value = bp->group_prom;\r\nbp->cmd_req_virt->filter_set.item[i].item_code = PI_ITEM_K_EOL;\r\nif (dfx_hw_dma_cmd_req(bp) != DFX_K_SUCCESS)\r\nreturn DFX_K_FAILURE;\r\nreturn DFX_K_SUCCESS;\r\n}\r\nstatic int dfx_hw_dma_cmd_req(DFX_board_t *bp)\r\n{\r\nint status;\r\nint timeout_cnt;\r\nstatus = dfx_hw_adap_state_rd(bp);\r\nif ((status == PI_STATE_K_RESET) ||\r\n(status == PI_STATE_K_HALTED) ||\r\n(status == PI_STATE_K_DMA_UNAVAIL) ||\r\n(status == PI_STATE_K_UPGRADE))\r\nreturn DFX_K_OUTSTATE;\r\nbp->descr_block_virt->cmd_rsp[bp->cmd_rsp_reg.index.prod].long_0 = (u32) (PI_RCV_DESCR_M_SOP |\r\n((PI_CMD_RSP_K_SIZE_MAX / PI_ALIGN_K_CMD_RSP_BUFF) << PI_RCV_DESCR_V_SEG_LEN));\r\nbp->descr_block_virt->cmd_rsp[bp->cmd_rsp_reg.index.prod].long_1 = bp->cmd_rsp_phys;\r\nbp->cmd_rsp_reg.index.prod += 1;\r\nbp->cmd_rsp_reg.index.prod &= PI_CMD_RSP_K_NUM_ENTRIES-1;\r\ndfx_port_write_long(bp, PI_PDQ_K_REG_CMD_RSP_PROD, bp->cmd_rsp_reg.lword);\r\nbp->descr_block_virt->cmd_req[bp->cmd_req_reg.index.prod].long_0 = (u32) (PI_XMT_DESCR_M_SOP |\r\nPI_XMT_DESCR_M_EOP | (PI_CMD_REQ_K_SIZE_MAX << PI_XMT_DESCR_V_SEG_LEN));\r\nbp->descr_block_virt->cmd_req[bp->cmd_req_reg.index.prod].long_1 = bp->cmd_req_phys;\r\nbp->cmd_req_reg.index.prod += 1;\r\nbp->cmd_req_reg.index.prod &= PI_CMD_REQ_K_NUM_ENTRIES-1;\r\ndfx_port_write_long(bp, PI_PDQ_K_REG_CMD_REQ_PROD, bp->cmd_req_reg.lword);\r\nfor (timeout_cnt = 20000; timeout_cnt > 0; timeout_cnt--)\r\n{\r\nif (bp->cmd_req_reg.index.prod == (u8)(bp->cons_block_virt->cmd_req))\r\nbreak;\r\nudelay(100);\r\n}\r\nif (timeout_cnt == 0)\r\nreturn DFX_K_HW_TIMEOUT;\r\nbp->cmd_req_reg.index.comp += 1;\r\nbp->cmd_req_reg.index.comp &= PI_CMD_REQ_K_NUM_ENTRIES-1;\r\ndfx_port_write_long(bp, PI_PDQ_K_REG_CMD_REQ_PROD, bp->cmd_req_reg.lword);\r\nfor (timeout_cnt = 20000; timeout_cnt > 0; timeout_cnt--)\r\n{\r\nif (bp->cmd_rsp_reg.index.prod == (u8)(bp->cons_block_virt->cmd_rsp))\r\nbreak;\r\nudelay(100);\r\n}\r\nif (timeout_cnt == 0)\r\nreturn DFX_K_HW_TIMEOUT;\r\nbp->cmd_rsp_reg.index.comp += 1;\r\nbp->cmd_rsp_reg.index.comp &= PI_CMD_RSP_K_NUM_ENTRIES-1;\r\ndfx_port_write_long(bp, PI_PDQ_K_REG_CMD_RSP_PROD, bp->cmd_rsp_reg.lword);\r\nreturn DFX_K_SUCCESS;\r\n}\r\nstatic int dfx_hw_port_ctrl_req(\r\nDFX_board_t *bp,\r\nPI_UINT32 command,\r\nPI_UINT32 data_a,\r\nPI_UINT32 data_b,\r\nPI_UINT32 *host_data\r\n)\r\n{\r\nPI_UINT32 port_cmd;\r\nint timeout_cnt;\r\nport_cmd = (PI_UINT32) (command | PI_PCTRL_M_CMD_ERROR);\r\ndfx_port_write_long(bp, PI_PDQ_K_REG_PORT_DATA_A, data_a);\r\ndfx_port_write_long(bp, PI_PDQ_K_REG_PORT_DATA_B, data_b);\r\ndfx_port_write_long(bp, PI_PDQ_K_REG_PORT_CTRL, port_cmd);\r\nif (command == PI_PCTRL_M_BLAST_FLASH)\r\ntimeout_cnt = 600000;\r\nelse\r\ntimeout_cnt = 20000;\r\nfor (; timeout_cnt > 0; timeout_cnt--)\r\n{\r\ndfx_port_read_long(bp, PI_PDQ_K_REG_PORT_CTRL, &port_cmd);\r\nif (!(port_cmd & PI_PCTRL_M_CMD_ERROR))\r\nbreak;\r\nudelay(100);\r\n}\r\nif (timeout_cnt == 0)\r\nreturn DFX_K_HW_TIMEOUT;\r\nif (host_data != NULL)\r\ndfx_port_read_long(bp, PI_PDQ_K_REG_HOST_DATA, host_data);\r\nreturn DFX_K_SUCCESS;\r\n}\r\nstatic void dfx_hw_adap_reset(\r\nDFX_board_t *bp,\r\nPI_UINT32 type\r\n)\r\n{\r\ndfx_port_write_long(bp, PI_PDQ_K_REG_PORT_DATA_A, type);\r\ndfx_port_write_long(bp, PI_PDQ_K_REG_PORT_RESET, PI_RESET_M_ASSERT_RESET);\r\nudelay(20);\r\ndfx_port_write_long(bp, PI_PDQ_K_REG_PORT_RESET, 0);\r\n}\r\nstatic int dfx_hw_adap_state_rd(DFX_board_t *bp)\r\n{\r\nPI_UINT32 port_status;\r\ndfx_port_read_long(bp, PI_PDQ_K_REG_PORT_STATUS, &port_status);\r\nreturn (port_status & PI_PSTATUS_M_STATE) >> PI_PSTATUS_V_STATE;\r\n}\r\nstatic int dfx_hw_dma_uninit(DFX_board_t *bp, PI_UINT32 type)\r\n{\r\nint timeout_cnt;\r\ndfx_hw_adap_reset(bp, type);\r\nfor (timeout_cnt = 100000; timeout_cnt > 0; timeout_cnt--)\r\n{\r\nif (dfx_hw_adap_state_rd(bp) == PI_STATE_K_DMA_UNAVAIL)\r\nbreak;\r\nudelay(100);\r\n}\r\nif (timeout_cnt == 0)\r\nreturn DFX_K_HW_TIMEOUT;\r\nreturn DFX_K_SUCCESS;\r\n}\r\nstatic void my_skb_align(struct sk_buff *skb, int n)\r\n{\r\nunsigned long x = (unsigned long)skb->data;\r\nunsigned long v;\r\nv = ALIGN(x, n);\r\nskb_reserve(skb, v - x);\r\n}\r\nstatic int dfx_rcv_init(DFX_board_t *bp, int get_buffers)\r\n{\r\nint i, j;\r\nif (get_buffers) {\r\n#ifdef DYNAMIC_BUFFERS\r\nfor (i = 0; i < (int)(bp->rcv_bufs_to_post); i++)\r\nfor (j = 0; (i + j) < (int)PI_RCV_DATA_K_NUM_ENTRIES; j += bp->rcv_bufs_to_post)\r\n{\r\nstruct sk_buff *newskb = __netdev_alloc_skb(bp->dev, NEW_SKB_SIZE, GFP_NOIO);\r\nif (!newskb)\r\nreturn -ENOMEM;\r\nbp->descr_block_virt->rcv_data[i+j].long_0 = (u32) (PI_RCV_DESCR_M_SOP |\r\n((PI_RCV_DATA_K_SIZE_MAX / PI_ALIGN_K_RCV_DATA_BUFF) << PI_RCV_DESCR_V_SEG_LEN));\r\nmy_skb_align(newskb, 128);\r\nbp->descr_block_virt->rcv_data[i + j].long_1 =\r\n(u32)dma_map_single(bp->bus_dev, newskb->data,\r\nNEW_SKB_SIZE,\r\nDMA_FROM_DEVICE);\r\nbp->p_rcv_buff_va[i+j] = (char *) newskb;\r\n}\r\n#else\r\nfor (i=0; i < (int)(bp->rcv_bufs_to_post); i++)\r\nfor (j=0; (i + j) < (int)PI_RCV_DATA_K_NUM_ENTRIES; j += bp->rcv_bufs_to_post)\r\n{\r\nbp->descr_block_virt->rcv_data[i+j].long_0 = (u32) (PI_RCV_DESCR_M_SOP |\r\n((PI_RCV_DATA_K_SIZE_MAX / PI_ALIGN_K_RCV_DATA_BUFF) << PI_RCV_DESCR_V_SEG_LEN));\r\nbp->descr_block_virt->rcv_data[i+j].long_1 = (u32) (bp->rcv_block_phys + (i * PI_RCV_DATA_K_SIZE_MAX));\r\nbp->p_rcv_buff_va[i+j] = (bp->rcv_block_virt + (i * PI_RCV_DATA_K_SIZE_MAX));\r\n}\r\n#endif\r\n}\r\nbp->rcv_xmt_reg.index.rcv_prod = bp->rcv_bufs_to_post;\r\ndfx_port_write_long(bp, PI_PDQ_K_REG_TYPE_2_PROD, bp->rcv_xmt_reg.lword);\r\nreturn 0;\r\n}\r\nstatic void dfx_rcv_queue_process(\r\nDFX_board_t *bp\r\n)\r\n{\r\nPI_TYPE_2_CONSUMER *p_type_2_cons;\r\nchar *p_buff;\r\nu32 descr, pkt_len;\r\nstruct sk_buff *skb;\r\np_type_2_cons = (PI_TYPE_2_CONSUMER *)(&bp->cons_block_virt->xmt_rcv_data);\r\nwhile (bp->rcv_xmt_reg.index.rcv_comp != p_type_2_cons->index.rcv_cons)\r\n{\r\nint entry;\r\nentry = bp->rcv_xmt_reg.index.rcv_comp;\r\n#ifdef DYNAMIC_BUFFERS\r\np_buff = (char *) (((struct sk_buff *)bp->p_rcv_buff_va[entry])->data);\r\n#else\r\np_buff = bp->p_rcv_buff_va[entry];\r\n#endif\r\nmemcpy(&descr, p_buff + RCV_BUFF_K_DESCR, sizeof(u32));\r\nif (descr & PI_FMC_DESCR_M_RCC_FLUSH)\r\n{\r\nif (descr & PI_FMC_DESCR_M_RCC_CRC)\r\nbp->rcv_crc_errors++;\r\nelse\r\nbp->rcv_frame_status_errors++;\r\n}\r\nelse\r\n{\r\nint rx_in_place = 0;\r\npkt_len = (u32)((descr & PI_FMC_DESCR_M_LEN) >> PI_FMC_DESCR_V_LEN);\r\npkt_len -= 4;\r\nif (!IN_RANGE(pkt_len, FDDI_K_LLC_ZLEN, FDDI_K_LLC_LEN))\r\nbp->rcv_length_errors++;\r\nelse{\r\n#ifdef DYNAMIC_BUFFERS\r\nif (pkt_len > SKBUFF_RX_COPYBREAK) {\r\nstruct sk_buff *newskb;\r\nnewskb = dev_alloc_skb(NEW_SKB_SIZE);\r\nif (newskb){\r\nrx_in_place = 1;\r\nmy_skb_align(newskb, 128);\r\nskb = (struct sk_buff *)bp->p_rcv_buff_va[entry];\r\ndma_unmap_single(bp->bus_dev,\r\nbp->descr_block_virt->rcv_data[entry].long_1,\r\nNEW_SKB_SIZE,\r\nDMA_FROM_DEVICE);\r\nskb_reserve(skb, RCV_BUFF_K_PADDING);\r\nbp->p_rcv_buff_va[entry] = (char *)newskb;\r\nbp->descr_block_virt->rcv_data[entry].long_1 =\r\n(u32)dma_map_single(bp->bus_dev,\r\nnewskb->data,\r\nNEW_SKB_SIZE,\r\nDMA_FROM_DEVICE);\r\n} else\r\nskb = NULL;\r\n} else\r\n#endif\r\nskb = dev_alloc_skb(pkt_len+3);\r\nif (skb == NULL)\r\n{\r\nprintk("%s: Could not allocate receive buffer. Dropping packet.\n", bp->dev->name);\r\nbp->rcv_discards++;\r\nbreak;\r\n}\r\nelse {\r\n#ifndef DYNAMIC_BUFFERS\r\nif (! rx_in_place)\r\n#endif\r\n{\r\nskb_copy_to_linear_data(skb,\r\np_buff + RCV_BUFF_K_PADDING,\r\npkt_len + 3);\r\n}\r\nskb_reserve(skb,3);\r\nskb_put(skb, pkt_len);\r\nskb->protocol = fddi_type_trans(skb, bp->dev);\r\nbp->rcv_total_bytes += skb->len;\r\nnetif_rx(skb);\r\nbp->rcv_total_frames++;\r\nif (*(p_buff + RCV_BUFF_K_DA) & 0x01)\r\nbp->rcv_multicast_frames++;\r\n}\r\n}\r\n}\r\nbp->rcv_xmt_reg.index.rcv_prod += 1;\r\nbp->rcv_xmt_reg.index.rcv_comp += 1;\r\n}\r\n}\r\nstatic netdev_tx_t dfx_xmt_queue_pkt(struct sk_buff *skb,\r\nstruct net_device *dev)\r\n{\r\nDFX_board_t *bp = netdev_priv(dev);\r\nu8 prod;\r\nPI_XMT_DESCR *p_xmt_descr;\r\nXMT_DRIVER_DESCR *p_xmt_drv_descr;\r\nunsigned long flags;\r\nnetif_stop_queue(dev);\r\nif (!IN_RANGE(skb->len, FDDI_K_LLC_ZLEN, FDDI_K_LLC_LEN))\r\n{\r\nprintk("%s: Invalid packet length - %u bytes\n",\r\ndev->name, skb->len);\r\nbp->xmt_length_errors++;\r\nnetif_wake_queue(dev);\r\ndev_kfree_skb(skb);\r\nreturn NETDEV_TX_OK;\r\n}\r\nif (bp->link_available == PI_K_FALSE)\r\n{\r\nif (dfx_hw_adap_state_rd(bp) == PI_STATE_K_LINK_AVAIL)\r\nbp->link_available = PI_K_TRUE;\r\nelse\r\n{\r\nbp->xmt_discards++;\r\ndev_kfree_skb(skb);\r\nnetif_wake_queue(dev);\r\nreturn NETDEV_TX_OK;\r\n}\r\n}\r\nspin_lock_irqsave(&bp->lock, flags);\r\nprod = bp->rcv_xmt_reg.index.xmt_prod;\r\np_xmt_descr = &(bp->descr_block_virt->xmt_data[prod]);\r\np_xmt_drv_descr = &(bp->xmt_drv_descr_blk[prod++]);\r\nskb_push(skb,3);\r\nskb->data[0] = DFX_PRH0_BYTE;\r\nskb->data[1] = DFX_PRH1_BYTE;\r\nskb->data[2] = DFX_PRH2_BYTE;\r\np_xmt_descr->long_0 = (u32) (PI_XMT_DESCR_M_SOP | PI_XMT_DESCR_M_EOP | ((skb->len) << PI_XMT_DESCR_V_SEG_LEN));\r\np_xmt_descr->long_1 = (u32)dma_map_single(bp->bus_dev, skb->data,\r\nskb->len, DMA_TO_DEVICE);\r\nif (prod == bp->rcv_xmt_reg.index.xmt_comp)\r\n{\r\nskb_pull(skb,3);\r\nspin_unlock_irqrestore(&bp->lock, flags);\r\nreturn NETDEV_TX_BUSY;\r\n}\r\np_xmt_drv_descr->p_skb = skb;\r\nbp->rcv_xmt_reg.index.xmt_prod = prod;\r\ndfx_port_write_long(bp, PI_PDQ_K_REG_TYPE_2_PROD, bp->rcv_xmt_reg.lword);\r\nspin_unlock_irqrestore(&bp->lock, flags);\r\nnetif_wake_queue(dev);\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic int dfx_xmt_done(DFX_board_t *bp)\r\n{\r\nXMT_DRIVER_DESCR *p_xmt_drv_descr;\r\nPI_TYPE_2_CONSUMER *p_type_2_cons;\r\nu8 comp;\r\nint freed = 0;\r\np_type_2_cons = (PI_TYPE_2_CONSUMER *)(&bp->cons_block_virt->xmt_rcv_data);\r\nwhile (bp->rcv_xmt_reg.index.xmt_comp != p_type_2_cons->index.xmt_cons)\r\n{\r\np_xmt_drv_descr = &(bp->xmt_drv_descr_blk[bp->rcv_xmt_reg.index.xmt_comp]);\r\nbp->xmt_total_frames++;\r\nbp->xmt_total_bytes += p_xmt_drv_descr->p_skb->len;\r\ncomp = bp->rcv_xmt_reg.index.xmt_comp;\r\ndma_unmap_single(bp->bus_dev,\r\nbp->descr_block_virt->xmt_data[comp].long_1,\r\np_xmt_drv_descr->p_skb->len,\r\nDMA_TO_DEVICE);\r\ndev_kfree_skb_irq(p_xmt_drv_descr->p_skb);\r\nbp->rcv_xmt_reg.index.xmt_comp += 1;\r\nfreed++;\r\n}\r\nreturn freed;\r\n}\r\nstatic void dfx_rcv_flush( DFX_board_t *bp )\r\n{\r\nint i, j;\r\nfor (i = 0; i < (int)(bp->rcv_bufs_to_post); i++)\r\nfor (j = 0; (i + j) < (int)PI_RCV_DATA_K_NUM_ENTRIES; j += bp->rcv_bufs_to_post)\r\n{\r\nstruct sk_buff *skb;\r\nskb = (struct sk_buff *)bp->p_rcv_buff_va[i+j];\r\nif (skb)\r\ndev_kfree_skb(skb);\r\nbp->p_rcv_buff_va[i+j] = NULL;\r\n}\r\n}\r\nstatic inline void dfx_rcv_flush( DFX_board_t *bp )\r\n{\r\n}\r\nstatic void dfx_xmt_flush( DFX_board_t *bp )\r\n{\r\nu32 prod_cons;\r\nXMT_DRIVER_DESCR *p_xmt_drv_descr;\r\nu8 comp;\r\nwhile (bp->rcv_xmt_reg.index.xmt_comp != bp->rcv_xmt_reg.index.xmt_prod)\r\n{\r\np_xmt_drv_descr = &(bp->xmt_drv_descr_blk[bp->rcv_xmt_reg.index.xmt_comp]);\r\ncomp = bp->rcv_xmt_reg.index.xmt_comp;\r\ndma_unmap_single(bp->bus_dev,\r\nbp->descr_block_virt->xmt_data[comp].long_1,\r\np_xmt_drv_descr->p_skb->len,\r\nDMA_TO_DEVICE);\r\ndev_kfree_skb(p_xmt_drv_descr->p_skb);\r\nbp->xmt_discards++;\r\nbp->rcv_xmt_reg.index.xmt_comp += 1;\r\n}\r\nprod_cons = (u32)(bp->cons_block_virt->xmt_rcv_data & ~PI_CONS_M_XMT_INDEX);\r\nprod_cons |= (u32)(bp->rcv_xmt_reg.index.xmt_prod << PI_CONS_V_XMT_INDEX);\r\nbp->cons_block_virt->xmt_rcv_data = prod_cons;\r\n}\r\nstatic void dfx_unregister(struct device *bdev)\r\n{\r\nstruct net_device *dev = dev_get_drvdata(bdev);\r\nDFX_board_t *bp = netdev_priv(dev);\r\nint dfx_bus_pci = DFX_BUS_PCI(bdev);\r\nint dfx_bus_tc = DFX_BUS_TC(bdev);\r\nint dfx_use_mmio = DFX_MMIO || dfx_bus_tc;\r\nresource_size_t bar_start = 0;\r\nresource_size_t bar_len = 0;\r\nint alloc_size;\r\nunregister_netdev(dev);\r\nalloc_size = sizeof(PI_DESCR_BLOCK) +\r\nPI_CMD_REQ_K_SIZE_MAX + PI_CMD_RSP_K_SIZE_MAX +\r\n#ifndef DYNAMIC_BUFFERS\r\n(bp->rcv_bufs_to_post * PI_RCV_DATA_K_SIZE_MAX) +\r\n#endif\r\nsizeof(PI_CONSUMER_BLOCK) +\r\n(PI_ALIGN_K_DESC_BLK - 1);\r\nif (bp->kmalloced)\r\ndma_free_coherent(bdev, alloc_size,\r\nbp->kmalloced, bp->kmalloced_dma);\r\ndfx_bus_uninit(dev);\r\ndfx_get_bars(bdev, &bar_start, &bar_len);\r\nif (dfx_use_mmio) {\r\niounmap(bp->base.mem);\r\nrelease_mem_region(bar_start, bar_len);\r\n} else\r\nrelease_region(bar_start, bar_len);\r\nif (dfx_bus_pci)\r\npci_disable_device(to_pci_dev(bdev));\r\nfree_netdev(dev);\r\n}\r\nstatic int dfx_pci_register(struct pci_dev *pdev,\r\nconst struct pci_device_id *ent)\r\n{\r\nreturn dfx_register(&pdev->dev);\r\n}\r\nstatic void dfx_pci_unregister(struct pci_dev *pdev)\r\n{\r\ndfx_unregister(&pdev->dev);\r\n}\r\nstatic int __maybe_unused dfx_dev_register(struct device *dev)\r\n{\r\nint status;\r\nstatus = dfx_register(dev);\r\nif (!status)\r\nget_device(dev);\r\nreturn status;\r\n}\r\nstatic int __maybe_unused dfx_dev_unregister(struct device *dev)\r\n{\r\nput_device(dev);\r\ndfx_unregister(dev);\r\nreturn 0;\r\n}\r\nstatic int dfx_init(void)\r\n{\r\nint status;\r\nstatus = pci_register_driver(&dfx_pci_driver);\r\nif (!status)\r\nstatus = eisa_driver_register(&dfx_eisa_driver);\r\nif (!status)\r\nstatus = tc_register_driver(&dfx_tc_driver);\r\nreturn status;\r\n}\r\nstatic void dfx_cleanup(void)\r\n{\r\ntc_unregister_driver(&dfx_tc_driver);\r\neisa_driver_unregister(&dfx_eisa_driver);\r\npci_unregister_driver(&dfx_pci_driver);\r\n}
