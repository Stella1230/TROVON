static int xxxfb_open(struct fb_info *info, int user)\r\n{\r\nreturn 0;\r\n}\r\nstatic int xxxfb_release(struct fb_info *info, int user)\r\n{\r\nreturn 0;\r\n}\r\nstatic int xxxfb_check_var(struct fb_var_screeninfo *var, struct fb_info *info)\r\n{\r\nreturn 0;\r\n}\r\nstatic int xxxfb_set_par(struct fb_info *info)\r\n{\r\nstruct xxx_par *par = info->par;\r\nreturn 0;\r\n}\r\nstatic int xxxfb_setcolreg(unsigned regno, unsigned red, unsigned green,\r\nunsigned blue, unsigned transp,\r\nstruct fb_info *info)\r\n{\r\nif (regno >= 256)\r\nreturn -EINVAL;\r\nif (info->var.grayscale) {\r\nred = green = blue = (red * 77 + green * 151 + blue * 28) >> 8;\r\n}\r\n#define CNVT_TOHW(val,width) ((((val)<<(width))+0x7FFF-(val))>>16)\r\nred = CNVT_TOHW(red, info->var.red.length);\r\ngreen = CNVT_TOHW(green, info->var.green.length);\r\nblue = CNVT_TOHW(blue, info->var.blue.length);\r\ntransp = CNVT_TOHW(transp, info->var.transp.length);\r\n#undef CNVT_TOHW\r\nif (info->fix.visual == FB_VISUAL_DIRECTCOLOR ||\r\ninfo->fix.visual == FB_VISUAL_TRUECOLOR)\r\nwrite_{red|green|blue|transp}_to_clut();\r\nif (info->fix.visual == FB_VISUAL_TRUECOLOR ||\r\ninfo->fix.visual == FB_VISUAL_DIRECTCOLOR) {\r\nu32 v;\r\nif (regno >= 16)\r\nreturn -EINVAL;\r\nv = (red << info->var.red.offset) |\r\n(green << info->var.green.offset) |\r\n(blue << info->var.blue.offset) |\r\n(transp << info->var.transp.offset);\r\n((u32*)(info->pseudo_palette))[regno] = v;\r\n}\r\nreturn 0;\r\n}\r\nstatic int xxxfb_pan_display(struct fb_var_screeninfo *var,\r\nstruct fb_info *info)\r\n{\r\nreturn 0;\r\n}\r\nstatic int xxxfb_blank(int blank_mode, struct fb_info *info)\r\n{\r\nreturn 0;\r\n}\r\nvoid xxxfb_fillrect(struct fb_info *p, const struct fb_fillrect *region)\r\n{\r\n}\r\nvoid xxxfb_copyarea(struct fb_info *p, const struct fb_copyarea *area)\r\n{\r\n}\r\nvoid xxxfb_imageblit(struct fb_info *p, const struct fb_image *image)\r\n{\r\n}\r\nint xxxfb_cursor(struct fb_info *info, struct fb_cursor *cursor)\r\n{\r\n}\r\nvoid xxxfb_rotate(struct fb_info *info, int angle)\r\n{\r\n}\r\nint xxxfb_sync(struct fb_info *info)\r\n{\r\nreturn 0;\r\n}\r\nstatic int xxxfb_probe(struct pci_dev *dev, const struct pci_device_id *ent)\r\n{\r\nstruct fb_info *info;\r\nstruct xxx_par *par;\r\nstruct device *device = &dev->dev;\r\nint cmap_len, retval;\r\ninfo = framebuffer_alloc(sizeof(struct xxx_par), device);\r\nif (!info) {\r\n}\r\npar = info->par;\r\ninfo->screen_base = framebuffer_virtual_memory;\r\ninfo->fbops = &xxxfb_ops;\r\ninfo->fix = xxxfb_fix;\r\ninfo->pseudo_palette = pseudo_palette;\r\ninfo->flags = FBINFO_DEFAULT;\r\ninfo->pixmap.addr = kmalloc(PIXMAP_SIZE, GFP_KERNEL);\r\nif (!info->pixmap.addr) {\r\n}\r\ninfo->pixmap.size = PIXMAP_SIZE;\r\ninfo->pixmap.flags = FB_PIXMAP_SYSTEM;\r\ninfo->pixmap.scan_align = 4;\r\ninfo->pixmap.buf_align = 4;\r\ninfo->pixmap.access_align = 32;\r\nif (!mode_option)\r\nmode_option = "640x480@60";\r\nretval = fb_find_mode(&info->var, info, mode_option, NULL, 0, NULL, 8);\r\nif (!retval || retval == 4)\r\nreturn -EINVAL;\r\nif (fb_alloc_cmap(&info->cmap, cmap_len, 0))\r\nreturn -ENOMEM;\r\ninfo->var = xxxfb_var;\r\nxxxfb_check_var(&info->var, info);\r\nif (register_framebuffer(info) < 0) {\r\nfb_dealloc_cmap(&info->cmap);\r\nreturn -EINVAL;\r\n}\r\nprintk(KERN_INFO "fb%d: %s frame buffer device\n", info->node,\r\ninfo->fix.id);\r\npci_set_drvdata(dev, info);\r\nreturn 0;\r\n}\r\nstatic void xxxfb_remove(struct pci_dev *dev)\r\n{\r\nstruct fb_info *info = pci_get_drvdata(dev);\r\nif (info) {\r\nunregister_framebuffer(info);\r\nfb_dealloc_cmap(&info->cmap);\r\nframebuffer_release(info);\r\n}\r\n}\r\nstatic int xxxfb_suspend(struct pci_dev *dev, pm_message_t msg)\r\n{\r\nstruct fb_info *info = pci_get_drvdata(dev);\r\nstruct xxxfb_par *par = info->par;\r\nreturn 0;\r\n}\r\nstatic int xxxfb_resume(struct pci_dev *dev)\r\n{\r\nstruct fb_info *info = pci_get_drvdata(dev);\r\nstruct xxxfb_par *par = info->par;\r\nreturn 0;\r\n}\r\nint __init xxxfb_init(void)\r\n{\r\n#ifndef MODULE\r\nchar *option = NULL;\r\nif (fb_get_options("xxxfb", &option))\r\nreturn -ENODEV;\r\nxxxfb_setup(option);\r\n#endif\r\nreturn pci_register_driver(&xxxfb_driver);\r\n}\r\nstatic void __exit xxxfb_exit(void)\r\n{\r\npci_unregister_driver(&xxxfb_driver);\r\n}\r\nstatic int xxxfb_suspend(struct platform_device *dev, pm_message_t msg)\r\n{\r\nstruct fb_info *info = platform_get_drvdata(dev);\r\nstruct xxxfb_par *par = info->par;\r\nreturn 0;\r\n}\r\nstatic int xxxfb_resume(struct platform_dev *dev)\r\n{\r\nstruct fb_info *info = platform_get_drvdata(dev);\r\nstruct xxxfb_par *par = info->par;\r\nreturn 0;\r\n}\r\nint __init xxxfb_setup(char *options)\r\n{\r\n}\r\nstatic int __init xxxfb_init(void)\r\n{\r\nint ret;\r\n#ifndef MODULE\r\nchar *option = NULL;\r\nif (fb_get_options("xxxfb", &option))\r\nreturn -ENODEV;\r\nxxxfb_setup(option);\r\n#endif\r\nret = platform_driver_register(&xxxfb_driver);\r\nif (!ret) {\r\nxxxfb_device = platform_device_register_simple("xxxfb", 0,\r\nNULL, 0);\r\nif (IS_ERR(xxxfb_device)) {\r\nplatform_driver_unregister(&xxxfb_driver);\r\nret = PTR_ERR(xxxfb_device);\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic void __exit xxxfb_exit(void)\r\n{\r\nplatform_device_unregister(xxxfb_device);\r\nplatform_driver_unregister(&xxxfb_driver);\r\n}
