static int pm860x_volatile(unsigned int reg)\r\n{\r\nBUG_ON(reg >= REG_CACHE_SIZE);\r\nswitch (reg) {\r\ncase PM860X_AUDIO_SUPPLIES_2:\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic unsigned int pm860x_read_reg_cache(struct snd_soc_codec *codec,\r\nunsigned int reg)\r\n{\r\nunsigned char *cache = codec->reg_cache;\r\nBUG_ON(reg >= REG_CACHE_SIZE);\r\nif (pm860x_volatile(reg))\r\nreturn cache[reg];\r\nreg += REG_CACHE_BASE;\r\nreturn pm860x_reg_read(codec->control_data, reg);\r\n}\r\nstatic int pm860x_write_reg_cache(struct snd_soc_codec *codec,\r\nunsigned int reg, unsigned int value)\r\n{\r\nunsigned char *cache = codec->reg_cache;\r\nBUG_ON(reg >= REG_CACHE_SIZE);\r\nif (!pm860x_volatile(reg))\r\ncache[reg] = (unsigned char)value;\r\nreg += REG_CACHE_BASE;\r\nreturn pm860x_reg_write(codec->control_data, reg, value);\r\n}\r\nstatic int snd_soc_get_volsw_2r_st(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct soc_mixer_control *mc =\r\n(struct soc_mixer_control *)kcontrol->private_value;\r\nstruct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);\r\nunsigned int reg = mc->reg;\r\nunsigned int reg2 = mc->rreg;\r\nint val[2], val2[2], i;\r\nval[0] = snd_soc_read(codec, reg) & 0x3f;\r\nval[1] = (snd_soc_read(codec, PM860X_SIDETONE_SHIFT) >> 4) & 0xf;\r\nval2[0] = snd_soc_read(codec, reg2) & 0x3f;\r\nval2[1] = (snd_soc_read(codec, PM860X_SIDETONE_SHIFT)) & 0xf;\r\nfor (i = 0; i < ARRAY_SIZE(st_table); i++) {\r\nif ((st_table[i].m == val[0]) && (st_table[i].n == val[1]))\r\nucontrol->value.integer.value[0] = i;\r\nif ((st_table[i].m == val2[0]) && (st_table[i].n == val2[1]))\r\nucontrol->value.integer.value[1] = i;\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_soc_put_volsw_2r_st(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct soc_mixer_control *mc =\r\n(struct soc_mixer_control *)kcontrol->private_value;\r\nstruct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);\r\nunsigned int reg = mc->reg;\r\nunsigned int reg2 = mc->rreg;\r\nint err;\r\nunsigned int val, val2;\r\nval = ucontrol->value.integer.value[0];\r\nval2 = ucontrol->value.integer.value[1];\r\nerr = snd_soc_update_bits(codec, reg, 0x3f, st_table[val].m);\r\nif (err < 0)\r\nreturn err;\r\nerr = snd_soc_update_bits(codec, PM860X_SIDETONE_SHIFT, 0xf0,\r\nst_table[val].n << 4);\r\nif (err < 0)\r\nreturn err;\r\nerr = snd_soc_update_bits(codec, reg2, 0x3f, st_table[val2].m);\r\nif (err < 0)\r\nreturn err;\r\nerr = snd_soc_update_bits(codec, PM860X_SIDETONE_SHIFT, 0x0f,\r\nst_table[val2].n);\r\nreturn err;\r\n}\r\nstatic int snd_soc_get_volsw_2r_out(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct soc_mixer_control *mc =\r\n(struct soc_mixer_control *)kcontrol->private_value;\r\nstruct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);\r\nunsigned int reg = mc->reg;\r\nunsigned int reg2 = mc->rreg;\r\nunsigned int shift = mc->shift;\r\nint max = mc->max, val, val2;\r\nunsigned int mask = (1 << fls(max)) - 1;\r\nval = snd_soc_read(codec, reg) >> shift;\r\nval2 = snd_soc_read(codec, reg2) >> shift;\r\nucontrol->value.integer.value[0] = (max - val) & mask;\r\nucontrol->value.integer.value[1] = (max - val2) & mask;\r\nreturn 0;\r\n}\r\nstatic int snd_soc_put_volsw_2r_out(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct soc_mixer_control *mc =\r\n(struct soc_mixer_control *)kcontrol->private_value;\r\nstruct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);\r\nunsigned int reg = mc->reg;\r\nunsigned int reg2 = mc->rreg;\r\nunsigned int shift = mc->shift;\r\nint max = mc->max;\r\nunsigned int mask = (1 << fls(max)) - 1;\r\nint err;\r\nunsigned int val, val2, val_mask;\r\nval_mask = mask << shift;\r\nval = ((max - ucontrol->value.integer.value[0]) & mask);\r\nval2 = ((max - ucontrol->value.integer.value[1]) & mask);\r\nval = val << shift;\r\nval2 = val2 << shift;\r\nerr = snd_soc_update_bits(codec, reg, val_mask, val);\r\nif (err < 0)\r\nreturn err;\r\nerr = snd_soc_update_bits(codec, reg2, val_mask, val2);\r\nreturn err;\r\n}\r\nstatic int pm860x_rsync_event(struct snd_soc_dapm_widget *w,\r\nstruct snd_kcontrol *kcontrol, int event)\r\n{\r\nstruct snd_soc_codec *codec = w->codec;\r\nsnd_soc_update_bits(codec, PM860X_DAC_OFFSET, DAC_MUTE, 0);\r\nsnd_soc_update_bits(codec, PM860X_EAR_CTRL_2,\r\nRSYNC_CHANGE, RSYNC_CHANGE);\r\nreturn 0;\r\n}\r\nstatic int pm860x_dac_event(struct snd_soc_dapm_widget *w,\r\nstruct snd_kcontrol *kcontrol, int event)\r\n{\r\nstruct snd_soc_codec *codec = w->codec;\r\nunsigned int dac = 0;\r\nint data;\r\nif (!strcmp(w->name, "Left DAC"))\r\ndac = DAC_LEFT;\r\nif (!strcmp(w->name, "Right DAC"))\r\ndac = DAC_RIGHT;\r\nswitch (event) {\r\ncase SND_SOC_DAPM_PRE_PMU:\r\nif (dac) {\r\ndac |= MODULATOR;\r\nsnd_soc_update_bits(codec, PM860X_DAC_OFFSET,\r\nDAC_MUTE, DAC_MUTE);\r\nsnd_soc_update_bits(codec, PM860X_EAR_CTRL_2,\r\nRSYNC_CHANGE, RSYNC_CHANGE);\r\nsnd_soc_update_bits(codec, PM860X_DAC_EN_2,\r\ndac, dac);\r\n}\r\nbreak;\r\ncase SND_SOC_DAPM_PRE_PMD:\r\nif (dac) {\r\nsnd_soc_update_bits(codec, PM860X_DAC_OFFSET,\r\nDAC_MUTE, DAC_MUTE);\r\nsnd_soc_update_bits(codec, PM860X_EAR_CTRL_2,\r\nRSYNC_CHANGE, RSYNC_CHANGE);\r\ndata = snd_soc_read(codec, PM860X_DAC_EN_2);\r\ndata &= ~dac;\r\nif (!(data & (DAC_LEFT | DAC_RIGHT)))\r\ndata &= ~MODULATOR;\r\nsnd_soc_write(codec, PM860X_DAC_EN_2, data);\r\n}\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int pm860x_digital_mute(struct snd_soc_dai *codec_dai, int mute)\r\n{\r\nstruct snd_soc_codec *codec = codec_dai->codec;\r\nint data = 0, mask = MUTE_LEFT | MUTE_RIGHT;\r\nif (mute)\r\ndata = mask;\r\nsnd_soc_update_bits(codec, PM860X_DAC_OFFSET, mask, data);\r\nsnd_soc_update_bits(codec, PM860X_EAR_CTRL_2,\r\nRSYNC_CHANGE, RSYNC_CHANGE);\r\nreturn 0;\r\n}\r\nstatic int pm860x_pcm_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nunsigned char inf = 0, mask = 0;\r\nswitch (params_format(params)) {\r\ncase SNDRV_PCM_FORMAT_S16_LE:\r\ninf &= ~PCM_INF2_18WL;\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S18_3LE:\r\ninf |= PCM_INF2_18WL;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nmask |= PCM_INF2_18WL;\r\nsnd_soc_update_bits(codec, PM860X_PCM_IFACE_2, mask, inf);\r\nswitch (params_rate(params)) {\r\ncase 8000:\r\ninf = 0;\r\nbreak;\r\ncase 16000:\r\ninf = 3;\r\nbreak;\r\ncase 32000:\r\ninf = 6;\r\nbreak;\r\ncase 48000:\r\ninf = 8;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nsnd_soc_update_bits(codec, PM860X_PCM_RATE, 0x0f, inf);\r\nreturn 0;\r\n}\r\nstatic int pm860x_pcm_set_dai_fmt(struct snd_soc_dai *codec_dai,\r\nunsigned int fmt)\r\n{\r\nstruct snd_soc_codec *codec = codec_dai->codec;\r\nstruct pm860x_priv *pm860x = snd_soc_codec_get_drvdata(codec);\r\nunsigned char inf = 0, mask = 0;\r\nint ret = -EINVAL;\r\nmask |= PCM_INF2_BCLK | PCM_INF2_FS | PCM_INF2_MASTER;\r\nswitch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {\r\ncase SND_SOC_DAIFMT_CBM_CFM:\r\ncase SND_SOC_DAIFMT_CBM_CFS:\r\nif (pm860x->dir == PM860X_CLK_DIR_OUT) {\r\ninf |= PCM_INF2_MASTER;\r\nret = 0;\r\n}\r\nbreak;\r\ncase SND_SOC_DAIFMT_CBS_CFS:\r\nif (pm860x->dir == PM860X_CLK_DIR_IN) {\r\ninf &= ~PCM_INF2_MASTER;\r\nret = 0;\r\n}\r\nbreak;\r\n}\r\nswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\r\ncase SND_SOC_DAIFMT_I2S:\r\ninf |= PCM_EXACT_I2S;\r\nret = 0;\r\nbreak;\r\n}\r\nmask |= PCM_MODE_MASK;\r\nif (ret)\r\nreturn ret;\r\nsnd_soc_update_bits(codec, PM860X_PCM_IFACE_2, mask, inf);\r\nreturn 0;\r\n}\r\nstatic int pm860x_set_dai_sysclk(struct snd_soc_dai *codec_dai,\r\nint clk_id, unsigned int freq, int dir)\r\n{\r\nstruct snd_soc_codec *codec = codec_dai->codec;\r\nstruct pm860x_priv *pm860x = snd_soc_codec_get_drvdata(codec);\r\nif (dir == PM860X_CLK_DIR_OUT)\r\npm860x->dir = PM860X_CLK_DIR_OUT;\r\nelse {\r\npm860x->dir = PM860X_CLK_DIR_IN;\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int pm860x_i2s_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nunsigned char inf;\r\nswitch (params_format(params)) {\r\ncase SNDRV_PCM_FORMAT_S16_LE:\r\ninf = 0;\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S18_3LE:\r\ninf = PCM_INF2_18WL;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nsnd_soc_update_bits(codec, PM860X_I2S_IFACE_2, PCM_INF2_18WL, inf);\r\nswitch (params_rate(params)) {\r\ncase 8000:\r\ninf = 0;\r\nbreak;\r\ncase 11025:\r\ninf = 1;\r\nbreak;\r\ncase 16000:\r\ninf = 3;\r\nbreak;\r\ncase 22050:\r\ninf = 4;\r\nbreak;\r\ncase 32000:\r\ninf = 6;\r\nbreak;\r\ncase 44100:\r\ninf = 7;\r\nbreak;\r\ncase 48000:\r\ninf = 8;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nsnd_soc_update_bits(codec, PM860X_I2S_IFACE_4, 0xf, inf);\r\nreturn 0;\r\n}\r\nstatic int pm860x_i2s_set_dai_fmt(struct snd_soc_dai *codec_dai,\r\nunsigned int fmt)\r\n{\r\nstruct snd_soc_codec *codec = codec_dai->codec;\r\nstruct pm860x_priv *pm860x = snd_soc_codec_get_drvdata(codec);\r\nunsigned char inf = 0, mask = 0;\r\nmask |= PCM_INF2_BCLK | PCM_INF2_FS | PCM_INF2_MASTER;\r\nswitch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {\r\ncase SND_SOC_DAIFMT_CBM_CFM:\r\nif (pm860x->dir == PM860X_CLK_DIR_OUT)\r\ninf |= PCM_INF2_MASTER;\r\nelse\r\nreturn -EINVAL;\r\nbreak;\r\ncase SND_SOC_DAIFMT_CBS_CFS:\r\nif (pm860x->dir == PM860X_CLK_DIR_IN)\r\ninf &= ~PCM_INF2_MASTER;\r\nelse\r\nreturn -EINVAL;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\r\ncase SND_SOC_DAIFMT_I2S:\r\ninf |= PCM_EXACT_I2S;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nmask |= PCM_MODE_MASK;\r\nsnd_soc_update_bits(codec, PM860X_I2S_IFACE_2, mask, inf);\r\nreturn 0;\r\n}\r\nstatic int pm860x_set_bias_level(struct snd_soc_codec *codec,\r\nenum snd_soc_bias_level level)\r\n{\r\nint data;\r\nswitch (level) {\r\ncase SND_SOC_BIAS_ON:\r\nbreak;\r\ncase SND_SOC_BIAS_PREPARE:\r\nbreak;\r\ncase SND_SOC_BIAS_STANDBY:\r\nif (codec->dapm.bias_level == SND_SOC_BIAS_OFF) {\r\ndata = AUDIO_PLL | AUDIO_SECTION_ON;\r\npm860x_reg_write(codec->control_data, REG_MISC2, data);\r\nudelay(300);\r\ndata = AUDIO_PLL | AUDIO_SECTION_RESET\r\n| AUDIO_SECTION_ON;\r\npm860x_reg_write(codec->control_data, REG_MISC2, data);\r\n}\r\nbreak;\r\ncase SND_SOC_BIAS_OFF:\r\ndata = AUDIO_PLL | AUDIO_SECTION_RESET | AUDIO_SECTION_ON;\r\npm860x_set_bits(codec->control_data, REG_MISC2, data, 0);\r\nbreak;\r\n}\r\ncodec->dapm.bias_level = level;\r\nreturn 0;\r\n}\r\nstatic irqreturn_t pm860x_codec_handler(int irq, void *data)\r\n{\r\nstruct pm860x_priv *pm860x = data;\r\nint status, shrt, report = 0, mic_report = 0;\r\nint mask;\r\nstatus = pm860x_reg_read(pm860x->i2c, REG_STATUS_1);\r\nshrt = pm860x_reg_read(pm860x->i2c, REG_SHORTS);\r\nmask = pm860x->det.hs_shrt | pm860x->det.hook_det | pm860x->det.lo_shrt\r\n| pm860x->det.hp_det;\r\n#ifndef CONFIG_SND_SOC_88PM860X_MODULE\r\nif (status & (HEADSET_STATUS | MIC_STATUS | SHORT_HS1 | SHORT_HS2 |\r\nSHORT_LO1 | SHORT_LO2))\r\ntrace_snd_soc_jack_irq(dev_name(pm860x->codec->dev));\r\n#endif\r\nif ((pm860x->det.hp_det & SND_JACK_HEADPHONE)\r\n&& (status & HEADSET_STATUS))\r\nreport |= SND_JACK_HEADPHONE;\r\nif ((pm860x->det.mic_det & SND_JACK_MICROPHONE)\r\n&& (status & MIC_STATUS))\r\nmic_report |= SND_JACK_MICROPHONE;\r\nif (pm860x->det.hs_shrt && (shrt & (SHORT_HS1 | SHORT_HS2)))\r\nreport |= pm860x->det.hs_shrt;\r\nif (pm860x->det.hook_det && (status & HOOK_STATUS))\r\nreport |= pm860x->det.hook_det;\r\nif (pm860x->det.lo_shrt && (shrt & (SHORT_LO1 | SHORT_LO2)))\r\nreport |= pm860x->det.lo_shrt;\r\nif (report)\r\nsnd_soc_jack_report(pm860x->det.hp_jack, report, mask);\r\nif (mic_report)\r\nsnd_soc_jack_report(pm860x->det.mic_jack, SND_JACK_MICROPHONE,\r\nSND_JACK_MICROPHONE);\r\ndev_dbg(pm860x->codec->dev, "headphone report:0x%x, mask:%x\n",\r\nreport, mask);\r\ndev_dbg(pm860x->codec->dev, "microphone report:0x%x\n", mic_report);\r\nreturn IRQ_HANDLED;\r\n}\r\nint pm860x_hs_jack_detect(struct snd_soc_codec *codec,\r\nstruct snd_soc_jack *jack,\r\nint det, int hook, int hs_shrt, int lo_shrt)\r\n{\r\nstruct pm860x_priv *pm860x = snd_soc_codec_get_drvdata(codec);\r\nint data;\r\npm860x->det.hp_jack = jack;\r\npm860x->det.hp_det = det;\r\npm860x->det.hook_det = hook;\r\npm860x->det.hs_shrt = hs_shrt;\r\npm860x->det.lo_shrt = lo_shrt;\r\nif (det & SND_JACK_HEADPHONE)\r\npm860x_set_bits(codec->control_data, REG_HS_DET,\r\nEN_HS_DET, EN_HS_DET);\r\nif (hs_shrt) {\r\ndata = CLR_SHORT_HS2 | CLR_SHORT_HS1;\r\npm860x_set_bits(codec->control_data, REG_SHORTS, data, data);\r\n}\r\nif (lo_shrt) {\r\ndata = CLR_SHORT_LO2 | CLR_SHORT_LO1;\r\npm860x_set_bits(codec->control_data, REG_SHORTS, data, data);\r\n}\r\npm860x_codec_handler(0, pm860x);\r\nreturn 0;\r\n}\r\nint pm860x_mic_jack_detect(struct snd_soc_codec *codec,\r\nstruct snd_soc_jack *jack, int det)\r\n{\r\nstruct pm860x_priv *pm860x = snd_soc_codec_get_drvdata(codec);\r\npm860x->det.mic_jack = jack;\r\npm860x->det.mic_det = det;\r\nif (det & SND_JACK_MICROPHONE)\r\npm860x_set_bits(codec->control_data, REG_MIC_DET,\r\nMICDET_MASK, MICDET_MASK);\r\npm860x_codec_handler(0, pm860x);\r\nreturn 0;\r\n}\r\nstatic int pm860x_probe(struct snd_soc_codec *codec)\r\n{\r\nstruct pm860x_priv *pm860x = snd_soc_codec_get_drvdata(codec);\r\nint i, ret;\r\npm860x->codec = codec;\r\ncodec->control_data = pm860x->i2c;\r\nfor (i = 0; i < 4; i++) {\r\nret = request_threaded_irq(pm860x->irq[i], NULL,\r\npm860x_codec_handler, IRQF_ONESHOT,\r\npm860x->name[i], pm860x);\r\nif (ret < 0) {\r\ndev_err(codec->dev, "Failed to request IRQ!\n");\r\ngoto out;\r\n}\r\n}\r\npm860x_set_bias_level(codec, SND_SOC_BIAS_STANDBY);\r\nret = pm860x_bulk_read(codec->control_data, REG_CACHE_BASE,\r\nREG_CACHE_SIZE, codec->reg_cache);\r\nif (ret < 0) {\r\ndev_err(codec->dev, "Failed to fill register cache: %d\n",\r\nret);\r\ngoto out;\r\n}\r\nreturn 0;\r\nout:\r\nwhile (--i >= 0)\r\nfree_irq(pm860x->irq[i], pm860x);\r\nreturn ret;\r\n}\r\nstatic int pm860x_remove(struct snd_soc_codec *codec)\r\n{\r\nstruct pm860x_priv *pm860x = snd_soc_codec_get_drvdata(codec);\r\nint i;\r\nfor (i = 3; i >= 0; i--)\r\nfree_irq(pm860x->irq[i], pm860x);\r\npm860x_set_bias_level(codec, SND_SOC_BIAS_OFF);\r\nreturn 0;\r\n}\r\nstatic int pm860x_codec_probe(struct platform_device *pdev)\r\n{\r\nstruct pm860x_chip *chip = dev_get_drvdata(pdev->dev.parent);\r\nstruct pm860x_priv *pm860x;\r\nstruct resource *res;\r\nint i, ret;\r\npm860x = devm_kzalloc(&pdev->dev, sizeof(struct pm860x_priv),\r\nGFP_KERNEL);\r\nif (pm860x == NULL)\r\nreturn -ENOMEM;\r\npm860x->chip = chip;\r\npm860x->i2c = (chip->id == CHIP_PM8607) ? chip->client\r\n: chip->companion;\r\nplatform_set_drvdata(pdev, pm860x);\r\nfor (i = 0; i < 4; i++) {\r\nres = platform_get_resource(pdev, IORESOURCE_IRQ, i);\r\nif (!res) {\r\ndev_err(&pdev->dev, "Failed to get IRQ resources\n");\r\ngoto out;\r\n}\r\npm860x->irq[i] = res->start + chip->irq_base;\r\nstrncpy(pm860x->name[i], res->name, MAX_NAME_LEN);\r\n}\r\nret = snd_soc_register_codec(&pdev->dev, &soc_codec_dev_pm860x,\r\npm860x_dai, ARRAY_SIZE(pm860x_dai));\r\nif (ret) {\r\ndev_err(&pdev->dev, "Failed to register codec\n");\r\ngoto out;\r\n}\r\nreturn ret;\r\nout:\r\nplatform_set_drvdata(pdev, NULL);\r\nreturn -EINVAL;\r\n}\r\nstatic int pm860x_codec_remove(struct platform_device *pdev)\r\n{\r\nsnd_soc_unregister_codec(&pdev->dev);\r\nplatform_set_drvdata(pdev, NULL);\r\nreturn 0;\r\n}
