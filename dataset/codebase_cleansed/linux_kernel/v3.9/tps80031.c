int tps80031_ext_power_req_config(struct device *dev,\r\nunsigned long ext_ctrl_flag, int preq_bit,\r\nint state_reg_add, int trans_reg_add)\r\n{\r\nu8 res_ass_reg = 0;\r\nint preq_mask_bit = 0;\r\nint ret;\r\nif (!(ext_ctrl_flag & TPS80031_EXT_PWR_REQ))\r\nreturn 0;\r\nif (ext_ctrl_flag & TPS80031_PWR_REQ_INPUT_PREQ1) {\r\nres_ass_reg = TPS80031_PREQ1_RES_ASS_A + (preq_bit >> 3);\r\npreq_mask_bit = 5;\r\n} else if (ext_ctrl_flag & TPS80031_PWR_REQ_INPUT_PREQ2) {\r\nres_ass_reg = TPS80031_PREQ2_RES_ASS_A + (preq_bit >> 3);\r\npreq_mask_bit = 6;\r\n} else if (ext_ctrl_flag & TPS80031_PWR_REQ_INPUT_PREQ3) {\r\nres_ass_reg = TPS80031_PREQ3_RES_ASS_A + (preq_bit >> 3);\r\npreq_mask_bit = 7;\r\n}\r\nret = tps80031_set_bits(dev, TPS80031_SLAVE_ID1, res_ass_reg,\r\nBIT(preq_bit & 0x7));\r\nif (ret < 0) {\r\ndev_err(dev, "reg 0x%02x setbit failed, err = %d\n",\r\nres_ass_reg, ret);\r\nreturn ret;\r\n}\r\nret = tps80031_clr_bits(dev, TPS80031_SLAVE_ID1,\r\nTPS80031_PHOENIX_MSK_TRANSITION, BIT(preq_mask_bit));\r\nif (ret < 0) {\r\ndev_err(dev, "reg 0x%02x clrbit failed, err = %d\n",\r\nTPS80031_PHOENIX_MSK_TRANSITION, ret);\r\nreturn ret;\r\n}\r\nif (ext_ctrl_flag & (TPS80031_PWR_REQ_INPUT_PREQ2 |\r\nTPS80031_PWR_REQ_INPUT_PREQ3)) {\r\nret = tps80031_update(dev, TPS80031_SLAVE_ID1, state_reg_add,\r\n0x0, TPS80031_STATE_MASK);\r\nif (ret < 0)\r\ndev_err(dev, "reg 0x%02x update failed, err = %d\n",\r\nstate_reg_add, ret);\r\n} else {\r\nret = tps80031_update(dev, TPS80031_SLAVE_ID1, trans_reg_add,\r\nTPS80031_TRANS_SLEEP_OFF,\r\nTPS80031_TRANS_SLEEP_MASK);\r\nif (ret < 0)\r\ndev_err(dev, "reg 0x%02x update failed, err = %d\n",\r\ntrans_reg_add, ret);\r\n}\r\nreturn ret;\r\n}\r\nstatic void tps80031_power_off(void)\r\n{\r\ndev_info(tps80031_power_off_dev->dev, "switching off PMU\n");\r\ntps80031_write(tps80031_power_off_dev->dev, TPS80031_SLAVE_ID1,\r\nTPS80031_PHOENIX_DEV_ON, TPS80031_DEVOFF);\r\n}\r\nstatic void tps80031_pupd_init(struct tps80031 *tps80031,\r\nstruct tps80031_platform_data *pdata)\r\n{\r\nstruct tps80031_pupd_init_data *pupd_init_data = pdata->pupd_init_data;\r\nint data_size = pdata->pupd_init_data_size;\r\nint i;\r\nfor (i = 0; i < data_size; ++i) {\r\nstruct tps80031_pupd_init_data *pupd_init = &pupd_init_data[i];\r\nconst struct tps80031_pupd_data *pupd =\r\n&tps80031_pupds[pupd_init->input_pin];\r\nu8 update_value = 0;\r\nu8 update_mask = pupd->pulldown_bit | pupd->pullup_bit;\r\nif (pupd_init->setting == TPS80031_PUPD_PULLDOWN)\r\nupdate_value = pupd->pulldown_bit;\r\nelse if (pupd_init->setting == TPS80031_PUPD_PULLUP)\r\nupdate_value = pupd->pullup_bit;\r\ntps80031_update(tps80031->dev, TPS80031_SLAVE_ID1, pupd->reg,\r\nupdate_value, update_mask);\r\n}\r\n}\r\nstatic int tps80031_init_ext_control(struct tps80031 *tps80031,\r\nstruct tps80031_platform_data *pdata)\r\n{\r\nstruct device *dev = tps80031->dev;\r\nint ret;\r\nint i;\r\nfor (i = 0; i < 9; ++i) {\r\nret = tps80031_write(dev, TPS80031_SLAVE_ID1,\r\nTPS80031_PREQ1_RES_ASS_A + i, 0);\r\nif (ret < 0) {\r\ndev_err(dev, "reg 0x%02x write failed, err = %d\n",\r\nTPS80031_PREQ1_RES_ASS_A + i, ret);\r\nreturn ret;\r\n}\r\n}\r\nret = tps80031_set_bits(dev, TPS80031_SLAVE_ID1,\r\nTPS80031_PHOENIX_MSK_TRANSITION, 0x7 << 5);\r\nif (ret < 0) {\r\ndev_err(dev, "reg 0x%02x set_bits failed, err = %d\n",\r\nTPS80031_PHOENIX_MSK_TRANSITION, ret);\r\nreturn ret;\r\n}\r\nreturn ret;\r\n}\r\nstatic int tps80031_irq_init(struct tps80031 *tps80031, int irq, int irq_base)\r\n{\r\nstruct device *dev = tps80031->dev;\r\nint i, ret;\r\nfor (i = 0; i < 3; i++)\r\ntps80031_write(dev, TPS80031_SLAVE_ID2,\r\nTPS80031_INT_MSK_STS_A + i, 0x00);\r\nret = regmap_add_irq_chip(tps80031->regmap[TPS80031_SLAVE_ID2], irq,\r\nIRQF_ONESHOT, irq_base,\r\n&tps80031_irq_chip, &tps80031->irq_data);\r\nif (ret < 0) {\r\ndev_err(dev, "add irq failed, err = %d\n", ret);\r\nreturn ret;\r\n}\r\nreturn ret;\r\n}\r\nstatic bool rd_wr_reg_id0(struct device *dev, unsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase TPS80031_SMPS1_CFG_FORCE ... TPS80031_SMPS2_CFG_VOLTAGE:\r\nreturn true;\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nstatic bool rd_wr_reg_id1(struct device *dev, unsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase TPS80031_SECONDS_REG ... TPS80031_RTC_RESET_STATUS_REG:\r\ncase TPS80031_VALIDITY0 ... TPS80031_VALIDITY7:\r\ncase TPS80031_PHOENIX_START_CONDITION ... TPS80031_KEY_PRESS_DUR_CFG:\r\ncase TPS80031_SMPS4_CFG_TRANS ... TPS80031_SMPS3_CFG_VOLTAGE:\r\ncase TPS80031_BROADCAST_ADDR_ALL ... TPS80031_BROADCAST_ADDR_CLK_RST:\r\ncase TPS80031_VANA_CFG_TRANS ... TPS80031_LDO7_CFG_VOLTAGE:\r\ncase TPS80031_REGEN1_CFG_TRANS ... TPS80031_TMP_CFG_STATE:\r\ncase TPS80031_PREQ1_RES_ASS_A ... TPS80031_PREQ3_RES_ASS_C:\r\ncase TPS80031_SMPS_OFFSET ... TPS80031_BATDEBOUNCING:\r\ncase TPS80031_CFG_INPUT_PUPD1 ... TPS80031_CFG_SMPS_PD:\r\ncase TPS80031_BACKUP_REG:\r\nreturn true;\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nstatic bool is_volatile_reg_id1(struct device *dev, unsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase TPS80031_SMPS4_CFG_TRANS ... TPS80031_SMPS3_CFG_VOLTAGE:\r\ncase TPS80031_VANA_CFG_TRANS ... TPS80031_LDO7_CFG_VOLTAGE:\r\ncase TPS80031_REGEN1_CFG_TRANS ... TPS80031_TMP_CFG_STATE:\r\ncase TPS80031_PREQ1_RES_ASS_A ... TPS80031_PREQ3_RES_ASS_C:\r\ncase TPS80031_SMPS_OFFSET ... TPS80031_BATDEBOUNCING:\r\ncase TPS80031_CFG_INPUT_PUPD1 ... TPS80031_CFG_SMPS_PD:\r\nreturn true;\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nstatic bool rd_wr_reg_id2(struct device *dev, unsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase TPS80031_USB_VENDOR_ID_LSB ... TPS80031_USB_OTG_REVISION:\r\ncase TPS80031_GPADC_CTRL ... TPS80031_CTRL_P1:\r\ncase TPS80031_RTCH0_LSB ... TPS80031_GPCH0_MSB:\r\ncase TPS80031_TOGGLE1 ... TPS80031_VIBMODE:\r\ncase TPS80031_PWM1ON ... TPS80031_PWM2OFF:\r\ncase TPS80031_FG_REG_00 ... TPS80031_FG_REG_11:\r\ncase TPS80031_INT_STS_A ... TPS80031_INT_MSK_STS_C:\r\ncase TPS80031_CONTROLLER_CTRL2 ... TPS80031_LED_PWM_CTRL2:\r\nreturn true;\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nstatic bool rd_wr_reg_id3(struct device *dev, unsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase TPS80031_GPADC_TRIM0 ... TPS80031_GPADC_TRIM18:\r\nreturn true;\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nstatic int tps80031_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct tps80031_platform_data *pdata = client->dev.platform_data;\r\nstruct tps80031 *tps80031;\r\nint ret;\r\nuint8_t es_version;\r\nuint8_t ep_ver;\r\nint i;\r\nif (!pdata) {\r\ndev_err(&client->dev, "tps80031 requires platform data\n");\r\nreturn -EINVAL;\r\n}\r\ntps80031 = devm_kzalloc(&client->dev, sizeof(*tps80031), GFP_KERNEL);\r\nif (!tps80031) {\r\ndev_err(&client->dev, "Malloc failed for tps80031\n");\r\nreturn -ENOMEM;\r\n}\r\nfor (i = 0; i < TPS80031_NUM_SLAVES; i++) {\r\nif (tps80031_slave_address[i] == client->addr)\r\ntps80031->clients[i] = client;\r\nelse\r\ntps80031->clients[i] = i2c_new_dummy(client->adapter,\r\ntps80031_slave_address[i]);\r\nif (!tps80031->clients[i]) {\r\ndev_err(&client->dev, "can't attach client %d\n", i);\r\nret = -ENOMEM;\r\ngoto fail_client_reg;\r\n}\r\ni2c_set_clientdata(tps80031->clients[i], tps80031);\r\ntps80031->regmap[i] = devm_regmap_init_i2c(tps80031->clients[i],\r\n&tps80031_regmap_configs[i]);\r\nif (IS_ERR(tps80031->regmap[i])) {\r\nret = PTR_ERR(tps80031->regmap[i]);\r\ndev_err(&client->dev,\r\n"regmap %d init failed, err %d\n", i, ret);\r\ngoto fail_client_reg;\r\n}\r\n}\r\nret = tps80031_read(&client->dev, TPS80031_SLAVE_ID3,\r\nTPS80031_JTAGVERNUM, &es_version);\r\nif (ret < 0) {\r\ndev_err(&client->dev,\r\n"Silicon version number read failed: %d\n", ret);\r\ngoto fail_client_reg;\r\n}\r\nret = tps80031_read(&client->dev, TPS80031_SLAVE_ID3,\r\nTPS80031_EPROM_REV, &ep_ver);\r\nif (ret < 0) {\r\ndev_err(&client->dev,\r\n"Silicon eeprom version read failed: %d\n", ret);\r\ngoto fail_client_reg;\r\n}\r\ndev_info(&client->dev, "ES version 0x%02x and EPROM version 0x%02x\n",\r\nes_version, ep_ver);\r\ntps80031->es_version = es_version;\r\ntps80031->dev = &client->dev;\r\ni2c_set_clientdata(client, tps80031);\r\ntps80031->chip_info = id->driver_data;\r\nret = tps80031_irq_init(tps80031, client->irq, pdata->irq_base);\r\nif (ret) {\r\ndev_err(&client->dev, "IRQ init failed: %d\n", ret);\r\ngoto fail_client_reg;\r\n}\r\ntps80031_pupd_init(tps80031, pdata);\r\ntps80031_init_ext_control(tps80031, pdata);\r\nret = mfd_add_devices(tps80031->dev, -1,\r\ntps80031_cell, ARRAY_SIZE(tps80031_cell),\r\nNULL, 0,\r\nregmap_irq_get_domain(tps80031->irq_data));\r\nif (ret < 0) {\r\ndev_err(&client->dev, "mfd_add_devices failed: %d\n", ret);\r\ngoto fail_mfd_add;\r\n}\r\nif (pdata->use_power_off && !pm_power_off) {\r\ntps80031_power_off_dev = tps80031;\r\npm_power_off = tps80031_power_off;\r\n}\r\nreturn 0;\r\nfail_mfd_add:\r\nregmap_del_irq_chip(client->irq, tps80031->irq_data);\r\nfail_client_reg:\r\nfor (i = 0; i < TPS80031_NUM_SLAVES; i++) {\r\nif (tps80031->clients[i] && (tps80031->clients[i] != client))\r\ni2c_unregister_device(tps80031->clients[i]);\r\n}\r\nreturn ret;\r\n}\r\nstatic int tps80031_remove(struct i2c_client *client)\r\n{\r\nstruct tps80031 *tps80031 = i2c_get_clientdata(client);\r\nint i;\r\nif (tps80031_power_off_dev == tps80031) {\r\ntps80031_power_off_dev = NULL;\r\npm_power_off = NULL;\r\n}\r\nmfd_remove_devices(tps80031->dev);\r\nregmap_del_irq_chip(client->irq, tps80031->irq_data);\r\nfor (i = 0; i < TPS80031_NUM_SLAVES; i++) {\r\nif (tps80031->clients[i] != client)\r\ni2c_unregister_device(tps80031->clients[i]);\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init tps80031_init(void)\r\n{\r\nreturn i2c_add_driver(&tps80031_driver);\r\n}\r\nstatic void __exit tps80031_exit(void)\r\n{\r\ni2c_del_driver(&tps80031_driver);\r\n}
