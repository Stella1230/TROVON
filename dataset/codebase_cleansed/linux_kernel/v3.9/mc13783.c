static unsigned int mc13783_read(struct snd_soc_codec *codec,\r\nunsigned int reg)\r\n{\r\nstruct mc13783_priv *priv = snd_soc_codec_get_drvdata(codec);\r\nunsigned int value = 0;\r\nmc13xxx_lock(priv->mc13xxx);\r\nmc13xxx_reg_read(priv->mc13xxx, reg, &value);\r\nmc13xxx_unlock(priv->mc13xxx);\r\nreturn value;\r\n}\r\nstatic int mc13783_write(struct snd_soc_codec *codec,\r\nunsigned int reg, unsigned int value)\r\n{\r\nstruct mc13783_priv *priv = snd_soc_codec_get_drvdata(codec);\r\nint ret;\r\nmc13xxx_lock(priv->mc13xxx);\r\nret = mc13xxx_reg_write(priv->mc13xxx, reg, value);\r\nmc13xxx_unlock(priv->mc13xxx);\r\nreturn ret;\r\n}\r\nstatic int mc13783_pcm_hw_params_dac(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\nstruct snd_soc_codec *codec = rtd->codec;\r\nunsigned int rate = params_rate(params);\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(mc13783_rates); i++) {\r\nif (rate == mc13783_rates[i]) {\r\nsnd_soc_update_bits(codec, MC13783_AUDIO_DAC,\r\n0xf << 17, i << 17);\r\nreturn 0;\r\n}\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int mc13783_pcm_hw_params_codec(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\nstruct snd_soc_codec *codec = rtd->codec;\r\nunsigned int rate = params_rate(params);\r\nunsigned int val;\r\nswitch (rate) {\r\ncase 8000:\r\nval = 0;\r\nbreak;\r\ncase 16000:\r\nval = AUDIO_CODEC_CDCFS8K16K;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nsnd_soc_update_bits(codec, MC13783_AUDIO_CODEC, AUDIO_CODEC_CDCFS8K16K,\r\nval);\r\nreturn 0;\r\n}\r\nstatic int mc13783_pcm_hw_params_sync(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params,\r\nstruct snd_soc_dai *dai)\r\n{\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\r\nreturn mc13783_pcm_hw_params_dac(substream, params, dai);\r\nelse\r\nreturn mc13783_pcm_hw_params_codec(substream, params, dai);\r\n}\r\nstatic int mc13783_set_fmt(struct snd_soc_dai *dai, unsigned int fmt,\r\nunsigned int reg)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nunsigned int val = 0;\r\nunsigned int mask = AUDIO_CFS(3) | AUDIO_BCL_INV | AUDIO_CFS_INV |\r\nAUDIO_CSM | AUDIO_C_CLK_EN | AUDIO_C_RESET;\r\nswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\r\ncase SND_SOC_DAIFMT_I2S:\r\nval |= AUDIO_CFS(2);\r\nbreak;\r\ncase SND_SOC_DAIFMT_DSP_A:\r\nval |= AUDIO_CFS(1);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\r\ncase SND_SOC_DAIFMT_NB_NF:\r\nval |= AUDIO_BCL_INV;\r\nbreak;\r\ncase SND_SOC_DAIFMT_NB_IF:\r\nval |= AUDIO_BCL_INV | AUDIO_CFS_INV;\r\nbreak;\r\ncase SND_SOC_DAIFMT_IB_NF:\r\nbreak;\r\ncase SND_SOC_DAIFMT_IB_IF:\r\nval |= AUDIO_CFS_INV;\r\nbreak;\r\n}\r\nswitch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {\r\ncase SND_SOC_DAIFMT_CBM_CFM:\r\nval |= AUDIO_C_CLK_EN;\r\nbreak;\r\ncase SND_SOC_DAIFMT_CBS_CFS:\r\nval |= AUDIO_CSM;\r\nbreak;\r\ncase SND_SOC_DAIFMT_CBM_CFS:\r\ncase SND_SOC_DAIFMT_CBS_CFM:\r\nreturn -EINVAL;\r\n}\r\nval |= AUDIO_C_RESET;\r\nsnd_soc_update_bits(codec, reg, mask, val);\r\nreturn 0;\r\n}\r\nstatic int mc13783_set_fmt_async(struct snd_soc_dai *dai, unsigned int fmt)\r\n{\r\nif (dai->id == MC13783_ID_STEREO_DAC)\r\nreturn mc13783_set_fmt(dai, fmt, MC13783_AUDIO_DAC);\r\nelse\r\nreturn mc13783_set_fmt(dai, fmt, MC13783_AUDIO_CODEC);\r\n}\r\nstatic int mc13783_set_fmt_sync(struct snd_soc_dai *dai, unsigned int fmt)\r\n{\r\nint ret;\r\nret = mc13783_set_fmt(dai, fmt, MC13783_AUDIO_DAC);\r\nif (ret)\r\nreturn ret;\r\nfmt &= ~SND_SOC_DAIFMT_MASTER_MASK;\r\nfmt |= SND_SOC_DAIFMT_CBS_CFS;\r\nret = mc13783_set_fmt(dai, fmt, MC13783_AUDIO_CODEC);\r\nreturn ret;\r\n}\r\nstatic int mc13783_set_sysclk(struct snd_soc_dai *dai,\r\nint clk_id, unsigned int freq, int dir,\r\nunsigned int reg)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nint clk;\r\nunsigned int val = 0;\r\nunsigned int mask = AUDIO_CLK(0x7) | AUDIO_CLK_SEL;\r\nfor (clk = 0; clk < ARRAY_SIZE(mc13783_sysclk); clk++) {\r\nif (mc13783_sysclk[clk] < 0)\r\ncontinue;\r\nif (mc13783_sysclk[clk] == freq)\r\nbreak;\r\n}\r\nif (clk == ARRAY_SIZE(mc13783_sysclk))\r\nreturn -EINVAL;\r\nif (clk_id == MC13783_CLK_CLIB)\r\nval |= AUDIO_CLK_SEL;\r\nval |= AUDIO_CLK(clk);\r\nsnd_soc_update_bits(codec, reg, mask, val);\r\nreturn 0;\r\n}\r\nstatic int mc13783_set_sysclk_dac(struct snd_soc_dai *dai,\r\nint clk_id, unsigned int freq, int dir)\r\n{\r\nreturn mc13783_set_sysclk(dai, clk_id, freq, dir, MC13783_AUDIO_DAC);\r\n}\r\nstatic int mc13783_set_sysclk_codec(struct snd_soc_dai *dai,\r\nint clk_id, unsigned int freq, int dir)\r\n{\r\nreturn mc13783_set_sysclk(dai, clk_id, freq, dir, MC13783_AUDIO_CODEC);\r\n}\r\nstatic int mc13783_set_sysclk_sync(struct snd_soc_dai *dai,\r\nint clk_id, unsigned int freq, int dir)\r\n{\r\nint ret;\r\nret = mc13783_set_sysclk(dai, clk_id, freq, dir, MC13783_AUDIO_DAC);\r\nif (ret)\r\nreturn ret;\r\nreturn mc13783_set_sysclk(dai, clk_id, freq, dir, MC13783_AUDIO_CODEC);\r\n}\r\nstatic int mc13783_set_tdm_slot_dac(struct snd_soc_dai *dai,\r\nunsigned int tx_mask, unsigned int rx_mask, int slots,\r\nint slot_width)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nunsigned int val = 0;\r\nunsigned int mask = SSI_NETWORK_DAC_SLOT_MASK |\r\nSSI_NETWORK_DAC_RXSLOT_MASK;\r\nswitch (slots) {\r\ncase 2:\r\nval |= SSI_NETWORK_DAC_SLOTS_2;\r\nbreak;\r\ncase 4:\r\nval |= SSI_NETWORK_DAC_SLOTS_4;\r\nbreak;\r\ncase 8:\r\nval |= SSI_NETWORK_DAC_SLOTS_8;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (rx_mask) {\r\ncase 0xfffffffc:\r\nval |= SSI_NETWORK_DAC_RXSLOT_0_1;\r\nbreak;\r\ncase 0xfffffff3:\r\nval |= SSI_NETWORK_DAC_RXSLOT_2_3;\r\nbreak;\r\ncase 0xffffffcf:\r\nval |= SSI_NETWORK_DAC_RXSLOT_4_5;\r\nbreak;\r\ncase 0xffffff3f:\r\nval |= SSI_NETWORK_DAC_RXSLOT_6_7;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n};\r\nsnd_soc_update_bits(codec, MC13783_SSI_NETWORK, mask, val);\r\nreturn 0;\r\n}\r\nstatic int mc13783_set_tdm_slot_codec(struct snd_soc_dai *dai,\r\nunsigned int tx_mask, unsigned int rx_mask, int slots,\r\nint slot_width)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nunsigned int val = 0;\r\nunsigned int mask = 0x3f;\r\nif (slots != 4)\r\nreturn -EINVAL;\r\nif (tx_mask != 0xfffffffc)\r\nreturn -EINVAL;\r\nval |= (0x00 << 2);\r\nval |= (0x01 << 4);\r\nsnd_soc_update_bits(codec, MC13783_SSI_NETWORK, mask, val);\r\nreturn 0;\r\n}\r\nstatic int mc13783_set_tdm_slot_sync(struct snd_soc_dai *dai,\r\nunsigned int tx_mask, unsigned int rx_mask, int slots,\r\nint slot_width)\r\n{\r\nint ret;\r\nret = mc13783_set_tdm_slot_dac(dai, tx_mask, rx_mask, slots,\r\nslot_width);\r\nif (ret)\r\nreturn ret;\r\nret = mc13783_set_tdm_slot_codec(dai, tx_mask, rx_mask, slots,\r\nslot_width);\r\nreturn ret;\r\n}\r\nstatic int mc13783_probe(struct snd_soc_codec *codec)\r\n{\r\nstruct mc13783_priv *priv = snd_soc_codec_get_drvdata(codec);\r\nmc13xxx_lock(priv->mc13xxx);\r\nmc13xxx_reg_write(priv->mc13xxx, MC13783_AUDIO_RX0, 0x25893);\r\nmc13xxx_reg_write(priv->mc13xxx, MC13783_AUDIO_RX1, 0x00d35A);\r\nmc13xxx_reg_write(priv->mc13xxx, MC13783_AUDIO_TX, 0x420000);\r\nmc13xxx_reg_write(priv->mc13xxx, MC13783_SSI_NETWORK, 0x013060);\r\nmc13xxx_reg_write(priv->mc13xxx, MC13783_AUDIO_CODEC, 0x180027);\r\nmc13xxx_reg_write(priv->mc13xxx, MC13783_AUDIO_DAC, 0x0e0004);\r\nif (priv->adc_ssi_port == MC13783_SSI1_PORT)\r\nmc13xxx_reg_rmw(priv->mc13xxx, MC13783_AUDIO_CODEC,\r\nAUDIO_SSI_SEL, 0);\r\nelse\r\nmc13xxx_reg_rmw(priv->mc13xxx, MC13783_AUDIO_CODEC,\r\n0, AUDIO_SSI_SEL);\r\nif (priv->dac_ssi_port == MC13783_SSI1_PORT)\r\nmc13xxx_reg_rmw(priv->mc13xxx, MC13783_AUDIO_DAC,\r\nAUDIO_SSI_SEL, 0);\r\nelse\r\nmc13xxx_reg_rmw(priv->mc13xxx, MC13783_AUDIO_DAC,\r\n0, AUDIO_SSI_SEL);\r\nmc13xxx_unlock(priv->mc13xxx);\r\nreturn 0;\r\n}\r\nstatic int mc13783_remove(struct snd_soc_codec *codec)\r\n{\r\nstruct mc13783_priv *priv = snd_soc_codec_get_drvdata(codec);\r\nmc13xxx_lock(priv->mc13xxx);\r\nmc13xxx_reg_rmw(priv->mc13xxx, MC13783_AUDIO_RX0, 0x3, 0);\r\nmc13xxx_unlock(priv->mc13xxx);\r\nreturn 0;\r\n}\r\nstatic int mc13783_codec_probe(struct platform_device *pdev)\r\n{\r\nstruct mc13xxx *mc13xxx;\r\nstruct mc13783_priv *priv;\r\nstruct mc13xxx_codec_platform_data *pdata = pdev->dev.platform_data;\r\nint ret;\r\nmc13xxx = dev_get_drvdata(pdev->dev.parent);\r\npriv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);\r\nif (priv == NULL)\r\nreturn -ENOMEM;\r\ndev_set_drvdata(&pdev->dev, priv);\r\npriv->mc13xxx = mc13xxx;\r\nif (pdata) {\r\npriv->adc_ssi_port = pdata->adc_ssi_port;\r\npriv->dac_ssi_port = pdata->dac_ssi_port;\r\n} else {\r\npriv->adc_ssi_port = MC13783_SSI1_PORT;\r\npriv->dac_ssi_port = MC13783_SSI2_PORT;\r\n}\r\nif (priv->adc_ssi_port == priv->dac_ssi_port)\r\nret = snd_soc_register_codec(&pdev->dev, &soc_codec_dev_mc13783,\r\nmc13783_dai_sync, ARRAY_SIZE(mc13783_dai_sync));\r\nelse\r\nret = snd_soc_register_codec(&pdev->dev, &soc_codec_dev_mc13783,\r\nmc13783_dai_async, ARRAY_SIZE(mc13783_dai_async));\r\nif (ret)\r\ngoto err_register_codec;\r\nreturn 0;\r\nerr_register_codec:\r\ndev_err(&pdev->dev, "register codec failed with %d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int mc13783_codec_remove(struct platform_device *pdev)\r\n{\r\nsnd_soc_unregister_codec(&pdev->dev);\r\nreturn 0;\r\n}
