static int rc5t583_regulator_enable_time(struct regulator_dev *rdev)\r\n{\r\nstruct rc5t583_regulator *reg = rdev_get_drvdata(rdev);\r\nint vsel = regulator_get_voltage_sel_regmap(rdev);\r\nint curr_uV = regulator_list_voltage_linear(rdev, vsel);\r\nreturn DIV_ROUND_UP(curr_uV, reg->reg_info->enable_uv_per_us);\r\n}\r\nstatic int rc5t583_regulator_probe(struct platform_device *pdev)\r\n{\r\nstruct rc5t583 *rc5t583 = dev_get_drvdata(pdev->dev.parent);\r\nstruct rc5t583_platform_data *pdata = dev_get_platdata(rc5t583->dev);\r\nstruct regulator_init_data *reg_data;\r\nstruct regulator_config config = { };\r\nstruct rc5t583_regulator *reg = NULL;\r\nstruct rc5t583_regulator *regs;\r\nstruct regulator_dev *rdev;\r\nstruct rc5t583_regulator_info *ri;\r\nint ret;\r\nint id;\r\nif (!pdata) {\r\ndev_err(&pdev->dev, "No platform data, exiting...\n");\r\nreturn -ENODEV;\r\n}\r\nregs = devm_kzalloc(&pdev->dev, RC5T583_REGULATOR_MAX *\r\nsizeof(struct rc5t583_regulator), GFP_KERNEL);\r\nif (!regs) {\r\ndev_err(&pdev->dev, "Memory allocation failed exiting..\n");\r\nreturn -ENOMEM;\r\n}\r\nfor (id = 0; id < RC5T583_REGULATOR_MAX; ++id) {\r\nreg_data = pdata->reg_init_data[id];\r\nif (!reg_data)\r\ncontinue;\r\nreg = &regs[id];\r\nri = &rc5t583_reg_info[id];\r\nreg->reg_info = ri;\r\nreg->mfd = rc5t583;\r\nreg->dev = &pdev->dev;\r\nif (ri->deepsleep_id == RC5T583_DS_NONE)\r\ngoto skip_ext_pwr_config;\r\nret = rc5t583_ext_power_req_config(rc5t583->dev,\r\nri->deepsleep_id,\r\npdata->regulator_ext_pwr_control[id],\r\npdata->regulator_deepsleep_slot[id]);\r\nif (ret < 0)\r\ndev_warn(&pdev->dev,\r\n"Failed to configure ext control %d\n", id);\r\nskip_ext_pwr_config:\r\nconfig.dev = &pdev->dev;\r\nconfig.init_data = reg_data;\r\nconfig.driver_data = reg;\r\nconfig.regmap = rc5t583->regmap;\r\nrdev = regulator_register(&ri->desc, &config);\r\nif (IS_ERR(rdev)) {\r\ndev_err(&pdev->dev, "Failed to register regulator %s\n",\r\nri->desc.name);\r\nret = PTR_ERR(rdev);\r\ngoto clean_exit;\r\n}\r\nreg->rdev = rdev;\r\n}\r\nplatform_set_drvdata(pdev, regs);\r\nreturn 0;\r\nclean_exit:\r\nwhile (--id >= 0)\r\nregulator_unregister(regs[id].rdev);\r\nreturn ret;\r\n}\r\nstatic int rc5t583_regulator_remove(struct platform_device *pdev)\r\n{\r\nstruct rc5t583_regulator *regs = platform_get_drvdata(pdev);\r\nint id;\r\nfor (id = 0; id < RC5T583_REGULATOR_MAX; ++id)\r\nregulator_unregister(regs[id].rdev);\r\nreturn 0;\r\n}\r\nstatic int __init rc5t583_regulator_init(void)\r\n{\r\nreturn platform_driver_register(&rc5t583_regulator_driver);\r\n}\r\nstatic void __exit rc5t583_regulator_exit(void)\r\n{\r\nplatform_driver_unregister(&rc5t583_regulator_driver);\r\n}
