static unsigned char indirect_read(struct pd6729_socket *socket,\r\nunsigned short reg)\r\n{\r\nunsigned long port;\r\nunsigned char val;\r\nunsigned long flags;\r\nspin_lock_irqsave(&port_lock, flags);\r\nreg += socket->number * 0x40;\r\nport = socket->io_base;\r\noutb(reg, port);\r\nval = inb(port + 1);\r\nspin_unlock_irqrestore(&port_lock, flags);\r\nreturn val;\r\n}\r\nstatic unsigned short indirect_read16(struct pd6729_socket *socket,\r\nunsigned short reg)\r\n{\r\nunsigned long port;\r\nunsigned short tmp;\r\nunsigned long flags;\r\nspin_lock_irqsave(&port_lock, flags);\r\nreg = reg + socket->number * 0x40;\r\nport = socket->io_base;\r\noutb(reg, port);\r\ntmp = inb(port + 1);\r\nreg++;\r\noutb(reg, port);\r\ntmp = tmp | (inb(port + 1) << 8);\r\nspin_unlock_irqrestore(&port_lock, flags);\r\nreturn tmp;\r\n}\r\nstatic void indirect_write(struct pd6729_socket *socket, unsigned short reg,\r\nunsigned char value)\r\n{\r\nunsigned long port;\r\nunsigned long flags;\r\nspin_lock_irqsave(&port_lock, flags);\r\nreg = reg + socket->number * 0x40;\r\nport = socket->io_base;\r\noutb(reg, port);\r\noutb(value, port + 1);\r\nspin_unlock_irqrestore(&port_lock, flags);\r\n}\r\nstatic void indirect_setbit(struct pd6729_socket *socket, unsigned short reg,\r\nunsigned char mask)\r\n{\r\nunsigned long port;\r\nunsigned char val;\r\nunsigned long flags;\r\nspin_lock_irqsave(&port_lock, flags);\r\nreg = reg + socket->number * 0x40;\r\nport = socket->io_base;\r\noutb(reg, port);\r\nval = inb(port + 1);\r\nval |= mask;\r\noutb(reg, port);\r\noutb(val, port + 1);\r\nspin_unlock_irqrestore(&port_lock, flags);\r\n}\r\nstatic void indirect_resetbit(struct pd6729_socket *socket, unsigned short reg,\r\nunsigned char mask)\r\n{\r\nunsigned long port;\r\nunsigned char val;\r\nunsigned long flags;\r\nspin_lock_irqsave(&port_lock, flags);\r\nreg = reg + socket->number * 0x40;\r\nport = socket->io_base;\r\noutb(reg, port);\r\nval = inb(port + 1);\r\nval &= ~mask;\r\noutb(reg, port);\r\noutb(val, port + 1);\r\nspin_unlock_irqrestore(&port_lock, flags);\r\n}\r\nstatic void indirect_write16(struct pd6729_socket *socket, unsigned short reg,\r\nunsigned short value)\r\n{\r\nunsigned long port;\r\nunsigned char val;\r\nunsigned long flags;\r\nspin_lock_irqsave(&port_lock, flags);\r\nreg = reg + socket->number * 0x40;\r\nport = socket->io_base;\r\noutb(reg, port);\r\nval = value & 255;\r\noutb(val, port + 1);\r\nreg++;\r\noutb(reg, port);\r\nval = value >> 8;\r\noutb(val, port + 1);\r\nspin_unlock_irqrestore(&port_lock, flags);\r\n}\r\nstatic irqreturn_t pd6729_interrupt(int irq, void *dev)\r\n{\r\nstruct pd6729_socket *socket = (struct pd6729_socket *)dev;\r\nint i;\r\nint loopcount = 0;\r\nint handled = 0;\r\nunsigned int events, active = 0;\r\nwhile (1) {\r\nloopcount++;\r\nif (loopcount > 20) {\r\nprintk(KERN_ERR "pd6729: infinite eventloop "\r\n"in interrupt\n");\r\nbreak;\r\n}\r\nactive = 0;\r\nfor (i = 0; i < MAX_SOCKETS; i++) {\r\nunsigned int csc;\r\ncsc = indirect_read(&socket[i], I365_CSC);\r\nif (csc == 0)\r\ncontinue;\r\nhandled = 1;\r\nevents = 0;\r\nif (csc & I365_CSC_DETECT) {\r\nevents |= SS_DETECT;\r\ndev_vdbg(&socket[i].socket.dev,\r\n"Card detected in socket %i!\n", i);\r\n}\r\nif (indirect_read(&socket[i], I365_INTCTL)\r\n& I365_PC_IOCARD) {\r\nevents |= (csc & I365_CSC_STSCHG)\r\n? SS_STSCHG : 0;\r\n} else {\r\nevents |= (csc & I365_CSC_BVD1)\r\n? SS_BATDEAD : 0;\r\nevents |= (csc & I365_CSC_BVD2)\r\n? SS_BATWARN : 0;\r\nevents |= (csc & I365_CSC_READY)\r\n? SS_READY : 0;\r\n}\r\nif (events)\r\npcmcia_parse_events(&socket[i].socket, events);\r\nactive |= events;\r\n}\r\nif (active == 0)\r\nbreak;\r\n}\r\nreturn IRQ_RETVAL(handled);\r\n}\r\nstatic void pd6729_interrupt_wrapper(unsigned long data)\r\n{\r\nstruct pd6729_socket *socket = (struct pd6729_socket *) data;\r\npd6729_interrupt(0, (void *)socket);\r\nmod_timer(&socket->poll_timer, jiffies + HZ);\r\n}\r\nstatic int pd6729_get_status(struct pcmcia_socket *sock, u_int *value)\r\n{\r\nstruct pd6729_socket *socket\r\n= container_of(sock, struct pd6729_socket, socket);\r\nunsigned int status;\r\nunsigned int data;\r\nstruct pd6729_socket *t;\r\nstatus = indirect_read(socket, I365_STATUS);\r\n*value = 0;\r\nif ((status & I365_CS_DETECT) == I365_CS_DETECT)\r\n*value |= SS_DETECT;\r\nif (indirect_read(socket, I365_INTCTL) & I365_PC_IOCARD) {\r\nif (!(status & I365_CS_STSCHG))\r\n*value |= SS_STSCHG;\r\n} else {\r\nif (!(status & I365_CS_BVD1))\r\n*value |= SS_BATDEAD;\r\nif (!(status & I365_CS_BVD2))\r\n*value |= SS_BATWARN;\r\n}\r\nif (status & I365_CS_WRPROT)\r\n*value |= SS_WRPROT;\r\nif (status & I365_CS_READY)\r\n*value |= SS_READY;\r\nif (status & I365_CS_POWERON)\r\n*value |= SS_POWERON;\r\nt = (socket->number) ? socket : socket + 1;\r\nindirect_write(t, PD67_EXT_INDEX, PD67_EXTERN_DATA);\r\ndata = indirect_read16(t, PD67_EXT_DATA);\r\n*value |= (data & PD67_EXD_VS1(socket->number)) ? 0 : SS_3VCARD;\r\nreturn 0;\r\n}\r\nstatic int pd6729_set_socket(struct pcmcia_socket *sock, socket_state_t *state)\r\n{\r\nstruct pd6729_socket *socket\r\n= container_of(sock, struct pd6729_socket, socket);\r\nunsigned char reg, data;\r\nindirect_write(socket, I365_GBLCTL, 0x00);\r\nindirect_write(socket, I365_GENCTL, 0x00);\r\nsocket->card_irq = state->io_irq;\r\nreg = 0;\r\nif (!(state->flags & SS_RESET))\r\nreg |= I365_PC_RESET;\r\nif (state->flags & SS_IOCARD)\r\nreg |= I365_PC_IOCARD;\r\nindirect_write(socket, I365_INTCTL, reg);\r\nreg = I365_PWR_NORESET;\r\nif (state->flags & SS_PWR_AUTO) {\r\ndev_dbg(&sock->dev, "Auto power\n");\r\nreg |= I365_PWR_AUTO;\r\n}\r\nif (state->flags & SS_OUTPUT_ENA) {\r\ndev_dbg(&sock->dev, "Power Enabled\n");\r\nreg |= I365_PWR_OUT;\r\n}\r\nswitch (state->Vcc) {\r\ncase 0:\r\nbreak;\r\ncase 33:\r\ndev_dbg(&sock->dev,\r\n"setting voltage to Vcc to 3.3V on socket %i\n",\r\nsocket->number);\r\nreg |= I365_VCC_5V;\r\nindirect_setbit(socket, PD67_MISC_CTL_1, PD67_MC1_VCC_3V);\r\nbreak;\r\ncase 50:\r\ndev_dbg(&sock->dev,\r\n"setting voltage to Vcc to 5V on socket %i\n",\r\nsocket->number);\r\nreg |= I365_VCC_5V;\r\nindirect_resetbit(socket, PD67_MISC_CTL_1, PD67_MC1_VCC_3V);\r\nbreak;\r\ndefault:\r\ndev_dbg(&sock->dev,\r\n"pd6729_set_socket called with invalid VCC power "\r\n"value: %i\n", state->Vcc);\r\nreturn -EINVAL;\r\n}\r\nswitch (state->Vpp) {\r\ncase 0:\r\ndev_dbg(&sock->dev, "not setting Vpp on socket %i\n",\r\nsocket->number);\r\nbreak;\r\ncase 33:\r\ncase 50:\r\ndev_dbg(&sock->dev, "setting Vpp to Vcc for socket %i\n",\r\nsocket->number);\r\nreg |= I365_VPP1_5V;\r\nbreak;\r\ncase 120:\r\ndev_dbg(&sock->dev, "setting Vpp to 12.0\n");\r\nreg |= I365_VPP1_12V;\r\nbreak;\r\ndefault:\r\ndev_dbg(&sock->dev, "pd6729: pd6729_set_socket called with "\r\n"invalid VPP power value: %i\n", state->Vpp);\r\nreturn -EINVAL;\r\n}\r\nif (reg != indirect_read(socket, I365_POWER))\r\nindirect_write(socket, I365_POWER, reg);\r\nif (irq_mode == 1) {\r\ndata = PD67_EC1_INV_MGMT_IRQ | PD67_EC1_INV_CARD_IRQ;\r\n} else\r\ndata = 0;\r\nindirect_write(socket, PD67_EXT_INDEX, PD67_EXT_CTL_1);\r\nindirect_write(socket, PD67_EXT_DATA, data);\r\nreg = 0x00;\r\nif (state->csc_mask & SS_DETECT)\r\nreg |= I365_CSC_DETECT;\r\nif (state->flags & SS_IOCARD) {\r\nif (state->csc_mask & SS_STSCHG)\r\nreg |= I365_CSC_STSCHG;\r\n} else {\r\nif (state->csc_mask & SS_BATDEAD)\r\nreg |= I365_CSC_BVD1;\r\nif (state->csc_mask & SS_BATWARN)\r\nreg |= I365_CSC_BVD2;\r\nif (state->csc_mask & SS_READY)\r\nreg |= I365_CSC_READY;\r\n}\r\nif (irq_mode == 1)\r\nreg |= 0x30;\r\nindirect_write(socket, I365_CSCINT, reg);\r\nreg = indirect_read(socket, I365_INTCTL);\r\nif (irq_mode == 1)\r\nreg |= 0x03;\r\nelse\r\nreg |= socket->card_irq;\r\nindirect_write(socket, I365_INTCTL, reg);\r\n(void)indirect_read(socket, I365_CSC);\r\nreturn 0;\r\n}\r\nstatic int pd6729_set_io_map(struct pcmcia_socket *sock,\r\nstruct pccard_io_map *io)\r\n{\r\nstruct pd6729_socket *socket\r\n= container_of(sock, struct pd6729_socket, socket);\r\nunsigned char map, ioctl;\r\nmap = io->map;\r\nif (map > 1) {\r\ndev_dbg(&sock->dev, "pd6729_set_io_map with invalid map\n");\r\nreturn -EINVAL;\r\n}\r\nif (indirect_read(socket, I365_ADDRWIN) & I365_ENA_IO(map))\r\nindirect_resetbit(socket, I365_ADDRWIN, I365_ENA_IO(map));\r\nindirect_write16(socket, I365_IO(map)+I365_W_START, io->start);\r\nindirect_write16(socket, I365_IO(map)+I365_W_STOP, io->stop);\r\nioctl = indirect_read(socket, I365_IOCTL) & ~I365_IOCTL_MASK(map);\r\nif (io->flags & MAP_0WS)\r\nioctl |= I365_IOCTL_0WS(map);\r\nif (io->flags & MAP_16BIT)\r\nioctl |= I365_IOCTL_16BIT(map);\r\nif (io->flags & MAP_AUTOSZ)\r\nioctl |= I365_IOCTL_IOCS16(map);\r\nindirect_write(socket, I365_IOCTL, ioctl);\r\nif (io->flags & MAP_ACTIVE)\r\nindirect_setbit(socket, I365_ADDRWIN, I365_ENA_IO(map));\r\nreturn 0;\r\n}\r\nstatic int pd6729_set_mem_map(struct pcmcia_socket *sock,\r\nstruct pccard_mem_map *mem)\r\n{\r\nstruct pd6729_socket *socket\r\n= container_of(sock, struct pd6729_socket, socket);\r\nunsigned short base, i;\r\nunsigned char map;\r\nmap = mem->map;\r\nif (map > 4) {\r\ndev_warn(&sock->dev, "invalid map requested\n");\r\nreturn -EINVAL;\r\n}\r\nif ((mem->res->start > mem->res->end) || (mem->speed > 1000)) {\r\ndev_warn(&sock->dev, "invalid invalid address / speed\n");\r\nreturn -EINVAL;\r\n}\r\nif (indirect_read(socket, I365_ADDRWIN) & I365_ENA_MEM(map))\r\nindirect_resetbit(socket, I365_ADDRWIN, I365_ENA_MEM(map));\r\nbase = I365_MEM(map);\r\ni = (mem->res->start >> 12) & 0x0fff;\r\nif (mem->flags & MAP_16BIT)\r\ni |= I365_MEM_16BIT;\r\nif (mem->flags & MAP_0WS)\r\ni |= I365_MEM_0WS;\r\nindirect_write16(socket, base + I365_W_START, i);\r\ni = (mem->res->end >> 12) & 0x0fff;\r\nswitch (to_cycles(mem->speed)) {\r\ncase 0:\r\nbreak;\r\ncase 1:\r\ni |= I365_MEM_WS0;\r\nbreak;\r\ncase 2:\r\ni |= I365_MEM_WS1;\r\nbreak;\r\ndefault:\r\ni |= I365_MEM_WS1 | I365_MEM_WS0;\r\nbreak;\r\n}\r\nindirect_write16(socket, base + I365_W_STOP, i);\r\nindirect_write(socket, PD67_EXT_INDEX, PD67_MEM_PAGE(map));\r\nindirect_write(socket, PD67_EXT_DATA, mem->res->start >> 24);\r\ni = ((mem->card_start - mem->res->start) >> 12) & 0x3fff;\r\nif (mem->flags & MAP_WRPROT)\r\ni |= I365_MEM_WRPROT;\r\nif (mem->flags & MAP_ATTRIB) {\r\ni |= I365_MEM_REG;\r\n} else {\r\n}\r\nindirect_write16(socket, base + I365_W_OFF, i);\r\nif (mem->flags & MAP_ACTIVE)\r\nindirect_setbit(socket, I365_ADDRWIN, I365_ENA_MEM(map));\r\nreturn 0;\r\n}\r\nstatic int pd6729_init(struct pcmcia_socket *sock)\r\n{\r\nint i;\r\nstruct resource res = { .end = 0x0fff };\r\npccard_io_map io = { 0, 0, 0, 0, 1 };\r\npccard_mem_map mem = { .res = &res, };\r\npd6729_set_socket(sock, &dead_socket);\r\nfor (i = 0; i < 2; i++) {\r\nio.map = i;\r\npd6729_set_io_map(sock, &io);\r\n}\r\nfor (i = 0; i < 5; i++) {\r\nmem.map = i;\r\npd6729_set_mem_map(sock, &mem);\r\n}\r\nreturn 0;\r\n}\r\nstatic irqreturn_t pd6729_test(int irq, void *dev)\r\n{\r\npr_devel("-> hit on irq %d\n", irq);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int pd6729_check_irq(int irq)\r\n{\r\nint ret;\r\nret = request_irq(irq, pd6729_test, IRQF_PROBE_SHARED, "x",\r\npd6729_test);\r\nif (ret)\r\nreturn -1;\r\nfree_irq(irq, pd6729_test);\r\nreturn 0;\r\n}\r\nstatic u_int pd6729_isa_scan(void)\r\n{\r\nu_int mask0, mask = 0;\r\nint i;\r\nif (irq_mode == 1) {\r\nprintk(KERN_INFO "pd6729: PCI card interrupts, "\r\n"PCI status changes\n");\r\nreturn 0;\r\n}\r\nmask0 = PD67_MASK;\r\nfor (i = 0; i < 16; i++)\r\nif ((mask0 & (1 << i)) && (pd6729_check_irq(i) == 0))\r\nmask |= (1 << i);\r\nprintk(KERN_INFO "pd6729: ISA irqs = ");\r\nfor (i = 0; i < 16; i++)\r\nif (mask & (1<<i))\r\nprintk("%s%d", ((mask & ((1<<i)-1)) ? "," : ""), i);\r\nif (mask == 0)\r\nprintk("none!");\r\nelse\r\nprintk(" polling status changes.\n");\r\nreturn mask;\r\n}\r\nstatic int pd6729_pci_probe(struct pci_dev *dev,\r\nconst struct pci_device_id *id)\r\n{\r\nint i, j, ret;\r\nu_int mask;\r\nchar configbyte;\r\nstruct pd6729_socket *socket;\r\nsocket = kzalloc(sizeof(struct pd6729_socket) * MAX_SOCKETS,\r\nGFP_KERNEL);\r\nif (!socket) {\r\ndev_warn(&dev->dev, "failed to kzalloc socket.\n");\r\nreturn -ENOMEM;\r\n}\r\nret = pci_enable_device(dev);\r\nif (ret) {\r\ndev_warn(&dev->dev, "failed to enable pci_device.\n");\r\ngoto err_out_free_mem;\r\n}\r\nif (!pci_resource_start(dev, 0)) {\r\ndev_warn(&dev->dev, "refusing to load the driver as the "\r\n"io_base is NULL.\n");\r\ngoto err_out_disable;\r\n}\r\ndev_info(&dev->dev, "Cirrus PD6729 PCI to PCMCIA Bridge at 0x%llx "\r\n"on irq %d\n",\r\n(unsigned long long)pci_resource_start(dev, 0), dev->irq);\r\npci_read_config_byte(dev, PCI_COMMAND, &configbyte);\r\nif (!(configbyte & PCI_COMMAND_MEMORY)) {\r\ndev_dbg(&dev->dev, "pd6729: Enabling PCI_COMMAND_MEMORY.\n");\r\nconfigbyte |= PCI_COMMAND_MEMORY;\r\npci_write_config_byte(dev, PCI_COMMAND, configbyte);\r\n}\r\nret = pci_request_regions(dev, "pd6729");\r\nif (ret) {\r\ndev_warn(&dev->dev, "pci request region failed.\n");\r\ngoto err_out_disable;\r\n}\r\nif (dev->irq == NO_IRQ)\r\nirq_mode = 0;\r\nmask = pd6729_isa_scan();\r\nif (irq_mode == 0 && mask == 0) {\r\ndev_warn(&dev->dev, "no ISA interrupt is available.\n");\r\ngoto err_out_free_res;\r\n}\r\nfor (i = 0; i < MAX_SOCKETS; i++) {\r\nsocket[i].io_base = pci_resource_start(dev, 0);\r\nsocket[i].socket.features |= SS_CAP_PAGE_REGS | SS_CAP_PCCARD;\r\nsocket[i].socket.map_size = 0x1000;\r\nsocket[i].socket.irq_mask = mask;\r\nsocket[i].socket.pci_irq = dev->irq;\r\nsocket[i].socket.cb_dev = dev;\r\nsocket[i].socket.owner = THIS_MODULE;\r\nsocket[i].number = i;\r\nsocket[i].socket.ops = &pd6729_operations;\r\nsocket[i].socket.resource_ops = &pccard_nonstatic_ops;\r\nsocket[i].socket.dev.parent = &dev->dev;\r\nsocket[i].socket.driver_data = &socket[i];\r\n}\r\npci_set_drvdata(dev, socket);\r\nif (irq_mode == 1) {\r\nret = request_irq(dev->irq, pd6729_interrupt, IRQF_SHARED,\r\n"pd6729", socket);\r\nif (ret) {\r\ndev_err(&dev->dev, "Failed to register irq %d\n",\r\ndev->irq);\r\ngoto err_out_free_res;\r\n}\r\n} else {\r\ninit_timer(&socket->poll_timer);\r\nsocket->poll_timer.function = pd6729_interrupt_wrapper;\r\nsocket->poll_timer.data = (unsigned long)socket;\r\nsocket->poll_timer.expires = jiffies + HZ;\r\nadd_timer(&socket->poll_timer);\r\n}\r\nfor (i = 0; i < MAX_SOCKETS; i++) {\r\nret = pcmcia_register_socket(&socket[i].socket);\r\nif (ret) {\r\ndev_warn(&dev->dev, "pcmcia_register_socket failed.\n");\r\nfor (j = 0; j < i ; j++)\r\npcmcia_unregister_socket(&socket[j].socket);\r\ngoto err_out_free_res2;\r\n}\r\n}\r\nreturn 0;\r\nerr_out_free_res2:\r\nif (irq_mode == 1)\r\nfree_irq(dev->irq, socket);\r\nelse\r\ndel_timer_sync(&socket->poll_timer);\r\nerr_out_free_res:\r\npci_release_regions(dev);\r\nerr_out_disable:\r\npci_disable_device(dev);\r\nerr_out_free_mem:\r\nkfree(socket);\r\nreturn ret;\r\n}\r\nstatic void pd6729_pci_remove(struct pci_dev *dev)\r\n{\r\nint i;\r\nstruct pd6729_socket *socket = pci_get_drvdata(dev);\r\nfor (i = 0; i < MAX_SOCKETS; i++) {\r\nindirect_write(&socket[i], I365_CSCINT, 0);\r\nindirect_write(&socket[i], I365_INTCTL, 0);\r\npcmcia_unregister_socket(&socket[i].socket);\r\n}\r\nif (irq_mode == 1)\r\nfree_irq(dev->irq, socket);\r\nelse\r\ndel_timer_sync(&socket->poll_timer);\r\npci_release_regions(dev);\r\npci_disable_device(dev);\r\nkfree(socket);\r\n}\r\nstatic int pd6729_module_init(void)\r\n{\r\nreturn pci_register_driver(&pd6729_pci_driver);\r\n}\r\nstatic void pd6729_module_exit(void)\r\n{\r\npci_unregister_driver(&pd6729_pci_driver);\r\n}
