static int stmmac_probe_config_dt(struct platform_device *pdev,\r\nstruct plat_stmmacenet_data *plat,\r\nconst char **mac)\r\n{\r\nstruct device_node *np = pdev->dev.of_node;\r\nif (!np)\r\nreturn -ENODEV;\r\n*mac = of_get_mac_address(np);\r\nplat->interface = of_get_phy_mode(np);\r\nplat->mdio_bus_data = devm_kzalloc(&pdev->dev,\r\nsizeof(struct stmmac_mdio_bus_data),\r\nGFP_KERNEL);\r\nif (of_device_is_compatible(np, "st,spear600-gmac") ||\r\nof_device_is_compatible(np, "snps,dwmac-3.70a") ||\r\nof_device_is_compatible(np, "snps,dwmac")) {\r\nplat->has_gmac = 1;\r\nplat->pmt = 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int stmmac_probe_config_dt(struct platform_device *pdev,\r\nstruct plat_stmmacenet_data *plat,\r\nconst char **mac)\r\n{\r\nreturn -ENOSYS;\r\n}\r\nstatic int stmmac_pltfr_probe(struct platform_device *pdev)\r\n{\r\nint ret = 0;\r\nstruct resource *res;\r\nstruct device *dev = &pdev->dev;\r\nvoid __iomem *addr = NULL;\r\nstruct stmmac_priv *priv = NULL;\r\nstruct plat_stmmacenet_data *plat_dat = NULL;\r\nconst char *mac = NULL;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!res)\r\nreturn -ENODEV;\r\naddr = devm_request_and_ioremap(dev, res);\r\nif (!addr) {\r\npr_err("%s: ERROR: memory mapping failed", __func__);\r\nreturn -ENOMEM;\r\n}\r\nif (pdev->dev.of_node) {\r\nplat_dat = devm_kzalloc(&pdev->dev,\r\nsizeof(struct plat_stmmacenet_data),\r\nGFP_KERNEL);\r\nif (!plat_dat) {\r\npr_err("%s: ERROR: no memory", __func__);\r\nreturn -ENOMEM;\r\n}\r\nret = stmmac_probe_config_dt(pdev, plat_dat, &mac);\r\nif (ret) {\r\npr_err("%s: main dt probe failed", __func__);\r\nreturn ret;\r\n}\r\n} else {\r\nplat_dat = pdev->dev.platform_data;\r\n}\r\nif (plat_dat->init) {\r\nret = plat_dat->init(pdev);\r\nif (unlikely(ret))\r\nreturn ret;\r\n}\r\npriv = stmmac_dvr_probe(&(pdev->dev), plat_dat, addr);\r\nif (!priv) {\r\npr_err("%s: main driver probe failed", __func__);\r\nreturn -ENODEV;\r\n}\r\nif (mac)\r\nmemcpy(priv->dev->dev_addr, mac, ETH_ALEN);\r\npriv->dev->irq = platform_get_irq_byname(pdev, "macirq");\r\nif (priv->dev->irq == -ENXIO) {\r\npr_err("%s: ERROR: MAC IRQ configuration "\r\n"information not found\n", __func__);\r\nreturn -ENXIO;\r\n}\r\npriv->wol_irq = platform_get_irq_byname(pdev, "eth_wake_irq");\r\nif (priv->wol_irq == -ENXIO)\r\npriv->wol_irq = priv->dev->irq;\r\npriv->lpi_irq = platform_get_irq_byname(pdev, "eth_lpi");\r\nplatform_set_drvdata(pdev, priv->dev);\r\npr_debug("STMMAC platform driver registration completed");\r\nreturn 0;\r\n}\r\nstatic int stmmac_pltfr_remove(struct platform_device *pdev)\r\n{\r\nstruct net_device *ndev = platform_get_drvdata(pdev);\r\nstruct stmmac_priv *priv = netdev_priv(ndev);\r\nint ret = stmmac_dvr_remove(ndev);\r\nif (priv->plat->exit)\r\npriv->plat->exit(pdev);\r\nplatform_set_drvdata(pdev, NULL);\r\nreturn ret;\r\n}\r\nstatic int stmmac_pltfr_suspend(struct device *dev)\r\n{\r\nstruct net_device *ndev = dev_get_drvdata(dev);\r\nreturn stmmac_suspend(ndev);\r\n}\r\nstatic int stmmac_pltfr_resume(struct device *dev)\r\n{\r\nstruct net_device *ndev = dev_get_drvdata(dev);\r\nreturn stmmac_resume(ndev);\r\n}\r\nint stmmac_pltfr_freeze(struct device *dev)\r\n{\r\nint ret;\r\nstruct plat_stmmacenet_data *plat_dat = dev_get_platdata(dev);\r\nstruct net_device *ndev = dev_get_drvdata(dev);\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nret = stmmac_freeze(ndev);\r\nif (plat_dat->exit)\r\nplat_dat->exit(pdev);\r\nreturn ret;\r\n}\r\nint stmmac_pltfr_restore(struct device *dev)\r\n{\r\nstruct plat_stmmacenet_data *plat_dat = dev_get_platdata(dev);\r\nstruct net_device *ndev = dev_get_drvdata(dev);\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nif (plat_dat->init)\r\nplat_dat->init(pdev);\r\nreturn stmmac_restore(ndev);\r\n}
