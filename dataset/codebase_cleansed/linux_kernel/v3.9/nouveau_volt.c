int\r\nnouveau_voltage_gpio_get(struct drm_device *dev)\r\n{\r\nstruct nouveau_pm_voltage *volt = &nouveau_pm(dev)->voltage;\r\nstruct nouveau_device *device = nouveau_dev(dev);\r\nstruct nouveau_gpio *gpio = nouveau_gpio(device);\r\nu8 vid = 0;\r\nint i;\r\nfor (i = 0; i < nr_vidtag; i++) {\r\nif (!(volt->vid_mask & (1 << i)))\r\ncontinue;\r\nvid |= gpio->get(gpio, 0, vidtag[i], 0xff) << i;\r\n}\r\nreturn nouveau_volt_lvl_lookup(dev, vid);\r\n}\r\nint\r\nnouveau_voltage_gpio_set(struct drm_device *dev, int voltage)\r\n{\r\nstruct nouveau_device *device = nouveau_dev(dev);\r\nstruct nouveau_gpio *gpio = nouveau_gpio(device);\r\nstruct nouveau_pm_voltage *volt = &nouveau_pm(dev)->voltage;\r\nint vid, i;\r\nvid = nouveau_volt_vid_lookup(dev, voltage);\r\nif (vid < 0)\r\nreturn vid;\r\nfor (i = 0; i < nr_vidtag; i++) {\r\nif (!(volt->vid_mask & (1 << i)))\r\ncontinue;\r\ngpio->set(gpio, 0, vidtag[i], 0xff, !!(vid & (1 << i)));\r\n}\r\nreturn 0;\r\n}\r\nint\r\nnouveau_volt_vid_lookup(struct drm_device *dev, int voltage)\r\n{\r\nstruct nouveau_pm_voltage *volt = &nouveau_pm(dev)->voltage;\r\nint i;\r\nfor (i = 0; i < volt->nr_level; i++) {\r\nif (volt->level[i].voltage == voltage)\r\nreturn volt->level[i].vid;\r\n}\r\nreturn -ENOENT;\r\n}\r\nint\r\nnouveau_volt_lvl_lookup(struct drm_device *dev, int vid)\r\n{\r\nstruct nouveau_pm_voltage *volt = &nouveau_pm(dev)->voltage;\r\nint i;\r\nfor (i = 0; i < volt->nr_level; i++) {\r\nif (volt->level[i].vid == vid)\r\nreturn volt->level[i].voltage;\r\n}\r\nreturn -ENOENT;\r\n}\r\nvoid\r\nnouveau_volt_init(struct drm_device *dev)\r\n{\r\nstruct nouveau_drm *drm = nouveau_drm(dev);\r\nstruct nouveau_gpio *gpio = nouveau_gpio(drm->device);\r\nstruct nouveau_pm *pm = nouveau_pm(dev);\r\nstruct nouveau_pm_voltage *voltage = &pm->voltage;\r\nstruct nvbios *bios = &drm->vbios;\r\nstruct dcb_gpio_func func;\r\nstruct bit_entry P;\r\nu8 *volt = NULL, *entry;\r\nint i, headerlen, recordlen, entries, vidmask, vidshift;\r\nif (bios->type == NVBIOS_BIT) {\r\nif (bit_table(dev, 'P', &P))\r\nreturn;\r\nif (P.version == 1)\r\nvolt = ROMPTR(dev, P.data[16]);\r\nelse\r\nif (P.version == 2)\r\nvolt = ROMPTR(dev, P.data[12]);\r\nelse {\r\nNV_WARN(drm, "unknown volt for BIT P %d\n", P.version);\r\n}\r\n} else {\r\nif (bios->data[bios->offset + 6] < 0x27) {\r\nNV_DEBUG(drm, "BMP version too old for voltage\n");\r\nreturn;\r\n}\r\nvolt = ROMPTR(dev, bios->data[bios->offset + 0x98]);\r\n}\r\nif (!volt) {\r\nNV_DEBUG(drm, "voltage table pointer invalid\n");\r\nreturn;\r\n}\r\nswitch (volt[0]) {\r\ncase 0x10:\r\ncase 0x11:\r\ncase 0x12:\r\nheaderlen = 5;\r\nrecordlen = volt[1];\r\nentries = volt[2];\r\nvidshift = 0;\r\nvidmask = volt[4];\r\nbreak;\r\ncase 0x20:\r\nheaderlen = volt[1];\r\nrecordlen = volt[3];\r\nentries = volt[2];\r\nvidshift = 0;\r\nvidmask = volt[5];\r\nbreak;\r\ncase 0x30:\r\nheaderlen = volt[1];\r\nrecordlen = volt[2];\r\nentries = volt[3];\r\nvidmask = volt[4];\r\nvidshift = 2;\r\nbreak;\r\ncase 0x40:\r\nheaderlen = volt[1];\r\nrecordlen = volt[2];\r\nentries = volt[3];\r\nvidmask = volt[11];\r\nvidshift = 0;\r\nbreak;\r\ndefault:\r\nNV_WARN(drm, "voltage table 0x%02x unknown\n", volt[0]);\r\nreturn;\r\n}\r\nvoltage->vid_mask = vidmask;\r\nif (!voltage->vid_mask)\r\nreturn;\r\ni = 0;\r\nwhile (vidmask) {\r\nif (i > nr_vidtag) {\r\nNV_DEBUG(drm, "vid bit %d unknown\n", i);\r\nreturn;\r\n}\r\nif (gpio && gpio->find(gpio, 0, vidtag[i], 0xff, &func)) {\r\nNV_DEBUG(drm, "vid bit %d has no gpio tag\n", i);\r\nreturn;\r\n}\r\nvidmask >>= 1;\r\ni++;\r\n}\r\nvoltage->version = volt[0];\r\nif (voltage->version < 0x40) {\r\nvoltage->nr_level = entries;\r\nvoltage->level =\r\nkcalloc(entries, sizeof(*voltage->level), GFP_KERNEL);\r\nif (!voltage->level)\r\nreturn;\r\nentry = volt + headerlen;\r\nfor (i = 0; i < entries; i++, entry += recordlen) {\r\nvoltage->level[i].voltage = entry[0] * 10000;\r\nvoltage->level[i].vid = entry[1] >> vidshift;\r\n}\r\n} else {\r\nu32 volt_uv = ROM32(volt[4]);\r\ns16 step_uv = ROM16(volt[8]);\r\nu8 vid;\r\nvoltage->nr_level = voltage->vid_mask + 1;\r\nvoltage->level = kcalloc(voltage->nr_level,\r\nsizeof(*voltage->level), GFP_KERNEL);\r\nif (!voltage->level)\r\nreturn;\r\nfor (vid = 0; vid <= voltage->vid_mask; vid++) {\r\nvoltage->level[vid].voltage = volt_uv;\r\nvoltage->level[vid].vid = vid;\r\nvolt_uv += step_uv;\r\n}\r\n}\r\nvoltage->supported = true;\r\n}\r\nvoid\r\nnouveau_volt_fini(struct drm_device *dev)\r\n{\r\nstruct nouveau_pm_voltage *volt = &nouveau_pm(dev)->voltage;\r\nkfree(volt->level);\r\n}
