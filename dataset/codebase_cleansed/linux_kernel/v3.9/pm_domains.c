static int exynos_pd_power(struct generic_pm_domain *domain, bool power_on)\r\n{\r\nstruct exynos_pm_domain *pd;\r\nvoid __iomem *base;\r\nu32 timeout, pwr;\r\nchar *op;\r\npd = container_of(domain, struct exynos_pm_domain, pd);\r\nbase = pd->base;\r\npwr = power_on ? S5P_INT_LOCAL_PWR_EN : 0;\r\n__raw_writel(pwr, base);\r\ntimeout = 10;\r\nwhile ((__raw_readl(base + 0x4) & S5P_INT_LOCAL_PWR_EN) != pwr) {\r\nif (!timeout) {\r\nop = (power_on) ? "enable" : "disable";\r\npr_err("Power domain %s %s failed\n", domain->name, op);\r\nreturn -ETIMEDOUT;\r\n}\r\ntimeout--;\r\ncpu_relax();\r\nusleep_range(80, 100);\r\n}\r\nreturn 0;\r\n}\r\nstatic int exynos_pd_power_on(struct generic_pm_domain *domain)\r\n{\r\nreturn exynos_pd_power(domain, true);\r\n}\r\nstatic int exynos_pd_power_off(struct generic_pm_domain *domain)\r\n{\r\nreturn exynos_pd_power(domain, false);\r\n}\r\nstatic void exynos_add_device_to_domain(struct exynos_pm_domain *pd,\r\nstruct device *dev)\r\n{\r\nint ret;\r\ndev_dbg(dev, "adding to power domain %s\n", pd->pd.name);\r\nwhile (1) {\r\nret = pm_genpd_add_device(&pd->pd, dev);\r\nif (ret != -EAGAIN)\r\nbreak;\r\ncond_resched();\r\n}\r\npm_genpd_dev_need_restore(dev, true);\r\n}\r\nstatic void exynos_remove_device_from_domain(struct device *dev)\r\n{\r\nstruct generic_pm_domain *genpd = dev_to_genpd(dev);\r\nint ret;\r\ndev_dbg(dev, "removing from power domain %s\n", genpd->name);\r\nwhile (1) {\r\nret = pm_genpd_remove_device(genpd, dev);\r\nif (ret != -EAGAIN)\r\nbreak;\r\ncond_resched();\r\n}\r\n}\r\nstatic void exynos_read_domain_from_dt(struct device *dev)\r\n{\r\nstruct platform_device *pd_pdev;\r\nstruct exynos_pm_domain *pd;\r\nstruct device_node *node;\r\nnode = of_parse_phandle(dev->of_node, "samsung,power-domain", 0);\r\nif (!node)\r\nreturn;\r\npd_pdev = of_find_device_by_node(node);\r\nif (!pd_pdev)\r\nreturn;\r\npd = platform_get_drvdata(pd_pdev);\r\nexynos_add_device_to_domain(pd, dev);\r\n}\r\nstatic int exynos_pm_notifier_call(struct notifier_block *nb,\r\nunsigned long event, void *data)\r\n{\r\nstruct device *dev = data;\r\nswitch (event) {\r\ncase BUS_NOTIFY_BIND_DRIVER:\r\nif (dev->of_node)\r\nexynos_read_domain_from_dt(dev);\r\nbreak;\r\ncase BUS_NOTIFY_UNBOUND_DRIVER:\r\nexynos_remove_device_from_domain(dev);\r\nbreak;\r\n}\r\nreturn NOTIFY_DONE;\r\n}\r\nstatic __init int exynos_pm_dt_parse_domains(void)\r\n{\r\nstruct platform_device *pdev;\r\nstruct device_node *np;\r\nfor_each_compatible_node(np, NULL, "samsung,exynos4210-pd") {\r\nstruct exynos_pm_domain *pd;\r\nint on;\r\npdev = of_find_device_by_node(np);\r\npd = kzalloc(sizeof(*pd), GFP_KERNEL);\r\nif (!pd) {\r\npr_err("%s: failed to allocate memory for domain\n",\r\n__func__);\r\nreturn -ENOMEM;\r\n}\r\npd->pd.name = kstrdup(np->name, GFP_KERNEL);\r\npd->name = pd->pd.name;\r\npd->base = of_iomap(np, 0);\r\npd->pd.power_off = exynos_pd_power_off;\r\npd->pd.power_on = exynos_pd_power_on;\r\npd->pd.of_node = np;\r\nplatform_set_drvdata(pdev, pd);\r\non = __raw_readl(pd->base + 0x4) & S5P_INT_LOCAL_PWR_EN;\r\npm_genpd_init(&pd->pd, NULL, !on);\r\n}\r\nbus_register_notifier(&platform_bus_type, &platform_nb);\r\nreturn 0;\r\n}\r\nstatic __init int exynos_pm_dt_parse_domains(void)\r\n{\r\nreturn 0;\r\n}\r\nstatic __init __maybe_unused void exynos_pm_add_dev_to_genpd(struct platform_device *pdev,\r\nstruct exynos_pm_domain *pd)\r\n{\r\nif (pdev->dev.bus) {\r\nif (!pm_genpd_add_device(&pd->pd, &pdev->dev))\r\npm_genpd_dev_need_restore(&pdev->dev, true);\r\nelse\r\npr_info("%s: error in adding %s device to %s power"\r\n"domain\n", __func__, dev_name(&pdev->dev),\r\npd->name);\r\n}\r\n}\r\nstatic __init int exynos4_pm_init_power_domain(void)\r\n{\r\nint idx;\r\nif (of_have_populated_dt())\r\nreturn exynos_pm_dt_parse_domains();\r\nfor (idx = 0; idx < ARRAY_SIZE(exynos4_pm_domains); idx++) {\r\nstruct exynos_pm_domain *pd = exynos4_pm_domains[idx];\r\nint on = __raw_readl(pd->base + 0x4) & S5P_INT_LOCAL_PWR_EN;\r\npm_genpd_init(&pd->pd, NULL, !on);\r\n}\r\n#ifdef CONFIG_S5P_DEV_FIMD0\r\nexynos_pm_add_dev_to_genpd(&s5p_device_fimd0, &exynos4_pd_lcd0);\r\n#endif\r\n#ifdef CONFIG_S5P_DEV_TV\r\nexynos_pm_add_dev_to_genpd(&s5p_device_hdmi, &exynos4_pd_tv);\r\nexynos_pm_add_dev_to_genpd(&s5p_device_mixer, &exynos4_pd_tv);\r\n#endif\r\n#ifdef CONFIG_S5P_DEV_MFC\r\nexynos_pm_add_dev_to_genpd(&s5p_device_mfc, &exynos4_pd_mfc);\r\n#endif\r\n#ifdef CONFIG_S5P_DEV_FIMC0\r\nexynos_pm_add_dev_to_genpd(&s5p_device_fimc0, &exynos4_pd_cam);\r\n#endif\r\n#ifdef CONFIG_S5P_DEV_FIMC1\r\nexynos_pm_add_dev_to_genpd(&s5p_device_fimc1, &exynos4_pd_cam);\r\n#endif\r\n#ifdef CONFIG_S5P_DEV_FIMC2\r\nexynos_pm_add_dev_to_genpd(&s5p_device_fimc2, &exynos4_pd_cam);\r\n#endif\r\n#ifdef CONFIG_S5P_DEV_FIMC3\r\nexynos_pm_add_dev_to_genpd(&s5p_device_fimc3, &exynos4_pd_cam);\r\n#endif\r\n#ifdef CONFIG_S5P_DEV_CSIS0\r\nexynos_pm_add_dev_to_genpd(&s5p_device_mipi_csis0, &exynos4_pd_cam);\r\n#endif\r\n#ifdef CONFIG_S5P_DEV_CSIS1\r\nexynos_pm_add_dev_to_genpd(&s5p_device_mipi_csis1, &exynos4_pd_cam);\r\n#endif\r\n#ifdef CONFIG_S5P_DEV_G2D\r\nexynos_pm_add_dev_to_genpd(&s5p_device_g2d, &exynos4_pd_lcd0);\r\n#endif\r\n#ifdef CONFIG_S5P_DEV_JPEG\r\nexynos_pm_add_dev_to_genpd(&s5p_device_jpeg, &exynos4_pd_cam);\r\n#endif\r\nreturn 0;\r\n}\r\nint __init exynos_pm_late_initcall(void)\r\n{\r\npm_genpd_poweroff_unused();\r\nreturn 0;\r\n}
