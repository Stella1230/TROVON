static int shark_write_reg(struct radio_tea5777 *tea, u64 reg)\r\n{\r\nstruct shark_device *shark = tea->private_data;\r\nint i, res, actual_len;\r\nmemset(shark->transfer_buffer, 0, TB_LEN);\r\nshark->transfer_buffer[0] = 0x81;\r\nfor (i = 0; i < 6; i++)\r\nshark->transfer_buffer[i + 1] = (reg >> (40 - i * 8)) & 0xff;\r\nv4l2_dbg(1, debug, tea->v4l2_dev, "shark2-write: %*ph\n",\r\n7, shark->transfer_buffer);\r\nres = usb_interrupt_msg(shark->usbdev,\r\nusb_sndintpipe(shark->usbdev, SHARK_OUT_EP),\r\nshark->transfer_buffer, TB_LEN,\r\n&actual_len, 1000);\r\nif (res < 0) {\r\nv4l2_err(tea->v4l2_dev, "write error: %d\n", res);\r\nreturn res;\r\n}\r\nreturn 0;\r\n}\r\nstatic int shark_read_reg(struct radio_tea5777 *tea, u32 *reg_ret)\r\n{\r\nstruct shark_device *shark = tea->private_data;\r\nint i, res, actual_len;\r\nu32 reg = 0;\r\nmemset(shark->transfer_buffer, 0, TB_LEN);\r\nshark->transfer_buffer[0] = 0x82;\r\nres = usb_interrupt_msg(shark->usbdev,\r\nusb_sndintpipe(shark->usbdev, SHARK_OUT_EP),\r\nshark->transfer_buffer, TB_LEN,\r\n&actual_len, 1000);\r\nif (res < 0) {\r\nv4l2_err(tea->v4l2_dev, "request-read error: %d\n", res);\r\nreturn res;\r\n}\r\nres = usb_interrupt_msg(shark->usbdev,\r\nusb_rcvintpipe(shark->usbdev, SHARK_IN_EP),\r\nshark->transfer_buffer, TB_LEN,\r\n&actual_len, 1000);\r\nif (res < 0) {\r\nv4l2_err(tea->v4l2_dev, "read error: %d\n", res);\r\nreturn res;\r\n}\r\nfor (i = 0; i < 3; i++)\r\nreg |= shark->transfer_buffer[i] << (16 - i * 8);\r\nv4l2_dbg(1, debug, tea->v4l2_dev, "shark2-read: %*ph\n",\r\n3, shark->transfer_buffer);\r\n*reg_ret = reg;\r\nreturn 0;\r\n}\r\nstatic void shark_led_work(struct work_struct *work)\r\n{\r\nstruct shark_device *shark =\r\ncontainer_of(work, struct shark_device, led_work);\r\nint i, res, brightness, actual_len;\r\nfor (i = 0; i < 2; i++) {\r\nif (!test_and_clear_bit(i, &shark->brightness_new))\r\ncontinue;\r\nbrightness = atomic_read(&shark->brightness[i]);\r\nmemset(shark->transfer_buffer, 0, TB_LEN);\r\nshark->transfer_buffer[0] = 0x83 + i;\r\nshark->transfer_buffer[1] = brightness;\r\nres = usb_interrupt_msg(shark->usbdev,\r\nusb_sndintpipe(shark->usbdev,\r\nSHARK_OUT_EP),\r\nshark->transfer_buffer, TB_LEN,\r\n&actual_len, 1000);\r\nif (res < 0)\r\nv4l2_err(&shark->v4l2_dev, "set LED %s error: %d\n",\r\nshark->led_names[i], res);\r\n}\r\n}\r\nstatic void shark_led_set_blue(struct led_classdev *led_cdev,\r\nenum led_brightness value)\r\n{\r\nstruct shark_device *shark =\r\ncontainer_of(led_cdev, struct shark_device, leds[BLUE_LED]);\r\natomic_set(&shark->brightness[BLUE_LED], value);\r\nset_bit(BLUE_LED, &shark->brightness_new);\r\nschedule_work(&shark->led_work);\r\n}\r\nstatic void shark_led_set_red(struct led_classdev *led_cdev,\r\nenum led_brightness value)\r\n{\r\nstruct shark_device *shark =\r\ncontainer_of(led_cdev, struct shark_device, leds[RED_LED]);\r\natomic_set(&shark->brightness[RED_LED], value);\r\nset_bit(RED_LED, &shark->brightness_new);\r\nschedule_work(&shark->led_work);\r\n}\r\nstatic int shark_register_leds(struct shark_device *shark, struct device *dev)\r\n{\r\nint i, retval;\r\natomic_set(&shark->brightness[BLUE_LED], 127);\r\nINIT_WORK(&shark->led_work, shark_led_work);\r\nfor (i = 0; i < NO_LEDS; i++) {\r\nshark->leds[i] = shark_led_templates[i];\r\nsnprintf(shark->led_names[i], sizeof(shark->led_names[0]),\r\nshark->leds[i].name, shark->v4l2_dev.name);\r\nshark->leds[i].name = shark->led_names[i];\r\nretval = led_classdev_register(dev, &shark->leds[i]);\r\nif (retval) {\r\nv4l2_err(&shark->v4l2_dev,\r\n"couldn't register led: %s\n",\r\nshark->led_names[i]);\r\nreturn retval;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void shark_unregister_leds(struct shark_device *shark)\r\n{\r\nint i;\r\nfor (i = 0; i < NO_LEDS; i++)\r\nled_classdev_unregister(&shark->leds[i]);\r\ncancel_work_sync(&shark->led_work);\r\n}\r\nstatic void shark_resume_leds(struct shark_device *shark)\r\n{\r\nint i;\r\nfor (i = 0; i < NO_LEDS; i++)\r\nset_bit(i, &shark->brightness_new);\r\nschedule_work(&shark->led_work);\r\n}\r\nstatic int shark_register_leds(struct shark_device *shark, struct device *dev)\r\n{\r\nv4l2_warn(&shark->v4l2_dev,\r\n"CONFIG_LED_CLASS not enabled, LED support disabled\n");\r\nreturn 0;\r\n}\r\nstatic inline void shark_unregister_leds(struct shark_device *shark) { }\r\nstatic inline void shark_resume_leds(struct shark_device *shark) { }\r\nstatic void usb_shark_disconnect(struct usb_interface *intf)\r\n{\r\nstruct v4l2_device *v4l2_dev = usb_get_intfdata(intf);\r\nstruct shark_device *shark = v4l2_dev_to_shark(v4l2_dev);\r\nmutex_lock(&shark->tea.mutex);\r\nv4l2_device_disconnect(&shark->v4l2_dev);\r\nradio_tea5777_exit(&shark->tea);\r\nmutex_unlock(&shark->tea.mutex);\r\nshark_unregister_leds(shark);\r\nv4l2_device_put(&shark->v4l2_dev);\r\n}\r\nstatic void usb_shark_release(struct v4l2_device *v4l2_dev)\r\n{\r\nstruct shark_device *shark = v4l2_dev_to_shark(v4l2_dev);\r\nv4l2_device_unregister(&shark->v4l2_dev);\r\nkfree(shark->transfer_buffer);\r\nkfree(shark);\r\n}\r\nstatic int usb_shark_probe(struct usb_interface *intf,\r\nconst struct usb_device_id *id)\r\n{\r\nstruct shark_device *shark;\r\nint retval = -ENOMEM;\r\nshark = kzalloc(sizeof(struct shark_device), GFP_KERNEL);\r\nif (!shark)\r\nreturn retval;\r\nshark->transfer_buffer = kmalloc(TB_LEN, GFP_KERNEL);\r\nif (!shark->transfer_buffer)\r\ngoto err_alloc_buffer;\r\nv4l2_device_set_name(&shark->v4l2_dev, DRV_NAME, &shark_instance);\r\nretval = shark_register_leds(shark, &intf->dev);\r\nif (retval)\r\ngoto err_reg_leds;\r\nshark->v4l2_dev.release = usb_shark_release;\r\nretval = v4l2_device_register(&intf->dev, &shark->v4l2_dev);\r\nif (retval) {\r\nv4l2_err(&shark->v4l2_dev, "couldn't register v4l2_device\n");\r\ngoto err_reg_dev;\r\n}\r\nshark->usbdev = interface_to_usbdev(intf);\r\nshark->tea.v4l2_dev = &shark->v4l2_dev;\r\nshark->tea.private_data = shark;\r\nshark->tea.ops = &shark_tea_ops;\r\nshark->tea.has_am = true;\r\nshark->tea.write_before_read = true;\r\nstrlcpy(shark->tea.card, "Griffin radioSHARK2",\r\nsizeof(shark->tea.card));\r\nusb_make_path(shark->usbdev, shark->tea.bus_info,\r\nsizeof(shark->tea.bus_info));\r\nretval = radio_tea5777_init(&shark->tea, THIS_MODULE);\r\nif (retval) {\r\nv4l2_err(&shark->v4l2_dev, "couldn't init tea5777\n");\r\ngoto err_init_tea;\r\n}\r\nreturn 0;\r\nerr_init_tea:\r\nv4l2_device_unregister(&shark->v4l2_dev);\r\nerr_reg_dev:\r\nshark_unregister_leds(shark);\r\nerr_reg_leds:\r\nkfree(shark->transfer_buffer);\r\nerr_alloc_buffer:\r\nkfree(shark);\r\nreturn retval;\r\n}\r\nstatic int usb_shark_suspend(struct usb_interface *intf, pm_message_t message)\r\n{\r\nreturn 0;\r\n}\r\nstatic int usb_shark_resume(struct usb_interface *intf)\r\n{\r\nstruct v4l2_device *v4l2_dev = usb_get_intfdata(intf);\r\nstruct shark_device *shark = v4l2_dev_to_shark(v4l2_dev);\r\nint ret;\r\nmutex_lock(&shark->tea.mutex);\r\nret = radio_tea5777_set_freq(&shark->tea);\r\nmutex_unlock(&shark->tea.mutex);\r\nshark_resume_leds(shark);\r\nreturn ret;\r\n}
