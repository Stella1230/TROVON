static void strfilter_node__delete(struct strfilter_node *self)\r\n{\r\nif (self) {\r\nif (self->p && !is_operator(*self->p))\r\nfree((char *)self->p);\r\nstrfilter_node__delete(self->l);\r\nstrfilter_node__delete(self->r);\r\nfree(self);\r\n}\r\n}\r\nvoid strfilter__delete(struct strfilter *self)\r\n{\r\nif (self) {\r\nstrfilter_node__delete(self->root);\r\nfree(self);\r\n}\r\n}\r\nstatic const char *get_token(const char *s, const char **e)\r\n{\r\nconst char *p;\r\nwhile (isspace(*s))\r\ns++;\r\nif (*s == '\0') {\r\np = s;\r\ngoto end;\r\n}\r\np = s + 1;\r\nif (!is_separator(*s)) {\r\nretry:\r\nwhile (*p && !is_separator(*p) && !isspace(*p))\r\np++;\r\nif (*(p - 1) == '\\' || (*p == '!' && *(p - 1) == '[')) {\r\np++;\r\ngoto retry;\r\n}\r\n}\r\nend:\r\n*e = p;\r\nreturn s;\r\n}\r\nstatic struct strfilter_node *strfilter_node__alloc(const char *op,\r\nstruct strfilter_node *l,\r\nstruct strfilter_node *r)\r\n{\r\nstruct strfilter_node *ret = zalloc(sizeof(struct strfilter_node));\r\nif (ret) {\r\nret->p = op;\r\nret->l = l;\r\nret->r = r;\r\n}\r\nreturn ret;\r\n}\r\nstatic struct strfilter_node *strfilter_node__new(const char *s,\r\nconst char **ep)\r\n{\r\nstruct strfilter_node root, *cur, *last_op;\r\nconst char *e;\r\nif (!s)\r\nreturn NULL;\r\nmemset(&root, 0, sizeof(root));\r\nlast_op = cur = &root;\r\ns = get_token(s, &e);\r\nwhile (*s != '\0' && *s != ')') {\r\nswitch (*s) {\r\ncase '&':\r\nif (!cur->r || !last_op->r)\r\ngoto error;\r\ncur = strfilter_node__alloc(OP_and, last_op->r, NULL);\r\nif (!cur)\r\ngoto nomem;\r\nlast_op->r = cur;\r\nlast_op = cur;\r\nbreak;\r\ncase '|':\r\nif (!cur->r || !root.r)\r\ngoto error;\r\ncur = strfilter_node__alloc(OP_or, root.r, NULL);\r\nif (!cur)\r\ngoto nomem;\r\nroot.r = cur;\r\nlast_op = cur;\r\nbreak;\r\ncase '!':\r\nif (cur->r)\r\ngoto error;\r\ncur->r = strfilter_node__alloc(OP_not, NULL, NULL);\r\nif (!cur->r)\r\ngoto nomem;\r\ncur = cur->r;\r\nbreak;\r\ncase '(':\r\nif (cur->r)\r\ngoto error;\r\ncur->r = strfilter_node__new(s + 1, &s);\r\nif (!s)\r\ngoto nomem;\r\nif (!cur->r || *s != ')')\r\ngoto error;\r\ne = s + 1;\r\nbreak;\r\ndefault:\r\nif (cur->r)\r\ngoto error;\r\ncur->r = strfilter_node__alloc(NULL, NULL, NULL);\r\nif (!cur->r)\r\ngoto nomem;\r\ncur->r->p = strndup(s, e - s);\r\nif (!cur->r->p)\r\ngoto nomem;\r\n}\r\ns = get_token(e, &e);\r\n}\r\nif (!cur->r)\r\ngoto error;\r\n*ep = s;\r\nreturn root.r;\r\nnomem:\r\ns = NULL;\r\nerror:\r\n*ep = s;\r\nstrfilter_node__delete(root.r);\r\nreturn NULL;\r\n}\r\nstruct strfilter *strfilter__new(const char *rules, const char **err)\r\n{\r\nstruct strfilter *ret = zalloc(sizeof(struct strfilter));\r\nconst char *ep = NULL;\r\nif (ret)\r\nret->root = strfilter_node__new(rules, &ep);\r\nif (!ret || !ret->root || *ep != '\0') {\r\nif (err)\r\n*err = ep;\r\nstrfilter__delete(ret);\r\nret = NULL;\r\n}\r\nreturn ret;\r\n}\r\nstatic bool strfilter_node__compare(struct strfilter_node *self,\r\nconst char *str)\r\n{\r\nif (!self || !self->p)\r\nreturn false;\r\nswitch (*self->p) {\r\ncase '|':\r\nreturn strfilter_node__compare(self->l, str) ||\r\nstrfilter_node__compare(self->r, str);\r\ncase '&':\r\nreturn strfilter_node__compare(self->l, str) &&\r\nstrfilter_node__compare(self->r, str);\r\ncase '!':\r\nreturn !strfilter_node__compare(self->r, str);\r\ndefault:\r\nreturn strglobmatch(str, self->p);\r\n}\r\n}\r\nbool strfilter__compare(struct strfilter *self, const char *str)\r\n{\r\nif (!self)\r\nreturn false;\r\nreturn strfilter_node__compare(self->root, str);\r\n}
