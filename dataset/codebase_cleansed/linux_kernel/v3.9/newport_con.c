static inline void newport_render_background(int xstart, int ystart,\r\nint xend, int yend, int ci)\r\n{\r\nnewport_wait(npregs);\r\nnpregs->set.wrmask = 0xffffffff;\r\nnpregs->set.drawmode0 = (NPORT_DMODE0_DRAW | NPORT_DMODE0_BLOCK |\r\nNPORT_DMODE0_DOSETUP | NPORT_DMODE0_STOPX\r\n| NPORT_DMODE0_STOPY);\r\nnpregs->set.colori = ci;\r\nnpregs->set.xystarti =\r\n(xstart << 16) | ((ystart + topscan) & 0x3ff);\r\nnpregs->go.xyendi =\r\n((xend + 7) << 16) | ((yend + topscan + 15) & 0x3ff);\r\n}\r\nstatic inline void newport_init_cmap(void)\r\n{\r\nunsigned short i;\r\nfor (i = 0; i < 16; i++) {\r\nnewport_bfwait(npregs);\r\nnewport_cmap_setaddr(npregs, color_table[i]);\r\nnewport_cmap_setrgb(npregs,\r\ndefault_red[i],\r\ndefault_grn[i], default_blu[i]);\r\n}\r\n}\r\nstatic const struct linux_logo *newport_show_logo(void)\r\n{\r\n#ifdef CONFIG_LOGO_SGI_CLUT224\r\nconst struct linux_logo *logo = fb_find_logo(8);\r\nconst unsigned char *clut;\r\nconst unsigned char *data;\r\nunsigned long i;\r\nif (!logo)\r\nreturn NULL;\r\nclut = logo->clut;\r\ndata = logo->data;\r\nfor (i = 0; i < logo->clutsize; i++) {\r\nnewport_bfwait(npregs);\r\nnewport_cmap_setaddr(npregs, i + 0x20);\r\nnewport_cmap_setrgb(npregs, clut[0], clut[1], clut[2]);\r\nclut += 3;\r\n}\r\nnewport_wait(npregs);\r\nnpregs->set.drawmode0 = (NPORT_DMODE0_DRAW | NPORT_DMODE0_BLOCK |\r\nNPORT_DMODE0_CHOST);\r\nnpregs->set.xystarti = ((newport_xsize - logo->width) << 16) | (0);\r\nnpregs->set.xyendi = ((newport_xsize - 1) << 16);\r\nnewport_wait(npregs);\r\nfor (i = 0; i < logo->width*logo->height; i++)\r\nnpregs->go.hostrw0 = *data++ << 24;\r\nreturn logo;\r\n#endif\r\n}\r\nstatic inline void newport_clear_screen(int xstart, int ystart, int xend,\r\nint yend, int ci)\r\n{\r\nif (logo_active)\r\nreturn;\r\nnewport_wait(npregs);\r\nnpregs->set.wrmask = 0xffffffff;\r\nnpregs->set.drawmode0 = (NPORT_DMODE0_DRAW | NPORT_DMODE0_BLOCK |\r\nNPORT_DMODE0_DOSETUP | NPORT_DMODE0_STOPX\r\n| NPORT_DMODE0_STOPY);\r\nnpregs->set.colori = ci;\r\nnpregs->set.xystarti = (xstart << 16) | ystart;\r\nnpregs->go.xyendi = (xend << 16) | yend;\r\n}\r\nstatic inline void newport_clear_lines(int ystart, int yend, int ci)\r\n{\r\nystart = ((ystart << 4) + topscan) & 0x3ff;\r\nyend = ((yend << 4) + topscan + 15) & 0x3ff;\r\nnewport_clear_screen(0, ystart, 1280 + 63, yend, ci);\r\n}\r\nstatic void newport_reset(void)\r\n{\r\nunsigned short treg;\r\nint i;\r\nnewport_wait(npregs);\r\ntreg = newport_vc2_get(npregs, VC2_IREG_CONTROL);\r\nnewport_vc2_set(npregs, VC2_IREG_CONTROL,\r\n(treg | VC2_CTRL_EVIDEO));\r\ntreg = newport_vc2_get(npregs, VC2_IREG_CENTRY);\r\nnewport_vc2_set(npregs, VC2_IREG_RADDR, treg);\r\nnpregs->set.dcbmode = (NPORT_DMODE_AVC2 | VC2_REGADDR_RAM |\r\nNPORT_DMODE_W2 | VC2_PROTOCOL);\r\nfor (i = 0; i < 128; i++) {\r\nnewport_bfwait(npregs);\r\nif (i == 92 || i == 94)\r\nnpregs->set.dcbdata0.byshort.s1 = 0xff00;\r\nelse\r\nnpregs->set.dcbdata0.byshort.s1 = 0x0000;\r\n}\r\nnewport_init_cmap();\r\nnpregs->set.dcbmode = (DCB_XMAP0 | R_DCB_XMAP9_PROTOCOL |\r\nXM9_CRS_CONFIG | NPORT_DMODE_W1);\r\nnpregs->set.dcbdata0.bybytes.b3 &= ~XM9_PUPMODE;\r\nnpregs->set.dcbmode = (DCB_XMAP1 | R_DCB_XMAP9_PROTOCOL |\r\nXM9_CRS_CONFIG | NPORT_DMODE_W1);\r\nnpregs->set.dcbdata0.bybytes.b3 &= ~XM9_PUPMODE;\r\ntopscan = 0;\r\nnpregs->cset.topscan = 0x3ff;\r\nnpregs->cset.xywin = (4096 << 16) | 4096;\r\nnewport_clear_screen(0, 0, 1280 + 63, 1024, 0);\r\n}\r\nstatic void newport_get_screensize(void)\r\n{\r\nint i, cols;\r\nunsigned short ventry, treg;\r\nunsigned short linetable[128];\r\nventry = newport_vc2_get(npregs, VC2_IREG_VENTRY);\r\nnewport_vc2_set(npregs, VC2_IREG_RADDR, ventry);\r\nnpregs->set.dcbmode = (NPORT_DMODE_AVC2 | VC2_REGADDR_RAM |\r\nNPORT_DMODE_W2 | VC2_PROTOCOL);\r\nfor (i = 0; i < 128; i++) {\r\nnewport_bfwait(npregs);\r\nlinetable[i] = npregs->set.dcbdata0.byshort.s1;\r\n}\r\nnewport_xsize = newport_ysize = 0;\r\nfor (i = 0; i < ARRAY_SIZE(linetable) - 1 && linetable[i + 1]; i += 2) {\r\ncols = 0;\r\nnewport_vc2_set(npregs, VC2_IREG_RADDR, linetable[i]);\r\nnpregs->set.dcbmode = (NPORT_DMODE_AVC2 | VC2_REGADDR_RAM |\r\nNPORT_DMODE_W2 | VC2_PROTOCOL);\r\ndo {\r\nnewport_bfwait(npregs);\r\ntreg = npregs->set.dcbdata0.byshort.s1;\r\nif ((treg & 1) == 0)\r\ncols += (treg >> 7) & 0xfe;\r\nif ((treg & 0x80) == 0) {\r\nnewport_bfwait(npregs);\r\ntreg = npregs->set.dcbdata0.byshort.s1;\r\n}\r\n} while ((treg & 0x8000) == 0);\r\nif (cols) {\r\nif (cols > newport_xsize)\r\nnewport_xsize = cols;\r\nnewport_ysize += linetable[i + 1];\r\n}\r\n}\r\nprintk("NG1: Screensize %dx%d\n", newport_xsize, newport_ysize);\r\n}\r\nstatic void newport_get_revisions(void)\r\n{\r\nunsigned int tmp;\r\nunsigned int board_rev;\r\nunsigned int rex3_rev;\r\nunsigned int vc2_rev;\r\nunsigned int cmap_rev;\r\nunsigned int xmap9_rev;\r\nunsigned int bt445_rev;\r\nunsigned int bitplanes;\r\nrex3_rev = npregs->cset.status & NPORT_STAT_VERS;\r\nnpregs->set.dcbmode = (DCB_CMAP0 | NCMAP_PROTOCOL |\r\nNCMAP_REGADDR_RREG | NPORT_DMODE_W1);\r\ntmp = npregs->set.dcbdata0.bybytes.b3;\r\ncmap_rev = tmp & 7;\r\nboard_rev = (tmp >> 4) & 7;\r\nbitplanes = ((board_rev > 1) && (tmp & 0x80)) ? 8 : 24;\r\nnpregs->set.dcbmode = (DCB_CMAP1 | NCMAP_PROTOCOL |\r\nNCMAP_REGADDR_RREG | NPORT_DMODE_W1);\r\ntmp = npregs->set.dcbdata0.bybytes.b3;\r\nif ((tmp & 7) < cmap_rev)\r\ncmap_rev = (tmp & 7);\r\nvc2_rev = (newport_vc2_get(npregs, VC2_IREG_CONFIG) >> 5) & 7;\r\nnpregs->set.dcbmode = (DCB_XMAP0 | R_DCB_XMAP9_PROTOCOL |\r\nXM9_CRS_REVISION | NPORT_DMODE_W1);\r\nxmap9_rev = npregs->set.dcbdata0.bybytes.b3 & 7;\r\nnpregs->set.dcbmode = (DCB_BT445 | BT445_PROTOCOL |\r\nBT445_CSR_ADDR_REG | NPORT_DMODE_W1);\r\nnpregs->set.dcbdata0.bybytes.b3 = BT445_REVISION_REG;\r\nnpregs->set.dcbmode = (DCB_BT445 | BT445_PROTOCOL |\r\nBT445_CSR_REVISION | NPORT_DMODE_W1);\r\nbt445_rev = (npregs->set.dcbdata0.bybytes.b3 >> 4) - 0x0a;\r\n#define L(a) (char)('A'+(a))\r\nprintk\r\n("NG1: Revision %d, %d bitplanes, REX3 revision %c, VC2 revision %c, xmap9 revision %c, cmap revision %c, bt445 revision %c\n",\r\nboard_rev, bitplanes, L(rex3_rev), L(vc2_rev), L(xmap9_rev),\r\nL(cmap_rev ? (cmap_rev + 1) : 0), L(bt445_rev));\r\n#undef L\r\nif (board_rev == 3)\r\nxcurs_correction = 21;\r\n}\r\nstatic void newport_exit(void)\r\n{\r\nint i;\r\nfor (i = 0; i < MAX_NR_CONSOLES; i++)\r\nnewport_set_def_font(i, NULL);\r\n}\r\nstatic const char *newport_startup(void)\r\n{\r\nint i;\r\nnpregs->cset.config = NPORT_CFG_GD0;\r\nif (newport_wait(npregs))\r\ngoto out_unmap;\r\nnpregs->set.xstarti = TESTVAL;\r\nif (npregs->set._xstart.word != XSTI_TO_FXSTART(TESTVAL))\r\ngoto out_unmap;\r\nfor (i = 0; i < MAX_NR_CONSOLES; i++)\r\nfont_data[i] = FONT_DATA;\r\nnewport_reset();\r\nnewport_get_revisions();\r\nnewport_get_screensize();\r\nnewport_has_init = 1;\r\nreturn "SGI Newport";\r\nout_unmap:\r\nreturn NULL;\r\n}\r\nstatic void newport_init(struct vc_data *vc, int init)\r\n{\r\nint cols, rows;\r\ncols = newport_xsize / 8;\r\nrows = newport_ysize / 16;\r\nvc->vc_can_do_color = 1;\r\nif (init) {\r\nvc->vc_cols = cols;\r\nvc->vc_rows = rows;\r\n} else\r\nvc_resize(vc, cols, rows);\r\n}\r\nstatic void newport_deinit(struct vc_data *c)\r\n{\r\nif (!con_is_bound(&newport_con) && newport_has_init) {\r\nnewport_exit();\r\nnewport_has_init = 0;\r\n}\r\n}\r\nstatic void newport_clear(struct vc_data *vc, int sy, int sx, int height,\r\nint width)\r\n{\r\nint xend = ((sx + width) << 3) - 1;\r\nint ystart = ((sy << 4) + topscan) & 0x3ff;\r\nint yend = (((sy + height) << 4) + topscan - 1) & 0x3ff;\r\nif (logo_active)\r\nreturn;\r\nif (ystart < yend) {\r\nnewport_clear_screen(sx << 3, ystart, xend, yend,\r\n(vc->vc_color & 0xf0) >> 4);\r\n} else {\r\nnewport_clear_screen(sx << 3, ystart, xend, 1023,\r\n(vc->vc_color & 0xf0) >> 4);\r\nnewport_clear_screen(sx << 3, 0, xend, yend,\r\n(vc->vc_color & 0xf0) >> 4);\r\n}\r\n}\r\nstatic void newport_putc(struct vc_data *vc, int charattr, int ypos,\r\nint xpos)\r\n{\r\nunsigned char *p;\r\np = &font_data[vc->vc_num][(charattr & 0xff) << 4];\r\ncharattr = (charattr >> 8) & 0xff;\r\nxpos <<= 3;\r\nypos <<= 4;\r\nnewport_render_background(xpos, ypos, xpos, ypos,\r\n(charattr & 0xf0) >> 4);\r\nnewport_wait(npregs);\r\nnpregs->set.colori = charattr & 0xf;\r\nnpregs->set.drawmode0 = (NPORT_DMODE0_DRAW | NPORT_DMODE0_BLOCK |\r\nNPORT_DMODE0_STOPX | NPORT_DMODE0_ZPENAB |\r\nNPORT_DMODE0_L32);\r\nnpregs->set.xystarti = (xpos << 16) | ((ypos + topscan) & 0x3ff);\r\nnpregs->set.xyendi = ((xpos + 7) << 16);\r\nnewport_wait(npregs);\r\nRENDER(npregs, p);\r\n}\r\nstatic void newport_putcs(struct vc_data *vc, const unsigned short *s,\r\nint count, int ypos, int xpos)\r\n{\r\nint i;\r\nint charattr;\r\nunsigned char *p;\r\ncharattr = (scr_readw(s) >> 8) & 0xff;\r\nxpos <<= 3;\r\nypos <<= 4;\r\nif (!logo_active)\r\nnewport_render_background(xpos, ypos,\r\nxpos + ((count - 1) << 3), ypos,\r\n(charattr & 0xf0) >> 4);\r\nnewport_wait(npregs);\r\nnpregs->set.colori = charattr & 0xf;\r\nnpregs->set.drawmode0 = (NPORT_DMODE0_DRAW | NPORT_DMODE0_BLOCK |\r\nNPORT_DMODE0_STOPX | NPORT_DMODE0_ZPENAB |\r\nNPORT_DMODE0_L32);\r\nfor (i = 0; i < count; i++, xpos += 8) {\r\np = &font_data[vc->vc_num][(scr_readw(s++) & 0xff) << 4];\r\nnewport_wait(npregs);\r\nnpregs->set.xystarti =\r\n(xpos << 16) | ((ypos + topscan) & 0x3ff);\r\nnpregs->set.xyendi = ((xpos + 7) << 16);\r\nRENDER(npregs, p);\r\n}\r\n}\r\nstatic void newport_cursor(struct vc_data *vc, int mode)\r\n{\r\nunsigned short treg;\r\nint xcurs, ycurs;\r\nswitch (mode) {\r\ncase CM_ERASE:\r\ntreg = newport_vc2_get(npregs, VC2_IREG_CONTROL);\r\nnewport_vc2_set(npregs, VC2_IREG_CONTROL,\r\n(treg & ~(VC2_CTRL_ECDISP)));\r\nbreak;\r\ncase CM_MOVE:\r\ncase CM_DRAW:\r\ntreg = newport_vc2_get(npregs, VC2_IREG_CONTROL);\r\nnewport_vc2_set(npregs, VC2_IREG_CONTROL,\r\n(treg | VC2_CTRL_ECDISP));\r\nxcurs = (vc->vc_pos - vc->vc_visible_origin) / 2;\r\nycurs = ((xcurs / vc->vc_cols) << 4) + 31;\r\nxcurs = ((xcurs % vc->vc_cols) << 3) + xcurs_correction;\r\nnewport_vc2_set(npregs, VC2_IREG_CURSX, xcurs);\r\nnewport_vc2_set(npregs, VC2_IREG_CURSY, ycurs);\r\n}\r\n}\r\nstatic int newport_switch(struct vc_data *vc)\r\n{\r\nstatic int logo_drawn = 0;\r\ntopscan = 0;\r\nnpregs->cset.topscan = 0x3ff;\r\nif (!logo_drawn) {\r\nif (newport_show_logo()) {\r\nlogo_drawn = 1;\r\nlogo_active = 1;\r\n}\r\n}\r\nreturn 1;\r\n}\r\nstatic int newport_blank(struct vc_data *c, int blank, int mode_switch)\r\n{\r\nunsigned short treg;\r\nif (blank == 0) {\r\ntreg = newport_vc2_get(npregs, VC2_IREG_CONTROL);\r\nnewport_vc2_set(npregs, VC2_IREG_CONTROL,\r\n(treg | VC2_CTRL_EDISP));\r\n} else {\r\ntreg = newport_vc2_get(npregs, VC2_IREG_CONTROL);\r\nnewport_vc2_set(npregs, VC2_IREG_CONTROL,\r\n(treg & ~(VC2_CTRL_EDISP)));\r\n}\r\nreturn 1;\r\n}\r\nstatic int newport_set_font(int unit, struct console_font *op)\r\n{\r\nint w = op->width;\r\nint h = op->height;\r\nint size = h * op->charcount;\r\nint i;\r\nunsigned char *new_data, *data = op->data, *p;\r\nif ((w != 8) || (h != 16)\r\n|| (op->charcount != 256 && op->charcount != 512))\r\nreturn -EINVAL;\r\nif (!(new_data = kmalloc(FONT_EXTRA_WORDS * sizeof(int) + size,\r\nGFP_USER))) return -ENOMEM;\r\nnew_data += FONT_EXTRA_WORDS * sizeof(int);\r\nFNTSIZE(new_data) = size;\r\nFNTCHARCNT(new_data) = op->charcount;\r\nREFCOUNT(new_data) = 0;\r\np = new_data;\r\nfor (i = 0; i < op->charcount; i++) {\r\nmemcpy(p, data, h);\r\ndata += 32;\r\np += h;\r\n}\r\nfor (i = 0; i < MAX_NR_CONSOLES; i++) {\r\nif (font_data[i] != FONT_DATA\r\n&& FNTSIZE(font_data[i]) == size\r\n&& !memcmp(font_data[i], new_data, size)) {\r\nkfree(new_data - FONT_EXTRA_WORDS * sizeof(int));\r\nif (i == unit)\r\nreturn 0;\r\nnew_data = font_data[i];\r\nbreak;\r\n}\r\n}\r\nif (font_data[unit] != FONT_DATA) {\r\nif (--REFCOUNT(font_data[unit]) == 0)\r\nkfree(font_data[unit] -\r\nFONT_EXTRA_WORDS * sizeof(int));\r\n}\r\nREFCOUNT(new_data)++;\r\nfont_data[unit] = new_data;\r\nreturn 0;\r\n}\r\nstatic int newport_set_def_font(int unit, struct console_font *op)\r\n{\r\nif (font_data[unit] != FONT_DATA) {\r\nif (--REFCOUNT(font_data[unit]) == 0)\r\nkfree(font_data[unit] -\r\nFONT_EXTRA_WORDS * sizeof(int));\r\nfont_data[unit] = FONT_DATA;\r\n}\r\nreturn 0;\r\n}\r\nstatic int newport_font_default(struct vc_data *vc, struct console_font *op, char *name)\r\n{\r\nreturn newport_set_def_font(vc->vc_num, op);\r\n}\r\nstatic int newport_font_set(struct vc_data *vc, struct console_font *font, unsigned flags)\r\n{\r\nreturn newport_set_font(vc->vc_num, font);\r\n}\r\nstatic int newport_set_palette(struct vc_data *vc, unsigned char *table)\r\n{\r\nreturn -EINVAL;\r\n}\r\nstatic int newport_scrolldelta(struct vc_data *vc, int lines)\r\n{\r\nreturn 0;\r\n}\r\nstatic int newport_scroll(struct vc_data *vc, int t, int b, int dir,\r\nint lines)\r\n{\r\nint count, x, y;\r\nunsigned short *s, *d;\r\nunsigned short chattr;\r\nlogo_active = 0;\r\nif (t == 0 && b == vc->vc_rows) {\r\nif (dir == SM_UP) {\r\ntopscan = (topscan + (lines << 4)) & 0x3ff;\r\nnewport_clear_lines(vc->vc_rows - lines,\r\nvc->vc_rows - 1,\r\n(vc->vc_color & 0xf0) >> 4);\r\n} else {\r\ntopscan = (topscan + (-lines << 4)) & 0x3ff;\r\nnewport_clear_lines(0, lines - 1,\r\n(vc->vc_color & 0xf0) >> 4);\r\n}\r\nnpregs->cset.topscan = (topscan - 1) & 0x3ff;\r\nreturn 0;\r\n}\r\ncount = (b - t - lines) * vc->vc_cols;\r\nif (dir == SM_UP) {\r\nx = 0;\r\ny = t;\r\ns = (unsigned short *) (vc->vc_origin +\r\nvc->vc_size_row * (t + lines));\r\nd = (unsigned short *) (vc->vc_origin +\r\nvc->vc_size_row * t);\r\nwhile (count--) {\r\nchattr = scr_readw(s++);\r\nif (chattr != scr_readw(d)) {\r\nnewport_putc(vc, chattr, y, x);\r\nscr_writew(chattr, d);\r\n}\r\nd++;\r\nif (++x == vc->vc_cols) {\r\nx = 0;\r\ny++;\r\n}\r\n}\r\nd = (unsigned short *) (vc->vc_origin +\r\nvc->vc_size_row * (b - lines));\r\nx = 0;\r\ny = b - lines;\r\nfor (count = 0; count < (lines * vc->vc_cols); count++) {\r\nif (scr_readw(d) != vc->vc_video_erase_char) {\r\nnewport_putc(vc, vc->vc_video_erase_char,\r\ny, x);\r\nscr_writew(vc->vc_video_erase_char, d);\r\n}\r\nd++;\r\nif (++x == vc->vc_cols) {\r\nx = 0;\r\ny++;\r\n}\r\n}\r\n} else {\r\nx = vc->vc_cols - 1;\r\ny = b - 1;\r\ns = (unsigned short *) (vc->vc_origin +\r\nvc->vc_size_row * (b - lines) - 2);\r\nd = (unsigned short *) (vc->vc_origin +\r\nvc->vc_size_row * b - 2);\r\nwhile (count--) {\r\nchattr = scr_readw(s--);\r\nif (chattr != scr_readw(d)) {\r\nnewport_putc(vc, chattr, y, x);\r\nscr_writew(chattr, d);\r\n}\r\nd--;\r\nif (x-- == 0) {\r\nx = vc->vc_cols - 1;\r\ny--;\r\n}\r\n}\r\nd = (unsigned short *) (vc->vc_origin +\r\nvc->vc_size_row * t);\r\nx = 0;\r\ny = t;\r\nfor (count = 0; count < (lines * vc->vc_cols); count++) {\r\nif (scr_readw(d) != vc->vc_video_erase_char) {\r\nnewport_putc(vc, vc->vc_video_erase_char,\r\ny, x);\r\nscr_writew(vc->vc_video_erase_char, d);\r\n}\r\nd++;\r\nif (++x == vc->vc_cols) {\r\nx = 0;\r\ny++;\r\n}\r\n}\r\n}\r\nreturn 1;\r\n}\r\nstatic void newport_bmove(struct vc_data *vc, int sy, int sx, int dy,\r\nint dx, int h, int w)\r\n{\r\nshort xs, ys, xe, ye, xoffs, yoffs, tmp;\r\nxs = sx << 3;\r\nxe = ((sx + w) << 3) - 1;\r\nys = ((sy << 4) + topscan) & 0x3ff;\r\nye = (((sy + h) << 4) - 1 + topscan) & 0x3ff;\r\nxoffs = (dx - sx) << 3;\r\nyoffs = (dy - sy) << 4;\r\nif (xoffs > 0) {\r\ntmp = xe;\r\nxe = xs;\r\nxs = tmp;\r\n}\r\nnewport_wait(npregs);\r\nnpregs->set.drawmode0 = (NPORT_DMODE0_S2S | NPORT_DMODE0_BLOCK |\r\nNPORT_DMODE0_DOSETUP | NPORT_DMODE0_STOPX\r\n| NPORT_DMODE0_STOPY);\r\nnpregs->set.xystarti = (xs << 16) | ys;\r\nnpregs->set.xyendi = (xe << 16) | ye;\r\nnpregs->go.xymove = (xoffs << 16) | yoffs;\r\n}\r\nstatic int newport_dummy(struct vc_data *c)\r\n{\r\nreturn 0;\r\n}\r\nstatic int newport_probe(struct gio_device *dev,\r\nconst struct gio_device_id *id)\r\n{\r\nunsigned long newport_addr;\r\nif (!dev->resource.start)\r\nreturn -EINVAL;\r\nif (npregs)\r\nreturn -EBUSY;\r\nnewport_addr = dev->resource.start + 0xF0000;\r\nif (!request_mem_region(newport_addr, 0x10000, "Newport"))\r\nreturn -ENODEV;\r\nnpregs = (struct newport_regs *)\r\nioremap(newport_addr, sizeof(struct newport_regs));\r\nreturn take_over_console(&newport_con, 0, MAX_NR_CONSOLES - 1, 1);\r\n}\r\nstatic void newport_remove(struct gio_device *dev)\r\n{\r\ngive_up_console(&newport_con);\r\niounmap((void *)npregs);\r\n}\r\nint __init newport_console_init(void)\r\n{\r\nreturn gio_register_driver(&newport_driver);\r\n}\r\nvoid __exit newport_console_exit(void)\r\n{\r\ngio_unregister_driver(&newport_driver);\r\n}
