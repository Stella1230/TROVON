static int sbs_read_word_data(struct i2c_client *client, u8 address)\r\n{\r\nstruct sbs_info *chip = i2c_get_clientdata(client);\r\ns32 ret = 0;\r\nint retries = 1;\r\nif (chip->pdata)\r\nretries = max(chip->pdata->i2c_retry_count + 1, 1);\r\nwhile (retries > 0) {\r\nret = i2c_smbus_read_word_data(client, address);\r\nif (ret >= 0)\r\nbreak;\r\nretries--;\r\n}\r\nif (ret < 0) {\r\ndev_dbg(&client->dev,\r\n"%s: i2c read at address 0x%x failed\n",\r\n__func__, address);\r\nreturn ret;\r\n}\r\nreturn le16_to_cpu(ret);\r\n}\r\nstatic int sbs_write_word_data(struct i2c_client *client, u8 address,\r\nu16 value)\r\n{\r\nstruct sbs_info *chip = i2c_get_clientdata(client);\r\ns32 ret = 0;\r\nint retries = 1;\r\nif (chip->pdata)\r\nretries = max(chip->pdata->i2c_retry_count + 1, 1);\r\nwhile (retries > 0) {\r\nret = i2c_smbus_write_word_data(client, address,\r\nle16_to_cpu(value));\r\nif (ret >= 0)\r\nbreak;\r\nretries--;\r\n}\r\nif (ret < 0) {\r\ndev_dbg(&client->dev,\r\n"%s: i2c write to address 0x%x failed\n",\r\n__func__, address);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int sbs_get_battery_presence_and_health(\r\nstruct i2c_client *client, enum power_supply_property psp,\r\nunion power_supply_propval *val)\r\n{\r\ns32 ret;\r\nstruct sbs_info *chip = i2c_get_clientdata(client);\r\nif (psp == POWER_SUPPLY_PROP_PRESENT &&\r\nchip->gpio_detect) {\r\nret = gpio_get_value(chip->pdata->battery_detect);\r\nif (ret == chip->pdata->battery_detect_present)\r\nval->intval = 1;\r\nelse\r\nval->intval = 0;\r\nchip->is_present = val->intval;\r\nreturn ret;\r\n}\r\nret = sbs_write_word_data(client, sbs_data[REG_MANUFACTURER_DATA].addr,\r\nMANUFACTURER_ACCESS_STATUS);\r\nif (ret < 0) {\r\nif (psp == POWER_SUPPLY_PROP_PRESENT)\r\nval->intval = 0;\r\nreturn ret;\r\n}\r\nret = sbs_read_word_data(client, sbs_data[REG_MANUFACTURER_DATA].addr);\r\nif (ret < 0)\r\nreturn ret;\r\nif (ret < sbs_data[REG_MANUFACTURER_DATA].min_value ||\r\nret > sbs_data[REG_MANUFACTURER_DATA].max_value) {\r\nval->intval = 0;\r\nreturn 0;\r\n}\r\nret &= 0x0F00;\r\nret >>= 8;\r\nif (psp == POWER_SUPPLY_PROP_PRESENT) {\r\nif (ret == 0x0F)\r\nval->intval = 0;\r\nelse\r\nval->intval = 1;\r\n} else if (psp == POWER_SUPPLY_PROP_HEALTH) {\r\nif (ret == 0x09)\r\nval->intval = POWER_SUPPLY_HEALTH_UNSPEC_FAILURE;\r\nelse if (ret == 0x0B)\r\nval->intval = POWER_SUPPLY_HEALTH_OVERHEAT;\r\nelse if (ret == 0x0C)\r\nval->intval = POWER_SUPPLY_HEALTH_DEAD;\r\nelse\r\nval->intval = POWER_SUPPLY_HEALTH_GOOD;\r\n}\r\nreturn 0;\r\n}\r\nstatic int sbs_get_battery_property(struct i2c_client *client,\r\nint reg_offset, enum power_supply_property psp,\r\nunion power_supply_propval *val)\r\n{\r\nstruct sbs_info *chip = i2c_get_clientdata(client);\r\ns32 ret;\r\nret = sbs_read_word_data(client, sbs_data[reg_offset].addr);\r\nif (ret < 0)\r\nreturn ret;\r\nif (sbs_data[reg_offset].min_value < 0)\r\nret = (s16)ret;\r\nif (ret >= sbs_data[reg_offset].min_value &&\r\nret <= sbs_data[reg_offset].max_value) {\r\nval->intval = ret;\r\nif (psp != POWER_SUPPLY_PROP_STATUS)\r\nreturn 0;\r\nif (ret & BATTERY_FULL_CHARGED)\r\nval->intval = POWER_SUPPLY_STATUS_FULL;\r\nelse if (ret & BATTERY_FULL_DISCHARGED)\r\nval->intval = POWER_SUPPLY_STATUS_NOT_CHARGING;\r\nelse if (ret & BATTERY_DISCHARGING)\r\nval->intval = POWER_SUPPLY_STATUS_DISCHARGING;\r\nelse\r\nval->intval = POWER_SUPPLY_STATUS_CHARGING;\r\nif (chip->poll_time == 0)\r\nchip->last_state = val->intval;\r\nelse if (chip->last_state != val->intval) {\r\ncancel_delayed_work_sync(&chip->work);\r\npower_supply_changed(&chip->power_supply);\r\nchip->poll_time = 0;\r\n}\r\n} else {\r\nif (psp == POWER_SUPPLY_PROP_STATUS)\r\nval->intval = POWER_SUPPLY_STATUS_UNKNOWN;\r\nelse\r\nval->intval = 0;\r\n}\r\nreturn 0;\r\n}\r\nstatic void sbs_unit_adjustment(struct i2c_client *client,\r\nenum power_supply_property psp, union power_supply_propval *val)\r\n{\r\n#define BASE_UNIT_CONVERSION 1000\r\n#define BATTERY_MODE_CAP_MULT_WATT (10 * BASE_UNIT_CONVERSION)\r\n#define TIME_UNIT_CONVERSION 60\r\n#define TEMP_KELVIN_TO_CELSIUS 2731\r\nswitch (psp) {\r\ncase POWER_SUPPLY_PROP_ENERGY_NOW:\r\ncase POWER_SUPPLY_PROP_ENERGY_FULL:\r\ncase POWER_SUPPLY_PROP_ENERGY_FULL_DESIGN:\r\nval->intval *= BATTERY_MODE_CAP_MULT_WATT;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_VOLTAGE_NOW:\r\ncase POWER_SUPPLY_PROP_VOLTAGE_MAX_DESIGN:\r\ncase POWER_SUPPLY_PROP_CURRENT_NOW:\r\ncase POWER_SUPPLY_PROP_CHARGE_NOW:\r\ncase POWER_SUPPLY_PROP_CHARGE_FULL:\r\ncase POWER_SUPPLY_PROP_CHARGE_FULL_DESIGN:\r\nval->intval *= BASE_UNIT_CONVERSION;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_TEMP:\r\nval->intval -= TEMP_KELVIN_TO_CELSIUS;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_TIME_TO_EMPTY_AVG:\r\ncase POWER_SUPPLY_PROP_TIME_TO_FULL_AVG:\r\nval->intval *= TIME_UNIT_CONVERSION;\r\nbreak;\r\ndefault:\r\ndev_dbg(&client->dev,\r\n"%s: no need for unit conversion %d\n", __func__, psp);\r\n}\r\n}\r\nstatic enum sbs_battery_mode sbs_set_battery_mode(struct i2c_client *client,\r\nenum sbs_battery_mode mode)\r\n{\r\nint ret, original_val;\r\noriginal_val = sbs_read_word_data(client, BATTERY_MODE_OFFSET);\r\nif (original_val < 0)\r\nreturn original_val;\r\nif ((original_val & BATTERY_MODE_MASK) == mode)\r\nreturn mode;\r\nif (mode == BATTERY_MODE_AMPS)\r\nret = original_val & ~BATTERY_MODE_MASK;\r\nelse\r\nret = original_val | BATTERY_MODE_MASK;\r\nret = sbs_write_word_data(client, BATTERY_MODE_OFFSET, ret);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn original_val & BATTERY_MODE_MASK;\r\n}\r\nstatic int sbs_get_battery_capacity(struct i2c_client *client,\r\nint reg_offset, enum power_supply_property psp,\r\nunion power_supply_propval *val)\r\n{\r\ns32 ret;\r\nenum sbs_battery_mode mode = BATTERY_MODE_WATTS;\r\nif (power_supply_is_amp_property(psp))\r\nmode = BATTERY_MODE_AMPS;\r\nmode = sbs_set_battery_mode(client, mode);\r\nif (mode < 0)\r\nreturn mode;\r\nret = sbs_read_word_data(client, sbs_data[reg_offset].addr);\r\nif (ret < 0)\r\nreturn ret;\r\nif (psp == POWER_SUPPLY_PROP_CAPACITY) {\r\nval->intval = min(ret, 100);\r\n} else\r\nval->intval = ret;\r\nret = sbs_set_battery_mode(client, mode);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nstatic int sbs_get_battery_serial_number(struct i2c_client *client,\r\nunion power_supply_propval *val)\r\n{\r\nint ret;\r\nret = sbs_read_word_data(client, sbs_data[REG_SERIAL_NUMBER].addr);\r\nif (ret < 0)\r\nreturn ret;\r\nret = sprintf(sbs_serial, "%04x", ret);\r\nval->strval = sbs_serial;\r\nreturn 0;\r\n}\r\nstatic int sbs_get_property_index(struct i2c_client *client,\r\nenum power_supply_property psp)\r\n{\r\nint count;\r\nfor (count = 0; count < ARRAY_SIZE(sbs_data); count++)\r\nif (psp == sbs_data[count].psp)\r\nreturn count;\r\ndev_warn(&client->dev,\r\n"%s: Invalid Property - %d\n", __func__, psp);\r\nreturn -EINVAL;\r\n}\r\nstatic int sbs_get_property(struct power_supply *psy,\r\nenum power_supply_property psp,\r\nunion power_supply_propval *val)\r\n{\r\nint ret = 0;\r\nstruct sbs_info *chip = container_of(psy,\r\nstruct sbs_info, power_supply);\r\nstruct i2c_client *client = chip->client;\r\nswitch (psp) {\r\ncase POWER_SUPPLY_PROP_PRESENT:\r\ncase POWER_SUPPLY_PROP_HEALTH:\r\nret = sbs_get_battery_presence_and_health(client, psp, val);\r\nif (psp == POWER_SUPPLY_PROP_PRESENT)\r\nreturn 0;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_TECHNOLOGY:\r\nval->intval = POWER_SUPPLY_TECHNOLOGY_LION;\r\ngoto done;\r\ncase POWER_SUPPLY_PROP_ENERGY_NOW:\r\ncase POWER_SUPPLY_PROP_ENERGY_FULL:\r\ncase POWER_SUPPLY_PROP_ENERGY_FULL_DESIGN:\r\ncase POWER_SUPPLY_PROP_CHARGE_NOW:\r\ncase POWER_SUPPLY_PROP_CHARGE_FULL:\r\ncase POWER_SUPPLY_PROP_CHARGE_FULL_DESIGN:\r\ncase POWER_SUPPLY_PROP_CAPACITY:\r\nret = sbs_get_property_index(client, psp);\r\nif (ret < 0)\r\nbreak;\r\nret = sbs_get_battery_capacity(client, ret, psp, val);\r\nbreak;\r\ncase POWER_SUPPLY_PROP_SERIAL_NUMBER:\r\nret = sbs_get_battery_serial_number(client, val);\r\nbreak;\r\ncase POWER_SUPPLY_PROP_STATUS:\r\ncase POWER_SUPPLY_PROP_CYCLE_COUNT:\r\ncase POWER_SUPPLY_PROP_VOLTAGE_NOW:\r\ncase POWER_SUPPLY_PROP_CURRENT_NOW:\r\ncase POWER_SUPPLY_PROP_TEMP:\r\ncase POWER_SUPPLY_PROP_TIME_TO_EMPTY_AVG:\r\ncase POWER_SUPPLY_PROP_TIME_TO_FULL_AVG:\r\ncase POWER_SUPPLY_PROP_VOLTAGE_MAX_DESIGN:\r\nret = sbs_get_property_index(client, psp);\r\nif (ret < 0)\r\nbreak;\r\nret = sbs_get_battery_property(client, ret, psp, val);\r\nbreak;\r\ndefault:\r\ndev_err(&client->dev,\r\n"%s: INVALID property\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nif (!chip->enable_detection)\r\ngoto done;\r\nif (!chip->gpio_detect &&\r\nchip->is_present != (ret >= 0)) {\r\nchip->is_present = (ret >= 0);\r\npower_supply_changed(&chip->power_supply);\r\n}\r\ndone:\r\nif (!ret) {\r\nsbs_unit_adjustment(client, psp, val);\r\n}\r\ndev_dbg(&client->dev,\r\n"%s: property = %d, value = %x\n", __func__, psp, val->intval);\r\nif (ret && chip->is_present)\r\nreturn ret;\r\nif (ret)\r\nreturn -ENODATA;\r\nreturn 0;\r\n}\r\nstatic irqreturn_t sbs_irq(int irq, void *devid)\r\n{\r\nstruct power_supply *battery = devid;\r\npower_supply_changed(battery);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void sbs_external_power_changed(struct power_supply *psy)\r\n{\r\nstruct sbs_info *chip;\r\nchip = container_of(psy, struct sbs_info, power_supply);\r\nif (chip->ignore_changes > 0) {\r\nchip->ignore_changes--;\r\nreturn;\r\n}\r\ncancel_delayed_work_sync(&chip->work);\r\nschedule_delayed_work(&chip->work, HZ);\r\nchip->poll_time = chip->pdata->poll_retry_count;\r\n}\r\nstatic void sbs_delayed_work(struct work_struct *work)\r\n{\r\nstruct sbs_info *chip;\r\ns32 ret;\r\nchip = container_of(work, struct sbs_info, work.work);\r\nret = sbs_read_word_data(chip->client, sbs_data[REG_STATUS].addr);\r\nif (ret < 0) {\r\nchip->poll_time = 0;\r\nreturn;\r\n}\r\nif (ret & BATTERY_FULL_CHARGED)\r\nret = POWER_SUPPLY_STATUS_FULL;\r\nelse if (ret & BATTERY_FULL_DISCHARGED)\r\nret = POWER_SUPPLY_STATUS_NOT_CHARGING;\r\nelse if (ret & BATTERY_DISCHARGING)\r\nret = POWER_SUPPLY_STATUS_DISCHARGING;\r\nelse\r\nret = POWER_SUPPLY_STATUS_CHARGING;\r\nif (chip->last_state != ret) {\r\nchip->poll_time = 0;\r\npower_supply_changed(&chip->power_supply);\r\nreturn;\r\n}\r\nif (chip->poll_time > 0) {\r\nschedule_delayed_work(&chip->work, HZ);\r\nchip->poll_time--;\r\nreturn;\r\n}\r\n}\r\nstatic struct sbs_platform_data *sbs_of_populate_pdata(\r\nstruct i2c_client *client)\r\n{\r\nstruct device_node *of_node = client->dev.of_node;\r\nstruct sbs_platform_data *pdata = client->dev.platform_data;\r\nenum of_gpio_flags gpio_flags;\r\nint rc;\r\nu32 prop;\r\nif (!of_node)\r\nreturn NULL;\r\nif (pdata)\r\nreturn pdata;\r\nif (!of_get_property(of_node, "sbs,i2c-retry-count", NULL) &&\r\n!of_get_property(of_node, "sbs,poll-retry-count", NULL) &&\r\n!of_get_property(of_node, "sbs,battery-detect-gpios", NULL))\r\ngoto of_out;\r\npdata = devm_kzalloc(&client->dev, sizeof(struct sbs_platform_data),\r\nGFP_KERNEL);\r\nif (!pdata)\r\ngoto of_out;\r\nrc = of_property_read_u32(of_node, "sbs,i2c-retry-count", &prop);\r\nif (!rc)\r\npdata->i2c_retry_count = prop;\r\nrc = of_property_read_u32(of_node, "sbs,poll-retry-count", &prop);\r\nif (!rc)\r\npdata->poll_retry_count = prop;\r\nif (!of_get_property(of_node, "sbs,battery-detect-gpios", NULL)) {\r\npdata->battery_detect = -1;\r\ngoto of_out;\r\n}\r\npdata->battery_detect = of_get_named_gpio_flags(of_node,\r\n"sbs,battery-detect-gpios", 0, &gpio_flags);\r\nif (gpio_flags & OF_GPIO_ACTIVE_LOW)\r\npdata->battery_detect_present = 0;\r\nelse\r\npdata->battery_detect_present = 1;\r\nof_out:\r\nreturn pdata;\r\n}\r\nstatic struct sbs_platform_data *sbs_of_populate_pdata(\r\nstruct i2c_client *client)\r\n{\r\nreturn client->dev.platform_data;\r\n}\r\nstatic int sbs_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct sbs_info *chip;\r\nstruct sbs_platform_data *pdata = client->dev.platform_data;\r\nint rc;\r\nint irq;\r\nchar *name;\r\nname = kasprintf(GFP_KERNEL, "sbs-%s", dev_name(&client->dev));\r\nif (!name) {\r\ndev_err(&client->dev, "Failed to allocate device name\n");\r\nreturn -ENOMEM;\r\n}\r\nchip = kzalloc(sizeof(struct sbs_info), GFP_KERNEL);\r\nif (!chip) {\r\nrc = -ENOMEM;\r\ngoto exit_free_name;\r\n}\r\nchip->client = client;\r\nchip->enable_detection = false;\r\nchip->gpio_detect = false;\r\nchip->power_supply.name = name;\r\nchip->power_supply.type = POWER_SUPPLY_TYPE_BATTERY;\r\nchip->power_supply.properties = sbs_properties;\r\nchip->power_supply.num_properties = ARRAY_SIZE(sbs_properties);\r\nchip->power_supply.get_property = sbs_get_property;\r\nchip->ignore_changes = 1;\r\nchip->last_state = POWER_SUPPLY_STATUS_UNKNOWN;\r\nchip->power_supply.external_power_changed = sbs_external_power_changed;\r\npdata = sbs_of_populate_pdata(client);\r\nif (pdata) {\r\nchip->gpio_detect = gpio_is_valid(pdata->battery_detect);\r\nchip->pdata = pdata;\r\n}\r\ni2c_set_clientdata(client, chip);\r\nif (!chip->gpio_detect)\r\ngoto skip_gpio;\r\nrc = gpio_request(pdata->battery_detect, dev_name(&client->dev));\r\nif (rc) {\r\ndev_warn(&client->dev, "Failed to request gpio: %d\n", rc);\r\nchip->gpio_detect = false;\r\ngoto skip_gpio;\r\n}\r\nrc = gpio_direction_input(pdata->battery_detect);\r\nif (rc) {\r\ndev_warn(&client->dev, "Failed to get gpio as input: %d\n", rc);\r\ngpio_free(pdata->battery_detect);\r\nchip->gpio_detect = false;\r\ngoto skip_gpio;\r\n}\r\nirq = gpio_to_irq(pdata->battery_detect);\r\nif (irq <= 0) {\r\ndev_warn(&client->dev, "Failed to get gpio as irq: %d\n", irq);\r\ngpio_free(pdata->battery_detect);\r\nchip->gpio_detect = false;\r\ngoto skip_gpio;\r\n}\r\nrc = request_irq(irq, sbs_irq,\r\nIRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING,\r\ndev_name(&client->dev), &chip->power_supply);\r\nif (rc) {\r\ndev_warn(&client->dev, "Failed to request irq: %d\n", rc);\r\ngpio_free(pdata->battery_detect);\r\nchip->gpio_detect = false;\r\ngoto skip_gpio;\r\n}\r\nchip->irq = irq;\r\nskip_gpio:\r\nrc = sbs_read_word_data(client, sbs_data[REG_STATUS].addr);\r\nif (rc < 0) {\r\ndev_err(&client->dev, "%s: Failed to get device status\n",\r\n__func__);\r\ngoto exit_psupply;\r\n}\r\nrc = power_supply_register(&client->dev, &chip->power_supply);\r\nif (rc) {\r\ndev_err(&client->dev,\r\n"%s: Failed to register power supply\n", __func__);\r\ngoto exit_psupply;\r\n}\r\ndev_info(&client->dev,\r\n"%s: battery gas gauge device registered\n", client->name);\r\nINIT_DELAYED_WORK(&chip->work, sbs_delayed_work);\r\nchip->enable_detection = true;\r\nreturn 0;\r\nexit_psupply:\r\nif (chip->irq)\r\nfree_irq(chip->irq, &chip->power_supply);\r\nif (chip->gpio_detect)\r\ngpio_free(pdata->battery_detect);\r\nkfree(chip);\r\nexit_free_name:\r\nkfree(name);\r\nreturn rc;\r\n}\r\nstatic int sbs_remove(struct i2c_client *client)\r\n{\r\nstruct sbs_info *chip = i2c_get_clientdata(client);\r\nif (chip->irq)\r\nfree_irq(chip->irq, &chip->power_supply);\r\nif (chip->gpio_detect)\r\ngpio_free(chip->pdata->battery_detect);\r\npower_supply_unregister(&chip->power_supply);\r\ncancel_delayed_work_sync(&chip->work);\r\nkfree(chip->power_supply.name);\r\nkfree(chip);\r\nchip = NULL;\r\nreturn 0;\r\n}\r\nstatic int sbs_suspend(struct i2c_client *client,\r\npm_message_t state)\r\n{\r\nstruct sbs_info *chip = i2c_get_clientdata(client);\r\ns32 ret;\r\nif (chip->poll_time > 0)\r\ncancel_delayed_work_sync(&chip->work);\r\nret = sbs_write_word_data(client, sbs_data[REG_MANUFACTURER_DATA].addr,\r\nMANUFACTURER_ACCESS_SLEEP);\r\nif (chip->is_present && ret < 0)\r\nreturn ret;\r\nreturn 0;\r\n}
