static void find_memory_chunks(struct mem_chunk chunk[])\r\n{\r\nunsigned long long memsize, rnmax, rzm;\r\nunsigned long addr = 0, size;\r\nint i = 0, type;\r\nrzm = sclp_get_rzm();\r\nrnmax = sclp_get_rnmax();\r\nmemsize = rzm * rnmax;\r\nif (!rzm)\r\nrzm = 1ULL << 17;\r\nif (sizeof(long) == 4) {\r\nrzm = min(ADDR2G, rzm);\r\nmemsize = memsize ? min(ADDR2G, memsize) : ADDR2G;\r\n}\r\ndo {\r\nsize = 0;\r\ntype = tprot(addr);\r\ndo {\r\nsize += rzm;\r\nif (memsize && addr + size >= memsize)\r\nbreak;\r\n} while (type == tprot(addr + size));\r\nif (type == CHUNK_READ_WRITE || type == CHUNK_READ_ONLY) {\r\nchunk[i].addr = addr;\r\nchunk[i].size = size;\r\nchunk[i].type = type;\r\ni++;\r\n}\r\naddr += size;\r\n} while (addr < memsize && i < MEMORY_CHUNKS);\r\n}\r\nvoid detect_memory_layout(struct mem_chunk chunk[])\r\n{\r\nunsigned long flags, cr0;\r\nmemset(chunk, 0, MEMORY_CHUNKS * sizeof(struct mem_chunk));\r\nflags = __arch_local_irq_stnsm(0xf8);\r\n__ctl_store(cr0, 0, 0);\r\n__ctl_clear_bit(0, 28);\r\nfind_memory_chunks(chunk);\r\n__ctl_load(cr0, 0, 0);\r\narch_local_irq_restore(flags);\r\n}\r\nstatic void mem_chunk_move(struct mem_chunk chunk[], int to, int from)\r\n{\r\nint cnt = MEMORY_CHUNKS - to;\r\nmemmove(&chunk[to], &chunk[from], cnt * sizeof(struct mem_chunk));\r\n}\r\nstatic void mem_chunk_init(struct mem_chunk *chunk, unsigned long addr,\r\nunsigned long size, int type)\r\n{\r\nchunk->type = type;\r\nchunk->addr = addr;\r\nchunk->size = size;\r\n}\r\nvoid create_mem_hole(struct mem_chunk chunk[], unsigned long addr,\r\nunsigned long size, int type)\r\n{\r\nunsigned long lh_start, lh_end, lh_size, ch_start, ch_end, ch_size;\r\nint i, ch_type;\r\nfor (i = 0; i < MEMORY_CHUNKS; i++) {\r\nif (chunk[i].size == 0)\r\ncontinue;\r\nch_start = chunk[i].addr;\r\nch_size = chunk[i].size;\r\nch_end = ch_start + ch_size - 1;\r\nch_type = chunk[i].type;\r\nif (addr + size <= ch_start)\r\ncontinue;\r\nif (addr > ch_end)\r\ncontinue;\r\nlh_start = max(addr, chunk[i].addr);\r\nlh_end = min(addr + size - 1, ch_end);\r\nlh_size = lh_end - lh_start + 1;\r\nif (lh_start == ch_start && lh_end == ch_end) {\r\nmem_chunk_init(&chunk[i], lh_start, lh_size, type);\r\n} else if (lh_end == ch_end) {\r\nmem_chunk_move(chunk, i + 1, i);\r\nmem_chunk_init(&chunk[i], ch_start, ch_size - lh_size,\r\nch_type);\r\nmem_chunk_init(&chunk[i + 1], lh_start, lh_size, type);\r\ni += 1;\r\n} else if (lh_start == ch_start) {\r\nmem_chunk_move(chunk, i + 1, i);\r\nmem_chunk_init(&chunk[i], lh_start, lh_size, type);\r\nmem_chunk_init(&chunk[i + 1], lh_end + 1,\r\nch_size - lh_size, ch_type);\r\nbreak;\r\n} else {\r\nmem_chunk_move(chunk, i + 2, i);\r\nmem_chunk_init(&chunk[i], ch_start,\r\nlh_start - ch_start, ch_type);\r\nmem_chunk_init(&chunk[i + 1], lh_start, lh_size, type);\r\nmem_chunk_init(&chunk[i + 2], lh_end + 1,\r\nch_end - lh_end, ch_type);\r\nbreak;\r\n}\r\n}\r\n}
