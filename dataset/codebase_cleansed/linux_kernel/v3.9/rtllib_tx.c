inline int rtllib_put_snap(u8 *data, u16 h_proto)\r\n{\r\nstruct rtllib_snap_hdr *snap;\r\nu8 *oui;\r\nsnap = (struct rtllib_snap_hdr *)data;\r\nsnap->dsap = 0xaa;\r\nsnap->ssap = 0xaa;\r\nsnap->ctrl = 0x03;\r\nif (h_proto == 0x8137 || h_proto == 0x80f3)\r\noui = P802_1H_OUI;\r\nelse\r\noui = RFC1042_OUI;\r\nsnap->oui[0] = oui[0];\r\nsnap->oui[1] = oui[1];\r\nsnap->oui[2] = oui[2];\r\n*(u16 *)(data + SNAP_SIZE) = htons(h_proto);\r\nreturn SNAP_SIZE + sizeof(u16);\r\n}\r\nint rtllib_encrypt_fragment(struct rtllib_device *ieee, struct sk_buff *frag,\r\nint hdr_len)\r\n{\r\nstruct lib80211_crypt_data *crypt = NULL;\r\nint res;\r\ncrypt = ieee->crypt_info.crypt[ieee->crypt_info.tx_keyidx];\r\nif (!(crypt && crypt->ops)) {\r\nprintk(KERN_INFO "=========>%s(), crypt is null\n", __func__);\r\nreturn -1;\r\n}\r\natomic_inc(&crypt->refcnt);\r\nres = 0;\r\nif (crypt->ops->encrypt_msdu)\r\nres = crypt->ops->encrypt_msdu(frag, hdr_len, crypt->priv);\r\nif (res == 0 && crypt->ops->encrypt_mpdu)\r\nres = crypt->ops->encrypt_mpdu(frag, hdr_len, crypt->priv);\r\natomic_dec(&crypt->refcnt);\r\nif (res < 0) {\r\nprintk(KERN_INFO "%s: Encryption failed: len=%d.\n",\r\nieee->dev->name, frag->len);\r\nieee->ieee_stats.tx_discards++;\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nvoid rtllib_txb_free(struct rtllib_txb *txb)\r\n{\r\nif (unlikely(!txb))\r\nreturn;\r\nkfree(txb);\r\n}\r\nstatic struct rtllib_txb *rtllib_alloc_txb(int nr_frags, int txb_size,\r\ngfp_t gfp_mask)\r\n{\r\nstruct rtllib_txb *txb;\r\nint i;\r\ntxb = kmalloc(sizeof(struct rtllib_txb) + (sizeof(u8 *) * nr_frags),\r\ngfp_mask);\r\nif (!txb)\r\nreturn NULL;\r\nmemset(txb, 0, sizeof(struct rtllib_txb));\r\ntxb->nr_frags = nr_frags;\r\ntxb->frag_size = txb_size;\r\nfor (i = 0; i < nr_frags; i++) {\r\ntxb->fragments[i] = dev_alloc_skb(txb_size);\r\nif (unlikely(!txb->fragments[i])) {\r\ni--;\r\nbreak;\r\n}\r\nmemset(txb->fragments[i]->cb, 0, sizeof(txb->fragments[i]->cb));\r\n}\r\nif (unlikely(i != nr_frags)) {\r\nwhile (i >= 0)\r\ndev_kfree_skb_any(txb->fragments[i--]);\r\nkfree(txb);\r\nreturn NULL;\r\n}\r\nreturn txb;\r\n}\r\nstatic int rtllib_classify(struct sk_buff *skb, u8 bIsAmsdu)\r\n{\r\nstruct ethhdr *eth;\r\nstruct iphdr *ip;\r\neth = (struct ethhdr *)skb->data;\r\nif (eth->h_proto != htons(ETH_P_IP))\r\nreturn 0;\r\nRTLLIB_DEBUG_DATA(RTLLIB_DL_DATA, skb->data, skb->len);\r\nip = ip_hdr(skb);\r\nswitch (ip->tos & 0xfc) {\r\ncase 0x20:\r\nreturn 2;\r\ncase 0x40:\r\nreturn 1;\r\ncase 0x60:\r\nreturn 3;\r\ncase 0x80:\r\nreturn 4;\r\ncase 0xa0:\r\nreturn 5;\r\ncase 0xc0:\r\nreturn 6;\r\ncase 0xe0:\r\nreturn 7;\r\ndefault:\r\nreturn 0;\r\n}\r\n}\r\nstatic void rtllib_tx_query_agg_cap(struct rtllib_device *ieee,\r\nstruct sk_buff *skb,\r\nstruct cb_desc *tcb_desc)\r\n{\r\nstruct rt_hi_throughput *pHTInfo = ieee->pHTInfo;\r\nstruct tx_ts_record *pTxTs = NULL;\r\nstruct rtllib_hdr_1addr *hdr = (struct rtllib_hdr_1addr *)skb->data;\r\nif (rtllib_act_scanning(ieee, false))\r\nreturn;\r\nif (!pHTInfo->bCurrentHTSupport || !pHTInfo->bEnableHT)\r\nreturn;\r\nif (!IsQoSDataFrame(skb->data))\r\nreturn;\r\nif (is_multicast_ether_addr(hdr->addr1))\r\nreturn;\r\nif (tcb_desc->bdhcp || ieee->CntAfterLink < 2)\r\nreturn;\r\nif (pHTInfo->IOTAction & HT_IOT_ACT_TX_NO_AGGREGATION)\r\nreturn;\r\nif (!ieee->GetNmodeSupportBySecCfg(ieee->dev))\r\nreturn;\r\nif (pHTInfo->bCurrentAMPDUEnable) {\r\nif (!GetTs(ieee, (struct ts_common_info **)(&pTxTs), hdr->addr1,\r\nskb->priority, TX_DIR, true)) {\r\nprintk(KERN_INFO "%s: can't get TS\n", __func__);\r\nreturn;\r\n}\r\nif (pTxTs->TxAdmittedBARecord.bValid == false) {\r\nif (ieee->wpa_ie_len && (ieee->pairwise_key_type ==\r\nKEY_TYPE_NA)) {\r\n;\r\n} else if (tcb_desc->bdhcp == 1) {\r\n;\r\n} else if (!pTxTs->bDisable_AddBa) {\r\nTsStartAddBaProcess(ieee, pTxTs);\r\n}\r\ngoto FORCED_AGG_SETTING;\r\n} else if (pTxTs->bUsingBa == false) {\r\nif (SN_LESS(pTxTs->TxAdmittedBARecord.BaStartSeqCtrl.field.SeqNum,\r\n(pTxTs->TxCurSeq+1)%4096))\r\npTxTs->bUsingBa = true;\r\nelse\r\ngoto FORCED_AGG_SETTING;\r\n}\r\nif (ieee->iw_mode == IW_MODE_INFRA) {\r\ntcb_desc->bAMPDUEnable = true;\r\ntcb_desc->ampdu_factor = pHTInfo->CurrentAMPDUFactor;\r\ntcb_desc->ampdu_density = pHTInfo->CurrentMPDUDensity;\r\n}\r\n}\r\nFORCED_AGG_SETTING:\r\nswitch (pHTInfo->ForcedAMPDUMode) {\r\ncase HT_AGG_AUTO:\r\nbreak;\r\ncase HT_AGG_FORCE_ENABLE:\r\ntcb_desc->bAMPDUEnable = true;\r\ntcb_desc->ampdu_density = pHTInfo->ForcedMPDUDensity;\r\ntcb_desc->ampdu_factor = pHTInfo->ForcedAMPDUFactor;\r\nbreak;\r\ncase HT_AGG_FORCE_DISABLE:\r\ntcb_desc->bAMPDUEnable = false;\r\ntcb_desc->ampdu_density = 0;\r\ntcb_desc->ampdu_factor = 0;\r\nbreak;\r\n}\r\nreturn;\r\n}\r\nstatic void rtllib_qurey_ShortPreambleMode(struct rtllib_device *ieee,\r\nstruct cb_desc *tcb_desc)\r\n{\r\ntcb_desc->bUseShortPreamble = false;\r\nif (tcb_desc->data_rate == 2)\r\nreturn;\r\nelse if (ieee->current_network.capability &\r\nWLAN_CAPABILITY_SHORT_PREAMBLE)\r\ntcb_desc->bUseShortPreamble = true;\r\nreturn;\r\n}\r\nstatic void rtllib_query_HTCapShortGI(struct rtllib_device *ieee,\r\nstruct cb_desc *tcb_desc)\r\n{\r\nstruct rt_hi_throughput *pHTInfo = ieee->pHTInfo;\r\ntcb_desc->bUseShortGI = false;\r\nif (!pHTInfo->bCurrentHTSupport || !pHTInfo->bEnableHT)\r\nreturn;\r\nif (pHTInfo->bForcedShortGI) {\r\ntcb_desc->bUseShortGI = true;\r\nreturn;\r\n}\r\nif ((pHTInfo->bCurBW40MHz == true) && pHTInfo->bCurShortGI40MHz)\r\ntcb_desc->bUseShortGI = true;\r\nelse if ((pHTInfo->bCurBW40MHz == false) && pHTInfo->bCurShortGI20MHz)\r\ntcb_desc->bUseShortGI = true;\r\n}\r\nstatic void rtllib_query_BandwidthMode(struct rtllib_device *ieee,\r\nstruct cb_desc *tcb_desc)\r\n{\r\nstruct rt_hi_throughput *pHTInfo = ieee->pHTInfo;\r\ntcb_desc->bPacketBW = false;\r\nif (!pHTInfo->bCurrentHTSupport || !pHTInfo->bEnableHT)\r\nreturn;\r\nif (tcb_desc->bMulticast || tcb_desc->bBroadcast)\r\nreturn;\r\nif ((tcb_desc->data_rate & 0x80) == 0)\r\nreturn;\r\nif (pHTInfo->bCurBW40MHz && pHTInfo->bCurTxBW40MHz &&\r\n!ieee->bandwidth_auto_switch.bforced_tx20Mhz)\r\ntcb_desc->bPacketBW = true;\r\nreturn;\r\n}\r\nstatic void rtllib_query_protectionmode(struct rtllib_device *ieee,\r\nstruct cb_desc *tcb_desc,\r\nstruct sk_buff *skb)\r\n{\r\ntcb_desc->bRTSSTBC = false;\r\ntcb_desc->bRTSUseShortGI = false;\r\ntcb_desc->bCTSEnable = false;\r\ntcb_desc->RTSSC = 0;\r\ntcb_desc->bRTSBW = false;\r\nif (tcb_desc->bBroadcast || tcb_desc->bMulticast)\r\nreturn;\r\nif (is_broadcast_ether_addr(skb->data+16))\r\nreturn;\r\nif (ieee->mode < IEEE_N_24G) {\r\nif (skb->len > ieee->rts) {\r\ntcb_desc->bRTSEnable = true;\r\ntcb_desc->rts_rate = MGN_24M;\r\n} else if (ieee->current_network.buseprotection) {\r\ntcb_desc->bRTSEnable = true;\r\ntcb_desc->bCTSEnable = true;\r\ntcb_desc->rts_rate = MGN_24M;\r\n}\r\nreturn;\r\n} else {\r\nstruct rt_hi_throughput *pHTInfo = ieee->pHTInfo;\r\nwhile (true) {\r\nif (pHTInfo->IOTAction & HT_IOT_ACT_FORCED_CTS2SELF) {\r\ntcb_desc->bCTSEnable = true;\r\ntcb_desc->rts_rate = MGN_24M;\r\ntcb_desc->bRTSEnable = true;\r\nbreak;\r\n} else if (pHTInfo->IOTAction & (HT_IOT_ACT_FORCED_RTS |\r\nHT_IOT_ACT_PURE_N_MODE)) {\r\ntcb_desc->bRTSEnable = true;\r\ntcb_desc->rts_rate = MGN_24M;\r\nbreak;\r\n}\r\nif (ieee->current_network.buseprotection) {\r\ntcb_desc->bRTSEnable = true;\r\ntcb_desc->bCTSEnable = true;\r\ntcb_desc->rts_rate = MGN_24M;\r\nbreak;\r\n}\r\nif (pHTInfo->bCurrentHTSupport && pHTInfo->bEnableHT) {\r\nu8 HTOpMode = pHTInfo->CurrentOpMode;\r\nif ((pHTInfo->bCurBW40MHz && (HTOpMode == 2 ||\r\nHTOpMode == 3)) ||\r\n(!pHTInfo->bCurBW40MHz && HTOpMode == 3)) {\r\ntcb_desc->rts_rate = MGN_24M;\r\ntcb_desc->bRTSEnable = true;\r\nbreak;\r\n}\r\n}\r\nif (skb->len > ieee->rts) {\r\ntcb_desc->rts_rate = MGN_24M;\r\ntcb_desc->bRTSEnable = true;\r\nbreak;\r\n}\r\nif (tcb_desc->bAMPDUEnable) {\r\ntcb_desc->rts_rate = MGN_24M;\r\ntcb_desc->bRTSEnable = false;\r\nbreak;\r\n}\r\ngoto NO_PROTECTION;\r\n}\r\n}\r\nif (ieee->current_network.capability & WLAN_CAPABILITY_SHORT_PREAMBLE)\r\ntcb_desc->bUseShortPreamble = true;\r\nif (ieee->iw_mode == IW_MODE_MASTER)\r\ngoto NO_PROTECTION;\r\nreturn;\r\nNO_PROTECTION:\r\ntcb_desc->bRTSEnable = false;\r\ntcb_desc->bCTSEnable = false;\r\ntcb_desc->rts_rate = 0;\r\ntcb_desc->RTSSC = 0;\r\ntcb_desc->bRTSBW = false;\r\n}\r\nstatic void rtllib_txrate_selectmode(struct rtllib_device *ieee,\r\nstruct cb_desc *tcb_desc)\r\n{\r\nif (ieee->bTxDisableRateFallBack)\r\ntcb_desc->bTxDisableRateFallBack = true;\r\nif (ieee->bTxUseDriverAssingedRate)\r\ntcb_desc->bTxUseDriverAssingedRate = true;\r\nif (!tcb_desc->bTxDisableRateFallBack ||\r\n!tcb_desc->bTxUseDriverAssingedRate) {\r\nif (ieee->iw_mode == IW_MODE_INFRA ||\r\nieee->iw_mode == IW_MODE_ADHOC)\r\ntcb_desc->RATRIndex = 0;\r\n}\r\n}\r\nu16 rtllib_query_seqnum(struct rtllib_device *ieee, struct sk_buff *skb,\r\nu8 *dst)\r\n{\r\nu16 seqnum = 0;\r\nif (is_multicast_ether_addr(dst))\r\nreturn 0;\r\nif (IsQoSDataFrame(skb->data)) {\r\nstruct tx_ts_record *pTS = NULL;\r\nif (!GetTs(ieee, (struct ts_common_info **)(&pTS), dst,\r\nskb->priority, TX_DIR, true))\r\nreturn 0;\r\nseqnum = pTS->TxCurSeq;\r\npTS->TxCurSeq = (pTS->TxCurSeq+1)%4096;\r\nreturn seqnum;\r\n}\r\nreturn 0;\r\n}\r\nstatic int wme_downgrade_ac(struct sk_buff *skb)\r\n{\r\nswitch (skb->priority) {\r\ncase 6:\r\ncase 7:\r\nskb->priority = 5;\r\nreturn 0;\r\ncase 4:\r\ncase 5:\r\nskb->priority = 3;\r\nreturn 0;\r\ncase 0:\r\ncase 3:\r\nskb->priority = 1;\r\nreturn 0;\r\ndefault:\r\nreturn -1;\r\n}\r\n}\r\nint rtllib_xmit_inter(struct sk_buff *skb, struct net_device *dev)\r\n{\r\nstruct rtllib_device *ieee = (struct rtllib_device *)\r\nnetdev_priv_rsl(dev);\r\nstruct rtllib_txb *txb = NULL;\r\nstruct rtllib_hdr_3addrqos *frag_hdr;\r\nint i, bytes_per_frag, nr_frags, bytes_last_frag, frag_size;\r\nunsigned long flags;\r\nstruct net_device_stats *stats = &ieee->stats;\r\nint ether_type = 0, encrypt;\r\nint bytes, fc, qos_ctl = 0, hdr_len;\r\nstruct sk_buff *skb_frag;\r\nstruct rtllib_hdr_3addrqos header = {\r\n.duration_id = 0,\r\n.seq_ctl = 0,\r\n.qos_ctl = 0\r\n};\r\nu8 dest[ETH_ALEN], src[ETH_ALEN];\r\nint qos_actived = ieee->current_network.qos_data.active;\r\nstruct lib80211_crypt_data *crypt = NULL;\r\nstruct cb_desc *tcb_desc;\r\nu8 bIsMulticast = false;\r\nu8 IsAmsdu = false;\r\nbool bdhcp = false;\r\nspin_lock_irqsave(&ieee->lock, flags);\r\nif ((!ieee->hard_start_xmit && !(ieee->softmac_features &\r\nIEEE_SOFTMAC_TX_QUEUE)) ||\r\n((!ieee->softmac_data_hard_start_xmit &&\r\n(ieee->softmac_features & IEEE_SOFTMAC_TX_QUEUE)))) {\r\nprintk(KERN_WARNING "%s: No xmit handler.\n",\r\nieee->dev->name);\r\ngoto success;\r\n}\r\nif (likely(ieee->raw_tx == 0)) {\r\nif (unlikely(skb->len < SNAP_SIZE + sizeof(u16))) {\r\nprintk(KERN_WARNING "%s: skb too small (%d).\n",\r\nieee->dev->name, skb->len);\r\ngoto success;\r\n}\r\nmemcpy(dest, skb->data, ETH_ALEN);\r\nmemcpy(src, skb->data+ETH_ALEN, ETH_ALEN);\r\nmemset(skb->cb, 0, sizeof(skb->cb));\r\nether_type = ntohs(((struct ethhdr *)skb->data)->h_proto);\r\nif (ieee->iw_mode == IW_MODE_MONITOR) {\r\ntxb = rtllib_alloc_txb(1, skb->len, GFP_ATOMIC);\r\nif (unlikely(!txb)) {\r\nprintk(KERN_WARNING "%s: Could not allocate "\r\n"TXB\n",\r\nieee->dev->name);\r\ngoto failed;\r\n}\r\ntxb->encrypted = 0;\r\ntxb->payload_size = skb->len;\r\nmemcpy(skb_put(txb->fragments[0], skb->len), skb->data,\r\nskb->len);\r\ngoto success;\r\n}\r\nif (skb->len > 282) {\r\nif (ETH_P_IP == ether_type) {\r\nconst struct iphdr *ip = (struct iphdr *)\r\n((u8 *)skb->data+14);\r\nif (IPPROTO_UDP == ip->protocol) {\r\nstruct udphdr *udp;\r\nudp = (struct udphdr *)((u8 *)ip +\r\n(ip->ihl << 2));\r\nif (((((u8 *)udp)[1] == 68) &&\r\n(((u8 *)udp)[3] == 67)) ||\r\n((((u8 *)udp)[1] == 67) &&\r\n(((u8 *)udp)[3] == 68))) {\r\nbdhcp = true;\r\nieee->LPSDelayCnt = 200;\r\n}\r\n}\r\n} else if (ETH_P_ARP == ether_type) {\r\nprintk(KERN_INFO "=================>DHCP "\r\n"Protocol start tx ARP pkt!!\n");\r\nbdhcp = true;\r\nieee->LPSDelayCnt =\r\nieee->current_network.tim.tim_count;\r\n}\r\n}\r\nskb->priority = rtllib_classify(skb, IsAmsdu);\r\ncrypt = ieee->crypt_info.crypt[ieee->crypt_info.tx_keyidx];\r\nencrypt = !(ether_type == ETH_P_PAE && ieee->ieee802_1x) &&\r\nieee->host_encrypt && crypt && crypt->ops;\r\nif (!encrypt && ieee->ieee802_1x &&\r\nieee->drop_unencrypted && ether_type != ETH_P_PAE) {\r\nstats->tx_dropped++;\r\ngoto success;\r\n}\r\nif (crypt && !encrypt && ether_type == ETH_P_PAE) {\r\nstruct eapol *eap = (struct eapol *)(skb->data +\r\nsizeof(struct ethhdr) - SNAP_SIZE -\r\nsizeof(u16));\r\nRTLLIB_DEBUG_EAP("TX: IEEE 802.11 EAPOL frame: %s\n",\r\neap_get_type(eap->type));\r\n}\r\nskb_pull(skb, sizeof(struct ethhdr));\r\nbytes = skb->len + SNAP_SIZE + sizeof(u16);\r\nif (encrypt)\r\nfc = RTLLIB_FTYPE_DATA | RTLLIB_FCTL_WEP;\r\nelse\r\nfc = RTLLIB_FTYPE_DATA;\r\nif (qos_actived)\r\nfc |= RTLLIB_STYPE_QOS_DATA;\r\nelse\r\nfc |= RTLLIB_STYPE_DATA;\r\nif (ieee->iw_mode == IW_MODE_INFRA) {\r\nfc |= RTLLIB_FCTL_TODS;\r\nmemcpy(&header.addr1, ieee->current_network.bssid,\r\nETH_ALEN);\r\nmemcpy(&header.addr2, &src, ETH_ALEN);\r\nif (IsAmsdu)\r\nmemcpy(&header.addr3,\r\nieee->current_network.bssid, ETH_ALEN);\r\nelse\r\nmemcpy(&header.addr3, &dest, ETH_ALEN);\r\n} else if (ieee->iw_mode == IW_MODE_ADHOC) {\r\nmemcpy(&header.addr1, dest, ETH_ALEN);\r\nmemcpy(&header.addr2, src, ETH_ALEN);\r\nmemcpy(&header.addr3, ieee->current_network.bssid,\r\nETH_ALEN);\r\n}\r\nbIsMulticast = is_multicast_ether_addr(header.addr1);\r\nheader.frame_ctl = cpu_to_le16(fc);\r\nif (bIsMulticast) {\r\nfrag_size = MAX_FRAG_THRESHOLD;\r\nqos_ctl |= QOS_CTL_NOTCONTAIN_ACK;\r\n} else {\r\nfrag_size = ieee->fts;\r\nqos_ctl = 0;\r\n}\r\nif (qos_actived) {\r\nhdr_len = RTLLIB_3ADDR_LEN + 2;\r\nwhile (unlikely(ieee->wmm_acm & (0x01 << skb->priority))) {\r\nprintk(KERN_INFO "skb->priority = %x\n", skb->priority);\r\nif (wme_downgrade_ac(skb))\r\nbreak;\r\nprintk(KERN_INFO "converted skb->priority = %x\n",\r\nskb->priority);\r\n}\r\nqos_ctl |= skb->priority;\r\nheader.qos_ctl = cpu_to_le16(qos_ctl & RTLLIB_QOS_TID);\r\n} else {\r\nhdr_len = RTLLIB_3ADDR_LEN;\r\n}\r\nbytes_per_frag = frag_size - hdr_len;\r\nif (ieee->config &\r\n(CFG_RTLLIB_COMPUTE_FCS | CFG_RTLLIB_RESERVE_FCS))\r\nbytes_per_frag -= RTLLIB_FCS_LEN;\r\nif (encrypt) {\r\nbytes_per_frag -= crypt->ops->extra_mpdu_prefix_len +\r\ncrypt->ops->extra_mpdu_postfix_len +\r\ncrypt->ops->extra_msdu_prefix_len +\r\ncrypt->ops->extra_msdu_postfix_len;\r\n}\r\nnr_frags = bytes / bytes_per_frag;\r\nbytes_last_frag = bytes % bytes_per_frag;\r\nif (bytes_last_frag)\r\nnr_frags++;\r\nelse\r\nbytes_last_frag = bytes_per_frag;\r\ntxb = rtllib_alloc_txb(nr_frags, frag_size +\r\nieee->tx_headroom, GFP_ATOMIC);\r\nif (unlikely(!txb)) {\r\nprintk(KERN_WARNING "%s: Could not allocate TXB\n",\r\nieee->dev->name);\r\ngoto failed;\r\n}\r\ntxb->encrypted = encrypt;\r\ntxb->payload_size = bytes;\r\nif (qos_actived)\r\ntxb->queue_index = UP2AC(skb->priority);\r\nelse\r\ntxb->queue_index = WME_AC_BE;\r\nfor (i = 0; i < nr_frags; i++) {\r\nskb_frag = txb->fragments[i];\r\ntcb_desc = (struct cb_desc *)(skb_frag->cb +\r\nMAX_DEV_ADDR_SIZE);\r\nif (qos_actived) {\r\nskb_frag->priority = skb->priority;\r\ntcb_desc->queue_index = UP2AC(skb->priority);\r\n} else {\r\nskb_frag->priority = WME_AC_BE;\r\ntcb_desc->queue_index = WME_AC_BE;\r\n}\r\nskb_reserve(skb_frag, ieee->tx_headroom);\r\nif (encrypt) {\r\nif (ieee->hwsec_active)\r\ntcb_desc->bHwSec = 1;\r\nelse\r\ntcb_desc->bHwSec = 0;\r\nskb_reserve(skb_frag,\r\ncrypt->ops->extra_mpdu_prefix_len +\r\ncrypt->ops->extra_msdu_prefix_len);\r\n} else {\r\ntcb_desc->bHwSec = 0;\r\n}\r\nfrag_hdr = (struct rtllib_hdr_3addrqos *)\r\nskb_put(skb_frag, hdr_len);\r\nmemcpy(frag_hdr, &header, hdr_len);\r\nif (i != nr_frags - 1) {\r\nfrag_hdr->frame_ctl = cpu_to_le16(\r\nfc | RTLLIB_FCTL_MOREFRAGS);\r\nbytes = bytes_per_frag;\r\n} else {\r\nbytes = bytes_last_frag;\r\n}\r\nif ((qos_actived) && (!bIsMulticast)) {\r\nfrag_hdr->seq_ctl =\r\nrtllib_query_seqnum(ieee, skb_frag,\r\nheader.addr1);\r\nfrag_hdr->seq_ctl =\r\ncpu_to_le16(frag_hdr->seq_ctl<<4 | i);\r\n} else {\r\nfrag_hdr->seq_ctl =\r\ncpu_to_le16(ieee->seq_ctrl[0]<<4 | i);\r\n}\r\nif (i == 0) {\r\nrtllib_put_snap(\r\nskb_put(skb_frag, SNAP_SIZE +\r\nsizeof(u16)), ether_type);\r\nbytes -= SNAP_SIZE + sizeof(u16);\r\n}\r\nmemcpy(skb_put(skb_frag, bytes), skb->data, bytes);\r\nskb_pull(skb, bytes);\r\nif (encrypt)\r\nrtllib_encrypt_fragment(ieee, skb_frag,\r\nhdr_len);\r\nif (ieee->config &\r\n(CFG_RTLLIB_COMPUTE_FCS | CFG_RTLLIB_RESERVE_FCS))\r\nskb_put(skb_frag, 4);\r\n}\r\nif ((qos_actived) && (!bIsMulticast)) {\r\nif (ieee->seq_ctrl[UP2AC(skb->priority) + 1] == 0xFFF)\r\nieee->seq_ctrl[UP2AC(skb->priority) + 1] = 0;\r\nelse\r\nieee->seq_ctrl[UP2AC(skb->priority) + 1]++;\r\n} else {\r\nif (ieee->seq_ctrl[0] == 0xFFF)\r\nieee->seq_ctrl[0] = 0;\r\nelse\r\nieee->seq_ctrl[0]++;\r\n}\r\n} else {\r\nif (unlikely(skb->len < sizeof(struct rtllib_hdr_3addr))) {\r\nprintk(KERN_WARNING "%s: skb too small (%d).\n",\r\nieee->dev->name, skb->len);\r\ngoto success;\r\n}\r\ntxb = rtllib_alloc_txb(1, skb->len, GFP_ATOMIC);\r\nif (!txb) {\r\nprintk(KERN_WARNING "%s: Could not allocate TXB\n",\r\nieee->dev->name);\r\ngoto failed;\r\n}\r\ntxb->encrypted = 0;\r\ntxb->payload_size = skb->len;\r\nmemcpy(skb_put(txb->fragments[0], skb->len), skb->data,\r\nskb->len);\r\n}\r\nsuccess:\r\nif (txb) {\r\nstruct cb_desc *tcb_desc = (struct cb_desc *)\r\n(txb->fragments[0]->cb + MAX_DEV_ADDR_SIZE);\r\ntcb_desc->bTxEnableFwCalcDur = 1;\r\ntcb_desc->priority = skb->priority;\r\nif (ether_type == ETH_P_PAE) {\r\nif (ieee->pHTInfo->IOTAction &\r\nHT_IOT_ACT_WA_IOT_Broadcom) {\r\ntcb_desc->data_rate =\r\nMgntQuery_TxRateExcludeCCKRates(ieee);\r\ntcb_desc->bTxDisableRateFallBack = false;\r\n} else {\r\ntcb_desc->data_rate = ieee->basic_rate;\r\ntcb_desc->bTxDisableRateFallBack = 1;\r\n}\r\ntcb_desc->RATRIndex = 7;\r\ntcb_desc->bTxUseDriverAssingedRate = 1;\r\n} else {\r\nif (is_multicast_ether_addr(header.addr1))\r\ntcb_desc->bMulticast = 1;\r\nif (is_broadcast_ether_addr(header.addr1))\r\ntcb_desc->bBroadcast = 1;\r\nrtllib_txrate_selectmode(ieee, tcb_desc);\r\nif (tcb_desc->bMulticast || tcb_desc->bBroadcast)\r\ntcb_desc->data_rate = ieee->basic_rate;\r\nelse\r\ntcb_desc->data_rate = CURRENT_RATE(ieee->mode,\r\nieee->rate, ieee->HTCurrentOperaRate);\r\nif (bdhcp == true) {\r\nif (ieee->pHTInfo->IOTAction &\r\nHT_IOT_ACT_WA_IOT_Broadcom) {\r\ntcb_desc->data_rate =\r\nMgntQuery_TxRateExcludeCCKRates(ieee);\r\ntcb_desc->bTxDisableRateFallBack = false;\r\n} else {\r\ntcb_desc->data_rate = MGN_1M;\r\ntcb_desc->bTxDisableRateFallBack = 1;\r\n}\r\ntcb_desc->RATRIndex = 7;\r\ntcb_desc->bTxUseDriverAssingedRate = 1;\r\ntcb_desc->bdhcp = 1;\r\n}\r\nrtllib_qurey_ShortPreambleMode(ieee, tcb_desc);\r\nrtllib_tx_query_agg_cap(ieee, txb->fragments[0],\r\ntcb_desc);\r\nrtllib_query_HTCapShortGI(ieee, tcb_desc);\r\nrtllib_query_BandwidthMode(ieee, tcb_desc);\r\nrtllib_query_protectionmode(ieee, tcb_desc,\r\ntxb->fragments[0]);\r\n}\r\n}\r\nspin_unlock_irqrestore(&ieee->lock, flags);\r\ndev_kfree_skb_any(skb);\r\nif (txb) {\r\nif (ieee->softmac_features & IEEE_SOFTMAC_TX_QUEUE) {\r\ndev->stats.tx_packets++;\r\ndev->stats.tx_bytes += txb->payload_size;\r\nrtllib_softmac_xmit(txb, ieee);\r\n} else {\r\nif ((*ieee->hard_start_xmit)(txb, dev) == 0) {\r\nstats->tx_packets++;\r\nstats->tx_bytes += txb->payload_size;\r\nreturn 0;\r\n}\r\nrtllib_txb_free(txb);\r\n}\r\n}\r\nreturn 0;\r\nfailed:\r\nspin_unlock_irqrestore(&ieee->lock, flags);\r\nnetif_stop_queue(dev);\r\nstats->tx_errors++;\r\nreturn 1;\r\n}\r\nint rtllib_xmit(struct sk_buff *skb, struct net_device *dev)\r\n{\r\nmemset(skb->cb, 0, sizeof(skb->cb));\r\nreturn rtllib_xmit_inter(skb, dev);\r\n}
