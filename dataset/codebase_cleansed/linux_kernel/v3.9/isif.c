static inline u32 regr(u32 offset)\r\n{\r\nreturn __raw_readl(isif_cfg.base_addr + offset);\r\n}\r\nstatic inline void regw(u32 val, u32 offset)\r\n{\r\n__raw_writel(val, isif_cfg.base_addr + offset);\r\n}\r\nstatic inline u32 reg_modify(u32 mask, u32 val, u32 offset)\r\n{\r\nu32 new_val = (regr(offset) & ~mask) | (val & mask);\r\nregw(new_val, offset);\r\nreturn new_val;\r\n}\r\nstatic inline void regw_lin_tbl(u32 val, u32 offset, int i)\r\n{\r\nif (!i)\r\n__raw_writel(val, isif_cfg.linear_tbl0_addr + offset);\r\nelse\r\n__raw_writel(val, isif_cfg.linear_tbl1_addr + offset);\r\n}\r\nstatic void isif_disable_all_modules(void)\r\n{\r\nregw(0, CLAMPCFG);\r\nregw(0, DFCCTL);\r\nregw(0, CSCCTL);\r\nregw(0, LINCFG0);\r\n}\r\nstatic void isif_enable(int en)\r\n{\r\nif (!en) {\r\nisif_disable_all_modules();\r\nmsleep(100);\r\n}\r\nreg_modify(ISIF_SYNCEN_VDHDEN_MASK, en, SYNCEN);\r\n}\r\nstatic void isif_enable_output_to_sdram(int en)\r\n{\r\nreg_modify(ISIF_SYNCEN_WEN_MASK, en << ISIF_SYNCEN_WEN_SHIFT, SYNCEN);\r\n}\r\nstatic void isif_config_culling(struct isif_cul *cul)\r\n{\r\nu32 val;\r\nval = (cul->hcpat_even << CULL_PAT_EVEN_LINE_SHIFT) | cul->hcpat_odd;\r\nregw(val, CULH);\r\nregw(cul->vcpat, CULV);\r\nreg_modify(ISIF_LPF_MASK << ISIF_LPF_SHIFT,\r\ncul->en_lpf << ISIF_LPF_SHIFT, MODESET);\r\n}\r\nstatic void isif_config_gain_offset(void)\r\n{\r\nstruct isif_gain_offsets_adj *gain_off_p =\r\n&isif_cfg.bayer.config_params.gain_offset;\r\nu32 val;\r\nval = (!!gain_off_p->gain_sdram_en << GAIN_SDRAM_EN_SHIFT) |\r\n(!!gain_off_p->gain_ipipe_en << GAIN_IPIPE_EN_SHIFT) |\r\n(!!gain_off_p->gain_h3a_en << GAIN_H3A_EN_SHIFT) |\r\n(!!gain_off_p->offset_sdram_en << OFST_SDRAM_EN_SHIFT) |\r\n(!!gain_off_p->offset_ipipe_en << OFST_IPIPE_EN_SHIFT) |\r\n(!!gain_off_p->offset_h3a_en << OFST_H3A_EN_SHIFT);\r\nreg_modify(GAIN_OFFSET_EN_MASK, val, CGAMMAWD);\r\nval = (gain_off_p->gain.r_ye.integer << GAIN_INTEGER_SHIFT) |\r\ngain_off_p->gain.r_ye.decimal;\r\nregw(val, CRGAIN);\r\nval = (gain_off_p->gain.gr_cy.integer << GAIN_INTEGER_SHIFT) |\r\ngain_off_p->gain.gr_cy.decimal;\r\nregw(val, CGRGAIN);\r\nval = (gain_off_p->gain.gb_g.integer << GAIN_INTEGER_SHIFT) |\r\ngain_off_p->gain.gb_g.decimal;\r\nregw(val, CGBGAIN);\r\nval = (gain_off_p->gain.b_mg.integer << GAIN_INTEGER_SHIFT) |\r\ngain_off_p->gain.b_mg.decimal;\r\nregw(val, CBGAIN);\r\nregw(gain_off_p->offset, COFSTA);\r\n}\r\nstatic void isif_restore_defaults(void)\r\n{\r\nenum vpss_ccdc_source_sel source = VPSS_CCDCIN;\r\ndev_dbg(isif_cfg.dev, "\nstarting isif_restore_defaults...");\r\nisif_cfg.bayer.config_params = isif_config_defaults;\r\nvpss_enable_clock(VPSS_CCDC_CLOCK, 1);\r\nvpss_enable_clock(VPSS_IPIPEIF_CLOCK, 1);\r\nvpss_enable_clock(VPSS_BL_CLOCK, 1);\r\nisif_config_gain_offset();\r\nvpss_select_ccdc_source(source);\r\ndev_dbg(isif_cfg.dev, "\nEnd of isif_restore_defaults...");\r\n}\r\nstatic int isif_open(struct device *device)\r\n{\r\nisif_restore_defaults();\r\nreturn 0;\r\n}\r\nstatic void isif_setwin(struct v4l2_rect *image_win,\r\nenum ccdc_frmfmt frm_fmt, int ppc)\r\n{\r\nint horz_start, horz_nr_pixels;\r\nint vert_start, vert_nr_lines;\r\nint mid_img = 0;\r\ndev_dbg(isif_cfg.dev, "\nStarting isif_setwin...");\r\nhorz_start = image_win->left << (ppc - 1);\r\nhorz_nr_pixels = ((image_win->width) << (ppc - 1)) - 1;\r\nregw(horz_start & START_PX_HOR_MASK, SPH);\r\nregw(horz_nr_pixels & NUM_PX_HOR_MASK, LNH);\r\nvert_start = image_win->top;\r\nif (frm_fmt == CCDC_FRMFMT_INTERLACED) {\r\nvert_nr_lines = (image_win->height >> 1) - 1;\r\nvert_start >>= 1;\r\nvert_start += 1;\r\n} else {\r\nvert_start += 1;\r\nvert_nr_lines = image_win->height - 1;\r\nmid_img = vert_start + (image_win->height / 2);\r\nregw(mid_img, VDINT1);\r\n}\r\nregw(0, VDINT0);\r\nregw(vert_start & START_VER_ONE_MASK, SLV0);\r\nregw(vert_start & START_VER_TWO_MASK, SLV1);\r\nregw(vert_nr_lines & NUM_LINES_VER, LNV);\r\n}\r\nstatic void isif_config_bclamp(struct isif_black_clamp *bc)\r\n{\r\nu32 val;\r\nregw(bc->dc_offset, CLDCOFST);\r\nif (bc->en) {\r\nval = bc->bc_mode_color << ISIF_BC_MODE_COLOR_SHIFT;\r\nval = val | 1 | (bc->horz.mode << ISIF_HORZ_BC_MODE_SHIFT);\r\nregw(val, CLAMPCFG);\r\nif (bc->horz.mode != ISIF_HORZ_BC_DISABLE) {\r\nval = bc->horz.win_count_calc |\r\n((!!bc->horz.base_win_sel_calc) <<\r\nISIF_HORZ_BC_WIN_SEL_SHIFT) |\r\n((!!bc->horz.clamp_pix_limit) <<\r\nISIF_HORZ_BC_PIX_LIMIT_SHIFT) |\r\n(bc->horz.win_h_sz_calc <<\r\nISIF_HORZ_BC_WIN_H_SIZE_SHIFT) |\r\n(bc->horz.win_v_sz_calc <<\r\nISIF_HORZ_BC_WIN_V_SIZE_SHIFT);\r\nregw(val, CLHWIN0);\r\nregw(bc->horz.win_start_h_calc, CLHWIN1);\r\nregw(bc->horz.win_start_v_calc, CLHWIN2);\r\n}\r\nval |=\r\n(bc->vert.reset_val_sel << ISIF_VERT_BC_RST_VAL_SEL_SHIFT) |\r\n(bc->vert.line_ave_coef << ISIF_VERT_BC_LINE_AVE_COEF_SHIFT);\r\nregw(val, CLVWIN0);\r\nregw(bc->vert.ob_start_h, CLVWIN1);\r\nregw(bc->vert.ob_start_v, CLVWIN2);\r\nregw(bc->vert.ob_v_sz_calc, CLVWIN3);\r\nregw(bc->vert_start_sub, CLSV);\r\n}\r\n}\r\nstatic void isif_config_linearization(struct isif_linearize *linearize)\r\n{\r\nu32 val, i;\r\nif (!linearize->en) {\r\nregw(0, LINCFG0);\r\nreturn;\r\n}\r\nval = (linearize->corr_shft << ISIF_LIN_CORRSFT_SHIFT) | 1;\r\nregw(val, LINCFG0);\r\nval = ((!!linearize->scale_fact.integer) <<\r\nISIF_LIN_SCALE_FACT_INTEG_SHIFT) |\r\nlinearize->scale_fact.decimal;\r\nregw(val, LINCFG1);\r\nfor (i = 0; i < ISIF_LINEAR_TAB_SIZE; i++) {\r\nif (i % 2)\r\nregw_lin_tbl(linearize->table[i], ((i >> 1) << 2), 1);\r\nelse\r\nregw_lin_tbl(linearize->table[i], ((i >> 1) << 2), 0);\r\n}\r\n}\r\nstatic int isif_config_dfc(struct isif_dfc *vdfc)\r\n{\r\nu32 val, count, retries = loops_per_jiffy / (4000/HZ);\r\nint i;\r\nif (!vdfc->en)\r\nreturn 0;\r\nval = (vdfc->corr_mode << ISIF_VDFC_CORR_MOD_SHIFT);\r\nif (vdfc->corr_whole_line)\r\nval |= 1 << ISIF_VDFC_CORR_WHOLE_LN_SHIFT;\r\nval |= vdfc->def_level_shift << ISIF_VDFC_LEVEL_SHFT_SHIFT;\r\nregw(val, DFCCTL);\r\nregw(vdfc->def_sat_level, VDFSATLV);\r\nregw(vdfc->table[0].pos_vert, DFCMEM0);\r\nregw(vdfc->table[0].pos_horz, DFCMEM1);\r\nif (vdfc->corr_mode == ISIF_VDFC_NORMAL ||\r\nvdfc->corr_mode == ISIF_VDFC_HORZ_INTERPOL_IF_SAT) {\r\nregw(vdfc->table[0].level_at_pos, DFCMEM2);\r\nregw(vdfc->table[0].level_up_pixels, DFCMEM3);\r\nregw(vdfc->table[0].level_low_pixels, DFCMEM4);\r\n}\r\nval = regr(DFCMEMCTL) | (1 << ISIF_DFCMEMCTL_DFCMARST_SHIFT) | 1;\r\nregw(val, DFCMEMCTL);\r\ncount = retries;\r\nwhile (count && (regr(DFCMEMCTL) & 0x1))\r\ncount--;\r\nif (!count) {\r\ndev_dbg(isif_cfg.dev, "defect table write timeout !!!\n");\r\nreturn -1;\r\n}\r\nfor (i = 1; i < vdfc->num_vdefects; i++) {\r\nregw(vdfc->table[i].pos_vert, DFCMEM0);\r\nregw(vdfc->table[i].pos_horz, DFCMEM1);\r\nif (vdfc->corr_mode == ISIF_VDFC_NORMAL ||\r\nvdfc->corr_mode == ISIF_VDFC_HORZ_INTERPOL_IF_SAT) {\r\nregw(vdfc->table[i].level_at_pos, DFCMEM2);\r\nregw(vdfc->table[i].level_up_pixels, DFCMEM3);\r\nregw(vdfc->table[i].level_low_pixels, DFCMEM4);\r\n}\r\nval = regr(DFCMEMCTL);\r\nval &= ~BIT(ISIF_DFCMEMCTL_DFCMARST_SHIFT);\r\nval |= 1;\r\nregw(val, DFCMEMCTL);\r\ncount = retries;\r\nwhile (count && (regr(DFCMEMCTL) & 0x1))\r\ncount--;\r\nif (!count) {\r\ndev_err(isif_cfg.dev,\r\n"defect table write timeout !!!\n");\r\nreturn -1;\r\n}\r\n}\r\nif (vdfc->num_vdefects < ISIF_VDFC_TABLE_SIZE) {\r\nregw(0, DFCMEM0);\r\nregw(0x1FFF, DFCMEM1);\r\nregw(1, DFCMEMCTL);\r\n}\r\nreg_modify((1 << ISIF_VDFC_EN_SHIFT), (1 << ISIF_VDFC_EN_SHIFT),\r\nDFCCTL);\r\nreturn 0;\r\n}\r\nstatic void isif_config_csc(struct isif_df_csc *df_csc)\r\n{\r\nu32 val1 = 0, val2 = 0, i;\r\nif (!df_csc->csc.en) {\r\nregw(0, CSCCTL);\r\nreturn;\r\n}\r\nfor (i = 0; i < ISIF_CSC_NUM_COEFF; i++) {\r\nif ((i % 2) == 0) {\r\nval1 = (df_csc->csc.coeff[i].integer <<\r\nISIF_CSC_COEF_INTEG_SHIFT) |\r\ndf_csc->csc.coeff[i].decimal;\r\n} else {\r\nval2 = (df_csc->csc.coeff[i].integer <<\r\nISIF_CSC_COEF_INTEG_SHIFT) |\r\ndf_csc->csc.coeff[i].decimal;\r\nval2 <<= ISIF_CSCM_MSB_SHIFT;\r\nval2 |= val1;\r\nregw(val2, (CSCM0 + ((i - 1) << 1)));\r\n}\r\n}\r\nregw(df_csc->start_pix, FMTSPH);\r\nregw(df_csc->num_pixels, FMTLNH);\r\nregw(df_csc->start_line, FMTSLV);\r\nregw(df_csc->num_lines, FMTLNV);\r\nregw(1, CSCCTL);\r\n}\r\nstatic int isif_config_raw(void)\r\n{\r\nstruct isif_params_raw *params = &isif_cfg.bayer;\r\nstruct isif_config_params_raw *module_params =\r\n&isif_cfg.bayer.config_params;\r\nstruct vpss_pg_frame_size frame_size;\r\nstruct vpss_sync_pol sync;\r\nu32 val;\r\ndev_dbg(isif_cfg.dev, "\nStarting isif_config_raw..\n");\r\nval = ISIF_YCINSWP_RAW | ISIF_CCDCFG_FIDMD_LATCH_VSYNC |\r\nISIF_CCDCFG_WENLOG_AND | ISIF_CCDCFG_TRGSEL_WEN |\r\nISIF_CCDCFG_EXTRG_DISABLE | isif_cfg.data_pack;\r\ndev_dbg(isif_cfg.dev, "Writing 0x%x to ...CCDCFG \n", val);\r\nregw(val, CCDCFG);\r\nval = ISIF_VDHDOUT_INPUT | (params->vd_pol << ISIF_VD_POL_SHIFT) |\r\n(params->hd_pol << ISIF_HD_POL_SHIFT) |\r\n(params->fid_pol << ISIF_FID_POL_SHIFT) |\r\n(ISIF_DATAPOL_NORMAL << ISIF_DATAPOL_SHIFT) |\r\n(ISIF_EXWEN_DISABLE << ISIF_EXWEN_SHIFT) |\r\n(params->frm_fmt << ISIF_FRM_FMT_SHIFT) |\r\n(params->pix_fmt << ISIF_INPUT_SHIFT) |\r\n(params->config_params.data_shift << ISIF_DATASFT_SHIFT);\r\nregw(val, MODESET);\r\ndev_dbg(isif_cfg.dev, "Writing 0x%x to MODESET...\n", val);\r\nval = params->cfa_pat << ISIF_GAMMAWD_CFA_SHIFT;\r\nif (module_params->compress.alg == ISIF_ALAW)\r\nval |= ISIF_ALAW_ENABLE;\r\nval |= (params->data_msb << ISIF_ALAW_GAMA_WD_SHIFT);\r\nregw(val, CGAMMAWD);\r\nif (module_params->compress.alg == ISIF_DPCM) {\r\nval = BIT(ISIF_DPCM_EN_SHIFT) |\r\n(module_params->compress.pred <<\r\nISIF_DPCM_PREDICTOR_SHIFT);\r\n}\r\nregw(val, MISC);\r\nisif_config_gain_offset();\r\nval = (params->config_params.col_pat_field0.olop) |\r\n(params->config_params.col_pat_field0.olep << 2) |\r\n(params->config_params.col_pat_field0.elop << 4) |\r\n(params->config_params.col_pat_field0.elep << 6) |\r\n(params->config_params.col_pat_field1.olop << 8) |\r\n(params->config_params.col_pat_field1.olep << 10) |\r\n(params->config_params.col_pat_field1.elop << 12) |\r\n(params->config_params.col_pat_field1.elep << 14);\r\nregw(val, CCOLP);\r\ndev_dbg(isif_cfg.dev, "Writing %x to CCOLP ...\n", val);\r\nval = (!!params->horz_flip_en) << ISIF_HSIZE_FLIP_SHIFT;\r\nif (isif_cfg.data_pack == ISIF_PACK_8BIT)\r\nval |= ((params->win.width + 31) >> 5);\r\nelse if (isif_cfg.data_pack == ISIF_PACK_12BIT)\r\nval |= (((params->win.width +\r\n(params->win.width >> 2)) + 31) >> 5);\r\nelse\r\nval |= (((params->win.width * 2) + 31) >> 5);\r\nregw(val, HSIZE);\r\nif (params->frm_fmt == CCDC_FRMFMT_INTERLACED) {\r\nif (params->image_invert_en) {\r\nregw(0x4B6D, SDOFST);\r\ndev_dbg(isif_cfg.dev, "Writing 0x4B6D to SDOFST...\n");\r\n} else {\r\nregw(0x0B6D, SDOFST);\r\ndev_dbg(isif_cfg.dev, "Writing 0x0B6D to SDOFST...\n");\r\n}\r\n} else if (params->frm_fmt == CCDC_FRMFMT_PROGRESSIVE) {\r\nif (params->image_invert_en) {\r\nregw(0x4000, SDOFST);\r\ndev_dbg(isif_cfg.dev, "Writing 0x4000 to SDOFST...\n");\r\n} else {\r\nregw(0x0000, SDOFST);\r\ndev_dbg(isif_cfg.dev, "Writing 0x0000 to SDOFST...\n");\r\n}\r\n}\r\nisif_setwin(&params->win, params->frm_fmt, 1);\r\nisif_config_bclamp(&module_params->bclamp);\r\nif (isif_config_dfc(&module_params->dfc) < 0)\r\nreturn -EFAULT;\r\nif (!module_params->df_csc.df_or_csc)\r\nisif_config_csc(&module_params->df_csc);\r\nisif_config_linearization(&module_params->linearize);\r\nisif_config_culling(&module_params->culling);\r\nregw(module_params->horz_offset, DATAHOFST);\r\nregw(module_params->vert_offset, DATAVOFST);\r\nif (params->config_params.test_pat_gen) {\r\nsync.ccdpg_hdpol = params->hd_pol;\r\nsync.ccdpg_vdpol = params->vd_pol;\r\ndm365_vpss_set_sync_pol(sync);\r\nframe_size.hlpfr = isif_cfg.bayer.win.width;\r\nframe_size.pplen = isif_cfg.bayer.win.height;\r\ndm365_vpss_set_pg_frame_size(frame_size);\r\nvpss_select_ccdc_source(VPSS_PGLPBK);\r\n}\r\ndev_dbg(isif_cfg.dev, "\nEnd of isif_config_ycbcr...\n");\r\nreturn 0;\r\n}\r\nstatic int isif_set_buftype(enum ccdc_buftype buf_type)\r\n{\r\nif (isif_cfg.if_type == VPFE_RAW_BAYER)\r\nisif_cfg.bayer.buf_type = buf_type;\r\nelse\r\nisif_cfg.ycbcr.buf_type = buf_type;\r\nreturn 0;\r\n}\r\nstatic enum ccdc_buftype isif_get_buftype(void)\r\n{\r\nif (isif_cfg.if_type == VPFE_RAW_BAYER)\r\nreturn isif_cfg.bayer.buf_type;\r\nreturn isif_cfg.ycbcr.buf_type;\r\n}\r\nstatic int isif_enum_pix(u32 *pix, int i)\r\n{\r\nint ret = -EINVAL;\r\nif (isif_cfg.if_type == VPFE_RAW_BAYER) {\r\nif (i < ARRAY_SIZE(isif_raw_bayer_pix_formats)) {\r\n*pix = isif_raw_bayer_pix_formats[i];\r\nret = 0;\r\n}\r\n} else {\r\nif (i < ARRAY_SIZE(isif_raw_yuv_pix_formats)) {\r\n*pix = isif_raw_yuv_pix_formats[i];\r\nret = 0;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic int isif_set_pixel_format(unsigned int pixfmt)\r\n{\r\nif (isif_cfg.if_type == VPFE_RAW_BAYER) {\r\nif (pixfmt == V4L2_PIX_FMT_SBGGR8) {\r\nif ((isif_cfg.bayer.config_params.compress.alg !=\r\nISIF_ALAW) &&\r\n(isif_cfg.bayer.config_params.compress.alg !=\r\nISIF_DPCM)) {\r\ndev_dbg(isif_cfg.dev,\r\n"Either configure A-Law or DPCM\n");\r\nreturn -EINVAL;\r\n}\r\nisif_cfg.data_pack = ISIF_PACK_8BIT;\r\n} else if (pixfmt == V4L2_PIX_FMT_SBGGR16) {\r\nisif_cfg.bayer.config_params.compress.alg =\r\nISIF_NO_COMPRESSION;\r\nisif_cfg.data_pack = ISIF_PACK_16BIT;\r\n} else\r\nreturn -EINVAL;\r\nisif_cfg.bayer.pix_fmt = CCDC_PIXFMT_RAW;\r\n} else {\r\nif (pixfmt == V4L2_PIX_FMT_YUYV)\r\nisif_cfg.ycbcr.pix_order = CCDC_PIXORDER_YCBYCR;\r\nelse if (pixfmt == V4L2_PIX_FMT_UYVY)\r\nisif_cfg.ycbcr.pix_order = CCDC_PIXORDER_CBYCRY;\r\nelse\r\nreturn -EINVAL;\r\nisif_cfg.data_pack = ISIF_PACK_8BIT;\r\n}\r\nreturn 0;\r\n}\r\nstatic u32 isif_get_pixel_format(void)\r\n{\r\nu32 pixfmt;\r\nif (isif_cfg.if_type == VPFE_RAW_BAYER)\r\nif (isif_cfg.bayer.config_params.compress.alg == ISIF_ALAW ||\r\nisif_cfg.bayer.config_params.compress.alg == ISIF_DPCM)\r\npixfmt = V4L2_PIX_FMT_SBGGR8;\r\nelse\r\npixfmt = V4L2_PIX_FMT_SBGGR16;\r\nelse {\r\nif (isif_cfg.ycbcr.pix_order == CCDC_PIXORDER_YCBYCR)\r\npixfmt = V4L2_PIX_FMT_YUYV;\r\nelse\r\npixfmt = V4L2_PIX_FMT_UYVY;\r\n}\r\nreturn pixfmt;\r\n}\r\nstatic int isif_set_image_window(struct v4l2_rect *win)\r\n{\r\nif (isif_cfg.if_type == VPFE_RAW_BAYER) {\r\nisif_cfg.bayer.win.top = win->top;\r\nisif_cfg.bayer.win.left = win->left;\r\nisif_cfg.bayer.win.width = win->width;\r\nisif_cfg.bayer.win.height = win->height;\r\n} else {\r\nisif_cfg.ycbcr.win.top = win->top;\r\nisif_cfg.ycbcr.win.left = win->left;\r\nisif_cfg.ycbcr.win.width = win->width;\r\nisif_cfg.ycbcr.win.height = win->height;\r\n}\r\nreturn 0;\r\n}\r\nstatic void isif_get_image_window(struct v4l2_rect *win)\r\n{\r\nif (isif_cfg.if_type == VPFE_RAW_BAYER)\r\n*win = isif_cfg.bayer.win;\r\nelse\r\n*win = isif_cfg.ycbcr.win;\r\n}\r\nstatic unsigned int isif_get_line_length(void)\r\n{\r\nunsigned int len;\r\nif (isif_cfg.if_type == VPFE_RAW_BAYER) {\r\nif (isif_cfg.data_pack == ISIF_PACK_8BIT)\r\nlen = ((isif_cfg.bayer.win.width));\r\nelse if (isif_cfg.data_pack == ISIF_PACK_12BIT)\r\nlen = (((isif_cfg.bayer.win.width * 2) +\r\n(isif_cfg.bayer.win.width >> 2)));\r\nelse\r\nlen = (((isif_cfg.bayer.win.width * 2)));\r\n} else\r\nlen = (((isif_cfg.ycbcr.win.width * 2)));\r\nreturn ALIGN(len, 32);\r\n}\r\nstatic int isif_set_frame_format(enum ccdc_frmfmt frm_fmt)\r\n{\r\nif (isif_cfg.if_type == VPFE_RAW_BAYER)\r\nisif_cfg.bayer.frm_fmt = frm_fmt;\r\nelse\r\nisif_cfg.ycbcr.frm_fmt = frm_fmt;\r\nreturn 0;\r\n}\r\nstatic enum ccdc_frmfmt isif_get_frame_format(void)\r\n{\r\nif (isif_cfg.if_type == VPFE_RAW_BAYER)\r\nreturn isif_cfg.bayer.frm_fmt;\r\nreturn isif_cfg.ycbcr.frm_fmt;\r\n}\r\nstatic int isif_getfid(void)\r\n{\r\nreturn (regr(MODESET) >> 15) & 0x1;\r\n}\r\nstatic void isif_setfbaddr(unsigned long addr)\r\n{\r\nregw((addr >> 21) & 0x07ff, CADU);\r\nregw((addr >> 5) & 0x0ffff, CADL);\r\n}\r\nstatic int isif_set_hw_if_params(struct vpfe_hw_if_param *params)\r\n{\r\nisif_cfg.if_type = params->if_type;\r\nswitch (params->if_type) {\r\ncase VPFE_BT656:\r\ncase VPFE_BT656_10BIT:\r\ncase VPFE_YCBCR_SYNC_8:\r\nisif_cfg.ycbcr.pix_fmt = CCDC_PIXFMT_YCBCR_8BIT;\r\nisif_cfg.ycbcr.pix_order = CCDC_PIXORDER_CBYCRY;\r\nbreak;\r\ncase VPFE_BT1120:\r\ncase VPFE_YCBCR_SYNC_16:\r\nisif_cfg.ycbcr.pix_fmt = CCDC_PIXFMT_YCBCR_16BIT;\r\nisif_cfg.ycbcr.pix_order = CCDC_PIXORDER_CBYCRY;\r\nbreak;\r\ncase VPFE_RAW_BAYER:\r\nisif_cfg.bayer.pix_fmt = CCDC_PIXFMT_RAW;\r\nbreak;\r\ndefault:\r\ndev_dbg(isif_cfg.dev, "Invalid interface type\n");\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int isif_config_ycbcr(void)\r\n{\r\nstruct isif_ycbcr_config *params = &isif_cfg.ycbcr;\r\nstruct vpss_pg_frame_size frame_size;\r\nu32 modeset = 0, ccdcfg = 0;\r\nstruct vpss_sync_pol sync;\r\ndev_dbg(isif_cfg.dev, "\nStarting isif_config_ycbcr...");\r\nmodeset = modeset | (params->pix_fmt << ISIF_INPUT_SHIFT) |\r\n(params->frm_fmt << ISIF_FRM_FMT_SHIFT) |\r\n(params->fid_pol << ISIF_FID_POL_SHIFT) |\r\n(params->hd_pol << ISIF_HD_POL_SHIFT) |\r\n(params->vd_pol << ISIF_VD_POL_SHIFT);\r\nswitch (isif_cfg.if_type) {\r\ncase VPFE_BT656:\r\nif (params->pix_fmt != CCDC_PIXFMT_YCBCR_8BIT) {\r\ndev_dbg(isif_cfg.dev, "Invalid pix_fmt(input mode)\n");\r\nreturn -EINVAL;\r\n}\r\nmodeset |= (VPFE_PINPOL_NEGATIVE << ISIF_VD_POL_SHIFT);\r\nregw(3, REC656IF);\r\nccdcfg = ccdcfg | ISIF_DATA_PACK8 | ISIF_YCINSWP_YCBCR;\r\nbreak;\r\ncase VPFE_BT656_10BIT:\r\nif (params->pix_fmt != CCDC_PIXFMT_YCBCR_8BIT) {\r\ndev_dbg(isif_cfg.dev, "Invalid pix_fmt(input mode)\n");\r\nreturn -EINVAL;\r\n}\r\nregw(3, REC656IF);\r\nccdcfg = ccdcfg | ISIF_DATA_PACK8 | ISIF_YCINSWP_YCBCR |\r\nISIF_BW656_ENABLE;\r\nbreak;\r\ncase VPFE_BT1120:\r\nif (params->pix_fmt != CCDC_PIXFMT_YCBCR_16BIT) {\r\ndev_dbg(isif_cfg.dev, "Invalid pix_fmt(input mode)\n");\r\nreturn -EINVAL;\r\n}\r\nregw(3, REC656IF);\r\nbreak;\r\ncase VPFE_YCBCR_SYNC_8:\r\nccdcfg |= ISIF_DATA_PACK8;\r\nccdcfg |= ISIF_YCINSWP_YCBCR;\r\nif (params->pix_fmt != CCDC_PIXFMT_YCBCR_8BIT) {\r\ndev_dbg(isif_cfg.dev, "Invalid pix_fmt(input mode)\n");\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ncase VPFE_YCBCR_SYNC_16:\r\nif (params->pix_fmt != CCDC_PIXFMT_YCBCR_16BIT) {\r\ndev_dbg(isif_cfg.dev, "Invalid pix_fmt(input mode)\n");\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ndefault:\r\ndev_dbg(isif_cfg.dev, "Invalid interface type\n");\r\nreturn -EINVAL;\r\n}\r\nregw(modeset, MODESET);\r\nccdcfg |= params->pix_order << ISIF_PIX_ORDER_SHIFT;\r\nregw(ccdcfg, CCDCFG);\r\nif ((isif_cfg.if_type == VPFE_BT1120) ||\r\n(isif_cfg.if_type == VPFE_YCBCR_SYNC_16))\r\nisif_setwin(&params->win, params->frm_fmt, 1);\r\nelse\r\nisif_setwin(&params->win, params->frm_fmt, 2);\r\nregw(((((params->win.width * 2) + 31) & 0xffffffe0) >> 5), HSIZE);\r\nif ((params->frm_fmt == CCDC_FRMFMT_INTERLACED) &&\r\n(params->buf_type == CCDC_BUFTYPE_FLD_INTERLEAVED))\r\nregw(0x00000249, SDOFST);\r\nif (isif_cfg.bayer.config_params.test_pat_gen) {\r\nsync.ccdpg_hdpol = params->hd_pol;\r\nsync.ccdpg_vdpol = params->vd_pol;\r\ndm365_vpss_set_sync_pol(sync);\r\ndm365_vpss_set_pg_frame_size(frame_size);\r\n}\r\nreturn 0;\r\n}\r\nstatic int isif_configure(void)\r\n{\r\nif (isif_cfg.if_type == VPFE_RAW_BAYER)\r\nreturn isif_config_raw();\r\nreturn isif_config_ycbcr();\r\n}\r\nstatic int isif_close(struct device *device)\r\n{\r\nisif_cfg.bayer.config_params = isif_config_defaults;\r\nreturn 0;\r\n}\r\nstatic int isif_probe(struct platform_device *pdev)\r\n{\r\nvoid (*setup_pinmux)(void);\r\nstruct resource *res;\r\nvoid *__iomem addr;\r\nint status = 0, i;\r\nstatus = vpfe_register_ccdc_device(&isif_hw_dev);\r\nif (status < 0)\r\nreturn status;\r\nisif_cfg.mclk = clk_get(&pdev->dev, "master");\r\nif (IS_ERR(isif_cfg.mclk)) {\r\nstatus = PTR_ERR(isif_cfg.mclk);\r\ngoto fail_mclk;\r\n}\r\nif (clk_prepare_enable(isif_cfg.mclk)) {\r\nstatus = -ENODEV;\r\ngoto fail_mclk;\r\n}\r\nif (NULL == pdev->dev.platform_data) {\r\nstatus = -ENODEV;\r\ngoto fail_mclk;\r\n}\r\nsetup_pinmux = pdev->dev.platform_data;\r\nsetup_pinmux();\r\ni = 0;\r\nwhile (i < 3) {\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, i);\r\nif (!res) {\r\nstatus = -ENODEV;\r\ngoto fail_nobase_res;\r\n}\r\nres = request_mem_region(res->start, resource_size(res),\r\nres->name);\r\nif (!res) {\r\nstatus = -EBUSY;\r\ngoto fail_nobase_res;\r\n}\r\naddr = ioremap_nocache(res->start, resource_size(res));\r\nif (!addr) {\r\nstatus = -ENOMEM;\r\ngoto fail_base_iomap;\r\n}\r\nswitch (i) {\r\ncase 0:\r\nisif_cfg.base_addr = addr;\r\nbreak;\r\ncase 1:\r\nisif_cfg.linear_tbl0_addr = addr;\r\nbreak;\r\ndefault:\r\nisif_cfg.linear_tbl1_addr = addr;\r\nbreak;\r\n}\r\ni++;\r\n}\r\nisif_cfg.dev = &pdev->dev;\r\nprintk(KERN_NOTICE "%s is registered with vpfe.\n",\r\nisif_hw_dev.name);\r\nreturn 0;\r\nfail_base_iomap:\r\nrelease_mem_region(res->start, resource_size(res));\r\ni--;\r\nfail_nobase_res:\r\nif (isif_cfg.base_addr)\r\niounmap(isif_cfg.base_addr);\r\nif (isif_cfg.linear_tbl0_addr)\r\niounmap(isif_cfg.linear_tbl0_addr);\r\nwhile (i >= 0) {\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, i);\r\nrelease_mem_region(res->start, resource_size(res));\r\ni--;\r\n}\r\nfail_mclk:\r\nclk_disable_unprepare(isif_cfg.mclk);\r\nclk_put(isif_cfg.mclk);\r\nvpfe_unregister_ccdc_device(&isif_hw_dev);\r\nreturn status;\r\n}\r\nstatic int isif_remove(struct platform_device *pdev)\r\n{\r\nstruct resource *res;\r\nint i = 0;\r\niounmap(isif_cfg.base_addr);\r\niounmap(isif_cfg.linear_tbl0_addr);\r\niounmap(isif_cfg.linear_tbl1_addr);\r\nwhile (i < 3) {\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, i);\r\nif (res)\r\nrelease_mem_region(res->start, resource_size(res));\r\ni++;\r\n}\r\nvpfe_unregister_ccdc_device(&isif_hw_dev);\r\nclk_disable_unprepare(isif_cfg.mclk);\r\nclk_put(isif_cfg.mclk);\r\nreturn 0;\r\n}
