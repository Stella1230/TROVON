static inline void *get_rloc_data(u32 *dl)\r\n{\r\nreturn (u8 *)dl + get_rloc_offs(*dl);\r\n}\r\nstatic inline void *get_loc_data(u32 *dl, void *ent)\r\n{\r\nreturn (u8 *)ent + get_rloc_offs(*dl);\r\n}\r\nstatic __kprobes int PRINT_TYPE_FUNC_NAME(string)(struct trace_seq *s,\r\nconst char *name,\r\nvoid *data, void *ent)\r\n{\r\nint len = *(u32 *)data >> 16;\r\nif (!len)\r\nreturn trace_seq_printf(s, " %s=(fault)", name);\r\nelse\r\nreturn trace_seq_printf(s, " %s=\"%s\"", name,\r\n(const char *)get_loc_data(data, ent));\r\n}\r\nstatic unsigned long update_symbol_cache(struct symbol_cache *sc)\r\n{\r\nsc->addr = (unsigned long)kallsyms_lookup_name(sc->symbol);\r\nif (sc->addr)\r\nsc->addr += sc->offset;\r\nreturn sc->addr;\r\n}\r\nstatic void free_symbol_cache(struct symbol_cache *sc)\r\n{\r\nkfree(sc->symbol);\r\nkfree(sc);\r\n}\r\nstatic struct symbol_cache *alloc_symbol_cache(const char *sym, long offset)\r\n{\r\nstruct symbol_cache *sc;\r\nif (!sym || strlen(sym) == 0)\r\nreturn NULL;\r\nsc = kzalloc(sizeof(struct symbol_cache), GFP_KERNEL);\r\nif (!sc)\r\nreturn NULL;\r\nsc->symbol = kstrdup(sym, GFP_KERNEL);\r\nif (!sc->symbol) {\r\nkfree(sc);\r\nreturn NULL;\r\n}\r\nsc->offset = offset;\r\nupdate_symbol_cache(sc);\r\nreturn sc;\r\n}\r\nstatic __kprobes void update_deref_fetch_param(struct deref_fetch_param *data)\r\n{\r\nif (CHECK_FETCH_FUNCS(deref, data->orig.fn))\r\nupdate_deref_fetch_param(data->orig.data);\r\nelse if (CHECK_FETCH_FUNCS(symbol, data->orig.fn))\r\nupdate_symbol_cache(data->orig.data);\r\n}\r\nstatic __kprobes void free_deref_fetch_param(struct deref_fetch_param *data)\r\n{\r\nif (CHECK_FETCH_FUNCS(deref, data->orig.fn))\r\nfree_deref_fetch_param(data->orig.data);\r\nelse if (CHECK_FETCH_FUNCS(symbol, data->orig.fn))\r\nfree_symbol_cache(data->orig.data);\r\nkfree(data);\r\n}\r\nstatic __kprobes void\r\nupdate_bitfield_fetch_param(struct bitfield_fetch_param *data)\r\n{\r\nif (CHECK_FETCH_FUNCS(deref, data->orig.fn))\r\nupdate_deref_fetch_param(data->orig.data);\r\nelse if (CHECK_FETCH_FUNCS(symbol, data->orig.fn))\r\nupdate_symbol_cache(data->orig.data);\r\n}\r\nstatic __kprobes void\r\nfree_bitfield_fetch_param(struct bitfield_fetch_param *data)\r\n{\r\nif (CHECK_FETCH_FUNCS(deref, data->orig.fn))\r\nfree_deref_fetch_param(data->orig.data);\r\nelse if (CHECK_FETCH_FUNCS(symbol, data->orig.fn))\r\nfree_symbol_cache(data->orig.data);\r\nkfree(data);\r\n}\r\nstatic const struct fetch_type *find_fetch_type(const char *type)\r\n{\r\nint i;\r\nif (!type)\r\ntype = DEFAULT_FETCH_TYPE_STR;\r\nif (*type == 'b') {\r\nunsigned long bs;\r\ntype = strchr(type, '/');\r\nif (!type)\r\ngoto fail;\r\ntype++;\r\nif (kstrtoul(type, 0, &bs))\r\ngoto fail;\r\nswitch (bs) {\r\ncase 8:\r\nreturn find_fetch_type("u8");\r\ncase 16:\r\nreturn find_fetch_type("u16");\r\ncase 32:\r\nreturn find_fetch_type("u32");\r\ncase 64:\r\nreturn find_fetch_type("u64");\r\ndefault:\r\ngoto fail;\r\n}\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(fetch_type_table); i++)\r\nif (strcmp(type, fetch_type_table[i].name) == 0)\r\nreturn &fetch_type_table[i];\r\nfail:\r\nreturn NULL;\r\n}\r\nstatic __kprobes void fetch_stack_address(struct pt_regs *regs,\r\nvoid *dummy, void *dest)\r\n{\r\n*(unsigned long *)dest = kernel_stack_pointer(regs);\r\n}\r\nstatic fetch_func_t get_fetch_size_function(const struct fetch_type *type,\r\nfetch_func_t orig_fn)\r\n{\r\nint i;\r\nif (type != &fetch_type_table[FETCH_TYPE_STRING])\r\nreturn NULL;\r\nfor (i = 0; i < FETCH_MTD_END; i++)\r\nif (type->fetch[i] == orig_fn)\r\nreturn fetch_type_table[FETCH_TYPE_STRSIZE].fetch[i];\r\nWARN_ON(1);\r\nreturn NULL;\r\n}\r\nint traceprobe_split_symbol_offset(char *symbol, unsigned long *offset)\r\n{\r\nchar *tmp;\r\nint ret;\r\nif (!offset)\r\nreturn -EINVAL;\r\ntmp = strchr(symbol, '+');\r\nif (tmp) {\r\nret = kstrtoul(tmp + 1, 0, offset);\r\nif (ret)\r\nreturn ret;\r\n*tmp = '\0';\r\n} else\r\n*offset = 0;\r\nreturn 0;\r\n}\r\nstatic int parse_probe_vars(char *arg, const struct fetch_type *t,\r\nstruct fetch_param *f, bool is_return)\r\n{\r\nint ret = 0;\r\nunsigned long param;\r\nif (strcmp(arg, "retval") == 0) {\r\nif (is_return)\r\nf->fn = t->fetch[FETCH_MTD_retval];\r\nelse\r\nret = -EINVAL;\r\n} else if (strncmp(arg, "stack", 5) == 0) {\r\nif (arg[5] == '\0') {\r\nif (strcmp(t->name, DEFAULT_FETCH_TYPE_STR) == 0)\r\nf->fn = fetch_stack_address;\r\nelse\r\nret = -EINVAL;\r\n} else if (isdigit(arg[5])) {\r\nret = kstrtoul(arg + 5, 10, &param);\r\nif (ret || param > PARAM_MAX_STACK)\r\nret = -EINVAL;\r\nelse {\r\nf->fn = t->fetch[FETCH_MTD_stack];\r\nf->data = (void *)param;\r\n}\r\n} else\r\nret = -EINVAL;\r\n} else\r\nret = -EINVAL;\r\nreturn ret;\r\n}\r\nstatic int parse_probe_arg(char *arg, const struct fetch_type *t,\r\nstruct fetch_param *f, bool is_return, bool is_kprobe)\r\n{\r\nunsigned long param;\r\nlong offset;\r\nchar *tmp;\r\nint ret;\r\nret = 0;\r\nif (!is_kprobe && arg[0] != '%')\r\nreturn -EINVAL;\r\nswitch (arg[0]) {\r\ncase '$':\r\nret = parse_probe_vars(arg + 1, t, f, is_return);\r\nbreak;\r\ncase '%':\r\nret = regs_query_register_offset(arg + 1);\r\nif (ret >= 0) {\r\nf->fn = t->fetch[FETCH_MTD_reg];\r\nf->data = (void *)(unsigned long)ret;\r\nret = 0;\r\n}\r\nbreak;\r\ncase '@':\r\nif (isdigit(arg[1])) {\r\nret = kstrtoul(arg + 1, 0, &param);\r\nif (ret)\r\nbreak;\r\nf->fn = t->fetch[FETCH_MTD_memory];\r\nf->data = (void *)param;\r\n} else {\r\nret = traceprobe_split_symbol_offset(arg + 1, &offset);\r\nif (ret)\r\nbreak;\r\nf->data = alloc_symbol_cache(arg + 1, offset);\r\nif (f->data)\r\nf->fn = t->fetch[FETCH_MTD_symbol];\r\n}\r\nbreak;\r\ncase '+':\r\narg++;\r\ncase '-':\r\ntmp = strchr(arg, '(');\r\nif (!tmp)\r\nbreak;\r\n*tmp = '\0';\r\nret = kstrtol(arg, 0, &offset);\r\nif (ret)\r\nbreak;\r\narg = tmp + 1;\r\ntmp = strrchr(arg, ')');\r\nif (tmp) {\r\nstruct deref_fetch_param *dprm;\r\nconst struct fetch_type *t2;\r\nt2 = find_fetch_type(NULL);\r\n*tmp = '\0';\r\ndprm = kzalloc(sizeof(struct deref_fetch_param), GFP_KERNEL);\r\nif (!dprm)\r\nreturn -ENOMEM;\r\ndprm->offset = offset;\r\nret = parse_probe_arg(arg, t2, &dprm->orig, is_return,\r\nis_kprobe);\r\nif (ret)\r\nkfree(dprm);\r\nelse {\r\nf->fn = t->fetch[FETCH_MTD_deref];\r\nf->data = (void *)dprm;\r\n}\r\n}\r\nbreak;\r\n}\r\nif (!ret && !f->fn) {\r\npr_info("%s type has no corresponding fetch method.\n", t->name);\r\nret = -EINVAL;\r\n}\r\nreturn ret;\r\n}\r\nstatic int __parse_bitfield_probe_arg(const char *bf,\r\nconst struct fetch_type *t,\r\nstruct fetch_param *f)\r\n{\r\nstruct bitfield_fetch_param *bprm;\r\nunsigned long bw, bo;\r\nchar *tail;\r\nif (*bf != 'b')\r\nreturn 0;\r\nbprm = kzalloc(sizeof(*bprm), GFP_KERNEL);\r\nif (!bprm)\r\nreturn -ENOMEM;\r\nbprm->orig = *f;\r\nf->fn = t->fetch[FETCH_MTD_bitfield];\r\nf->data = (void *)bprm;\r\nbw = simple_strtoul(bf + 1, &tail, 0);\r\nif (bw == 0 || *tail != '@')\r\nreturn -EINVAL;\r\nbf = tail + 1;\r\nbo = simple_strtoul(bf, &tail, 0);\r\nif (tail == bf || *tail != '/')\r\nreturn -EINVAL;\r\nbprm->hi_shift = BYTES_TO_BITS(t->size) - (bw + bo);\r\nbprm->low_shift = bprm->hi_shift + bo;\r\nreturn (BYTES_TO_BITS(t->size) < (bw + bo)) ? -EINVAL : 0;\r\n}\r\nint traceprobe_parse_probe_arg(char *arg, ssize_t *size,\r\nstruct probe_arg *parg, bool is_return, bool is_kprobe)\r\n{\r\nconst char *t;\r\nint ret;\r\nif (strlen(arg) > MAX_ARGSTR_LEN) {\r\npr_info("Argument is too long.: %s\n", arg);\r\nreturn -ENOSPC;\r\n}\r\nparg->comm = kstrdup(arg, GFP_KERNEL);\r\nif (!parg->comm) {\r\npr_info("Failed to allocate memory for command '%s'.\n", arg);\r\nreturn -ENOMEM;\r\n}\r\nt = strchr(parg->comm, ':');\r\nif (t) {\r\narg[t - parg->comm] = '\0';\r\nt++;\r\n}\r\nparg->type = find_fetch_type(t);\r\nif (!parg->type) {\r\npr_info("Unsupported type: %s\n", t);\r\nreturn -EINVAL;\r\n}\r\nparg->offset = *size;\r\n*size += parg->type->size;\r\nret = parse_probe_arg(arg, parg->type, &parg->fetch, is_return, is_kprobe);\r\nif (ret >= 0 && t != NULL)\r\nret = __parse_bitfield_probe_arg(t, parg->type, &parg->fetch);\r\nif (ret >= 0) {\r\nparg->fetch_size.fn = get_fetch_size_function(parg->type,\r\nparg->fetch.fn);\r\nparg->fetch_size.data = parg->fetch.data;\r\n}\r\nreturn ret;\r\n}\r\nint traceprobe_conflict_field_name(const char *name,\r\nstruct probe_arg *args, int narg)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(reserved_field_names); i++)\r\nif (strcmp(reserved_field_names[i], name) == 0)\r\nreturn 1;\r\nfor (i = 0; i < narg; i++)\r\nif (strcmp(args[i].name, name) == 0)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nvoid traceprobe_update_arg(struct probe_arg *arg)\r\n{\r\nif (CHECK_FETCH_FUNCS(bitfield, arg->fetch.fn))\r\nupdate_bitfield_fetch_param(arg->fetch.data);\r\nelse if (CHECK_FETCH_FUNCS(deref, arg->fetch.fn))\r\nupdate_deref_fetch_param(arg->fetch.data);\r\nelse if (CHECK_FETCH_FUNCS(symbol, arg->fetch.fn))\r\nupdate_symbol_cache(arg->fetch.data);\r\n}\r\nvoid traceprobe_free_probe_arg(struct probe_arg *arg)\r\n{\r\nif (CHECK_FETCH_FUNCS(bitfield, arg->fetch.fn))\r\nfree_bitfield_fetch_param(arg->fetch.data);\r\nelse if (CHECK_FETCH_FUNCS(deref, arg->fetch.fn))\r\nfree_deref_fetch_param(arg->fetch.data);\r\nelse if (CHECK_FETCH_FUNCS(symbol, arg->fetch.fn))\r\nfree_symbol_cache(arg->fetch.data);\r\nkfree(arg->name);\r\nkfree(arg->comm);\r\n}\r\nint traceprobe_command(const char *buf, int (*createfn)(int, char **))\r\n{\r\nchar **argv;\r\nint argc, ret;\r\nargc = 0;\r\nret = 0;\r\nargv = argv_split(GFP_KERNEL, buf, &argc);\r\nif (!argv)\r\nreturn -ENOMEM;\r\nif (argc)\r\nret = createfn(argc, argv);\r\nargv_free(argv);\r\nreturn ret;\r\n}\r\nssize_t traceprobe_probes_write(struct file *file, const char __user *buffer,\r\nsize_t count, loff_t *ppos,\r\nint (*createfn)(int, char **))\r\n{\r\nchar *kbuf, *tmp;\r\nint ret = 0;\r\nsize_t done = 0;\r\nsize_t size;\r\nkbuf = kmalloc(WRITE_BUFSIZE, GFP_KERNEL);\r\nif (!kbuf)\r\nreturn -ENOMEM;\r\nwhile (done < count) {\r\nsize = count - done;\r\nif (size >= WRITE_BUFSIZE)\r\nsize = WRITE_BUFSIZE - 1;\r\nif (copy_from_user(kbuf, buffer + done, size)) {\r\nret = -EFAULT;\r\ngoto out;\r\n}\r\nkbuf[size] = '\0';\r\ntmp = strchr(kbuf, '\n');\r\nif (tmp) {\r\n*tmp = '\0';\r\nsize = tmp - kbuf + 1;\r\n} else if (done + size < count) {\r\npr_warning("Line length is too long: "\r\n"Should be less than %d.", WRITE_BUFSIZE);\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\ndone += size;\r\ntmp = strchr(kbuf, '#');\r\nif (tmp)\r\n*tmp = '\0';\r\nret = traceprobe_command(kbuf, createfn);\r\nif (ret)\r\ngoto out;\r\n}\r\nret = done;\r\nout:\r\nkfree(kbuf);\r\nreturn ret;\r\n}
