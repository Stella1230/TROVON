static const struct clksel *_get_clksel_by_parent(struct clk_hw_omap *clk,\r\nstruct clk *src_clk)\r\n{\r\nconst struct clksel *clks;\r\nif (!src_clk)\r\nreturn NULL;\r\nfor (clks = clk->clksel; clks->parent; clks++)\r\nif (clks->parent == src_clk)\r\nbreak;\r\nif (!clks->parent) {\r\nWARN(1, "clock: %s: could not find parent clock %s in clksel array\n",\r\n__clk_get_name(clk->hw.clk), __clk_get_name(src_clk));\r\nreturn NULL;\r\n}\r\nreturn clks;\r\n}\r\nstatic void _write_clksel_reg(struct clk_hw_omap *clk, u32 field_val)\r\n{\r\nu32 v;\r\nv = __raw_readl(clk->clksel_reg);\r\nv &= ~clk->clksel_mask;\r\nv |= field_val << __ffs(clk->clksel_mask);\r\n__raw_writel(v, clk->clksel_reg);\r\nv = __raw_readl(clk->clksel_reg);\r\n}\r\nstatic u32 _clksel_to_divisor(struct clk_hw_omap *clk, u32 field_val)\r\n{\r\nconst struct clksel *clks;\r\nconst struct clksel_rate *clkr;\r\nstruct clk *parent;\r\nparent = __clk_get_parent(clk->hw.clk);\r\nclks = _get_clksel_by_parent(clk, parent);\r\nif (!clks)\r\nreturn 0;\r\nfor (clkr = clks->rates; clkr->div; clkr++) {\r\nif (!(clkr->flags & cpu_mask))\r\ncontinue;\r\nif (clkr->val == field_val)\r\nbreak;\r\n}\r\nif (!clkr->div) {\r\nWARN(1, "clock: %s: could not find fieldval %d for parent %s\n",\r\n__clk_get_name(clk->hw.clk), field_val,\r\n__clk_get_name(parent));\r\nreturn 0;\r\n}\r\nreturn clkr->div;\r\n}\r\nstatic u32 _divisor_to_clksel(struct clk_hw_omap *clk, u32 div)\r\n{\r\nconst struct clksel *clks;\r\nconst struct clksel_rate *clkr;\r\nstruct clk *parent;\r\nWARN_ON(div == 0);\r\nparent = __clk_get_parent(clk->hw.clk);\r\nclks = _get_clksel_by_parent(clk, parent);\r\nif (!clks)\r\nreturn ~0;\r\nfor (clkr = clks->rates; clkr->div; clkr++) {\r\nif (!(clkr->flags & cpu_mask))\r\ncontinue;\r\nif (clkr->div == div)\r\nbreak;\r\n}\r\nif (!clkr->div) {\r\npr_err("clock: %s: could not find divisor %d for parent %s\n",\r\n__clk_get_name(clk->hw.clk), div,\r\n__clk_get_name(parent));\r\nreturn ~0;\r\n}\r\nreturn clkr->val;\r\n}\r\nstatic u32 _read_divisor(struct clk_hw_omap *clk)\r\n{\r\nu32 v;\r\nif (!clk->clksel || !clk->clksel_mask)\r\nreturn 0;\r\nv = __raw_readl(clk->clksel_reg);\r\nv &= clk->clksel_mask;\r\nv >>= __ffs(clk->clksel_mask);\r\nreturn _clksel_to_divisor(clk, v);\r\n}\r\nu32 omap2_clksel_round_rate_div(struct clk_hw_omap *clk,\r\nunsigned long target_rate,\r\nu32 *new_div)\r\n{\r\nunsigned long test_rate;\r\nconst struct clksel *clks;\r\nconst struct clksel_rate *clkr;\r\nu32 last_div = 0;\r\nstruct clk *parent;\r\nunsigned long parent_rate;\r\nconst char *clk_name;\r\nparent = __clk_get_parent(clk->hw.clk);\r\nclk_name = __clk_get_name(clk->hw.clk);\r\nparent_rate = __clk_get_rate(parent);\r\nif (!clk->clksel || !clk->clksel_mask)\r\nreturn ~0;\r\npr_debug("clock: clksel_round_rate_div: %s target_rate %ld\n",\r\nclk_name, target_rate);\r\n*new_div = 1;\r\nclks = _get_clksel_by_parent(clk, parent);\r\nif (!clks)\r\nreturn ~0;\r\nfor (clkr = clks->rates; clkr->div; clkr++) {\r\nif (!(clkr->flags & cpu_mask))\r\ncontinue;\r\nif (clkr->div <= last_div)\r\npr_err("clock: %s: clksel_rate table not sorted\n",\r\nclk_name);\r\nlast_div = clkr->div;\r\ntest_rate = parent_rate / clkr->div;\r\nif (test_rate <= target_rate)\r\nbreak;\r\n}\r\nif (!clkr->div) {\r\npr_err("clock: %s: could not find divisor for target rate %ld for parent %s\n",\r\nclk_name, target_rate, __clk_get_name(parent));\r\nreturn ~0;\r\n}\r\n*new_div = clkr->div;\r\npr_debug("clock: new_div = %d, new_rate = %ld\n", *new_div,\r\n(parent_rate / clkr->div));\r\nreturn parent_rate / clkr->div;\r\n}\r\nu8 omap2_clksel_find_parent_index(struct clk_hw *hw)\r\n{\r\nstruct clk_hw_omap *clk = to_clk_hw_omap(hw);\r\nconst struct clksel *clks;\r\nconst struct clksel_rate *clkr;\r\nu32 r, found = 0;\r\nstruct clk *parent;\r\nconst char *clk_name;\r\nint ret = 0, f = 0;\r\nparent = __clk_get_parent(hw->clk);\r\nclk_name = __clk_get_name(hw->clk);\r\nWARN((!clk->clksel || !clk->clksel_mask),\r\n"clock: %s: attempt to call on a non-clksel clock", clk_name);\r\nr = __raw_readl(clk->clksel_reg) & clk->clksel_mask;\r\nr >>= __ffs(clk->clksel_mask);\r\nfor (clks = clk->clksel; clks->parent && !found; clks++) {\r\nfor (clkr = clks->rates; clkr->div && !found; clkr++) {\r\nif (!(clkr->flags & cpu_mask))\r\ncontinue;\r\nif (clkr->val == r) {\r\nfound = 1;\r\nret = f;\r\n}\r\n}\r\nf++;\r\n}\r\nWARN(!found, "clock: %s: init parent: could not find regval %0x\n",\r\nclk_name, r);\r\nreturn ret;\r\n}\r\nunsigned long omap2_clksel_recalc(struct clk_hw *hw, unsigned long parent_rate)\r\n{\r\nunsigned long rate;\r\nu32 div = 0;\r\nstruct clk_hw_omap *clk = to_clk_hw_omap(hw);\r\nif (!parent_rate)\r\nreturn 0;\r\ndiv = _read_divisor(clk);\r\nif (!div)\r\nrate = parent_rate;\r\nelse\r\nrate = parent_rate / div;\r\npr_debug("%s: recalc'd %s's rate to %lu (div %d)\n", __func__,\r\n__clk_get_name(hw->clk), rate, div);\r\nreturn rate;\r\n}\r\nlong omap2_clksel_round_rate(struct clk_hw *hw, unsigned long target_rate,\r\nunsigned long *parent_rate)\r\n{\r\nstruct clk_hw_omap *clk = to_clk_hw_omap(hw);\r\nu32 new_div;\r\nreturn omap2_clksel_round_rate_div(clk, target_rate, &new_div);\r\n}\r\nint omap2_clksel_set_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long parent_rate)\r\n{\r\nstruct clk_hw_omap *clk = to_clk_hw_omap(hw);\r\nu32 field_val, validrate, new_div = 0;\r\nif (!clk->clksel || !clk->clksel_mask)\r\nreturn -EINVAL;\r\nvalidrate = omap2_clksel_round_rate_div(clk, rate, &new_div);\r\nif (validrate != rate)\r\nreturn -EINVAL;\r\nfield_val = _divisor_to_clksel(clk, new_div);\r\nif (field_val == ~0)\r\nreturn -EINVAL;\r\n_write_clksel_reg(clk, field_val);\r\npr_debug("clock: %s: set rate to %ld\n", __clk_get_name(hw->clk),\r\n__clk_get_rate(hw->clk));\r\nreturn 0;\r\n}\r\nint omap2_clksel_set_parent(struct clk_hw *hw, u8 field_val)\r\n{\r\nstruct clk_hw_omap *clk = to_clk_hw_omap(hw);\r\nif (!clk->clksel || !clk->clksel_mask)\r\nreturn -EINVAL;\r\n_write_clksel_reg(clk, field_val);\r\nreturn 0;\r\n}
