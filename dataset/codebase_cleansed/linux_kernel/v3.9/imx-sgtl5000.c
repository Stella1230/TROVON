static int imx_sgtl5000_dai_init(struct snd_soc_pcm_runtime *rtd)\r\n{\r\nstruct imx_sgtl5000_data *data = container_of(rtd->card,\r\nstruct imx_sgtl5000_data, card);\r\nstruct device *dev = rtd->card->dev;\r\nint ret;\r\nret = snd_soc_dai_set_sysclk(rtd->codec_dai, SGTL5000_SYSCLK,\r\ndata->clk_frequency, SND_SOC_CLOCK_IN);\r\nif (ret) {\r\ndev_err(dev, "could not set codec driver clock params\n");\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int imx_sgtl5000_probe(struct platform_device *pdev)\r\n{\r\nstruct device_node *np = pdev->dev.of_node;\r\nstruct device_node *ssi_np, *codec_np;\r\nstruct platform_device *ssi_pdev;\r\nstruct i2c_client *codec_dev;\r\nstruct imx_sgtl5000_data *data;\r\nint int_port, ext_port;\r\nint ret;\r\nret = of_property_read_u32(np, "mux-int-port", &int_port);\r\nif (ret) {\r\ndev_err(&pdev->dev, "mux-int-port missing or invalid\n");\r\nreturn ret;\r\n}\r\nret = of_property_read_u32(np, "mux-ext-port", &ext_port);\r\nif (ret) {\r\ndev_err(&pdev->dev, "mux-ext-port missing or invalid\n");\r\nreturn ret;\r\n}\r\nint_port--;\r\next_port--;\r\nret = imx_audmux_v2_configure_port(int_port,\r\nIMX_AUDMUX_V2_PTCR_SYN |\r\nIMX_AUDMUX_V2_PTCR_TFSEL(ext_port) |\r\nIMX_AUDMUX_V2_PTCR_TCSEL(ext_port) |\r\nIMX_AUDMUX_V2_PTCR_TFSDIR |\r\nIMX_AUDMUX_V2_PTCR_TCLKDIR,\r\nIMX_AUDMUX_V2_PDCR_RXDSEL(ext_port));\r\nif (ret) {\r\ndev_err(&pdev->dev, "audmux internal port setup failed\n");\r\nreturn ret;\r\n}\r\nret = imx_audmux_v2_configure_port(ext_port,\r\nIMX_AUDMUX_V2_PTCR_SYN,\r\nIMX_AUDMUX_V2_PDCR_RXDSEL(int_port));\r\nif (ret) {\r\ndev_err(&pdev->dev, "audmux external port setup failed\n");\r\nreturn ret;\r\n}\r\nssi_np = of_parse_phandle(pdev->dev.of_node, "ssi-controller", 0);\r\ncodec_np = of_parse_phandle(pdev->dev.of_node, "audio-codec", 0);\r\nif (!ssi_np || !codec_np) {\r\ndev_err(&pdev->dev, "phandle missing or invalid\n");\r\nret = -EINVAL;\r\ngoto fail;\r\n}\r\nssi_pdev = of_find_device_by_node(ssi_np);\r\nif (!ssi_pdev) {\r\ndev_err(&pdev->dev, "failed to find SSI platform device\n");\r\nret = -EINVAL;\r\ngoto fail;\r\n}\r\ncodec_dev = of_find_i2c_device_by_node(codec_np);\r\nif (!codec_dev) {\r\ndev_err(&pdev->dev, "failed to find codec platform device\n");\r\nreturn -EINVAL;\r\n}\r\ndata = devm_kzalloc(&pdev->dev, sizeof(*data), GFP_KERNEL);\r\nif (!data) {\r\nret = -ENOMEM;\r\ngoto fail;\r\n}\r\ndata->codec_clk = clk_get(&codec_dev->dev, NULL);\r\nif (IS_ERR(data->codec_clk)) {\r\ndata->codec_clk = NULL;\r\nret = of_property_read_u32(codec_np, "clock-frequency",\r\n&data->clk_frequency);\r\nif (ret) {\r\ndev_err(&codec_dev->dev,\r\n"clock-frequency missing or invalid\n");\r\ngoto fail;\r\n}\r\n} else {\r\ndata->clk_frequency = clk_get_rate(data->codec_clk);\r\nclk_prepare_enable(data->codec_clk);\r\n}\r\ndata->dai.name = "HiFi";\r\ndata->dai.stream_name = "HiFi";\r\ndata->dai.codec_dai_name = "sgtl5000";\r\ndata->dai.codec_of_node = codec_np;\r\ndata->dai.cpu_dai_name = dev_name(&ssi_pdev->dev);\r\ndata->dai.platform_name = "imx-pcm-audio";\r\ndata->dai.init = &imx_sgtl5000_dai_init;\r\ndata->dai.dai_fmt = SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_NB_NF |\r\nSND_SOC_DAIFMT_CBM_CFM;\r\ndata->card.dev = &pdev->dev;\r\nret = snd_soc_of_parse_card_name(&data->card, "model");\r\nif (ret)\r\ngoto clk_fail;\r\nret = snd_soc_of_parse_audio_routing(&data->card, "audio-routing");\r\nif (ret)\r\ngoto clk_fail;\r\ndata->card.num_links = 1;\r\ndata->card.owner = THIS_MODULE;\r\ndata->card.dai_link = &data->dai;\r\ndata->card.dapm_widgets = imx_sgtl5000_dapm_widgets;\r\ndata->card.num_dapm_widgets = ARRAY_SIZE(imx_sgtl5000_dapm_widgets);\r\nret = snd_soc_register_card(&data->card);\r\nif (ret) {\r\ndev_err(&pdev->dev, "snd_soc_register_card failed (%d)\n", ret);\r\ngoto clk_fail;\r\n}\r\nplatform_set_drvdata(pdev, data);\r\nclk_fail:\r\nclk_put(data->codec_clk);\r\nfail:\r\nif (ssi_np)\r\nof_node_put(ssi_np);\r\nif (codec_np)\r\nof_node_put(codec_np);\r\nreturn ret;\r\n}\r\nstatic int imx_sgtl5000_remove(struct platform_device *pdev)\r\n{\r\nstruct imx_sgtl5000_data *data = platform_get_drvdata(pdev);\r\nif (data->codec_clk) {\r\nclk_disable_unprepare(data->codec_clk);\r\nclk_put(data->codec_clk);\r\n}\r\nsnd_soc_unregister_card(&data->card);\r\nreturn 0;\r\n}
