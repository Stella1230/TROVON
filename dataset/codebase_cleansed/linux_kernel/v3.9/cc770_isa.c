static u8 cc770_isa_mem_read_reg(const struct cc770_priv *priv, int reg)\r\n{\r\nreturn readb(priv->reg_base + reg);\r\n}\r\nstatic void cc770_isa_mem_write_reg(const struct cc770_priv *priv,\r\nint reg, u8 val)\r\n{\r\nwriteb(val, priv->reg_base + reg);\r\n}\r\nstatic u8 cc770_isa_port_read_reg(const struct cc770_priv *priv, int reg)\r\n{\r\nreturn inb((unsigned long)priv->reg_base + reg);\r\n}\r\nstatic void cc770_isa_port_write_reg(const struct cc770_priv *priv,\r\nint reg, u8 val)\r\n{\r\noutb(val, (unsigned long)priv->reg_base + reg);\r\n}\r\nstatic u8 cc770_isa_port_read_reg_indirect(const struct cc770_priv *priv,\r\nint reg)\r\n{\r\nunsigned long base = (unsigned long)priv->reg_base;\r\nunsigned long flags;\r\nu8 val;\r\nspin_lock_irqsave(&cc770_isa_port_lock, flags);\r\noutb(reg, base);\r\nval = inb(base + 1);\r\nspin_unlock_irqrestore(&cc770_isa_port_lock, flags);\r\nreturn val;\r\n}\r\nstatic void cc770_isa_port_write_reg_indirect(const struct cc770_priv *priv,\r\nint reg, u8 val)\r\n{\r\nunsigned long base = (unsigned long)priv->reg_base;\r\nunsigned long flags;\r\nspin_lock_irqsave(&cc770_isa_port_lock, flags);\r\noutb(reg, base);\r\noutb(val, base + 1);\r\nspin_unlock_irqrestore(&cc770_isa_port_lock, flags);\r\n}\r\nstatic int cc770_isa_probe(struct platform_device *pdev)\r\n{\r\nstruct net_device *dev;\r\nstruct cc770_priv *priv;\r\nvoid __iomem *base = NULL;\r\nint iosize = CC770_IOSIZE;\r\nint idx = pdev->id;\r\nint err;\r\nu32 clktmp;\r\ndev_dbg(&pdev->dev, "probing idx=%d: port=%#lx, mem=%#lx, irq=%d\n",\r\nidx, port[idx], mem[idx], irq[idx]);\r\nif (mem[idx]) {\r\nif (!request_mem_region(mem[idx], iosize, KBUILD_MODNAME)) {\r\nerr = -EBUSY;\r\ngoto exit;\r\n}\r\nbase = ioremap_nocache(mem[idx], iosize);\r\nif (!base) {\r\nerr = -ENOMEM;\r\ngoto exit_release;\r\n}\r\n} else {\r\nif (indirect[idx] > 0 ||\r\n(indirect[idx] == -1 && indirect[0] > 0))\r\niosize = CC770_IOSIZE_INDIRECT;\r\nif (!request_region(port[idx], iosize, KBUILD_MODNAME)) {\r\nerr = -EBUSY;\r\ngoto exit;\r\n}\r\n}\r\ndev = alloc_cc770dev(0);\r\nif (!dev) {\r\nerr = -ENOMEM;\r\ngoto exit_unmap;\r\n}\r\npriv = netdev_priv(dev);\r\ndev->irq = irq[idx];\r\npriv->irq_flags = IRQF_SHARED;\r\nif (mem[idx]) {\r\npriv->reg_base = base;\r\ndev->base_addr = mem[idx];\r\npriv->read_reg = cc770_isa_mem_read_reg;\r\npriv->write_reg = cc770_isa_mem_write_reg;\r\n} else {\r\npriv->reg_base = (void __iomem *)port[idx];\r\ndev->base_addr = port[idx];\r\nif (iosize == CC770_IOSIZE_INDIRECT) {\r\npriv->read_reg = cc770_isa_port_read_reg_indirect;\r\npriv->write_reg = cc770_isa_port_write_reg_indirect;\r\n} else {\r\npriv->read_reg = cc770_isa_port_read_reg;\r\npriv->write_reg = cc770_isa_port_write_reg;\r\n}\r\n}\r\nif (clk[idx])\r\nclktmp = clk[idx];\r\nelse if (clk[0])\r\nclktmp = clk[0];\r\nelse\r\nclktmp = CLK_DEFAULT;\r\npriv->can.clock.freq = clktmp;\r\nif (cir[idx] != 0xff) {\r\npriv->cpu_interface = cir[idx];\r\n} else if (cir[0] != 0xff) {\r\npriv->cpu_interface = cir[0];\r\n} else {\r\nif (clktmp > 10000000) {\r\npriv->cpu_interface |= CPUIF_DSC;\r\nclktmp /= 2;\r\n}\r\nif (clktmp > 8000000)\r\npriv->cpu_interface |= CPUIF_DMC;\r\n}\r\nif (priv->cpu_interface & CPUIF_DSC)\r\npriv->can.clock.freq /= 2;\r\nif (bcr[idx] != 0xff)\r\npriv->bus_config = bcr[idx];\r\nelse if (bcr[0] != 0xff)\r\npriv->bus_config = bcr[0];\r\nelse\r\npriv->bus_config = BCR_DEFAULT;\r\nif (cor[idx] != 0xff)\r\npriv->clkout = cor[idx];\r\nelse if (cor[0] != 0xff)\r\npriv->clkout = cor[0];\r\nelse\r\npriv->clkout = COR_DEFAULT;\r\ndev_set_drvdata(&pdev->dev, dev);\r\nSET_NETDEV_DEV(dev, &pdev->dev);\r\nerr = register_cc770dev(dev);\r\nif (err) {\r\ndev_err(&pdev->dev,\r\n"couldn't register device (err=%d)\n", err);\r\ngoto exit_unmap;\r\n}\r\ndev_info(&pdev->dev, "device registered (reg_base=0x%p, irq=%d)\n",\r\npriv->reg_base, dev->irq);\r\nreturn 0;\r\nexit_unmap:\r\nif (mem[idx])\r\niounmap(base);\r\nexit_release:\r\nif (mem[idx])\r\nrelease_mem_region(mem[idx], iosize);\r\nelse\r\nrelease_region(port[idx], iosize);\r\nexit:\r\nreturn err;\r\n}\r\nstatic int cc770_isa_remove(struct platform_device *pdev)\r\n{\r\nstruct net_device *dev = dev_get_drvdata(&pdev->dev);\r\nstruct cc770_priv *priv = netdev_priv(dev);\r\nint idx = pdev->id;\r\nunregister_cc770dev(dev);\r\ndev_set_drvdata(&pdev->dev, NULL);\r\nif (mem[idx]) {\r\niounmap(priv->reg_base);\r\nrelease_mem_region(mem[idx], CC770_IOSIZE);\r\n} else {\r\nif (priv->read_reg == cc770_isa_port_read_reg_indirect)\r\nrelease_region(port[idx], CC770_IOSIZE_INDIRECT);\r\nelse\r\nrelease_region(port[idx], CC770_IOSIZE);\r\n}\r\nfree_cc770dev(dev);\r\nreturn 0;\r\n}\r\nstatic int __init cc770_isa_init(void)\r\n{\r\nint idx, err;\r\nfor (idx = 0; idx < ARRAY_SIZE(cc770_isa_devs); idx++) {\r\nif ((port[idx] || mem[idx]) && irq[idx]) {\r\ncc770_isa_devs[idx] =\r\nplatform_device_alloc(KBUILD_MODNAME, idx);\r\nif (!cc770_isa_devs[idx]) {\r\nerr = -ENOMEM;\r\ngoto exit_free_devices;\r\n}\r\nerr = platform_device_add(cc770_isa_devs[idx]);\r\nif (err) {\r\nplatform_device_put(cc770_isa_devs[idx]);\r\ngoto exit_free_devices;\r\n}\r\npr_debug("platform device %d: port=%#lx, mem=%#lx, "\r\n"irq=%d\n",\r\nidx, port[idx], mem[idx], irq[idx]);\r\n} else if (idx == 0 || port[idx] || mem[idx]) {\r\npr_err("insufficient parameters supplied\n");\r\nerr = -EINVAL;\r\ngoto exit_free_devices;\r\n}\r\n}\r\nerr = platform_driver_register(&cc770_isa_driver);\r\nif (err)\r\ngoto exit_free_devices;\r\npr_info("driver for max. %d devices registered\n", MAXDEV);\r\nreturn 0;\r\nexit_free_devices:\r\nwhile (--idx >= 0) {\r\nif (cc770_isa_devs[idx])\r\nplatform_device_unregister(cc770_isa_devs[idx]);\r\n}\r\nreturn err;\r\n}\r\nstatic void __exit cc770_isa_exit(void)\r\n{\r\nint idx;\r\nplatform_driver_unregister(&cc770_isa_driver);\r\nfor (idx = 0; idx < ARRAY_SIZE(cc770_isa_devs); idx++) {\r\nif (cc770_isa_devs[idx])\r\nplatform_device_unregister(cc770_isa_devs[idx]);\r\n}\r\n}
