static ssize_t pSeries_nvram_read(char *buf, size_t count, loff_t *index)\r\n{\r\nunsigned int i;\r\nunsigned long len;\r\nint done;\r\nunsigned long flags;\r\nchar *p = buf;\r\nif (nvram_size == 0 || nvram_fetch == RTAS_UNKNOWN_SERVICE)\r\nreturn -ENODEV;\r\nif (*index >= nvram_size)\r\nreturn 0;\r\ni = *index;\r\nif (i + count > nvram_size)\r\ncount = nvram_size - i;\r\nspin_lock_irqsave(&nvram_lock, flags);\r\nfor (; count != 0; count -= len) {\r\nlen = count;\r\nif (len > NVRW_CNT)\r\nlen = NVRW_CNT;\r\nif ((rtas_call(nvram_fetch, 3, 2, &done, i, __pa(nvram_buf),\r\nlen) != 0) || len != done) {\r\nspin_unlock_irqrestore(&nvram_lock, flags);\r\nreturn -EIO;\r\n}\r\nmemcpy(p, nvram_buf, len);\r\np += len;\r\ni += len;\r\n}\r\nspin_unlock_irqrestore(&nvram_lock, flags);\r\n*index = i;\r\nreturn p - buf;\r\n}\r\nstatic ssize_t pSeries_nvram_write(char *buf, size_t count, loff_t *index)\r\n{\r\nunsigned int i;\r\nunsigned long len;\r\nint done;\r\nunsigned long flags;\r\nconst char *p = buf;\r\nif (nvram_size == 0 || nvram_store == RTAS_UNKNOWN_SERVICE)\r\nreturn -ENODEV;\r\nif (*index >= nvram_size)\r\nreturn 0;\r\ni = *index;\r\nif (i + count > nvram_size)\r\ncount = nvram_size - i;\r\nspin_lock_irqsave(&nvram_lock, flags);\r\nfor (; count != 0; count -= len) {\r\nlen = count;\r\nif (len > NVRW_CNT)\r\nlen = NVRW_CNT;\r\nmemcpy(nvram_buf, p, len);\r\nif ((rtas_call(nvram_store, 3, 2, &done, i, __pa(nvram_buf),\r\nlen) != 0) || len != done) {\r\nspin_unlock_irqrestore(&nvram_lock, flags);\r\nreturn -EIO;\r\n}\r\np += len;\r\ni += len;\r\n}\r\nspin_unlock_irqrestore(&nvram_lock, flags);\r\n*index = i;\r\nreturn p - buf;\r\n}\r\nstatic ssize_t pSeries_nvram_get_size(void)\r\n{\r\nreturn nvram_size ? nvram_size : -ENODEV;\r\n}\r\nint nvram_write_os_partition(struct nvram_os_partition *part, char * buff,\r\nint length, unsigned int err_type, unsigned int error_log_cnt)\r\n{\r\nint rc;\r\nloff_t tmp_index;\r\nstruct err_log_info info;\r\nif (part->index == -1) {\r\nreturn -ESPIPE;\r\n}\r\nif (length > part->size) {\r\nlength = part->size;\r\n}\r\ninfo.error_type = err_type;\r\ninfo.seq_num = error_log_cnt;\r\ntmp_index = part->index;\r\nrc = ppc_md.nvram_write((char *)&info, sizeof(struct err_log_info), &tmp_index);\r\nif (rc <= 0) {\r\npr_err("%s: Failed nvram_write (%d)\n", __FUNCTION__, rc);\r\nreturn rc;\r\n}\r\nrc = ppc_md.nvram_write(buff, length, &tmp_index);\r\nif (rc <= 0) {\r\npr_err("%s: Failed nvram_write (%d)\n", __FUNCTION__, rc);\r\nreturn rc;\r\n}\r\nreturn 0;\r\n}\r\nint nvram_write_error_log(char * buff, int length,\r\nunsigned int err_type, unsigned int error_log_cnt)\r\n{\r\nint rc = nvram_write_os_partition(&rtas_log_partition, buff, length,\r\nerr_type, error_log_cnt);\r\nif (!rc)\r\nlast_unread_rtas_event = get_seconds();\r\nreturn rc;\r\n}\r\nint nvram_read_error_log(char * buff, int length,\r\nunsigned int * err_type, unsigned int * error_log_cnt)\r\n{\r\nint rc;\r\nloff_t tmp_index;\r\nstruct err_log_info info;\r\nif (rtas_log_partition.index == -1)\r\nreturn -1;\r\nif (length > rtas_log_partition.size)\r\nlength = rtas_log_partition.size;\r\ntmp_index = rtas_log_partition.index;\r\nrc = ppc_md.nvram_read((char *)&info, sizeof(struct err_log_info), &tmp_index);\r\nif (rc <= 0) {\r\nprintk(KERN_ERR "nvram_read_error_log: Failed nvram_read (%d)\n", rc);\r\nreturn rc;\r\n}\r\nrc = ppc_md.nvram_read(buff, length, &tmp_index);\r\nif (rc <= 0) {\r\nprintk(KERN_ERR "nvram_read_error_log: Failed nvram_read (%d)\n", rc);\r\nreturn rc;\r\n}\r\n*error_log_cnt = info.seq_num;\r\n*err_type = info.error_type;\r\nreturn 0;\r\n}\r\nint nvram_clear_error_log(void)\r\n{\r\nloff_t tmp_index;\r\nint clear_word = ERR_FLAG_ALREADY_LOGGED;\r\nint rc;\r\nif (rtas_log_partition.index == -1)\r\nreturn -1;\r\ntmp_index = rtas_log_partition.index;\r\nrc = ppc_md.nvram_write((char *)&clear_word, sizeof(int), &tmp_index);\r\nif (rc <= 0) {\r\nprintk(KERN_ERR "nvram_clear_error_log: Failed nvram_write (%d)\n", rc);\r\nreturn rc;\r\n}\r\nlast_unread_rtas_event = 0;\r\nreturn 0;\r\n}\r\nstatic int __init pseries_nvram_init_os_partition(struct nvram_os_partition\r\n*part)\r\n{\r\nloff_t p;\r\nint size;\r\nnvram_scan_partitions();\r\np = nvram_find_partition(part->name, NVRAM_SIG_OS, &size);\r\nif (p && size < part->min_size) {\r\npr_info("nvram: Found too small %s partition,"\r\n" removing it...\n", part->name);\r\nnvram_remove_partition(part->name, NVRAM_SIG_OS, NULL);\r\np = 0;\r\n}\r\nif (!p) {\r\np = nvram_create_partition(part->name, NVRAM_SIG_OS,\r\npart->req_size, part->min_size);\r\nif (p == -ENOSPC) {\r\npr_info("nvram: No room to create %s partition, "\r\n"deleting any obsolete OS partitions...\n",\r\npart->name);\r\nnvram_remove_partition(NULL, NVRAM_SIG_OS,\r\npseries_nvram_os_partitions);\r\np = nvram_create_partition(part->name, NVRAM_SIG_OS,\r\npart->req_size, part->min_size);\r\n}\r\n}\r\nif (p <= 0) {\r\npr_err("nvram: Failed to find or create %s"\r\n" partition, err %d\n", part->name, (int)p);\r\nreturn -1;\r\n}\r\npart->index = p;\r\npart->size = nvram_get_partition_size(p) - sizeof(struct err_log_info);\r\nreturn 0;\r\n}\r\nstatic void __init nvram_init_oops_partition(int rtas_partition_exists)\r\n{\r\nint rc;\r\nrc = pseries_nvram_init_os_partition(&oops_log_partition);\r\nif (rc != 0) {\r\nif (!rtas_partition_exists)\r\nreturn;\r\npr_notice("nvram: Using %s partition to log both"\r\n" RTAS errors and oops/panic reports\n",\r\nrtas_log_partition.name);\r\nmemcpy(&oops_log_partition, &rtas_log_partition,\r\nsizeof(rtas_log_partition));\r\n}\r\noops_buf = kmalloc(oops_log_partition.size, GFP_KERNEL);\r\nif (!oops_buf) {\r\npr_err("nvram: No memory for %s partition\n",\r\noops_log_partition.name);\r\nreturn;\r\n}\r\noops_len = (u16*) oops_buf;\r\noops_data = oops_buf + sizeof(u16);\r\noops_data_sz = oops_log_partition.size - sizeof(u16);\r\nbig_oops_buf_sz = (oops_data_sz * 100) / 45;\r\nbig_oops_buf = kmalloc(big_oops_buf_sz, GFP_KERNEL);\r\nif (big_oops_buf) {\r\nstream.workspace = kmalloc(zlib_deflate_workspacesize(\r\nWINDOW_BITS, MEM_LEVEL), GFP_KERNEL);\r\nif (!stream.workspace) {\r\npr_err("nvram: No memory for compression workspace; "\r\n"skipping compression of %s partition data\n",\r\noops_log_partition.name);\r\nkfree(big_oops_buf);\r\nbig_oops_buf = NULL;\r\n}\r\n} else {\r\npr_err("No memory for uncompressed %s data; "\r\n"skipping compression\n", oops_log_partition.name);\r\nstream.workspace = NULL;\r\n}\r\nrc = kmsg_dump_register(&nvram_kmsg_dumper);\r\nif (rc != 0) {\r\npr_err("nvram: kmsg_dump_register() failed; returned %d\n", rc);\r\nkfree(oops_buf);\r\nkfree(big_oops_buf);\r\nkfree(stream.workspace);\r\n}\r\n}\r\nstatic int __init pseries_nvram_init_log_partitions(void)\r\n{\r\nint rc;\r\nrc = pseries_nvram_init_os_partition(&rtas_log_partition);\r\nnvram_init_oops_partition(rc == 0);\r\nreturn 0;\r\n}\r\nint __init pSeries_nvram_init(void)\r\n{\r\nstruct device_node *nvram;\r\nconst unsigned int *nbytes_p;\r\nunsigned int proplen;\r\nnvram = of_find_node_by_type(NULL, "nvram");\r\nif (nvram == NULL)\r\nreturn -ENODEV;\r\nnbytes_p = of_get_property(nvram, "#bytes", &proplen);\r\nif (nbytes_p == NULL || proplen != sizeof(unsigned int)) {\r\nof_node_put(nvram);\r\nreturn -EIO;\r\n}\r\nnvram_size = *nbytes_p;\r\nnvram_fetch = rtas_token("nvram-fetch");\r\nnvram_store = rtas_token("nvram-store");\r\nprintk(KERN_INFO "PPC64 nvram contains %d bytes\n", nvram_size);\r\nof_node_put(nvram);\r\nppc_md.nvram_read = pSeries_nvram_read;\r\nppc_md.nvram_write = pSeries_nvram_write;\r\nppc_md.nvram_size = pSeries_nvram_get_size;\r\nreturn 0;\r\n}\r\nstatic int clobbering_unread_rtas_event(void)\r\n{\r\nreturn (oops_log_partition.index == rtas_log_partition.index\r\n&& last_unread_rtas_event\r\n&& get_seconds() - last_unread_rtas_event <=\r\nNVRAM_RTAS_READ_TIMEOUT);\r\n}\r\nstatic int nvram_compress(const void *in, void *out, size_t inlen,\r\nsize_t outlen)\r\n{\r\nint err, ret;\r\nret = -EIO;\r\nerr = zlib_deflateInit2(&stream, COMPR_LEVEL, Z_DEFLATED, WINDOW_BITS,\r\nMEM_LEVEL, Z_DEFAULT_STRATEGY);\r\nif (err != Z_OK)\r\ngoto error;\r\nstream.next_in = in;\r\nstream.avail_in = inlen;\r\nstream.total_in = 0;\r\nstream.next_out = out;\r\nstream.avail_out = outlen;\r\nstream.total_out = 0;\r\nerr = zlib_deflate(&stream, Z_FINISH);\r\nif (err != Z_STREAM_END)\r\ngoto error;\r\nerr = zlib_deflateEnd(&stream);\r\nif (err != Z_OK)\r\ngoto error;\r\nif (stream.total_out >= stream.total_in)\r\ngoto error;\r\nret = stream.total_out;\r\nerror:\r\nreturn ret;\r\n}\r\nstatic int zip_oops(size_t text_len)\r\n{\r\nint zipped_len = nvram_compress(big_oops_buf, oops_data, text_len,\r\noops_data_sz);\r\nif (zipped_len < 0) {\r\npr_err("nvram: compression failed; returned %d\n", zipped_len);\r\npr_err("nvram: logging uncompressed oops/panic report\n");\r\nreturn -1;\r\n}\r\n*oops_len = (u16) zipped_len;\r\nreturn 0;\r\n}\r\nstatic void oops_to_nvram(struct kmsg_dumper *dumper,\r\nenum kmsg_dump_reason reason)\r\n{\r\nstatic unsigned int oops_count = 0;\r\nstatic bool panicking = false;\r\nstatic DEFINE_SPINLOCK(lock);\r\nunsigned long flags;\r\nsize_t text_len;\r\nunsigned int err_type = ERR_TYPE_KERNEL_PANIC_GZ;\r\nint rc = -1;\r\nswitch (reason) {\r\ncase KMSG_DUMP_RESTART:\r\ncase KMSG_DUMP_HALT:\r\ncase KMSG_DUMP_POWEROFF:\r\nreturn;\r\ncase KMSG_DUMP_OOPS:\r\nbreak;\r\ncase KMSG_DUMP_PANIC:\r\npanicking = true;\r\nbreak;\r\ncase KMSG_DUMP_EMERG:\r\nif (panicking)\r\nreturn;\r\nbreak;\r\ndefault:\r\npr_err("%s: ignoring unrecognized KMSG_DUMP_* reason %d\n",\r\n__FUNCTION__, (int) reason);\r\nreturn;\r\n}\r\nif (clobbering_unread_rtas_event())\r\nreturn;\r\nif (!spin_trylock_irqsave(&lock, flags))\r\nreturn;\r\nif (big_oops_buf) {\r\nkmsg_dump_get_buffer(dumper, false,\r\nbig_oops_buf, big_oops_buf_sz, &text_len);\r\nrc = zip_oops(text_len);\r\n}\r\nif (rc != 0) {\r\nkmsg_dump_rewind(dumper);\r\nkmsg_dump_get_buffer(dumper, true,\r\noops_data, oops_data_sz, &text_len);\r\nerr_type = ERR_TYPE_KERNEL_PANIC;\r\n*oops_len = (u16) text_len;\r\n}\r\n(void) nvram_write_os_partition(&oops_log_partition, oops_buf,\r\n(int) (sizeof(*oops_len) + *oops_len), err_type, ++oops_count);\r\nspin_unlock_irqrestore(&lock, flags);\r\n}
