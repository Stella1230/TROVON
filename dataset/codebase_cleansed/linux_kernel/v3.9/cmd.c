static int mlx4_status_to_errno(u8 status)\r\n{\r\nstatic const int trans_table[] = {\r\n[CMD_STAT_INTERNAL_ERR] = -EIO,\r\n[CMD_STAT_BAD_OP] = -EPERM,\r\n[CMD_STAT_BAD_PARAM] = -EINVAL,\r\n[CMD_STAT_BAD_SYS_STATE] = -ENXIO,\r\n[CMD_STAT_BAD_RESOURCE] = -EBADF,\r\n[CMD_STAT_RESOURCE_BUSY] = -EBUSY,\r\n[CMD_STAT_EXCEED_LIM] = -ENOMEM,\r\n[CMD_STAT_BAD_RES_STATE] = -EBADF,\r\n[CMD_STAT_BAD_INDEX] = -EBADF,\r\n[CMD_STAT_BAD_NVMEM] = -EFAULT,\r\n[CMD_STAT_ICM_ERROR] = -ENFILE,\r\n[CMD_STAT_BAD_QP_STATE] = -EINVAL,\r\n[CMD_STAT_BAD_SEG_PARAM] = -EFAULT,\r\n[CMD_STAT_REG_BOUND] = -EBUSY,\r\n[CMD_STAT_LAM_NOT_PRE] = -EAGAIN,\r\n[CMD_STAT_BAD_PKT] = -EINVAL,\r\n[CMD_STAT_BAD_SIZE] = -ENOMEM,\r\n[CMD_STAT_MULTI_FUNC_REQ] = -EACCES,\r\n};\r\nif (status >= ARRAY_SIZE(trans_table) ||\r\n(status != CMD_STAT_OK && trans_table[status] == 0))\r\nreturn -EIO;\r\nreturn trans_table[status];\r\n}\r\nstatic u8 mlx4_errno_to_status(int errno)\r\n{\r\nswitch (errno) {\r\ncase -EPERM:\r\nreturn CMD_STAT_BAD_OP;\r\ncase -EINVAL:\r\nreturn CMD_STAT_BAD_PARAM;\r\ncase -ENXIO:\r\nreturn CMD_STAT_BAD_SYS_STATE;\r\ncase -EBUSY:\r\nreturn CMD_STAT_RESOURCE_BUSY;\r\ncase -ENOMEM:\r\nreturn CMD_STAT_EXCEED_LIM;\r\ncase -ENFILE:\r\nreturn CMD_STAT_ICM_ERROR;\r\ndefault:\r\nreturn CMD_STAT_INTERNAL_ERR;\r\n}\r\n}\r\nstatic int comm_pending(struct mlx4_dev *dev)\r\n{\r\nstruct mlx4_priv *priv = mlx4_priv(dev);\r\nu32 status = readl(&priv->mfunc.comm->slave_read);\r\nreturn (swab32(status) >> 31) != priv->cmd.comm_toggle;\r\n}\r\nstatic void mlx4_comm_cmd_post(struct mlx4_dev *dev, u8 cmd, u16 param)\r\n{\r\nstruct mlx4_priv *priv = mlx4_priv(dev);\r\nu32 val;\r\npriv->cmd.comm_toggle ^= 1;\r\nval = param | (cmd << 16) | (priv->cmd.comm_toggle << 31);\r\n__raw_writel((__force u32) cpu_to_be32(val),\r\n&priv->mfunc.comm->slave_write);\r\nmmiowb();\r\n}\r\nstatic int mlx4_comm_cmd_poll(struct mlx4_dev *dev, u8 cmd, u16 param,\r\nunsigned long timeout)\r\n{\r\nstruct mlx4_priv *priv = mlx4_priv(dev);\r\nunsigned long end;\r\nint err = 0;\r\nint ret_from_pending = 0;\r\nif (comm_pending(dev)) {\r\nmlx4_warn(dev, "Communication channel is not idle."\r\n"my toggle is %d (cmd:0x%x)\n",\r\npriv->cmd.comm_toggle, cmd);\r\nreturn -EAGAIN;\r\n}\r\ndown(&priv->cmd.poll_sem);\r\nmlx4_comm_cmd_post(dev, cmd, param);\r\nend = msecs_to_jiffies(timeout) + jiffies;\r\nwhile (comm_pending(dev) && time_before(jiffies, end))\r\ncond_resched();\r\nret_from_pending = comm_pending(dev);\r\nif (ret_from_pending) {\r\nif ((MLX4_COMM_CMD_RESET == cmd)) {\r\nmlx4_warn(dev, "Got slave FLRed from Communication"\r\n" channel (ret:0x%x)\n", ret_from_pending);\r\nerr = MLX4_DELAY_RESET_SLAVE;\r\n} else {\r\nmlx4_warn(dev, "Communication channel timed out\n");\r\nerr = -ETIMEDOUT;\r\n}\r\n}\r\nup(&priv->cmd.poll_sem);\r\nreturn err;\r\n}\r\nstatic int mlx4_comm_cmd_wait(struct mlx4_dev *dev, u8 op,\r\nu16 param, unsigned long timeout)\r\n{\r\nstruct mlx4_cmd *cmd = &mlx4_priv(dev)->cmd;\r\nstruct mlx4_cmd_context *context;\r\nunsigned long end;\r\nint err = 0;\r\ndown(&cmd->event_sem);\r\nspin_lock(&cmd->context_lock);\r\nBUG_ON(cmd->free_head < 0);\r\ncontext = &cmd->context[cmd->free_head];\r\ncontext->token += cmd->token_mask + 1;\r\ncmd->free_head = context->next;\r\nspin_unlock(&cmd->context_lock);\r\ninit_completion(&context->done);\r\nmlx4_comm_cmd_post(dev, op, param);\r\nif (!wait_for_completion_timeout(&context->done,\r\nmsecs_to_jiffies(timeout))) {\r\nerr = -EBUSY;\r\ngoto out;\r\n}\r\nerr = context->result;\r\nif (err && context->fw_status != CMD_STAT_MULTI_FUNC_REQ) {\r\nmlx4_err(dev, "command 0x%x failed: fw status = 0x%x\n",\r\nop, context->fw_status);\r\ngoto out;\r\n}\r\nout:\r\nend = msecs_to_jiffies(timeout) + jiffies;\r\nwhile (comm_pending(dev) && time_before(jiffies, end))\r\ncond_resched();\r\nspin_lock(&cmd->context_lock);\r\ncontext->next = cmd->free_head;\r\ncmd->free_head = context - cmd->context;\r\nspin_unlock(&cmd->context_lock);\r\nup(&cmd->event_sem);\r\nreturn err;\r\n}\r\nint mlx4_comm_cmd(struct mlx4_dev *dev, u8 cmd, u16 param,\r\nunsigned long timeout)\r\n{\r\nif (mlx4_priv(dev)->cmd.use_events)\r\nreturn mlx4_comm_cmd_wait(dev, cmd, param, timeout);\r\nreturn mlx4_comm_cmd_poll(dev, cmd, param, timeout);\r\n}\r\nstatic int cmd_pending(struct mlx4_dev *dev)\r\n{\r\nu32 status;\r\nif (pci_channel_offline(dev->pdev))\r\nreturn -EIO;\r\nstatus = readl(mlx4_priv(dev)->cmd.hcr + HCR_STATUS_OFFSET);\r\nreturn (status & swab32(1 << HCR_GO_BIT)) ||\r\n(mlx4_priv(dev)->cmd.toggle ==\r\n!!(status & swab32(1 << HCR_T_BIT)));\r\n}\r\nstatic int mlx4_cmd_post(struct mlx4_dev *dev, u64 in_param, u64 out_param,\r\nu32 in_modifier, u8 op_modifier, u16 op, u16 token,\r\nint event)\r\n{\r\nstruct mlx4_cmd *cmd = &mlx4_priv(dev)->cmd;\r\nu32 __iomem *hcr = cmd->hcr;\r\nint ret = -EAGAIN;\r\nunsigned long end;\r\nmutex_lock(&cmd->hcr_mutex);\r\nif (pci_channel_offline(dev->pdev)) {\r\nret = -EIO;\r\ngoto out;\r\n}\r\nend = jiffies;\r\nif (event)\r\nend += msecs_to_jiffies(GO_BIT_TIMEOUT_MSECS);\r\nwhile (cmd_pending(dev)) {\r\nif (pci_channel_offline(dev->pdev)) {\r\nret = -EIO;\r\ngoto out;\r\n}\r\nif (time_after_eq(jiffies, end)) {\r\nmlx4_err(dev, "%s:cmd_pending failed\n", __func__);\r\ngoto out;\r\n}\r\ncond_resched();\r\n}\r\n__raw_writel((__force u32) cpu_to_be32(in_param >> 32), hcr + 0);\r\n__raw_writel((__force u32) cpu_to_be32(in_param & 0xfffffffful), hcr + 1);\r\n__raw_writel((__force u32) cpu_to_be32(in_modifier), hcr + 2);\r\n__raw_writel((__force u32) cpu_to_be32(out_param >> 32), hcr + 3);\r\n__raw_writel((__force u32) cpu_to_be32(out_param & 0xfffffffful), hcr + 4);\r\n__raw_writel((__force u32) cpu_to_be32(token << 16), hcr + 5);\r\nwmb();\r\n__raw_writel((__force u32) cpu_to_be32((1 << HCR_GO_BIT) |\r\n(cmd->toggle << HCR_T_BIT) |\r\n(event ? (1 << HCR_E_BIT) : 0) |\r\n(op_modifier << HCR_OPMOD_SHIFT) |\r\nop), hcr + 6);\r\nmmiowb();\r\ncmd->toggle = cmd->toggle ^ 1;\r\nret = 0;\r\nout:\r\nmutex_unlock(&cmd->hcr_mutex);\r\nreturn ret;\r\n}\r\nstatic int mlx4_slave_cmd(struct mlx4_dev *dev, u64 in_param, u64 *out_param,\r\nint out_is_imm, u32 in_modifier, u8 op_modifier,\r\nu16 op, unsigned long timeout)\r\n{\r\nstruct mlx4_priv *priv = mlx4_priv(dev);\r\nstruct mlx4_vhcr_cmd *vhcr = priv->mfunc.vhcr;\r\nint ret;\r\nmutex_lock(&priv->cmd.slave_cmd_mutex);\r\nvhcr->in_param = cpu_to_be64(in_param);\r\nvhcr->out_param = out_param ? cpu_to_be64(*out_param) : 0;\r\nvhcr->in_modifier = cpu_to_be32(in_modifier);\r\nvhcr->opcode = cpu_to_be16((((u16) op_modifier) << 12) | (op & 0xfff));\r\nvhcr->token = cpu_to_be16(CMD_POLL_TOKEN);\r\nvhcr->status = 0;\r\nvhcr->flags = !!(priv->cmd.use_events) << 6;\r\nif (mlx4_is_master(dev)) {\r\nret = mlx4_master_process_vhcr(dev, dev->caps.function, vhcr);\r\nif (!ret) {\r\nif (out_is_imm) {\r\nif (out_param)\r\n*out_param =\r\nbe64_to_cpu(vhcr->out_param);\r\nelse {\r\nmlx4_err(dev, "response expected while"\r\n"output mailbox is NULL for "\r\n"command 0x%x\n", op);\r\nvhcr->status = CMD_STAT_BAD_PARAM;\r\n}\r\n}\r\nret = mlx4_status_to_errno(vhcr->status);\r\n}\r\n} else {\r\nret = mlx4_comm_cmd(dev, MLX4_COMM_CMD_VHCR_POST, 0,\r\nMLX4_COMM_TIME + timeout);\r\nif (!ret) {\r\nif (out_is_imm) {\r\nif (out_param)\r\n*out_param =\r\nbe64_to_cpu(vhcr->out_param);\r\nelse {\r\nmlx4_err(dev, "response expected while"\r\n"output mailbox is NULL for "\r\n"command 0x%x\n", op);\r\nvhcr->status = CMD_STAT_BAD_PARAM;\r\n}\r\n}\r\nret = mlx4_status_to_errno(vhcr->status);\r\n} else\r\nmlx4_err(dev, "failed execution of VHCR_POST command"\r\n"opcode 0x%x\n", op);\r\n}\r\nmutex_unlock(&priv->cmd.slave_cmd_mutex);\r\nreturn ret;\r\n}\r\nstatic int mlx4_cmd_poll(struct mlx4_dev *dev, u64 in_param, u64 *out_param,\r\nint out_is_imm, u32 in_modifier, u8 op_modifier,\r\nu16 op, unsigned long timeout)\r\n{\r\nstruct mlx4_priv *priv = mlx4_priv(dev);\r\nvoid __iomem *hcr = priv->cmd.hcr;\r\nint err = 0;\r\nunsigned long end;\r\nu32 stat;\r\ndown(&priv->cmd.poll_sem);\r\nif (pci_channel_offline(dev->pdev)) {\r\nerr = -EIO;\r\ngoto out;\r\n}\r\nerr = mlx4_cmd_post(dev, in_param, out_param ? *out_param : 0,\r\nin_modifier, op_modifier, op, CMD_POLL_TOKEN, 0);\r\nif (err)\r\ngoto out;\r\nend = msecs_to_jiffies(timeout) + jiffies;\r\nwhile (cmd_pending(dev) && time_before(jiffies, end)) {\r\nif (pci_channel_offline(dev->pdev)) {\r\nerr = -EIO;\r\ngoto out;\r\n}\r\ncond_resched();\r\n}\r\nif (cmd_pending(dev)) {\r\nerr = -ETIMEDOUT;\r\ngoto out;\r\n}\r\nif (out_is_imm)\r\n*out_param =\r\n(u64) be32_to_cpu((__force __be32)\r\n__raw_readl(hcr + HCR_OUT_PARAM_OFFSET)) << 32 |\r\n(u64) be32_to_cpu((__force __be32)\r\n__raw_readl(hcr + HCR_OUT_PARAM_OFFSET + 4));\r\nstat = be32_to_cpu((__force __be32)\r\n__raw_readl(hcr + HCR_STATUS_OFFSET)) >> 24;\r\nerr = mlx4_status_to_errno(stat);\r\nif (err)\r\nmlx4_err(dev, "command 0x%x failed: fw status = 0x%x\n",\r\nop, stat);\r\nout:\r\nup(&priv->cmd.poll_sem);\r\nreturn err;\r\n}\r\nvoid mlx4_cmd_event(struct mlx4_dev *dev, u16 token, u8 status, u64 out_param)\r\n{\r\nstruct mlx4_priv *priv = mlx4_priv(dev);\r\nstruct mlx4_cmd_context *context =\r\n&priv->cmd.context[token & priv->cmd.token_mask];\r\nif (token != context->token)\r\nreturn;\r\ncontext->fw_status = status;\r\ncontext->result = mlx4_status_to_errno(status);\r\ncontext->out_param = out_param;\r\ncomplete(&context->done);\r\n}\r\nstatic int mlx4_cmd_wait(struct mlx4_dev *dev, u64 in_param, u64 *out_param,\r\nint out_is_imm, u32 in_modifier, u8 op_modifier,\r\nu16 op, unsigned long timeout)\r\n{\r\nstruct mlx4_cmd *cmd = &mlx4_priv(dev)->cmd;\r\nstruct mlx4_cmd_context *context;\r\nint err = 0;\r\ndown(&cmd->event_sem);\r\nspin_lock(&cmd->context_lock);\r\nBUG_ON(cmd->free_head < 0);\r\ncontext = &cmd->context[cmd->free_head];\r\ncontext->token += cmd->token_mask + 1;\r\ncmd->free_head = context->next;\r\nspin_unlock(&cmd->context_lock);\r\ninit_completion(&context->done);\r\nmlx4_cmd_post(dev, in_param, out_param ? *out_param : 0,\r\nin_modifier, op_modifier, op, context->token, 1);\r\nif (!wait_for_completion_timeout(&context->done,\r\nmsecs_to_jiffies(timeout))) {\r\nerr = -EBUSY;\r\ngoto out;\r\n}\r\nerr = context->result;\r\nif (err) {\r\nmlx4_err(dev, "command 0x%x failed: fw status = 0x%x\n",\r\nop, context->fw_status);\r\ngoto out;\r\n}\r\nif (out_is_imm)\r\n*out_param = context->out_param;\r\nout:\r\nspin_lock(&cmd->context_lock);\r\ncontext->next = cmd->free_head;\r\ncmd->free_head = context - cmd->context;\r\nspin_unlock(&cmd->context_lock);\r\nup(&cmd->event_sem);\r\nreturn err;\r\n}\r\nint __mlx4_cmd(struct mlx4_dev *dev, u64 in_param, u64 *out_param,\r\nint out_is_imm, u32 in_modifier, u8 op_modifier,\r\nu16 op, unsigned long timeout, int native)\r\n{\r\nif (pci_channel_offline(dev->pdev))\r\nreturn -EIO;\r\nif (!mlx4_is_mfunc(dev) || (native && mlx4_is_master(dev))) {\r\nif (mlx4_priv(dev)->cmd.use_events)\r\nreturn mlx4_cmd_wait(dev, in_param, out_param,\r\nout_is_imm, in_modifier,\r\nop_modifier, op, timeout);\r\nelse\r\nreturn mlx4_cmd_poll(dev, in_param, out_param,\r\nout_is_imm, in_modifier,\r\nop_modifier, op, timeout);\r\n}\r\nreturn mlx4_slave_cmd(dev, in_param, out_param, out_is_imm,\r\nin_modifier, op_modifier, op, timeout);\r\n}\r\nstatic int mlx4_ARM_COMM_CHANNEL(struct mlx4_dev *dev)\r\n{\r\nreturn mlx4_cmd(dev, 0, 0, 0, MLX4_CMD_ARM_COMM_CHANNEL,\r\nMLX4_CMD_TIME_CLASS_B, MLX4_CMD_NATIVE);\r\n}\r\nstatic int mlx4_ACCESS_MEM(struct mlx4_dev *dev, u64 master_addr,\r\nint slave, u64 slave_addr,\r\nint size, int is_read)\r\n{\r\nu64 in_param;\r\nu64 out_param;\r\nif ((slave_addr & 0xfff) | (master_addr & 0xfff) |\r\n(slave & ~0x7f) | (size & 0xff)) {\r\nmlx4_err(dev, "Bad access mem params - slave_addr:0x%llx "\r\n"master_addr:0x%llx slave_id:%d size:%d\n",\r\nslave_addr, master_addr, slave, size);\r\nreturn -EINVAL;\r\n}\r\nif (is_read) {\r\nin_param = (u64) slave | slave_addr;\r\nout_param = (u64) dev->caps.function | master_addr;\r\n} else {\r\nin_param = (u64) dev->caps.function | master_addr;\r\nout_param = (u64) slave | slave_addr;\r\n}\r\nreturn mlx4_cmd_imm(dev, in_param, &out_param, size, 0,\r\nMLX4_CMD_ACCESS_MEM,\r\nMLX4_CMD_TIME_CLASS_A, MLX4_CMD_NATIVE);\r\n}\r\nstatic int query_pkey_block(struct mlx4_dev *dev, u8 port, u16 index, u16 *pkey,\r\nstruct mlx4_cmd_mailbox *inbox,\r\nstruct mlx4_cmd_mailbox *outbox)\r\n{\r\nstruct ib_smp *in_mad = (struct ib_smp *)(inbox->buf);\r\nstruct ib_smp *out_mad = (struct ib_smp *)(outbox->buf);\r\nint err;\r\nint i;\r\nif (index & 0x1f)\r\nreturn -EINVAL;\r\nin_mad->attr_mod = cpu_to_be32(index / 32);\r\nerr = mlx4_cmd_box(dev, inbox->dma, outbox->dma, port, 3,\r\nMLX4_CMD_MAD_IFC, MLX4_CMD_TIME_CLASS_C,\r\nMLX4_CMD_NATIVE);\r\nif (err)\r\nreturn err;\r\nfor (i = 0; i < 32; ++i)\r\npkey[i] = be16_to_cpu(((__be16 *) out_mad->data)[i]);\r\nreturn err;\r\n}\r\nstatic int get_full_pkey_table(struct mlx4_dev *dev, u8 port, u16 *table,\r\nstruct mlx4_cmd_mailbox *inbox,\r\nstruct mlx4_cmd_mailbox *outbox)\r\n{\r\nint i;\r\nint err;\r\nfor (i = 0; i < dev->caps.pkey_table_len[port]; i += 32) {\r\nerr = query_pkey_block(dev, port, i, table + i, inbox, outbox);\r\nif (err)\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic enum ib_port_state vf_port_state(struct mlx4_dev *dev, int port, int vf)\r\n{\r\nif (mlx4_get_slave_port_state(dev, vf, port) == SLAVE_PORT_UP)\r\nreturn IB_PORT_ACTIVE;\r\nelse\r\nreturn IB_PORT_DOWN;\r\n}\r\nstatic int mlx4_MAD_IFC_wrapper(struct mlx4_dev *dev, int slave,\r\nstruct mlx4_vhcr *vhcr,\r\nstruct mlx4_cmd_mailbox *inbox,\r\nstruct mlx4_cmd_mailbox *outbox,\r\nstruct mlx4_cmd_info *cmd)\r\n{\r\nstruct ib_smp *smp = inbox->buf;\r\nu32 index;\r\nu8 port;\r\nu16 *table;\r\nint err;\r\nint vidx, pidx;\r\nstruct mlx4_priv *priv = mlx4_priv(dev);\r\nstruct ib_smp *outsmp = outbox->buf;\r\n__be16 *outtab = (__be16 *)(outsmp->data);\r\n__be32 slave_cap_mask;\r\n__be64 slave_node_guid;\r\nport = vhcr->in_modifier;\r\nif (smp->base_version == 1 &&\r\nsmp->mgmt_class == IB_MGMT_CLASS_SUBN_LID_ROUTED &&\r\nsmp->class_version == 1) {\r\nif (smp->method == IB_MGMT_METHOD_GET) {\r\nif (smp->attr_id == IB_SMP_ATTR_PKEY_TABLE) {\r\nindex = be32_to_cpu(smp->attr_mod);\r\nif (port < 1 || port > dev->caps.num_ports)\r\nreturn -EINVAL;\r\ntable = kcalloc(dev->caps.pkey_table_len[port], sizeof *table, GFP_KERNEL);\r\nif (!table)\r\nreturn -ENOMEM;\r\nerr = get_full_pkey_table(dev, port, table, inbox, outbox);\r\nif (!err) {\r\nfor (vidx = index * 32; vidx < (index + 1) * 32; ++vidx) {\r\npidx = priv->virt2phys_pkey[slave][port - 1][vidx];\r\nouttab[vidx % 32] = cpu_to_be16(table[pidx]);\r\n}\r\n}\r\nkfree(table);\r\nreturn err;\r\n}\r\nif (smp->attr_id == IB_SMP_ATTR_PORT_INFO) {\r\nerr = mlx4_cmd_box(dev, inbox->dma, outbox->dma,\r\nvhcr->in_modifier, vhcr->op_modifier,\r\nvhcr->op, MLX4_CMD_TIME_CLASS_C, MLX4_CMD_NATIVE);\r\nif (!err && slave != mlx4_master_func_num(dev)) {\r\nu8 *state = outsmp->data + PORT_STATE_OFFSET;\r\n*state = (*state & 0xf0) | vf_port_state(dev, port, slave);\r\nslave_cap_mask = priv->mfunc.master.slave_state[slave].ib_cap_mask[port];\r\nmemcpy(outsmp->data + PORT_CAPABILITY_LOCATION_IN_SMP, &slave_cap_mask, 4);\r\n}\r\nreturn err;\r\n}\r\nif (smp->attr_id == IB_SMP_ATTR_GUID_INFO) {\r\nsmp->attr_mod = cpu_to_be32(slave / 8);\r\nerr = mlx4_cmd_box(dev, inbox->dma, outbox->dma,\r\nvhcr->in_modifier, vhcr->op_modifier,\r\nvhcr->op, MLX4_CMD_TIME_CLASS_C, MLX4_CMD_NATIVE);\r\nif (!err) {\r\nif (slave % 8)\r\nmemcpy(outsmp->data,\r\noutsmp->data + (slave % 8) * 8, 8);\r\nmemset(outsmp->data + 8, 0, 56);\r\n}\r\nreturn err;\r\n}\r\nif (smp->attr_id == IB_SMP_ATTR_NODE_INFO) {\r\nerr = mlx4_cmd_box(dev, inbox->dma, outbox->dma,\r\nvhcr->in_modifier, vhcr->op_modifier,\r\nvhcr->op, MLX4_CMD_TIME_CLASS_C, MLX4_CMD_NATIVE);\r\nif (!err) {\r\nslave_node_guid = mlx4_get_slave_node_guid(dev, slave);\r\nmemcpy(outsmp->data + 12, &slave_node_guid, 8);\r\n}\r\nreturn err;\r\n}\r\n}\r\n}\r\nif (slave != mlx4_master_func_num(dev) &&\r\n((smp->mgmt_class == IB_MGMT_CLASS_SUBN_DIRECTED_ROUTE) ||\r\n(smp->mgmt_class == IB_MGMT_CLASS_SUBN_LID_ROUTED &&\r\nsmp->method == IB_MGMT_METHOD_SET))) {\r\nmlx4_err(dev, "slave %d is trying to execute a Subnet MGMT MAD, "\r\n"class 0x%x, method 0x%x for attr 0x%x. Rejecting\n",\r\nslave, smp->method, smp->mgmt_class,\r\nbe16_to_cpu(smp->attr_id));\r\nreturn -EPERM;\r\n}\r\nreturn mlx4_cmd_box(dev, inbox->dma, outbox->dma,\r\nvhcr->in_modifier, vhcr->op_modifier,\r\nvhcr->op, MLX4_CMD_TIME_CLASS_C, MLX4_CMD_NATIVE);\r\n}\r\nint mlx4_DMA_wrapper(struct mlx4_dev *dev, int slave,\r\nstruct mlx4_vhcr *vhcr,\r\nstruct mlx4_cmd_mailbox *inbox,\r\nstruct mlx4_cmd_mailbox *outbox,\r\nstruct mlx4_cmd_info *cmd)\r\n{\r\nu64 in_param;\r\nu64 out_param;\r\nint err;\r\nin_param = cmd->has_inbox ? (u64) inbox->dma : vhcr->in_param;\r\nout_param = cmd->has_outbox ? (u64) outbox->dma : vhcr->out_param;\r\nif (cmd->encode_slave_id) {\r\nin_param &= 0xffffffffffffff00ll;\r\nin_param |= slave;\r\n}\r\nerr = __mlx4_cmd(dev, in_param, &out_param, cmd->out_is_imm,\r\nvhcr->in_modifier, vhcr->op_modifier, vhcr->op,\r\nMLX4_CMD_TIME_CLASS_A, MLX4_CMD_NATIVE);\r\nif (cmd->out_is_imm)\r\nvhcr->out_param = out_param;\r\nreturn err;\r\n}\r\nstatic int mlx4_master_process_vhcr(struct mlx4_dev *dev, int slave,\r\nstruct mlx4_vhcr_cmd *in_vhcr)\r\n{\r\nstruct mlx4_priv *priv = mlx4_priv(dev);\r\nstruct mlx4_cmd_info *cmd = NULL;\r\nstruct mlx4_vhcr_cmd *vhcr_cmd = in_vhcr ? in_vhcr : priv->mfunc.vhcr;\r\nstruct mlx4_vhcr *vhcr;\r\nstruct mlx4_cmd_mailbox *inbox = NULL;\r\nstruct mlx4_cmd_mailbox *outbox = NULL;\r\nu64 in_param;\r\nu64 out_param;\r\nint ret = 0;\r\nint i;\r\nint err = 0;\r\nvhcr = kzalloc(sizeof(struct mlx4_vhcr), GFP_KERNEL);\r\nif (!vhcr)\r\nreturn -ENOMEM;\r\nif (!in_vhcr) {\r\nret = mlx4_ACCESS_MEM(dev, priv->mfunc.vhcr_dma, slave,\r\npriv->mfunc.master.slave_state[slave].vhcr_dma,\r\nALIGN(sizeof(struct mlx4_vhcr_cmd),\r\nMLX4_ACCESS_MEM_ALIGN), 1);\r\nif (ret) {\r\nmlx4_err(dev, "%s:Failed reading vhcr"\r\n"ret: 0x%x\n", __func__, ret);\r\nkfree(vhcr);\r\nreturn ret;\r\n}\r\n}\r\nvhcr->in_param = be64_to_cpu(vhcr_cmd->in_param);\r\nvhcr->out_param = be64_to_cpu(vhcr_cmd->out_param);\r\nvhcr->in_modifier = be32_to_cpu(vhcr_cmd->in_modifier);\r\nvhcr->token = be16_to_cpu(vhcr_cmd->token);\r\nvhcr->op = be16_to_cpu(vhcr_cmd->opcode) & 0xfff;\r\nvhcr->op_modifier = (u8) (be16_to_cpu(vhcr_cmd->opcode) >> 12);\r\nvhcr->e_bit = vhcr_cmd->flags & (1 << 6);\r\nfor (i = 0; i < ARRAY_SIZE(cmd_info); ++i) {\r\nif (vhcr->op == cmd_info[i].opcode) {\r\ncmd = &cmd_info[i];\r\nbreak;\r\n}\r\n}\r\nif (!cmd) {\r\nmlx4_err(dev, "Unknown command:0x%x accepted from slave:%d\n",\r\nvhcr->op, slave);\r\nvhcr_cmd->status = CMD_STAT_BAD_PARAM;\r\ngoto out_status;\r\n}\r\nif (cmd->has_inbox) {\r\nvhcr->in_param &= INBOX_MASK;\r\ninbox = mlx4_alloc_cmd_mailbox(dev);\r\nif (IS_ERR(inbox)) {\r\nvhcr_cmd->status = CMD_STAT_BAD_SIZE;\r\ninbox = NULL;\r\ngoto out_status;\r\n}\r\nif (mlx4_ACCESS_MEM(dev, inbox->dma, slave,\r\nvhcr->in_param,\r\nMLX4_MAILBOX_SIZE, 1)) {\r\nmlx4_err(dev, "%s: Failed reading inbox (cmd:0x%x)\n",\r\n__func__, cmd->opcode);\r\nvhcr_cmd->status = CMD_STAT_INTERNAL_ERR;\r\ngoto out_status;\r\n}\r\n}\r\nif (cmd->verify && cmd->verify(dev, slave, vhcr, inbox)) {\r\nmlx4_warn(dev, "Command:0x%x from slave: %d failed protection "\r\n"checks for resource_id:%d\n", vhcr->op, slave,\r\nvhcr->in_modifier);\r\nvhcr_cmd->status = CMD_STAT_BAD_OP;\r\ngoto out_status;\r\n}\r\nif (cmd->has_outbox) {\r\noutbox = mlx4_alloc_cmd_mailbox(dev);\r\nif (IS_ERR(outbox)) {\r\nvhcr_cmd->status = CMD_STAT_BAD_SIZE;\r\noutbox = NULL;\r\ngoto out_status;\r\n}\r\n}\r\nif (cmd->wrapper) {\r\nerr = cmd->wrapper(dev, slave, vhcr, inbox, outbox,\r\ncmd);\r\nif (cmd->out_is_imm)\r\nvhcr_cmd->out_param = cpu_to_be64(vhcr->out_param);\r\n} else {\r\nin_param = cmd->has_inbox ? (u64) inbox->dma :\r\nvhcr->in_param;\r\nout_param = cmd->has_outbox ? (u64) outbox->dma :\r\nvhcr->out_param;\r\nerr = __mlx4_cmd(dev, in_param, &out_param,\r\ncmd->out_is_imm, vhcr->in_modifier,\r\nvhcr->op_modifier, vhcr->op,\r\nMLX4_CMD_TIME_CLASS_A,\r\nMLX4_CMD_NATIVE);\r\nif (cmd->out_is_imm) {\r\nvhcr->out_param = out_param;\r\nvhcr_cmd->out_param = cpu_to_be64(vhcr->out_param);\r\n}\r\n}\r\nif (err) {\r\nmlx4_warn(dev, "vhcr command:0x%x slave:%d failed with"\r\n" error:%d, status %d\n",\r\nvhcr->op, slave, vhcr->errno, err);\r\nvhcr_cmd->status = mlx4_errno_to_status(err);\r\ngoto out_status;\r\n}\r\nif (cmd->has_outbox && !vhcr_cmd->status) {\r\nret = mlx4_ACCESS_MEM(dev, outbox->dma, slave,\r\nvhcr->out_param,\r\nMLX4_MAILBOX_SIZE, MLX4_CMD_WRAPPED);\r\nif (ret) {\r\nmlx4_err(dev, "%s:Failed writing outbox\n", __func__);\r\ngoto out;\r\n}\r\n}\r\nout_status:\r\nif (!in_vhcr) {\r\nret = mlx4_ACCESS_MEM(dev, priv->mfunc.vhcr_dma, slave,\r\npriv->mfunc.master.slave_state[slave].vhcr_dma,\r\nALIGN(sizeof(struct mlx4_vhcr),\r\nMLX4_ACCESS_MEM_ALIGN),\r\nMLX4_CMD_WRAPPED);\r\nif (ret)\r\nmlx4_err(dev, "%s:Failed writing vhcr result\n",\r\n__func__);\r\nelse if (vhcr->e_bit &&\r\nmlx4_GEN_EQE(dev, slave, &priv->mfunc.master.cmd_eqe))\r\nmlx4_warn(dev, "Failed to generate command completion "\r\n"eqe for slave %d\n", slave);\r\n}\r\nout:\r\nkfree(vhcr);\r\nmlx4_free_cmd_mailbox(dev, inbox);\r\nmlx4_free_cmd_mailbox(dev, outbox);\r\nreturn ret;\r\n}\r\nstatic void mlx4_master_do_cmd(struct mlx4_dev *dev, int slave, u8 cmd,\r\nu16 param, u8 toggle)\r\n{\r\nstruct mlx4_priv *priv = mlx4_priv(dev);\r\nstruct mlx4_slave_state *slave_state = priv->mfunc.master.slave_state;\r\nu32 reply;\r\nu8 is_going_down = 0;\r\nint i;\r\nunsigned long flags;\r\nslave_state[slave].comm_toggle ^= 1;\r\nreply = (u32) slave_state[slave].comm_toggle << 31;\r\nif (toggle != slave_state[slave].comm_toggle) {\r\nmlx4_warn(dev, "Incorrect toggle %d from slave %d. *** MASTER"\r\n"STATE COMPROMISIED ***\n", toggle, slave);\r\ngoto reset_slave;\r\n}\r\nif (cmd == MLX4_COMM_CMD_RESET) {\r\nmlx4_warn(dev, "Received reset from slave:%d\n", slave);\r\nslave_state[slave].active = false;\r\nfor (i = 0; i < MLX4_EVENT_TYPES_NUM; ++i) {\r\nslave_state[slave].event_eq[i].eqn = -1;\r\nslave_state[slave].event_eq[i].token = 0;\r\n}\r\nif (MLX4_COMM_CMD_FLR == slave_state[slave].last_cmd)\r\ngoto inform_slave_state;\r\nmlx4_dispatch_event(dev, MLX4_DEV_EVENT_SLAVE_SHUTDOWN, slave);\r\nreply |= mlx4_comm_get_version();\r\ngoto reset_slave;\r\n}\r\nif (cmd != MLX4_COMM_CMD_RESET &&\r\nMLX4_COMM_CMD_FLR == slave_state[slave].last_cmd) {\r\nmlx4_warn(dev, "slave:%d is Trying to run cmd(0x%x) "\r\n"in the middle of FLR\n", slave, cmd);\r\nreturn;\r\n}\r\nswitch (cmd) {\r\ncase MLX4_COMM_CMD_VHCR0:\r\nif (slave_state[slave].last_cmd != MLX4_COMM_CMD_RESET)\r\ngoto reset_slave;\r\nslave_state[slave].vhcr_dma = ((u64) param) << 48;\r\npriv->mfunc.master.slave_state[slave].cookie = 0;\r\nmutex_init(&priv->mfunc.master.gen_eqe_mutex[slave]);\r\nbreak;\r\ncase MLX4_COMM_CMD_VHCR1:\r\nif (slave_state[slave].last_cmd != MLX4_COMM_CMD_VHCR0)\r\ngoto reset_slave;\r\nslave_state[slave].vhcr_dma |= ((u64) param) << 32;\r\nbreak;\r\ncase MLX4_COMM_CMD_VHCR2:\r\nif (slave_state[slave].last_cmd != MLX4_COMM_CMD_VHCR1)\r\ngoto reset_slave;\r\nslave_state[slave].vhcr_dma |= ((u64) param) << 16;\r\nbreak;\r\ncase MLX4_COMM_CMD_VHCR_EN:\r\nif (slave_state[slave].last_cmd != MLX4_COMM_CMD_VHCR2)\r\ngoto reset_slave;\r\nslave_state[slave].vhcr_dma |= param;\r\nslave_state[slave].active = true;\r\nmlx4_dispatch_event(dev, MLX4_DEV_EVENT_SLAVE_INIT, slave);\r\nbreak;\r\ncase MLX4_COMM_CMD_VHCR_POST:\r\nif ((slave_state[slave].last_cmd != MLX4_COMM_CMD_VHCR_EN) &&\r\n(slave_state[slave].last_cmd != MLX4_COMM_CMD_VHCR_POST))\r\ngoto reset_slave;\r\nmutex_lock(&priv->cmd.slave_cmd_mutex);\r\nif (mlx4_master_process_vhcr(dev, slave, NULL)) {\r\nmlx4_err(dev, "Failed processing vhcr for slave:%d,"\r\n" resetting slave.\n", slave);\r\nmutex_unlock(&priv->cmd.slave_cmd_mutex);\r\ngoto reset_slave;\r\n}\r\nmutex_unlock(&priv->cmd.slave_cmd_mutex);\r\nbreak;\r\ndefault:\r\nmlx4_warn(dev, "Bad comm cmd:%d from slave:%d\n", cmd, slave);\r\ngoto reset_slave;\r\n}\r\nspin_lock_irqsave(&priv->mfunc.master.slave_state_lock, flags);\r\nif (!slave_state[slave].is_slave_going_down)\r\nslave_state[slave].last_cmd = cmd;\r\nelse\r\nis_going_down = 1;\r\nspin_unlock_irqrestore(&priv->mfunc.master.slave_state_lock, flags);\r\nif (is_going_down) {\r\nmlx4_warn(dev, "Slave is going down aborting command(%d)"\r\n" executing from slave:%d\n",\r\ncmd, slave);\r\nreturn;\r\n}\r\n__raw_writel((__force u32) cpu_to_be32(reply),\r\n&priv->mfunc.comm[slave].slave_read);\r\nmmiowb();\r\nreturn;\r\nreset_slave:\r\nmlx4_delete_all_resources_for_slave(dev, slave);\r\nspin_lock_irqsave(&priv->mfunc.master.slave_state_lock, flags);\r\nif (!slave_state[slave].is_slave_going_down)\r\nslave_state[slave].last_cmd = MLX4_COMM_CMD_RESET;\r\nspin_unlock_irqrestore(&priv->mfunc.master.slave_state_lock, flags);\r\ninform_slave_state:\r\nmemset(&slave_state[slave].event_eq, 0,\r\nsizeof(struct mlx4_slave_event_eq_info));\r\n__raw_writel((__force u32) cpu_to_be32(reply),\r\n&priv->mfunc.comm[slave].slave_read);\r\nwmb();\r\n}\r\nvoid mlx4_master_comm_channel(struct work_struct *work)\r\n{\r\nstruct mlx4_mfunc_master_ctx *master =\r\ncontainer_of(work,\r\nstruct mlx4_mfunc_master_ctx,\r\ncomm_work);\r\nstruct mlx4_mfunc *mfunc =\r\ncontainer_of(master, struct mlx4_mfunc, master);\r\nstruct mlx4_priv *priv =\r\ncontainer_of(mfunc, struct mlx4_priv, mfunc);\r\nstruct mlx4_dev *dev = &priv->dev;\r\n__be32 *bit_vec;\r\nu32 comm_cmd;\r\nu32 vec;\r\nint i, j, slave;\r\nint toggle;\r\nint served = 0;\r\nint reported = 0;\r\nu32 slt;\r\nbit_vec = master->comm_arm_bit_vector;\r\nfor (i = 0; i < COMM_CHANNEL_BIT_ARRAY_SIZE; i++) {\r\nvec = be32_to_cpu(bit_vec[i]);\r\nfor (j = 0; j < 32; j++) {\r\nif (!(vec & (1 << j)))\r\ncontinue;\r\n++reported;\r\nslave = (i * 32) + j;\r\ncomm_cmd = swab32(readl(\r\n&mfunc->comm[slave].slave_write));\r\nslt = swab32(readl(&mfunc->comm[slave].slave_read))\r\n>> 31;\r\ntoggle = comm_cmd >> 31;\r\nif (toggle != slt) {\r\nif (master->slave_state[slave].comm_toggle\r\n!= slt) {\r\nprintk(KERN_INFO "slave %d out of sync."\r\n" read toggle %d, state toggle %d. "\r\n"Resynching.\n", slave, slt,\r\nmaster->slave_state[slave].comm_toggle);\r\nmaster->slave_state[slave].comm_toggle =\r\nslt;\r\n}\r\nmlx4_master_do_cmd(dev, slave,\r\ncomm_cmd >> 16 & 0xff,\r\ncomm_cmd & 0xffff, toggle);\r\n++served;\r\n}\r\n}\r\n}\r\nif (reported && reported != served)\r\nmlx4_warn(dev, "Got command event with bitmask from %d slaves"\r\n" but %d were served\n",\r\nreported, served);\r\nif (mlx4_ARM_COMM_CHANNEL(dev))\r\nmlx4_warn(dev, "Failed to arm comm channel events\n");\r\n}\r\nstatic int sync_toggles(struct mlx4_dev *dev)\r\n{\r\nstruct mlx4_priv *priv = mlx4_priv(dev);\r\nint wr_toggle;\r\nint rd_toggle;\r\nunsigned long end;\r\nwr_toggle = swab32(readl(&priv->mfunc.comm->slave_write)) >> 31;\r\nend = jiffies + msecs_to_jiffies(5000);\r\nwhile (time_before(jiffies, end)) {\r\nrd_toggle = swab32(readl(&priv->mfunc.comm->slave_read)) >> 31;\r\nif (rd_toggle == wr_toggle) {\r\npriv->cmd.comm_toggle = rd_toggle;\r\nreturn 0;\r\n}\r\ncond_resched();\r\n}\r\nmlx4_warn(dev, "recovering from previously mis-behaved VM\n");\r\n__raw_writel((__force u32) 0, &priv->mfunc.comm->slave_read);\r\n__raw_writel((__force u32) 0, &priv->mfunc.comm->slave_write);\r\npriv->cmd.comm_toggle = 0;\r\nreturn 0;\r\n}\r\nint mlx4_multi_func_init(struct mlx4_dev *dev)\r\n{\r\nstruct mlx4_priv *priv = mlx4_priv(dev);\r\nstruct mlx4_slave_state *s_state;\r\nint i, j, err, port;\r\nif (mlx4_is_master(dev))\r\npriv->mfunc.comm =\r\nioremap(pci_resource_start(dev->pdev, priv->fw.comm_bar) +\r\npriv->fw.comm_base, MLX4_COMM_PAGESIZE);\r\nelse\r\npriv->mfunc.comm =\r\nioremap(pci_resource_start(dev->pdev, 2) +\r\nMLX4_SLAVE_COMM_BASE, MLX4_COMM_PAGESIZE);\r\nif (!priv->mfunc.comm) {\r\nmlx4_err(dev, "Couldn't map communication vector.\n");\r\ngoto err_vhcr;\r\n}\r\nif (mlx4_is_master(dev)) {\r\npriv->mfunc.master.slave_state =\r\nkzalloc(dev->num_slaves *\r\nsizeof(struct mlx4_slave_state), GFP_KERNEL);\r\nif (!priv->mfunc.master.slave_state)\r\ngoto err_comm;\r\nfor (i = 0; i < dev->num_slaves; ++i) {\r\ns_state = &priv->mfunc.master.slave_state[i];\r\ns_state->last_cmd = MLX4_COMM_CMD_RESET;\r\nfor (j = 0; j < MLX4_EVENT_TYPES_NUM; ++j)\r\ns_state->event_eq[j].eqn = -1;\r\n__raw_writel((__force u32) 0,\r\n&priv->mfunc.comm[i].slave_write);\r\n__raw_writel((__force u32) 0,\r\n&priv->mfunc.comm[i].slave_read);\r\nmmiowb();\r\nfor (port = 1; port <= MLX4_MAX_PORTS; port++) {\r\ns_state->vlan_filter[port] =\r\nkzalloc(sizeof(struct mlx4_vlan_fltr),\r\nGFP_KERNEL);\r\nif (!s_state->vlan_filter[port]) {\r\nif (--port)\r\nkfree(s_state->vlan_filter[port]);\r\ngoto err_slaves;\r\n}\r\nINIT_LIST_HEAD(&s_state->mcast_filters[port]);\r\n}\r\nspin_lock_init(&s_state->lock);\r\n}\r\nmemset(&priv->mfunc.master.cmd_eqe, 0, dev->caps.eqe_size);\r\npriv->mfunc.master.cmd_eqe.type = MLX4_EVENT_TYPE_CMD;\r\nINIT_WORK(&priv->mfunc.master.comm_work,\r\nmlx4_master_comm_channel);\r\nINIT_WORK(&priv->mfunc.master.slave_event_work,\r\nmlx4_gen_slave_eqe);\r\nINIT_WORK(&priv->mfunc.master.slave_flr_event_work,\r\nmlx4_master_handle_slave_flr);\r\nspin_lock_init(&priv->mfunc.master.slave_state_lock);\r\nspin_lock_init(&priv->mfunc.master.slave_eq.event_lock);\r\npriv->mfunc.master.comm_wq =\r\ncreate_singlethread_workqueue("mlx4_comm");\r\nif (!priv->mfunc.master.comm_wq)\r\ngoto err_slaves;\r\nif (mlx4_init_resource_tracker(dev))\r\ngoto err_thread;\r\nerr = mlx4_ARM_COMM_CHANNEL(dev);\r\nif (err) {\r\nmlx4_err(dev, " Failed to arm comm channel eq: %x\n",\r\nerr);\r\ngoto err_resource;\r\n}\r\n} else {\r\nerr = sync_toggles(dev);\r\nif (err) {\r\nmlx4_err(dev, "Couldn't sync toggles\n");\r\ngoto err_comm;\r\n}\r\n}\r\nreturn 0;\r\nerr_resource:\r\nmlx4_free_resource_tracker(dev, RES_TR_FREE_ALL);\r\nerr_thread:\r\nflush_workqueue(priv->mfunc.master.comm_wq);\r\ndestroy_workqueue(priv->mfunc.master.comm_wq);\r\nerr_slaves:\r\nwhile (--i) {\r\nfor (port = 1; port <= MLX4_MAX_PORTS; port++)\r\nkfree(priv->mfunc.master.slave_state[i].vlan_filter[port]);\r\n}\r\nkfree(priv->mfunc.master.slave_state);\r\nerr_comm:\r\niounmap(priv->mfunc.comm);\r\nerr_vhcr:\r\ndma_free_coherent(&(dev->pdev->dev), PAGE_SIZE,\r\npriv->mfunc.vhcr,\r\npriv->mfunc.vhcr_dma);\r\npriv->mfunc.vhcr = NULL;\r\nreturn -ENOMEM;\r\n}\r\nint mlx4_cmd_init(struct mlx4_dev *dev)\r\n{\r\nstruct mlx4_priv *priv = mlx4_priv(dev);\r\nmutex_init(&priv->cmd.hcr_mutex);\r\nmutex_init(&priv->cmd.slave_cmd_mutex);\r\nsema_init(&priv->cmd.poll_sem, 1);\r\npriv->cmd.use_events = 0;\r\npriv->cmd.toggle = 1;\r\npriv->cmd.hcr = NULL;\r\npriv->mfunc.vhcr = NULL;\r\nif (!mlx4_is_slave(dev)) {\r\npriv->cmd.hcr = ioremap(pci_resource_start(dev->pdev, 0) +\r\nMLX4_HCR_BASE, MLX4_HCR_SIZE);\r\nif (!priv->cmd.hcr) {\r\nmlx4_err(dev, "Couldn't map command register.\n");\r\nreturn -ENOMEM;\r\n}\r\n}\r\nif (mlx4_is_mfunc(dev)) {\r\npriv->mfunc.vhcr = dma_alloc_coherent(&(dev->pdev->dev), PAGE_SIZE,\r\n&priv->mfunc.vhcr_dma,\r\nGFP_KERNEL);\r\nif (!priv->mfunc.vhcr) {\r\nmlx4_err(dev, "Couldn't allocate VHCR.\n");\r\ngoto err_hcr;\r\n}\r\n}\r\npriv->cmd.pool = pci_pool_create("mlx4_cmd", dev->pdev,\r\nMLX4_MAILBOX_SIZE,\r\nMLX4_MAILBOX_SIZE, 0);\r\nif (!priv->cmd.pool)\r\ngoto err_vhcr;\r\nreturn 0;\r\nerr_vhcr:\r\nif (mlx4_is_mfunc(dev))\r\ndma_free_coherent(&(dev->pdev->dev), PAGE_SIZE,\r\npriv->mfunc.vhcr, priv->mfunc.vhcr_dma);\r\npriv->mfunc.vhcr = NULL;\r\nerr_hcr:\r\nif (!mlx4_is_slave(dev))\r\niounmap(priv->cmd.hcr);\r\nreturn -ENOMEM;\r\n}\r\nvoid mlx4_multi_func_cleanup(struct mlx4_dev *dev)\r\n{\r\nstruct mlx4_priv *priv = mlx4_priv(dev);\r\nint i, port;\r\nif (mlx4_is_master(dev)) {\r\nflush_workqueue(priv->mfunc.master.comm_wq);\r\ndestroy_workqueue(priv->mfunc.master.comm_wq);\r\nfor (i = 0; i < dev->num_slaves; i++) {\r\nfor (port = 1; port <= MLX4_MAX_PORTS; port++)\r\nkfree(priv->mfunc.master.slave_state[i].vlan_filter[port]);\r\n}\r\nkfree(priv->mfunc.master.slave_state);\r\n}\r\niounmap(priv->mfunc.comm);\r\n}\r\nvoid mlx4_cmd_cleanup(struct mlx4_dev *dev)\r\n{\r\nstruct mlx4_priv *priv = mlx4_priv(dev);\r\npci_pool_destroy(priv->cmd.pool);\r\nif (!mlx4_is_slave(dev))\r\niounmap(priv->cmd.hcr);\r\nif (mlx4_is_mfunc(dev))\r\ndma_free_coherent(&(dev->pdev->dev), PAGE_SIZE,\r\npriv->mfunc.vhcr, priv->mfunc.vhcr_dma);\r\npriv->mfunc.vhcr = NULL;\r\n}\r\nint mlx4_cmd_use_events(struct mlx4_dev *dev)\r\n{\r\nstruct mlx4_priv *priv = mlx4_priv(dev);\r\nint i;\r\nint err = 0;\r\npriv->cmd.context = kmalloc(priv->cmd.max_cmds *\r\nsizeof (struct mlx4_cmd_context),\r\nGFP_KERNEL);\r\nif (!priv->cmd.context)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < priv->cmd.max_cmds; ++i) {\r\npriv->cmd.context[i].token = i;\r\npriv->cmd.context[i].next = i + 1;\r\n}\r\npriv->cmd.context[priv->cmd.max_cmds - 1].next = -1;\r\npriv->cmd.free_head = 0;\r\nsema_init(&priv->cmd.event_sem, priv->cmd.max_cmds);\r\nspin_lock_init(&priv->cmd.context_lock);\r\nfor (priv->cmd.token_mask = 1;\r\npriv->cmd.token_mask < priv->cmd.max_cmds;\r\npriv->cmd.token_mask <<= 1)\r\n;\r\n--priv->cmd.token_mask;\r\ndown(&priv->cmd.poll_sem);\r\npriv->cmd.use_events = 1;\r\nreturn err;\r\n}\r\nvoid mlx4_cmd_use_polling(struct mlx4_dev *dev)\r\n{\r\nstruct mlx4_priv *priv = mlx4_priv(dev);\r\nint i;\r\npriv->cmd.use_events = 0;\r\nfor (i = 0; i < priv->cmd.max_cmds; ++i)\r\ndown(&priv->cmd.event_sem);\r\nkfree(priv->cmd.context);\r\nup(&priv->cmd.poll_sem);\r\n}\r\nstruct mlx4_cmd_mailbox *mlx4_alloc_cmd_mailbox(struct mlx4_dev *dev)\r\n{\r\nstruct mlx4_cmd_mailbox *mailbox;\r\nmailbox = kmalloc(sizeof *mailbox, GFP_KERNEL);\r\nif (!mailbox)\r\nreturn ERR_PTR(-ENOMEM);\r\nmailbox->buf = pci_pool_alloc(mlx4_priv(dev)->cmd.pool, GFP_KERNEL,\r\n&mailbox->dma);\r\nif (!mailbox->buf) {\r\nkfree(mailbox);\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nreturn mailbox;\r\n}\r\nvoid mlx4_free_cmd_mailbox(struct mlx4_dev *dev,\r\nstruct mlx4_cmd_mailbox *mailbox)\r\n{\r\nif (!mailbox)\r\nreturn;\r\npci_pool_free(mlx4_priv(dev)->cmd.pool, mailbox->buf, mailbox->dma);\r\nkfree(mailbox);\r\n}\r\nu32 mlx4_comm_get_version(void)\r\n{\r\nreturn ((u32) CMD_CHAN_IF_REV << 8) | (u32) CMD_CHAN_VER;\r\n}
