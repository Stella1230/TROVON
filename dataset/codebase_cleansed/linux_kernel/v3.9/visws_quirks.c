static void __init visws_time_init(void)\r\n{\r\nprintk(KERN_INFO "Starting Cobalt Timer system clock\n");\r\nco_cpu_write(CO_CPU_TIMEVAL, CO_TIME_HZ/HZ);\r\nco_cpu_write(CO_CPU_CTRL, co_cpu_read(CO_CPU_CTRL) | CO_CTRL_TIMERUN);\r\nco_cpu_write(CO_CPU_CTRL, co_cpu_read(CO_CPU_CTRL) & ~CO_CTRL_TIMEMASK);\r\nsetup_default_timer_irq();\r\n}\r\nstatic char * __init visws_memory_setup(void)\r\n{\r\nlong long gfx_mem_size = 8 * MB;\r\nmem_size = boot_params.alt_mem_k;\r\nif (!mem_size) {\r\nprintk(KERN_WARNING "Bootloader didn't set memory size, upgrade it !\n");\r\nmem_size = 128 * MB;\r\n}\r\nif (!sgivwfb_mem_size) {\r\nprintk(KERN_WARNING "Defaulting to 8 MB framebuffer size\n");\r\nsgivwfb_mem_size = 8 * MB;\r\n}\r\nsgivwfb_mem_size &= ~((1 << 20) - 1);\r\nsgivwfb_mem_phys = mem_size - gfx_mem_size;\r\ne820_add_region(0, LOWMEMSIZE(), E820_RAM);\r\ne820_add_region(HIGH_MEMORY, mem_size - sgivwfb_mem_size - HIGH_MEMORY, E820_RAM);\r\ne820_add_region(sgivwfb_mem_phys, sgivwfb_mem_size, E820_RESERVED);\r\nreturn "PROM";\r\n}\r\nstatic void visws_machine_emergency_restart(void)\r\n{\r\noutb(PIIX4_RESET_VAL, PIIX4_RESET_PORT);\r\n}\r\nstatic void visws_machine_power_off(void)\r\n{\r\nunsigned short pm_status;\r\nwhile ((pm_status = inw(PMSTS_PORT)) & 0x100)\r\noutw(pm_status, PMSTS_PORT);\r\noutw(PM_SUSPEND_ENABLE, PMCNTRL_PORT);\r\nmdelay(10);\r\n#define PCI_CONF1_ADDRESS(bus, devfn, reg) \\r\n(0x80000000 | (bus << 16) | (devfn << 8) | (reg & ~3))\r\noutl(PIIX_SPECIAL_STOP, 0xCFC);\r\n}\r\nstatic void __init visws_get_smp_config(unsigned int early)\r\n{\r\n}\r\nstatic void __init MP_processor_info(struct mpc_cpu *m)\r\n{\r\nint ver, logical_apicid;\r\nphysid_mask_t apic_cpus;\r\nif (!(m->cpuflag & CPU_ENABLED))\r\nreturn;\r\nlogical_apicid = m->apicid;\r\nprintk(KERN_INFO "%sCPU #%d %u:%u APIC version %d\n",\r\nm->cpuflag & CPU_BOOTPROCESSOR ? "Bootup " : "",\r\nm->apicid, (m->cpufeature & CPU_FAMILY_MASK) >> 8,\r\n(m->cpufeature & CPU_MODEL_MASK) >> 4, m->apicver);\r\nif (m->cpuflag & CPU_BOOTPROCESSOR)\r\nboot_cpu_physical_apicid = m->apicid;\r\nver = m->apicver;\r\nif ((ver >= 0x14 && m->apicid >= 0xff) || m->apicid >= 0xf) {\r\nprintk(KERN_ERR "Processor #%d INVALID. (Max ID: %d).\n",\r\nm->apicid, MAX_LOCAL_APIC);\r\nreturn;\r\n}\r\napic->apicid_to_cpu_present(m->apicid, &apic_cpus);\r\nphysids_or(phys_cpu_present_map, phys_cpu_present_map, apic_cpus);\r\nif (ver == 0x0) {\r\nprintk(KERN_ERR "BIOS bug, APIC version is 0 for CPU#%d! "\r\n"fixing up to 0x10. (tell your hw vendor)\n",\r\nm->apicid);\r\nver = 0x10;\r\n}\r\napic_version[m->apicid] = ver;\r\n}\r\nstatic void __init visws_find_smp_config(void)\r\n{\r\nstruct mpc_cpu *mp = phys_to_virt(CO_CPU_TAB_PHYS);\r\nunsigned short ncpus = readw(phys_to_virt(CO_CPU_NUM_PHYS));\r\nif (ncpus > CO_CPU_MAX) {\r\nprintk(KERN_WARNING "find_visws_smp: got cpu count of %d at %p\n",\r\nncpus, mp);\r\nncpus = CO_CPU_MAX;\r\n}\r\nif (ncpus > setup_max_cpus)\r\nncpus = setup_max_cpus;\r\n#ifdef CONFIG_X86_LOCAL_APIC\r\nsmp_found_config = 1;\r\n#endif\r\nwhile (ncpus--)\r\nMP_processor_info(mp++);\r\nmp_lapic_addr = APIC_DEFAULT_PHYS_BASE;\r\n}\r\nvoid __init visws_early_detect(void)\r\n{\r\nint raw;\r\nvisws_board_type = (char)(inb_p(PIIX_GPI_BD_REG) & PIIX_GPI_BD_REG)\r\n>> PIIX_GPI_BD_SHIFT;\r\nif (visws_board_type < 0)\r\nreturn;\r\nx86_init.resources.memory_setup = visws_memory_setup;\r\nx86_init.mpparse.get_smp_config = visws_get_smp_config;\r\nx86_init.mpparse.find_smp_config = visws_find_smp_config;\r\nx86_init.irqs.pre_vector_init = visws_pre_intr_init;\r\nx86_init.irqs.trap_init = visws_trap_init;\r\nx86_init.timers.timer_init = visws_time_init;\r\nx86_init.pci.init = pci_visws_init;\r\nx86_init.pci.init_irq = x86_init_noop;\r\npm_power_off = visws_machine_power_off;\r\nmachine_ops.emergency_restart = visws_machine_emergency_restart;\r\nno_broadcast = 0;\r\n#ifdef CONFIG_X86_IO_APIC\r\nskip_ioapic_setup = 1;\r\n#endif\r\noutb_p(SIO_DEV_SEL, SIO_INDEX);\r\noutb_p(SIO_GP_DEV, SIO_DATA);\r\noutb_p(SIO_DEV_MSB, SIO_INDEX);\r\noutb_p(SIO_GP_MSB, SIO_DATA);\r\noutb_p(SIO_DEV_LSB, SIO_INDEX);\r\noutb_p(SIO_GP_LSB, SIO_DATA);\r\noutb_p(SIO_DEV_ENB, SIO_INDEX);\r\noutb_p(1, SIO_DATA);\r\noutb_p(SIO_DEV_SEL, SIO_INDEX);\r\noutb_p(SIO_PM_DEV, SIO_DATA);\r\noutb_p(SIO_DEV_MSB, SIO_INDEX);\r\noutb_p(SIO_PM_MSB, SIO_DATA);\r\noutb_p(SIO_DEV_LSB, SIO_INDEX);\r\noutb_p(SIO_PM_LSB, SIO_DATA);\r\noutb_p(SIO_DEV_ENB, SIO_INDEX);\r\noutb_p(1, SIO_DATA);\r\noutb_p(SIO_PM_FER2, SIO_PM_INDEX);\r\noutb_p(SIO_PM_GP_EN, SIO_PM_DATA);\r\nraw = inb_p(SIO_GP_DATA1);\r\nraw &= 0x7f;\r\nif (visws_board_type == VISWS_320) {\r\nif (raw < 0x6) {\r\nvisws_board_rev = 4;\r\n} else if (raw < 0xc) {\r\nvisws_board_rev = 5;\r\n} else {\r\nvisws_board_rev = 6;\r\n}\r\n} else if (visws_board_type == VISWS_540) {\r\nvisws_board_rev = 2;\r\n} else {\r\nvisws_board_rev = raw;\r\n}\r\nprintk(KERN_INFO "Silicon Graphics Visual Workstation %s (rev %d) detected\n",\r\n(visws_board_type == VISWS_320 ? "320" :\r\n(visws_board_type == VISWS_540 ? "540" :\r\n"unknown")), visws_board_rev);\r\n}\r\nstatic __init void lithium_init(void)\r\n{\r\nset_fixmap(FIX_LI_PCIA, LI_PCI_A_PHYS);\r\nset_fixmap(FIX_LI_PCIB, LI_PCI_B_PHYS);\r\nif ((li_pcia_read16(PCI_VENDOR_ID) != PCI_VENDOR_ID_SGI) ||\r\n(li_pcia_read16(PCI_DEVICE_ID) != PCI_DEVICE_ID_SGI_LITHIUM)) {\r\nprintk(KERN_EMERG "Lithium hostbridge %c not found\n", 'A');\r\n}\r\nif ((li_pcib_read16(PCI_VENDOR_ID) != PCI_VENDOR_ID_SGI) ||\r\n(li_pcib_read16(PCI_DEVICE_ID) != PCI_DEVICE_ID_SGI_LITHIUM)) {\r\nprintk(KERN_EMERG "Lithium hostbridge %c not found\n", 'B');\r\n}\r\nli_pcia_write16(LI_PCI_INTEN, ALLDEVS);\r\nli_pcib_write16(LI_PCI_INTEN, ALLDEVS);\r\n}\r\nstatic __init void cobalt_init(void)\r\n{\r\nset_fixmap(FIX_APIC_BASE, APIC_DEFAULT_PHYS_BASE);\r\nsetup_local_APIC();\r\nprintk(KERN_INFO "Local APIC Version %#x, ID %#x\n",\r\n(unsigned int)apic_read(APIC_LVR),\r\n(unsigned int)apic_read(APIC_ID));\r\nset_fixmap(FIX_CO_CPU, CO_CPU_PHYS);\r\nset_fixmap(FIX_CO_APIC, CO_APIC_PHYS);\r\nprintk(KERN_INFO "Cobalt Revision %#lx, APIC ID %#lx\n",\r\nco_cpu_read(CO_CPU_REV), co_apic_read(CO_APIC_ID));\r\nco_apic_write(CO_APIC_ID, co_apic_read(CO_APIC_ID) | CO_APIC_ENABLE);\r\nprintk(KERN_INFO "Cobalt APIC enabled: ID reg %#lx\n",\r\nco_apic_read(CO_APIC_ID));\r\n}\r\nstatic void __init visws_trap_init(void)\r\n{\r\nlithium_init();\r\ncobalt_init();\r\n}\r\nstatic inline void co_apic_set(int entry, int irq)\r\n{\r\nco_apic_write(CO_APIC_LO(entry), CO_APIC_LEVEL | (irq + FIRST_EXTERNAL_VECTOR));\r\nco_apic_write(CO_APIC_HI(entry), 0);\r\n}\r\nstatic inline int co_apic_ide0_hack(void)\r\n{\r\nextern char visws_board_type;\r\nextern char visws_board_rev;\r\nif (visws_board_type == VISWS_320 && visws_board_rev == 5)\r\nreturn 5;\r\nreturn CO_APIC_IDE0;\r\n}\r\nstatic int is_co_apic(unsigned int irq)\r\n{\r\nif (IS_CO_APIC(irq))\r\nreturn CO_APIC(irq);\r\nswitch (irq) {\r\ncase 0: return CO_APIC_CPU;\r\ncase CO_IRQ_IDE0: return co_apic_ide0_hack();\r\ncase CO_IRQ_IDE1: return CO_APIC_IDE1;\r\ndefault: return -1;\r\n}\r\n}\r\nstatic void enable_cobalt_irq(struct irq_data *data)\r\n{\r\nco_apic_set(is_co_apic(data->irq), data->irq);\r\n}\r\nstatic void disable_cobalt_irq(struct irq_data *data)\r\n{\r\nint entry = is_co_apic(data->irq);\r\nco_apic_write(CO_APIC_LO(entry), CO_APIC_MASK);\r\nco_apic_read(CO_APIC_LO(entry));\r\n}\r\nstatic void ack_cobalt_irq(struct irq_data *data)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&cobalt_lock, flags);\r\ndisable_cobalt_irq(data);\r\napic_write(APIC_EOI, APIC_EOI_ACK);\r\nspin_unlock_irqrestore(&cobalt_lock, flags);\r\n}\r\nstatic unsigned int startup_piix4_master_irq(struct irq_data *data)\r\n{\r\nlegacy_pic->init(0);\r\nenable_cobalt_irq(data);\r\nreturn 0;\r\n}\r\nstatic void pii4_mask(struct irq_data *data) { }\r\nstatic irqreturn_t piix4_master_intr(int irq, void *dev_id)\r\n{\r\nunsigned long flags;\r\nint realirq;\r\nraw_spin_lock_irqsave(&i8259A_lock, flags);\r\noutb(0x0c, 0x20);\r\nrealirq = inb(0x20);\r\nif (unlikely(!(realirq & 0x80)))\r\ngoto out_unlock;\r\nrealirq &= 7;\r\nif (unlikely(realirq == 2)) {\r\noutb(0x0c, 0xa0);\r\nrealirq = inb(0xa0);\r\nif (unlikely(!(realirq & 0x80)))\r\ngoto out_unlock;\r\nrealirq = (realirq & 7) + 8;\r\n}\r\ncached_irq_mask |= 1 << realirq;\r\nif (unlikely(realirq > 7)) {\r\ninb(0xa1);\r\noutb(cached_slave_mask, 0xa1);\r\noutb(0x60 + (realirq & 7), 0xa0);\r\noutb(0x60 + 2, 0x20);\r\n} else {\r\ninb(0x21);\r\noutb(cached_master_mask, 0x21);\r\noutb(0x60 + realirq, 0x20);\r\n}\r\nraw_spin_unlock_irqrestore(&i8259A_lock, flags);\r\ngeneric_handle_irq(realirq);\r\nreturn IRQ_HANDLED;\r\nout_unlock:\r\nraw_spin_unlock_irqrestore(&i8259A_lock, flags);\r\nreturn IRQ_NONE;\r\n}\r\nstatic inline void set_piix4_virtual_irq_type(void)\r\n{\r\npiix4_virtual_irq_type.irq_enable = i8259A_chip.irq_unmask;\r\npiix4_virtual_irq_type.irq_disable = i8259A_chip.irq_mask;\r\npiix4_virtual_irq_type.irq_unmask = i8259A_chip.irq_unmask;\r\n}\r\nstatic void __init visws_pre_intr_init(void)\r\n{\r\nint i;\r\nset_piix4_virtual_irq_type();\r\nfor (i = 0; i < CO_IRQ_APIC0 + CO_APIC_LAST + 1; i++) {\r\nstruct irq_chip *chip = NULL;\r\nif (i == 0)\r\nchip = &cobalt_irq_type;\r\nelse if (i == CO_IRQ_IDE0)\r\nchip = &cobalt_irq_type;\r\nelse if (i == CO_IRQ_IDE1)\r\nchip = &cobalt_irq_type;\r\nelse if (i == CO_IRQ_8259)\r\nchip = &piix4_master_irq_type;\r\nelse if (i < CO_IRQ_APIC0)\r\nchip = &piix4_virtual_irq_type;\r\nelse if (IS_CO_APIC(i))\r\nchip = &cobalt_irq_type;\r\nif (chip)\r\nirq_set_chip(i, chip);\r\n}\r\nsetup_irq(CO_IRQ_8259, &master_action);\r\nsetup_irq(2, &cascade_action);\r\n}
