static inline void fscache_done_parent_op(struct fscache_object *object)\r\n{\r\nstruct fscache_object *parent = object->parent;\r\n_enter("OBJ%x {OBJ%x,%x}",\r\nobject->debug_id, parent->debug_id, parent->n_ops);\r\nspin_lock_nested(&parent->lock, 1);\r\nparent->n_ops--;\r\nparent->n_obj_ops--;\r\nif (parent->n_ops == 0)\r\nfscache_raise_event(parent, FSCACHE_OBJECT_EV_CLEARED);\r\nspin_unlock(&parent->lock);\r\n}\r\nstatic inline void fscache_invalidation_complete(struct fscache_cookie *cookie)\r\n{\r\nif (test_and_clear_bit(FSCACHE_COOKIE_INVALIDATING, &cookie->flags))\r\nwake_up_bit(&cookie->flags, FSCACHE_COOKIE_INVALIDATING);\r\n}\r\nstatic void fscache_object_state_machine(struct fscache_object *object)\r\n{\r\nenum fscache_object_state new_state;\r\nstruct fscache_cookie *cookie;\r\nint event;\r\nASSERT(object != NULL);\r\n_enter("{OBJ%x,%s,%lx}",\r\nobject->debug_id, fscache_object_states[object->state],\r\nobject->events);\r\nswitch (object->state) {\r\ncase FSCACHE_OBJECT_INIT:\r\nobject->event_mask =\r\nFSCACHE_OBJECT_EVENTS_MASK &\r\n~(1 << FSCACHE_OBJECT_EV_CLEARED);\r\nfscache_initialise_object(object);\r\ngoto done;\r\ncase FSCACHE_OBJECT_LOOKING_UP:\r\nfscache_lookup_object(object);\r\ngoto lookup_transit;\r\ncase FSCACHE_OBJECT_CREATING:\r\nfscache_lookup_object(object);\r\ngoto lookup_transit;\r\ncase FSCACHE_OBJECT_AVAILABLE:\r\nfscache_object_available(object);\r\ngoto active_transit;\r\ncase FSCACHE_OBJECT_ACTIVE:\r\ngoto active_transit;\r\ncase FSCACHE_OBJECT_INVALIDATING:\r\nclear_bit(FSCACHE_OBJECT_EV_INVALIDATE, &object->events);\r\nfscache_stat(&fscache_n_invalidates_run);\r\nfscache_stat(&fscache_n_cop_invalidate_object);\r\nfscache_invalidate_object(object);\r\nfscache_stat_d(&fscache_n_cop_invalidate_object);\r\nfscache_raise_event(object, FSCACHE_OBJECT_EV_UPDATE);\r\ngoto active_transit;\r\ncase FSCACHE_OBJECT_UPDATING:\r\nclear_bit(FSCACHE_OBJECT_EV_UPDATE, &object->events);\r\nfscache_stat(&fscache_n_updates_run);\r\nfscache_stat(&fscache_n_cop_update_object);\r\nobject->cache->ops->update_object(object);\r\nfscache_stat_d(&fscache_n_cop_update_object);\r\ngoto active_transit;\r\ncase FSCACHE_OBJECT_LC_DYING:\r\nobject->event_mask &= ~(1 << FSCACHE_OBJECT_EV_UPDATE);\r\nfscache_stat(&fscache_n_cop_lookup_complete);\r\nobject->cache->ops->lookup_complete(object);\r\nfscache_stat_d(&fscache_n_cop_lookup_complete);\r\nspin_lock(&object->lock);\r\nobject->state = FSCACHE_OBJECT_DYING;\r\ncookie = object->cookie;\r\nif (cookie) {\r\nif (test_and_clear_bit(FSCACHE_COOKIE_LOOKING_UP,\r\n&cookie->flags))\r\nwake_up_bit(&cookie->flags,\r\nFSCACHE_COOKIE_LOOKING_UP);\r\nif (test_and_clear_bit(FSCACHE_COOKIE_CREATING,\r\n&cookie->flags))\r\nwake_up_bit(&cookie->flags,\r\nFSCACHE_COOKIE_CREATING);\r\n}\r\nspin_unlock(&object->lock);\r\nfscache_done_parent_op(object);\r\ncase FSCACHE_OBJECT_DYING:\r\ndying:\r\nclear_bit(FSCACHE_OBJECT_EV_CLEARED, &object->events);\r\nspin_lock(&object->lock);\r\n_debug("dying OBJ%x {%d,%d}",\r\nobject->debug_id, object->n_ops, object->n_children);\r\nif (object->n_ops == 0 && object->n_children == 0) {\r\nobject->event_mask &=\r\n~(1 << FSCACHE_OBJECT_EV_CLEARED);\r\nobject->event_mask |=\r\n(1 << FSCACHE_OBJECT_EV_WITHDRAW) |\r\n(1 << FSCACHE_OBJECT_EV_RETIRE) |\r\n(1 << FSCACHE_OBJECT_EV_RELEASE) |\r\n(1 << FSCACHE_OBJECT_EV_ERROR);\r\n} else {\r\nobject->event_mask &=\r\n~((1 << FSCACHE_OBJECT_EV_WITHDRAW) |\r\n(1 << FSCACHE_OBJECT_EV_RETIRE) |\r\n(1 << FSCACHE_OBJECT_EV_RELEASE) |\r\n(1 << FSCACHE_OBJECT_EV_ERROR));\r\nobject->event_mask |=\r\n1 << FSCACHE_OBJECT_EV_CLEARED;\r\n}\r\nspin_unlock(&object->lock);\r\nfscache_enqueue_dependents(object);\r\nfscache_start_operations(object);\r\ngoto terminal_transit;\r\ncase FSCACHE_OBJECT_ABORT_INIT:\r\n_debug("handle abort init %lx", object->events);\r\nobject->event_mask &= ~(1 << FSCACHE_OBJECT_EV_UPDATE);\r\nspin_lock(&object->lock);\r\nfscache_dequeue_object(object);\r\nobject->state = FSCACHE_OBJECT_DYING;\r\nif (test_and_clear_bit(FSCACHE_COOKIE_CREATING,\r\n&object->cookie->flags))\r\nwake_up_bit(&object->cookie->flags,\r\nFSCACHE_COOKIE_CREATING);\r\nspin_unlock(&object->lock);\r\ngoto dying;\r\ncase FSCACHE_OBJECT_RELEASING:\r\ncase FSCACHE_OBJECT_RECYCLING:\r\nobject->event_mask &=\r\n~((1 << FSCACHE_OBJECT_EV_WITHDRAW) |\r\n(1 << FSCACHE_OBJECT_EV_RETIRE) |\r\n(1 << FSCACHE_OBJECT_EV_RELEASE) |\r\n(1 << FSCACHE_OBJECT_EV_ERROR));\r\nfscache_release_object(object);\r\nspin_lock(&object->lock);\r\nobject->state = FSCACHE_OBJECT_DEAD;\r\nspin_unlock(&object->lock);\r\nfscache_stat(&fscache_n_object_dead);\r\ngoto terminal_transit;\r\ncase FSCACHE_OBJECT_WITHDRAWING:\r\nobject->event_mask &=\r\n~((1 << FSCACHE_OBJECT_EV_WITHDRAW) |\r\n(1 << FSCACHE_OBJECT_EV_RETIRE) |\r\n(1 << FSCACHE_OBJECT_EV_RELEASE) |\r\n(1 << FSCACHE_OBJECT_EV_ERROR));\r\nfscache_withdraw_object(object);\r\nspin_lock(&object->lock);\r\nobject->state = FSCACHE_OBJECT_DEAD;\r\nspin_unlock(&object->lock);\r\nfscache_stat(&fscache_n_object_dead);\r\ngoto terminal_transit;\r\ncase FSCACHE_OBJECT_DEAD:\r\nprintk(KERN_ERR "FS-Cache:"\r\n" Unexpected event in dead state %lx\n",\r\nobject->events & object->event_mask);\r\nBUG();\r\ndefault:\r\nprintk(KERN_ERR "FS-Cache: Unknown object state %u\n",\r\nobject->state);\r\nBUG();\r\n}\r\nlookup_transit:\r\nevent = fls(object->events & object->event_mask) - 1;\r\nswitch (event) {\r\ncase FSCACHE_OBJECT_EV_WITHDRAW:\r\ncase FSCACHE_OBJECT_EV_RETIRE:\r\ncase FSCACHE_OBJECT_EV_RELEASE:\r\ncase FSCACHE_OBJECT_EV_ERROR:\r\nnew_state = FSCACHE_OBJECT_LC_DYING;\r\ngoto change_state;\r\ncase FSCACHE_OBJECT_EV_INVALIDATE:\r\nnew_state = FSCACHE_OBJECT_INVALIDATING;\r\ngoto change_state;\r\ncase FSCACHE_OBJECT_EV_REQUEUE:\r\ngoto done;\r\ncase -1:\r\ngoto done;\r\ndefault:\r\ngoto unsupported_event;\r\n}\r\nactive_transit:\r\nevent = fls(object->events & object->event_mask) - 1;\r\nswitch (event) {\r\ncase FSCACHE_OBJECT_EV_WITHDRAW:\r\ncase FSCACHE_OBJECT_EV_RETIRE:\r\ncase FSCACHE_OBJECT_EV_RELEASE:\r\ncase FSCACHE_OBJECT_EV_ERROR:\r\nnew_state = FSCACHE_OBJECT_DYING;\r\ngoto change_state;\r\ncase FSCACHE_OBJECT_EV_INVALIDATE:\r\nnew_state = FSCACHE_OBJECT_INVALIDATING;\r\ngoto change_state;\r\ncase FSCACHE_OBJECT_EV_UPDATE:\r\nnew_state = FSCACHE_OBJECT_UPDATING;\r\ngoto change_state;\r\ncase -1:\r\nnew_state = FSCACHE_OBJECT_ACTIVE;\r\ngoto change_state;\r\ndefault:\r\ngoto unsupported_event;\r\n}\r\nterminal_transit:\r\nevent = fls(object->events & object->event_mask) - 1;\r\nswitch (event) {\r\ncase FSCACHE_OBJECT_EV_WITHDRAW:\r\nnew_state = FSCACHE_OBJECT_WITHDRAWING;\r\ngoto change_state;\r\ncase FSCACHE_OBJECT_EV_RETIRE:\r\nnew_state = FSCACHE_OBJECT_RECYCLING;\r\ngoto change_state;\r\ncase FSCACHE_OBJECT_EV_RELEASE:\r\nnew_state = FSCACHE_OBJECT_RELEASING;\r\ngoto change_state;\r\ncase FSCACHE_OBJECT_EV_ERROR:\r\nnew_state = FSCACHE_OBJECT_WITHDRAWING;\r\ngoto change_state;\r\ncase FSCACHE_OBJECT_EV_CLEARED:\r\nnew_state = FSCACHE_OBJECT_DYING;\r\ngoto change_state;\r\ncase -1:\r\ngoto done;\r\ndefault:\r\ngoto unsupported_event;\r\n}\r\nchange_state:\r\nspin_lock(&object->lock);\r\nobject->state = new_state;\r\nspin_unlock(&object->lock);\r\ndone:\r\n_leave(" [->%s]", fscache_object_states[object->state]);\r\nreturn;\r\nunsupported_event:\r\nprintk(KERN_ERR "FS-Cache:"\r\n" Unsupported event %d [%lx/%lx] in state %s\n",\r\nevent, object->events, object->event_mask,\r\nfscache_object_states[object->state]);\r\nBUG();\r\n}\r\nvoid fscache_object_work_func(struct work_struct *work)\r\n{\r\nstruct fscache_object *object =\r\ncontainer_of(work, struct fscache_object, work);\r\nunsigned long start;\r\n_enter("{OBJ%x}", object->debug_id);\r\nstart = jiffies;\r\nfscache_object_state_machine(object);\r\nfscache_hist(fscache_objs_histogram, start);\r\nif (object->events & object->event_mask)\r\nfscache_enqueue_object(object);\r\nclear_bit(FSCACHE_OBJECT_EV_REQUEUE, &object->events);\r\nfscache_put_object(object);\r\n}\r\nstatic void fscache_initialise_object(struct fscache_object *object)\r\n{\r\nstruct fscache_object *parent;\r\n_enter("");\r\nASSERT(object->cookie != NULL);\r\nASSERT(object->cookie->parent != NULL);\r\nif (object->events & ((1 << FSCACHE_OBJECT_EV_ERROR) |\r\n(1 << FSCACHE_OBJECT_EV_RELEASE) |\r\n(1 << FSCACHE_OBJECT_EV_RETIRE) |\r\n(1 << FSCACHE_OBJECT_EV_WITHDRAW))) {\r\n_debug("abort init %lx", object->events);\r\nspin_lock(&object->lock);\r\nobject->state = FSCACHE_OBJECT_ABORT_INIT;\r\nspin_unlock(&object->lock);\r\nreturn;\r\n}\r\nspin_lock(&object->cookie->lock);\r\nspin_lock_nested(&object->cookie->parent->lock, 1);\r\nparent = object->parent;\r\nif (!parent) {\r\n_debug("no parent");\r\nset_bit(FSCACHE_OBJECT_EV_WITHDRAW, &object->events);\r\n} else {\r\nspin_lock(&object->lock);\r\nspin_lock_nested(&parent->lock, 1);\r\n_debug("parent %s", fscache_object_states[parent->state]);\r\nif (parent->state >= FSCACHE_OBJECT_DYING) {\r\n_debug("bad parent");\r\nset_bit(FSCACHE_OBJECT_EV_WITHDRAW, &object->events);\r\n} else if (parent->state < FSCACHE_OBJECT_AVAILABLE) {\r\n_debug("wait");\r\nif (list_empty(&object->dep_link)) {\r\nfscache_stat(&fscache_n_cop_grab_object);\r\nobject->cache->ops->grab_object(object);\r\nfscache_stat_d(&fscache_n_cop_grab_object);\r\nlist_add(&object->dep_link,\r\n&parent->dependents);\r\nif (parent->state == FSCACHE_OBJECT_INIT)\r\nfscache_enqueue_object(parent);\r\n}\r\n} else {\r\n_debug("go");\r\nparent->n_ops++;\r\nparent->n_obj_ops++;\r\nobject->lookup_jif = jiffies;\r\nobject->state = FSCACHE_OBJECT_LOOKING_UP;\r\nset_bit(FSCACHE_OBJECT_EV_REQUEUE, &object->events);\r\n}\r\nspin_unlock(&parent->lock);\r\nspin_unlock(&object->lock);\r\n}\r\nspin_unlock(&object->cookie->parent->lock);\r\nspin_unlock(&object->cookie->lock);\r\n_leave("");\r\n}\r\nstatic void fscache_lookup_object(struct fscache_object *object)\r\n{\r\nstruct fscache_cookie *cookie = object->cookie;\r\nstruct fscache_object *parent;\r\nint ret;\r\n_enter("");\r\nparent = object->parent;\r\nASSERT(parent != NULL);\r\nASSERTCMP(parent->n_ops, >, 0);\r\nASSERTCMP(parent->n_obj_ops, >, 0);\r\nASSERTCMP(parent->state, >=, FSCACHE_OBJECT_AVAILABLE);\r\nif (parent->state >= FSCACHE_OBJECT_DYING ||\r\ntest_bit(FSCACHE_IOERROR, &object->cache->flags)) {\r\n_debug("unavailable");\r\nset_bit(FSCACHE_OBJECT_EV_WITHDRAW, &object->events);\r\n_leave("");\r\nreturn;\r\n}\r\n_debug("LOOKUP \"%s/%s\" in \"%s\"",\r\nparent->cookie->def->name, cookie->def->name,\r\nobject->cache->tag->name);\r\nfscache_stat(&fscache_n_object_lookups);\r\nfscache_stat(&fscache_n_cop_lookup_object);\r\nret = object->cache->ops->lookup_object(object);\r\nfscache_stat_d(&fscache_n_cop_lookup_object);\r\nif (test_bit(FSCACHE_OBJECT_EV_ERROR, &object->events))\r\nset_bit(FSCACHE_COOKIE_UNAVAILABLE, &cookie->flags);\r\nif (ret == -ETIMEDOUT) {\r\nfscache_stat(&fscache_n_object_lookups_timed_out);\r\nset_bit(FSCACHE_OBJECT_EV_REQUEUE, &object->events);\r\n}\r\n_leave("");\r\n}\r\nvoid fscache_object_lookup_negative(struct fscache_object *object)\r\n{\r\nstruct fscache_cookie *cookie = object->cookie;\r\n_enter("{OBJ%x,%s}",\r\nobject->debug_id, fscache_object_states[object->state]);\r\nspin_lock(&object->lock);\r\nif (object->state == FSCACHE_OBJECT_LOOKING_UP) {\r\nfscache_stat(&fscache_n_object_lookups_negative);\r\nobject->state = FSCACHE_OBJECT_CREATING;\r\nspin_unlock(&object->lock);\r\nset_bit(FSCACHE_COOKIE_PENDING_FILL, &cookie->flags);\r\nset_bit(FSCACHE_COOKIE_NO_DATA_YET, &cookie->flags);\r\n_debug("wake up lookup %p", &cookie->flags);\r\nsmp_mb__before_clear_bit();\r\nclear_bit(FSCACHE_COOKIE_LOOKING_UP, &cookie->flags);\r\nsmp_mb__after_clear_bit();\r\nwake_up_bit(&cookie->flags, FSCACHE_COOKIE_LOOKING_UP);\r\nset_bit(FSCACHE_OBJECT_EV_REQUEUE, &object->events);\r\n} else {\r\nASSERTCMP(object->state, ==, FSCACHE_OBJECT_CREATING);\r\nspin_unlock(&object->lock);\r\n}\r\n_leave("");\r\n}\r\nvoid fscache_obtained_object(struct fscache_object *object)\r\n{\r\nstruct fscache_cookie *cookie = object->cookie;\r\n_enter("{OBJ%x,%s}",\r\nobject->debug_id, fscache_object_states[object->state]);\r\nspin_lock(&object->lock);\r\nif (object->state == FSCACHE_OBJECT_LOOKING_UP) {\r\nfscache_stat(&fscache_n_object_lookups_positive);\r\nclear_bit(FSCACHE_COOKIE_NO_DATA_YET, &cookie->flags);\r\nobject->state = FSCACHE_OBJECT_AVAILABLE;\r\nspin_unlock(&object->lock);\r\nsmp_mb__before_clear_bit();\r\nclear_bit(FSCACHE_COOKIE_LOOKING_UP, &cookie->flags);\r\nsmp_mb__after_clear_bit();\r\nwake_up_bit(&cookie->flags, FSCACHE_COOKIE_LOOKING_UP);\r\nset_bit(FSCACHE_OBJECT_EV_REQUEUE, &object->events);\r\n} else {\r\nASSERTCMP(object->state, ==, FSCACHE_OBJECT_CREATING);\r\nfscache_stat(&fscache_n_object_created);\r\nobject->state = FSCACHE_OBJECT_AVAILABLE;\r\nspin_unlock(&object->lock);\r\nset_bit(FSCACHE_OBJECT_EV_REQUEUE, &object->events);\r\nsmp_wmb();\r\n}\r\nif (test_and_clear_bit(FSCACHE_COOKIE_CREATING, &cookie->flags))\r\nwake_up_bit(&cookie->flags, FSCACHE_COOKIE_CREATING);\r\n_leave("");\r\n}\r\nstatic void fscache_object_available(struct fscache_object *object)\r\n{\r\n_enter("{OBJ%x}", object->debug_id);\r\nspin_lock(&object->lock);\r\nif (object->cookie &&\r\ntest_and_clear_bit(FSCACHE_COOKIE_CREATING, &object->cookie->flags))\r\nwake_up_bit(&object->cookie->flags, FSCACHE_COOKIE_CREATING);\r\nfscache_done_parent_op(object);\r\nif (object->n_in_progress == 0) {\r\nif (object->n_ops > 0) {\r\nASSERTCMP(object->n_ops, >=, object->n_obj_ops);\r\nfscache_start_operations(object);\r\n} else {\r\nASSERT(list_empty(&object->pending_ops));\r\n}\r\n}\r\nspin_unlock(&object->lock);\r\nfscache_stat(&fscache_n_cop_lookup_complete);\r\nobject->cache->ops->lookup_complete(object);\r\nfscache_stat_d(&fscache_n_cop_lookup_complete);\r\nfscache_enqueue_dependents(object);\r\nfscache_hist(fscache_obj_instantiate_histogram, object->lookup_jif);\r\nfscache_stat(&fscache_n_object_avail);\r\n_leave("");\r\n}\r\nstatic void fscache_drop_object(struct fscache_object *object)\r\n{\r\nstruct fscache_object *parent = object->parent;\r\nstruct fscache_cache *cache = object->cache;\r\n_enter("{OBJ%x,%d}", object->debug_id, object->n_children);\r\nASSERTCMP(object->cookie, ==, NULL);\r\nASSERT(hlist_unhashed(&object->cookie_link));\r\nspin_lock(&cache->object_list_lock);\r\nlist_del_init(&object->cache_link);\r\nspin_unlock(&cache->object_list_lock);\r\nfscache_stat(&fscache_n_cop_drop_object);\r\ncache->ops->drop_object(object);\r\nfscache_stat_d(&fscache_n_cop_drop_object);\r\nif (parent) {\r\n_debug("release parent OBJ%x {%d}",\r\nparent->debug_id, parent->n_children);\r\nspin_lock(&parent->lock);\r\nparent->n_children--;\r\nif (parent->n_children == 0)\r\nfscache_raise_event(parent, FSCACHE_OBJECT_EV_CLEARED);\r\nspin_unlock(&parent->lock);\r\nobject->parent = NULL;\r\n}\r\nfscache_put_object(object);\r\n_leave("");\r\n}\r\nstatic void fscache_release_object(struct fscache_object *object)\r\n{\r\n_enter("");\r\nfscache_drop_object(object);\r\n}\r\nstatic void fscache_withdraw_object(struct fscache_object *object)\r\n{\r\nstruct fscache_cookie *cookie;\r\nbool detached;\r\n_enter("");\r\nspin_lock(&object->lock);\r\ncookie = object->cookie;\r\nif (cookie) {\r\natomic_inc(&cookie->usage);\r\nspin_unlock(&object->lock);\r\ndetached = false;\r\nspin_lock(&cookie->lock);\r\nspin_lock(&object->lock);\r\nif (object->cookie == cookie) {\r\nhlist_del_init(&object->cookie_link);\r\nobject->cookie = NULL;\r\nfscache_invalidation_complete(cookie);\r\ndetached = true;\r\n}\r\nspin_unlock(&cookie->lock);\r\nfscache_cookie_put(cookie);\r\nif (detached)\r\nfscache_cookie_put(cookie);\r\n}\r\nspin_unlock(&object->lock);\r\nfscache_drop_object(object);\r\n}\r\nvoid fscache_withdrawing_object(struct fscache_cache *cache,\r\nstruct fscache_object *object)\r\n{\r\nbool enqueue = false;\r\n_enter(",OBJ%x", object->debug_id);\r\nspin_lock(&object->lock);\r\nif (object->state < FSCACHE_OBJECT_WITHDRAWING) {\r\nobject->state = FSCACHE_OBJECT_WITHDRAWING;\r\nenqueue = true;\r\n}\r\nspin_unlock(&object->lock);\r\nif (enqueue)\r\nfscache_enqueue_object(object);\r\n_leave("");\r\n}\r\nstatic int fscache_get_object(struct fscache_object *object)\r\n{\r\nint ret;\r\nfscache_stat(&fscache_n_cop_grab_object);\r\nret = object->cache->ops->grab_object(object) ? 0 : -EAGAIN;\r\nfscache_stat_d(&fscache_n_cop_grab_object);\r\nreturn ret;\r\n}\r\nstatic void fscache_put_object(struct fscache_object *object)\r\n{\r\nfscache_stat(&fscache_n_cop_put_object);\r\nobject->cache->ops->put_object(object);\r\nfscache_stat_d(&fscache_n_cop_put_object);\r\n}\r\nvoid fscache_enqueue_object(struct fscache_object *object)\r\n{\r\n_enter("{OBJ%x}", object->debug_id);\r\nif (fscache_get_object(object) >= 0) {\r\nwait_queue_head_t *cong_wq =\r\n&get_cpu_var(fscache_object_cong_wait);\r\nif (queue_work(fscache_object_wq, &object->work)) {\r\nif (fscache_object_congested())\r\nwake_up(cong_wq);\r\n} else\r\nfscache_put_object(object);\r\nput_cpu_var(fscache_object_cong_wait);\r\n}\r\n}\r\nbool fscache_object_sleep_till_congested(signed long *timeoutp)\r\n{\r\nwait_queue_head_t *cong_wq = &__get_cpu_var(fscache_object_cong_wait);\r\nDEFINE_WAIT(wait);\r\nif (fscache_object_congested())\r\nreturn true;\r\nadd_wait_queue_exclusive(cong_wq, &wait);\r\nif (!fscache_object_congested())\r\n*timeoutp = schedule_timeout(*timeoutp);\r\nfinish_wait(cong_wq, &wait);\r\nreturn fscache_object_congested();\r\n}\r\nstatic void fscache_enqueue_dependents(struct fscache_object *object)\r\n{\r\nstruct fscache_object *dep;\r\n_enter("{OBJ%x}", object->debug_id);\r\nif (list_empty(&object->dependents))\r\nreturn;\r\nspin_lock(&object->lock);\r\nwhile (!list_empty(&object->dependents)) {\r\ndep = list_entry(object->dependents.next,\r\nstruct fscache_object, dep_link);\r\nlist_del_init(&dep->dep_link);\r\nfscache_enqueue_object(dep);\r\nfscache_put_object(dep);\r\nif (!list_empty(&object->dependents))\r\ncond_resched_lock(&object->lock);\r\n}\r\nspin_unlock(&object->lock);\r\n}\r\nvoid fscache_dequeue_object(struct fscache_object *object)\r\n{\r\n_enter("{OBJ%x}", object->debug_id);\r\nif (!list_empty(&object->dep_link)) {\r\nspin_lock(&object->parent->lock);\r\nlist_del_init(&object->dep_link);\r\nspin_unlock(&object->parent->lock);\r\n}\r\n_leave("");\r\n}\r\nenum fscache_checkaux fscache_check_aux(struct fscache_object *object,\r\nconst void *data, uint16_t datalen)\r\n{\r\nenum fscache_checkaux result;\r\nif (!object->cookie->def->check_aux) {\r\nfscache_stat(&fscache_n_checkaux_none);\r\nreturn FSCACHE_CHECKAUX_OKAY;\r\n}\r\nresult = object->cookie->def->check_aux(object->cookie->netfs_data,\r\ndata, datalen);\r\nswitch (result) {\r\ncase FSCACHE_CHECKAUX_OKAY:\r\nfscache_stat(&fscache_n_checkaux_okay);\r\nbreak;\r\ncase FSCACHE_CHECKAUX_NEEDS_UPDATE:\r\nfscache_stat(&fscache_n_checkaux_update);\r\nbreak;\r\ncase FSCACHE_CHECKAUX_OBSOLETE:\r\nfscache_stat(&fscache_n_checkaux_obsolete);\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\nreturn result;\r\n}\r\nstatic void fscache_invalidate_object(struct fscache_object *object)\r\n{\r\nstruct fscache_operation *op;\r\nstruct fscache_cookie *cookie = object->cookie;\r\n_enter("{OBJ%x}", object->debug_id);\r\nfscache_invalidate_writes(cookie);\r\nclear_bit(FSCACHE_OBJECT_PENDING_WRITE, &object->flags);\r\nfscache_cancel_all_ops(object);\r\nop = kzalloc(sizeof(*op), GFP_KERNEL);\r\nif (!op) {\r\nfscache_raise_event(object, FSCACHE_OBJECT_EV_ERROR);\r\n_leave(" [ENOMEM]");\r\nreturn;\r\n}\r\nfscache_operation_init(op, object->cache->ops->invalidate_object, NULL);\r\nop->flags = FSCACHE_OP_ASYNC | (1 << FSCACHE_OP_EXCLUSIVE);\r\nspin_lock(&cookie->lock);\r\nif (fscache_submit_exclusive_op(object, op) < 0)\r\ngoto submit_op_failed;\r\nspin_unlock(&cookie->lock);\r\nfscache_put_operation(op);\r\nset_bit(FSCACHE_COOKIE_NO_DATA_YET, &cookie->flags);\r\nfscache_invalidation_complete(cookie);\r\n_leave("");\r\nreturn;\r\nsubmit_op_failed:\r\nspin_unlock(&cookie->lock);\r\nkfree(op);\r\nfscache_raise_event(object, FSCACHE_OBJECT_EV_ERROR);\r\n_leave(" [EIO]");\r\n}
