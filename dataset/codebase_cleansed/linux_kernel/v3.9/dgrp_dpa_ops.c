void dgrp_register_dpa_hook(struct proc_dir_entry *de)\r\n{\r\nstruct nd_struct *node = de->data;\r\nde->proc_iops = &dpa_inode_ops;\r\nde->proc_fops = &dpa_ops;\r\nnode->nd_dpa_de = de;\r\nspin_lock_init(&node->nd_dpa_lock);\r\n}\r\nstatic int dgrp_dpa_open(struct inode *inode, struct file *file)\r\n{\r\nstruct nd_struct *nd;\r\nint rtn = 0;\r\nstruct proc_dir_entry *de;\r\nrtn = try_module_get(THIS_MODULE);\r\nif (!rtn)\r\nreturn -ENXIO;\r\nrtn = 0;\r\nif (!capable(CAP_SYS_ADMIN)) {\r\nrtn = -EPERM;\r\ngoto done;\r\n}\r\nif (file->private_data) {\r\nrtn = -EINVAL;\r\ngoto done;\r\n}\r\nde = PDE(inode);\r\nif (!de) {\r\nrtn = -ENXIO;\r\ngoto done;\r\n}\r\nnd = (struct nd_struct *)de->data;\r\nif (!nd) {\r\nrtn = -ENXIO;\r\ngoto done;\r\n}\r\nfile->private_data = (void *) nd;\r\nif (nd->nd_dpa_buf) {\r\nrtn = -EBUSY;\r\n} else {\r\nnd->nd_dpa_buf = kmalloc(DPA_MAX, GFP_KERNEL);\r\nif (!nd->nd_dpa_buf) {\r\nrtn = -ENOMEM;\r\n} else {\r\nnd->nd_dpa_out = 0;\r\nnd->nd_dpa_in = 0;\r\nnd->nd_dpa_lbolt = jiffies;\r\n}\r\n}\r\ndone:\r\nif (rtn)\r\nmodule_put(THIS_MODULE);\r\nreturn rtn;\r\n}\r\nstatic int dgrp_dpa_release(struct inode *inode, struct file *file)\r\n{\r\nstruct nd_struct *nd;\r\nu8 *buf;\r\nunsigned long lock_flags;\r\nnd = (struct nd_struct *)(file->private_data);\r\nif (!nd)\r\ngoto done;\r\nspin_lock_irqsave(&nd->nd_dpa_lock, lock_flags);\r\nbuf = nd->nd_dpa_buf;\r\nnd->nd_dpa_buf = NULL;\r\nnd->nd_dpa_out = nd->nd_dpa_in;\r\nif (nd->nd_dpa_flag & DPA_WAIT_SPACE) {\r\nnd->nd_dpa_flag &= ~DPA_WAIT_SPACE;\r\nwake_up_interruptible(&nd->nd_dpa_wqueue);\r\n}\r\nspin_unlock_irqrestore(&nd->nd_dpa_lock, lock_flags);\r\nkfree(buf);\r\ndone:\r\nmodule_put(THIS_MODULE);\r\nfile->private_data = NULL;\r\nreturn 0;\r\n}\r\nstatic ssize_t dgrp_dpa_read(struct file *file, char __user *buf, size_t count,\r\nloff_t *ppos)\r\n{\r\nstruct nd_struct *nd;\r\nint n;\r\nint r;\r\nint offset = 0;\r\nint res = 0;\r\nssize_t rtn;\r\nunsigned long lock_flags;\r\nnd = (struct nd_struct *)(file->private_data);\r\nif (!nd)\r\nreturn -ENXIO;\r\nspin_lock_irqsave(&nd->nd_dpa_lock, lock_flags);\r\nfor (;;) {\r\nn = (nd->nd_dpa_in - nd->nd_dpa_out) & DPA_MASK;\r\nif (n != 0)\r\nbreak;\r\nnd->nd_dpa_flag |= DPA_WAIT_DATA;\r\nspin_unlock_irqrestore(&nd->nd_dpa_lock, lock_flags);\r\nrtn = wait_event_interruptible(nd->nd_dpa_wqueue,\r\n((nd->nd_dpa_flag & DPA_WAIT_DATA) == 0));\r\nif (rtn)\r\nreturn rtn;\r\nspin_lock_irqsave(&nd->nd_dpa_lock, lock_flags);\r\n}\r\nif (n > count)\r\nn = count;\r\nres = n;\r\nr = DPA_MAX - nd->nd_dpa_out;\r\nif (r <= n) {\r\nspin_unlock_irqrestore(&nd->nd_dpa_lock, lock_flags);\r\nrtn = copy_to_user((void __user *)buf,\r\nnd->nd_dpa_buf + nd->nd_dpa_out, r);\r\nspin_lock_irqsave(&nd->nd_dpa_lock, lock_flags);\r\nif (rtn) {\r\nrtn = -EFAULT;\r\ngoto done;\r\n}\r\nnd->nd_dpa_out = 0;\r\nn -= r;\r\noffset = r;\r\n}\r\nspin_unlock_irqrestore(&nd->nd_dpa_lock, lock_flags);\r\nrtn = copy_to_user((void __user *)buf + offset,\r\nnd->nd_dpa_buf + nd->nd_dpa_out, n);\r\nspin_lock_irqsave(&nd->nd_dpa_lock, lock_flags);\r\nif (rtn) {\r\nrtn = -EFAULT;\r\ngoto done;\r\n}\r\nnd->nd_dpa_out += n;\r\n*ppos += res;\r\nrtn = res;\r\nn = (nd->nd_dpa_in - nd->nd_dpa_out) & DPA_MASK;\r\nif (nd->nd_dpa_flag & DPA_WAIT_SPACE &&\r\n(DPA_MAX - n) > DPA_HIGH_WATER) {\r\nnd->nd_dpa_flag &= ~DPA_WAIT_SPACE;\r\nwake_up_interruptible(&nd->nd_dpa_wqueue);\r\n}\r\ndone:\r\nspin_unlock_irqrestore(&nd->nd_dpa_lock, lock_flags);\r\nreturn rtn;\r\n}\r\nstatic unsigned int dgrp_dpa_select(struct file *file,\r\nstruct poll_table_struct *table)\r\n{\r\nunsigned int retval = 0;\r\nstruct nd_struct *nd = file->private_data;\r\nif (nd->nd_dpa_out != nd->nd_dpa_in)\r\nretval |= POLLIN | POLLRDNORM;\r\nretval |= POLLOUT | POLLWRNORM;\r\nreturn retval;\r\n}\r\nstatic long dgrp_dpa_ioctl(struct file *file, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\nstruct nd_struct *nd;\r\nstruct digi_chan getchan;\r\nstruct digi_node getnode;\r\nstruct ch_struct *ch;\r\nstruct digi_debug setdebug;\r\nstruct digi_vpd vpd;\r\nunsigned int port;\r\nvoid __user *uarg = (void __user *) arg;\r\nnd = file->private_data;\r\nswitch (cmd) {\r\ncase DIGI_GETCHAN:\r\nif (copy_from_user(&getchan, uarg, sizeof(struct digi_chan)))\r\nreturn -EFAULT;\r\nport = getchan.ch_port;\r\nif (port > nd->nd_chan_count)\r\nreturn -EINVAL;\r\nch = nd->nd_chan + port;\r\ngetchan.ch_open = (ch->ch_open_count > 0) ? 1 : 0;\r\ngetchan.ch_txcount = ch->ch_txcount;\r\ngetchan.ch_rxcount = ch->ch_rxcount;\r\ngetchan.ch_s_brate = ch->ch_s_brate;\r\ngetchan.ch_s_estat = ch->ch_s_elast;\r\ngetchan.ch_s_cflag = ch->ch_s_cflag;\r\ngetchan.ch_s_iflag = ch->ch_s_iflag;\r\ngetchan.ch_s_oflag = ch->ch_s_oflag;\r\ngetchan.ch_s_xflag = ch->ch_s_xflag;\r\ngetchan.ch_s_mstat = ch->ch_s_mlast;\r\nif (copy_to_user(uarg, &getchan, sizeof(struct digi_chan)))\r\nreturn -EFAULT;\r\nbreak;\r\ncase DIGI_GETNODE:\r\ngetnode.nd_state = (nd->nd_state & NS_READY) ? 1 : 0;\r\ngetnode.nd_chan_count = nd->nd_chan_count;\r\ngetnode.nd_tx_byte = nd->nd_tx_byte;\r\ngetnode.nd_rx_byte = nd->nd_rx_byte;\r\nmemset(&getnode.nd_ps_desc, 0, MAX_DESC_LEN);\r\nstrncpy(getnode.nd_ps_desc, nd->nd_ps_desc, MAX_DESC_LEN);\r\nif (copy_to_user(uarg, &getnode, sizeof(struct digi_node)))\r\nreturn -EFAULT;\r\nbreak;\r\ncase DIGI_SETDEBUG:\r\nif (copy_from_user(&setdebug, uarg, sizeof(struct digi_debug)))\r\nreturn -EFAULT;\r\nnd->nd_dpa_debug = setdebug.onoff;\r\nnd->nd_dpa_port = setdebug.port;\r\nbreak;\r\ncase DIGI_GETVPD:\r\nif (nd->nd_vpd_len > 0) {\r\nvpd.vpd_len = nd->nd_vpd_len;\r\nmemcpy(&vpd.vpd_data, &nd->nd_vpd, nd->nd_vpd_len);\r\n} else {\r\nvpd.vpd_len = 0;\r\n}\r\nif (copy_to_user(uarg, &vpd, sizeof(struct digi_vpd)))\r\nreturn -EFAULT;\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic void dgrp_dpa(struct nd_struct *nd, u8 *buf, int nbuf)\r\n{\r\nint n;\r\nint r;\r\nunsigned long lock_flags;\r\nspin_lock_irqsave(&nd->nd_dpa_lock, lock_flags);\r\nwhile (nbuf > 0 && nd->nd_dpa_buf != NULL) {\r\nn = (nd->nd_dpa_out - nd->nd_dpa_in - 1) & DPA_MASK;\r\nif (n < (DPA_MAX - DPA_HIGH_WATER))\r\nnd->nd_dpa_flag |= DPA_WAIT_SPACE;\r\nif (n == 0) {\r\nspin_unlock_irqrestore(&nd->nd_dpa_lock, lock_flags);\r\nreturn;\r\n}\r\nif (n > nbuf)\r\nn = nbuf;\r\nr = DPA_MAX - nd->nd_dpa_in;\r\nif (r <= n) {\r\nmemcpy(nd->nd_dpa_buf + nd->nd_dpa_in, buf, r);\r\nn -= r;\r\nnd->nd_dpa_in = 0;\r\nbuf += r;\r\nnbuf -= r;\r\n}\r\nmemcpy(nd->nd_dpa_buf + nd->nd_dpa_in, buf, n);\r\nnd->nd_dpa_in += n;\r\nbuf += n;\r\nnbuf -= n;\r\nif (nd->nd_dpa_in >= DPA_MAX)\r\npr_info_ratelimited("%s - nd->nd_dpa_in (%i) >= DPA_MAX\n",\r\n__func__, nd->nd_dpa_in);\r\nif (nd->nd_dpa_flag & DPA_WAIT_DATA) {\r\nnd->nd_dpa_flag &= ~DPA_WAIT_DATA;\r\nwake_up_interruptible(&nd->nd_dpa_wqueue);\r\n}\r\n}\r\nspin_unlock_irqrestore(&nd->nd_dpa_lock, lock_flags);\r\n}\r\nvoid dgrp_dpa_data(struct nd_struct *nd, int type, u8 *buf, int size)\r\n{\r\nu8 header[5];\r\nheader[0] = type;\r\nput_unaligned_be32(size, header + 1);\r\ndgrp_dpa(nd, header, sizeof(header));\r\ndgrp_dpa(nd, buf, size);\r\n}
