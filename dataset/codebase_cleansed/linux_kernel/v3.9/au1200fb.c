static int winbpp (unsigned int winctrl1)\r\n{\r\nint bits = 0;\r\nswitch (winctrl1 & LCD_WINCTRL1_FRM) {\r\ncase LCD_WINCTRL1_FRM_1BPP:\r\nbits = 1;\r\nbreak;\r\ncase LCD_WINCTRL1_FRM_2BPP:\r\nbits = 2;\r\nbreak;\r\ncase LCD_WINCTRL1_FRM_4BPP:\r\nbits = 4;\r\nbreak;\r\ncase LCD_WINCTRL1_FRM_8BPP:\r\nbits = 8;\r\nbreak;\r\ncase LCD_WINCTRL1_FRM_12BPP:\r\ncase LCD_WINCTRL1_FRM_16BPP655:\r\ncase LCD_WINCTRL1_FRM_16BPP565:\r\ncase LCD_WINCTRL1_FRM_16BPP556:\r\ncase LCD_WINCTRL1_FRM_16BPPI1555:\r\ncase LCD_WINCTRL1_FRM_16BPPI5551:\r\ncase LCD_WINCTRL1_FRM_16BPPA1555:\r\ncase LCD_WINCTRL1_FRM_16BPPA5551:\r\nbits = 16;\r\nbreak;\r\ncase LCD_WINCTRL1_FRM_24BPP:\r\ncase LCD_WINCTRL1_FRM_32BPP:\r\nbits = 32;\r\nbreak;\r\n}\r\nreturn bits;\r\n}\r\nstatic int fbinfo2index (struct fb_info *fb_info)\r\n{\r\nint i;\r\nfor (i = 0; i < device_count; ++i) {\r\nif (fb_info == _au1200fb_infos[i])\r\nreturn i;\r\n}\r\nprintk("au1200fb: ERROR: fbinfo2index failed!\n");\r\nreturn -1;\r\n}\r\nstatic int au1200_setlocation (struct au1200fb_device *fbdev, int plane,\r\nint xpos, int ypos)\r\n{\r\nuint32 winctrl0, winctrl1, winenable, fb_offset = 0;\r\nint xsz, ysz;\r\nwinctrl0 = lcd->window[plane].winctrl0;\r\nwinctrl1 = lcd->window[plane].winctrl1;\r\nwinctrl0 &= (LCD_WINCTRL0_A | LCD_WINCTRL0_AEN);\r\nwinctrl1 &= ~(LCD_WINCTRL1_SZX | LCD_WINCTRL1_SZY);\r\nxsz = win->w[plane].xres;\r\nysz = win->w[plane].yres;\r\nif ((xpos + win->w[plane].xres) > panel->Xres) {\r\nxsz = panel->Xres - xpos;\r\n}\r\nif ((ypos + win->w[plane].yres) > panel->Yres) {\r\nysz = panel->Yres - ypos;\r\n}\r\nif (xpos < 0) {\r\nxsz = win->w[plane].xres + xpos;\r\nfb_offset += (((0 - xpos) * winbpp(lcd->window[plane].winctrl1))/8);\r\nxpos = 0;\r\n}\r\nif (ypos < 0) {\r\nysz = win->w[plane].yres + ypos;\r\nypos = 0;\r\n}\r\nwin->w[plane].xpos = xpos;\r\nwin->w[plane].ypos = ypos;\r\nxsz -= 1;\r\nysz -= 1;\r\nwinctrl0 |= (xpos << 21);\r\nwinctrl0 |= (ypos << 10);\r\nwinctrl1 |= (xsz << 11);\r\nwinctrl1 |= (ysz << 0);\r\nwinenable = lcd->winenable & (1 << plane);\r\nau_sync();\r\nlcd->winenable &= ~(1 << plane);\r\nlcd->window[plane].winctrl0 = winctrl0;\r\nlcd->window[plane].winctrl1 = winctrl1;\r\nlcd->window[plane].winbuf0 =\r\nlcd->window[plane].winbuf1 = fbdev->fb_phys;\r\nlcd->window[plane].winbufctrl = 0;\r\nlcd->winenable |= winenable;\r\nau_sync();\r\nreturn 0;\r\n}\r\nstatic void au1200_setpanel(struct panel_settings *newpanel,\r\nstruct au1200fb_platdata *pd)\r\n{\r\nuint32 winenable;\r\nwinenable = lcd->winenable;\r\nlcd->winenable = 0;\r\nau_sync();\r\nif (lcd->screen & LCD_SCREEN_SEN) {\r\nlcd->intstatus = LCD_INT_SS;\r\nwhile ((lcd->intstatus & LCD_INT_SS) == 0) {\r\nau_sync();\r\n}\r\nlcd->screen &= ~LCD_SCREEN_SEN;\r\ndo {\r\nlcd->intstatus = lcd->intstatus;\r\nau_sync();\r\n} while ((lcd->intstatus & LCD_INT_SD) == 0);\r\nif (pd->panel_shutdown)\r\npd->panel_shutdown();\r\n}\r\nif (newpanel == NULL)\r\nreturn;\r\npanel = newpanel;\r\nprintk("Panel(%s), %dx%d\n", panel->name, panel->Xres, panel->Yres);\r\nif (!(panel->mode_clkcontrol & LCD_CLKCONTROL_EXT))\r\n{\r\nuint32 sys_clksrc;\r\nau_writel(panel->mode_auxpll, SYS_AUXPLL);\r\nsys_clksrc = au_readl(SYS_CLKSRC) & ~0x0000001f;\r\nsys_clksrc |= panel->mode_toyclksrc;\r\nau_writel(sys_clksrc, SYS_CLKSRC);\r\n}\r\nlcd->screen = panel->mode_screen;\r\nlcd->horztiming = panel->mode_horztiming;\r\nlcd->verttiming = panel->mode_verttiming;\r\nlcd->clkcontrol = panel->mode_clkcontrol;\r\nlcd->pwmdiv = panel->mode_pwmdiv;\r\nlcd->pwmhi = panel->mode_pwmhi;\r\nlcd->outmask = panel->mode_outmask;\r\nlcd->fifoctrl = panel->mode_fifoctrl;\r\nau_sync();\r\n#if 0\r\nau1200_setlocation(fbdev, 0, win->w[0].xpos, win->w[0].ypos);\r\nau1200_setlocation(fbdev, 1, win->w[1].xpos, win->w[1].ypos);\r\nau1200_setlocation(fbdev, 2, win->w[2].xpos, win->w[2].ypos);\r\nau1200_setlocation(fbdev, 3, win->w[3].xpos, win->w[3].ypos);\r\n#endif\r\nlcd->winenable = winenable;\r\nlcd->screen |= LCD_SCREEN_SEN;\r\nau_sync();\r\nif (pd->panel_init)\r\npd->panel_init();\r\nlcd->intenable = 0;\r\nlcd->intstatus = ~0;\r\nlcd->backcolor = win->mode_backcolor;\r\nlcd->colorkey = win->mode_colorkey;\r\nlcd->colorkeymsk = win->mode_colorkeymsk;\r\nlcd->hwc.cursorctrl = 0;\r\nlcd->hwc.cursorpos = 0;\r\nlcd->hwc.cursorcolor0 = 0;\r\nlcd->hwc.cursorcolor1 = 0;\r\nlcd->hwc.cursorcolor2 = 0;\r\nlcd->hwc.cursorcolor3 = 0;\r\n#if 0\r\n#define D(X) printk("%25s: %08X\n", #X, X)\r\nD(lcd->screen);\r\nD(lcd->horztiming);\r\nD(lcd->verttiming);\r\nD(lcd->clkcontrol);\r\nD(lcd->pwmdiv);\r\nD(lcd->pwmhi);\r\nD(lcd->outmask);\r\nD(lcd->fifoctrl);\r\nD(lcd->window[0].winctrl0);\r\nD(lcd->window[0].winctrl1);\r\nD(lcd->window[0].winctrl2);\r\nD(lcd->window[0].winbuf0);\r\nD(lcd->window[0].winbuf1);\r\nD(lcd->window[0].winbufctrl);\r\nD(lcd->window[1].winctrl0);\r\nD(lcd->window[1].winctrl1);\r\nD(lcd->window[1].winctrl2);\r\nD(lcd->window[1].winbuf0);\r\nD(lcd->window[1].winbuf1);\r\nD(lcd->window[1].winbufctrl);\r\nD(lcd->window[2].winctrl0);\r\nD(lcd->window[2].winctrl1);\r\nD(lcd->window[2].winctrl2);\r\nD(lcd->window[2].winbuf0);\r\nD(lcd->window[2].winbuf1);\r\nD(lcd->window[2].winbufctrl);\r\nD(lcd->window[3].winctrl0);\r\nD(lcd->window[3].winctrl1);\r\nD(lcd->window[3].winctrl2);\r\nD(lcd->window[3].winbuf0);\r\nD(lcd->window[3].winbuf1);\r\nD(lcd->window[3].winbufctrl);\r\nD(lcd->winenable);\r\nD(lcd->intenable);\r\nD(lcd->intstatus);\r\nD(lcd->backcolor);\r\nD(lcd->winenable);\r\nD(lcd->colorkey);\r\nD(lcd->colorkeymsk);\r\nD(lcd->hwc.cursorctrl);\r\nD(lcd->hwc.cursorpos);\r\nD(lcd->hwc.cursorcolor0);\r\nD(lcd->hwc.cursorcolor1);\r\nD(lcd->hwc.cursorcolor2);\r\nD(lcd->hwc.cursorcolor3);\r\n#endif\r\n}\r\nstatic void au1200_setmode(struct au1200fb_device *fbdev)\r\n{\r\nint plane = fbdev->plane;\r\nlcd->window[plane].winctrl1 = ( 0\r\n| LCD_WINCTRL1_PRI_N(plane)\r\n| win->w[plane].mode_winctrl1\r\n) ;\r\nau1200_setlocation(fbdev, plane, win->w[plane].xpos, win->w[plane].ypos);\r\nlcd->window[plane].winctrl2 = ( 0\r\n| LCD_WINCTRL2_CKMODE_00\r\n| LCD_WINCTRL2_DBM\r\n| LCD_WINCTRL2_BX_N(fbdev->fb_info->fix.line_length)\r\n| LCD_WINCTRL2_SCX_1\r\n| LCD_WINCTRL2_SCY_1\r\n) ;\r\nlcd->winenable |= win->w[plane].mode_winenable;\r\nau_sync();\r\n}\r\nstatic void au1200fb_update_fbinfo(struct fb_info *fbi)\r\n{\r\nif (panel_is_color(panel)) {\r\nif (fbi->var.bits_per_pixel <= 8) {\r\nfbi->fix.visual = FB_VISUAL_PSEUDOCOLOR;\r\nfbi->fix.line_length = fbi->var.xres_virtual /\r\n(8/fbi->var.bits_per_pixel);\r\n} else {\r\nfbi->fix.visual = FB_VISUAL_TRUECOLOR;\r\nfbi->fix.line_length = fbi->var.xres_virtual * (fbi->var.bits_per_pixel / 8);\r\n}\r\n} else {\r\nfbi->fix.visual = FB_VISUAL_MONO10;\r\nfbi->fix.line_length = fbi->var.xres_virtual / 8;\r\n}\r\nfbi->screen_size = fbi->fix.line_length * fbi->var.yres_virtual;\r\nprint_dbg("line length: %d\n", fbi->fix.line_length);\r\nprint_dbg("bits_per_pixel: %d\n", fbi->var.bits_per_pixel);\r\n}\r\nstatic int au1200fb_fb_check_var(struct fb_var_screeninfo *var,\r\nstruct fb_info *fbi)\r\n{\r\nstruct au1200fb_device *fbdev = fbi->par;\r\nu32 pixclock;\r\nint screen_size, plane;\r\nplane = fbdev->plane;\r\nvar->xres = win->w[plane].xres;\r\nvar->yres = win->w[plane].yres;\r\nvar->xres_virtual = var->xres;\r\nvar->yres_virtual = var->yres;\r\nvar->bits_per_pixel = winbpp(win->w[plane].mode_winctrl1);\r\nscreen_size = var->xres_virtual * var->yres_virtual;\r\nif (var->bits_per_pixel > 8) screen_size *= (var->bits_per_pixel / 8);\r\nelse screen_size /= (8/var->bits_per_pixel);\r\nif (fbdev->fb_len < screen_size)\r\nreturn -EINVAL;\r\npixclock = max((u32)(PICOS2KHZ(var->pixclock) * 1000), fbi->monspecs.dclkmin);\r\npixclock = min3(pixclock, fbi->monspecs.dclkmax, (u32)AU1200_LCD_MAX_CLK/2);\r\nif (AU1200_LCD_MAX_CLK % pixclock) {\r\nint diff = AU1200_LCD_MAX_CLK % pixclock;\r\npixclock -= diff;\r\n}\r\nvar->pixclock = KHZ2PICOS(pixclock/1000);\r\n#if 0\r\nif (!panel_is_active(panel)) {\r\nint pcd = AU1200_LCD_MAX_CLK / (pixclock * 2) - 1;\r\nif (!panel_is_color(panel)\r\n&& (panel->control_base & LCD_CONTROL_MPI) && (pcd < 3)) {\r\nvar->pixclock = KHZ2PICOS(6000);\r\n} else if (!pcd) {\r\nvar->pixclock = KHZ2PICOS(12000);\r\n}\r\n}\r\n#endif\r\nswitch (var->bits_per_pixel) {\r\ncase 16:\r\n{\r\nint idx;\r\nidx = (win->w[0].mode_winctrl1 & LCD_WINCTRL1_FRM) >> 25;\r\nvar->red = rgb_bitfields[idx][0];\r\nvar->green = rgb_bitfields[idx][1];\r\nvar->blue = rgb_bitfields[idx][2];\r\nvar->transp = rgb_bitfields[idx][3];\r\nbreak;\r\n}\r\ncase 32:\r\n{\r\nint idx;\r\nidx = (win->w[0].mode_winctrl1 & LCD_WINCTRL1_FRM) >> 25;\r\nvar->red = rgb_bitfields[idx][0];\r\nvar->green = rgb_bitfields[idx][1];\r\nvar->blue = rgb_bitfields[idx][2];\r\nvar->transp = rgb_bitfields[idx][3];\r\nbreak;\r\n}\r\ndefault:\r\nprint_dbg("Unsupported depth %dbpp", var->bits_per_pixel);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int au1200fb_fb_set_par(struct fb_info *fbi)\r\n{\r\nstruct au1200fb_device *fbdev = fbi->par;\r\nau1200fb_update_fbinfo(fbi);\r\nau1200_setmode(fbdev);\r\nreturn 0;\r\n}\r\nstatic int au1200fb_fb_setcolreg(unsigned regno, unsigned red, unsigned green,\r\nunsigned blue, unsigned transp, struct fb_info *fbi)\r\n{\r\nvolatile u32 *palette = lcd->palette;\r\nu32 value;\r\nif (regno > (AU1200_LCD_NBR_PALETTE_ENTRIES - 1))\r\nreturn -EINVAL;\r\nif (fbi->var.grayscale) {\r\nred = green = blue =\r\n(19595 * red + 38470 * green + 7471 * blue) >> 16;\r\n}\r\nif (fbi->fix.visual == FB_VISUAL_TRUECOLOR) {\r\nif (regno > 16)\r\nreturn -EINVAL;\r\npalette = (u32*) fbi->pseudo_palette;\r\nred >>= (16 - fbi->var.red.length);\r\ngreen >>= (16 - fbi->var.green.length);\r\nblue >>= (16 - fbi->var.blue.length);\r\nvalue = (red << fbi->var.red.offset) |\r\n(green << fbi->var.green.offset)|\r\n(blue << fbi->var.blue.offset);\r\nvalue &= 0xFFFF;\r\n} else if (1 ) {\r\nvalue = (red & 0xF800)|((green >> 5) &\r\n0x07E0)|((blue >> 11) & 0x001F);\r\nvalue &= 0xFFFF;\r\n} else if (0 ) {\r\nvalue = 0x1234;\r\nvalue &= 0xFFF;\r\n} else {\r\nvalue = (green >> 12) & 0x000F;\r\nvalue &= 0xF;\r\n}\r\npalette[regno] = value;\r\nreturn 0;\r\n}\r\nstatic int au1200fb_fb_blank(int blank_mode, struct fb_info *fbi)\r\n{\r\nstruct au1200fb_device *fbdev = fbi->par;\r\nif (noblanking)\r\nreturn 0;\r\nswitch (blank_mode) {\r\ncase FB_BLANK_UNBLANK:\r\ncase FB_BLANK_NORMAL:\r\nau1200_setpanel(panel, fbdev->pd);\r\nbreak;\r\ncase FB_BLANK_VSYNC_SUSPEND:\r\ncase FB_BLANK_HSYNC_SUSPEND:\r\ncase FB_BLANK_POWERDOWN:\r\nau1200_setpanel(NULL, fbdev->pd);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn (blank_mode == FB_BLANK_NORMAL) ? -EINVAL : 0;\r\n}\r\nstatic int au1200fb_fb_mmap(struct fb_info *info, struct vm_area_struct *vma)\r\n{\r\nunsigned int len;\r\nunsigned long start=0, off;\r\nstruct au1200fb_device *fbdev = info->par;\r\nif (vma->vm_pgoff > (~0UL >> PAGE_SHIFT)) {\r\nreturn -EINVAL;\r\n}\r\nstart = fbdev->fb_phys & PAGE_MASK;\r\nlen = PAGE_ALIGN((start & ~PAGE_MASK) + fbdev->fb_len);\r\noff = vma->vm_pgoff << PAGE_SHIFT;\r\nif ((vma->vm_end - vma->vm_start + off) > len) {\r\nreturn -EINVAL;\r\n}\r\noff += start;\r\nvma->vm_pgoff = off >> PAGE_SHIFT;\r\nvma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);\r\npgprot_val(vma->vm_page_prot) |= _CACHE_MASK;\r\nvma->vm_flags |= VM_IO;\r\nreturn io_remap_pfn_range(vma, vma->vm_start, off >> PAGE_SHIFT,\r\nvma->vm_end - vma->vm_start,\r\nvma->vm_page_prot);\r\nreturn 0;\r\n}\r\nstatic void set_global(u_int cmd, struct au1200_lcd_global_regs_t *pdata)\r\n{\r\nunsigned int hi1, divider;\r\nif (pdata->flags & SCREEN_BACKCOLOR)\r\nlcd->backcolor = pdata->backcolor;\r\nif (pdata->flags & SCREEN_BRIGHTNESS) {\r\nif (pdata->brightness < 30) {\r\npdata->brightness = 30;\r\n}\r\ndivider = (lcd->pwmdiv & 0x3FFFF) + 1;\r\nhi1 = (lcd->pwmhi >> 16) + 1;\r\nhi1 = (((pdata->brightness & 0xFF)+1) * divider >> 8);\r\nlcd->pwmhi &= 0xFFFF;\r\nlcd->pwmhi |= (hi1 << 16);\r\n}\r\nif (pdata->flags & SCREEN_COLORKEY)\r\nlcd->colorkey = pdata->colorkey;\r\nif (pdata->flags & SCREEN_MASK)\r\nlcd->colorkeymsk = pdata->mask;\r\nau_sync();\r\n}\r\nstatic void get_global(u_int cmd, struct au1200_lcd_global_regs_t *pdata)\r\n{\r\nunsigned int hi1, divider;\r\npdata->xsize = ((lcd->screen & LCD_SCREEN_SX) >> 19) + 1;\r\npdata->ysize = ((lcd->screen & LCD_SCREEN_SY) >> 8) + 1;\r\npdata->backcolor = lcd->backcolor;\r\npdata->colorkey = lcd->colorkey;\r\npdata->mask = lcd->colorkeymsk;\r\nhi1 = (lcd->pwmhi >> 16) + 1;\r\ndivider = (lcd->pwmdiv & 0x3FFFF) + 1;\r\npdata->brightness = ((hi1 << 8) / divider) - 1;\r\nau_sync();\r\n}\r\nstatic void set_window(unsigned int plane,\r\nstruct au1200_lcd_window_regs_t *pdata)\r\n{\r\nunsigned int val, bpp;\r\nif (pdata->flags & WIN_POSITION) {\r\nval = lcd->window[plane].winctrl0 & ~(LCD_WINCTRL0_OX |\r\nLCD_WINCTRL0_OY);\r\nval |= ((pdata->xpos << 21) & LCD_WINCTRL0_OX);\r\nval |= ((pdata->ypos << 10) & LCD_WINCTRL0_OY);\r\nlcd->window[plane].winctrl0 = val;\r\n}\r\nif (pdata->flags & WIN_ALPHA_COLOR) {\r\nval = lcd->window[plane].winctrl0 & ~(LCD_WINCTRL0_A);\r\nval |= ((pdata->alpha_color << 2) & LCD_WINCTRL0_A);\r\nlcd->window[plane].winctrl0 = val;\r\n}\r\nif (pdata->flags & WIN_ALPHA_MODE) {\r\nval = lcd->window[plane].winctrl0 & ~(LCD_WINCTRL0_AEN);\r\nval |= ((pdata->alpha_mode << 1) & LCD_WINCTRL0_AEN);\r\nlcd->window[plane].winctrl0 = val;\r\n}\r\nif (pdata->flags & WIN_PRIORITY) {\r\nval = lcd->window[plane].winctrl1 & ~(LCD_WINCTRL1_PRI);\r\nval |= ((pdata->priority << 30) & LCD_WINCTRL1_PRI);\r\nlcd->window[plane].winctrl1 = val;\r\n}\r\nif (pdata->flags & WIN_CHANNEL) {\r\nval = lcd->window[plane].winctrl1 & ~(LCD_WINCTRL1_PIPE);\r\nval |= ((pdata->channel << 29) & LCD_WINCTRL1_PIPE);\r\nlcd->window[plane].winctrl1 = val;\r\n}\r\nif (pdata->flags & WIN_BUFFER_FORMAT) {\r\nval = lcd->window[plane].winctrl1 & ~(LCD_WINCTRL1_FRM);\r\nval |= ((pdata->buffer_format << 25) & LCD_WINCTRL1_FRM);\r\nlcd->window[plane].winctrl1 = val;\r\n}\r\nif (pdata->flags & WIN_COLOR_ORDER) {\r\nval = lcd->window[plane].winctrl1 & ~(LCD_WINCTRL1_CCO);\r\nval |= ((pdata->color_order << 24) & LCD_WINCTRL1_CCO);\r\nlcd->window[plane].winctrl1 = val;\r\n}\r\nif (pdata->flags & WIN_PIXEL_ORDER) {\r\nval = lcd->window[plane].winctrl1 & ~(LCD_WINCTRL1_PO);\r\nval |= ((pdata->pixel_order << 22) & LCD_WINCTRL1_PO);\r\nlcd->window[plane].winctrl1 = val;\r\n}\r\nif (pdata->flags & WIN_SIZE) {\r\nval = lcd->window[plane].winctrl1 & ~(LCD_WINCTRL1_SZX |\r\nLCD_WINCTRL1_SZY);\r\nval |= (((pdata->xsize << 11) - 1) & LCD_WINCTRL1_SZX);\r\nval |= (((pdata->ysize) - 1) & LCD_WINCTRL1_SZY);\r\nlcd->window[plane].winctrl1 = val;\r\nbpp = winbpp(val) / 8;\r\nval = lcd->window[plane].winctrl2 & ~(LCD_WINCTRL2_BX);\r\nval |= (((pdata->xsize * bpp) << 8) & LCD_WINCTRL2_BX);\r\nlcd->window[plane].winctrl2 = val;\r\n}\r\nif (pdata->flags & WIN_COLORKEY_MODE) {\r\nval = lcd->window[plane].winctrl2 & ~(LCD_WINCTRL2_CKMODE);\r\nval |= ((pdata->colorkey_mode << 24) & LCD_WINCTRL2_CKMODE);\r\nlcd->window[plane].winctrl2 = val;\r\n}\r\nif (pdata->flags & WIN_DOUBLE_BUFFER_MODE) {\r\nval = lcd->window[plane].winctrl2 & ~(LCD_WINCTRL2_DBM);\r\nval |= ((pdata->double_buffer_mode << 23) & LCD_WINCTRL2_DBM);\r\nlcd->window[plane].winctrl2 = val;\r\n}\r\nif (pdata->flags & WIN_RAM_ARRAY_MODE) {\r\nval = lcd->window[plane].winctrl2 & ~(LCD_WINCTRL2_RAM);\r\nval |= ((pdata->ram_array_mode << 21) & LCD_WINCTRL2_RAM);\r\nlcd->window[plane].winctrl2 = val;\r\n}\r\nif (pdata->flags & WIN_BUFFER_SCALE) {\r\nval = lcd->window[plane].winctrl2 & ~(LCD_WINCTRL2_SCX |\r\nLCD_WINCTRL2_SCY);\r\nval |= ((pdata->xsize << 11) & LCD_WINCTRL2_SCX);\r\nval |= ((pdata->ysize) & LCD_WINCTRL2_SCY);\r\nlcd->window[plane].winctrl2 = val;\r\n}\r\nif (pdata->flags & WIN_ENABLE) {\r\nval = lcd->winenable;\r\nval &= ~(1<<plane);\r\nval |= (pdata->enable & 1) << plane;\r\nlcd->winenable = val;\r\n}\r\nau_sync();\r\n}\r\nstatic void get_window(unsigned int plane,\r\nstruct au1200_lcd_window_regs_t *pdata)\r\n{\r\npdata->xpos = (lcd->window[plane].winctrl0 & LCD_WINCTRL0_OX) >> 21;\r\npdata->ypos = (lcd->window[plane].winctrl0 & LCD_WINCTRL0_OY) >> 10;\r\npdata->alpha_color = (lcd->window[plane].winctrl0 & LCD_WINCTRL0_A) >> 2;\r\npdata->alpha_mode = (lcd->window[plane].winctrl0 & LCD_WINCTRL0_AEN) >> 1;\r\npdata->priority = (lcd->window[plane].winctrl1& LCD_WINCTRL1_PRI) >> 30;\r\npdata->channel = (lcd->window[plane].winctrl1 & LCD_WINCTRL1_PIPE) >> 29;\r\npdata->buffer_format = (lcd->window[plane].winctrl1 & LCD_WINCTRL1_FRM) >> 25;\r\npdata->color_order = (lcd->window[plane].winctrl1 & LCD_WINCTRL1_CCO) >> 24;\r\npdata->pixel_order = (lcd->window[plane].winctrl1 & LCD_WINCTRL1_PO) >> 22;\r\npdata->xsize = ((lcd->window[plane].winctrl1 & LCD_WINCTRL1_SZX) >> 11) + 1;\r\npdata->ysize = (lcd->window[plane].winctrl1 & LCD_WINCTRL1_SZY) + 1;\r\npdata->colorkey_mode = (lcd->window[plane].winctrl2 & LCD_WINCTRL2_CKMODE) >> 24;\r\npdata->double_buffer_mode = (lcd->window[plane].winctrl2 & LCD_WINCTRL2_DBM) >> 23;\r\npdata->ram_array_mode = (lcd->window[plane].winctrl2 & LCD_WINCTRL2_RAM) >> 21;\r\npdata->enable = (lcd->winenable >> plane) & 1;\r\nau_sync();\r\n}\r\nstatic int au1200fb_ioctl(struct fb_info *info, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\nstruct au1200fb_device *fbdev = info->par;\r\nint plane;\r\nint val;\r\nplane = fbinfo2index(info);\r\nprint_dbg("au1200fb: ioctl %d on plane %d\n", cmd, plane);\r\nif (cmd == AU1200_LCD_FB_IOCTL) {\r\nstruct au1200_lcd_iodata_t iodata;\r\nif (copy_from_user(&iodata, (void __user *) arg, sizeof(iodata)))\r\nreturn -EFAULT;\r\nprint_dbg("FB IOCTL called\n");\r\nswitch (iodata.subcmd) {\r\ncase AU1200_LCD_SET_SCREEN:\r\nprint_dbg("AU1200_LCD_SET_SCREEN\n");\r\nset_global(cmd, &iodata.global);\r\nbreak;\r\ncase AU1200_LCD_GET_SCREEN:\r\nprint_dbg("AU1200_LCD_GET_SCREEN\n");\r\nget_global(cmd, &iodata.global);\r\nbreak;\r\ncase AU1200_LCD_SET_WINDOW:\r\nprint_dbg("AU1200_LCD_SET_WINDOW\n");\r\nset_window(plane, &iodata.window);\r\nbreak;\r\ncase AU1200_LCD_GET_WINDOW:\r\nprint_dbg("AU1200_LCD_GET_WINDOW\n");\r\nget_window(plane, &iodata.window);\r\nbreak;\r\ncase AU1200_LCD_SET_PANEL:\r\nprint_dbg("AU1200_LCD_SET_PANEL\n");\r\nif ((iodata.global.panel_choice >= 0) &&\r\n(iodata.global.panel_choice <\r\nNUM_PANELS))\r\n{\r\nstruct panel_settings *newpanel;\r\npanel_index = iodata.global.panel_choice;\r\nnewpanel = &known_lcd_panels[panel_index];\r\nau1200_setpanel(newpanel, fbdev->pd);\r\n}\r\nbreak;\r\ncase AU1200_LCD_GET_PANEL:\r\nprint_dbg("AU1200_LCD_GET_PANEL\n");\r\niodata.global.panel_choice = panel_index;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nval = copy_to_user((void __user *) arg, &iodata, sizeof(iodata));\r\nif (val) {\r\nprint_dbg("error: could not copy %d bytes\n", val);\r\nreturn -EFAULT;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic irqreturn_t au1200fb_handle_irq(int irq, void* dev_id)\r\n{\r\nlcd->intstatus = lcd->intstatus;\r\nau_sync();\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int au1200fb_init_fbinfo(struct au1200fb_device *fbdev)\r\n{\r\nstruct fb_info *fbi = fbdev->fb_info;\r\nint bpp;\r\nfbi->fbops = &au1200fb_fb_ops;\r\nbpp = winbpp(win->w[fbdev->plane].mode_winctrl1);\r\nmemcpy(&fbi->monspecs, &panel->monspecs, sizeof(struct fb_monspecs));\r\nif (!fb_find_mode(&fbi->var,\r\nfbi,\r\nNULL,\r\nfbi->monspecs.modedb,\r\nfbi->monspecs.modedb_len,\r\nfbi->monspecs.modedb,\r\nbpp)) {\r\nprint_err("Cannot find valid mode for panel %s", panel->name);\r\nreturn -EFAULT;\r\n}\r\nfbi->pseudo_palette = kcalloc(16, sizeof(u32), GFP_KERNEL);\r\nif (!fbi->pseudo_palette) {\r\nreturn -ENOMEM;\r\n}\r\nif (fb_alloc_cmap(&fbi->cmap, AU1200_LCD_NBR_PALETTE_ENTRIES, 0) < 0) {\r\nprint_err("Fail to allocate colormap (%d entries)",\r\nAU1200_LCD_NBR_PALETTE_ENTRIES);\r\nkfree(fbi->pseudo_palette);\r\nreturn -EFAULT;\r\n}\r\nstrncpy(fbi->fix.id, "AU1200", sizeof(fbi->fix.id));\r\nfbi->fix.smem_start = fbdev->fb_phys;\r\nfbi->fix.smem_len = fbdev->fb_len;\r\nfbi->fix.type = FB_TYPE_PACKED_PIXELS;\r\nfbi->fix.xpanstep = 0;\r\nfbi->fix.ypanstep = 0;\r\nfbi->fix.mmio_start = 0;\r\nfbi->fix.mmio_len = 0;\r\nfbi->fix.accel = FB_ACCEL_NONE;\r\nfbi->screen_base = (char __iomem *) fbdev->fb_mem;\r\nau1200fb_update_fbinfo(fbi);\r\nreturn 0;\r\n}\r\nstatic int au1200fb_setup(struct au1200fb_platdata *pd)\r\n{\r\nchar *options = NULL;\r\nchar *this_opt, *endptr;\r\nint num_panels = ARRAY_SIZE(known_lcd_panels);\r\nint panel_idx = -1;\r\nfb_get_options(DRIVER_NAME, &options);\r\nif (!options)\r\ngoto out;\r\nwhile ((this_opt = strsep(&options, ",")) != NULL) {\r\nif (!strncmp(this_opt, "panel:", 6)) {\r\nint i;\r\nlong int li;\r\nchar *endptr;\r\nthis_opt += 6;\r\nli = simple_strtol(this_opt, &endptr, 0);\r\nif (*endptr == '\0')\r\npanel_idx = (int)li;\r\nelse if (strcmp(this_opt, "bs") == 0)\r\npanel_idx = pd->panel_index();\r\nelse {\r\nfor (i = 0; i < num_panels; i++) {\r\nif (!strcmp(this_opt,\r\nknown_lcd_panels[i].name)) {\r\npanel_idx = i;\r\nbreak;\r\n}\r\n}\r\n}\r\nif ((panel_idx < 0) || (panel_idx >= num_panels))\r\nprint_warn("Panel %s not supported!", this_opt);\r\nelse\r\npanel_index = panel_idx;\r\n} else if (strncmp(this_opt, "nohwcursor", 10) == 0)\r\nnohwcursor = 1;\r\nelse if (strncmp(this_opt, "devices:", 8) == 0) {\r\nthis_opt += 8;\r\ndevice_count = simple_strtol(this_opt, &endptr, 0);\r\nif ((device_count < 0) ||\r\n(device_count > MAX_DEVICE_COUNT))\r\ndevice_count = MAX_DEVICE_COUNT;\r\n} else if (strncmp(this_opt, "wincfg:", 7) == 0) {\r\nthis_opt += 7;\r\nwindow_index = simple_strtol(this_opt, &endptr, 0);\r\nif ((window_index < 0) ||\r\n(window_index >= ARRAY_SIZE(windows)))\r\nwindow_index = DEFAULT_WINDOW_INDEX;\r\n} else if (strncmp(this_opt, "off", 3) == 0)\r\nreturn 1;\r\nelse\r\nprint_warn("Unsupported option \"%s\"", this_opt);\r\n}\r\nout:\r\nreturn 0;\r\n}\r\nstatic int au1200fb_drv_probe(struct platform_device *dev)\r\n{\r\nstruct au1200fb_device *fbdev;\r\nstruct au1200fb_platdata *pd;\r\nstruct fb_info *fbi = NULL;\r\nunsigned long page;\r\nint bpp, plane, ret, irq;\r\nprint_info("" DRIVER_DESC "");\r\npd = dev->dev.platform_data;\r\nif (!pd)\r\nreturn -ENODEV;\r\nif (au1200fb_setup(pd))\r\nreturn -ENODEV;\r\npanel = &known_lcd_panels[panel_index];\r\nwin = &windows[window_index];\r\nprintk(DRIVER_NAME ": Panel %d %s\n", panel_index, panel->name);\r\nprintk(DRIVER_NAME ": Win %d %s\n", window_index, win->name);\r\nret = 0;\r\nfbdev = NULL;\r\nfor (plane = 0; plane < device_count; ++plane) {\r\nbpp = winbpp(win->w[plane].mode_winctrl1);\r\nif (win->w[plane].xres == 0)\r\nwin->w[plane].xres = panel->Xres;\r\nif (win->w[plane].yres == 0)\r\nwin->w[plane].yres = panel->Yres;\r\nfbi = framebuffer_alloc(sizeof(struct au1200fb_device),\r\n&dev->dev);\r\nif (!fbi)\r\ngoto failed;\r\n_au1200fb_infos[plane] = fbi;\r\nfbdev = fbi->par;\r\nfbdev->fb_info = fbi;\r\nfbdev->pd = pd;\r\nfbdev->plane = plane;\r\nfbdev->fb_len = (win->w[plane].xres * win->w[plane].yres * bpp) / 8;\r\nfbdev->fb_mem = dmam_alloc_noncoherent(&dev->dev,\r\nPAGE_ALIGN(fbdev->fb_len),\r\n&fbdev->fb_phys, GFP_KERNEL);\r\nif (!fbdev->fb_mem) {\r\nprint_err("fail to allocate frambuffer (size: %dK))",\r\nfbdev->fb_len / 1024);\r\nreturn -ENOMEM;\r\n}\r\nfor (page = (unsigned long)fbdev->fb_phys;\r\npage < PAGE_ALIGN((unsigned long)fbdev->fb_phys +\r\nfbdev->fb_len);\r\npage += PAGE_SIZE) {\r\nSetPageReserved(pfn_to_page(page >> PAGE_SHIFT));\r\n}\r\nprint_dbg("Framebuffer memory map at %p", fbdev->fb_mem);\r\nprint_dbg("phys=0x%08x, size=%dK", fbdev->fb_phys, fbdev->fb_len / 1024);\r\nif ((ret = au1200fb_init_fbinfo(fbdev)) < 0)\r\ngoto failed;\r\nret = register_framebuffer(fbi);\r\nif (ret < 0) {\r\nprint_err("cannot register new framebuffer");\r\ngoto failed;\r\n}\r\nau1200fb_fb_set_par(fbi);\r\n#if !defined(CONFIG_FRAMEBUFFER_CONSOLE) && defined(CONFIG_LOGO)\r\nif (plane == 0)\r\nif (fb_prepare_logo(fbi, FB_ROTATE_UR)) {\r\nfb_set_cmap(&fbi->cmap, fbi);\r\nfb_show_logo(fbi, FB_ROTATE_UR);\r\n}\r\n#endif\r\n}\r\nirq = platform_get_irq(dev, 0);\r\nret = request_irq(irq, au1200fb_handle_irq,\r\nIRQF_SHARED, "lcd", (void *)dev);\r\nif (ret) {\r\nprint_err("fail to request interrupt line %d (err: %d)",\r\nirq, ret);\r\ngoto failed;\r\n}\r\nplatform_set_drvdata(dev, pd);\r\nau1200_setpanel(panel, pd);\r\nreturn 0;\r\nfailed:\r\nif (fbi) {\r\nif (fbi->cmap.len != 0)\r\nfb_dealloc_cmap(&fbi->cmap);\r\nkfree(fbi->pseudo_palette);\r\n}\r\nif (plane == 0)\r\nfree_irq(AU1200_LCD_INT, (void*)dev);\r\nreturn ret;\r\n}\r\nstatic int au1200fb_drv_remove(struct platform_device *dev)\r\n{\r\nstruct au1200fb_platdata *pd = platform_get_drvdata(dev);\r\nstruct au1200fb_device *fbdev;\r\nstruct fb_info *fbi;\r\nint plane;\r\nau1200_setpanel(NULL, pd);\r\nfor (plane = 0; plane < device_count; ++plane) {\r\nfbi = _au1200fb_infos[plane];\r\nfbdev = fbi->par;\r\nunregister_framebuffer(fbi);\r\nif (fbi->cmap.len != 0)\r\nfb_dealloc_cmap(&fbi->cmap);\r\nkfree(fbi->pseudo_palette);\r\nframebuffer_release(fbi);\r\n_au1200fb_infos[plane] = NULL;\r\n}\r\nfree_irq(platform_get_irq(dev, 0), (void *)dev);\r\nreturn 0;\r\n}\r\nstatic int au1200fb_drv_suspend(struct device *dev)\r\n{\r\nstruct au1200fb_platdata *pd = dev_get_drvdata(dev);\r\nau1200_setpanel(NULL, pd);\r\nlcd->outmask = 0;\r\nau_sync();\r\nreturn 0;\r\n}\r\nstatic int au1200fb_drv_resume(struct device *dev)\r\n{\r\nstruct au1200fb_platdata *pd = dev_get_drvdata(dev);\r\nstruct fb_info *fbi;\r\nint i;\r\nau1200_setpanel(panel, pd);\r\nfor (i = 0; i < device_count; i++) {\r\nfbi = _au1200fb_infos[i];\r\nau1200fb_fb_set_par(fbi);\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init au1200fb_init(void)\r\n{\r\nreturn platform_driver_register(&au1200fb_driver);\r\n}\r\nstatic void __exit au1200fb_cleanup(void)\r\n{\r\nplatform_driver_unregister(&au1200fb_driver);\r\n}
