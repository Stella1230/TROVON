static void pxa3xx_cpu_standby(unsigned int pwrmode)\r\n{\r\nextern const char pm_enter_standby_start[], pm_enter_standby_end[];\r\nvoid (*fn)(unsigned int) = (void __force *)(sram + 0x8000);\r\nmemcpy_toio(sram + 0x8000, pm_enter_standby_start,\r\npm_enter_standby_end - pm_enter_standby_start);\r\nAD2D0SR = ~0;\r\nAD2D1SR = ~0;\r\nAD2D0ER = wakeup_src;\r\nAD2D1ER = 0;\r\nASCR = ASCR;\r\nARSR = ARSR;\r\nlocal_fiq_disable();\r\nfn(pwrmode);\r\nlocal_fiq_enable();\r\nAD2D0ER = 0;\r\nAD2D1ER = 0;\r\n}\r\nstatic void pxa3xx_cpu_pm_suspend(void)\r\n{\r\nvolatile unsigned long *p = (volatile void *)0xc0000000;\r\nunsigned long saved_data = *p;\r\n#ifndef CONFIG_IWMMXT\r\nu64 acc0;\r\nasm volatile("mra %Q0, %R0, acc0" : "=r" (acc0));\r\n#endif\r\nextern int pxa3xx_finish_suspend(unsigned long);\r\nCKENA |= (1 << CKEN_BOOT) | (1 << CKEN_TPM);\r\nCKENB |= 1 << (CKEN_HSIO2 & 0x1f);\r\nAD3SR = ~0;\r\nAD3ER = wakeup_src;\r\nASCR = ASCR;\r\nARSR = ARSR;\r\nPCFR |= (1u << 13);\r\nPCFR &= ~((1u << 12) | (1u << 1));\r\nPSPR = 0x5c014000;\r\n*p = virt_to_phys(cpu_resume);\r\ncpu_suspend(0, pxa3xx_finish_suspend);\r\n*p = saved_data;\r\nAD3ER = 0;\r\n#ifndef CONFIG_IWMMXT\r\nasm volatile("mar acc0, %Q0, %R0" : "=r" (acc0));\r\n#endif\r\n}\r\nstatic void pxa3xx_cpu_pm_enter(suspend_state_t state)\r\n{\r\nif (wakeup_src == 0) {\r\nprintk(KERN_ERR "Not suspending: no wakeup sources\n");\r\nreturn;\r\n}\r\nswitch (state) {\r\ncase PM_SUSPEND_STANDBY:\r\npxa3xx_cpu_standby(PXA3xx_PM_S0D2C2);\r\nbreak;\r\ncase PM_SUSPEND_MEM:\r\npxa3xx_cpu_pm_suspend();\r\nbreak;\r\n}\r\n}\r\nstatic int pxa3xx_cpu_pm_valid(suspend_state_t state)\r\n{\r\nreturn state == PM_SUSPEND_MEM || state == PM_SUSPEND_STANDBY;\r\n}\r\nstatic void __init pxa3xx_init_pm(void)\r\n{\r\nsram = ioremap(ISRAM_START, ISRAM_SIZE);\r\nif (!sram) {\r\nprintk(KERN_ERR "Unable to map ISRAM: disabling standby/suspend\n");\r\nreturn;\r\n}\r\nAD1R |= ADXR_L2 | ADXR_R0;\r\nAD2R |= ADXR_L2 | ADXR_R0;\r\nAD3R |= ADXR_L2 | ADXR_R0;\r\nAD1D0ER = 0;\r\nAD2D0ER = 0;\r\nAD2D1ER = 0;\r\nAD3ER = 0;\r\npxa_cpu_pm_fns = &pxa3xx_cpu_pm_fns;\r\n}\r\nstatic int pxa3xx_set_wake(struct irq_data *d, unsigned int on)\r\n{\r\nunsigned long flags, mask = 0;\r\nswitch (d->irq) {\r\ncase IRQ_SSP3:\r\nmask = ADXER_MFP_WSSP3;\r\nbreak;\r\ncase IRQ_MSL:\r\nmask = ADXER_WMSL0;\r\nbreak;\r\ncase IRQ_USBH2:\r\ncase IRQ_USBH1:\r\nmask = ADXER_WUSBH;\r\nbreak;\r\ncase IRQ_KEYPAD:\r\nmask = ADXER_WKP;\r\nbreak;\r\ncase IRQ_AC97:\r\nmask = ADXER_MFP_WAC97;\r\nbreak;\r\ncase IRQ_USIM:\r\nmask = ADXER_WUSIM0;\r\nbreak;\r\ncase IRQ_SSP2:\r\nmask = ADXER_MFP_WSSP2;\r\nbreak;\r\ncase IRQ_I2C:\r\nmask = ADXER_MFP_WI2C;\r\nbreak;\r\ncase IRQ_STUART:\r\nmask = ADXER_MFP_WUART3;\r\nbreak;\r\ncase IRQ_BTUART:\r\nmask = ADXER_MFP_WUART2;\r\nbreak;\r\ncase IRQ_FFUART:\r\nmask = ADXER_MFP_WUART1;\r\nbreak;\r\ncase IRQ_MMC:\r\nmask = ADXER_MFP_WMMC1;\r\nbreak;\r\ncase IRQ_SSP:\r\nmask = ADXER_MFP_WSSP1;\r\nbreak;\r\ncase IRQ_RTCAlrm:\r\nmask = ADXER_WRTC;\r\nbreak;\r\ncase IRQ_SSP4:\r\nmask = ADXER_MFP_WSSP4;\r\nbreak;\r\ncase IRQ_TSI:\r\nmask = ADXER_WTSI;\r\nbreak;\r\ncase IRQ_USIM2:\r\nmask = ADXER_WUSIM1;\r\nbreak;\r\ncase IRQ_MMC2:\r\nmask = ADXER_MFP_WMMC2;\r\nbreak;\r\ncase IRQ_NAND:\r\nmask = ADXER_MFP_WFLASH;\r\nbreak;\r\ncase IRQ_USB2:\r\nmask = ADXER_WUSB2;\r\nbreak;\r\ncase IRQ_WAKEUP0:\r\nmask = ADXER_WEXTWAKE0;\r\nbreak;\r\ncase IRQ_WAKEUP1:\r\nmask = ADXER_WEXTWAKE1;\r\nbreak;\r\ncase IRQ_MMC3:\r\nmask = ADXER_MFP_GEN12;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nlocal_irq_save(flags);\r\nif (on)\r\nwakeup_src |= mask;\r\nelse\r\nwakeup_src &= ~mask;\r\nlocal_irq_restore(flags);\r\nreturn 0;\r\n}\r\nstatic inline void pxa3xx_init_pm(void) {}\r\nstatic void pxa_ack_ext_wakeup(struct irq_data *d)\r\n{\r\nPECR |= PECR_IS(d->irq - IRQ_WAKEUP0);\r\n}\r\nstatic void pxa_mask_ext_wakeup(struct irq_data *d)\r\n{\r\npxa_mask_irq(d);\r\nPECR &= ~PECR_IE(d->irq - IRQ_WAKEUP0);\r\n}\r\nstatic void pxa_unmask_ext_wakeup(struct irq_data *d)\r\n{\r\npxa_unmask_irq(d);\r\nPECR |= PECR_IE(d->irq - IRQ_WAKEUP0);\r\n}\r\nstatic int pxa_set_ext_wakeup_type(struct irq_data *d, unsigned int flow_type)\r\n{\r\nif (flow_type & IRQ_TYPE_EDGE_RISING)\r\nPWER |= 1 << (d->irq - IRQ_WAKEUP0);\r\nif (flow_type & IRQ_TYPE_EDGE_FALLING)\r\nPWER |= 1 << (d->irq - IRQ_WAKEUP0 + 2);\r\nreturn 0;\r\n}\r\nstatic void __init pxa_init_ext_wakeup_irq(int (*fn)(struct irq_data *,\r\nunsigned int))\r\n{\r\nint irq;\r\nfor (irq = IRQ_WAKEUP0; irq <= IRQ_WAKEUP1; irq++) {\r\nirq_set_chip_and_handler(irq, &pxa_ext_wakeup_chip,\r\nhandle_edge_irq);\r\nset_irq_flags(irq, IRQF_VALID);\r\n}\r\npxa_ext_wakeup_chip.irq_set_wake = fn;\r\n}\r\nstatic void __init __pxa3xx_init_irq(void)\r\n{\r\nu32 value;\r\n__asm__ __volatile__("mrc p15, 0, %0, c15, c1, 0\n": "=r"(value));\r\nvalue |= (1 << 6);\r\n__asm__ __volatile__("mcr p15, 0, %0, c15, c1, 0\n": :"r"(value));\r\npxa_init_ext_wakeup_irq(pxa3xx_set_wake);\r\n}\r\nvoid __init pxa3xx_init_irq(void)\r\n{\r\n__pxa3xx_init_irq();\r\npxa_init_irq(56, pxa3xx_set_wake);\r\n}\r\nvoid __init pxa3xx_dt_init_irq(void)\r\n{\r\n__pxa3xx_init_irq();\r\npxa_dt_irq_init(pxa3xx_set_wake);\r\n}\r\nvoid __init pxa3xx_map_io(void)\r\n{\r\npxa_map_io();\r\niotable_init(ARRAY_AND_SIZE(pxa3xx_io_desc));\r\npxa3xx_get_clk_frequency_khz(1);\r\n}\r\nvoid __init pxa3xx_set_i2c_power_info(struct i2c_pxa_platform_data *info)\r\n{\r\npxa_register_device(&pxa3xx_device_i2c_power, info);\r\n}\r\nstatic int __init pxa3xx_init(void)\r\n{\r\nint ret = 0;\r\nif (cpu_is_pxa3xx()) {\r\nreset_status = ARSR;\r\nASCR &= ~(ASCR_RDH | ASCR_D1S | ASCR_D2S | ASCR_D3S);\r\nclkdev_add_table(pxa3xx_clkregs, ARRAY_SIZE(pxa3xx_clkregs));\r\nif ((ret = pxa_init_dma(IRQ_DMA, 32)))\r\nreturn ret;\r\npxa3xx_init_pm();\r\nregister_syscore_ops(&pxa_irq_syscore_ops);\r\nregister_syscore_ops(&pxa3xx_mfp_syscore_ops);\r\nregister_syscore_ops(&pxa3xx_clock_syscore_ops);\r\nif (!of_have_populated_dt())\r\nret = platform_add_devices(devices, ARRAY_SIZE(devices));\r\n}\r\nreturn ret;\r\n}
