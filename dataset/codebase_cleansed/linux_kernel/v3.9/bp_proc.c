static struct proc_dir_entry *proc_getdir(char *name,\r\nstruct proc_dir_entry *proc_dir)\r\n{\r\nstruct proc_dir_entry *pde = proc_dir;\r\nfor (pde = pde->subdir; pde; pde = pde->next) {\r\nif (pde->namelen && (strcmp(name, pde->name) == 0)) {\r\nbreak;\r\n}\r\n}\r\nif (pde == (struct proc_dir_entry *)0) {\r\npde = create_proc_entry(name, S_IFDIR, proc_dir);\r\nif (pde == (struct proc_dir_entry *)0)\r\nreturn pde;\r\n}\r\nreturn pde;\r\n}\r\nint\r\nbypass_proc_create_entry_sd(struct pfs_unit *pfs_unit_curr,\r\nchar *proc_name,\r\nwrite_proc_t *write_proc,\r\nread_proc_t *read_proc,\r\nstruct proc_dir_entry *parent_pfs, void *data)\r\n{\r\nstrcpy(pfs_unit_curr->proc_name, proc_name);\r\npfs_unit_curr->proc_entry = create_proc_entry(pfs_unit_curr->proc_name,\r\nS_IFREG | S_IRUSR |\r\nS_IWUSR | S_IRGRP |\r\nS_IROTH, parent_pfs);\r\nif (pfs_unit_curr->proc_entry == 0)\r\nreturn -1;\r\npfs_unit_curr->proc_entry->read_proc = read_proc;\r\npfs_unit_curr->proc_entry->write_proc = write_proc;\r\npfs_unit_curr->proc_entry->data = data;\r\nreturn 0;\r\n}\r\nint\r\nget_bypass_info_pfs(char *page, char **start, off_t off, int count,\r\nint *eof, void *data)\r\n{\r\nbpctl_dev_t *pbp_device_block = (bpctl_dev_t *) data;\r\nint len = 0;\r\nlen += sprintf(page, "Name\t\t\t%s\n", pbp_device_block->bp_name);\r\nlen +=\r\nsprintf(page + len, "Firmware version\t0x%x\n",\r\npbp_device_block->bp_fw_ver);\r\n*eof = 1;\r\nreturn len;\r\n}\r\nint\r\nget_bypass_slave_pfs(char *page, char **start, off_t off, int count,\r\nint *eof, void *data)\r\n{\r\nbpctl_dev_t *pbp_device_block = (bpctl_dev_t *) data;\r\nstruct pci_dev *pci_slave_dev = pbp_device_block->bp_slave;\r\nstruct net_device *net_slave_dev;\r\nint len = 0;\r\nif (is_bypass_fn(pbp_device_block)) {\r\nnet_slave_dev = pci_get_drvdata(pci_slave_dev);\r\nif (net_slave_dev)\r\nlen = sprintf(page, "%s\n", net_slave_dev->name);\r\nelse\r\nlen = sprintf(page, "fail\n");\r\n} else\r\nlen = sprintf(page, "fail\n");\r\n*eof = 1;\r\nreturn len;\r\n}\r\nint\r\nget_bypass_caps_pfs(char *page, char **start, off_t off, int count,\r\nint *eof, void *data)\r\n{\r\nbpctl_dev_t *pbp_device_block = (bpctl_dev_t *) data;\r\nint len = 0, ret = 0;\r\nret = get_bypass_caps_fn(pbp_device_block);\r\nif (ret == BP_NOT_CAP)\r\nlen = sprintf(page, "-1\n");\r\nelse\r\nlen = sprintf(page, "0x%x\n", ret);\r\n*eof = 1;\r\nreturn len;\r\n}\r\nint\r\nget_wd_set_caps_pfs(char *page, char **start, off_t off, int count,\r\nint *eof, void *data)\r\n{\r\nbpctl_dev_t *pbp_device_block = (bpctl_dev_t *) data;\r\nint len = 0, ret = 0;\r\nret = get_wd_set_caps_fn(pbp_device_block);\r\nif (ret == BP_NOT_CAP)\r\nlen = sprintf(page, "-1\n");\r\nelse\r\nlen = sprintf(page, "0x%x\n", ret);\r\n*eof = 1;\r\nreturn len;\r\n}\r\nint\r\nset_bypass_pfs(struct file *file, const char *buffer,\r\nunsigned long count, void *data)\r\n{\r\nchar kbuf[256];\r\nbpctl_dev_t *pbp_device_block = (bpctl_dev_t *) data;\r\nint bypass_param = 0, length = 0;\r\nif (count > (sizeof(kbuf) - 1))\r\nreturn -1;\r\nif (copy_from_user(&kbuf, buffer, count))\r\nreturn -1;\r\nkbuf[count] = '\0';\r\nlength = strlen(kbuf);\r\nif (kbuf[length - 1] == '\n')\r\nkbuf[--length] = '\0';\r\nif (strcmp(kbuf, "on") == 0)\r\nbypass_param = 1;\r\nelse if (strcmp(kbuf, "off") == 0)\r\nbypass_param = 0;\r\nset_bypass_fn(pbp_device_block, bypass_param);\r\nreturn count;\r\n}\r\nint\r\nset_tap_pfs(struct file *file, const char *buffer,\r\nunsigned long count, void *data)\r\n{\r\nchar kbuf[256];\r\nbpctl_dev_t *pbp_device_block = (bpctl_dev_t *) data;\r\nint tap_param = 0, length = 0;\r\nif (count > (sizeof(kbuf) - 1))\r\nreturn -1;\r\nif (copy_from_user(&kbuf, buffer, count))\r\nreturn -1;\r\nkbuf[count] = '\0';\r\nlength = strlen(kbuf);\r\nif (kbuf[length - 1] == '\n')\r\nkbuf[--length] = '\0';\r\nif (strcmp(kbuf, "on") == 0)\r\ntap_param = 1;\r\nelse if (strcmp(kbuf, "off") == 0)\r\ntap_param = 0;\r\nset_tap_fn(pbp_device_block, tap_param);\r\nreturn count;\r\n}\r\nint\r\nset_disc_pfs(struct file *file, const char *buffer,\r\nunsigned long count, void *data)\r\n{\r\nchar kbuf[256];\r\nbpctl_dev_t *pbp_device_block = (bpctl_dev_t *) data;\r\nint tap_param = 0, length = 0;\r\nif (count > (sizeof(kbuf) - 1))\r\nreturn -1;\r\nif (copy_from_user(&kbuf, buffer, count))\r\nreturn -1;\r\nkbuf[count] = '\0';\r\nlength = strlen(kbuf);\r\nif (kbuf[length - 1] == '\n')\r\nkbuf[--length] = '\0';\r\nif (strcmp(kbuf, "on") == 0)\r\ntap_param = 1;\r\nelse if (strcmp(kbuf, "off") == 0)\r\ntap_param = 0;\r\nset_disc_fn(pbp_device_block, tap_param);\r\nreturn count;\r\n}\r\nint\r\nget_bypass_pfs(char *page, char **start, off_t off, int count,\r\nint *eof, void *data)\r\n{\r\nbpctl_dev_t *pbp_device_block = (bpctl_dev_t *) data;\r\nint len = 0, ret = 0;\r\nret = get_bypass_fn(pbp_device_block);\r\nif (ret == BP_NOT_CAP)\r\nlen = sprintf(page, "fail\n");\r\nelse if (ret == 1)\r\nlen = sprintf(page, "on\n");\r\nelse if (ret == 0)\r\nlen = sprintf(page, "off\n");\r\n*eof = 1;\r\nreturn len;\r\n}\r\nint\r\nget_tap_pfs(char *page, char **start, off_t off, int count,\r\nint *eof, void *data)\r\n{\r\nbpctl_dev_t *pbp_device_block = (bpctl_dev_t *) data;\r\nint len = 0, ret = 0;\r\nret = get_tap_fn(pbp_device_block);\r\nif (ret == BP_NOT_CAP)\r\nlen = sprintf(page, "fail\n");\r\nelse if (ret == 1)\r\nlen = sprintf(page, "on\n");\r\nelse if (ret == 0)\r\nlen = sprintf(page, "off\n");\r\n*eof = 1;\r\nreturn len;\r\n}\r\nint\r\nget_disc_pfs(char *page, char **start, off_t off, int count,\r\nint *eof, void *data)\r\n{\r\nbpctl_dev_t *pbp_device_block = (bpctl_dev_t *) data;\r\nint len = 0, ret = 0;\r\nret = get_disc_fn(pbp_device_block);\r\nif (ret == BP_NOT_CAP)\r\nlen = sprintf(page, "fail\n");\r\nelse if (ret == 1)\r\nlen = sprintf(page, "on\n");\r\nelse if (ret == 0)\r\nlen = sprintf(page, "off\n");\r\n*eof = 1;\r\nreturn len;\r\n}\r\nint\r\nget_bypass_change_pfs(char *page, char **start, off_t off, int count,\r\nint *eof, void *data)\r\n{\r\nbpctl_dev_t *pbp_device_block = (bpctl_dev_t *) data;\r\nint len = 0, ret = 0;\r\nret = get_bypass_change_fn(pbp_device_block);\r\nif (ret == 1)\r\nlen = sprintf(page, "on\n");\r\nelse if (ret == 0)\r\nlen = sprintf(page, "off\n");\r\nelse\r\nlen = sprintf(page, "fail\n");\r\n*eof = 1;\r\nreturn len;\r\n}\r\nint\r\nget_tap_change_pfs(char *page, char **start, off_t off, int count,\r\nint *eof, void *data)\r\n{\r\nbpctl_dev_t *pbp_device_block = (bpctl_dev_t *) data;\r\nint len = 0, ret = 0;\r\nret = get_tap_change_fn(pbp_device_block);\r\nif (ret == 1)\r\nlen = sprintf(page, "on\n");\r\nelse if (ret == 0)\r\nlen = sprintf(page, "off\n");\r\nelse\r\nlen = sprintf(page, "fail\n");\r\n*eof = 1;\r\nreturn len;\r\n}\r\nint\r\nget_disc_change_pfs(char *page, char **start, off_t off, int count,\r\nint *eof, void *data)\r\n{\r\nbpctl_dev_t *pbp_device_block = (bpctl_dev_t *) data;\r\nint len = 0, ret = 0;\r\nret = get_disc_change_fn(pbp_device_block);\r\nif (ret == 1)\r\nlen = sprintf(page, "on\n");\r\nelse if (ret == 0)\r\nlen = sprintf(page, "off\n");\r\nelse\r\nlen = sprintf(page, "fail\n");\r\n*eof = 1;\r\nreturn len;\r\n}\r\nint\r\nset_bypass_wd_pfs(struct file *file, const char *buffer,\r\nunsigned long count, void *data)\r\n{\r\nchar kbuf[256];\r\nbpctl_dev_t *pbp_device_block = (bpctl_dev_t *) data;\r\nunsigned int timeout = 0;\r\nchar *timeout_ptr = kbuf;\r\nif (copy_from_user(&kbuf, buffer, count))\r\nreturn -1;\r\ntimeout_ptr = kbuf;\r\ntimeout = atoi(&timeout_ptr);\r\nset_bypass_wd_fn(pbp_device_block, timeout);\r\nreturn count;\r\n}\r\nint\r\nget_bypass_wd_pfs(char *page, char **start, off_t off, int count,\r\nint *eof, void *data)\r\n{\r\nbpctl_dev_t *pbp_device_block = (bpctl_dev_t *) data;\r\nint len = 0, ret = 0, timeout = 0;\r\nret = get_bypass_wd_fn(pbp_device_block, &timeout);\r\nif (ret == BP_NOT_CAP)\r\nlen = sprintf(page, "fail\n");\r\nelse if (timeout == -1)\r\nlen = sprintf(page, "unknown\n");\r\nelse if (timeout == 0)\r\nlen = sprintf(page, "disable\n");\r\nelse\r\nlen = sprintf(page, "%d\n", timeout);\r\n*eof = 1;\r\nreturn len;\r\n}\r\nint\r\nget_wd_expire_time_pfs(char *page, char **start, off_t off, int count,\r\nint *eof, void *data)\r\n{\r\nbpctl_dev_t *pbp_device_block = (bpctl_dev_t *) data;\r\nint len = 0, ret = 0, timeout = 0;\r\nret = get_wd_expire_time_fn(pbp_device_block, &timeout);\r\nif (ret == BP_NOT_CAP)\r\nlen = sprintf(page, "fail\n");\r\nelse if (timeout == -1)\r\nlen = sprintf(page, "expire\n");\r\nelse if (timeout == 0)\r\nlen = sprintf(page, "disable\n");\r\nelse\r\nlen = sprintf(page, "%d\n", timeout);\r\n*eof = 1;\r\nreturn len;\r\n}\r\nint\r\nget_tpl_pfs(char *page, char **start, off_t off, int count,\r\nint *eof, void *data)\r\n{\r\nbpctl_dev_t *pbp_device_block = (bpctl_dev_t *) data;\r\nint len = 0, ret = 0;\r\nret = get_tpl_fn(pbp_device_block);\r\nif (ret == BP_NOT_CAP)\r\nlen = sprintf(page, "fail\n");\r\nelse if (ret == 1)\r\nlen = sprintf(page, "on\n");\r\nelse if (ret == 0)\r\nlen = sprintf(page, "off\n");\r\n*eof = 1;\r\nreturn len;\r\n}\r\nint\r\nget_wait_at_pwup_pfs(char *page, char **start, off_t off, int count,\r\nint *eof, void *data)\r\n{\r\nbpctl_dev_t *pbp_device_block = (bpctl_dev_t *) data;\r\nint len = 0, ret = 0;\r\nret = get_bp_wait_at_pwup_fn(pbp_device_block);\r\nif (ret == BP_NOT_CAP)\r\nlen = sprintf(page, "fail\n");\r\nelse if (ret == 1)\r\nlen = sprintf(page, "on\n");\r\nelse if (ret == 0)\r\nlen = sprintf(page, "off\n");\r\n*eof = 1;\r\nreturn len;\r\n}\r\nint\r\nget_hw_reset_pfs(char *page, char **start, off_t off, int count,\r\nint *eof, void *data)\r\n{\r\nbpctl_dev_t *pbp_device_block = (bpctl_dev_t *) data;\r\nint len = 0, ret = 0;\r\nret = get_bp_hw_reset_fn(pbp_device_block);\r\nif (ret == BP_NOT_CAP)\r\nlen = sprintf(page, "fail\n");\r\nelse if (ret == 1)\r\nlen = sprintf(page, "on\n");\r\nelse if (ret == 0)\r\nlen = sprintf(page, "off\n");\r\n*eof = 1;\r\nreturn len;\r\n}\r\nint\r\nreset_bypass_wd_pfs(char *page, char **start, off_t off, int count,\r\nint *eof, void *data)\r\n{\r\nbpctl_dev_t *pbp_device_block = (bpctl_dev_t *) data;\r\nint len = 0, ret = 0;\r\nret = reset_bypass_wd_timer_fn(pbp_device_block);\r\nif (ret == BP_NOT_CAP)\r\nlen = sprintf(page, "fail\n");\r\nelse if (ret == 0)\r\nlen = sprintf(page, "disable\n");\r\nelse if (ret == 1)\r\nlen = sprintf(page, "success\n");\r\n*eof = 1;\r\nreturn len;\r\n}\r\nint\r\nset_dis_bypass_pfs(struct file *file, const char *buffer,\r\nunsigned long count, void *data)\r\n{\r\nchar kbuf[256];\r\nbpctl_dev_t *pbp_device_block = (bpctl_dev_t *) data;\r\nint bypass_param = 0, length = 0;\r\nif (copy_from_user(&kbuf, buffer, count))\r\nreturn -1;\r\nkbuf[count] = '\0';\r\nlength = strlen(kbuf);\r\nif (kbuf[length - 1] == '\n')\r\nkbuf[--length] = '\0';\r\nif (strcmp(kbuf, "on") == 0)\r\nbypass_param = 1;\r\nelse if (strcmp(kbuf, "off") == 0)\r\nbypass_param = 0;\r\nset_dis_bypass_fn(pbp_device_block, bypass_param);\r\nreturn count;\r\n}\r\nint\r\nset_dis_tap_pfs(struct file *file, const char *buffer,\r\nunsigned long count, void *data)\r\n{\r\nchar kbuf[256];\r\nbpctl_dev_t *pbp_device_block = (bpctl_dev_t *) data;\r\nint tap_param = 0, length = 0;\r\nif (copy_from_user(&kbuf, buffer, count))\r\nreturn -1;\r\nkbuf[count] = '\0';\r\nlength = strlen(kbuf);\r\nif (kbuf[length - 1] == '\n')\r\nkbuf[--length] = '\0';\r\nif (strcmp(kbuf, "on") == 0)\r\ntap_param = 1;\r\nelse if (strcmp(kbuf, "off") == 0)\r\ntap_param = 0;\r\nset_dis_tap_fn(pbp_device_block, tap_param);\r\nreturn count;\r\n}\r\nint\r\nset_dis_disc_pfs(struct file *file, const char *buffer,\r\nunsigned long count, void *data)\r\n{\r\nchar kbuf[256];\r\nbpctl_dev_t *pbp_device_block = (bpctl_dev_t *) data;\r\nint tap_param = 0, length = 0;\r\nif (copy_from_user(&kbuf, buffer, count))\r\nreturn -1;\r\nkbuf[count] = '\0';\r\nlength = strlen(kbuf);\r\nif (kbuf[length - 1] == '\n')\r\nkbuf[--length] = '\0';\r\nif (strcmp(kbuf, "on") == 0)\r\ntap_param = 1;\r\nelse if (strcmp(kbuf, "off") == 0)\r\ntap_param = 0;\r\nset_dis_disc_fn(pbp_device_block, tap_param);\r\nreturn count;\r\n}\r\nint\r\nget_dis_bypass_pfs(char *page, char **start, off_t off, int count,\r\nint *eof, void *data)\r\n{\r\nbpctl_dev_t *pbp_device_block = (bpctl_dev_t *) data;\r\nint len = 0, ret = 0;\r\nret = get_dis_bypass_fn(pbp_device_block);\r\nif (ret == BP_NOT_CAP)\r\nlen = sprintf(page, "fail\n");\r\nelse if (ret == 0)\r\nlen = sprintf(page, "off\n");\r\nelse\r\nlen = sprintf(page, "on\n");\r\n*eof = 1;\r\nreturn len;\r\n}\r\nint\r\nget_dis_tap_pfs(char *page, char **start, off_t off, int count,\r\nint *eof, void *data)\r\n{\r\nbpctl_dev_t *pbp_device_block = (bpctl_dev_t *) data;\r\nint len = 0, ret = 0;\r\nret = get_dis_tap_fn(pbp_device_block);\r\nif (ret == BP_NOT_CAP)\r\nlen = sprintf(page, "fail\n");\r\nelse if (ret == 0)\r\nlen = sprintf(page, "off\n");\r\nelse\r\nlen = sprintf(page, "on\n");\r\n*eof = 1;\r\nreturn len;\r\n}\r\nint\r\nget_dis_disc_pfs(char *page, char **start, off_t off, int count,\r\nint *eof, void *data)\r\n{\r\nbpctl_dev_t *pbp_device_block = (bpctl_dev_t *) data;\r\nint len = 0, ret = 0;\r\nret = get_dis_disc_fn(pbp_device_block);\r\nif (ret == BP_NOT_CAP)\r\nlen = sprintf(page, "fail\n");\r\nelse if (ret == 0)\r\nlen = sprintf(page, "off\n");\r\nelse\r\nlen = sprintf(page, "on\n");\r\n*eof = 1;\r\nreturn len;\r\n}\r\nint\r\nset_bypass_pwup_pfs(struct file *file, const char *buffer,\r\nunsigned long count, void *data)\r\n{\r\nchar kbuf[256];\r\nbpctl_dev_t *pbp_device_block = (bpctl_dev_t *) data;\r\nint bypass_param = 0, length = 0;\r\nif (copy_from_user(&kbuf, buffer, count))\r\nreturn -1;\r\nkbuf[count] = '\0';\r\nlength = strlen(kbuf);\r\nif (kbuf[length - 1] == '\n')\r\nkbuf[--length] = '\0';\r\nif (strcmp(kbuf, "on") == 0)\r\nbypass_param = 1;\r\nelse if (strcmp(kbuf, "off") == 0)\r\nbypass_param = 0;\r\nset_bypass_pwup_fn(pbp_device_block, bypass_param);\r\nreturn count;\r\n}\r\nint\r\nset_bypass_pwoff_pfs(struct file *file, const char *buffer,\r\nunsigned long count, void *data)\r\n{\r\nchar kbuf[256];\r\nbpctl_dev_t *pbp_device_block = (bpctl_dev_t *) data;\r\nint bypass_param = 0, length = 0;\r\nif (copy_from_user(&kbuf, buffer, count))\r\nreturn -1;\r\nkbuf[count] = '\0';\r\nlength = strlen(kbuf);\r\nif (kbuf[length - 1] == '\n')\r\nkbuf[--length] = '\0';\r\nif (strcmp(kbuf, "on") == 0)\r\nbypass_param = 1;\r\nelse if (strcmp(kbuf, "off") == 0)\r\nbypass_param = 0;\r\nset_bypass_pwoff_fn(pbp_device_block, bypass_param);\r\nreturn count;\r\n}\r\nint\r\nset_tap_pwup_pfs(struct file *file, const char *buffer,\r\nunsigned long count, void *data)\r\n{\r\nchar kbuf[256];\r\nbpctl_dev_t *pbp_device_block = (bpctl_dev_t *) data;\r\nint tap_param = 0, length = 0;\r\nif (copy_from_user(&kbuf, buffer, count))\r\nreturn -1;\r\nkbuf[count] = '\0';\r\nlength = strlen(kbuf);\r\nif (kbuf[length - 1] == '\n')\r\nkbuf[--length] = '\0';\r\nif (strcmp(kbuf, "on") == 0)\r\ntap_param = 1;\r\nelse if (strcmp(kbuf, "off") == 0)\r\ntap_param = 0;\r\nset_tap_pwup_fn(pbp_device_block, tap_param);\r\nreturn count;\r\n}\r\nint\r\nset_disc_pwup_pfs(struct file *file, const char *buffer,\r\nunsigned long count, void *data)\r\n{\r\nchar kbuf[256];\r\nbpctl_dev_t *pbp_device_block = (bpctl_dev_t *) data;\r\nint tap_param = 0, length = 0;\r\nif (copy_from_user(&kbuf, buffer, count))\r\nreturn -1;\r\nkbuf[count] = '\0';\r\nlength = strlen(kbuf);\r\nif (kbuf[length - 1] == '\n')\r\nkbuf[--length] = '\0';\r\nif (strcmp(kbuf, "on") == 0)\r\ntap_param = 1;\r\nelse if (strcmp(kbuf, "off") == 0)\r\ntap_param = 0;\r\nset_disc_pwup_fn(pbp_device_block, tap_param);\r\nreturn count;\r\n}\r\nint\r\nget_bypass_pwup_pfs(char *page, char **start, off_t off, int count,\r\nint *eof, void *data)\r\n{\r\nbpctl_dev_t *pbp_device_block = (bpctl_dev_t *) data;\r\nint len = 0, ret = 0;\r\nret = get_bypass_pwup_fn(pbp_device_block);\r\nif (ret == BP_NOT_CAP)\r\nlen = sprintf(page, "fail\n");\r\nelse if (ret == 0)\r\nlen = sprintf(page, "off\n");\r\nelse\r\nlen = sprintf(page, "on\n");\r\n*eof = 1;\r\nreturn len;\r\n}\r\nint\r\nget_bypass_pwoff_pfs(char *page, char **start, off_t off, int count,\r\nint *eof, void *data)\r\n{\r\nbpctl_dev_t *pbp_device_block = (bpctl_dev_t *) data;\r\nint len = 0, ret = 0;\r\nret = get_bypass_pwoff_fn(pbp_device_block);\r\nif (ret == BP_NOT_CAP)\r\nlen = sprintf(page, "fail\n");\r\nelse if (ret == 0)\r\nlen = sprintf(page, "off\n");\r\nelse\r\nlen = sprintf(page, "on\n");\r\n*eof = 1;\r\nreturn len;\r\n}\r\nint\r\nget_tap_pwup_pfs(char *page, char **start, off_t off, int count,\r\nint *eof, void *data)\r\n{\r\nbpctl_dev_t *pbp_device_block = (bpctl_dev_t *) data;\r\nint len = 0, ret = 0;\r\nret = get_tap_pwup_fn(pbp_device_block);\r\nif (ret == BP_NOT_CAP)\r\nlen = sprintf(page, "fail\n");\r\nelse if (ret == 0)\r\nlen = sprintf(page, "off\n");\r\nelse\r\nlen = sprintf(page, "on\n");\r\n*eof = 1;\r\nreturn len;\r\n}\r\nint\r\nget_disc_pwup_pfs(char *page, char **start, off_t off, int count,\r\nint *eof, void *data)\r\n{\r\nbpctl_dev_t *pbp_device_block = (bpctl_dev_t *) data;\r\nint len = 0, ret = 0;\r\nret = get_disc_pwup_fn(pbp_device_block);\r\nif (ret == BP_NOT_CAP)\r\nlen = sprintf(page, "fail\n");\r\nelse if (ret == 0)\r\nlen = sprintf(page, "off\n");\r\nelse\r\nlen = sprintf(page, "on\n");\r\n*eof = 1;\r\nreturn len;\r\n}\r\nint\r\nset_std_nic_pfs(struct file *file, const char *buffer,\r\nunsigned long count, void *data)\r\n{\r\nchar kbuf[256];\r\nbpctl_dev_t *pbp_device_block = (bpctl_dev_t *) data;\r\nint bypass_param = 0, length = 0;\r\nif (copy_from_user(&kbuf, buffer, count))\r\nreturn -1;\r\nkbuf[count] = '\0';\r\nlength = strlen(kbuf);\r\nif (kbuf[length - 1] == '\n')\r\nkbuf[--length] = '\0';\r\nif (strcmp(kbuf, "on") == 0)\r\nbypass_param = 1;\r\nelse if (strcmp(kbuf, "off") == 0)\r\nbypass_param = 0;\r\nset_std_nic_fn(pbp_device_block, bypass_param);\r\nreturn count;\r\n}\r\nint\r\nget_std_nic_pfs(char *page, char **start, off_t off, int count,\r\nint *eof, void *data)\r\n{\r\nbpctl_dev_t *pbp_device_block = (bpctl_dev_t *) data;\r\nint len = 0, ret = 0;\r\nret = get_std_nic_fn(pbp_device_block);\r\nif (ret == BP_NOT_CAP)\r\nlen = sprintf(page, "fail\n");\r\nelse if (ret == 0)\r\nlen = sprintf(page, "off\n");\r\nelse\r\nlen = sprintf(page, "on\n");\r\n*eof = 1;\r\nreturn len;\r\n}\r\nint\r\nget_wd_exp_mode_pfs(char *page, char **start, off_t off, int count,\r\nint *eof, void *data)\r\n{\r\nbpctl_dev_t *pbp_device_block = (bpctl_dev_t *) data;\r\nint len = 0, ret = 0;\r\nret = get_wd_exp_mode_fn(pbp_device_block);\r\nif (ret == 1)\r\nlen = sprintf(page, "tap\n");\r\nelse if (ret == 0)\r\nlen = sprintf(page, "bypass\n");\r\nelse if (ret == 2)\r\nlen = sprintf(page, "disc\n");\r\nelse\r\nlen = sprintf(page, "fail\n");\r\n*eof = 1;\r\nreturn len;\r\n}\r\nint\r\nset_wd_exp_mode_pfs(struct file *file, const char *buffer,\r\nunsigned long count, void *data)\r\n{\r\nchar kbuf[256];\r\nbpctl_dev_t *pbp_device_block = (bpctl_dev_t *) data;\r\nint bypass_param = 0, length = 0;\r\nif (count > (sizeof(kbuf) - 1))\r\nreturn -1;\r\nif (copy_from_user(&kbuf, buffer, count))\r\nreturn -1;\r\nkbuf[count] = '\0';\r\nlength = strlen(kbuf);\r\nif (kbuf[length - 1] == '\n')\r\nkbuf[--length] = '\0';\r\nif (strcmp(kbuf, "tap") == 0)\r\nbypass_param = 1;\r\nelse if (strcmp(kbuf, "bypass") == 0)\r\nbypass_param = 0;\r\nelse if (strcmp(kbuf, "disc") == 0)\r\nbypass_param = 2;\r\nset_wd_exp_mode_fn(pbp_device_block, bypass_param);\r\nreturn count;\r\n}\r\nint\r\nget_wd_autoreset_pfs(char *page, char **start, off_t off, int count,\r\nint *eof, void *data)\r\n{\r\nbpctl_dev_t *pbp_device_block = (bpctl_dev_t *) data;\r\nint len = 0, ret = 0;\r\nret = get_wd_autoreset_fn(pbp_device_block);\r\nif (ret >= 0)\r\nlen = sprintf(page, "%d\n", ret);\r\nelse\r\nlen = sprintf(page, "fail\n");\r\n*eof = 1;\r\nreturn len;\r\n}\r\nint\r\nset_wd_autoreset_pfs(struct file *file, const char *buffer,\r\nunsigned long count, void *data)\r\n{\r\nchar kbuf[256];\r\nbpctl_dev_t *pbp_device_block = (bpctl_dev_t *) data;\r\nu32 timeout = 0;\r\nchar *timeout_ptr = kbuf;\r\nif (copy_from_user(&kbuf, buffer, count))\r\nreturn -1;\r\ntimeout_ptr = kbuf;\r\ntimeout = atoi(&timeout_ptr);\r\nset_wd_autoreset_fn(pbp_device_block, timeout);\r\nreturn count;\r\n}\r\nint\r\nset_tpl_pfs(struct file *file, const char *buffer,\r\nunsigned long count, void *data)\r\n{\r\nchar kbuf[256];\r\nbpctl_dev_t *pbp_device_block = (bpctl_dev_t *) data;\r\nint tpl_param = 0, length = 0;\r\nif (count > (sizeof(kbuf) - 1))\r\nreturn -1;\r\nif (copy_from_user(&kbuf, buffer, count))\r\nreturn -1;\r\nkbuf[count] = '\0';\r\nlength = strlen(kbuf);\r\nif (kbuf[length - 1] == '\n')\r\nkbuf[--length] = '\0';\r\nif (strcmp(kbuf, "on") == 0)\r\ntpl_param = 1;\r\nelse if (strcmp(kbuf, "off") == 0)\r\ntpl_param = 0;\r\nset_tpl_fn(pbp_device_block, tpl_param);\r\nreturn count;\r\n}\r\nint\r\nset_wait_at_pwup_pfs(struct file *file, const char *buffer,\r\nunsigned long count, void *data)\r\n{\r\nchar kbuf[256];\r\nbpctl_dev_t *pbp_device_block = (bpctl_dev_t *) data;\r\nint tpl_param = 0, length = 0;\r\nif (count > (sizeof(kbuf) - 1))\r\nreturn -1;\r\nif (copy_from_user(&kbuf, buffer, count))\r\nreturn -1;\r\nkbuf[count] = '\0';\r\nlength = strlen(kbuf);\r\nif (kbuf[length - 1] == '\n')\r\nkbuf[--length] = '\0';\r\nif (strcmp(kbuf, "on") == 0)\r\ntpl_param = 1;\r\nelse if (strcmp(kbuf, "off") == 0)\r\ntpl_param = 0;\r\nset_bp_wait_at_pwup_fn(pbp_device_block, tpl_param);\r\nreturn count;\r\n}\r\nint\r\nset_hw_reset_pfs(struct file *file, const char *buffer,\r\nunsigned long count, void *data)\r\n{\r\nchar kbuf[256];\r\nbpctl_dev_t *pbp_device_block = (bpctl_dev_t *) data;\r\nint tpl_param = 0, length = 0;\r\nif (count > (sizeof(kbuf) - 1))\r\nreturn -1;\r\nif (copy_from_user(&kbuf, buffer, count))\r\nreturn -1;\r\nkbuf[count] = '\0';\r\nlength = strlen(kbuf);\r\nif (kbuf[length - 1] == '\n')\r\nkbuf[--length] = '\0';\r\nif (strcmp(kbuf, "on") == 0)\r\ntpl_param = 1;\r\nelse if (strcmp(kbuf, "off") == 0)\r\ntpl_param = 0;\r\nset_bp_hw_reset_fn(pbp_device_block, tpl_param);\r\nreturn count;\r\n}\r\nint bypass_proc_create_dev_sd(bpctl_dev_t *pbp_device_block)\r\n{\r\nstruct bypass_pfs_sd *current_pfs = &(pbp_device_block->bypass_pfs_set);\r\nstatic struct proc_dir_entry *procfs_dir;\r\nint ret = 0;\r\nsprintf(current_pfs->dir_name, "bypass_%s", dev->name);\r\nif (!bp_procfs_dir)\r\nreturn -1;\r\nprocfs_dir = proc_getdir(current_pfs->dir_name, bp_procfs_dir);\r\nif (procfs_dir == 0) {\r\nprintk(KERN_DEBUG "Could not create procfs directory %s\n",\r\ncurrent_pfs->dir_name);\r\nreturn -1;\r\n}\r\ncurrent_pfs->bypass_entry = procfs_dir;\r\nif (bypass_proc_create_entry(&(current_pfs->bypass_info), BYPASS_INFO_ENTRY_SD, NULL,\r\nget_bypass_info_pfs,\r\nprocfs_dir, pbp_device_block))\r\nret = -1;\r\nif (pbp_device_block->bp_caps & SW_CTL_CAP) {\r\nif (bypass_proc_create_entry_sd(&(current_pfs->bypass_slave), BYPASS_SLAVE_ENTRY_SD, NULL,\r\nget_bypass_slave_pfs,\r\nprocfs_dir, pbp_device_block))\r\nret = -1;\r\nif (bypass_proc_create_entry_sd(&(current_pfs->bypass_caps), BYPASS_CAPS_ENTRY_SD, NULL,\r\nget_bypass_caps_pfs,\r\nprocfs_dir, pbp_device_block))\r\nret = -1;\r\nif (bypass_proc_create_entry_sd(&(current_pfs->wd_set_caps), WD_SET_CAPS_ENTRY_SD, NULL,\r\nget_wd_set_caps_pfs,\r\nprocfs_dir, pbp_device_block))\r\nret = -1;\r\nif (bypass_proc_create_entry_sd(&(current_pfs->bypass_wd), BYPASS_WD_ENTRY_SD, set_bypass_wd_pfs,\r\nget_bypass_wd_pfs,\r\nprocfs_dir, pbp_device_block))\r\nret = -1;\r\nif (bypass_proc_create_entry_sd(&(current_pfs->wd_expire_time), WD_EXPIRE_TIME_ENTRY_SD, NULL,\r\nget_wd_expire_time_pfs,\r\nprocfs_dir, pbp_device_block))\r\nret = -1;\r\nif (bypass_proc_create_entry_sd(&(current_pfs->reset_bypass_wd), RESET_BYPASS_WD_ENTRY_SD, NULL,\r\nreset_bypass_wd_pfs,\r\nprocfs_dir, pbp_device_block))\r\nret = -1;\r\nif (bypass_proc_create_entry_sd(&(current_pfs->std_nic), STD_NIC_ENTRY_SD, set_std_nic_pfs,\r\nget_std_nic_pfs,\r\nprocfs_dir, pbp_device_block))\r\nret = -1;\r\nif (pbp_device_block->bp_caps & BP_CAP) {\r\nif (bypass_proc_create_entry_sd(&(current_pfs->bypass), BYPASS_ENTRY_SD, set_bypass_pfs,\r\nget_bypass_pfs,\r\nprocfs_dir,\r\npbp_device_block))\r\nret = -1;\r\nif (bypass_proc_create_entry_sd(&(current_pfs->dis_bypass), DIS_BYPASS_ENTRY_SD, set_dis_bypass_pfs,\r\nget_dis_bypass_pfs,\r\nprocfs_dir,\r\npbp_device_block))\r\nret = -1;\r\nif (bypass_proc_create_entry_sd(&(current_pfs->bypass_pwup), BYPASS_PWUP_ENTRY_SD, set_bypass_pwup_pfs,\r\nget_bypass_pwup_pfs,\r\nprocfs_dir,\r\npbp_device_block))\r\nret = -1;\r\nif (bypass_proc_create_entry_sd(&(current_pfs->bypass_pwoff), BYPASS_PWOFF_ENTRY_SD, set_bypass_pwoff_pfs,\r\nget_bypass_pwoff_pfs,\r\nprocfs_dir,\r\npbp_device_block))\r\nret = -1;\r\nif (bypass_proc_create_entry_sd(&(current_pfs->bypass_change), BYPASS_CHANGE_ENTRY_SD, NULL,\r\nget_bypass_change_pfs,\r\nprocfs_dir,\r\npbp_device_block))\r\nret = -1;\r\n}\r\nif (pbp_device_block->bp_caps & TAP_CAP) {\r\nif (bypass_proc_create_entry_sd(&(current_pfs->tap), TAP_ENTRY_SD, set_tap_pfs,\r\nget_tap_pfs,\r\nprocfs_dir,\r\npbp_device_block))\r\nret = -1;\r\nif (bypass_proc_create_entry_sd(&(current_pfs->dis_tap), DIS_TAP_ENTRY_SD, set_dis_tap_pfs,\r\nget_dis_tap_pfs,\r\nprocfs_dir,\r\npbp_device_block))\r\nret = -1;\r\nif (bypass_proc_create_entry_sd(&(current_pfs->tap_pwup), TAP_PWUP_ENTRY_SD, set_tap_pwup_pfs,\r\nget_tap_pwup_pfs,\r\nprocfs_dir,\r\npbp_device_block))\r\nret = -1;\r\nif (bypass_proc_create_entry_sd(&(current_pfs->tap_change), TAP_CHANGE_ENTRY_SD, NULL,\r\nget_tap_change_pfs,\r\nprocfs_dir,\r\npbp_device_block))\r\nret = -1;\r\n}\r\nif (pbp_device_block->bp_caps & DISC_CAP) {\r\nif (bypass_proc_create_entry_sd(&(current_pfs->tap), DISC_ENTRY_SD, set_disc_pfs,\r\nget_disc_pfs,\r\nprocfs_dir,\r\npbp_device_block))\r\nret = -1;\r\n#if 1\r\nif (bypass_proc_create_entry_sd(&(current_pfs->dis_tap), DIS_DISC_ENTRY_SD, set_dis_disc_pfs,\r\nget_dis_disc_pfs,\r\nprocfs_dir,\r\npbp_device_block))\r\nret = -1;\r\n#endif\r\nif (bypass_proc_create_entry_sd(&(current_pfs->tap_pwup), DISC_PWUP_ENTRY_SD, set_disc_pwup_pfs,\r\nget_disc_pwup_pfs,\r\nprocfs_dir,\r\npbp_device_block))\r\nret = -1;\r\nif (bypass_proc_create_entry_sd(&(current_pfs->tap_change), DISC_CHANGE_ENTRY_SD, NULL,\r\nget_disc_change_pfs,\r\nprocfs_dir,\r\npbp_device_block))\r\nret = -1;\r\n}\r\nif (bypass_proc_create_entry_sd(&(current_pfs->wd_exp_mode), WD_EXP_MODE_ENTRY_SD, set_wd_exp_mode_pfs,\r\nget_wd_exp_mode_pfs,\r\nprocfs_dir, pbp_device_block))\r\nret = -1;\r\nif (bypass_proc_create_entry_sd(&(current_pfs->wd_autoreset), WD_AUTORESET_ENTRY_SD, set_wd_autoreset_pfs,\r\nget_wd_autoreset_pfs,\r\nprocfs_dir, pbp_device_block))\r\nret = -1;\r\nif (bypass_proc_create_entry_sd(&(current_pfs->tpl), TPL_ENTRY_SD, set_tpl_pfs,\r\nget_tpl_pfs,\r\nprocfs_dir, pbp_device_block))\r\nret = -1;\r\n#ifdef PMC_FIX_FLAG\r\nif (bypass_proc_create_entry_sd(&(current_pfs->tpl), WAIT_AT_PWUP_ENTRY_SD, set_wait_at_pwup_pfs,\r\nget_wait_at_pwup_pfs,\r\nprocfs_dir, pbp_device_block))\r\nret = -1;\r\nif (bypass_proc_create_entry_sd(&(current_pfs->tpl), HW_RESET_ENTRY_SD, set_hw_reset_pfs,\r\nget_hw_reset_pfs,\r\nprocfs_dir, pbp_device_block))\r\nret = -1;\r\n#endif\r\n}\r\nif (ret < 0)\r\nprintk(KERN_DEBUG "Create proc entry failed\n");\r\nreturn ret;\r\n}\r\nint bypass_proc_remove_dev_sd(bpctl_dev_t *pbp_device_block)\r\n{\r\nstruct bypass_pfs_sd *current_pfs = &pbp_device_block->bypass_pfs_set;\r\nstruct proc_dir_entry *pde = current_pfs->bypass_entry, *pde_curr =\r\nNULL;\r\nchar name[256];\r\nfor (pde = pde->subdir; pde;) {\r\nstrcpy(name, pde->name);\r\npde_curr = pde;\r\npde = pde->next;\r\nremove_proc_entry(name, current_pfs->bypass_entry);\r\n}\r\nif (!pde)\r\nremove_proc_entry(current_pfs->dir_name, bp_procfs_dir);\r\nreturn 0;\r\n}
