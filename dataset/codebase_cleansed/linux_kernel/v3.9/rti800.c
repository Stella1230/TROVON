static irqreturn_t rti800_interrupt(int irq, void *dev)\r\n{\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int rti800_ai_insn_read(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nstruct rti800_private *devpriv = dev->private;\r\nint i, t;\r\nint status;\r\nint chan = CR_CHAN(insn->chanspec);\r\nunsigned gain = CR_RANGE(insn->chanspec);\r\nunsigned muxgain_bits;\r\ninb(dev->iobase + RTI800_ADCHI);\r\noutb(0, dev->iobase + RTI800_CLRFLAGS);\r\nmuxgain_bits = chan | (gain << 5);\r\nif (muxgain_bits != devpriv->muxgain_bits) {\r\ndevpriv->muxgain_bits = muxgain_bits;\r\noutb(devpriv->muxgain_bits, dev->iobase + RTI800_MUXGAIN);\r\nif (insn->n > 0) {\r\nBUG_ON(gain >= ARRAY_SIZE(gaindelay));\r\nudelay(gaindelay[gain]);\r\n}\r\n}\r\nfor (i = 0; i < insn->n; i++) {\r\noutb(0, dev->iobase + RTI800_CONVERT);\r\nfor (t = RTI800_TIMEOUT; t; t--) {\r\nstatus = inb(dev->iobase + RTI800_CSR);\r\nif (status & RTI800_OVERRUN) {\r\nprintk(KERN_WARNING "rti800: a/d overrun\n");\r\noutb(0, dev->iobase + RTI800_CLRFLAGS);\r\nreturn -EIO;\r\n}\r\nif (status & RTI800_DONE)\r\nbreak;\r\nudelay(1);\r\n}\r\nif (t == 0) {\r\nprintk(KERN_WARNING "rti800: timeout\n");\r\nreturn -ETIME;\r\n}\r\ndata[i] = inb(dev->iobase + RTI800_ADCLO);\r\ndata[i] |= (0xf & inb(dev->iobase + RTI800_ADCHI)) << 8;\r\nif (devpriv->adc_coding == adc_2comp)\r\ndata[i] ^= 0x800;\r\n}\r\nreturn i;\r\n}\r\nstatic int rti800_ao_insn_read(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nstruct rti800_private *devpriv = dev->private;\r\nint i;\r\nint chan = CR_CHAN(insn->chanspec);\r\nfor (i = 0; i < insn->n; i++)\r\ndata[i] = devpriv->ao_readback[chan];\r\nreturn i;\r\n}\r\nstatic int rti800_ao_insn_write(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nstruct rti800_private *devpriv = dev->private;\r\nint chan = CR_CHAN(insn->chanspec);\r\nint d;\r\nint i;\r\nfor (i = 0; i < insn->n; i++) {\r\ndevpriv->ao_readback[chan] = d = data[i];\r\nif (devpriv->dac0_coding == dac_2comp)\r\nd ^= 0x800;\r\noutb(d & 0xff,\r\ndev->iobase + (chan ? RTI800_DAC1LO : RTI800_DAC0LO));\r\noutb(d >> 8,\r\ndev->iobase + (chan ? RTI800_DAC1HI : RTI800_DAC0HI));\r\n}\r\nreturn i;\r\n}\r\nstatic int rti800_di_insn_bits(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\ndata[1] = inb(dev->iobase + RTI800_DI);\r\nreturn insn->n;\r\n}\r\nstatic int rti800_do_insn_bits(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nif (data[0]) {\r\ns->state &= ~data[0];\r\ns->state |= data[0] & data[1];\r\noutb(s->state ^ 0xff, dev->iobase + RTI800_DO);\r\n}\r\ndata[1] = s->state;\r\nreturn insn->n;\r\n}\r\nstatic int rti800_attach(struct comedi_device *dev, struct comedi_devconfig *it)\r\n{\r\nconst struct rti800_board *board = comedi_board(dev);\r\nstruct rti800_private *devpriv;\r\nunsigned int irq;\r\nunsigned long iobase;\r\nint ret;\r\nstruct comedi_subdevice *s;\r\niobase = it->options[0];\r\nprintk(KERN_INFO "comedi%d: rti800: 0x%04lx\n", dev->minor, iobase);\r\nif (!request_region(iobase, RTI800_SIZE, "rti800")) {\r\nprintk(KERN_WARNING "I/O port conflict\n");\r\nreturn -EIO;\r\n}\r\ndev->iobase = iobase;\r\n#ifdef DEBUG\r\nprintk(KERN_DEBUG "fingerprint=%x,%x,%x,%x,%x ",\r\ninb(dev->iobase + 0),\r\ninb(dev->iobase + 1),\r\ninb(dev->iobase + 2),\r\ninb(dev->iobase + 3), inb(dev->iobase + 4));\r\n#endif\r\noutb(0, dev->iobase + RTI800_CSR);\r\ninb(dev->iobase + RTI800_ADCHI);\r\noutb(0, dev->iobase + RTI800_CLRFLAGS);\r\nirq = it->options[1];\r\nif (irq) {\r\nprintk(KERN_INFO "( irq = %u )\n", irq);\r\nret = request_irq(irq, rti800_interrupt, 0, "rti800", dev);\r\nif (ret < 0) {\r\nprintk(KERN_WARNING " Failed to allocate IRQ\n");\r\nreturn ret;\r\n}\r\ndev->irq = irq;\r\n} else {\r\nprintk(KERN_INFO "( no irq )\n");\r\n}\r\ndev->board_name = board->name;\r\nret = comedi_alloc_subdevices(dev, 4);\r\nif (ret)\r\nreturn ret;\r\ndevpriv = kzalloc(sizeof(*devpriv), GFP_KERNEL);\r\nif (!devpriv)\r\nreturn -ENOMEM;\r\ndev->private = devpriv;\r\ndevpriv->adc_mux = it->options[2];\r\ndevpriv->adc_range = it->options[3];\r\ndevpriv->adc_coding = it->options[4];\r\ndevpriv->dac0_range = it->options[5];\r\ndevpriv->dac0_coding = it->options[6];\r\ndevpriv->dac1_range = it->options[7];\r\ndevpriv->dac1_coding = it->options[8];\r\ndevpriv->muxgain_bits = -1;\r\ns = &dev->subdevices[0];\r\ns->type = COMEDI_SUBD_AI;\r\ns->subdev_flags = SDF_READABLE | SDF_GROUND;\r\ns->n_chan = (devpriv->adc_mux ? 16 : 8);\r\ns->insn_read = rti800_ai_insn_read;\r\ns->maxdata = 0xfff;\r\nswitch (devpriv->adc_range) {\r\ncase adc_bipolar10:\r\ns->range_table = &range_rti800_ai_10_bipolar;\r\nbreak;\r\ncase adc_bipolar5:\r\ns->range_table = &range_rti800_ai_5_bipolar;\r\nbreak;\r\ncase adc_unipolar10:\r\ns->range_table = &range_rti800_ai_unipolar;\r\nbreak;\r\n}\r\ns = &dev->subdevices[1];\r\nif (board->has_ao) {\r\ns->type = COMEDI_SUBD_AO;\r\ns->subdev_flags = SDF_WRITABLE;\r\ns->n_chan = 2;\r\ns->insn_read = rti800_ao_insn_read;\r\ns->insn_write = rti800_ao_insn_write;\r\ns->maxdata = 0xfff;\r\ns->range_table_list = devpriv->ao_range_type_list;\r\nswitch (devpriv->dac0_range) {\r\ncase dac_bipolar10:\r\ndevpriv->ao_range_type_list[0] = &range_bipolar10;\r\nbreak;\r\ncase dac_unipolar10:\r\ndevpriv->ao_range_type_list[0] = &range_unipolar10;\r\nbreak;\r\n}\r\nswitch (devpriv->dac1_range) {\r\ncase dac_bipolar10:\r\ndevpriv->ao_range_type_list[1] = &range_bipolar10;\r\nbreak;\r\ncase dac_unipolar10:\r\ndevpriv->ao_range_type_list[1] = &range_unipolar10;\r\nbreak;\r\n}\r\n} else {\r\ns->type = COMEDI_SUBD_UNUSED;\r\n}\r\ns = &dev->subdevices[2];\r\ns->type = COMEDI_SUBD_DI;\r\ns->subdev_flags = SDF_READABLE;\r\ns->n_chan = 8;\r\ns->insn_bits = rti800_di_insn_bits;\r\ns->maxdata = 1;\r\ns->range_table = &range_digital;\r\ns = &dev->subdevices[3];\r\ns->type = COMEDI_SUBD_DO;\r\ns->subdev_flags = SDF_WRITABLE;\r\ns->n_chan = 8;\r\ns->insn_bits = rti800_do_insn_bits;\r\ns->maxdata = 1;\r\ns->range_table = &range_digital;\r\n#if 0\r\ns = &dev->subdevices[4];\r\ns->type = COMEDI_SUBD_TIMER;\r\n#endif\r\nreturn 0;\r\n}\r\nstatic void rti800_detach(struct comedi_device *dev)\r\n{\r\nif (dev->iobase)\r\nrelease_region(dev->iobase, RTI800_SIZE);\r\nif (dev->irq)\r\nfree_irq(dev->irq, dev);\r\n}
