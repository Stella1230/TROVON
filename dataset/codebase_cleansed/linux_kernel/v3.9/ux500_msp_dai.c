static int setup_pcm_multichan(struct snd_soc_dai *dai,\r\nstruct ux500_msp_config *msp_config)\r\n{\r\nstruct ux500_msp_i2s_drvdata *drvdata = dev_get_drvdata(dai->dev);\r\nstruct msp_multichannel_config *multi =\r\n&msp_config->multichannel_config;\r\nif (drvdata->slots > 1) {\r\nmsp_config->multichannel_configured = 1;\r\nmulti->tx_multichannel_enable = true;\r\nmulti->rx_multichannel_enable = true;\r\nmulti->rx_comparison_enable_mode = MSP_COMPARISON_DISABLED;\r\nmulti->tx_channel_0_enable = drvdata->tx_mask;\r\nmulti->tx_channel_1_enable = 0;\r\nmulti->tx_channel_2_enable = 0;\r\nmulti->tx_channel_3_enable = 0;\r\nmulti->rx_channel_0_enable = drvdata->rx_mask;\r\nmulti->rx_channel_1_enable = 0;\r\nmulti->rx_channel_2_enable = 0;\r\nmulti->rx_channel_3_enable = 0;\r\ndev_dbg(dai->dev,\r\n"%s: Multichannel enabled. Slots: %d, TX: %u, RX: %u\n",\r\n__func__, drvdata->slots, multi->tx_channel_0_enable,\r\nmulti->rx_channel_0_enable);\r\n}\r\nreturn 0;\r\n}\r\nstatic int setup_frameper(struct snd_soc_dai *dai, unsigned int rate,\r\nstruct msp_protdesc *prot_desc)\r\n{\r\nstruct ux500_msp_i2s_drvdata *drvdata = dev_get_drvdata(dai->dev);\r\nswitch (drvdata->slots) {\r\ncase 1:\r\nswitch (rate) {\r\ncase 8000:\r\nprot_desc->frame_period =\r\nFRAME_PER_SINGLE_SLOT_8_KHZ;\r\nbreak;\r\ncase 16000:\r\nprot_desc->frame_period =\r\nFRAME_PER_SINGLE_SLOT_16_KHZ;\r\nbreak;\r\ncase 44100:\r\nprot_desc->frame_period =\r\nFRAME_PER_SINGLE_SLOT_44_1_KHZ;\r\nbreak;\r\ncase 48000:\r\nprot_desc->frame_period =\r\nFRAME_PER_SINGLE_SLOT_48_KHZ;\r\nbreak;\r\ndefault:\r\ndev_err(dai->dev,\r\n"%s: Error: Unsupported sample-rate (freq = %d)!\n",\r\n__func__, rate);\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ncase 2:\r\nprot_desc->frame_period = FRAME_PER_2_SLOTS;\r\nbreak;\r\ncase 8:\r\nprot_desc->frame_period = FRAME_PER_8_SLOTS;\r\nbreak;\r\ncase 16:\r\nprot_desc->frame_period = FRAME_PER_16_SLOTS;\r\nbreak;\r\ndefault:\r\ndev_err(dai->dev,\r\n"%s: Error: Unsupported slot-count (slots = %d)!\n",\r\n__func__, drvdata->slots);\r\nreturn -EINVAL;\r\n}\r\nprot_desc->clocks_per_frame =\r\nprot_desc->frame_period+1;\r\ndev_dbg(dai->dev, "%s: Clocks per frame: %u\n",\r\n__func__,\r\nprot_desc->clocks_per_frame);\r\nreturn 0;\r\n}\r\nstatic int setup_pcm_framing(struct snd_soc_dai *dai, unsigned int rate,\r\nstruct msp_protdesc *prot_desc)\r\n{\r\nstruct ux500_msp_i2s_drvdata *drvdata = dev_get_drvdata(dai->dev);\r\nu32 frame_length = MSP_FRAME_LEN_1;\r\nprot_desc->frame_width = 0;\r\nswitch (drvdata->slots) {\r\ncase 1:\r\nframe_length = MSP_FRAME_LEN_1;\r\nbreak;\r\ncase 2:\r\nframe_length = MSP_FRAME_LEN_2;\r\nbreak;\r\ncase 8:\r\nframe_length = MSP_FRAME_LEN_8;\r\nbreak;\r\ncase 16:\r\nframe_length = MSP_FRAME_LEN_16;\r\nbreak;\r\ndefault:\r\ndev_err(dai->dev,\r\n"%s: Error: Unsupported slot-count (slots = %d)!\n",\r\n__func__, drvdata->slots);\r\nreturn -EINVAL;\r\n}\r\nprot_desc->tx_frame_len_1 = frame_length;\r\nprot_desc->rx_frame_len_1 = frame_length;\r\nprot_desc->tx_frame_len_2 = frame_length;\r\nprot_desc->rx_frame_len_2 = frame_length;\r\nprot_desc->tx_elem_len_1 = MSP_ELEM_LEN_16;\r\nprot_desc->rx_elem_len_1 = MSP_ELEM_LEN_16;\r\nprot_desc->tx_elem_len_2 = MSP_ELEM_LEN_16;\r\nprot_desc->rx_elem_len_2 = MSP_ELEM_LEN_16;\r\nreturn setup_frameper(dai, rate, prot_desc);\r\n}\r\nstatic int setup_clocking(struct snd_soc_dai *dai,\r\nunsigned int fmt,\r\nstruct ux500_msp_config *msp_config)\r\n{\r\nswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\r\ncase SND_SOC_DAIFMT_NB_NF:\r\nbreak;\r\ncase SND_SOC_DAIFMT_NB_IF:\r\nmsp_config->tx_fsync_pol ^= 1 << TFSPOL_SHIFT;\r\nmsp_config->rx_fsync_pol ^= 1 << RFSPOL_SHIFT;\r\nbreak;\r\ndefault:\r\ndev_err(dai->dev,\r\n"%s: Error: Unsopported inversion (fmt = 0x%x)!\n",\r\n__func__, fmt);\r\nreturn -EINVAL;\r\n}\r\nswitch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {\r\ncase SND_SOC_DAIFMT_CBM_CFM:\r\ndev_dbg(dai->dev, "%s: Codec is master.\n", __func__);\r\nmsp_config->iodelay = 0x20;\r\nmsp_config->rx_fsync_sel = 0;\r\nmsp_config->tx_fsync_sel = 1 << TFSSEL_SHIFT;\r\nmsp_config->tx_clk_sel = 0;\r\nmsp_config->rx_clk_sel = 0;\r\nmsp_config->srg_clk_sel = 0x2 << SCKSEL_SHIFT;\r\nbreak;\r\ncase SND_SOC_DAIFMT_CBS_CFS:\r\ndev_dbg(dai->dev, "%s: Codec is slave.\n", __func__);\r\nmsp_config->tx_clk_sel = TX_CLK_SEL_SRG;\r\nmsp_config->tx_fsync_sel = TX_SYNC_SRG_PROG;\r\nmsp_config->rx_clk_sel = RX_CLK_SEL_SRG;\r\nmsp_config->rx_fsync_sel = RX_SYNC_SRG;\r\nmsp_config->srg_clk_sel = 1 << SCKSEL_SHIFT;\r\nbreak;\r\ndefault:\r\ndev_err(dai->dev, "%s: Error: Unsopported master (fmt = 0x%x)!\n",\r\n__func__, fmt);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int setup_pcm_protdesc(struct snd_soc_dai *dai,\r\nunsigned int fmt,\r\nstruct msp_protdesc *prot_desc)\r\n{\r\nprot_desc->rx_phase_mode = MSP_SINGLE_PHASE;\r\nprot_desc->tx_phase_mode = MSP_SINGLE_PHASE;\r\nprot_desc->rx_phase2_start_mode = MSP_PHASE2_START_MODE_IMEDIATE;\r\nprot_desc->tx_phase2_start_mode = MSP_PHASE2_START_MODE_IMEDIATE;\r\nprot_desc->rx_byte_order = MSP_BTF_MS_BIT_FIRST;\r\nprot_desc->tx_byte_order = MSP_BTF_MS_BIT_FIRST;\r\nprot_desc->tx_fsync_pol = MSP_FSYNC_POL(MSP_FSYNC_POL_ACT_HI);\r\nprot_desc->rx_fsync_pol = MSP_FSYNC_POL_ACT_HI << RFSPOL_SHIFT;\r\nif ((fmt & SND_SOC_DAIFMT_FORMAT_MASK) == SND_SOC_DAIFMT_DSP_A) {\r\ndev_dbg(dai->dev, "%s: DSP_A.\n", __func__);\r\nprot_desc->rx_clk_pol = MSP_RISING_EDGE;\r\nprot_desc->tx_clk_pol = MSP_FALLING_EDGE;\r\nprot_desc->rx_data_delay = MSP_DELAY_1;\r\nprot_desc->tx_data_delay = MSP_DELAY_1;\r\n} else {\r\ndev_dbg(dai->dev, "%s: DSP_B.\n", __func__);\r\nprot_desc->rx_clk_pol = MSP_FALLING_EDGE;\r\nprot_desc->tx_clk_pol = MSP_RISING_EDGE;\r\nprot_desc->rx_data_delay = MSP_DELAY_0;\r\nprot_desc->tx_data_delay = MSP_DELAY_0;\r\n}\r\nprot_desc->rx_half_word_swap = MSP_SWAP_NONE;\r\nprot_desc->tx_half_word_swap = MSP_SWAP_NONE;\r\nprot_desc->compression_mode = MSP_COMPRESS_MODE_LINEAR;\r\nprot_desc->expansion_mode = MSP_EXPAND_MODE_LINEAR;\r\nprot_desc->frame_sync_ignore = MSP_FSYNC_IGNORE;\r\nreturn 0;\r\n}\r\nstatic int setup_i2s_protdesc(struct msp_protdesc *prot_desc)\r\n{\r\nprot_desc->rx_phase_mode = MSP_DUAL_PHASE;\r\nprot_desc->tx_phase_mode = MSP_DUAL_PHASE;\r\nprot_desc->rx_phase2_start_mode = MSP_PHASE2_START_MODE_FSYNC;\r\nprot_desc->tx_phase2_start_mode = MSP_PHASE2_START_MODE_FSYNC;\r\nprot_desc->rx_byte_order = MSP_BTF_MS_BIT_FIRST;\r\nprot_desc->tx_byte_order = MSP_BTF_MS_BIT_FIRST;\r\nprot_desc->tx_fsync_pol = MSP_FSYNC_POL(MSP_FSYNC_POL_ACT_LO);\r\nprot_desc->rx_fsync_pol = MSP_FSYNC_POL_ACT_LO << RFSPOL_SHIFT;\r\nprot_desc->rx_frame_len_1 = MSP_FRAME_LEN_1;\r\nprot_desc->rx_frame_len_2 = MSP_FRAME_LEN_1;\r\nprot_desc->tx_frame_len_1 = MSP_FRAME_LEN_1;\r\nprot_desc->tx_frame_len_2 = MSP_FRAME_LEN_1;\r\nprot_desc->rx_elem_len_1 = MSP_ELEM_LEN_16;\r\nprot_desc->rx_elem_len_2 = MSP_ELEM_LEN_16;\r\nprot_desc->tx_elem_len_1 = MSP_ELEM_LEN_16;\r\nprot_desc->tx_elem_len_2 = MSP_ELEM_LEN_16;\r\nprot_desc->rx_clk_pol = MSP_RISING_EDGE;\r\nprot_desc->tx_clk_pol = MSP_FALLING_EDGE;\r\nprot_desc->rx_data_delay = MSP_DELAY_0;\r\nprot_desc->tx_data_delay = MSP_DELAY_0;\r\nprot_desc->tx_half_word_swap = MSP_SWAP_NONE;\r\nprot_desc->rx_half_word_swap = MSP_SWAP_NONE;\r\nprot_desc->compression_mode = MSP_COMPRESS_MODE_LINEAR;\r\nprot_desc->expansion_mode = MSP_EXPAND_MODE_LINEAR;\r\nprot_desc->frame_sync_ignore = MSP_FSYNC_IGNORE;\r\nreturn 0;\r\n}\r\nstatic int setup_msp_config(struct snd_pcm_substream *substream,\r\nstruct snd_soc_dai *dai,\r\nstruct ux500_msp_config *msp_config)\r\n{\r\nstruct ux500_msp_i2s_drvdata *drvdata = dev_get_drvdata(dai->dev);\r\nstruct msp_protdesc *prot_desc = &msp_config->protdesc;\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nunsigned int fmt = drvdata->fmt;\r\nint ret;\r\nmemset(msp_config, 0, sizeof(*msp_config));\r\nmsp_config->f_inputclk = drvdata->master_clk;\r\nmsp_config->tx_fifo_config = TX_FIFO_ENABLE;\r\nmsp_config->rx_fifo_config = RX_FIFO_ENABLE;\r\nmsp_config->def_elem_len = 1;\r\nmsp_config->direction = substream->stream == SNDRV_PCM_STREAM_PLAYBACK ?\r\nMSP_DIR_TX : MSP_DIR_RX;\r\nmsp_config->data_size = MSP_DATA_BITS_32;\r\nmsp_config->frame_freq = runtime->rate;\r\ndev_dbg(dai->dev, "%s: f_inputclk = %u, frame_freq = %u.\n",\r\n__func__, msp_config->f_inputclk, msp_config->frame_freq);\r\nprot_desc->clocks_per_frame = 1;\r\ndev_dbg(dai->dev, "%s: rate: %u, channels: %d.\n", __func__,\r\nruntime->rate, runtime->channels);\r\nswitch (fmt &\r\n(SND_SOC_DAIFMT_FORMAT_MASK | SND_SOC_DAIFMT_MASTER_MASK)) {\r\ncase SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_CBS_CFS:\r\ndev_dbg(dai->dev, "%s: SND_SOC_DAIFMT_I2S.\n", __func__);\r\nmsp_config->default_protdesc = 1;\r\nmsp_config->protocol = MSP_I2S_PROTOCOL;\r\nbreak;\r\ncase SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_CBM_CFM:\r\ndev_dbg(dai->dev, "%s: SND_SOC_DAIFMT_I2S.\n", __func__);\r\nmsp_config->data_size = MSP_DATA_BITS_16;\r\nmsp_config->protocol = MSP_I2S_PROTOCOL;\r\nret = setup_i2s_protdesc(prot_desc);\r\nif (ret < 0)\r\nreturn ret;\r\nbreak;\r\ncase SND_SOC_DAIFMT_DSP_A | SND_SOC_DAIFMT_CBS_CFS:\r\ncase SND_SOC_DAIFMT_DSP_A | SND_SOC_DAIFMT_CBM_CFM:\r\ncase SND_SOC_DAIFMT_DSP_B | SND_SOC_DAIFMT_CBS_CFS:\r\ncase SND_SOC_DAIFMT_DSP_B | SND_SOC_DAIFMT_CBM_CFM:\r\ndev_dbg(dai->dev, "%s: PCM format.\n", __func__);\r\nmsp_config->data_size = MSP_DATA_BITS_16;\r\nmsp_config->protocol = MSP_PCM_PROTOCOL;\r\nret = setup_pcm_protdesc(dai, fmt, prot_desc);\r\nif (ret < 0)\r\nreturn ret;\r\nret = setup_pcm_multichan(dai, msp_config);\r\nif (ret < 0)\r\nreturn ret;\r\nret = setup_pcm_framing(dai, runtime->rate, prot_desc);\r\nif (ret < 0)\r\nreturn ret;\r\nbreak;\r\ndefault:\r\ndev_err(dai->dev, "%s: Error: Unsopported format (%d)!\n",\r\n__func__, fmt);\r\nreturn -EINVAL;\r\n}\r\nreturn setup_clocking(dai, fmt, msp_config);\r\n}\r\nstatic int ux500_msp_dai_startup(struct snd_pcm_substream *substream,\r\nstruct snd_soc_dai *dai)\r\n{\r\nint ret = 0;\r\nstruct ux500_msp_i2s_drvdata *drvdata = dev_get_drvdata(dai->dev);\r\ndev_dbg(dai->dev, "%s: MSP %d (%s): Enter.\n", __func__, dai->id,\r\nsnd_pcm_stream_str(substream));\r\nret = regulator_enable(drvdata->reg_vape);\r\nif (ret != 0) {\r\ndev_err(drvdata->msp->dev,\r\n"%s: Failed to enable regulator!\n", __func__);\r\nreturn ret;\r\n}\r\ndev_dbg(dai->dev, "%s: Enabling MSP-clocks.\n", __func__);\r\nret = clk_prepare_enable(drvdata->pclk);\r\nif (ret) {\r\ndev_err(drvdata->msp->dev,\r\n"%s: Failed to prepare/enable pclk!\n", __func__);\r\ngoto err_pclk;\r\n}\r\nret = clk_prepare_enable(drvdata->clk);\r\nif (ret) {\r\ndev_err(drvdata->msp->dev,\r\n"%s: Failed to prepare/enable clk!\n", __func__);\r\ngoto err_clk;\r\n}\r\nreturn ret;\r\nerr_clk:\r\nclk_disable_unprepare(drvdata->pclk);\r\nerr_pclk:\r\nregulator_disable(drvdata->reg_vape);\r\nreturn ret;\r\n}\r\nstatic void ux500_msp_dai_shutdown(struct snd_pcm_substream *substream,\r\nstruct snd_soc_dai *dai)\r\n{\r\nint ret;\r\nstruct ux500_msp_i2s_drvdata *drvdata = dev_get_drvdata(dai->dev);\r\nbool is_playback = (substream->stream == SNDRV_PCM_STREAM_PLAYBACK);\r\ndev_dbg(dai->dev, "%s: MSP %d (%s): Enter.\n", __func__, dai->id,\r\nsnd_pcm_stream_str(substream));\r\nif (drvdata->vape_opp_constraint == 1) {\r\nprcmu_qos_update_requirement(PRCMU_QOS_APE_OPP,\r\n"ux500_msp_i2s", 50);\r\ndrvdata->vape_opp_constraint = 0;\r\n}\r\nif (ux500_msp_i2s_close(drvdata->msp,\r\nis_playback ? MSP_DIR_TX : MSP_DIR_RX)) {\r\ndev_err(dai->dev,\r\n"%s: Error: MSP %d (%s): Unable to close i2s.\n",\r\n__func__, dai->id, snd_pcm_stream_str(substream));\r\n}\r\nclk_disable_unprepare(drvdata->clk);\r\nclk_disable_unprepare(drvdata->pclk);\r\nret = regulator_disable(drvdata->reg_vape);\r\nif (ret < 0)\r\ndev_err(dai->dev,\r\n"%s: ERROR: Failed to disable regulator (%d)!\n",\r\n__func__, ret);\r\n}\r\nstatic int ux500_msp_dai_prepare(struct snd_pcm_substream *substream,\r\nstruct snd_soc_dai *dai)\r\n{\r\nint ret = 0;\r\nstruct ux500_msp_i2s_drvdata *drvdata = dev_get_drvdata(dai->dev);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct ux500_msp_config msp_config;\r\ndev_dbg(dai->dev, "%s: MSP %d (%s): Enter (rate = %d).\n", __func__,\r\ndai->id, snd_pcm_stream_str(substream), runtime->rate);\r\nsetup_msp_config(substream, dai, &msp_config);\r\nret = ux500_msp_i2s_open(drvdata->msp, &msp_config);\r\nif (ret < 0) {\r\ndev_err(dai->dev, "%s: Error: msp_setup failed (ret = %d)!\n",\r\n__func__, ret);\r\nreturn ret;\r\n}\r\nif ((drvdata->fmt & SND_SOC_DAIFMT_MASTER_MASK) &&\r\n(drvdata->msp->f_bitclk > 19200000)) {\r\nprcmu_qos_update_requirement(PRCMU_QOS_APE_OPP,\r\n"ux500-msp-i2s", 100);\r\ndrvdata->vape_opp_constraint = 1;\r\n} else {\r\nprcmu_qos_update_requirement(PRCMU_QOS_APE_OPP,\r\n"ux500-msp-i2s", 50);\r\ndrvdata->vape_opp_constraint = 0;\r\n}\r\nreturn ret;\r\n}\r\nstatic int ux500_msp_dai_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params,\r\nstruct snd_soc_dai *dai)\r\n{\r\nunsigned int mask, slots_active;\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct ux500_msp_i2s_drvdata *drvdata = dev_get_drvdata(dai->dev);\r\ndev_dbg(dai->dev, "%s: MSP %d (%s): Enter.\n",\r\n__func__, dai->id, snd_pcm_stream_str(substream));\r\nswitch (drvdata->fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\r\ncase SND_SOC_DAIFMT_I2S:\r\nsnd_pcm_hw_constraint_minmax(runtime,\r\nSNDRV_PCM_HW_PARAM_CHANNELS,\r\n1, 2);\r\nbreak;\r\ncase SND_SOC_DAIFMT_DSP_B:\r\ncase SND_SOC_DAIFMT_DSP_A:\r\nmask = substream->stream == SNDRV_PCM_STREAM_PLAYBACK ?\r\ndrvdata->tx_mask :\r\ndrvdata->rx_mask;\r\nslots_active = hweight32(mask);\r\ndev_dbg(dai->dev, "TDM-slots active: %d", slots_active);\r\nsnd_pcm_hw_constraint_minmax(runtime,\r\nSNDRV_PCM_HW_PARAM_CHANNELS,\r\nslots_active, slots_active);\r\nbreak;\r\ndefault:\r\ndev_err(dai->dev,\r\n"%s: Error: Unsupported protocol (fmt = 0x%x)!\n",\r\n__func__, drvdata->fmt);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ux500_msp_dai_set_dai_fmt(struct snd_soc_dai *dai,\r\nunsigned int fmt)\r\n{\r\nstruct ux500_msp_i2s_drvdata *drvdata = dev_get_drvdata(dai->dev);\r\ndev_dbg(dai->dev, "%s: MSP %d: Enter.\n", __func__, dai->id);\r\nswitch (fmt & (SND_SOC_DAIFMT_FORMAT_MASK |\r\nSND_SOC_DAIFMT_MASTER_MASK)) {\r\ncase SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_CBS_CFS:\r\ncase SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_CBM_CFM:\r\ncase SND_SOC_DAIFMT_DSP_B | SND_SOC_DAIFMT_CBS_CFS:\r\ncase SND_SOC_DAIFMT_DSP_B | SND_SOC_DAIFMT_CBM_CFM:\r\ncase SND_SOC_DAIFMT_DSP_A | SND_SOC_DAIFMT_CBS_CFS:\r\ncase SND_SOC_DAIFMT_DSP_A | SND_SOC_DAIFMT_CBM_CFM:\r\nbreak;\r\ndefault:\r\ndev_err(dai->dev,\r\n"%s: Error: Unsupported protocol/master (fmt = 0x%x)!\n",\r\n__func__, drvdata->fmt);\r\nreturn -EINVAL;\r\n}\r\nswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\r\ncase SND_SOC_DAIFMT_NB_NF:\r\ncase SND_SOC_DAIFMT_NB_IF:\r\ncase SND_SOC_DAIFMT_IB_IF:\r\nbreak;\r\ndefault:\r\ndev_err(dai->dev,\r\n"%s: Error: Unsupported inversion (fmt = 0x%x)!\n",\r\n__func__, drvdata->fmt);\r\nreturn -EINVAL;\r\n}\r\ndrvdata->fmt = fmt;\r\nreturn 0;\r\n}\r\nstatic int ux500_msp_dai_set_tdm_slot(struct snd_soc_dai *dai,\r\nunsigned int tx_mask,\r\nunsigned int rx_mask,\r\nint slots, int slot_width)\r\n{\r\nstruct ux500_msp_i2s_drvdata *drvdata = dev_get_drvdata(dai->dev);\r\nunsigned int cap;\r\nswitch (slots) {\r\ncase 1:\r\ncap = 0x01;\r\nbreak;\r\ncase 2:\r\ncap = 0x03;\r\nbreak;\r\ncase 8:\r\ncap = 0xFF;\r\nbreak;\r\ncase 16:\r\ncap = 0xFFFF;\r\nbreak;\r\ndefault:\r\ndev_err(dai->dev, "%s: Error: Unsupported slot-count (%d)!\n",\r\n__func__, slots);\r\nreturn -EINVAL;\r\n}\r\ndrvdata->slots = slots;\r\nif (!(slot_width == 16)) {\r\ndev_err(dai->dev, "%s: Error: Unsupported slot-width (%d)!\n",\r\n__func__, slot_width);\r\nreturn -EINVAL;\r\n}\r\ndrvdata->slot_width = slot_width;\r\ndrvdata->tx_mask = tx_mask & cap;\r\ndrvdata->rx_mask = rx_mask & cap;\r\nreturn 0;\r\n}\r\nstatic int ux500_msp_dai_set_dai_sysclk(struct snd_soc_dai *dai,\r\nint clk_id, unsigned int freq, int dir)\r\n{\r\nstruct ux500_msp_i2s_drvdata *drvdata = dev_get_drvdata(dai->dev);\r\ndev_dbg(dai->dev, "%s: MSP %d: Enter. clk-id: %d, freq: %u.\n",\r\n__func__, dai->id, clk_id, freq);\r\nswitch (clk_id) {\r\ncase UX500_MSP_MASTER_CLOCK:\r\ndrvdata->master_clk = freq;\r\nbreak;\r\ndefault:\r\ndev_err(dai->dev, "%s: MSP %d: Invalid clk-id (%d)!\n",\r\n__func__, dai->id, clk_id);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ux500_msp_dai_trigger(struct snd_pcm_substream *substream,\r\nint cmd, struct snd_soc_dai *dai)\r\n{\r\nint ret = 0;\r\nstruct ux500_msp_i2s_drvdata *drvdata = dev_get_drvdata(dai->dev);\r\ndev_dbg(dai->dev, "%s: MSP %d (%s): Enter (msp->id = %d, cmd = %d).\n",\r\n__func__, dai->id, snd_pcm_stream_str(substream),\r\n(int)drvdata->msp->id, cmd);\r\nret = ux500_msp_i2s_trigger(drvdata->msp, cmd, substream->stream);\r\nreturn ret;\r\n}\r\nstatic int ux500_msp_dai_probe(struct snd_soc_dai *dai)\r\n{\r\nstruct ux500_msp_i2s_drvdata *drvdata = dev_get_drvdata(dai->dev);\r\ndrvdata->playback_dma_data.dma_cfg = drvdata->msp->dma_cfg_tx;\r\ndrvdata->capture_dma_data.dma_cfg = drvdata->msp->dma_cfg_rx;\r\ndai->playback_dma_data = &drvdata->playback_dma_data;\r\ndai->capture_dma_data = &drvdata->capture_dma_data;\r\ndrvdata->playback_dma_data.data_size = drvdata->slot_width;\r\ndrvdata->capture_dma_data.data_size = drvdata->slot_width;\r\nreturn 0;\r\n}\r\nstatic int ux500_msp_drv_probe(struct platform_device *pdev)\r\n{\r\nstruct ux500_msp_i2s_drvdata *drvdata;\r\nint ret = 0;\r\ndev_dbg(&pdev->dev, "%s: Enter (pdev->name = %s).\n", __func__,\r\npdev->name);\r\ndrvdata = devm_kzalloc(&pdev->dev,\r\nsizeof(struct ux500_msp_i2s_drvdata),\r\nGFP_KERNEL);\r\nif (!drvdata)\r\nreturn -ENOMEM;\r\ndrvdata->fmt = 0;\r\ndrvdata->slots = 1;\r\ndrvdata->tx_mask = 0x01;\r\ndrvdata->rx_mask = 0x01;\r\ndrvdata->slot_width = 16;\r\ndrvdata->master_clk = MSP_INPUT_FREQ_APB;\r\ndrvdata->reg_vape = devm_regulator_get(&pdev->dev, "v-ape");\r\nif (IS_ERR(drvdata->reg_vape)) {\r\nret = (int)PTR_ERR(drvdata->reg_vape);\r\ndev_err(&pdev->dev,\r\n"%s: ERROR: Failed to get Vape supply (%d)!\n",\r\n__func__, ret);\r\nreturn ret;\r\n}\r\nprcmu_qos_add_requirement(PRCMU_QOS_APE_OPP, (char *)pdev->name, 50);\r\ndrvdata->pclk = clk_get(&pdev->dev, "apb_pclk");\r\nif (IS_ERR(drvdata->pclk)) {\r\nret = (int)PTR_ERR(drvdata->pclk);\r\ndev_err(&pdev->dev, "%s: ERROR: clk_get of pclk failed (%d)!\n",\r\n__func__, ret);\r\ngoto err_pclk;\r\n}\r\ndrvdata->clk = clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(drvdata->clk)) {\r\nret = (int)PTR_ERR(drvdata->clk);\r\ndev_err(&pdev->dev, "%s: ERROR: clk_get failed (%d)!\n",\r\n__func__, ret);\r\ngoto err_clk;\r\n}\r\nret = ux500_msp_i2s_init_msp(pdev, &drvdata->msp,\r\npdev->dev.platform_data);\r\nif (!drvdata->msp) {\r\ndev_err(&pdev->dev,\r\n"%s: ERROR: Failed to init MSP-struct (%d)!",\r\n__func__, ret);\r\ngoto err_init_msp;\r\n}\r\ndev_set_drvdata(&pdev->dev, drvdata);\r\nret = snd_soc_register_dai(&pdev->dev,\r\n&ux500_msp_dai_drv[drvdata->msp->id]);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "Error: %s: Failed to register MSP%d!\n",\r\n__func__, drvdata->msp->id);\r\ngoto err_init_msp;\r\n}\r\nret = ux500_pcm_register_platform(pdev);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev,\r\n"Error: %s: Failed to register PCM platform device!\n",\r\n__func__);\r\ngoto err_reg_plat;\r\n}\r\nreturn 0;\r\nerr_reg_plat:\r\nsnd_soc_unregister_dais(&pdev->dev, ARRAY_SIZE(ux500_msp_dai_drv));\r\nerr_init_msp:\r\nclk_put(drvdata->clk);\r\nerr_clk:\r\nclk_put(drvdata->pclk);\r\nerr_pclk:\r\ndevm_regulator_put(drvdata->reg_vape);\r\nreturn ret;\r\n}\r\nstatic int ux500_msp_drv_remove(struct platform_device *pdev)\r\n{\r\nstruct ux500_msp_i2s_drvdata *drvdata = dev_get_drvdata(&pdev->dev);\r\nux500_pcm_unregister_platform(pdev);\r\nsnd_soc_unregister_dais(&pdev->dev, ARRAY_SIZE(ux500_msp_dai_drv));\r\ndevm_regulator_put(drvdata->reg_vape);\r\nprcmu_qos_remove_requirement(PRCMU_QOS_APE_OPP, "ux500_msp_i2s");\r\nclk_put(drvdata->clk);\r\nclk_put(drvdata->pclk);\r\nux500_msp_i2s_cleanup_msp(pdev, drvdata->msp);\r\nreturn 0;\r\n}
