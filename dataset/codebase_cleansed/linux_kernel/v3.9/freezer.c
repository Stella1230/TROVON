bool freezing_slow_path(struct task_struct *p)\r\n{\r\nif (p->flags & PF_NOFREEZE)\r\nreturn false;\r\nif (pm_nosig_freezing || cgroup_freezing(p))\r\nreturn true;\r\nif (pm_freezing && !(p->flags & PF_KTHREAD))\r\nreturn true;\r\nreturn false;\r\n}\r\nbool __refrigerator(bool check_kthr_stop)\r\n{\r\nbool was_frozen = false;\r\nlong save = current->state;\r\npr_debug("%s entered refrigerator\n", current->comm);\r\nfor (;;) {\r\nset_current_state(TASK_UNINTERRUPTIBLE);\r\nspin_lock_irq(&freezer_lock);\r\ncurrent->flags |= PF_FROZEN;\r\nif (!freezing(current) ||\r\n(check_kthr_stop && kthread_should_stop()))\r\ncurrent->flags &= ~PF_FROZEN;\r\nspin_unlock_irq(&freezer_lock);\r\nif (!(current->flags & PF_FROZEN))\r\nbreak;\r\nwas_frozen = true;\r\nschedule();\r\n}\r\npr_debug("%s left refrigerator\n", current->comm);\r\nset_current_state(save);\r\nreturn was_frozen;\r\n}\r\nstatic void fake_signal_wake_up(struct task_struct *p)\r\n{\r\nunsigned long flags;\r\nif (lock_task_sighand(p, &flags)) {\r\nsignal_wake_up(p, 0);\r\nunlock_task_sighand(p, &flags);\r\n}\r\n}\r\nbool freeze_task(struct task_struct *p)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&freezer_lock, flags);\r\nif (!freezing(p) || frozen(p)) {\r\nspin_unlock_irqrestore(&freezer_lock, flags);\r\nreturn false;\r\n}\r\nif (!(p->flags & PF_KTHREAD))\r\nfake_signal_wake_up(p);\r\nelse\r\nwake_up_state(p, TASK_INTERRUPTIBLE);\r\nspin_unlock_irqrestore(&freezer_lock, flags);\r\nreturn true;\r\n}\r\nvoid __thaw_task(struct task_struct *p)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&freezer_lock, flags);\r\nif (frozen(p))\r\nwake_up_process(p);\r\nspin_unlock_irqrestore(&freezer_lock, flags);\r\n}\r\nbool set_freezable(void)\r\n{\r\nmight_sleep();\r\nspin_lock_irq(&freezer_lock);\r\ncurrent->flags &= ~PF_NOFREEZE;\r\nspin_unlock_irq(&freezer_lock);\r\nreturn try_to_freeze();\r\n}
