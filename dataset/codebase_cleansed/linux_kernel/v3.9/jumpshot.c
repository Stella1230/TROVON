static inline int jumpshot_bulk_read(struct us_data *us,\r\nunsigned char *data,\r\nunsigned int len)\r\n{\r\nif (len == 0)\r\nreturn USB_STOR_XFER_GOOD;\r\nUS_DEBUGP("jumpshot_bulk_read: len = %d\n", len);\r\nreturn usb_stor_bulk_transfer_buf(us, us->recv_bulk_pipe,\r\ndata, len, NULL);\r\n}\r\nstatic inline int jumpshot_bulk_write(struct us_data *us,\r\nunsigned char *data,\r\nunsigned int len)\r\n{\r\nif (len == 0)\r\nreturn USB_STOR_XFER_GOOD;\r\nUS_DEBUGP("jumpshot_bulk_write: len = %d\n", len);\r\nreturn usb_stor_bulk_transfer_buf(us, us->send_bulk_pipe,\r\ndata, len, NULL);\r\n}\r\nstatic int jumpshot_get_status(struct us_data *us)\r\n{\r\nint rc;\r\nif (!us)\r\nreturn USB_STOR_TRANSPORT_ERROR;\r\nrc = usb_stor_ctrl_transfer(us, us->recv_ctrl_pipe,\r\n0, 0xA0, 0, 7, us->iobuf, 1);\r\nif (rc != USB_STOR_XFER_GOOD)\r\nreturn USB_STOR_TRANSPORT_ERROR;\r\nif (us->iobuf[0] != 0x50) {\r\nUS_DEBUGP("jumpshot_get_status: 0x%2x\n",\r\nus->iobuf[0]);\r\nreturn USB_STOR_TRANSPORT_ERROR;\r\n}\r\nreturn USB_STOR_TRANSPORT_GOOD;\r\n}\r\nstatic int jumpshot_read_data(struct us_data *us,\r\nstruct jumpshot_info *info,\r\nu32 sector,\r\nu32 sectors)\r\n{\r\nunsigned char *command = us->iobuf;\r\nunsigned char *buffer;\r\nunsigned char thistime;\r\nunsigned int totallen, alloclen;\r\nint len, result;\r\nunsigned int sg_offset = 0;\r\nstruct scatterlist *sg = NULL;\r\nif (sector > 0x0FFFFFFF)\r\nreturn USB_STOR_TRANSPORT_ERROR;\r\ntotallen = sectors * info->ssize;\r\nalloclen = min(totallen, 65536u);\r\nbuffer = kmalloc(alloclen, GFP_NOIO);\r\nif (buffer == NULL)\r\nreturn USB_STOR_TRANSPORT_ERROR;\r\ndo {\r\nlen = min(totallen, alloclen);\r\nthistime = (len / info->ssize) & 0xff;\r\ncommand[0] = 0;\r\ncommand[1] = thistime;\r\ncommand[2] = sector & 0xFF;\r\ncommand[3] = (sector >> 8) & 0xFF;\r\ncommand[4] = (sector >> 16) & 0xFF;\r\ncommand[5] = 0xE0 | ((sector >> 24) & 0x0F);\r\ncommand[6] = 0x20;\r\nresult = usb_stor_ctrl_transfer(us, us->send_ctrl_pipe,\r\n0, 0x20, 0, 1, command, 7);\r\nif (result != USB_STOR_XFER_GOOD)\r\ngoto leave;\r\nresult = jumpshot_bulk_read(us, buffer, len);\r\nif (result != USB_STOR_XFER_GOOD)\r\ngoto leave;\r\nUS_DEBUGP("jumpshot_read_data: %d bytes\n", len);\r\nusb_stor_access_xfer_buf(buffer, len, us->srb,\r\n&sg, &sg_offset, TO_XFER_BUF);\r\nsector += thistime;\r\ntotallen -= len;\r\n} while (totallen > 0);\r\nkfree(buffer);\r\nreturn USB_STOR_TRANSPORT_GOOD;\r\nleave:\r\nkfree(buffer);\r\nreturn USB_STOR_TRANSPORT_ERROR;\r\n}\r\nstatic int jumpshot_write_data(struct us_data *us,\r\nstruct jumpshot_info *info,\r\nu32 sector,\r\nu32 sectors)\r\n{\r\nunsigned char *command = us->iobuf;\r\nunsigned char *buffer;\r\nunsigned char thistime;\r\nunsigned int totallen, alloclen;\r\nint len, result, waitcount;\r\nunsigned int sg_offset = 0;\r\nstruct scatterlist *sg = NULL;\r\nif (sector > 0x0FFFFFFF)\r\nreturn USB_STOR_TRANSPORT_ERROR;\r\ntotallen = sectors * info->ssize;\r\nalloclen = min(totallen, 65536u);\r\nbuffer = kmalloc(alloclen, GFP_NOIO);\r\nif (buffer == NULL)\r\nreturn USB_STOR_TRANSPORT_ERROR;\r\ndo {\r\nlen = min(totallen, alloclen);\r\nthistime = (len / info->ssize) & 0xff;\r\nusb_stor_access_xfer_buf(buffer, len, us->srb,\r\n&sg, &sg_offset, FROM_XFER_BUF);\r\ncommand[0] = 0;\r\ncommand[1] = thistime;\r\ncommand[2] = sector & 0xFF;\r\ncommand[3] = (sector >> 8) & 0xFF;\r\ncommand[4] = (sector >> 16) & 0xFF;\r\ncommand[5] = 0xE0 | ((sector >> 24) & 0x0F);\r\ncommand[6] = 0x30;\r\nresult = usb_stor_ctrl_transfer(us, us->send_ctrl_pipe,\r\n0, 0x20, 0, 1, command, 7);\r\nif (result != USB_STOR_XFER_GOOD)\r\ngoto leave;\r\nresult = jumpshot_bulk_write(us, buffer, len);\r\nif (result != USB_STOR_XFER_GOOD)\r\ngoto leave;\r\nwaitcount = 0;\r\ndo {\r\nresult = jumpshot_get_status(us);\r\nif (result != USB_STOR_TRANSPORT_GOOD) {\r\nmsleep(50);\r\n}\r\n} while ((result != USB_STOR_TRANSPORT_GOOD) && (waitcount < 10));\r\nif (result != USB_STOR_TRANSPORT_GOOD)\r\nUS_DEBUGP("jumpshot_write_data: Gah! Waitcount = 10. Bad write!?\n");\r\nsector += thistime;\r\ntotallen -= len;\r\n} while (totallen > 0);\r\nkfree(buffer);\r\nreturn result;\r\nleave:\r\nkfree(buffer);\r\nreturn USB_STOR_TRANSPORT_ERROR;\r\n}\r\nstatic int jumpshot_id_device(struct us_data *us,\r\nstruct jumpshot_info *info)\r\n{\r\nunsigned char *command = us->iobuf;\r\nunsigned char *reply;\r\nint rc;\r\nif (!info)\r\nreturn USB_STOR_TRANSPORT_ERROR;\r\ncommand[0] = 0xE0;\r\ncommand[1] = 0xEC;\r\nreply = kmalloc(512, GFP_NOIO);\r\nif (!reply)\r\nreturn USB_STOR_TRANSPORT_ERROR;\r\nrc = usb_stor_ctrl_transfer(us, us->send_ctrl_pipe,\r\n0, 0x20, 0, 6, command, 2);\r\nif (rc != USB_STOR_XFER_GOOD) {\r\nUS_DEBUGP("jumpshot_id_device: Gah! "\r\n"send_control for read_capacity failed\n");\r\nrc = USB_STOR_TRANSPORT_ERROR;\r\ngoto leave;\r\n}\r\nrc = jumpshot_bulk_read(us, reply, 512);\r\nif (rc != USB_STOR_XFER_GOOD) {\r\nrc = USB_STOR_TRANSPORT_ERROR;\r\ngoto leave;\r\n}\r\ninfo->sectors = ((u32)(reply[117]) << 24) |\r\n((u32)(reply[116]) << 16) |\r\n((u32)(reply[115]) << 8) |\r\n((u32)(reply[114]) );\r\nrc = USB_STOR_TRANSPORT_GOOD;\r\nleave:\r\nkfree(reply);\r\nreturn rc;\r\n}\r\nstatic int jumpshot_handle_mode_sense(struct us_data *us,\r\nstruct scsi_cmnd * srb,\r\nint sense_6)\r\n{\r\nstatic unsigned char rw_err_page[12] = {\r\n0x1, 0xA, 0x21, 1, 0, 0, 0, 0, 1, 0, 0, 0\r\n};\r\nstatic unsigned char cache_page[12] = {\r\n0x8, 0xA, 0x1, 0, 0, 0, 0, 0, 0, 0, 0, 0\r\n};\r\nstatic unsigned char rbac_page[12] = {\r\n0x1B, 0xA, 0, 0x81, 0, 0, 0, 0, 0, 0, 0, 0\r\n};\r\nstatic unsigned char timer_page[8] = {\r\n0x1C, 0x6, 0, 0, 0, 0\r\n};\r\nunsigned char pc, page_code;\r\nunsigned int i = 0;\r\nstruct jumpshot_info *info = (struct jumpshot_info *) (us->extra);\r\nunsigned char *ptr = us->iobuf;\r\npc = srb->cmnd[2] >> 6;\r\npage_code = srb->cmnd[2] & 0x3F;\r\nswitch (pc) {\r\ncase 0x0:\r\nUS_DEBUGP("jumpshot_handle_mode_sense: Current values\n");\r\nbreak;\r\ncase 0x1:\r\nUS_DEBUGP("jumpshot_handle_mode_sense: Changeable values\n");\r\nbreak;\r\ncase 0x2:\r\nUS_DEBUGP("jumpshot_handle_mode_sense: Default values\n");\r\nbreak;\r\ncase 0x3:\r\nUS_DEBUGP("jumpshot_handle_mode_sense: Saves values\n");\r\nbreak;\r\n}\r\nmemset(ptr, 0, 8);\r\nif (sense_6) {\r\nptr[2] = 0x00;\r\ni = 4;\r\n} else {\r\nptr[3] = 0x00;\r\ni = 8;\r\n}\r\nswitch (page_code) {\r\ncase 0x0:\r\ninfo->sense_key = 0x05;\r\ninfo->sense_asc = 0x24;\r\ninfo->sense_ascq = 0x00;\r\nreturn USB_STOR_TRANSPORT_FAILED;\r\ncase 0x1:\r\nmemcpy(ptr + i, rw_err_page, sizeof(rw_err_page));\r\ni += sizeof(rw_err_page);\r\nbreak;\r\ncase 0x8:\r\nmemcpy(ptr + i, cache_page, sizeof(cache_page));\r\ni += sizeof(cache_page);\r\nbreak;\r\ncase 0x1B:\r\nmemcpy(ptr + i, rbac_page, sizeof(rbac_page));\r\ni += sizeof(rbac_page);\r\nbreak;\r\ncase 0x1C:\r\nmemcpy(ptr + i, timer_page, sizeof(timer_page));\r\ni += sizeof(timer_page);\r\nbreak;\r\ncase 0x3F:\r\nmemcpy(ptr + i, timer_page, sizeof(timer_page));\r\ni += sizeof(timer_page);\r\nmemcpy(ptr + i, rbac_page, sizeof(rbac_page));\r\ni += sizeof(rbac_page);\r\nmemcpy(ptr + i, cache_page, sizeof(cache_page));\r\ni += sizeof(cache_page);\r\nmemcpy(ptr + i, rw_err_page, sizeof(rw_err_page));\r\ni += sizeof(rw_err_page);\r\nbreak;\r\n}\r\nif (sense_6)\r\nptr[0] = i - 1;\r\nelse\r\n((__be16 *) ptr)[0] = cpu_to_be16(i - 2);\r\nusb_stor_set_xfer_buf(ptr, i, srb);\r\nreturn USB_STOR_TRANSPORT_GOOD;\r\n}\r\nstatic void jumpshot_info_destructor(void *extra)\r\n{\r\n}\r\nstatic int jumpshot_transport(struct scsi_cmnd *srb, struct us_data *us)\r\n{\r\nstruct jumpshot_info *info;\r\nint rc;\r\nunsigned long block, blocks;\r\nunsigned char *ptr = us->iobuf;\r\nstatic unsigned char inquiry_response[8] = {\r\n0x00, 0x80, 0x00, 0x01, 0x1F, 0x00, 0x00, 0x00\r\n};\r\nif (!us->extra) {\r\nus->extra = kzalloc(sizeof(struct jumpshot_info), GFP_NOIO);\r\nif (!us->extra) {\r\nUS_DEBUGP("jumpshot_transport: Gah! Can't allocate storage for jumpshot info struct!\n");\r\nreturn USB_STOR_TRANSPORT_ERROR;\r\n}\r\nus->extra_destructor = jumpshot_info_destructor;\r\n}\r\ninfo = (struct jumpshot_info *) (us->extra);\r\nif (srb->cmnd[0] == INQUIRY) {\r\nUS_DEBUGP("jumpshot_transport: INQUIRY. Returning bogus response.\n");\r\nmemcpy(ptr, inquiry_response, sizeof(inquiry_response));\r\nfill_inquiry_response(us, ptr, 36);\r\nreturn USB_STOR_TRANSPORT_GOOD;\r\n}\r\nif (srb->cmnd[0] == READ_CAPACITY) {\r\ninfo->ssize = 0x200;\r\nrc = jumpshot_get_status(us);\r\nif (rc != USB_STOR_TRANSPORT_GOOD)\r\nreturn rc;\r\nrc = jumpshot_id_device(us, info);\r\nif (rc != USB_STOR_TRANSPORT_GOOD)\r\nreturn rc;\r\nUS_DEBUGP("jumpshot_transport: READ_CAPACITY: %ld sectors, %ld bytes per sector\n",\r\ninfo->sectors, info->ssize);\r\n((__be32 *) ptr)[0] = cpu_to_be32(info->sectors - 1);\r\n((__be32 *) ptr)[1] = cpu_to_be32(info->ssize);\r\nusb_stor_set_xfer_buf(ptr, 8, srb);\r\nreturn USB_STOR_TRANSPORT_GOOD;\r\n}\r\nif (srb->cmnd[0] == MODE_SELECT_10) {\r\nUS_DEBUGP("jumpshot_transport: Gah! MODE_SELECT_10.\n");\r\nreturn USB_STOR_TRANSPORT_ERROR;\r\n}\r\nif (srb->cmnd[0] == READ_10) {\r\nblock = ((u32)(srb->cmnd[2]) << 24) | ((u32)(srb->cmnd[3]) << 16) |\r\n((u32)(srb->cmnd[4]) << 8) | ((u32)(srb->cmnd[5]));\r\nblocks = ((u32)(srb->cmnd[7]) << 8) | ((u32)(srb->cmnd[8]));\r\nUS_DEBUGP("jumpshot_transport: READ_10: read block 0x%04lx count %ld\n", block, blocks);\r\nreturn jumpshot_read_data(us, info, block, blocks);\r\n}\r\nif (srb->cmnd[0] == READ_12) {\r\nblock = ((u32)(srb->cmnd[2]) << 24) | ((u32)(srb->cmnd[3]) << 16) |\r\n((u32)(srb->cmnd[4]) << 8) | ((u32)(srb->cmnd[5]));\r\nblocks = ((u32)(srb->cmnd[6]) << 24) | ((u32)(srb->cmnd[7]) << 16) |\r\n((u32)(srb->cmnd[8]) << 8) | ((u32)(srb->cmnd[9]));\r\nUS_DEBUGP("jumpshot_transport: READ_12: read block 0x%04lx count %ld\n", block, blocks);\r\nreturn jumpshot_read_data(us, info, block, blocks);\r\n}\r\nif (srb->cmnd[0] == WRITE_10) {\r\nblock = ((u32)(srb->cmnd[2]) << 24) | ((u32)(srb->cmnd[3]) << 16) |\r\n((u32)(srb->cmnd[4]) << 8) | ((u32)(srb->cmnd[5]));\r\nblocks = ((u32)(srb->cmnd[7]) << 8) | ((u32)(srb->cmnd[8]));\r\nUS_DEBUGP("jumpshot_transport: WRITE_10: write block 0x%04lx count %ld\n", block, blocks);\r\nreturn jumpshot_write_data(us, info, block, blocks);\r\n}\r\nif (srb->cmnd[0] == WRITE_12) {\r\nblock = ((u32)(srb->cmnd[2]) << 24) | ((u32)(srb->cmnd[3]) << 16) |\r\n((u32)(srb->cmnd[4]) << 8) | ((u32)(srb->cmnd[5]));\r\nblocks = ((u32)(srb->cmnd[6]) << 24) | ((u32)(srb->cmnd[7]) << 16) |\r\n((u32)(srb->cmnd[8]) << 8) | ((u32)(srb->cmnd[9]));\r\nUS_DEBUGP("jumpshot_transport: WRITE_12: write block 0x%04lx count %ld\n", block, blocks);\r\nreturn jumpshot_write_data(us, info, block, blocks);\r\n}\r\nif (srb->cmnd[0] == TEST_UNIT_READY) {\r\nUS_DEBUGP("jumpshot_transport: TEST_UNIT_READY.\n");\r\nreturn jumpshot_get_status(us);\r\n}\r\nif (srb->cmnd[0] == REQUEST_SENSE) {\r\nUS_DEBUGP("jumpshot_transport: REQUEST_SENSE.\n");\r\nmemset(ptr, 0, 18);\r\nptr[0] = 0xF0;\r\nptr[2] = info->sense_key;\r\nptr[7] = 11;\r\nptr[12] = info->sense_asc;\r\nptr[13] = info->sense_ascq;\r\nusb_stor_set_xfer_buf(ptr, 18, srb);\r\nreturn USB_STOR_TRANSPORT_GOOD;\r\n}\r\nif (srb->cmnd[0] == MODE_SENSE) {\r\nUS_DEBUGP("jumpshot_transport: MODE_SENSE_6 detected\n");\r\nreturn jumpshot_handle_mode_sense(us, srb, 1);\r\n}\r\nif (srb->cmnd[0] == MODE_SENSE_10) {\r\nUS_DEBUGP("jumpshot_transport: MODE_SENSE_10 detected\n");\r\nreturn jumpshot_handle_mode_sense(us, srb, 0);\r\n}\r\nif (srb->cmnd[0] == ALLOW_MEDIUM_REMOVAL) {\r\nreturn USB_STOR_TRANSPORT_GOOD;\r\n}\r\nif (srb->cmnd[0] == START_STOP) {\r\nUS_DEBUGP("jumpshot_transport: START_STOP.\n");\r\nrc = jumpshot_id_device(us, info);\r\nif (rc == USB_STOR_TRANSPORT_GOOD) {\r\ninfo->sense_key = NO_SENSE;\r\nsrb->result = SUCCESS;\r\n} else {\r\ninfo->sense_key = UNIT_ATTENTION;\r\nsrb->result = SAM_STAT_CHECK_CONDITION;\r\n}\r\nreturn rc;\r\n}\r\nUS_DEBUGP("jumpshot_transport: Gah! Unknown command: %d (0x%x)\n",\r\nsrb->cmnd[0], srb->cmnd[0]);\r\ninfo->sense_key = 0x05;\r\ninfo->sense_asc = 0x20;\r\ninfo->sense_ascq = 0x00;\r\nreturn USB_STOR_TRANSPORT_FAILED;\r\n}\r\nstatic int jumpshot_probe(struct usb_interface *intf,\r\nconst struct usb_device_id *id)\r\n{\r\nstruct us_data *us;\r\nint result;\r\nresult = usb_stor_probe1(&us, intf, id,\r\n(id - jumpshot_usb_ids) + jumpshot_unusual_dev_list);\r\nif (result)\r\nreturn result;\r\nus->transport_name = "Lexar Jumpshot Control/Bulk";\r\nus->transport = jumpshot_transport;\r\nus->transport_reset = usb_stor_Bulk_reset;\r\nus->max_lun = 1;\r\nresult = usb_stor_probe2(us);\r\nreturn result;\r\n}
