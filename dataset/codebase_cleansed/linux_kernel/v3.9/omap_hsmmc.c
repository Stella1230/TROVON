static int omap_hsmmc_card_detect(struct device *dev, int slot)\r\n{\r\nstruct omap_hsmmc_host *host = dev_get_drvdata(dev);\r\nstruct omap_mmc_platform_data *mmc = host->pdata;\r\nreturn !gpio_get_value_cansleep(mmc->slots[0].switch_pin);\r\n}\r\nstatic int omap_hsmmc_get_wp(struct device *dev, int slot)\r\n{\r\nstruct omap_hsmmc_host *host = dev_get_drvdata(dev);\r\nstruct omap_mmc_platform_data *mmc = host->pdata;\r\nreturn gpio_get_value_cansleep(mmc->slots[0].gpio_wp);\r\n}\r\nstatic int omap_hsmmc_get_cover_state(struct device *dev, int slot)\r\n{\r\nstruct omap_hsmmc_host *host = dev_get_drvdata(dev);\r\nstruct omap_mmc_platform_data *mmc = host->pdata;\r\nreturn !gpio_get_value_cansleep(mmc->slots[0].switch_pin);\r\n}\r\nstatic int omap_hsmmc_suspend_cdirq(struct device *dev, int slot)\r\n{\r\nstruct omap_hsmmc_host *host = dev_get_drvdata(dev);\r\nstruct omap_mmc_platform_data *mmc = host->pdata;\r\ndisable_irq(mmc->slots[0].card_detect_irq);\r\nreturn 0;\r\n}\r\nstatic int omap_hsmmc_resume_cdirq(struct device *dev, int slot)\r\n{\r\nstruct omap_hsmmc_host *host = dev_get_drvdata(dev);\r\nstruct omap_mmc_platform_data *mmc = host->pdata;\r\nenable_irq(mmc->slots[0].card_detect_irq);\r\nreturn 0;\r\n}\r\nstatic int omap_hsmmc_set_power(struct device *dev, int slot, int power_on,\r\nint vdd)\r\n{\r\nstruct omap_hsmmc_host *host =\r\nplatform_get_drvdata(to_platform_device(dev));\r\nint ret = 0;\r\nif (!host->vcc)\r\nreturn 0;\r\nif (dev->of_node && !vdd)\r\nreturn 0;\r\nif (mmc_slot(host).before_set_reg)\r\nmmc_slot(host).before_set_reg(dev, slot, power_on, vdd);\r\nif (power_on) {\r\nret = mmc_regulator_set_ocr(host->mmc, host->vcc, vdd);\r\nif (ret == 0 && host->vcc_aux) {\r\nret = regulator_enable(host->vcc_aux);\r\nif (ret < 0)\r\nret = mmc_regulator_set_ocr(host->mmc,\r\nhost->vcc, 0);\r\n}\r\n} else {\r\nif (host->vcc_aux)\r\nret = regulator_disable(host->vcc_aux);\r\nif (!ret) {\r\nret = mmc_regulator_set_ocr(host->mmc,\r\nhost->vcc, 0);\r\n}\r\n}\r\nif (mmc_slot(host).after_set_reg)\r\nmmc_slot(host).after_set_reg(dev, slot, power_on, vdd);\r\nreturn ret;\r\n}\r\nstatic int omap_hsmmc_reg_get(struct omap_hsmmc_host *host)\r\n{\r\nstruct regulator *reg;\r\nint ocr_value = 0;\r\nreg = regulator_get(host->dev, "vmmc");\r\nif (IS_ERR(reg)) {\r\ndev_err(host->dev, "vmmc regulator missing\n");\r\nreturn PTR_ERR(reg);\r\n} else {\r\nmmc_slot(host).set_power = omap_hsmmc_set_power;\r\nhost->vcc = reg;\r\nocr_value = mmc_regulator_get_ocrmask(reg);\r\nif (!mmc_slot(host).ocr_mask) {\r\nmmc_slot(host).ocr_mask = ocr_value;\r\n} else {\r\nif (!(mmc_slot(host).ocr_mask & ocr_value)) {\r\ndev_err(host->dev, "ocrmask %x is not supported\n",\r\nmmc_slot(host).ocr_mask);\r\nmmc_slot(host).ocr_mask = 0;\r\nreturn -EINVAL;\r\n}\r\n}\r\nreg = regulator_get(host->dev, "vmmc_aux");\r\nhost->vcc_aux = IS_ERR(reg) ? NULL : reg;\r\nif (mmc_slot(host).no_regulator_off_init)\r\nreturn 0;\r\nif (regulator_is_enabled(host->vcc) > 0 ||\r\n(host->vcc_aux && regulator_is_enabled(host->vcc_aux))) {\r\nint vdd = ffs(mmc_slot(host).ocr_mask) - 1;\r\nmmc_slot(host).set_power(host->dev, host->slot_id,\r\n1, vdd);\r\nmmc_slot(host).set_power(host->dev, host->slot_id,\r\n0, 0);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void omap_hsmmc_reg_put(struct omap_hsmmc_host *host)\r\n{\r\nregulator_put(host->vcc);\r\nregulator_put(host->vcc_aux);\r\nmmc_slot(host).set_power = NULL;\r\n}\r\nstatic inline int omap_hsmmc_have_reg(void)\r\n{\r\nreturn 1;\r\n}\r\nstatic inline int omap_hsmmc_reg_get(struct omap_hsmmc_host *host)\r\n{\r\nreturn -EINVAL;\r\n}\r\nstatic inline void omap_hsmmc_reg_put(struct omap_hsmmc_host *host)\r\n{\r\n}\r\nstatic inline int omap_hsmmc_have_reg(void)\r\n{\r\nreturn 0;\r\n}\r\nstatic int omap_hsmmc_gpio_init(struct omap_mmc_platform_data *pdata)\r\n{\r\nint ret;\r\nif (gpio_is_valid(pdata->slots[0].switch_pin)) {\r\nif (pdata->slots[0].cover)\r\npdata->slots[0].get_cover_state =\r\nomap_hsmmc_get_cover_state;\r\nelse\r\npdata->slots[0].card_detect = omap_hsmmc_card_detect;\r\npdata->slots[0].card_detect_irq =\r\ngpio_to_irq(pdata->slots[0].switch_pin);\r\nret = gpio_request(pdata->slots[0].switch_pin, "mmc_cd");\r\nif (ret)\r\nreturn ret;\r\nret = gpio_direction_input(pdata->slots[0].switch_pin);\r\nif (ret)\r\ngoto err_free_sp;\r\n} else\r\npdata->slots[0].switch_pin = -EINVAL;\r\nif (gpio_is_valid(pdata->slots[0].gpio_wp)) {\r\npdata->slots[0].get_ro = omap_hsmmc_get_wp;\r\nret = gpio_request(pdata->slots[0].gpio_wp, "mmc_wp");\r\nif (ret)\r\ngoto err_free_cd;\r\nret = gpio_direction_input(pdata->slots[0].gpio_wp);\r\nif (ret)\r\ngoto err_free_wp;\r\n} else\r\npdata->slots[0].gpio_wp = -EINVAL;\r\nreturn 0;\r\nerr_free_wp:\r\ngpio_free(pdata->slots[0].gpio_wp);\r\nerr_free_cd:\r\nif (gpio_is_valid(pdata->slots[0].switch_pin))\r\nerr_free_sp:\r\ngpio_free(pdata->slots[0].switch_pin);\r\nreturn ret;\r\n}\r\nstatic void omap_hsmmc_gpio_free(struct omap_mmc_platform_data *pdata)\r\n{\r\nif (gpio_is_valid(pdata->slots[0].gpio_wp))\r\ngpio_free(pdata->slots[0].gpio_wp);\r\nif (gpio_is_valid(pdata->slots[0].switch_pin))\r\ngpio_free(pdata->slots[0].switch_pin);\r\n}\r\nstatic void omap_hsmmc_start_clock(struct omap_hsmmc_host *host)\r\n{\r\nOMAP_HSMMC_WRITE(host->base, SYSCTL,\r\nOMAP_HSMMC_READ(host->base, SYSCTL) | CEN);\r\n}\r\nstatic void omap_hsmmc_stop_clock(struct omap_hsmmc_host *host)\r\n{\r\nOMAP_HSMMC_WRITE(host->base, SYSCTL,\r\nOMAP_HSMMC_READ(host->base, SYSCTL) & ~CEN);\r\nif ((OMAP_HSMMC_READ(host->base, SYSCTL) & CEN) != 0x0)\r\ndev_dbg(mmc_dev(host->mmc), "MMC Clock is not stopped\n");\r\n}\r\nstatic void omap_hsmmc_enable_irq(struct omap_hsmmc_host *host,\r\nstruct mmc_command *cmd)\r\n{\r\nunsigned int irq_mask;\r\nif (host->use_dma)\r\nirq_mask = INT_EN_MASK & ~(BRR_EN | BWR_EN);\r\nelse\r\nirq_mask = INT_EN_MASK;\r\nif (cmd->opcode == MMC_ERASE)\r\nirq_mask &= ~DTO_EN;\r\nOMAP_HSMMC_WRITE(host->base, STAT, STAT_CLEAR);\r\nOMAP_HSMMC_WRITE(host->base, ISE, irq_mask);\r\nOMAP_HSMMC_WRITE(host->base, IE, irq_mask);\r\n}\r\nstatic void omap_hsmmc_disable_irq(struct omap_hsmmc_host *host)\r\n{\r\nOMAP_HSMMC_WRITE(host->base, ISE, 0);\r\nOMAP_HSMMC_WRITE(host->base, IE, 0);\r\nOMAP_HSMMC_WRITE(host->base, STAT, STAT_CLEAR);\r\n}\r\nstatic u16 calc_divisor(struct omap_hsmmc_host *host, struct mmc_ios *ios)\r\n{\r\nu16 dsor = 0;\r\nif (ios->clock) {\r\ndsor = DIV_ROUND_UP(clk_get_rate(host->fclk), ios->clock);\r\nif (dsor > 250)\r\ndsor = 250;\r\n}\r\nreturn dsor;\r\n}\r\nstatic void omap_hsmmc_set_clock(struct omap_hsmmc_host *host)\r\n{\r\nstruct mmc_ios *ios = &host->mmc->ios;\r\nunsigned long regval;\r\nunsigned long timeout;\r\nunsigned long clkdiv;\r\ndev_vdbg(mmc_dev(host->mmc), "Set clock to %uHz\n", ios->clock);\r\nomap_hsmmc_stop_clock(host);\r\nregval = OMAP_HSMMC_READ(host->base, SYSCTL);\r\nregval = regval & ~(CLKD_MASK | DTO_MASK);\r\nclkdiv = calc_divisor(host, ios);\r\nregval = regval | (clkdiv << 6) | (DTO << 16);\r\nOMAP_HSMMC_WRITE(host->base, SYSCTL, regval);\r\nOMAP_HSMMC_WRITE(host->base, SYSCTL,\r\nOMAP_HSMMC_READ(host->base, SYSCTL) | ICE);\r\ntimeout = jiffies + msecs_to_jiffies(MMC_TIMEOUT_MS);\r\nwhile ((OMAP_HSMMC_READ(host->base, SYSCTL) & ICS) != ICS\r\n&& time_before(jiffies, timeout))\r\ncpu_relax();\r\nif ((mmc_slot(host).features & HSMMC_HAS_HSPE_SUPPORT) &&\r\n(ios->timing != MMC_TIMING_UHS_DDR50) &&\r\n((OMAP_HSMMC_READ(host->base, CAPA) & HSS) == HSS)) {\r\nregval = OMAP_HSMMC_READ(host->base, HCTL);\r\nif (clkdiv && (clk_get_rate(host->fclk)/clkdiv) > 25000000)\r\nregval |= HSPE;\r\nelse\r\nregval &= ~HSPE;\r\nOMAP_HSMMC_WRITE(host->base, HCTL, regval);\r\n}\r\nomap_hsmmc_start_clock(host);\r\n}\r\nstatic void omap_hsmmc_set_bus_width(struct omap_hsmmc_host *host)\r\n{\r\nstruct mmc_ios *ios = &host->mmc->ios;\r\nu32 con;\r\ncon = OMAP_HSMMC_READ(host->base, CON);\r\nif (ios->timing == MMC_TIMING_UHS_DDR50)\r\ncon |= DDR;\r\nelse\r\ncon &= ~DDR;\r\nswitch (ios->bus_width) {\r\ncase MMC_BUS_WIDTH_8:\r\nOMAP_HSMMC_WRITE(host->base, CON, con | DW8);\r\nbreak;\r\ncase MMC_BUS_WIDTH_4:\r\nOMAP_HSMMC_WRITE(host->base, CON, con & ~DW8);\r\nOMAP_HSMMC_WRITE(host->base, HCTL,\r\nOMAP_HSMMC_READ(host->base, HCTL) | FOUR_BIT);\r\nbreak;\r\ncase MMC_BUS_WIDTH_1:\r\nOMAP_HSMMC_WRITE(host->base, CON, con & ~DW8);\r\nOMAP_HSMMC_WRITE(host->base, HCTL,\r\nOMAP_HSMMC_READ(host->base, HCTL) & ~FOUR_BIT);\r\nbreak;\r\n}\r\n}\r\nstatic void omap_hsmmc_set_bus_mode(struct omap_hsmmc_host *host)\r\n{\r\nstruct mmc_ios *ios = &host->mmc->ios;\r\nu32 con;\r\ncon = OMAP_HSMMC_READ(host->base, CON);\r\nif (ios->bus_mode == MMC_BUSMODE_OPENDRAIN)\r\nOMAP_HSMMC_WRITE(host->base, CON, con | OD);\r\nelse\r\nOMAP_HSMMC_WRITE(host->base, CON, con & ~OD);\r\n}\r\nstatic int omap_hsmmc_context_restore(struct omap_hsmmc_host *host)\r\n{\r\nstruct mmc_ios *ios = &host->mmc->ios;\r\nstruct omap_mmc_platform_data *pdata = host->pdata;\r\nint context_loss = 0;\r\nu32 hctl, capa;\r\nunsigned long timeout;\r\nif (pdata->get_context_loss_count) {\r\ncontext_loss = pdata->get_context_loss_count(host->dev);\r\nif (context_loss < 0)\r\nreturn 1;\r\n}\r\ndev_dbg(mmc_dev(host->mmc), "context was %slost\n",\r\ncontext_loss == host->context_loss ? "not " : "");\r\nif (host->context_loss == context_loss)\r\nreturn 1;\r\nif (!OMAP_HSMMC_READ(host->base, SYSSTATUS) & RESETDONE)\r\nreturn 1;\r\nif (host->pdata->controller_flags & OMAP_HSMMC_SUPPORTS_DUAL_VOLT) {\r\nif (host->power_mode != MMC_POWER_OFF &&\r\n(1 << ios->vdd) <= MMC_VDD_23_24)\r\nhctl = SDVS18;\r\nelse\r\nhctl = SDVS30;\r\ncapa = VS30 | VS18;\r\n} else {\r\nhctl = SDVS18;\r\ncapa = VS18;\r\n}\r\nOMAP_HSMMC_WRITE(host->base, HCTL,\r\nOMAP_HSMMC_READ(host->base, HCTL) | hctl);\r\nOMAP_HSMMC_WRITE(host->base, CAPA,\r\nOMAP_HSMMC_READ(host->base, CAPA) | capa);\r\nOMAP_HSMMC_WRITE(host->base, HCTL,\r\nOMAP_HSMMC_READ(host->base, HCTL) | SDBP);\r\ntimeout = jiffies + msecs_to_jiffies(MMC_TIMEOUT_MS);\r\nwhile ((OMAP_HSMMC_READ(host->base, HCTL) & SDBP) != SDBP\r\n&& time_before(jiffies, timeout))\r\n;\r\nomap_hsmmc_disable_irq(host);\r\nif (host->power_mode == MMC_POWER_OFF)\r\ngoto out;\r\nomap_hsmmc_set_bus_width(host);\r\nomap_hsmmc_set_clock(host);\r\nomap_hsmmc_set_bus_mode(host);\r\nout:\r\nhost->context_loss = context_loss;\r\ndev_dbg(mmc_dev(host->mmc), "context is restored\n");\r\nreturn 0;\r\n}\r\nstatic void omap_hsmmc_context_save(struct omap_hsmmc_host *host)\r\n{\r\nstruct omap_mmc_platform_data *pdata = host->pdata;\r\nint context_loss;\r\nif (pdata->get_context_loss_count) {\r\ncontext_loss = pdata->get_context_loss_count(host->dev);\r\nif (context_loss < 0)\r\nreturn;\r\nhost->context_loss = context_loss;\r\n}\r\n}\r\nstatic int omap_hsmmc_context_restore(struct omap_hsmmc_host *host)\r\n{\r\nreturn 0;\r\n}\r\nstatic void omap_hsmmc_context_save(struct omap_hsmmc_host *host)\r\n{\r\n}\r\nstatic void send_init_stream(struct omap_hsmmc_host *host)\r\n{\r\nint reg = 0;\r\nunsigned long timeout;\r\nif (host->protect_card)\r\nreturn;\r\ndisable_irq(host->irq);\r\nOMAP_HSMMC_WRITE(host->base, IE, INT_EN_MASK);\r\nOMAP_HSMMC_WRITE(host->base, CON,\r\nOMAP_HSMMC_READ(host->base, CON) | INIT_STREAM);\r\nOMAP_HSMMC_WRITE(host->base, CMD, INIT_STREAM_CMD);\r\ntimeout = jiffies + msecs_to_jiffies(MMC_TIMEOUT_MS);\r\nwhile ((reg != CC_EN) && time_before(jiffies, timeout))\r\nreg = OMAP_HSMMC_READ(host->base, STAT) & CC_EN;\r\nOMAP_HSMMC_WRITE(host->base, CON,\r\nOMAP_HSMMC_READ(host->base, CON) & ~INIT_STREAM);\r\nOMAP_HSMMC_WRITE(host->base, STAT, STAT_CLEAR);\r\nOMAP_HSMMC_READ(host->base, STAT);\r\nenable_irq(host->irq);\r\n}\r\nstatic inline\r\nint omap_hsmmc_cover_is_closed(struct omap_hsmmc_host *host)\r\n{\r\nint r = 1;\r\nif (mmc_slot(host).get_cover_state)\r\nr = mmc_slot(host).get_cover_state(host->dev, host->slot_id);\r\nreturn r;\r\n}\r\nstatic ssize_t\r\nomap_hsmmc_show_cover_switch(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct mmc_host *mmc = container_of(dev, struct mmc_host, class_dev);\r\nstruct omap_hsmmc_host *host = mmc_priv(mmc);\r\nreturn sprintf(buf, "%s\n",\r\nomap_hsmmc_cover_is_closed(host) ? "closed" : "open");\r\n}\r\nstatic ssize_t\r\nomap_hsmmc_show_slot_name(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct mmc_host *mmc = container_of(dev, struct mmc_host, class_dev);\r\nstruct omap_hsmmc_host *host = mmc_priv(mmc);\r\nreturn sprintf(buf, "%s\n", mmc_slot(host).name);\r\n}\r\nstatic void\r\nomap_hsmmc_start_command(struct omap_hsmmc_host *host, struct mmc_command *cmd,\r\nstruct mmc_data *data)\r\n{\r\nint cmdreg = 0, resptype = 0, cmdtype = 0;\r\ndev_vdbg(mmc_dev(host->mmc), "%s: CMD%d, argument 0x%08x\n",\r\nmmc_hostname(host->mmc), cmd->opcode, cmd->arg);\r\nhost->cmd = cmd;\r\nomap_hsmmc_enable_irq(host, cmd);\r\nhost->response_busy = 0;\r\nif (cmd->flags & MMC_RSP_PRESENT) {\r\nif (cmd->flags & MMC_RSP_136)\r\nresptype = 1;\r\nelse if (cmd->flags & MMC_RSP_BUSY) {\r\nresptype = 3;\r\nhost->response_busy = 1;\r\n} else\r\nresptype = 2;\r\n}\r\nif (cmd == host->mrq->stop)\r\ncmdtype = 0x3;\r\ncmdreg = (cmd->opcode << 24) | (resptype << 16) | (cmdtype << 22);\r\nif (data) {\r\ncmdreg |= DP_SELECT | MSBS | BCE;\r\nif (data->flags & MMC_DATA_READ)\r\ncmdreg |= DDIR;\r\nelse\r\ncmdreg &= ~(DDIR);\r\n}\r\nif (host->use_dma)\r\ncmdreg |= DMAE;\r\nhost->req_in_progress = 1;\r\nOMAP_HSMMC_WRITE(host->base, ARG, cmd->arg);\r\nOMAP_HSMMC_WRITE(host->base, CMD, cmdreg);\r\n}\r\nstatic int\r\nomap_hsmmc_get_dma_dir(struct omap_hsmmc_host *host, struct mmc_data *data)\r\n{\r\nif (data->flags & MMC_DATA_WRITE)\r\nreturn DMA_TO_DEVICE;\r\nelse\r\nreturn DMA_FROM_DEVICE;\r\n}\r\nstatic struct dma_chan *omap_hsmmc_get_dma_chan(struct omap_hsmmc_host *host,\r\nstruct mmc_data *data)\r\n{\r\nreturn data->flags & MMC_DATA_WRITE ? host->tx_chan : host->rx_chan;\r\n}\r\nstatic void omap_hsmmc_request_done(struct omap_hsmmc_host *host, struct mmc_request *mrq)\r\n{\r\nint dma_ch;\r\nunsigned long flags;\r\nspin_lock_irqsave(&host->irq_lock, flags);\r\nhost->req_in_progress = 0;\r\ndma_ch = host->dma_ch;\r\nspin_unlock_irqrestore(&host->irq_lock, flags);\r\nomap_hsmmc_disable_irq(host);\r\nif (mrq->data && host->use_dma && dma_ch != -1)\r\nreturn;\r\nhost->mrq = NULL;\r\nmmc_request_done(host->mmc, mrq);\r\n}\r\nstatic void\r\nomap_hsmmc_xfer_done(struct omap_hsmmc_host *host, struct mmc_data *data)\r\n{\r\nif (!data) {\r\nstruct mmc_request *mrq = host->mrq;\r\nif (host->cmd && host->cmd->opcode == 6 &&\r\nhost->response_busy) {\r\nhost->response_busy = 0;\r\nreturn;\r\n}\r\nomap_hsmmc_request_done(host, mrq);\r\nreturn;\r\n}\r\nhost->data = NULL;\r\nif (!data->error)\r\ndata->bytes_xfered += data->blocks * (data->blksz);\r\nelse\r\ndata->bytes_xfered = 0;\r\nif (!data->stop) {\r\nomap_hsmmc_request_done(host, data->mrq);\r\nreturn;\r\n}\r\nomap_hsmmc_start_command(host, data->stop, NULL);\r\n}\r\nstatic void\r\nomap_hsmmc_cmd_done(struct omap_hsmmc_host *host, struct mmc_command *cmd)\r\n{\r\nhost->cmd = NULL;\r\nif (cmd->flags & MMC_RSP_PRESENT) {\r\nif (cmd->flags & MMC_RSP_136) {\r\ncmd->resp[3] = OMAP_HSMMC_READ(host->base, RSP10);\r\ncmd->resp[2] = OMAP_HSMMC_READ(host->base, RSP32);\r\ncmd->resp[1] = OMAP_HSMMC_READ(host->base, RSP54);\r\ncmd->resp[0] = OMAP_HSMMC_READ(host->base, RSP76);\r\n} else {\r\ncmd->resp[0] = OMAP_HSMMC_READ(host->base, RSP10);\r\n}\r\n}\r\nif ((host->data == NULL && !host->response_busy) || cmd->error)\r\nomap_hsmmc_request_done(host, cmd->mrq);\r\n}\r\nstatic void omap_hsmmc_dma_cleanup(struct omap_hsmmc_host *host, int errno)\r\n{\r\nint dma_ch;\r\nunsigned long flags;\r\nhost->data->error = errno;\r\nspin_lock_irqsave(&host->irq_lock, flags);\r\ndma_ch = host->dma_ch;\r\nhost->dma_ch = -1;\r\nspin_unlock_irqrestore(&host->irq_lock, flags);\r\nif (host->use_dma && dma_ch != -1) {\r\nstruct dma_chan *chan = omap_hsmmc_get_dma_chan(host, host->data);\r\ndmaengine_terminate_all(chan);\r\ndma_unmap_sg(chan->device->dev,\r\nhost->data->sg, host->data->sg_len,\r\nomap_hsmmc_get_dma_dir(host, host->data));\r\nhost->data->host_cookie = 0;\r\n}\r\nhost->data = NULL;\r\n}\r\nstatic void omap_hsmmc_dbg_report_irq(struct omap_hsmmc_host *host, u32 status)\r\n{\r\nstatic const char *omap_hsmmc_status_bits[] = {\r\n"CC" , "TC" , "BGE", "---", "BWR" , "BRR" , "---" , "---" ,\r\n"CIRQ", "OBI" , "---", "---", "---" , "---" , "---" , "ERRI",\r\n"CTO" , "CCRC", "CEB", "CIE", "DTO" , "DCRC", "DEB" , "---" ,\r\n"ACE" , "---" , "---", "---", "CERR", "BADA", "---" , "---"\r\n};\r\nchar res[256];\r\nchar *buf = res;\r\nint len, i;\r\nlen = sprintf(buf, "MMC IRQ 0x%x :", status);\r\nbuf += len;\r\nfor (i = 0; i < ARRAY_SIZE(omap_hsmmc_status_bits); i++)\r\nif (status & (1 << i)) {\r\nlen = sprintf(buf, " %s", omap_hsmmc_status_bits[i]);\r\nbuf += len;\r\n}\r\ndev_vdbg(mmc_dev(host->mmc), "%s\n", res);\r\n}\r\nstatic inline void omap_hsmmc_dbg_report_irq(struct omap_hsmmc_host *host,\r\nu32 status)\r\n{\r\n}\r\nstatic inline void omap_hsmmc_reset_controller_fsm(struct omap_hsmmc_host *host,\r\nunsigned long bit)\r\n{\r\nunsigned long i = 0;\r\nunsigned long limit = (loops_per_jiffy *\r\nmsecs_to_jiffies(MMC_TIMEOUT_MS));\r\nOMAP_HSMMC_WRITE(host->base, SYSCTL,\r\nOMAP_HSMMC_READ(host->base, SYSCTL) | bit);\r\nif (mmc_slot(host).features & HSMMC_HAS_UPDATED_RESET) {\r\nwhile ((!(OMAP_HSMMC_READ(host->base, SYSCTL) & bit))\r\n&& (i++ < limit))\r\ncpu_relax();\r\n}\r\ni = 0;\r\nwhile ((OMAP_HSMMC_READ(host->base, SYSCTL) & bit) &&\r\n(i++ < limit))\r\ncpu_relax();\r\nif (OMAP_HSMMC_READ(host->base, SYSCTL) & bit)\r\ndev_err(mmc_dev(host->mmc),\r\n"Timeout waiting on controller reset in %s\n",\r\n__func__);\r\n}\r\nstatic void hsmmc_command_incomplete(struct omap_hsmmc_host *host,\r\nint err, int end_cmd)\r\n{\r\nif (end_cmd) {\r\nomap_hsmmc_reset_controller_fsm(host, SRC);\r\nif (host->cmd)\r\nhost->cmd->error = err;\r\n}\r\nif (host->data) {\r\nomap_hsmmc_reset_controller_fsm(host, SRD);\r\nomap_hsmmc_dma_cleanup(host, err);\r\n} else if (host->mrq && host->mrq->cmd)\r\nhost->mrq->cmd->error = err;\r\n}\r\nstatic void omap_hsmmc_do_irq(struct omap_hsmmc_host *host, int status)\r\n{\r\nstruct mmc_data *data;\r\nint end_cmd = 0, end_trans = 0;\r\ndata = host->data;\r\ndev_vdbg(mmc_dev(host->mmc), "IRQ Status is %x\n", status);\r\nif (status & ERR_EN) {\r\nomap_hsmmc_dbg_report_irq(host, status);\r\nif (status & (CTO_EN | CCRC_EN))\r\nend_cmd = 1;\r\nif (status & (CTO_EN | DTO_EN))\r\nhsmmc_command_incomplete(host, -ETIMEDOUT, end_cmd);\r\nelse if (status & (CCRC_EN | DCRC_EN))\r\nhsmmc_command_incomplete(host, -EILSEQ, end_cmd);\r\nif (host->data || host->response_busy) {\r\nend_trans = !end_cmd;\r\nhost->response_busy = 0;\r\n}\r\n}\r\nif (end_cmd || ((status & CC_EN) && host->cmd))\r\nomap_hsmmc_cmd_done(host, host->cmd);\r\nif ((end_trans || (status & TC_EN)) && host->mrq)\r\nomap_hsmmc_xfer_done(host, data);\r\n}\r\nstatic irqreturn_t omap_hsmmc_irq(int irq, void *dev_id)\r\n{\r\nstruct omap_hsmmc_host *host = dev_id;\r\nint status;\r\nstatus = OMAP_HSMMC_READ(host->base, STAT);\r\nwhile (status & INT_EN_MASK && host->req_in_progress) {\r\nomap_hsmmc_do_irq(host, status);\r\nOMAP_HSMMC_WRITE(host->base, STAT, status);\r\nstatus = OMAP_HSMMC_READ(host->base, STAT);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void set_sd_bus_power(struct omap_hsmmc_host *host)\r\n{\r\nunsigned long i;\r\nOMAP_HSMMC_WRITE(host->base, HCTL,\r\nOMAP_HSMMC_READ(host->base, HCTL) | SDBP);\r\nfor (i = 0; i < loops_per_jiffy; i++) {\r\nif (OMAP_HSMMC_READ(host->base, HCTL) & SDBP)\r\nbreak;\r\ncpu_relax();\r\n}\r\n}\r\nstatic int omap_hsmmc_switch_opcond(struct omap_hsmmc_host *host, int vdd)\r\n{\r\nu32 reg_val = 0;\r\nint ret;\r\npm_runtime_put_sync(host->dev);\r\nif (host->dbclk)\r\nclk_disable_unprepare(host->dbclk);\r\nret = mmc_slot(host).set_power(host->dev, host->slot_id, 0, 0);\r\nif (!ret)\r\nret = mmc_slot(host).set_power(host->dev, host->slot_id, 1,\r\nvdd);\r\npm_runtime_get_sync(host->dev);\r\nif (host->dbclk)\r\nclk_prepare_enable(host->dbclk);\r\nif (ret != 0)\r\ngoto err;\r\nOMAP_HSMMC_WRITE(host->base, HCTL,\r\nOMAP_HSMMC_READ(host->base, HCTL) & SDVSCLR);\r\nreg_val = OMAP_HSMMC_READ(host->base, HCTL);\r\nif ((1 << vdd) <= MMC_VDD_23_24)\r\nreg_val |= SDVS18;\r\nelse\r\nreg_val |= SDVS30;\r\nOMAP_HSMMC_WRITE(host->base, HCTL, reg_val);\r\nset_sd_bus_power(host);\r\nreturn 0;\r\nerr:\r\ndev_err(mmc_dev(host->mmc), "Unable to switch operating voltage\n");\r\nreturn ret;\r\n}\r\nstatic void omap_hsmmc_protect_card(struct omap_hsmmc_host *host)\r\n{\r\nif (!mmc_slot(host).get_cover_state)\r\nreturn;\r\nhost->reqs_blocked = 0;\r\nif (mmc_slot(host).get_cover_state(host->dev, host->slot_id)) {\r\nif (host->protect_card) {\r\ndev_info(host->dev, "%s: cover is closed, "\r\n"card is now accessible\n",\r\nmmc_hostname(host->mmc));\r\nhost->protect_card = 0;\r\n}\r\n} else {\r\nif (!host->protect_card) {\r\ndev_info(host->dev, "%s: cover is open, "\r\n"card is now inaccessible\n",\r\nmmc_hostname(host->mmc));\r\nhost->protect_card = 1;\r\n}\r\n}\r\n}\r\nstatic irqreturn_t omap_hsmmc_detect(int irq, void *dev_id)\r\n{\r\nstruct omap_hsmmc_host *host = dev_id;\r\nstruct omap_mmc_slot_data *slot = &mmc_slot(host);\r\nint carddetect;\r\nif (host->suspended)\r\nreturn IRQ_HANDLED;\r\nsysfs_notify(&host->mmc->class_dev.kobj, NULL, "cover_switch");\r\nif (slot->card_detect)\r\ncarddetect = slot->card_detect(host->dev, host->slot_id);\r\nelse {\r\nomap_hsmmc_protect_card(host);\r\ncarddetect = -ENOSYS;\r\n}\r\nif (carddetect)\r\nmmc_detect_change(host->mmc, (HZ * 200) / 1000);\r\nelse\r\nmmc_detect_change(host->mmc, (HZ * 50) / 1000);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void omap_hsmmc_dma_callback(void *param)\r\n{\r\nstruct omap_hsmmc_host *host = param;\r\nstruct dma_chan *chan;\r\nstruct mmc_data *data;\r\nint req_in_progress;\r\nspin_lock_irq(&host->irq_lock);\r\nif (host->dma_ch < 0) {\r\nspin_unlock_irq(&host->irq_lock);\r\nreturn;\r\n}\r\ndata = host->mrq->data;\r\nchan = omap_hsmmc_get_dma_chan(host, data);\r\nif (!data->host_cookie)\r\ndma_unmap_sg(chan->device->dev,\r\ndata->sg, data->sg_len,\r\nomap_hsmmc_get_dma_dir(host, data));\r\nreq_in_progress = host->req_in_progress;\r\nhost->dma_ch = -1;\r\nspin_unlock_irq(&host->irq_lock);\r\nif (!req_in_progress) {\r\nstruct mmc_request *mrq = host->mrq;\r\nhost->mrq = NULL;\r\nmmc_request_done(host->mmc, mrq);\r\n}\r\n}\r\nstatic int omap_hsmmc_pre_dma_transfer(struct omap_hsmmc_host *host,\r\nstruct mmc_data *data,\r\nstruct omap_hsmmc_next *next,\r\nstruct dma_chan *chan)\r\n{\r\nint dma_len;\r\nif (!next && data->host_cookie &&\r\ndata->host_cookie != host->next_data.cookie) {\r\ndev_warn(host->dev, "[%s] invalid cookie: data->host_cookie %d"\r\n" host->next_data.cookie %d\n",\r\n__func__, data->host_cookie, host->next_data.cookie);\r\ndata->host_cookie = 0;\r\n}\r\nif (next ||\r\n(!next && data->host_cookie != host->next_data.cookie)) {\r\ndma_len = dma_map_sg(chan->device->dev, data->sg, data->sg_len,\r\nomap_hsmmc_get_dma_dir(host, data));\r\n} else {\r\ndma_len = host->next_data.dma_len;\r\nhost->next_data.dma_len = 0;\r\n}\r\nif (dma_len == 0)\r\nreturn -EINVAL;\r\nif (next) {\r\nnext->dma_len = dma_len;\r\ndata->host_cookie = ++next->cookie < 0 ? 1 : next->cookie;\r\n} else\r\nhost->dma_len = dma_len;\r\nreturn 0;\r\n}\r\nstatic int omap_hsmmc_start_dma_transfer(struct omap_hsmmc_host *host,\r\nstruct mmc_request *req)\r\n{\r\nstruct dma_slave_config cfg;\r\nstruct dma_async_tx_descriptor *tx;\r\nint ret = 0, i;\r\nstruct mmc_data *data = req->data;\r\nstruct dma_chan *chan;\r\nfor (i = 0; i < data->sg_len; i++) {\r\nstruct scatterlist *sgl;\r\nsgl = data->sg + i;\r\nif (sgl->length % data->blksz)\r\nreturn -EINVAL;\r\n}\r\nif ((data->blksz % 4) != 0)\r\nreturn -EINVAL;\r\nBUG_ON(host->dma_ch != -1);\r\nchan = omap_hsmmc_get_dma_chan(host, data);\r\ncfg.src_addr = host->mapbase + OMAP_HSMMC_DATA;\r\ncfg.dst_addr = host->mapbase + OMAP_HSMMC_DATA;\r\ncfg.src_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;\r\ncfg.dst_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;\r\ncfg.src_maxburst = data->blksz / 4;\r\ncfg.dst_maxburst = data->blksz / 4;\r\nret = dmaengine_slave_config(chan, &cfg);\r\nif (ret)\r\nreturn ret;\r\nret = omap_hsmmc_pre_dma_transfer(host, data, NULL, chan);\r\nif (ret)\r\nreturn ret;\r\ntx = dmaengine_prep_slave_sg(chan, data->sg, data->sg_len,\r\ndata->flags & MMC_DATA_WRITE ? DMA_MEM_TO_DEV : DMA_DEV_TO_MEM,\r\nDMA_PREP_INTERRUPT | DMA_CTRL_ACK);\r\nif (!tx) {\r\ndev_err(mmc_dev(host->mmc), "prep_slave_sg() failed\n");\r\nreturn -1;\r\n}\r\ntx->callback = omap_hsmmc_dma_callback;\r\ntx->callback_param = host;\r\ndmaengine_submit(tx);\r\nhost->dma_ch = 1;\r\ndma_async_issue_pending(chan);\r\nreturn 0;\r\n}\r\nstatic void set_data_timeout(struct omap_hsmmc_host *host,\r\nunsigned int timeout_ns,\r\nunsigned int timeout_clks)\r\n{\r\nunsigned int timeout, cycle_ns;\r\nuint32_t reg, clkd, dto = 0;\r\nreg = OMAP_HSMMC_READ(host->base, SYSCTL);\r\nclkd = (reg & CLKD_MASK) >> CLKD_SHIFT;\r\nif (clkd == 0)\r\nclkd = 1;\r\ncycle_ns = 1000000000 / (clk_get_rate(host->fclk) / clkd);\r\ntimeout = timeout_ns / cycle_ns;\r\ntimeout += timeout_clks;\r\nif (timeout) {\r\nwhile ((timeout & 0x80000000) == 0) {\r\ndto += 1;\r\ntimeout <<= 1;\r\n}\r\ndto = 31 - dto;\r\ntimeout <<= 1;\r\nif (timeout && dto)\r\ndto += 1;\r\nif (dto >= 13)\r\ndto -= 13;\r\nelse\r\ndto = 0;\r\nif (dto > 14)\r\ndto = 14;\r\n}\r\nreg &= ~DTO_MASK;\r\nreg |= dto << DTO_SHIFT;\r\nOMAP_HSMMC_WRITE(host->base, SYSCTL, reg);\r\n}\r\nstatic int\r\nomap_hsmmc_prepare_data(struct omap_hsmmc_host *host, struct mmc_request *req)\r\n{\r\nint ret;\r\nhost->data = req->data;\r\nif (req->data == NULL) {\r\nOMAP_HSMMC_WRITE(host->base, BLK, 0);\r\nif (req->cmd->flags & MMC_RSP_BUSY)\r\nset_data_timeout(host, 100000000U, 0);\r\nreturn 0;\r\n}\r\nOMAP_HSMMC_WRITE(host->base, BLK, (req->data->blksz)\r\n| (req->data->blocks << 16));\r\nset_data_timeout(host, req->data->timeout_ns, req->data->timeout_clks);\r\nif (host->use_dma) {\r\nret = omap_hsmmc_start_dma_transfer(host, req);\r\nif (ret != 0) {\r\ndev_err(mmc_dev(host->mmc), "MMC start dma failure\n");\r\nreturn ret;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void omap_hsmmc_post_req(struct mmc_host *mmc, struct mmc_request *mrq,\r\nint err)\r\n{\r\nstruct omap_hsmmc_host *host = mmc_priv(mmc);\r\nstruct mmc_data *data = mrq->data;\r\nif (host->use_dma && data->host_cookie) {\r\nstruct dma_chan *c = omap_hsmmc_get_dma_chan(host, data);\r\ndma_unmap_sg(c->device->dev, data->sg, data->sg_len,\r\nomap_hsmmc_get_dma_dir(host, data));\r\ndata->host_cookie = 0;\r\n}\r\n}\r\nstatic void omap_hsmmc_pre_req(struct mmc_host *mmc, struct mmc_request *mrq,\r\nbool is_first_req)\r\n{\r\nstruct omap_hsmmc_host *host = mmc_priv(mmc);\r\nif (mrq->data->host_cookie) {\r\nmrq->data->host_cookie = 0;\r\nreturn ;\r\n}\r\nif (host->use_dma) {\r\nstruct dma_chan *c = omap_hsmmc_get_dma_chan(host, mrq->data);\r\nif (omap_hsmmc_pre_dma_transfer(host, mrq->data,\r\n&host->next_data, c))\r\nmrq->data->host_cookie = 0;\r\n}\r\n}\r\nstatic void omap_hsmmc_request(struct mmc_host *mmc, struct mmc_request *req)\r\n{\r\nstruct omap_hsmmc_host *host = mmc_priv(mmc);\r\nint err;\r\nBUG_ON(host->req_in_progress);\r\nBUG_ON(host->dma_ch != -1);\r\nif (host->protect_card) {\r\nif (host->reqs_blocked < 3) {\r\nomap_hsmmc_reset_controller_fsm(host, SRD);\r\nomap_hsmmc_reset_controller_fsm(host, SRC);\r\nhost->reqs_blocked += 1;\r\n}\r\nreq->cmd->error = -EBADF;\r\nif (req->data)\r\nreq->data->error = -EBADF;\r\nreq->cmd->retries = 0;\r\nmmc_request_done(mmc, req);\r\nreturn;\r\n} else if (host->reqs_blocked)\r\nhost->reqs_blocked = 0;\r\nWARN_ON(host->mrq != NULL);\r\nhost->mrq = req;\r\nerr = omap_hsmmc_prepare_data(host, req);\r\nif (err) {\r\nreq->cmd->error = err;\r\nif (req->data)\r\nreq->data->error = err;\r\nhost->mrq = NULL;\r\nmmc_request_done(mmc, req);\r\nreturn;\r\n}\r\nomap_hsmmc_start_command(host, req->cmd, req->data);\r\n}\r\nstatic void omap_hsmmc_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)\r\n{\r\nstruct omap_hsmmc_host *host = mmc_priv(mmc);\r\nint do_send_init_stream = 0;\r\npm_runtime_get_sync(host->dev);\r\nif (ios->power_mode != host->power_mode) {\r\nswitch (ios->power_mode) {\r\ncase MMC_POWER_OFF:\r\nmmc_slot(host).set_power(host->dev, host->slot_id,\r\n0, 0);\r\nbreak;\r\ncase MMC_POWER_UP:\r\nmmc_slot(host).set_power(host->dev, host->slot_id,\r\n1, ios->vdd);\r\nbreak;\r\ncase MMC_POWER_ON:\r\ndo_send_init_stream = 1;\r\nbreak;\r\n}\r\nhost->power_mode = ios->power_mode;\r\n}\r\nomap_hsmmc_set_bus_width(host);\r\nif (host->pdata->controller_flags & OMAP_HSMMC_SUPPORTS_DUAL_VOLT) {\r\nif ((OMAP_HSMMC_READ(host->base, HCTL) & SDVSDET) &&\r\n(ios->vdd == DUAL_VOLT_OCR_BIT) &&\r\n!host->dev->of_node) {\r\nif (omap_hsmmc_switch_opcond(host, ios->vdd) != 0)\r\ndev_dbg(mmc_dev(host->mmc),\r\n"Switch operation failed\n");\r\n}\r\n}\r\nomap_hsmmc_set_clock(host);\r\nif (do_send_init_stream)\r\nsend_init_stream(host);\r\nomap_hsmmc_set_bus_mode(host);\r\npm_runtime_put_autosuspend(host->dev);\r\n}\r\nstatic int omap_hsmmc_get_cd(struct mmc_host *mmc)\r\n{\r\nstruct omap_hsmmc_host *host = mmc_priv(mmc);\r\nif (!mmc_slot(host).card_detect)\r\nreturn -ENOSYS;\r\nreturn mmc_slot(host).card_detect(host->dev, host->slot_id);\r\n}\r\nstatic int omap_hsmmc_get_ro(struct mmc_host *mmc)\r\n{\r\nstruct omap_hsmmc_host *host = mmc_priv(mmc);\r\nif (!mmc_slot(host).get_ro)\r\nreturn -ENOSYS;\r\nreturn mmc_slot(host).get_ro(host->dev, 0);\r\n}\r\nstatic void omap_hsmmc_init_card(struct mmc_host *mmc, struct mmc_card *card)\r\n{\r\nstruct omap_hsmmc_host *host = mmc_priv(mmc);\r\nif (mmc_slot(host).init_card)\r\nmmc_slot(host).init_card(card);\r\n}\r\nstatic void omap_hsmmc_conf_bus_power(struct omap_hsmmc_host *host)\r\n{\r\nu32 hctl, capa, value;\r\nif (host->pdata->controller_flags & OMAP_HSMMC_SUPPORTS_DUAL_VOLT) {\r\nhctl = SDVS30;\r\ncapa = VS30 | VS18;\r\n} else {\r\nhctl = SDVS18;\r\ncapa = VS18;\r\n}\r\nvalue = OMAP_HSMMC_READ(host->base, HCTL) & ~SDVS_MASK;\r\nOMAP_HSMMC_WRITE(host->base, HCTL, value | hctl);\r\nvalue = OMAP_HSMMC_READ(host->base, CAPA);\r\nOMAP_HSMMC_WRITE(host->base, CAPA, value | capa);\r\nset_sd_bus_power(host);\r\n}\r\nstatic int omap_hsmmc_enable_fclk(struct mmc_host *mmc)\r\n{\r\nstruct omap_hsmmc_host *host = mmc_priv(mmc);\r\npm_runtime_get_sync(host->dev);\r\nreturn 0;\r\n}\r\nstatic int omap_hsmmc_disable_fclk(struct mmc_host *mmc)\r\n{\r\nstruct omap_hsmmc_host *host = mmc_priv(mmc);\r\npm_runtime_mark_last_busy(host->dev);\r\npm_runtime_put_autosuspend(host->dev);\r\nreturn 0;\r\n}\r\nstatic int omap_hsmmc_regs_show(struct seq_file *s, void *data)\r\n{\r\nstruct mmc_host *mmc = s->private;\r\nstruct omap_hsmmc_host *host = mmc_priv(mmc);\r\nint context_loss = 0;\r\nif (host->pdata->get_context_loss_count)\r\ncontext_loss = host->pdata->get_context_loss_count(host->dev);\r\nseq_printf(s, "mmc%d:\n ctx_loss:\t%d:%d\n\nregs:\n",\r\nmmc->index, host->context_loss, context_loss);\r\nif (host->suspended) {\r\nseq_printf(s, "host suspended, can't read registers\n");\r\nreturn 0;\r\n}\r\npm_runtime_get_sync(host->dev);\r\nseq_printf(s, "CON:\t\t0x%08x\n",\r\nOMAP_HSMMC_READ(host->base, CON));\r\nseq_printf(s, "HCTL:\t\t0x%08x\n",\r\nOMAP_HSMMC_READ(host->base, HCTL));\r\nseq_printf(s, "SYSCTL:\t\t0x%08x\n",\r\nOMAP_HSMMC_READ(host->base, SYSCTL));\r\nseq_printf(s, "IE:\t\t0x%08x\n",\r\nOMAP_HSMMC_READ(host->base, IE));\r\nseq_printf(s, "ISE:\t\t0x%08x\n",\r\nOMAP_HSMMC_READ(host->base, ISE));\r\nseq_printf(s, "CAPA:\t\t0x%08x\n",\r\nOMAP_HSMMC_READ(host->base, CAPA));\r\npm_runtime_mark_last_busy(host->dev);\r\npm_runtime_put_autosuspend(host->dev);\r\nreturn 0;\r\n}\r\nstatic int omap_hsmmc_regs_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, omap_hsmmc_regs_show, inode->i_private);\r\n}\r\nstatic void omap_hsmmc_debugfs(struct mmc_host *mmc)\r\n{\r\nif (mmc->debugfs_root)\r\ndebugfs_create_file("regs", S_IRUSR, mmc->debugfs_root,\r\nmmc, &mmc_regs_fops);\r\n}\r\nstatic void omap_hsmmc_debugfs(struct mmc_host *mmc)\r\n{\r\n}\r\nstatic struct omap_mmc_platform_data *of_get_hsmmc_pdata(struct device *dev)\r\n{\r\nstruct omap_mmc_platform_data *pdata;\r\nstruct device_node *np = dev->of_node;\r\nu32 bus_width, max_freq;\r\npdata = devm_kzalloc(dev, sizeof(*pdata), GFP_KERNEL);\r\nif (!pdata)\r\nreturn NULL;\r\nif (of_find_property(np, "ti,dual-volt", NULL))\r\npdata->controller_flags |= OMAP_HSMMC_SUPPORTS_DUAL_VOLT;\r\npdata->nr_slots = 1;\r\npdata->slots[0].switch_pin = of_get_named_gpio(np, "cd-gpios", 0);\r\npdata->slots[0].gpio_wp = of_get_named_gpio(np, "wp-gpios", 0);\r\nif (of_find_property(np, "ti,non-removable", NULL)) {\r\npdata->slots[0].nonremovable = true;\r\npdata->slots[0].no_regulator_off_init = true;\r\n}\r\nof_property_read_u32(np, "bus-width", &bus_width);\r\nif (bus_width == 4)\r\npdata->slots[0].caps |= MMC_CAP_4_BIT_DATA;\r\nelse if (bus_width == 8)\r\npdata->slots[0].caps |= MMC_CAP_8_BIT_DATA;\r\nif (of_find_property(np, "ti,needs-special-reset", NULL))\r\npdata->slots[0].features |= HSMMC_HAS_UPDATED_RESET;\r\nif (!of_property_read_u32(np, "max-frequency", &max_freq))\r\npdata->max_freq = max_freq;\r\nif (of_find_property(np, "ti,needs-special-hs-handling", NULL))\r\npdata->slots[0].features |= HSMMC_HAS_HSPE_SUPPORT;\r\nreturn pdata;\r\n}\r\nstatic inline struct omap_mmc_platform_data\r\n*of_get_hsmmc_pdata(struct device *dev)\r\n{\r\nreturn NULL;\r\n}\r\nstatic int omap_hsmmc_probe(struct platform_device *pdev)\r\n{\r\nstruct omap_mmc_platform_data *pdata = pdev->dev.platform_data;\r\nstruct mmc_host *mmc;\r\nstruct omap_hsmmc_host *host = NULL;\r\nstruct resource *res;\r\nint ret, irq;\r\nconst struct of_device_id *match;\r\ndma_cap_mask_t mask;\r\nunsigned tx_req, rx_req;\r\nstruct pinctrl *pinctrl;\r\nmatch = of_match_device(of_match_ptr(omap_mmc_of_match), &pdev->dev);\r\nif (match) {\r\npdata = of_get_hsmmc_pdata(&pdev->dev);\r\nif (match->data) {\r\nconst u16 *offsetp = match->data;\r\npdata->reg_offset = *offsetp;\r\n}\r\n}\r\nif (pdata == NULL) {\r\ndev_err(&pdev->dev, "Platform Data is missing\n");\r\nreturn -ENXIO;\r\n}\r\nif (pdata->nr_slots == 0) {\r\ndev_err(&pdev->dev, "No Slots\n");\r\nreturn -ENXIO;\r\n}\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nirq = platform_get_irq(pdev, 0);\r\nif (res == NULL || irq < 0)\r\nreturn -ENXIO;\r\nres = request_mem_region(res->start, resource_size(res), pdev->name);\r\nif (res == NULL)\r\nreturn -EBUSY;\r\nret = omap_hsmmc_gpio_init(pdata);\r\nif (ret)\r\ngoto err;\r\nmmc = mmc_alloc_host(sizeof(struct omap_hsmmc_host), &pdev->dev);\r\nif (!mmc) {\r\nret = -ENOMEM;\r\ngoto err_alloc;\r\n}\r\nhost = mmc_priv(mmc);\r\nhost->mmc = mmc;\r\nhost->pdata = pdata;\r\nhost->dev = &pdev->dev;\r\nhost->use_dma = 1;\r\nhost->dma_ch = -1;\r\nhost->irq = irq;\r\nhost->slot_id = 0;\r\nhost->mapbase = res->start + pdata->reg_offset;\r\nhost->base = ioremap(host->mapbase, SZ_4K);\r\nhost->power_mode = MMC_POWER_OFF;\r\nhost->next_data.cookie = 1;\r\nplatform_set_drvdata(pdev, host);\r\nmmc->ops = &omap_hsmmc_ops;\r\nif (mmc_slot(host).vcc_aux_disable_is_sleep)\r\nmmc_slot(host).no_off = 1;\r\nmmc->f_min = OMAP_MMC_MIN_CLOCK;\r\nif (pdata->max_freq > 0)\r\nmmc->f_max = pdata->max_freq;\r\nelse\r\nmmc->f_max = OMAP_MMC_MAX_CLOCK;\r\nspin_lock_init(&host->irq_lock);\r\nhost->fclk = clk_get(&pdev->dev, "fck");\r\nif (IS_ERR(host->fclk)) {\r\nret = PTR_ERR(host->fclk);\r\nhost->fclk = NULL;\r\ngoto err1;\r\n}\r\nif (host->pdata->controller_flags & OMAP_HSMMC_BROKEN_MULTIBLOCK_READ) {\r\ndev_info(&pdev->dev, "multiblock reads disabled due to 35xx erratum 2.1.1.128; MMC read performance may suffer\n");\r\nmmc->caps2 |= MMC_CAP2_NO_MULTI_READ;\r\n}\r\npm_runtime_enable(host->dev);\r\npm_runtime_get_sync(host->dev);\r\npm_runtime_set_autosuspend_delay(host->dev, MMC_AUTOSUSPEND_DELAY);\r\npm_runtime_use_autosuspend(host->dev);\r\nomap_hsmmc_context_save(host);\r\nhost->dbclk = clk_get(&pdev->dev, "mmchsdb_fck");\r\nif (IS_ERR(host->dbclk)) {\r\nhost->dbclk = NULL;\r\n} else if (clk_prepare_enable(host->dbclk) != 0) {\r\ndev_warn(mmc_dev(host->mmc), "Failed to enable debounce clk\n");\r\nclk_put(host->dbclk);\r\nhost->dbclk = NULL;\r\n}\r\nmmc->max_segs = 1024;\r\nmmc->max_blk_size = 512;\r\nmmc->max_blk_count = 0xFFFF;\r\nmmc->max_req_size = mmc->max_blk_size * mmc->max_blk_count;\r\nmmc->max_seg_size = mmc->max_req_size;\r\nmmc->caps |= MMC_CAP_MMC_HIGHSPEED | MMC_CAP_SD_HIGHSPEED |\r\nMMC_CAP_WAIT_WHILE_BUSY | MMC_CAP_ERASE;\r\nmmc->caps |= mmc_slot(host).caps;\r\nif (mmc->caps & MMC_CAP_8_BIT_DATA)\r\nmmc->caps |= MMC_CAP_4_BIT_DATA;\r\nif (mmc_slot(host).nonremovable)\r\nmmc->caps |= MMC_CAP_NONREMOVABLE;\r\nmmc->pm_caps = mmc_slot(host).pm_caps;\r\nomap_hsmmc_conf_bus_power(host);\r\nres = platform_get_resource_byname(pdev, IORESOURCE_DMA, "tx");\r\nif (!res) {\r\ndev_err(mmc_dev(host->mmc), "cannot get DMA TX channel\n");\r\nret = -ENXIO;\r\ngoto err_irq;\r\n}\r\ntx_req = res->start;\r\nres = platform_get_resource_byname(pdev, IORESOURCE_DMA, "rx");\r\nif (!res) {\r\ndev_err(mmc_dev(host->mmc), "cannot get DMA RX channel\n");\r\nret = -ENXIO;\r\ngoto err_irq;\r\n}\r\nrx_req = res->start;\r\ndma_cap_zero(mask);\r\ndma_cap_set(DMA_SLAVE, mask);\r\nhost->rx_chan = dma_request_channel(mask, omap_dma_filter_fn, &rx_req);\r\nif (!host->rx_chan) {\r\ndev_err(mmc_dev(host->mmc), "unable to obtain RX DMA engine channel %u\n", rx_req);\r\nret = -ENXIO;\r\ngoto err_irq;\r\n}\r\nhost->tx_chan = dma_request_channel(mask, omap_dma_filter_fn, &tx_req);\r\nif (!host->tx_chan) {\r\ndev_err(mmc_dev(host->mmc), "unable to obtain TX DMA engine channel %u\n", tx_req);\r\nret = -ENXIO;\r\ngoto err_irq;\r\n}\r\nret = request_irq(host->irq, omap_hsmmc_irq, 0,\r\nmmc_hostname(mmc), host);\r\nif (ret) {\r\ndev_err(mmc_dev(host->mmc), "Unable to grab HSMMC IRQ\n");\r\ngoto err_irq;\r\n}\r\nif (pdata->init != NULL) {\r\nif (pdata->init(&pdev->dev) != 0) {\r\ndev_err(mmc_dev(host->mmc),\r\n"Unable to configure MMC IRQs\n");\r\ngoto err_irq_cd_init;\r\n}\r\n}\r\nif (omap_hsmmc_have_reg() && !mmc_slot(host).set_power) {\r\nret = omap_hsmmc_reg_get(host);\r\nif (ret)\r\ngoto err_reg;\r\nhost->use_reg = 1;\r\n}\r\nmmc->ocr_avail = mmc_slot(host).ocr_mask;\r\nif ((mmc_slot(host).card_detect_irq)) {\r\nret = request_threaded_irq(mmc_slot(host).card_detect_irq,\r\nNULL,\r\nomap_hsmmc_detect,\r\nIRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING | IRQF_ONESHOT,\r\nmmc_hostname(mmc), host);\r\nif (ret) {\r\ndev_err(mmc_dev(host->mmc),\r\n"Unable to grab MMC CD IRQ\n");\r\ngoto err_irq_cd;\r\n}\r\npdata->suspend = omap_hsmmc_suspend_cdirq;\r\npdata->resume = omap_hsmmc_resume_cdirq;\r\n}\r\nomap_hsmmc_disable_irq(host);\r\npinctrl = devm_pinctrl_get_select_default(&pdev->dev);\r\nif (IS_ERR(pinctrl))\r\ndev_warn(&pdev->dev,\r\n"pins are not configured from the driver\n");\r\nomap_hsmmc_protect_card(host);\r\nmmc_add_host(mmc);\r\nif (mmc_slot(host).name != NULL) {\r\nret = device_create_file(&mmc->class_dev, &dev_attr_slot_name);\r\nif (ret < 0)\r\ngoto err_slot_name;\r\n}\r\nif (mmc_slot(host).card_detect_irq && mmc_slot(host).get_cover_state) {\r\nret = device_create_file(&mmc->class_dev,\r\n&dev_attr_cover_switch);\r\nif (ret < 0)\r\ngoto err_slot_name;\r\n}\r\nomap_hsmmc_debugfs(mmc);\r\npm_runtime_mark_last_busy(host->dev);\r\npm_runtime_put_autosuspend(host->dev);\r\nreturn 0;\r\nerr_slot_name:\r\nmmc_remove_host(mmc);\r\nfree_irq(mmc_slot(host).card_detect_irq, host);\r\nerr_irq_cd:\r\nif (host->use_reg)\r\nomap_hsmmc_reg_put(host);\r\nerr_reg:\r\nif (host->pdata->cleanup)\r\nhost->pdata->cleanup(&pdev->dev);\r\nerr_irq_cd_init:\r\nfree_irq(host->irq, host);\r\nerr_irq:\r\nif (host->tx_chan)\r\ndma_release_channel(host->tx_chan);\r\nif (host->rx_chan)\r\ndma_release_channel(host->rx_chan);\r\npm_runtime_put_sync(host->dev);\r\npm_runtime_disable(host->dev);\r\nclk_put(host->fclk);\r\nif (host->dbclk) {\r\nclk_disable_unprepare(host->dbclk);\r\nclk_put(host->dbclk);\r\n}\r\nerr1:\r\niounmap(host->base);\r\nplatform_set_drvdata(pdev, NULL);\r\nmmc_free_host(mmc);\r\nerr_alloc:\r\nomap_hsmmc_gpio_free(pdata);\r\nerr:\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (res)\r\nrelease_mem_region(res->start, resource_size(res));\r\nreturn ret;\r\n}\r\nstatic int omap_hsmmc_remove(struct platform_device *pdev)\r\n{\r\nstruct omap_hsmmc_host *host = platform_get_drvdata(pdev);\r\nstruct resource *res;\r\npm_runtime_get_sync(host->dev);\r\nmmc_remove_host(host->mmc);\r\nif (host->use_reg)\r\nomap_hsmmc_reg_put(host);\r\nif (host->pdata->cleanup)\r\nhost->pdata->cleanup(&pdev->dev);\r\nfree_irq(host->irq, host);\r\nif (mmc_slot(host).card_detect_irq)\r\nfree_irq(mmc_slot(host).card_detect_irq, host);\r\nif (host->tx_chan)\r\ndma_release_channel(host->tx_chan);\r\nif (host->rx_chan)\r\ndma_release_channel(host->rx_chan);\r\npm_runtime_put_sync(host->dev);\r\npm_runtime_disable(host->dev);\r\nclk_put(host->fclk);\r\nif (host->dbclk) {\r\nclk_disable_unprepare(host->dbclk);\r\nclk_put(host->dbclk);\r\n}\r\nomap_hsmmc_gpio_free(host->pdata);\r\niounmap(host->base);\r\nmmc_free_host(host->mmc);\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (res)\r\nrelease_mem_region(res->start, resource_size(res));\r\nplatform_set_drvdata(pdev, NULL);\r\nreturn 0;\r\n}\r\nstatic int omap_hsmmc_prepare(struct device *dev)\r\n{\r\nstruct omap_hsmmc_host *host = dev_get_drvdata(dev);\r\nif (host->pdata->suspend)\r\nreturn host->pdata->suspend(dev, host->slot_id);\r\nreturn 0;\r\n}\r\nstatic void omap_hsmmc_complete(struct device *dev)\r\n{\r\nstruct omap_hsmmc_host *host = dev_get_drvdata(dev);\r\nif (host->pdata->resume)\r\nhost->pdata->resume(dev, host->slot_id);\r\n}\r\nstatic int omap_hsmmc_suspend(struct device *dev)\r\n{\r\nint ret = 0;\r\nstruct omap_hsmmc_host *host = dev_get_drvdata(dev);\r\nif (!host)\r\nreturn 0;\r\nif (host && host->suspended)\r\nreturn 0;\r\npm_runtime_get_sync(host->dev);\r\nhost->suspended = 1;\r\nret = mmc_suspend_host(host->mmc);\r\nif (ret) {\r\nhost->suspended = 0;\r\ngoto err;\r\n}\r\nif (!(host->mmc->pm_flags & MMC_PM_KEEP_POWER)) {\r\nomap_hsmmc_disable_irq(host);\r\nOMAP_HSMMC_WRITE(host->base, HCTL,\r\nOMAP_HSMMC_READ(host->base, HCTL) & ~SDBP);\r\n}\r\nif (host->dbclk)\r\nclk_disable_unprepare(host->dbclk);\r\nerr:\r\npm_runtime_put_sync(host->dev);\r\nreturn ret;\r\n}\r\nstatic int omap_hsmmc_resume(struct device *dev)\r\n{\r\nint ret = 0;\r\nstruct omap_hsmmc_host *host = dev_get_drvdata(dev);\r\nif (!host)\r\nreturn 0;\r\nif (host && !host->suspended)\r\nreturn 0;\r\npm_runtime_get_sync(host->dev);\r\nif (host->dbclk)\r\nclk_prepare_enable(host->dbclk);\r\nif (!(host->mmc->pm_flags & MMC_PM_KEEP_POWER))\r\nomap_hsmmc_conf_bus_power(host);\r\nomap_hsmmc_protect_card(host);\r\nret = mmc_resume_host(host->mmc);\r\nif (ret == 0)\r\nhost->suspended = 0;\r\npm_runtime_mark_last_busy(host->dev);\r\npm_runtime_put_autosuspend(host->dev);\r\nreturn ret;\r\n}\r\nstatic int omap_hsmmc_runtime_suspend(struct device *dev)\r\n{\r\nstruct omap_hsmmc_host *host;\r\nhost = platform_get_drvdata(to_platform_device(dev));\r\nomap_hsmmc_context_save(host);\r\ndev_dbg(dev, "disabled\n");\r\nreturn 0;\r\n}\r\nstatic int omap_hsmmc_runtime_resume(struct device *dev)\r\n{\r\nstruct omap_hsmmc_host *host;\r\nhost = platform_get_drvdata(to_platform_device(dev));\r\nomap_hsmmc_context_restore(host);\r\ndev_dbg(dev, "enabled\n");\r\nreturn 0;\r\n}
