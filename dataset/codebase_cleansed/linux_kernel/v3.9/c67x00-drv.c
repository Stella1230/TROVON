static void c67x00_probe_sie(struct c67x00_sie *sie,\r\nstruct c67x00_device *dev, int sie_num)\r\n{\r\nspin_lock_init(&sie->lock);\r\nsie->dev = dev;\r\nsie->sie_num = sie_num;\r\nsie->mode = c67x00_sie_config(dev->pdata->sie_config, sie_num);\r\nswitch (sie->mode) {\r\ncase C67X00_SIE_HOST:\r\nc67x00_hcd_probe(sie);\r\nbreak;\r\ncase C67X00_SIE_UNUSED:\r\ndev_info(sie_dev(sie),\r\n"Not using SIE %d as requested\n", sie->sie_num);\r\nbreak;\r\ndefault:\r\ndev_err(sie_dev(sie),\r\n"Unsupported configuration: 0x%x for SIE %d\n",\r\nsie->mode, sie->sie_num);\r\nbreak;\r\n}\r\n}\r\nstatic void c67x00_remove_sie(struct c67x00_sie *sie)\r\n{\r\nswitch (sie->mode) {\r\ncase C67X00_SIE_HOST:\r\nc67x00_hcd_remove(sie);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic irqreturn_t c67x00_irq(int irq, void *__dev)\r\n{\r\nstruct c67x00_device *c67x00 = __dev;\r\nstruct c67x00_sie *sie;\r\nu16 msg, int_status;\r\nint i, count = 8;\r\nint_status = c67x00_ll_hpi_status(c67x00);\r\nif (!int_status)\r\nreturn IRQ_NONE;\r\nwhile (int_status != 0 && (count-- >= 0)) {\r\nc67x00_ll_irq(c67x00, int_status);\r\nfor (i = 0; i < C67X00_SIES; i++) {\r\nsie = &c67x00->sie[i];\r\nmsg = 0;\r\nif (int_status & SIEMSG_FLG(i))\r\nmsg = c67x00_ll_fetch_siemsg(c67x00, i);\r\nif (sie->irq)\r\nsie->irq(sie, int_status, msg);\r\n}\r\nint_status = c67x00_ll_hpi_status(c67x00);\r\n}\r\nif (int_status)\r\ndev_warn(&c67x00->pdev->dev, "Not all interrupts handled! "\r\n"status = 0x%04x\n", int_status);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int c67x00_drv_probe(struct platform_device *pdev)\r\n{\r\nstruct c67x00_device *c67x00;\r\nstruct c67x00_platform_data *pdata;\r\nstruct resource *res, *res2;\r\nint ret, i;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!res)\r\nreturn -ENODEV;\r\nres2 = platform_get_resource(pdev, IORESOURCE_IRQ, 0);\r\nif (!res2)\r\nreturn -ENODEV;\r\npdata = pdev->dev.platform_data;\r\nif (!pdata)\r\nreturn -ENODEV;\r\nc67x00 = kzalloc(sizeof(*c67x00), GFP_KERNEL);\r\nif (!c67x00)\r\nreturn -ENOMEM;\r\nif (!request_mem_region(res->start, resource_size(res),\r\npdev->name)) {\r\ndev_err(&pdev->dev, "Memory region busy\n");\r\nret = -EBUSY;\r\ngoto request_mem_failed;\r\n}\r\nc67x00->hpi.base = ioremap(res->start, resource_size(res));\r\nif (!c67x00->hpi.base) {\r\ndev_err(&pdev->dev, "Unable to map HPI registers\n");\r\nret = -EIO;\r\ngoto map_failed;\r\n}\r\nspin_lock_init(&c67x00->hpi.lock);\r\nc67x00->hpi.regstep = pdata->hpi_regstep;\r\nc67x00->pdata = pdev->dev.platform_data;\r\nc67x00->pdev = pdev;\r\nc67x00_ll_init(c67x00);\r\nc67x00_ll_hpi_reg_init(c67x00);\r\nret = request_irq(res2->start, c67x00_irq, 0, pdev->name, c67x00);\r\nif (ret) {\r\ndev_err(&pdev->dev, "Cannot claim IRQ\n");\r\ngoto request_irq_failed;\r\n}\r\nret = c67x00_ll_reset(c67x00);\r\nif (ret) {\r\ndev_err(&pdev->dev, "Device reset failed\n");\r\ngoto reset_failed;\r\n}\r\nfor (i = 0; i < C67X00_SIES; i++)\r\nc67x00_probe_sie(&c67x00->sie[i], c67x00, i);\r\nplatform_set_drvdata(pdev, c67x00);\r\nreturn 0;\r\nreset_failed:\r\nfree_irq(res2->start, c67x00);\r\nrequest_irq_failed:\r\niounmap(c67x00->hpi.base);\r\nmap_failed:\r\nrelease_mem_region(res->start, resource_size(res));\r\nrequest_mem_failed:\r\nkfree(c67x00);\r\nreturn ret;\r\n}\r\nstatic int c67x00_drv_remove(struct platform_device *pdev)\r\n{\r\nstruct c67x00_device *c67x00 = platform_get_drvdata(pdev);\r\nstruct resource *res;\r\nint i;\r\nfor (i = 0; i < C67X00_SIES; i++)\r\nc67x00_remove_sie(&c67x00->sie[i]);\r\nc67x00_ll_release(c67x00);\r\nres = platform_get_resource(pdev, IORESOURCE_IRQ, 0);\r\nif (res)\r\nfree_irq(res->start, c67x00);\r\niounmap(c67x00->hpi.base);\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (res)\r\nrelease_mem_region(res->start, resource_size(res));\r\nkfree(c67x00);\r\nreturn 0;\r\n}
