static u32 esdhc_readl(struct sdhci_host *host, int reg)\r\n{\r\nu32 ret;\r\nret = in_be32(host->ioaddr + reg);\r\nif ((reg == SDHCI_CAPABILITIES) && (ret & SDHCI_CAN_DO_ADMA1)) {\r\nu32 tmp = in_be32(host->ioaddr + SDHCI_SLOT_INT_STATUS);\r\ntmp = (tmp & SDHCI_VENDOR_VER_MASK) >> SDHCI_VENDOR_VER_SHIFT;\r\nif (tmp > VENDOR_V_22)\r\nret |= SDHCI_CAN_DO_ADMA2;\r\n}\r\nreturn ret;\r\n}\r\nstatic u16 esdhc_readw(struct sdhci_host *host, int reg)\r\n{\r\nu16 ret;\r\nint base = reg & ~0x3;\r\nint shift = (reg & 0x2) * 8;\r\nif (unlikely(reg == SDHCI_HOST_VERSION))\r\nret = in_be32(host->ioaddr + base) & 0xffff;\r\nelse\r\nret = (in_be32(host->ioaddr + base) >> shift) & 0xffff;\r\nreturn ret;\r\n}\r\nstatic u8 esdhc_readb(struct sdhci_host *host, int reg)\r\n{\r\nint base = reg & ~0x3;\r\nint shift = (reg & 0x3) * 8;\r\nu8 ret = (in_be32(host->ioaddr + base) >> shift) & 0xff;\r\nif (reg == SDHCI_HOST_CONTROL) {\r\nu32 dma_bits;\r\ndma_bits = in_be32(host->ioaddr + reg);\r\ndma_bits = (dma_bits >> 5) & SDHCI_CTRL_DMA_MASK;\r\nret &= ~SDHCI_CTRL_DMA_MASK;\r\nret |= dma_bits;\r\n}\r\nreturn ret;\r\n}\r\nstatic void esdhc_writel(struct sdhci_host *host, u32 val, int reg)\r\n{\r\nif (reg == SDHCI_INT_ENABLE)\r\nval |= SDHCI_INT_BLK_GAP;\r\nsdhci_be32bs_writel(host, val, reg);\r\n}\r\nstatic void esdhc_writew(struct sdhci_host *host, u16 val, int reg)\r\n{\r\nif (reg == SDHCI_BLOCK_SIZE) {\r\nval &= ~SDHCI_MAKE_BLKSZ(0x7, 0);\r\n}\r\nsdhci_be32bs_writew(host, val, reg);\r\n}\r\nstatic void esdhc_writeb(struct sdhci_host *host, u8 val, int reg)\r\n{\r\nif (reg == SDHCI_HOST_CONTROL) {\r\nu32 dma_bits;\r\ndma_bits = (val & SDHCI_CTRL_DMA_MASK) << 5;\r\nclrsetbits_be32(host->ioaddr + reg , SDHCI_CTRL_DMA_MASK << 5,\r\ndma_bits);\r\nval &= ~SDHCI_CTRL_DMA_MASK;\r\nval |= in_be32(host->ioaddr + reg) & SDHCI_CTRL_DMA_MASK;\r\n}\r\nif (reg == SDHCI_HOST_CONTROL)\r\nval &= ~ESDHC_HOST_CONTROL_RES;\r\nsdhci_be32bs_writeb(host, val, reg);\r\n}\r\nstatic void esdhci_of_adma_workaround(struct sdhci_host *host, u32 intmask)\r\n{\r\nu32 tmp;\r\nbool applicable;\r\ndma_addr_t dmastart;\r\ndma_addr_t dmanow;\r\ntmp = in_be32(host->ioaddr + SDHCI_SLOT_INT_STATUS);\r\ntmp = (tmp & SDHCI_VENDOR_VER_MASK) >> SDHCI_VENDOR_VER_SHIFT;\r\napplicable = (intmask & SDHCI_INT_DATA_END) &&\r\n(intmask & SDHCI_INT_BLK_GAP) &&\r\n(tmp == VENDOR_V_23);\r\nif (!applicable)\r\nreturn;\r\nhost->data->error = 0;\r\ndmastart = sg_dma_address(host->data->sg);\r\ndmanow = dmastart + host->data->bytes_xfered;\r\ndmanow = (dmanow & ~(SDHCI_DEFAULT_BOUNDARY_SIZE - 1)) +\r\nSDHCI_DEFAULT_BOUNDARY_SIZE;\r\nhost->data->bytes_xfered = dmanow - dmastart;\r\nsdhci_writel(host, dmanow, SDHCI_DMA_ADDRESS);\r\n}\r\nstatic int esdhc_of_enable_dma(struct sdhci_host *host)\r\n{\r\nsetbits32(host->ioaddr + ESDHC_DMA_SYSCTL, ESDHC_DMA_SNOOP);\r\nreturn 0;\r\n}\r\nstatic unsigned int esdhc_of_get_max_clock(struct sdhci_host *host)\r\n{\r\nstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\r\nreturn pltfm_host->clock;\r\n}\r\nstatic unsigned int esdhc_of_get_min_clock(struct sdhci_host *host)\r\n{\r\nstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\r\nreturn pltfm_host->clock / 256 / 16;\r\n}\r\nstatic void esdhc_of_set_clock(struct sdhci_host *host, unsigned int clock)\r\n{\r\nif (of_find_compatible_node(NULL, NULL, "fsl,p1010-esdhc")) {\r\nif (clock > 20000000)\r\nclock -= 5000000;\r\nif (clock > 40000000)\r\nclock -= 5000000;\r\n}\r\nesdhc_set_clock(host, clock);\r\n}\r\nstatic void esdhc_of_suspend(struct sdhci_host *host)\r\n{\r\nesdhc_proctl = sdhci_be32bs_readl(host, SDHCI_HOST_CONTROL);\r\n}\r\nstatic void esdhc_of_resume(struct sdhci_host *host)\r\n{\r\nesdhc_of_enable_dma(host);\r\nsdhci_be32bs_writel(host, esdhc_proctl, SDHCI_HOST_CONTROL);\r\n}\r\nstatic void esdhc_of_platform_init(struct sdhci_host *host)\r\n{\r\nu32 vvn;\r\nvvn = in_be32(host->ioaddr + SDHCI_SLOT_INT_STATUS);\r\nvvn = (vvn & SDHCI_VENDOR_VER_MASK) >> SDHCI_VENDOR_VER_SHIFT;\r\nif (vvn == VENDOR_V_22)\r\nhost->quirks2 |= SDHCI_QUIRK2_HOST_NO_CMD23;\r\nif (vvn > VENDOR_V_22)\r\nhost->quirks &= ~SDHCI_QUIRK_NO_BUSY_IRQ;\r\n}\r\nstatic int sdhci_esdhc_probe(struct platform_device *pdev)\r\n{\r\nreturn sdhci_pltfm_register(pdev, &sdhci_esdhc_pdata);\r\n}\r\nstatic int sdhci_esdhc_remove(struct platform_device *pdev)\r\n{\r\nreturn sdhci_pltfm_unregister(pdev);\r\n}
