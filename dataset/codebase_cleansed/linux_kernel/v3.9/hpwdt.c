static int cru_detect(unsigned long map_entry,\r\nunsigned long map_offset)\r\n{\r\nvoid *bios32_map;\r\nunsigned long *bios32_entrypoint;\r\nunsigned long cru_physical_address;\r\nunsigned long cru_length;\r\nunsigned long physical_bios_base = 0;\r\nunsigned long physical_bios_offset = 0;\r\nint retval = -ENODEV;\r\nbios32_map = ioremap(map_entry, (2 * PAGE_SIZE));\r\nif (bios32_map == NULL)\r\nreturn -ENODEV;\r\nbios32_entrypoint = bios32_map + map_offset;\r\ncmn_regs.u1.reax = CRU_BIOS_SIGNATURE_VALUE;\r\nset_memory_x((unsigned long)bios32_map, 2);\r\nasminline_call(&cmn_regs, bios32_entrypoint);\r\nif (cmn_regs.u1.ral != 0) {\r\npr_warn("Call succeeded but with an error: 0x%x\n",\r\ncmn_regs.u1.ral);\r\n} else {\r\nphysical_bios_base = cmn_regs.u2.rebx;\r\nphysical_bios_offset = cmn_regs.u4.redx;\r\ncru_length = cmn_regs.u3.recx;\r\ncru_physical_address =\r\nphysical_bios_base + physical_bios_offset;\r\nif ((physical_bios_base + physical_bios_offset)) {\r\ncru_rom_addr =\r\nioremap(cru_physical_address, cru_length);\r\nif (cru_rom_addr) {\r\nset_memory_x((unsigned long)cru_rom_addr & PAGE_MASK,\r\n(cru_length + PAGE_SIZE - 1) >> PAGE_SHIFT);\r\nretval = 0;\r\n}\r\n}\r\npr_debug("CRU Base Address: 0x%lx\n", physical_bios_base);\r\npr_debug("CRU Offset Address: 0x%lx\n", physical_bios_offset);\r\npr_debug("CRU Length: 0x%lx\n", cru_length);\r\npr_debug("CRU Mapped Address: %p\n", &cru_rom_addr);\r\n}\r\niounmap(bios32_map);\r\nreturn retval;\r\n}\r\nstatic int bios_checksum(const char __iomem *ptr, int len)\r\n{\r\nchar sum = 0;\r\nint i;\r\nfor (i = 0; i < len; i++)\r\nsum += ptr[i];\r\nreturn ((sum == 0) && (len > 0));\r\n}\r\nstatic int bios32_present(const char __iomem *p)\r\n{\r\nstruct bios32_service_dir *bios_32_ptr;\r\nint length;\r\nunsigned long map_entry, map_offset;\r\nbios_32_ptr = (struct bios32_service_dir *) p;\r\nif (bios_32_ptr->signature == PCI_BIOS32_SD_VALUE) {\r\nlength = bios_32_ptr->length * PCI_BIOS32_PARAGRAPH_LEN;\r\nif (bios_checksum(p, length)) {\r\nmap_entry = bios_32_ptr->entry_point & ~(PAGE_SIZE - 1);\r\nmap_offset = bios_32_ptr->entry_point - map_entry;\r\nreturn cru_detect(map_entry, map_offset);\r\n}\r\n}\r\nreturn -ENODEV;\r\n}\r\nstatic int detect_cru_service(void)\r\n{\r\nchar __iomem *p, *q;\r\nint rc = -1;\r\np = ioremap(PCI_ROM_BASE1, ROM_SIZE);\r\nif (p == NULL)\r\nreturn -ENOMEM;\r\nfor (q = p; q < p + ROM_SIZE; q += 16) {\r\nrc = bios32_present(q);\r\nif (!rc)\r\nbreak;\r\n}\r\niounmap(p);\r\nreturn rc;\r\n}\r\nstatic void dmi_find_cru(const struct dmi_header *dm, void *dummy)\r\n{\r\nstruct smbios_cru64_info *smbios_cru64_ptr;\r\nunsigned long cru_physical_address;\r\nif (dm->type == SMBIOS_CRU64_INFORMATION) {\r\nsmbios_cru64_ptr = (struct smbios_cru64_info *) dm;\r\nif (smbios_cru64_ptr->signature == CRU_BIOS_SIGNATURE_VALUE) {\r\ncru_physical_address =\r\nsmbios_cru64_ptr->physical_address +\r\nsmbios_cru64_ptr->double_offset;\r\ncru_rom_addr = ioremap(cru_physical_address,\r\nsmbios_cru64_ptr->double_length);\r\nset_memory_x((unsigned long)cru_rom_addr & PAGE_MASK,\r\nsmbios_cru64_ptr->double_length >> PAGE_SHIFT);\r\n}\r\n}\r\n}\r\nstatic int detect_cru_service(void)\r\n{\r\ncru_rom_addr = NULL;\r\ndmi_walk(dmi_find_cru, NULL);\r\nreturn ((cru_rom_addr != NULL) ? 0 : -ENODEV);\r\n}\r\nstatic void hpwdt_start(void)\r\n{\r\nreload = SECS_TO_TICKS(soft_margin);\r\niowrite16(reload, hpwdt_timer_reg);\r\niowrite8(0x85, hpwdt_timer_con);\r\n}\r\nstatic void hpwdt_stop(void)\r\n{\r\nunsigned long data;\r\ndata = ioread8(hpwdt_timer_con);\r\ndata &= 0xFE;\r\niowrite8(data, hpwdt_timer_con);\r\n}\r\nstatic void hpwdt_ping(void)\r\n{\r\niowrite16(reload, hpwdt_timer_reg);\r\n}\r\nstatic int hpwdt_change_timer(int new_margin)\r\n{\r\nif (new_margin < 1 || new_margin > HPWDT_MAX_TIMER) {\r\npr_warn("New value passed in is invalid: %d seconds\n",\r\nnew_margin);\r\nreturn -EINVAL;\r\n}\r\nsoft_margin = new_margin;\r\npr_debug("New timer passed in is %d seconds\n", new_margin);\r\nreload = SECS_TO_TICKS(soft_margin);\r\nreturn 0;\r\n}\r\nstatic int hpwdt_time_left(void)\r\n{\r\nreturn TICKS_TO_SECS(ioread16(hpwdt_timer_reg));\r\n}\r\nstatic int hpwdt_pretimeout(unsigned int ulReason, struct pt_regs *regs)\r\n{\r\nunsigned long rom_pl;\r\nstatic int die_nmi_called;\r\nif (!hpwdt_nmi_decoding)\r\ngoto out;\r\nspin_lock_irqsave(&rom_lock, rom_pl);\r\nif (!die_nmi_called && !is_icru)\r\nasminline_call(&cmn_regs, cru_rom_addr);\r\ndie_nmi_called = 1;\r\nspin_unlock_irqrestore(&rom_lock, rom_pl);\r\nif (allow_kdump)\r\nhpwdt_stop();\r\nif (!is_icru) {\r\nif (cmn_regs.u1.ral == 0) {\r\npanic("An NMI occurred, "\r\n"but unable to determine source.\n");\r\n}\r\n}\r\npanic("An NMI occurred, please see the Integrated "\r\n"Management Log for details.\n");\r\nout:\r\nreturn NMI_DONE;\r\n}\r\nstatic int hpwdt_open(struct inode *inode, struct file *file)\r\n{\r\nif (test_and_set_bit(0, &hpwdt_is_open))\r\nreturn -EBUSY;\r\nhpwdt_start();\r\nhpwdt_ping();\r\nreturn nonseekable_open(inode, file);\r\n}\r\nstatic int hpwdt_release(struct inode *inode, struct file *file)\r\n{\r\nif (expect_release == 42) {\r\nhpwdt_stop();\r\n} else {\r\npr_crit("Unexpected close, not stopping watchdog!\n");\r\nhpwdt_ping();\r\n}\r\nexpect_release = 0;\r\nclear_bit(0, &hpwdt_is_open);\r\nreturn 0;\r\n}\r\nstatic ssize_t hpwdt_write(struct file *file, const char __user *data,\r\nsize_t len, loff_t *ppos)\r\n{\r\nif (len) {\r\nif (!nowayout) {\r\nsize_t i;\r\nexpect_release = 0;\r\nfor (i = 0; i != len; i++) {\r\nchar c;\r\nif (get_user(c, data + i))\r\nreturn -EFAULT;\r\nif (c == 'V')\r\nexpect_release = 42;\r\n}\r\n}\r\nhpwdt_ping();\r\n}\r\nreturn len;\r\n}\r\nstatic long hpwdt_ioctl(struct file *file, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\nvoid __user *argp = (void __user *)arg;\r\nint __user *p = argp;\r\nint new_margin;\r\nint ret = -ENOTTY;\r\nswitch (cmd) {\r\ncase WDIOC_GETSUPPORT:\r\nret = 0;\r\nif (copy_to_user(argp, &ident, sizeof(ident)))\r\nret = -EFAULT;\r\nbreak;\r\ncase WDIOC_GETSTATUS:\r\ncase WDIOC_GETBOOTSTATUS:\r\nret = put_user(0, p);\r\nbreak;\r\ncase WDIOC_KEEPALIVE:\r\nhpwdt_ping();\r\nret = 0;\r\nbreak;\r\ncase WDIOC_SETTIMEOUT:\r\nret = get_user(new_margin, p);\r\nif (ret)\r\nbreak;\r\nret = hpwdt_change_timer(new_margin);\r\nif (ret)\r\nbreak;\r\nhpwdt_ping();\r\ncase WDIOC_GETTIMEOUT:\r\nret = put_user(soft_margin, p);\r\nbreak;\r\ncase WDIOC_GETTIMELEFT:\r\nret = put_user(hpwdt_time_left(), p);\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic void hpwdt_check_nmi_decoding(struct pci_dev *dev)\r\n{\r\nhpwdt_nmi_decoding = 1;\r\n}\r\nstatic void hpwdt_check_nmi_decoding(struct pci_dev *dev)\r\n{\r\ndev_warn(&dev->dev, "NMI decoding is disabled. "\r\n"Your kernel does not support a NMI Watchdog.\n");\r\n}\r\nstatic void dmi_find_icru(const struct dmi_header *dm, void *dummy)\r\n{\r\nstruct smbios_proliant_info *smbios_proliant_ptr;\r\nif (dm->type == SMBIOS_ICRU_INFORMATION) {\r\nsmbios_proliant_ptr = (struct smbios_proliant_info *) dm;\r\nif (smbios_proliant_ptr->misc_features & 0x01)\r\nis_icru = 1;\r\n}\r\n}\r\nstatic int hpwdt_init_nmi_decoding(struct pci_dev *dev)\r\n{\r\nint retval;\r\ndmi_walk(dmi_find_icru, NULL);\r\nif (!is_icru) {\r\nretval = detect_cru_service();\r\nif (retval < 0) {\r\ndev_warn(&dev->dev,\r\n"Unable to detect the %d Bit CRU Service.\n",\r\nHPWDT_ARCH);\r\nreturn retval;\r\n}\r\ncmn_regs.u1.rah = 0x0D;\r\ncmn_regs.u1.ral = 0x02;\r\n}\r\nretval = register_nmi_handler(NMI_UNKNOWN, hpwdt_pretimeout, 0, "hpwdt");\r\nif (retval)\r\ngoto error;\r\nretval = register_nmi_handler(NMI_SERR, hpwdt_pretimeout, 0, "hpwdt");\r\nif (retval)\r\ngoto error1;\r\nretval = register_nmi_handler(NMI_IO_CHECK, hpwdt_pretimeout, 0, "hpwdt");\r\nif (retval)\r\ngoto error2;\r\ndev_info(&dev->dev,\r\n"HP Watchdog Timer Driver: NMI decoding initialized"\r\n", allow kernel dump: %s (default = 0/OFF)\n",\r\n(allow_kdump == 0) ? "OFF" : "ON");\r\nreturn 0;\r\nerror2:\r\nunregister_nmi_handler(NMI_SERR, "hpwdt");\r\nerror1:\r\nunregister_nmi_handler(NMI_UNKNOWN, "hpwdt");\r\nerror:\r\ndev_warn(&dev->dev,\r\n"Unable to register a die notifier (err=%d).\n",\r\nretval);\r\nif (cru_rom_addr)\r\niounmap(cru_rom_addr);\r\nreturn retval;\r\n}\r\nstatic void hpwdt_exit_nmi_decoding(void)\r\n{\r\nunregister_nmi_handler(NMI_UNKNOWN, "hpwdt");\r\nunregister_nmi_handler(NMI_SERR, "hpwdt");\r\nunregister_nmi_handler(NMI_IO_CHECK, "hpwdt");\r\nif (cru_rom_addr)\r\niounmap(cru_rom_addr);\r\n}\r\nstatic void hpwdt_check_nmi_decoding(struct pci_dev *dev)\r\n{\r\n}\r\nstatic int hpwdt_init_nmi_decoding(struct pci_dev *dev)\r\n{\r\nreturn 0;\r\n}\r\nstatic void hpwdt_exit_nmi_decoding(void)\r\n{\r\n}\r\nstatic int hpwdt_init_one(struct pci_dev *dev,\r\nconst struct pci_device_id *ent)\r\n{\r\nint retval;\r\nhpwdt_check_nmi_decoding(dev);\r\nif (dev->subsystem_vendor != PCI_VENDOR_ID_HP) {\r\ndev_warn(&dev->dev,\r\n"This server does not have an iLO2+ ASIC.\n");\r\nreturn -ENODEV;\r\n}\r\nif (pci_enable_device(dev)) {\r\ndev_warn(&dev->dev,\r\n"Not possible to enable PCI Device: 0x%x:0x%x.\n",\r\nent->vendor, ent->device);\r\nreturn -ENODEV;\r\n}\r\npci_mem_addr = pci_iomap(dev, 1, 0x80);\r\nif (!pci_mem_addr) {\r\ndev_warn(&dev->dev,\r\n"Unable to detect the iLO2+ server memory.\n");\r\nretval = -ENOMEM;\r\ngoto error_pci_iomap;\r\n}\r\nhpwdt_timer_reg = pci_mem_addr + 0x70;\r\nhpwdt_timer_con = pci_mem_addr + 0x72;\r\nhpwdt_stop();\r\nif (hpwdt_change_timer(soft_margin))\r\nhpwdt_change_timer(DEFAULT_MARGIN);\r\nretval = hpwdt_init_nmi_decoding(dev);\r\nif (retval != 0)\r\ngoto error_init_nmi_decoding;\r\nretval = misc_register(&hpwdt_miscdev);\r\nif (retval < 0) {\r\ndev_warn(&dev->dev,\r\n"Unable to register miscdev on minor=%d (err=%d).\n",\r\nWATCHDOG_MINOR, retval);\r\ngoto error_misc_register;\r\n}\r\ndev_info(&dev->dev, "HP Watchdog Timer Driver: %s"\r\n", timer margin: %d seconds (nowayout=%d).\n",\r\nHPWDT_VERSION, soft_margin, nowayout);\r\nreturn 0;\r\nerror_misc_register:\r\nhpwdt_exit_nmi_decoding();\r\nerror_init_nmi_decoding:\r\npci_iounmap(dev, pci_mem_addr);\r\nerror_pci_iomap:\r\npci_disable_device(dev);\r\nreturn retval;\r\n}\r\nstatic void hpwdt_exit(struct pci_dev *dev)\r\n{\r\nif (!nowayout)\r\nhpwdt_stop();\r\nmisc_deregister(&hpwdt_miscdev);\r\nhpwdt_exit_nmi_decoding();\r\npci_iounmap(dev, pci_mem_addr);\r\npci_disable_device(dev);\r\n}
