static int hex(unsigned char ch)\r\n{\r\nif (ch >= 'a' && ch <= 'f')\r\nreturn ch-'a'+10;\r\nif (ch >= '0' && ch <= '9')\r\nreturn ch-'0';\r\nif (ch >= 'A' && ch <= 'F')\r\nreturn ch-'A'+10;\r\nreturn -1;\r\n}\r\nvoid gdbstub_printk(const char *fmt, ...)\r\n{\r\nstatic char buf[1024];\r\nva_list args;\r\nint len;\r\nva_start(args, fmt);\r\nlen = vsnprintf(buf, sizeof(buf), fmt, args);\r\nva_end(args);\r\ndebug_to_serial(buf, len);\r\n}\r\nstatic inline char *gdbstub_strcpy(char *dst, const char *src)\r\n{\r\nint loop = 0;\r\nwhile ((dst[loop] = src[loop]))\r\nloop++;\r\nreturn dst;\r\n}\r\nstatic void gdbstub_purge_cache(void)\r\n{\r\nasm volatile(" dcef @(gr0,gr0),#1 \n"\r\n" icei @(gr0,gr0),#1 \n"\r\n" membar \n"\r\n" bar \n"\r\n);\r\n}\r\nstatic void gdbstub_recv_packet(char *buffer)\r\n{\r\nunsigned char checksum;\r\nunsigned char xmitcsum;\r\nunsigned char ch;\r\nint count, i, ret, error;\r\nfor (;;) {\r\ndo {\r\ngdbstub_rx_char(&ch, 0);\r\n} while (ch != '$');\r\nchecksum = 0;\r\nxmitcsum = -1;\r\ncount = 0;\r\nerror = 0;\r\nwhile (count < BUFMAX) {\r\nret = gdbstub_rx_char(&ch, 0);\r\nif (ret < 0)\r\nerror = ret;\r\nif (ch == '#')\r\nbreak;\r\nchecksum += ch;\r\nbuffer[count] = ch;\r\ncount++;\r\n}\r\nif (error == -EIO) {\r\ngdbstub_proto("### GDB Rx Error - Skipping packet ###\n");\r\ngdbstub_proto("### GDB Tx NAK\n");\r\ngdbstub_tx_char('-');\r\ncontinue;\r\n}\r\nif (count >= BUFMAX || error)\r\ncontinue;\r\nbuffer[count] = 0;\r\nret = gdbstub_rx_char(&ch, 0);\r\nif (ret < 0)\r\nerror = ret;\r\nxmitcsum = hex(ch) << 4;\r\nret = gdbstub_rx_char(&ch, 0);\r\nif (ret < 0)\r\nerror = ret;\r\nxmitcsum |= hex(ch);\r\nif (error) {\r\nif (error == -EIO)\r\ngdbstub_proto("### GDB Rx Error - Skipping packet\n");\r\ngdbstub_proto("### GDB Tx NAK\n");\r\ngdbstub_tx_char('-');\r\ncontinue;\r\n}\r\nif (checksum != xmitcsum) {\r\ngdbstub_proto("### GDB Tx NAK\n");\r\ngdbstub_tx_char('-');\r\ncontinue;\r\n}\r\ngdbstub_proto("### GDB Rx '$%s#%02x' ###\n", buffer, checksum);\r\ngdbstub_proto("### GDB Tx ACK\n");\r\ngdbstub_tx_char('+');\r\nif (buffer[2] == ':') {\r\ngdbstub_tx_char(buffer[0]);\r\ngdbstub_tx_char(buffer[1]);\r\ncount = 0;\r\nwhile (buffer[count]) count++;\r\nfor (i=3; i <= count; i++)\r\nbuffer[i - 3] = buffer[i];\r\n}\r\nbreak;\r\n}\r\n}\r\nstatic int gdbstub_send_packet(char *buffer)\r\n{\r\nunsigned char checksum;\r\nint count;\r\nunsigned char ch;\r\ngdbstub_proto("### GDB Tx '%s' ###\n", buffer);\r\ndo {\r\ngdbstub_tx_char('$');\r\nchecksum = 0;\r\ncount = 0;\r\nwhile ((ch = buffer[count]) != 0) {\r\ngdbstub_tx_char(ch);\r\nchecksum += ch;\r\ncount += 1;\r\n}\r\ngdbstub_tx_char('#');\r\ngdbstub_tx_char(hex_asc_hi(checksum));\r\ngdbstub_tx_char(hex_asc_lo(checksum));\r\n} while (gdbstub_rx_char(&ch,0),\r\n#ifdef GDBSTUB_DEBUG_PROTOCOL\r\nch=='-' && (gdbstub_proto("### GDB Rx NAK\n"),0),\r\nch!='-' && ch!='+' && (gdbstub_proto("### GDB Rx ??? %02x\n",ch),0),\r\n#endif\r\nch!='+' && ch!='$');\r\nif (ch=='+') {\r\ngdbstub_proto("### GDB Rx ACK\n");\r\nreturn 0;\r\n}\r\ngdbstub_proto("### GDB Tx Abandoned\n");\r\ngdbstub_rx_unget = ch;\r\nreturn 1;\r\n}\r\nstatic int hexToInt(char **ptr, unsigned long *_value)\r\n{\r\nint count = 0, ch;\r\n*_value = 0;\r\nwhile (**ptr) {\r\nch = hex(**ptr);\r\nif (ch < 0)\r\nbreak;\r\n*_value = (*_value << 4) | ((uint8_t) ch & 0xf);\r\ncount++;\r\n(*ptr)++;\r\n}\r\nreturn count;\r\n}\r\nstatic inline int gdbstub_addr_probe(const void *vaddr)\r\n{\r\n#ifdef CONFIG_MMU\r\nunsigned long paddr;\r\nasm("lrad %1,%0,#1,#0,#0" : "=r"(paddr) : "r"(vaddr));\r\nif (!(paddr & xAMPRx_V))\r\nreturn 0;\r\n#endif\r\nreturn 1;\r\n}\r\nstatic inline unsigned long gdbstub_virt_to_pte(unsigned long vaddr)\r\n{\r\npgd_t *pgd;\r\npud_t *pud;\r\npmd_t *pmd;\r\npte_t *pte;\r\nunsigned long val, dampr5;\r\npgd = (pgd_t *) __get_DAMLR(3) + pgd_index(vaddr);\r\npud = pud_offset(pgd, vaddr);\r\npmd = pmd_offset(pud, vaddr);\r\nif (pmd_bad(*pmd) || !pmd_present(*pmd))\r\nreturn 0;\r\ndampr5 = __get_DAMPR(5);\r\nval = pmd_val(*pmd);\r\n__set_DAMPR(5, val | xAMPRx_L | xAMPRx_SS_16Kb | xAMPRx_S | xAMPRx_C | xAMPRx_V);\r\npte = (pte_t *)__get_DAMLR(5) + __pte_index(vaddr);\r\nif (pte_present(*pte))\r\nval = pte_val(*pte);\r\nelse\r\nval = 0;\r\n__set_DAMPR(5, dampr5);\r\nreturn val;\r\n}\r\nstatic inline int gdbstub_addr_map(const void *vaddr)\r\n{\r\n#ifdef CONFIG_MMU\r\nunsigned long pte;\r\n__saved_dampr = __get_DAMPR(2);\r\n__saved_damlr = __get_DAMLR(2);\r\n#endif\r\nif (gdbstub_addr_probe(vaddr))\r\nreturn 1;\r\n#ifdef CONFIG_MMU\r\npte = gdbstub_virt_to_pte((unsigned long) vaddr);\r\nif (pte) {\r\n__set_DAMPR(2, pte);\r\n__set_DAMLR(2, (unsigned long) vaddr & PAGE_MASK);\r\nreturn 1;\r\n}\r\n#endif\r\nreturn 0;\r\n}\r\nstatic inline void gdbstub_addr_unmap(void)\r\n{\r\n#ifdef CONFIG_MMU\r\n__set_DAMPR(2, __saved_dampr);\r\n__set_DAMLR(2, __saved_damlr);\r\n#endif\r\n}\r\nstatic inline int gdbstub_read_dword(const void *addr, uint32_t *_res)\r\n{\r\nunsigned long brr;\r\nuint32_t res;\r\nif (!gdbstub_addr_map(addr))\r\nreturn 0;\r\nasm volatile(" movgs gr0,brr \n"\r\n" ld%I2 %M2,%0 \n"\r\n" movsg brr,%1 \n"\r\n: "=r"(res), "=r"(brr)\r\n: "m"(*(uint32_t *) addr));\r\n*_res = res;\r\ngdbstub_addr_unmap();\r\nreturn likely(!brr);\r\n}\r\nstatic inline int gdbstub_write_dword(void *addr, uint32_t val)\r\n{\r\nunsigned long brr;\r\nif (!gdbstub_addr_map(addr))\r\nreturn 0;\r\nasm volatile(" movgs gr0,brr \n"\r\n" st%I2 %1,%M2 \n"\r\n" movsg brr,%0 \n"\r\n: "=r"(brr)\r\n: "r"(val), "m"(*(uint32_t *) addr));\r\ngdbstub_addr_unmap();\r\nreturn likely(!brr);\r\n}\r\nstatic inline int gdbstub_read_word(const void *addr, uint16_t *_res)\r\n{\r\nunsigned long brr;\r\nuint16_t res;\r\nif (!gdbstub_addr_map(addr))\r\nreturn 0;\r\nasm volatile(" movgs gr0,brr \n"\r\n" lduh%I2 %M2,%0 \n"\r\n" movsg brr,%1 \n"\r\n: "=r"(res), "=r"(brr)\r\n: "m"(*(uint16_t *) addr));\r\n*_res = res;\r\ngdbstub_addr_unmap();\r\nreturn likely(!brr);\r\n}\r\nstatic inline int gdbstub_write_word(void *addr, uint16_t val)\r\n{\r\nunsigned long brr;\r\nif (!gdbstub_addr_map(addr))\r\nreturn 0;\r\nasm volatile(" movgs gr0,brr \n"\r\n" sth%I2 %1,%M2 \n"\r\n" movsg brr,%0 \n"\r\n: "=r"(brr)\r\n: "r"(val), "m"(*(uint16_t *) addr));\r\ngdbstub_addr_unmap();\r\nreturn likely(!brr);\r\n}\r\nstatic inline int gdbstub_read_byte(const void *addr, uint8_t *_res)\r\n{\r\nunsigned long brr;\r\nuint8_t res;\r\nif (!gdbstub_addr_map(addr))\r\nreturn 0;\r\nasm volatile(" movgs gr0,brr \n"\r\n" ldub%I2 %M2,%0 \n"\r\n" movsg brr,%1 \n"\r\n: "=r"(res), "=r"(brr)\r\n: "m"(*(uint8_t *) addr));\r\n*_res = res;\r\ngdbstub_addr_unmap();\r\nreturn likely(!brr);\r\n}\r\nstatic inline int gdbstub_write_byte(void *addr, uint8_t val)\r\n{\r\nunsigned long brr;\r\nif (!gdbstub_addr_map(addr))\r\nreturn 0;\r\nasm volatile(" movgs gr0,brr \n"\r\n" stb%I2 %1,%M2 \n"\r\n" movsg brr,%0 \n"\r\n: "=r"(brr)\r\n: "r"(val), "m"(*(uint8_t *) addr));\r\ngdbstub_addr_unmap();\r\nreturn likely(!brr);\r\n}\r\nstatic void __gdbstub_console_write(struct console *co, const char *p, unsigned n)\r\n{\r\nchar outbuf[26];\r\nint qty;\r\noutbuf[0] = 'O';\r\nwhile (n > 0) {\r\nqty = 1;\r\nwhile (n > 0 && qty < 20) {\r\nmem2hex(p, outbuf + qty, 2, 0);\r\nqty += 2;\r\nif (*p == 0x0a) {\r\noutbuf[qty++] = '0';\r\noutbuf[qty++] = 'd';\r\n}\r\np++;\r\nn--;\r\n}\r\noutbuf[qty] = 0;\r\ngdbstub_send_packet(outbuf);\r\n}\r\n}\r\nstatic unsigned char *mem2hex(const void *_mem, char *buf, int count, int may_fault)\r\n{\r\nconst uint8_t *mem = _mem;\r\nuint8_t ch[4] __attribute__((aligned(4)));\r\nif ((uint32_t)mem&1 && count>=1) {\r\nif (!gdbstub_read_byte(mem,ch))\r\nreturn NULL;\r\nbuf = hex_byte_pack(buf, ch[0]);\r\nmem++;\r\ncount--;\r\n}\r\nif ((uint32_t)mem&3 && count>=2) {\r\nif (!gdbstub_read_word(mem,(uint16_t *)ch))\r\nreturn NULL;\r\nbuf = hex_byte_pack(buf, ch[0]);\r\nbuf = hex_byte_pack(buf, ch[1]);\r\nmem += 2;\r\ncount -= 2;\r\n}\r\nwhile (count>=4) {\r\nif (!gdbstub_read_dword(mem,(uint32_t *)ch))\r\nreturn NULL;\r\nbuf = hex_byte_pack(buf, ch[0]);\r\nbuf = hex_byte_pack(buf, ch[1]);\r\nbuf = hex_byte_pack(buf, ch[2]);\r\nbuf = hex_byte_pack(buf, ch[3]);\r\nmem += 4;\r\ncount -= 4;\r\n}\r\nif (count>=2) {\r\nif (!gdbstub_read_word(mem,(uint16_t *)ch))\r\nreturn NULL;\r\nbuf = hex_byte_pack(buf, ch[0]);\r\nbuf = hex_byte_pack(buf, ch[1]);\r\nmem += 2;\r\ncount -= 2;\r\n}\r\nif (count>=1) {\r\nif (!gdbstub_read_byte(mem,ch))\r\nreturn NULL;\r\nbuf = hex_byte_pack(buf, ch[0]);\r\n}\r\n*buf = 0;\r\nreturn buf;\r\n}\r\nstatic char *hex2mem(const char *buf, void *_mem, int count)\r\n{\r\nuint8_t *mem = _mem;\r\nunion {\r\nuint32_t l;\r\nuint16_t w;\r\nuint8_t b[4];\r\n} ch;\r\nif ((u32)mem&1 && count>=1) {\r\nch.b[0] = hex(*buf++) << 4;\r\nch.b[0] |= hex(*buf++);\r\nif (!gdbstub_write_byte(mem,ch.b[0]))\r\nreturn NULL;\r\nmem++;\r\ncount--;\r\n}\r\nif ((u32)mem&3 && count>=2) {\r\nch.b[0] = hex(*buf++) << 4;\r\nch.b[0] |= hex(*buf++);\r\nch.b[1] = hex(*buf++) << 4;\r\nch.b[1] |= hex(*buf++);\r\nif (!gdbstub_write_word(mem,ch.w))\r\nreturn NULL;\r\nmem += 2;\r\ncount -= 2;\r\n}\r\nwhile (count>=4) {\r\nch.b[0] = hex(*buf++) << 4;\r\nch.b[0] |= hex(*buf++);\r\nch.b[1] = hex(*buf++) << 4;\r\nch.b[1] |= hex(*buf++);\r\nch.b[2] = hex(*buf++) << 4;\r\nch.b[2] |= hex(*buf++);\r\nch.b[3] = hex(*buf++) << 4;\r\nch.b[3] |= hex(*buf++);\r\nif (!gdbstub_write_dword(mem,ch.l))\r\nreturn NULL;\r\nmem += 4;\r\ncount -= 4;\r\n}\r\nif (count>=2) {\r\nch.b[0] = hex(*buf++) << 4;\r\nch.b[0] |= hex(*buf++);\r\nch.b[1] = hex(*buf++) << 4;\r\nch.b[1] |= hex(*buf++);\r\nif (!gdbstub_write_word(mem,ch.w))\r\nreturn NULL;\r\nmem += 2;\r\ncount -= 2;\r\n}\r\nif (count>=1) {\r\nch.b[0] = hex(*buf++) << 4;\r\nch.b[0] |= hex(*buf++);\r\nif (!gdbstub_write_byte(mem,ch.b[0]))\r\nreturn NULL;\r\n}\r\nreturn (char *) buf;\r\n}\r\nstatic inline int gdbstub_compute_signal(unsigned long brr)\r\n{\r\nconst struct brr_to_sig_map *map;\r\nunsigned long tbr = (brr & BRR_EBTT) >> 12;\r\nfor (map = brr_to_sig_map; map->brr_mask; map++)\r\nif (map->brr_mask & brr)\r\nif (!map->tbr_tt || map->tbr_tt == tbr)\r\nbreak;\r\nreturn map->signo;\r\n}\r\nstatic int gdbstub_set_breakpoint(unsigned long type, unsigned long addr, unsigned long len)\r\n{\r\nunsigned long tmp;\r\nint bkpt, loop, xloop;\r\nunion {\r\nstruct {\r\nunsigned long mask0, mask1;\r\n};\r\nuint8_t bytes[8];\r\n} dbmr;\r\nswitch (type) {\r\ncase 0:\r\nif (addr & 3 || len > 7*4)\r\nreturn -EINVAL;\r\nfor (bkpt = 255; bkpt >= 0; bkpt--)\r\nif (!gdbstub_bkpts[bkpt].addr)\r\nbreak;\r\nif (bkpt < 0)\r\nreturn -ENOSPC;\r\nfor (loop = 0; loop < len/4; loop++)\r\nif (!gdbstub_read_dword(&((uint32_t *) addr)[loop],\r\n&gdbstub_bkpts[bkpt].originsns[loop]))\r\nreturn -EFAULT;\r\nfor (loop = 0; loop < len/4; loop++)\r\nif (!gdbstub_write_dword(&((uint32_t *) addr)[loop],\r\nBREAK_INSN)\r\n) {\r\nfor (xloop = 0; xloop < loop; xloop++)\r\ngdbstub_write_dword(&((uint32_t *) addr)[xloop],\r\ngdbstub_bkpts[bkpt].originsns[xloop]);\r\nreturn -EFAULT;\r\n}\r\ngdbstub_bkpts[bkpt].addr = addr;\r\ngdbstub_bkpts[bkpt].len = len;\r\n#if 0\r\ngdbstub_printk("Set BKPT[%02x]: %08lx #%d {%04x, %04x} -> { %04x, %04x }\n",\r\nbkpt,\r\ngdbstub_bkpts[bkpt].addr,\r\ngdbstub_bkpts[bkpt].len,\r\ngdbstub_bkpts[bkpt].originsns[0],\r\ngdbstub_bkpts[bkpt].originsns[1],\r\n((uint32_t *) addr)[0],\r\n((uint32_t *) addr)[1]\r\n);\r\n#endif\r\nreturn 0;\r\ncase 1:\r\nif (addr & 3 || len != 4)\r\nreturn -EINVAL;\r\nif (!(__debug_regs->dcr & DCR_IBE0)) {\r\n__debug_regs->dcr |= DCR_IBE0;\r\n__debug_regs->ibar[0] = addr;\r\nasm volatile("movgs %0,ibar0" : : "r"(addr));\r\nreturn 0;\r\n}\r\nif (!(__debug_regs->dcr & DCR_IBE1)) {\r\n__debug_regs->dcr |= DCR_IBE1;\r\n__debug_regs->ibar[1] = addr;\r\nasm volatile("movgs %0,ibar1" : : "r"(addr));\r\nreturn 0;\r\n}\r\nif (!(__debug_regs->dcr & DCR_IBE2)) {\r\n__debug_regs->dcr |= DCR_IBE2;\r\n__debug_regs->ibar[2] = addr;\r\nasm volatile("movgs %0,ibar2" : : "r"(addr));\r\nreturn 0;\r\n}\r\nif (!(__debug_regs->dcr & DCR_IBE3)) {\r\n__debug_regs->dcr |= DCR_IBE3;\r\n__debug_regs->ibar[3] = addr;\r\nasm volatile("movgs %0,ibar3" : : "r"(addr));\r\nreturn 0;\r\n}\r\nreturn -ENOSPC;\r\ncase 2:\r\ncase 3:\r\ncase 4:\r\nif ((addr & ~7) != ((addr + len - 1) & ~7))\r\nreturn -EINVAL;\r\ntmp = addr & 7;\r\nmemset(dbmr.bytes, 0xff, sizeof(dbmr.bytes));\r\nfor (loop = 0; loop < len; loop++)\r\ndbmr.bytes[tmp + loop] = 0;\r\naddr &= ~7;\r\nif (!(__debug_regs->dcr & (DCR_DRBE0|DCR_DWBE0))) {\r\ntmp = type==2 ? DCR_DWBE0 : type==3 ? DCR_DRBE0 : DCR_DRBE0|DCR_DWBE0;\r\n__debug_regs->dcr |= tmp;\r\n__debug_regs->dbar[0] = addr;\r\n__debug_regs->dbmr[0][0] = dbmr.mask0;\r\n__debug_regs->dbmr[0][1] = dbmr.mask1;\r\n__debug_regs->dbdr[0][0] = 0;\r\n__debug_regs->dbdr[0][1] = 0;\r\nasm volatile(" movgs %0,dbar0 \n"\r\n" movgs %1,dbmr00 \n"\r\n" movgs %2,dbmr01 \n"\r\n" movgs gr0,dbdr00 \n"\r\n" movgs gr0,dbdr01 \n"\r\n: : "r"(addr), "r"(dbmr.mask0), "r"(dbmr.mask1));\r\nreturn 0;\r\n}\r\nif (!(__debug_regs->dcr & (DCR_DRBE1|DCR_DWBE1))) {\r\ntmp = type==2 ? DCR_DWBE1 : type==3 ? DCR_DRBE1 : DCR_DRBE1|DCR_DWBE1;\r\n__debug_regs->dcr |= tmp;\r\n__debug_regs->dbar[1] = addr;\r\n__debug_regs->dbmr[1][0] = dbmr.mask0;\r\n__debug_regs->dbmr[1][1] = dbmr.mask1;\r\n__debug_regs->dbdr[1][0] = 0;\r\n__debug_regs->dbdr[1][1] = 0;\r\nasm volatile(" movgs %0,dbar1 \n"\r\n" movgs %1,dbmr10 \n"\r\n" movgs %2,dbmr11 \n"\r\n" movgs gr0,dbdr10 \n"\r\n" movgs gr0,dbdr11 \n"\r\n: : "r"(addr), "r"(dbmr.mask0), "r"(dbmr.mask1));\r\nreturn 0;\r\n}\r\nreturn -ENOSPC;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nint gdbstub_clear_breakpoint(unsigned long type, unsigned long addr, unsigned long len)\r\n{\r\nunsigned long tmp;\r\nint bkpt, loop;\r\nunion {\r\nstruct {\r\nunsigned long mask0, mask1;\r\n};\r\nuint8_t bytes[8];\r\n} dbmr;\r\nswitch (type) {\r\ncase 0:\r\nfor (bkpt = 255; bkpt >= 0; bkpt--)\r\nif (gdbstub_bkpts[bkpt].addr == addr && gdbstub_bkpts[bkpt].len == len)\r\nbreak;\r\nif (bkpt < 0)\r\nreturn -ENOENT;\r\ngdbstub_bkpts[bkpt].addr = 0;\r\nfor (loop = 0; loop < len/4; loop++)\r\nif (!gdbstub_write_dword(&((uint32_t *) addr)[loop],\r\ngdbstub_bkpts[bkpt].originsns[loop]))\r\nreturn -EFAULT;\r\nreturn 0;\r\ncase 1:\r\nif (addr & 3 || len != 4)\r\nreturn -EINVAL;\r\n#define __get_ibar(X) ({ unsigned long x; asm volatile("movsg ibar"#X",%0" : "=r"(x)); x; })\r\nif (__debug_regs->dcr & DCR_IBE0 && __get_ibar(0) == addr) {\r\n__debug_regs->dcr &= ~DCR_IBE0;\r\n__debug_regs->ibar[0] = 0;\r\nasm volatile("movgs gr0,ibar0");\r\nreturn 0;\r\n}\r\nif (__debug_regs->dcr & DCR_IBE1 && __get_ibar(1) == addr) {\r\n__debug_regs->dcr &= ~DCR_IBE1;\r\n__debug_regs->ibar[1] = 0;\r\nasm volatile("movgs gr0,ibar1");\r\nreturn 0;\r\n}\r\nif (__debug_regs->dcr & DCR_IBE2 && __get_ibar(2) == addr) {\r\n__debug_regs->dcr &= ~DCR_IBE2;\r\n__debug_regs->ibar[2] = 0;\r\nasm volatile("movgs gr0,ibar2");\r\nreturn 0;\r\n}\r\nif (__debug_regs->dcr & DCR_IBE3 && __get_ibar(3) == addr) {\r\n__debug_regs->dcr &= ~DCR_IBE3;\r\n__debug_regs->ibar[3] = 0;\r\nasm volatile("movgs gr0,ibar3");\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\ncase 2:\r\ncase 3:\r\ncase 4:\r\nif ((addr & ~7) != ((addr + len - 1) & ~7))\r\nreturn -EINVAL;\r\ntmp = addr & 7;\r\nmemset(dbmr.bytes, 0xff, sizeof(dbmr.bytes));\r\nfor (loop = 0; loop < len; loop++)\r\ndbmr.bytes[tmp + loop] = 0;\r\naddr &= ~7;\r\n#define __get_dbar(X) ({ unsigned long x; asm volatile("movsg dbar"#X",%0" : "=r"(x)); x; })\r\n#define __get_dbmr0(X) ({ unsigned long x; asm volatile("movsg dbmr"#X"0,%0" : "=r"(x)); x; })\r\n#define __get_dbmr1(X) ({ unsigned long x; asm volatile("movsg dbmr"#X"1,%0" : "=r"(x)); x; })\r\ntmp = type==2 ? DCR_DWBE0 : type==3 ? DCR_DRBE0 : DCR_DRBE0|DCR_DWBE0;\r\nif ((__debug_regs->dcr & (DCR_DRBE0|DCR_DWBE0)) != tmp ||\r\n__get_dbar(0) != addr ||\r\n__get_dbmr0(0) != dbmr.mask0 ||\r\n__get_dbmr1(0) != dbmr.mask1)\r\ngoto skip_dbar0;\r\n__debug_regs->dcr &= ~(DCR_DRBE0|DCR_DWBE0);\r\n__debug_regs->dbar[0] = 0;\r\n__debug_regs->dbmr[0][0] = 0;\r\n__debug_regs->dbmr[0][1] = 0;\r\n__debug_regs->dbdr[0][0] = 0;\r\n__debug_regs->dbdr[0][1] = 0;\r\nasm volatile(" movgs gr0,dbar0 \n"\r\n" movgs gr0,dbmr00 \n"\r\n" movgs gr0,dbmr01 \n"\r\n" movgs gr0,dbdr00 \n"\r\n" movgs gr0,dbdr01 \n");\r\nreturn 0;\r\nskip_dbar0:\r\ntmp = type==2 ? DCR_DWBE1 : type==3 ? DCR_DRBE1 : DCR_DRBE1|DCR_DWBE1;\r\nif ((__debug_regs->dcr & (DCR_DRBE1|DCR_DWBE1)) != tmp ||\r\n__get_dbar(1) != addr ||\r\n__get_dbmr0(1) != dbmr.mask0 ||\r\n__get_dbmr1(1) != dbmr.mask1)\r\ngoto skip_dbar1;\r\n__debug_regs->dcr &= ~(DCR_DRBE1|DCR_DWBE1);\r\n__debug_regs->dbar[1] = 0;\r\n__debug_regs->dbmr[1][0] = 0;\r\n__debug_regs->dbmr[1][1] = 0;\r\n__debug_regs->dbdr[1][0] = 0;\r\n__debug_regs->dbdr[1][1] = 0;\r\nasm volatile(" movgs gr0,dbar1 \n"\r\n" movgs gr0,dbmr10 \n"\r\n" movgs gr0,dbmr11 \n"\r\n" movgs gr0,dbdr10 \n"\r\n" movgs gr0,dbdr11 \n");\r\nreturn 0;\r\nskip_dbar1:\r\nreturn -ENOSPC;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic void gdbstub_check_breakpoint(void)\r\n{\r\nunsigned long addr = __debug_frame->pc - 4;\r\nint bkpt;\r\nfor (bkpt = 255; bkpt >= 0; bkpt--)\r\nif (gdbstub_bkpts[bkpt].addr == addr)\r\nbreak;\r\nif (bkpt >= 0)\r\n__debug_frame->pc = addr;\r\n}\r\nstatic void __maybe_unused gdbstub_show_regs(void)\r\n{\r\nunsigned long *reg;\r\nint loop;\r\ngdbstub_printk("\n");\r\ngdbstub_printk("Frame: @%p [%s]\n",\r\n__debug_frame,\r\n__debug_frame->psr & PSR_S ? "kernel" : "user");\r\nreg = (unsigned long *) __debug_frame;\r\nfor (loop = 0; loop < NR_PT_REGS; loop++) {\r\nprintk("%s %08lx", regnames[loop + 0], reg[loop + 0]);\r\nif (loop == NR_PT_REGS - 1 || loop % 5 == 4)\r\nprintk("\n");\r\nelse\r\nprintk(" | ");\r\n}\r\ngdbstub_printk("Process %s (pid: %d)\n", current->comm, current->pid);\r\n}\r\nstatic void __maybe_unused gdbstub_dump_debugregs(void)\r\n{\r\ngdbstub_printk("DCR %08lx ", __debug_status.dcr);\r\ngdbstub_printk("BRR %08lx\n", __debug_status.brr);\r\ngdbstub_printk("IBAR0 %08lx ", __get_ibar(0));\r\ngdbstub_printk("IBAR1 %08lx ", __get_ibar(1));\r\ngdbstub_printk("IBAR2 %08lx ", __get_ibar(2));\r\ngdbstub_printk("IBAR3 %08lx\n", __get_ibar(3));\r\ngdbstub_printk("DBAR0 %08lx ", __get_dbar(0));\r\ngdbstub_printk("DBMR00 %08lx ", __get_dbmr0(0));\r\ngdbstub_printk("DBMR01 %08lx\n", __get_dbmr1(0));\r\ngdbstub_printk("DBAR1 %08lx ", __get_dbar(1));\r\ngdbstub_printk("DBMR10 %08lx ", __get_dbmr0(1));\r\ngdbstub_printk("DBMR11 %08lx\n", __get_dbmr1(1));\r\ngdbstub_printk("\n");\r\n}\r\nvoid gdbstub_get_mmu_state(void)\r\n{\r\nasm volatile("movsg hsr0,%0" : "=r"(__debug_mmu.regs.hsr0));\r\nasm volatile("movsg pcsr,%0" : "=r"(__debug_mmu.regs.pcsr));\r\nasm volatile("movsg esr0,%0" : "=r"(__debug_mmu.regs.esr0));\r\nasm volatile("movsg ear0,%0" : "=r"(__debug_mmu.regs.ear0));\r\nasm volatile("movsg epcr0,%0" : "=r"(__debug_mmu.regs.epcr0));\r\n__debug_mmu.iamr[0].L = __get_IAMLR(0);\r\n__debug_mmu.iamr[0].P = __get_IAMPR(0);\r\n__debug_mmu.iamr[1].L = __get_IAMLR(1);\r\n__debug_mmu.iamr[1].P = __get_IAMPR(1);\r\n__debug_mmu.iamr[2].L = __get_IAMLR(2);\r\n__debug_mmu.iamr[2].P = __get_IAMPR(2);\r\n__debug_mmu.iamr[3].L = __get_IAMLR(3);\r\n__debug_mmu.iamr[3].P = __get_IAMPR(3);\r\n__debug_mmu.iamr[4].L = __get_IAMLR(4);\r\n__debug_mmu.iamr[4].P = __get_IAMPR(4);\r\n__debug_mmu.iamr[5].L = __get_IAMLR(5);\r\n__debug_mmu.iamr[5].P = __get_IAMPR(5);\r\n__debug_mmu.iamr[6].L = __get_IAMLR(6);\r\n__debug_mmu.iamr[6].P = __get_IAMPR(6);\r\n__debug_mmu.iamr[7].L = __get_IAMLR(7);\r\n__debug_mmu.iamr[7].P = __get_IAMPR(7);\r\n__debug_mmu.iamr[8].L = __get_IAMLR(8);\r\n__debug_mmu.iamr[8].P = __get_IAMPR(8);\r\n__debug_mmu.iamr[9].L = __get_IAMLR(9);\r\n__debug_mmu.iamr[9].P = __get_IAMPR(9);\r\n__debug_mmu.iamr[10].L = __get_IAMLR(10);\r\n__debug_mmu.iamr[10].P = __get_IAMPR(10);\r\n__debug_mmu.iamr[11].L = __get_IAMLR(11);\r\n__debug_mmu.iamr[11].P = __get_IAMPR(11);\r\n__debug_mmu.iamr[12].L = __get_IAMLR(12);\r\n__debug_mmu.iamr[12].P = __get_IAMPR(12);\r\n__debug_mmu.iamr[13].L = __get_IAMLR(13);\r\n__debug_mmu.iamr[13].P = __get_IAMPR(13);\r\n__debug_mmu.iamr[14].L = __get_IAMLR(14);\r\n__debug_mmu.iamr[14].P = __get_IAMPR(14);\r\n__debug_mmu.iamr[15].L = __get_IAMLR(15);\r\n__debug_mmu.iamr[15].P = __get_IAMPR(15);\r\n__debug_mmu.damr[0].L = __get_DAMLR(0);\r\n__debug_mmu.damr[0].P = __get_DAMPR(0);\r\n__debug_mmu.damr[1].L = __get_DAMLR(1);\r\n__debug_mmu.damr[1].P = __get_DAMPR(1);\r\n__debug_mmu.damr[2].L = __get_DAMLR(2);\r\n__debug_mmu.damr[2].P = __get_DAMPR(2);\r\n__debug_mmu.damr[3].L = __get_DAMLR(3);\r\n__debug_mmu.damr[3].P = __get_DAMPR(3);\r\n__debug_mmu.damr[4].L = __get_DAMLR(4);\r\n__debug_mmu.damr[4].P = __get_DAMPR(4);\r\n__debug_mmu.damr[5].L = __get_DAMLR(5);\r\n__debug_mmu.damr[5].P = __get_DAMPR(5);\r\n__debug_mmu.damr[6].L = __get_DAMLR(6);\r\n__debug_mmu.damr[6].P = __get_DAMPR(6);\r\n__debug_mmu.damr[7].L = __get_DAMLR(7);\r\n__debug_mmu.damr[7].P = __get_DAMPR(7);\r\n__debug_mmu.damr[8].L = __get_DAMLR(8);\r\n__debug_mmu.damr[8].P = __get_DAMPR(8);\r\n__debug_mmu.damr[9].L = __get_DAMLR(9);\r\n__debug_mmu.damr[9].P = __get_DAMPR(9);\r\n__debug_mmu.damr[10].L = __get_DAMLR(10);\r\n__debug_mmu.damr[10].P = __get_DAMPR(10);\r\n__debug_mmu.damr[11].L = __get_DAMLR(11);\r\n__debug_mmu.damr[11].P = __get_DAMPR(11);\r\n__debug_mmu.damr[12].L = __get_DAMLR(12);\r\n__debug_mmu.damr[12].P = __get_DAMPR(12);\r\n__debug_mmu.damr[13].L = __get_DAMLR(13);\r\n__debug_mmu.damr[13].P = __get_DAMPR(13);\r\n__debug_mmu.damr[14].L = __get_DAMLR(14);\r\n__debug_mmu.damr[14].P = __get_DAMPR(14);\r\n__debug_mmu.damr[15].L = __get_DAMLR(15);\r\n__debug_mmu.damr[15].P = __get_DAMPR(15);\r\n#ifdef CONFIG_MMU\r\ndo {\r\nstruct __debug_amr *p;\r\nint loop;\r\nasm volatile("movsg tplr,%0" : "=r"(__debug_mmu.regs.tplr));\r\nasm volatile("movsg tppr,%0" : "=r"(__debug_mmu.regs.tppr));\r\nasm volatile("movsg tpxr,%0" : "=r"(__debug_mmu.regs.tpxr));\r\nasm volatile("movsg cxnr,%0" : "=r"(__debug_mmu.regs.cxnr));\r\np = __debug_mmu.tlb;\r\nasm volatile("movgs %0,tpxr" :: "r"(0 << TPXR_WAY_SHIFT));\r\nfor (loop = 0; loop < 64; loop++) {\r\nasm volatile("tlbpr %0,gr0,#1,#0" :: "r"(loop << PAGE_SHIFT));\r\nasm volatile("movsg tplr,%0" : "=r"(p->L));\r\nasm volatile("movsg tppr,%0" : "=r"(p->P));\r\np++;\r\n}\r\nasm volatile("movgs %0,tpxr" :: "r"(1 << TPXR_WAY_SHIFT));\r\nfor (loop = 0; loop < 64; loop++) {\r\nasm volatile("tlbpr %0,gr0,#1,#0" :: "r"(loop << PAGE_SHIFT));\r\nasm volatile("movsg tplr,%0" : "=r"(p->L));\r\nasm volatile("movsg tppr,%0" : "=r"(p->P));\r\np++;\r\n}\r\nasm volatile("movgs %0,tplr" :: "r"(__debug_mmu.regs.tplr));\r\nasm volatile("movgs %0,tppr" :: "r"(__debug_mmu.regs.tppr));\r\nasm volatile("movgs %0,tpxr" :: "r"(__debug_mmu.regs.tpxr));\r\n} while(0);\r\n#endif\r\n}\r\nstatic void gdbstub_handle_query(void)\r\n{\r\nif (strcmp(input_buffer, "qAttached") == 0) {\r\nsprintf(output_buffer, "1");\r\nreturn;\r\n}\r\nif (strcmp(input_buffer, "qC") == 0) {\r\nsprintf(output_buffer, "QC 0");\r\nreturn;\r\n}\r\nif (strcmp(input_buffer, "qOffsets") == 0) {\r\nsprintf(output_buffer, "Text=0;Data=0;Bss=0");\r\nreturn;\r\n}\r\nif (strcmp(input_buffer, "qSymbol::") == 0) {\r\nsprintf(output_buffer, "OK");\r\nreturn;\r\n}\r\nif (strcmp(input_buffer, "qSupported") == 0) {\r\nsprintf(output_buffer, "PacketSize=%u;ReverseContinue-;ReverseStep-",\r\nsizeof(input_buffer));\r\nreturn;\r\n}\r\ngdbstub_strcpy(output_buffer,"E01");\r\n}\r\nvoid gdbstub(int sigval)\r\n{\r\nunsigned long addr, length, loop, dbar, temp, temp2, temp3;\r\nuint32_t zero;\r\nchar *ptr;\r\nint flush_cache = 0;\r\nLEDS(0x5000);\r\nif (sigval < 0) {\r\n#ifndef CONFIG_GDBSTUB_IMMEDIATE\r\nreturn;\r\n#else\r\nsigval = SIGINT;\r\n#endif\r\n}\r\nsave_user_regs(&__debug_frame0->uc);\r\n#if 0\r\ngdbstub_printk("--> gdbstub() %08x %p %08x %08x\n",\r\n__debug_frame->pc,\r\n__debug_frame,\r\n__debug_regs->brr,\r\n__debug_regs->bpsr);\r\n#endif\r\nLEDS(0x5001);\r\ntemp = (unsigned long) __entry_kerneltrap_table;\r\ntemp2 = (unsigned long) __entry_usertrap_table;\r\ntemp3 = __debug_frame->pc & ~15;\r\nif (temp3 == temp + TBR_TT_INTERRUPT_15 ||\r\ntemp3 == temp2 + TBR_TT_INTERRUPT_15\r\n) {\r\nasm volatile("movsg pcsr,%0" : "=r"(__debug_frame->pc));\r\n__debug_frame->psr |= PSR_ET;\r\n__debug_frame->psr &= ~PSR_S;\r\nif (__debug_frame->psr & PSR_PS)\r\n__debug_frame->psr |= PSR_S;\r\n__debug_status.brr = (__debug_frame->tbr & TBR_TT) << 12;\r\n__debug_status.brr |= BRR_EB;\r\nsigval = SIGINT;\r\n}\r\nif (temp3 == temp + TBR_TT_DECREMENT_TIMER ||\r\ntemp3 == temp2 + TBR_TT_DECREMENT_TIMER\r\n) {\r\nasm volatile("movgs %0,timerd" :: "r"(10000000));\r\nasm volatile("movsg pcsr,%0" : "=r"(__debug_frame->pc));\r\n__debug_frame->psr |= PSR_ET;\r\n__debug_frame->psr &= ~PSR_S;\r\nif (__debug_frame->psr & PSR_PS)\r\n__debug_frame->psr |= PSR_S;\r\n__debug_status.brr = (__debug_frame->tbr & TBR_TT) << 12;\r\n__debug_status.brr |= BRR_EB;\r\nsigval = SIGXCPU;\r\n}\r\nLEDS(0x5002);\r\nif (__debug_status.brr & BRR_SB)\r\ngdbstub_check_breakpoint();\r\nLEDS(0x5003);\r\nif (__debug_frame->pc == (unsigned long) gdbstub_console_write + 4) {\r\n__gdbstub_console_write((struct console *) __debug_frame->gr8,\r\n(const char *) __debug_frame->gr9,\r\n(unsigned) __debug_frame->gr10);\r\ngoto done;\r\n}\r\nif (gdbstub_rx_unget) {\r\nsigval = SIGINT;\r\ngoto packet_waiting;\r\n}\r\nif (!sigval)\r\nsigval = gdbstub_compute_signal(__debug_status.brr);\r\nLEDS(0x5004);\r\nif (sigval != SIGINT && sigval != SIGTRAP && sigval != SIGILL) {\r\nstatic const char title[] = "Break ";\r\nstatic const char crlf[] = "\r\n";\r\nunsigned long brr = __debug_status.brr;\r\nchar hx;\r\nptr = output_buffer;\r\n*ptr++ = 'O';\r\nptr = mem2hex(title, ptr, sizeof(title) - 1,0);\r\nhx = hex_asc_hi(brr >> 24);\r\nptr = hex_byte_pack(ptr, hx);\r\nhx = hex_asc_lo(brr >> 24);\r\nptr = hex_byte_pack(ptr, hx);\r\nhx = hex_asc_hi(brr >> 16);\r\nptr = hex_byte_pack(ptr, hx);\r\nhx = hex_asc_lo(brr >> 16);\r\nptr = hex_byte_pack(ptr, hx);\r\nhx = hex_asc_hi(brr >> 8);\r\nptr = hex_byte_pack(ptr, hx);\r\nhx = hex_asc_lo(brr >> 8);\r\nptr = hex_byte_pack(ptr, hx);\r\nhx = hex_asc_hi(brr);\r\nptr = hex_byte_pack(ptr, hx);\r\nhx = hex_asc_lo(brr);\r\nptr = hex_byte_pack(ptr, hx);\r\nptr = mem2hex(crlf, ptr, sizeof(crlf) - 1, 0);\r\n*ptr = 0;\r\ngdbstub_send_packet(output_buffer);\r\n}\r\nLEDS(0x5005);\r\nptr = output_buffer;\r\n*ptr++ = 'T';\r\nptr = hex_byte_pack(ptr, sigval);\r\nptr = hex_byte_pack(ptr, GDB_REG_PC);\r\n*ptr++ = ':';\r\nptr = mem2hex(&__debug_frame->pc, ptr, 4, 0);\r\n*ptr++ = ';';\r\nptr = hex_byte_pack(ptr, GDB_REG_FP);\r\n*ptr++ = ':';\r\nptr = mem2hex(&__debug_frame->fp, ptr, 4, 0);\r\n*ptr++ = ';';\r\nptr = hex_byte_pack(ptr, GDB_REG_SP);\r\n*ptr++ = ':';\r\nptr = mem2hex(&__debug_frame->sp, ptr, 4, 0);\r\n*ptr++ = ';';\r\n*ptr++ = 0;\r\ngdbstub_send_packet(output_buffer);\r\nLEDS(0x5006);\r\npacket_waiting:\r\ngdbstub_get_mmu_state();\r\nwhile (1) {\r\noutput_buffer[0] = 0;\r\nLEDS(0x5007);\r\ngdbstub_recv_packet(input_buffer);\r\nLEDS(0x5600 | input_buffer[0]);\r\nswitch (input_buffer[0]) {\r\ncase '?':\r\noutput_buffer[0] = 'S';\r\noutput_buffer[1] = hex_asc_hi(sigval);\r\noutput_buffer[2] = hex_asc_lo(sigval);\r\noutput_buffer[3] = 0;\r\nbreak;\r\ncase 'd':\r\nbreak;\r\ncase 'g':\r\nzero = 0;\r\nptr = output_buffer;\r\nptr = mem2hex(&zero, ptr, 4, 0);\r\nfor (loop = 1; loop <= 27; loop++)\r\nptr = mem2hex(&__debug_user_context->i.gr[loop], ptr, 4, 0);\r\ntemp = (unsigned long) __frame;\r\nptr = mem2hex(&temp, ptr, 4, 0);\r\nptr = mem2hex(&__debug_user_context->i.gr[29], ptr, 4, 0);\r\nptr = mem2hex(&__debug_user_context->i.gr[30], ptr, 4, 0);\r\n#ifdef CONFIG_MMU\r\nptr = mem2hex(&__debug_user_context->i.gr[31], ptr, 4, 0);\r\n#else\r\ntemp = (unsigned long) __debug_frame;\r\nptr = mem2hex(&temp, ptr, 4, 0);\r\n#endif\r\nfor (loop = 32; loop <= 63; loop++)\r\nptr = mem2hex(&__debug_user_context->i.gr[loop], ptr, 4, 0);\r\nfor (loop = 0; loop <= 63; loop++)\r\nptr = mem2hex(&__debug_user_context->f.fr[loop], ptr, 4, 0);\r\nptr = mem2hex(&__debug_frame->pc, ptr, 4, 0);\r\nptr = mem2hex(&__debug_frame->psr, ptr, 4, 0);\r\nptr = mem2hex(&__debug_frame->ccr, ptr, 4, 0);\r\nptr = mem2hex(&__debug_frame->cccr, ptr, 4, 0);\r\nptr = mem2hex(&zero, ptr, 4, 0);\r\nptr = mem2hex(&zero, ptr, 4, 0);\r\nptr = mem2hex(&zero, ptr, 4, 0);\r\nptr = mem2hex(&__debug_frame->tbr, ptr, 4, 0);\r\nptr = mem2hex(&__debug_status.brr , ptr, 4, 0);\r\nasm volatile("movsg dbar0,%0" : "=r"(dbar));\r\nptr = mem2hex(&dbar, ptr, 4, 0);\r\nasm volatile("movsg dbar1,%0" : "=r"(dbar));\r\nptr = mem2hex(&dbar, ptr, 4, 0);\r\nasm volatile("movsg dbar2,%0" : "=r"(dbar));\r\nptr = mem2hex(&dbar, ptr, 4, 0);\r\nasm volatile("movsg dbar3,%0" : "=r"(dbar));\r\nptr = mem2hex(&dbar, ptr, 4, 0);\r\nasm volatile("movsg scr0,%0" : "=r"(dbar));\r\nptr = mem2hex(&dbar, ptr, 4, 0);\r\nasm volatile("movsg scr1,%0" : "=r"(dbar));\r\nptr = mem2hex(&dbar, ptr, 4, 0);\r\nasm volatile("movsg scr2,%0" : "=r"(dbar));\r\nptr = mem2hex(&dbar, ptr, 4, 0);\r\nasm volatile("movsg scr3,%0" : "=r"(dbar));\r\nptr = mem2hex(&dbar, ptr, 4, 0);\r\nptr = mem2hex(&__debug_frame->lr, ptr, 4, 0);\r\nptr = mem2hex(&__debug_frame->lcr, ptr, 4, 0);\r\nptr = mem2hex(&__debug_frame->iacc0, ptr, 8, 0);\r\nptr = mem2hex(&__debug_user_context->f.fsr[0], ptr, 4, 0);\r\nfor (loop = 0; loop <= 7; loop++)\r\nptr = mem2hex(&__debug_user_context->f.acc[loop], ptr, 4, 0);\r\nptr = mem2hex(&__debug_user_context->f.accg, ptr, 8, 0);\r\nfor (loop = 0; loop <= 1; loop++)\r\nptr = mem2hex(&__debug_user_context->f.msr[loop], ptr, 4, 0);\r\nptr = mem2hex(&__debug_frame->gner0, ptr, 4, 0);\r\nptr = mem2hex(&__debug_frame->gner1, ptr, 4, 0);\r\nptr = mem2hex(&__debug_user_context->f.fner[0], ptr, 4, 0);\r\nptr = mem2hex(&__debug_user_context->f.fner[1], ptr, 4, 0);\r\nbreak;\r\ncase 'G':\r\nptr = &input_buffer[1];\r\nptr = hex2mem(ptr, &temp, 4);\r\nfor (loop = 1; loop <= 27; loop++)\r\nptr = hex2mem(ptr, &__debug_user_context->i.gr[loop], 4);\r\nptr = hex2mem(ptr, &temp, 4);\r\n__frame = (struct pt_regs *) temp;\r\nptr = hex2mem(ptr, &__debug_frame->gr29, 4);\r\nptr = hex2mem(ptr, &__debug_frame->gr30, 4);\r\n#ifdef CONFIG_MMU\r\nptr = hex2mem(ptr, &__debug_frame->gr31, 4);\r\n#else\r\nptr = hex2mem(ptr, &temp, 4);\r\n#endif\r\nfor (loop = 32; loop <= 63; loop++)\r\nptr = hex2mem(ptr, &__debug_user_context->i.gr[loop], 4);\r\nfor (loop = 0; loop <= 63; loop++)\r\nptr = mem2hex(&__debug_user_context->f.fr[loop], ptr, 4, 0);\r\nptr = hex2mem(ptr, &__debug_frame->pc, 4);\r\nptr = hex2mem(ptr, &__debug_frame->psr, 4);\r\nptr = hex2mem(ptr, &__debug_frame->ccr, 4);\r\nptr = hex2mem(ptr, &__debug_frame->cccr,4);\r\nfor (loop = 132; loop <= 140; loop++)\r\nptr = hex2mem(ptr, &temp, 4);\r\nptr = hex2mem(ptr, &temp, 4);\r\nasm volatile("movgs %0,scr0" :: "r"(temp));\r\nptr = hex2mem(ptr, &temp, 4);\r\nasm volatile("movgs %0,scr1" :: "r"(temp));\r\nptr = hex2mem(ptr, &temp, 4);\r\nasm volatile("movgs %0,scr2" :: "r"(temp));\r\nptr = hex2mem(ptr, &temp, 4);\r\nasm volatile("movgs %0,scr3" :: "r"(temp));\r\nptr = hex2mem(ptr, &__debug_frame->lr, 4);\r\nptr = hex2mem(ptr, &__debug_frame->lcr, 4);\r\nptr = hex2mem(ptr, &__debug_frame->iacc0, 8);\r\nptr = hex2mem(ptr, &__debug_user_context->f.fsr[0], 4);\r\nfor (loop = 0; loop <= 7; loop++)\r\nptr = hex2mem(ptr, &__debug_user_context->f.acc[loop], 4);\r\nptr = hex2mem(ptr, &__debug_user_context->f.accg, 8);\r\nfor (loop = 0; loop <= 1; loop++)\r\nptr = hex2mem(ptr, &__debug_user_context->f.msr[loop], 4);\r\nptr = hex2mem(ptr, &__debug_frame->gner0, 4);\r\nptr = hex2mem(ptr, &__debug_frame->gner1, 4);\r\nptr = hex2mem(ptr, &__debug_user_context->f.fner[0], 4);\r\nptr = hex2mem(ptr, &__debug_user_context->f.fner[1], 4);\r\ngdbstub_strcpy(output_buffer,"OK");\r\nbreak;\r\ncase 'm':\r\nptr = &input_buffer[1];\r\nif (hexToInt(&ptr, &addr) &&\r\n*ptr++ == ',' &&\r\nhexToInt(&ptr, &length)\r\n) {\r\nif (mem2hex((char *)addr, output_buffer, length, 1))\r\nbreak;\r\ngdbstub_strcpy (output_buffer, "E03");\r\n}\r\nelse {\r\ngdbstub_strcpy(output_buffer,"E01");\r\n}\r\nbreak;\r\ncase 'M':\r\nptr = &input_buffer[1];\r\nif (hexToInt(&ptr, &addr) &&\r\n*ptr++ == ',' &&\r\nhexToInt(&ptr, &length) &&\r\n*ptr++ == ':'\r\n) {\r\nif (hex2mem(ptr, (char *)addr, length)) {\r\ngdbstub_strcpy(output_buffer, "OK");\r\n}\r\nelse {\r\ngdbstub_strcpy(output_buffer, "E03");\r\n}\r\n}\r\nelse\r\ngdbstub_strcpy(output_buffer, "E02");\r\nflush_cache = 1;\r\nbreak;\r\ncase 'p':\r\nbreak;\r\ncase 'P':\r\nptr = &input_buffer[1];\r\nif (!hexToInt(&ptr, &addr) ||\r\n*ptr++ != '=' ||\r\n!hexToInt(&ptr, &temp)\r\n) {\r\ngdbstub_strcpy(output_buffer, "E01");\r\nbreak;\r\n}\r\ntemp2 = 1;\r\nswitch (addr) {\r\ncase GDB_REG_GR(0):\r\nbreak;\r\ncase GDB_REG_GR(1) ... GDB_REG_GR(63):\r\n__debug_user_context->i.gr[addr - GDB_REG_GR(0)] = temp;\r\nbreak;\r\ncase GDB_REG_FR(0) ... GDB_REG_FR(63):\r\n__debug_user_context->f.fr[addr - GDB_REG_FR(0)] = temp;\r\nbreak;\r\ncase GDB_REG_PC:\r\n__debug_user_context->i.pc = temp;\r\nbreak;\r\ncase GDB_REG_PSR:\r\n__debug_user_context->i.psr = temp;\r\nbreak;\r\ncase GDB_REG_CCR:\r\n__debug_user_context->i.ccr = temp;\r\nbreak;\r\ncase GDB_REG_CCCR:\r\n__debug_user_context->i.cccr = temp;\r\nbreak;\r\ncase GDB_REG_BRR:\r\n__debug_status.brr = temp;\r\nbreak;\r\ncase GDB_REG_LR:\r\n__debug_user_context->i.lr = temp;\r\nbreak;\r\ncase GDB_REG_LCR:\r\n__debug_user_context->i.lcr = temp;\r\nbreak;\r\ncase GDB_REG_FSR0:\r\n__debug_user_context->f.fsr[0] = temp;\r\nbreak;\r\ncase GDB_REG_ACC(0) ... GDB_REG_ACC(7):\r\n__debug_user_context->f.acc[addr - GDB_REG_ACC(0)] = temp;\r\nbreak;\r\ncase GDB_REG_ACCG(0):\r\n*(uint32_t *) &__debug_user_context->f.accg[0] = temp;\r\nbreak;\r\ncase GDB_REG_ACCG(4):\r\n*(uint32_t *) &__debug_user_context->f.accg[4] = temp;\r\nbreak;\r\ncase GDB_REG_MSR(0) ... GDB_REG_MSR(1):\r\n__debug_user_context->f.msr[addr - GDB_REG_MSR(0)] = temp;\r\nbreak;\r\ncase GDB_REG_GNER(0) ... GDB_REG_GNER(1):\r\n__debug_user_context->i.gner[addr - GDB_REG_GNER(0)] = temp;\r\nbreak;\r\ncase GDB_REG_FNER(0) ... GDB_REG_FNER(1):\r\n__debug_user_context->f.fner[addr - GDB_REG_FNER(0)] = temp;\r\nbreak;\r\ndefault:\r\ntemp2 = 0;\r\nbreak;\r\n}\r\nif (temp2) {\r\ngdbstub_strcpy(output_buffer, "OK");\r\n}\r\nelse {\r\ngdbstub_strcpy(output_buffer, "E02");\r\n}\r\nbreak;\r\ncase 'c':\r\nptr = &input_buffer[1];\r\nif (hexToInt(&ptr, &addr))\r\n__debug_frame->pc = addr;\r\ngoto done;\r\ncase 'k' :\r\ngoto done;\r\ncase 'D':\r\ngdbstub_strcpy(output_buffer, "OK");\r\nbreak;\r\ncase 'r':\r\nbreak;\r\ncase 's':\r\n__debug_regs->dcr |= DCR_SE;\r\n__debug_status.dcr |= DCR_SE;\r\ngoto done;\r\ncase 'v':\r\nif (strcmp(input_buffer, "vCont?") == 0) {\r\noutput_buffer[0] = 0;\r\nbreak;\r\n}\r\ngoto unsupported_cmd;\r\ncase 'b':\r\nptr = &input_buffer[1];\r\nif (!hexToInt(&ptr, &temp)) {\r\ngdbstub_strcpy(output_buffer,"B01");\r\nbreak;\r\n}\r\nif (temp) {\r\ngdbstub_send_packet("OK");\r\ngdbstub_set_baud(temp);\r\n}\r\nbreak;\r\ncase 'Z':\r\nptr = &input_buffer[1];\r\nif (!hexToInt(&ptr,&temp) || *ptr++ != ',' ||\r\n!hexToInt(&ptr,&addr) || *ptr++ != ',' ||\r\n!hexToInt(&ptr,&length)\r\n) {\r\ngdbstub_strcpy(output_buffer,"E01");\r\nbreak;\r\n}\r\nif (temp >= 5) {\r\ngdbstub_strcpy(output_buffer,"E03");\r\nbreak;\r\n}\r\nif (gdbstub_set_breakpoint(temp, addr, length) < 0) {\r\ngdbstub_strcpy(output_buffer,"E03");\r\nbreak;\r\n}\r\nif (temp == 0)\r\nflush_cache = 1;\r\ngdbstub_strcpy(output_buffer,"OK");\r\nbreak;\r\ncase 'z':\r\nptr = &input_buffer[1];\r\nif (!hexToInt(&ptr,&temp) || *ptr++ != ',' ||\r\n!hexToInt(&ptr,&addr) || *ptr++ != ',' ||\r\n!hexToInt(&ptr,&length)\r\n) {\r\ngdbstub_strcpy(output_buffer,"E01");\r\nbreak;\r\n}\r\nif (temp >= 5) {\r\ngdbstub_strcpy(output_buffer,"E03");\r\nbreak;\r\n}\r\nif (gdbstub_clear_breakpoint(temp, addr, length) < 0) {\r\ngdbstub_strcpy(output_buffer,"E03");\r\nbreak;\r\n}\r\nif (temp == 0)\r\nflush_cache = 1;\r\ngdbstub_strcpy(output_buffer,"OK");\r\nbreak;\r\ncase 'H':\r\ngdbstub_strcpy(output_buffer, "OK");\r\nbreak;\r\ncase 'q':\r\ngdbstub_handle_query();\r\nbreak;\r\ndefault:\r\nunsupported_cmd:\r\ngdbstub_proto("### GDB Unsupported Cmd '%s'\n",input_buffer);\r\ngdbstub_strcpy(output_buffer,"E01");\r\nbreak;\r\n}\r\nLEDS(0x5009);\r\ngdbstub_send_packet(output_buffer);\r\n}\r\ndone:\r\nrestore_user_regs(&__debug_frame0->uc);\r\nif (flush_cache)\r\ngdbstub_purge_cache();\r\nLEDS(0x5666);\r\n}\r\nvoid __init gdbstub_init(void)\r\n{\r\n#ifdef CONFIG_GDBSTUB_IMMEDIATE\r\nunsigned char ch;\r\nint ret;\r\n#endif\r\ngdbstub_printk("%s", gdbstub_banner);\r\ngdbstub_io_init();\r\ngdbstub_proto("### GDB Tx ACK\n");\r\ngdbstub_tx_char('+');\r\n#ifdef CONFIG_GDBSTUB_IMMEDIATE\r\ngdbstub_printk("GDB Stub waiting for packet\n");\r\ndo { gdbstub_rx_char(&ch, 0); } while (ch != '$');\r\ndo { gdbstub_rx_char(&ch, 0); } while (ch != '#');\r\ndo { ret = gdbstub_rx_char(&ch, 0); } while (ret != 0);\r\ndo { ret = gdbstub_rx_char(&ch, 0); } while (ret != 0);\r\ngdbstub_proto("### GDB Tx NAK\n");\r\ngdbstub_tx_char('-');\r\n#else\r\ngdbstub_printk("GDB Stub set\n");\r\n#endif\r\n#if 0\r\nptr = output_buffer;\r\n*ptr++ = 'O';\r\nptr = mem2hex(gdbstub_banner, ptr, sizeof(gdbstub_banner) - 1, 0);\r\ngdbstub_send_packet(output_buffer);\r\n#endif\r\n#if defined(CONFIG_GDB_CONSOLE) && defined(CONFIG_GDBSTUB_IMMEDIATE)\r\nregister_console(&gdbstub_console);\r\n#endif\r\n}\r\nstatic int __init gdbstub_postinit(void)\r\n{\r\nprintk("registering console\n");\r\nregister_console(&gdbstub_console);\r\nreturn 0;\r\n}\r\nvoid gdbstub_exit(int status)\r\n{\r\nunsigned char checksum;\r\nint count;\r\nunsigned char ch;\r\nsprintf(output_buffer,"W%02x",status&0xff);\r\ngdbstub_tx_char('$');\r\nchecksum = 0;\r\ncount = 0;\r\nwhile ((ch = output_buffer[count]) != 0) {\r\ngdbstub_tx_char(ch);\r\nchecksum += ch;\r\ncount += 1;\r\n}\r\ngdbstub_tx_char('#');\r\ngdbstub_tx_char(hex_asc_hi(checksum));\r\ngdbstub_tx_char(hex_asc_lo(checksum));\r\ngdbstub_tx_char('-');\r\ngdbstub_tx_flush();\r\n}\r\nstatic void *malloc(size_t size)\r\n{\r\nreturn kmalloc(size, GFP_ATOMIC);\r\n}\r\nstatic void free(void *p)\r\n{\r\nkfree(p);\r\n}\r\nstatic uint32_t ___get_HSR0(void)\r\n{\r\nreturn __get_HSR(0);\r\n}\r\nstatic uint32_t ___set_HSR0(uint32_t x)\r\n{\r\n__set_HSR(0, x);\r\nreturn __get_HSR(0);\r\n}
