static void dt282x_munge(struct comedi_device *dev, short *buf,\r\nunsigned int nbytes)\r\n{\r\nstruct dt282x_private *devpriv = dev->private;\r\nunsigned int i;\r\nunsigned short mask = (1 << boardtype.adbits) - 1;\r\nunsigned short sign = 1 << (boardtype.adbits - 1);\r\nint n;\r\nif (devpriv->ad_2scomp)\r\nsign = 1 << (boardtype.adbits - 1);\r\nelse\r\nsign = 0;\r\nif (nbytes % 2)\r\ncomedi_error(dev, "bug! odd number of bytes from dma xfer");\r\nn = nbytes / 2;\r\nfor (i = 0; i < n; i++)\r\nbuf[i] = (buf[i] & mask) ^ sign;\r\n}\r\nstatic void dt282x_ao_dma_interrupt(struct comedi_device *dev)\r\n{\r\nstruct dt282x_private *devpriv = dev->private;\r\nvoid *ptr;\r\nint size;\r\nint i;\r\nstruct comedi_subdevice *s = &dev->subdevices[1];\r\noutw(devpriv->supcsr | DT2821_CLRDMADNE, dev->iobase + DT2821_SUPCSR);\r\nif (!s->async->prealloc_buf) {\r\nprintk(KERN_ERR "async->data disappeared. dang!\n");\r\nreturn;\r\n}\r\ni = devpriv->current_dma_index;\r\nptr = devpriv->dma[i].buf;\r\ndisable_dma(devpriv->dma[i].chan);\r\ndevpriv->current_dma_index = 1 - i;\r\nsize = cfc_read_array_from_buffer(s, ptr, devpriv->dma_maxsize);\r\nif (size == 0) {\r\nprintk(KERN_ERR "dt282x: AO underrun\n");\r\ndt282x_ao_cancel(dev, s);\r\ns->async->events |= COMEDI_CB_OVERFLOW;\r\nreturn;\r\n}\r\nprep_ao_dma(dev, i, size);\r\nreturn;\r\n}\r\nstatic void dt282x_ai_dma_interrupt(struct comedi_device *dev)\r\n{\r\nstruct dt282x_private *devpriv = dev->private;\r\nvoid *ptr;\r\nint size;\r\nint i;\r\nint ret;\r\nstruct comedi_subdevice *s = &dev->subdevices[0];\r\noutw(devpriv->supcsr | DT2821_CLRDMADNE, dev->iobase + DT2821_SUPCSR);\r\nif (!s->async->prealloc_buf) {\r\nprintk(KERN_ERR "async->data disappeared. dang!\n");\r\nreturn;\r\n}\r\ni = devpriv->current_dma_index;\r\nptr = devpriv->dma[i].buf;\r\nsize = devpriv->dma[i].size;\r\ndisable_dma(devpriv->dma[i].chan);\r\ndevpriv->current_dma_index = 1 - i;\r\ndt282x_munge(dev, ptr, size);\r\nret = cfc_write_array_to_buffer(s, ptr, size);\r\nif (ret != size) {\r\ndt282x_ai_cancel(dev, s);\r\nreturn;\r\n}\r\ndevpriv->nread -= size / 2;\r\nif (devpriv->nread < 0) {\r\nprintk(KERN_INFO "dt282x: off by one\n");\r\ndevpriv->nread = 0;\r\n}\r\nif (!devpriv->nread) {\r\ndt282x_ai_cancel(dev, s);\r\ns->async->events |= COMEDI_CB_EOA;\r\nreturn;\r\n}\r\n#if 0\r\nif (!devpriv->ntrig) {\r\ndevpriv->supcsr &= ~(DT2821_DDMA);\r\noutw(devpriv->supcsr, dev->iobase + DT2821_SUPCSR);\r\n}\r\n#endif\r\nprep_ai_dma(dev, i, 0);\r\n}\r\nstatic int prep_ai_dma(struct comedi_device *dev, int dma_index, int n)\r\n{\r\nstruct dt282x_private *devpriv = dev->private;\r\nint dma_chan;\r\nunsigned long dma_ptr;\r\nunsigned long flags;\r\nif (!devpriv->ntrig)\r\nreturn 0;\r\nif (n == 0)\r\nn = devpriv->dma_maxsize;\r\nif (n > devpriv->ntrig * 2)\r\nn = devpriv->ntrig * 2;\r\ndevpriv->ntrig -= n / 2;\r\ndevpriv->dma[dma_index].size = n;\r\ndma_chan = devpriv->dma[dma_index].chan;\r\ndma_ptr = virt_to_bus(devpriv->dma[dma_index].buf);\r\nset_dma_mode(dma_chan, DMA_MODE_READ);\r\nflags = claim_dma_lock();\r\nclear_dma_ff(dma_chan);\r\nset_dma_addr(dma_chan, dma_ptr);\r\nset_dma_count(dma_chan, n);\r\nrelease_dma_lock(flags);\r\nenable_dma(dma_chan);\r\nreturn n;\r\n}\r\nstatic int prep_ao_dma(struct comedi_device *dev, int dma_index, int n)\r\n{\r\nstruct dt282x_private *devpriv = dev->private;\r\nint dma_chan;\r\nunsigned long dma_ptr;\r\nunsigned long flags;\r\ndevpriv->dma[dma_index].size = n;\r\ndma_chan = devpriv->dma[dma_index].chan;\r\ndma_ptr = virt_to_bus(devpriv->dma[dma_index].buf);\r\nset_dma_mode(dma_chan, DMA_MODE_WRITE);\r\nflags = claim_dma_lock();\r\nclear_dma_ff(dma_chan);\r\nset_dma_addr(dma_chan, dma_ptr);\r\nset_dma_count(dma_chan, n);\r\nrelease_dma_lock(flags);\r\nenable_dma(dma_chan);\r\nreturn n;\r\n}\r\nstatic irqreturn_t dt282x_interrupt(int irq, void *d)\r\n{\r\nstruct comedi_device *dev = d;\r\nstruct dt282x_private *devpriv = dev->private;\r\nstruct comedi_subdevice *s;\r\nstruct comedi_subdevice *s_ao;\r\nunsigned int supcsr, adcsr, dacsr;\r\nint handled = 0;\r\nif (!dev->attached) {\r\ncomedi_error(dev, "spurious interrupt");\r\nreturn IRQ_HANDLED;\r\n}\r\ns = &dev->subdevices[0];\r\ns_ao = &dev->subdevices[1];\r\nadcsr = inw(dev->iobase + DT2821_ADCSR);\r\ndacsr = inw(dev->iobase + DT2821_DACSR);\r\nsupcsr = inw(dev->iobase + DT2821_SUPCSR);\r\nif (supcsr & DT2821_DMAD) {\r\nif (devpriv->dma_dir == DMA_MODE_READ)\r\ndt282x_ai_dma_interrupt(dev);\r\nelse\r\ndt282x_ao_dma_interrupt(dev);\r\nhandled = 1;\r\n}\r\nif (adcsr & DT2821_ADERR) {\r\nif (devpriv->nread != 0) {\r\ncomedi_error(dev, "A/D error");\r\ndt282x_ai_cancel(dev, s);\r\ns->async->events |= COMEDI_CB_ERROR;\r\n}\r\nhandled = 1;\r\n}\r\nif (dacsr & DT2821_DAERR) {\r\n#if 0\r\nstatic int warn = 5;\r\nif (--warn <= 0) {\r\ndisable_irq(dev->irq);\r\nprintk(KERN_INFO "disabling irq\n");\r\n}\r\n#endif\r\ncomedi_error(dev, "D/A error");\r\ndt282x_ao_cancel(dev, s_ao);\r\ns->async->events |= COMEDI_CB_ERROR;\r\nhandled = 1;\r\n}\r\n#if 0\r\nif (adcsr & DT2821_ADDONE) {\r\nint ret;\r\nshort data;\r\ndata = (short)inw(dev->iobase + DT2821_ADDAT);\r\ndata &= (1 << boardtype.adbits) - 1;\r\nif (devpriv->ad_2scomp)\r\ndata ^= 1 << (boardtype.adbits - 1);\r\nret = comedi_buf_put(s->async, data);\r\nif (ret == 0)\r\ns->async->events |= COMEDI_CB_OVERFLOW;\r\ndevpriv->nread--;\r\nif (!devpriv->nread) {\r\ns->async->events |= COMEDI_CB_EOA;\r\n} else {\r\nif (supcsr & DT2821_SCDN)\r\noutw(devpriv->supcsr | DT2821_STRIG,\r\ndev->iobase + DT2821_SUPCSR);\r\n}\r\nhandled = 1;\r\n}\r\n#endif\r\ncomedi_event(dev, s);\r\nreturn IRQ_RETVAL(handled);\r\n}\r\nstatic void dt282x_load_changain(struct comedi_device *dev, int n,\r\nunsigned int *chanlist)\r\n{\r\nstruct dt282x_private *devpriv = dev->private;\r\nunsigned int i;\r\nunsigned int chan, range;\r\noutw(DT2821_LLE | (n - 1), dev->iobase + DT2821_CHANCSR);\r\nfor (i = 0; i < n; i++) {\r\nchan = CR_CHAN(chanlist[i]);\r\nrange = CR_RANGE(chanlist[i]);\r\noutw(devpriv->adcsr | (range << 4) | chan,\r\ndev->iobase + DT2821_ADCSR);\r\n}\r\noutw(n - 1, dev->iobase + DT2821_CHANCSR);\r\n}\r\nstatic int dt282x_ai_insn_read(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nstruct dt282x_private *devpriv = dev->private;\r\nint i;\r\ndevpriv->adcsr = DT2821_ADCLK;\r\noutw(devpriv->adcsr, dev->iobase + DT2821_ADCSR);\r\ndt282x_load_changain(dev, 1, &insn->chanspec);\r\noutw(devpriv->supcsr | DT2821_PRLD, dev->iobase + DT2821_SUPCSR);\r\nwait_for(!mux_busy(), comedi_error(dev, "timeout\n"); return -ETIME;);\r\nfor (i = 0; i < insn->n; i++) {\r\noutw(devpriv->supcsr | DT2821_STRIG,\r\ndev->iobase + DT2821_SUPCSR);\r\nwait_for(ad_done(), comedi_error(dev, "timeout\n");\r\nreturn -ETIME;);\r\ndata[i] =\r\ninw(dev->iobase +\r\nDT2821_ADDAT) & ((1 << boardtype.adbits) - 1);\r\nif (devpriv->ad_2scomp)\r\ndata[i] ^= (1 << (boardtype.adbits - 1));\r\n}\r\nreturn i;\r\n}\r\nstatic int dt282x_ai_cmdtest(struct comedi_device *dev,\r\nstruct comedi_subdevice *s, struct comedi_cmd *cmd)\r\n{\r\nconst struct dt282x_board *board = comedi_board(dev);\r\nint err = 0;\r\nint tmp;\r\nerr |= cfc_check_trigger_src(&cmd->start_src, TRIG_NOW);\r\nerr |= cfc_check_trigger_src(&cmd->scan_begin_src,\r\nTRIG_FOLLOW | TRIG_EXT);\r\nerr |= cfc_check_trigger_src(&cmd->convert_src, TRIG_TIMER);\r\nerr |= cfc_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);\r\nerr |= cfc_check_trigger_src(&cmd->stop_src, TRIG_COUNT | TRIG_NONE);\r\nif (err)\r\nreturn 1;\r\nerr |= cfc_check_trigger_is_unique(cmd->scan_begin_src);\r\nerr |= cfc_check_trigger_is_unique(cmd->stop_src);\r\nif (err)\r\nreturn 2;\r\nerr |= cfc_check_trigger_arg_is(&cmd->start_arg, 0);\r\nif (cmd->scan_begin_src == TRIG_FOLLOW) {\r\nerr |= cfc_check_trigger_arg_is(&cmd->scan_begin_arg, 0);\r\n} else {\r\nerr |= cfc_check_trigger_arg_is(&cmd->scan_begin_arg, 0);\r\n}\r\nerr |= cfc_check_trigger_arg_min(&cmd->convert_arg, 4000);\r\n#define SLOWEST_TIMER (250*(1<<15)*255)\r\nerr |= cfc_check_trigger_arg_max(&cmd->convert_arg, SLOWEST_TIMER);\r\nerr |= cfc_check_trigger_arg_min(&cmd->convert_arg, board->ai_speed);\r\nerr |= cfc_check_trigger_arg_is(&cmd->scan_end_arg, cmd->chanlist_len);\r\nif (cmd->stop_src == TRIG_COUNT) {\r\n} else {\r\nerr |= cfc_check_trigger_arg_is(&cmd->stop_arg, 0);\r\n}\r\nif (err)\r\nreturn 3;\r\ntmp = cmd->convert_arg;\r\ndt282x_ns_to_timer(&cmd->convert_arg, cmd->flags & TRIG_ROUND_MASK);\r\nif (tmp != cmd->convert_arg)\r\nerr++;\r\nif (err)\r\nreturn 4;\r\nreturn 0;\r\n}\r\nstatic int dt282x_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)\r\n{\r\nconst struct dt282x_board *board = comedi_board(dev);\r\nstruct dt282x_private *devpriv = dev->private;\r\nstruct comedi_cmd *cmd = &s->async->cmd;\r\nint timer;\r\nif (devpriv->usedma == 0) {\r\ncomedi_error(dev,\r\n"driver requires 2 dma channels"\r\n" to execute command");\r\nreturn -EIO;\r\n}\r\ndt282x_disable_dma(dev);\r\nif (cmd->convert_arg < board->ai_speed)\r\ncmd->convert_arg = board->ai_speed;\r\ntimer = dt282x_ns_to_timer(&cmd->convert_arg, TRIG_ROUND_NEAREST);\r\noutw(timer, dev->iobase + DT2821_TMRCTR);\r\nif (cmd->scan_begin_src == TRIG_FOLLOW) {\r\ndevpriv->supcsr = DT2821_ERRINTEN | DT2821_DS0;\r\n} else {\r\ndevpriv->supcsr = DT2821_ERRINTEN | DT2821_DS0 | DT2821_DS1;\r\n}\r\noutw(devpriv->supcsr | DT2821_CLRDMADNE | DT2821_BUFFB | DT2821_ADCINIT,\r\ndev->iobase + DT2821_SUPCSR);\r\ndevpriv->ntrig = cmd->stop_arg * cmd->scan_end_arg;\r\ndevpriv->nread = devpriv->ntrig;\r\ndevpriv->dma_dir = DMA_MODE_READ;\r\ndevpriv->current_dma_index = 0;\r\nprep_ai_dma(dev, 0, 0);\r\nif (devpriv->ntrig) {\r\nprep_ai_dma(dev, 1, 0);\r\ndevpriv->supcsr |= DT2821_DDMA;\r\noutw(devpriv->supcsr, dev->iobase + DT2821_SUPCSR);\r\n}\r\ndevpriv->adcsr = 0;\r\ndt282x_load_changain(dev, cmd->chanlist_len, cmd->chanlist);\r\ndevpriv->adcsr = DT2821_ADCLK | DT2821_IADDONE;\r\noutw(devpriv->adcsr, dev->iobase + DT2821_ADCSR);\r\noutw(devpriv->supcsr | DT2821_PRLD, dev->iobase + DT2821_SUPCSR);\r\nwait_for(!mux_busy(), comedi_error(dev, "timeout\n"); return -ETIME;);\r\nif (cmd->scan_begin_src == TRIG_FOLLOW) {\r\noutw(devpriv->supcsr | DT2821_STRIG,\r\ndev->iobase + DT2821_SUPCSR);\r\n} else {\r\ndevpriv->supcsr |= DT2821_XTRIG;\r\noutw(devpriv->supcsr, dev->iobase + DT2821_SUPCSR);\r\n}\r\nreturn 0;\r\n}\r\nstatic void dt282x_disable_dma(struct comedi_device *dev)\r\n{\r\nstruct dt282x_private *devpriv = dev->private;\r\nif (devpriv->usedma) {\r\ndisable_dma(devpriv->dma[0].chan);\r\ndisable_dma(devpriv->dma[1].chan);\r\n}\r\n}\r\nstatic int dt282x_ai_cancel(struct comedi_device *dev,\r\nstruct comedi_subdevice *s)\r\n{\r\nstruct dt282x_private *devpriv = dev->private;\r\ndt282x_disable_dma(dev);\r\ndevpriv->adcsr = 0;\r\noutw(devpriv->adcsr, dev->iobase + DT2821_ADCSR);\r\ndevpriv->supcsr = 0;\r\noutw(devpriv->supcsr | DT2821_ADCINIT, dev->iobase + DT2821_SUPCSR);\r\nreturn 0;\r\n}\r\nstatic int dt282x_ns_to_timer(int *nanosec, int round_mode)\r\n{\r\nint prescale, base, divider;\r\nfor (prescale = 0; prescale < 16; prescale++) {\r\nif (prescale == 1)\r\ncontinue;\r\nbase = 250 * (1 << prescale);\r\nswitch (round_mode) {\r\ncase TRIG_ROUND_NEAREST:\r\ndefault:\r\ndivider = (*nanosec + base / 2) / base;\r\nbreak;\r\ncase TRIG_ROUND_DOWN:\r\ndivider = (*nanosec) / base;\r\nbreak;\r\ncase TRIG_ROUND_UP:\r\ndivider = (*nanosec + base - 1) / base;\r\nbreak;\r\n}\r\nif (divider < 256) {\r\n*nanosec = divider * base;\r\nreturn (prescale << 8) | (255 - divider);\r\n}\r\n}\r\nbase = 250 * (1 << 15);\r\ndivider = 255;\r\n*nanosec = divider * base;\r\nreturn (15 << 8) | (255 - divider);\r\n}\r\nstatic int dt282x_ao_insn_read(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nstruct dt282x_private *devpriv = dev->private;\r\ndata[0] = devpriv->ao[CR_CHAN(insn->chanspec)];\r\nreturn 1;\r\n}\r\nstatic int dt282x_ao_insn_write(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nstruct dt282x_private *devpriv = dev->private;\r\nshort d;\r\nunsigned int chan;\r\nchan = CR_CHAN(insn->chanspec);\r\nd = data[0];\r\nd &= (1 << boardtype.dabits) - 1;\r\ndevpriv->ao[chan] = d;\r\ndevpriv->dacsr |= DT2821_SSEL;\r\nif (chan) {\r\ndevpriv->dacsr |= DT2821_YSEL;\r\nif (devpriv->da0_2scomp)\r\nd ^= (1 << (boardtype.dabits - 1));\r\n} else {\r\ndevpriv->dacsr &= ~DT2821_YSEL;\r\nif (devpriv->da1_2scomp)\r\nd ^= (1 << (boardtype.dabits - 1));\r\n}\r\noutw(devpriv->dacsr, dev->iobase + DT2821_DACSR);\r\noutw(d, dev->iobase + DT2821_DADAT);\r\noutw(devpriv->supcsr | DT2821_DACON, dev->iobase + DT2821_SUPCSR);\r\nreturn 1;\r\n}\r\nstatic int dt282x_ao_cmdtest(struct comedi_device *dev,\r\nstruct comedi_subdevice *s, struct comedi_cmd *cmd)\r\n{\r\nint err = 0;\r\nint tmp;\r\nerr |= cfc_check_trigger_src(&cmd->start_src, TRIG_INT);\r\nerr |= cfc_check_trigger_src(&cmd->scan_begin_src, TRIG_TIMER);\r\nerr |= cfc_check_trigger_src(&cmd->convert_src, TRIG_NOW);\r\nerr |= cfc_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);\r\nerr |= cfc_check_trigger_src(&cmd->stop_src, TRIG_COUNT | TRIG_NONE);\r\nif (err)\r\nreturn 1;\r\nerr |= cfc_check_trigger_is_unique(cmd->stop_src);\r\nif (err)\r\nreturn 2;\r\nerr |= cfc_check_trigger_arg_is(&cmd->start_arg, 0);\r\nerr |= cfc_check_trigger_arg_min(&cmd->scan_begin_arg, 5000);\r\nerr |= cfc_check_trigger_arg_is(&cmd->convert_arg, 0);\r\nerr |= cfc_check_trigger_arg_max(&cmd->scan_end_arg, 2);\r\nif (cmd->stop_src == TRIG_COUNT) {\r\n} else {\r\nerr |= cfc_check_trigger_arg_is(&cmd->stop_arg, 0);\r\n}\r\nif (err)\r\nreturn 3;\r\ntmp = cmd->scan_begin_arg;\r\ndt282x_ns_to_timer(&cmd->scan_begin_arg, cmd->flags & TRIG_ROUND_MASK);\r\nif (tmp != cmd->scan_begin_arg)\r\nerr++;\r\nif (err)\r\nreturn 4;\r\nreturn 0;\r\n}\r\nstatic int dt282x_ao_inttrig(struct comedi_device *dev,\r\nstruct comedi_subdevice *s, unsigned int x)\r\n{\r\nstruct dt282x_private *devpriv = dev->private;\r\nint size;\r\nif (x != 0)\r\nreturn -EINVAL;\r\nsize = cfc_read_array_from_buffer(s, devpriv->dma[0].buf,\r\ndevpriv->dma_maxsize);\r\nif (size == 0) {\r\nprintk(KERN_ERR "dt282x: AO underrun\n");\r\nreturn -EPIPE;\r\n}\r\nprep_ao_dma(dev, 0, size);\r\nsize = cfc_read_array_from_buffer(s, devpriv->dma[1].buf,\r\ndevpriv->dma_maxsize);\r\nif (size == 0) {\r\nprintk(KERN_ERR "dt282x: AO underrun\n");\r\nreturn -EPIPE;\r\n}\r\nprep_ao_dma(dev, 1, size);\r\noutw(devpriv->supcsr | DT2821_STRIG, dev->iobase + DT2821_SUPCSR);\r\ns->async->inttrig = NULL;\r\nreturn 1;\r\n}\r\nstatic int dt282x_ao_cmd(struct comedi_device *dev, struct comedi_subdevice *s)\r\n{\r\nstruct dt282x_private *devpriv = dev->private;\r\nint timer;\r\nstruct comedi_cmd *cmd = &s->async->cmd;\r\nif (devpriv->usedma == 0) {\r\ncomedi_error(dev,\r\n"driver requires 2 dma channels"\r\n" to execute command");\r\nreturn -EIO;\r\n}\r\ndt282x_disable_dma(dev);\r\ndevpriv->supcsr = DT2821_ERRINTEN | DT2821_DS1 | DT2821_DDMA;\r\noutw(devpriv->supcsr | DT2821_CLRDMADNE | DT2821_BUFFB | DT2821_DACINIT,\r\ndev->iobase + DT2821_SUPCSR);\r\ndevpriv->ntrig = cmd->stop_arg * cmd->chanlist_len;\r\ndevpriv->nread = devpriv->ntrig;\r\ndevpriv->dma_dir = DMA_MODE_WRITE;\r\ndevpriv->current_dma_index = 0;\r\ntimer = dt282x_ns_to_timer(&cmd->scan_begin_arg, TRIG_ROUND_NEAREST);\r\noutw(timer, dev->iobase + DT2821_TMRCTR);\r\ndevpriv->dacsr = DT2821_SSEL | DT2821_DACLK | DT2821_IDARDY;\r\noutw(devpriv->dacsr, dev->iobase + DT2821_DACSR);\r\ns->async->inttrig = dt282x_ao_inttrig;\r\nreturn 0;\r\n}\r\nstatic int dt282x_ao_cancel(struct comedi_device *dev,\r\nstruct comedi_subdevice *s)\r\n{\r\nstruct dt282x_private *devpriv = dev->private;\r\ndt282x_disable_dma(dev);\r\ndevpriv->dacsr = 0;\r\noutw(devpriv->dacsr, dev->iobase + DT2821_DACSR);\r\ndevpriv->supcsr = 0;\r\noutw(devpriv->supcsr | DT2821_DACINIT, dev->iobase + DT2821_SUPCSR);\r\nreturn 0;\r\n}\r\nstatic int dt282x_dio_insn_bits(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nif (data[0]) {\r\ns->state &= ~data[0];\r\ns->state |= (data[0] & data[1]);\r\noutw(s->state, dev->iobase + DT2821_DIODAT);\r\n}\r\ndata[1] = inw(dev->iobase + DT2821_DIODAT);\r\nreturn insn->n;\r\n}\r\nstatic int dt282x_dio_insn_config(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nstruct dt282x_private *devpriv = dev->private;\r\nint mask;\r\nmask = (CR_CHAN(insn->chanspec) < 8) ? 0x00ff : 0xff00;\r\nif (data[0])\r\ns->io_bits |= mask;\r\nelse\r\ns->io_bits &= ~mask;\r\nif (s->io_bits & 0x00ff)\r\ndevpriv->dacsr |= DT2821_LBOE;\r\nelse\r\ndevpriv->dacsr &= ~DT2821_LBOE;\r\nif (s->io_bits & 0xff00)\r\ndevpriv->dacsr |= DT2821_HBOE;\r\nelse\r\ndevpriv->dacsr &= ~DT2821_HBOE;\r\noutw(devpriv->dacsr, dev->iobase + DT2821_DACSR);\r\nreturn 1;\r\n}\r\nstatic const struct comedi_lrange *opt_ai_range_lkup(int ispgl, int x)\r\n{\r\nif (ispgl) {\r\nif (x < 0 || x >= 2)\r\nx = 0;\r\nreturn ai_range_pgl_table[x];\r\n} else {\r\nif (x < 0 || x >= 4)\r\nx = 0;\r\nreturn ai_range_table[x];\r\n}\r\n}\r\nstatic const struct comedi_lrange *opt_ao_range_lkup(int x)\r\n{\r\nif (x < 0 || x >= 5)\r\nx = 0;\r\nreturn ao_range_table[x];\r\n}\r\nstatic int dt282x_grab_dma(struct comedi_device *dev, int dma1, int dma2)\r\n{\r\nstruct dt282x_private *devpriv = dev->private;\r\nint ret;\r\ndevpriv->usedma = 0;\r\nif (!dma1 && !dma2) {\r\nprintk(KERN_ERR " (no dma)");\r\nreturn 0;\r\n}\r\nif (dma1 == dma2 || dma1 < 5 || dma2 < 5 || dma1 > 7 || dma2 > 7)\r\nreturn -EINVAL;\r\nif (dma2 < dma1) {\r\nint i;\r\ni = dma1;\r\ndma1 = dma2;\r\ndma2 = i;\r\n}\r\nret = request_dma(dma1, "dt282x A");\r\nif (ret)\r\nreturn -EBUSY;\r\ndevpriv->dma[0].chan = dma1;\r\nret = request_dma(dma2, "dt282x B");\r\nif (ret)\r\nreturn -EBUSY;\r\ndevpriv->dma[1].chan = dma2;\r\ndevpriv->dma_maxsize = PAGE_SIZE;\r\ndevpriv->dma[0].buf = (void *)__get_free_page(GFP_KERNEL | GFP_DMA);\r\ndevpriv->dma[1].buf = (void *)__get_free_page(GFP_KERNEL | GFP_DMA);\r\nif (!devpriv->dma[0].buf || !devpriv->dma[1].buf) {\r\nprintk(KERN_ERR " can't get DMA memory");\r\nreturn -ENOMEM;\r\n}\r\nprintk(KERN_INFO " (dma=%d,%d)", dma1, dma2);\r\ndevpriv->usedma = 1;\r\nreturn 0;\r\n}\r\nstatic int dt282x_attach(struct comedi_device *dev, struct comedi_devconfig *it)\r\n{\r\nconst struct dt282x_board *board = comedi_board(dev);\r\nstruct dt282x_private *devpriv;\r\nint i, irq;\r\nint ret;\r\nstruct comedi_subdevice *s;\r\nunsigned long iobase;\r\ndev->board_name = board->name;\r\niobase = it->options[opt_iobase];\r\nif (!iobase)\r\niobase = 0x240;\r\nprintk(KERN_INFO "comedi%d: dt282x: 0x%04lx", dev->minor, iobase);\r\nif (!request_region(iobase, DT2821_SIZE, "dt282x")) {\r\nprintk(KERN_INFO " I/O port conflict\n");\r\nreturn -EBUSY;\r\n}\r\ndev->iobase = iobase;\r\noutw(DT2821_BDINIT, dev->iobase + DT2821_SUPCSR);\r\ni = inw(dev->iobase + DT2821_ADCSR);\r\n#ifdef DEBUG\r\nprintk(KERN_DEBUG " fingerprint=%x,%x,%x,%x,%x",\r\ninw(dev->iobase + DT2821_ADCSR),\r\ninw(dev->iobase + DT2821_CHANCSR),\r\ninw(dev->iobase + DT2821_DACSR),\r\ninw(dev->iobase + DT2821_SUPCSR),\r\ninw(dev->iobase + DT2821_TMRCTR));\r\n#endif\r\nif (((inw(dev->iobase + DT2821_ADCSR) & DT2821_ADCSR_MASK)\r\n!= DT2821_ADCSR_VAL) ||\r\n((inw(dev->iobase + DT2821_CHANCSR) & DT2821_CHANCSR_MASK)\r\n!= DT2821_CHANCSR_VAL) ||\r\n((inw(dev->iobase + DT2821_DACSR) & DT2821_DACSR_MASK)\r\n!= DT2821_DACSR_VAL) ||\r\n((inw(dev->iobase + DT2821_SUPCSR) & DT2821_SUPCSR_MASK)\r\n!= DT2821_SUPCSR_VAL) ||\r\n((inw(dev->iobase + DT2821_TMRCTR) & DT2821_TMRCTR_MASK)\r\n!= DT2821_TMRCTR_VAL)) {\r\nprintk(KERN_ERR " board not found");\r\nreturn -EIO;\r\n}\r\nirq = it->options[opt_irq];\r\n#if 0\r\nif (irq < 0) {\r\nunsigned long flags;\r\nint irqs;\r\nsave_flags(flags);\r\nsti();\r\nirqs = probe_irq_on();\r\nudelay(100);\r\nirq = probe_irq_off(irqs);\r\nrestore_flags(flags);\r\nif (0 )\r\nprintk(KERN_ERR " error probing irq (bad)");\r\n}\r\n#endif\r\nif (irq > 0) {\r\nprintk(KERN_INFO " ( irq = %d )", irq);\r\nret = request_irq(irq, dt282x_interrupt, 0, "dt282x", dev);\r\nif (ret < 0) {\r\nprintk(KERN_ERR " failed to get irq\n");\r\nreturn -EIO;\r\n}\r\ndev->irq = irq;\r\n} else if (irq == 0) {\r\nprintk(KERN_INFO " (no irq)");\r\n} else {\r\n#if 0\r\nprintk(KERN_INFO " (probe returned multiple irqs--bad)");\r\n#else\r\nprintk(KERN_INFO " (irq probe not implemented)");\r\n#endif\r\n}\r\ndevpriv = kzalloc(sizeof(*devpriv), GFP_KERNEL);\r\nif (!devpriv)\r\nreturn -ENOMEM;\r\ndev->private = devpriv;\r\nret = dt282x_grab_dma(dev, it->options[opt_dma1],\r\nit->options[opt_dma2]);\r\nif (ret < 0)\r\nreturn ret;\r\nret = comedi_alloc_subdevices(dev, 3);\r\nif (ret)\r\nreturn ret;\r\ns = &dev->subdevices[0];\r\ndev->read_subdev = s;\r\ns->type = COMEDI_SUBD_AI;\r\ns->subdev_flags = SDF_READABLE | SDF_CMD_READ |\r\n((it->options[opt_diff]) ? SDF_DIFF : SDF_COMMON);\r\ns->n_chan =\r\n(it->options[opt_diff]) ? boardtype.adchan_di : boardtype.adchan_se;\r\ns->insn_read = dt282x_ai_insn_read;\r\ns->do_cmdtest = dt282x_ai_cmdtest;\r\ns->do_cmd = dt282x_ai_cmd;\r\ns->cancel = dt282x_ai_cancel;\r\ns->maxdata = (1 << boardtype.adbits) - 1;\r\ns->len_chanlist = 16;\r\ns->range_table =\r\nopt_ai_range_lkup(boardtype.ispgl, it->options[opt_ai_range]);\r\ndevpriv->ad_2scomp = it->options[opt_ai_twos];\r\ns = &dev->subdevices[1];\r\ns->n_chan = boardtype.dachan;\r\nif (s->n_chan) {\r\ns->type = COMEDI_SUBD_AO;\r\ndev->write_subdev = s;\r\ns->subdev_flags = SDF_WRITABLE | SDF_CMD_WRITE;\r\ns->insn_read = dt282x_ao_insn_read;\r\ns->insn_write = dt282x_ao_insn_write;\r\ns->do_cmdtest = dt282x_ao_cmdtest;\r\ns->do_cmd = dt282x_ao_cmd;\r\ns->cancel = dt282x_ao_cancel;\r\ns->maxdata = (1 << boardtype.dabits) - 1;\r\ns->len_chanlist = 2;\r\ns->range_table_list = devpriv->darangelist;\r\ndevpriv->darangelist[0] =\r\nopt_ao_range_lkup(it->options[opt_ao0_range]);\r\ndevpriv->darangelist[1] =\r\nopt_ao_range_lkup(it->options[opt_ao1_range]);\r\ndevpriv->da0_2scomp = it->options[opt_ao0_twos];\r\ndevpriv->da1_2scomp = it->options[opt_ao1_twos];\r\n} else {\r\ns->type = COMEDI_SUBD_UNUSED;\r\n}\r\ns = &dev->subdevices[2];\r\ns->type = COMEDI_SUBD_DIO;\r\ns->subdev_flags = SDF_READABLE | SDF_WRITABLE;\r\ns->n_chan = 16;\r\ns->insn_bits = dt282x_dio_insn_bits;\r\ns->insn_config = dt282x_dio_insn_config;\r\ns->maxdata = 1;\r\ns->range_table = &range_digital;\r\nprintk(KERN_INFO "\n");\r\nreturn 0;\r\n}\r\nstatic void dt282x_detach(struct comedi_device *dev)\r\n{\r\nstruct dt282x_private *devpriv = dev->private;\r\nif (dev->irq)\r\nfree_irq(dev->irq, dev);\r\nif (dev->iobase)\r\nrelease_region(dev->iobase, DT2821_SIZE);\r\nif (dev->private) {\r\nif (devpriv->dma[0].chan)\r\nfree_dma(devpriv->dma[0].chan);\r\nif (devpriv->dma[1].chan)\r\nfree_dma(devpriv->dma[1].chan);\r\nif (devpriv->dma[0].buf)\r\nfree_page((unsigned long)devpriv->dma[0].buf);\r\nif (devpriv->dma[1].buf)\r\nfree_page((unsigned long)devpriv->dma[1].buf);\r\n}\r\n}
