static void gpio_keys_polled_check_state(struct input_dev *input,\r\nstruct gpio_keys_button *button,\r\nstruct gpio_keys_button_data *bdata)\r\n{\r\nint state;\r\nif (bdata->can_sleep)\r\nstate = !!gpio_get_value_cansleep(button->gpio);\r\nelse\r\nstate = !!gpio_get_value(button->gpio);\r\nif (state != bdata->last_state) {\r\nunsigned int type = button->type ?: EV_KEY;\r\ninput_event(input, type, button->code,\r\n!!(state ^ button->active_low));\r\ninput_sync(input);\r\nbdata->count = 0;\r\nbdata->last_state = state;\r\n}\r\n}\r\nstatic void gpio_keys_polled_poll(struct input_polled_dev *dev)\r\n{\r\nstruct gpio_keys_polled_dev *bdev = dev->private;\r\nconst struct gpio_keys_platform_data *pdata = bdev->pdata;\r\nstruct input_dev *input = dev->input;\r\nint i;\r\nfor (i = 0; i < pdata->nbuttons; i++) {\r\nstruct gpio_keys_button_data *bdata = &bdev->data[i];\r\nif (bdata->count < bdata->threshold)\r\nbdata->count++;\r\nelse\r\ngpio_keys_polled_check_state(input, &pdata->buttons[i],\r\nbdata);\r\n}\r\n}\r\nstatic void gpio_keys_polled_open(struct input_polled_dev *dev)\r\n{\r\nstruct gpio_keys_polled_dev *bdev = dev->private;\r\nconst struct gpio_keys_platform_data *pdata = bdev->pdata;\r\nif (pdata->enable)\r\npdata->enable(bdev->dev);\r\n}\r\nstatic void gpio_keys_polled_close(struct input_polled_dev *dev)\r\n{\r\nstruct gpio_keys_polled_dev *bdev = dev->private;\r\nconst struct gpio_keys_platform_data *pdata = bdev->pdata;\r\nif (pdata->disable)\r\npdata->disable(bdev->dev);\r\n}\r\nstatic struct gpio_keys_platform_data *gpio_keys_polled_get_devtree_pdata(struct device *dev)\r\n{\r\nstruct device_node *node, *pp;\r\nstruct gpio_keys_platform_data *pdata;\r\nstruct gpio_keys_button *button;\r\nint error;\r\nint nbuttons;\r\nint i;\r\nnode = dev->of_node;\r\nif (!node)\r\nreturn NULL;\r\nnbuttons = of_get_child_count(node);\r\nif (nbuttons == 0)\r\nreturn NULL;\r\npdata = kzalloc(sizeof(*pdata) + nbuttons * (sizeof *button),\r\nGFP_KERNEL);\r\nif (!pdata) {\r\nerror = -ENOMEM;\r\ngoto err_out;\r\n}\r\npdata->buttons = (struct gpio_keys_button *)(pdata + 1);\r\npdata->nbuttons = nbuttons;\r\npdata->rep = !!of_get_property(node, "autorepeat", NULL);\r\nof_property_read_u32(node, "poll-interval", &pdata->poll_interval);\r\ni = 0;\r\nfor_each_child_of_node(node, pp) {\r\nint gpio;\r\nenum of_gpio_flags flags;\r\nif (!of_find_property(pp, "gpios", NULL)) {\r\npdata->nbuttons--;\r\ndev_warn(dev, "Found button without gpios\n");\r\ncontinue;\r\n}\r\ngpio = of_get_gpio_flags(pp, 0, &flags);\r\nif (gpio < 0) {\r\nerror = gpio;\r\nif (error != -EPROBE_DEFER)\r\ndev_err(dev,\r\n"Failed to get gpio flags, error: %d\n",\r\nerror);\r\ngoto err_free_pdata;\r\n}\r\nbutton = &pdata->buttons[i++];\r\nbutton->gpio = gpio;\r\nbutton->active_low = flags & OF_GPIO_ACTIVE_LOW;\r\nif (of_property_read_u32(pp, "linux,code", &button->code)) {\r\ndev_err(dev, "Button without keycode: 0x%x\n",\r\nbutton->gpio);\r\nerror = -EINVAL;\r\ngoto err_free_pdata;\r\n}\r\nbutton->desc = of_get_property(pp, "label", NULL);\r\nif (of_property_read_u32(pp, "linux,input-type", &button->type))\r\nbutton->type = EV_KEY;\r\nbutton->wakeup = !!of_get_property(pp, "gpio-key,wakeup", NULL);\r\nif (of_property_read_u32(pp, "debounce-interval",\r\n&button->debounce_interval))\r\nbutton->debounce_interval = 5;\r\n}\r\nif (pdata->nbuttons == 0) {\r\nerror = -EINVAL;\r\ngoto err_free_pdata;\r\n}\r\nreturn pdata;\r\nerr_free_pdata:\r\nkfree(pdata);\r\nerr_out:\r\nreturn ERR_PTR(error);\r\n}\r\nstatic inline struct gpio_keys_platform_data *\r\ngpio_keys_polled_get_devtree_pdata(struct device *dev)\r\n{\r\nreturn NULL;\r\n}\r\nstatic int gpio_keys_polled_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nconst struct gpio_keys_platform_data *pdata = dev_get_platdata(dev);\r\nstruct gpio_keys_polled_dev *bdev;\r\nstruct input_polled_dev *poll_dev;\r\nstruct input_dev *input;\r\nint error;\r\nint i;\r\nif (!pdata) {\r\npdata = gpio_keys_polled_get_devtree_pdata(dev);\r\nif (IS_ERR(pdata))\r\nreturn PTR_ERR(pdata);\r\nif (!pdata) {\r\ndev_err(dev, "missing platform data\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\nif (!pdata->poll_interval) {\r\ndev_err(dev, "missing poll_interval value\n");\r\nerror = -EINVAL;\r\ngoto err_free_pdata;\r\n}\r\nbdev = kzalloc(sizeof(struct gpio_keys_polled_dev) +\r\npdata->nbuttons * sizeof(struct gpio_keys_button_data),\r\nGFP_KERNEL);\r\nif (!bdev) {\r\ndev_err(dev, "no memory for private data\n");\r\nerror = -ENOMEM;\r\ngoto err_free_pdata;\r\n}\r\npoll_dev = input_allocate_polled_device();\r\nif (!poll_dev) {\r\ndev_err(dev, "no memory for polled device\n");\r\nerror = -ENOMEM;\r\ngoto err_free_bdev;\r\n}\r\npoll_dev->private = bdev;\r\npoll_dev->poll = gpio_keys_polled_poll;\r\npoll_dev->poll_interval = pdata->poll_interval;\r\npoll_dev->open = gpio_keys_polled_open;\r\npoll_dev->close = gpio_keys_polled_close;\r\ninput = poll_dev->input;\r\ninput->name = pdev->name;\r\ninput->phys = DRV_NAME"/input0";\r\ninput->dev.parent = &pdev->dev;\r\ninput->id.bustype = BUS_HOST;\r\ninput->id.vendor = 0x0001;\r\ninput->id.product = 0x0001;\r\ninput->id.version = 0x0100;\r\n__set_bit(EV_KEY, input->evbit);\r\nif (pdata->rep)\r\n__set_bit(EV_REP, input->evbit);\r\nfor (i = 0; i < pdata->nbuttons; i++) {\r\nstruct gpio_keys_button *button = &pdata->buttons[i];\r\nstruct gpio_keys_button_data *bdata = &bdev->data[i];\r\nunsigned int gpio = button->gpio;\r\nunsigned int type = button->type ?: EV_KEY;\r\nif (button->wakeup) {\r\ndev_err(dev, DRV_NAME " does not support wakeup\n");\r\nerror = -EINVAL;\r\ngoto err_free_gpio;\r\n}\r\nerror = gpio_request_one(gpio, GPIOF_IN,\r\nbutton->desc ?: DRV_NAME);\r\nif (error) {\r\ndev_err(dev, "unable to claim gpio %u, err=%d\n",\r\ngpio, error);\r\ngoto err_free_gpio;\r\n}\r\nbdata->can_sleep = gpio_cansleep(gpio);\r\nbdata->last_state = -1;\r\nbdata->threshold = DIV_ROUND_UP(button->debounce_interval,\r\npdata->poll_interval);\r\ninput_set_capability(input, type, button->code);\r\n}\r\nbdev->poll_dev = poll_dev;\r\nbdev->dev = dev;\r\nbdev->pdata = pdata;\r\nplatform_set_drvdata(pdev, bdev);\r\nerror = input_register_polled_device(poll_dev);\r\nif (error) {\r\ndev_err(dev, "unable to register polled device, err=%d\n",\r\nerror);\r\ngoto err_free_gpio;\r\n}\r\nfor (i = 0; i < pdata->nbuttons; i++)\r\ngpio_keys_polled_check_state(input, &pdata->buttons[i],\r\n&bdev->data[i]);\r\nreturn 0;\r\nerr_free_gpio:\r\nwhile (--i >= 0)\r\ngpio_free(pdata->buttons[i].gpio);\r\ninput_free_polled_device(poll_dev);\r\nerr_free_bdev:\r\nkfree(bdev);\r\nplatform_set_drvdata(pdev, NULL);\r\nerr_free_pdata:\r\nif (!dev_get_platdata(&pdev->dev))\r\nkfree(pdata);\r\nreturn error;\r\n}\r\nstatic int gpio_keys_polled_remove(struct platform_device *pdev)\r\n{\r\nstruct gpio_keys_polled_dev *bdev = platform_get_drvdata(pdev);\r\nconst struct gpio_keys_platform_data *pdata = bdev->pdata;\r\nint i;\r\ninput_unregister_polled_device(bdev->poll_dev);\r\nfor (i = 0; i < pdata->nbuttons; i++)\r\ngpio_free(pdata->buttons[i].gpio);\r\ninput_free_polled_device(bdev->poll_dev);\r\nif (!dev_get_platdata(&pdev->dev))\r\nkfree(pdata);\r\nkfree(bdev);\r\nplatform_set_drvdata(pdev, NULL);\r\nreturn 0;\r\n}
