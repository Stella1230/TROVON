static int pcmcia_set_mode(struct ata_link *link, struct ata_device **r_failed_dev)\r\n{\r\nstruct ata_device *master = &link->device[0];\r\nstruct ata_device *slave = &link->device[1];\r\nif (!ata_dev_enabled(master) || !ata_dev_enabled(slave))\r\nreturn ata_do_set_mode(link, r_failed_dev);\r\nif (memcmp(master->id + ATA_ID_FW_REV, slave->id + ATA_ID_FW_REV,\r\nATA_ID_FW_REV_LEN + ATA_ID_PROD_LEN) == 0) {\r\nif (memcmp(master->id + ATA_ID_SERNO, slave->id + ATA_ID_SERNO,\r\nATA_ID_SERNO_LEN) == 0 && master->id[ATA_ID_SERNO] >> 8) {\r\nata_dev_warn(slave, "is a ghost device, ignoring\n");\r\nata_dev_disable(slave);\r\n}\r\n}\r\nreturn ata_do_set_mode(link, r_failed_dev);\r\n}\r\nstatic int pcmcia_set_mode_8bit(struct ata_link *link,\r\nstruct ata_device **r_failed_dev)\r\n{\r\nreturn 0;\r\n}\r\nstatic unsigned int ata_data_xfer_8bit(struct ata_device *dev,\r\nunsigned char *buf, unsigned int buflen, int rw)\r\n{\r\nstruct ata_port *ap = dev->link->ap;\r\nif (rw == READ)\r\nioread8_rep(ap->ioaddr.data_addr, buf, buflen);\r\nelse\r\niowrite8_rep(ap->ioaddr.data_addr, buf, buflen);\r\nreturn buflen;\r\n}\r\nstatic void pcmcia_8bit_drain_fifo(struct ata_queued_cmd *qc)\r\n{\r\nint count;\r\nstruct ata_port *ap;\r\nif (qc == NULL || qc->dma_dir == DMA_TO_DEVICE)\r\nreturn;\r\nap = qc->ap;\r\nfor (count = 0; (ap->ops->sff_check_status(ap) & ATA_DRQ)\r\n&& count++ < 65536;)\r\nioread8(ap->ioaddr.data_addr);\r\nif (count)\r\nata_port_warn(ap, "drained %d bytes to clear DRQ\n", count);\r\n}\r\nstatic int pcmcia_check_one_config(struct pcmcia_device *pdev, void *priv_data)\r\n{\r\nint *is_kme = priv_data;\r\nif ((pdev->resource[0]->flags & IO_DATA_PATH_WIDTH)\r\n!= IO_DATA_PATH_WIDTH_8) {\r\npdev->resource[0]->flags &= ~IO_DATA_PATH_WIDTH;\r\npdev->resource[0]->flags |= IO_DATA_PATH_WIDTH_AUTO;\r\n}\r\npdev->resource[1]->flags &= ~IO_DATA_PATH_WIDTH;\r\npdev->resource[1]->flags |= IO_DATA_PATH_WIDTH_8;\r\nif (pdev->resource[1]->end) {\r\npdev->resource[0]->end = 8;\r\npdev->resource[1]->end = (*is_kme) ? 2 : 1;\r\n} else {\r\nif (pdev->resource[0]->end < 16)\r\nreturn -ENODEV;\r\n}\r\nreturn pcmcia_request_io(pdev);\r\n}\r\nstatic int pcmcia_init_one(struct pcmcia_device *pdev)\r\n{\r\nstruct ata_host *host;\r\nstruct ata_port *ap;\r\nint is_kme = 0, ret = -ENOMEM, p;\r\nunsigned long io_base, ctl_base;\r\nvoid __iomem *io_addr, *ctl_addr;\r\nint n_ports = 1;\r\nstruct ata_port_operations *ops = &pcmcia_port_ops;\r\npdev->config_flags |= CONF_ENABLE_IRQ | CONF_AUTO_SET_IO |\r\nCONF_AUTO_SET_VPP | CONF_AUTO_CHECK_VCC;\r\nis_kme = ((pdev->manf_id == MANFID_KME) &&\r\n((pdev->card_id == PRODID_KME_KXLC005_A) ||\r\n(pdev->card_id == PRODID_KME_KXLC005_B)));\r\nif (pcmcia_loop_config(pdev, pcmcia_check_one_config, &is_kme)) {\r\npdev->config_flags &= ~CONF_AUTO_CHECK_VCC;\r\nif (pcmcia_loop_config(pdev, pcmcia_check_one_config, &is_kme))\r\ngoto failed;\r\n}\r\nio_base = pdev->resource[0]->start;\r\nif (pdev->resource[1]->end)\r\nctl_base = pdev->resource[1]->start;\r\nelse\r\nctl_base = pdev->resource[0]->start + 0x0e;\r\nif (!pdev->irq)\r\ngoto failed;\r\nret = pcmcia_enable_device(pdev);\r\nif (ret)\r\ngoto failed;\r\nret = -ENOMEM;\r\nio_addr = devm_ioport_map(&pdev->dev, io_base, 8);\r\nctl_addr = devm_ioport_map(&pdev->dev, ctl_base, 1);\r\nif (!io_addr || !ctl_addr)\r\ngoto failed;\r\niowrite8(0x02, ctl_addr);\r\nif (is_kme)\r\niowrite8(0x81, ctl_addr + 0x01);\r\nif (resource_size(pdev->resource[0]) >= 0x20)\r\nn_ports = 2;\r\nif (pdev->manf_id == 0x0097 && pdev->card_id == 0x1620)\r\nops = &pcmcia_8bit_port_ops;\r\nret = -ENOMEM;\r\nhost = ata_host_alloc(&pdev->dev, n_ports);\r\nif (!host)\r\ngoto failed;\r\nfor (p = 0; p < n_ports; p++) {\r\nap = host->ports[p];\r\nap->ops = ops;\r\nap->pio_mask = ATA_PIO0;\r\nap->flags |= ATA_FLAG_SLAVE_POSS;\r\nap->ioaddr.cmd_addr = io_addr + 0x10 * p;\r\nap->ioaddr.altstatus_addr = ctl_addr + 0x10 * p;\r\nap->ioaddr.ctl_addr = ctl_addr + 0x10 * p;\r\nata_sff_std_ports(&ap->ioaddr);\r\nata_port_desc(ap, "cmd 0x%lx ctl 0x%lx", io_base, ctl_base);\r\n}\r\nret = ata_host_activate(host, pdev->irq, ata_sff_interrupt,\r\nIRQF_SHARED, &pcmcia_sht);\r\nif (ret)\r\ngoto failed;\r\npdev->priv = host;\r\nreturn 0;\r\nfailed:\r\npcmcia_disable_device(pdev);\r\nreturn ret;\r\n}\r\nstatic void pcmcia_remove_one(struct pcmcia_device *pdev)\r\n{\r\nstruct ata_host *host = pdev->priv;\r\nif (host)\r\nata_host_detach(host);\r\npcmcia_disable_device(pdev);\r\n}\r\nstatic int __init pcmcia_init(void)\r\n{\r\nreturn pcmcia_register_driver(&pcmcia_driver);\r\n}\r\nstatic void __exit pcmcia_exit(void)\r\n{\r\npcmcia_unregister_driver(&pcmcia_driver);\r\n}
