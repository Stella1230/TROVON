static int adf4350_sync_config(struct adf4350_state *st)\r\n{\r\nint ret, i, doublebuf = 0;\r\nfor (i = ADF4350_REG5; i >= ADF4350_REG0; i--) {\r\nif ((st->regs_hw[i] != st->regs[i]) ||\r\n((i == ADF4350_REG0) && doublebuf)) {\r\nswitch (i) {\r\ncase ADF4350_REG1:\r\ncase ADF4350_REG4:\r\ndoublebuf = 1;\r\nbreak;\r\n}\r\nst->val = cpu_to_be32(st->regs[i] | i);\r\nret = spi_write(st->spi, &st->val, 4);\r\nif (ret < 0)\r\nreturn ret;\r\nst->regs_hw[i] = st->regs[i];\r\ndev_dbg(&st->spi->dev, "[%d] 0x%X\n",\r\ni, (u32)st->regs[i] | i);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int adf4350_reg_access(struct iio_dev *indio_dev,\r\nunsigned reg, unsigned writeval,\r\nunsigned *readval)\r\n{\r\nstruct adf4350_state *st = iio_priv(indio_dev);\r\nint ret;\r\nif (reg > ADF4350_REG5)\r\nreturn -EINVAL;\r\nmutex_lock(&indio_dev->mlock);\r\nif (readval == NULL) {\r\nst->regs[reg] = writeval & ~(BIT(0) | BIT(1) | BIT(2));\r\nret = adf4350_sync_config(st);\r\n} else {\r\n*readval = st->regs_hw[reg];\r\nret = 0;\r\n}\r\nmutex_unlock(&indio_dev->mlock);\r\nreturn ret;\r\n}\r\nstatic int adf4350_tune_r_cnt(struct adf4350_state *st, unsigned short r_cnt)\r\n{\r\nstruct adf4350_platform_data *pdata = st->pdata;\r\ndo {\r\nr_cnt++;\r\nst->fpfd = (st->clkin * (pdata->ref_doubler_en ? 2 : 1)) /\r\n(r_cnt * (pdata->ref_div2_en ? 2 : 1));\r\n} while (st->fpfd > ADF4350_MAX_FREQ_PFD);\r\nreturn r_cnt;\r\n}\r\nstatic int adf4350_set_freq(struct adf4350_state *st, unsigned long long freq)\r\n{\r\nstruct adf4350_platform_data *pdata = st->pdata;\r\nu64 tmp;\r\nu32 div_gcd, prescaler, chspc;\r\nu16 mdiv, r_cnt = 0;\r\nu8 band_sel_div;\r\nif (freq > ADF4350_MAX_OUT_FREQ || freq < st->min_out_freq)\r\nreturn -EINVAL;\r\nif (freq > ADF4350_MAX_FREQ_45_PRESC) {\r\nprescaler = ADF4350_REG1_PRESCALER;\r\nmdiv = 75;\r\n} else {\r\nprescaler = 0;\r\nmdiv = 23;\r\n}\r\nst->r4_rf_div_sel = 0;\r\nwhile (freq < ADF4350_MIN_VCO_FREQ) {\r\nfreq <<= 1;\r\nst->r4_rf_div_sel++;\r\n}\r\nif (pdata->ref_div_factor)\r\nr_cnt = pdata->ref_div_factor - 1;\r\nchspc = st->chspc;\r\ndo {\r\ndo {\r\ndo {\r\nr_cnt = adf4350_tune_r_cnt(st, r_cnt);\r\nst->r1_mod = st->fpfd / chspc;\r\nif (r_cnt > ADF4350_MAX_R_CNT) {\r\nchspc++;\r\nr_cnt = 0;\r\n}\r\n} while ((st->r1_mod > ADF4350_MAX_MODULUS) && r_cnt);\r\n} while (r_cnt == 0);\r\ntmp = freq * (u64)st->r1_mod + (st->fpfd >> 1);\r\ndo_div(tmp, st->fpfd);\r\nst->r0_fract = do_div(tmp, st->r1_mod);\r\nst->r0_int = tmp;\r\n} while (mdiv > st->r0_int);\r\nband_sel_div = DIV_ROUND_UP(st->fpfd, ADF4350_MAX_BANDSEL_CLK);\r\nif (st->r0_fract && st->r1_mod) {\r\ndiv_gcd = gcd(st->r1_mod, st->r0_fract);\r\nst->r1_mod /= div_gcd;\r\nst->r0_fract /= div_gcd;\r\n} else {\r\nst->r0_fract = 0;\r\nst->r1_mod = 1;\r\n}\r\ndev_dbg(&st->spi->dev, "VCO: %llu Hz, PFD %lu Hz\n"\r\n"REF_DIV %d, R0_INT %d, R0_FRACT %d\n"\r\n"R1_MOD %d, RF_DIV %d\nPRESCALER %s, BAND_SEL_DIV %d\n",\r\nfreq, st->fpfd, r_cnt, st->r0_int, st->r0_fract, st->r1_mod,\r\n1 << st->r4_rf_div_sel, prescaler ? "8/9" : "4/5",\r\nband_sel_div);\r\nst->regs[ADF4350_REG0] = ADF4350_REG0_INT(st->r0_int) |\r\nADF4350_REG0_FRACT(st->r0_fract);\r\nst->regs[ADF4350_REG1] = ADF4350_REG1_PHASE(1) |\r\nADF4350_REG1_MOD(st->r1_mod) |\r\nprescaler;\r\nst->regs[ADF4350_REG2] =\r\nADF4350_REG2_10BIT_R_CNT(r_cnt) |\r\nADF4350_REG2_DOUBLE_BUFF_EN |\r\n(pdata->ref_doubler_en ? ADF4350_REG2_RMULT2_EN : 0) |\r\n(pdata->ref_div2_en ? ADF4350_REG2_RDIV2_EN : 0) |\r\n(pdata->r2_user_settings & (ADF4350_REG2_PD_POLARITY_POS |\r\nADF4350_REG2_LDP_6ns | ADF4350_REG2_LDF_INT_N |\r\nADF4350_REG2_CHARGE_PUMP_CURR_uA(5000) |\r\nADF4350_REG2_MUXOUT(0x7) | ADF4350_REG2_NOISE_MODE(0x9)));\r\nst->regs[ADF4350_REG3] = pdata->r3_user_settings &\r\n(ADF4350_REG3_12BIT_CLKDIV(0xFFF) |\r\nADF4350_REG3_12BIT_CLKDIV_MODE(0x3) |\r\nADF4350_REG3_12BIT_CSR_EN |\r\nADF4351_REG3_CHARGE_CANCELLATION_EN |\r\nADF4351_REG3_ANTI_BACKLASH_3ns_EN |\r\nADF4351_REG3_BAND_SEL_CLOCK_MODE_HIGH);\r\nst->regs[ADF4350_REG4] =\r\nADF4350_REG4_FEEDBACK_FUND |\r\nADF4350_REG4_RF_DIV_SEL(st->r4_rf_div_sel) |\r\nADF4350_REG4_8BIT_BAND_SEL_CLKDIV(band_sel_div) |\r\nADF4350_REG4_RF_OUT_EN |\r\n(pdata->r4_user_settings &\r\n(ADF4350_REG4_OUTPUT_PWR(0x3) |\r\nADF4350_REG4_AUX_OUTPUT_PWR(0x3) |\r\nADF4350_REG4_AUX_OUTPUT_EN |\r\nADF4350_REG4_AUX_OUTPUT_FUND |\r\nADF4350_REG4_MUTE_TILL_LOCK_EN));\r\nst->regs[ADF4350_REG5] = ADF4350_REG5_LD_PIN_MODE_DIGITAL;\r\nreturn adf4350_sync_config(st);\r\n}\r\nstatic ssize_t adf4350_write(struct iio_dev *indio_dev,\r\nuintptr_t private,\r\nconst struct iio_chan_spec *chan,\r\nconst char *buf, size_t len)\r\n{\r\nstruct adf4350_state *st = iio_priv(indio_dev);\r\nunsigned long long readin;\r\nint ret;\r\nret = kstrtoull(buf, 10, &readin);\r\nif (ret)\r\nreturn ret;\r\nmutex_lock(&indio_dev->mlock);\r\nswitch ((u32)private) {\r\ncase ADF4350_FREQ:\r\nret = adf4350_set_freq(st, readin);\r\nbreak;\r\ncase ADF4350_FREQ_REFIN:\r\nif (readin > ADF4350_MAX_FREQ_REFIN)\r\nret = -EINVAL;\r\nelse\r\nst->clkin = readin;\r\nbreak;\r\ncase ADF4350_FREQ_RESOLUTION:\r\nif (readin == 0)\r\nret = -EINVAL;\r\nelse\r\nst->chspc = readin;\r\nbreak;\r\ncase ADF4350_PWRDOWN:\r\nif (readin)\r\nst->regs[ADF4350_REG2] |= ADF4350_REG2_POWER_DOWN_EN;\r\nelse\r\nst->regs[ADF4350_REG2] &= ~ADF4350_REG2_POWER_DOWN_EN;\r\nadf4350_sync_config(st);\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\n}\r\nmutex_unlock(&indio_dev->mlock);\r\nreturn ret ? ret : len;\r\n}\r\nstatic ssize_t adf4350_read(struct iio_dev *indio_dev,\r\nuintptr_t private,\r\nconst struct iio_chan_spec *chan,\r\nchar *buf)\r\n{\r\nstruct adf4350_state *st = iio_priv(indio_dev);\r\nunsigned long long val;\r\nint ret = 0;\r\nmutex_lock(&indio_dev->mlock);\r\nswitch ((u32)private) {\r\ncase ADF4350_FREQ:\r\nval = (u64)((st->r0_int * st->r1_mod) + st->r0_fract) *\r\n(u64)st->fpfd;\r\ndo_div(val, st->r1_mod * (1 << st->r4_rf_div_sel));\r\nif (gpio_is_valid(st->pdata->gpio_lock_detect))\r\nif (!gpio_get_value(st->pdata->gpio_lock_detect)) {\r\ndev_dbg(&st->spi->dev, "PLL un-locked\n");\r\nret = -EBUSY;\r\n}\r\nbreak;\r\ncase ADF4350_FREQ_REFIN:\r\nval = st->clkin;\r\nbreak;\r\ncase ADF4350_FREQ_RESOLUTION:\r\nval = st->chspc;\r\nbreak;\r\ncase ADF4350_PWRDOWN:\r\nval = !!(st->regs[ADF4350_REG2] & ADF4350_REG2_POWER_DOWN_EN);\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\n}\r\nmutex_unlock(&indio_dev->mlock);\r\nreturn ret < 0 ? ret : sprintf(buf, "%llu\n", val);\r\n}\r\nstatic int adf4350_probe(struct spi_device *spi)\r\n{\r\nstruct adf4350_platform_data *pdata = spi->dev.platform_data;\r\nstruct iio_dev *indio_dev;\r\nstruct adf4350_state *st;\r\nint ret;\r\nif (!pdata) {\r\ndev_warn(&spi->dev, "no platform data? using default\n");\r\npdata = &default_pdata;\r\n}\r\nindio_dev = iio_device_alloc(sizeof(*st));\r\nif (indio_dev == NULL)\r\nreturn -ENOMEM;\r\nst = iio_priv(indio_dev);\r\nst->reg = regulator_get(&spi->dev, "vcc");\r\nif (!IS_ERR(st->reg)) {\r\nret = regulator_enable(st->reg);\r\nif (ret)\r\ngoto error_put_reg;\r\n}\r\nspi_set_drvdata(spi, indio_dev);\r\nst->spi = spi;\r\nst->pdata = pdata;\r\nindio_dev->dev.parent = &spi->dev;\r\nindio_dev->name = (pdata->name[0] != 0) ? pdata->name :\r\nspi_get_device_id(spi)->name;\r\nindio_dev->info = &adf4350_info;\r\nindio_dev->modes = INDIO_DIRECT_MODE;\r\nindio_dev->channels = &adf4350_chan;\r\nindio_dev->num_channels = 1;\r\nst->chspc = pdata->channel_spacing;\r\nst->clkin = pdata->clkin;\r\nst->min_out_freq = spi_get_device_id(spi)->driver_data == 4351 ?\r\nADF4351_MIN_OUT_FREQ : ADF4350_MIN_OUT_FREQ;\r\nmemset(st->regs_hw, 0xFF, sizeof(st->regs_hw));\r\nif (gpio_is_valid(pdata->gpio_lock_detect)) {\r\nret = gpio_request(pdata->gpio_lock_detect, indio_dev->name);\r\nif (ret) {\r\ndev_err(&spi->dev, "fail to request lock detect GPIO-%d",\r\npdata->gpio_lock_detect);\r\ngoto error_disable_reg;\r\n}\r\ngpio_direction_input(pdata->gpio_lock_detect);\r\n}\r\nif (pdata->power_up_frequency) {\r\nret = adf4350_set_freq(st, pdata->power_up_frequency);\r\nif (ret)\r\ngoto error_free_gpio;\r\n}\r\nret = iio_device_register(indio_dev);\r\nif (ret)\r\ngoto error_free_gpio;\r\nreturn 0;\r\nerror_free_gpio:\r\nif (gpio_is_valid(pdata->gpio_lock_detect))\r\ngpio_free(pdata->gpio_lock_detect);\r\nerror_disable_reg:\r\nif (!IS_ERR(st->reg))\r\nregulator_disable(st->reg);\r\nerror_put_reg:\r\nif (!IS_ERR(st->reg))\r\nregulator_put(st->reg);\r\niio_device_free(indio_dev);\r\nreturn ret;\r\n}\r\nstatic int adf4350_remove(struct spi_device *spi)\r\n{\r\nstruct iio_dev *indio_dev = spi_get_drvdata(spi);\r\nstruct adf4350_state *st = iio_priv(indio_dev);\r\nstruct regulator *reg = st->reg;\r\nst->regs[ADF4350_REG2] |= ADF4350_REG2_POWER_DOWN_EN;\r\nadf4350_sync_config(st);\r\niio_device_unregister(indio_dev);\r\nif (!IS_ERR(reg)) {\r\nregulator_disable(reg);\r\nregulator_put(reg);\r\n}\r\nif (gpio_is_valid(st->pdata->gpio_lock_detect))\r\ngpio_free(st->pdata->gpio_lock_detect);\r\niio_device_free(indio_dev);\r\nreturn 0;\r\n}
