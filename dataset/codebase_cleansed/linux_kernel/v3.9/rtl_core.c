static bool PlatformIOCheckPageLegalAndGetRegMask(u32 u4bPage, u8 *pu1bPageMask)\r\n{\r\nbool bReturn = false;\r\n*pu1bPageMask = 0xfe;\r\nswitch (u4bPage) {\r\ncase 1: case 2: case 3: case 4:\r\ncase 8: case 9: case 10: case 12: case 13:\r\nbReturn = true;\r\n*pu1bPageMask = 0xf0;\r\nbreak;\r\ndefault:\r\nbReturn = false;\r\nbreak;\r\n}\r\nreturn bReturn;\r\n}\r\nvoid write_nic_io_byte(struct net_device *dev, int x, u8 y)\r\n{\r\nu32 u4bPage = (x >> 8);\r\nu8 u1PageMask = 0;\r\nbool bIsLegalPage = false;\r\nif (u4bPage == 0) {\r\noutb(y&0xff, dev->base_addr + x);\r\n} else {\r\nbIsLegalPage = PlatformIOCheckPageLegalAndGetRegMask(u4bPage,\r\n&u1PageMask);\r\nif (bIsLegalPage) {\r\nu8 u1bPsr = read_nic_io_byte(dev, PSR);\r\nwrite_nic_io_byte(dev, PSR, ((u1bPsr & u1PageMask) |\r\n(u8)u4bPage));\r\nwrite_nic_io_byte(dev, (x & 0xff), y);\r\nwrite_nic_io_byte(dev, PSR, (u1bPsr & u1PageMask));\r\n}\r\n}\r\n}\r\nvoid write_nic_io_word(struct net_device *dev, int x, u16 y)\r\n{\r\nu32 u4bPage = (x >> 8);\r\nu8 u1PageMask = 0;\r\nbool bIsLegalPage = false;\r\nif (u4bPage == 0) {\r\noutw(y, dev->base_addr + x);\r\n} else {\r\nbIsLegalPage = PlatformIOCheckPageLegalAndGetRegMask(u4bPage,\r\n&u1PageMask);\r\nif (bIsLegalPage) {\r\nu8 u1bPsr = read_nic_io_byte(dev, PSR);\r\nwrite_nic_io_byte(dev, PSR, ((u1bPsr & u1PageMask) |\r\n(u8)u4bPage));\r\nwrite_nic_io_word(dev, (x & 0xff), y);\r\nwrite_nic_io_byte(dev, PSR, (u1bPsr & u1PageMask));\r\n}\r\n}\r\n}\r\nvoid write_nic_io_dword(struct net_device *dev, int x, u32 y)\r\n{\r\nu32 u4bPage = (x >> 8);\r\nu8 u1PageMask = 0;\r\nbool bIsLegalPage = false;\r\nif (u4bPage == 0) {\r\noutl(y, dev->base_addr + x);\r\n} else {\r\nbIsLegalPage = PlatformIOCheckPageLegalAndGetRegMask(u4bPage,\r\n&u1PageMask);\r\nif (bIsLegalPage) {\r\nu8 u1bPsr = read_nic_io_byte(dev, PSR);\r\nwrite_nic_io_byte(dev, PSR, ((u1bPsr & u1PageMask) |\r\n(u8)u4bPage));\r\nwrite_nic_io_dword(dev, (x & 0xff), y);\r\nwrite_nic_io_byte(dev, PSR, (u1bPsr & u1PageMask));\r\n}\r\n}\r\n}\r\nu8 read_nic_io_byte(struct net_device *dev, int x)\r\n{\r\nu32 u4bPage = (x >> 8);\r\nu8 u1PageMask = 0;\r\nbool bIsLegalPage = false;\r\nu8 Data = 0;\r\nif (u4bPage == 0) {\r\nreturn 0xff&inb(dev->base_addr + x);\r\n} else {\r\nbIsLegalPage = PlatformIOCheckPageLegalAndGetRegMask(u4bPage,\r\n&u1PageMask);\r\nif (bIsLegalPage) {\r\nu8 u1bPsr = read_nic_io_byte(dev, PSR);\r\nwrite_nic_io_byte(dev, PSR, ((u1bPsr & u1PageMask) |\r\n(u8)u4bPage));\r\nData = read_nic_io_byte(dev, (x & 0xff));\r\nwrite_nic_io_byte(dev, PSR, (u1bPsr & u1PageMask));\r\n}\r\n}\r\nreturn Data;\r\n}\r\nu16 read_nic_io_word(struct net_device *dev, int x)\r\n{\r\nu32 u4bPage = (x >> 8);\r\nu8 u1PageMask = 0;\r\nbool bIsLegalPage = false;\r\nu16 Data = 0;\r\nif (u4bPage == 0) {\r\nreturn inw(dev->base_addr + x);\r\n} else {\r\nbIsLegalPage = PlatformIOCheckPageLegalAndGetRegMask(u4bPage,\r\n&u1PageMask);\r\nif (bIsLegalPage) {\r\nu8 u1bPsr = read_nic_io_byte(dev, PSR);\r\nwrite_nic_io_byte(dev, PSR, ((u1bPsr & u1PageMask) |\r\n(u8)u4bPage));\r\nData = read_nic_io_word(dev, (x & 0xff));\r\nwrite_nic_io_byte(dev, PSR, (u1bPsr & u1PageMask));\r\n}\r\n}\r\nreturn Data;\r\n}\r\nu32 read_nic_io_dword(struct net_device *dev, int x)\r\n{\r\nu32 u4bPage = (x >> 8);\r\nu8 u1PageMask = 0;\r\nbool bIsLegalPage = false;\r\nu32 Data = 0;\r\nif (u4bPage == 0) {\r\nreturn inl(dev->base_addr + x);\r\n} else {\r\nbIsLegalPage = PlatformIOCheckPageLegalAndGetRegMask(u4bPage,\r\n&u1PageMask);\r\nif (bIsLegalPage) {\r\nu8 u1bPsr = read_nic_io_byte(dev, PSR);\r\nwrite_nic_io_byte(dev, PSR, ((u1bPsr & u1PageMask) |\r\n(u8)u4bPage));\r\nData = read_nic_io_dword(dev, (x & 0xff));\r\nwrite_nic_io_byte(dev, PSR, (u1bPsr & u1PageMask));\r\n}\r\n}\r\nreturn Data;\r\n}\r\nu8 read_nic_byte(struct net_device *dev, int x)\r\n{\r\nreturn 0xff & readb((u8 __iomem *)dev->mem_start + x);\r\n}\r\nu32 read_nic_dword(struct net_device *dev, int x)\r\n{\r\nreturn readl((u8 __iomem *)dev->mem_start + x);\r\n}\r\nu16 read_nic_word(struct net_device *dev, int x)\r\n{\r\nreturn readw((u8 __iomem *)dev->mem_start + x);\r\n}\r\nvoid write_nic_byte(struct net_device *dev, int x, u8 y)\r\n{\r\nwriteb(y, (u8 __iomem *)dev->mem_start + x);\r\nudelay(20);\r\n}\r\nvoid write_nic_dword(struct net_device *dev, int x, u32 y)\r\n{\r\nwritel(y, (u8 __iomem *)dev->mem_start + x);\r\nudelay(20);\r\n}\r\nvoid write_nic_word(struct net_device *dev, int x, u16 y)\r\n{\r\nwritew(y, (u8 __iomem *)dev->mem_start + x);\r\nudelay(20);\r\n}\r\nbool MgntActSet_RF_State(struct net_device *dev,\r\nenum rt_rf_power_state StateToSet,\r\nRT_RF_CHANGE_SOURCE ChangeSource,\r\nbool ProtectOrNot)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nstruct rtllib_device *ieee = priv->rtllib;\r\nbool bActionAllowed = false;\r\nbool bConnectBySSID = false;\r\nenum rt_rf_power_state rtState;\r\nu16 RFWaitCounter = 0;\r\nunsigned long flag;\r\nRT_TRACE((COMP_PS | COMP_RF), "===>MgntActSet_RF_State(): "\r\n"StateToSet(%d)\n", StateToSet);\r\nProtectOrNot = false;\r\nif (!ProtectOrNot) {\r\nwhile (true) {\r\nspin_lock_irqsave(&priv->rf_ps_lock, flag);\r\nif (priv->RFChangeInProgress) {\r\nspin_unlock_irqrestore(&priv->rf_ps_lock, flag);\r\nRT_TRACE((COMP_PS | COMP_RF),\r\n"MgntActSet_RF_State(): RF Change in "\r\n"progress! Wait to set..StateToSet"\r\n"(%d).\n", StateToSet);\r\nwhile (priv->RFChangeInProgress) {\r\nRFWaitCounter++;\r\nRT_TRACE((COMP_PS | COMP_RF),\r\n"MgntActSet_RF_State(): Wait 1"\r\n" ms (%d times)...\n",\r\nRFWaitCounter);\r\nmdelay(1);\r\nif (RFWaitCounter > 100) {\r\nRT_TRACE(COMP_ERR, "MgntActSet_"\r\n"RF_State(): Wait too "\r\n"logn to set RF\n");\r\nreturn false;\r\n}\r\n}\r\n} else {\r\npriv->RFChangeInProgress = true;\r\nspin_unlock_irqrestore(&priv->rf_ps_lock, flag);\r\nbreak;\r\n}\r\n}\r\n}\r\nrtState = priv->rtllib->eRFPowerState;\r\nswitch (StateToSet) {\r\ncase eRfOn:\r\npriv->rtllib->RfOffReason &= (~ChangeSource);\r\nif ((ChangeSource == RF_CHANGE_BY_HW) &&\r\n(priv->bHwRadioOff == true))\r\npriv->bHwRadioOff = false;\r\nif (!priv->rtllib->RfOffReason) {\r\npriv->rtllib->RfOffReason = 0;\r\nbActionAllowed = true;\r\nif (rtState == eRfOff &&\r\nChangeSource >= RF_CHANGE_BY_HW)\r\nbConnectBySSID = true;\r\n} else {\r\nRT_TRACE((COMP_PS | COMP_RF), "MgntActSet_RF_State - "\r\n"eRfon reject pMgntInfo->RfOffReason= 0x%x,"\r\n" ChangeSource=0x%X\n",\r\npriv->rtllib->RfOffReason, ChangeSource);\r\n}\r\nbreak;\r\ncase eRfOff:\r\nif ((priv->rtllib->iw_mode == IW_MODE_INFRA) ||\r\n(priv->rtllib->iw_mode == IW_MODE_ADHOC)) {\r\nif ((priv->rtllib->RfOffReason > RF_CHANGE_BY_IPS) ||\r\n(ChangeSource > RF_CHANGE_BY_IPS)) {\r\nif (ieee->state == RTLLIB_LINKED)\r\npriv->blinked_ingpio = true;\r\nelse\r\npriv->blinked_ingpio = false;\r\nrtllib_MgntDisconnect(priv->rtllib,\r\ndisas_lv_ss);\r\n}\r\n}\r\nif ((ChangeSource == RF_CHANGE_BY_HW) &&\r\n(priv->bHwRadioOff == false))\r\npriv->bHwRadioOff = true;\r\npriv->rtllib->RfOffReason |= ChangeSource;\r\nbActionAllowed = true;\r\nbreak;\r\ncase eRfSleep:\r\npriv->rtllib->RfOffReason |= ChangeSource;\r\nbActionAllowed = true;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif (bActionAllowed) {\r\nRT_TRACE((COMP_PS | COMP_RF), "MgntActSet_RF_State(): Action is"\r\n" allowed.... StateToSet(%d), RfOffReason(%#X)\n",\r\nStateToSet, priv->rtllib->RfOffReason);\r\nPHY_SetRFPowerState(dev, StateToSet);\r\nif (StateToSet == eRfOn) {\r\nif (bConnectBySSID && (priv->blinked_ingpio == true)) {\r\nqueue_delayed_work_rsl(ieee->wq,\r\n&ieee->associate_procedure_wq, 0);\r\npriv->blinked_ingpio = false;\r\n}\r\n}\r\n} else {\r\nRT_TRACE((COMP_PS | COMP_RF), "MgntActSet_RF_State(): "\r\n"Action is rejected.... StateToSet(%d), ChangeSource"\r\n"(%#X), RfOffReason(%#X)\n", StateToSet, ChangeSource,\r\npriv->rtllib->RfOffReason);\r\n}\r\nif (!ProtectOrNot) {\r\nspin_lock_irqsave(&priv->rf_ps_lock, flag);\r\npriv->RFChangeInProgress = false;\r\nspin_unlock_irqrestore(&priv->rf_ps_lock, flag);\r\n}\r\nRT_TRACE((COMP_PS | COMP_RF), "<===MgntActSet_RF_State()\n");\r\nreturn bActionAllowed;\r\n}\r\nstatic short rtl8192_get_nic_desc_num(struct net_device *dev, int prio)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nstruct rtl8192_tx_ring *ring = &priv->tx_ring[prio];\r\nif ((prio == MGNT_QUEUE) && (skb_queue_len(&ring->queue) > 10))\r\nRT_TRACE(COMP_DBG, "-----[%d]---------ring->idx=%d "\r\n"queue_len=%d---------\n", prio, ring->idx,\r\nskb_queue_len(&ring->queue));\r\nreturn skb_queue_len(&ring->queue);\r\n}\r\nstatic short rtl8192_check_nic_enough_desc(struct net_device *dev, int prio)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nstruct rtl8192_tx_ring *ring = &priv->tx_ring[prio];\r\nif (ring->entries - skb_queue_len(&ring->queue) >= 2)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nvoid rtl8192_tx_timeout(struct net_device *dev)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nschedule_work(&priv->reset_wq);\r\nprintk(KERN_INFO "TXTIMEOUT");\r\n}\r\nvoid rtl8192_irq_enable(struct net_device *dev)\r\n{\r\nstruct r8192_priv *priv = (struct r8192_priv *)rtllib_priv(dev);\r\npriv->irq_enabled = 1;\r\npriv->ops->irq_enable(dev);\r\n}\r\nvoid rtl8192_irq_disable(struct net_device *dev)\r\n{\r\nstruct r8192_priv *priv = (struct r8192_priv *)rtllib_priv(dev);\r\npriv->ops->irq_disable(dev);\r\npriv->irq_enabled = 0;\r\n}\r\nvoid rtl8192_set_chan(struct net_device *dev, short ch)\r\n{\r\nstruct r8192_priv *priv = (struct r8192_priv *)rtllib_priv(dev);\r\nRT_TRACE(COMP_CH, "=====>%s()====ch:%d\n", __func__, ch);\r\nif (priv->chan_forced)\r\nreturn;\r\npriv->chan = ch;\r\nif (priv->rf_set_chan)\r\npriv->rf_set_chan(dev, priv->chan);\r\n}\r\nvoid rtl8192_update_cap(struct net_device *dev, u16 cap)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nstruct rtllib_network *net = &priv->rtllib->current_network;\r\nbool ShortPreamble;\r\nif (cap & WLAN_CAPABILITY_SHORT_PREAMBLE) {\r\nif (priv->dot11CurrentPreambleMode != PREAMBLE_SHORT) {\r\nShortPreamble = true;\r\npriv->dot11CurrentPreambleMode = PREAMBLE_SHORT;\r\nRT_TRACE(COMP_DBG, "%s(): WLAN_CAPABILITY_SHORT_"\r\n"PREAMBLE\n", __func__);\r\npriv->rtllib->SetHwRegHandler(dev, HW_VAR_ACK_PREAMBLE,\r\n(unsigned char *)&ShortPreamble);\r\n}\r\n} else {\r\nif (priv->dot11CurrentPreambleMode != PREAMBLE_LONG) {\r\nShortPreamble = false;\r\npriv->dot11CurrentPreambleMode = PREAMBLE_LONG;\r\nRT_TRACE(COMP_DBG, "%s(): WLAN_CAPABILITY_LONG_"\r\n"PREAMBLE\n", __func__);\r\npriv->rtllib->SetHwRegHandler(dev, HW_VAR_ACK_PREAMBLE,\r\n(unsigned char *)&ShortPreamble);\r\n}\r\n}\r\nif (net->mode & (IEEE_G|IEEE_N_24G)) {\r\nu8 slot_time_val;\r\nu8 CurSlotTime = priv->slot_time;\r\nif ((cap & WLAN_CAPABILITY_SHORT_SLOT_TIME) &&\r\n(!priv->rtllib->pHTInfo->bCurrentRT2RTLongSlotTime)) {\r\nif (CurSlotTime != SHORT_SLOT_TIME) {\r\nslot_time_val = SHORT_SLOT_TIME;\r\npriv->rtllib->SetHwRegHandler(dev,\r\nHW_VAR_SLOT_TIME, &slot_time_val);\r\n}\r\n} else {\r\nif (CurSlotTime != NON_SHORT_SLOT_TIME) {\r\nslot_time_val = NON_SHORT_SLOT_TIME;\r\npriv->rtllib->SetHwRegHandler(dev,\r\nHW_VAR_SLOT_TIME, &slot_time_val);\r\n}\r\n}\r\n}\r\n}\r\nstatic void rtl8192_update_beacon(void *data)\r\n{\r\nstruct r8192_priv *priv = container_of_work_rsl(data, struct r8192_priv,\r\nupdate_beacon_wq.work);\r\nstruct net_device *dev = priv->rtllib->dev;\r\nstruct rtllib_device *ieee = priv->rtllib;\r\nstruct rtllib_network *net = &ieee->current_network;\r\nif (ieee->pHTInfo->bCurrentHTSupport)\r\nHT_update_self_and_peer_setting(ieee, net);\r\nieee->pHTInfo->bCurrentRT2RTLongSlotTime =\r\nnet->bssht.bdRT2RTLongSlotTime;\r\nieee->pHTInfo->RT2RT_HT_Mode = net->bssht.RT2RT_HT_Mode;\r\nrtl8192_update_cap(dev, net->capability);\r\n}\r\nstatic void rtl8192_qos_activate(void *data)\r\n{\r\nstruct r8192_priv *priv = container_of_work_rsl(data, struct r8192_priv,\r\nqos_activate);\r\nstruct net_device *dev = priv->rtllib->dev;\r\nint i;\r\nmutex_lock(&priv->mutex);\r\nif (priv->rtllib->state != RTLLIB_LINKED)\r\ngoto success;\r\nRT_TRACE(COMP_QOS, "qos active process with associate response "\r\n"received\n");\r\nfor (i = 0; i < QOS_QUEUE_NUM; i++) {\r\npriv->rtllib->SetHwRegHandler(dev, HW_VAR_AC_PARAM, (u8 *)(&i));\r\n}\r\nsuccess:\r\nmutex_unlock(&priv->mutex);\r\n}\r\nstatic int rtl8192_qos_handle_probe_response(struct r8192_priv *priv,\r\nint active_network,\r\nstruct rtllib_network *network)\r\n{\r\nint ret = 0;\r\nu32 size = sizeof(struct rtllib_qos_parameters);\r\nif (priv->rtllib->state != RTLLIB_LINKED)\r\nreturn ret;\r\nif ((priv->rtllib->iw_mode != IW_MODE_INFRA))\r\nreturn ret;\r\nif (network->flags & NETWORK_HAS_QOS_MASK) {\r\nif (active_network &&\r\n(network->flags & NETWORK_HAS_QOS_PARAMETERS))\r\nnetwork->qos_data.active = network->qos_data.supported;\r\nif ((network->qos_data.active == 1) && (active_network == 1) &&\r\n(network->flags & NETWORK_HAS_QOS_PARAMETERS) &&\r\n(network->qos_data.old_param_count !=\r\nnetwork->qos_data.param_count)) {\r\nnetwork->qos_data.old_param_count =\r\nnetwork->qos_data.param_count;\r\npriv->rtllib->wmm_acm = network->qos_data.wmm_acm;\r\nqueue_work_rsl(priv->priv_wq, &priv->qos_activate);\r\nRT_TRACE(COMP_QOS, "QoS parameters change call "\r\n"qos_activate\n");\r\n}\r\n} else {\r\nmemcpy(&priv->rtllib->current_network.qos_data.parameters,\r\n&def_qos_parameters, size);\r\nif ((network->qos_data.active == 1) && (active_network == 1)) {\r\nqueue_work_rsl(priv->priv_wq, &priv->qos_activate);\r\nRT_TRACE(COMP_QOS, "QoS was disabled call qos_"\r\n"activate\n");\r\n}\r\nnetwork->qos_data.active = 0;\r\nnetwork->qos_data.supported = 0;\r\n}\r\nreturn 0;\r\n}\r\nstatic int rtl8192_handle_beacon(struct net_device *dev,\r\nstruct rtllib_beacon *beacon,\r\nstruct rtllib_network *network)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nrtl8192_qos_handle_probe_response(priv, 1, network);\r\nqueue_delayed_work_rsl(priv->priv_wq, &priv->update_beacon_wq, 0);\r\nreturn 0;\r\n}\r\nstatic int rtl8192_qos_association_resp(struct r8192_priv *priv,\r\nstruct rtllib_network *network)\r\n{\r\nint ret = 0;\r\nunsigned long flags;\r\nu32 size = sizeof(struct rtllib_qos_parameters);\r\nint set_qos_param = 0;\r\nif ((priv == NULL) || (network == NULL))\r\nreturn ret;\r\nif (priv->rtllib->state != RTLLIB_LINKED)\r\nreturn ret;\r\nif ((priv->rtllib->iw_mode != IW_MODE_INFRA))\r\nreturn ret;\r\nspin_lock_irqsave(&priv->rtllib->lock, flags);\r\nif (network->flags & NETWORK_HAS_QOS_PARAMETERS) {\r\nmemcpy(&priv->rtllib->current_network.qos_data.parameters,\r\n&network->qos_data.parameters,\r\nsizeof(struct rtllib_qos_parameters));\r\npriv->rtllib->current_network.qos_data.active = 1;\r\npriv->rtllib->wmm_acm = network->qos_data.wmm_acm;\r\nset_qos_param = 1;\r\npriv->rtllib->current_network.qos_data.old_param_count =\r\npriv->rtllib->current_network.qos_data.param_count;\r\npriv->rtllib->current_network.qos_data.param_count =\r\nnetwork->qos_data.param_count;\r\n} else {\r\nmemcpy(&priv->rtllib->current_network.qos_data.parameters,\r\n&def_qos_parameters, size);\r\npriv->rtllib->current_network.qos_data.active = 0;\r\npriv->rtllib->current_network.qos_data.supported = 0;\r\nset_qos_param = 1;\r\n}\r\nspin_unlock_irqrestore(&priv->rtllib->lock, flags);\r\nRT_TRACE(COMP_QOS, "%s: network->flags = %d,%d\n", __func__,\r\nnetwork->flags, priv->rtllib->current_network.qos_data.active);\r\nif (set_qos_param == 1) {\r\ndm_init_edca_turbo(priv->rtllib->dev);\r\nqueue_work_rsl(priv->priv_wq, &priv->qos_activate);\r\n}\r\nreturn ret;\r\n}\r\nstatic int rtl8192_handle_assoc_response(struct net_device *dev,\r\nstruct rtllib_assoc_response_frame *resp,\r\nstruct rtllib_network *network)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nrtl8192_qos_association_resp(priv, network);\r\nreturn 0;\r\n}\r\nstatic void rtl8192_prepare_beacon(struct r8192_priv *priv)\r\n{\r\nstruct net_device *dev = priv->rtllib->dev;\r\nstruct sk_buff *pskb = NULL, *pnewskb = NULL;\r\nstruct cb_desc *tcb_desc = NULL;\r\nstruct rtl8192_tx_ring *ring = NULL;\r\nstruct tx_desc *pdesc = NULL;\r\nring = &priv->tx_ring[BEACON_QUEUE];\r\npskb = __skb_dequeue(&ring->queue);\r\nkfree_skb(pskb);\r\npnewskb = rtllib_get_beacon(priv->rtllib);\r\nif (!pnewskb)\r\nreturn;\r\ntcb_desc = (struct cb_desc *)(pnewskb->cb + 8);\r\ntcb_desc->queue_index = BEACON_QUEUE;\r\ntcb_desc->data_rate = 2;\r\ntcb_desc->RATRIndex = 7;\r\ntcb_desc->bTxDisableRateFallBack = 1;\r\ntcb_desc->bTxUseDriverAssingedRate = 1;\r\nskb_push(pnewskb, priv->rtllib->tx_headroom);\r\npdesc = &ring->desc[0];\r\npriv->ops->tx_fill_descriptor(dev, pdesc, tcb_desc, pnewskb);\r\n__skb_queue_tail(&ring->queue, pnewskb);\r\npdesc->OWN = 1;\r\nreturn;\r\n}\r\nstatic void rtl8192_stop_beacon(struct net_device *dev)\r\n{\r\n}\r\nvoid rtl8192_config_rate(struct net_device *dev, u16 *rate_config)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nstruct rtllib_network *net;\r\nu8 i = 0, basic_rate = 0;\r\nnet = &priv->rtllib->current_network;\r\nfor (i = 0; i < net->rates_len; i++) {\r\nbasic_rate = net->rates[i] & 0x7f;\r\nswitch (basic_rate) {\r\ncase MGN_1M:\r\n*rate_config |= RRSR_1M;\r\nbreak;\r\ncase MGN_2M:\r\n*rate_config |= RRSR_2M;\r\nbreak;\r\ncase MGN_5_5M:\r\n*rate_config |= RRSR_5_5M;\r\nbreak;\r\ncase MGN_11M:\r\n*rate_config |= RRSR_11M;\r\nbreak;\r\ncase MGN_6M:\r\n*rate_config |= RRSR_6M;\r\nbreak;\r\ncase MGN_9M:\r\n*rate_config |= RRSR_9M;\r\nbreak;\r\ncase MGN_12M:\r\n*rate_config |= RRSR_12M;\r\nbreak;\r\ncase MGN_18M:\r\n*rate_config |= RRSR_18M;\r\nbreak;\r\ncase MGN_24M:\r\n*rate_config |= RRSR_24M;\r\nbreak;\r\ncase MGN_36M:\r\n*rate_config |= RRSR_36M;\r\nbreak;\r\ncase MGN_48M:\r\n*rate_config |= RRSR_48M;\r\nbreak;\r\ncase MGN_54M:\r\n*rate_config |= RRSR_54M;\r\nbreak;\r\n}\r\n}\r\nfor (i = 0; i < net->rates_ex_len; i++) {\r\nbasic_rate = net->rates_ex[i] & 0x7f;\r\nswitch (basic_rate) {\r\ncase MGN_1M:\r\n*rate_config |= RRSR_1M;\r\nbreak;\r\ncase MGN_2M:\r\n*rate_config |= RRSR_2M;\r\nbreak;\r\ncase MGN_5_5M:\r\n*rate_config |= RRSR_5_5M;\r\nbreak;\r\ncase MGN_11M:\r\n*rate_config |= RRSR_11M;\r\nbreak;\r\ncase MGN_6M:\r\n*rate_config |= RRSR_6M;\r\nbreak;\r\ncase MGN_9M:\r\n*rate_config |= RRSR_9M;\r\nbreak;\r\ncase MGN_12M:\r\n*rate_config |= RRSR_12M;\r\nbreak;\r\ncase MGN_18M:\r\n*rate_config |= RRSR_18M;\r\nbreak;\r\ncase MGN_24M:\r\n*rate_config |= RRSR_24M;\r\nbreak;\r\ncase MGN_36M:\r\n*rate_config |= RRSR_36M;\r\nbreak;\r\ncase MGN_48M:\r\n*rate_config |= RRSR_48M;\r\nbreak;\r\ncase MGN_54M:\r\n*rate_config |= RRSR_54M;\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic void rtl8192_refresh_supportrate(struct r8192_priv *priv)\r\n{\r\nstruct rtllib_device *ieee = priv->rtllib;\r\nif (ieee->mode == WIRELESS_MODE_N_24G ||\r\nieee->mode == WIRELESS_MODE_N_5G) {\r\nmemcpy(ieee->Regdot11HTOperationalRateSet,\r\nieee->RegHTSuppRateSet, 16);\r\nmemcpy(ieee->Regdot11TxHTOperationalRateSet,\r\nieee->RegHTSuppRateSet, 16);\r\n} else {\r\nmemset(ieee->Regdot11HTOperationalRateSet, 0, 16);\r\n}\r\nreturn;\r\n}\r\nstatic u8 rtl8192_getSupportedWireleeMode(struct net_device *dev)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nu8 ret = 0;\r\nswitch (priv->rf_chip) {\r\ncase RF_8225:\r\ncase RF_8256:\r\ncase RF_6052:\r\ncase RF_PSEUDO_11N:\r\nret = (WIRELESS_MODE_N_24G|WIRELESS_MODE_G | WIRELESS_MODE_B);\r\nbreak;\r\ncase RF_8258:\r\nret = (WIRELESS_MODE_A | WIRELESS_MODE_N_5G);\r\nbreak;\r\ndefault:\r\nret = WIRELESS_MODE_B;\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nvoid rtl8192_SetWirelessMode(struct net_device *dev, u8 wireless_mode)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nu8 bSupportMode = rtl8192_getSupportedWireleeMode(dev);\r\nif ((wireless_mode == WIRELESS_MODE_AUTO) ||\r\n((wireless_mode & bSupportMode) == 0)) {\r\nif (bSupportMode & WIRELESS_MODE_N_24G) {\r\nwireless_mode = WIRELESS_MODE_N_24G;\r\n} else if (bSupportMode & WIRELESS_MODE_N_5G) {\r\nwireless_mode = WIRELESS_MODE_N_5G;\r\n} else if ((bSupportMode & WIRELESS_MODE_A)) {\r\nwireless_mode = WIRELESS_MODE_A;\r\n} else if ((bSupportMode & WIRELESS_MODE_G)) {\r\nwireless_mode = WIRELESS_MODE_G;\r\n} else if ((bSupportMode & WIRELESS_MODE_B)) {\r\nwireless_mode = WIRELESS_MODE_B;\r\n} else {\r\nRT_TRACE(COMP_ERR, "%s(), No valid wireless mode "\r\n"supported (%x)!!!\n", __func__, bSupportMode);\r\nwireless_mode = WIRELESS_MODE_B;\r\n}\r\n}\r\nif ((wireless_mode & (WIRELESS_MODE_B | WIRELESS_MODE_G)) ==\r\n(WIRELESS_MODE_G | WIRELESS_MODE_B))\r\nwireless_mode = WIRELESS_MODE_G;\r\npriv->rtllib->mode = wireless_mode;\r\nActUpdateChannelAccessSetting(dev, wireless_mode,\r\n&priv->ChannelAccessSetting);\r\nif ((wireless_mode == WIRELESS_MODE_N_24G) ||\r\n(wireless_mode == WIRELESS_MODE_N_5G)) {\r\npriv->rtllib->pHTInfo->bEnableHT = 1;\r\nRT_TRACE(COMP_DBG, "%s(), wireless_mode:%x, bEnableHT = 1\n",\r\n__func__, wireless_mode);\r\n} else {\r\npriv->rtllib->pHTInfo->bEnableHT = 0;\r\nRT_TRACE(COMP_DBG, "%s(), wireless_mode:%x, bEnableHT = 0\n",\r\n__func__, wireless_mode);\r\n}\r\nRT_TRACE(COMP_INIT, "Current Wireless Mode is %x\n", wireless_mode);\r\nrtl8192_refresh_supportrate(priv);\r\n}\r\nstatic int _rtl8192_sta_up(struct net_device *dev, bool is_silent_reset)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nstruct rt_pwr_save_ctrl *pPSC = (struct rt_pwr_save_ctrl *)\r\n(&(priv->rtllib->PowerSaveControl));\r\nbool init_status = true;\r\npriv->bDriverIsGoingToUnload = false;\r\npriv->bdisable_nic = false;\r\npriv->up = 1;\r\npriv->rtllib->ieee_up = 1;\r\npriv->up_first_time = 0;\r\nRT_TRACE(COMP_INIT, "Bringing up iface");\r\npriv->bfirst_init = true;\r\ninit_status = priv->ops->initialize_adapter(dev);\r\nif (init_status != true) {\r\nRT_TRACE(COMP_ERR, "ERR!!! %s(): initialization is failed!\n",\r\n__func__);\r\npriv->bfirst_init = false;\r\nreturn -1;\r\n}\r\nRT_TRACE(COMP_INIT, "start adapter finished\n");\r\nRT_CLEAR_PS_LEVEL(pPSC, RT_RF_OFF_LEVL_HALT_NIC);\r\npriv->bfirst_init = false;\r\nif (priv->polling_timer_on == 0)\r\ncheck_rfctrl_gpio_timer((unsigned long)dev);\r\nif (priv->rtllib->state != RTLLIB_LINKED)\r\nrtllib_softmac_start_protocol(priv->rtllib, 0);\r\nrtllib_reset_queue(priv->rtllib);\r\nwatch_dog_timer_callback((unsigned long) dev);\r\nif (!netif_queue_stopped(dev))\r\nnetif_start_queue(dev);\r\nelse\r\nnetif_wake_queue(dev);\r\nreturn 0;\r\n}\r\nstatic int rtl8192_sta_down(struct net_device *dev, bool shutdownrf)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nunsigned long flags = 0;\r\nu8 RFInProgressTimeOut = 0;\r\nif (priv->up == 0)\r\nreturn -1;\r\nif (priv->rtllib->rtllib_ips_leave != NULL)\r\npriv->rtllib->rtllib_ips_leave(dev);\r\nif (priv->rtllib->state == RTLLIB_LINKED)\r\nLeisurePSLeave(dev);\r\npriv->bDriverIsGoingToUnload = true;\r\npriv->up = 0;\r\npriv->rtllib->ieee_up = 0;\r\npriv->bfirst_after_down = 1;\r\nRT_TRACE(COMP_DOWN, "==========>%s()\n", __func__);\r\nif (!netif_queue_stopped(dev))\r\nnetif_stop_queue(dev);\r\npriv->rtllib->wpa_ie_len = 0;\r\nkfree(priv->rtllib->wpa_ie);\r\npriv->rtllib->wpa_ie = NULL;\r\nCamResetAllEntry(dev);\r\nmemset(priv->rtllib->swcamtable, 0, sizeof(struct sw_cam_table) * 32);\r\nrtl8192_irq_disable(dev);\r\ndel_timer_sync(&priv->watch_dog_timer);\r\nrtl8192_cancel_deferred_work(priv);\r\ncancel_delayed_work(&priv->rtllib->hw_wakeup_wq);\r\nrtllib_softmac_stop_protocol(priv->rtllib, 0, true);\r\nspin_lock_irqsave(&priv->rf_ps_lock, flags);\r\nwhile (priv->RFChangeInProgress) {\r\nspin_unlock_irqrestore(&priv->rf_ps_lock, flags);\r\nif (RFInProgressTimeOut > 100) {\r\nspin_lock_irqsave(&priv->rf_ps_lock, flags);\r\nbreak;\r\n}\r\nRT_TRACE(COMP_DBG, "===>%s():RF is in progress, need to wait "\r\n"until rf change is done.\n", __func__);\r\nmdelay(1);\r\nRFInProgressTimeOut++;\r\nspin_lock_irqsave(&priv->rf_ps_lock, flags);\r\n}\r\npriv->RFChangeInProgress = true;\r\nspin_unlock_irqrestore(&priv->rf_ps_lock, flags);\r\npriv->ops->stop_adapter(dev, false);\r\nspin_lock_irqsave(&priv->rf_ps_lock, flags);\r\npriv->RFChangeInProgress = false;\r\nspin_unlock_irqrestore(&priv->rf_ps_lock, flags);\r\nudelay(100);\r\nmemset(&priv->rtllib->current_network, 0,\r\noffsetof(struct rtllib_network, list));\r\nRT_TRACE(COMP_DOWN, "<==========%s()\n", __func__);\r\nreturn 0;\r\n}\r\nstatic void rtl8192_init_priv_handler(struct net_device *dev)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\npriv->rtllib->softmac_hard_start_xmit = rtl8192_hard_start_xmit;\r\npriv->rtllib->set_chan = rtl8192_set_chan;\r\npriv->rtllib->link_change = priv->ops->link_change;\r\npriv->rtllib->softmac_data_hard_start_xmit = rtl8192_hard_data_xmit;\r\npriv->rtllib->data_hard_stop = rtl8192_data_hard_stop;\r\npriv->rtllib->data_hard_resume = rtl8192_data_hard_resume;\r\npriv->rtllib->check_nic_enough_desc = rtl8192_check_nic_enough_desc;\r\npriv->rtllib->get_nic_desc_num = rtl8192_get_nic_desc_num;\r\npriv->rtllib->handle_assoc_response = rtl8192_handle_assoc_response;\r\npriv->rtllib->handle_beacon = rtl8192_handle_beacon;\r\npriv->rtllib->SetWirelessMode = rtl8192_SetWirelessMode;\r\npriv->rtllib->LeisurePSLeave = LeisurePSLeave;\r\npriv->rtllib->SetBWModeHandler = rtl8192_SetBWMode;\r\npriv->rf_set_chan = rtl8192_phy_SwChnl;\r\npriv->rtllib->start_send_beacons = rtl8192e_start_beacon;\r\npriv->rtllib->stop_send_beacons = rtl8192_stop_beacon;\r\npriv->rtllib->sta_wake_up = rtl8192_hw_wakeup;\r\npriv->rtllib->enter_sleep_state = rtl8192_hw_to_sleep;\r\npriv->rtllib->ps_is_queue_empty = rtl8192_is_tx_queue_empty;\r\npriv->rtllib->GetNmodeSupportBySecCfg = rtl8192_GetNmodeSupportBySecCfg;\r\npriv->rtllib->GetHalfNmodeSupportByAPsHandler =\r\nrtl8192_GetHalfNmodeSupportByAPs;\r\npriv->rtllib->SetHwRegHandler = rtl8192e_SetHwReg;\r\npriv->rtllib->AllowAllDestAddrHandler = rtl8192_AllowAllDestAddr;\r\npriv->rtllib->SetFwCmdHandler = NULL;\r\npriv->rtllib->InitialGainHandler = InitialGain819xPci;\r\npriv->rtllib->rtllib_ips_leave_wq = rtllib_ips_leave_wq;\r\npriv->rtllib->rtllib_ips_leave = rtllib_ips_leave;\r\npriv->rtllib->LedControlHandler = NULL;\r\npriv->rtllib->UpdateBeaconInterruptHandler = NULL;\r\npriv->rtllib->ScanOperationBackupHandler = PHY_ScanOperationBackup8192;\r\npriv->rtllib->rtllib_rfkill_poll = NULL;\r\n}\r\nstatic void rtl8192_init_priv_constant(struct net_device *dev)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nstruct rt_pwr_save_ctrl *pPSC = (struct rt_pwr_save_ctrl *)\r\n&(priv->rtllib->PowerSaveControl);\r\npPSC->RegMaxLPSAwakeIntvl = 5;\r\npriv->RegPciASPM = 2;\r\npriv->RegDevicePciASPMSetting = 0x03;\r\npriv->RegHostPciASPMSetting = 0x02;\r\npriv->RegHwSwRfOffD3 = 2;\r\npriv->RegSupportPciASPM = 2;\r\n}\r\nstatic void rtl8192_init_priv_variable(struct net_device *dev)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nu8 i;\r\npriv->AcmMethod = eAcmWay2_SW;\r\npriv->dot11CurrentPreambleMode = PREAMBLE_AUTO;\r\npriv->rtllib->hwscan_sem_up = 1;\r\npriv->rtllib->status = 0;\r\npriv->H2CTxCmdSeq = 0;\r\npriv->bDisableFrameBursting = 0;\r\npriv->bDMInitialGainEnable = 1;\r\npriv->polling_timer_on = 0;\r\npriv->up_first_time = 1;\r\npriv->blinked_ingpio = false;\r\npriv->bDriverIsGoingToUnload = false;\r\npriv->being_init_adapter = false;\r\npriv->initialized_at_probe = false;\r\npriv->sw_radio_on = true;\r\npriv->bdisable_nic = false;\r\npriv->bfirst_init = false;\r\npriv->txringcount = 64;\r\npriv->rxbuffersize = 9100;\r\npriv->rxringcount = MAX_RX_COUNT;\r\npriv->irq_enabled = 0;\r\npriv->chan = 1;\r\npriv->RegWirelessMode = WIRELESS_MODE_AUTO;\r\npriv->RegChannelPlan = 0xf;\r\npriv->nrxAMPDU_size = 0;\r\npriv->nrxAMPDU_aggr_num = 0;\r\npriv->last_rxdesc_tsf_high = 0;\r\npriv->last_rxdesc_tsf_low = 0;\r\npriv->rtllib->mode = WIRELESS_MODE_AUTO;\r\npriv->rtllib->iw_mode = IW_MODE_INFRA;\r\npriv->rtllib->bNetPromiscuousMode = false;\r\npriv->rtllib->IntelPromiscuousModeInfo.bPromiscuousOn = false;\r\npriv->rtllib->IntelPromiscuousModeInfo.bFilterSourceStationFrame =\r\nfalse;\r\npriv->rtllib->ieee_up = 0;\r\npriv->retry_rts = DEFAULT_RETRY_RTS;\r\npriv->retry_data = DEFAULT_RETRY_DATA;\r\npriv->rtllib->rts = DEFAULT_RTS_THRESHOLD;\r\npriv->rtllib->rate = 110;\r\npriv->rtllib->short_slot = 1;\r\npriv->promisc = (dev->flags & IFF_PROMISC) ? 1 : 0;\r\npriv->bcck_in_ch14 = false;\r\npriv->bfsync_processing = false;\r\npriv->CCKPresentAttentuation = 0;\r\npriv->rfa_txpowertrackingindex = 0;\r\npriv->rfc_txpowertrackingindex = 0;\r\npriv->CckPwEnl = 6;\r\npriv->ScanDelay = 50;\r\npriv->ResetProgress = RESET_TYPE_NORESET;\r\npriv->bForcedSilentReset = 0;\r\npriv->bDisableNormalResetCheck = false;\r\npriv->force_reset = false;\r\nmemset(priv->rtllib->swcamtable, 0, sizeof(struct sw_cam_table) * 32);\r\nmemset(&priv->InterruptLog, 0, sizeof(struct log_int_8190));\r\npriv->RxCounter = 0;\r\npriv->rtllib->wx_set_enc = 0;\r\npriv->bHwRadioOff = false;\r\npriv->RegRfOff = 0;\r\npriv->isRFOff = false;\r\npriv->bInPowerSaveMode = false;\r\npriv->rtllib->RfOffReason = 0;\r\npriv->RFChangeInProgress = false;\r\npriv->bHwRfOffAction = 0;\r\npriv->SetRFPowerStateInProgress = false;\r\npriv->rtllib->PowerSaveControl.bInactivePs = true;\r\npriv->rtllib->PowerSaveControl.bIPSModeBackup = false;\r\npriv->rtllib->PowerSaveControl.bLeisurePs = true;\r\npriv->rtllib->PowerSaveControl.bFwCtrlLPS = false;\r\npriv->rtllib->LPSDelayCnt = 0;\r\npriv->rtllib->sta_sleep = LPS_IS_WAKE;\r\npriv->rtllib->eRFPowerState = eRfOn;\r\npriv->txpower_checkcnt = 0;\r\npriv->thermal_readback_index = 0;\r\npriv->txpower_tracking_callback_cnt = 0;\r\npriv->ccktxpower_adjustcnt_ch14 = 0;\r\npriv->ccktxpower_adjustcnt_not_ch14 = 0;\r\npriv->rtllib->current_network.beacon_interval = DEFAULT_BEACONINTERVAL;\r\npriv->rtllib->iw_mode = IW_MODE_INFRA;\r\npriv->rtllib->active_scan = 1;\r\npriv->rtllib->be_scan_inprogress = false;\r\npriv->rtllib->modulation = RTLLIB_CCK_MODULATION |\r\nRTLLIB_OFDM_MODULATION;\r\npriv->rtllib->host_encrypt = 1;\r\npriv->rtllib->host_decrypt = 1;\r\npriv->rtllib->dot11PowerSaveMode = eActive;\r\npriv->rtllib->fts = DEFAULT_FRAG_THRESHOLD;\r\npriv->rtllib->MaxMssDensity = 0;\r\npriv->rtllib->MinSpaceCfg = 0;\r\npriv->card_type = PCI;\r\npriv->AcmControl = 0;\r\npriv->pFirmware = vzalloc(sizeof(struct rt_firmware));\r\nif (!priv->pFirmware)\r\nprintk(KERN_ERR "rtl8192e: Unable to allocate space "\r\n"for firmware\n");\r\nskb_queue_head_init(&priv->rx_queue);\r\nskb_queue_head_init(&priv->skb_queue);\r\nfor (i = 0; i < MAX_QUEUE_SIZE; i++)\r\nskb_queue_head_init(&priv->rtllib->skb_waitQ[i]);\r\nfor (i = 0; i < MAX_QUEUE_SIZE; i++)\r\nskb_queue_head_init(&priv->rtllib->skb_aggQ[i]);\r\n}\r\nstatic void rtl8192_init_priv_lock(struct r8192_priv *priv)\r\n{\r\nspin_lock_init(&priv->fw_scan_lock);\r\nspin_lock_init(&priv->tx_lock);\r\nspin_lock_init(&priv->irq_lock);\r\nspin_lock_init(&priv->irq_th_lock);\r\nspin_lock_init(&priv->rf_ps_lock);\r\nspin_lock_init(&priv->ps_lock);\r\nspin_lock_init(&priv->rf_lock);\r\nspin_lock_init(&priv->rt_h2c_lock);\r\nsema_init(&priv->wx_sem, 1);\r\nsema_init(&priv->rf_sem, 1);\r\nmutex_init(&priv->mutex);\r\n}\r\nstatic void rtl8192_init_priv_task(struct net_device *dev)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\npriv->priv_wq = create_workqueue(DRV_NAME);\r\nINIT_WORK_RSL(&priv->reset_wq, (void *)rtl8192_restart, dev);\r\nINIT_WORK_RSL(&priv->rtllib->ips_leave_wq, (void *)IPSLeave_wq, dev);\r\nINIT_DELAYED_WORK_RSL(&priv->watch_dog_wq,\r\n(void *)rtl819x_watchdog_wqcallback, dev);\r\nINIT_DELAYED_WORK_RSL(&priv->txpower_tracking_wq,\r\n(void *)dm_txpower_trackingcallback, dev);\r\nINIT_DELAYED_WORK_RSL(&priv->rfpath_check_wq,\r\n(void *)dm_rf_pathcheck_workitemcallback, dev);\r\nINIT_DELAYED_WORK_RSL(&priv->update_beacon_wq,\r\n(void *)rtl8192_update_beacon, dev);\r\nINIT_WORK_RSL(&priv->qos_activate, (void *)rtl8192_qos_activate, dev);\r\nINIT_DELAYED_WORK_RSL(&priv->rtllib->hw_wakeup_wq,\r\n(void *) rtl8192_hw_wakeup_wq, dev);\r\nINIT_DELAYED_WORK_RSL(&priv->rtllib->hw_sleep_wq,\r\n(void *) rtl8192_hw_sleep_wq, dev);\r\ntasklet_init(&priv->irq_rx_tasklet,\r\n(void(*)(unsigned long))rtl8192_irq_rx_tasklet,\r\n(unsigned long)priv);\r\ntasklet_init(&priv->irq_tx_tasklet,\r\n(void(*)(unsigned long))rtl8192_irq_tx_tasklet,\r\n(unsigned long)priv);\r\ntasklet_init(&priv->irq_prepare_beacon_tasklet,\r\n(void(*)(unsigned long))rtl8192_prepare_beacon,\r\n(unsigned long)priv);\r\n}\r\nstatic short rtl8192_get_channel_map(struct net_device *dev)\r\n{\r\nint i;\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nif ((priv->rf_chip != RF_8225) && (priv->rf_chip != RF_8256)\r\n&& (priv->rf_chip != RF_6052)) {\r\nRT_TRACE(COMP_ERR, "%s: unknown rf chip, can't set channel "\r\n"map\n", __func__);\r\nreturn -1;\r\n}\r\nif (priv->ChannelPlan >= COUNTRY_CODE_MAX) {\r\nprintk(KERN_INFO "rtl819x_init:Error channel plan! Set to "\r\n"default.\n");\r\npriv->ChannelPlan = COUNTRY_CODE_FCC;\r\n}\r\nRT_TRACE(COMP_INIT, "Channel plan is %d\n", priv->ChannelPlan);\r\ndot11d_init(priv->rtllib);\r\nDot11d_Channelmap(priv->ChannelPlan, priv->rtllib);\r\nfor (i = 1; i <= 11; i++)\r\n(priv->rtllib->active_channel_map)[i] = 1;\r\n(priv->rtllib->active_channel_map)[12] = 2;\r\n(priv->rtllib->active_channel_map)[13] = 2;\r\nreturn 0;\r\n}\r\nstatic short rtl8192_init(struct net_device *dev)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nmemset(&(priv->stats), 0, sizeof(struct rt_stats));\r\nrtl8192_init_priv_handler(dev);\r\nrtl8192_init_priv_constant(dev);\r\nrtl8192_init_priv_variable(dev);\r\nrtl8192_init_priv_lock(priv);\r\nrtl8192_init_priv_task(dev);\r\npriv->ops->get_eeprom_size(dev);\r\npriv->ops->init_adapter_variable(dev);\r\nrtl8192_get_channel_map(dev);\r\ninit_hal_dm(dev);\r\ninit_timer(&priv->watch_dog_timer);\r\nsetup_timer(&priv->watch_dog_timer,\r\nwatch_dog_timer_callback,\r\n(unsigned long) dev);\r\ninit_timer(&priv->gpio_polling_timer);\r\nsetup_timer(&priv->gpio_polling_timer,\r\ncheck_rfctrl_gpio_timer,\r\n(unsigned long)dev);\r\nrtl8192_irq_disable(dev);\r\nif (request_irq(dev->irq, (void *)rtl8192_interrupt_rsl, IRQF_SHARED,\r\ndev->name, dev)) {\r\nprintk(KERN_ERR "Error allocating IRQ %d", dev->irq);\r\nreturn -1;\r\n} else {\r\npriv->irq = dev->irq;\r\nRT_TRACE(COMP_INIT, "IRQ %d\n", dev->irq);\r\n}\r\nif (rtl8192_pci_initdescring(dev) != 0) {\r\nprintk(KERN_ERR "Endopoints initialization failed");\r\nfree_irq(dev->irq, dev);\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nshort rtl8192_is_tx_queue_empty(struct net_device *dev)\r\n{\r\nint i = 0;\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nfor (i = 0; i <= MGNT_QUEUE; i++) {\r\nif ((i == TXCMD_QUEUE) || (i == HCCA_QUEUE))\r\ncontinue;\r\nif (skb_queue_len(&(&priv->tx_ring[i])->queue) > 0) {\r\nprintk(KERN_INFO "===>tx queue is not empty:%d, %d\n",\r\ni, skb_queue_len(&(&priv->tx_ring[i])->queue));\r\nreturn 0;\r\n}\r\n}\r\nreturn 1;\r\n}\r\nstatic enum reset_type rtl819x_TxCheckStuck(struct net_device *dev)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nu8 QueueID;\r\nu8 ResetThreshold = NIC_SEND_HANG_THRESHOLD_POWERSAVE;\r\nbool bCheckFwTxCnt = false;\r\nstruct rtl8192_tx_ring *ring = NULL;\r\nstruct sk_buff *skb = NULL;\r\nstruct cb_desc *tcb_desc = NULL;\r\nunsigned long flags = 0;\r\nswitch (priv->rtllib->ps) {\r\ncase RTLLIB_PS_DISABLED:\r\nResetThreshold = NIC_SEND_HANG_THRESHOLD_NORMAL;\r\nbreak;\r\ncase (RTLLIB_PS_MBCAST|RTLLIB_PS_UNICAST):\r\nResetThreshold = NIC_SEND_HANG_THRESHOLD_POWERSAVE;\r\nbreak;\r\ndefault:\r\nResetThreshold = NIC_SEND_HANG_THRESHOLD_POWERSAVE;\r\nbreak;\r\n}\r\nspin_lock_irqsave(&priv->irq_th_lock, flags);\r\nfor (QueueID = 0; QueueID < MAX_TX_QUEUE; QueueID++) {\r\nif (QueueID == TXCMD_QUEUE)\r\ncontinue;\r\nif (QueueID == BEACON_QUEUE)\r\ncontinue;\r\nring = &priv->tx_ring[QueueID];\r\nif (skb_queue_len(&ring->queue) == 0) {\r\ncontinue;\r\n} else {\r\nskb = (&ring->queue)->next;\r\ntcb_desc = (struct cb_desc *)(skb->cb +\r\nMAX_DEV_ADDR_SIZE);\r\ntcb_desc->nStuckCount++;\r\nbCheckFwTxCnt = true;\r\nif (tcb_desc->nStuckCount > 1)\r\nprintk(KERN_INFO "%s: QueueID=%d tcb_desc->n"\r\n"StuckCount=%d\n", __func__, QueueID,\r\ntcb_desc->nStuckCount);\r\n}\r\n}\r\nspin_unlock_irqrestore(&priv->irq_th_lock, flags);\r\nif (bCheckFwTxCnt) {\r\nif (priv->ops->TxCheckStuckHandler(dev)) {\r\nRT_TRACE(COMP_RESET, "TxCheckStuck(): Fw indicates no"\r\n" Tx condition!\n");\r\nreturn RESET_TYPE_SILENT;\r\n}\r\n}\r\nreturn RESET_TYPE_NORESET;\r\n}\r\nstatic enum reset_type rtl819x_RxCheckStuck(struct net_device *dev)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nif (priv->ops->RxCheckStuckHandler(dev)) {\r\nRT_TRACE(COMP_RESET, "RxStuck Condition\n");\r\nreturn RESET_TYPE_SILENT;\r\n}\r\nreturn RESET_TYPE_NORESET;\r\n}\r\nstatic enum reset_type rtl819x_ifcheck_resetornot(struct net_device *dev)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nenum reset_type TxResetType = RESET_TYPE_NORESET;\r\nenum reset_type RxResetType = RESET_TYPE_NORESET;\r\nenum rt_rf_power_state rfState;\r\nrfState = priv->rtllib->eRFPowerState;\r\nif (rfState == eRfOn)\r\nTxResetType = rtl819x_TxCheckStuck(dev);\r\nif (rfState == eRfOn &&\r\n(priv->rtllib->iw_mode == IW_MODE_INFRA) &&\r\n(priv->rtllib->state == RTLLIB_LINKED))\r\nRxResetType = rtl819x_RxCheckStuck(dev);\r\nif (TxResetType == RESET_TYPE_NORMAL ||\r\nRxResetType == RESET_TYPE_NORMAL) {\r\nprintk(KERN_INFO "%s(): TxResetType is %d, RxResetType is %d\n",\r\n__func__, TxResetType, RxResetType);\r\nreturn RESET_TYPE_NORMAL;\r\n} else if (TxResetType == RESET_TYPE_SILENT ||\r\nRxResetType == RESET_TYPE_SILENT) {\r\nprintk(KERN_INFO "%s(): TxResetType is %d, RxResetType is %d\n",\r\n__func__, TxResetType, RxResetType);\r\nreturn RESET_TYPE_SILENT;\r\n} else {\r\nreturn RESET_TYPE_NORESET;\r\n}\r\n}\r\nstatic void rtl819x_silentreset_mesh_bk(struct net_device *dev, u8 IsPortal)\r\n{\r\n}\r\nstatic void rtl819x_ifsilentreset(struct net_device *dev)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nu8 reset_times = 0;\r\nint reset_status = 0;\r\nstruct rtllib_device *ieee = priv->rtllib;\r\nunsigned long flag;\r\nu8 IsPortal = 0;\r\nif (priv->ResetProgress == RESET_TYPE_NORESET) {\r\nRT_TRACE(COMP_RESET, "=========>Reset progress!!\n");\r\npriv->ResetProgress = RESET_TYPE_SILENT;\r\nspin_lock_irqsave(&priv->rf_ps_lock, flag);\r\nif (priv->RFChangeInProgress) {\r\nspin_unlock_irqrestore(&priv->rf_ps_lock, flag);\r\ngoto END;\r\n}\r\npriv->RFChangeInProgress = true;\r\npriv->bResetInProgress = true;\r\nspin_unlock_irqrestore(&priv->rf_ps_lock, flag);\r\nRESET_START:\r\ndown(&priv->wx_sem);\r\nif (priv->rtllib->state == RTLLIB_LINKED)\r\nLeisurePSLeave(dev);\r\nif (IS_NIC_DOWN(priv)) {\r\nRT_TRACE(COMP_ERR, "%s():the driver is not up! "\r\n"return\n", __func__);\r\nup(&priv->wx_sem);\r\nreturn ;\r\n}\r\npriv->up = 0;\r\nRT_TRACE(COMP_RESET, "%s():======>start to down the driver\n",\r\n__func__);\r\nmdelay(1000);\r\nRT_TRACE(COMP_RESET, "%s():111111111111111111111111======>start"\r\n" to down the driver\n", __func__);\r\nif (!netif_queue_stopped(dev))\r\nnetif_stop_queue(dev);\r\nrtl8192_irq_disable(dev);\r\ndel_timer_sync(&priv->watch_dog_timer);\r\nrtl8192_cancel_deferred_work(priv);\r\ndeinit_hal_dm(dev);\r\nrtllib_stop_scan_syncro(ieee);\r\nif (ieee->state == RTLLIB_LINKED) {\r\nSEM_DOWN_IEEE_WX(&ieee->wx_sem);\r\nprintk(KERN_INFO "ieee->state is RTLLIB_LINKED\n");\r\nrtllib_stop_send_beacons(priv->rtllib);\r\ndel_timer_sync(&ieee->associate_timer);\r\ncancel_delayed_work(&ieee->associate_retry_wq);\r\nrtllib_stop_scan(ieee);\r\nnetif_carrier_off(dev);\r\nSEM_UP_IEEE_WX(&ieee->wx_sem);\r\n} else {\r\nprintk(KERN_INFO "ieee->state is NOT LINKED\n");\r\nrtllib_softmac_stop_protocol(priv->rtllib, 0 , true);\r\n}\r\ndm_backup_dynamic_mechanism_state(dev);\r\nup(&priv->wx_sem);\r\nRT_TRACE(COMP_RESET, "%s():<==========down process is "\r\n"finished\n", __func__);\r\nRT_TRACE(COMP_RESET, "%s():<===========up process start\n",\r\n__func__);\r\nreset_status = _rtl8192_up(dev, true);\r\nRT_TRACE(COMP_RESET, "%s():<===========up process is "\r\n"finished\n", __func__);\r\nif (reset_status == -1) {\r\nif (reset_times < 3) {\r\nreset_times++;\r\ngoto RESET_START;\r\n} else {\r\nRT_TRACE(COMP_ERR, " ERR!!! %s(): Reset "\r\n"Failed!!\n", __func__);\r\n}\r\n}\r\nieee->is_silent_reset = 1;\r\nspin_lock_irqsave(&priv->rf_ps_lock, flag);\r\npriv->RFChangeInProgress = false;\r\nspin_unlock_irqrestore(&priv->rf_ps_lock, flag);\r\nEnableHWSecurityConfig8192(dev);\r\nif (ieee->state == RTLLIB_LINKED && ieee->iw_mode ==\r\nIW_MODE_INFRA) {\r\nieee->set_chan(ieee->dev,\r\nieee->current_network.channel);\r\nqueue_work_rsl(ieee->wq, &ieee->associate_complete_wq);\r\n} else if (ieee->state == RTLLIB_LINKED && ieee->iw_mode ==\r\nIW_MODE_ADHOC) {\r\nieee->set_chan(ieee->dev,\r\nieee->current_network.channel);\r\nieee->link_change(ieee->dev);\r\nnotify_wx_assoc_event(ieee);\r\nrtllib_start_send_beacons(ieee);\r\nif (ieee->data_hard_resume)\r\nieee->data_hard_resume(ieee->dev);\r\nnetif_carrier_on(ieee->dev);\r\n} else if (ieee->iw_mode == IW_MODE_MESH) {\r\nrtl819x_silentreset_mesh_bk(dev, IsPortal);\r\n}\r\nCamRestoreAllEntry(dev);\r\ndm_restore_dynamic_mechanism_state(dev);\r\nEND:\r\npriv->ResetProgress = RESET_TYPE_NORESET;\r\npriv->reset_count++;\r\npriv->bForcedSilentReset = false;\r\npriv->bResetInProgress = false;\r\nwrite_nic_byte(dev, UFWP, 1);\r\nRT_TRACE(COMP_RESET, "Reset finished!! ====>[%d]\n",\r\npriv->reset_count);\r\n}\r\n}\r\nstatic void rtl819x_update_rxcounts(struct r8192_priv *priv, u32 *TotalRxBcnNum,\r\nu32 *TotalRxDataNum)\r\n{\r\nu16 SlotIndex;\r\nu8 i;\r\n*TotalRxBcnNum = 0;\r\n*TotalRxDataNum = 0;\r\nSlotIndex = (priv->rtllib->LinkDetectInfo.SlotIndex++) %\r\n(priv->rtllib->LinkDetectInfo.SlotNum);\r\npriv->rtllib->LinkDetectInfo.RxBcnNum[SlotIndex] =\r\npriv->rtllib->LinkDetectInfo.NumRecvBcnInPeriod;\r\npriv->rtllib->LinkDetectInfo.RxDataNum[SlotIndex] =\r\npriv->rtllib->LinkDetectInfo.NumRecvDataInPeriod;\r\nfor (i = 0; i < priv->rtllib->LinkDetectInfo.SlotNum; i++) {\r\n*TotalRxBcnNum += priv->rtllib->LinkDetectInfo.RxBcnNum[i];\r\n*TotalRxDataNum += priv->rtllib->LinkDetectInfo.RxDataNum[i];\r\n}\r\n}\r\nvoid rtl819x_watchdog_wqcallback(void *data)\r\n{\r\nstruct r8192_priv *priv = container_of_dwork_rsl(data,\r\nstruct r8192_priv, watch_dog_wq);\r\nstruct net_device *dev = priv->rtllib->dev;\r\nstruct rtllib_device *ieee = priv->rtllib;\r\nenum reset_type ResetType = RESET_TYPE_NORESET;\r\nstatic u8 check_reset_cnt;\r\nunsigned long flags;\r\nstruct rt_pwr_save_ctrl *pPSC = (struct rt_pwr_save_ctrl *)\r\n(&(priv->rtllib->PowerSaveControl));\r\nbool bBusyTraffic = false;\r\nbool bHigherBusyTraffic = false;\r\nbool bHigherBusyRxTraffic = false;\r\nbool bEnterPS = false;\r\nif (IS_NIC_DOWN(priv) || (priv->bHwRadioOff == true))\r\nreturn;\r\nif (priv->rtllib->state >= RTLLIB_LINKED) {\r\nif (priv->rtllib->CntAfterLink < 2)\r\npriv->rtllib->CntAfterLink++;\r\n} else {\r\npriv->rtllib->CntAfterLink = 0;\r\n}\r\nhal_dm_watchdog(dev);\r\nif (rtllib_act_scanning(priv->rtllib, false) == false) {\r\nif ((ieee->iw_mode == IW_MODE_INFRA) && (ieee->state ==\r\nRTLLIB_NOLINK) &&\r\n(ieee->eRFPowerState == eRfOn) && !ieee->is_set_key &&\r\n(!ieee->proto_stoppping) && !ieee->wx_set_enc) {\r\nif ((ieee->PowerSaveControl.ReturnPoint ==\r\nIPS_CALLBACK_NONE) &&\r\n(!ieee->bNetPromiscuousMode)) {\r\nRT_TRACE(COMP_PS, "====================>haha: "\r\n"IPSEnter()\n");\r\nIPSEnter(dev);\r\n}\r\n}\r\n}\r\nif ((ieee->state == RTLLIB_LINKED) && (ieee->iw_mode ==\r\nIW_MODE_INFRA) && (!ieee->bNetPromiscuousMode)) {\r\nif (ieee->LinkDetectInfo.NumRxOkInPeriod > 100 ||\r\nieee->LinkDetectInfo.NumTxOkInPeriod > 100)\r\nbBusyTraffic = true;\r\nif (ieee->LinkDetectInfo.NumRxOkInPeriod > 4000 ||\r\nieee->LinkDetectInfo.NumTxOkInPeriod > 4000) {\r\nbHigherBusyTraffic = true;\r\nif (ieee->LinkDetectInfo.NumRxOkInPeriod > 5000)\r\nbHigherBusyRxTraffic = true;\r\nelse\r\nbHigherBusyRxTraffic = false;\r\n}\r\nif (((ieee->LinkDetectInfo.NumRxUnicastOkInPeriod +\r\nieee->LinkDetectInfo.NumTxOkInPeriod) > 8) ||\r\n(ieee->LinkDetectInfo.NumRxUnicastOkInPeriod > 2))\r\nbEnterPS = false;\r\nelse\r\nbEnterPS = true;\r\nif (ieee->current_network.beacon_interval < 95)\r\nbEnterPS = false;\r\nif (bEnterPS)\r\nLeisurePSEnter(dev);\r\nelse\r\nLeisurePSLeave(dev);\r\n} else {\r\nRT_TRACE(COMP_LPS, "====>no link LPS leave\n");\r\nLeisurePSLeave(dev);\r\n}\r\nieee->LinkDetectInfo.NumRxOkInPeriod = 0;\r\nieee->LinkDetectInfo.NumTxOkInPeriod = 0;\r\nieee->LinkDetectInfo.NumRxUnicastOkInPeriod = 0;\r\nieee->LinkDetectInfo.bBusyTraffic = bBusyTraffic;\r\nieee->LinkDetectInfo.bHigherBusyTraffic = bHigherBusyTraffic;\r\nieee->LinkDetectInfo.bHigherBusyRxTraffic = bHigherBusyRxTraffic;\r\nif (ieee->state == RTLLIB_LINKED && ieee->iw_mode == IW_MODE_INFRA) {\r\nu32 TotalRxBcnNum = 0;\r\nu32 TotalRxDataNum = 0;\r\nrtl819x_update_rxcounts(priv, &TotalRxBcnNum, &TotalRxDataNum);\r\nif ((TotalRxBcnNum+TotalRxDataNum) == 0)\r\npriv->check_roaming_cnt++;\r\nelse\r\npriv->check_roaming_cnt = 0;\r\nif (priv->check_roaming_cnt > 0) {\r\nif (ieee->eRFPowerState == eRfOff)\r\nRT_TRACE(COMP_ERR, "========>%s()\n", __func__);\r\nprintk(KERN_INFO "===>%s(): AP is power off, chan:%d,"\r\n" connect another one\n", __func__, priv->chan);\r\nieee->state = RTLLIB_ASSOCIATING;\r\nRemovePeerTS(priv->rtllib,\r\npriv->rtllib->current_network.bssid);\r\nieee->is_roaming = true;\r\nieee->is_set_key = false;\r\nieee->link_change(dev);\r\nif (ieee->LedControlHandler)\r\nieee->LedControlHandler(ieee->dev,\r\nLED_CTL_START_TO_LINK);\r\nnotify_wx_assoc_event(ieee);\r\nif (!(ieee->rtllib_ap_sec_type(ieee) &\r\n(SEC_ALG_CCMP|SEC_ALG_TKIP)))\r\nqueue_delayed_work_rsl(ieee->wq,\r\n&ieee->associate_procedure_wq, 0);\r\npriv->check_roaming_cnt = 0;\r\n}\r\nieee->LinkDetectInfo.NumRecvBcnInPeriod = 0;\r\nieee->LinkDetectInfo.NumRecvDataInPeriod = 0;\r\n}\r\nspin_lock_irqsave(&priv->tx_lock, flags);\r\nif ((check_reset_cnt++ >= 3) && (!ieee->is_roaming) &&\r\n(!priv->RFChangeInProgress) && (!pPSC->bSwRfProcessing)) {\r\nResetType = rtl819x_ifcheck_resetornot(dev);\r\ncheck_reset_cnt = 3;\r\n}\r\nspin_unlock_irqrestore(&priv->tx_lock, flags);\r\nif (!priv->bDisableNormalResetCheck && ResetType == RESET_TYPE_NORMAL) {\r\npriv->ResetProgress = RESET_TYPE_NORMAL;\r\nRT_TRACE(COMP_RESET, "%s(): NOMAL RESET\n", __func__);\r\nreturn;\r\n}\r\nif (((priv->force_reset) || (!priv->bDisableNormalResetCheck &&\r\nResetType == RESET_TYPE_SILENT)))\r\nrtl819x_ifsilentreset(dev);\r\npriv->force_reset = false;\r\npriv->bForcedSilentReset = false;\r\npriv->bResetInProgress = false;\r\nRT_TRACE(COMP_TRACE, " <==RtUsbCheckForHangWorkItemCallback()\n");\r\n}\r\nvoid watch_dog_timer_callback(unsigned long data)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv((struct net_device *)data);\r\nqueue_delayed_work_rsl(priv->priv_wq, &priv->watch_dog_wq, 0);\r\nmod_timer(&priv->watch_dog_timer, jiffies +\r\nMSECS(RTLLIB_WATCH_DOG_TIME));\r\n}\r\nvoid rtl8192_rx_enable(struct net_device *dev)\r\n{\r\nstruct r8192_priv *priv = (struct r8192_priv *)rtllib_priv(dev);\r\npriv->ops->rx_enable(dev);\r\n}\r\nvoid rtl8192_tx_enable(struct net_device *dev)\r\n{\r\nstruct r8192_priv *priv = (struct r8192_priv *)rtllib_priv(dev);\r\npriv->ops->tx_enable(dev);\r\nrtllib_reset_queue(priv->rtllib);\r\n}\r\nstatic void rtl8192_free_rx_ring(struct net_device *dev)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nint i, rx_queue_idx;\r\nfor (rx_queue_idx = 0; rx_queue_idx < MAX_RX_QUEUE;\r\nrx_queue_idx++) {\r\nfor (i = 0; i < priv->rxringcount; i++) {\r\nstruct sk_buff *skb = priv->rx_buf[rx_queue_idx][i];\r\nif (!skb)\r\ncontinue;\r\npci_unmap_single(priv->pdev,\r\n*((dma_addr_t *)skb->cb),\r\npriv->rxbuffersize, PCI_DMA_FROMDEVICE);\r\nkfree_skb(skb);\r\n}\r\npci_free_consistent(priv->pdev,\r\nsizeof(*priv->rx_ring[rx_queue_idx]) *\r\npriv->rxringcount,\r\npriv->rx_ring[rx_queue_idx],\r\npriv->rx_ring_dma[rx_queue_idx]);\r\npriv->rx_ring[rx_queue_idx] = NULL;\r\n}\r\n}\r\nstatic void rtl8192_free_tx_ring(struct net_device *dev, unsigned int prio)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nstruct rtl8192_tx_ring *ring = &priv->tx_ring[prio];\r\nwhile (skb_queue_len(&ring->queue)) {\r\nstruct tx_desc *entry = &ring->desc[ring->idx];\r\nstruct sk_buff *skb = __skb_dequeue(&ring->queue);\r\npci_unmap_single(priv->pdev, le32_to_cpu(entry->TxBuffAddr),\r\nskb->len, PCI_DMA_TODEVICE);\r\nkfree_skb(skb);\r\nring->idx = (ring->idx + 1) % ring->entries;\r\n}\r\npci_free_consistent(priv->pdev, sizeof(*ring->desc)*ring->entries,\r\nring->desc, ring->dma);\r\nring->desc = NULL;\r\n}\r\nvoid rtl8192_data_hard_stop(struct net_device *dev)\r\n{\r\n}\r\nvoid rtl8192_data_hard_resume(struct net_device *dev)\r\n{\r\n}\r\nvoid rtl8192_hard_data_xmit(struct sk_buff *skb, struct net_device *dev,\r\nint rate)\r\n{\r\nstruct r8192_priv *priv = (struct r8192_priv *)rtllib_priv(dev);\r\nint ret;\r\nstruct cb_desc *tcb_desc = (struct cb_desc *)(skb->cb +\r\nMAX_DEV_ADDR_SIZE);\r\nu8 queue_index = tcb_desc->queue_index;\r\nif ((priv->rtllib->eRFPowerState == eRfOff) || IS_NIC_DOWN(priv) ||\r\npriv->bResetInProgress) {\r\nkfree_skb(skb);\r\nreturn;\r\n}\r\nassert(queue_index != TXCMD_QUEUE);\r\nmemcpy((unsigned char *)(skb->cb), &dev, sizeof(dev));\r\nskb_push(skb, priv->rtllib->tx_headroom);\r\nret = rtl8192_tx(dev, skb);\r\nif (ret != 0) {\r\nkfree_skb(skb);\r\n};\r\nif (queue_index != MGNT_QUEUE) {\r\npriv->rtllib->stats.tx_bytes += (skb->len -\r\npriv->rtllib->tx_headroom);\r\npriv->rtllib->stats.tx_packets++;\r\n}\r\nreturn;\r\n}\r\nint rtl8192_hard_start_xmit(struct sk_buff *skb, struct net_device *dev)\r\n{\r\nstruct r8192_priv *priv = (struct r8192_priv *)rtllib_priv(dev);\r\nint ret;\r\nstruct cb_desc *tcb_desc = (struct cb_desc *)(skb->cb +\r\nMAX_DEV_ADDR_SIZE);\r\nu8 queue_index = tcb_desc->queue_index;\r\nif (queue_index != TXCMD_QUEUE) {\r\nif ((priv->rtllib->eRFPowerState == eRfOff) ||\r\nIS_NIC_DOWN(priv) || priv->bResetInProgress) {\r\nkfree_skb(skb);\r\nreturn 0;\r\n}\r\n}\r\nmemcpy((unsigned char *)(skb->cb), &dev, sizeof(dev));\r\nif (queue_index == TXCMD_QUEUE) {\r\nrtl8192_tx_cmd(dev, skb);\r\nret = 0;\r\nreturn ret;\r\n} else {\r\ntcb_desc->RATRIndex = 7;\r\ntcb_desc->bTxDisableRateFallBack = 1;\r\ntcb_desc->bTxUseDriverAssingedRate = 1;\r\ntcb_desc->bTxEnableFwCalcDur = 1;\r\nskb_push(skb, priv->rtllib->tx_headroom);\r\nret = rtl8192_tx(dev, skb);\r\nif (ret != 0) {\r\nkfree_skb(skb);\r\n};\r\n}\r\nreturn ret;\r\n}\r\nstatic void rtl8192_tx_isr(struct net_device *dev, int prio)\r\n{\r\nstruct r8192_priv *priv = (struct r8192_priv *)rtllib_priv(dev);\r\nstruct rtl8192_tx_ring *ring = &priv->tx_ring[prio];\r\nwhile (skb_queue_len(&ring->queue)) {\r\nstruct tx_desc *entry = &ring->desc[ring->idx];\r\nstruct sk_buff *skb;\r\nif (prio != BEACON_QUEUE) {\r\nif (entry->OWN)\r\nreturn;\r\nring->idx = (ring->idx + 1) % ring->entries;\r\n}\r\nskb = __skb_dequeue(&ring->queue);\r\npci_unmap_single(priv->pdev, le32_to_cpu(entry->TxBuffAddr),\r\nskb->len, PCI_DMA_TODEVICE);\r\nkfree_skb(skb);\r\n}\r\nif (prio != BEACON_QUEUE)\r\ntasklet_schedule(&priv->irq_tx_tasklet);\r\n}\r\nvoid rtl8192_tx_cmd(struct net_device *dev, struct sk_buff *skb)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nstruct rtl8192_tx_ring *ring;\r\nstruct tx_desc_cmd *entry;\r\nunsigned int idx;\r\nstruct cb_desc *tcb_desc;\r\nunsigned long flags;\r\nspin_lock_irqsave(&priv->irq_th_lock, flags);\r\nring = &priv->tx_ring[TXCMD_QUEUE];\r\nidx = (ring->idx + skb_queue_len(&ring->queue)) % ring->entries;\r\nentry = (struct tx_desc_cmd *) &ring->desc[idx];\r\ntcb_desc = (struct cb_desc *)(skb->cb + MAX_DEV_ADDR_SIZE);\r\npriv->ops->tx_fill_cmd_descriptor(dev, entry, tcb_desc, skb);\r\n__skb_queue_tail(&ring->queue, skb);\r\nspin_unlock_irqrestore(&priv->irq_th_lock, flags);\r\nreturn;\r\n}\r\nshort rtl8192_tx(struct net_device *dev, struct sk_buff *skb)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nstruct rtl8192_tx_ring *ring;\r\nunsigned long flags;\r\nstruct cb_desc *tcb_desc = (struct cb_desc *)(skb->cb +\r\nMAX_DEV_ADDR_SIZE);\r\nstruct tx_desc *pdesc = NULL;\r\nstruct rtllib_hdr_1addr *header = NULL;\r\nu16 fc = 0, type = 0, stype = 0;\r\nbool multi_addr = false, broad_addr = false, uni_addr = false;\r\nu8 *pda_addr = NULL;\r\nint idx;\r\nu32 fwinfo_size = 0;\r\nif (priv->bdisable_nic) {\r\nRT_TRACE(COMP_ERR, "%s: ERR!! Nic is disabled! Can't tx packet"\r\n" len=%d qidx=%d!!!\n", __func__, skb->len,\r\ntcb_desc->queue_index);\r\nreturn skb->len;\r\n}\r\npriv->rtllib->bAwakePktSent = true;\r\nfwinfo_size = sizeof(struct tx_fwinfo_8190pci);\r\nheader = (struct rtllib_hdr_1addr *)(((u8 *)skb->data) + fwinfo_size);\r\nfc = header->frame_ctl;\r\ntype = WLAN_FC_GET_TYPE(fc);\r\nstype = WLAN_FC_GET_STYPE(fc);\r\npda_addr = header->addr1;\r\nif (is_broadcast_ether_addr(pda_addr))\r\nbroad_addr = true;\r\nelse if (is_multicast_ether_addr(pda_addr))\r\nmulti_addr = true;\r\nelse\r\nuni_addr = true;\r\nif (uni_addr)\r\npriv->stats.txbytesunicast += skb->len - fwinfo_size;\r\nelse if (multi_addr)\r\npriv->stats.txbytesmulticast += skb->len - fwinfo_size;\r\nelse\r\npriv->stats.txbytesbroadcast += skb->len - fwinfo_size;\r\nspin_lock_irqsave(&priv->irq_th_lock, flags);\r\nring = &priv->tx_ring[tcb_desc->queue_index];\r\nif (tcb_desc->queue_index != BEACON_QUEUE)\r\nidx = (ring->idx + skb_queue_len(&ring->queue)) % ring->entries;\r\nelse\r\nidx = 0;\r\npdesc = &ring->desc[idx];\r\nif ((pdesc->OWN == 1) && (tcb_desc->queue_index != BEACON_QUEUE)) {\r\nRT_TRACE(COMP_ERR, "No more TX desc@%d, ring->idx = %d, idx = "\r\n"%d, skblen = 0x%x queuelen=%d",\r\ntcb_desc->queue_index, ring->idx, idx, skb->len,\r\nskb_queue_len(&ring->queue));\r\nspin_unlock_irqrestore(&priv->irq_th_lock, flags);\r\nreturn skb->len;\r\n}\r\nif (type == RTLLIB_FTYPE_DATA) {\r\nif (priv->rtllib->LedControlHandler)\r\npriv->rtllib->LedControlHandler(dev, LED_CTL_TX);\r\n}\r\npriv->ops->tx_fill_descriptor(dev, pdesc, tcb_desc, skb);\r\n__skb_queue_tail(&ring->queue, skb);\r\npdesc->OWN = 1;\r\nspin_unlock_irqrestore(&priv->irq_th_lock, flags);\r\ndev->trans_start = jiffies;\r\nwrite_nic_word(dev, TPPoll, 0x01 << tcb_desc->queue_index);\r\nreturn 0;\r\n}\r\nstatic short rtl8192_alloc_rx_desc_ring(struct net_device *dev)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nstruct rx_desc *entry = NULL;\r\nint i, rx_queue_idx;\r\nfor (rx_queue_idx = 0; rx_queue_idx < MAX_RX_QUEUE; rx_queue_idx++) {\r\npriv->rx_ring[rx_queue_idx] = pci_alloc_consistent(priv->pdev,\r\nsizeof(*priv->rx_ring[rx_queue_idx]) *\r\npriv->rxringcount,\r\n&priv->rx_ring_dma[rx_queue_idx]);\r\nif (!priv->rx_ring[rx_queue_idx] ||\r\n(unsigned long)priv->rx_ring[rx_queue_idx] & 0xFF) {\r\nRT_TRACE(COMP_ERR, "Cannot allocate RX ring\n");\r\nreturn -ENOMEM;\r\n}\r\nmemset(priv->rx_ring[rx_queue_idx], 0,\r\nsizeof(*priv->rx_ring[rx_queue_idx]) *\r\npriv->rxringcount);\r\npriv->rx_idx[rx_queue_idx] = 0;\r\nfor (i = 0; i < priv->rxringcount; i++) {\r\nstruct sk_buff *skb = dev_alloc_skb(priv->rxbuffersize);\r\ndma_addr_t *mapping;\r\nentry = &priv->rx_ring[rx_queue_idx][i];\r\nif (!skb)\r\nreturn 0;\r\nskb->dev = dev;\r\npriv->rx_buf[rx_queue_idx][i] = skb;\r\nmapping = (dma_addr_t *)skb->cb;\r\n*mapping = pci_map_single(priv->pdev,\r\nskb_tail_pointer_rsl(skb),\r\npriv->rxbuffersize,\r\nPCI_DMA_FROMDEVICE);\r\nif (pci_dma_mapping_error(priv->pdev, *mapping)) {\r\ndev_kfree_skb_any(skb);\r\nreturn -1;\r\n}\r\nentry->BufferAddress = cpu_to_le32(*mapping);\r\nentry->Length = priv->rxbuffersize;\r\nentry->OWN = 1;\r\n}\r\nif(entry)\r\nentry->EOR = 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int rtl8192_alloc_tx_desc_ring(struct net_device *dev,\r\nunsigned int prio, unsigned int entries)\r\n{\r\nstruct r8192_priv *priv = (struct r8192_priv *)rtllib_priv(dev);\r\nstruct tx_desc *ring;\r\ndma_addr_t dma;\r\nint i;\r\nring = pci_alloc_consistent(priv->pdev, sizeof(*ring) * entries, &dma);\r\nif (!ring || (unsigned long)ring & 0xFF) {\r\nRT_TRACE(COMP_ERR, "Cannot allocate TX ring (prio = %d)\n",\r\nprio);\r\nreturn -ENOMEM;\r\n}\r\nmemset(ring, 0, sizeof(*ring)*entries);\r\npriv->tx_ring[prio].desc = ring;\r\npriv->tx_ring[prio].dma = dma;\r\npriv->tx_ring[prio].idx = 0;\r\npriv->tx_ring[prio].entries = entries;\r\nskb_queue_head_init(&priv->tx_ring[prio].queue);\r\nfor (i = 0; i < entries; i++)\r\nring[i].NextDescAddress =\r\ncpu_to_le32((u32)dma + ((i + 1) % entries) *\r\nsizeof(*ring));\r\nreturn 0;\r\n}\r\nshort rtl8192_pci_initdescring(struct net_device *dev)\r\n{\r\nu32 ret;\r\nint i;\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nret = rtl8192_alloc_rx_desc_ring(dev);\r\nif (ret)\r\nreturn ret;\r\nfor (i = 0; i < MAX_TX_QUEUE_COUNT; i++) {\r\nret = rtl8192_alloc_tx_desc_ring(dev, i, priv->txringcount);\r\nif (ret)\r\ngoto err_free_rings;\r\n}\r\nreturn 0;\r\nerr_free_rings:\r\nrtl8192_free_rx_ring(dev);\r\nfor (i = 0; i < MAX_TX_QUEUE_COUNT; i++)\r\nif (priv->tx_ring[i].desc)\r\nrtl8192_free_tx_ring(dev, i);\r\nreturn 1;\r\n}\r\nvoid rtl8192_pci_resetdescring(struct net_device *dev)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nint i, rx_queue_idx;\r\nunsigned long flags = 0;\r\nfor (rx_queue_idx = 0; rx_queue_idx < MAX_RX_QUEUE; rx_queue_idx++) {\r\nif (priv->rx_ring[rx_queue_idx]) {\r\nstruct rx_desc *entry = NULL;\r\nfor (i = 0; i < priv->rxringcount; i++) {\r\nentry = &priv->rx_ring[rx_queue_idx][i];\r\nentry->OWN = 1;\r\n}\r\npriv->rx_idx[rx_queue_idx] = 0;\r\n}\r\n}\r\nspin_lock_irqsave(&priv->irq_th_lock, flags);\r\nfor (i = 0; i < MAX_TX_QUEUE_COUNT; i++) {\r\nif (priv->tx_ring[i].desc) {\r\nstruct rtl8192_tx_ring *ring = &priv->tx_ring[i];\r\nwhile (skb_queue_len(&ring->queue)) {\r\nstruct tx_desc *entry = &ring->desc[ring->idx];\r\nstruct sk_buff *skb =\r\n__skb_dequeue(&ring->queue);\r\npci_unmap_single(priv->pdev,\r\nle32_to_cpu(entry->TxBuffAddr),\r\nskb->len, PCI_DMA_TODEVICE);\r\nkfree_skb(skb);\r\nring->idx = (ring->idx + 1) % ring->entries;\r\n}\r\nring->idx = 0;\r\n}\r\n}\r\nspin_unlock_irqrestore(&priv->irq_th_lock, flags);\r\n}\r\nvoid rtl819x_UpdateRxPktTimeStamp(struct net_device *dev,\r\nstruct rtllib_rx_stats *stats)\r\n{\r\nstruct r8192_priv *priv = (struct r8192_priv *)rtllib_priv(dev);\r\nif (stats->bIsAMPDU && !stats->bFirstMPDU)\r\nstats->mac_time = priv->LastRxDescTSF;\r\nelse\r\npriv->LastRxDescTSF = stats->mac_time;\r\n}\r\nlong rtl819x_translate_todbm(struct r8192_priv *priv, u8 signal_strength_index)\r\n{\r\nlong signal_power;\r\nsignal_power = (long)((signal_strength_index + 1) >> 1);\r\nsignal_power -= 95;\r\nreturn signal_power;\r\n}\r\nvoid\r\nrtl819x_update_rxsignalstatistics8190pci(\r\nstruct r8192_priv *priv,\r\nstruct rtllib_rx_stats *pprevious_stats\r\n)\r\n{\r\nint weighting = 0;\r\nif (priv->stats.recv_signal_power == 0)\r\npriv->stats.recv_signal_power =\r\npprevious_stats->RecvSignalPower;\r\nif (pprevious_stats->RecvSignalPower > priv->stats.recv_signal_power)\r\nweighting = 5;\r\nelse if (pprevious_stats->RecvSignalPower <\r\npriv->stats.recv_signal_power)\r\nweighting = (-5);\r\npriv->stats.recv_signal_power = (priv->stats.recv_signal_power * 5 +\r\npprevious_stats->RecvSignalPower +\r\nweighting) / 6;\r\n}\r\nvoid rtl819x_process_cck_rxpathsel(struct r8192_priv *priv,\r\nstruct rtllib_rx_stats *pprevious_stats)\r\n{\r\n}\r\nu8 rtl819x_query_rxpwrpercentage(char antpower)\r\n{\r\nif ((antpower <= -100) || (antpower >= 20))\r\nreturn 0;\r\nelse if (antpower >= 0)\r\nreturn 100;\r\nelse\r\nreturn 100 + antpower;\r\n}\r\nu8\r\nrtl819x_evm_dbtopercentage(\r\nchar value\r\n)\r\n{\r\nchar ret_val;\r\nret_val = value;\r\nif (ret_val >= 0)\r\nret_val = 0;\r\nif (ret_val <= -33)\r\nret_val = -33;\r\nret_val = 0 - ret_val;\r\nret_val *= 3;\r\nif (ret_val == 99)\r\nret_val = 100;\r\nreturn ret_val;\r\n}\r\nvoid\r\nrtl8192_record_rxdesc_forlateruse(\r\nstruct rtllib_rx_stats *psrc_stats,\r\nstruct rtllib_rx_stats *ptarget_stats\r\n)\r\n{\r\nptarget_stats->bIsAMPDU = psrc_stats->bIsAMPDU;\r\nptarget_stats->bFirstMPDU = psrc_stats->bFirstMPDU;\r\n}\r\nstatic void rtl8192_rx_normal(struct net_device *dev)\r\n{\r\nstruct r8192_priv *priv = (struct r8192_priv *)rtllib_priv(dev);\r\nstruct rtllib_hdr_1addr *rtllib_hdr = NULL;\r\nbool unicast_packet = false;\r\nbool bLedBlinking = true;\r\nu16 fc = 0, type = 0;\r\nu32 skb_len = 0;\r\nint rx_queue_idx = RX_MPDU_QUEUE;\r\nstruct rtllib_rx_stats stats = {\r\n.signal = 0,\r\n.noise = -98,\r\n.rate = 0,\r\n.freq = RTLLIB_24GHZ_BAND,\r\n};\r\nunsigned int count = priv->rxringcount;\r\nstats.nic_type = NIC_8192E;\r\nwhile (count--) {\r\nstruct rx_desc *pdesc = &priv->rx_ring[rx_queue_idx]\r\n[priv->rx_idx[rx_queue_idx]];\r\nstruct sk_buff *skb = priv->rx_buf[rx_queue_idx]\r\n[priv->rx_idx[rx_queue_idx]];\r\nif (pdesc->OWN) {\r\nreturn;\r\n} else {\r\nstruct sk_buff *new_skb;\r\nif (!priv->ops->rx_query_status_descriptor(dev, &stats,\r\npdesc, skb))\r\ngoto done;\r\nnew_skb = dev_alloc_skb(priv->rxbuffersize);\r\nif (unlikely(!new_skb))\r\ngoto done;\r\npci_unmap_single(priv->pdev,\r\n*((dma_addr_t *)skb->cb),\r\npriv->rxbuffersize,\r\nPCI_DMA_FROMDEVICE);\r\nskb_put(skb, pdesc->Length);\r\nskb_reserve(skb, stats.RxDrvInfoSize +\r\nstats.RxBufShift);\r\nskb_trim(skb, skb->len - 4);\r\nrtllib_hdr = (struct rtllib_hdr_1addr *)skb->data;\r\nif (!is_multicast_ether_addr(rtllib_hdr->addr1)) {\r\nunicast_packet = true;\r\n}\r\nfc = le16_to_cpu(rtllib_hdr->frame_ctl);\r\ntype = WLAN_FC_GET_TYPE(fc);\r\nif (type == RTLLIB_FTYPE_MGMT)\r\nbLedBlinking = false;\r\nif (bLedBlinking)\r\nif (priv->rtllib->LedControlHandler)\r\npriv->rtllib->LedControlHandler(dev,\r\nLED_CTL_RX);\r\nif (stats.bCRC) {\r\nif (type != RTLLIB_FTYPE_MGMT)\r\npriv->stats.rxdatacrcerr++;\r\nelse\r\npriv->stats.rxmgmtcrcerr++;\r\n}\r\nskb_len = skb->len;\r\nif (!rtllib_rx(priv->rtllib, skb, &stats)) {\r\ndev_kfree_skb_any(skb);\r\n} else {\r\npriv->stats.rxok++;\r\nif (unicast_packet)\r\npriv->stats.rxbytesunicast += skb_len;\r\n}\r\nskb = new_skb;\r\nskb->dev = dev;\r\npriv->rx_buf[rx_queue_idx][priv->rx_idx[rx_queue_idx]] =\r\nskb;\r\n*((dma_addr_t *) skb->cb) = pci_map_single(priv->pdev,\r\nskb_tail_pointer_rsl(skb),\r\npriv->rxbuffersize,\r\nPCI_DMA_FROMDEVICE);\r\nif (pci_dma_mapping_error(priv->pdev,\r\n*((dma_addr_t *)skb->cb))) {\r\ndev_kfree_skb_any(skb);\r\nreturn;\r\n}\r\n}\r\ndone:\r\npdesc->BufferAddress = cpu_to_le32(*((dma_addr_t *)skb->cb));\r\npdesc->OWN = 1;\r\npdesc->Length = priv->rxbuffersize;\r\nif (priv->rx_idx[rx_queue_idx] == priv->rxringcount-1)\r\npdesc->EOR = 1;\r\npriv->rx_idx[rx_queue_idx] = (priv->rx_idx[rx_queue_idx] + 1) %\r\npriv->rxringcount;\r\n}\r\n}\r\nstatic void rtl8192_rx_cmd(struct net_device *dev)\r\n{\r\n}\r\nstatic void rtl8192_tx_resume(struct net_device *dev)\r\n{\r\nstruct r8192_priv *priv = (struct r8192_priv *)rtllib_priv(dev);\r\nstruct rtllib_device *ieee = priv->rtllib;\r\nstruct sk_buff *skb;\r\nint queue_index;\r\nfor (queue_index = BK_QUEUE;\r\nqueue_index < MAX_QUEUE_SIZE; queue_index++) {\r\nwhile ((!skb_queue_empty(&ieee->skb_waitQ[queue_index])) &&\r\n(priv->rtllib->check_nic_enough_desc(dev, queue_index) > 0)) {\r\nskb = skb_dequeue(&ieee->skb_waitQ[queue_index]);\r\nieee->softmac_data_hard_start_xmit(skb, dev, 0);\r\n}\r\n}\r\n}\r\nvoid rtl8192_irq_tx_tasklet(struct r8192_priv *priv)\r\n{\r\nrtl8192_tx_resume(priv->rtllib->dev);\r\n}\r\nvoid rtl8192_irq_rx_tasklet(struct r8192_priv *priv)\r\n{\r\nrtl8192_rx_normal(priv->rtllib->dev);\r\nif (MAX_RX_QUEUE > 1)\r\nrtl8192_rx_cmd(priv->rtllib->dev);\r\nwrite_nic_dword(priv->rtllib->dev, INTA_MASK,\r\nread_nic_dword(priv->rtllib->dev, INTA_MASK) | IMR_RDU);\r\n}\r\nvoid rtl8192_cancel_deferred_work(struct r8192_priv *priv)\r\n{\r\ncancel_delayed_work(&priv->watch_dog_wq);\r\ncancel_delayed_work(&priv->update_beacon_wq);\r\ncancel_delayed_work(&priv->rtllib->hw_sleep_wq);\r\ncancel_work_sync(&priv->reset_wq);\r\ncancel_work_sync(&priv->qos_activate);\r\n}\r\nint _rtl8192_up(struct net_device *dev, bool is_silent_reset)\r\n{\r\nif (_rtl8192_sta_up(dev, is_silent_reset) == -1)\r\nreturn -1;\r\nreturn 0;\r\n}\r\nstatic int rtl8192_open(struct net_device *dev)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nint ret;\r\ndown(&priv->wx_sem);\r\nret = rtl8192_up(dev);\r\nup(&priv->wx_sem);\r\nreturn ret;\r\n}\r\nint rtl8192_up(struct net_device *dev)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nif (priv->up == 1)\r\nreturn -1;\r\nreturn _rtl8192_up(dev, false);\r\n}\r\nstatic int rtl8192_close(struct net_device *dev)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nint ret;\r\nif ((rtllib_act_scanning(priv->rtllib, false)) &&\r\n!(priv->rtllib->softmac_features & IEEE_SOFTMAC_SCAN)) {\r\nrtllib_stop_scan(priv->rtllib);\r\n}\r\ndown(&priv->wx_sem);\r\nret = rtl8192_down(dev, true);\r\nup(&priv->wx_sem);\r\nreturn ret;\r\n}\r\nint rtl8192_down(struct net_device *dev, bool shutdownrf)\r\n{\r\nif (rtl8192_sta_down(dev, shutdownrf) == -1)\r\nreturn -1;\r\nreturn 0;\r\n}\r\nvoid rtl8192_commit(struct net_device *dev)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nif (priv->up == 0)\r\nreturn;\r\nrtllib_softmac_stop_protocol(priv->rtllib, 0 , true);\r\nrtl8192_irq_disable(dev);\r\npriv->ops->stop_adapter(dev, true);\r\n_rtl8192_up(dev, false);\r\n}\r\nvoid rtl8192_restart(void *data)\r\n{\r\nstruct r8192_priv *priv = container_of_work_rsl(data, struct r8192_priv,\r\nreset_wq);\r\nstruct net_device *dev = priv->rtllib->dev;\r\ndown(&priv->wx_sem);\r\nrtl8192_commit(dev);\r\nup(&priv->wx_sem);\r\n}\r\nstatic void r8192_set_multicast(struct net_device *dev)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nshort promisc;\r\npromisc = (dev->flags & IFF_PROMISC) ? 1 : 0;\r\npriv->promisc = promisc;\r\n}\r\nstatic int r8192_set_mac_adr(struct net_device *dev, void *mac)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nstruct sockaddr *addr = mac;\r\ndown(&priv->wx_sem);\r\nmemcpy(dev->dev_addr, addr->sa_data, ETH_ALEN);\r\nschedule_work(&priv->reset_wq);\r\nup(&priv->wx_sem);\r\nreturn 0;\r\n}\r\nstatic int rtl8192_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)\r\n{\r\nstruct r8192_priv *priv = (struct r8192_priv *)rtllib_priv(dev);\r\nstruct iwreq *wrq = (struct iwreq *)rq;\r\nint ret = -1;\r\nstruct rtllib_device *ieee = priv->rtllib;\r\nu32 key[4];\r\nu8 broadcast_addr[6] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};\r\nu8 zero_addr[6] = {0};\r\nstruct iw_point *p = &wrq->u.data;\r\nstruct ieee_param *ipw = NULL;\r\ndown(&priv->wx_sem);\r\nswitch (cmd) {\r\ncase RTL_IOCTL_WPA_SUPPLICANT:\r\nif (p->length < sizeof(struct ieee_param) || !p->pointer) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nipw = kmalloc(p->length, GFP_KERNEL);\r\nif (ipw == NULL) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nif (copy_from_user(ipw, p->pointer, p->length)) {\r\nkfree(ipw);\r\nret = -EFAULT;\r\ngoto out;\r\n}\r\nif (ipw->cmd == IEEE_CMD_SET_ENCRYPTION) {\r\nif (ipw->u.crypt.set_tx) {\r\nif (strcmp(ipw->u.crypt.alg, "CCMP") == 0)\r\nieee->pairwise_key_type = KEY_TYPE_CCMP;\r\nelse if (strcmp(ipw->u.crypt.alg, "TKIP") == 0)\r\nieee->pairwise_key_type = KEY_TYPE_TKIP;\r\nelse if (strcmp(ipw->u.crypt.alg, "WEP") == 0) {\r\nif (ipw->u.crypt.key_len == 13)\r\nieee->pairwise_key_type =\r\nKEY_TYPE_WEP104;\r\nelse if (ipw->u.crypt.key_len == 5)\r\nieee->pairwise_key_type =\r\nKEY_TYPE_WEP40;\r\n} else {\r\nieee->pairwise_key_type = KEY_TYPE_NA;\r\n}\r\nif (ieee->pairwise_key_type) {\r\nif (memcmp(ieee->ap_mac_addr, zero_addr,\r\n6) == 0)\r\nieee->iw_mode = IW_MODE_ADHOC;\r\nmemcpy((u8 *)key, ipw->u.crypt.key, 16);\r\nEnableHWSecurityConfig8192(dev);\r\nset_swcam(dev, 4, ipw->u.crypt.idx,\r\nieee->pairwise_key_type,\r\n(u8 *)ieee->ap_mac_addr,\r\n0, key, 0);\r\nsetKey(dev, 4, ipw->u.crypt.idx,\r\nieee->pairwise_key_type,\r\n(u8 *)ieee->ap_mac_addr, 0, key);\r\nif (ieee->iw_mode == IW_MODE_ADHOC) {\r\nset_swcam(dev, ipw->u.crypt.idx,\r\nipw->u.crypt.idx,\r\nieee->pairwise_key_type,\r\n(u8 *)ieee->ap_mac_addr,\r\n0, key, 0);\r\nsetKey(dev, ipw->u.crypt.idx,\r\nipw->u.crypt.idx,\r\nieee->pairwise_key_type,\r\n(u8 *)ieee->ap_mac_addr,\r\n0, key);\r\n}\r\n}\r\nif ((ieee->pairwise_key_type == KEY_TYPE_CCMP)\r\n&& ieee->pHTInfo->bCurrentHTSupport) {\r\nwrite_nic_byte(dev, 0x173, 1);\r\n}\r\n} else {\r\nmemcpy((u8 *)key, ipw->u.crypt.key, 16);\r\nif (strcmp(ipw->u.crypt.alg, "CCMP") == 0)\r\nieee->group_key_type = KEY_TYPE_CCMP;\r\nelse if (strcmp(ipw->u.crypt.alg, "TKIP") == 0)\r\nieee->group_key_type = KEY_TYPE_TKIP;\r\nelse if (strcmp(ipw->u.crypt.alg, "WEP") == 0) {\r\nif (ipw->u.crypt.key_len == 13)\r\nieee->group_key_type =\r\nKEY_TYPE_WEP104;\r\nelse if (ipw->u.crypt.key_len == 5)\r\nieee->group_key_type =\r\nKEY_TYPE_WEP40;\r\n} else\r\nieee->group_key_type = KEY_TYPE_NA;\r\nif (ieee->group_key_type) {\r\nset_swcam(dev, ipw->u.crypt.idx,\r\nipw->u.crypt.idx,\r\nieee->group_key_type,\r\nbroadcast_addr, 0, key, 0);\r\nsetKey(dev, ipw->u.crypt.idx,\r\nipw->u.crypt.idx,\r\nieee->group_key_type,\r\nbroadcast_addr, 0, key);\r\n}\r\n}\r\n}\r\nret = rtllib_wpa_supplicant_ioctl(priv->rtllib, &wrq->u.data,\r\n0);\r\nkfree(ipw);\r\nbreak;\r\ndefault:\r\nret = -EOPNOTSUPP;\r\nbreak;\r\n}\r\nout:\r\nup(&priv->wx_sem);\r\nreturn ret;\r\n}\r\nirqreturn_type rtl8192_interrupt(int irq, void *netdev, struct pt_regs *regs)\r\n{\r\nstruct net_device *dev = (struct net_device *) netdev;\r\nstruct r8192_priv *priv = (struct r8192_priv *)rtllib_priv(dev);\r\nunsigned long flags;\r\nu32 inta;\r\nu32 intb;\r\nintb = 0;\r\nif (priv->irq_enabled == 0)\r\ngoto done;\r\nspin_lock_irqsave(&priv->irq_th_lock, flags);\r\npriv->ops->interrupt_recognized(dev, &inta, &intb);\r\npriv->stats.shints++;\r\nif (!inta) {\r\nspin_unlock_irqrestore(&priv->irq_th_lock, flags);\r\ngoto done;\r\n}\r\nif (inta == 0xffff) {\r\nspin_unlock_irqrestore(&priv->irq_th_lock, flags);\r\ngoto done;\r\n}\r\npriv->stats.ints++;\r\nif (!netif_running(dev)) {\r\nspin_unlock_irqrestore(&priv->irq_th_lock, flags);\r\ngoto done;\r\n}\r\nif (inta & IMR_TBDOK) {\r\nRT_TRACE(COMP_INTR, "beacon ok interrupt!\n");\r\npriv->stats.txbeaconokint++;\r\n}\r\nif (inta & IMR_TBDER) {\r\nRT_TRACE(COMP_INTR, "beacon ok interrupt!\n");\r\npriv->stats.txbeaconerr++;\r\n}\r\nif (inta & IMR_BDOK)\r\nRT_TRACE(COMP_INTR, "beacon interrupt!\n");\r\nif (inta & IMR_MGNTDOK) {\r\nRT_TRACE(COMP_INTR, "Manage ok interrupt!\n");\r\npriv->stats.txmanageokint++;\r\nrtl8192_tx_isr(dev, MGNT_QUEUE);\r\nspin_unlock_irqrestore(&priv->irq_th_lock, flags);\r\nif (priv->rtllib->ack_tx_to_ieee) {\r\nif (rtl8192_is_tx_queue_empty(dev)) {\r\npriv->rtllib->ack_tx_to_ieee = 0;\r\nrtllib_ps_tx_ack(priv->rtllib, 1);\r\n}\r\n}\r\nspin_lock_irqsave(&priv->irq_th_lock, flags);\r\n}\r\nif (inta & IMR_COMDOK) {\r\npriv->stats.txcmdpktokint++;\r\nrtl8192_tx_isr(dev, TXCMD_QUEUE);\r\n}\r\nif (inta & IMR_HIGHDOK)\r\nrtl8192_tx_isr(dev, HIGH_QUEUE);\r\nif (inta & IMR_ROK) {\r\npriv->stats.rxint++;\r\npriv->InterruptLog.nIMR_ROK++;\r\ntasklet_schedule(&priv->irq_rx_tasklet);\r\n}\r\nif (inta & IMR_BcnInt) {\r\nRT_TRACE(COMP_INTR, "prepare beacon for interrupt!\n");\r\ntasklet_schedule(&priv->irq_prepare_beacon_tasklet);\r\n}\r\nif (inta & IMR_RDU) {\r\nRT_TRACE(COMP_INTR, "rx descriptor unavailable!\n");\r\npriv->stats.rxrdu++;\r\nwrite_nic_dword(dev, INTA_MASK,\r\nread_nic_dword(dev, INTA_MASK) & ~IMR_RDU);\r\ntasklet_schedule(&priv->irq_rx_tasklet);\r\n}\r\nif (inta & IMR_RXFOVW) {\r\nRT_TRACE(COMP_INTR, "rx overflow !\n");\r\npriv->stats.rxoverflow++;\r\ntasklet_schedule(&priv->irq_rx_tasklet);\r\n}\r\nif (inta & IMR_TXFOVW)\r\npriv->stats.txoverflow++;\r\nif (inta & IMR_BKDOK) {\r\nRT_TRACE(COMP_INTR, "BK Tx OK interrupt!\n");\r\npriv->stats.txbkokint++;\r\npriv->rtllib->LinkDetectInfo.NumTxOkInPeriod++;\r\nrtl8192_tx_isr(dev, BK_QUEUE);\r\n}\r\nif (inta & IMR_BEDOK) {\r\nRT_TRACE(COMP_INTR, "BE TX OK interrupt!\n");\r\npriv->stats.txbeokint++;\r\npriv->rtllib->LinkDetectInfo.NumTxOkInPeriod++;\r\nrtl8192_tx_isr(dev, BE_QUEUE);\r\n}\r\nif (inta & IMR_VIDOK) {\r\nRT_TRACE(COMP_INTR, "VI TX OK interrupt!\n");\r\npriv->stats.txviokint++;\r\npriv->rtllib->LinkDetectInfo.NumTxOkInPeriod++;\r\nrtl8192_tx_isr(dev, VI_QUEUE);\r\n}\r\nif (inta & IMR_VODOK) {\r\npriv->stats.txvookint++;\r\nRT_TRACE(COMP_INTR, "Vo TX OK interrupt!\n");\r\npriv->rtllib->LinkDetectInfo.NumTxOkInPeriod++;\r\nrtl8192_tx_isr(dev, VO_QUEUE);\r\n}\r\nspin_unlock_irqrestore(&priv->irq_th_lock, flags);\r\ndone:\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int rtl8192_pci_probe(struct pci_dev *pdev,\r\nconst struct pci_device_id *id)\r\n{\r\nunsigned long ioaddr = 0;\r\nstruct net_device *dev = NULL;\r\nstruct r8192_priv *priv = NULL;\r\nstruct rtl819x_ops *ops = (struct rtl819x_ops *)(id->driver_data);\r\nunsigned long pmem_start, pmem_len, pmem_flags;\r\nint err = -ENOMEM;\r\nbool bdma64 = false;\r\nu8 revision_id;\r\nRT_TRACE(COMP_INIT, "Configuring chip resources");\r\nif (pci_enable_device(pdev)) {\r\nRT_TRACE(COMP_ERR, "Failed to enable PCI device");\r\nreturn -EIO;\r\n}\r\npci_set_master(pdev);\r\nif (!pci_set_dma_mask(pdev, DMA_BIT_MASK(32))) {\r\nif (pci_set_consistent_dma_mask(pdev, DMA_BIT_MASK(32))) {\r\nprintk(KERN_INFO "Unable to obtain 32bit DMA for consistent allocations\n");\r\ngoto err_pci_disable;\r\n}\r\n}\r\ndev = alloc_rtllib(sizeof(struct r8192_priv));\r\nif (!dev)\r\ngoto err_pci_disable;\r\nerr = -ENODEV;\r\nif (bdma64)\r\ndev->features |= NETIF_F_HIGHDMA;\r\npci_set_drvdata(pdev, dev);\r\nSET_NETDEV_DEV(dev, &pdev->dev);\r\npriv = rtllib_priv(dev);\r\npriv->rtllib = (struct rtllib_device *)netdev_priv_rsl(dev);\r\npriv->pdev = pdev;\r\npriv->rtllib->pdev = pdev;\r\nif ((pdev->subsystem_vendor == PCI_VENDOR_ID_DLINK) &&\r\n(pdev->subsystem_device == 0x3304))\r\npriv->rtllib->bSupportRemoteWakeUp = 1;\r\nelse\r\npriv->rtllib->bSupportRemoteWakeUp = 0;\r\npmem_start = pci_resource_start(pdev, 1);\r\npmem_len = pci_resource_len(pdev, 1);\r\npmem_flags = pci_resource_flags(pdev, 1);\r\nif (!(pmem_flags & IORESOURCE_MEM)) {\r\nRT_TRACE(COMP_ERR, "region #1 not a MMIO resource, aborting");\r\ngoto err_rel_rtllib;\r\n}\r\nprintk(KERN_INFO "Memory mapped space start: 0x%08lx\n", pmem_start);\r\nif (!request_mem_region(pmem_start, pmem_len, DRV_NAME)) {\r\nRT_TRACE(COMP_ERR, "request_mem_region failed!");\r\ngoto err_rel_rtllib;\r\n}\r\nioaddr = (unsigned long)ioremap_nocache(pmem_start, pmem_len);\r\nif (ioaddr == (unsigned long)NULL) {\r\nRT_TRACE(COMP_ERR, "ioremap failed!");\r\ngoto err_rel_mem;\r\n}\r\ndev->mem_start = ioaddr;\r\ndev->mem_end = ioaddr + pci_resource_len(pdev, 0);\r\npci_read_config_byte(pdev, 0x08, &revision_id);\r\nif (pdev->device == 0x8192 && revision_id == 0x10)\r\ngoto err_rel_mem;\r\npriv->ops = ops;\r\nif (rtl8192_pci_findadapter(pdev, dev) == false)\r\ngoto err_rel_mem;\r\ndev->irq = pdev->irq;\r\npriv->irq = 0;\r\ndev->netdev_ops = &rtl8192_netdev_ops;\r\ndev->wireless_handlers = (struct iw_handler_def *)\r\n&r8192_wx_handlers_def;\r\ndev->ethtool_ops = &rtl819x_ethtool_ops;\r\ndev->type = ARPHRD_ETHER;\r\ndev->watchdog_timeo = HZ * 3;\r\nif (dev_alloc_name(dev, ifname) < 0) {\r\nRT_TRACE(COMP_INIT, "Oops: devname already taken! Trying "\r\n"wlan%%d...\n");\r\ndev_alloc_name(dev, ifname);\r\n}\r\nRT_TRACE(COMP_INIT, "Driver probe completed1\n");\r\nif (rtl8192_init(dev) != 0) {\r\nRT_TRACE(COMP_ERR, "Initialization failed");\r\ngoto err_free_irq;\r\n}\r\nnetif_carrier_off(dev);\r\nnetif_stop_queue(dev);\r\nif (register_netdev(dev))\r\ngoto err_free_irq;\r\nRT_TRACE(COMP_INIT, "dev name: %s\n", dev->name);\r\nrtl8192_proc_init_one(dev);\r\nif (priv->polling_timer_on == 0)\r\ncheck_rfctrl_gpio_timer((unsigned long)dev);\r\nRT_TRACE(COMP_INIT, "Driver probe completed\n");\r\nreturn 0;\r\nerr_free_irq:\r\nfree_irq(dev->irq, dev);\r\npriv->irq = 0;\r\nerr_rel_mem:\r\nrelease_mem_region(pmem_start, pmem_len);\r\nerr_rel_rtllib:\r\nfree_rtllib(dev);\r\nDMESG("wlan driver load failed\n");\r\npci_set_drvdata(pdev, NULL);\r\nerr_pci_disable:\r\npci_disable_device(pdev);\r\nreturn err;\r\n}\r\nstatic void rtl8192_pci_disconnect(struct pci_dev *pdev)\r\n{\r\nstruct net_device *dev = pci_get_drvdata(pdev);\r\nstruct r8192_priv *priv ;\r\nu32 i;\r\nif (dev) {\r\nunregister_netdev(dev);\r\npriv = rtllib_priv(dev);\r\ndel_timer_sync(&priv->gpio_polling_timer);\r\ncancel_delayed_work(&priv->gpio_change_rf_wq);\r\npriv->polling_timer_on = 0;\r\nrtl8192_proc_remove_one(dev);\r\nrtl8192_down(dev, true);\r\ndeinit_hal_dm(dev);\r\nif (priv->pFirmware) {\r\nvfree(priv->pFirmware);\r\npriv->pFirmware = NULL;\r\n}\r\ndestroy_workqueue(priv->priv_wq);\r\nrtl8192_free_rx_ring(dev);\r\nfor (i = 0; i < MAX_TX_QUEUE_COUNT; i++)\r\nrtl8192_free_tx_ring(dev, i);\r\nif (priv->irq) {\r\nprintk(KERN_INFO "Freeing irq %d\n", dev->irq);\r\nfree_irq(dev->irq, dev);\r\npriv->irq = 0;\r\n}\r\nfree_rtllib(dev);\r\nkfree(priv->scan_cmd);\r\nif (dev->mem_start != 0) {\r\niounmap((void __iomem *)dev->mem_start);\r\nrelease_mem_region(pci_resource_start(pdev, 1),\r\npci_resource_len(pdev, 1));\r\n}\r\n} else {\r\npriv = rtllib_priv(dev);\r\n}\r\npci_disable_device(pdev);\r\nRT_TRACE(COMP_DOWN, "wlan driver removed\n");\r\n}\r\nbool NicIFEnableNIC(struct net_device *dev)\r\n{\r\nbool init_status = true;\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nstruct rt_pwr_save_ctrl *pPSC = (struct rt_pwr_save_ctrl *)\r\n(&(priv->rtllib->PowerSaveControl));\r\nif (IS_NIC_DOWN(priv)) {\r\nRT_TRACE(COMP_ERR, "ERR!!! %s(): Driver is already down!\n",\r\n__func__);\r\npriv->bdisable_nic = false;\r\nreturn RT_STATUS_FAILURE;\r\n}\r\nRT_TRACE(COMP_PS, "===========>%s()\n", __func__);\r\npriv->bfirst_init = true;\r\ninit_status = priv->ops->initialize_adapter(dev);\r\nif (init_status != true) {\r\nRT_TRACE(COMP_ERR, "ERR!!! %s(): initialization is failed!\n",\r\n__func__);\r\npriv->bdisable_nic = false;\r\nreturn -1;\r\n}\r\nRT_TRACE(COMP_INIT, "start adapter finished\n");\r\nRT_CLEAR_PS_LEVEL(pPSC, RT_RF_OFF_LEVL_HALT_NIC);\r\npriv->bfirst_init = false;\r\nrtl8192_irq_enable(dev);\r\npriv->bdisable_nic = false;\r\nRT_TRACE(COMP_PS, "<===========%s()\n", __func__);\r\nreturn init_status;\r\n}\r\nbool NicIFDisableNIC(struct net_device *dev)\r\n{\r\nbool status = true;\r\nstruct r8192_priv *priv = rtllib_priv(dev);\r\nu8 tmp_state = 0;\r\nRT_TRACE(COMP_PS, "=========>%s()\n", __func__);\r\npriv->bdisable_nic = true;\r\ntmp_state = priv->rtllib->state;\r\nrtllib_softmac_stop_protocol(priv->rtllib, 0, false);\r\npriv->rtllib->state = tmp_state;\r\nrtl8192_cancel_deferred_work(priv);\r\nrtl8192_irq_disable(dev);\r\npriv->ops->stop_adapter(dev, false);\r\nRT_TRACE(COMP_PS, "<=========%s()\n", __func__);\r\nreturn status;\r\n}\r\nstatic int __init rtl8192_pci_module_init(void)\r\n{\r\nprintk(KERN_INFO "\nLinux kernel driver for RTL8192E WLAN cards\n");\r\nprintk(KERN_INFO "Copyright (c) 2007-2008, Realsil Wlan Driver\n");\r\nrtl8192_proc_module_init();\r\nif (0 != pci_register_driver(&rtl8192_pci_driver)) {\r\nDMESG("No device found");\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\n}\r\nstatic void __exit rtl8192_pci_module_exit(void)\r\n{\r\npci_unregister_driver(&rtl8192_pci_driver);\r\nRT_TRACE(COMP_DOWN, "Exiting");\r\nrtl8192_proc_module_remove();\r\n}\r\nvoid check_rfctrl_gpio_timer(unsigned long data)\r\n{\r\nstruct r8192_priv *priv = rtllib_priv((struct net_device *)data);\r\npriv->polling_timer_on = 1;\r\nqueue_delayed_work_rsl(priv->priv_wq, &priv->gpio_change_rf_wq, 0);\r\nmod_timer(&priv->gpio_polling_timer, jiffies +\r\nMSECS(RTLLIB_WATCH_DOG_TIME));\r\n}
