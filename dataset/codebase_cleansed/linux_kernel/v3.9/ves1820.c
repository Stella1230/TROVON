static int ves1820_writereg(struct ves1820_state *state, u8 reg, u8 data)\r\n{\r\nu8 buf[] = { 0x00, reg, data };\r\nstruct i2c_msg msg = {.addr = state->config->demod_address,.flags = 0,.buf = buf,.len = 3 };\r\nint ret;\r\nret = i2c_transfer(state->i2c, &msg, 1);\r\nif (ret != 1)\r\nprintk("ves1820: %s(): writereg error (reg == 0x%02x, "\r\n"val == 0x%02x, ret == %i)\n", __func__, reg, data, ret);\r\nreturn (ret != 1) ? -EREMOTEIO : 0;\r\n}\r\nstatic u8 ves1820_readreg(struct ves1820_state *state, u8 reg)\r\n{\r\nu8 b0[] = { 0x00, reg };\r\nu8 b1[] = { 0 };\r\nstruct i2c_msg msg[] = {\r\n{.addr = state->config->demod_address,.flags = 0,.buf = b0,.len = 2},\r\n{.addr = state->config->demod_address,.flags = I2C_M_RD,.buf = b1,.len = 1}\r\n};\r\nint ret;\r\nret = i2c_transfer(state->i2c, msg, 2);\r\nif (ret != 2)\r\nprintk("ves1820: %s(): readreg error (reg == 0x%02x, "\r\n"ret == %i)\n", __func__, reg, ret);\r\nreturn b1[0];\r\n}\r\nstatic int ves1820_setup_reg0(struct ves1820_state *state, u8 reg0, fe_spectral_inversion_t inversion)\r\n{\r\nreg0 |= state->reg0 & 0x62;\r\nif (INVERSION_ON == inversion) {\r\nif (!state->config->invert) reg0 |= 0x20;\r\nelse reg0 &= ~0x20;\r\n} else if (INVERSION_OFF == inversion) {\r\nif (!state->config->invert) reg0 &= ~0x20;\r\nelse reg0 |= 0x20;\r\n}\r\nves1820_writereg(state, 0x00, reg0 & 0xfe);\r\nves1820_writereg(state, 0x00, reg0 | 0x01);\r\nstate->reg0 = reg0;\r\nreturn 0;\r\n}\r\nstatic int ves1820_set_symbolrate(struct ves1820_state *state, u32 symbolrate)\r\n{\r\ns32 BDR;\r\ns32 BDRI;\r\ns16 SFIL = 0;\r\nu16 NDEC = 0;\r\nu32 ratio;\r\nu32 fin;\r\nu32 tmp;\r\nu64 fptmp;\r\nu64 fpxin;\r\nif (symbolrate > state->config->xin / 2)\r\nsymbolrate = state->config->xin / 2;\r\nif (symbolrate < 500000)\r\nsymbolrate = 500000;\r\nif (symbolrate < state->config->xin / 16)\r\nNDEC = 1;\r\nif (symbolrate < state->config->xin / 32)\r\nNDEC = 2;\r\nif (symbolrate < state->config->xin / 64)\r\nNDEC = 3;\r\nfpxin = state->config->xin * 10;\r\nfptmp = fpxin; do_div(fptmp, 123);\r\nif (symbolrate < fptmp)\r\nSFIL = 1;\r\nfptmp = fpxin; do_div(fptmp, 160);\r\nif (symbolrate < fptmp)\r\nSFIL = 0;\r\nfptmp = fpxin; do_div(fptmp, 246);\r\nif (symbolrate < fptmp)\r\nSFIL = 1;\r\nfptmp = fpxin; do_div(fptmp, 320);\r\nif (symbolrate < fptmp)\r\nSFIL = 0;\r\nfptmp = fpxin; do_div(fptmp, 492);\r\nif (symbolrate < fptmp)\r\nSFIL = 1;\r\nfptmp = fpxin; do_div(fptmp, 640);\r\nif (symbolrate < fptmp)\r\nSFIL = 0;\r\nfptmp = fpxin; do_div(fptmp, 984);\r\nif (symbolrate < fptmp)\r\nSFIL = 1;\r\nfin = state->config->xin >> 4;\r\nsymbolrate <<= NDEC;\r\nratio = (symbolrate << 4) / fin;\r\ntmp = ((symbolrate << 4) % fin) << 8;\r\nratio = (ratio << 8) + tmp / fin;\r\ntmp = (tmp % fin) << 8;\r\nratio = (ratio << 8) + DIV_ROUND_CLOSEST(tmp, fin);\r\nBDR = ratio;\r\nBDRI = (((state->config->xin << 5) / symbolrate) + 1) / 2;\r\nif (BDRI > 0xFF)\r\nBDRI = 0xFF;\r\nSFIL = (SFIL << 4) | ves1820_inittab[0x0E];\r\nNDEC = (NDEC << 6) | ves1820_inittab[0x03];\r\nves1820_writereg(state, 0x03, NDEC);\r\nves1820_writereg(state, 0x0a, BDR & 0xff);\r\nves1820_writereg(state, 0x0b, (BDR >> 8) & 0xff);\r\nves1820_writereg(state, 0x0c, (BDR >> 16) & 0x3f);\r\nves1820_writereg(state, 0x0d, BDRI);\r\nves1820_writereg(state, 0x0e, SFIL);\r\nreturn 0;\r\n}\r\nstatic int ves1820_init(struct dvb_frontend* fe)\r\n{\r\nstruct ves1820_state* state = fe->demodulator_priv;\r\nint i;\r\nves1820_writereg(state, 0, 0);\r\nfor (i = 0; i < sizeof(ves1820_inittab); i++)\r\nves1820_writereg(state, i, ves1820_inittab[i]);\r\nif (state->config->selagc)\r\nves1820_writereg(state, 2, ves1820_inittab[2] | 0x08);\r\nves1820_writereg(state, 0x34, state->pwm);\r\nreturn 0;\r\n}\r\nstatic int ves1820_set_parameters(struct dvb_frontend *fe)\r\n{\r\nstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\r\nstruct ves1820_state* state = fe->demodulator_priv;\r\nstatic const u8 reg0x00[] = { 0x00, 0x04, 0x08, 0x0c, 0x10 };\r\nstatic const u8 reg0x01[] = { 140, 140, 106, 100, 92 };\r\nstatic const u8 reg0x05[] = { 135, 100, 70, 54, 38 };\r\nstatic const u8 reg0x08[] = { 162, 116, 67, 52, 35 };\r\nstatic const u8 reg0x09[] = { 145, 150, 106, 126, 107 };\r\nint real_qam = p->modulation - QAM_16;\r\nif (real_qam < 0 || real_qam > 4)\r\nreturn -EINVAL;\r\nif (fe->ops.tuner_ops.set_params) {\r\nfe->ops.tuner_ops.set_params(fe);\r\nif (fe->ops.i2c_gate_ctrl) fe->ops.i2c_gate_ctrl(fe, 0);\r\n}\r\nves1820_set_symbolrate(state, p->symbol_rate);\r\nves1820_writereg(state, 0x34, state->pwm);\r\nves1820_writereg(state, 0x01, reg0x01[real_qam]);\r\nves1820_writereg(state, 0x05, reg0x05[real_qam]);\r\nves1820_writereg(state, 0x08, reg0x08[real_qam]);\r\nves1820_writereg(state, 0x09, reg0x09[real_qam]);\r\nves1820_setup_reg0(state, reg0x00[real_qam], p->inversion);\r\nves1820_writereg(state, 2, ves1820_inittab[2] | (state->config->selagc ? 0x08 : 0));\r\nreturn 0;\r\n}\r\nstatic int ves1820_read_status(struct dvb_frontend* fe, fe_status_t* status)\r\n{\r\nstruct ves1820_state* state = fe->demodulator_priv;\r\nint sync;\r\n*status = 0;\r\nsync = ves1820_readreg(state, 0x11);\r\nif (sync & 1)\r\n*status |= FE_HAS_SIGNAL;\r\nif (sync & 2)\r\n*status |= FE_HAS_CARRIER;\r\nif (sync & 2)\r\n*status |= FE_HAS_VITERBI;\r\nif (sync & 4)\r\n*status |= FE_HAS_SYNC;\r\nif (sync & 8)\r\n*status |= FE_HAS_LOCK;\r\nreturn 0;\r\n}\r\nstatic int ves1820_read_ber(struct dvb_frontend* fe, u32* ber)\r\n{\r\nstruct ves1820_state* state = fe->demodulator_priv;\r\nu32 _ber = ves1820_readreg(state, 0x14) |\r\n(ves1820_readreg(state, 0x15) << 8) |\r\n((ves1820_readreg(state, 0x16) & 0x0f) << 16);\r\n*ber = 10 * _ber;\r\nreturn 0;\r\n}\r\nstatic int ves1820_read_signal_strength(struct dvb_frontend* fe, u16* strength)\r\n{\r\nstruct ves1820_state* state = fe->demodulator_priv;\r\nu8 gain = ves1820_readreg(state, 0x17);\r\n*strength = (gain << 8) | gain;\r\nreturn 0;\r\n}\r\nstatic int ves1820_read_snr(struct dvb_frontend* fe, u16* snr)\r\n{\r\nstruct ves1820_state* state = fe->demodulator_priv;\r\nu8 quality = ~ves1820_readreg(state, 0x18);\r\n*snr = (quality << 8) | quality;\r\nreturn 0;\r\n}\r\nstatic int ves1820_read_ucblocks(struct dvb_frontend* fe, u32* ucblocks)\r\n{\r\nstruct ves1820_state* state = fe->demodulator_priv;\r\n*ucblocks = ves1820_readreg(state, 0x13) & 0x7f;\r\nif (*ucblocks == 0x7f)\r\n*ucblocks = 0xffffffff;\r\nves1820_writereg(state, 0x10, ves1820_inittab[0x10] & 0xdf);\r\nves1820_writereg(state, 0x10, ves1820_inittab[0x10]);\r\nreturn 0;\r\n}\r\nstatic int ves1820_get_frontend(struct dvb_frontend *fe)\r\n{\r\nstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\r\nstruct ves1820_state* state = fe->demodulator_priv;\r\nint sync;\r\ns8 afc = 0;\r\nsync = ves1820_readreg(state, 0x11);\r\nafc = ves1820_readreg(state, 0x19);\r\nif (verbose) {\r\nprintk(sync & 2 ? "ves1820: AFC (%d) %dHz\n" :\r\n"ves1820: [AFC (%d) %dHz]\n", afc, -((s32) p->symbol_rate * afc) >> 10);\r\n}\r\nif (!state->config->invert) {\r\np->inversion = (state->reg0 & 0x20) ? INVERSION_ON : INVERSION_OFF;\r\n} else {\r\np->inversion = (!(state->reg0 & 0x20)) ? INVERSION_ON : INVERSION_OFF;\r\n}\r\np->modulation = ((state->reg0 >> 2) & 7) + QAM_16;\r\np->fec_inner = FEC_NONE;\r\np->frequency = ((p->frequency + 31250) / 62500) * 62500;\r\nif (sync & 2)\r\np->frequency -= ((s32) p->symbol_rate * afc) >> 10;\r\nreturn 0;\r\n}\r\nstatic int ves1820_sleep(struct dvb_frontend* fe)\r\n{\r\nstruct ves1820_state* state = fe->demodulator_priv;\r\nves1820_writereg(state, 0x1b, 0x02);\r\nves1820_writereg(state, 0x00, 0x80);\r\nreturn 0;\r\n}\r\nstatic int ves1820_get_tune_settings(struct dvb_frontend* fe, struct dvb_frontend_tune_settings* fesettings)\r\n{\r\nfesettings->min_delay_ms = 200;\r\nfesettings->step_size = 0;\r\nfesettings->max_drift = 0;\r\nreturn 0;\r\n}\r\nstatic void ves1820_release(struct dvb_frontend* fe)\r\n{\r\nstruct ves1820_state* state = fe->demodulator_priv;\r\nkfree(state);\r\n}\r\nstruct dvb_frontend* ves1820_attach(const struct ves1820_config* config,\r\nstruct i2c_adapter* i2c,\r\nu8 pwm)\r\n{\r\nstruct ves1820_state* state = NULL;\r\nstate = kzalloc(sizeof(struct ves1820_state), GFP_KERNEL);\r\nif (state == NULL)\r\ngoto error;\r\nstate->reg0 = ves1820_inittab[0];\r\nstate->config = config;\r\nstate->i2c = i2c;\r\nstate->pwm = pwm;\r\nif ((ves1820_readreg(state, 0x1a) & 0xf0) != 0x70)\r\ngoto error;\r\nif (verbose)\r\nprintk("ves1820: pwm=0x%02x\n", state->pwm);\r\nmemcpy(&state->frontend.ops, &ves1820_ops, sizeof(struct dvb_frontend_ops));\r\nstate->frontend.ops.info.symbol_rate_min = (state->config->xin / 2) / 64;\r\nstate->frontend.ops.info.symbol_rate_max = (state->config->xin / 2) / 4;\r\nstate->frontend.demodulator_priv = state;\r\nreturn &state->frontend;\r\nerror:\r\nkfree(state);\r\nreturn NULL;\r\n}
