int\r\nsmb2_calc_signature(struct smb_rqst *rqst, struct TCP_Server_Info *server)\r\n{\r\nint i, rc;\r\nunsigned char smb2_signature[SMB2_HMACSHA256_SIZE];\r\nunsigned char *sigptr = smb2_signature;\r\nstruct kvec *iov = rqst->rq_iov;\r\nint n_vec = rqst->rq_nvec;\r\nstruct smb2_hdr *smb2_pdu = (struct smb2_hdr *)iov[0].iov_base;\r\nmemset(smb2_signature, 0x0, SMB2_HMACSHA256_SIZE);\r\nmemset(smb2_pdu->Signature, 0x0, SMB2_SIGNATURE_SIZE);\r\nrc = crypto_shash_setkey(server->secmech.hmacsha256,\r\nserver->session_key.response, SMB2_NTLMV2_SESSKEY_SIZE);\r\nif (rc) {\r\ncERROR(1, "%s: Could not update with response\n", __func__);\r\nreturn rc;\r\n}\r\nrc = crypto_shash_init(&server->secmech.sdeschmacsha256->shash);\r\nif (rc) {\r\ncERROR(1, "%s: Could not init md5\n", __func__);\r\nreturn rc;\r\n}\r\nfor (i = 0; i < n_vec; i++) {\r\nif (iov[i].iov_len == 0)\r\ncontinue;\r\nif (iov[i].iov_base == NULL) {\r\ncERROR(1, "null iovec entry");\r\nreturn -EIO;\r\n}\r\nif (i == 0) {\r\nif (iov[0].iov_len <= 8)\r\nbreak;\r\nrc =\r\ncrypto_shash_update(\r\n&server->secmech.sdeschmacsha256->shash,\r\niov[i].iov_base + 4, iov[i].iov_len - 4);\r\n} else {\r\nrc =\r\ncrypto_shash_update(\r\n&server->secmech.sdeschmacsha256->shash,\r\niov[i].iov_base, iov[i].iov_len);\r\n}\r\nif (rc) {\r\ncERROR(1, "%s: Could not update with payload\n",\r\n__func__);\r\nreturn rc;\r\n}\r\n}\r\nfor (i = 0; i < rqst->rq_npages; i++) {\r\nstruct kvec p_iov;\r\ncifs_rqst_page_to_kvec(rqst, i, &p_iov);\r\ncrypto_shash_update(&server->secmech.sdeschmacsha256->shash,\r\np_iov.iov_base, p_iov.iov_len);\r\nkunmap(rqst->rq_pages[i]);\r\n}\r\nrc = crypto_shash_final(&server->secmech.sdeschmacsha256->shash,\r\nsigptr);\r\nif (rc)\r\ncERROR(1, "%s: Could not generate sha256 hash\n", __func__);\r\nmemcpy(smb2_pdu->Signature, sigptr, SMB2_SIGNATURE_SIZE);\r\nreturn rc;\r\n}\r\nint\r\nsmb3_calc_signature(struct smb_rqst *rqst, struct TCP_Server_Info *server)\r\n{\r\ncFYI(1, "smb3 signatures not supported yet");\r\nreturn -EOPNOTSUPP;\r\n}\r\nstatic int\r\nsmb2_sign_rqst(struct smb_rqst *rqst, struct TCP_Server_Info *server)\r\n{\r\nint rc = 0;\r\nstruct smb2_hdr *smb2_pdu = rqst->rq_iov[0].iov_base;\r\nif (!(smb2_pdu->Flags & SMB2_FLAGS_SIGNED) ||\r\nserver->tcpStatus == CifsNeedNegotiate)\r\nreturn rc;\r\nif (!server->session_estab) {\r\nstrncpy(smb2_pdu->Signature, "BSRSPYL", 8);\r\nreturn rc;\r\n}\r\nrc = server->ops->calc_signature(rqst, server);\r\nreturn rc;\r\n}\r\nint\r\nsmb2_verify_signature(struct smb_rqst *rqst, struct TCP_Server_Info *server)\r\n{\r\nunsigned int rc;\r\nchar server_response_sig[16];\r\nstruct smb2_hdr *smb2_pdu = (struct smb2_hdr *)rqst->rq_iov[0].iov_base;\r\nif ((smb2_pdu->Command == SMB2_NEGOTIATE) ||\r\n(smb2_pdu->Command == SMB2_OPLOCK_BREAK) ||\r\n(!server->session_estab))\r\nreturn 0;\r\nif (memcmp(smb2_pdu->Signature, "BSRSPYL ", 8) == 0)\r\ncFYI(1, "dummy signature received for smb command 0x%x",\r\nsmb2_pdu->Command);\r\nmemcpy(server_response_sig, smb2_pdu->Signature, SMB2_SIGNATURE_SIZE);\r\nmemset(smb2_pdu->Signature, 0, SMB2_SIGNATURE_SIZE);\r\nmutex_lock(&server->srv_mutex);\r\nrc = server->ops->calc_signature(rqst, server);\r\nmutex_unlock(&server->srv_mutex);\r\nif (rc)\r\nreturn rc;\r\nif (memcmp(server_response_sig, smb2_pdu->Signature,\r\nSMB2_SIGNATURE_SIZE))\r\nreturn -EACCES;\r\nelse\r\nreturn 0;\r\n}\r\nstatic inline void\r\nsmb2_seq_num_into_buf(struct TCP_Server_Info *server, struct smb2_hdr *hdr)\r\n{\r\nhdr->MessageId = get_next_mid(server);\r\n}\r\nstatic struct mid_q_entry *\r\nsmb2_mid_entry_alloc(const struct smb2_hdr *smb_buffer,\r\nstruct TCP_Server_Info *server)\r\n{\r\nstruct mid_q_entry *temp;\r\nif (server == NULL) {\r\ncERROR(1, "Null TCP session in smb2_mid_entry_alloc");\r\nreturn NULL;\r\n}\r\ntemp = mempool_alloc(cifs_mid_poolp, GFP_NOFS);\r\nif (temp == NULL)\r\nreturn temp;\r\nelse {\r\nmemset(temp, 0, sizeof(struct mid_q_entry));\r\ntemp->mid = smb_buffer->MessageId;\r\ntemp->pid = current->pid;\r\ntemp->command = smb_buffer->Command;\r\ntemp->when_alloc = jiffies;\r\ntemp->server = server;\r\ntemp->callback = cifs_wake_up_task;\r\ntemp->callback_data = current;\r\n}\r\natomic_inc(&midCount);\r\ntemp->mid_state = MID_REQUEST_ALLOCATED;\r\nreturn temp;\r\n}\r\nstatic int\r\nsmb2_get_mid_entry(struct cifs_ses *ses, struct smb2_hdr *buf,\r\nstruct mid_q_entry **mid)\r\n{\r\nif (ses->server->tcpStatus == CifsExiting)\r\nreturn -ENOENT;\r\nif (ses->server->tcpStatus == CifsNeedReconnect) {\r\ncFYI(1, "tcp session dead - return to caller to retry");\r\nreturn -EAGAIN;\r\n}\r\nif (ses->status != CifsGood) {\r\nif ((buf->Command != SMB2_SESSION_SETUP) &&\r\n(buf->Command != SMB2_NEGOTIATE))\r\nreturn -EAGAIN;\r\n}\r\n*mid = smb2_mid_entry_alloc(buf, ses->server);\r\nif (*mid == NULL)\r\nreturn -ENOMEM;\r\nspin_lock(&GlobalMid_Lock);\r\nlist_add_tail(&(*mid)->qhead, &ses->server->pending_mid_q);\r\nspin_unlock(&GlobalMid_Lock);\r\nreturn 0;\r\n}\r\nint\r\nsmb2_check_receive(struct mid_q_entry *mid, struct TCP_Server_Info *server,\r\nbool log_error)\r\n{\r\nunsigned int len = get_rfc1002_length(mid->resp_buf);\r\nstruct kvec iov;\r\nstruct smb_rqst rqst = { .rq_iov = &iov,\r\n.rq_nvec = 1 };\r\niov.iov_base = (char *)mid->resp_buf;\r\niov.iov_len = get_rfc1002_length(mid->resp_buf) + 4;\r\ndump_smb(mid->resp_buf, min_t(u32, 80, len));\r\nif ((len > 24) &&\r\n(server->sec_mode & (SECMODE_SIGN_REQUIRED|SECMODE_SIGN_ENABLED))) {\r\nint rc;\r\nrc = smb2_verify_signature(&rqst, server);\r\nif (rc)\r\ncERROR(1, "SMB signature verification returned error = "\r\n"%d", rc);\r\n}\r\nreturn map_smb2_to_linux_error(mid->resp_buf, log_error);\r\n}\r\nstruct mid_q_entry *\r\nsmb2_setup_request(struct cifs_ses *ses, struct smb_rqst *rqst)\r\n{\r\nint rc;\r\nstruct smb2_hdr *hdr = (struct smb2_hdr *)rqst->rq_iov[0].iov_base;\r\nstruct mid_q_entry *mid;\r\nsmb2_seq_num_into_buf(ses->server, hdr);\r\nrc = smb2_get_mid_entry(ses, hdr, &mid);\r\nif (rc)\r\nreturn ERR_PTR(rc);\r\nrc = smb2_sign_rqst(rqst, ses->server);\r\nif (rc) {\r\ncifs_delete_mid(mid);\r\nreturn ERR_PTR(rc);\r\n}\r\nreturn mid;\r\n}\r\nstruct mid_q_entry *\r\nsmb2_setup_async_request(struct TCP_Server_Info *server, struct smb_rqst *rqst)\r\n{\r\nint rc;\r\nstruct smb2_hdr *hdr = (struct smb2_hdr *)rqst->rq_iov[0].iov_base;\r\nstruct mid_q_entry *mid;\r\nsmb2_seq_num_into_buf(server, hdr);\r\nmid = smb2_mid_entry_alloc(hdr, server);\r\nif (mid == NULL)\r\nreturn ERR_PTR(-ENOMEM);\r\nrc = smb2_sign_rqst(rqst, server);\r\nif (rc) {\r\nDeleteMidQEntry(mid);\r\nreturn ERR_PTR(rc);\r\n}\r\nreturn mid;\r\n}
