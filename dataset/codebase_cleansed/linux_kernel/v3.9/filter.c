static u16 efx_filter_hash(u32 key)\r\n{\r\nu16 tmp;\r\ntmp = 0x1fff ^ key >> 16;\r\ntmp = tmp ^ tmp >> 3 ^ tmp >> 6;\r\ntmp = tmp ^ tmp >> 9;\r\ntmp = tmp ^ tmp << 13 ^ key;\r\ntmp = tmp ^ tmp >> 3 ^ tmp >> 6;\r\nreturn tmp ^ tmp >> 9;\r\n}\r\nstatic u16 efx_filter_increment(u32 key)\r\n{\r\nreturn key * 2 - 1;\r\n}\r\nstatic enum efx_filter_table_id\r\nefx_filter_spec_table_id(const struct efx_filter_spec *spec)\r\n{\r\nBUILD_BUG_ON(EFX_FILTER_TABLE_RX_IP != (EFX_FILTER_TCP_FULL >> 2));\r\nBUILD_BUG_ON(EFX_FILTER_TABLE_RX_IP != (EFX_FILTER_TCP_WILD >> 2));\r\nBUILD_BUG_ON(EFX_FILTER_TABLE_RX_IP != (EFX_FILTER_UDP_FULL >> 2));\r\nBUILD_BUG_ON(EFX_FILTER_TABLE_RX_IP != (EFX_FILTER_UDP_WILD >> 2));\r\nBUILD_BUG_ON(EFX_FILTER_TABLE_RX_MAC != (EFX_FILTER_MAC_FULL >> 2));\r\nBUILD_BUG_ON(EFX_FILTER_TABLE_RX_MAC != (EFX_FILTER_MAC_WILD >> 2));\r\nBUILD_BUG_ON(EFX_FILTER_TABLE_TX_MAC != EFX_FILTER_TABLE_RX_MAC + 2);\r\nEFX_BUG_ON_PARANOID(spec->type == EFX_FILTER_UNSPEC);\r\nreturn (spec->type >> 2) + ((spec->flags & EFX_FILTER_FLAG_TX) ? 2 : 0);\r\n}\r\nstatic struct efx_filter_table *\r\nefx_filter_spec_table(struct efx_filter_state *state,\r\nconst struct efx_filter_spec *spec)\r\n{\r\nif (spec->type == EFX_FILTER_UNSPEC)\r\nreturn NULL;\r\nelse\r\nreturn &state->table[efx_filter_spec_table_id(spec)];\r\n}\r\nstatic void efx_filter_table_reset_search_depth(struct efx_filter_table *table)\r\n{\r\nmemset(table->search_depth, 0, sizeof(table->search_depth));\r\n}\r\nstatic void efx_filter_push_rx_config(struct efx_nic *efx)\r\n{\r\nstruct efx_filter_state *state = efx->filter_state;\r\nstruct efx_filter_table *table;\r\nefx_oword_t filter_ctl;\r\nefx_reado(efx, &filter_ctl, FR_BZ_RX_FILTER_CTL);\r\ntable = &state->table[EFX_FILTER_TABLE_RX_IP];\r\nEFX_SET_OWORD_FIELD(filter_ctl, FRF_BZ_TCP_FULL_SRCH_LIMIT,\r\ntable->search_depth[EFX_FILTER_TCP_FULL] +\r\nFILTER_CTL_SRCH_FUDGE_FULL);\r\nEFX_SET_OWORD_FIELD(filter_ctl, FRF_BZ_TCP_WILD_SRCH_LIMIT,\r\ntable->search_depth[EFX_FILTER_TCP_WILD] +\r\nFILTER_CTL_SRCH_FUDGE_WILD);\r\nEFX_SET_OWORD_FIELD(filter_ctl, FRF_BZ_UDP_FULL_SRCH_LIMIT,\r\ntable->search_depth[EFX_FILTER_UDP_FULL] +\r\nFILTER_CTL_SRCH_FUDGE_FULL);\r\nEFX_SET_OWORD_FIELD(filter_ctl, FRF_BZ_UDP_WILD_SRCH_LIMIT,\r\ntable->search_depth[EFX_FILTER_UDP_WILD] +\r\nFILTER_CTL_SRCH_FUDGE_WILD);\r\ntable = &state->table[EFX_FILTER_TABLE_RX_MAC];\r\nif (table->size) {\r\nEFX_SET_OWORD_FIELD(\r\nfilter_ctl, FRF_CZ_ETHERNET_FULL_SEARCH_LIMIT,\r\ntable->search_depth[EFX_FILTER_MAC_FULL] +\r\nFILTER_CTL_SRCH_FUDGE_FULL);\r\nEFX_SET_OWORD_FIELD(\r\nfilter_ctl, FRF_CZ_ETHERNET_WILDCARD_SEARCH_LIMIT,\r\ntable->search_depth[EFX_FILTER_MAC_WILD] +\r\nFILTER_CTL_SRCH_FUDGE_WILD);\r\n}\r\ntable = &state->table[EFX_FILTER_TABLE_RX_DEF];\r\nif (table->size) {\r\nEFX_SET_OWORD_FIELD(\r\nfilter_ctl, FRF_CZ_UNICAST_NOMATCH_Q_ID,\r\ntable->spec[EFX_FILTER_INDEX_UC_DEF].dmaq_id);\r\nEFX_SET_OWORD_FIELD(\r\nfilter_ctl, FRF_CZ_UNICAST_NOMATCH_RSS_ENABLED,\r\n!!(table->spec[EFX_FILTER_INDEX_UC_DEF].flags &\r\nEFX_FILTER_FLAG_RX_RSS));\r\nEFX_SET_OWORD_FIELD(\r\nfilter_ctl, FRF_CZ_MULTICAST_NOMATCH_Q_ID,\r\ntable->spec[EFX_FILTER_INDEX_MC_DEF].dmaq_id);\r\nEFX_SET_OWORD_FIELD(\r\nfilter_ctl, FRF_CZ_MULTICAST_NOMATCH_RSS_ENABLED,\r\n!!(table->spec[EFX_FILTER_INDEX_MC_DEF].flags &\r\nEFX_FILTER_FLAG_RX_RSS));\r\n}\r\nefx_writeo(efx, &filter_ctl, FR_BZ_RX_FILTER_CTL);\r\n}\r\nstatic void efx_filter_push_tx_limits(struct efx_nic *efx)\r\n{\r\nstruct efx_filter_state *state = efx->filter_state;\r\nstruct efx_filter_table *table;\r\nefx_oword_t tx_cfg;\r\nefx_reado(efx, &tx_cfg, FR_AZ_TX_CFG);\r\ntable = &state->table[EFX_FILTER_TABLE_TX_MAC];\r\nif (table->size) {\r\nEFX_SET_OWORD_FIELD(\r\ntx_cfg, FRF_CZ_TX_ETH_FILTER_FULL_SEARCH_RANGE,\r\ntable->search_depth[EFX_FILTER_MAC_FULL] +\r\nFILTER_CTL_SRCH_FUDGE_FULL);\r\nEFX_SET_OWORD_FIELD(\r\ntx_cfg, FRF_CZ_TX_ETH_FILTER_WILD_SEARCH_RANGE,\r\ntable->search_depth[EFX_FILTER_MAC_WILD] +\r\nFILTER_CTL_SRCH_FUDGE_WILD);\r\n}\r\nefx_writeo(efx, &tx_cfg, FR_AZ_TX_CFG);\r\n}\r\nstatic inline void __efx_filter_set_ipv4(struct efx_filter_spec *spec,\r\n__be32 host1, __be16 port1,\r\n__be32 host2, __be16 port2)\r\n{\r\nspec->data[0] = ntohl(host1) << 16 | ntohs(port1);\r\nspec->data[1] = ntohs(port2) << 16 | ntohl(host1) >> 16;\r\nspec->data[2] = ntohl(host2);\r\n}\r\nstatic inline void __efx_filter_get_ipv4(const struct efx_filter_spec *spec,\r\n__be32 *host1, __be16 *port1,\r\n__be32 *host2, __be16 *port2)\r\n{\r\n*host1 = htonl(spec->data[0] >> 16 | spec->data[1] << 16);\r\n*port1 = htons(spec->data[0]);\r\n*host2 = htonl(spec->data[2]);\r\n*port2 = htons(spec->data[1] >> 16);\r\n}\r\nint efx_filter_set_ipv4_local(struct efx_filter_spec *spec, u8 proto,\r\n__be32 host, __be16 port)\r\n{\r\n__be32 host1;\r\n__be16 port1;\r\nEFX_BUG_ON_PARANOID(!(spec->flags & EFX_FILTER_FLAG_RX));\r\nif (spec->type != EFX_FILTER_UNSPEC)\r\nreturn -EPROTONOSUPPORT;\r\nif (port == 0)\r\nreturn -EINVAL;\r\nswitch (proto) {\r\ncase IPPROTO_TCP:\r\nspec->type = EFX_FILTER_TCP_WILD;\r\nbreak;\r\ncase IPPROTO_UDP:\r\nspec->type = EFX_FILTER_UDP_WILD;\r\nbreak;\r\ndefault:\r\nreturn -EPROTONOSUPPORT;\r\n}\r\nhost1 = 0;\r\nif (proto != IPPROTO_UDP) {\r\nport1 = 0;\r\n} else {\r\nport1 = port;\r\nport = 0;\r\n}\r\n__efx_filter_set_ipv4(spec, host1, port1, host, port);\r\nreturn 0;\r\n}\r\nint efx_filter_get_ipv4_local(const struct efx_filter_spec *spec,\r\nu8 *proto, __be32 *host, __be16 *port)\r\n{\r\n__be32 host1;\r\n__be16 port1;\r\nswitch (spec->type) {\r\ncase EFX_FILTER_TCP_WILD:\r\n*proto = IPPROTO_TCP;\r\n__efx_filter_get_ipv4(spec, &host1, &port1, host, port);\r\nreturn 0;\r\ncase EFX_FILTER_UDP_WILD:\r\n*proto = IPPROTO_UDP;\r\n__efx_filter_get_ipv4(spec, &host1, port, host, &port1);\r\nreturn 0;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nint efx_filter_set_ipv4_full(struct efx_filter_spec *spec, u8 proto,\r\n__be32 host, __be16 port,\r\n__be32 rhost, __be16 rport)\r\n{\r\nEFX_BUG_ON_PARANOID(!(spec->flags & EFX_FILTER_FLAG_RX));\r\nif (spec->type != EFX_FILTER_UNSPEC)\r\nreturn -EPROTONOSUPPORT;\r\nif (port == 0 || rport == 0)\r\nreturn -EINVAL;\r\nswitch (proto) {\r\ncase IPPROTO_TCP:\r\nspec->type = EFX_FILTER_TCP_FULL;\r\nbreak;\r\ncase IPPROTO_UDP:\r\nspec->type = EFX_FILTER_UDP_FULL;\r\nbreak;\r\ndefault:\r\nreturn -EPROTONOSUPPORT;\r\n}\r\n__efx_filter_set_ipv4(spec, rhost, rport, host, port);\r\nreturn 0;\r\n}\r\nint efx_filter_get_ipv4_full(const struct efx_filter_spec *spec,\r\nu8 *proto, __be32 *host, __be16 *port,\r\n__be32 *rhost, __be16 *rport)\r\n{\r\nswitch (spec->type) {\r\ncase EFX_FILTER_TCP_FULL:\r\n*proto = IPPROTO_TCP;\r\nbreak;\r\ncase EFX_FILTER_UDP_FULL:\r\n*proto = IPPROTO_UDP;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n__efx_filter_get_ipv4(spec, rhost, rport, host, port);\r\nreturn 0;\r\n}\r\nint efx_filter_set_eth_local(struct efx_filter_spec *spec,\r\nu16 vid, const u8 *addr)\r\n{\r\nEFX_BUG_ON_PARANOID(!(spec->flags &\r\n(EFX_FILTER_FLAG_RX | EFX_FILTER_FLAG_TX)));\r\nif (spec->type != EFX_FILTER_UNSPEC)\r\nreturn -EPROTONOSUPPORT;\r\nif (vid == EFX_FILTER_VID_UNSPEC) {\r\nspec->type = EFX_FILTER_MAC_WILD;\r\nspec->data[0] = 0;\r\n} else {\r\nspec->type = EFX_FILTER_MAC_FULL;\r\nspec->data[0] = vid;\r\n}\r\nspec->data[1] = addr[2] << 24 | addr[3] << 16 | addr[4] << 8 | addr[5];\r\nspec->data[2] = addr[0] << 8 | addr[1];\r\nreturn 0;\r\n}\r\nint efx_filter_set_uc_def(struct efx_filter_spec *spec)\r\n{\r\nEFX_BUG_ON_PARANOID(!(spec->flags &\r\n(EFX_FILTER_FLAG_RX | EFX_FILTER_FLAG_TX)));\r\nif (spec->type != EFX_FILTER_UNSPEC)\r\nreturn -EINVAL;\r\nspec->type = EFX_FILTER_UC_DEF;\r\nmemset(spec->data, 0, sizeof(spec->data));\r\nreturn 0;\r\n}\r\nint efx_filter_set_mc_def(struct efx_filter_spec *spec)\r\n{\r\nEFX_BUG_ON_PARANOID(!(spec->flags &\r\n(EFX_FILTER_FLAG_RX | EFX_FILTER_FLAG_TX)));\r\nif (spec->type != EFX_FILTER_UNSPEC)\r\nreturn -EINVAL;\r\nspec->type = EFX_FILTER_MC_DEF;\r\nmemset(spec->data, 0, sizeof(spec->data));\r\nreturn 0;\r\n}\r\nstatic void efx_filter_reset_rx_def(struct efx_nic *efx, unsigned filter_idx)\r\n{\r\nstruct efx_filter_state *state = efx->filter_state;\r\nstruct efx_filter_table *table = &state->table[EFX_FILTER_TABLE_RX_DEF];\r\nstruct efx_filter_spec *spec = &table->spec[filter_idx];\r\nefx_filter_init_rx(spec, EFX_FILTER_PRI_MANUAL,\r\nEFX_FILTER_FLAG_RX_RSS, 0);\r\nspec->type = EFX_FILTER_UC_DEF + filter_idx;\r\ntable->used_bitmap[0] |= 1 << filter_idx;\r\n}\r\nint efx_filter_get_eth_local(const struct efx_filter_spec *spec,\r\nu16 *vid, u8 *addr)\r\n{\r\nswitch (spec->type) {\r\ncase EFX_FILTER_MAC_WILD:\r\n*vid = EFX_FILTER_VID_UNSPEC;\r\nbreak;\r\ncase EFX_FILTER_MAC_FULL:\r\n*vid = spec->data[0];\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\naddr[0] = spec->data[2] >> 8;\r\naddr[1] = spec->data[2];\r\naddr[2] = spec->data[1] >> 24;\r\naddr[3] = spec->data[1] >> 16;\r\naddr[4] = spec->data[1] >> 8;\r\naddr[5] = spec->data[1];\r\nreturn 0;\r\n}\r\nstatic u32 efx_filter_build(efx_oword_t *filter, struct efx_filter_spec *spec)\r\n{\r\nu32 data3;\r\nswitch (efx_filter_spec_table_id(spec)) {\r\ncase EFX_FILTER_TABLE_RX_IP: {\r\nbool is_udp = (spec->type == EFX_FILTER_UDP_FULL ||\r\nspec->type == EFX_FILTER_UDP_WILD);\r\nEFX_POPULATE_OWORD_7(\r\n*filter,\r\nFRF_BZ_RSS_EN,\r\n!!(spec->flags & EFX_FILTER_FLAG_RX_RSS),\r\nFRF_BZ_SCATTER_EN,\r\n!!(spec->flags & EFX_FILTER_FLAG_RX_SCATTER),\r\nFRF_BZ_TCP_UDP, is_udp,\r\nFRF_BZ_RXQ_ID, spec->dmaq_id,\r\nEFX_DWORD_2, spec->data[2],\r\nEFX_DWORD_1, spec->data[1],\r\nEFX_DWORD_0, spec->data[0]);\r\ndata3 = is_udp;\r\nbreak;\r\n}\r\ncase EFX_FILTER_TABLE_RX_DEF:\r\nBUILD_BUG_ON(EFX_FILTER_INDEX_UC_DEF != 0);\r\nBUILD_BUG_ON(EFX_FILTER_INDEX_MC_DEF !=\r\nEFX_FILTER_MC_DEF - EFX_FILTER_UC_DEF);\r\nreturn spec->type - EFX_FILTER_UC_DEF;\r\ncase EFX_FILTER_TABLE_RX_MAC: {\r\nbool is_wild = spec->type == EFX_FILTER_MAC_WILD;\r\nEFX_POPULATE_OWORD_7(\r\n*filter,\r\nFRF_CZ_RMFT_RSS_EN,\r\n!!(spec->flags & EFX_FILTER_FLAG_RX_RSS),\r\nFRF_CZ_RMFT_SCATTER_EN,\r\n!!(spec->flags & EFX_FILTER_FLAG_RX_SCATTER),\r\nFRF_CZ_RMFT_RXQ_ID, spec->dmaq_id,\r\nFRF_CZ_RMFT_WILDCARD_MATCH, is_wild,\r\nFRF_CZ_RMFT_DEST_MAC_HI, spec->data[2],\r\nFRF_CZ_RMFT_DEST_MAC_LO, spec->data[1],\r\nFRF_CZ_RMFT_VLAN_ID, spec->data[0]);\r\ndata3 = is_wild;\r\nbreak;\r\n}\r\ncase EFX_FILTER_TABLE_TX_MAC: {\r\nbool is_wild = spec->type == EFX_FILTER_MAC_WILD;\r\nEFX_POPULATE_OWORD_5(*filter,\r\nFRF_CZ_TMFT_TXQ_ID, spec->dmaq_id,\r\nFRF_CZ_TMFT_WILDCARD_MATCH, is_wild,\r\nFRF_CZ_TMFT_SRC_MAC_HI, spec->data[2],\r\nFRF_CZ_TMFT_SRC_MAC_LO, spec->data[1],\r\nFRF_CZ_TMFT_VLAN_ID, spec->data[0]);\r\ndata3 = is_wild | spec->dmaq_id << 1;\r\nbreak;\r\n}\r\ndefault:\r\nBUG();\r\n}\r\nreturn spec->data[0] ^ spec->data[1] ^ spec->data[2] ^ data3;\r\n}\r\nstatic bool efx_filter_equal(const struct efx_filter_spec *left,\r\nconst struct efx_filter_spec *right)\r\n{\r\nif (left->type != right->type ||\r\nmemcmp(left->data, right->data, sizeof(left->data)))\r\nreturn false;\r\nif (left->flags & EFX_FILTER_FLAG_TX &&\r\nleft->dmaq_id != right->dmaq_id)\r\nreturn false;\r\nreturn true;\r\n}\r\nstatic int efx_filter_search(struct efx_filter_table *table,\r\nstruct efx_filter_spec *spec, u32 key,\r\nbool for_insert, unsigned int *depth_required)\r\n{\r\nunsigned hash, incr, filter_idx, depth, depth_max;\r\nhash = efx_filter_hash(key);\r\nincr = efx_filter_increment(key);\r\nfilter_idx = hash & (table->size - 1);\r\ndepth = 1;\r\ndepth_max = (for_insert ?\r\n(spec->priority <= EFX_FILTER_PRI_HINT ?\r\nFILTER_CTL_SRCH_HINT_MAX : FILTER_CTL_SRCH_MAX) :\r\ntable->search_depth[spec->type]);\r\nfor (;;) {\r\nif (test_bit(filter_idx, table->used_bitmap) ?\r\nefx_filter_equal(spec, &table->spec[filter_idx]) :\r\nfor_insert) {\r\n*depth_required = depth;\r\nreturn filter_idx;\r\n}\r\nif (depth == depth_max)\r\nreturn for_insert ? -EBUSY : -ENOENT;\r\nfilter_idx = (filter_idx + incr) & (table->size - 1);\r\n++depth;\r\n}\r\n}\r\nstatic inline u32\r\nefx_filter_make_id(const struct efx_filter_spec *spec, unsigned int index)\r\n{\r\nunsigned int range;\r\nrange = efx_filter_type_match_pri[spec->type];\r\nif (!(spec->flags & EFX_FILTER_FLAG_RX))\r\nrange += EFX_FILTER_MATCH_PRI_COUNT;\r\nreturn range << EFX_FILTER_INDEX_WIDTH | index;\r\n}\r\nstatic inline enum efx_filter_table_id efx_filter_id_table_id(u32 id)\r\n{\r\nunsigned int range = id >> EFX_FILTER_INDEX_WIDTH;\r\nif (range < ARRAY_SIZE(efx_filter_range_table))\r\nreturn efx_filter_range_table[range];\r\nelse\r\nreturn EFX_FILTER_TABLE_COUNT;\r\n}\r\nstatic inline unsigned int efx_filter_id_index(u32 id)\r\n{\r\nreturn id & EFX_FILTER_INDEX_MASK;\r\n}\r\nstatic inline u8 efx_filter_id_flags(u32 id)\r\n{\r\nunsigned int range = id >> EFX_FILTER_INDEX_WIDTH;\r\nif (range < EFX_FILTER_MATCH_PRI_COUNT)\r\nreturn EFX_FILTER_FLAG_RX;\r\nelse\r\nreturn EFX_FILTER_FLAG_TX;\r\n}\r\nu32 efx_filter_get_rx_id_limit(struct efx_nic *efx)\r\n{\r\nstruct efx_filter_state *state = efx->filter_state;\r\nunsigned int range = EFX_FILTER_MATCH_PRI_COUNT - 1;\r\nenum efx_filter_table_id table_id;\r\ndo {\r\ntable_id = efx_filter_range_table[range];\r\nif (state->table[table_id].size != 0)\r\nreturn range << EFX_FILTER_INDEX_WIDTH |\r\nstate->table[table_id].size;\r\n} while (range--);\r\nreturn 0;\r\n}\r\ns32 efx_filter_insert_filter(struct efx_nic *efx, struct efx_filter_spec *spec,\r\nbool replace)\r\n{\r\nstruct efx_filter_state *state = efx->filter_state;\r\nstruct efx_filter_table *table = efx_filter_spec_table(state, spec);\r\nstruct efx_filter_spec *saved_spec;\r\nefx_oword_t filter;\r\nunsigned int filter_idx, depth = 0;\r\nu32 key;\r\nint rc;\r\nif (!table || table->size == 0)\r\nreturn -EINVAL;\r\nkey = efx_filter_build(&filter, spec);\r\nnetif_vdbg(efx, hw, efx->net_dev,\r\n"%s: type %d search_depth=%d", __func__, spec->type,\r\ntable->search_depth[spec->type]);\r\nspin_lock_bh(&state->lock);\r\nrc = efx_filter_search(table, spec, key, true, &depth);\r\nif (rc < 0)\r\ngoto out;\r\nfilter_idx = rc;\r\nBUG_ON(filter_idx >= table->size);\r\nsaved_spec = &table->spec[filter_idx];\r\nif (test_bit(filter_idx, table->used_bitmap)) {\r\nif (!replace) {\r\nrc = -EEXIST;\r\ngoto out;\r\n}\r\nif (spec->priority < saved_spec->priority) {\r\nrc = -EPERM;\r\ngoto out;\r\n}\r\n} else {\r\n__set_bit(filter_idx, table->used_bitmap);\r\n++table->used;\r\n}\r\n*saved_spec = *spec;\r\nif (table->id == EFX_FILTER_TABLE_RX_DEF) {\r\nefx_filter_push_rx_config(efx);\r\n} else {\r\nif (table->search_depth[spec->type] < depth) {\r\ntable->search_depth[spec->type] = depth;\r\nif (spec->flags & EFX_FILTER_FLAG_TX)\r\nefx_filter_push_tx_limits(efx);\r\nelse\r\nefx_filter_push_rx_config(efx);\r\n}\r\nefx_writeo(efx, &filter,\r\ntable->offset + table->step * filter_idx);\r\n}\r\nnetif_vdbg(efx, hw, efx->net_dev,\r\n"%s: filter type %d index %d rxq %u set",\r\n__func__, spec->type, filter_idx, spec->dmaq_id);\r\nrc = efx_filter_make_id(spec, filter_idx);\r\nout:\r\nspin_unlock_bh(&state->lock);\r\nreturn rc;\r\n}\r\nstatic void efx_filter_table_clear_entry(struct efx_nic *efx,\r\nstruct efx_filter_table *table,\r\nunsigned int filter_idx)\r\n{\r\nstatic efx_oword_t filter;\r\nif (table->id == EFX_FILTER_TABLE_RX_DEF) {\r\nefx_filter_reset_rx_def(efx, filter_idx);\r\nefx_filter_push_rx_config(efx);\r\n} else if (test_bit(filter_idx, table->used_bitmap)) {\r\n__clear_bit(filter_idx, table->used_bitmap);\r\n--table->used;\r\nmemset(&table->spec[filter_idx], 0, sizeof(table->spec[0]));\r\nefx_writeo(efx, &filter,\r\ntable->offset + table->step * filter_idx);\r\n}\r\n}\r\nint efx_filter_remove_id_safe(struct efx_nic *efx,\r\nenum efx_filter_priority priority,\r\nu32 filter_id)\r\n{\r\nstruct efx_filter_state *state = efx->filter_state;\r\nenum efx_filter_table_id table_id;\r\nstruct efx_filter_table *table;\r\nunsigned int filter_idx;\r\nstruct efx_filter_spec *spec;\r\nu8 filter_flags;\r\nint rc;\r\ntable_id = efx_filter_id_table_id(filter_id);\r\nif ((unsigned int)table_id >= EFX_FILTER_TABLE_COUNT)\r\nreturn -ENOENT;\r\ntable = &state->table[table_id];\r\nfilter_idx = efx_filter_id_index(filter_id);\r\nif (filter_idx >= table->size)\r\nreturn -ENOENT;\r\nspec = &table->spec[filter_idx];\r\nfilter_flags = efx_filter_id_flags(filter_id);\r\nspin_lock_bh(&state->lock);\r\nif (test_bit(filter_idx, table->used_bitmap) &&\r\nspec->priority == priority) {\r\nefx_filter_table_clear_entry(efx, table, filter_idx);\r\nif (table->used == 0)\r\nefx_filter_table_reset_search_depth(table);\r\nrc = 0;\r\n} else {\r\nrc = -ENOENT;\r\n}\r\nspin_unlock_bh(&state->lock);\r\nreturn rc;\r\n}\r\nint efx_filter_get_filter_safe(struct efx_nic *efx,\r\nenum efx_filter_priority priority,\r\nu32 filter_id, struct efx_filter_spec *spec_buf)\r\n{\r\nstruct efx_filter_state *state = efx->filter_state;\r\nenum efx_filter_table_id table_id;\r\nstruct efx_filter_table *table;\r\nstruct efx_filter_spec *spec;\r\nunsigned int filter_idx;\r\nu8 filter_flags;\r\nint rc;\r\ntable_id = efx_filter_id_table_id(filter_id);\r\nif ((unsigned int)table_id >= EFX_FILTER_TABLE_COUNT)\r\nreturn -ENOENT;\r\ntable = &state->table[table_id];\r\nfilter_idx = efx_filter_id_index(filter_id);\r\nif (filter_idx >= table->size)\r\nreturn -ENOENT;\r\nspec = &table->spec[filter_idx];\r\nfilter_flags = efx_filter_id_flags(filter_id);\r\nspin_lock_bh(&state->lock);\r\nif (test_bit(filter_idx, table->used_bitmap) &&\r\nspec->priority == priority) {\r\n*spec_buf = *spec;\r\nrc = 0;\r\n} else {\r\nrc = -ENOENT;\r\n}\r\nspin_unlock_bh(&state->lock);\r\nreturn rc;\r\n}\r\nstatic void efx_filter_table_clear(struct efx_nic *efx,\r\nenum efx_filter_table_id table_id,\r\nenum efx_filter_priority priority)\r\n{\r\nstruct efx_filter_state *state = efx->filter_state;\r\nstruct efx_filter_table *table = &state->table[table_id];\r\nunsigned int filter_idx;\r\nspin_lock_bh(&state->lock);\r\nfor (filter_idx = 0; filter_idx < table->size; ++filter_idx)\r\nif (table->spec[filter_idx].priority <= priority)\r\nefx_filter_table_clear_entry(efx, table, filter_idx);\r\nif (table->used == 0)\r\nefx_filter_table_reset_search_depth(table);\r\nspin_unlock_bh(&state->lock);\r\n}\r\nvoid efx_filter_clear_rx(struct efx_nic *efx, enum efx_filter_priority priority)\r\n{\r\nefx_filter_table_clear(efx, EFX_FILTER_TABLE_RX_IP, priority);\r\nefx_filter_table_clear(efx, EFX_FILTER_TABLE_RX_MAC, priority);\r\n}\r\nu32 efx_filter_count_rx_used(struct efx_nic *efx,\r\nenum efx_filter_priority priority)\r\n{\r\nstruct efx_filter_state *state = efx->filter_state;\r\nenum efx_filter_table_id table_id;\r\nstruct efx_filter_table *table;\r\nunsigned int filter_idx;\r\nu32 count = 0;\r\nspin_lock_bh(&state->lock);\r\nfor (table_id = EFX_FILTER_TABLE_RX_IP;\r\ntable_id <= EFX_FILTER_TABLE_RX_DEF;\r\ntable_id++) {\r\ntable = &state->table[table_id];\r\nfor (filter_idx = 0; filter_idx < table->size; filter_idx++) {\r\nif (test_bit(filter_idx, table->used_bitmap) &&\r\ntable->spec[filter_idx].priority == priority)\r\n++count;\r\n}\r\n}\r\nspin_unlock_bh(&state->lock);\r\nreturn count;\r\n}\r\ns32 efx_filter_get_rx_ids(struct efx_nic *efx,\r\nenum efx_filter_priority priority,\r\nu32 *buf, u32 size)\r\n{\r\nstruct efx_filter_state *state = efx->filter_state;\r\nenum efx_filter_table_id table_id;\r\nstruct efx_filter_table *table;\r\nunsigned int filter_idx;\r\ns32 count = 0;\r\nspin_lock_bh(&state->lock);\r\nfor (table_id = EFX_FILTER_TABLE_RX_IP;\r\ntable_id <= EFX_FILTER_TABLE_RX_DEF;\r\ntable_id++) {\r\ntable = &state->table[table_id];\r\nfor (filter_idx = 0; filter_idx < table->size; filter_idx++) {\r\nif (test_bit(filter_idx, table->used_bitmap) &&\r\ntable->spec[filter_idx].priority == priority) {\r\nif (count == size) {\r\ncount = -EMSGSIZE;\r\ngoto out;\r\n}\r\nbuf[count++] = efx_filter_make_id(\r\n&table->spec[filter_idx], filter_idx);\r\n}\r\n}\r\n}\r\nout:\r\nspin_unlock_bh(&state->lock);\r\nreturn count;\r\n}\r\nvoid efx_restore_filters(struct efx_nic *efx)\r\n{\r\nstruct efx_filter_state *state = efx->filter_state;\r\nenum efx_filter_table_id table_id;\r\nstruct efx_filter_table *table;\r\nefx_oword_t filter;\r\nunsigned int filter_idx;\r\nspin_lock_bh(&state->lock);\r\nfor (table_id = 0; table_id < EFX_FILTER_TABLE_COUNT; table_id++) {\r\ntable = &state->table[table_id];\r\nif (table->step == 0)\r\ncontinue;\r\nfor (filter_idx = 0; filter_idx < table->size; filter_idx++) {\r\nif (!test_bit(filter_idx, table->used_bitmap))\r\ncontinue;\r\nefx_filter_build(&filter, &table->spec[filter_idx]);\r\nefx_writeo(efx, &filter,\r\ntable->offset + table->step * filter_idx);\r\n}\r\n}\r\nefx_filter_push_rx_config(efx);\r\nefx_filter_push_tx_limits(efx);\r\nspin_unlock_bh(&state->lock);\r\n}\r\nint efx_probe_filters(struct efx_nic *efx)\r\n{\r\nstruct efx_filter_state *state;\r\nstruct efx_filter_table *table;\r\nunsigned table_id;\r\nstate = kzalloc(sizeof(*efx->filter_state), GFP_KERNEL);\r\nif (!state)\r\nreturn -ENOMEM;\r\nefx->filter_state = state;\r\nspin_lock_init(&state->lock);\r\nif (efx_nic_rev(efx) >= EFX_REV_FALCON_B0) {\r\n#ifdef CONFIG_RFS_ACCEL\r\nstate->rps_flow_id = kcalloc(FR_BZ_RX_FILTER_TBL0_ROWS,\r\nsizeof(*state->rps_flow_id),\r\nGFP_KERNEL);\r\nif (!state->rps_flow_id)\r\ngoto fail;\r\n#endif\r\ntable = &state->table[EFX_FILTER_TABLE_RX_IP];\r\ntable->id = EFX_FILTER_TABLE_RX_IP;\r\ntable->offset = FR_BZ_RX_FILTER_TBL0;\r\ntable->size = FR_BZ_RX_FILTER_TBL0_ROWS;\r\ntable->step = FR_BZ_RX_FILTER_TBL0_STEP;\r\n}\r\nif (efx_nic_rev(efx) >= EFX_REV_SIENA_A0) {\r\ntable = &state->table[EFX_FILTER_TABLE_RX_MAC];\r\ntable->id = EFX_FILTER_TABLE_RX_MAC;\r\ntable->offset = FR_CZ_RX_MAC_FILTER_TBL0;\r\ntable->size = FR_CZ_RX_MAC_FILTER_TBL0_ROWS;\r\ntable->step = FR_CZ_RX_MAC_FILTER_TBL0_STEP;\r\ntable = &state->table[EFX_FILTER_TABLE_RX_DEF];\r\ntable->id = EFX_FILTER_TABLE_RX_DEF;\r\ntable->size = EFX_FILTER_SIZE_RX_DEF;\r\ntable = &state->table[EFX_FILTER_TABLE_TX_MAC];\r\ntable->id = EFX_FILTER_TABLE_TX_MAC;\r\ntable->offset = FR_CZ_TX_MAC_FILTER_TBL0;\r\ntable->size = FR_CZ_TX_MAC_FILTER_TBL0_ROWS;\r\ntable->step = FR_CZ_TX_MAC_FILTER_TBL0_STEP;\r\n}\r\nfor (table_id = 0; table_id < EFX_FILTER_TABLE_COUNT; table_id++) {\r\ntable = &state->table[table_id];\r\nif (table->size == 0)\r\ncontinue;\r\ntable->used_bitmap = kcalloc(BITS_TO_LONGS(table->size),\r\nsizeof(unsigned long),\r\nGFP_KERNEL);\r\nif (!table->used_bitmap)\r\ngoto fail;\r\ntable->spec = vzalloc(table->size * sizeof(*table->spec));\r\nif (!table->spec)\r\ngoto fail;\r\n}\r\nif (state->table[EFX_FILTER_TABLE_RX_DEF].size) {\r\nunsigned i;\r\nfor (i = 0; i < EFX_FILTER_SIZE_RX_DEF; i++)\r\nefx_filter_reset_rx_def(efx, i);\r\n}\r\nefx_filter_push_rx_config(efx);\r\nreturn 0;\r\nfail:\r\nefx_remove_filters(efx);\r\nreturn -ENOMEM;\r\n}\r\nvoid efx_remove_filters(struct efx_nic *efx)\r\n{\r\nstruct efx_filter_state *state = efx->filter_state;\r\nenum efx_filter_table_id table_id;\r\nfor (table_id = 0; table_id < EFX_FILTER_TABLE_COUNT; table_id++) {\r\nkfree(state->table[table_id].used_bitmap);\r\nvfree(state->table[table_id].spec);\r\n}\r\n#ifdef CONFIG_RFS_ACCEL\r\nkfree(state->rps_flow_id);\r\n#endif\r\nkfree(state);\r\n}\r\nint efx_filter_rfs(struct net_device *net_dev, const struct sk_buff *skb,\r\nu16 rxq_index, u32 flow_id)\r\n{\r\nstruct efx_nic *efx = netdev_priv(net_dev);\r\nstruct efx_channel *channel;\r\nstruct efx_filter_state *state = efx->filter_state;\r\nstruct efx_filter_spec spec;\r\nconst struct iphdr *ip;\r\nconst __be16 *ports;\r\nint nhoff;\r\nint rc;\r\nnhoff = skb_network_offset(skb);\r\nif (skb->protocol != htons(ETH_P_IP))\r\nreturn -EPROTONOSUPPORT;\r\nEFX_BUG_ON_PARANOID(skb_headlen(skb) < nhoff + sizeof(*ip));\r\nip = (const struct iphdr *)(skb->data + nhoff);\r\nif (ip_is_fragment(ip))\r\nreturn -EPROTONOSUPPORT;\r\nEFX_BUG_ON_PARANOID(skb_headlen(skb) < nhoff + 4 * ip->ihl + 4);\r\nports = (const __be16 *)(skb->data + nhoff + 4 * ip->ihl);\r\nefx_filter_init_rx(&spec, EFX_FILTER_PRI_HINT, 0, rxq_index);\r\nrc = efx_filter_set_ipv4_full(&spec, ip->protocol,\r\nip->daddr, ports[1], ip->saddr, ports[0]);\r\nif (rc)\r\nreturn rc;\r\nrc = efx_filter_insert_filter(efx, &spec, true);\r\nif (rc < 0)\r\nreturn rc;\r\nstate->rps_flow_id[rc] = flow_id;\r\nchannel = efx_get_channel(efx, skb_get_rx_queue(skb));\r\n++channel->rfs_filters_added;\r\nnetif_info(efx, rx_status, efx->net_dev,\r\n"steering %s %pI4:%u:%pI4:%u to queue %u [flow %u filter %d]\n",\r\n(ip->protocol == IPPROTO_TCP) ? "TCP" : "UDP",\r\n&ip->saddr, ntohs(ports[0]), &ip->daddr, ntohs(ports[1]),\r\nrxq_index, flow_id, rc);\r\nreturn rc;\r\n}\r\nbool __efx_filter_rfs_expire(struct efx_nic *efx, unsigned quota)\r\n{\r\nstruct efx_filter_state *state = efx->filter_state;\r\nstruct efx_filter_table *table = &state->table[EFX_FILTER_TABLE_RX_IP];\r\nunsigned mask = table->size - 1;\r\nunsigned index;\r\nunsigned stop;\r\nif (!spin_trylock_bh(&state->lock))\r\nreturn false;\r\nindex = state->rps_expire_index;\r\nstop = (index + quota) & mask;\r\nwhile (index != stop) {\r\nif (test_bit(index, table->used_bitmap) &&\r\ntable->spec[index].priority == EFX_FILTER_PRI_HINT &&\r\nrps_may_expire_flow(efx->net_dev,\r\ntable->spec[index].dmaq_id,\r\nstate->rps_flow_id[index], index)) {\r\nnetif_info(efx, rx_status, efx->net_dev,\r\n"expiring filter %d [flow %u]\n",\r\nindex, state->rps_flow_id[index]);\r\nefx_filter_table_clear_entry(efx, table, index);\r\n}\r\nindex = (index + 1) & mask;\r\n}\r\nstate->rps_expire_index = stop;\r\nif (table->used == 0)\r\nefx_filter_table_reset_search_depth(table);\r\nspin_unlock_bh(&state->lock);\r\nreturn true;\r\n}
