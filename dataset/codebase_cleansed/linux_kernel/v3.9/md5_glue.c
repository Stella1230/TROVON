static int md5_sparc64_init(struct shash_desc *desc)\r\n{\r\nstruct md5_state *mctx = shash_desc_ctx(desc);\r\nmctx->hash[0] = cpu_to_le32(0x67452301);\r\nmctx->hash[1] = cpu_to_le32(0xefcdab89);\r\nmctx->hash[2] = cpu_to_le32(0x98badcfe);\r\nmctx->hash[3] = cpu_to_le32(0x10325476);\r\nmctx->byte_count = 0;\r\nreturn 0;\r\n}\r\nstatic void __md5_sparc64_update(struct md5_state *sctx, const u8 *data,\r\nunsigned int len, unsigned int partial)\r\n{\r\nunsigned int done = 0;\r\nsctx->byte_count += len;\r\nif (partial) {\r\ndone = MD5_HMAC_BLOCK_SIZE - partial;\r\nmemcpy((u8 *)sctx->block + partial, data, done);\r\nmd5_sparc64_transform(sctx->hash, (u8 *)sctx->block, 1);\r\n}\r\nif (len - done >= MD5_HMAC_BLOCK_SIZE) {\r\nconst unsigned int rounds = (len - done) / MD5_HMAC_BLOCK_SIZE;\r\nmd5_sparc64_transform(sctx->hash, data + done, rounds);\r\ndone += rounds * MD5_HMAC_BLOCK_SIZE;\r\n}\r\nmemcpy(sctx->block, data + done, len - done);\r\n}\r\nstatic int md5_sparc64_update(struct shash_desc *desc, const u8 *data,\r\nunsigned int len)\r\n{\r\nstruct md5_state *sctx = shash_desc_ctx(desc);\r\nunsigned int partial = sctx->byte_count % MD5_HMAC_BLOCK_SIZE;\r\nif (partial + len < MD5_HMAC_BLOCK_SIZE) {\r\nsctx->byte_count += len;\r\nmemcpy((u8 *)sctx->block + partial, data, len);\r\n} else\r\n__md5_sparc64_update(sctx, data, len, partial);\r\nreturn 0;\r\n}\r\nstatic int md5_sparc64_final(struct shash_desc *desc, u8 *out)\r\n{\r\nstruct md5_state *sctx = shash_desc_ctx(desc);\r\nunsigned int i, index, padlen;\r\nu32 *dst = (u32 *)out;\r\n__le64 bits;\r\nstatic const u8 padding[MD5_HMAC_BLOCK_SIZE] = { 0x80, };\r\nbits = cpu_to_le64(sctx->byte_count << 3);\r\nindex = sctx->byte_count % MD5_HMAC_BLOCK_SIZE;\r\npadlen = (index < 56) ? (56 - index) : ((MD5_HMAC_BLOCK_SIZE+56) - index);\r\nif (padlen <= 56) {\r\nsctx->byte_count += padlen;\r\nmemcpy((u8 *)sctx->block + index, padding, padlen);\r\n} else {\r\n__md5_sparc64_update(sctx, padding, padlen, index);\r\n}\r\n__md5_sparc64_update(sctx, (const u8 *)&bits, sizeof(bits), 56);\r\nfor (i = 0; i < MD5_HASH_WORDS; i++)\r\ndst[i] = sctx->hash[i];\r\nmemset(sctx, 0, sizeof(*sctx));\r\nreturn 0;\r\n}\r\nstatic int md5_sparc64_export(struct shash_desc *desc, void *out)\r\n{\r\nstruct md5_state *sctx = shash_desc_ctx(desc);\r\nmemcpy(out, sctx, sizeof(*sctx));\r\nreturn 0;\r\n}\r\nstatic int md5_sparc64_import(struct shash_desc *desc, const void *in)\r\n{\r\nstruct md5_state *sctx = shash_desc_ctx(desc);\r\nmemcpy(sctx, in, sizeof(*sctx));\r\nreturn 0;\r\n}\r\nstatic bool __init sparc64_has_md5_opcode(void)\r\n{\r\nunsigned long cfr;\r\nif (!(sparc64_elf_hwcap & HWCAP_SPARC_CRYPTO))\r\nreturn false;\r\n__asm__ __volatile__("rd %%asr26, %0" : "=r" (cfr));\r\nif (!(cfr & CFR_MD5))\r\nreturn false;\r\nreturn true;\r\n}\r\nstatic int __init md5_sparc64_mod_init(void)\r\n{\r\nif (sparc64_has_md5_opcode()) {\r\npr_info("Using sparc64 md5 opcode optimized MD5 implementation\n");\r\nreturn crypto_register_shash(&alg);\r\n}\r\npr_info("sparc64 md5 opcode not available.\n");\r\nreturn -ENODEV;\r\n}\r\nstatic void __exit md5_sparc64_mod_fini(void)\r\n{\r\ncrypto_unregister_shash(&alg);\r\n}
