static void tmio_write_pm(struct platform_device *dev)\r\n{\r\nstruct usb_hcd *hcd = platform_get_drvdata(dev);\r\nstruct tmio_hcd *tmio = hcd_to_tmio(hcd);\r\nu16 pm;\r\nunsigned long flags;\r\nspin_lock_irqsave(&tmio->lock, flags);\r\npm = CCR_PM_GKEN | CCR_PM_CKRNEN |\r\nCCR_PM_PMEE | CCR_PM_PMES;\r\ntmio_iowrite16(pm, tmio->ccr + CCR_PM);\r\nspin_unlock_irqrestore(&tmio->lock, flags);\r\n}\r\nstatic void tmio_stop_hc(struct platform_device *dev)\r\n{\r\nstruct usb_hcd *hcd = platform_get_drvdata(dev);\r\nstruct ohci_hcd *ohci = hcd_to_ohci(hcd);\r\nstruct tmio_hcd *tmio = hcd_to_tmio(hcd);\r\nu16 pm;\r\npm = CCR_PM_GKEN | CCR_PM_CKRNEN;\r\nswitch (ohci->num_ports) {\r\ndefault:\r\ndev_err(&dev->dev, "Unsupported amount of ports: %d\n", ohci->num_ports);\r\ncase 3:\r\npm |= CCR_PM_USBPW3;\r\ncase 2:\r\npm |= CCR_PM_USBPW2;\r\ncase 1:\r\npm |= CCR_PM_USBPW1;\r\n}\r\ntmio_iowrite8(0, tmio->ccr + CCR_INTC);\r\ntmio_iowrite8(0, tmio->ccr + CCR_ILME);\r\ntmio_iowrite16(0, tmio->ccr + CCR_BASE);\r\ntmio_iowrite16(0, tmio->ccr + CCR_BASE + 2);\r\ntmio_iowrite16(pm, tmio->ccr + CCR_PM);\r\n}\r\nstatic void tmio_start_hc(struct platform_device *dev)\r\n{\r\nstruct usb_hcd *hcd = platform_get_drvdata(dev);\r\nstruct tmio_hcd *tmio = hcd_to_tmio(hcd);\r\nunsigned long base = hcd->rsrc_start;\r\ntmio_write_pm(dev);\r\ntmio_iowrite16(base, tmio->ccr + CCR_BASE);\r\ntmio_iowrite16(base >> 16, tmio->ccr + CCR_BASE + 2);\r\ntmio_iowrite8(1, tmio->ccr + CCR_ILME);\r\ntmio_iowrite8(2, tmio->ccr + CCR_INTC);\r\ndev_info(&dev->dev, "revision %d @ 0x%08llx, irq %d\n",\r\ntmio_ioread8(tmio->ccr + CCR_REVID),\r\n(u64) hcd->rsrc_start, hcd->irq);\r\n}\r\nstatic int ohci_tmio_start(struct usb_hcd *hcd)\r\n{\r\nstruct ohci_hcd *ohci = hcd_to_ohci(hcd);\r\nint ret;\r\nif ((ret = ohci_init(ohci)) < 0)\r\nreturn ret;\r\nif ((ret = ohci_run(ohci)) < 0) {\r\ndev_err(hcd->self.controller, "can't start %s\n",\r\nhcd->self.bus_name);\r\nohci_stop(hcd);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ohci_hcd_tmio_drv_probe(struct platform_device *dev)\r\n{\r\nconst struct mfd_cell *cell = mfd_get_cell(dev);\r\nstruct resource *regs = platform_get_resource(dev, IORESOURCE_MEM, 0);\r\nstruct resource *config = platform_get_resource(dev, IORESOURCE_MEM, 1);\r\nstruct resource *sram = platform_get_resource(dev, IORESOURCE_MEM, 2);\r\nint irq = platform_get_irq(dev, 0);\r\nstruct tmio_hcd *tmio;\r\nstruct ohci_hcd *ohci;\r\nstruct usb_hcd *hcd;\r\nint ret;\r\nif (usb_disabled())\r\nreturn -ENODEV;\r\nif (!cell)\r\nreturn -EINVAL;\r\nhcd = usb_create_hcd(&ohci_tmio_hc_driver, &dev->dev, dev_name(&dev->dev));\r\nif (!hcd) {\r\nret = -ENOMEM;\r\ngoto err_usb_create_hcd;\r\n}\r\nhcd->rsrc_start = regs->start;\r\nhcd->rsrc_len = resource_size(regs);\r\ntmio = hcd_to_tmio(hcd);\r\nspin_lock_init(&tmio->lock);\r\ntmio->ccr = ioremap(config->start, resource_size(config));\r\nif (!tmio->ccr) {\r\nret = -ENOMEM;\r\ngoto err_ioremap_ccr;\r\n}\r\nhcd->regs = ioremap(hcd->rsrc_start, hcd->rsrc_len);\r\nif (!hcd->regs) {\r\nret = -ENOMEM;\r\ngoto err_ioremap_regs;\r\n}\r\nif (!dma_declare_coherent_memory(&dev->dev, sram->start,\r\nsram->start,\r\nresource_size(sram),\r\nDMA_MEMORY_MAP | DMA_MEMORY_EXCLUSIVE)) {\r\nret = -EBUSY;\r\ngoto err_dma_declare;\r\n}\r\nif (cell->enable) {\r\nret = cell->enable(dev);\r\nif (ret)\r\ngoto err_enable;\r\n}\r\ntmio_start_hc(dev);\r\nohci = hcd_to_ohci(hcd);\r\nohci_hcd_init(ohci);\r\nret = usb_add_hcd(hcd, irq, 0);\r\nif (ret)\r\ngoto err_add_hcd;\r\nif (ret == 0)\r\nreturn ret;\r\nusb_remove_hcd(hcd);\r\nerr_add_hcd:\r\ntmio_stop_hc(dev);\r\nif (cell->disable)\r\ncell->disable(dev);\r\nerr_enable:\r\ndma_release_declared_memory(&dev->dev);\r\nerr_dma_declare:\r\niounmap(hcd->regs);\r\nerr_ioremap_regs:\r\niounmap(tmio->ccr);\r\nerr_ioremap_ccr:\r\nusb_put_hcd(hcd);\r\nerr_usb_create_hcd:\r\nreturn ret;\r\n}\r\nstatic int ohci_hcd_tmio_drv_remove(struct platform_device *dev)\r\n{\r\nstruct usb_hcd *hcd = platform_get_drvdata(dev);\r\nstruct tmio_hcd *tmio = hcd_to_tmio(hcd);\r\nconst struct mfd_cell *cell = mfd_get_cell(dev);\r\nusb_remove_hcd(hcd);\r\ntmio_stop_hc(dev);\r\nif (cell->disable)\r\ncell->disable(dev);\r\ndma_release_declared_memory(&dev->dev);\r\niounmap(hcd->regs);\r\niounmap(tmio->ccr);\r\nusb_put_hcd(hcd);\r\nplatform_set_drvdata(dev, NULL);\r\nreturn 0;\r\n}\r\nstatic int ohci_hcd_tmio_drv_suspend(struct platform_device *dev, pm_message_t state)\r\n{\r\nconst struct mfd_cell *cell = mfd_get_cell(dev);\r\nstruct usb_hcd *hcd = platform_get_drvdata(dev);\r\nstruct ohci_hcd *ohci = hcd_to_ohci(hcd);\r\nstruct tmio_hcd *tmio = hcd_to_tmio(hcd);\r\nunsigned long flags;\r\nu8 misc;\r\nint ret;\r\nif (time_before(jiffies, ohci->next_statechange))\r\nmsleep(5);\r\nohci->next_statechange = jiffies;\r\nspin_lock_irqsave(&tmio->lock, flags);\r\nmisc = tmio_ioread8(tmio->ccr + CCR_MISC);\r\nmisc |= 1 << 3;\r\ntmio_iowrite8(misc, tmio->ccr + CCR_MISC);\r\nspin_unlock_irqrestore(&tmio->lock, flags);\r\nif (cell->suspend) {\r\nret = cell->suspend(dev);\r\nif (ret)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ohci_hcd_tmio_drv_resume(struct platform_device *dev)\r\n{\r\nconst struct mfd_cell *cell = mfd_get_cell(dev);\r\nstruct usb_hcd *hcd = platform_get_drvdata(dev);\r\nstruct ohci_hcd *ohci = hcd_to_ohci(hcd);\r\nstruct tmio_hcd *tmio = hcd_to_tmio(hcd);\r\nunsigned long flags;\r\nu8 misc;\r\nint ret;\r\nif (time_before(jiffies, ohci->next_statechange))\r\nmsleep(5);\r\nohci->next_statechange = jiffies;\r\nif (cell->resume) {\r\nret = cell->resume(dev);\r\nif (ret)\r\nreturn ret;\r\n}\r\ntmio_start_hc(dev);\r\nspin_lock_irqsave(&tmio->lock, flags);\r\nmisc = tmio_ioread8(tmio->ccr + CCR_MISC);\r\nmisc &= ~(1 << 3);\r\ntmio_iowrite8(misc, tmio->ccr + CCR_MISC);\r\nspin_unlock_irqrestore(&tmio->lock, flags);\r\nohci_resume(hcd, false);\r\nreturn 0;\r\n}
