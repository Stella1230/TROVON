static s32 hmc5843_configure(struct i2c_client *client,\r\nu8 operating_mode)\r\n{\r\nreturn i2c_smbus_write_byte_data(client,\r\nHMC5843_MODE_REG,\r\noperating_mode & HMC5843_MODE_MASK);\r\n}\r\nstatic int hmc5843_read_measurement(struct iio_dev *indio_dev,\r\nint address,\r\nint *val)\r\n{\r\nstruct i2c_client *client = to_i2c_client(indio_dev->dev.parent);\r\nstruct hmc5843_data *data = iio_priv(indio_dev);\r\ns32 result;\r\nmutex_lock(&data->lock);\r\nresult = i2c_smbus_read_byte_data(client, HMC5843_STATUS_REG);\r\nwhile (!(result & HMC5843_DATA_READY))\r\nresult = i2c_smbus_read_byte_data(client, HMC5843_STATUS_REG);\r\nresult = i2c_smbus_read_word_data(client, address);\r\nmutex_unlock(&data->lock);\r\nif (result < 0)\r\nreturn -EINVAL;\r\n*val = (s16)swab16((u16)result);\r\nreturn IIO_VAL_INT;\r\n}\r\nstatic ssize_t hmc5843_show_operating_mode(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\r\nstruct hmc5843_data *data = iio_priv(indio_dev);\r\nreturn sprintf(buf, "%d\n", data->operating_mode);\r\n}\r\nstatic ssize_t hmc5843_set_operating_mode(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf,\r\nsize_t count)\r\n{\r\nstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\r\nstruct i2c_client *client = to_i2c_client(indio_dev->dev.parent);\r\nstruct hmc5843_data *data = iio_priv(indio_dev);\r\nstruct iio_dev_attr *this_attr = to_iio_dev_attr(attr);\r\nunsigned long operating_mode = 0;\r\ns32 status;\r\nint error;\r\nmutex_lock(&data->lock);\r\nerror = kstrtoul(buf, 10, &operating_mode);\r\nif (error) {\r\ncount = error;\r\ngoto exit;\r\n}\r\ndev_dbg(dev, "set conversion mode to %lu\n", operating_mode);\r\nif (operating_mode > HMC5843_MODE_SLEEP) {\r\ncount = -EINVAL;\r\ngoto exit;\r\n}\r\nstatus = i2c_smbus_write_byte_data(client, this_attr->address,\r\noperating_mode);\r\nif (status) {\r\ncount = -EINVAL;\r\ngoto exit;\r\n}\r\ndata->operating_mode = operating_mode;\r\nexit:\r\nmutex_unlock(&data->lock);\r\nreturn count;\r\n}\r\nstatic s32 hmc5843_set_meas_conf(struct i2c_client *client,\r\nu8 meas_conf)\r\n{\r\nstruct iio_dev *indio_dev = i2c_get_clientdata(client);\r\nstruct hmc5843_data *data = iio_priv(indio_dev);\r\nu8 reg_val;\r\nreg_val = (meas_conf & HMC5843_MEAS_CONF_MASK) |\r\n(data->rate << HMC5843_RATE_OFFSET);\r\nreturn i2c_smbus_write_byte_data(client, HMC5843_CONFIG_REG_A, reg_val);\r\n}\r\nstatic ssize_t hmc5843_show_measurement_configuration(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\r\nstruct hmc5843_data *data = iio_priv(indio_dev);\r\nreturn sprintf(buf, "%d\n", data->meas_conf);\r\n}\r\nstatic ssize_t hmc5843_set_measurement_configuration(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf,\r\nsize_t count)\r\n{\r\nstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\r\nstruct i2c_client *client = to_i2c_client(indio_dev->dev.parent);\r\nstruct hmc5843_data *data = iio_priv(indio_dev);\r\nunsigned long meas_conf = 0;\r\nint error;\r\nerror = kstrtoul(buf, 10, &meas_conf);\r\nif (error)\r\nreturn error;\r\nif (meas_conf >= HMC5843_MEAS_CONF_NOT_USED)\r\nreturn -EINVAL;\r\nmutex_lock(&data->lock);\r\ndev_dbg(dev, "set measurement configuration to %lu\n", meas_conf);\r\nif (hmc5843_set_meas_conf(client, meas_conf)) {\r\ncount = -EINVAL;\r\ngoto exit;\r\n}\r\ndata->meas_conf = meas_conf;\r\nexit:\r\nmutex_unlock(&data->lock);\r\nreturn count;\r\n}\r\nstatic ssize_t hmc5843_show_sampling_frequencies_available(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\r\nstruct hmc5843_data *data = iio_priv(indio_dev);\r\nssize_t total_n = 0;\r\nint i;\r\nfor (i = 0; i < HMC5843_RATE_NOT_USED; i++) {\r\nssize_t n = sprintf(buf, "%s ", data->variant->regval_to_sample_freq[i]);\r\nbuf += n;\r\ntotal_n += n;\r\n}\r\nbuf[-1] = '\n';\r\nreturn total_n;\r\n}\r\nstatic s32 hmc5843_set_rate(struct i2c_client *client,\r\nu8 rate)\r\n{\r\nstruct iio_dev *indio_dev = i2c_get_clientdata(client);\r\nstruct hmc5843_data *data = iio_priv(indio_dev);\r\nu8 reg_val;\r\nif (rate >= HMC5843_RATE_NOT_USED) {\r\ndev_err(&client->dev,\r\n"data output rate is not supported\n");\r\nreturn -EINVAL;\r\n}\r\nreg_val = data->meas_conf | (rate << HMC5843_RATE_OFFSET);\r\nreturn i2c_smbus_write_byte_data(client, HMC5843_CONFIG_REG_A, reg_val);\r\n}\r\nstatic int hmc5843_check_sampling_frequency(struct hmc5843_data *data,\r\nconst char *buf)\r\n{\r\nconst char * const *samp_freq = data->variant->regval_to_sample_freq;\r\nint i;\r\nfor (i = 0; i < HMC5843_RATE_NOT_USED; i++) {\r\nif (sysfs_streq(buf, samp_freq[i]))\r\nreturn i;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic ssize_t hmc5843_set_sampling_frequency(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\r\nstruct i2c_client *client = to_i2c_client(indio_dev->dev.parent);\r\nstruct hmc5843_data *data = iio_priv(indio_dev);\r\nint rate;\r\nrate = hmc5843_check_sampling_frequency(data, buf);\r\nif (rate < 0) {\r\ndev_err(&client->dev,\r\n"sampling frequency is not supported\n");\r\nreturn rate;\r\n}\r\nmutex_lock(&data->lock);\r\ndev_dbg(dev, "set rate to %d\n", rate);\r\nif (hmc5843_set_rate(client, rate)) {\r\ncount = -EINVAL;\r\ngoto exit;\r\n}\r\ndata->rate = rate;\r\nexit:\r\nmutex_unlock(&data->lock);\r\nreturn count;\r\n}\r\nstatic ssize_t hmc5843_show_sampling_frequency(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\r\nstruct i2c_client *client = to_i2c_client(indio_dev->dev.parent);\r\nstruct iio_dev_attr *this_attr = to_iio_dev_attr(attr);\r\nstruct hmc5843_data *data = iio_priv(indio_dev);\r\ns32 rate;\r\nrate = i2c_smbus_read_byte_data(client, this_attr->address);\r\nif (rate < 0)\r\nreturn rate;\r\nrate = (rate & HMC5843_RATE_BITMASK) >> HMC5843_RATE_OFFSET;\r\nreturn sprintf(buf, "%s\n", data->variant->regval_to_sample_freq[rate]);\r\n}\r\nstatic ssize_t hmc5843_show_range_gain(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nu8 range;\r\nstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\r\nstruct hmc5843_data *data = iio_priv(indio_dev);\r\nrange = data->range;\r\nreturn sprintf(buf, "%d\n", data->variant->regval_to_input_field_mga[range]);\r\n}\r\nstatic ssize_t hmc5843_set_range_gain(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf,\r\nsize_t count)\r\n{\r\nstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\r\nstruct i2c_client *client = to_i2c_client(indio_dev->dev.parent);\r\nstruct iio_dev_attr *this_attr = to_iio_dev_attr(attr);\r\nstruct hmc5843_data *data = iio_priv(indio_dev);\r\nunsigned long range = 0;\r\nint error;\r\nmutex_lock(&data->lock);\r\nerror = kstrtoul(buf, 10, &range);\r\nif (error) {\r\ncount = error;\r\ngoto exit;\r\n}\r\ndev_dbg(dev, "set range to %lu\n", range);\r\nif (range > HMC5843_RANGE_GAIN_MAX) {\r\ncount = -EINVAL;\r\ngoto exit;\r\n}\r\ndata->range = range;\r\nrange = range << HMC5843_RANGE_GAIN_OFFSET;\r\nif (i2c_smbus_write_byte_data(client, this_attr->address, range))\r\ncount = -EINVAL;\r\nexit:\r\nmutex_unlock(&data->lock);\r\nreturn count;\r\n}\r\nstatic int hmc5843_read_raw(struct iio_dev *indio_dev,\r\nstruct iio_chan_spec const *chan,\r\nint *val, int *val2,\r\nlong mask)\r\n{\r\nstruct hmc5843_data *data = iio_priv(indio_dev);\r\nswitch (mask) {\r\ncase IIO_CHAN_INFO_RAW:\r\nreturn hmc5843_read_measurement(indio_dev,\r\nchan->address,\r\nval);\r\ncase IIO_CHAN_INFO_SCALE:\r\n*val = 0;\r\n*val2 = data->variant->regval_to_nanoscale[data->range];\r\nreturn IIO_VAL_INT_PLUS_NANO;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int hmc5843_detect(struct i2c_client *client,\r\nstruct i2c_board_info *info)\r\n{\r\nunsigned char id_str[HMC5843_ID_REG_LENGTH];\r\nif (client->addr != HMC5843_I2C_ADDRESS)\r\nreturn -ENODEV;\r\nif (i2c_smbus_read_i2c_block_data(client, HMC5843_ID_REG_A,\r\nHMC5843_ID_REG_LENGTH, id_str)\r\n!= HMC5843_ID_REG_LENGTH)\r\nreturn -ENODEV;\r\nif (0 != strncmp(id_str, HMC5843_ID_STRING, HMC5843_ID_REG_LENGTH))\r\nreturn -ENODEV;\r\nreturn 0;\r\n}\r\nstatic void hmc5843_init_client(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct iio_dev *indio_dev = i2c_get_clientdata(client);\r\nstruct hmc5843_data *data = iio_priv(indio_dev);\r\ndata->variant = &hmc5843_chip_info_tbl[id->driver_data];\r\nindio_dev->channels = data->variant->channels;\r\nindio_dev->num_channels = data->variant->num_channels;\r\nhmc5843_set_meas_conf(client, data->meas_conf);\r\nhmc5843_set_rate(client, data->rate);\r\nhmc5843_configure(client, data->operating_mode);\r\ni2c_smbus_write_byte_data(client, HMC5843_CONFIG_REG_B, data->range);\r\nmutex_init(&data->lock);\r\npr_info("%s initialized\n", id->name);\r\n}\r\nstatic int hmc5843_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct hmc5843_data *data;\r\nstruct iio_dev *indio_dev;\r\nint err = 0;\r\nindio_dev = iio_device_alloc(sizeof(*data));\r\nif (indio_dev == NULL) {\r\nerr = -ENOMEM;\r\ngoto exit;\r\n}\r\ndata = iio_priv(indio_dev);\r\ndata->meas_conf = HMC5843_MEAS_CONF_NORMAL;\r\ndata->range = HMC5843_RANGE_GAIN_DEFAULT;\r\ndata->operating_mode = HMC5843_MODE_CONVERSION_CONTINUOUS;\r\ni2c_set_clientdata(client, indio_dev);\r\nhmc5843_init_client(client, id);\r\nindio_dev->info = &hmc5843_info;\r\nindio_dev->name = id->name;\r\nindio_dev->dev.parent = &client->dev;\r\nindio_dev->modes = INDIO_DIRECT_MODE;\r\nerr = iio_device_register(indio_dev);\r\nif (err)\r\ngoto exit_free2;\r\nreturn 0;\r\nexit_free2:\r\niio_device_free(indio_dev);\r\nexit:\r\nreturn err;\r\n}\r\nstatic int hmc5843_remove(struct i2c_client *client)\r\n{\r\nstruct iio_dev *indio_dev = i2c_get_clientdata(client);\r\niio_device_unregister(indio_dev);\r\nhmc5843_configure(client, HMC5843_MODE_SLEEP);\r\niio_device_free(indio_dev);\r\nreturn 0;\r\n}\r\nstatic int hmc5843_suspend(struct device *dev)\r\n{\r\nhmc5843_configure(to_i2c_client(dev), HMC5843_MODE_SLEEP);\r\nreturn 0;\r\n}\r\nstatic int hmc5843_resume(struct device *dev)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct iio_dev *indio_dev = i2c_get_clientdata(client);\r\nstruct hmc5843_data *data = iio_priv(indio_dev);\r\nhmc5843_configure(client, data->operating_mode);\r\nreturn 0;\r\n}
