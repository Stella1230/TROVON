static void send_to_client(unifi_priv_t *priv, ul_client_t *client,\r\nint receiver_id,\r\nunsigned char *sigdata, int siglen,\r\nconst bulk_data_param_t *bulkdata)\r\n{\r\nif (client && client->event_hook) {\r\nclient->event_hook(client, sigdata, siglen, bulkdata, UDI_TO_HOST);\r\n}\r\n}\r\nstatic void\r\nunifi_process_receive_event(void *ospriv,\r\nu8 *sigdata, u32 siglen,\r\nconst bulk_data_param_t *bulkdata)\r\n{\r\nunifi_priv_t *priv = (unifi_priv_t*)ospriv;\r\nint i, receiver_id;\r\nint client_id;\r\ns16 signal_id;\r\nu8 pktIndToSme = FALSE, freeBulkData = FALSE;\r\nunifi_trace(priv, UDBG5, "unifi_process_receive_event: "\r\n"%04x %04x %04x %04x %04x %04x %04x %04x (%d)\n",\r\nCSR_GET_UINT16_FROM_LITTLE_ENDIAN((sigdata) + sizeof(s16)*0) & 0xFFFF,\r\nCSR_GET_UINT16_FROM_LITTLE_ENDIAN((sigdata) + sizeof(s16)*1) & 0xFFFF,\r\nCSR_GET_UINT16_FROM_LITTLE_ENDIAN((sigdata) + sizeof(s16)*2) & 0xFFFF,\r\nCSR_GET_UINT16_FROM_LITTLE_ENDIAN((sigdata) + sizeof(s16)*3) & 0xFFFF,\r\nCSR_GET_UINT16_FROM_LITTLE_ENDIAN((sigdata) + sizeof(s16)*4) & 0xFFFF,\r\nCSR_GET_UINT16_FROM_LITTLE_ENDIAN((sigdata) + sizeof(s16)*5) & 0xFFFF,\r\nCSR_GET_UINT16_FROM_LITTLE_ENDIAN((sigdata) + sizeof(s16)*6) & 0xFFFF,\r\nCSR_GET_UINT16_FROM_LITTLE_ENDIAN((sigdata) + sizeof(s16)*7) & 0xFFFF,\r\nsiglen);\r\nreceiver_id = CSR_GET_UINT16_FROM_LITTLE_ENDIAN((sigdata) + sizeof(s16)) & 0xFF00;\r\nclient_id = (receiver_id & 0x0F00) >> UDI_SENDER_ID_SHIFT;\r\nsignal_id = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(sigdata);\r\nif (signal_id == CSR_MA_PACKET_INDICATION_ID)\r\n{\r\n#define CSR_MA_PACKET_INDICATION_INTERFACETAG_OFFSET 14\r\nu8 interfaceTag;\r\nnetInterface_priv_t *interfacePriv;\r\ninterfaceTag = (CSR_GET_UINT16_FROM_LITTLE_ENDIAN(sigdata + CSR_MA_PACKET_INDICATION_INTERFACETAG_OFFSET)) & 0xff;\r\ninterfacePriv = priv->interfacePriv[interfaceTag];\r\n#ifdef CSR_SUPPORT_SME\r\nif (interfacePriv->interfaceMode == CSR_WIFI_ROUTER_CTRL_MODE_IBSS)\r\n{\r\nu8 *saddr;\r\nsaddr = (u8 *) bulkdata->d[0].os_data_ptr + MAC_HEADER_ADDR2_OFFSET;\r\nunifi_trace(priv, UDBG5,\r\n"Updating sta activity in IBSS interfaceTag %x Src Addr %x:%x:%x:%x:%x:%x\n",\r\ninterfaceTag, saddr[0], saddr[1], saddr[2], saddr[3], saddr[4], saddr[5]);\r\nuf_update_sta_activity(priv, interfaceTag, saddr);\r\n}\r\n#endif\r\npktIndToSme = check_routing_pkt_data_ind(priv, sigdata, bulkdata, &freeBulkData, interfacePriv);\r\nunifi_trace(priv, UDBG6, "RX: packet entry point to driver from HIP,pkt to SME ?(%s) \n", (pktIndToSme)? "YES":"NO");\r\n}\r\nif (pktIndToSme)\r\n{\r\nif(sigdata != NULL && bulkdata != NULL){\r\nsend_to_client(priv, priv->sme_cli, receiver_id, sigdata, siglen, bulkdata);\r\n}\r\nelse{\r\nunifi_error(priv, "unifi_receive_event2: sigdata or Bulkdata is NULL \n");\r\n}\r\n#ifdef CSR_NATIVE_LINUX\r\nsend_to_client(priv, priv->wext_client,\r\nreceiver_id,\r\nsigdata, siglen, bulkdata);\r\n#endif\r\n}\r\nelse\r\n{\r\nif (!receiver_id) {\r\nif(signal_id == CSR_MA_VIF_AVAILABILITY_INDICATION_ID) {\r\nuf_process_ma_vif_availibility_ind(priv, sigdata, siglen);\r\n}\r\nelse if (signal_id != CSR_MA_PACKET_INDICATION_ID) {\r\nsend_to_client(priv, priv->sme_cli, receiver_id, sigdata, siglen, bulkdata);\r\n#ifdef CSR_NATIVE_LINUX\r\nsend_to_client(priv, priv->wext_client,\r\nreceiver_id,\r\nsigdata, siglen, bulkdata);\r\n#endif\r\n}\r\nelse\r\n{\r\n#if (defined(CSR_SUPPORT_SME) && defined(CSR_WIFI_SECURITY_WAPI_ENABLE))\r\n#define CSR_MA_PACKET_INDICATION_RECEPTION_STATUS_OFFSET sizeof(CSR_SIGNAL_PRIMITIVE_HEADER) + 22\r\nnetInterface_priv_t *interfacePriv;\r\nu8 interfaceTag;\r\nu16 receptionStatus = CSR_RX_SUCCESS;\r\ninterfaceTag = (CSR_GET_UINT16_FROM_LITTLE_ENDIAN(sigdata + CSR_MA_PACKET_INDICATION_INTERFACETAG_OFFSET)) & 0xff;\r\ninterfacePriv = priv->interfacePriv[interfaceTag];\r\nreceptionStatus = CSR_GET_UINT16_FROM_LITTLE_ENDIAN(sigdata + CSR_MA_PACKET_INDICATION_RECEPTION_STATUS_OFFSET);\r\nif ((!freeBulkData) &&\r\n(interfacePriv->interfaceMode == CSR_WIFI_ROUTER_CTRL_MODE_STA) &&\r\n(receptionStatus == CSR_MICHAEL_MIC_ERROR) &&\r\n((priv->wapi_multicast_filter == 1)\r\n#ifdef CSR_WIFI_SECURITY_WAPI_SW_ENCRYPTION\r\n|| (priv->wapi_unicast_filter == 1)\r\n#endif\r\n))\r\n{\r\nCSR_SIGNAL signal;\r\nu8 *destAddr;\r\nCsrResult res;\r\nu16 interfaceTag = 0;\r\nu8 isMcastPkt = TRUE;\r\nunifi_trace(priv, UDBG6, "Received a WAPI data packet when the Unicast/Multicast filter is set\n");\r\nres = read_unpack_signal(sigdata, &signal);\r\nif (res) {\r\nunifi_error(priv, "Received unknown or corrupted signal (0x%x).\n",\r\nCSR_GET_UINT16_FROM_LITTLE_ENDIAN(sigdata));\r\nreturn;\r\n}\r\ndestAddr = (u8 *) bulkdata->d[0].os_data_ptr + MAC_HEADER_ADDR1_OFFSET;\r\nisMcastPkt = (destAddr[0] & 0x01) ? TRUE : FALSE;\r\nunifi_trace(priv, UDBG6,\r\n"1.MPDU type: (%s), 2.Multicast filter: (%s), 3. Unicast filter: (%s)\n",\r\n((isMcastPkt) ? "Multiast":"Unicast"),\r\n((priv->wapi_multicast_filter) ? "Enabled":"Disabled"),\r\n((priv->wapi_unicast_filter) ? "Enabled":"Disabled"));\r\nif (((isMcastPkt) && (priv->wapi_multicast_filter == 1))\r\n#ifdef CSR_WIFI_SECURITY_WAPI_SW_ENCRYPTION\r\n|| ((!isMcastPkt) && (priv->wapi_unicast_filter == 1))\r\n#endif\r\n)\r\n{\r\nunifi_trace(priv, UDBG4, "Sending the WAPI MPDU for MIC check\n");\r\nCsrWifiRouterCtrlWapiRxMicCheckIndSend(priv->CSR_WIFI_SME_IFACEQUEUE, 0, interfaceTag, siglen, sigdata, bulkdata->d[0].data_length, (u8*)bulkdata->d[0].os_data_ptr);\r\nfor (i = 0; i < UNIFI_MAX_DATA_REFERENCES; i++) {\r\nif (bulkdata->d[i].data_length != 0) {\r\nunifi_net_data_free(priv, (void *)&bulkdata->d[i]);\r\n}\r\n}\r\nreturn;\r\n}\r\n}\r\n#endif\r\n}\r\n}\r\nif(!freeBulkData){\r\nif ((client_id < MAX_UDI_CLIENTS) &&\r\n(&priv->ul_clients[client_id] != priv->logging_client)) {\r\nunifi_trace(priv, UDBG6, "Call the registered clients handler callback func\n");\r\nsend_to_client(priv, &priv->ul_clients[client_id],\r\nreceiver_id,\r\nsigdata, siglen, bulkdata);\r\n}\r\n}\r\n}\r\nswitch (signal_id)\r\n{\r\n#ifdef UNIFI_SNIFF_ARPHRD\r\ncase CSR_MA_SNIFFDATA_INDICATION_ID:\r\n#endif\r\nbreak;\r\ncase CSR_MA_PACKET_INDICATION_ID:\r\nif (!freeBulkData)\r\n{\r\nbreak;\r\n}\r\ndefault:\r\nfor (i = 0; i < UNIFI_MAX_DATA_REFERENCES; i++) {\r\nif (bulkdata->d[i].data_length != 0) {\r\nunifi_net_data_free(priv, (void *)&bulkdata->d[i]);\r\n}\r\n}\r\n}\r\n}\r\nstatic u8 signal_buffer_is_full(unifi_priv_t* priv)\r\n{\r\nreturn (((priv->rxSignalBuffer.writePointer + 1)% priv->rxSignalBuffer.size) == (priv->rxSignalBuffer.readPointer));\r\n}\r\nvoid unifi_rx_queue_flush(void *ospriv)\r\n{\r\nunifi_priv_t *priv = (unifi_priv_t*)ospriv;\r\nunifi_trace(priv, UDBG4, "rx_wq_handler: RdPtr = %d WritePtr = %d\n",\r\npriv->rxSignalBuffer.readPointer,priv->rxSignalBuffer.writePointer);\r\nif(priv != NULL) {\r\nu8 readPointer = priv->rxSignalBuffer.readPointer;\r\nwhile (readPointer != priv->rxSignalBuffer.writePointer)\r\n{\r\nrx_buff_struct_t *buf = &priv->rxSignalBuffer.rx_buff[readPointer];\r\nunifi_trace(priv, UDBG6, "rx_wq_handler: RdPtr = %d WritePtr = %d\n",\r\nreadPointer,priv->rxSignalBuffer.writePointer);\r\nunifi_process_receive_event(priv, buf->bufptr, buf->sig_len, &buf->data_ptrs);\r\nreadPointer ++;\r\nif(readPointer >= priv->rxSignalBuffer.size) {\r\nreadPointer = 0;\r\n}\r\n}\r\npriv->rxSignalBuffer.readPointer = readPointer;\r\n}\r\n}\r\nvoid rx_wq_handler(struct work_struct *work)\r\n{\r\nunifi_priv_t *priv = container_of(work, unifi_priv_t, rx_work_struct);\r\nunifi_rx_queue_flush(priv);\r\n}\r\nvoid\r\nunifi_receive_event(void *ospriv,\r\nu8 *sigdata, u32 siglen,\r\nconst bulk_data_param_t *bulkdata)\r\n{\r\n#ifdef CSR_WIFI_RX_PATH_SPLIT\r\nunifi_priv_t *priv = (unifi_priv_t*)ospriv;\r\nu8 writePointer;\r\nint i;\r\nrx_buff_struct_t * rx_buff;\r\nunifi_trace(priv, UDBG5, "unifi_receive_event: "\r\n"%04x %04x %04x %04x %04x %04x %04x %04x (%d)\n",\r\nCSR_GET_UINT16_FROM_LITTLE_ENDIAN((sigdata) + sizeof(s16)*0) & 0xFFFF,\r\nCSR_GET_UINT16_FROM_LITTLE_ENDIAN((sigdata) + sizeof(s16)*1) & 0xFFFF,\r\nCSR_GET_UINT16_FROM_LITTLE_ENDIAN((sigdata) + sizeof(s16)*2) & 0xFFFF,\r\nCSR_GET_UINT16_FROM_LITTLE_ENDIAN((sigdata) + sizeof(s16)*3) & 0xFFFF,\r\nCSR_GET_UINT16_FROM_LITTLE_ENDIAN((sigdata) + sizeof(s16)*4) & 0xFFFF,\r\nCSR_GET_UINT16_FROM_LITTLE_ENDIAN((sigdata) + sizeof(s16)*5) & 0xFFFF,\r\nCSR_GET_UINT16_FROM_LITTLE_ENDIAN((sigdata) + sizeof(s16)*6) & 0xFFFF,\r\nCSR_GET_UINT16_FROM_LITTLE_ENDIAN((sigdata) + sizeof(s16)*7) & 0xFFFF, siglen);\r\nif(signal_buffer_is_full(priv)) {\r\nunifi_error(priv,"TO HOST signal queue FULL dropping the PDU\n");\r\nfor (i = 0; i < UNIFI_MAX_DATA_REFERENCES; i++) {\r\nif (bulkdata->d[i].data_length != 0) {\r\nunifi_net_data_free(priv, (void *)&bulkdata->d[i]);\r\n}\r\n}\r\nreturn;\r\n}\r\nwritePointer = priv->rxSignalBuffer.writePointer;\r\nrx_buff = &priv->rxSignalBuffer.rx_buff[writePointer];\r\nmemcpy(rx_buff->bufptr,sigdata,siglen);\r\nrx_buff->sig_len = siglen;\r\nrx_buff->data_ptrs = *bulkdata;\r\nwritePointer++;\r\nif(writePointer >= priv->rxSignalBuffer.size) {\r\nwritePointer =0;\r\n}\r\nunifi_trace(priv, UDBG4, "unifi_receive_event:writePtr = %d\n",priv->rxSignalBuffer.writePointer);\r\npriv->rxSignalBuffer.writePointer = writePointer;\r\n#ifndef CSR_WIFI_RX_PATH_SPLIT_DONT_USE_WQ\r\nqueue_work(priv->rx_workqueue, &priv->rx_work_struct);\r\n#endif\r\n#else\r\nunifi_process_receive_event(ospriv, sigdata, siglen, bulkdata);\r\n#endif\r\n}
