static irqreturn_t mfld_pb_isr(int irq, void *dev_id)\r\n{\r\nstruct input_dev *input = dev_id;\r\nint ret;\r\nu8 pbstat;\r\nret = intel_msic_reg_read(INTEL_MSIC_PBSTATUS, &pbstat);\r\ndev_dbg(input->dev.parent, "PB_INT status= %d\n", pbstat);\r\nif (ret < 0) {\r\ndev_err(input->dev.parent, "Read error %d while reading"\r\n" MSIC_PB_STATUS\n", ret);\r\n} else {\r\ninput_event(input, EV_KEY, KEY_POWER,\r\n!(pbstat & MSIC_PB_LEVEL));\r\ninput_sync(input);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int mfld_pb_probe(struct platform_device *pdev)\r\n{\r\nstruct input_dev *input;\r\nint irq = platform_get_irq(pdev, 0);\r\nint error;\r\nif (irq < 0)\r\nreturn -EINVAL;\r\ninput = input_allocate_device();\r\nif (!input) {\r\ndev_err(&pdev->dev, "Input device allocation error\n");\r\nreturn -ENOMEM;\r\n}\r\ninput->name = pdev->name;\r\ninput->phys = "power-button/input0";\r\ninput->id.bustype = BUS_HOST;\r\ninput->dev.parent = &pdev->dev;\r\ninput_set_capability(input, EV_KEY, KEY_POWER);\r\nerror = request_threaded_irq(irq, NULL, mfld_pb_isr, IRQF_NO_SUSPEND,\r\nDRIVER_NAME, input);\r\nif (error) {\r\ndev_err(&pdev->dev, "Unable to request irq %d for mfld power"\r\n"button\n", irq);\r\ngoto err_free_input;\r\n}\r\nerror = input_register_device(input);\r\nif (error) {\r\ndev_err(&pdev->dev, "Unable to register input dev, error "\r\n"%d\n", error);\r\ngoto err_free_irq;\r\n}\r\nplatform_set_drvdata(pdev, input);\r\nerror = intel_msic_reg_update(INTEL_MSIC_IRQLVL1MSK, 0, MSIC_PWRBTNM);\r\nif (error) {\r\ndev_err(&pdev->dev, "Unable to clear power button interrupt, "\r\n"error: %d\n", error);\r\ngoto err_free_irq;\r\n}\r\nreturn 0;\r\nerr_free_irq:\r\nfree_irq(irq, input);\r\nerr_free_input:\r\ninput_free_device(input);\r\nreturn error;\r\n}\r\nstatic int mfld_pb_remove(struct platform_device *pdev)\r\n{\r\nstruct input_dev *input = platform_get_drvdata(pdev);\r\nint irq = platform_get_irq(pdev, 0);\r\nfree_irq(irq, input);\r\ninput_unregister_device(input);\r\nplatform_set_drvdata(pdev, NULL);\r\nreturn 0;\r\n}
