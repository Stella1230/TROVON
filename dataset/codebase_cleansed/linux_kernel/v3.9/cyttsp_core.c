static int ttsp_read_block_data(struct cyttsp *ts, u8 command,\r\nu8 length, void *buf)\r\n{\r\nint error;\r\nint tries;\r\nfor (tries = 0; tries < CY_NUM_RETRY; tries++) {\r\nerror = ts->bus_ops->read(ts, command, length, buf);\r\nif (!error)\r\nreturn 0;\r\nmsleep(CY_DELAY_DFLT);\r\n}\r\nreturn -EIO;\r\n}\r\nstatic int ttsp_write_block_data(struct cyttsp *ts, u8 command,\r\nu8 length, void *buf)\r\n{\r\nint error;\r\nint tries;\r\nfor (tries = 0; tries < CY_NUM_RETRY; tries++) {\r\nerror = ts->bus_ops->write(ts, command, length, buf);\r\nif (!error)\r\nreturn 0;\r\nmsleep(CY_DELAY_DFLT);\r\n}\r\nreturn -EIO;\r\n}\r\nstatic int ttsp_send_command(struct cyttsp *ts, u8 cmd)\r\n{\r\nreturn ttsp_write_block_data(ts, CY_REG_BASE, sizeof(cmd), &cmd);\r\n}\r\nstatic int cyttsp_load_bl_regs(struct cyttsp *ts)\r\n{\r\nmemset(&ts->bl_data, 0, sizeof(ts->bl_data));\r\nts->bl_data.bl_status = 0x10;\r\nreturn ttsp_read_block_data(ts, CY_REG_BASE,\r\nsizeof(ts->bl_data), &ts->bl_data);\r\n}\r\nstatic int cyttsp_exit_bl_mode(struct cyttsp *ts)\r\n{\r\nint error;\r\nu8 bl_cmd[sizeof(bl_command)];\r\nmemcpy(bl_cmd, bl_command, sizeof(bl_command));\r\nif (ts->pdata->bl_keys)\r\nmemcpy(&bl_cmd[sizeof(bl_command) - CY_NUM_BL_KEYS],\r\nts->pdata->bl_keys, sizeof(bl_command));\r\nerror = ttsp_write_block_data(ts, CY_REG_BASE,\r\nsizeof(bl_cmd), bl_cmd);\r\nif (error)\r\nreturn error;\r\nmsleep(CY_DELAY_DFLT);\r\nerror = cyttsp_load_bl_regs(ts);\r\nif (error)\r\nreturn error;\r\nif (GET_BOOTLOADERMODE(ts->bl_data.bl_status))\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nstatic int cyttsp_set_operational_mode(struct cyttsp *ts)\r\n{\r\nint error;\r\nerror = ttsp_send_command(ts, CY_OPERATE_MODE);\r\nif (error)\r\nreturn error;\r\nerror = ttsp_read_block_data(ts, CY_REG_BASE,\r\nsizeof(ts->xy_data), &ts->xy_data);\r\nif (error)\r\nreturn error;\r\nreturn ts->xy_data.act_dist == CY_ACT_DIST_DFLT ? -EIO : 0;\r\n}\r\nstatic int cyttsp_set_sysinfo_mode(struct cyttsp *ts)\r\n{\r\nint error;\r\nmemset(&ts->sysinfo_data, 0, sizeof(ts->sysinfo_data));\r\nerror = ttsp_send_command(ts, CY_SYSINFO_MODE);\r\nif (error)\r\nreturn error;\r\nmsleep(CY_DELAY_DFLT);\r\nerror = ttsp_read_block_data(ts, CY_REG_BASE, sizeof(ts->sysinfo_data),\r\n&ts->sysinfo_data);\r\nif (error)\r\nreturn error;\r\nif (!ts->sysinfo_data.tts_verh && !ts->sysinfo_data.tts_verl)\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nstatic int cyttsp_set_sysinfo_regs(struct cyttsp *ts)\r\n{\r\nint retval = 0;\r\nif (ts->pdata->act_intrvl != CY_ACT_INTRVL_DFLT ||\r\nts->pdata->tch_tmout != CY_TCH_TMOUT_DFLT ||\r\nts->pdata->lp_intrvl != CY_LP_INTRVL_DFLT) {\r\nu8 intrvl_ray[] = {\r\nts->pdata->act_intrvl,\r\nts->pdata->tch_tmout,\r\nts->pdata->lp_intrvl\r\n};\r\nretval = ttsp_write_block_data(ts, CY_REG_ACT_INTRVL,\r\nsizeof(intrvl_ray), intrvl_ray);\r\nmsleep(CY_DELAY_DFLT);\r\n}\r\nreturn retval;\r\n}\r\nstatic int cyttsp_soft_reset(struct cyttsp *ts)\r\n{\r\nunsigned long timeout;\r\nint retval;\r\nINIT_COMPLETION(ts->bl_ready);\r\nts->state = CY_BL_STATE;\r\nenable_irq(ts->irq);\r\nretval = ttsp_send_command(ts, CY_SOFT_RESET_MODE);\r\nif (retval)\r\ngoto out;\r\ntimeout = wait_for_completion_timeout(&ts->bl_ready,\r\nmsecs_to_jiffies(CY_DELAY_DFLT * CY_DELAY_MAX));\r\nretval = timeout ? 0 : -EIO;\r\nout:\r\nts->state = CY_IDLE_STATE;\r\ndisable_irq(ts->irq);\r\nreturn retval;\r\n}\r\nstatic int cyttsp_act_dist_setup(struct cyttsp *ts)\r\n{\r\nu8 act_dist_setup = ts->pdata->act_dist;\r\nreturn ttsp_write_block_data(ts, CY_REG_ACT_DIST,\r\nsizeof(act_dist_setup), &act_dist_setup);\r\n}\r\nstatic void cyttsp_extract_track_ids(struct cyttsp_xydata *xy_data, int *ids)\r\n{\r\nids[0] = xy_data->touch12_id >> 4;\r\nids[1] = xy_data->touch12_id & 0xF;\r\nids[2] = xy_data->touch34_id >> 4;\r\nids[3] = xy_data->touch34_id & 0xF;\r\n}\r\nstatic const struct cyttsp_tch *cyttsp_get_tch(struct cyttsp_xydata *xy_data,\r\nint idx)\r\n{\r\nswitch (idx) {\r\ncase 0:\r\nreturn &xy_data->tch1;\r\ncase 1:\r\nreturn &xy_data->tch2;\r\ncase 2:\r\nreturn &xy_data->tch3;\r\ncase 3:\r\nreturn &xy_data->tch4;\r\ndefault:\r\nreturn NULL;\r\n}\r\n}\r\nstatic void cyttsp_report_tchdata(struct cyttsp *ts)\r\n{\r\nstruct cyttsp_xydata *xy_data = &ts->xy_data;\r\nstruct input_dev *input = ts->input;\r\nint num_tch = GET_NUM_TOUCHES(xy_data->tt_stat);\r\nconst struct cyttsp_tch *tch;\r\nint ids[CY_MAX_ID];\r\nint i;\r\nDECLARE_BITMAP(used, CY_MAX_ID);\r\nif (IS_LARGE_AREA(xy_data->tt_stat) == 1) {\r\nnum_tch = 0;\r\ndev_dbg(ts->dev, "%s: Large area detected\n", __func__);\r\n} else if (num_tch > CY_MAX_FINGER) {\r\nnum_tch = 0;\r\ndev_dbg(ts->dev, "%s: Num touch error detected\n", __func__);\r\n} else if (IS_BAD_PKT(xy_data->tt_mode)) {\r\nnum_tch = 0;\r\ndev_dbg(ts->dev, "%s: Invalid buffer detected\n", __func__);\r\n}\r\ncyttsp_extract_track_ids(xy_data, ids);\r\nbitmap_zero(used, CY_MAX_ID);\r\nfor (i = 0; i < num_tch; i++) {\r\ntch = cyttsp_get_tch(xy_data, i);\r\ninput_mt_slot(input, ids[i]);\r\ninput_mt_report_slot_state(input, MT_TOOL_FINGER, true);\r\ninput_report_abs(input, ABS_MT_POSITION_X, be16_to_cpu(tch->x));\r\ninput_report_abs(input, ABS_MT_POSITION_Y, be16_to_cpu(tch->y));\r\ninput_report_abs(input, ABS_MT_TOUCH_MAJOR, tch->z);\r\n__set_bit(ids[i], used);\r\n}\r\nfor (i = 0; i < CY_MAX_ID; i++) {\r\nif (test_bit(i, used))\r\ncontinue;\r\ninput_mt_slot(input, i);\r\ninput_mt_report_slot_state(input, MT_TOOL_FINGER, false);\r\n}\r\ninput_sync(input);\r\n}\r\nstatic irqreturn_t cyttsp_irq(int irq, void *handle)\r\n{\r\nstruct cyttsp *ts = handle;\r\nint error;\r\nif (unlikely(ts->state == CY_BL_STATE)) {\r\ncomplete(&ts->bl_ready);\r\ngoto out;\r\n}\r\nerror = ttsp_read_block_data(ts, CY_REG_BASE,\r\nsizeof(struct cyttsp_xydata), &ts->xy_data);\r\nif (error)\r\ngoto out;\r\nif (ts->pdata->use_hndshk) {\r\nerror = ttsp_send_command(ts,\r\nts->xy_data.hst_mode ^ CY_HNDSHK_BIT);\r\nif (error)\r\ngoto out;\r\n}\r\nif (unlikely(ts->state == CY_IDLE_STATE))\r\ngoto out;\r\nif (GET_BOOTLOADERMODE(ts->xy_data.tt_mode)) {\r\nerror = cyttsp_exit_bl_mode(ts);\r\nif (error) {\r\ndev_err(ts->dev,\r\n"Could not return to operational mode, err: %d\n",\r\nerror);\r\nts->state = CY_IDLE_STATE;\r\n}\r\n} else {\r\ncyttsp_report_tchdata(ts);\r\n}\r\nout:\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int cyttsp_power_on(struct cyttsp *ts)\r\n{\r\nint error;\r\nerror = cyttsp_soft_reset(ts);\r\nif (error)\r\nreturn error;\r\nerror = cyttsp_load_bl_regs(ts);\r\nif (error)\r\nreturn error;\r\nif (GET_BOOTLOADERMODE(ts->bl_data.bl_status) &&\r\nIS_VALID_APP(ts->bl_data.bl_status)) {\r\nerror = cyttsp_exit_bl_mode(ts);\r\nif (error)\r\nreturn error;\r\n}\r\nif (GET_HSTMODE(ts->bl_data.bl_file) != CY_OPERATE_MODE ||\r\nIS_OPERATIONAL_ERR(ts->bl_data.bl_status)) {\r\nreturn -ENODEV;\r\n}\r\nerror = cyttsp_set_sysinfo_mode(ts);\r\nif (error)\r\nreturn error;\r\nerror = cyttsp_set_sysinfo_regs(ts);\r\nif (error)\r\nreturn error;\r\nerror = cyttsp_set_operational_mode(ts);\r\nif (error)\r\nreturn error;\r\nerror = cyttsp_act_dist_setup(ts);\r\nif (error)\r\nreturn error;\r\nts->state = CY_ACTIVE_STATE;\r\nreturn 0;\r\n}\r\nstatic int cyttsp_enable(struct cyttsp *ts)\r\n{\r\nint error;\r\nerror = ttsp_read_block_data(ts, CY_REG_BASE,\r\nsizeof(ts->xy_data), &ts->xy_data);\r\nif (error)\r\nreturn error;\r\nif (GET_HSTMODE(ts->xy_data.hst_mode))\r\nreturn -EIO;\r\nenable_irq(ts->irq);\r\nreturn 0;\r\n}\r\nstatic int cyttsp_disable(struct cyttsp *ts)\r\n{\r\nint error;\r\nerror = ttsp_send_command(ts, CY_LOW_POWER_MODE);\r\nif (error)\r\nreturn error;\r\ndisable_irq(ts->irq);\r\nreturn 0;\r\n}\r\nstatic int cyttsp_suspend(struct device *dev)\r\n{\r\nstruct cyttsp *ts = dev_get_drvdata(dev);\r\nint retval = 0;\r\nmutex_lock(&ts->input->mutex);\r\nif (ts->input->users) {\r\nretval = cyttsp_disable(ts);\r\nif (retval == 0)\r\nts->suspended = true;\r\n}\r\nmutex_unlock(&ts->input->mutex);\r\nreturn retval;\r\n}\r\nstatic int cyttsp_resume(struct device *dev)\r\n{\r\nstruct cyttsp *ts = dev_get_drvdata(dev);\r\nmutex_lock(&ts->input->mutex);\r\nif (ts->input->users)\r\ncyttsp_enable(ts);\r\nts->suspended = false;\r\nmutex_unlock(&ts->input->mutex);\r\nreturn 0;\r\n}\r\nstatic int cyttsp_open(struct input_dev *dev)\r\n{\r\nstruct cyttsp *ts = input_get_drvdata(dev);\r\nint retval = 0;\r\nif (!ts->suspended)\r\nretval = cyttsp_enable(ts);\r\nreturn retval;\r\n}\r\nstatic void cyttsp_close(struct input_dev *dev)\r\n{\r\nstruct cyttsp *ts = input_get_drvdata(dev);\r\nif (!ts->suspended)\r\ncyttsp_disable(ts);\r\n}\r\nstruct cyttsp *cyttsp_probe(const struct cyttsp_bus_ops *bus_ops,\r\nstruct device *dev, int irq, size_t xfer_buf_size)\r\n{\r\nconst struct cyttsp_platform_data *pdata = dev->platform_data;\r\nstruct cyttsp *ts;\r\nstruct input_dev *input_dev;\r\nint error;\r\nif (!pdata || !pdata->name || irq <= 0) {\r\nerror = -EINVAL;\r\ngoto err_out;\r\n}\r\nts = kzalloc(sizeof(*ts) + xfer_buf_size, GFP_KERNEL);\r\ninput_dev = input_allocate_device();\r\nif (!ts || !input_dev) {\r\nerror = -ENOMEM;\r\ngoto err_free_mem;\r\n}\r\nts->dev = dev;\r\nts->input = input_dev;\r\nts->pdata = dev->platform_data;\r\nts->bus_ops = bus_ops;\r\nts->irq = irq;\r\ninit_completion(&ts->bl_ready);\r\nsnprintf(ts->phys, sizeof(ts->phys), "%s/input0", dev_name(dev));\r\nif (pdata->init) {\r\nerror = pdata->init();\r\nif (error) {\r\ndev_err(ts->dev, "platform init failed, err: %d\n",\r\nerror);\r\ngoto err_free_mem;\r\n}\r\n}\r\ninput_dev->name = pdata->name;\r\ninput_dev->phys = ts->phys;\r\ninput_dev->id.bustype = bus_ops->bustype;\r\ninput_dev->dev.parent = ts->dev;\r\ninput_dev->open = cyttsp_open;\r\ninput_dev->close = cyttsp_close;\r\ninput_set_drvdata(input_dev, ts);\r\n__set_bit(EV_ABS, input_dev->evbit);\r\ninput_set_abs_params(input_dev, ABS_MT_POSITION_X,\r\n0, pdata->maxx, 0, 0);\r\ninput_set_abs_params(input_dev, ABS_MT_POSITION_Y,\r\n0, pdata->maxy, 0, 0);\r\ninput_set_abs_params(input_dev, ABS_MT_TOUCH_MAJOR,\r\n0, CY_MAXZ, 0, 0);\r\ninput_mt_init_slots(input_dev, CY_MAX_ID, 0);\r\nerror = request_threaded_irq(ts->irq, NULL, cyttsp_irq,\r\nIRQF_TRIGGER_FALLING | IRQF_ONESHOT,\r\npdata->name, ts);\r\nif (error) {\r\ndev_err(ts->dev, "failed to request IRQ %d, err: %d\n",\r\nts->irq, error);\r\ngoto err_platform_exit;\r\n}\r\ndisable_irq(ts->irq);\r\nerror = cyttsp_power_on(ts);\r\nif (error)\r\ngoto err_free_irq;\r\nerror = input_register_device(input_dev);\r\nif (error) {\r\ndev_err(ts->dev, "failed to register input device: %d\n",\r\nerror);\r\ngoto err_free_irq;\r\n}\r\nreturn ts;\r\nerr_free_irq:\r\nfree_irq(ts->irq, ts);\r\nerr_platform_exit:\r\nif (pdata->exit)\r\npdata->exit();\r\nerr_free_mem:\r\ninput_free_device(input_dev);\r\nkfree(ts);\r\nerr_out:\r\nreturn ERR_PTR(error);\r\n}\r\nvoid cyttsp_remove(struct cyttsp *ts)\r\n{\r\nfree_irq(ts->irq, ts);\r\ninput_unregister_device(ts->input);\r\nif (ts->pdata->exit)\r\nts->pdata->exit();\r\nkfree(ts);\r\n}
