static int pseries_eeh_init(void)\r\n{\r\nibm_set_eeh_option = rtas_token("ibm,set-eeh-option");\r\nibm_set_slot_reset = rtas_token("ibm,set-slot-reset");\r\nibm_read_slot_reset_state2 = rtas_token("ibm,read-slot-reset-state2");\r\nibm_read_slot_reset_state = rtas_token("ibm,read-slot-reset-state");\r\nibm_slot_error_detail = rtas_token("ibm,slot-error-detail");\r\nibm_get_config_addr_info2 = rtas_token("ibm,get-config-addr-info2");\r\nibm_get_config_addr_info = rtas_token("ibm,get-config-addr-info");\r\nibm_configure_pe = rtas_token("ibm,configure-pe");\r\nibm_configure_bridge = rtas_token("ibm,configure-bridge");\r\nif (ibm_set_eeh_option == RTAS_UNKNOWN_SERVICE) {\r\npr_warning("%s: RTAS service <ibm,set-eeh-option> invalid\n",\r\n__func__);\r\nreturn -EINVAL;\r\n} else if (ibm_set_slot_reset == RTAS_UNKNOWN_SERVICE) {\r\npr_warning("%s: RTAS service <ibm,set-slot-reset> invalid\n",\r\n__func__);\r\nreturn -EINVAL;\r\n} else if (ibm_read_slot_reset_state2 == RTAS_UNKNOWN_SERVICE &&\r\nibm_read_slot_reset_state == RTAS_UNKNOWN_SERVICE) {\r\npr_warning("%s: RTAS service <ibm,read-slot-reset-state2> and "\r\n"<ibm,read-slot-reset-state> invalid\n",\r\n__func__);\r\nreturn -EINVAL;\r\n} else if (ibm_slot_error_detail == RTAS_UNKNOWN_SERVICE) {\r\npr_warning("%s: RTAS service <ibm,slot-error-detail> invalid\n",\r\n__func__);\r\nreturn -EINVAL;\r\n} else if (ibm_get_config_addr_info2 == RTAS_UNKNOWN_SERVICE &&\r\nibm_get_config_addr_info == RTAS_UNKNOWN_SERVICE) {\r\npr_warning("%s: RTAS service <ibm,get-config-addr-info2> and "\r\n"<ibm,get-config-addr-info> invalid\n",\r\n__func__);\r\nreturn -EINVAL;\r\n} else if (ibm_configure_pe == RTAS_UNKNOWN_SERVICE &&\r\nibm_configure_bridge == RTAS_UNKNOWN_SERVICE) {\r\npr_warning("%s: RTAS service <ibm,configure-pe> and "\r\n"<ibm,configure-bridge> invalid\n",\r\n__func__);\r\nreturn -EINVAL;\r\n}\r\nspin_lock_init(&slot_errbuf_lock);\r\neeh_error_buf_size = rtas_token("rtas-error-log-max");\r\nif (eeh_error_buf_size == RTAS_UNKNOWN_SERVICE) {\r\npr_warning("%s: unknown EEH error log size\n",\r\n__func__);\r\neeh_error_buf_size = 1024;\r\n} else if (eeh_error_buf_size > RTAS_ERROR_LOG_MAX) {\r\npr_warning("%s: EEH error log size %d exceeds the maximal %d\n",\r\n__func__, eeh_error_buf_size, RTAS_ERROR_LOG_MAX);\r\neeh_error_buf_size = RTAS_ERROR_LOG_MAX;\r\n}\r\neeh_probe_mode_set(EEH_PROBE_MODE_DEVTREE);\r\nreturn 0;\r\n}\r\nstatic void *pseries_eeh_of_probe(struct device_node *dn, void *flag)\r\n{\r\nstruct eeh_dev *edev;\r\nstruct eeh_pe pe;\r\nconst u32 *class_code, *vendor_id, *device_id;\r\nconst u32 *regs;\r\nint enable = 0;\r\nint ret;\r\nedev = of_node_to_eeh_dev(dn);\r\nif (!of_device_is_available(dn))\r\nreturn NULL;\r\nclass_code = of_get_property(dn, "class-code", NULL);\r\nvendor_id = of_get_property(dn, "vendor-id", NULL);\r\ndevice_id = of_get_property(dn, "device-id", NULL);\r\nif (!class_code || !vendor_id || !device_id)\r\nreturn NULL;\r\nif (dn->type && !strcmp(dn->type, "isa"))\r\nreturn NULL;\r\nedev->class_code = *class_code;\r\nedev->mode = 0;\r\nregs = of_get_property(dn, "reg", NULL);\r\nif (!regs) {\r\npr_warning("%s: OF node property %s::reg not found\n",\r\n__func__, dn->full_name);\r\nreturn NULL;\r\n}\r\nmemset(&pe, 0, sizeof(struct eeh_pe));\r\npe.phb = edev->phb;\r\npe.config_addr = regs[0];\r\nret = eeh_ops->set_option(&pe, EEH_OPT_ENABLE);\r\nif (!ret) {\r\nedev->config_addr = regs[0];\r\nedev->pe_config_addr = eeh_ops->get_pe_addr(&pe);\r\npe.addr = edev->pe_config_addr;\r\nret = eeh_ops->get_state(&pe, NULL);\r\nif (ret > 0 && ret != EEH_STATE_NOT_SUPPORT)\r\nenable = 1;\r\nif (enable) {\r\neeh_subsystem_enabled = 1;\r\neeh_add_to_parent_pe(edev);\r\npr_debug("%s: EEH enabled on %s PHB#%d-PE#%x, config addr#%x\n",\r\n__func__, dn->full_name, pe.phb->global_number,\r\npe.addr, pe.config_addr);\r\n} else if (dn->parent && of_node_to_eeh_dev(dn->parent) &&\r\n(of_node_to_eeh_dev(dn->parent))->pe) {\r\nedev->config_addr = of_node_to_eeh_dev(dn->parent)->config_addr;\r\nedev->pe_config_addr = of_node_to_eeh_dev(dn->parent)->pe_config_addr;\r\neeh_add_to_parent_pe(edev);\r\n}\r\n}\r\neeh_save_bars(edev);\r\nreturn NULL;\r\n}\r\nstatic int pseries_eeh_set_option(struct eeh_pe *pe, int option)\r\n{\r\nint ret = 0;\r\nint config_addr;\r\nswitch (option) {\r\ncase EEH_OPT_DISABLE:\r\ncase EEH_OPT_ENABLE:\r\ncase EEH_OPT_THAW_MMIO:\r\ncase EEH_OPT_THAW_DMA:\r\nconfig_addr = pe->config_addr;\r\nif (pe->addr)\r\nconfig_addr = pe->addr;\r\nbreak;\r\ndefault:\r\npr_err("%s: Invalid option %d\n",\r\n__func__, option);\r\nreturn -EINVAL;\r\n}\r\nret = rtas_call(ibm_set_eeh_option, 4, 1, NULL,\r\nconfig_addr, BUID_HI(pe->phb->buid),\r\nBUID_LO(pe->phb->buid), option);\r\nreturn ret;\r\n}\r\nstatic int pseries_eeh_get_pe_addr(struct eeh_pe *pe)\r\n{\r\nint ret = 0;\r\nint rets[3];\r\nif (ibm_get_config_addr_info2 != RTAS_UNKNOWN_SERVICE) {\r\nret = rtas_call(ibm_get_config_addr_info2, 4, 2, rets,\r\npe->config_addr, BUID_HI(pe->phb->buid),\r\nBUID_LO(pe->phb->buid), 1);\r\nif (ret || (rets[0] == 0))\r\nreturn 0;\r\nret = rtas_call(ibm_get_config_addr_info2, 4, 2, rets,\r\npe->config_addr, BUID_HI(pe->phb->buid),\r\nBUID_LO(pe->phb->buid), 0);\r\nif (ret) {\r\npr_warning("%s: Failed to get address for PHB#%d-PE#%x\n",\r\n__func__, pe->phb->global_number, pe->config_addr);\r\nreturn 0;\r\n}\r\nreturn rets[0];\r\n}\r\nif (ibm_get_config_addr_info != RTAS_UNKNOWN_SERVICE) {\r\nret = rtas_call(ibm_get_config_addr_info, 4, 2, rets,\r\npe->config_addr, BUID_HI(pe->phb->buid),\r\nBUID_LO(pe->phb->buid), 0);\r\nif (ret) {\r\npr_warning("%s: Failed to get address for PHB#%d-PE#%x\n",\r\n__func__, pe->phb->global_number, pe->config_addr);\r\nreturn 0;\r\n}\r\nreturn rets[0];\r\n}\r\nreturn ret;\r\n}\r\nstatic int pseries_eeh_get_state(struct eeh_pe *pe, int *state)\r\n{\r\nint config_addr;\r\nint ret;\r\nint rets[4];\r\nint result;\r\nconfig_addr = pe->config_addr;\r\nif (pe->addr)\r\nconfig_addr = pe->addr;\r\nif (ibm_read_slot_reset_state2 != RTAS_UNKNOWN_SERVICE) {\r\nret = rtas_call(ibm_read_slot_reset_state2, 3, 4, rets,\r\nconfig_addr, BUID_HI(pe->phb->buid),\r\nBUID_LO(pe->phb->buid));\r\n} else if (ibm_read_slot_reset_state != RTAS_UNKNOWN_SERVICE) {\r\nrets[2] = 0;\r\nret = rtas_call(ibm_read_slot_reset_state, 3, 3, rets,\r\nconfig_addr, BUID_HI(pe->phb->buid),\r\nBUID_LO(pe->phb->buid));\r\n} else {\r\nreturn EEH_STATE_NOT_SUPPORT;\r\n}\r\nif (ret)\r\nreturn ret;\r\nresult = 0;\r\nif (rets[1]) {\r\nswitch(rets[0]) {\r\ncase 0:\r\nresult &= ~EEH_STATE_RESET_ACTIVE;\r\nresult |= EEH_STATE_MMIO_ACTIVE;\r\nresult |= EEH_STATE_DMA_ACTIVE;\r\nbreak;\r\ncase 1:\r\nresult |= EEH_STATE_RESET_ACTIVE;\r\nresult |= EEH_STATE_MMIO_ACTIVE;\r\nresult |= EEH_STATE_DMA_ACTIVE;\r\nbreak;\r\ncase 2:\r\nresult &= ~EEH_STATE_RESET_ACTIVE;\r\nresult &= ~EEH_STATE_MMIO_ACTIVE;\r\nresult &= ~EEH_STATE_DMA_ACTIVE;\r\nbreak;\r\ncase 4:\r\nresult &= ~EEH_STATE_RESET_ACTIVE;\r\nresult &= ~EEH_STATE_MMIO_ACTIVE;\r\nresult &= ~EEH_STATE_DMA_ACTIVE;\r\nresult |= EEH_STATE_MMIO_ENABLED;\r\nbreak;\r\ncase 5:\r\nif (rets[2]) {\r\nif (state) *state = rets[2];\r\nresult = EEH_STATE_UNAVAILABLE;\r\n} else {\r\nresult = EEH_STATE_NOT_SUPPORT;\r\n}\r\ndefault:\r\nresult = EEH_STATE_NOT_SUPPORT;\r\n}\r\n} else {\r\nresult = EEH_STATE_NOT_SUPPORT;\r\n}\r\nreturn result;\r\n}\r\nstatic int pseries_eeh_reset(struct eeh_pe *pe, int option)\r\n{\r\nint config_addr;\r\nint ret;\r\nconfig_addr = pe->config_addr;\r\nif (pe->addr)\r\nconfig_addr = pe->addr;\r\nret = rtas_call(ibm_set_slot_reset, 4, 1, NULL,\r\nconfig_addr, BUID_HI(pe->phb->buid),\r\nBUID_LO(pe->phb->buid), option);\r\nif (option == EEH_RESET_FUNDAMENTAL &&\r\nret == -8) {\r\nret = rtas_call(ibm_set_slot_reset, 4, 1, NULL,\r\nconfig_addr, BUID_HI(pe->phb->buid),\r\nBUID_LO(pe->phb->buid), EEH_RESET_HOT);\r\n}\r\nreturn ret;\r\n}\r\nstatic int pseries_eeh_wait_state(struct eeh_pe *pe, int max_wait)\r\n{\r\nint ret;\r\nint mwait;\r\n#define EEH_STATE_MIN_WAIT_TIME (1000)\r\n#define EEH_STATE_MAX_WAIT_TIME (300 * 1000)\r\nwhile (1) {\r\nret = pseries_eeh_get_state(pe, &mwait);\r\nif (ret != EEH_STATE_UNAVAILABLE)\r\nreturn ret;\r\nif (max_wait <= 0) {\r\npr_warning("%s: Timeout when getting PE's state (%d)\n",\r\n__func__, max_wait);\r\nreturn EEH_STATE_NOT_SUPPORT;\r\n}\r\nif (mwait <= 0) {\r\npr_warning("%s: Firmware returned bad wait value %d\n",\r\n__func__, mwait);\r\nmwait = EEH_STATE_MIN_WAIT_TIME;\r\n} else if (mwait > EEH_STATE_MAX_WAIT_TIME) {\r\npr_warning("%s: Firmware returned too long wait value %d\n",\r\n__func__, mwait);\r\nmwait = EEH_STATE_MAX_WAIT_TIME;\r\n}\r\nmax_wait -= mwait;\r\nmsleep(mwait);\r\n}\r\nreturn EEH_STATE_NOT_SUPPORT;\r\n}\r\nstatic int pseries_eeh_get_log(struct eeh_pe *pe, int severity, char *drv_log, unsigned long len)\r\n{\r\nint config_addr;\r\nunsigned long flags;\r\nint ret;\r\nspin_lock_irqsave(&slot_errbuf_lock, flags);\r\nmemset(slot_errbuf, 0, eeh_error_buf_size);\r\nconfig_addr = pe->config_addr;\r\nif (pe->addr)\r\nconfig_addr = pe->addr;\r\nret = rtas_call(ibm_slot_error_detail, 8, 1, NULL, config_addr,\r\nBUID_HI(pe->phb->buid), BUID_LO(pe->phb->buid),\r\nvirt_to_phys(drv_log), len,\r\nvirt_to_phys(slot_errbuf), eeh_error_buf_size,\r\nseverity);\r\nif (!ret)\r\nlog_error(slot_errbuf, ERR_TYPE_RTAS_LOG, 0);\r\nspin_unlock_irqrestore(&slot_errbuf_lock, flags);\r\nreturn ret;\r\n}\r\nstatic int pseries_eeh_configure_bridge(struct eeh_pe *pe)\r\n{\r\nint config_addr;\r\nint ret;\r\nconfig_addr = pe->config_addr;\r\nif (pe->addr)\r\nconfig_addr = pe->addr;\r\nif (ibm_configure_pe != RTAS_UNKNOWN_SERVICE) {\r\nret = rtas_call(ibm_configure_pe, 3, 1, NULL,\r\nconfig_addr, BUID_HI(pe->phb->buid),\r\nBUID_LO(pe->phb->buid));\r\n} else if (ibm_configure_bridge != RTAS_UNKNOWN_SERVICE) {\r\nret = rtas_call(ibm_configure_bridge, 3, 1, NULL,\r\nconfig_addr, BUID_HI(pe->phb->buid),\r\nBUID_LO(pe->phb->buid));\r\n} else {\r\nreturn -EFAULT;\r\n}\r\nif (ret)\r\npr_warning("%s: Unable to configure bridge PHB#%d-PE#%x (%d)\n",\r\n__func__, pe->phb->global_number, pe->addr, ret);\r\nreturn ret;\r\n}\r\nstatic int pseries_eeh_read_config(struct device_node *dn, int where, int size, u32 *val)\r\n{\r\nstruct pci_dn *pdn;\r\npdn = PCI_DN(dn);\r\nreturn rtas_read_config(pdn, where, size, val);\r\n}\r\nstatic int pseries_eeh_write_config(struct device_node *dn, int where, int size, u32 val)\r\n{\r\nstruct pci_dn *pdn;\r\npdn = PCI_DN(dn);\r\nreturn rtas_write_config(pdn, where, size, val);\r\n}\r\nstatic int __init eeh_pseries_init(void)\r\n{\r\nint ret = -EINVAL;\r\nif (!machine_is(pseries))\r\nreturn ret;\r\nret = eeh_ops_register(&pseries_eeh_ops);\r\nif (!ret)\r\npr_info("EEH: pSeries platform initialized\n");\r\nelse\r\npr_info("EEH: pSeries platform initialization failure (%d)\n",\r\nret);\r\nreturn ret;\r\n}
