int\r\nsgl_to_sgl_fcnvfx(\r\nsgl_floating_point *srcptr,\r\nsgl_floating_point *nullptr,\r\nint *dstptr,\r\nsgl_floating_point *status)\r\n{\r\nregister unsigned int src, temp;\r\nregister int src_exponent, result;\r\nregister boolean inexact = FALSE;\r\nsrc = *srcptr;\r\nsrc_exponent = Sgl_exponent(src) - SGL_BIAS;\r\nif (src_exponent > SGL_FX_MAX_EXP) {\r\nif ((src_exponent > SGL_FX_MAX_EXP + 1) ||\r\nSgl_isnotzero_mantissa(src) || Sgl_iszero_sign(src)) {\r\nif (Sgl_iszero_sign(src)) result = 0x7fffffff;\r\nelse result = 0x80000000;\r\nif (Is_invalidtrap_enabled()) {\r\nreturn(INVALIDEXCEPTION);\r\n}\r\nSet_invalidflag();\r\n*dstptr = result;\r\nreturn(NOEXCEPTION);\r\n}\r\n}\r\nif (src_exponent >= 0) {\r\ntemp = src;\r\nSgl_clear_signexponent_set_hidden(temp);\r\nInt_from_sgl_mantissa(temp,src_exponent);\r\nif (Sgl_isone_sign(src)) result = -Sgl_all(temp);\r\nelse result = Sgl_all(temp);\r\nif (Sgl_isinexact_to_fix(src,src_exponent)) {\r\ninexact = TRUE;\r\nswitch (Rounding_mode()) {\r\ncase ROUNDPLUS:\r\nif (Sgl_iszero_sign(src)) result++;\r\nbreak;\r\ncase ROUNDMINUS:\r\nif (Sgl_isone_sign(src)) result--;\r\nbreak;\r\ncase ROUNDNEAREST:\r\nif (Sgl_isone_roundbit(src,src_exponent)) {\r\nif (Sgl_isone_stickybit(src,src_exponent)\r\n|| (Sgl_isone_lowmantissa(temp)))\r\nif (Sgl_iszero_sign(src)) result++;\r\nelse result--;\r\n}\r\n}\r\n}\r\n}\r\nelse {\r\nresult = 0;\r\nif (Sgl_isnotzero_exponentmantissa(src)) {\r\ninexact = TRUE;\r\nswitch (Rounding_mode()) {\r\ncase ROUNDPLUS:\r\nif (Sgl_iszero_sign(src)) result++;\r\nbreak;\r\ncase ROUNDMINUS:\r\nif (Sgl_isone_sign(src)) result--;\r\nbreak;\r\ncase ROUNDNEAREST:\r\nif (src_exponent == -1)\r\nif (Sgl_isnotzero_mantissa(src))\r\nif (Sgl_iszero_sign(src)) result++;\r\nelse result--;\r\n}\r\n}\r\n}\r\n*dstptr = result;\r\nif (inexact) {\r\nif (Is_inexacttrap_enabled()) return(INEXACTEXCEPTION);\r\nelse Set_inexactflag();\r\n}\r\nreturn(NOEXCEPTION);\r\n}\r\nint\r\nsgl_to_dbl_fcnvfx(\r\nsgl_floating_point *srcptr,\r\nunsigned int *nullptr,\r\ndbl_integer *dstptr,\r\nunsigned int *status)\r\n{\r\nregister int src_exponent, resultp1;\r\nregister unsigned int src, temp, resultp2;\r\nregister boolean inexact = FALSE;\r\nsrc = *srcptr;\r\nsrc_exponent = Sgl_exponent(src) - SGL_BIAS;\r\nif (src_exponent > DBL_FX_MAX_EXP) {\r\nif ((src_exponent > DBL_FX_MAX_EXP + 1) ||\r\nSgl_isnotzero_mantissa(src) || Sgl_iszero_sign(src)) {\r\nif (Sgl_iszero_sign(src)) {\r\nresultp1 = 0x7fffffff;\r\nresultp2 = 0xffffffff;\r\n}\r\nelse {\r\nresultp1 = 0x80000000;\r\nresultp2 = 0;\r\n}\r\nif (Is_invalidtrap_enabled()) {\r\nreturn(INVALIDEXCEPTION);\r\n}\r\nSet_invalidflag();\r\nDint_copytoptr(resultp1,resultp2,dstptr);\r\nreturn(NOEXCEPTION);\r\n}\r\nDint_set_minint(resultp1,resultp2);\r\nDint_copytoptr(resultp1,resultp2,dstptr);\r\nreturn(NOEXCEPTION);\r\n}\r\nif (src_exponent >= 0) {\r\ntemp = src;\r\nSgl_clear_signexponent_set_hidden(temp);\r\nDint_from_sgl_mantissa(temp,src_exponent,resultp1,resultp2);\r\nif (Sgl_isone_sign(src)) {\r\nDint_setone_sign(resultp1,resultp2);\r\n}\r\nif (Sgl_isinexact_to_fix(src,src_exponent)) {\r\ninexact = TRUE;\r\nswitch (Rounding_mode()) {\r\ncase ROUNDPLUS:\r\nif (Sgl_iszero_sign(src)) {\r\nDint_increment(resultp1,resultp2);\r\n}\r\nbreak;\r\ncase ROUNDMINUS:\r\nif (Sgl_isone_sign(src)) {\r\nDint_decrement(resultp1,resultp2);\r\n}\r\nbreak;\r\ncase ROUNDNEAREST:\r\nif (Sgl_isone_roundbit(src,src_exponent))\r\nif (Sgl_isone_stickybit(src,src_exponent) ||\r\n(Dint_isone_lowp2(resultp2)))\r\nif (Sgl_iszero_sign(src)) {\r\nDint_increment(resultp1,resultp2);\r\n}\r\nelse {\r\nDint_decrement(resultp1,resultp2);\r\n}\r\n}\r\n}\r\n}\r\nelse {\r\nDint_setzero(resultp1,resultp2);\r\nif (Sgl_isnotzero_exponentmantissa(src)) {\r\ninexact = TRUE;\r\nswitch (Rounding_mode()) {\r\ncase ROUNDPLUS:\r\nif (Sgl_iszero_sign(src)) {\r\nDint_increment(resultp1,resultp2);\r\n}\r\nbreak;\r\ncase ROUNDMINUS:\r\nif (Sgl_isone_sign(src)) {\r\nDint_decrement(resultp1,resultp2);\r\n}\r\nbreak;\r\ncase ROUNDNEAREST:\r\nif (src_exponent == -1)\r\nif (Sgl_isnotzero_mantissa(src))\r\nif (Sgl_iszero_sign(src)) {\r\nDint_increment(resultp1,resultp2);\r\n}\r\nelse {\r\nDint_decrement(resultp1,resultp2);\r\n}\r\n}\r\n}\r\n}\r\nDint_copytoptr(resultp1,resultp2,dstptr);\r\nif (inexact) {\r\nif (Is_inexacttrap_enabled()) return(INEXACTEXCEPTION);\r\nelse Set_inexactflag();\r\n}\r\nreturn(NOEXCEPTION);\r\n}\r\nint\r\ndbl_to_sgl_fcnvfx(\r\ndbl_floating_point *srcptr,\r\nunsigned int *nullptr,\r\nint *dstptr,\r\nunsigned int *status)\r\n{\r\nregister unsigned int srcp1,srcp2, tempp1,tempp2;\r\nregister int src_exponent, result;\r\nregister boolean inexact = FALSE;\r\nDbl_copyfromptr(srcptr,srcp1,srcp2);\r\nsrc_exponent = Dbl_exponent(srcp1) - DBL_BIAS;\r\nif (src_exponent > SGL_FX_MAX_EXP) {\r\nif (Dbl_isoverflow_to_int(src_exponent,srcp1,srcp2)) {\r\nif (Dbl_iszero_sign(srcp1)) result = 0x7fffffff;\r\nelse result = 0x80000000;\r\nif (Is_invalidtrap_enabled()) {\r\nreturn(INVALIDEXCEPTION);\r\n}\r\nSet_invalidflag();\r\n*dstptr = result;\r\nreturn(NOEXCEPTION);\r\n}\r\n}\r\nif (src_exponent >= 0) {\r\ntempp1 = srcp1;\r\ntempp2 = srcp2;\r\nDbl_clear_signexponent_set_hidden(tempp1);\r\nInt_from_dbl_mantissa(tempp1,tempp2,src_exponent);\r\nif (Dbl_isone_sign(srcp1) && (src_exponent <= SGL_FX_MAX_EXP))\r\nresult = -Dbl_allp1(tempp1);\r\nelse result = Dbl_allp1(tempp1);\r\nif (Dbl_isinexact_to_fix(srcp1,srcp2,src_exponent)) {\r\ninexact = TRUE;\r\nswitch (Rounding_mode()) {\r\ncase ROUNDPLUS:\r\nif (Dbl_iszero_sign(srcp1)) result++;\r\nbreak;\r\ncase ROUNDMINUS:\r\nif (Dbl_isone_sign(srcp1)) result--;\r\nbreak;\r\ncase ROUNDNEAREST:\r\nif (Dbl_isone_roundbit(srcp1,srcp2,src_exponent))\r\nif (Dbl_isone_stickybit(srcp1,srcp2,src_exponent) ||\r\n(Dbl_isone_lowmantissap1(tempp1)))\r\nif (Dbl_iszero_sign(srcp1)) result++;\r\nelse result--;\r\n}\r\nif ((Dbl_iszero_sign(srcp1) && result < 0) ||\r\n(Dbl_isone_sign(srcp1) && result > 0)) {\r\nif (Dbl_iszero_sign(srcp1)) result = 0x7fffffff;\r\nelse result = 0x80000000;\r\nif (Is_invalidtrap_enabled()) {\r\nreturn(INVALIDEXCEPTION);\r\n}\r\nSet_invalidflag();\r\n*dstptr = result;\r\nreturn(NOEXCEPTION);\r\n}\r\n}\r\n}\r\nelse {\r\nresult = 0;\r\nif (Dbl_isnotzero_exponentmantissa(srcp1,srcp2)) {\r\ninexact = TRUE;\r\nswitch (Rounding_mode()) {\r\ncase ROUNDPLUS:\r\nif (Dbl_iszero_sign(srcp1)) result++;\r\nbreak;\r\ncase ROUNDMINUS:\r\nif (Dbl_isone_sign(srcp1)) result--;\r\nbreak;\r\ncase ROUNDNEAREST:\r\nif (src_exponent == -1)\r\nif (Dbl_isnotzero_mantissa(srcp1,srcp2))\r\nif (Dbl_iszero_sign(srcp1)) result++;\r\nelse result--;\r\n}\r\n}\r\n}\r\n*dstptr = result;\r\nif (inexact) {\r\nif (Is_inexacttrap_enabled()) return(INEXACTEXCEPTION);\r\nelse Set_inexactflag();\r\n}\r\nreturn(NOEXCEPTION);\r\n}\r\nint\r\ndbl_to_dbl_fcnvfx(\r\ndbl_floating_point *srcptr,\r\nunsigned int *nullptr,\r\ndbl_integer *dstptr,\r\nunsigned int *status)\r\n{\r\nregister int src_exponent, resultp1;\r\nregister unsigned int srcp1, srcp2, tempp1, tempp2, resultp2;\r\nregister boolean inexact = FALSE;\r\nDbl_copyfromptr(srcptr,srcp1,srcp2);\r\nsrc_exponent = Dbl_exponent(srcp1) - DBL_BIAS;\r\nif (src_exponent > DBL_FX_MAX_EXP) {\r\nif ((src_exponent > DBL_FX_MAX_EXP + 1) ||\r\nDbl_isnotzero_mantissa(srcp1,srcp2) || Dbl_iszero_sign(srcp1)) {\r\nif (Dbl_iszero_sign(srcp1)) {\r\nresultp1 = 0x7fffffff;\r\nresultp2 = 0xffffffff;\r\n}\r\nelse {\r\nresultp1 = 0x80000000;\r\nresultp2 = 0;\r\n}\r\nif (Is_invalidtrap_enabled()) {\r\nreturn(INVALIDEXCEPTION);\r\n}\r\nSet_invalidflag();\r\nDint_copytoptr(resultp1,resultp2,dstptr);\r\nreturn(NOEXCEPTION);\r\n}\r\n}\r\nif (src_exponent >= 0) {\r\ntempp1 = srcp1;\r\ntempp2 = srcp2;\r\nDbl_clear_signexponent_set_hidden(tempp1);\r\nDint_from_dbl_mantissa(tempp1,tempp2,src_exponent,resultp1,\r\nresultp2);\r\nif (Dbl_isone_sign(srcp1)) {\r\nDint_setone_sign(resultp1,resultp2);\r\n}\r\nif (Dbl_isinexact_to_fix(srcp1,srcp2,src_exponent)) {\r\ninexact = TRUE;\r\nswitch (Rounding_mode()) {\r\ncase ROUNDPLUS:\r\nif (Dbl_iszero_sign(srcp1)) {\r\nDint_increment(resultp1,resultp2);\r\n}\r\nbreak;\r\ncase ROUNDMINUS:\r\nif (Dbl_isone_sign(srcp1)) {\r\nDint_decrement(resultp1,resultp2);\r\n}\r\nbreak;\r\ncase ROUNDNEAREST:\r\nif (Dbl_isone_roundbit(srcp1,srcp2,src_exponent))\r\nif (Dbl_isone_stickybit(srcp1,srcp2,src_exponent) ||\r\n(Dint_isone_lowp2(resultp2)))\r\nif (Dbl_iszero_sign(srcp1)) {\r\nDint_increment(resultp1,resultp2);\r\n}\r\nelse {\r\nDint_decrement(resultp1,resultp2);\r\n}\r\n}\r\n}\r\n}\r\nelse {\r\nDint_setzero(resultp1,resultp2);\r\nif (Dbl_isnotzero_exponentmantissa(srcp1,srcp2)) {\r\ninexact = TRUE;\r\nswitch (Rounding_mode()) {\r\ncase ROUNDPLUS:\r\nif (Dbl_iszero_sign(srcp1)) {\r\nDint_increment(resultp1,resultp2);\r\n}\r\nbreak;\r\ncase ROUNDMINUS:\r\nif (Dbl_isone_sign(srcp1)) {\r\nDint_decrement(resultp1,resultp2);\r\n}\r\nbreak;\r\ncase ROUNDNEAREST:\r\nif (src_exponent == -1)\r\nif (Dbl_isnotzero_mantissa(srcp1,srcp2))\r\nif (Dbl_iszero_sign(srcp1)) {\r\nDint_increment(resultp1,resultp2);\r\n}\r\nelse {\r\nDint_decrement(resultp1,resultp2);\r\n}\r\n}\r\n}\r\n}\r\nDint_copytoptr(resultp1,resultp2,dstptr);\r\nif (inexact) {\r\nif (Is_inexacttrap_enabled()) return(INEXACTEXCEPTION);\r\nelse Set_inexactflag();\r\n}\r\nreturn(NOEXCEPTION);\r\n}
