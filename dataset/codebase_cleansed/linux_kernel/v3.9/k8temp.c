static struct k8temp_data *k8temp_update_device(struct device *dev)\r\n{\r\nstruct k8temp_data *data = dev_get_drvdata(dev);\r\nstruct pci_dev *pdev = to_pci_dev(dev);\r\nu8 tmp;\r\nmutex_lock(&data->update_lock);\r\nif (!data->valid\r\n|| time_after(jiffies, data->last_updated + HZ)) {\r\npci_read_config_byte(pdev, REG_TEMP, &tmp);\r\ntmp &= ~(SEL_PLACE | SEL_CORE);\r\npci_write_config_byte(pdev, REG_TEMP, tmp);\r\npci_read_config_dword(pdev, REG_TEMP, &data->temp[0][0]);\r\nif (data->sensorsp & SEL_PLACE) {\r\ntmp |= SEL_PLACE;\r\npci_write_config_byte(pdev, REG_TEMP, tmp);\r\npci_read_config_dword(pdev, REG_TEMP,\r\n&data->temp[0][1]);\r\n}\r\nif (data->sensorsp & SEL_CORE) {\r\ntmp &= ~SEL_PLACE;\r\ntmp |= SEL_CORE;\r\npci_write_config_byte(pdev, REG_TEMP, tmp);\r\npci_read_config_dword(pdev, REG_TEMP,\r\n&data->temp[1][0]);\r\nif (data->sensorsp & SEL_PLACE) {\r\ntmp |= SEL_PLACE;\r\npci_write_config_byte(pdev, REG_TEMP, tmp);\r\npci_read_config_dword(pdev, REG_TEMP,\r\n&data->temp[1][1]);\r\n}\r\n}\r\ndata->last_updated = jiffies;\r\ndata->valid = 1;\r\n}\r\nmutex_unlock(&data->update_lock);\r\nreturn data;\r\n}\r\nstatic ssize_t show_name(struct device *dev, struct device_attribute\r\n*devattr, char *buf)\r\n{\r\nstruct k8temp_data *data = dev_get_drvdata(dev);\r\nreturn sprintf(buf, "%s\n", data->name);\r\n}\r\nstatic ssize_t show_temp(struct device *dev,\r\nstruct device_attribute *devattr, char *buf)\r\n{\r\nstruct sensor_device_attribute_2 *attr =\r\nto_sensor_dev_attr_2(devattr);\r\nint core = attr->nr;\r\nint place = attr->index;\r\nint temp;\r\nstruct k8temp_data *data = k8temp_update_device(dev);\r\nif (data->swap_core_select && (data->sensorsp & SEL_CORE))\r\ncore = core ? 0 : 1;\r\ntemp = TEMP_FROM_REG(data->temp[core][place]) + data->temp_offset;\r\nreturn sprintf(buf, "%d\n", temp);\r\n}\r\nstatic int is_rev_g_desktop(u8 model)\r\n{\r\nu32 brandidx;\r\nif (model < 0x69)\r\nreturn 0;\r\nif (model == 0xc1 || model == 0x6c || model == 0x7c)\r\nreturn 0;\r\nbrandidx = cpuid_ebx(0x80000001);\r\nbrandidx = (brandidx >> 9) & 0x1f;\r\nif ((model == 0x6f || model == 0x7f) &&\r\n(brandidx == 0x7 || brandidx == 0x9 || brandidx == 0xc))\r\nreturn 0;\r\nif (model == 0x6b &&\r\n(brandidx == 0xb || brandidx == 0xc))\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic int k8temp_probe(struct pci_dev *pdev,\r\nconst struct pci_device_id *id)\r\n{\r\nint err;\r\nu8 scfg;\r\nu32 temp;\r\nu8 model, stepping;\r\nstruct k8temp_data *data;\r\ndata = devm_kzalloc(&pdev->dev, sizeof(struct k8temp_data), GFP_KERNEL);\r\nif (!data)\r\nreturn -ENOMEM;\r\nmodel = boot_cpu_data.x86_model;\r\nstepping = boot_cpu_data.x86_mask;\r\nif ((model == 4 && stepping == 0) ||\r\n(model == 5 && stepping <= 1))\r\nreturn -ENODEV;\r\nif (model >= 0x40) {\r\ndata->swap_core_select = 1;\r\ndev_warn(&pdev->dev, "Temperature readouts might be wrong - "\r\n"check erratum #141\n");\r\n}\r\nif (is_rev_g_desktop(model))\r\ndata->temp_offset = 21000;\r\npci_read_config_byte(pdev, REG_TEMP, &scfg);\r\nscfg &= ~(SEL_PLACE | SEL_CORE);\r\npci_write_config_byte(pdev, REG_TEMP, scfg);\r\npci_read_config_byte(pdev, REG_TEMP, &scfg);\r\nif (scfg & (SEL_PLACE | SEL_CORE)) {\r\ndev_err(&pdev->dev, "Configuration bit(s) stuck at 1!\n");\r\nreturn -ENODEV;\r\n}\r\nscfg |= (SEL_PLACE | SEL_CORE);\r\npci_write_config_byte(pdev, REG_TEMP, scfg);\r\npci_read_config_byte(pdev, REG_TEMP, &data->sensorsp);\r\nif (data->sensorsp & SEL_PLACE) {\r\nscfg &= ~SEL_CORE;\r\npci_write_config_byte(pdev, REG_TEMP, scfg);\r\npci_read_config_dword(pdev, REG_TEMP, &temp);\r\nscfg |= SEL_CORE;\r\nif (!((temp >> 16) & 0xff))\r\ndata->sensorsp &= ~SEL_PLACE;\r\n}\r\nif (data->sensorsp & SEL_CORE) {\r\nscfg &= ~SEL_PLACE;\r\npci_write_config_byte(pdev, REG_TEMP, scfg);\r\npci_read_config_dword(pdev, REG_TEMP, &temp);\r\nif (!((temp >> 16) & 0xff))\r\ndata->sensorsp &= ~SEL_CORE;\r\n}\r\ndata->name = "k8temp";\r\nmutex_init(&data->update_lock);\r\npci_set_drvdata(pdev, data);\r\nerr = device_create_file(&pdev->dev,\r\n&sensor_dev_attr_temp1_input.dev_attr);\r\nif (err)\r\ngoto exit_remove;\r\nif (data->sensorsp & SEL_PLACE) {\r\nerr = device_create_file(&pdev->dev,\r\n&sensor_dev_attr_temp2_input.dev_attr);\r\nif (err)\r\ngoto exit_remove;\r\n}\r\nif (data->sensorsp & SEL_CORE) {\r\nerr = device_create_file(&pdev->dev,\r\n&sensor_dev_attr_temp3_input.dev_attr);\r\nif (err)\r\ngoto exit_remove;\r\nif (data->sensorsp & SEL_PLACE) {\r\nerr = device_create_file(&pdev->dev,\r\n&sensor_dev_attr_temp4_input.\r\ndev_attr);\r\nif (err)\r\ngoto exit_remove;\r\n}\r\n}\r\nerr = device_create_file(&pdev->dev, &dev_attr_name);\r\nif (err)\r\ngoto exit_remove;\r\ndata->hwmon_dev = hwmon_device_register(&pdev->dev);\r\nif (IS_ERR(data->hwmon_dev)) {\r\nerr = PTR_ERR(data->hwmon_dev);\r\ngoto exit_remove;\r\n}\r\nreturn 0;\r\nexit_remove:\r\ndevice_remove_file(&pdev->dev,\r\n&sensor_dev_attr_temp1_input.dev_attr);\r\ndevice_remove_file(&pdev->dev,\r\n&sensor_dev_attr_temp2_input.dev_attr);\r\ndevice_remove_file(&pdev->dev,\r\n&sensor_dev_attr_temp3_input.dev_attr);\r\ndevice_remove_file(&pdev->dev,\r\n&sensor_dev_attr_temp4_input.dev_attr);\r\ndevice_remove_file(&pdev->dev, &dev_attr_name);\r\nreturn err;\r\n}\r\nstatic void k8temp_remove(struct pci_dev *pdev)\r\n{\r\nstruct k8temp_data *data = pci_get_drvdata(pdev);\r\nhwmon_device_unregister(data->hwmon_dev);\r\ndevice_remove_file(&pdev->dev,\r\n&sensor_dev_attr_temp1_input.dev_attr);\r\ndevice_remove_file(&pdev->dev,\r\n&sensor_dev_attr_temp2_input.dev_attr);\r\ndevice_remove_file(&pdev->dev,\r\n&sensor_dev_attr_temp3_input.dev_attr);\r\ndevice_remove_file(&pdev->dev,\r\n&sensor_dev_attr_temp4_input.dev_attr);\r\ndevice_remove_file(&pdev->dev, &dev_attr_name);\r\n}
