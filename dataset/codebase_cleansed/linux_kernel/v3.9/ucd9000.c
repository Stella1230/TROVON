static int ucd9000_get_fan_config(struct i2c_client *client, int fan)\r\n{\r\nint fan_config = 0;\r\nstruct ucd9000_data *data\r\n= to_ucd9000_data(pmbus_get_driver_info(client));\r\nif (data->fan_data[fan][3] & 1)\r\nfan_config |= PB_FAN_2_INSTALLED;\r\nfan_config |= (data->fan_data[fan][3] & 0x06) >> 1;\r\nreturn fan_config;\r\n}\r\nstatic int ucd9000_read_byte_data(struct i2c_client *client, int page, int reg)\r\n{\r\nint ret = 0;\r\nint fan_config;\r\nswitch (reg) {\r\ncase PMBUS_FAN_CONFIG_12:\r\nif (page > 0)\r\nreturn -ENXIO;\r\nret = ucd9000_get_fan_config(client, 0);\r\nif (ret < 0)\r\nreturn ret;\r\nfan_config = ret << 4;\r\nret = ucd9000_get_fan_config(client, 1);\r\nif (ret < 0)\r\nreturn ret;\r\nfan_config |= ret;\r\nret = fan_config;\r\nbreak;\r\ncase PMBUS_FAN_CONFIG_34:\r\nif (page > 0)\r\nreturn -ENXIO;\r\nret = ucd9000_get_fan_config(client, 2);\r\nif (ret < 0)\r\nreturn ret;\r\nfan_config = ret << 4;\r\nret = ucd9000_get_fan_config(client, 3);\r\nif (ret < 0)\r\nreturn ret;\r\nfan_config |= ret;\r\nret = fan_config;\r\nbreak;\r\ndefault:\r\nret = -ENODATA;\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int ucd9000_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nu8 block_buffer[I2C_SMBUS_BLOCK_MAX + 1];\r\nstruct ucd9000_data *data;\r\nstruct pmbus_driver_info *info;\r\nconst struct i2c_device_id *mid;\r\nint i, ret;\r\nif (!i2c_check_functionality(client->adapter,\r\nI2C_FUNC_SMBUS_BYTE_DATA |\r\nI2C_FUNC_SMBUS_BLOCK_DATA))\r\nreturn -ENODEV;\r\nret = i2c_smbus_read_block_data(client, UCD9000_DEVICE_ID,\r\nblock_buffer);\r\nif (ret < 0) {\r\ndev_err(&client->dev, "Failed to read device ID\n");\r\nreturn ret;\r\n}\r\nblock_buffer[ret] = '\0';\r\ndev_info(&client->dev, "Device ID %s\n", block_buffer);\r\nfor (mid = ucd9000_id; mid->name[0]; mid++) {\r\nif (!strncasecmp(mid->name, block_buffer, strlen(mid->name)))\r\nbreak;\r\n}\r\nif (!mid->name[0]) {\r\ndev_err(&client->dev, "Unsupported device\n");\r\nreturn -ENODEV;\r\n}\r\nif (id->driver_data != ucd9000 && id->driver_data != mid->driver_data)\r\ndev_notice(&client->dev,\r\n"Device mismatch: Configured %s, detected %s\n",\r\nid->name, mid->name);\r\ndata = devm_kzalloc(&client->dev, sizeof(struct ucd9000_data),\r\nGFP_KERNEL);\r\nif (!data)\r\nreturn -ENOMEM;\r\ninfo = &data->info;\r\nret = i2c_smbus_read_byte_data(client, UCD9000_NUM_PAGES);\r\nif (ret < 0) {\r\ndev_err(&client->dev,\r\n"Failed to read number of active pages\n");\r\nreturn ret;\r\n}\r\ninfo->pages = ret;\r\nif (!info->pages) {\r\ndev_err(&client->dev, "No pages configured\n");\r\nreturn -ENODEV;\r\n}\r\ninfo->func[0] = PMBUS_HAVE_TEMP;\r\nret = i2c_smbus_read_block_data(client, UCD9000_MONITOR_CONFIG,\r\nblock_buffer);\r\nif (ret <= 0) {\r\ndev_err(&client->dev, "Failed to read configuration data\n");\r\nreturn -ENODEV;\r\n}\r\nfor (i = 0; i < ret; i++) {\r\nint page = UCD9000_MON_PAGE(block_buffer[i]);\r\nif (page >= info->pages)\r\ncontinue;\r\nswitch (UCD9000_MON_TYPE(block_buffer[i])) {\r\ncase UCD9000_MON_VOLTAGE:\r\ncase UCD9000_MON_VOLTAGE_HW:\r\ninfo->func[page] |= PMBUS_HAVE_VOUT\r\n| PMBUS_HAVE_STATUS_VOUT;\r\nbreak;\r\ncase UCD9000_MON_TEMPERATURE:\r\ninfo->func[page] |= PMBUS_HAVE_TEMP2\r\n| PMBUS_HAVE_STATUS_TEMP;\r\nbreak;\r\ncase UCD9000_MON_CURRENT:\r\ninfo->func[page] |= PMBUS_HAVE_IOUT\r\n| PMBUS_HAVE_STATUS_IOUT;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nif (mid->driver_data == ucd90124) {\r\nfor (i = 0; i < UCD9000_NUM_FAN; i++) {\r\ni2c_smbus_write_byte_data(client,\r\nUCD9000_FAN_CONFIG_INDEX, i);\r\nret = i2c_smbus_read_block_data(client,\r\nUCD9000_FAN_CONFIG,\r\ndata->fan_data[i]);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\ni2c_smbus_write_byte_data(client, UCD9000_FAN_CONFIG_INDEX, 0);\r\ninfo->read_byte_data = ucd9000_read_byte_data;\r\ninfo->func[0] |= PMBUS_HAVE_FAN12 | PMBUS_HAVE_STATUS_FAN12\r\n| PMBUS_HAVE_FAN34 | PMBUS_HAVE_STATUS_FAN34;\r\n}\r\nreturn pmbus_do_probe(client, mid, info);\r\n}
