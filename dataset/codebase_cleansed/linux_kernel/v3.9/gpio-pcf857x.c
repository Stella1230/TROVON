static int i2c_write_le8(struct i2c_client *client, unsigned data)\r\n{\r\nreturn i2c_smbus_write_byte(client, data);\r\n}\r\nstatic int i2c_read_le8(struct i2c_client *client)\r\n{\r\nreturn (int)i2c_smbus_read_byte(client);\r\n}\r\nstatic int i2c_write_le16(struct i2c_client *client, unsigned word)\r\n{\r\nu8 buf[2] = { word & 0xff, word >> 8, };\r\nint status;\r\nstatus = i2c_master_send(client, buf, 2);\r\nreturn (status < 0) ? status : 0;\r\n}\r\nstatic int i2c_read_le16(struct i2c_client *client)\r\n{\r\nu8 buf[2];\r\nint status;\r\nstatus = i2c_master_recv(client, buf, 2);\r\nif (status < 0)\r\nreturn status;\r\nreturn (buf[1] << 8) | buf[0];\r\n}\r\nstatic int pcf857x_input(struct gpio_chip *chip, unsigned offset)\r\n{\r\nstruct pcf857x *gpio = container_of(chip, struct pcf857x, chip);\r\nint status;\r\nmutex_lock(&gpio->lock);\r\ngpio->out |= (1 << offset);\r\nstatus = gpio->write(gpio->client, gpio->out);\r\nmutex_unlock(&gpio->lock);\r\nreturn status;\r\n}\r\nstatic int pcf857x_get(struct gpio_chip *chip, unsigned offset)\r\n{\r\nstruct pcf857x *gpio = container_of(chip, struct pcf857x, chip);\r\nint value;\r\nvalue = gpio->read(gpio->client);\r\nreturn (value < 0) ? 0 : (value & (1 << offset));\r\n}\r\nstatic int pcf857x_output(struct gpio_chip *chip, unsigned offset, int value)\r\n{\r\nstruct pcf857x *gpio = container_of(chip, struct pcf857x, chip);\r\nunsigned bit = 1 << offset;\r\nint status;\r\nmutex_lock(&gpio->lock);\r\nif (value)\r\ngpio->out |= bit;\r\nelse\r\ngpio->out &= ~bit;\r\nstatus = gpio->write(gpio->client, gpio->out);\r\nmutex_unlock(&gpio->lock);\r\nreturn status;\r\n}\r\nstatic void pcf857x_set(struct gpio_chip *chip, unsigned offset, int value)\r\n{\r\npcf857x_output(chip, offset, value);\r\n}\r\nstatic int pcf857x_to_irq(struct gpio_chip *chip, unsigned offset)\r\n{\r\nstruct pcf857x *gpio = container_of(chip, struct pcf857x, chip);\r\nreturn irq_create_mapping(gpio->irq_domain, offset);\r\n}\r\nstatic void pcf857x_irq_demux_work(struct work_struct *work)\r\n{\r\nstruct pcf857x *gpio = container_of(work,\r\nstruct pcf857x,\r\nwork);\r\nunsigned long change, i, status, flags;\r\nstatus = gpio->read(gpio->client);\r\nspin_lock_irqsave(&gpio->slock, flags);\r\nchange = gpio->status ^ status;\r\nfor_each_set_bit(i, &change, gpio->chip.ngpio)\r\ngeneric_handle_irq(irq_find_mapping(gpio->irq_domain, i));\r\ngpio->status = status;\r\nspin_unlock_irqrestore(&gpio->slock, flags);\r\n}\r\nstatic irqreturn_t pcf857x_irq_demux(int irq, void *data)\r\n{\r\nstruct pcf857x *gpio = data;\r\nschedule_work(&gpio->work);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int pcf857x_irq_domain_map(struct irq_domain *domain, unsigned int virq,\r\nirq_hw_number_t hw)\r\n{\r\nirq_set_chip_and_handler(virq,\r\n&dummy_irq_chip,\r\nhandle_level_irq);\r\nreturn 0;\r\n}\r\nstatic void pcf857x_irq_domain_cleanup(struct pcf857x *gpio)\r\n{\r\nif (gpio->irq_domain)\r\nirq_domain_remove(gpio->irq_domain);\r\nif (gpio->irq)\r\nfree_irq(gpio->irq, gpio);\r\n}\r\nstatic int pcf857x_irq_domain_init(struct pcf857x *gpio,\r\nstruct pcf857x_platform_data *pdata,\r\nstruct i2c_client *client)\r\n{\r\nint status;\r\ngpio->irq_domain = irq_domain_add_linear(client->dev.of_node,\r\ngpio->chip.ngpio,\r\n&pcf857x_irq_domain_ops,\r\nNULL);\r\nif (!gpio->irq_domain)\r\ngoto fail;\r\nstatus = request_irq(client->irq, pcf857x_irq_demux, 0,\r\ndev_name(&client->dev), gpio);\r\nif (status)\r\ngoto fail;\r\nINIT_WORK(&gpio->work, pcf857x_irq_demux_work);\r\ngpio->chip.to_irq = pcf857x_to_irq;\r\ngpio->irq = client->irq;\r\nreturn 0;\r\nfail:\r\npcf857x_irq_domain_cleanup(gpio);\r\nreturn -EINVAL;\r\n}\r\nstatic int pcf857x_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct pcf857x_platform_data *pdata;\r\nstruct pcf857x *gpio;\r\nint status;\r\npdata = client->dev.platform_data;\r\nif (!pdata) {\r\ndev_dbg(&client->dev, "no platform data\n");\r\n}\r\ngpio = kzalloc(sizeof *gpio, GFP_KERNEL);\r\nif (!gpio)\r\nreturn -ENOMEM;\r\nmutex_init(&gpio->lock);\r\nspin_lock_init(&gpio->slock);\r\ngpio->chip.base = pdata ? pdata->gpio_base : -1;\r\ngpio->chip.can_sleep = 1;\r\ngpio->chip.dev = &client->dev;\r\ngpio->chip.owner = THIS_MODULE;\r\ngpio->chip.get = pcf857x_get;\r\ngpio->chip.set = pcf857x_set;\r\ngpio->chip.direction_input = pcf857x_input;\r\ngpio->chip.direction_output = pcf857x_output;\r\ngpio->chip.ngpio = id->driver_data;\r\nif (pdata && client->irq) {\r\nstatus = pcf857x_irq_domain_init(gpio, pdata, client);\r\nif (status < 0) {\r\ndev_err(&client->dev, "irq_domain init failed\n");\r\ngoto fail;\r\n}\r\n}\r\nif (gpio->chip.ngpio == 8) {\r\ngpio->write = i2c_write_le8;\r\ngpio->read = i2c_read_le8;\r\nif (!i2c_check_functionality(client->adapter,\r\nI2C_FUNC_SMBUS_BYTE))\r\nstatus = -EIO;\r\nelse\r\nstatus = i2c_smbus_read_byte(client);\r\n} else if (gpio->chip.ngpio == 16) {\r\ngpio->write = i2c_write_le16;\r\ngpio->read = i2c_read_le16;\r\nif (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C))\r\nstatus = -EIO;\r\nelse\r\nstatus = i2c_read_le16(client);\r\n} else {\r\ndev_dbg(&client->dev, "unsupported number of gpios\n");\r\nstatus = -EINVAL;\r\n}\r\nif (status < 0)\r\ngoto fail;\r\ngpio->chip.label = client->name;\r\ngpio->client = client;\r\ni2c_set_clientdata(client, gpio);\r\ngpio->out = pdata ? ~pdata->n_latch : ~0;\r\ngpio->status = gpio->out;\r\nstatus = gpiochip_add(&gpio->chip);\r\nif (status < 0)\r\ngoto fail;\r\nif (pdata && pdata->setup) {\r\nstatus = pdata->setup(client,\r\ngpio->chip.base, gpio->chip.ngpio,\r\npdata->context);\r\nif (status < 0)\r\ndev_warn(&client->dev, "setup --> %d\n", status);\r\n}\r\ndev_info(&client->dev, "probed\n");\r\nreturn 0;\r\nfail:\r\ndev_dbg(&client->dev, "probe error %d for '%s'\n",\r\nstatus, client->name);\r\nif (pdata && client->irq)\r\npcf857x_irq_domain_cleanup(gpio);\r\nkfree(gpio);\r\nreturn status;\r\n}\r\nstatic int pcf857x_remove(struct i2c_client *client)\r\n{\r\nstruct pcf857x_platform_data *pdata = client->dev.platform_data;\r\nstruct pcf857x *gpio = i2c_get_clientdata(client);\r\nint status = 0;\r\nif (pdata && pdata->teardown) {\r\nstatus = pdata->teardown(client,\r\ngpio->chip.base, gpio->chip.ngpio,\r\npdata->context);\r\nif (status < 0) {\r\ndev_err(&client->dev, "%s --> %d\n",\r\n"teardown", status);\r\nreturn status;\r\n}\r\n}\r\nif (pdata && client->irq)\r\npcf857x_irq_domain_cleanup(gpio);\r\nstatus = gpiochip_remove(&gpio->chip);\r\nif (status == 0)\r\nkfree(gpio);\r\nelse\r\ndev_err(&client->dev, "%s --> %d\n", "remove", status);\r\nreturn status;\r\n}\r\nstatic int __init pcf857x_init(void)\r\n{\r\nreturn i2c_add_driver(&pcf857x_driver);\r\n}\r\nstatic void __exit pcf857x_exit(void)\r\n{\r\ni2c_del_driver(&pcf857x_driver);\r\n}
