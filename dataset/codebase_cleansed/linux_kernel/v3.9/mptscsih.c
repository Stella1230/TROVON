static inline int\r\nmptscsih_getFreeChainBuffer(MPT_ADAPTER *ioc, int *retIndex)\r\n{\r\nMPT_FRAME_HDR *chainBuf;\r\nunsigned long flags;\r\nint rc;\r\nint chain_idx;\r\ndsgprintk(ioc, printk(MYIOC_s_DEBUG_FMT "getFreeChainBuffer called\n",\r\nioc->name));\r\nspin_lock_irqsave(&ioc->FreeQlock, flags);\r\nif (!list_empty(&ioc->FreeChainQ)) {\r\nint offset;\r\nchainBuf = list_entry(ioc->FreeChainQ.next, MPT_FRAME_HDR,\r\nu.frame.linkage.list);\r\nlist_del(&chainBuf->u.frame.linkage.list);\r\noffset = (u8 *)chainBuf - (u8 *)ioc->ChainBuffer;\r\nchain_idx = offset / ioc->req_sz;\r\nrc = SUCCESS;\r\ndsgprintk(ioc, printk(MYIOC_s_DEBUG_FMT\r\n"getFreeChainBuffer chainBuf=%p ChainBuffer=%p offset=%d chain_idx=%d\n",\r\nioc->name, chainBuf, ioc->ChainBuffer, offset, chain_idx));\r\n} else {\r\nrc = FAILED;\r\nchain_idx = MPT_HOST_NO_CHAIN;\r\ndfailprintk(ioc, printk(MYIOC_s_ERR_FMT "getFreeChainBuffer failed\n",\r\nioc->name));\r\n}\r\nspin_unlock_irqrestore(&ioc->FreeQlock, flags);\r\n*retIndex = chain_idx;\r\nreturn rc;\r\n}\r\nstatic int\r\nmptscsih_AddSGE(MPT_ADAPTER *ioc, struct scsi_cmnd *SCpnt,\r\nSCSIIORequest_t *pReq, int req_idx)\r\n{\r\nchar *psge;\r\nchar *chainSge;\r\nstruct scatterlist *sg;\r\nint frm_sz;\r\nint sges_left, sg_done;\r\nint chain_idx = MPT_HOST_NO_CHAIN;\r\nint sgeOffset;\r\nint numSgeSlots, numSgeThisFrame;\r\nu32 sgflags, sgdir, thisxfer = 0;\r\nint chain_dma_off = 0;\r\nint newIndex;\r\nint ii;\r\ndma_addr_t v2;\r\nu32 RequestNB;\r\nsgdir = le32_to_cpu(pReq->Control) & MPI_SCSIIO_CONTROL_DATADIRECTION_MASK;\r\nif (sgdir == MPI_SCSIIO_CONTROL_WRITE) {\r\nsgdir = MPT_TRANSFER_HOST_TO_IOC;\r\n} else {\r\nsgdir = MPT_TRANSFER_IOC_TO_HOST;\r\n}\r\npsge = (char *) &pReq->SGL;\r\nfrm_sz = ioc->req_sz;\r\nsges_left = scsi_dma_map(SCpnt);\r\nif (sges_left < 0)\r\nreturn FAILED;\r\nsg = scsi_sglist(SCpnt);\r\nsg_done = 0;\r\nsgeOffset = sizeof(SCSIIORequest_t) - sizeof(SGE_IO_UNION);\r\nchainSge = NULL;\r\nnextSGEset:\r\nnumSgeSlots = ((frm_sz - sgeOffset) / ioc->SGE_size);\r\nnumSgeThisFrame = (sges_left < numSgeSlots) ? sges_left : numSgeSlots;\r\nsgflags = MPT_SGE_FLAGS_SIMPLE_ELEMENT | sgdir;\r\nfor (ii=0; ii < (numSgeThisFrame-1); ii++) {\r\nthisxfer = sg_dma_len(sg);\r\nif (thisxfer == 0) {\r\nsg = sg_next(sg);\r\nsg_done++;\r\ncontinue;\r\n}\r\nv2 = sg_dma_address(sg);\r\nioc->add_sge(psge, sgflags | thisxfer, v2);\r\nsg = sg_next(sg);\r\npsge += ioc->SGE_size;\r\nsgeOffset += ioc->SGE_size;\r\nsg_done++;\r\n}\r\nif (numSgeThisFrame == sges_left) {\r\nsgflags |= MPT_SGE_FLAGS_LAST_ELEMENT |\r\nMPT_SGE_FLAGS_END_OF_BUFFER |\r\nMPT_SGE_FLAGS_END_OF_LIST;\r\nthisxfer = sg_dma_len(sg);\r\nv2 = sg_dma_address(sg);\r\nioc->add_sge(psge, sgflags | thisxfer, v2);\r\nsgeOffset += ioc->SGE_size;\r\nsg_done++;\r\nif (chainSge) {\r\nioc->add_chain((char *)chainSge, 0, sgeOffset,\r\nioc->ChainBufferDMA + chain_dma_off);\r\n} else {\r\npReq->ChainOffset = 0;\r\nRequestNB = (((sgeOffset - 1) >> ioc->NBShiftFactor) + 1) & 0x03;\r\ndsgprintk(ioc, printk(MYIOC_s_DEBUG_FMT\r\n"Single Buffer RequestNB=%x, sgeOffset=%d\n", ioc->name, RequestNB, sgeOffset));\r\nioc->RequestNB[req_idx] = RequestNB;\r\n}\r\n} else {\r\ndsgprintk(ioc, printk(MYIOC_s_DEBUG_FMT "SG: Chain Required! sg done %d\n",\r\nioc->name, sg_done));\r\nif (sg_done) {\r\nu32 *ptmp = (u32 *) (psge - ioc->SGE_size);\r\nsgflags = le32_to_cpu(*ptmp);\r\nsgflags |= MPT_SGE_FLAGS_LAST_ELEMENT;\r\n*ptmp = cpu_to_le32(sgflags);\r\n}\r\nif (chainSge) {\r\nu8 nextChain = (u8) (sgeOffset >> 2);\r\nsgeOffset += ioc->SGE_size;\r\nioc->add_chain((char *)chainSge, nextChain, sgeOffset,\r\nioc->ChainBufferDMA + chain_dma_off);\r\n} else {\r\npReq->ChainOffset = (u8) (sgeOffset >> 2);\r\nRequestNB = (((sgeOffset - 1) >> ioc->NBShiftFactor) + 1) & 0x03;\r\ndsgprintk(ioc, printk(MYIOC_s_DEBUG_FMT "Chain Buffer Needed, RequestNB=%x sgeOffset=%d\n", ioc->name, RequestNB, sgeOffset));\r\nioc->RequestNB[req_idx] = RequestNB;\r\n}\r\nsges_left -= sg_done;\r\nif ((mptscsih_getFreeChainBuffer(ioc, &newIndex)) == FAILED) {\r\ndfailprintk(ioc, printk(MYIOC_s_DEBUG_FMT\r\n"getFreeChainBuffer FAILED SCSI cmd=%02x (%p)\n",\r\nioc->name, pReq->CDB[0], SCpnt));\r\nreturn FAILED;\r\n}\r\nif (chainSge) {\r\nioc->ChainToChain[chain_idx] = newIndex;\r\n} else {\r\nioc->ReqToChain[req_idx] = newIndex;\r\n}\r\nchain_idx = newIndex;\r\nchain_dma_off = ioc->req_sz * chain_idx;\r\nchainSge = (char *) psge;\r\ndsgprintk(ioc, printk(MYIOC_s_DEBUG_FMT " Current buff @ %p (index 0x%x)",\r\nioc->name, psge, req_idx));\r\npsge = (char *) (ioc->ChainBuffer + chain_dma_off);\r\nsgeOffset = 0;\r\nsg_done = 0;\r\ndsgprintk(ioc, printk(MYIOC_s_DEBUG_FMT " Chain buff @ %p (index 0x%x)\n",\r\nioc->name, psge, chain_idx));\r\ngoto nextSGEset;\r\n}\r\nreturn SUCCESS;\r\n}\r\nstatic void\r\nmptscsih_issue_sep_command(MPT_ADAPTER *ioc, VirtTarget *vtarget,\r\nU32 SlotStatus)\r\n{\r\nMPT_FRAME_HDR *mf;\r\nSEPRequest_t *SEPMsg;\r\nif (ioc->bus_type != SAS)\r\nreturn;\r\nif (vtarget->tflags & MPT_TARGET_FLAGS_RAID_COMPONENT)\r\nreturn;\r\nif ((mf = mpt_get_msg_frame(ioc->InternalCtx, ioc)) == NULL) {\r\ndfailprintk(ioc, printk(MYIOC_s_WARN_FMT "%s: no msg frames!!\n",\r\nioc->name,__func__));\r\nreturn;\r\n}\r\nSEPMsg = (SEPRequest_t *)mf;\r\nSEPMsg->Function = MPI_FUNCTION_SCSI_ENCLOSURE_PROCESSOR;\r\nSEPMsg->Bus = vtarget->channel;\r\nSEPMsg->TargetID = vtarget->id;\r\nSEPMsg->Action = MPI_SEP_REQ_ACTION_WRITE_STATUS;\r\nSEPMsg->SlotStatus = SlotStatus;\r\ndevtverboseprintk(ioc, printk(MYIOC_s_DEBUG_FMT\r\n"Sending SEP cmd=%x channel=%d id=%d\n",\r\nioc->name, SlotStatus, SEPMsg->Bus, SEPMsg->TargetID));\r\nmpt_put_msg_frame(ioc->DoneCtx, ioc, mf);\r\n}\r\nstatic void\r\nmptscsih_info_scsiio(MPT_ADAPTER *ioc, struct scsi_cmnd *sc, SCSIIOReply_t * pScsiReply)\r\n{\r\nchar *desc = NULL;\r\nchar *desc1 = NULL;\r\nu16 ioc_status;\r\nu8 skey, asc, ascq;\r\nioc_status = le16_to_cpu(pScsiReply->IOCStatus) & MPI_IOCSTATUS_MASK;\r\nswitch (ioc_status) {\r\ncase MPI_IOCSTATUS_SUCCESS:\r\ndesc = "success";\r\nbreak;\r\ncase MPI_IOCSTATUS_SCSI_INVALID_BUS:\r\ndesc = "invalid bus";\r\nbreak;\r\ncase MPI_IOCSTATUS_SCSI_INVALID_TARGETID:\r\ndesc = "invalid target_id";\r\nbreak;\r\ncase MPI_IOCSTATUS_SCSI_DEVICE_NOT_THERE:\r\ndesc = "device not there";\r\nbreak;\r\ncase MPI_IOCSTATUS_SCSI_DATA_OVERRUN:\r\ndesc = "data overrun";\r\nbreak;\r\ncase MPI_IOCSTATUS_SCSI_DATA_UNDERRUN:\r\ndesc = "data underrun";\r\nbreak;\r\ncase MPI_IOCSTATUS_SCSI_IO_DATA_ERROR:\r\ndesc = "I/O data error";\r\nbreak;\r\ncase MPI_IOCSTATUS_SCSI_PROTOCOL_ERROR:\r\ndesc = "protocol error";\r\nbreak;\r\ncase MPI_IOCSTATUS_SCSI_TASK_TERMINATED:\r\ndesc = "task terminated";\r\nbreak;\r\ncase MPI_IOCSTATUS_SCSI_RESIDUAL_MISMATCH:\r\ndesc = "residual mismatch";\r\nbreak;\r\ncase MPI_IOCSTATUS_SCSI_TASK_MGMT_FAILED:\r\ndesc = "task management failed";\r\nbreak;\r\ncase MPI_IOCSTATUS_SCSI_IOC_TERMINATED:\r\ndesc = "IOC terminated";\r\nbreak;\r\ncase MPI_IOCSTATUS_SCSI_EXT_TERMINATED:\r\ndesc = "ext terminated";\r\nbreak;\r\ndefault:\r\ndesc = "";\r\nbreak;\r\n}\r\nswitch (pScsiReply->SCSIStatus)\r\n{\r\ncase MPI_SCSI_STATUS_SUCCESS:\r\ndesc1 = "success";\r\nbreak;\r\ncase MPI_SCSI_STATUS_CHECK_CONDITION:\r\ndesc1 = "check condition";\r\nbreak;\r\ncase MPI_SCSI_STATUS_CONDITION_MET:\r\ndesc1 = "condition met";\r\nbreak;\r\ncase MPI_SCSI_STATUS_BUSY:\r\ndesc1 = "busy";\r\nbreak;\r\ncase MPI_SCSI_STATUS_INTERMEDIATE:\r\ndesc1 = "intermediate";\r\nbreak;\r\ncase MPI_SCSI_STATUS_INTERMEDIATE_CONDMET:\r\ndesc1 = "intermediate condmet";\r\nbreak;\r\ncase MPI_SCSI_STATUS_RESERVATION_CONFLICT:\r\ndesc1 = "reservation conflict";\r\nbreak;\r\ncase MPI_SCSI_STATUS_COMMAND_TERMINATED:\r\ndesc1 = "command terminated";\r\nbreak;\r\ncase MPI_SCSI_STATUS_TASK_SET_FULL:\r\ndesc1 = "task set full";\r\nbreak;\r\ncase MPI_SCSI_STATUS_ACA_ACTIVE:\r\ndesc1 = "aca active";\r\nbreak;\r\ncase MPI_SCSI_STATUS_FCPEXT_DEVICE_LOGGED_OUT:\r\ndesc1 = "fcpext device logged out";\r\nbreak;\r\ncase MPI_SCSI_STATUS_FCPEXT_NO_LINK:\r\ndesc1 = "fcpext no link";\r\nbreak;\r\ncase MPI_SCSI_STATUS_FCPEXT_UNASSIGNED:\r\ndesc1 = "fcpext unassigned";\r\nbreak;\r\ndefault:\r\ndesc1 = "";\r\nbreak;\r\n}\r\nscsi_print_command(sc);\r\nprintk(MYIOC_s_DEBUG_FMT "\tfw_channel = %d, fw_id = %d, lun = %d\n",\r\nioc->name, pScsiReply->Bus, pScsiReply->TargetID, sc->device->lun);\r\nprintk(MYIOC_s_DEBUG_FMT "\trequest_len = %d, underflow = %d, "\r\n"resid = %d\n", ioc->name, scsi_bufflen(sc), sc->underflow,\r\nscsi_get_resid(sc));\r\nprintk(MYIOC_s_DEBUG_FMT "\ttag = %d, transfer_count = %d, "\r\n"sc->result = %08X\n", ioc->name, le16_to_cpu(pScsiReply->TaskTag),\r\nle32_to_cpu(pScsiReply->TransferCount), sc->result);\r\nprintk(MYIOC_s_DEBUG_FMT "\tiocstatus = %s (0x%04x), "\r\n"scsi_status = %s (0x%02x), scsi_state = (0x%02x)\n",\r\nioc->name, desc, ioc_status, desc1, pScsiReply->SCSIStatus,\r\npScsiReply->SCSIState);\r\nif (pScsiReply->SCSIState & MPI_SCSI_STATE_AUTOSENSE_VALID) {\r\nskey = sc->sense_buffer[2] & 0x0F;\r\nasc = sc->sense_buffer[12];\r\nascq = sc->sense_buffer[13];\r\nprintk(MYIOC_s_DEBUG_FMT "\t[sense_key,asc,ascq]: "\r\n"[0x%02x,0x%02x,0x%02x]\n", ioc->name, skey, asc, ascq);\r\n}\r\nif (pScsiReply->SCSIState & MPI_SCSI_STATE_RESPONSE_INFO_VALID &&\r\npScsiReply->ResponseInfo)\r\nprintk(MYIOC_s_DEBUG_FMT "response_info = %08xh\n",\r\nioc->name, le32_to_cpu(pScsiReply->ResponseInfo));\r\n}\r\nint\r\nmptscsih_io_done(MPT_ADAPTER *ioc, MPT_FRAME_HDR *mf, MPT_FRAME_HDR *mr)\r\n{\r\nstruct scsi_cmnd *sc;\r\nMPT_SCSI_HOST *hd;\r\nSCSIIORequest_t *pScsiReq;\r\nSCSIIOReply_t *pScsiReply;\r\nu16 req_idx, req_idx_MR;\r\nVirtDevice *vdevice;\r\nVirtTarget *vtarget;\r\nhd = shost_priv(ioc->sh);\r\nreq_idx = le16_to_cpu(mf->u.frame.hwhdr.msgctxu.fld.req_idx);\r\nreq_idx_MR = (mr != NULL) ?\r\nle16_to_cpu(mr->u.frame.hwhdr.msgctxu.fld.req_idx) : req_idx;\r\nif ((req_idx != req_idx_MR) ||\r\n(le32_to_cpu(mf->u.frame.linkage.arg1) == 0xdeadbeaf))\r\nreturn 0;\r\nsc = mptscsih_getclear_scsi_lookup(ioc, req_idx);\r\nif (sc == NULL) {\r\nMPIHeader_t *hdr = (MPIHeader_t *)mf;\r\nif (hdr->Function == MPI_FUNCTION_SCSI_IO_REQUEST)\r\nprintk(MYIOC_s_ERR_FMT "NULL ScsiCmd ptr!\n",\r\nioc->name);\r\nmptscsih_freeChainBuffers(ioc, req_idx);\r\nreturn 1;\r\n}\r\nif ((unsigned char *)mf != sc->host_scribble) {\r\nmptscsih_freeChainBuffers(ioc, req_idx);\r\nreturn 1;\r\n}\r\nif (ioc->bus_type == SAS) {\r\nVirtDevice *vdevice = sc->device->hostdata;\r\nif (!vdevice || !vdevice->vtarget ||\r\nvdevice->vtarget->deleted) {\r\nsc->result = DID_NO_CONNECT << 16;\r\ngoto out;\r\n}\r\n}\r\nsc->host_scribble = NULL;\r\nsc->result = DID_OK << 16;\r\npScsiReq = (SCSIIORequest_t *) mf;\r\npScsiReply = (SCSIIOReply_t *) mr;\r\nif((ioc->facts.MsgVersion >= MPI_VERSION_01_05) && pScsiReply){\r\ndmfprintk(ioc, printk(MYIOC_s_DEBUG_FMT\r\n"ScsiDone (mf=%p,mr=%p,sc=%p,idx=%d,task-tag=%d)\n",\r\nioc->name, mf, mr, sc, req_idx, pScsiReply->TaskTag));\r\n}else{\r\ndmfprintk(ioc, printk(MYIOC_s_DEBUG_FMT\r\n"ScsiDone (mf=%p,mr=%p,sc=%p,idx=%d)\n",\r\nioc->name, mf, mr, sc, req_idx));\r\n}\r\nif (pScsiReply == NULL) {\r\n;\r\n} else {\r\nu32 xfer_cnt;\r\nu16 status;\r\nu8 scsi_state, scsi_status;\r\nu32 log_info;\r\nstatus = le16_to_cpu(pScsiReply->IOCStatus) & MPI_IOCSTATUS_MASK;\r\nscsi_state = pScsiReply->SCSIState;\r\nscsi_status = pScsiReply->SCSIStatus;\r\nxfer_cnt = le32_to_cpu(pScsiReply->TransferCount);\r\nscsi_set_resid(sc, scsi_bufflen(sc) - xfer_cnt);\r\nlog_info = le32_to_cpu(pScsiReply->IOCLogInfo);\r\nif (status == MPI_IOCSTATUS_SCSI_DATA_UNDERRUN && xfer_cnt == 0 &&\r\n(scsi_status == MPI_SCSI_STATUS_BUSY ||\r\nscsi_status == MPI_SCSI_STATUS_RESERVATION_CONFLICT ||\r\nscsi_status == MPI_SCSI_STATUS_TASK_SET_FULL)) {\r\nstatus = MPI_IOCSTATUS_SUCCESS;\r\n}\r\nif (scsi_state & MPI_SCSI_STATE_AUTOSENSE_VALID)\r\nmptscsih_copy_sense_data(sc, hd, mf, pScsiReply);\r\nif (scsi_state & MPI_SCSI_STATE_RESPONSE_INFO_VALID &&\r\npScsiReply->ResponseInfo) {\r\nprintk(MYIOC_s_NOTE_FMT "[%d:%d:%d:%d] "\r\n"FCP_ResponseInfo=%08xh\n", ioc->name,\r\nsc->device->host->host_no, sc->device->channel,\r\nsc->device->id, sc->device->lun,\r\nle32_to_cpu(pScsiReply->ResponseInfo));\r\n}\r\nswitch(status) {\r\ncase MPI_IOCSTATUS_BUSY:\r\ncase MPI_IOCSTATUS_INSUFFICIENT_RESOURCES:\r\nsc->result = SAM_STAT_BUSY;\r\nbreak;\r\ncase MPI_IOCSTATUS_SCSI_INVALID_BUS:\r\ncase MPI_IOCSTATUS_SCSI_INVALID_TARGETID:\r\nsc->result = DID_BAD_TARGET << 16;\r\nbreak;\r\ncase MPI_IOCSTATUS_SCSI_DEVICE_NOT_THERE:\r\nif (ioc->bus_type != FC)\r\nsc->result = DID_NO_CONNECT << 16;\r\nelse\r\nsc->result = DID_REQUEUE << 16;\r\nif (hd->sel_timeout[pScsiReq->TargetID] < 0xFFFF)\r\nhd->sel_timeout[pScsiReq->TargetID]++;\r\nvdevice = sc->device->hostdata;\r\nif (!vdevice)\r\nbreak;\r\nvtarget = vdevice->vtarget;\r\nif (vtarget->tflags & MPT_TARGET_FLAGS_LED_ON) {\r\nmptscsih_issue_sep_command(ioc, vtarget,\r\nMPI_SEP_REQ_SLOTSTATUS_UNCONFIGURED);\r\nvtarget->tflags &= ~MPT_TARGET_FLAGS_LED_ON;\r\n}\r\nbreak;\r\ncase MPI_IOCSTATUS_SCSI_IOC_TERMINATED:\r\nif ( ioc->bus_type == SAS ) {\r\nu16 ioc_status =\r\nle16_to_cpu(pScsiReply->IOCStatus);\r\nif ((ioc_status &\r\nMPI_IOCSTATUS_FLAG_LOG_INFO_AVAILABLE)\r\n&&\r\n((log_info & SAS_LOGINFO_MASK) ==\r\nSAS_LOGINFO_NEXUS_LOSS)) {\r\nVirtDevice *vdevice =\r\nsc->device->hostdata;\r\nif (vdevice && vdevice->\r\nvtarget &&\r\nvdevice->vtarget->\r\nraidVolume)\r\nprintk(KERN_INFO\r\n"Skipping Raid Volume"\r\n"for inDMD\n");\r\nelse if (vdevice &&\r\nvdevice->vtarget)\r\nvdevice->vtarget->\r\ninDMD = 1;\r\nsc->result =\r\n(DID_TRANSPORT_DISRUPTED\r\n<< 16);\r\nbreak;\r\n}\r\n} else if (ioc->bus_type == FC) {\r\nsc->result = DID_ERROR << 16;\r\nbreak;\r\n}\r\ncase MPI_IOCSTATUS_SCSI_TASK_TERMINATED:\r\nsc->result = DID_RESET << 16;\r\nbreak;\r\ncase MPI_IOCSTATUS_SCSI_EXT_TERMINATED:\r\nif (ioc->bus_type == FC)\r\nsc->result = DID_ERROR << 16;\r\nelse\r\nsc->result = DID_RESET << 16;\r\nbreak;\r\ncase MPI_IOCSTATUS_SCSI_RESIDUAL_MISMATCH:\r\nscsi_set_resid(sc, scsi_bufflen(sc) - xfer_cnt);\r\nif((xfer_cnt==0)||(sc->underflow > xfer_cnt))\r\nsc->result=DID_SOFT_ERROR << 16;\r\nelse\r\nsc->result = (DID_OK << 16) | scsi_status;\r\ndreplyprintk(ioc, printk(MYIOC_s_DEBUG_FMT\r\n"RESIDUAL_MISMATCH: result=%x on channel=%d id=%d\n",\r\nioc->name, sc->result, sc->device->channel, sc->device->id));\r\nbreak;\r\ncase MPI_IOCSTATUS_SCSI_DATA_UNDERRUN:\r\nsc->result = (DID_OK << 16) | scsi_status;\r\nif (!(scsi_state & MPI_SCSI_STATE_AUTOSENSE_VALID)) {\r\nif (ioc->bus_type == SPI) {\r\nif ((pScsiReq->CDB[0] == READ_6 && ((pScsiReq->CDB[1] & 0x02) == 0)) ||\r\npScsiReq->CDB[0] == READ_10 ||\r\npScsiReq->CDB[0] == READ_12 ||\r\n(pScsiReq->CDB[0] == READ_16 &&\r\n((pScsiReq->CDB[1] & 0x02) == 0)) ||\r\npScsiReq->CDB[0] == VERIFY ||\r\npScsiReq->CDB[0] == VERIFY_16) {\r\nif (scsi_bufflen(sc) !=\r\nxfer_cnt) {\r\nsc->result =\r\nDID_SOFT_ERROR << 16;\r\nprintk(KERN_WARNING "Errata"\r\n"on LSI53C1030 occurred."\r\n"sc->req_bufflen=0x%02x,"\r\n"xfer_cnt=0x%02x\n",\r\nscsi_bufflen(sc),\r\nxfer_cnt);\r\n}\r\n}\r\n}\r\nif (xfer_cnt < sc->underflow) {\r\nif (scsi_status == SAM_STAT_BUSY)\r\nsc->result = SAM_STAT_BUSY;\r\nelse\r\nsc->result = DID_SOFT_ERROR << 16;\r\n}\r\nif (scsi_state & (MPI_SCSI_STATE_AUTOSENSE_FAILED | MPI_SCSI_STATE_NO_SCSI_STATUS)) {\r\nsc->result = DID_SOFT_ERROR << 16;\r\n}\r\nelse if (scsi_state & MPI_SCSI_STATE_TERMINATED) {\r\nsc->result = DID_RESET << 16;\r\n}\r\n}\r\ndreplyprintk(ioc, printk(MYIOC_s_DEBUG_FMT\r\n" sc->underflow={report ERR if < %02xh bytes xfer'd}\n",\r\nioc->name, sc->underflow));\r\ndreplyprintk(ioc, printk(MYIOC_s_DEBUG_FMT\r\n" ActBytesXferd=%02xh\n", ioc->name, xfer_cnt));\r\nif (scsi_status == MPI_SCSI_STATUS_TASK_SET_FULL)\r\nmptscsih_report_queue_full(sc, pScsiReply, pScsiReq);\r\nbreak;\r\ncase MPI_IOCSTATUS_SCSI_DATA_OVERRUN:\r\nscsi_set_resid(sc, 0);\r\ncase MPI_IOCSTATUS_SCSI_RECOVERED_ERROR:\r\ncase MPI_IOCSTATUS_SUCCESS:\r\nsc->result = (DID_OK << 16) | scsi_status;\r\nif (scsi_state == 0) {\r\n;\r\n} else if (scsi_state &\r\nMPI_SCSI_STATE_AUTOSENSE_VALID) {\r\nif ((ioc->bus_type == SPI) &&\r\n(sc->sense_buffer[2] & 0x20)) {\r\nu32 difftransfer;\r\ndifftransfer =\r\nsc->sense_buffer[3] << 24 |\r\nsc->sense_buffer[4] << 16 |\r\nsc->sense_buffer[5] << 8 |\r\nsc->sense_buffer[6];\r\nif (((sc->sense_buffer[3] & 0x80) ==\r\n0x80) && (scsi_bufflen(sc)\r\n!= xfer_cnt)) {\r\nsc->sense_buffer[2] =\r\nMEDIUM_ERROR;\r\nsc->sense_buffer[12] = 0xff;\r\nsc->sense_buffer[13] = 0xff;\r\nprintk(KERN_WARNING"Errata"\r\n"on LSI53C1030 occurred."\r\n"sc->req_bufflen=0x%02x,"\r\n"xfer_cnt=0x%02x\n" ,\r\nscsi_bufflen(sc),\r\nxfer_cnt);\r\n}\r\nif (((sc->sense_buffer[3] & 0x80)\r\n!= 0x80) &&\r\n(scsi_bufflen(sc) !=\r\nxfer_cnt + difftransfer)) {\r\nsc->sense_buffer[2] =\r\nMEDIUM_ERROR;\r\nsc->sense_buffer[12] = 0xff;\r\nsc->sense_buffer[13] = 0xff;\r\nprintk(KERN_WARNING\r\n"Errata on LSI53C1030 occurred"\r\n"sc->req_bufflen=0x%02x,"\r\n" xfer_cnt=0x%02x,"\r\n"difftransfer=0x%02x\n",\r\nscsi_bufflen(sc),\r\nxfer_cnt,\r\ndifftransfer);\r\n}\r\n}\r\nif (pScsiReply->SCSIStatus == MPI_SCSI_STATUS_TASK_SET_FULL)\r\nmptscsih_report_queue_full(sc, pScsiReply, pScsiReq);\r\n}\r\nelse if (scsi_state &\r\n(MPI_SCSI_STATE_AUTOSENSE_FAILED | MPI_SCSI_STATE_NO_SCSI_STATUS)\r\n) {\r\nsc->result = DID_SOFT_ERROR << 16;\r\n}\r\nelse if (scsi_state & MPI_SCSI_STATE_TERMINATED) {\r\nsc->result = DID_RESET << 16;\r\n}\r\nelse if (scsi_state & MPI_SCSI_STATE_QUEUE_TAG_REJECTED) {\r\n}\r\nif (sc->result == MPI_SCSI_STATUS_TASK_SET_FULL)\r\nmptscsih_report_queue_full(sc, pScsiReply, pScsiReq);\r\nbreak;\r\ncase MPI_IOCSTATUS_SCSI_PROTOCOL_ERROR:\r\nsc->result = DID_SOFT_ERROR << 16;\r\nbreak;\r\ncase MPI_IOCSTATUS_INVALID_FUNCTION:\r\ncase MPI_IOCSTATUS_INVALID_SGL:\r\ncase MPI_IOCSTATUS_INTERNAL_ERROR:\r\ncase MPI_IOCSTATUS_RESERVED:\r\ncase MPI_IOCSTATUS_INVALID_FIELD:\r\ncase MPI_IOCSTATUS_INVALID_STATE:\r\ncase MPI_IOCSTATUS_SCSI_IO_DATA_ERROR:\r\ncase MPI_IOCSTATUS_SCSI_TASK_MGMT_FAILED:\r\ndefault:\r\nsc->result = DID_SOFT_ERROR << 16;\r\nbreak;\r\n}\r\n#ifdef CONFIG_FUSION_LOGGING\r\nif (sc->result && (ioc->debug_level & MPT_DEBUG_REPLY))\r\nmptscsih_info_scsiio(ioc, sc, pScsiReply);\r\n#endif\r\n}\r\nout:\r\nscsi_dma_unmap(sc);\r\nsc->scsi_done(sc);\r\nmptscsih_freeChainBuffers(ioc, req_idx);\r\nreturn 1;\r\n}\r\nvoid\r\nmptscsih_flush_running_cmds(MPT_SCSI_HOST *hd)\r\n{\r\nMPT_ADAPTER *ioc = hd->ioc;\r\nstruct scsi_cmnd *sc;\r\nSCSIIORequest_t *mf = NULL;\r\nint ii;\r\nint channel, id;\r\nfor (ii= 0; ii < ioc->req_depth; ii++) {\r\nsc = mptscsih_getclear_scsi_lookup(ioc, ii);\r\nif (!sc)\r\ncontinue;\r\nmf = (SCSIIORequest_t *)MPT_INDEX_2_MFPTR(ioc, ii);\r\nif (!mf)\r\ncontinue;\r\nchannel = mf->Bus;\r\nid = mf->TargetID;\r\nmptscsih_freeChainBuffers(ioc, ii);\r\nmpt_free_msg_frame(ioc, (MPT_FRAME_HDR *)mf);\r\nif ((unsigned char *)mf != sc->host_scribble)\r\ncontinue;\r\nscsi_dma_unmap(sc);\r\nsc->result = DID_RESET << 16;\r\nsc->host_scribble = NULL;\r\ndtmprintk(ioc, sdev_printk(KERN_INFO, sc->device, MYIOC_s_FMT\r\n"completing cmds: fw_channel %d, fw_id %d, sc=%p, mf = %p, "\r\n"idx=%x\n", ioc->name, channel, id, sc, mf, ii));\r\nsc->scsi_done(sc);\r\n}\r\n}\r\nstatic void\r\nmptscsih_search_running_cmds(MPT_SCSI_HOST *hd, VirtDevice *vdevice)\r\n{\r\nSCSIIORequest_t *mf = NULL;\r\nint ii;\r\nstruct scsi_cmnd *sc;\r\nstruct scsi_lun lun;\r\nMPT_ADAPTER *ioc = hd->ioc;\r\nunsigned long flags;\r\nspin_lock_irqsave(&ioc->scsi_lookup_lock, flags);\r\nfor (ii = 0; ii < ioc->req_depth; ii++) {\r\nif ((sc = ioc->ScsiLookup[ii]) != NULL) {\r\nmf = (SCSIIORequest_t *)MPT_INDEX_2_MFPTR(ioc, ii);\r\nif (mf == NULL)\r\ncontinue;\r\nif (vdevice->vtarget->tflags &\r\nMPT_TARGET_FLAGS_RAID_COMPONENT && mf->Function !=\r\nMPI_FUNCTION_RAID_SCSI_IO_PASSTHROUGH)\r\ncontinue;\r\nint_to_scsilun(vdevice->lun, &lun);\r\nif ((mf->Bus != vdevice->vtarget->channel) ||\r\n(mf->TargetID != vdevice->vtarget->id) ||\r\nmemcmp(lun.scsi_lun, mf->LUN, 8))\r\ncontinue;\r\nif ((unsigned char *)mf != sc->host_scribble)\r\ncontinue;\r\nioc->ScsiLookup[ii] = NULL;\r\nspin_unlock_irqrestore(&ioc->scsi_lookup_lock, flags);\r\nmptscsih_freeChainBuffers(ioc, ii);\r\nmpt_free_msg_frame(ioc, (MPT_FRAME_HDR *)mf);\r\nscsi_dma_unmap(sc);\r\nsc->host_scribble = NULL;\r\nsc->result = DID_NO_CONNECT << 16;\r\ndtmprintk(ioc, sdev_printk(KERN_INFO, sc->device,\r\nMYIOC_s_FMT "completing cmds: fw_channel %d, "\r\n"fw_id %d, sc=%p, mf = %p, idx=%x\n", ioc->name,\r\nvdevice->vtarget->channel, vdevice->vtarget->id,\r\nsc, mf, ii));\r\nsc->scsi_done(sc);\r\nspin_lock_irqsave(&ioc->scsi_lookup_lock, flags);\r\n}\r\n}\r\nspin_unlock_irqrestore(&ioc->scsi_lookup_lock, flags);\r\nreturn;\r\n}\r\nstatic void\r\nmptscsih_report_queue_full(struct scsi_cmnd *sc, SCSIIOReply_t *pScsiReply, SCSIIORequest_t *pScsiReq)\r\n{\r\nlong time = jiffies;\r\nMPT_SCSI_HOST *hd;\r\nMPT_ADAPTER *ioc;\r\nif (sc->device == NULL)\r\nreturn;\r\nif (sc->device->host == NULL)\r\nreturn;\r\nif ((hd = shost_priv(sc->device->host)) == NULL)\r\nreturn;\r\nioc = hd->ioc;\r\nif (time - hd->last_queue_full > 10 * HZ) {\r\ndprintk(ioc, printk(MYIOC_s_WARN_FMT "Device (%d:%d:%d) reported QUEUE_FULL!\n",\r\nioc->name, 0, sc->device->id, sc->device->lun));\r\nhd->last_queue_full = time;\r\n}\r\n}\r\nvoid\r\nmptscsih_remove(struct pci_dev *pdev)\r\n{\r\nMPT_ADAPTER *ioc = pci_get_drvdata(pdev);\r\nstruct Scsi_Host *host = ioc->sh;\r\nMPT_SCSI_HOST *hd;\r\nint sz1;\r\nscsi_remove_host(host);\r\nif((hd = shost_priv(host)) == NULL)\r\nreturn;\r\nmptscsih_shutdown(pdev);\r\nsz1=0;\r\nif (ioc->ScsiLookup != NULL) {\r\nsz1 = ioc->req_depth * sizeof(void *);\r\nkfree(ioc->ScsiLookup);\r\nioc->ScsiLookup = NULL;\r\n}\r\ndprintk(ioc, printk(MYIOC_s_DEBUG_FMT\r\n"Free'd ScsiLookup (%d) memory\n",\r\nioc->name, sz1));\r\nkfree(hd->info_kbuf);\r\nioc->sh = NULL;\r\nscsi_host_put(host);\r\nmpt_detach(pdev);\r\n}\r\nvoid\r\nmptscsih_shutdown(struct pci_dev *pdev)\r\n{\r\n}\r\nint\r\nmptscsih_suspend(struct pci_dev *pdev, pm_message_t state)\r\n{\r\nMPT_ADAPTER *ioc = pci_get_drvdata(pdev);\r\nscsi_block_requests(ioc->sh);\r\nflush_scheduled_work();\r\nmptscsih_shutdown(pdev);\r\nreturn mpt_suspend(pdev,state);\r\n}\r\nint\r\nmptscsih_resume(struct pci_dev *pdev)\r\n{\r\nMPT_ADAPTER *ioc = pci_get_drvdata(pdev);\r\nint rc;\r\nrc = mpt_resume(pdev);\r\nscsi_unblock_requests(ioc->sh);\r\nreturn rc;\r\n}\r\nconst char *\r\nmptscsih_info(struct Scsi_Host *SChost)\r\n{\r\nMPT_SCSI_HOST *h;\r\nint size = 0;\r\nh = shost_priv(SChost);\r\nif (h) {\r\nif (h->info_kbuf == NULL)\r\nif ((h->info_kbuf = kmalloc(0x1000 , GFP_KERNEL)) == NULL)\r\nreturn h->info_kbuf;\r\nh->info_kbuf[0] = '\0';\r\nmpt_print_ioc_summary(h->ioc, h->info_kbuf, &size, 0, 0);\r\nh->info_kbuf[size-1] = '\0';\r\n}\r\nreturn h->info_kbuf;\r\n}\r\nstatic void\r\nmptscsih_copy_mem_info(struct info_str *info, char *data, int len)\r\n{\r\nif (info->pos + len > info->length)\r\nlen = info->length - info->pos;\r\nif (info->pos + len < info->offset) {\r\ninfo->pos += len;\r\nreturn;\r\n}\r\nif (info->pos < info->offset) {\r\ndata += (info->offset - info->pos);\r\nlen -= (info->offset - info->pos);\r\n}\r\nif (len > 0) {\r\nmemcpy(info->buffer + info->pos, data, len);\r\ninfo->pos += len;\r\n}\r\n}\r\nstatic int\r\nmptscsih_copy_info(struct info_str *info, char *fmt, ...)\r\n{\r\nva_list args;\r\nchar buf[81];\r\nint len;\r\nva_start(args, fmt);\r\nlen = vsprintf(buf, fmt, args);\r\nva_end(args);\r\nmptscsih_copy_mem_info(info, buf, len);\r\nreturn len;\r\n}\r\nstatic int\r\nmptscsih_host_info(MPT_ADAPTER *ioc, char *pbuf, off_t offset, int len)\r\n{\r\nstruct info_str info;\r\ninfo.buffer = pbuf;\r\ninfo.length = len;\r\ninfo.offset = offset;\r\ninfo.pos = 0;\r\nmptscsih_copy_info(&info, "%s: %s, ", ioc->name, ioc->prod_name);\r\nmptscsih_copy_info(&info, "%s%08xh, ", MPT_FW_REV_MAGIC_ID_STRING, ioc->facts.FWVersion.Word);\r\nmptscsih_copy_info(&info, "Ports=%d, ", ioc->facts.NumberOfPorts);\r\nmptscsih_copy_info(&info, "MaxQ=%d\n", ioc->req_depth);\r\nreturn ((info.pos > info.offset) ? info.pos - info.offset : 0);\r\n}\r\nint\r\nmptscsih_proc_info(struct Scsi_Host *host, char *buffer, char **start, off_t offset,\r\nint length, int func)\r\n{\r\nMPT_SCSI_HOST *hd = shost_priv(host);\r\nMPT_ADAPTER *ioc = hd->ioc;\r\nint size = 0;\r\nif (func) {\r\n} else {\r\nif (start)\r\n*start = buffer;\r\nsize = mptscsih_host_info(ioc, buffer, offset, length);\r\n}\r\nreturn size;\r\n}\r\nint\r\nmptscsih_qcmd(struct scsi_cmnd *SCpnt, void (*done)(struct scsi_cmnd *))\r\n{\r\nMPT_SCSI_HOST *hd;\r\nMPT_FRAME_HDR *mf;\r\nSCSIIORequest_t *pScsiReq;\r\nVirtDevice *vdevice = SCpnt->device->hostdata;\r\nu32 datalen;\r\nu32 scsictl;\r\nu32 scsidir;\r\nu32 cmd_len;\r\nint my_idx;\r\nint ii;\r\nMPT_ADAPTER *ioc;\r\nhd = shost_priv(SCpnt->device->host);\r\nioc = hd->ioc;\r\nSCpnt->scsi_done = done;\r\ndmfprintk(ioc, printk(MYIOC_s_DEBUG_FMT "qcmd: SCpnt=%p, done()=%p\n",\r\nioc->name, SCpnt, done));\r\nif (ioc->taskmgmt_quiesce_io)\r\nreturn SCSI_MLQUEUE_HOST_BUSY;\r\nif ((mf = mpt_get_msg_frame(ioc->DoneCtx, ioc)) == NULL) {\r\ndprintk(ioc, printk(MYIOC_s_WARN_FMT "QueueCmd, no msg frames!!\n",\r\nioc->name));\r\nreturn SCSI_MLQUEUE_HOST_BUSY;\r\n}\r\npScsiReq = (SCSIIORequest_t *) mf;\r\nmy_idx = le16_to_cpu(mf->u.frame.hwhdr.msgctxu.fld.req_idx);\r\nADD_INDEX_LOG(my_idx);\r\nif (SCpnt->sc_data_direction == DMA_FROM_DEVICE) {\r\ndatalen = scsi_bufflen(SCpnt);\r\nscsidir = MPI_SCSIIO_CONTROL_READ;\r\n} else if (SCpnt->sc_data_direction == DMA_TO_DEVICE) {\r\ndatalen = scsi_bufflen(SCpnt);\r\nscsidir = MPI_SCSIIO_CONTROL_WRITE;\r\n} else {\r\ndatalen = 0;\r\nscsidir = MPI_SCSIIO_CONTROL_NODATATRANSFER;\r\n}\r\nif (vdevice\r\n&& (vdevice->vtarget->tflags & MPT_TARGET_FLAGS_Q_YES)\r\n&& (SCpnt->device->tagged_supported)) {\r\nscsictl = scsidir | MPI_SCSIIO_CONTROL_SIMPLEQ;\r\nif (SCpnt->request && SCpnt->request->ioprio) {\r\nif (((SCpnt->request->ioprio & 0x7) == 1) ||\r\n!(SCpnt->request->ioprio & 0x7))\r\nscsictl |= MPI_SCSIIO_CONTROL_HEADOFQ;\r\n}\r\n} else\r\nscsictl = scsidir | MPI_SCSIIO_CONTROL_UNTAGGED;\r\npScsiReq->TargetID = (u8) vdevice->vtarget->id;\r\npScsiReq->Bus = vdevice->vtarget->channel;\r\npScsiReq->ChainOffset = 0;\r\nif (vdevice->vtarget->tflags & MPT_TARGET_FLAGS_RAID_COMPONENT)\r\npScsiReq->Function = MPI_FUNCTION_RAID_SCSI_IO_PASSTHROUGH;\r\nelse\r\npScsiReq->Function = MPI_FUNCTION_SCSI_IO_REQUEST;\r\npScsiReq->CDBLength = SCpnt->cmd_len;\r\npScsiReq->SenseBufferLength = MPT_SENSE_BUFFER_SIZE;\r\npScsiReq->Reserved = 0;\r\npScsiReq->MsgFlags = mpt_msg_flags(ioc);\r\nint_to_scsilun(SCpnt->device->lun, (struct scsi_lun *)pScsiReq->LUN);\r\npScsiReq->Control = cpu_to_le32(scsictl);\r\ncmd_len = SCpnt->cmd_len;\r\nfor (ii=0; ii < cmd_len; ii++)\r\npScsiReq->CDB[ii] = SCpnt->cmnd[ii];\r\nfor (ii=cmd_len; ii < 16; ii++)\r\npScsiReq->CDB[ii] = 0;\r\npScsiReq->DataLength = cpu_to_le32(datalen);\r\npScsiReq->SenseBufferLowAddr = cpu_to_le32(ioc->sense_buf_low_dma\r\n+ (my_idx * MPT_SENSE_BUFFER_ALLOC));\r\nif (datalen == 0) {\r\nioc->add_sge((char *)&pScsiReq->SGL,\r\nMPT_SGE_FLAGS_SSIMPLE_READ | 0,\r\n(dma_addr_t) -1);\r\n} else {\r\nif (mptscsih_AddSGE(ioc, SCpnt, pScsiReq, my_idx) != SUCCESS)\r\ngoto fail;\r\n}\r\nSCpnt->host_scribble = (unsigned char *)mf;\r\nmptscsih_set_scsi_lookup(ioc, my_idx, SCpnt);\r\nmpt_put_msg_frame(ioc->DoneCtx, ioc, mf);\r\ndmfprintk(ioc, printk(MYIOC_s_DEBUG_FMT "Issued SCSI cmd (%p) mf=%p idx=%d\n",\r\nioc->name, SCpnt, mf, my_idx));\r\nDBG_DUMP_REQUEST_FRAME(ioc, (u32 *)mf);\r\nreturn 0;\r\nfail:\r\nmptscsih_freeChainBuffers(ioc, my_idx);\r\nmpt_free_msg_frame(ioc, mf);\r\nreturn SCSI_MLQUEUE_HOST_BUSY;\r\n}\r\nstatic void\r\nmptscsih_freeChainBuffers(MPT_ADAPTER *ioc, int req_idx)\r\n{\r\nMPT_FRAME_HDR *chain;\r\nunsigned long flags;\r\nint chain_idx;\r\nint next;\r\nchain_idx = ioc->ReqToChain[req_idx];\r\nioc->ReqToChain[req_idx] = MPT_HOST_NO_CHAIN;\r\nwhile (chain_idx != MPT_HOST_NO_CHAIN) {\r\nnext = ioc->ChainToChain[chain_idx];\r\nioc->ChainToChain[chain_idx] = MPT_HOST_NO_CHAIN;\r\nchain = (MPT_FRAME_HDR *) (ioc->ChainBuffer\r\n+ (chain_idx * ioc->req_sz));\r\nspin_lock_irqsave(&ioc->FreeQlock, flags);\r\nlist_add_tail(&chain->u.frame.linkage.list, &ioc->FreeChainQ);\r\nspin_unlock_irqrestore(&ioc->FreeQlock, flags);\r\ndmfprintk(ioc, printk(MYIOC_s_DEBUG_FMT "FreeChainBuffers (index %d)\n",\r\nioc->name, chain_idx));\r\nchain_idx = next;\r\n}\r\nreturn;\r\n}\r\nint\r\nmptscsih_IssueTaskMgmt(MPT_SCSI_HOST *hd, u8 type, u8 channel, u8 id, int lun,\r\nint ctx2abort, ulong timeout)\r\n{\r\nMPT_FRAME_HDR *mf;\r\nSCSITaskMgmt_t *pScsiTm;\r\nint ii;\r\nint retval;\r\nMPT_ADAPTER *ioc = hd->ioc;\r\nunsigned long timeleft;\r\nu8 issue_hard_reset;\r\nu32 ioc_raw_state;\r\nunsigned long time_count;\r\nissue_hard_reset = 0;\r\nioc_raw_state = mpt_GetIocState(ioc, 0);\r\nif ((ioc_raw_state & MPI_IOC_STATE_MASK) != MPI_IOC_STATE_OPERATIONAL) {\r\nprintk(MYIOC_s_WARN_FMT\r\n"TaskMgmt type=%x: IOC Not operational (0x%x)!\n",\r\nioc->name, type, ioc_raw_state);\r\nprintk(MYIOC_s_WARN_FMT "Issuing HardReset from %s!!\n",\r\nioc->name, __func__);\r\nif (mpt_HardResetHandler(ioc, CAN_SLEEP) < 0)\r\nprintk(MYIOC_s_WARN_FMT "TaskMgmt HardReset "\r\n"FAILED!!\n", ioc->name);\r\nreturn 0;\r\n}\r\nif (!((ioc->facts.IOCCapabilities & MPI_IOCFACTS_CAPABILITY_HIGH_PRI_Q)\r\n&& (ioc->facts.MsgVersion >= MPI_VERSION_01_05)) &&\r\n(ioc_raw_state & MPI_DOORBELL_ACTIVE)) {\r\nprintk(MYIOC_s_WARN_FMT\r\n"TaskMgmt type=%x: ioc_state: "\r\n"DOORBELL_ACTIVE (0x%x)!\n",\r\nioc->name, type, ioc_raw_state);\r\nreturn FAILED;\r\n}\r\nmutex_lock(&ioc->taskmgmt_cmds.mutex);\r\nif (mpt_set_taskmgmt_in_progress_flag(ioc) != 0) {\r\nmf = NULL;\r\nretval = FAILED;\r\ngoto out;\r\n}\r\nif ((mf = mpt_get_msg_frame(ioc->TaskCtx, ioc)) == NULL) {\r\ndfailprintk(ioc, printk(MYIOC_s_ERR_FMT\r\n"TaskMgmt no msg frames!!\n", ioc->name));\r\nretval = FAILED;\r\nmpt_clear_taskmgmt_in_progress_flag(ioc);\r\ngoto out;\r\n}\r\ndtmprintk(ioc, printk(MYIOC_s_DEBUG_FMT "TaskMgmt request (mf=%p)\n",\r\nioc->name, mf));\r\npScsiTm = (SCSITaskMgmt_t *) mf;\r\npScsiTm->TargetID = id;\r\npScsiTm->Bus = channel;\r\npScsiTm->ChainOffset = 0;\r\npScsiTm->Function = MPI_FUNCTION_SCSI_TASK_MGMT;\r\npScsiTm->Reserved = 0;\r\npScsiTm->TaskType = type;\r\npScsiTm->Reserved1 = 0;\r\npScsiTm->MsgFlags = (type == MPI_SCSITASKMGMT_TASKTYPE_RESET_BUS)\r\n? MPI_SCSITASKMGMT_MSGFLAGS_LIPRESET_RESET_OPTION : 0;\r\nint_to_scsilun(lun, (struct scsi_lun *)pScsiTm->LUN);\r\nfor (ii=0; ii < 7; ii++)\r\npScsiTm->Reserved2[ii] = 0;\r\npScsiTm->TaskMsgContext = ctx2abort;\r\ndtmprintk(ioc, printk(MYIOC_s_DEBUG_FMT "TaskMgmt: ctx2abort (0x%08x) "\r\n"task_type = 0x%02X, timeout = %ld\n", ioc->name, ctx2abort,\r\ntype, timeout));\r\nDBG_DUMP_TM_REQUEST_FRAME(ioc, (u32 *)pScsiTm);\r\nINITIALIZE_MGMT_STATUS(ioc->taskmgmt_cmds.status)\r\ntime_count = jiffies;\r\nif ((ioc->facts.IOCCapabilities & MPI_IOCFACTS_CAPABILITY_HIGH_PRI_Q) &&\r\n(ioc->facts.MsgVersion >= MPI_VERSION_01_05))\r\nmpt_put_msg_frame_hi_pri(ioc->TaskCtx, ioc, mf);\r\nelse {\r\nretval = mpt_send_handshake_request(ioc->TaskCtx, ioc,\r\nsizeof(SCSITaskMgmt_t), (u32*)pScsiTm, CAN_SLEEP);\r\nif (retval) {\r\ndfailprintk(ioc, printk(MYIOC_s_ERR_FMT\r\n"TaskMgmt handshake FAILED!(mf=%p, rc=%d) \n",\r\nioc->name, mf, retval));\r\nmpt_free_msg_frame(ioc, mf);\r\nmpt_clear_taskmgmt_in_progress_flag(ioc);\r\ngoto out;\r\n}\r\n}\r\ntimeleft = wait_for_completion_timeout(&ioc->taskmgmt_cmds.done,\r\ntimeout*HZ);\r\nif (!(ioc->taskmgmt_cmds.status & MPT_MGMT_STATUS_COMMAND_GOOD)) {\r\nretval = FAILED;\r\ndtmprintk(ioc, printk(MYIOC_s_ERR_FMT\r\n"TaskMgmt TIMED OUT!(mf=%p)\n", ioc->name, mf));\r\nmpt_clear_taskmgmt_in_progress_flag(ioc);\r\nif (ioc->taskmgmt_cmds.status & MPT_MGMT_STATUS_DID_IOCRESET)\r\ngoto out;\r\nissue_hard_reset = 1;\r\ngoto out;\r\n}\r\nretval = mptscsih_taskmgmt_reply(ioc, type,\r\n(SCSITaskMgmtReply_t *) ioc->taskmgmt_cmds.reply);\r\ndtmprintk(ioc, printk(MYIOC_s_DEBUG_FMT\r\n"TaskMgmt completed (%d seconds)\n",\r\nioc->name, jiffies_to_msecs(jiffies - time_count)/1000));\r\nout:\r\nCLEAR_MGMT_STATUS(ioc->taskmgmt_cmds.status)\r\nif (issue_hard_reset) {\r\nprintk(MYIOC_s_WARN_FMT\r\n"Issuing Reset from %s!! doorbell=0x%08x\n",\r\nioc->name, __func__, mpt_GetIocState(ioc, 0));\r\nretval = (ioc->bus_type == SAS) ?\r\nmpt_HardResetHandler(ioc, CAN_SLEEP) :\r\nmpt_Soft_Hard_ResetHandler(ioc, CAN_SLEEP);\r\nmpt_free_msg_frame(ioc, mf);\r\n}\r\nretval = (retval == 0) ? 0 : FAILED;\r\nmutex_unlock(&ioc->taskmgmt_cmds.mutex);\r\nreturn retval;\r\n}\r\nstatic int\r\nmptscsih_get_tm_timeout(MPT_ADAPTER *ioc)\r\n{\r\nswitch (ioc->bus_type) {\r\ncase FC:\r\nreturn 40;\r\ncase SAS:\r\nreturn 30;\r\ncase SPI:\r\ndefault:\r\nreturn 10;\r\n}\r\n}\r\nint\r\nmptscsih_abort(struct scsi_cmnd * SCpnt)\r\n{\r\nMPT_SCSI_HOST *hd;\r\nMPT_FRAME_HDR *mf;\r\nu32 ctx2abort;\r\nint scpnt_idx;\r\nint retval;\r\nVirtDevice *vdevice;\r\nMPT_ADAPTER *ioc;\r\nif ((hd = shost_priv(SCpnt->device->host)) == NULL) {\r\nSCpnt->result = DID_RESET << 16;\r\nSCpnt->scsi_done(SCpnt);\r\nprintk(KERN_ERR MYNAM ": task abort: "\r\n"can't locate host! (sc=%p)\n", SCpnt);\r\nreturn FAILED;\r\n}\r\nioc = hd->ioc;\r\nprintk(MYIOC_s_INFO_FMT "attempting task abort! (sc=%p)\n",\r\nioc->name, SCpnt);\r\nscsi_print_command(SCpnt);\r\nvdevice = SCpnt->device->hostdata;\r\nif (!vdevice || !vdevice->vtarget) {\r\ndtmprintk(ioc, printk(MYIOC_s_DEBUG_FMT\r\n"task abort: device has been deleted (sc=%p)\n",\r\nioc->name, SCpnt));\r\nSCpnt->result = DID_NO_CONNECT << 16;\r\nSCpnt->scsi_done(SCpnt);\r\nretval = SUCCESS;\r\ngoto out;\r\n}\r\nif (vdevice->vtarget->tflags & MPT_TARGET_FLAGS_RAID_COMPONENT) {\r\ndtmprintk(ioc, printk(MYIOC_s_DEBUG_FMT\r\n"task abort: hidden raid component (sc=%p)\n",\r\nioc->name, SCpnt));\r\nSCpnt->result = DID_RESET << 16;\r\nretval = FAILED;\r\ngoto out;\r\n}\r\nif (vdevice->vtarget->raidVolume) {\r\ndtmprintk(ioc, printk(MYIOC_s_DEBUG_FMT\r\n"task abort: raid volume (sc=%p)\n",\r\nioc->name, SCpnt));\r\nSCpnt->result = DID_RESET << 16;\r\nretval = FAILED;\r\ngoto out;\r\n}\r\nif ((scpnt_idx = SCPNT_TO_LOOKUP_IDX(ioc, SCpnt)) < 0) {\r\nSCpnt->result = DID_RESET << 16;\r\ndtmprintk(ioc, printk(MYIOC_s_DEBUG_FMT "task abort: "\r\n"Command not in the active list! (sc=%p)\n", ioc->name,\r\nSCpnt));\r\nretval = SUCCESS;\r\ngoto out;\r\n}\r\nif (ioc->timeouts < -1)\r\nioc->timeouts++;\r\nif (mpt_fwfault_debug)\r\nmpt_halt_firmware(ioc);\r\nmf = MPT_INDEX_2_MFPTR(ioc, scpnt_idx);\r\nctx2abort = mf->u.frame.hwhdr.msgctxu.MsgContext;\r\nretval = mptscsih_IssueTaskMgmt(hd,\r\nMPI_SCSITASKMGMT_TASKTYPE_ABORT_TASK,\r\nvdevice->vtarget->channel,\r\nvdevice->vtarget->id, vdevice->lun,\r\nctx2abort, mptscsih_get_tm_timeout(ioc));\r\nif (SCPNT_TO_LOOKUP_IDX(ioc, SCpnt) == scpnt_idx) {\r\ndtmprintk(ioc, printk(MYIOC_s_DEBUG_FMT\r\n"task abort: command still in active list! (sc=%p)\n",\r\nioc->name, SCpnt));\r\nretval = FAILED;\r\n} else {\r\ndtmprintk(ioc, printk(MYIOC_s_DEBUG_FMT\r\n"task abort: command cleared from active list! (sc=%p)\n",\r\nioc->name, SCpnt));\r\nretval = SUCCESS;\r\n}\r\nout:\r\nprintk(MYIOC_s_INFO_FMT "task abort: %s (rv=%04x) (sc=%p)\n",\r\nioc->name, ((retval == SUCCESS) ? "SUCCESS" : "FAILED"), retval,\r\nSCpnt);\r\nreturn retval;\r\n}\r\nint\r\nmptscsih_dev_reset(struct scsi_cmnd * SCpnt)\r\n{\r\nMPT_SCSI_HOST *hd;\r\nint retval;\r\nVirtDevice *vdevice;\r\nMPT_ADAPTER *ioc;\r\nif ((hd = shost_priv(SCpnt->device->host)) == NULL){\r\nprintk(KERN_ERR MYNAM ": target reset: "\r\n"Can't locate host! (sc=%p)\n", SCpnt);\r\nreturn FAILED;\r\n}\r\nioc = hd->ioc;\r\nprintk(MYIOC_s_INFO_FMT "attempting target reset! (sc=%p)\n",\r\nioc->name, SCpnt);\r\nscsi_print_command(SCpnt);\r\nvdevice = SCpnt->device->hostdata;\r\nif (!vdevice || !vdevice->vtarget) {\r\nretval = 0;\r\ngoto out;\r\n}\r\nif (vdevice->vtarget->tflags & MPT_TARGET_FLAGS_RAID_COMPONENT) {\r\nretval = FAILED;\r\ngoto out;\r\n}\r\nretval = mptscsih_IssueTaskMgmt(hd,\r\nMPI_SCSITASKMGMT_TASKTYPE_TARGET_RESET,\r\nvdevice->vtarget->channel,\r\nvdevice->vtarget->id, 0, 0,\r\nmptscsih_get_tm_timeout(ioc));\r\nout:\r\nprintk (MYIOC_s_INFO_FMT "target reset: %s (sc=%p)\n",\r\nioc->name, ((retval == 0) ? "SUCCESS" : "FAILED" ), SCpnt);\r\nif (retval == 0)\r\nreturn SUCCESS;\r\nelse\r\nreturn FAILED;\r\n}\r\nint\r\nmptscsih_bus_reset(struct scsi_cmnd * SCpnt)\r\n{\r\nMPT_SCSI_HOST *hd;\r\nint retval;\r\nVirtDevice *vdevice;\r\nMPT_ADAPTER *ioc;\r\nif ((hd = shost_priv(SCpnt->device->host)) == NULL){\r\nprintk(KERN_ERR MYNAM ": bus reset: "\r\n"Can't locate host! (sc=%p)\n", SCpnt);\r\nreturn FAILED;\r\n}\r\nioc = hd->ioc;\r\nprintk(MYIOC_s_INFO_FMT "attempting bus reset! (sc=%p)\n",\r\nioc->name, SCpnt);\r\nscsi_print_command(SCpnt);\r\nif (ioc->timeouts < -1)\r\nioc->timeouts++;\r\nvdevice = SCpnt->device->hostdata;\r\nif (!vdevice || !vdevice->vtarget)\r\nreturn SUCCESS;\r\nretval = mptscsih_IssueTaskMgmt(hd,\r\nMPI_SCSITASKMGMT_TASKTYPE_RESET_BUS,\r\nvdevice->vtarget->channel, 0, 0, 0,\r\nmptscsih_get_tm_timeout(ioc));\r\nprintk(MYIOC_s_INFO_FMT "bus reset: %s (sc=%p)\n",\r\nioc->name, ((retval == 0) ? "SUCCESS" : "FAILED" ), SCpnt);\r\nif (retval == 0)\r\nreturn SUCCESS;\r\nelse\r\nreturn FAILED;\r\n}\r\nint\r\nmptscsih_host_reset(struct scsi_cmnd *SCpnt)\r\n{\r\nMPT_SCSI_HOST * hd;\r\nint status = SUCCESS;\r\nMPT_ADAPTER *ioc;\r\nint retval;\r\nif ((hd = shost_priv(SCpnt->device->host)) == NULL){\r\nprintk(KERN_ERR MYNAM ": host reset: "\r\n"Can't locate host! (sc=%p)\n", SCpnt);\r\nreturn FAILED;\r\n}\r\nmptscsih_flush_running_cmds(hd);\r\nioc = hd->ioc;\r\nprintk(MYIOC_s_INFO_FMT "attempting host reset! (sc=%p)\n",\r\nioc->name, SCpnt);\r\nretval = mpt_Soft_Hard_ResetHandler(ioc, CAN_SLEEP);\r\nif (retval < 0)\r\nstatus = FAILED;\r\nelse\r\nstatus = SUCCESS;\r\nprintk(MYIOC_s_INFO_FMT "host reset: %s (sc=%p)\n",\r\nioc->name, ((retval == 0) ? "SUCCESS" : "FAILED" ), SCpnt);\r\nreturn status;\r\n}\r\nstatic int\r\nmptscsih_taskmgmt_reply(MPT_ADAPTER *ioc, u8 type,\r\nSCSITaskMgmtReply_t *pScsiTmReply)\r\n{\r\nu16 iocstatus;\r\nu32 termination_count;\r\nint retval;\r\nif (!(ioc->taskmgmt_cmds.status & MPT_MGMT_STATUS_RF_VALID)) {\r\nretval = FAILED;\r\ngoto out;\r\n}\r\nDBG_DUMP_TM_REPLY_FRAME(ioc, (u32 *)pScsiTmReply);\r\niocstatus = le16_to_cpu(pScsiTmReply->IOCStatus) & MPI_IOCSTATUS_MASK;\r\ntermination_count = le32_to_cpu(pScsiTmReply->TerminationCount);\r\ndtmprintk(ioc, printk(MYIOC_s_DEBUG_FMT\r\n"TaskMgmt fw_channel = %d, fw_id = %d, task_type = 0x%02X,\n"\r\n"\tiocstatus = 0x%04X, loginfo = 0x%08X, response_code = 0x%02X,\n"\r\n"\tterm_cmnds = %d\n", ioc->name, pScsiTmReply->Bus,\r\npScsiTmReply->TargetID, type, le16_to_cpu(pScsiTmReply->IOCStatus),\r\nle32_to_cpu(pScsiTmReply->IOCLogInfo), pScsiTmReply->ResponseCode,\r\ntermination_count));\r\nif (ioc->facts.MsgVersion >= MPI_VERSION_01_05 &&\r\npScsiTmReply->ResponseCode)\r\nmptscsih_taskmgmt_response_code(ioc,\r\npScsiTmReply->ResponseCode);\r\nif (iocstatus == MPI_IOCSTATUS_SUCCESS) {\r\nretval = 0;\r\ngoto out;\r\n}\r\nretval = FAILED;\r\nif (type == MPI_SCSITASKMGMT_TASKTYPE_ABORT_TASK) {\r\nif (termination_count == 1)\r\nretval = 0;\r\ngoto out;\r\n}\r\nif (iocstatus == MPI_IOCSTATUS_SCSI_TASK_TERMINATED ||\r\niocstatus == MPI_IOCSTATUS_SCSI_IOC_TERMINATED)\r\nretval = 0;\r\nout:\r\nreturn retval;\r\n}\r\nvoid\r\nmptscsih_taskmgmt_response_code(MPT_ADAPTER *ioc, u8 response_code)\r\n{\r\nchar *desc;\r\nswitch (response_code) {\r\ncase MPI_SCSITASKMGMT_RSP_TM_COMPLETE:\r\ndesc = "The task completed.";\r\nbreak;\r\ncase MPI_SCSITASKMGMT_RSP_INVALID_FRAME:\r\ndesc = "The IOC received an invalid frame status.";\r\nbreak;\r\ncase MPI_SCSITASKMGMT_RSP_TM_NOT_SUPPORTED:\r\ndesc = "The task type is not supported.";\r\nbreak;\r\ncase MPI_SCSITASKMGMT_RSP_TM_FAILED:\r\ndesc = "The requested task failed.";\r\nbreak;\r\ncase MPI_SCSITASKMGMT_RSP_TM_SUCCEEDED:\r\ndesc = "The task completed successfully.";\r\nbreak;\r\ncase MPI_SCSITASKMGMT_RSP_TM_INVALID_LUN:\r\ndesc = "The LUN request is invalid.";\r\nbreak;\r\ncase MPI_SCSITASKMGMT_RSP_IO_QUEUED_ON_IOC:\r\ndesc = "The task is in the IOC queue and has not been sent to target.";\r\nbreak;\r\ndefault:\r\ndesc = "unknown";\r\nbreak;\r\n}\r\nprintk(MYIOC_s_INFO_FMT "Response Code(0x%08x): F/W: %s\n",\r\nioc->name, response_code, desc);\r\n}\r\nint\r\nmptscsih_taskmgmt_complete(MPT_ADAPTER *ioc, MPT_FRAME_HDR *mf,\r\nMPT_FRAME_HDR *mr)\r\n{\r\ndtmprintk(ioc, printk(MYIOC_s_DEBUG_FMT\r\n"TaskMgmt completed (mf=%p, mr=%p)\n", ioc->name, mf, mr));\r\nioc->taskmgmt_cmds.status |= MPT_MGMT_STATUS_COMMAND_GOOD;\r\nif (!mr)\r\ngoto out;\r\nioc->taskmgmt_cmds.status |= MPT_MGMT_STATUS_RF_VALID;\r\nmemcpy(ioc->taskmgmt_cmds.reply, mr,\r\nmin(MPT_DEFAULT_FRAME_SIZE, 4 * mr->u.reply.MsgLength));\r\nout:\r\nif (ioc->taskmgmt_cmds.status & MPT_MGMT_STATUS_PENDING) {\r\nmpt_clear_taskmgmt_in_progress_flag(ioc);\r\nioc->taskmgmt_cmds.status &= ~MPT_MGMT_STATUS_PENDING;\r\ncomplete(&ioc->taskmgmt_cmds.done);\r\nif (ioc->bus_type == SAS)\r\nioc->schedule_target_reset(ioc);\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nint\r\nmptscsih_bios_param(struct scsi_device * sdev, struct block_device *bdev,\r\nsector_t capacity, int geom[])\r\n{\r\nint heads;\r\nint sectors;\r\nsector_t cylinders;\r\nulong dummy;\r\nheads = 64;\r\nsectors = 32;\r\ndummy = heads * sectors;\r\ncylinders = capacity;\r\nsector_div(cylinders,dummy);\r\nif ((ulong)capacity >= 0x200000) {\r\nheads = 255;\r\nsectors = 63;\r\ndummy = heads * sectors;\r\ncylinders = capacity;\r\nsector_div(cylinders,dummy);\r\n}\r\ngeom[0] = heads;\r\ngeom[1] = sectors;\r\ngeom[2] = cylinders;\r\nreturn 0;\r\n}\r\nint\r\nmptscsih_is_phys_disk(MPT_ADAPTER *ioc, u8 channel, u8 id)\r\n{\r\nstruct inactive_raid_component_info *component_info;\r\nint i, j;\r\nRaidPhysDiskPage1_t *phys_disk;\r\nint rc = 0;\r\nint num_paths;\r\nif (!ioc->raid_data.pIocPg3)\r\ngoto out;\r\nfor (i = 0; i < ioc->raid_data.pIocPg3->NumPhysDisks; i++) {\r\nif ((id == ioc->raid_data.pIocPg3->PhysDisk[i].PhysDiskID) &&\r\n(channel == ioc->raid_data.pIocPg3->PhysDisk[i].PhysDiskBus)) {\r\nrc = 1;\r\ngoto out;\r\n}\r\n}\r\nif (ioc->bus_type != SAS)\r\ngoto out;\r\nfor (i = 0; i < ioc->raid_data.pIocPg3->NumPhysDisks; i++) {\r\nnum_paths = mpt_raid_phys_disk_get_num_paths(ioc,\r\nioc->raid_data.pIocPg3->PhysDisk[i].PhysDiskNum);\r\nif (num_paths < 2)\r\ncontinue;\r\nphys_disk = kzalloc(offsetof(RaidPhysDiskPage1_t, Path) +\r\n(num_paths * sizeof(RAID_PHYS_DISK1_PATH)), GFP_KERNEL);\r\nif (!phys_disk)\r\ncontinue;\r\nif ((mpt_raid_phys_disk_pg1(ioc,\r\nioc->raid_data.pIocPg3->PhysDisk[i].PhysDiskNum,\r\nphys_disk))) {\r\nkfree(phys_disk);\r\ncontinue;\r\n}\r\nfor (j = 0; j < num_paths; j++) {\r\nif ((phys_disk->Path[j].Flags &\r\nMPI_RAID_PHYSDISK1_FLAG_INVALID))\r\ncontinue;\r\nif ((phys_disk->Path[j].Flags &\r\nMPI_RAID_PHYSDISK1_FLAG_BROKEN))\r\ncontinue;\r\nif ((id == phys_disk->Path[j].PhysDiskID) &&\r\n(channel == phys_disk->Path[j].PhysDiskBus)) {\r\nrc = 1;\r\nkfree(phys_disk);\r\ngoto out;\r\n}\r\n}\r\nkfree(phys_disk);\r\n}\r\nif (list_empty(&ioc->raid_data.inactive_list))\r\ngoto out;\r\nmutex_lock(&ioc->raid_data.inactive_list_mutex);\r\nlist_for_each_entry(component_info, &ioc->raid_data.inactive_list,\r\nlist) {\r\nif ((component_info->d.PhysDiskID == id) &&\r\n(component_info->d.PhysDiskBus == channel))\r\nrc = 1;\r\n}\r\nmutex_unlock(&ioc->raid_data.inactive_list_mutex);\r\nout:\r\nreturn rc;\r\n}\r\nu8\r\nmptscsih_raid_id_to_num(MPT_ADAPTER *ioc, u8 channel, u8 id)\r\n{\r\nstruct inactive_raid_component_info *component_info;\r\nint i, j;\r\nRaidPhysDiskPage1_t *phys_disk;\r\nint rc = -ENXIO;\r\nint num_paths;\r\nif (!ioc->raid_data.pIocPg3)\r\ngoto out;\r\nfor (i = 0; i < ioc->raid_data.pIocPg3->NumPhysDisks; i++) {\r\nif ((id == ioc->raid_data.pIocPg3->PhysDisk[i].PhysDiskID) &&\r\n(channel == ioc->raid_data.pIocPg3->PhysDisk[i].PhysDiskBus)) {\r\nrc = ioc->raid_data.pIocPg3->PhysDisk[i].PhysDiskNum;\r\ngoto out;\r\n}\r\n}\r\nif (ioc->bus_type != SAS)\r\ngoto out;\r\nfor (i = 0; i < ioc->raid_data.pIocPg3->NumPhysDisks; i++) {\r\nnum_paths = mpt_raid_phys_disk_get_num_paths(ioc,\r\nioc->raid_data.pIocPg3->PhysDisk[i].PhysDiskNum);\r\nif (num_paths < 2)\r\ncontinue;\r\nphys_disk = kzalloc(offsetof(RaidPhysDiskPage1_t, Path) +\r\n(num_paths * sizeof(RAID_PHYS_DISK1_PATH)), GFP_KERNEL);\r\nif (!phys_disk)\r\ncontinue;\r\nif ((mpt_raid_phys_disk_pg1(ioc,\r\nioc->raid_data.pIocPg3->PhysDisk[i].PhysDiskNum,\r\nphys_disk))) {\r\nkfree(phys_disk);\r\ncontinue;\r\n}\r\nfor (j = 0; j < num_paths; j++) {\r\nif ((phys_disk->Path[j].Flags &\r\nMPI_RAID_PHYSDISK1_FLAG_INVALID))\r\ncontinue;\r\nif ((phys_disk->Path[j].Flags &\r\nMPI_RAID_PHYSDISK1_FLAG_BROKEN))\r\ncontinue;\r\nif ((id == phys_disk->Path[j].PhysDiskID) &&\r\n(channel == phys_disk->Path[j].PhysDiskBus)) {\r\nrc = phys_disk->PhysDiskNum;\r\nkfree(phys_disk);\r\ngoto out;\r\n}\r\n}\r\nkfree(phys_disk);\r\n}\r\nif (list_empty(&ioc->raid_data.inactive_list))\r\ngoto out;\r\nmutex_lock(&ioc->raid_data.inactive_list_mutex);\r\nlist_for_each_entry(component_info, &ioc->raid_data.inactive_list,\r\nlist) {\r\nif ((component_info->d.PhysDiskID == id) &&\r\n(component_info->d.PhysDiskBus == channel))\r\nrc = component_info->d.PhysDiskNum;\r\n}\r\nmutex_unlock(&ioc->raid_data.inactive_list_mutex);\r\nout:\r\nreturn rc;\r\n}\r\nvoid\r\nmptscsih_slave_destroy(struct scsi_device *sdev)\r\n{\r\nstruct Scsi_Host *host = sdev->host;\r\nMPT_SCSI_HOST *hd = shost_priv(host);\r\nVirtTarget *vtarget;\r\nVirtDevice *vdevice;\r\nstruct scsi_target *starget;\r\nstarget = scsi_target(sdev);\r\nvtarget = starget->hostdata;\r\nvdevice = sdev->hostdata;\r\nif (!vdevice)\r\nreturn;\r\nmptscsih_search_running_cmds(hd, vdevice);\r\nvtarget->num_luns--;\r\nmptscsih_synchronize_cache(hd, vdevice);\r\nkfree(vdevice);\r\nsdev->hostdata = NULL;\r\n}\r\nint\r\nmptscsih_change_queue_depth(struct scsi_device *sdev, int qdepth, int reason)\r\n{\r\nMPT_SCSI_HOST *hd = shost_priv(sdev->host);\r\nVirtTarget *vtarget;\r\nstruct scsi_target *starget;\r\nint max_depth;\r\nint tagged;\r\nMPT_ADAPTER *ioc = hd->ioc;\r\nstarget = scsi_target(sdev);\r\nvtarget = starget->hostdata;\r\nif (reason != SCSI_QDEPTH_DEFAULT)\r\nreturn -EOPNOTSUPP;\r\nif (ioc->bus_type == SPI) {\r\nif (!(vtarget->tflags & MPT_TARGET_FLAGS_Q_YES))\r\nmax_depth = 1;\r\nelse if (sdev->type == TYPE_DISK &&\r\nvtarget->minSyncFactor <= MPT_ULTRA160)\r\nmax_depth = MPT_SCSI_CMD_PER_DEV_HIGH;\r\nelse\r\nmax_depth = MPT_SCSI_CMD_PER_DEV_LOW;\r\n} else\r\nmax_depth = ioc->sh->can_queue;\r\nif (!sdev->tagged_supported)\r\nmax_depth = 1;\r\nif (qdepth > max_depth)\r\nqdepth = max_depth;\r\nif (qdepth == 1)\r\ntagged = 0;\r\nelse\r\ntagged = MSG_SIMPLE_TAG;\r\nscsi_adjust_queue_depth(sdev, tagged, qdepth);\r\nreturn sdev->queue_depth;\r\n}\r\nint\r\nmptscsih_slave_configure(struct scsi_device *sdev)\r\n{\r\nstruct Scsi_Host *sh = sdev->host;\r\nVirtTarget *vtarget;\r\nVirtDevice *vdevice;\r\nstruct scsi_target *starget;\r\nMPT_SCSI_HOST *hd = shost_priv(sh);\r\nMPT_ADAPTER *ioc = hd->ioc;\r\nstarget = scsi_target(sdev);\r\nvtarget = starget->hostdata;\r\nvdevice = sdev->hostdata;\r\ndsprintk(ioc, printk(MYIOC_s_DEBUG_FMT\r\n"device @ %p, channel=%d, id=%d, lun=%d\n",\r\nioc->name, sdev, sdev->channel, sdev->id, sdev->lun));\r\nif (ioc->bus_type == SPI)\r\ndsprintk(ioc, printk(MYIOC_s_DEBUG_FMT\r\n"sdtr %d wdtr %d ppr %d inq length=%d\n",\r\nioc->name, sdev->sdtr, sdev->wdtr,\r\nsdev->ppr, sdev->inquiry_len));\r\nvdevice->configured_lun = 1;\r\ndsprintk(ioc, printk(MYIOC_s_DEBUG_FMT\r\n"Queue depth=%d, tflags=%x\n",\r\nioc->name, sdev->queue_depth, vtarget->tflags));\r\nif (ioc->bus_type == SPI)\r\ndsprintk(ioc, printk(MYIOC_s_DEBUG_FMT\r\n"negoFlags=%x, maxOffset=%x, SyncFactor=%x\n",\r\nioc->name, vtarget->negoFlags, vtarget->maxOffset,\r\nvtarget->minSyncFactor));\r\nmptscsih_change_queue_depth(sdev, MPT_SCSI_CMD_PER_DEV_HIGH,\r\nSCSI_QDEPTH_DEFAULT);\r\ndsprintk(ioc, printk(MYIOC_s_DEBUG_FMT\r\n"tagged %d, simple %d, ordered %d\n",\r\nioc->name,sdev->tagged_supported, sdev->simple_tags,\r\nsdev->ordered_tags));\r\nblk_queue_dma_alignment (sdev->request_queue, 512 - 1);\r\nreturn 0;\r\n}\r\nstatic void\r\nmptscsih_copy_sense_data(struct scsi_cmnd *sc, MPT_SCSI_HOST *hd, MPT_FRAME_HDR *mf, SCSIIOReply_t *pScsiReply)\r\n{\r\nVirtDevice *vdevice;\r\nSCSIIORequest_t *pReq;\r\nu32 sense_count = le32_to_cpu(pScsiReply->SenseCount);\r\nMPT_ADAPTER *ioc = hd->ioc;\r\npReq = (SCSIIORequest_t *) mf;\r\nvdevice = sc->device->hostdata;\r\nif (sense_count) {\r\nu8 *sense_data;\r\nint req_index;\r\nreq_index = le16_to_cpu(mf->u.frame.hwhdr.msgctxu.fld.req_idx);\r\nsense_data = ((u8 *)ioc->sense_buf_pool + (req_index * MPT_SENSE_BUFFER_ALLOC));\r\nmemcpy(sc->sense_buffer, sense_data, SNS_LEN(sc));\r\nif ((ioc->events) && (ioc->eventTypes & (1 << MPI_EVENT_SCSI_DEVICE_STATUS_CHANGE))) {\r\nif ((sense_data[12] == 0x5D) && (vdevice->vtarget->raidVolume == 0)) {\r\nint idx;\r\nidx = ioc->eventContext % MPTCTL_EVENT_LOG_SIZE;\r\nioc->events[idx].event = MPI_EVENT_SCSI_DEVICE_STATUS_CHANGE;\r\nioc->events[idx].eventContext = ioc->eventContext;\r\nioc->events[idx].data[0] = (pReq->LUN[1] << 24) |\r\n(MPI_EVENT_SCSI_DEV_STAT_RC_SMART_DATA << 16) |\r\n(sc->device->channel << 8) | sc->device->id;\r\nioc->events[idx].data[1] = (sense_data[13] << 8) | sense_data[12];\r\nioc->eventContext++;\r\nif (ioc->pcidev->vendor ==\r\nPCI_VENDOR_ID_IBM) {\r\nmptscsih_issue_sep_command(ioc,\r\nvdevice->vtarget, MPI_SEP_REQ_SLOTSTATUS_PREDICTED_FAULT);\r\nvdevice->vtarget->tflags |=\r\nMPT_TARGET_FLAGS_LED_ON;\r\n}\r\n}\r\n}\r\n} else {\r\ndprintk(ioc, printk(MYIOC_s_DEBUG_FMT "Hmmm... SenseData len=0! (?)\n",\r\nioc->name));\r\n}\r\n}\r\nstruct scsi_cmnd *\r\nmptscsih_get_scsi_lookup(MPT_ADAPTER *ioc, int i)\r\n{\r\nunsigned long flags;\r\nstruct scsi_cmnd *scmd;\r\nspin_lock_irqsave(&ioc->scsi_lookup_lock, flags);\r\nscmd = ioc->ScsiLookup[i];\r\nspin_unlock_irqrestore(&ioc->scsi_lookup_lock, flags);\r\nreturn scmd;\r\n}\r\nstatic struct scsi_cmnd *\r\nmptscsih_getclear_scsi_lookup(MPT_ADAPTER *ioc, int i)\r\n{\r\nunsigned long flags;\r\nstruct scsi_cmnd *scmd;\r\nspin_lock_irqsave(&ioc->scsi_lookup_lock, flags);\r\nscmd = ioc->ScsiLookup[i];\r\nioc->ScsiLookup[i] = NULL;\r\nspin_unlock_irqrestore(&ioc->scsi_lookup_lock, flags);\r\nreturn scmd;\r\n}\r\nstatic void\r\nmptscsih_set_scsi_lookup(MPT_ADAPTER *ioc, int i, struct scsi_cmnd *scmd)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&ioc->scsi_lookup_lock, flags);\r\nioc->ScsiLookup[i] = scmd;\r\nspin_unlock_irqrestore(&ioc->scsi_lookup_lock, flags);\r\n}\r\nstatic int\r\nSCPNT_TO_LOOKUP_IDX(MPT_ADAPTER *ioc, struct scsi_cmnd *sc)\r\n{\r\nunsigned long flags;\r\nint i, index=-1;\r\nspin_lock_irqsave(&ioc->scsi_lookup_lock, flags);\r\nfor (i = 0; i < ioc->req_depth; i++) {\r\nif (ioc->ScsiLookup[i] == sc) {\r\nindex = i;\r\ngoto out;\r\n}\r\n}\r\nout:\r\nspin_unlock_irqrestore(&ioc->scsi_lookup_lock, flags);\r\nreturn index;\r\n}\r\nint\r\nmptscsih_ioc_reset(MPT_ADAPTER *ioc, int reset_phase)\r\n{\r\nMPT_SCSI_HOST *hd;\r\nif (ioc->sh == NULL || shost_priv(ioc->sh) == NULL)\r\nreturn 0;\r\nhd = shost_priv(ioc->sh);\r\nswitch (reset_phase) {\r\ncase MPT_IOC_SETUP_RESET:\r\ndtmprintk(ioc, printk(MYIOC_s_DEBUG_FMT\r\n"%s: MPT_IOC_SETUP_RESET\n", ioc->name, __func__));\r\nbreak;\r\ncase MPT_IOC_PRE_RESET:\r\ndtmprintk(ioc, printk(MYIOC_s_DEBUG_FMT\r\n"%s: MPT_IOC_PRE_RESET\n", ioc->name, __func__));\r\nmptscsih_flush_running_cmds(hd);\r\nbreak;\r\ncase MPT_IOC_POST_RESET:\r\ndtmprintk(ioc, printk(MYIOC_s_DEBUG_FMT\r\n"%s: MPT_IOC_POST_RESET\n", ioc->name, __func__));\r\nif (ioc->internal_cmds.status & MPT_MGMT_STATUS_PENDING) {\r\nioc->internal_cmds.status |=\r\nMPT_MGMT_STATUS_DID_IOCRESET;\r\ncomplete(&ioc->internal_cmds.done);\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn 1;\r\n}\r\nint\r\nmptscsih_event_process(MPT_ADAPTER *ioc, EventNotificationReply_t *pEvReply)\r\n{\r\nu8 event = le32_to_cpu(pEvReply->Event) & 0xFF;\r\ndevtverboseprintk(ioc, printk(MYIOC_s_DEBUG_FMT\r\n"MPT event (=%02Xh) routed to SCSI host driver!\n",\r\nioc->name, event));\r\nif ((event == MPI_EVENT_IOC_BUS_RESET ||\r\nevent == MPI_EVENT_EXT_BUS_RESET) &&\r\n(ioc->bus_type == SPI) && (ioc->soft_resets < -1))\r\nioc->soft_resets++;\r\nreturn 1;\r\n}\r\nint\r\nmptscsih_scandv_complete(MPT_ADAPTER *ioc, MPT_FRAME_HDR *req,\r\nMPT_FRAME_HDR *reply)\r\n{\r\nSCSIIORequest_t *pReq;\r\nSCSIIOReply_t *pReply;\r\nu8 cmd;\r\nu16 req_idx;\r\nu8 *sense_data;\r\nint sz;\r\nioc->internal_cmds.status |= MPT_MGMT_STATUS_COMMAND_GOOD;\r\nioc->internal_cmds.completion_code = MPT_SCANDV_GOOD;\r\nif (!reply)\r\ngoto out;\r\npReply = (SCSIIOReply_t *) reply;\r\npReq = (SCSIIORequest_t *) req;\r\nioc->internal_cmds.completion_code =\r\nmptscsih_get_completion_code(ioc, req, reply);\r\nioc->internal_cmds.status |= MPT_MGMT_STATUS_RF_VALID;\r\nmemcpy(ioc->internal_cmds.reply, reply,\r\nmin(MPT_DEFAULT_FRAME_SIZE, 4 * reply->u.reply.MsgLength));\r\ncmd = reply->u.hdr.Function;\r\nif (((cmd == MPI_FUNCTION_SCSI_IO_REQUEST) ||\r\n(cmd == MPI_FUNCTION_RAID_SCSI_IO_PASSTHROUGH)) &&\r\n(pReply->SCSIState & MPI_SCSI_STATE_AUTOSENSE_VALID)) {\r\nreq_idx = le16_to_cpu(req->u.frame.hwhdr.msgctxu.fld.req_idx);\r\nsense_data = ((u8 *)ioc->sense_buf_pool +\r\n(req_idx * MPT_SENSE_BUFFER_ALLOC));\r\nsz = min_t(int, pReq->SenseBufferLength,\r\nMPT_SENSE_BUFFER_ALLOC);\r\nmemcpy(ioc->internal_cmds.sense, sense_data, sz);\r\n}\r\nout:\r\nif (!(ioc->internal_cmds.status & MPT_MGMT_STATUS_PENDING))\r\nreturn 0;\r\nioc->internal_cmds.status &= ~MPT_MGMT_STATUS_PENDING;\r\ncomplete(&ioc->internal_cmds.done);\r\nreturn 1;\r\n}\r\nstatic int\r\nmptscsih_get_completion_code(MPT_ADAPTER *ioc, MPT_FRAME_HDR *req,\r\nMPT_FRAME_HDR *reply)\r\n{\r\nSCSIIOReply_t *pReply;\r\nMpiRaidActionReply_t *pr;\r\nu8 scsi_status;\r\nu16 status;\r\nint completion_code;\r\npReply = (SCSIIOReply_t *)reply;\r\nstatus = le16_to_cpu(pReply->IOCStatus) & MPI_IOCSTATUS_MASK;\r\nscsi_status = pReply->SCSIStatus;\r\ndevtprintk(ioc, printk(MYIOC_s_DEBUG_FMT\r\n"IOCStatus=%04xh, SCSIState=%02xh, SCSIStatus=%02xh,"\r\n"IOCLogInfo=%08xh\n", ioc->name, status, pReply->SCSIState,\r\nscsi_status, le32_to_cpu(pReply->IOCLogInfo)));\r\nswitch (status) {\r\ncase MPI_IOCSTATUS_SCSI_DEVICE_NOT_THERE:\r\ncompletion_code = MPT_SCANDV_SELECTION_TIMEOUT;\r\nbreak;\r\ncase MPI_IOCSTATUS_SCSI_IO_DATA_ERROR:\r\ncase MPI_IOCSTATUS_SCSI_TASK_TERMINATED:\r\ncase MPI_IOCSTATUS_SCSI_IOC_TERMINATED:\r\ncase MPI_IOCSTATUS_SCSI_EXT_TERMINATED:\r\ncompletion_code = MPT_SCANDV_DID_RESET;\r\nbreak;\r\ncase MPI_IOCSTATUS_BUSY:\r\ncase MPI_IOCSTATUS_INSUFFICIENT_RESOURCES:\r\ncompletion_code = MPT_SCANDV_BUSY;\r\nbreak;\r\ncase MPI_IOCSTATUS_SCSI_DATA_UNDERRUN:\r\ncase MPI_IOCSTATUS_SCSI_RECOVERED_ERROR:\r\ncase MPI_IOCSTATUS_SUCCESS:\r\nif (pReply->Function == MPI_FUNCTION_CONFIG) {\r\ncompletion_code = MPT_SCANDV_GOOD;\r\n} else if (pReply->Function == MPI_FUNCTION_RAID_ACTION) {\r\npr = (MpiRaidActionReply_t *)reply;\r\nif (le16_to_cpu(pr->ActionStatus) ==\r\nMPI_RAID_ACTION_ASTATUS_SUCCESS)\r\ncompletion_code = MPT_SCANDV_GOOD;\r\nelse\r\ncompletion_code = MPT_SCANDV_SOME_ERROR;\r\n} else if (pReply->SCSIState & MPI_SCSI_STATE_AUTOSENSE_VALID)\r\ncompletion_code = MPT_SCANDV_SENSE;\r\nelse if (pReply->SCSIState & MPI_SCSI_STATE_AUTOSENSE_FAILED) {\r\nif (req->u.scsireq.CDB[0] == INQUIRY)\r\ncompletion_code = MPT_SCANDV_ISSUE_SENSE;\r\nelse\r\ncompletion_code = MPT_SCANDV_DID_RESET;\r\n} else if (pReply->SCSIState & MPI_SCSI_STATE_NO_SCSI_STATUS)\r\ncompletion_code = MPT_SCANDV_DID_RESET;\r\nelse if (pReply->SCSIState & MPI_SCSI_STATE_TERMINATED)\r\ncompletion_code = MPT_SCANDV_DID_RESET;\r\nelse if (scsi_status == MPI_SCSI_STATUS_BUSY)\r\ncompletion_code = MPT_SCANDV_BUSY;\r\nelse\r\ncompletion_code = MPT_SCANDV_GOOD;\r\nbreak;\r\ncase MPI_IOCSTATUS_SCSI_PROTOCOL_ERROR:\r\nif (pReply->SCSIState & MPI_SCSI_STATE_TERMINATED)\r\ncompletion_code = MPT_SCANDV_DID_RESET;\r\nelse\r\ncompletion_code = MPT_SCANDV_SOME_ERROR;\r\nbreak;\r\ndefault:\r\ncompletion_code = MPT_SCANDV_SOME_ERROR;\r\nbreak;\r\n}\r\ndevtprintk(ioc, printk(MYIOC_s_DEBUG_FMT\r\n" completionCode set to %08xh\n", ioc->name, completion_code));\r\nreturn completion_code;\r\n}\r\nstatic int\r\nmptscsih_do_cmd(MPT_SCSI_HOST *hd, INTERNAL_CMD *io)\r\n{\r\nMPT_FRAME_HDR *mf;\r\nSCSIIORequest_t *pScsiReq;\r\nint my_idx, ii, dir;\r\nint timeout;\r\nchar cmdLen;\r\nchar CDB[]={0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};\r\nu8 cmd = io->cmd;\r\nMPT_ADAPTER *ioc = hd->ioc;\r\nint ret = 0;\r\nunsigned long timeleft;\r\nunsigned long flags;\r\nspin_lock_irqsave(&ioc->taskmgmt_lock, flags);\r\nif (ioc->ioc_reset_in_progress) {\r\nspin_unlock_irqrestore(&ioc->taskmgmt_lock, flags);\r\ndfailprintk(ioc, printk(MYIOC_s_DEBUG_FMT\r\n"%s: busy with host reset\n", ioc->name, __func__));\r\nreturn MPT_SCANDV_BUSY;\r\n}\r\nspin_unlock_irqrestore(&ioc->taskmgmt_lock, flags);\r\nmutex_lock(&ioc->internal_cmds.mutex);\r\nswitch (cmd) {\r\ncase INQUIRY:\r\ncmdLen = 6;\r\ndir = MPI_SCSIIO_CONTROL_READ;\r\nCDB[0] = cmd;\r\nCDB[4] = io->size;\r\ntimeout = 10;\r\nbreak;\r\ncase TEST_UNIT_READY:\r\ncmdLen = 6;\r\ndir = MPI_SCSIIO_CONTROL_READ;\r\ntimeout = 10;\r\nbreak;\r\ncase START_STOP:\r\ncmdLen = 6;\r\ndir = MPI_SCSIIO_CONTROL_READ;\r\nCDB[0] = cmd;\r\nCDB[4] = 1;\r\ntimeout = 15;\r\nbreak;\r\ncase REQUEST_SENSE:\r\ncmdLen = 6;\r\nCDB[0] = cmd;\r\nCDB[4] = io->size;\r\ndir = MPI_SCSIIO_CONTROL_READ;\r\ntimeout = 10;\r\nbreak;\r\ncase READ_BUFFER:\r\ncmdLen = 10;\r\ndir = MPI_SCSIIO_CONTROL_READ;\r\nCDB[0] = cmd;\r\nif (io->flags & MPT_ICFLAG_ECHO) {\r\nCDB[1] = 0x0A;\r\n} else {\r\nCDB[1] = 0x02;\r\n}\r\nif (io->flags & MPT_ICFLAG_BUF_CAP) {\r\nCDB[1] |= 0x01;\r\n}\r\nCDB[6] = (io->size >> 16) & 0xFF;\r\nCDB[7] = (io->size >> 8) & 0xFF;\r\nCDB[8] = io->size & 0xFF;\r\ntimeout = 10;\r\nbreak;\r\ncase WRITE_BUFFER:\r\ncmdLen = 10;\r\ndir = MPI_SCSIIO_CONTROL_WRITE;\r\nCDB[0] = cmd;\r\nif (io->flags & MPT_ICFLAG_ECHO) {\r\nCDB[1] = 0x0A;\r\n} else {\r\nCDB[1] = 0x02;\r\n}\r\nCDB[6] = (io->size >> 16) & 0xFF;\r\nCDB[7] = (io->size >> 8) & 0xFF;\r\nCDB[8] = io->size & 0xFF;\r\ntimeout = 10;\r\nbreak;\r\ncase RESERVE:\r\ncmdLen = 6;\r\ndir = MPI_SCSIIO_CONTROL_READ;\r\nCDB[0] = cmd;\r\ntimeout = 10;\r\nbreak;\r\ncase RELEASE:\r\ncmdLen = 6;\r\ndir = MPI_SCSIIO_CONTROL_READ;\r\nCDB[0] = cmd;\r\ntimeout = 10;\r\nbreak;\r\ncase SYNCHRONIZE_CACHE:\r\ncmdLen = 10;\r\ndir = MPI_SCSIIO_CONTROL_READ;\r\nCDB[0] = cmd;\r\ntimeout = 10;\r\nbreak;\r\ndefault:\r\nret = -EFAULT;\r\ngoto out;\r\n}\r\nif ((mf = mpt_get_msg_frame(ioc->InternalCtx, ioc)) == NULL) {\r\ndfailprintk(ioc, printk(MYIOC_s_WARN_FMT "%s: No msg frames!\n",\r\nioc->name, __func__));\r\nret = MPT_SCANDV_BUSY;\r\ngoto out;\r\n}\r\npScsiReq = (SCSIIORequest_t *) mf;\r\nmy_idx = le16_to_cpu(mf->u.frame.hwhdr.msgctxu.fld.req_idx);\r\nADD_INDEX_LOG(my_idx);\r\nif (io->flags & MPT_ICFLAG_PHYS_DISK) {\r\npScsiReq->TargetID = io->physDiskNum;\r\npScsiReq->Bus = 0;\r\npScsiReq->ChainOffset = 0;\r\npScsiReq->Function = MPI_FUNCTION_RAID_SCSI_IO_PASSTHROUGH;\r\n} else {\r\npScsiReq->TargetID = io->id;\r\npScsiReq->Bus = io->channel;\r\npScsiReq->ChainOffset = 0;\r\npScsiReq->Function = MPI_FUNCTION_SCSI_IO_REQUEST;\r\n}\r\npScsiReq->CDBLength = cmdLen;\r\npScsiReq->SenseBufferLength = MPT_SENSE_BUFFER_SIZE;\r\npScsiReq->Reserved = 0;\r\npScsiReq->MsgFlags = mpt_msg_flags(ioc);\r\nint_to_scsilun(io->lun, (struct scsi_lun *)pScsiReq->LUN);\r\nif (io->flags & MPT_ICFLAG_TAGGED_CMD)\r\npScsiReq->Control = cpu_to_le32(dir | MPI_SCSIIO_CONTROL_SIMPLEQ);\r\nelse\r\npScsiReq->Control = cpu_to_le32(dir | MPI_SCSIIO_CONTROL_UNTAGGED);\r\nif (cmd == REQUEST_SENSE) {\r\npScsiReq->Control = cpu_to_le32(dir | MPI_SCSIIO_CONTROL_UNTAGGED);\r\ndevtprintk(ioc, printk(MYIOC_s_DEBUG_FMT\r\n"%s: Untagged! 0x%02x\n", ioc->name, __func__, cmd));\r\n}\r\nfor (ii = 0; ii < 16; ii++)\r\npScsiReq->CDB[ii] = CDB[ii];\r\npScsiReq->DataLength = cpu_to_le32(io->size);\r\npScsiReq->SenseBufferLowAddr = cpu_to_le32(ioc->sense_buf_low_dma\r\n+ (my_idx * MPT_SENSE_BUFFER_ALLOC));\r\ndevtprintk(ioc, printk(MYIOC_s_DEBUG_FMT\r\n"%s: Sending Command 0x%02x for fw_channel=%d fw_id=%d lun=%d\n",\r\nioc->name, __func__, cmd, io->channel, io->id, io->lun));\r\nif (dir == MPI_SCSIIO_CONTROL_READ)\r\nioc->add_sge((char *) &pScsiReq->SGL,\r\nMPT_SGE_FLAGS_SSIMPLE_READ | io->size, io->data_dma);\r\nelse\r\nioc->add_sge((char *) &pScsiReq->SGL,\r\nMPT_SGE_FLAGS_SSIMPLE_WRITE | io->size, io->data_dma);\r\nINITIALIZE_MGMT_STATUS(ioc->internal_cmds.status)\r\nmpt_put_msg_frame(ioc->InternalCtx, ioc, mf);\r\ntimeleft = wait_for_completion_timeout(&ioc->internal_cmds.done,\r\ntimeout*HZ);\r\nif (!(ioc->internal_cmds.status & MPT_MGMT_STATUS_COMMAND_GOOD)) {\r\nret = MPT_SCANDV_DID_RESET;\r\ndfailprintk(ioc, printk(MYIOC_s_DEBUG_FMT\r\n"%s: TIMED OUT for cmd=0x%02x\n", ioc->name, __func__,\r\ncmd));\r\nif (ioc->internal_cmds.status & MPT_MGMT_STATUS_DID_IOCRESET) {\r\nmpt_free_msg_frame(ioc, mf);\r\ngoto out;\r\n}\r\nif (!timeleft) {\r\nprintk(MYIOC_s_WARN_FMT\r\n"Issuing Reset from %s!! doorbell=0x%08xh"\r\n" cmd=0x%02x\n",\r\nioc->name, __func__, mpt_GetIocState(ioc, 0),\r\ncmd);\r\nmpt_Soft_Hard_ResetHandler(ioc, CAN_SLEEP);\r\nmpt_free_msg_frame(ioc, mf);\r\n}\r\ngoto out;\r\n}\r\nret = ioc->internal_cmds.completion_code;\r\ndevtprintk(ioc, printk(MYIOC_s_DEBUG_FMT "%s: success, rc=0x%02x\n",\r\nioc->name, __func__, ret));\r\nout:\r\nCLEAR_MGMT_STATUS(ioc->internal_cmds.status)\r\nmutex_unlock(&ioc->internal_cmds.mutex);\r\nreturn ret;\r\n}\r\nstatic void\r\nmptscsih_synchronize_cache(MPT_SCSI_HOST *hd, VirtDevice *vdevice)\r\n{\r\nINTERNAL_CMD iocmd;\r\nif (vdevice->vtarget->tflags & MPT_TARGET_FLAGS_RAID_COMPONENT)\r\nreturn;\r\nif (vdevice->vtarget->type != TYPE_DISK || vdevice->vtarget->deleted ||\r\n!vdevice->configured_lun)\r\nreturn;\r\niocmd.cmd = SYNCHRONIZE_CACHE;\r\niocmd.flags = 0;\r\niocmd.physDiskNum = -1;\r\niocmd.data = NULL;\r\niocmd.data_dma = -1;\r\niocmd.size = 0;\r\niocmd.rsvd = iocmd.rsvd2 = 0;\r\niocmd.channel = vdevice->vtarget->channel;\r\niocmd.id = vdevice->vtarget->id;\r\niocmd.lun = vdevice->lun;\r\nmptscsih_do_cmd(hd, &iocmd);\r\n}\r\nstatic ssize_t\r\nmptscsih_version_fw_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct Scsi_Host *host = class_to_shost(dev);\r\nMPT_SCSI_HOST *hd = shost_priv(host);\r\nMPT_ADAPTER *ioc = hd->ioc;\r\nreturn snprintf(buf, PAGE_SIZE, "%02d.%02d.%02d.%02d\n",\r\n(ioc->facts.FWVersion.Word & 0xFF000000) >> 24,\r\n(ioc->facts.FWVersion.Word & 0x00FF0000) >> 16,\r\n(ioc->facts.FWVersion.Word & 0x0000FF00) >> 8,\r\nioc->facts.FWVersion.Word & 0x000000FF);\r\n}\r\nstatic ssize_t\r\nmptscsih_version_bios_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct Scsi_Host *host = class_to_shost(dev);\r\nMPT_SCSI_HOST *hd = shost_priv(host);\r\nMPT_ADAPTER *ioc = hd->ioc;\r\nreturn snprintf(buf, PAGE_SIZE, "%02x.%02x.%02x.%02x\n",\r\n(ioc->biosVersion & 0xFF000000) >> 24,\r\n(ioc->biosVersion & 0x00FF0000) >> 16,\r\n(ioc->biosVersion & 0x0000FF00) >> 8,\r\nioc->biosVersion & 0x000000FF);\r\n}\r\nstatic ssize_t\r\nmptscsih_version_mpi_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct Scsi_Host *host = class_to_shost(dev);\r\nMPT_SCSI_HOST *hd = shost_priv(host);\r\nMPT_ADAPTER *ioc = hd->ioc;\r\nreturn snprintf(buf, PAGE_SIZE, "%03x\n", ioc->facts.MsgVersion);\r\n}\r\nstatic ssize_t\r\nmptscsih_version_product_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct Scsi_Host *host = class_to_shost(dev);\r\nMPT_SCSI_HOST *hd = shost_priv(host);\r\nMPT_ADAPTER *ioc = hd->ioc;\r\nreturn snprintf(buf, PAGE_SIZE, "%s\n", ioc->prod_name);\r\n}\r\nstatic ssize_t\r\nmptscsih_version_nvdata_persistent_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct Scsi_Host *host = class_to_shost(dev);\r\nMPT_SCSI_HOST *hd = shost_priv(host);\r\nMPT_ADAPTER *ioc = hd->ioc;\r\nreturn snprintf(buf, PAGE_SIZE, "%02xh\n",\r\nioc->nvdata_version_persistent);\r\n}\r\nstatic ssize_t\r\nmptscsih_version_nvdata_default_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct Scsi_Host *host = class_to_shost(dev);\r\nMPT_SCSI_HOST *hd = shost_priv(host);\r\nMPT_ADAPTER *ioc = hd->ioc;\r\nreturn snprintf(buf, PAGE_SIZE, "%02xh\n",ioc->nvdata_version_default);\r\n}\r\nstatic ssize_t\r\nmptscsih_board_name_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct Scsi_Host *host = class_to_shost(dev);\r\nMPT_SCSI_HOST *hd = shost_priv(host);\r\nMPT_ADAPTER *ioc = hd->ioc;\r\nreturn snprintf(buf, PAGE_SIZE, "%s\n", ioc->board_name);\r\n}\r\nstatic ssize_t\r\nmptscsih_board_assembly_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct Scsi_Host *host = class_to_shost(dev);\r\nMPT_SCSI_HOST *hd = shost_priv(host);\r\nMPT_ADAPTER *ioc = hd->ioc;\r\nreturn snprintf(buf, PAGE_SIZE, "%s\n", ioc->board_assembly);\r\n}\r\nstatic ssize_t\r\nmptscsih_board_tracer_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct Scsi_Host *host = class_to_shost(dev);\r\nMPT_SCSI_HOST *hd = shost_priv(host);\r\nMPT_ADAPTER *ioc = hd->ioc;\r\nreturn snprintf(buf, PAGE_SIZE, "%s\n", ioc->board_tracer);\r\n}\r\nstatic ssize_t\r\nmptscsih_io_delay_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct Scsi_Host *host = class_to_shost(dev);\r\nMPT_SCSI_HOST *hd = shost_priv(host);\r\nMPT_ADAPTER *ioc = hd->ioc;\r\nreturn snprintf(buf, PAGE_SIZE, "%02d\n", ioc->io_missing_delay);\r\n}\r\nstatic ssize_t\r\nmptscsih_device_delay_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct Scsi_Host *host = class_to_shost(dev);\r\nMPT_SCSI_HOST *hd = shost_priv(host);\r\nMPT_ADAPTER *ioc = hd->ioc;\r\nreturn snprintf(buf, PAGE_SIZE, "%02d\n", ioc->device_missing_delay);\r\n}\r\nstatic ssize_t\r\nmptscsih_debug_level_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct Scsi_Host *host = class_to_shost(dev);\r\nMPT_SCSI_HOST *hd = shost_priv(host);\r\nMPT_ADAPTER *ioc = hd->ioc;\r\nreturn snprintf(buf, PAGE_SIZE, "%08xh\n", ioc->debug_level);\r\n}\r\nstatic ssize_t\r\nmptscsih_debug_level_store(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct Scsi_Host *host = class_to_shost(dev);\r\nMPT_SCSI_HOST *hd = shost_priv(host);\r\nMPT_ADAPTER *ioc = hd->ioc;\r\nint val = 0;\r\nif (sscanf(buf, "%x", &val) != 1)\r\nreturn -EINVAL;\r\nioc->debug_level = val;\r\nprintk(MYIOC_s_INFO_FMT "debug_level=%08xh\n",\r\nioc->name, ioc->debug_level);\r\nreturn strlen(buf);\r\n}
