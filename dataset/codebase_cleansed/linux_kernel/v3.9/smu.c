static void smu_start_cmd(void)\r\n{\r\nunsigned long faddr, fend;\r\nstruct smu_cmd *cmd;\r\nif (list_empty(&smu->cmd_list))\r\nreturn;\r\ncmd = list_entry(smu->cmd_list.next, struct smu_cmd, link);\r\nsmu->cmd_cur = cmd;\r\nlist_del(&cmd->link);\r\nDPRINTK("SMU: starting cmd %x, %d bytes data\n", cmd->cmd,\r\ncmd->data_len);\r\nDPRINTK("SMU: data buffer: %02x %02x %02x %02x %02x %02x %02x %02x\n",\r\n((u8 *)cmd->data_buf)[0], ((u8 *)cmd->data_buf)[1],\r\n((u8 *)cmd->data_buf)[2], ((u8 *)cmd->data_buf)[3],\r\n((u8 *)cmd->data_buf)[4], ((u8 *)cmd->data_buf)[5],\r\n((u8 *)cmd->data_buf)[6], ((u8 *)cmd->data_buf)[7]);\r\nsmu->cmd_buf->cmd = cmd->cmd;\r\nsmu->cmd_buf->length = cmd->data_len;\r\nmemcpy(smu->cmd_buf->data, cmd->data_buf, cmd->data_len);\r\nfaddr = (unsigned long)smu->cmd_buf;\r\nfend = faddr + smu->cmd_buf->length + 2;\r\nflush_inval_dcache_range(faddr, fend);\r\nif (smu->broken_nap)\r\npowersave_nap = 0;\r\nwritel(smu->cmd_buf_abs, smu->db_buf);\r\npmac_do_feature_call(PMAC_FTR_WRITE_GPIO, NULL, smu->doorbell, 4);\r\n}\r\nstatic irqreturn_t smu_db_intr(int irq, void *arg)\r\n{\r\nunsigned long flags;\r\nstruct smu_cmd *cmd;\r\nvoid (*done)(struct smu_cmd *cmd, void *misc) = NULL;\r\nvoid *misc = NULL;\r\nu8 gpio;\r\nint rc = 0;\r\nspin_lock_irqsave(&smu->lock, flags);\r\ngpio = pmac_do_feature_call(PMAC_FTR_READ_GPIO, NULL, smu->doorbell);\r\nif ((gpio & 7) != 7) {\r\nspin_unlock_irqrestore(&smu->lock, flags);\r\nreturn IRQ_HANDLED;\r\n}\r\ncmd = smu->cmd_cur;\r\nsmu->cmd_cur = NULL;\r\nif (cmd == NULL)\r\ngoto bail;\r\nif (rc == 0) {\r\nunsigned long faddr;\r\nint reply_len;\r\nu8 ack;\r\nfaddr = (unsigned long)smu->cmd_buf;\r\nflush_inval_dcache_range(faddr, faddr + 256);\r\nack = (~cmd->cmd) & 0xff;\r\nif (ack != smu->cmd_buf->cmd) {\r\nDPRINTK("SMU: incorrect ack, want %x got %x\n",\r\nack, smu->cmd_buf->cmd);\r\nrc = -EIO;\r\n}\r\nreply_len = rc == 0 ? smu->cmd_buf->length : 0;\r\nDPRINTK("SMU: reply len: %d\n", reply_len);\r\nif (reply_len > cmd->reply_len) {\r\nprintk(KERN_WARNING "SMU: reply buffer too small,"\r\n"got %d bytes for a %d bytes buffer\n",\r\nreply_len, cmd->reply_len);\r\nreply_len = cmd->reply_len;\r\n}\r\ncmd->reply_len = reply_len;\r\nif (cmd->reply_buf && reply_len)\r\nmemcpy(cmd->reply_buf, smu->cmd_buf->data, reply_len);\r\n}\r\ndone = cmd->done;\r\nmisc = cmd->misc;\r\nmb();\r\ncmd->status = rc;\r\nif (smu->broken_nap)\r\npowersave_nap = 1;\r\nbail:\r\nsmu_start_cmd();\r\nspin_unlock_irqrestore(&smu->lock, flags);\r\nif (done)\r\ndone(cmd, misc);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t smu_msg_intr(int irq, void *arg)\r\n{\r\nprintk(KERN_INFO "SMU: message interrupt !\n");\r\nreturn IRQ_HANDLED;\r\n}\r\nint smu_queue_cmd(struct smu_cmd *cmd)\r\n{\r\nunsigned long flags;\r\nif (smu == NULL)\r\nreturn -ENODEV;\r\nif (cmd->data_len > SMU_MAX_DATA ||\r\ncmd->reply_len > SMU_MAX_DATA)\r\nreturn -EINVAL;\r\ncmd->status = 1;\r\nspin_lock_irqsave(&smu->lock, flags);\r\nlist_add_tail(&cmd->link, &smu->cmd_list);\r\nif (smu->cmd_cur == NULL)\r\nsmu_start_cmd();\r\nspin_unlock_irqrestore(&smu->lock, flags);\r\nif (!smu_irq_inited || smu->db_irq == NO_IRQ)\r\nsmu_spinwait_cmd(cmd);\r\nreturn 0;\r\n}\r\nint smu_queue_simple(struct smu_simple_cmd *scmd, u8 command,\r\nunsigned int data_len,\r\nvoid (*done)(struct smu_cmd *cmd, void *misc),\r\nvoid *misc, ...)\r\n{\r\nstruct smu_cmd *cmd = &scmd->cmd;\r\nva_list list;\r\nint i;\r\nif (data_len > sizeof(scmd->buffer))\r\nreturn -EINVAL;\r\nmemset(scmd, 0, sizeof(*scmd));\r\ncmd->cmd = command;\r\ncmd->data_len = data_len;\r\ncmd->data_buf = scmd->buffer;\r\ncmd->reply_len = sizeof(scmd->buffer);\r\ncmd->reply_buf = scmd->buffer;\r\ncmd->done = done;\r\ncmd->misc = misc;\r\nva_start(list, misc);\r\nfor (i = 0; i < data_len; ++i)\r\nscmd->buffer[i] = (u8)va_arg(list, int);\r\nva_end(list);\r\nreturn smu_queue_cmd(cmd);\r\n}\r\nvoid smu_poll(void)\r\n{\r\nu8 gpio;\r\nif (smu == NULL)\r\nreturn;\r\ngpio = pmac_do_feature_call(PMAC_FTR_READ_GPIO, NULL, smu->doorbell);\r\nif ((gpio & 7) == 7)\r\nsmu_db_intr(smu->db_irq, smu);\r\n}\r\nvoid smu_done_complete(struct smu_cmd *cmd, void *misc)\r\n{\r\nstruct completion *comp = misc;\r\ncomplete(comp);\r\n}\r\nvoid smu_spinwait_cmd(struct smu_cmd *cmd)\r\n{\r\nwhile(cmd->status == 1)\r\nsmu_poll();\r\n}\r\nstatic inline int bcd2hex (int n)\r\n{\r\nreturn (((n & 0xf0) >> 4) * 10) + (n & 0xf);\r\n}\r\nstatic inline int hex2bcd (int n)\r\n{\r\nreturn ((n / 10) << 4) + (n % 10);\r\n}\r\nstatic inline void smu_fill_set_rtc_cmd(struct smu_cmd_buf *cmd_buf,\r\nstruct rtc_time *time)\r\n{\r\ncmd_buf->cmd = 0x8e;\r\ncmd_buf->length = 8;\r\ncmd_buf->data[0] = 0x80;\r\ncmd_buf->data[1] = hex2bcd(time->tm_sec);\r\ncmd_buf->data[2] = hex2bcd(time->tm_min);\r\ncmd_buf->data[3] = hex2bcd(time->tm_hour);\r\ncmd_buf->data[4] = time->tm_wday;\r\ncmd_buf->data[5] = hex2bcd(time->tm_mday);\r\ncmd_buf->data[6] = hex2bcd(time->tm_mon) + 1;\r\ncmd_buf->data[7] = hex2bcd(time->tm_year - 100);\r\n}\r\nint smu_get_rtc_time(struct rtc_time *time, int spinwait)\r\n{\r\nstruct smu_simple_cmd cmd;\r\nint rc;\r\nif (smu == NULL)\r\nreturn -ENODEV;\r\nmemset(time, 0, sizeof(struct rtc_time));\r\nrc = smu_queue_simple(&cmd, SMU_CMD_RTC_COMMAND, 1, NULL, NULL,\r\nSMU_CMD_RTC_GET_DATETIME);\r\nif (rc)\r\nreturn rc;\r\nsmu_spinwait_simple(&cmd);\r\ntime->tm_sec = bcd2hex(cmd.buffer[0]);\r\ntime->tm_min = bcd2hex(cmd.buffer[1]);\r\ntime->tm_hour = bcd2hex(cmd.buffer[2]);\r\ntime->tm_wday = bcd2hex(cmd.buffer[3]);\r\ntime->tm_mday = bcd2hex(cmd.buffer[4]);\r\ntime->tm_mon = bcd2hex(cmd.buffer[5]) - 1;\r\ntime->tm_year = bcd2hex(cmd.buffer[6]) + 100;\r\nreturn 0;\r\n}\r\nint smu_set_rtc_time(struct rtc_time *time, int spinwait)\r\n{\r\nstruct smu_simple_cmd cmd;\r\nint rc;\r\nif (smu == NULL)\r\nreturn -ENODEV;\r\nrc = smu_queue_simple(&cmd, SMU_CMD_RTC_COMMAND, 8, NULL, NULL,\r\nSMU_CMD_RTC_SET_DATETIME,\r\nhex2bcd(time->tm_sec),\r\nhex2bcd(time->tm_min),\r\nhex2bcd(time->tm_hour),\r\ntime->tm_wday,\r\nhex2bcd(time->tm_mday),\r\nhex2bcd(time->tm_mon) + 1,\r\nhex2bcd(time->tm_year - 100));\r\nif (rc)\r\nreturn rc;\r\nsmu_spinwait_simple(&cmd);\r\nreturn 0;\r\n}\r\nvoid smu_shutdown(void)\r\n{\r\nstruct smu_simple_cmd cmd;\r\nif (smu == NULL)\r\nreturn;\r\nif (smu_queue_simple(&cmd, SMU_CMD_POWER_COMMAND, 9, NULL, NULL,\r\n'S', 'H', 'U', 'T', 'D', 'O', 'W', 'N', 0))\r\nreturn;\r\nsmu_spinwait_simple(&cmd);\r\nfor (;;)\r\n;\r\n}\r\nvoid smu_restart(void)\r\n{\r\nstruct smu_simple_cmd cmd;\r\nif (smu == NULL)\r\nreturn;\r\nif (smu_queue_simple(&cmd, SMU_CMD_POWER_COMMAND, 8, NULL, NULL,\r\n'R', 'E', 'S', 'T', 'A', 'R', 'T', 0))\r\nreturn;\r\nsmu_spinwait_simple(&cmd);\r\nfor (;;)\r\n;\r\n}\r\nint smu_present(void)\r\n{\r\nreturn smu != NULL;\r\n}\r\nint __init smu_init (void)\r\n{\r\nstruct device_node *np;\r\nconst u32 *data;\r\nint ret = 0;\r\nnp = of_find_node_by_type(NULL, "smu");\r\nif (np == NULL)\r\nreturn -ENODEV;\r\nprintk(KERN_INFO "SMU: Driver %s %s\n", VERSION, AUTHOR);\r\nif (smu_cmdbuf_abs == 0) {\r\nprintk(KERN_ERR "SMU: Command buffer not allocated !\n");\r\nret = -EINVAL;\r\ngoto fail_np;\r\n}\r\nsmu = alloc_bootmem(sizeof(struct smu_device));\r\nspin_lock_init(&smu->lock);\r\nINIT_LIST_HEAD(&smu->cmd_list);\r\nINIT_LIST_HEAD(&smu->cmd_i2c_list);\r\nsmu->of_node = np;\r\nsmu->db_irq = NO_IRQ;\r\nsmu->msg_irq = NO_IRQ;\r\nsmu->cmd_buf_abs = (u32)smu_cmdbuf_abs;\r\nsmu->cmd_buf = __va(smu_cmdbuf_abs);\r\nsmu->db_node = of_find_node_by_name(NULL, "smu-doorbell");\r\nif (smu->db_node == NULL) {\r\nprintk(KERN_ERR "SMU: Can't find doorbell GPIO !\n");\r\nret = -ENXIO;\r\ngoto fail_bootmem;\r\n}\r\ndata = of_get_property(smu->db_node, "reg", NULL);\r\nif (data == NULL) {\r\nprintk(KERN_ERR "SMU: Can't find doorbell GPIO address !\n");\r\nret = -ENXIO;\r\ngoto fail_db_node;\r\n}\r\nsmu->doorbell = *data;\r\nif (smu->doorbell < 0x50)\r\nsmu->doorbell += 0x50;\r\ndo {\r\nsmu->msg_node = of_find_node_by_name(NULL, "smu-interrupt");\r\nif (smu->msg_node == NULL)\r\nbreak;\r\ndata = of_get_property(smu->msg_node, "reg", NULL);\r\nif (data == NULL) {\r\nof_node_put(smu->msg_node);\r\nsmu->msg_node = NULL;\r\nbreak;\r\n}\r\nsmu->msg = *data;\r\nif (smu->msg < 0x50)\r\nsmu->msg += 0x50;\r\n} while(0);\r\nsmu->db_buf = ioremap(0x8000860c, 0x1000);\r\nif (smu->db_buf == NULL) {\r\nprintk(KERN_ERR "SMU: Can't map doorbell buffer pointer !\n");\r\nret = -ENXIO;\r\ngoto fail_msg_node;\r\n}\r\nsmu->broken_nap = pmac_get_uninorth_variant() < 4;\r\nif (smu->broken_nap)\r\nprintk(KERN_INFO "SMU: using NAP mode workaround\n");\r\nsys_ctrler = SYS_CTRLER_SMU;\r\nreturn 0;\r\nfail_msg_node:\r\nif (smu->msg_node)\r\nof_node_put(smu->msg_node);\r\nfail_db_node:\r\nof_node_put(smu->db_node);\r\nfail_bootmem:\r\nfree_bootmem(__pa(smu), sizeof(struct smu_device));\r\nsmu = NULL;\r\nfail_np:\r\nof_node_put(np);\r\nreturn ret;\r\n}\r\nstatic int smu_late_init(void)\r\n{\r\nif (!smu)\r\nreturn 0;\r\ninit_timer(&smu->i2c_timer);\r\nsmu->i2c_timer.function = smu_i2c_retry;\r\nsmu->i2c_timer.data = (unsigned long)smu;\r\nif (smu->db_node) {\r\nsmu->db_irq = irq_of_parse_and_map(smu->db_node, 0);\r\nif (smu->db_irq == NO_IRQ)\r\nprintk(KERN_ERR "smu: failed to map irq for node %s\n",\r\nsmu->db_node->full_name);\r\n}\r\nif (smu->msg_node) {\r\nsmu->msg_irq = irq_of_parse_and_map(smu->msg_node, 0);\r\nif (smu->msg_irq == NO_IRQ)\r\nprintk(KERN_ERR "smu: failed to map irq for node %s\n",\r\nsmu->msg_node->full_name);\r\n}\r\nif (smu->db_irq != NO_IRQ) {\r\nif (request_irq(smu->db_irq, smu_db_intr,\r\nIRQF_SHARED, "SMU doorbell", smu) < 0) {\r\nprintk(KERN_WARNING "SMU: can't "\r\n"request interrupt %d\n",\r\nsmu->db_irq);\r\nsmu->db_irq = NO_IRQ;\r\n}\r\n}\r\nif (smu->msg_irq != NO_IRQ) {\r\nif (request_irq(smu->msg_irq, smu_msg_intr,\r\nIRQF_SHARED, "SMU message", smu) < 0) {\r\nprintk(KERN_WARNING "SMU: can't "\r\n"request interrupt %d\n",\r\nsmu->msg_irq);\r\nsmu->msg_irq = NO_IRQ;\r\n}\r\n}\r\nsmu_irq_inited = 1;\r\nreturn 0;\r\n}\r\nstatic void smu_expose_childs(struct work_struct *unused)\r\n{\r\nstruct device_node *np;\r\nfor (np = NULL; (np = of_get_next_child(smu->of_node, np)) != NULL;)\r\nif (of_device_is_compatible(np, "smu-sensors"))\r\nof_platform_device_create(np, "smu-sensors",\r\n&smu->of_dev->dev);\r\n}\r\nstatic int smu_platform_probe(struct platform_device* dev)\r\n{\r\nif (!smu)\r\nreturn -ENODEV;\r\nsmu->of_dev = dev;\r\nschedule_work(&smu_expose_childs_work);\r\nreturn 0;\r\n}\r\nstatic int __init smu_init_sysfs(void)\r\n{\r\nplatform_driver_register(&smu_of_platform_driver);\r\nreturn 0;\r\n}\r\nstruct platform_device *smu_get_ofdev(void)\r\n{\r\nif (!smu)\r\nreturn NULL;\r\nreturn smu->of_dev;\r\n}\r\nstatic void smu_i2c_complete_command(struct smu_i2c_cmd *cmd, int fail)\r\n{\r\nvoid (*done)(struct smu_i2c_cmd *cmd, void *misc) = cmd->done;\r\nvoid *misc = cmd->misc;\r\nunsigned long flags;\r\nif (!fail && cmd->read) {\r\nif (cmd->pdata[0] < 1)\r\nfail = 1;\r\nelse\r\nmemcpy(cmd->info.data, &cmd->pdata[1],\r\ncmd->info.datalen);\r\n}\r\nDPRINTK("SMU: completing, success: %d\n", !fail);\r\nspin_lock_irqsave(&smu->lock, flags);\r\nsmu->cmd_i2c_cur = NULL;\r\nwmb();\r\ncmd->status = fail ? -EIO : 0;\r\nif (!list_empty(&smu->cmd_i2c_list)) {\r\nstruct smu_i2c_cmd *newcmd;\r\nnewcmd = list_entry(smu->cmd_i2c_list.next,\r\nstruct smu_i2c_cmd, link);\r\nsmu->cmd_i2c_cur = newcmd;\r\nlist_del(&cmd->link);\r\nlist_add_tail(&cmd->scmd.link, &smu->cmd_list);\r\nif (smu->cmd_cur == NULL)\r\nsmu_start_cmd();\r\n}\r\nspin_unlock_irqrestore(&smu->lock, flags);\r\nif (done)\r\ndone(cmd, misc);\r\n}\r\nstatic void smu_i2c_retry(unsigned long data)\r\n{\r\nstruct smu_i2c_cmd *cmd = smu->cmd_i2c_cur;\r\nDPRINTK("SMU: i2c failure, requeuing...\n");\r\ncmd->pdata[0] = 0xff;\r\ncmd->scmd.reply_len = sizeof(cmd->pdata);\r\nsmu_queue_cmd(&cmd->scmd);\r\n}\r\nstatic void smu_i2c_low_completion(struct smu_cmd *scmd, void *misc)\r\n{\r\nstruct smu_i2c_cmd *cmd = misc;\r\nint fail = 0;\r\nDPRINTK("SMU: i2c compl. stage=%d status=%x pdata[0]=%x rlen: %x\n",\r\ncmd->stage, scmd->status, cmd->pdata[0], scmd->reply_len);\r\nif (scmd->status < 0)\r\nfail = 1;\r\nelse if (cmd->read) {\r\nif (cmd->stage == 0)\r\nfail = cmd->pdata[0] != 0;\r\nelse\r\nfail = cmd->pdata[0] >= 0x80;\r\n} else {\r\nfail = cmd->pdata[0] != 0;\r\n}\r\nif (fail && --cmd->retries > 0) {\r\nDPRINTK("SMU: i2c failure, starting timer...\n");\r\nBUG_ON(cmd != smu->cmd_i2c_cur);\r\nif (!smu_irq_inited) {\r\nmdelay(5);\r\nsmu_i2c_retry(0);\r\nreturn;\r\n}\r\nmod_timer(&smu->i2c_timer, jiffies + msecs_to_jiffies(5));\r\nreturn;\r\n}\r\nif (fail || cmd->stage != 0) {\r\nsmu_i2c_complete_command(cmd, fail);\r\nreturn;\r\n}\r\nDPRINTK("SMU: going to stage 1\n");\r\nscmd->reply_buf = cmd->pdata;\r\nscmd->reply_len = sizeof(cmd->pdata);\r\nscmd->data_buf = cmd->pdata;\r\nscmd->data_len = 1;\r\ncmd->pdata[0] = 0;\r\ncmd->stage = 1;\r\ncmd->retries = 20;\r\nsmu_queue_cmd(scmd);\r\n}\r\nint smu_queue_i2c(struct smu_i2c_cmd *cmd)\r\n{\r\nunsigned long flags;\r\nif (smu == NULL)\r\nreturn -ENODEV;\r\ncmd->scmd.cmd = SMU_CMD_I2C_COMMAND;\r\ncmd->scmd.done = smu_i2c_low_completion;\r\ncmd->scmd.misc = cmd;\r\ncmd->scmd.reply_buf = cmd->pdata;\r\ncmd->scmd.reply_len = sizeof(cmd->pdata);\r\ncmd->scmd.data_buf = (u8 *)(char *)&cmd->info;\r\ncmd->scmd.status = 1;\r\ncmd->stage = 0;\r\ncmd->pdata[0] = 0xff;\r\ncmd->retries = 20;\r\ncmd->status = 1;\r\ncmd->info.caddr = cmd->info.devaddr;\r\ncmd->read = cmd->info.devaddr & 0x01;\r\nswitch(cmd->info.type) {\r\ncase SMU_I2C_TRANSFER_SIMPLE:\r\nmemset(&cmd->info.sublen, 0, 4);\r\nbreak;\r\ncase SMU_I2C_TRANSFER_COMBINED:\r\ncmd->info.devaddr &= 0xfe;\r\ncase SMU_I2C_TRANSFER_STDSUB:\r\nif (cmd->info.sublen > 3)\r\nreturn -EINVAL;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (cmd->read) {\r\nif (cmd->info.datalen > SMU_I2C_READ_MAX)\r\nreturn -EINVAL;\r\nmemset(cmd->info.data, 0xff, cmd->info.datalen);\r\ncmd->scmd.data_len = 9;\r\n} else {\r\nif (cmd->info.datalen > SMU_I2C_WRITE_MAX)\r\nreturn -EINVAL;\r\ncmd->scmd.data_len = 9 + cmd->info.datalen;\r\n}\r\nDPRINTK("SMU: i2c enqueuing command\n");\r\nDPRINTK("SMU: %s, len=%d bus=%x addr=%x sub0=%x type=%x\n",\r\ncmd->read ? "read" : "write", cmd->info.datalen,\r\ncmd->info.bus, cmd->info.caddr,\r\ncmd->info.subaddr[0], cmd->info.type);\r\nspin_lock_irqsave(&smu->lock, flags);\r\nif (smu->cmd_i2c_cur == NULL) {\r\nsmu->cmd_i2c_cur = cmd;\r\nlist_add_tail(&cmd->scmd.link, &smu->cmd_list);\r\nif (smu->cmd_cur == NULL)\r\nsmu_start_cmd();\r\n} else\r\nlist_add_tail(&cmd->link, &smu->cmd_i2c_list);\r\nspin_unlock_irqrestore(&smu->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int smu_read_datablock(u8 *dest, unsigned int addr, unsigned int len)\r\n{\r\nDECLARE_COMPLETION_ONSTACK(comp);\r\nunsigned int chunk;\r\nstruct smu_cmd cmd;\r\nint rc;\r\nu8 params[8];\r\nchunk = 0xe;\r\nwhile (len) {\r\nunsigned int clen = min(len, chunk);\r\ncmd.cmd = SMU_CMD_MISC_ee_COMMAND;\r\ncmd.data_len = 7;\r\ncmd.data_buf = params;\r\ncmd.reply_len = chunk;\r\ncmd.reply_buf = dest;\r\ncmd.done = smu_done_complete;\r\ncmd.misc = &comp;\r\nparams[0] = SMU_CMD_MISC_ee_GET_DATABLOCK_REC;\r\nparams[1] = 0x4;\r\n*((u32 *)&params[2]) = addr;\r\nparams[6] = clen;\r\nrc = smu_queue_cmd(&cmd);\r\nif (rc)\r\nreturn rc;\r\nwait_for_completion(&comp);\r\nif (cmd.status != 0)\r\nreturn rc;\r\nif (cmd.reply_len != clen) {\r\nprintk(KERN_DEBUG "SMU: short read in "\r\n"smu_read_datablock, got: %d, want: %d\n",\r\ncmd.reply_len, clen);\r\nreturn -EIO;\r\n}\r\nlen -= clen;\r\naddr += clen;\r\ndest += clen;\r\n}\r\nreturn 0;\r\n}\r\nstatic struct smu_sdbp_header *smu_create_sdb_partition(int id)\r\n{\r\nDECLARE_COMPLETION_ONSTACK(comp);\r\nstruct smu_simple_cmd cmd;\r\nunsigned int addr, len, tlen;\r\nstruct smu_sdbp_header *hdr;\r\nstruct property *prop;\r\nDPRINTK("SMU: Query partition infos ... (irq=%d)\n", smu->db_irq);\r\nsmu_queue_simple(&cmd, SMU_CMD_PARTITION_COMMAND, 2,\r\nsmu_done_complete, &comp,\r\nSMU_CMD_PARTITION_LATEST, id);\r\nwait_for_completion(&comp);\r\nDPRINTK("SMU: done, status: %d, reply_len: %d\n",\r\ncmd.cmd.status, cmd.cmd.reply_len);\r\nif (cmd.cmd.status != 0 || cmd.cmd.reply_len != 6)\r\nreturn NULL;\r\naddr = *((u16 *)cmd.buffer);\r\nlen = cmd.buffer[3] << 2;\r\ntlen = sizeof(struct property) + len + 18;\r\nprop = kzalloc(tlen, GFP_KERNEL);\r\nif (prop == NULL)\r\nreturn NULL;\r\nhdr = (struct smu_sdbp_header *)(prop + 1);\r\nprop->name = ((char *)prop) + tlen - 18;\r\nsprintf(prop->name, "sdb-partition-%02x", id);\r\nprop->length = len;\r\nprop->value = hdr;\r\nprop->next = NULL;\r\nif (smu_read_datablock((u8 *)hdr, addr, len)) {\r\nprintk(KERN_DEBUG "SMU: datablock read failed while reading "\r\n"partition %02x !\n", id);\r\ngoto failure;\r\n}\r\nif (hdr->id != id) {\r\nprintk(KERN_DEBUG "SMU: Reading partition %02x and got "\r\n"%02x !\n", id, hdr->id);\r\ngoto failure;\r\n}\r\nif (of_add_property(smu->of_node, prop)) {\r\nprintk(KERN_DEBUG "SMU: Failed creating sdb-partition-%02x "\r\n"property !\n", id);\r\ngoto failure;\r\n}\r\nreturn hdr;\r\nfailure:\r\nkfree(prop);\r\nreturn NULL;\r\n}\r\nconst struct smu_sdbp_header *__smu_get_sdb_partition(int id,\r\nunsigned int *size, int interruptible)\r\n{\r\nchar pname[32];\r\nconst struct smu_sdbp_header *part;\r\nif (!smu)\r\nreturn NULL;\r\nsprintf(pname, "sdb-partition-%02x", id);\r\nDPRINTK("smu_get_sdb_partition(%02x)\n", id);\r\nif (interruptible) {\r\nint rc;\r\nrc = mutex_lock_interruptible(&smu_part_access);\r\nif (rc)\r\nreturn ERR_PTR(rc);\r\n} else\r\nmutex_lock(&smu_part_access);\r\npart = of_get_property(smu->of_node, pname, size);\r\nif (part == NULL) {\r\nDPRINTK("trying to extract from SMU ...\n");\r\npart = smu_create_sdb_partition(id);\r\nif (part != NULL && size)\r\n*size = part->len << 2;\r\n}\r\nmutex_unlock(&smu_part_access);\r\nreturn part;\r\n}\r\nconst struct smu_sdbp_header *smu_get_sdb_partition(int id, unsigned int *size)\r\n{\r\nreturn __smu_get_sdb_partition(id, size, 0);\r\n}\r\nstatic int smu_open(struct inode *inode, struct file *file)\r\n{\r\nstruct smu_private *pp;\r\nunsigned long flags;\r\npp = kzalloc(sizeof(struct smu_private), GFP_KERNEL);\r\nif (pp == 0)\r\nreturn -ENOMEM;\r\nspin_lock_init(&pp->lock);\r\npp->mode = smu_file_commands;\r\ninit_waitqueue_head(&pp->wait);\r\nmutex_lock(&smu_mutex);\r\nspin_lock_irqsave(&smu_clist_lock, flags);\r\nlist_add(&pp->list, &smu_clist);\r\nspin_unlock_irqrestore(&smu_clist_lock, flags);\r\nfile->private_data = pp;\r\nmutex_unlock(&smu_mutex);\r\nreturn 0;\r\n}\r\nstatic void smu_user_cmd_done(struct smu_cmd *cmd, void *misc)\r\n{\r\nstruct smu_private *pp = misc;\r\nwake_up_all(&pp->wait);\r\n}\r\nstatic ssize_t smu_write(struct file *file, const char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct smu_private *pp = file->private_data;\r\nunsigned long flags;\r\nstruct smu_user_cmd_hdr hdr;\r\nint rc = 0;\r\nif (pp->busy)\r\nreturn -EBUSY;\r\nelse if (copy_from_user(&hdr, buf, sizeof(hdr)))\r\nreturn -EFAULT;\r\nelse if (hdr.cmdtype == SMU_CMDTYPE_WANTS_EVENTS) {\r\npp->mode = smu_file_events;\r\nreturn 0;\r\n} else if (hdr.cmdtype == SMU_CMDTYPE_GET_PARTITION) {\r\nconst struct smu_sdbp_header *part;\r\npart = __smu_get_sdb_partition(hdr.cmd, NULL, 1);\r\nif (part == NULL)\r\nreturn -EINVAL;\r\nelse if (IS_ERR(part))\r\nreturn PTR_ERR(part);\r\nreturn 0;\r\n} else if (hdr.cmdtype != SMU_CMDTYPE_SMU)\r\nreturn -EINVAL;\r\nelse if (pp->mode != smu_file_commands)\r\nreturn -EBADFD;\r\nelse if (hdr.data_len > SMU_MAX_DATA)\r\nreturn -EINVAL;\r\nspin_lock_irqsave(&pp->lock, flags);\r\nif (pp->busy) {\r\nspin_unlock_irqrestore(&pp->lock, flags);\r\nreturn -EBUSY;\r\n}\r\npp->busy = 1;\r\npp->cmd.status = 1;\r\nspin_unlock_irqrestore(&pp->lock, flags);\r\nif (copy_from_user(pp->buffer, buf + sizeof(hdr), hdr.data_len)) {\r\npp->busy = 0;\r\nreturn -EFAULT;\r\n}\r\npp->cmd.cmd = hdr.cmd;\r\npp->cmd.data_len = hdr.data_len;\r\npp->cmd.reply_len = SMU_MAX_DATA;\r\npp->cmd.data_buf = pp->buffer;\r\npp->cmd.reply_buf = pp->buffer;\r\npp->cmd.done = smu_user_cmd_done;\r\npp->cmd.misc = pp;\r\nrc = smu_queue_cmd(&pp->cmd);\r\nif (rc < 0)\r\nreturn rc;\r\nreturn count;\r\n}\r\nstatic ssize_t smu_read_command(struct file *file, struct smu_private *pp,\r\nchar __user *buf, size_t count)\r\n{\r\nDECLARE_WAITQUEUE(wait, current);\r\nstruct smu_user_reply_hdr hdr;\r\nunsigned long flags;\r\nint size, rc = 0;\r\nif (!pp->busy)\r\nreturn 0;\r\nif (count < sizeof(struct smu_user_reply_hdr))\r\nreturn -EOVERFLOW;\r\nspin_lock_irqsave(&pp->lock, flags);\r\nif (pp->cmd.status == 1) {\r\nif (file->f_flags & O_NONBLOCK) {\r\nspin_unlock_irqrestore(&pp->lock, flags);\r\nreturn -EAGAIN;\r\n}\r\nadd_wait_queue(&pp->wait, &wait);\r\nfor (;;) {\r\nset_current_state(TASK_INTERRUPTIBLE);\r\nrc = 0;\r\nif (pp->cmd.status != 1)\r\nbreak;\r\nrc = -ERESTARTSYS;\r\nif (signal_pending(current))\r\nbreak;\r\nspin_unlock_irqrestore(&pp->lock, flags);\r\nschedule();\r\nspin_lock_irqsave(&pp->lock, flags);\r\n}\r\nset_current_state(TASK_RUNNING);\r\nremove_wait_queue(&pp->wait, &wait);\r\n}\r\nspin_unlock_irqrestore(&pp->lock, flags);\r\nif (rc)\r\nreturn rc;\r\nif (pp->cmd.status != 0)\r\npp->cmd.reply_len = 0;\r\nsize = sizeof(hdr) + pp->cmd.reply_len;\r\nif (count < size)\r\nsize = count;\r\nrc = size;\r\nhdr.status = pp->cmd.status;\r\nhdr.reply_len = pp->cmd.reply_len;\r\nif (copy_to_user(buf, &hdr, sizeof(hdr)))\r\nreturn -EFAULT;\r\nsize -= sizeof(hdr);\r\nif (size && copy_to_user(buf + sizeof(hdr), pp->buffer, size))\r\nreturn -EFAULT;\r\npp->busy = 0;\r\nreturn rc;\r\n}\r\nstatic ssize_t smu_read_events(struct file *file, struct smu_private *pp,\r\nchar __user *buf, size_t count)\r\n{\r\nmsleep_interruptible(1000);\r\nreturn 0;\r\n}\r\nstatic ssize_t smu_read(struct file *file, char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct smu_private *pp = file->private_data;\r\nif (pp->mode == smu_file_commands)\r\nreturn smu_read_command(file, pp, buf, count);\r\nif (pp->mode == smu_file_events)\r\nreturn smu_read_events(file, pp, buf, count);\r\nreturn -EBADFD;\r\n}\r\nstatic unsigned int smu_fpoll(struct file *file, poll_table *wait)\r\n{\r\nstruct smu_private *pp = file->private_data;\r\nunsigned int mask = 0;\r\nunsigned long flags;\r\nif (pp == 0)\r\nreturn 0;\r\nif (pp->mode == smu_file_commands) {\r\npoll_wait(file, &pp->wait, wait);\r\nspin_lock_irqsave(&pp->lock, flags);\r\nif (pp->busy && pp->cmd.status != 1)\r\nmask |= POLLIN;\r\nspin_unlock_irqrestore(&pp->lock, flags);\r\n} if (pp->mode == smu_file_events) {\r\n}\r\nreturn mask;\r\n}\r\nstatic int smu_release(struct inode *inode, struct file *file)\r\n{\r\nstruct smu_private *pp = file->private_data;\r\nunsigned long flags;\r\nunsigned int busy;\r\nif (pp == 0)\r\nreturn 0;\r\nfile->private_data = NULL;\r\nspin_lock_irqsave(&pp->lock, flags);\r\npp->mode = smu_file_closing;\r\nbusy = pp->busy;\r\nif (busy && pp->cmd.status == 1) {\r\nDECLARE_WAITQUEUE(wait, current);\r\nadd_wait_queue(&pp->wait, &wait);\r\nfor (;;) {\r\nset_current_state(TASK_UNINTERRUPTIBLE);\r\nif (pp->cmd.status != 1)\r\nbreak;\r\nspin_unlock_irqrestore(&pp->lock, flags);\r\nschedule();\r\nspin_lock_irqsave(&pp->lock, flags);\r\n}\r\nset_current_state(TASK_RUNNING);\r\nremove_wait_queue(&pp->wait, &wait);\r\n}\r\nspin_unlock_irqrestore(&pp->lock, flags);\r\nspin_lock_irqsave(&smu_clist_lock, flags);\r\nlist_del(&pp->list);\r\nspin_unlock_irqrestore(&smu_clist_lock, flags);\r\nkfree(pp);\r\nreturn 0;\r\n}\r\nstatic int smu_device_init(void)\r\n{\r\nif (!smu)\r\nreturn -ENODEV;\r\nif (misc_register(&pmu_device) < 0)\r\nprintk(KERN_ERR "via-pmu: cannot register misc device.\n");\r\nreturn 0;\r\n}
