static int powernow_k6_get_cpu_multiplier(void)\r\n{\r\nu64 invalue = 0;\r\nu32 msrval;\r\nmsrval = POWERNOW_IOPORT + 0x1;\r\nwrmsr(MSR_K6_EPMR, msrval, 0);\r\ninvalue = inl(POWERNOW_IOPORT + 0x8);\r\nmsrval = POWERNOW_IOPORT + 0x0;\r\nwrmsr(MSR_K6_EPMR, msrval, 0);\r\nreturn clock_ratio[(invalue >> 5)&7].index;\r\n}\r\nstatic void powernow_k6_set_state(unsigned int best_i)\r\n{\r\nunsigned long outvalue = 0, invalue = 0;\r\nunsigned long msrval;\r\nstruct cpufreq_freqs freqs;\r\nif (clock_ratio[best_i].index > max_multiplier) {\r\nprintk(KERN_ERR PFX "invalid target frequency\n");\r\nreturn;\r\n}\r\nfreqs.old = busfreq * powernow_k6_get_cpu_multiplier();\r\nfreqs.new = busfreq * clock_ratio[best_i].index;\r\nfreqs.cpu = 0;\r\ncpufreq_notify_transition(&freqs, CPUFREQ_PRECHANGE);\r\noutvalue = (1<<12) | (1<<10) | (1<<9) | (best_i<<5);\r\nmsrval = POWERNOW_IOPORT + 0x1;\r\nwrmsr(MSR_K6_EPMR, msrval, 0);\r\ninvalue = inl(POWERNOW_IOPORT + 0x8);\r\ninvalue = invalue & 0xf;\r\noutvalue = outvalue | invalue;\r\noutl(outvalue , (POWERNOW_IOPORT + 0x8));\r\nmsrval = POWERNOW_IOPORT + 0x0;\r\nwrmsr(MSR_K6_EPMR, msrval, 0);\r\ncpufreq_notify_transition(&freqs, CPUFREQ_POSTCHANGE);\r\nreturn;\r\n}\r\nstatic int powernow_k6_verify(struct cpufreq_policy *policy)\r\n{\r\nreturn cpufreq_frequency_table_verify(policy, &clock_ratio[0]);\r\n}\r\nstatic int powernow_k6_target(struct cpufreq_policy *policy,\r\nunsigned int target_freq,\r\nunsigned int relation)\r\n{\r\nunsigned int newstate = 0;\r\nif (cpufreq_frequency_table_target(policy, &clock_ratio[0],\r\ntarget_freq, relation, &newstate))\r\nreturn -EINVAL;\r\npowernow_k6_set_state(newstate);\r\nreturn 0;\r\n}\r\nstatic int powernow_k6_cpu_init(struct cpufreq_policy *policy)\r\n{\r\nunsigned int i, f;\r\nint result;\r\nif (policy->cpu != 0)\r\nreturn -ENODEV;\r\nmax_multiplier = powernow_k6_get_cpu_multiplier();\r\nbusfreq = cpu_khz / max_multiplier;\r\nfor (i = 0; (clock_ratio[i].frequency != CPUFREQ_TABLE_END); i++) {\r\nf = clock_ratio[i].index;\r\nif (f > max_multiplier)\r\nclock_ratio[i].frequency = CPUFREQ_ENTRY_INVALID;\r\nelse\r\nclock_ratio[i].frequency = busfreq * f;\r\n}\r\npolicy->cpuinfo.transition_latency = 200000;\r\npolicy->cur = busfreq * max_multiplier;\r\nresult = cpufreq_frequency_table_cpuinfo(policy, clock_ratio);\r\nif (result)\r\nreturn result;\r\ncpufreq_frequency_table_get_attr(clock_ratio, policy->cpu);\r\nreturn 0;\r\n}\r\nstatic int powernow_k6_cpu_exit(struct cpufreq_policy *policy)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < 8; i++) {\r\nif (i == max_multiplier)\r\npowernow_k6_set_state(i);\r\n}\r\ncpufreq_frequency_table_put_attr(policy->cpu);\r\nreturn 0;\r\n}\r\nstatic unsigned int powernow_k6_get(unsigned int cpu)\r\n{\r\nunsigned int ret;\r\nret = (busfreq * powernow_k6_get_cpu_multiplier());\r\nreturn ret;\r\n}\r\nstatic int __init powernow_k6_init(void)\r\n{\r\nif (!x86_match_cpu(powernow_k6_ids))\r\nreturn -ENODEV;\r\nif (!request_region(POWERNOW_IOPORT, 16, "PowerNow!")) {\r\nprintk(KERN_INFO PFX "PowerNow IOPORT region already used.\n");\r\nreturn -EIO;\r\n}\r\nif (cpufreq_register_driver(&powernow_k6_driver)) {\r\nrelease_region(POWERNOW_IOPORT, 16);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic void __exit powernow_k6_exit(void)\r\n{\r\ncpufreq_unregister_driver(&powernow_k6_driver);\r\nrelease_region(POWERNOW_IOPORT, 16);\r\n}
