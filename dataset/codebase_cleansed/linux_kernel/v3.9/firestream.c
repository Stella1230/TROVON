static void my_hd (void *addr, int len)\r\n{\r\nint j, ch;\r\nunsigned char *ptr = addr;\r\nwhile (len > 0) {\r\nprintk ("%p ", ptr);\r\nfor (j=0;j < ((len < 16)?len:16);j++) {\r\nprintk ("%02x %s", ptr[j], (j==7)?" ":"");\r\n}\r\nfor ( ;j < 16;j++) {\r\nprintk (" %s", (j==7)?" ":"");\r\n}\r\nfor (j=0;j < ((len < 16)?len:16);j++) {\r\nch = ptr[j];\r\nprintk ("%c", (ch < 0x20)?'.':((ch > 0x7f)?'.':ch));\r\n}\r\nprintk ("\n");\r\nptr += 16;\r\nlen -= 16;\r\n}\r\n}\r\nstatic void my_hd (void *addr, int len){}\r\nstatic inline void fs_kfree_skb (struct sk_buff * skb)\r\n{\r\nif (ATM_SKB(skb)->vcc->pop)\r\nATM_SKB(skb)->vcc->pop (ATM_SKB(skb)->vcc, skb);\r\nelse\r\ndev_kfree_skb_any (skb);\r\n}\r\nstatic int make_rate(unsigned int rate, int r,\r\nu16 *bits, unsigned int *actual)\r\n{\r\nunsigned char exp = -1;\r\nunsigned int man = -1;\r\nfs_dprintk (FS_DEBUG_QOS, "make_rate %u", rate);\r\nif (rate > 0xffc00000U) {\r\nif (r == ROUND_UP) {\r\nreturn -EINVAL;\r\n} else {\r\nexp = 31;\r\nman = 511;\r\n}\r\n} else if (rate) {\r\nexp = 31;\r\nman = rate;\r\nwhile (!(man & (1<<31))) {\r\nexp = exp - 1;\r\nman = man<<1;\r\n}\r\nman = man<<1;\r\nman &= 0xffffffffU;\r\nswitch (r) {\r\ncase ROUND_DOWN: {\r\nman = man>>(32-9);\r\nbreak;\r\n}\r\ncase ROUND_UP: {\r\nif (man & (~0U>>9)) {\r\nman = (man>>(32-9)) + 1;\r\nif (man == (1<<9)) {\r\nman = 0;\r\nexp += 1;\r\n}\r\n} else {\r\nman = (man>>(32-9));\r\n}\r\nbreak;\r\n}\r\ncase ROUND_NEAREST: {\r\nif (man & (1<<(32-9-1))) {\r\nman = (man>>(32-9)) + 1;\r\nif (man == (1<<9)) {\r\nman = 0;\r\nexp += 1;\r\n}\r\n} else {\r\nman = (man>>(32-9));\r\n}\r\nbreak;\r\n}\r\n}\r\n} else {\r\nif (r == ROUND_DOWN) {\r\nreturn -EINVAL;\r\n} else {\r\nexp = 0;\r\nman = 0;\r\n}\r\n}\r\nfs_dprintk (FS_DEBUG_QOS, "rate: man=%u, exp=%hu", man, exp);\r\nif (bits)\r\n*bits = (exp<<9) | man;\r\nif (actual)\r\n*actual = (exp >= 9)\r\n? (1 << exp) + (man << (exp-9))\r\n: (1 << exp) + ((man + (1<<(9-exp-1))) >> (9-exp));\r\nreturn 0;\r\n}\r\nstatic inline void write_fs (struct fs_dev *dev, int offset, u32 val)\r\n{\r\nwritel (val, dev->base + offset);\r\n}\r\nstatic inline u32 read_fs (struct fs_dev *dev, int offset)\r\n{\r\nreturn readl (dev->base + offset);\r\n}\r\nstatic inline struct FS_QENTRY *get_qentry (struct fs_dev *dev, struct queue *q)\r\n{\r\nreturn bus_to_virt (read_fs (dev, Q_WP(q->offset)) & Q_ADDR_MASK);\r\n}\r\nstatic void submit_qentry (struct fs_dev *dev, struct queue *q, struct FS_QENTRY *qe)\r\n{\r\nu32 wp;\r\nstruct FS_QENTRY *cqe;\r\nwhile ((wp = read_fs (dev, Q_WP (q->offset))) & Q_FULL) {\r\nfs_dprintk (FS_DEBUG_TXQ, "Found queue at %x full. Waiting.\n",\r\nq->offset);\r\nschedule ();\r\n}\r\nwp &= ~0xf;\r\ncqe = bus_to_virt (wp);\r\nif (qe != cqe) {\r\nfs_dprintk (FS_DEBUG_TXQ, "q mismatch! %p %p\n", qe, cqe);\r\n}\r\nwrite_fs (dev, Q_WP(q->offset), Q_INCWRAP);\r\n{\r\nstatic int c;\r\nif (!(c++ % 100))\r\n{\r\nint rp, wp;\r\nrp = read_fs (dev, Q_RP(q->offset));\r\nwp = read_fs (dev, Q_WP(q->offset));\r\nfs_dprintk (FS_DEBUG_TXQ, "q at %d: %x-%x: %x entries.\n",\r\nq->offset, rp, wp, wp-rp);\r\n}\r\n}\r\n}\r\nstatic void submit_queue (struct fs_dev *dev, struct queue *q,\r\nu32 cmd, u32 p1, u32 p2, u32 p3)\r\n{\r\nstruct FS_QENTRY *qe;\r\nqe = get_qentry (dev, q);\r\nqe->cmd = cmd;\r\nqe->p0 = p1;\r\nqe->p1 = p2;\r\nqe->p2 = p3;\r\nsubmit_qentry (dev, q, qe);\r\n#ifdef DEBUG_EXTRA\r\npq[qp].cmd = cmd;\r\npq[qp].p0 = p1;\r\npq[qp].p1 = p2;\r\npq[qp].p2 = p3;\r\nqp++;\r\nif (qp >= 60) qp = 0;\r\n#endif\r\n}\r\nstatic void submit_command (struct fs_dev *dev, struct queue *q,\r\nu32 cmd, u32 p1, u32 p2, u32 p3)\r\n{\r\nwrite_fs (dev, CMDR0, cmd);\r\nwrite_fs (dev, CMDR1, p1);\r\nwrite_fs (dev, CMDR2, p2);\r\nwrite_fs (dev, CMDR3, p3);\r\n}\r\nstatic void process_return_queue (struct fs_dev *dev, struct queue *q)\r\n{\r\nlong rq;\r\nstruct FS_QENTRY *qe;\r\nvoid *tc;\r\nwhile (!((rq = read_fs (dev, Q_RP(q->offset))) & Q_EMPTY)) {\r\nfs_dprintk (FS_DEBUG_QUEUE, "reaping return queue entry at %lx\n", rq);\r\nqe = bus_to_virt (rq);\r\nfs_dprintk (FS_DEBUG_QUEUE, "queue entry: %08x %08x %08x %08x. (%d)\n",\r\nqe->cmd, qe->p0, qe->p1, qe->p2, STATUS_CODE (qe));\r\nswitch (STATUS_CODE (qe)) {\r\ncase 5:\r\ntc = bus_to_virt (qe->p0);\r\nfs_dprintk (FS_DEBUG_ALLOC, "Free tc: %p\n", tc);\r\nkfree (tc);\r\nbreak;\r\n}\r\nwrite_fs (dev, Q_RP(q->offset), Q_INCWRAP);\r\n}\r\n}\r\nstatic void process_txdone_queue (struct fs_dev *dev, struct queue *q)\r\n{\r\nlong rq;\r\nlong tmp;\r\nstruct FS_QENTRY *qe;\r\nstruct sk_buff *skb;\r\nstruct FS_BPENTRY *td;\r\nwhile (!((rq = read_fs (dev, Q_RP(q->offset))) & Q_EMPTY)) {\r\nfs_dprintk (FS_DEBUG_QUEUE, "reaping txdone entry at %lx\n", rq);\r\nqe = bus_to_virt (rq);\r\nfs_dprintk (FS_DEBUG_QUEUE, "queue entry: %08x %08x %08x %08x: %d\n",\r\nqe->cmd, qe->p0, qe->p1, qe->p2, STATUS_CODE (qe));\r\nif (STATUS_CODE (qe) != 2)\r\nfs_dprintk (FS_DEBUG_TXMEM, "queue entry: %08x %08x %08x %08x: %d\n",\r\nqe->cmd, qe->p0, qe->p1, qe->p2, STATUS_CODE (qe));\r\nswitch (STATUS_CODE (qe)) {\r\ncase 0x01:\r\ncase 0x02:\r\ntmp = qe->p0;\r\nif (tmp & 0x0f)\r\nprintk (KERN_WARNING "td not aligned: %ld\n", tmp);\r\ntmp &= ~0x0f;\r\ntd = bus_to_virt (tmp);\r\nfs_dprintk (FS_DEBUG_QUEUE, "Pool entry: %08x %08x %08x %08x %p.\n",\r\ntd->flags, td->next, td->bsa, td->aal_bufsize, td->skb );\r\nskb = td->skb;\r\nif (skb == FS_VCC (ATM_SKB(skb)->vcc)->last_skb) {\r\nwake_up_interruptible (& FS_VCC (ATM_SKB(skb)->vcc)->close_wait);\r\nFS_VCC (ATM_SKB(skb)->vcc)->last_skb = NULL;\r\n}\r\ntd->dev->ntxpckts--;\r\n{\r\nstatic int c=0;\r\nif (!(c++ % 100)) {\r\nfs_dprintk (FS_DEBUG_QSIZE, "[%d]", td->dev->ntxpckts);\r\n}\r\n}\r\natomic_inc(&ATM_SKB(skb)->vcc->stats->tx);\r\nfs_dprintk (FS_DEBUG_TXMEM, "i");\r\nfs_dprintk (FS_DEBUG_ALLOC, "Free t-skb: %p\n", skb);\r\nfs_kfree_skb (skb);\r\nfs_dprintk (FS_DEBUG_ALLOC, "Free trans-d: %p\n", td);\r\nmemset (td, ATM_POISON_FREE, sizeof(struct FS_BPENTRY));\r\nkfree (td);\r\nbreak;\r\ndefault:\r\n;\r\n}\r\nwrite_fs (dev, Q_RP(q->offset), Q_INCWRAP);\r\n}\r\n}\r\nstatic void process_incoming (struct fs_dev *dev, struct queue *q)\r\n{\r\nlong rq;\r\nstruct FS_QENTRY *qe;\r\nstruct FS_BPENTRY *pe;\r\nstruct sk_buff *skb;\r\nunsigned int channo;\r\nstruct atm_vcc *atm_vcc;\r\nwhile (!((rq = read_fs (dev, Q_RP(q->offset))) & Q_EMPTY)) {\r\nfs_dprintk (FS_DEBUG_QUEUE, "reaping incoming queue entry at %lx\n", rq);\r\nqe = bus_to_virt (rq);\r\nfs_dprintk (FS_DEBUG_QUEUE, "queue entry: %08x %08x %08x %08x. ",\r\nqe->cmd, qe->p0, qe->p1, qe->p2);\r\nfs_dprintk (FS_DEBUG_QUEUE, "-> %x: %s\n",\r\nSTATUS_CODE (qe),\r\nres_strings[STATUS_CODE(qe)]);\r\npe = bus_to_virt (qe->p0);\r\nfs_dprintk (FS_DEBUG_QUEUE, "Pool entry: %08x %08x %08x %08x %p %p.\n",\r\npe->flags, pe->next, pe->bsa, pe->aal_bufsize,\r\npe->skb, pe->fp);\r\nchanno = qe->cmd & 0xffff;\r\nif (channo < dev->nchannels)\r\natm_vcc = dev->atm_vccs[channo];\r\nelse\r\natm_vcc = NULL;\r\nswitch (STATUS_CODE (qe)) {\r\ncase 0x1:\r\ncase 0x2:\r\nif (atm_vcc) {\r\nskb = pe->skb;\r\npe->fp->n--;\r\n#if 0\r\nfs_dprintk (FS_DEBUG_QUEUE, "Got skb: %p\n", skb);\r\nif (FS_DEBUG_QUEUE & fs_debug) my_hd (bus_to_virt (pe->bsa), 0x20);\r\n#endif\r\nskb_put (skb, qe->p1 & 0xffff);\r\nATM_SKB(skb)->vcc = atm_vcc;\r\natomic_inc(&atm_vcc->stats->rx);\r\n__net_timestamp(skb);\r\nfs_dprintk (FS_DEBUG_ALLOC, "Free rec-skb: %p (pushed)\n", skb);\r\natm_vcc->push (atm_vcc, skb);\r\nfs_dprintk (FS_DEBUG_ALLOC, "Free rec-d: %p\n", pe);\r\nkfree (pe);\r\n} else {\r\nprintk (KERN_ERR "Got a receive on a non-open channel %d.\n", channo);\r\n}\r\nbreak;\r\ncase 0x17:\r\nif (qe->p1 & 0xffff) {\r\npe = bus_to_virt (qe->p0);\r\npe->fp->n--;\r\nfs_dprintk (FS_DEBUG_ALLOC, "Free rec-skb: %p\n", pe->skb);\r\ndev_kfree_skb_any (pe->skb);\r\nfs_dprintk (FS_DEBUG_ALLOC, "Free rec-d: %p\n", pe);\r\nkfree (pe);\r\n}\r\nif (atm_vcc)\r\natomic_inc(&atm_vcc->stats->rx_drop);\r\nbreak;\r\ncase 0x1f:\r\nif (atm_vcc)\r\natomic_inc(&atm_vcc->stats->rx_drop);\r\nbreak;\r\ndefault:\r\nprintk (KERN_WARNING "Don't know what to do with RX status %x: %s.\n",\r\nSTATUS_CODE(qe), res_strings[STATUS_CODE (qe)]);\r\n}\r\nwrite_fs (dev, Q_RP(q->offset), Q_INCWRAP);\r\n}\r\n}\r\nstatic int fs_open(struct atm_vcc *atm_vcc)\r\n{\r\nstruct fs_dev *dev;\r\nstruct fs_vcc *vcc;\r\nstruct fs_transmit_config *tc;\r\nstruct atm_trafprm * txtp;\r\nstruct atm_trafprm * rxtp;\r\nint error;\r\nint bfp;\r\nint to;\r\nunsigned short tmc0;\r\nshort vpi = atm_vcc->vpi;\r\nint vci = atm_vcc->vci;\r\nfunc_enter ();\r\ndev = FS_DEV(atm_vcc->dev);\r\nfs_dprintk (FS_DEBUG_OPEN, "fs: open on dev: %p, vcc at %p\n",\r\ndev, atm_vcc);\r\nif (vci != ATM_VPI_UNSPEC && vpi != ATM_VCI_UNSPEC)\r\nset_bit(ATM_VF_ADDR, &atm_vcc->flags);\r\nif ((atm_vcc->qos.aal != ATM_AAL5) &&\r\n(atm_vcc->qos.aal != ATM_AAL2))\r\nreturn -EINVAL;\r\nfs_dprintk (FS_DEBUG_OPEN, "fs: (itf %d): open %d.%d\n",\r\natm_vcc->dev->number, atm_vcc->vpi, atm_vcc->vci);\r\nvcc = kmalloc(sizeof(struct fs_vcc), GFP_KERNEL);\r\nfs_dprintk (FS_DEBUG_ALLOC, "Alloc VCC: %p(%Zd)\n", vcc, sizeof(struct fs_vcc));\r\nif (!vcc) {\r\nclear_bit(ATM_VF_ADDR, &atm_vcc->flags);\r\nreturn -ENOMEM;\r\n}\r\natm_vcc->dev_data = vcc;\r\nvcc->last_skb = NULL;\r\ninit_waitqueue_head (&vcc->close_wait);\r\ntxtp = &atm_vcc->qos.txtp;\r\nrxtp = &atm_vcc->qos.rxtp;\r\nif (!test_bit(ATM_VF_PARTIAL, &atm_vcc->flags)) {\r\nif (IS_FS50(dev)) {\r\nfor (to=33;to;to--, dev->channo++) {\r\nif (dev->channo >= 32)\r\ndev->channo = 0;\r\nif (DO_DIRECTION(rxtp) && dev->atm_vccs[dev->channo])\r\ncontinue;\r\nif (DO_DIRECTION(txtp) && test_bit (dev->channo, dev->tx_inuse))\r\ncontinue;\r\nbreak;\r\n}\r\nif (!to) {\r\nprintk ("No more free channels for FS50..\n");\r\nreturn -EBUSY;\r\n}\r\nvcc->channo = dev->channo;\r\ndev->channo &= dev->channel_mask;\r\n} else {\r\nvcc->channo = (vpi << FS155_VCI_BITS) | (vci);\r\nif (((DO_DIRECTION(rxtp) && dev->atm_vccs[vcc->channo])) ||\r\n( DO_DIRECTION(txtp) && test_bit (vcc->channo, dev->tx_inuse))) {\r\nprintk ("Channel is in use for FS155.\n");\r\nreturn -EBUSY;\r\n}\r\n}\r\nfs_dprintk (FS_DEBUG_OPEN, "OK. Allocated channel %x(%d).\n",\r\nvcc->channo, vcc->channo);\r\n}\r\nif (DO_DIRECTION (txtp)) {\r\ntc = kmalloc (sizeof (struct fs_transmit_config), GFP_KERNEL);\r\nfs_dprintk (FS_DEBUG_ALLOC, "Alloc tc: %p(%Zd)\n",\r\ntc, sizeof (struct fs_transmit_config));\r\nif (!tc) {\r\nfs_dprintk (FS_DEBUG_OPEN, "fs: can't alloc transmit_config.\n");\r\nreturn -ENOMEM;\r\n}\r\nswitch (atm_vcc->qos.aal) {\r\ncase ATM_AAL2:\r\ncase ATM_AAL0:\r\ntc->flags = 0\r\n| TC_FLAGS_TRANSPARENT_PAYLOAD\r\n| TC_FLAGS_PACKET\r\n| (1 << 28)\r\n| TC_FLAGS_TYPE_UBR\r\n| TC_FLAGS_CAL0;\r\nbreak;\r\ncase ATM_AAL5:\r\ntc->flags = 0\r\n| TC_FLAGS_AAL5\r\n| TC_FLAGS_PACKET\r\n| TC_FLAGS_TYPE_CBR\r\n| TC_FLAGS_CAL0;\r\nbreak;\r\ndefault:\r\nprintk ("Unknown aal: %d\n", atm_vcc->qos.aal);\r\ntc->flags = 0;\r\n}\r\ntc->atm_hdr = (vpi << 20) | (vci << 4);\r\ntmc0 = 0;\r\n{\r\nint pcr = atm_pcr_goal (txtp);\r\nfs_dprintk (FS_DEBUG_OPEN, "pcr = %d.\n", pcr);\r\nif (IS_FS50(dev)) {\r\nif (pcr > 51840000/53/8) pcr = 51840000/53/8;\r\n} else {\r\nif (pcr > 155520000/53/8) pcr = 155520000/53/8;\r\n}\r\nif (!pcr) {\r\ntmc0 = IS_FS50(dev)?0x61BE:0x64c9;\r\n} else {\r\nint r;\r\nif (pcr < 0) {\r\nr = ROUND_DOWN;\r\npcr = -pcr;\r\n} else {\r\nr = ROUND_UP;\r\n}\r\nerror = make_rate (pcr, r, &tmc0, NULL);\r\nif (error) {\r\nkfree(tc);\r\nreturn error;\r\n}\r\n}\r\nfs_dprintk (FS_DEBUG_OPEN, "pcr = %d.\n", pcr);\r\n}\r\ntc->TMC[0] = tmc0 | 0x4000;\r\ntc->TMC[1] = 0;\r\ntc->TMC[2] = 0;\r\ntc->TMC[3] = 0;\r\ntc->spec = 0;\r\ntc->rtag[0] = 0;\r\ntc->rtag[1] = 0;\r\ntc->rtag[2] = 0;\r\nif (fs_debug & FS_DEBUG_OPEN) {\r\nfs_dprintk (FS_DEBUG_OPEN, "TX config record:\n");\r\nmy_hd (tc, sizeof (*tc));\r\n}\r\nsubmit_command (dev, &dev->hp_txq,\r\nQE_CMD_CONFIG_TX | QE_CMD_IMM_INQ | vcc->channo,\r\nvirt_to_bus (tc), 0, 0);\r\nsubmit_command (dev, &dev->hp_txq,\r\nQE_CMD_TX_EN | QE_CMD_IMM_INQ | vcc->channo,\r\n0, 0, 0);\r\nset_bit (vcc->channo, dev->tx_inuse);\r\n}\r\nif (DO_DIRECTION (rxtp)) {\r\ndev->atm_vccs[vcc->channo] = atm_vcc;\r\nfor (bfp = 0;bfp < FS_NR_FREE_POOLS; bfp++)\r\nif (atm_vcc->qos.rxtp.max_sdu <= dev->rx_fp[bfp].bufsize) break;\r\nif (bfp >= FS_NR_FREE_POOLS) {\r\nfs_dprintk (FS_DEBUG_OPEN, "No free pool fits sdu: %d.\n",\r\natm_vcc->qos.rxtp.max_sdu);\r\ndev->atm_vccs[vcc->channo] = NULL;\r\nkfree (vcc);\r\nreturn -EINVAL;\r\n}\r\nswitch (atm_vcc->qos.aal) {\r\ncase ATM_AAL0:\r\ncase ATM_AAL2:\r\nsubmit_command (dev, &dev->hp_txq,\r\nQE_CMD_CONFIG_RX | QE_CMD_IMM_INQ | vcc->channo,\r\nRC_FLAGS_TRANSP |\r\nRC_FLAGS_BFPS_BFP * bfp |\r\nRC_FLAGS_RXBM_PSB, 0, 0);\r\nbreak;\r\ncase ATM_AAL5:\r\nsubmit_command (dev, &dev->hp_txq,\r\nQE_CMD_CONFIG_RX | QE_CMD_IMM_INQ | vcc->channo,\r\nRC_FLAGS_AAL5 |\r\nRC_FLAGS_BFPS_BFP * bfp |\r\nRC_FLAGS_RXBM_PSB, 0, 0);\r\nbreak;\r\n};\r\nif (IS_FS50 (dev)) {\r\nsubmit_command (dev, &dev->hp_txq,\r\nQE_CMD_REG_WR | QE_CMD_IMM_INQ,\r\n0x80 + vcc->channo,\r\n(vpi << 16) | vci, 0 );\r\n}\r\nsubmit_command (dev, &dev->hp_txq,\r\nQE_CMD_RX_EN | QE_CMD_IMM_INQ | vcc->channo,\r\n0, 0, 0);\r\n}\r\nset_bit(ATM_VF_READY, &atm_vcc->flags);\r\nfunc_exit ();\r\nreturn 0;\r\n}\r\nstatic void fs_close(struct atm_vcc *atm_vcc)\r\n{\r\nstruct fs_dev *dev = FS_DEV (atm_vcc->dev);\r\nstruct fs_vcc *vcc = FS_VCC (atm_vcc);\r\nstruct atm_trafprm * txtp;\r\nstruct atm_trafprm * rxtp;\r\nfunc_enter ();\r\nclear_bit(ATM_VF_READY, &atm_vcc->flags);\r\nfs_dprintk (FS_DEBUG_QSIZE, "--==**[%d]**==--", dev->ntxpckts);\r\nif (vcc->last_skb) {\r\nfs_dprintk (FS_DEBUG_QUEUE, "Waiting for skb %p to be sent.\n",\r\nvcc->last_skb);\r\ninterruptible_sleep_on (& vcc->close_wait);\r\n}\r\ntxtp = &atm_vcc->qos.txtp;\r\nrxtp = &atm_vcc->qos.rxtp;\r\nif (DO_DIRECTION (txtp)) {\r\nsubmit_command (dev, &dev->hp_txq,\r\nQE_CMD_TX_PURGE_INH | vcc->channo, 0,0,0);\r\nclear_bit (vcc->channo, dev->tx_inuse);\r\n}\r\nif (DO_DIRECTION (rxtp)) {\r\nsubmit_command (dev, &dev->hp_txq,\r\nQE_CMD_RX_PURGE_INH | QE_CMD_IMM_INQ | vcc->channo, 0,0,0);\r\ndev->atm_vccs [vcc->channo] = NULL;\r\nif (IS_FS50 (dev)) {\r\nsubmit_command (dev, &dev->hp_txq,\r\nQE_CMD_REG_WR | QE_CMD_IMM_INQ,\r\n0x80 + vcc->channo, -1, 0 );\r\n}\r\n}\r\nfs_dprintk (FS_DEBUG_ALLOC, "Free vcc: %p\n", vcc);\r\nkfree (vcc);\r\nfunc_exit ();\r\n}\r\nstatic int fs_send (struct atm_vcc *atm_vcc, struct sk_buff *skb)\r\n{\r\nstruct fs_dev *dev = FS_DEV (atm_vcc->dev);\r\nstruct fs_vcc *vcc = FS_VCC (atm_vcc);\r\nstruct FS_BPENTRY *td;\r\nfunc_enter ();\r\nfs_dprintk (FS_DEBUG_TXMEM, "I");\r\nfs_dprintk (FS_DEBUG_SEND, "Send: atm_vcc %p skb %p vcc %p dev %p\n",\r\natm_vcc, skb, vcc, dev);\r\nfs_dprintk (FS_DEBUG_ALLOC, "Alloc t-skb: %p (atm_send)\n", skb);\r\nATM_SKB(skb)->vcc = atm_vcc;\r\nvcc->last_skb = skb;\r\ntd = kmalloc (sizeof (struct FS_BPENTRY), GFP_ATOMIC);\r\nfs_dprintk (FS_DEBUG_ALLOC, "Alloc transd: %p(%Zd)\n", td, sizeof (struct FS_BPENTRY));\r\nif (!td) {\r\nreturn -ENOMEM;\r\n}\r\nfs_dprintk (FS_DEBUG_SEND, "first word in buffer: %x\n",\r\n*(int *) skb->data);\r\ntd->flags = TD_EPI | TD_DATA | skb->len;\r\ntd->next = 0;\r\ntd->bsa = virt_to_bus (skb->data);\r\ntd->skb = skb;\r\ntd->dev = dev;\r\ndev->ntxpckts++;\r\n#ifdef DEBUG_EXTRA\r\nda[qd] = td;\r\ndq[qd].flags = td->flags;\r\ndq[qd].next = td->next;\r\ndq[qd].bsa = td->bsa;\r\ndq[qd].skb = td->skb;\r\ndq[qd].dev = td->dev;\r\nqd++;\r\nif (qd >= 60) qd = 0;\r\n#endif\r\nsubmit_queue (dev, &dev->hp_txq,\r\nQE_TRANSMIT_DE | vcc->channo,\r\nvirt_to_bus (td), 0,\r\nvirt_to_bus (td));\r\nfs_dprintk (FS_DEBUG_QUEUE, "in send: txq %d txrq %d\n",\r\nread_fs (dev, Q_EA (dev->hp_txq.offset)) -\r\nread_fs (dev, Q_SA (dev->hp_txq.offset)),\r\nread_fs (dev, Q_EA (dev->tx_relq.offset)) -\r\nread_fs (dev, Q_SA (dev->tx_relq.offset)));\r\nfunc_exit ();\r\nreturn 0;\r\n}\r\nstatic void undocumented_pci_fix(struct pci_dev *pdev)\r\n{\r\nu32 tint;\r\npci_read_config_dword (pdev, 0x28, &tint);\r\nif (tint != 0x80) {\r\ntint = 0x80;\r\npci_write_config_dword (pdev, 0x28, tint);\r\n}\r\n}\r\nstatic void write_phy(struct fs_dev *dev, int regnum, int val)\r\n{\r\nsubmit_command (dev, &dev->hp_txq, QE_CMD_PRP_WR | QE_CMD_IMM_INQ,\r\nregnum, val, 0);\r\n}\r\nstatic int init_phy(struct fs_dev *dev, struct reginit_item *reginit)\r\n{\r\nint i;\r\nfunc_enter ();\r\nwhile (reginit->reg != PHY_EOF) {\r\nif (reginit->reg == PHY_CLEARALL) {\r\nfor (i=0;i<reginit->val;i++) {\r\nwrite_phy (dev, i, 0);\r\n}\r\n} else {\r\nwrite_phy (dev, reginit->reg, reginit->val);\r\n}\r\nreginit++;\r\n}\r\nfunc_exit ();\r\nreturn 0;\r\n}\r\nstatic void reset_chip (struct fs_dev *dev)\r\n{\r\nint i;\r\nwrite_fs (dev, SARMODE0, SARMODE0_SRTS0);\r\nudelay (128);\r\nfor (i=0;i < FS_NR_FREE_POOLS;i++) {\r\nwrite_fs (dev, FP_CNF (RXB_FP(i)), 0);\r\nwrite_fs (dev, FP_SA (RXB_FP(i)), 0);\r\nwrite_fs (dev, FP_EA (RXB_FP(i)), 0);\r\nwrite_fs (dev, FP_CNT (RXB_FP(i)), 0);\r\nwrite_fs (dev, FP_CTU (RXB_FP(i)), 0);\r\n}\r\nif (IS_FS50 (dev)) {\r\nfor (i=0;i<FS50_NR_CHANNELS;i++) {\r\nwrite_fs (dev, 0x200 + i * 4, -1);\r\n}\r\n}\r\n}\r\nstatic void *aligned_kmalloc(int size, gfp_t flags, int alignment)\r\n{\r\nvoid *t;\r\nif (alignment <= 0x10) {\r\nt = kmalloc (size, flags);\r\nif ((unsigned long)t & (alignment-1)) {\r\nprintk ("Kmalloc doesn't align things correctly! %p\n", t);\r\nkfree (t);\r\nreturn aligned_kmalloc (size, flags, alignment * 4);\r\n}\r\nreturn t;\r\n}\r\nprintk (KERN_ERR "Request for > 0x10 alignment not yet implemented (hard!)\n");\r\nreturn NULL;\r\n}\r\nstatic int init_q(struct fs_dev *dev, struct queue *txq, int queue,\r\nint nentries, int is_rq)\r\n{\r\nint sz = nentries * sizeof (struct FS_QENTRY);\r\nstruct FS_QENTRY *p;\r\nfunc_enter ();\r\nfs_dprintk (FS_DEBUG_INIT, "Inititing queue at %x: %d entries:\n",\r\nqueue, nentries);\r\np = aligned_kmalloc (sz, GFP_KERNEL, 0x10);\r\nfs_dprintk (FS_DEBUG_ALLOC, "Alloc queue: %p(%d)\n", p, sz);\r\nif (!p) return 0;\r\nwrite_fs (dev, Q_SA(queue), virt_to_bus(p));\r\nwrite_fs (dev, Q_EA(queue), virt_to_bus(p+nentries-1));\r\nwrite_fs (dev, Q_WP(queue), virt_to_bus(p));\r\nwrite_fs (dev, Q_RP(queue), virt_to_bus(p));\r\nif (is_rq) {\r\nwrite_fs (dev, Q_CNF(queue), 0 );\r\n}\r\ntxq->sa = p;\r\ntxq->ea = p;\r\ntxq->offset = queue;\r\nfunc_exit ();\r\nreturn 1;\r\n}\r\nstatic int init_fp(struct fs_dev *dev, struct freepool *fp, int queue,\r\nint bufsize, int nr_buffers)\r\n{\r\nfunc_enter ();\r\nfs_dprintk (FS_DEBUG_INIT, "Inititing free pool at %x:\n", queue);\r\nwrite_fs (dev, FP_CNF(queue), (bufsize * RBFP_RBS) | RBFP_RBSVAL | RBFP_CME);\r\nwrite_fs (dev, FP_SA(queue), 0);\r\nwrite_fs (dev, FP_EA(queue), 0);\r\nwrite_fs (dev, FP_CTU(queue), 0);\r\nwrite_fs (dev, FP_CNT(queue), 0);\r\nfp->offset = queue;\r\nfp->bufsize = bufsize;\r\nfp->nr_buffers = nr_buffers;\r\nfunc_exit ();\r\nreturn 1;\r\n}\r\nstatic inline int nr_buffers_in_freepool (struct fs_dev *dev, struct freepool *fp)\r\n{\r\n#if 0\r\nreturn read_fs (dev, FP_CNT (fp->offset));\r\n#else\r\nreturn fp->n;\r\n#endif\r\n}\r\nstatic void top_off_fp (struct fs_dev *dev, struct freepool *fp,\r\ngfp_t gfp_flags)\r\n{\r\nstruct FS_BPENTRY *qe, *ne;\r\nstruct sk_buff *skb;\r\nint n = 0;\r\nu32 qe_tmp;\r\nfs_dprintk (FS_DEBUG_QUEUE, "Topping off queue at %x (%d-%d/%d)\n",\r\nfp->offset, read_fs (dev, FP_CNT (fp->offset)), fp->n,\r\nfp->nr_buffers);\r\nwhile (nr_buffers_in_freepool(dev, fp) < fp->nr_buffers) {\r\nskb = alloc_skb (fp->bufsize, gfp_flags);\r\nfs_dprintk (FS_DEBUG_ALLOC, "Alloc rec-skb: %p(%d)\n", skb, fp->bufsize);\r\nif (!skb) break;\r\nne = kmalloc (sizeof (struct FS_BPENTRY), gfp_flags);\r\nfs_dprintk (FS_DEBUG_ALLOC, "Alloc rec-d: %p(%Zd)\n", ne, sizeof (struct FS_BPENTRY));\r\nif (!ne) {\r\nfs_dprintk (FS_DEBUG_ALLOC, "Free rec-skb: %p\n", skb);\r\ndev_kfree_skb_any (skb);\r\nbreak;\r\n}\r\nfs_dprintk (FS_DEBUG_QUEUE, "Adding skb %p desc %p -> %p(%p) ",\r\nskb, ne, skb->data, skb->head);\r\nn++;\r\nne->flags = FP_FLAGS_EPI | fp->bufsize;\r\nne->next = virt_to_bus (NULL);\r\nne->bsa = virt_to_bus (skb->data);\r\nne->aal_bufsize = fp->bufsize;\r\nne->skb = skb;\r\nne->fp = fp;\r\nqe_tmp = read_fs (dev, FP_EA(fp->offset));\r\nfs_dprintk (FS_DEBUG_QUEUE, "link at %x\n", qe_tmp);\r\nif (qe_tmp) {\r\nqe = bus_to_virt ((long) qe_tmp);\r\nqe->next = virt_to_bus(ne);\r\nqe->flags &= ~FP_FLAGS_EPI;\r\n} else\r\nwrite_fs (dev, FP_SA(fp->offset), virt_to_bus(ne));\r\nwrite_fs (dev, FP_EA(fp->offset), virt_to_bus (ne));\r\nfp->n++;\r\nwrite_fs (dev, FP_CTU(fp->offset), 1);\r\n}\r\nfs_dprintk (FS_DEBUG_QUEUE, "Added %d entries. \n", n);\r\n}\r\nstatic void free_queue(struct fs_dev *dev, struct queue *txq)\r\n{\r\nfunc_enter ();\r\nwrite_fs (dev, Q_SA(txq->offset), 0);\r\nwrite_fs (dev, Q_EA(txq->offset), 0);\r\nwrite_fs (dev, Q_RP(txq->offset), 0);\r\nwrite_fs (dev, Q_WP(txq->offset), 0);\r\nfs_dprintk (FS_DEBUG_ALLOC, "Free queue: %p\n", txq->sa);\r\nkfree (txq->sa);\r\nfunc_exit ();\r\n}\r\nstatic void free_freepool(struct fs_dev *dev, struct freepool *fp)\r\n{\r\nfunc_enter ();\r\nwrite_fs (dev, FP_CNF(fp->offset), 0);\r\nwrite_fs (dev, FP_SA (fp->offset), 0);\r\nwrite_fs (dev, FP_EA (fp->offset), 0);\r\nwrite_fs (dev, FP_CNT(fp->offset), 0);\r\nwrite_fs (dev, FP_CTU(fp->offset), 0);\r\nfunc_exit ();\r\n}\r\nstatic irqreturn_t fs_irq (int irq, void *dev_id)\r\n{\r\nint i;\r\nu32 status;\r\nstruct fs_dev *dev = dev_id;\r\nstatus = read_fs (dev, ISR);\r\nif (!status)\r\nreturn IRQ_NONE;\r\nfunc_enter ();\r\n#ifdef IRQ_RATE_LIMIT\r\n{\r\nstatic int lastjif;\r\nstatic int nintr=0;\r\nif (lastjif == jiffies) {\r\nif (++nintr > IRQ_RATE_LIMIT) {\r\nfree_irq (dev->irq, dev_id);\r\nprintk (KERN_ERR "fs: Too many interrupts. Turning off interrupt %d.\n",\r\ndev->irq);\r\n}\r\n} else {\r\nlastjif = jiffies;\r\nnintr = 0;\r\n}\r\n}\r\n#endif\r\nfs_dprintk (FS_DEBUG_QUEUE, "in intr: txq %d txrq %d\n",\r\nread_fs (dev, Q_EA (dev->hp_txq.offset)) -\r\nread_fs (dev, Q_SA (dev->hp_txq.offset)),\r\nread_fs (dev, Q_EA (dev->tx_relq.offset)) -\r\nread_fs (dev, Q_SA (dev->tx_relq.offset)));\r\nif (fs_debug & FS_DEBUG_IRQ) {\r\nfs_dprintk (FS_DEBUG_IRQ, "IRQ status:");\r\nfor (i=0;i<27;i++)\r\nif (status & (1 << i))\r\nfs_dprintk (FS_DEBUG_IRQ, " %s", irq_bitname[i]);\r\nfs_dprintk (FS_DEBUG_IRQ, "\n");\r\n}\r\nif (status & ISR_RBRQ0_W) {\r\nfs_dprintk (FS_DEBUG_IRQ, "Iiiin-coming (0)!!!!\n");\r\nprocess_incoming (dev, &dev->rx_rq[0]);\r\ntop_off_fp (dev, &dev->rx_fp[0], GFP_ATOMIC);\r\ntop_off_fp (dev, &dev->rx_fp[1], GFP_ATOMIC);\r\n}\r\nif (status & ISR_RBRQ1_W) {\r\nfs_dprintk (FS_DEBUG_IRQ, "Iiiin-coming (1)!!!!\n");\r\nprocess_incoming (dev, &dev->rx_rq[1]);\r\ntop_off_fp (dev, &dev->rx_fp[2], GFP_ATOMIC);\r\ntop_off_fp (dev, &dev->rx_fp[3], GFP_ATOMIC);\r\n}\r\nif (status & ISR_RBRQ2_W) {\r\nfs_dprintk (FS_DEBUG_IRQ, "Iiiin-coming (2)!!!!\n");\r\nprocess_incoming (dev, &dev->rx_rq[2]);\r\ntop_off_fp (dev, &dev->rx_fp[4], GFP_ATOMIC);\r\ntop_off_fp (dev, &dev->rx_fp[5], GFP_ATOMIC);\r\n}\r\nif (status & ISR_RBRQ3_W) {\r\nfs_dprintk (FS_DEBUG_IRQ, "Iiiin-coming (3)!!!!\n");\r\nprocess_incoming (dev, &dev->rx_rq[3]);\r\ntop_off_fp (dev, &dev->rx_fp[6], GFP_ATOMIC);\r\ntop_off_fp (dev, &dev->rx_fp[7], GFP_ATOMIC);\r\n}\r\nif (status & ISR_CSQ_W) {\r\nfs_dprintk (FS_DEBUG_IRQ, "Command executed ok!\n");\r\nprocess_return_queue (dev, &dev->st_q);\r\n}\r\nif (status & ISR_TBRQ_W) {\r\nfs_dprintk (FS_DEBUG_IRQ, "Data tramsitted!\n");\r\nprocess_txdone_queue (dev, &dev->tx_relq);\r\n}\r\nfunc_exit ();\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void fs_poll (unsigned long data)\r\n{\r\nstruct fs_dev *dev = (struct fs_dev *) data;\r\nfs_irq (0, dev);\r\ndev->timer.expires = jiffies + FS_POLL_FREQ;\r\nadd_timer (&dev->timer);\r\n}\r\nstatic int fs_init(struct fs_dev *dev)\r\n{\r\nstruct pci_dev *pci_dev;\r\nint isr, to;\r\nint i;\r\nfunc_enter ();\r\npci_dev = dev->pci_dev;\r\nprintk (KERN_INFO "found a FireStream %d card, base %16llx, irq%d.\n",\r\nIS_FS50(dev)?50:155,\r\n(unsigned long long)pci_resource_start(pci_dev, 0),\r\ndev->pci_dev->irq);\r\nif (fs_debug & FS_DEBUG_INIT)\r\nmy_hd ((unsigned char *) dev, sizeof (*dev));\r\nundocumented_pci_fix (pci_dev);\r\ndev->hw_base = pci_resource_start(pci_dev, 0);\r\ndev->base = ioremap(dev->hw_base, 0x1000);\r\nreset_chip (dev);\r\nwrite_fs (dev, SARMODE0, 0\r\n| (0 * SARMODE0_SHADEN)\r\n| (1 * SARMODE0_INTMODE_READCLEAR)\r\n| (1 * SARMODE0_CWRE)\r\n| (IS_FS50(dev) ? SARMODE0_PRPWT_FS50_5:\r\nSARMODE0_PRPWT_FS155_3)\r\n| (1 * SARMODE0_CALSUP_1)\r\n| (IS_FS50(dev) ? (0\r\n| SARMODE0_RXVCS_32\r\n| SARMODE0_ABRVCS_32\r\n| SARMODE0_TXVCS_32):\r\n(0\r\n| SARMODE0_RXVCS_1k\r\n| SARMODE0_ABRVCS_1k\r\n| SARMODE0_TXVCS_1k)));\r\nto = 100;\r\nwhile (--to) {\r\nisr = read_fs (dev, ISR);\r\nif (isr & ISR_INIT_ERR) {\r\nprintk (KERN_ERR "Error initializing the FS... \n");\r\ngoto unmap;\r\n}\r\nif (isr & ISR_INIT) {\r\nfs_dprintk (FS_DEBUG_INIT, "Ha! Initialized OK!\n");\r\nbreak;\r\n}\r\nmsleep(10);\r\n}\r\nif (!to) {\r\nprintk (KERN_ERR "timeout initializing the FS... \n");\r\ngoto unmap;\r\n}\r\ndev->channel_mask = 0x1f;\r\ndev->channo = 0;\r\nwrite_fs (dev, SARMODE1, 0\r\n| (fs_keystream * SARMODE1_DEFHEC)\r\n| ((loopback == 1) * SARMODE1_TSTLP)\r\n| (1 * SARMODE1_DCRM)\r\n| (1 * SARMODE1_DCOAM)\r\n| (0 * SARMODE1_OAMCRC)\r\n| (0 * SARMODE1_DUMPE)\r\n| (0 * SARMODE1_GPLEN)\r\n| (0 * SARMODE1_GNAM)\r\n| (0 * SARMODE1_GVAS)\r\n| (0 * SARMODE1_GPAS)\r\n| (1 * SARMODE1_GPRI)\r\n| (0 * SARMODE1_PMS)\r\n| (0 * SARMODE1_GFCR)\r\n| (1 * SARMODE1_HECM2)\r\n| (1 * SARMODE1_HECM1)\r\n| (1 * SARMODE1_HECM0)\r\n| (1 << 12)\r\n| (0 * 0xff) );\r\nwrite_fs (dev, TMCONF, 0x0000000f);\r\nwrite_fs (dev, CALPRESCALE, 0x01010101 * num);\r\nwrite_fs (dev, 0x80, 0x000F00E4);\r\nwrite_fs (dev, CELLOSCONF, 0\r\n| ( 0 * CELLOSCONF_CEN)\r\n| ( CELLOSCONF_SC1)\r\n| (0x80 * CELLOSCONF_COBS)\r\n| (num * CELLOSCONF_COPK)\r\n| (num * CELLOSCONF_COST));\r\nwrite_fs (dev, CELLOSCONF_COST, 0x0B809191);\r\nif (IS_FS50 (dev)) {\r\nwrite_fs (dev, RAS0, RAS0_DCD_XHLT);\r\ndev->atm_dev->ci_range.vpi_bits = 12;\r\ndev->atm_dev->ci_range.vci_bits = 16;\r\ndev->nchannels = FS50_NR_CHANNELS;\r\n} else {\r\nwrite_fs (dev, RAS0, RAS0_DCD_XHLT\r\n| (((1 << FS155_VPI_BITS) - 1) * RAS0_VPSEL)\r\n| (((1 << FS155_VCI_BITS) - 1) * RAS0_VCSEL));\r\ndev->atm_dev->ci_range.vpi_bits = FS155_VPI_BITS;\r\ndev->atm_dev->ci_range.vci_bits = FS155_VCI_BITS;\r\nwrite_fs (dev, RAC, 0);\r\nwrite_fs (dev, RAM, (1 << (28 - FS155_VPI_BITS - FS155_VCI_BITS)) - 1);\r\ndev->nchannels = FS155_NR_CHANNELS;\r\n}\r\ndev->atm_vccs = kcalloc (dev->nchannels, sizeof (struct atm_vcc *),\r\nGFP_KERNEL);\r\nfs_dprintk (FS_DEBUG_ALLOC, "Alloc atmvccs: %p(%Zd)\n",\r\ndev->atm_vccs, dev->nchannels * sizeof (struct atm_vcc *));\r\nif (!dev->atm_vccs) {\r\nprintk (KERN_WARNING "Couldn't allocate memory for VCC buffers. Woops!\n");\r\ngoto unmap;\r\n}\r\ndev->tx_inuse = kzalloc (dev->nchannels / 8 , GFP_KERNEL);\r\nfs_dprintk (FS_DEBUG_ALLOC, "Alloc tx_inuse: %p(%d)\n",\r\ndev->atm_vccs, dev->nchannels / 8);\r\nif (!dev->tx_inuse) {\r\nprintk (KERN_WARNING "Couldn't allocate memory for tx_inuse bits!\n");\r\ngoto unmap;\r\n}\r\nwrite_fs (dev, DMAMR, DMAMR_TX_MODE_FULL);\r\ninit_q (dev, &dev->hp_txq, TX_PQ(TXQ_HP), TXQ_NENTRIES, 0);\r\ninit_q (dev, &dev->lp_txq, TX_PQ(TXQ_LP), TXQ_NENTRIES, 0);\r\ninit_q (dev, &dev->tx_relq, TXB_RQ, TXQ_NENTRIES, 1);\r\ninit_q (dev, &dev->st_q, ST_Q, TXQ_NENTRIES, 1);\r\nfor (i=0;i < FS_NR_FREE_POOLS;i++) {\r\ninit_fp (dev, &dev->rx_fp[i], RXB_FP(i),\r\nrx_buf_sizes[i], rx_pool_sizes[i]);\r\ntop_off_fp (dev, &dev->rx_fp[i], GFP_KERNEL);\r\n}\r\nfor (i=0;i < FS_NR_RX_QUEUES;i++)\r\ninit_q (dev, &dev->rx_rq[i], RXB_RQ(i), RXRQ_NENTRIES, 1);\r\ndev->irq = pci_dev->irq;\r\nif (request_irq (dev->irq, fs_irq, IRQF_SHARED, "firestream", dev)) {\r\nprintk (KERN_WARNING "couldn't get irq %d for firestream.\n", pci_dev->irq);\r\ngoto unmap;\r\n}\r\nfs_dprintk (FS_DEBUG_INIT, "Grabbed irq %d for dev at %p.\n", dev->irq, dev);\r\nwrite_fs (dev, IMR, 0\r\n| ISR_RBRQ0_W\r\n| ISR_RBRQ1_W\r\n| ISR_RBRQ2_W\r\n| ISR_RBRQ3_W\r\n| ISR_TBRQ_W\r\n| ISR_CSQ_W);\r\nwrite_fs (dev, SARMODE0, 0\r\n| (0 * SARMODE0_SHADEN)\r\n| (1 * SARMODE0_GINT)\r\n| (1 * SARMODE0_INTMODE_READCLEAR)\r\n| (0 * SARMODE0_CWRE)\r\n| (IS_FS50(dev)?SARMODE0_PRPWT_FS50_5:\r\nSARMODE0_PRPWT_FS155_3)\r\n| (1 * SARMODE0_CALSUP_1)\r\n| (IS_FS50 (dev)?(0\r\n| SARMODE0_RXVCS_32\r\n| SARMODE0_ABRVCS_32\r\n| SARMODE0_TXVCS_32):\r\n(0\r\n| SARMODE0_RXVCS_1k\r\n| SARMODE0_ABRVCS_1k\r\n| SARMODE0_TXVCS_1k))\r\n| (1 * SARMODE0_RUN));\r\ninit_phy (dev, PHY_NTC_INIT);\r\nif (loopback == 2) {\r\nwrite_phy (dev, 0x39, 0x000e);\r\n}\r\n#ifdef FS_POLL_FREQ\r\ninit_timer (&dev->timer);\r\ndev->timer.data = (unsigned long) dev;\r\ndev->timer.function = fs_poll;\r\ndev->timer.expires = jiffies + FS_POLL_FREQ;\r\nadd_timer (&dev->timer);\r\n#endif\r\ndev->atm_dev->dev_data = dev;\r\nfunc_exit ();\r\nreturn 0;\r\nunmap:\r\niounmap(dev->base);\r\nreturn 1;\r\n}\r\nstatic int firestream_init_one(struct pci_dev *pci_dev,\r\nconst struct pci_device_id *ent)\r\n{\r\nstruct atm_dev *atm_dev;\r\nstruct fs_dev *fs_dev;\r\nif (pci_enable_device(pci_dev))\r\ngoto err_out;\r\nfs_dev = kzalloc (sizeof (struct fs_dev), GFP_KERNEL);\r\nfs_dprintk (FS_DEBUG_ALLOC, "Alloc fs-dev: %p(%Zd)\n",\r\nfs_dev, sizeof (struct fs_dev));\r\nif (!fs_dev)\r\ngoto err_out;\r\natm_dev = atm_dev_register("fs", &pci_dev->dev, &ops, -1, NULL);\r\nif (!atm_dev)\r\ngoto err_out_free_fs_dev;\r\nfs_dev->pci_dev = pci_dev;\r\nfs_dev->atm_dev = atm_dev;\r\nfs_dev->flags = ent->driver_data;\r\nif (fs_init(fs_dev))\r\ngoto err_out_free_atm_dev;\r\nfs_dev->next = fs_boards;\r\nfs_boards = fs_dev;\r\nreturn 0;\r\nerr_out_free_atm_dev:\r\natm_dev_deregister(atm_dev);\r\nerr_out_free_fs_dev:\r\nkfree(fs_dev);\r\nerr_out:\r\nreturn -ENODEV;\r\n}\r\nstatic void firestream_remove_one(struct pci_dev *pdev)\r\n{\r\nint i;\r\nstruct fs_dev *dev, *nxtdev;\r\nstruct fs_vcc *vcc;\r\nstruct FS_BPENTRY *fp, *nxt;\r\nfunc_enter ();\r\n#if 0\r\nprintk ("hptxq:\n");\r\nfor (i=0;i<60;i++) {\r\nprintk ("%d: %08x %08x %08x %08x \n",\r\ni, pq[qp].cmd, pq[qp].p0, pq[qp].p1, pq[qp].p2);\r\nqp++;\r\nif (qp >= 60) qp = 0;\r\n}\r\nprintk ("descriptors:\n");\r\nfor (i=0;i<60;i++) {\r\nprintk ("%d: %p: %08x %08x %p %p\n",\r\ni, da[qd], dq[qd].flags, dq[qd].bsa, dq[qd].skb, dq[qd].dev);\r\nqd++;\r\nif (qd >= 60) qd = 0;\r\n}\r\n#endif\r\nfor (dev = fs_boards;dev != NULL;dev=nxtdev) {\r\nfs_dprintk (FS_DEBUG_CLEANUP, "Releasing resources for dev at %p.\n", dev);\r\nfor (i=0;i < dev->nchannels;i++) {\r\nif (dev->atm_vccs[i]) {\r\nvcc = FS_VCC (dev->atm_vccs[i]);\r\nsubmit_command (dev, &dev->hp_txq,\r\nQE_CMD_TX_PURGE_INH | QE_CMD_IMM_INQ | vcc->channo, 0,0,0);\r\nsubmit_command (dev, &dev->hp_txq,\r\nQE_CMD_RX_PURGE_INH | QE_CMD_IMM_INQ | vcc->channo, 0,0,0);\r\n}\r\n}\r\nfor (i=0;i < FS_NR_FREE_POOLS;i++) {\r\nfor (fp=bus_to_virt (read_fs (dev, FP_SA(dev->rx_fp[i].offset)));\r\n!(fp->flags & FP_FLAGS_EPI);fp = nxt) {\r\nfs_dprintk (FS_DEBUG_ALLOC, "Free rec-skb: %p\n", fp->skb);\r\ndev_kfree_skb_any (fp->skb);\r\nnxt = bus_to_virt (fp->next);\r\nfs_dprintk (FS_DEBUG_ALLOC, "Free rec-d: %p\n", fp);\r\nkfree (fp);\r\n}\r\nfs_dprintk (FS_DEBUG_ALLOC, "Free rec-skb: %p\n", fp->skb);\r\ndev_kfree_skb_any (fp->skb);\r\nfs_dprintk (FS_DEBUG_ALLOC, "Free rec-d: %p\n", fp);\r\nkfree (fp);\r\n}\r\nreset_chip (dev);\r\nfs_dprintk (FS_DEBUG_CLEANUP, "Freeing irq%d.\n", dev->irq);\r\nfree_irq (dev->irq, dev);\r\ndel_timer (&dev->timer);\r\natm_dev_deregister(dev->atm_dev);\r\nfree_queue (dev, &dev->hp_txq);\r\nfree_queue (dev, &dev->lp_txq);\r\nfree_queue (dev, &dev->tx_relq);\r\nfree_queue (dev, &dev->st_q);\r\nfs_dprintk (FS_DEBUG_ALLOC, "Free atmvccs: %p\n", dev->atm_vccs);\r\nkfree (dev->atm_vccs);\r\nfor (i=0;i< FS_NR_FREE_POOLS;i++)\r\nfree_freepool (dev, &dev->rx_fp[i]);\r\nfor (i=0;i < FS_NR_RX_QUEUES;i++)\r\nfree_queue (dev, &dev->rx_rq[i]);\r\niounmap(dev->base);\r\nfs_dprintk (FS_DEBUG_ALLOC, "Free fs-dev: %p\n", dev);\r\nnxtdev = dev->next;\r\nkfree (dev);\r\n}\r\nfunc_exit ();\r\n}\r\nstatic int __init firestream_init_module (void)\r\n{\r\nint error;\r\nfunc_enter ();\r\nerror = pci_register_driver(&firestream_driver);\r\nfunc_exit ();\r\nreturn error;\r\n}\r\nstatic void __exit firestream_cleanup_module(void)\r\n{\r\npci_unregister_driver(&firestream_driver);\r\n}
