void\r\nmix_write(unsigned char data, int ioaddr)\r\n{\r\nif (pas_model == 4)\r\n{\r\noutw(data | (data << 8), (ioaddr + pas_translate_code) - 1);\r\noutb((0x80), 0);\r\n} else\r\npas_write(data, ioaddr);\r\n}\r\nstatic int\r\nmixer_output(int right_vol, int left_vol, int div, int bits,\r\nint mixer)\r\n{\r\nint left = left_vol * div / 100;\r\nint right = right_vol * div / 100;\r\nif (bits & 0x10)\r\n{\r\nleft |= mixer;\r\nright |= mixer;\r\n}\r\nif (bits == 0x03 || bits == 0x04)\r\n{\r\nmix_write(0x80 | bits, 0x078B);\r\nmix_write(left, 0x078B);\r\nright_vol = left_vol;\r\n} else\r\n{\r\nmix_write(0x80 | 0x20 | bits, 0x078B);\r\nmix_write(left, 0x078B);\r\nmix_write(0x80 | 0x40 | bits, 0x078B);\r\nmix_write(right, 0x078B);\r\n}\r\nreturn (left_vol | (right_vol << 8));\r\n}\r\nstatic void\r\nset_mode(int new_mode)\r\n{\r\nmix_write(0x80 | 0x05, 0x078B);\r\nmix_write(new_mode, 0x078B);\r\nmode_control = new_mode;\r\n}\r\nstatic int\r\npas_mixer_set(int whichDev, unsigned int level)\r\n{\r\nint left, right, devmask, changed, i, mixer = 0;\r\nDEB(printk("static int pas_mixer_set(int whichDev = %d, unsigned int level = %X)\n", whichDev, level));\r\nleft = level & 0x7f;\r\nright = (level & 0x7f00) >> 8;\r\nif (whichDev < SOUND_MIXER_NRDEVICES) {\r\nif ((1 << whichDev) & rec_devices)\r\nmixer = 0x20;\r\nelse\r\nmixer = 0x00;\r\n}\r\nswitch (whichDev)\r\n{\r\ncase SOUND_MIXER_VOLUME:\r\nlevels[whichDev] = mixer_output(right, left, 63, 0x01, 0);\r\nbreak;\r\ncase SOUND_MIXER_BASS:\r\nlevels[whichDev] = mixer_output(right, left, 12, 0x03, 0);\r\nbreak;\r\ncase SOUND_MIXER_TREBLE:\r\nlevels[whichDev] = mixer_output(right, left, 12, 0x04, 0);\r\nbreak;\r\ncase SOUND_MIXER_SYNTH:\r\nlevels[whichDev] = mixer_output(right, left, 31, 0x10 | 0x00, mixer);\r\nbreak;\r\ncase SOUND_MIXER_PCM:\r\nlevels[whichDev] = mixer_output(right, left, 31, 0x10 | 0x05, mixer);\r\nbreak;\r\ncase SOUND_MIXER_ALTPCM:\r\nlevels[whichDev] = mixer_output(right, left, 31, 0x10 | 0x07, mixer);\r\nbreak;\r\ncase SOUND_MIXER_SPEAKER:\r\nlevels[whichDev] = mixer_output(right, left, 31, 0x10 | 0x06, mixer);\r\nbreak;\r\ncase SOUND_MIXER_LINE:\r\nlevels[whichDev] = mixer_output(right, left, 31, 0x10 | 0x02, mixer);\r\nbreak;\r\ncase SOUND_MIXER_CD:\r\nlevels[whichDev] = mixer_output(right, left, 31, 0x10 | 0x03, mixer);\r\nbreak;\r\ncase SOUND_MIXER_MIC:\r\nlevels[whichDev] = mixer_output(right, left, 31, 0x10 | 0x04, mixer);\r\nbreak;\r\ncase SOUND_MIXER_IMIX:\r\nlevels[whichDev] = mixer_output(right, left, 31, 0x10 | 0x01,\r\n0x00);\r\nbreak;\r\ncase SOUND_MIXER_RECLEV:\r\nlevels[whichDev] = mixer_output(right, left, 15, 0x02, 0);\r\nbreak;\r\ncase SOUND_MIXER_RECSRC:\r\ndevmask = level & POSSIBLE_RECORDING_DEVICES;\r\nchanged = devmask ^ rec_devices;\r\nrec_devices = devmask;\r\nfor (i = 0; i < SOUND_MIXER_NRDEVICES; i++)\r\nif (changed & (1 << i))\r\n{\r\npas_mixer_set(i, levels[i]);\r\n}\r\nreturn rec_devices;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn (levels[whichDev]);\r\n}\r\nstatic void\r\npas_mixer_reset(void)\r\n{\r\nint foo;\r\nDEB(printk("pas2_mixer.c: void pas_mixer_reset(void)\n"));\r\nfor (foo = 0; foo < SOUND_MIXER_NRDEVICES; foo++)\r\npas_mixer_set(foo, levels[foo]);\r\nset_mode(0x04 | 0x01);\r\n}\r\nstatic int pas_mixer_ioctl(int dev, unsigned int cmd, void __user *arg)\r\n{\r\nint level,v ;\r\nint __user *p = (int __user *)arg;\r\nDEB(printk("pas2_mixer.c: int pas_mixer_ioctl(unsigned int cmd = %X, unsigned int arg = %X)\n", cmd, arg));\r\nif (cmd == SOUND_MIXER_PRIVATE1) {\r\nif (get_user(level, p))\r\nreturn -EFAULT;\r\nif (level == -1)\r\nlevel = (mode_control & 0x04);\r\nelse {\r\nmode_control &= ~0x04;\r\nif (level)\r\nmode_control |= 0x04;\r\nset_mode(mode_control);\r\n}\r\nlevel = !!level;\r\nreturn put_user(level, p);\r\n}\r\nif (cmd == SOUND_MIXER_PRIVATE2) {\r\nif (get_user(level, p))\r\nreturn -EFAULT;\r\nif (level == -1) {\r\nif (!(mode_control & 0x03))\r\nlevel = 0;\r\nelse\r\nlevel = ((mode_control & 0x03) + 1) * 20;\r\n} else {\r\nint i = 0;\r\nlevel &= 0x7f;\r\nif (level)\r\ni = (level / 20) - 1;\r\nmode_control &= ~0x03;\r\nmode_control |= i & 0x03;\r\nset_mode(mode_control);\r\nif (i)\r\ni = (i + 1) * 20;\r\nlevel = i;\r\n}\r\nreturn put_user(level, p);\r\n}\r\nif (cmd == SOUND_MIXER_PRIVATE3) {\r\nif (get_user(level, p))\r\nreturn -EFAULT;\r\nif (level == -1)\r\nlevel = !(pas_read(0x0B8A) & 0x20);\r\nelse {\r\nif (level)\r\npas_write(pas_read(0x0B8A) & (~0x20), 0x0B8A);\r\nelse\r\npas_write(pas_read(0x0B8A) | 0x20, 0x0B8A);\r\nlevel = !(pas_read(0x0B8A) & 0x20);\r\n}\r\nreturn put_user(level, p);\r\n}\r\nif (((cmd >> 8) & 0xff) == 'M') {\r\nif (get_user(v, p))\r\nreturn -EFAULT;\r\nif (_SIOC_DIR(cmd) & _SIOC_WRITE) {\r\nv = pas_mixer_set(cmd & 0xff, v);\r\n} else {\r\nswitch (cmd & 0xff) {\r\ncase SOUND_MIXER_RECSRC:\r\nv = rec_devices;\r\nbreak;\r\ncase SOUND_MIXER_STEREODEVS:\r\nv = SUPPORTED_MIXER_DEVICES & ~(SOUND_MASK_BASS | SOUND_MASK_TREBLE);\r\nbreak;\r\ncase SOUND_MIXER_DEVMASK:\r\nv = SUPPORTED_MIXER_DEVICES;\r\nbreak;\r\ncase SOUND_MIXER_RECMASK:\r\nv = POSSIBLE_RECORDING_DEVICES & SUPPORTED_MIXER_DEVICES;\r\nbreak;\r\ncase SOUND_MIXER_CAPS:\r\nv = 0;\r\nbreak;\r\ndefault:\r\nv = levels[cmd & 0xff];\r\nbreak;\r\n}\r\n}\r\nreturn put_user(v, p);\r\n}\r\nreturn -EINVAL;\r\n}\r\nint __init\r\npas_init_mixer(void)\r\n{\r\nint d;\r\nlevels = load_mixer_volumes("PAS16_1", default_levels, 1);\r\npas_mixer_reset();\r\nif ((d = sound_alloc_mixerdev()) != -1)\r\n{\r\naudio_devs[pas_audiodev]->mixer_dev = d;\r\nmixer_devs[d] = &pas_mixer_operations;\r\n}\r\nreturn 1;\r\n}
