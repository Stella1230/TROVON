static __inline__ char * get_opt_string(const char *this_opt, const char *name)\r\n{\r\nconst char *p;\r\nint i;\r\nchar *ret;\r\np = OPT_STRVAL(this_opt, name);\r\ni = 0;\r\nwhile (p[i] && p[i] != ' ' && p[i] != ',')\r\ni++;\r\nret = kmalloc(i + 1, GFP_KERNEL);\r\nif (ret) {\r\nstrncpy(ret, p, i);\r\nret[i] = '\0';\r\n}\r\nreturn ret;\r\n}\r\nstatic __inline__ int get_opt_int(const char *this_opt, const char *name,\r\nint *ret)\r\n{\r\nif (!ret)\r\nreturn 0;\r\nif (!OPT_EQUAL(this_opt, name))\r\nreturn 0;\r\n*ret = OPT_INTVAL(this_opt, name);\r\nreturn 1;\r\n}\r\nstatic __inline__ int get_opt_bool(const char *this_opt, const char *name,\r\nint *ret)\r\n{\r\nif (!ret)\r\nreturn 0;\r\nif (OPT_EQUAL(this_opt, name)) {\r\nif (this_opt[strlen(name)] == '=')\r\n*ret = simple_strtoul(this_opt + strlen(name) + 1,\r\nNULL, 0);\r\nelse\r\n*ret = 1;\r\n} else {\r\nif (OPT_EQUAL(this_opt, "no") && OPT_EQUAL(this_opt + 2, name))\r\n*ret = 0;\r\nelse\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nstatic int __init intelfb_setup(char *options)\r\n{\r\nchar *this_opt;\r\nDBG_MSG("intelfb_setup\n");\r\nif (!options || !*options) {\r\nDBG_MSG("no options\n");\r\nreturn 0;\r\n} else\r\nDBG_MSG("options: %s\n", options);\r\nwhile ((this_opt = strsep(&options, ","))) {\r\nif (!*this_opt)\r\ncontinue;\r\nif (get_opt_bool(this_opt, "accel", &accel))\r\n;\r\nelse if (get_opt_int(this_opt, "vram", &vram))\r\n;\r\nelse if (get_opt_bool(this_opt, "hwcursor", &hwcursor))\r\n;\r\nelse if (get_opt_bool(this_opt, "mtrr", &mtrr))\r\n;\r\nelse if (get_opt_bool(this_opt, "fixed", &fixed))\r\n;\r\nelse if (get_opt_bool(this_opt, "init", &noinit))\r\nnoinit = !noinit;\r\nelse if (OPT_EQUAL(this_opt, "mode="))\r\nmode = get_opt_string(this_opt, "mode=");\r\nelse\r\nmode = this_opt;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init intelfb_init(void)\r\n{\r\n#ifndef MODULE\r\nchar *option = NULL;\r\n#endif\r\nDBG_MSG("intelfb_init\n");\r\nINF_MSG("Framebuffer driver for "\r\n"Intel(R) " SUPPORTED_CHIPSETS " chipsets\n");\r\nINF_MSG("Version " INTELFB_VERSION "\n");\r\nif (idonly)\r\nreturn -ENODEV;\r\n#ifndef MODULE\r\nif (fb_get_options("intelfb", &option))\r\nreturn -ENODEV;\r\nintelfb_setup(option);\r\n#endif\r\nreturn pci_register_driver(&intelfb_driver);\r\n}\r\nstatic void __exit intelfb_exit(void)\r\n{\r\nDBG_MSG("intelfb_exit\n");\r\npci_unregister_driver(&intelfb_driver);\r\n}\r\nstatic inline void set_mtrr(struct intelfb_info *dinfo)\r\n{\r\ndinfo->mtrr_reg = mtrr_add(dinfo->aperture.physical,\r\ndinfo->aperture.size, MTRR_TYPE_WRCOMB, 1);\r\nif (dinfo->mtrr_reg < 0) {\r\nERR_MSG("unable to set MTRR\n");\r\nreturn;\r\n}\r\ndinfo->has_mtrr = 1;\r\n}\r\nstatic inline void unset_mtrr(struct intelfb_info *dinfo)\r\n{\r\nif (dinfo->has_mtrr)\r\nmtrr_del(dinfo->mtrr_reg, dinfo->aperture.physical,\r\ndinfo->aperture.size);\r\n}\r\nstatic void cleanup(struct intelfb_info *dinfo)\r\n{\r\nDBG_MSG("cleanup\n");\r\nif (!dinfo)\r\nreturn;\r\nintelfbhw_disable_irq(dinfo);\r\nfb_dealloc_cmap(&dinfo->info->cmap);\r\nkfree(dinfo->info->pixmap.addr);\r\nif (dinfo->registered)\r\nunregister_framebuffer(dinfo->info);\r\nunset_mtrr(dinfo);\r\nif (dinfo->fbmem_gart && dinfo->gtt_fb_mem) {\r\nagp_unbind_memory(dinfo->gtt_fb_mem);\r\nagp_free_memory(dinfo->gtt_fb_mem);\r\n}\r\nif (dinfo->gtt_cursor_mem) {\r\nagp_unbind_memory(dinfo->gtt_cursor_mem);\r\nagp_free_memory(dinfo->gtt_cursor_mem);\r\n}\r\nif (dinfo->gtt_ring_mem) {\r\nagp_unbind_memory(dinfo->gtt_ring_mem);\r\nagp_free_memory(dinfo->gtt_ring_mem);\r\n}\r\n#ifdef CONFIG_FB_INTEL_I2C\r\nintelfb_delete_i2c_busses(dinfo);\r\n#endif\r\nif (dinfo->mmio_base)\r\niounmap((void __iomem *)dinfo->mmio_base);\r\nif (dinfo->aperture.virtual)\r\niounmap((void __iomem *)dinfo->aperture.virtual);\r\nif (dinfo->flag & INTELFB_MMIO_ACQUIRED)\r\nrelease_mem_region(dinfo->mmio_base_phys, INTEL_REG_SIZE);\r\nif (dinfo->flag & INTELFB_FB_ACQUIRED)\r\nrelease_mem_region(dinfo->aperture.physical,\r\ndinfo->aperture.size);\r\nframebuffer_release(dinfo->info);\r\n}\r\nstatic int intelfb_pci_register(struct pci_dev *pdev,\r\nconst struct pci_device_id *ent)\r\n{\r\nstruct fb_info *info;\r\nstruct intelfb_info *dinfo;\r\nint i, err, dvo;\r\nint aperture_size, stolen_size;\r\nstruct agp_kern_info gtt_info;\r\nint agp_memtype;\r\nconst char *s;\r\nstruct agp_bridge_data *bridge;\r\nint aperture_bar = 0;\r\nint mmio_bar = 1;\r\nint offset;\r\nDBG_MSG("intelfb_pci_register\n");\r\nnum_registered++;\r\nif (num_registered != 1) {\r\nERR_MSG("Attempted to register %d devices "\r\n"(should be only 1).\n", num_registered);\r\nreturn -ENODEV;\r\n}\r\ninfo = framebuffer_alloc(sizeof(struct intelfb_info), &pdev->dev);\r\nif (!info) {\r\nERR_MSG("Could not allocate memory for intelfb_info.\n");\r\nreturn -ENODEV;\r\n}\r\nif (fb_alloc_cmap(&info->cmap, 256, 1) < 0) {\r\nERR_MSG("Could not allocate cmap for intelfb_info.\n");\r\ngoto err_out_cmap;\r\n}\r\ndinfo = info->par;\r\ndinfo->info = info;\r\ndinfo->fbops = &intel_fb_ops;\r\ndinfo->pdev = pdev;\r\ninfo->pixmap.addr = kzalloc(64 * 1024, GFP_KERNEL);\r\nif (info->pixmap.addr == NULL) {\r\nERR_MSG("Cannot reserve pixmap memory.\n");\r\ngoto err_out_pixmap;\r\n}\r\ndinfo->fixed_mode = fixed;\r\nif ((err = pci_enable_device(pdev))) {\r\nERR_MSG("Cannot enable device.\n");\r\ncleanup(dinfo);\r\nreturn -ENODEV;\r\n}\r\nif ((ent->device == PCI_DEVICE_ID_INTEL_915G) ||\r\n(ent->device == PCI_DEVICE_ID_INTEL_915GM) ||\r\n(ent->device == PCI_DEVICE_ID_INTEL_945G) ||\r\n(ent->device == PCI_DEVICE_ID_INTEL_945GM) ||\r\n(ent->device == PCI_DEVICE_ID_INTEL_945GME) ||\r\n(ent->device == PCI_DEVICE_ID_INTEL_965G) ||\r\n(ent->device == PCI_DEVICE_ID_INTEL_965GM)) {\r\naperture_bar = 2;\r\nmmio_bar = 0;\r\n}\r\ndinfo->aperture.physical = pci_resource_start(pdev, aperture_bar);\r\ndinfo->aperture.size = pci_resource_len(pdev, aperture_bar);\r\ndinfo->mmio_base_phys = pci_resource_start(pdev, mmio_bar);\r\nDBG_MSG("fb aperture: 0x%llx/0x%llx, MMIO region: 0x%llx/0x%llx\n",\r\n(unsigned long long)pci_resource_start(pdev, aperture_bar),\r\n(unsigned long long)pci_resource_len(pdev, aperture_bar),\r\n(unsigned long long)pci_resource_start(pdev, mmio_bar),\r\n(unsigned long long)pci_resource_len(pdev, mmio_bar));\r\nif (!request_mem_region(dinfo->aperture.physical, dinfo->aperture.size,\r\nINTELFB_MODULE_NAME)) {\r\nERR_MSG("Cannot reserve FB region.\n");\r\ncleanup(dinfo);\r\nreturn -ENODEV;\r\n}\r\ndinfo->flag |= INTELFB_FB_ACQUIRED;\r\nif (!request_mem_region(dinfo->mmio_base_phys,\r\nINTEL_REG_SIZE,\r\nINTELFB_MODULE_NAME)) {\r\nERR_MSG("Cannot reserve MMIO region.\n");\r\ncleanup(dinfo);\r\nreturn -ENODEV;\r\n}\r\ndinfo->flag |= INTELFB_MMIO_ACQUIRED;\r\ndinfo->pci_chipset = pdev->device;\r\nif (intelfbhw_get_chipset(pdev, dinfo)) {\r\ncleanup(dinfo);\r\nreturn -ENODEV;\r\n}\r\nif (intelfbhw_get_memory(pdev, &aperture_size,&stolen_size)) {\r\ncleanup(dinfo);\r\nreturn -ENODEV;\r\n}\r\nINF_MSG("%02x:%02x.%d: %s, aperture size %dMB, "\r\n"stolen memory %dkB\n",\r\npdev->bus->number, PCI_SLOT(pdev->devfn),\r\nPCI_FUNC(pdev->devfn), dinfo->name,\r\nBtoMB(aperture_size), BtoKB(stolen_size));\r\ndinfo->accel = accel;\r\ndinfo->hwcursor = hwcursor;\r\nif (NOACCEL_CHIPSET(dinfo) && dinfo->accel == 1) {\r\nINF_MSG("Acceleration is not supported for the %s chipset.\n",\r\ndinfo->name);\r\ndinfo->accel = 0;\r\n}\r\nif (ROUND_UP_TO_PAGE(stolen_size) >= MB(vram)) {\r\ndinfo->fb.size = ROUND_UP_TO_PAGE(stolen_size);\r\ndinfo->fbmem_gart = 0;\r\n} else {\r\ndinfo->fb.size = MB(vram);\r\ndinfo->fbmem_gart = 1;\r\n}\r\nif (dinfo->accel) {\r\ndinfo->ring.size = RINGBUFFER_SIZE;\r\ndinfo->ring_tail_mask = dinfo->ring.size - 1;\r\n}\r\nif (dinfo->hwcursor)\r\ndinfo->cursor.size = HW_CURSOR_SIZE;\r\nif (!(bridge = agp_backend_acquire(pdev))) {\r\nERR_MSG("cannot acquire agp\n");\r\ncleanup(dinfo);\r\nreturn -ENODEV;\r\n}\r\nif (agp_copy_info(bridge, &gtt_info)) {\r\nERR_MSG("cannot get agp info\n");\r\nagp_backend_release(bridge);\r\ncleanup(dinfo);\r\nreturn -ENODEV;\r\n}\r\nif (MB(voffset) < stolen_size)\r\noffset = (stolen_size >> 12);\r\nelse\r\noffset = ROUND_UP_TO_PAGE(MB(voffset))/GTT_PAGE_SIZE;\r\nif (dinfo->accel)\r\ndinfo->ring.offset = offset + gtt_info.current_memory;\r\nif (dinfo->hwcursor)\r\ndinfo->cursor.offset = offset +\r\n+ gtt_info.current_memory + (dinfo->ring.size >> 12);\r\nif (dinfo->fbmem_gart)\r\ndinfo->fb.offset = offset +\r\n+ gtt_info.current_memory + (dinfo->ring.size >> 12)\r\n+ (dinfo->cursor.size >> 12);\r\ndinfo->aperture.virtual = (u8 __iomem *)ioremap_nocache\r\n(dinfo->aperture.physical, ((offset + dinfo->fb.offset) << 12)\r\n+ dinfo->fb.size);\r\nif (!dinfo->aperture.virtual) {\r\nERR_MSG("Cannot remap FB region.\n");\r\nagp_backend_release(bridge);\r\ncleanup(dinfo);\r\nreturn -ENODEV;\r\n}\r\ndinfo->mmio_base =\r\n(u8 __iomem *)ioremap_nocache(dinfo->mmio_base_phys,\r\nINTEL_REG_SIZE);\r\nif (!dinfo->mmio_base) {\r\nERR_MSG("Cannot remap MMIO region.\n");\r\nagp_backend_release(bridge);\r\ncleanup(dinfo);\r\nreturn -ENODEV;\r\n}\r\nif (dinfo->accel) {\r\nif (!(dinfo->gtt_ring_mem =\r\nagp_allocate_memory(bridge, dinfo->ring.size >> 12,\r\nAGP_NORMAL_MEMORY))) {\r\nERR_MSG("cannot allocate ring buffer memory\n");\r\nagp_backend_release(bridge);\r\ncleanup(dinfo);\r\nreturn -ENOMEM;\r\n}\r\nif (agp_bind_memory(dinfo->gtt_ring_mem,\r\ndinfo->ring.offset)) {\r\nERR_MSG("cannot bind ring buffer memory\n");\r\nagp_backend_release(bridge);\r\ncleanup(dinfo);\r\nreturn -EBUSY;\r\n}\r\ndinfo->ring.physical = dinfo->aperture.physical\r\n+ (dinfo->ring.offset << 12);\r\ndinfo->ring.virtual = dinfo->aperture.virtual\r\n+ (dinfo->ring.offset << 12);\r\ndinfo->ring_head = 0;\r\n}\r\nif (dinfo->hwcursor) {\r\nagp_memtype = dinfo->mobile ? AGP_PHYSICAL_MEMORY\r\n: AGP_NORMAL_MEMORY;\r\nif (!(dinfo->gtt_cursor_mem =\r\nagp_allocate_memory(bridge, dinfo->cursor.size >> 12,\r\nagp_memtype))) {\r\nERR_MSG("cannot allocate cursor memory\n");\r\nagp_backend_release(bridge);\r\ncleanup(dinfo);\r\nreturn -ENOMEM;\r\n}\r\nif (agp_bind_memory(dinfo->gtt_cursor_mem,\r\ndinfo->cursor.offset)) {\r\nERR_MSG("cannot bind cursor memory\n");\r\nagp_backend_release(bridge);\r\ncleanup(dinfo);\r\nreturn -EBUSY;\r\n}\r\nif (dinfo->mobile)\r\ndinfo->cursor.physical\r\n= dinfo->gtt_cursor_mem->physical;\r\nelse\r\ndinfo->cursor.physical = dinfo->aperture.physical\r\n+ (dinfo->cursor.offset << 12);\r\ndinfo->cursor.virtual = dinfo->aperture.virtual\r\n+ (dinfo->cursor.offset << 12);\r\n}\r\nif (dinfo->fbmem_gart) {\r\nif (!(dinfo->gtt_fb_mem =\r\nagp_allocate_memory(bridge, dinfo->fb.size >> 12,\r\nAGP_NORMAL_MEMORY))) {\r\nWRN_MSG("cannot allocate framebuffer memory - use "\r\n"the stolen one\n");\r\ndinfo->fbmem_gart = 0;\r\n}\r\nif (agp_bind_memory(dinfo->gtt_fb_mem,\r\ndinfo->fb.offset)) {\r\nWRN_MSG("cannot bind framebuffer memory - use "\r\n"the stolen one\n");\r\ndinfo->fbmem_gart = 0;\r\n}\r\n}\r\nif (!dinfo->fbmem_gart)\r\ndinfo->fb.offset = 0;\r\ndinfo->fb.physical = dinfo->aperture.physical\r\n+ (dinfo->fb.offset << 12);\r\ndinfo->fb.virtual = dinfo->aperture.virtual + (dinfo->fb.offset << 12);\r\ndinfo->fb_start = dinfo->fb.offset << 12;\r\nagp_backend_release(bridge);\r\nif (mtrr)\r\nset_mtrr(dinfo);\r\nDBG_MSG("fb: 0x%x(+ 0x%x)/0x%x (0x%p)\n",\r\ndinfo->fb.physical, dinfo->fb.offset, dinfo->fb.size,\r\ndinfo->fb.virtual);\r\nDBG_MSG("MMIO: 0x%x/0x%x (0x%p)\n",\r\ndinfo->mmio_base_phys, INTEL_REG_SIZE,\r\ndinfo->mmio_base);\r\nDBG_MSG("ring buffer: 0x%x/0x%x (0x%p)\n",\r\ndinfo->ring.physical, dinfo->ring.size,\r\ndinfo->ring.virtual);\r\nDBG_MSG("HW cursor: 0x%x/0x%x (0x%p) (offset 0x%x) (phys 0x%x)\n",\r\ndinfo->cursor.physical, dinfo->cursor.size,\r\ndinfo->cursor.virtual, dinfo->cursor.offset,\r\ndinfo->cursor.physical);\r\nDBG_MSG("options: vram = %d, accel = %d, hwcursor = %d, fixed = %d, "\r\n"noinit = %d\n", vram, accel, hwcursor, fixed, noinit);\r\nDBG_MSG("options: mode = \"%s\"\n", mode ? mode : "");\r\nif (probeonly)\r\nbailout(dinfo);\r\ndvo = intelfbhw_check_non_crt(dinfo);\r\nif (dvo) {\r\ndinfo->fixed_mode = 1;\r\nWRN_MSG("Non-CRT device is enabled ( ");\r\ni = 0;\r\nwhile (dvo) {\r\nif (dvo & 1) {\r\ns = intelfbhw_dvo_to_string(1 << i);\r\nif (s)\r\nprintk("%s ", s);\r\n}\r\ndvo >>= 1;\r\n++i;\r\n}\r\nprintk("). Disabling mode switching.\n");\r\n}\r\nif (bailearly == 1)\r\nbailout(dinfo);\r\nif (FIXED_MODE(dinfo) &&\r\nscreen_info.orig_video_isVGA != VIDEO_TYPE_VLFB) {\r\nERR_MSG("Video mode must be programmed at boot time.\n");\r\ncleanup(dinfo);\r\nreturn -ENODEV;\r\n}\r\nif (bailearly == 2)\r\nbailout(dinfo);\r\nif (screen_info.orig_video_isVGA == VIDEO_TYPE_VLFB)\r\nget_initial_mode(dinfo);\r\nif (bailearly == 3)\r\nbailout(dinfo);\r\nif (FIXED_MODE(dinfo))\r\nupdate_dinfo(dinfo, &dinfo->initial_var);\r\nif (bailearly == 4)\r\nbailout(dinfo);\r\nif (intelfb_set_fbinfo(dinfo)) {\r\ncleanup(dinfo);\r\nreturn -ENODEV;\r\n}\r\nif (bailearly == 5)\r\nbailout(dinfo);\r\n#ifdef CONFIG_FB_INTEL_I2C\r\nintelfb_create_i2c_busses(dinfo);\r\n#endif\r\nif (bailearly == 6)\r\nbailout(dinfo);\r\npci_set_drvdata(pdev, dinfo);\r\ni = intelfbhw_read_hw_state(dinfo, &dinfo->save_state,\r\nbailearly > 6 ? bailearly - 6 : 0);\r\nif (i != 0) {\r\nDBG_MSG("intelfbhw_read_hw_state returned %d\n", i);\r\nbailout(dinfo);\r\n}\r\nintelfbhw_print_hw_state(dinfo, &dinfo->save_state);\r\nif (bailearly == 18)\r\nbailout(dinfo);\r\ndinfo->pipe = intelfbhw_active_pipe(&dinfo->save_state);\r\nif (dinfo->hwcursor) {\r\nintelfbhw_cursor_init(dinfo);\r\nintelfbhw_cursor_reset(dinfo);\r\n}\r\nif (bailearly == 19)\r\nbailout(dinfo);\r\nif (dinfo->accel)\r\nintelfbhw_2d_start(dinfo);\r\nif (bailearly == 20)\r\nbailout(dinfo);\r\nif (noregister)\r\nbailout(dinfo);\r\nif (register_framebuffer(dinfo->info) < 0) {\r\nERR_MSG("Cannot register framebuffer.\n");\r\ncleanup(dinfo);\r\nreturn -ENODEV;\r\n}\r\ndinfo->registered = 1;\r\ndinfo->open = 0;\r\ninit_waitqueue_head(&dinfo->vsync.wait);\r\nspin_lock_init(&dinfo->int_lock);\r\ndinfo->irq_flags = 0;\r\ndinfo->vsync.pan_display = 0;\r\ndinfo->vsync.pan_offset = 0;\r\nreturn 0;\r\nerr_out_pixmap:\r\nfb_dealloc_cmap(&info->cmap);\r\nerr_out_cmap:\r\nframebuffer_release(info);\r\nreturn -ENODEV;\r\n}\r\nstatic void intelfb_pci_unregister(struct pci_dev *pdev)\r\n{\r\nstruct intelfb_info *dinfo = pci_get_drvdata(pdev);\r\nDBG_MSG("intelfb_pci_unregister\n");\r\nif (!dinfo)\r\nreturn;\r\ncleanup(dinfo);\r\npci_set_drvdata(pdev, NULL);\r\n}\r\nint __inline__ intelfb_var_to_depth(const struct fb_var_screeninfo *var)\r\n{\r\nDBG_MSG("intelfb_var_to_depth: bpp: %d, green.length is %d\n",\r\nvar->bits_per_pixel, var->green.length);\r\nswitch (var->bits_per_pixel) {\r\ncase 16:\r\nreturn (var->green.length == 6) ? 16 : 15;\r\ncase 32:\r\nreturn 24;\r\ndefault:\r\nreturn var->bits_per_pixel;\r\n}\r\n}\r\nstatic __inline__ int var_to_refresh(const struct fb_var_screeninfo *var)\r\n{\r\nint xtot = var->xres + var->left_margin + var->right_margin +\r\nvar->hsync_len;\r\nint ytot = var->yres + var->upper_margin + var->lower_margin +\r\nvar->vsync_len;\r\nreturn (1000000000 / var->pixclock * 1000 + 500) / xtot / ytot;\r\n}\r\nstatic void get_initial_mode(struct intelfb_info *dinfo)\r\n{\r\nstruct fb_var_screeninfo *var;\r\nint xtot, ytot;\r\nDBG_MSG("get_initial_mode\n");\r\ndinfo->initial_vga = 1;\r\ndinfo->initial_fb_base = screen_info.lfb_base;\r\ndinfo->initial_video_ram = screen_info.lfb_size * KB(64);\r\ndinfo->initial_pitch = screen_info.lfb_linelength;\r\nvar = &dinfo->initial_var;\r\nmemset(var, 0, sizeof(*var));\r\nvar->xres = screen_info.lfb_width;\r\nvar->yres = screen_info.lfb_height;\r\nvar->bits_per_pixel = screen_info.lfb_depth;\r\nswitch (screen_info.lfb_depth) {\r\ncase 15:\r\nvar->bits_per_pixel = 16;\r\nbreak;\r\ncase 24:\r\nvar->bits_per_pixel = 32;\r\nbreak;\r\n}\r\nDBG_MSG("Initial info: FB is 0x%x/0x%x (%d kByte)\n",\r\ndinfo->initial_fb_base, dinfo->initial_video_ram,\r\nBtoKB(dinfo->initial_video_ram));\r\nDBG_MSG("Initial info: mode is %dx%d-%d (%d)\n",\r\nvar->xres, var->yres, var->bits_per_pixel,\r\ndinfo->initial_pitch);\r\nvar->left_margin = (var->xres / 8) & 0xf8;\r\nvar->right_margin = 32;\r\nvar->upper_margin = 16;\r\nvar->lower_margin = 4;\r\nvar->hsync_len = (var->xres / 8) & 0xf8;\r\nvar->vsync_len = 4;\r\nxtot = var->xres + var->left_margin +\r\nvar->right_margin + var->hsync_len;\r\nytot = var->yres + var->upper_margin +\r\nvar->lower_margin + var->vsync_len;\r\nvar->pixclock = 10000000 / xtot * 1000 / ytot * 100 / 60;\r\nvar->height = -1;\r\nvar->width = -1;\r\nif (var->bits_per_pixel > 8) {\r\nvar->red.offset = screen_info.red_pos;\r\nvar->red.length = screen_info.red_size;\r\nvar->green.offset = screen_info.green_pos;\r\nvar->green.length = screen_info.green_size;\r\nvar->blue.offset = screen_info.blue_pos;\r\nvar->blue.length = screen_info.blue_size;\r\nvar->transp.offset = screen_info.rsvd_pos;\r\nvar->transp.length = screen_info.rsvd_size;\r\n} else {\r\nvar->red.length = 8;\r\nvar->green.length = 8;\r\nvar->blue.length = 8;\r\n}\r\n}\r\nstatic int intelfb_init_var(struct intelfb_info *dinfo)\r\n{\r\nstruct fb_var_screeninfo *var;\r\nint msrc = 0;\r\nDBG_MSG("intelfb_init_var\n");\r\nvar = &dinfo->info->var;\r\nif (FIXED_MODE(dinfo)) {\r\nmemcpy(var, &dinfo->initial_var,\r\nsizeof(struct fb_var_screeninfo));\r\nmsrc = 5;\r\n} else {\r\nconst u8 *edid_s = fb_firmware_edid(&dinfo->pdev->dev);\r\nu8 *edid_d = NULL;\r\nif (edid_s) {\r\nedid_d = kmemdup(edid_s, EDID_LENGTH, GFP_KERNEL);\r\nif (edid_d) {\r\nfb_edid_to_monspecs(edid_d,\r\n&dinfo->info->monspecs);\r\nkfree(edid_d);\r\n}\r\n}\r\nif (mode) {\r\nprintk("intelfb: Looking for mode in private "\r\n"database\n");\r\nmsrc = fb_find_mode(var, dinfo->info, mode,\r\ndinfo->info->monspecs.modedb,\r\ndinfo->info->monspecs.modedb_len,\r\nNULL, 0);\r\nif (msrc && msrc > 1) {\r\nprintk("intelfb: No mode in private database, "\r\n"intelfb: looking for mode in global "\r\n"database ");\r\nmsrc = fb_find_mode(var, dinfo->info, mode,\r\nNULL, 0, NULL, 0);\r\nif (msrc)\r\nmsrc |= 8;\r\n}\r\n}\r\nif (!msrc)\r\nmsrc = fb_find_mode(var, dinfo->info, PREFERRED_MODE,\r\nNULL, 0, NULL, 0);\r\n}\r\nif (!msrc) {\r\nERR_MSG("Cannot find a suitable video mode.\n");\r\nreturn 1;\r\n}\r\nINF_MSG("Initial video mode is %dx%d-%d@%d.\n", var->xres, var->yres,\r\nvar->bits_per_pixel, var_to_refresh(var));\r\nDBG_MSG("Initial video mode is from %d.\n", msrc);\r\n#if ALLOCATE_FOR_PANNING\r\nvar->xres_virtual = var->xres;\r\nvar->yres_virtual =\r\ndinfo->fb.size / 2 / (var->bits_per_pixel * var->xres);\r\nif (var->yres_virtual < var->yres)\r\nvar->yres_virtual = var->yres;\r\n#else\r\nvar->yres_virtual = var->yres;\r\n#endif\r\nif (dinfo->accel)\r\nvar->accel_flags |= FB_ACCELF_TEXT;\r\nelse\r\nvar->accel_flags &= ~FB_ACCELF_TEXT;\r\nreturn 0;\r\n}\r\nstatic int intelfb_set_fbinfo(struct intelfb_info *dinfo)\r\n{\r\nstruct fb_info *info = dinfo->info;\r\nDBG_MSG("intelfb_set_fbinfo\n");\r\ninfo->flags = FBINFO_FLAG_DEFAULT;\r\ninfo->fbops = &intel_fb_ops;\r\ninfo->pseudo_palette = dinfo->pseudo_palette;\r\ninfo->pixmap.size = 64*1024;\r\ninfo->pixmap.buf_align = 8;\r\ninfo->pixmap.access_align = 32;\r\ninfo->pixmap.flags = FB_PIXMAP_SYSTEM;\r\nif (intelfb_init_var(dinfo))\r\nreturn 1;\r\ninfo->pixmap.scan_align = 1;\r\nstrcpy(info->fix.id, dinfo->name);\r\ninfo->fix.smem_start = dinfo->fb.physical;\r\ninfo->fix.smem_len = dinfo->fb.size;\r\ninfo->fix.type = FB_TYPE_PACKED_PIXELS;\r\ninfo->fix.type_aux = 0;\r\ninfo->fix.xpanstep = 8;\r\ninfo->fix.ypanstep = 1;\r\ninfo->fix.ywrapstep = 0;\r\ninfo->fix.mmio_start = dinfo->mmio_base_phys;\r\ninfo->fix.mmio_len = INTEL_REG_SIZE;\r\ninfo->fix.accel = FB_ACCEL_I830;\r\nupdate_dinfo(dinfo, &info->var);\r\nreturn 0;\r\n}\r\nstatic void update_dinfo(struct intelfb_info *dinfo,\r\nstruct fb_var_screeninfo *var)\r\n{\r\nDBG_MSG("update_dinfo\n");\r\ndinfo->bpp = var->bits_per_pixel;\r\ndinfo->depth = intelfb_var_to_depth(var);\r\ndinfo->xres = var->xres;\r\ndinfo->yres = var->xres;\r\ndinfo->pixclock = var->pixclock;\r\ndinfo->info->fix.visual = dinfo->visual;\r\ndinfo->info->fix.line_length = dinfo->pitch;\r\nswitch (dinfo->bpp) {\r\ncase 8:\r\ndinfo->visual = FB_VISUAL_PSEUDOCOLOR;\r\ndinfo->pitch = var->xres_virtual;\r\nbreak;\r\ncase 16:\r\ndinfo->visual = FB_VISUAL_TRUECOLOR;\r\ndinfo->pitch = var->xres_virtual * 2;\r\nbreak;\r\ncase 32:\r\ndinfo->visual = FB_VISUAL_TRUECOLOR;\r\ndinfo->pitch = var->xres_virtual * 4;\r\nbreak;\r\n}\r\nif (IS_I9XX(dinfo))\r\ndinfo->pitch = ROUND_UP_TO(dinfo->pitch, STRIDE_ALIGNMENT_I9XX);\r\nelse\r\ndinfo->pitch = ROUND_UP_TO(dinfo->pitch, STRIDE_ALIGNMENT);\r\nif (FIXED_MODE(dinfo))\r\ndinfo->pitch = dinfo->initial_pitch;\r\ndinfo->info->screen_base = (char __iomem *)dinfo->fb.virtual;\r\ndinfo->info->fix.line_length = dinfo->pitch;\r\ndinfo->info->fix.visual = dinfo->visual;\r\n}\r\nstatic int intelfb_open(struct fb_info *info, int user)\r\n{\r\nstruct intelfb_info *dinfo = GET_DINFO(info);\r\nif (user)\r\ndinfo->open++;\r\nreturn 0;\r\n}\r\nstatic int intelfb_release(struct fb_info *info, int user)\r\n{\r\nstruct intelfb_info *dinfo = GET_DINFO(info);\r\nif (user) {\r\ndinfo->open--;\r\nmsleep(1);\r\nif (!dinfo->open)\r\nintelfbhw_disable_irq(dinfo);\r\n}\r\nreturn 0;\r\n}\r\nstatic int intelfb_check_var(struct fb_var_screeninfo *var,\r\nstruct fb_info *info)\r\n{\r\nint change_var = 0;\r\nstruct fb_var_screeninfo v;\r\nstruct intelfb_info *dinfo;\r\nstatic int first = 1;\r\nint i;\r\nstatic const int pitches[] = {\r\n128 * 8,\r\n128 * 16,\r\n128 * 32,\r\n128 * 64,\r\n0\r\n};\r\nDBG_MSG("intelfb_check_var: accel_flags is %d\n", var->accel_flags);\r\ndinfo = GET_DINFO(info);\r\nif (intelfbhw_validate_mode(dinfo, var) != 0)\r\nreturn -EINVAL;\r\nv = *var;\r\nfor (i = 0; pitches[i] != 0; i++) {\r\nif (pitches[i] >= v.xres_virtual) {\r\nv.xres_virtual = pitches[i];\r\nbreak;\r\n}\r\n}\r\nif (v.bits_per_pixel <= 8)\r\nv.bits_per_pixel = 8;\r\nelse if (v.bits_per_pixel <= 16) {\r\nif (v.bits_per_pixel == 16)\r\nv.green.length = 6;\r\nv.bits_per_pixel = 16;\r\n} else if (v.bits_per_pixel <= 32)\r\nv.bits_per_pixel = 32;\r\nelse\r\nreturn -EINVAL;\r\nchange_var = ((info->var.xres != var->xres) ||\r\n(info->var.yres != var->yres) ||\r\n(info->var.xres_virtual != var->xres_virtual) ||\r\n(info->var.yres_virtual != var->yres_virtual) ||\r\n(info->var.bits_per_pixel != var->bits_per_pixel) ||\r\nmemcmp(&info->var.red, &var->red, sizeof(var->red)) ||\r\nmemcmp(&info->var.green, &var->green,\r\nsizeof(var->green)) ||\r\nmemcmp(&info->var.blue, &var->blue, sizeof(var->blue)));\r\nif (FIXED_MODE(dinfo) &&\r\n(change_var ||\r\nvar->yres_virtual > dinfo->initial_var.yres_virtual ||\r\nvar->yres_virtual < dinfo->initial_var.yres ||\r\nvar->xoffset || var->nonstd)) {\r\nif (first) {\r\nERR_MSG("Changing the video mode is not supported.\n");\r\nfirst = 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nswitch (intelfb_var_to_depth(&v)) {\r\ncase 8:\r\nv.red.offset = v.green.offset = v.blue.offset = 0;\r\nv.red.length = v.green.length = v.blue.length = 8;\r\nv.transp.offset = v.transp.length = 0;\r\nbreak;\r\ncase 15:\r\nv.red.offset = 10;\r\nv.green.offset = 5;\r\nv.blue.offset = 0;\r\nv.red.length = v.green.length = v.blue.length = 5;\r\nv.transp.offset = v.transp.length = 0;\r\nbreak;\r\ncase 16:\r\nv.red.offset = 11;\r\nv.green.offset = 5;\r\nv.blue.offset = 0;\r\nv.red.length = 5;\r\nv.green.length = 6;\r\nv.blue.length = 5;\r\nv.transp.offset = v.transp.length = 0;\r\nbreak;\r\ncase 24:\r\nv.red.offset = 16;\r\nv.green.offset = 8;\r\nv.blue.offset = 0;\r\nv.red.length = v.green.length = v.blue.length = 8;\r\nv.transp.offset = v.transp.length = 0;\r\nbreak;\r\ncase 32:\r\nv.red.offset = 16;\r\nv.green.offset = 8;\r\nv.blue.offset = 0;\r\nv.red.length = v.green.length = v.blue.length = 8;\r\nv.transp.offset = 24;\r\nv.transp.length = 8;\r\nbreak;\r\n}\r\nif (v.xoffset < 0)\r\nv.xoffset = 0;\r\nif (v.yoffset < 0)\r\nv.yoffset = 0;\r\nif (v.xoffset > v.xres_virtual - v.xres)\r\nv.xoffset = v.xres_virtual - v.xres;\r\nif (v.yoffset > v.yres_virtual - v.yres)\r\nv.yoffset = v.yres_virtual - v.yres;\r\nv.red.msb_right = v.green.msb_right = v.blue.msb_right =\r\nv.transp.msb_right = 0;\r\n*var = v;\r\nreturn 0;\r\n}\r\nstatic int intelfb_set_par(struct fb_info *info)\r\n{\r\nstruct intelfb_hwstate *hw;\r\nstruct intelfb_info *dinfo = GET_DINFO(info);\r\nif (FIXED_MODE(dinfo)) {\r\nERR_MSG("Changing the video mode is not supported.\n");\r\nreturn -EINVAL;\r\n}\r\nhw = kmalloc(sizeof(*hw), GFP_ATOMIC);\r\nif (!hw)\r\nreturn -ENOMEM;\r\nDBG_MSG("intelfb_set_par (%dx%d-%d)\n", info->var.xres,\r\ninfo->var.yres, info->var.bits_per_pixel);\r\nOUTREG(DPLL_A, INREG(DPLL_A) & ~DPLL_VCO_ENABLE);\r\nintelfb_blank(FB_BLANK_POWERDOWN, info);\r\nif (ACCEL(dinfo, info))\r\nintelfbhw_2d_stop(dinfo);\r\nmemcpy(hw, &dinfo->save_state, sizeof(*hw));\r\nif (intelfbhw_mode_to_hw(dinfo, hw, &info->var))\r\ngoto invalid_mode;\r\nif (intelfbhw_program_mode(dinfo, hw, 0))\r\ngoto invalid_mode;\r\n#if REGDUMP > 0\r\nintelfbhw_read_hw_state(dinfo, hw, 0);\r\nintelfbhw_print_hw_state(dinfo, hw);\r\n#endif\r\nupdate_dinfo(dinfo, &info->var);\r\nif (ACCEL(dinfo, info))\r\nintelfbhw_2d_start(dinfo);\r\nintelfb_pan_display(&info->var, info);\r\nintelfb_blank(FB_BLANK_UNBLANK, info);\r\nif (ACCEL(dinfo, info)) {\r\ninfo->flags = FBINFO_DEFAULT | FBINFO_HWACCEL_YPAN |\r\nFBINFO_HWACCEL_COPYAREA | FBINFO_HWACCEL_FILLRECT |\r\nFBINFO_HWACCEL_IMAGEBLIT;\r\n} else\r\ninfo->flags = FBINFO_DEFAULT | FBINFO_HWACCEL_YPAN;\r\nkfree(hw);\r\nreturn 0;\r\ninvalid_mode:\r\nkfree(hw);\r\nreturn -EINVAL;\r\n}\r\nstatic int intelfb_setcolreg(unsigned regno, unsigned red, unsigned green,\r\nunsigned blue, unsigned transp,\r\nstruct fb_info *info)\r\n{\r\nstruct intelfb_info *dinfo = GET_DINFO(info);\r\n#if VERBOSE > 0\r\nDBG_MSG("intelfb_setcolreg: regno %d, depth %d\n", regno, dinfo->depth);\r\n#endif\r\nif (regno > 255)\r\nreturn 1;\r\nif (dinfo->depth == 8) {\r\nred >>= 8;\r\ngreen >>= 8;\r\nblue >>= 8;\r\nintelfbhw_setcolreg(dinfo, regno, red, green, blue,\r\ntransp);\r\n}\r\nif (regno < 16) {\r\nswitch (dinfo->depth) {\r\ncase 15:\r\ndinfo->pseudo_palette[regno] = ((red & 0xf800) >> 1) |\r\n((green & 0xf800) >> 6) |\r\n((blue & 0xf800) >> 11);\r\nbreak;\r\ncase 16:\r\ndinfo->pseudo_palette[regno] = (red & 0xf800) |\r\n((green & 0xfc00) >> 5) |\r\n((blue & 0xf800) >> 11);\r\nbreak;\r\ncase 24:\r\ndinfo->pseudo_palette[regno] = ((red & 0xff00) << 8) |\r\n(green & 0xff00) |\r\n((blue & 0xff00) >> 8);\r\nbreak;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int intelfb_blank(int blank, struct fb_info *info)\r\n{\r\nintelfbhw_do_blank(blank, info);\r\nreturn 0;\r\n}\r\nstatic int intelfb_pan_display(struct fb_var_screeninfo *var,\r\nstruct fb_info *info)\r\n{\r\nintelfbhw_pan_display(var, info);\r\nreturn 0;\r\n}\r\nstatic int intelfb_ioctl(struct fb_info *info, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\nint retval = 0;\r\nstruct intelfb_info *dinfo = GET_DINFO(info);\r\nu32 pipe = 0;\r\nswitch (cmd) {\r\ncase FBIO_WAITFORVSYNC:\r\nif (get_user(pipe, (__u32 __user *)arg))\r\nreturn -EFAULT;\r\nretval = intelfbhw_wait_for_vsync(dinfo, pipe);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn retval;\r\n}\r\nstatic void intelfb_fillrect (struct fb_info *info,\r\nconst struct fb_fillrect *rect)\r\n{\r\nstruct intelfb_info *dinfo = GET_DINFO(info);\r\nu32 rop, color;\r\n#if VERBOSE > 0\r\nDBG_MSG("intelfb_fillrect\n");\r\n#endif\r\nif (!ACCEL(dinfo, info) || dinfo->depth == 4) {\r\ncfb_fillrect(info, rect);\r\nreturn;\r\n}\r\nif (rect->rop == ROP_COPY)\r\nrop = PAT_ROP_GXCOPY;\r\nelse\r\nrop = PAT_ROP_GXXOR;\r\nif (dinfo->depth != 8)\r\ncolor = dinfo->pseudo_palette[rect->color];\r\nelse\r\ncolor = rect->color;\r\nintelfbhw_do_fillrect(dinfo, rect->dx, rect->dy,\r\nrect->width, rect->height, color,\r\ndinfo->pitch, info->var.bits_per_pixel,\r\nrop);\r\n}\r\nstatic void intelfb_copyarea(struct fb_info *info,\r\nconst struct fb_copyarea *region)\r\n{\r\nstruct intelfb_info *dinfo = GET_DINFO(info);\r\n#if VERBOSE > 0\r\nDBG_MSG("intelfb_copyarea\n");\r\n#endif\r\nif (!ACCEL(dinfo, info) || dinfo->depth == 4) {\r\ncfb_copyarea(info, region);\r\nreturn;\r\n}\r\nintelfbhw_do_bitblt(dinfo, region->sx, region->sy, region->dx,\r\nregion->dy, region->width, region->height,\r\ndinfo->pitch, info->var.bits_per_pixel);\r\n}\r\nstatic void intelfb_imageblit(struct fb_info *info,\r\nconst struct fb_image *image)\r\n{\r\nstruct intelfb_info *dinfo = GET_DINFO(info);\r\nu32 fgcolor, bgcolor;\r\n#if VERBOSE > 0\r\nDBG_MSG("intelfb_imageblit\n");\r\n#endif\r\nif (!ACCEL(dinfo, info) || dinfo->depth == 4\r\n|| image->depth != 1) {\r\ncfb_imageblit(info, image);\r\nreturn;\r\n}\r\nif (dinfo->depth != 8) {\r\nfgcolor = dinfo->pseudo_palette[image->fg_color];\r\nbgcolor = dinfo->pseudo_palette[image->bg_color];\r\n} else {\r\nfgcolor = image->fg_color;\r\nbgcolor = image->bg_color;\r\n}\r\nif (!intelfbhw_do_drawglyph(dinfo, fgcolor, bgcolor, image->width,\r\nimage->height, image->data,\r\nimage->dx, image->dy,\r\ndinfo->pitch, info->var.bits_per_pixel)) {\r\ncfb_imageblit(info, image);\r\nreturn;\r\n}\r\n}\r\nstatic int intelfb_cursor(struct fb_info *info, struct fb_cursor *cursor)\r\n{\r\nstruct intelfb_info *dinfo = GET_DINFO(info);\r\nu32 physical;\r\n#if VERBOSE > 0\r\nDBG_MSG("intelfb_cursor\n");\r\n#endif\r\nif (!dinfo->hwcursor)\r\nreturn -ENODEV;\r\nintelfbhw_cursor_hide(dinfo);\r\nphysical = (dinfo->mobile || IS_I9XX(dinfo)) ? dinfo->cursor.physical :\r\n(dinfo->cursor.offset << 12);\r\nif (INREG(CURSOR_A_BASEADDR) != physical) {\r\nu32 fg, bg;\r\nDBG_MSG("the cursor was killed - restore it !!\n");\r\nDBG_MSG("size %d, %d pos %d, %d\n",\r\ncursor->image.width, cursor->image.height,\r\ncursor->image.dx, cursor->image.dy);\r\nintelfbhw_cursor_init(dinfo);\r\nintelfbhw_cursor_reset(dinfo);\r\nintelfbhw_cursor_setpos(dinfo, cursor->image.dx,\r\ncursor->image.dy);\r\nif (dinfo->depth != 8) {\r\nfg =dinfo->pseudo_palette[cursor->image.fg_color];\r\nbg =dinfo->pseudo_palette[cursor->image.bg_color];\r\n} else {\r\nfg = cursor->image.fg_color;\r\nbg = cursor->image.bg_color;\r\n}\r\nintelfbhw_cursor_setcolor(dinfo, bg, fg);\r\nintelfbhw_cursor_load(dinfo, cursor->image.width,\r\ncursor->image.height,\r\ndinfo->cursor_src);\r\nif (cursor->enable)\r\nintelfbhw_cursor_show(dinfo);\r\nreturn 0;\r\n}\r\nif (cursor->set & FB_CUR_SETPOS) {\r\nu32 dx, dy;\r\ndx = cursor->image.dx - info->var.xoffset;\r\ndy = cursor->image.dy - info->var.yoffset;\r\nintelfbhw_cursor_setpos(dinfo, dx, dy);\r\n}\r\nif (cursor->set & FB_CUR_SETSIZE) {\r\nif (cursor->image.width > 64 || cursor->image.height > 64)\r\nreturn -ENXIO;\r\nintelfbhw_cursor_reset(dinfo);\r\n}\r\nif (cursor->set & FB_CUR_SETCMAP) {\r\nu32 fg, bg;\r\nif (dinfo->depth != 8) {\r\nfg = dinfo->pseudo_palette[cursor->image.fg_color];\r\nbg = dinfo->pseudo_palette[cursor->image.bg_color];\r\n} else {\r\nfg = cursor->image.fg_color;\r\nbg = cursor->image.bg_color;\r\n}\r\nintelfbhw_cursor_setcolor(dinfo, bg, fg);\r\n}\r\nif (cursor->set & (FB_CUR_SETSHAPE | FB_CUR_SETIMAGE)) {\r\nu32 s_pitch = (ROUND_UP_TO(cursor->image.width, 8) / 8);\r\nu32 size = s_pitch * cursor->image.height;\r\nu8 *dat = (u8 *) cursor->image.data;\r\nu8 *msk = (u8 *) cursor->mask;\r\nu8 src[64];\r\nu32 i;\r\nif (cursor->image.depth != 1)\r\nreturn -ENXIO;\r\nswitch (cursor->rop) {\r\ncase ROP_XOR:\r\nfor (i = 0; i < size; i++)\r\nsrc[i] = dat[i] ^ msk[i];\r\nbreak;\r\ncase ROP_COPY:\r\ndefault:\r\nfor (i = 0; i < size; i++)\r\nsrc[i] = dat[i] & msk[i];\r\nbreak;\r\n}\r\nmemcpy(dinfo->cursor_src, src, size);\r\nintelfbhw_cursor_load(dinfo, cursor->image.width,\r\ncursor->image.height, src);\r\n}\r\nif (cursor->enable)\r\nintelfbhw_cursor_show(dinfo);\r\nreturn 0;\r\n}\r\nstatic int intelfb_sync(struct fb_info *info)\r\n{\r\nstruct intelfb_info *dinfo = GET_DINFO(info);\r\n#if VERBOSE > 0\r\nDBG_MSG("intelfb_sync\n");\r\n#endif\r\nif (dinfo->ring_lockup)\r\nreturn 0;\r\nintelfbhw_do_sync(dinfo);\r\nreturn 0;\r\n}
