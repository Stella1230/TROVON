static inline struct saa7191 *to_saa7191(struct v4l2_subdev *sd)\r\n{\r\nreturn container_of(sd, struct saa7191, sd);\r\n}\r\nstatic u8 saa7191_read_reg(struct v4l2_subdev *sd, u8 reg)\r\n{\r\nreturn to_saa7191(sd)->reg[reg];\r\n}\r\nstatic int saa7191_read_status(struct v4l2_subdev *sd, u8 *value)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nint ret;\r\nret = i2c_master_recv(client, value, 1);\r\nif (ret < 0) {\r\nprintk(KERN_ERR "SAA7191: saa7191_read_status(): read failed\n");\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int saa7191_write_reg(struct v4l2_subdev *sd, u8 reg, u8 value)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nto_saa7191(sd)->reg[reg] = value;\r\nreturn i2c_smbus_write_byte_data(client, reg, value);\r\n}\r\nstatic int saa7191_write_block(struct v4l2_subdev *sd,\r\nu8 length, const u8 *data)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nstruct saa7191 *decoder = to_saa7191(sd);\r\nint i;\r\nint ret;\r\nfor (i = 0; i < (length - 1); i++) {\r\ndecoder->reg[data[0] + i] = data[i + 1];\r\n}\r\nret = i2c_master_send(client, data, length);\r\nif (ret < 0) {\r\nprintk(KERN_ERR "SAA7191: saa7191_write_block(): "\r\n"write failed\n");\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int saa7191_s_routing(struct v4l2_subdev *sd,\r\nu32 input, u32 output, u32 config)\r\n{\r\nstruct saa7191 *decoder = to_saa7191(sd);\r\nu8 luma = saa7191_read_reg(sd, SAA7191_REG_LUMA);\r\nu8 iock = saa7191_read_reg(sd, SAA7191_REG_IOCK);\r\nint err;\r\nswitch (input) {\r\ncase SAA7191_INPUT_COMPOSITE:\r\niock &= ~(SAA7191_IOCK_CHRS | SAA7191_IOCK_GPSW1\r\n| SAA7191_IOCK_GPSW2);\r\nluma &= ~SAA7191_LUMA_BYPS;\r\nbreak;\r\ncase SAA7191_INPUT_SVIDEO:\r\niock |= SAA7191_IOCK_CHRS | SAA7191_IOCK_GPSW2;\r\nluma |= SAA7191_LUMA_BYPS;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nerr = saa7191_write_reg(sd, SAA7191_REG_LUMA, luma);\r\nif (err)\r\nreturn -EIO;\r\nerr = saa7191_write_reg(sd, SAA7191_REG_IOCK, iock);\r\nif (err)\r\nreturn -EIO;\r\ndecoder->input = input;\r\nreturn 0;\r\n}\r\nstatic int saa7191_s_std(struct v4l2_subdev *sd, v4l2_std_id norm)\r\n{\r\nstruct saa7191 *decoder = to_saa7191(sd);\r\nu8 stdc = saa7191_read_reg(sd, SAA7191_REG_STDC);\r\nu8 ctl3 = saa7191_read_reg(sd, SAA7191_REG_CTL3);\r\nu8 chcv = saa7191_read_reg(sd, SAA7191_REG_CHCV);\r\nint err;\r\nif (norm & V4L2_STD_PAL) {\r\nstdc &= ~SAA7191_STDC_SECS;\r\nctl3 &= ~(SAA7191_CTL3_AUFD | SAA7191_CTL3_FSEL);\r\nchcv = SAA7191_CHCV_PAL;\r\n} else if (norm & V4L2_STD_NTSC) {\r\nstdc &= ~SAA7191_STDC_SECS;\r\nctl3 &= ~SAA7191_CTL3_AUFD;\r\nctl3 |= SAA7191_CTL3_FSEL;\r\nchcv = SAA7191_CHCV_NTSC;\r\n} else if (norm & V4L2_STD_SECAM) {\r\nstdc |= SAA7191_STDC_SECS;\r\nctl3 &= ~(SAA7191_CTL3_AUFD | SAA7191_CTL3_FSEL);\r\nchcv = SAA7191_CHCV_PAL;\r\n} else {\r\nreturn -EINVAL;\r\n}\r\nerr = saa7191_write_reg(sd, SAA7191_REG_CTL3, ctl3);\r\nif (err)\r\nreturn -EIO;\r\nerr = saa7191_write_reg(sd, SAA7191_REG_STDC, stdc);\r\nif (err)\r\nreturn -EIO;\r\nerr = saa7191_write_reg(sd, SAA7191_REG_CHCV, chcv);\r\nif (err)\r\nreturn -EIO;\r\ndecoder->norm = norm;\r\ndprintk("ctl3: %02x stdc: %02x chcv: %02x\n", ctl3,\r\nstdc, chcv);\r\ndprintk("norm: %llx\n", norm);\r\nreturn 0;\r\n}\r\nstatic int saa7191_wait_for_signal(struct v4l2_subdev *sd, u8 *status)\r\n{\r\nint i = 0;\r\ndprintk("Checking for signal...\n");\r\nfor (i = 0; i < SAA7191_SYNC_COUNT; i++) {\r\nif (saa7191_read_status(sd, status))\r\nreturn -EIO;\r\nif (((*status) & SAA7191_STATUS_HLCK) == 0) {\r\ndprintk("Signal found\n");\r\nreturn 0;\r\n}\r\nmsleep(SAA7191_SYNC_DELAY);\r\n}\r\ndprintk("No signal\n");\r\nreturn -EBUSY;\r\n}\r\nstatic int saa7191_querystd(struct v4l2_subdev *sd, v4l2_std_id *norm)\r\n{\r\nstruct saa7191 *decoder = to_saa7191(sd);\r\nu8 stdc = saa7191_read_reg(sd, SAA7191_REG_STDC);\r\nu8 ctl3 = saa7191_read_reg(sd, SAA7191_REG_CTL3);\r\nu8 status;\r\nv4l2_std_id old_norm = decoder->norm;\r\nint err = 0;\r\ndprintk("SAA7191 extended signal auto-detection...\n");\r\n*norm = V4L2_STD_NTSC | V4L2_STD_PAL | V4L2_STD_SECAM;\r\nstdc &= ~SAA7191_STDC_SECS;\r\nctl3 &= ~(SAA7191_CTL3_FSEL);\r\nerr = saa7191_write_reg(sd, SAA7191_REG_STDC, stdc);\r\nif (err) {\r\nerr = -EIO;\r\ngoto out;\r\n}\r\nerr = saa7191_write_reg(sd, SAA7191_REG_CTL3, ctl3);\r\nif (err) {\r\nerr = -EIO;\r\ngoto out;\r\n}\r\nctl3 |= SAA7191_CTL3_AUFD;\r\nerr = saa7191_write_reg(sd, SAA7191_REG_CTL3, ctl3);\r\nif (err) {\r\nerr = -EIO;\r\ngoto out;\r\n}\r\nmsleep(SAA7191_SYNC_DELAY);\r\nerr = saa7191_wait_for_signal(sd, &status);\r\nif (err)\r\ngoto out;\r\nif (status & SAA7191_STATUS_FIDT) {\r\ndprintk("60Hz signal: NTSC\n");\r\n*norm = V4L2_STD_NTSC;\r\nreturn 0;\r\n}\r\ndprintk("50Hz signal: Trying PAL...\n");\r\nerr = saa7191_s_std(sd, V4L2_STD_PAL);\r\nif (err)\r\ngoto out;\r\nmsleep(SAA7191_SYNC_DELAY);\r\nerr = saa7191_wait_for_signal(sd, &status);\r\nif (err)\r\ngoto out;\r\nif (status & SAA7191_STATUS_FIDT) {\r\ndprintk("No 50Hz signal\n");\r\nsaa7191_s_std(sd, old_norm);\r\nreturn -EAGAIN;\r\n}\r\nif (status & SAA7191_STATUS_CODE) {\r\ndprintk("PAL\n");\r\n*norm = V4L2_STD_PAL;\r\nreturn saa7191_s_std(sd, old_norm);\r\n}\r\ndprintk("No color detected with PAL - Trying SECAM...\n");\r\nerr = saa7191_s_std(sd, V4L2_STD_SECAM);\r\nif (err)\r\ngoto out;\r\nmsleep(SAA7191_SYNC_DELAY);\r\nerr = saa7191_wait_for_signal(sd, &status);\r\nif (err)\r\ngoto out;\r\nif (status & SAA7191_STATUS_FIDT) {\r\ndprintk("No 50Hz signal\n");\r\nerr = -EAGAIN;\r\ngoto out;\r\n}\r\nif (status & SAA7191_STATUS_CODE) {\r\ndprintk("SECAM\n");\r\n*norm = V4L2_STD_SECAM;\r\nreturn saa7191_s_std(sd, old_norm);\r\n}\r\ndprintk("No color detected with SECAM - Going back to PAL.\n");\r\nout:\r\nreturn saa7191_s_std(sd, old_norm);\r\n}\r\nstatic int saa7191_autodetect_norm(struct v4l2_subdev *sd)\r\n{\r\nu8 status;\r\ndprintk("SAA7191 signal auto-detection...\n");\r\ndprintk("Reading status...\n");\r\nif (saa7191_read_status(sd, &status))\r\nreturn -EIO;\r\ndprintk("Checking for signal...\n");\r\nif (status & SAA7191_STATUS_HLCK) {\r\ndprintk("No signal\n");\r\nreturn -EBUSY;\r\n}\r\ndprintk("Signal found\n");\r\nif (status & SAA7191_STATUS_FIDT) {\r\ndprintk("NTSC\n");\r\nreturn saa7191_s_std(sd, V4L2_STD_NTSC);\r\n} else {\r\ndprintk("PAL\n");\r\nreturn saa7191_s_std(sd, V4L2_STD_PAL);\r\n}\r\n}\r\nstatic int saa7191_g_ctrl(struct v4l2_subdev *sd, struct v4l2_control *ctrl)\r\n{\r\nu8 reg;\r\nint ret = 0;\r\nswitch (ctrl->id) {\r\ncase SAA7191_CONTROL_BANDPASS:\r\ncase SAA7191_CONTROL_BANDPASS_WEIGHT:\r\ncase SAA7191_CONTROL_CORING:\r\nreg = saa7191_read_reg(sd, SAA7191_REG_LUMA);\r\nswitch (ctrl->id) {\r\ncase SAA7191_CONTROL_BANDPASS:\r\nctrl->value = ((s32)reg & SAA7191_LUMA_BPSS_MASK)\r\n>> SAA7191_LUMA_BPSS_SHIFT;\r\nbreak;\r\ncase SAA7191_CONTROL_BANDPASS_WEIGHT:\r\nctrl->value = ((s32)reg & SAA7191_LUMA_APER_MASK)\r\n>> SAA7191_LUMA_APER_SHIFT;\r\nbreak;\r\ncase SAA7191_CONTROL_CORING:\r\nctrl->value = ((s32)reg & SAA7191_LUMA_CORI_MASK)\r\n>> SAA7191_LUMA_CORI_SHIFT;\r\nbreak;\r\n}\r\nbreak;\r\ncase SAA7191_CONTROL_FORCE_COLOUR:\r\ncase SAA7191_CONTROL_CHROMA_GAIN:\r\nreg = saa7191_read_reg(sd, SAA7191_REG_GAIN);\r\nif (ctrl->id == SAA7191_CONTROL_FORCE_COLOUR)\r\nctrl->value = ((s32)reg & SAA7191_GAIN_COLO) ? 1 : 0;\r\nelse\r\nctrl->value = ((s32)reg & SAA7191_GAIN_LFIS_MASK)\r\n>> SAA7191_GAIN_LFIS_SHIFT;\r\nbreak;\r\ncase V4L2_CID_HUE:\r\nreg = saa7191_read_reg(sd, SAA7191_REG_HUEC);\r\nif (reg < 0x80)\r\nreg += 0x80;\r\nelse\r\nreg -= 0x80;\r\nctrl->value = (s32)reg;\r\nbreak;\r\ncase SAA7191_CONTROL_VTRC:\r\nreg = saa7191_read_reg(sd, SAA7191_REG_STDC);\r\nctrl->value = ((s32)reg & SAA7191_STDC_VTRC) ? 1 : 0;\r\nbreak;\r\ncase SAA7191_CONTROL_LUMA_DELAY:\r\nreg = saa7191_read_reg(sd, SAA7191_REG_CTL3);\r\nctrl->value = ((s32)reg & SAA7191_CTL3_YDEL_MASK)\r\n>> SAA7191_CTL3_YDEL_SHIFT;\r\nif (ctrl->value >= 4)\r\nctrl->value -= 8;\r\nbreak;\r\ncase SAA7191_CONTROL_VNR:\r\nreg = saa7191_read_reg(sd, SAA7191_REG_CTL4);\r\nctrl->value = ((s32)reg & SAA7191_CTL4_VNOI_MASK)\r\n>> SAA7191_CTL4_VNOI_SHIFT;\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\n}\r\nreturn ret;\r\n}\r\nstatic int saa7191_s_ctrl(struct v4l2_subdev *sd, struct v4l2_control *ctrl)\r\n{\r\nu8 reg;\r\nint ret = 0;\r\nswitch (ctrl->id) {\r\ncase SAA7191_CONTROL_BANDPASS:\r\ncase SAA7191_CONTROL_BANDPASS_WEIGHT:\r\ncase SAA7191_CONTROL_CORING:\r\nreg = saa7191_read_reg(sd, SAA7191_REG_LUMA);\r\nswitch (ctrl->id) {\r\ncase SAA7191_CONTROL_BANDPASS:\r\nreg &= ~SAA7191_LUMA_BPSS_MASK;\r\nreg |= (ctrl->value << SAA7191_LUMA_BPSS_SHIFT)\r\n& SAA7191_LUMA_BPSS_MASK;\r\nbreak;\r\ncase SAA7191_CONTROL_BANDPASS_WEIGHT:\r\nreg &= ~SAA7191_LUMA_APER_MASK;\r\nreg |= (ctrl->value << SAA7191_LUMA_APER_SHIFT)\r\n& SAA7191_LUMA_APER_MASK;\r\nbreak;\r\ncase SAA7191_CONTROL_CORING:\r\nreg &= ~SAA7191_LUMA_CORI_MASK;\r\nreg |= (ctrl->value << SAA7191_LUMA_CORI_SHIFT)\r\n& SAA7191_LUMA_CORI_MASK;\r\nbreak;\r\n}\r\nret = saa7191_write_reg(sd, SAA7191_REG_LUMA, reg);\r\nbreak;\r\ncase SAA7191_CONTROL_FORCE_COLOUR:\r\ncase SAA7191_CONTROL_CHROMA_GAIN:\r\nreg = saa7191_read_reg(sd, SAA7191_REG_GAIN);\r\nif (ctrl->id == SAA7191_CONTROL_FORCE_COLOUR) {\r\nif (ctrl->value)\r\nreg |= SAA7191_GAIN_COLO;\r\nelse\r\nreg &= ~SAA7191_GAIN_COLO;\r\n} else {\r\nreg &= ~SAA7191_GAIN_LFIS_MASK;\r\nreg |= (ctrl->value << SAA7191_GAIN_LFIS_SHIFT)\r\n& SAA7191_GAIN_LFIS_MASK;\r\n}\r\nret = saa7191_write_reg(sd, SAA7191_REG_GAIN, reg);\r\nbreak;\r\ncase V4L2_CID_HUE:\r\nreg = ctrl->value & 0xff;\r\nif (reg < 0x80)\r\nreg += 0x80;\r\nelse\r\nreg -= 0x80;\r\nret = saa7191_write_reg(sd, SAA7191_REG_HUEC, reg);\r\nbreak;\r\ncase SAA7191_CONTROL_VTRC:\r\nreg = saa7191_read_reg(sd, SAA7191_REG_STDC);\r\nif (ctrl->value)\r\nreg |= SAA7191_STDC_VTRC;\r\nelse\r\nreg &= ~SAA7191_STDC_VTRC;\r\nret = saa7191_write_reg(sd, SAA7191_REG_STDC, reg);\r\nbreak;\r\ncase SAA7191_CONTROL_LUMA_DELAY: {\r\ns32 value = ctrl->value;\r\nif (value < 0)\r\nvalue += 8;\r\nreg = saa7191_read_reg(sd, SAA7191_REG_CTL3);\r\nreg &= ~SAA7191_CTL3_YDEL_MASK;\r\nreg |= (value << SAA7191_CTL3_YDEL_SHIFT)\r\n& SAA7191_CTL3_YDEL_MASK;\r\nret = saa7191_write_reg(sd, SAA7191_REG_CTL3, reg);\r\nbreak;\r\n}\r\ncase SAA7191_CONTROL_VNR:\r\nreg = saa7191_read_reg(sd, SAA7191_REG_CTL4);\r\nreg &= ~SAA7191_CTL4_VNOI_MASK;\r\nreg |= (ctrl->value << SAA7191_CTL4_VNOI_SHIFT)\r\n& SAA7191_CTL4_VNOI_MASK;\r\nret = saa7191_write_reg(sd, SAA7191_REG_CTL4, reg);\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\n}\r\nreturn ret;\r\n}\r\nstatic int saa7191_g_input_status(struct v4l2_subdev *sd, u32 *status)\r\n{\r\nu8 status_reg;\r\nint res = V4L2_IN_ST_NO_SIGNAL;\r\nif (saa7191_read_status(sd, &status_reg))\r\nreturn -EIO;\r\nif ((status_reg & SAA7191_STATUS_HLCK) == 0)\r\nres = 0;\r\nif (!(status_reg & SAA7191_STATUS_CODE))\r\nres |= V4L2_IN_ST_NO_COLOR;\r\n*status = res;\r\nreturn 0;\r\n}\r\nstatic int saa7191_g_chip_ident(struct v4l2_subdev *sd,\r\nstruct v4l2_dbg_chip_ident *chip)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nreturn v4l2_chip_ident_i2c_client(client, chip, V4L2_IDENT_SAA7191, 0);\r\n}\r\nstatic int saa7191_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nint err = 0;\r\nstruct saa7191 *decoder;\r\nstruct v4l2_subdev *sd;\r\nv4l_info(client, "chip found @ 0x%x (%s)\n",\r\nclient->addr << 1, client->adapter->name);\r\ndecoder = kzalloc(sizeof(*decoder), GFP_KERNEL);\r\nif (!decoder)\r\nreturn -ENOMEM;\r\nsd = &decoder->sd;\r\nv4l2_i2c_subdev_init(sd, client, &saa7191_ops);\r\nerr = saa7191_write_block(sd, sizeof(initseq), initseq);\r\nif (err) {\r\nprintk(KERN_ERR "SAA7191 initialization failed\n");\r\nkfree(decoder);\r\nreturn err;\r\n}\r\nprintk(KERN_INFO "SAA7191 initialized\n");\r\ndecoder->input = SAA7191_INPUT_COMPOSITE;\r\ndecoder->norm = V4L2_STD_PAL;\r\nerr = saa7191_autodetect_norm(sd);\r\nif (err && (err != -EBUSY))\r\nprintk(KERN_ERR "SAA7191: Signal auto-detection failed\n");\r\nreturn 0;\r\n}\r\nstatic int saa7191_remove(struct i2c_client *client)\r\n{\r\nstruct v4l2_subdev *sd = i2c_get_clientdata(client);\r\nv4l2_device_unregister_subdev(sd);\r\nkfree(to_saa7191(sd));\r\nreturn 0;\r\n}
