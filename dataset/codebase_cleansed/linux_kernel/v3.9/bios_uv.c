s64 uv_bios_call(enum uv_bios_cmd which, u64 a1, u64 a2, u64 a3, u64 a4, u64 a5)\r\n{\r\nstruct uv_systab *tab = &uv_systab;\r\ns64 ret;\r\nif (!tab->function)\r\nreturn BIOS_STATUS_UNIMPLEMENTED;\r\nret = efi_call6((void *)__va(tab->function), (u64)which,\r\na1, a2, a3, a4, a5);\r\nreturn ret;\r\n}\r\ns64 uv_bios_call_irqsave(enum uv_bios_cmd which, u64 a1, u64 a2, u64 a3,\r\nu64 a4, u64 a5)\r\n{\r\nunsigned long bios_flags;\r\ns64 ret;\r\nlocal_irq_save(bios_flags);\r\nret = uv_bios_call(which, a1, a2, a3, a4, a5);\r\nlocal_irq_restore(bios_flags);\r\nreturn ret;\r\n}\r\ns64 uv_bios_call_reentrant(enum uv_bios_cmd which, u64 a1, u64 a2, u64 a3,\r\nu64 a4, u64 a5)\r\n{\r\ns64 ret;\r\npreempt_disable();\r\nret = uv_bios_call(which, a1, a2, a3, a4, a5);\r\npreempt_enable();\r\nreturn ret;\r\n}\r\ns64 uv_bios_get_sn_info(int fc, int *uvtype, long *partid, long *coher,\r\nlong *region, long *ssn)\r\n{\r\ns64 ret;\r\nu64 v0, v1;\r\nunion partition_info_u part;\r\nret = uv_bios_call_irqsave(UV_BIOS_GET_SN_INFO, fc,\r\n(u64)(&v0), (u64)(&v1), 0, 0);\r\nif (ret != BIOS_STATUS_SUCCESS)\r\nreturn ret;\r\npart.val = v0;\r\nif (uvtype)\r\n*uvtype = part.hub_version;\r\nif (partid)\r\n*partid = part.partition_id;\r\nif (coher)\r\n*coher = part.coherence_id;\r\nif (region)\r\n*region = part.region_size;\r\nif (ssn)\r\n*ssn = v1;\r\nreturn ret;\r\n}\r\nint\r\nuv_bios_mq_watchlist_alloc(unsigned long addr, unsigned int mq_size,\r\nunsigned long *intr_mmr_offset)\r\n{\r\nu64 watchlist;\r\ns64 ret;\r\nret = (int)uv_bios_call_irqsave(UV_BIOS_WATCHLIST_ALLOC, addr,\r\nmq_size, (u64)intr_mmr_offset,\r\n(u64)&watchlist, 0);\r\nif (ret < BIOS_STATUS_SUCCESS)\r\nreturn ret;\r\nreturn watchlist;\r\n}\r\nint\r\nuv_bios_mq_watchlist_free(int blade, int watchlist_num)\r\n{\r\nreturn (int)uv_bios_call_irqsave(UV_BIOS_WATCHLIST_FREE,\r\nblade, watchlist_num, 0, 0, 0);\r\n}\r\ns64\r\nuv_bios_change_memprotect(u64 paddr, u64 len, enum uv_memprotect perms)\r\n{\r\nreturn uv_bios_call_irqsave(UV_BIOS_MEMPROTECT, paddr, len,\r\nperms, 0, 0);\r\n}\r\ns64\r\nuv_bios_reserved_page_pa(u64 buf, u64 *cookie, u64 *addr, u64 *len)\r\n{\r\ns64 ret;\r\nret = uv_bios_call_irqsave(UV_BIOS_GET_PARTITION_ADDR, (u64)cookie,\r\n(u64)addr, buf, (u64)len, 0);\r\nreturn ret;\r\n}\r\ns64 uv_bios_freq_base(u64 clock_type, u64 *ticks_per_second)\r\n{\r\nreturn uv_bios_call(UV_BIOS_FREQ_BASE, clock_type,\r\n(u64)ticks_per_second, 0, 0, 0);\r\n}\r\nint uv_bios_set_legacy_vga_target(bool decode, int domain, int bus)\r\n{\r\nreturn uv_bios_call(UV_BIOS_SET_LEGACY_VGA_TARGET,\r\n(u64)decode, (u64)domain, (u64)bus, 0, 0);\r\n}\r\nvoid uv_bios_init(void)\r\n{\r\nstruct uv_systab *tab;\r\nif ((efi.uv_systab == EFI_INVALID_TABLE_ADDR) ||\r\n(efi.uv_systab == (unsigned long)NULL)) {\r\nprintk(KERN_CRIT "No EFI UV System Table.\n");\r\nuv_systab.function = (unsigned long)NULL;\r\nreturn;\r\n}\r\ntab = (struct uv_systab *)ioremap(efi.uv_systab,\r\nsizeof(struct uv_systab));\r\nif (strncmp(tab->signature, "UVST", 4) != 0)\r\nprintk(KERN_ERR "bad signature in UV system table!");\r\nmemcpy(&uv_systab, tab, sizeof(struct uv_systab));\r\niounmap(tab);\r\nprintk(KERN_INFO "EFI UV System Table Revision %d\n",\r\nuv_systab.revision);\r\n}\r\nvoid uv_bios_init(void) { }
