static inline struct Scsi_Host *virtio_scsi_host(struct virtio_device *vdev)\r\n{\r\nreturn vdev->priv;\r\n}\r\nstatic void virtscsi_compute_resid(struct scsi_cmnd *sc, u32 resid)\r\n{\r\nif (!resid)\r\nreturn;\r\nif (!scsi_bidi_cmnd(sc)) {\r\nscsi_set_resid(sc, resid);\r\nreturn;\r\n}\r\nscsi_in(sc)->resid = min(resid, scsi_in(sc)->length);\r\nscsi_out(sc)->resid = resid - scsi_in(sc)->resid;\r\n}\r\nstatic void virtscsi_complete_cmd(void *buf)\r\n{\r\nstruct virtio_scsi_cmd *cmd = buf;\r\nstruct scsi_cmnd *sc = cmd->sc;\r\nstruct virtio_scsi_cmd_resp *resp = &cmd->resp.cmd;\r\ndev_dbg(&sc->device->sdev_gendev,\r\n"cmd %p response %u status %#02x sense_len %u\n",\r\nsc, resp->response, resp->status, resp->sense_len);\r\nsc->result = resp->status;\r\nvirtscsi_compute_resid(sc, resp->resid);\r\nswitch (resp->response) {\r\ncase VIRTIO_SCSI_S_OK:\r\nset_host_byte(sc, DID_OK);\r\nbreak;\r\ncase VIRTIO_SCSI_S_OVERRUN:\r\nset_host_byte(sc, DID_ERROR);\r\nbreak;\r\ncase VIRTIO_SCSI_S_ABORTED:\r\nset_host_byte(sc, DID_ABORT);\r\nbreak;\r\ncase VIRTIO_SCSI_S_BAD_TARGET:\r\nset_host_byte(sc, DID_BAD_TARGET);\r\nbreak;\r\ncase VIRTIO_SCSI_S_RESET:\r\nset_host_byte(sc, DID_RESET);\r\nbreak;\r\ncase VIRTIO_SCSI_S_BUSY:\r\nset_host_byte(sc, DID_BUS_BUSY);\r\nbreak;\r\ncase VIRTIO_SCSI_S_TRANSPORT_FAILURE:\r\nset_host_byte(sc, DID_TRANSPORT_DISRUPTED);\r\nbreak;\r\ncase VIRTIO_SCSI_S_TARGET_FAILURE:\r\nset_host_byte(sc, DID_TARGET_FAILURE);\r\nbreak;\r\ncase VIRTIO_SCSI_S_NEXUS_FAILURE:\r\nset_host_byte(sc, DID_NEXUS_FAILURE);\r\nbreak;\r\ndefault:\r\nscmd_printk(KERN_WARNING, sc, "Unknown response %d",\r\nresp->response);\r\ncase VIRTIO_SCSI_S_FAILURE:\r\nset_host_byte(sc, DID_ERROR);\r\nbreak;\r\n}\r\nWARN_ON(resp->sense_len > VIRTIO_SCSI_SENSE_SIZE);\r\nif (sc->sense_buffer) {\r\nmemcpy(sc->sense_buffer, resp->sense,\r\nmin_t(u32, resp->sense_len, VIRTIO_SCSI_SENSE_SIZE));\r\nif (resp->sense_len)\r\nset_driver_byte(sc, DRIVER_SENSE);\r\n}\r\nmempool_free(cmd, virtscsi_cmd_pool);\r\nsc->scsi_done(sc);\r\n}\r\nstatic void virtscsi_vq_done(struct virtqueue *vq, void (*fn)(void *buf))\r\n{\r\nvoid *buf;\r\nunsigned int len;\r\ndo {\r\nvirtqueue_disable_cb(vq);\r\nwhile ((buf = virtqueue_get_buf(vq, &len)) != NULL)\r\nfn(buf);\r\n} while (!virtqueue_enable_cb(vq));\r\n}\r\nstatic void virtscsi_req_done(struct virtqueue *vq)\r\n{\r\nstruct Scsi_Host *sh = virtio_scsi_host(vq->vdev);\r\nstruct virtio_scsi *vscsi = shost_priv(sh);\r\nunsigned long flags;\r\nspin_lock_irqsave(&vscsi->req_vq.vq_lock, flags);\r\nvirtscsi_vq_done(vq, virtscsi_complete_cmd);\r\nspin_unlock_irqrestore(&vscsi->req_vq.vq_lock, flags);\r\n}\r\nstatic void virtscsi_complete_free(void *buf)\r\n{\r\nstruct virtio_scsi_cmd *cmd = buf;\r\nif (cmd->comp)\r\ncomplete_all(cmd->comp);\r\nelse\r\nmempool_free(cmd, virtscsi_cmd_pool);\r\n}\r\nstatic void virtscsi_ctrl_done(struct virtqueue *vq)\r\n{\r\nstruct Scsi_Host *sh = virtio_scsi_host(vq->vdev);\r\nstruct virtio_scsi *vscsi = shost_priv(sh);\r\nunsigned long flags;\r\nspin_lock_irqsave(&vscsi->ctrl_vq.vq_lock, flags);\r\nvirtscsi_vq_done(vq, virtscsi_complete_free);\r\nspin_unlock_irqrestore(&vscsi->ctrl_vq.vq_lock, flags);\r\n}\r\nstatic int virtscsi_kick_event(struct virtio_scsi *vscsi,\r\nstruct virtio_scsi_event_node *event_node)\r\n{\r\nint err;\r\nstruct scatterlist sg;\r\nunsigned long flags;\r\nsg_init_one(&sg, &event_node->event, sizeof(struct virtio_scsi_event));\r\nspin_lock_irqsave(&vscsi->event_vq.vq_lock, flags);\r\nerr = virtqueue_add_buf(vscsi->event_vq.vq, &sg, 0, 1, event_node,\r\nGFP_ATOMIC);\r\nif (!err)\r\nvirtqueue_kick(vscsi->event_vq.vq);\r\nspin_unlock_irqrestore(&vscsi->event_vq.vq_lock, flags);\r\nreturn err;\r\n}\r\nstatic int virtscsi_kick_event_all(struct virtio_scsi *vscsi)\r\n{\r\nint i;\r\nfor (i = 0; i < VIRTIO_SCSI_EVENT_LEN; i++) {\r\nvscsi->event_list[i].vscsi = vscsi;\r\nvirtscsi_kick_event(vscsi, &vscsi->event_list[i]);\r\n}\r\nreturn 0;\r\n}\r\nstatic void virtscsi_cancel_event_work(struct virtio_scsi *vscsi)\r\n{\r\nint i;\r\nfor (i = 0; i < VIRTIO_SCSI_EVENT_LEN; i++)\r\ncancel_work_sync(&vscsi->event_list[i].work);\r\n}\r\nstatic void virtscsi_handle_transport_reset(struct virtio_scsi *vscsi,\r\nstruct virtio_scsi_event *event)\r\n{\r\nstruct scsi_device *sdev;\r\nstruct Scsi_Host *shost = virtio_scsi_host(vscsi->vdev);\r\nunsigned int target = event->lun[1];\r\nunsigned int lun = (event->lun[2] << 8) | event->lun[3];\r\nswitch (event->reason) {\r\ncase VIRTIO_SCSI_EVT_RESET_RESCAN:\r\nscsi_add_device(shost, 0, target, lun);\r\nbreak;\r\ncase VIRTIO_SCSI_EVT_RESET_REMOVED:\r\nsdev = scsi_device_lookup(shost, 0, target, lun);\r\nif (sdev) {\r\nscsi_remove_device(sdev);\r\nscsi_device_put(sdev);\r\n} else {\r\npr_err("SCSI device %d 0 %d %d not found\n",\r\nshost->host_no, target, lun);\r\n}\r\nbreak;\r\ndefault:\r\npr_info("Unsupport virtio scsi event reason %x\n", event->reason);\r\n}\r\n}\r\nstatic void virtscsi_handle_param_change(struct virtio_scsi *vscsi,\r\nstruct virtio_scsi_event *event)\r\n{\r\nstruct scsi_device *sdev;\r\nstruct Scsi_Host *shost = virtio_scsi_host(vscsi->vdev);\r\nunsigned int target = event->lun[1];\r\nunsigned int lun = (event->lun[2] << 8) | event->lun[3];\r\nu8 asc = event->reason & 255;\r\nu8 ascq = event->reason >> 8;\r\nsdev = scsi_device_lookup(shost, 0, target, lun);\r\nif (!sdev) {\r\npr_err("SCSI device %d 0 %d %d not found\n",\r\nshost->host_no, target, lun);\r\nreturn;\r\n}\r\nif (asc == 0x2a && (ascq == 0x00 || ascq == 0x01 || ascq == 0x09))\r\nscsi_rescan_device(&sdev->sdev_gendev);\r\nscsi_device_put(sdev);\r\n}\r\nstatic void virtscsi_handle_event(struct work_struct *work)\r\n{\r\nstruct virtio_scsi_event_node *event_node =\r\ncontainer_of(work, struct virtio_scsi_event_node, work);\r\nstruct virtio_scsi *vscsi = event_node->vscsi;\r\nstruct virtio_scsi_event *event = &event_node->event;\r\nif (event->event & VIRTIO_SCSI_T_EVENTS_MISSED) {\r\nevent->event &= ~VIRTIO_SCSI_T_EVENTS_MISSED;\r\nscsi_scan_host(virtio_scsi_host(vscsi->vdev));\r\n}\r\nswitch (event->event) {\r\ncase VIRTIO_SCSI_T_NO_EVENT:\r\nbreak;\r\ncase VIRTIO_SCSI_T_TRANSPORT_RESET:\r\nvirtscsi_handle_transport_reset(vscsi, event);\r\nbreak;\r\ncase VIRTIO_SCSI_T_PARAM_CHANGE:\r\nvirtscsi_handle_param_change(vscsi, event);\r\nbreak;\r\ndefault:\r\npr_err("Unsupport virtio scsi event %x\n", event->event);\r\n}\r\nvirtscsi_kick_event(vscsi, event_node);\r\n}\r\nstatic void virtscsi_complete_event(void *buf)\r\n{\r\nstruct virtio_scsi_event_node *event_node = buf;\r\nINIT_WORK(&event_node->work, virtscsi_handle_event);\r\nschedule_work(&event_node->work);\r\n}\r\nstatic void virtscsi_event_done(struct virtqueue *vq)\r\n{\r\nstruct Scsi_Host *sh = virtio_scsi_host(vq->vdev);\r\nstruct virtio_scsi *vscsi = shost_priv(sh);\r\nunsigned long flags;\r\nspin_lock_irqsave(&vscsi->event_vq.vq_lock, flags);\r\nvirtscsi_vq_done(vq, virtscsi_complete_event);\r\nspin_unlock_irqrestore(&vscsi->event_vq.vq_lock, flags);\r\n}\r\nstatic void virtscsi_map_sgl(struct scatterlist *sg, unsigned int *p_idx,\r\nstruct scsi_data_buffer *sdb)\r\n{\r\nstruct sg_table *table = &sdb->table;\r\nstruct scatterlist *sg_elem;\r\nunsigned int idx = *p_idx;\r\nint i;\r\nfor_each_sg(table->sgl, sg_elem, table->nents, i)\r\nsg[idx++] = *sg_elem;\r\n*p_idx = idx;\r\n}\r\nstatic void virtscsi_map_cmd(struct virtio_scsi_target_state *tgt,\r\nstruct virtio_scsi_cmd *cmd,\r\nunsigned *out_num, unsigned *in_num,\r\nsize_t req_size, size_t resp_size)\r\n{\r\nstruct scsi_cmnd *sc = cmd->sc;\r\nstruct scatterlist *sg = tgt->sg;\r\nunsigned int idx = 0;\r\nsg_set_buf(&sg[idx++], &cmd->req, req_size);\r\nif (sc && sc->sc_data_direction != DMA_FROM_DEVICE)\r\nvirtscsi_map_sgl(sg, &idx, scsi_out(sc));\r\n*out_num = idx;\r\nsg_set_buf(&sg[idx++], &cmd->resp, resp_size);\r\nif (sc && sc->sc_data_direction != DMA_TO_DEVICE)\r\nvirtscsi_map_sgl(sg, &idx, scsi_in(sc));\r\n*in_num = idx - *out_num;\r\n}\r\nstatic int virtscsi_kick_cmd(struct virtio_scsi_target_state *tgt,\r\nstruct virtio_scsi_vq *vq,\r\nstruct virtio_scsi_cmd *cmd,\r\nsize_t req_size, size_t resp_size, gfp_t gfp)\r\n{\r\nunsigned int out_num, in_num;\r\nunsigned long flags;\r\nint err;\r\nbool needs_kick = false;\r\nspin_lock_irqsave(&tgt->tgt_lock, flags);\r\nvirtscsi_map_cmd(tgt, cmd, &out_num, &in_num, req_size, resp_size);\r\nspin_lock(&vq->vq_lock);\r\nerr = virtqueue_add_buf(vq->vq, tgt->sg, out_num, in_num, cmd, gfp);\r\nspin_unlock(&tgt->tgt_lock);\r\nif (!err)\r\nneeds_kick = virtqueue_kick_prepare(vq->vq);\r\nspin_unlock_irqrestore(&vq->vq_lock, flags);\r\nif (needs_kick)\r\nvirtqueue_notify(vq->vq);\r\nreturn err;\r\n}\r\nstatic int virtscsi_queuecommand(struct Scsi_Host *sh, struct scsi_cmnd *sc)\r\n{\r\nstruct virtio_scsi *vscsi = shost_priv(sh);\r\nstruct virtio_scsi_target_state *tgt = vscsi->tgt[sc->device->id];\r\nstruct virtio_scsi_cmd *cmd;\r\nint ret;\r\nstruct Scsi_Host *shost = virtio_scsi_host(vscsi->vdev);\r\nBUG_ON(scsi_sg_count(sc) > shost->sg_tablesize);\r\nBUG_ON(sc->sc_data_direction == DMA_BIDIRECTIONAL);\r\ndev_dbg(&sc->device->sdev_gendev,\r\n"cmd %p CDB: %#02x\n", sc, sc->cmnd[0]);\r\nret = SCSI_MLQUEUE_HOST_BUSY;\r\ncmd = mempool_alloc(virtscsi_cmd_pool, GFP_ATOMIC);\r\nif (!cmd)\r\ngoto out;\r\nmemset(cmd, 0, sizeof(*cmd));\r\ncmd->sc = sc;\r\ncmd->req.cmd = (struct virtio_scsi_cmd_req){\r\n.lun[0] = 1,\r\n.lun[1] = sc->device->id,\r\n.lun[2] = (sc->device->lun >> 8) | 0x40,\r\n.lun[3] = sc->device->lun & 0xff,\r\n.tag = (unsigned long)sc,\r\n.task_attr = VIRTIO_SCSI_S_SIMPLE,\r\n.prio = 0,\r\n.crn = 0,\r\n};\r\nBUG_ON(sc->cmd_len > VIRTIO_SCSI_CDB_SIZE);\r\nmemcpy(cmd->req.cmd.cdb, sc->cmnd, sc->cmd_len);\r\nif (virtscsi_kick_cmd(tgt, &vscsi->req_vq, cmd,\r\nsizeof cmd->req.cmd, sizeof cmd->resp.cmd,\r\nGFP_ATOMIC) == 0)\r\nret = 0;\r\nelse\r\nmempool_free(cmd, virtscsi_cmd_pool);\r\nout:\r\nreturn ret;\r\n}\r\nstatic int virtscsi_tmf(struct virtio_scsi *vscsi, struct virtio_scsi_cmd *cmd)\r\n{\r\nDECLARE_COMPLETION_ONSTACK(comp);\r\nstruct virtio_scsi_target_state *tgt = vscsi->tgt[cmd->sc->device->id];\r\nint ret = FAILED;\r\ncmd->comp = &comp;\r\nif (virtscsi_kick_cmd(tgt, &vscsi->ctrl_vq, cmd,\r\nsizeof cmd->req.tmf, sizeof cmd->resp.tmf,\r\nGFP_NOIO) < 0)\r\ngoto out;\r\nwait_for_completion(&comp);\r\nif (cmd->resp.tmf.response == VIRTIO_SCSI_S_OK ||\r\ncmd->resp.tmf.response == VIRTIO_SCSI_S_FUNCTION_SUCCEEDED)\r\nret = SUCCESS;\r\nout:\r\nmempool_free(cmd, virtscsi_cmd_pool);\r\nreturn ret;\r\n}\r\nstatic int virtscsi_device_reset(struct scsi_cmnd *sc)\r\n{\r\nstruct virtio_scsi *vscsi = shost_priv(sc->device->host);\r\nstruct virtio_scsi_cmd *cmd;\r\nsdev_printk(KERN_INFO, sc->device, "device reset\n");\r\ncmd = mempool_alloc(virtscsi_cmd_pool, GFP_NOIO);\r\nif (!cmd)\r\nreturn FAILED;\r\nmemset(cmd, 0, sizeof(*cmd));\r\ncmd->sc = sc;\r\ncmd->req.tmf = (struct virtio_scsi_ctrl_tmf_req){\r\n.type = VIRTIO_SCSI_T_TMF,\r\n.subtype = VIRTIO_SCSI_T_TMF_LOGICAL_UNIT_RESET,\r\n.lun[0] = 1,\r\n.lun[1] = sc->device->id,\r\n.lun[2] = (sc->device->lun >> 8) | 0x40,\r\n.lun[3] = sc->device->lun & 0xff,\r\n};\r\nreturn virtscsi_tmf(vscsi, cmd);\r\n}\r\nstatic int virtscsi_abort(struct scsi_cmnd *sc)\r\n{\r\nstruct virtio_scsi *vscsi = shost_priv(sc->device->host);\r\nstruct virtio_scsi_cmd *cmd;\r\nscmd_printk(KERN_INFO, sc, "abort\n");\r\ncmd = mempool_alloc(virtscsi_cmd_pool, GFP_NOIO);\r\nif (!cmd)\r\nreturn FAILED;\r\nmemset(cmd, 0, sizeof(*cmd));\r\ncmd->sc = sc;\r\ncmd->req.tmf = (struct virtio_scsi_ctrl_tmf_req){\r\n.type = VIRTIO_SCSI_T_TMF,\r\n.subtype = VIRTIO_SCSI_T_TMF_ABORT_TASK,\r\n.lun[0] = 1,\r\n.lun[1] = sc->device->id,\r\n.lun[2] = (sc->device->lun >> 8) | 0x40,\r\n.lun[3] = sc->device->lun & 0xff,\r\n.tag = (unsigned long)sc,\r\n};\r\nreturn virtscsi_tmf(vscsi, cmd);\r\n}\r\nstatic void virtscsi_init_vq(struct virtio_scsi_vq *virtscsi_vq,\r\nstruct virtqueue *vq)\r\n{\r\nspin_lock_init(&virtscsi_vq->vq_lock);\r\nvirtscsi_vq->vq = vq;\r\n}\r\nstatic struct virtio_scsi_target_state *virtscsi_alloc_tgt(\r\nstruct virtio_device *vdev, int sg_elems)\r\n{\r\nstruct virtio_scsi_target_state *tgt;\r\ngfp_t gfp_mask = GFP_KERNEL;\r\ntgt = kmalloc(sizeof(*tgt) + sizeof(tgt->sg[0]) * (sg_elems + 2),\r\ngfp_mask);\r\nif (!tgt)\r\nreturn NULL;\r\nspin_lock_init(&tgt->tgt_lock);\r\nsg_init_table(tgt->sg, sg_elems + 2);\r\nreturn tgt;\r\n}\r\nstatic void virtscsi_scan(struct virtio_device *vdev)\r\n{\r\nstruct Scsi_Host *shost = (struct Scsi_Host *)vdev->priv;\r\nscsi_scan_host(shost);\r\n}\r\nstatic void virtscsi_remove_vqs(struct virtio_device *vdev)\r\n{\r\nstruct Scsi_Host *sh = virtio_scsi_host(vdev);\r\nstruct virtio_scsi *vscsi = shost_priv(sh);\r\nu32 i, num_targets;\r\nvdev->config->reset(vdev);\r\nnum_targets = sh->max_id;\r\nfor (i = 0; i < num_targets; i++) {\r\nkfree(vscsi->tgt[i]);\r\nvscsi->tgt[i] = NULL;\r\n}\r\nvdev->config->del_vqs(vdev);\r\n}\r\nstatic int virtscsi_init(struct virtio_device *vdev,\r\nstruct virtio_scsi *vscsi, int num_targets)\r\n{\r\nint err;\r\nstruct virtqueue *vqs[3];\r\nu32 i, sg_elems;\r\nvq_callback_t *callbacks[] = {\r\nvirtscsi_ctrl_done,\r\nvirtscsi_event_done,\r\nvirtscsi_req_done\r\n};\r\nconst char *names[] = {\r\n"control",\r\n"event",\r\n"request"\r\n};\r\nerr = vdev->config->find_vqs(vdev, 3, vqs, callbacks, names);\r\nif (err)\r\nreturn err;\r\nvirtscsi_init_vq(&vscsi->ctrl_vq, vqs[0]);\r\nvirtscsi_init_vq(&vscsi->event_vq, vqs[1]);\r\nvirtscsi_init_vq(&vscsi->req_vq, vqs[2]);\r\nvirtscsi_config_set(vdev, cdb_size, VIRTIO_SCSI_CDB_SIZE);\r\nvirtscsi_config_set(vdev, sense_size, VIRTIO_SCSI_SENSE_SIZE);\r\nif (virtio_has_feature(vdev, VIRTIO_SCSI_F_HOTPLUG))\r\nvirtscsi_kick_event_all(vscsi);\r\nsg_elems = virtscsi_config_get(vdev, seg_max) ?: 1;\r\nfor (i = 0; i < num_targets; i++) {\r\nvscsi->tgt[i] = virtscsi_alloc_tgt(vdev, sg_elems);\r\nif (!vscsi->tgt[i]) {\r\nerr = -ENOMEM;\r\ngoto out;\r\n}\r\n}\r\nerr = 0;\r\nout:\r\nif (err)\r\nvirtscsi_remove_vqs(vdev);\r\nreturn err;\r\n}\r\nstatic int virtscsi_probe(struct virtio_device *vdev)\r\n{\r\nstruct Scsi_Host *shost;\r\nstruct virtio_scsi *vscsi;\r\nint err;\r\nu32 sg_elems, num_targets;\r\nu32 cmd_per_lun;\r\nnum_targets = virtscsi_config_get(vdev, max_target) + 1;\r\nshost = scsi_host_alloc(&virtscsi_host_template,\r\nsizeof(*vscsi)\r\n+ num_targets * sizeof(struct virtio_scsi_target_state));\r\nif (!shost)\r\nreturn -ENOMEM;\r\nsg_elems = virtscsi_config_get(vdev, seg_max) ?: 1;\r\nshost->sg_tablesize = sg_elems;\r\nvscsi = shost_priv(shost);\r\nvscsi->vdev = vdev;\r\nvdev->priv = shost;\r\nerr = virtscsi_init(vdev, vscsi, num_targets);\r\nif (err)\r\ngoto virtscsi_init_failed;\r\ncmd_per_lun = virtscsi_config_get(vdev, cmd_per_lun) ?: 1;\r\nshost->cmd_per_lun = min_t(u32, cmd_per_lun, shost->can_queue);\r\nshost->max_sectors = virtscsi_config_get(vdev, max_sectors) ?: 0xFFFF;\r\nshost->max_lun = virtscsi_config_get(vdev, max_lun) + 1 + 0x4000;\r\nshost->max_id = num_targets;\r\nshost->max_channel = 0;\r\nshost->max_cmd_len = VIRTIO_SCSI_CDB_SIZE;\r\nerr = scsi_add_host(shost, &vdev->dev);\r\nif (err)\r\ngoto scsi_add_host_failed;\r\nreturn 0;\r\nscsi_add_host_failed:\r\nvdev->config->del_vqs(vdev);\r\nvirtscsi_init_failed:\r\nscsi_host_put(shost);\r\nreturn err;\r\n}\r\nstatic void virtscsi_remove(struct virtio_device *vdev)\r\n{\r\nstruct Scsi_Host *shost = virtio_scsi_host(vdev);\r\nstruct virtio_scsi *vscsi = shost_priv(shost);\r\nif (virtio_has_feature(vdev, VIRTIO_SCSI_F_HOTPLUG))\r\nvirtscsi_cancel_event_work(vscsi);\r\nscsi_remove_host(shost);\r\nvirtscsi_remove_vqs(vdev);\r\nscsi_host_put(shost);\r\n}\r\nstatic int virtscsi_freeze(struct virtio_device *vdev)\r\n{\r\nvirtscsi_remove_vqs(vdev);\r\nreturn 0;\r\n}\r\nstatic int virtscsi_restore(struct virtio_device *vdev)\r\n{\r\nstruct Scsi_Host *sh = virtio_scsi_host(vdev);\r\nstruct virtio_scsi *vscsi = shost_priv(sh);\r\nreturn virtscsi_init(vdev, vscsi, sh->max_id);\r\n}\r\nstatic int __init init(void)\r\n{\r\nint ret = -ENOMEM;\r\nvirtscsi_cmd_cache = KMEM_CACHE(virtio_scsi_cmd, 0);\r\nif (!virtscsi_cmd_cache) {\r\nprintk(KERN_ERR "kmem_cache_create() for "\r\n"virtscsi_cmd_cache failed\n");\r\ngoto error;\r\n}\r\nvirtscsi_cmd_pool =\r\nmempool_create_slab_pool(VIRTIO_SCSI_MEMPOOL_SZ,\r\nvirtscsi_cmd_cache);\r\nif (!virtscsi_cmd_pool) {\r\nprintk(KERN_ERR "mempool_create() for"\r\n"virtscsi_cmd_pool failed\n");\r\ngoto error;\r\n}\r\nret = register_virtio_driver(&virtio_scsi_driver);\r\nif (ret < 0)\r\ngoto error;\r\nreturn 0;\r\nerror:\r\nif (virtscsi_cmd_pool) {\r\nmempool_destroy(virtscsi_cmd_pool);\r\nvirtscsi_cmd_pool = NULL;\r\n}\r\nif (virtscsi_cmd_cache) {\r\nkmem_cache_destroy(virtscsi_cmd_cache);\r\nvirtscsi_cmd_cache = NULL;\r\n}\r\nreturn ret;\r\n}\r\nstatic void __exit fini(void)\r\n{\r\nunregister_virtio_driver(&virtio_scsi_driver);\r\nmempool_destroy(virtscsi_cmd_pool);\r\nkmem_cache_destroy(virtscsi_cmd_cache);\r\n}
