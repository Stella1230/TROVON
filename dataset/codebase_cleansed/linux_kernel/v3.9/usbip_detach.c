void usbip_detach_usage(void)\r\n{\r\nprintf("usage: %s", usbip_detach_usage_string);\r\n}\r\nstatic int detach_port(char *port)\r\n{\r\nint ret;\r\nuint8_t portnum;\r\nchar path[PATH_MAX+1];\r\nfor (unsigned int i=0; i < strlen(port); i++)\r\nif (!isdigit(port[i])) {\r\nerr("invalid port %s", port);\r\nreturn -1;\r\n}\r\nportnum = atoi(port);\r\nsnprintf(path, PATH_MAX, VHCI_STATE_PATH"/port%d", portnum);\r\nremove(path);\r\nrmdir(VHCI_STATE_PATH);\r\nret = usbip_vhci_driver_open();\r\nif (ret < 0) {\r\nerr("open vhci_driver");\r\nreturn -1;\r\n}\r\nret = usbip_vhci_detach_device(portnum);\r\nif (ret < 0)\r\nreturn -1;\r\nusbip_vhci_driver_close();\r\nreturn ret;\r\n}\r\nint usbip_detach(int argc, char *argv[])\r\n{\r\nstatic const struct option opts[] = {\r\n{ "port", required_argument, NULL, 'p' },\r\n{ NULL, 0, NULL, 0 }\r\n};\r\nint opt;\r\nint ret = -1;\r\nfor (;;) {\r\nopt = getopt_long(argc, argv, "p:", opts, NULL);\r\nif (opt == -1)\r\nbreak;\r\nswitch (opt) {\r\ncase 'p':\r\nret = detach_port(optarg);\r\ngoto out;\r\ndefault:\r\ngoto err_out;\r\n}\r\n}\r\nerr_out:\r\nusbip_detach_usage();\r\nout:\r\nreturn ret;\r\n}
