static int timeout_to_regval(int new_timeout)\r\n{\r\nint i;\r\nnew_timeout = clamp_val(new_timeout, 1, 8);\r\nfor (i = 0; i < ARRAY_SIZE(ts72xx_wdt_map); i++) {\r\nif (ts72xx_wdt_map[i].timeout >= new_timeout)\r\nreturn ts72xx_wdt_map[i].regval;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int regval_to_timeout(int regval)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(ts72xx_wdt_map); i++) {\r\nif (ts72xx_wdt_map[i].regval == regval)\r\nreturn ts72xx_wdt_map[i].timeout;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic inline void ts72xx_wdt_kick(struct ts72xx_wdt *wdt)\r\n{\r\n__raw_writeb(TS72XX_WDT_FEED_VAL, wdt->feed_reg);\r\n}\r\nstatic void ts72xx_wdt_start(struct ts72xx_wdt *wdt)\r\n{\r\nts72xx_wdt_kick(wdt);\r\n__raw_writeb((u8)wdt->regval, wdt->control_reg);\r\n}\r\nstatic void ts72xx_wdt_stop(struct ts72xx_wdt *wdt)\r\n{\r\nts72xx_wdt_kick(wdt);\r\n__raw_writeb(0, wdt->control_reg);\r\n}\r\nstatic int ts72xx_wdt_open(struct inode *inode, struct file *file)\r\n{\r\nstruct ts72xx_wdt *wdt = platform_get_drvdata(ts72xx_wdt_pdev);\r\nint regval;\r\nregval = timeout_to_regval(timeout);\r\nif (regval < 0) {\r\ndev_err(&wdt->pdev->dev,\r\n"failed to convert timeout (%d) to register value\n",\r\ntimeout);\r\nreturn -EINVAL;\r\n}\r\nif (mutex_lock_interruptible(&wdt->lock))\r\nreturn -ERESTARTSYS;\r\nif ((wdt->flags & TS72XX_WDT_BUSY_FLAG) != 0) {\r\nmutex_unlock(&wdt->lock);\r\nreturn -EBUSY;\r\n}\r\nwdt->flags = TS72XX_WDT_BUSY_FLAG;\r\nwdt->regval = regval;\r\nfile->private_data = wdt;\r\nts72xx_wdt_start(wdt);\r\nmutex_unlock(&wdt->lock);\r\nreturn nonseekable_open(inode, file);\r\n}\r\nstatic int ts72xx_wdt_release(struct inode *inode, struct file *file)\r\n{\r\nstruct ts72xx_wdt *wdt = file->private_data;\r\nif (mutex_lock_interruptible(&wdt->lock))\r\nreturn -ERESTARTSYS;\r\nif ((wdt->flags & TS72XX_WDT_EXPECT_CLOSE_FLAG) != 0) {\r\nts72xx_wdt_stop(wdt);\r\n} else {\r\ndev_warn(&wdt->pdev->dev,\r\n"TS-72XX WDT device closed unexpectly. "\r\n"Watchdog timer will not stop!\n");\r\nts72xx_wdt_kick(wdt);\r\n}\r\nwdt->flags = 0;\r\nmutex_unlock(&wdt->lock);\r\nreturn 0;\r\n}\r\nstatic ssize_t ts72xx_wdt_write(struct file *file,\r\nconst char __user *data,\r\nsize_t len,\r\nloff_t *ppos)\r\n{\r\nstruct ts72xx_wdt *wdt = file->private_data;\r\nif (!len)\r\nreturn 0;\r\nif (mutex_lock_interruptible(&wdt->lock))\r\nreturn -ERESTARTSYS;\r\nts72xx_wdt_kick(wdt);\r\nif (!nowayout) {\r\nint i;\r\nfor (i = 0; i < len; i++) {\r\nchar c;\r\nwdt->flags &= ~TS72XX_WDT_EXPECT_CLOSE_FLAG;\r\nif (get_user(c, data + i)) {\r\nmutex_unlock(&wdt->lock);\r\nreturn -EFAULT;\r\n}\r\nif (c == 'V') {\r\nwdt->flags |= TS72XX_WDT_EXPECT_CLOSE_FLAG;\r\nbreak;\r\n}\r\n}\r\n}\r\nmutex_unlock(&wdt->lock);\r\nreturn len;\r\n}\r\nstatic long ts72xx_wdt_ioctl(struct file *file, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\nstruct ts72xx_wdt *wdt = file->private_data;\r\nvoid __user *argp = (void __user *)arg;\r\nint __user *p = (int __user *)argp;\r\nint error = 0;\r\nif (mutex_lock_interruptible(&wdt->lock))\r\nreturn -ERESTARTSYS;\r\nswitch (cmd) {\r\ncase WDIOC_GETSUPPORT:\r\nerror = copy_to_user(argp, &winfo, sizeof(winfo));\r\nbreak;\r\ncase WDIOC_GETSTATUS:\r\ncase WDIOC_GETBOOTSTATUS:\r\nreturn put_user(0, p);\r\ncase WDIOC_KEEPALIVE:\r\nts72xx_wdt_kick(wdt);\r\nbreak;\r\ncase WDIOC_SETOPTIONS: {\r\nint options;\r\nif (get_user(options, p)) {\r\nerror = -EFAULT;\r\nbreak;\r\n}\r\nerror = -EINVAL;\r\nif ((options & WDIOS_DISABLECARD) != 0) {\r\nts72xx_wdt_stop(wdt);\r\nerror = 0;\r\n}\r\nif ((options & WDIOS_ENABLECARD) != 0) {\r\nts72xx_wdt_start(wdt);\r\nerror = 0;\r\n}\r\nbreak;\r\n}\r\ncase WDIOC_SETTIMEOUT: {\r\nint new_timeout;\r\nif (get_user(new_timeout, p)) {\r\nerror = -EFAULT;\r\n} else {\r\nint regval;\r\nregval = timeout_to_regval(new_timeout);\r\nif (regval < 0) {\r\nerror = -EINVAL;\r\n} else {\r\nts72xx_wdt_stop(wdt);\r\nwdt->regval = regval;\r\nts72xx_wdt_start(wdt);\r\n}\r\n}\r\nif (error)\r\nbreak;\r\n}\r\ncase WDIOC_GETTIMEOUT:\r\nif (put_user(regval_to_timeout(wdt->regval), p))\r\nerror = -EFAULT;\r\nbreak;\r\ndefault:\r\nerror = -ENOTTY;\r\nbreak;\r\n}\r\nmutex_unlock(&wdt->lock);\r\nreturn error;\r\n}\r\nstatic int ts72xx_wdt_probe(struct platform_device *pdev)\r\n{\r\nstruct ts72xx_wdt *wdt;\r\nstruct resource *r1, *r2;\r\nint error = 0;\r\nwdt = kzalloc(sizeof(struct ts72xx_wdt), GFP_KERNEL);\r\nif (!wdt) {\r\ndev_err(&pdev->dev, "failed to allocate memory\n");\r\nreturn -ENOMEM;\r\n}\r\nr1 = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!r1) {\r\ndev_err(&pdev->dev, "failed to get memory resource\n");\r\nerror = -ENODEV;\r\ngoto fail;\r\n}\r\nr1 = request_mem_region(r1->start, resource_size(r1), pdev->name);\r\nif (!r1) {\r\ndev_err(&pdev->dev, "cannot request memory region\n");\r\nerror = -EBUSY;\r\ngoto fail;\r\n}\r\nwdt->control_reg = ioremap(r1->start, resource_size(r1));\r\nif (!wdt->control_reg) {\r\ndev_err(&pdev->dev, "failed to map memory\n");\r\nerror = -ENODEV;\r\ngoto fail_free_control;\r\n}\r\nr2 = platform_get_resource(pdev, IORESOURCE_MEM, 1);\r\nif (!r2) {\r\ndev_err(&pdev->dev, "failed to get memory resource\n");\r\nerror = -ENODEV;\r\ngoto fail_unmap_control;\r\n}\r\nr2 = request_mem_region(r2->start, resource_size(r2), pdev->name);\r\nif (!r2) {\r\ndev_err(&pdev->dev, "cannot request memory region\n");\r\nerror = -EBUSY;\r\ngoto fail_unmap_control;\r\n}\r\nwdt->feed_reg = ioremap(r2->start, resource_size(r2));\r\nif (!wdt->feed_reg) {\r\ndev_err(&pdev->dev, "failed to map memory\n");\r\nerror = -ENODEV;\r\ngoto fail_free_feed;\r\n}\r\nplatform_set_drvdata(pdev, wdt);\r\nts72xx_wdt_pdev = pdev;\r\nwdt->pdev = pdev;\r\nmutex_init(&wdt->lock);\r\nts72xx_wdt_stop(wdt);\r\nerror = misc_register(&ts72xx_wdt_miscdev);\r\nif (error) {\r\ndev_err(&pdev->dev, "failed to register miscdev\n");\r\ngoto fail_unmap_feed;\r\n}\r\ndev_info(&pdev->dev, "TS-72xx Watchdog driver\n");\r\nreturn 0;\r\nfail_unmap_feed:\r\nplatform_set_drvdata(pdev, NULL);\r\niounmap(wdt->feed_reg);\r\nfail_free_feed:\r\nrelease_mem_region(r2->start, resource_size(r2));\r\nfail_unmap_control:\r\niounmap(wdt->control_reg);\r\nfail_free_control:\r\nrelease_mem_region(r1->start, resource_size(r1));\r\nfail:\r\nkfree(wdt);\r\nreturn error;\r\n}\r\nstatic int ts72xx_wdt_remove(struct platform_device *pdev)\r\n{\r\nstruct ts72xx_wdt *wdt = platform_get_drvdata(pdev);\r\nstruct resource *res;\r\nint error;\r\nerror = misc_deregister(&ts72xx_wdt_miscdev);\r\nplatform_set_drvdata(pdev, NULL);\r\niounmap(wdt->feed_reg);\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 1);\r\nrelease_mem_region(res->start, resource_size(res));\r\niounmap(wdt->control_reg);\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nrelease_mem_region(res->start, resource_size(res));\r\nkfree(wdt);\r\nreturn error;\r\n}
