static inline struct msm_gpio_dev *to_msm_gpio_dev(struct gpio_chip *chip)\r\n{\r\nreturn container_of(chip, struct msm_gpio_dev, gpio_chip);\r\n}\r\nstatic inline void set_gpio_bits(unsigned n, void __iomem *reg)\r\n{\r\nwritel(readl(reg) | n, reg);\r\n}\r\nstatic inline void clear_gpio_bits(unsigned n, void __iomem *reg)\r\n{\r\nwritel(readl(reg) & ~n, reg);\r\n}\r\nstatic int msm_gpio_get(struct gpio_chip *chip, unsigned offset)\r\n{\r\nreturn readl(GPIO_IN_OUT(offset)) & BIT(GPIO_IN);\r\n}\r\nstatic void msm_gpio_set(struct gpio_chip *chip, unsigned offset, int val)\r\n{\r\nwritel(val ? BIT(GPIO_OUT) : 0, GPIO_IN_OUT(offset));\r\n}\r\nstatic int msm_gpio_direction_input(struct gpio_chip *chip, unsigned offset)\r\n{\r\nunsigned long irq_flags;\r\nspin_lock_irqsave(&tlmm_lock, irq_flags);\r\nclear_gpio_bits(BIT(GPIO_OE), GPIO_CONFIG(offset));\r\nspin_unlock_irqrestore(&tlmm_lock, irq_flags);\r\nreturn 0;\r\n}\r\nstatic int msm_gpio_direction_output(struct gpio_chip *chip,\r\nunsigned offset,\r\nint val)\r\n{\r\nunsigned long irq_flags;\r\nspin_lock_irqsave(&tlmm_lock, irq_flags);\r\nmsm_gpio_set(chip, offset, val);\r\nset_gpio_bits(BIT(GPIO_OE), GPIO_CONFIG(offset));\r\nspin_unlock_irqrestore(&tlmm_lock, irq_flags);\r\nreturn 0;\r\n}\r\nstatic int msm_gpio_request(struct gpio_chip *chip, unsigned offset)\r\n{\r\nreturn msm_gpiomux_get(chip->base + offset);\r\n}\r\nstatic void msm_gpio_free(struct gpio_chip *chip, unsigned offset)\r\n{\r\nmsm_gpiomux_put(chip->base + offset);\r\n}\r\nstatic int msm_gpio_to_irq(struct gpio_chip *chip, unsigned offset)\r\n{\r\nreturn MSM_GPIO_TO_INT(chip->base + offset);\r\n}\r\nstatic inline int msm_irq_to_gpio(struct gpio_chip *chip, unsigned irq)\r\n{\r\nreturn irq - MSM_GPIO_TO_INT(chip->base);\r\n}\r\nstatic void msm_gpio_update_dual_edge_pos(unsigned gpio)\r\n{\r\nint loop_limit = 100;\r\nunsigned val, val2, intstat;\r\ndo {\r\nval = readl(GPIO_IN_OUT(gpio)) & BIT(GPIO_IN);\r\nif (val)\r\nclear_gpio_bits(BIT(INTR_POL_CTL), GPIO_INTR_CFG(gpio));\r\nelse\r\nset_gpio_bits(BIT(INTR_POL_CTL), GPIO_INTR_CFG(gpio));\r\nval2 = readl(GPIO_IN_OUT(gpio)) & BIT(GPIO_IN);\r\nintstat = readl(GPIO_INTR_STATUS(gpio)) & BIT(INTR_STATUS);\r\nif (intstat || val == val2)\r\nreturn;\r\n} while (loop_limit-- > 0);\r\npr_err("dual-edge irq failed to stabilize, "\r\n"interrupts dropped. %#08x != %#08x\n",\r\nval, val2);\r\n}\r\nstatic void msm_gpio_irq_ack(struct irq_data *d)\r\n{\r\nint gpio = msm_irq_to_gpio(&msm_gpio.gpio_chip, d->irq);\r\nwritel(BIT(INTR_STATUS), GPIO_INTR_STATUS(gpio));\r\nif (test_bit(gpio, msm_gpio.dual_edge_irqs))\r\nmsm_gpio_update_dual_edge_pos(gpio);\r\n}\r\nstatic void msm_gpio_irq_mask(struct irq_data *d)\r\n{\r\nint gpio = msm_irq_to_gpio(&msm_gpio.gpio_chip, d->irq);\r\nunsigned long irq_flags;\r\nspin_lock_irqsave(&tlmm_lock, irq_flags);\r\nwritel(TARGET_PROC_NONE, GPIO_INTR_CFG_SU(gpio));\r\nclear_gpio_bits(INTR_RAW_STATUS_EN | INTR_ENABLE, GPIO_INTR_CFG(gpio));\r\n__clear_bit(gpio, msm_gpio.enabled_irqs);\r\nspin_unlock_irqrestore(&tlmm_lock, irq_flags);\r\n}\r\nstatic void msm_gpio_irq_unmask(struct irq_data *d)\r\n{\r\nint gpio = msm_irq_to_gpio(&msm_gpio.gpio_chip, d->irq);\r\nunsigned long irq_flags;\r\nspin_lock_irqsave(&tlmm_lock, irq_flags);\r\n__set_bit(gpio, msm_gpio.enabled_irqs);\r\nset_gpio_bits(INTR_RAW_STATUS_EN | INTR_ENABLE, GPIO_INTR_CFG(gpio));\r\nwritel(TARGET_PROC_SCORPION, GPIO_INTR_CFG_SU(gpio));\r\nspin_unlock_irqrestore(&tlmm_lock, irq_flags);\r\n}\r\nstatic int msm_gpio_irq_set_type(struct irq_data *d, unsigned int flow_type)\r\n{\r\nint gpio = msm_irq_to_gpio(&msm_gpio.gpio_chip, d->irq);\r\nunsigned long irq_flags;\r\nuint32_t bits;\r\nspin_lock_irqsave(&tlmm_lock, irq_flags);\r\nbits = readl(GPIO_INTR_CFG(gpio));\r\nif (flow_type & IRQ_TYPE_EDGE_BOTH) {\r\nbits |= BIT(INTR_DECT_CTL);\r\n__irq_set_handler_locked(d->irq, handle_edge_irq);\r\nif ((flow_type & IRQ_TYPE_EDGE_BOTH) == IRQ_TYPE_EDGE_BOTH)\r\n__set_bit(gpio, msm_gpio.dual_edge_irqs);\r\nelse\r\n__clear_bit(gpio, msm_gpio.dual_edge_irqs);\r\n} else {\r\nbits &= ~BIT(INTR_DECT_CTL);\r\n__irq_set_handler_locked(d->irq, handle_level_irq);\r\n__clear_bit(gpio, msm_gpio.dual_edge_irqs);\r\n}\r\nif (flow_type & (IRQ_TYPE_EDGE_RISING | IRQ_TYPE_LEVEL_HIGH))\r\nbits |= BIT(INTR_POL_CTL);\r\nelse\r\nbits &= ~BIT(INTR_POL_CTL);\r\nwritel(bits, GPIO_INTR_CFG(gpio));\r\nif ((flow_type & IRQ_TYPE_EDGE_BOTH) == IRQ_TYPE_EDGE_BOTH)\r\nmsm_gpio_update_dual_edge_pos(gpio);\r\nspin_unlock_irqrestore(&tlmm_lock, irq_flags);\r\nreturn 0;\r\n}\r\nstatic void msm_summary_irq_handler(unsigned int irq, struct irq_desc *desc)\r\n{\r\nunsigned long i;\r\nstruct irq_chip *chip = irq_desc_get_chip(desc);\r\nchained_irq_enter(chip, desc);\r\nfor_each_set_bit(i, msm_gpio.enabled_irqs, NR_GPIO_IRQS) {\r\nif (readl(GPIO_INTR_STATUS(i)) & BIT(INTR_STATUS))\r\ngeneric_handle_irq(msm_gpio_to_irq(&msm_gpio.gpio_chip,\r\ni));\r\n}\r\nchained_irq_exit(chip, desc);\r\n}\r\nstatic int msm_gpio_irq_set_wake(struct irq_data *d, unsigned int on)\r\n{\r\nint gpio = msm_irq_to_gpio(&msm_gpio.gpio_chip, d->irq);\r\nif (on) {\r\nif (bitmap_empty(msm_gpio.wake_irqs, NR_GPIO_IRQS))\r\nirq_set_irq_wake(TLMM_SCSS_SUMMARY_IRQ, 1);\r\nset_bit(gpio, msm_gpio.wake_irqs);\r\n} else {\r\nclear_bit(gpio, msm_gpio.wake_irqs);\r\nif (bitmap_empty(msm_gpio.wake_irqs, NR_GPIO_IRQS))\r\nirq_set_irq_wake(TLMM_SCSS_SUMMARY_IRQ, 0);\r\n}\r\nreturn 0;\r\n}\r\nstatic int msm_gpio_probe(struct platform_device *dev)\r\n{\r\nint i, irq, ret;\r\nbitmap_zero(msm_gpio.enabled_irqs, NR_GPIO_IRQS);\r\nbitmap_zero(msm_gpio.wake_irqs, NR_GPIO_IRQS);\r\nbitmap_zero(msm_gpio.dual_edge_irqs, NR_GPIO_IRQS);\r\nmsm_gpio.gpio_chip.label = dev->name;\r\nret = gpiochip_add(&msm_gpio.gpio_chip);\r\nif (ret < 0)\r\nreturn ret;\r\nfor (i = 0; i < msm_gpio.gpio_chip.ngpio; ++i) {\r\nirq = msm_gpio_to_irq(&msm_gpio.gpio_chip, i);\r\nirq_set_chip_and_handler(irq, &msm_gpio_irq_chip,\r\nhandle_level_irq);\r\nset_irq_flags(irq, IRQF_VALID);\r\n}\r\nirq_set_chained_handler(TLMM_SCSS_SUMMARY_IRQ,\r\nmsm_summary_irq_handler);\r\nreturn 0;\r\n}\r\nstatic int msm_gpio_remove(struct platform_device *dev)\r\n{\r\nint ret = gpiochip_remove(&msm_gpio.gpio_chip);\r\nif (ret < 0)\r\nreturn ret;\r\nirq_set_handler(TLMM_SCSS_SUMMARY_IRQ, NULL);\r\nreturn 0;\r\n}\r\nstatic int __init msm_gpio_init(void)\r\n{\r\nint rc;\r\nrc = platform_driver_register(&msm_gpio_driver);\r\nif (!rc) {\r\nrc = platform_device_register(&msm_device_gpio);\r\nif (rc)\r\nplatform_driver_unregister(&msm_gpio_driver);\r\n}\r\nreturn rc;\r\n}\r\nstatic void __exit msm_gpio_exit(void)\r\n{\r\nplatform_device_unregister(&msm_device_gpio);\r\nplatform_driver_unregister(&msm_gpio_driver);\r\n}
