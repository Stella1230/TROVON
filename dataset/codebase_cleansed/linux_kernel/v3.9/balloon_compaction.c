struct balloon_dev_info *balloon_devinfo_alloc(void *balloon_dev_descriptor)\r\n{\r\nstruct balloon_dev_info *b_dev_info;\r\nb_dev_info = kmalloc(sizeof(*b_dev_info), GFP_KERNEL);\r\nif (!b_dev_info)\r\nreturn ERR_PTR(-ENOMEM);\r\nb_dev_info->balloon_device = balloon_dev_descriptor;\r\nb_dev_info->mapping = NULL;\r\nb_dev_info->isolated_pages = 0;\r\nspin_lock_init(&b_dev_info->pages_lock);\r\nINIT_LIST_HEAD(&b_dev_info->pages);\r\nreturn b_dev_info;\r\n}\r\nstruct page *balloon_page_enqueue(struct balloon_dev_info *b_dev_info)\r\n{\r\nunsigned long flags;\r\nstruct page *page = alloc_page(balloon_mapping_gfp_mask() |\r\n__GFP_NOMEMALLOC | __GFP_NORETRY);\r\nif (!page)\r\nreturn NULL;\r\nBUG_ON(!trylock_page(page));\r\nspin_lock_irqsave(&b_dev_info->pages_lock, flags);\r\nballoon_page_insert(page, b_dev_info->mapping, &b_dev_info->pages);\r\nspin_unlock_irqrestore(&b_dev_info->pages_lock, flags);\r\nunlock_page(page);\r\nreturn page;\r\n}\r\nstruct page *balloon_page_dequeue(struct balloon_dev_info *b_dev_info)\r\n{\r\nstruct page *page, *tmp;\r\nunsigned long flags;\r\nbool dequeued_page;\r\ndequeued_page = false;\r\nlist_for_each_entry_safe(page, tmp, &b_dev_info->pages, lru) {\r\nif (trylock_page(page)) {\r\nspin_lock_irqsave(&b_dev_info->pages_lock, flags);\r\nget_page(page);\r\nballoon_page_delete(page);\r\nspin_unlock_irqrestore(&b_dev_info->pages_lock, flags);\r\nunlock_page(page);\r\ndequeued_page = true;\r\nbreak;\r\n}\r\n}\r\nif (!dequeued_page) {\r\nspin_lock_irqsave(&b_dev_info->pages_lock, flags);\r\nif (unlikely(list_empty(&b_dev_info->pages) &&\r\n!b_dev_info->isolated_pages))\r\nBUG();\r\nspin_unlock_irqrestore(&b_dev_info->pages_lock, flags);\r\npage = NULL;\r\n}\r\nreturn page;\r\n}\r\nstruct address_space *balloon_mapping_alloc(struct balloon_dev_info *b_dev_info,\r\nconst struct address_space_operations *a_ops)\r\n{\r\nstruct address_space *mapping;\r\nmapping = kmalloc(sizeof(*mapping), GFP_KERNEL);\r\nif (!mapping)\r\nreturn ERR_PTR(-ENOMEM);\r\naddress_space_init_once(mapping);\r\nmapping_set_balloon(mapping);\r\nmapping_set_gfp_mask(mapping, balloon_mapping_gfp_mask());\r\nmapping->a_ops = a_ops;\r\nmapping->private_data = b_dev_info;\r\nb_dev_info->mapping = mapping;\r\nreturn mapping;\r\n}\r\nstatic inline void __isolate_balloon_page(struct page *page)\r\n{\r\nstruct balloon_dev_info *b_dev_info = page->mapping->private_data;\r\nunsigned long flags;\r\nspin_lock_irqsave(&b_dev_info->pages_lock, flags);\r\nlist_del(&page->lru);\r\nb_dev_info->isolated_pages++;\r\nspin_unlock_irqrestore(&b_dev_info->pages_lock, flags);\r\n}\r\nstatic inline void __putback_balloon_page(struct page *page)\r\n{\r\nstruct balloon_dev_info *b_dev_info = page->mapping->private_data;\r\nunsigned long flags;\r\nspin_lock_irqsave(&b_dev_info->pages_lock, flags);\r\nlist_add(&page->lru, &b_dev_info->pages);\r\nb_dev_info->isolated_pages--;\r\nspin_unlock_irqrestore(&b_dev_info->pages_lock, flags);\r\n}\r\nstatic inline int __migrate_balloon_page(struct address_space *mapping,\r\nstruct page *newpage, struct page *page, enum migrate_mode mode)\r\n{\r\nreturn page->mapping->a_ops->migratepage(mapping, newpage, page, mode);\r\n}\r\nbool balloon_page_isolate(struct page *page)\r\n{\r\nif (likely(get_page_unless_zero(page))) {\r\nif (likely(trylock_page(page))) {\r\nif (__is_movable_balloon_page(page) &&\r\npage_count(page) == 2) {\r\n__isolate_balloon_page(page);\r\nunlock_page(page);\r\nreturn true;\r\n}\r\nunlock_page(page);\r\n}\r\nput_page(page);\r\n}\r\nreturn false;\r\n}\r\nvoid balloon_page_putback(struct page *page)\r\n{\r\nlock_page(page);\r\nif (__is_movable_balloon_page(page)) {\r\n__putback_balloon_page(page);\r\nput_page(page);\r\n} else {\r\nWARN_ON(1);\r\ndump_page(page);\r\n}\r\nunlock_page(page);\r\n}\r\nint balloon_page_migrate(struct page *newpage,\r\nstruct page *page, enum migrate_mode mode)\r\n{\r\nstruct address_space *mapping;\r\nint rc = -EAGAIN;\r\nBUG_ON(!trylock_page(newpage));\r\nif (WARN_ON(!__is_movable_balloon_page(page))) {\r\ndump_page(page);\r\nunlock_page(newpage);\r\nreturn rc;\r\n}\r\nmapping = page->mapping;\r\nif (mapping)\r\nrc = __migrate_balloon_page(mapping, newpage, page, mode);\r\nunlock_page(newpage);\r\nreturn rc;\r\n}
