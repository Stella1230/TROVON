static inline void s6_i2s_write_reg(struct s6000_i2s_dev *dev, int reg, u32 val)\r\n{\r\nwritel(val, dev->scbbase + reg);\r\n}\r\nstatic inline u32 s6_i2s_read_reg(struct s6000_i2s_dev *dev, int reg)\r\n{\r\nreturn readl(dev->scbbase + reg);\r\n}\r\nstatic inline void s6_i2s_mod_reg(struct s6000_i2s_dev *dev, int reg,\r\nu32 mask, u32 val)\r\n{\r\nval ^= s6_i2s_read_reg(dev, reg) & ~mask;\r\ns6_i2s_write_reg(dev, reg, val);\r\n}\r\nstatic void s6000_i2s_start_channel(struct s6000_i2s_dev *dev, int channel)\r\n{\r\nint i, j, cur, prev;\r\nj = 0;\r\nprev = ~S6_I2S_CUR_WS;\r\nfor (i = 1000000; --i && j < 6; ) {\r\ncur = s6_i2s_read_reg(dev, S6_I2S_INTERFACE_CFG(channel))\r\n& S6_I2S_CUR_WS;\r\nif (prev != cur) {\r\nprev = cur;\r\nj++;\r\n}\r\n}\r\nif (j < 6)\r\nprintk(KERN_WARNING "s6000-i2s: timeout waiting for WCLK\n");\r\ns6_i2s_write_reg(dev, S6_I2S_ENABLE(channel), S6_I2S_ENABLE_IF);\r\n}\r\nstatic void s6000_i2s_stop_channel(struct s6000_i2s_dev *dev, int channel)\r\n{\r\ns6_i2s_write_reg(dev, S6_I2S_ENABLE(channel), S6_I2S_DISABLE_IF);\r\n}\r\nstatic void s6000_i2s_start(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\nstruct s6000_i2s_dev *dev = snd_soc_dai_get_drvdata(rtd->cpu_dai);\r\nint channel;\r\nchannel = (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) ?\r\ndev->channel_out : dev->channel_in;\r\ns6000_i2s_start_channel(dev, channel);\r\n}\r\nstatic void s6000_i2s_stop(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\nstruct s6000_i2s_dev *dev = snd_soc_dai_get_drvdata(rtd->cpu_dai);\r\nint channel;\r\nchannel = (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) ?\r\ndev->channel_out : dev->channel_in;\r\ns6000_i2s_stop_channel(dev, channel);\r\n}\r\nstatic int s6000_i2s_trigger(struct snd_pcm_substream *substream, int cmd,\r\nint after)\r\n{\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\ncase SNDRV_PCM_TRIGGER_RESUME:\r\ncase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\r\nif ((substream->stream == SNDRV_PCM_STREAM_CAPTURE) ^ !after)\r\ns6000_i2s_start(substream);\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\ncase SNDRV_PCM_TRIGGER_SUSPEND:\r\ncase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\r\nif (!after)\r\ns6000_i2s_stop(substream);\r\n}\r\nreturn 0;\r\n}\r\nstatic unsigned int s6000_i2s_int_sources(struct s6000_i2s_dev *dev)\r\n{\r\nunsigned int pending;\r\npending = s6_i2s_read_reg(dev, S6_I2S_INTERRUPT_RAW);\r\npending &= S6_I2S_INT_ALIGNMENT |\r\nS6_I2S_INT_UNDERRUN |\r\nS6_I2S_INT_OVERRUN;\r\ns6_i2s_write_reg(dev, S6_I2S_INTERRUPT_CLEAR, pending);\r\nreturn pending;\r\n}\r\nstatic unsigned int s6000_i2s_check_xrun(struct snd_soc_dai *cpu_dai)\r\n{\r\nstruct s6000_i2s_dev *dev = snd_soc_dai_get_drvdata(cpu_dai);\r\nunsigned int errors;\r\nunsigned int ret;\r\nerrors = s6000_i2s_int_sources(dev);\r\nif (likely(!errors))\r\nreturn 0;\r\nret = 0;\r\nif (errors & S6_I2S_INT_ALIGNMENT)\r\nprintk(KERN_ERR "s6000-i2s: WCLK misaligned\n");\r\nif (errors & S6_I2S_INT_UNDERRUN)\r\nret |= 1 << SNDRV_PCM_STREAM_PLAYBACK;\r\nif (errors & S6_I2S_INT_OVERRUN)\r\nret |= 1 << SNDRV_PCM_STREAM_CAPTURE;\r\nreturn ret;\r\n}\r\nstatic void s6000_i2s_wait_disabled(struct s6000_i2s_dev *dev)\r\n{\r\nint channel;\r\nint n = 50;\r\nfor (channel = 0; channel < 2; channel++) {\r\nwhile (--n >= 0) {\r\nint v = s6_i2s_read_reg(dev, S6_I2S_ENABLE(channel));\r\nif ((v & S6_I2S_IS_ENABLED)\r\n|| !(v & (S6_I2S_DMA_ACTIVE | S6_I2S_IS_BUSY)))\r\nbreak;\r\nudelay(20);\r\n}\r\n}\r\nif (n < 0)\r\nprintk(KERN_WARNING "s6000-i2s: timeout disabling interfaces");\r\n}\r\nstatic int s6000_i2s_set_dai_fmt(struct snd_soc_dai *cpu_dai,\r\nunsigned int fmt)\r\n{\r\nstruct s6000_i2s_dev *dev = snd_soc_dai_get_drvdata(cpu_dai);\r\nu32 w;\r\nswitch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {\r\ncase SND_SOC_DAIFMT_CBM_CFM:\r\nw = S6_I2S_SCK_IN | S6_I2S_WS_IN;\r\nbreak;\r\ncase SND_SOC_DAIFMT_CBS_CFM:\r\nw = S6_I2S_SCK_OUT | S6_I2S_WS_IN;\r\nbreak;\r\ncase SND_SOC_DAIFMT_CBM_CFS:\r\nw = S6_I2S_SCK_IN | S6_I2S_WS_OUT;\r\nbreak;\r\ncase SND_SOC_DAIFMT_CBS_CFS:\r\nw = S6_I2S_SCK_OUT | S6_I2S_WS_OUT;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\r\ncase SND_SOC_DAIFMT_NB_NF:\r\nw |= S6_I2S_LEFT_FIRST;\r\nbreak;\r\ncase SND_SOC_DAIFMT_NB_IF:\r\nw |= S6_I2S_RIGHT_FIRST;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\ns6_i2s_mod_reg(dev, S6_I2S_INTERFACE_CFG(0),\r\nS6_I2S_FIRST | S6_I2S_WS_DIR | S6_I2S_SCK_DIR, w);\r\ns6_i2s_mod_reg(dev, S6_I2S_INTERFACE_CFG(1),\r\nS6_I2S_FIRST | S6_I2S_WS_DIR | S6_I2S_SCK_DIR, w);\r\nreturn 0;\r\n}\r\nstatic int s6000_i2s_set_clkdiv(struct snd_soc_dai *dai, int div_id, int div)\r\n{\r\nstruct s6000_i2s_dev *dev = snd_soc_dai_get_drvdata(dai);\r\nif (!div || (div & 1) || div > (S6_I2S_DIV_MASK + 1) * 2)\r\nreturn -EINVAL;\r\ns6_i2s_mod_reg(dev, S6_I2S_INTERFACE_CFG(div_id),\r\nS6_I2S_DIV_MASK, div / 2 - 1);\r\nreturn 0;\r\n}\r\nstatic int s6000_i2s_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct s6000_i2s_dev *dev = snd_soc_dai_get_drvdata(dai);\r\nint interf;\r\nu32 w = 0;\r\nif (dev->wide)\r\ninterf = 0;\r\nelse {\r\nw |= (((params_channels(params) - 2) / 2)\r\n<< S6_I2S_CHANNELS_SHIFT) & S6_I2S_CHANNELS_MASK;\r\ninterf = (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\r\n? dev->channel_out : dev->channel_in;\r\n}\r\nswitch (params_format(params)) {\r\ncase SNDRV_PCM_FORMAT_S16_LE:\r\nw |= S6_I2S_16BIT | S6_I2S_MEM_16BIT;\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S32_LE:\r\nw |= S6_I2S_32BIT | S6_I2S_MEM_32BIT;\r\nbreak;\r\ndefault:\r\nprintk(KERN_WARNING "s6000-i2s: unsupported PCM format %x\n",\r\nparams_format(params));\r\nreturn -EINVAL;\r\n}\r\nif (s6_i2s_read_reg(dev, S6_I2S_INTERFACE_CFG(interf))\r\n& S6_I2S_IS_ENABLED) {\r\nprintk(KERN_ERR "s6000-i2s: interface already enabled\n");\r\nreturn -EBUSY;\r\n}\r\ns6_i2s_mod_reg(dev, S6_I2S_INTERFACE_CFG(interf),\r\nS6_I2S_CHANNELS_MASK|S6_I2S_MEM_MASK|S6_I2S_BITS_MASK,\r\nw);\r\nreturn 0;\r\n}\r\nstatic int s6000_i2s_dai_probe(struct snd_soc_dai *dai)\r\n{\r\nstruct s6000_i2s_dev *dev = snd_soc_dai_get_drvdata(dai);\r\nstruct s6000_snd_platform_data *pdata = dai->dev->platform_data;\r\nif (!pdata)\r\nreturn -EINVAL;\r\ndai->capture_dma_data = &dev->dma_params;\r\ndai->playback_dma_data = &dev->dma_params;\r\ndev->wide = pdata->wide;\r\ndev->channel_in = pdata->channel_in;\r\ndev->channel_out = pdata->channel_out;\r\ndev->lines_in = pdata->lines_in;\r\ndev->lines_out = pdata->lines_out;\r\ns6_i2s_write_reg(dev, S6_I2S_MODE,\r\ndev->wide ? S6_I2S_WIDE : S6_I2S_DUAL);\r\nif (dev->wide) {\r\nint i;\r\nif (dev->lines_in + dev->lines_out > S6_I2S_NUM_LINES)\r\nreturn -EINVAL;\r\ndev->channel_in = 0;\r\ndev->channel_out = 1;\r\ndai->driver->capture.channels_min = 2 * dev->lines_in;\r\ndai->driver->capture.channels_max = dai->driver->capture.channels_min;\r\ndai->driver->playback.channels_min = 2 * dev->lines_out;\r\ndai->driver->playback.channels_max = dai->driver->playback.channels_min;\r\nfor (i = 0; i < dev->lines_out; i++)\r\ns6_i2s_write_reg(dev, S6_I2S_DATA_CFG(i), S6_I2S_OUT);\r\nfor (; i < S6_I2S_NUM_LINES - dev->lines_in; i++)\r\ns6_i2s_write_reg(dev, S6_I2S_DATA_CFG(i),\r\nS6_I2S_UNUSED);\r\nfor (; i < S6_I2S_NUM_LINES; i++)\r\ns6_i2s_write_reg(dev, S6_I2S_DATA_CFG(i), S6_I2S_IN);\r\n} else {\r\nunsigned int cfg[2] = {S6_I2S_UNUSED, S6_I2S_UNUSED};\r\nif (dev->lines_in > 1 || dev->lines_out > 1)\r\nreturn -EINVAL;\r\ndai->driver->capture.channels_min = 2 * dev->lines_in;\r\ndai->driver->capture.channels_max = 8 * dev->lines_in;\r\ndai->driver->playback.channels_min = 2 * dev->lines_out;\r\ndai->driver->playback.channels_max = 8 * dev->lines_out;\r\nif (dev->lines_in)\r\ncfg[dev->channel_in] = S6_I2S_IN;\r\nif (dev->lines_out)\r\ncfg[dev->channel_out] = S6_I2S_OUT;\r\ns6_i2s_write_reg(dev, S6_I2S_DATA_CFG(0), cfg[0]);\r\ns6_i2s_write_reg(dev, S6_I2S_DATA_CFG(1), cfg[1]);\r\n}\r\nif (dev->lines_out) {\r\nif (dev->lines_in) {\r\nif (!dev->dma_params.dma_out)\r\nreturn -ENODEV;\r\n} else {\r\ndev->dma_params.dma_out = dev->dma_params.dma_in;\r\ndev->dma_params.dma_in = 0;\r\n}\r\n}\r\ndev->dma_params.sif_in = dev->sifbase + (dev->channel_in ?\r\nS6_I2S_SIF_PORT1 : S6_I2S_SIF_PORT0);\r\ndev->dma_params.sif_out = dev->sifbase + (dev->channel_out ?\r\nS6_I2S_SIF_PORT1 : S6_I2S_SIF_PORT0);\r\ndev->dma_params.same_rate = pdata->same_rate | pdata->wide;\r\nreturn 0;\r\n}\r\nstatic int s6000_i2s_probe(struct platform_device *pdev)\r\n{\r\nstruct s6000_i2s_dev *dev;\r\nstruct resource *scbmem, *sifmem, *region, *dma1, *dma2;\r\nu8 __iomem *mmio;\r\nint ret;\r\nscbmem = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!scbmem) {\r\ndev_err(&pdev->dev, "no mem resource?\n");\r\nret = -ENODEV;\r\ngoto err_release_none;\r\n}\r\nregion = request_mem_region(scbmem->start, resource_size(scbmem),\r\npdev->name);\r\nif (!region) {\r\ndev_err(&pdev->dev, "I2S SCB region already claimed\n");\r\nret = -EBUSY;\r\ngoto err_release_none;\r\n}\r\nmmio = ioremap(scbmem->start, resource_size(scbmem));\r\nif (!mmio) {\r\ndev_err(&pdev->dev, "can't ioremap SCB region\n");\r\nret = -ENOMEM;\r\ngoto err_release_scb;\r\n}\r\nsifmem = platform_get_resource(pdev, IORESOURCE_MEM, 1);\r\nif (!sifmem) {\r\ndev_err(&pdev->dev, "no second mem resource?\n");\r\nret = -ENODEV;\r\ngoto err_release_map;\r\n}\r\nregion = request_mem_region(sifmem->start, resource_size(sifmem),\r\npdev->name);\r\nif (!region) {\r\ndev_err(&pdev->dev, "I2S SIF region already claimed\n");\r\nret = -EBUSY;\r\ngoto err_release_map;\r\n}\r\ndma1 = platform_get_resource(pdev, IORESOURCE_DMA, 0);\r\nif (!dma1) {\r\ndev_err(&pdev->dev, "no dma resource?\n");\r\nret = -ENODEV;\r\ngoto err_release_sif;\r\n}\r\nregion = request_mem_region(dma1->start, resource_size(dma1),\r\npdev->name);\r\nif (!region) {\r\ndev_err(&pdev->dev, "I2S DMA region already claimed\n");\r\nret = -EBUSY;\r\ngoto err_release_sif;\r\n}\r\ndma2 = platform_get_resource(pdev, IORESOURCE_DMA, 1);\r\nif (dma2) {\r\nregion = request_mem_region(dma2->start, resource_size(dma2),\r\npdev->name);\r\nif (!region) {\r\ndev_err(&pdev->dev,\r\n"I2S DMA region already claimed\n");\r\nret = -EBUSY;\r\ngoto err_release_dma1;\r\n}\r\n}\r\ndev = kzalloc(sizeof(struct s6000_i2s_dev), GFP_KERNEL);\r\nif (!dev) {\r\nret = -ENOMEM;\r\ngoto err_release_dma2;\r\n}\r\ndev_set_drvdata(&pdev->dev, dev);\r\ndev->sifbase = sifmem->start;\r\ndev->scbbase = mmio;\r\ns6_i2s_write_reg(dev, S6_I2S_INTERRUPT_ENABLE, 0);\r\ns6_i2s_write_reg(dev, S6_I2S_INTERRUPT_CLEAR,\r\nS6_I2S_INT_ALIGNMENT |\r\nS6_I2S_INT_UNDERRUN |\r\nS6_I2S_INT_OVERRUN);\r\ns6000_i2s_stop_channel(dev, 0);\r\ns6000_i2s_stop_channel(dev, 1);\r\ns6000_i2s_wait_disabled(dev);\r\ndev->dma_params.check_xrun = s6000_i2s_check_xrun;\r\ndev->dma_params.trigger = s6000_i2s_trigger;\r\ndev->dma_params.dma_in = dma1->start;\r\ndev->dma_params.dma_out = dma2 ? dma2->start : 0;\r\ndev->dma_params.irq = platform_get_irq(pdev, 0);\r\nif (dev->dma_params.irq < 0) {\r\ndev_err(&pdev->dev, "no irq resource?\n");\r\nret = -ENODEV;\r\ngoto err_release_dev;\r\n}\r\ns6_i2s_write_reg(dev, S6_I2S_INTERRUPT_ENABLE,\r\nS6_I2S_INT_ALIGNMENT |\r\nS6_I2S_INT_UNDERRUN |\r\nS6_I2S_INT_OVERRUN);\r\nret = snd_soc_register_dai(&pdev->dev, &s6000_i2s_dai);\r\nif (ret)\r\ngoto err_release_dev;\r\nreturn 0;\r\nerr_release_dev:\r\nkfree(dev);\r\nerr_release_dma2:\r\nif (dma2)\r\nrelease_mem_region(dma2->start, resource_size(dma2));\r\nerr_release_dma1:\r\nrelease_mem_region(dma1->start, resource_size(dma1));\r\nerr_release_sif:\r\nrelease_mem_region(sifmem->start, resource_size(sifmem));\r\nerr_release_map:\r\niounmap(mmio);\r\nerr_release_scb:\r\nrelease_mem_region(scbmem->start, resource_size(scbmem));\r\nerr_release_none:\r\nreturn ret;\r\n}\r\nstatic void s6000_i2s_remove(struct platform_device *pdev)\r\n{\r\nstruct s6000_i2s_dev *dev = dev_get_drvdata(&pdev->dev);\r\nstruct resource *region;\r\nvoid __iomem *mmio = dev->scbbase;\r\nsnd_soc_unregister_dai(&pdev->dev);\r\ns6000_i2s_stop_channel(dev, 0);\r\ns6000_i2s_stop_channel(dev, 1);\r\ns6_i2s_write_reg(dev, S6_I2S_INTERRUPT_ENABLE, 0);\r\nkfree(dev);\r\nregion = platform_get_resource(pdev, IORESOURCE_DMA, 0);\r\nrelease_mem_region(region->start, resource_size(region));\r\nregion = platform_get_resource(pdev, IORESOURCE_DMA, 1);\r\nif (region)\r\nrelease_mem_region(region->start, resource_size(region));\r\nregion = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nrelease_mem_region(region->start, resource_size(region));\r\niounmap(mmio);\r\nregion = platform_get_resource(pdev, IORESOURCE_IO, 0);\r\nrelease_mem_region(region->start, resource_size(region));\r\n}
