static struct bfin_sd_host *get_sdh_data(struct platform_device *pdev)\r\n{\r\nreturn pdev->dev.platform_data;\r\n}\r\nstatic void sdh_stop_clock(struct sdh_host *host)\r\n{\r\nbfin_write_SDH_CLK_CTL(bfin_read_SDH_CLK_CTL() & ~CLK_E);\r\nSSYNC();\r\n}\r\nstatic void sdh_enable_stat_irq(struct sdh_host *host, unsigned int mask)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&host->lock, flags);\r\nhost->imask |= mask;\r\nbfin_write_SDH_MASK0(mask);\r\nSSYNC();\r\nspin_unlock_irqrestore(&host->lock, flags);\r\n}\r\nstatic void sdh_disable_stat_irq(struct sdh_host *host, unsigned int mask)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&host->lock, flags);\r\nhost->imask &= ~mask;\r\nbfin_write_SDH_MASK0(host->imask);\r\nSSYNC();\r\nspin_unlock_irqrestore(&host->lock, flags);\r\n}\r\nstatic int sdh_setup_data(struct sdh_host *host, struct mmc_data *data)\r\n{\r\nunsigned int length;\r\nunsigned int data_ctl;\r\nunsigned int dma_cfg;\r\nunsigned int cycle_ns, timeout;\r\ndev_dbg(mmc_dev(host->mmc), "%s enter flags: 0x%x\n", __func__, data->flags);\r\nhost->data = data;\r\ndata_ctl = 0;\r\ndma_cfg = 0;\r\nlength = data->blksz * data->blocks;\r\nbfin_write_SDH_DATA_LGTH(length);\r\nif (data->flags & MMC_DATA_STREAM)\r\ndata_ctl |= DTX_MODE;\r\nif (data->flags & MMC_DATA_READ)\r\ndata_ctl |= DTX_DIR;\r\nif (data->blksz & (data->blksz - 1))\r\nreturn -EINVAL;\r\n#ifndef RSI_BLKSZ\r\ndata_ctl |= ((ffs(data->blksz) - 1) << 4);\r\n#else\r\nbfin_write_SDH_BLK_SIZE(data->blksz);\r\n#endif\r\nbfin_write_SDH_DATA_CTL(data_ctl);\r\ncycle_ns = 1000000000 / (host->sclk / (2 * (host->clk_div + 1)));\r\ntimeout = data->timeout_ns / cycle_ns;\r\ntimeout += data->timeout_clks;\r\nbfin_write_SDH_DATA_TIMER(timeout);\r\nSSYNC();\r\nif (data->flags & MMC_DATA_READ) {\r\nhost->dma_dir = DMA_FROM_DEVICE;\r\ndma_cfg |= WNR;\r\n} else\r\nhost->dma_dir = DMA_TO_DEVICE;\r\nsdh_enable_stat_irq(host, (DAT_CRC_FAIL | DAT_TIME_OUT | DAT_END));\r\nhost->dma_len = dma_map_sg(mmc_dev(host->mmc), data->sg, data->sg_len, host->dma_dir);\r\n#if defined(CONFIG_BF54x) || defined(CONFIG_BF60x)\r\ndma_cfg |= DMAFLOW_ARRAY | RESTART | WDSIZE_32 | DMAEN;\r\n# ifdef RSI_BLKSZ\r\ndma_cfg |= PSIZE_32 | NDSIZE_3;\r\n# else\r\ndma_cfg |= NDSIZE_5;\r\n# endif\r\n{\r\nstruct scatterlist *sg;\r\nint i;\r\nfor_each_sg(data->sg, sg, host->dma_len, i) {\r\nhost->sg_cpu[i].start_addr = sg_dma_address(sg);\r\nhost->sg_cpu[i].cfg = dma_cfg;\r\nhost->sg_cpu[i].x_count = sg_dma_len(sg) / 4;\r\nhost->sg_cpu[i].x_modify = 4;\r\ndev_dbg(mmc_dev(host->mmc), "%d: start_addr:0x%lx, "\r\n"cfg:0x%lx, x_count:0x%lx, x_modify:0x%lx\n",\r\ni, host->sg_cpu[i].start_addr,\r\nhost->sg_cpu[i].cfg, host->sg_cpu[i].x_count,\r\nhost->sg_cpu[i].x_modify);\r\n}\r\n}\r\nflush_dcache_range((unsigned int)host->sg_cpu,\r\n(unsigned int)host->sg_cpu +\r\nhost->dma_len * sizeof(struct dma_desc_array));\r\nhost->sg_cpu[host->dma_len - 1].cfg &= ~(DMAFLOW | NDSIZE);\r\nhost->sg_cpu[host->dma_len - 1].cfg |= DI_EN;\r\nset_dma_curr_desc_addr(host->dma_ch, (unsigned long *)host->sg_dma);\r\nset_dma_x_count(host->dma_ch, 0);\r\nset_dma_x_modify(host->dma_ch, 0);\r\nSSYNC();\r\nset_dma_config(host->dma_ch, dma_cfg);\r\n#elif defined(CONFIG_BF51x)\r\ndma_cfg |= WDSIZE_32 | DMAEN;\r\nset_dma_start_addr(host->dma_ch, sg_dma_address(&data->sg[0]));\r\nset_dma_x_count(host->dma_ch, length / 4);\r\nset_dma_x_modify(host->dma_ch, 4);\r\nSSYNC();\r\nset_dma_config(host->dma_ch, dma_cfg);\r\n#endif\r\nbfin_write_SDH_DATA_CTL(bfin_read_SDH_DATA_CTL() | DTX_DMA_E | DTX_E);\r\nSSYNC();\r\ndev_dbg(mmc_dev(host->mmc), "%s exit\n", __func__);\r\nreturn 0;\r\n}\r\nstatic void sdh_start_cmd(struct sdh_host *host, struct mmc_command *cmd)\r\n{\r\nunsigned int sdh_cmd;\r\nunsigned int stat_mask;\r\ndev_dbg(mmc_dev(host->mmc), "%s enter cmd: 0x%p\n", __func__, cmd);\r\nWARN_ON(host->cmd != NULL);\r\nhost->cmd = cmd;\r\nsdh_cmd = 0;\r\nstat_mask = 0;\r\nsdh_cmd |= cmd->opcode;\r\nif (cmd->flags & MMC_RSP_PRESENT) {\r\nsdh_cmd |= CMD_RSP;\r\nstat_mask |= CMD_RESP_END;\r\n} else {\r\nstat_mask |= CMD_SENT;\r\n}\r\nif (cmd->flags & MMC_RSP_136)\r\nsdh_cmd |= CMD_L_RSP;\r\nstat_mask |= CMD_CRC_FAIL | CMD_TIME_OUT;\r\nsdh_enable_stat_irq(host, stat_mask);\r\nbfin_write_SDH_ARGUMENT(cmd->arg);\r\nbfin_write_SDH_COMMAND(sdh_cmd | CMD_E);\r\nbfin_write_SDH_CLK_CTL(bfin_read_SDH_CLK_CTL() | CLK_E);\r\nSSYNC();\r\n}\r\nstatic void sdh_finish_request(struct sdh_host *host, struct mmc_request *mrq)\r\n{\r\ndev_dbg(mmc_dev(host->mmc), "%s enter\n", __func__);\r\nhost->mrq = NULL;\r\nhost->cmd = NULL;\r\nhost->data = NULL;\r\nmmc_request_done(host->mmc, mrq);\r\n}\r\nstatic int sdh_cmd_done(struct sdh_host *host, unsigned int stat)\r\n{\r\nstruct mmc_command *cmd = host->cmd;\r\nint ret = 0;\r\ndev_dbg(mmc_dev(host->mmc), "%s enter cmd: %p\n", __func__, cmd);\r\nif (!cmd)\r\nreturn 0;\r\nhost->cmd = NULL;\r\nif (cmd->flags & MMC_RSP_PRESENT) {\r\ncmd->resp[0] = bfin_read_SDH_RESPONSE0();\r\nif (cmd->flags & MMC_RSP_136) {\r\ncmd->resp[1] = bfin_read_SDH_RESPONSE1();\r\ncmd->resp[2] = bfin_read_SDH_RESPONSE2();\r\ncmd->resp[3] = bfin_read_SDH_RESPONSE3();\r\n}\r\n}\r\nif (stat & CMD_TIME_OUT)\r\ncmd->error = -ETIMEDOUT;\r\nelse if (stat & CMD_CRC_FAIL && cmd->flags & MMC_RSP_CRC)\r\ncmd->error = -EILSEQ;\r\nsdh_disable_stat_irq(host, (CMD_SENT | CMD_RESP_END | CMD_TIME_OUT | CMD_CRC_FAIL));\r\nif (host->data && !cmd->error) {\r\nif (host->data->flags & MMC_DATA_WRITE) {\r\nret = sdh_setup_data(host, host->data);\r\nif (ret)\r\nreturn 0;\r\n}\r\nsdh_enable_stat_irq(host, DAT_END | RX_OVERRUN | TX_UNDERRUN | DAT_TIME_OUT);\r\n} else\r\nsdh_finish_request(host, host->mrq);\r\nreturn 1;\r\n}\r\nstatic int sdh_data_done(struct sdh_host *host, unsigned int stat)\r\n{\r\nstruct mmc_data *data = host->data;\r\ndev_dbg(mmc_dev(host->mmc), "%s enter stat: 0x%x\n", __func__, stat);\r\nif (!data)\r\nreturn 0;\r\ndisable_dma(host->dma_ch);\r\ndma_unmap_sg(mmc_dev(host->mmc), data->sg, data->sg_len,\r\nhost->dma_dir);\r\nif (stat & DAT_TIME_OUT)\r\ndata->error = -ETIMEDOUT;\r\nelse if (stat & DAT_CRC_FAIL)\r\ndata->error = -EILSEQ;\r\nelse if (stat & (RX_OVERRUN | TX_UNDERRUN))\r\ndata->error = -EIO;\r\nif (!data->error)\r\ndata->bytes_xfered = data->blocks * data->blksz;\r\nelse\r\ndata->bytes_xfered = 0;\r\nbfin_write_SDH_STATUS_CLR(DAT_END_STAT | DAT_TIMEOUT_STAT | \\r\nDAT_CRC_FAIL_STAT | DAT_BLK_END_STAT | RX_OVERRUN | TX_UNDERRUN);\r\nbfin_write_SDH_DATA_CTL(0);\r\nSSYNC();\r\nhost->data = NULL;\r\nif (host->mrq->stop) {\r\nsdh_stop_clock(host);\r\nsdh_start_cmd(host, host->mrq->stop);\r\n} else {\r\nsdh_finish_request(host, host->mrq);\r\n}\r\nreturn 1;\r\n}\r\nstatic void sdh_request(struct mmc_host *mmc, struct mmc_request *mrq)\r\n{\r\nstruct sdh_host *host = mmc_priv(mmc);\r\nint ret = 0;\r\ndev_dbg(mmc_dev(host->mmc), "%s enter, mrp:%p, cmd:%p\n", __func__, mrq, mrq->cmd);\r\nWARN_ON(host->mrq != NULL);\r\nspin_lock(&host->lock);\r\nhost->mrq = mrq;\r\nhost->data = mrq->data;\r\nif (mrq->data && mrq->data->flags & MMC_DATA_READ) {\r\nret = sdh_setup_data(host, mrq->data);\r\nif (ret)\r\ngoto data_err;\r\n}\r\nsdh_start_cmd(host, mrq->cmd);\r\ndata_err:\r\nspin_unlock(&host->lock);\r\n}\r\nstatic void sdh_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)\r\n{\r\nstruct sdh_host *host;\r\nu16 clk_ctl = 0;\r\n#ifndef RSI_BLKSZ\r\nu16 pwr_ctl = 0;\r\n#endif\r\nu16 cfg;\r\nhost = mmc_priv(mmc);\r\nspin_lock(&host->lock);\r\ncfg = bfin_read_SDH_CFG();\r\ncfg |= MWE;\r\nswitch (ios->bus_width) {\r\ncase MMC_BUS_WIDTH_4:\r\n#ifndef RSI_BLKSZ\r\ncfg &= ~PD_SDDAT3;\r\n#endif\r\ncfg |= PUP_SDDAT3;\r\ncfg |= SD4E;\r\nclk_ctl |= WIDE_BUS_4;\r\nbreak;\r\ncase MMC_BUS_WIDTH_8:\r\n#ifndef RSI_BLKSZ\r\ncfg &= ~PD_SDDAT3;\r\n#endif\r\ncfg |= PUP_SDDAT3;\r\ncfg &= ~SD4E;\r\nclk_ctl |= BYTE_BUS_8;\r\nbreak;\r\ndefault:\r\ncfg &= ~PUP_SDDAT3;\r\ncfg &= ~SD4E;\r\n}\r\nhost->power_mode = ios->power_mode;\r\n#ifndef RSI_BLKSZ\r\nif (ios->bus_mode == MMC_BUSMODE_OPENDRAIN) {\r\npwr_ctl |= ROD_CTL;\r\n# ifndef CONFIG_SDH_BFIN_MISSING_CMD_PULLUP_WORKAROUND\r\npwr_ctl |= SD_CMD_OD;\r\n# endif\r\n}\r\nif (ios->power_mode != MMC_POWER_OFF)\r\npwr_ctl |= PWR_ON;\r\nelse\r\npwr_ctl &= ~PWR_ON;\r\nbfin_write_SDH_PWR_CTL(pwr_ctl);\r\n#else\r\n# ifndef CONFIG_SDH_BFIN_MISSING_CMD_PULLUP_WORKAROUND\r\nif (ios->bus_mode == MMC_BUSMODE_OPENDRAIN)\r\ncfg |= SD_CMD_OD;\r\nelse\r\ncfg &= ~SD_CMD_OD;\r\n# endif\r\nif (ios->power_mode != MMC_POWER_OFF)\r\ncfg |= PWR_ON;\r\nelse\r\ncfg &= ~PWR_ON;\r\nbfin_write_SDH_CFG(cfg);\r\n#endif\r\nSSYNC();\r\nif (ios->power_mode == MMC_POWER_ON && ios->clock) {\r\nunsigned char clk_div;\r\nclk_div = (get_sclk() / ios->clock - 1) / 2;\r\nclk_div = min_t(unsigned char, clk_div, 0xFF);\r\nclk_ctl |= clk_div;\r\nclk_ctl |= CLK_E;\r\nhost->clk_div = clk_div;\r\nbfin_write_SDH_CLK_CTL(clk_ctl);\r\n} else\r\nsdh_stop_clock(host);\r\nif (ios->power_mode == MMC_POWER_ON)\r\nbfin_write_SDH_MASK0(DAT_END | DAT_TIME_OUT | DAT_CRC_FAIL |\r\nRX_OVERRUN | TX_UNDERRUN | CMD_SENT | CMD_RESP_END |\r\nCMD_TIME_OUT | CMD_CRC_FAIL);\r\nelse\r\nbfin_write_SDH_MASK0(0);\r\nSSYNC();\r\nspin_unlock(&host->lock);\r\ndev_dbg(mmc_dev(host->mmc), "SDH: clk_div = 0x%x actual clock:%ld expected clock:%d\n",\r\nhost->clk_div,\r\nhost->clk_div ? get_sclk() / (2 * (host->clk_div + 1)) : 0,\r\nios->clock);\r\n}\r\nstatic irqreturn_t sdh_dma_irq(int irq, void *devid)\r\n{\r\nstruct sdh_host *host = devid;\r\ndev_dbg(mmc_dev(host->mmc), "%s enter, irq_stat: 0x%04lx\n", __func__,\r\nget_dma_curr_irqstat(host->dma_ch));\r\nclear_dma_irqstat(host->dma_ch);\r\nSSYNC();\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t sdh_stat_irq(int irq, void *devid)\r\n{\r\nstruct sdh_host *host = devid;\r\nunsigned int status;\r\nint handled = 0;\r\ndev_dbg(mmc_dev(host->mmc), "%s enter\n", __func__);\r\nspin_lock(&host->lock);\r\nstatus = bfin_read_SDH_E_STATUS();\r\nif (status & SD_CARD_DET) {\r\nmmc_detect_change(host->mmc, 0);\r\nbfin_write_SDH_E_STATUS(SD_CARD_DET);\r\n}\r\nstatus = bfin_read_SDH_STATUS();\r\nif (status & (CMD_SENT | CMD_RESP_END | CMD_TIME_OUT | CMD_CRC_FAIL)) {\r\nhandled |= sdh_cmd_done(host, status);\r\nbfin_write_SDH_STATUS_CLR(CMD_SENT_STAT | CMD_RESP_END_STAT | \\r\nCMD_TIMEOUT_STAT | CMD_CRC_FAIL_STAT);\r\nSSYNC();\r\n}\r\nstatus = bfin_read_SDH_STATUS();\r\nif (status & (DAT_END | DAT_TIME_OUT | DAT_CRC_FAIL | RX_OVERRUN | TX_UNDERRUN))\r\nhandled |= sdh_data_done(host, status);\r\nspin_unlock(&host->lock);\r\ndev_dbg(mmc_dev(host->mmc), "%s exit\n\n", __func__);\r\nreturn IRQ_RETVAL(handled);\r\n}\r\nstatic void sdh_reset(void)\r\n{\r\n#if defined(CONFIG_BF54x)\r\nbfin_write_DMAC1_PERIMUX(bfin_read_DMAC1_PERIMUX() | 0x1);\r\n#endif\r\nbfin_write_SDH_CFG(bfin_read_SDH_CFG() | CLKS_EN);\r\nSSYNC();\r\nbfin_write_SDH_CFG((bfin_read_SDH_CFG() & 0x1F) | (PUP_SDDAT | PUP_SDDAT3));\r\nSSYNC();\r\n}\r\nstatic int sdh_probe(struct platform_device *pdev)\r\n{\r\nstruct mmc_host *mmc;\r\nstruct sdh_host *host;\r\nstruct bfin_sd_host *drv_data = get_sdh_data(pdev);\r\nint ret;\r\nif (!drv_data) {\r\ndev_err(&pdev->dev, "missing platform driver data\n");\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nmmc = mmc_alloc_host(sizeof(struct sdh_host), &pdev->dev);\r\nif (!mmc) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nmmc->ops = &sdh_ops;\r\n#if defined(CONFIG_BF51x)\r\nmmc->max_segs = 1;\r\n#else\r\nmmc->max_segs = PAGE_SIZE / sizeof(struct dma_desc_array);\r\n#endif\r\n#ifdef RSI_BLKSZ\r\nmmc->max_seg_size = -1;\r\n#else\r\nmmc->max_seg_size = 1 << 16;\r\n#endif\r\nmmc->max_blk_size = 1 << 11;\r\nmmc->max_blk_count = 1 << 11;\r\nmmc->max_req_size = PAGE_SIZE;\r\nmmc->ocr_avail = MMC_VDD_32_33 | MMC_VDD_33_34;\r\nmmc->f_max = get_sclk();\r\nmmc->f_min = mmc->f_max >> 9;\r\nmmc->caps = MMC_CAP_4_BIT_DATA | MMC_CAP_NEEDS_POLL;\r\nhost = mmc_priv(mmc);\r\nhost->mmc = mmc;\r\nhost->sclk = get_sclk();\r\nspin_lock_init(&host->lock);\r\nhost->irq = drv_data->irq_int0;\r\nhost->dma_ch = drv_data->dma_chan;\r\nret = request_dma(host->dma_ch, DRIVER_NAME "DMA");\r\nif (ret) {\r\ndev_err(&pdev->dev, "unable to request DMA channel\n");\r\ngoto out1;\r\n}\r\nret = set_dma_callback(host->dma_ch, sdh_dma_irq, host);\r\nif (ret) {\r\ndev_err(&pdev->dev, "unable to request DMA irq\n");\r\ngoto out2;\r\n}\r\nhost->sg_cpu = dma_alloc_coherent(&pdev->dev, PAGE_SIZE, &host->sg_dma, GFP_KERNEL);\r\nif (host->sg_cpu == NULL) {\r\nret = -ENOMEM;\r\ngoto out2;\r\n}\r\nplatform_set_drvdata(pdev, mmc);\r\nret = request_irq(host->irq, sdh_stat_irq, 0, "SDH Status IRQ", host);\r\nif (ret) {\r\ndev_err(&pdev->dev, "unable to request status irq\n");\r\ngoto out3;\r\n}\r\nret = peripheral_request_list(drv_data->pin_req, DRIVER_NAME);\r\nif (ret) {\r\ndev_err(&pdev->dev, "unable to request peripheral pins\n");\r\ngoto out4;\r\n}\r\nsdh_reset();\r\nmmc_add_host(mmc);\r\nreturn 0;\r\nout4:\r\nfree_irq(host->irq, host);\r\nout3:\r\nmmc_remove_host(mmc);\r\ndma_free_coherent(&pdev->dev, PAGE_SIZE, host->sg_cpu, host->sg_dma);\r\nout2:\r\nfree_dma(host->dma_ch);\r\nout1:\r\nmmc_free_host(mmc);\r\nout:\r\nreturn ret;\r\n}\r\nstatic int sdh_remove(struct platform_device *pdev)\r\n{\r\nstruct mmc_host *mmc = platform_get_drvdata(pdev);\r\nplatform_set_drvdata(pdev, NULL);\r\nif (mmc) {\r\nstruct sdh_host *host = mmc_priv(mmc);\r\nmmc_remove_host(mmc);\r\nsdh_stop_clock(host);\r\nfree_irq(host->irq, host);\r\nfree_dma(host->dma_ch);\r\ndma_free_coherent(&pdev->dev, PAGE_SIZE, host->sg_cpu, host->sg_dma);\r\nmmc_free_host(mmc);\r\n}\r\nreturn 0;\r\n}\r\nstatic int sdh_suspend(struct platform_device *dev, pm_message_t state)\r\n{\r\nstruct mmc_host *mmc = platform_get_drvdata(dev);\r\nstruct bfin_sd_host *drv_data = get_sdh_data(dev);\r\nint ret = 0;\r\nif (mmc)\r\nret = mmc_suspend_host(mmc);\r\nperipheral_free_list(drv_data->pin_req);\r\nreturn ret;\r\n}\r\nstatic int sdh_resume(struct platform_device *dev)\r\n{\r\nstruct mmc_host *mmc = platform_get_drvdata(dev);\r\nstruct bfin_sd_host *drv_data = get_sdh_data(dev);\r\nint ret = 0;\r\nret = peripheral_request_list(drv_data->pin_req, DRIVER_NAME);\r\nif (ret) {\r\ndev_err(&dev->dev, "unable to request peripheral pins\n");\r\nreturn ret;\r\n}\r\nsdh_reset();\r\nif (mmc)\r\nret = mmc_resume_host(mmc);\r\nreturn ret;\r\n}
