static int pcan_usb_send_cmd(struct peak_usb_device *dev, u8 f, u8 n, u8 *p)\r\n{\r\nint err;\r\nint actual_length;\r\nif (!(dev->state & PCAN_USB_STATE_CONNECTED))\r\nreturn 0;\r\ndev->cmd_buf[PCAN_USB_CMD_FUNC] = f;\r\ndev->cmd_buf[PCAN_USB_CMD_NUM] = n;\r\nif (p)\r\nmemcpy(dev->cmd_buf + PCAN_USB_CMD_ARGS,\r\np, PCAN_USB_CMD_ARGS_LEN);\r\nerr = usb_bulk_msg(dev->udev,\r\nusb_sndbulkpipe(dev->udev, PCAN_USB_EP_CMDOUT),\r\ndev->cmd_buf, PCAN_USB_CMD_LEN, &actual_length,\r\nPCAN_USB_COMMAND_TIMEOUT);\r\nif (err)\r\nnetdev_err(dev->netdev,\r\n"sending cmd f=0x%x n=0x%x failure: %d\n",\r\nf, n, err);\r\nreturn err;\r\n}\r\nstatic int pcan_usb_wait_rsp(struct peak_usb_device *dev, u8 f, u8 n, u8 *p)\r\n{\r\nint err;\r\nint actual_length;\r\nif (!(dev->state & PCAN_USB_STATE_CONNECTED))\r\nreturn 0;\r\nerr = pcan_usb_send_cmd(dev, f, n, NULL);\r\nif (err)\r\nreturn err;\r\nerr = usb_bulk_msg(dev->udev,\r\nusb_rcvbulkpipe(dev->udev, PCAN_USB_EP_CMDIN),\r\ndev->cmd_buf, PCAN_USB_CMD_LEN, &actual_length,\r\nPCAN_USB_COMMAND_TIMEOUT);\r\nif (err)\r\nnetdev_err(dev->netdev,\r\n"waiting rsp f=0x%x n=0x%x failure: %d\n", f, n, err);\r\nelse if (p)\r\nmemcpy(p, dev->cmd_buf + PCAN_USB_CMD_ARGS,\r\nPCAN_USB_CMD_ARGS_LEN);\r\nreturn err;\r\n}\r\nstatic int pcan_usb_set_sja1000(struct peak_usb_device *dev, u8 mode)\r\n{\r\nu8 args[PCAN_USB_CMD_ARGS_LEN] = {\r\n[1] = mode,\r\n};\r\nreturn pcan_usb_send_cmd(dev, 9, 2, args);\r\n}\r\nstatic int pcan_usb_set_bus(struct peak_usb_device *dev, u8 onoff)\r\n{\r\nu8 args[PCAN_USB_CMD_ARGS_LEN] = {\r\n[0] = !!onoff,\r\n};\r\nreturn pcan_usb_send_cmd(dev, 3, 2, args);\r\n}\r\nstatic int pcan_usb_set_silent(struct peak_usb_device *dev, u8 onoff)\r\n{\r\nu8 args[PCAN_USB_CMD_ARGS_LEN] = {\r\n[0] = !!onoff,\r\n};\r\nreturn pcan_usb_send_cmd(dev, 3, 3, args);\r\n}\r\nstatic int pcan_usb_set_ext_vcc(struct peak_usb_device *dev, u8 onoff)\r\n{\r\nu8 args[PCAN_USB_CMD_ARGS_LEN] = {\r\n[0] = !!onoff,\r\n};\r\nreturn pcan_usb_send_cmd(dev, 10, 2, args);\r\n}\r\nstatic int pcan_usb_set_bittiming(struct peak_usb_device *dev,\r\nstruct can_bittiming *bt)\r\n{\r\nu8 args[PCAN_USB_CMD_ARGS_LEN];\r\nu8 btr0, btr1;\r\nbtr0 = ((bt->brp - 1) & 0x3f) | (((bt->sjw - 1) & 0x3) << 6);\r\nbtr1 = ((bt->prop_seg + bt->phase_seg1 - 1) & 0xf) |\r\n(((bt->phase_seg2 - 1) & 0x7) << 4);\r\nif (dev->can.ctrlmode & CAN_CTRLMODE_3_SAMPLES)\r\nbtr1 |= 0x80;\r\nnetdev_info(dev->netdev, "setting BTR0=0x%02x BTR1=0x%02x\n",\r\nbtr0, btr1);\r\nargs[0] = btr1;\r\nargs[1] = btr0;\r\nreturn pcan_usb_send_cmd(dev, 1, 2, args);\r\n}\r\nstatic int pcan_usb_write_mode(struct peak_usb_device *dev, u8 onoff)\r\n{\r\nint err;\r\nerr = pcan_usb_set_bus(dev, onoff);\r\nif (err)\r\nreturn err;\r\nif (!onoff) {\r\nerr = pcan_usb_set_sja1000(dev, SJA1000_MODE_INIT);\r\n} else {\r\nset_current_state(TASK_INTERRUPTIBLE);\r\nschedule_timeout(msecs_to_jiffies(PCAN_USB_STARTUP_TIMEOUT));\r\n}\r\nreturn err;\r\n}\r\nstatic void pcan_usb_restart(unsigned long arg)\r\n{\r\npeak_usb_restart_complete((struct peak_usb_device *)arg);\r\n}\r\nstatic void pcan_usb_restart_pending(struct urb *urb)\r\n{\r\nstruct pcan_usb *pdev = urb->context;\r\nmod_timer(&pdev->restart_timer,\r\njiffies + msecs_to_jiffies(PCAN_USB_STARTUP_TIMEOUT));\r\npeak_usb_async_complete(urb);\r\n}\r\nstatic int pcan_usb_restart_async(struct peak_usb_device *dev, struct urb *urb,\r\nu8 *buf)\r\n{\r\nstruct pcan_usb *pdev = container_of(dev, struct pcan_usb, dev);\r\nif (timer_pending(&pdev->restart_timer))\r\nreturn -EBUSY;\r\nbuf[PCAN_USB_CMD_FUNC] = 3;\r\nbuf[PCAN_USB_CMD_NUM] = 2;\r\nbuf[PCAN_USB_CMD_ARGS] = 1;\r\nusb_fill_bulk_urb(urb, dev->udev,\r\nusb_sndbulkpipe(dev->udev, PCAN_USB_EP_CMDOUT),\r\nbuf, PCAN_USB_CMD_LEN,\r\npcan_usb_restart_pending, pdev);\r\nreturn usb_submit_urb(urb, GFP_ATOMIC);\r\n}\r\nstatic int pcan_usb_get_serial(struct peak_usb_device *dev, u32 *serial_number)\r\n{\r\nu8 args[PCAN_USB_CMD_ARGS_LEN];\r\nint err;\r\nerr = pcan_usb_wait_rsp(dev, 6, 1, args);\r\nif (err) {\r\nnetdev_err(dev->netdev, "getting serial failure: %d\n", err);\r\n} else if (serial_number) {\r\nu32 tmp32;\r\nmemcpy(&tmp32, args, 4);\r\n*serial_number = le32_to_cpu(tmp32);\r\n}\r\nreturn err;\r\n}\r\nstatic int pcan_usb_get_device_id(struct peak_usb_device *dev, u32 *device_id)\r\n{\r\nu8 args[PCAN_USB_CMD_ARGS_LEN];\r\nint err;\r\nerr = pcan_usb_wait_rsp(dev, 4, 1, args);\r\nif (err)\r\nnetdev_err(dev->netdev, "getting device id failure: %d\n", err);\r\nelse if (device_id)\r\n*device_id = args[0];\r\nreturn err;\r\n}\r\nstatic int pcan_usb_update_ts(struct pcan_usb_msg_context *mc)\r\n{\r\nu16 tmp16;\r\nif ((mc->ptr+2) > mc->end)\r\nreturn -EINVAL;\r\nmemcpy(&tmp16, mc->ptr, 2);\r\nmc->ts16 = le16_to_cpu(tmp16);\r\nif (mc->rec_idx > 0)\r\npeak_usb_update_ts_now(&mc->pdev->time_ref, mc->ts16);\r\nelse\r\npeak_usb_set_ts_now(&mc->pdev->time_ref, mc->ts16);\r\nreturn 0;\r\n}\r\nstatic int pcan_usb_decode_ts(struct pcan_usb_msg_context *mc, u8 first_packet)\r\n{\r\nif (first_packet) {\r\nu16 tmp16;\r\nif ((mc->ptr + 2) > mc->end)\r\nreturn -EINVAL;\r\nmemcpy(&tmp16, mc->ptr, 2);\r\nmc->ptr += 2;\r\nmc->ts16 = le16_to_cpu(tmp16);\r\nmc->prev_ts8 = mc->ts16 & 0x00ff;\r\n} else {\r\nu8 ts8;\r\nif ((mc->ptr + 1) > mc->end)\r\nreturn -EINVAL;\r\nts8 = *mc->ptr++;\r\nif (ts8 < mc->prev_ts8)\r\nmc->ts16 += 0x100;\r\nmc->ts16 &= 0xff00;\r\nmc->ts16 |= ts8;\r\nmc->prev_ts8 = ts8;\r\n}\r\nreturn 0;\r\n}\r\nstatic int pcan_usb_decode_error(struct pcan_usb_msg_context *mc, u8 n,\r\nu8 status_len)\r\n{\r\nstruct sk_buff *skb;\r\nstruct can_frame *cf;\r\nstruct timeval tv;\r\nenum can_state new_state;\r\nif (n == PCAN_USB_ERROR_QOVR)\r\nif (!mc->pdev->time_ref.tick_count)\r\nreturn 0;\r\nnew_state = mc->pdev->dev.can.state;\r\nswitch (mc->pdev->dev.can.state) {\r\ncase CAN_STATE_ERROR_ACTIVE:\r\nif (n & PCAN_USB_ERROR_BUS_LIGHT) {\r\nnew_state = CAN_STATE_ERROR_WARNING;\r\nbreak;\r\n}\r\ncase CAN_STATE_ERROR_WARNING:\r\nif (n & PCAN_USB_ERROR_BUS_HEAVY) {\r\nnew_state = CAN_STATE_ERROR_PASSIVE;\r\nbreak;\r\n}\r\nif (n & PCAN_USB_ERROR_BUS_OFF) {\r\nnew_state = CAN_STATE_BUS_OFF;\r\nbreak;\r\n}\r\nif (n & (PCAN_USB_ERROR_RXQOVR | PCAN_USB_ERROR_QOVR)) {\r\nnew_state = CAN_STATE_MAX;\r\nbreak;\r\n}\r\nif ((n & PCAN_USB_ERROR_BUS_LIGHT) == 0) {\r\nmc->pdev->dev.can.state = CAN_STATE_ERROR_ACTIVE;\r\nreturn 0;\r\n}\r\nbreak;\r\ncase CAN_STATE_ERROR_PASSIVE:\r\nif (n & PCAN_USB_ERROR_BUS_OFF) {\r\nnew_state = CAN_STATE_BUS_OFF;\r\nbreak;\r\n}\r\nif (n & PCAN_USB_ERROR_BUS_LIGHT) {\r\nnew_state = CAN_STATE_ERROR_WARNING;\r\nbreak;\r\n}\r\nif (n & (PCAN_USB_ERROR_RXQOVR | PCAN_USB_ERROR_QOVR)) {\r\nnew_state = CAN_STATE_MAX;\r\nbreak;\r\n}\r\nif ((n & PCAN_USB_ERROR_BUS_HEAVY) == 0) {\r\nmc->pdev->dev.can.state = CAN_STATE_ERROR_ACTIVE;\r\nreturn 0;\r\n}\r\nbreak;\r\ndefault:\r\nreturn 0;\r\n}\r\nif (mc->pdev->dev.can.state == new_state)\r\nreturn 0;\r\nskb = alloc_can_err_skb(mc->netdev, &cf);\r\nif (!skb)\r\nreturn -ENOMEM;\r\nswitch (new_state) {\r\ncase CAN_STATE_BUS_OFF:\r\ncf->can_id |= CAN_ERR_BUSOFF;\r\ncan_bus_off(mc->netdev);\r\nbreak;\r\ncase CAN_STATE_ERROR_PASSIVE:\r\ncf->can_id |= CAN_ERR_CRTL;\r\ncf->data[1] |= CAN_ERR_CRTL_TX_PASSIVE |\r\nCAN_ERR_CRTL_RX_PASSIVE;\r\nmc->pdev->dev.can.can_stats.error_passive++;\r\nbreak;\r\ncase CAN_STATE_ERROR_WARNING:\r\ncf->can_id |= CAN_ERR_CRTL;\r\ncf->data[1] |= CAN_ERR_CRTL_TX_WARNING |\r\nCAN_ERR_CRTL_RX_WARNING;\r\nmc->pdev->dev.can.can_stats.error_warning++;\r\nbreak;\r\ndefault:\r\ncf->can_id |= CAN_ERR_CRTL;\r\ncf->data[1] |= CAN_ERR_CRTL_RX_OVERFLOW;\r\nmc->netdev->stats.rx_over_errors++;\r\nmc->netdev->stats.rx_errors++;\r\nnew_state = mc->pdev->dev.can.state;\r\nbreak;\r\n}\r\nmc->pdev->dev.can.state = new_state;\r\nif (status_len & PCAN_USB_STATUSLEN_TIMESTAMP) {\r\nstruct skb_shared_hwtstamps *hwts = skb_hwtstamps(skb);\r\npeak_usb_get_ts_tv(&mc->pdev->time_ref, mc->ts16, &tv);\r\nhwts->hwtstamp = timeval_to_ktime(tv);\r\n}\r\nnetif_rx(skb);\r\nmc->netdev->stats.rx_packets++;\r\nmc->netdev->stats.rx_bytes += cf->can_dlc;\r\nreturn 0;\r\n}\r\nstatic int pcan_usb_decode_status(struct pcan_usb_msg_context *mc,\r\nu8 status_len)\r\n{\r\nu8 rec_len = status_len & PCAN_USB_STATUSLEN_DLC;\r\nu8 f, n;\r\nint err;\r\nif ((mc->ptr + 2) > mc->end)\r\nreturn -EINVAL;\r\nf = mc->ptr[PCAN_USB_CMD_FUNC];\r\nn = mc->ptr[PCAN_USB_CMD_NUM];\r\nmc->ptr += PCAN_USB_CMD_ARGS;\r\nif (status_len & PCAN_USB_STATUSLEN_TIMESTAMP) {\r\nint err = pcan_usb_decode_ts(mc, !mc->rec_idx);\r\nif (err)\r\nreturn err;\r\n}\r\nswitch (f) {\r\ncase PCAN_USB_REC_ERROR:\r\nerr = pcan_usb_decode_error(mc, n, status_len);\r\nif (err)\r\nreturn err;\r\nbreak;\r\ncase PCAN_USB_REC_ANALOG:\r\nrec_len = 2;\r\nbreak;\r\ncase PCAN_USB_REC_BUSLOAD:\r\nrec_len = 1;\r\nbreak;\r\ncase PCAN_USB_REC_TS:\r\nif (pcan_usb_update_ts(mc))\r\nreturn -EINVAL;\r\nbreak;\r\ncase PCAN_USB_REC_BUSEVT:\r\nif (n & PCAN_USB_ERROR_TXQFULL)\r\nnetdev_dbg(mc->netdev, "device Tx queue full)\n");\r\nbreak;\r\ndefault:\r\nnetdev_err(mc->netdev, "unexpected function %u\n", f);\r\nbreak;\r\n}\r\nif ((mc->ptr + rec_len) > mc->end)\r\nreturn -EINVAL;\r\nmc->ptr += rec_len;\r\nreturn 0;\r\n}\r\nstatic int pcan_usb_decode_data(struct pcan_usb_msg_context *mc, u8 status_len)\r\n{\r\nu8 rec_len = status_len & PCAN_USB_STATUSLEN_DLC;\r\nstruct sk_buff *skb;\r\nstruct can_frame *cf;\r\nstruct timeval tv;\r\nstruct skb_shared_hwtstamps *hwts;\r\nskb = alloc_can_skb(mc->netdev, &cf);\r\nif (!skb)\r\nreturn -ENOMEM;\r\nif (status_len & PCAN_USB_STATUSLEN_EXT_ID) {\r\nu32 tmp32;\r\nif ((mc->ptr + 4) > mc->end)\r\ngoto decode_failed;\r\nmemcpy(&tmp32, mc->ptr, 4);\r\nmc->ptr += 4;\r\ncf->can_id = le32_to_cpu(tmp32 >> 3) | CAN_EFF_FLAG;\r\n} else {\r\nu16 tmp16;\r\nif ((mc->ptr + 2) > mc->end)\r\ngoto decode_failed;\r\nmemcpy(&tmp16, mc->ptr, 2);\r\nmc->ptr += 2;\r\ncf->can_id = le16_to_cpu(tmp16 >> 5);\r\n}\r\ncf->can_dlc = get_can_dlc(rec_len);\r\nif (pcan_usb_decode_ts(mc, !mc->rec_data_idx))\r\ngoto decode_failed;\r\nmemset(cf->data, 0x0, sizeof(cf->data));\r\nif (status_len & PCAN_USB_STATUSLEN_RTR) {\r\ncf->can_id |= CAN_RTR_FLAG;\r\n} else {\r\nif ((mc->ptr + rec_len) > mc->end)\r\ngoto decode_failed;\r\nmemcpy(cf->data, mc->ptr, rec_len);\r\nmc->ptr += rec_len;\r\n}\r\npeak_usb_get_ts_tv(&mc->pdev->time_ref, mc->ts16, &tv);\r\nhwts = skb_hwtstamps(skb);\r\nhwts->hwtstamp = timeval_to_ktime(tv);\r\nnetif_rx(skb);\r\nmc->netdev->stats.rx_packets++;\r\nmc->netdev->stats.rx_bytes += cf->can_dlc;\r\nreturn 0;\r\ndecode_failed:\r\ndev_kfree_skb(skb);\r\nreturn -EINVAL;\r\n}\r\nstatic int pcan_usb_decode_msg(struct peak_usb_device *dev, u8 *ibuf, u32 lbuf)\r\n{\r\nstruct pcan_usb_msg_context mc = {\r\n.rec_cnt = ibuf[1],\r\n.ptr = ibuf + PCAN_USB_MSG_HEADER_LEN,\r\n.end = ibuf + lbuf,\r\n.netdev = dev->netdev,\r\n.pdev = container_of(dev, struct pcan_usb, dev),\r\n};\r\nint err;\r\nfor (err = 0; mc.rec_idx < mc.rec_cnt && !err; mc.rec_idx++) {\r\nu8 sl = *mc.ptr++;\r\nif (sl & PCAN_USB_STATUSLEN_INTERNAL) {\r\nerr = pcan_usb_decode_status(&mc, sl);\r\n} else {\r\nerr = pcan_usb_decode_data(&mc, sl);\r\nmc.rec_data_idx++;\r\n}\r\n}\r\nreturn err;\r\n}\r\nstatic int pcan_usb_decode_buf(struct peak_usb_device *dev, struct urb *urb)\r\n{\r\nint err = 0;\r\nif (urb->actual_length > PCAN_USB_MSG_HEADER_LEN) {\r\nerr = pcan_usb_decode_msg(dev, urb->transfer_buffer,\r\nurb->actual_length);\r\n} else if (urb->actual_length > 0) {\r\nnetdev_err(dev->netdev, "usb message length error (%u)\n",\r\nurb->actual_length);\r\nerr = -EINVAL;\r\n}\r\nreturn err;\r\n}\r\nstatic int pcan_usb_encode_msg(struct peak_usb_device *dev, struct sk_buff *skb,\r\nu8 *obuf, size_t *size)\r\n{\r\nstruct net_device *netdev = dev->netdev;\r\nstruct net_device_stats *stats = &netdev->stats;\r\nstruct can_frame *cf = (struct can_frame *)skb->data;\r\nu8 *pc;\r\nobuf[0] = 2;\r\nobuf[1] = 1;\r\npc = obuf + PCAN_USB_MSG_HEADER_LEN;\r\n*pc = cf->can_dlc;\r\nif (cf->can_id & CAN_RTR_FLAG)\r\n*pc |= PCAN_USB_STATUSLEN_RTR;\r\nif (cf->can_id & CAN_EFF_FLAG) {\r\n__le32 tmp32 = cpu_to_le32((cf->can_id & CAN_ERR_MASK) << 3);\r\n*pc |= PCAN_USB_STATUSLEN_EXT_ID;\r\nmemcpy(++pc, &tmp32, 4);\r\npc += 4;\r\n} else {\r\n__le16 tmp16 = cpu_to_le16((cf->can_id & CAN_ERR_MASK) << 5);\r\nmemcpy(++pc, &tmp16, 2);\r\npc += 2;\r\n}\r\nif (!(cf->can_id & CAN_RTR_FLAG)) {\r\nmemcpy(pc, cf->data, cf->can_dlc);\r\npc += cf->can_dlc;\r\n}\r\nobuf[(*size)-1] = (u8)(stats->tx_packets & 0xff);\r\nreturn 0;\r\n}\r\nstatic int pcan_usb_start(struct peak_usb_device *dev)\r\n{\r\nstruct pcan_usb *pdev = container_of(dev, struct pcan_usb, dev);\r\npeak_usb_init_time_ref(&pdev->time_ref, &pcan_usb);\r\nif (dev->device_rev > 3) {\r\nint err;\r\nerr = pcan_usb_set_silent(dev,\r\ndev->can.ctrlmode & CAN_CTRLMODE_LISTENONLY);\r\nif (err)\r\nreturn err;\r\n}\r\nreturn pcan_usb_set_ext_vcc(dev, 0);\r\n}\r\nstatic int pcan_usb_init(struct peak_usb_device *dev)\r\n{\r\nstruct pcan_usb *pdev = container_of(dev, struct pcan_usb, dev);\r\nu32 serial_number;\r\nint err;\r\ninit_timer(&pdev->restart_timer);\r\npdev->restart_timer.function = pcan_usb_restart;\r\npdev->restart_timer.data = (unsigned long)dev;\r\nerr = pcan_usb_get_serial(dev, &serial_number);\r\nif (err) {\r\ndev_err(dev->netdev->dev.parent,\r\n"unable to read %s serial number (err %d)\n",\r\npcan_usb.name, err);\r\nreturn err;\r\n}\r\ndev_info(dev->netdev->dev.parent,\r\n"PEAK-System %s adapter hwrev %u serial %08X (%u channel)\n",\r\npcan_usb.name, dev->device_rev, serial_number,\r\npcan_usb.ctrl_count);\r\nreturn 0;\r\n}\r\nstatic int pcan_usb_probe(struct usb_interface *intf)\r\n{\r\nstruct usb_host_interface *if_desc;\r\nint i;\r\nif_desc = intf->altsetting;\r\nfor (i = 0; i < if_desc->desc.bNumEndpoints; i++) {\r\nstruct usb_endpoint_descriptor *ep = &if_desc->endpoint[i].desc;\r\nswitch (ep->bEndpointAddress) {\r\ncase PCAN_USB_EP_CMDOUT:\r\ncase PCAN_USB_EP_CMDIN:\r\ncase PCAN_USB_EP_MSGOUT:\r\ncase PCAN_USB_EP_MSGIN:\r\nbreak;\r\ndefault:\r\nreturn -ENODEV;\r\n}\r\n}\r\nreturn 0;\r\n}
