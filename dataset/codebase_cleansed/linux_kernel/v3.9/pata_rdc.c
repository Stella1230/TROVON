static int rdc_pata_cable_detect(struct ata_port *ap)\r\n{\r\nstruct rdc_host_priv *hpriv = ap->host->private_data;\r\nu8 mask;\r\nmask = 0x30 << (2 * ap->port_no);\r\nif ((hpriv->saved_iocfg & mask) == 0)\r\nreturn ATA_CBL_PATA40;\r\nreturn ATA_CBL_PATA80;\r\n}\r\nstatic int rdc_pata_prereset(struct ata_link *link, unsigned long deadline)\r\n{\r\nstruct ata_port *ap = link->ap;\r\nstruct pci_dev *pdev = to_pci_dev(ap->host->dev);\r\nstatic const struct pci_bits rdc_enable_bits[] = {\r\n{ 0x41U, 1U, 0x80UL, 0x80UL },\r\n{ 0x43U, 1U, 0x80UL, 0x80UL },\r\n};\r\nif (!pci_test_config_bits(pdev, &rdc_enable_bits[ap->port_no]))\r\nreturn -ENOENT;\r\nreturn ata_sff_prereset(link, deadline);\r\n}\r\nstatic void rdc_set_piomode(struct ata_port *ap, struct ata_device *adev)\r\n{\r\nunsigned int pio = adev->pio_mode - XFER_PIO_0;\r\nstruct pci_dev *dev = to_pci_dev(ap->host->dev);\r\nunsigned long flags;\r\nunsigned int is_slave = (adev->devno != 0);\r\nunsigned int master_port= ap->port_no ? 0x42 : 0x40;\r\nunsigned int slave_port = 0x44;\r\nu16 master_data;\r\nu8 slave_data;\r\nu8 udma_enable;\r\nint control = 0;\r\nstatic const\r\nu8 timings[][2] = { { 0, 0 },\r\n{ 0, 0 },\r\n{ 1, 0 },\r\n{ 2, 1 },\r\n{ 2, 3 }, };\r\nif (pio >= 2)\r\ncontrol |= 1;\r\nif (ata_pio_need_iordy(adev))\r\ncontrol |= 2;\r\nif (adev->class == ATA_DEV_ATA)\r\ncontrol |= 4;\r\nspin_lock_irqsave(&rdc_lock, flags);\r\npci_read_config_word(dev, master_port, &master_data);\r\nif (is_slave) {\r\nmaster_data &= 0xff0f;\r\nmaster_data |= 0x4000;\r\nmaster_data |= (control << 4);\r\npci_read_config_byte(dev, slave_port, &slave_data);\r\nslave_data &= (ap->port_no ? 0x0f : 0xf0);\r\nslave_data |= ((timings[pio][0] << 2) | timings[pio][1])\r\n<< (ap->port_no ? 4 : 0);\r\n} else {\r\nmaster_data &= 0xccf0;\r\nmaster_data |= control;\r\nmaster_data |=\r\n(timings[pio][0] << 12) |\r\n(timings[pio][1] << 8);\r\n}\r\npci_write_config_word(dev, master_port, master_data);\r\nif (is_slave)\r\npci_write_config_byte(dev, slave_port, slave_data);\r\npci_read_config_byte(dev, 0x48, &udma_enable);\r\nudma_enable &= ~(1 << (2 * ap->port_no + adev->devno));\r\npci_write_config_byte(dev, 0x48, udma_enable);\r\nspin_unlock_irqrestore(&rdc_lock, flags);\r\n}\r\nstatic void rdc_set_dmamode(struct ata_port *ap, struct ata_device *adev)\r\n{\r\nstruct pci_dev *dev = to_pci_dev(ap->host->dev);\r\nunsigned long flags;\r\nu8 master_port = ap->port_no ? 0x42 : 0x40;\r\nu16 master_data;\r\nu8 speed = adev->dma_mode;\r\nint devid = adev->devno + 2 * ap->port_no;\r\nu8 udma_enable = 0;\r\nstatic const\r\nu8 timings[][2] = { { 0, 0 },\r\n{ 0, 0 },\r\n{ 1, 0 },\r\n{ 2, 1 },\r\n{ 2, 3 }, };\r\nspin_lock_irqsave(&rdc_lock, flags);\r\npci_read_config_word(dev, master_port, &master_data);\r\npci_read_config_byte(dev, 0x48, &udma_enable);\r\nif (speed >= XFER_UDMA_0) {\r\nunsigned int udma = adev->dma_mode - XFER_UDMA_0;\r\nu16 udma_timing;\r\nu16 ideconf;\r\nint u_clock, u_speed;\r\nu_speed = min(2 - (udma & 1), udma);\r\nif (udma == 5)\r\nu_clock = 0x1000;\r\nelse if (udma > 2)\r\nu_clock = 1;\r\nelse\r\nu_clock = 0;\r\nudma_enable |= (1 << devid);\r\npci_read_config_word(dev, 0x4A, &udma_timing);\r\nudma_timing &= ~(3 << (4 * devid));\r\nudma_timing |= u_speed << (4 * devid);\r\npci_write_config_word(dev, 0x4A, udma_timing);\r\npci_read_config_word(dev, 0x54, &ideconf);\r\nideconf &= ~(0x1001 << devid);\r\nideconf |= u_clock << devid;\r\npci_write_config_word(dev, 0x54, ideconf);\r\n} else {\r\nunsigned int mwdma = adev->dma_mode - XFER_MW_DMA_0;\r\nunsigned int control;\r\nu8 slave_data;\r\nconst unsigned int needed_pio[3] = {\r\nXFER_PIO_0, XFER_PIO_3, XFER_PIO_4\r\n};\r\nint pio = needed_pio[mwdma] - XFER_PIO_0;\r\ncontrol = 3;\r\nif (adev->pio_mode < needed_pio[mwdma])\r\ncontrol |= 8;\r\nif (adev->devno) {\r\nmaster_data &= 0xFF4F;\r\nmaster_data |= control << 4;\r\npci_read_config_byte(dev, 0x44, &slave_data);\r\nslave_data &= (ap->port_no ? 0x0f : 0xf0);\r\nslave_data |= ((timings[pio][0] << 2) | timings[pio][1]) << (ap->port_no ? 4 : 0);\r\npci_write_config_byte(dev, 0x44, slave_data);\r\n} else {\r\nmaster_data &= 0xCCF4;\r\nmaster_data |= control;\r\nmaster_data |=\r\n(timings[pio][0] << 12) |\r\n(timings[pio][1] << 8);\r\n}\r\nudma_enable &= ~(1 << devid);\r\npci_write_config_word(dev, master_port, master_data);\r\n}\r\npci_write_config_byte(dev, 0x48, udma_enable);\r\nspin_unlock_irqrestore(&rdc_lock, flags);\r\n}\r\nstatic int rdc_init_one(struct pci_dev *pdev, const struct pci_device_id *ent)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct ata_port_info port_info[2];\r\nconst struct ata_port_info *ppi[] = { &port_info[0], &port_info[1] };\r\nstruct ata_host *host;\r\nstruct rdc_host_priv *hpriv;\r\nint rc;\r\nata_print_version_once(&pdev->dev, DRV_VERSION);\r\nport_info[0] = rdc_port_info;\r\nport_info[1] = rdc_port_info;\r\nrc = pcim_enable_device(pdev);\r\nif (rc)\r\nreturn rc;\r\nhpriv = devm_kzalloc(dev, sizeof(*hpriv), GFP_KERNEL);\r\nif (!hpriv)\r\nreturn -ENOMEM;\r\npci_read_config_dword(pdev, 0x54, &hpriv->saved_iocfg);\r\nrc = ata_pci_bmdma_prepare_host(pdev, ppi, &host);\r\nif (rc)\r\nreturn rc;\r\nhost->private_data = hpriv;\r\npci_intx(pdev, 1);\r\nhost->flags |= ATA_HOST_PARALLEL_SCAN;\r\npci_set_master(pdev);\r\nreturn ata_pci_sff_activate_host(host, ata_bmdma_interrupt, &rdc_sht);\r\n}\r\nstatic void rdc_remove_one(struct pci_dev *pdev)\r\n{\r\nstruct ata_host *host = dev_get_drvdata(&pdev->dev);\r\nstruct rdc_host_priv *hpriv = host->private_data;\r\npci_write_config_dword(pdev, 0x54, hpriv->saved_iocfg);\r\nata_pci_remove_one(pdev);\r\n}
