static void gntdev_print_maps(struct gntdev_priv *priv,\r\nchar *text, int text_index)\r\n{\r\n#ifdef DEBUG\r\nstruct grant_map *map;\r\npr_debug("%s: maps list (priv %p)\n", __func__, priv);\r\nlist_for_each_entry(map, &priv->maps, next)\r\npr_debug(" index %2d, count %2d %s\n",\r\nmap->index, map->count,\r\nmap->index == text_index && text ? text : "");\r\n#endif\r\n}\r\nstatic void gntdev_free_map(struct grant_map *map)\r\n{\r\nif (map == NULL)\r\nreturn;\r\nif (map->pages)\r\nfree_xenballooned_pages(map->count, map->pages);\r\nkfree(map->pages);\r\nkfree(map->grants);\r\nkfree(map->map_ops);\r\nkfree(map->unmap_ops);\r\nkfree(map->kmap_ops);\r\nkfree(map);\r\n}\r\nstatic struct grant_map *gntdev_alloc_map(struct gntdev_priv *priv, int count)\r\n{\r\nstruct grant_map *add;\r\nint i;\r\nadd = kzalloc(sizeof(struct grant_map), GFP_KERNEL);\r\nif (NULL == add)\r\nreturn NULL;\r\nadd->grants = kcalloc(count, sizeof(add->grants[0]), GFP_KERNEL);\r\nadd->map_ops = kcalloc(count, sizeof(add->map_ops[0]), GFP_KERNEL);\r\nadd->unmap_ops = kcalloc(count, sizeof(add->unmap_ops[0]), GFP_KERNEL);\r\nadd->kmap_ops = kcalloc(count, sizeof(add->kmap_ops[0]), GFP_KERNEL);\r\nadd->pages = kcalloc(count, sizeof(add->pages[0]), GFP_KERNEL);\r\nif (NULL == add->grants ||\r\nNULL == add->map_ops ||\r\nNULL == add->unmap_ops ||\r\nNULL == add->kmap_ops ||\r\nNULL == add->pages)\r\ngoto err;\r\nif (alloc_xenballooned_pages(count, add->pages, false ))\r\ngoto err;\r\nfor (i = 0; i < count; i++) {\r\nadd->map_ops[i].handle = -1;\r\nadd->unmap_ops[i].handle = -1;\r\nadd->kmap_ops[i].handle = -1;\r\n}\r\nadd->index = 0;\r\nadd->count = count;\r\natomic_set(&add->users, 1);\r\nreturn add;\r\nerr:\r\ngntdev_free_map(add);\r\nreturn NULL;\r\n}\r\nstatic void gntdev_add_map(struct gntdev_priv *priv, struct grant_map *add)\r\n{\r\nstruct grant_map *map;\r\nlist_for_each_entry(map, &priv->maps, next) {\r\nif (add->index + add->count < map->index) {\r\nlist_add_tail(&add->next, &map->next);\r\ngoto done;\r\n}\r\nadd->index = map->index + map->count;\r\n}\r\nlist_add_tail(&add->next, &priv->maps);\r\ndone:\r\ngntdev_print_maps(priv, "[new]", add->index);\r\n}\r\nstatic struct grant_map *gntdev_find_map_index(struct gntdev_priv *priv,\r\nint index, int count)\r\n{\r\nstruct grant_map *map;\r\nlist_for_each_entry(map, &priv->maps, next) {\r\nif (map->index != index)\r\ncontinue;\r\nif (count && map->count != count)\r\ncontinue;\r\nreturn map;\r\n}\r\nreturn NULL;\r\n}\r\nstatic void gntdev_put_map(struct gntdev_priv *priv, struct grant_map *map)\r\n{\r\nif (!map)\r\nreturn;\r\nif (!atomic_dec_and_test(&map->users))\r\nreturn;\r\natomic_sub(map->count, &pages_mapped);\r\nif (map->notify.flags & UNMAP_NOTIFY_SEND_EVENT) {\r\nnotify_remote_via_evtchn(map->notify.event);\r\nevtchn_put(map->notify.event);\r\n}\r\nif (populate_freeable_maps && priv) {\r\nspin_lock(&priv->lock);\r\nlist_del(&map->next);\r\nspin_unlock(&priv->lock);\r\n}\r\nif (map->pages && !use_ptemod)\r\nunmap_grant_pages(map, 0, map->count);\r\ngntdev_free_map(map);\r\n}\r\nstatic int find_grant_ptes(pte_t *pte, pgtable_t token,\r\nunsigned long addr, void *data)\r\n{\r\nstruct grant_map *map = data;\r\nunsigned int pgnr = (addr - map->vma->vm_start) >> PAGE_SHIFT;\r\nint flags = map->flags | GNTMAP_application_map | GNTMAP_contains_pte;\r\nu64 pte_maddr;\r\nBUG_ON(pgnr >= map->count);\r\npte_maddr = arbitrary_virt_to_machine(pte).maddr;\r\ngnttab_set_map_op(&map->map_ops[pgnr], pte_maddr, flags,\r\nmap->grants[pgnr].ref,\r\nmap->grants[pgnr].domid);\r\ngnttab_set_unmap_op(&map->unmap_ops[pgnr], pte_maddr, flags,\r\n-1 );\r\nreturn 0;\r\n}\r\nstatic int map_grant_pages(struct grant_map *map)\r\n{\r\nint i, err = 0;\r\nif (!use_ptemod) {\r\nif (map->map_ops[0].handle != -1)\r\nreturn 0;\r\nfor (i = 0; i < map->count; i++) {\r\nunsigned long addr = (unsigned long)\r\npfn_to_kaddr(page_to_pfn(map->pages[i]));\r\ngnttab_set_map_op(&map->map_ops[i], addr, map->flags,\r\nmap->grants[i].ref,\r\nmap->grants[i].domid);\r\ngnttab_set_unmap_op(&map->unmap_ops[i], addr,\r\nmap->flags, -1 );\r\n}\r\n} else {\r\nfor (i = 0; i < map->count; i++) {\r\nunsigned level;\r\nunsigned long address = (unsigned long)\r\npfn_to_kaddr(page_to_pfn(map->pages[i]));\r\npte_t *ptep;\r\nu64 pte_maddr = 0;\r\nBUG_ON(PageHighMem(map->pages[i]));\r\nptep = lookup_address(address, &level);\r\npte_maddr = arbitrary_virt_to_machine(ptep).maddr;\r\ngnttab_set_map_op(&map->kmap_ops[i], pte_maddr,\r\nmap->flags |\r\nGNTMAP_host_map |\r\nGNTMAP_contains_pte,\r\nmap->grants[i].ref,\r\nmap->grants[i].domid);\r\n}\r\n}\r\npr_debug("map %d+%d\n", map->index, map->count);\r\nerr = gnttab_map_refs(map->map_ops, use_ptemod ? map->kmap_ops : NULL,\r\nmap->pages, map->count);\r\nif (err)\r\nreturn err;\r\nfor (i = 0; i < map->count; i++) {\r\nif (map->map_ops[i].status)\r\nerr = -EINVAL;\r\nelse {\r\nBUG_ON(map->map_ops[i].handle == -1);\r\nmap->unmap_ops[i].handle = map->map_ops[i].handle;\r\npr_debug("map handle=%d\n", map->map_ops[i].handle);\r\n}\r\n}\r\nreturn err;\r\n}\r\nstatic int __unmap_grant_pages(struct grant_map *map, int offset, int pages)\r\n{\r\nint i, err = 0;\r\nif (map->notify.flags & UNMAP_NOTIFY_CLEAR_BYTE) {\r\nint pgno = (map->notify.addr >> PAGE_SHIFT);\r\nif (pgno >= offset && pgno < offset + pages) {\r\nuint8_t *tmp = pfn_to_kaddr(page_to_pfn(map->pages[pgno]));\r\ntmp[map->notify.addr & (PAGE_SIZE-1)] = 0;\r\nmap->notify.flags &= ~UNMAP_NOTIFY_CLEAR_BYTE;\r\n}\r\n}\r\nerr = gnttab_unmap_refs(map->unmap_ops + offset,\r\nuse_ptemod ? map->kmap_ops + offset : NULL, map->pages + offset,\r\npages);\r\nif (err)\r\nreturn err;\r\nfor (i = 0; i < pages; i++) {\r\nif (map->unmap_ops[offset+i].status)\r\nerr = -EINVAL;\r\npr_debug("unmap handle=%d st=%d\n",\r\nmap->unmap_ops[offset+i].handle,\r\nmap->unmap_ops[offset+i].status);\r\nmap->unmap_ops[offset+i].handle = -1;\r\n}\r\nreturn err;\r\n}\r\nstatic int unmap_grant_pages(struct grant_map *map, int offset, int pages)\r\n{\r\nint range, err = 0;\r\npr_debug("unmap %d+%d [%d+%d]\n", map->index, map->count, offset, pages);\r\nwhile (pages && !err) {\r\nwhile (pages && map->unmap_ops[offset].handle == -1) {\r\noffset++;\r\npages--;\r\n}\r\nrange = 0;\r\nwhile (range < pages) {\r\nif (map->unmap_ops[offset+range].handle == -1) {\r\nrange--;\r\nbreak;\r\n}\r\nrange++;\r\n}\r\nerr = __unmap_grant_pages(map, offset, range);\r\noffset += range;\r\npages -= range;\r\n}\r\nreturn err;\r\n}\r\nstatic void gntdev_vma_open(struct vm_area_struct *vma)\r\n{\r\nstruct grant_map *map = vma->vm_private_data;\r\npr_debug("gntdev_vma_open %p\n", vma);\r\natomic_inc(&map->users);\r\n}\r\nstatic void gntdev_vma_close(struct vm_area_struct *vma)\r\n{\r\nstruct grant_map *map = vma->vm_private_data;\r\nstruct file *file = vma->vm_file;\r\nstruct gntdev_priv *priv = file->private_data;\r\npr_debug("gntdev_vma_close %p\n", vma);\r\nif (use_ptemod) {\r\nspin_lock(&priv->lock);\r\nmap->vma = NULL;\r\nspin_unlock(&priv->lock);\r\n}\r\nvma->vm_private_data = NULL;\r\ngntdev_put_map(priv, map);\r\n}\r\nstatic void unmap_if_in_range(struct grant_map *map,\r\nunsigned long start, unsigned long end)\r\n{\r\nunsigned long mstart, mend;\r\nint err;\r\nif (!map->vma)\r\nreturn;\r\nif (map->vma->vm_start >= end)\r\nreturn;\r\nif (map->vma->vm_end <= start)\r\nreturn;\r\nmstart = max(start, map->vma->vm_start);\r\nmend = min(end, map->vma->vm_end);\r\npr_debug("map %d+%d (%lx %lx), range %lx %lx, mrange %lx %lx\n",\r\nmap->index, map->count,\r\nmap->vma->vm_start, map->vma->vm_end,\r\nstart, end, mstart, mend);\r\nerr = unmap_grant_pages(map,\r\n(mstart - map->vma->vm_start) >> PAGE_SHIFT,\r\n(mend - mstart) >> PAGE_SHIFT);\r\nWARN_ON(err);\r\n}\r\nstatic void mn_invl_range_start(struct mmu_notifier *mn,\r\nstruct mm_struct *mm,\r\nunsigned long start, unsigned long end)\r\n{\r\nstruct gntdev_priv *priv = container_of(mn, struct gntdev_priv, mn);\r\nstruct grant_map *map;\r\nspin_lock(&priv->lock);\r\nlist_for_each_entry(map, &priv->maps, next) {\r\nunmap_if_in_range(map, start, end);\r\n}\r\nlist_for_each_entry(map, &priv->freeable_maps, next) {\r\nunmap_if_in_range(map, start, end);\r\n}\r\nspin_unlock(&priv->lock);\r\n}\r\nstatic void mn_invl_page(struct mmu_notifier *mn,\r\nstruct mm_struct *mm,\r\nunsigned long address)\r\n{\r\nmn_invl_range_start(mn, mm, address, address + PAGE_SIZE);\r\n}\r\nstatic void mn_release(struct mmu_notifier *mn,\r\nstruct mm_struct *mm)\r\n{\r\nstruct gntdev_priv *priv = container_of(mn, struct gntdev_priv, mn);\r\nstruct grant_map *map;\r\nint err;\r\nspin_lock(&priv->lock);\r\nlist_for_each_entry(map, &priv->maps, next) {\r\nif (!map->vma)\r\ncontinue;\r\npr_debug("map %d+%d (%lx %lx)\n",\r\nmap->index, map->count,\r\nmap->vma->vm_start, map->vma->vm_end);\r\nerr = unmap_grant_pages(map, 0, map->count);\r\nWARN_ON(err);\r\n}\r\nlist_for_each_entry(map, &priv->freeable_maps, next) {\r\nif (!map->vma)\r\ncontinue;\r\npr_debug("map %d+%d (%lx %lx)\n",\r\nmap->index, map->count,\r\nmap->vma->vm_start, map->vma->vm_end);\r\nerr = unmap_grant_pages(map, 0, map->count);\r\nWARN_ON(err);\r\n}\r\nspin_unlock(&priv->lock);\r\n}\r\nstatic int gntdev_open(struct inode *inode, struct file *flip)\r\n{\r\nstruct gntdev_priv *priv;\r\nint ret = 0;\r\npriv = kzalloc(sizeof(*priv), GFP_KERNEL);\r\nif (!priv)\r\nreturn -ENOMEM;\r\nINIT_LIST_HEAD(&priv->maps);\r\nINIT_LIST_HEAD(&priv->freeable_maps);\r\nspin_lock_init(&priv->lock);\r\nif (use_ptemod) {\r\npriv->mm = get_task_mm(current);\r\nif (!priv->mm) {\r\nkfree(priv);\r\nreturn -ENOMEM;\r\n}\r\npriv->mn.ops = &gntdev_mmu_ops;\r\nret = mmu_notifier_register(&priv->mn, priv->mm);\r\nmmput(priv->mm);\r\n}\r\nif (ret) {\r\nkfree(priv);\r\nreturn ret;\r\n}\r\nflip->private_data = priv;\r\npr_debug("priv %p\n", priv);\r\nreturn 0;\r\n}\r\nstatic int gntdev_release(struct inode *inode, struct file *flip)\r\n{\r\nstruct gntdev_priv *priv = flip->private_data;\r\nstruct grant_map *map;\r\npr_debug("priv %p\n", priv);\r\nwhile (!list_empty(&priv->maps)) {\r\nmap = list_entry(priv->maps.next, struct grant_map, next);\r\nlist_del(&map->next);\r\ngntdev_put_map(NULL , map);\r\n}\r\nWARN_ON(!list_empty(&priv->freeable_maps));\r\nif (use_ptemod)\r\nmmu_notifier_unregister(&priv->mn, priv->mm);\r\nkfree(priv);\r\nreturn 0;\r\n}\r\nstatic long gntdev_ioctl_map_grant_ref(struct gntdev_priv *priv,\r\nstruct ioctl_gntdev_map_grant_ref __user *u)\r\n{\r\nstruct ioctl_gntdev_map_grant_ref op;\r\nstruct grant_map *map;\r\nint err;\r\nif (copy_from_user(&op, u, sizeof(op)) != 0)\r\nreturn -EFAULT;\r\npr_debug("priv %p, add %d\n", priv, op.count);\r\nif (unlikely(op.count <= 0))\r\nreturn -EINVAL;\r\nerr = -ENOMEM;\r\nmap = gntdev_alloc_map(priv, op.count);\r\nif (!map)\r\nreturn err;\r\nif (unlikely(atomic_add_return(op.count, &pages_mapped) > limit)) {\r\npr_debug("can't map: over limit\n");\r\ngntdev_put_map(NULL, map);\r\nreturn err;\r\n}\r\nif (copy_from_user(map->grants, &u->refs,\r\nsizeof(map->grants[0]) * op.count) != 0) {\r\ngntdev_put_map(NULL, map);\r\nreturn -EFAULT;\r\n}\r\nspin_lock(&priv->lock);\r\ngntdev_add_map(priv, map);\r\nop.index = map->index << PAGE_SHIFT;\r\nspin_unlock(&priv->lock);\r\nif (copy_to_user(u, &op, sizeof(op)) != 0)\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic long gntdev_ioctl_unmap_grant_ref(struct gntdev_priv *priv,\r\nstruct ioctl_gntdev_unmap_grant_ref __user *u)\r\n{\r\nstruct ioctl_gntdev_unmap_grant_ref op;\r\nstruct grant_map *map;\r\nint err = -ENOENT;\r\nif (copy_from_user(&op, u, sizeof(op)) != 0)\r\nreturn -EFAULT;\r\npr_debug("priv %p, del %d+%d\n", priv, (int)op.index, (int)op.count);\r\nspin_lock(&priv->lock);\r\nmap = gntdev_find_map_index(priv, op.index >> PAGE_SHIFT, op.count);\r\nif (map) {\r\nlist_del(&map->next);\r\nif (populate_freeable_maps)\r\nlist_add_tail(&map->next, &priv->freeable_maps);\r\nerr = 0;\r\n}\r\nspin_unlock(&priv->lock);\r\nif (map)\r\ngntdev_put_map(priv, map);\r\nreturn err;\r\n}\r\nstatic long gntdev_ioctl_get_offset_for_vaddr(struct gntdev_priv *priv,\r\nstruct ioctl_gntdev_get_offset_for_vaddr __user *u)\r\n{\r\nstruct ioctl_gntdev_get_offset_for_vaddr op;\r\nstruct vm_area_struct *vma;\r\nstruct grant_map *map;\r\nint rv = -EINVAL;\r\nif (copy_from_user(&op, u, sizeof(op)) != 0)\r\nreturn -EFAULT;\r\npr_debug("priv %p, offset for vaddr %lx\n", priv, (unsigned long)op.vaddr);\r\ndown_read(&current->mm->mmap_sem);\r\nvma = find_vma(current->mm, op.vaddr);\r\nif (!vma || vma->vm_ops != &gntdev_vmops)\r\ngoto out_unlock;\r\nmap = vma->vm_private_data;\r\nif (!map)\r\ngoto out_unlock;\r\nop.offset = map->index << PAGE_SHIFT;\r\nop.count = map->count;\r\nrv = 0;\r\nout_unlock:\r\nup_read(&current->mm->mmap_sem);\r\nif (rv == 0 && copy_to_user(u, &op, sizeof(op)) != 0)\r\nreturn -EFAULT;\r\nreturn rv;\r\n}\r\nstatic long gntdev_ioctl_notify(struct gntdev_priv *priv, void __user *u)\r\n{\r\nstruct ioctl_gntdev_unmap_notify op;\r\nstruct grant_map *map;\r\nint rc;\r\nint out_flags;\r\nunsigned int out_event;\r\nif (copy_from_user(&op, u, sizeof(op)))\r\nreturn -EFAULT;\r\nif (op.action & ~(UNMAP_NOTIFY_CLEAR_BYTE|UNMAP_NOTIFY_SEND_EVENT))\r\nreturn -EINVAL;\r\nif (op.action & UNMAP_NOTIFY_SEND_EVENT) {\r\nif (evtchn_get(op.event_channel_port))\r\nreturn -EINVAL;\r\n}\r\nout_flags = op.action;\r\nout_event = op.event_channel_port;\r\nspin_lock(&priv->lock);\r\nlist_for_each_entry(map, &priv->maps, next) {\r\nuint64_t begin = map->index << PAGE_SHIFT;\r\nuint64_t end = (map->index + map->count) << PAGE_SHIFT;\r\nif (op.index >= begin && op.index < end)\r\ngoto found;\r\n}\r\nrc = -ENOENT;\r\ngoto unlock_out;\r\nfound:\r\nif ((op.action & UNMAP_NOTIFY_CLEAR_BYTE) &&\r\n(map->flags & GNTMAP_readonly)) {\r\nrc = -EINVAL;\r\ngoto unlock_out;\r\n}\r\nout_flags = map->notify.flags;\r\nout_event = map->notify.event;\r\nmap->notify.flags = op.action;\r\nmap->notify.addr = op.index - (map->index << PAGE_SHIFT);\r\nmap->notify.event = op.event_channel_port;\r\nrc = 0;\r\nunlock_out:\r\nspin_unlock(&priv->lock);\r\nif (out_flags & UNMAP_NOTIFY_SEND_EVENT)\r\nevtchn_put(out_event);\r\nreturn rc;\r\n}\r\nstatic long gntdev_ioctl(struct file *flip,\r\nunsigned int cmd, unsigned long arg)\r\n{\r\nstruct gntdev_priv *priv = flip->private_data;\r\nvoid __user *ptr = (void __user *)arg;\r\nswitch (cmd) {\r\ncase IOCTL_GNTDEV_MAP_GRANT_REF:\r\nreturn gntdev_ioctl_map_grant_ref(priv, ptr);\r\ncase IOCTL_GNTDEV_UNMAP_GRANT_REF:\r\nreturn gntdev_ioctl_unmap_grant_ref(priv, ptr);\r\ncase IOCTL_GNTDEV_GET_OFFSET_FOR_VADDR:\r\nreturn gntdev_ioctl_get_offset_for_vaddr(priv, ptr);\r\ncase IOCTL_GNTDEV_SET_UNMAP_NOTIFY:\r\nreturn gntdev_ioctl_notify(priv, ptr);\r\ndefault:\r\npr_debug("priv %p, unknown cmd %x\n", priv, cmd);\r\nreturn -ENOIOCTLCMD;\r\n}\r\nreturn 0;\r\n}\r\nstatic int gntdev_mmap(struct file *flip, struct vm_area_struct *vma)\r\n{\r\nstruct gntdev_priv *priv = flip->private_data;\r\nint index = vma->vm_pgoff;\r\nint count = (vma->vm_end - vma->vm_start) >> PAGE_SHIFT;\r\nstruct grant_map *map;\r\nint i, err = -EINVAL;\r\nif ((vma->vm_flags & VM_WRITE) && !(vma->vm_flags & VM_SHARED))\r\nreturn -EINVAL;\r\npr_debug("map %d+%d at %lx (pgoff %lx)\n",\r\nindex, count, vma->vm_start, vma->vm_pgoff);\r\nspin_lock(&priv->lock);\r\nmap = gntdev_find_map_index(priv, index, count);\r\nif (!map)\r\ngoto unlock_out;\r\nif (use_ptemod && map->vma)\r\ngoto unlock_out;\r\nif (use_ptemod && priv->mm != vma->vm_mm) {\r\nprintk(KERN_WARNING "Huh? Other mm?\n");\r\ngoto unlock_out;\r\n}\r\natomic_inc(&map->users);\r\nvma->vm_ops = &gntdev_vmops;\r\nvma->vm_flags |= VM_DONTEXPAND | VM_DONTDUMP;\r\nif (use_ptemod)\r\nvma->vm_flags |= VM_DONTCOPY;\r\nvma->vm_private_data = map;\r\nif (use_ptemod)\r\nmap->vma = vma;\r\nif (map->flags) {\r\nif ((vma->vm_flags & VM_WRITE) &&\r\n(map->flags & GNTMAP_readonly))\r\ngoto out_unlock_put;\r\n} else {\r\nmap->flags = GNTMAP_host_map;\r\nif (!(vma->vm_flags & VM_WRITE))\r\nmap->flags |= GNTMAP_readonly;\r\n}\r\nspin_unlock(&priv->lock);\r\nif (use_ptemod) {\r\nerr = apply_to_page_range(vma->vm_mm, vma->vm_start,\r\nvma->vm_end - vma->vm_start,\r\nfind_grant_ptes, map);\r\nif (err) {\r\nprintk(KERN_WARNING "find_grant_ptes() failure.\n");\r\ngoto out_put_map;\r\n}\r\n}\r\nerr = map_grant_pages(map);\r\nif (err)\r\ngoto out_put_map;\r\nif (!use_ptemod) {\r\nfor (i = 0; i < count; i++) {\r\nerr = vm_insert_page(vma, vma->vm_start + i*PAGE_SIZE,\r\nmap->pages[i]);\r\nif (err)\r\ngoto out_put_map;\r\n}\r\n}\r\nreturn 0;\r\nunlock_out:\r\nspin_unlock(&priv->lock);\r\nreturn err;\r\nout_unlock_put:\r\nspin_unlock(&priv->lock);\r\nout_put_map:\r\nif (use_ptemod)\r\nmap->vma = NULL;\r\ngntdev_put_map(priv, map);\r\nreturn err;\r\n}\r\nstatic int __init gntdev_init(void)\r\n{\r\nint err;\r\nif (!xen_domain())\r\nreturn -ENODEV;\r\nuse_ptemod = xen_pv_domain();\r\nerr = misc_register(&gntdev_miscdev);\r\nif (err != 0) {\r\nprintk(KERN_ERR "Could not register gntdev device\n");\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic void __exit gntdev_exit(void)\r\n{\r\nmisc_deregister(&gntdev_miscdev);\r\n}
