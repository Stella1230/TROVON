static int\r\nnv40_mem_timing_calc(struct drm_device *dev, u32 freq,\r\nstruct nouveau_pm_tbl_entry *e, u8 len,\r\nstruct nouveau_pm_memtiming *boot,\r\nstruct nouveau_pm_memtiming *t)\r\n{\r\nstruct nouveau_drm *drm = nouveau_drm(dev);\r\nt->reg[0] = (e->tRP << 24 | e->tRAS << 16 | e->tRFC << 8 | e->tRC);\r\nt->reg[1] = (e->tWR + 2 + (t->tCWL - 1)) << 24 |\r\n1 << 16 |\r\n(e->tWTR + 2 + (t->tCWL - 1)) << 8 |\r\n(e->tCL + 2 - (t->tCWL - 1));\r\nt->reg[2] = 0x20200000 |\r\n((t->tCWL - 1) << 24 |\r\ne->tRRD << 16 |\r\ne->tRCDWR << 8 |\r\ne->tRCDRD);\r\nNV_DEBUG(drm, "Entry %d: 220: %08x %08x %08x\n", t->id,\r\nt->reg[0], t->reg[1], t->reg[2]);\r\nreturn 0;\r\n}\r\nstatic int\r\nnv50_mem_timing_calc(struct drm_device *dev, u32 freq,\r\nstruct nouveau_pm_tbl_entry *e, u8 len,\r\nstruct nouveau_pm_memtiming *boot,\r\nstruct nouveau_pm_memtiming *t)\r\n{\r\nstruct nouveau_device *device = nouveau_dev(dev);\r\nstruct nouveau_fb *pfb = nouveau_fb(device);\r\nstruct nouveau_drm *drm = nouveau_drm(dev);\r\nstruct bit_entry P;\r\nuint8_t unk18 = 1, unk20 = 0, unk21 = 0, tmp7_3;\r\nif (bit_table(dev, 'P', &P))\r\nreturn -EINVAL;\r\nswitch (min(len, (u8) 22)) {\r\ncase 22:\r\nunk21 = e->tUNK_21;\r\ncase 21:\r\nunk20 = e->tUNK_20;\r\ncase 20:\r\nif (e->tCWL > 0)\r\nt->tCWL = e->tCWL;\r\ncase 19:\r\nunk18 = e->tUNK_18;\r\nbreak;\r\n}\r\nt->reg[0] = (e->tRP << 24 | e->tRAS << 16 | e->tRFC << 8 | e->tRC);\r\nt->reg[1] = (e->tWR + 2 + (t->tCWL - 1)) << 24 |\r\nmax(unk18, (u8) 1) << 16 |\r\n(e->tWTR + 2 + (t->tCWL - 1)) << 8;\r\nt->reg[2] = ((t->tCWL - 1) << 24 |\r\ne->tRRD << 16 |\r\ne->tRCDWR << 8 |\r\ne->tRCDRD);\r\nt->reg[4] = e->tUNK_13 << 8 | e->tUNK_13;\r\nt->reg[5] = (e->tRFC << 24 | max(e->tRCDRD, e->tRCDWR) << 16 | e->tRP);\r\nt->reg[8] = boot->reg[8] & 0xffffff00;\r\nif (P.version == 1) {\r\nt->reg[1] |= (e->tCL + 2 - (t->tCWL - 1));\r\nt->reg[3] = (0x14 + e->tCL) << 24 |\r\n0x16 << 16 |\r\n(e->tCL - 1) << 8 |\r\n(e->tCL - 1);\r\nt->reg[4] |= boot->reg[4] & 0xffff0000;\r\nt->reg[6] = (0x33 - t->tCWL) << 16 |\r\nt->tCWL << 8 |\r\n(0x2e + e->tCL - t->tCWL);\r\nt->reg[7] = 0x4000202 | (e->tCL - 1) << 16;\r\nif (pfb->ram.type == NV_MEM_TYPE_DDR2) {\r\nt->reg[5] |= (e->tCL + 3) << 8;\r\nt->reg[6] |= (t->tCWL - 2) << 8;\r\nt->reg[8] |= (e->tCL - 4);\r\n} else {\r\nt->reg[5] |= (e->tCL + 2) << 8;\r\nt->reg[6] |= t->tCWL << 8;\r\nt->reg[8] |= (e->tCL - 2);\r\n}\r\n} else {\r\nt->reg[1] |= (5 + e->tCL - (t->tCWL));\r\nt->reg[3] = (0x30 + e->tCL) << 24 |\r\n(boot->reg[3] & 0x00ff0000)|\r\n(0xb + e->tCL) << 8 |\r\n(e->tCL - 1);\r\nt->reg[4] |= (unk20 << 24 | unk21 << 16);\r\nt->reg[5] |= (t->tCWL + 6) << 8;\r\nt->reg[6] = (0x5a + e->tCL) << 16 |\r\n(6 - e->tCL + t->tCWL) << 8 |\r\n(0x50 + e->tCL - t->tCWL);\r\ntmp7_3 = (boot->reg[7] & 0xff000000) >> 24;\r\nt->reg[7] = (tmp7_3 << 24) |\r\n((tmp7_3 - 6 + e->tCL) << 16) |\r\n0x202;\r\n}\r\nNV_DEBUG(drm, "Entry %d: 220: %08x %08x %08x %08x\n", t->id,\r\nt->reg[0], t->reg[1], t->reg[2], t->reg[3]);\r\nNV_DEBUG(drm, " 230: %08x %08x %08x %08x\n",\r\nt->reg[4], t->reg[5], t->reg[6], t->reg[7]);\r\nNV_DEBUG(drm, " 240: %08x\n", t->reg[8]);\r\nreturn 0;\r\n}\r\nstatic int\r\nnvc0_mem_timing_calc(struct drm_device *dev, u32 freq,\r\nstruct nouveau_pm_tbl_entry *e, u8 len,\r\nstruct nouveau_pm_memtiming *boot,\r\nstruct nouveau_pm_memtiming *t)\r\n{\r\nstruct nouveau_drm *drm = nouveau_drm(dev);\r\nif (e->tCWL > 0)\r\nt->tCWL = e->tCWL;\r\nt->reg[0] = (e->tRP << 24 | (e->tRAS & 0x7f) << 17 |\r\ne->tRFC << 8 | e->tRC);\r\nt->reg[1] = (boot->reg[1] & 0xff000000) |\r\n(e->tRCDWR & 0x0f) << 20 |\r\n(e->tRCDRD & 0x0f) << 14 |\r\n(t->tCWL << 7) |\r\n(e->tCL & 0x0f);\r\nt->reg[2] = (boot->reg[2] & 0xff0000ff) |\r\ne->tWR << 16 | e->tWTR << 8;\r\nt->reg[3] = (e->tUNK_20 & 0x1f) << 9 |\r\n(e->tUNK_21 & 0xf) << 5 |\r\n(e->tUNK_13 & 0x1f);\r\nt->reg[4] = (boot->reg[4] & 0xfff00fff) |\r\n(e->tRRD&0x1f) << 15;\r\nNV_DEBUG(drm, "Entry %d: 290: %08x %08x %08x %08x\n", t->id,\r\nt->reg[0], t->reg[1], t->reg[2], t->reg[3]);\r\nNV_DEBUG(drm, " 2a0: %08x\n", t->reg[4]);\r\nreturn 0;\r\n}\r\nstatic int\r\nnouveau_mem_ddr2_mr(struct drm_device *dev, u32 freq,\r\nstruct nouveau_pm_tbl_entry *e, u8 len,\r\nstruct nouveau_pm_memtiming *boot,\r\nstruct nouveau_pm_memtiming *t)\r\n{\r\nstruct nouveau_drm *drm = nouveau_drm(dev);\r\nt->drive_strength = 0;\r\nif (len < 15) {\r\nt->odt = boot->odt;\r\n} else {\r\nt->odt = e->RAM_FT1 & 0x07;\r\n}\r\nif (e->tCL >= NV_MEM_CL_DDR2_MAX) {\r\nNV_WARN(drm, "(%u) Invalid tCL: %u", t->id, e->tCL);\r\nreturn -ERANGE;\r\n}\r\nif (e->tWR >= NV_MEM_WR_DDR2_MAX) {\r\nNV_WARN(drm, "(%u) Invalid tWR: %u", t->id, e->tWR);\r\nreturn -ERANGE;\r\n}\r\nif (t->odt > 3) {\r\nNV_WARN(drm, "(%u) Invalid odt value, assuming disabled: %x",\r\nt->id, t->odt);\r\nt->odt = 0;\r\n}\r\nt->mr[0] = (boot->mr[0] & 0x100f) |\r\n(e->tCL) << 4 |\r\n(e->tWR - 1) << 9;\r\nt->mr[1] = (boot->mr[1] & 0x101fbb) |\r\n(t->odt & 0x1) << 2 |\r\n(t->odt & 0x2) << 5;\r\nNV_DEBUG(drm, "(%u) MR: %08x", t->id, t->mr[0]);\r\nreturn 0;\r\n}\r\nstatic int\r\nnouveau_mem_ddr3_mr(struct drm_device *dev, u32 freq,\r\nstruct nouveau_pm_tbl_entry *e, u8 len,\r\nstruct nouveau_pm_memtiming *boot,\r\nstruct nouveau_pm_memtiming *t)\r\n{\r\nstruct nouveau_drm *drm = nouveau_drm(dev);\r\nu8 cl = e->tCL - 4;\r\nt->drive_strength = 0;\r\nif (len < 15) {\r\nt->odt = boot->odt;\r\n} else {\r\nt->odt = e->RAM_FT1 & 0x07;\r\n}\r\nif (e->tCL >= NV_MEM_CL_DDR3_MAX || e->tCL < 4) {\r\nNV_WARN(drm, "(%u) Invalid tCL: %u", t->id, e->tCL);\r\nreturn -ERANGE;\r\n}\r\nif (e->tWR >= NV_MEM_WR_DDR3_MAX || e->tWR < 4) {\r\nNV_WARN(drm, "(%u) Invalid tWR: %u", t->id, e->tWR);\r\nreturn -ERANGE;\r\n}\r\nif (e->tCWL < 5) {\r\nNV_WARN(drm, "(%u) Invalid tCWL: %u", t->id, e->tCWL);\r\nreturn -ERANGE;\r\n}\r\nt->mr[0] = (boot->mr[0] & 0x180b) |\r\n(cl & 0x7) << 4 |\r\n(cl & 0x8) >> 1 |\r\n(nv_mem_wr_lut_ddr3[e->tWR]) << 9;\r\nt->mr[1] = (boot->mr[1] & 0x101dbb) |\r\n(t->odt & 0x1) << 2 |\r\n(t->odt & 0x2) << 5 |\r\n(t->odt & 0x4) << 7;\r\nt->mr[2] = (boot->mr[2] & 0x20ffb7) | (e->tCWL - 5) << 3;\r\nNV_DEBUG(drm, "(%u) MR: %08x %08x", t->id, t->mr[0], t->mr[2]);\r\nreturn 0;\r\n}\r\nstatic int\r\nnouveau_mem_gddr3_mr(struct drm_device *dev, u32 freq,\r\nstruct nouveau_pm_tbl_entry *e, u8 len,\r\nstruct nouveau_pm_memtiming *boot,\r\nstruct nouveau_pm_memtiming *t)\r\n{\r\nstruct nouveau_drm *drm = nouveau_drm(dev);\r\nif (len < 15) {\r\nt->drive_strength = boot->drive_strength;\r\nt->odt = boot->odt;\r\n} else {\r\nt->drive_strength = (e->RAM_FT1 & 0x30) >> 4;\r\nt->odt = e->RAM_FT1 & 0x07;\r\n}\r\nif (e->tCL >= NV_MEM_CL_GDDR3_MAX) {\r\nNV_WARN(drm, "(%u) Invalid tCL: %u", t->id, e->tCL);\r\nreturn -ERANGE;\r\n}\r\nif (e->tWR >= NV_MEM_WR_GDDR3_MAX) {\r\nNV_WARN(drm, "(%u) Invalid tWR: %u", t->id, e->tWR);\r\nreturn -ERANGE;\r\n}\r\nif (t->odt > 3) {\r\nNV_WARN(drm, "(%u) Invalid odt value, assuming autocal: %x",\r\nt->id, t->odt);\r\nt->odt = 0;\r\n}\r\nt->mr[0] = (boot->mr[0] & 0xe0b) |\r\n((nv_mem_cl_lut_gddr3[e->tCL] & 0x7) << 4) |\r\n((nv_mem_cl_lut_gddr3[e->tCL] & 0x8) >> 2);\r\nt->mr[1] = (boot->mr[1] & 0x100f40) | t->drive_strength |\r\n(t->odt << 2) |\r\n(nv_mem_wr_lut_gddr3[e->tWR] & 0xf) << 4;\r\nt->mr[2] = boot->mr[2];\r\nNV_DEBUG(drm, "(%u) MR: %08x %08x %08x", t->id,\r\nt->mr[0], t->mr[1], t->mr[2]);\r\nreturn 0;\r\n}\r\nstatic int\r\nnouveau_mem_gddr5_mr(struct drm_device *dev, u32 freq,\r\nstruct nouveau_pm_tbl_entry *e, u8 len,\r\nstruct nouveau_pm_memtiming *boot,\r\nstruct nouveau_pm_memtiming *t)\r\n{\r\nstruct nouveau_drm *drm = nouveau_drm(dev);\r\nif (len < 15) {\r\nt->drive_strength = boot->drive_strength;\r\nt->odt = boot->odt;\r\n} else {\r\nt->drive_strength = (e->RAM_FT1 & 0x30) >> 4;\r\nt->odt = e->RAM_FT1 & 0x03;\r\n}\r\nif (e->tCL >= NV_MEM_CL_GDDR5_MAX) {\r\nNV_WARN(drm, "(%u) Invalid tCL: %u", t->id, e->tCL);\r\nreturn -ERANGE;\r\n}\r\nif (e->tWR >= NV_MEM_WR_GDDR5_MAX) {\r\nNV_WARN(drm, "(%u) Invalid tWR: %u", t->id, e->tWR);\r\nreturn -ERANGE;\r\n}\r\nif (t->odt > 3) {\r\nNV_WARN(drm, "(%u) Invalid odt value, assuming autocal: %x",\r\nt->id, t->odt);\r\nt->odt = 0;\r\n}\r\nt->mr[0] = (boot->mr[0] & 0x007) |\r\n((e->tCL - 5) << 3) |\r\n((e->tWR - 4) << 8);\r\nt->mr[1] = (boot->mr[1] & 0x1007f0) |\r\nt->drive_strength |\r\n(t->odt << 2);\r\nNV_DEBUG(drm, "(%u) MR: %08x %08x", t->id, t->mr[0], t->mr[1]);\r\nreturn 0;\r\n}\r\nint\r\nnouveau_mem_timing_calc(struct drm_device *dev, u32 freq,\r\nstruct nouveau_pm_memtiming *t)\r\n{\r\nstruct nouveau_device *device = nouveau_dev(dev);\r\nstruct nouveau_fb *pfb = nouveau_fb(device);\r\nstruct nouveau_pm *pm = nouveau_pm(dev);\r\nstruct nouveau_pm_memtiming *boot = &pm->boot.timing;\r\nstruct nouveau_pm_tbl_entry *e;\r\nu8 ver, len, *ptr, *ramcfg;\r\nint ret;\r\nptr = nouveau_perf_timing(dev, freq, &ver, &len);\r\nif (!ptr || ptr[0] == 0x00) {\r\n*t = *boot;\r\nreturn 0;\r\n}\r\ne = (struct nouveau_pm_tbl_entry *)ptr;\r\nt->tCWL = boot->tCWL;\r\nswitch (device->card_type) {\r\ncase NV_40:\r\nret = nv40_mem_timing_calc(dev, freq, e, len, boot, t);\r\nbreak;\r\ncase NV_50:\r\nret = nv50_mem_timing_calc(dev, freq, e, len, boot, t);\r\nbreak;\r\ncase NV_C0:\r\ncase NV_D0:\r\nret = nvc0_mem_timing_calc(dev, freq, e, len, boot, t);\r\nbreak;\r\ndefault:\r\nret = -ENODEV;\r\nbreak;\r\n}\r\nswitch (pfb->ram.type * !ret) {\r\ncase NV_MEM_TYPE_GDDR3:\r\nret = nouveau_mem_gddr3_mr(dev, freq, e, len, boot, t);\r\nbreak;\r\ncase NV_MEM_TYPE_GDDR5:\r\nret = nouveau_mem_gddr5_mr(dev, freq, e, len, boot, t);\r\nbreak;\r\ncase NV_MEM_TYPE_DDR2:\r\nret = nouveau_mem_ddr2_mr(dev, freq, e, len, boot, t);\r\nbreak;\r\ncase NV_MEM_TYPE_DDR3:\r\nret = nouveau_mem_ddr3_mr(dev, freq, e, len, boot, t);\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nramcfg = nouveau_perf_ramcfg(dev, freq, &ver, &len);\r\nif (ramcfg) {\r\nint dll_off;\r\nif (ver == 0x00)\r\ndll_off = !!(ramcfg[3] & 0x04);\r\nelse\r\ndll_off = !!(ramcfg[2] & 0x40);\r\nswitch (pfb->ram.type) {\r\ncase NV_MEM_TYPE_GDDR3:\r\nt->mr[1] &= ~0x00000040;\r\nt->mr[1] |= 0x00000040 * dll_off;\r\nbreak;\r\ndefault:\r\nt->mr[1] &= ~0x00000001;\r\nt->mr[1] |= 0x00000001 * dll_off;\r\nbreak;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nvoid\r\nnouveau_mem_timing_read(struct drm_device *dev, struct nouveau_pm_memtiming *t)\r\n{\r\nstruct nouveau_device *device = nouveau_dev(dev);\r\nstruct nouveau_fb *pfb = nouveau_fb(device);\r\nu32 timing_base, timing_regs, mr_base;\r\nint i;\r\nif (device->card_type >= 0xC0) {\r\ntiming_base = 0x10f290;\r\nmr_base = 0x10f300;\r\n} else {\r\ntiming_base = 0x100220;\r\nmr_base = 0x1002c0;\r\n}\r\nt->id = -1;\r\nswitch (device->card_type) {\r\ncase NV_50:\r\ntiming_regs = 9;\r\nbreak;\r\ncase NV_C0:\r\ncase NV_D0:\r\ntiming_regs = 5;\r\nbreak;\r\ncase NV_30:\r\ncase NV_40:\r\ntiming_regs = 3;\r\nbreak;\r\ndefault:\r\ntiming_regs = 0;\r\nreturn;\r\n}\r\nfor(i = 0; i < timing_regs; i++)\r\nt->reg[i] = nv_rd32(device, timing_base + (0x04 * i));\r\nt->tCWL = 0;\r\nif (device->card_type < NV_C0) {\r\nt->tCWL = ((nv_rd32(device, 0x100228) & 0x0f000000) >> 24) + 1;\r\n} else if (device->card_type <= NV_D0) {\r\nt->tCWL = ((nv_rd32(device, 0x10f294) & 0x00000f80) >> 7);\r\n}\r\nt->mr[0] = nv_rd32(device, mr_base);\r\nt->mr[1] = nv_rd32(device, mr_base + 0x04);\r\nt->mr[2] = nv_rd32(device, mr_base + 0x20);\r\nt->mr[3] = nv_rd32(device, mr_base + 0x24);\r\nt->odt = 0;\r\nt->drive_strength = 0;\r\nswitch (pfb->ram.type) {\r\ncase NV_MEM_TYPE_DDR3:\r\nt->odt |= (t->mr[1] & 0x200) >> 7;\r\ncase NV_MEM_TYPE_DDR2:\r\nt->odt |= (t->mr[1] & 0x04) >> 2 |\r\n(t->mr[1] & 0x40) >> 5;\r\nbreak;\r\ncase NV_MEM_TYPE_GDDR3:\r\ncase NV_MEM_TYPE_GDDR5:\r\nt->drive_strength = t->mr[1] & 0x03;\r\nt->odt = (t->mr[1] & 0x0c) >> 2;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nint\r\nnouveau_mem_exec(struct nouveau_mem_exec_func *exec,\r\nstruct nouveau_pm_level *perflvl)\r\n{\r\nstruct nouveau_drm *drm = nouveau_drm(exec->dev);\r\nstruct nouveau_device *device = nouveau_dev(exec->dev);\r\nstruct nouveau_fb *pfb = nouveau_fb(device);\r\nstruct nouveau_pm_memtiming *info = &perflvl->timing;\r\nu32 tMRD = 1000, tCKSRE = 0, tCKSRX = 0, tXS = 0, tDLLK = 0;\r\nu32 mr[3] = { info->mr[0], info->mr[1], info->mr[2] };\r\nu32 mr1_dlloff;\r\nswitch (pfb->ram.type) {\r\ncase NV_MEM_TYPE_DDR2:\r\ntDLLK = 2000;\r\nmr1_dlloff = 0x00000001;\r\nbreak;\r\ncase NV_MEM_TYPE_DDR3:\r\ntDLLK = 12000;\r\ntCKSRE = 2000;\r\ntXS = 1000;\r\nmr1_dlloff = 0x00000001;\r\nbreak;\r\ncase NV_MEM_TYPE_GDDR3:\r\ntDLLK = 40000;\r\nmr1_dlloff = 0x00000040;\r\nbreak;\r\ndefault:\r\nNV_ERROR(drm, "cannot reclock unsupported memtype\n");\r\nreturn -ENODEV;\r\n}\r\nswitch (pfb->ram.type) {\r\ncase NV_MEM_TYPE_GDDR3:\r\ncase NV_MEM_TYPE_DDR3:\r\nmr[2] = exec->mrg(exec, 2);\r\ndefault:\r\nmr[1] = exec->mrg(exec, 1);\r\nmr[0] = exec->mrg(exec, 0);\r\nbreak;\r\n}\r\nif (!(mr[1] & mr1_dlloff) && (info->mr[1] & mr1_dlloff)) {\r\nexec->precharge(exec);\r\nexec->mrs (exec, 1, mr[1] | mr1_dlloff);\r\nexec->wait(exec, tMRD);\r\n}\r\nexec->precharge(exec);\r\nexec->refresh(exec);\r\nexec->refresh(exec);\r\nexec->refresh_auto(exec, false);\r\nexec->refresh_self(exec, true);\r\nexec->wait(exec, tCKSRE);\r\nexec->clock_set(exec);\r\nexec->wait(exec, tCKSRX);\r\nexec->precharge(exec);\r\nexec->refresh_self(exec, false);\r\nexec->refresh_auto(exec, true);\r\nexec->wait(exec, tXS);\r\nexec->wait(exec, tXS);\r\nif (mr[2] != info->mr[2]) {\r\nexec->mrs (exec, 2, info->mr[2]);\r\nexec->wait(exec, tMRD);\r\n}\r\nif (mr[1] != info->mr[1]) {\r\nexec->mrs (exec, 1, info->mr[1] | (mr[1] & mr1_dlloff));\r\nexec->wait(exec, tMRD);\r\n}\r\nif (mr[0] != info->mr[0]) {\r\nexec->mrs (exec, 0, info->mr[0]);\r\nexec->wait(exec, tMRD);\r\n}\r\nexec->timing_set(exec);\r\nif (!(info->mr[1] & mr1_dlloff)) {\r\nif (mr[1] & mr1_dlloff) {\r\nexec->mrs (exec, 1, info->mr[1]);\r\nexec->wait(exec, tMRD);\r\n}\r\nexec->mrs (exec, 0, info->mr[0] | 0x00000100);\r\nexec->wait(exec, tMRD);\r\nexec->mrs (exec, 0, info->mr[0] | 0x00000000);\r\nexec->wait(exec, tMRD);\r\nexec->wait(exec, tDLLK);\r\nif (pfb->ram.type == NV_MEM_TYPE_GDDR3)\r\nexec->precharge(exec);\r\n}\r\nreturn 0;\r\n}
