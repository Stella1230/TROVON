static inline u8 snd_ymfpci_readb(struct snd_ymfpci *chip, u32 offset)\r\n{\r\nreturn readb(chip->reg_area_virt + offset);\r\n}\r\nstatic inline void snd_ymfpci_writeb(struct snd_ymfpci *chip, u32 offset, u8 val)\r\n{\r\nwriteb(val, chip->reg_area_virt + offset);\r\n}\r\nstatic inline u16 snd_ymfpci_readw(struct snd_ymfpci *chip, u32 offset)\r\n{\r\nreturn readw(chip->reg_area_virt + offset);\r\n}\r\nstatic inline void snd_ymfpci_writew(struct snd_ymfpci *chip, u32 offset, u16 val)\r\n{\r\nwritew(val, chip->reg_area_virt + offset);\r\n}\r\nstatic inline u32 snd_ymfpci_readl(struct snd_ymfpci *chip, u32 offset)\r\n{\r\nreturn readl(chip->reg_area_virt + offset);\r\n}\r\nstatic inline void snd_ymfpci_writel(struct snd_ymfpci *chip, u32 offset, u32 val)\r\n{\r\nwritel(val, chip->reg_area_virt + offset);\r\n}\r\nstatic int snd_ymfpci_codec_ready(struct snd_ymfpci *chip, int secondary)\r\n{\r\nunsigned long end_time;\r\nu32 reg = secondary ? YDSXGR_SECSTATUSADR : YDSXGR_PRISTATUSADR;\r\nend_time = jiffies + msecs_to_jiffies(750);\r\ndo {\r\nif ((snd_ymfpci_readw(chip, reg) & 0x8000) == 0)\r\nreturn 0;\r\nschedule_timeout_uninterruptible(1);\r\n} while (time_before(jiffies, end_time));\r\nsnd_printk(KERN_ERR "codec_ready: codec %i is not ready [0x%x]\n", secondary, snd_ymfpci_readw(chip, reg));\r\nreturn -EBUSY;\r\n}\r\nstatic void snd_ymfpci_codec_write(struct snd_ac97 *ac97, u16 reg, u16 val)\r\n{\r\nstruct snd_ymfpci *chip = ac97->private_data;\r\nu32 cmd;\r\nsnd_ymfpci_codec_ready(chip, 0);\r\ncmd = ((YDSXG_AC97WRITECMD | reg) << 16) | val;\r\nsnd_ymfpci_writel(chip, YDSXGR_AC97CMDDATA, cmd);\r\n}\r\nstatic u16 snd_ymfpci_codec_read(struct snd_ac97 *ac97, u16 reg)\r\n{\r\nstruct snd_ymfpci *chip = ac97->private_data;\r\nif (snd_ymfpci_codec_ready(chip, 0))\r\nreturn ~0;\r\nsnd_ymfpci_writew(chip, YDSXGR_AC97CMDADR, YDSXG_AC97READCMD | reg);\r\nif (snd_ymfpci_codec_ready(chip, 0))\r\nreturn ~0;\r\nif (chip->device_id == PCI_DEVICE_ID_YAMAHA_744 && chip->rev < 2) {\r\nint i;\r\nfor (i = 0; i < 600; i++)\r\nsnd_ymfpci_readw(chip, YDSXGR_PRISTATUSDATA);\r\n}\r\nreturn snd_ymfpci_readw(chip, YDSXGR_PRISTATUSDATA);\r\n}\r\nstatic u32 snd_ymfpci_calc_delta(u32 rate)\r\n{\r\nswitch (rate) {\r\ncase 8000: return 0x02aaab00;\r\ncase 11025: return 0x03accd00;\r\ncase 16000: return 0x05555500;\r\ncase 22050: return 0x07599a00;\r\ncase 32000: return 0x0aaaab00;\r\ncase 44100: return 0x0eb33300;\r\ndefault: return ((rate << 16) / 375) << 5;\r\n}\r\n}\r\nstatic u32 snd_ymfpci_calc_lpfK(u32 rate)\r\n{\r\nu32 i;\r\nstatic u32 val[8] = {\r\n0x00570000, 0x06AA0000, 0x18B20000, 0x20930000,\r\n0x2B9A0000, 0x35A10000, 0x3EAA0000, 0x40000000\r\n};\r\nif (rate == 44100)\r\nreturn 0x40000000;\r\nfor (i = 0; i < 8; i++)\r\nif (rate <= def_rate[i])\r\nreturn val[i];\r\nreturn val[0];\r\n}\r\nstatic u32 snd_ymfpci_calc_lpfQ(u32 rate)\r\n{\r\nu32 i;\r\nstatic u32 val[8] = {\r\n0x35280000, 0x34A70000, 0x32020000, 0x31770000,\r\n0x31390000, 0x31C90000, 0x33D00000, 0x40000000\r\n};\r\nif (rate == 44100)\r\nreturn 0x370A0000;\r\nfor (i = 0; i < 8; i++)\r\nif (rate <= def_rate[i])\r\nreturn val[i];\r\nreturn val[0];\r\n}\r\nstatic void snd_ymfpci_hw_start(struct snd_ymfpci *chip)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&chip->reg_lock, flags);\r\nif (chip->start_count++ > 0)\r\ngoto __end;\r\nsnd_ymfpci_writel(chip, YDSXGR_MODE,\r\nsnd_ymfpci_readl(chip, YDSXGR_MODE) | 3);\r\nchip->active_bank = snd_ymfpci_readl(chip, YDSXGR_CTRLSELECT) & 1;\r\n__end:\r\nspin_unlock_irqrestore(&chip->reg_lock, flags);\r\n}\r\nstatic void snd_ymfpci_hw_stop(struct snd_ymfpci *chip)\r\n{\r\nunsigned long flags;\r\nlong timeout = 1000;\r\nspin_lock_irqsave(&chip->reg_lock, flags);\r\nif (--chip->start_count > 0)\r\ngoto __end;\r\nsnd_ymfpci_writel(chip, YDSXGR_MODE,\r\nsnd_ymfpci_readl(chip, YDSXGR_MODE) & ~3);\r\nwhile (timeout-- > 0) {\r\nif ((snd_ymfpci_readl(chip, YDSXGR_STATUS) & 2) == 0)\r\nbreak;\r\n}\r\nif (atomic_read(&chip->interrupt_sleep_count)) {\r\natomic_set(&chip->interrupt_sleep_count, 0);\r\nwake_up(&chip->interrupt_sleep);\r\n}\r\n__end:\r\nspin_unlock_irqrestore(&chip->reg_lock, flags);\r\n}\r\nstatic int voice_alloc(struct snd_ymfpci *chip,\r\nenum snd_ymfpci_voice_type type, int pair,\r\nstruct snd_ymfpci_voice **rvoice)\r\n{\r\nstruct snd_ymfpci_voice *voice, *voice2;\r\nint idx;\r\n*rvoice = NULL;\r\nfor (idx = 0; idx < YDSXG_PLAYBACK_VOICES; idx += pair ? 2 : 1) {\r\nvoice = &chip->voices[idx];\r\nvoice2 = pair ? &chip->voices[idx+1] : NULL;\r\nif (voice->use || (voice2 && voice2->use))\r\ncontinue;\r\nvoice->use = 1;\r\nif (voice2)\r\nvoice2->use = 1;\r\nswitch (type) {\r\ncase YMFPCI_PCM:\r\nvoice->pcm = 1;\r\nif (voice2)\r\nvoice2->pcm = 1;\r\nbreak;\r\ncase YMFPCI_SYNTH:\r\nvoice->synth = 1;\r\nbreak;\r\ncase YMFPCI_MIDI:\r\nvoice->midi = 1;\r\nbreak;\r\n}\r\nsnd_ymfpci_hw_start(chip);\r\nif (voice2)\r\nsnd_ymfpci_hw_start(chip);\r\n*rvoice = voice;\r\nreturn 0;\r\n}\r\nreturn -ENOMEM;\r\n}\r\nstatic int snd_ymfpci_voice_alloc(struct snd_ymfpci *chip,\r\nenum snd_ymfpci_voice_type type, int pair,\r\nstruct snd_ymfpci_voice **rvoice)\r\n{\r\nunsigned long flags;\r\nint result;\r\nif (snd_BUG_ON(!rvoice))\r\nreturn -EINVAL;\r\nif (snd_BUG_ON(pair && type != YMFPCI_PCM))\r\nreturn -EINVAL;\r\nspin_lock_irqsave(&chip->voice_lock, flags);\r\nfor (;;) {\r\nresult = voice_alloc(chip, type, pair, rvoice);\r\nif (result == 0 || type != YMFPCI_PCM)\r\nbreak;\r\nbreak;\r\n}\r\nspin_unlock_irqrestore(&chip->voice_lock, flags);\r\nreturn result;\r\n}\r\nstatic int snd_ymfpci_voice_free(struct snd_ymfpci *chip, struct snd_ymfpci_voice *pvoice)\r\n{\r\nunsigned long flags;\r\nif (snd_BUG_ON(!pvoice))\r\nreturn -EINVAL;\r\nsnd_ymfpci_hw_stop(chip);\r\nspin_lock_irqsave(&chip->voice_lock, flags);\r\nif (pvoice->number == chip->src441_used) {\r\nchip->src441_used = -1;\r\npvoice->ypcm->use_441_slot = 0;\r\n}\r\npvoice->use = pvoice->pcm = pvoice->synth = pvoice->midi = 0;\r\npvoice->ypcm = NULL;\r\npvoice->interrupt = NULL;\r\nspin_unlock_irqrestore(&chip->voice_lock, flags);\r\nreturn 0;\r\n}\r\nstatic void snd_ymfpci_pcm_interrupt(struct snd_ymfpci *chip, struct snd_ymfpci_voice *voice)\r\n{\r\nstruct snd_ymfpci_pcm *ypcm;\r\nu32 pos, delta;\r\nif ((ypcm = voice->ypcm) == NULL)\r\nreturn;\r\nif (ypcm->substream == NULL)\r\nreturn;\r\nspin_lock(&chip->reg_lock);\r\nif (ypcm->running) {\r\npos = le32_to_cpu(voice->bank[chip->active_bank].start);\r\nif (pos < ypcm->last_pos)\r\ndelta = pos + (ypcm->buffer_size - ypcm->last_pos);\r\nelse\r\ndelta = pos - ypcm->last_pos;\r\nypcm->period_pos += delta;\r\nypcm->last_pos = pos;\r\nif (ypcm->period_pos >= ypcm->period_size) {\r\nypcm->period_pos %= ypcm->period_size;\r\nspin_unlock(&chip->reg_lock);\r\nsnd_pcm_period_elapsed(ypcm->substream);\r\nspin_lock(&chip->reg_lock);\r\n}\r\nif (unlikely(ypcm->update_pcm_vol)) {\r\nunsigned int subs = ypcm->substream->number;\r\nunsigned int next_bank = 1 - chip->active_bank;\r\nstruct snd_ymfpci_playback_bank *bank;\r\nu32 volume;\r\nbank = &voice->bank[next_bank];\r\nvolume = cpu_to_le32(chip->pcm_mixer[subs].left << 15);\r\nbank->left_gain_end = volume;\r\nif (ypcm->output_rear)\r\nbank->eff2_gain_end = volume;\r\nif (ypcm->voices[1])\r\nbank = &ypcm->voices[1]->bank[next_bank];\r\nvolume = cpu_to_le32(chip->pcm_mixer[subs].right << 15);\r\nbank->right_gain_end = volume;\r\nif (ypcm->output_rear)\r\nbank->eff3_gain_end = volume;\r\nypcm->update_pcm_vol--;\r\n}\r\n}\r\nspin_unlock(&chip->reg_lock);\r\n}\r\nstatic void snd_ymfpci_pcm_capture_interrupt(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct snd_ymfpci_pcm *ypcm = runtime->private_data;\r\nstruct snd_ymfpci *chip = ypcm->chip;\r\nu32 pos, delta;\r\nspin_lock(&chip->reg_lock);\r\nif (ypcm->running) {\r\npos = le32_to_cpu(chip->bank_capture[ypcm->capture_bank_number][chip->active_bank]->start) >> ypcm->shift;\r\nif (pos < ypcm->last_pos)\r\ndelta = pos + (ypcm->buffer_size - ypcm->last_pos);\r\nelse\r\ndelta = pos - ypcm->last_pos;\r\nypcm->period_pos += delta;\r\nypcm->last_pos = pos;\r\nif (ypcm->period_pos >= ypcm->period_size) {\r\nypcm->period_pos %= ypcm->period_size;\r\nspin_unlock(&chip->reg_lock);\r\nsnd_pcm_period_elapsed(substream);\r\nspin_lock(&chip->reg_lock);\r\n}\r\n}\r\nspin_unlock(&chip->reg_lock);\r\n}\r\nstatic int snd_ymfpci_playback_trigger(struct snd_pcm_substream *substream,\r\nint cmd)\r\n{\r\nstruct snd_ymfpci *chip = snd_pcm_substream_chip(substream);\r\nstruct snd_ymfpci_pcm *ypcm = substream->runtime->private_data;\r\nstruct snd_kcontrol *kctl = NULL;\r\nint result = 0;\r\nspin_lock(&chip->reg_lock);\r\nif (ypcm->voices[0] == NULL) {\r\nresult = -EINVAL;\r\ngoto __unlock;\r\n}\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\ncase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\r\ncase SNDRV_PCM_TRIGGER_RESUME:\r\nchip->ctrl_playback[ypcm->voices[0]->number + 1] = cpu_to_le32(ypcm->voices[0]->bank_addr);\r\nif (ypcm->voices[1] != NULL && !ypcm->use_441_slot)\r\nchip->ctrl_playback[ypcm->voices[1]->number + 1] = cpu_to_le32(ypcm->voices[1]->bank_addr);\r\nypcm->running = 1;\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\nif (substream->pcm == chip->pcm && !ypcm->use_441_slot) {\r\nkctl = chip->pcm_mixer[substream->number].ctl;\r\nkctl->vd[0].access |= SNDRV_CTL_ELEM_ACCESS_INACTIVE;\r\n}\r\ncase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\r\ncase SNDRV_PCM_TRIGGER_SUSPEND:\r\nchip->ctrl_playback[ypcm->voices[0]->number + 1] = 0;\r\nif (ypcm->voices[1] != NULL && !ypcm->use_441_slot)\r\nchip->ctrl_playback[ypcm->voices[1]->number + 1] = 0;\r\nypcm->running = 0;\r\nbreak;\r\ndefault:\r\nresult = -EINVAL;\r\nbreak;\r\n}\r\n__unlock:\r\nspin_unlock(&chip->reg_lock);\r\nif (kctl)\r\nsnd_ctl_notify(chip->card, SNDRV_CTL_EVENT_MASK_INFO, &kctl->id);\r\nreturn result;\r\n}\r\nstatic int snd_ymfpci_capture_trigger(struct snd_pcm_substream *substream,\r\nint cmd)\r\n{\r\nstruct snd_ymfpci *chip = snd_pcm_substream_chip(substream);\r\nstruct snd_ymfpci_pcm *ypcm = substream->runtime->private_data;\r\nint result = 0;\r\nu32 tmp;\r\nspin_lock(&chip->reg_lock);\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\ncase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\r\ncase SNDRV_PCM_TRIGGER_RESUME:\r\ntmp = snd_ymfpci_readl(chip, YDSXGR_MAPOFREC) | (1 << ypcm->capture_bank_number);\r\nsnd_ymfpci_writel(chip, YDSXGR_MAPOFREC, tmp);\r\nypcm->running = 1;\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\ncase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\r\ncase SNDRV_PCM_TRIGGER_SUSPEND:\r\ntmp = snd_ymfpci_readl(chip, YDSXGR_MAPOFREC) & ~(1 << ypcm->capture_bank_number);\r\nsnd_ymfpci_writel(chip, YDSXGR_MAPOFREC, tmp);\r\nypcm->running = 0;\r\nbreak;\r\ndefault:\r\nresult = -EINVAL;\r\nbreak;\r\n}\r\nspin_unlock(&chip->reg_lock);\r\nreturn result;\r\n}\r\nstatic int snd_ymfpci_pcm_voice_alloc(struct snd_ymfpci_pcm *ypcm, int voices)\r\n{\r\nint err;\r\nif (ypcm->voices[1] != NULL && voices < 2) {\r\nsnd_ymfpci_voice_free(ypcm->chip, ypcm->voices[1]);\r\nypcm->voices[1] = NULL;\r\n}\r\nif (voices == 1 && ypcm->voices[0] != NULL)\r\nreturn 0;\r\nif (voices == 2 && ypcm->voices[0] != NULL && ypcm->voices[1] != NULL)\r\nreturn 0;\r\nif (voices > 1) {\r\nif (ypcm->voices[0] != NULL && ypcm->voices[1] == NULL) {\r\nsnd_ymfpci_voice_free(ypcm->chip, ypcm->voices[0]);\r\nypcm->voices[0] = NULL;\r\n}\r\n}\r\nerr = snd_ymfpci_voice_alloc(ypcm->chip, YMFPCI_PCM, voices > 1, &ypcm->voices[0]);\r\nif (err < 0)\r\nreturn err;\r\nypcm->voices[0]->ypcm = ypcm;\r\nypcm->voices[0]->interrupt = snd_ymfpci_pcm_interrupt;\r\nif (voices > 1) {\r\nypcm->voices[1] = &ypcm->chip->voices[ypcm->voices[0]->number + 1];\r\nypcm->voices[1]->ypcm = ypcm;\r\n}\r\nreturn 0;\r\n}\r\nstatic void snd_ymfpci_pcm_init_voice(struct snd_ymfpci_pcm *ypcm, unsigned int voiceidx,\r\nstruct snd_pcm_runtime *runtime,\r\nint has_pcm_volume)\r\n{\r\nstruct snd_ymfpci_voice *voice = ypcm->voices[voiceidx];\r\nu32 format;\r\nu32 delta = snd_ymfpci_calc_delta(runtime->rate);\r\nu32 lpfQ = snd_ymfpci_calc_lpfQ(runtime->rate);\r\nu32 lpfK = snd_ymfpci_calc_lpfK(runtime->rate);\r\nstruct snd_ymfpci_playback_bank *bank;\r\nunsigned int nbank;\r\nu32 vol_left, vol_right;\r\nu8 use_left, use_right;\r\nunsigned long flags;\r\nif (snd_BUG_ON(!voice))\r\nreturn;\r\nif (runtime->channels == 1) {\r\nuse_left = 1;\r\nuse_right = 1;\r\n} else {\r\nuse_left = (voiceidx & 1) == 0;\r\nuse_right = !use_left;\r\n}\r\nif (has_pcm_volume) {\r\nvol_left = cpu_to_le32(ypcm->chip->pcm_mixer\r\n[ypcm->substream->number].left << 15);\r\nvol_right = cpu_to_le32(ypcm->chip->pcm_mixer\r\n[ypcm->substream->number].right << 15);\r\n} else {\r\nvol_left = cpu_to_le32(0x40000000);\r\nvol_right = cpu_to_le32(0x40000000);\r\n}\r\nspin_lock_irqsave(&ypcm->chip->voice_lock, flags);\r\nformat = runtime->channels == 2 ? 0x00010000 : 0;\r\nif (snd_pcm_format_width(runtime->format) == 8)\r\nformat |= 0x80000000;\r\nelse if (ypcm->chip->device_id == PCI_DEVICE_ID_YAMAHA_754 &&\r\nruntime->rate == 44100 && runtime->channels == 2 &&\r\nvoiceidx == 0 && (ypcm->chip->src441_used == -1 ||\r\nypcm->chip->src441_used == voice->number)) {\r\nypcm->chip->src441_used = voice->number;\r\nypcm->use_441_slot = 1;\r\nformat |= 0x10000000;\r\n}\r\nif (ypcm->chip->src441_used == voice->number &&\r\n(format & 0x10000000) == 0) {\r\nypcm->chip->src441_used = -1;\r\nypcm->use_441_slot = 0;\r\n}\r\nif (runtime->channels == 2 && (voiceidx & 1) != 0)\r\nformat |= 1;\r\nspin_unlock_irqrestore(&ypcm->chip->voice_lock, flags);\r\nfor (nbank = 0; nbank < 2; nbank++) {\r\nbank = &voice->bank[nbank];\r\nmemset(bank, 0, sizeof(*bank));\r\nbank->format = cpu_to_le32(format);\r\nbank->base = cpu_to_le32(runtime->dma_addr);\r\nbank->loop_end = cpu_to_le32(ypcm->buffer_size);\r\nbank->lpfQ = cpu_to_le32(lpfQ);\r\nbank->delta =\r\nbank->delta_end = cpu_to_le32(delta);\r\nbank->lpfK =\r\nbank->lpfK_end = cpu_to_le32(lpfK);\r\nbank->eg_gain =\r\nbank->eg_gain_end = cpu_to_le32(0x40000000);\r\nif (ypcm->output_front) {\r\nif (use_left) {\r\nbank->left_gain =\r\nbank->left_gain_end = vol_left;\r\n}\r\nif (use_right) {\r\nbank->right_gain =\r\nbank->right_gain_end = vol_right;\r\n}\r\n}\r\nif (ypcm->output_rear) {\r\nif (!ypcm->swap_rear) {\r\nif (use_left) {\r\nbank->eff2_gain =\r\nbank->eff2_gain_end = vol_left;\r\n}\r\nif (use_right) {\r\nbank->eff3_gain =\r\nbank->eff3_gain_end = vol_right;\r\n}\r\n} else {\r\nif (use_left) {\r\nbank->eff3_gain =\r\nbank->eff3_gain_end = vol_left;\r\n}\r\nif (use_right) {\r\nbank->eff2_gain =\r\nbank->eff2_gain_end = vol_right;\r\n}\r\n}\r\n}\r\n}\r\n}\r\nstatic int snd_ymfpci_ac3_init(struct snd_ymfpci *chip)\r\n{\r\nif (snd_dma_alloc_pages(SNDRV_DMA_TYPE_DEV, snd_dma_pci_data(chip->pci),\r\n4096, &chip->ac3_tmp_base) < 0)\r\nreturn -ENOMEM;\r\nchip->bank_effect[3][0]->base =\r\nchip->bank_effect[3][1]->base = cpu_to_le32(chip->ac3_tmp_base.addr);\r\nchip->bank_effect[3][0]->loop_end =\r\nchip->bank_effect[3][1]->loop_end = cpu_to_le32(1024);\r\nchip->bank_effect[4][0]->base =\r\nchip->bank_effect[4][1]->base = cpu_to_le32(chip->ac3_tmp_base.addr + 2048);\r\nchip->bank_effect[4][0]->loop_end =\r\nchip->bank_effect[4][1]->loop_end = cpu_to_le32(1024);\r\nspin_lock_irq(&chip->reg_lock);\r\nsnd_ymfpci_writel(chip, YDSXGR_MAPOFEFFECT,\r\nsnd_ymfpci_readl(chip, YDSXGR_MAPOFEFFECT) | 3 << 3);\r\nspin_unlock_irq(&chip->reg_lock);\r\nreturn 0;\r\n}\r\nstatic int snd_ymfpci_ac3_done(struct snd_ymfpci *chip)\r\n{\r\nspin_lock_irq(&chip->reg_lock);\r\nsnd_ymfpci_writel(chip, YDSXGR_MAPOFEFFECT,\r\nsnd_ymfpci_readl(chip, YDSXGR_MAPOFEFFECT) & ~(3 << 3));\r\nspin_unlock_irq(&chip->reg_lock);\r\nif (chip->ac3_tmp_base.area) {\r\nsnd_dma_free_pages(&chip->ac3_tmp_base);\r\nchip->ac3_tmp_base.area = NULL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_ymfpci_playback_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *hw_params)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct snd_ymfpci_pcm *ypcm = runtime->private_data;\r\nint err;\r\nif ((err = snd_pcm_lib_malloc_pages(substream, params_buffer_bytes(hw_params))) < 0)\r\nreturn err;\r\nif ((err = snd_ymfpci_pcm_voice_alloc(ypcm, params_channels(hw_params))) < 0)\r\nreturn err;\r\nreturn 0;\r\n}\r\nstatic int snd_ymfpci_playback_hw_free(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_ymfpci *chip = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct snd_ymfpci_pcm *ypcm;\r\nif (runtime->private_data == NULL)\r\nreturn 0;\r\nypcm = runtime->private_data;\r\nsnd_ymfpci_irq_wait(chip);\r\nsnd_pcm_lib_free_pages(substream);\r\nif (ypcm->voices[1]) {\r\nsnd_ymfpci_voice_free(chip, ypcm->voices[1]);\r\nypcm->voices[1] = NULL;\r\n}\r\nif (ypcm->voices[0]) {\r\nsnd_ymfpci_voice_free(chip, ypcm->voices[0]);\r\nypcm->voices[0] = NULL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_ymfpci_playback_prepare(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_ymfpci *chip = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct snd_ymfpci_pcm *ypcm = runtime->private_data;\r\nstruct snd_kcontrol *kctl;\r\nunsigned int nvoice;\r\nypcm->period_size = runtime->period_size;\r\nypcm->buffer_size = runtime->buffer_size;\r\nypcm->period_pos = 0;\r\nypcm->last_pos = 0;\r\nfor (nvoice = 0; nvoice < runtime->channels; nvoice++)\r\nsnd_ymfpci_pcm_init_voice(ypcm, nvoice, runtime,\r\nsubstream->pcm == chip->pcm);\r\nif (substream->pcm == chip->pcm && !ypcm->use_441_slot) {\r\nkctl = chip->pcm_mixer[substream->number].ctl;\r\nkctl->vd[0].access &= ~SNDRV_CTL_ELEM_ACCESS_INACTIVE;\r\nsnd_ctl_notify(chip->card, SNDRV_CTL_EVENT_MASK_INFO, &kctl->id);\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_ymfpci_capture_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *hw_params)\r\n{\r\nreturn snd_pcm_lib_malloc_pages(substream, params_buffer_bytes(hw_params));\r\n}\r\nstatic int snd_ymfpci_capture_hw_free(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_ymfpci *chip = snd_pcm_substream_chip(substream);\r\nsnd_ymfpci_irq_wait(chip);\r\nreturn snd_pcm_lib_free_pages(substream);\r\n}\r\nstatic int snd_ymfpci_capture_prepare(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_ymfpci *chip = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct snd_ymfpci_pcm *ypcm = runtime->private_data;\r\nstruct snd_ymfpci_capture_bank * bank;\r\nint nbank;\r\nu32 rate, format;\r\nypcm->period_size = runtime->period_size;\r\nypcm->buffer_size = runtime->buffer_size;\r\nypcm->period_pos = 0;\r\nypcm->last_pos = 0;\r\nypcm->shift = 0;\r\nrate = ((48000 * 4096) / runtime->rate) - 1;\r\nformat = 0;\r\nif (runtime->channels == 2) {\r\nformat |= 2;\r\nypcm->shift++;\r\n}\r\nif (snd_pcm_format_width(runtime->format) == 8)\r\nformat |= 1;\r\nelse\r\nypcm->shift++;\r\nswitch (ypcm->capture_bank_number) {\r\ncase 0:\r\nsnd_ymfpci_writel(chip, YDSXGR_RECFORMAT, format);\r\nsnd_ymfpci_writel(chip, YDSXGR_RECSLOTSR, rate);\r\nbreak;\r\ncase 1:\r\nsnd_ymfpci_writel(chip, YDSXGR_ADCFORMAT, format);\r\nsnd_ymfpci_writel(chip, YDSXGR_ADCSLOTSR, rate);\r\nbreak;\r\n}\r\nfor (nbank = 0; nbank < 2; nbank++) {\r\nbank = chip->bank_capture[ypcm->capture_bank_number][nbank];\r\nbank->base = cpu_to_le32(runtime->dma_addr);\r\nbank->loop_end = cpu_to_le32(ypcm->buffer_size << ypcm->shift);\r\nbank->start = 0;\r\nbank->num_of_loops = 0;\r\n}\r\nreturn 0;\r\n}\r\nstatic snd_pcm_uframes_t snd_ymfpci_playback_pointer(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_ymfpci *chip = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct snd_ymfpci_pcm *ypcm = runtime->private_data;\r\nstruct snd_ymfpci_voice *voice = ypcm->voices[0];\r\nif (!(ypcm->running && voice))\r\nreturn 0;\r\nreturn le32_to_cpu(voice->bank[chip->active_bank].start);\r\n}\r\nstatic snd_pcm_uframes_t snd_ymfpci_capture_pointer(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_ymfpci *chip = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct snd_ymfpci_pcm *ypcm = runtime->private_data;\r\nif (!ypcm->running)\r\nreturn 0;\r\nreturn le32_to_cpu(chip->bank_capture[ypcm->capture_bank_number][chip->active_bank]->start) >> ypcm->shift;\r\n}\r\nstatic void snd_ymfpci_irq_wait(struct snd_ymfpci *chip)\r\n{\r\nwait_queue_t wait;\r\nint loops = 4;\r\nwhile (loops-- > 0) {\r\nif ((snd_ymfpci_readl(chip, YDSXGR_MODE) & 3) == 0)\r\ncontinue;\r\ninit_waitqueue_entry(&wait, current);\r\nadd_wait_queue(&chip->interrupt_sleep, &wait);\r\natomic_inc(&chip->interrupt_sleep_count);\r\nschedule_timeout_uninterruptible(msecs_to_jiffies(50));\r\nremove_wait_queue(&chip->interrupt_sleep, &wait);\r\n}\r\n}\r\nstatic irqreturn_t snd_ymfpci_interrupt(int irq, void *dev_id)\r\n{\r\nstruct snd_ymfpci *chip = dev_id;\r\nu32 status, nvoice, mode;\r\nstruct snd_ymfpci_voice *voice;\r\nstatus = snd_ymfpci_readl(chip, YDSXGR_STATUS);\r\nif (status & 0x80000000) {\r\nchip->active_bank = snd_ymfpci_readl(chip, YDSXGR_CTRLSELECT) & 1;\r\nspin_lock(&chip->voice_lock);\r\nfor (nvoice = 0; nvoice < YDSXG_PLAYBACK_VOICES; nvoice++) {\r\nvoice = &chip->voices[nvoice];\r\nif (voice->interrupt)\r\nvoice->interrupt(chip, voice);\r\n}\r\nfor (nvoice = 0; nvoice < YDSXG_CAPTURE_VOICES; nvoice++) {\r\nif (chip->capture_substream[nvoice])\r\nsnd_ymfpci_pcm_capture_interrupt(chip->capture_substream[nvoice]);\r\n}\r\n#if 0\r\nfor (nvoice = 0; nvoice < YDSXG_EFFECT_VOICES; nvoice++) {\r\nif (chip->effect_substream[nvoice])\r\nsnd_ymfpci_pcm_effect_interrupt(chip->effect_substream[nvoice]);\r\n}\r\n#endif\r\nspin_unlock(&chip->voice_lock);\r\nspin_lock(&chip->reg_lock);\r\nsnd_ymfpci_writel(chip, YDSXGR_STATUS, 0x80000000);\r\nmode = snd_ymfpci_readl(chip, YDSXGR_MODE) | 2;\r\nsnd_ymfpci_writel(chip, YDSXGR_MODE, mode);\r\nspin_unlock(&chip->reg_lock);\r\nif (atomic_read(&chip->interrupt_sleep_count)) {\r\natomic_set(&chip->interrupt_sleep_count, 0);\r\nwake_up(&chip->interrupt_sleep);\r\n}\r\n}\r\nstatus = snd_ymfpci_readw(chip, YDSXGR_INTFLAG);\r\nif (status & 1) {\r\nif (chip->timer)\r\nsnd_timer_interrupt(chip->timer, chip->timer_ticks);\r\n}\r\nsnd_ymfpci_writew(chip, YDSXGR_INTFLAG, status);\r\nif (chip->rawmidi)\r\nsnd_mpu401_uart_interrupt(irq, chip->rawmidi->private_data);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void snd_ymfpci_pcm_free_substream(struct snd_pcm_runtime *runtime)\r\n{\r\nkfree(runtime->private_data);\r\n}\r\nstatic int snd_ymfpci_playback_open_1(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_ymfpci *chip = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct snd_ymfpci_pcm *ypcm;\r\nint err;\r\nruntime->hw = snd_ymfpci_playback;\r\nerr = snd_pcm_hw_constraint_minmax(runtime,\r\nSNDRV_PCM_HW_PARAM_PERIOD_TIME,\r\n5334, UINT_MAX);\r\nif (err < 0)\r\nreturn err;\r\nerr = snd_pcm_hw_rule_noresample(runtime, 48000);\r\nif (err < 0)\r\nreturn err;\r\nypcm = kzalloc(sizeof(*ypcm), GFP_KERNEL);\r\nif (ypcm == NULL)\r\nreturn -ENOMEM;\r\nypcm->chip = chip;\r\nypcm->type = PLAYBACK_VOICE;\r\nypcm->substream = substream;\r\nruntime->private_data = ypcm;\r\nruntime->private_free = snd_ymfpci_pcm_free_substream;\r\nreturn 0;\r\n}\r\nstatic void ymfpci_open_extension(struct snd_ymfpci *chip)\r\n{\r\nif (! chip->rear_opened) {\r\nif (! chip->spdif_opened)\r\nsnd_ymfpci_writel(chip, YDSXGR_MODE,\r\nsnd_ymfpci_readl(chip, YDSXGR_MODE) | (1 << 30));\r\nsnd_ymfpci_writew(chip, YDSXGR_SECCONFIG,\r\n(snd_ymfpci_readw(chip, YDSXGR_SECCONFIG) & ~0x0330) | 0x0010);\r\n}\r\n}\r\nstatic void ymfpci_close_extension(struct snd_ymfpci *chip)\r\n{\r\nif (! chip->rear_opened) {\r\nif (! chip->spdif_opened)\r\nsnd_ymfpci_writel(chip, YDSXGR_MODE,\r\nsnd_ymfpci_readl(chip, YDSXGR_MODE) & ~(1 << 30));\r\nsnd_ymfpci_writew(chip, YDSXGR_SECCONFIG,\r\n(snd_ymfpci_readw(chip, YDSXGR_SECCONFIG) & ~0x0330) & ~0x0010);\r\n}\r\n}\r\nstatic int snd_ymfpci_playback_open(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_ymfpci *chip = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct snd_ymfpci_pcm *ypcm;\r\nint err;\r\nif ((err = snd_ymfpci_playback_open_1(substream)) < 0)\r\nreturn err;\r\nypcm = runtime->private_data;\r\nypcm->output_front = 1;\r\nypcm->output_rear = chip->mode_dup4ch ? 1 : 0;\r\nypcm->swap_rear = 0;\r\nspin_lock_irq(&chip->reg_lock);\r\nif (ypcm->output_rear) {\r\nymfpci_open_extension(chip);\r\nchip->rear_opened++;\r\n}\r\nspin_unlock_irq(&chip->reg_lock);\r\nreturn 0;\r\n}\r\nstatic int snd_ymfpci_playback_spdif_open(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_ymfpci *chip = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct snd_ymfpci_pcm *ypcm;\r\nint err;\r\nif ((err = snd_ymfpci_playback_open_1(substream)) < 0)\r\nreturn err;\r\nypcm = runtime->private_data;\r\nypcm->output_front = 0;\r\nypcm->output_rear = 1;\r\nypcm->swap_rear = 1;\r\nspin_lock_irq(&chip->reg_lock);\r\nsnd_ymfpci_writew(chip, YDSXGR_SPDIFOUTCTRL,\r\nsnd_ymfpci_readw(chip, YDSXGR_SPDIFOUTCTRL) | 2);\r\nymfpci_open_extension(chip);\r\nchip->spdif_pcm_bits = chip->spdif_bits;\r\nsnd_ymfpci_writew(chip, YDSXGR_SPDIFOUTSTATUS, chip->spdif_pcm_bits);\r\nchip->spdif_opened++;\r\nspin_unlock_irq(&chip->reg_lock);\r\nchip->spdif_pcm_ctl->vd[0].access &= ~SNDRV_CTL_ELEM_ACCESS_INACTIVE;\r\nsnd_ctl_notify(chip->card, SNDRV_CTL_EVENT_MASK_VALUE |\r\nSNDRV_CTL_EVENT_MASK_INFO, &chip->spdif_pcm_ctl->id);\r\nreturn 0;\r\n}\r\nstatic int snd_ymfpci_playback_4ch_open(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_ymfpci *chip = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct snd_ymfpci_pcm *ypcm;\r\nint err;\r\nif ((err = snd_ymfpci_playback_open_1(substream)) < 0)\r\nreturn err;\r\nypcm = runtime->private_data;\r\nypcm->output_front = 0;\r\nypcm->output_rear = 1;\r\nypcm->swap_rear = 0;\r\nspin_lock_irq(&chip->reg_lock);\r\nymfpci_open_extension(chip);\r\nchip->rear_opened++;\r\nspin_unlock_irq(&chip->reg_lock);\r\nreturn 0;\r\n}\r\nstatic int snd_ymfpci_capture_open(struct snd_pcm_substream *substream,\r\nu32 capture_bank_number)\r\n{\r\nstruct snd_ymfpci *chip = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct snd_ymfpci_pcm *ypcm;\r\nint err;\r\nruntime->hw = snd_ymfpci_capture;\r\nerr = snd_pcm_hw_constraint_minmax(runtime,\r\nSNDRV_PCM_HW_PARAM_PERIOD_TIME,\r\n5334, UINT_MAX);\r\nif (err < 0)\r\nreturn err;\r\nerr = snd_pcm_hw_rule_noresample(runtime, 48000);\r\nif (err < 0)\r\nreturn err;\r\nypcm = kzalloc(sizeof(*ypcm), GFP_KERNEL);\r\nif (ypcm == NULL)\r\nreturn -ENOMEM;\r\nypcm->chip = chip;\r\nypcm->type = capture_bank_number + CAPTURE_REC;\r\nypcm->substream = substream;\r\nypcm->capture_bank_number = capture_bank_number;\r\nchip->capture_substream[capture_bank_number] = substream;\r\nruntime->private_data = ypcm;\r\nruntime->private_free = snd_ymfpci_pcm_free_substream;\r\nsnd_ymfpci_hw_start(chip);\r\nreturn 0;\r\n}\r\nstatic int snd_ymfpci_capture_rec_open(struct snd_pcm_substream *substream)\r\n{\r\nreturn snd_ymfpci_capture_open(substream, 0);\r\n}\r\nstatic int snd_ymfpci_capture_ac97_open(struct snd_pcm_substream *substream)\r\n{\r\nreturn snd_ymfpci_capture_open(substream, 1);\r\n}\r\nstatic int snd_ymfpci_playback_close_1(struct snd_pcm_substream *substream)\r\n{\r\nreturn 0;\r\n}\r\nstatic int snd_ymfpci_playback_close(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_ymfpci *chip = snd_pcm_substream_chip(substream);\r\nstruct snd_ymfpci_pcm *ypcm = substream->runtime->private_data;\r\nspin_lock_irq(&chip->reg_lock);\r\nif (ypcm->output_rear && chip->rear_opened > 0) {\r\nchip->rear_opened--;\r\nymfpci_close_extension(chip);\r\n}\r\nspin_unlock_irq(&chip->reg_lock);\r\nreturn snd_ymfpci_playback_close_1(substream);\r\n}\r\nstatic int snd_ymfpci_playback_spdif_close(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_ymfpci *chip = snd_pcm_substream_chip(substream);\r\nspin_lock_irq(&chip->reg_lock);\r\nchip->spdif_opened = 0;\r\nymfpci_close_extension(chip);\r\nsnd_ymfpci_writew(chip, YDSXGR_SPDIFOUTCTRL,\r\nsnd_ymfpci_readw(chip, YDSXGR_SPDIFOUTCTRL) & ~2);\r\nsnd_ymfpci_writew(chip, YDSXGR_SPDIFOUTSTATUS, chip->spdif_bits);\r\nspin_unlock_irq(&chip->reg_lock);\r\nchip->spdif_pcm_ctl->vd[0].access |= SNDRV_CTL_ELEM_ACCESS_INACTIVE;\r\nsnd_ctl_notify(chip->card, SNDRV_CTL_EVENT_MASK_VALUE |\r\nSNDRV_CTL_EVENT_MASK_INFO, &chip->spdif_pcm_ctl->id);\r\nreturn snd_ymfpci_playback_close_1(substream);\r\n}\r\nstatic int snd_ymfpci_playback_4ch_close(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_ymfpci *chip = snd_pcm_substream_chip(substream);\r\nspin_lock_irq(&chip->reg_lock);\r\nif (chip->rear_opened > 0) {\r\nchip->rear_opened--;\r\nymfpci_close_extension(chip);\r\n}\r\nspin_unlock_irq(&chip->reg_lock);\r\nreturn snd_ymfpci_playback_close_1(substream);\r\n}\r\nstatic int snd_ymfpci_capture_close(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_ymfpci *chip = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct snd_ymfpci_pcm *ypcm = runtime->private_data;\r\nif (ypcm != NULL) {\r\nchip->capture_substream[ypcm->capture_bank_number] = NULL;\r\nsnd_ymfpci_hw_stop(chip);\r\n}\r\nreturn 0;\r\n}\r\nint snd_ymfpci_pcm(struct snd_ymfpci *chip, int device, struct snd_pcm **rpcm)\r\n{\r\nstruct snd_pcm *pcm;\r\nint err;\r\nif (rpcm)\r\n*rpcm = NULL;\r\nif ((err = snd_pcm_new(chip->card, "YMFPCI", device, 32, 1, &pcm)) < 0)\r\nreturn err;\r\npcm->private_data = chip;\r\nsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &snd_ymfpci_playback_ops);\r\nsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &snd_ymfpci_capture_rec_ops);\r\npcm->info_flags = 0;\r\nstrcpy(pcm->name, "YMFPCI");\r\nchip->pcm = pcm;\r\nsnd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_DEV,\r\nsnd_dma_pci_data(chip->pci), 64*1024, 256*1024);\r\nerr = snd_pcm_add_chmap_ctls(pcm, SNDRV_PCM_STREAM_PLAYBACK,\r\nsnd_pcm_std_chmaps, 2, 0, NULL);\r\nif (err < 0)\r\nreturn err;\r\nif (rpcm)\r\n*rpcm = pcm;\r\nreturn 0;\r\n}\r\nint snd_ymfpci_pcm2(struct snd_ymfpci *chip, int device, struct snd_pcm **rpcm)\r\n{\r\nstruct snd_pcm *pcm;\r\nint err;\r\nif (rpcm)\r\n*rpcm = NULL;\r\nif ((err = snd_pcm_new(chip->card, "YMFPCI - PCM2", device, 0, 1, &pcm)) < 0)\r\nreturn err;\r\npcm->private_data = chip;\r\nsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &snd_ymfpci_capture_ac97_ops);\r\npcm->info_flags = 0;\r\nsprintf(pcm->name, "YMFPCI - %s",\r\nchip->device_id == PCI_DEVICE_ID_YAMAHA_754 ? "Direct Recording" : "AC'97");\r\nchip->pcm2 = pcm;\r\nsnd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_DEV,\r\nsnd_dma_pci_data(chip->pci), 64*1024, 256*1024);\r\nif (rpcm)\r\n*rpcm = pcm;\r\nreturn 0;\r\n}\r\nint snd_ymfpci_pcm_spdif(struct snd_ymfpci *chip, int device,\r\nstruct snd_pcm **rpcm)\r\n{\r\nstruct snd_pcm *pcm;\r\nint err;\r\nif (rpcm)\r\n*rpcm = NULL;\r\nif ((err = snd_pcm_new(chip->card, "YMFPCI - IEC958", device, 1, 0, &pcm)) < 0)\r\nreturn err;\r\npcm->private_data = chip;\r\nsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &snd_ymfpci_playback_spdif_ops);\r\npcm->info_flags = 0;\r\nstrcpy(pcm->name, "YMFPCI - IEC958");\r\nchip->pcm_spdif = pcm;\r\nsnd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_DEV,\r\nsnd_dma_pci_data(chip->pci), 64*1024, 256*1024);\r\nif (rpcm)\r\n*rpcm = pcm;\r\nreturn 0;\r\n}\r\nint snd_ymfpci_pcm_4ch(struct snd_ymfpci *chip, int device,\r\nstruct snd_pcm **rpcm)\r\n{\r\nstruct snd_pcm *pcm;\r\nint err;\r\nif (rpcm)\r\n*rpcm = NULL;\r\nif ((err = snd_pcm_new(chip->card, "YMFPCI - Rear", device, 1, 0, &pcm)) < 0)\r\nreturn err;\r\npcm->private_data = chip;\r\nsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &snd_ymfpci_playback_4ch_ops);\r\npcm->info_flags = 0;\r\nstrcpy(pcm->name, "YMFPCI - Rear PCM");\r\nchip->pcm_4ch = pcm;\r\nsnd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_DEV,\r\nsnd_dma_pci_data(chip->pci), 64*1024, 256*1024);\r\nerr = snd_pcm_add_chmap_ctls(pcm, SNDRV_PCM_STREAM_PLAYBACK,\r\nsurround_map, 2, 0, NULL);\r\nif (err < 0)\r\nreturn err;\r\nif (rpcm)\r\n*rpcm = pcm;\r\nreturn 0;\r\n}\r\nstatic int snd_ymfpci_spdif_default_info(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\r\n{\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_IEC958;\r\nuinfo->count = 1;\r\nreturn 0;\r\n}\r\nstatic int snd_ymfpci_spdif_default_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_ymfpci *chip = snd_kcontrol_chip(kcontrol);\r\nspin_lock_irq(&chip->reg_lock);\r\nucontrol->value.iec958.status[0] = (chip->spdif_bits >> 0) & 0xff;\r\nucontrol->value.iec958.status[1] = (chip->spdif_bits >> 8) & 0xff;\r\nucontrol->value.iec958.status[3] = IEC958_AES3_CON_FS_48000;\r\nspin_unlock_irq(&chip->reg_lock);\r\nreturn 0;\r\n}\r\nstatic int snd_ymfpci_spdif_default_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_ymfpci *chip = snd_kcontrol_chip(kcontrol);\r\nunsigned int val;\r\nint change;\r\nval = ((ucontrol->value.iec958.status[0] & 0x3e) << 0) |\r\n(ucontrol->value.iec958.status[1] << 8);\r\nspin_lock_irq(&chip->reg_lock);\r\nchange = chip->spdif_bits != val;\r\nchip->spdif_bits = val;\r\nif ((snd_ymfpci_readw(chip, YDSXGR_SPDIFOUTCTRL) & 1) && chip->pcm_spdif == NULL)\r\nsnd_ymfpci_writew(chip, YDSXGR_SPDIFOUTSTATUS, chip->spdif_bits);\r\nspin_unlock_irq(&chip->reg_lock);\r\nreturn change;\r\n}\r\nstatic int snd_ymfpci_spdif_mask_info(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\r\n{\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_IEC958;\r\nuinfo->count = 1;\r\nreturn 0;\r\n}\r\nstatic int snd_ymfpci_spdif_mask_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_ymfpci *chip = snd_kcontrol_chip(kcontrol);\r\nspin_lock_irq(&chip->reg_lock);\r\nucontrol->value.iec958.status[0] = 0x3e;\r\nucontrol->value.iec958.status[1] = 0xff;\r\nspin_unlock_irq(&chip->reg_lock);\r\nreturn 0;\r\n}\r\nstatic int snd_ymfpci_spdif_stream_info(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\r\n{\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_IEC958;\r\nuinfo->count = 1;\r\nreturn 0;\r\n}\r\nstatic int snd_ymfpci_spdif_stream_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_ymfpci *chip = snd_kcontrol_chip(kcontrol);\r\nspin_lock_irq(&chip->reg_lock);\r\nucontrol->value.iec958.status[0] = (chip->spdif_pcm_bits >> 0) & 0xff;\r\nucontrol->value.iec958.status[1] = (chip->spdif_pcm_bits >> 8) & 0xff;\r\nucontrol->value.iec958.status[3] = IEC958_AES3_CON_FS_48000;\r\nspin_unlock_irq(&chip->reg_lock);\r\nreturn 0;\r\n}\r\nstatic int snd_ymfpci_spdif_stream_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_ymfpci *chip = snd_kcontrol_chip(kcontrol);\r\nunsigned int val;\r\nint change;\r\nval = ((ucontrol->value.iec958.status[0] & 0x3e) << 0) |\r\n(ucontrol->value.iec958.status[1] << 8);\r\nspin_lock_irq(&chip->reg_lock);\r\nchange = chip->spdif_pcm_bits != val;\r\nchip->spdif_pcm_bits = val;\r\nif ((snd_ymfpci_readw(chip, YDSXGR_SPDIFOUTCTRL) & 2))\r\nsnd_ymfpci_writew(chip, YDSXGR_SPDIFOUTSTATUS, chip->spdif_pcm_bits);\r\nspin_unlock_irq(&chip->reg_lock);\r\nreturn change;\r\n}\r\nstatic int snd_ymfpci_drec_source_info(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *info)\r\n{\r\nstatic const char *const texts[3] = {"AC'97", "IEC958", "ZV Port"};\r\nreturn snd_ctl_enum_info(info, 1, 3, texts);\r\n}\r\nstatic int snd_ymfpci_drec_source_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *value)\r\n{\r\nstruct snd_ymfpci *chip = snd_kcontrol_chip(kcontrol);\r\nu16 reg;\r\nspin_lock_irq(&chip->reg_lock);\r\nreg = snd_ymfpci_readw(chip, YDSXGR_GLOBALCTRL);\r\nspin_unlock_irq(&chip->reg_lock);\r\nif (!(reg & 0x100))\r\nvalue->value.enumerated.item[0] = 0;\r\nelse\r\nvalue->value.enumerated.item[0] = 1 + ((reg & 0x200) != 0);\r\nreturn 0;\r\n}\r\nstatic int snd_ymfpci_drec_source_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *value)\r\n{\r\nstruct snd_ymfpci *chip = snd_kcontrol_chip(kcontrol);\r\nu16 reg, old_reg;\r\nspin_lock_irq(&chip->reg_lock);\r\nold_reg = snd_ymfpci_readw(chip, YDSXGR_GLOBALCTRL);\r\nif (value->value.enumerated.item[0] == 0)\r\nreg = old_reg & ~0x100;\r\nelse\r\nreg = (old_reg & ~0x300) | 0x100 | ((value->value.enumerated.item[0] == 2) << 9);\r\nsnd_ymfpci_writew(chip, YDSXGR_GLOBALCTRL, reg);\r\nspin_unlock_irq(&chip->reg_lock);\r\nreturn reg != old_reg;\r\n}\r\nstatic int snd_ymfpci_get_single(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_ymfpci *chip = snd_kcontrol_chip(kcontrol);\r\nint reg = kcontrol->private_value & 0xffff;\r\nunsigned int shift = (kcontrol->private_value >> 16) & 0xff;\r\nunsigned int mask = 1;\r\nswitch (reg) {\r\ncase YDSXGR_SPDIFOUTCTRL: break;\r\ncase YDSXGR_SPDIFINCTRL: break;\r\ndefault: return -EINVAL;\r\n}\r\nucontrol->value.integer.value[0] =\r\n(snd_ymfpci_readl(chip, reg) >> shift) & mask;\r\nreturn 0;\r\n}\r\nstatic int snd_ymfpci_put_single(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_ymfpci *chip = snd_kcontrol_chip(kcontrol);\r\nint reg = kcontrol->private_value & 0xffff;\r\nunsigned int shift = (kcontrol->private_value >> 16) & 0xff;\r\nunsigned int mask = 1;\r\nint change;\r\nunsigned int val, oval;\r\nswitch (reg) {\r\ncase YDSXGR_SPDIFOUTCTRL: break;\r\ncase YDSXGR_SPDIFINCTRL: break;\r\ndefault: return -EINVAL;\r\n}\r\nval = (ucontrol->value.integer.value[0] & mask);\r\nval <<= shift;\r\nspin_lock_irq(&chip->reg_lock);\r\noval = snd_ymfpci_readl(chip, reg);\r\nval = (oval & ~(mask << shift)) | val;\r\nchange = val != oval;\r\nsnd_ymfpci_writel(chip, reg, val);\r\nspin_unlock_irq(&chip->reg_lock);\r\nreturn change;\r\n}\r\nstatic int snd_ymfpci_info_double(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\r\n{\r\nunsigned int reg = kcontrol->private_value;\r\nif (reg < 0x80 || reg >= 0xc0)\r\nreturn -EINVAL;\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\r\nuinfo->count = 2;\r\nuinfo->value.integer.min = 0;\r\nuinfo->value.integer.max = 16383;\r\nreturn 0;\r\n}\r\nstatic int snd_ymfpci_get_double(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_ymfpci *chip = snd_kcontrol_chip(kcontrol);\r\nunsigned int reg = kcontrol->private_value;\r\nunsigned int shift_left = 0, shift_right = 16, mask = 16383;\r\nunsigned int val;\r\nif (reg < 0x80 || reg >= 0xc0)\r\nreturn -EINVAL;\r\nspin_lock_irq(&chip->reg_lock);\r\nval = snd_ymfpci_readl(chip, reg);\r\nspin_unlock_irq(&chip->reg_lock);\r\nucontrol->value.integer.value[0] = (val >> shift_left) & mask;\r\nucontrol->value.integer.value[1] = (val >> shift_right) & mask;\r\nreturn 0;\r\n}\r\nstatic int snd_ymfpci_put_double(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_ymfpci *chip = snd_kcontrol_chip(kcontrol);\r\nunsigned int reg = kcontrol->private_value;\r\nunsigned int shift_left = 0, shift_right = 16, mask = 16383;\r\nint change;\r\nunsigned int val1, val2, oval;\r\nif (reg < 0x80 || reg >= 0xc0)\r\nreturn -EINVAL;\r\nval1 = ucontrol->value.integer.value[0] & mask;\r\nval2 = ucontrol->value.integer.value[1] & mask;\r\nval1 <<= shift_left;\r\nval2 <<= shift_right;\r\nspin_lock_irq(&chip->reg_lock);\r\noval = snd_ymfpci_readl(chip, reg);\r\nval1 = (oval & ~((mask << shift_left) | (mask << shift_right))) | val1 | val2;\r\nchange = val1 != oval;\r\nsnd_ymfpci_writel(chip, reg, val1);\r\nspin_unlock_irq(&chip->reg_lock);\r\nreturn change;\r\n}\r\nstatic int snd_ymfpci_put_nativedacvol(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_ymfpci *chip = snd_kcontrol_chip(kcontrol);\r\nunsigned int reg = YDSXGR_NATIVEDACOUTVOL;\r\nunsigned int reg2 = YDSXGR_BUF441OUTVOL;\r\nint change;\r\nunsigned int value, oval;\r\nvalue = ucontrol->value.integer.value[0] & 0x3fff;\r\nvalue |= (ucontrol->value.integer.value[1] & 0x3fff) << 16;\r\nspin_lock_irq(&chip->reg_lock);\r\noval = snd_ymfpci_readl(chip, reg);\r\nchange = value != oval;\r\nsnd_ymfpci_writel(chip, reg, value);\r\nsnd_ymfpci_writel(chip, reg2, value);\r\nspin_unlock_irq(&chip->reg_lock);\r\nreturn change;\r\n}\r\nstatic int snd_ymfpci_get_dup4ch(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_ymfpci *chip = snd_kcontrol_chip(kcontrol);\r\nucontrol->value.integer.value[0] = chip->mode_dup4ch;\r\nreturn 0;\r\n}\r\nstatic int snd_ymfpci_put_dup4ch(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_ymfpci *chip = snd_kcontrol_chip(kcontrol);\r\nint change;\r\nchange = (ucontrol->value.integer.value[0] != chip->mode_dup4ch);\r\nif (change)\r\nchip->mode_dup4ch = !!ucontrol->value.integer.value[0];\r\nreturn change;\r\n}\r\nstatic int snd_ymfpci_get_gpio_out(struct snd_ymfpci *chip, int pin)\r\n{\r\nu16 reg, mode;\r\nunsigned long flags;\r\nspin_lock_irqsave(&chip->reg_lock, flags);\r\nreg = snd_ymfpci_readw(chip, YDSXGR_GPIOFUNCENABLE);\r\nreg &= ~(1 << (pin + 8));\r\nreg |= (1 << pin);\r\nsnd_ymfpci_writew(chip, YDSXGR_GPIOFUNCENABLE, reg);\r\nmode = snd_ymfpci_readw(chip, YDSXGR_GPIOTYPECONFIG);\r\nmode &= ~(3 << (pin * 2));\r\nsnd_ymfpci_writew(chip, YDSXGR_GPIOTYPECONFIG, mode);\r\nsnd_ymfpci_writew(chip, YDSXGR_GPIOFUNCENABLE, reg | (1 << (pin + 8)));\r\nmode = snd_ymfpci_readw(chip, YDSXGR_GPIOINSTATUS);\r\nspin_unlock_irqrestore(&chip->reg_lock, flags);\r\nreturn (mode >> pin) & 1;\r\n}\r\nstatic int snd_ymfpci_set_gpio_out(struct snd_ymfpci *chip, int pin, int enable)\r\n{\r\nu16 reg;\r\nunsigned long flags;\r\nspin_lock_irqsave(&chip->reg_lock, flags);\r\nreg = snd_ymfpci_readw(chip, YDSXGR_GPIOFUNCENABLE);\r\nreg &= ~(1 << pin);\r\nreg &= ~(1 << (pin + 8));\r\nsnd_ymfpci_writew(chip, YDSXGR_GPIOFUNCENABLE, reg);\r\nsnd_ymfpci_writew(chip, YDSXGR_GPIOOUTCTRL, enable << pin);\r\nsnd_ymfpci_writew(chip, YDSXGR_GPIOFUNCENABLE, reg | (1 << (pin + 8)));\r\nspin_unlock_irqrestore(&chip->reg_lock, flags);\r\nreturn 0;\r\n}\r\nstatic int snd_ymfpci_gpio_sw_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_ymfpci *chip = snd_kcontrol_chip(kcontrol);\r\nint pin = (int)kcontrol->private_value;\r\nucontrol->value.integer.value[0] = snd_ymfpci_get_gpio_out(chip, pin);\r\nreturn 0;\r\n}\r\nstatic int snd_ymfpci_gpio_sw_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_ymfpci *chip = snd_kcontrol_chip(kcontrol);\r\nint pin = (int)kcontrol->private_value;\r\nif (snd_ymfpci_get_gpio_out(chip, pin) != ucontrol->value.integer.value[0]) {\r\nsnd_ymfpci_set_gpio_out(chip, pin, !!ucontrol->value.integer.value[0]);\r\nucontrol->value.integer.value[0] = snd_ymfpci_get_gpio_out(chip, pin);\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_ymfpci_pcm_vol_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\r\nuinfo->count = 2;\r\nuinfo->value.integer.min = 0;\r\nuinfo->value.integer.max = 0x8000;\r\nreturn 0;\r\n}\r\nstatic int snd_ymfpci_pcm_vol_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_ymfpci *chip = snd_kcontrol_chip(kcontrol);\r\nunsigned int subs = kcontrol->id.subdevice;\r\nucontrol->value.integer.value[0] = chip->pcm_mixer[subs].left;\r\nucontrol->value.integer.value[1] = chip->pcm_mixer[subs].right;\r\nreturn 0;\r\n}\r\nstatic int snd_ymfpci_pcm_vol_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_ymfpci *chip = snd_kcontrol_chip(kcontrol);\r\nunsigned int subs = kcontrol->id.subdevice;\r\nstruct snd_pcm_substream *substream;\r\nunsigned long flags;\r\nif (ucontrol->value.integer.value[0] != chip->pcm_mixer[subs].left ||\r\nucontrol->value.integer.value[1] != chip->pcm_mixer[subs].right) {\r\nchip->pcm_mixer[subs].left = ucontrol->value.integer.value[0];\r\nchip->pcm_mixer[subs].right = ucontrol->value.integer.value[1];\r\nif (chip->pcm_mixer[subs].left > 0x8000)\r\nchip->pcm_mixer[subs].left = 0x8000;\r\nif (chip->pcm_mixer[subs].right > 0x8000)\r\nchip->pcm_mixer[subs].right = 0x8000;\r\nsubstream = (struct snd_pcm_substream *)kcontrol->private_value;\r\nspin_lock_irqsave(&chip->voice_lock, flags);\r\nif (substream->runtime && substream->runtime->private_data) {\r\nstruct snd_ymfpci_pcm *ypcm = substream->runtime->private_data;\r\nif (!ypcm->use_441_slot)\r\nypcm->update_pcm_vol = 2;\r\n}\r\nspin_unlock_irqrestore(&chip->voice_lock, flags);\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic void snd_ymfpci_mixer_free_ac97_bus(struct snd_ac97_bus *bus)\r\n{\r\nstruct snd_ymfpci *chip = bus->private_data;\r\nchip->ac97_bus = NULL;\r\n}\r\nstatic void snd_ymfpci_mixer_free_ac97(struct snd_ac97 *ac97)\r\n{\r\nstruct snd_ymfpci *chip = ac97->private_data;\r\nchip->ac97 = NULL;\r\n}\r\nint snd_ymfpci_mixer(struct snd_ymfpci *chip, int rear_switch)\r\n{\r\nstruct snd_ac97_template ac97;\r\nstruct snd_kcontrol *kctl;\r\nstruct snd_pcm_substream *substream;\r\nunsigned int idx;\r\nint err;\r\nstatic struct snd_ac97_bus_ops ops = {\r\n.write = snd_ymfpci_codec_write,\r\n.read = snd_ymfpci_codec_read,\r\n};\r\nif ((err = snd_ac97_bus(chip->card, 0, &ops, chip, &chip->ac97_bus)) < 0)\r\nreturn err;\r\nchip->ac97_bus->private_free = snd_ymfpci_mixer_free_ac97_bus;\r\nchip->ac97_bus->no_vra = 1;\r\nmemset(&ac97, 0, sizeof(ac97));\r\nac97.private_data = chip;\r\nac97.private_free = snd_ymfpci_mixer_free_ac97;\r\nif ((err = snd_ac97_mixer(chip->ac97_bus, &ac97, &chip->ac97)) < 0)\r\nreturn err;\r\nsnd_ac97_update_bits(chip->ac97, AC97_EXTENDED_STATUS,\r\nAC97_EA_VRA|AC97_EA_VRM, 0);\r\nfor (idx = 0; idx < ARRAY_SIZE(snd_ymfpci_controls); idx++) {\r\nif ((err = snd_ctl_add(chip->card, snd_ctl_new1(&snd_ymfpci_controls[idx], chip))) < 0)\r\nreturn err;\r\n}\r\nif (chip->ac97->ext_id & AC97_EI_SDAC) {\r\nkctl = snd_ctl_new1(&snd_ymfpci_dup4ch, chip);\r\nerr = snd_ctl_add(chip->card, kctl);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nif (snd_BUG_ON(!chip->pcm_spdif))\r\nreturn -ENXIO;\r\nif ((err = snd_ctl_add(chip->card, kctl = snd_ctl_new1(&snd_ymfpci_spdif_default, chip))) < 0)\r\nreturn err;\r\nkctl->id.device = chip->pcm_spdif->device;\r\nif ((err = snd_ctl_add(chip->card, kctl = snd_ctl_new1(&snd_ymfpci_spdif_mask, chip))) < 0)\r\nreturn err;\r\nkctl->id.device = chip->pcm_spdif->device;\r\nif ((err = snd_ctl_add(chip->card, kctl = snd_ctl_new1(&snd_ymfpci_spdif_stream, chip))) < 0)\r\nreturn err;\r\nkctl->id.device = chip->pcm_spdif->device;\r\nchip->spdif_pcm_ctl = kctl;\r\nif (chip->device_id == PCI_DEVICE_ID_YAMAHA_754 &&\r\n(err = snd_ctl_add(chip->card, kctl = snd_ctl_new1(&snd_ymfpci_drec_source, chip))) < 0)\r\nreturn err;\r\nif (rear_switch) {\r\nif ((err = snd_ctl_add(chip->card, snd_ctl_new1(&snd_ymfpci_rear_shared, chip))) < 0)\r\nreturn err;\r\n}\r\nsubstream = chip->pcm->streams[SNDRV_PCM_STREAM_PLAYBACK].substream;\r\nfor (idx = 0; idx < 32; ++idx) {\r\nkctl = snd_ctl_new1(&snd_ymfpci_pcm_volume, chip);\r\nif (!kctl)\r\nreturn -ENOMEM;\r\nkctl->id.device = chip->pcm->device;\r\nkctl->id.subdevice = idx;\r\nkctl->private_value = (unsigned long)substream;\r\nif ((err = snd_ctl_add(chip->card, kctl)) < 0)\r\nreturn err;\r\nchip->pcm_mixer[idx].left = 0x8000;\r\nchip->pcm_mixer[idx].right = 0x8000;\r\nchip->pcm_mixer[idx].ctl = kctl;\r\nsubstream = substream->next;\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_ymfpci_timer_start(struct snd_timer *timer)\r\n{\r\nstruct snd_ymfpci *chip;\r\nunsigned long flags;\r\nunsigned int count;\r\nchip = snd_timer_chip(timer);\r\nspin_lock_irqsave(&chip->reg_lock, flags);\r\nif (timer->sticks > 1) {\r\nchip->timer_ticks = timer->sticks;\r\ncount = timer->sticks - 1;\r\n} else {\r\nchip->timer_ticks = 2;\r\ncount = 2 - 1;\r\n}\r\nsnd_ymfpci_writew(chip, YDSXGR_TIMERCOUNT, count);\r\nsnd_ymfpci_writeb(chip, YDSXGR_TIMERCTRL, 0x03);\r\nspin_unlock_irqrestore(&chip->reg_lock, flags);\r\nreturn 0;\r\n}\r\nstatic int snd_ymfpci_timer_stop(struct snd_timer *timer)\r\n{\r\nstruct snd_ymfpci *chip;\r\nunsigned long flags;\r\nchip = snd_timer_chip(timer);\r\nspin_lock_irqsave(&chip->reg_lock, flags);\r\nsnd_ymfpci_writeb(chip, YDSXGR_TIMERCTRL, 0x00);\r\nspin_unlock_irqrestore(&chip->reg_lock, flags);\r\nreturn 0;\r\n}\r\nstatic int snd_ymfpci_timer_precise_resolution(struct snd_timer *timer,\r\nunsigned long *num, unsigned long *den)\r\n{\r\n*num = 1;\r\n*den = 96000;\r\nreturn 0;\r\n}\r\nint snd_ymfpci_timer(struct snd_ymfpci *chip, int device)\r\n{\r\nstruct snd_timer *timer = NULL;\r\nstruct snd_timer_id tid;\r\nint err;\r\ntid.dev_class = SNDRV_TIMER_CLASS_CARD;\r\ntid.dev_sclass = SNDRV_TIMER_SCLASS_NONE;\r\ntid.card = chip->card->number;\r\ntid.device = device;\r\ntid.subdevice = 0;\r\nif ((err = snd_timer_new(chip->card, "YMFPCI", &tid, &timer)) >= 0) {\r\nstrcpy(timer->name, "YMFPCI timer");\r\ntimer->private_data = chip;\r\ntimer->hw = snd_ymfpci_timer_hw;\r\n}\r\nchip->timer = timer;\r\nreturn err;\r\n}\r\nstatic void snd_ymfpci_proc_read(struct snd_info_entry *entry,\r\nstruct snd_info_buffer *buffer)\r\n{\r\nstruct snd_ymfpci *chip = entry->private_data;\r\nint i;\r\nsnd_iprintf(buffer, "YMFPCI\n\n");\r\nfor (i = 0; i <= YDSXGR_WORKBASE; i += 4)\r\nsnd_iprintf(buffer, "%04x: %04x\n", i, snd_ymfpci_readl(chip, i));\r\n}\r\nstatic int snd_ymfpci_proc_init(struct snd_card *card, struct snd_ymfpci *chip)\r\n{\r\nstruct snd_info_entry *entry;\r\nif (! snd_card_proc_new(card, "ymfpci", &entry))\r\nsnd_info_set_text_ops(entry, chip, snd_ymfpci_proc_read);\r\nreturn 0;\r\n}\r\nstatic void snd_ymfpci_aclink_reset(struct pci_dev * pci)\r\n{\r\nu8 cmd;\r\npci_read_config_byte(pci, PCIR_DSXG_CTRL, &cmd);\r\n#if 0\r\nif (cmd & 0x03) {\r\n#endif\r\npci_write_config_byte(pci, PCIR_DSXG_CTRL, cmd & 0xfc);\r\npci_write_config_byte(pci, PCIR_DSXG_CTRL, cmd | 0x03);\r\npci_write_config_byte(pci, PCIR_DSXG_CTRL, cmd & 0xfc);\r\npci_write_config_word(pci, PCIR_DSXG_PWRCTRL1, 0);\r\npci_write_config_word(pci, PCIR_DSXG_PWRCTRL2, 0);\r\n#if 0\r\n}\r\n#endif\r\n}\r\nstatic void snd_ymfpci_enable_dsp(struct snd_ymfpci *chip)\r\n{\r\nsnd_ymfpci_writel(chip, YDSXGR_CONFIG, 0x00000001);\r\n}\r\nstatic void snd_ymfpci_disable_dsp(struct snd_ymfpci *chip)\r\n{\r\nu32 val;\r\nint timeout = 1000;\r\nval = snd_ymfpci_readl(chip, YDSXGR_CONFIG);\r\nif (val)\r\nsnd_ymfpci_writel(chip, YDSXGR_CONFIG, 0x00000000);\r\nwhile (timeout-- > 0) {\r\nval = snd_ymfpci_readl(chip, YDSXGR_STATUS);\r\nif ((val & 0x00000002) == 0)\r\nbreak;\r\n}\r\n}\r\nstatic int snd_ymfpci_request_firmware(struct snd_ymfpci *chip)\r\n{\r\nint err, is_1e;\r\nconst char *name;\r\nerr = request_firmware(&chip->dsp_microcode, "yamaha/ds1_dsp.fw",\r\n&chip->pci->dev);\r\nif (err >= 0) {\r\nif (chip->dsp_microcode->size != YDSXG_DSPLENGTH) {\r\nsnd_printk(KERN_ERR "DSP microcode has wrong size\n");\r\nerr = -EINVAL;\r\n}\r\n}\r\nif (err < 0)\r\nreturn err;\r\nis_1e = chip->device_id == PCI_DEVICE_ID_YAMAHA_724F ||\r\nchip->device_id == PCI_DEVICE_ID_YAMAHA_740C ||\r\nchip->device_id == PCI_DEVICE_ID_YAMAHA_744 ||\r\nchip->device_id == PCI_DEVICE_ID_YAMAHA_754;\r\nname = is_1e ? "yamaha/ds1e_ctrl.fw" : "yamaha/ds1_ctrl.fw";\r\nerr = request_firmware(&chip->controller_microcode, name,\r\n&chip->pci->dev);\r\nif (err >= 0) {\r\nif (chip->controller_microcode->size != YDSXG_CTRLLENGTH) {\r\nsnd_printk(KERN_ERR "controller microcode"\r\n" has wrong size\n");\r\nerr = -EINVAL;\r\n}\r\n}\r\nif (err < 0)\r\nreturn err;\r\nreturn 0;\r\n}\r\nstatic void snd_ymfpci_download_image(struct snd_ymfpci *chip)\r\n{\r\nint i;\r\nu16 ctrl;\r\nconst __le32 *inst;\r\nsnd_ymfpci_writel(chip, YDSXGR_NATIVEDACOUTVOL, 0x00000000);\r\nsnd_ymfpci_disable_dsp(chip);\r\nsnd_ymfpci_writel(chip, YDSXGR_MODE, 0x00010000);\r\nsnd_ymfpci_writel(chip, YDSXGR_MODE, 0x00000000);\r\nsnd_ymfpci_writel(chip, YDSXGR_MAPOFREC, 0x00000000);\r\nsnd_ymfpci_writel(chip, YDSXGR_MAPOFEFFECT, 0x00000000);\r\nsnd_ymfpci_writel(chip, YDSXGR_PLAYCTRLBASE, 0x00000000);\r\nsnd_ymfpci_writel(chip, YDSXGR_RECCTRLBASE, 0x00000000);\r\nsnd_ymfpci_writel(chip, YDSXGR_EFFCTRLBASE, 0x00000000);\r\nctrl = snd_ymfpci_readw(chip, YDSXGR_GLOBALCTRL);\r\nsnd_ymfpci_writew(chip, YDSXGR_GLOBALCTRL, ctrl & ~0x0007);\r\ninst = (const __le32 *)chip->dsp_microcode->data;\r\nfor (i = 0; i < YDSXG_DSPLENGTH / 4; i++)\r\nsnd_ymfpci_writel(chip, YDSXGR_DSPINSTRAM + (i << 2),\r\nle32_to_cpu(inst[i]));\r\ninst = (const __le32 *)chip->controller_microcode->data;\r\nfor (i = 0; i < YDSXG_CTRLLENGTH / 4; i++)\r\nsnd_ymfpci_writel(chip, YDSXGR_CTRLINSTRAM + (i << 2),\r\nle32_to_cpu(inst[i]));\r\nsnd_ymfpci_enable_dsp(chip);\r\n}\r\nstatic int snd_ymfpci_memalloc(struct snd_ymfpci *chip)\r\n{\r\nlong size, playback_ctrl_size;\r\nint voice, bank, reg;\r\nu8 *ptr;\r\ndma_addr_t ptr_addr;\r\nplayback_ctrl_size = 4 + 4 * YDSXG_PLAYBACK_VOICES;\r\nchip->bank_size_playback = snd_ymfpci_readl(chip, YDSXGR_PLAYCTRLSIZE) << 2;\r\nchip->bank_size_capture = snd_ymfpci_readl(chip, YDSXGR_RECCTRLSIZE) << 2;\r\nchip->bank_size_effect = snd_ymfpci_readl(chip, YDSXGR_EFFCTRLSIZE) << 2;\r\nchip->work_size = YDSXG_DEFAULT_WORK_SIZE;\r\nsize = ALIGN(playback_ctrl_size, 0x100) +\r\nALIGN(chip->bank_size_playback * 2 * YDSXG_PLAYBACK_VOICES, 0x100) +\r\nALIGN(chip->bank_size_capture * 2 * YDSXG_CAPTURE_VOICES, 0x100) +\r\nALIGN(chip->bank_size_effect * 2 * YDSXG_EFFECT_VOICES, 0x100) +\r\nchip->work_size;\r\nif (snd_dma_alloc_pages(SNDRV_DMA_TYPE_DEV, snd_dma_pci_data(chip->pci),\r\nsize, &chip->work_ptr) < 0)\r\nreturn -ENOMEM;\r\nptr = chip->work_ptr.area;\r\nptr_addr = chip->work_ptr.addr;\r\nmemset(ptr, 0, size);\r\nchip->bank_base_playback = ptr;\r\nchip->bank_base_playback_addr = ptr_addr;\r\nchip->ctrl_playback = (u32 *)ptr;\r\nchip->ctrl_playback[0] = cpu_to_le32(YDSXG_PLAYBACK_VOICES);\r\nptr += ALIGN(playback_ctrl_size, 0x100);\r\nptr_addr += ALIGN(playback_ctrl_size, 0x100);\r\nfor (voice = 0; voice < YDSXG_PLAYBACK_VOICES; voice++) {\r\nchip->voices[voice].number = voice;\r\nchip->voices[voice].bank = (struct snd_ymfpci_playback_bank *)ptr;\r\nchip->voices[voice].bank_addr = ptr_addr;\r\nfor (bank = 0; bank < 2; bank++) {\r\nchip->bank_playback[voice][bank] = (struct snd_ymfpci_playback_bank *)ptr;\r\nptr += chip->bank_size_playback;\r\nptr_addr += chip->bank_size_playback;\r\n}\r\n}\r\nptr = (char *)ALIGN((unsigned long)ptr, 0x100);\r\nptr_addr = ALIGN(ptr_addr, 0x100);\r\nchip->bank_base_capture = ptr;\r\nchip->bank_base_capture_addr = ptr_addr;\r\nfor (voice = 0; voice < YDSXG_CAPTURE_VOICES; voice++)\r\nfor (bank = 0; bank < 2; bank++) {\r\nchip->bank_capture[voice][bank] = (struct snd_ymfpci_capture_bank *)ptr;\r\nptr += chip->bank_size_capture;\r\nptr_addr += chip->bank_size_capture;\r\n}\r\nptr = (char *)ALIGN((unsigned long)ptr, 0x100);\r\nptr_addr = ALIGN(ptr_addr, 0x100);\r\nchip->bank_base_effect = ptr;\r\nchip->bank_base_effect_addr = ptr_addr;\r\nfor (voice = 0; voice < YDSXG_EFFECT_VOICES; voice++)\r\nfor (bank = 0; bank < 2; bank++) {\r\nchip->bank_effect[voice][bank] = (struct snd_ymfpci_effect_bank *)ptr;\r\nptr += chip->bank_size_effect;\r\nptr_addr += chip->bank_size_effect;\r\n}\r\nptr = (char *)ALIGN((unsigned long)ptr, 0x100);\r\nptr_addr = ALIGN(ptr_addr, 0x100);\r\nchip->work_base = ptr;\r\nchip->work_base_addr = ptr_addr;\r\nsnd_BUG_ON(ptr + chip->work_size !=\r\nchip->work_ptr.area + chip->work_ptr.bytes);\r\nsnd_ymfpci_writel(chip, YDSXGR_PLAYCTRLBASE, chip->bank_base_playback_addr);\r\nsnd_ymfpci_writel(chip, YDSXGR_RECCTRLBASE, chip->bank_base_capture_addr);\r\nsnd_ymfpci_writel(chip, YDSXGR_EFFCTRLBASE, chip->bank_base_effect_addr);\r\nsnd_ymfpci_writel(chip, YDSXGR_WORKBASE, chip->work_base_addr);\r\nsnd_ymfpci_writel(chip, YDSXGR_WORKSIZE, chip->work_size >> 2);\r\nchip->spdif_bits = chip->spdif_pcm_bits = SNDRV_PCM_DEFAULT_CON_SPDIF & 0xffff;\r\nsnd_ymfpci_writew(chip, YDSXGR_SPDIFOUTCTRL, 0);\r\nsnd_ymfpci_writew(chip, YDSXGR_SPDIFOUTSTATUS, chip->spdif_bits);\r\nsnd_ymfpci_writew(chip, YDSXGR_SPDIFINCTRL, 0);\r\nfor (reg = 0x80; reg < 0xc0; reg += 4)\r\nsnd_ymfpci_writel(chip, reg, 0);\r\nsnd_ymfpci_writel(chip, YDSXGR_NATIVEDACOUTVOL, 0x3fff3fff);\r\nsnd_ymfpci_writel(chip, YDSXGR_BUF441OUTVOL, 0x3fff3fff);\r\nsnd_ymfpci_writel(chip, YDSXGR_ZVOUTVOL, 0x3fff3fff);\r\nsnd_ymfpci_writel(chip, YDSXGR_SPDIFOUTVOL, 0x3fff3fff);\r\nsnd_ymfpci_writel(chip, YDSXGR_NATIVEADCINVOL, 0x3fff3fff);\r\nsnd_ymfpci_writel(chip, YDSXGR_NATIVEDACINVOL, 0x3fff3fff);\r\nsnd_ymfpci_writel(chip, YDSXGR_PRIADCLOOPVOL, 0x3fff3fff);\r\nsnd_ymfpci_writel(chip, YDSXGR_LEGACYOUTVOL, 0x3fff3fff);\r\nreturn 0;\r\n}\r\nstatic int snd_ymfpci_free(struct snd_ymfpci *chip)\r\n{\r\nu16 ctrl;\r\nif (snd_BUG_ON(!chip))\r\nreturn -EINVAL;\r\nif (chip->res_reg_area) {\r\nsnd_ymfpci_writel(chip, YDSXGR_NATIVEDACOUTVOL, 0);\r\nsnd_ymfpci_writel(chip, YDSXGR_BUF441OUTVOL, 0);\r\nsnd_ymfpci_writel(chip, YDSXGR_LEGACYOUTVOL, 0);\r\nsnd_ymfpci_writel(chip, YDSXGR_STATUS, ~0);\r\nsnd_ymfpci_disable_dsp(chip);\r\nsnd_ymfpci_writel(chip, YDSXGR_PLAYCTRLBASE, 0);\r\nsnd_ymfpci_writel(chip, YDSXGR_RECCTRLBASE, 0);\r\nsnd_ymfpci_writel(chip, YDSXGR_EFFCTRLBASE, 0);\r\nsnd_ymfpci_writel(chip, YDSXGR_WORKBASE, 0);\r\nsnd_ymfpci_writel(chip, YDSXGR_WORKSIZE, 0);\r\nctrl = snd_ymfpci_readw(chip, YDSXGR_GLOBALCTRL);\r\nsnd_ymfpci_writew(chip, YDSXGR_GLOBALCTRL, ctrl & ~0x0007);\r\n}\r\nsnd_ymfpci_ac3_done(chip);\r\n#if 0\r\npci_set_power_state(chip->pci, 3);\r\n#endif\r\n#ifdef CONFIG_PM_SLEEP\r\nkfree(chip->saved_regs);\r\n#endif\r\nif (chip->irq >= 0)\r\nfree_irq(chip->irq, chip);\r\nrelease_and_free_resource(chip->mpu_res);\r\nrelease_and_free_resource(chip->fm_res);\r\nsnd_ymfpci_free_gameport(chip);\r\nif (chip->reg_area_virt)\r\niounmap(chip->reg_area_virt);\r\nif (chip->work_ptr.area)\r\nsnd_dma_free_pages(&chip->work_ptr);\r\nrelease_and_free_resource(chip->res_reg_area);\r\npci_write_config_word(chip->pci, 0x40, chip->old_legacy_ctrl);\r\npci_disable_device(chip->pci);\r\nrelease_firmware(chip->dsp_microcode);\r\nrelease_firmware(chip->controller_microcode);\r\nkfree(chip);\r\nreturn 0;\r\n}\r\nstatic int snd_ymfpci_dev_free(struct snd_device *device)\r\n{\r\nstruct snd_ymfpci *chip = device->device_data;\r\nreturn snd_ymfpci_free(chip);\r\n}\r\nstatic int snd_ymfpci_suspend(struct device *dev)\r\n{\r\nstruct pci_dev *pci = to_pci_dev(dev);\r\nstruct snd_card *card = dev_get_drvdata(dev);\r\nstruct snd_ymfpci *chip = card->private_data;\r\nunsigned int i;\r\nsnd_power_change_state(card, SNDRV_CTL_POWER_D3hot);\r\nsnd_pcm_suspend_all(chip->pcm);\r\nsnd_pcm_suspend_all(chip->pcm2);\r\nsnd_pcm_suspend_all(chip->pcm_spdif);\r\nsnd_pcm_suspend_all(chip->pcm_4ch);\r\nsnd_ac97_suspend(chip->ac97);\r\nfor (i = 0; i < YDSXGR_NUM_SAVED_REGS; i++)\r\nchip->saved_regs[i] = snd_ymfpci_readl(chip, saved_regs_index[i]);\r\nchip->saved_ydsxgr_mode = snd_ymfpci_readl(chip, YDSXGR_MODE);\r\npci_read_config_word(chip->pci, PCIR_DSXG_LEGACY,\r\n&chip->saved_dsxg_legacy);\r\npci_read_config_word(chip->pci, PCIR_DSXG_ELEGACY,\r\n&chip->saved_dsxg_elegacy);\r\nsnd_ymfpci_writel(chip, YDSXGR_NATIVEDACOUTVOL, 0);\r\nsnd_ymfpci_writel(chip, YDSXGR_BUF441OUTVOL, 0);\r\nsnd_ymfpci_disable_dsp(chip);\r\npci_disable_device(pci);\r\npci_save_state(pci);\r\npci_set_power_state(pci, PCI_D3hot);\r\nreturn 0;\r\n}\r\nstatic int snd_ymfpci_resume(struct device *dev)\r\n{\r\nstruct pci_dev *pci = to_pci_dev(dev);\r\nstruct snd_card *card = dev_get_drvdata(dev);\r\nstruct snd_ymfpci *chip = card->private_data;\r\nunsigned int i;\r\npci_set_power_state(pci, PCI_D0);\r\npci_restore_state(pci);\r\nif (pci_enable_device(pci) < 0) {\r\nprintk(KERN_ERR "ymfpci: pci_enable_device failed, "\r\n"disabling device\n");\r\nsnd_card_disconnect(card);\r\nreturn -EIO;\r\n}\r\npci_set_master(pci);\r\nsnd_ymfpci_aclink_reset(pci);\r\nsnd_ymfpci_codec_ready(chip, 0);\r\nsnd_ymfpci_download_image(chip);\r\nudelay(100);\r\nfor (i = 0; i < YDSXGR_NUM_SAVED_REGS; i++)\r\nsnd_ymfpci_writel(chip, saved_regs_index[i], chip->saved_regs[i]);\r\nsnd_ac97_resume(chip->ac97);\r\npci_write_config_word(chip->pci, PCIR_DSXG_LEGACY,\r\nchip->saved_dsxg_legacy);\r\npci_write_config_word(chip->pci, PCIR_DSXG_ELEGACY,\r\nchip->saved_dsxg_elegacy);\r\nif (chip->start_count > 0) {\r\nspin_lock_irq(&chip->reg_lock);\r\nsnd_ymfpci_writel(chip, YDSXGR_MODE, chip->saved_ydsxgr_mode);\r\nchip->active_bank = snd_ymfpci_readl(chip, YDSXGR_CTRLSELECT);\r\nspin_unlock_irq(&chip->reg_lock);\r\n}\r\nsnd_power_change_state(card, SNDRV_CTL_POWER_D0);\r\nreturn 0;\r\n}\r\nint snd_ymfpci_create(struct snd_card *card,\r\nstruct pci_dev *pci,\r\nunsigned short old_legacy_ctrl,\r\nstruct snd_ymfpci **rchip)\r\n{\r\nstruct snd_ymfpci *chip;\r\nint err;\r\nstatic struct snd_device_ops ops = {\r\n.dev_free = snd_ymfpci_dev_free,\r\n};\r\n*rchip = NULL;\r\nif ((err = pci_enable_device(pci)) < 0)\r\nreturn err;\r\nchip = kzalloc(sizeof(*chip), GFP_KERNEL);\r\nif (chip == NULL) {\r\npci_disable_device(pci);\r\nreturn -ENOMEM;\r\n}\r\nchip->old_legacy_ctrl = old_legacy_ctrl;\r\nspin_lock_init(&chip->reg_lock);\r\nspin_lock_init(&chip->voice_lock);\r\ninit_waitqueue_head(&chip->interrupt_sleep);\r\natomic_set(&chip->interrupt_sleep_count, 0);\r\nchip->card = card;\r\nchip->pci = pci;\r\nchip->irq = -1;\r\nchip->device_id = pci->device;\r\nchip->rev = pci->revision;\r\nchip->reg_area_phys = pci_resource_start(pci, 0);\r\nchip->reg_area_virt = ioremap_nocache(chip->reg_area_phys, 0x8000);\r\npci_set_master(pci);\r\nchip->src441_used = -1;\r\nif ((chip->res_reg_area = request_mem_region(chip->reg_area_phys, 0x8000, "YMFPCI")) == NULL) {\r\nsnd_printk(KERN_ERR "unable to grab memory region 0x%lx-0x%lx\n", chip->reg_area_phys, chip->reg_area_phys + 0x8000 - 1);\r\nsnd_ymfpci_free(chip);\r\nreturn -EBUSY;\r\n}\r\nif (request_irq(pci->irq, snd_ymfpci_interrupt, IRQF_SHARED,\r\nKBUILD_MODNAME, chip)) {\r\nsnd_printk(KERN_ERR "unable to grab IRQ %d\n", pci->irq);\r\nsnd_ymfpci_free(chip);\r\nreturn -EBUSY;\r\n}\r\nchip->irq = pci->irq;\r\nsnd_ymfpci_aclink_reset(pci);\r\nif (snd_ymfpci_codec_ready(chip, 0) < 0) {\r\nsnd_ymfpci_free(chip);\r\nreturn -EIO;\r\n}\r\nerr = snd_ymfpci_request_firmware(chip);\r\nif (err < 0) {\r\nsnd_printk(KERN_ERR "firmware request failed: %d\n", err);\r\nsnd_ymfpci_free(chip);\r\nreturn err;\r\n}\r\nsnd_ymfpci_download_image(chip);\r\nudelay(100);\r\nif (snd_ymfpci_memalloc(chip) < 0) {\r\nsnd_ymfpci_free(chip);\r\nreturn -EIO;\r\n}\r\nif ((err = snd_ymfpci_ac3_init(chip)) < 0) {\r\nsnd_ymfpci_free(chip);\r\nreturn err;\r\n}\r\n#ifdef CONFIG_PM_SLEEP\r\nchip->saved_regs = kmalloc(YDSXGR_NUM_SAVED_REGS * sizeof(u32),\r\nGFP_KERNEL);\r\nif (chip->saved_regs == NULL) {\r\nsnd_ymfpci_free(chip);\r\nreturn -ENOMEM;\r\n}\r\n#endif\r\nif ((err = snd_device_new(card, SNDRV_DEV_LOWLEVEL, chip, &ops)) < 0) {\r\nsnd_ymfpci_free(chip);\r\nreturn err;\r\n}\r\nsnd_ymfpci_proc_init(card, chip);\r\nsnd_card_set_dev(card, &pci->dev);\r\n*rchip = chip;\r\nreturn 0;\r\n}
