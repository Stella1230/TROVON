static void agp_3_5_dev_list_insert(struct list_head *head, struct list_head *new)\r\n{\r\nstruct agp_3_5_dev *cur, *n = list_entry(new, struct agp_3_5_dev, list);\r\nstruct list_head *pos;\r\nlist_for_each(pos, head) {\r\ncur = list_entry(pos, struct agp_3_5_dev, list);\r\nif (cur->maxbw > n->maxbw)\r\nbreak;\r\n}\r\nlist_add_tail(new, pos);\r\n}\r\nstatic void agp_3_5_dev_list_sort(struct agp_3_5_dev *list, unsigned int ndevs)\r\n{\r\nstruct agp_3_5_dev *cur;\r\nstruct pci_dev *dev;\r\nstruct list_head *pos, *tmp, *head = &list->list, *start = head->next;\r\nu32 nistat;\r\nINIT_LIST_HEAD(head);\r\nfor (pos=start; pos!=head; ) {\r\ncur = list_entry(pos, struct agp_3_5_dev, list);\r\ndev = cur->dev;\r\npci_read_config_dword(dev, cur->capndx+AGPNISTAT, &nistat);\r\ncur->maxbw = (nistat >> 16) & 0xff;\r\ntmp = pos;\r\npos = pos->next;\r\nagp_3_5_dev_list_insert(head, tmp);\r\n}\r\n}\r\nstatic int agp_3_5_isochronous_node_enable(struct agp_bridge_data *bridge,\r\nstruct agp_3_5_dev *dev_list, unsigned int ndevs)\r\n{\r\nstruct isoch_data {\r\nu32 maxbw;\r\nu32 n;\r\nu32 y;\r\nu32 l;\r\nu32 rq;\r\nstruct agp_3_5_dev *dev;\r\n};\r\nstruct pci_dev *td = bridge->dev, *dev;\r\nstruct list_head *head = &dev_list->list, *pos;\r\nstruct agp_3_5_dev *cur;\r\nstruct isoch_data *master, target;\r\nunsigned int cdev = 0;\r\nu32 mnistat, tnistat, tstatus, mcmd;\r\nu16 tnicmd, mnicmd;\r\nu8 mcapndx;\r\nu32 tot_bw = 0, tot_n = 0, tot_rq = 0, y_max, rq_isoch, rq_async;\r\nu32 step, rem, rem_isoch, rem_async;\r\nint ret = 0;\r\nif ((master = kmalloc(ndevs * sizeof(*master), GFP_KERNEL)) == NULL) {\r\nret = -ENOMEM;\r\ngoto get_out;\r\n}\r\nagp_3_5_dev_list_sort(dev_list, ndevs);\r\npci_read_config_dword(td, bridge->capndx+AGPNISTAT, &tnistat);\r\npci_read_config_dword(td, bridge->capndx+AGPSTAT, &tstatus);\r\ntarget.maxbw = (tnistat >> 16) & 0xff;\r\ntarget.n = (tnistat >> 8) & 0xff;\r\ntarget.y = (tnistat >> 6) & 0x3;\r\ntarget.l = (tnistat >> 3) & 0x7;\r\ntarget.rq = (tstatus >> 24) & 0xff;\r\ny_max = target.y;\r\nlist_for_each(pos, head) {\r\ncur = list_entry(pos, struct agp_3_5_dev, list);\r\ndev = cur->dev;\r\nmcapndx = cur->capndx;\r\npci_read_config_dword(dev, cur->capndx+AGPNISTAT, &mnistat);\r\nmaster[cdev].maxbw = (mnistat >> 16) & 0xff;\r\nmaster[cdev].n = (mnistat >> 8) & 0xff;\r\nmaster[cdev].y = (mnistat >> 6) & 0x3;\r\nmaster[cdev].dev = cur;\r\ntot_bw += master[cdev].maxbw;\r\ny_max = max(y_max, master[cdev].y);\r\ncdev++;\r\n}\r\nif (tot_bw > target.maxbw) {\r\ndev_err(&td->dev, "isochronous bandwidth required "\r\n"by AGP 3.0 devices exceeds that which is supported by "\r\n"the AGP 3.0 bridge!\n");\r\nret = -ENODEV;\r\ngoto free_and_exit;\r\n}\r\ntarget.y = y_max;\r\npci_read_config_word(td, bridge->capndx+AGPNICMD, &tnicmd);\r\ntnicmd &= ~(0x3 << 6);\r\ntnicmd |= target.y << 6;\r\npci_write_config_word(td, bridge->capndx+AGPNICMD, tnicmd);\r\npci_read_config_dword(td, bridge->capndx+AGPNISTAT, &tnistat);\r\ntarget.n = (tnistat >> 8) & 0xff;\r\nfor (cdev=0; cdev<ndevs; cdev++) {\r\nmaster[cdev].y = target.y;\r\nmaster[cdev].n = master[cdev].maxbw / (master[cdev].y + 1);\r\ntot_n += master[cdev].n;\r\n}\r\nif (tot_n > target.n) {\r\ndev_err(&td->dev, "number of isochronous "\r\n"transactions per period required by AGP 3.0 devices "\r\n"exceeds that which is supported by the AGP 3.0 "\r\n"bridge!\n");\r\nret = -ENODEV;\r\ngoto free_and_exit;\r\n}\r\nrem = target.n - tot_n;\r\nfor (cdev=0; cdev<ndevs; cdev++) {\r\nmaster[cdev].rq = master[cdev].n;\r\nif (master[cdev].y > 0x1)\r\nmaster[cdev].rq *= (1 << (master[cdev].y - 1));\r\ntot_rq += master[cdev].rq;\r\n}\r\nmaster[ndevs-1].n += rem;\r\nrq_isoch = (target.y > 0x1) ? target.n * (1 << (target.y - 1)) : target.n;\r\nrq_async = target.rq - rq_isoch;\r\nif (tot_rq > rq_isoch) {\r\ndev_err(&td->dev, "number of request queue slots "\r\n"required by the isochronous bandwidth requested by "\r\n"AGP 3.0 devices exceeds the number provided by the "\r\n"AGP 3.0 bridge!\n");\r\nret = -ENODEV;\r\ngoto free_and_exit;\r\n}\r\nstep = rq_async / ndevs;\r\nrem_async = step + (rq_async % ndevs);\r\nrem_isoch = rq_isoch - tot_rq;\r\nfor (cdev=0; cdev<ndevs; cdev++) {\r\ncur = master[cdev].dev;\r\ndev = cur->dev;\r\nmcapndx = cur->capndx;\r\nmaster[cdev].rq += (cdev == ndevs - 1)\r\n? (rem_async + rem_isoch) : step;\r\npci_read_config_word(dev, cur->capndx+AGPNICMD, &mnicmd);\r\npci_read_config_dword(dev, cur->capndx+AGPCMD, &mcmd);\r\nmnicmd &= ~(0xff << 8);\r\nmnicmd &= ~(0x3 << 6);\r\nmcmd &= ~(0xff << 24);\r\nmnicmd |= master[cdev].n << 8;\r\nmnicmd |= master[cdev].y << 6;\r\nmcmd |= master[cdev].rq << 24;\r\npci_write_config_dword(dev, cur->capndx+AGPCMD, mcmd);\r\npci_write_config_word(dev, cur->capndx+AGPNICMD, mnicmd);\r\n}\r\nfree_and_exit:\r\nkfree(master);\r\nget_out:\r\nreturn ret;\r\n}\r\nstatic void agp_3_5_nonisochronous_node_enable(struct agp_bridge_data *bridge,\r\nstruct agp_3_5_dev *dev_list, unsigned int ndevs)\r\n{\r\nstruct agp_3_5_dev *cur;\r\nstruct list_head *head = &dev_list->list, *pos;\r\nu32 tstatus, mcmd;\r\nu32 trq, mrq, rem;\r\nunsigned int cdev = 0;\r\npci_read_config_dword(bridge->dev, bridge->capndx+AGPSTAT, &tstatus);\r\ntrq = (tstatus >> 24) & 0xff;\r\nmrq = trq / ndevs;\r\nrem = mrq + (trq % ndevs);\r\nfor (pos=head->next; cdev<ndevs; cdev++, pos=pos->next) {\r\ncur = list_entry(pos, struct agp_3_5_dev, list);\r\npci_read_config_dword(cur->dev, cur->capndx+AGPCMD, &mcmd);\r\nmcmd &= ~(0xff << 24);\r\nmcmd |= ((cdev == ndevs - 1) ? rem : mrq) << 24;\r\npci_write_config_dword(cur->dev, cur->capndx+AGPCMD, mcmd);\r\n}\r\n}\r\nint agp_3_5_enable(struct agp_bridge_data *bridge)\r\n{\r\nstruct pci_dev *td = bridge->dev, *dev = NULL;\r\nu8 mcapndx;\r\nu32 isoch, arqsz;\r\nu32 tstatus, mstatus, ncapid;\r\nu32 mmajor;\r\nu16 mpstat;\r\nstruct agp_3_5_dev *dev_list, *cur;\r\nstruct list_head *head, *pos;\r\nunsigned int ndevs = 0;\r\nint ret = 0;\r\npci_read_config_dword(td, bridge->capndx+AGPSTAT, &tstatus);\r\nisoch = (tstatus >> 17) & 0x1;\r\nif (isoch == 0)\r\nreturn -ENODEV;\r\narqsz = (tstatus >> 13) & 0x7;\r\nif ((dev_list = kmalloc(sizeof(*dev_list), GFP_KERNEL)) == NULL) {\r\nret = -ENOMEM;\r\ngoto get_out;\r\n}\r\nhead = &dev_list->list;\r\nINIT_LIST_HEAD(head);\r\nfor_each_pci_dev(dev) {\r\nmcapndx = pci_find_capability(dev, PCI_CAP_ID_AGP);\r\nif (mcapndx == 0)\r\ncontinue;\r\nswitch ((dev->class >>8) & 0xff00) {\r\ncase 0x0600:\r\ncontinue;\r\ncase 0x0001:\r\nif (mcapndx != 0) {\r\ndev_info(&td->dev, "wacky, found unclassified AGP device %s [%04x/%04x]\n",\r\npci_name(dev),\r\ndev->vendor, dev->device);\r\n}\r\ncontinue;\r\ncase 0x0300:\r\ncase 0x0400:\r\nif ((cur = kmalloc(sizeof(*cur), GFP_KERNEL)) == NULL) {\r\nret = -ENOMEM;\r\ngoto free_and_exit;\r\n}\r\ncur->dev = dev;\r\npos = &cur->list;\r\nlist_add(pos, head);\r\nndevs++;\r\ncontinue;\r\ndefault:\r\ncontinue;\r\n}\r\n}\r\nlist_for_each(pos, head) {\r\ncur = list_entry(pos, struct agp_3_5_dev, list);\r\ndev = cur->dev;\r\npci_read_config_word(dev, PCI_STATUS, &mpstat);\r\nif ((mpstat & PCI_STATUS_CAP_LIST) == 0)\r\ncontinue;\r\npci_read_config_byte(dev, PCI_CAPABILITY_LIST, &mcapndx);\r\nif (mcapndx != 0) {\r\ndo {\r\npci_read_config_dword(dev, mcapndx, &ncapid);\r\nif ((ncapid & 0xff) != 2)\r\nmcapndx = (ncapid >> 8) & 0xff;\r\n}\r\nwhile (((ncapid & 0xff) != 2) && (mcapndx != 0));\r\n}\r\nif (mcapndx == 0) {\r\ndev_err(&td->dev, "woah! Non-AGP device %s on "\r\n"secondary bus of AGP 3.5 bridge!\n",\r\npci_name(dev));\r\nret = -ENODEV;\r\ngoto free_and_exit;\r\n}\r\nmmajor = (ncapid >> AGP_MAJOR_VERSION_SHIFT) & 0xf;\r\nif (mmajor < 3) {\r\ndev_err(&td->dev, "woah! AGP 2.0 device %s on "\r\n"secondary bus of AGP 3.5 bridge operating "\r\n"with AGP 3.0 electricals!\n", pci_name(dev));\r\nret = -ENODEV;\r\ngoto free_and_exit;\r\n}\r\ncur->capndx = mcapndx;\r\npci_read_config_dword(dev, cur->capndx+AGPSTAT, &mstatus);\r\nif (((mstatus >> 3) & 0x1) == 0) {\r\ndev_err(&td->dev, "woah! AGP 3.x device %s not "\r\n"operating in AGP 3.x mode on secondary bus "\r\n"of AGP 3.5 bridge operating with AGP 3.0 "\r\n"electricals!\n", pci_name(dev));\r\nret = -ENODEV;\r\ngoto free_and_exit;\r\n}\r\n}\r\nif (isoch) {\r\nret = agp_3_5_isochronous_node_enable(bridge, dev_list, ndevs);\r\nif (ret) {\r\ndev_info(&td->dev, "something bad happened setting "\r\n"up isochronous xfers; falling back to "\r\n"non-isochronous xfer mode\n");\r\n} else {\r\ngoto free_and_exit;\r\n}\r\n}\r\nagp_3_5_nonisochronous_node_enable(bridge, dev_list, ndevs);\r\nfree_and_exit:\r\nfor (pos=head->next; pos!=head; ) {\r\ncur = list_entry(pos, struct agp_3_5_dev, list);\r\npos = pos->next;\r\nkfree(cur);\r\n}\r\nkfree(dev_list);\r\nget_out:\r\nreturn ret;\r\n}
