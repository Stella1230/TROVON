static void update_pzl_pointers(struct whc *whc, int period, u64 addr)\r\n{\r\nswitch (period) {\r\ncase 0:\r\nwhc_qset_set_link_ptr(&whc->pz_list[0], addr);\r\nwhc_qset_set_link_ptr(&whc->pz_list[2], addr);\r\nwhc_qset_set_link_ptr(&whc->pz_list[4], addr);\r\nwhc_qset_set_link_ptr(&whc->pz_list[6], addr);\r\nwhc_qset_set_link_ptr(&whc->pz_list[8], addr);\r\nwhc_qset_set_link_ptr(&whc->pz_list[10], addr);\r\nwhc_qset_set_link_ptr(&whc->pz_list[12], addr);\r\nwhc_qset_set_link_ptr(&whc->pz_list[14], addr);\r\nbreak;\r\ncase 1:\r\nwhc_qset_set_link_ptr(&whc->pz_list[1], addr);\r\nwhc_qset_set_link_ptr(&whc->pz_list[5], addr);\r\nwhc_qset_set_link_ptr(&whc->pz_list[9], addr);\r\nwhc_qset_set_link_ptr(&whc->pz_list[13], addr);\r\nbreak;\r\ncase 2:\r\nwhc_qset_set_link_ptr(&whc->pz_list[3], addr);\r\nwhc_qset_set_link_ptr(&whc->pz_list[11], addr);\r\nbreak;\r\ncase 3:\r\nwhc_qset_set_link_ptr(&whc->pz_list[7], addr);\r\nbreak;\r\ncase 4:\r\nwhc_qset_set_link_ptr(&whc->pz_list[15], addr);\r\nbreak;\r\n}\r\n}\r\nstatic int qset_get_period(struct whc *whc, struct whc_qset *qset)\r\n{\r\nuint8_t bInterval = qset->ep->desc.bInterval;\r\nif (bInterval < 6)\r\nbInterval = 6;\r\nif (bInterval > 10)\r\nbInterval = 10;\r\nreturn bInterval - 6;\r\n}\r\nstatic void qset_insert_in_sw_list(struct whc *whc, struct whc_qset *qset)\r\n{\r\nint period;\r\nperiod = qset_get_period(whc, qset);\r\nqset_clear(whc, qset);\r\nlist_move(&qset->list_node, &whc->periodic_list[period]);\r\nqset->in_sw_list = true;\r\n}\r\nstatic void pzl_qset_remove(struct whc *whc, struct whc_qset *qset)\r\n{\r\nlist_move(&qset->list_node, &whc->periodic_removed_list);\r\nqset->in_hw_list = false;\r\nqset->in_sw_list = false;\r\n}\r\nstatic enum whc_update pzl_process_qset(struct whc *whc, struct whc_qset *qset)\r\n{\r\nenum whc_update update = 0;\r\nuint32_t status = 0;\r\nwhile (qset->ntds) {\r\nstruct whc_qtd *td;\r\nint t;\r\nt = qset->td_start;\r\ntd = &qset->qtd[qset->td_start];\r\nstatus = le32_to_cpu(td->status);\r\nif (status & QTD_STS_ACTIVE)\r\nbreak;\r\nif (status & QTD_STS_HALTED) {\r\nprocess_halted_qtd(whc, qset, td);\r\nupdate |= WHC_UPDATE_UPDATED;\r\ngoto done;\r\n}\r\nprocess_inactive_qtd(whc, qset, td);\r\n}\r\nif (!qset->remove)\r\nupdate |= qset_add_qtds(whc, qset);\r\ndone:\r\nif (qset->remove && qset->ntds == 0) {\r\npzl_qset_remove(whc, qset);\r\nupdate |= WHC_UPDATE_REMOVED;\r\n}\r\nreturn update;\r\n}\r\nvoid pzl_start(struct whc *whc)\r\n{\r\nle_writeq(whc->pz_list_dma, whc->base + WUSBPERIODICLISTBASE);\r\nwhc_write_wusbcmd(whc, WUSBCMD_PERIODIC_EN, WUSBCMD_PERIODIC_EN);\r\nwhci_wait_for(&whc->umc->dev, whc->base + WUSBSTS,\r\nWUSBSTS_PERIODIC_SCHED, WUSBSTS_PERIODIC_SCHED,\r\n1000, "start PZL");\r\n}\r\nvoid pzl_stop(struct whc *whc)\r\n{\r\nwhc_write_wusbcmd(whc, WUSBCMD_PERIODIC_EN, 0);\r\nwhci_wait_for(&whc->umc->dev, whc->base + WUSBSTS,\r\nWUSBSTS_PERIODIC_SCHED, 0,\r\n1000, "stop PZL");\r\n}\r\nvoid pzl_update(struct whc *whc, uint32_t wusbcmd)\r\n{\r\nstruct wusbhc *wusbhc = &whc->wusbhc;\r\nlong t;\r\nmutex_lock(&wusbhc->mutex);\r\nif (wusbhc->active) {\r\nwhc_write_wusbcmd(whc, wusbcmd, wusbcmd);\r\nt = wait_event_timeout(\r\nwhc->periodic_list_wq,\r\n(le_readl(whc->base + WUSBCMD) & WUSBCMD_PERIODIC_UPDATED) == 0,\r\nmsecs_to_jiffies(1000));\r\nif (t == 0)\r\nwhc_hw_error(whc, "PZL update timeout");\r\n}\r\nmutex_unlock(&wusbhc->mutex);\r\n}\r\nstatic void update_pzl_hw_view(struct whc *whc)\r\n{\r\nstruct whc_qset *qset, *t;\r\nint period;\r\nu64 tmp_qh = 0;\r\nfor (period = 0; period < 5; period++) {\r\nlist_for_each_entry_safe(qset, t, &whc->periodic_list[period], list_node) {\r\nwhc_qset_set_link_ptr(&qset->qh.link, tmp_qh);\r\ntmp_qh = qset->qset_dma;\r\nqset->in_hw_list = true;\r\n}\r\nupdate_pzl_pointers(whc, period, tmp_qh);\r\n}\r\n}\r\nvoid scan_periodic_work(struct work_struct *work)\r\n{\r\nstruct whc *whc = container_of(work, struct whc, periodic_work);\r\nstruct whc_qset *qset, *t;\r\nenum whc_update update = 0;\r\nint period;\r\nspin_lock_irq(&whc->lock);\r\nfor (period = 4; period >= 0; period--) {\r\nlist_for_each_entry_safe(qset, t, &whc->periodic_list[period], list_node) {\r\nif (!qset->in_hw_list)\r\nupdate |= WHC_UPDATE_ADDED;\r\nupdate |= pzl_process_qset(whc, qset);\r\n}\r\n}\r\nif (update & (WHC_UPDATE_ADDED | WHC_UPDATE_REMOVED))\r\nupdate_pzl_hw_view(whc);\r\nspin_unlock_irq(&whc->lock);\r\nif (update) {\r\nuint32_t wusbcmd = WUSBCMD_PERIODIC_UPDATED | WUSBCMD_PERIODIC_SYNCED_DB;\r\nif (update & WHC_UPDATE_REMOVED)\r\nwusbcmd |= WUSBCMD_PERIODIC_QSET_RM;\r\npzl_update(whc, wusbcmd);\r\n}\r\nspin_lock_irq(&whc->lock);\r\nlist_for_each_entry_safe(qset, t, &whc->periodic_removed_list, list_node) {\r\nqset_remove_complete(whc, qset);\r\nif (qset->reset) {\r\nqset_reset(whc, qset);\r\nif (!list_empty(&qset->stds)) {\r\nqset_insert_in_sw_list(whc, qset);\r\nqueue_work(whc->workqueue, &whc->periodic_work);\r\n}\r\n}\r\n}\r\nspin_unlock_irq(&whc->lock);\r\n}\r\nint pzl_urb_enqueue(struct whc *whc, struct urb *urb, gfp_t mem_flags)\r\n{\r\nstruct whc_qset *qset;\r\nint err;\r\nunsigned long flags;\r\nspin_lock_irqsave(&whc->lock, flags);\r\nerr = usb_hcd_link_urb_to_ep(&whc->wusbhc.usb_hcd, urb);\r\nif (err < 0) {\r\nspin_unlock_irqrestore(&whc->lock, flags);\r\nreturn err;\r\n}\r\nqset = get_qset(whc, urb, GFP_ATOMIC);\r\nif (qset == NULL)\r\nerr = -ENOMEM;\r\nelse\r\nerr = qset_add_urb(whc, qset, urb, GFP_ATOMIC);\r\nif (!err) {\r\nif (!qset->in_sw_list && !qset->remove)\r\nqset_insert_in_sw_list(whc, qset);\r\n} else\r\nusb_hcd_unlink_urb_from_ep(&whc->wusbhc.usb_hcd, urb);\r\nspin_unlock_irqrestore(&whc->lock, flags);\r\nif (!err)\r\nqueue_work(whc->workqueue, &whc->periodic_work);\r\nreturn err;\r\n}\r\nint pzl_urb_dequeue(struct whc *whc, struct urb *urb, int status)\r\n{\r\nstruct whc_urb *wurb = urb->hcpriv;\r\nstruct whc_qset *qset = wurb->qset;\r\nstruct whc_std *std, *t;\r\nbool has_qtd = false;\r\nint ret;\r\nunsigned long flags;\r\nspin_lock_irqsave(&whc->lock, flags);\r\nret = usb_hcd_check_unlink_urb(&whc->wusbhc.usb_hcd, urb, status);\r\nif (ret < 0)\r\ngoto out;\r\nlist_for_each_entry_safe(std, t, &qset->stds, list_node) {\r\nif (std->urb == urb) {\r\nif (std->qtd)\r\nhas_qtd = true;\r\nqset_free_std(whc, std);\r\n} else\r\nstd->qtd = NULL;\r\n}\r\nif (has_qtd) {\r\npzl_qset_remove(whc, qset);\r\nupdate_pzl_hw_view(whc);\r\nwurb->status = status;\r\nwurb->is_async = false;\r\nqueue_work(whc->workqueue, &wurb->dequeue_work);\r\n} else\r\nqset_remove_urb(whc, qset, urb, status);\r\nout:\r\nspin_unlock_irqrestore(&whc->lock, flags);\r\nreturn ret;\r\n}\r\nvoid pzl_qset_delete(struct whc *whc, struct whc_qset *qset)\r\n{\r\nqset->remove = 1;\r\nqueue_work(whc->workqueue, &whc->periodic_work);\r\nqset_delete(whc, qset);\r\n}\r\nint pzl_init(struct whc *whc)\r\n{\r\nint i;\r\nwhc->pz_list = dma_alloc_coherent(&whc->umc->dev, sizeof(u64) * 16,\r\n&whc->pz_list_dma, GFP_KERNEL);\r\nif (whc->pz_list == NULL)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < 16; i++)\r\nwhc->pz_list[i] = cpu_to_le64(QH_LINK_NTDS(8) | QH_LINK_T);\r\nle_writeq(whc->pz_list_dma, whc->base + WUSBPERIODICLISTBASE);\r\nreturn 0;\r\n}\r\nvoid pzl_clean_up(struct whc *whc)\r\n{\r\nif (whc->pz_list)\r\ndma_free_coherent(&whc->umc->dev, sizeof(u64) * 16, whc->pz_list,\r\nwhc->pz_list_dma);\r\n}
