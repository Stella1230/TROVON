static void at803x_set_wol_mac_addr(struct phy_device *phydev)\r\n{\r\nstruct net_device *ndev = phydev->attached_dev;\r\nconst u8 *mac;\r\nunsigned int i, offsets[] = {\r\nAT803X_LOC_MAC_ADDR_32_47_OFFSET,\r\nAT803X_LOC_MAC_ADDR_16_31_OFFSET,\r\nAT803X_LOC_MAC_ADDR_0_15_OFFSET,\r\n};\r\nif (!ndev)\r\nreturn;\r\nmac = (const u8 *) ndev->dev_addr;\r\nif (!is_valid_ether_addr(mac))\r\nreturn;\r\nfor (i = 0; i < 3; i++) {\r\nphy_write(phydev, AT803X_MMD_ACCESS_CONTROL,\r\nAT803X_DEVICE_ADDR);\r\nphy_write(phydev, AT803X_MMD_ACCESS_CONTROL_DATA,\r\noffsets[i]);\r\nphy_write(phydev, AT803X_MMD_ACCESS_CONTROL,\r\nAT803X_FUNC_DATA);\r\nphy_write(phydev, AT803X_MMD_ACCESS_CONTROL_DATA,\r\nmac[(i * 2) + 1] | (mac[(i * 2)] << 8));\r\n}\r\n}\r\nstatic int at803x_config_init(struct phy_device *phydev)\r\n{\r\nint val;\r\nu32 features;\r\nint status;\r\nfeatures = SUPPORTED_TP | SUPPORTED_MII | SUPPORTED_AUI |\r\nSUPPORTED_FIBRE | SUPPORTED_BNC;\r\nval = phy_read(phydev, MII_BMSR);\r\nif (val < 0)\r\nreturn val;\r\nif (val & BMSR_ANEGCAPABLE)\r\nfeatures |= SUPPORTED_Autoneg;\r\nif (val & BMSR_100FULL)\r\nfeatures |= SUPPORTED_100baseT_Full;\r\nif (val & BMSR_100HALF)\r\nfeatures |= SUPPORTED_100baseT_Half;\r\nif (val & BMSR_10FULL)\r\nfeatures |= SUPPORTED_10baseT_Full;\r\nif (val & BMSR_10HALF)\r\nfeatures |= SUPPORTED_10baseT_Half;\r\nif (val & BMSR_ESTATEN) {\r\nval = phy_read(phydev, MII_ESTATUS);\r\nif (val < 0)\r\nreturn val;\r\nif (val & ESTATUS_1000_TFULL)\r\nfeatures |= SUPPORTED_1000baseT_Full;\r\nif (val & ESTATUS_1000_THALF)\r\nfeatures |= SUPPORTED_1000baseT_Half;\r\n}\r\nphydev->supported = features;\r\nphydev->advertising = features;\r\nat803x_set_wol_mac_addr(phydev);\r\nstatus = phy_write(phydev, AT803X_INTR_ENABLE, AT803X_WOL_ENABLE);\r\nstatus = phy_read(phydev, AT803X_INTR_STATUS);\r\nreturn 0;\r\n}\r\nstatic int __init atheros_init(void)\r\n{\r\nint ret;\r\nret = phy_driver_register(&at8035_driver);\r\nif (ret)\r\ngoto err1;\r\nret = phy_driver_register(&at8030_driver);\r\nif (ret)\r\ngoto err2;\r\nreturn 0;\r\nerr2:\r\nphy_driver_unregister(&at8035_driver);\r\nerr1:\r\nreturn ret;\r\n}\r\nstatic void __exit atheros_exit(void)\r\n{\r\nphy_driver_unregister(&at8035_driver);\r\nphy_driver_unregister(&at8030_driver);\r\n}
