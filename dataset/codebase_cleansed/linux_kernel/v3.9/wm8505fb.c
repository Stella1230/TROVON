static int wm8505fb_init_hw(struct fb_info *info)\r\n{\r\nstruct wm8505fb_info *fbi = to_wm8505fb_info(info);\r\nint i;\r\nfor (i = 0; i < 0x200; i += 4)\r\nwritel(0, fbi->regbase + i);\r\nwritel(fbi->fb.fix.smem_start, fbi->regbase + WMT_GOVR_FBADDR);\r\nwritel(fbi->fb.fix.smem_start, fbi->regbase + WMT_GOVR_FBADDR1);\r\nwritel(0x31c, fbi->regbase + WMT_GOVR_COLORSPACE);\r\nwritel(1, fbi->regbase + WMT_GOVR_COLORSPACE1);\r\nwritel(info->var.xres, fbi->regbase + WMT_GOVR_XRES);\r\nwritel(info->var.xres_virtual, fbi->regbase + WMT_GOVR_XRES_VIRTUAL);\r\nwritel(0xf, fbi->regbase + WMT_GOVR_FHI);\r\nwritel(4, fbi->regbase + WMT_GOVR_DVO_SET);\r\nwritel(1, fbi->regbase + WMT_GOVR_MIF_ENABLE);\r\nwritel(1, fbi->regbase + WMT_GOVR_REG_UPDATE);\r\nreturn 0;\r\n}\r\nstatic int wm8505fb_set_timing(struct fb_info *info)\r\n{\r\nstruct wm8505fb_info *fbi = to_wm8505fb_info(info);\r\nint h_start = info->var.left_margin;\r\nint h_end = h_start + info->var.xres;\r\nint h_all = h_end + info->var.right_margin;\r\nint h_sync = info->var.hsync_len;\r\nint v_start = info->var.upper_margin;\r\nint v_end = v_start + info->var.yres;\r\nint v_all = v_end + info->var.lower_margin;\r\nint v_sync = info->var.vsync_len;\r\nwritel(0, fbi->regbase + WMT_GOVR_TG);\r\nwritel(h_start, fbi->regbase + WMT_GOVR_TIMING_H_START);\r\nwritel(h_end, fbi->regbase + WMT_GOVR_TIMING_H_END);\r\nwritel(h_all, fbi->regbase + WMT_GOVR_TIMING_H_ALL);\r\nwritel(h_sync, fbi->regbase + WMT_GOVR_TIMING_H_SYNC);\r\nwritel(v_start, fbi->regbase + WMT_GOVR_TIMING_V_START);\r\nwritel(v_end, fbi->regbase + WMT_GOVR_TIMING_V_END);\r\nwritel(v_all, fbi->regbase + WMT_GOVR_TIMING_V_ALL);\r\nwritel(v_sync, fbi->regbase + WMT_GOVR_TIMING_V_SYNC);\r\nwritel(1, fbi->regbase + WMT_GOVR_TG);\r\nreturn 0;\r\n}\r\nstatic int wm8505fb_set_par(struct fb_info *info)\r\n{\r\nstruct wm8505fb_info *fbi = to_wm8505fb_info(info);\r\nif (!fbi)\r\nreturn -EINVAL;\r\nif (info->var.bits_per_pixel == 32) {\r\ninfo->var.red.offset = 16;\r\ninfo->var.red.length = 8;\r\ninfo->var.red.msb_right = 0;\r\ninfo->var.green.offset = 8;\r\ninfo->var.green.length = 8;\r\ninfo->var.green.msb_right = 0;\r\ninfo->var.blue.offset = 0;\r\ninfo->var.blue.length = 8;\r\ninfo->var.blue.msb_right = 0;\r\ninfo->fix.visual = FB_VISUAL_TRUECOLOR;\r\ninfo->fix.line_length = info->var.xres_virtual << 2;\r\n} else if (info->var.bits_per_pixel == 16) {\r\ninfo->var.red.offset = 11;\r\ninfo->var.red.length = 5;\r\ninfo->var.red.msb_right = 0;\r\ninfo->var.green.offset = 5;\r\ninfo->var.green.length = 6;\r\ninfo->var.green.msb_right = 0;\r\ninfo->var.blue.offset = 0;\r\ninfo->var.blue.length = 5;\r\ninfo->var.blue.msb_right = 0;\r\ninfo->fix.visual = FB_VISUAL_TRUECOLOR;\r\ninfo->fix.line_length = info->var.xres_virtual << 1;\r\n}\r\nwm8505fb_set_timing(info);\r\nwritel(fbi->contrast<<16 | fbi->contrast<<8 | fbi->contrast,\r\nfbi->regbase + WMT_GOVR_CONTRAST);\r\nreturn 0;\r\n}\r\nstatic ssize_t contrast_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct fb_info *info = dev_get_drvdata(dev);\r\nstruct wm8505fb_info *fbi = to_wm8505fb_info(info);\r\nreturn sprintf(buf, "%d\n", fbi->contrast);\r\n}\r\nstatic ssize_t contrast_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct fb_info *info = dev_get_drvdata(dev);\r\nstruct wm8505fb_info *fbi = to_wm8505fb_info(info);\r\nunsigned long tmp;\r\nif (strict_strtoul(buf, 10, &tmp) || (tmp > 0xff))\r\nreturn -EINVAL;\r\nfbi->contrast = tmp;\r\nwm8505fb_set_par(info);\r\nreturn count;\r\n}\r\nstatic inline u_int chan_to_field(u_int chan, struct fb_bitfield *bf)\r\n{\r\nchan &= 0xffff;\r\nchan >>= 16 - bf->length;\r\nreturn chan << bf->offset;\r\n}\r\nstatic int wm8505fb_setcolreg(unsigned regno, unsigned red, unsigned green,\r\nunsigned blue, unsigned transp,\r\nstruct fb_info *info) {\r\nstruct wm8505fb_info *fbi = to_wm8505fb_info(info);\r\nint ret = 1;\r\nunsigned int val;\r\nif (regno >= 256)\r\nreturn -EINVAL;\r\nif (info->var.grayscale)\r\nred = green = blue =\r\n(19595 * red + 38470 * green + 7471 * blue) >> 16;\r\nswitch (fbi->fb.fix.visual) {\r\ncase FB_VISUAL_TRUECOLOR:\r\nif (regno < 16) {\r\nu32 *pal = info->pseudo_palette;\r\nval = chan_to_field(red, &fbi->fb.var.red);\r\nval |= chan_to_field(green, &fbi->fb.var.green);\r\nval |= chan_to_field(blue, &fbi->fb.var.blue);\r\npal[regno] = val;\r\nret = 0;\r\n}\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int wm8505fb_pan_display(struct fb_var_screeninfo *var,\r\nstruct fb_info *info)\r\n{\r\nstruct wm8505fb_info *fbi = to_wm8505fb_info(info);\r\nwritel(var->xoffset, fbi->regbase + WMT_GOVR_XPAN);\r\nwritel(var->yoffset, fbi->regbase + WMT_GOVR_YPAN);\r\nreturn 0;\r\n}\r\nstatic int wm8505fb_blank(int blank, struct fb_info *info)\r\n{\r\nstruct wm8505fb_info *fbi = to_wm8505fb_info(info);\r\nswitch (blank) {\r\ncase FB_BLANK_UNBLANK:\r\nwm8505fb_set_timing(info);\r\nbreak;\r\ndefault:\r\nwritel(0, fbi->regbase + WMT_GOVR_TIMING_V_SYNC);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int wm8505fb_probe(struct platform_device *pdev)\r\n{\r\nstruct wm8505fb_info *fbi;\r\nstruct resource *res;\r\nvoid *addr;\r\nint ret;\r\nstruct fb_videomode of_mode;\r\nstruct device_node *np;\r\nu32 bpp;\r\ndma_addr_t fb_mem_phys;\r\nunsigned long fb_mem_len;\r\nvoid *fb_mem_virt;\r\nret = -ENOMEM;\r\nfbi = NULL;\r\nfbi = devm_kzalloc(&pdev->dev, sizeof(struct wm8505fb_info) +\r\nsizeof(u32) * 16, GFP_KERNEL);\r\nif (!fbi) {\r\ndev_err(&pdev->dev, "Failed to initialize framebuffer device\n");\r\nret = -ENOMEM;\r\ngoto failed;\r\n}\r\nstrcpy(fbi->fb.fix.id, DRIVER_NAME);\r\nfbi->fb.fix.type = FB_TYPE_PACKED_PIXELS;\r\nfbi->fb.fix.xpanstep = 1;\r\nfbi->fb.fix.ypanstep = 1;\r\nfbi->fb.fix.ywrapstep = 0;\r\nfbi->fb.fix.accel = FB_ACCEL_NONE;\r\nfbi->fb.fbops = &wm8505fb_ops;\r\nfbi->fb.flags = FBINFO_DEFAULT\r\n| FBINFO_HWACCEL_COPYAREA\r\n| FBINFO_HWACCEL_FILLRECT\r\n| FBINFO_HWACCEL_XPAN\r\n| FBINFO_HWACCEL_YPAN\r\n| FBINFO_VIRTFB\r\n| FBINFO_PARTIAL_PAN_OK;\r\nfbi->fb.node = -1;\r\naddr = fbi;\r\naddr = addr + sizeof(struct wm8505fb_info);\r\nfbi->fb.pseudo_palette = addr;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (res == NULL) {\r\ndev_err(&pdev->dev, "no I/O memory resource defined\n");\r\nret = -ENODEV;\r\ngoto failed_fbi;\r\n}\r\nres = request_mem_region(res->start, resource_size(res), DRIVER_NAME);\r\nif (res == NULL) {\r\ndev_err(&pdev->dev, "failed to request I/O memory\n");\r\nret = -EBUSY;\r\ngoto failed_fbi;\r\n}\r\nfbi->regbase = ioremap(res->start, resource_size(res));\r\nif (fbi->regbase == NULL) {\r\ndev_err(&pdev->dev, "failed to map I/O memory\n");\r\nret = -EBUSY;\r\ngoto failed_free_res;\r\n}\r\nnp = of_parse_phandle(pdev->dev.of_node, "default-mode", 0);\r\nif (!np) {\r\npr_err("%s: No display description in Device Tree\n", __func__);\r\nret = -EINVAL;\r\ngoto failed_free_res;\r\n}\r\nret = 0;\r\nret |= of_property_read_u32(np, "hactive", &of_mode.xres);\r\nret |= of_property_read_u32(np, "vactive", &of_mode.yres);\r\nret |= of_property_read_u32(np, "hback-porch", &of_mode.left_margin);\r\nret |= of_property_read_u32(np, "hfront-porch", &of_mode.right_margin);\r\nret |= of_property_read_u32(np, "hsync-len", &of_mode.hsync_len);\r\nret |= of_property_read_u32(np, "vback-porch", &of_mode.upper_margin);\r\nret |= of_property_read_u32(np, "vfront-porch", &of_mode.lower_margin);\r\nret |= of_property_read_u32(np, "vsync-len", &of_mode.vsync_len);\r\nret |= of_property_read_u32(np, "bpp", &bpp);\r\nif (ret) {\r\npr_err("%s: Unable to read display properties\n", __func__);\r\ngoto failed_free_res;\r\n}\r\nof_mode.vmode = FB_VMODE_NONINTERLACED;\r\nfb_videomode_to_var(&fbi->fb.var, &of_mode);\r\nfbi->fb.var.nonstd = 0;\r\nfbi->fb.var.activate = FB_ACTIVATE_NOW;\r\nfbi->fb.var.height = -1;\r\nfbi->fb.var.width = -1;\r\nfb_mem_len = of_mode.xres * of_mode.yres * 2 * (bpp / 8);\r\nfb_mem_virt = dma_alloc_coherent(&pdev->dev, fb_mem_len, &fb_mem_phys,\r\nGFP_KERNEL);\r\nif (!fb_mem_virt) {\r\npr_err("%s: Failed to allocate framebuffer\n", __func__);\r\nreturn -ENOMEM;\r\n};\r\nfbi->fb.var.xres_virtual = of_mode.xres;\r\nfbi->fb.var.yres_virtual = of_mode.yres * 2;\r\nfbi->fb.var.bits_per_pixel = bpp;\r\nfbi->fb.fix.smem_start = fb_mem_phys;\r\nfbi->fb.fix.smem_len = fb_mem_len;\r\nfbi->fb.screen_base = fb_mem_virt;\r\nfbi->fb.screen_size = fb_mem_len;\r\nif (fb_alloc_cmap(&fbi->fb.cmap, 256, 0) < 0) {\r\ndev_err(&pdev->dev, "Failed to allocate color map\n");\r\nret = -ENOMEM;\r\ngoto failed_free_io;\r\n}\r\nwm8505fb_init_hw(&fbi->fb);\r\nfbi->contrast = 0x80;\r\nret = wm8505fb_set_par(&fbi->fb);\r\nif (ret) {\r\ndev_err(&pdev->dev, "Failed to set parameters\n");\r\ngoto failed_free_cmap;\r\n}\r\nplatform_set_drvdata(pdev, fbi);\r\nret = register_framebuffer(&fbi->fb);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev,\r\n"Failed to register framebuffer device: %d\n", ret);\r\ngoto failed_free_cmap;\r\n}\r\nret = device_create_file(&pdev->dev, &dev_attr_contrast);\r\nif (ret < 0) {\r\nprintk(KERN_WARNING "fb%d: failed to register attributes (%d)\n",\r\nfbi->fb.node, ret);\r\n}\r\nprintk(KERN_INFO "fb%d: %s frame buffer at 0x%lx-0x%lx\n",\r\nfbi->fb.node, fbi->fb.fix.id, fbi->fb.fix.smem_start,\r\nfbi->fb.fix.smem_start + fbi->fb.fix.smem_len - 1);\r\nreturn 0;\r\nfailed_free_cmap:\r\nif (fbi->fb.cmap.len)\r\nfb_dealloc_cmap(&fbi->fb.cmap);\r\nfailed_free_io:\r\niounmap(fbi->regbase);\r\nfailed_free_res:\r\nrelease_mem_region(res->start, resource_size(res));\r\nfailed_fbi:\r\nplatform_set_drvdata(pdev, NULL);\r\nkfree(fbi);\r\nfailed:\r\nreturn ret;\r\n}\r\nstatic int wm8505fb_remove(struct platform_device *pdev)\r\n{\r\nstruct wm8505fb_info *fbi = platform_get_drvdata(pdev);\r\nstruct resource *res;\r\ndevice_remove_file(&pdev->dev, &dev_attr_contrast);\r\nunregister_framebuffer(&fbi->fb);\r\nwritel(0, fbi->regbase);\r\nif (fbi->fb.cmap.len)\r\nfb_dealloc_cmap(&fbi->fb.cmap);\r\niounmap(fbi->regbase);\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nrelease_mem_region(res->start, resource_size(res));\r\nkfree(fbi);\r\nreturn 0;\r\n}
