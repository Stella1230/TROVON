static void\r\neesoxscsi_irqenable(struct expansion_card *ec, int irqnr)\r\n{\r\nstruct eesoxscsi_info *info = (struct eesoxscsi_info *)ec->irq_data;\r\ninfo->control |= EESOX_INTR_ENABLE;\r\nwriteb(info->control, info->ctl_port);\r\n}\r\nstatic void\r\neesoxscsi_irqdisable(struct expansion_card *ec, int irqnr)\r\n{\r\nstruct eesoxscsi_info *info = (struct eesoxscsi_info *)ec->irq_data;\r\ninfo->control &= ~EESOX_INTR_ENABLE;\r\nwriteb(info->control, info->ctl_port);\r\n}\r\nstatic void\r\neesoxscsi_terminator_ctl(struct Scsi_Host *host, int on_off)\r\n{\r\nstruct eesoxscsi_info *info = (struct eesoxscsi_info *)host->hostdata;\r\nunsigned long flags;\r\nspin_lock_irqsave(host->host_lock, flags);\r\nif (on_off)\r\ninfo->control |= EESOX_TERM_ENABLE;\r\nelse\r\ninfo->control &= ~EESOX_TERM_ENABLE;\r\nwriteb(info->control, info->ctl_port);\r\nspin_unlock_irqrestore(host->host_lock, flags);\r\n}\r\nstatic irqreturn_t\r\neesoxscsi_intr(int irq, void *dev_id)\r\n{\r\nstruct eesoxscsi_info *info = dev_id;\r\nreturn fas216_intr(&info->info);\r\n}\r\nstatic fasdmatype_t\r\neesoxscsi_dma_setup(struct Scsi_Host *host, struct scsi_pointer *SCp,\r\nfasdmadir_t direction, fasdmatype_t min_type)\r\n{\r\nstruct eesoxscsi_info *info = (struct eesoxscsi_info *)host->hostdata;\r\nstruct device *dev = scsi_get_device(host);\r\nint dmach = info->info.scsi.dma;\r\nif (dmach != NO_DMA &&\r\n(min_type == fasdma_real_all || SCp->this_residual >= 512)) {\r\nint bufs, map_dir, dma_dir;\r\nbufs = copy_SCp_to_sg(&info->sg[0], SCp, NR_SG);\r\nif (direction == DMA_OUT)\r\nmap_dir = DMA_TO_DEVICE,\r\ndma_dir = DMA_MODE_WRITE;\r\nelse\r\nmap_dir = DMA_FROM_DEVICE,\r\ndma_dir = DMA_MODE_READ;\r\ndma_map_sg(dev, info->sg, bufs, map_dir);\r\ndisable_dma(dmach);\r\nset_dma_sg(dmach, info->sg, bufs);\r\nset_dma_mode(dmach, dma_dir);\r\nenable_dma(dmach);\r\nreturn fasdma_real_all;\r\n}\r\nreturn fasdma_pseudo;\r\n}\r\nstatic void eesoxscsi_buffer_in(void *buf, int length, void __iomem *base)\r\n{\r\nconst void __iomem *reg_fas = base + EESOX_FAS216_OFFSET;\r\nconst void __iomem *reg_dmastat = base + EESOX_DMASTAT;\r\nconst void __iomem *reg_dmadata = base + EESOX_DMADATA;\r\nregister const unsigned long mask = 0xffff;\r\ndo {\r\nunsigned int status;\r\nstatus = readb(reg_fas + (REG_STAT << EESOX_FAS216_SHIFT));\r\nif (status & STAT_INT)\r\nbreak;\r\nstatus = readb(reg_dmastat);\r\nif (!(status & EESOX_STAT_DMA))\r\ncontinue;\r\nstatus = readb(reg_fas + (REG_CFIS << EESOX_FAS216_SHIFT)) & CFIS_CF;\r\nif (status > 16)\r\nstatus = 16;\r\nif (status > length)\r\nstatus = length;\r\nif (((u32)buf) & 2 && status >= 2) {\r\n*(u16 *)buf = readl(reg_dmadata);\r\nbuf += 2;\r\nstatus -= 2;\r\nlength -= 2;\r\n}\r\nif (status >= 8) {\r\nunsigned long l1, l2;\r\nl1 = readl(reg_dmadata) & mask;\r\nl1 |= readl(reg_dmadata) << 16;\r\nl2 = readl(reg_dmadata) & mask;\r\nl2 |= readl(reg_dmadata) << 16;\r\n*(u32 *)buf = l1;\r\nbuf += 4;\r\n*(u32 *)buf = l2;\r\nbuf += 4;\r\nlength -= 8;\r\ncontinue;\r\n}\r\nif (status >= 4) {\r\nunsigned long l1;\r\nl1 = readl(reg_dmadata) & mask;\r\nl1 |= readl(reg_dmadata) << 16;\r\n*(u32 *)buf = l1;\r\nbuf += 4;\r\nlength -= 4;\r\ncontinue;\r\n}\r\nif (status >= 2) {\r\n*(u16 *)buf = readl(reg_dmadata);\r\nbuf += 2;\r\nlength -= 2;\r\n}\r\n} while (length);\r\n}\r\nstatic void eesoxscsi_buffer_out(void *buf, int length, void __iomem *base)\r\n{\r\nconst void __iomem *reg_fas = base + EESOX_FAS216_OFFSET;\r\nconst void __iomem *reg_dmastat = base + EESOX_DMASTAT;\r\nvoid __iomem *reg_dmadata = base + EESOX_DMADATA;\r\ndo {\r\nunsigned int status;\r\nstatus = readb(reg_fas + (REG_STAT << EESOX_FAS216_SHIFT));\r\nif (status & STAT_INT)\r\nbreak;\r\nstatus = readb(reg_dmastat);\r\nif (!(status & EESOX_STAT_DMA))\r\ncontinue;\r\nstatus = readb(reg_fas + (REG_CFIS << EESOX_FAS216_SHIFT)) & CFIS_CF;\r\nif (status > 16)\r\nstatus = 16;\r\nstatus = 16 - status;\r\nif (status > length)\r\nstatus = length;\r\nstatus &= ~1;\r\nif (((u32)buf) & 2 && status >= 2) {\r\nwritel(*(u16 *)buf << 16, reg_dmadata);\r\nbuf += 2;\r\nstatus -= 2;\r\nlength -= 2;\r\n}\r\nif (status >= 8) {\r\nunsigned long l1, l2;\r\nl1 = *(u32 *)buf;\r\nbuf += 4;\r\nl2 = *(u32 *)buf;\r\nbuf += 4;\r\nwritel(l1 << 16, reg_dmadata);\r\nwritel(l1, reg_dmadata);\r\nwritel(l2 << 16, reg_dmadata);\r\nwritel(l2, reg_dmadata);\r\nlength -= 8;\r\ncontinue;\r\n}\r\nif (status >= 4) {\r\nunsigned long l1;\r\nl1 = *(u32 *)buf;\r\nbuf += 4;\r\nwritel(l1 << 16, reg_dmadata);\r\nwritel(l1, reg_dmadata);\r\nlength -= 4;\r\ncontinue;\r\n}\r\nif (status >= 2) {\r\nwritel(*(u16 *)buf << 16, reg_dmadata);\r\nbuf += 2;\r\nlength -= 2;\r\n}\r\n} while (length);\r\n}\r\nstatic void\r\neesoxscsi_dma_pseudo(struct Scsi_Host *host, struct scsi_pointer *SCp,\r\nfasdmadir_t dir, int transfer_size)\r\n{\r\nstruct eesoxscsi_info *info = (struct eesoxscsi_info *)host->hostdata;\r\nif (dir == DMA_IN) {\r\neesoxscsi_buffer_in(SCp->ptr, SCp->this_residual, info->base);\r\n} else {\r\neesoxscsi_buffer_out(SCp->ptr, SCp->this_residual, info->base);\r\n}\r\n}\r\nstatic void\r\neesoxscsi_dma_stop(struct Scsi_Host *host, struct scsi_pointer *SCp)\r\n{\r\nstruct eesoxscsi_info *info = (struct eesoxscsi_info *)host->hostdata;\r\nif (info->info.scsi.dma != NO_DMA)\r\ndisable_dma(info->info.scsi.dma);\r\n}\r\nconst char *eesoxscsi_info(struct Scsi_Host *host)\r\n{\r\nstruct eesoxscsi_info *info = (struct eesoxscsi_info *)host->hostdata;\r\nstatic char string[150];\r\nsprintf(string, "%s (%s) in slot %d v%s terminators o%s",\r\nhost->hostt->name, info->info.scsi.type, info->ec->slot_no,\r\nVERSION, info->control & EESOX_TERM_ENABLE ? "n" : "ff");\r\nreturn string;\r\n}\r\nstatic int\r\neesoxscsi_set_proc_info(struct Scsi_Host *host, char *buffer, int length)\r\n{\r\nint ret = length;\r\nif (length >= 9 && strncmp(buffer, "EESOXSCSI", 9) == 0) {\r\nbuffer += 9;\r\nlength -= 9;\r\nif (length >= 5 && strncmp(buffer, "term=", 5) == 0) {\r\nif (buffer[5] == '1')\r\neesoxscsi_terminator_ctl(host, 1);\r\nelse if (buffer[5] == '0')\r\neesoxscsi_terminator_ctl(host, 0);\r\nelse\r\nret = -EINVAL;\r\n} else\r\nret = -EINVAL;\r\n} else\r\nret = -EINVAL;\r\nreturn ret;\r\n}\r\nint eesoxscsi_proc_info(struct Scsi_Host *host, char *buffer, char **start, off_t offset,\r\nint length, int inout)\r\n{\r\nstruct eesoxscsi_info *info;\r\nchar *p = buffer;\r\nint pos;\r\nif (inout == 1)\r\nreturn eesoxscsi_set_proc_info(host, buffer, length);\r\ninfo = (struct eesoxscsi_info *)host->hostdata;\r\np += sprintf(p, "EESOX SCSI driver v%s\n", VERSION);\r\np += fas216_print_host(&info->info, p);\r\np += sprintf(p, "Term : o%s\n",\r\ninfo->control & EESOX_TERM_ENABLE ? "n" : "ff");\r\np += fas216_print_stats(&info->info, p);\r\np += fas216_print_devices(&info->info, p);\r\n*start = buffer + offset;\r\npos = p - buffer - offset;\r\nif (pos > length)\r\npos = length;\r\nreturn pos;\r\n}\r\nstatic ssize_t eesoxscsi_show_term(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct expansion_card *ec = ECARD_DEV(dev);\r\nstruct Scsi_Host *host = ecard_get_drvdata(ec);\r\nstruct eesoxscsi_info *info = (struct eesoxscsi_info *)host->hostdata;\r\nreturn sprintf(buf, "%d\n", info->control & EESOX_TERM_ENABLE ? 1 : 0);\r\n}\r\nstatic ssize_t eesoxscsi_store_term(struct device *dev, struct device_attribute *attr, const char *buf, size_t len)\r\n{\r\nstruct expansion_card *ec = ECARD_DEV(dev);\r\nstruct Scsi_Host *host = ecard_get_drvdata(ec);\r\nstruct eesoxscsi_info *info = (struct eesoxscsi_info *)host->hostdata;\r\nunsigned long flags;\r\nif (len > 1) {\r\nspin_lock_irqsave(host->host_lock, flags);\r\nif (buf[0] != '0') {\r\ninfo->control |= EESOX_TERM_ENABLE;\r\n} else {\r\ninfo->control &= ~EESOX_TERM_ENABLE;\r\n}\r\nwriteb(info->control, info->ctl_port);\r\nspin_unlock_irqrestore(host->host_lock, flags);\r\n}\r\nreturn len;\r\n}\r\nstatic int eesoxscsi_probe(struct expansion_card *ec, const struct ecard_id *id)\r\n{\r\nstruct Scsi_Host *host;\r\nstruct eesoxscsi_info *info;\r\nvoid __iomem *base;\r\nint ret;\r\nret = ecard_request_resources(ec);\r\nif (ret)\r\ngoto out;\r\nbase = ecardm_iomap(ec, ECARD_RES_IOCFAST, 0, 0);\r\nif (!base) {\r\nret = -ENOMEM;\r\ngoto out_region;\r\n}\r\nhost = scsi_host_alloc(&eesox_template,\r\nsizeof(struct eesoxscsi_info));\r\nif (!host) {\r\nret = -ENOMEM;\r\ngoto out_region;\r\n}\r\necard_set_drvdata(ec, host);\r\ninfo = (struct eesoxscsi_info *)host->hostdata;\r\ninfo->ec = ec;\r\ninfo->base = base;\r\ninfo->ctl_port = base + EESOX_CONTROL;\r\ninfo->control = term[ec->slot_no] ? EESOX_TERM_ENABLE : 0;\r\nwriteb(info->control, info->ctl_port);\r\ninfo->info.scsi.io_base = base + EESOX_FAS216_OFFSET;\r\ninfo->info.scsi.io_shift = EESOX_FAS216_SHIFT;\r\ninfo->info.scsi.irq = ec->irq;\r\ninfo->info.scsi.dma = ec->dma;\r\ninfo->info.ifcfg.clockrate = 40;\r\ninfo->info.ifcfg.select_timeout = 255;\r\ninfo->info.ifcfg.asyncperiod = 200;\r\ninfo->info.ifcfg.sync_max_depth = 7;\r\ninfo->info.ifcfg.cntl3 = CNTL3_FASTSCSI | CNTL3_FASTCLK;\r\ninfo->info.ifcfg.disconnect_ok = 1;\r\ninfo->info.ifcfg.wide_max_size = 0;\r\ninfo->info.ifcfg.capabilities = FASCAP_PSEUDODMA;\r\ninfo->info.dma.setup = eesoxscsi_dma_setup;\r\ninfo->info.dma.pseudo = eesoxscsi_dma_pseudo;\r\ninfo->info.dma.stop = eesoxscsi_dma_stop;\r\nec->irqaddr = base + EESOX_DMASTAT;\r\nec->irqmask = EESOX_STAT_INTR;\r\necard_setirq(ec, &eesoxscsi_ops, info);\r\ndevice_create_file(&ec->dev, &dev_attr_bus_term);\r\nret = fas216_init(host);\r\nif (ret)\r\ngoto out_free;\r\nret = request_irq(ec->irq, eesoxscsi_intr, 0, "eesoxscsi", info);\r\nif (ret) {\r\nprintk("scsi%d: IRQ%d not free: %d\n",\r\nhost->host_no, ec->irq, ret);\r\ngoto out_remove;\r\n}\r\nif (info->info.scsi.dma != NO_DMA) {\r\nif (request_dma(info->info.scsi.dma, "eesox")) {\r\nprintk("scsi%d: DMA%d not free, DMA disabled\n",\r\nhost->host_no, info->info.scsi.dma);\r\ninfo->info.scsi.dma = NO_DMA;\r\n} else {\r\nset_dma_speed(info->info.scsi.dma, 180);\r\ninfo->info.ifcfg.capabilities |= FASCAP_DMA;\r\ninfo->info.ifcfg.cntl3 |= CNTL3_BS8;\r\n}\r\n}\r\nret = fas216_add(host, &ec->dev);\r\nif (ret == 0)\r\ngoto out;\r\nif (info->info.scsi.dma != NO_DMA)\r\nfree_dma(info->info.scsi.dma);\r\nfree_irq(ec->irq, host);\r\nout_remove:\r\nfas216_remove(host);\r\nout_free:\r\ndevice_remove_file(&ec->dev, &dev_attr_bus_term);\r\nscsi_host_put(host);\r\nout_region:\r\necard_release_resources(ec);\r\nout:\r\nreturn ret;\r\n}\r\nstatic void eesoxscsi_remove(struct expansion_card *ec)\r\n{\r\nstruct Scsi_Host *host = ecard_get_drvdata(ec);\r\nstruct eesoxscsi_info *info = (struct eesoxscsi_info *)host->hostdata;\r\necard_set_drvdata(ec, NULL);\r\nfas216_remove(host);\r\nif (info->info.scsi.dma != NO_DMA)\r\nfree_dma(info->info.scsi.dma);\r\nfree_irq(ec->irq, info);\r\ndevice_remove_file(&ec->dev, &dev_attr_bus_term);\r\nfas216_release(host);\r\nscsi_host_put(host);\r\necard_release_resources(ec);\r\n}\r\nstatic int __init eesox_init(void)\r\n{\r\nreturn ecard_register_driver(&eesoxscsi_driver);\r\n}\r\nstatic void __exit eesox_exit(void)\r\n{\r\necard_remove_driver(&eesoxscsi_driver);\r\n}
