static int smiapp_read_frame_fmt(struct smiapp_sensor *sensor)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(&sensor->src->sd);\r\nu32 fmt_model_type, fmt_model_subtype, ncol_desc, nrow_desc;\r\nunsigned int i;\r\nint rval;\r\nint line_count = 0;\r\nint embedded_start = -1, embedded_end = -1;\r\nint image_start = 0;\r\nrval = smiapp_read(sensor, SMIAPP_REG_U8_FRAME_FORMAT_MODEL_TYPE,\r\n&fmt_model_type);\r\nif (rval)\r\nreturn rval;\r\nrval = smiapp_read(sensor, SMIAPP_REG_U8_FRAME_FORMAT_MODEL_SUBTYPE,\r\n&fmt_model_subtype);\r\nif (rval)\r\nreturn rval;\r\nncol_desc = (fmt_model_subtype\r\n& SMIAPP_FRAME_FORMAT_MODEL_SUBTYPE_NCOLS_MASK)\r\n>> SMIAPP_FRAME_FORMAT_MODEL_SUBTYPE_NCOLS_SHIFT;\r\nnrow_desc = fmt_model_subtype\r\n& SMIAPP_FRAME_FORMAT_MODEL_SUBTYPE_NROWS_MASK;\r\ndev_dbg(&client->dev, "format_model_type %s\n",\r\nfmt_model_type == SMIAPP_FRAME_FORMAT_MODEL_TYPE_2BYTE\r\n? "2 byte" :\r\nfmt_model_type == SMIAPP_FRAME_FORMAT_MODEL_TYPE_4BYTE\r\n? "4 byte" : "is simply bad");\r\nfor (i = 0; i < ncol_desc + nrow_desc; i++) {\r\nu32 desc;\r\nu32 pixelcode;\r\nu32 pixels;\r\nchar *which;\r\nchar *what;\r\nif (fmt_model_type == SMIAPP_FRAME_FORMAT_MODEL_TYPE_2BYTE) {\r\nrval = smiapp_read(\r\nsensor,\r\nSMIAPP_REG_U16_FRAME_FORMAT_DESCRIPTOR_2(i),\r\n&desc);\r\nif (rval)\r\nreturn rval;\r\npixelcode =\r\n(desc\r\n& SMIAPP_FRAME_FORMAT_DESC_2_PIXELCODE_MASK)\r\n>> SMIAPP_FRAME_FORMAT_DESC_2_PIXELCODE_SHIFT;\r\npixels = desc & SMIAPP_FRAME_FORMAT_DESC_2_PIXELS_MASK;\r\n} else if (fmt_model_type\r\n== SMIAPP_FRAME_FORMAT_MODEL_TYPE_4BYTE) {\r\nrval = smiapp_read(\r\nsensor,\r\nSMIAPP_REG_U32_FRAME_FORMAT_DESCRIPTOR_4(i),\r\n&desc);\r\nif (rval)\r\nreturn rval;\r\npixelcode =\r\n(desc\r\n& SMIAPP_FRAME_FORMAT_DESC_4_PIXELCODE_MASK)\r\n>> SMIAPP_FRAME_FORMAT_DESC_4_PIXELCODE_SHIFT;\r\npixels = desc & SMIAPP_FRAME_FORMAT_DESC_4_PIXELS_MASK;\r\n} else {\r\ndev_dbg(&client->dev,\r\n"invalid frame format model type %d\n",\r\nfmt_model_type);\r\nreturn -EINVAL;\r\n}\r\nif (i < ncol_desc)\r\nwhich = "columns";\r\nelse\r\nwhich = "rows";\r\nswitch (pixelcode) {\r\ncase SMIAPP_FRAME_FORMAT_DESC_PIXELCODE_EMBEDDED:\r\nwhat = "embedded";\r\nbreak;\r\ncase SMIAPP_FRAME_FORMAT_DESC_PIXELCODE_DUMMY:\r\nwhat = "dummy";\r\nbreak;\r\ncase SMIAPP_FRAME_FORMAT_DESC_PIXELCODE_BLACK:\r\nwhat = "black";\r\nbreak;\r\ncase SMIAPP_FRAME_FORMAT_DESC_PIXELCODE_DARK:\r\nwhat = "dark";\r\nbreak;\r\ncase SMIAPP_FRAME_FORMAT_DESC_PIXELCODE_VISIBLE:\r\nwhat = "visible";\r\nbreak;\r\ndefault:\r\nwhat = "invalid";\r\ndev_dbg(&client->dev, "pixelcode %d\n", pixelcode);\r\nbreak;\r\n}\r\ndev_dbg(&client->dev, "%s pixels: %d %s\n",\r\nwhat, pixels, which);\r\nif (i < ncol_desc)\r\ncontinue;\r\nif (pixelcode\r\n== SMIAPP_FRAME_FORMAT_DESC_PIXELCODE_EMBEDDED) {\r\nembedded_start = line_count;\r\n} else {\r\nif (pixelcode == SMIAPP_FRAME_FORMAT_DESC_PIXELCODE_VISIBLE\r\n|| pixels >= sensor->limits[SMIAPP_LIMIT_MIN_FRAME_LENGTH_LINES] / 2)\r\nimage_start = line_count;\r\nif (embedded_start != -1 && embedded_end == -1)\r\nembedded_end = line_count;\r\n}\r\nline_count += pixels;\r\n}\r\nif (embedded_start == -1 || embedded_end == -1) {\r\nembedded_start = 0;\r\nembedded_end = 0;\r\n}\r\ndev_dbg(&client->dev, "embedded data from lines %d to %d\n",\r\nembedded_start, embedded_end);\r\ndev_dbg(&client->dev, "image data starts at line %d\n", image_start);\r\nreturn 0;\r\n}\r\nstatic int smiapp_pll_configure(struct smiapp_sensor *sensor)\r\n{\r\nstruct smiapp_pll *pll = &sensor->pll;\r\nint rval;\r\nrval = smiapp_write(\r\nsensor, SMIAPP_REG_U16_VT_PIX_CLK_DIV, pll->vt_pix_clk_div);\r\nif (rval < 0)\r\nreturn rval;\r\nrval = smiapp_write(\r\nsensor, SMIAPP_REG_U16_VT_SYS_CLK_DIV, pll->vt_sys_clk_div);\r\nif (rval < 0)\r\nreturn rval;\r\nrval = smiapp_write(\r\nsensor, SMIAPP_REG_U16_PRE_PLL_CLK_DIV, pll->pre_pll_clk_div);\r\nif (rval < 0)\r\nreturn rval;\r\nrval = smiapp_write(\r\nsensor, SMIAPP_REG_U16_PLL_MULTIPLIER, pll->pll_multiplier);\r\nif (rval < 0)\r\nreturn rval;\r\nrval = smiapp_write(\r\nsensor, SMIAPP_REG_U32_REQUESTED_LINK_BIT_RATE_MBPS,\r\nDIV_ROUND_UP(pll->op_sys_clk_freq_hz, 1000000 / 256 / 256));\r\nif (rval < 0 || sensor->minfo.smiapp_profile == SMIAPP_PROFILE_0)\r\nreturn rval;\r\nrval = smiapp_write(\r\nsensor, SMIAPP_REG_U16_OP_PIX_CLK_DIV, pll->op_pix_clk_div);\r\nif (rval < 0)\r\nreturn rval;\r\nreturn smiapp_write(\r\nsensor, SMIAPP_REG_U16_OP_SYS_CLK_DIV, pll->op_sys_clk_div);\r\n}\r\nstatic int smiapp_pll_update(struct smiapp_sensor *sensor)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(&sensor->src->sd);\r\nstruct smiapp_pll_limits lim = {\r\n.min_pre_pll_clk_div = sensor->limits[SMIAPP_LIMIT_MIN_PRE_PLL_CLK_DIV],\r\n.max_pre_pll_clk_div = sensor->limits[SMIAPP_LIMIT_MAX_PRE_PLL_CLK_DIV],\r\n.min_pll_ip_freq_hz = sensor->limits[SMIAPP_LIMIT_MIN_PLL_IP_FREQ_HZ],\r\n.max_pll_ip_freq_hz = sensor->limits[SMIAPP_LIMIT_MAX_PLL_IP_FREQ_HZ],\r\n.min_pll_multiplier = sensor->limits[SMIAPP_LIMIT_MIN_PLL_MULTIPLIER],\r\n.max_pll_multiplier = sensor->limits[SMIAPP_LIMIT_MAX_PLL_MULTIPLIER],\r\n.min_pll_op_freq_hz = sensor->limits[SMIAPP_LIMIT_MIN_PLL_OP_FREQ_HZ],\r\n.max_pll_op_freq_hz = sensor->limits[SMIAPP_LIMIT_MAX_PLL_OP_FREQ_HZ],\r\n.op.min_sys_clk_div = sensor->limits[SMIAPP_LIMIT_MIN_OP_SYS_CLK_DIV],\r\n.op.max_sys_clk_div = sensor->limits[SMIAPP_LIMIT_MAX_OP_SYS_CLK_DIV],\r\n.op.min_pix_clk_div = sensor->limits[SMIAPP_LIMIT_MIN_OP_PIX_CLK_DIV],\r\n.op.max_pix_clk_div = sensor->limits[SMIAPP_LIMIT_MAX_OP_PIX_CLK_DIV],\r\n.op.min_sys_clk_freq_hz = sensor->limits[SMIAPP_LIMIT_MIN_OP_SYS_CLK_FREQ_HZ],\r\n.op.max_sys_clk_freq_hz = sensor->limits[SMIAPP_LIMIT_MAX_OP_SYS_CLK_FREQ_HZ],\r\n.op.min_pix_clk_freq_hz = sensor->limits[SMIAPP_LIMIT_MIN_OP_PIX_CLK_FREQ_HZ],\r\n.op.max_pix_clk_freq_hz = sensor->limits[SMIAPP_LIMIT_MAX_OP_PIX_CLK_FREQ_HZ],\r\n.vt.min_sys_clk_div = sensor->limits[SMIAPP_LIMIT_MIN_VT_SYS_CLK_DIV],\r\n.vt.max_sys_clk_div = sensor->limits[SMIAPP_LIMIT_MAX_VT_SYS_CLK_DIV],\r\n.vt.min_pix_clk_div = sensor->limits[SMIAPP_LIMIT_MIN_VT_PIX_CLK_DIV],\r\n.vt.max_pix_clk_div = sensor->limits[SMIAPP_LIMIT_MAX_VT_PIX_CLK_DIV],\r\n.vt.min_sys_clk_freq_hz = sensor->limits[SMIAPP_LIMIT_MIN_VT_SYS_CLK_FREQ_HZ],\r\n.vt.max_sys_clk_freq_hz = sensor->limits[SMIAPP_LIMIT_MAX_VT_SYS_CLK_FREQ_HZ],\r\n.vt.min_pix_clk_freq_hz = sensor->limits[SMIAPP_LIMIT_MIN_VT_PIX_CLK_FREQ_HZ],\r\n.vt.max_pix_clk_freq_hz = sensor->limits[SMIAPP_LIMIT_MAX_VT_PIX_CLK_FREQ_HZ],\r\n.min_line_length_pck_bin = sensor->limits[SMIAPP_LIMIT_MIN_LINE_LENGTH_PCK_BIN],\r\n.min_line_length_pck = sensor->limits[SMIAPP_LIMIT_MIN_LINE_LENGTH_PCK],\r\n};\r\nstruct smiapp_pll *pll = &sensor->pll;\r\nint rval;\r\nif (sensor->minfo.smiapp_profile == SMIAPP_PROFILE_0) {\r\nlim.op = lim.vt;\r\n}\r\npll->binning_horizontal = sensor->binning_horizontal;\r\npll->binning_vertical = sensor->binning_vertical;\r\npll->link_freq =\r\nsensor->link_freq->qmenu_int[sensor->link_freq->val];\r\npll->scale_m = sensor->scale_m;\r\npll->bits_per_pixel = sensor->csi_format->compressed;\r\nrval = smiapp_pll_calculate(&client->dev, &lim, pll);\r\nif (rval < 0)\r\nreturn rval;\r\nsensor->pixel_rate_parray->cur.val64 = pll->vt_pix_clk_freq_hz;\r\nsensor->pixel_rate_csi->cur.val64 = pll->pixel_rate_csi;\r\nreturn 0;\r\n}\r\nstatic void __smiapp_update_exposure_limits(struct smiapp_sensor *sensor)\r\n{\r\nstruct v4l2_ctrl *ctrl = sensor->exposure;\r\nint max;\r\nmax = sensor->pixel_array->crop[SMIAPP_PA_PAD_SRC].height\r\n+ sensor->vblank->val\r\n- sensor->limits[SMIAPP_LIMIT_COARSE_INTEGRATION_TIME_MAX_MARGIN];\r\nctrl->maximum = max;\r\nif (ctrl->default_value > max)\r\nctrl->default_value = max;\r\nif (ctrl->val > max)\r\nctrl->val = max;\r\nif (ctrl->cur.val > max)\r\nctrl->cur.val = max;\r\n}\r\nstatic u32 smiapp_pixel_order(struct smiapp_sensor *sensor)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(&sensor->src->sd);\r\nint flip = 0;\r\nif (sensor->hflip) {\r\nif (sensor->hflip->val)\r\nflip |= SMIAPP_IMAGE_ORIENTATION_HFLIP;\r\nif (sensor->vflip->val)\r\nflip |= SMIAPP_IMAGE_ORIENTATION_VFLIP;\r\n}\r\nflip ^= sensor->hvflip_inv_mask;\r\ndev_dbg(&client->dev, "flip %d\n", flip);\r\nreturn sensor->default_pixel_order ^ flip;\r\n}\r\nstatic void smiapp_update_mbus_formats(struct smiapp_sensor *sensor)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(&sensor->src->sd);\r\nunsigned int csi_format_idx =\r\nto_csi_format_idx(sensor->csi_format) & ~3;\r\nunsigned int internal_csi_format_idx =\r\nto_csi_format_idx(sensor->internal_csi_format) & ~3;\r\nunsigned int pixel_order = smiapp_pixel_order(sensor);\r\nsensor->mbus_frame_fmts =\r\nsensor->default_mbus_frame_fmts << pixel_order;\r\nsensor->csi_format =\r\n&smiapp_csi_data_formats[csi_format_idx + pixel_order];\r\nsensor->internal_csi_format =\r\n&smiapp_csi_data_formats[internal_csi_format_idx\r\n+ pixel_order];\r\nBUG_ON(max(internal_csi_format_idx, csi_format_idx) + pixel_order\r\n>= ARRAY_SIZE(smiapp_csi_data_formats));\r\nBUG_ON(min(internal_csi_format_idx, csi_format_idx) < 0);\r\ndev_dbg(&client->dev, "new pixel order %s\n",\r\npixel_order_str[pixel_order]);\r\n}\r\nstatic int smiapp_set_ctrl(struct v4l2_ctrl *ctrl)\r\n{\r\nstruct smiapp_sensor *sensor =\r\ncontainer_of(ctrl->handler, struct smiapp_subdev, ctrl_handler)\r\n->sensor;\r\nu32 orient = 0;\r\nint exposure;\r\nint rval;\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_ANALOGUE_GAIN:\r\nreturn smiapp_write(\r\nsensor,\r\nSMIAPP_REG_U16_ANALOGUE_GAIN_CODE_GLOBAL, ctrl->val);\r\ncase V4L2_CID_EXPOSURE:\r\nreturn smiapp_write(\r\nsensor,\r\nSMIAPP_REG_U16_COARSE_INTEGRATION_TIME, ctrl->val);\r\ncase V4L2_CID_HFLIP:\r\ncase V4L2_CID_VFLIP:\r\nif (sensor->streaming)\r\nreturn -EBUSY;\r\nif (sensor->hflip->val)\r\norient |= SMIAPP_IMAGE_ORIENTATION_HFLIP;\r\nif (sensor->vflip->val)\r\norient |= SMIAPP_IMAGE_ORIENTATION_VFLIP;\r\norient ^= sensor->hvflip_inv_mask;\r\nrval = smiapp_write(sensor,\r\nSMIAPP_REG_U8_IMAGE_ORIENTATION,\r\norient);\r\nif (rval < 0)\r\nreturn rval;\r\nsmiapp_update_mbus_formats(sensor);\r\nreturn 0;\r\ncase V4L2_CID_VBLANK:\r\nexposure = sensor->exposure->val;\r\n__smiapp_update_exposure_limits(sensor);\r\nif (exposure > sensor->exposure->maximum) {\r\nsensor->exposure->val =\r\nsensor->exposure->maximum;\r\nrval = smiapp_set_ctrl(\r\nsensor->exposure);\r\nif (rval < 0)\r\nreturn rval;\r\n}\r\nreturn smiapp_write(\r\nsensor, SMIAPP_REG_U16_FRAME_LENGTH_LINES,\r\nsensor->pixel_array->crop[SMIAPP_PA_PAD_SRC].height\r\n+ ctrl->val);\r\ncase V4L2_CID_HBLANK:\r\nreturn smiapp_write(\r\nsensor, SMIAPP_REG_U16_LINE_LENGTH_PCK,\r\nsensor->pixel_array->crop[SMIAPP_PA_PAD_SRC].width\r\n+ ctrl->val);\r\ncase V4L2_CID_LINK_FREQ:\r\nif (sensor->streaming)\r\nreturn -EBUSY;\r\nreturn smiapp_pll_update(sensor);\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic int smiapp_init_controls(struct smiapp_sensor *sensor)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(&sensor->src->sd);\r\nunsigned int max;\r\nint rval;\r\nrval = v4l2_ctrl_handler_init(&sensor->pixel_array->ctrl_handler, 7);\r\nif (rval)\r\nreturn rval;\r\nsensor->pixel_array->ctrl_handler.lock = &sensor->mutex;\r\nsensor->analog_gain = v4l2_ctrl_new_std(\r\n&sensor->pixel_array->ctrl_handler, &smiapp_ctrl_ops,\r\nV4L2_CID_ANALOGUE_GAIN,\r\nsensor->limits[SMIAPP_LIMIT_ANALOGUE_GAIN_CODE_MIN],\r\nsensor->limits[SMIAPP_LIMIT_ANALOGUE_GAIN_CODE_MAX],\r\nmax(sensor->limits[SMIAPP_LIMIT_ANALOGUE_GAIN_CODE_STEP], 1U),\r\nsensor->limits[SMIAPP_LIMIT_ANALOGUE_GAIN_CODE_MIN]);\r\nsensor->exposure = v4l2_ctrl_new_std(\r\n&sensor->pixel_array->ctrl_handler, &smiapp_ctrl_ops,\r\nV4L2_CID_EXPOSURE, 0, 0, 1, 0);\r\nsensor->hflip = v4l2_ctrl_new_std(\r\n&sensor->pixel_array->ctrl_handler, &smiapp_ctrl_ops,\r\nV4L2_CID_HFLIP, 0, 1, 1, 0);\r\nsensor->vflip = v4l2_ctrl_new_std(\r\n&sensor->pixel_array->ctrl_handler, &smiapp_ctrl_ops,\r\nV4L2_CID_VFLIP, 0, 1, 1, 0);\r\nsensor->vblank = v4l2_ctrl_new_std(\r\n&sensor->pixel_array->ctrl_handler, &smiapp_ctrl_ops,\r\nV4L2_CID_VBLANK, 0, 1, 1, 0);\r\nif (sensor->vblank)\r\nsensor->vblank->flags |= V4L2_CTRL_FLAG_UPDATE;\r\nsensor->hblank = v4l2_ctrl_new_std(\r\n&sensor->pixel_array->ctrl_handler, &smiapp_ctrl_ops,\r\nV4L2_CID_HBLANK, 0, 1, 1, 0);\r\nif (sensor->hblank)\r\nsensor->hblank->flags |= V4L2_CTRL_FLAG_UPDATE;\r\nsensor->pixel_rate_parray = v4l2_ctrl_new_std(\r\n&sensor->pixel_array->ctrl_handler, &smiapp_ctrl_ops,\r\nV4L2_CID_PIXEL_RATE, 0, 0, 1, 0);\r\nif (sensor->pixel_array->ctrl_handler.error) {\r\ndev_err(&client->dev,\r\n"pixel array controls initialization failed (%d)\n",\r\nsensor->pixel_array->ctrl_handler.error);\r\nrval = sensor->pixel_array->ctrl_handler.error;\r\ngoto error;\r\n}\r\nsensor->pixel_array->sd.ctrl_handler =\r\n&sensor->pixel_array->ctrl_handler;\r\nv4l2_ctrl_cluster(2, &sensor->hflip);\r\nrval = v4l2_ctrl_handler_init(&sensor->src->ctrl_handler, 0);\r\nif (rval)\r\ngoto error;\r\nsensor->src->ctrl_handler.lock = &sensor->mutex;\r\nfor (max = 0; sensor->platform_data->op_sys_clock[max + 1]; max++);\r\nsensor->link_freq = v4l2_ctrl_new_int_menu(\r\n&sensor->src->ctrl_handler, &smiapp_ctrl_ops,\r\nV4L2_CID_LINK_FREQ, max, 0,\r\nsensor->platform_data->op_sys_clock);\r\nsensor->pixel_rate_csi = v4l2_ctrl_new_std(\r\n&sensor->src->ctrl_handler, &smiapp_ctrl_ops,\r\nV4L2_CID_PIXEL_RATE, 0, 0, 1, 0);\r\nif (sensor->src->ctrl_handler.error) {\r\ndev_err(&client->dev,\r\n"src controls initialization failed (%d)\n",\r\nsensor->src->ctrl_handler.error);\r\nrval = sensor->src->ctrl_handler.error;\r\ngoto error;\r\n}\r\nsensor->src->sd.ctrl_handler =\r\n&sensor->src->ctrl_handler;\r\nreturn 0;\r\nerror:\r\nv4l2_ctrl_handler_free(&sensor->pixel_array->ctrl_handler);\r\nv4l2_ctrl_handler_free(&sensor->src->ctrl_handler);\r\nreturn rval;\r\n}\r\nstatic void smiapp_free_controls(struct smiapp_sensor *sensor)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < sensor->ssds_used; i++)\r\nv4l2_ctrl_handler_free(&sensor->ssds[i].ctrl_handler);\r\n}\r\nstatic int smiapp_get_limits(struct smiapp_sensor *sensor, int const *limit,\r\nunsigned int n)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(&sensor->src->sd);\r\nunsigned int i;\r\nu32 val;\r\nint rval;\r\nfor (i = 0; i < n; i++) {\r\nrval = smiapp_read(\r\nsensor, smiapp_reg_limits[limit[i]].addr, &val);\r\nif (rval)\r\nreturn rval;\r\nsensor->limits[limit[i]] = val;\r\ndev_dbg(&client->dev, "0x%8.8x \"%s\" = %d, 0x%x\n",\r\nsmiapp_reg_limits[limit[i]].addr,\r\nsmiapp_reg_limits[limit[i]].what, val, val);\r\n}\r\nreturn 0;\r\n}\r\nstatic int smiapp_get_all_limits(struct smiapp_sensor *sensor)\r\n{\r\nunsigned int i;\r\nint rval;\r\nfor (i = 0; i < SMIAPP_LIMIT_LAST; i++) {\r\nrval = smiapp_get_limits(sensor, &i, 1);\r\nif (rval < 0)\r\nreturn rval;\r\n}\r\nif (sensor->limits[SMIAPP_LIMIT_SCALER_N_MIN] == 0)\r\nsmiapp_replace_limit(sensor, SMIAPP_LIMIT_SCALER_N_MIN, 16);\r\nreturn 0;\r\n}\r\nstatic int smiapp_get_limits_binning(struct smiapp_sensor *sensor)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(&sensor->src->sd);\r\nstatic u32 const limits[] = {\r\nSMIAPP_LIMIT_MIN_FRAME_LENGTH_LINES_BIN,\r\nSMIAPP_LIMIT_MAX_FRAME_LENGTH_LINES_BIN,\r\nSMIAPP_LIMIT_MIN_LINE_LENGTH_PCK_BIN,\r\nSMIAPP_LIMIT_MAX_LINE_LENGTH_PCK_BIN,\r\nSMIAPP_LIMIT_MIN_LINE_BLANKING_PCK_BIN,\r\nSMIAPP_LIMIT_FINE_INTEGRATION_TIME_MIN_BIN,\r\nSMIAPP_LIMIT_FINE_INTEGRATION_TIME_MAX_MARGIN_BIN,\r\n};\r\nstatic u32 const limits_replace[] = {\r\nSMIAPP_LIMIT_MIN_FRAME_LENGTH_LINES,\r\nSMIAPP_LIMIT_MAX_FRAME_LENGTH_LINES,\r\nSMIAPP_LIMIT_MIN_LINE_LENGTH_PCK,\r\nSMIAPP_LIMIT_MAX_LINE_LENGTH_PCK,\r\nSMIAPP_LIMIT_MIN_LINE_BLANKING_PCK,\r\nSMIAPP_LIMIT_FINE_INTEGRATION_TIME_MIN,\r\nSMIAPP_LIMIT_FINE_INTEGRATION_TIME_MAX_MARGIN,\r\n};\r\nunsigned int i;\r\nint rval;\r\nif (sensor->limits[SMIAPP_LIMIT_BINNING_CAPABILITY] ==\r\nSMIAPP_BINNING_CAPABILITY_NO) {\r\nfor (i = 0; i < ARRAY_SIZE(limits); i++)\r\nsensor->limits[limits[i]] =\r\nsensor->limits[limits_replace[i]];\r\nreturn 0;\r\n}\r\nrval = smiapp_get_limits(sensor, limits, ARRAY_SIZE(limits));\r\nif (rval < 0)\r\nreturn rval;\r\nif (sensor->limits[SMIAPP_LIMIT_MIN_FRAME_LENGTH_LINES_BIN]\r\n&& sensor->limits[SMIAPP_LIMIT_MIN_LINE_LENGTH_PCK_BIN]\r\n&& sensor->limits[SMIAPP_LIMIT_MIN_LINE_BLANKING_PCK_BIN])\r\nreturn 0;\r\nfor (i = 0; i < ARRAY_SIZE(limits); i++) {\r\ndev_dbg(&client->dev,\r\n"replace limit 0x%8.8x \"%s\" = %d, 0x%x\n",\r\nsmiapp_reg_limits[limits[i]].addr,\r\nsmiapp_reg_limits[limits[i]].what,\r\nsensor->limits[limits_replace[i]],\r\nsensor->limits[limits_replace[i]]);\r\nsensor->limits[limits[i]] =\r\nsensor->limits[limits_replace[i]];\r\n}\r\nreturn 0;\r\n}\r\nstatic int smiapp_get_mbus_formats(struct smiapp_sensor *sensor)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(&sensor->src->sd);\r\nunsigned int type, n;\r\nunsigned int i, pixel_order;\r\nint rval;\r\nrval = smiapp_read(\r\nsensor, SMIAPP_REG_U8_DATA_FORMAT_MODEL_TYPE, &type);\r\nif (rval)\r\nreturn rval;\r\ndev_dbg(&client->dev, "data_format_model_type %d\n", type);\r\nrval = smiapp_read(sensor, SMIAPP_REG_U8_PIXEL_ORDER,\r\n&pixel_order);\r\nif (rval)\r\nreturn rval;\r\nif (pixel_order >= ARRAY_SIZE(pixel_order_str)) {\r\ndev_dbg(&client->dev, "bad pixel order %d\n", pixel_order);\r\nreturn -EINVAL;\r\n}\r\ndev_dbg(&client->dev, "pixel order %d (%s)\n", pixel_order,\r\npixel_order_str[pixel_order]);\r\nswitch (type) {\r\ncase SMIAPP_DATA_FORMAT_MODEL_TYPE_NORMAL:\r\nn = SMIAPP_DATA_FORMAT_MODEL_TYPE_NORMAL_N;\r\nbreak;\r\ncase SMIAPP_DATA_FORMAT_MODEL_TYPE_EXTENDED:\r\nn = SMIAPP_DATA_FORMAT_MODEL_TYPE_EXTENDED_N;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nsensor->default_pixel_order = pixel_order;\r\nsensor->mbus_frame_fmts = 0;\r\nfor (i = 0; i < n; i++) {\r\nunsigned int fmt, j;\r\nrval = smiapp_read(\r\nsensor,\r\nSMIAPP_REG_U16_DATA_FORMAT_DESCRIPTOR(i), &fmt);\r\nif (rval)\r\nreturn rval;\r\ndev_dbg(&client->dev, "bpp %d, compressed %d\n",\r\nfmt >> 8, (u8)fmt);\r\nfor (j = 0; j < ARRAY_SIZE(smiapp_csi_data_formats); j++) {\r\nconst struct smiapp_csi_data_format *f =\r\n&smiapp_csi_data_formats[j];\r\nif (f->pixel_order != SMIAPP_PIXEL_ORDER_GRBG)\r\ncontinue;\r\nif (f->width != fmt >> 8 || f->compressed != (u8)fmt)\r\ncontinue;\r\ndev_dbg(&client->dev, "jolly good! %d\n", j);\r\nsensor->default_mbus_frame_fmts |= 1 << j;\r\nif (!sensor->csi_format\r\n|| f->width > sensor->csi_format->width\r\n|| (f->width == sensor->csi_format->width\r\n&& f->compressed\r\n> sensor->csi_format->compressed)) {\r\nsensor->csi_format = f;\r\nsensor->internal_csi_format = f;\r\n}\r\n}\r\n}\r\nif (!sensor->csi_format) {\r\ndev_err(&client->dev, "no supported mbus code found\n");\r\nreturn -EINVAL;\r\n}\r\nsmiapp_update_mbus_formats(sensor);\r\nreturn 0;\r\n}\r\nstatic void smiapp_update_blanking(struct smiapp_sensor *sensor)\r\n{\r\nstruct v4l2_ctrl *vblank = sensor->vblank;\r\nstruct v4l2_ctrl *hblank = sensor->hblank;\r\nvblank->minimum =\r\nmax_t(int,\r\nsensor->limits[SMIAPP_LIMIT_MIN_FRAME_BLANKING_LINES],\r\nsensor->limits[SMIAPP_LIMIT_MIN_FRAME_LENGTH_LINES_BIN] -\r\nsensor->pixel_array->crop[SMIAPP_PA_PAD_SRC].height);\r\nvblank->maximum =\r\nsensor->limits[SMIAPP_LIMIT_MAX_FRAME_LENGTH_LINES_BIN] -\r\nsensor->pixel_array->crop[SMIAPP_PA_PAD_SRC].height;\r\nvblank->val = clamp_t(int, vblank->val,\r\nvblank->minimum, vblank->maximum);\r\nvblank->default_value = vblank->minimum;\r\nvblank->val = vblank->val;\r\nvblank->cur.val = vblank->val;\r\nhblank->minimum =\r\nmax_t(int,\r\nsensor->limits[SMIAPP_LIMIT_MIN_LINE_LENGTH_PCK_BIN] -\r\nsensor->pixel_array->crop[SMIAPP_PA_PAD_SRC].width,\r\nsensor->limits[SMIAPP_LIMIT_MIN_LINE_BLANKING_PCK_BIN]);\r\nhblank->maximum =\r\nsensor->limits[SMIAPP_LIMIT_MAX_LINE_LENGTH_PCK_BIN] -\r\nsensor->pixel_array->crop[SMIAPP_PA_PAD_SRC].width;\r\nhblank->val = clamp_t(int, hblank->val,\r\nhblank->minimum, hblank->maximum);\r\nhblank->default_value = hblank->minimum;\r\nhblank->val = hblank->val;\r\nhblank->cur.val = hblank->val;\r\n__smiapp_update_exposure_limits(sensor);\r\n}\r\nstatic int smiapp_update_mode(struct smiapp_sensor *sensor)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(&sensor->src->sd);\r\nunsigned int binning_mode;\r\nint rval;\r\ndev_dbg(&client->dev, "frame size: %dx%d\n",\r\nsensor->src->crop[SMIAPP_PAD_SRC].width,\r\nsensor->src->crop[SMIAPP_PAD_SRC].height);\r\ndev_dbg(&client->dev, "csi format width: %d\n",\r\nsensor->csi_format->width);\r\nif (sensor->binning_horizontal == 1 &&\r\nsensor->binning_vertical == 1) {\r\nbinning_mode = 0;\r\n} else {\r\nu8 binning_type =\r\n(sensor->binning_horizontal << 4)\r\n| sensor->binning_vertical;\r\nrval = smiapp_write(\r\nsensor, SMIAPP_REG_U8_BINNING_TYPE, binning_type);\r\nif (rval < 0)\r\nreturn rval;\r\nbinning_mode = 1;\r\n}\r\nrval = smiapp_write(sensor, SMIAPP_REG_U8_BINNING_MODE, binning_mode);\r\nif (rval < 0)\r\nreturn rval;\r\nrval = smiapp_get_limits_binning(sensor);\r\nif (rval < 0)\r\nreturn rval;\r\nrval = smiapp_pll_update(sensor);\r\nif (rval < 0)\r\nreturn rval;\r\nsmiapp_update_blanking(sensor);\r\ndev_dbg(&client->dev, "vblank\t\t%d\n", sensor->vblank->val);\r\ndev_dbg(&client->dev, "hblank\t\t%d\n", sensor->hblank->val);\r\ndev_dbg(&client->dev, "real timeperframe\t100/%d\n",\r\nsensor->pll.vt_pix_clk_freq_hz /\r\n((sensor->pixel_array->crop[SMIAPP_PA_PAD_SRC].width\r\n+ sensor->hblank->val) *\r\n(sensor->pixel_array->crop[SMIAPP_PA_PAD_SRC].height\r\n+ sensor->vblank->val) / 100));\r\nreturn 0;\r\n}\r\nstatic int smiapp_read_nvm(struct smiapp_sensor *sensor,\r\nunsigned char *nvm)\r\n{\r\nu32 i, s, p, np, v;\r\nint rval = 0, rval2;\r\nnp = sensor->nvm_size / SMIAPP_NVM_PAGE_SIZE;\r\nfor (p = 0; p < np; p++) {\r\nrval = smiapp_write(\r\nsensor,\r\nSMIAPP_REG_U8_DATA_TRANSFER_IF_1_PAGE_SELECT, p);\r\nif (rval)\r\ngoto out;\r\nrval = smiapp_write(sensor,\r\nSMIAPP_REG_U8_DATA_TRANSFER_IF_1_CTRL,\r\nSMIAPP_DATA_TRANSFER_IF_1_CTRL_EN |\r\nSMIAPP_DATA_TRANSFER_IF_1_CTRL_RD_EN);\r\nif (rval)\r\ngoto out;\r\nfor (i = 0; i < 1000; i++) {\r\nrval = smiapp_read(\r\nsensor,\r\nSMIAPP_REG_U8_DATA_TRANSFER_IF_1_STATUS, &s);\r\nif (rval)\r\ngoto out;\r\nif (s & SMIAPP_DATA_TRANSFER_IF_1_STATUS_RD_READY)\r\nbreak;\r\nif (--i == 0) {\r\nrval = -ETIMEDOUT;\r\ngoto out;\r\n}\r\n}\r\nfor (i = 0; i < SMIAPP_NVM_PAGE_SIZE; i++) {\r\nrval = smiapp_read(\r\nsensor,\r\nSMIAPP_REG_U8_DATA_TRANSFER_IF_1_DATA_0 + i,\r\n&v);\r\nif (rval)\r\ngoto out;\r\n*nvm++ = v;\r\n}\r\n}\r\nout:\r\nrval2 = smiapp_write(sensor, SMIAPP_REG_U8_DATA_TRANSFER_IF_1_CTRL, 0);\r\nif (rval < 0)\r\nreturn rval;\r\nelse\r\nreturn rval2;\r\n}\r\nstatic int smiapp_change_cci_addr(struct smiapp_sensor *sensor)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(&sensor->src->sd);\r\nint rval;\r\nu32 val;\r\nclient->addr = sensor->platform_data->i2c_addr_dfl;\r\nrval = smiapp_write(sensor,\r\nSMIAPP_REG_U8_CCI_ADDRESS_CONTROL,\r\nsensor->platform_data->i2c_addr_alt << 1);\r\nif (rval)\r\nreturn rval;\r\nclient->addr = sensor->platform_data->i2c_addr_alt;\r\nrval = smiapp_read(sensor, SMIAPP_REG_U8_CCI_ADDRESS_CONTROL, &val);\r\nif (rval)\r\nreturn rval;\r\nif (val != sensor->platform_data->i2c_addr_alt << 1)\r\nreturn -ENODEV;\r\nreturn 0;\r\n}\r\nstatic int smiapp_setup_flash_strobe(struct smiapp_sensor *sensor)\r\n{\r\nstruct smiapp_flash_strobe_parms *strobe_setup;\r\nunsigned int ext_freq = sensor->platform_data->ext_clk;\r\nu32 tmp;\r\nu32 strobe_adjustment;\r\nu32 strobe_width_high_rs;\r\nint rval;\r\nstrobe_setup = sensor->platform_data->strobe_setup;\r\ntmp = div_u64(1000000ULL * ((1 << 16) - 1) * ((1 << 8) - 1) -\r\n1000000 + 1, ext_freq);\r\nstrobe_setup->strobe_width_high_us =\r\nclamp_t(u32, strobe_setup->strobe_width_high_us, 1, tmp);\r\ntmp = div_u64(((u64)strobe_setup->strobe_width_high_us * (u64)ext_freq +\r\n1000000 - 1), 1000000ULL);\r\nstrobe_adjustment = (tmp + (1 << 16) - 1 - 1) / ((1 << 16) - 1);\r\nstrobe_width_high_rs = (tmp + strobe_adjustment - 1) /\r\nstrobe_adjustment;\r\nrval = smiapp_write(sensor, SMIAPP_REG_U8_FLASH_MODE_RS,\r\nstrobe_setup->mode);\r\nif (rval < 0)\r\ngoto out;\r\nrval = smiapp_write(sensor, SMIAPP_REG_U8_FLASH_STROBE_ADJUSTMENT,\r\nstrobe_adjustment);\r\nif (rval < 0)\r\ngoto out;\r\nrval = smiapp_write(\r\nsensor, SMIAPP_REG_U16_TFLASH_STROBE_WIDTH_HIGH_RS_CTRL,\r\nstrobe_width_high_rs);\r\nif (rval < 0)\r\ngoto out;\r\nrval = smiapp_write(sensor, SMIAPP_REG_U16_TFLASH_STROBE_DELAY_RS_CTRL,\r\nstrobe_setup->strobe_delay);\r\nif (rval < 0)\r\ngoto out;\r\nrval = smiapp_write(sensor, SMIAPP_REG_U16_FLASH_STROBE_START_POINT,\r\nstrobe_setup->stobe_start_point);\r\nif (rval < 0)\r\ngoto out;\r\nrval = smiapp_write(sensor, SMIAPP_REG_U8_FLASH_TRIGGER_RS,\r\nstrobe_setup->trigger);\r\nout:\r\nsensor->platform_data->strobe_setup->trigger = 0;\r\nreturn rval;\r\n}\r\nstatic int smiapp_power_on(struct smiapp_sensor *sensor)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(&sensor->src->sd);\r\nunsigned int sleep;\r\nint rval;\r\nrval = regulator_enable(sensor->vana);\r\nif (rval) {\r\ndev_err(&client->dev, "failed to enable vana regulator\n");\r\nreturn rval;\r\n}\r\nusleep_range(1000, 1000);\r\nif (sensor->platform_data->set_xclk)\r\nrval = sensor->platform_data->set_xclk(\r\n&sensor->src->sd, sensor->platform_data->ext_clk);\r\nelse\r\nrval = clk_enable(sensor->ext_clk);\r\nif (rval < 0) {\r\ndev_dbg(&client->dev, "failed to set xclk\n");\r\ngoto out_xclk_fail;\r\n}\r\nusleep_range(1000, 1000);\r\nif (sensor->platform_data->xshutdown != SMIAPP_NO_XSHUTDOWN)\r\ngpio_set_value(sensor->platform_data->xshutdown, 1);\r\nsleep = SMIAPP_RESET_DELAY(sensor->platform_data->ext_clk);\r\nusleep_range(sleep, sleep);\r\nif (sensor->platform_data->i2c_addr_alt) {\r\nrval = smiapp_change_cci_addr(sensor);\r\nif (rval) {\r\ndev_err(&client->dev, "cci address change error\n");\r\ngoto out_cci_addr_fail;\r\n}\r\n}\r\nrval = smiapp_write(sensor, SMIAPP_REG_U8_SOFTWARE_RESET,\r\nSMIAPP_SOFTWARE_RESET);\r\nif (rval < 0) {\r\ndev_err(&client->dev, "software reset failed\n");\r\ngoto out_cci_addr_fail;\r\n}\r\nif (sensor->platform_data->i2c_addr_alt) {\r\nrval = smiapp_change_cci_addr(sensor);\r\nif (rval) {\r\ndev_err(&client->dev, "cci address change error\n");\r\ngoto out_cci_addr_fail;\r\n}\r\n}\r\nrval = smiapp_write(sensor, SMIAPP_REG_U16_COMPRESSION_MODE,\r\nSMIAPP_COMPRESSION_MODE_SIMPLE_PREDICTOR);\r\nif (rval) {\r\ndev_err(&client->dev, "compression mode set failed\n");\r\ngoto out_cci_addr_fail;\r\n}\r\nrval = smiapp_write(\r\nsensor, SMIAPP_REG_U16_EXTCLK_FREQUENCY_MHZ,\r\nsensor->platform_data->ext_clk / (1000000 / (1 << 8)));\r\nif (rval) {\r\ndev_err(&client->dev, "extclk frequency set failed\n");\r\ngoto out_cci_addr_fail;\r\n}\r\nrval = smiapp_write(sensor, SMIAPP_REG_U8_CSI_LANE_MODE,\r\nsensor->platform_data->lanes - 1);\r\nif (rval) {\r\ndev_err(&client->dev, "csi lane mode set failed\n");\r\ngoto out_cci_addr_fail;\r\n}\r\nrval = smiapp_write(sensor, SMIAPP_REG_U8_FAST_STANDBY_CTRL,\r\nSMIAPP_FAST_STANDBY_CTRL_IMMEDIATE);\r\nif (rval) {\r\ndev_err(&client->dev, "fast standby set failed\n");\r\ngoto out_cci_addr_fail;\r\n}\r\nrval = smiapp_write(sensor, SMIAPP_REG_U8_CSI_SIGNALLING_MODE,\r\nsensor->platform_data->csi_signalling_mode);\r\nif (rval) {\r\ndev_err(&client->dev, "csi signalling mode set failed\n");\r\ngoto out_cci_addr_fail;\r\n}\r\nrval = smiapp_write(sensor, SMIAPP_REG_U8_DPHY_CTRL,\r\nSMIAPP_DPHY_CTRL_UI);\r\nif (rval < 0)\r\nreturn rval;\r\nrval = smiapp_call_quirk(sensor, post_poweron);\r\nif (rval) {\r\ndev_err(&client->dev, "post_poweron quirks failed\n");\r\ngoto out_cci_addr_fail;\r\n}\r\nif (!sensor->pixel_array)\r\nreturn 0;\r\nrval = v4l2_ctrl_handler_setup(\r\n&sensor->pixel_array->ctrl_handler);\r\nif (rval)\r\ngoto out_cci_addr_fail;\r\nrval = v4l2_ctrl_handler_setup(&sensor->src->ctrl_handler);\r\nif (rval)\r\ngoto out_cci_addr_fail;\r\nmutex_lock(&sensor->mutex);\r\nrval = smiapp_update_mode(sensor);\r\nmutex_unlock(&sensor->mutex);\r\nif (rval < 0)\r\ngoto out_cci_addr_fail;\r\nreturn 0;\r\nout_cci_addr_fail:\r\nif (sensor->platform_data->xshutdown != SMIAPP_NO_XSHUTDOWN)\r\ngpio_set_value(sensor->platform_data->xshutdown, 0);\r\nif (sensor->platform_data->set_xclk)\r\nsensor->platform_data->set_xclk(&sensor->src->sd, 0);\r\nelse\r\nclk_disable(sensor->ext_clk);\r\nout_xclk_fail:\r\nregulator_disable(sensor->vana);\r\nreturn rval;\r\n}\r\nstatic void smiapp_power_off(struct smiapp_sensor *sensor)\r\n{\r\nif (sensor->platform_data->i2c_addr_alt)\r\nsmiapp_write(sensor,\r\nSMIAPP_REG_U8_SOFTWARE_RESET,\r\nSMIAPP_SOFTWARE_RESET);\r\nif (sensor->platform_data->xshutdown != SMIAPP_NO_XSHUTDOWN)\r\ngpio_set_value(sensor->platform_data->xshutdown, 0);\r\nif (sensor->platform_data->set_xclk)\r\nsensor->platform_data->set_xclk(&sensor->src->sd, 0);\r\nelse\r\nclk_disable(sensor->ext_clk);\r\nusleep_range(5000, 5000);\r\nregulator_disable(sensor->vana);\r\nsensor->streaming = 0;\r\n}\r\nstatic int smiapp_set_power(struct v4l2_subdev *subdev, int on)\r\n{\r\nstruct smiapp_sensor *sensor = to_smiapp_sensor(subdev);\r\nint ret = 0;\r\nmutex_lock(&sensor->power_mutex);\r\nif (!sensor->power_count == !on)\r\ngoto out;\r\nif (on) {\r\nret = smiapp_power_on(sensor);\r\nif (ret < 0)\r\ngoto out;\r\n} else {\r\nsmiapp_power_off(sensor);\r\n}\r\nsensor->power_count += on ? 1 : -1;\r\nWARN_ON(sensor->power_count < 0);\r\nout:\r\nmutex_unlock(&sensor->power_mutex);\r\nreturn ret;\r\n}\r\nstatic int smiapp_start_streaming(struct smiapp_sensor *sensor)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(&sensor->src->sd);\r\nint rval;\r\nmutex_lock(&sensor->mutex);\r\nrval = smiapp_write(sensor, SMIAPP_REG_U16_CSI_DATA_FORMAT,\r\n(sensor->csi_format->width << 8) |\r\nsensor->csi_format->compressed);\r\nif (rval)\r\ngoto out;\r\nrval = smiapp_pll_configure(sensor);\r\nif (rval)\r\ngoto out;\r\nrval = smiapp_write(sensor, SMIAPP_REG_U16_X_ADDR_START,\r\nsensor->pixel_array->crop[SMIAPP_PA_PAD_SRC].left);\r\nif (rval < 0)\r\ngoto out;\r\nrval = smiapp_write(sensor, SMIAPP_REG_U16_Y_ADDR_START,\r\nsensor->pixel_array->crop[SMIAPP_PA_PAD_SRC].top);\r\nif (rval < 0)\r\ngoto out;\r\nrval = smiapp_write(\r\nsensor, SMIAPP_REG_U16_X_ADDR_END,\r\nsensor->pixel_array->crop[SMIAPP_PA_PAD_SRC].left\r\n+ sensor->pixel_array->crop[SMIAPP_PA_PAD_SRC].width - 1);\r\nif (rval < 0)\r\ngoto out;\r\nrval = smiapp_write(\r\nsensor, SMIAPP_REG_U16_Y_ADDR_END,\r\nsensor->pixel_array->crop[SMIAPP_PA_PAD_SRC].top\r\n+ sensor->pixel_array->crop[SMIAPP_PA_PAD_SRC].height - 1);\r\nif (rval < 0)\r\ngoto out;\r\nif (sensor->limits[SMIAPP_LIMIT_DIGITAL_CROP_CAPABILITY]\r\n== SMIAPP_DIGITAL_CROP_CAPABILITY_INPUT_CROP) {\r\nrval = smiapp_write(\r\nsensor, SMIAPP_REG_U16_DIGITAL_CROP_X_OFFSET,\r\nsensor->scaler->crop[SMIAPP_PAD_SINK].left);\r\nif (rval < 0)\r\ngoto out;\r\nrval = smiapp_write(\r\nsensor, SMIAPP_REG_U16_DIGITAL_CROP_Y_OFFSET,\r\nsensor->scaler->crop[SMIAPP_PAD_SINK].top);\r\nif (rval < 0)\r\ngoto out;\r\nrval = smiapp_write(\r\nsensor, SMIAPP_REG_U16_DIGITAL_CROP_IMAGE_WIDTH,\r\nsensor->scaler->crop[SMIAPP_PAD_SINK].width);\r\nif (rval < 0)\r\ngoto out;\r\nrval = smiapp_write(\r\nsensor, SMIAPP_REG_U16_DIGITAL_CROP_IMAGE_HEIGHT,\r\nsensor->scaler->crop[SMIAPP_PAD_SINK].height);\r\nif (rval < 0)\r\ngoto out;\r\n}\r\nif (sensor->limits[SMIAPP_LIMIT_SCALING_CAPABILITY]\r\n!= SMIAPP_SCALING_CAPABILITY_NONE) {\r\nrval = smiapp_write(sensor, SMIAPP_REG_U16_SCALING_MODE,\r\nsensor->scaling_mode);\r\nif (rval < 0)\r\ngoto out;\r\nrval = smiapp_write(sensor, SMIAPP_REG_U16_SCALE_M,\r\nsensor->scale_m);\r\nif (rval < 0)\r\ngoto out;\r\n}\r\nrval = smiapp_write(sensor, SMIAPP_REG_U16_X_OUTPUT_SIZE,\r\nsensor->src->crop[SMIAPP_PAD_SRC].width);\r\nif (rval < 0)\r\ngoto out;\r\nrval = smiapp_write(sensor, SMIAPP_REG_U16_Y_OUTPUT_SIZE,\r\nsensor->src->crop[SMIAPP_PAD_SRC].height);\r\nif (rval < 0)\r\ngoto out;\r\nif ((sensor->flash_capability &\r\n(SMIAPP_FLASH_MODE_CAPABILITY_SINGLE_STROBE |\r\nSMIAPP_FLASH_MODE_CAPABILITY_MULTIPLE_STROBE)) &&\r\nsensor->platform_data->strobe_setup != NULL &&\r\nsensor->platform_data->strobe_setup->trigger != 0) {\r\nrval = smiapp_setup_flash_strobe(sensor);\r\nif (rval)\r\ngoto out;\r\n}\r\nrval = smiapp_call_quirk(sensor, pre_streamon);\r\nif (rval) {\r\ndev_err(&client->dev, "pre_streamon quirks failed\n");\r\ngoto out;\r\n}\r\nrval = smiapp_write(sensor, SMIAPP_REG_U8_MODE_SELECT,\r\nSMIAPP_MODE_SELECT_STREAMING);\r\nout:\r\nmutex_unlock(&sensor->mutex);\r\nreturn rval;\r\n}\r\nstatic int smiapp_stop_streaming(struct smiapp_sensor *sensor)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(&sensor->src->sd);\r\nint rval;\r\nmutex_lock(&sensor->mutex);\r\nrval = smiapp_write(sensor, SMIAPP_REG_U8_MODE_SELECT,\r\nSMIAPP_MODE_SELECT_SOFTWARE_STANDBY);\r\nif (rval)\r\ngoto out;\r\nrval = smiapp_call_quirk(sensor, post_streamoff);\r\nif (rval)\r\ndev_err(&client->dev, "post_streamoff quirks failed\n");\r\nout:\r\nmutex_unlock(&sensor->mutex);\r\nreturn rval;\r\n}\r\nstatic int smiapp_set_stream(struct v4l2_subdev *subdev, int enable)\r\n{\r\nstruct smiapp_sensor *sensor = to_smiapp_sensor(subdev);\r\nint rval;\r\nif (sensor->streaming == enable)\r\nreturn 0;\r\nif (enable) {\r\nsensor->streaming = 1;\r\nrval = smiapp_start_streaming(sensor);\r\nif (rval < 0)\r\nsensor->streaming = 0;\r\n} else {\r\nrval = smiapp_stop_streaming(sensor);\r\nsensor->streaming = 0;\r\n}\r\nreturn rval;\r\n}\r\nstatic int smiapp_enum_mbus_code(struct v4l2_subdev *subdev,\r\nstruct v4l2_subdev_fh *fh,\r\nstruct v4l2_subdev_mbus_code_enum *code)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(subdev);\r\nstruct smiapp_sensor *sensor = to_smiapp_sensor(subdev);\r\nunsigned int i;\r\nint idx = -1;\r\nint rval = -EINVAL;\r\nmutex_lock(&sensor->mutex);\r\ndev_err(&client->dev, "subdev %s, pad %d, index %d\n",\r\nsubdev->name, code->pad, code->index);\r\nif (subdev != &sensor->src->sd || code->pad != SMIAPP_PAD_SRC) {\r\nif (code->index)\r\ngoto out;\r\ncode->code = sensor->internal_csi_format->code;\r\nrval = 0;\r\ngoto out;\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(smiapp_csi_data_formats); i++) {\r\nif (sensor->mbus_frame_fmts & (1 << i))\r\nidx++;\r\nif (idx == code->index) {\r\ncode->code = smiapp_csi_data_formats[i].code;\r\ndev_err(&client->dev, "found index %d, i %d, code %x\n",\r\ncode->index, i, code->code);\r\nrval = 0;\r\nbreak;\r\n}\r\n}\r\nout:\r\nmutex_unlock(&sensor->mutex);\r\nreturn rval;\r\n}\r\nstatic u32 __smiapp_get_mbus_code(struct v4l2_subdev *subdev,\r\nunsigned int pad)\r\n{\r\nstruct smiapp_sensor *sensor = to_smiapp_sensor(subdev);\r\nif (subdev == &sensor->src->sd && pad == SMIAPP_PAD_SRC)\r\nreturn sensor->csi_format->code;\r\nelse\r\nreturn sensor->internal_csi_format->code;\r\n}\r\nstatic int __smiapp_get_format(struct v4l2_subdev *subdev,\r\nstruct v4l2_subdev_fh *fh,\r\nstruct v4l2_subdev_format *fmt)\r\n{\r\nstruct smiapp_subdev *ssd = to_smiapp_subdev(subdev);\r\nif (fmt->which == V4L2_SUBDEV_FORMAT_TRY) {\r\nfmt->format = *v4l2_subdev_get_try_format(fh, fmt->pad);\r\n} else {\r\nstruct v4l2_rect *r;\r\nif (fmt->pad == ssd->source_pad)\r\nr = &ssd->crop[ssd->source_pad];\r\nelse\r\nr = &ssd->sink_fmt;\r\nfmt->format.code = __smiapp_get_mbus_code(subdev, fmt->pad);\r\nfmt->format.width = r->width;\r\nfmt->format.height = r->height;\r\n}\r\nreturn 0;\r\n}\r\nstatic int smiapp_get_format(struct v4l2_subdev *subdev,\r\nstruct v4l2_subdev_fh *fh,\r\nstruct v4l2_subdev_format *fmt)\r\n{\r\nstruct smiapp_sensor *sensor = to_smiapp_sensor(subdev);\r\nint rval;\r\nmutex_lock(&sensor->mutex);\r\nrval = __smiapp_get_format(subdev, fh, fmt);\r\nmutex_unlock(&sensor->mutex);\r\nreturn rval;\r\n}\r\nstatic void smiapp_get_crop_compose(struct v4l2_subdev *subdev,\r\nstruct v4l2_subdev_fh *fh,\r\nstruct v4l2_rect **crops,\r\nstruct v4l2_rect **comps, int which)\r\n{\r\nstruct smiapp_subdev *ssd = to_smiapp_subdev(subdev);\r\nunsigned int i;\r\nif (which == V4L2_SUBDEV_FORMAT_ACTIVE) {\r\nif (crops)\r\nfor (i = 0; i < subdev->entity.num_pads; i++)\r\ncrops[i] = &ssd->crop[i];\r\nif (comps)\r\n*comps = &ssd->compose;\r\n} else {\r\nif (crops) {\r\nfor (i = 0; i < subdev->entity.num_pads; i++) {\r\ncrops[i] = v4l2_subdev_get_try_crop(fh, i);\r\nBUG_ON(!crops[i]);\r\n}\r\n}\r\nif (comps) {\r\n*comps = v4l2_subdev_get_try_compose(fh,\r\nSMIAPP_PAD_SINK);\r\nBUG_ON(!*comps);\r\n}\r\n}\r\n}\r\nstatic void smiapp_propagate(struct v4l2_subdev *subdev,\r\nstruct v4l2_subdev_fh *fh, int which,\r\nint target)\r\n{\r\nstruct smiapp_sensor *sensor = to_smiapp_sensor(subdev);\r\nstruct smiapp_subdev *ssd = to_smiapp_subdev(subdev);\r\nstruct v4l2_rect *comp, *crops[SMIAPP_PADS];\r\nsmiapp_get_crop_compose(subdev, fh, crops, &comp, which);\r\nswitch (target) {\r\ncase V4L2_SEL_TGT_CROP:\r\ncomp->width = crops[SMIAPP_PAD_SINK]->width;\r\ncomp->height = crops[SMIAPP_PAD_SINK]->height;\r\nif (which == V4L2_SUBDEV_FORMAT_ACTIVE) {\r\nif (ssd == sensor->scaler) {\r\nsensor->scale_m =\r\nsensor->limits[\r\nSMIAPP_LIMIT_SCALER_N_MIN];\r\nsensor->scaling_mode =\r\nSMIAPP_SCALING_MODE_NONE;\r\n} else if (ssd == sensor->binner) {\r\nsensor->binning_horizontal = 1;\r\nsensor->binning_vertical = 1;\r\n}\r\n}\r\ncase V4L2_SEL_TGT_COMPOSE:\r\n*crops[SMIAPP_PAD_SRC] = *comp;\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\n}\r\nstatic const struct smiapp_csi_data_format\r\n*smiapp_validate_csi_data_format(struct smiapp_sensor *sensor, u32 code)\r\n{\r\nconst struct smiapp_csi_data_format *csi_format = sensor->csi_format;\r\nunsigned int i;\r\nfor (i = 0; i < ARRAY_SIZE(smiapp_csi_data_formats); i++) {\r\nif (sensor->mbus_frame_fmts & (1 << i)\r\n&& smiapp_csi_data_formats[i].code == code)\r\nreturn &smiapp_csi_data_formats[i];\r\n}\r\nreturn csi_format;\r\n}\r\nstatic int smiapp_set_format(struct v4l2_subdev *subdev,\r\nstruct v4l2_subdev_fh *fh,\r\nstruct v4l2_subdev_format *fmt)\r\n{\r\nstruct smiapp_sensor *sensor = to_smiapp_sensor(subdev);\r\nstruct smiapp_subdev *ssd = to_smiapp_subdev(subdev);\r\nstruct v4l2_rect *crops[SMIAPP_PADS];\r\nmutex_lock(&sensor->mutex);\r\nif (fmt->pad == ssd->source_pad) {\r\nu32 code = fmt->format.code;\r\nint rval = __smiapp_get_format(subdev, fh, fmt);\r\nif (!rval && subdev == &sensor->src->sd) {\r\nconst struct smiapp_csi_data_format *csi_format =\r\nsmiapp_validate_csi_data_format(sensor, code);\r\nif (fmt->which == V4L2_SUBDEV_FORMAT_ACTIVE)\r\nsensor->csi_format = csi_format;\r\nfmt->format.code = csi_format->code;\r\n}\r\nmutex_unlock(&sensor->mutex);\r\nreturn rval;\r\n}\r\nfmt->format.code = __smiapp_get_mbus_code(subdev, fmt->pad);\r\nfmt->format.width &= ~1;\r\nfmt->format.height &= ~1;\r\nfmt->format.width =\r\nclamp(fmt->format.width,\r\nsensor->limits[SMIAPP_LIMIT_MIN_X_OUTPUT_SIZE],\r\nsensor->limits[SMIAPP_LIMIT_MAX_X_OUTPUT_SIZE]);\r\nfmt->format.height =\r\nclamp(fmt->format.height,\r\nsensor->limits[SMIAPP_LIMIT_MIN_Y_OUTPUT_SIZE],\r\nsensor->limits[SMIAPP_LIMIT_MAX_Y_OUTPUT_SIZE]);\r\nsmiapp_get_crop_compose(subdev, fh, crops, NULL, fmt->which);\r\ncrops[ssd->sink_pad]->left = 0;\r\ncrops[ssd->sink_pad]->top = 0;\r\ncrops[ssd->sink_pad]->width = fmt->format.width;\r\ncrops[ssd->sink_pad]->height = fmt->format.height;\r\nif (fmt->which == V4L2_SUBDEV_FORMAT_ACTIVE)\r\nssd->sink_fmt = *crops[ssd->sink_pad];\r\nsmiapp_propagate(subdev, fh, fmt->which,\r\nV4L2_SEL_TGT_CROP);\r\nmutex_unlock(&sensor->mutex);\r\nreturn 0;\r\n}\r\nstatic int scaling_goodness(struct v4l2_subdev *subdev, int w, int ask_w,\r\nint h, int ask_h, u32 flags)\r\n{\r\nstruct smiapp_sensor *sensor = to_smiapp_sensor(subdev);\r\nstruct i2c_client *client = v4l2_get_subdevdata(subdev);\r\nint val = 0;\r\nw &= ~1;\r\nask_w &= ~1;\r\nh &= ~1;\r\nask_h &= ~1;\r\nif (flags & V4L2_SEL_FLAG_GE) {\r\nif (w < ask_w)\r\nval -= SCALING_GOODNESS;\r\nif (h < ask_h)\r\nval -= SCALING_GOODNESS;\r\n}\r\nif (flags & V4L2_SEL_FLAG_LE) {\r\nif (w > ask_w)\r\nval -= SCALING_GOODNESS;\r\nif (h > ask_h)\r\nval -= SCALING_GOODNESS;\r\n}\r\nval -= abs(w - ask_w);\r\nval -= abs(h - ask_h);\r\nif (w < sensor->limits[SMIAPP_LIMIT_MIN_X_OUTPUT_SIZE])\r\nval -= SCALING_GOODNESS_EXTREME;\r\ndev_dbg(&client->dev, "w %d ask_w %d h %d ask_h %d goodness %d\n",\r\nw, ask_h, h, ask_h, val);\r\nreturn val;\r\n}\r\nstatic void smiapp_set_compose_binner(struct v4l2_subdev *subdev,\r\nstruct v4l2_subdev_fh *fh,\r\nstruct v4l2_subdev_selection *sel,\r\nstruct v4l2_rect **crops,\r\nstruct v4l2_rect *comp)\r\n{\r\nstruct smiapp_sensor *sensor = to_smiapp_sensor(subdev);\r\nunsigned int i;\r\nunsigned int binh = 1, binv = 1;\r\nunsigned int best = scaling_goodness(\r\nsubdev,\r\ncrops[SMIAPP_PAD_SINK]->width, sel->r.width,\r\ncrops[SMIAPP_PAD_SINK]->height, sel->r.height, sel->flags);\r\nfor (i = 0; i < sensor->nbinning_subtypes; i++) {\r\nint this = scaling_goodness(\r\nsubdev,\r\ncrops[SMIAPP_PAD_SINK]->width\r\n/ sensor->binning_subtypes[i].horizontal,\r\nsel->r.width,\r\ncrops[SMIAPP_PAD_SINK]->height\r\n/ sensor->binning_subtypes[i].vertical,\r\nsel->r.height, sel->flags);\r\nif (this > best) {\r\nbinh = sensor->binning_subtypes[i].horizontal;\r\nbinv = sensor->binning_subtypes[i].vertical;\r\nbest = this;\r\n}\r\n}\r\nif (sel->which == V4L2_SUBDEV_FORMAT_ACTIVE) {\r\nsensor->binning_vertical = binv;\r\nsensor->binning_horizontal = binh;\r\n}\r\nsel->r.width = (crops[SMIAPP_PAD_SINK]->width / binh) & ~1;\r\nsel->r.height = (crops[SMIAPP_PAD_SINK]->height / binv) & ~1;\r\n}\r\nstatic void smiapp_set_compose_scaler(struct v4l2_subdev *subdev,\r\nstruct v4l2_subdev_fh *fh,\r\nstruct v4l2_subdev_selection *sel,\r\nstruct v4l2_rect **crops,\r\nstruct v4l2_rect *comp)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(subdev);\r\nstruct smiapp_sensor *sensor = to_smiapp_sensor(subdev);\r\nu32 min, max, a, b, max_m;\r\nu32 scale_m = sensor->limits[SMIAPP_LIMIT_SCALER_N_MIN];\r\nint mode = SMIAPP_SCALING_MODE_HORIZONTAL;\r\nu32 try[4];\r\nu32 ntry = 0;\r\nunsigned int i;\r\nint best = INT_MIN;\r\nsel->r.width = min_t(unsigned int, sel->r.width,\r\ncrops[SMIAPP_PAD_SINK]->width);\r\nsel->r.height = min_t(unsigned int, sel->r.height,\r\ncrops[SMIAPP_PAD_SINK]->height);\r\na = crops[SMIAPP_PAD_SINK]->width\r\n* sensor->limits[SMIAPP_LIMIT_SCALER_N_MIN] / sel->r.width;\r\nb = crops[SMIAPP_PAD_SINK]->height\r\n* sensor->limits[SMIAPP_LIMIT_SCALER_N_MIN] / sel->r.height;\r\nmax_m = crops[SMIAPP_PAD_SINK]->width\r\n* sensor->limits[SMIAPP_LIMIT_SCALER_N_MIN]\r\n/ sensor->limits[SMIAPP_LIMIT_MIN_X_OUTPUT_SIZE];\r\na = min(sensor->limits[SMIAPP_LIMIT_SCALER_M_MAX],\r\nmax(a, sensor->limits[SMIAPP_LIMIT_SCALER_M_MIN]));\r\nb = min(sensor->limits[SMIAPP_LIMIT_SCALER_M_MAX],\r\nmax(b, sensor->limits[SMIAPP_LIMIT_SCALER_M_MIN]));\r\nmax_m = min(sensor->limits[SMIAPP_LIMIT_SCALER_M_MAX],\r\nmax(max_m, sensor->limits[SMIAPP_LIMIT_SCALER_M_MIN]));\r\ndev_dbg(&client->dev, "scaling: a %d b %d max_m %d\n", a, b, max_m);\r\nmin = min(max_m, min(a, b));\r\nmax = min(max_m, max(a, b));\r\ntry[ntry] = min;\r\nntry++;\r\nif (min != max) {\r\ntry[ntry] = max;\r\nntry++;\r\n}\r\nif (max != max_m) {\r\ntry[ntry] = min + 1;\r\nntry++;\r\nif (min != max) {\r\ntry[ntry] = max + 1;\r\nntry++;\r\n}\r\n}\r\nfor (i = 0; i < ntry; i++) {\r\nint this = scaling_goodness(\r\nsubdev,\r\ncrops[SMIAPP_PAD_SINK]->width\r\n/ try[i]\r\n* sensor->limits[SMIAPP_LIMIT_SCALER_N_MIN],\r\nsel->r.width,\r\ncrops[SMIAPP_PAD_SINK]->height,\r\nsel->r.height,\r\nsel->flags);\r\ndev_dbg(&client->dev, "trying factor %d (%d)\n", try[i], i);\r\nif (this > best) {\r\nscale_m = try[i];\r\nmode = SMIAPP_SCALING_MODE_HORIZONTAL;\r\nbest = this;\r\n}\r\nif (sensor->limits[SMIAPP_LIMIT_SCALING_CAPABILITY]\r\n== SMIAPP_SCALING_CAPABILITY_HORIZONTAL)\r\ncontinue;\r\nthis = scaling_goodness(\r\nsubdev, crops[SMIAPP_PAD_SINK]->width\r\n/ try[i]\r\n* sensor->limits[SMIAPP_LIMIT_SCALER_N_MIN],\r\nsel->r.width,\r\ncrops[SMIAPP_PAD_SINK]->height\r\n/ try[i]\r\n* sensor->limits[SMIAPP_LIMIT_SCALER_N_MIN],\r\nsel->r.height,\r\nsel->flags);\r\nif (this > best) {\r\nscale_m = try[i];\r\nmode = SMIAPP_SCALING_MODE_BOTH;\r\nbest = this;\r\n}\r\n}\r\nsel->r.width =\r\n(crops[SMIAPP_PAD_SINK]->width\r\n/ scale_m\r\n* sensor->limits[SMIAPP_LIMIT_SCALER_N_MIN]) & ~1;\r\nif (mode == SMIAPP_SCALING_MODE_BOTH)\r\nsel->r.height =\r\n(crops[SMIAPP_PAD_SINK]->height\r\n/ scale_m\r\n* sensor->limits[SMIAPP_LIMIT_SCALER_N_MIN])\r\n& ~1;\r\nelse\r\nsel->r.height = crops[SMIAPP_PAD_SINK]->height;\r\nif (sel->which == V4L2_SUBDEV_FORMAT_ACTIVE) {\r\nsensor->scale_m = scale_m;\r\nsensor->scaling_mode = mode;\r\n}\r\n}\r\nstatic int smiapp_set_compose(struct v4l2_subdev *subdev,\r\nstruct v4l2_subdev_fh *fh,\r\nstruct v4l2_subdev_selection *sel)\r\n{\r\nstruct smiapp_sensor *sensor = to_smiapp_sensor(subdev);\r\nstruct smiapp_subdev *ssd = to_smiapp_subdev(subdev);\r\nstruct v4l2_rect *comp, *crops[SMIAPP_PADS];\r\nsmiapp_get_crop_compose(subdev, fh, crops, &comp, sel->which);\r\nsel->r.top = 0;\r\nsel->r.left = 0;\r\nif (ssd == sensor->binner)\r\nsmiapp_set_compose_binner(subdev, fh, sel, crops, comp);\r\nelse\r\nsmiapp_set_compose_scaler(subdev, fh, sel, crops, comp);\r\n*comp = sel->r;\r\nsmiapp_propagate(subdev, fh, sel->which,\r\nV4L2_SEL_TGT_COMPOSE);\r\nif (sel->which == V4L2_SUBDEV_FORMAT_ACTIVE)\r\nreturn smiapp_update_mode(sensor);\r\nreturn 0;\r\n}\r\nstatic int __smiapp_sel_supported(struct v4l2_subdev *subdev,\r\nstruct v4l2_subdev_selection *sel)\r\n{\r\nstruct smiapp_sensor *sensor = to_smiapp_sensor(subdev);\r\nstruct smiapp_subdev *ssd = to_smiapp_subdev(subdev);\r\nswitch (sel->target) {\r\ncase V4L2_SEL_TGT_CROP:\r\ncase V4L2_SEL_TGT_CROP_BOUNDS:\r\nif (ssd == sensor->pixel_array\r\n&& sel->pad == SMIAPP_PA_PAD_SRC)\r\nreturn 0;\r\nif (ssd == sensor->src\r\n&& sel->pad == SMIAPP_PAD_SRC)\r\nreturn 0;\r\nif (ssd == sensor->scaler\r\n&& sel->pad == SMIAPP_PAD_SINK\r\n&& sensor->limits[SMIAPP_LIMIT_DIGITAL_CROP_CAPABILITY]\r\n== SMIAPP_DIGITAL_CROP_CAPABILITY_INPUT_CROP)\r\nreturn 0;\r\nreturn -EINVAL;\r\ncase V4L2_SEL_TGT_COMPOSE:\r\ncase V4L2_SEL_TGT_COMPOSE_BOUNDS:\r\nif (sel->pad == ssd->source_pad)\r\nreturn -EINVAL;\r\nif (ssd == sensor->binner)\r\nreturn 0;\r\nif (ssd == sensor->scaler\r\n&& sensor->limits[SMIAPP_LIMIT_SCALING_CAPABILITY]\r\n!= SMIAPP_SCALING_CAPABILITY_NONE)\r\nreturn 0;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic int smiapp_set_crop(struct v4l2_subdev *subdev,\r\nstruct v4l2_subdev_fh *fh,\r\nstruct v4l2_subdev_selection *sel)\r\n{\r\nstruct smiapp_sensor *sensor = to_smiapp_sensor(subdev);\r\nstruct smiapp_subdev *ssd = to_smiapp_subdev(subdev);\r\nstruct v4l2_rect *src_size, *crops[SMIAPP_PADS];\r\nstruct v4l2_rect _r;\r\nsmiapp_get_crop_compose(subdev, fh, crops, NULL, sel->which);\r\nif (sel->which == V4L2_SUBDEV_FORMAT_ACTIVE) {\r\nif (sel->pad == ssd->sink_pad)\r\nsrc_size = &ssd->sink_fmt;\r\nelse\r\nsrc_size = &ssd->compose;\r\n} else {\r\nif (sel->pad == ssd->sink_pad) {\r\n_r.left = 0;\r\n_r.top = 0;\r\n_r.width = v4l2_subdev_get_try_format(fh, sel->pad)\r\n->width;\r\n_r.height = v4l2_subdev_get_try_format(fh, sel->pad)\r\n->height;\r\nsrc_size = &_r;\r\n} else {\r\nsrc_size =\r\nv4l2_subdev_get_try_compose(\r\nfh, ssd->sink_pad);\r\n}\r\n}\r\nif (ssd == sensor->src && sel->pad == SMIAPP_PAD_SRC) {\r\nsel->r.left = 0;\r\nsel->r.top = 0;\r\n}\r\nsel->r.width = min(sel->r.width, src_size->width);\r\nsel->r.height = min(sel->r.height, src_size->height);\r\nsel->r.left = min(sel->r.left, src_size->width - sel->r.width);\r\nsel->r.top = min(sel->r.top, src_size->height - sel->r.height);\r\n*crops[sel->pad] = sel->r;\r\nif (ssd != sensor->pixel_array && sel->pad == SMIAPP_PAD_SINK)\r\nsmiapp_propagate(subdev, fh, sel->which,\r\nV4L2_SEL_TGT_CROP);\r\nreturn 0;\r\n}\r\nstatic int __smiapp_get_selection(struct v4l2_subdev *subdev,\r\nstruct v4l2_subdev_fh *fh,\r\nstruct v4l2_subdev_selection *sel)\r\n{\r\nstruct smiapp_sensor *sensor = to_smiapp_sensor(subdev);\r\nstruct smiapp_subdev *ssd = to_smiapp_subdev(subdev);\r\nstruct v4l2_rect *comp, *crops[SMIAPP_PADS];\r\nstruct v4l2_rect sink_fmt;\r\nint ret;\r\nret = __smiapp_sel_supported(subdev, sel);\r\nif (ret)\r\nreturn ret;\r\nsmiapp_get_crop_compose(subdev, fh, crops, &comp, sel->which);\r\nif (sel->which == V4L2_SUBDEV_FORMAT_ACTIVE) {\r\nsink_fmt = ssd->sink_fmt;\r\n} else {\r\nstruct v4l2_mbus_framefmt *fmt =\r\nv4l2_subdev_get_try_format(fh, ssd->sink_pad);\r\nsink_fmt.left = 0;\r\nsink_fmt.top = 0;\r\nsink_fmt.width = fmt->width;\r\nsink_fmt.height = fmt->height;\r\n}\r\nswitch (sel->target) {\r\ncase V4L2_SEL_TGT_CROP_BOUNDS:\r\nif (ssd == sensor->pixel_array) {\r\nsel->r.width =\r\nsensor->limits[SMIAPP_LIMIT_X_ADDR_MAX] + 1;\r\nsel->r.height =\r\nsensor->limits[SMIAPP_LIMIT_Y_ADDR_MAX] + 1;\r\n} else if (sel->pad == ssd->sink_pad) {\r\nsel->r = sink_fmt;\r\n} else {\r\nsel->r = *comp;\r\n}\r\nbreak;\r\ncase V4L2_SEL_TGT_CROP:\r\ncase V4L2_SEL_TGT_COMPOSE_BOUNDS:\r\nsel->r = *crops[sel->pad];\r\nbreak;\r\ncase V4L2_SEL_TGT_COMPOSE:\r\nsel->r = *comp;\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int smiapp_get_selection(struct v4l2_subdev *subdev,\r\nstruct v4l2_subdev_fh *fh,\r\nstruct v4l2_subdev_selection *sel)\r\n{\r\nstruct smiapp_sensor *sensor = to_smiapp_sensor(subdev);\r\nint rval;\r\nmutex_lock(&sensor->mutex);\r\nrval = __smiapp_get_selection(subdev, fh, sel);\r\nmutex_unlock(&sensor->mutex);\r\nreturn rval;\r\n}\r\nstatic int smiapp_set_selection(struct v4l2_subdev *subdev,\r\nstruct v4l2_subdev_fh *fh,\r\nstruct v4l2_subdev_selection *sel)\r\n{\r\nstruct smiapp_sensor *sensor = to_smiapp_sensor(subdev);\r\nint ret;\r\nret = __smiapp_sel_supported(subdev, sel);\r\nif (ret)\r\nreturn ret;\r\nmutex_lock(&sensor->mutex);\r\nsel->r.left = max(0, sel->r.left & ~1);\r\nsel->r.top = max(0, sel->r.top & ~1);\r\nsel->r.width = max(0, SMIAPP_ALIGN_DIM(sel->r.width, sel->flags));\r\nsel->r.height = max(0, SMIAPP_ALIGN_DIM(sel->r.height, sel->flags));\r\nsel->r.width = max_t(unsigned int,\r\nsensor->limits[SMIAPP_LIMIT_MIN_X_OUTPUT_SIZE],\r\nsel->r.width);\r\nsel->r.height = max_t(unsigned int,\r\nsensor->limits[SMIAPP_LIMIT_MIN_Y_OUTPUT_SIZE],\r\nsel->r.height);\r\nswitch (sel->target) {\r\ncase V4L2_SEL_TGT_CROP:\r\nret = smiapp_set_crop(subdev, fh, sel);\r\nbreak;\r\ncase V4L2_SEL_TGT_COMPOSE:\r\nret = smiapp_set_compose(subdev, fh, sel);\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\nmutex_unlock(&sensor->mutex);\r\nreturn ret;\r\n}\r\nstatic int smiapp_get_skip_frames(struct v4l2_subdev *subdev, u32 *frames)\r\n{\r\nstruct smiapp_sensor *sensor = to_smiapp_sensor(subdev);\r\n*frames = sensor->frame_skip;\r\nreturn 0;\r\n}\r\nstatic ssize_t\r\nsmiapp_sysfs_nvm_read(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct v4l2_subdev *subdev = i2c_get_clientdata(to_i2c_client(dev));\r\nstruct i2c_client *client = v4l2_get_subdevdata(subdev);\r\nstruct smiapp_sensor *sensor = to_smiapp_sensor(subdev);\r\nunsigned int nbytes;\r\nif (!sensor->dev_init_done)\r\nreturn -EBUSY;\r\nif (!sensor->nvm_size) {\r\nsensor->nvm_size = sensor->platform_data->nvm_size;\r\nif (smiapp_set_power(subdev, 1) < 0)\r\nreturn -ENODEV;\r\nif (smiapp_read_nvm(sensor, sensor->nvm)) {\r\ndev_err(&client->dev, "nvm read failed\n");\r\nreturn -ENODEV;\r\n}\r\nsmiapp_set_power(subdev, 0);\r\n}\r\nnbytes = min_t(unsigned int, sensor->nvm_size, PAGE_SIZE);\r\nmemcpy(buf, sensor->nvm, nbytes);\r\nreturn nbytes;\r\n}\r\nstatic ssize_t\r\nsmiapp_sysfs_ident_read(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct v4l2_subdev *subdev = i2c_get_clientdata(to_i2c_client(dev));\r\nstruct smiapp_sensor *sensor = to_smiapp_sensor(subdev);\r\nstruct smiapp_module_info *minfo = &sensor->minfo;\r\nreturn snprintf(buf, PAGE_SIZE, "%2.2x%4.4x%2.2x\n",\r\nminfo->manufacturer_id, minfo->model_id,\r\nminfo->revision_number_major) + 1;\r\n}\r\nstatic int smiapp_identify_module(struct v4l2_subdev *subdev)\r\n{\r\nstruct smiapp_sensor *sensor = to_smiapp_sensor(subdev);\r\nstruct i2c_client *client = v4l2_get_subdevdata(subdev);\r\nstruct smiapp_module_info *minfo = &sensor->minfo;\r\nunsigned int i;\r\nint rval = 0;\r\nminfo->name = SMIAPP_NAME;\r\nrval = smiapp_read_8only(sensor, SMIAPP_REG_U8_MANUFACTURER_ID,\r\n&minfo->manufacturer_id);\r\nif (!rval)\r\nrval = smiapp_read_8only(sensor, SMIAPP_REG_U16_MODEL_ID,\r\n&minfo->model_id);\r\nif (!rval)\r\nrval = smiapp_read_8only(sensor,\r\nSMIAPP_REG_U8_REVISION_NUMBER_MAJOR,\r\n&minfo->revision_number_major);\r\nif (!rval)\r\nrval = smiapp_read_8only(sensor,\r\nSMIAPP_REG_U8_REVISION_NUMBER_MINOR,\r\n&minfo->revision_number_minor);\r\nif (!rval)\r\nrval = smiapp_read_8only(sensor,\r\nSMIAPP_REG_U8_MODULE_DATE_YEAR,\r\n&minfo->module_year);\r\nif (!rval)\r\nrval = smiapp_read_8only(sensor,\r\nSMIAPP_REG_U8_MODULE_DATE_MONTH,\r\n&minfo->module_month);\r\nif (!rval)\r\nrval = smiapp_read_8only(sensor, SMIAPP_REG_U8_MODULE_DATE_DAY,\r\n&minfo->module_day);\r\nif (!rval)\r\nrval = smiapp_read_8only(sensor,\r\nSMIAPP_REG_U8_SENSOR_MANUFACTURER_ID,\r\n&minfo->sensor_manufacturer_id);\r\nif (!rval)\r\nrval = smiapp_read_8only(sensor,\r\nSMIAPP_REG_U16_SENSOR_MODEL_ID,\r\n&minfo->sensor_model_id);\r\nif (!rval)\r\nrval = smiapp_read_8only(sensor,\r\nSMIAPP_REG_U8_SENSOR_REVISION_NUMBER,\r\n&minfo->sensor_revision_number);\r\nif (!rval)\r\nrval = smiapp_read_8only(sensor,\r\nSMIAPP_REG_U8_SENSOR_FIRMWARE_VERSION,\r\n&minfo->sensor_firmware_version);\r\nif (!rval)\r\nrval = smiapp_read_8only(sensor, SMIAPP_REG_U8_SMIA_VERSION,\r\n&minfo->smia_version);\r\nif (!rval)\r\nrval = smiapp_read_8only(sensor, SMIAPP_REG_U8_SMIAPP_VERSION,\r\n&minfo->smiapp_version);\r\nif (rval) {\r\ndev_err(&client->dev, "sensor detection failed\n");\r\nreturn -ENODEV;\r\n}\r\ndev_dbg(&client->dev, "module 0x%2.2x-0x%4.4x\n",\r\nminfo->manufacturer_id, minfo->model_id);\r\ndev_dbg(&client->dev,\r\n"module revision 0x%2.2x-0x%2.2x date %2.2d-%2.2d-%2.2d\n",\r\nminfo->revision_number_major, minfo->revision_number_minor,\r\nminfo->module_year, minfo->module_month, minfo->module_day);\r\ndev_dbg(&client->dev, "sensor 0x%2.2x-0x%4.4x\n",\r\nminfo->sensor_manufacturer_id, minfo->sensor_model_id);\r\ndev_dbg(&client->dev,\r\n"sensor revision 0x%2.2x firmware version 0x%2.2x\n",\r\nminfo->sensor_revision_number, minfo->sensor_firmware_version);\r\ndev_dbg(&client->dev, "smia version %2.2d smiapp version %2.2d\n",\r\nminfo->smia_version, minfo->smiapp_version);\r\nif (!minfo->manufacturer_id && !minfo->model_id) {\r\nminfo->manufacturer_id = minfo->sensor_manufacturer_id;\r\nminfo->model_id = minfo->sensor_model_id;\r\nminfo->revision_number_major = minfo->sensor_revision_number;\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(smiapp_module_idents); i++) {\r\nif (smiapp_module_idents[i].manufacturer_id\r\n!= minfo->manufacturer_id)\r\ncontinue;\r\nif (smiapp_module_idents[i].model_id != minfo->model_id)\r\ncontinue;\r\nif (smiapp_module_idents[i].flags\r\n& SMIAPP_MODULE_IDENT_FLAG_REV_LE) {\r\nif (smiapp_module_idents[i].revision_number_major\r\n< minfo->revision_number_major)\r\ncontinue;\r\n} else {\r\nif (smiapp_module_idents[i].revision_number_major\r\n!= minfo->revision_number_major)\r\ncontinue;\r\n}\r\nminfo->name = smiapp_module_idents[i].name;\r\nminfo->quirk = smiapp_module_idents[i].quirk;\r\nbreak;\r\n}\r\nif (i >= ARRAY_SIZE(smiapp_module_idents))\r\ndev_warn(&client->dev,\r\n"no quirks for this module; let's hope it's fully compliant\n");\r\ndev_dbg(&client->dev, "the sensor is called %s, ident %2.2x%4.4x%2.2x\n",\r\nminfo->name, minfo->manufacturer_id, minfo->model_id,\r\nminfo->revision_number_major);\r\nstrlcpy(subdev->name, sensor->minfo.name, sizeof(subdev->name));\r\nreturn 0;\r\n}\r\nstatic int smiapp_registered(struct v4l2_subdev *subdev)\r\n{\r\nstruct smiapp_sensor *sensor = to_smiapp_sensor(subdev);\r\nstruct i2c_client *client = v4l2_get_subdevdata(subdev);\r\nstruct smiapp_pll *pll = &sensor->pll;\r\nstruct smiapp_subdev *last = NULL;\r\nu32 tmp;\r\nunsigned int i;\r\nint rval;\r\nsensor->vana = devm_regulator_get(&client->dev, "VANA");\r\nif (IS_ERR(sensor->vana)) {\r\ndev_err(&client->dev, "could not get regulator for vana\n");\r\nreturn -ENODEV;\r\n}\r\nif (!sensor->platform_data->set_xclk) {\r\nsensor->ext_clk = devm_clk_get(&client->dev,\r\nsensor->platform_data->ext_clk_name);\r\nif (IS_ERR(sensor->ext_clk)) {\r\ndev_err(&client->dev, "could not get clock %s\n",\r\nsensor->platform_data->ext_clk_name);\r\nreturn -ENODEV;\r\n}\r\nrval = clk_set_rate(sensor->ext_clk,\r\nsensor->platform_data->ext_clk);\r\nif (rval < 0) {\r\ndev_err(&client->dev,\r\n"unable to set clock %s freq to %u\n",\r\nsensor->platform_data->ext_clk_name,\r\nsensor->platform_data->ext_clk);\r\nreturn -ENODEV;\r\n}\r\n}\r\nif (sensor->platform_data->xshutdown != SMIAPP_NO_XSHUTDOWN) {\r\nif (gpio_request_one(sensor->platform_data->xshutdown, 0,\r\n"SMIA++ xshutdown") != 0) {\r\ndev_err(&client->dev,\r\n"unable to acquire reset gpio %d\n",\r\nsensor->platform_data->xshutdown);\r\nreturn -ENODEV;\r\n}\r\n}\r\nrval = smiapp_power_on(sensor);\r\nif (rval) {\r\nrval = -ENODEV;\r\ngoto out_smiapp_power_on;\r\n}\r\nrval = smiapp_identify_module(subdev);\r\nif (rval) {\r\nrval = -ENODEV;\r\ngoto out_power_off;\r\n}\r\nrval = smiapp_get_all_limits(sensor);\r\nif (rval) {\r\nrval = -ENODEV;\r\ngoto out_power_off;\r\n}\r\nif (sensor->platform_data->module_board_orient ==\r\nSMIAPP_MODULE_BOARD_ORIENT_180)\r\nsensor->hvflip_inv_mask = SMIAPP_IMAGE_ORIENTATION_HFLIP |\r\nSMIAPP_IMAGE_ORIENTATION_VFLIP;\r\nrval = smiapp_get_mbus_formats(sensor);\r\nif (rval) {\r\nrval = -ENODEV;\r\ngoto out_power_off;\r\n}\r\nif (sensor->limits[SMIAPP_LIMIT_BINNING_CAPABILITY]) {\r\nu32 val;\r\nrval = smiapp_read(sensor,\r\nSMIAPP_REG_U8_BINNING_SUBTYPES, &val);\r\nif (rval < 0) {\r\nrval = -ENODEV;\r\ngoto out_power_off;\r\n}\r\nsensor->nbinning_subtypes = min_t(u8, val,\r\nSMIAPP_BINNING_SUBTYPES);\r\nfor (i = 0; i < sensor->nbinning_subtypes; i++) {\r\nrval = smiapp_read(\r\nsensor, SMIAPP_REG_U8_BINNING_TYPE_n(i), &val);\r\nif (rval < 0) {\r\nrval = -ENODEV;\r\ngoto out_power_off;\r\n}\r\nsensor->binning_subtypes[i] =\r\n*(struct smiapp_binning_subtype *)&val;\r\ndev_dbg(&client->dev, "binning %xx%x\n",\r\nsensor->binning_subtypes[i].horizontal,\r\nsensor->binning_subtypes[i].vertical);\r\n}\r\n}\r\nsensor->binning_horizontal = 1;\r\nsensor->binning_vertical = 1;\r\nif (device_create_file(&client->dev, &dev_attr_ident) != 0) {\r\ndev_err(&client->dev, "sysfs ident entry creation failed\n");\r\nrval = -ENOENT;\r\ngoto out_power_off;\r\n}\r\nif (sensor->minfo.smiapp_version && sensor->platform_data->nvm_size) {\r\nsensor->nvm = devm_kzalloc(&client->dev,\r\nsensor->platform_data->nvm_size, GFP_KERNEL);\r\nif (sensor->nvm == NULL) {\r\ndev_err(&client->dev, "nvm buf allocation failed\n");\r\nrval = -ENOMEM;\r\ngoto out_ident_release;\r\n}\r\nif (device_create_file(&client->dev, &dev_attr_nvm) != 0) {\r\ndev_err(&client->dev, "sysfs nvm entry failed\n");\r\nrval = -EBUSY;\r\ngoto out_ident_release;\r\n}\r\n}\r\nrval = smiapp_call_quirk(sensor, limits);\r\nif (rval) {\r\ndev_err(&client->dev, "limits quirks failed\n");\r\ngoto out_nvm_release;\r\n}\r\nif (!sensor->limits[SMIAPP_LIMIT_MIN_OP_SYS_CLK_DIV] ||\r\n!sensor->limits[SMIAPP_LIMIT_MAX_OP_SYS_CLK_DIV] ||\r\n!sensor->limits[SMIAPP_LIMIT_MIN_OP_PIX_CLK_DIV] ||\r\n!sensor->limits[SMIAPP_LIMIT_MAX_OP_PIX_CLK_DIV]) {\r\nsensor->minfo.smiapp_profile = SMIAPP_PROFILE_0;\r\n} else if (sensor->limits[SMIAPP_LIMIT_SCALING_CAPABILITY]\r\n!= SMIAPP_SCALING_CAPABILITY_NONE) {\r\nif (sensor->limits[SMIAPP_LIMIT_SCALING_CAPABILITY]\r\n== SMIAPP_SCALING_CAPABILITY_HORIZONTAL)\r\nsensor->minfo.smiapp_profile = SMIAPP_PROFILE_1;\r\nelse\r\nsensor->minfo.smiapp_profile = SMIAPP_PROFILE_2;\r\nsensor->scaler = &sensor->ssds[sensor->ssds_used];\r\nsensor->ssds_used++;\r\n} else if (sensor->limits[SMIAPP_LIMIT_DIGITAL_CROP_CAPABILITY]\r\n== SMIAPP_DIGITAL_CROP_CAPABILITY_INPUT_CROP) {\r\nsensor->scaler = &sensor->ssds[sensor->ssds_used];\r\nsensor->ssds_used++;\r\n}\r\nsensor->binner = &sensor->ssds[sensor->ssds_used];\r\nsensor->ssds_used++;\r\nsensor->pixel_array = &sensor->ssds[sensor->ssds_used];\r\nsensor->ssds_used++;\r\nsensor->scale_m = sensor->limits[SMIAPP_LIMIT_SCALER_N_MIN];\r\nfor (i = 0; i < SMIAPP_SUBDEVS; i++) {\r\nstruct {\r\nstruct smiapp_subdev *ssd;\r\nchar *name;\r\n} const __this[] = {\r\n{ sensor->scaler, "scaler", },\r\n{ sensor->binner, "binner", },\r\n{ sensor->pixel_array, "pixel array", },\r\n}, *_this = &__this[i];\r\nstruct smiapp_subdev *this = _this->ssd;\r\nif (!this)\r\ncontinue;\r\nif (this != sensor->src)\r\nv4l2_subdev_init(&this->sd, &smiapp_ops);\r\nthis->sensor = sensor;\r\nif (this == sensor->pixel_array) {\r\nthis->npads = 1;\r\n} else {\r\nthis->npads = 2;\r\nthis->source_pad = 1;\r\n}\r\nsnprintf(this->sd.name,\r\nsizeof(this->sd.name), "%s %s",\r\nsensor->minfo.name, _this->name);\r\nthis->sink_fmt.width =\r\nsensor->limits[SMIAPP_LIMIT_X_ADDR_MAX] + 1;\r\nthis->sink_fmt.height =\r\nsensor->limits[SMIAPP_LIMIT_Y_ADDR_MAX] + 1;\r\nthis->compose.width = this->sink_fmt.width;\r\nthis->compose.height = this->sink_fmt.height;\r\nthis->crop[this->source_pad] = this->compose;\r\nthis->pads[this->source_pad].flags = MEDIA_PAD_FL_SOURCE;\r\nif (this != sensor->pixel_array) {\r\nthis->crop[this->sink_pad] = this->compose;\r\nthis->pads[this->sink_pad].flags = MEDIA_PAD_FL_SINK;\r\n}\r\nthis->sd.entity.ops = &smiapp_entity_ops;\r\nif (last == NULL) {\r\nlast = this;\r\ncontinue;\r\n}\r\nthis->sd.flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;\r\nthis->sd.internal_ops = &smiapp_internal_ops;\r\nthis->sd.owner = NULL;\r\nv4l2_set_subdevdata(&this->sd, client);\r\nrval = media_entity_init(&this->sd.entity,\r\nthis->npads, this->pads, 0);\r\nif (rval) {\r\ndev_err(&client->dev,\r\n"media_entity_init failed\n");\r\ngoto out_nvm_release;\r\n}\r\nrval = media_entity_create_link(&this->sd.entity,\r\nthis->source_pad,\r\n&last->sd.entity,\r\nlast->sink_pad,\r\nMEDIA_LNK_FL_ENABLED |\r\nMEDIA_LNK_FL_IMMUTABLE);\r\nif (rval) {\r\ndev_err(&client->dev,\r\n"media_entity_create_link failed\n");\r\ngoto out_nvm_release;\r\n}\r\nrval = v4l2_device_register_subdev(sensor->src->sd.v4l2_dev,\r\n&this->sd);\r\nif (rval) {\r\ndev_err(&client->dev,\r\n"v4l2_device_register_subdev failed\n");\r\ngoto out_nvm_release;\r\n}\r\nlast = this;\r\n}\r\ndev_dbg(&client->dev, "profile %d\n", sensor->minfo.smiapp_profile);\r\nsensor->pixel_array->sd.entity.type = MEDIA_ENT_T_V4L2_SUBDEV_SENSOR;\r\nsmiapp_read_frame_fmt(sensor);\r\nrval = smiapp_init_controls(sensor);\r\nif (rval < 0)\r\ngoto out_nvm_release;\r\npll->bus_type = SMIAPP_PLL_BUS_TYPE_CSI2;\r\npll->csi2.lanes = sensor->platform_data->lanes;\r\npll->ext_clk_freq_hz = sensor->platform_data->ext_clk;\r\nif (sensor->minfo.smiapp_profile == SMIAPP_PROFILE_0)\r\npll->flags |= SMIAPP_PLL_FLAG_NO_OP_CLOCKS;\r\nif (smiapp_needs_quirk(sensor,\r\nSMIAPP_QUIRK_FLAG_OP_PIX_CLOCK_PER_LANE))\r\npll->flags |= SMIAPP_PLL_FLAG_OP_PIX_CLOCK_PER_LANE;\r\npll->scale_n = sensor->limits[SMIAPP_LIMIT_SCALER_N_MIN];\r\nrval = smiapp_update_mode(sensor);\r\nif (rval) {\r\ndev_err(&client->dev, "update mode failed\n");\r\ngoto out_nvm_release;\r\n}\r\nsensor->streaming = false;\r\nsensor->dev_init_done = true;\r\nrval = smiapp_read(sensor, SMIAPP_REG_U8_FLASH_MODE_CAPABILITY, &tmp);\r\nsensor->flash_capability = tmp;\r\nif (rval)\r\ngoto out_nvm_release;\r\nsmiapp_power_off(sensor);\r\nreturn 0;\r\nout_nvm_release:\r\ndevice_remove_file(&client->dev, &dev_attr_nvm);\r\nout_ident_release:\r\ndevice_remove_file(&client->dev, &dev_attr_ident);\r\nout_power_off:\r\nsmiapp_power_off(sensor);\r\nout_smiapp_power_on:\r\nif (sensor->platform_data->xshutdown != SMIAPP_NO_XSHUTDOWN)\r\ngpio_free(sensor->platform_data->xshutdown);\r\nreturn rval;\r\n}\r\nstatic int smiapp_open(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh)\r\n{\r\nstruct smiapp_subdev *ssd = to_smiapp_subdev(sd);\r\nstruct smiapp_sensor *sensor = ssd->sensor;\r\nu32 mbus_code =\r\nsmiapp_csi_data_formats[smiapp_pixel_order(sensor)].code;\r\nunsigned int i;\r\nmutex_lock(&sensor->mutex);\r\nfor (i = 0; i < ssd->npads; i++) {\r\nstruct v4l2_mbus_framefmt *try_fmt =\r\nv4l2_subdev_get_try_format(fh, i);\r\nstruct v4l2_rect *try_crop = v4l2_subdev_get_try_crop(fh, i);\r\nstruct v4l2_rect *try_comp;\r\ntry_fmt->width = sensor->limits[SMIAPP_LIMIT_X_ADDR_MAX] + 1;\r\ntry_fmt->height = sensor->limits[SMIAPP_LIMIT_Y_ADDR_MAX] + 1;\r\ntry_fmt->code = mbus_code;\r\ntry_crop->top = 0;\r\ntry_crop->left = 0;\r\ntry_crop->width = try_fmt->width;\r\ntry_crop->height = try_fmt->height;\r\nif (ssd != sensor->pixel_array)\r\ncontinue;\r\ntry_comp = v4l2_subdev_get_try_compose(fh, i);\r\n*try_comp = *try_crop;\r\n}\r\nmutex_unlock(&sensor->mutex);\r\nreturn smiapp_set_power(sd, 1);\r\n}\r\nstatic int smiapp_close(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh)\r\n{\r\nreturn smiapp_set_power(sd, 0);\r\n}\r\nstatic int smiapp_suspend(struct device *dev)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct v4l2_subdev *subdev = i2c_get_clientdata(client);\r\nstruct smiapp_sensor *sensor = to_smiapp_sensor(subdev);\r\nbool streaming;\r\nBUG_ON(mutex_is_locked(&sensor->mutex));\r\nif (sensor->power_count == 0)\r\nreturn 0;\r\nif (sensor->streaming)\r\nsmiapp_stop_streaming(sensor);\r\nstreaming = sensor->streaming;\r\nsmiapp_power_off(sensor);\r\nsensor->streaming = streaming;\r\nreturn 0;\r\n}\r\nstatic int smiapp_resume(struct device *dev)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct v4l2_subdev *subdev = i2c_get_clientdata(client);\r\nstruct smiapp_sensor *sensor = to_smiapp_sensor(subdev);\r\nint rval;\r\nif (sensor->power_count == 0)\r\nreturn 0;\r\nrval = smiapp_power_on(sensor);\r\nif (rval)\r\nreturn rval;\r\nif (sensor->streaming)\r\nrval = smiapp_start_streaming(sensor);\r\nreturn rval;\r\n}\r\nstatic int smiapp_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *devid)\r\n{\r\nstruct smiapp_sensor *sensor;\r\nif (client->dev.platform_data == NULL)\r\nreturn -ENODEV;\r\nsensor = devm_kzalloc(&client->dev, sizeof(*sensor), GFP_KERNEL);\r\nif (sensor == NULL)\r\nreturn -ENOMEM;\r\nsensor->platform_data = client->dev.platform_data;\r\nmutex_init(&sensor->mutex);\r\nmutex_init(&sensor->power_mutex);\r\nsensor->src = &sensor->ssds[sensor->ssds_used];\r\nv4l2_i2c_subdev_init(&sensor->src->sd, client, &smiapp_ops);\r\nsensor->src->sd.internal_ops = &smiapp_internal_src_ops;\r\nsensor->src->sd.flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;\r\nsensor->src->sensor = sensor;\r\nsensor->src->pads[0].flags = MEDIA_PAD_FL_SOURCE;\r\nreturn media_entity_init(&sensor->src->sd.entity, 2,\r\nsensor->src->pads, 0);\r\n}\r\nstatic int __exit smiapp_remove(struct i2c_client *client)\r\n{\r\nstruct v4l2_subdev *subdev = i2c_get_clientdata(client);\r\nstruct smiapp_sensor *sensor = to_smiapp_sensor(subdev);\r\nunsigned int i;\r\nif (sensor->power_count) {\r\nif (sensor->platform_data->xshutdown != SMIAPP_NO_XSHUTDOWN)\r\ngpio_set_value(sensor->platform_data->xshutdown, 0);\r\nif (sensor->platform_data->set_xclk)\r\nsensor->platform_data->set_xclk(&sensor->src->sd, 0);\r\nelse\r\nclk_disable(sensor->ext_clk);\r\nsensor->power_count = 0;\r\n}\r\ndevice_remove_file(&client->dev, &dev_attr_ident);\r\nif (sensor->nvm)\r\ndevice_remove_file(&client->dev, &dev_attr_nvm);\r\nfor (i = 0; i < sensor->ssds_used; i++) {\r\nmedia_entity_cleanup(&sensor->ssds[i].sd.entity);\r\nv4l2_device_unregister_subdev(&sensor->ssds[i].sd);\r\n}\r\nsmiapp_free_controls(sensor);\r\nif (sensor->platform_data->xshutdown != SMIAPP_NO_XSHUTDOWN)\r\ngpio_free(sensor->platform_data->xshutdown);\r\nreturn 0;\r\n}
