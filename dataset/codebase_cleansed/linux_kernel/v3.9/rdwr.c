static int cachefiles_read_waiter(wait_queue_t *wait, unsigned mode,\r\nint sync, void *_key)\r\n{\r\nstruct cachefiles_one_read *monitor =\r\ncontainer_of(wait, struct cachefiles_one_read, monitor);\r\nstruct cachefiles_object *object;\r\nstruct wait_bit_key *key = _key;\r\nstruct page *page = wait->private;\r\nASSERT(key);\r\n_enter("{%lu},%u,%d,{%p,%u}",\r\nmonitor->netfs_page->index, mode, sync,\r\nkey->flags, key->bit_nr);\r\nif (key->flags != &page->flags ||\r\nkey->bit_nr != PG_locked)\r\nreturn 0;\r\n_debug("--- monitor %p %lx ---", page, page->flags);\r\nif (!PageUptodate(page) && !PageError(page)) {\r\n_debug("page probably truncated");\r\n}\r\nlist_del(&wait->task_list);\r\nASSERT(monitor->op);\r\nobject = container_of(monitor->op->op.object,\r\nstruct cachefiles_object, fscache);\r\nspin_lock(&object->work_lock);\r\nlist_add_tail(&monitor->op_link, &monitor->op->to_do);\r\nspin_unlock(&object->work_lock);\r\nfscache_enqueue_retrieval(monitor->op);\r\nreturn 0;\r\n}\r\nstatic int cachefiles_read_reissue(struct cachefiles_object *object,\r\nstruct cachefiles_one_read *monitor)\r\n{\r\nstruct address_space *bmapping = object->backer->d_inode->i_mapping;\r\nstruct page *backpage = monitor->back_page, *backpage2;\r\nint ret;\r\n_enter("{ino=%lx},{%lx,%lx}",\r\nobject->backer->d_inode->i_ino,\r\nbackpage->index, backpage->flags);\r\nif (backpage->mapping != bmapping) {\r\n_leave(" = -ENODATA [mapping]");\r\nreturn -ENODATA;\r\n}\r\nbackpage2 = find_get_page(bmapping, backpage->index);\r\nif (!backpage2) {\r\n_leave(" = -ENODATA [gone]");\r\nreturn -ENODATA;\r\n}\r\nif (backpage != backpage2) {\r\nput_page(backpage2);\r\n_leave(" = -ENODATA [different]");\r\nreturn -ENODATA;\r\n}\r\nput_page(backpage2);\r\nINIT_LIST_HEAD(&monitor->op_link);\r\nadd_page_wait_queue(backpage, &monitor->monitor);\r\nif (trylock_page(backpage)) {\r\nret = -EIO;\r\nif (PageError(backpage))\r\ngoto unlock_discard;\r\nret = 0;\r\nif (PageUptodate(backpage))\r\ngoto unlock_discard;\r\n_debug("reissue read");\r\nret = bmapping->a_ops->readpage(NULL, backpage);\r\nif (ret < 0)\r\ngoto unlock_discard;\r\n}\r\nif (trylock_page(backpage)) {\r\n_debug("jumpstart %p {%lx}", backpage, backpage->flags);\r\nunlock_page(backpage);\r\n}\r\n_leave(" = -EINPROGRESS");\r\nreturn -EINPROGRESS;\r\nunlock_discard:\r\nunlock_page(backpage);\r\nspin_lock_irq(&object->work_lock);\r\nlist_del(&monitor->op_link);\r\nspin_unlock_irq(&object->work_lock);\r\n_leave(" = %d", ret);\r\nreturn ret;\r\n}\r\nstatic void cachefiles_read_copier(struct fscache_operation *_op)\r\n{\r\nstruct cachefiles_one_read *monitor;\r\nstruct cachefiles_object *object;\r\nstruct fscache_retrieval *op;\r\nstruct pagevec pagevec;\r\nint error, max;\r\nop = container_of(_op, struct fscache_retrieval, op);\r\nobject = container_of(op->op.object,\r\nstruct cachefiles_object, fscache);\r\n_enter("{ino=%lu}", object->backer->d_inode->i_ino);\r\npagevec_init(&pagevec, 0);\r\nmax = 8;\r\nspin_lock_irq(&object->work_lock);\r\nwhile (!list_empty(&op->to_do)) {\r\nmonitor = list_entry(op->to_do.next,\r\nstruct cachefiles_one_read, op_link);\r\nlist_del(&monitor->op_link);\r\nspin_unlock_irq(&object->work_lock);\r\n_debug("- copy {%lu}", monitor->back_page->index);\r\nrecheck:\r\nif (test_bit(FSCACHE_COOKIE_INVALIDATING,\r\n&object->fscache.cookie->flags)) {\r\nerror = -ESTALE;\r\n} else if (PageUptodate(monitor->back_page)) {\r\ncopy_highpage(monitor->netfs_page, monitor->back_page);\r\nfscache_mark_page_cached(monitor->op,\r\nmonitor->netfs_page);\r\nerror = 0;\r\n} else if (!PageError(monitor->back_page)) {\r\nerror = cachefiles_read_reissue(object, monitor);\r\nif (error == -EINPROGRESS)\r\ngoto next;\r\ngoto recheck;\r\n} else {\r\ncachefiles_io_error_obj(\r\nobject,\r\n"Readpage failed on backing file %lx",\r\n(unsigned long) monitor->back_page->flags);\r\nerror = -EIO;\r\n}\r\npage_cache_release(monitor->back_page);\r\nfscache_end_io(op, monitor->netfs_page, error);\r\npage_cache_release(monitor->netfs_page);\r\nfscache_retrieval_complete(op, 1);\r\nfscache_put_retrieval(op);\r\nkfree(monitor);\r\nnext:\r\nmax--;\r\nif (max < 0 || need_resched()) {\r\nif (!list_empty(&op->to_do))\r\nfscache_enqueue_retrieval(op);\r\n_leave(" [maxed out]");\r\nreturn;\r\n}\r\nspin_lock_irq(&object->work_lock);\r\n}\r\nspin_unlock_irq(&object->work_lock);\r\n_leave("");\r\n}\r\nstatic int cachefiles_read_backing_file_one(struct cachefiles_object *object,\r\nstruct fscache_retrieval *op,\r\nstruct page *netpage,\r\nstruct pagevec *pagevec)\r\n{\r\nstruct cachefiles_one_read *monitor;\r\nstruct address_space *bmapping;\r\nstruct page *newpage, *backpage;\r\nint ret;\r\n_enter("");\r\npagevec_reinit(pagevec);\r\n_debug("read back %p{%lu,%d}",\r\nnetpage, netpage->index, page_count(netpage));\r\nmonitor = kzalloc(sizeof(*monitor), cachefiles_gfp);\r\nif (!monitor)\r\ngoto nomem;\r\nmonitor->netfs_page = netpage;\r\nmonitor->op = fscache_get_retrieval(op);\r\ninit_waitqueue_func_entry(&monitor->monitor, cachefiles_read_waiter);\r\nbmapping = object->backer->d_inode->i_mapping;\r\nnewpage = NULL;\r\nfor (;;) {\r\nbackpage = find_get_page(bmapping, netpage->index);\r\nif (backpage)\r\ngoto backing_page_already_present;\r\nif (!newpage) {\r\nnewpage = __page_cache_alloc(cachefiles_gfp |\r\n__GFP_COLD);\r\nif (!newpage)\r\ngoto nomem_monitor;\r\n}\r\nret = add_to_page_cache(newpage, bmapping,\r\nnetpage->index, cachefiles_gfp);\r\nif (ret == 0)\r\ngoto installed_new_backing_page;\r\nif (ret != -EEXIST)\r\ngoto nomem_page;\r\n}\r\ninstalled_new_backing_page:\r\n_debug("- new %p", newpage);\r\nbackpage = newpage;\r\nnewpage = NULL;\r\npage_cache_get(backpage);\r\npagevec_add(pagevec, backpage);\r\n__pagevec_lru_add_file(pagevec);\r\nread_backing_page:\r\nret = bmapping->a_ops->readpage(NULL, backpage);\r\nif (ret < 0)\r\ngoto read_error;\r\nmonitor_backing_page:\r\n_debug("- monitor add");\r\npage_cache_get(monitor->netfs_page);\r\npage_cache_get(backpage);\r\nmonitor->back_page = backpage;\r\nmonitor->monitor.private = backpage;\r\nadd_page_wait_queue(backpage, &monitor->monitor);\r\nmonitor = NULL;\r\nif (trylock_page(backpage)) {\r\n_debug("jumpstart %p {%lx}", backpage, backpage->flags);\r\nunlock_page(backpage);\r\n}\r\ngoto success;\r\nbacking_page_already_present:\r\n_debug("- present");\r\nif (newpage) {\r\npage_cache_release(newpage);\r\nnewpage = NULL;\r\n}\r\nif (PageError(backpage))\r\ngoto io_error;\r\nif (PageUptodate(backpage))\r\ngoto backing_page_already_uptodate;\r\nif (!trylock_page(backpage))\r\ngoto monitor_backing_page;\r\n_debug("read %p {%lx}", backpage, backpage->flags);\r\ngoto read_backing_page;\r\nbacking_page_already_uptodate:\r\n_debug("- uptodate");\r\nfscache_mark_page_cached(op, netpage);\r\ncopy_highpage(netpage, backpage);\r\nfscache_end_io(op, netpage, 0);\r\nfscache_retrieval_complete(op, 1);\r\nsuccess:\r\n_debug("success");\r\nret = 0;\r\nout:\r\nif (backpage)\r\npage_cache_release(backpage);\r\nif (monitor) {\r\nfscache_put_retrieval(monitor->op);\r\nkfree(monitor);\r\n}\r\n_leave(" = %d", ret);\r\nreturn ret;\r\nread_error:\r\n_debug("read error %d", ret);\r\nif (ret == -ENOMEM) {\r\nfscache_retrieval_complete(op, 1);\r\ngoto out;\r\n}\r\nio_error:\r\ncachefiles_io_error_obj(object, "Page read error on backing file");\r\nfscache_retrieval_complete(op, 1);\r\nret = -ENOBUFS;\r\ngoto out;\r\nnomem_page:\r\npage_cache_release(newpage);\r\nnomem_monitor:\r\nfscache_put_retrieval(monitor->op);\r\nkfree(monitor);\r\nnomem:\r\nfscache_retrieval_complete(op, 1);\r\n_leave(" = -ENOMEM");\r\nreturn -ENOMEM;\r\n}\r\nint cachefiles_read_or_alloc_page(struct fscache_retrieval *op,\r\nstruct page *page,\r\ngfp_t gfp)\r\n{\r\nstruct cachefiles_object *object;\r\nstruct cachefiles_cache *cache;\r\nstruct pagevec pagevec;\r\nstruct inode *inode;\r\nsector_t block0, block;\r\nunsigned shift;\r\nint ret;\r\nobject = container_of(op->op.object,\r\nstruct cachefiles_object, fscache);\r\ncache = container_of(object->fscache.cache,\r\nstruct cachefiles_cache, cache);\r\n_enter("{%p},{%lx},,,", object, page->index);\r\nif (!object->backer)\r\ngoto enobufs;\r\ninode = object->backer->d_inode;\r\nASSERT(S_ISREG(inode->i_mode));\r\nASSERT(inode->i_mapping->a_ops->bmap);\r\nASSERT(inode->i_mapping->a_ops->readpages);\r\nif (inode->i_sb->s_blocksize > PAGE_SIZE)\r\ngoto enobufs;\r\nshift = PAGE_SHIFT - inode->i_sb->s_blocksize_bits;\r\nop->op.flags &= FSCACHE_OP_KEEP_FLAGS;\r\nop->op.flags |= FSCACHE_OP_ASYNC;\r\nop->op.processor = cachefiles_read_copier;\r\npagevec_init(&pagevec, 0);\r\nblock0 = page->index;\r\nblock0 <<= shift;\r\nblock = inode->i_mapping->a_ops->bmap(inode->i_mapping, block0);\r\n_debug("%llx -> %llx",\r\n(unsigned long long) block0,\r\n(unsigned long long) block);\r\nif (block) {\r\nret = cachefiles_read_backing_file_one(object, op, page,\r\n&pagevec);\r\n} else if (cachefiles_has_space(cache, 0, 1) == 0) {\r\nfscache_mark_page_cached(op, page);\r\nfscache_retrieval_complete(op, 1);\r\nret = -ENODATA;\r\n} else {\r\ngoto enobufs;\r\n}\r\n_leave(" = %d", ret);\r\nreturn ret;\r\nenobufs:\r\nfscache_retrieval_complete(op, 1);\r\n_leave(" = -ENOBUFS");\r\nreturn -ENOBUFS;\r\n}\r\nstatic int cachefiles_read_backing_file(struct cachefiles_object *object,\r\nstruct fscache_retrieval *op,\r\nstruct list_head *list)\r\n{\r\nstruct cachefiles_one_read *monitor = NULL;\r\nstruct address_space *bmapping = object->backer->d_inode->i_mapping;\r\nstruct pagevec lru_pvec;\r\nstruct page *newpage = NULL, *netpage, *_n, *backpage = NULL;\r\nint ret = 0;\r\n_enter("");\r\npagevec_init(&lru_pvec, 0);\r\nlist_for_each_entry_safe(netpage, _n, list, lru) {\r\nlist_del(&netpage->lru);\r\n_debug("read back %p{%lu,%d}",\r\nnetpage, netpage->index, page_count(netpage));\r\nif (!monitor) {\r\nmonitor = kzalloc(sizeof(*monitor), cachefiles_gfp);\r\nif (!monitor)\r\ngoto nomem;\r\nmonitor->op = fscache_get_retrieval(op);\r\ninit_waitqueue_func_entry(&monitor->monitor,\r\ncachefiles_read_waiter);\r\n}\r\nfor (;;) {\r\nbackpage = find_get_page(bmapping, netpage->index);\r\nif (backpage)\r\ngoto backing_page_already_present;\r\nif (!newpage) {\r\nnewpage = __page_cache_alloc(cachefiles_gfp |\r\n__GFP_COLD);\r\nif (!newpage)\r\ngoto nomem;\r\n}\r\nret = add_to_page_cache(newpage, bmapping,\r\nnetpage->index, cachefiles_gfp);\r\nif (ret == 0)\r\ngoto installed_new_backing_page;\r\nif (ret != -EEXIST)\r\ngoto nomem;\r\n}\r\ninstalled_new_backing_page:\r\n_debug("- new %p", newpage);\r\nbackpage = newpage;\r\nnewpage = NULL;\r\npage_cache_get(backpage);\r\nif (!pagevec_add(&lru_pvec, backpage))\r\n__pagevec_lru_add_file(&lru_pvec);\r\nreread_backing_page:\r\nret = bmapping->a_ops->readpage(NULL, backpage);\r\nif (ret < 0)\r\ngoto read_error;\r\nmonitor_backing_page:\r\n_debug("- monitor add");\r\nret = add_to_page_cache(netpage, op->mapping, netpage->index,\r\ncachefiles_gfp);\r\nif (ret < 0) {\r\nif (ret == -EEXIST) {\r\npage_cache_release(netpage);\r\nfscache_retrieval_complete(op, 1);\r\ncontinue;\r\n}\r\ngoto nomem;\r\n}\r\npage_cache_get(netpage);\r\nif (!pagevec_add(&lru_pvec, netpage))\r\n__pagevec_lru_add_file(&lru_pvec);\r\npage_cache_get(netpage);\r\nmonitor->netfs_page = netpage;\r\npage_cache_get(backpage);\r\nmonitor->back_page = backpage;\r\nmonitor->monitor.private = backpage;\r\nadd_page_wait_queue(backpage, &monitor->monitor);\r\nmonitor = NULL;\r\nif (trylock_page(backpage)) {\r\n_debug("2unlock %p {%lx}", backpage, backpage->flags);\r\nunlock_page(backpage);\r\n}\r\npage_cache_release(backpage);\r\nbackpage = NULL;\r\npage_cache_release(netpage);\r\nnetpage = NULL;\r\ncontinue;\r\nbacking_page_already_present:\r\n_debug("- present %p", backpage);\r\nif (PageError(backpage))\r\ngoto io_error;\r\nif (PageUptodate(backpage))\r\ngoto backing_page_already_uptodate;\r\n_debug("- not ready %p{%lx}", backpage, backpage->flags);\r\nif (!trylock_page(backpage))\r\ngoto monitor_backing_page;\r\nif (PageError(backpage)) {\r\n_debug("error %lx", backpage->flags);\r\nunlock_page(backpage);\r\ngoto io_error;\r\n}\r\nif (PageUptodate(backpage))\r\ngoto backing_page_already_uptodate_unlock;\r\ngoto reread_backing_page;\r\nbacking_page_already_uptodate_unlock:\r\n_debug("uptodate %lx", backpage->flags);\r\nunlock_page(backpage);\r\nbacking_page_already_uptodate:\r\n_debug("- uptodate");\r\nret = add_to_page_cache(netpage, op->mapping, netpage->index,\r\ncachefiles_gfp);\r\nif (ret < 0) {\r\nif (ret == -EEXIST) {\r\npage_cache_release(netpage);\r\nfscache_retrieval_complete(op, 1);\r\ncontinue;\r\n}\r\ngoto nomem;\r\n}\r\ncopy_highpage(netpage, backpage);\r\npage_cache_release(backpage);\r\nbackpage = NULL;\r\nfscache_mark_page_cached(op, netpage);\r\npage_cache_get(netpage);\r\nif (!pagevec_add(&lru_pvec, netpage))\r\n__pagevec_lru_add_file(&lru_pvec);\r\nfscache_end_io(op, netpage, 0);\r\npage_cache_release(netpage);\r\nnetpage = NULL;\r\nfscache_retrieval_complete(op, 1);\r\ncontinue;\r\n}\r\nnetpage = NULL;\r\n_debug("out");\r\nout:\r\npagevec_lru_add_file(&lru_pvec);\r\nif (newpage)\r\npage_cache_release(newpage);\r\nif (netpage)\r\npage_cache_release(netpage);\r\nif (backpage)\r\npage_cache_release(backpage);\r\nif (monitor) {\r\nfscache_put_retrieval(op);\r\nkfree(monitor);\r\n}\r\nlist_for_each_entry_safe(netpage, _n, list, lru) {\r\nlist_del(&netpage->lru);\r\npage_cache_release(netpage);\r\nfscache_retrieval_complete(op, 1);\r\n}\r\n_leave(" = %d", ret);\r\nreturn ret;\r\nnomem:\r\n_debug("nomem");\r\nret = -ENOMEM;\r\ngoto record_page_complete;\r\nread_error:\r\n_debug("read error %d", ret);\r\nif (ret == -ENOMEM)\r\ngoto record_page_complete;\r\nio_error:\r\ncachefiles_io_error_obj(object, "Page read error on backing file");\r\nret = -ENOBUFS;\r\nrecord_page_complete:\r\nfscache_retrieval_complete(op, 1);\r\ngoto out;\r\n}\r\nint cachefiles_read_or_alloc_pages(struct fscache_retrieval *op,\r\nstruct list_head *pages,\r\nunsigned *nr_pages,\r\ngfp_t gfp)\r\n{\r\nstruct cachefiles_object *object;\r\nstruct cachefiles_cache *cache;\r\nstruct list_head backpages;\r\nstruct pagevec pagevec;\r\nstruct inode *inode;\r\nstruct page *page, *_n;\r\nunsigned shift, nrbackpages;\r\nint ret, ret2, space;\r\nobject = container_of(op->op.object,\r\nstruct cachefiles_object, fscache);\r\ncache = container_of(object->fscache.cache,\r\nstruct cachefiles_cache, cache);\r\n_enter("{OBJ%x,%d},,%d,,",\r\nobject->fscache.debug_id, atomic_read(&op->op.usage),\r\n*nr_pages);\r\nif (!object->backer)\r\ngoto all_enobufs;\r\nspace = 1;\r\nif (cachefiles_has_space(cache, 0, *nr_pages) < 0)\r\nspace = 0;\r\ninode = object->backer->d_inode;\r\nASSERT(S_ISREG(inode->i_mode));\r\nASSERT(inode->i_mapping->a_ops->bmap);\r\nASSERT(inode->i_mapping->a_ops->readpages);\r\nif (inode->i_sb->s_blocksize > PAGE_SIZE)\r\ngoto all_enobufs;\r\nshift = PAGE_SHIFT - inode->i_sb->s_blocksize_bits;\r\npagevec_init(&pagevec, 0);\r\nop->op.flags &= FSCACHE_OP_KEEP_FLAGS;\r\nop->op.flags |= FSCACHE_OP_ASYNC;\r\nop->op.processor = cachefiles_read_copier;\r\nINIT_LIST_HEAD(&backpages);\r\nnrbackpages = 0;\r\nret = space ? -ENODATA : -ENOBUFS;\r\nlist_for_each_entry_safe(page, _n, pages, lru) {\r\nsector_t block0, block;\r\nblock0 = page->index;\r\nblock0 <<= shift;\r\nblock = inode->i_mapping->a_ops->bmap(inode->i_mapping,\r\nblock0);\r\n_debug("%llx -> %llx",\r\n(unsigned long long) block0,\r\n(unsigned long long) block);\r\nif (block) {\r\nlist_move(&page->lru, &backpages);\r\n(*nr_pages)--;\r\nnrbackpages++;\r\n} else if (space && pagevec_add(&pagevec, page) == 0) {\r\nfscache_mark_pages_cached(op, &pagevec);\r\nfscache_retrieval_complete(op, 1);\r\nret = -ENODATA;\r\n} else {\r\nfscache_retrieval_complete(op, 1);\r\n}\r\n}\r\nif (pagevec_count(&pagevec) > 0)\r\nfscache_mark_pages_cached(op, &pagevec);\r\nif (list_empty(pages))\r\nret = 0;\r\nif (nrbackpages > 0) {\r\nret2 = cachefiles_read_backing_file(object, op, &backpages);\r\nif (ret2 == -ENOMEM || ret2 == -EINTR)\r\nret = ret2;\r\n}\r\n_leave(" = %d [nr=%u%s]",\r\nret, *nr_pages, list_empty(pages) ? " empty" : "");\r\nreturn ret;\r\nall_enobufs:\r\nfscache_retrieval_complete(op, *nr_pages);\r\nreturn -ENOBUFS;\r\n}\r\nint cachefiles_allocate_page(struct fscache_retrieval *op,\r\nstruct page *page,\r\ngfp_t gfp)\r\n{\r\nstruct cachefiles_object *object;\r\nstruct cachefiles_cache *cache;\r\nint ret;\r\nobject = container_of(op->op.object,\r\nstruct cachefiles_object, fscache);\r\ncache = container_of(object->fscache.cache,\r\nstruct cachefiles_cache, cache);\r\n_enter("%p,{%lx},", object, page->index);\r\nret = cachefiles_has_space(cache, 0, 1);\r\nif (ret == 0)\r\nfscache_mark_page_cached(op, page);\r\nelse\r\nret = -ENOBUFS;\r\nfscache_retrieval_complete(op, 1);\r\n_leave(" = %d", ret);\r\nreturn ret;\r\n}\r\nint cachefiles_allocate_pages(struct fscache_retrieval *op,\r\nstruct list_head *pages,\r\nunsigned *nr_pages,\r\ngfp_t gfp)\r\n{\r\nstruct cachefiles_object *object;\r\nstruct cachefiles_cache *cache;\r\nstruct pagevec pagevec;\r\nstruct page *page;\r\nint ret;\r\nobject = container_of(op->op.object,\r\nstruct cachefiles_object, fscache);\r\ncache = container_of(object->fscache.cache,\r\nstruct cachefiles_cache, cache);\r\n_enter("%p,,,%d,", object, *nr_pages);\r\nret = cachefiles_has_space(cache, 0, *nr_pages);\r\nif (ret == 0) {\r\npagevec_init(&pagevec, 0);\r\nlist_for_each_entry(page, pages, lru) {\r\nif (pagevec_add(&pagevec, page) == 0)\r\nfscache_mark_pages_cached(op, &pagevec);\r\n}\r\nif (pagevec_count(&pagevec) > 0)\r\nfscache_mark_pages_cached(op, &pagevec);\r\nret = -ENODATA;\r\n} else {\r\nret = -ENOBUFS;\r\n}\r\nfscache_retrieval_complete(op, *nr_pages);\r\n_leave(" = %d", ret);\r\nreturn ret;\r\n}\r\nint cachefiles_write_page(struct fscache_storage *op, struct page *page)\r\n{\r\nstruct cachefiles_object *object;\r\nstruct cachefiles_cache *cache;\r\nmm_segment_t old_fs;\r\nstruct file *file;\r\nstruct path path;\r\nloff_t pos, eof;\r\nsize_t len;\r\nvoid *data;\r\nint ret;\r\nASSERT(op != NULL);\r\nASSERT(page != NULL);\r\nobject = container_of(op->op.object,\r\nstruct cachefiles_object, fscache);\r\n_enter("%p,%p{%lx},,,", object, page, page->index);\r\nif (!object->backer) {\r\n_leave(" = -ENOBUFS");\r\nreturn -ENOBUFS;\r\n}\r\nASSERT(S_ISREG(object->backer->d_inode->i_mode));\r\ncache = container_of(object->fscache.cache,\r\nstruct cachefiles_cache, cache);\r\npath.mnt = cache->mnt;\r\npath.dentry = object->backer;\r\nfile = dentry_open(&path, O_RDWR | O_LARGEFILE, cache->cache_cred);\r\nif (IS_ERR(file)) {\r\nret = PTR_ERR(file);\r\n} else {\r\nret = -EIO;\r\nif (file->f_op->write) {\r\npos = (loff_t) page->index << PAGE_SHIFT;\r\neof = object->fscache.store_limit_l;\r\nlen = PAGE_SIZE;\r\nif (eof & ~PAGE_MASK) {\r\nASSERTCMP(pos, <, eof);\r\nif (eof - pos < PAGE_SIZE) {\r\n_debug("cut short %llx to %llx",\r\npos, eof);\r\nlen = eof - pos;\r\nASSERTCMP(pos + len, ==, eof);\r\n}\r\n}\r\ndata = kmap(page);\r\nold_fs = get_fs();\r\nset_fs(KERNEL_DS);\r\nret = file->f_op->write(\r\nfile, (const void __user *) data, len, &pos);\r\nset_fs(old_fs);\r\nkunmap(page);\r\nif (ret != len)\r\nret = -EIO;\r\n}\r\nfput(file);\r\n}\r\nif (ret < 0) {\r\nif (ret == -EIO)\r\ncachefiles_io_error_obj(\r\nobject, "Write page to backing file failed");\r\nret = -ENOBUFS;\r\n}\r\n_leave(" = %d", ret);\r\nreturn ret;\r\n}\r\nvoid cachefiles_uncache_page(struct fscache_object *_object, struct page *page)\r\n{\r\nstruct cachefiles_object *object;\r\nstruct cachefiles_cache *cache;\r\nobject = container_of(_object, struct cachefiles_object, fscache);\r\ncache = container_of(object->fscache.cache,\r\nstruct cachefiles_cache, cache);\r\n_enter("%p,{%lu}", object, page->index);\r\nspin_unlock(&object->fscache.cookie->lock);\r\n}
