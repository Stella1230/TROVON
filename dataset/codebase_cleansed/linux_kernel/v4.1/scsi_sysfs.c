const char *scsi_device_state_name(enum scsi_device_state state)\r\n{\r\nint i;\r\nchar *name = NULL;\r\nfor (i = 0; i < ARRAY_SIZE(sdev_states); i++) {\r\nif (sdev_states[i].value == state) {\r\nname = sdev_states[i].name;\r\nbreak;\r\n}\r\n}\r\nreturn name;\r\n}\r\nconst char *scsi_host_state_name(enum scsi_host_state state)\r\n{\r\nint i;\r\nchar *name = NULL;\r\nfor (i = 0; i < ARRAY_SIZE(shost_states); i++) {\r\nif (shost_states[i].value == state) {\r\nname = shost_states[i].name;\r\nbreak;\r\n}\r\n}\r\nreturn name;\r\n}\r\nstatic int check_set(unsigned long long *val, char *src)\r\n{\r\nchar *last;\r\nif (strncmp(src, "-", 20) == 0) {\r\n*val = SCAN_WILD_CARD;\r\n} else {\r\n*val = simple_strtoull(src, &last, 0);\r\nif (*last != '\0')\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int scsi_scan(struct Scsi_Host *shost, const char *str)\r\n{\r\nchar s1[15], s2[15], s3[17], junk;\r\nunsigned long long channel, id, lun;\r\nint res;\r\nres = sscanf(str, "%10s %10s %16s %c", s1, s2, s3, &junk);\r\nif (res != 3)\r\nreturn -EINVAL;\r\nif (check_set(&channel, s1))\r\nreturn -EINVAL;\r\nif (check_set(&id, s2))\r\nreturn -EINVAL;\r\nif (check_set(&lun, s3))\r\nreturn -EINVAL;\r\nif (shost->transportt->user_scan)\r\nres = shost->transportt->user_scan(shost, channel, id, lun);\r\nelse\r\nres = scsi_scan_host_selected(shost, channel, id, lun, 1);\r\nreturn res;\r\n}\r\nstatic ssize_t\r\nstore_scan(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct Scsi_Host *shost = class_to_shost(dev);\r\nint res;\r\nres = scsi_scan(shost, buf);\r\nif (res == 0)\r\nres = count;\r\nreturn res;\r\n}\r\nstatic ssize_t\r\nstore_shost_state(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nint i;\r\nstruct Scsi_Host *shost = class_to_shost(dev);\r\nenum scsi_host_state state = 0;\r\nfor (i = 0; i < ARRAY_SIZE(shost_states); i++) {\r\nconst int len = strlen(shost_states[i].name);\r\nif (strncmp(shost_states[i].name, buf, len) == 0 &&\r\nbuf[len] == '\n') {\r\nstate = shost_states[i].value;\r\nbreak;\r\n}\r\n}\r\nif (!state)\r\nreturn -EINVAL;\r\nif (scsi_host_set_state(shost, state))\r\nreturn -EINVAL;\r\nreturn count;\r\n}\r\nstatic ssize_t\r\nshow_shost_state(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct Scsi_Host *shost = class_to_shost(dev);\r\nconst char *name = scsi_host_state_name(shost->shost_state);\r\nif (!name)\r\nreturn -EINVAL;\r\nreturn snprintf(buf, 20, "%s\n", name);\r\n}\r\nstatic ssize_t\r\nshow_shost_mode(unsigned int mode, char *buf)\r\n{\r\nssize_t len = 0;\r\nif (mode & MODE_INITIATOR)\r\nlen = sprintf(buf, "%s", "Initiator");\r\nif (mode & MODE_TARGET)\r\nlen += sprintf(buf + len, "%s%s", len ? ", " : "", "Target");\r\nlen += sprintf(buf + len, "\n");\r\nreturn len;\r\n}\r\nstatic ssize_t\r\nshow_shost_supported_mode(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct Scsi_Host *shost = class_to_shost(dev);\r\nunsigned int supported_mode = shost->hostt->supported_mode;\r\nif (supported_mode == MODE_UNKNOWN)\r\nsupported_mode = MODE_INITIATOR;\r\nreturn show_shost_mode(supported_mode, buf);\r\n}\r\nstatic ssize_t\r\nshow_shost_active_mode(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct Scsi_Host *shost = class_to_shost(dev);\r\nif (shost->active_mode == MODE_UNKNOWN)\r\nreturn snprintf(buf, 20, "unknown\n");\r\nelse\r\nreturn show_shost_mode(shost->active_mode, buf);\r\n}\r\nstatic int check_reset_type(const char *str)\r\n{\r\nif (sysfs_streq(str, "adapter"))\r\nreturn SCSI_ADAPTER_RESET;\r\nelse if (sysfs_streq(str, "firmware"))\r\nreturn SCSI_FIRMWARE_RESET;\r\nelse\r\nreturn 0;\r\n}\r\nstatic ssize_t\r\nstore_host_reset(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct Scsi_Host *shost = class_to_shost(dev);\r\nstruct scsi_host_template *sht = shost->hostt;\r\nint ret = -EINVAL;\r\nint type;\r\ntype = check_reset_type(buf);\r\nif (!type)\r\ngoto exit_store_host_reset;\r\nif (sht->host_reset)\r\nret = sht->host_reset(shost, type);\r\nexit_store_host_reset:\r\nif (ret == 0)\r\nret = count;\r\nreturn ret;\r\n}\r\nstatic ssize_t\r\nshow_shost_eh_deadline(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct Scsi_Host *shost = class_to_shost(dev);\r\nif (shost->eh_deadline == -1)\r\nreturn snprintf(buf, strlen("off") + 2, "off\n");\r\nreturn sprintf(buf, "%u\n", shost->eh_deadline / HZ);\r\n}\r\nstatic ssize_t\r\nstore_shost_eh_deadline(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct Scsi_Host *shost = class_to_shost(dev);\r\nint ret = -EINVAL;\r\nunsigned long deadline, flags;\r\nif (shost->transportt &&\r\n(shost->transportt->eh_strategy_handler ||\r\n!shost->hostt->eh_host_reset_handler))\r\nreturn ret;\r\nif (!strncmp(buf, "off", strlen("off")))\r\ndeadline = -1;\r\nelse {\r\nret = kstrtoul(buf, 10, &deadline);\r\nif (ret)\r\nreturn ret;\r\nif (deadline * HZ > UINT_MAX)\r\nreturn -EINVAL;\r\n}\r\nspin_lock_irqsave(shost->host_lock, flags);\r\nif (scsi_host_in_recovery(shost))\r\nret = -EBUSY;\r\nelse {\r\nif (deadline == -1)\r\nshost->eh_deadline = -1;\r\nelse\r\nshost->eh_deadline = deadline * HZ;\r\nret = count;\r\n}\r\nspin_unlock_irqrestore(shost->host_lock, flags);\r\nreturn ret;\r\n}\r\nstatic ssize_t\r\nshow_host_busy(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct Scsi_Host *shost = class_to_shost(dev);\r\nreturn snprintf(buf, 20, "%d\n", atomic_read(&shost->host_busy));\r\n}\r\nstatic void scsi_device_cls_release(struct device *class_dev)\r\n{\r\nstruct scsi_device *sdev;\r\nsdev = class_to_sdev(class_dev);\r\nput_device(&sdev->sdev_gendev);\r\n}\r\nstatic void scsi_device_dev_release_usercontext(struct work_struct *work)\r\n{\r\nstruct scsi_device *sdev;\r\nstruct device *parent;\r\nstruct list_head *this, *tmp;\r\nunsigned long flags;\r\nsdev = container_of(work, struct scsi_device, ew.work);\r\nparent = sdev->sdev_gendev.parent;\r\nspin_lock_irqsave(sdev->host->host_lock, flags);\r\nlist_del(&sdev->siblings);\r\nlist_del(&sdev->same_target_siblings);\r\nlist_del(&sdev->starved_entry);\r\nspin_unlock_irqrestore(sdev->host->host_lock, flags);\r\ncancel_work_sync(&sdev->event_work);\r\nlist_for_each_safe(this, tmp, &sdev->event_list) {\r\nstruct scsi_event *evt;\r\nevt = list_entry(this, struct scsi_event, node);\r\nlist_del(&evt->node);\r\nkfree(evt);\r\n}\r\nblk_put_queue(sdev->request_queue);\r\nsdev->request_queue = NULL;\r\nkfree(sdev->vpd_pg83);\r\nkfree(sdev->vpd_pg80);\r\nkfree(sdev->inquiry);\r\nkfree(sdev);\r\nif (parent)\r\nput_device(parent);\r\n}\r\nstatic void scsi_device_dev_release(struct device *dev)\r\n{\r\nstruct scsi_device *sdp = to_scsi_device(dev);\r\nexecute_in_process_context(scsi_device_dev_release_usercontext,\r\n&sdp->ew);\r\n}\r\nstatic int scsi_bus_match(struct device *dev, struct device_driver *gendrv)\r\n{\r\nstruct scsi_device *sdp;\r\nif (dev->type != &scsi_dev_type)\r\nreturn 0;\r\nsdp = to_scsi_device(dev);\r\nif (sdp->no_uld_attach)\r\nreturn 0;\r\nreturn (sdp->inq_periph_qual == SCSI_INQ_PQ_CON)? 1: 0;\r\n}\r\nstatic int scsi_bus_uevent(struct device *dev, struct kobj_uevent_env *env)\r\n{\r\nstruct scsi_device *sdev;\r\nif (dev->type != &scsi_dev_type)\r\nreturn 0;\r\nsdev = to_scsi_device(dev);\r\nadd_uevent_var(env, "MODALIAS=" SCSI_DEVICE_MODALIAS_FMT, sdev->type);\r\nreturn 0;\r\n}\r\nint scsi_sysfs_register(void)\r\n{\r\nint error;\r\nerror = bus_register(&scsi_bus_type);\r\nif (!error) {\r\nerror = class_register(&sdev_class);\r\nif (error)\r\nbus_unregister(&scsi_bus_type);\r\n}\r\nreturn error;\r\n}\r\nvoid scsi_sysfs_unregister(void)\r\n{\r\nclass_unregister(&sdev_class);\r\nbus_unregister(&scsi_bus_type);\r\n}\r\nstatic ssize_t\r\nsdev_show_device_busy(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct scsi_device *sdev = to_scsi_device(dev);\r\nreturn snprintf(buf, 20, "%d\n", atomic_read(&sdev->device_busy));\r\n}\r\nstatic ssize_t\r\nsdev_show_device_blocked(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct scsi_device *sdev = to_scsi_device(dev);\r\nreturn snprintf(buf, 20, "%d\n", atomic_read(&sdev->device_blocked));\r\n}\r\nstatic ssize_t\r\nsdev_show_timeout (struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct scsi_device *sdev;\r\nsdev = to_scsi_device(dev);\r\nreturn snprintf(buf, 20, "%d\n", sdev->request_queue->rq_timeout / HZ);\r\n}\r\nstatic ssize_t\r\nsdev_store_timeout (struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct scsi_device *sdev;\r\nint timeout;\r\nsdev = to_scsi_device(dev);\r\nsscanf (buf, "%d\n", &timeout);\r\nblk_queue_rq_timeout(sdev->request_queue, timeout * HZ);\r\nreturn count;\r\n}\r\nstatic ssize_t\r\nsdev_show_eh_timeout(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct scsi_device *sdev;\r\nsdev = to_scsi_device(dev);\r\nreturn snprintf(buf, 20, "%u\n", sdev->eh_timeout / HZ);\r\n}\r\nstatic ssize_t\r\nsdev_store_eh_timeout(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct scsi_device *sdev;\r\nunsigned int eh_timeout;\r\nint err;\r\nif (!capable(CAP_SYS_ADMIN))\r\nreturn -EACCES;\r\nsdev = to_scsi_device(dev);\r\nerr = kstrtouint(buf, 10, &eh_timeout);\r\nif (err)\r\nreturn err;\r\nsdev->eh_timeout = eh_timeout * HZ;\r\nreturn count;\r\n}\r\nstatic ssize_t\r\nstore_rescan_field (struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nscsi_rescan_device(dev);\r\nreturn count;\r\n}\r\nstatic ssize_t\r\nsdev_store_delete(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nif (device_remove_file_self(dev, attr))\r\nscsi_remove_device(to_scsi_device(dev));\r\nreturn count;\r\n}\r\nstatic ssize_t\r\nstore_state_field(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nint i;\r\nstruct scsi_device *sdev = to_scsi_device(dev);\r\nenum scsi_device_state state = 0;\r\nfor (i = 0; i < ARRAY_SIZE(sdev_states); i++) {\r\nconst int len = strlen(sdev_states[i].name);\r\nif (strncmp(sdev_states[i].name, buf, len) == 0 &&\r\nbuf[len] == '\n') {\r\nstate = sdev_states[i].value;\r\nbreak;\r\n}\r\n}\r\nif (!state)\r\nreturn -EINVAL;\r\nif (scsi_device_set_state(sdev, state))\r\nreturn -EINVAL;\r\nreturn count;\r\n}\r\nstatic ssize_t\r\nshow_state_field(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct scsi_device *sdev = to_scsi_device(dev);\r\nconst char *name = scsi_device_state_name(sdev->sdev_state);\r\nif (!name)\r\nreturn -EINVAL;\r\nreturn snprintf(buf, 20, "%s\n", name);\r\n}\r\nstatic ssize_t\r\nshow_queue_type_field(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct scsi_device *sdev = to_scsi_device(dev);\r\nconst char *name = "none";\r\nif (sdev->simple_tags)\r\nname = "simple";\r\nreturn snprintf(buf, 20, "%s\n", name);\r\n}\r\nstatic ssize_t\r\nstore_queue_type_field(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct scsi_device *sdev = to_scsi_device(dev);\r\nif (!sdev->tagged_supported)\r\nreturn -EINVAL;\r\nsdev_printk(KERN_INFO, sdev,\r\n"ignoring write to deprecated queue_type attribute");\r\nreturn count;\r\n}\r\nstatic ssize_t\r\nshow_iostat_counterbits(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nreturn snprintf(buf, 20, "%d\n", (int)sizeof(atomic_t) * 8);\r\n}\r\nstatic ssize_t\r\nsdev_show_modalias(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct scsi_device *sdev;\r\nsdev = to_scsi_device(dev);\r\nreturn snprintf (buf, 20, SCSI_DEVICE_MODALIAS_FMT "\n", sdev->type);\r\n}\r\nstatic ssize_t\r\nsdev_store_queue_depth(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nint depth, retval;\r\nstruct scsi_device *sdev = to_scsi_device(dev);\r\nstruct scsi_host_template *sht = sdev->host->hostt;\r\nif (!sht->change_queue_depth)\r\nreturn -EINVAL;\r\ndepth = simple_strtoul(buf, NULL, 0);\r\nif (depth < 1 || depth > sht->can_queue)\r\nreturn -EINVAL;\r\nretval = sht->change_queue_depth(sdev, depth);\r\nif (retval < 0)\r\nreturn retval;\r\nsdev->max_queue_depth = sdev->queue_depth;\r\nreturn count;\r\n}\r\nstatic ssize_t\r\nsdev_show_queue_ramp_up_period(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct scsi_device *sdev;\r\nsdev = to_scsi_device(dev);\r\nreturn snprintf(buf, 20, "%u\n",\r\njiffies_to_msecs(sdev->queue_ramp_up_period));\r\n}\r\nstatic ssize_t\r\nsdev_store_queue_ramp_up_period(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct scsi_device *sdev = to_scsi_device(dev);\r\nunsigned int period;\r\nif (kstrtouint(buf, 10, &period))\r\nreturn -EINVAL;\r\nsdev->queue_ramp_up_period = msecs_to_jiffies(period);\r\nreturn period;\r\n}\r\nstatic umode_t scsi_sdev_attr_is_visible(struct kobject *kobj,\r\nstruct attribute *attr, int i)\r\n{\r\nstruct device *dev = container_of(kobj, struct device, kobj);\r\nstruct scsi_device *sdev = to_scsi_device(dev);\r\nif (attr == &dev_attr_queue_depth.attr &&\r\n!sdev->host->hostt->change_queue_depth)\r\nreturn S_IRUGO;\r\nif (attr == &dev_attr_queue_ramp_up_period.attr &&\r\n!sdev->host->hostt->change_queue_depth)\r\nreturn 0;\r\nreturn attr->mode;\r\n}\r\nstatic int scsi_target_add(struct scsi_target *starget)\r\n{\r\nint error;\r\nif (starget->state != STARGET_CREATED)\r\nreturn 0;\r\nerror = device_add(&starget->dev);\r\nif (error) {\r\ndev_err(&starget->dev, "target device_add failed, error %d\n", error);\r\nreturn error;\r\n}\r\ntransport_add_device(&starget->dev);\r\nstarget->state = STARGET_RUNNING;\r\npm_runtime_set_active(&starget->dev);\r\npm_runtime_enable(&starget->dev);\r\ndevice_enable_async_suspend(&starget->dev);\r\nreturn 0;\r\n}\r\nint scsi_sysfs_add_sdev(struct scsi_device *sdev)\r\n{\r\nint error, i;\r\nstruct request_queue *rq = sdev->request_queue;\r\nstruct scsi_target *starget = sdev->sdev_target;\r\nerror = scsi_device_set_state(sdev, SDEV_RUNNING);\r\nif (error)\r\nreturn error;\r\nerror = scsi_target_add(starget);\r\nif (error)\r\nreturn error;\r\ntransport_configure_device(&starget->dev);\r\ndevice_enable_async_suspend(&sdev->sdev_gendev);\r\nscsi_autopm_get_target(starget);\r\npm_runtime_set_active(&sdev->sdev_gendev);\r\npm_runtime_forbid(&sdev->sdev_gendev);\r\npm_runtime_enable(&sdev->sdev_gendev);\r\nscsi_autopm_put_target(starget);\r\nscsi_autopm_get_device(sdev);\r\nerror = device_add(&sdev->sdev_gendev);\r\nif (error) {\r\nsdev_printk(KERN_INFO, sdev,\r\n"failed to add device: %d\n", error);\r\nreturn error;\r\n}\r\ndevice_enable_async_suspend(&sdev->sdev_dev);\r\nerror = device_add(&sdev->sdev_dev);\r\nif (error) {\r\nsdev_printk(KERN_INFO, sdev,\r\n"failed to add class device: %d\n", error);\r\ndevice_del(&sdev->sdev_gendev);\r\nreturn error;\r\n}\r\ntransport_add_device(&sdev->sdev_gendev);\r\nsdev->is_visible = 1;\r\nerror = bsg_register_queue(rq, &sdev->sdev_gendev, NULL, NULL);\r\nif (error)\r\nsdev_printk(KERN_INFO, sdev,\r\n"Failed to register bsg queue, errno=%d\n", error);\r\nif (sdev->host->hostt->sdev_attrs) {\r\nfor (i = 0; sdev->host->hostt->sdev_attrs[i]; i++) {\r\nerror = device_create_file(&sdev->sdev_gendev,\r\nsdev->host->hostt->sdev_attrs[i]);\r\nif (error)\r\nreturn error;\r\n}\r\n}\r\nscsi_autopm_put_device(sdev);\r\nreturn error;\r\n}\r\nvoid __scsi_remove_device(struct scsi_device *sdev)\r\n{\r\nstruct device *dev = &sdev->sdev_gendev;\r\nif (sdev->is_visible) {\r\nif (scsi_device_set_state(sdev, SDEV_CANCEL) != 0)\r\nreturn;\r\nbsg_unregister_queue(sdev->request_queue);\r\ndevice_unregister(&sdev->sdev_dev);\r\ntransport_remove_device(dev);\r\ndevice_del(dev);\r\n} else\r\nput_device(&sdev->sdev_dev);\r\nscsi_device_set_state(sdev, SDEV_DEL);\r\nblk_cleanup_queue(sdev->request_queue);\r\ncancel_work_sync(&sdev->requeue_work);\r\nif (sdev->host->hostt->slave_destroy)\r\nsdev->host->hostt->slave_destroy(sdev);\r\ntransport_destroy_device(dev);\r\nscsi_target_reap(scsi_target(sdev));\r\nput_device(dev);\r\n}\r\nvoid scsi_remove_device(struct scsi_device *sdev)\r\n{\r\nstruct Scsi_Host *shost = sdev->host;\r\nmutex_lock(&shost->scan_mutex);\r\n__scsi_remove_device(sdev);\r\nmutex_unlock(&shost->scan_mutex);\r\n}\r\nstatic void __scsi_remove_target(struct scsi_target *starget)\r\n{\r\nstruct Scsi_Host *shost = dev_to_shost(starget->dev.parent);\r\nunsigned long flags;\r\nstruct scsi_device *sdev;\r\nspin_lock_irqsave(shost->host_lock, flags);\r\nrestart:\r\nlist_for_each_entry(sdev, &shost->__devices, siblings) {\r\nif (sdev->channel != starget->channel ||\r\nsdev->id != starget->id ||\r\nscsi_device_get(sdev))\r\ncontinue;\r\nspin_unlock_irqrestore(shost->host_lock, flags);\r\nscsi_remove_device(sdev);\r\nscsi_device_put(sdev);\r\nspin_lock_irqsave(shost->host_lock, flags);\r\ngoto restart;\r\n}\r\nspin_unlock_irqrestore(shost->host_lock, flags);\r\n}\r\nvoid scsi_remove_target(struct device *dev)\r\n{\r\nstruct Scsi_Host *shost = dev_to_shost(dev->parent);\r\nstruct scsi_target *starget, *last = NULL;\r\nunsigned long flags;\r\nspin_lock_irqsave(shost->host_lock, flags);\r\nlist_for_each_entry(starget, &shost->__targets, siblings) {\r\nif (starget->state == STARGET_DEL)\r\ncontinue;\r\nif (starget->dev.parent == dev || &starget->dev == dev) {\r\nkref_get(&starget->reap_ref);\r\nspin_unlock_irqrestore(shost->host_lock, flags);\r\nif (last)\r\nscsi_target_reap(last);\r\nlast = starget;\r\n__scsi_remove_target(starget);\r\nspin_lock_irqsave(shost->host_lock, flags);\r\n}\r\n}\r\nspin_unlock_irqrestore(shost->host_lock, flags);\r\nif (last)\r\nscsi_target_reap(last);\r\n}\r\nint scsi_register_driver(struct device_driver *drv)\r\n{\r\ndrv->bus = &scsi_bus_type;\r\nreturn driver_register(drv);\r\n}\r\nint scsi_register_interface(struct class_interface *intf)\r\n{\r\nintf->class = &sdev_class;\r\nreturn class_interface_register(intf);\r\n}\r\nint scsi_sysfs_add_host(struct Scsi_Host *shost)\r\n{\r\nint error, i;\r\nif (shost->hostt->shost_attrs) {\r\nfor (i = 0; shost->hostt->shost_attrs[i]; i++) {\r\nerror = device_create_file(&shost->shost_dev,\r\nshost->hostt->shost_attrs[i]);\r\nif (error)\r\nreturn error;\r\n}\r\n}\r\ntransport_register_device(&shost->shost_gendev);\r\ntransport_configure_device(&shost->shost_gendev);\r\nreturn 0;\r\n}\r\nvoid scsi_sysfs_device_initialize(struct scsi_device *sdev)\r\n{\r\nunsigned long flags;\r\nstruct Scsi_Host *shost = sdev->host;\r\nstruct scsi_target *starget = sdev->sdev_target;\r\ndevice_initialize(&sdev->sdev_gendev);\r\nsdev->sdev_gendev.bus = &scsi_bus_type;\r\nsdev->sdev_gendev.type = &scsi_dev_type;\r\ndev_set_name(&sdev->sdev_gendev, "%d:%d:%d:%llu",\r\nsdev->host->host_no, sdev->channel, sdev->id, sdev->lun);\r\ndevice_initialize(&sdev->sdev_dev);\r\nsdev->sdev_dev.parent = get_device(&sdev->sdev_gendev);\r\nsdev->sdev_dev.class = &sdev_class;\r\ndev_set_name(&sdev->sdev_dev, "%d:%d:%d:%llu",\r\nsdev->host->host_no, sdev->channel, sdev->id, sdev->lun);\r\nsdev->scsi_level = starget->scsi_level;\r\nif (sdev->scsi_level <= SCSI_2 &&\r\nsdev->scsi_level != SCSI_UNKNOWN &&\r\n!shost->no_scsi2_lun_in_cdb)\r\nsdev->lun_in_cdb = 1;\r\ntransport_setup_device(&sdev->sdev_gendev);\r\nspin_lock_irqsave(shost->host_lock, flags);\r\nlist_add_tail(&sdev->same_target_siblings, &starget->devices);\r\nlist_add_tail(&sdev->siblings, &shost->__devices);\r\nspin_unlock_irqrestore(shost->host_lock, flags);\r\nkref_get(&starget->reap_ref);\r\n}\r\nint scsi_is_sdev_device(const struct device *dev)\r\n{\r\nreturn dev->type == &scsi_dev_type;\r\n}
