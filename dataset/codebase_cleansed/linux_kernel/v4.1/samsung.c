static inline int s3c_read_reg(int offset)\r\n{\r\nreturn readl(onenand->base + offset);\r\n}\r\nstatic inline void s3c_write_reg(int value, int offset)\r\n{\r\nwritel(value, onenand->base + offset);\r\n}\r\nstatic inline int s3c_read_cmd(unsigned int cmd)\r\n{\r\nreturn readl(onenand->ahb_addr + cmd);\r\n}\r\nstatic inline void s3c_write_cmd(int value, unsigned int cmd)\r\n{\r\nwritel(value, onenand->ahb_addr + cmd);\r\n}\r\nstatic void s3c_dump_reg(void)\r\n{\r\nint i;\r\nfor (i = 0; i < 0x400; i += 0x40) {\r\nprintk(KERN_INFO "0x%08X: 0x%08x 0x%08x 0x%08x 0x%08x\n",\r\n(unsigned int) onenand->base + i,\r\ns3c_read_reg(i), s3c_read_reg(i + 0x10),\r\ns3c_read_reg(i + 0x20), s3c_read_reg(i + 0x30));\r\n}\r\n}\r\nstatic unsigned int s3c64xx_cmd_map(unsigned type, unsigned val)\r\n{\r\nreturn (type << S3C64XX_CMD_MAP_SHIFT) | val;\r\n}\r\nstatic unsigned int s3c6400_mem_addr(int fba, int fpa, int fsa)\r\n{\r\nreturn (fba << S3C6400_FBA_SHIFT) | (fpa << S3C6400_FPA_SHIFT) |\r\n(fsa << S3C6400_FSA_SHIFT);\r\n}\r\nstatic unsigned int s3c6410_mem_addr(int fba, int fpa, int fsa)\r\n{\r\nreturn (fba << S3C6410_FBA_SHIFT) | (fpa << S3C6410_FPA_SHIFT) |\r\n(fsa << S3C6410_FSA_SHIFT);\r\n}\r\nstatic void s3c_onenand_reset(void)\r\n{\r\nunsigned long timeout = 0x10000;\r\nint stat;\r\ns3c_write_reg(ONENAND_MEM_RESET_COLD, MEM_RESET_OFFSET);\r\nwhile (1 && timeout--) {\r\nstat = s3c_read_reg(INT_ERR_STAT_OFFSET);\r\nif (stat & RST_CMP)\r\nbreak;\r\n}\r\nstat = s3c_read_reg(INT_ERR_STAT_OFFSET);\r\ns3c_write_reg(stat, INT_ERR_ACK_OFFSET);\r\ns3c_write_reg(0x0, INT_ERR_ACK_OFFSET);\r\ns3c_write_reg(0x0, ECC_ERR_STAT_OFFSET);\r\n}\r\nstatic unsigned short s3c_onenand_readw(void __iomem *addr)\r\n{\r\nstruct onenand_chip *this = onenand->mtd->priv;\r\nstruct device *dev = &onenand->pdev->dev;\r\nint reg = addr - this->base;\r\nint word_addr = reg >> 1;\r\nint value;\r\nswitch (reg) {\r\ncase ONENAND_REG_MANUFACTURER_ID:\r\nreturn s3c_read_reg(MANUFACT_ID_OFFSET);\r\ncase ONENAND_REG_DEVICE_ID:\r\nreturn s3c_read_reg(DEVICE_ID_OFFSET);\r\ncase ONENAND_REG_VERSION_ID:\r\nreturn s3c_read_reg(FLASH_VER_ID_OFFSET);\r\ncase ONENAND_REG_DATA_BUFFER_SIZE:\r\nreturn s3c_read_reg(DATA_BUF_SIZE_OFFSET);\r\ncase ONENAND_REG_TECHNOLOGY:\r\nreturn s3c_read_reg(TECH_OFFSET);\r\ncase ONENAND_REG_SYS_CFG1:\r\nreturn s3c_read_reg(MEM_CFG_OFFSET);\r\ncase ONENAND_REG_CTRL_STATUS:\r\nreturn 0;\r\ncase ONENAND_REG_WP_STATUS:\r\nreturn ONENAND_WP_US;\r\ndefault:\r\nbreak;\r\n}\r\nif ((unsigned int) addr < ONENAND_DATARAM && onenand->bootram_command) {\r\nif (word_addr == 0)\r\nreturn s3c_read_reg(MANUFACT_ID_OFFSET);\r\nif (word_addr == 1)\r\nreturn s3c_read_reg(DEVICE_ID_OFFSET);\r\nif (word_addr == 2)\r\nreturn s3c_read_reg(FLASH_VER_ID_OFFSET);\r\n}\r\nvalue = s3c_read_cmd(CMD_MAP_11(onenand, word_addr)) & 0xffff;\r\ndev_info(dev, "%s: Illegal access at reg 0x%x, value 0x%x\n", __func__,\r\nword_addr, value);\r\nreturn value;\r\n}\r\nstatic void s3c_onenand_writew(unsigned short value, void __iomem *addr)\r\n{\r\nstruct onenand_chip *this = onenand->mtd->priv;\r\nstruct device *dev = &onenand->pdev->dev;\r\nunsigned int reg = addr - this->base;\r\nunsigned int word_addr = reg >> 1;\r\nswitch (reg) {\r\ncase ONENAND_REG_SYS_CFG1:\r\ns3c_write_reg(value, MEM_CFG_OFFSET);\r\nreturn;\r\ncase ONENAND_REG_START_ADDRESS1:\r\ncase ONENAND_REG_START_ADDRESS2:\r\nreturn;\r\ncase ONENAND_REG_START_BLOCK_ADDRESS:\r\nreturn;\r\ndefault:\r\nbreak;\r\n}\r\nif ((unsigned int)addr < ONENAND_DATARAM) {\r\nif (value == ONENAND_CMD_READID) {\r\nonenand->bootram_command = 1;\r\nreturn;\r\n}\r\nif (value == ONENAND_CMD_RESET) {\r\ns3c_write_reg(ONENAND_MEM_RESET_COLD, MEM_RESET_OFFSET);\r\nonenand->bootram_command = 0;\r\nreturn;\r\n}\r\n}\r\ndev_info(dev, "%s: Illegal access at reg 0x%x, value 0x%x\n", __func__,\r\nword_addr, value);\r\ns3c_write_cmd(value, CMD_MAP_11(onenand, word_addr));\r\n}\r\nstatic int s3c_onenand_wait(struct mtd_info *mtd, int state)\r\n{\r\nstruct device *dev = &onenand->pdev->dev;\r\nunsigned int flags = INT_ACT;\r\nunsigned int stat, ecc;\r\nunsigned long timeout;\r\nswitch (state) {\r\ncase FL_READING:\r\nflags |= BLK_RW_CMP | LOAD_CMP;\r\nbreak;\r\ncase FL_WRITING:\r\nflags |= BLK_RW_CMP | PGM_CMP;\r\nbreak;\r\ncase FL_ERASING:\r\nflags |= BLK_RW_CMP | ERS_CMP;\r\nbreak;\r\ncase FL_LOCKING:\r\nflags |= BLK_RW_CMP;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\ntimeout = jiffies + msecs_to_jiffies(20);\r\nwhile (time_before(jiffies, timeout)) {\r\nstat = s3c_read_reg(INT_ERR_STAT_OFFSET);\r\nif (stat & flags)\r\nbreak;\r\nif (state != FL_READING)\r\ncond_resched();\r\n}\r\nstat = s3c_read_reg(INT_ERR_STAT_OFFSET);\r\ns3c_write_reg(stat, INT_ERR_ACK_OFFSET);\r\nif (stat & LOAD_CMP) {\r\necc = s3c_read_reg(ECC_ERR_STAT_OFFSET);\r\nif (ecc & ONENAND_ECC_4BIT_UNCORRECTABLE) {\r\ndev_info(dev, "%s: ECC error = 0x%04x\n", __func__,\r\necc);\r\nmtd->ecc_stats.failed++;\r\nreturn -EBADMSG;\r\n}\r\n}\r\nif (stat & (LOCKED_BLK | ERS_FAIL | PGM_FAIL | LD_FAIL_ECC_ERR)) {\r\ndev_info(dev, "%s: controller error = 0x%04x\n", __func__,\r\nstat);\r\nif (stat & LOCKED_BLK)\r\ndev_info(dev, "%s: it's locked error = 0x%04x\n",\r\n__func__, stat);\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic int s3c_onenand_command(struct mtd_info *mtd, int cmd, loff_t addr,\r\nsize_t len)\r\n{\r\nstruct onenand_chip *this = mtd->priv;\r\nunsigned int *m, *s;\r\nint fba, fpa, fsa = 0;\r\nunsigned int mem_addr, cmd_map_01, cmd_map_10;\r\nint i, mcount, scount;\r\nint index;\r\nfba = (int) (addr >> this->erase_shift);\r\nfpa = (int) (addr >> this->page_shift);\r\nfpa &= this->page_mask;\r\nmem_addr = onenand->mem_addr(fba, fpa, fsa);\r\ncmd_map_01 = CMD_MAP_01(onenand, mem_addr);\r\ncmd_map_10 = CMD_MAP_10(onenand, mem_addr);\r\nswitch (cmd) {\r\ncase ONENAND_CMD_READ:\r\ncase ONENAND_CMD_READOOB:\r\ncase ONENAND_CMD_BUFFERRAM:\r\nONENAND_SET_NEXT_BUFFERRAM(this);\r\ndefault:\r\nbreak;\r\n}\r\nindex = ONENAND_CURRENT_BUFFERRAM(this);\r\nm = (unsigned int *) onenand->page_buf;\r\ns = (unsigned int *) onenand->oob_buf;\r\nif (index) {\r\nm += (this->writesize >> 2);\r\ns += (mtd->oobsize >> 2);\r\n}\r\nmcount = mtd->writesize >> 2;\r\nscount = mtd->oobsize >> 2;\r\nswitch (cmd) {\r\ncase ONENAND_CMD_READ:\r\nfor (i = 0; i < mcount; i++)\r\n*m++ = s3c_read_cmd(cmd_map_01);\r\nreturn 0;\r\ncase ONENAND_CMD_READOOB:\r\ns3c_write_reg(TSRF, TRANS_SPARE_OFFSET);\r\nfor (i = 0; i < mcount; i++)\r\n*m++ = s3c_read_cmd(cmd_map_01);\r\nfor (i = 0; i < scount; i++)\r\n*s++ = s3c_read_cmd(cmd_map_01);\r\ns3c_write_reg(0, TRANS_SPARE_OFFSET);\r\nreturn 0;\r\ncase ONENAND_CMD_PROG:\r\nfor (i = 0; i < mcount; i++)\r\ns3c_write_cmd(*m++, cmd_map_01);\r\nreturn 0;\r\ncase ONENAND_CMD_PROGOOB:\r\ns3c_write_reg(TSRF, TRANS_SPARE_OFFSET);\r\nfor (i = 0; i < mcount; i++)\r\ns3c_write_cmd(0xffffffff, cmd_map_01);\r\nfor (i = 0; i < scount; i++)\r\ns3c_write_cmd(*s++, cmd_map_01);\r\ns3c_write_reg(0, TRANS_SPARE_OFFSET);\r\nreturn 0;\r\ncase ONENAND_CMD_UNLOCK_ALL:\r\ns3c_write_cmd(ONENAND_UNLOCK_ALL, cmd_map_10);\r\nreturn 0;\r\ncase ONENAND_CMD_ERASE:\r\ns3c_write_cmd(ONENAND_ERASE_START, cmd_map_10);\r\nreturn 0;\r\ndefault:\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic unsigned char *s3c_get_bufferram(struct mtd_info *mtd, int area)\r\n{\r\nstruct onenand_chip *this = mtd->priv;\r\nint index = ONENAND_CURRENT_BUFFERRAM(this);\r\nunsigned char *p;\r\nif (area == ONENAND_DATARAM) {\r\np = (unsigned char *) onenand->page_buf;\r\nif (index == 1)\r\np += this->writesize;\r\n} else {\r\np = (unsigned char *) onenand->oob_buf;\r\nif (index == 1)\r\np += mtd->oobsize;\r\n}\r\nreturn p;\r\n}\r\nstatic int onenand_read_bufferram(struct mtd_info *mtd, int area,\r\nunsigned char *buffer, int offset,\r\nsize_t count)\r\n{\r\nunsigned char *p;\r\np = s3c_get_bufferram(mtd, area);\r\nmemcpy(buffer, p + offset, count);\r\nreturn 0;\r\n}\r\nstatic int onenand_write_bufferram(struct mtd_info *mtd, int area,\r\nconst unsigned char *buffer, int offset,\r\nsize_t count)\r\n{\r\nunsigned char *p;\r\np = s3c_get_bufferram(mtd, area);\r\nmemcpy(p + offset, buffer, count);\r\nreturn 0;\r\n}\r\nstatic int s5pc110_dma_poll(dma_addr_t dst, dma_addr_t src, size_t count, int direction)\r\n{\r\nvoid __iomem *base = onenand->dma_addr;\r\nint status;\r\nunsigned long timeout;\r\nwritel(src, base + S5PC110_DMA_SRC_ADDR);\r\nwritel(dst, base + S5PC110_DMA_DST_ADDR);\r\nif (direction == S5PC110_DMA_DIR_READ) {\r\nwritel(S5PC110_DMA_SRC_CFG_READ, base + S5PC110_DMA_SRC_CFG);\r\nwritel(S5PC110_DMA_DST_CFG_READ, base + S5PC110_DMA_DST_CFG);\r\n} else {\r\nwritel(S5PC110_DMA_SRC_CFG_WRITE, base + S5PC110_DMA_SRC_CFG);\r\nwritel(S5PC110_DMA_DST_CFG_WRITE, base + S5PC110_DMA_DST_CFG);\r\n}\r\nwritel(count, base + S5PC110_DMA_TRANS_SIZE);\r\nwritel(direction, base + S5PC110_DMA_TRANS_DIR);\r\nwritel(S5PC110_DMA_TRANS_CMD_TR, base + S5PC110_DMA_TRANS_CMD);\r\ntimeout = jiffies + msecs_to_jiffies(20);\r\ndo {\r\nstatus = readl(base + S5PC110_DMA_TRANS_STATUS);\r\nif (status & S5PC110_DMA_TRANS_STATUS_TE) {\r\nwritel(S5PC110_DMA_TRANS_CMD_TEC,\r\nbase + S5PC110_DMA_TRANS_CMD);\r\nreturn -EIO;\r\n}\r\n} while (!(status & S5PC110_DMA_TRANS_STATUS_TD) &&\r\ntime_before(jiffies, timeout));\r\nwritel(S5PC110_DMA_TRANS_CMD_TDC, base + S5PC110_DMA_TRANS_CMD);\r\nreturn 0;\r\n}\r\nstatic irqreturn_t s5pc110_onenand_irq(int irq, void *data)\r\n{\r\nvoid __iomem *base = onenand->dma_addr;\r\nint status, cmd = 0;\r\nstatus = readl(base + S5PC110_INTC_DMA_STATUS);\r\nif (likely(status & S5PC110_INTC_DMA_TD))\r\ncmd = S5PC110_DMA_TRANS_CMD_TDC;\r\nif (unlikely(status & S5PC110_INTC_DMA_TE))\r\ncmd = S5PC110_DMA_TRANS_CMD_TEC;\r\nwritel(cmd, base + S5PC110_DMA_TRANS_CMD);\r\nwritel(status, base + S5PC110_INTC_DMA_CLR);\r\nif (!onenand->complete.done)\r\ncomplete(&onenand->complete);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int s5pc110_dma_irq(dma_addr_t dst, dma_addr_t src, size_t count, int direction)\r\n{\r\nvoid __iomem *base = onenand->dma_addr;\r\nint status;\r\nstatus = readl(base + S5PC110_INTC_DMA_MASK);\r\nif (status) {\r\nstatus &= ~(S5PC110_INTC_DMA_TD | S5PC110_INTC_DMA_TE);\r\nwritel(status, base + S5PC110_INTC_DMA_MASK);\r\n}\r\nwritel(src, base + S5PC110_DMA_SRC_ADDR);\r\nwritel(dst, base + S5PC110_DMA_DST_ADDR);\r\nif (direction == S5PC110_DMA_DIR_READ) {\r\nwritel(S5PC110_DMA_SRC_CFG_READ, base + S5PC110_DMA_SRC_CFG);\r\nwritel(S5PC110_DMA_DST_CFG_READ, base + S5PC110_DMA_DST_CFG);\r\n} else {\r\nwritel(S5PC110_DMA_SRC_CFG_WRITE, base + S5PC110_DMA_SRC_CFG);\r\nwritel(S5PC110_DMA_DST_CFG_WRITE, base + S5PC110_DMA_DST_CFG);\r\n}\r\nwritel(count, base + S5PC110_DMA_TRANS_SIZE);\r\nwritel(direction, base + S5PC110_DMA_TRANS_DIR);\r\nwritel(S5PC110_DMA_TRANS_CMD_TR, base + S5PC110_DMA_TRANS_CMD);\r\nwait_for_completion_timeout(&onenand->complete, msecs_to_jiffies(20));\r\nreturn 0;\r\n}\r\nstatic int s5pc110_read_bufferram(struct mtd_info *mtd, int area,\r\nunsigned char *buffer, int offset, size_t count)\r\n{\r\nstruct onenand_chip *this = mtd->priv;\r\nvoid __iomem *p;\r\nvoid *buf = (void *) buffer;\r\ndma_addr_t dma_src, dma_dst;\r\nint err, ofs, page_dma = 0;\r\nstruct device *dev = &onenand->pdev->dev;\r\np = this->base + area;\r\nif (ONENAND_CURRENT_BUFFERRAM(this)) {\r\nif (area == ONENAND_DATARAM)\r\np += this->writesize;\r\nelse\r\np += mtd->oobsize;\r\n}\r\nif (offset & 3 || (size_t) buf & 3 ||\r\n!onenand->dma_addr || count != mtd->writesize)\r\ngoto normal;\r\nif (buf >= high_memory) {\r\nstruct page *page;\r\nif (((size_t) buf & PAGE_MASK) !=\r\n((size_t) (buf + count - 1) & PAGE_MASK))\r\ngoto normal;\r\npage = vmalloc_to_page(buf);\r\nif (!page)\r\ngoto normal;\r\nofs = ((size_t) buf & ~PAGE_MASK);\r\npage_dma = 1;\r\ndma_src = onenand->phys_base + (p - this->base);\r\ndma_dst = dma_map_page(dev, page, ofs, count, DMA_FROM_DEVICE);\r\n} else {\r\ndma_src = onenand->phys_base + (p - this->base);\r\ndma_dst = dma_map_single(dev, buf, count, DMA_FROM_DEVICE);\r\n}\r\nif (dma_mapping_error(dev, dma_dst)) {\r\ndev_err(dev, "Couldn't map a %d byte buffer for DMA\n", count);\r\ngoto normal;\r\n}\r\nerr = s5pc110_dma_ops(dma_dst, dma_src,\r\ncount, S5PC110_DMA_DIR_READ);\r\nif (page_dma)\r\ndma_unmap_page(dev, dma_dst, count, DMA_FROM_DEVICE);\r\nelse\r\ndma_unmap_single(dev, dma_dst, count, DMA_FROM_DEVICE);\r\nif (!err)\r\nreturn 0;\r\nnormal:\r\nif (count != mtd->writesize) {\r\nmemcpy(this->page_buf, p, mtd->writesize);\r\np = this->page_buf + offset;\r\n}\r\nmemcpy(buffer, p, count);\r\nreturn 0;\r\n}\r\nstatic int s5pc110_chip_probe(struct mtd_info *mtd)\r\n{\r\nreturn 0;\r\n}\r\nstatic int s3c_onenand_bbt_wait(struct mtd_info *mtd, int state)\r\n{\r\nunsigned int flags = INT_ACT | LOAD_CMP;\r\nunsigned int stat;\r\nunsigned long timeout;\r\ntimeout = jiffies + msecs_to_jiffies(20);\r\nwhile (time_before(jiffies, timeout)) {\r\nstat = s3c_read_reg(INT_ERR_STAT_OFFSET);\r\nif (stat & flags)\r\nbreak;\r\n}\r\nstat = s3c_read_reg(INT_ERR_STAT_OFFSET);\r\ns3c_write_reg(stat, INT_ERR_ACK_OFFSET);\r\nif (stat & LD_FAIL_ECC_ERR) {\r\ns3c_onenand_reset();\r\nreturn ONENAND_BBT_READ_ERROR;\r\n}\r\nif (stat & LOAD_CMP) {\r\nint ecc = s3c_read_reg(ECC_ERR_STAT_OFFSET);\r\nif (ecc & ONENAND_ECC_4BIT_UNCORRECTABLE) {\r\ns3c_onenand_reset();\r\nreturn ONENAND_BBT_READ_ERROR;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void s3c_onenand_check_lock_status(struct mtd_info *mtd)\r\n{\r\nstruct onenand_chip *this = mtd->priv;\r\nstruct device *dev = &onenand->pdev->dev;\r\nunsigned int block, end;\r\nint tmp;\r\nend = this->chipsize >> this->erase_shift;\r\nfor (block = 0; block < end; block++) {\r\nunsigned int mem_addr = onenand->mem_addr(block, 0, 0);\r\ntmp = s3c_read_cmd(CMD_MAP_01(onenand, mem_addr));\r\nif (s3c_read_reg(INT_ERR_STAT_OFFSET) & LOCKED_BLK) {\r\ndev_err(dev, "block %d is write-protected!\n", block);\r\ns3c_write_reg(LOCKED_BLK, INT_ERR_ACK_OFFSET);\r\n}\r\n}\r\n}\r\nstatic void s3c_onenand_do_lock_cmd(struct mtd_info *mtd, loff_t ofs,\r\nsize_t len, int cmd)\r\n{\r\nstruct onenand_chip *this = mtd->priv;\r\nint start, end, start_mem_addr, end_mem_addr;\r\nstart = ofs >> this->erase_shift;\r\nstart_mem_addr = onenand->mem_addr(start, 0, 0);\r\nend = start + (len >> this->erase_shift) - 1;\r\nend_mem_addr = onenand->mem_addr(end, 0, 0);\r\nif (cmd == ONENAND_CMD_LOCK) {\r\ns3c_write_cmd(ONENAND_LOCK_START, CMD_MAP_10(onenand,\r\nstart_mem_addr));\r\ns3c_write_cmd(ONENAND_LOCK_END, CMD_MAP_10(onenand,\r\nend_mem_addr));\r\n} else {\r\ns3c_write_cmd(ONENAND_UNLOCK_START, CMD_MAP_10(onenand,\r\nstart_mem_addr));\r\ns3c_write_cmd(ONENAND_UNLOCK_END, CMD_MAP_10(onenand,\r\nend_mem_addr));\r\n}\r\nthis->wait(mtd, FL_LOCKING);\r\n}\r\nstatic void s3c_unlock_all(struct mtd_info *mtd)\r\n{\r\nstruct onenand_chip *this = mtd->priv;\r\nloff_t ofs = 0;\r\nsize_t len = this->chipsize;\r\nif (this->options & ONENAND_HAS_UNLOCK_ALL) {\r\nthis->command(mtd, ONENAND_CMD_UNLOCK_ALL, 0, 0);\r\nthis->wait(mtd, FL_LOCKING);\r\nif (!ONENAND_IS_DDP(this)) {\r\ns3c_onenand_check_lock_status(mtd);\r\nreturn;\r\n}\r\nofs = this->chipsize >> 1;\r\nlen = this->chipsize >> 1;\r\n}\r\ns3c_onenand_do_lock_cmd(mtd, ofs, len, ONENAND_CMD_UNLOCK);\r\ns3c_onenand_check_lock_status(mtd);\r\n}\r\nstatic void s3c_onenand_setup(struct mtd_info *mtd)\r\n{\r\nstruct onenand_chip *this = mtd->priv;\r\nonenand->mtd = mtd;\r\nif (onenand->type == TYPE_S3C6400) {\r\nonenand->mem_addr = s3c6400_mem_addr;\r\nonenand->cmd_map = s3c64xx_cmd_map;\r\n} else if (onenand->type == TYPE_S3C6410) {\r\nonenand->mem_addr = s3c6410_mem_addr;\r\nonenand->cmd_map = s3c64xx_cmd_map;\r\n} else if (onenand->type == TYPE_S5PC110) {\r\nthis->read_bufferram = s5pc110_read_bufferram;\r\nthis->chip_probe = s5pc110_chip_probe;\r\nreturn;\r\n} else {\r\nBUG();\r\n}\r\nthis->read_word = s3c_onenand_readw;\r\nthis->write_word = s3c_onenand_writew;\r\nthis->wait = s3c_onenand_wait;\r\nthis->bbt_wait = s3c_onenand_bbt_wait;\r\nthis->unlock_all = s3c_unlock_all;\r\nthis->command = s3c_onenand_command;\r\nthis->read_bufferram = onenand_read_bufferram;\r\nthis->write_bufferram = onenand_write_bufferram;\r\n}\r\nstatic int s3c_onenand_probe(struct platform_device *pdev)\r\n{\r\nstruct onenand_platform_data *pdata;\r\nstruct onenand_chip *this;\r\nstruct mtd_info *mtd;\r\nstruct resource *r;\r\nint size, err;\r\npdata = dev_get_platdata(&pdev->dev);\r\nsize = sizeof(struct mtd_info) + sizeof(struct onenand_chip);\r\nmtd = kzalloc(size, GFP_KERNEL);\r\nif (!mtd)\r\nreturn -ENOMEM;\r\nonenand = kzalloc(sizeof(struct s3c_onenand), GFP_KERNEL);\r\nif (!onenand) {\r\nerr = -ENOMEM;\r\ngoto onenand_fail;\r\n}\r\nthis = (struct onenand_chip *) &mtd[1];\r\nmtd->priv = this;\r\nmtd->dev.parent = &pdev->dev;\r\nmtd->owner = THIS_MODULE;\r\nonenand->pdev = pdev;\r\nonenand->type = platform_get_device_id(pdev)->driver_data;\r\ns3c_onenand_setup(mtd);\r\nr = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!r) {\r\ndev_err(&pdev->dev, "no memory resource defined\n");\r\nreturn -ENOENT;\r\ngoto ahb_resource_failed;\r\n}\r\nonenand->base_res = request_mem_region(r->start, resource_size(r),\r\npdev->name);\r\nif (!onenand->base_res) {\r\ndev_err(&pdev->dev, "failed to request memory resource\n");\r\nerr = -EBUSY;\r\ngoto resource_failed;\r\n}\r\nonenand->base = ioremap(r->start, resource_size(r));\r\nif (!onenand->base) {\r\ndev_err(&pdev->dev, "failed to map memory resource\n");\r\nerr = -EFAULT;\r\ngoto ioremap_failed;\r\n}\r\nthis->base = onenand->base;\r\nthis->options |= ONENAND_SKIP_UNLOCK_CHECK;\r\nif (onenand->type != TYPE_S5PC110) {\r\nr = platform_get_resource(pdev, IORESOURCE_MEM, 1);\r\nif (!r) {\r\ndev_err(&pdev->dev, "no buffer memory resource defined\n");\r\nerr = -ENOENT;\r\ngoto ahb_resource_failed;\r\n}\r\nonenand->ahb_res = request_mem_region(r->start, resource_size(r),\r\npdev->name);\r\nif (!onenand->ahb_res) {\r\ndev_err(&pdev->dev, "failed to request buffer memory resource\n");\r\nerr = -EBUSY;\r\ngoto ahb_resource_failed;\r\n}\r\nonenand->ahb_addr = ioremap(r->start, resource_size(r));\r\nif (!onenand->ahb_addr) {\r\ndev_err(&pdev->dev, "failed to map buffer memory resource\n");\r\nerr = -EINVAL;\r\ngoto ahb_ioremap_failed;\r\n}\r\nonenand->page_buf = kzalloc(SZ_4K, GFP_KERNEL);\r\nif (!onenand->page_buf) {\r\nerr = -ENOMEM;\r\ngoto page_buf_fail;\r\n}\r\nonenand->oob_buf = kzalloc(128, GFP_KERNEL);\r\nif (!onenand->oob_buf) {\r\nerr = -ENOMEM;\r\ngoto oob_buf_fail;\r\n}\r\nmtd->subpage_sft = 0;\r\nthis->subpagesize = mtd->writesize;\r\n} else {\r\nr = platform_get_resource(pdev, IORESOURCE_MEM, 1);\r\nif (!r) {\r\ndev_err(&pdev->dev, "no dma memory resource defined\n");\r\nerr = -ENOENT;\r\ngoto dma_resource_failed;\r\n}\r\nonenand->dma_res = request_mem_region(r->start, resource_size(r),\r\npdev->name);\r\nif (!onenand->dma_res) {\r\ndev_err(&pdev->dev, "failed to request dma memory resource\n");\r\nerr = -EBUSY;\r\ngoto dma_resource_failed;\r\n}\r\nonenand->dma_addr = ioremap(r->start, resource_size(r));\r\nif (!onenand->dma_addr) {\r\ndev_err(&pdev->dev, "failed to map dma memory resource\n");\r\nerr = -EINVAL;\r\ngoto dma_ioremap_failed;\r\n}\r\nonenand->phys_base = onenand->base_res->start;\r\ns5pc110_dma_ops = s5pc110_dma_poll;\r\nr = platform_get_resource(pdev, IORESOURCE_IRQ, 0);\r\nif (r) {\r\ninit_completion(&onenand->complete);\r\ns5pc110_dma_ops = s5pc110_dma_irq;\r\nerr = request_irq(r->start, s5pc110_onenand_irq,\r\nIRQF_SHARED, "onenand", &onenand);\r\nif (err) {\r\ndev_err(&pdev->dev, "failed to get irq\n");\r\ngoto scan_failed;\r\n}\r\n}\r\n}\r\nif (onenand_scan(mtd, 1)) {\r\nerr = -EFAULT;\r\ngoto scan_failed;\r\n}\r\nif (onenand->type != TYPE_S5PC110) {\r\nmtd->subpage_sft = 0;\r\nthis->subpagesize = mtd->writesize;\r\n}\r\nif (s3c_read_reg(MEM_CFG_OFFSET) & ONENAND_SYS_CFG1_SYNC_READ)\r\ndev_info(&onenand->pdev->dev, "OneNAND Sync. Burst Read enabled\n");\r\nerr = mtd_device_parse_register(mtd, NULL, NULL,\r\npdata ? pdata->parts : NULL,\r\npdata ? pdata->nr_parts : 0);\r\nplatform_set_drvdata(pdev, mtd);\r\nreturn 0;\r\nscan_failed:\r\nif (onenand->dma_addr)\r\niounmap(onenand->dma_addr);\r\ndma_ioremap_failed:\r\nif (onenand->dma_res)\r\nrelease_mem_region(onenand->dma_res->start,\r\nresource_size(onenand->dma_res));\r\nkfree(onenand->oob_buf);\r\noob_buf_fail:\r\nkfree(onenand->page_buf);\r\npage_buf_fail:\r\nif (onenand->ahb_addr)\r\niounmap(onenand->ahb_addr);\r\nahb_ioremap_failed:\r\nif (onenand->ahb_res)\r\nrelease_mem_region(onenand->ahb_res->start,\r\nresource_size(onenand->ahb_res));\r\ndma_resource_failed:\r\nahb_resource_failed:\r\niounmap(onenand->base);\r\nioremap_failed:\r\nif (onenand->base_res)\r\nrelease_mem_region(onenand->base_res->start,\r\nresource_size(onenand->base_res));\r\nresource_failed:\r\nkfree(onenand);\r\nonenand_fail:\r\nkfree(mtd);\r\nreturn err;\r\n}\r\nstatic int s3c_onenand_remove(struct platform_device *pdev)\r\n{\r\nstruct mtd_info *mtd = platform_get_drvdata(pdev);\r\nonenand_release(mtd);\r\nif (onenand->ahb_addr)\r\niounmap(onenand->ahb_addr);\r\nif (onenand->ahb_res)\r\nrelease_mem_region(onenand->ahb_res->start,\r\nresource_size(onenand->ahb_res));\r\nif (onenand->dma_addr)\r\niounmap(onenand->dma_addr);\r\nif (onenand->dma_res)\r\nrelease_mem_region(onenand->dma_res->start,\r\nresource_size(onenand->dma_res));\r\niounmap(onenand->base);\r\nrelease_mem_region(onenand->base_res->start,\r\nresource_size(onenand->base_res));\r\nkfree(onenand->oob_buf);\r\nkfree(onenand->page_buf);\r\nkfree(onenand);\r\nkfree(mtd);\r\nreturn 0;\r\n}\r\nstatic int s3c_pm_ops_suspend(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct mtd_info *mtd = platform_get_drvdata(pdev);\r\nstruct onenand_chip *this = mtd->priv;\r\nthis->wait(mtd, FL_PM_SUSPENDED);\r\nreturn 0;\r\n}\r\nstatic int s3c_pm_ops_resume(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct mtd_info *mtd = platform_get_drvdata(pdev);\r\nstruct onenand_chip *this = mtd->priv;\r\nthis->unlock_all(mtd);\r\nreturn 0;\r\n}
