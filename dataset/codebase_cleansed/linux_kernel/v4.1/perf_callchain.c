static bool is_valid_call(unsigned long calladdr)\r\n{\r\nunsigned int callinsn;\r\nif (!(calladdr & 0x3)) {\r\nif (!get_user(callinsn, (unsigned int *)calladdr)) {\r\nif ((callinsn & 0xff000000) == 0xab000000 ||\r\ncallinsn == 0xa3200aa0)\r\nreturn true;\r\n}\r\n}\r\nreturn false;\r\n}\r\nstatic struct metag_frame __user *\r\nuser_backtrace(struct metag_frame __user *user_frame,\r\nstruct perf_callchain_entry *entry)\r\n{\r\nstruct metag_frame frame;\r\nunsigned long calladdr;\r\nwhile (1) {\r\nif (!access_ok(VERIFY_READ, user_frame, sizeof(frame)))\r\nreturn 0;\r\nif (__copy_from_user_inatomic(&frame, user_frame,\r\nsizeof(frame)))\r\nreturn 0;\r\n--user_frame;\r\ncalladdr = frame.lr - 4;\r\nif (is_valid_call(calladdr)) {\r\nperf_callchain_store(entry, calladdr);\r\nreturn user_frame;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nvoid\r\nperf_callchain_user(struct perf_callchain_entry *entry, struct pt_regs *regs)\r\n{\r\nunsigned long sp = regs->ctx.AX[0].U0;\r\nstruct metag_frame __user *frame;\r\nframe = (struct metag_frame __user *)sp;\r\n--frame;\r\nwhile ((entry->nr < PERF_MAX_STACK_DEPTH) && frame)\r\nframe = user_backtrace(frame, entry);\r\n}\r\nstatic int\r\ncallchain_trace(struct stackframe *fr,\r\nvoid *data)\r\n{\r\nstruct perf_callchain_entry *entry = data;\r\nperf_callchain_store(entry, fr->pc);\r\nreturn 0;\r\n}\r\nvoid\r\nperf_callchain_kernel(struct perf_callchain_entry *entry, struct pt_regs *regs)\r\n{\r\nstruct stackframe fr;\r\nfr.fp = regs->ctx.AX[1].U0;\r\nfr.sp = regs->ctx.AX[0].U0;\r\nfr.lr = regs->ctx.DX[4].U1;\r\nfr.pc = regs->ctx.CurrPC;\r\nwalk_stackframe(&fr, callchain_trace, entry);\r\n}
