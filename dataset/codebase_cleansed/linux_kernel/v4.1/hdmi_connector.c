static int gpio_config(struct hdmi *hdmi, bool on)\r\n{\r\nstruct drm_device *dev = hdmi->dev;\r\nconst struct hdmi_platform_config *config = hdmi->config;\r\nint ret;\r\nif (on) {\r\nret = gpio_request(config->ddc_clk_gpio, "HDMI_DDC_CLK");\r\nif (ret) {\r\ndev_err(dev->dev, "'%s'(%d) gpio_request failed: %d\n",\r\n"HDMI_DDC_CLK", config->ddc_clk_gpio, ret);\r\ngoto error1;\r\n}\r\ngpio_set_value_cansleep(config->ddc_clk_gpio, 1);\r\nret = gpio_request(config->ddc_data_gpio, "HDMI_DDC_DATA");\r\nif (ret) {\r\ndev_err(dev->dev, "'%s'(%d) gpio_request failed: %d\n",\r\n"HDMI_DDC_DATA", config->ddc_data_gpio, ret);\r\ngoto error2;\r\n}\r\ngpio_set_value_cansleep(config->ddc_data_gpio, 1);\r\nret = gpio_request(config->hpd_gpio, "HDMI_HPD");\r\nif (ret) {\r\ndev_err(dev->dev, "'%s'(%d) gpio_request failed: %d\n",\r\n"HDMI_HPD", config->hpd_gpio, ret);\r\ngoto error3;\r\n}\r\ngpio_direction_input(config->hpd_gpio);\r\ngpio_set_value_cansleep(config->hpd_gpio, 1);\r\nif (config->mux_en_gpio != -1) {\r\nret = gpio_request(config->mux_en_gpio, "HDMI_MUX_EN");\r\nif (ret) {\r\ndev_err(dev->dev, "'%s'(%d) gpio_request failed: %d\n",\r\n"HDMI_MUX_EN", config->mux_en_gpio, ret);\r\ngoto error4;\r\n}\r\ngpio_set_value_cansleep(config->mux_en_gpio, 1);\r\n}\r\nif (config->mux_sel_gpio != -1) {\r\nret = gpio_request(config->mux_sel_gpio, "HDMI_MUX_SEL");\r\nif (ret) {\r\ndev_err(dev->dev, "'%s'(%d) gpio_request failed: %d\n",\r\n"HDMI_MUX_SEL", config->mux_sel_gpio, ret);\r\ngoto error5;\r\n}\r\ngpio_set_value_cansleep(config->mux_sel_gpio, 0);\r\n}\r\nif (config->mux_lpm_gpio != -1) {\r\nret = gpio_request(config->mux_lpm_gpio,\r\n"HDMI_MUX_LPM");\r\nif (ret) {\r\ndev_err(dev->dev,\r\n"'%s'(%d) gpio_request failed: %d\n",\r\n"HDMI_MUX_LPM",\r\nconfig->mux_lpm_gpio, ret);\r\ngoto error6;\r\n}\r\ngpio_set_value_cansleep(config->mux_lpm_gpio, 1);\r\n}\r\nDBG("gpio on");\r\n} else {\r\ngpio_free(config->ddc_clk_gpio);\r\ngpio_free(config->ddc_data_gpio);\r\ngpio_free(config->hpd_gpio);\r\nif (config->mux_en_gpio != -1) {\r\ngpio_set_value_cansleep(config->mux_en_gpio, 0);\r\ngpio_free(config->mux_en_gpio);\r\n}\r\nif (config->mux_sel_gpio != -1) {\r\ngpio_set_value_cansleep(config->mux_sel_gpio, 1);\r\ngpio_free(config->mux_sel_gpio);\r\n}\r\nif (config->mux_lpm_gpio != -1) {\r\ngpio_set_value_cansleep(config->mux_lpm_gpio, 0);\r\ngpio_free(config->mux_lpm_gpio);\r\n}\r\nDBG("gpio off");\r\n}\r\nreturn 0;\r\nerror6:\r\nif (config->mux_sel_gpio != -1)\r\ngpio_free(config->mux_sel_gpio);\r\nerror5:\r\nif (config->mux_en_gpio != -1)\r\ngpio_free(config->mux_en_gpio);\r\nerror4:\r\ngpio_free(config->hpd_gpio);\r\nerror3:\r\ngpio_free(config->ddc_data_gpio);\r\nerror2:\r\ngpio_free(config->ddc_clk_gpio);\r\nerror1:\r\nreturn ret;\r\n}\r\nstatic int hpd_enable(struct hdmi_connector *hdmi_connector)\r\n{\r\nstruct hdmi *hdmi = hdmi_connector->hdmi;\r\nconst struct hdmi_platform_config *config = hdmi->config;\r\nstruct drm_device *dev = hdmi_connector->base.dev;\r\nstruct hdmi_phy *phy = hdmi->phy;\r\nuint32_t hpd_ctrl;\r\nint i, ret;\r\nfor (i = 0; i < config->hpd_reg_cnt; i++) {\r\nret = regulator_enable(hdmi->hpd_regs[i]);\r\nif (ret) {\r\ndev_err(dev->dev, "failed to enable hpd regulator: %s (%d)\n",\r\nconfig->hpd_reg_names[i], ret);\r\ngoto fail;\r\n}\r\n}\r\nret = gpio_config(hdmi, true);\r\nif (ret) {\r\ndev_err(dev->dev, "failed to configure GPIOs: %d\n", ret);\r\ngoto fail;\r\n}\r\nfor (i = 0; i < config->hpd_clk_cnt; i++) {\r\nif (config->hpd_freq && config->hpd_freq[i]) {\r\nret = clk_set_rate(hdmi->hpd_clks[i],\r\nconfig->hpd_freq[i]);\r\nif (ret)\r\ndev_warn(dev->dev, "failed to set clk %s (%d)\n",\r\nconfig->hpd_clk_names[i], ret);\r\n}\r\nret = clk_prepare_enable(hdmi->hpd_clks[i]);\r\nif (ret) {\r\ndev_err(dev->dev, "failed to enable hpd clk: %s (%d)\n",\r\nconfig->hpd_clk_names[i], ret);\r\ngoto fail;\r\n}\r\n}\r\nhdmi_set_mode(hdmi, false);\r\nphy->funcs->reset(phy);\r\nhdmi_set_mode(hdmi, true);\r\nhdmi_write(hdmi, REG_HDMI_USEC_REFTIMER, 0x0001001b);\r\nhdmi_write(hdmi, REG_HDMI_HPD_INT_CTRL,\r\nHDMI_HPD_INT_CTRL_INT_CONNECT |\r\nHDMI_HPD_INT_CTRL_INT_EN);\r\nhpd_ctrl = hdmi_read(hdmi, REG_HDMI_HPD_CTRL);\r\nhpd_ctrl |= HDMI_HPD_CTRL_TIMEOUT(0x1fff);\r\nhdmi_write(hdmi, REG_HDMI_HPD_CTRL,\r\n~HDMI_HPD_CTRL_ENABLE & hpd_ctrl);\r\nhdmi_write(hdmi, REG_HDMI_HPD_CTRL,\r\nHDMI_HPD_CTRL_ENABLE | hpd_ctrl);\r\nreturn 0;\r\nfail:\r\nreturn ret;\r\n}\r\nstatic void hdp_disable(struct hdmi_connector *hdmi_connector)\r\n{\r\nstruct hdmi *hdmi = hdmi_connector->hdmi;\r\nconst struct hdmi_platform_config *config = hdmi->config;\r\nstruct drm_device *dev = hdmi_connector->base.dev;\r\nint i, ret = 0;\r\nhdmi_write(hdmi, REG_HDMI_HPD_INT_CTRL, 0);\r\nhdmi_set_mode(hdmi, false);\r\nfor (i = 0; i < config->hpd_clk_cnt; i++)\r\nclk_disable_unprepare(hdmi->hpd_clks[i]);\r\nret = gpio_config(hdmi, false);\r\nif (ret)\r\ndev_warn(dev->dev, "failed to unconfigure GPIOs: %d\n", ret);\r\nfor (i = 0; i < config->hpd_reg_cnt; i++) {\r\nret = regulator_disable(hdmi->hpd_regs[i]);\r\nif (ret)\r\ndev_warn(dev->dev, "failed to disable hpd regulator: %s (%d)\n",\r\nconfig->hpd_reg_names[i], ret);\r\n}\r\n}\r\nstatic void\r\nhotplug_work(struct work_struct *work)\r\n{\r\nstruct hdmi_connector *hdmi_connector =\r\ncontainer_of(work, struct hdmi_connector, hpd_work);\r\nstruct drm_connector *connector = &hdmi_connector->base;\r\ndrm_helper_hpd_irq_event(connector->dev);\r\n}\r\nvoid hdmi_connector_irq(struct drm_connector *connector)\r\n{\r\nstruct hdmi_connector *hdmi_connector = to_hdmi_connector(connector);\r\nstruct msm_drm_private *priv = connector->dev->dev_private;\r\nstruct hdmi *hdmi = hdmi_connector->hdmi;\r\nuint32_t hpd_int_status, hpd_int_ctrl;\r\nhpd_int_status = hdmi_read(hdmi, REG_HDMI_HPD_INT_STATUS);\r\nhpd_int_ctrl = hdmi_read(hdmi, REG_HDMI_HPD_INT_CTRL);\r\nif ((hpd_int_ctrl & HDMI_HPD_INT_CTRL_INT_EN) &&\r\n(hpd_int_status & HDMI_HPD_INT_STATUS_INT)) {\r\nbool detected = !!(hpd_int_status & HDMI_HPD_INT_STATUS_CABLE_DETECTED);\r\nhdmi_write(hdmi, REG_HDMI_HPD_INT_CTRL,\r\nHDMI_HPD_INT_CTRL_INT_ACK);\r\nDBG("status=%04x, ctrl=%04x", hpd_int_status, hpd_int_ctrl);\r\nhpd_int_ctrl = HDMI_HPD_INT_CTRL_INT_EN;\r\nif (!detected)\r\nhpd_int_ctrl |= HDMI_HPD_INT_CTRL_INT_CONNECT;\r\nhdmi_write(hdmi, REG_HDMI_HPD_INT_CTRL, hpd_int_ctrl);\r\nqueue_work(priv->wq, &hdmi_connector->hpd_work);\r\n}\r\n}\r\nstatic enum drm_connector_status detect_reg(struct hdmi *hdmi)\r\n{\r\nuint32_t hpd_int_status = hdmi_read(hdmi, REG_HDMI_HPD_INT_STATUS);\r\nreturn (hpd_int_status & HDMI_HPD_INT_STATUS_CABLE_DETECTED) ?\r\nconnector_status_connected : connector_status_disconnected;\r\n}\r\nstatic enum drm_connector_status detect_gpio(struct hdmi *hdmi)\r\n{\r\nconst struct hdmi_platform_config *config = hdmi->config;\r\nreturn gpio_get_value(config->hpd_gpio) ?\r\nconnector_status_connected :\r\nconnector_status_disconnected;\r\n}\r\nstatic enum drm_connector_status hdmi_connector_detect(\r\nstruct drm_connector *connector, bool force)\r\n{\r\nstruct hdmi_connector *hdmi_connector = to_hdmi_connector(connector);\r\nstruct hdmi *hdmi = hdmi_connector->hdmi;\r\nenum drm_connector_status stat_gpio, stat_reg;\r\nint retry = 20;\r\ndo {\r\nstat_gpio = detect_gpio(hdmi);\r\nstat_reg = detect_reg(hdmi);\r\nif (stat_gpio == stat_reg)\r\nbreak;\r\nmdelay(10);\r\n} while (--retry);\r\nif (stat_gpio != stat_reg) {\r\nDBG("HDMI_HPD_INT_STATUS tells us: %d", stat_reg);\r\nDBG("hpd gpio tells us: %d", stat_gpio);\r\n}\r\nreturn stat_gpio;\r\n}\r\nstatic void hdmi_connector_destroy(struct drm_connector *connector)\r\n{\r\nstruct hdmi_connector *hdmi_connector = to_hdmi_connector(connector);\r\nhdp_disable(hdmi_connector);\r\ndrm_connector_unregister(connector);\r\ndrm_connector_cleanup(connector);\r\nkfree(hdmi_connector);\r\n}\r\nstatic int hdmi_connector_get_modes(struct drm_connector *connector)\r\n{\r\nstruct hdmi_connector *hdmi_connector = to_hdmi_connector(connector);\r\nstruct hdmi *hdmi = hdmi_connector->hdmi;\r\nstruct edid *edid;\r\nuint32_t hdmi_ctrl;\r\nint ret = 0;\r\nhdmi_ctrl = hdmi_read(hdmi, REG_HDMI_CTRL);\r\nhdmi_write(hdmi, REG_HDMI_CTRL, hdmi_ctrl | HDMI_CTRL_ENABLE);\r\nedid = drm_get_edid(connector, hdmi->i2c);\r\nhdmi_write(hdmi, REG_HDMI_CTRL, hdmi_ctrl);\r\ndrm_mode_connector_update_edid_property(connector, edid);\r\nif (edid) {\r\nret = drm_add_edid_modes(connector, edid);\r\nkfree(edid);\r\n}\r\nreturn ret;\r\n}\r\nstatic int hdmi_connector_mode_valid(struct drm_connector *connector,\r\nstruct drm_display_mode *mode)\r\n{\r\nstruct hdmi_connector *hdmi_connector = to_hdmi_connector(connector);\r\nstruct hdmi *hdmi = hdmi_connector->hdmi;\r\nconst struct hdmi_platform_config *config = hdmi->config;\r\nstruct msm_drm_private *priv = connector->dev->dev_private;\r\nstruct msm_kms *kms = priv->kms;\r\nlong actual, requested;\r\nrequested = 1000 * mode->clock;\r\nactual = kms->funcs->round_pixclk(kms,\r\nrequested, hdmi_connector->hdmi->encoder);\r\nif (config->pwr_clk_cnt > 0)\r\nactual = clk_round_rate(hdmi->pwr_clks[0], actual);\r\nDBG("requested=%ld, actual=%ld", requested, actual);\r\nif (actual != requested)\r\nreturn MODE_CLOCK_RANGE;\r\nreturn 0;\r\n}\r\nstatic struct drm_encoder *\r\nhdmi_connector_best_encoder(struct drm_connector *connector)\r\n{\r\nstruct hdmi_connector *hdmi_connector = to_hdmi_connector(connector);\r\nreturn hdmi_connector->hdmi->encoder;\r\n}\r\nstruct drm_connector *hdmi_connector_init(struct hdmi *hdmi)\r\n{\r\nstruct drm_connector *connector = NULL;\r\nstruct hdmi_connector *hdmi_connector;\r\nint ret;\r\nhdmi_connector = kzalloc(sizeof(*hdmi_connector), GFP_KERNEL);\r\nif (!hdmi_connector) {\r\nret = -ENOMEM;\r\ngoto fail;\r\n}\r\nhdmi_connector->hdmi = hdmi;\r\nINIT_WORK(&hdmi_connector->hpd_work, hotplug_work);\r\nconnector = &hdmi_connector->base;\r\ndrm_connector_init(hdmi->dev, connector, &hdmi_connector_funcs,\r\nDRM_MODE_CONNECTOR_HDMIA);\r\ndrm_connector_helper_add(connector, &hdmi_connector_helper_funcs);\r\nconnector->polled = DRM_CONNECTOR_POLL_CONNECT |\r\nDRM_CONNECTOR_POLL_DISCONNECT;\r\nconnector->interlace_allowed = 0;\r\nconnector->doublescan_allowed = 0;\r\ndrm_connector_register(connector);\r\nret = hpd_enable(hdmi_connector);\r\nif (ret) {\r\ndev_err(hdmi->dev->dev, "failed to enable HPD: %d\n", ret);\r\ngoto fail;\r\n}\r\ndrm_mode_connector_attach_encoder(connector, hdmi->encoder);\r\nreturn connector;\r\nfail:\r\nif (connector)\r\nhdmi_connector_destroy(connector);\r\nreturn ERR_PTR(ret);\r\n}
