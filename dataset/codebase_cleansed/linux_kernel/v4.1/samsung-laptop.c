static int sabi_command(struct samsung_laptop *samsung, u16 command,\r\nstruct sabi_data *in,\r\nstruct sabi_data *out)\r\n{\r\nconst struct sabi_config *config = samsung->config;\r\nint ret = 0;\r\nu16 port = readw(samsung->sabi + config->header_offsets.port);\r\nu8 complete, iface_data;\r\nmutex_lock(&samsung->sabi_mutex);\r\nif (debug) {\r\nif (in)\r\npr_info("SABI command:0x%04x "\r\n"data:{0x%08x, 0x%08x, 0x%04x, 0x%02x}",\r\ncommand, in->d0, in->d1, in->d2, in->d3);\r\nelse\r\npr_info("SABI command:0x%04x", command);\r\n}\r\noutb(readb(samsung->sabi + config->header_offsets.en_mem), port);\r\nwritew(config->main_function, samsung->sabi_iface + SABI_IFACE_MAIN);\r\nwritew(command, samsung->sabi_iface + SABI_IFACE_SUB);\r\nwriteb(0, samsung->sabi_iface + SABI_IFACE_COMPLETE);\r\nif (in) {\r\nwritel(in->d0, samsung->sabi_iface + SABI_IFACE_DATA);\r\nwritel(in->d1, samsung->sabi_iface + SABI_IFACE_DATA + 4);\r\nwritew(in->d2, samsung->sabi_iface + SABI_IFACE_DATA + 8);\r\nwriteb(in->d3, samsung->sabi_iface + SABI_IFACE_DATA + 10);\r\n}\r\noutb(readb(samsung->sabi + config->header_offsets.iface_func), port);\r\noutb(readb(samsung->sabi + config->header_offsets.re_mem), port);\r\ncomplete = readb(samsung->sabi_iface + SABI_IFACE_COMPLETE);\r\niface_data = readb(samsung->sabi_iface + SABI_IFACE_DATA);\r\nif (complete != 0xaa || (iface_data == 0xff && debug))\r\npr_warn("SABI command 0x%04x failed with"\r\n" completion flag 0x%02x and interface data 0x%02x",\r\ncommand, complete, iface_data);\r\nif (complete != 0xaa || iface_data == 0xff) {\r\nret = -EINVAL;\r\ngoto exit;\r\n}\r\nif (out) {\r\nout->d0 = readl(samsung->sabi_iface + SABI_IFACE_DATA);\r\nout->d1 = readl(samsung->sabi_iface + SABI_IFACE_DATA + 4);\r\nout->d2 = readw(samsung->sabi_iface + SABI_IFACE_DATA + 2);\r\nout->d3 = readb(samsung->sabi_iface + SABI_IFACE_DATA + 1);\r\n}\r\nif (debug && out) {\r\npr_info("SABI return data:{0x%08x, 0x%08x, 0x%04x, 0x%02x}",\r\nout->d0, out->d1, out->d2, out->d3);\r\n}\r\nexit:\r\nmutex_unlock(&samsung->sabi_mutex);\r\nreturn ret;\r\n}\r\nstatic int sabi_set_commandb(struct samsung_laptop *samsung,\r\nu16 command, u8 data)\r\n{\r\nstruct sabi_data in = { { { .d0 = 0, .d1 = 0, .d2 = 0, .d3 = 0 } } };\r\nin.data[0] = data;\r\nreturn sabi_command(samsung, command, &in, NULL);\r\n}\r\nstatic int read_brightness(struct samsung_laptop *samsung)\r\n{\r\nconst struct sabi_config *config = samsung->config;\r\nconst struct sabi_commands *commands = &samsung->config->commands;\r\nstruct sabi_data sretval;\r\nint user_brightness = 0;\r\nint retval;\r\nretval = sabi_command(samsung, commands->get_brightness,\r\nNULL, &sretval);\r\nif (retval)\r\nreturn retval;\r\nuser_brightness = sretval.data[0];\r\nif (user_brightness > config->min_brightness)\r\nuser_brightness -= config->min_brightness;\r\nelse\r\nuser_brightness = 0;\r\nreturn user_brightness;\r\n}\r\nstatic void set_brightness(struct samsung_laptop *samsung, u8 user_brightness)\r\n{\r\nconst struct sabi_config *config = samsung->config;\r\nconst struct sabi_commands *commands = &samsung->config->commands;\r\nu8 user_level = user_brightness + config->min_brightness;\r\nif (samsung->has_stepping_quirk && user_level != 0) {\r\nif (user_brightness == read_brightness(samsung))\r\nreturn;\r\nsabi_set_commandb(samsung, commands->set_brightness, 0);\r\n}\r\nsabi_set_commandb(samsung, commands->set_brightness, user_level);\r\n}\r\nstatic int get_brightness(struct backlight_device *bd)\r\n{\r\nstruct samsung_laptop *samsung = bl_get_data(bd);\r\nreturn read_brightness(samsung);\r\n}\r\nstatic void check_for_stepping_quirk(struct samsung_laptop *samsung)\r\n{\r\nint initial_level;\r\nint check_level;\r\nint orig_level = read_brightness(samsung);\r\nif (orig_level == 0)\r\nset_brightness(samsung, 1);\r\ninitial_level = read_brightness(samsung);\r\nif (initial_level <= 2)\r\ncheck_level = initial_level + 2;\r\nelse\r\ncheck_level = initial_level - 2;\r\nsamsung->has_stepping_quirk = false;\r\nset_brightness(samsung, check_level);\r\nif (read_brightness(samsung) != check_level) {\r\nsamsung->has_stepping_quirk = true;\r\npr_info("enabled workaround for brightness stepping quirk\n");\r\n}\r\nset_brightness(samsung, orig_level);\r\n}\r\nstatic int update_status(struct backlight_device *bd)\r\n{\r\nstruct samsung_laptop *samsung = bl_get_data(bd);\r\nconst struct sabi_commands *commands = &samsung->config->commands;\r\nset_brightness(samsung, bd->props.brightness);\r\nif (bd->props.power == FB_BLANK_UNBLANK)\r\nsabi_set_commandb(samsung, commands->set_backlight, 1);\r\nelse\r\nsabi_set_commandb(samsung, commands->set_backlight, 0);\r\nreturn 0;\r\n}\r\nstatic int seclinux_rfkill_set(void *data, bool blocked)\r\n{\r\nstruct samsung_rfkill *srfkill = data;\r\nstruct samsung_laptop *samsung = srfkill->samsung;\r\nconst struct sabi_commands *commands = &samsung->config->commands;\r\nreturn sabi_set_commandb(samsung, commands->set_wireless_button,\r\n!blocked);\r\n}\r\nstatic int swsmi_wireless_status(struct samsung_laptop *samsung,\r\nstruct sabi_data *data)\r\n{\r\nconst struct sabi_commands *commands = &samsung->config->commands;\r\nreturn sabi_command(samsung, commands->get_wireless_status,\r\nNULL, data);\r\n}\r\nstatic int swsmi_rfkill_set(void *priv, bool blocked)\r\n{\r\nstruct samsung_rfkill *srfkill = priv;\r\nstruct samsung_laptop *samsung = srfkill->samsung;\r\nconst struct sabi_commands *commands = &samsung->config->commands;\r\nstruct sabi_data data;\r\nint ret, i;\r\nret = swsmi_wireless_status(samsung, &data);\r\nif (ret)\r\nreturn ret;\r\nfor (i = 0; i < 4; i++)\r\nif (data.data[i] == 0x02)\r\ndata.data[1] = 0;\r\nif (srfkill->type == RFKILL_TYPE_WLAN)\r\ndata.data[WL_STATUS_WLAN] = !blocked;\r\nelse if (srfkill->type == RFKILL_TYPE_BLUETOOTH)\r\ndata.data[WL_STATUS_BT] = !blocked;\r\nreturn sabi_command(samsung, commands->set_wireless_status,\r\n&data, &data);\r\n}\r\nstatic void swsmi_rfkill_query(struct rfkill *rfkill, void *priv)\r\n{\r\nstruct samsung_rfkill *srfkill = priv;\r\nstruct samsung_laptop *samsung = srfkill->samsung;\r\nstruct sabi_data data;\r\nint ret;\r\nret = swsmi_wireless_status(samsung, &data);\r\nif (ret)\r\nreturn ;\r\nif (srfkill->type == RFKILL_TYPE_WLAN)\r\nret = data.data[WL_STATUS_WLAN];\r\nelse if (srfkill->type == RFKILL_TYPE_BLUETOOTH)\r\nret = data.data[WL_STATUS_BT];\r\nelse\r\nreturn ;\r\nrfkill_set_sw_state(rfkill, !ret);\r\n}\r\nstatic ssize_t get_performance_level(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct samsung_laptop *samsung = dev_get_drvdata(dev);\r\nconst struct sabi_config *config = samsung->config;\r\nconst struct sabi_commands *commands = &config->commands;\r\nstruct sabi_data sretval;\r\nint retval;\r\nint i;\r\nretval = sabi_command(samsung, commands->get_performance_level,\r\nNULL, &sretval);\r\nif (retval)\r\nreturn retval;\r\nfor (i = 0; config->performance_levels[i].name; ++i) {\r\nif (sretval.data[0] == config->performance_levels[i].value)\r\nreturn sprintf(buf, "%s\n", config->performance_levels[i].name);\r\n}\r\nreturn sprintf(buf, "%s\n", "unknown");\r\n}\r\nstatic ssize_t set_performance_level(struct device *dev,\r\nstruct device_attribute *attr, const char *buf,\r\nsize_t count)\r\n{\r\nstruct samsung_laptop *samsung = dev_get_drvdata(dev);\r\nconst struct sabi_config *config = samsung->config;\r\nconst struct sabi_commands *commands = &config->commands;\r\nint i;\r\nif (count < 1)\r\nreturn count;\r\nfor (i = 0; config->performance_levels[i].name; ++i) {\r\nconst struct sabi_performance_level *level =\r\n&config->performance_levels[i];\r\nif (!strncasecmp(level->name, buf, strlen(level->name))) {\r\nsabi_set_commandb(samsung,\r\ncommands->set_performance_level,\r\nlevel->value);\r\nbreak;\r\n}\r\n}\r\nif (!config->performance_levels[i].name)\r\nreturn -EINVAL;\r\nreturn count;\r\n}\r\nstatic int read_battery_life_extender(struct samsung_laptop *samsung)\r\n{\r\nconst struct sabi_commands *commands = &samsung->config->commands;\r\nstruct sabi_data data;\r\nint retval;\r\nif (commands->get_battery_life_extender == 0xFFFF)\r\nreturn -ENODEV;\r\nmemset(&data, 0, sizeof(data));\r\ndata.data[0] = 0x80;\r\nretval = sabi_command(samsung, commands->get_battery_life_extender,\r\n&data, &data);\r\nif (retval)\r\nreturn retval;\r\nif (data.data[0] != 0 && data.data[0] != 1)\r\nreturn -ENODEV;\r\nreturn data.data[0];\r\n}\r\nstatic int write_battery_life_extender(struct samsung_laptop *samsung,\r\nint enabled)\r\n{\r\nconst struct sabi_commands *commands = &samsung->config->commands;\r\nstruct sabi_data data;\r\nmemset(&data, 0, sizeof(data));\r\ndata.data[0] = 0x80 | enabled;\r\nreturn sabi_command(samsung, commands->set_battery_life_extender,\r\n&data, NULL);\r\n}\r\nstatic ssize_t get_battery_life_extender(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct samsung_laptop *samsung = dev_get_drvdata(dev);\r\nint ret;\r\nret = read_battery_life_extender(samsung);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn sprintf(buf, "%d\n", ret);\r\n}\r\nstatic ssize_t set_battery_life_extender(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct samsung_laptop *samsung = dev_get_drvdata(dev);\r\nint ret, value;\r\nif (!count || kstrtoint(buf, 0, &value) != 0)\r\nreturn -EINVAL;\r\nret = write_battery_life_extender(samsung, !!value);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn count;\r\n}\r\nstatic int read_usb_charge(struct samsung_laptop *samsung)\r\n{\r\nconst struct sabi_commands *commands = &samsung->config->commands;\r\nstruct sabi_data data;\r\nint retval;\r\nif (commands->get_usb_charge == 0xFFFF)\r\nreturn -ENODEV;\r\nmemset(&data, 0, sizeof(data));\r\ndata.data[0] = 0x80;\r\nretval = sabi_command(samsung, commands->get_usb_charge,\r\n&data, &data);\r\nif (retval)\r\nreturn retval;\r\nif (data.data[0] != 0 && data.data[0] != 1)\r\nreturn -ENODEV;\r\nreturn data.data[0];\r\n}\r\nstatic int write_usb_charge(struct samsung_laptop *samsung,\r\nint enabled)\r\n{\r\nconst struct sabi_commands *commands = &samsung->config->commands;\r\nstruct sabi_data data;\r\nmemset(&data, 0, sizeof(data));\r\ndata.data[0] = 0x80 | enabled;\r\nreturn sabi_command(samsung, commands->set_usb_charge,\r\n&data, NULL);\r\n}\r\nstatic ssize_t get_usb_charge(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct samsung_laptop *samsung = dev_get_drvdata(dev);\r\nint ret;\r\nret = read_usb_charge(samsung);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn sprintf(buf, "%d\n", ret);\r\n}\r\nstatic ssize_t set_usb_charge(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct samsung_laptop *samsung = dev_get_drvdata(dev);\r\nint ret, value;\r\nif (!count || kstrtoint(buf, 0, &value) != 0)\r\nreturn -EINVAL;\r\nret = write_usb_charge(samsung, !!value);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn count;\r\n}\r\nstatic int read_lid_handling(struct samsung_laptop *samsung)\r\n{\r\nconst struct sabi_commands *commands = &samsung->config->commands;\r\nstruct sabi_data data;\r\nint retval;\r\nif (commands->get_lid_handling == 0xFFFF)\r\nreturn -ENODEV;\r\nmemset(&data, 0, sizeof(data));\r\nretval = sabi_command(samsung, commands->get_lid_handling,\r\n&data, &data);\r\nif (retval)\r\nreturn retval;\r\nreturn data.data[0] & 0x1;\r\n}\r\nstatic int write_lid_handling(struct samsung_laptop *samsung,\r\nint enabled)\r\n{\r\nconst struct sabi_commands *commands = &samsung->config->commands;\r\nstruct sabi_data data;\r\nmemset(&data, 0, sizeof(data));\r\ndata.data[0] = 0x80 | enabled;\r\nreturn sabi_command(samsung, commands->set_lid_handling,\r\n&data, NULL);\r\n}\r\nstatic ssize_t get_lid_handling(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct samsung_laptop *samsung = dev_get_drvdata(dev);\r\nint ret;\r\nret = read_lid_handling(samsung);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn sprintf(buf, "%d\n", ret);\r\n}\r\nstatic ssize_t set_lid_handling(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct samsung_laptop *samsung = dev_get_drvdata(dev);\r\nint ret, value;\r\nif (!count || kstrtoint(buf, 0, &value) != 0)\r\nreturn -EINVAL;\r\nret = write_lid_handling(samsung, !!value);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn count;\r\n}\r\nstatic int find_signature(void __iomem *memcheck, const char *testStr)\r\n{\r\nint i = 0;\r\nint loca;\r\nfor (loca = 0; loca < 0xffff; loca++) {\r\nchar temp = readb(memcheck + loca);\r\nif (temp == testStr[i]) {\r\nif (i == strlen(testStr)-1)\r\nbreak;\r\n++i;\r\n} else {\r\ni = 0;\r\n}\r\n}\r\nreturn loca;\r\n}\r\nstatic void samsung_rfkill_exit(struct samsung_laptop *samsung)\r\n{\r\nif (samsung->wlan.rfkill) {\r\nrfkill_unregister(samsung->wlan.rfkill);\r\nrfkill_destroy(samsung->wlan.rfkill);\r\nsamsung->wlan.rfkill = NULL;\r\n}\r\nif (samsung->bluetooth.rfkill) {\r\nrfkill_unregister(samsung->bluetooth.rfkill);\r\nrfkill_destroy(samsung->bluetooth.rfkill);\r\nsamsung->bluetooth.rfkill = NULL;\r\n}\r\n}\r\nstatic int samsung_new_rfkill(struct samsung_laptop *samsung,\r\nstruct samsung_rfkill *arfkill,\r\nconst char *name, enum rfkill_type type,\r\nconst struct rfkill_ops *ops,\r\nint blocked)\r\n{\r\nstruct rfkill **rfkill = &arfkill->rfkill;\r\nint ret;\r\narfkill->type = type;\r\narfkill->samsung = samsung;\r\n*rfkill = rfkill_alloc(name, &samsung->platform_device->dev,\r\ntype, ops, arfkill);\r\nif (!*rfkill)\r\nreturn -EINVAL;\r\nif (blocked != -1)\r\nrfkill_init_sw_state(*rfkill, blocked);\r\nret = rfkill_register(*rfkill);\r\nif (ret) {\r\nrfkill_destroy(*rfkill);\r\n*rfkill = NULL;\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init samsung_rfkill_init_seclinux(struct samsung_laptop *samsung)\r\n{\r\nreturn samsung_new_rfkill(samsung, &samsung->wlan, "samsung-wlan",\r\nRFKILL_TYPE_WLAN, &seclinux_rfkill_ops, -1);\r\n}\r\nstatic int __init samsung_rfkill_init_swsmi(struct samsung_laptop *samsung)\r\n{\r\nstruct sabi_data data;\r\nint ret;\r\nret = swsmi_wireless_status(samsung, &data);\r\nif (ret) {\r\nif (ret == -EINVAL)\r\nret = samsung_rfkill_init_seclinux(samsung);\r\nreturn ret;\r\n}\r\nif (data.data[WL_STATUS_WLAN] != 0x02)\r\nret = samsung_new_rfkill(samsung, &samsung->wlan,\r\n"samsung-wlan",\r\nRFKILL_TYPE_WLAN,\r\n&swsmi_rfkill_ops,\r\n!data.data[WL_STATUS_WLAN]);\r\nif (ret)\r\ngoto exit;\r\nif (data.data[WL_STATUS_BT] != 0x02)\r\nret = samsung_new_rfkill(samsung, &samsung->bluetooth,\r\n"samsung-bluetooth",\r\nRFKILL_TYPE_BLUETOOTH,\r\n&swsmi_rfkill_ops,\r\n!data.data[WL_STATUS_BT]);\r\nif (ret)\r\ngoto exit;\r\nexit:\r\nif (ret)\r\nsamsung_rfkill_exit(samsung);\r\nreturn ret;\r\n}\r\nstatic int __init samsung_rfkill_init(struct samsung_laptop *samsung)\r\n{\r\nif (samsung->config->sabi_version == 2)\r\nreturn samsung_rfkill_init_seclinux(samsung);\r\nif (samsung->config->sabi_version == 3)\r\nreturn samsung_rfkill_init_swsmi(samsung);\r\nreturn 0;\r\n}\r\nstatic void samsung_lid_handling_exit(struct samsung_laptop *samsung)\r\n{\r\nif (samsung->quirks->lid_handling)\r\nwrite_lid_handling(samsung, 0);\r\n}\r\nstatic int __init samsung_lid_handling_init(struct samsung_laptop *samsung)\r\n{\r\nint retval = 0;\r\nif (samsung->quirks->lid_handling)\r\nretval = write_lid_handling(samsung, 1);\r\nreturn retval;\r\n}\r\nstatic int kbd_backlight_enable(struct samsung_laptop *samsung)\r\n{\r\nconst struct sabi_commands *commands = &samsung->config->commands;\r\nstruct sabi_data data;\r\nint retval;\r\nif (commands->kbd_backlight == 0xFFFF)\r\nreturn -ENODEV;\r\nmemset(&data, 0, sizeof(data));\r\ndata.d0 = 0xaabb;\r\nretval = sabi_command(samsung, commands->kbd_backlight,\r\n&data, &data);\r\nif (retval)\r\nreturn retval;\r\nif (data.d0 != 0xccdd)\r\nreturn -ENODEV;\r\nreturn 0;\r\n}\r\nstatic int kbd_backlight_read(struct samsung_laptop *samsung)\r\n{\r\nconst struct sabi_commands *commands = &samsung->config->commands;\r\nstruct sabi_data data;\r\nint retval;\r\nmemset(&data, 0, sizeof(data));\r\ndata.data[0] = 0x81;\r\nretval = sabi_command(samsung, commands->kbd_backlight,\r\n&data, &data);\r\nif (retval)\r\nreturn retval;\r\nreturn data.data[0];\r\n}\r\nstatic int kbd_backlight_write(struct samsung_laptop *samsung, int brightness)\r\n{\r\nconst struct sabi_commands *commands = &samsung->config->commands;\r\nstruct sabi_data data;\r\nmemset(&data, 0, sizeof(data));\r\ndata.d0 = 0x82 | ((brightness & 0xFF) << 8);\r\nreturn sabi_command(samsung, commands->kbd_backlight,\r\n&data, NULL);\r\n}\r\nstatic void kbd_led_update(struct work_struct *work)\r\n{\r\nstruct samsung_laptop *samsung;\r\nsamsung = container_of(work, struct samsung_laptop, kbd_led_work);\r\nkbd_backlight_write(samsung, samsung->kbd_led_wk);\r\n}\r\nstatic void kbd_led_set(struct led_classdev *led_cdev,\r\nenum led_brightness value)\r\n{\r\nstruct samsung_laptop *samsung;\r\nsamsung = container_of(led_cdev, struct samsung_laptop, kbd_led);\r\nif (value > samsung->kbd_led.max_brightness)\r\nvalue = samsung->kbd_led.max_brightness;\r\nelse if (value < 0)\r\nvalue = 0;\r\nsamsung->kbd_led_wk = value;\r\nqueue_work(samsung->led_workqueue, &samsung->kbd_led_work);\r\n}\r\nstatic enum led_brightness kbd_led_get(struct led_classdev *led_cdev)\r\n{\r\nstruct samsung_laptop *samsung;\r\nsamsung = container_of(led_cdev, struct samsung_laptop, kbd_led);\r\nreturn kbd_backlight_read(samsung);\r\n}\r\nstatic void samsung_leds_exit(struct samsung_laptop *samsung)\r\n{\r\nif (!IS_ERR_OR_NULL(samsung->kbd_led.dev))\r\nled_classdev_unregister(&samsung->kbd_led);\r\nif (samsung->led_workqueue)\r\ndestroy_workqueue(samsung->led_workqueue);\r\n}\r\nstatic int __init samsung_leds_init(struct samsung_laptop *samsung)\r\n{\r\nint ret = 0;\r\nsamsung->led_workqueue = create_singlethread_workqueue("led_workqueue");\r\nif (!samsung->led_workqueue)\r\nreturn -ENOMEM;\r\nif (kbd_backlight_enable(samsung) >= 0) {\r\nINIT_WORK(&samsung->kbd_led_work, kbd_led_update);\r\nsamsung->kbd_led.name = "samsung::kbd_backlight";\r\nsamsung->kbd_led.brightness_set = kbd_led_set;\r\nsamsung->kbd_led.brightness_get = kbd_led_get;\r\nsamsung->kbd_led.max_brightness = 8;\r\nif (samsung->quirks->four_kbd_backlight_levels)\r\nsamsung->kbd_led.max_brightness = 4;\r\nret = led_classdev_register(&samsung->platform_device->dev,\r\n&samsung->kbd_led);\r\n}\r\nif (ret)\r\nsamsung_leds_exit(samsung);\r\nreturn ret;\r\n}\r\nstatic void samsung_backlight_exit(struct samsung_laptop *samsung)\r\n{\r\nif (samsung->backlight_device) {\r\nbacklight_device_unregister(samsung->backlight_device);\r\nsamsung->backlight_device = NULL;\r\n}\r\n}\r\nstatic int __init samsung_backlight_init(struct samsung_laptop *samsung)\r\n{\r\nstruct backlight_device *bd;\r\nstruct backlight_properties props;\r\nif (!samsung->handle_backlight)\r\nreturn 0;\r\nmemset(&props, 0, sizeof(struct backlight_properties));\r\nprops.type = BACKLIGHT_PLATFORM;\r\nprops.max_brightness = samsung->config->max_brightness -\r\nsamsung->config->min_brightness;\r\nbd = backlight_device_register("samsung",\r\n&samsung->platform_device->dev,\r\nsamsung, &backlight_ops,\r\n&props);\r\nif (IS_ERR(bd))\r\nreturn PTR_ERR(bd);\r\nsamsung->backlight_device = bd;\r\nsamsung->backlight_device->props.brightness = read_brightness(samsung);\r\nsamsung->backlight_device->props.power = FB_BLANK_UNBLANK;\r\nbacklight_update_status(samsung->backlight_device);\r\nreturn 0;\r\n}\r\nstatic umode_t samsung_sysfs_is_visible(struct kobject *kobj,\r\nstruct attribute *attr, int idx)\r\n{\r\nstruct device *dev = container_of(kobj, struct device, kobj);\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct samsung_laptop *samsung = platform_get_drvdata(pdev);\r\nbool ok = true;\r\nif (attr == &dev_attr_performance_level.attr)\r\nok = !!samsung->config->performance_levels[0].name;\r\nif (attr == &dev_attr_battery_life_extender.attr)\r\nok = !!(read_battery_life_extender(samsung) >= 0);\r\nif (attr == &dev_attr_usb_charge.attr)\r\nok = !!(read_usb_charge(samsung) >= 0);\r\nif (attr == &dev_attr_lid_handling.attr)\r\nok = !!(read_lid_handling(samsung) >= 0);\r\nreturn ok ? attr->mode : 0;\r\n}\r\nstatic void samsung_sysfs_exit(struct samsung_laptop *samsung)\r\n{\r\nstruct platform_device *device = samsung->platform_device;\r\nsysfs_remove_group(&device->dev.kobj, &platform_attribute_group);\r\n}\r\nstatic int __init samsung_sysfs_init(struct samsung_laptop *samsung)\r\n{\r\nstruct platform_device *device = samsung->platform_device;\r\nreturn sysfs_create_group(&device->dev.kobj, &platform_attribute_group);\r\n}\r\nstatic int show_call(struct seq_file *m, void *data)\r\n{\r\nstruct samsung_laptop *samsung = m->private;\r\nstruct sabi_data *sdata = &samsung->debug.data;\r\nint ret;\r\nseq_printf(m, "SABI 0x%04x {0x%08x, 0x%08x, 0x%04x, 0x%02x}\n",\r\nsamsung->debug.command,\r\nsdata->d0, sdata->d1, sdata->d2, sdata->d3);\r\nret = sabi_command(samsung, samsung->debug.command, sdata, sdata);\r\nif (ret) {\r\nseq_printf(m, "SABI command 0x%04x failed\n",\r\nsamsung->debug.command);\r\nreturn ret;\r\n}\r\nseq_printf(m, "SABI {0x%08x, 0x%08x, 0x%04x, 0x%02x}\n",\r\nsdata->d0, sdata->d1, sdata->d2, sdata->d3);\r\nreturn 0;\r\n}\r\nstatic int samsung_debugfs_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, show_call, inode->i_private);\r\n}\r\nstatic void samsung_debugfs_exit(struct samsung_laptop *samsung)\r\n{\r\ndebugfs_remove_recursive(samsung->debug.root);\r\n}\r\nstatic int samsung_debugfs_init(struct samsung_laptop *samsung)\r\n{\r\nstruct dentry *dent;\r\nsamsung->debug.root = debugfs_create_dir("samsung-laptop", NULL);\r\nif (!samsung->debug.root) {\r\npr_err("failed to create debugfs directory");\r\ngoto error_debugfs;\r\n}\r\nsamsung->debug.f0000_wrapper.data = samsung->f0000_segment;\r\nsamsung->debug.f0000_wrapper.size = 0xffff;\r\nsamsung->debug.data_wrapper.data = &samsung->debug.data;\r\nsamsung->debug.data_wrapper.size = sizeof(samsung->debug.data);\r\nsamsung->debug.sdiag_wrapper.data = samsung->sdiag;\r\nsamsung->debug.sdiag_wrapper.size = strlen(samsung->sdiag);\r\ndent = debugfs_create_u16("command", S_IRUGO | S_IWUSR,\r\nsamsung->debug.root, &samsung->debug.command);\r\nif (!dent)\r\ngoto error_debugfs;\r\ndent = debugfs_create_u32("d0", S_IRUGO | S_IWUSR, samsung->debug.root,\r\n&samsung->debug.data.d0);\r\nif (!dent)\r\ngoto error_debugfs;\r\ndent = debugfs_create_u32("d1", S_IRUGO | S_IWUSR, samsung->debug.root,\r\n&samsung->debug.data.d1);\r\nif (!dent)\r\ngoto error_debugfs;\r\ndent = debugfs_create_u16("d2", S_IRUGO | S_IWUSR, samsung->debug.root,\r\n&samsung->debug.data.d2);\r\nif (!dent)\r\ngoto error_debugfs;\r\ndent = debugfs_create_u8("d3", S_IRUGO | S_IWUSR, samsung->debug.root,\r\n&samsung->debug.data.d3);\r\nif (!dent)\r\ngoto error_debugfs;\r\ndent = debugfs_create_blob("data", S_IRUGO | S_IWUSR,\r\nsamsung->debug.root,\r\n&samsung->debug.data_wrapper);\r\nif (!dent)\r\ngoto error_debugfs;\r\ndent = debugfs_create_blob("f0000_segment", S_IRUSR | S_IWUSR,\r\nsamsung->debug.root,\r\n&samsung->debug.f0000_wrapper);\r\nif (!dent)\r\ngoto error_debugfs;\r\ndent = debugfs_create_file("call", S_IFREG | S_IRUGO,\r\nsamsung->debug.root, samsung,\r\n&samsung_laptop_call_io_ops);\r\nif (!dent)\r\ngoto error_debugfs;\r\ndent = debugfs_create_blob("sdiag", S_IRUGO | S_IWUSR,\r\nsamsung->debug.root,\r\n&samsung->debug.sdiag_wrapper);\r\nif (!dent)\r\ngoto error_debugfs;\r\nreturn 0;\r\nerror_debugfs:\r\nsamsung_debugfs_exit(samsung);\r\nreturn -ENOMEM;\r\n}\r\nstatic void samsung_sabi_exit(struct samsung_laptop *samsung)\r\n{\r\nconst struct sabi_config *config = samsung->config;\r\nif (config && config->commands.set_linux != 0xff)\r\nsabi_set_commandb(samsung, config->commands.set_linux, 0x80);\r\nif (samsung->sabi_iface) {\r\niounmap(samsung->sabi_iface);\r\nsamsung->sabi_iface = NULL;\r\n}\r\nif (samsung->f0000_segment) {\r\niounmap(samsung->f0000_segment);\r\nsamsung->f0000_segment = NULL;\r\n}\r\nsamsung->config = NULL;\r\n}\r\nstatic __init void samsung_sabi_infos(struct samsung_laptop *samsung, int loca,\r\nunsigned int ifaceP)\r\n{\r\nconst struct sabi_config *config = samsung->config;\r\nprintk(KERN_DEBUG "This computer supports SABI==%x\n",\r\nloca + 0xf0000 - 6);\r\nprintk(KERN_DEBUG "SABI header:\n");\r\nprintk(KERN_DEBUG " SMI Port Number = 0x%04x\n",\r\nreadw(samsung->sabi + config->header_offsets.port));\r\nprintk(KERN_DEBUG " SMI Interface Function = 0x%02x\n",\r\nreadb(samsung->sabi + config->header_offsets.iface_func));\r\nprintk(KERN_DEBUG " SMI enable memory buffer = 0x%02x\n",\r\nreadb(samsung->sabi + config->header_offsets.en_mem));\r\nprintk(KERN_DEBUG " SMI restore memory buffer = 0x%02x\n",\r\nreadb(samsung->sabi + config->header_offsets.re_mem));\r\nprintk(KERN_DEBUG " SABI data offset = 0x%04x\n",\r\nreadw(samsung->sabi + config->header_offsets.data_offset));\r\nprintk(KERN_DEBUG " SABI data segment = 0x%04x\n",\r\nreadw(samsung->sabi + config->header_offsets.data_segment));\r\nprintk(KERN_DEBUG " SABI pointer = 0x%08x\n", ifaceP);\r\n}\r\nstatic void __init samsung_sabi_diag(struct samsung_laptop *samsung)\r\n{\r\nint loca = find_signature(samsung->f0000_segment, "SDiaG@");\r\nint i;\r\nif (loca == 0xffff)\r\nreturn ;\r\nloca += 1;\r\nfor (i = 0; loca < 0xffff && i < sizeof(samsung->sdiag) - 1; loca++) {\r\nchar temp = readb(samsung->f0000_segment + loca);\r\nif (isalnum(temp) || temp == '/' || temp == '-')\r\nsamsung->sdiag[i++] = temp;\r\nelse\r\nbreak ;\r\n}\r\nif (debug && samsung->sdiag[0])\r\npr_info("sdiag: %s", samsung->sdiag);\r\n}\r\nstatic int __init samsung_sabi_init(struct samsung_laptop *samsung)\r\n{\r\nconst struct sabi_config *config = NULL;\r\nconst struct sabi_commands *commands;\r\nunsigned int ifaceP;\r\nint ret = 0;\r\nint i;\r\nint loca;\r\nsamsung->f0000_segment = ioremap_nocache(0xf0000, 0xffff);\r\nif (!samsung->f0000_segment) {\r\nif (debug || force)\r\npr_err("Can't map the segment at 0xf0000\n");\r\nret = -EINVAL;\r\ngoto exit;\r\n}\r\nsamsung_sabi_diag(samsung);\r\nfor (i = 0; sabi_configs[i].test_string != NULL; ++i) {\r\nsamsung->config = &sabi_configs[i];\r\nloca = find_signature(samsung->f0000_segment,\r\nsamsung->config->test_string);\r\nif (loca != 0xffff)\r\nbreak;\r\n}\r\nif (loca == 0xffff) {\r\nif (debug || force)\r\npr_err("This computer does not support SABI\n");\r\nret = -ENODEV;\r\ngoto exit;\r\n}\r\nconfig = samsung->config;\r\ncommands = &config->commands;\r\nloca += 1;\r\nsamsung->sabi = (samsung->f0000_segment + loca);\r\nifaceP = (readw(samsung->sabi + config->header_offsets.data_segment) & 0x0ffff) << 4;\r\nifaceP += readw(samsung->sabi + config->header_offsets.data_offset) & 0x0ffff;\r\nif (debug)\r\nsamsung_sabi_infos(samsung, loca, ifaceP);\r\nsamsung->sabi_iface = ioremap_nocache(ifaceP, 16);\r\nif (!samsung->sabi_iface) {\r\npr_err("Can't remap %x\n", ifaceP);\r\nret = -EINVAL;\r\ngoto exit;\r\n}\r\nif (commands->set_linux != 0xff) {\r\nint retval = sabi_set_commandb(samsung,\r\ncommands->set_linux, 0x81);\r\nif (retval) {\r\npr_warn("Linux mode was not set!\n");\r\nret = -ENODEV;\r\ngoto exit;\r\n}\r\n}\r\nif (samsung->handle_backlight)\r\ncheck_for_stepping_quirk(samsung);\r\npr_info("detected SABI interface: %s\n",\r\nsamsung->config->test_string);\r\nexit:\r\nif (ret)\r\nsamsung_sabi_exit(samsung);\r\nreturn ret;\r\n}\r\nstatic void samsung_platform_exit(struct samsung_laptop *samsung)\r\n{\r\nif (samsung->platform_device) {\r\nplatform_device_unregister(samsung->platform_device);\r\nsamsung->platform_device = NULL;\r\n}\r\n}\r\nstatic int samsung_pm_notification(struct notifier_block *nb,\r\nunsigned long val, void *ptr)\r\n{\r\nstruct samsung_laptop *samsung;\r\nsamsung = container_of(nb, struct samsung_laptop, pm_nb);\r\nif (val == PM_POST_HIBERNATION &&\r\nsamsung->quirks->enable_kbd_backlight)\r\nkbd_backlight_enable(samsung);\r\nif (val == PM_POST_HIBERNATION && samsung->quirks->lid_handling)\r\nwrite_lid_handling(samsung, 1);\r\nreturn 0;\r\n}\r\nstatic int __init samsung_platform_init(struct samsung_laptop *samsung)\r\n{\r\nstruct platform_device *pdev;\r\npdev = platform_device_register_simple("samsung", -1, NULL, 0);\r\nif (IS_ERR(pdev))\r\nreturn PTR_ERR(pdev);\r\nsamsung->platform_device = pdev;\r\nplatform_set_drvdata(samsung->platform_device, samsung);\r\nreturn 0;\r\n}\r\nstatic int __init samsung_dmi_matched(const struct dmi_system_id *d)\r\n{\r\nquirks = d->driver_data;\r\nreturn 0;\r\n}\r\nstatic int __init samsung_init(void)\r\n{\r\nstruct samsung_laptop *samsung;\r\nint ret;\r\nif (efi_enabled(EFI_BOOT))\r\nreturn -ENODEV;\r\nquirks = &samsung_unknown;\r\nif (!force && !dmi_check_system(samsung_dmi_table))\r\nreturn -ENODEV;\r\nsamsung = kzalloc(sizeof(*samsung), GFP_KERNEL);\r\nif (!samsung)\r\nreturn -ENOMEM;\r\nmutex_init(&samsung->sabi_mutex);\r\nsamsung->handle_backlight = true;\r\nsamsung->quirks = quirks;\r\n#ifdef CONFIG_ACPI\r\nif (samsung->quirks->broken_acpi_video)\r\nacpi_video_dmi_promote_vendor();\r\nif (acpi_video_backlight_support()) {\r\nsamsung->handle_backlight = false;\r\n} else if (samsung->quirks->broken_acpi_video) {\r\npr_info("Disabling ACPI video driver\n");\r\nacpi_video_unregister();\r\n}\r\nif (samsung->quirks->use_native_backlight) {\r\npr_info("Using native backlight driver\n");\r\nacpi_video_dmi_promote_vendor();\r\nacpi_video_unregister();\r\nsamsung->handle_backlight = false;\r\n}\r\n#endif\r\nret = samsung_platform_init(samsung);\r\nif (ret)\r\ngoto error_platform;\r\nret = samsung_sabi_init(samsung);\r\nif (ret)\r\ngoto error_sabi;\r\n#ifdef CONFIG_ACPI\r\nif (acpi_video_backlight_support())\r\npr_info("Backlight controlled by ACPI video driver\n");\r\n#endif\r\nret = samsung_sysfs_init(samsung);\r\nif (ret)\r\ngoto error_sysfs;\r\nret = samsung_backlight_init(samsung);\r\nif (ret)\r\ngoto error_backlight;\r\nret = samsung_rfkill_init(samsung);\r\nif (ret)\r\ngoto error_rfkill;\r\nret = samsung_leds_init(samsung);\r\nif (ret)\r\ngoto error_leds;\r\nret = samsung_lid_handling_init(samsung);\r\nif (ret)\r\ngoto error_lid_handling;\r\nret = samsung_debugfs_init(samsung);\r\nif (ret)\r\ngoto error_debugfs;\r\nsamsung->pm_nb.notifier_call = samsung_pm_notification;\r\nregister_pm_notifier(&samsung->pm_nb);\r\nsamsung_platform_device = samsung->platform_device;\r\nreturn ret;\r\nerror_debugfs:\r\nsamsung_lid_handling_exit(samsung);\r\nerror_lid_handling:\r\nsamsung_leds_exit(samsung);\r\nerror_leds:\r\nsamsung_rfkill_exit(samsung);\r\nerror_rfkill:\r\nsamsung_backlight_exit(samsung);\r\nerror_backlight:\r\nsamsung_sysfs_exit(samsung);\r\nerror_sysfs:\r\nsamsung_sabi_exit(samsung);\r\nerror_sabi:\r\nsamsung_platform_exit(samsung);\r\nerror_platform:\r\nkfree(samsung);\r\nreturn ret;\r\n}\r\nstatic void __exit samsung_exit(void)\r\n{\r\nstruct samsung_laptop *samsung;\r\nsamsung = platform_get_drvdata(samsung_platform_device);\r\nunregister_pm_notifier(&samsung->pm_nb);\r\nsamsung_debugfs_exit(samsung);\r\nsamsung_lid_handling_exit(samsung);\r\nsamsung_leds_exit(samsung);\r\nsamsung_rfkill_exit(samsung);\r\nsamsung_backlight_exit(samsung);\r\nsamsung_sysfs_exit(samsung);\r\nsamsung_sabi_exit(samsung);\r\nsamsung_platform_exit(samsung);\r\nkfree(samsung);\r\nsamsung_platform_device = NULL;\r\n}
