static inline struct s3c_hsotg_req *our_req(struct usb_request *req)\r\n{\r\nreturn container_of(req, struct s3c_hsotg_req, req);\r\n}\r\nstatic inline struct s3c_hsotg_ep *our_ep(struct usb_ep *ep)\r\n{\r\nreturn container_of(ep, struct s3c_hsotg_ep, ep);\r\n}\r\nstatic inline struct dwc2_hsotg *to_hsotg(struct usb_gadget *gadget)\r\n{\r\nreturn container_of(gadget, struct dwc2_hsotg, gadget);\r\n}\r\nstatic inline void __orr32(void __iomem *ptr, u32 val)\r\n{\r\nwritel(readl(ptr) | val, ptr);\r\n}\r\nstatic inline void __bic32(void __iomem *ptr, u32 val)\r\n{\r\nwritel(readl(ptr) & ~val, ptr);\r\n}\r\nstatic inline struct s3c_hsotg_ep *index_to_ep(struct dwc2_hsotg *hsotg,\r\nu32 ep_index, u32 dir_in)\r\n{\r\nif (dir_in)\r\nreturn hsotg->eps_in[ep_index];\r\nelse\r\nreturn hsotg->eps_out[ep_index];\r\n}\r\nstatic inline bool using_dma(struct dwc2_hsotg *hsotg)\r\n{\r\nreturn hsotg->g_using_dma;\r\n}\r\nstatic void s3c_hsotg_en_gsint(struct dwc2_hsotg *hsotg, u32 ints)\r\n{\r\nu32 gsintmsk = readl(hsotg->regs + GINTMSK);\r\nu32 new_gsintmsk;\r\nnew_gsintmsk = gsintmsk | ints;\r\nif (new_gsintmsk != gsintmsk) {\r\ndev_dbg(hsotg->dev, "gsintmsk now 0x%08x\n", new_gsintmsk);\r\nwritel(new_gsintmsk, hsotg->regs + GINTMSK);\r\n}\r\n}\r\nstatic void s3c_hsotg_disable_gsint(struct dwc2_hsotg *hsotg, u32 ints)\r\n{\r\nu32 gsintmsk = readl(hsotg->regs + GINTMSK);\r\nu32 new_gsintmsk;\r\nnew_gsintmsk = gsintmsk & ~ints;\r\nif (new_gsintmsk != gsintmsk)\r\nwritel(new_gsintmsk, hsotg->regs + GINTMSK);\r\n}\r\nstatic void s3c_hsotg_ctrl_epint(struct dwc2_hsotg *hsotg,\r\nunsigned int ep, unsigned int dir_in,\r\nunsigned int en)\r\n{\r\nunsigned long flags;\r\nu32 bit = 1 << ep;\r\nu32 daint;\r\nif (!dir_in)\r\nbit <<= 16;\r\nlocal_irq_save(flags);\r\ndaint = readl(hsotg->regs + DAINTMSK);\r\nif (en)\r\ndaint |= bit;\r\nelse\r\ndaint &= ~bit;\r\nwritel(daint, hsotg->regs + DAINTMSK);\r\nlocal_irq_restore(flags);\r\n}\r\nstatic void s3c_hsotg_init_fifo(struct dwc2_hsotg *hsotg)\r\n{\r\nunsigned int ep;\r\nunsigned int addr;\r\nint timeout;\r\nu32 val;\r\nWARN_ON(hsotg->fifo_map);\r\nhsotg->fifo_map = 0;\r\nwritel(hsotg->g_rx_fifo_sz, hsotg->regs + GRXFSIZ);\r\nwritel((hsotg->g_rx_fifo_sz << FIFOSIZE_STARTADDR_SHIFT) |\r\n(hsotg->g_np_g_tx_fifo_sz << FIFOSIZE_DEPTH_SHIFT),\r\nhsotg->regs + GNPTXFSIZ);\r\naddr = hsotg->g_rx_fifo_sz + hsotg->g_np_g_tx_fifo_sz;\r\nfor (ep = 1; ep < MAX_EPS_CHANNELS; ep++) {\r\nif (!hsotg->g_tx_fifo_sz[ep])\r\ncontinue;\r\nval = addr;\r\nval |= hsotg->g_tx_fifo_sz[ep] << FIFOSIZE_DEPTH_SHIFT;\r\nWARN_ONCE(addr + hsotg->g_tx_fifo_sz[ep] > hsotg->fifo_mem,\r\n"insufficient fifo memory");\r\naddr += hsotg->g_tx_fifo_sz[ep];\r\nwritel(val, hsotg->regs + DPTXFSIZN(ep));\r\n}\r\nwritel(GRSTCTL_TXFNUM(0x10) | GRSTCTL_TXFFLSH |\r\nGRSTCTL_RXFFLSH, hsotg->regs + GRSTCTL);\r\ntimeout = 100;\r\nwhile (1) {\r\nval = readl(hsotg->regs + GRSTCTL);\r\nif ((val & (GRSTCTL_TXFFLSH | GRSTCTL_RXFFLSH)) == 0)\r\nbreak;\r\nif (--timeout == 0) {\r\ndev_err(hsotg->dev,\r\n"%s: timeout flushing fifos (GRSTCTL=%08x)\n",\r\n__func__, val);\r\nbreak;\r\n}\r\nudelay(1);\r\n}\r\ndev_dbg(hsotg->dev, "FIFOs reset, timeout at %d\n", timeout);\r\n}\r\nstatic struct usb_request *s3c_hsotg_ep_alloc_request(struct usb_ep *ep,\r\ngfp_t flags)\r\n{\r\nstruct s3c_hsotg_req *req;\r\nreq = kzalloc(sizeof(struct s3c_hsotg_req), flags);\r\nif (!req)\r\nreturn NULL;\r\nINIT_LIST_HEAD(&req->queue);\r\nreturn &req->req;\r\n}\r\nstatic inline int is_ep_periodic(struct s3c_hsotg_ep *hs_ep)\r\n{\r\nreturn hs_ep->periodic;\r\n}\r\nstatic void s3c_hsotg_unmap_dma(struct dwc2_hsotg *hsotg,\r\nstruct s3c_hsotg_ep *hs_ep,\r\nstruct s3c_hsotg_req *hs_req)\r\n{\r\nstruct usb_request *req = &hs_req->req;\r\nif (hs_req->req.length == 0)\r\nreturn;\r\nusb_gadget_unmap_request(&hsotg->gadget, req, hs_ep->dir_in);\r\n}\r\nstatic int s3c_hsotg_write_fifo(struct dwc2_hsotg *hsotg,\r\nstruct s3c_hsotg_ep *hs_ep,\r\nstruct s3c_hsotg_req *hs_req)\r\n{\r\nbool periodic = is_ep_periodic(hs_ep);\r\nu32 gnptxsts = readl(hsotg->regs + GNPTXSTS);\r\nint buf_pos = hs_req->req.actual;\r\nint to_write = hs_ep->size_loaded;\r\nvoid *data;\r\nint can_write;\r\nint pkt_round;\r\nint max_transfer;\r\nto_write -= (buf_pos - hs_ep->last_load);\r\nif (to_write == 0)\r\nreturn 0;\r\nif (periodic && !hsotg->dedicated_fifos) {\r\nu32 epsize = readl(hsotg->regs + DIEPTSIZ(hs_ep->index));\r\nint size_left;\r\nint size_done;\r\nsize_left = DXEPTSIZ_XFERSIZE_GET(epsize);\r\nif (hs_ep->fifo_load != 0) {\r\ns3c_hsotg_en_gsint(hsotg, GINTSTS_PTXFEMP);\r\nreturn -ENOSPC;\r\n}\r\ndev_dbg(hsotg->dev, "%s: left=%d, load=%d, fifo=%d, size %d\n",\r\n__func__, size_left,\r\nhs_ep->size_loaded, hs_ep->fifo_load, hs_ep->fifo_size);\r\nsize_done = hs_ep->size_loaded - size_left;\r\ncan_write = hs_ep->fifo_load - size_done;\r\ndev_dbg(hsotg->dev, "%s: => can_write1=%d\n",\r\n__func__, can_write);\r\ncan_write = hs_ep->fifo_size - can_write;\r\ndev_dbg(hsotg->dev, "%s: => can_write2=%d\n",\r\n__func__, can_write);\r\nif (can_write <= 0) {\r\ns3c_hsotg_en_gsint(hsotg, GINTSTS_PTXFEMP);\r\nreturn -ENOSPC;\r\n}\r\n} else if (hsotg->dedicated_fifos && hs_ep->index != 0) {\r\ncan_write = readl(hsotg->regs + DTXFSTS(hs_ep->index));\r\ncan_write &= 0xffff;\r\ncan_write *= 4;\r\n} else {\r\nif (GNPTXSTS_NP_TXQ_SPC_AVAIL_GET(gnptxsts) == 0) {\r\ndev_dbg(hsotg->dev,\r\n"%s: no queue slots available (0x%08x)\n",\r\n__func__, gnptxsts);\r\ns3c_hsotg_en_gsint(hsotg, GINTSTS_NPTXFEMP);\r\nreturn -ENOSPC;\r\n}\r\ncan_write = GNPTXSTS_NP_TXF_SPC_AVAIL_GET(gnptxsts);\r\ncan_write *= 4;\r\n}\r\nmax_transfer = hs_ep->ep.maxpacket * hs_ep->mc;\r\ndev_dbg(hsotg->dev, "%s: GNPTXSTS=%08x, can=%d, to=%d, max_transfer %d\n",\r\n__func__, gnptxsts, can_write, to_write, max_transfer);\r\nif (can_write > 512 && !periodic)\r\ncan_write = 512;\r\nif (to_write > max_transfer) {\r\nto_write = max_transfer;\r\nif (!hsotg->dedicated_fifos)\r\ns3c_hsotg_en_gsint(hsotg,\r\nperiodic ? GINTSTS_PTXFEMP :\r\nGINTSTS_NPTXFEMP);\r\n}\r\nif (to_write > can_write) {\r\nto_write = can_write;\r\npkt_round = to_write % max_transfer;\r\nif (pkt_round)\r\nto_write -= pkt_round;\r\nif (!hsotg->dedicated_fifos)\r\ns3c_hsotg_en_gsint(hsotg,\r\nperiodic ? GINTSTS_PTXFEMP :\r\nGINTSTS_NPTXFEMP);\r\n}\r\ndev_dbg(hsotg->dev, "write %d/%d, can_write %d, done %d\n",\r\nto_write, hs_req->req.length, can_write, buf_pos);\r\nif (to_write <= 0)\r\nreturn -ENOSPC;\r\nhs_req->req.actual = buf_pos + to_write;\r\nhs_ep->total_data += to_write;\r\nif (periodic)\r\nhs_ep->fifo_load += to_write;\r\nto_write = DIV_ROUND_UP(to_write, 4);\r\ndata = hs_req->req.buf + buf_pos;\r\niowrite32_rep(hsotg->regs + EPFIFO(hs_ep->index), data, to_write);\r\nreturn (to_write >= can_write) ? -ENOSPC : 0;\r\n}\r\nstatic unsigned get_ep_limit(struct s3c_hsotg_ep *hs_ep)\r\n{\r\nint index = hs_ep->index;\r\nunsigned maxsize;\r\nunsigned maxpkt;\r\nif (index != 0) {\r\nmaxsize = DXEPTSIZ_XFERSIZE_LIMIT + 1;\r\nmaxpkt = DXEPTSIZ_PKTCNT_LIMIT + 1;\r\n} else {\r\nmaxsize = 64+64;\r\nif (hs_ep->dir_in)\r\nmaxpkt = DIEPTSIZ0_PKTCNT_LIMIT + 1;\r\nelse\r\nmaxpkt = 2;\r\n}\r\nmaxpkt--;\r\nmaxsize--;\r\nif ((maxpkt * hs_ep->ep.maxpacket) < maxsize)\r\nmaxsize = maxpkt * hs_ep->ep.maxpacket;\r\nreturn maxsize;\r\n}\r\nstatic void s3c_hsotg_start_req(struct dwc2_hsotg *hsotg,\r\nstruct s3c_hsotg_ep *hs_ep,\r\nstruct s3c_hsotg_req *hs_req,\r\nbool continuing)\r\n{\r\nstruct usb_request *ureq = &hs_req->req;\r\nint index = hs_ep->index;\r\nint dir_in = hs_ep->dir_in;\r\nu32 epctrl_reg;\r\nu32 epsize_reg;\r\nu32 epsize;\r\nu32 ctrl;\r\nunsigned length;\r\nunsigned packets;\r\nunsigned maxreq;\r\nif (index != 0) {\r\nif (hs_ep->req && !continuing) {\r\ndev_err(hsotg->dev, "%s: active request\n", __func__);\r\nWARN_ON(1);\r\nreturn;\r\n} else if (hs_ep->req != hs_req && continuing) {\r\ndev_err(hsotg->dev,\r\n"%s: continue different req\n", __func__);\r\nWARN_ON(1);\r\nreturn;\r\n}\r\n}\r\nepctrl_reg = dir_in ? DIEPCTL(index) : DOEPCTL(index);\r\nepsize_reg = dir_in ? DIEPTSIZ(index) : DOEPTSIZ(index);\r\ndev_dbg(hsotg->dev, "%s: DxEPCTL=0x%08x, ep %d, dir %s\n",\r\n__func__, readl(hsotg->regs + epctrl_reg), index,\r\nhs_ep->dir_in ? "in" : "out");\r\nctrl = readl(hsotg->regs + epctrl_reg);\r\nif (ctrl & DXEPCTL_STALL) {\r\ndev_warn(hsotg->dev, "%s: ep%d is stalled\n", __func__, index);\r\nreturn;\r\n}\r\nlength = ureq->length - ureq->actual;\r\ndev_dbg(hsotg->dev, "ureq->length:%d ureq->actual:%d\n",\r\nureq->length, ureq->actual);\r\nmaxreq = get_ep_limit(hs_ep);\r\nif (length > maxreq) {\r\nint round = maxreq % hs_ep->ep.maxpacket;\r\ndev_dbg(hsotg->dev, "%s: length %d, max-req %d, r %d\n",\r\n__func__, length, maxreq, round);\r\nif (round)\r\nmaxreq -= round;\r\nlength = maxreq;\r\n}\r\nif (length)\r\npackets = DIV_ROUND_UP(length, hs_ep->ep.maxpacket);\r\nelse\r\npackets = 1;\r\nif (hs_ep->isochronous && length > (hs_ep->mc * hs_ep->ep.maxpacket)) {\r\ndev_err(hsotg->dev, "req length > maxpacket*mc\n");\r\nreturn;\r\n}\r\nif (dir_in && index != 0)\r\nif (hs_ep->isochronous)\r\nepsize = DXEPTSIZ_MC(packets);\r\nelse\r\nepsize = DXEPTSIZ_MC(1);\r\nelse\r\nepsize = 0;\r\nif (dir_in && ureq->zero && !continuing) {\r\nif ((ureq->length >= hs_ep->ep.maxpacket) &&\r\n!(ureq->length % hs_ep->ep.maxpacket))\r\nhs_ep->send_zlp = 1;\r\n}\r\nepsize |= DXEPTSIZ_PKTCNT(packets);\r\nepsize |= DXEPTSIZ_XFERSIZE(length);\r\ndev_dbg(hsotg->dev, "%s: %d@%d/%d, 0x%08x => 0x%08x\n",\r\n__func__, packets, length, ureq->length, epsize, epsize_reg);\r\nhs_ep->req = hs_req;\r\nwritel(epsize, hsotg->regs + epsize_reg);\r\nif (using_dma(hsotg) && !continuing) {\r\nunsigned int dma_reg;\r\ndma_reg = dir_in ? DIEPDMA(index) : DOEPDMA(index);\r\nwritel(ureq->dma, hsotg->regs + dma_reg);\r\ndev_dbg(hsotg->dev, "%s: %pad => 0x%08x\n",\r\n__func__, &ureq->dma, dma_reg);\r\n}\r\nctrl |= DXEPCTL_EPENA;\r\nctrl |= DXEPCTL_USBACTEP;\r\ndev_dbg(hsotg->dev, "ep0 state:%d\n", hsotg->ep0_state);\r\nif (!(index == 0 && hsotg->ep0_state == DWC2_EP0_SETUP))\r\nctrl |= DXEPCTL_CNAK;\r\ndev_dbg(hsotg->dev, "%s: DxEPCTL=0x%08x\n", __func__, ctrl);\r\nwritel(ctrl, hsotg->regs + epctrl_reg);\r\nhs_ep->size_loaded = length;\r\nhs_ep->last_load = ureq->actual;\r\nif (dir_in && !using_dma(hsotg)) {\r\nhs_ep->fifo_load = 0;\r\ns3c_hsotg_write_fifo(hsotg, hs_ep, hs_req);\r\n}\r\nif (dir_in)\r\nwritel(DIEPMSK_INTKNTXFEMPMSK,\r\nhsotg->regs + DIEPINT(index));\r\nif (!(readl(hsotg->regs + epctrl_reg) & DXEPCTL_EPENA))\r\ndev_dbg(hsotg->dev,\r\n"ep%d: failed to become enabled (DXEPCTL=0x%08x)?\n",\r\nindex, readl(hsotg->regs + epctrl_reg));\r\ndev_dbg(hsotg->dev, "%s: DXEPCTL=0x%08x\n",\r\n__func__, readl(hsotg->regs + epctrl_reg));\r\ns3c_hsotg_ctrl_epint(hsotg, hs_ep->index, hs_ep->dir_in, 1);\r\n}\r\nstatic int s3c_hsotg_map_dma(struct dwc2_hsotg *hsotg,\r\nstruct s3c_hsotg_ep *hs_ep,\r\nstruct usb_request *req)\r\n{\r\nstruct s3c_hsotg_req *hs_req = our_req(req);\r\nint ret;\r\nif (hs_req->req.length == 0)\r\nreturn 0;\r\nret = usb_gadget_map_request(&hsotg->gadget, req, hs_ep->dir_in);\r\nif (ret)\r\ngoto dma_error;\r\nreturn 0;\r\ndma_error:\r\ndev_err(hsotg->dev, "%s: failed to map buffer %p, %d bytes\n",\r\n__func__, req->buf, req->length);\r\nreturn -EIO;\r\n}\r\nstatic int s3c_hsotg_handle_unaligned_buf_start(struct dwc2_hsotg *hsotg,\r\nstruct s3c_hsotg_ep *hs_ep, struct s3c_hsotg_req *hs_req)\r\n{\r\nvoid *req_buf = hs_req->req.buf;\r\nif (!using_dma(hsotg) || !((long)req_buf & 3))\r\nreturn 0;\r\nWARN_ON(hs_req->saved_req_buf);\r\ndev_dbg(hsotg->dev, "%s: %s: buf=%p length=%d\n", __func__,\r\nhs_ep->ep.name, req_buf, hs_req->req.length);\r\nhs_req->req.buf = kmalloc(hs_req->req.length, GFP_ATOMIC);\r\nif (!hs_req->req.buf) {\r\nhs_req->req.buf = req_buf;\r\ndev_err(hsotg->dev,\r\n"%s: unable to allocate memory for bounce buffer\n",\r\n__func__);\r\nreturn -ENOMEM;\r\n}\r\nhs_req->saved_req_buf = req_buf;\r\nif (hs_ep->dir_in)\r\nmemcpy(hs_req->req.buf, req_buf, hs_req->req.length);\r\nreturn 0;\r\n}\r\nstatic void s3c_hsotg_handle_unaligned_buf_complete(struct dwc2_hsotg *hsotg,\r\nstruct s3c_hsotg_ep *hs_ep, struct s3c_hsotg_req *hs_req)\r\n{\r\nif (!using_dma(hsotg) || !hs_req->saved_req_buf)\r\nreturn;\r\ndev_dbg(hsotg->dev, "%s: %s: status=%d actual-length=%d\n", __func__,\r\nhs_ep->ep.name, hs_req->req.status, hs_req->req.actual);\r\nif (!hs_ep->dir_in && !hs_req->req.status)\r\nmemcpy(hs_req->saved_req_buf, hs_req->req.buf,\r\nhs_req->req.actual);\r\nkfree(hs_req->req.buf);\r\nhs_req->req.buf = hs_req->saved_req_buf;\r\nhs_req->saved_req_buf = NULL;\r\n}\r\nstatic int s3c_hsotg_ep_queue(struct usb_ep *ep, struct usb_request *req,\r\ngfp_t gfp_flags)\r\n{\r\nstruct s3c_hsotg_req *hs_req = our_req(req);\r\nstruct s3c_hsotg_ep *hs_ep = our_ep(ep);\r\nstruct dwc2_hsotg *hs = hs_ep->parent;\r\nbool first;\r\nint ret;\r\ndev_dbg(hs->dev, "%s: req %p: %d@%p, noi=%d, zero=%d, snok=%d\n",\r\nep->name, req, req->length, req->buf, req->no_interrupt,\r\nreq->zero, req->short_not_ok);\r\nINIT_LIST_HEAD(&hs_req->queue);\r\nreq->actual = 0;\r\nreq->status = -EINPROGRESS;\r\nret = s3c_hsotg_handle_unaligned_buf_start(hs, hs_ep, hs_req);\r\nif (ret)\r\nreturn ret;\r\nif (using_dma(hs)) {\r\nret = s3c_hsotg_map_dma(hs, hs_ep, req);\r\nif (ret)\r\nreturn ret;\r\n}\r\nfirst = list_empty(&hs_ep->queue);\r\nlist_add_tail(&hs_req->queue, &hs_ep->queue);\r\nif (first)\r\ns3c_hsotg_start_req(hs, hs_ep, hs_req, false);\r\nreturn 0;\r\n}\r\nstatic int s3c_hsotg_ep_queue_lock(struct usb_ep *ep, struct usb_request *req,\r\ngfp_t gfp_flags)\r\n{\r\nstruct s3c_hsotg_ep *hs_ep = our_ep(ep);\r\nstruct dwc2_hsotg *hs = hs_ep->parent;\r\nunsigned long flags = 0;\r\nint ret = 0;\r\nspin_lock_irqsave(&hs->lock, flags);\r\nret = s3c_hsotg_ep_queue(ep, req, gfp_flags);\r\nspin_unlock_irqrestore(&hs->lock, flags);\r\nreturn ret;\r\n}\r\nstatic void s3c_hsotg_ep_free_request(struct usb_ep *ep,\r\nstruct usb_request *req)\r\n{\r\nstruct s3c_hsotg_req *hs_req = our_req(req);\r\nkfree(hs_req);\r\n}\r\nstatic void s3c_hsotg_complete_oursetup(struct usb_ep *ep,\r\nstruct usb_request *req)\r\n{\r\nstruct s3c_hsotg_ep *hs_ep = our_ep(ep);\r\nstruct dwc2_hsotg *hsotg = hs_ep->parent;\r\ndev_dbg(hsotg->dev, "%s: ep %p, req %p\n", __func__, ep, req);\r\ns3c_hsotg_ep_free_request(ep, req);\r\n}\r\nstatic struct s3c_hsotg_ep *ep_from_windex(struct dwc2_hsotg *hsotg,\r\nu32 windex)\r\n{\r\nstruct s3c_hsotg_ep *ep;\r\nint dir = (windex & USB_DIR_IN) ? 1 : 0;\r\nint idx = windex & 0x7F;\r\nif (windex >= 0x100)\r\nreturn NULL;\r\nif (idx > hsotg->num_of_eps)\r\nreturn NULL;\r\nep = index_to_ep(hsotg, idx, dir);\r\nif (idx && ep->dir_in != dir)\r\nreturn NULL;\r\nreturn ep;\r\n}\r\nstatic int s3c_hsotg_set_test_mode(struct dwc2_hsotg *hsotg, int testmode)\r\n{\r\nint dctl = readl(hsotg->regs + DCTL);\r\ndctl &= ~DCTL_TSTCTL_MASK;\r\nswitch (testmode) {\r\ncase TEST_J:\r\ncase TEST_K:\r\ncase TEST_SE0_NAK:\r\ncase TEST_PACKET:\r\ncase TEST_FORCE_EN:\r\ndctl |= testmode << DCTL_TSTCTL_SHIFT;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nwritel(dctl, hsotg->regs + DCTL);\r\nreturn 0;\r\n}\r\nstatic int s3c_hsotg_send_reply(struct dwc2_hsotg *hsotg,\r\nstruct s3c_hsotg_ep *ep,\r\nvoid *buff,\r\nint length)\r\n{\r\nstruct usb_request *req;\r\nint ret;\r\ndev_dbg(hsotg->dev, "%s: buff %p, len %d\n", __func__, buff, length);\r\nreq = s3c_hsotg_ep_alloc_request(&ep->ep, GFP_ATOMIC);\r\nhsotg->ep0_reply = req;\r\nif (!req) {\r\ndev_warn(hsotg->dev, "%s: cannot alloc req\n", __func__);\r\nreturn -ENOMEM;\r\n}\r\nreq->buf = hsotg->ep0_buff;\r\nreq->length = length;\r\nreq->zero = 0;\r\nreq->complete = s3c_hsotg_complete_oursetup;\r\nif (length)\r\nmemcpy(req->buf, buff, length);\r\nret = s3c_hsotg_ep_queue(&ep->ep, req, GFP_ATOMIC);\r\nif (ret) {\r\ndev_warn(hsotg->dev, "%s: cannot queue req\n", __func__);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int s3c_hsotg_process_req_status(struct dwc2_hsotg *hsotg,\r\nstruct usb_ctrlrequest *ctrl)\r\n{\r\nstruct s3c_hsotg_ep *ep0 = hsotg->eps_out[0];\r\nstruct s3c_hsotg_ep *ep;\r\n__le16 reply;\r\nint ret;\r\ndev_dbg(hsotg->dev, "%s: USB_REQ_GET_STATUS\n", __func__);\r\nif (!ep0->dir_in) {\r\ndev_warn(hsotg->dev, "%s: direction out?\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nswitch (ctrl->bRequestType & USB_RECIP_MASK) {\r\ncase USB_RECIP_DEVICE:\r\nreply = cpu_to_le16(0);\r\nbreak;\r\ncase USB_RECIP_INTERFACE:\r\nreply = cpu_to_le16(0);\r\nbreak;\r\ncase USB_RECIP_ENDPOINT:\r\nep = ep_from_windex(hsotg, le16_to_cpu(ctrl->wIndex));\r\nif (!ep)\r\nreturn -ENOENT;\r\nreply = cpu_to_le16(ep->halted ? 1 : 0);\r\nbreak;\r\ndefault:\r\nreturn 0;\r\n}\r\nif (le16_to_cpu(ctrl->wLength) != 2)\r\nreturn -EINVAL;\r\nret = s3c_hsotg_send_reply(hsotg, ep0, &reply, 2);\r\nif (ret) {\r\ndev_err(hsotg->dev, "%s: failed to send reply\n", __func__);\r\nreturn ret;\r\n}\r\nreturn 1;\r\n}\r\nstatic struct s3c_hsotg_req *get_ep_head(struct s3c_hsotg_ep *hs_ep)\r\n{\r\nif (list_empty(&hs_ep->queue))\r\nreturn NULL;\r\nreturn list_first_entry(&hs_ep->queue, struct s3c_hsotg_req, queue);\r\n}\r\nstatic int s3c_hsotg_process_req_feature(struct dwc2_hsotg *hsotg,\r\nstruct usb_ctrlrequest *ctrl)\r\n{\r\nstruct s3c_hsotg_ep *ep0 = hsotg->eps_out[0];\r\nstruct s3c_hsotg_req *hs_req;\r\nbool restart;\r\nbool set = (ctrl->bRequest == USB_REQ_SET_FEATURE);\r\nstruct s3c_hsotg_ep *ep;\r\nint ret;\r\nbool halted;\r\nu32 recip;\r\nu32 wValue;\r\nu32 wIndex;\r\ndev_dbg(hsotg->dev, "%s: %s_FEATURE\n",\r\n__func__, set ? "SET" : "CLEAR");\r\nwValue = le16_to_cpu(ctrl->wValue);\r\nwIndex = le16_to_cpu(ctrl->wIndex);\r\nrecip = ctrl->bRequestType & USB_RECIP_MASK;\r\nswitch (recip) {\r\ncase USB_RECIP_DEVICE:\r\nswitch (wValue) {\r\ncase USB_DEVICE_TEST_MODE:\r\nif ((wIndex & 0xff) != 0)\r\nreturn -EINVAL;\r\nif (!set)\r\nreturn -EINVAL;\r\nhsotg->test_mode = wIndex >> 8;\r\nret = s3c_hsotg_send_reply(hsotg, ep0, NULL, 0);\r\nif (ret) {\r\ndev_err(hsotg->dev,\r\n"%s: failed to send reply\n", __func__);\r\nreturn ret;\r\n}\r\nbreak;\r\ndefault:\r\nreturn -ENOENT;\r\n}\r\nbreak;\r\ncase USB_RECIP_ENDPOINT:\r\nep = ep_from_windex(hsotg, wIndex);\r\nif (!ep) {\r\ndev_dbg(hsotg->dev, "%s: no endpoint for 0x%04x\n",\r\n__func__, wIndex);\r\nreturn -ENOENT;\r\n}\r\nswitch (wValue) {\r\ncase USB_ENDPOINT_HALT:\r\nhalted = ep->halted;\r\ns3c_hsotg_ep_sethalt(&ep->ep, set);\r\nret = s3c_hsotg_send_reply(hsotg, ep0, NULL, 0);\r\nif (ret) {\r\ndev_err(hsotg->dev,\r\n"%s: failed to send reply\n", __func__);\r\nreturn ret;\r\n}\r\nif (!set && halted) {\r\nif (ep->req) {\r\nhs_req = ep->req;\r\nep->req = NULL;\r\nlist_del_init(&hs_req->queue);\r\nif (hs_req->req.complete) {\r\nspin_unlock(&hsotg->lock);\r\nusb_gadget_giveback_request(\r\n&ep->ep, &hs_req->req);\r\nspin_lock(&hsotg->lock);\r\n}\r\n}\r\nif (!ep->req) {\r\nrestart = !list_empty(&ep->queue);\r\nif (restart) {\r\nhs_req = get_ep_head(ep);\r\ns3c_hsotg_start_req(hsotg, ep,\r\nhs_req, false);\r\n}\r\n}\r\n}\r\nbreak;\r\ndefault:\r\nreturn -ENOENT;\r\n}\r\nbreak;\r\ndefault:\r\nreturn -ENOENT;\r\n}\r\nreturn 1;\r\n}\r\nstatic void s3c_hsotg_stall_ep0(struct dwc2_hsotg *hsotg)\r\n{\r\nstruct s3c_hsotg_ep *ep0 = hsotg->eps_out[0];\r\nu32 reg;\r\nu32 ctrl;\r\ndev_dbg(hsotg->dev, "ep0 stall (dir=%d)\n", ep0->dir_in);\r\nreg = (ep0->dir_in) ? DIEPCTL0 : DOEPCTL0;\r\nctrl = readl(hsotg->regs + reg);\r\nctrl |= DXEPCTL_STALL;\r\nctrl |= DXEPCTL_CNAK;\r\nwritel(ctrl, hsotg->regs + reg);\r\ndev_dbg(hsotg->dev,\r\n"written DXEPCTL=0x%08x to %08x (DXEPCTL=0x%08x)\n",\r\nctrl, reg, readl(hsotg->regs + reg));\r\ns3c_hsotg_enqueue_setup(hsotg);\r\n}\r\nstatic void s3c_hsotg_process_control(struct dwc2_hsotg *hsotg,\r\nstruct usb_ctrlrequest *ctrl)\r\n{\r\nstruct s3c_hsotg_ep *ep0 = hsotg->eps_out[0];\r\nint ret = 0;\r\nu32 dcfg;\r\ndev_dbg(hsotg->dev, "ctrl Req=%02x, Type=%02x, V=%04x, L=%04x\n",\r\nctrl->bRequest, ctrl->bRequestType,\r\nctrl->wValue, ctrl->wLength);\r\nif (ctrl->wLength == 0) {\r\nep0->dir_in = 1;\r\nhsotg->ep0_state = DWC2_EP0_STATUS_IN;\r\n} else if (ctrl->bRequestType & USB_DIR_IN) {\r\nep0->dir_in = 1;\r\nhsotg->ep0_state = DWC2_EP0_DATA_IN;\r\n} else {\r\nep0->dir_in = 0;\r\nhsotg->ep0_state = DWC2_EP0_DATA_OUT;\r\n}\r\nif ((ctrl->bRequestType & USB_TYPE_MASK) == USB_TYPE_STANDARD) {\r\nswitch (ctrl->bRequest) {\r\ncase USB_REQ_SET_ADDRESS:\r\nhsotg->connected = 1;\r\ndcfg = readl(hsotg->regs + DCFG);\r\ndcfg &= ~DCFG_DEVADDR_MASK;\r\ndcfg |= (le16_to_cpu(ctrl->wValue) <<\r\nDCFG_DEVADDR_SHIFT) & DCFG_DEVADDR_MASK;\r\nwritel(dcfg, hsotg->regs + DCFG);\r\ndev_info(hsotg->dev, "new address %d\n", ctrl->wValue);\r\nret = s3c_hsotg_send_reply(hsotg, ep0, NULL, 0);\r\nreturn;\r\ncase USB_REQ_GET_STATUS:\r\nret = s3c_hsotg_process_req_status(hsotg, ctrl);\r\nbreak;\r\ncase USB_REQ_CLEAR_FEATURE:\r\ncase USB_REQ_SET_FEATURE:\r\nret = s3c_hsotg_process_req_feature(hsotg, ctrl);\r\nbreak;\r\n}\r\n}\r\nif (ret == 0 && hsotg->driver) {\r\nspin_unlock(&hsotg->lock);\r\nret = hsotg->driver->setup(&hsotg->gadget, ctrl);\r\nspin_lock(&hsotg->lock);\r\nif (ret < 0)\r\ndev_dbg(hsotg->dev, "driver->setup() ret %d\n", ret);\r\n}\r\nif (ret < 0)\r\ns3c_hsotg_stall_ep0(hsotg);\r\n}\r\nstatic void s3c_hsotg_complete_setup(struct usb_ep *ep,\r\nstruct usb_request *req)\r\n{\r\nstruct s3c_hsotg_ep *hs_ep = our_ep(ep);\r\nstruct dwc2_hsotg *hsotg = hs_ep->parent;\r\nif (req->status < 0) {\r\ndev_dbg(hsotg->dev, "%s: failed %d\n", __func__, req->status);\r\nreturn;\r\n}\r\nspin_lock(&hsotg->lock);\r\nif (req->actual == 0)\r\ns3c_hsotg_enqueue_setup(hsotg);\r\nelse\r\ns3c_hsotg_process_control(hsotg, req->buf);\r\nspin_unlock(&hsotg->lock);\r\n}\r\nstatic void s3c_hsotg_enqueue_setup(struct dwc2_hsotg *hsotg)\r\n{\r\nstruct usb_request *req = hsotg->ctrl_req;\r\nstruct s3c_hsotg_req *hs_req = our_req(req);\r\nint ret;\r\ndev_dbg(hsotg->dev, "%s: queueing setup request\n", __func__);\r\nreq->zero = 0;\r\nreq->length = 8;\r\nreq->buf = hsotg->ctrl_buff;\r\nreq->complete = s3c_hsotg_complete_setup;\r\nif (!list_empty(&hs_req->queue)) {\r\ndev_dbg(hsotg->dev, "%s already queued???\n", __func__);\r\nreturn;\r\n}\r\nhsotg->eps_out[0]->dir_in = 0;\r\nhsotg->eps_out[0]->send_zlp = 0;\r\nhsotg->ep0_state = DWC2_EP0_SETUP;\r\nret = s3c_hsotg_ep_queue(&hsotg->eps_out[0]->ep, req, GFP_ATOMIC);\r\nif (ret < 0) {\r\ndev_err(hsotg->dev, "%s: failed queue (%d)\n", __func__, ret);\r\n}\r\n}\r\nstatic void s3c_hsotg_program_zlp(struct dwc2_hsotg *hsotg,\r\nstruct s3c_hsotg_ep *hs_ep)\r\n{\r\nu32 ctrl;\r\nu8 index = hs_ep->index;\r\nu32 epctl_reg = hs_ep->dir_in ? DIEPCTL(index) : DOEPCTL(index);\r\nu32 epsiz_reg = hs_ep->dir_in ? DIEPTSIZ(index) : DOEPTSIZ(index);\r\nif (hs_ep->dir_in)\r\ndev_dbg(hsotg->dev, "Sending zero-length packet on ep%d\n",\r\nindex);\r\nelse\r\ndev_dbg(hsotg->dev, "Receiving zero-length packet on ep%d\n",\r\nindex);\r\nwritel(DXEPTSIZ_MC(1) | DXEPTSIZ_PKTCNT(1) |\r\nDXEPTSIZ_XFERSIZE(0), hsotg->regs +\r\nepsiz_reg);\r\nctrl = readl(hsotg->regs + epctl_reg);\r\nctrl |= DXEPCTL_CNAK;\r\nctrl |= DXEPCTL_EPENA;\r\nctrl |= DXEPCTL_USBACTEP;\r\nwritel(ctrl, hsotg->regs + epctl_reg);\r\n}\r\nstatic void s3c_hsotg_complete_request(struct dwc2_hsotg *hsotg,\r\nstruct s3c_hsotg_ep *hs_ep,\r\nstruct s3c_hsotg_req *hs_req,\r\nint result)\r\n{\r\nbool restart;\r\nif (!hs_req) {\r\ndev_dbg(hsotg->dev, "%s: nothing to complete?\n", __func__);\r\nreturn;\r\n}\r\ndev_dbg(hsotg->dev, "complete: ep %p %s, req %p, %d => %p\n",\r\nhs_ep, hs_ep->ep.name, hs_req, result, hs_req->req.complete);\r\nif (hs_req->req.status == -EINPROGRESS)\r\nhs_req->req.status = result;\r\ns3c_hsotg_handle_unaligned_buf_complete(hsotg, hs_ep, hs_req);\r\nhs_ep->req = NULL;\r\nlist_del_init(&hs_req->queue);\r\nif (using_dma(hsotg))\r\ns3c_hsotg_unmap_dma(hsotg, hs_ep, hs_req);\r\nif (hs_req->req.complete) {\r\nspin_unlock(&hsotg->lock);\r\nusb_gadget_giveback_request(&hs_ep->ep, &hs_req->req);\r\nspin_lock(&hsotg->lock);\r\n}\r\nif (!hs_ep->req && result >= 0) {\r\nrestart = !list_empty(&hs_ep->queue);\r\nif (restart) {\r\nhs_req = get_ep_head(hs_ep);\r\ns3c_hsotg_start_req(hsotg, hs_ep, hs_req, false);\r\n}\r\n}\r\n}\r\nstatic void s3c_hsotg_rx_data(struct dwc2_hsotg *hsotg, int ep_idx, int size)\r\n{\r\nstruct s3c_hsotg_ep *hs_ep = hsotg->eps_out[ep_idx];\r\nstruct s3c_hsotg_req *hs_req = hs_ep->req;\r\nvoid __iomem *fifo = hsotg->regs + EPFIFO(ep_idx);\r\nint to_read;\r\nint max_req;\r\nint read_ptr;\r\nif (!hs_req) {\r\nu32 epctl = readl(hsotg->regs + DOEPCTL(ep_idx));\r\nint ptr;\r\ndev_dbg(hsotg->dev,\r\n"%s: FIFO %d bytes on ep%d but no req (DXEPCTl=0x%08x)\n",\r\n__func__, size, ep_idx, epctl);\r\nfor (ptr = 0; ptr < size; ptr += 4)\r\n(void)readl(fifo);\r\nreturn;\r\n}\r\nto_read = size;\r\nread_ptr = hs_req->req.actual;\r\nmax_req = hs_req->req.length - read_ptr;\r\ndev_dbg(hsotg->dev, "%s: read %d/%d, done %d/%d\n",\r\n__func__, to_read, max_req, read_ptr, hs_req->req.length);\r\nif (to_read > max_req) {\r\nWARN_ON_ONCE(1);\r\n}\r\nhs_ep->total_data += to_read;\r\nhs_req->req.actual += to_read;\r\nto_read = DIV_ROUND_UP(to_read, 4);\r\nioread32_rep(fifo, hs_req->req.buf + read_ptr, to_read);\r\n}\r\nstatic void s3c_hsotg_ep0_zlp(struct dwc2_hsotg *hsotg, bool dir_in)\r\n{\r\nhsotg->eps_out[0]->dir_in = dir_in;\r\nhsotg->ep0_state = dir_in ? DWC2_EP0_STATUS_IN : DWC2_EP0_STATUS_OUT;\r\ns3c_hsotg_program_zlp(hsotg, hsotg->eps_out[0]);\r\n}\r\nstatic void s3c_hsotg_handle_outdone(struct dwc2_hsotg *hsotg, int epnum)\r\n{\r\nu32 epsize = readl(hsotg->regs + DOEPTSIZ(epnum));\r\nstruct s3c_hsotg_ep *hs_ep = hsotg->eps_out[epnum];\r\nstruct s3c_hsotg_req *hs_req = hs_ep->req;\r\nstruct usb_request *req = &hs_req->req;\r\nunsigned size_left = DXEPTSIZ_XFERSIZE_GET(epsize);\r\nint result = 0;\r\nif (!hs_req) {\r\ndev_dbg(hsotg->dev, "%s: no request active\n", __func__);\r\nreturn;\r\n}\r\nif (epnum == 0 && hsotg->ep0_state == DWC2_EP0_STATUS_OUT) {\r\ndev_dbg(hsotg->dev, "zlp packet received\n");\r\ns3c_hsotg_complete_request(hsotg, hs_ep, hs_req, 0);\r\ns3c_hsotg_enqueue_setup(hsotg);\r\nreturn;\r\n}\r\nif (using_dma(hsotg)) {\r\nunsigned size_done;\r\nsize_done = hs_ep->size_loaded - size_left;\r\nsize_done += hs_ep->last_load;\r\nreq->actual = size_done;\r\n}\r\nif (req->actual < req->length && size_left == 0) {\r\ns3c_hsotg_start_req(hsotg, hs_ep, hs_req, true);\r\nreturn;\r\n}\r\nif (req->actual < req->length && req->short_not_ok) {\r\ndev_dbg(hsotg->dev, "%s: got %d/%d (short not ok) => error\n",\r\n__func__, req->actual, req->length);\r\n}\r\nif (epnum == 0 && hsotg->ep0_state == DWC2_EP0_DATA_OUT) {\r\ns3c_hsotg_ep0_zlp(hsotg, true);\r\nreturn;\r\n}\r\ns3c_hsotg_complete_request(hsotg, hs_ep, hs_req, result);\r\n}\r\nstatic u32 s3c_hsotg_read_frameno(struct dwc2_hsotg *hsotg)\r\n{\r\nu32 dsts;\r\ndsts = readl(hsotg->regs + DSTS);\r\ndsts &= DSTS_SOFFN_MASK;\r\ndsts >>= DSTS_SOFFN_SHIFT;\r\nreturn dsts;\r\n}\r\nstatic void s3c_hsotg_handle_rx(struct dwc2_hsotg *hsotg)\r\n{\r\nu32 grxstsr = readl(hsotg->regs + GRXSTSP);\r\nu32 epnum, status, size;\r\nWARN_ON(using_dma(hsotg));\r\nepnum = grxstsr & GRXSTS_EPNUM_MASK;\r\nstatus = grxstsr & GRXSTS_PKTSTS_MASK;\r\nsize = grxstsr & GRXSTS_BYTECNT_MASK;\r\nsize >>= GRXSTS_BYTECNT_SHIFT;\r\ndev_dbg(hsotg->dev, "%s: GRXSTSP=0x%08x (%d@%d)\n",\r\n__func__, grxstsr, size, epnum);\r\nswitch ((status & GRXSTS_PKTSTS_MASK) >> GRXSTS_PKTSTS_SHIFT) {\r\ncase GRXSTS_PKTSTS_GLOBALOUTNAK:\r\ndev_dbg(hsotg->dev, "GLOBALOUTNAK\n");\r\nbreak;\r\ncase GRXSTS_PKTSTS_OUTDONE:\r\ndev_dbg(hsotg->dev, "OutDone (Frame=0x%08x)\n",\r\ns3c_hsotg_read_frameno(hsotg));\r\nif (!using_dma(hsotg))\r\ns3c_hsotg_handle_outdone(hsotg, epnum);\r\nbreak;\r\ncase GRXSTS_PKTSTS_SETUPDONE:\r\ndev_dbg(hsotg->dev,\r\n"SetupDone (Frame=0x%08x, DOPEPCTL=0x%08x)\n",\r\ns3c_hsotg_read_frameno(hsotg),\r\nreadl(hsotg->regs + DOEPCTL(0)));\r\nif (hsotg->ep0_state == DWC2_EP0_SETUP)\r\ns3c_hsotg_handle_outdone(hsotg, epnum);\r\nbreak;\r\ncase GRXSTS_PKTSTS_OUTRX:\r\ns3c_hsotg_rx_data(hsotg, epnum, size);\r\nbreak;\r\ncase GRXSTS_PKTSTS_SETUPRX:\r\ndev_dbg(hsotg->dev,\r\n"SetupRX (Frame=0x%08x, DOPEPCTL=0x%08x)\n",\r\ns3c_hsotg_read_frameno(hsotg),\r\nreadl(hsotg->regs + DOEPCTL(0)));\r\nWARN_ON(hsotg->ep0_state != DWC2_EP0_SETUP);\r\ns3c_hsotg_rx_data(hsotg, epnum, size);\r\nbreak;\r\ndefault:\r\ndev_warn(hsotg->dev, "%s: unknown status %08x\n",\r\n__func__, grxstsr);\r\ns3c_hsotg_dump(hsotg);\r\nbreak;\r\n}\r\n}\r\nstatic u32 s3c_hsotg_ep0_mps(unsigned int mps)\r\n{\r\nswitch (mps) {\r\ncase 64:\r\nreturn D0EPCTL_MPS_64;\r\ncase 32:\r\nreturn D0EPCTL_MPS_32;\r\ncase 16:\r\nreturn D0EPCTL_MPS_16;\r\ncase 8:\r\nreturn D0EPCTL_MPS_8;\r\n}\r\nWARN_ON(1);\r\nreturn (u32)-1;\r\n}\r\nstatic void s3c_hsotg_set_ep_maxpacket(struct dwc2_hsotg *hsotg,\r\nunsigned int ep, unsigned int mps, unsigned int dir_in)\r\n{\r\nstruct s3c_hsotg_ep *hs_ep;\r\nvoid __iomem *regs = hsotg->regs;\r\nu32 mpsval;\r\nu32 mcval;\r\nu32 reg;\r\nhs_ep = index_to_ep(hsotg, ep, dir_in);\r\nif (!hs_ep)\r\nreturn;\r\nif (ep == 0) {\r\nmpsval = s3c_hsotg_ep0_mps(mps);\r\nif (mpsval > 3)\r\ngoto bad_mps;\r\nhs_ep->ep.maxpacket = mps;\r\nhs_ep->mc = 1;\r\n} else {\r\nmpsval = mps & DXEPCTL_MPS_MASK;\r\nif (mpsval > 1024)\r\ngoto bad_mps;\r\nmcval = ((mps >> 11) & 0x3) + 1;\r\nhs_ep->mc = mcval;\r\nif (mcval > 3)\r\ngoto bad_mps;\r\nhs_ep->ep.maxpacket = mpsval;\r\n}\r\nif (dir_in) {\r\nreg = readl(regs + DIEPCTL(ep));\r\nreg &= ~DXEPCTL_MPS_MASK;\r\nreg |= mpsval;\r\nwritel(reg, regs + DIEPCTL(ep));\r\n} else {\r\nreg = readl(regs + DOEPCTL(ep));\r\nreg &= ~DXEPCTL_MPS_MASK;\r\nreg |= mpsval;\r\nwritel(reg, regs + DOEPCTL(ep));\r\n}\r\nreturn;\r\nbad_mps:\r\ndev_err(hsotg->dev, "ep%d: bad mps of %d\n", ep, mps);\r\n}\r\nstatic void s3c_hsotg_txfifo_flush(struct dwc2_hsotg *hsotg, unsigned int idx)\r\n{\r\nint timeout;\r\nint val;\r\nwritel(GRSTCTL_TXFNUM(idx) | GRSTCTL_TXFFLSH,\r\nhsotg->regs + GRSTCTL);\r\ntimeout = 100;\r\nwhile (1) {\r\nval = readl(hsotg->regs + GRSTCTL);\r\nif ((val & (GRSTCTL_TXFFLSH)) == 0)\r\nbreak;\r\nif (--timeout == 0) {\r\ndev_err(hsotg->dev,\r\n"%s: timeout flushing fifo (GRSTCTL=%08x)\n",\r\n__func__, val);\r\nbreak;\r\n}\r\nudelay(1);\r\n}\r\n}\r\nstatic int s3c_hsotg_trytx(struct dwc2_hsotg *hsotg,\r\nstruct s3c_hsotg_ep *hs_ep)\r\n{\r\nstruct s3c_hsotg_req *hs_req = hs_ep->req;\r\nif (!hs_ep->dir_in || !hs_req) {\r\nif (hs_ep->index != 0)\r\ns3c_hsotg_ctrl_epint(hsotg, hs_ep->index,\r\nhs_ep->dir_in, 0);\r\nreturn 0;\r\n}\r\nif (hs_req->req.actual < hs_req->req.length) {\r\ndev_dbg(hsotg->dev, "trying to write more for ep%d\n",\r\nhs_ep->index);\r\nreturn s3c_hsotg_write_fifo(hsotg, hs_ep, hs_req);\r\n}\r\nreturn 0;\r\n}\r\nstatic void s3c_hsotg_complete_in(struct dwc2_hsotg *hsotg,\r\nstruct s3c_hsotg_ep *hs_ep)\r\n{\r\nstruct s3c_hsotg_req *hs_req = hs_ep->req;\r\nu32 epsize = readl(hsotg->regs + DIEPTSIZ(hs_ep->index));\r\nint size_left, size_done;\r\nif (!hs_req) {\r\ndev_dbg(hsotg->dev, "XferCompl but no req\n");\r\nreturn;\r\n}\r\nif (hs_ep->index == 0 && hsotg->ep0_state == DWC2_EP0_STATUS_IN) {\r\ndev_dbg(hsotg->dev, "zlp packet sent\n");\r\ns3c_hsotg_complete_request(hsotg, hs_ep, hs_req, 0);\r\nif (hsotg->test_mode) {\r\nint ret;\r\nret = s3c_hsotg_set_test_mode(hsotg, hsotg->test_mode);\r\nif (ret < 0) {\r\ndev_dbg(hsotg->dev, "Invalid Test #%d\n",\r\nhsotg->test_mode);\r\ns3c_hsotg_stall_ep0(hsotg);\r\nreturn;\r\n}\r\n}\r\ns3c_hsotg_enqueue_setup(hsotg);\r\nreturn;\r\n}\r\nsize_left = DXEPTSIZ_XFERSIZE_GET(epsize);\r\nsize_done = hs_ep->size_loaded - size_left;\r\nsize_done += hs_ep->last_load;\r\nif (hs_req->req.actual != size_done)\r\ndev_dbg(hsotg->dev, "%s: adjusting size done %d => %d\n",\r\n__func__, hs_req->req.actual, size_done);\r\nhs_req->req.actual = size_done;\r\ndev_dbg(hsotg->dev, "req->length:%d req->actual:%d req->zero:%d\n",\r\nhs_req->req.length, hs_req->req.actual, hs_req->req.zero);\r\nif (!size_left && hs_req->req.actual < hs_req->req.length) {\r\ndev_dbg(hsotg->dev, "%s trying more for req...\n", __func__);\r\ns3c_hsotg_start_req(hsotg, hs_ep, hs_req, true);\r\nreturn;\r\n}\r\nif (hs_ep->send_zlp) {\r\ns3c_hsotg_program_zlp(hsotg, hs_ep);\r\nhs_ep->send_zlp = 0;\r\nreturn;\r\n}\r\nif (hs_ep->index == 0 && hsotg->ep0_state == DWC2_EP0_DATA_IN) {\r\ns3c_hsotg_ep0_zlp(hsotg, false);\r\nreturn;\r\n}\r\ns3c_hsotg_complete_request(hsotg, hs_ep, hs_req, 0);\r\n}\r\nstatic void s3c_hsotg_epint(struct dwc2_hsotg *hsotg, unsigned int idx,\r\nint dir_in)\r\n{\r\nstruct s3c_hsotg_ep *hs_ep = index_to_ep(hsotg, idx, dir_in);\r\nu32 epint_reg = dir_in ? DIEPINT(idx) : DOEPINT(idx);\r\nu32 epctl_reg = dir_in ? DIEPCTL(idx) : DOEPCTL(idx);\r\nu32 epsiz_reg = dir_in ? DIEPTSIZ(idx) : DOEPTSIZ(idx);\r\nu32 ints;\r\nu32 ctrl;\r\nints = readl(hsotg->regs + epint_reg);\r\nctrl = readl(hsotg->regs + epctl_reg);\r\nwritel(ints, hsotg->regs + epint_reg);\r\nif (!hs_ep) {\r\ndev_err(hsotg->dev, "%s:Interrupt for unconfigured ep%d(%s)\n",\r\n__func__, idx, dir_in ? "in" : "out");\r\nreturn;\r\n}\r\ndev_dbg(hsotg->dev, "%s: ep%d(%s) DxEPINT=0x%08x\n",\r\n__func__, idx, dir_in ? "in" : "out", ints);\r\nif (idx == 0 && (ints & (DXEPINT_SETUP | DXEPINT_SETUP_RCVD)))\r\nints &= ~DXEPINT_XFERCOMPL;\r\nif (ints & DXEPINT_XFERCOMPL) {\r\nif (hs_ep->isochronous && hs_ep->interval == 1) {\r\nif (ctrl & DXEPCTL_EOFRNUM)\r\nctrl |= DXEPCTL_SETEVENFR;\r\nelse\r\nctrl |= DXEPCTL_SETODDFR;\r\nwritel(ctrl, hsotg->regs + epctl_reg);\r\n}\r\ndev_dbg(hsotg->dev,\r\n"%s: XferCompl: DxEPCTL=0x%08x, DXEPTSIZ=%08x\n",\r\n__func__, readl(hsotg->regs + epctl_reg),\r\nreadl(hsotg->regs + epsiz_reg));\r\nif (dir_in) {\r\ns3c_hsotg_complete_in(hsotg, hs_ep);\r\nif (idx == 0 && !hs_ep->req)\r\ns3c_hsotg_enqueue_setup(hsotg);\r\n} else if (using_dma(hsotg)) {\r\ns3c_hsotg_handle_outdone(hsotg, idx);\r\n}\r\n}\r\nif (ints & DXEPINT_EPDISBLD) {\r\ndev_dbg(hsotg->dev, "%s: EPDisbld\n", __func__);\r\nif (dir_in) {\r\nint epctl = readl(hsotg->regs + epctl_reg);\r\ns3c_hsotg_txfifo_flush(hsotg, hs_ep->fifo_index);\r\nif ((epctl & DXEPCTL_STALL) &&\r\n(epctl & DXEPCTL_EPTYPE_BULK)) {\r\nint dctl = readl(hsotg->regs + DCTL);\r\ndctl |= DCTL_CGNPINNAK;\r\nwritel(dctl, hsotg->regs + DCTL);\r\n}\r\n}\r\n}\r\nif (ints & DXEPINT_AHBERR)\r\ndev_dbg(hsotg->dev, "%s: AHBErr\n", __func__);\r\nif (ints & DXEPINT_SETUP) {\r\ndev_dbg(hsotg->dev, "%s: Setup/Timeout\n", __func__);\r\nif (using_dma(hsotg) && idx == 0) {\r\nif (dir_in)\r\nWARN_ON_ONCE(1);\r\nelse\r\ns3c_hsotg_handle_outdone(hsotg, 0);\r\n}\r\n}\r\nif (ints & DXEPINT_BACK2BACKSETUP)\r\ndev_dbg(hsotg->dev, "%s: B2BSetup/INEPNakEff\n", __func__);\r\nif (dir_in && !hs_ep->isochronous) {\r\nif (ints & DIEPMSK_INTKNTXFEMPMSK) {\r\ndev_dbg(hsotg->dev, "%s: ep%d: INTknTXFEmpMsk\n",\r\n__func__, idx);\r\n}\r\nif (ints & DIEPMSK_INTKNEPMISMSK) {\r\ndev_warn(hsotg->dev, "%s: ep%d: INTknEP\n",\r\n__func__, idx);\r\n}\r\nif (hsotg->dedicated_fifos &&\r\nints & DIEPMSK_TXFIFOEMPTY) {\r\ndev_dbg(hsotg->dev, "%s: ep%d: TxFIFOEmpty\n",\r\n__func__, idx);\r\nif (!using_dma(hsotg))\r\ns3c_hsotg_trytx(hsotg, hs_ep);\r\n}\r\n}\r\n}\r\nstatic void s3c_hsotg_irq_enumdone(struct dwc2_hsotg *hsotg)\r\n{\r\nu32 dsts = readl(hsotg->regs + DSTS);\r\nint ep0_mps = 0, ep_mps = 8;\r\ndev_dbg(hsotg->dev, "EnumDone (DSTS=0x%08x)\n", dsts);\r\nswitch (dsts & DSTS_ENUMSPD_MASK) {\r\ncase DSTS_ENUMSPD_FS:\r\ncase DSTS_ENUMSPD_FS48:\r\nhsotg->gadget.speed = USB_SPEED_FULL;\r\nep0_mps = EP0_MPS_LIMIT;\r\nep_mps = 1023;\r\nbreak;\r\ncase DSTS_ENUMSPD_HS:\r\nhsotg->gadget.speed = USB_SPEED_HIGH;\r\nep0_mps = EP0_MPS_LIMIT;\r\nep_mps = 1024;\r\nbreak;\r\ncase DSTS_ENUMSPD_LS:\r\nhsotg->gadget.speed = USB_SPEED_LOW;\r\nbreak;\r\n}\r\ndev_info(hsotg->dev, "new device is %s\n",\r\nusb_speed_string(hsotg->gadget.speed));\r\nif (ep0_mps) {\r\nint i;\r\ns3c_hsotg_set_ep_maxpacket(hsotg, 0, ep0_mps, 1);\r\ns3c_hsotg_set_ep_maxpacket(hsotg, 0, ep0_mps, 0);\r\nfor (i = 1; i < hsotg->num_of_eps; i++) {\r\nif (hsotg->eps_in[i])\r\ns3c_hsotg_set_ep_maxpacket(hsotg, i, ep_mps, 1);\r\nif (hsotg->eps_out[i])\r\ns3c_hsotg_set_ep_maxpacket(hsotg, i, ep_mps, 0);\r\n}\r\n}\r\ns3c_hsotg_enqueue_setup(hsotg);\r\ndev_dbg(hsotg->dev, "EP0: DIEPCTL0=0x%08x, DOEPCTL0=0x%08x\n",\r\nreadl(hsotg->regs + DIEPCTL0),\r\nreadl(hsotg->regs + DOEPCTL0));\r\n}\r\nstatic void kill_all_requests(struct dwc2_hsotg *hsotg,\r\nstruct s3c_hsotg_ep *ep,\r\nint result)\r\n{\r\nstruct s3c_hsotg_req *req, *treq;\r\nunsigned size;\r\nep->req = NULL;\r\nlist_for_each_entry_safe(req, treq, &ep->queue, queue)\r\ns3c_hsotg_complete_request(hsotg, ep, req,\r\nresult);\r\nif (!hsotg->dedicated_fifos)\r\nreturn;\r\nsize = (readl(hsotg->regs + DTXFSTS(ep->index)) & 0xffff) * 4;\r\nif (size < ep->fifo_size)\r\ns3c_hsotg_txfifo_flush(hsotg, ep->fifo_index);\r\n}\r\nvoid s3c_hsotg_disconnect(struct dwc2_hsotg *hsotg)\r\n{\r\nunsigned ep;\r\nif (!hsotg->connected)\r\nreturn;\r\nhsotg->connected = 0;\r\nhsotg->test_mode = 0;\r\nfor (ep = 0; ep < hsotg->num_of_eps; ep++) {\r\nif (hsotg->eps_in[ep])\r\nkill_all_requests(hsotg, hsotg->eps_in[ep],\r\n-ESHUTDOWN);\r\nif (hsotg->eps_out[ep])\r\nkill_all_requests(hsotg, hsotg->eps_out[ep],\r\n-ESHUTDOWN);\r\n}\r\ncall_gadget(hsotg, disconnect);\r\n}\r\nstatic void s3c_hsotg_irq_fifoempty(struct dwc2_hsotg *hsotg, bool periodic)\r\n{\r\nstruct s3c_hsotg_ep *ep;\r\nint epno, ret;\r\nfor (epno = 0; epno < hsotg->num_of_eps; epno++) {\r\nep = index_to_ep(hsotg, epno, 1);\r\nif (!ep)\r\ncontinue;\r\nif (!ep->dir_in)\r\ncontinue;\r\nif ((periodic && !ep->periodic) ||\r\n(!periodic && ep->periodic))\r\ncontinue;\r\nret = s3c_hsotg_trytx(hsotg, ep);\r\nif (ret < 0)\r\nbreak;\r\n}\r\n}\r\nstatic int s3c_hsotg_corereset(struct dwc2_hsotg *hsotg)\r\n{\r\nint timeout;\r\nu32 grstctl;\r\ndev_dbg(hsotg->dev, "resetting core\n");\r\nwritel(GRSTCTL_CSFTRST, hsotg->regs + GRSTCTL);\r\ntimeout = 10000;\r\ndo {\r\ngrstctl = readl(hsotg->regs + GRSTCTL);\r\n} while ((grstctl & GRSTCTL_CSFTRST) && timeout-- > 0);\r\nif (grstctl & GRSTCTL_CSFTRST) {\r\ndev_err(hsotg->dev, "Failed to get CSftRst asserted\n");\r\nreturn -EINVAL;\r\n}\r\ntimeout = 10000;\r\nwhile (1) {\r\nu32 grstctl = readl(hsotg->regs + GRSTCTL);\r\nif (timeout-- < 0) {\r\ndev_info(hsotg->dev,\r\n"%s: reset failed, GRSTCTL=%08x\n",\r\n__func__, grstctl);\r\nreturn -ETIMEDOUT;\r\n}\r\nif (!(grstctl & GRSTCTL_AHBIDLE))\r\ncontinue;\r\nbreak;\r\n}\r\ndev_dbg(hsotg->dev, "reset successful\n");\r\nreturn 0;\r\n}\r\nvoid s3c_hsotg_core_init_disconnected(struct dwc2_hsotg *hsotg,\r\nbool is_usb_reset)\r\n{\r\nu32 val;\r\nif (!is_usb_reset)\r\ns3c_hsotg_corereset(hsotg);\r\nval = (hsotg->phyif == GUSBCFG_PHYIF8) ? 9 : 5;\r\nwritel(hsotg->phyif | GUSBCFG_TOUTCAL(7) |\r\n(val << GUSBCFG_USBTRDTIM_SHIFT), hsotg->regs + GUSBCFG);\r\ns3c_hsotg_init_fifo(hsotg);\r\nif (!is_usb_reset)\r\n__orr32(hsotg->regs + DCTL, DCTL_SFTDISCON);\r\nwritel(DCFG_EPMISCNT(1) | DCFG_DEVSPD_HS, hsotg->regs + DCFG);\r\nwritel(0xffffffff, hsotg->regs + GOTGINT);\r\nwritel(0xffffffff, hsotg->regs + GINTSTS);\r\nwritel(GINTSTS_ERLYSUSP | GINTSTS_SESSREQINT |\r\nGINTSTS_GOUTNAKEFF | GINTSTS_GINNAKEFF |\r\nGINTSTS_CONIDSTSCHNG | GINTSTS_USBRST |\r\nGINTSTS_ENUMDONE | GINTSTS_OTGINT |\r\nGINTSTS_USBSUSP | GINTSTS_WKUPINT,\r\nhsotg->regs + GINTMSK);\r\nif (using_dma(hsotg))\r\nwritel(GAHBCFG_GLBL_INTR_EN | GAHBCFG_DMA_EN |\r\n(GAHBCFG_HBSTLEN_INCR4 << GAHBCFG_HBSTLEN_SHIFT),\r\nhsotg->regs + GAHBCFG);\r\nelse\r\nwritel(((hsotg->dedicated_fifos) ? (GAHBCFG_NP_TXF_EMP_LVL |\r\nGAHBCFG_P_TXF_EMP_LVL) : 0) |\r\nGAHBCFG_GLBL_INTR_EN,\r\nhsotg->regs + GAHBCFG);\r\nwritel(((hsotg->dedicated_fifos && !using_dma(hsotg)) ?\r\nDIEPMSK_TXFIFOEMPTY | DIEPMSK_INTKNTXFEMPMSK : 0) |\r\nDIEPMSK_EPDISBLDMSK | DIEPMSK_XFERCOMPLMSK |\r\nDIEPMSK_TIMEOUTMSK | DIEPMSK_AHBERRMSK |\r\nDIEPMSK_INTKNEPMISMSK,\r\nhsotg->regs + DIEPMSK);\r\nwritel((using_dma(hsotg) ? (DIEPMSK_XFERCOMPLMSK |\r\nDIEPMSK_TIMEOUTMSK) : 0) |\r\nDOEPMSK_EPDISBLDMSK | DOEPMSK_AHBERRMSK |\r\nDOEPMSK_SETUPMSK,\r\nhsotg->regs + DOEPMSK);\r\nwritel(0, hsotg->regs + DAINTMSK);\r\ndev_dbg(hsotg->dev, "EP0: DIEPCTL0=0x%08x, DOEPCTL0=0x%08x\n",\r\nreadl(hsotg->regs + DIEPCTL0),\r\nreadl(hsotg->regs + DOEPCTL0));\r\ns3c_hsotg_en_gsint(hsotg, GINTSTS_OEPINT | GINTSTS_IEPINT);\r\nif (!using_dma(hsotg))\r\ns3c_hsotg_en_gsint(hsotg, GINTSTS_RXFLVL);\r\ns3c_hsotg_ctrl_epint(hsotg, 0, 0, 1);\r\ns3c_hsotg_ctrl_epint(hsotg, 0, 1, 1);\r\nif (!is_usb_reset) {\r\n__orr32(hsotg->regs + DCTL, DCTL_PWRONPRGDONE);\r\nudelay(10);\r\n__bic32(hsotg->regs + DCTL, DCTL_PWRONPRGDONE);\r\n}\r\ndev_dbg(hsotg->dev, "DCTL=0x%08x\n", readl(hsotg->regs + DCTL));\r\nwritel(DXEPTSIZ_MC(1) | DXEPTSIZ_PKTCNT(1) |\r\nDXEPTSIZ_XFERSIZE(8), hsotg->regs + DOEPTSIZ0);\r\nwritel(s3c_hsotg_ep0_mps(hsotg->eps_out[0]->ep.maxpacket) |\r\nDXEPCTL_CNAK | DXEPCTL_EPENA |\r\nDXEPCTL_USBACTEP,\r\nhsotg->regs + DOEPCTL0);\r\nwritel(s3c_hsotg_ep0_mps(hsotg->eps_out[0]->ep.maxpacket) |\r\nDXEPCTL_USBACTEP, hsotg->regs + DIEPCTL0);\r\ns3c_hsotg_enqueue_setup(hsotg);\r\ndev_dbg(hsotg->dev, "EP0: DIEPCTL0=0x%08x, DOEPCTL0=0x%08x\n",\r\nreadl(hsotg->regs + DIEPCTL0),\r\nreadl(hsotg->regs + DOEPCTL0));\r\nval = DCTL_CGOUTNAK | DCTL_CGNPINNAK;\r\nif (!is_usb_reset)\r\nval |= DCTL_SFTDISCON;\r\n__orr32(hsotg->regs + DCTL, val);\r\nmdelay(3);\r\nhsotg->last_rst = jiffies;\r\n}\r\nstatic void s3c_hsotg_core_disconnect(struct dwc2_hsotg *hsotg)\r\n{\r\n__orr32(hsotg->regs + DCTL, DCTL_SFTDISCON);\r\n}\r\nvoid s3c_hsotg_core_connect(struct dwc2_hsotg *hsotg)\r\n{\r\n__bic32(hsotg->regs + DCTL, DCTL_SFTDISCON);\r\n}\r\nstatic irqreturn_t s3c_hsotg_irq(int irq, void *pw)\r\n{\r\nstruct dwc2_hsotg *hsotg = pw;\r\nint retry_count = 8;\r\nu32 gintsts;\r\nu32 gintmsk;\r\nspin_lock(&hsotg->lock);\r\nirq_retry:\r\ngintsts = readl(hsotg->regs + GINTSTS);\r\ngintmsk = readl(hsotg->regs + GINTMSK);\r\ndev_dbg(hsotg->dev, "%s: %08x %08x (%08x) retry %d\n",\r\n__func__, gintsts, gintsts & gintmsk, gintmsk, retry_count);\r\ngintsts &= gintmsk;\r\nif (gintsts & GINTSTS_ENUMDONE) {\r\nwritel(GINTSTS_ENUMDONE, hsotg->regs + GINTSTS);\r\ns3c_hsotg_irq_enumdone(hsotg);\r\n}\r\nif (gintsts & (GINTSTS_OEPINT | GINTSTS_IEPINT)) {\r\nu32 daint = readl(hsotg->regs + DAINT);\r\nu32 daintmsk = readl(hsotg->regs + DAINTMSK);\r\nu32 daint_out, daint_in;\r\nint ep;\r\ndaint &= daintmsk;\r\ndaint_out = daint >> DAINT_OUTEP_SHIFT;\r\ndaint_in = daint & ~(daint_out << DAINT_OUTEP_SHIFT);\r\ndev_dbg(hsotg->dev, "%s: daint=%08x\n", __func__, daint);\r\nfor (ep = 0; ep < hsotg->num_of_eps && daint_out;\r\nep++, daint_out >>= 1) {\r\nif (daint_out & 1)\r\ns3c_hsotg_epint(hsotg, ep, 0);\r\n}\r\nfor (ep = 0; ep < hsotg->num_of_eps && daint_in;\r\nep++, daint_in >>= 1) {\r\nif (daint_in & 1)\r\ns3c_hsotg_epint(hsotg, ep, 1);\r\n}\r\n}\r\nif (gintsts & GINTSTS_USBRST) {\r\nu32 usb_status = readl(hsotg->regs + GOTGCTL);\r\ndev_dbg(hsotg->dev, "%s: USBRst\n", __func__);\r\ndev_dbg(hsotg->dev, "GNPTXSTS=%08x\n",\r\nreadl(hsotg->regs + GNPTXSTS));\r\nwritel(GINTSTS_USBRST, hsotg->regs + GINTSTS);\r\ns3c_hsotg_disconnect(hsotg);\r\nif (usb_status & GOTGCTL_BSESVLD) {\r\nif (time_after(jiffies, hsotg->last_rst +\r\nmsecs_to_jiffies(200))) {\r\nkill_all_requests(hsotg, hsotg->eps_out[0],\r\n-ECONNRESET);\r\ns3c_hsotg_core_init_disconnected(hsotg, true);\r\n}\r\n}\r\n}\r\nif (gintsts & GINTSTS_NPTXFEMP) {\r\ndev_dbg(hsotg->dev, "NPTxFEmp\n");\r\ns3c_hsotg_disable_gsint(hsotg, GINTSTS_NPTXFEMP);\r\ns3c_hsotg_irq_fifoempty(hsotg, false);\r\n}\r\nif (gintsts & GINTSTS_PTXFEMP) {\r\ndev_dbg(hsotg->dev, "PTxFEmp\n");\r\ns3c_hsotg_disable_gsint(hsotg, GINTSTS_PTXFEMP);\r\ns3c_hsotg_irq_fifoempty(hsotg, true);\r\n}\r\nif (gintsts & GINTSTS_RXFLVL) {\r\ns3c_hsotg_handle_rx(hsotg);\r\n}\r\nif (gintsts & GINTSTS_ERLYSUSP) {\r\ndev_dbg(hsotg->dev, "GINTSTS_ErlySusp\n");\r\nwritel(GINTSTS_ERLYSUSP, hsotg->regs + GINTSTS);\r\n}\r\nif (gintsts & GINTSTS_GOUTNAKEFF) {\r\ndev_info(hsotg->dev, "GOUTNakEff triggered\n");\r\nwritel(DCTL_CGOUTNAK, hsotg->regs + DCTL);\r\ns3c_hsotg_dump(hsotg);\r\n}\r\nif (gintsts & GINTSTS_GINNAKEFF) {\r\ndev_info(hsotg->dev, "GINNakEff triggered\n");\r\nwritel(DCTL_CGNPINNAK, hsotg->regs + DCTL);\r\ns3c_hsotg_dump(hsotg);\r\n}\r\nif (gintsts & IRQ_RETRY_MASK && --retry_count > 0)\r\ngoto irq_retry;\r\nspin_unlock(&hsotg->lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int s3c_hsotg_ep_enable(struct usb_ep *ep,\r\nconst struct usb_endpoint_descriptor *desc)\r\n{\r\nstruct s3c_hsotg_ep *hs_ep = our_ep(ep);\r\nstruct dwc2_hsotg *hsotg = hs_ep->parent;\r\nunsigned long flags;\r\nunsigned int index = hs_ep->index;\r\nu32 epctrl_reg;\r\nu32 epctrl;\r\nu32 mps;\r\nunsigned int dir_in;\r\nunsigned int i, val, size;\r\nint ret = 0;\r\ndev_dbg(hsotg->dev,\r\n"%s: ep %s: a 0x%02x, attr 0x%02x, mps 0x%04x, intr %d\n",\r\n__func__, ep->name, desc->bEndpointAddress, desc->bmAttributes,\r\ndesc->wMaxPacketSize, desc->bInterval);\r\nWARN_ON(index == 0);\r\ndir_in = (desc->bEndpointAddress & USB_ENDPOINT_DIR_MASK) ? 1 : 0;\r\nif (dir_in != hs_ep->dir_in) {\r\ndev_err(hsotg->dev, "%s: direction mismatch!\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nmps = usb_endpoint_maxp(desc);\r\nepctrl_reg = dir_in ? DIEPCTL(index) : DOEPCTL(index);\r\nepctrl = readl(hsotg->regs + epctrl_reg);\r\ndev_dbg(hsotg->dev, "%s: read DxEPCTL=0x%08x from 0x%08x\n",\r\n__func__, epctrl, epctrl_reg);\r\nspin_lock_irqsave(&hsotg->lock, flags);\r\nepctrl &= ~(DXEPCTL_EPTYPE_MASK | DXEPCTL_MPS_MASK);\r\nepctrl |= DXEPCTL_MPS(mps);\r\nepctrl |= DXEPCTL_USBACTEP;\r\nepctrl |= DXEPCTL_SNAK;\r\ns3c_hsotg_set_ep_maxpacket(hsotg, hs_ep->index, mps, dir_in);\r\nhs_ep->isochronous = 0;\r\nhs_ep->periodic = 0;\r\nhs_ep->halted = 0;\r\nhs_ep->interval = desc->bInterval;\r\nif (hs_ep->interval > 1 && hs_ep->mc > 1)\r\ndev_err(hsotg->dev, "MC > 1 when interval is not 1\n");\r\nswitch (desc->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK) {\r\ncase USB_ENDPOINT_XFER_ISOC:\r\nepctrl |= DXEPCTL_EPTYPE_ISO;\r\nepctrl |= DXEPCTL_SETEVENFR;\r\nhs_ep->isochronous = 1;\r\nif (dir_in)\r\nhs_ep->periodic = 1;\r\nbreak;\r\ncase USB_ENDPOINT_XFER_BULK:\r\nepctrl |= DXEPCTL_EPTYPE_BULK;\r\nbreak;\r\ncase USB_ENDPOINT_XFER_INT:\r\nif (dir_in)\r\nhs_ep->periodic = 1;\r\nepctrl |= DXEPCTL_EPTYPE_INTERRUPT;\r\nbreak;\r\ncase USB_ENDPOINT_XFER_CONTROL:\r\nepctrl |= DXEPCTL_EPTYPE_CONTROL;\r\nbreak;\r\n}\r\nif (hs_ep->fifo_index) {\r\nsize = hs_ep->ep.maxpacket * hs_ep->mc;\r\nif (size > hs_ep->fifo_size) {\r\nhsotg->fifo_map &= ~(1 << hs_ep->fifo_index);\r\nhs_ep->fifo_index = 0;\r\nhs_ep->fifo_size = 0;\r\n}\r\n}\r\nif (dir_in && hsotg->dedicated_fifos && !hs_ep->fifo_index) {\r\nu32 fifo_index = 0;\r\nu32 fifo_size = UINT_MAX;\r\nsize = hs_ep->ep.maxpacket*hs_ep->mc;\r\nfor (i = 1; i < hsotg->num_of_eps; ++i) {\r\nif (hsotg->fifo_map & (1<<i))\r\ncontinue;\r\nval = readl(hsotg->regs + DPTXFSIZN(i));\r\nval = (val >> FIFOSIZE_DEPTH_SHIFT)*4;\r\nif (val < size)\r\ncontinue;\r\nif (val < fifo_size) {\r\nfifo_size = val;\r\nfifo_index = i;\r\n}\r\n}\r\nif (!fifo_index) {\r\ndev_err(hsotg->dev,\r\n"%s: No suitable fifo found\n", __func__);\r\nret = -ENOMEM;\r\ngoto error;\r\n}\r\nhsotg->fifo_map |= 1 << fifo_index;\r\nepctrl |= DXEPCTL_TXFNUM(fifo_index);\r\nhs_ep->fifo_index = fifo_index;\r\nhs_ep->fifo_size = fifo_size;\r\n}\r\nif (index)\r\nepctrl |= DXEPCTL_SETD0PID;\r\ndev_dbg(hsotg->dev, "%s: write DxEPCTL=0x%08x\n",\r\n__func__, epctrl);\r\nwritel(epctrl, hsotg->regs + epctrl_reg);\r\ndev_dbg(hsotg->dev, "%s: read DxEPCTL=0x%08x\n",\r\n__func__, readl(hsotg->regs + epctrl_reg));\r\ns3c_hsotg_ctrl_epint(hsotg, index, dir_in, 1);\r\nerror:\r\nspin_unlock_irqrestore(&hsotg->lock, flags);\r\nreturn ret;\r\n}\r\nstatic int s3c_hsotg_ep_disable_force(struct usb_ep *ep, bool force)\r\n{\r\nstruct s3c_hsotg_ep *hs_ep = our_ep(ep);\r\nstruct dwc2_hsotg *hsotg = hs_ep->parent;\r\nint dir_in = hs_ep->dir_in;\r\nint index = hs_ep->index;\r\nunsigned long flags;\r\nu32 epctrl_reg;\r\nu32 ctrl;\r\ndev_dbg(hsotg->dev, "%s(ep %p)\n", __func__, ep);\r\nif (ep == &hsotg->eps_out[0]->ep) {\r\ndev_err(hsotg->dev, "%s: called for ep0\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nepctrl_reg = dir_in ? DIEPCTL(index) : DOEPCTL(index);\r\nspin_lock_irqsave(&hsotg->lock, flags);\r\nhsotg->fifo_map &= ~(1<<hs_ep->fifo_index);\r\nhs_ep->fifo_index = 0;\r\nhs_ep->fifo_size = 0;\r\nctrl = readl(hsotg->regs + epctrl_reg);\r\nctrl &= ~DXEPCTL_EPENA;\r\nctrl &= ~DXEPCTL_USBACTEP;\r\nctrl |= DXEPCTL_SNAK;\r\ndev_dbg(hsotg->dev, "%s: DxEPCTL=0x%08x\n", __func__, ctrl);\r\nwritel(ctrl, hsotg->regs + epctrl_reg);\r\ns3c_hsotg_ctrl_epint(hsotg, hs_ep->index, hs_ep->dir_in, 0);\r\nkill_all_requests(hsotg, hs_ep, -ESHUTDOWN);\r\nspin_unlock_irqrestore(&hsotg->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int s3c_hsotg_ep_disable(struct usb_ep *ep)\r\n{\r\nreturn s3c_hsotg_ep_disable_force(ep, false);\r\n}\r\nstatic bool on_list(struct s3c_hsotg_ep *ep, struct s3c_hsotg_req *test)\r\n{\r\nstruct s3c_hsotg_req *req, *treq;\r\nlist_for_each_entry_safe(req, treq, &ep->queue, queue) {\r\nif (req == test)\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic int s3c_hsotg_ep_dequeue(struct usb_ep *ep, struct usb_request *req)\r\n{\r\nstruct s3c_hsotg_req *hs_req = our_req(req);\r\nstruct s3c_hsotg_ep *hs_ep = our_ep(ep);\r\nstruct dwc2_hsotg *hs = hs_ep->parent;\r\nunsigned long flags;\r\ndev_dbg(hs->dev, "ep_dequeue(%p,%p)\n", ep, req);\r\nspin_lock_irqsave(&hs->lock, flags);\r\nif (!on_list(hs_ep, hs_req)) {\r\nspin_unlock_irqrestore(&hs->lock, flags);\r\nreturn -EINVAL;\r\n}\r\ns3c_hsotg_complete_request(hs, hs_ep, hs_req, -ECONNRESET);\r\nspin_unlock_irqrestore(&hs->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int s3c_hsotg_ep_sethalt(struct usb_ep *ep, int value)\r\n{\r\nstruct s3c_hsotg_ep *hs_ep = our_ep(ep);\r\nstruct dwc2_hsotg *hs = hs_ep->parent;\r\nint index = hs_ep->index;\r\nu32 epreg;\r\nu32 epctl;\r\nu32 xfertype;\r\ndev_info(hs->dev, "%s(ep %p %s, %d)\n", __func__, ep, ep->name, value);\r\nif (index == 0) {\r\nif (value)\r\ns3c_hsotg_stall_ep0(hs);\r\nelse\r\ndev_warn(hs->dev,\r\n"%s: can't clear halt on ep0\n", __func__);\r\nreturn 0;\r\n}\r\nif (hs_ep->dir_in) {\r\nepreg = DIEPCTL(index);\r\nepctl = readl(hs->regs + epreg);\r\nif (value) {\r\nepctl |= DXEPCTL_STALL + DXEPCTL_SNAK;\r\nif (epctl & DXEPCTL_EPENA)\r\nepctl |= DXEPCTL_EPDIS;\r\n} else {\r\nepctl &= ~DXEPCTL_STALL;\r\nxfertype = epctl & DXEPCTL_EPTYPE_MASK;\r\nif (xfertype == DXEPCTL_EPTYPE_BULK ||\r\nxfertype == DXEPCTL_EPTYPE_INTERRUPT)\r\nepctl |= DXEPCTL_SETD0PID;\r\n}\r\nwritel(epctl, hs->regs + epreg);\r\n} else {\r\nepreg = DOEPCTL(index);\r\nepctl = readl(hs->regs + epreg);\r\nif (value)\r\nepctl |= DXEPCTL_STALL;\r\nelse {\r\nepctl &= ~DXEPCTL_STALL;\r\nxfertype = epctl & DXEPCTL_EPTYPE_MASK;\r\nif (xfertype == DXEPCTL_EPTYPE_BULK ||\r\nxfertype == DXEPCTL_EPTYPE_INTERRUPT)\r\nepctl |= DXEPCTL_SETD0PID;\r\n}\r\nwritel(epctl, hs->regs + epreg);\r\n}\r\nhs_ep->halted = value;\r\nreturn 0;\r\n}\r\nstatic int s3c_hsotg_ep_sethalt_lock(struct usb_ep *ep, int value)\r\n{\r\nstruct s3c_hsotg_ep *hs_ep = our_ep(ep);\r\nstruct dwc2_hsotg *hs = hs_ep->parent;\r\nunsigned long flags = 0;\r\nint ret = 0;\r\nspin_lock_irqsave(&hs->lock, flags);\r\nret = s3c_hsotg_ep_sethalt(ep, value);\r\nspin_unlock_irqrestore(&hs->lock, flags);\r\nreturn ret;\r\n}\r\nstatic void s3c_hsotg_phy_enable(struct dwc2_hsotg *hsotg)\r\n{\r\nstruct platform_device *pdev = to_platform_device(hsotg->dev);\r\ndev_dbg(hsotg->dev, "pdev 0x%p\n", pdev);\r\nif (hsotg->uphy)\r\nusb_phy_init(hsotg->uphy);\r\nelse if (hsotg->plat && hsotg->plat->phy_init)\r\nhsotg->plat->phy_init(pdev, hsotg->plat->phy_type);\r\nelse {\r\nphy_init(hsotg->phy);\r\nphy_power_on(hsotg->phy);\r\n}\r\n}\r\nstatic void s3c_hsotg_phy_disable(struct dwc2_hsotg *hsotg)\r\n{\r\nstruct platform_device *pdev = to_platform_device(hsotg->dev);\r\nif (hsotg->uphy)\r\nusb_phy_shutdown(hsotg->uphy);\r\nelse if (hsotg->plat && hsotg->plat->phy_exit)\r\nhsotg->plat->phy_exit(pdev, hsotg->plat->phy_type);\r\nelse {\r\nphy_power_off(hsotg->phy);\r\nphy_exit(hsotg->phy);\r\n}\r\n}\r\nstatic void s3c_hsotg_init(struct dwc2_hsotg *hsotg)\r\n{\r\nu32 trdtim;\r\nwritel(DIEPMSK_TIMEOUTMSK | DIEPMSK_AHBERRMSK |\r\nDIEPMSK_EPDISBLDMSK | DIEPMSK_XFERCOMPLMSK,\r\nhsotg->regs + DIEPMSK);\r\nwritel(DOEPMSK_SETUPMSK | DOEPMSK_AHBERRMSK |\r\nDOEPMSK_EPDISBLDMSK | DOEPMSK_XFERCOMPLMSK,\r\nhsotg->regs + DOEPMSK);\r\nwritel(0, hsotg->regs + DAINTMSK);\r\n__orr32(hsotg->regs + DCTL, DCTL_SFTDISCON);\r\ndev_dbg(hsotg->dev, "GRXFSIZ=0x%08x, GNPTXFSIZ=0x%08x\n",\r\nreadl(hsotg->regs + GRXFSIZ),\r\nreadl(hsotg->regs + GNPTXFSIZ));\r\ns3c_hsotg_init_fifo(hsotg);\r\ntrdtim = (hsotg->phyif == GUSBCFG_PHYIF8) ? 9 : 5;\r\nwritel(hsotg->phyif | GUSBCFG_TOUTCAL(7) |\r\n(trdtim << GUSBCFG_USBTRDTIM_SHIFT),\r\nhsotg->regs + GUSBCFG);\r\nif (using_dma(hsotg))\r\n__orr32(hsotg->regs + GAHBCFG, GAHBCFG_DMA_EN);\r\n}\r\nstatic int s3c_hsotg_udc_start(struct usb_gadget *gadget,\r\nstruct usb_gadget_driver *driver)\r\n{\r\nstruct dwc2_hsotg *hsotg = to_hsotg(gadget);\r\nunsigned long flags;\r\nint ret;\r\nif (!hsotg) {\r\npr_err("%s: called with no device\n", __func__);\r\nreturn -ENODEV;\r\n}\r\nif (!driver) {\r\ndev_err(hsotg->dev, "%s: no driver\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nif (driver->max_speed < USB_SPEED_FULL)\r\ndev_err(hsotg->dev, "%s: bad speed\n", __func__);\r\nif (!driver->setup) {\r\ndev_err(hsotg->dev, "%s: missing entry points\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nmutex_lock(&hsotg->init_mutex);\r\nWARN_ON(hsotg->driver);\r\ndriver->driver.bus = NULL;\r\nhsotg->driver = driver;\r\nhsotg->gadget.dev.of_node = hsotg->dev->of_node;\r\nhsotg->gadget.speed = USB_SPEED_UNKNOWN;\r\nclk_enable(hsotg->clk);\r\nret = regulator_bulk_enable(ARRAY_SIZE(hsotg->supplies),\r\nhsotg->supplies);\r\nif (ret) {\r\ndev_err(hsotg->dev, "failed to enable supplies: %d\n", ret);\r\ngoto err;\r\n}\r\ns3c_hsotg_phy_enable(hsotg);\r\nif (!IS_ERR_OR_NULL(hsotg->uphy))\r\notg_set_peripheral(hsotg->uphy->otg, &hsotg->gadget);\r\nspin_lock_irqsave(&hsotg->lock, flags);\r\ns3c_hsotg_init(hsotg);\r\ns3c_hsotg_core_init_disconnected(hsotg, false);\r\nhsotg->enabled = 0;\r\nspin_unlock_irqrestore(&hsotg->lock, flags);\r\ndev_info(hsotg->dev, "bound driver %s\n", driver->driver.name);\r\nmutex_unlock(&hsotg->init_mutex);\r\nreturn 0;\r\nerr:\r\nmutex_unlock(&hsotg->init_mutex);\r\nhsotg->driver = NULL;\r\nreturn ret;\r\n}\r\nstatic int s3c_hsotg_udc_stop(struct usb_gadget *gadget)\r\n{\r\nstruct dwc2_hsotg *hsotg = to_hsotg(gadget);\r\nunsigned long flags = 0;\r\nint ep;\r\nif (!hsotg)\r\nreturn -ENODEV;\r\nmutex_lock(&hsotg->init_mutex);\r\nfor (ep = 1; ep < hsotg->num_of_eps; ep++) {\r\nif (hsotg->eps_in[ep])\r\ns3c_hsotg_ep_disable(&hsotg->eps_in[ep]->ep);\r\nif (hsotg->eps_out[ep])\r\ns3c_hsotg_ep_disable(&hsotg->eps_out[ep]->ep);\r\n}\r\nspin_lock_irqsave(&hsotg->lock, flags);\r\nhsotg->driver = NULL;\r\nhsotg->gadget.speed = USB_SPEED_UNKNOWN;\r\nhsotg->enabled = 0;\r\nspin_unlock_irqrestore(&hsotg->lock, flags);\r\nif (!IS_ERR_OR_NULL(hsotg->uphy))\r\notg_set_peripheral(hsotg->uphy->otg, NULL);\r\ns3c_hsotg_phy_disable(hsotg);\r\nregulator_bulk_disable(ARRAY_SIZE(hsotg->supplies), hsotg->supplies);\r\nclk_disable(hsotg->clk);\r\nmutex_unlock(&hsotg->init_mutex);\r\nreturn 0;\r\n}\r\nstatic int s3c_hsotg_gadget_getframe(struct usb_gadget *gadget)\r\n{\r\nreturn s3c_hsotg_read_frameno(to_hsotg(gadget));\r\n}\r\nstatic int s3c_hsotg_pullup(struct usb_gadget *gadget, int is_on)\r\n{\r\nstruct dwc2_hsotg *hsotg = to_hsotg(gadget);\r\nunsigned long flags = 0;\r\ndev_dbg(hsotg->dev, "%s: is_on: %d\n", __func__, is_on);\r\nmutex_lock(&hsotg->init_mutex);\r\nspin_lock_irqsave(&hsotg->lock, flags);\r\nif (is_on) {\r\nclk_enable(hsotg->clk);\r\nhsotg->enabled = 1;\r\ns3c_hsotg_core_init_disconnected(hsotg, false);\r\ns3c_hsotg_core_connect(hsotg);\r\n} else {\r\ns3c_hsotg_core_disconnect(hsotg);\r\ns3c_hsotg_disconnect(hsotg);\r\nhsotg->enabled = 0;\r\nclk_disable(hsotg->clk);\r\n}\r\nhsotg->gadget.speed = USB_SPEED_UNKNOWN;\r\nspin_unlock_irqrestore(&hsotg->lock, flags);\r\nmutex_unlock(&hsotg->init_mutex);\r\nreturn 0;\r\n}\r\nstatic int s3c_hsotg_vbus_session(struct usb_gadget *gadget, int is_active)\r\n{\r\nstruct dwc2_hsotg *hsotg = to_hsotg(gadget);\r\nunsigned long flags;\r\ndev_dbg(hsotg->dev, "%s: is_active: %d\n", __func__, is_active);\r\nspin_lock_irqsave(&hsotg->lock, flags);\r\nif (is_active) {\r\nkill_all_requests(hsotg, hsotg->eps_out[0], -ECONNRESET);\r\ns3c_hsotg_core_init_disconnected(hsotg, false);\r\nif (hsotg->enabled)\r\ns3c_hsotg_core_connect(hsotg);\r\n} else {\r\ns3c_hsotg_core_disconnect(hsotg);\r\ns3c_hsotg_disconnect(hsotg);\r\n}\r\nspin_unlock_irqrestore(&hsotg->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int s3c_hsotg_vbus_draw(struct usb_gadget *gadget, unsigned mA)\r\n{\r\nstruct dwc2_hsotg *hsotg = to_hsotg(gadget);\r\nif (IS_ERR_OR_NULL(hsotg->uphy))\r\nreturn -ENOTSUPP;\r\nreturn usb_phy_set_power(hsotg->uphy, mA);\r\n}\r\nstatic void s3c_hsotg_initep(struct dwc2_hsotg *hsotg,\r\nstruct s3c_hsotg_ep *hs_ep,\r\nint epnum,\r\nbool dir_in)\r\n{\r\nchar *dir;\r\nif (epnum == 0)\r\ndir = "";\r\nelse if (dir_in)\r\ndir = "in";\r\nelse\r\ndir = "out";\r\nhs_ep->dir_in = dir_in;\r\nhs_ep->index = epnum;\r\nsnprintf(hs_ep->name, sizeof(hs_ep->name), "ep%d%s", epnum, dir);\r\nINIT_LIST_HEAD(&hs_ep->queue);\r\nINIT_LIST_HEAD(&hs_ep->ep.ep_list);\r\nif (epnum)\r\nlist_add_tail(&hs_ep->ep.ep_list, &hsotg->gadget.ep_list);\r\nhs_ep->parent = hsotg;\r\nhs_ep->ep.name = hs_ep->name;\r\nusb_ep_set_maxpacket_limit(&hs_ep->ep, epnum ? 1024 : EP0_MPS_LIMIT);\r\nhs_ep->ep.ops = &s3c_hsotg_ep_ops;\r\nif (using_dma(hsotg)) {\r\nu32 next = DXEPCTL_NEXTEP((epnum + 1) % 15);\r\nif (dir_in)\r\nwritel(next, hsotg->regs + DIEPCTL(epnum));\r\nelse\r\nwritel(next, hsotg->regs + DOEPCTL(epnum));\r\n}\r\n}\r\nstatic int s3c_hsotg_hw_cfg(struct dwc2_hsotg *hsotg)\r\n{\r\nu32 cfg;\r\nu32 ep_type;\r\nu32 i;\r\ncfg = readl(hsotg->regs + GHWCFG2);\r\nhsotg->num_of_eps = (cfg >> GHWCFG2_NUM_DEV_EP_SHIFT) & 0xF;\r\nhsotg->num_of_eps++;\r\nhsotg->eps_in[0] = devm_kzalloc(hsotg->dev, sizeof(struct s3c_hsotg_ep),\r\nGFP_KERNEL);\r\nif (!hsotg->eps_in[0])\r\nreturn -ENOMEM;\r\nhsotg->eps_out[0] = hsotg->eps_in[0];\r\ncfg = readl(hsotg->regs + GHWCFG1);\r\nfor (i = 1, cfg >>= 2; i < hsotg->num_of_eps; i++, cfg >>= 2) {\r\nep_type = cfg & 3;\r\nif (!(ep_type & 2)) {\r\nhsotg->eps_in[i] = devm_kzalloc(hsotg->dev,\r\nsizeof(struct s3c_hsotg_ep), GFP_KERNEL);\r\nif (!hsotg->eps_in[i])\r\nreturn -ENOMEM;\r\n}\r\nif (!(ep_type & 1)) {\r\nhsotg->eps_out[i] = devm_kzalloc(hsotg->dev,\r\nsizeof(struct s3c_hsotg_ep), GFP_KERNEL);\r\nif (!hsotg->eps_out[i])\r\nreturn -ENOMEM;\r\n}\r\n}\r\ncfg = readl(hsotg->regs + GHWCFG3);\r\nhsotg->fifo_mem = (cfg >> GHWCFG3_DFIFO_DEPTH_SHIFT);\r\ncfg = readl(hsotg->regs + GHWCFG4);\r\nhsotg->dedicated_fifos = (cfg >> GHWCFG4_DED_FIFO_SHIFT) & 1;\r\ndev_info(hsotg->dev, "EPs: %d, %s fifos, %d entries in SPRAM\n",\r\nhsotg->num_of_eps,\r\nhsotg->dedicated_fifos ? "dedicated" : "shared",\r\nhsotg->fifo_mem);\r\nreturn 0;\r\n}\r\nstatic void s3c_hsotg_dump(struct dwc2_hsotg *hsotg)\r\n{\r\n#ifdef DEBUG\r\nstruct device *dev = hsotg->dev;\r\nvoid __iomem *regs = hsotg->regs;\r\nu32 val;\r\nint idx;\r\ndev_info(dev, "DCFG=0x%08x, DCTL=0x%08x, DIEPMSK=%08x\n",\r\nreadl(regs + DCFG), readl(regs + DCTL),\r\nreadl(regs + DIEPMSK));\r\ndev_info(dev, "GAHBCFG=0x%08x, GHWCFG1=0x%08x\n",\r\nreadl(regs + GAHBCFG), readl(regs + GHWCFG1));\r\ndev_info(dev, "GRXFSIZ=0x%08x, GNPTXFSIZ=0x%08x\n",\r\nreadl(regs + GRXFSIZ), readl(regs + GNPTXFSIZ));\r\nfor (idx = 1; idx < hsotg->num_of_eps; idx++) {\r\nval = readl(regs + DPTXFSIZN(idx));\r\ndev_info(dev, "DPTx[%d] FSize=%d, StAddr=0x%08x\n", idx,\r\nval >> FIFOSIZE_DEPTH_SHIFT,\r\nval & FIFOSIZE_STARTADDR_MASK);\r\n}\r\nfor (idx = 0; idx < hsotg->num_of_eps; idx++) {\r\ndev_info(dev,\r\n"ep%d-in: EPCTL=0x%08x, SIZ=0x%08x, DMA=0x%08x\n", idx,\r\nreadl(regs + DIEPCTL(idx)),\r\nreadl(regs + DIEPTSIZ(idx)),\r\nreadl(regs + DIEPDMA(idx)));\r\nval = readl(regs + DOEPCTL(idx));\r\ndev_info(dev,\r\n"ep%d-out: EPCTL=0x%08x, SIZ=0x%08x, DMA=0x%08x\n",\r\nidx, readl(regs + DOEPCTL(idx)),\r\nreadl(regs + DOEPTSIZ(idx)),\r\nreadl(regs + DOEPDMA(idx)));\r\n}\r\ndev_info(dev, "DVBUSDIS=0x%08x, DVBUSPULSE=%08x\n",\r\nreadl(regs + DVBUSDIS), readl(regs + DVBUSPULSE));\r\n#endif\r\n}\r\nstatic ssize_t testmode_write(struct file *file, const char __user *ubuf, size_t\r\ncount, loff_t *ppos)\r\n{\r\nstruct seq_file *s = file->private_data;\r\nstruct dwc2_hsotg *hsotg = s->private;\r\nunsigned long flags;\r\nu32 testmode = 0;\r\nchar buf[32];\r\nif (copy_from_user(&buf, ubuf, min_t(size_t, sizeof(buf) - 1, count)))\r\nreturn -EFAULT;\r\nif (!strncmp(buf, "test_j", 6))\r\ntestmode = TEST_J;\r\nelse if (!strncmp(buf, "test_k", 6))\r\ntestmode = TEST_K;\r\nelse if (!strncmp(buf, "test_se0_nak", 12))\r\ntestmode = TEST_SE0_NAK;\r\nelse if (!strncmp(buf, "test_packet", 11))\r\ntestmode = TEST_PACKET;\r\nelse if (!strncmp(buf, "test_force_enable", 17))\r\ntestmode = TEST_FORCE_EN;\r\nelse\r\ntestmode = 0;\r\nspin_lock_irqsave(&hsotg->lock, flags);\r\ns3c_hsotg_set_test_mode(hsotg, testmode);\r\nspin_unlock_irqrestore(&hsotg->lock, flags);\r\nreturn count;\r\n}\r\nstatic int testmode_show(struct seq_file *s, void *unused)\r\n{\r\nstruct dwc2_hsotg *hsotg = s->private;\r\nunsigned long flags;\r\nint dctl;\r\nspin_lock_irqsave(&hsotg->lock, flags);\r\ndctl = readl(hsotg->regs + DCTL);\r\ndctl &= DCTL_TSTCTL_MASK;\r\ndctl >>= DCTL_TSTCTL_SHIFT;\r\nspin_unlock_irqrestore(&hsotg->lock, flags);\r\nswitch (dctl) {\r\ncase 0:\r\nseq_puts(s, "no test\n");\r\nbreak;\r\ncase TEST_J:\r\nseq_puts(s, "test_j\n");\r\nbreak;\r\ncase TEST_K:\r\nseq_puts(s, "test_k\n");\r\nbreak;\r\ncase TEST_SE0_NAK:\r\nseq_puts(s, "test_se0_nak\n");\r\nbreak;\r\ncase TEST_PACKET:\r\nseq_puts(s, "test_packet\n");\r\nbreak;\r\ncase TEST_FORCE_EN:\r\nseq_puts(s, "test_force_enable\n");\r\nbreak;\r\ndefault:\r\nseq_printf(s, "UNKNOWN %d\n", dctl);\r\n}\r\nreturn 0;\r\n}\r\nstatic int testmode_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, testmode_show, inode->i_private);\r\n}\r\nstatic int state_show(struct seq_file *seq, void *v)\r\n{\r\nstruct dwc2_hsotg *hsotg = seq->private;\r\nvoid __iomem *regs = hsotg->regs;\r\nint idx;\r\nseq_printf(seq, "DCFG=0x%08x, DCTL=0x%08x, DSTS=0x%08x\n",\r\nreadl(regs + DCFG),\r\nreadl(regs + DCTL),\r\nreadl(regs + DSTS));\r\nseq_printf(seq, "DIEPMSK=0x%08x, DOEPMASK=0x%08x\n",\r\nreadl(regs + DIEPMSK), readl(regs + DOEPMSK));\r\nseq_printf(seq, "GINTMSK=0x%08x, GINTSTS=0x%08x\n",\r\nreadl(regs + GINTMSK),\r\nreadl(regs + GINTSTS));\r\nseq_printf(seq, "DAINTMSK=0x%08x, DAINT=0x%08x\n",\r\nreadl(regs + DAINTMSK),\r\nreadl(regs + DAINT));\r\nseq_printf(seq, "GNPTXSTS=0x%08x, GRXSTSR=%08x\n",\r\nreadl(regs + GNPTXSTS),\r\nreadl(regs + GRXSTSR));\r\nseq_puts(seq, "\nEndpoint status:\n");\r\nfor (idx = 0; idx < hsotg->num_of_eps; idx++) {\r\nu32 in, out;\r\nin = readl(regs + DIEPCTL(idx));\r\nout = readl(regs + DOEPCTL(idx));\r\nseq_printf(seq, "ep%d: DIEPCTL=0x%08x, DOEPCTL=0x%08x",\r\nidx, in, out);\r\nin = readl(regs + DIEPTSIZ(idx));\r\nout = readl(regs + DOEPTSIZ(idx));\r\nseq_printf(seq, ", DIEPTSIZ=0x%08x, DOEPTSIZ=0x%08x",\r\nin, out);\r\nseq_puts(seq, "\n");\r\n}\r\nreturn 0;\r\n}\r\nstatic int state_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, state_show, inode->i_private);\r\n}\r\nstatic int fifo_show(struct seq_file *seq, void *v)\r\n{\r\nstruct dwc2_hsotg *hsotg = seq->private;\r\nvoid __iomem *regs = hsotg->regs;\r\nu32 val;\r\nint idx;\r\nseq_puts(seq, "Non-periodic FIFOs:\n");\r\nseq_printf(seq, "RXFIFO: Size %d\n", readl(regs + GRXFSIZ));\r\nval = readl(regs + GNPTXFSIZ);\r\nseq_printf(seq, "NPTXFIFO: Size %d, Start 0x%08x\n",\r\nval >> FIFOSIZE_DEPTH_SHIFT,\r\nval & FIFOSIZE_DEPTH_MASK);\r\nseq_puts(seq, "\nPeriodic TXFIFOs:\n");\r\nfor (idx = 1; idx < hsotg->num_of_eps; idx++) {\r\nval = readl(regs + DPTXFSIZN(idx));\r\nseq_printf(seq, "\tDPTXFIFO%2d: Size %d, Start 0x%08x\n", idx,\r\nval >> FIFOSIZE_DEPTH_SHIFT,\r\nval & FIFOSIZE_STARTADDR_MASK);\r\n}\r\nreturn 0;\r\n}\r\nstatic int fifo_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, fifo_show, inode->i_private);\r\n}\r\nstatic const char *decode_direction(int is_in)\r\n{\r\nreturn is_in ? "in" : "out";\r\n}\r\nstatic int ep_show(struct seq_file *seq, void *v)\r\n{\r\nstruct s3c_hsotg_ep *ep = seq->private;\r\nstruct dwc2_hsotg *hsotg = ep->parent;\r\nstruct s3c_hsotg_req *req;\r\nvoid __iomem *regs = hsotg->regs;\r\nint index = ep->index;\r\nint show_limit = 15;\r\nunsigned long flags;\r\nseq_printf(seq, "Endpoint index %d, named %s, dir %s:\n",\r\nep->index, ep->ep.name, decode_direction(ep->dir_in));\r\nseq_printf(seq, "\tDIEPCTL=0x%08x, DOEPCTL=0x%08x\n",\r\nreadl(regs + DIEPCTL(index)),\r\nreadl(regs + DOEPCTL(index)));\r\nseq_printf(seq, "\tDIEPDMA=0x%08x, DOEPDMA=0x%08x\n",\r\nreadl(regs + DIEPDMA(index)),\r\nreadl(regs + DOEPDMA(index)));\r\nseq_printf(seq, "\tDIEPINT=0x%08x, DOEPINT=0x%08x\n",\r\nreadl(regs + DIEPINT(index)),\r\nreadl(regs + DOEPINT(index)));\r\nseq_printf(seq, "\tDIEPTSIZ=0x%08x, DOEPTSIZ=0x%08x\n",\r\nreadl(regs + DIEPTSIZ(index)),\r\nreadl(regs + DOEPTSIZ(index)));\r\nseq_puts(seq, "\n");\r\nseq_printf(seq, "mps %d\n", ep->ep.maxpacket);\r\nseq_printf(seq, "total_data=%ld\n", ep->total_data);\r\nseq_printf(seq, "request list (%p,%p):\n",\r\nep->queue.next, ep->queue.prev);\r\nspin_lock_irqsave(&hsotg->lock, flags);\r\nlist_for_each_entry(req, &ep->queue, queue) {\r\nif (--show_limit < 0) {\r\nseq_puts(seq, "not showing more requests...\n");\r\nbreak;\r\n}\r\nseq_printf(seq, "%c req %p: %d bytes @%p, ",\r\nreq == ep->req ? '*' : ' ',\r\nreq, req->req.length, req->req.buf);\r\nseq_printf(seq, "%d done, res %d\n",\r\nreq->req.actual, req->req.status);\r\n}\r\nspin_unlock_irqrestore(&hsotg->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int ep_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, ep_show, inode->i_private);\r\n}\r\nstatic void s3c_hsotg_create_debug(struct dwc2_hsotg *hsotg)\r\n{\r\nstruct dentry *root;\r\nunsigned epidx;\r\nroot = debugfs_create_dir(dev_name(hsotg->dev), NULL);\r\nhsotg->debug_root = root;\r\nif (IS_ERR(root)) {\r\ndev_err(hsotg->dev, "cannot create debug root\n");\r\nreturn;\r\n}\r\nhsotg->debug_file = debugfs_create_file("state", S_IRUGO, root,\r\nhsotg, &state_fops);\r\nif (IS_ERR(hsotg->debug_file))\r\ndev_err(hsotg->dev, "%s: failed to create state\n", __func__);\r\nhsotg->debug_testmode = debugfs_create_file("testmode",\r\nS_IRUGO | S_IWUSR, root,\r\nhsotg, &testmode_fops);\r\nif (IS_ERR(hsotg->debug_testmode))\r\ndev_err(hsotg->dev, "%s: failed to create testmode\n",\r\n__func__);\r\nhsotg->debug_fifo = debugfs_create_file("fifo", S_IRUGO, root,\r\nhsotg, &fifo_fops);\r\nif (IS_ERR(hsotg->debug_fifo))\r\ndev_err(hsotg->dev, "%s: failed to create fifo\n", __func__);\r\nfor (epidx = 0; epidx < hsotg->num_of_eps; epidx++) {\r\nstruct s3c_hsotg_ep *ep;\r\nep = hsotg->eps_out[epidx];\r\nif (ep) {\r\nep->debugfs = debugfs_create_file(ep->name, S_IRUGO,\r\nroot, ep, &ep_fops);\r\nif (IS_ERR(ep->debugfs))\r\ndev_err(hsotg->dev, "failed to create %s debug file\n",\r\nep->name);\r\n}\r\n}\r\nfor (epidx = 1; epidx < hsotg->num_of_eps; epidx++) {\r\nstruct s3c_hsotg_ep *ep;\r\nep = hsotg->eps_in[epidx];\r\nif (ep) {\r\nep->debugfs = debugfs_create_file(ep->name, S_IRUGO,\r\nroot, ep, &ep_fops);\r\nif (IS_ERR(ep->debugfs))\r\ndev_err(hsotg->dev, "failed to create %s debug file\n",\r\nep->name);\r\n}\r\n}\r\n}\r\nstatic void s3c_hsotg_delete_debug(struct dwc2_hsotg *hsotg)\r\n{\r\nunsigned epidx;\r\nfor (epidx = 0; epidx < hsotg->num_of_eps; epidx++) {\r\nif (hsotg->eps_in[epidx])\r\ndebugfs_remove(hsotg->eps_in[epidx]->debugfs);\r\nif (hsotg->eps_out[epidx])\r\ndebugfs_remove(hsotg->eps_out[epidx]->debugfs);\r\n}\r\ndebugfs_remove(hsotg->debug_file);\r\ndebugfs_remove(hsotg->debug_testmode);\r\ndebugfs_remove(hsotg->debug_fifo);\r\ndebugfs_remove(hsotg->debug_root);\r\n}\r\nstatic void s3c_hsotg_of_probe(struct dwc2_hsotg *hsotg)\r\n{\r\nstruct device_node *np = hsotg->dev->of_node;\r\nu32 len = 0;\r\nu32 i = 0;\r\nhsotg->g_using_dma = of_property_read_bool(np, "g-use-dma");\r\nif (!of_find_property(np, "g-tx-fifo-size", &len))\r\ngoto rx_fifo;\r\nlen /= sizeof(u32);\r\nif (of_property_read_u32_array(np, "g-tx-fifo-size",\r\n&hsotg->g_tx_fifo_sz[1], len))\r\ngoto rx_fifo;\r\nlen++;\r\nif (len < MAX_EPS_CHANNELS) {\r\nfor (i = len; i < MAX_EPS_CHANNELS; i++)\r\nhsotg->g_tx_fifo_sz[i] = 0;\r\n}\r\nrx_fifo:\r\nof_property_read_u32(np, "g-rx-fifo-size", &hsotg->g_rx_fifo_sz);\r\nof_property_read_u32(np, "g-np-tx-fifo-size",\r\n&hsotg->g_np_g_tx_fifo_sz);\r\n}\r\nstatic inline void s3c_hsotg_of_probe(struct dwc2_hsotg *hsotg) { }\r\nint dwc2_gadget_init(struct dwc2_hsotg *hsotg, int irq)\r\n{\r\nstruct device *dev = hsotg->dev;\r\nstruct s3c_hsotg_plat *plat = dev->platform_data;\r\nint epnum;\r\nint ret;\r\nint i;\r\nu32 p_tx_fifo[] = DWC2_G_P_LEGACY_TX_FIFO_SIZE;\r\nhsotg->phyif = GUSBCFG_PHYIF16;\r\ns3c_hsotg_of_probe(hsotg);\r\nhsotg->g_rx_fifo_sz = 2048;\r\nhsotg->g_np_g_tx_fifo_sz = 1024;\r\nmemcpy(&hsotg->g_tx_fifo_sz[1], p_tx_fifo, sizeof(p_tx_fifo));\r\ns3c_hsotg_of_probe(hsotg);\r\ndev_dbg(dev, "NonPeriodic TXFIFO size: %d\n",\r\nhsotg->g_np_g_tx_fifo_sz);\r\ndev_dbg(dev, "RXFIFO size: %d\n", hsotg->g_rx_fifo_sz);\r\nfor (i = 0; i < MAX_EPS_CHANNELS; i++)\r\ndev_dbg(dev, "Periodic TXFIFO%2d size: %d\n", i,\r\nhsotg->g_tx_fifo_sz[i]);\r\nif (IS_ERR_OR_NULL(hsotg->phy) && IS_ERR_OR_NULL(hsotg->uphy)) {\r\nplat = dev_get_platdata(dev);\r\nif (!plat) {\r\ndev_err(dev,\r\n"no platform data or transceiver defined\n");\r\nreturn -EPROBE_DEFER;\r\n}\r\nhsotg->plat = plat;\r\n} else if (hsotg->phy) {\r\nif (phy_get_bus_width(hsotg->phy) == 8)\r\nhsotg->phyif = GUSBCFG_PHYIF8;\r\n}\r\nhsotg->clk = devm_clk_get(dev, "otg");\r\nif (IS_ERR(hsotg->clk)) {\r\nhsotg->clk = NULL;\r\ndev_dbg(dev, "cannot get otg clock\n");\r\n}\r\nhsotg->gadget.max_speed = USB_SPEED_HIGH;\r\nhsotg->gadget.ops = &s3c_hsotg_gadget_ops;\r\nhsotg->gadget.name = dev_name(dev);\r\nret = clk_prepare_enable(hsotg->clk);\r\nif (ret) {\r\ndev_err(dev, "failed to enable otg clk\n");\r\ngoto err_clk;\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(hsotg->supplies); i++)\r\nhsotg->supplies[i].supply = s3c_hsotg_supply_names[i];\r\nret = devm_regulator_bulk_get(dev, ARRAY_SIZE(hsotg->supplies),\r\nhsotg->supplies);\r\nif (ret) {\r\ndev_err(dev, "failed to request supplies: %d\n", ret);\r\ngoto err_clk;\r\n}\r\nret = regulator_bulk_enable(ARRAY_SIZE(hsotg->supplies),\r\nhsotg->supplies);\r\nif (ret) {\r\ndev_err(dev, "failed to enable supplies: %d\n", ret);\r\ngoto err_clk;\r\n}\r\ns3c_hsotg_phy_enable(hsotg);\r\n__bic32(hsotg->regs + GUSBCFG, GUSBCFG_FORCEHOSTMODE);\r\n__orr32(hsotg->regs + GUSBCFG, GUSBCFG_FORCEDEVMODE);\r\nmsleep(25);\r\ns3c_hsotg_corereset(hsotg);\r\nret = s3c_hsotg_hw_cfg(hsotg);\r\nif (ret) {\r\ndev_err(hsotg->dev, "Hardware configuration failed: %d\n", ret);\r\ngoto err_clk;\r\n}\r\ns3c_hsotg_init(hsotg);\r\n__bic32(hsotg->regs + GUSBCFG, GUSBCFG_FORCEDEVMODE);\r\nhsotg->ctrl_buff = devm_kzalloc(hsotg->dev,\r\nDWC2_CTRL_BUFF_SIZE, GFP_KERNEL);\r\nif (!hsotg->ctrl_buff) {\r\ndev_err(dev, "failed to allocate ctrl request buff\n");\r\nret = -ENOMEM;\r\ngoto err_supplies;\r\n}\r\nhsotg->ep0_buff = devm_kzalloc(hsotg->dev,\r\nDWC2_CTRL_BUFF_SIZE, GFP_KERNEL);\r\nif (!hsotg->ep0_buff) {\r\ndev_err(dev, "failed to allocate ctrl reply buff\n");\r\nret = -ENOMEM;\r\ngoto err_supplies;\r\n}\r\nret = devm_request_irq(hsotg->dev, irq, s3c_hsotg_irq, IRQF_SHARED,\r\ndev_name(hsotg->dev), hsotg);\r\nif (ret < 0) {\r\ns3c_hsotg_phy_disable(hsotg);\r\nclk_disable_unprepare(hsotg->clk);\r\nregulator_bulk_disable(ARRAY_SIZE(hsotg->supplies),\r\nhsotg->supplies);\r\ndev_err(dev, "cannot claim IRQ for gadget\n");\r\ngoto err_supplies;\r\n}\r\nif (hsotg->num_of_eps == 0) {\r\ndev_err(dev, "wrong number of EPs (zero)\n");\r\nret = -EINVAL;\r\ngoto err_supplies;\r\n}\r\nINIT_LIST_HEAD(&hsotg->gadget.ep_list);\r\nhsotg->gadget.ep0 = &hsotg->eps_out[0]->ep;\r\nhsotg->ctrl_req = s3c_hsotg_ep_alloc_request(&hsotg->eps_out[0]->ep,\r\nGFP_KERNEL);\r\nif (!hsotg->ctrl_req) {\r\ndev_err(dev, "failed to allocate ctrl req\n");\r\nret = -ENOMEM;\r\ngoto err_supplies;\r\n}\r\nfor (epnum = 0; epnum < hsotg->num_of_eps; epnum++) {\r\nif (hsotg->eps_in[epnum])\r\ns3c_hsotg_initep(hsotg, hsotg->eps_in[epnum],\r\nepnum, 1);\r\nif (hsotg->eps_out[epnum])\r\ns3c_hsotg_initep(hsotg, hsotg->eps_out[epnum],\r\nepnum, 0);\r\n}\r\ns3c_hsotg_phy_disable(hsotg);\r\nret = regulator_bulk_disable(ARRAY_SIZE(hsotg->supplies),\r\nhsotg->supplies);\r\nif (ret) {\r\ndev_err(dev, "failed to disable supplies: %d\n", ret);\r\ngoto err_supplies;\r\n}\r\nret = usb_add_gadget_udc(dev, &hsotg->gadget);\r\nif (ret)\r\ngoto err_supplies;\r\ns3c_hsotg_create_debug(hsotg);\r\ns3c_hsotg_dump(hsotg);\r\nreturn 0;\r\nerr_supplies:\r\ns3c_hsotg_phy_disable(hsotg);\r\nerr_clk:\r\nclk_disable_unprepare(hsotg->clk);\r\nreturn ret;\r\n}\r\nint s3c_hsotg_remove(struct dwc2_hsotg *hsotg)\r\n{\r\nusb_del_gadget_udc(&hsotg->gadget);\r\ns3c_hsotg_delete_debug(hsotg);\r\nclk_disable_unprepare(hsotg->clk);\r\nreturn 0;\r\n}\r\nint s3c_hsotg_suspend(struct dwc2_hsotg *hsotg)\r\n{\r\nunsigned long flags;\r\nint ret = 0;\r\nmutex_lock(&hsotg->init_mutex);\r\nif (hsotg->driver) {\r\nint ep;\r\ndev_info(hsotg->dev, "suspending usb gadget %s\n",\r\nhsotg->driver->driver.name);\r\nspin_lock_irqsave(&hsotg->lock, flags);\r\nif (hsotg->enabled)\r\ns3c_hsotg_core_disconnect(hsotg);\r\ns3c_hsotg_disconnect(hsotg);\r\nhsotg->gadget.speed = USB_SPEED_UNKNOWN;\r\nspin_unlock_irqrestore(&hsotg->lock, flags);\r\ns3c_hsotg_phy_disable(hsotg);\r\nfor (ep = 0; ep < hsotg->num_of_eps; ep++) {\r\nif (hsotg->eps_in[ep])\r\ns3c_hsotg_ep_disable(&hsotg->eps_in[ep]->ep);\r\nif (hsotg->eps_out[ep])\r\ns3c_hsotg_ep_disable(&hsotg->eps_out[ep]->ep);\r\n}\r\nret = regulator_bulk_disable(ARRAY_SIZE(hsotg->supplies),\r\nhsotg->supplies);\r\nclk_disable(hsotg->clk);\r\n}\r\nmutex_unlock(&hsotg->init_mutex);\r\nreturn ret;\r\n}\r\nint s3c_hsotg_resume(struct dwc2_hsotg *hsotg)\r\n{\r\nunsigned long flags;\r\nint ret = 0;\r\nmutex_lock(&hsotg->init_mutex);\r\nif (hsotg->driver) {\r\ndev_info(hsotg->dev, "resuming usb gadget %s\n",\r\nhsotg->driver->driver.name);\r\nclk_enable(hsotg->clk);\r\nret = regulator_bulk_enable(ARRAY_SIZE(hsotg->supplies),\r\nhsotg->supplies);\r\ns3c_hsotg_phy_enable(hsotg);\r\nspin_lock_irqsave(&hsotg->lock, flags);\r\ns3c_hsotg_core_init_disconnected(hsotg, false);\r\nif (hsotg->enabled)\r\ns3c_hsotg_core_connect(hsotg);\r\nspin_unlock_irqrestore(&hsotg->lock, flags);\r\n}\r\nmutex_unlock(&hsotg->init_mutex);\r\nreturn ret;\r\n}
