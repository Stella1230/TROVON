int default_machine_kexec_prepare(struct kimage *image)\r\n{\r\nint i;\r\nunsigned long begin, end;\r\nunsigned long low, high;\r\nstruct device_node *node;\r\nconst unsigned long *basep;\r\nconst unsigned int *sizep;\r\nif (!ppc_md.hpte_clear_all)\r\nreturn -ENOENT;\r\nfor (i = 0; i < image->nr_segments; i++)\r\nif (image->segment[i].mem < __pa(_end))\r\nreturn -ETXTBSY;\r\nif (htab_address) {\r\nlow = __pa(htab_address);\r\nhigh = low + htab_size_bytes;\r\nfor (i = 0; i < image->nr_segments; i++) {\r\nbegin = image->segment[i].mem;\r\nend = begin + image->segment[i].memsz;\r\nif ((begin < high) && (end > low))\r\nreturn -ETXTBSY;\r\n}\r\n}\r\nfor_each_node_by_type(node, "pci") {\r\nbasep = of_get_property(node, "linux,tce-base", NULL);\r\nsizep = of_get_property(node, "linux,tce-size", NULL);\r\nif (basep == NULL || sizep == NULL)\r\ncontinue;\r\nlow = *basep;\r\nhigh = low + (*sizep);\r\nfor (i = 0; i < image->nr_segments; i++) {\r\nbegin = image->segment[i].mem;\r\nend = begin + image->segment[i].memsz;\r\nif ((begin < high) && (end > low))\r\nreturn -ETXTBSY;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void copy_segments(unsigned long ind)\r\n{\r\nunsigned long entry;\r\nunsigned long *ptr;\r\nvoid *dest;\r\nvoid *addr;\r\nptr = NULL;\r\ndest = NULL;\r\nfor (entry = ind; !(entry & IND_DONE); entry = *ptr++) {\r\naddr = __va(entry & PAGE_MASK);\r\nswitch (entry & IND_FLAGS) {\r\ncase IND_DESTINATION:\r\ndest = addr;\r\nbreak;\r\ncase IND_INDIRECTION:\r\nptr = addr;\r\nbreak;\r\ncase IND_SOURCE:\r\ncopy_page(dest, addr);\r\ndest += PAGE_SIZE;\r\n}\r\n}\r\n}\r\nvoid kexec_copy_flush(struct kimage *image)\r\n{\r\nlong i, nr_segments = image->nr_segments;\r\nstruct kexec_segment ranges[KEXEC_SEGMENT_MAX];\r\nmemcpy(ranges, image->segment, sizeof(ranges));\r\ncopy_segments(image->head);\r\nfor (i = 0; i < nr_segments; i++)\r\nflush_icache_range((unsigned long)__va(ranges[i].mem),\r\n(unsigned long)__va(ranges[i].mem + ranges[i].memsz));\r\n}\r\nstatic void kexec_smp_down(void *arg)\r\n{\r\nlocal_irq_disable();\r\nhard_irq_disable();\r\nmb();\r\nget_paca()->kexec_state = KEXEC_STATE_IRQS_OFF;\r\nwhile(kexec_all_irq_disabled == 0)\r\ncpu_relax();\r\nmb();\r\nhw_breakpoint_disable();\r\nif (ppc_md.kexec_cpu_down)\r\nppc_md.kexec_cpu_down(0, 1);\r\nkexec_smp_wait();\r\n}\r\nstatic void kexec_prepare_cpus_wait(int wait_state)\r\n{\r\nint my_cpu, i, notified=-1;\r\nhw_breakpoint_disable();\r\nmy_cpu = get_cpu();\r\nfor_each_online_cpu(i) {\r\nif (i == my_cpu)\r\ncontinue;\r\nwhile (paca[i].kexec_state < wait_state) {\r\nbarrier();\r\nif (i != notified) {\r\nprintk(KERN_INFO "kexec: waiting for cpu %d "\r\n"(physical %d) to enter %i state\n",\r\ni, paca[i].hw_cpu_id, wait_state);\r\nnotified = i;\r\n}\r\n}\r\n}\r\nmb();\r\n}\r\nstatic void wake_offline_cpus(void)\r\n{\r\nint cpu = 0;\r\nfor_each_present_cpu(cpu) {\r\nif (!cpu_online(cpu)) {\r\nprintk(KERN_INFO "kexec: Waking offline cpu %d.\n",\r\ncpu);\r\nWARN_ON(cpu_up(cpu));\r\n}\r\n}\r\n}\r\nstatic void kexec_prepare_cpus(void)\r\n{\r\nwake_offline_cpus();\r\nsmp_call_function(kexec_smp_down, NULL, 0);\r\nlocal_irq_disable();\r\nhard_irq_disable();\r\nmb();\r\nget_paca()->kexec_state = KEXEC_STATE_IRQS_OFF;\r\nkexec_prepare_cpus_wait(KEXEC_STATE_IRQS_OFF);\r\nkexec_all_irq_disabled = 1;\r\nif (ppc_md.kexec_cpu_down)\r\nppc_md.kexec_cpu_down(0, 0);\r\nkexec_prepare_cpus_wait(KEXEC_STATE_REAL_MODE);\r\nput_cpu();\r\n}\r\nstatic void kexec_prepare_cpus(void)\r\n{\r\nsmp_release_cpus();\r\nif (ppc_md.kexec_cpu_down)\r\nppc_md.kexec_cpu_down(0, 0);\r\nlocal_irq_disable();\r\nhard_irq_disable();\r\n}\r\nvoid default_machine_kexec(struct kimage *image)\r\n{\r\nif (!kdump_in_progress())\r\nkexec_prepare_cpus();\r\npr_debug("kexec: Starting switchover sequence.\n");\r\nkexec_stack.thread_info.task = current_thread_info()->task;\r\nkexec_stack.thread_info.flags = 0;\r\nkexec_stack.thread_info.preempt_count = HARDIRQ_OFFSET;\r\nkexec_stack.thread_info.cpu = current_thread_info()->cpu;\r\nmemcpy(&kexec_paca, get_paca(), sizeof(struct paca_struct));\r\nkexec_paca.data_offset = 0xedeaddeadeeeeeeeUL;\r\npaca = (struct paca_struct *)RELOC_HIDE(&kexec_paca, 0) -\r\nkexec_paca.paca_index;\r\nsetup_paca(&kexec_paca);\r\nkexec_sequence(&kexec_stack, image->start, image,\r\npage_address(image->control_code_page),\r\nppc_md.hpte_clear_all);\r\n}\r\nstatic int __init export_htab_values(void)\r\n{\r\nstruct device_node *node;\r\nstruct property *prop;\r\nif (!htab_address)\r\nreturn -ENODEV;\r\nnode = of_find_node_by_path("/chosen");\r\nif (!node)\r\nreturn -ENODEV;\r\nprop = of_find_property(node, htab_base_prop.name, NULL);\r\nif (prop)\r\nof_remove_property(node, prop);\r\nprop = of_find_property(node, htab_size_prop.name, NULL);\r\nif (prop)\r\nof_remove_property(node, prop);\r\nhtab_base = cpu_to_be64(__pa(htab_address));\r\nof_add_property(node, &htab_base_prop);\r\nhtab_size = cpu_to_be64(htab_size_bytes);\r\nof_add_property(node, &htab_size_prop);\r\nof_node_put(node);\r\nreturn 0;\r\n}
