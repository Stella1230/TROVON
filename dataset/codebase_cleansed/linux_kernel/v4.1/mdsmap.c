int ceph_mdsmap_get_random_mds(struct ceph_mdsmap *m)\r\n{\r\nint n = 0;\r\nint i;\r\nif (1 == m->m_max_mds && m->m_info[0].state > 0)\r\nreturn 0;\r\nfor (i = 0; i < m->m_max_mds; i++)\r\nif (m->m_info[i].state > 0)\r\nn++;\r\nif (n == 0)\r\nreturn -1;\r\nn = prandom_u32() % n;\r\ni = 0;\r\nfor (i = 0; n > 0; i++, n--)\r\nwhile (m->m_info[i].state <= 0)\r\ni++;\r\nreturn i;\r\n}\r\nstruct ceph_mdsmap *ceph_mdsmap_decode(void **p, void *end)\r\n{\r\nstruct ceph_mdsmap *m;\r\nconst void *start = *p;\r\nint i, j, n;\r\nint err = -EINVAL;\r\nu16 version;\r\nm = kzalloc(sizeof(*m), GFP_NOFS);\r\nif (m == NULL)\r\nreturn ERR_PTR(-ENOMEM);\r\nceph_decode_16_safe(p, end, version, bad);\r\nif (version > 3) {\r\npr_warn("got mdsmap version %d > 3, failing", version);\r\ngoto bad;\r\n}\r\nceph_decode_need(p, end, 8*sizeof(u32) + sizeof(u64), bad);\r\nm->m_epoch = ceph_decode_32(p);\r\nm->m_client_epoch = ceph_decode_32(p);\r\nm->m_last_failure = ceph_decode_32(p);\r\nm->m_root = ceph_decode_32(p);\r\nm->m_session_timeout = ceph_decode_32(p);\r\nm->m_session_autoclose = ceph_decode_32(p);\r\nm->m_max_file_size = ceph_decode_64(p);\r\nm->m_max_mds = ceph_decode_32(p);\r\nm->m_info = kcalloc(m->m_max_mds, sizeof(*m->m_info), GFP_NOFS);\r\nif (m->m_info == NULL)\r\ngoto badmem;\r\nn = ceph_decode_32(p);\r\nfor (i = 0; i < n; i++) {\r\nu64 global_id;\r\nu32 namelen;\r\ns32 mds, inc, state;\r\nu64 state_seq;\r\nu8 infoversion;\r\nstruct ceph_entity_addr addr;\r\nu32 num_export_targets;\r\nvoid *pexport_targets = NULL;\r\nstruct ceph_timespec laggy_since;\r\nstruct ceph_mds_info *info;\r\nceph_decode_need(p, end, sizeof(u64)*2 + 1 + sizeof(u32), bad);\r\nglobal_id = ceph_decode_64(p);\r\ninfoversion = ceph_decode_8(p);\r\n*p += sizeof(u64);\r\nnamelen = ceph_decode_32(p);\r\n*p += namelen;\r\nceph_decode_need(p, end,\r\n4*sizeof(u32) + sizeof(u64) +\r\nsizeof(addr) + sizeof(struct ceph_timespec),\r\nbad);\r\nmds = ceph_decode_32(p);\r\ninc = ceph_decode_32(p);\r\nstate = ceph_decode_32(p);\r\nstate_seq = ceph_decode_64(p);\r\nceph_decode_copy(p, &addr, sizeof(addr));\r\nceph_decode_addr(&addr);\r\nceph_decode_copy(p, &laggy_since, sizeof(laggy_since));\r\n*p += sizeof(u32);\r\nceph_decode_32_safe(p, end, namelen, bad);\r\n*p += namelen;\r\nif (infoversion >= 2) {\r\nceph_decode_32_safe(p, end, num_export_targets, bad);\r\npexport_targets = *p;\r\n*p += num_export_targets * sizeof(u32);\r\n} else {\r\nnum_export_targets = 0;\r\n}\r\ndout("mdsmap_decode %d/%d %lld mds%d.%d %s %s\n",\r\ni+1, n, global_id, mds, inc,\r\nceph_pr_addr(&addr.in_addr),\r\nceph_mds_state_name(state));\r\nif (mds < 0 || mds >= m->m_max_mds || state <= 0)\r\ncontinue;\r\ninfo = &m->m_info[mds];\r\ninfo->global_id = global_id;\r\ninfo->state = state;\r\ninfo->addr = addr;\r\ninfo->laggy = (laggy_since.tv_sec != 0 ||\r\nlaggy_since.tv_nsec != 0);\r\ninfo->num_export_targets = num_export_targets;\r\nif (num_export_targets) {\r\ninfo->export_targets = kcalloc(num_export_targets,\r\nsizeof(u32), GFP_NOFS);\r\nif (info->export_targets == NULL)\r\ngoto badmem;\r\nfor (j = 0; j < num_export_targets; j++)\r\ninfo->export_targets[j] =\r\nceph_decode_32(&pexport_targets);\r\n} else {\r\ninfo->export_targets = NULL;\r\n}\r\n}\r\nceph_decode_32_safe(p, end, n, bad);\r\nm->m_num_data_pg_pools = n;\r\nm->m_data_pg_pools = kcalloc(n, sizeof(u64), GFP_NOFS);\r\nif (!m->m_data_pg_pools)\r\ngoto badmem;\r\nceph_decode_need(p, end, sizeof(u64)*(n+1), bad);\r\nfor (i = 0; i < n; i++)\r\nm->m_data_pg_pools[i] = ceph_decode_64(p);\r\nm->m_cas_pg_pool = ceph_decode_64(p);\r\ndout("mdsmap_decode success epoch %u\n", m->m_epoch);\r\nreturn m;\r\nbadmem:\r\nerr = -ENOMEM;\r\nbad:\r\npr_err("corrupt mdsmap\n");\r\nprint_hex_dump(KERN_DEBUG, "mdsmap: ",\r\nDUMP_PREFIX_OFFSET, 16, 1,\r\nstart, end - start, true);\r\nceph_mdsmap_destroy(m);\r\nreturn ERR_PTR(err);\r\n}\r\nvoid ceph_mdsmap_destroy(struct ceph_mdsmap *m)\r\n{\r\nint i;\r\nfor (i = 0; i < m->m_max_mds; i++)\r\nkfree(m->m_info[i].export_targets);\r\nkfree(m->m_info);\r\nkfree(m->m_data_pg_pools);\r\nkfree(m);\r\n}
