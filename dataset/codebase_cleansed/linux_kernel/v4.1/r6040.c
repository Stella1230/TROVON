static int r6040_phy_read(void __iomem *ioaddr, int phy_addr, int reg)\r\n{\r\nint limit = MAC_DEF_TIMEOUT;\r\nu16 cmd;\r\niowrite16(MDIO_READ + reg + (phy_addr << 8), ioaddr + MMDIO);\r\nwhile (limit--) {\r\ncmd = ioread16(ioaddr + MMDIO);\r\nif (!(cmd & MDIO_READ))\r\nbreak;\r\nudelay(1);\r\n}\r\nif (limit < 0)\r\nreturn -ETIMEDOUT;\r\nreturn ioread16(ioaddr + MMRD);\r\n}\r\nstatic int r6040_phy_write(void __iomem *ioaddr,\r\nint phy_addr, int reg, u16 val)\r\n{\r\nint limit = MAC_DEF_TIMEOUT;\r\nu16 cmd;\r\niowrite16(val, ioaddr + MMWD);\r\niowrite16(MDIO_WRITE + reg + (phy_addr << 8), ioaddr + MMDIO);\r\nwhile (limit--) {\r\ncmd = ioread16(ioaddr + MMDIO);\r\nif (!(cmd & MDIO_WRITE))\r\nbreak;\r\nudelay(1);\r\n}\r\nreturn (limit < 0) ? -ETIMEDOUT : 0;\r\n}\r\nstatic int r6040_mdiobus_read(struct mii_bus *bus, int phy_addr, int reg)\r\n{\r\nstruct net_device *dev = bus->priv;\r\nstruct r6040_private *lp = netdev_priv(dev);\r\nvoid __iomem *ioaddr = lp->base;\r\nreturn r6040_phy_read(ioaddr, phy_addr, reg);\r\n}\r\nstatic int r6040_mdiobus_write(struct mii_bus *bus, int phy_addr,\r\nint reg, u16 value)\r\n{\r\nstruct net_device *dev = bus->priv;\r\nstruct r6040_private *lp = netdev_priv(dev);\r\nvoid __iomem *ioaddr = lp->base;\r\nreturn r6040_phy_write(ioaddr, phy_addr, reg, value);\r\n}\r\nstatic void r6040_free_txbufs(struct net_device *dev)\r\n{\r\nstruct r6040_private *lp = netdev_priv(dev);\r\nint i;\r\nfor (i = 0; i < TX_DCNT; i++) {\r\nif (lp->tx_insert_ptr->skb_ptr) {\r\npci_unmap_single(lp->pdev,\r\nle32_to_cpu(lp->tx_insert_ptr->buf),\r\nMAX_BUF_SIZE, PCI_DMA_TODEVICE);\r\ndev_kfree_skb(lp->tx_insert_ptr->skb_ptr);\r\nlp->tx_insert_ptr->skb_ptr = NULL;\r\n}\r\nlp->tx_insert_ptr = lp->tx_insert_ptr->vndescp;\r\n}\r\n}\r\nstatic void r6040_free_rxbufs(struct net_device *dev)\r\n{\r\nstruct r6040_private *lp = netdev_priv(dev);\r\nint i;\r\nfor (i = 0; i < RX_DCNT; i++) {\r\nif (lp->rx_insert_ptr->skb_ptr) {\r\npci_unmap_single(lp->pdev,\r\nle32_to_cpu(lp->rx_insert_ptr->buf),\r\nMAX_BUF_SIZE, PCI_DMA_FROMDEVICE);\r\ndev_kfree_skb(lp->rx_insert_ptr->skb_ptr);\r\nlp->rx_insert_ptr->skb_ptr = NULL;\r\n}\r\nlp->rx_insert_ptr = lp->rx_insert_ptr->vndescp;\r\n}\r\n}\r\nstatic void r6040_init_ring_desc(struct r6040_descriptor *desc_ring,\r\ndma_addr_t desc_dma, int size)\r\n{\r\nstruct r6040_descriptor *desc = desc_ring;\r\ndma_addr_t mapping = desc_dma;\r\nwhile (size-- > 0) {\r\nmapping += sizeof(*desc);\r\ndesc->ndesc = cpu_to_le32(mapping);\r\ndesc->vndescp = desc + 1;\r\ndesc++;\r\n}\r\ndesc--;\r\ndesc->ndesc = cpu_to_le32(desc_dma);\r\ndesc->vndescp = desc_ring;\r\n}\r\nstatic void r6040_init_txbufs(struct net_device *dev)\r\n{\r\nstruct r6040_private *lp = netdev_priv(dev);\r\nlp->tx_free_desc = TX_DCNT;\r\nlp->tx_remove_ptr = lp->tx_insert_ptr = lp->tx_ring;\r\nr6040_init_ring_desc(lp->tx_ring, lp->tx_ring_dma, TX_DCNT);\r\n}\r\nstatic int r6040_alloc_rxbufs(struct net_device *dev)\r\n{\r\nstruct r6040_private *lp = netdev_priv(dev);\r\nstruct r6040_descriptor *desc;\r\nstruct sk_buff *skb;\r\nint rc;\r\nlp->rx_remove_ptr = lp->rx_insert_ptr = lp->rx_ring;\r\nr6040_init_ring_desc(lp->rx_ring, lp->rx_ring_dma, RX_DCNT);\r\ndesc = lp->rx_ring;\r\ndo {\r\nskb = netdev_alloc_skb(dev, MAX_BUF_SIZE);\r\nif (!skb) {\r\nrc = -ENOMEM;\r\ngoto err_exit;\r\n}\r\ndesc->skb_ptr = skb;\r\ndesc->buf = cpu_to_le32(pci_map_single(lp->pdev,\r\ndesc->skb_ptr->data,\r\nMAX_BUF_SIZE, PCI_DMA_FROMDEVICE));\r\ndesc->status = DSC_OWNER_MAC;\r\ndesc = desc->vndescp;\r\n} while (desc != lp->rx_ring);\r\nreturn 0;\r\nerr_exit:\r\nr6040_free_rxbufs(dev);\r\nreturn rc;\r\n}\r\nstatic void r6040_reset_mac(struct r6040_private *lp)\r\n{\r\nvoid __iomem *ioaddr = lp->base;\r\nint limit = MAC_DEF_TIMEOUT;\r\nu16 cmd;\r\niowrite16(MAC_RST, ioaddr + MCR1);\r\nwhile (limit--) {\r\ncmd = ioread16(ioaddr + MCR1);\r\nif (cmd & MAC_RST)\r\nbreak;\r\n}\r\niowrite16(MAC_SM_RST, ioaddr + MAC_SM);\r\niowrite16(0, ioaddr + MAC_SM);\r\nmdelay(5);\r\n}\r\nstatic void r6040_init_mac_regs(struct net_device *dev)\r\n{\r\nstruct r6040_private *lp = netdev_priv(dev);\r\nvoid __iomem *ioaddr = lp->base;\r\niowrite16(MSK_INT, ioaddr + MIER);\r\nr6040_reset_mac(lp);\r\niowrite16(MBCR_DEFAULT, ioaddr + MBCR);\r\niowrite16(MAX_BUF_SIZE, ioaddr + MR_BSR);\r\niowrite16(lp->tx_ring_dma, ioaddr + MTD_SA0);\r\niowrite16(lp->tx_ring_dma >> 16, ioaddr + MTD_SA1);\r\niowrite16(lp->rx_ring_dma, ioaddr + MRD_SA0);\r\niowrite16(lp->rx_ring_dma >> 16, ioaddr + MRD_SA1);\r\niowrite16(0, ioaddr + MT_ICR);\r\niowrite16(0, ioaddr + MR_ICR);\r\niowrite16(INT_MASK, ioaddr + MIER);\r\niowrite16(lp->mcr0 | MCR0_RCVEN, ioaddr);\r\niowrite16(TM2TX, ioaddr + MTPR);\r\n}\r\nstatic void r6040_tx_timeout(struct net_device *dev)\r\n{\r\nstruct r6040_private *priv = netdev_priv(dev);\r\nvoid __iomem *ioaddr = priv->base;\r\nnetdev_warn(dev, "transmit timed out, int enable %4.4x "\r\n"status %4.4x\n",\r\nioread16(ioaddr + MIER),\r\nioread16(ioaddr + MISR));\r\ndev->stats.tx_errors++;\r\nr6040_init_mac_regs(dev);\r\n}\r\nstatic struct net_device_stats *r6040_get_stats(struct net_device *dev)\r\n{\r\nstruct r6040_private *priv = netdev_priv(dev);\r\nvoid __iomem *ioaddr = priv->base;\r\nunsigned long flags;\r\nspin_lock_irqsave(&priv->lock, flags);\r\ndev->stats.rx_crc_errors += ioread8(ioaddr + ME_CNT1);\r\ndev->stats.multicast += ioread8(ioaddr + ME_CNT0);\r\nspin_unlock_irqrestore(&priv->lock, flags);\r\nreturn &dev->stats;\r\n}\r\nstatic void r6040_down(struct net_device *dev)\r\n{\r\nstruct r6040_private *lp = netdev_priv(dev);\r\nvoid __iomem *ioaddr = lp->base;\r\nu16 *adrp;\r\niowrite16(MSK_INT, ioaddr + MIER);\r\nr6040_reset_mac(lp);\r\nadrp = (u16 *) dev->dev_addr;\r\niowrite16(adrp[0], ioaddr + MID_0L);\r\niowrite16(adrp[1], ioaddr + MID_0M);\r\niowrite16(adrp[2], ioaddr + MID_0H);\r\nphy_stop(lp->phydev);\r\n}\r\nstatic int r6040_close(struct net_device *dev)\r\n{\r\nstruct r6040_private *lp = netdev_priv(dev);\r\nstruct pci_dev *pdev = lp->pdev;\r\nspin_lock_irq(&lp->lock);\r\nnapi_disable(&lp->napi);\r\nnetif_stop_queue(dev);\r\nr6040_down(dev);\r\nfree_irq(dev->irq, dev);\r\nr6040_free_rxbufs(dev);\r\nr6040_free_txbufs(dev);\r\nspin_unlock_irq(&lp->lock);\r\nif (lp->rx_ring) {\r\npci_free_consistent(pdev,\r\nRX_DESC_SIZE, lp->rx_ring, lp->rx_ring_dma);\r\nlp->rx_ring = NULL;\r\n}\r\nif (lp->tx_ring) {\r\npci_free_consistent(pdev,\r\nTX_DESC_SIZE, lp->tx_ring, lp->tx_ring_dma);\r\nlp->tx_ring = NULL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int r6040_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)\r\n{\r\nstruct r6040_private *lp = netdev_priv(dev);\r\nif (!lp->phydev)\r\nreturn -EINVAL;\r\nreturn phy_mii_ioctl(lp->phydev, rq, cmd);\r\n}\r\nstatic int r6040_rx(struct net_device *dev, int limit)\r\n{\r\nstruct r6040_private *priv = netdev_priv(dev);\r\nstruct r6040_descriptor *descptr = priv->rx_remove_ptr;\r\nstruct sk_buff *skb_ptr, *new_skb;\r\nint count = 0;\r\nu16 err;\r\nwhile (count < limit && !(descptr->status & DSC_OWNER_MAC)) {\r\nerr = descptr->status;\r\nif (err & DSC_RX_ERR) {\r\nif (err & DSC_RX_ERR_DRI)\r\ndev->stats.rx_frame_errors++;\r\nif (err & DSC_RX_ERR_BUF)\r\ndev->stats.rx_length_errors++;\r\nif (err & DSC_RX_ERR_LONG)\r\ndev->stats.rx_length_errors++;\r\nif (err & DSC_RX_ERR_RUNT)\r\ndev->stats.rx_length_errors++;\r\nif (err & DSC_RX_ERR_CRC) {\r\nspin_lock(&priv->lock);\r\ndev->stats.rx_crc_errors++;\r\nspin_unlock(&priv->lock);\r\n}\r\ngoto next_descr;\r\n}\r\nnew_skb = netdev_alloc_skb(dev, MAX_BUF_SIZE);\r\nif (!new_skb) {\r\ndev->stats.rx_dropped++;\r\ngoto next_descr;\r\n}\r\nskb_ptr = descptr->skb_ptr;\r\nskb_ptr->dev = priv->dev;\r\nskb_put(skb_ptr, descptr->len - 4);\r\npci_unmap_single(priv->pdev, le32_to_cpu(descptr->buf),\r\nMAX_BUF_SIZE, PCI_DMA_FROMDEVICE);\r\nskb_ptr->protocol = eth_type_trans(skb_ptr, priv->dev);\r\nnetif_receive_skb(skb_ptr);\r\ndev->stats.rx_packets++;\r\ndev->stats.rx_bytes += descptr->len - 4;\r\ndescptr->skb_ptr = new_skb;\r\ndescptr->buf = cpu_to_le32(pci_map_single(priv->pdev,\r\ndescptr->skb_ptr->data,\r\nMAX_BUF_SIZE, PCI_DMA_FROMDEVICE));\r\nnext_descr:\r\ndescptr->status = DSC_OWNER_MAC;\r\ndescptr = descptr->vndescp;\r\ncount++;\r\n}\r\npriv->rx_remove_ptr = descptr;\r\nreturn count;\r\n}\r\nstatic void r6040_tx(struct net_device *dev)\r\n{\r\nstruct r6040_private *priv = netdev_priv(dev);\r\nstruct r6040_descriptor *descptr;\r\nvoid __iomem *ioaddr = priv->base;\r\nstruct sk_buff *skb_ptr;\r\nu16 err;\r\nspin_lock(&priv->lock);\r\ndescptr = priv->tx_remove_ptr;\r\nwhile (priv->tx_free_desc < TX_DCNT) {\r\nerr = ioread16(ioaddr + MLSR);\r\nif (err & TX_FIFO_UNDR)\r\ndev->stats.tx_fifo_errors++;\r\nif (err & (TX_EXCEEDC | TX_LATEC))\r\ndev->stats.tx_carrier_errors++;\r\nif (descptr->status & DSC_OWNER_MAC)\r\nbreak;\r\nskb_ptr = descptr->skb_ptr;\r\npci_unmap_single(priv->pdev, le32_to_cpu(descptr->buf),\r\nskb_ptr->len, PCI_DMA_TODEVICE);\r\ndev_kfree_skb_irq(skb_ptr);\r\ndescptr->skb_ptr = NULL;\r\ndescptr = descptr->vndescp;\r\npriv->tx_free_desc++;\r\n}\r\npriv->tx_remove_ptr = descptr;\r\nif (priv->tx_free_desc)\r\nnetif_wake_queue(dev);\r\nspin_unlock(&priv->lock);\r\n}\r\nstatic int r6040_poll(struct napi_struct *napi, int budget)\r\n{\r\nstruct r6040_private *priv =\r\ncontainer_of(napi, struct r6040_private, napi);\r\nstruct net_device *dev = priv->dev;\r\nvoid __iomem *ioaddr = priv->base;\r\nint work_done;\r\nwork_done = r6040_rx(dev, budget);\r\nif (work_done < budget) {\r\nnapi_complete(napi);\r\niowrite16(ioread16(ioaddr + MIER) | RX_INTS, ioaddr + MIER);\r\n}\r\nreturn work_done;\r\n}\r\nstatic irqreturn_t r6040_interrupt(int irq, void *dev_id)\r\n{\r\nstruct net_device *dev = dev_id;\r\nstruct r6040_private *lp = netdev_priv(dev);\r\nvoid __iomem *ioaddr = lp->base;\r\nu16 misr, status;\r\nmisr = ioread16(ioaddr + MIER);\r\niowrite16(MSK_INT, ioaddr + MIER);\r\nstatus = ioread16(ioaddr + MISR);\r\nif (status == 0x0000 || status == 0xffff) {\r\niowrite16(misr, ioaddr + MIER);\r\nreturn IRQ_NONE;\r\n}\r\nif (status & RX_INTS) {\r\nif (status & RX_NO_DESC) {\r\ndev->stats.rx_dropped++;\r\ndev->stats.rx_missed_errors++;\r\n}\r\nif (status & RX_FIFO_FULL)\r\ndev->stats.rx_fifo_errors++;\r\nif (likely(napi_schedule_prep(&lp->napi))) {\r\nmisr &= ~RX_INTS;\r\n__napi_schedule(&lp->napi);\r\n}\r\n}\r\nif (status & TX_INTS)\r\nr6040_tx(dev);\r\niowrite16(misr, ioaddr + MIER);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void r6040_poll_controller(struct net_device *dev)\r\n{\r\ndisable_irq(dev->irq);\r\nr6040_interrupt(dev->irq, dev);\r\nenable_irq(dev->irq);\r\n}\r\nstatic int r6040_up(struct net_device *dev)\r\n{\r\nstruct r6040_private *lp = netdev_priv(dev);\r\nvoid __iomem *ioaddr = lp->base;\r\nint ret;\r\nr6040_init_txbufs(dev);\r\nret = r6040_alloc_rxbufs(dev);\r\nif (ret)\r\nreturn ret;\r\nr6040_phy_write(ioaddr, 30, 17,\r\n(r6040_phy_read(ioaddr, 30, 17) | 0x4000));\r\nr6040_phy_write(ioaddr, 30, 17,\r\n~((~r6040_phy_read(ioaddr, 30, 17)) | 0x2000));\r\nr6040_phy_write(ioaddr, 0, 19, 0x0000);\r\nr6040_phy_write(ioaddr, 0, 30, 0x01F0);\r\nr6040_init_mac_regs(dev);\r\nphy_start(lp->phydev);\r\nreturn 0;\r\n}\r\nstatic void r6040_mac_address(struct net_device *dev)\r\n{\r\nstruct r6040_private *lp = netdev_priv(dev);\r\nvoid __iomem *ioaddr = lp->base;\r\nu16 *adrp;\r\nr6040_reset_mac(lp);\r\nadrp = (u16 *) dev->dev_addr;\r\niowrite16(adrp[0], ioaddr + MID_0L);\r\niowrite16(adrp[1], ioaddr + MID_0M);\r\niowrite16(adrp[2], ioaddr + MID_0H);\r\n}\r\nstatic int r6040_open(struct net_device *dev)\r\n{\r\nstruct r6040_private *lp = netdev_priv(dev);\r\nint ret;\r\nret = request_irq(dev->irq, r6040_interrupt,\r\nIRQF_SHARED, dev->name, dev);\r\nif (ret)\r\ngoto out;\r\nr6040_mac_address(dev);\r\nlp->rx_ring =\r\npci_alloc_consistent(lp->pdev, RX_DESC_SIZE, &lp->rx_ring_dma);\r\nif (!lp->rx_ring) {\r\nret = -ENOMEM;\r\ngoto err_free_irq;\r\n}\r\nlp->tx_ring =\r\npci_alloc_consistent(lp->pdev, TX_DESC_SIZE, &lp->tx_ring_dma);\r\nif (!lp->tx_ring) {\r\nret = -ENOMEM;\r\ngoto err_free_rx_ring;\r\n}\r\nret = r6040_up(dev);\r\nif (ret)\r\ngoto err_free_tx_ring;\r\nnapi_enable(&lp->napi);\r\nnetif_start_queue(dev);\r\nreturn 0;\r\nerr_free_tx_ring:\r\npci_free_consistent(lp->pdev, TX_DESC_SIZE, lp->tx_ring,\r\nlp->tx_ring_dma);\r\nerr_free_rx_ring:\r\npci_free_consistent(lp->pdev, RX_DESC_SIZE, lp->rx_ring,\r\nlp->rx_ring_dma);\r\nerr_free_irq:\r\nfree_irq(dev->irq, dev);\r\nout:\r\nreturn ret;\r\n}\r\nstatic netdev_tx_t r6040_start_xmit(struct sk_buff *skb,\r\nstruct net_device *dev)\r\n{\r\nstruct r6040_private *lp = netdev_priv(dev);\r\nstruct r6040_descriptor *descptr;\r\nvoid __iomem *ioaddr = lp->base;\r\nunsigned long flags;\r\nspin_lock_irqsave(&lp->lock, flags);\r\nif (!lp->tx_free_desc) {\r\nspin_unlock_irqrestore(&lp->lock, flags);\r\nnetif_stop_queue(dev);\r\nnetdev_err(dev, ": no tx descriptor\n");\r\nreturn NETDEV_TX_BUSY;\r\n}\r\ndev->stats.tx_packets++;\r\ndev->stats.tx_bytes += skb->len;\r\nlp->tx_free_desc--;\r\ndescptr = lp->tx_insert_ptr;\r\nif (skb->len < ETH_ZLEN)\r\ndescptr->len = ETH_ZLEN;\r\nelse\r\ndescptr->len = skb->len;\r\ndescptr->skb_ptr = skb;\r\ndescptr->buf = cpu_to_le32(pci_map_single(lp->pdev,\r\nskb->data, skb->len, PCI_DMA_TODEVICE));\r\ndescptr->status = DSC_OWNER_MAC;\r\nskb_tx_timestamp(skb);\r\niowrite16(TM2TX, ioaddr + MTPR);\r\nlp->tx_insert_ptr = descptr->vndescp;\r\nif (!lp->tx_free_desc)\r\nnetif_stop_queue(dev);\r\nspin_unlock_irqrestore(&lp->lock, flags);\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic void r6040_multicast_list(struct net_device *dev)\r\n{\r\nstruct r6040_private *lp = netdev_priv(dev);\r\nvoid __iomem *ioaddr = lp->base;\r\nunsigned long flags;\r\nstruct netdev_hw_addr *ha;\r\nint i;\r\nu16 *adrp;\r\nu16 hash_table[4] = { 0 };\r\nspin_lock_irqsave(&lp->lock, flags);\r\nadrp = (u16 *)dev->dev_addr;\r\niowrite16(adrp[0], ioaddr + MID_0L);\r\niowrite16(adrp[1], ioaddr + MID_0M);\r\niowrite16(adrp[2], ioaddr + MID_0H);\r\nlp->mcr0 = ioread16(ioaddr + MCR0) & ~(MCR0_PROMISC | MCR0_HASH_EN);\r\nif (dev->flags & IFF_PROMISC)\r\nlp->mcr0 |= MCR0_PROMISC;\r\nelse if (dev->flags & IFF_ALLMULTI) {\r\nlp->mcr0 |= MCR0_HASH_EN;\r\nfor (i = 0; i < MCAST_MAX ; i++) {\r\niowrite16(0, ioaddr + MID_1L + 8 * i);\r\niowrite16(0, ioaddr + MID_1M + 8 * i);\r\niowrite16(0, ioaddr + MID_1H + 8 * i);\r\n}\r\nfor (i = 0; i < 4; i++)\r\nhash_table[i] = 0xffff;\r\n}\r\nelse if (netdev_mc_count(dev) <= MCAST_MAX) {\r\ni = 0;\r\nnetdev_for_each_mc_addr(ha, dev) {\r\nu16 *adrp = (u16 *) ha->addr;\r\niowrite16(adrp[0], ioaddr + MID_1L + 8 * i);\r\niowrite16(adrp[1], ioaddr + MID_1M + 8 * i);\r\niowrite16(adrp[2], ioaddr + MID_1H + 8 * i);\r\ni++;\r\n}\r\nwhile (i < MCAST_MAX) {\r\niowrite16(0, ioaddr + MID_1L + 8 * i);\r\niowrite16(0, ioaddr + MID_1M + 8 * i);\r\niowrite16(0, ioaddr + MID_1H + 8 * i);\r\ni++;\r\n}\r\n}\r\nelse {\r\nu32 crc;\r\nlp->mcr0 |= MCR0_HASH_EN;\r\nfor (i = 0; i < MCAST_MAX ; i++) {\r\niowrite16(0, ioaddr + MID_1L + 8 * i);\r\niowrite16(0, ioaddr + MID_1M + 8 * i);\r\niowrite16(0, ioaddr + MID_1H + 8 * i);\r\n}\r\nnetdev_for_each_mc_addr(ha, dev) {\r\nu8 *addrs = ha->addr;\r\ncrc = ether_crc(ETH_ALEN, addrs);\r\ncrc >>= 26;\r\nhash_table[crc >> 4] |= 1 << (crc & 0xf);\r\n}\r\n}\r\niowrite16(lp->mcr0, ioaddr + MCR0);\r\nif (lp->mcr0 & MCR0_HASH_EN) {\r\niowrite16(hash_table[0], ioaddr + MAR0);\r\niowrite16(hash_table[1], ioaddr + MAR1);\r\niowrite16(hash_table[2], ioaddr + MAR2);\r\niowrite16(hash_table[3], ioaddr + MAR3);\r\n}\r\nspin_unlock_irqrestore(&lp->lock, flags);\r\n}\r\nstatic void netdev_get_drvinfo(struct net_device *dev,\r\nstruct ethtool_drvinfo *info)\r\n{\r\nstruct r6040_private *rp = netdev_priv(dev);\r\nstrlcpy(info->driver, DRV_NAME, sizeof(info->driver));\r\nstrlcpy(info->version, DRV_VERSION, sizeof(info->version));\r\nstrlcpy(info->bus_info, pci_name(rp->pdev), sizeof(info->bus_info));\r\n}\r\nstatic int netdev_get_settings(struct net_device *dev, struct ethtool_cmd *cmd)\r\n{\r\nstruct r6040_private *rp = netdev_priv(dev);\r\nreturn phy_ethtool_gset(rp->phydev, cmd);\r\n}\r\nstatic int netdev_set_settings(struct net_device *dev, struct ethtool_cmd *cmd)\r\n{\r\nstruct r6040_private *rp = netdev_priv(dev);\r\nreturn phy_ethtool_sset(rp->phydev, cmd);\r\n}\r\nstatic void r6040_adjust_link(struct net_device *dev)\r\n{\r\nstruct r6040_private *lp = netdev_priv(dev);\r\nstruct phy_device *phydev = lp->phydev;\r\nint status_changed = 0;\r\nvoid __iomem *ioaddr = lp->base;\r\nBUG_ON(!phydev);\r\nif (lp->old_link != phydev->link) {\r\nstatus_changed = 1;\r\nlp->old_link = phydev->link;\r\n}\r\nif (phydev->link && (lp->old_duplex != phydev->duplex)) {\r\nlp->mcr0 |= (phydev->duplex == DUPLEX_FULL ? MCR0_FD : 0);\r\niowrite16(lp->mcr0, ioaddr);\r\nstatus_changed = 1;\r\nlp->old_duplex = phydev->duplex;\r\n}\r\nif (status_changed) {\r\npr_info("%s: link %s", dev->name, phydev->link ?\r\n"UP" : "DOWN");\r\nif (phydev->link)\r\npr_cont(" - %d/%s", phydev->speed,\r\nDUPLEX_FULL == phydev->duplex ? "full" : "half");\r\npr_cont("\n");\r\n}\r\n}\r\nstatic int r6040_mii_probe(struct net_device *dev)\r\n{\r\nstruct r6040_private *lp = netdev_priv(dev);\r\nstruct phy_device *phydev = NULL;\r\nphydev = phy_find_first(lp->mii_bus);\r\nif (!phydev) {\r\ndev_err(&lp->pdev->dev, "no PHY found\n");\r\nreturn -ENODEV;\r\n}\r\nphydev = phy_connect(dev, dev_name(&phydev->dev), &r6040_adjust_link,\r\nPHY_INTERFACE_MODE_MII);\r\nif (IS_ERR(phydev)) {\r\ndev_err(&lp->pdev->dev, "could not attach to PHY\n");\r\nreturn PTR_ERR(phydev);\r\n}\r\nphydev->supported &= (SUPPORTED_10baseT_Half\r\n| SUPPORTED_10baseT_Full\r\n| SUPPORTED_100baseT_Half\r\n| SUPPORTED_100baseT_Full\r\n| SUPPORTED_Autoneg\r\n| SUPPORTED_MII\r\n| SUPPORTED_TP);\r\nphydev->advertising = phydev->supported;\r\nlp->phydev = phydev;\r\nlp->old_link = 0;\r\nlp->old_duplex = -1;\r\ndev_info(&lp->pdev->dev, "attached PHY driver [%s] "\r\n"(mii_bus:phy_addr=%s)\n",\r\nphydev->drv->name, dev_name(&phydev->dev));\r\nreturn 0;\r\n}\r\nstatic int r6040_init_one(struct pci_dev *pdev, const struct pci_device_id *ent)\r\n{\r\nstruct net_device *dev;\r\nstruct r6040_private *lp;\r\nvoid __iomem *ioaddr;\r\nint err, io_size = R6040_IO_SIZE;\r\nstatic int card_idx = -1;\r\nint bar = 0;\r\nu16 *adrp;\r\nint i;\r\npr_info("%s\n", version);\r\nerr = pci_enable_device(pdev);\r\nif (err)\r\ngoto err_out;\r\nerr = pci_set_dma_mask(pdev, DMA_BIT_MASK(32));\r\nif (err) {\r\ndev_err(&pdev->dev, "32-bit PCI DMA addresses"\r\n"not supported by the card\n");\r\ngoto err_out_disable_dev;\r\n}\r\nerr = pci_set_consistent_dma_mask(pdev, DMA_BIT_MASK(32));\r\nif (err) {\r\ndev_err(&pdev->dev, "32-bit PCI DMA addresses"\r\n"not supported by the card\n");\r\ngoto err_out_disable_dev;\r\n}\r\nif (pci_resource_len(pdev, bar) < io_size) {\r\ndev_err(&pdev->dev, "Insufficient PCI resources, aborting\n");\r\nerr = -EIO;\r\ngoto err_out_disable_dev;\r\n}\r\npci_set_master(pdev);\r\ndev = alloc_etherdev(sizeof(struct r6040_private));\r\nif (!dev) {\r\nerr = -ENOMEM;\r\ngoto err_out_disable_dev;\r\n}\r\nSET_NETDEV_DEV(dev, &pdev->dev);\r\nlp = netdev_priv(dev);\r\nerr = pci_request_regions(pdev, DRV_NAME);\r\nif (err) {\r\ndev_err(&pdev->dev, "Failed to request PCI regions\n");\r\ngoto err_out_free_dev;\r\n}\r\nioaddr = pci_iomap(pdev, bar, io_size);\r\nif (!ioaddr) {\r\ndev_err(&pdev->dev, "ioremap failed for device\n");\r\nerr = -EIO;\r\ngoto err_out_free_res;\r\n}\r\nif (ioread16(ioaddr + PHY_CC) == 0)\r\niowrite16(SCEN | PHY_MAX_ADDR << PHYAD_SHIFT |\r\n7 << TMRDIV_SHIFT, ioaddr + PHY_CC);\r\nlp->base = ioaddr;\r\ndev->irq = pdev->irq;\r\nspin_lock_init(&lp->lock);\r\npci_set_drvdata(pdev, dev);\r\ncard_idx++;\r\nadrp = (u16 *)dev->dev_addr;\r\nadrp[0] = ioread16(ioaddr + MID_0L);\r\nadrp[1] = ioread16(ioaddr + MID_0M);\r\nadrp[2] = ioread16(ioaddr + MID_0H);\r\nif (!(adrp[0] || adrp[1] || adrp[2])) {\r\nnetdev_warn(dev, "MAC address not initialized, "\r\n"generating random\n");\r\neth_hw_addr_random(dev);\r\n}\r\nlp->pdev = pdev;\r\nlp->dev = dev;\r\nlp->mcr0 = MCR0_XMTEN | MCR0_RCVEN;\r\ndev->netdev_ops = &r6040_netdev_ops;\r\ndev->ethtool_ops = &netdev_ethtool_ops;\r\ndev->watchdog_timeo = TX_TIMEOUT;\r\nnetif_napi_add(dev, &lp->napi, r6040_poll, 64);\r\nlp->mii_bus = mdiobus_alloc();\r\nif (!lp->mii_bus) {\r\ndev_err(&pdev->dev, "mdiobus_alloc() failed\n");\r\nerr = -ENOMEM;\r\ngoto err_out_unmap;\r\n}\r\nlp->mii_bus->priv = dev;\r\nlp->mii_bus->read = r6040_mdiobus_read;\r\nlp->mii_bus->write = r6040_mdiobus_write;\r\nlp->mii_bus->name = "r6040_eth_mii";\r\nsnprintf(lp->mii_bus->id, MII_BUS_ID_SIZE, "%s-%x",\r\ndev_name(&pdev->dev), card_idx);\r\nlp->mii_bus->irq = kmalloc_array(PHY_MAX_ADDR, sizeof(int), GFP_KERNEL);\r\nif (!lp->mii_bus->irq) {\r\nerr = -ENOMEM;\r\ngoto err_out_mdio;\r\n}\r\nfor (i = 0; i < PHY_MAX_ADDR; i++)\r\nlp->mii_bus->irq[i] = PHY_POLL;\r\nerr = mdiobus_register(lp->mii_bus);\r\nif (err) {\r\ndev_err(&pdev->dev, "failed to register MII bus\n");\r\ngoto err_out_mdio_irq;\r\n}\r\nerr = r6040_mii_probe(dev);\r\nif (err) {\r\ndev_err(&pdev->dev, "failed to probe MII bus\n");\r\ngoto err_out_mdio_unregister;\r\n}\r\nerr = register_netdev(dev);\r\nif (err) {\r\ndev_err(&pdev->dev, "Failed to register net device\n");\r\ngoto err_out_mdio_unregister;\r\n}\r\nreturn 0;\r\nerr_out_mdio_unregister:\r\nmdiobus_unregister(lp->mii_bus);\r\nerr_out_mdio_irq:\r\nkfree(lp->mii_bus->irq);\r\nerr_out_mdio:\r\nmdiobus_free(lp->mii_bus);\r\nerr_out_unmap:\r\nnetif_napi_del(&lp->napi);\r\npci_iounmap(pdev, ioaddr);\r\nerr_out_free_res:\r\npci_release_regions(pdev);\r\nerr_out_free_dev:\r\nfree_netdev(dev);\r\nerr_out_disable_dev:\r\npci_disable_device(pdev);\r\nerr_out:\r\nreturn err;\r\n}\r\nstatic void r6040_remove_one(struct pci_dev *pdev)\r\n{\r\nstruct net_device *dev = pci_get_drvdata(pdev);\r\nstruct r6040_private *lp = netdev_priv(dev);\r\nunregister_netdev(dev);\r\nmdiobus_unregister(lp->mii_bus);\r\nkfree(lp->mii_bus->irq);\r\nmdiobus_free(lp->mii_bus);\r\nnetif_napi_del(&lp->napi);\r\npci_iounmap(pdev, lp->base);\r\npci_release_regions(pdev);\r\nfree_netdev(dev);\r\npci_disable_device(pdev);\r\n}
