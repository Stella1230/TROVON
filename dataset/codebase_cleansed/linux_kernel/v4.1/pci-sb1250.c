static inline u32 READCFG32(u32 addr)\r\n{\r\nreturn *(u32 *) (cfg_space + (addr & ~3));\r\n}\r\nstatic inline void WRITECFG32(u32 addr, u32 data)\r\n{\r\n*(u32 *) (cfg_space + (addr & ~3)) = data;\r\n}\r\nint pcibios_map_irq(const struct pci_dev *dev, u8 slot, u8 pin)\r\n{\r\nreturn dev->irq;\r\n}\r\nint pcibios_plat_dev_init(struct pci_dev *dev)\r\n{\r\nreturn 0;\r\n}\r\nstatic int sb1250_pci_can_access(struct pci_bus *bus, int devfn)\r\n{\r\nu32 devno;\r\nif (!(sb1250_bus_status & (PCI_BUS_ENABLED | PCI_DEVICE_MODE)))\r\nreturn 0;\r\nif (bus->number == 0) {\r\ndevno = PCI_SLOT(devfn);\r\nif (devno == LDT_BRIDGE_DEVICE)\r\nreturn (sb1250_bus_status & LDT_BUS_ENABLED) != 0;\r\nelse if (sb1250_bus_status & PCI_DEVICE_MODE)\r\nreturn 0;\r\nelse\r\nreturn 1;\r\n} else\r\nreturn 1;\r\n}\r\nstatic int sb1250_pcibios_read(struct pci_bus *bus, unsigned int devfn,\r\nint where, int size, u32 * val)\r\n{\r\nu32 data = 0;\r\nif ((size == 2) && (where & 1))\r\nreturn PCIBIOS_BAD_REGISTER_NUMBER;\r\nelse if ((size == 4) && (where & 3))\r\nreturn PCIBIOS_BAD_REGISTER_NUMBER;\r\nif (sb1250_pci_can_access(bus, devfn))\r\ndata = READCFG32(CFGADDR(bus, devfn, where));\r\nelse\r\ndata = 0xFFFFFFFF;\r\nif (size == 1)\r\n*val = (data >> ((where & 3) << 3)) & 0xff;\r\nelse if (size == 2)\r\n*val = (data >> ((where & 3) << 3)) & 0xffff;\r\nelse\r\n*val = data;\r\nreturn PCIBIOS_SUCCESSFUL;\r\n}\r\nstatic int sb1250_pcibios_write(struct pci_bus *bus, unsigned int devfn,\r\nint where, int size, u32 val)\r\n{\r\nu32 cfgaddr = CFGADDR(bus, devfn, where);\r\nu32 data = 0;\r\nif ((size == 2) && (where & 1))\r\nreturn PCIBIOS_BAD_REGISTER_NUMBER;\r\nelse if ((size == 4) && (where & 3))\r\nreturn PCIBIOS_BAD_REGISTER_NUMBER;\r\nif (!sb1250_pci_can_access(bus, devfn))\r\nreturn PCIBIOS_BAD_REGISTER_NUMBER;\r\ndata = READCFG32(cfgaddr);\r\nif (size == 1)\r\ndata = (data & ~(0xff << ((where & 3) << 3))) |\r\n(val << ((where & 3) << 3));\r\nelse if (size == 2)\r\ndata = (data & ~(0xffff << ((where & 3) << 3))) |\r\n(val << ((where & 3) << 3));\r\nelse\r\ndata = val;\r\nWRITECFG32(cfgaddr, data);\r\nreturn PCIBIOS_SUCCESSFUL;\r\n}\r\nstatic int __init sb1250_pcibios_init(void)\r\n{\r\nvoid __iomem *io_map_base;\r\nuint32_t cmdreg;\r\nuint64_t reg;\r\npci_set_flags(PCI_PROBE_ONLY);\r\nPCIBIOS_MIN_IO = 0x00008000UL;\r\nPCIBIOS_MIN_MEM = 0x01000000UL;\r\nioport_resource.end = 0x01ffffffUL;\r\niomem_resource.end = 0xffffffffUL;\r\ncfg_space =\r\nioremap(A_PHYS_LDTPCI_CFG_MATCH_BITS, 16 * 1024 * 1024);\r\nreg = __raw_readq(IOADDR(A_SCD_SYSTEM_CFG));\r\nif (!(reg & M_SYS_PCI_HOST)) {\r\nsb1250_bus_status |= PCI_DEVICE_MODE;\r\n} else {\r\ncmdreg =\r\nREADCFG32(CFGOFFSET\r\n(0, PCI_DEVFN(PCI_BRIDGE_DEVICE, 0),\r\nPCI_COMMAND));\r\nif (!(cmdreg & PCI_COMMAND_MASTER)) {\r\nprintk\r\n("PCI: Skipping PCI probe. Bus is not initialized.\n");\r\niounmap(cfg_space);\r\nreturn 0;\r\n}\r\nsb1250_bus_status |= PCI_BUS_ENABLED;\r\n}\r\nio_map_base = ioremap(A_PHYS_LDTPCI_IO_MATCH_BYTES, 1024 * 1024);\r\nsb1250_controller.io_map_base = (unsigned long)io_map_base;\r\nset_io_port_base((unsigned long)io_map_base);\r\n#ifdef CONFIG_SIBYTE_HAS_LDT\r\ncmdreg = READCFG32(CFGOFFSET(0, PCI_DEVFN(LDT_BRIDGE_DEVICE, 0),\r\nPCI_COMMAND));\r\nif (cmdreg & PCI_COMMAND_MASTER) {\r\nsb1250_bus_status |= LDT_BUS_ENABLED;\r\nldt_eoi_space = (unsigned long)\r\nioremap(A_PHYS_LDT_SPECIAL_MATCH_BYTES,\r\n4 * 1024 * 1024);\r\n}\r\n#endif\r\nregister_pci_controller(&sb1250_controller);\r\n#ifdef CONFIG_VGA_CONSOLE\r\nconsole_lock();\r\ndo_take_over_console(&vga_con, 0, MAX_NR_CONSOLES - 1, 1);\r\nconsole_unlock();\r\n#endif\r\nreturn 0;\r\n}
