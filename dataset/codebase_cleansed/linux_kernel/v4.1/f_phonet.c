static inline struct f_phonet *func_to_pn(struct usb_function *f)\r\n{\r\nreturn container_of(f, struct f_phonet, function);\r\n}\r\nstatic int pn_net_open(struct net_device *dev)\r\n{\r\nnetif_wake_queue(dev);\r\nreturn 0;\r\n}\r\nstatic int pn_net_close(struct net_device *dev)\r\n{\r\nnetif_stop_queue(dev);\r\nreturn 0;\r\n}\r\nstatic void pn_tx_complete(struct usb_ep *ep, struct usb_request *req)\r\n{\r\nstruct f_phonet *fp = ep->driver_data;\r\nstruct net_device *dev = fp->dev;\r\nstruct sk_buff *skb = req->context;\r\nswitch (req->status) {\r\ncase 0:\r\ndev->stats.tx_packets++;\r\ndev->stats.tx_bytes += skb->len;\r\nbreak;\r\ncase -ESHUTDOWN:\r\ncase -ECONNRESET:\r\ndev->stats.tx_aborted_errors++;\r\ndefault:\r\ndev->stats.tx_errors++;\r\n}\r\ndev_kfree_skb_any(skb);\r\nnetif_wake_queue(dev);\r\n}\r\nstatic int pn_net_xmit(struct sk_buff *skb, struct net_device *dev)\r\n{\r\nstruct phonet_port *port = netdev_priv(dev);\r\nstruct f_phonet *fp;\r\nstruct usb_request *req;\r\nunsigned long flags;\r\nif (skb->protocol != htons(ETH_P_PHONET))\r\ngoto out;\r\nspin_lock_irqsave(&port->lock, flags);\r\nfp = port->usb;\r\nif (unlikely(!fp))\r\ngoto out_unlock;\r\nreq = fp->in_req;\r\nreq->buf = skb->data;\r\nreq->length = skb->len;\r\nreq->complete = pn_tx_complete;\r\nreq->zero = 1;\r\nreq->context = skb;\r\nif (unlikely(usb_ep_queue(fp->in_ep, req, GFP_ATOMIC)))\r\ngoto out_unlock;\r\nnetif_stop_queue(dev);\r\nskb = NULL;\r\nout_unlock:\r\nspin_unlock_irqrestore(&port->lock, flags);\r\nout:\r\nif (unlikely(skb)) {\r\ndev_kfree_skb(skb);\r\ndev->stats.tx_dropped++;\r\n}\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic int pn_net_mtu(struct net_device *dev, int new_mtu)\r\n{\r\nif ((new_mtu < PHONET_MIN_MTU) || (new_mtu > PHONET_MAX_MTU))\r\nreturn -EINVAL;\r\ndev->mtu = new_mtu;\r\nreturn 0;\r\n}\r\nstatic void pn_net_setup(struct net_device *dev)\r\n{\r\ndev->features = 0;\r\ndev->type = ARPHRD_PHONET;\r\ndev->flags = IFF_POINTOPOINT | IFF_NOARP;\r\ndev->mtu = PHONET_DEV_MTU;\r\ndev->hard_header_len = 1;\r\ndev->dev_addr[0] = PN_MEDIA_USB;\r\ndev->addr_len = 1;\r\ndev->tx_queue_len = 1;\r\ndev->netdev_ops = &pn_netdev_ops;\r\ndev->destructor = free_netdev;\r\ndev->header_ops = &phonet_header_ops;\r\n}\r\nstatic int\r\npn_rx_submit(struct f_phonet *fp, struct usb_request *req, gfp_t gfp_flags)\r\n{\r\nstruct page *page;\r\nint err;\r\npage = __dev_alloc_page(gfp_flags | __GFP_NOMEMALLOC);\r\nif (!page)\r\nreturn -ENOMEM;\r\nreq->buf = page_address(page);\r\nreq->length = PAGE_SIZE;\r\nreq->context = page;\r\nerr = usb_ep_queue(fp->out_ep, req, gfp_flags);\r\nif (unlikely(err))\r\nput_page(page);\r\nreturn err;\r\n}\r\nstatic void pn_rx_complete(struct usb_ep *ep, struct usb_request *req)\r\n{\r\nstruct f_phonet *fp = ep->driver_data;\r\nstruct net_device *dev = fp->dev;\r\nstruct page *page = req->context;\r\nstruct sk_buff *skb;\r\nunsigned long flags;\r\nint status = req->status;\r\nswitch (status) {\r\ncase 0:\r\nspin_lock_irqsave(&fp->rx.lock, flags);\r\nskb = fp->rx.skb;\r\nif (!skb)\r\nskb = fp->rx.skb = netdev_alloc_skb(dev, 12);\r\nif (req->actual < req->length)\r\nfp->rx.skb = NULL;\r\nspin_unlock_irqrestore(&fp->rx.lock, flags);\r\nif (unlikely(!skb))\r\nbreak;\r\nif (skb->len == 0) {\r\nskb->protocol = htons(ETH_P_PHONET);\r\nskb_reset_mac_header(skb);\r\nmemcpy(skb_put(skb, 1), page_address(page), 1);\r\n}\r\nskb_add_rx_frag(skb, skb_shinfo(skb)->nr_frags, page,\r\nskb->len <= 1, req->actual, PAGE_SIZE);\r\npage = NULL;\r\nif (req->actual < req->length) {\r\nskb->dev = dev;\r\ndev->stats.rx_packets++;\r\ndev->stats.rx_bytes += skb->len;\r\nnetif_rx(skb);\r\n}\r\nbreak;\r\ncase -ESHUTDOWN:\r\ncase -ECONNABORTED:\r\ncase -ECONNRESET:\r\nreq = NULL;\r\nbreak;\r\ncase -EOVERFLOW:\r\ndev->stats.rx_over_errors++;\r\ndefault:\r\ndev->stats.rx_errors++;\r\nbreak;\r\n}\r\nif (page)\r\nput_page(page);\r\nif (req)\r\npn_rx_submit(fp, req, GFP_ATOMIC);\r\n}\r\nstatic void __pn_reset(struct usb_function *f)\r\n{\r\nstruct f_phonet *fp = func_to_pn(f);\r\nstruct net_device *dev = fp->dev;\r\nstruct phonet_port *port = netdev_priv(dev);\r\nnetif_carrier_off(dev);\r\nport->usb = NULL;\r\nusb_ep_disable(fp->out_ep);\r\nusb_ep_disable(fp->in_ep);\r\nif (fp->rx.skb) {\r\ndev_kfree_skb_irq(fp->rx.skb);\r\nfp->rx.skb = NULL;\r\n}\r\n}\r\nstatic int pn_set_alt(struct usb_function *f, unsigned intf, unsigned alt)\r\n{\r\nstruct f_phonet *fp = func_to_pn(f);\r\nstruct usb_gadget *gadget = fp->function.config->cdev->gadget;\r\nif (intf == pn_control_intf_desc.bInterfaceNumber)\r\nreturn (alt > 0) ? -EINVAL : 0;\r\nif (intf == pn_data_intf_desc.bInterfaceNumber) {\r\nstruct net_device *dev = fp->dev;\r\nstruct phonet_port *port = netdev_priv(dev);\r\nif (alt > 1)\r\nreturn -EINVAL;\r\nspin_lock(&port->lock);\r\nif (fp->in_ep->driver_data)\r\n__pn_reset(f);\r\nif (alt == 1) {\r\nint i;\r\nif (config_ep_by_speed(gadget, f, fp->in_ep) ||\r\nconfig_ep_by_speed(gadget, f, fp->out_ep)) {\r\nfp->in_ep->desc = NULL;\r\nfp->out_ep->desc = NULL;\r\nspin_unlock(&port->lock);\r\nreturn -EINVAL;\r\n}\r\nusb_ep_enable(fp->out_ep);\r\nusb_ep_enable(fp->in_ep);\r\nport->usb = fp;\r\nfp->out_ep->driver_data = fp;\r\nfp->in_ep->driver_data = fp;\r\nnetif_carrier_on(dev);\r\nfor (i = 0; i < phonet_rxq_size; i++)\r\npn_rx_submit(fp, fp->out_reqv[i], GFP_ATOMIC);\r\n}\r\nspin_unlock(&port->lock);\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int pn_get_alt(struct usb_function *f, unsigned intf)\r\n{\r\nstruct f_phonet *fp = func_to_pn(f);\r\nif (intf == pn_control_intf_desc.bInterfaceNumber)\r\nreturn 0;\r\nif (intf == pn_data_intf_desc.bInterfaceNumber) {\r\nstruct phonet_port *port = netdev_priv(fp->dev);\r\nu8 alt;\r\nspin_lock(&port->lock);\r\nalt = port->usb != NULL;\r\nspin_unlock(&port->lock);\r\nreturn alt;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic void pn_disconnect(struct usb_function *f)\r\n{\r\nstruct f_phonet *fp = func_to_pn(f);\r\nstruct phonet_port *port = netdev_priv(fp->dev);\r\nunsigned long flags;\r\nspin_lock_irqsave(&port->lock, flags);\r\n__pn_reset(f);\r\nspin_unlock_irqrestore(&port->lock, flags);\r\n}\r\nstatic int pn_bind(struct usb_configuration *c, struct usb_function *f)\r\n{\r\nstruct usb_composite_dev *cdev = c->cdev;\r\nstruct usb_gadget *gadget = cdev->gadget;\r\nstruct f_phonet *fp = func_to_pn(f);\r\nstruct usb_ep *ep;\r\nint status, i;\r\nstruct f_phonet_opts *phonet_opts;\r\nphonet_opts = container_of(f->fi, struct f_phonet_opts, func_inst);\r\nif (!phonet_opts->bound) {\r\ngphonet_set_gadget(phonet_opts->net, gadget);\r\nstatus = gphonet_register_netdev(phonet_opts->net);\r\nif (status)\r\nreturn status;\r\nphonet_opts->bound = true;\r\n}\r\nstatus = usb_interface_id(c, f);\r\nif (status < 0)\r\ngoto err;\r\npn_control_intf_desc.bInterfaceNumber = status;\r\npn_union_desc.bMasterInterface0 = status;\r\nstatus = usb_interface_id(c, f);\r\nif (status < 0)\r\ngoto err;\r\npn_data_nop_intf_desc.bInterfaceNumber = status;\r\npn_data_intf_desc.bInterfaceNumber = status;\r\npn_union_desc.bSlaveInterface0 = status;\r\nstatus = -ENODEV;\r\nep = usb_ep_autoconfig(gadget, &pn_fs_sink_desc);\r\nif (!ep)\r\ngoto err;\r\nfp->out_ep = ep;\r\nep->driver_data = fp;\r\nep = usb_ep_autoconfig(gadget, &pn_fs_source_desc);\r\nif (!ep)\r\ngoto err;\r\nfp->in_ep = ep;\r\nep->driver_data = fp;\r\npn_hs_sink_desc.bEndpointAddress = pn_fs_sink_desc.bEndpointAddress;\r\npn_hs_source_desc.bEndpointAddress = pn_fs_source_desc.bEndpointAddress;\r\nstatus = usb_assign_descriptors(f, fs_pn_function, hs_pn_function,\r\nNULL);\r\nif (status)\r\ngoto err;\r\nstatus = -ENOMEM;\r\nfor (i = 0; i < phonet_rxq_size; i++) {\r\nstruct usb_request *req;\r\nreq = usb_ep_alloc_request(fp->out_ep, GFP_KERNEL);\r\nif (!req)\r\ngoto err_req;\r\nreq->complete = pn_rx_complete;\r\nfp->out_reqv[i] = req;\r\n}\r\nfp->in_req = usb_ep_alloc_request(fp->in_ep, GFP_KERNEL);\r\nif (!fp->in_req)\r\ngoto err_req;\r\nINFO(cdev, "USB CDC Phonet function\n");\r\nINFO(cdev, "using %s, OUT %s, IN %s\n", cdev->gadget->name,\r\nfp->out_ep->name, fp->in_ep->name);\r\nreturn 0;\r\nerr_req:\r\nfor (i = 0; i < phonet_rxq_size && fp->out_reqv[i]; i++)\r\nusb_ep_free_request(fp->out_ep, fp->out_reqv[i]);\r\nusb_free_all_descriptors(f);\r\nerr:\r\nif (fp->out_ep)\r\nfp->out_ep->driver_data = NULL;\r\nif (fp->in_ep)\r\nfp->in_ep->driver_data = NULL;\r\nERROR(cdev, "USB CDC Phonet: cannot autoconfigure\n");\r\nreturn status;\r\n}\r\nstatic inline struct f_phonet_opts *to_f_phonet_opts(struct config_item *item)\r\n{\r\nreturn container_of(to_config_group(item), struct f_phonet_opts,\r\nfunc_inst.group);\r\n}\r\nstatic ssize_t f_phonet_attr_show(struct config_item *item,\r\nstruct configfs_attribute *attr,\r\nchar *page)\r\n{\r\nstruct f_phonet_opts *opts = to_f_phonet_opts(item);\r\nstruct f_phonet_opts_attribute *f_phonet_opts_attr =\r\ncontainer_of(attr, struct f_phonet_opts_attribute, attr);\r\nssize_t ret = 0;\r\nif (f_phonet_opts_attr->show)\r\nret = f_phonet_opts_attr->show(opts, page);\r\nreturn ret;\r\n}\r\nstatic void phonet_attr_release(struct config_item *item)\r\n{\r\nstruct f_phonet_opts *opts = to_f_phonet_opts(item);\r\nusb_put_function_instance(&opts->func_inst);\r\n}\r\nstatic ssize_t f_phonet_ifname_show(struct f_phonet_opts *opts, char *page)\r\n{\r\nreturn gether_get_ifname(opts->net, page, PAGE_SIZE);\r\n}\r\nstatic void phonet_free_inst(struct usb_function_instance *f)\r\n{\r\nstruct f_phonet_opts *opts;\r\nopts = container_of(f, struct f_phonet_opts, func_inst);\r\nif (opts->bound)\r\ngphonet_cleanup(opts->net);\r\nelse\r\nfree_netdev(opts->net);\r\nkfree(opts);\r\n}\r\nstatic struct usb_function_instance *phonet_alloc_inst(void)\r\n{\r\nstruct f_phonet_opts *opts;\r\nopts = kzalloc(sizeof(*opts), GFP_KERNEL);\r\nif (!opts)\r\nreturn ERR_PTR(-ENOMEM);\r\nopts->func_inst.free_func_inst = phonet_free_inst;\r\nopts->net = gphonet_setup_default();\r\nif (IS_ERR(opts->net)) {\r\nstruct net_device *net = opts->net;\r\nkfree(opts);\r\nreturn ERR_CAST(net);\r\n}\r\nconfig_group_init_type_name(&opts->func_inst.group, "",\r\n&phonet_func_type);\r\nreturn &opts->func_inst;\r\n}\r\nstatic void phonet_free(struct usb_function *f)\r\n{\r\nstruct f_phonet *phonet;\r\nphonet = func_to_pn(f);\r\nkfree(phonet);\r\n}\r\nstatic void pn_unbind(struct usb_configuration *c, struct usb_function *f)\r\n{\r\nstruct f_phonet *fp = func_to_pn(f);\r\nint i;\r\nif (fp->in_req)\r\nusb_ep_free_request(fp->in_ep, fp->in_req);\r\nfor (i = 0; i < phonet_rxq_size; i++)\r\nif (fp->out_reqv[i])\r\nusb_ep_free_request(fp->out_ep, fp->out_reqv[i]);\r\nusb_free_all_descriptors(f);\r\n}\r\nstatic struct usb_function *phonet_alloc(struct usb_function_instance *fi)\r\n{\r\nstruct f_phonet *fp;\r\nstruct f_phonet_opts *opts;\r\nint size;\r\nsize = sizeof(*fp) + (phonet_rxq_size * sizeof(struct usb_request *));\r\nfp = kzalloc(size, GFP_KERNEL);\r\nif (!fp)\r\nreturn ERR_PTR(-ENOMEM);\r\nopts = container_of(fi, struct f_phonet_opts, func_inst);\r\nfp->dev = opts->net;\r\nfp->function.name = "phonet";\r\nfp->function.bind = pn_bind;\r\nfp->function.unbind = pn_unbind;\r\nfp->function.set_alt = pn_set_alt;\r\nfp->function.get_alt = pn_get_alt;\r\nfp->function.disable = pn_disconnect;\r\nfp->function.free_func = phonet_free;\r\nspin_lock_init(&fp->rx.lock);\r\nreturn &fp->function;\r\n}\r\nstruct net_device *gphonet_setup_default(void)\r\n{\r\nstruct net_device *dev;\r\nstruct phonet_port *port;\r\ndev = alloc_netdev(sizeof(*port), "upnlink%d", NET_NAME_UNKNOWN,\r\npn_net_setup);\r\nif (!dev)\r\nreturn ERR_PTR(-ENOMEM);\r\nport = netdev_priv(dev);\r\nspin_lock_init(&port->lock);\r\nnetif_carrier_off(dev);\r\nreturn dev;\r\n}\r\nvoid gphonet_set_gadget(struct net_device *net, struct usb_gadget *g)\r\n{\r\nSET_NETDEV_DEV(net, &g->dev);\r\n}\r\nint gphonet_register_netdev(struct net_device *net)\r\n{\r\nint status;\r\nstatus = register_netdev(net);\r\nif (status)\r\nfree_netdev(net);\r\nreturn status;\r\n}\r\nvoid gphonet_cleanup(struct net_device *dev)\r\n{\r\nunregister_netdev(dev);\r\n}
