static int cryptomgr_probe(void *data)\r\n{\r\nstruct cryptomgr_param *param = data;\r\nstruct crypto_template *tmpl;\r\nstruct crypto_instance *inst;\r\nint err;\r\ntmpl = crypto_lookup_template(param->template);\r\nif (!tmpl)\r\ngoto out;\r\ndo {\r\nif (tmpl->create) {\r\nerr = tmpl->create(tmpl, param->tb);\r\ncontinue;\r\n}\r\ninst = tmpl->alloc(param->tb);\r\nif (IS_ERR(inst))\r\nerr = PTR_ERR(inst);\r\nelse if ((err = crypto_register_instance(tmpl, inst)))\r\ntmpl->free(inst);\r\n} while (err == -EAGAIN && !signal_pending(current));\r\ncrypto_tmpl_put(tmpl);\r\nout:\r\ncomplete_all(&param->larval->completion);\r\ncrypto_alg_put(&param->larval->alg);\r\nkfree(param);\r\nmodule_put_and_exit(0);\r\n}\r\nstatic int cryptomgr_schedule_probe(struct crypto_larval *larval)\r\n{\r\nstruct task_struct *thread;\r\nstruct cryptomgr_param *param;\r\nconst char *name = larval->alg.cra_name;\r\nconst char *p;\r\nunsigned int len;\r\nint i;\r\nif (!try_module_get(THIS_MODULE))\r\ngoto err;\r\nparam = kzalloc(sizeof(*param), GFP_KERNEL);\r\nif (!param)\r\ngoto err_put_module;\r\nfor (p = name; isalnum(*p) || *p == '-' || *p == '_'; p++)\r\n;\r\nlen = p - name;\r\nif (!len || *p != '(')\r\ngoto err_free_param;\r\nmemcpy(param->template, name, len);\r\ni = 0;\r\nfor (;;) {\r\nint notnum = 0;\r\nname = ++p;\r\nlen = 0;\r\nfor (; isalnum(*p) || *p == '-' || *p == '_'; p++)\r\nnotnum |= !isdigit(*p);\r\nif (*p == '(') {\r\nint recursion = 0;\r\nfor (;;) {\r\nif (!*++p)\r\ngoto err_free_param;\r\nif (*p == '(')\r\nrecursion++;\r\nelse if (*p == ')' && !recursion--)\r\nbreak;\r\n}\r\nnotnum = 1;\r\np++;\r\n}\r\nlen = p - name;\r\nif (!len)\r\ngoto err_free_param;\r\nif (notnum) {\r\nparam->attrs[i].alg.attr.rta_len =\r\nsizeof(param->attrs[i].alg);\r\nparam->attrs[i].alg.attr.rta_type = CRYPTOA_ALG;\r\nmemcpy(param->attrs[i].alg.data.name, name, len);\r\n} else {\r\nparam->attrs[i].nu32.attr.rta_len =\r\nsizeof(param->attrs[i].nu32);\r\nparam->attrs[i].nu32.attr.rta_type = CRYPTOA_U32;\r\nparam->attrs[i].nu32.data.num =\r\nsimple_strtol(name, NULL, 0);\r\n}\r\nparam->tb[i + 1] = &param->attrs[i].attr;\r\ni++;\r\nif (i >= CRYPTO_MAX_ATTRS)\r\ngoto err_free_param;\r\nif (*p == ')')\r\nbreak;\r\nif (*p != ',')\r\ngoto err_free_param;\r\n}\r\nif (!i)\r\ngoto err_free_param;\r\nparam->tb[i + 1] = NULL;\r\nparam->type.attr.rta_len = sizeof(param->type);\r\nparam->type.attr.rta_type = CRYPTOA_TYPE;\r\nparam->type.data.type = larval->alg.cra_flags & ~CRYPTO_ALG_TESTED;\r\nparam->type.data.mask = larval->mask & ~CRYPTO_ALG_TESTED;\r\nparam->tb[0] = &param->type.attr;\r\nparam->otype = larval->alg.cra_flags;\r\nparam->omask = larval->mask;\r\ncrypto_alg_get(&larval->alg);\r\nparam->larval = larval;\r\nthread = kthread_run(cryptomgr_probe, param, "cryptomgr_probe");\r\nif (IS_ERR(thread))\r\ngoto err_put_larval;\r\nwait_for_completion_interruptible(&larval->completion);\r\nreturn NOTIFY_STOP;\r\nerr_put_larval:\r\ncrypto_alg_put(&larval->alg);\r\nerr_free_param:\r\nkfree(param);\r\nerr_put_module:\r\nmodule_put(THIS_MODULE);\r\nerr:\r\nreturn NOTIFY_OK;\r\n}\r\nstatic int cryptomgr_test(void *data)\r\n{\r\nstruct crypto_test_param *param = data;\r\nu32 type = param->type;\r\nint err = 0;\r\n#ifdef CONFIG_CRYPTO_MANAGER_DISABLE_TESTS\r\ngoto skiptest;\r\n#endif\r\nif (type & CRYPTO_ALG_TESTED)\r\ngoto skiptest;\r\nerr = alg_test(param->driver, param->alg, type, CRYPTO_ALG_TESTED);\r\nskiptest:\r\ncrypto_alg_tested(param->driver, err);\r\nkfree(param);\r\nmodule_put_and_exit(0);\r\n}\r\nstatic int cryptomgr_schedule_test(struct crypto_alg *alg)\r\n{\r\nstruct task_struct *thread;\r\nstruct crypto_test_param *param;\r\nu32 type;\r\nif (!try_module_get(THIS_MODULE))\r\ngoto err;\r\nparam = kzalloc(sizeof(*param), GFP_KERNEL);\r\nif (!param)\r\ngoto err_put_module;\r\nmemcpy(param->driver, alg->cra_driver_name, sizeof(param->driver));\r\nmemcpy(param->alg, alg->cra_name, sizeof(param->alg));\r\ntype = alg->cra_flags;\r\nif ((!((type ^ CRYPTO_ALG_TYPE_BLKCIPHER) &\r\nCRYPTO_ALG_TYPE_BLKCIPHER_MASK) && !(type & CRYPTO_ALG_GENIV) &&\r\n((alg->cra_flags & CRYPTO_ALG_TYPE_MASK) ==\r\nCRYPTO_ALG_TYPE_BLKCIPHER ? alg->cra_blkcipher.ivsize :\r\nalg->cra_ablkcipher.ivsize)) ||\r\n(!((type ^ CRYPTO_ALG_TYPE_AEAD) & CRYPTO_ALG_TYPE_MASK) &&\r\nalg->cra_type == &crypto_nivaead_type && alg->cra_aead.ivsize))\r\ntype |= CRYPTO_ALG_TESTED;\r\nparam->type = type;\r\nthread = kthread_run(cryptomgr_test, param, "cryptomgr_test");\r\nif (IS_ERR(thread))\r\ngoto err_free_param;\r\nreturn NOTIFY_STOP;\r\nerr_free_param:\r\nkfree(param);\r\nerr_put_module:\r\nmodule_put(THIS_MODULE);\r\nerr:\r\nreturn NOTIFY_OK;\r\n}\r\nstatic int cryptomgr_notify(struct notifier_block *this, unsigned long msg,\r\nvoid *data)\r\n{\r\nswitch (msg) {\r\ncase CRYPTO_MSG_ALG_REQUEST:\r\nreturn cryptomgr_schedule_probe(data);\r\ncase CRYPTO_MSG_ALG_REGISTER:\r\nreturn cryptomgr_schedule_test(data);\r\n}\r\nreturn NOTIFY_DONE;\r\n}\r\nstatic int __init cryptomgr_init(void)\r\n{\r\nreturn crypto_register_notifier(&cryptomgr_notifier);\r\n}\r\nstatic void __exit cryptomgr_exit(void)\r\n{\r\nint err = crypto_unregister_notifier(&cryptomgr_notifier);\r\nBUG_ON(err);\r\n}
