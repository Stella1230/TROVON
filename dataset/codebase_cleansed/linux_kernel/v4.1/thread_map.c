static int filter(const struct dirent *dir)\r\n{\r\nif (dir->d_name[0] == '.')\r\nreturn 0;\r\nelse\r\nreturn 1;\r\n}\r\nstruct thread_map *thread_map__new_by_pid(pid_t pid)\r\n{\r\nstruct thread_map *threads;\r\nchar name[256];\r\nint items;\r\nstruct dirent **namelist = NULL;\r\nint i;\r\nsprintf(name, "/proc/%d/task", pid);\r\nitems = scandir(name, &namelist, filter, NULL);\r\nif (items <= 0)\r\nreturn NULL;\r\nthreads = malloc(sizeof(*threads) + sizeof(pid_t) * items);\r\nif (threads != NULL) {\r\nfor (i = 0; i < items; i++)\r\nthreads->map[i] = atoi(namelist[i]->d_name);\r\nthreads->nr = items;\r\n}\r\nfor (i=0; i<items; i++)\r\nzfree(&namelist[i]);\r\nfree(namelist);\r\nreturn threads;\r\n}\r\nstruct thread_map *thread_map__new_by_tid(pid_t tid)\r\n{\r\nstruct thread_map *threads = malloc(sizeof(*threads) + sizeof(pid_t));\r\nif (threads != NULL) {\r\nthreads->map[0] = tid;\r\nthreads->nr = 1;\r\n}\r\nreturn threads;\r\n}\r\nstruct thread_map *thread_map__new_by_uid(uid_t uid)\r\n{\r\nDIR *proc;\r\nint max_threads = 32, items, i;\r\nchar path[256];\r\nstruct dirent dirent, *next, **namelist = NULL;\r\nstruct thread_map *threads = malloc(sizeof(*threads) +\r\nmax_threads * sizeof(pid_t));\r\nif (threads == NULL)\r\ngoto out;\r\nproc = opendir("/proc");\r\nif (proc == NULL)\r\ngoto out_free_threads;\r\nthreads->nr = 0;\r\nwhile (!readdir_r(proc, &dirent, &next) && next) {\r\nchar *end;\r\nbool grow = false;\r\nstruct stat st;\r\npid_t pid = strtol(dirent.d_name, &end, 10);\r\nif (*end)\r\ncontinue;\r\nsnprintf(path, sizeof(path), "/proc/%s", dirent.d_name);\r\nif (stat(path, &st) != 0)\r\ncontinue;\r\nif (st.st_uid != uid)\r\ncontinue;\r\nsnprintf(path, sizeof(path), "/proc/%d/task", pid);\r\nitems = scandir(path, &namelist, filter, NULL);\r\nif (items <= 0)\r\ngoto out_free_closedir;\r\nwhile (threads->nr + items >= max_threads) {\r\nmax_threads *= 2;\r\ngrow = true;\r\n}\r\nif (grow) {\r\nstruct thread_map *tmp;\r\ntmp = realloc(threads, (sizeof(*threads) +\r\nmax_threads * sizeof(pid_t)));\r\nif (tmp == NULL)\r\ngoto out_free_namelist;\r\nthreads = tmp;\r\n}\r\nfor (i = 0; i < items; i++)\r\nthreads->map[threads->nr + i] = atoi(namelist[i]->d_name);\r\nfor (i = 0; i < items; i++)\r\nzfree(&namelist[i]);\r\nfree(namelist);\r\nthreads->nr += items;\r\n}\r\nout_closedir:\r\nclosedir(proc);\r\nout:\r\nreturn threads;\r\nout_free_threads:\r\nfree(threads);\r\nreturn NULL;\r\nout_free_namelist:\r\nfor (i = 0; i < items; i++)\r\nzfree(&namelist[i]);\r\nfree(namelist);\r\nout_free_closedir:\r\nzfree(&threads);\r\ngoto out_closedir;\r\n}\r\nstruct thread_map *thread_map__new(pid_t pid, pid_t tid, uid_t uid)\r\n{\r\nif (pid != -1)\r\nreturn thread_map__new_by_pid(pid);\r\nif (tid == -1 && uid != UINT_MAX)\r\nreturn thread_map__new_by_uid(uid);\r\nreturn thread_map__new_by_tid(tid);\r\n}\r\nstatic struct thread_map *thread_map__new_by_pid_str(const char *pid_str)\r\n{\r\nstruct thread_map *threads = NULL, *nt;\r\nchar name[256];\r\nint items, total_tasks = 0;\r\nstruct dirent **namelist = NULL;\r\nint i, j = 0;\r\npid_t pid, prev_pid = INT_MAX;\r\nchar *end_ptr;\r\nstruct str_node *pos;\r\nstruct strlist *slist = strlist__new(false, pid_str);\r\nif (!slist)\r\nreturn NULL;\r\nstrlist__for_each(pos, slist) {\r\npid = strtol(pos->s, &end_ptr, 10);\r\nif (pid == INT_MIN || pid == INT_MAX ||\r\n(*end_ptr != '\0' && *end_ptr != ','))\r\ngoto out_free_threads;\r\nif (pid == prev_pid)\r\ncontinue;\r\nsprintf(name, "/proc/%d/task", pid);\r\nitems = scandir(name, &namelist, filter, NULL);\r\nif (items <= 0)\r\ngoto out_free_threads;\r\ntotal_tasks += items;\r\nnt = realloc(threads, (sizeof(*threads) +\r\nsizeof(pid_t) * total_tasks));\r\nif (nt == NULL)\r\ngoto out_free_namelist;\r\nthreads = nt;\r\nfor (i = 0; i < items; i++) {\r\nthreads->map[j++] = atoi(namelist[i]->d_name);\r\nzfree(&namelist[i]);\r\n}\r\nthreads->nr = total_tasks;\r\nfree(namelist);\r\n}\r\nout:\r\nstrlist__delete(slist);\r\nreturn threads;\r\nout_free_namelist:\r\nfor (i = 0; i < items; i++)\r\nzfree(&namelist[i]);\r\nfree(namelist);\r\nout_free_threads:\r\nzfree(&threads);\r\ngoto out;\r\n}\r\nstruct thread_map *thread_map__new_dummy(void)\r\n{\r\nstruct thread_map *threads = malloc(sizeof(*threads) + sizeof(pid_t));\r\nif (threads != NULL) {\r\nthreads->map[0] = -1;\r\nthreads->nr = 1;\r\n}\r\nreturn threads;\r\n}\r\nstatic struct thread_map *thread_map__new_by_tid_str(const char *tid_str)\r\n{\r\nstruct thread_map *threads = NULL, *nt;\r\nint ntasks = 0;\r\npid_t tid, prev_tid = INT_MAX;\r\nchar *end_ptr;\r\nstruct str_node *pos;\r\nstruct strlist *slist;\r\nif (!tid_str)\r\nreturn thread_map__new_dummy();\r\nslist = strlist__new(false, tid_str);\r\nif (!slist)\r\nreturn NULL;\r\nstrlist__for_each(pos, slist) {\r\ntid = strtol(pos->s, &end_ptr, 10);\r\nif (tid == INT_MIN || tid == INT_MAX ||\r\n(*end_ptr != '\0' && *end_ptr != ','))\r\ngoto out_free_threads;\r\nif (tid == prev_tid)\r\ncontinue;\r\nntasks++;\r\nnt = realloc(threads, sizeof(*threads) + sizeof(pid_t) * ntasks);\r\nif (nt == NULL)\r\ngoto out_free_threads;\r\nthreads = nt;\r\nthreads->map[ntasks - 1] = tid;\r\nthreads->nr = ntasks;\r\n}\r\nout:\r\nreturn threads;\r\nout_free_threads:\r\nzfree(&threads);\r\ngoto out;\r\n}\r\nstruct thread_map *thread_map__new_str(const char *pid, const char *tid,\r\nuid_t uid)\r\n{\r\nif (pid)\r\nreturn thread_map__new_by_pid_str(pid);\r\nif (!tid && uid != UINT_MAX)\r\nreturn thread_map__new_by_uid(uid);\r\nreturn thread_map__new_by_tid_str(tid);\r\n}\r\nvoid thread_map__delete(struct thread_map *threads)\r\n{\r\nfree(threads);\r\n}\r\nsize_t thread_map__fprintf(struct thread_map *threads, FILE *fp)\r\n{\r\nint i;\r\nsize_t printed = fprintf(fp, "%d thread%s: ",\r\nthreads->nr, threads->nr > 1 ? "s" : "");\r\nfor (i = 0; i < threads->nr; ++i)\r\nprinted += fprintf(fp, "%s%d", i ? ", " : "", threads->map[i]);\r\nreturn printed + fprintf(fp, "\n");\r\n}
