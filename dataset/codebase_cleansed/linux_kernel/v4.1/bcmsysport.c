static inline void dma_desc_set_addr(struct bcm_sysport_priv *priv,\r\nvoid __iomem *d,\r\ndma_addr_t addr)\r\n{\r\n#ifdef CONFIG_PHYS_ADDR_T_64BIT\r\n__raw_writel(upper_32_bits(addr) & DESC_ADDR_HI_MASK,\r\nd + DESC_ADDR_HI_STATUS_LEN);\r\n#endif\r\n__raw_writel(lower_32_bits(addr), d + DESC_ADDR_LO);\r\n}\r\nstatic inline void tdma_port_write_desc_addr(struct bcm_sysport_priv *priv,\r\nstruct dma_desc *desc,\r\nunsigned int port)\r\n{\r\ntdma_writel(priv, desc->addr_status_len, TDMA_WRITE_PORT_HI(port));\r\ntdma_writel(priv, desc->addr_lo, TDMA_WRITE_PORT_LO(port));\r\n}\r\nstatic int bcm_sysport_set_settings(struct net_device *dev,\r\nstruct ethtool_cmd *cmd)\r\n{\r\nstruct bcm_sysport_priv *priv = netdev_priv(dev);\r\nif (!netif_running(dev))\r\nreturn -EINVAL;\r\nreturn phy_ethtool_sset(priv->phydev, cmd);\r\n}\r\nstatic int bcm_sysport_get_settings(struct net_device *dev,\r\nstruct ethtool_cmd *cmd)\r\n{\r\nstruct bcm_sysport_priv *priv = netdev_priv(dev);\r\nif (!netif_running(dev))\r\nreturn -EINVAL;\r\nreturn phy_ethtool_gset(priv->phydev, cmd);\r\n}\r\nstatic int bcm_sysport_set_rx_csum(struct net_device *dev,\r\nnetdev_features_t wanted)\r\n{\r\nstruct bcm_sysport_priv *priv = netdev_priv(dev);\r\nu32 reg;\r\npriv->rx_chk_en = !!(wanted & NETIF_F_RXCSUM);\r\nreg = rxchk_readl(priv, RXCHK_CONTROL);\r\nif (priv->rx_chk_en)\r\nreg |= RXCHK_EN;\r\nelse\r\nreg &= ~RXCHK_EN;\r\nif (priv->rx_chk_en && priv->crc_fwd)\r\nreg |= RXCHK_SKIP_FCS;\r\nelse\r\nreg &= ~RXCHK_SKIP_FCS;\r\nif (netdev_uses_dsa(dev))\r\nreg |= RXCHK_BRCM_TAG_EN;\r\nelse\r\nreg &= ~RXCHK_BRCM_TAG_EN;\r\nrxchk_writel(priv, reg, RXCHK_CONTROL);\r\nreturn 0;\r\n}\r\nstatic int bcm_sysport_set_tx_csum(struct net_device *dev,\r\nnetdev_features_t wanted)\r\n{\r\nstruct bcm_sysport_priv *priv = netdev_priv(dev);\r\nu32 reg;\r\npriv->tsb_en = !!(wanted & (NETIF_F_IP_CSUM | NETIF_F_IPV6_CSUM));\r\nreg = tdma_readl(priv, TDMA_CONTROL);\r\nif (priv->tsb_en)\r\nreg |= TSB_EN;\r\nelse\r\nreg &= ~TSB_EN;\r\ntdma_writel(priv, reg, TDMA_CONTROL);\r\nreturn 0;\r\n}\r\nstatic int bcm_sysport_set_features(struct net_device *dev,\r\nnetdev_features_t features)\r\n{\r\nnetdev_features_t changed = features ^ dev->features;\r\nnetdev_features_t wanted = dev->wanted_features;\r\nint ret = 0;\r\nif (changed & NETIF_F_RXCSUM)\r\nret = bcm_sysport_set_rx_csum(dev, wanted);\r\nif (changed & (NETIF_F_IP_CSUM | NETIF_F_IPV6_CSUM))\r\nret = bcm_sysport_set_tx_csum(dev, wanted);\r\nreturn ret;\r\n}\r\nstatic void bcm_sysport_get_drvinfo(struct net_device *dev,\r\nstruct ethtool_drvinfo *info)\r\n{\r\nstrlcpy(info->driver, KBUILD_MODNAME, sizeof(info->driver));\r\nstrlcpy(info->version, "0.1", sizeof(info->version));\r\nstrlcpy(info->bus_info, "platform", sizeof(info->bus_info));\r\ninfo->n_stats = BCM_SYSPORT_STATS_LEN;\r\n}\r\nstatic u32 bcm_sysport_get_msglvl(struct net_device *dev)\r\n{\r\nstruct bcm_sysport_priv *priv = netdev_priv(dev);\r\nreturn priv->msg_enable;\r\n}\r\nstatic void bcm_sysport_set_msglvl(struct net_device *dev, u32 enable)\r\n{\r\nstruct bcm_sysport_priv *priv = netdev_priv(dev);\r\npriv->msg_enable = enable;\r\n}\r\nstatic int bcm_sysport_get_sset_count(struct net_device *dev, int string_set)\r\n{\r\nswitch (string_set) {\r\ncase ETH_SS_STATS:\r\nreturn BCM_SYSPORT_STATS_LEN;\r\ndefault:\r\nreturn -EOPNOTSUPP;\r\n}\r\n}\r\nstatic void bcm_sysport_get_strings(struct net_device *dev,\r\nu32 stringset, u8 *data)\r\n{\r\nint i;\r\nswitch (stringset) {\r\ncase ETH_SS_STATS:\r\nfor (i = 0; i < BCM_SYSPORT_STATS_LEN; i++) {\r\nmemcpy(data + i * ETH_GSTRING_LEN,\r\nbcm_sysport_gstrings_stats[i].stat_string,\r\nETH_GSTRING_LEN);\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic void bcm_sysport_update_mib_counters(struct bcm_sysport_priv *priv)\r\n{\r\nint i, j = 0;\r\nfor (i = 0; i < BCM_SYSPORT_STATS_LEN; i++) {\r\nconst struct bcm_sysport_stats *s;\r\nu8 offset = 0;\r\nu32 val = 0;\r\nchar *p;\r\ns = &bcm_sysport_gstrings_stats[i];\r\nswitch (s->type) {\r\ncase BCM_SYSPORT_STAT_NETDEV:\r\ncase BCM_SYSPORT_STAT_SOFT:\r\ncontinue;\r\ncase BCM_SYSPORT_STAT_MIB_RX:\r\ncase BCM_SYSPORT_STAT_MIB_TX:\r\ncase BCM_SYSPORT_STAT_RUNT:\r\nif (s->type != BCM_SYSPORT_STAT_MIB_RX)\r\noffset = UMAC_MIB_STAT_OFFSET;\r\nval = umac_readl(priv, UMAC_MIB_START + j + offset);\r\nbreak;\r\ncase BCM_SYSPORT_STAT_RXCHK:\r\nval = rxchk_readl(priv, s->reg_offset);\r\nif (val == ~0)\r\nrxchk_writel(priv, 0, s->reg_offset);\r\nbreak;\r\ncase BCM_SYSPORT_STAT_RBUF:\r\nval = rbuf_readl(priv, s->reg_offset);\r\nif (val == ~0)\r\nrbuf_writel(priv, 0, s->reg_offset);\r\nbreak;\r\n}\r\nj += s->stat_sizeof;\r\np = (char *)priv + s->stat_offset;\r\n*(u32 *)p = val;\r\n}\r\nnetif_dbg(priv, hw, priv->netdev, "updated MIB counters\n");\r\n}\r\nstatic void bcm_sysport_get_stats(struct net_device *dev,\r\nstruct ethtool_stats *stats, u64 *data)\r\n{\r\nstruct bcm_sysport_priv *priv = netdev_priv(dev);\r\nint i;\r\nif (netif_running(dev))\r\nbcm_sysport_update_mib_counters(priv);\r\nfor (i = 0; i < BCM_SYSPORT_STATS_LEN; i++) {\r\nconst struct bcm_sysport_stats *s;\r\nchar *p;\r\ns = &bcm_sysport_gstrings_stats[i];\r\nif (s->type == BCM_SYSPORT_STAT_NETDEV)\r\np = (char *)&dev->stats;\r\nelse\r\np = (char *)priv;\r\np += s->stat_offset;\r\ndata[i] = *(u32 *)p;\r\n}\r\n}\r\nstatic void bcm_sysport_get_wol(struct net_device *dev,\r\nstruct ethtool_wolinfo *wol)\r\n{\r\nstruct bcm_sysport_priv *priv = netdev_priv(dev);\r\nu32 reg;\r\nwol->supported = WAKE_MAGIC | WAKE_MAGICSECURE;\r\nwol->wolopts = priv->wolopts;\r\nif (!(priv->wolopts & WAKE_MAGICSECURE))\r\nreturn;\r\nreg = umac_readl(priv, UMAC_PSW_MS);\r\nput_unaligned_be16(reg, &wol->sopass[0]);\r\nreg = umac_readl(priv, UMAC_PSW_LS);\r\nput_unaligned_be32(reg, &wol->sopass[2]);\r\n}\r\nstatic int bcm_sysport_set_wol(struct net_device *dev,\r\nstruct ethtool_wolinfo *wol)\r\n{\r\nstruct bcm_sysport_priv *priv = netdev_priv(dev);\r\nstruct device *kdev = &priv->pdev->dev;\r\nu32 supported = WAKE_MAGIC | WAKE_MAGICSECURE;\r\nif (!device_can_wakeup(kdev))\r\nreturn -ENOTSUPP;\r\nif (wol->wolopts & ~supported)\r\nreturn -EINVAL;\r\nif (wol->wolopts & WAKE_MAGICSECURE) {\r\numac_writel(priv, get_unaligned_be16(&wol->sopass[0]),\r\nUMAC_PSW_MS);\r\numac_writel(priv, get_unaligned_be32(&wol->sopass[2]),\r\nUMAC_PSW_LS);\r\n}\r\nif (wol->wolopts) {\r\ndevice_set_wakeup_enable(kdev, 1);\r\nif (priv->wol_irq_disabled)\r\nenable_irq_wake(priv->wol_irq);\r\npriv->wol_irq_disabled = 0;\r\n} else {\r\ndevice_set_wakeup_enable(kdev, 0);\r\nif (!priv->wol_irq_disabled)\r\ndisable_irq_wake(priv->wol_irq);\r\npriv->wol_irq_disabled = 1;\r\n}\r\npriv->wolopts = wol->wolopts;\r\nreturn 0;\r\n}\r\nstatic void bcm_sysport_free_cb(struct bcm_sysport_cb *cb)\r\n{\r\ndev_kfree_skb_any(cb->skb);\r\ncb->skb = NULL;\r\ndma_unmap_addr_set(cb, dma_addr, 0);\r\n}\r\nstatic int bcm_sysport_rx_refill(struct bcm_sysport_priv *priv,\r\nstruct bcm_sysport_cb *cb)\r\n{\r\nstruct device *kdev = &priv->pdev->dev;\r\nstruct net_device *ndev = priv->netdev;\r\ndma_addr_t mapping;\r\nint ret;\r\ncb->skb = netdev_alloc_skb(priv->netdev, RX_BUF_LENGTH);\r\nif (!cb->skb) {\r\nnetif_err(priv, rx_err, ndev, "SKB alloc failed\n");\r\nreturn -ENOMEM;\r\n}\r\nmapping = dma_map_single(kdev, cb->skb->data,\r\nRX_BUF_LENGTH, DMA_FROM_DEVICE);\r\nret = dma_mapping_error(kdev, mapping);\r\nif (ret) {\r\npriv->mib.rx_dma_failed++;\r\nbcm_sysport_free_cb(cb);\r\nnetif_err(priv, rx_err, ndev, "DMA mapping failure\n");\r\nreturn ret;\r\n}\r\ndma_unmap_addr_set(cb, dma_addr, mapping);\r\ndma_desc_set_addr(priv, priv->rx_bd_assign_ptr, mapping);\r\npriv->rx_bd_assign_index++;\r\npriv->rx_bd_assign_index &= (priv->num_rx_bds - 1);\r\npriv->rx_bd_assign_ptr = priv->rx_bds +\r\n(priv->rx_bd_assign_index * DESC_SIZE);\r\nnetif_dbg(priv, rx_status, ndev, "RX refill\n");\r\nreturn 0;\r\n}\r\nstatic int bcm_sysport_alloc_rx_bufs(struct bcm_sysport_priv *priv)\r\n{\r\nstruct bcm_sysport_cb *cb;\r\nint ret = 0;\r\nunsigned int i;\r\nfor (i = 0; i < priv->num_rx_bds; i++) {\r\ncb = &priv->rx_cbs[priv->rx_bd_assign_index];\r\nif (cb->skb)\r\ncontinue;\r\nret = bcm_sysport_rx_refill(priv, cb);\r\nif (ret)\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic unsigned int bcm_sysport_desc_rx(struct bcm_sysport_priv *priv,\r\nunsigned int budget)\r\n{\r\nstruct device *kdev = &priv->pdev->dev;\r\nstruct net_device *ndev = priv->netdev;\r\nunsigned int processed = 0, to_process;\r\nstruct bcm_sysport_cb *cb;\r\nstruct sk_buff *skb;\r\nunsigned int p_index;\r\nu16 len, status;\r\nstruct bcm_rsb *rsb;\r\nint ret;\r\np_index = rdma_readl(priv, RDMA_PROD_INDEX);\r\np_index &= RDMA_PROD_INDEX_MASK;\r\nif (p_index < priv->rx_c_index)\r\nto_process = (RDMA_CONS_INDEX_MASK + 1) -\r\npriv->rx_c_index + p_index;\r\nelse\r\nto_process = p_index - priv->rx_c_index;\r\nnetif_dbg(priv, rx_status, ndev,\r\n"p_index=%d rx_c_index=%d to_process=%d\n",\r\np_index, priv->rx_c_index, to_process);\r\nwhile ((processed < to_process) && (processed < budget)) {\r\ncb = &priv->rx_cbs[priv->rx_read_ptr];\r\nskb = cb->skb;\r\nprocessed++;\r\npriv->rx_read_ptr++;\r\nif (priv->rx_read_ptr == priv->num_rx_bds)\r\npriv->rx_read_ptr = 0;\r\nif (unlikely(!skb)) {\r\nnetif_err(priv, rx_err, ndev, "out of memory!\n");\r\nndev->stats.rx_dropped++;\r\nndev->stats.rx_errors++;\r\ngoto refill;\r\n}\r\ndma_unmap_single(kdev, dma_unmap_addr(cb, dma_addr),\r\nRX_BUF_LENGTH, DMA_FROM_DEVICE);\r\nrsb = (struct bcm_rsb *)skb->data;\r\nlen = (rsb->rx_status_len >> DESC_LEN_SHIFT) & DESC_LEN_MASK;\r\nstatus = (rsb->rx_status_len >> DESC_STATUS_SHIFT) &\r\nDESC_STATUS_MASK;\r\nnetif_dbg(priv, rx_status, ndev,\r\n"p=%d, c=%d, rd_ptr=%d, len=%d, flag=0x%04x\n",\r\np_index, priv->rx_c_index, priv->rx_read_ptr,\r\nlen, status);\r\nif (unlikely(!(status & DESC_EOP) || !(status & DESC_SOP))) {\r\nnetif_err(priv, rx_status, ndev, "fragmented packet!\n");\r\nndev->stats.rx_dropped++;\r\nndev->stats.rx_errors++;\r\nbcm_sysport_free_cb(cb);\r\ngoto refill;\r\n}\r\nif (unlikely(status & (RX_STATUS_ERR | RX_STATUS_OVFLOW))) {\r\nnetif_err(priv, rx_err, ndev, "error packet\n");\r\nif (status & RX_STATUS_OVFLOW)\r\nndev->stats.rx_over_errors++;\r\nndev->stats.rx_dropped++;\r\nndev->stats.rx_errors++;\r\nbcm_sysport_free_cb(cb);\r\ngoto refill;\r\n}\r\nskb_put(skb, len);\r\nif (likely(status & DESC_L4_CSUM))\r\nskb->ip_summed = CHECKSUM_UNNECESSARY;\r\nskb_pull(skb, sizeof(*rsb) + 2);\r\nlen -= (sizeof(*rsb) + 2);\r\nif (priv->crc_fwd) {\r\nskb_trim(skb, len - ETH_FCS_LEN);\r\nlen -= ETH_FCS_LEN;\r\n}\r\nskb->protocol = eth_type_trans(skb, ndev);\r\nndev->stats.rx_packets++;\r\nndev->stats.rx_bytes += len;\r\nnapi_gro_receive(&priv->napi, skb);\r\nrefill:\r\nret = bcm_sysport_rx_refill(priv, cb);\r\nif (ret)\r\npriv->mib.alloc_rx_buff_failed++;\r\n}\r\nreturn processed;\r\n}\r\nstatic void bcm_sysport_tx_reclaim_one(struct bcm_sysport_priv *priv,\r\nstruct bcm_sysport_cb *cb,\r\nunsigned int *bytes_compl,\r\nunsigned int *pkts_compl)\r\n{\r\nstruct device *kdev = &priv->pdev->dev;\r\nstruct net_device *ndev = priv->netdev;\r\nif (cb->skb) {\r\nndev->stats.tx_bytes += cb->skb->len;\r\n*bytes_compl += cb->skb->len;\r\ndma_unmap_single(kdev, dma_unmap_addr(cb, dma_addr),\r\ndma_unmap_len(cb, dma_len),\r\nDMA_TO_DEVICE);\r\nndev->stats.tx_packets++;\r\n(*pkts_compl)++;\r\nbcm_sysport_free_cb(cb);\r\n} else if (dma_unmap_addr(cb, dma_addr)) {\r\nndev->stats.tx_bytes += dma_unmap_len(cb, dma_len);\r\ndma_unmap_page(kdev, dma_unmap_addr(cb, dma_addr),\r\ndma_unmap_len(cb, dma_len), DMA_TO_DEVICE);\r\ndma_unmap_addr_set(cb, dma_addr, 0);\r\n}\r\n}\r\nstatic unsigned int __bcm_sysport_tx_reclaim(struct bcm_sysport_priv *priv,\r\nstruct bcm_sysport_tx_ring *ring)\r\n{\r\nstruct net_device *ndev = priv->netdev;\r\nunsigned int c_index, last_c_index, last_tx_cn, num_tx_cbs;\r\nunsigned int pkts_compl = 0, bytes_compl = 0;\r\nstruct bcm_sysport_cb *cb;\r\nstruct netdev_queue *txq;\r\nu32 hw_ind;\r\ntxq = netdev_get_tx_queue(ndev, ring->index);\r\nhw_ind = tdma_readl(priv, TDMA_DESC_RING_PROD_CONS_INDEX(ring->index));\r\nc_index = (hw_ind >> RING_CONS_INDEX_SHIFT) & RING_CONS_INDEX_MASK;\r\nring->p_index = (hw_ind & RING_PROD_INDEX_MASK);\r\nlast_c_index = ring->c_index;\r\nnum_tx_cbs = ring->size;\r\nc_index &= (num_tx_cbs - 1);\r\nif (c_index >= last_c_index)\r\nlast_tx_cn = c_index - last_c_index;\r\nelse\r\nlast_tx_cn = num_tx_cbs - last_c_index + c_index;\r\nnetif_dbg(priv, tx_done, ndev,\r\n"ring=%d c_index=%d last_tx_cn=%d last_c_index=%d\n",\r\nring->index, c_index, last_tx_cn, last_c_index);\r\nwhile (last_tx_cn-- > 0) {\r\ncb = ring->cbs + last_c_index;\r\nbcm_sysport_tx_reclaim_one(priv, cb, &bytes_compl, &pkts_compl);\r\nring->desc_count++;\r\nlast_c_index++;\r\nlast_c_index &= (num_tx_cbs - 1);\r\n}\r\nring->c_index = c_index;\r\nif (netif_tx_queue_stopped(txq) && pkts_compl)\r\nnetif_tx_wake_queue(txq);\r\nnetif_dbg(priv, tx_done, ndev,\r\n"ring=%d c_index=%d pkts_compl=%d, bytes_compl=%d\n",\r\nring->index, ring->c_index, pkts_compl, bytes_compl);\r\nreturn pkts_compl;\r\n}\r\nstatic unsigned int bcm_sysport_tx_reclaim(struct bcm_sysport_priv *priv,\r\nstruct bcm_sysport_tx_ring *ring)\r\n{\r\nunsigned int released;\r\nunsigned long flags;\r\nspin_lock_irqsave(&ring->lock, flags);\r\nreleased = __bcm_sysport_tx_reclaim(priv, ring);\r\nspin_unlock_irqrestore(&ring->lock, flags);\r\nreturn released;\r\n}\r\nstatic int bcm_sysport_tx_poll(struct napi_struct *napi, int budget)\r\n{\r\nstruct bcm_sysport_tx_ring *ring =\r\ncontainer_of(napi, struct bcm_sysport_tx_ring, napi);\r\nunsigned int work_done = 0;\r\nwork_done = bcm_sysport_tx_reclaim(ring->priv, ring);\r\nif (work_done == 0) {\r\nnapi_complete(napi);\r\nintrl2_1_mask_clear(ring->priv, BIT(ring->index));\r\nreturn 0;\r\n}\r\nreturn budget;\r\n}\r\nstatic void bcm_sysport_tx_reclaim_all(struct bcm_sysport_priv *priv)\r\n{\r\nunsigned int q;\r\nfor (q = 0; q < priv->netdev->num_tx_queues; q++)\r\nbcm_sysport_tx_reclaim(priv, &priv->tx_rings[q]);\r\n}\r\nstatic int bcm_sysport_poll(struct napi_struct *napi, int budget)\r\n{\r\nstruct bcm_sysport_priv *priv =\r\ncontainer_of(napi, struct bcm_sysport_priv, napi);\r\nunsigned int work_done = 0;\r\nwork_done = bcm_sysport_desc_rx(priv, budget);\r\npriv->rx_c_index += work_done;\r\npriv->rx_c_index &= RDMA_CONS_INDEX_MASK;\r\nrdma_writel(priv, priv->rx_c_index, RDMA_CONS_INDEX);\r\nif (work_done < budget) {\r\nnapi_complete(napi);\r\nintrl2_0_mask_clear(priv, INTRL2_0_RDMA_MBDONE);\r\n}\r\nreturn work_done;\r\n}\r\nstatic void bcm_sysport_resume_from_wol(struct bcm_sysport_priv *priv)\r\n{\r\nu32 reg;\r\nintrl2_0_mask_set(priv, INTRL2_0_MPD);\r\nreg = umac_readl(priv, UMAC_MPD_CTRL);\r\nreg &= ~MPD_EN;\r\numac_writel(priv, reg, UMAC_MPD_CTRL);\r\nnetif_dbg(priv, wol, priv->netdev, "resumed from WOL\n");\r\n}\r\nstatic irqreturn_t bcm_sysport_rx_isr(int irq, void *dev_id)\r\n{\r\nstruct net_device *dev = dev_id;\r\nstruct bcm_sysport_priv *priv = netdev_priv(dev);\r\npriv->irq0_stat = intrl2_0_readl(priv, INTRL2_CPU_STATUS) &\r\n~intrl2_0_readl(priv, INTRL2_CPU_MASK_STATUS);\r\nintrl2_0_writel(priv, priv->irq0_stat, INTRL2_CPU_CLEAR);\r\nif (unlikely(priv->irq0_stat == 0)) {\r\nnetdev_warn(priv->netdev, "spurious RX interrupt\n");\r\nreturn IRQ_NONE;\r\n}\r\nif (priv->irq0_stat & INTRL2_0_RDMA_MBDONE) {\r\nif (likely(napi_schedule_prep(&priv->napi))) {\r\nintrl2_0_mask_set(priv, INTRL2_0_RDMA_MBDONE);\r\n__napi_schedule(&priv->napi);\r\n}\r\n}\r\nif (priv->irq0_stat & INTRL2_0_TX_RING_FULL)\r\nbcm_sysport_tx_reclaim_all(priv);\r\nif (priv->irq0_stat & INTRL2_0_MPD) {\r\nnetdev_info(priv->netdev, "Wake-on-LAN interrupt!\n");\r\nbcm_sysport_resume_from_wol(priv);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t bcm_sysport_tx_isr(int irq, void *dev_id)\r\n{\r\nstruct net_device *dev = dev_id;\r\nstruct bcm_sysport_priv *priv = netdev_priv(dev);\r\nstruct bcm_sysport_tx_ring *txr;\r\nunsigned int ring;\r\npriv->irq1_stat = intrl2_1_readl(priv, INTRL2_CPU_STATUS) &\r\n~intrl2_1_readl(priv, INTRL2_CPU_MASK_STATUS);\r\nintrl2_1_writel(priv, 0xffffffff, INTRL2_CPU_CLEAR);\r\nif (unlikely(priv->irq1_stat == 0)) {\r\nnetdev_warn(priv->netdev, "spurious TX interrupt\n");\r\nreturn IRQ_NONE;\r\n}\r\nfor (ring = 0; ring < dev->num_tx_queues; ring++) {\r\nif (!(priv->irq1_stat & BIT(ring)))\r\ncontinue;\r\ntxr = &priv->tx_rings[ring];\r\nif (likely(napi_schedule_prep(&txr->napi))) {\r\nintrl2_1_mask_set(priv, BIT(ring));\r\n__napi_schedule(&txr->napi);\r\n}\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t bcm_sysport_wol_isr(int irq, void *dev_id)\r\n{\r\nstruct bcm_sysport_priv *priv = dev_id;\r\npm_wakeup_event(&priv->pdev->dev, 0);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic struct sk_buff *bcm_sysport_insert_tsb(struct sk_buff *skb,\r\nstruct net_device *dev)\r\n{\r\nstruct sk_buff *nskb;\r\nstruct bcm_tsb *tsb;\r\nu32 csum_info;\r\nu8 ip_proto;\r\nu16 csum_start;\r\nu16 ip_ver;\r\nif (unlikely(skb_headroom(skb) < sizeof(*tsb))) {\r\nnskb = skb_realloc_headroom(skb, sizeof(*tsb));\r\ndev_kfree_skb(skb);\r\nif (!nskb) {\r\ndev->stats.tx_errors++;\r\ndev->stats.tx_dropped++;\r\nreturn NULL;\r\n}\r\nskb = nskb;\r\n}\r\ntsb = (struct bcm_tsb *)skb_push(skb, sizeof(*tsb));\r\nmemset(tsb, 0, sizeof(*tsb));\r\nif (skb->ip_summed == CHECKSUM_PARTIAL) {\r\nip_ver = htons(skb->protocol);\r\nswitch (ip_ver) {\r\ncase ETH_P_IP:\r\nip_proto = ip_hdr(skb)->protocol;\r\nbreak;\r\ncase ETH_P_IPV6:\r\nip_proto = ipv6_hdr(skb)->nexthdr;\r\nbreak;\r\ndefault:\r\nreturn skb;\r\n}\r\ncsum_start = skb_checksum_start_offset(skb) - sizeof(*tsb);\r\ncsum_info = (csum_start + skb->csum_offset) & L4_CSUM_PTR_MASK;\r\ncsum_info |= (csum_start << L4_PTR_SHIFT);\r\nif (ip_proto == IPPROTO_TCP || ip_proto == IPPROTO_UDP) {\r\ncsum_info |= L4_LENGTH_VALID;\r\nif (ip_proto == IPPROTO_UDP && ip_ver == ETH_P_IP)\r\ncsum_info |= L4_UDP;\r\n} else {\r\ncsum_info = 0;\r\n}\r\ntsb->l4_ptr_dest_map = csum_info;\r\n}\r\nreturn skb;\r\n}\r\nstatic netdev_tx_t bcm_sysport_xmit(struct sk_buff *skb,\r\nstruct net_device *dev)\r\n{\r\nstruct bcm_sysport_priv *priv = netdev_priv(dev);\r\nstruct device *kdev = &priv->pdev->dev;\r\nstruct bcm_sysport_tx_ring *ring;\r\nstruct bcm_sysport_cb *cb;\r\nstruct netdev_queue *txq;\r\nstruct dma_desc *desc;\r\nunsigned int skb_len;\r\nunsigned long flags;\r\ndma_addr_t mapping;\r\nu32 len_status;\r\nu16 queue;\r\nint ret;\r\nqueue = skb_get_queue_mapping(skb);\r\ntxq = netdev_get_tx_queue(dev, queue);\r\nring = &priv->tx_rings[queue];\r\nspin_lock_irqsave(&ring->lock, flags);\r\nif (unlikely(ring->desc_count == 0)) {\r\nnetif_tx_stop_queue(txq);\r\nnetdev_err(dev, "queue %d awake and ring full!\n", queue);\r\nret = NETDEV_TX_BUSY;\r\ngoto out;\r\n}\r\nif (priv->tsb_en) {\r\nskb = bcm_sysport_insert_tsb(skb, dev);\r\nif (!skb) {\r\nret = NETDEV_TX_OK;\r\ngoto out;\r\n}\r\n}\r\nif (skb_padto(skb, ETH_ZLEN + ENET_BRCM_TAG_LEN)) {\r\nret = NETDEV_TX_OK;\r\ngoto out;\r\n}\r\nskb_len = skb->len < ETH_ZLEN + ENET_BRCM_TAG_LEN ?\r\nETH_ZLEN + ENET_BRCM_TAG_LEN : skb->len;\r\nmapping = dma_map_single(kdev, skb->data, skb_len, DMA_TO_DEVICE);\r\nif (dma_mapping_error(kdev, mapping)) {\r\npriv->mib.tx_dma_failed++;\r\nnetif_err(priv, tx_err, dev, "DMA map failed at %p (len=%d)\n",\r\nskb->data, skb_len);\r\nret = NETDEV_TX_OK;\r\ngoto out;\r\n}\r\ncb = &ring->cbs[ring->curr_desc];\r\ncb->skb = skb;\r\ndma_unmap_addr_set(cb, dma_addr, mapping);\r\ndma_unmap_len_set(cb, dma_len, skb_len);\r\ndesc = ring->desc_cpu;\r\ndesc->addr_lo = lower_32_bits(mapping);\r\nlen_status = upper_32_bits(mapping) & DESC_ADDR_HI_MASK;\r\nlen_status |= (skb_len << DESC_LEN_SHIFT);\r\nlen_status |= (DESC_SOP | DESC_EOP | TX_STATUS_APP_CRC) <<\r\nDESC_STATUS_SHIFT;\r\nif (skb->ip_summed == CHECKSUM_PARTIAL)\r\nlen_status |= (DESC_L4_CSUM << DESC_STATUS_SHIFT);\r\nring->curr_desc++;\r\nif (ring->curr_desc == ring->size)\r\nring->curr_desc = 0;\r\nring->desc_count--;\r\nwmb();\r\ndesc->addr_status_len = len_status;\r\nwmb();\r\ntdma_port_write_desc_addr(priv, desc, ring->index);\r\nif (ring->desc_count == 0)\r\nnetif_tx_stop_queue(txq);\r\nnetif_dbg(priv, tx_queued, dev, "ring=%d desc_count=%d, curr_desc=%d\n",\r\nring->index, ring->desc_count, ring->curr_desc);\r\nret = NETDEV_TX_OK;\r\nout:\r\nspin_unlock_irqrestore(&ring->lock, flags);\r\nreturn ret;\r\n}\r\nstatic void bcm_sysport_tx_timeout(struct net_device *dev)\r\n{\r\nnetdev_warn(dev, "transmit timeout!\n");\r\ndev->trans_start = jiffies;\r\ndev->stats.tx_errors++;\r\nnetif_tx_wake_all_queues(dev);\r\n}\r\nstatic void bcm_sysport_adj_link(struct net_device *dev)\r\n{\r\nstruct bcm_sysport_priv *priv = netdev_priv(dev);\r\nstruct phy_device *phydev = priv->phydev;\r\nunsigned int changed = 0;\r\nu32 cmd_bits = 0, reg;\r\nif (priv->old_link != phydev->link) {\r\nchanged = 1;\r\npriv->old_link = phydev->link;\r\n}\r\nif (priv->old_duplex != phydev->duplex) {\r\nchanged = 1;\r\npriv->old_duplex = phydev->duplex;\r\n}\r\nswitch (phydev->speed) {\r\ncase SPEED_2500:\r\ncmd_bits = CMD_SPEED_2500;\r\nbreak;\r\ncase SPEED_1000:\r\ncmd_bits = CMD_SPEED_1000;\r\nbreak;\r\ncase SPEED_100:\r\ncmd_bits = CMD_SPEED_100;\r\nbreak;\r\ncase SPEED_10:\r\ncmd_bits = CMD_SPEED_10;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\ncmd_bits <<= CMD_SPEED_SHIFT;\r\nif (phydev->duplex == DUPLEX_HALF)\r\ncmd_bits |= CMD_HD_EN;\r\nif (priv->old_pause != phydev->pause) {\r\nchanged = 1;\r\npriv->old_pause = phydev->pause;\r\n}\r\nif (!phydev->pause)\r\ncmd_bits |= CMD_RX_PAUSE_IGNORE | CMD_TX_PAUSE_IGNORE;\r\nif (!changed)\r\nreturn;\r\nif (phydev->link) {\r\nreg = umac_readl(priv, UMAC_CMD);\r\nreg &= ~((CMD_SPEED_MASK << CMD_SPEED_SHIFT) |\r\nCMD_HD_EN | CMD_RX_PAUSE_IGNORE |\r\nCMD_TX_PAUSE_IGNORE);\r\nreg |= cmd_bits;\r\numac_writel(priv, reg, UMAC_CMD);\r\n}\r\nphy_print_status(priv->phydev);\r\n}\r\nstatic int bcm_sysport_init_tx_ring(struct bcm_sysport_priv *priv,\r\nunsigned int index)\r\n{\r\nstruct bcm_sysport_tx_ring *ring = &priv->tx_rings[index];\r\nstruct device *kdev = &priv->pdev->dev;\r\nsize_t size;\r\nvoid *p;\r\nu32 reg;\r\nsize = 256;\r\np = dma_zalloc_coherent(kdev, sizeof(struct dma_desc), &ring->desc_dma,\r\nGFP_KERNEL);\r\nif (!p) {\r\nnetif_err(priv, hw, priv->netdev, "DMA alloc failed\n");\r\nreturn -ENOMEM;\r\n}\r\nring->cbs = kcalloc(size, sizeof(struct bcm_sysport_cb), GFP_KERNEL);\r\nif (!ring->cbs) {\r\nnetif_err(priv, hw, priv->netdev, "CB allocation failed\n");\r\nreturn -ENOMEM;\r\n}\r\nspin_lock_init(&ring->lock);\r\nring->priv = priv;\r\nnetif_napi_add(priv->netdev, &ring->napi, bcm_sysport_tx_poll, 64);\r\nring->index = index;\r\nring->size = size;\r\nring->alloc_size = ring->size;\r\nring->desc_cpu = p;\r\nring->desc_count = ring->size;\r\nring->curr_desc = 0;\r\ntdma_writel(priv, RING_EN, TDMA_DESC_RING_HEAD_TAIL_PTR(index));\r\ntdma_writel(priv, 0, TDMA_DESC_RING_COUNT(index));\r\ntdma_writel(priv, 1, TDMA_DESC_RING_INTR_CONTROL(index));\r\ntdma_writel(priv, 0, TDMA_DESC_RING_PROD_CONS_INDEX(index));\r\ntdma_writel(priv, RING_IGNORE_STATUS, TDMA_DESC_RING_MAPPING(index));\r\ntdma_writel(priv, 0, TDMA_DESC_RING_PCP_DEI_VID(index));\r\ntdma_writel(priv, ring->size |\r\n1 << RING_HYST_THRESH_SHIFT,\r\nTDMA_DESC_RING_MAX_HYST(index));\r\nreg = tdma_readl(priv, TDMA_TIER1_ARB_0_QUEUE_EN);\r\nreg |= (1 << index);\r\ntdma_writel(priv, reg, TDMA_TIER1_ARB_0_QUEUE_EN);\r\nnapi_enable(&ring->napi);\r\nnetif_dbg(priv, hw, priv->netdev,\r\n"TDMA cfg, size=%d, desc_cpu=%p\n",\r\nring->size, ring->desc_cpu);\r\nreturn 0;\r\n}\r\nstatic void bcm_sysport_fini_tx_ring(struct bcm_sysport_priv *priv,\r\nunsigned int index)\r\n{\r\nstruct bcm_sysport_tx_ring *ring = &priv->tx_rings[index];\r\nstruct device *kdev = &priv->pdev->dev;\r\nu32 reg;\r\nreg = tdma_readl(priv, TDMA_STATUS);\r\nif (!(reg & TDMA_DISABLED))\r\nnetdev_warn(priv->netdev, "TDMA not stopped!\n");\r\nif (!ring->cbs)\r\nreturn;\r\nnapi_disable(&ring->napi);\r\nnetif_napi_del(&ring->napi);\r\nbcm_sysport_tx_reclaim(priv, ring);\r\nkfree(ring->cbs);\r\nring->cbs = NULL;\r\nif (ring->desc_dma) {\r\ndma_free_coherent(kdev, sizeof(struct dma_desc),\r\nring->desc_cpu, ring->desc_dma);\r\nring->desc_dma = 0;\r\n}\r\nring->size = 0;\r\nring->alloc_size = 0;\r\nnetif_dbg(priv, hw, priv->netdev, "TDMA fini done\n");\r\n}\r\nstatic inline int rdma_enable_set(struct bcm_sysport_priv *priv,\r\nunsigned int enable)\r\n{\r\nunsigned int timeout = 1000;\r\nu32 reg;\r\nreg = rdma_readl(priv, RDMA_CONTROL);\r\nif (enable)\r\nreg |= RDMA_EN;\r\nelse\r\nreg &= ~RDMA_EN;\r\nrdma_writel(priv, reg, RDMA_CONTROL);\r\ndo {\r\nreg = rdma_readl(priv, RDMA_STATUS);\r\nif (!!(reg & RDMA_DISABLED) == !enable)\r\nreturn 0;\r\nusleep_range(1000, 2000);\r\n} while (timeout-- > 0);\r\nnetdev_err(priv->netdev, "timeout waiting for RDMA to finish\n");\r\nreturn -ETIMEDOUT;\r\n}\r\nstatic inline int tdma_enable_set(struct bcm_sysport_priv *priv,\r\nunsigned int enable)\r\n{\r\nunsigned int timeout = 1000;\r\nu32 reg;\r\nreg = tdma_readl(priv, TDMA_CONTROL);\r\nif (enable)\r\nreg |= TDMA_EN;\r\nelse\r\nreg &= ~TDMA_EN;\r\ntdma_writel(priv, reg, TDMA_CONTROL);\r\ndo {\r\nreg = tdma_readl(priv, TDMA_STATUS);\r\nif (!!(reg & TDMA_DISABLED) == !enable)\r\nreturn 0;\r\nusleep_range(1000, 2000);\r\n} while (timeout-- > 0);\r\nnetdev_err(priv->netdev, "timeout waiting for TDMA to finish\n");\r\nreturn -ETIMEDOUT;\r\n}\r\nstatic int bcm_sysport_init_rx_ring(struct bcm_sysport_priv *priv)\r\n{\r\nu32 reg;\r\nint ret;\r\npriv->num_rx_bds = NUM_RX_DESC;\r\npriv->rx_bds = priv->base + SYS_PORT_RDMA_OFFSET;\r\npriv->rx_bd_assign_ptr = priv->rx_bds;\r\npriv->rx_bd_assign_index = 0;\r\npriv->rx_c_index = 0;\r\npriv->rx_read_ptr = 0;\r\npriv->rx_cbs = kcalloc(priv->num_rx_bds, sizeof(struct bcm_sysport_cb),\r\nGFP_KERNEL);\r\nif (!priv->rx_cbs) {\r\nnetif_err(priv, hw, priv->netdev, "CB allocation failed\n");\r\nreturn -ENOMEM;\r\n}\r\nret = bcm_sysport_alloc_rx_bufs(priv);\r\nif (ret) {\r\nnetif_err(priv, hw, priv->netdev, "SKB allocation failed\n");\r\nreturn ret;\r\n}\r\nreg = rdma_readl(priv, RDMA_STATUS);\r\nif (!(reg & RDMA_DISABLED))\r\nrdma_enable_set(priv, 0);\r\nrdma_writel(priv, 0, RDMA_WRITE_PTR_LO);\r\nrdma_writel(priv, 0, RDMA_WRITE_PTR_HI);\r\nrdma_writel(priv, 0, RDMA_PROD_INDEX);\r\nrdma_writel(priv, 0, RDMA_CONS_INDEX);\r\nrdma_writel(priv, priv->num_rx_bds << RDMA_RING_SIZE_SHIFT |\r\nRX_BUF_LENGTH, RDMA_RING_BUF_SIZE);\r\nrdma_writel(priv, 0, RDMA_START_ADDR_HI);\r\nrdma_writel(priv, 0, RDMA_START_ADDR_LO);\r\nrdma_writel(priv, 0, RDMA_END_ADDR_HI);\r\nrdma_writel(priv, NUM_HW_RX_DESC_WORDS - 1, RDMA_END_ADDR_LO);\r\nrdma_writel(priv, 1, RDMA_MBDONE_INTR);\r\nnetif_dbg(priv, hw, priv->netdev,\r\n"RDMA cfg, num_rx_bds=%d, rx_bds=%p\n",\r\npriv->num_rx_bds, priv->rx_bds);\r\nreturn 0;\r\n}\r\nstatic void bcm_sysport_fini_rx_ring(struct bcm_sysport_priv *priv)\r\n{\r\nstruct bcm_sysport_cb *cb;\r\nunsigned int i;\r\nu32 reg;\r\nreg = rdma_readl(priv, RDMA_STATUS);\r\nif (!(reg & RDMA_DISABLED))\r\nnetdev_warn(priv->netdev, "RDMA not stopped!\n");\r\nfor (i = 0; i < priv->num_rx_bds; i++) {\r\ncb = &priv->rx_cbs[i];\r\nif (dma_unmap_addr(cb, dma_addr))\r\ndma_unmap_single(&priv->pdev->dev,\r\ndma_unmap_addr(cb, dma_addr),\r\nRX_BUF_LENGTH, DMA_FROM_DEVICE);\r\nbcm_sysport_free_cb(cb);\r\n}\r\nkfree(priv->rx_cbs);\r\npriv->rx_cbs = NULL;\r\nnetif_dbg(priv, hw, priv->netdev, "RDMA fini done\n");\r\n}\r\nstatic void bcm_sysport_set_rx_mode(struct net_device *dev)\r\n{\r\nstruct bcm_sysport_priv *priv = netdev_priv(dev);\r\nu32 reg;\r\nreg = umac_readl(priv, UMAC_CMD);\r\nif (dev->flags & IFF_PROMISC)\r\nreg |= CMD_PROMISC;\r\nelse\r\nreg &= ~CMD_PROMISC;\r\numac_writel(priv, reg, UMAC_CMD);\r\nif (dev->flags & IFF_ALLMULTI)\r\nreturn;\r\n}\r\nstatic inline void umac_enable_set(struct bcm_sysport_priv *priv,\r\nu32 mask, unsigned int enable)\r\n{\r\nu32 reg;\r\nreg = umac_readl(priv, UMAC_CMD);\r\nif (enable)\r\nreg |= mask;\r\nelse\r\nreg &= ~mask;\r\numac_writel(priv, reg, UMAC_CMD);\r\nif (enable == 0)\r\nusleep_range(1000, 2000);\r\n}\r\nstatic inline void umac_reset(struct bcm_sysport_priv *priv)\r\n{\r\nu32 reg;\r\nreg = umac_readl(priv, UMAC_CMD);\r\nreg |= CMD_SW_RESET;\r\numac_writel(priv, reg, UMAC_CMD);\r\nudelay(10);\r\nreg = umac_readl(priv, UMAC_CMD);\r\nreg &= ~CMD_SW_RESET;\r\numac_writel(priv, reg, UMAC_CMD);\r\n}\r\nstatic void umac_set_hw_addr(struct bcm_sysport_priv *priv,\r\nunsigned char *addr)\r\n{\r\numac_writel(priv, (addr[0] << 24) | (addr[1] << 16) |\r\n(addr[2] << 8) | addr[3], UMAC_MAC0);\r\numac_writel(priv, (addr[4] << 8) | addr[5], UMAC_MAC1);\r\n}\r\nstatic void topctrl_flush(struct bcm_sysport_priv *priv)\r\n{\r\ntopctrl_writel(priv, RX_FLUSH, RX_FLUSH_CNTL);\r\ntopctrl_writel(priv, TX_FLUSH, TX_FLUSH_CNTL);\r\nmdelay(1);\r\ntopctrl_writel(priv, 0, RX_FLUSH_CNTL);\r\ntopctrl_writel(priv, 0, TX_FLUSH_CNTL);\r\n}\r\nstatic int bcm_sysport_change_mac(struct net_device *dev, void *p)\r\n{\r\nstruct bcm_sysport_priv *priv = netdev_priv(dev);\r\nstruct sockaddr *addr = p;\r\nif (!is_valid_ether_addr(addr->sa_data))\r\nreturn -EINVAL;\r\nmemcpy(dev->dev_addr, addr->sa_data, dev->addr_len);\r\nif (!netif_running(dev))\r\nreturn 0;\r\numac_set_hw_addr(priv, dev->dev_addr);\r\nreturn 0;\r\n}\r\nstatic void bcm_sysport_netif_start(struct net_device *dev)\r\n{\r\nstruct bcm_sysport_priv *priv = netdev_priv(dev);\r\nnapi_enable(&priv->napi);\r\nintrl2_0_mask_clear(priv, INTRL2_0_RDMA_MBDONE | INTRL2_0_TX_RING_FULL);\r\nphy_start(priv->phydev);\r\nintrl2_1_mask_clear(priv, 0xffffffff);\r\nnetif_tx_start_all_queues(dev);\r\n}\r\nstatic void rbuf_init(struct bcm_sysport_priv *priv)\r\n{\r\nu32 reg;\r\nreg = rbuf_readl(priv, RBUF_CONTROL);\r\nreg |= RBUF_4B_ALGN | RBUF_RSB_EN;\r\nrbuf_writel(priv, reg, RBUF_CONTROL);\r\n}\r\nstatic int bcm_sysport_open(struct net_device *dev)\r\n{\r\nstruct bcm_sysport_priv *priv = netdev_priv(dev);\r\nunsigned int i;\r\nint ret;\r\numac_reset(priv);\r\ntopctrl_flush(priv);\r\numac_enable_set(priv, CMD_RX_EN | CMD_TX_EN, 0);\r\nrbuf_init(priv);\r\numac_writel(priv, UMAC_MAX_MTU_SIZE, UMAC_MAX_FRAME_LEN);\r\numac_set_hw_addr(priv, dev->dev_addr);\r\npriv->crc_fwd = !!(umac_readl(priv, UMAC_CMD) & CMD_CRC_FWD);\r\npriv->phydev = of_phy_connect(dev, priv->phy_dn, bcm_sysport_adj_link,\r\n0, priv->phy_interface);\r\nif (!priv->phydev) {\r\nnetdev_err(dev, "could not attach to PHY\n");\r\nreturn -ENODEV;\r\n}\r\npriv->old_duplex = -1;\r\npriv->old_link = -1;\r\npriv->old_pause = -1;\r\nintrl2_0_writel(priv, 0xffffffff, INTRL2_CPU_MASK_SET);\r\nintrl2_0_writel(priv, 0xffffffff, INTRL2_CPU_CLEAR);\r\nintrl2_0_writel(priv, 0, INTRL2_CPU_MASK_CLEAR);\r\nintrl2_1_writel(priv, 0xffffffff, INTRL2_CPU_MASK_SET);\r\nintrl2_1_writel(priv, 0xffffffff, INTRL2_CPU_CLEAR);\r\nintrl2_1_writel(priv, 0, INTRL2_CPU_MASK_CLEAR);\r\nret = request_irq(priv->irq0, bcm_sysport_rx_isr, 0, dev->name, dev);\r\nif (ret) {\r\nnetdev_err(dev, "failed to request RX interrupt\n");\r\ngoto out_phy_disconnect;\r\n}\r\nret = request_irq(priv->irq1, bcm_sysport_tx_isr, 0, dev->name, dev);\r\nif (ret) {\r\nnetdev_err(dev, "failed to request TX interrupt\n");\r\ngoto out_free_irq0;\r\n}\r\nfor (i = 0; i < dev->num_tx_queues; i++) {\r\nret = bcm_sysport_init_tx_ring(priv, i);\r\nif (ret) {\r\nnetdev_err(dev, "failed to initialize TX ring %d\n",\r\ni);\r\ngoto out_free_tx_ring;\r\n}\r\n}\r\ntdma_writel(priv, TDMA_LL_RAM_INIT_BUSY, TDMA_STATUS);\r\nret = bcm_sysport_init_rx_ring(priv);\r\nif (ret) {\r\nnetdev_err(dev, "failed to initialize RX ring\n");\r\ngoto out_free_rx_ring;\r\n}\r\nret = rdma_enable_set(priv, 1);\r\nif (ret)\r\ngoto out_free_rx_ring;\r\nret = tdma_enable_set(priv, 1);\r\nif (ret)\r\ngoto out_clear_rx_int;\r\numac_enable_set(priv, CMD_RX_EN | CMD_TX_EN, 1);\r\nbcm_sysport_netif_start(dev);\r\nreturn 0;\r\nout_clear_rx_int:\r\nintrl2_0_mask_set(priv, INTRL2_0_RDMA_MBDONE | INTRL2_0_TX_RING_FULL);\r\nout_free_rx_ring:\r\nbcm_sysport_fini_rx_ring(priv);\r\nout_free_tx_ring:\r\nfor (i = 0; i < dev->num_tx_queues; i++)\r\nbcm_sysport_fini_tx_ring(priv, i);\r\nfree_irq(priv->irq1, dev);\r\nout_free_irq0:\r\nfree_irq(priv->irq0, dev);\r\nout_phy_disconnect:\r\nphy_disconnect(priv->phydev);\r\nreturn ret;\r\n}\r\nstatic void bcm_sysport_netif_stop(struct net_device *dev)\r\n{\r\nstruct bcm_sysport_priv *priv = netdev_priv(dev);\r\nnetif_tx_stop_all_queues(dev);\r\nnapi_disable(&priv->napi);\r\nphy_stop(priv->phydev);\r\nintrl2_0_mask_set(priv, 0xffffffff);\r\nintrl2_0_writel(priv, 0xffffffff, INTRL2_CPU_CLEAR);\r\nintrl2_1_mask_set(priv, 0xffffffff);\r\nintrl2_1_writel(priv, 0xffffffff, INTRL2_CPU_CLEAR);\r\n}\r\nstatic int bcm_sysport_stop(struct net_device *dev)\r\n{\r\nstruct bcm_sysport_priv *priv = netdev_priv(dev);\r\nunsigned int i;\r\nint ret;\r\nbcm_sysport_netif_stop(dev);\r\numac_enable_set(priv, CMD_RX_EN, 0);\r\nret = tdma_enable_set(priv, 0);\r\nif (ret) {\r\nnetdev_err(dev, "timeout disabling RDMA\n");\r\nreturn ret;\r\n}\r\nusleep_range(2000, 3000);\r\nret = rdma_enable_set(priv, 0);\r\nif (ret) {\r\nnetdev_err(dev, "timeout disabling TDMA\n");\r\nreturn ret;\r\n}\r\numac_enable_set(priv, CMD_TX_EN, 0);\r\nfor (i = 0; i < dev->num_tx_queues; i++)\r\nbcm_sysport_fini_tx_ring(priv, i);\r\nbcm_sysport_fini_rx_ring(priv);\r\nfree_irq(priv->irq0, dev);\r\nfree_irq(priv->irq1, dev);\r\nphy_disconnect(priv->phydev);\r\nreturn 0;\r\n}\r\nstatic int bcm_sysport_probe(struct platform_device *pdev)\r\n{\r\nstruct bcm_sysport_priv *priv;\r\nstruct device_node *dn;\r\nstruct net_device *dev;\r\nconst void *macaddr;\r\nstruct resource *r;\r\nu32 txq, rxq;\r\nint ret;\r\ndn = pdev->dev.of_node;\r\nr = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (of_property_read_u32(dn, "systemport,num-txq", &txq))\r\ntxq = TDMA_NUM_RINGS;\r\nif (of_property_read_u32(dn, "systemport,num-rxq", &rxq))\r\nrxq = 1;\r\ndev = alloc_etherdev_mqs(sizeof(*priv), txq, rxq);\r\nif (!dev)\r\nreturn -ENOMEM;\r\npriv = netdev_priv(dev);\r\npriv->irq0 = platform_get_irq(pdev, 0);\r\npriv->irq1 = platform_get_irq(pdev, 1);\r\npriv->wol_irq = platform_get_irq(pdev, 2);\r\nif (priv->irq0 <= 0 || priv->irq1 <= 0) {\r\ndev_err(&pdev->dev, "invalid interrupts\n");\r\nret = -EINVAL;\r\ngoto err;\r\n}\r\npriv->base = devm_ioremap_resource(&pdev->dev, r);\r\nif (IS_ERR(priv->base)) {\r\nret = PTR_ERR(priv->base);\r\ngoto err;\r\n}\r\npriv->netdev = dev;\r\npriv->pdev = pdev;\r\npriv->phy_interface = of_get_phy_mode(dn);\r\nif (priv->phy_interface < 0)\r\npriv->phy_interface = PHY_INTERFACE_MODE_GMII;\r\nif (of_phy_is_fixed_link(dn)) {\r\nret = of_phy_register_fixed_link(dn);\r\nif (ret) {\r\ndev_err(&pdev->dev, "failed to register fixed PHY\n");\r\ngoto err;\r\n}\r\npriv->phy_dn = dn;\r\n}\r\nmacaddr = of_get_mac_address(dn);\r\nif (!macaddr || !is_valid_ether_addr(macaddr)) {\r\ndev_warn(&pdev->dev, "using random Ethernet MAC\n");\r\nrandom_ether_addr(dev->dev_addr);\r\n} else {\r\nether_addr_copy(dev->dev_addr, macaddr);\r\n}\r\nSET_NETDEV_DEV(dev, &pdev->dev);\r\ndev_set_drvdata(&pdev->dev, dev);\r\ndev->ethtool_ops = &bcm_sysport_ethtool_ops;\r\ndev->netdev_ops = &bcm_sysport_netdev_ops;\r\nnetif_napi_add(dev, &priv->napi, bcm_sysport_poll, 64);\r\ndev->hw_features |= NETIF_F_RXCSUM | NETIF_F_HIGHDMA |\r\nNETIF_F_IP_CSUM | NETIF_F_IPV6_CSUM;\r\npriv->wol_irq_disabled = 1;\r\nret = devm_request_irq(&pdev->dev, priv->wol_irq,\r\nbcm_sysport_wol_isr, 0, dev->name, priv);\r\nif (!ret)\r\ndevice_set_wakeup_capable(&pdev->dev, 1);\r\nBUILD_BUG_ON(sizeof(struct bcm_tsb) != 8);\r\ndev->needed_headroom += sizeof(struct bcm_tsb);\r\nnetif_carrier_off(dev);\r\nret = register_netdev(dev);\r\nif (ret) {\r\ndev_err(&pdev->dev, "failed to register net_device\n");\r\ngoto err;\r\n}\r\npriv->rev = topctrl_readl(priv, REV_CNTL) & REV_MASK;\r\ndev_info(&pdev->dev,\r\n"Broadcom SYSTEMPORT" REV_FMT\r\n" at 0x%p (irqs: %d, %d, TXQs: %d, RXQs: %d)\n",\r\n(priv->rev >> 8) & 0xff, priv->rev & 0xff,\r\npriv->base, priv->irq0, priv->irq1, txq, rxq);\r\nreturn 0;\r\nerr:\r\nfree_netdev(dev);\r\nreturn ret;\r\n}\r\nstatic int bcm_sysport_remove(struct platform_device *pdev)\r\n{\r\nstruct net_device *dev = dev_get_drvdata(&pdev->dev);\r\nunregister_netdev(dev);\r\nfree_netdev(dev);\r\ndev_set_drvdata(&pdev->dev, NULL);\r\nreturn 0;\r\n}\r\nstatic int bcm_sysport_suspend_to_wol(struct bcm_sysport_priv *priv)\r\n{\r\nstruct net_device *ndev = priv->netdev;\r\nunsigned int timeout = 1000;\r\nu32 reg;\r\nreg = umac_readl(priv, UMAC_MPD_CTRL);\r\nreg |= MPD_EN;\r\nreg &= ~PSW_EN;\r\nif (priv->wolopts & WAKE_MAGICSECURE)\r\nreg |= PSW_EN;\r\numac_writel(priv, reg, UMAC_MPD_CTRL);\r\ndo {\r\nreg = rbuf_readl(priv, RBUF_STATUS);\r\nif (reg & RBUF_WOL_MODE)\r\nbreak;\r\nudelay(10);\r\n} while (timeout-- > 0);\r\nif (!timeout) {\r\nreg = umac_readl(priv, UMAC_MPD_CTRL);\r\nreg &= ~MPD_EN;\r\numac_writel(priv, reg, UMAC_MPD_CTRL);\r\nnetif_err(priv, wol, ndev, "failed to enter WOL mode\n");\r\nreturn -ETIMEDOUT;\r\n}\r\numac_enable_set(priv, CMD_RX_EN, 1);\r\nintrl2_0_mask_clear(priv, INTRL2_0_MPD);\r\nnetif_dbg(priv, wol, ndev, "entered WOL mode\n");\r\nreturn 0;\r\n}\r\nstatic int bcm_sysport_suspend(struct device *d)\r\n{\r\nstruct net_device *dev = dev_get_drvdata(d);\r\nstruct bcm_sysport_priv *priv = netdev_priv(dev);\r\nunsigned int i;\r\nint ret = 0;\r\nu32 reg;\r\nif (!netif_running(dev))\r\nreturn 0;\r\nbcm_sysport_netif_stop(dev);\r\nphy_suspend(priv->phydev);\r\nnetif_device_detach(dev);\r\numac_enable_set(priv, CMD_RX_EN, 0);\r\nret = rdma_enable_set(priv, 0);\r\nif (ret) {\r\nnetdev_err(dev, "RDMA timeout!\n");\r\nreturn ret;\r\n}\r\nif (priv->rx_chk_en) {\r\nreg = rxchk_readl(priv, RXCHK_CONTROL);\r\nreg &= ~RXCHK_EN;\r\nrxchk_writel(priv, reg, RXCHK_CONTROL);\r\n}\r\nif (!priv->wolopts)\r\ntopctrl_writel(priv, RX_FLUSH, RX_FLUSH_CNTL);\r\nret = tdma_enable_set(priv, 0);\r\nif (ret) {\r\nnetdev_err(dev, "TDMA timeout!\n");\r\nreturn ret;\r\n}\r\nusleep_range(2000, 3000);\r\numac_enable_set(priv, CMD_TX_EN, 0);\r\ntopctrl_writel(priv, TX_FLUSH, TX_FLUSH_CNTL);\r\nfor (i = 0; i < dev->num_tx_queues; i++)\r\nbcm_sysport_fini_tx_ring(priv, i);\r\nbcm_sysport_fini_rx_ring(priv);\r\nif (device_may_wakeup(d) && priv->wolopts)\r\nret = bcm_sysport_suspend_to_wol(priv);\r\nreturn ret;\r\n}\r\nstatic int bcm_sysport_resume(struct device *d)\r\n{\r\nstruct net_device *dev = dev_get_drvdata(d);\r\nstruct bcm_sysport_priv *priv = netdev_priv(dev);\r\nunsigned int i;\r\nu32 reg;\r\nint ret;\r\nif (!netif_running(dev))\r\nreturn 0;\r\numac_reset(priv);\r\nbcm_sysport_resume_from_wol(priv);\r\nfor (i = 0; i < dev->num_tx_queues; i++) {\r\nret = bcm_sysport_init_tx_ring(priv, i);\r\nif (ret) {\r\nnetdev_err(dev, "failed to initialize TX ring %d\n",\r\ni);\r\ngoto out_free_tx_rings;\r\n}\r\n}\r\ntdma_writel(priv, TDMA_LL_RAM_INIT_BUSY, TDMA_STATUS);\r\nret = bcm_sysport_init_rx_ring(priv);\r\nif (ret) {\r\nnetdev_err(dev, "failed to initialize RX ring\n");\r\ngoto out_free_rx_ring;\r\n}\r\nnetif_device_attach(dev);\r\ntopctrl_writel(priv, 0, RX_FLUSH_CNTL);\r\nret = rdma_enable_set(priv, 1);\r\nif (ret) {\r\nnetdev_err(dev, "failed to enable RDMA\n");\r\ngoto out_free_rx_ring;\r\n}\r\nif (priv->rx_chk_en) {\r\nreg = rxchk_readl(priv, RXCHK_CONTROL);\r\nreg |= RXCHK_EN;\r\nrxchk_writel(priv, reg, RXCHK_CONTROL);\r\n}\r\nrbuf_init(priv);\r\numac_writel(priv, UMAC_MAX_MTU_SIZE, UMAC_MAX_FRAME_LEN);\r\numac_set_hw_addr(priv, dev->dev_addr);\r\numac_enable_set(priv, CMD_RX_EN, 1);\r\ntopctrl_writel(priv, 0, TX_FLUSH_CNTL);\r\numac_enable_set(priv, CMD_TX_EN, 1);\r\nret = tdma_enable_set(priv, 1);\r\nif (ret) {\r\nnetdev_err(dev, "TDMA timeout!\n");\r\ngoto out_free_rx_ring;\r\n}\r\nphy_resume(priv->phydev);\r\nbcm_sysport_netif_start(dev);\r\nreturn 0;\r\nout_free_rx_ring:\r\nbcm_sysport_fini_rx_ring(priv);\r\nout_free_tx_rings:\r\nfor (i = 0; i < dev->num_tx_queues; i++)\r\nbcm_sysport_fini_tx_ring(priv, i);\r\nreturn ret;\r\n}
