static int meson_restart_handle(struct notifier_block *this, unsigned long mode,\r\nvoid *cmd)\r\n{\r\nu32 tc_reboot = MESON_WDT_DC_RESET | MESON_WDT_TC_EN;\r\nstruct meson_wdt_dev *meson_wdt = container_of(this,\r\nstruct meson_wdt_dev,\r\nrestart_handler);\r\nwhile (1) {\r\nwritel(tc_reboot, meson_wdt->wdt_base + MESON_WDT_TC);\r\nmdelay(5);\r\n}\r\nreturn NOTIFY_DONE;\r\n}\r\nstatic int meson_wdt_ping(struct watchdog_device *wdt_dev)\r\n{\r\nstruct meson_wdt_dev *meson_wdt = watchdog_get_drvdata(wdt_dev);\r\nwritel(0, meson_wdt->wdt_base + MESON_WDT_RESET);\r\nreturn 0;\r\n}\r\nstatic void meson_wdt_change_timeout(struct watchdog_device *wdt_dev,\r\nunsigned int timeout)\r\n{\r\nstruct meson_wdt_dev *meson_wdt = watchdog_get_drvdata(wdt_dev);\r\nu32 reg;\r\nreg = readl(meson_wdt->wdt_base + MESON_WDT_TC);\r\nreg &= ~MESON_WDT_TC_TM_MASK;\r\nreg |= MESON_SEC_TO_TC(timeout);\r\nwritel(reg, meson_wdt->wdt_base + MESON_WDT_TC);\r\n}\r\nstatic int meson_wdt_set_timeout(struct watchdog_device *wdt_dev,\r\nunsigned int timeout)\r\n{\r\nwdt_dev->timeout = timeout;\r\nmeson_wdt_change_timeout(wdt_dev, timeout);\r\nmeson_wdt_ping(wdt_dev);\r\nreturn 0;\r\n}\r\nstatic int meson_wdt_stop(struct watchdog_device *wdt_dev)\r\n{\r\nstruct meson_wdt_dev *meson_wdt = watchdog_get_drvdata(wdt_dev);\r\nu32 reg;\r\nreg = readl(meson_wdt->wdt_base + MESON_WDT_TC);\r\nreg &= ~MESON_WDT_TC_EN;\r\nwritel(reg, meson_wdt->wdt_base + MESON_WDT_TC);\r\nreturn 0;\r\n}\r\nstatic int meson_wdt_start(struct watchdog_device *wdt_dev)\r\n{\r\nstruct meson_wdt_dev *meson_wdt = watchdog_get_drvdata(wdt_dev);\r\nu32 reg;\r\nmeson_wdt_change_timeout(wdt_dev, meson_wdt->wdt_dev.timeout);\r\nmeson_wdt_ping(wdt_dev);\r\nreg = readl(meson_wdt->wdt_base + MESON_WDT_TC);\r\nreg |= MESON_WDT_TC_EN;\r\nwritel(reg, meson_wdt->wdt_base + MESON_WDT_TC);\r\nreturn 0;\r\n}\r\nstatic int meson_wdt_probe(struct platform_device *pdev)\r\n{\r\nstruct resource *res;\r\nstruct meson_wdt_dev *meson_wdt;\r\nint err;\r\nmeson_wdt = devm_kzalloc(&pdev->dev, sizeof(*meson_wdt), GFP_KERNEL);\r\nif (!meson_wdt)\r\nreturn -ENOMEM;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nmeson_wdt->wdt_base = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(meson_wdt->wdt_base))\r\nreturn PTR_ERR(meson_wdt->wdt_base);\r\nmeson_wdt->wdt_dev.parent = &pdev->dev;\r\nmeson_wdt->wdt_dev.info = &meson_wdt_info;\r\nmeson_wdt->wdt_dev.ops = &meson_wdt_ops;\r\nmeson_wdt->wdt_dev.timeout = MESON_WDT_TIMEOUT;\r\nmeson_wdt->wdt_dev.max_timeout = MESON_WDT_MAX_TIMEOUT;\r\nmeson_wdt->wdt_dev.min_timeout = MESON_WDT_MIN_TIMEOUT;\r\nwatchdog_set_drvdata(&meson_wdt->wdt_dev, meson_wdt);\r\nwatchdog_init_timeout(&meson_wdt->wdt_dev, timeout, &pdev->dev);\r\nwatchdog_set_nowayout(&meson_wdt->wdt_dev, nowayout);\r\nmeson_wdt_stop(&meson_wdt->wdt_dev);\r\nerr = watchdog_register_device(&meson_wdt->wdt_dev);\r\nif (err)\r\nreturn err;\r\nplatform_set_drvdata(pdev, meson_wdt);\r\nmeson_wdt->restart_handler.notifier_call = meson_restart_handle;\r\nmeson_wdt->restart_handler.priority = 128;\r\nerr = register_restart_handler(&meson_wdt->restart_handler);\r\nif (err)\r\ndev_err(&pdev->dev,\r\n"cannot register restart handler (err=%d)\n", err);\r\ndev_info(&pdev->dev, "Watchdog enabled (timeout=%d sec, nowayout=%d)",\r\nmeson_wdt->wdt_dev.timeout, nowayout);\r\nreturn 0;\r\n}\r\nstatic int meson_wdt_remove(struct platform_device *pdev)\r\n{\r\nstruct meson_wdt_dev *meson_wdt = platform_get_drvdata(pdev);\r\nunregister_restart_handler(&meson_wdt->restart_handler);\r\nwatchdog_unregister_device(&meson_wdt->wdt_dev);\r\nreturn 0;\r\n}\r\nstatic void meson_wdt_shutdown(struct platform_device *pdev)\r\n{\r\nstruct meson_wdt_dev *meson_wdt = platform_get_drvdata(pdev);\r\nmeson_wdt_stop(&meson_wdt->wdt_dev);\r\n}
