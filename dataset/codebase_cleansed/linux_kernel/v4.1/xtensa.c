u32\r\n_nvkm_xtensa_rd32(struct nvkm_object *object, u64 addr)\r\n{\r\nstruct nvkm_xtensa *xtensa = (void *)object;\r\nreturn nv_rd32(xtensa, xtensa->addr + addr);\r\n}\r\nvoid\r\n_nvkm_xtensa_wr32(struct nvkm_object *object, u64 addr, u32 data)\r\n{\r\nstruct nvkm_xtensa *xtensa = (void *)object;\r\nnv_wr32(xtensa, xtensa->addr + addr, data);\r\n}\r\nint\r\n_nvkm_xtensa_engctx_ctor(struct nvkm_object *parent, struct nvkm_object *engine,\r\nstruct nvkm_oclass *oclass, void *data, u32 size,\r\nstruct nvkm_object **pobject)\r\n{\r\nstruct nvkm_engctx *engctx;\r\nint ret;\r\nret = nvkm_engctx_create(parent, engine, oclass, NULL, 0x10000, 0x1000,\r\nNVOBJ_FLAG_ZERO_ALLOC, &engctx);\r\n*pobject = nv_object(engctx);\r\nreturn ret;\r\n}\r\nvoid\r\n_nvkm_xtensa_intr(struct nvkm_subdev *subdev)\r\n{\r\nstruct nvkm_xtensa *xtensa = (void *)subdev;\r\nu32 unk104 = nv_ro32(xtensa, 0xd04);\r\nu32 intr = nv_ro32(xtensa, 0xc20);\r\nu32 chan = nv_ro32(xtensa, 0xc28);\r\nu32 unk10c = nv_ro32(xtensa, 0xd0c);\r\nif (intr & 0x10)\r\nnv_warn(xtensa, "Watchdog interrupt, engine hung.\n");\r\nnv_wo32(xtensa, 0xc20, intr);\r\nintr = nv_ro32(xtensa, 0xc20);\r\nif (unk104 == 0x10001 && unk10c == 0x200 && chan && !intr) {\r\nnv_debug(xtensa, "Enabling FIFO_CTRL\n");\r\nnv_mask(xtensa, xtensa->addr + 0xd94, 0, xtensa->fifo_val);\r\n}\r\n}\r\nint\r\nnvkm_xtensa_create_(struct nvkm_object *parent, struct nvkm_object *engine,\r\nstruct nvkm_oclass *oclass, u32 addr, bool enable,\r\nconst char *iname, const char *fname,\r\nint length, void **pobject)\r\n{\r\nstruct nvkm_xtensa *xtensa;\r\nint ret;\r\nret = nvkm_engine_create_(parent, engine, oclass, enable, iname,\r\nfname, length, pobject);\r\nxtensa = *pobject;\r\nif (ret)\r\nreturn ret;\r\nnv_subdev(xtensa)->intr = _nvkm_xtensa_intr;\r\nxtensa->addr = addr;\r\nreturn 0;\r\n}\r\nint\r\n_nvkm_xtensa_init(struct nvkm_object *object)\r\n{\r\nstruct nvkm_device *device = nv_device(object);\r\nstruct nvkm_xtensa *xtensa = (void *)object;\r\nconst struct firmware *fw;\r\nchar name[32];\r\nint i, ret;\r\nu32 tmp;\r\nret = nvkm_engine_init(&xtensa->base);\r\nif (ret)\r\nreturn ret;\r\nif (!xtensa->gpu_fw) {\r\nsnprintf(name, sizeof(name), "nouveau/nv84_xuc%03x",\r\nxtensa->addr >> 12);\r\nret = request_firmware(&fw, name, nv_device_base(device));\r\nif (ret) {\r\nnv_warn(xtensa, "unable to load firmware %s\n", name);\r\nreturn ret;\r\n}\r\nif (fw->size > 0x40000) {\r\nnv_warn(xtensa, "firmware %s too large\n", name);\r\nrelease_firmware(fw);\r\nreturn -EINVAL;\r\n}\r\nret = nvkm_gpuobj_new(object, NULL, 0x40000, 0x1000, 0,\r\n&xtensa->gpu_fw);\r\nif (ret) {\r\nrelease_firmware(fw);\r\nreturn ret;\r\n}\r\nnv_debug(xtensa, "Loading firmware to address: 0x%llx\n",\r\nxtensa->gpu_fw->addr);\r\nfor (i = 0; i < fw->size / 4; i++)\r\nnv_wo32(xtensa->gpu_fw, i * 4, *((u32 *)fw->data + i));\r\nrelease_firmware(fw);\r\n}\r\nnv_wo32(xtensa, 0xd10, 0x1fffffff);\r\nnv_wo32(xtensa, 0xd08, 0x0fffffff);\r\nnv_wo32(xtensa, 0xd28, xtensa->unkd28);\r\nnv_wo32(xtensa, 0xc20, 0x3f);\r\nnv_wo32(xtensa, 0xd84, 0x3f);\r\nnv_wo32(xtensa, 0xcc0, xtensa->gpu_fw->addr >> 8);\r\nnv_wo32(xtensa, 0xcc4, 0x1c);\r\nnv_wo32(xtensa, 0xcc8, xtensa->gpu_fw->size >> 8);\r\ntmp = nv_rd32(xtensa, 0x0);\r\nnv_wo32(xtensa, 0xde0, tmp);\r\nnv_wo32(xtensa, 0xce8, 0xf);\r\nnv_wo32(xtensa, 0xc20, 0x3f);\r\nnv_wo32(xtensa, 0xd84, 0x3f);\r\nreturn 0;\r\n}\r\nint\r\n_nvkm_xtensa_fini(struct nvkm_object *object, bool suspend)\r\n{\r\nstruct nvkm_xtensa *xtensa = (void *)object;\r\nnv_wo32(xtensa, 0xd84, 0);\r\nnv_wo32(xtensa, 0xd94, 0);\r\nif (!suspend)\r\nnvkm_gpuobj_ref(NULL, &xtensa->gpu_fw);\r\nreturn nvkm_engine_fini(&xtensa->base, suspend);\r\n}
