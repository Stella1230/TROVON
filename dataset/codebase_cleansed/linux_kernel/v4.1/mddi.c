void mddi_activate_link(struct msm_mddi_client_data *cdata)\r\n{\r\nstruct mddi_info *mddi = container_of(cdata, struct mddi_info,\r\nclient_data);\r\nmddi_writel(MDDI_CMD_LINK_ACTIVE, CMD);\r\n}\r\nstatic void mddi_handle_link_list_done(struct mddi_info *mddi)\r\n{\r\n}\r\nstatic void mddi_reset_rev_encap_ptr(struct mddi_info *mddi)\r\n{\r\nprintk(KERN_INFO "mddi: resetting rev ptr\n");\r\nmddi->rev_data_curr = 0;\r\nmddi_writel(mddi->rev_addr, REV_PTR);\r\nmddi_writel(mddi->rev_addr, REV_PTR);\r\nmddi_writel(MDDI_CMD_FORCE_NEW_REV_PTR, CMD);\r\n}\r\nstatic void mddi_handle_rev_data(struct mddi_info *mddi, union mddi_rev *rev)\r\n{\r\nint i;\r\nstruct reg_read_info *ri;\r\nif ((rev->hdr.length <= MDDI_REV_BUFFER_SIZE - 2) &&\r\n(rev->hdr.length >= sizeof(struct mddi_rev_packet) - 2)) {\r\nswitch (rev->hdr.type) {\r\ncase TYPE_CLIENT_CAPS:\r\nmemcpy(&mddi->caps, &rev->caps,\r\nsizeof(struct mddi_client_caps));\r\nmddi->flags |= FLAG_HAVE_CAPS;\r\nwake_up(&mddi->int_wait);\r\nbreak;\r\ncase TYPE_CLIENT_STATUS:\r\nmemcpy(&mddi->status, &rev->status,\r\nsizeof(struct mddi_client_status));\r\nmddi->flags |= FLAG_HAVE_STATUS;\r\nwake_up(&mddi->int_wait);\r\nbreak;\r\ncase TYPE_REGISTER_ACCESS:\r\nri = mddi->reg_read;\r\nif (ri == 0) {\r\nprintk(KERN_INFO "rev: got reg %x = %x without "\r\n" pending read\n",\r\nrev->reg.register_address,\r\nrev->reg.register_data_list);\r\nbreak;\r\n}\r\nif (ri->reg != rev->reg.register_address) {\r\nprintk(KERN_INFO "rev: got reg %x = %x for "\r\n"wrong register, expected "\r\n"%x\n",\r\nrev->reg.register_address,\r\nrev->reg.register_data_list, ri->reg);\r\nbreak;\r\n}\r\nmddi->reg_read = NULL;\r\nri->status = 0;\r\nri->result = rev->reg.register_data_list;\r\ncomplete(&ri->done);\r\nbreak;\r\ndefault:\r\nprintk(KERN_INFO "rev: unknown reverse packet: "\r\n"len=%04x type=%04x CURR_REV_PTR=%x\n",\r\nrev->hdr.length, rev->hdr.type,\r\nmddi_readl(CURR_REV_PTR));\r\nfor (i = 0; i < rev->hdr.length + 2; i++) {\r\nif ((i % 16) == 0)\r\nprintk(KERN_INFO "\n");\r\nprintk(KERN_INFO " %02x", rev->raw[i]);\r\n}\r\nprintk(KERN_INFO "\n");\r\nmddi_reset_rev_encap_ptr(mddi);\r\n}\r\n} else {\r\nprintk(KERN_INFO "bad rev length, %d, CURR_REV_PTR %x\n",\r\nrev->hdr.length, mddi_readl(CURR_REV_PTR));\r\nmddi_reset_rev_encap_ptr(mddi);\r\n}\r\n}\r\nstatic void mddi_handle_rev_data_avail(struct mddi_info *mddi)\r\n{\r\nuint32_t rev_data_count;\r\nuint32_t rev_crc_err_count;\r\nstruct reg_read_info *ri;\r\nsize_t prev_offset;\r\nuint16_t length;\r\nunion mddi_rev *crev = mddi->rev_data + mddi->rev_data_curr;\r\nmddi_writel(MDDI_INT_REV_DATA_AVAIL, INT);\r\nrev_data_count = mddi_readl(REV_PKT_CNT);\r\nrev_crc_err_count = mddi_readl(REV_CRC_ERR);\r\nif (rev_data_count > 1)\r\nprintk(KERN_INFO "rev_data_count %d\n", rev_data_count);\r\nif (rev_crc_err_count) {\r\nprintk(KERN_INFO "rev_crc_err_count %d, INT %x\n",\r\nrev_crc_err_count, mddi_readl(INT));\r\nri = mddi->reg_read;\r\nif (ri == 0) {\r\nprintk(KERN_INFO "rev: got crc error without pending "\r\n"read\n");\r\n} else {\r\nmddi->reg_read = NULL;\r\nri->status = -EIO;\r\nri->result = -1;\r\ncomplete(&ri->done);\r\n}\r\n}\r\nif (rev_data_count == 0)\r\nreturn;\r\nprev_offset = mddi->rev_data_curr;\r\nlength = *((uint8_t *)mddi->rev_data + mddi->rev_data_curr);\r\nmddi->rev_data_curr++;\r\nif (mddi->rev_data_curr == MDDI_REV_BUFFER_SIZE)\r\nmddi->rev_data_curr = 0;\r\nlength += *((uint8_t *)mddi->rev_data + mddi->rev_data_curr) << 8;\r\nmddi->rev_data_curr += 1 + length;\r\nif (mddi->rev_data_curr >= MDDI_REV_BUFFER_SIZE)\r\nmddi->rev_data_curr =\r\nmddi->rev_data_curr % MDDI_REV_BUFFER_SIZE;\r\nif (length > MDDI_REV_BUFFER_SIZE - 2) {\r\nprintk(KERN_INFO "mddi: rev data length greater than buffer"\r\n"size\n");\r\nmddi_reset_rev_encap_ptr(mddi);\r\nreturn;\r\n}\r\nif (prev_offset + 2 + length >= MDDI_REV_BUFFER_SIZE) {\r\nunion mddi_rev tmprev;\r\nsize_t rem = MDDI_REV_BUFFER_SIZE - prev_offset;\r\nmemcpy(&tmprev.raw[0], mddi->rev_data + prev_offset, rem);\r\nmemcpy(&tmprev.raw[rem], mddi->rev_data, 2 + length - rem);\r\nmddi_handle_rev_data(mddi, &tmprev);\r\n} else {\r\nmddi_handle_rev_data(mddi, crev);\r\n}\r\nif (prev_offset < MDDI_REV_BUFFER_SIZE / 2 &&\r\nmddi->rev_data_curr >= MDDI_REV_BUFFER_SIZE / 2) {\r\nmddi_writel(mddi->rev_addr, REV_PTR);\r\n}\r\n}\r\nstatic irqreturn_t mddi_isr(int irq, void *data)\r\n{\r\nstruct msm_mddi_client_data *cdata = data;\r\nstruct mddi_info *mddi = container_of(cdata, struct mddi_info,\r\nclient_data);\r\nuint32_t active, status;\r\nspin_lock(&mddi->int_lock);\r\nactive = mddi_readl(INT);\r\nstatus = mddi_readl(STAT);\r\nmddi_writel(active, INT);\r\nactive &= mddi->int_enable;\r\nmddi->got_int |= active;\r\nwake_up(&mddi->int_wait);\r\nif (active & MDDI_INT_PRI_LINK_LIST_DONE) {\r\nmddi->int_enable &= (~MDDI_INT_PRI_LINK_LIST_DONE);\r\nmddi_handle_link_list_done(mddi);\r\n}\r\nif (active & MDDI_INT_REV_DATA_AVAIL)\r\nmddi_handle_rev_data_avail(mddi);\r\nif (active & ~MDDI_INT_NEED_CLEAR)\r\nmddi->int_enable &= ~(active & ~MDDI_INT_NEED_CLEAR);\r\nif (active & MDDI_INT_LINK_ACTIVE) {\r\nmddi->int_enable &= (~MDDI_INT_LINK_ACTIVE);\r\nmddi->int_enable |= MDDI_INT_IN_HIBERNATION;\r\n}\r\nif (active & MDDI_INT_IN_HIBERNATION) {\r\nmddi->int_enable &= (~MDDI_INT_IN_HIBERNATION);\r\nmddi->int_enable |= MDDI_INT_LINK_ACTIVE;\r\n}\r\nmddi_writel(mddi->int_enable, INTEN);\r\nspin_unlock(&mddi->int_lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic long mddi_wait_interrupt_timeout(struct mddi_info *mddi,\r\nuint32_t intmask, int timeout)\r\n{\r\nunsigned long irq_flags;\r\nspin_lock_irqsave(&mddi->int_lock, irq_flags);\r\nmddi->got_int &= ~intmask;\r\nmddi->int_enable |= intmask;\r\nmddi_writel(mddi->int_enable, INTEN);\r\nspin_unlock_irqrestore(&mddi->int_lock, irq_flags);\r\nreturn wait_event_timeout(mddi->int_wait, mddi->got_int & intmask,\r\ntimeout);\r\n}\r\nstatic void mddi_wait_interrupt(struct mddi_info *mddi, uint32_t intmask)\r\n{\r\nif (mddi_wait_interrupt_timeout(mddi, intmask, HZ/10) == 0)\r\nprintk(KERN_INFO "mddi_wait_interrupt %d, timeout "\r\n"waiting for %x, INT = %x, STAT = %x gotint = %x\n",\r\ncurrent->pid, intmask, mddi_readl(INT), mddi_readl(STAT),\r\nmddi->got_int);\r\n}\r\nstatic void mddi_init_rev_encap(struct mddi_info *mddi)\r\n{\r\nmemset(mddi->rev_data, 0xee, MDDI_REV_BUFFER_SIZE);\r\nmddi_writel(mddi->rev_addr, REV_PTR);\r\nmddi_writel(MDDI_CMD_FORCE_NEW_REV_PTR, CMD);\r\nmddi_wait_interrupt(mddi, MDDI_INT_NO_CMD_PKTS_PEND);\r\n}\r\nvoid mddi_set_auto_hibernate(struct msm_mddi_client_data *cdata, int on)\r\n{\r\nstruct mddi_info *mddi = container_of(cdata, struct mddi_info,\r\nclient_data);\r\nmddi_writel(MDDI_CMD_POWERDOWN, CMD);\r\nmddi_wait_interrupt(mddi, MDDI_INT_IN_HIBERNATION);\r\nmddi_writel(MDDI_CMD_HIBERNATE | !!on, CMD);\r\nmddi_wait_interrupt(mddi, MDDI_INT_NO_CMD_PKTS_PEND);\r\n}\r\nstatic uint16_t mddi_init_registers(struct mddi_info *mddi)\r\n{\r\nmddi_writel(0x0001, VERSION);\r\nmddi_writel(MDDI_HOST_BYTES_PER_SUBFRAME, BPS);\r\nmddi_writel(0x0003, SPM);\r\nmddi_writel(0x0005, TA1_LEN);\r\nmddi_writel(MDDI_HOST_TA2_LEN, TA2_LEN);\r\nmddi_writel(0x0096, DRIVE_HI);\r\nmddi_writel(0x0050, DRIVE_LO);\r\nmddi_writel(0x003C, DISP_WAKE);\r\nmddi_writel(MDDI_HOST_REV_RATE_DIV, REV_RATE_DIV);\r\nmddi_writel(MDDI_REV_BUFFER_SIZE, REV_SIZE);\r\nmddi_writel(MDDI_MAX_REV_PKT_SIZE, REV_ENCAP_SZ);\r\nmddi_writel(MDDI_CMD_PERIODIC_REV_ENCAP, CMD);\r\nmddi_wait_interrupt(mddi, MDDI_INT_NO_CMD_PKTS_PEND);\r\nif (mddi_readl(PAD_CTL) == 0) {\r\nmddi_writel(0x08000, PAD_CTL);\r\nudelay(5);\r\n}\r\nmddi_writel(0xa850f, PAD_CTL);\r\nmddi_writel(0x60006, DRIVER_START_CNT);\r\nmddi_set_auto_hibernate(&mddi->client_data, 0);\r\nmddi_writel(MDDI_CMD_DISP_IGNORE, CMD);\r\nmddi_wait_interrupt(mddi, MDDI_INT_NO_CMD_PKTS_PEND);\r\nmddi_init_rev_encap(mddi);\r\nreturn mddi_readl(CORE_VER) & 0xffff;\r\n}\r\nstatic void mddi_suspend(struct msm_mddi_client_data *cdata)\r\n{\r\nstruct mddi_info *mddi = container_of(cdata, struct mddi_info,\r\nclient_data);\r\nif (mddi->power_client)\r\nmddi->power_client(&mddi->client_data, 0);\r\nmddi_writel(MDDI_CMD_RESET, CMD);\r\nmddi_wait_interrupt(mddi, MDDI_INT_NO_CMD_PKTS_PEND);\r\nclk_disable(mddi->clk);\r\n}\r\nstatic void mddi_resume(struct msm_mddi_client_data *cdata)\r\n{\r\nstruct mddi_info *mddi = container_of(cdata, struct mddi_info,\r\nclient_data);\r\nmddi_set_auto_hibernate(&mddi->client_data, 0);\r\nif (mddi->power_client)\r\nmddi->power_client(&mddi->client_data, 1);\r\nclk_enable(mddi->clk);\r\nmddi->rev_data_curr = 0;\r\nmddi_init_registers(mddi);\r\nmddi_writel(mddi->int_enable, INTEN);\r\nmddi_writel(MDDI_CMD_LINK_ACTIVE, CMD);\r\nmddi_writel(MDDI_CMD_SEND_RTD, CMD);\r\nmddi_wait_interrupt(mddi, MDDI_INT_NO_CMD_PKTS_PEND);\r\nmddi_set_auto_hibernate(&mddi->client_data, 1);\r\n}\r\nstatic int mddi_get_client_caps(struct mddi_info *mddi)\r\n{\r\nint i, j;\r\nmddi_writel(0xffffffff, INT);\r\nmddi->int_enable = MDDI_INT_LINK_ACTIVE |\r\nMDDI_INT_IN_HIBERNATION |\r\nMDDI_INT_PRI_LINK_LIST_DONE |\r\nMDDI_INT_REV_DATA_AVAIL |\r\nMDDI_INT_REV_OVERFLOW |\r\nMDDI_INT_REV_OVERWRITE |\r\nMDDI_INT_RTD_FAILURE;\r\nmddi_writel(mddi->int_enable, INTEN);\r\nmddi_writel(MDDI_CMD_LINK_ACTIVE, CMD);\r\nmddi_wait_interrupt(mddi, MDDI_INT_NO_CMD_PKTS_PEND);\r\nfor (j = 0; j < 3; j++) {\r\nfor (i = 0; i < 4; i++) {\r\nuint32_t stat;\r\nmddi_writel(MDDI_CMD_SEND_RTD, CMD);\r\nmddi_wait_interrupt(mddi, MDDI_INT_NO_CMD_PKTS_PEND);\r\nstat = mddi_readl(STAT);\r\nprintk(KERN_INFO "mddi cmd send rtd: int %x, stat %x, "\r\n"rtd val %x\n", mddi_readl(INT), stat,\r\nmddi_readl(RTD_VAL));\r\nif ((stat & MDDI_STAT_RTD_MEAS_FAIL) == 0)\r\nbreak;\r\nmsleep(1);\r\n}\r\nmddi_writel(CMD_GET_CLIENT_CAP, CMD);\r\nmddi_wait_interrupt(mddi, MDDI_INT_NO_CMD_PKTS_PEND);\r\nwait_event_timeout(mddi->int_wait, mddi->flags & FLAG_HAVE_CAPS,\r\nHZ / 100);\r\nif (mddi->flags & FLAG_HAVE_CAPS)\r\nbreak;\r\nprintk(KERN_INFO "mddi_init, timeout waiting for caps\n");\r\n}\r\nreturn mddi->flags & FLAG_HAVE_CAPS;\r\n}\r\nint mddi_check_status(struct mddi_info *mddi)\r\n{\r\nint ret = -1, retry = 3;\r\nmutex_lock(&mddi->reg_read_lock);\r\nmddi_writel(MDDI_CMD_PERIODIC_REV_ENCAP | 1, CMD);\r\nmddi_wait_interrupt(mddi, MDDI_INT_NO_CMD_PKTS_PEND);\r\ndo {\r\nmddi->flags &= ~FLAG_HAVE_STATUS;\r\nmddi_writel(CMD_GET_CLIENT_STATUS, CMD);\r\nmddi_wait_interrupt(mddi, MDDI_INT_NO_CMD_PKTS_PEND);\r\nwait_event_timeout(mddi->int_wait,\r\nmddi->flags & FLAG_HAVE_STATUS,\r\nHZ / 100);\r\nif (mddi->flags & FLAG_HAVE_STATUS) {\r\nif (mddi->status.crc_error_count)\r\nprintk(KERN_INFO "mddi status: crc_error "\r\n"count: %d\n",\r\nmddi->status.crc_error_count);\r\nelse\r\nret = 0;\r\nbreak;\r\n} else\r\nprintk(KERN_INFO "mddi status: failed to get client "\r\n"status\n");\r\nmddi_writel(MDDI_CMD_SEND_RTD, CMD);\r\nmddi_wait_interrupt(mddi, MDDI_INT_NO_CMD_PKTS_PEND);\r\n} while (--retry);\r\nmddi_writel(MDDI_CMD_PERIODIC_REV_ENCAP | 0, CMD);\r\nmddi_wait_interrupt(mddi, MDDI_INT_NO_CMD_PKTS_PEND);\r\nmutex_unlock(&mddi->reg_read_lock);\r\nreturn ret;\r\n}\r\nvoid mddi_remote_write(struct msm_mddi_client_data *cdata, uint32_t val,\r\nuint32_t reg)\r\n{\r\nstruct mddi_info *mddi = container_of(cdata, struct mddi_info,\r\nclient_data);\r\nstruct mddi_llentry *ll;\r\nstruct mddi_register_access *ra;\r\nmutex_lock(&mddi->reg_write_lock);\r\nll = mddi->reg_write_data;\r\nra = &(ll->u.r);\r\nra->length = 14 + 4;\r\nra->type = TYPE_REGISTER_ACCESS;\r\nra->client_id = 0;\r\nra->read_write_info = MDDI_WRITE | 1;\r\nra->crc16 = 0;\r\nra->register_address = reg;\r\nra->register_data_list = val;\r\nll->flags = 1;\r\nll->header_count = 14;\r\nll->data_count = 4;\r\nll->data = mddi->reg_write_addr + offsetof(struct mddi_llentry,\r\nu.r.register_data_list);\r\nll->next = 0;\r\nll->reserved = 0;\r\nmddi_writel(mddi->reg_write_addr, PRI_PTR);\r\nmddi_wait_interrupt(mddi, MDDI_INT_PRI_LINK_LIST_DONE);\r\nmutex_unlock(&mddi->reg_write_lock);\r\n}\r\nuint32_t mddi_remote_read(struct msm_mddi_client_data *cdata, uint32_t reg)\r\n{\r\nstruct mddi_info *mddi = container_of(cdata, struct mddi_info,\r\nclient_data);\r\nstruct mddi_llentry *ll;\r\nstruct mddi_register_access *ra;\r\nstruct reg_read_info ri;\r\nunsigned s;\r\nint retry_count = 2;\r\nunsigned long irq_flags;\r\nmutex_lock(&mddi->reg_read_lock);\r\nll = mddi->reg_read_data;\r\nra = &(ll->u.r);\r\nra->length = 14;\r\nra->type = TYPE_REGISTER_ACCESS;\r\nra->client_id = 0;\r\nra->read_write_info = MDDI_READ | 1;\r\nra->crc16 = 0;\r\nra->register_address = reg;\r\nll->flags = 0x11;\r\nll->header_count = 14;\r\nll->data_count = 0;\r\nll->data = 0;\r\nll->next = 0;\r\nll->reserved = 0;\r\ns = mddi_readl(STAT);\r\nri.reg = reg;\r\nri.status = -1;\r\ndo {\r\ninit_completion(&ri.done);\r\nmddi->reg_read = &ri;\r\nmddi_writel(mddi->reg_read_addr, PRI_PTR);\r\nmddi_wait_interrupt(mddi, MDDI_INT_PRI_LINK_LIST_DONE);\r\nmddi_writel(MDDI_CMD_PERIODIC_REV_ENCAP | 1, CMD);\r\nmddi_wait_interrupt(mddi, MDDI_INT_NO_CMD_PKTS_PEND);\r\nif (wait_for_completion_timeout(&ri.done, HZ/10) == 0 &&\r\n!ri.done.done) {\r\nprintk(KERN_INFO "mddi_remote_read(%x) timeout "\r\n"(%d %d %d)\n",\r\nreg, ri.status, ri.result, ri.done.done);\r\nspin_lock_irqsave(&mddi->int_lock, irq_flags);\r\nmddi->reg_read = NULL;\r\nspin_unlock_irqrestore(&mddi->int_lock, irq_flags);\r\nri.status = -1;\r\nri.result = -1;\r\n}\r\nif (ri.status == 0)\r\nbreak;\r\nmddi_writel(MDDI_CMD_SEND_RTD, CMD);\r\nmddi_writel(MDDI_CMD_LINK_ACTIVE, CMD);\r\nmddi_wait_interrupt(mddi, MDDI_INT_NO_CMD_PKTS_PEND);\r\nprintk(KERN_INFO "mddi_remote_read: failed, sent "\r\n"MDDI_CMD_SEND_RTD: int %x, stat %x, rtd val %x "\r\n"curr_rev_ptr %x\n", mddi_readl(INT), mddi_readl(STAT),\r\nmddi_readl(RTD_VAL), mddi_readl(CURR_REV_PTR));\r\n} while (retry_count-- > 0);\r\nmddi_writel(MDDI_CMD_PERIODIC_REV_ENCAP | 0, CMD);\r\nmddi_wait_interrupt(mddi, MDDI_INT_NO_CMD_PKTS_PEND);\r\nmddi->reg_read = NULL;\r\nmutex_unlock(&mddi->reg_read_lock);\r\nreturn ri.result;\r\n}\r\nstatic int mddi_clk_setup(struct platform_device *pdev, struct mddi_info *mddi,\r\nunsigned long clk_rate)\r\n{\r\nint ret;\r\nmddi->clk = clk_get(&pdev->dev, "mddi_clk");\r\nif (IS_ERR(mddi->clk)) {\r\nprintk(KERN_INFO "mddi: failed to get clock\n");\r\nreturn PTR_ERR(mddi->clk);\r\n}\r\nret = clk_enable(mddi->clk);\r\nif (ret)\r\ngoto fail;\r\nret = clk_set_rate(mddi->clk, clk_rate);\r\nif (ret)\r\ngoto fail;\r\nreturn 0;\r\nfail:\r\nclk_put(mddi->clk);\r\nreturn ret;\r\n}\r\nstatic int __init mddi_rev_data_setup(struct mddi_info *mddi)\r\n{\r\nvoid *dma;\r\ndma_addr_t dma_addr;\r\ndma = dma_alloc_coherent(NULL, 0x1000, &dma_addr, GFP_KERNEL);\r\nif (dma == 0)\r\nreturn -ENOMEM;\r\nmddi->rev_data = dma;\r\nmddi->rev_data_curr = 0;\r\nmddi->rev_addr = dma_addr;\r\nmddi->reg_write_data = dma + MDDI_REV_BUFFER_SIZE;\r\nmddi->reg_write_addr = dma_addr + MDDI_REV_BUFFER_SIZE;\r\nmddi->reg_read_data = mddi->reg_write_data + 1;\r\nmddi->reg_read_addr = mddi->reg_write_addr +\r\nsizeof(*mddi->reg_write_data);\r\nreturn 0;\r\n}\r\nstatic int mddi_probe(struct platform_device *pdev)\r\n{\r\nstruct msm_mddi_platform_data *pdata = pdev->dev.platform_data;\r\nstruct mddi_info *mddi = &mddi_info[pdev->id];\r\nstruct resource *resource;\r\nint ret, i;\r\nresource = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!resource) {\r\nprintk(KERN_ERR "mddi: no associated mem resource!\n");\r\nreturn -ENOMEM;\r\n}\r\nmddi->base = ioremap(resource->start, resource_size(resource));\r\nif (!mddi->base) {\r\nprintk(KERN_ERR "mddi: failed to remap base!\n");\r\nret = -EINVAL;\r\ngoto error_ioremap;\r\n}\r\nresource = platform_get_resource(pdev, IORESOURCE_IRQ, 0);\r\nif (!resource) {\r\nprintk(KERN_ERR "mddi: no associated irq resource!\n");\r\nret = -EINVAL;\r\ngoto error_get_irq_resource;\r\n}\r\nmddi->irq = resource->start;\r\nprintk(KERN_INFO "mddi: init() base=0x%p irq=%d\n", mddi->base,\r\nmddi->irq);\r\nmddi->power_client = pdata->power_client;\r\nmutex_init(&mddi->reg_write_lock);\r\nmutex_init(&mddi->reg_read_lock);\r\nspin_lock_init(&mddi->int_lock);\r\ninit_waitqueue_head(&mddi->int_wait);\r\nret = mddi_clk_setup(pdev, mddi, pdata->clk_rate);\r\nif (ret) {\r\nprintk(KERN_ERR "mddi: failed to setup clock!\n");\r\ngoto error_clk_setup;\r\n}\r\nret = mddi_rev_data_setup(mddi);\r\nif (ret) {\r\nprintk(KERN_ERR "mddi: failed to setup rev data!\n");\r\ngoto error_rev_data;\r\n}\r\nmddi->int_enable = 0;\r\nmddi_writel(mddi->int_enable, INTEN);\r\nret = request_irq(mddi->irq, mddi_isr, 0, "mddi",\r\n&mddi->client_data);\r\nif (ret) {\r\nprintk(KERN_ERR "mddi: failed to request enable irq!\n");\r\ngoto error_request_irq;\r\n}\r\nif (mddi->power_client)\r\nmddi->power_client(&mddi->client_data, 1);\r\nmddi_set_auto_hibernate(&mddi->client_data, 0);\r\nmddi_writel(MDDI_CMD_RESET, CMD);\r\nmddi_wait_interrupt(mddi, MDDI_INT_NO_CMD_PKTS_PEND);\r\nmddi->version = mddi_init_registers(mddi);\r\nif (mddi->version < 0x20) {\r\nprintk(KERN_ERR "mddi: unsupported version 0x%x\n",\r\nmddi->version);\r\nret = -ENODEV;\r\ngoto error_mddi_version;\r\n}\r\nif (!mddi_get_client_caps(mddi)) {\r\nprintk(KERN_INFO "mddi: no client found\n");\r\nmddi_writel(MDDI_CMD_POWERDOWN, CMD);\r\nprintk(KERN_INFO "mddi powerdown: stat %x\n", mddi_readl(STAT));\r\nmsleep(100);\r\nprintk(KERN_INFO "mddi powerdown: stat %x\n", mddi_readl(STAT));\r\nreturn 0;\r\n}\r\nmddi_set_auto_hibernate(&mddi->client_data, 1);\r\nif (mddi->caps.Mfr_Name == 0 && mddi->caps.Product_Code == 0)\r\npdata->fixup(&mddi->caps.Mfr_Name, &mddi->caps.Product_Code);\r\nmddi->client_pdev.id = 0;\r\nfor (i = 0; i < pdata->num_clients; i++) {\r\nif (pdata->client_platform_data[i].product_id ==\r\n(mddi->caps.Mfr_Name << 16 | mddi->caps.Product_Code)) {\r\nmddi->client_data.private_client_data =\r\npdata->client_platform_data[i].client_data;\r\nmddi->client_pdev.name =\r\npdata->client_platform_data[i].name;\r\nmddi->client_pdev.id =\r\npdata->client_platform_data[i].id;\r\nbreak;\r\n}\r\n}\r\nif (i >= pdata->num_clients)\r\nmddi->client_pdev.name = "mddi_c_dummy";\r\nprintk(KERN_INFO "mddi: registering panel %s\n",\r\nmddi->client_pdev.name);\r\nmddi->client_data.suspend = mddi_suspend;\r\nmddi->client_data.resume = mddi_resume;\r\nmddi->client_data.activate_link = mddi_activate_link;\r\nmddi->client_data.remote_write = mddi_remote_write;\r\nmddi->client_data.remote_read = mddi_remote_read;\r\nmddi->client_data.auto_hibernate = mddi_set_auto_hibernate;\r\nmddi->client_data.fb_resource = pdata->fb_resource;\r\nif (pdev->id == 0)\r\nmddi->client_data.interface_type = MSM_MDDI_PMDH_INTERFACE;\r\nelse if (pdev->id == 1)\r\nmddi->client_data.interface_type = MSM_MDDI_EMDH_INTERFACE;\r\nelse {\r\nprintk(KERN_ERR "mddi: can not determine interface %d!\n",\r\npdev->id);\r\nret = -EINVAL;\r\ngoto error_mddi_interface;\r\n}\r\nmddi->client_pdev.dev.platform_data = &mddi->client_data;\r\nprintk(KERN_INFO "mddi: publish: %s\n", mddi->client_name);\r\nplatform_device_register(&mddi->client_pdev);\r\nreturn 0;\r\nerror_mddi_interface:\r\nerror_mddi_version:\r\nfree_irq(mddi->irq, 0);\r\nerror_request_irq:\r\ndma_free_coherent(NULL, 0x1000, mddi->rev_data, mddi->rev_addr);\r\nerror_rev_data:\r\nerror_clk_setup:\r\nerror_get_irq_resource:\r\niounmap(mddi->base);\r\nerror_ioremap:\r\nprintk(KERN_INFO "mddi: mddi_init() failed (%d)\n", ret);\r\nreturn ret;\r\n}\r\nstatic int __init _mddi_init(void)\r\n{\r\nreturn platform_driver_register(&mddi_driver);\r\n}
