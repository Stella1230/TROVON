static void op_overflow_handler(struct perf_event *event,\r\nstruct perf_sample_data *data, struct pt_regs *regs)\r\n{\r\nint id;\r\nu32 cpu = smp_processor_id();\r\nfor (id = 0; id < num_counters; ++id)\r\nif (per_cpu(perf_events, cpu)[id] == event)\r\nbreak;\r\nif (id != num_counters)\r\noprofile_add_sample(regs, id);\r\nelse\r\npr_warning("oprofile: ignoring spurious overflow "\r\n"on cpu %u\n", cpu);\r\n}\r\nstatic void op_perf_setup(void)\r\n{\r\nint i;\r\nu32 size = sizeof(struct perf_event_attr);\r\nstruct perf_event_attr *attr;\r\nfor (i = 0; i < num_counters; ++i) {\r\nattr = &counter_config[i].attr;\r\nmemset(attr, 0, size);\r\nattr->type = PERF_TYPE_RAW;\r\nattr->size = size;\r\nattr->config = counter_config[i].event;\r\nattr->sample_period = counter_config[i].count;\r\nattr->pinned = 1;\r\n}\r\n}\r\nstatic int op_create_counter(int cpu, int event)\r\n{\r\nstruct perf_event *pevent;\r\nif (!counter_config[event].enabled || per_cpu(perf_events, cpu)[event])\r\nreturn 0;\r\npevent = perf_event_create_kernel_counter(&counter_config[event].attr,\r\ncpu, NULL,\r\nop_overflow_handler, NULL);\r\nif (IS_ERR(pevent))\r\nreturn PTR_ERR(pevent);\r\nif (pevent->state != PERF_EVENT_STATE_ACTIVE) {\r\nperf_event_release_kernel(pevent);\r\npr_warning("oprofile: failed to enable event %d "\r\n"on CPU %d\n", event, cpu);\r\nreturn -EBUSY;\r\n}\r\nper_cpu(perf_events, cpu)[event] = pevent;\r\nreturn 0;\r\n}\r\nstatic void op_destroy_counter(int cpu, int event)\r\n{\r\nstruct perf_event *pevent = per_cpu(perf_events, cpu)[event];\r\nif (pevent) {\r\nperf_event_release_kernel(pevent);\r\nper_cpu(perf_events, cpu)[event] = NULL;\r\n}\r\n}\r\nstatic int op_perf_start(void)\r\n{\r\nint cpu, event, ret = 0;\r\nfor_each_online_cpu(cpu) {\r\nfor (event = 0; event < num_counters; ++event) {\r\nret = op_create_counter(cpu, event);\r\nif (ret)\r\nreturn ret;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic void op_perf_stop(void)\r\n{\r\nint cpu, event;\r\nfor_each_online_cpu(cpu)\r\nfor (event = 0; event < num_counters; ++event)\r\nop_destroy_counter(cpu, event);\r\n}\r\nstatic int oprofile_perf_create_files(struct dentry *root)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < num_counters; i++) {\r\nstruct dentry *dir;\r\nchar buf[4];\r\nsnprintf(buf, sizeof buf, "%d", i);\r\ndir = oprofilefs_mkdir(root, buf);\r\noprofilefs_create_ulong(dir, "enabled", &counter_config[i].enabled);\r\noprofilefs_create_ulong(dir, "event", &counter_config[i].event);\r\noprofilefs_create_ulong(dir, "count", &counter_config[i].count);\r\noprofilefs_create_ulong(dir, "unit_mask", &counter_config[i].unit_mask);\r\noprofilefs_create_ulong(dir, "kernel", &counter_config[i].kernel);\r\noprofilefs_create_ulong(dir, "user", &counter_config[i].user);\r\n}\r\nreturn 0;\r\n}\r\nstatic int oprofile_perf_setup(void)\r\n{\r\nraw_spin_lock(&oprofilefs_lock);\r\nop_perf_setup();\r\nraw_spin_unlock(&oprofilefs_lock);\r\nreturn 0;\r\n}\r\nstatic int oprofile_perf_start(void)\r\n{\r\nint ret = -EBUSY;\r\nmutex_lock(&oprofile_perf_mutex);\r\nif (!oprofile_perf_enabled) {\r\nret = 0;\r\nop_perf_start();\r\noprofile_perf_enabled = 1;\r\n}\r\nmutex_unlock(&oprofile_perf_mutex);\r\nreturn ret;\r\n}\r\nstatic void oprofile_perf_stop(void)\r\n{\r\nmutex_lock(&oprofile_perf_mutex);\r\nif (oprofile_perf_enabled)\r\nop_perf_stop();\r\noprofile_perf_enabled = 0;\r\nmutex_unlock(&oprofile_perf_mutex);\r\n}\r\nstatic int oprofile_perf_suspend(struct platform_device *dev, pm_message_t state)\r\n{\r\nmutex_lock(&oprofile_perf_mutex);\r\nif (oprofile_perf_enabled)\r\nop_perf_stop();\r\nmutex_unlock(&oprofile_perf_mutex);\r\nreturn 0;\r\n}\r\nstatic int oprofile_perf_resume(struct platform_device *dev)\r\n{\r\nmutex_lock(&oprofile_perf_mutex);\r\nif (oprofile_perf_enabled && op_perf_start())\r\noprofile_perf_enabled = 0;\r\nmutex_unlock(&oprofile_perf_mutex);\r\nreturn 0;\r\n}\r\nstatic int __init init_driverfs(void)\r\n{\r\nint ret;\r\nret = platform_driver_register(&oprofile_driver);\r\nif (ret)\r\nreturn ret;\r\noprofile_pdev = platform_device_register_simple(\r\noprofile_driver.driver.name, 0, NULL, 0);\r\nif (IS_ERR(oprofile_pdev)) {\r\nret = PTR_ERR(oprofile_pdev);\r\nplatform_driver_unregister(&oprofile_driver);\r\n}\r\nreturn ret;\r\n}\r\nstatic void exit_driverfs(void)\r\n{\r\nplatform_device_unregister(oprofile_pdev);\r\nplatform_driver_unregister(&oprofile_driver);\r\n}\r\nstatic inline int init_driverfs(void) { return 0; }\r\nstatic inline void exit_driverfs(void) { }\r\nvoid oprofile_perf_exit(void)\r\n{\r\nint cpu, id;\r\nstruct perf_event *event;\r\nfor_each_possible_cpu(cpu) {\r\nfor (id = 0; id < num_counters; ++id) {\r\nevent = per_cpu(perf_events, cpu)[id];\r\nif (event)\r\nperf_event_release_kernel(event);\r\n}\r\nkfree(per_cpu(perf_events, cpu));\r\n}\r\nkfree(counter_config);\r\nexit_driverfs();\r\n}\r\nint __init oprofile_perf_init(struct oprofile_operations *ops)\r\n{\r\nint cpu, ret = 0;\r\nret = init_driverfs();\r\nif (ret)\r\nreturn ret;\r\nnum_counters = perf_num_counters();\r\nif (num_counters <= 0) {\r\npr_info("oprofile: no performance counters\n");\r\nret = -ENODEV;\r\ngoto out;\r\n}\r\ncounter_config = kcalloc(num_counters,\r\nsizeof(struct op_counter_config), GFP_KERNEL);\r\nif (!counter_config) {\r\npr_info("oprofile: failed to allocate %d "\r\n"counters\n", num_counters);\r\nret = -ENOMEM;\r\nnum_counters = 0;\r\ngoto out;\r\n}\r\nfor_each_possible_cpu(cpu) {\r\nper_cpu(perf_events, cpu) = kcalloc(num_counters,\r\nsizeof(struct perf_event *), GFP_KERNEL);\r\nif (!per_cpu(perf_events, cpu)) {\r\npr_info("oprofile: failed to allocate %d perf events "\r\n"for cpu %d\n", num_counters, cpu);\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\n}\r\nops->create_files = oprofile_perf_create_files;\r\nops->setup = oprofile_perf_setup;\r\nops->start = oprofile_perf_start;\r\nops->stop = oprofile_perf_stop;\r\nops->shutdown = oprofile_perf_stop;\r\nops->cpu_type = op_name_from_perf_id();\r\nif (!ops->cpu_type)\r\nret = -ENODEV;\r\nelse\r\npr_info("oprofile: using %s\n", ops->cpu_type);\r\nout:\r\nif (ret)\r\noprofile_perf_exit();\r\nreturn ret;\r\n}
