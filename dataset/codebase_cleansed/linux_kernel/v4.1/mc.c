static int tegra_mc_setup_latency_allowance(struct tegra_mc *mc)\r\n{\r\nunsigned long long tick;\r\nunsigned int i;\r\nu32 value;\r\ntick = mc->tick * clk_get_rate(mc->clk);\r\ndo_div(tick, NSEC_PER_SEC);\r\nvalue = readl(mc->regs + MC_EMEM_ARB_CFG);\r\nvalue &= ~MC_EMEM_ARB_CFG_CYCLES_PER_UPDATE_MASK;\r\nvalue |= MC_EMEM_ARB_CFG_CYCLES_PER_UPDATE(tick);\r\nwritel(value, mc->regs + MC_EMEM_ARB_CFG);\r\nfor (i = 0; i < mc->soc->num_clients; i++) {\r\nconst struct tegra_mc_la *la = &mc->soc->clients[i].la;\r\nu32 value;\r\nvalue = readl(mc->regs + la->reg);\r\nvalue &= ~(la->mask << la->shift);\r\nvalue |= (la->def & la->mask) << la->shift;\r\nwritel(value, mc->regs + la->reg);\r\n}\r\nreturn 0;\r\n}\r\nstatic irqreturn_t tegra_mc_irq(int irq, void *data)\r\n{\r\nstruct tegra_mc *mc = data;\r\nunsigned long status, mask;\r\nunsigned int bit;\r\nstatus = mc_readl(mc, MC_INTSTATUS);\r\nmask = mc_readl(mc, MC_INTMASK);\r\nfor_each_set_bit(bit, &status, 32) {\r\nconst char *error = status_names[bit] ?: "unknown";\r\nconst char *client = "unknown", *desc;\r\nconst char *direction, *secure;\r\nphys_addr_t addr = 0;\r\nunsigned int i;\r\nchar perm[7];\r\nu8 id, type;\r\nu32 value;\r\nvalue = mc_readl(mc, MC_ERR_STATUS);\r\n#ifdef CONFIG_PHYS_ADDR_T_64BIT\r\nif (mc->soc->num_address_bits > 32) {\r\naddr = ((value >> MC_ERR_STATUS_ADR_HI_SHIFT) &\r\nMC_ERR_STATUS_ADR_HI_MASK);\r\naddr <<= 32;\r\n}\r\n#endif\r\nif (value & MC_ERR_STATUS_RW)\r\ndirection = "write";\r\nelse\r\ndirection = "read";\r\nif (value & MC_ERR_STATUS_SECURITY)\r\nsecure = "secure ";\r\nelse\r\nsecure = "";\r\nid = value & MC_ERR_STATUS_CLIENT_MASK;\r\nfor (i = 0; i < mc->soc->num_clients; i++) {\r\nif (mc->soc->clients[i].id == id) {\r\nclient = mc->soc->clients[i].name;\r\nbreak;\r\n}\r\n}\r\ntype = (value & MC_ERR_STATUS_TYPE_MASK) >>\r\nMC_ERR_STATUS_TYPE_SHIFT;\r\ndesc = error_names[type];\r\nswitch (value & MC_ERR_STATUS_TYPE_MASK) {\r\ncase MC_ERR_STATUS_TYPE_INVALID_SMMU_PAGE:\r\nperm[0] = ' ';\r\nperm[1] = '[';\r\nif (value & MC_ERR_STATUS_READABLE)\r\nperm[2] = 'R';\r\nelse\r\nperm[2] = '-';\r\nif (value & MC_ERR_STATUS_WRITABLE)\r\nperm[3] = 'W';\r\nelse\r\nperm[3] = '-';\r\nif (value & MC_ERR_STATUS_NONSECURE)\r\nperm[4] = '-';\r\nelse\r\nperm[4] = 'S';\r\nperm[5] = ']';\r\nperm[6] = '\0';\r\nbreak;\r\ndefault:\r\nperm[0] = '\0';\r\nbreak;\r\n}\r\nvalue = mc_readl(mc, MC_ERR_ADR);\r\naddr |= value;\r\ndev_err_ratelimited(mc->dev, "%s: %s%s @%pa: %s (%s%s)\n",\r\nclient, secure, direction, &addr, error,\r\ndesc, perm);\r\n}\r\nmc_writel(mc, status, MC_INTSTATUS);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int tegra_mc_probe(struct platform_device *pdev)\r\n{\r\nconst struct of_device_id *match;\r\nstruct resource *res;\r\nstruct tegra_mc *mc;\r\nu32 value;\r\nint err;\r\nmatch = of_match_node(tegra_mc_of_match, pdev->dev.of_node);\r\nif (!match)\r\nreturn -ENODEV;\r\nmc = devm_kzalloc(&pdev->dev, sizeof(*mc), GFP_KERNEL);\r\nif (!mc)\r\nreturn -ENOMEM;\r\nplatform_set_drvdata(pdev, mc);\r\nmc->soc = match->data;\r\nmc->dev = &pdev->dev;\r\nmc->tick = 30;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nmc->regs = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(mc->regs))\r\nreturn PTR_ERR(mc->regs);\r\nmc->clk = devm_clk_get(&pdev->dev, "mc");\r\nif (IS_ERR(mc->clk)) {\r\ndev_err(&pdev->dev, "failed to get MC clock: %ld\n",\r\nPTR_ERR(mc->clk));\r\nreturn PTR_ERR(mc->clk);\r\n}\r\nerr = tegra_mc_setup_latency_allowance(mc);\r\nif (err < 0) {\r\ndev_err(&pdev->dev, "failed to setup latency allowance: %d\n",\r\nerr);\r\nreturn err;\r\n}\r\nif (IS_ENABLED(CONFIG_TEGRA_IOMMU_SMMU)) {\r\nmc->smmu = tegra_smmu_probe(&pdev->dev, mc->soc->smmu, mc);\r\nif (IS_ERR(mc->smmu)) {\r\ndev_err(&pdev->dev, "failed to probe SMMU: %ld\n",\r\nPTR_ERR(mc->smmu));\r\nreturn PTR_ERR(mc->smmu);\r\n}\r\n}\r\nmc->irq = platform_get_irq(pdev, 0);\r\nif (mc->irq < 0) {\r\ndev_err(&pdev->dev, "interrupt not specified\n");\r\nreturn mc->irq;\r\n}\r\nerr = devm_request_irq(&pdev->dev, mc->irq, tegra_mc_irq, IRQF_SHARED,\r\ndev_name(&pdev->dev), mc);\r\nif (err < 0) {\r\ndev_err(&pdev->dev, "failed to request IRQ#%u: %d\n", mc->irq,\r\nerr);\r\nreturn err;\r\n}\r\nvalue = MC_INT_DECERR_MTS | MC_INT_SECERR_SEC | MC_INT_DECERR_VPR |\r\nMC_INT_INVALID_APB_ASID_UPDATE | MC_INT_INVALID_SMMU_PAGE |\r\nMC_INT_ARBITRATION_EMEM | MC_INT_SECURITY_VIOLATION |\r\nMC_INT_DECERR_EMEM;\r\nmc_writel(mc, value, MC_INTMASK);\r\nreturn 0;\r\n}\r\nstatic int tegra_mc_init(void)\r\n{\r\nreturn platform_driver_register(&tegra_mc_driver);\r\n}
