static int snd_ak4531_info_single(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\r\n{\r\nint mask = (kcontrol->private_value >> 24) & 0xff;\r\nuinfo->type = mask == 1 ? SNDRV_CTL_ELEM_TYPE_BOOLEAN : SNDRV_CTL_ELEM_TYPE_INTEGER;\r\nuinfo->count = 1;\r\nuinfo->value.integer.min = 0;\r\nuinfo->value.integer.max = mask;\r\nreturn 0;\r\n}\r\nstatic int snd_ak4531_get_single(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_ak4531 *ak4531 = snd_kcontrol_chip(kcontrol);\r\nint reg = kcontrol->private_value & 0xff;\r\nint shift = (kcontrol->private_value >> 16) & 0x07;\r\nint mask = (kcontrol->private_value >> 24) & 0xff;\r\nint invert = (kcontrol->private_value >> 22) & 1;\r\nint val;\r\nmutex_lock(&ak4531->reg_mutex);\r\nval = (ak4531->regs[reg] >> shift) & mask;\r\nmutex_unlock(&ak4531->reg_mutex);\r\nif (invert) {\r\nval = mask - val;\r\n}\r\nucontrol->value.integer.value[0] = val;\r\nreturn 0;\r\n}\r\nstatic int snd_ak4531_put_single(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_ak4531 *ak4531 = snd_kcontrol_chip(kcontrol);\r\nint reg = kcontrol->private_value & 0xff;\r\nint shift = (kcontrol->private_value >> 16) & 0x07;\r\nint mask = (kcontrol->private_value >> 24) & 0xff;\r\nint invert = (kcontrol->private_value >> 22) & 1;\r\nint change;\r\nint val;\r\nval = ucontrol->value.integer.value[0] & mask;\r\nif (invert) {\r\nval = mask - val;\r\n}\r\nval <<= shift;\r\nmutex_lock(&ak4531->reg_mutex);\r\nval = (ak4531->regs[reg] & ~(mask << shift)) | val;\r\nchange = val != ak4531->regs[reg];\r\nak4531->write(ak4531, reg, ak4531->regs[reg] = val);\r\nmutex_unlock(&ak4531->reg_mutex);\r\nreturn change;\r\n}\r\nstatic int snd_ak4531_info_double(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\r\n{\r\nint mask = (kcontrol->private_value >> 24) & 0xff;\r\nuinfo->type = mask == 1 ? SNDRV_CTL_ELEM_TYPE_BOOLEAN : SNDRV_CTL_ELEM_TYPE_INTEGER;\r\nuinfo->count = 2;\r\nuinfo->value.integer.min = 0;\r\nuinfo->value.integer.max = mask;\r\nreturn 0;\r\n}\r\nstatic int snd_ak4531_get_double(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_ak4531 *ak4531 = snd_kcontrol_chip(kcontrol);\r\nint left_reg = kcontrol->private_value & 0xff;\r\nint right_reg = (kcontrol->private_value >> 8) & 0xff;\r\nint left_shift = (kcontrol->private_value >> 16) & 0x07;\r\nint right_shift = (kcontrol->private_value >> 19) & 0x07;\r\nint mask = (kcontrol->private_value >> 24) & 0xff;\r\nint invert = (kcontrol->private_value >> 22) & 1;\r\nint left, right;\r\nmutex_lock(&ak4531->reg_mutex);\r\nleft = (ak4531->regs[left_reg] >> left_shift) & mask;\r\nright = (ak4531->regs[right_reg] >> right_shift) & mask;\r\nmutex_unlock(&ak4531->reg_mutex);\r\nif (invert) {\r\nleft = mask - left;\r\nright = mask - right;\r\n}\r\nucontrol->value.integer.value[0] = left;\r\nucontrol->value.integer.value[1] = right;\r\nreturn 0;\r\n}\r\nstatic int snd_ak4531_put_double(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_ak4531 *ak4531 = snd_kcontrol_chip(kcontrol);\r\nint left_reg = kcontrol->private_value & 0xff;\r\nint right_reg = (kcontrol->private_value >> 8) & 0xff;\r\nint left_shift = (kcontrol->private_value >> 16) & 0x07;\r\nint right_shift = (kcontrol->private_value >> 19) & 0x07;\r\nint mask = (kcontrol->private_value >> 24) & 0xff;\r\nint invert = (kcontrol->private_value >> 22) & 1;\r\nint change;\r\nint left, right;\r\nleft = ucontrol->value.integer.value[0] & mask;\r\nright = ucontrol->value.integer.value[1] & mask;\r\nif (invert) {\r\nleft = mask - left;\r\nright = mask - right;\r\n}\r\nleft <<= left_shift;\r\nright <<= right_shift;\r\nmutex_lock(&ak4531->reg_mutex);\r\nif (left_reg == right_reg) {\r\nleft = (ak4531->regs[left_reg] & ~((mask << left_shift) | (mask << right_shift))) | left | right;\r\nchange = left != ak4531->regs[left_reg];\r\nak4531->write(ak4531, left_reg, ak4531->regs[left_reg] = left);\r\n} else {\r\nleft = (ak4531->regs[left_reg] & ~(mask << left_shift)) | left;\r\nright = (ak4531->regs[right_reg] & ~(mask << right_shift)) | right;\r\nchange = left != ak4531->regs[left_reg] || right != ak4531->regs[right_reg];\r\nak4531->write(ak4531, left_reg, ak4531->regs[left_reg] = left);\r\nak4531->write(ak4531, right_reg, ak4531->regs[right_reg] = right);\r\n}\r\nmutex_unlock(&ak4531->reg_mutex);\r\nreturn change;\r\n}\r\nstatic int snd_ak4531_info_input_sw(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)\r\n{\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;\r\nuinfo->count = 4;\r\nuinfo->value.integer.min = 0;\r\nuinfo->value.integer.max = 1;\r\nreturn 0;\r\n}\r\nstatic int snd_ak4531_get_input_sw(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_ak4531 *ak4531 = snd_kcontrol_chip(kcontrol);\r\nint reg1 = kcontrol->private_value & 0xff;\r\nint reg2 = (kcontrol->private_value >> 8) & 0xff;\r\nint left_shift = (kcontrol->private_value >> 16) & 0x0f;\r\nint right_shift = (kcontrol->private_value >> 24) & 0x0f;\r\nmutex_lock(&ak4531->reg_mutex);\r\nucontrol->value.integer.value[0] = (ak4531->regs[reg1] >> left_shift) & 1;\r\nucontrol->value.integer.value[1] = (ak4531->regs[reg2] >> left_shift) & 1;\r\nucontrol->value.integer.value[2] = (ak4531->regs[reg1] >> right_shift) & 1;\r\nucontrol->value.integer.value[3] = (ak4531->regs[reg2] >> right_shift) & 1;\r\nmutex_unlock(&ak4531->reg_mutex);\r\nreturn 0;\r\n}\r\nstatic int snd_ak4531_put_input_sw(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_ak4531 *ak4531 = snd_kcontrol_chip(kcontrol);\r\nint reg1 = kcontrol->private_value & 0xff;\r\nint reg2 = (kcontrol->private_value >> 8) & 0xff;\r\nint left_shift = (kcontrol->private_value >> 16) & 0x0f;\r\nint right_shift = (kcontrol->private_value >> 24) & 0x0f;\r\nint change;\r\nint val1, val2;\r\nmutex_lock(&ak4531->reg_mutex);\r\nval1 = ak4531->regs[reg1] & ~((1 << left_shift) | (1 << right_shift));\r\nval2 = ak4531->regs[reg2] & ~((1 << left_shift) | (1 << right_shift));\r\nval1 |= (ucontrol->value.integer.value[0] & 1) << left_shift;\r\nval2 |= (ucontrol->value.integer.value[1] & 1) << left_shift;\r\nval1 |= (ucontrol->value.integer.value[2] & 1) << right_shift;\r\nval2 |= (ucontrol->value.integer.value[3] & 1) << right_shift;\r\nchange = val1 != ak4531->regs[reg1] || val2 != ak4531->regs[reg2];\r\nak4531->write(ak4531, reg1, ak4531->regs[reg1] = val1);\r\nak4531->write(ak4531, reg2, ak4531->regs[reg2] = val2);\r\nmutex_unlock(&ak4531->reg_mutex);\r\nreturn change;\r\n}\r\nstatic int snd_ak4531_free(struct snd_ak4531 *ak4531)\r\n{\r\nif (ak4531) {\r\nif (ak4531->private_free)\r\nak4531->private_free(ak4531);\r\nkfree(ak4531);\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_ak4531_dev_free(struct snd_device *device)\r\n{\r\nstruct snd_ak4531 *ak4531 = device->device_data;\r\nreturn snd_ak4531_free(ak4531);\r\n}\r\nint snd_ak4531_mixer(struct snd_card *card,\r\nstruct snd_ak4531 *_ak4531,\r\nstruct snd_ak4531 **rak4531)\r\n{\r\nunsigned int idx;\r\nint err;\r\nstruct snd_ak4531 *ak4531;\r\nstatic struct snd_device_ops ops = {\r\n.dev_free = snd_ak4531_dev_free,\r\n};\r\nif (snd_BUG_ON(!card || !_ak4531))\r\nreturn -EINVAL;\r\nif (rak4531)\r\n*rak4531 = NULL;\r\nak4531 = kzalloc(sizeof(*ak4531), GFP_KERNEL);\r\nif (ak4531 == NULL)\r\nreturn -ENOMEM;\r\n*ak4531 = *_ak4531;\r\nmutex_init(&ak4531->reg_mutex);\r\nif ((err = snd_component_add(card, "AK4531")) < 0) {\r\nsnd_ak4531_free(ak4531);\r\nreturn err;\r\n}\r\nstrcpy(card->mixername, "Asahi Kasei AK4531");\r\nak4531->write(ak4531, AK4531_RESET, 0x03);\r\nudelay(100);\r\nak4531->write(ak4531, AK4531_CLOCK, 0x00);\r\nfor (idx = 0; idx <= 0x19; idx++) {\r\nif (idx == AK4531_RESET || idx == AK4531_CLOCK)\r\ncontinue;\r\nak4531->write(ak4531, idx, ak4531->regs[idx] = snd_ak4531_initial_map[idx]);\r\n}\r\nfor (idx = 0; idx < ARRAY_SIZE(snd_ak4531_controls); idx++) {\r\nif ((err = snd_ctl_add(card, snd_ctl_new1(&snd_ak4531_controls[idx], ak4531))) < 0) {\r\nsnd_ak4531_free(ak4531);\r\nreturn err;\r\n}\r\n}\r\nsnd_ak4531_proc_init(card, ak4531);\r\nif ((err = snd_device_new(card, SNDRV_DEV_CODEC, ak4531, &ops)) < 0) {\r\nsnd_ak4531_free(ak4531);\r\nreturn err;\r\n}\r\n#if 0\r\nsnd_ak4531_dump(ak4531);\r\n#endif\r\nif (rak4531)\r\n*rak4531 = ak4531;\r\nreturn 0;\r\n}\r\nvoid snd_ak4531_suspend(struct snd_ak4531 *ak4531)\r\n{\r\nak4531->write(ak4531, AK4531_LMASTER, 0x9f);\r\nak4531->write(ak4531, AK4531_RMASTER, 0x9f);\r\nak4531->write(ak4531, AK4531_RESET, 0x01);\r\n}\r\nvoid snd_ak4531_resume(struct snd_ak4531 *ak4531)\r\n{\r\nint idx;\r\nak4531->write(ak4531, AK4531_RESET, 0x03);\r\nudelay(100);\r\nak4531->write(ak4531, AK4531_CLOCK, 0x00);\r\nfor (idx = 0; idx <= 0x19; idx++) {\r\nif (idx == AK4531_RESET || idx == AK4531_CLOCK)\r\ncontinue;\r\nak4531->write(ak4531, idx, ak4531->regs[idx]);\r\n}\r\n}\r\nstatic void snd_ak4531_proc_read(struct snd_info_entry *entry,\r\nstruct snd_info_buffer *buffer)\r\n{\r\nstruct snd_ak4531 *ak4531 = entry->private_data;\r\nsnd_iprintf(buffer, "Asahi Kasei AK4531\n\n");\r\nsnd_iprintf(buffer, "Recording source : %s\n"\r\n"MIC gain : %s\n",\r\nak4531->regs[AK4531_AD_IN] & 1 ? "external" : "mixer",\r\nak4531->regs[AK4531_MIC_GAIN] & 1 ? "+30dB" : "+0dB");\r\n}\r\nstatic void\r\nsnd_ak4531_proc_init(struct snd_card *card, struct snd_ak4531 *ak4531)\r\n{\r\nstruct snd_info_entry *entry;\r\nif (! snd_card_proc_new(card, "ak4531", &entry))\r\nsnd_info_set_text_ops(entry, ak4531, snd_ak4531_proc_read);\r\n}
