static inline int seq_less(u16 sq1, u16 sq2)\r\n{\r\nreturn ((sq1 - sq2) & SEQ_MASK) > (SEQ_MODULO >> 1);\r\n}\r\nstatic inline u16 seq_inc(u16 sq)\r\n{\r\nreturn (sq + 1) & SEQ_MASK;\r\n}\r\nstatic inline u16 seq_sub(u16 sq1, u16 sq2)\r\n{\r\nreturn (sq1 - sq2) & SEQ_MASK;\r\n}\r\nstatic inline int reorder_index(struct wil_tid_ampdu_rx *r, u16 seq)\r\n{\r\nreturn seq_sub(seq, r->ssn) % r->buf_size;\r\n}\r\nstatic void wil_release_reorder_frame(struct wil6210_priv *wil,\r\nstruct wil_tid_ampdu_rx *r,\r\nint index)\r\n{\r\nstruct net_device *ndev = wil_to_ndev(wil);\r\nstruct sk_buff *skb = r->reorder_buf[index];\r\nif (!skb)\r\ngoto no_frame;\r\nr->stored_mpdu_num--;\r\nr->reorder_buf[index] = NULL;\r\nwil_netif_rx_any(skb, ndev);\r\nno_frame:\r\nr->head_seq_num = seq_inc(r->head_seq_num);\r\n}\r\nstatic void wil_release_reorder_frames(struct wil6210_priv *wil,\r\nstruct wil_tid_ampdu_rx *r,\r\nu16 hseq)\r\n{\r\nint index;\r\nwhile (seq_less(r->head_seq_num, hseq) && r->stored_mpdu_num) {\r\nindex = reorder_index(r, r->head_seq_num);\r\nwil_release_reorder_frame(wil, r, index);\r\n}\r\nr->head_seq_num = hseq;\r\n}\r\nstatic void wil_reorder_release(struct wil6210_priv *wil,\r\nstruct wil_tid_ampdu_rx *r)\r\n{\r\nint index = reorder_index(r, r->head_seq_num);\r\nwhile (r->reorder_buf[index]) {\r\nwil_release_reorder_frame(wil, r, index);\r\nindex = reorder_index(r, r->head_seq_num);\r\n}\r\n}\r\nvoid wil_rx_reorder(struct wil6210_priv *wil, struct sk_buff *skb)\r\n__acquires(&sta->tid_rx_lock\r\nstruct wil_tid_ampdu_rx *wil_tid_ampdu_rx_alloc(struct wil6210_priv *wil,\r\nint size, u16 ssn)\r\n{\r\nstruct wil_tid_ampdu_rx *r = kzalloc(sizeof(*r), GFP_KERNEL);\r\nif (!r)\r\nreturn NULL;\r\nr->reorder_buf =\r\nkcalloc(size, sizeof(struct sk_buff *), GFP_KERNEL);\r\nr->reorder_time =\r\nkcalloc(size, sizeof(unsigned long), GFP_KERNEL);\r\nif (!r->reorder_buf || !r->reorder_time) {\r\nkfree(r->reorder_buf);\r\nkfree(r->reorder_time);\r\nkfree(r);\r\nreturn NULL;\r\n}\r\nr->ssn = ssn;\r\nr->head_seq_num = ssn;\r\nr->buf_size = size;\r\nr->stored_mpdu_num = 0;\r\nr->first_time = true;\r\nreturn r;\r\n}\r\nvoid wil_tid_ampdu_rx_free(struct wil6210_priv *wil,\r\nstruct wil_tid_ampdu_rx *r)\r\n{\r\nif (!r)\r\nreturn;\r\nwil_release_reorder_frames(wil, r, r->head_seq_num + r->buf_size);\r\nkfree(r->reorder_buf);\r\nkfree(r->reorder_time);\r\nkfree(r);\r\n}\r\nstatic u16 wil_agg_size(struct wil6210_priv *wil, u16 req_agg_wsize)\r\n{\r\nu16 max_agg_size = min_t(u16, WIL_MAX_AGG_WSIZE, WIL_MAX_AMPDU_SIZE /\r\n(mtu_max + WIL_MAX_MPDU_OVERHEAD));\r\nif (!req_agg_wsize)\r\nreturn max_agg_size;\r\nreturn min(max_agg_size, req_agg_wsize);\r\n}\r\nint wil_addba_rx_request(struct wil6210_priv *wil, u8 cidxtid,\r\nu8 dialog_token, __le16 ba_param_set,\r\n__le16 ba_timeout, __le16 ba_seq_ctrl)\r\n{\r\nstruct wil_back_rx *req = kzalloc(sizeof(*req), GFP_KERNEL);\r\nif (!req)\r\nreturn -ENOMEM;\r\nreq->cidxtid = cidxtid;\r\nreq->dialog_token = dialog_token;\r\nreq->ba_param_set = le16_to_cpu(ba_param_set);\r\nreq->ba_timeout = le16_to_cpu(ba_timeout);\r\nreq->ba_seq_ctrl = le16_to_cpu(ba_seq_ctrl);\r\nmutex_lock(&wil->back_rx_mutex);\r\nlist_add_tail(&req->list, &wil->back_rx_pending);\r\nmutex_unlock(&wil->back_rx_mutex);\r\nqueue_work(wil->wq_service, &wil->back_rx_worker);\r\nreturn 0;\r\n}\r\nstatic void wil_back_rx_handle(struct wil6210_priv *wil,\r\nstruct wil_back_rx *req)\r\n__acquires(&sta->tid_rx_lock\r\nvoid wil_back_rx_flush(struct wil6210_priv *wil)\r\n{\r\nstruct wil_back_rx *evt, *t;\r\nwil_dbg_misc(wil, "%s()\n", __func__);\r\nmutex_lock(&wil->back_rx_mutex);\r\nlist_for_each_entry_safe(evt, t, &wil->back_rx_pending, list) {\r\nlist_del(&evt->list);\r\nkfree(evt);\r\n}\r\nmutex_unlock(&wil->back_rx_mutex);\r\n}\r\nstatic struct list_head *next_back_rx(struct wil6210_priv *wil)\r\n{\r\nstruct list_head *ret = NULL;\r\nmutex_lock(&wil->back_rx_mutex);\r\nif (!list_empty(&wil->back_rx_pending)) {\r\nret = wil->back_rx_pending.next;\r\nlist_del(ret);\r\n}\r\nmutex_unlock(&wil->back_rx_mutex);\r\nreturn ret;\r\n}\r\nvoid wil_back_rx_worker(struct work_struct *work)\r\n{\r\nstruct wil6210_priv *wil = container_of(work, struct wil6210_priv,\r\nback_rx_worker);\r\nstruct wil_back_rx *evt;\r\nstruct list_head *lh;\r\nwhile ((lh = next_back_rx(wil)) != NULL) {\r\nevt = list_entry(lh, struct wil_back_rx, list);\r\nwil_back_rx_handle(wil, evt);\r\nkfree(evt);\r\n}\r\n}\r\nstatic void wil_back_tx_handle(struct wil6210_priv *wil,\r\nstruct wil_back_tx *req)\r\n{\r\nstruct vring_tx_data *txdata = &wil->vring_tx_data[req->ringid];\r\nint rc;\r\nif (txdata->addba_in_progress) {\r\nwil_dbg_misc(wil, "ADDBA for vring[%d] already in progress\n",\r\nreq->ringid);\r\nreturn;\r\n}\r\nif (txdata->agg_wsize) {\r\nwil_dbg_misc(wil,\r\n"ADDBA for vring[%d] already established wsize %d\n",\r\nreq->ringid, txdata->agg_wsize);\r\nreturn;\r\n}\r\ntxdata->addba_in_progress = true;\r\nrc = wmi_addba(wil, req->ringid, req->agg_wsize, req->agg_timeout);\r\nif (rc)\r\ntxdata->addba_in_progress = false;\r\n}\r\nstatic struct list_head *next_back_tx(struct wil6210_priv *wil)\r\n{\r\nstruct list_head *ret = NULL;\r\nmutex_lock(&wil->back_tx_mutex);\r\nif (!list_empty(&wil->back_tx_pending)) {\r\nret = wil->back_tx_pending.next;\r\nlist_del(ret);\r\n}\r\nmutex_unlock(&wil->back_tx_mutex);\r\nreturn ret;\r\n}\r\nvoid wil_back_tx_worker(struct work_struct *work)\r\n{\r\nstruct wil6210_priv *wil = container_of(work, struct wil6210_priv,\r\nback_tx_worker);\r\nstruct wil_back_tx *evt;\r\nstruct list_head *lh;\r\nwhile ((lh = next_back_tx(wil)) != NULL) {\r\nevt = list_entry(lh, struct wil_back_tx, list);\r\nwil_back_tx_handle(wil, evt);\r\nkfree(evt);\r\n}\r\n}\r\nvoid wil_back_tx_flush(struct wil6210_priv *wil)\r\n{\r\nstruct wil_back_tx *evt, *t;\r\nwil_dbg_misc(wil, "%s()\n", __func__);\r\nmutex_lock(&wil->back_tx_mutex);\r\nlist_for_each_entry_safe(evt, t, &wil->back_tx_pending, list) {\r\nlist_del(&evt->list);\r\nkfree(evt);\r\n}\r\nmutex_unlock(&wil->back_tx_mutex);\r\n}\r\nint wil_addba_tx_request(struct wil6210_priv *wil, u8 ringid, u16 wsize)\r\n{\r\nstruct wil_back_tx *req = kzalloc(sizeof(*req), GFP_KERNEL);\r\nif (!req)\r\nreturn -ENOMEM;\r\nreq->ringid = ringid;\r\nreq->agg_wsize = wil_agg_size(wil, wsize);\r\nreq->agg_timeout = 0;\r\nmutex_lock(&wil->back_tx_mutex);\r\nlist_add_tail(&req->list, &wil->back_tx_pending);\r\nmutex_unlock(&wil->back_tx_mutex);\r\nqueue_work(wil->wq_service, &wil->back_tx_worker);\r\nreturn 0;\r\n}
