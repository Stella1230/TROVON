static int sst_fill_byte_control(struct sst_data *drv,\r\nu8 ipc_msg, u8 block,\r\nu8 task_id, u8 pipe_id,\r\nu16 len, void *cmd_data)\r\n{\r\nstruct snd_sst_bytes_v2 *byte_data = drv->byte_stream;\r\nbyte_data->type = SST_CMD_BYTES_SET;\r\nbyte_data->ipc_msg = ipc_msg;\r\nbyte_data->block = block;\r\nbyte_data->task_id = task_id;\r\nbyte_data->pipe_id = pipe_id;\r\nif (len > SST_MAX_BIN_BYTES - sizeof(*byte_data)) {\r\ndev_err(&drv->pdev->dev, "command length too big (%u)", len);\r\nreturn -EINVAL;\r\n}\r\nbyte_data->len = len;\r\nmemcpy(byte_data->bytes, cmd_data, len);\r\nprint_hex_dump_bytes("writing to lpe: ", DUMP_PREFIX_OFFSET,\r\nbyte_data, len + sizeof(*byte_data));\r\nreturn 0;\r\n}\r\nstatic int sst_fill_and_send_cmd_unlocked(struct sst_data *drv,\r\nu8 ipc_msg, u8 block, u8 task_id, u8 pipe_id,\r\nvoid *cmd_data, u16 len)\r\n{\r\nint ret = 0;\r\nret = sst_fill_byte_control(drv, ipc_msg,\r\nblock, task_id, pipe_id, len, cmd_data);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn sst->ops->send_byte_stream(sst->dev, drv->byte_stream);\r\n}\r\nstatic int sst_fill_and_send_cmd(struct sst_data *drv,\r\nu8 ipc_msg, u8 block, u8 task_id, u8 pipe_id,\r\nvoid *cmd_data, u16 len)\r\n{\r\nint ret;\r\nmutex_lock(&drv->lock);\r\nret = sst_fill_and_send_cmd_unlocked(drv, ipc_msg, block,\r\ntask_id, pipe_id, cmd_data, len);\r\nmutex_unlock(&drv->lock);\r\nreturn ret;\r\n}\r\nstatic int sst_send_slot_map(struct sst_data *drv)\r\n{\r\nstruct sst_param_sba_ssp_slot_map cmd;\r\nSST_FILL_DEFAULT_DESTINATION(cmd.header.dst);\r\ncmd.header.command_id = SBA_SET_SSP_SLOT_MAP;\r\ncmd.header.length = sizeof(struct sst_param_sba_ssp_slot_map)\r\n- sizeof(struct sst_dsp_header);\r\ncmd.param_id = SBA_SET_SSP_SLOT_MAP;\r\ncmd.param_len = sizeof(cmd.rx_slot_map) + sizeof(cmd.tx_slot_map)\r\n+ sizeof(cmd.ssp_index);\r\ncmd.ssp_index = SSP_CODEC;\r\nmemcpy(cmd.rx_slot_map, &sst_ssp_tx_map[0], sizeof(cmd.rx_slot_map));\r\nmemcpy(cmd.tx_slot_map, &sst_ssp_rx_map[0], sizeof(cmd.tx_slot_map));\r\nreturn sst_fill_and_send_cmd_unlocked(drv, SST_IPC_IA_SET_PARAMS,\r\nSST_FLAG_BLOCKED, SST_TASK_SBA, 0, &cmd,\r\nsizeof(cmd.header) + cmd.header.length);\r\n}\r\nint sst_slot_enum_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nstruct sst_enum *e = (struct sst_enum *)kcontrol->private_value;\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;\r\nuinfo->count = 1;\r\nuinfo->value.enumerated.items = e->max;\r\nif (uinfo->value.enumerated.item > e->max - 1)\r\nuinfo->value.enumerated.item = e->max - 1;\r\nstrcpy(uinfo->value.enumerated.name,\r\ne->texts[uinfo->value.enumerated.item]);\r\nreturn 0;\r\n}\r\nstatic int sst_slot_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct sst_enum *e = (void *)kcontrol->private_value;\r\nstruct snd_soc_component *c = snd_kcontrol_chip(kcontrol);\r\nstruct sst_data *drv = snd_soc_component_get_drvdata(c);\r\nunsigned int ctl_no = e->reg;\r\nunsigned int is_tx = e->tx;\r\nunsigned int val, mux;\r\nu8 *map = is_tx ? sst_ssp_rx_map : sst_ssp_tx_map;\r\nmutex_lock(&drv->lock);\r\nval = 1 << ctl_no;\r\nfor (mux = e->max; mux > 0; mux--)\r\nif (map[mux - 1] & val)\r\nbreak;\r\nucontrol->value.enumerated.item[0] = mux;\r\nmutex_unlock(&drv->lock);\r\ndev_dbg(c->dev, "%s - %s map = %#x\n",\r\nis_tx ? "tx channel" : "rx slot",\r\ne->texts[mux], mux ? map[mux - 1] : -1);\r\nreturn 0;\r\n}\r\nstatic int sst_check_and_send_slot_map(struct sst_data *drv, struct snd_kcontrol *kcontrol)\r\n{\r\nstruct sst_enum *e = (void *)kcontrol->private_value;\r\nint ret = 0;\r\nif (e->w && e->w->power)\r\nret = sst_send_slot_map(drv);\r\nelse\r\ndev_err(&drv->pdev->dev, "Slot control: %s doesn't have DAPM widget!!!\n",\r\nkcontrol->id.name);\r\nreturn ret;\r\n}\r\nstatic int sst_slot_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_component *c = snd_soc_kcontrol_component(kcontrol);\r\nstruct sst_data *drv = snd_soc_component_get_drvdata(c);\r\nstruct sst_enum *e = (void *)kcontrol->private_value;\r\nint i, ret = 0;\r\nunsigned int ctl_no = e->reg;\r\nunsigned int is_tx = e->tx;\r\nunsigned int slot_channel_no;\r\nunsigned int val, mux;\r\nu8 *map;\r\nmap = is_tx ? sst_ssp_rx_map : sst_ssp_tx_map;\r\nval = 1 << ctl_no;\r\nmux = ucontrol->value.enumerated.item[0];\r\nif (mux > e->max - 1)\r\nreturn -EINVAL;\r\nmutex_lock(&drv->lock);\r\nfor (i = 0; i < e->max; i++)\r\nmap[i] &= ~val;\r\nif (mux == 0) {\r\nret = sst_check_and_send_slot_map(drv, kcontrol);\r\nmutex_unlock(&drv->lock);\r\nreturn ret;\r\n}\r\nslot_channel_no = mux - 1;\r\nmap[slot_channel_no] |= val;\r\ndev_dbg(c->dev, "%s %s map = %#x\n",\r\nis_tx ? "tx channel" : "rx slot",\r\ne->texts[mux], map[slot_channel_no]);\r\nret = sst_check_and_send_slot_map(drv, kcontrol);\r\nmutex_unlock(&drv->lock);\r\nreturn ret;\r\n}\r\nstatic int sst_send_algo_cmd(struct sst_data *drv,\r\nstruct sst_algo_control *bc)\r\n{\r\nint len, ret = 0;\r\nstruct sst_cmd_set_params *cmd;\r\nlen = sizeof(cmd->dst) + sizeof(cmd->command_id) + bc->max;\r\ncmd = kzalloc(len, GFP_KERNEL);\r\nif (cmd == NULL)\r\nreturn -ENOMEM;\r\nSST_FILL_DESTINATION(2, cmd->dst, bc->pipe_id, bc->module_id);\r\ncmd->command_id = bc->cmd_id;\r\nmemcpy(cmd->params, bc->params, bc->max);\r\nret = sst_fill_and_send_cmd_unlocked(drv, SST_IPC_IA_SET_PARAMS,\r\nSST_FLAG_BLOCKED, bc->task_id, 0, cmd, len);\r\nkfree(cmd);\r\nreturn ret;\r\n}\r\nstatic int sst_find_and_send_pipe_algo(struct sst_data *drv,\r\nconst char *pipe, struct sst_ids *ids)\r\n{\r\nint ret = 0;\r\nstruct sst_algo_control *bc;\r\nstruct sst_module *algo = NULL;\r\ndev_dbg(&drv->pdev->dev, "Enter: widget=%s\n", pipe);\r\nlist_for_each_entry(algo, &ids->algo_list, node) {\r\nbc = (void *)algo->kctl->private_value;\r\ndev_dbg(&drv->pdev->dev, "Found algo control name=%s pipe=%s\n",\r\nalgo->kctl->id.name, pipe);\r\nret = sst_send_algo_cmd(drv, bc);\r\nif (ret)\r\nreturn ret;\r\n}\r\nreturn ret;\r\n}\r\nstatic int sst_algo_bytes_ctl_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nstruct sst_algo_control *bc = (void *)kcontrol->private_value;\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_BYTES;\r\nuinfo->count = bc->max;\r\nreturn 0;\r\n}\r\nstatic int sst_algo_control_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct sst_algo_control *bc = (void *)kcontrol->private_value;\r\nstruct snd_soc_component *component = snd_kcontrol_chip(kcontrol);\r\nswitch (bc->type) {\r\ncase SST_ALGO_PARAMS:\r\nmemcpy(ucontrol->value.bytes.data, bc->params, bc->max);\r\nbreak;\r\ndefault:\r\ndev_err(component->dev, "Invalid Input- algo type:%d\n",\r\nbc->type);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int sst_algo_control_set(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nint ret = 0;\r\nstruct snd_soc_component *cmpnt = snd_soc_kcontrol_component(kcontrol);\r\nstruct sst_data *drv = snd_soc_component_get_drvdata(cmpnt);\r\nstruct sst_algo_control *bc = (void *)kcontrol->private_value;\r\ndev_dbg(cmpnt->dev, "control_name=%s\n", kcontrol->id.name);\r\nmutex_lock(&drv->lock);\r\nswitch (bc->type) {\r\ncase SST_ALGO_PARAMS:\r\nmemcpy(bc->params, ucontrol->value.bytes.data, bc->max);\r\nbreak;\r\ndefault:\r\nmutex_unlock(&drv->lock);\r\ndev_err(cmpnt->dev, "Invalid Input- algo type:%d\n",\r\nbc->type);\r\nreturn -EINVAL;\r\n}\r\nif (bc->w && bc->w->power)\r\nret = sst_send_algo_cmd(drv, bc);\r\nmutex_unlock(&drv->lock);\r\nreturn ret;\r\n}\r\nstatic int sst_gain_ctl_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nstruct sst_gain_mixer_control *mc = (void *)kcontrol->private_value;\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\r\nuinfo->count = mc->stereo ? 2 : 1;\r\nuinfo->value.integer.min = mc->min;\r\nuinfo->value.integer.max = mc->max;\r\nreturn 0;\r\n}\r\nstatic int sst_send_gain_cmd(struct sst_data *drv, struct sst_gain_value *gv,\r\nu16 task_id, u16 loc_id, u16 module_id, int mute)\r\n{\r\nstruct sst_cmd_set_gain_dual cmd;\r\ndev_dbg(&drv->pdev->dev, "Enter\n");\r\ncmd.header.command_id = MMX_SET_GAIN;\r\nSST_FILL_DEFAULT_DESTINATION(cmd.header.dst);\r\ncmd.gain_cell_num = 1;\r\nif (mute || gv->mute) {\r\ncmd.cell_gains[0].cell_gain_left = SST_GAIN_MIN_VALUE;\r\ncmd.cell_gains[0].cell_gain_right = SST_GAIN_MIN_VALUE;\r\n} else {\r\ncmd.cell_gains[0].cell_gain_left = gv->l_gain;\r\ncmd.cell_gains[0].cell_gain_right = gv->r_gain;\r\n}\r\nSST_FILL_DESTINATION(2, cmd.cell_gains[0].dest,\r\nloc_id, module_id);\r\ncmd.cell_gains[0].gain_time_constant = gv->ramp_duration;\r\ncmd.header.length = sizeof(struct sst_cmd_set_gain_dual)\r\n- sizeof(struct sst_dsp_header);\r\nreturn sst_fill_and_send_cmd_unlocked(drv, SST_IPC_IA_SET_PARAMS,\r\nSST_FLAG_BLOCKED, task_id, 0, &cmd,\r\nsizeof(cmd.header) + cmd.header.length);\r\n}\r\nstatic int sst_gain_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_component *component = snd_kcontrol_chip(kcontrol);\r\nstruct sst_gain_mixer_control *mc = (void *)kcontrol->private_value;\r\nstruct sst_gain_value *gv = mc->gain_val;\r\nswitch (mc->type) {\r\ncase SST_GAIN_TLV:\r\nucontrol->value.integer.value[0] = gv->l_gain;\r\nucontrol->value.integer.value[1] = gv->r_gain;\r\nbreak;\r\ncase SST_GAIN_MUTE:\r\nucontrol->value.integer.value[0] = gv->mute ? 1 : 0;\r\nbreak;\r\ncase SST_GAIN_RAMP_DURATION:\r\nucontrol->value.integer.value[0] = gv->ramp_duration;\r\nbreak;\r\ndefault:\r\ndev_err(component->dev, "Invalid Input- gain type:%d\n",\r\nmc->type);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int sst_gain_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nint ret = 0;\r\nstruct snd_soc_component *cmpnt = snd_soc_kcontrol_component(kcontrol);\r\nstruct sst_data *drv = snd_soc_component_get_drvdata(cmpnt);\r\nstruct sst_gain_mixer_control *mc = (void *)kcontrol->private_value;\r\nstruct sst_gain_value *gv = mc->gain_val;\r\nmutex_lock(&drv->lock);\r\nswitch (mc->type) {\r\ncase SST_GAIN_TLV:\r\ngv->l_gain = ucontrol->value.integer.value[0];\r\ngv->r_gain = ucontrol->value.integer.value[1];\r\ndev_dbg(cmpnt->dev, "%s: Volume %d, %d\n",\r\nmc->pname, gv->l_gain, gv->r_gain);\r\nbreak;\r\ncase SST_GAIN_MUTE:\r\ngv->mute = !!ucontrol->value.integer.value[0];\r\ndev_dbg(cmpnt->dev, "%s: Mute %d\n", mc->pname, gv->mute);\r\nbreak;\r\ncase SST_GAIN_RAMP_DURATION:\r\ngv->ramp_duration = ucontrol->value.integer.value[0];\r\ndev_dbg(cmpnt->dev, "%s: Ramp Delay%d\n",\r\nmc->pname, gv->ramp_duration);\r\nbreak;\r\ndefault:\r\nmutex_unlock(&drv->lock);\r\ndev_err(cmpnt->dev, "Invalid Input- gain type:%d\n",\r\nmc->type);\r\nreturn -EINVAL;\r\n}\r\nif (mc->w && mc->w->power)\r\nret = sst_send_gain_cmd(drv, gv, mc->task_id,\r\nmc->pipe_id | mc->instance_id, mc->module_id, 0);\r\nmutex_unlock(&drv->lock);\r\nreturn ret;\r\n}\r\nstatic int sst_send_pipe_module_params(struct snd_soc_dapm_widget *w,\r\nstruct snd_kcontrol *kcontrol)\r\n{\r\nstruct snd_soc_component *c = snd_soc_dapm_to_component(w->dapm);\r\nstruct sst_data *drv = snd_soc_component_get_drvdata(c);\r\nstruct sst_ids *ids = w->priv;\r\nmutex_lock(&drv->lock);\r\nsst_find_and_send_pipe_algo(drv, w->name, ids);\r\nsst_set_pipe_gain(ids, drv, 0);\r\nmutex_unlock(&drv->lock);\r\nreturn 0;\r\n}\r\nstatic int sst_generic_modules_event(struct snd_soc_dapm_widget *w,\r\nstruct snd_kcontrol *k, int event)\r\n{\r\nif (SND_SOC_DAPM_EVENT_ON(event))\r\nreturn sst_send_pipe_module_params(w, k);\r\nreturn 0;\r\n}\r\nstatic int fill_swm_input(struct snd_soc_component *cmpnt,\r\nstruct swm_input_ids *swm_input, unsigned int reg)\r\n{\r\nuint i, is_set, nb_inputs = 0;\r\nu16 input_loc_id;\r\ndev_dbg(cmpnt->dev, "reg: %#x\n", reg);\r\nfor (i = 0; i < SST_SWM_INPUT_COUNT; i++) {\r\nis_set = reg & BIT(i);\r\nif (!is_set)\r\ncontinue;\r\ninput_loc_id = swm_mixer_input_ids[i];\r\nSST_FILL_DESTINATION(2, swm_input->input_id,\r\ninput_loc_id, SST_DEFAULT_MODULE_ID);\r\nnb_inputs++;\r\nswm_input++;\r\ndev_dbg(cmpnt->dev, "input id: %#x, nb_inputs: %d\n",\r\ninput_loc_id, nb_inputs);\r\nif (nb_inputs == SST_CMD_SWM_MAX_INPUTS) {\r\ndev_warn(cmpnt->dev, "SET_SWM cmd max inputs reached");\r\nbreak;\r\n}\r\n}\r\nreturn nb_inputs;\r\n}\r\nstatic int sst_set_pipe_gain(struct sst_ids *ids,\r\nstruct sst_data *drv, int mute)\r\n{\r\nint ret = 0;\r\nstruct sst_gain_mixer_control *mc;\r\nstruct sst_gain_value *gv;\r\nstruct sst_module *gain = NULL;\r\nlist_for_each_entry(gain, &ids->gain_list, node) {\r\nstruct snd_kcontrol *kctl = gain->kctl;\r\ndev_dbg(&drv->pdev->dev, "control name=%s\n", kctl->id.name);\r\nmc = (void *)kctl->private_value;\r\ngv = mc->gain_val;\r\nret = sst_send_gain_cmd(drv, gv, mc->task_id,\r\nmc->pipe_id | mc->instance_id, mc->module_id, mute);\r\nif (ret)\r\nreturn ret;\r\n}\r\nreturn ret;\r\n}\r\nstatic int sst_swm_mixer_event(struct snd_soc_dapm_widget *w,\r\nstruct snd_kcontrol *k, int event)\r\n{\r\nstruct sst_cmd_set_swm cmd;\r\nstruct snd_soc_component *cmpnt = snd_soc_dapm_to_component(w->dapm);\r\nstruct sst_data *drv = snd_soc_component_get_drvdata(cmpnt);\r\nstruct sst_ids *ids = w->priv;\r\nbool set_mixer = false;\r\nstruct soc_mixer_control *mc;\r\nint val = 0;\r\nint i = 0;\r\ndev_dbg(cmpnt->dev, "widget = %s\n", w->name);\r\nfor (i = 0; i < w->num_kcontrols; i++) {\r\nif (dapm_kcontrol_get_value(w->kcontrols[i])) {\r\nmc = (struct soc_mixer_control *)(w->kcontrols[i])->private_value;\r\nval |= 1 << mc->shift;\r\n}\r\n}\r\ndev_dbg(cmpnt->dev, "val = %#x\n", val);\r\nswitch (event) {\r\ncase SND_SOC_DAPM_PRE_PMU:\r\ncase SND_SOC_DAPM_POST_PMD:\r\nset_mixer = true;\r\nbreak;\r\ncase SND_SOC_DAPM_POST_REG:\r\nif (w->power)\r\nset_mixer = true;\r\nbreak;\r\ndefault:\r\nset_mixer = false;\r\n}\r\nif (set_mixer == false)\r\nreturn 0;\r\nif (SND_SOC_DAPM_EVENT_ON(event) ||\r\nevent == SND_SOC_DAPM_POST_REG)\r\ncmd.switch_state = SST_SWM_ON;\r\nelse\r\ncmd.switch_state = SST_SWM_OFF;\r\nSST_FILL_DEFAULT_DESTINATION(cmd.header.dst);\r\ncmd.header.command_id = SBA_SET_SWM;\r\nSST_FILL_DESTINATION(2, cmd.output_id,\r\nids->location_id, SST_DEFAULT_MODULE_ID);\r\ncmd.nb_inputs = fill_swm_input(cmpnt, &cmd.input[0], val);\r\ncmd.header.length = offsetof(struct sst_cmd_set_swm, input)\r\n- sizeof(struct sst_dsp_header)\r\n+ (cmd.nb_inputs * sizeof(cmd.input[0]));\r\nreturn sst_fill_and_send_cmd(drv, SST_IPC_IA_CMD, SST_FLAG_BLOCKED,\r\nids->task_id, 0, &cmd,\r\nsizeof(cmd.header) + cmd.header.length);\r\n}\r\nint sst_handle_vb_timer(struct snd_soc_dai *dai, bool enable)\r\n{\r\nint ret = 0;\r\nstruct sst_cmd_generic cmd;\r\nstruct sst_data *drv = snd_soc_dai_get_drvdata(dai);\r\nstatic int timer_usage;\r\nif (enable)\r\ncmd.header.command_id = SBA_VB_START;\r\nelse\r\ncmd.header.command_id = SBA_IDLE;\r\ndev_dbg(dai->dev, "enable=%u, usage=%d\n", enable, timer_usage);\r\nSST_FILL_DEFAULT_DESTINATION(cmd.header.dst);\r\ncmd.header.length = 0;\r\nif (enable) {\r\nret = sst->ops->power(sst->dev, true);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nmutex_lock(&drv->lock);\r\nif (enable)\r\ntimer_usage++;\r\nelse\r\ntimer_usage--;\r\nif ((enable && (timer_usage == 1)) ||\r\n(!enable && (timer_usage == 0))) {\r\nret = sst_fill_and_send_cmd_unlocked(drv, SST_IPC_IA_CMD,\r\nSST_FLAG_BLOCKED, SST_TASK_SBA, 0, &cmd,\r\nsizeof(cmd.header) + cmd.header.length);\r\nif (ret && enable) {\r\ntimer_usage--;\r\nenable = false;\r\n}\r\n}\r\nmutex_unlock(&drv->lock);\r\nif (!enable)\r\nsst->ops->power(sst->dev, false);\r\nreturn ret;\r\n}\r\nint send_ssp_cmd(struct snd_soc_dai *dai, const char *id, bool enable)\r\n{\r\nstruct sst_cmd_sba_hw_set_ssp cmd;\r\nstruct sst_data *drv = snd_soc_dai_get_drvdata(dai);\r\nconst struct sst_ssp_config *config;\r\ndev_info(dai->dev, "Enter: enable=%d port_name=%s\n", enable, id);\r\nSST_FILL_DEFAULT_DESTINATION(cmd.header.dst);\r\ncmd.header.command_id = SBA_HW_SET_SSP;\r\ncmd.header.length = sizeof(struct sst_cmd_sba_hw_set_ssp)\r\n- sizeof(struct sst_dsp_header);\r\nconfig = &sst_ssp_configs;\r\ndev_dbg(dai->dev, "ssp_id: %u\n", config->ssp_id);\r\nif (enable)\r\ncmd.switch_state = SST_SWITCH_ON;\r\nelse\r\ncmd.switch_state = SST_SWITCH_OFF;\r\ncmd.selection = config->ssp_id;\r\ncmd.nb_bits_per_slots = config->bits_per_slot;\r\ncmd.nb_slots = config->slots;\r\ncmd.mode = config->ssp_mode | (config->pcm_mode << 1);\r\ncmd.duplex = config->duplex;\r\ncmd.active_tx_slot_map = config->active_slot_map;\r\ncmd.active_rx_slot_map = config->active_slot_map;\r\ncmd.frame_sync_frequency = config->fs_frequency;\r\ncmd.frame_sync_polarity = SSP_FS_ACTIVE_HIGH;\r\ncmd.data_polarity = 1;\r\ncmd.frame_sync_width = config->fs_width;\r\ncmd.ssp_protocol = config->ssp_protocol;\r\ncmd.start_delay = config->start_delay;\r\ncmd.reserved1 = cmd.reserved2 = 0xFF;\r\nreturn sst_fill_and_send_cmd(drv, SST_IPC_IA_CMD, SST_FLAG_BLOCKED,\r\nSST_TASK_SBA, 0, &cmd,\r\nsizeof(cmd.header) + cmd.header.length);\r\n}\r\nstatic int sst_set_be_modules(struct snd_soc_dapm_widget *w,\r\nstruct snd_kcontrol *k, int event)\r\n{\r\nint ret = 0;\r\nstruct snd_soc_component *c = snd_soc_dapm_to_component(w->dapm);\r\nstruct sst_data *drv = snd_soc_component_get_drvdata(c);\r\ndev_dbg(c->dev, "Enter: widget=%s\n", w->name);\r\nif (SND_SOC_DAPM_EVENT_ON(event)) {\r\nret = sst_send_slot_map(drv);\r\nif (ret)\r\nreturn ret;\r\nret = sst_send_pipe_module_params(w, k);\r\n}\r\nreturn ret;\r\n}\r\nstatic int sst_set_media_path(struct snd_soc_dapm_widget *w,\r\nstruct snd_kcontrol *k, int event)\r\n{\r\nint ret = 0;\r\nstruct sst_cmd_set_media_path cmd;\r\nstruct snd_soc_component *c = snd_soc_dapm_to_component(w->dapm);\r\nstruct sst_data *drv = snd_soc_component_get_drvdata(c);\r\nstruct sst_ids *ids = w->priv;\r\ndev_dbg(c->dev, "widget=%s\n", w->name);\r\ndev_dbg(c->dev, "task=%u, location=%#x\n",\r\nids->task_id, ids->location_id);\r\nif (SND_SOC_DAPM_EVENT_ON(event))\r\ncmd.switch_state = SST_PATH_ON;\r\nelse\r\ncmd.switch_state = SST_PATH_OFF;\r\nSST_FILL_DESTINATION(2, cmd.header.dst,\r\nids->location_id, SST_DEFAULT_MODULE_ID);\r\ncmd.header.command_id = MMX_SET_MEDIA_PATH;\r\ncmd.header.length = sizeof(struct sst_cmd_set_media_path)\r\n- sizeof(struct sst_dsp_header);\r\nret = sst_fill_and_send_cmd(drv, SST_IPC_IA_CMD, SST_FLAG_BLOCKED,\r\nids->task_id, 0, &cmd,\r\nsizeof(cmd.header) + cmd.header.length);\r\nif (ret)\r\nreturn ret;\r\nif (SND_SOC_DAPM_EVENT_ON(event))\r\nret = sst_send_pipe_module_params(w, k);\r\nreturn ret;\r\n}\r\nstatic int sst_set_media_loop(struct snd_soc_dapm_widget *w,\r\nstruct snd_kcontrol *k, int event)\r\n{\r\nint ret = 0;\r\nstruct sst_cmd_sba_set_media_loop_map cmd;\r\nstruct snd_soc_component *c = snd_soc_dapm_to_component(w->dapm);\r\nstruct sst_data *drv = snd_soc_component_get_drvdata(c);\r\nstruct sst_ids *ids = w->priv;\r\ndev_dbg(c->dev, "Enter:widget=%s\n", w->name);\r\nif (SND_SOC_DAPM_EVENT_ON(event))\r\ncmd.switch_state = SST_SWITCH_ON;\r\nelse\r\ncmd.switch_state = SST_SWITCH_OFF;\r\nSST_FILL_DESTINATION(2, cmd.header.dst,\r\nids->location_id, SST_DEFAULT_MODULE_ID);\r\ncmd.header.command_id = SBA_SET_MEDIA_LOOP_MAP;\r\ncmd.header.length = sizeof(struct sst_cmd_sba_set_media_loop_map)\r\n- sizeof(struct sst_dsp_header);\r\ncmd.param.part.cfg.rate = 2;\r\ncmd.param.part.cfg.format = ids->format;\r\ncmd.param.part.cfg.s_length = 1;\r\ncmd.map = 0;\r\nret = sst_fill_and_send_cmd(drv, SST_IPC_IA_CMD, SST_FLAG_BLOCKED,\r\nSST_TASK_SBA, 0, &cmd,\r\nsizeof(cmd.header) + cmd.header.length);\r\nif (ret)\r\nreturn ret;\r\nif (SND_SOC_DAPM_EVENT_ON(event))\r\nret = sst_send_pipe_module_params(w, k);\r\nreturn ret;\r\n}\r\nstatic int sst_algo_control_init(struct device *dev)\r\n{\r\nint i = 0;\r\nstruct sst_algo_control *bc;\r\nfor (i = 0; i < ARRAY_SIZE(sst_algo_controls); i++) {\r\nbc = (struct sst_algo_control *)sst_algo_controls[i].private_value;\r\nbc->params = devm_kzalloc(dev, bc->max, GFP_KERNEL);\r\nif (bc->params == NULL)\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}\r\nstatic bool is_sst_dapm_widget(struct snd_soc_dapm_widget *w)\r\n{\r\nswitch (w->id) {\r\ncase snd_soc_dapm_pga:\r\ncase snd_soc_dapm_aif_in:\r\ncase snd_soc_dapm_aif_out:\r\ncase snd_soc_dapm_input:\r\ncase snd_soc_dapm_output:\r\ncase snd_soc_dapm_mixer:\r\nreturn true;\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nint sst_send_pipe_gains(struct snd_soc_dai *dai, int stream, int mute)\r\n{\r\nstruct sst_data *drv = snd_soc_dai_get_drvdata(dai);\r\nstruct snd_soc_dapm_widget *w;\r\nstruct snd_soc_dapm_path *p = NULL;\r\ndev_dbg(dai->dev, "enter, dai-name=%s dir=%d\n", dai->name, stream);\r\nif (stream == SNDRV_PCM_STREAM_PLAYBACK) {\r\ndev_dbg(dai->dev, "Stream name=%s\n",\r\ndai->playback_widget->name);\r\nw = dai->playback_widget;\r\nlist_for_each_entry(p, &w->sinks, list_source) {\r\nif (p->connected && !p->connected(w, p->sink))\r\ncontinue;\r\nif (p->connect && p->sink->power &&\r\nis_sst_dapm_widget(p->sink)) {\r\nstruct sst_ids *ids = p->sink->priv;\r\ndev_dbg(dai->dev, "send gains for widget=%s\n",\r\np->sink->name);\r\nmutex_lock(&drv->lock);\r\nsst_set_pipe_gain(ids, drv, mute);\r\nmutex_unlock(&drv->lock);\r\n}\r\n}\r\n} else {\r\ndev_dbg(dai->dev, "Stream name=%s\n",\r\ndai->capture_widget->name);\r\nw = dai->capture_widget;\r\nlist_for_each_entry(p, &w->sources, list_sink) {\r\nif (p->connected && !p->connected(w, p->sink))\r\ncontinue;\r\nif (p->connect && p->source->power &&\r\nis_sst_dapm_widget(p->source)) {\r\nstruct sst_ids *ids = p->source->priv;\r\ndev_dbg(dai->dev, "send gain for widget=%s\n",\r\np->source->name);\r\nmutex_lock(&drv->lock);\r\nsst_set_pipe_gain(ids, drv, mute);\r\nmutex_unlock(&drv->lock);\r\n}\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int sst_fill_module_list(struct snd_kcontrol *kctl,\r\nstruct snd_soc_dapm_widget *w, int type)\r\n{\r\nstruct sst_module *module = NULL;\r\nstruct snd_soc_component *c = snd_soc_dapm_to_component(w->dapm);\r\nstruct sst_ids *ids = w->priv;\r\nint ret = 0;\r\nmodule = devm_kzalloc(c->dev, sizeof(*module), GFP_KERNEL);\r\nif (!module)\r\nreturn -ENOMEM;\r\nif (type == SST_MODULE_GAIN) {\r\nstruct sst_gain_mixer_control *mc = (void *)kctl->private_value;\r\nmc->w = w;\r\nmodule->kctl = kctl;\r\nlist_add_tail(&module->node, &ids->gain_list);\r\n} else if (type == SST_MODULE_ALGO) {\r\nstruct sst_algo_control *bc = (void *)kctl->private_value;\r\nbc->w = w;\r\nmodule->kctl = kctl;\r\nlist_add_tail(&module->node, &ids->algo_list);\r\n} else {\r\ndev_err(c->dev, "invoked for unknown type %d module %s",\r\ntype, kctl->id.name);\r\nret = -EINVAL;\r\n}\r\nreturn ret;\r\n}\r\nstatic int sst_fill_widget_module_info(struct snd_soc_dapm_widget *w,\r\nstruct snd_soc_platform *platform)\r\n{\r\nstruct snd_kcontrol *kctl;\r\nint index, ret = 0;\r\nstruct snd_card *card = platform->component.card->snd_card;\r\nchar *idx;\r\ndown_read(&card->controls_rwsem);\r\nlist_for_each_entry(kctl, &card->controls, list) {\r\nidx = strstr(kctl->id.name, " ");\r\nif (idx == NULL)\r\ncontinue;\r\nindex = strlen(kctl->id.name) - strlen(idx);\r\nif (strstr(kctl->id.name, "Volume") &&\r\n!strncmp(kctl->id.name, w->name, index))\r\nret = sst_fill_module_list(kctl, w, SST_MODULE_GAIN);\r\nelse if (strstr(kctl->id.name, "params") &&\r\n!strncmp(kctl->id.name, w->name, index))\r\nret = sst_fill_module_list(kctl, w, SST_MODULE_ALGO);\r\nelse if (strstr(kctl->id.name, "Switch") &&\r\n!strncmp(kctl->id.name, w->name, index) &&\r\nstrstr(kctl->id.name, "Gain")) {\r\nstruct sst_gain_mixer_control *mc =\r\n(void *)kctl->private_value;\r\nmc->w = w;\r\n} else if (strstr(kctl->id.name, "interleaver") &&\r\n!strncmp(kctl->id.name, w->name, index)) {\r\nstruct sst_enum *e = (void *)kctl->private_value;\r\ne->w = w;\r\n} else if (strstr(kctl->id.name, "deinterleaver") &&\r\n!strncmp(kctl->id.name, w->name, index)) {\r\nstruct sst_enum *e = (void *)kctl->private_value;\r\ne->w = w;\r\n}\r\nif (ret < 0) {\r\nup_read(&card->controls_rwsem);\r\nreturn ret;\r\n}\r\n}\r\nup_read(&card->controls_rwsem);\r\nreturn 0;\r\n}\r\nstatic void sst_fill_linked_widgets(struct snd_soc_platform *platform,\r\nstruct sst_ids *ids)\r\n{\r\nstruct snd_soc_dapm_widget *w;\r\nunsigned int len = strlen(ids->parent_wname);\r\nlist_for_each_entry(w, &platform->component.card->widgets, list) {\r\nif (!strncmp(ids->parent_wname, w->name, len)) {\r\nids->parent_w = w;\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic int sst_map_modules_to_pipe(struct snd_soc_platform *platform)\r\n{\r\nstruct snd_soc_dapm_widget *w;\r\nint ret = 0;\r\nlist_for_each_entry(w, &platform->component.card->widgets, list) {\r\nif (is_sst_dapm_widget(w) && (w->priv)) {\r\nstruct sst_ids *ids = w->priv;\r\ndev_dbg(platform->dev, "widget type=%d name=%s\n",\r\nw->id, w->name);\r\nINIT_LIST_HEAD(&ids->algo_list);\r\nINIT_LIST_HEAD(&ids->gain_list);\r\nret = sst_fill_widget_module_info(w, platform);\r\nif (ret < 0)\r\nreturn ret;\r\nif (ids->parent_wname != NULL)\r\nsst_fill_linked_widgets(platform, ids);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nint sst_dsp_init_v2_dpcm(struct snd_soc_platform *platform)\r\n{\r\nint i, ret = 0;\r\nstruct snd_soc_dapm_context *dapm =\r\nsnd_soc_component_get_dapm(&platform->component);\r\nstruct sst_data *drv = snd_soc_platform_get_drvdata(platform);\r\nunsigned int gains = ARRAY_SIZE(sst_gain_controls)/3;\r\ndrv->byte_stream = devm_kzalloc(platform->dev,\r\nSST_MAX_BIN_BYTES, GFP_KERNEL);\r\nif (!drv->byte_stream)\r\nreturn -ENOMEM;\r\nsnd_soc_dapm_new_controls(dapm, sst_dapm_widgets,\r\nARRAY_SIZE(sst_dapm_widgets));\r\nsnd_soc_dapm_add_routes(dapm, intercon,\r\nARRAY_SIZE(intercon));\r\nsnd_soc_dapm_new_widgets(dapm->card);\r\nfor (i = 0; i < gains; i++) {\r\nsst_gains[i].mute = SST_GAIN_MUTE_DEFAULT;\r\nsst_gains[i].l_gain = SST_GAIN_VOLUME_DEFAULT;\r\nsst_gains[i].r_gain = SST_GAIN_VOLUME_DEFAULT;\r\nsst_gains[i].ramp_duration = SST_GAIN_RAMP_DURATION_DEFAULT;\r\n}\r\nret = snd_soc_add_platform_controls(platform, sst_gain_controls,\r\nARRAY_SIZE(sst_gain_controls));\r\nif (ret)\r\nreturn ret;\r\nret = sst_algo_control_init(platform->dev);\r\nif (ret)\r\nreturn ret;\r\nret = snd_soc_add_platform_controls(platform, sst_algo_controls,\r\nARRAY_SIZE(sst_algo_controls));\r\nif (ret)\r\nreturn ret;\r\nret = snd_soc_add_platform_controls(platform, sst_slot_controls,\r\nARRAY_SIZE(sst_slot_controls));\r\nif (ret)\r\nreturn ret;\r\nret = sst_map_modules_to_pipe(platform);\r\nreturn ret;\r\n}
