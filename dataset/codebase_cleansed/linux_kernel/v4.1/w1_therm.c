static int w1_therm_add_slave(struct w1_slave *sl)\r\n{\r\nsl->family_data = kzalloc(9, GFP_KERNEL);\r\nif (!sl->family_data)\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nstatic void w1_therm_remove_slave(struct w1_slave *sl)\r\n{\r\nkfree(sl->family_data);\r\nsl->family_data = NULL;\r\n}\r\nstatic inline int w1_DS18B20_convert_temp(u8 rom[9])\r\n{\r\ns16 t = le16_to_cpup((__le16 *)rom);\r\nreturn t*1000/16;\r\n}\r\nstatic inline int w1_DS18S20_convert_temp(u8 rom[9])\r\n{\r\nint t, h;\r\nif (!rom[7])\r\nreturn 0;\r\nif (rom[1] == 0)\r\nt = ((s32)rom[0] >> 1)*1000;\r\nelse\r\nt = 1000*(-1*(s32)(0x100-rom[0]) >> 1);\r\nt -= 250;\r\nh = 1000*((s32)rom[7] - (s32)rom[6]);\r\nh /= (s32)rom[7];\r\nt += h;\r\nreturn t;\r\n}\r\nstatic inline int w1_convert_temp(u8 rom[9], u8 fid)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(w1_therm_families); ++i)\r\nif (w1_therm_families[i].f->fid == fid)\r\nreturn w1_therm_families[i].convert(rom);\r\nreturn 0;\r\n}\r\nstatic ssize_t w1_slave_show(struct device *device,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct w1_slave *sl = dev_to_w1_slave(device);\r\nstruct w1_master *dev = sl->master;\r\nu8 rom[9], crc, verdict, external_power;\r\nint i, max_trying = 10;\r\nssize_t c = PAGE_SIZE;\r\ni = mutex_lock_interruptible(&dev->bus_mutex);\r\nif (i != 0)\r\nreturn i;\r\nmemset(rom, 0, sizeof(rom));\r\nwhile (max_trying--) {\r\nverdict = 0;\r\ncrc = 0;\r\nif (!w1_reset_select_slave(sl)) {\r\nint count = 0;\r\nunsigned int tm = 750;\r\nunsigned long sleep_rem;\r\nw1_write_8(dev, W1_READ_PSUPPLY);\r\nexternal_power = w1_read_8(dev);\r\nif (w1_reset_select_slave(sl))\r\ncontinue;\r\nif (w1_strong_pullup == 2 ||\r\n(!external_power && w1_strong_pullup))\r\nw1_next_pullup(dev, tm);\r\nw1_write_8(dev, W1_CONVERT_TEMP);\r\nif (external_power) {\r\nmutex_unlock(&dev->bus_mutex);\r\nsleep_rem = msleep_interruptible(tm);\r\nif (sleep_rem != 0)\r\nreturn -EINTR;\r\ni = mutex_lock_interruptible(&dev->bus_mutex);\r\nif (i != 0)\r\nreturn i;\r\n} else if (!w1_strong_pullup) {\r\nsleep_rem = msleep_interruptible(tm);\r\nif (sleep_rem != 0) {\r\nmutex_unlock(&dev->bus_mutex);\r\nreturn -EINTR;\r\n}\r\n}\r\nif (!w1_reset_select_slave(sl)) {\r\nw1_write_8(dev, W1_READ_SCRATCHPAD);\r\nif ((count = w1_read_block(dev, rom, 9)) != 9) {\r\ndev_warn(device, "w1_read_block() "\r\n"returned %u instead of 9.\n",\r\ncount);\r\n}\r\ncrc = w1_calc_crc8(rom, 8);\r\nif (rom[8] == crc)\r\nverdict = 1;\r\n}\r\n}\r\nif (verdict)\r\nbreak;\r\n}\r\nfor (i = 0; i < 9; ++i)\r\nc -= snprintf(buf + PAGE_SIZE - c, c, "%02x ", rom[i]);\r\nc -= snprintf(buf + PAGE_SIZE - c, c, ": crc=%02x %s\n",\r\ncrc, (verdict) ? "YES" : "NO");\r\nif (verdict)\r\nmemcpy(sl->family_data, rom, sizeof(rom));\r\nelse\r\ndev_warn(device, "Read failed CRC check\n");\r\nfor (i = 0; i < 9; ++i)\r\nc -= snprintf(buf + PAGE_SIZE - c, c, "%02x ",\r\n((u8 *)sl->family_data)[i]);\r\nc -= snprintf(buf + PAGE_SIZE - c, c, "t=%d\n",\r\nw1_convert_temp(rom, sl->family->fid));\r\nmutex_unlock(&dev->bus_mutex);\r\nreturn PAGE_SIZE - c;\r\n}\r\nstatic int __init w1_therm_init(void)\r\n{\r\nint err, i;\r\nfor (i = 0; i < ARRAY_SIZE(w1_therm_families); ++i) {\r\nerr = w1_register_family(w1_therm_families[i].f);\r\nif (err)\r\nw1_therm_families[i].broken = 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic void __exit w1_therm_fini(void)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(w1_therm_families); ++i)\r\nif (!w1_therm_families[i].broken)\r\nw1_unregister_family(w1_therm_families[i].f);\r\n}
