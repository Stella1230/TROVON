static int __set_phy_state(struct exynos_mipi_video_phy *state,\r\nenum exynos_mipi_phy_id id, unsigned int on)\r\n{\r\nconst unsigned int offset = EXYNOS4_MIPI_PHY_CONTROL(id / 2);\r\nvoid __iomem *addr;\r\nu32 val, reset;\r\nif (is_mipi_dsim_phy_id(id))\r\nreset = EXYNOS4_MIPI_PHY_MRESETN;\r\nelse\r\nreset = EXYNOS4_MIPI_PHY_SRESETN;\r\nspin_lock(&state->slock);\r\nif (!IS_ERR(state->regmap)) {\r\nregmap_read(state->regmap, offset, &val);\r\nif (on)\r\nval |= reset;\r\nelse\r\nval &= ~reset;\r\nregmap_write(state->regmap, offset, val);\r\nif (on)\r\nval |= EXYNOS4_MIPI_PHY_ENABLE;\r\nelse if (!(val & EXYNOS4_MIPI_PHY_RESET_MASK))\r\nval &= ~EXYNOS4_MIPI_PHY_ENABLE;\r\nregmap_write(state->regmap, offset, val);\r\n} else {\r\naddr = state->regs + EXYNOS_MIPI_PHY_CONTROL(id / 2);\r\nval = readl(addr);\r\nif (on)\r\nval |= reset;\r\nelse\r\nval &= ~reset;\r\nwritel(val, addr);\r\nif (on)\r\nval |= EXYNOS4_MIPI_PHY_ENABLE;\r\nelse if (!(val & EXYNOS4_MIPI_PHY_RESET_MASK))\r\nval &= ~EXYNOS4_MIPI_PHY_ENABLE;\r\nwritel(val, addr);\r\n}\r\nspin_unlock(&state->slock);\r\nreturn 0;\r\n}\r\nstatic int exynos_mipi_video_phy_power_on(struct phy *phy)\r\n{\r\nstruct video_phy_desc *phy_desc = phy_get_drvdata(phy);\r\nstruct exynos_mipi_video_phy *state = to_mipi_video_phy(phy_desc);\r\nreturn __set_phy_state(state, phy_desc->index, 1);\r\n}\r\nstatic int exynos_mipi_video_phy_power_off(struct phy *phy)\r\n{\r\nstruct video_phy_desc *phy_desc = phy_get_drvdata(phy);\r\nstruct exynos_mipi_video_phy *state = to_mipi_video_phy(phy_desc);\r\nreturn __set_phy_state(state, phy_desc->index, 0);\r\n}\r\nstatic struct phy *exynos_mipi_video_phy_xlate(struct device *dev,\r\nstruct of_phandle_args *args)\r\n{\r\nstruct exynos_mipi_video_phy *state = dev_get_drvdata(dev);\r\nif (WARN_ON(args->args[0] >= EXYNOS_MIPI_PHYS_NUM))\r\nreturn ERR_PTR(-ENODEV);\r\nreturn state->phys[args->args[0]].phy;\r\n}\r\nstatic int exynos_mipi_video_phy_probe(struct platform_device *pdev)\r\n{\r\nstruct exynos_mipi_video_phy *state;\r\nstruct device *dev = &pdev->dev;\r\nstruct phy_provider *phy_provider;\r\nunsigned int i;\r\nstate = devm_kzalloc(dev, sizeof(*state), GFP_KERNEL);\r\nif (!state)\r\nreturn -ENOMEM;\r\nstate->regmap = syscon_regmap_lookup_by_phandle(dev->of_node, "syscon");\r\nif (IS_ERR(state->regmap)) {\r\nstruct resource *res;\r\ndev_info(dev, "regmap lookup failed: %ld\n",\r\nPTR_ERR(state->regmap));\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nstate->regs = devm_ioremap_resource(dev, res);\r\nif (IS_ERR(state->regs))\r\nreturn PTR_ERR(state->regs);\r\n}\r\ndev_set_drvdata(dev, state);\r\nspin_lock_init(&state->slock);\r\nfor (i = 0; i < EXYNOS_MIPI_PHYS_NUM; i++) {\r\nstruct phy *phy = devm_phy_create(dev, NULL,\r\n&exynos_mipi_video_phy_ops);\r\nif (IS_ERR(phy)) {\r\ndev_err(dev, "failed to create PHY %d\n", i);\r\nreturn PTR_ERR(phy);\r\n}\r\nstate->phys[i].phy = phy;\r\nstate->phys[i].index = i;\r\nphy_set_drvdata(phy, &state->phys[i]);\r\n}\r\nphy_provider = devm_of_phy_provider_register(dev,\r\nexynos_mipi_video_phy_xlate);\r\nreturn PTR_ERR_OR_ZERO(phy_provider);\r\n}
