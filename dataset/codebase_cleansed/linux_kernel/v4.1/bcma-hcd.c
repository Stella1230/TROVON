static int bcma_wait_bits(struct bcma_device *dev, u16 reg, u32 bitmask,\r\nint timeout)\r\n{\r\nint i;\r\nu32 val;\r\nfor (i = 0; i < timeout; i++) {\r\nval = bcma_read32(dev, reg);\r\nif ((val & bitmask) == bitmask)\r\nreturn 0;\r\nudelay(10);\r\n}\r\nreturn -ETIMEDOUT;\r\n}\r\nstatic void bcma_hcd_4716wa(struct bcma_device *dev)\r\n{\r\n#ifdef CONFIG_BCMA_DRIVER_MIPS\r\nif (dev->bus->chipinfo.id == 0x4716) {\r\nu32 tmp;\r\ntmp = bcma_cpu_clock(&dev->bus->drv_mips);\r\nif (tmp >= 480000000)\r\ntmp = 0x1846b;\r\nelse if (tmp == 453000000)\r\ntmp = 0x1046b;\r\nelse\r\ntmp = 0;\r\nif (tmp) {\r\nbcma_write32(dev, 0x524, 0x1);\r\nudelay(500);\r\nbcma_write32(dev, 0x524, tmp);\r\nudelay(500);\r\nbcma_write32(dev, 0x524, 0x4ab);\r\nudelay(500);\r\nbcma_read32(dev, 0x528);\r\nbcma_write32(dev, 0x528, 0x80000000);\r\n}\r\n}\r\n#endif\r\n}\r\nstatic void bcma_hcd_init_chip(struct bcma_device *dev)\r\n{\r\nu32 tmp;\r\nif (!bcma_core_is_enabled(dev)) {\r\nbcma_core_enable(dev, 0);\r\nmdelay(10);\r\nif (dev->id.rev >= 5) {\r\ntmp = bcma_read32(dev, 0x1e0);\r\ntmp |= 0x100;\r\nbcma_write32(dev, 0x1e0, tmp);\r\nif (bcma_wait_bits(dev, 0x1e0, 1 << 24, 100))\r\nprintk(KERN_EMERG "Failed to enable misc PPL!\n");\r\nbcma_write32(dev, 0x200, 0x4ff);\r\nudelay(25);\r\nbcma_write32(dev, 0x200, 0x6ff);\r\nudelay(25);\r\nbcma_write32(dev, 0x524, 0x6b);\r\nudelay(50);\r\ntmp = bcma_read32(dev, 0x524);\r\nudelay(50);\r\nbcma_write32(dev, 0x524, 0xab);\r\nudelay(50);\r\ntmp = bcma_read32(dev, 0x524);\r\nudelay(50);\r\nbcma_write32(dev, 0x524, 0x2b);\r\nudelay(50);\r\ntmp = bcma_read32(dev, 0x524);\r\nudelay(50);\r\nbcma_write32(dev, 0x524, 0x10ab);\r\nudelay(50);\r\ntmp = bcma_read32(dev, 0x524);\r\nif (bcma_wait_bits(dev, 0x528, 0xc000, 10000)) {\r\ntmp = bcma_read32(dev, 0x528);\r\nprintk(KERN_EMERG\r\n"USB20H mdio_rddata 0x%08x\n", tmp);\r\n}\r\nbcma_write32(dev, 0x528, 0x80000000);\r\ntmp = bcma_read32(dev, 0x314);\r\nudelay(265);\r\nbcma_write32(dev, 0x200, 0x7ff);\r\nudelay(10);\r\nbcma_write32(dev, 0x510, 0);\r\n} else {\r\nbcma_write32(dev, 0x200, 0x7ff);\r\nudelay(1);\r\n}\r\nbcma_hcd_4716wa(dev);\r\n}\r\n}\r\nstatic struct platform_device *bcma_hcd_create_pdev(struct bcma_device *dev, bool ohci, u32 addr)\r\n{\r\nstruct platform_device *hci_dev;\r\nstruct resource hci_res[2];\r\nint ret = -ENOMEM;\r\nmemset(hci_res, 0, sizeof(hci_res));\r\nhci_res[0].start = addr;\r\nhci_res[0].end = hci_res[0].start + 0x1000 - 1;\r\nhci_res[0].flags = IORESOURCE_MEM;\r\nhci_res[1].start = dev->irq;\r\nhci_res[1].flags = IORESOURCE_IRQ;\r\nhci_dev = platform_device_alloc(ohci ? "ohci-platform" :\r\n"ehci-platform" , 0);\r\nif (!hci_dev)\r\nreturn NULL;\r\nhci_dev->dev.parent = &dev->dev;\r\nhci_dev->dev.dma_mask = &hci_dev->dev.coherent_dma_mask;\r\nret = platform_device_add_resources(hci_dev, hci_res,\r\nARRAY_SIZE(hci_res));\r\nif (ret)\r\ngoto err_alloc;\r\nif (ohci)\r\nret = platform_device_add_data(hci_dev, &ohci_pdata,\r\nsizeof(ohci_pdata));\r\nelse\r\nret = platform_device_add_data(hci_dev, &ehci_pdata,\r\nsizeof(ehci_pdata));\r\nif (ret)\r\ngoto err_alloc;\r\nret = platform_device_add(hci_dev);\r\nif (ret)\r\ngoto err_alloc;\r\nreturn hci_dev;\r\nerr_alloc:\r\nplatform_device_put(hci_dev);\r\nreturn ERR_PTR(ret);\r\n}\r\nstatic int bcma_hcd_probe(struct bcma_device *dev)\r\n{\r\nint err;\r\nu16 chipid_top;\r\nu32 ohci_addr;\r\nstruct bcma_hcd_device *usb_dev;\r\nstruct bcma_chipinfo *chipinfo;\r\nchipinfo = &dev->bus->chipinfo;\r\nchipid_top = (chipinfo->id & 0xFF00);\r\nif (chipid_top != 0x4700 && chipid_top != 0x5300)\r\nreturn -ENODEV;\r\nif (dma_set_mask_and_coherent(dev->dma_dev, DMA_BIT_MASK(32)))\r\nreturn -EOPNOTSUPP;\r\nusb_dev = kzalloc(sizeof(struct bcma_hcd_device), GFP_KERNEL);\r\nif (!usb_dev)\r\nreturn -ENOMEM;\r\nbcma_hcd_init_chip(dev);\r\nohci_addr = dev->addr_s[0];\r\nif ((chipinfo->id == 0x5357 || chipinfo->id == 0x4749)\r\n&& chipinfo->rev == 0)\r\nohci_addr = 0x18009000;\r\nusb_dev->ohci_dev = bcma_hcd_create_pdev(dev, true, ohci_addr);\r\nif (IS_ERR(usb_dev->ohci_dev)) {\r\nerr = PTR_ERR(usb_dev->ohci_dev);\r\ngoto err_free_usb_dev;\r\n}\r\nusb_dev->ehci_dev = bcma_hcd_create_pdev(dev, false, dev->addr);\r\nif (IS_ERR(usb_dev->ehci_dev)) {\r\nerr = PTR_ERR(usb_dev->ehci_dev);\r\ngoto err_unregister_ohci_dev;\r\n}\r\nbcma_set_drvdata(dev, usb_dev);\r\nreturn 0;\r\nerr_unregister_ohci_dev:\r\nplatform_device_unregister(usb_dev->ohci_dev);\r\nerr_free_usb_dev:\r\nkfree(usb_dev);\r\nreturn err;\r\n}\r\nstatic void bcma_hcd_remove(struct bcma_device *dev)\r\n{\r\nstruct bcma_hcd_device *usb_dev = bcma_get_drvdata(dev);\r\nstruct platform_device *ohci_dev = usb_dev->ohci_dev;\r\nstruct platform_device *ehci_dev = usb_dev->ehci_dev;\r\nif (ohci_dev)\r\nplatform_device_unregister(ohci_dev);\r\nif (ehci_dev)\r\nplatform_device_unregister(ehci_dev);\r\nbcma_core_disable(dev, 0);\r\n}\r\nstatic void bcma_hcd_shutdown(struct bcma_device *dev)\r\n{\r\nbcma_core_disable(dev, 0);\r\n}\r\nstatic int bcma_hcd_suspend(struct bcma_device *dev)\r\n{\r\nbcma_core_disable(dev, 0);\r\nreturn 0;\r\n}\r\nstatic int bcma_hcd_resume(struct bcma_device *dev)\r\n{\r\nbcma_core_enable(dev, 0);\r\nreturn 0;\r\n}\r\nstatic int __init bcma_hcd_init(void)\r\n{\r\nreturn bcma_driver_register(&bcma_hcd_driver);\r\n}\r\nstatic void __exit bcma_hcd_exit(void)\r\n{\r\nbcma_driver_unregister(&bcma_hcd_driver);\r\n}
