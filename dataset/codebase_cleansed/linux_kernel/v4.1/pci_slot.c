static int\r\ncheck_slot(acpi_handle handle, unsigned long long *sun)\r\n{\r\nint device = -1;\r\nunsigned long long adr, sta;\r\nacpi_status status;\r\nstruct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };\r\nacpi_get_name(handle, ACPI_FULL_PATHNAME, &buffer);\r\ndbg("Checking slot on path: %s\n", (char *)buffer.pointer);\r\nif (check_sta_before_sun) {\r\nstatus = acpi_evaluate_integer(handle, "_STA", NULL, &sta);\r\nif (ACPI_SUCCESS(status) && !(sta & ACPI_STA_DEVICE_PRESENT))\r\ngoto out;\r\n}\r\nstatus = acpi_evaluate_integer(handle, "_ADR", NULL, &adr);\r\nif (ACPI_FAILURE(status)) {\r\ndbg("_ADR returned %d on %s\n", status, (char *)buffer.pointer);\r\ngoto out;\r\n}\r\nstatus = acpi_evaluate_integer(handle, "_SUN", NULL, sun);\r\nif (ACPI_FAILURE(status)) {\r\ndbg("_SUN returned %d on %s\n", status, (char *)buffer.pointer);\r\ngoto out;\r\n}\r\ndevice = (adr >> 16) & 0xffff;\r\nout:\r\nkfree(buffer.pointer);\r\nreturn device;\r\n}\r\nstatic acpi_status\r\nregister_slot(acpi_handle handle, u32 lvl, void *context, void **rv)\r\n{\r\nint device;\r\nunsigned long long sun;\r\nchar name[SLOT_NAME_SIZE];\r\nstruct acpi_pci_slot *slot;\r\nstruct pci_slot *pci_slot;\r\nstruct pci_bus *pci_bus = context;\r\ndevice = check_slot(handle, &sun);\r\nif (device < 0)\r\nreturn AE_OK;\r\nlist_for_each_entry(slot, &slot_list, list) {\r\npci_slot = slot->pci_slot;\r\nif (pci_slot->bus == pci_bus && pci_slot->number == device)\r\nreturn AE_OK;\r\n}\r\nslot = kmalloc(sizeof(*slot), GFP_KERNEL);\r\nif (!slot) {\r\nerr("%s: cannot allocate memory\n", __func__);\r\nreturn AE_OK;\r\n}\r\nsnprintf(name, sizeof(name), "%llu", sun);\r\npci_slot = pci_create_slot(pci_bus, device, name, NULL);\r\nif (IS_ERR(pci_slot)) {\r\nerr("pci_create_slot returned %ld\n", PTR_ERR(pci_slot));\r\nkfree(slot);\r\nreturn AE_OK;\r\n}\r\nslot->pci_slot = pci_slot;\r\nlist_add(&slot->list, &slot_list);\r\nget_device(&pci_bus->dev);\r\ndbg("pci_slot: %p, pci_bus: %x, device: %d, name: %s\n",\r\npci_slot, pci_bus->number, device, name);\r\nreturn AE_OK;\r\n}\r\nvoid acpi_pci_slot_enumerate(struct pci_bus *bus)\r\n{\r\nacpi_handle handle = ACPI_HANDLE(bus->bridge);\r\nif (handle) {\r\nmutex_lock(&slot_list_lock);\r\nacpi_walk_namespace(ACPI_TYPE_DEVICE, handle, 1,\r\nregister_slot, NULL, bus, NULL);\r\nmutex_unlock(&slot_list_lock);\r\n}\r\n}\r\nvoid acpi_pci_slot_remove(struct pci_bus *bus)\r\n{\r\nstruct acpi_pci_slot *slot, *tmp;\r\nmutex_lock(&slot_list_lock);\r\nlist_for_each_entry_safe(slot, tmp, &slot_list, list) {\r\nif (slot->pci_slot->bus == bus) {\r\nlist_del(&slot->list);\r\npci_destroy_slot(slot->pci_slot);\r\nput_device(&bus->dev);\r\nkfree(slot);\r\n}\r\n}\r\nmutex_unlock(&slot_list_lock);\r\n}\r\nstatic int do_sta_before_sun(const struct dmi_system_id *d)\r\n{\r\ninfo("%s detected: will evaluate _STA before calling _SUN\n", d->ident);\r\ncheck_sta_before_sun = 1;\r\nreturn 0;\r\n}\r\nvoid __init acpi_pci_slot_init(void)\r\n{\r\ndmi_check_system(acpi_pci_slot_dmi_table);\r\n}
