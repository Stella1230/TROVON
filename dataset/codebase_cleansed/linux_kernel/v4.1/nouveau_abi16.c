struct nouveau_abi16 *\r\nnouveau_abi16_get(struct drm_file *file_priv, struct drm_device *dev)\r\n{\r\nstruct nouveau_cli *cli = nouveau_cli(file_priv);\r\nmutex_lock(&cli->mutex);\r\nif (!cli->abi16) {\r\nstruct nouveau_abi16 *abi16;\r\ncli->abi16 = abi16 = kzalloc(sizeof(*abi16), GFP_KERNEL);\r\nif (cli->abi16) {\r\nstruct nv_device_v0 args = {\r\n.device = ~0ULL,\r\n};\r\nINIT_LIST_HEAD(&abi16->channels);\r\nif (nvif_device_init(&cli->base.base, NULL,\r\nNOUVEAU_ABI16_DEVICE, NV_DEVICE,\r\n&args, sizeof(args),\r\n&abi16->device) == 0)\r\nreturn cli->abi16;\r\nkfree(cli->abi16);\r\ncli->abi16 = NULL;\r\n}\r\nmutex_unlock(&cli->mutex);\r\n}\r\nreturn cli->abi16;\r\n}\r\nint\r\nnouveau_abi16_put(struct nouveau_abi16 *abi16, int ret)\r\n{\r\nstruct nouveau_cli *cli = (void *)nvif_client(&abi16->device.base);\r\nmutex_unlock(&cli->mutex);\r\nreturn ret;\r\n}\r\nu16\r\nnouveau_abi16_swclass(struct nouveau_drm *drm)\r\n{\r\nswitch (drm->device.info.family) {\r\ncase NV_DEVICE_INFO_V0_TNT:\r\nreturn 0x006e;\r\ncase NV_DEVICE_INFO_V0_CELSIUS:\r\ncase NV_DEVICE_INFO_V0_KELVIN:\r\ncase NV_DEVICE_INFO_V0_RANKINE:\r\ncase NV_DEVICE_INFO_V0_CURIE:\r\nreturn 0x016e;\r\ncase NV_DEVICE_INFO_V0_TESLA:\r\nreturn 0x506e;\r\ncase NV_DEVICE_INFO_V0_FERMI:\r\ncase NV_DEVICE_INFO_V0_KEPLER:\r\ncase NV_DEVICE_INFO_V0_MAXWELL:\r\nreturn 0x906e;\r\n}\r\nreturn 0x0000;\r\n}\r\nstatic void\r\nnouveau_abi16_ntfy_fini(struct nouveau_abi16_chan *chan,\r\nstruct nouveau_abi16_ntfy *ntfy)\r\n{\r\nnvkm_mm_free(&chan->heap, &ntfy->node);\r\nlist_del(&ntfy->head);\r\nkfree(ntfy);\r\n}\r\nstatic void\r\nnouveau_abi16_chan_fini(struct nouveau_abi16 *abi16,\r\nstruct nouveau_abi16_chan *chan)\r\n{\r\nstruct nouveau_abi16_ntfy *ntfy, *temp;\r\nif (chan->chan && chan->ntfy)\r\nnouveau_channel_idle(chan->chan);\r\nlist_for_each_entry_safe(ntfy, temp, &chan->notifiers, head) {\r\nnouveau_abi16_ntfy_fini(chan, ntfy);\r\n}\r\nif (chan->ntfy) {\r\nnouveau_bo_vma_del(chan->ntfy, &chan->ntfy_vma);\r\nnouveau_bo_unpin(chan->ntfy);\r\ndrm_gem_object_unreference_unlocked(&chan->ntfy->gem);\r\n}\r\nif (chan->heap.block_size)\r\nnvkm_mm_fini(&chan->heap);\r\nif (chan->chan) {\r\nabi16->handles &= ~(1ULL << (chan->chan->object->handle & 0xffff));\r\nnouveau_channel_del(&chan->chan);\r\n}\r\nlist_del(&chan->head);\r\nkfree(chan);\r\n}\r\nvoid\r\nnouveau_abi16_fini(struct nouveau_abi16 *abi16)\r\n{\r\nstruct nouveau_cli *cli = (void *)nvif_client(&abi16->device.base);\r\nstruct nouveau_abi16_chan *chan, *temp;\r\nlist_for_each_entry_safe(chan, temp, &abi16->channels, head) {\r\nnouveau_abi16_chan_fini(abi16, chan);\r\n}\r\nnvif_device_fini(&abi16->device);\r\nkfree(cli->abi16);\r\ncli->abi16 = NULL;\r\n}\r\nint\r\nnouveau_abi16_ioctl_getparam(ABI16_IOCTL_ARGS)\r\n{\r\nstruct nouveau_cli *cli = nouveau_cli(file_priv);\r\nstruct nouveau_drm *drm = nouveau_drm(dev);\r\nstruct nvif_device *device = &drm->device;\r\nstruct nvkm_timer *ptimer = nvxx_timer(device);\r\nstruct nvkm_gr *gr = nvxx_gr(device);\r\nstruct drm_nouveau_getparam *getparam = data;\r\nswitch (getparam->param) {\r\ncase NOUVEAU_GETPARAM_CHIPSET_ID:\r\ngetparam->value = device->info.chipset;\r\nbreak;\r\ncase NOUVEAU_GETPARAM_PCI_VENDOR:\r\nif (nv_device_is_pci(nvxx_device(device)))\r\ngetparam->value = dev->pdev->vendor;\r\nelse\r\ngetparam->value = 0;\r\nbreak;\r\ncase NOUVEAU_GETPARAM_PCI_DEVICE:\r\nif (nv_device_is_pci(nvxx_device(device)))\r\ngetparam->value = dev->pdev->device;\r\nelse\r\ngetparam->value = 0;\r\nbreak;\r\ncase NOUVEAU_GETPARAM_BUS_TYPE:\r\nif (!nv_device_is_pci(nvxx_device(device)))\r\ngetparam->value = 3;\r\nelse\r\nif (drm_pci_device_is_agp(dev))\r\ngetparam->value = 0;\r\nelse\r\nif (!pci_is_pcie(dev->pdev))\r\ngetparam->value = 1;\r\nelse\r\ngetparam->value = 2;\r\nbreak;\r\ncase NOUVEAU_GETPARAM_FB_SIZE:\r\ngetparam->value = drm->gem.vram_available;\r\nbreak;\r\ncase NOUVEAU_GETPARAM_AGP_SIZE:\r\ngetparam->value = drm->gem.gart_available;\r\nbreak;\r\ncase NOUVEAU_GETPARAM_VM_VRAM_BASE:\r\ngetparam->value = 0;\r\nbreak;\r\ncase NOUVEAU_GETPARAM_PTIMER_TIME:\r\ngetparam->value = ptimer->read(ptimer);\r\nbreak;\r\ncase NOUVEAU_GETPARAM_HAS_BO_USAGE:\r\ngetparam->value = 1;\r\nbreak;\r\ncase NOUVEAU_GETPARAM_HAS_PAGEFLIP:\r\ngetparam->value = 1;\r\nbreak;\r\ncase NOUVEAU_GETPARAM_GRAPH_UNITS:\r\ngetparam->value = gr->units ? gr->units(gr) : 0;\r\nbreak;\r\ndefault:\r\nNV_PRINTK(debug, cli, "unknown parameter %lld\n", getparam->param);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nint\r\nnouveau_abi16_ioctl_setparam(ABI16_IOCTL_ARGS)\r\n{\r\nreturn -EINVAL;\r\n}\r\nint\r\nnouveau_abi16_ioctl_channel_alloc(ABI16_IOCTL_ARGS)\r\n{\r\nstruct drm_nouveau_channel_alloc *init = data;\r\nstruct nouveau_cli *cli = nouveau_cli(file_priv);\r\nstruct nouveau_drm *drm = nouveau_drm(dev);\r\nstruct nouveau_abi16 *abi16 = nouveau_abi16_get(file_priv, dev);\r\nstruct nouveau_abi16_chan *chan;\r\nstruct nvif_device *device;\r\nint ret;\r\nif (unlikely(!abi16))\r\nreturn -ENOMEM;\r\nif (!drm->channel)\r\nreturn nouveau_abi16_put(abi16, -ENODEV);\r\ndevice = &abi16->device;\r\nif (device->info.family >= NV_DEVICE_INFO_V0_KEPLER) {\r\nif (init->fb_ctxdma_handle != ~0)\r\ninit->fb_ctxdma_handle = KEPLER_CHANNEL_GPFIFO_A_V0_ENGINE_GR;\r\nelse\r\ninit->fb_ctxdma_handle = init->tt_ctxdma_handle;\r\ninit->tt_ctxdma_handle = 0;\r\nif (init->fb_ctxdma_handle == KEPLER_CHANNEL_GPFIFO_A_V0_ENGINE_GR)\r\ninit->tt_ctxdma_handle = 1;\r\n}\r\nif (init->fb_ctxdma_handle == ~0 || init->tt_ctxdma_handle == ~0)\r\nreturn nouveau_abi16_put(abi16, -EINVAL);\r\ninit->channel = __ffs64(~abi16->handles);\r\nif (~abi16->handles == 0)\r\nreturn nouveau_abi16_put(abi16, -ENOSPC);\r\nchan = kzalloc(sizeof(*chan), GFP_KERNEL);\r\nif (!chan)\r\nreturn nouveau_abi16_put(abi16, -ENOMEM);\r\nINIT_LIST_HEAD(&chan->notifiers);\r\nlist_add(&chan->head, &abi16->channels);\r\nabi16->handles |= (1ULL << init->channel);\r\nret = nouveau_channel_new(drm, device,\r\nNOUVEAU_ABI16_CHAN(init->channel),\r\ninit->fb_ctxdma_handle,\r\ninit->tt_ctxdma_handle, &chan->chan);\r\nif (ret)\r\ngoto done;\r\nif (device->info.family >= NV_DEVICE_INFO_V0_TESLA)\r\ninit->pushbuf_domains = NOUVEAU_GEM_DOMAIN_VRAM |\r\nNOUVEAU_GEM_DOMAIN_GART;\r\nelse\r\nif (chan->chan->push.buffer->bo.mem.mem_type == TTM_PL_VRAM)\r\ninit->pushbuf_domains = NOUVEAU_GEM_DOMAIN_VRAM;\r\nelse\r\ninit->pushbuf_domains = NOUVEAU_GEM_DOMAIN_GART;\r\nif (device->info.family < NV_DEVICE_INFO_V0_CELSIUS) {\r\ninit->subchan[0].handle = 0x00000000;\r\ninit->subchan[0].grclass = 0x0000;\r\ninit->subchan[1].handle = chan->chan->nvsw.handle;\r\ninit->subchan[1].grclass = 0x506e;\r\ninit->nr_subchan = 2;\r\n}\r\nret = nouveau_gem_new(dev, PAGE_SIZE, 0, NOUVEAU_GEM_DOMAIN_GART,\r\n0, 0, &chan->ntfy);\r\nif (ret == 0)\r\nret = nouveau_bo_pin(chan->ntfy, TTM_PL_FLAG_TT, false);\r\nif (ret)\r\ngoto done;\r\nif (device->info.family >= NV_DEVICE_INFO_V0_TESLA) {\r\nret = nouveau_bo_vma_add(chan->ntfy, cli->vm,\r\n&chan->ntfy_vma);\r\nif (ret)\r\ngoto done;\r\n}\r\nret = drm_gem_handle_create(file_priv, &chan->ntfy->gem,\r\n&init->notifier_handle);\r\nif (ret)\r\ngoto done;\r\nret = nvkm_mm_init(&chan->heap, 0, PAGE_SIZE, 1);\r\ndone:\r\nif (ret)\r\nnouveau_abi16_chan_fini(abi16, chan);\r\nreturn nouveau_abi16_put(abi16, ret);\r\n}\r\nstatic struct nouveau_abi16_chan *\r\nnouveau_abi16_chan(struct nouveau_abi16 *abi16, int channel)\r\n{\r\nstruct nouveau_abi16_chan *chan;\r\nlist_for_each_entry(chan, &abi16->channels, head) {\r\nif (chan->chan->object->handle == NOUVEAU_ABI16_CHAN(channel))\r\nreturn chan;\r\n}\r\nreturn NULL;\r\n}\r\nint\r\nnouveau_abi16_ioctl_channel_free(ABI16_IOCTL_ARGS)\r\n{\r\nstruct drm_nouveau_channel_free *req = data;\r\nstruct nouveau_abi16 *abi16 = nouveau_abi16_get(file_priv, dev);\r\nstruct nouveau_abi16_chan *chan;\r\nif (unlikely(!abi16))\r\nreturn -ENOMEM;\r\nchan = nouveau_abi16_chan(abi16, req->channel);\r\nif (!chan)\r\nreturn nouveau_abi16_put(abi16, -ENOENT);\r\nnouveau_abi16_chan_fini(abi16, chan);\r\nreturn nouveau_abi16_put(abi16, 0);\r\n}\r\nint\r\nnouveau_abi16_ioctl_grobj_alloc(ABI16_IOCTL_ARGS)\r\n{\r\nstruct drm_nouveau_grobj_alloc *init = data;\r\nstruct {\r\nstruct nvif_ioctl_v0 ioctl;\r\nstruct nvif_ioctl_new_v0 new;\r\n} args = {\r\n.ioctl.owner = NVIF_IOCTL_V0_OWNER_ANY,\r\n.ioctl.type = NVIF_IOCTL_V0_NEW,\r\n.ioctl.path_nr = 3,\r\n.ioctl.path[2] = NOUVEAU_ABI16_CLIENT,\r\n.ioctl.path[1] = NOUVEAU_ABI16_DEVICE,\r\n.ioctl.path[0] = NOUVEAU_ABI16_CHAN(init->channel),\r\n.new.route = NVDRM_OBJECT_ABI16,\r\n.new.handle = init->handle,\r\n.new.oclass = init->class,\r\n};\r\nstruct nouveau_abi16 *abi16 = nouveau_abi16_get(file_priv, dev);\r\nstruct nouveau_drm *drm = nouveau_drm(dev);\r\nstruct nvif_client *client;\r\nint ret;\r\nif (unlikely(!abi16))\r\nreturn -ENOMEM;\r\nif (init->handle == ~0)\r\nreturn nouveau_abi16_put(abi16, -EINVAL);\r\nclient = nvif_client(nvif_object(&abi16->device));\r\nif (init->class == 0x506e) {\r\ninit->class = nouveau_abi16_swclass(drm);\r\nif (init->class == 0x906e)\r\nreturn nouveau_abi16_put(abi16, 0);\r\n}\r\nret = nvif_client_ioctl(client, &args, sizeof(args));\r\nreturn nouveau_abi16_put(abi16, ret);\r\n}\r\nint\r\nnouveau_abi16_ioctl_notifierobj_alloc(ABI16_IOCTL_ARGS)\r\n{\r\nstruct drm_nouveau_notifierobj_alloc *info = data;\r\nstruct {\r\nstruct nvif_ioctl_v0 ioctl;\r\nstruct nvif_ioctl_new_v0 new;\r\nstruct nv_dma_v0 ctxdma;\r\n} args = {\r\n.ioctl.owner = NVIF_IOCTL_V0_OWNER_ANY,\r\n.ioctl.type = NVIF_IOCTL_V0_NEW,\r\n.ioctl.path_nr = 3,\r\n.ioctl.path[2] = NOUVEAU_ABI16_CLIENT,\r\n.ioctl.path[1] = NOUVEAU_ABI16_DEVICE,\r\n.ioctl.path[0] = NOUVEAU_ABI16_CHAN(info->channel),\r\n.new.route = NVDRM_OBJECT_ABI16,\r\n.new.handle = info->handle,\r\n.new.oclass = NV_DMA_IN_MEMORY,\r\n};\r\nstruct nouveau_drm *drm = nouveau_drm(dev);\r\nstruct nouveau_abi16 *abi16 = nouveau_abi16_get(file_priv, dev);\r\nstruct nouveau_abi16_chan *chan;\r\nstruct nouveau_abi16_ntfy *ntfy;\r\nstruct nvif_device *device = &abi16->device;\r\nstruct nvif_client *client;\r\nint ret;\r\nif (unlikely(!abi16))\r\nreturn -ENOMEM;\r\nif (unlikely(device->info.family >= NV_DEVICE_INFO_V0_FERMI))\r\nreturn nouveau_abi16_put(abi16, -EINVAL);\r\nclient = nvif_client(nvif_object(&abi16->device));\r\nchan = nouveau_abi16_chan(abi16, info->channel);\r\nif (!chan)\r\nreturn nouveau_abi16_put(abi16, -ENOENT);\r\nntfy = kzalloc(sizeof(*ntfy), GFP_KERNEL);\r\nif (!ntfy)\r\nreturn nouveau_abi16_put(abi16, -ENOMEM);\r\nlist_add(&ntfy->head, &chan->notifiers);\r\nntfy->handle = info->handle;\r\nret = nvkm_mm_head(&chan->heap, 0, 1, info->size, info->size, 1,\r\n&ntfy->node);\r\nif (ret)\r\ngoto done;\r\nargs.ctxdma.start = ntfy->node->offset;\r\nargs.ctxdma.limit = ntfy->node->offset + ntfy->node->length - 1;\r\nif (device->info.family >= NV_DEVICE_INFO_V0_TESLA) {\r\nargs.ctxdma.target = NV_DMA_V0_TARGET_VM;\r\nargs.ctxdma.access = NV_DMA_V0_ACCESS_VM;\r\nargs.ctxdma.start += chan->ntfy_vma.offset;\r\nargs.ctxdma.limit += chan->ntfy_vma.offset;\r\n} else\r\nif (drm->agp.stat == ENABLED) {\r\nargs.ctxdma.target = NV_DMA_V0_TARGET_AGP;\r\nargs.ctxdma.access = NV_DMA_V0_ACCESS_RDWR;\r\nargs.ctxdma.start += drm->agp.base + chan->ntfy->bo.offset;\r\nargs.ctxdma.limit += drm->agp.base + chan->ntfy->bo.offset;\r\nclient->super = true;\r\n} else {\r\nargs.ctxdma.target = NV_DMA_V0_TARGET_VM;\r\nargs.ctxdma.access = NV_DMA_V0_ACCESS_RDWR;\r\nargs.ctxdma.start += chan->ntfy->bo.offset;\r\nargs.ctxdma.limit += chan->ntfy->bo.offset;\r\n}\r\nret = nvif_client_ioctl(client, &args, sizeof(args));\r\nclient->super = false;\r\nif (ret)\r\ngoto done;\r\ninfo->offset = ntfy->node->offset;\r\ndone:\r\nif (ret)\r\nnouveau_abi16_ntfy_fini(chan, ntfy);\r\nreturn nouveau_abi16_put(abi16, ret);\r\n}\r\nint\r\nnouveau_abi16_ioctl_gpuobj_free(ABI16_IOCTL_ARGS)\r\n{\r\nstruct drm_nouveau_gpuobj_free *fini = data;\r\nstruct {\r\nstruct nvif_ioctl_v0 ioctl;\r\nstruct nvif_ioctl_del del;\r\n} args = {\r\n.ioctl.owner = NVDRM_OBJECT_ABI16,\r\n.ioctl.type = NVIF_IOCTL_V0_DEL,\r\n.ioctl.path_nr = 4,\r\n.ioctl.path[3] = NOUVEAU_ABI16_CLIENT,\r\n.ioctl.path[2] = NOUVEAU_ABI16_DEVICE,\r\n.ioctl.path[1] = NOUVEAU_ABI16_CHAN(fini->channel),\r\n.ioctl.path[0] = fini->handle,\r\n};\r\nstruct nouveau_abi16 *abi16 = nouveau_abi16_get(file_priv, dev);\r\nstruct nouveau_abi16_chan *chan;\r\nstruct nouveau_abi16_ntfy *ntfy;\r\nstruct nvif_client *client;\r\nint ret;\r\nif (unlikely(!abi16))\r\nreturn -ENOMEM;\r\nchan = nouveau_abi16_chan(abi16, fini->channel);\r\nif (!chan)\r\nreturn nouveau_abi16_put(abi16, -ENOENT);\r\nclient = nvif_client(nvif_object(&abi16->device));\r\nnouveau_channel_idle(chan->chan);\r\nret = nvif_client_ioctl(client, &args, sizeof(args));\r\nif (ret)\r\nreturn nouveau_abi16_put(abi16, ret);\r\nlist_for_each_entry(ntfy, &chan->notifiers, head) {\r\nif (ntfy->handle == fini->handle) {\r\nnvkm_mm_free(&chan->heap, &ntfy->node);\r\nlist_del(&ntfy->head);\r\nbreak;\r\n}\r\n}\r\nreturn nouveau_abi16_put(abi16, 0);\r\n}
