static void init_uobj(struct ib_uobject *uobj, u64 user_handle,\r\nstruct ib_ucontext *context, struct uverbs_lock_class *c)\r\n{\r\nuobj->user_handle = user_handle;\r\nuobj->context = context;\r\nkref_init(&uobj->ref);\r\ninit_rwsem(&uobj->mutex);\r\nlockdep_set_class_and_name(&uobj->mutex, &c->key, c->name);\r\nuobj->live = 0;\r\n}\r\nstatic void release_uobj(struct kref *kref)\r\n{\r\nkfree(container_of(kref, struct ib_uobject, ref));\r\n}\r\nstatic void put_uobj(struct ib_uobject *uobj)\r\n{\r\nkref_put(&uobj->ref, release_uobj);\r\n}\r\nstatic void put_uobj_read(struct ib_uobject *uobj)\r\n{\r\nup_read(&uobj->mutex);\r\nput_uobj(uobj);\r\n}\r\nstatic void put_uobj_write(struct ib_uobject *uobj)\r\n{\r\nup_write(&uobj->mutex);\r\nput_uobj(uobj);\r\n}\r\nstatic int idr_add_uobj(struct idr *idr, struct ib_uobject *uobj)\r\n{\r\nint ret;\r\nidr_preload(GFP_KERNEL);\r\nspin_lock(&ib_uverbs_idr_lock);\r\nret = idr_alloc(idr, uobj, 0, 0, GFP_NOWAIT);\r\nif (ret >= 0)\r\nuobj->id = ret;\r\nspin_unlock(&ib_uverbs_idr_lock);\r\nidr_preload_end();\r\nreturn ret < 0 ? ret : 0;\r\n}\r\nvoid idr_remove_uobj(struct idr *idr, struct ib_uobject *uobj)\r\n{\r\nspin_lock(&ib_uverbs_idr_lock);\r\nidr_remove(idr, uobj->id);\r\nspin_unlock(&ib_uverbs_idr_lock);\r\n}\r\nstatic struct ib_uobject *__idr_get_uobj(struct idr *idr, int id,\r\nstruct ib_ucontext *context)\r\n{\r\nstruct ib_uobject *uobj;\r\nspin_lock(&ib_uverbs_idr_lock);\r\nuobj = idr_find(idr, id);\r\nif (uobj) {\r\nif (uobj->context == context)\r\nkref_get(&uobj->ref);\r\nelse\r\nuobj = NULL;\r\n}\r\nspin_unlock(&ib_uverbs_idr_lock);\r\nreturn uobj;\r\n}\r\nstatic struct ib_uobject *idr_read_uobj(struct idr *idr, int id,\r\nstruct ib_ucontext *context, int nested)\r\n{\r\nstruct ib_uobject *uobj;\r\nuobj = __idr_get_uobj(idr, id, context);\r\nif (!uobj)\r\nreturn NULL;\r\nif (nested)\r\ndown_read_nested(&uobj->mutex, SINGLE_DEPTH_NESTING);\r\nelse\r\ndown_read(&uobj->mutex);\r\nif (!uobj->live) {\r\nput_uobj_read(uobj);\r\nreturn NULL;\r\n}\r\nreturn uobj;\r\n}\r\nstatic struct ib_uobject *idr_write_uobj(struct idr *idr, int id,\r\nstruct ib_ucontext *context)\r\n{\r\nstruct ib_uobject *uobj;\r\nuobj = __idr_get_uobj(idr, id, context);\r\nif (!uobj)\r\nreturn NULL;\r\ndown_write(&uobj->mutex);\r\nif (!uobj->live) {\r\nput_uobj_write(uobj);\r\nreturn NULL;\r\n}\r\nreturn uobj;\r\n}\r\nstatic void *idr_read_obj(struct idr *idr, int id, struct ib_ucontext *context,\r\nint nested)\r\n{\r\nstruct ib_uobject *uobj;\r\nuobj = idr_read_uobj(idr, id, context, nested);\r\nreturn uobj ? uobj->object : NULL;\r\n}\r\nstatic struct ib_pd *idr_read_pd(int pd_handle, struct ib_ucontext *context)\r\n{\r\nreturn idr_read_obj(&ib_uverbs_pd_idr, pd_handle, context, 0);\r\n}\r\nstatic void put_pd_read(struct ib_pd *pd)\r\n{\r\nput_uobj_read(pd->uobject);\r\n}\r\nstatic struct ib_cq *idr_read_cq(int cq_handle, struct ib_ucontext *context, int nested)\r\n{\r\nreturn idr_read_obj(&ib_uverbs_cq_idr, cq_handle, context, nested);\r\n}\r\nstatic void put_cq_read(struct ib_cq *cq)\r\n{\r\nput_uobj_read(cq->uobject);\r\n}\r\nstatic struct ib_ah *idr_read_ah(int ah_handle, struct ib_ucontext *context)\r\n{\r\nreturn idr_read_obj(&ib_uverbs_ah_idr, ah_handle, context, 0);\r\n}\r\nstatic void put_ah_read(struct ib_ah *ah)\r\n{\r\nput_uobj_read(ah->uobject);\r\n}\r\nstatic struct ib_qp *idr_read_qp(int qp_handle, struct ib_ucontext *context)\r\n{\r\nreturn idr_read_obj(&ib_uverbs_qp_idr, qp_handle, context, 0);\r\n}\r\nstatic struct ib_qp *idr_write_qp(int qp_handle, struct ib_ucontext *context)\r\n{\r\nstruct ib_uobject *uobj;\r\nuobj = idr_write_uobj(&ib_uverbs_qp_idr, qp_handle, context);\r\nreturn uobj ? uobj->object : NULL;\r\n}\r\nstatic void put_qp_read(struct ib_qp *qp)\r\n{\r\nput_uobj_read(qp->uobject);\r\n}\r\nstatic void put_qp_write(struct ib_qp *qp)\r\n{\r\nput_uobj_write(qp->uobject);\r\n}\r\nstatic struct ib_srq *idr_read_srq(int srq_handle, struct ib_ucontext *context)\r\n{\r\nreturn idr_read_obj(&ib_uverbs_srq_idr, srq_handle, context, 0);\r\n}\r\nstatic void put_srq_read(struct ib_srq *srq)\r\n{\r\nput_uobj_read(srq->uobject);\r\n}\r\nstatic struct ib_xrcd *idr_read_xrcd(int xrcd_handle, struct ib_ucontext *context,\r\nstruct ib_uobject **uobj)\r\n{\r\n*uobj = idr_read_uobj(&ib_uverbs_xrcd_idr, xrcd_handle, context, 0);\r\nreturn *uobj ? (*uobj)->object : NULL;\r\n}\r\nstatic void put_xrcd_read(struct ib_uobject *uobj)\r\n{\r\nput_uobj_read(uobj);\r\n}\r\nssize_t ib_uverbs_get_context(struct ib_uverbs_file *file,\r\nconst char __user *buf,\r\nint in_len, int out_len)\r\n{\r\nstruct ib_uverbs_get_context cmd;\r\nstruct ib_uverbs_get_context_resp resp;\r\nstruct ib_udata udata;\r\nstruct ib_device *ibdev = file->device->ib_dev;\r\n#ifdef CONFIG_INFINIBAND_ON_DEMAND_PAGING\r\nstruct ib_device_attr dev_attr;\r\n#endif\r\nstruct ib_ucontext *ucontext;\r\nstruct file *filp;\r\nint ret;\r\nif (out_len < sizeof resp)\r\nreturn -ENOSPC;\r\nif (copy_from_user(&cmd, buf, sizeof cmd))\r\nreturn -EFAULT;\r\nmutex_lock(&file->mutex);\r\nif (file->ucontext) {\r\nret = -EINVAL;\r\ngoto err;\r\n}\r\nINIT_UDATA(&udata, buf + sizeof cmd,\r\n(unsigned long) cmd.response + sizeof resp,\r\nin_len - sizeof cmd, out_len - sizeof resp);\r\nucontext = ibdev->alloc_ucontext(ibdev, &udata);\r\nif (IS_ERR(ucontext)) {\r\nret = PTR_ERR(ucontext);\r\ngoto err;\r\n}\r\nucontext->device = ibdev;\r\nINIT_LIST_HEAD(&ucontext->pd_list);\r\nINIT_LIST_HEAD(&ucontext->mr_list);\r\nINIT_LIST_HEAD(&ucontext->mw_list);\r\nINIT_LIST_HEAD(&ucontext->cq_list);\r\nINIT_LIST_HEAD(&ucontext->qp_list);\r\nINIT_LIST_HEAD(&ucontext->srq_list);\r\nINIT_LIST_HEAD(&ucontext->ah_list);\r\nINIT_LIST_HEAD(&ucontext->xrcd_list);\r\nINIT_LIST_HEAD(&ucontext->rule_list);\r\nrcu_read_lock();\r\nucontext->tgid = get_task_pid(current->group_leader, PIDTYPE_PID);\r\nrcu_read_unlock();\r\nucontext->closing = 0;\r\n#ifdef CONFIG_INFINIBAND_ON_DEMAND_PAGING\r\nucontext->umem_tree = RB_ROOT;\r\ninit_rwsem(&ucontext->umem_rwsem);\r\nucontext->odp_mrs_count = 0;\r\nINIT_LIST_HEAD(&ucontext->no_private_counters);\r\nret = ib_query_device(ibdev, &dev_attr);\r\nif (ret)\r\ngoto err_free;\r\nif (!(dev_attr.device_cap_flags & IB_DEVICE_ON_DEMAND_PAGING))\r\nucontext->invalidate_range = NULL;\r\n#endif\r\nresp.num_comp_vectors = file->device->num_comp_vectors;\r\nret = get_unused_fd_flags(O_CLOEXEC);\r\nif (ret < 0)\r\ngoto err_free;\r\nresp.async_fd = ret;\r\nfilp = ib_uverbs_alloc_event_file(file, 1);\r\nif (IS_ERR(filp)) {\r\nret = PTR_ERR(filp);\r\ngoto err_fd;\r\n}\r\nif (copy_to_user((void __user *) (unsigned long) cmd.response,\r\n&resp, sizeof resp)) {\r\nret = -EFAULT;\r\ngoto err_file;\r\n}\r\nfile->async_file = filp->private_data;\r\nINIT_IB_EVENT_HANDLER(&file->event_handler, file->device->ib_dev,\r\nib_uverbs_event_handler);\r\nret = ib_register_event_handler(&file->event_handler);\r\nif (ret)\r\ngoto err_file;\r\nkref_get(&file->async_file->ref);\r\nkref_get(&file->ref);\r\nfile->ucontext = ucontext;\r\nfd_install(resp.async_fd, filp);\r\nmutex_unlock(&file->mutex);\r\nreturn in_len;\r\nerr_file:\r\nfput(filp);\r\nerr_fd:\r\nput_unused_fd(resp.async_fd);\r\nerr_free:\r\nput_pid(ucontext->tgid);\r\nibdev->dealloc_ucontext(ucontext);\r\nerr:\r\nmutex_unlock(&file->mutex);\r\nreturn ret;\r\n}\r\nstatic void copy_query_dev_fields(struct ib_uverbs_file *file,\r\nstruct ib_uverbs_query_device_resp *resp,\r\nstruct ib_device_attr *attr)\r\n{\r\nresp->fw_ver = attr->fw_ver;\r\nresp->node_guid = file->device->ib_dev->node_guid;\r\nresp->sys_image_guid = attr->sys_image_guid;\r\nresp->max_mr_size = attr->max_mr_size;\r\nresp->page_size_cap = attr->page_size_cap;\r\nresp->vendor_id = attr->vendor_id;\r\nresp->vendor_part_id = attr->vendor_part_id;\r\nresp->hw_ver = attr->hw_ver;\r\nresp->max_qp = attr->max_qp;\r\nresp->max_qp_wr = attr->max_qp_wr;\r\nresp->device_cap_flags = attr->device_cap_flags;\r\nresp->max_sge = attr->max_sge;\r\nresp->max_sge_rd = attr->max_sge_rd;\r\nresp->max_cq = attr->max_cq;\r\nresp->max_cqe = attr->max_cqe;\r\nresp->max_mr = attr->max_mr;\r\nresp->max_pd = attr->max_pd;\r\nresp->max_qp_rd_atom = attr->max_qp_rd_atom;\r\nresp->max_ee_rd_atom = attr->max_ee_rd_atom;\r\nresp->max_res_rd_atom = attr->max_res_rd_atom;\r\nresp->max_qp_init_rd_atom = attr->max_qp_init_rd_atom;\r\nresp->max_ee_init_rd_atom = attr->max_ee_init_rd_atom;\r\nresp->atomic_cap = attr->atomic_cap;\r\nresp->max_ee = attr->max_ee;\r\nresp->max_rdd = attr->max_rdd;\r\nresp->max_mw = attr->max_mw;\r\nresp->max_raw_ipv6_qp = attr->max_raw_ipv6_qp;\r\nresp->max_raw_ethy_qp = attr->max_raw_ethy_qp;\r\nresp->max_mcast_grp = attr->max_mcast_grp;\r\nresp->max_mcast_qp_attach = attr->max_mcast_qp_attach;\r\nresp->max_total_mcast_qp_attach = attr->max_total_mcast_qp_attach;\r\nresp->max_ah = attr->max_ah;\r\nresp->max_fmr = attr->max_fmr;\r\nresp->max_map_per_fmr = attr->max_map_per_fmr;\r\nresp->max_srq = attr->max_srq;\r\nresp->max_srq_wr = attr->max_srq_wr;\r\nresp->max_srq_sge = attr->max_srq_sge;\r\nresp->max_pkeys = attr->max_pkeys;\r\nresp->local_ca_ack_delay = attr->local_ca_ack_delay;\r\nresp->phys_port_cnt = file->device->ib_dev->phys_port_cnt;\r\n}\r\nssize_t ib_uverbs_query_device(struct ib_uverbs_file *file,\r\nconst char __user *buf,\r\nint in_len, int out_len)\r\n{\r\nstruct ib_uverbs_query_device cmd;\r\nstruct ib_uverbs_query_device_resp resp;\r\nstruct ib_device_attr attr;\r\nint ret;\r\nif (out_len < sizeof resp)\r\nreturn -ENOSPC;\r\nif (copy_from_user(&cmd, buf, sizeof cmd))\r\nreturn -EFAULT;\r\nret = ib_query_device(file->device->ib_dev, &attr);\r\nif (ret)\r\nreturn ret;\r\nmemset(&resp, 0, sizeof resp);\r\ncopy_query_dev_fields(file, &resp, &attr);\r\nif (copy_to_user((void __user *) (unsigned long) cmd.response,\r\n&resp, sizeof resp))\r\nreturn -EFAULT;\r\nreturn in_len;\r\n}\r\nssize_t ib_uverbs_query_port(struct ib_uverbs_file *file,\r\nconst char __user *buf,\r\nint in_len, int out_len)\r\n{\r\nstruct ib_uverbs_query_port cmd;\r\nstruct ib_uverbs_query_port_resp resp;\r\nstruct ib_port_attr attr;\r\nint ret;\r\nif (out_len < sizeof resp)\r\nreturn -ENOSPC;\r\nif (copy_from_user(&cmd, buf, sizeof cmd))\r\nreturn -EFAULT;\r\nret = ib_query_port(file->device->ib_dev, cmd.port_num, &attr);\r\nif (ret)\r\nreturn ret;\r\nmemset(&resp, 0, sizeof resp);\r\nresp.state = attr.state;\r\nresp.max_mtu = attr.max_mtu;\r\nresp.active_mtu = attr.active_mtu;\r\nresp.gid_tbl_len = attr.gid_tbl_len;\r\nresp.port_cap_flags = attr.port_cap_flags;\r\nresp.max_msg_sz = attr.max_msg_sz;\r\nresp.bad_pkey_cntr = attr.bad_pkey_cntr;\r\nresp.qkey_viol_cntr = attr.qkey_viol_cntr;\r\nresp.pkey_tbl_len = attr.pkey_tbl_len;\r\nresp.lid = attr.lid;\r\nresp.sm_lid = attr.sm_lid;\r\nresp.lmc = attr.lmc;\r\nresp.max_vl_num = attr.max_vl_num;\r\nresp.sm_sl = attr.sm_sl;\r\nresp.subnet_timeout = attr.subnet_timeout;\r\nresp.init_type_reply = attr.init_type_reply;\r\nresp.active_width = attr.active_width;\r\nresp.active_speed = attr.active_speed;\r\nresp.phys_state = attr.phys_state;\r\nresp.link_layer = rdma_port_get_link_layer(file->device->ib_dev,\r\ncmd.port_num);\r\nif (copy_to_user((void __user *) (unsigned long) cmd.response,\r\n&resp, sizeof resp))\r\nreturn -EFAULT;\r\nreturn in_len;\r\n}\r\nssize_t ib_uverbs_alloc_pd(struct ib_uverbs_file *file,\r\nconst char __user *buf,\r\nint in_len, int out_len)\r\n{\r\nstruct ib_uverbs_alloc_pd cmd;\r\nstruct ib_uverbs_alloc_pd_resp resp;\r\nstruct ib_udata udata;\r\nstruct ib_uobject *uobj;\r\nstruct ib_pd *pd;\r\nint ret;\r\nif (out_len < sizeof resp)\r\nreturn -ENOSPC;\r\nif (copy_from_user(&cmd, buf, sizeof cmd))\r\nreturn -EFAULT;\r\nINIT_UDATA(&udata, buf + sizeof cmd,\r\n(unsigned long) cmd.response + sizeof resp,\r\nin_len - sizeof cmd, out_len - sizeof resp);\r\nuobj = kmalloc(sizeof *uobj, GFP_KERNEL);\r\nif (!uobj)\r\nreturn -ENOMEM;\r\ninit_uobj(uobj, 0, file->ucontext, &pd_lock_class);\r\ndown_write(&uobj->mutex);\r\npd = file->device->ib_dev->alloc_pd(file->device->ib_dev,\r\nfile->ucontext, &udata);\r\nif (IS_ERR(pd)) {\r\nret = PTR_ERR(pd);\r\ngoto err;\r\n}\r\npd->device = file->device->ib_dev;\r\npd->uobject = uobj;\r\natomic_set(&pd->usecnt, 0);\r\nuobj->object = pd;\r\nret = idr_add_uobj(&ib_uverbs_pd_idr, uobj);\r\nif (ret)\r\ngoto err_idr;\r\nmemset(&resp, 0, sizeof resp);\r\nresp.pd_handle = uobj->id;\r\nif (copy_to_user((void __user *) (unsigned long) cmd.response,\r\n&resp, sizeof resp)) {\r\nret = -EFAULT;\r\ngoto err_copy;\r\n}\r\nmutex_lock(&file->mutex);\r\nlist_add_tail(&uobj->list, &file->ucontext->pd_list);\r\nmutex_unlock(&file->mutex);\r\nuobj->live = 1;\r\nup_write(&uobj->mutex);\r\nreturn in_len;\r\nerr_copy:\r\nidr_remove_uobj(&ib_uverbs_pd_idr, uobj);\r\nerr_idr:\r\nib_dealloc_pd(pd);\r\nerr:\r\nput_uobj_write(uobj);\r\nreturn ret;\r\n}\r\nssize_t ib_uverbs_dealloc_pd(struct ib_uverbs_file *file,\r\nconst char __user *buf,\r\nint in_len, int out_len)\r\n{\r\nstruct ib_uverbs_dealloc_pd cmd;\r\nstruct ib_uobject *uobj;\r\nint ret;\r\nif (copy_from_user(&cmd, buf, sizeof cmd))\r\nreturn -EFAULT;\r\nuobj = idr_write_uobj(&ib_uverbs_pd_idr, cmd.pd_handle, file->ucontext);\r\nif (!uobj)\r\nreturn -EINVAL;\r\nret = ib_dealloc_pd(uobj->object);\r\nif (!ret)\r\nuobj->live = 0;\r\nput_uobj_write(uobj);\r\nif (ret)\r\nreturn ret;\r\nidr_remove_uobj(&ib_uverbs_pd_idr, uobj);\r\nmutex_lock(&file->mutex);\r\nlist_del(&uobj->list);\r\nmutex_unlock(&file->mutex);\r\nput_uobj(uobj);\r\nreturn in_len;\r\n}\r\nstatic int xrcd_table_insert(struct ib_uverbs_device *dev,\r\nstruct inode *inode,\r\nstruct ib_xrcd *xrcd)\r\n{\r\nstruct xrcd_table_entry *entry, *scan;\r\nstruct rb_node **p = &dev->xrcd_tree.rb_node;\r\nstruct rb_node *parent = NULL;\r\nentry = kmalloc(sizeof *entry, GFP_KERNEL);\r\nif (!entry)\r\nreturn -ENOMEM;\r\nentry->xrcd = xrcd;\r\nentry->inode = inode;\r\nwhile (*p) {\r\nparent = *p;\r\nscan = rb_entry(parent, struct xrcd_table_entry, node);\r\nif (inode < scan->inode) {\r\np = &(*p)->rb_left;\r\n} else if (inode > scan->inode) {\r\np = &(*p)->rb_right;\r\n} else {\r\nkfree(entry);\r\nreturn -EEXIST;\r\n}\r\n}\r\nrb_link_node(&entry->node, parent, p);\r\nrb_insert_color(&entry->node, &dev->xrcd_tree);\r\nigrab(inode);\r\nreturn 0;\r\n}\r\nstatic struct xrcd_table_entry *xrcd_table_search(struct ib_uverbs_device *dev,\r\nstruct inode *inode)\r\n{\r\nstruct xrcd_table_entry *entry;\r\nstruct rb_node *p = dev->xrcd_tree.rb_node;\r\nwhile (p) {\r\nentry = rb_entry(p, struct xrcd_table_entry, node);\r\nif (inode < entry->inode)\r\np = p->rb_left;\r\nelse if (inode > entry->inode)\r\np = p->rb_right;\r\nelse\r\nreturn entry;\r\n}\r\nreturn NULL;\r\n}\r\nstatic struct ib_xrcd *find_xrcd(struct ib_uverbs_device *dev, struct inode *inode)\r\n{\r\nstruct xrcd_table_entry *entry;\r\nentry = xrcd_table_search(dev, inode);\r\nif (!entry)\r\nreturn NULL;\r\nreturn entry->xrcd;\r\n}\r\nstatic void xrcd_table_delete(struct ib_uverbs_device *dev,\r\nstruct inode *inode)\r\n{\r\nstruct xrcd_table_entry *entry;\r\nentry = xrcd_table_search(dev, inode);\r\nif (entry) {\r\niput(inode);\r\nrb_erase(&entry->node, &dev->xrcd_tree);\r\nkfree(entry);\r\n}\r\n}\r\nssize_t ib_uverbs_open_xrcd(struct ib_uverbs_file *file,\r\nconst char __user *buf, int in_len,\r\nint out_len)\r\n{\r\nstruct ib_uverbs_open_xrcd cmd;\r\nstruct ib_uverbs_open_xrcd_resp resp;\r\nstruct ib_udata udata;\r\nstruct ib_uxrcd_object *obj;\r\nstruct ib_xrcd *xrcd = NULL;\r\nstruct fd f = {NULL, 0};\r\nstruct inode *inode = NULL;\r\nint ret = 0;\r\nint new_xrcd = 0;\r\nif (out_len < sizeof resp)\r\nreturn -ENOSPC;\r\nif (copy_from_user(&cmd, buf, sizeof cmd))\r\nreturn -EFAULT;\r\nINIT_UDATA(&udata, buf + sizeof cmd,\r\n(unsigned long) cmd.response + sizeof resp,\r\nin_len - sizeof cmd, out_len - sizeof resp);\r\nmutex_lock(&file->device->xrcd_tree_mutex);\r\nif (cmd.fd != -1) {\r\nf = fdget(cmd.fd);\r\nif (!f.file) {\r\nret = -EBADF;\r\ngoto err_tree_mutex_unlock;\r\n}\r\ninode = file_inode(f.file);\r\nxrcd = find_xrcd(file->device, inode);\r\nif (!xrcd && !(cmd.oflags & O_CREAT)) {\r\nret = -EAGAIN;\r\ngoto err_tree_mutex_unlock;\r\n}\r\nif (xrcd && cmd.oflags & O_EXCL) {\r\nret = -EINVAL;\r\ngoto err_tree_mutex_unlock;\r\n}\r\n}\r\nobj = kmalloc(sizeof *obj, GFP_KERNEL);\r\nif (!obj) {\r\nret = -ENOMEM;\r\ngoto err_tree_mutex_unlock;\r\n}\r\ninit_uobj(&obj->uobject, 0, file->ucontext, &xrcd_lock_class);\r\ndown_write(&obj->uobject.mutex);\r\nif (!xrcd) {\r\nxrcd = file->device->ib_dev->alloc_xrcd(file->device->ib_dev,\r\nfile->ucontext, &udata);\r\nif (IS_ERR(xrcd)) {\r\nret = PTR_ERR(xrcd);\r\ngoto err;\r\n}\r\nxrcd->inode = inode;\r\nxrcd->device = file->device->ib_dev;\r\natomic_set(&xrcd->usecnt, 0);\r\nmutex_init(&xrcd->tgt_qp_mutex);\r\nINIT_LIST_HEAD(&xrcd->tgt_qp_list);\r\nnew_xrcd = 1;\r\n}\r\natomic_set(&obj->refcnt, 0);\r\nobj->uobject.object = xrcd;\r\nret = idr_add_uobj(&ib_uverbs_xrcd_idr, &obj->uobject);\r\nif (ret)\r\ngoto err_idr;\r\nmemset(&resp, 0, sizeof resp);\r\nresp.xrcd_handle = obj->uobject.id;\r\nif (inode) {\r\nif (new_xrcd) {\r\nret = xrcd_table_insert(file->device, inode, xrcd);\r\nif (ret)\r\ngoto err_insert_xrcd;\r\n}\r\natomic_inc(&xrcd->usecnt);\r\n}\r\nif (copy_to_user((void __user *) (unsigned long) cmd.response,\r\n&resp, sizeof resp)) {\r\nret = -EFAULT;\r\ngoto err_copy;\r\n}\r\nif (f.file)\r\nfdput(f);\r\nmutex_lock(&file->mutex);\r\nlist_add_tail(&obj->uobject.list, &file->ucontext->xrcd_list);\r\nmutex_unlock(&file->mutex);\r\nobj->uobject.live = 1;\r\nup_write(&obj->uobject.mutex);\r\nmutex_unlock(&file->device->xrcd_tree_mutex);\r\nreturn in_len;\r\nerr_copy:\r\nif (inode) {\r\nif (new_xrcd)\r\nxrcd_table_delete(file->device, inode);\r\natomic_dec(&xrcd->usecnt);\r\n}\r\nerr_insert_xrcd:\r\nidr_remove_uobj(&ib_uverbs_xrcd_idr, &obj->uobject);\r\nerr_idr:\r\nib_dealloc_xrcd(xrcd);\r\nerr:\r\nput_uobj_write(&obj->uobject);\r\nerr_tree_mutex_unlock:\r\nif (f.file)\r\nfdput(f);\r\nmutex_unlock(&file->device->xrcd_tree_mutex);\r\nreturn ret;\r\n}\r\nssize_t ib_uverbs_close_xrcd(struct ib_uverbs_file *file,\r\nconst char __user *buf, int in_len,\r\nint out_len)\r\n{\r\nstruct ib_uverbs_close_xrcd cmd;\r\nstruct ib_uobject *uobj;\r\nstruct ib_xrcd *xrcd = NULL;\r\nstruct inode *inode = NULL;\r\nstruct ib_uxrcd_object *obj;\r\nint live;\r\nint ret = 0;\r\nif (copy_from_user(&cmd, buf, sizeof cmd))\r\nreturn -EFAULT;\r\nmutex_lock(&file->device->xrcd_tree_mutex);\r\nuobj = idr_write_uobj(&ib_uverbs_xrcd_idr, cmd.xrcd_handle, file->ucontext);\r\nif (!uobj) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nxrcd = uobj->object;\r\ninode = xrcd->inode;\r\nobj = container_of(uobj, struct ib_uxrcd_object, uobject);\r\nif (atomic_read(&obj->refcnt)) {\r\nput_uobj_write(uobj);\r\nret = -EBUSY;\r\ngoto out;\r\n}\r\nif (!inode || atomic_dec_and_test(&xrcd->usecnt)) {\r\nret = ib_dealloc_xrcd(uobj->object);\r\nif (!ret)\r\nuobj->live = 0;\r\n}\r\nlive = uobj->live;\r\nif (inode && ret)\r\natomic_inc(&xrcd->usecnt);\r\nput_uobj_write(uobj);\r\nif (ret)\r\ngoto out;\r\nif (inode && !live)\r\nxrcd_table_delete(file->device, inode);\r\nidr_remove_uobj(&ib_uverbs_xrcd_idr, uobj);\r\nmutex_lock(&file->mutex);\r\nlist_del(&uobj->list);\r\nmutex_unlock(&file->mutex);\r\nput_uobj(uobj);\r\nret = in_len;\r\nout:\r\nmutex_unlock(&file->device->xrcd_tree_mutex);\r\nreturn ret;\r\n}\r\nvoid ib_uverbs_dealloc_xrcd(struct ib_uverbs_device *dev,\r\nstruct ib_xrcd *xrcd)\r\n{\r\nstruct inode *inode;\r\ninode = xrcd->inode;\r\nif (inode && !atomic_dec_and_test(&xrcd->usecnt))\r\nreturn;\r\nib_dealloc_xrcd(xrcd);\r\nif (inode)\r\nxrcd_table_delete(dev, inode);\r\n}\r\nssize_t ib_uverbs_reg_mr(struct ib_uverbs_file *file,\r\nconst char __user *buf, int in_len,\r\nint out_len)\r\n{\r\nstruct ib_uverbs_reg_mr cmd;\r\nstruct ib_uverbs_reg_mr_resp resp;\r\nstruct ib_udata udata;\r\nstruct ib_uobject *uobj;\r\nstruct ib_pd *pd;\r\nstruct ib_mr *mr;\r\nint ret;\r\nif (out_len < sizeof resp)\r\nreturn -ENOSPC;\r\nif (copy_from_user(&cmd, buf, sizeof cmd))\r\nreturn -EFAULT;\r\nINIT_UDATA(&udata, buf + sizeof cmd,\r\n(unsigned long) cmd.response + sizeof resp,\r\nin_len - sizeof cmd, out_len - sizeof resp);\r\nif ((cmd.start & ~PAGE_MASK) != (cmd.hca_va & ~PAGE_MASK))\r\nreturn -EINVAL;\r\nret = ib_check_mr_access(cmd.access_flags);\r\nif (ret)\r\nreturn ret;\r\nuobj = kmalloc(sizeof *uobj, GFP_KERNEL);\r\nif (!uobj)\r\nreturn -ENOMEM;\r\ninit_uobj(uobj, 0, file->ucontext, &mr_lock_class);\r\ndown_write(&uobj->mutex);\r\npd = idr_read_pd(cmd.pd_handle, file->ucontext);\r\nif (!pd) {\r\nret = -EINVAL;\r\ngoto err_free;\r\n}\r\nif (cmd.access_flags & IB_ACCESS_ON_DEMAND) {\r\nstruct ib_device_attr attr;\r\nret = ib_query_device(pd->device, &attr);\r\nif (ret || !(attr.device_cap_flags &\r\nIB_DEVICE_ON_DEMAND_PAGING)) {\r\npr_debug("ODP support not available\n");\r\nret = -EINVAL;\r\ngoto err_put;\r\n}\r\n}\r\nmr = pd->device->reg_user_mr(pd, cmd.start, cmd.length, cmd.hca_va,\r\ncmd.access_flags, &udata);\r\nif (IS_ERR(mr)) {\r\nret = PTR_ERR(mr);\r\ngoto err_put;\r\n}\r\nmr->device = pd->device;\r\nmr->pd = pd;\r\nmr->uobject = uobj;\r\natomic_inc(&pd->usecnt);\r\natomic_set(&mr->usecnt, 0);\r\nuobj->object = mr;\r\nret = idr_add_uobj(&ib_uverbs_mr_idr, uobj);\r\nif (ret)\r\ngoto err_unreg;\r\nmemset(&resp, 0, sizeof resp);\r\nresp.lkey = mr->lkey;\r\nresp.rkey = mr->rkey;\r\nresp.mr_handle = uobj->id;\r\nif (copy_to_user((void __user *) (unsigned long) cmd.response,\r\n&resp, sizeof resp)) {\r\nret = -EFAULT;\r\ngoto err_copy;\r\n}\r\nput_pd_read(pd);\r\nmutex_lock(&file->mutex);\r\nlist_add_tail(&uobj->list, &file->ucontext->mr_list);\r\nmutex_unlock(&file->mutex);\r\nuobj->live = 1;\r\nup_write(&uobj->mutex);\r\nreturn in_len;\r\nerr_copy:\r\nidr_remove_uobj(&ib_uverbs_mr_idr, uobj);\r\nerr_unreg:\r\nib_dereg_mr(mr);\r\nerr_put:\r\nput_pd_read(pd);\r\nerr_free:\r\nput_uobj_write(uobj);\r\nreturn ret;\r\n}\r\nssize_t ib_uverbs_rereg_mr(struct ib_uverbs_file *file,\r\nconst char __user *buf, int in_len,\r\nint out_len)\r\n{\r\nstruct ib_uverbs_rereg_mr cmd;\r\nstruct ib_uverbs_rereg_mr_resp resp;\r\nstruct ib_udata udata;\r\nstruct ib_pd *pd = NULL;\r\nstruct ib_mr *mr;\r\nstruct ib_pd *old_pd;\r\nint ret;\r\nstruct ib_uobject *uobj;\r\nif (out_len < sizeof(resp))\r\nreturn -ENOSPC;\r\nif (copy_from_user(&cmd, buf, sizeof(cmd)))\r\nreturn -EFAULT;\r\nINIT_UDATA(&udata, buf + sizeof(cmd),\r\n(unsigned long) cmd.response + sizeof(resp),\r\nin_len - sizeof(cmd), out_len - sizeof(resp));\r\nif (cmd.flags & ~IB_MR_REREG_SUPPORTED || !cmd.flags)\r\nreturn -EINVAL;\r\nif ((cmd.flags & IB_MR_REREG_TRANS) &&\r\n(!cmd.start || !cmd.hca_va || 0 >= cmd.length ||\r\n(cmd.start & ~PAGE_MASK) != (cmd.hca_va & ~PAGE_MASK)))\r\nreturn -EINVAL;\r\nuobj = idr_write_uobj(&ib_uverbs_mr_idr, cmd.mr_handle,\r\nfile->ucontext);\r\nif (!uobj)\r\nreturn -EINVAL;\r\nmr = uobj->object;\r\nif (cmd.flags & IB_MR_REREG_ACCESS) {\r\nret = ib_check_mr_access(cmd.access_flags);\r\nif (ret)\r\ngoto put_uobjs;\r\n}\r\nif (cmd.flags & IB_MR_REREG_PD) {\r\npd = idr_read_pd(cmd.pd_handle, file->ucontext);\r\nif (!pd) {\r\nret = -EINVAL;\r\ngoto put_uobjs;\r\n}\r\n}\r\nif (atomic_read(&mr->usecnt)) {\r\nret = -EBUSY;\r\ngoto put_uobj_pd;\r\n}\r\nold_pd = mr->pd;\r\nret = mr->device->rereg_user_mr(mr, cmd.flags, cmd.start,\r\ncmd.length, cmd.hca_va,\r\ncmd.access_flags, pd, &udata);\r\nif (!ret) {\r\nif (cmd.flags & IB_MR_REREG_PD) {\r\natomic_inc(&pd->usecnt);\r\nmr->pd = pd;\r\natomic_dec(&old_pd->usecnt);\r\n}\r\n} else {\r\ngoto put_uobj_pd;\r\n}\r\nmemset(&resp, 0, sizeof(resp));\r\nresp.lkey = mr->lkey;\r\nresp.rkey = mr->rkey;\r\nif (copy_to_user((void __user *)(unsigned long)cmd.response,\r\n&resp, sizeof(resp)))\r\nret = -EFAULT;\r\nelse\r\nret = in_len;\r\nput_uobj_pd:\r\nif (cmd.flags & IB_MR_REREG_PD)\r\nput_pd_read(pd);\r\nput_uobjs:\r\nput_uobj_write(mr->uobject);\r\nreturn ret;\r\n}\r\nssize_t ib_uverbs_dereg_mr(struct ib_uverbs_file *file,\r\nconst char __user *buf, int in_len,\r\nint out_len)\r\n{\r\nstruct ib_uverbs_dereg_mr cmd;\r\nstruct ib_mr *mr;\r\nstruct ib_uobject *uobj;\r\nint ret = -EINVAL;\r\nif (copy_from_user(&cmd, buf, sizeof cmd))\r\nreturn -EFAULT;\r\nuobj = idr_write_uobj(&ib_uverbs_mr_idr, cmd.mr_handle, file->ucontext);\r\nif (!uobj)\r\nreturn -EINVAL;\r\nmr = uobj->object;\r\nret = ib_dereg_mr(mr);\r\nif (!ret)\r\nuobj->live = 0;\r\nput_uobj_write(uobj);\r\nif (ret)\r\nreturn ret;\r\nidr_remove_uobj(&ib_uverbs_mr_idr, uobj);\r\nmutex_lock(&file->mutex);\r\nlist_del(&uobj->list);\r\nmutex_unlock(&file->mutex);\r\nput_uobj(uobj);\r\nreturn in_len;\r\n}\r\nssize_t ib_uverbs_alloc_mw(struct ib_uverbs_file *file,\r\nconst char __user *buf, int in_len,\r\nint out_len)\r\n{\r\nstruct ib_uverbs_alloc_mw cmd;\r\nstruct ib_uverbs_alloc_mw_resp resp;\r\nstruct ib_uobject *uobj;\r\nstruct ib_pd *pd;\r\nstruct ib_mw *mw;\r\nint ret;\r\nif (out_len < sizeof(resp))\r\nreturn -ENOSPC;\r\nif (copy_from_user(&cmd, buf, sizeof(cmd)))\r\nreturn -EFAULT;\r\nuobj = kmalloc(sizeof(*uobj), GFP_KERNEL);\r\nif (!uobj)\r\nreturn -ENOMEM;\r\ninit_uobj(uobj, 0, file->ucontext, &mw_lock_class);\r\ndown_write(&uobj->mutex);\r\npd = idr_read_pd(cmd.pd_handle, file->ucontext);\r\nif (!pd) {\r\nret = -EINVAL;\r\ngoto err_free;\r\n}\r\nmw = pd->device->alloc_mw(pd, cmd.mw_type);\r\nif (IS_ERR(mw)) {\r\nret = PTR_ERR(mw);\r\ngoto err_put;\r\n}\r\nmw->device = pd->device;\r\nmw->pd = pd;\r\nmw->uobject = uobj;\r\natomic_inc(&pd->usecnt);\r\nuobj->object = mw;\r\nret = idr_add_uobj(&ib_uverbs_mw_idr, uobj);\r\nif (ret)\r\ngoto err_unalloc;\r\nmemset(&resp, 0, sizeof(resp));\r\nresp.rkey = mw->rkey;\r\nresp.mw_handle = uobj->id;\r\nif (copy_to_user((void __user *)(unsigned long)cmd.response,\r\n&resp, sizeof(resp))) {\r\nret = -EFAULT;\r\ngoto err_copy;\r\n}\r\nput_pd_read(pd);\r\nmutex_lock(&file->mutex);\r\nlist_add_tail(&uobj->list, &file->ucontext->mw_list);\r\nmutex_unlock(&file->mutex);\r\nuobj->live = 1;\r\nup_write(&uobj->mutex);\r\nreturn in_len;\r\nerr_copy:\r\nidr_remove_uobj(&ib_uverbs_mw_idr, uobj);\r\nerr_unalloc:\r\nib_dealloc_mw(mw);\r\nerr_put:\r\nput_pd_read(pd);\r\nerr_free:\r\nput_uobj_write(uobj);\r\nreturn ret;\r\n}\r\nssize_t ib_uverbs_dealloc_mw(struct ib_uverbs_file *file,\r\nconst char __user *buf, int in_len,\r\nint out_len)\r\n{\r\nstruct ib_uverbs_dealloc_mw cmd;\r\nstruct ib_mw *mw;\r\nstruct ib_uobject *uobj;\r\nint ret = -EINVAL;\r\nif (copy_from_user(&cmd, buf, sizeof(cmd)))\r\nreturn -EFAULT;\r\nuobj = idr_write_uobj(&ib_uverbs_mw_idr, cmd.mw_handle, file->ucontext);\r\nif (!uobj)\r\nreturn -EINVAL;\r\nmw = uobj->object;\r\nret = ib_dealloc_mw(mw);\r\nif (!ret)\r\nuobj->live = 0;\r\nput_uobj_write(uobj);\r\nif (ret)\r\nreturn ret;\r\nidr_remove_uobj(&ib_uverbs_mw_idr, uobj);\r\nmutex_lock(&file->mutex);\r\nlist_del(&uobj->list);\r\nmutex_unlock(&file->mutex);\r\nput_uobj(uobj);\r\nreturn in_len;\r\n}\r\nssize_t ib_uverbs_create_comp_channel(struct ib_uverbs_file *file,\r\nconst char __user *buf, int in_len,\r\nint out_len)\r\n{\r\nstruct ib_uverbs_create_comp_channel cmd;\r\nstruct ib_uverbs_create_comp_channel_resp resp;\r\nstruct file *filp;\r\nint ret;\r\nif (out_len < sizeof resp)\r\nreturn -ENOSPC;\r\nif (copy_from_user(&cmd, buf, sizeof cmd))\r\nreturn -EFAULT;\r\nret = get_unused_fd_flags(O_CLOEXEC);\r\nif (ret < 0)\r\nreturn ret;\r\nresp.fd = ret;\r\nfilp = ib_uverbs_alloc_event_file(file, 0);\r\nif (IS_ERR(filp)) {\r\nput_unused_fd(resp.fd);\r\nreturn PTR_ERR(filp);\r\n}\r\nif (copy_to_user((void __user *) (unsigned long) cmd.response,\r\n&resp, sizeof resp)) {\r\nput_unused_fd(resp.fd);\r\nfput(filp);\r\nreturn -EFAULT;\r\n}\r\nfd_install(resp.fd, filp);\r\nreturn in_len;\r\n}\r\nssize_t ib_uverbs_create_cq(struct ib_uverbs_file *file,\r\nconst char __user *buf, int in_len,\r\nint out_len)\r\n{\r\nstruct ib_uverbs_create_cq cmd;\r\nstruct ib_uverbs_create_cq_resp resp;\r\nstruct ib_udata udata;\r\nstruct ib_ucq_object *obj;\r\nstruct ib_uverbs_event_file *ev_file = NULL;\r\nstruct ib_cq *cq;\r\nint ret;\r\nif (out_len < sizeof resp)\r\nreturn -ENOSPC;\r\nif (copy_from_user(&cmd, buf, sizeof cmd))\r\nreturn -EFAULT;\r\nINIT_UDATA(&udata, buf + sizeof cmd,\r\n(unsigned long) cmd.response + sizeof resp,\r\nin_len - sizeof cmd, out_len - sizeof resp);\r\nif (cmd.comp_vector >= file->device->num_comp_vectors)\r\nreturn -EINVAL;\r\nobj = kmalloc(sizeof *obj, GFP_KERNEL);\r\nif (!obj)\r\nreturn -ENOMEM;\r\ninit_uobj(&obj->uobject, cmd.user_handle, file->ucontext, &cq_lock_class);\r\ndown_write(&obj->uobject.mutex);\r\nif (cmd.comp_channel >= 0) {\r\nev_file = ib_uverbs_lookup_comp_file(cmd.comp_channel);\r\nif (!ev_file) {\r\nret = -EINVAL;\r\ngoto err;\r\n}\r\n}\r\nobj->uverbs_file = file;\r\nobj->comp_events_reported = 0;\r\nobj->async_events_reported = 0;\r\nINIT_LIST_HEAD(&obj->comp_list);\r\nINIT_LIST_HEAD(&obj->async_list);\r\ncq = file->device->ib_dev->create_cq(file->device->ib_dev, cmd.cqe,\r\ncmd.comp_vector,\r\nfile->ucontext, &udata);\r\nif (IS_ERR(cq)) {\r\nret = PTR_ERR(cq);\r\ngoto err_file;\r\n}\r\ncq->device = file->device->ib_dev;\r\ncq->uobject = &obj->uobject;\r\ncq->comp_handler = ib_uverbs_comp_handler;\r\ncq->event_handler = ib_uverbs_cq_event_handler;\r\ncq->cq_context = ev_file;\r\natomic_set(&cq->usecnt, 0);\r\nobj->uobject.object = cq;\r\nret = idr_add_uobj(&ib_uverbs_cq_idr, &obj->uobject);\r\nif (ret)\r\ngoto err_free;\r\nmemset(&resp, 0, sizeof resp);\r\nresp.cq_handle = obj->uobject.id;\r\nresp.cqe = cq->cqe;\r\nif (copy_to_user((void __user *) (unsigned long) cmd.response,\r\n&resp, sizeof resp)) {\r\nret = -EFAULT;\r\ngoto err_copy;\r\n}\r\nmutex_lock(&file->mutex);\r\nlist_add_tail(&obj->uobject.list, &file->ucontext->cq_list);\r\nmutex_unlock(&file->mutex);\r\nobj->uobject.live = 1;\r\nup_write(&obj->uobject.mutex);\r\nreturn in_len;\r\nerr_copy:\r\nidr_remove_uobj(&ib_uverbs_cq_idr, &obj->uobject);\r\nerr_free:\r\nib_destroy_cq(cq);\r\nerr_file:\r\nif (ev_file)\r\nib_uverbs_release_ucq(file, ev_file, obj);\r\nerr:\r\nput_uobj_write(&obj->uobject);\r\nreturn ret;\r\n}\r\nssize_t ib_uverbs_resize_cq(struct ib_uverbs_file *file,\r\nconst char __user *buf, int in_len,\r\nint out_len)\r\n{\r\nstruct ib_uverbs_resize_cq cmd;\r\nstruct ib_uverbs_resize_cq_resp resp;\r\nstruct ib_udata udata;\r\nstruct ib_cq *cq;\r\nint ret = -EINVAL;\r\nif (copy_from_user(&cmd, buf, sizeof cmd))\r\nreturn -EFAULT;\r\nINIT_UDATA(&udata, buf + sizeof cmd,\r\n(unsigned long) cmd.response + sizeof resp,\r\nin_len - sizeof cmd, out_len - sizeof resp);\r\ncq = idr_read_cq(cmd.cq_handle, file->ucontext, 0);\r\nif (!cq)\r\nreturn -EINVAL;\r\nret = cq->device->resize_cq(cq, cmd.cqe, &udata);\r\nif (ret)\r\ngoto out;\r\nresp.cqe = cq->cqe;\r\nif (copy_to_user((void __user *) (unsigned long) cmd.response,\r\n&resp, sizeof resp.cqe))\r\nret = -EFAULT;\r\nout:\r\nput_cq_read(cq);\r\nreturn ret ? ret : in_len;\r\n}\r\nstatic int copy_wc_to_user(void __user *dest, struct ib_wc *wc)\r\n{\r\nstruct ib_uverbs_wc tmp;\r\ntmp.wr_id = wc->wr_id;\r\ntmp.status = wc->status;\r\ntmp.opcode = wc->opcode;\r\ntmp.vendor_err = wc->vendor_err;\r\ntmp.byte_len = wc->byte_len;\r\ntmp.ex.imm_data = (__u32 __force) wc->ex.imm_data;\r\ntmp.qp_num = wc->qp->qp_num;\r\ntmp.src_qp = wc->src_qp;\r\ntmp.wc_flags = wc->wc_flags;\r\ntmp.pkey_index = wc->pkey_index;\r\ntmp.slid = wc->slid;\r\ntmp.sl = wc->sl;\r\ntmp.dlid_path_bits = wc->dlid_path_bits;\r\ntmp.port_num = wc->port_num;\r\ntmp.reserved = 0;\r\nif (copy_to_user(dest, &tmp, sizeof tmp))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nssize_t ib_uverbs_poll_cq(struct ib_uverbs_file *file,\r\nconst char __user *buf, int in_len,\r\nint out_len)\r\n{\r\nstruct ib_uverbs_poll_cq cmd;\r\nstruct ib_uverbs_poll_cq_resp resp;\r\nu8 __user *header_ptr;\r\nu8 __user *data_ptr;\r\nstruct ib_cq *cq;\r\nstruct ib_wc wc;\r\nint ret;\r\nif (copy_from_user(&cmd, buf, sizeof cmd))\r\nreturn -EFAULT;\r\ncq = idr_read_cq(cmd.cq_handle, file->ucontext, 0);\r\nif (!cq)\r\nreturn -EINVAL;\r\nheader_ptr = (void __user *)(unsigned long) cmd.response;\r\ndata_ptr = header_ptr + sizeof resp;\r\nmemset(&resp, 0, sizeof resp);\r\nwhile (resp.count < cmd.ne) {\r\nret = ib_poll_cq(cq, 1, &wc);\r\nif (ret < 0)\r\ngoto out_put;\r\nif (!ret)\r\nbreak;\r\nret = copy_wc_to_user(data_ptr, &wc);\r\nif (ret)\r\ngoto out_put;\r\ndata_ptr += sizeof(struct ib_uverbs_wc);\r\n++resp.count;\r\n}\r\nif (copy_to_user(header_ptr, &resp, sizeof resp)) {\r\nret = -EFAULT;\r\ngoto out_put;\r\n}\r\nret = in_len;\r\nout_put:\r\nput_cq_read(cq);\r\nreturn ret;\r\n}\r\nssize_t ib_uverbs_req_notify_cq(struct ib_uverbs_file *file,\r\nconst char __user *buf, int in_len,\r\nint out_len)\r\n{\r\nstruct ib_uverbs_req_notify_cq cmd;\r\nstruct ib_cq *cq;\r\nif (copy_from_user(&cmd, buf, sizeof cmd))\r\nreturn -EFAULT;\r\ncq = idr_read_cq(cmd.cq_handle, file->ucontext, 0);\r\nif (!cq)\r\nreturn -EINVAL;\r\nib_req_notify_cq(cq, cmd.solicited_only ?\r\nIB_CQ_SOLICITED : IB_CQ_NEXT_COMP);\r\nput_cq_read(cq);\r\nreturn in_len;\r\n}\r\nssize_t ib_uverbs_destroy_cq(struct ib_uverbs_file *file,\r\nconst char __user *buf, int in_len,\r\nint out_len)\r\n{\r\nstruct ib_uverbs_destroy_cq cmd;\r\nstruct ib_uverbs_destroy_cq_resp resp;\r\nstruct ib_uobject *uobj;\r\nstruct ib_cq *cq;\r\nstruct ib_ucq_object *obj;\r\nstruct ib_uverbs_event_file *ev_file;\r\nint ret = -EINVAL;\r\nif (copy_from_user(&cmd, buf, sizeof cmd))\r\nreturn -EFAULT;\r\nuobj = idr_write_uobj(&ib_uverbs_cq_idr, cmd.cq_handle, file->ucontext);\r\nif (!uobj)\r\nreturn -EINVAL;\r\ncq = uobj->object;\r\nev_file = cq->cq_context;\r\nobj = container_of(cq->uobject, struct ib_ucq_object, uobject);\r\nret = ib_destroy_cq(cq);\r\nif (!ret)\r\nuobj->live = 0;\r\nput_uobj_write(uobj);\r\nif (ret)\r\nreturn ret;\r\nidr_remove_uobj(&ib_uverbs_cq_idr, uobj);\r\nmutex_lock(&file->mutex);\r\nlist_del(&uobj->list);\r\nmutex_unlock(&file->mutex);\r\nib_uverbs_release_ucq(file, ev_file, obj);\r\nmemset(&resp, 0, sizeof resp);\r\nresp.comp_events_reported = obj->comp_events_reported;\r\nresp.async_events_reported = obj->async_events_reported;\r\nput_uobj(uobj);\r\nif (copy_to_user((void __user *) (unsigned long) cmd.response,\r\n&resp, sizeof resp))\r\nreturn -EFAULT;\r\nreturn in_len;\r\n}\r\nssize_t ib_uverbs_create_qp(struct ib_uverbs_file *file,\r\nconst char __user *buf, int in_len,\r\nint out_len)\r\n{\r\nstruct ib_uverbs_create_qp cmd;\r\nstruct ib_uverbs_create_qp_resp resp;\r\nstruct ib_udata udata;\r\nstruct ib_uqp_object *obj;\r\nstruct ib_device *device;\r\nstruct ib_pd *pd = NULL;\r\nstruct ib_xrcd *xrcd = NULL;\r\nstruct ib_uobject *uninitialized_var(xrcd_uobj);\r\nstruct ib_cq *scq = NULL, *rcq = NULL;\r\nstruct ib_srq *srq = NULL;\r\nstruct ib_qp *qp;\r\nstruct ib_qp_init_attr attr;\r\nint ret;\r\nif (out_len < sizeof resp)\r\nreturn -ENOSPC;\r\nif (copy_from_user(&cmd, buf, sizeof cmd))\r\nreturn -EFAULT;\r\nif (cmd.qp_type == IB_QPT_RAW_PACKET && !capable(CAP_NET_RAW))\r\nreturn -EPERM;\r\nINIT_UDATA(&udata, buf + sizeof cmd,\r\n(unsigned long) cmd.response + sizeof resp,\r\nin_len - sizeof cmd, out_len - sizeof resp);\r\nobj = kzalloc(sizeof *obj, GFP_KERNEL);\r\nif (!obj)\r\nreturn -ENOMEM;\r\ninit_uobj(&obj->uevent.uobject, cmd.user_handle, file->ucontext, &qp_lock_class);\r\ndown_write(&obj->uevent.uobject.mutex);\r\nif (cmd.qp_type == IB_QPT_XRC_TGT) {\r\nxrcd = idr_read_xrcd(cmd.pd_handle, file->ucontext, &xrcd_uobj);\r\nif (!xrcd) {\r\nret = -EINVAL;\r\ngoto err_put;\r\n}\r\ndevice = xrcd->device;\r\n} else {\r\nif (cmd.qp_type == IB_QPT_XRC_INI) {\r\ncmd.max_recv_wr = cmd.max_recv_sge = 0;\r\n} else {\r\nif (cmd.is_srq) {\r\nsrq = idr_read_srq(cmd.srq_handle, file->ucontext);\r\nif (!srq || srq->srq_type != IB_SRQT_BASIC) {\r\nret = -EINVAL;\r\ngoto err_put;\r\n}\r\n}\r\nif (cmd.recv_cq_handle != cmd.send_cq_handle) {\r\nrcq = idr_read_cq(cmd.recv_cq_handle, file->ucontext, 0);\r\nif (!rcq) {\r\nret = -EINVAL;\r\ngoto err_put;\r\n}\r\n}\r\n}\r\nscq = idr_read_cq(cmd.send_cq_handle, file->ucontext, !!rcq);\r\nrcq = rcq ?: scq;\r\npd = idr_read_pd(cmd.pd_handle, file->ucontext);\r\nif (!pd || !scq) {\r\nret = -EINVAL;\r\ngoto err_put;\r\n}\r\ndevice = pd->device;\r\n}\r\nattr.event_handler = ib_uverbs_qp_event_handler;\r\nattr.qp_context = file;\r\nattr.send_cq = scq;\r\nattr.recv_cq = rcq;\r\nattr.srq = srq;\r\nattr.xrcd = xrcd;\r\nattr.sq_sig_type = cmd.sq_sig_all ? IB_SIGNAL_ALL_WR : IB_SIGNAL_REQ_WR;\r\nattr.qp_type = cmd.qp_type;\r\nattr.create_flags = 0;\r\nattr.cap.max_send_wr = cmd.max_send_wr;\r\nattr.cap.max_recv_wr = cmd.max_recv_wr;\r\nattr.cap.max_send_sge = cmd.max_send_sge;\r\nattr.cap.max_recv_sge = cmd.max_recv_sge;\r\nattr.cap.max_inline_data = cmd.max_inline_data;\r\nobj->uevent.events_reported = 0;\r\nINIT_LIST_HEAD(&obj->uevent.event_list);\r\nINIT_LIST_HEAD(&obj->mcast_list);\r\nif (cmd.qp_type == IB_QPT_XRC_TGT)\r\nqp = ib_create_qp(pd, &attr);\r\nelse\r\nqp = device->create_qp(pd, &attr, &udata);\r\nif (IS_ERR(qp)) {\r\nret = PTR_ERR(qp);\r\ngoto err_put;\r\n}\r\nif (cmd.qp_type != IB_QPT_XRC_TGT) {\r\nqp->real_qp = qp;\r\nqp->device = device;\r\nqp->pd = pd;\r\nqp->send_cq = attr.send_cq;\r\nqp->recv_cq = attr.recv_cq;\r\nqp->srq = attr.srq;\r\nqp->event_handler = attr.event_handler;\r\nqp->qp_context = attr.qp_context;\r\nqp->qp_type = attr.qp_type;\r\natomic_set(&qp->usecnt, 0);\r\natomic_inc(&pd->usecnt);\r\natomic_inc(&attr.send_cq->usecnt);\r\nif (attr.recv_cq)\r\natomic_inc(&attr.recv_cq->usecnt);\r\nif (attr.srq)\r\natomic_inc(&attr.srq->usecnt);\r\n}\r\nqp->uobject = &obj->uevent.uobject;\r\nobj->uevent.uobject.object = qp;\r\nret = idr_add_uobj(&ib_uverbs_qp_idr, &obj->uevent.uobject);\r\nif (ret)\r\ngoto err_destroy;\r\nmemset(&resp, 0, sizeof resp);\r\nresp.qpn = qp->qp_num;\r\nresp.qp_handle = obj->uevent.uobject.id;\r\nresp.max_recv_sge = attr.cap.max_recv_sge;\r\nresp.max_send_sge = attr.cap.max_send_sge;\r\nresp.max_recv_wr = attr.cap.max_recv_wr;\r\nresp.max_send_wr = attr.cap.max_send_wr;\r\nresp.max_inline_data = attr.cap.max_inline_data;\r\nif (copy_to_user((void __user *) (unsigned long) cmd.response,\r\n&resp, sizeof resp)) {\r\nret = -EFAULT;\r\ngoto err_copy;\r\n}\r\nif (xrcd) {\r\nobj->uxrcd = container_of(xrcd_uobj, struct ib_uxrcd_object,\r\nuobject);\r\natomic_inc(&obj->uxrcd->refcnt);\r\nput_xrcd_read(xrcd_uobj);\r\n}\r\nif (pd)\r\nput_pd_read(pd);\r\nif (scq)\r\nput_cq_read(scq);\r\nif (rcq && rcq != scq)\r\nput_cq_read(rcq);\r\nif (srq)\r\nput_srq_read(srq);\r\nmutex_lock(&file->mutex);\r\nlist_add_tail(&obj->uevent.uobject.list, &file->ucontext->qp_list);\r\nmutex_unlock(&file->mutex);\r\nobj->uevent.uobject.live = 1;\r\nup_write(&obj->uevent.uobject.mutex);\r\nreturn in_len;\r\nerr_copy:\r\nidr_remove_uobj(&ib_uverbs_qp_idr, &obj->uevent.uobject);\r\nerr_destroy:\r\nib_destroy_qp(qp);\r\nerr_put:\r\nif (xrcd)\r\nput_xrcd_read(xrcd_uobj);\r\nif (pd)\r\nput_pd_read(pd);\r\nif (scq)\r\nput_cq_read(scq);\r\nif (rcq && rcq != scq)\r\nput_cq_read(rcq);\r\nif (srq)\r\nput_srq_read(srq);\r\nput_uobj_write(&obj->uevent.uobject);\r\nreturn ret;\r\n}\r\nssize_t ib_uverbs_open_qp(struct ib_uverbs_file *file,\r\nconst char __user *buf, int in_len, int out_len)\r\n{\r\nstruct ib_uverbs_open_qp cmd;\r\nstruct ib_uverbs_create_qp_resp resp;\r\nstruct ib_udata udata;\r\nstruct ib_uqp_object *obj;\r\nstruct ib_xrcd *xrcd;\r\nstruct ib_uobject *uninitialized_var(xrcd_uobj);\r\nstruct ib_qp *qp;\r\nstruct ib_qp_open_attr attr;\r\nint ret;\r\nif (out_len < sizeof resp)\r\nreturn -ENOSPC;\r\nif (copy_from_user(&cmd, buf, sizeof cmd))\r\nreturn -EFAULT;\r\nINIT_UDATA(&udata, buf + sizeof cmd,\r\n(unsigned long) cmd.response + sizeof resp,\r\nin_len - sizeof cmd, out_len - sizeof resp);\r\nobj = kmalloc(sizeof *obj, GFP_KERNEL);\r\nif (!obj)\r\nreturn -ENOMEM;\r\ninit_uobj(&obj->uevent.uobject, cmd.user_handle, file->ucontext, &qp_lock_class);\r\ndown_write(&obj->uevent.uobject.mutex);\r\nxrcd = idr_read_xrcd(cmd.pd_handle, file->ucontext, &xrcd_uobj);\r\nif (!xrcd) {\r\nret = -EINVAL;\r\ngoto err_put;\r\n}\r\nattr.event_handler = ib_uverbs_qp_event_handler;\r\nattr.qp_context = file;\r\nattr.qp_num = cmd.qpn;\r\nattr.qp_type = cmd.qp_type;\r\nobj->uevent.events_reported = 0;\r\nINIT_LIST_HEAD(&obj->uevent.event_list);\r\nINIT_LIST_HEAD(&obj->mcast_list);\r\nqp = ib_open_qp(xrcd, &attr);\r\nif (IS_ERR(qp)) {\r\nret = PTR_ERR(qp);\r\ngoto err_put;\r\n}\r\nqp->uobject = &obj->uevent.uobject;\r\nobj->uevent.uobject.object = qp;\r\nret = idr_add_uobj(&ib_uverbs_qp_idr, &obj->uevent.uobject);\r\nif (ret)\r\ngoto err_destroy;\r\nmemset(&resp, 0, sizeof resp);\r\nresp.qpn = qp->qp_num;\r\nresp.qp_handle = obj->uevent.uobject.id;\r\nif (copy_to_user((void __user *) (unsigned long) cmd.response,\r\n&resp, sizeof resp)) {\r\nret = -EFAULT;\r\ngoto err_remove;\r\n}\r\nobj->uxrcd = container_of(xrcd_uobj, struct ib_uxrcd_object, uobject);\r\natomic_inc(&obj->uxrcd->refcnt);\r\nput_xrcd_read(xrcd_uobj);\r\nmutex_lock(&file->mutex);\r\nlist_add_tail(&obj->uevent.uobject.list, &file->ucontext->qp_list);\r\nmutex_unlock(&file->mutex);\r\nobj->uevent.uobject.live = 1;\r\nup_write(&obj->uevent.uobject.mutex);\r\nreturn in_len;\r\nerr_remove:\r\nidr_remove_uobj(&ib_uverbs_qp_idr, &obj->uevent.uobject);\r\nerr_destroy:\r\nib_destroy_qp(qp);\r\nerr_put:\r\nput_xrcd_read(xrcd_uobj);\r\nput_uobj_write(&obj->uevent.uobject);\r\nreturn ret;\r\n}\r\nssize_t ib_uverbs_query_qp(struct ib_uverbs_file *file,\r\nconst char __user *buf, int in_len,\r\nint out_len)\r\n{\r\nstruct ib_uverbs_query_qp cmd;\r\nstruct ib_uverbs_query_qp_resp resp;\r\nstruct ib_qp *qp;\r\nstruct ib_qp_attr *attr;\r\nstruct ib_qp_init_attr *init_attr;\r\nint ret;\r\nif (copy_from_user(&cmd, buf, sizeof cmd))\r\nreturn -EFAULT;\r\nattr = kmalloc(sizeof *attr, GFP_KERNEL);\r\ninit_attr = kmalloc(sizeof *init_attr, GFP_KERNEL);\r\nif (!attr || !init_attr) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nqp = idr_read_qp(cmd.qp_handle, file->ucontext);\r\nif (!qp) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nret = ib_query_qp(qp, attr, cmd.attr_mask, init_attr);\r\nput_qp_read(qp);\r\nif (ret)\r\ngoto out;\r\nmemset(&resp, 0, sizeof resp);\r\nresp.qp_state = attr->qp_state;\r\nresp.cur_qp_state = attr->cur_qp_state;\r\nresp.path_mtu = attr->path_mtu;\r\nresp.path_mig_state = attr->path_mig_state;\r\nresp.qkey = attr->qkey;\r\nresp.rq_psn = attr->rq_psn;\r\nresp.sq_psn = attr->sq_psn;\r\nresp.dest_qp_num = attr->dest_qp_num;\r\nresp.qp_access_flags = attr->qp_access_flags;\r\nresp.pkey_index = attr->pkey_index;\r\nresp.alt_pkey_index = attr->alt_pkey_index;\r\nresp.sq_draining = attr->sq_draining;\r\nresp.max_rd_atomic = attr->max_rd_atomic;\r\nresp.max_dest_rd_atomic = attr->max_dest_rd_atomic;\r\nresp.min_rnr_timer = attr->min_rnr_timer;\r\nresp.port_num = attr->port_num;\r\nresp.timeout = attr->timeout;\r\nresp.retry_cnt = attr->retry_cnt;\r\nresp.rnr_retry = attr->rnr_retry;\r\nresp.alt_port_num = attr->alt_port_num;\r\nresp.alt_timeout = attr->alt_timeout;\r\nmemcpy(resp.dest.dgid, attr->ah_attr.grh.dgid.raw, 16);\r\nresp.dest.flow_label = attr->ah_attr.grh.flow_label;\r\nresp.dest.sgid_index = attr->ah_attr.grh.sgid_index;\r\nresp.dest.hop_limit = attr->ah_attr.grh.hop_limit;\r\nresp.dest.traffic_class = attr->ah_attr.grh.traffic_class;\r\nresp.dest.dlid = attr->ah_attr.dlid;\r\nresp.dest.sl = attr->ah_attr.sl;\r\nresp.dest.src_path_bits = attr->ah_attr.src_path_bits;\r\nresp.dest.static_rate = attr->ah_attr.static_rate;\r\nresp.dest.is_global = !!(attr->ah_attr.ah_flags & IB_AH_GRH);\r\nresp.dest.port_num = attr->ah_attr.port_num;\r\nmemcpy(resp.alt_dest.dgid, attr->alt_ah_attr.grh.dgid.raw, 16);\r\nresp.alt_dest.flow_label = attr->alt_ah_attr.grh.flow_label;\r\nresp.alt_dest.sgid_index = attr->alt_ah_attr.grh.sgid_index;\r\nresp.alt_dest.hop_limit = attr->alt_ah_attr.grh.hop_limit;\r\nresp.alt_dest.traffic_class = attr->alt_ah_attr.grh.traffic_class;\r\nresp.alt_dest.dlid = attr->alt_ah_attr.dlid;\r\nresp.alt_dest.sl = attr->alt_ah_attr.sl;\r\nresp.alt_dest.src_path_bits = attr->alt_ah_attr.src_path_bits;\r\nresp.alt_dest.static_rate = attr->alt_ah_attr.static_rate;\r\nresp.alt_dest.is_global = !!(attr->alt_ah_attr.ah_flags & IB_AH_GRH);\r\nresp.alt_dest.port_num = attr->alt_ah_attr.port_num;\r\nresp.max_send_wr = init_attr->cap.max_send_wr;\r\nresp.max_recv_wr = init_attr->cap.max_recv_wr;\r\nresp.max_send_sge = init_attr->cap.max_send_sge;\r\nresp.max_recv_sge = init_attr->cap.max_recv_sge;\r\nresp.max_inline_data = init_attr->cap.max_inline_data;\r\nresp.sq_sig_all = init_attr->sq_sig_type == IB_SIGNAL_ALL_WR;\r\nif (copy_to_user((void __user *) (unsigned long) cmd.response,\r\n&resp, sizeof resp))\r\nret = -EFAULT;\r\nout:\r\nkfree(attr);\r\nkfree(init_attr);\r\nreturn ret ? ret : in_len;\r\n}\r\nstatic int modify_qp_mask(enum ib_qp_type qp_type, int mask)\r\n{\r\nswitch (qp_type) {\r\ncase IB_QPT_XRC_INI:\r\nreturn mask & ~(IB_QP_MAX_DEST_RD_ATOMIC | IB_QP_MIN_RNR_TIMER);\r\ncase IB_QPT_XRC_TGT:\r\nreturn mask & ~(IB_QP_MAX_QP_RD_ATOMIC | IB_QP_RETRY_CNT |\r\nIB_QP_RNR_RETRY);\r\ndefault:\r\nreturn mask;\r\n}\r\n}\r\nssize_t ib_uverbs_modify_qp(struct ib_uverbs_file *file,\r\nconst char __user *buf, int in_len,\r\nint out_len)\r\n{\r\nstruct ib_uverbs_modify_qp cmd;\r\nstruct ib_udata udata;\r\nstruct ib_qp *qp;\r\nstruct ib_qp_attr *attr;\r\nint ret;\r\nif (copy_from_user(&cmd, buf, sizeof cmd))\r\nreturn -EFAULT;\r\nINIT_UDATA(&udata, buf + sizeof cmd, NULL, in_len - sizeof cmd,\r\nout_len);\r\nattr = kmalloc(sizeof *attr, GFP_KERNEL);\r\nif (!attr)\r\nreturn -ENOMEM;\r\nqp = idr_read_qp(cmd.qp_handle, file->ucontext);\r\nif (!qp) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nattr->qp_state = cmd.qp_state;\r\nattr->cur_qp_state = cmd.cur_qp_state;\r\nattr->path_mtu = cmd.path_mtu;\r\nattr->path_mig_state = cmd.path_mig_state;\r\nattr->qkey = cmd.qkey;\r\nattr->rq_psn = cmd.rq_psn;\r\nattr->sq_psn = cmd.sq_psn;\r\nattr->dest_qp_num = cmd.dest_qp_num;\r\nattr->qp_access_flags = cmd.qp_access_flags;\r\nattr->pkey_index = cmd.pkey_index;\r\nattr->alt_pkey_index = cmd.alt_pkey_index;\r\nattr->en_sqd_async_notify = cmd.en_sqd_async_notify;\r\nattr->max_rd_atomic = cmd.max_rd_atomic;\r\nattr->max_dest_rd_atomic = cmd.max_dest_rd_atomic;\r\nattr->min_rnr_timer = cmd.min_rnr_timer;\r\nattr->port_num = cmd.port_num;\r\nattr->timeout = cmd.timeout;\r\nattr->retry_cnt = cmd.retry_cnt;\r\nattr->rnr_retry = cmd.rnr_retry;\r\nattr->alt_port_num = cmd.alt_port_num;\r\nattr->alt_timeout = cmd.alt_timeout;\r\nmemcpy(attr->ah_attr.grh.dgid.raw, cmd.dest.dgid, 16);\r\nattr->ah_attr.grh.flow_label = cmd.dest.flow_label;\r\nattr->ah_attr.grh.sgid_index = cmd.dest.sgid_index;\r\nattr->ah_attr.grh.hop_limit = cmd.dest.hop_limit;\r\nattr->ah_attr.grh.traffic_class = cmd.dest.traffic_class;\r\nattr->ah_attr.dlid = cmd.dest.dlid;\r\nattr->ah_attr.sl = cmd.dest.sl;\r\nattr->ah_attr.src_path_bits = cmd.dest.src_path_bits;\r\nattr->ah_attr.static_rate = cmd.dest.static_rate;\r\nattr->ah_attr.ah_flags = cmd.dest.is_global ? IB_AH_GRH : 0;\r\nattr->ah_attr.port_num = cmd.dest.port_num;\r\nmemcpy(attr->alt_ah_attr.grh.dgid.raw, cmd.alt_dest.dgid, 16);\r\nattr->alt_ah_attr.grh.flow_label = cmd.alt_dest.flow_label;\r\nattr->alt_ah_attr.grh.sgid_index = cmd.alt_dest.sgid_index;\r\nattr->alt_ah_attr.grh.hop_limit = cmd.alt_dest.hop_limit;\r\nattr->alt_ah_attr.grh.traffic_class = cmd.alt_dest.traffic_class;\r\nattr->alt_ah_attr.dlid = cmd.alt_dest.dlid;\r\nattr->alt_ah_attr.sl = cmd.alt_dest.sl;\r\nattr->alt_ah_attr.src_path_bits = cmd.alt_dest.src_path_bits;\r\nattr->alt_ah_attr.static_rate = cmd.alt_dest.static_rate;\r\nattr->alt_ah_attr.ah_flags = cmd.alt_dest.is_global ? IB_AH_GRH : 0;\r\nattr->alt_ah_attr.port_num = cmd.alt_dest.port_num;\r\nif (qp->real_qp == qp) {\r\nret = ib_resolve_eth_l2_attrs(qp, attr, &cmd.attr_mask);\r\nif (ret)\r\ngoto release_qp;\r\nret = qp->device->modify_qp(qp, attr,\r\nmodify_qp_mask(qp->qp_type, cmd.attr_mask), &udata);\r\n} else {\r\nret = ib_modify_qp(qp, attr, modify_qp_mask(qp->qp_type, cmd.attr_mask));\r\n}\r\nif (ret)\r\ngoto release_qp;\r\nret = in_len;\r\nrelease_qp:\r\nput_qp_read(qp);\r\nout:\r\nkfree(attr);\r\nreturn ret;\r\n}\r\nssize_t ib_uverbs_destroy_qp(struct ib_uverbs_file *file,\r\nconst char __user *buf, int in_len,\r\nint out_len)\r\n{\r\nstruct ib_uverbs_destroy_qp cmd;\r\nstruct ib_uverbs_destroy_qp_resp resp;\r\nstruct ib_uobject *uobj;\r\nstruct ib_qp *qp;\r\nstruct ib_uqp_object *obj;\r\nint ret = -EINVAL;\r\nif (copy_from_user(&cmd, buf, sizeof cmd))\r\nreturn -EFAULT;\r\nmemset(&resp, 0, sizeof resp);\r\nuobj = idr_write_uobj(&ib_uverbs_qp_idr, cmd.qp_handle, file->ucontext);\r\nif (!uobj)\r\nreturn -EINVAL;\r\nqp = uobj->object;\r\nobj = container_of(uobj, struct ib_uqp_object, uevent.uobject);\r\nif (!list_empty(&obj->mcast_list)) {\r\nput_uobj_write(uobj);\r\nreturn -EBUSY;\r\n}\r\nret = ib_destroy_qp(qp);\r\nif (!ret)\r\nuobj->live = 0;\r\nput_uobj_write(uobj);\r\nif (ret)\r\nreturn ret;\r\nif (obj->uxrcd)\r\natomic_dec(&obj->uxrcd->refcnt);\r\nidr_remove_uobj(&ib_uverbs_qp_idr, uobj);\r\nmutex_lock(&file->mutex);\r\nlist_del(&uobj->list);\r\nmutex_unlock(&file->mutex);\r\nib_uverbs_release_uevent(file, &obj->uevent);\r\nresp.events_reported = obj->uevent.events_reported;\r\nput_uobj(uobj);\r\nif (copy_to_user((void __user *) (unsigned long) cmd.response,\r\n&resp, sizeof resp))\r\nreturn -EFAULT;\r\nreturn in_len;\r\n}\r\nssize_t ib_uverbs_post_send(struct ib_uverbs_file *file,\r\nconst char __user *buf, int in_len,\r\nint out_len)\r\n{\r\nstruct ib_uverbs_post_send cmd;\r\nstruct ib_uverbs_post_send_resp resp;\r\nstruct ib_uverbs_send_wr *user_wr;\r\nstruct ib_send_wr *wr = NULL, *last, *next, *bad_wr;\r\nstruct ib_qp *qp;\r\nint i, sg_ind;\r\nint is_ud;\r\nssize_t ret = -EINVAL;\r\nif (copy_from_user(&cmd, buf, sizeof cmd))\r\nreturn -EFAULT;\r\nif (in_len < sizeof cmd + cmd.wqe_size * cmd.wr_count +\r\ncmd.sge_count * sizeof (struct ib_uverbs_sge))\r\nreturn -EINVAL;\r\nif (cmd.wqe_size < sizeof (struct ib_uverbs_send_wr))\r\nreturn -EINVAL;\r\nuser_wr = kmalloc(cmd.wqe_size, GFP_KERNEL);\r\nif (!user_wr)\r\nreturn -ENOMEM;\r\nqp = idr_read_qp(cmd.qp_handle, file->ucontext);\r\nif (!qp)\r\ngoto out;\r\nis_ud = qp->qp_type == IB_QPT_UD;\r\nsg_ind = 0;\r\nlast = NULL;\r\nfor (i = 0; i < cmd.wr_count; ++i) {\r\nif (copy_from_user(user_wr,\r\nbuf + sizeof cmd + i * cmd.wqe_size,\r\ncmd.wqe_size)) {\r\nret = -EFAULT;\r\ngoto out_put;\r\n}\r\nif (user_wr->num_sge + sg_ind > cmd.sge_count) {\r\nret = -EINVAL;\r\ngoto out_put;\r\n}\r\nnext = kmalloc(ALIGN(sizeof *next, sizeof (struct ib_sge)) +\r\nuser_wr->num_sge * sizeof (struct ib_sge),\r\nGFP_KERNEL);\r\nif (!next) {\r\nret = -ENOMEM;\r\ngoto out_put;\r\n}\r\nif (!last)\r\nwr = next;\r\nelse\r\nlast->next = next;\r\nlast = next;\r\nnext->next = NULL;\r\nnext->wr_id = user_wr->wr_id;\r\nnext->num_sge = user_wr->num_sge;\r\nnext->opcode = user_wr->opcode;\r\nnext->send_flags = user_wr->send_flags;\r\nif (is_ud) {\r\nnext->wr.ud.ah = idr_read_ah(user_wr->wr.ud.ah,\r\nfile->ucontext);\r\nif (!next->wr.ud.ah) {\r\nret = -EINVAL;\r\ngoto out_put;\r\n}\r\nnext->wr.ud.remote_qpn = user_wr->wr.ud.remote_qpn;\r\nnext->wr.ud.remote_qkey = user_wr->wr.ud.remote_qkey;\r\nif (next->opcode == IB_WR_SEND_WITH_IMM)\r\nnext->ex.imm_data =\r\n(__be32 __force) user_wr->ex.imm_data;\r\n} else {\r\nswitch (next->opcode) {\r\ncase IB_WR_RDMA_WRITE_WITH_IMM:\r\nnext->ex.imm_data =\r\n(__be32 __force) user_wr->ex.imm_data;\r\ncase IB_WR_RDMA_WRITE:\r\ncase IB_WR_RDMA_READ:\r\nnext->wr.rdma.remote_addr =\r\nuser_wr->wr.rdma.remote_addr;\r\nnext->wr.rdma.rkey =\r\nuser_wr->wr.rdma.rkey;\r\nbreak;\r\ncase IB_WR_SEND_WITH_IMM:\r\nnext->ex.imm_data =\r\n(__be32 __force) user_wr->ex.imm_data;\r\nbreak;\r\ncase IB_WR_SEND_WITH_INV:\r\nnext->ex.invalidate_rkey =\r\nuser_wr->ex.invalidate_rkey;\r\nbreak;\r\ncase IB_WR_ATOMIC_CMP_AND_SWP:\r\ncase IB_WR_ATOMIC_FETCH_AND_ADD:\r\nnext->wr.atomic.remote_addr =\r\nuser_wr->wr.atomic.remote_addr;\r\nnext->wr.atomic.compare_add =\r\nuser_wr->wr.atomic.compare_add;\r\nnext->wr.atomic.swap = user_wr->wr.atomic.swap;\r\nnext->wr.atomic.rkey = user_wr->wr.atomic.rkey;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nif (next->num_sge) {\r\nnext->sg_list = (void *) next +\r\nALIGN(sizeof *next, sizeof (struct ib_sge));\r\nif (copy_from_user(next->sg_list,\r\nbuf + sizeof cmd +\r\ncmd.wr_count * cmd.wqe_size +\r\nsg_ind * sizeof (struct ib_sge),\r\nnext->num_sge * sizeof (struct ib_sge))) {\r\nret = -EFAULT;\r\ngoto out_put;\r\n}\r\nsg_ind += next->num_sge;\r\n} else\r\nnext->sg_list = NULL;\r\n}\r\nresp.bad_wr = 0;\r\nret = qp->device->post_send(qp->real_qp, wr, &bad_wr);\r\nif (ret)\r\nfor (next = wr; next; next = next->next) {\r\n++resp.bad_wr;\r\nif (next == bad_wr)\r\nbreak;\r\n}\r\nif (copy_to_user((void __user *) (unsigned long) cmd.response,\r\n&resp, sizeof resp))\r\nret = -EFAULT;\r\nout_put:\r\nput_qp_read(qp);\r\nwhile (wr) {\r\nif (is_ud && wr->wr.ud.ah)\r\nput_ah_read(wr->wr.ud.ah);\r\nnext = wr->next;\r\nkfree(wr);\r\nwr = next;\r\n}\r\nout:\r\nkfree(user_wr);\r\nreturn ret ? ret : in_len;\r\n}\r\nstatic struct ib_recv_wr *ib_uverbs_unmarshall_recv(const char __user *buf,\r\nint in_len,\r\nu32 wr_count,\r\nu32 sge_count,\r\nu32 wqe_size)\r\n{\r\nstruct ib_uverbs_recv_wr *user_wr;\r\nstruct ib_recv_wr *wr = NULL, *last, *next;\r\nint sg_ind;\r\nint i;\r\nint ret;\r\nif (in_len < wqe_size * wr_count +\r\nsge_count * sizeof (struct ib_uverbs_sge))\r\nreturn ERR_PTR(-EINVAL);\r\nif (wqe_size < sizeof (struct ib_uverbs_recv_wr))\r\nreturn ERR_PTR(-EINVAL);\r\nuser_wr = kmalloc(wqe_size, GFP_KERNEL);\r\nif (!user_wr)\r\nreturn ERR_PTR(-ENOMEM);\r\nsg_ind = 0;\r\nlast = NULL;\r\nfor (i = 0; i < wr_count; ++i) {\r\nif (copy_from_user(user_wr, buf + i * wqe_size,\r\nwqe_size)) {\r\nret = -EFAULT;\r\ngoto err;\r\n}\r\nif (user_wr->num_sge + sg_ind > sge_count) {\r\nret = -EINVAL;\r\ngoto err;\r\n}\r\nnext = kmalloc(ALIGN(sizeof *next, sizeof (struct ib_sge)) +\r\nuser_wr->num_sge * sizeof (struct ib_sge),\r\nGFP_KERNEL);\r\nif (!next) {\r\nret = -ENOMEM;\r\ngoto err;\r\n}\r\nif (!last)\r\nwr = next;\r\nelse\r\nlast->next = next;\r\nlast = next;\r\nnext->next = NULL;\r\nnext->wr_id = user_wr->wr_id;\r\nnext->num_sge = user_wr->num_sge;\r\nif (next->num_sge) {\r\nnext->sg_list = (void *) next +\r\nALIGN(sizeof *next, sizeof (struct ib_sge));\r\nif (copy_from_user(next->sg_list,\r\nbuf + wr_count * wqe_size +\r\nsg_ind * sizeof (struct ib_sge),\r\nnext->num_sge * sizeof (struct ib_sge))) {\r\nret = -EFAULT;\r\ngoto err;\r\n}\r\nsg_ind += next->num_sge;\r\n} else\r\nnext->sg_list = NULL;\r\n}\r\nkfree(user_wr);\r\nreturn wr;\r\nerr:\r\nkfree(user_wr);\r\nwhile (wr) {\r\nnext = wr->next;\r\nkfree(wr);\r\nwr = next;\r\n}\r\nreturn ERR_PTR(ret);\r\n}\r\nssize_t ib_uverbs_post_recv(struct ib_uverbs_file *file,\r\nconst char __user *buf, int in_len,\r\nint out_len)\r\n{\r\nstruct ib_uverbs_post_recv cmd;\r\nstruct ib_uverbs_post_recv_resp resp;\r\nstruct ib_recv_wr *wr, *next, *bad_wr;\r\nstruct ib_qp *qp;\r\nssize_t ret = -EINVAL;\r\nif (copy_from_user(&cmd, buf, sizeof cmd))\r\nreturn -EFAULT;\r\nwr = ib_uverbs_unmarshall_recv(buf + sizeof cmd,\r\nin_len - sizeof cmd, cmd.wr_count,\r\ncmd.sge_count, cmd.wqe_size);\r\nif (IS_ERR(wr))\r\nreturn PTR_ERR(wr);\r\nqp = idr_read_qp(cmd.qp_handle, file->ucontext);\r\nif (!qp)\r\ngoto out;\r\nresp.bad_wr = 0;\r\nret = qp->device->post_recv(qp->real_qp, wr, &bad_wr);\r\nput_qp_read(qp);\r\nif (ret)\r\nfor (next = wr; next; next = next->next) {\r\n++resp.bad_wr;\r\nif (next == bad_wr)\r\nbreak;\r\n}\r\nif (copy_to_user((void __user *) (unsigned long) cmd.response,\r\n&resp, sizeof resp))\r\nret = -EFAULT;\r\nout:\r\nwhile (wr) {\r\nnext = wr->next;\r\nkfree(wr);\r\nwr = next;\r\n}\r\nreturn ret ? ret : in_len;\r\n}\r\nssize_t ib_uverbs_post_srq_recv(struct ib_uverbs_file *file,\r\nconst char __user *buf, int in_len,\r\nint out_len)\r\n{\r\nstruct ib_uverbs_post_srq_recv cmd;\r\nstruct ib_uverbs_post_srq_recv_resp resp;\r\nstruct ib_recv_wr *wr, *next, *bad_wr;\r\nstruct ib_srq *srq;\r\nssize_t ret = -EINVAL;\r\nif (copy_from_user(&cmd, buf, sizeof cmd))\r\nreturn -EFAULT;\r\nwr = ib_uverbs_unmarshall_recv(buf + sizeof cmd,\r\nin_len - sizeof cmd, cmd.wr_count,\r\ncmd.sge_count, cmd.wqe_size);\r\nif (IS_ERR(wr))\r\nreturn PTR_ERR(wr);\r\nsrq = idr_read_srq(cmd.srq_handle, file->ucontext);\r\nif (!srq)\r\ngoto out;\r\nresp.bad_wr = 0;\r\nret = srq->device->post_srq_recv(srq, wr, &bad_wr);\r\nput_srq_read(srq);\r\nif (ret)\r\nfor (next = wr; next; next = next->next) {\r\n++resp.bad_wr;\r\nif (next == bad_wr)\r\nbreak;\r\n}\r\nif (copy_to_user((void __user *) (unsigned long) cmd.response,\r\n&resp, sizeof resp))\r\nret = -EFAULT;\r\nout:\r\nwhile (wr) {\r\nnext = wr->next;\r\nkfree(wr);\r\nwr = next;\r\n}\r\nreturn ret ? ret : in_len;\r\n}\r\nssize_t ib_uverbs_create_ah(struct ib_uverbs_file *file,\r\nconst char __user *buf, int in_len,\r\nint out_len)\r\n{\r\nstruct ib_uverbs_create_ah cmd;\r\nstruct ib_uverbs_create_ah_resp resp;\r\nstruct ib_uobject *uobj;\r\nstruct ib_pd *pd;\r\nstruct ib_ah *ah;\r\nstruct ib_ah_attr attr;\r\nint ret;\r\nif (out_len < sizeof resp)\r\nreturn -ENOSPC;\r\nif (copy_from_user(&cmd, buf, sizeof cmd))\r\nreturn -EFAULT;\r\nuobj = kmalloc(sizeof *uobj, GFP_KERNEL);\r\nif (!uobj)\r\nreturn -ENOMEM;\r\ninit_uobj(uobj, cmd.user_handle, file->ucontext, &ah_lock_class);\r\ndown_write(&uobj->mutex);\r\npd = idr_read_pd(cmd.pd_handle, file->ucontext);\r\nif (!pd) {\r\nret = -EINVAL;\r\ngoto err;\r\n}\r\nattr.dlid = cmd.attr.dlid;\r\nattr.sl = cmd.attr.sl;\r\nattr.src_path_bits = cmd.attr.src_path_bits;\r\nattr.static_rate = cmd.attr.static_rate;\r\nattr.ah_flags = cmd.attr.is_global ? IB_AH_GRH : 0;\r\nattr.port_num = cmd.attr.port_num;\r\nattr.grh.flow_label = cmd.attr.grh.flow_label;\r\nattr.grh.sgid_index = cmd.attr.grh.sgid_index;\r\nattr.grh.hop_limit = cmd.attr.grh.hop_limit;\r\nattr.grh.traffic_class = cmd.attr.grh.traffic_class;\r\nattr.vlan_id = 0;\r\nmemset(&attr.dmac, 0, sizeof(attr.dmac));\r\nmemcpy(attr.grh.dgid.raw, cmd.attr.grh.dgid, 16);\r\nah = ib_create_ah(pd, &attr);\r\nif (IS_ERR(ah)) {\r\nret = PTR_ERR(ah);\r\ngoto err_put;\r\n}\r\nah->uobject = uobj;\r\nuobj->object = ah;\r\nret = idr_add_uobj(&ib_uverbs_ah_idr, uobj);\r\nif (ret)\r\ngoto err_destroy;\r\nresp.ah_handle = uobj->id;\r\nif (copy_to_user((void __user *) (unsigned long) cmd.response,\r\n&resp, sizeof resp)) {\r\nret = -EFAULT;\r\ngoto err_copy;\r\n}\r\nput_pd_read(pd);\r\nmutex_lock(&file->mutex);\r\nlist_add_tail(&uobj->list, &file->ucontext->ah_list);\r\nmutex_unlock(&file->mutex);\r\nuobj->live = 1;\r\nup_write(&uobj->mutex);\r\nreturn in_len;\r\nerr_copy:\r\nidr_remove_uobj(&ib_uverbs_ah_idr, uobj);\r\nerr_destroy:\r\nib_destroy_ah(ah);\r\nerr_put:\r\nput_pd_read(pd);\r\nerr:\r\nput_uobj_write(uobj);\r\nreturn ret;\r\n}\r\nssize_t ib_uverbs_destroy_ah(struct ib_uverbs_file *file,\r\nconst char __user *buf, int in_len, int out_len)\r\n{\r\nstruct ib_uverbs_destroy_ah cmd;\r\nstruct ib_ah *ah;\r\nstruct ib_uobject *uobj;\r\nint ret;\r\nif (copy_from_user(&cmd, buf, sizeof cmd))\r\nreturn -EFAULT;\r\nuobj = idr_write_uobj(&ib_uverbs_ah_idr, cmd.ah_handle, file->ucontext);\r\nif (!uobj)\r\nreturn -EINVAL;\r\nah = uobj->object;\r\nret = ib_destroy_ah(ah);\r\nif (!ret)\r\nuobj->live = 0;\r\nput_uobj_write(uobj);\r\nif (ret)\r\nreturn ret;\r\nidr_remove_uobj(&ib_uverbs_ah_idr, uobj);\r\nmutex_lock(&file->mutex);\r\nlist_del(&uobj->list);\r\nmutex_unlock(&file->mutex);\r\nput_uobj(uobj);\r\nreturn in_len;\r\n}\r\nssize_t ib_uverbs_attach_mcast(struct ib_uverbs_file *file,\r\nconst char __user *buf, int in_len,\r\nint out_len)\r\n{\r\nstruct ib_uverbs_attach_mcast cmd;\r\nstruct ib_qp *qp;\r\nstruct ib_uqp_object *obj;\r\nstruct ib_uverbs_mcast_entry *mcast;\r\nint ret;\r\nif (copy_from_user(&cmd, buf, sizeof cmd))\r\nreturn -EFAULT;\r\nqp = idr_write_qp(cmd.qp_handle, file->ucontext);\r\nif (!qp)\r\nreturn -EINVAL;\r\nobj = container_of(qp->uobject, struct ib_uqp_object, uevent.uobject);\r\nlist_for_each_entry(mcast, &obj->mcast_list, list)\r\nif (cmd.mlid == mcast->lid &&\r\n!memcmp(cmd.gid, mcast->gid.raw, sizeof mcast->gid.raw)) {\r\nret = 0;\r\ngoto out_put;\r\n}\r\nmcast = kmalloc(sizeof *mcast, GFP_KERNEL);\r\nif (!mcast) {\r\nret = -ENOMEM;\r\ngoto out_put;\r\n}\r\nmcast->lid = cmd.mlid;\r\nmemcpy(mcast->gid.raw, cmd.gid, sizeof mcast->gid.raw);\r\nret = ib_attach_mcast(qp, &mcast->gid, cmd.mlid);\r\nif (!ret)\r\nlist_add_tail(&mcast->list, &obj->mcast_list);\r\nelse\r\nkfree(mcast);\r\nout_put:\r\nput_qp_write(qp);\r\nreturn ret ? ret : in_len;\r\n}\r\nssize_t ib_uverbs_detach_mcast(struct ib_uverbs_file *file,\r\nconst char __user *buf, int in_len,\r\nint out_len)\r\n{\r\nstruct ib_uverbs_detach_mcast cmd;\r\nstruct ib_uqp_object *obj;\r\nstruct ib_qp *qp;\r\nstruct ib_uverbs_mcast_entry *mcast;\r\nint ret = -EINVAL;\r\nif (copy_from_user(&cmd, buf, sizeof cmd))\r\nreturn -EFAULT;\r\nqp = idr_write_qp(cmd.qp_handle, file->ucontext);\r\nif (!qp)\r\nreturn -EINVAL;\r\nret = ib_detach_mcast(qp, (union ib_gid *) cmd.gid, cmd.mlid);\r\nif (ret)\r\ngoto out_put;\r\nobj = container_of(qp->uobject, struct ib_uqp_object, uevent.uobject);\r\nlist_for_each_entry(mcast, &obj->mcast_list, list)\r\nif (cmd.mlid == mcast->lid &&\r\n!memcmp(cmd.gid, mcast->gid.raw, sizeof mcast->gid.raw)) {\r\nlist_del(&mcast->list);\r\nkfree(mcast);\r\nbreak;\r\n}\r\nout_put:\r\nput_qp_write(qp);\r\nreturn ret ? ret : in_len;\r\n}\r\nstatic int kern_spec_to_ib_spec(struct ib_uverbs_flow_spec *kern_spec,\r\nunion ib_flow_spec *ib_spec)\r\n{\r\nif (kern_spec->reserved)\r\nreturn -EINVAL;\r\nib_spec->type = kern_spec->type;\r\nswitch (ib_spec->type) {\r\ncase IB_FLOW_SPEC_ETH:\r\nib_spec->eth.size = sizeof(struct ib_flow_spec_eth);\r\nif (ib_spec->eth.size != kern_spec->eth.size)\r\nreturn -EINVAL;\r\nmemcpy(&ib_spec->eth.val, &kern_spec->eth.val,\r\nsizeof(struct ib_flow_eth_filter));\r\nmemcpy(&ib_spec->eth.mask, &kern_spec->eth.mask,\r\nsizeof(struct ib_flow_eth_filter));\r\nbreak;\r\ncase IB_FLOW_SPEC_IPV4:\r\nib_spec->ipv4.size = sizeof(struct ib_flow_spec_ipv4);\r\nif (ib_spec->ipv4.size != kern_spec->ipv4.size)\r\nreturn -EINVAL;\r\nmemcpy(&ib_spec->ipv4.val, &kern_spec->ipv4.val,\r\nsizeof(struct ib_flow_ipv4_filter));\r\nmemcpy(&ib_spec->ipv4.mask, &kern_spec->ipv4.mask,\r\nsizeof(struct ib_flow_ipv4_filter));\r\nbreak;\r\ncase IB_FLOW_SPEC_TCP:\r\ncase IB_FLOW_SPEC_UDP:\r\nib_spec->tcp_udp.size = sizeof(struct ib_flow_spec_tcp_udp);\r\nif (ib_spec->tcp_udp.size != kern_spec->tcp_udp.size)\r\nreturn -EINVAL;\r\nmemcpy(&ib_spec->tcp_udp.val, &kern_spec->tcp_udp.val,\r\nsizeof(struct ib_flow_tcp_udp_filter));\r\nmemcpy(&ib_spec->tcp_udp.mask, &kern_spec->tcp_udp.mask,\r\nsizeof(struct ib_flow_tcp_udp_filter));\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nint ib_uverbs_ex_create_flow(struct ib_uverbs_file *file,\r\nstruct ib_udata *ucore,\r\nstruct ib_udata *uhw)\r\n{\r\nstruct ib_uverbs_create_flow cmd;\r\nstruct ib_uverbs_create_flow_resp resp;\r\nstruct ib_uobject *uobj;\r\nstruct ib_flow *flow_id;\r\nstruct ib_uverbs_flow_attr *kern_flow_attr;\r\nstruct ib_flow_attr *flow_attr;\r\nstruct ib_qp *qp;\r\nint err = 0;\r\nvoid *kern_spec;\r\nvoid *ib_spec;\r\nint i;\r\nif (ucore->inlen < sizeof(cmd))\r\nreturn -EINVAL;\r\nif (ucore->outlen < sizeof(resp))\r\nreturn -ENOSPC;\r\nerr = ib_copy_from_udata(&cmd, ucore, sizeof(cmd));\r\nif (err)\r\nreturn err;\r\nucore->inbuf += sizeof(cmd);\r\nucore->inlen -= sizeof(cmd);\r\nif (cmd.comp_mask)\r\nreturn -EINVAL;\r\nif ((cmd.flow_attr.type == IB_FLOW_ATTR_SNIFFER &&\r\n!capable(CAP_NET_ADMIN)) || !capable(CAP_NET_RAW))\r\nreturn -EPERM;\r\nif (cmd.flow_attr.num_of_specs > IB_FLOW_SPEC_SUPPORT_LAYERS)\r\nreturn -EINVAL;\r\nif (cmd.flow_attr.size > ucore->inlen ||\r\ncmd.flow_attr.size >\r\n(cmd.flow_attr.num_of_specs * sizeof(struct ib_uverbs_flow_spec)))\r\nreturn -EINVAL;\r\nif (cmd.flow_attr.reserved[0] ||\r\ncmd.flow_attr.reserved[1])\r\nreturn -EINVAL;\r\nif (cmd.flow_attr.num_of_specs) {\r\nkern_flow_attr = kmalloc(sizeof(*kern_flow_attr) + cmd.flow_attr.size,\r\nGFP_KERNEL);\r\nif (!kern_flow_attr)\r\nreturn -ENOMEM;\r\nmemcpy(kern_flow_attr, &cmd.flow_attr, sizeof(*kern_flow_attr));\r\nerr = ib_copy_from_udata(kern_flow_attr + 1, ucore,\r\ncmd.flow_attr.size);\r\nif (err)\r\ngoto err_free_attr;\r\n} else {\r\nkern_flow_attr = &cmd.flow_attr;\r\n}\r\nuobj = kmalloc(sizeof(*uobj), GFP_KERNEL);\r\nif (!uobj) {\r\nerr = -ENOMEM;\r\ngoto err_free_attr;\r\n}\r\ninit_uobj(uobj, 0, file->ucontext, &rule_lock_class);\r\ndown_write(&uobj->mutex);\r\nqp = idr_read_qp(cmd.qp_handle, file->ucontext);\r\nif (!qp) {\r\nerr = -EINVAL;\r\ngoto err_uobj;\r\n}\r\nflow_attr = kmalloc(sizeof(*flow_attr) + cmd.flow_attr.size, GFP_KERNEL);\r\nif (!flow_attr) {\r\nerr = -ENOMEM;\r\ngoto err_put;\r\n}\r\nflow_attr->type = kern_flow_attr->type;\r\nflow_attr->priority = kern_flow_attr->priority;\r\nflow_attr->num_of_specs = kern_flow_attr->num_of_specs;\r\nflow_attr->port = kern_flow_attr->port;\r\nflow_attr->flags = kern_flow_attr->flags;\r\nflow_attr->size = sizeof(*flow_attr);\r\nkern_spec = kern_flow_attr + 1;\r\nib_spec = flow_attr + 1;\r\nfor (i = 0; i < flow_attr->num_of_specs &&\r\ncmd.flow_attr.size > offsetof(struct ib_uverbs_flow_spec, reserved) &&\r\ncmd.flow_attr.size >=\r\n((struct ib_uverbs_flow_spec *)kern_spec)->size; i++) {\r\nerr = kern_spec_to_ib_spec(kern_spec, ib_spec);\r\nif (err)\r\ngoto err_free;\r\nflow_attr->size +=\r\n((union ib_flow_spec *) ib_spec)->size;\r\ncmd.flow_attr.size -= ((struct ib_uverbs_flow_spec *)kern_spec)->size;\r\nkern_spec += ((struct ib_uverbs_flow_spec *) kern_spec)->size;\r\nib_spec += ((union ib_flow_spec *) ib_spec)->size;\r\n}\r\nif (cmd.flow_attr.size || (i != flow_attr->num_of_specs)) {\r\npr_warn("create flow failed, flow %d: %d bytes left from uverb cmd\n",\r\ni, cmd.flow_attr.size);\r\nerr = -EINVAL;\r\ngoto err_free;\r\n}\r\nflow_id = ib_create_flow(qp, flow_attr, IB_FLOW_DOMAIN_USER);\r\nif (IS_ERR(flow_id)) {\r\nerr = PTR_ERR(flow_id);\r\ngoto err_free;\r\n}\r\nflow_id->qp = qp;\r\nflow_id->uobject = uobj;\r\nuobj->object = flow_id;\r\nerr = idr_add_uobj(&ib_uverbs_rule_idr, uobj);\r\nif (err)\r\ngoto destroy_flow;\r\nmemset(&resp, 0, sizeof(resp));\r\nresp.flow_handle = uobj->id;\r\nerr = ib_copy_to_udata(ucore,\r\n&resp, sizeof(resp));\r\nif (err)\r\ngoto err_copy;\r\nput_qp_read(qp);\r\nmutex_lock(&file->mutex);\r\nlist_add_tail(&uobj->list, &file->ucontext->rule_list);\r\nmutex_unlock(&file->mutex);\r\nuobj->live = 1;\r\nup_write(&uobj->mutex);\r\nkfree(flow_attr);\r\nif (cmd.flow_attr.num_of_specs)\r\nkfree(kern_flow_attr);\r\nreturn 0;\r\nerr_copy:\r\nidr_remove_uobj(&ib_uverbs_rule_idr, uobj);\r\ndestroy_flow:\r\nib_destroy_flow(flow_id);\r\nerr_free:\r\nkfree(flow_attr);\r\nerr_put:\r\nput_qp_read(qp);\r\nerr_uobj:\r\nput_uobj_write(uobj);\r\nerr_free_attr:\r\nif (cmd.flow_attr.num_of_specs)\r\nkfree(kern_flow_attr);\r\nreturn err;\r\n}\r\nint ib_uverbs_ex_destroy_flow(struct ib_uverbs_file *file,\r\nstruct ib_udata *ucore,\r\nstruct ib_udata *uhw)\r\n{\r\nstruct ib_uverbs_destroy_flow cmd;\r\nstruct ib_flow *flow_id;\r\nstruct ib_uobject *uobj;\r\nint ret;\r\nif (ucore->inlen < sizeof(cmd))\r\nreturn -EINVAL;\r\nret = ib_copy_from_udata(&cmd, ucore, sizeof(cmd));\r\nif (ret)\r\nreturn ret;\r\nif (cmd.comp_mask)\r\nreturn -EINVAL;\r\nuobj = idr_write_uobj(&ib_uverbs_rule_idr, cmd.flow_handle,\r\nfile->ucontext);\r\nif (!uobj)\r\nreturn -EINVAL;\r\nflow_id = uobj->object;\r\nret = ib_destroy_flow(flow_id);\r\nif (!ret)\r\nuobj->live = 0;\r\nput_uobj_write(uobj);\r\nidr_remove_uobj(&ib_uverbs_rule_idr, uobj);\r\nmutex_lock(&file->mutex);\r\nlist_del(&uobj->list);\r\nmutex_unlock(&file->mutex);\r\nput_uobj(uobj);\r\nreturn ret;\r\n}\r\nstatic int __uverbs_create_xsrq(struct ib_uverbs_file *file,\r\nstruct ib_uverbs_create_xsrq *cmd,\r\nstruct ib_udata *udata)\r\n{\r\nstruct ib_uverbs_create_srq_resp resp;\r\nstruct ib_usrq_object *obj;\r\nstruct ib_pd *pd;\r\nstruct ib_srq *srq;\r\nstruct ib_uobject *uninitialized_var(xrcd_uobj);\r\nstruct ib_srq_init_attr attr;\r\nint ret;\r\nobj = kmalloc(sizeof *obj, GFP_KERNEL);\r\nif (!obj)\r\nreturn -ENOMEM;\r\ninit_uobj(&obj->uevent.uobject, cmd->user_handle, file->ucontext, &srq_lock_class);\r\ndown_write(&obj->uevent.uobject.mutex);\r\nif (cmd->srq_type == IB_SRQT_XRC) {\r\nattr.ext.xrc.xrcd = idr_read_xrcd(cmd->xrcd_handle, file->ucontext, &xrcd_uobj);\r\nif (!attr.ext.xrc.xrcd) {\r\nret = -EINVAL;\r\ngoto err;\r\n}\r\nobj->uxrcd = container_of(xrcd_uobj, struct ib_uxrcd_object, uobject);\r\natomic_inc(&obj->uxrcd->refcnt);\r\nattr.ext.xrc.cq = idr_read_cq(cmd->cq_handle, file->ucontext, 0);\r\nif (!attr.ext.xrc.cq) {\r\nret = -EINVAL;\r\ngoto err_put_xrcd;\r\n}\r\n}\r\npd = idr_read_pd(cmd->pd_handle, file->ucontext);\r\nif (!pd) {\r\nret = -EINVAL;\r\ngoto err_put_cq;\r\n}\r\nattr.event_handler = ib_uverbs_srq_event_handler;\r\nattr.srq_context = file;\r\nattr.srq_type = cmd->srq_type;\r\nattr.attr.max_wr = cmd->max_wr;\r\nattr.attr.max_sge = cmd->max_sge;\r\nattr.attr.srq_limit = cmd->srq_limit;\r\nobj->uevent.events_reported = 0;\r\nINIT_LIST_HEAD(&obj->uevent.event_list);\r\nsrq = pd->device->create_srq(pd, &attr, udata);\r\nif (IS_ERR(srq)) {\r\nret = PTR_ERR(srq);\r\ngoto err_put;\r\n}\r\nsrq->device = pd->device;\r\nsrq->pd = pd;\r\nsrq->srq_type = cmd->srq_type;\r\nsrq->uobject = &obj->uevent.uobject;\r\nsrq->event_handler = attr.event_handler;\r\nsrq->srq_context = attr.srq_context;\r\nif (cmd->srq_type == IB_SRQT_XRC) {\r\nsrq->ext.xrc.cq = attr.ext.xrc.cq;\r\nsrq->ext.xrc.xrcd = attr.ext.xrc.xrcd;\r\natomic_inc(&attr.ext.xrc.cq->usecnt);\r\natomic_inc(&attr.ext.xrc.xrcd->usecnt);\r\n}\r\natomic_inc(&pd->usecnt);\r\natomic_set(&srq->usecnt, 0);\r\nobj->uevent.uobject.object = srq;\r\nret = idr_add_uobj(&ib_uverbs_srq_idr, &obj->uevent.uobject);\r\nif (ret)\r\ngoto err_destroy;\r\nmemset(&resp, 0, sizeof resp);\r\nresp.srq_handle = obj->uevent.uobject.id;\r\nresp.max_wr = attr.attr.max_wr;\r\nresp.max_sge = attr.attr.max_sge;\r\nif (cmd->srq_type == IB_SRQT_XRC)\r\nresp.srqn = srq->ext.xrc.srq_num;\r\nif (copy_to_user((void __user *) (unsigned long) cmd->response,\r\n&resp, sizeof resp)) {\r\nret = -EFAULT;\r\ngoto err_copy;\r\n}\r\nif (cmd->srq_type == IB_SRQT_XRC) {\r\nput_uobj_read(xrcd_uobj);\r\nput_cq_read(attr.ext.xrc.cq);\r\n}\r\nput_pd_read(pd);\r\nmutex_lock(&file->mutex);\r\nlist_add_tail(&obj->uevent.uobject.list, &file->ucontext->srq_list);\r\nmutex_unlock(&file->mutex);\r\nobj->uevent.uobject.live = 1;\r\nup_write(&obj->uevent.uobject.mutex);\r\nreturn 0;\r\nerr_copy:\r\nidr_remove_uobj(&ib_uverbs_srq_idr, &obj->uevent.uobject);\r\nerr_destroy:\r\nib_destroy_srq(srq);\r\nerr_put:\r\nput_pd_read(pd);\r\nerr_put_cq:\r\nif (cmd->srq_type == IB_SRQT_XRC)\r\nput_cq_read(attr.ext.xrc.cq);\r\nerr_put_xrcd:\r\nif (cmd->srq_type == IB_SRQT_XRC) {\r\natomic_dec(&obj->uxrcd->refcnt);\r\nput_uobj_read(xrcd_uobj);\r\n}\r\nerr:\r\nput_uobj_write(&obj->uevent.uobject);\r\nreturn ret;\r\n}\r\nssize_t ib_uverbs_create_srq(struct ib_uverbs_file *file,\r\nconst char __user *buf, int in_len,\r\nint out_len)\r\n{\r\nstruct ib_uverbs_create_srq cmd;\r\nstruct ib_uverbs_create_xsrq xcmd;\r\nstruct ib_uverbs_create_srq_resp resp;\r\nstruct ib_udata udata;\r\nint ret;\r\nif (out_len < sizeof resp)\r\nreturn -ENOSPC;\r\nif (copy_from_user(&cmd, buf, sizeof cmd))\r\nreturn -EFAULT;\r\nxcmd.response = cmd.response;\r\nxcmd.user_handle = cmd.user_handle;\r\nxcmd.srq_type = IB_SRQT_BASIC;\r\nxcmd.pd_handle = cmd.pd_handle;\r\nxcmd.max_wr = cmd.max_wr;\r\nxcmd.max_sge = cmd.max_sge;\r\nxcmd.srq_limit = cmd.srq_limit;\r\nINIT_UDATA(&udata, buf + sizeof cmd,\r\n(unsigned long) cmd.response + sizeof resp,\r\nin_len - sizeof cmd, out_len - sizeof resp);\r\nret = __uverbs_create_xsrq(file, &xcmd, &udata);\r\nif (ret)\r\nreturn ret;\r\nreturn in_len;\r\n}\r\nssize_t ib_uverbs_create_xsrq(struct ib_uverbs_file *file,\r\nconst char __user *buf, int in_len, int out_len)\r\n{\r\nstruct ib_uverbs_create_xsrq cmd;\r\nstruct ib_uverbs_create_srq_resp resp;\r\nstruct ib_udata udata;\r\nint ret;\r\nif (out_len < sizeof resp)\r\nreturn -ENOSPC;\r\nif (copy_from_user(&cmd, buf, sizeof cmd))\r\nreturn -EFAULT;\r\nINIT_UDATA(&udata, buf + sizeof cmd,\r\n(unsigned long) cmd.response + sizeof resp,\r\nin_len - sizeof cmd, out_len - sizeof resp);\r\nret = __uverbs_create_xsrq(file, &cmd, &udata);\r\nif (ret)\r\nreturn ret;\r\nreturn in_len;\r\n}\r\nssize_t ib_uverbs_modify_srq(struct ib_uverbs_file *file,\r\nconst char __user *buf, int in_len,\r\nint out_len)\r\n{\r\nstruct ib_uverbs_modify_srq cmd;\r\nstruct ib_udata udata;\r\nstruct ib_srq *srq;\r\nstruct ib_srq_attr attr;\r\nint ret;\r\nif (copy_from_user(&cmd, buf, sizeof cmd))\r\nreturn -EFAULT;\r\nINIT_UDATA(&udata, buf + sizeof cmd, NULL, in_len - sizeof cmd,\r\nout_len);\r\nsrq = idr_read_srq(cmd.srq_handle, file->ucontext);\r\nif (!srq)\r\nreturn -EINVAL;\r\nattr.max_wr = cmd.max_wr;\r\nattr.srq_limit = cmd.srq_limit;\r\nret = srq->device->modify_srq(srq, &attr, cmd.attr_mask, &udata);\r\nput_srq_read(srq);\r\nreturn ret ? ret : in_len;\r\n}\r\nssize_t ib_uverbs_query_srq(struct ib_uverbs_file *file,\r\nconst char __user *buf,\r\nint in_len, int out_len)\r\n{\r\nstruct ib_uverbs_query_srq cmd;\r\nstruct ib_uverbs_query_srq_resp resp;\r\nstruct ib_srq_attr attr;\r\nstruct ib_srq *srq;\r\nint ret;\r\nif (out_len < sizeof resp)\r\nreturn -ENOSPC;\r\nif (copy_from_user(&cmd, buf, sizeof cmd))\r\nreturn -EFAULT;\r\nsrq = idr_read_srq(cmd.srq_handle, file->ucontext);\r\nif (!srq)\r\nreturn -EINVAL;\r\nret = ib_query_srq(srq, &attr);\r\nput_srq_read(srq);\r\nif (ret)\r\nreturn ret;\r\nmemset(&resp, 0, sizeof resp);\r\nresp.max_wr = attr.max_wr;\r\nresp.max_sge = attr.max_sge;\r\nresp.srq_limit = attr.srq_limit;\r\nif (copy_to_user((void __user *) (unsigned long) cmd.response,\r\n&resp, sizeof resp))\r\nreturn -EFAULT;\r\nreturn in_len;\r\n}\r\nssize_t ib_uverbs_destroy_srq(struct ib_uverbs_file *file,\r\nconst char __user *buf, int in_len,\r\nint out_len)\r\n{\r\nstruct ib_uverbs_destroy_srq cmd;\r\nstruct ib_uverbs_destroy_srq_resp resp;\r\nstruct ib_uobject *uobj;\r\nstruct ib_srq *srq;\r\nstruct ib_uevent_object *obj;\r\nint ret = -EINVAL;\r\nstruct ib_usrq_object *us;\r\nenum ib_srq_type srq_type;\r\nif (copy_from_user(&cmd, buf, sizeof cmd))\r\nreturn -EFAULT;\r\nuobj = idr_write_uobj(&ib_uverbs_srq_idr, cmd.srq_handle, file->ucontext);\r\nif (!uobj)\r\nreturn -EINVAL;\r\nsrq = uobj->object;\r\nobj = container_of(uobj, struct ib_uevent_object, uobject);\r\nsrq_type = srq->srq_type;\r\nret = ib_destroy_srq(srq);\r\nif (!ret)\r\nuobj->live = 0;\r\nput_uobj_write(uobj);\r\nif (ret)\r\nreturn ret;\r\nif (srq_type == IB_SRQT_XRC) {\r\nus = container_of(obj, struct ib_usrq_object, uevent);\r\natomic_dec(&us->uxrcd->refcnt);\r\n}\r\nidr_remove_uobj(&ib_uverbs_srq_idr, uobj);\r\nmutex_lock(&file->mutex);\r\nlist_del(&uobj->list);\r\nmutex_unlock(&file->mutex);\r\nib_uverbs_release_uevent(file, obj);\r\nmemset(&resp, 0, sizeof resp);\r\nresp.events_reported = obj->events_reported;\r\nput_uobj(uobj);\r\nif (copy_to_user((void __user *) (unsigned long) cmd.response,\r\n&resp, sizeof resp))\r\nret = -EFAULT;\r\nreturn ret ? ret : in_len;\r\n}\r\nint ib_uverbs_ex_query_device(struct ib_uverbs_file *file,\r\nstruct ib_udata *ucore,\r\nstruct ib_udata *uhw)\r\n{\r\nstruct ib_uverbs_ex_query_device_resp resp;\r\nstruct ib_uverbs_ex_query_device cmd;\r\nstruct ib_device_attr attr;\r\nstruct ib_device *device;\r\nint err;\r\ndevice = file->device->ib_dev;\r\nif (ucore->inlen < sizeof(cmd))\r\nreturn -EINVAL;\r\nerr = ib_copy_from_udata(&cmd, ucore, sizeof(cmd));\r\nif (err)\r\nreturn err;\r\nif (cmd.comp_mask)\r\nreturn -EINVAL;\r\nif (cmd.reserved)\r\nreturn -EINVAL;\r\nresp.response_length = offsetof(typeof(resp), odp_caps);\r\nif (ucore->outlen < resp.response_length)\r\nreturn -ENOSPC;\r\nerr = device->query_device(device, &attr);\r\nif (err)\r\nreturn err;\r\ncopy_query_dev_fields(file, &resp.base, &attr);\r\nresp.comp_mask = 0;\r\nif (ucore->outlen < resp.response_length + sizeof(resp.odp_caps))\r\ngoto end;\r\n#ifdef CONFIG_INFINIBAND_ON_DEMAND_PAGING\r\nresp.odp_caps.general_caps = attr.odp_caps.general_caps;\r\nresp.odp_caps.per_transport_caps.rc_odp_caps =\r\nattr.odp_caps.per_transport_caps.rc_odp_caps;\r\nresp.odp_caps.per_transport_caps.uc_odp_caps =\r\nattr.odp_caps.per_transport_caps.uc_odp_caps;\r\nresp.odp_caps.per_transport_caps.ud_odp_caps =\r\nattr.odp_caps.per_transport_caps.ud_odp_caps;\r\nresp.odp_caps.reserved = 0;\r\n#else\r\nmemset(&resp.odp_caps, 0, sizeof(resp.odp_caps));\r\n#endif\r\nresp.response_length += sizeof(resp.odp_caps);\r\nend:\r\nerr = ib_copy_to_udata(ucore, &resp, resp.response_length);\r\nif (err)\r\nreturn err;\r\nreturn 0;\r\n}
