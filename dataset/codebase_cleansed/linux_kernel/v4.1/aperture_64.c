static u32 __init allocate_aperture(void)\r\n{\r\nu32 aper_size;\r\nunsigned long addr;\r\nif (fallback_aper_order > 5)\r\nfallback_aper_order = 5;\r\naper_size = (32 * 1024 * 1024) << fallback_aper_order;\r\naddr = memblock_find_in_range(GART_MIN_ADDR, GART_MAX_ADDR,\r\naper_size, aper_size);\r\nif (!addr) {\r\npr_err("Cannot allocate aperture memory hole [mem %#010lx-%#010lx] (%uKB)\n",\r\naddr, addr + aper_size - 1, aper_size >> 10);\r\nreturn 0;\r\n}\r\nmemblock_reserve(addr, aper_size);\r\npr_info("Mapping aperture over RAM [mem %#010lx-%#010lx] (%uKB)\n",\r\naddr, addr + aper_size - 1, aper_size >> 10);\r\nregister_nosave_region(addr >> PAGE_SHIFT,\r\n(addr+aper_size) >> PAGE_SHIFT);\r\nreturn (u32)addr;\r\n}\r\nstatic u32 __init find_cap(int bus, int slot, int func, int cap)\r\n{\r\nint bytes;\r\nu8 pos;\r\nif (!(read_pci_config_16(bus, slot, func, PCI_STATUS) &\r\nPCI_STATUS_CAP_LIST))\r\nreturn 0;\r\npos = read_pci_config_byte(bus, slot, func, PCI_CAPABILITY_LIST);\r\nfor (bytes = 0; bytes < 48 && pos >= 0x40; bytes++) {\r\nu8 id;\r\npos &= ~3;\r\nid = read_pci_config_byte(bus, slot, func, pos+PCI_CAP_LIST_ID);\r\nif (id == 0xff)\r\nbreak;\r\nif (id == cap)\r\nreturn pos;\r\npos = read_pci_config_byte(bus, slot, func,\r\npos+PCI_CAP_LIST_NEXT);\r\n}\r\nreturn 0;\r\n}\r\nstatic u32 __init read_agp(int bus, int slot, int func, int cap, u32 *order)\r\n{\r\nu32 apsize;\r\nu32 apsizereg;\r\nint nbits;\r\nu32 aper_low, aper_hi;\r\nu64 aper;\r\nu32 old_order;\r\npr_info("pci 0000:%02x:%02x:%02x: AGP bridge\n", bus, slot, func);\r\napsizereg = read_pci_config_16(bus, slot, func, cap + 0x14);\r\nif (apsizereg == 0xffffffff) {\r\npr_err("pci 0000:%02x:%02x.%d: APSIZE unreadable\n",\r\nbus, slot, func);\r\nreturn 0;\r\n}\r\nold_order = *order;\r\napsize = apsizereg & 0xfff;\r\nif (apsize & 0xff)\r\napsize |= 0xf00;\r\nnbits = hweight16(apsize);\r\n*order = 7 - nbits;\r\nif ((int)*order < 0)\r\n*order = 0;\r\naper_low = read_pci_config(bus, slot, func, 0x10);\r\naper_hi = read_pci_config(bus, slot, func, 0x14);\r\naper = (aper_low & ~((1<<22)-1)) | ((u64)aper_hi << 32);\r\npr_info("pci 0000:%02x:%02x.%d: AGP aperture [bus addr %#010Lx-%#010Lx] (old size %uMB)\n",\r\nbus, slot, func, aper, aper + (32ULL << (old_order + 20)) - 1,\r\n32 << old_order);\r\nif (aper + (32ULL<<(20 + *order)) > 0x100000000ULL) {\r\npr_info("pci 0000:%02x:%02x.%d: AGP aperture size %uMB (APSIZE %#x) is not right, using settings from NB\n",\r\nbus, slot, func, 32 << *order, apsizereg);\r\n*order = old_order;\r\n}\r\npr_info("pci 0000:%02x:%02x.%d: AGP aperture [bus addr %#010Lx-%#010Lx] (%uMB, APSIZE %#x)\n",\r\nbus, slot, func, aper, aper + (32ULL << (*order + 20)) - 1,\r\n32 << *order, apsizereg);\r\nif (!aperture_valid(aper, (32*1024*1024) << *order, 32<<20))\r\nreturn 0;\r\nreturn (u32)aper;\r\n}\r\nstatic u32 __init search_agp_bridge(u32 *order, int *valid_agp)\r\n{\r\nint bus, slot, func;\r\nfor (bus = 0; bus < 256; bus++) {\r\nfor (slot = 0; slot < 32; slot++) {\r\nfor (func = 0; func < 8; func++) {\r\nu32 class, cap;\r\nu8 type;\r\nclass = read_pci_config(bus, slot, func,\r\nPCI_CLASS_REVISION);\r\nif (class == 0xffffffff)\r\nbreak;\r\nswitch (class >> 16) {\r\ncase PCI_CLASS_BRIDGE_HOST:\r\ncase PCI_CLASS_BRIDGE_OTHER:\r\ncap = find_cap(bus, slot, func,\r\nPCI_CAP_ID_AGP);\r\nif (!cap)\r\nbreak;\r\n*valid_agp = 1;\r\nreturn read_agp(bus, slot, func, cap,\r\norder);\r\n}\r\ntype = read_pci_config_byte(bus, slot, func,\r\nPCI_HEADER_TYPE);\r\nif (!(type & 0x80))\r\nbreak;\r\n}\r\n}\r\n}\r\npr_info("No AGP bridge found\n");\r\nreturn 0;\r\n}\r\nstatic int __init parse_gart_mem(char *p)\r\n{\r\nif (!p)\r\nreturn -EINVAL;\r\nif (!strncmp(p, "off", 3))\r\ngart_fix_e820 = 0;\r\nelse if (!strncmp(p, "on", 2))\r\ngart_fix_e820 = 1;\r\nreturn 0;\r\n}\r\nvoid __init early_gart_iommu_check(void)\r\n{\r\nu32 agp_aper_order = 0;\r\nint i, fix, slot, valid_agp = 0;\r\nu32 ctl;\r\nu32 aper_size = 0, aper_order = 0, last_aper_order = 0;\r\nu64 aper_base = 0, last_aper_base = 0;\r\nint aper_enabled = 0, last_aper_enabled = 0, last_valid = 0;\r\nif (!early_pci_allowed())\r\nreturn;\r\nsearch_agp_bridge(&agp_aper_order, &valid_agp);\r\nfix = 0;\r\nfor (i = 0; amd_nb_bus_dev_ranges[i].dev_limit; i++) {\r\nint bus;\r\nint dev_base, dev_limit;\r\nbus = amd_nb_bus_dev_ranges[i].bus;\r\ndev_base = amd_nb_bus_dev_ranges[i].dev_base;\r\ndev_limit = amd_nb_bus_dev_ranges[i].dev_limit;\r\nfor (slot = dev_base; slot < dev_limit; slot++) {\r\nif (!early_is_amd_nb(read_pci_config(bus, slot, 3, 0x00)))\r\ncontinue;\r\nctl = read_pci_config(bus, slot, 3, AMD64_GARTAPERTURECTL);\r\naper_enabled = ctl & GARTEN;\r\naper_order = (ctl >> 1) & 7;\r\naper_size = (32 * 1024 * 1024) << aper_order;\r\naper_base = read_pci_config(bus, slot, 3, AMD64_GARTAPERTUREBASE) & 0x7fff;\r\naper_base <<= 25;\r\nif (last_valid) {\r\nif ((aper_order != last_aper_order) ||\r\n(aper_base != last_aper_base) ||\r\n(aper_enabled != last_aper_enabled)) {\r\nfix = 1;\r\nbreak;\r\n}\r\n}\r\nlast_aper_order = aper_order;\r\nlast_aper_base = aper_base;\r\nlast_aper_enabled = aper_enabled;\r\nlast_valid = 1;\r\n}\r\n}\r\nif (!fix && !aper_enabled)\r\nreturn;\r\nif (!aper_base || !aper_size || aper_base + aper_size > 0x100000000UL)\r\nfix = 1;\r\nif (gart_fix_e820 && !fix && aper_enabled) {\r\nif (e820_any_mapped(aper_base, aper_base + aper_size,\r\nE820_RAM)) {\r\npr_info("e820: reserve [mem %#010Lx-%#010Lx] for GART\n",\r\naper_base, aper_base + aper_size - 1);\r\ne820_add_region(aper_base, aper_size, E820_RESERVED);\r\nupdate_e820();\r\n}\r\n}\r\nif (valid_agp)\r\nreturn;\r\nfor (i = 0; i < amd_nb_bus_dev_ranges[i].dev_limit; i++) {\r\nint bus;\r\nint dev_base, dev_limit;\r\nbus = amd_nb_bus_dev_ranges[i].bus;\r\ndev_base = amd_nb_bus_dev_ranges[i].dev_base;\r\ndev_limit = amd_nb_bus_dev_ranges[i].dev_limit;\r\nfor (slot = dev_base; slot < dev_limit; slot++) {\r\nif (!early_is_amd_nb(read_pci_config(bus, slot, 3, 0x00)))\r\ncontinue;\r\nctl = read_pci_config(bus, slot, 3, AMD64_GARTAPERTURECTL);\r\nctl &= ~GARTEN;\r\nwrite_pci_config(bus, slot, 3, AMD64_GARTAPERTURECTL, ctl);\r\n}\r\n}\r\n}\r\nint __init gart_iommu_hole_init(void)\r\n{\r\nu32 agp_aper_base = 0, agp_aper_order = 0;\r\nu32 aper_size, aper_alloc = 0, aper_order = 0, last_aper_order = 0;\r\nu64 aper_base, last_aper_base = 0;\r\nint fix, slot, valid_agp = 0;\r\nint i, node;\r\nif (gart_iommu_aperture_disabled || !fix_aperture ||\r\n!early_pci_allowed())\r\nreturn -ENODEV;\r\npr_info("Checking aperture...\n");\r\nif (!fallback_aper_force)\r\nagp_aper_base = search_agp_bridge(&agp_aper_order, &valid_agp);\r\nfix = 0;\r\nnode = 0;\r\nfor (i = 0; i < amd_nb_bus_dev_ranges[i].dev_limit; i++) {\r\nint bus;\r\nint dev_base, dev_limit;\r\nu32 ctl;\r\nbus = amd_nb_bus_dev_ranges[i].bus;\r\ndev_base = amd_nb_bus_dev_ranges[i].dev_base;\r\ndev_limit = amd_nb_bus_dev_ranges[i].dev_limit;\r\nfor (slot = dev_base; slot < dev_limit; slot++) {\r\nif (!early_is_amd_nb(read_pci_config(bus, slot, 3, 0x00)))\r\ncontinue;\r\niommu_detected = 1;\r\ngart_iommu_aperture = 1;\r\nx86_init.iommu.iommu_init = gart_iommu_init;\r\nctl = read_pci_config(bus, slot, 3,\r\nAMD64_GARTAPERTURECTL);\r\nctl &= ~GARTEN;\r\nwrite_pci_config(bus, slot, 3, AMD64_GARTAPERTURECTL, ctl);\r\naper_order = (ctl >> 1) & 7;\r\naper_size = (32 * 1024 * 1024) << aper_order;\r\naper_base = read_pci_config(bus, slot, 3, AMD64_GARTAPERTUREBASE) & 0x7fff;\r\naper_base <<= 25;\r\npr_info("Node %d: aperture [bus addr %#010Lx-%#010Lx] (%uMB)\n",\r\nnode, aper_base, aper_base + aper_size - 1,\r\naper_size >> 20);\r\nnode++;\r\nif (!aperture_valid(aper_base, aper_size, 64<<20)) {\r\nif (valid_agp && agp_aper_base &&\r\nagp_aper_base == aper_base &&\r\nagp_aper_order == aper_order) {\r\nif (!no_iommu &&\r\nmax_pfn > MAX_DMA32_PFN &&\r\n!printed_gart_size_msg) {\r\npr_err("you are using iommu with agp, but GART size is less than 64MB\n");\r\npr_err("please increase GART size in your BIOS setup\n");\r\npr_err("if BIOS doesn't have that option, contact your HW vendor!\n");\r\nprinted_gart_size_msg = 1;\r\n}\r\n} else {\r\nfix = 1;\r\ngoto out;\r\n}\r\n}\r\nif ((last_aper_order && aper_order != last_aper_order) ||\r\n(last_aper_base && aper_base != last_aper_base)) {\r\nfix = 1;\r\ngoto out;\r\n}\r\nlast_aper_order = aper_order;\r\nlast_aper_base = aper_base;\r\n}\r\n}\r\nout:\r\nif (!fix && !fallback_aper_force) {\r\nif (last_aper_base)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nif (!fallback_aper_force) {\r\naper_alloc = agp_aper_base;\r\naper_order = agp_aper_order;\r\n}\r\nif (aper_alloc) {\r\n} else if ((!no_iommu && max_pfn > MAX_DMA32_PFN) ||\r\nforce_iommu ||\r\nvalid_agp ||\r\nfallback_aper_force) {\r\npr_info("Your BIOS doesn't leave a aperture memory hole\n");\r\npr_info("Please enable the IOMMU option in the BIOS setup\n");\r\npr_info("This costs you %dMB of RAM\n",\r\n32 << fallback_aper_order);\r\naper_order = fallback_aper_order;\r\naper_alloc = allocate_aperture();\r\nif (!aper_alloc) {\r\npanic("Not enough memory for aperture");\r\n}\r\n} else {\r\nreturn 0;\r\n}\r\nfor (i = 0; i < amd_nb_bus_dev_ranges[i].dev_limit; i++) {\r\nint bus, dev_base, dev_limit;\r\nu32 ctl = aper_order << 1;\r\nbus = amd_nb_bus_dev_ranges[i].bus;\r\ndev_base = amd_nb_bus_dev_ranges[i].dev_base;\r\ndev_limit = amd_nb_bus_dev_ranges[i].dev_limit;\r\nfor (slot = dev_base; slot < dev_limit; slot++) {\r\nif (!early_is_amd_nb(read_pci_config(bus, slot, 3, 0x00)))\r\ncontinue;\r\nwrite_pci_config(bus, slot, 3, AMD64_GARTAPERTURECTL, ctl);\r\nwrite_pci_config(bus, slot, 3, AMD64_GARTAPERTUREBASE, aper_alloc >> 25);\r\n}\r\n}\r\nset_up_gart_resume(aper_order, aper_alloc);\r\nreturn 1;\r\n}
