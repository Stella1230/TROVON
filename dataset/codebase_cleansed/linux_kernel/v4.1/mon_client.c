struct ceph_monmap *ceph_monmap_decode(void *p, void *end)\r\n{\r\nstruct ceph_monmap *m = NULL;\r\nint i, err = -EINVAL;\r\nstruct ceph_fsid fsid;\r\nu32 epoch, num_mon;\r\nu16 version;\r\nu32 len;\r\nceph_decode_32_safe(&p, end, len, bad);\r\nceph_decode_need(&p, end, len, bad);\r\ndout("monmap_decode %p %p len %d\n", p, end, (int)(end-p));\r\nceph_decode_16_safe(&p, end, version, bad);\r\nceph_decode_need(&p, end, sizeof(fsid) + 2*sizeof(u32), bad);\r\nceph_decode_copy(&p, &fsid, sizeof(fsid));\r\nepoch = ceph_decode_32(&p);\r\nnum_mon = ceph_decode_32(&p);\r\nceph_decode_need(&p, end, num_mon*sizeof(m->mon_inst[0]), bad);\r\nif (num_mon >= CEPH_MAX_MON)\r\ngoto bad;\r\nm = kmalloc(sizeof(*m) + sizeof(m->mon_inst[0])*num_mon, GFP_NOFS);\r\nif (m == NULL)\r\nreturn ERR_PTR(-ENOMEM);\r\nm->fsid = fsid;\r\nm->epoch = epoch;\r\nm->num_mon = num_mon;\r\nceph_decode_copy(&p, m->mon_inst, num_mon*sizeof(m->mon_inst[0]));\r\nfor (i = 0; i < num_mon; i++)\r\nceph_decode_addr(&m->mon_inst[i].addr);\r\ndout("monmap_decode epoch %d, num_mon %d\n", m->epoch,\r\nm->num_mon);\r\nfor (i = 0; i < m->num_mon; i++)\r\ndout("monmap_decode mon%d is %s\n", i,\r\nceph_pr_addr(&m->mon_inst[i].addr.in_addr));\r\nreturn m;\r\nbad:\r\ndout("monmap_decode failed with %d\n", err);\r\nkfree(m);\r\nreturn ERR_PTR(err);\r\n}\r\nint ceph_monmap_contains(struct ceph_monmap *m, struct ceph_entity_addr *addr)\r\n{\r\nint i;\r\nfor (i = 0; i < m->num_mon; i++)\r\nif (memcmp(addr, &m->mon_inst[i].addr, sizeof(*addr)) == 0)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic void __send_prepared_auth_request(struct ceph_mon_client *monc, int len)\r\n{\r\nmonc->pending_auth = 1;\r\nmonc->m_auth->front.iov_len = len;\r\nmonc->m_auth->hdr.front_len = cpu_to_le32(len);\r\nceph_msg_revoke(monc->m_auth);\r\nceph_msg_get(monc->m_auth);\r\nceph_con_send(&monc->con, monc->m_auth);\r\n}\r\nstatic void __close_session(struct ceph_mon_client *monc)\r\n{\r\ndout("__close_session closing mon%d\n", monc->cur_mon);\r\nceph_msg_revoke(monc->m_auth);\r\nceph_msg_revoke_incoming(monc->m_auth_reply);\r\nceph_msg_revoke(monc->m_subscribe);\r\nceph_msg_revoke_incoming(monc->m_subscribe_ack);\r\nceph_con_close(&monc->con);\r\nmonc->cur_mon = -1;\r\nmonc->pending_auth = 0;\r\nceph_auth_reset(monc->auth);\r\n}\r\nstatic int __open_session(struct ceph_mon_client *monc)\r\n{\r\nchar r;\r\nint ret;\r\nif (monc->cur_mon < 0) {\r\nget_random_bytes(&r, 1);\r\nmonc->cur_mon = r % monc->monmap->num_mon;\r\ndout("open_session num=%d r=%d -> mon%d\n",\r\nmonc->monmap->num_mon, r, monc->cur_mon);\r\nmonc->sub_sent = 0;\r\nmonc->sub_renew_after = jiffies;\r\nmonc->want_next_osdmap = !!monc->want_next_osdmap;\r\ndout("open_session mon%d opening\n", monc->cur_mon);\r\nceph_con_open(&monc->con,\r\nCEPH_ENTITY_TYPE_MON, monc->cur_mon,\r\n&monc->monmap->mon_inst[monc->cur_mon].addr);\r\nret = ceph_auth_build_hello(monc->auth,\r\nmonc->m_auth->front.iov_base,\r\nmonc->m_auth->front_alloc_len);\r\n__send_prepared_auth_request(monc, ret);\r\n} else {\r\ndout("open_session mon%d already open\n", monc->cur_mon);\r\n}\r\nreturn 0;\r\n}\r\nstatic bool __sub_expired(struct ceph_mon_client *monc)\r\n{\r\nreturn time_after_eq(jiffies, monc->sub_renew_after);\r\n}\r\nstatic void __schedule_delayed(struct ceph_mon_client *monc)\r\n{\r\nunsigned int delay;\r\nif (monc->cur_mon < 0 || __sub_expired(monc))\r\ndelay = 10 * HZ;\r\nelse\r\ndelay = 20 * HZ;\r\ndout("__schedule_delayed after %u\n", delay);\r\nschedule_delayed_work(&monc->delayed_work, delay);\r\n}\r\nstatic void __send_subscribe(struct ceph_mon_client *monc)\r\n{\r\ndout("__send_subscribe sub_sent=%u exp=%u want_osd=%d\n",\r\n(unsigned int)monc->sub_sent, __sub_expired(monc),\r\nmonc->want_next_osdmap);\r\nif ((__sub_expired(monc) && !monc->sub_sent) ||\r\nmonc->want_next_osdmap == 1) {\r\nstruct ceph_msg *msg = monc->m_subscribe;\r\nstruct ceph_mon_subscribe_item *i;\r\nvoid *p, *end;\r\nint num;\r\np = msg->front.iov_base;\r\nend = p + msg->front_alloc_len;\r\nnum = 1 + !!monc->want_next_osdmap + !!monc->want_mdsmap;\r\nceph_encode_32(&p, num);\r\nif (monc->want_next_osdmap) {\r\ndout("__send_subscribe to 'osdmap' %u\n",\r\n(unsigned int)monc->have_osdmap);\r\nceph_encode_string(&p, end, "osdmap", 6);\r\ni = p;\r\ni->have = cpu_to_le64(monc->have_osdmap);\r\ni->onetime = 1;\r\np += sizeof(*i);\r\nmonc->want_next_osdmap = 2;\r\n}\r\nif (monc->want_mdsmap) {\r\ndout("__send_subscribe to 'mdsmap' %u+\n",\r\n(unsigned int)monc->have_mdsmap);\r\nceph_encode_string(&p, end, "mdsmap", 6);\r\ni = p;\r\ni->have = cpu_to_le64(monc->have_mdsmap);\r\ni->onetime = 0;\r\np += sizeof(*i);\r\n}\r\nceph_encode_string(&p, end, "monmap", 6);\r\ni = p;\r\ni->have = 0;\r\ni->onetime = 0;\r\np += sizeof(*i);\r\nmsg->front.iov_len = p - msg->front.iov_base;\r\nmsg->hdr.front_len = cpu_to_le32(msg->front.iov_len);\r\nceph_msg_revoke(msg);\r\nceph_con_send(&monc->con, ceph_msg_get(msg));\r\nmonc->sub_sent = jiffies | 1;\r\n}\r\n}\r\nstatic void handle_subscribe_ack(struct ceph_mon_client *monc,\r\nstruct ceph_msg *msg)\r\n{\r\nunsigned int seconds;\r\nstruct ceph_mon_subscribe_ack *h = msg->front.iov_base;\r\nif (msg->front.iov_len < sizeof(*h))\r\ngoto bad;\r\nseconds = le32_to_cpu(h->duration);\r\nmutex_lock(&monc->mutex);\r\nif (monc->hunting) {\r\npr_info("mon%d %s session established\n",\r\nmonc->cur_mon,\r\nceph_pr_addr(&monc->con.peer_addr.in_addr));\r\nmonc->hunting = false;\r\n}\r\ndout("handle_subscribe_ack after %d seconds\n", seconds);\r\nmonc->sub_renew_after = monc->sub_sent + (seconds >> 1)*HZ - 1;\r\nmonc->sub_sent = 0;\r\nmutex_unlock(&monc->mutex);\r\nreturn;\r\nbad:\r\npr_err("got corrupt subscribe-ack msg\n");\r\nceph_msg_dump(msg);\r\n}\r\nint ceph_monc_got_mdsmap(struct ceph_mon_client *monc, u32 got)\r\n{\r\nmutex_lock(&monc->mutex);\r\nmonc->have_mdsmap = got;\r\nmutex_unlock(&monc->mutex);\r\nreturn 0;\r\n}\r\nint ceph_monc_got_osdmap(struct ceph_mon_client *monc, u32 got)\r\n{\r\nmutex_lock(&monc->mutex);\r\nmonc->have_osdmap = got;\r\nmonc->want_next_osdmap = 0;\r\nmutex_unlock(&monc->mutex);\r\nreturn 0;\r\n}\r\nvoid ceph_monc_request_next_osdmap(struct ceph_mon_client *monc)\r\n{\r\ndout("request_next_osdmap have %u\n", monc->have_osdmap);\r\nmutex_lock(&monc->mutex);\r\nif (!monc->want_next_osdmap)\r\nmonc->want_next_osdmap = 1;\r\nif (monc->want_next_osdmap < 2)\r\n__send_subscribe(monc);\r\nmutex_unlock(&monc->mutex);\r\n}\r\nint ceph_monc_wait_osdmap(struct ceph_mon_client *monc, u32 epoch,\r\nunsigned long timeout)\r\n{\r\nunsigned long started = jiffies;\r\nint ret;\r\nmutex_lock(&monc->mutex);\r\nwhile (monc->have_osdmap < epoch) {\r\nmutex_unlock(&monc->mutex);\r\nif (timeout != 0 && time_after_eq(jiffies, started + timeout))\r\nreturn -ETIMEDOUT;\r\nret = wait_event_interruptible_timeout(monc->client->auth_wq,\r\nmonc->have_osdmap >= epoch, timeout);\r\nif (ret < 0)\r\nreturn ret;\r\nmutex_lock(&monc->mutex);\r\n}\r\nmutex_unlock(&monc->mutex);\r\nreturn 0;\r\n}\r\nint ceph_monc_open_session(struct ceph_mon_client *monc)\r\n{\r\nmutex_lock(&monc->mutex);\r\n__open_session(monc);\r\n__schedule_delayed(monc);\r\nmutex_unlock(&monc->mutex);\r\nreturn 0;\r\n}\r\nstatic bool have_debugfs_info(struct ceph_mon_client *monc)\r\n{\r\ndout("have_debugfs_info fsid %d globalid %lld\n",\r\n(int)monc->client->have_fsid, monc->auth->global_id);\r\nreturn monc->client->have_fsid && monc->auth->global_id > 0;\r\n}\r\nstatic void ceph_monc_handle_map(struct ceph_mon_client *monc,\r\nstruct ceph_msg *msg)\r\n{\r\nstruct ceph_client *client = monc->client;\r\nstruct ceph_monmap *monmap = NULL, *old = monc->monmap;\r\nvoid *p, *end;\r\nint had_debugfs_info, init_debugfs = 0;\r\nmutex_lock(&monc->mutex);\r\nhad_debugfs_info = have_debugfs_info(monc);\r\ndout("handle_monmap\n");\r\np = msg->front.iov_base;\r\nend = p + msg->front.iov_len;\r\nmonmap = ceph_monmap_decode(p, end);\r\nif (IS_ERR(monmap)) {\r\npr_err("problem decoding monmap, %d\n",\r\n(int)PTR_ERR(monmap));\r\ngoto out;\r\n}\r\nif (ceph_check_fsid(monc->client, &monmap->fsid) < 0) {\r\nkfree(monmap);\r\ngoto out;\r\n}\r\nclient->monc.monmap = monmap;\r\nkfree(old);\r\nif (!client->have_fsid) {\r\nclient->have_fsid = true;\r\nif (!had_debugfs_info && have_debugfs_info(monc)) {\r\npr_info("client%lld fsid %pU\n",\r\nceph_client_id(monc->client),\r\n&monc->client->fsid);\r\ninit_debugfs = 1;\r\n}\r\nmutex_unlock(&monc->mutex);\r\nif (init_debugfs) {\r\nceph_debugfs_client_init(monc->client);\r\n}\r\ngoto out_unlocked;\r\n}\r\nout:\r\nmutex_unlock(&monc->mutex);\r\nout_unlocked:\r\nwake_up_all(&client->auth_wq);\r\n}\r\nstatic struct ceph_mon_generic_request *__lookup_generic_req(\r\nstruct ceph_mon_client *monc, u64 tid)\r\n{\r\nstruct ceph_mon_generic_request *req;\r\nstruct rb_node *n = monc->generic_request_tree.rb_node;\r\nwhile (n) {\r\nreq = rb_entry(n, struct ceph_mon_generic_request, node);\r\nif (tid < req->tid)\r\nn = n->rb_left;\r\nelse if (tid > req->tid)\r\nn = n->rb_right;\r\nelse\r\nreturn req;\r\n}\r\nreturn NULL;\r\n}\r\nstatic void __insert_generic_request(struct ceph_mon_client *monc,\r\nstruct ceph_mon_generic_request *new)\r\n{\r\nstruct rb_node **p = &monc->generic_request_tree.rb_node;\r\nstruct rb_node *parent = NULL;\r\nstruct ceph_mon_generic_request *req = NULL;\r\nwhile (*p) {\r\nparent = *p;\r\nreq = rb_entry(parent, struct ceph_mon_generic_request, node);\r\nif (new->tid < req->tid)\r\np = &(*p)->rb_left;\r\nelse if (new->tid > req->tid)\r\np = &(*p)->rb_right;\r\nelse\r\nBUG();\r\n}\r\nrb_link_node(&new->node, parent, p);\r\nrb_insert_color(&new->node, &monc->generic_request_tree);\r\n}\r\nstatic void release_generic_request(struct kref *kref)\r\n{\r\nstruct ceph_mon_generic_request *req =\r\ncontainer_of(kref, struct ceph_mon_generic_request, kref);\r\nif (req->reply)\r\nceph_msg_put(req->reply);\r\nif (req->request)\r\nceph_msg_put(req->request);\r\nkfree(req);\r\n}\r\nstatic void put_generic_request(struct ceph_mon_generic_request *req)\r\n{\r\nkref_put(&req->kref, release_generic_request);\r\n}\r\nstatic void get_generic_request(struct ceph_mon_generic_request *req)\r\n{\r\nkref_get(&req->kref);\r\n}\r\nstatic struct ceph_msg *get_generic_reply(struct ceph_connection *con,\r\nstruct ceph_msg_header *hdr,\r\nint *skip)\r\n{\r\nstruct ceph_mon_client *monc = con->private;\r\nstruct ceph_mon_generic_request *req;\r\nu64 tid = le64_to_cpu(hdr->tid);\r\nstruct ceph_msg *m;\r\nmutex_lock(&monc->mutex);\r\nreq = __lookup_generic_req(monc, tid);\r\nif (!req) {\r\ndout("get_generic_reply %lld dne\n", tid);\r\n*skip = 1;\r\nm = NULL;\r\n} else {\r\ndout("get_generic_reply %lld got %p\n", tid, req->reply);\r\n*skip = 0;\r\nm = ceph_msg_get(req->reply);\r\n}\r\nmutex_unlock(&monc->mutex);\r\nreturn m;\r\n}\r\nstatic int __do_generic_request(struct ceph_mon_client *monc, u64 tid,\r\nstruct ceph_mon_generic_request *req)\r\n{\r\nint err;\r\nreq->tid = tid != 0 ? tid : ++monc->last_tid;\r\nreq->request->hdr.tid = cpu_to_le64(req->tid);\r\n__insert_generic_request(monc, req);\r\nmonc->num_generic_requests++;\r\nceph_con_send(&monc->con, ceph_msg_get(req->request));\r\nmutex_unlock(&monc->mutex);\r\nerr = wait_for_completion_interruptible(&req->completion);\r\nmutex_lock(&monc->mutex);\r\nrb_erase(&req->node, &monc->generic_request_tree);\r\nmonc->num_generic_requests--;\r\nif (!err)\r\nerr = req->result;\r\nreturn err;\r\n}\r\nstatic int do_generic_request(struct ceph_mon_client *monc,\r\nstruct ceph_mon_generic_request *req)\r\n{\r\nint err;\r\nmutex_lock(&monc->mutex);\r\nerr = __do_generic_request(monc, 0, req);\r\nmutex_unlock(&monc->mutex);\r\nreturn err;\r\n}\r\nstatic void handle_statfs_reply(struct ceph_mon_client *monc,\r\nstruct ceph_msg *msg)\r\n{\r\nstruct ceph_mon_generic_request *req;\r\nstruct ceph_mon_statfs_reply *reply = msg->front.iov_base;\r\nu64 tid = le64_to_cpu(msg->hdr.tid);\r\nif (msg->front.iov_len != sizeof(*reply))\r\ngoto bad;\r\ndout("handle_statfs_reply %p tid %llu\n", msg, tid);\r\nmutex_lock(&monc->mutex);\r\nreq = __lookup_generic_req(monc, tid);\r\nif (req) {\r\n*(struct ceph_statfs *)req->buf = reply->st;\r\nreq->result = 0;\r\nget_generic_request(req);\r\n}\r\nmutex_unlock(&monc->mutex);\r\nif (req) {\r\ncomplete_all(&req->completion);\r\nput_generic_request(req);\r\n}\r\nreturn;\r\nbad:\r\npr_err("corrupt statfs reply, tid %llu\n", tid);\r\nceph_msg_dump(msg);\r\n}\r\nint ceph_monc_do_statfs(struct ceph_mon_client *monc, struct ceph_statfs *buf)\r\n{\r\nstruct ceph_mon_generic_request *req;\r\nstruct ceph_mon_statfs *h;\r\nint err;\r\nreq = kzalloc(sizeof(*req), GFP_NOFS);\r\nif (!req)\r\nreturn -ENOMEM;\r\nkref_init(&req->kref);\r\nreq->buf = buf;\r\ninit_completion(&req->completion);\r\nerr = -ENOMEM;\r\nreq->request = ceph_msg_new(CEPH_MSG_STATFS, sizeof(*h), GFP_NOFS,\r\ntrue);\r\nif (!req->request)\r\ngoto out;\r\nreq->reply = ceph_msg_new(CEPH_MSG_STATFS_REPLY, 1024, GFP_NOFS,\r\ntrue);\r\nif (!req->reply)\r\ngoto out;\r\nh = req->request->front.iov_base;\r\nh->monhdr.have_version = 0;\r\nh->monhdr.session_mon = cpu_to_le16(-1);\r\nh->monhdr.session_mon_tid = 0;\r\nh->fsid = monc->monmap->fsid;\r\nerr = do_generic_request(monc, req);\r\nout:\r\nput_generic_request(req);\r\nreturn err;\r\n}\r\nstatic void handle_get_version_reply(struct ceph_mon_client *monc,\r\nstruct ceph_msg *msg)\r\n{\r\nstruct ceph_mon_generic_request *req;\r\nu64 tid = le64_to_cpu(msg->hdr.tid);\r\nvoid *p = msg->front.iov_base;\r\nvoid *end = p + msg->front_alloc_len;\r\nu64 handle;\r\ndout("%s %p tid %llu\n", __func__, msg, tid);\r\nceph_decode_need(&p, end, 2*sizeof(u64), bad);\r\nhandle = ceph_decode_64(&p);\r\nif (tid != 0 && tid != handle)\r\ngoto bad;\r\nmutex_lock(&monc->mutex);\r\nreq = __lookup_generic_req(monc, handle);\r\nif (req) {\r\n*(u64 *)req->buf = ceph_decode_64(&p);\r\nreq->result = 0;\r\nget_generic_request(req);\r\n}\r\nmutex_unlock(&monc->mutex);\r\nif (req) {\r\ncomplete_all(&req->completion);\r\nput_generic_request(req);\r\n}\r\nreturn;\r\nbad:\r\npr_err("corrupt mon_get_version reply, tid %llu\n", tid);\r\nceph_msg_dump(msg);\r\n}\r\nint ceph_monc_do_get_version(struct ceph_mon_client *monc, const char *what,\r\nu64 *newest)\r\n{\r\nstruct ceph_mon_generic_request *req;\r\nvoid *p, *end;\r\nu64 tid;\r\nint err;\r\nreq = kzalloc(sizeof(*req), GFP_NOFS);\r\nif (!req)\r\nreturn -ENOMEM;\r\nkref_init(&req->kref);\r\nreq->buf = newest;\r\ninit_completion(&req->completion);\r\nreq->request = ceph_msg_new(CEPH_MSG_MON_GET_VERSION,\r\nsizeof(u64) + sizeof(u32) + strlen(what),\r\nGFP_NOFS, true);\r\nif (!req->request) {\r\nerr = -ENOMEM;\r\ngoto out;\r\n}\r\nreq->reply = ceph_msg_new(CEPH_MSG_MON_GET_VERSION_REPLY, 1024,\r\nGFP_NOFS, true);\r\nif (!req->reply) {\r\nerr = -ENOMEM;\r\ngoto out;\r\n}\r\np = req->request->front.iov_base;\r\nend = p + req->request->front_alloc_len;\r\nmutex_lock(&monc->mutex);\r\ntid = ++monc->last_tid;\r\nceph_encode_64(&p, tid);\r\nceph_encode_string(&p, end, what, strlen(what));\r\nerr = __do_generic_request(monc, tid, req);\r\nmutex_unlock(&monc->mutex);\r\nout:\r\nput_generic_request(req);\r\nreturn err;\r\n}\r\nstatic void __resend_generic_request(struct ceph_mon_client *monc)\r\n{\r\nstruct ceph_mon_generic_request *req;\r\nstruct rb_node *p;\r\nfor (p = rb_first(&monc->generic_request_tree); p; p = rb_next(p)) {\r\nreq = rb_entry(p, struct ceph_mon_generic_request, node);\r\nceph_msg_revoke(req->request);\r\nceph_msg_revoke_incoming(req->reply);\r\nceph_con_send(&monc->con, ceph_msg_get(req->request));\r\n}\r\n}\r\nstatic void delayed_work(struct work_struct *work)\r\n{\r\nstruct ceph_mon_client *monc =\r\ncontainer_of(work, struct ceph_mon_client, delayed_work.work);\r\ndout("monc delayed_work\n");\r\nmutex_lock(&monc->mutex);\r\nif (monc->hunting) {\r\n__close_session(monc);\r\n__open_session(monc);\r\n} else {\r\nceph_con_keepalive(&monc->con);\r\n__validate_auth(monc);\r\nif (ceph_auth_is_authenticated(monc->auth))\r\n__send_subscribe(monc);\r\n}\r\n__schedule_delayed(monc);\r\nmutex_unlock(&monc->mutex);\r\n}\r\nstatic int build_initial_monmap(struct ceph_mon_client *monc)\r\n{\r\nstruct ceph_options *opt = monc->client->options;\r\nstruct ceph_entity_addr *mon_addr = opt->mon_addr;\r\nint num_mon = opt->num_mon;\r\nint i;\r\nmonc->monmap = kzalloc(sizeof(*monc->monmap) +\r\nnum_mon*sizeof(monc->monmap->mon_inst[0]),\r\nGFP_KERNEL);\r\nif (!monc->monmap)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < num_mon; i++) {\r\nmonc->monmap->mon_inst[i].addr = mon_addr[i];\r\nmonc->monmap->mon_inst[i].addr.nonce = 0;\r\nmonc->monmap->mon_inst[i].name.type =\r\nCEPH_ENTITY_TYPE_MON;\r\nmonc->monmap->mon_inst[i].name.num = cpu_to_le64(i);\r\n}\r\nmonc->monmap->num_mon = num_mon;\r\nreturn 0;\r\n}\r\nint ceph_monc_init(struct ceph_mon_client *monc, struct ceph_client *cl)\r\n{\r\nint err = 0;\r\ndout("init\n");\r\nmemset(monc, 0, sizeof(*monc));\r\nmonc->client = cl;\r\nmonc->monmap = NULL;\r\nmutex_init(&monc->mutex);\r\nerr = build_initial_monmap(monc);\r\nif (err)\r\ngoto out;\r\nmonc->auth = ceph_auth_init(cl->options->name,\r\ncl->options->key);\r\nif (IS_ERR(monc->auth)) {\r\nerr = PTR_ERR(monc->auth);\r\ngoto out_monmap;\r\n}\r\nmonc->auth->want_keys =\r\nCEPH_ENTITY_TYPE_AUTH | CEPH_ENTITY_TYPE_MON |\r\nCEPH_ENTITY_TYPE_OSD | CEPH_ENTITY_TYPE_MDS;\r\nerr = -ENOMEM;\r\nmonc->m_subscribe_ack = ceph_msg_new(CEPH_MSG_MON_SUBSCRIBE_ACK,\r\nsizeof(struct ceph_mon_subscribe_ack),\r\nGFP_NOFS, true);\r\nif (!monc->m_subscribe_ack)\r\ngoto out_auth;\r\nmonc->m_subscribe = ceph_msg_new(CEPH_MSG_MON_SUBSCRIBE, 96, GFP_NOFS,\r\ntrue);\r\nif (!monc->m_subscribe)\r\ngoto out_subscribe_ack;\r\nmonc->m_auth_reply = ceph_msg_new(CEPH_MSG_AUTH_REPLY, 4096, GFP_NOFS,\r\ntrue);\r\nif (!monc->m_auth_reply)\r\ngoto out_subscribe;\r\nmonc->m_auth = ceph_msg_new(CEPH_MSG_AUTH, 4096, GFP_NOFS, true);\r\nmonc->pending_auth = 0;\r\nif (!monc->m_auth)\r\ngoto out_auth_reply;\r\nceph_con_init(&monc->con, monc, &mon_con_ops,\r\n&monc->client->msgr);\r\nmonc->cur_mon = -1;\r\nmonc->hunting = true;\r\nmonc->sub_renew_after = jiffies;\r\nmonc->sub_sent = 0;\r\nINIT_DELAYED_WORK(&monc->delayed_work, delayed_work);\r\nmonc->generic_request_tree = RB_ROOT;\r\nmonc->num_generic_requests = 0;\r\nmonc->last_tid = 0;\r\nmonc->have_mdsmap = 0;\r\nmonc->have_osdmap = 0;\r\nmonc->want_next_osdmap = 1;\r\nreturn 0;\r\nout_auth_reply:\r\nceph_msg_put(monc->m_auth_reply);\r\nout_subscribe:\r\nceph_msg_put(monc->m_subscribe);\r\nout_subscribe_ack:\r\nceph_msg_put(monc->m_subscribe_ack);\r\nout_auth:\r\nceph_auth_destroy(monc->auth);\r\nout_monmap:\r\nkfree(monc->monmap);\r\nout:\r\nreturn err;\r\n}\r\nvoid ceph_monc_stop(struct ceph_mon_client *monc)\r\n{\r\ndout("stop\n");\r\ncancel_delayed_work_sync(&monc->delayed_work);\r\nmutex_lock(&monc->mutex);\r\n__close_session(monc);\r\nmutex_unlock(&monc->mutex);\r\nceph_msgr_flush();\r\nceph_auth_destroy(monc->auth);\r\nceph_msg_put(monc->m_auth);\r\nceph_msg_put(monc->m_auth_reply);\r\nceph_msg_put(monc->m_subscribe);\r\nceph_msg_put(monc->m_subscribe_ack);\r\nkfree(monc->monmap);\r\n}\r\nstatic void handle_auth_reply(struct ceph_mon_client *monc,\r\nstruct ceph_msg *msg)\r\n{\r\nint ret;\r\nint was_auth = 0;\r\nint had_debugfs_info, init_debugfs = 0;\r\nmutex_lock(&monc->mutex);\r\nhad_debugfs_info = have_debugfs_info(monc);\r\nwas_auth = ceph_auth_is_authenticated(monc->auth);\r\nmonc->pending_auth = 0;\r\nret = ceph_handle_auth_reply(monc->auth, msg->front.iov_base,\r\nmsg->front.iov_len,\r\nmonc->m_auth->front.iov_base,\r\nmonc->m_auth->front_alloc_len);\r\nif (ret < 0) {\r\nmonc->client->auth_err = ret;\r\nwake_up_all(&monc->client->auth_wq);\r\n} else if (ret > 0) {\r\n__send_prepared_auth_request(monc, ret);\r\n} else if (!was_auth && ceph_auth_is_authenticated(monc->auth)) {\r\ndout("authenticated, starting session\n");\r\nmonc->client->msgr.inst.name.type = CEPH_ENTITY_TYPE_CLIENT;\r\nmonc->client->msgr.inst.name.num =\r\ncpu_to_le64(monc->auth->global_id);\r\n__send_subscribe(monc);\r\n__resend_generic_request(monc);\r\n}\r\nif (!had_debugfs_info && have_debugfs_info(monc)) {\r\npr_info("client%lld fsid %pU\n",\r\nceph_client_id(monc->client),\r\n&monc->client->fsid);\r\ninit_debugfs = 1;\r\n}\r\nmutex_unlock(&monc->mutex);\r\nif (init_debugfs) {\r\nceph_debugfs_client_init(monc->client);\r\n}\r\n}\r\nstatic int __validate_auth(struct ceph_mon_client *monc)\r\n{\r\nint ret;\r\nif (monc->pending_auth)\r\nreturn 0;\r\nret = ceph_build_auth(monc->auth, monc->m_auth->front.iov_base,\r\nmonc->m_auth->front_alloc_len);\r\nif (ret <= 0)\r\nreturn ret;\r\n__send_prepared_auth_request(monc, ret);\r\nreturn 0;\r\n}\r\nint ceph_monc_validate_auth(struct ceph_mon_client *monc)\r\n{\r\nint ret;\r\nmutex_lock(&monc->mutex);\r\nret = __validate_auth(monc);\r\nmutex_unlock(&monc->mutex);\r\nreturn ret;\r\n}\r\nstatic void dispatch(struct ceph_connection *con, struct ceph_msg *msg)\r\n{\r\nstruct ceph_mon_client *monc = con->private;\r\nint type = le16_to_cpu(msg->hdr.type);\r\nif (!monc)\r\nreturn;\r\nswitch (type) {\r\ncase CEPH_MSG_AUTH_REPLY:\r\nhandle_auth_reply(monc, msg);\r\nbreak;\r\ncase CEPH_MSG_MON_SUBSCRIBE_ACK:\r\nhandle_subscribe_ack(monc, msg);\r\nbreak;\r\ncase CEPH_MSG_STATFS_REPLY:\r\nhandle_statfs_reply(monc, msg);\r\nbreak;\r\ncase CEPH_MSG_MON_GET_VERSION_REPLY:\r\nhandle_get_version_reply(monc, msg);\r\nbreak;\r\ncase CEPH_MSG_MON_MAP:\r\nceph_monc_handle_map(monc, msg);\r\nbreak;\r\ncase CEPH_MSG_OSD_MAP:\r\nceph_osdc_handle_map(&monc->client->osdc, msg);\r\nbreak;\r\ndefault:\r\nif (monc->client->extra_mon_dispatch &&\r\nmonc->client->extra_mon_dispatch(monc->client, msg) == 0)\r\nbreak;\r\npr_err("received unknown message type %d %s\n", type,\r\nceph_msg_type_name(type));\r\n}\r\nceph_msg_put(msg);\r\n}\r\nstatic struct ceph_msg *mon_alloc_msg(struct ceph_connection *con,\r\nstruct ceph_msg_header *hdr,\r\nint *skip)\r\n{\r\nstruct ceph_mon_client *monc = con->private;\r\nint type = le16_to_cpu(hdr->type);\r\nint front_len = le32_to_cpu(hdr->front_len);\r\nstruct ceph_msg *m = NULL;\r\n*skip = 0;\r\nswitch (type) {\r\ncase CEPH_MSG_MON_SUBSCRIBE_ACK:\r\nm = ceph_msg_get(monc->m_subscribe_ack);\r\nbreak;\r\ncase CEPH_MSG_STATFS_REPLY:\r\nreturn get_generic_reply(con, hdr, skip);\r\ncase CEPH_MSG_AUTH_REPLY:\r\nm = ceph_msg_get(monc->m_auth_reply);\r\nbreak;\r\ncase CEPH_MSG_MON_GET_VERSION_REPLY:\r\nif (le64_to_cpu(hdr->tid) != 0)\r\nreturn get_generic_reply(con, hdr, skip);\r\ncase CEPH_MSG_MON_MAP:\r\ncase CEPH_MSG_MDS_MAP:\r\ncase CEPH_MSG_OSD_MAP:\r\nm = ceph_msg_new(type, front_len, GFP_NOFS, false);\r\nif (!m)\r\nreturn NULL;\r\nbreak;\r\n}\r\nif (!m) {\r\npr_info("alloc_msg unknown type %d\n", type);\r\n*skip = 1;\r\n} else if (front_len > m->front_alloc_len) {\r\npr_warn("mon_alloc_msg front %d > prealloc %d (%u#%llu)\n",\r\nfront_len, m->front_alloc_len,\r\n(unsigned int)con->peer_name.type,\r\nle64_to_cpu(con->peer_name.num));\r\nceph_msg_put(m);\r\nm = ceph_msg_new(type, front_len, GFP_NOFS, false);\r\n}\r\nreturn m;\r\n}\r\nstatic void mon_fault(struct ceph_connection *con)\r\n{\r\nstruct ceph_mon_client *monc = con->private;\r\nif (!monc)\r\nreturn;\r\ndout("mon_fault\n");\r\nmutex_lock(&monc->mutex);\r\nif (!con->private)\r\ngoto out;\r\nif (!monc->hunting)\r\npr_info("mon%d %s session lost, "\r\n"hunting for new mon\n", monc->cur_mon,\r\nceph_pr_addr(&monc->con.peer_addr.in_addr));\r\n__close_session(monc);\r\nif (!monc->hunting) {\r\nmonc->hunting = true;\r\n__open_session(monc);\r\n} else {\r\n__schedule_delayed(monc);\r\n}\r\nout:\r\nmutex_unlock(&monc->mutex);\r\n}\r\nstatic struct ceph_connection *con_get(struct ceph_connection *con)\r\n{\r\nreturn con;\r\n}\r\nstatic void con_put(struct ceph_connection *con)\r\n{\r\n}
