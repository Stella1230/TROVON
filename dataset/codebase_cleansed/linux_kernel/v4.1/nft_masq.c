int nft_masq_validate(const struct nft_ctx *ctx,\r\nconst struct nft_expr *expr,\r\nconst struct nft_data **data)\r\n{\r\nint err;\r\nerr = nft_chain_validate_dependency(ctx->chain, NFT_CHAIN_T_NAT);\r\nif (err < 0)\r\nreturn err;\r\nreturn nft_chain_validate_hooks(ctx->chain,\r\n(1 << NF_INET_POST_ROUTING));\r\n}\r\nint nft_masq_init(const struct nft_ctx *ctx,\r\nconst struct nft_expr *expr,\r\nconst struct nlattr * const tb[])\r\n{\r\nstruct nft_masq *priv = nft_expr_priv(expr);\r\nint err;\r\nerr = nft_masq_validate(ctx, expr, NULL);\r\nif (err)\r\nreturn err;\r\nif (tb[NFTA_MASQ_FLAGS] == NULL)\r\nreturn 0;\r\npriv->flags = ntohl(nla_get_be32(tb[NFTA_MASQ_FLAGS]));\r\nif (priv->flags & ~NF_NAT_RANGE_MASK)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nint nft_masq_dump(struct sk_buff *skb, const struct nft_expr *expr)\r\n{\r\nconst struct nft_masq *priv = nft_expr_priv(expr);\r\nif (priv->flags == 0)\r\nreturn 0;\r\nif (nla_put_be32(skb, NFTA_MASQ_FLAGS, htonl(priv->flags)))\r\ngoto nla_put_failure;\r\nreturn 0;\r\nnla_put_failure:\r\nreturn -1;\r\n}
