static void set_to_rgmii(struct rk_priv_data *bsp_priv,\r\nint tx_delay, int rx_delay)\r\n{\r\nstruct device *dev = &bsp_priv->pdev->dev;\r\nif (IS_ERR(bsp_priv->grf)) {\r\ndev_err(dev, "%s: Missing rockchip,grf property\n", __func__);\r\nreturn;\r\n}\r\nregmap_write(bsp_priv->grf, RK3288_GRF_SOC_CON1,\r\nGMAC_PHY_INTF_SEL_RGMII | GMAC_RMII_MODE_CLR);\r\nregmap_write(bsp_priv->grf, RK3288_GRF_SOC_CON3,\r\nGMAC_RXCLK_DLY_ENABLE | GMAC_TXCLK_DLY_ENABLE |\r\nGMAC_CLK_RX_DL_CFG(rx_delay) |\r\nGMAC_CLK_TX_DL_CFG(tx_delay));\r\n}\r\nstatic void set_to_rmii(struct rk_priv_data *bsp_priv)\r\n{\r\nstruct device *dev = &bsp_priv->pdev->dev;\r\nif (IS_ERR(bsp_priv->grf)) {\r\ndev_err(dev, "%s: Missing rockchip,grf property\n", __func__);\r\nreturn;\r\n}\r\nregmap_write(bsp_priv->grf, RK3288_GRF_SOC_CON1,\r\nGMAC_PHY_INTF_SEL_RMII | GMAC_RMII_MODE);\r\n}\r\nstatic void set_rgmii_speed(struct rk_priv_data *bsp_priv, int speed)\r\n{\r\nstruct device *dev = &bsp_priv->pdev->dev;\r\nif (IS_ERR(bsp_priv->grf)) {\r\ndev_err(dev, "%s: Missing rockchip,grf property\n", __func__);\r\nreturn;\r\n}\r\nif (speed == 10)\r\nregmap_write(bsp_priv->grf, RK3288_GRF_SOC_CON1, GMAC_CLK_2_5M);\r\nelse if (speed == 100)\r\nregmap_write(bsp_priv->grf, RK3288_GRF_SOC_CON1, GMAC_CLK_25M);\r\nelse if (speed == 1000)\r\nregmap_write(bsp_priv->grf, RK3288_GRF_SOC_CON1, GMAC_CLK_125M);\r\nelse\r\ndev_err(dev, "unknown speed value for RGMII! speed=%d", speed);\r\n}\r\nstatic void set_rmii_speed(struct rk_priv_data *bsp_priv, int speed)\r\n{\r\nstruct device *dev = &bsp_priv->pdev->dev;\r\nif (IS_ERR(bsp_priv->grf)) {\r\ndev_err(dev, "%s: Missing rockchip,grf property\n", __func__);\r\nreturn;\r\n}\r\nif (speed == 10) {\r\nregmap_write(bsp_priv->grf, RK3288_GRF_SOC_CON1,\r\nGMAC_RMII_CLK_2_5M | GMAC_SPEED_10M);\r\n} else if (speed == 100) {\r\nregmap_write(bsp_priv->grf, RK3288_GRF_SOC_CON1,\r\nGMAC_RMII_CLK_25M | GMAC_SPEED_100M);\r\n} else {\r\ndev_err(dev, "unknown speed value for RMII! speed=%d", speed);\r\n}\r\n}\r\nstatic int gmac_clk_init(struct rk_priv_data *bsp_priv)\r\n{\r\nstruct device *dev = &bsp_priv->pdev->dev;\r\nbsp_priv->clk_enabled = false;\r\nbsp_priv->mac_clk_rx = devm_clk_get(dev, "mac_clk_rx");\r\nif (IS_ERR(bsp_priv->mac_clk_rx))\r\ndev_err(dev, "%s: cannot get clock %s\n",\r\n__func__, "mac_clk_rx");\r\nbsp_priv->mac_clk_tx = devm_clk_get(dev, "mac_clk_tx");\r\nif (IS_ERR(bsp_priv->mac_clk_tx))\r\ndev_err(dev, "%s: cannot get clock %s\n",\r\n__func__, "mac_clk_tx");\r\nbsp_priv->aclk_mac = devm_clk_get(dev, "aclk_mac");\r\nif (IS_ERR(bsp_priv->aclk_mac))\r\ndev_err(dev, "%s: cannot get clock %s\n",\r\n__func__, "aclk_mac");\r\nbsp_priv->pclk_mac = devm_clk_get(dev, "pclk_mac");\r\nif (IS_ERR(bsp_priv->pclk_mac))\r\ndev_err(dev, "%s: cannot get clock %s\n",\r\n__func__, "pclk_mac");\r\nbsp_priv->clk_mac = devm_clk_get(dev, "stmmaceth");\r\nif (IS_ERR(bsp_priv->clk_mac))\r\ndev_err(dev, "%s: cannot get clock %s\n",\r\n__func__, "stmmaceth");\r\nif (bsp_priv->phy_iface == PHY_INTERFACE_MODE_RMII) {\r\nbsp_priv->clk_mac_ref = devm_clk_get(dev, "clk_mac_ref");\r\nif (IS_ERR(bsp_priv->clk_mac_ref))\r\ndev_err(dev, "%s: cannot get clock %s\n",\r\n__func__, "clk_mac_ref");\r\nif (!bsp_priv->clock_input) {\r\nbsp_priv->clk_mac_refout =\r\ndevm_clk_get(dev, "clk_mac_refout");\r\nif (IS_ERR(bsp_priv->clk_mac_refout))\r\ndev_err(dev, "%s: cannot get clock %s\n",\r\n__func__, "clk_mac_refout");\r\n}\r\n}\r\nif (bsp_priv->clock_input) {\r\ndev_info(dev, "%s: clock input from PHY\n", __func__);\r\n} else {\r\nif (bsp_priv->phy_iface == PHY_INTERFACE_MODE_RMII)\r\nclk_set_rate(bsp_priv->clk_mac_pll, 50000000);\r\n}\r\nreturn 0;\r\n}\r\nstatic int gmac_clk_enable(struct rk_priv_data *bsp_priv, bool enable)\r\n{\r\nint phy_iface = phy_iface = bsp_priv->phy_iface;\r\nif (enable) {\r\nif (!bsp_priv->clk_enabled) {\r\nif (phy_iface == PHY_INTERFACE_MODE_RMII) {\r\nif (!IS_ERR(bsp_priv->mac_clk_rx))\r\nclk_prepare_enable(\r\nbsp_priv->mac_clk_rx);\r\nif (!IS_ERR(bsp_priv->clk_mac_ref))\r\nclk_prepare_enable(\r\nbsp_priv->clk_mac_ref);\r\nif (!IS_ERR(bsp_priv->clk_mac_refout))\r\nclk_prepare_enable(\r\nbsp_priv->clk_mac_refout);\r\n}\r\nif (!IS_ERR(bsp_priv->aclk_mac))\r\nclk_prepare_enable(bsp_priv->aclk_mac);\r\nif (!IS_ERR(bsp_priv->pclk_mac))\r\nclk_prepare_enable(bsp_priv->pclk_mac);\r\nif (!IS_ERR(bsp_priv->mac_clk_tx))\r\nclk_prepare_enable(bsp_priv->mac_clk_tx);\r\nmdelay(5);\r\nbsp_priv->clk_enabled = true;\r\n}\r\n} else {\r\nif (bsp_priv->clk_enabled) {\r\nif (phy_iface == PHY_INTERFACE_MODE_RMII) {\r\nif (!IS_ERR(bsp_priv->mac_clk_rx))\r\nclk_disable_unprepare(\r\nbsp_priv->mac_clk_rx);\r\nif (!IS_ERR(bsp_priv->clk_mac_ref))\r\nclk_disable_unprepare(\r\nbsp_priv->clk_mac_ref);\r\nif (!IS_ERR(bsp_priv->clk_mac_refout))\r\nclk_disable_unprepare(\r\nbsp_priv->clk_mac_refout);\r\n}\r\nif (!IS_ERR(bsp_priv->aclk_mac))\r\nclk_disable_unprepare(bsp_priv->aclk_mac);\r\nif (!IS_ERR(bsp_priv->pclk_mac))\r\nclk_disable_unprepare(bsp_priv->pclk_mac);\r\nif (!IS_ERR(bsp_priv->mac_clk_tx))\r\nclk_disable_unprepare(bsp_priv->mac_clk_tx);\r\nbsp_priv->clk_enabled = false;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int phy_power_on(struct rk_priv_data *bsp_priv, bool enable)\r\n{\r\nstruct regulator *ldo = bsp_priv->regulator;\r\nint ret;\r\nstruct device *dev = &bsp_priv->pdev->dev;\r\nif (!ldo) {\r\ndev_err(dev, "%s: no regulator found\n", __func__);\r\nreturn -1;\r\n}\r\nif (enable) {\r\nret = regulator_enable(ldo);\r\nif (ret)\r\ndev_err(dev, "%s: fail to enable phy-supply\n",\r\n__func__);\r\n} else {\r\nret = regulator_disable(ldo);\r\nif (ret)\r\ndev_err(dev, "%s: fail to disable phy-supply\n",\r\n__func__);\r\n}\r\nreturn 0;\r\n}\r\nstatic void *rk_gmac_setup(struct platform_device *pdev)\r\n{\r\nstruct rk_priv_data *bsp_priv;\r\nstruct device *dev = &pdev->dev;\r\nint ret;\r\nconst char *strings = NULL;\r\nint value;\r\nbsp_priv = devm_kzalloc(dev, sizeof(*bsp_priv), GFP_KERNEL);\r\nif (!bsp_priv)\r\nreturn ERR_PTR(-ENOMEM);\r\nbsp_priv->phy_iface = of_get_phy_mode(dev->of_node);\r\nbsp_priv->regulator = devm_regulator_get_optional(dev, "phy");\r\nif (IS_ERR(bsp_priv->regulator)) {\r\nif (PTR_ERR(bsp_priv->regulator) == -EPROBE_DEFER) {\r\ndev_err(dev, "phy regulator is not available yet, deferred probing\n");\r\nreturn ERR_PTR(-EPROBE_DEFER);\r\n}\r\ndev_err(dev, "no regulator found\n");\r\nbsp_priv->regulator = NULL;\r\n}\r\nret = of_property_read_string(dev->of_node, "clock_in_out", &strings);\r\nif (ret) {\r\ndev_err(dev, "%s: Can not read property: clock_in_out.\n",\r\n__func__);\r\nbsp_priv->clock_input = true;\r\n} else {\r\ndev_info(dev, "%s: clock input or output? (%s).\n",\r\n__func__, strings);\r\nif (!strcmp(strings, "input"))\r\nbsp_priv->clock_input = true;\r\nelse\r\nbsp_priv->clock_input = false;\r\n}\r\nret = of_property_read_u32(dev->of_node, "tx_delay", &value);\r\nif (ret) {\r\nbsp_priv->tx_delay = 0x30;\r\ndev_err(dev, "%s: Can not read property: tx_delay.", __func__);\r\ndev_err(dev, "%s: set tx_delay to 0x%x\n",\r\n__func__, bsp_priv->tx_delay);\r\n} else {\r\ndev_info(dev, "%s: TX delay(0x%x).\n", __func__, value);\r\nbsp_priv->tx_delay = value;\r\n}\r\nret = of_property_read_u32(dev->of_node, "rx_delay", &value);\r\nif (ret) {\r\nbsp_priv->rx_delay = 0x10;\r\ndev_err(dev, "%s: Can not read property: rx_delay.", __func__);\r\ndev_err(dev, "%s: set rx_delay to 0x%x\n",\r\n__func__, bsp_priv->rx_delay);\r\n} else {\r\ndev_info(dev, "%s: RX delay(0x%x).\n", __func__, value);\r\nbsp_priv->rx_delay = value;\r\n}\r\nbsp_priv->grf = syscon_regmap_lookup_by_phandle(dev->of_node,\r\n"rockchip,grf");\r\nbsp_priv->pdev = pdev;\r\nif (bsp_priv->phy_iface == PHY_INTERFACE_MODE_RGMII) {\r\ndev_info(dev, "%s: init for RGMII\n", __func__);\r\nset_to_rgmii(bsp_priv, bsp_priv->tx_delay, bsp_priv->rx_delay);\r\n} else if (bsp_priv->phy_iface == PHY_INTERFACE_MODE_RMII) {\r\ndev_info(dev, "%s: init for RMII\n", __func__);\r\nset_to_rmii(bsp_priv);\r\n} else {\r\ndev_err(dev, "%s: NO interface defined!\n", __func__);\r\n}\r\ngmac_clk_init(bsp_priv);\r\nreturn bsp_priv;\r\n}\r\nstatic int rk_gmac_init(struct platform_device *pdev, void *priv)\r\n{\r\nstruct rk_priv_data *bsp_priv = priv;\r\nint ret;\r\nret = phy_power_on(bsp_priv, true);\r\nif (ret)\r\nreturn ret;\r\nret = gmac_clk_enable(bsp_priv, true);\r\nif (ret)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nstatic void rk_gmac_exit(struct platform_device *pdev, void *priv)\r\n{\r\nstruct rk_priv_data *gmac = priv;\r\nphy_power_on(gmac, false);\r\ngmac_clk_enable(gmac, false);\r\n}\r\nstatic void rk_fix_speed(void *priv, unsigned int speed)\r\n{\r\nstruct rk_priv_data *bsp_priv = priv;\r\nstruct device *dev = &bsp_priv->pdev->dev;\r\nif (bsp_priv->phy_iface == PHY_INTERFACE_MODE_RGMII)\r\nset_rgmii_speed(bsp_priv, speed);\r\nelse if (bsp_priv->phy_iface == PHY_INTERFACE_MODE_RMII)\r\nset_rmii_speed(bsp_priv, speed);\r\nelse\r\ndev_err(dev, "unsupported interface %d", bsp_priv->phy_iface);\r\n}
