static int sigmadsp_write(struct sigmadsp *sigmadsp, unsigned int addr,\r\nconst uint8_t data[], size_t len)\r\n{\r\nreturn sigmadsp->write(sigmadsp->control_data, addr, data, len);\r\n}\r\nstatic int sigmadsp_read(struct sigmadsp *sigmadsp, unsigned int addr,\r\nuint8_t data[], size_t len)\r\n{\r\nreturn sigmadsp->read(sigmadsp->control_data, addr, data, len);\r\n}\r\nstatic int sigmadsp_ctrl_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *info)\r\n{\r\nstruct sigmadsp_control *ctrl = (void *)kcontrol->private_value;\r\ninfo->type = SNDRV_CTL_ELEM_TYPE_BYTES;\r\ninfo->count = ctrl->num_bytes;\r\nreturn 0;\r\n}\r\nstatic int sigmadsp_ctrl_write(struct sigmadsp *sigmadsp,\r\nstruct sigmadsp_control *ctrl, void *data)\r\n{\r\nif (ctrl->num_bytes > 4 && ctrl->num_bytes <= 20 && sigmadsp->ops &&\r\nsigmadsp->ops->safeload)\r\nreturn sigmadsp->ops->safeload(sigmadsp, ctrl->addr, data,\r\nctrl->num_bytes);\r\nelse\r\nreturn sigmadsp_write(sigmadsp, ctrl->addr, data,\r\nctrl->num_bytes);\r\n}\r\nstatic int sigmadsp_ctrl_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct sigmadsp_control *ctrl = (void *)kcontrol->private_value;\r\nstruct sigmadsp *sigmadsp = snd_kcontrol_chip(kcontrol);\r\nuint8_t *data;\r\nint ret = 0;\r\nmutex_lock(&sigmadsp->lock);\r\ndata = ucontrol->value.bytes.data;\r\nif (!(kcontrol->vd[0].access & SNDRV_CTL_ELEM_ACCESS_INACTIVE))\r\nret = sigmadsp_ctrl_write(sigmadsp, ctrl, data);\r\nif (ret == 0) {\r\nmemcpy(ctrl->cache, data, ctrl->num_bytes);\r\nctrl->cached = true;\r\n}\r\nmutex_unlock(&sigmadsp->lock);\r\nreturn ret;\r\n}\r\nstatic int sigmadsp_ctrl_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct sigmadsp_control *ctrl = (void *)kcontrol->private_value;\r\nstruct sigmadsp *sigmadsp = snd_kcontrol_chip(kcontrol);\r\nint ret = 0;\r\nmutex_lock(&sigmadsp->lock);\r\nif (!ctrl->cached) {\r\nret = sigmadsp_read(sigmadsp, ctrl->addr, ctrl->cache,\r\nctrl->num_bytes);\r\n}\r\nif (ret == 0) {\r\nctrl->cached = true;\r\nmemcpy(ucontrol->value.bytes.data, ctrl->cache,\r\nctrl->num_bytes);\r\n}\r\nmutex_unlock(&sigmadsp->lock);\r\nreturn ret;\r\n}\r\nstatic void sigmadsp_control_free(struct snd_kcontrol *kcontrol)\r\n{\r\nstruct sigmadsp_control *ctrl = (void *)kcontrol->private_value;\r\nctrl->kcontrol = NULL;\r\n}\r\nstatic bool sigma_fw_validate_control_name(const char *name, unsigned int len)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < len; i++) {\r\nif (name[i] < ' ' || name[i] > '~')\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\nstatic int sigma_fw_load_control(struct sigmadsp *sigmadsp,\r\nconst struct sigma_fw_chunk *chunk, unsigned int length)\r\n{\r\nconst struct sigma_fw_chunk_control *ctrl_chunk;\r\nstruct sigmadsp_control *ctrl;\r\nunsigned int num_bytes;\r\nsize_t name_len;\r\nchar *name;\r\nint ret;\r\nif (length <= sizeof(*ctrl_chunk))\r\nreturn -EINVAL;\r\nctrl_chunk = (const struct sigma_fw_chunk_control *)chunk;\r\nname_len = length - sizeof(*ctrl_chunk);\r\nif (name_len >= SNDRV_CTL_ELEM_ID_NAME_MAXLEN)\r\nname_len = SNDRV_CTL_ELEM_ID_NAME_MAXLEN - 1;\r\nif (!sigma_fw_validate_control_name(ctrl_chunk->name, name_len))\r\nreturn -EINVAL;\r\nnum_bytes = le16_to_cpu(ctrl_chunk->num_bytes);\r\nctrl = kzalloc(sizeof(*ctrl) + num_bytes, GFP_KERNEL);\r\nif (!ctrl)\r\nreturn -ENOMEM;\r\nname = kzalloc(name_len + 1, GFP_KERNEL);\r\nif (!name) {\r\nret = -ENOMEM;\r\ngoto err_free_ctrl;\r\n}\r\nmemcpy(name, ctrl_chunk->name, name_len);\r\nname[name_len] = '\0';\r\nctrl->name = name;\r\nctrl->addr = le16_to_cpu(ctrl_chunk->addr);\r\nctrl->num_bytes = num_bytes;\r\nctrl->samplerates = le32_to_cpu(chunk->samplerates);\r\nlist_add_tail(&ctrl->head, &sigmadsp->ctrl_list);\r\nreturn 0;\r\nerr_free_ctrl:\r\nkfree(ctrl);\r\nreturn ret;\r\n}\r\nstatic int sigma_fw_load_data(struct sigmadsp *sigmadsp,\r\nconst struct sigma_fw_chunk *chunk, unsigned int length)\r\n{\r\nconst struct sigma_fw_chunk_data *data_chunk;\r\nstruct sigmadsp_data *data;\r\nif (length <= sizeof(*data_chunk))\r\nreturn -EINVAL;\r\ndata_chunk = (struct sigma_fw_chunk_data *)chunk;\r\nlength -= sizeof(*data_chunk);\r\ndata = kzalloc(sizeof(*data) + length, GFP_KERNEL);\r\nif (!data)\r\nreturn -ENOMEM;\r\ndata->addr = le16_to_cpu(data_chunk->addr);\r\ndata->length = length;\r\ndata->samplerates = le32_to_cpu(chunk->samplerates);\r\nmemcpy(data->data, data_chunk->data, length);\r\nlist_add_tail(&data->head, &sigmadsp->data_list);\r\nreturn 0;\r\n}\r\nstatic int sigma_fw_load_samplerates(struct sigmadsp *sigmadsp,\r\nconst struct sigma_fw_chunk *chunk, unsigned int length)\r\n{\r\nconst struct sigma_fw_chunk_samplerate *rate_chunk;\r\nunsigned int num_rates;\r\nunsigned int *rates;\r\nunsigned int i;\r\nrate_chunk = (const struct sigma_fw_chunk_samplerate *)chunk;\r\nnum_rates = (length - sizeof(*rate_chunk)) / sizeof(__le32);\r\nif (num_rates > 32 || num_rates == 0)\r\nreturn -EINVAL;\r\nif (sigmadsp->rate_constraints.count)\r\nreturn -EINVAL;\r\nrates = kcalloc(num_rates, sizeof(*rates), GFP_KERNEL);\r\nif (!rates)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < num_rates; i++)\r\nrates[i] = le32_to_cpu(rate_chunk->samplerates[i]);\r\nsigmadsp->rate_constraints.count = num_rates;\r\nsigmadsp->rate_constraints.list = rates;\r\nreturn 0;\r\n}\r\nstatic int sigmadsp_fw_load_v2(struct sigmadsp *sigmadsp,\r\nconst struct firmware *fw)\r\n{\r\nstruct sigma_fw_chunk *chunk;\r\nunsigned int length, pos;\r\nint ret;\r\nif (fw->size < sizeof(*chunk) + sizeof(struct sigma_firmware_header))\r\nreturn 0;\r\npos = sizeof(struct sigma_firmware_header);\r\nwhile (pos < fw->size - sizeof(*chunk)) {\r\nchunk = (struct sigma_fw_chunk *)(fw->data + pos);\r\nlength = le32_to_cpu(chunk->length);\r\nif (length > fw->size - pos || length < sizeof(*chunk))\r\nreturn -EINVAL;\r\nswitch (le32_to_cpu(chunk->tag)) {\r\ncase SIGMA_FW_CHUNK_TYPE_DATA:\r\nret = sigma_fw_load_data(sigmadsp, chunk, length);\r\nbreak;\r\ncase SIGMA_FW_CHUNK_TYPE_CONTROL:\r\nret = sigma_fw_load_control(sigmadsp, chunk, length);\r\nbreak;\r\ncase SIGMA_FW_CHUNK_TYPE_SAMPLERATES:\r\nret = sigma_fw_load_samplerates(sigmadsp, chunk, length);\r\nbreak;\r\ndefault:\r\ndev_warn(sigmadsp->dev, "Unknown chunk type: %d\n",\r\nchunk->tag);\r\nret = 0;\r\nbreak;\r\n}\r\nif (ret)\r\nreturn ret;\r\npos += ALIGN(length, sizeof(__le32));\r\n}\r\nreturn 0;\r\n}\r\nstatic inline u32 sigma_action_len(struct sigma_action *sa)\r\n{\r\nreturn (sa->len_hi << 16) | le16_to_cpu(sa->len);\r\n}\r\nstatic size_t sigma_action_size(struct sigma_action *sa)\r\n{\r\nsize_t payload = 0;\r\nswitch (sa->instr) {\r\ncase SIGMA_ACTION_WRITEXBYTES:\r\ncase SIGMA_ACTION_WRITESINGLE:\r\ncase SIGMA_ACTION_WRITESAFELOAD:\r\npayload = sigma_action_len(sa);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\npayload = ALIGN(payload, 2);\r\nreturn payload + sizeof(struct sigma_action);\r\n}\r\nstatic int process_sigma_action(struct sigmadsp *sigmadsp,\r\nstruct sigma_action *sa)\r\n{\r\nsize_t len = sigma_action_len(sa);\r\nstruct sigmadsp_data *data;\r\npr_debug("%s: instr:%i addr:%#x len:%zu\n", __func__,\r\nsa->instr, sa->addr, len);\r\nswitch (sa->instr) {\r\ncase SIGMA_ACTION_WRITEXBYTES:\r\ncase SIGMA_ACTION_WRITESINGLE:\r\ncase SIGMA_ACTION_WRITESAFELOAD:\r\nif (len < 3)\r\nreturn -EINVAL;\r\ndata = kzalloc(sizeof(*data) + len - 2, GFP_KERNEL);\r\nif (!data)\r\nreturn -ENOMEM;\r\ndata->addr = be16_to_cpu(sa->addr);\r\ndata->length = len - 2;\r\nmemcpy(data->data, sa->payload, data->length);\r\nlist_add_tail(&data->head, &sigmadsp->data_list);\r\nbreak;\r\ncase SIGMA_ACTION_END:\r\nreturn 0;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 1;\r\n}\r\nstatic int sigmadsp_fw_load_v1(struct sigmadsp *sigmadsp,\r\nconst struct firmware *fw)\r\n{\r\nstruct sigma_action *sa;\r\nsize_t size, pos;\r\nint ret;\r\npos = sizeof(struct sigma_firmware_header);\r\nwhile (pos + sizeof(*sa) <= fw->size) {\r\nsa = (struct sigma_action *)(fw->data + pos);\r\nsize = sigma_action_size(sa);\r\npos += size;\r\nif (pos > fw->size || size == 0)\r\nbreak;\r\nret = process_sigma_action(sigmadsp, sa);\r\npr_debug("%s: action returned %i\n", __func__, ret);\r\nif (ret <= 0)\r\nreturn ret;\r\n}\r\nif (pos != fw->size)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic void sigmadsp_firmware_release(struct sigmadsp *sigmadsp)\r\n{\r\nstruct sigmadsp_control *ctrl, *_ctrl;\r\nstruct sigmadsp_data *data, *_data;\r\nlist_for_each_entry_safe(ctrl, _ctrl, &sigmadsp->ctrl_list, head) {\r\nkfree(ctrl->name);\r\nkfree(ctrl);\r\n}\r\nlist_for_each_entry_safe(data, _data, &sigmadsp->data_list, head)\r\nkfree(data);\r\nINIT_LIST_HEAD(&sigmadsp->ctrl_list);\r\nINIT_LIST_HEAD(&sigmadsp->data_list);\r\n}\r\nstatic void devm_sigmadsp_release(struct device *dev, void *res)\r\n{\r\nsigmadsp_firmware_release((struct sigmadsp *)res);\r\n}\r\nstatic int sigmadsp_firmware_load(struct sigmadsp *sigmadsp, const char *name)\r\n{\r\nconst struct sigma_firmware_header *ssfw_head;\r\nconst struct firmware *fw;\r\nint ret;\r\nu32 crc;\r\nret = request_firmware(&fw, name, sigmadsp->dev);\r\nif (ret) {\r\npr_debug("%s: request_firmware() failed with %i\n", __func__, ret);\r\ngoto done;\r\n}\r\nret = -EINVAL;\r\nif (fw->size < sizeof(*ssfw_head) || fw->size >= 0x4000000) {\r\ndev_err(sigmadsp->dev, "Failed to load firmware: Invalid size\n");\r\ngoto done;\r\n}\r\nssfw_head = (void *)fw->data;\r\nif (memcmp(ssfw_head->magic, SIGMA_MAGIC, ARRAY_SIZE(ssfw_head->magic))) {\r\ndev_err(sigmadsp->dev, "Failed to load firmware: Invalid magic\n");\r\ngoto done;\r\n}\r\ncrc = crc32(0, fw->data + sizeof(*ssfw_head),\r\nfw->size - sizeof(*ssfw_head));\r\npr_debug("%s: crc=%x\n", __func__, crc);\r\nif (crc != le32_to_cpu(ssfw_head->crc)) {\r\ndev_err(sigmadsp->dev, "Failed to load firmware: Wrong crc checksum: expected %x got %x\n",\r\nle32_to_cpu(ssfw_head->crc), crc);\r\ngoto done;\r\n}\r\nswitch (ssfw_head->version) {\r\ncase 1:\r\nret = sigmadsp_fw_load_v1(sigmadsp, fw);\r\nbreak;\r\ncase 2:\r\nret = sigmadsp_fw_load_v2(sigmadsp, fw);\r\nbreak;\r\ndefault:\r\ndev_err(sigmadsp->dev,\r\n"Failed to load firmware: Invalid version %d. Supported firmware versions: 1, 2\n",\r\nssfw_head->version);\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nif (ret)\r\nsigmadsp_firmware_release(sigmadsp);\r\ndone:\r\nrelease_firmware(fw);\r\nreturn ret;\r\n}\r\nstatic int sigmadsp_init(struct sigmadsp *sigmadsp, struct device *dev,\r\nconst struct sigmadsp_ops *ops, const char *firmware_name)\r\n{\r\nsigmadsp->ops = ops;\r\nsigmadsp->dev = dev;\r\nINIT_LIST_HEAD(&sigmadsp->ctrl_list);\r\nINIT_LIST_HEAD(&sigmadsp->data_list);\r\nmutex_init(&sigmadsp->lock);\r\nreturn sigmadsp_firmware_load(sigmadsp, firmware_name);\r\n}\r\nstruct sigmadsp *devm_sigmadsp_init(struct device *dev,\r\nconst struct sigmadsp_ops *ops, const char *firmware_name)\r\n{\r\nstruct sigmadsp *sigmadsp;\r\nint ret;\r\nsigmadsp = devres_alloc(devm_sigmadsp_release, sizeof(*sigmadsp),\r\nGFP_KERNEL);\r\nif (!sigmadsp)\r\nreturn ERR_PTR(-ENOMEM);\r\nret = sigmadsp_init(sigmadsp, dev, ops, firmware_name);\r\nif (ret) {\r\ndevres_free(sigmadsp);\r\nreturn ERR_PTR(ret);\r\n}\r\ndevres_add(dev, sigmadsp);\r\nreturn sigmadsp;\r\n}\r\nstatic int sigmadsp_rate_to_index(struct sigmadsp *sigmadsp, unsigned int rate)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < sigmadsp->rate_constraints.count; i++) {\r\nif (sigmadsp->rate_constraints.list[i] == rate)\r\nreturn i;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic unsigned int sigmadsp_get_samplerate_mask(struct sigmadsp *sigmadsp,\r\nunsigned int samplerate)\r\n{\r\nint samplerate_index;\r\nif (samplerate == 0)\r\nreturn 0;\r\nif (sigmadsp->rate_constraints.count) {\r\nsamplerate_index = sigmadsp_rate_to_index(sigmadsp, samplerate);\r\nif (samplerate_index < 0)\r\nreturn 0;\r\nreturn BIT(samplerate_index);\r\n} else {\r\nreturn ~0;\r\n}\r\n}\r\nstatic bool sigmadsp_samplerate_valid(unsigned int supported,\r\nunsigned int requested)\r\n{\r\nif (!supported)\r\nreturn true;\r\nreturn supported & requested;\r\n}\r\nstatic int sigmadsp_alloc_control(struct sigmadsp *sigmadsp,\r\nstruct sigmadsp_control *ctrl, unsigned int samplerate_mask)\r\n{\r\nstruct snd_kcontrol_new template;\r\nstruct snd_kcontrol *kcontrol;\r\nmemset(&template, 0, sizeof(template));\r\ntemplate.iface = SNDRV_CTL_ELEM_IFACE_MIXER;\r\ntemplate.name = ctrl->name;\r\ntemplate.info = sigmadsp_ctrl_info;\r\ntemplate.get = sigmadsp_ctrl_get;\r\ntemplate.put = sigmadsp_ctrl_put;\r\ntemplate.private_value = (unsigned long)ctrl;\r\ntemplate.access = SNDRV_CTL_ELEM_ACCESS_READWRITE;\r\nif (!sigmadsp_samplerate_valid(ctrl->samplerates, samplerate_mask))\r\ntemplate.access |= SNDRV_CTL_ELEM_ACCESS_INACTIVE;\r\nkcontrol = snd_ctl_new1(&template, sigmadsp);\r\nif (!kcontrol)\r\nreturn -ENOMEM;\r\nkcontrol->private_free = sigmadsp_control_free;\r\nctrl->kcontrol = kcontrol;\r\nreturn snd_ctl_add(sigmadsp->component->card->snd_card, kcontrol);\r\n}\r\nstatic void sigmadsp_activate_ctrl(struct sigmadsp *sigmadsp,\r\nstruct sigmadsp_control *ctrl, unsigned int samplerate_mask)\r\n{\r\nstruct snd_card *card = sigmadsp->component->card->snd_card;\r\nstruct snd_kcontrol_volatile *vd;\r\nstruct snd_ctl_elem_id id;\r\nbool active;\r\nbool changed = false;\r\nactive = sigmadsp_samplerate_valid(ctrl->samplerates, samplerate_mask);\r\ndown_write(&card->controls_rwsem);\r\nif (!ctrl->kcontrol) {\r\nup_write(&card->controls_rwsem);\r\nreturn;\r\n}\r\nid = ctrl->kcontrol->id;\r\nvd = &ctrl->kcontrol->vd[0];\r\nif (active == (bool)(vd->access & SNDRV_CTL_ELEM_ACCESS_INACTIVE)) {\r\nvd->access ^= SNDRV_CTL_ELEM_ACCESS_INACTIVE;\r\nchanged = true;\r\n}\r\nup_write(&card->controls_rwsem);\r\nif (active && changed) {\r\nmutex_lock(&sigmadsp->lock);\r\nif (ctrl->cached)\r\nsigmadsp_ctrl_write(sigmadsp, ctrl, ctrl->cache);\r\nmutex_unlock(&sigmadsp->lock);\r\n}\r\nif (changed)\r\nsnd_ctl_notify(card, SNDRV_CTL_EVENT_MASK_INFO, &id);\r\n}\r\nint sigmadsp_attach(struct sigmadsp *sigmadsp,\r\nstruct snd_soc_component *component)\r\n{\r\nstruct sigmadsp_control *ctrl;\r\nunsigned int samplerate_mask;\r\nint ret;\r\nsigmadsp->component = component;\r\nsamplerate_mask = sigmadsp_get_samplerate_mask(sigmadsp,\r\nsigmadsp->current_samplerate);\r\nlist_for_each_entry(ctrl, &sigmadsp->ctrl_list, head) {\r\nret = sigmadsp_alloc_control(sigmadsp, ctrl, samplerate_mask);\r\nif (ret)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nint sigmadsp_setup(struct sigmadsp *sigmadsp, unsigned int samplerate)\r\n{\r\nstruct sigmadsp_control *ctrl;\r\nunsigned int samplerate_mask;\r\nstruct sigmadsp_data *data;\r\nint ret;\r\nif (sigmadsp->current_samplerate == samplerate)\r\nreturn 0;\r\nsamplerate_mask = sigmadsp_get_samplerate_mask(sigmadsp, samplerate);\r\nif (samplerate_mask == 0)\r\nreturn -EINVAL;\r\nlist_for_each_entry(data, &sigmadsp->data_list, head) {\r\nif (!sigmadsp_samplerate_valid(data->samplerates,\r\nsamplerate_mask))\r\ncontinue;\r\nret = sigmadsp_write(sigmadsp, data->addr, data->data,\r\ndata->length);\r\nif (ret)\r\ngoto err;\r\n}\r\nlist_for_each_entry(ctrl, &sigmadsp->ctrl_list, head)\r\nsigmadsp_activate_ctrl(sigmadsp, ctrl, samplerate_mask);\r\nsigmadsp->current_samplerate = samplerate;\r\nreturn 0;\r\nerr:\r\nsigmadsp_reset(sigmadsp);\r\nreturn ret;\r\n}\r\nvoid sigmadsp_reset(struct sigmadsp *sigmadsp)\r\n{\r\nstruct sigmadsp_control *ctrl;\r\nlist_for_each_entry(ctrl, &sigmadsp->ctrl_list, head)\r\nsigmadsp_activate_ctrl(sigmadsp, ctrl, false);\r\nsigmadsp->current_samplerate = 0;\r\n}\r\nint sigmadsp_restrict_params(struct sigmadsp *sigmadsp,\r\nstruct snd_pcm_substream *substream)\r\n{\r\nif (sigmadsp->rate_constraints.count == 0)\r\nreturn 0;\r\nreturn snd_pcm_hw_constraint_list(substream->runtime, 0,\r\nSNDRV_PCM_HW_PARAM_RATE, &sigmadsp->rate_constraints);\r\n}
