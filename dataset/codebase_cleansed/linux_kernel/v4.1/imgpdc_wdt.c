static int pdc_wdt_keepalive(struct watchdog_device *wdt_dev)\r\n{\r\nstruct pdc_wdt_dev *wdt = watchdog_get_drvdata(wdt_dev);\r\nwritel(PDC_WDT_TICKLE1_MAGIC, wdt->base + PDC_WDT_TICKLE1);\r\nwritel(PDC_WDT_TICKLE2_MAGIC, wdt->base + PDC_WDT_TICKLE2);\r\nreturn 0;\r\n}\r\nstatic int pdc_wdt_stop(struct watchdog_device *wdt_dev)\r\n{\r\nunsigned int val;\r\nstruct pdc_wdt_dev *wdt = watchdog_get_drvdata(wdt_dev);\r\nval = readl(wdt->base + PDC_WDT_CONFIG);\r\nval &= ~PDC_WDT_CONFIG_ENABLE;\r\nwritel(val, wdt->base + PDC_WDT_CONFIG);\r\npdc_wdt_keepalive(wdt_dev);\r\nreturn 0;\r\n}\r\nstatic int pdc_wdt_set_timeout(struct watchdog_device *wdt_dev,\r\nunsigned int new_timeout)\r\n{\r\nunsigned int val;\r\nstruct pdc_wdt_dev *wdt = watchdog_get_drvdata(wdt_dev);\r\nunsigned long clk_rate = clk_get_rate(wdt->wdt_clk);\r\nwdt->wdt_dev.timeout = new_timeout;\r\nval = readl(wdt->base + PDC_WDT_CONFIG) & ~PDC_WDT_CONFIG_DELAY_MASK;\r\nval |= order_base_2(new_timeout * clk_rate) - 1;\r\nwritel(val, wdt->base + PDC_WDT_CONFIG);\r\nreturn 0;\r\n}\r\nstatic int pdc_wdt_start(struct watchdog_device *wdt_dev)\r\n{\r\nunsigned int val;\r\nstruct pdc_wdt_dev *wdt = watchdog_get_drvdata(wdt_dev);\r\nval = readl(wdt->base + PDC_WDT_CONFIG);\r\nval |= PDC_WDT_CONFIG_ENABLE;\r\nwritel(val, wdt->base + PDC_WDT_CONFIG);\r\nreturn 0;\r\n}\r\nstatic int pdc_wdt_probe(struct platform_device *pdev)\r\n{\r\nint ret, val;\r\nunsigned long clk_rate;\r\nstruct resource *res;\r\nstruct pdc_wdt_dev *pdc_wdt;\r\npdc_wdt = devm_kzalloc(&pdev->dev, sizeof(*pdc_wdt), GFP_KERNEL);\r\nif (!pdc_wdt)\r\nreturn -ENOMEM;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\npdc_wdt->base = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(pdc_wdt->base))\r\nreturn PTR_ERR(pdc_wdt->base);\r\npdc_wdt->sys_clk = devm_clk_get(&pdev->dev, "sys");\r\nif (IS_ERR(pdc_wdt->sys_clk)) {\r\ndev_err(&pdev->dev, "failed to get the sys clock\n");\r\nreturn PTR_ERR(pdc_wdt->sys_clk);\r\n}\r\npdc_wdt->wdt_clk = devm_clk_get(&pdev->dev, "wdt");\r\nif (IS_ERR(pdc_wdt->wdt_clk)) {\r\ndev_err(&pdev->dev, "failed to get the wdt clock\n");\r\nreturn PTR_ERR(pdc_wdt->wdt_clk);\r\n}\r\nret = clk_prepare_enable(pdc_wdt->sys_clk);\r\nif (ret) {\r\ndev_err(&pdev->dev, "could not prepare or enable sys clock\n");\r\nreturn ret;\r\n}\r\nret = clk_prepare_enable(pdc_wdt->wdt_clk);\r\nif (ret) {\r\ndev_err(&pdev->dev, "could not prepare or enable wdt clock\n");\r\ngoto disable_sys_clk;\r\n}\r\nclk_rate = clk_get_rate(pdc_wdt->wdt_clk);\r\nif (clk_rate == 0) {\r\ndev_err(&pdev->dev, "failed to get clock rate\n");\r\nret = -EINVAL;\r\ngoto disable_wdt_clk;\r\n}\r\nif (order_base_2(clk_rate) > PDC_WDT_CONFIG_DELAY_MASK + 1) {\r\ndev_err(&pdev->dev, "invalid clock rate\n");\r\nret = -EINVAL;\r\ngoto disable_wdt_clk;\r\n}\r\nif (order_base_2(clk_rate) == 0)\r\npdc_wdt->wdt_dev.min_timeout = PDC_WDT_MIN_TIMEOUT + 1;\r\nelse\r\npdc_wdt->wdt_dev.min_timeout = PDC_WDT_MIN_TIMEOUT;\r\npdc_wdt->wdt_dev.info = &pdc_wdt_info;\r\npdc_wdt->wdt_dev.ops = &pdc_wdt_ops;\r\npdc_wdt->wdt_dev.max_timeout = 1 << PDC_WDT_CONFIG_DELAY_MASK;\r\npdc_wdt->wdt_dev.parent = &pdev->dev;\r\nwatchdog_set_drvdata(&pdc_wdt->wdt_dev, pdc_wdt);\r\nret = watchdog_init_timeout(&pdc_wdt->wdt_dev, heartbeat, &pdev->dev);\r\nif (ret < 0) {\r\npdc_wdt->wdt_dev.timeout = pdc_wdt->wdt_dev.max_timeout;\r\ndev_warn(&pdev->dev,\r\n"Initial timeout out of range! setting max timeout\n");\r\n}\r\npdc_wdt_stop(&pdc_wdt->wdt_dev);\r\nval = readl(pdc_wdt->base + PDC_WDT_TICKLE1);\r\nval = (val & PDC_WDT_TICKLE_STATUS_MASK) >> PDC_WDT_TICKLE_STATUS_SHIFT;\r\nswitch (val) {\r\ncase PDC_WDT_TICKLE_STATUS_TICKLE:\r\ncase PDC_WDT_TICKLE_STATUS_TIMEOUT:\r\npdc_wdt->wdt_dev.bootstatus |= WDIOF_CARDRESET;\r\ndev_info(&pdev->dev,\r\n"watchdog module last reset due to timeout\n");\r\nbreak;\r\ncase PDC_WDT_TICKLE_STATUS_HRESET:\r\ndev_info(&pdev->dev,\r\n"watchdog module last reset due to hard reset\n");\r\nbreak;\r\ncase PDC_WDT_TICKLE_STATUS_SRESET:\r\ndev_info(&pdev->dev,\r\n"watchdog module last reset due to soft reset\n");\r\nbreak;\r\ncase PDC_WDT_TICKLE_STATUS_USER:\r\ndev_info(&pdev->dev,\r\n"watchdog module last reset due to user reset\n");\r\nbreak;\r\ndefault:\r\ndev_info(&pdev->dev,\r\n"contains an illegal status code (%08x)\n", val);\r\nbreak;\r\n}\r\nwatchdog_set_nowayout(&pdc_wdt->wdt_dev, nowayout);\r\nplatform_set_drvdata(pdev, pdc_wdt);\r\nret = watchdog_register_device(&pdc_wdt->wdt_dev);\r\nif (ret)\r\ngoto disable_wdt_clk;\r\nreturn 0;\r\ndisable_wdt_clk:\r\nclk_disable_unprepare(pdc_wdt->wdt_clk);\r\ndisable_sys_clk:\r\nclk_disable_unprepare(pdc_wdt->sys_clk);\r\nreturn ret;\r\n}\r\nstatic void pdc_wdt_shutdown(struct platform_device *pdev)\r\n{\r\nstruct pdc_wdt_dev *pdc_wdt = platform_get_drvdata(pdev);\r\npdc_wdt_stop(&pdc_wdt->wdt_dev);\r\n}\r\nstatic int pdc_wdt_remove(struct platform_device *pdev)\r\n{\r\nstruct pdc_wdt_dev *pdc_wdt = platform_get_drvdata(pdev);\r\npdc_wdt_stop(&pdc_wdt->wdt_dev);\r\nwatchdog_unregister_device(&pdc_wdt->wdt_dev);\r\nclk_disable_unprepare(pdc_wdt->wdt_clk);\r\nclk_disable_unprepare(pdc_wdt->sys_clk);\r\nreturn 0;\r\n}
