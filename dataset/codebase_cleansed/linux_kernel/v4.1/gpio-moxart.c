static int moxart_gpio_request(struct gpio_chip *chip, unsigned offset)\r\n{\r\nreturn pinctrl_request_gpio(offset);\r\n}\r\nstatic void moxart_gpio_free(struct gpio_chip *chip, unsigned offset)\r\n{\r\npinctrl_free_gpio(offset);\r\n}\r\nstatic int moxart_gpio_get(struct gpio_chip *chip, unsigned offset)\r\n{\r\nstruct bgpio_chip *bgc = to_bgpio_chip(chip);\r\nu32 ret = bgc->read_reg(bgc->reg_dir);\r\nif (ret & BIT(offset))\r\nreturn !!(bgc->read_reg(bgc->reg_set) & BIT(offset));\r\nelse\r\nreturn !!(bgc->read_reg(bgc->reg_dat) & BIT(offset));\r\n}\r\nstatic int moxart_gpio_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct resource *res;\r\nstruct bgpio_chip *bgc;\r\nvoid __iomem *base;\r\nint ret;\r\nbgc = devm_kzalloc(dev, sizeof(*bgc), GFP_KERNEL);\r\nif (!bgc)\r\nreturn -ENOMEM;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nbase = devm_ioremap_resource(dev, res);\r\nif (IS_ERR(base))\r\nreturn PTR_ERR(base);\r\nret = bgpio_init(bgc, dev, 4, base + GPIO_DATA_IN,\r\nbase + GPIO_DATA_OUT, NULL,\r\nbase + GPIO_PIN_DIRECTION, NULL, 0);\r\nif (ret) {\r\ndev_err(&pdev->dev, "bgpio_init failed\n");\r\nreturn ret;\r\n}\r\nbgc->gc.label = "moxart-gpio";\r\nbgc->gc.request = moxart_gpio_request;\r\nbgc->gc.free = moxart_gpio_free;\r\nbgc->gc.get = moxart_gpio_get;\r\nbgc->data = bgc->read_reg(bgc->reg_set);\r\nbgc->gc.base = 0;\r\nbgc->gc.ngpio = 32;\r\nbgc->gc.dev = dev;\r\nbgc->gc.owner = THIS_MODULE;\r\nret = gpiochip_add(&bgc->gc);\r\nif (ret) {\r\ndev_err(dev, "%s: gpiochip_add failed\n",\r\ndev->of_node->full_name);\r\nreturn ret;\r\n}\r\nreturn ret;\r\n}
