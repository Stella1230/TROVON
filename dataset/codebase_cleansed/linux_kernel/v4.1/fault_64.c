static inline __kprobes int notify_page_fault(struct pt_regs *regs)\r\n{\r\nint ret = 0;\r\nif (kprobes_built_in() && !user_mode(regs)) {\r\npreempt_disable();\r\nif (kprobe_running() && kprobe_fault_handler(regs, 0))\r\nret = 1;\r\npreempt_enable();\r\n}\r\nreturn ret;\r\n}\r\nstatic void __kprobes unhandled_fault(unsigned long address,\r\nstruct task_struct *tsk,\r\nstruct pt_regs *regs)\r\n{\r\nif ((unsigned long) address < PAGE_SIZE) {\r\nprintk(KERN_ALERT "Unable to handle kernel NULL "\r\n"pointer dereference\n");\r\n} else {\r\nprintk(KERN_ALERT "Unable to handle kernel paging request "\r\n"at virtual address %016lx\n", (unsigned long)address);\r\n}\r\nprintk(KERN_ALERT "tsk->{mm,active_mm}->context = %016lx\n",\r\n(tsk->mm ?\r\nCTX_HWBITS(tsk->mm->context) :\r\nCTX_HWBITS(tsk->active_mm->context)));\r\nprintk(KERN_ALERT "tsk->{mm,active_mm}->pgd = %016lx\n",\r\n(tsk->mm ? (unsigned long) tsk->mm->pgd :\r\n(unsigned long) tsk->active_mm->pgd));\r\ndie_if_kernel("Oops", regs);\r\n}\r\nstatic void __kprobes bad_kernel_pc(struct pt_regs *regs, unsigned long vaddr)\r\n{\r\nprintk(KERN_CRIT "OOPS: Bogus kernel PC [%016lx] in fault handler\n",\r\nregs->tpc);\r\nprintk(KERN_CRIT "OOPS: RPC [%016lx]\n", regs->u_regs[15]);\r\nprintk("OOPS: RPC <%pS>\n", (void *) regs->u_regs[15]);\r\nprintk(KERN_CRIT "OOPS: Fault was to vaddr[%lx]\n", vaddr);\r\ndump_stack();\r\nunhandled_fault(regs->tpc, current, regs);\r\n}\r\nstatic unsigned int get_user_insn(unsigned long tpc)\r\n{\r\npgd_t *pgdp = pgd_offset(current->mm, tpc);\r\npud_t *pudp;\r\npmd_t *pmdp;\r\npte_t *ptep, pte;\r\nunsigned long pa;\r\nu32 insn = 0;\r\nif (pgd_none(*pgdp) || unlikely(pgd_bad(*pgdp)))\r\ngoto out;\r\npudp = pud_offset(pgdp, tpc);\r\nif (pud_none(*pudp) || unlikely(pud_bad(*pudp)))\r\ngoto out;\r\nlocal_irq_disable();\r\npmdp = pmd_offset(pudp, tpc);\r\nif (pmd_none(*pmdp) || unlikely(pmd_bad(*pmdp)))\r\ngoto out_irq_enable;\r\n#ifdef CONFIG_TRANSPARENT_HUGEPAGE\r\nif (pmd_trans_huge(*pmdp)) {\r\nif (pmd_trans_splitting(*pmdp))\r\ngoto out_irq_enable;\r\npa = pmd_pfn(*pmdp) << PAGE_SHIFT;\r\npa += tpc & ~HPAGE_MASK;\r\n__asm__ __volatile__("lduwa [%1] %2, %0"\r\n: "=r" (insn)\r\n: "r" (pa), "i" (ASI_PHYS_USE_EC));\r\n} else\r\n#endif\r\n{\r\nptep = pte_offset_map(pmdp, tpc);\r\npte = *ptep;\r\nif (pte_present(pte)) {\r\npa = (pte_pfn(pte) << PAGE_SHIFT);\r\npa += (tpc & ~PAGE_MASK);\r\n__asm__ __volatile__("lduwa [%1] %2, %0"\r\n: "=r" (insn)\r\n: "r" (pa), "i" (ASI_PHYS_USE_EC));\r\n}\r\npte_unmap(ptep);\r\n}\r\nout_irq_enable:\r\nlocal_irq_enable();\r\nout:\r\nreturn insn;\r\n}\r\nstatic inline void\r\nshow_signal_msg(struct pt_regs *regs, int sig, int code,\r\nunsigned long address, struct task_struct *tsk)\r\n{\r\nif (!unhandled_signal(tsk, sig))\r\nreturn;\r\nif (!printk_ratelimit())\r\nreturn;\r\nprintk("%s%s[%d]: segfault at %lx ip %p (rpc %p) sp %p error %x",\r\ntask_pid_nr(tsk) > 1 ? KERN_INFO : KERN_EMERG,\r\ntsk->comm, task_pid_nr(tsk), address,\r\n(void *)regs->tpc, (void *)regs->u_regs[UREG_I7],\r\n(void *)regs->u_regs[UREG_FP], code);\r\nprint_vma_addr(KERN_CONT " in ", regs->tpc);\r\nprintk(KERN_CONT "\n");\r\n}\r\nstatic void do_fault_siginfo(int code, int sig, struct pt_regs *regs,\r\nunsigned long fault_addr, unsigned int insn,\r\nint fault_code)\r\n{\r\nunsigned long addr;\r\nsiginfo_t info;\r\ninfo.si_code = code;\r\ninfo.si_signo = sig;\r\ninfo.si_errno = 0;\r\nif (fault_code & FAULT_CODE_ITLB) {\r\naddr = regs->tpc;\r\n} else {\r\nif (insn)\r\naddr = compute_effective_address(regs, insn, 0);\r\nelse\r\naddr = fault_addr;\r\n}\r\ninfo.si_addr = (void __user *) addr;\r\ninfo.si_trapno = 0;\r\nif (unlikely(show_unhandled_signals))\r\nshow_signal_msg(regs, sig, code, addr, current);\r\nforce_sig_info(sig, &info, current);\r\n}\r\nstatic unsigned int get_fault_insn(struct pt_regs *regs, unsigned int insn)\r\n{\r\nif (!insn) {\r\nif (!regs->tpc || (regs->tpc & 0x3))\r\nreturn 0;\r\nif (regs->tstate & TSTATE_PRIV) {\r\ninsn = *(unsigned int *) regs->tpc;\r\n} else {\r\ninsn = get_user_insn(regs->tpc);\r\n}\r\n}\r\nreturn insn;\r\n}\r\nstatic void __kprobes do_kernel_fault(struct pt_regs *regs, int si_code,\r\nint fault_code, unsigned int insn,\r\nunsigned long address)\r\n{\r\nunsigned char asi = ASI_P;\r\nif ((!insn) && (regs->tstate & TSTATE_PRIV))\r\ngoto cannot_handle;\r\nif (!(fault_code & (FAULT_CODE_WRITE|FAULT_CODE_ITLB)) &&\r\n(insn & 0xc0800000) == 0xc0800000) {\r\nif (insn & 0x2000)\r\nasi = (regs->tstate >> 24);\r\nelse\r\nasi = (insn >> 5);\r\nif ((asi & 0xf2) == 0x82) {\r\nif (insn & 0x1000000) {\r\nhandle_ldf_stq(insn, regs);\r\n} else {\r\nhandle_ld_nf(insn, regs);\r\n}\r\nreturn;\r\n}\r\n}\r\nif (regs->tstate & TSTATE_PRIV) {\r\nconst struct exception_table_entry *entry;\r\nentry = search_exception_tables(regs->tpc);\r\nif (entry) {\r\nregs->tpc = entry->fixup;\r\nregs->tnpc = regs->tpc + 4;\r\nreturn;\r\n}\r\n} else {\r\ndo_fault_siginfo(si_code, SIGSEGV, regs, address, insn, fault_code);\r\nreturn;\r\n}\r\ncannot_handle:\r\nunhandled_fault (address, current, regs);\r\n}\r\nstatic void noinline __kprobes bogus_32bit_fault_tpc(struct pt_regs *regs)\r\n{\r\nstatic int times;\r\nif (times++ < 10)\r\nprintk(KERN_ERR "FAULT[%s:%d]: 32-bit process reports "\r\n"64-bit TPC [%lx]\n",\r\ncurrent->comm, current->pid,\r\nregs->tpc);\r\nshow_regs(regs);\r\n}\r\nasmlinkage void __kprobes do_sparc64_fault(struct pt_regs *regs)\r\n{\r\nenum ctx_state prev_state = exception_enter();\r\nstruct mm_struct *mm = current->mm;\r\nstruct vm_area_struct *vma;\r\nunsigned int insn = 0;\r\nint si_code, fault_code, fault;\r\nunsigned long address, mm_rss;\r\nunsigned int flags = FAULT_FLAG_ALLOW_RETRY | FAULT_FLAG_KILLABLE;\r\nfault_code = get_thread_fault_code();\r\nif (notify_page_fault(regs))\r\ngoto exit_exception;\r\nsi_code = SEGV_MAPERR;\r\naddress = current_thread_info()->fault_address;\r\nif ((fault_code & FAULT_CODE_ITLB) &&\r\n(fault_code & FAULT_CODE_DTLB))\r\nBUG();\r\nif (test_thread_flag(TIF_32BIT)) {\r\nif (!(regs->tstate & TSTATE_PRIV)) {\r\nif (unlikely((regs->tpc >> 32) != 0)) {\r\nbogus_32bit_fault_tpc(regs);\r\ngoto intr_or_no_mm;\r\n}\r\n}\r\nif (unlikely((address >> 32) != 0))\r\ngoto intr_or_no_mm;\r\n}\r\nif (regs->tstate & TSTATE_PRIV) {\r\nunsigned long tpc = regs->tpc;\r\nif ((tpc >= KERNBASE && tpc < (unsigned long) __init_end) ||\r\n(tpc >= MODULES_VADDR && tpc < MODULES_END)) {\r\n} else {\r\nbad_kernel_pc(regs, address);\r\ngoto exit_exception;\r\n}\r\n} else\r\nflags |= FAULT_FLAG_USER;\r\nif (in_atomic() || !mm)\r\ngoto intr_or_no_mm;\r\nperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS, 1, regs, address);\r\nif (!down_read_trylock(&mm->mmap_sem)) {\r\nif ((regs->tstate & TSTATE_PRIV) &&\r\n!search_exception_tables(regs->tpc)) {\r\ninsn = get_fault_insn(regs, insn);\r\ngoto handle_kernel_fault;\r\n}\r\nretry:\r\ndown_read(&mm->mmap_sem);\r\n}\r\nif (fault_code & FAULT_CODE_BAD_RA)\r\ngoto do_sigbus;\r\nvma = find_vma(mm, address);\r\nif (!vma)\r\ngoto bad_area;\r\nif (((fault_code &\r\n(FAULT_CODE_DTLB | FAULT_CODE_WRITE | FAULT_CODE_WINFIXUP)) == FAULT_CODE_DTLB) &&\r\n(vma->vm_flags & VM_WRITE) != 0) {\r\ninsn = get_fault_insn(regs, 0);\r\nif (!insn)\r\ngoto continue_fault;\r\nif ((insn & 0xc0200000) == 0xc0200000 &&\r\n(insn & 0x01780000) != 0x01680000) {\r\nfault_code |= FAULT_CODE_WRITE;\r\n}\r\n}\r\ncontinue_fault:\r\nif (vma->vm_start <= address)\r\ngoto good_area;\r\nif (!(vma->vm_flags & VM_GROWSDOWN))\r\ngoto bad_area;\r\nif (!(fault_code & FAULT_CODE_WRITE)) {\r\ninsn = get_fault_insn(regs, insn);\r\nif ((insn & 0xc0800000) == 0xc0800000) {\r\nunsigned char asi;\r\nif (insn & 0x2000)\r\nasi = (regs->tstate >> 24);\r\nelse\r\nasi = (insn >> 5);\r\nif ((asi & 0xf2) == 0x82)\r\ngoto bad_area;\r\n}\r\n}\r\nif (expand_stack(vma, address))\r\ngoto bad_area;\r\ngood_area:\r\nsi_code = SEGV_ACCERR;\r\nif ((fault_code & FAULT_CODE_ITLB) && !(vma->vm_flags & VM_EXEC)) {\r\nBUG_ON(address != regs->tpc);\r\nBUG_ON(regs->tstate & TSTATE_PRIV);\r\ngoto bad_area;\r\n}\r\nif (fault_code & FAULT_CODE_WRITE) {\r\nif (!(vma->vm_flags & VM_WRITE))\r\ngoto bad_area;\r\nif (tlb_type == spitfire &&\r\n(vma->vm_flags & VM_EXEC) != 0 &&\r\nvma->vm_file != NULL)\r\nset_thread_fault_code(fault_code |\r\nFAULT_CODE_BLKCOMMIT);\r\nflags |= FAULT_FLAG_WRITE;\r\n} else {\r\nif (!(vma->vm_flags & (VM_READ | VM_EXEC)))\r\ngoto bad_area;\r\n}\r\nfault = handle_mm_fault(mm, vma, address, flags);\r\nif ((fault & VM_FAULT_RETRY) && fatal_signal_pending(current))\r\ngoto exit_exception;\r\nif (unlikely(fault & VM_FAULT_ERROR)) {\r\nif (fault & VM_FAULT_OOM)\r\ngoto out_of_memory;\r\nelse if (fault & VM_FAULT_SIGSEGV)\r\ngoto bad_area;\r\nelse if (fault & VM_FAULT_SIGBUS)\r\ngoto do_sigbus;\r\nBUG();\r\n}\r\nif (flags & FAULT_FLAG_ALLOW_RETRY) {\r\nif (fault & VM_FAULT_MAJOR) {\r\ncurrent->maj_flt++;\r\nperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS_MAJ,\r\n1, regs, address);\r\n} else {\r\ncurrent->min_flt++;\r\nperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS_MIN,\r\n1, regs, address);\r\n}\r\nif (fault & VM_FAULT_RETRY) {\r\nflags &= ~FAULT_FLAG_ALLOW_RETRY;\r\nflags |= FAULT_FLAG_TRIED;\r\ngoto retry;\r\n}\r\n}\r\nup_read(&mm->mmap_sem);\r\nmm_rss = get_mm_rss(mm);\r\n#if defined(CONFIG_HUGETLB_PAGE) || defined(CONFIG_TRANSPARENT_HUGEPAGE)\r\nmm_rss -= (mm->context.huge_pte_count * (HPAGE_SIZE / PAGE_SIZE));\r\n#endif\r\nif (unlikely(mm_rss >\r\nmm->context.tsb_block[MM_TSB_BASE].tsb_rss_limit))\r\ntsb_grow(mm, MM_TSB_BASE, mm_rss);\r\n#if defined(CONFIG_HUGETLB_PAGE) || defined(CONFIG_TRANSPARENT_HUGEPAGE)\r\nmm_rss = mm->context.huge_pte_count;\r\nif (unlikely(mm_rss >\r\nmm->context.tsb_block[MM_TSB_HUGE].tsb_rss_limit)) {\r\nif (mm->context.tsb_block[MM_TSB_HUGE].tsb)\r\ntsb_grow(mm, MM_TSB_HUGE, mm_rss);\r\nelse\r\nhugetlb_setup(regs);\r\n}\r\n#endif\r\nexit_exception:\r\nexception_exit(prev_state);\r\nreturn;\r\nbad_area:\r\ninsn = get_fault_insn(regs, insn);\r\nup_read(&mm->mmap_sem);\r\nhandle_kernel_fault:\r\ndo_kernel_fault(regs, si_code, fault_code, insn, address);\r\ngoto exit_exception;\r\nout_of_memory:\r\ninsn = get_fault_insn(regs, insn);\r\nup_read(&mm->mmap_sem);\r\nif (!(regs->tstate & TSTATE_PRIV)) {\r\npagefault_out_of_memory();\r\ngoto exit_exception;\r\n}\r\ngoto handle_kernel_fault;\r\nintr_or_no_mm:\r\ninsn = get_fault_insn(regs, 0);\r\ngoto handle_kernel_fault;\r\ndo_sigbus:\r\ninsn = get_fault_insn(regs, insn);\r\nup_read(&mm->mmap_sem);\r\ndo_fault_siginfo(BUS_ADRERR, SIGBUS, regs, address, insn, fault_code);\r\nif (regs->tstate & TSTATE_PRIV)\r\ngoto handle_kernel_fault;\r\n}
