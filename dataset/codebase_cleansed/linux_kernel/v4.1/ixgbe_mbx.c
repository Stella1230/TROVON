s32 ixgbe_read_mbx(struct ixgbe_hw *hw, u32 *msg, u16 size, u16 mbx_id)\r\n{\r\nstruct ixgbe_mbx_info *mbx = &hw->mbx;\r\nif (size > mbx->size)\r\nsize = mbx->size;\r\nif (!mbx->ops.read)\r\nreturn IXGBE_ERR_MBX;\r\nreturn mbx->ops.read(hw, msg, size, mbx_id);\r\n}\r\ns32 ixgbe_write_mbx(struct ixgbe_hw *hw, u32 *msg, u16 size, u16 mbx_id)\r\n{\r\nstruct ixgbe_mbx_info *mbx = &hw->mbx;\r\nif (size > mbx->size)\r\nreturn IXGBE_ERR_MBX;\r\nif (!mbx->ops.write)\r\nreturn IXGBE_ERR_MBX;\r\nreturn mbx->ops.write(hw, msg, size, mbx_id);\r\n}\r\ns32 ixgbe_check_for_msg(struct ixgbe_hw *hw, u16 mbx_id)\r\n{\r\nstruct ixgbe_mbx_info *mbx = &hw->mbx;\r\nif (!mbx->ops.check_for_msg)\r\nreturn IXGBE_ERR_MBX;\r\nreturn mbx->ops.check_for_msg(hw, mbx_id);\r\n}\r\ns32 ixgbe_check_for_ack(struct ixgbe_hw *hw, u16 mbx_id)\r\n{\r\nstruct ixgbe_mbx_info *mbx = &hw->mbx;\r\nif (!mbx->ops.check_for_ack)\r\nreturn IXGBE_ERR_MBX;\r\nreturn mbx->ops.check_for_ack(hw, mbx_id);\r\n}\r\ns32 ixgbe_check_for_rst(struct ixgbe_hw *hw, u16 mbx_id)\r\n{\r\nstruct ixgbe_mbx_info *mbx = &hw->mbx;\r\nif (!mbx->ops.check_for_rst)\r\nreturn IXGBE_ERR_MBX;\r\nreturn mbx->ops.check_for_rst(hw, mbx_id);\r\n}\r\nstatic s32 ixgbe_poll_for_msg(struct ixgbe_hw *hw, u16 mbx_id)\r\n{\r\nstruct ixgbe_mbx_info *mbx = &hw->mbx;\r\nint countdown = mbx->timeout;\r\nif (!countdown || !mbx->ops.check_for_msg)\r\nreturn IXGBE_ERR_MBX;\r\nwhile (mbx->ops.check_for_msg(hw, mbx_id)) {\r\ncountdown--;\r\nif (!countdown)\r\nreturn IXGBE_ERR_MBX;\r\nudelay(mbx->usec_delay);\r\n}\r\nreturn 0;\r\n}\r\nstatic s32 ixgbe_poll_for_ack(struct ixgbe_hw *hw, u16 mbx_id)\r\n{\r\nstruct ixgbe_mbx_info *mbx = &hw->mbx;\r\nint countdown = mbx->timeout;\r\nif (!countdown || !mbx->ops.check_for_ack)\r\nreturn IXGBE_ERR_MBX;\r\nwhile (mbx->ops.check_for_ack(hw, mbx_id)) {\r\ncountdown--;\r\nif (!countdown)\r\nreturn IXGBE_ERR_MBX;\r\nudelay(mbx->usec_delay);\r\n}\r\nreturn 0;\r\n}\r\nstatic s32 ixgbe_read_posted_mbx(struct ixgbe_hw *hw, u32 *msg, u16 size,\r\nu16 mbx_id)\r\n{\r\nstruct ixgbe_mbx_info *mbx = &hw->mbx;\r\ns32 ret_val;\r\nif (!mbx->ops.read)\r\nreturn IXGBE_ERR_MBX;\r\nret_val = ixgbe_poll_for_msg(hw, mbx_id);\r\nif (ret_val)\r\nreturn ret_val;\r\nreturn mbx->ops.read(hw, msg, size, mbx_id);\r\n}\r\nstatic s32 ixgbe_write_posted_mbx(struct ixgbe_hw *hw, u32 *msg, u16 size,\r\nu16 mbx_id)\r\n{\r\nstruct ixgbe_mbx_info *mbx = &hw->mbx;\r\ns32 ret_val;\r\nif (!mbx->ops.write || !mbx->timeout)\r\nreturn IXGBE_ERR_MBX;\r\nret_val = mbx->ops.write(hw, msg, size, mbx_id);\r\nif (ret_val)\r\nreturn ret_val;\r\nreturn ixgbe_poll_for_ack(hw, mbx_id);\r\n}\r\nstatic s32 ixgbe_check_for_bit_pf(struct ixgbe_hw *hw, u32 mask, s32 index)\r\n{\r\nu32 mbvficr = IXGBE_READ_REG(hw, IXGBE_MBVFICR(index));\r\nif (mbvficr & mask) {\r\nIXGBE_WRITE_REG(hw, IXGBE_MBVFICR(index), mask);\r\nreturn 0;\r\n}\r\nreturn IXGBE_ERR_MBX;\r\n}\r\nstatic s32 ixgbe_check_for_msg_pf(struct ixgbe_hw *hw, u16 vf_number)\r\n{\r\ns32 index = IXGBE_MBVFICR_INDEX(vf_number);\r\nu32 vf_bit = vf_number % 16;\r\nif (!ixgbe_check_for_bit_pf(hw, IXGBE_MBVFICR_VFREQ_VF1 << vf_bit,\r\nindex)) {\r\nhw->mbx.stats.reqs++;\r\nreturn 0;\r\n}\r\nreturn IXGBE_ERR_MBX;\r\n}\r\nstatic s32 ixgbe_check_for_ack_pf(struct ixgbe_hw *hw, u16 vf_number)\r\n{\r\ns32 index = IXGBE_MBVFICR_INDEX(vf_number);\r\nu32 vf_bit = vf_number % 16;\r\nif (!ixgbe_check_for_bit_pf(hw, IXGBE_MBVFICR_VFACK_VF1 << vf_bit,\r\nindex)) {\r\nhw->mbx.stats.acks++;\r\nreturn 0;\r\n}\r\nreturn IXGBE_ERR_MBX;\r\n}\r\nstatic s32 ixgbe_check_for_rst_pf(struct ixgbe_hw *hw, u16 vf_number)\r\n{\r\nu32 reg_offset = (vf_number < 32) ? 0 : 1;\r\nu32 vf_shift = vf_number % 32;\r\nu32 vflre = 0;\r\nswitch (hw->mac.type) {\r\ncase ixgbe_mac_82599EB:\r\nvflre = IXGBE_READ_REG(hw, IXGBE_VFLRE(reg_offset));\r\nbreak;\r\ncase ixgbe_mac_X540:\r\ncase ixgbe_mac_X550:\r\ncase ixgbe_mac_X550EM_x:\r\nvflre = IXGBE_READ_REG(hw, IXGBE_VFLREC(reg_offset));\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif (vflre & (1 << vf_shift)) {\r\nIXGBE_WRITE_REG(hw, IXGBE_VFLREC(reg_offset), (1 << vf_shift));\r\nhw->mbx.stats.rsts++;\r\nreturn 0;\r\n}\r\nreturn IXGBE_ERR_MBX;\r\n}\r\nstatic s32 ixgbe_obtain_mbx_lock_pf(struct ixgbe_hw *hw, u16 vf_number)\r\n{\r\nu32 p2v_mailbox;\r\nIXGBE_WRITE_REG(hw, IXGBE_PFMAILBOX(vf_number), IXGBE_PFMAILBOX_PFU);\r\np2v_mailbox = IXGBE_READ_REG(hw, IXGBE_PFMAILBOX(vf_number));\r\nif (p2v_mailbox & IXGBE_PFMAILBOX_PFU)\r\nreturn 0;\r\nreturn IXGBE_ERR_MBX;\r\n}\r\nstatic s32 ixgbe_write_mbx_pf(struct ixgbe_hw *hw, u32 *msg, u16 size,\r\nu16 vf_number)\r\n{\r\ns32 ret_val;\r\nu16 i;\r\nret_val = ixgbe_obtain_mbx_lock_pf(hw, vf_number);\r\nif (ret_val)\r\nreturn ret_val;\r\nixgbe_check_for_msg_pf(hw, vf_number);\r\nixgbe_check_for_ack_pf(hw, vf_number);\r\nfor (i = 0; i < size; i++)\r\nIXGBE_WRITE_REG_ARRAY(hw, IXGBE_PFMBMEM(vf_number), i, msg[i]);\r\nIXGBE_WRITE_REG(hw, IXGBE_PFMAILBOX(vf_number), IXGBE_PFMAILBOX_STS);\r\nhw->mbx.stats.msgs_tx++;\r\nreturn 0;\r\n}\r\nstatic s32 ixgbe_read_mbx_pf(struct ixgbe_hw *hw, u32 *msg, u16 size,\r\nu16 vf_number)\r\n{\r\ns32 ret_val;\r\nu16 i;\r\nret_val = ixgbe_obtain_mbx_lock_pf(hw, vf_number);\r\nif (ret_val)\r\nreturn ret_val;\r\nfor (i = 0; i < size; i++)\r\nmsg[i] = IXGBE_READ_REG_ARRAY(hw, IXGBE_PFMBMEM(vf_number), i);\r\nIXGBE_WRITE_REG(hw, IXGBE_PFMAILBOX(vf_number), IXGBE_PFMAILBOX_ACK);\r\nhw->mbx.stats.msgs_rx++;\r\nreturn 0;\r\n}\r\nvoid ixgbe_init_mbx_params_pf(struct ixgbe_hw *hw)\r\n{\r\nstruct ixgbe_mbx_info *mbx = &hw->mbx;\r\nif (hw->mac.type != ixgbe_mac_82599EB &&\r\nhw->mac.type != ixgbe_mac_X550 &&\r\nhw->mac.type != ixgbe_mac_X550EM_x &&\r\nhw->mac.type != ixgbe_mac_X540)\r\nreturn;\r\nmbx->timeout = 0;\r\nmbx->usec_delay = 0;\r\nmbx->stats.msgs_tx = 0;\r\nmbx->stats.msgs_rx = 0;\r\nmbx->stats.reqs = 0;\r\nmbx->stats.acks = 0;\r\nmbx->stats.rsts = 0;\r\nmbx->size = IXGBE_VFMAILBOX_SIZE;\r\n}
