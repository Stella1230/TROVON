static unsigned int max77686_get_opmode_shift(int id)\r\n{\r\nswitch (id) {\r\ncase MAX77686_BUCK1:\r\ncase MAX77686_BUCK5 ... MAX77686_BUCK9:\r\nreturn 0;\r\ncase MAX77686_BUCK2 ... MAX77686_BUCK4:\r\nreturn MAX77686_OPMODE_BUCK234_SHIFT;\r\ndefault:\r\nreturn MAX77686_OPMODE_SHIFT;\r\n}\r\n}\r\nstatic unsigned int max77686_map_normal_mode(struct max77686_data *max77686,\r\nint id)\r\n{\r\nswitch (id) {\r\ncase MAX77686_BUCK8:\r\ncase MAX77686_BUCK9:\r\ncase MAX77686_LDO20 ... MAX77686_LDO22:\r\nif (max77686->gpio_enabled & (1 << id))\r\nreturn MAX77686_GPIO_CONTROL;\r\n}\r\nreturn MAX77686_NORMAL;\r\n}\r\nstatic int max77686_set_suspend_disable(struct regulator_dev *rdev)\r\n{\r\nunsigned int val, shift;\r\nstruct max77686_data *max77686 = rdev_get_drvdata(rdev);\r\nint ret, id = rdev_get_id(rdev);\r\nshift = max77686_get_opmode_shift(id);\r\nval = MAX77686_OFF_PWRREQ;\r\nret = regmap_update_bits(rdev->regmap, rdev->desc->enable_reg,\r\nrdev->desc->enable_mask, val << shift);\r\nif (ret)\r\nreturn ret;\r\nmax77686->opmode[id] = val;\r\nreturn 0;\r\n}\r\nstatic int max77686_set_suspend_mode(struct regulator_dev *rdev,\r\nunsigned int mode)\r\n{\r\nstruct max77686_data *max77686 = rdev_get_drvdata(rdev);\r\nunsigned int val;\r\nint ret, id = rdev_get_id(rdev);\r\nif (id >= MAX77686_BUCK5)\r\nreturn 0;\r\nswitch (mode) {\r\ncase REGULATOR_MODE_IDLE:\r\nval = MAX77686_LDO_LOWPOWER_PWRREQ;\r\nbreak;\r\ncase REGULATOR_MODE_NORMAL:\r\nval = max77686_map_normal_mode(max77686, id);\r\nbreak;\r\ndefault:\r\npr_warn("%s: regulator_suspend_mode : 0x%x not supported\n",\r\nrdev->desc->name, mode);\r\nreturn -EINVAL;\r\n}\r\nret = regmap_update_bits(rdev->regmap, rdev->desc->enable_reg,\r\nrdev->desc->enable_mask,\r\nval << MAX77686_OPMODE_SHIFT);\r\nif (ret)\r\nreturn ret;\r\nmax77686->opmode[id] = val;\r\nreturn 0;\r\n}\r\nstatic int max77686_ldo_set_suspend_mode(struct regulator_dev *rdev,\r\nunsigned int mode)\r\n{\r\nunsigned int val;\r\nstruct max77686_data *max77686 = rdev_get_drvdata(rdev);\r\nint ret, id = rdev_get_id(rdev);\r\nswitch (mode) {\r\ncase REGULATOR_MODE_STANDBY:\r\nval = MAX77686_OFF_PWRREQ;\r\nbreak;\r\ncase REGULATOR_MODE_IDLE:\r\nval = MAX77686_LDO_LOWPOWER_PWRREQ;\r\nbreak;\r\ncase REGULATOR_MODE_NORMAL:\r\nval = max77686_map_normal_mode(max77686, id);\r\nbreak;\r\ndefault:\r\npr_warn("%s: regulator_suspend_mode : 0x%x not supported\n",\r\nrdev->desc->name, mode);\r\nreturn -EINVAL;\r\n}\r\nret = regmap_update_bits(rdev->regmap, rdev->desc->enable_reg,\r\nrdev->desc->enable_mask,\r\nval << MAX77686_OPMODE_SHIFT);\r\nif (ret)\r\nreturn ret;\r\nmax77686->opmode[id] = val;\r\nreturn 0;\r\n}\r\nstatic int max77686_enable(struct regulator_dev *rdev)\r\n{\r\nstruct max77686_data *max77686 = rdev_get_drvdata(rdev);\r\nunsigned int shift;\r\nint id = rdev_get_id(rdev);\r\nshift = max77686_get_opmode_shift(id);\r\nif (max77686->opmode[id] == MAX77686_OFF_PWRREQ)\r\nmax77686->opmode[id] = max77686_map_normal_mode(max77686, id);\r\nreturn regmap_update_bits(rdev->regmap, rdev->desc->enable_reg,\r\nrdev->desc->enable_mask,\r\nmax77686->opmode[id] << shift);\r\n}\r\nstatic int max77686_set_ramp_delay(struct regulator_dev *rdev, int ramp_delay)\r\n{\r\nunsigned int ramp_value = RAMP_RATE_NO_CTRL;\r\nswitch (ramp_delay) {\r\ncase 1 ... 13750:\r\nramp_value = RAMP_RATE_13P75MV;\r\nbreak;\r\ncase 13751 ... 27500:\r\nramp_value = RAMP_RATE_27P5MV;\r\nbreak;\r\ncase 27501 ... 55000:\r\nramp_value = RAMP_RATE_55MV;\r\nbreak;\r\ncase 55001 ... 100000:\r\nbreak;\r\ndefault:\r\npr_warn("%s: ramp_delay: %d not supported, setting 100000\n",\r\nrdev->desc->name, ramp_delay);\r\n}\r\nreturn regmap_update_bits(rdev->regmap, rdev->desc->enable_reg,\r\nMAX77686_RAMP_RATE_MASK, ramp_value << 6);\r\n}\r\nstatic int max77686_of_parse_cb(struct device_node *np,\r\nconst struct regulator_desc *desc,\r\nstruct regulator_config *config)\r\n{\r\nstruct max77686_data *max77686 = config->driver_data;\r\nswitch (desc->id) {\r\ncase MAX77686_BUCK8:\r\ncase MAX77686_BUCK9:\r\ncase MAX77686_LDO20 ... MAX77686_LDO22:\r\nconfig->ena_gpio = of_get_named_gpio(np,\r\n"maxim,ena-gpios", 0);\r\nconfig->ena_gpio_flags = GPIOF_OUT_INIT_HIGH;\r\nconfig->ena_gpio_initialized = true;\r\nbreak;\r\ndefault:\r\nreturn 0;\r\n}\r\nif (gpio_is_valid(config->ena_gpio)) {\r\nmax77686->gpio_enabled |= (1 << desc->id);\r\nreturn regmap_update_bits(config->regmap, desc->enable_reg,\r\ndesc->enable_mask,\r\nMAX77686_GPIO_CONTROL);\r\n}\r\nreturn 0;\r\n}\r\nstatic int max77686_pmic_probe(struct platform_device *pdev)\r\n{\r\nstruct max77686_dev *iodev = dev_get_drvdata(pdev->dev.parent);\r\nstruct max77686_data *max77686;\r\nint i;\r\nstruct regulator_config config = { };\r\ndev_dbg(&pdev->dev, "%s\n", __func__);\r\nmax77686 = devm_kzalloc(&pdev->dev, sizeof(struct max77686_data),\r\nGFP_KERNEL);\r\nif (!max77686)\r\nreturn -ENOMEM;\r\nconfig.dev = iodev->dev;\r\nconfig.regmap = iodev->regmap;\r\nconfig.driver_data = max77686;\r\nplatform_set_drvdata(pdev, max77686);\r\nfor (i = 0; i < MAX77686_REGULATORS; i++) {\r\nstruct regulator_dev *rdev;\r\nint id = regulators[i].id;\r\nmax77686->opmode[id] = MAX77686_NORMAL;\r\nrdev = devm_regulator_register(&pdev->dev,\r\n&regulators[i], &config);\r\nif (IS_ERR(rdev)) {\r\nint ret = PTR_ERR(rdev);\r\ndev_err(&pdev->dev,\r\n"regulator init failed for %d: %d\n", i, ret);\r\nreturn ret;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init max77686_pmic_init(void)\r\n{\r\nreturn platform_driver_register(&max77686_pmic_driver);\r\n}\r\nstatic void __exit max77686_pmic_cleanup(void)\r\n{\r\nplatform_driver_unregister(&max77686_pmic_driver);\r\n}
