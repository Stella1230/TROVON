static void drop_pagecache_sb(struct super_block *sb, void *unused)\r\n{\r\nstruct inode *inode, *toput_inode = NULL;\r\nspin_lock(&inode_sb_list_lock);\r\nlist_for_each_entry(inode, &sb->s_inodes, i_sb_list) {\r\nspin_lock(&inode->i_lock);\r\nif ((inode->i_state & (I_FREEING|I_WILL_FREE|I_NEW)) ||\r\n(inode->i_mapping->nrpages == 0)) {\r\nspin_unlock(&inode->i_lock);\r\ncontinue;\r\n}\r\n__iget(inode);\r\nspin_unlock(&inode->i_lock);\r\nspin_unlock(&inode_sb_list_lock);\r\ninvalidate_mapping_pages(inode->i_mapping, 0, -1);\r\niput(toput_inode);\r\ntoput_inode = inode;\r\nspin_lock(&inode_sb_list_lock);\r\n}\r\nspin_unlock(&inode_sb_list_lock);\r\niput(toput_inode);\r\n}\r\nint drop_caches_sysctl_handler(struct ctl_table *table, int write,\r\nvoid __user *buffer, size_t *length, loff_t *ppos)\r\n{\r\nint ret;\r\nret = proc_dointvec_minmax(table, write, buffer, length, ppos);\r\nif (ret)\r\nreturn ret;\r\nif (write) {\r\nstatic int stfu;\r\nif (sysctl_drop_caches & 1) {\r\niterate_supers(drop_pagecache_sb, NULL);\r\ncount_vm_event(DROP_PAGECACHE);\r\n}\r\nif (sysctl_drop_caches & 2) {\r\ndrop_slab();\r\ncount_vm_event(DROP_SLAB);\r\n}\r\nif (!stfu) {\r\npr_info("%s (%d): drop_caches: %d\n",\r\ncurrent->comm, task_pid_nr(current),\r\nsysctl_drop_caches);\r\n}\r\nstfu |= sysctl_drop_caches & 4;\r\n}\r\nreturn 0;\r\n}
