static inline struct geneve_port *geneve_vport(const struct vport *vport)\r\n{\r\nreturn vport_priv(vport);\r\n}\r\nstatic inline struct genevehdr *geneve_hdr(const struct sk_buff *skb)\r\n{\r\nreturn (struct genevehdr *)(udp_hdr(skb) + 1);\r\n}\r\nstatic void tunnel_id_to_vni(__be64 tun_id, __u8 *vni)\r\n{\r\n#ifdef __BIG_ENDIAN\r\nvni[0] = (__force __u8)(tun_id >> 16);\r\nvni[1] = (__force __u8)(tun_id >> 8);\r\nvni[2] = (__force __u8)tun_id;\r\n#else\r\nvni[0] = (__force __u8)((__force u64)tun_id >> 40);\r\nvni[1] = (__force __u8)((__force u64)tun_id >> 48);\r\nvni[2] = (__force __u8)((__force u64)tun_id >> 56);\r\n#endif\r\n}\r\nstatic __be64 vni_to_tunnel_id(const __u8 *vni)\r\n{\r\n#ifdef __BIG_ENDIAN\r\nreturn (vni[0] << 16) | (vni[1] << 8) | vni[2];\r\n#else\r\nreturn (__force __be64)(((__force u64)vni[0] << 40) |\r\n((__force u64)vni[1] << 48) |\r\n((__force u64)vni[2] << 56));\r\n#endif\r\n}\r\nstatic void geneve_rcv(struct geneve_sock *gs, struct sk_buff *skb)\r\n{\r\nstruct vport *vport = gs->rcv_data;\r\nstruct genevehdr *geneveh = geneve_hdr(skb);\r\nint opts_len;\r\nstruct ovs_tunnel_info tun_info;\r\n__be64 key;\r\n__be16 flags;\r\nopts_len = geneveh->opt_len * 4;\r\nflags = TUNNEL_KEY | TUNNEL_GENEVE_OPT |\r\n(udp_hdr(skb)->check != 0 ? TUNNEL_CSUM : 0) |\r\n(geneveh->oam ? TUNNEL_OAM : 0) |\r\n(geneveh->critical ? TUNNEL_CRIT_OPT : 0);\r\nkey = vni_to_tunnel_id(geneveh->vni);\r\novs_flow_tun_info_init(&tun_info, ip_hdr(skb),\r\nudp_hdr(skb)->source, udp_hdr(skb)->dest,\r\nkey, flags,\r\ngeneveh->options, opts_len);\r\novs_vport_receive(vport, skb, &tun_info);\r\n}\r\nstatic int geneve_get_options(const struct vport *vport,\r\nstruct sk_buff *skb)\r\n{\r\nstruct geneve_port *geneve_port = geneve_vport(vport);\r\nstruct inet_sock *sk = inet_sk(geneve_port->gs->sock->sk);\r\nif (nla_put_u16(skb, OVS_TUNNEL_ATTR_DST_PORT, ntohs(sk->inet_sport)))\r\nreturn -EMSGSIZE;\r\nreturn 0;\r\n}\r\nstatic void geneve_tnl_destroy(struct vport *vport)\r\n{\r\nstruct geneve_port *geneve_port = geneve_vport(vport);\r\ngeneve_sock_release(geneve_port->gs);\r\novs_vport_deferred_free(vport);\r\n}\r\nstatic struct vport *geneve_tnl_create(const struct vport_parms *parms)\r\n{\r\nstruct net *net = ovs_dp_get_net(parms->dp);\r\nstruct nlattr *options = parms->options;\r\nstruct geneve_port *geneve_port;\r\nstruct geneve_sock *gs;\r\nstruct vport *vport;\r\nstruct nlattr *a;\r\nint err;\r\nu16 dst_port;\r\nif (!options) {\r\nerr = -EINVAL;\r\ngoto error;\r\n}\r\na = nla_find_nested(options, OVS_TUNNEL_ATTR_DST_PORT);\r\nif (a && nla_len(a) == sizeof(u16)) {\r\ndst_port = nla_get_u16(a);\r\n} else {\r\nerr = -EINVAL;\r\ngoto error;\r\n}\r\nvport = ovs_vport_alloc(sizeof(struct geneve_port),\r\n&ovs_geneve_vport_ops, parms);\r\nif (IS_ERR(vport))\r\nreturn vport;\r\ngeneve_port = geneve_vport(vport);\r\nstrncpy(geneve_port->name, parms->name, IFNAMSIZ);\r\ngs = geneve_sock_add(net, htons(dst_port), geneve_rcv, vport, true, 0);\r\nif (IS_ERR(gs)) {\r\novs_vport_free(vport);\r\nreturn (void *)gs;\r\n}\r\ngeneve_port->gs = gs;\r\nreturn vport;\r\nerror:\r\nreturn ERR_PTR(err);\r\n}\r\nstatic int geneve_tnl_send(struct vport *vport, struct sk_buff *skb)\r\n{\r\nconst struct ovs_key_ipv4_tunnel *tun_key;\r\nstruct ovs_tunnel_info *tun_info;\r\nstruct net *net = ovs_dp_get_net(vport->dp);\r\nstruct geneve_port *geneve_port = geneve_vport(vport);\r\n__be16 dport = inet_sk(geneve_port->gs->sock->sk)->inet_sport;\r\n__be16 sport;\r\nstruct rtable *rt;\r\nstruct flowi4 fl;\r\nu8 vni[3], opts_len, *opts;\r\n__be16 df;\r\nint err;\r\ntun_info = OVS_CB(skb)->egress_tun_info;\r\nif (unlikely(!tun_info)) {\r\nerr = -EINVAL;\r\ngoto error;\r\n}\r\ntun_key = &tun_info->tunnel;\r\nrt = ovs_tunnel_route_lookup(net, tun_key, skb->mark, &fl, IPPROTO_UDP);\r\nif (IS_ERR(rt)) {\r\nerr = PTR_ERR(rt);\r\ngoto error;\r\n}\r\ndf = tun_key->tun_flags & TUNNEL_DONT_FRAGMENT ? htons(IP_DF) : 0;\r\nsport = udp_flow_src_port(net, skb, 1, USHRT_MAX, true);\r\ntunnel_id_to_vni(tun_key->tun_id, vni);\r\nskb->ignore_df = 1;\r\nif (tun_key->tun_flags & TUNNEL_GENEVE_OPT) {\r\nopts = (u8 *)tun_info->options;\r\nopts_len = tun_info->options_len;\r\n} else {\r\nopts = NULL;\r\nopts_len = 0;\r\n}\r\nerr = geneve_xmit_skb(geneve_port->gs, rt, skb, fl.saddr,\r\ntun_key->ipv4_dst, tun_key->ipv4_tos,\r\ntun_key->ipv4_ttl, df, sport, dport,\r\ntun_key->tun_flags, vni, opts_len, opts,\r\n!!(tun_key->tun_flags & TUNNEL_CSUM), false);\r\nif (err < 0)\r\nip_rt_put(rt);\r\nreturn err;\r\nerror:\r\nkfree_skb(skb);\r\nreturn err;\r\n}\r\nstatic const char *geneve_get_name(const struct vport *vport)\r\n{\r\nstruct geneve_port *geneve_port = geneve_vport(vport);\r\nreturn geneve_port->name;\r\n}\r\nstatic int geneve_get_egress_tun_info(struct vport *vport, struct sk_buff *skb,\r\nstruct ovs_tunnel_info *egress_tun_info)\r\n{\r\nstruct geneve_port *geneve_port = geneve_vport(vport);\r\nstruct net *net = ovs_dp_get_net(vport->dp);\r\n__be16 dport = inet_sk(geneve_port->gs->sock->sk)->inet_sport;\r\n__be16 sport = udp_flow_src_port(net, skb, 1, USHRT_MAX, true);\r\nreturn ovs_tunnel_get_egress_info(egress_tun_info,\r\novs_dp_get_net(vport->dp),\r\nOVS_CB(skb)->egress_tun_info,\r\nIPPROTO_UDP, skb->mark, sport, dport);\r\n}\r\nstatic int __init ovs_geneve_tnl_init(void)\r\n{\r\nreturn ovs_vport_ops_register(&ovs_geneve_vport_ops);\r\n}\r\nstatic void __exit ovs_geneve_tnl_exit(void)\r\n{\r\novs_vport_ops_unregister(&ovs_geneve_vport_ops);\r\n}
