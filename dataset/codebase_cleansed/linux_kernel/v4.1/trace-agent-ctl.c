static void signal_handler(int sig)\r\n{\r\nglobal_signal_val = sig;\r\n}\r\nint rw_ctl_init(const char *ctl_path)\r\n{\r\nint ctl_fd;\r\nctl_fd = open(ctl_path, O_RDONLY);\r\nif (ctl_fd == -1) {\r\npr_err("Cannot open ctl_fd\n");\r\ngoto error;\r\n}\r\nreturn ctl_fd;\r\nerror:\r\nexit(EXIT_FAILURE);\r\n}\r\nstatic int wait_order(int ctl_fd)\r\n{\r\nstruct pollfd poll_fd;\r\nint ret = 0;\r\nwhile (!global_sig_receive) {\r\npoll_fd.fd = ctl_fd;\r\npoll_fd.events = POLLIN;\r\nret = poll(&poll_fd, 1, EVENT_WAIT_MSEC);\r\nif (global_signal_val) {\r\nglobal_sig_receive = true;\r\npr_info("Receive interrupt %d\n", global_signal_val);\r\nif (!global_run_operation)\r\npthread_cond_broadcast(&cond_wakeup);\r\nret = -1;\r\nbreak;\r\n}\r\nif (ret < 0) {\r\npr_err("Polling error\n");\r\ngoto error;\r\n}\r\nif (ret)\r\nbreak;\r\n};\r\nreturn ret;\r\nerror:\r\nexit(EXIT_FAILURE);\r\n}\r\nvoid *rw_ctl_loop(int ctl_fd)\r\n{\r\nssize_t rlen;\r\nchar buf[HOST_MSG_SIZE];\r\nint ret;\r\nsignal(SIGTERM, signal_handler);\r\nsignal(SIGINT, signal_handler);\r\nsignal(SIGQUIT, signal_handler);\r\nwhile (!global_sig_receive) {\r\nret = wait_order(ctl_fd);\r\nif (ret < 0)\r\nbreak;\r\nrlen = read(ctl_fd, buf, sizeof(buf));\r\nif (rlen < 0) {\r\npr_err("read data error in ctl thread\n");\r\ngoto error;\r\n}\r\nif (rlen == 2 && buf[0] == '1') {\r\nglobal_run_operation = true;\r\npthread_cond_broadcast(&cond_wakeup);\r\npr_debug("Wake up all read/write threads\n");\r\n} else if (rlen == 2 && buf[0] == '0') {\r\nglobal_run_operation = false;\r\npr_debug("Stop all read/write threads\n");\r\n} else\r\npr_info("Invalid host notification: %s\n", buf);\r\n}\r\nreturn NULL;\r\nerror:\r\nexit(EXIT_FAILURE);\r\n}
