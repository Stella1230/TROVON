static void ep0_reset(struct mv_udc *udc)\r\n{\r\nstruct mv_ep *ep;\r\nu32 epctrlx;\r\nint i = 0;\r\nfor (i = 0; i < 2; i++) {\r\nep = &udc->eps[i];\r\nep->udc = udc;\r\nep->dqh = &udc->ep_dqh[i];\r\nep->dqh->max_packet_length =\r\n(EP0_MAX_PKT_SIZE << EP_QUEUE_HEAD_MAX_PKT_LEN_POS)\r\n| EP_QUEUE_HEAD_IOS;\r\nep->dqh->next_dtd_ptr = EP_QUEUE_HEAD_NEXT_TERMINATE;\r\nepctrlx = readl(&udc->op_regs->epctrlx[0]);\r\nif (i) {\r\nepctrlx |= EPCTRL_TX_ENABLE\r\n| (USB_ENDPOINT_XFER_CONTROL\r\n<< EPCTRL_TX_EP_TYPE_SHIFT);\r\n} else {\r\nepctrlx |= EPCTRL_RX_ENABLE\r\n| (USB_ENDPOINT_XFER_CONTROL\r\n<< EPCTRL_RX_EP_TYPE_SHIFT);\r\n}\r\nwritel(epctrlx, &udc->op_regs->epctrlx[0]);\r\n}\r\n}\r\nstatic void ep0_stall(struct mv_udc *udc)\r\n{\r\nu32 epctrlx;\r\nepctrlx = readl(&udc->op_regs->epctrlx[0]);\r\nepctrlx |= EPCTRL_RX_EP_STALL | EPCTRL_TX_EP_STALL;\r\nwritel(epctrlx, &udc->op_regs->epctrlx[0]);\r\nudc->ep0_state = WAIT_FOR_SETUP;\r\nudc->ep0_dir = EP_DIR_OUT;\r\n}\r\nstatic int process_ep_req(struct mv_udc *udc, int index,\r\nstruct mv_req *curr_req)\r\n{\r\nstruct mv_dtd *curr_dtd;\r\nstruct mv_dqh *curr_dqh;\r\nint td_complete, actual, remaining_length;\r\nint i, direction;\r\nint retval = 0;\r\nu32 errors;\r\nu32 bit_pos;\r\ncurr_dqh = &udc->ep_dqh[index];\r\ndirection = index % 2;\r\ncurr_dtd = curr_req->head;\r\ntd_complete = 0;\r\nactual = curr_req->req.length;\r\nfor (i = 0; i < curr_req->dtd_count; i++) {\r\nif (curr_dtd->size_ioc_sts & DTD_STATUS_ACTIVE) {\r\ndev_dbg(&udc->dev->dev, "%s, dTD not completed\n",\r\nudc->eps[index].name);\r\nreturn 1;\r\n}\r\nerrors = curr_dtd->size_ioc_sts & DTD_ERROR_MASK;\r\nif (!errors) {\r\nremaining_length =\r\n(curr_dtd->size_ioc_sts & DTD_PACKET_SIZE)\r\n>> DTD_LENGTH_BIT_POS;\r\nactual -= remaining_length;\r\nif (remaining_length) {\r\nif (direction) {\r\ndev_dbg(&udc->dev->dev,\r\n"TX dTD remains data\n");\r\nretval = -EPROTO;\r\nbreak;\r\n} else\r\nbreak;\r\n}\r\n} else {\r\ndev_info(&udc->dev->dev,\r\n"complete_tr error: ep=%d %s: error = 0x%x\n",\r\nindex >> 1, direction ? "SEND" : "RECV",\r\nerrors);\r\nif (errors & DTD_STATUS_HALTED) {\r\ncurr_dqh->size_ioc_int_sts &= ~errors;\r\nretval = -EPIPE;\r\n} else if (errors & DTD_STATUS_DATA_BUFF_ERR) {\r\nretval = -EPROTO;\r\n} else if (errors & DTD_STATUS_TRANSACTION_ERR) {\r\nretval = -EILSEQ;\r\n}\r\n}\r\nif (i != curr_req->dtd_count - 1)\r\ncurr_dtd = (struct mv_dtd *)curr_dtd->next_dtd_virt;\r\n}\r\nif (retval)\r\nreturn retval;\r\nif (direction == EP_DIR_OUT)\r\nbit_pos = 1 << curr_req->ep->ep_num;\r\nelse\r\nbit_pos = 1 << (16 + curr_req->ep->ep_num);\r\nwhile ((curr_dqh->curr_dtd_ptr == curr_dtd->td_dma)) {\r\nif (curr_dtd->dtd_next == EP_QUEUE_HEAD_NEXT_TERMINATE) {\r\nwhile (readl(&udc->op_regs->epstatus) & bit_pos)\r\nudelay(1);\r\nbreak;\r\n}\r\nudelay(1);\r\n}\r\ncurr_req->req.actual = actual;\r\nreturn 0;\r\n}\r\nstatic void done(struct mv_ep *ep, struct mv_req *req, int status)\r\n__releases(&ep->udc->lock\r\nstatic int queue_dtd(struct mv_ep *ep, struct mv_req *req)\r\n{\r\nstruct mv_udc *udc;\r\nstruct mv_dqh *dqh;\r\nu32 bit_pos, direction;\r\nu32 usbcmd, epstatus;\r\nunsigned int loops;\r\nint retval = 0;\r\nudc = ep->udc;\r\ndirection = ep_dir(ep);\r\ndqh = &(udc->ep_dqh[ep->ep_num * 2 + direction]);\r\nbit_pos = 1 << (((direction == EP_DIR_OUT) ? 0 : 16) + ep->ep_num);\r\nif (!(list_empty(&ep->queue))) {\r\nstruct mv_req *lastreq;\r\nlastreq = list_entry(ep->queue.prev, struct mv_req, queue);\r\nlastreq->tail->dtd_next =\r\nreq->head->td_dma & EP_QUEUE_HEAD_NEXT_POINTER_MASK;\r\nwmb();\r\nif (readl(&udc->op_regs->epprime) & bit_pos)\r\ngoto done;\r\nloops = LOOPS(READSAFE_TIMEOUT);\r\nwhile (1) {\r\nusbcmd = readl(&udc->op_regs->usbcmd);\r\nusbcmd |= USBCMD_ATDTW_TRIPWIRE_SET;\r\nwritel(usbcmd, &udc->op_regs->usbcmd);\r\nepstatus = readl(&udc->op_regs->epstatus) & bit_pos;\r\nif (readl(&udc->op_regs->usbcmd)\r\n& USBCMD_ATDTW_TRIPWIRE_SET)\r\nbreak;\r\nloops--;\r\nif (loops == 0) {\r\ndev_err(&udc->dev->dev,\r\n"Timeout for ATDTW_TRIPWIRE...\n");\r\nretval = -ETIME;\r\ngoto done;\r\n}\r\nudelay(LOOPS_USEC);\r\n}\r\nusbcmd = readl(&udc->op_regs->usbcmd);\r\nusbcmd &= USBCMD_ATDTW_TRIPWIRE_CLEAR;\r\nwritel(usbcmd, &udc->op_regs->usbcmd);\r\nif (epstatus)\r\ngoto done;\r\n}\r\ndqh->next_dtd_ptr = req->head->td_dma\r\n& EP_QUEUE_HEAD_NEXT_POINTER_MASK;\r\ndqh->size_ioc_int_sts &= ~(DTD_STATUS_ACTIVE | DTD_STATUS_HALTED);\r\nwmb();\r\nwritel(bit_pos, &udc->op_regs->epprime);\r\ndone:\r\nreturn retval;\r\n}\r\nstatic struct mv_dtd *build_dtd(struct mv_req *req, unsigned *length,\r\ndma_addr_t *dma, int *is_last)\r\n{\r\nstruct mv_dtd *dtd;\r\nstruct mv_udc *udc;\r\nstruct mv_dqh *dqh;\r\nu32 temp, mult = 0;\r\nif (usb_endpoint_xfer_isoc(req->ep->ep.desc)) {\r\ndqh = req->ep->dqh;\r\nmult = (dqh->max_packet_length >> EP_QUEUE_HEAD_MULT_POS)\r\n& 0x3;\r\n*length = min(req->req.length - req->req.actual,\r\n(unsigned)(mult * req->ep->ep.maxpacket));\r\n} else\r\n*length = min(req->req.length - req->req.actual,\r\n(unsigned)EP_MAX_LENGTH_TRANSFER);\r\nudc = req->ep->udc;\r\ndtd = dma_pool_alloc(udc->dtd_pool, GFP_ATOMIC, dma);\r\nif (dtd == NULL)\r\nreturn dtd;\r\ndtd->td_dma = *dma;\r\ntemp = (u32)(req->req.dma + req->req.actual);\r\ndtd->buff_ptr0 = cpu_to_le32(temp);\r\ntemp &= ~0xFFF;\r\ndtd->buff_ptr1 = cpu_to_le32(temp + 0x1000);\r\ndtd->buff_ptr2 = cpu_to_le32(temp + 0x2000);\r\ndtd->buff_ptr3 = cpu_to_le32(temp + 0x3000);\r\ndtd->buff_ptr4 = cpu_to_le32(temp + 0x4000);\r\nreq->req.actual += *length;\r\nif (req->req.zero) {\r\nif (*length == 0 || (*length % req->ep->ep.maxpacket) != 0)\r\n*is_last = 1;\r\nelse\r\n*is_last = 0;\r\n} else if (req->req.length == req->req.actual)\r\n*is_last = 1;\r\nelse\r\n*is_last = 0;\r\ntemp = ((*length << DTD_LENGTH_BIT_POS) | DTD_STATUS_ACTIVE);\r\nif (*is_last && !req->req.no_interrupt)\r\ntemp |= DTD_IOC;\r\ntemp |= mult << 10;\r\ndtd->size_ioc_sts = temp;\r\nmb();\r\nreturn dtd;\r\n}\r\nstatic int req_to_dtd(struct mv_req *req)\r\n{\r\nunsigned count;\r\nint is_last, is_first = 1;\r\nstruct mv_dtd *dtd, *last_dtd = NULL;\r\nstruct mv_udc *udc;\r\ndma_addr_t dma;\r\nudc = req->ep->udc;\r\ndo {\r\ndtd = build_dtd(req, &count, &dma, &is_last);\r\nif (dtd == NULL)\r\nreturn -ENOMEM;\r\nif (is_first) {\r\nis_first = 0;\r\nreq->head = dtd;\r\n} else {\r\nlast_dtd->dtd_next = dma;\r\nlast_dtd->next_dtd_virt = dtd;\r\n}\r\nlast_dtd = dtd;\r\nreq->dtd_count++;\r\n} while (!is_last);\r\ndtd->dtd_next = DTD_NEXT_TERMINATE;\r\nreq->tail = dtd;\r\nreturn 0;\r\n}\r\nstatic int mv_ep_enable(struct usb_ep *_ep,\r\nconst struct usb_endpoint_descriptor *desc)\r\n{\r\nstruct mv_udc *udc;\r\nstruct mv_ep *ep;\r\nstruct mv_dqh *dqh;\r\nu16 max = 0;\r\nu32 bit_pos, epctrlx, direction;\r\nunsigned char zlt = 0, ios = 0, mult = 0;\r\nunsigned long flags;\r\nep = container_of(_ep, struct mv_ep, ep);\r\nudc = ep->udc;\r\nif (!_ep || !desc\r\n|| desc->bDescriptorType != USB_DT_ENDPOINT)\r\nreturn -EINVAL;\r\nif (!udc->driver || udc->gadget.speed == USB_SPEED_UNKNOWN)\r\nreturn -ESHUTDOWN;\r\ndirection = ep_dir(ep);\r\nmax = usb_endpoint_maxp(desc);\r\nzlt = 1;\r\nbit_pos = 1 << ((direction == EP_DIR_OUT ? 0 : 16) + ep->ep_num);\r\nif ((readl(&udc->op_regs->epprime) & bit_pos)\r\n|| (readl(&udc->op_regs->epstatus) & bit_pos)) {\r\ndev_info(&udc->dev->dev,\r\n"ep=%d %s: Init ERROR: ENDPTPRIME=0x%x,"\r\n" ENDPTSTATUS=0x%x, bit_pos=0x%x\n",\r\n(unsigned)ep->ep_num, direction ? "SEND" : "RECV",\r\n(unsigned)readl(&udc->op_regs->epprime),\r\n(unsigned)readl(&udc->op_regs->epstatus),\r\n(unsigned)bit_pos);\r\ngoto en_done;\r\n}\r\nswitch (desc->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK) {\r\ncase USB_ENDPOINT_XFER_BULK:\r\nzlt = 1;\r\nmult = 0;\r\nbreak;\r\ncase USB_ENDPOINT_XFER_CONTROL:\r\nios = 1;\r\ncase USB_ENDPOINT_XFER_INT:\r\nmult = 0;\r\nbreak;\r\ncase USB_ENDPOINT_XFER_ISOC:\r\nmult = (unsigned char)(1 + ((max >> 11) & 0x03));\r\nmax = max & 0x7ff;\r\nif (mult > 3)\r\ngoto en_done;\r\nbreak;\r\ndefault:\r\ngoto en_done;\r\n}\r\nspin_lock_irqsave(&udc->lock, flags);\r\ndqh = ep->dqh;\r\ndqh->max_packet_length = (max << EP_QUEUE_HEAD_MAX_PKT_LEN_POS)\r\n| (mult << EP_QUEUE_HEAD_MULT_POS)\r\n| (zlt ? EP_QUEUE_HEAD_ZLT_SEL : 0)\r\n| (ios ? EP_QUEUE_HEAD_IOS : 0);\r\ndqh->next_dtd_ptr = 1;\r\ndqh->size_ioc_int_sts = 0;\r\nep->ep.maxpacket = max;\r\nep->ep.desc = desc;\r\nep->stopped = 0;\r\nepctrlx = readl(&udc->op_regs->epctrlx[ep->ep_num]);\r\nif (direction == EP_DIR_IN) {\r\nepctrlx &= ~EPCTRL_TX_ALL_MASK;\r\nepctrlx |= EPCTRL_TX_ENABLE | EPCTRL_TX_DATA_TOGGLE_RST\r\n| ((desc->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK)\r\n<< EPCTRL_TX_EP_TYPE_SHIFT);\r\n} else {\r\nepctrlx &= ~EPCTRL_RX_ALL_MASK;\r\nepctrlx |= EPCTRL_RX_ENABLE | EPCTRL_RX_DATA_TOGGLE_RST\r\n| ((desc->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK)\r\n<< EPCTRL_RX_EP_TYPE_SHIFT);\r\n}\r\nwritel(epctrlx, &udc->op_regs->epctrlx[ep->ep_num]);\r\nepctrlx = readl(&udc->op_regs->epctrlx[ep->ep_num]);\r\nif ((epctrlx & EPCTRL_RX_ENABLE) == 0) {\r\nepctrlx |= (USB_ENDPOINT_XFER_BULK\r\n<< EPCTRL_RX_EP_TYPE_SHIFT);\r\nwritel(epctrlx, &udc->op_regs->epctrlx[ep->ep_num]);\r\n}\r\nepctrlx = readl(&udc->op_regs->epctrlx[ep->ep_num]);\r\nif ((epctrlx & EPCTRL_TX_ENABLE) == 0) {\r\nepctrlx |= (USB_ENDPOINT_XFER_BULK\r\n<< EPCTRL_TX_EP_TYPE_SHIFT);\r\nwritel(epctrlx, &udc->op_regs->epctrlx[ep->ep_num]);\r\n}\r\nspin_unlock_irqrestore(&udc->lock, flags);\r\nreturn 0;\r\nen_done:\r\nreturn -EINVAL;\r\n}\r\nstatic int mv_ep_disable(struct usb_ep *_ep)\r\n{\r\nstruct mv_udc *udc;\r\nstruct mv_ep *ep;\r\nstruct mv_dqh *dqh;\r\nu32 bit_pos, epctrlx, direction;\r\nunsigned long flags;\r\nep = container_of(_ep, struct mv_ep, ep);\r\nif ((_ep == NULL) || !ep->ep.desc)\r\nreturn -EINVAL;\r\nudc = ep->udc;\r\ndqh = ep->dqh;\r\nspin_lock_irqsave(&udc->lock, flags);\r\ndirection = ep_dir(ep);\r\nbit_pos = 1 << ((direction == EP_DIR_OUT ? 0 : 16) + ep->ep_num);\r\ndqh->max_packet_length = 0;\r\nepctrlx = readl(&udc->op_regs->epctrlx[ep->ep_num]);\r\nepctrlx &= ~((direction == EP_DIR_IN)\r\n? (EPCTRL_TX_ENABLE | EPCTRL_TX_TYPE)\r\n: (EPCTRL_RX_ENABLE | EPCTRL_RX_TYPE));\r\nwritel(epctrlx, &udc->op_regs->epctrlx[ep->ep_num]);\r\nnuke(ep, -ESHUTDOWN);\r\nep->ep.desc = NULL;\r\nep->stopped = 1;\r\nspin_unlock_irqrestore(&udc->lock, flags);\r\nreturn 0;\r\n}\r\nstatic struct usb_request *\r\nmv_alloc_request(struct usb_ep *_ep, gfp_t gfp_flags)\r\n{\r\nstruct mv_req *req = NULL;\r\nreq = kzalloc(sizeof *req, gfp_flags);\r\nif (!req)\r\nreturn NULL;\r\nreq->req.dma = DMA_ADDR_INVALID;\r\nINIT_LIST_HEAD(&req->queue);\r\nreturn &req->req;\r\n}\r\nstatic void mv_free_request(struct usb_ep *_ep, struct usb_request *_req)\r\n{\r\nstruct mv_req *req = NULL;\r\nreq = container_of(_req, struct mv_req, req);\r\nif (_req)\r\nkfree(req);\r\n}\r\nstatic void mv_ep_fifo_flush(struct usb_ep *_ep)\r\n{\r\nstruct mv_udc *udc;\r\nu32 bit_pos, direction;\r\nstruct mv_ep *ep;\r\nunsigned int loops;\r\nif (!_ep)\r\nreturn;\r\nep = container_of(_ep, struct mv_ep, ep);\r\nif (!ep->ep.desc)\r\nreturn;\r\nudc = ep->udc;\r\ndirection = ep_dir(ep);\r\nif (ep->ep_num == 0)\r\nbit_pos = (1 << 16) | 1;\r\nelse if (direction == EP_DIR_OUT)\r\nbit_pos = 1 << ep->ep_num;\r\nelse\r\nbit_pos = 1 << (16 + ep->ep_num);\r\nloops = LOOPS(EPSTATUS_TIMEOUT);\r\ndo {\r\nunsigned int inter_loops;\r\nif (loops == 0) {\r\ndev_err(&udc->dev->dev,\r\n"TIMEOUT for ENDPTSTATUS=0x%x, bit_pos=0x%x\n",\r\n(unsigned)readl(&udc->op_regs->epstatus),\r\n(unsigned)bit_pos);\r\nreturn;\r\n}\r\nwritel(bit_pos, &udc->op_regs->epflush);\r\ninter_loops = LOOPS(FLUSH_TIMEOUT);\r\nwhile (readl(&udc->op_regs->epflush)) {\r\nif (inter_loops == 0) {\r\ndev_err(&udc->dev->dev,\r\n"TIMEOUT for ENDPTFLUSH=0x%x,"\r\n"bit_pos=0x%x\n",\r\n(unsigned)readl(&udc->op_regs->epflush),\r\n(unsigned)bit_pos);\r\nreturn;\r\n}\r\ninter_loops--;\r\nudelay(LOOPS_USEC);\r\n}\r\nloops--;\r\n} while (readl(&udc->op_regs->epstatus) & bit_pos);\r\n}\r\nstatic int\r\nmv_ep_queue(struct usb_ep *_ep, struct usb_request *_req, gfp_t gfp_flags)\r\n{\r\nstruct mv_ep *ep = container_of(_ep, struct mv_ep, ep);\r\nstruct mv_req *req = container_of(_req, struct mv_req, req);\r\nstruct mv_udc *udc = ep->udc;\r\nunsigned long flags;\r\nint retval;\r\nif (!_req || !req->req.complete || !req->req.buf\r\n|| !list_empty(&req->queue)) {\r\ndev_err(&udc->dev->dev, "%s, bad params", __func__);\r\nreturn -EINVAL;\r\n}\r\nif (unlikely(!_ep || !ep->ep.desc)) {\r\ndev_err(&udc->dev->dev, "%s, bad ep", __func__);\r\nreturn -EINVAL;\r\n}\r\nudc = ep->udc;\r\nif (!udc->driver || udc->gadget.speed == USB_SPEED_UNKNOWN)\r\nreturn -ESHUTDOWN;\r\nreq->ep = ep;\r\nretval = usb_gadget_map_request(&udc->gadget, _req, ep_dir(ep));\r\nif (retval)\r\nreturn retval;\r\nreq->req.status = -EINPROGRESS;\r\nreq->req.actual = 0;\r\nreq->dtd_count = 0;\r\nspin_lock_irqsave(&udc->lock, flags);\r\nif (!req_to_dtd(req)) {\r\nretval = queue_dtd(ep, req);\r\nif (retval) {\r\nspin_unlock_irqrestore(&udc->lock, flags);\r\ndev_err(&udc->dev->dev, "Failed to queue dtd\n");\r\ngoto err_unmap_dma;\r\n}\r\n} else {\r\nspin_unlock_irqrestore(&udc->lock, flags);\r\ndev_err(&udc->dev->dev, "Failed to dma_pool_alloc\n");\r\nretval = -ENOMEM;\r\ngoto err_unmap_dma;\r\n}\r\nif (ep->ep_num == 0)\r\nudc->ep0_state = DATA_STATE_XMIT;\r\nlist_add_tail(&req->queue, &ep->queue);\r\nspin_unlock_irqrestore(&udc->lock, flags);\r\nreturn 0;\r\nerr_unmap_dma:\r\nusb_gadget_unmap_request(&udc->gadget, _req, ep_dir(ep));\r\nreturn retval;\r\n}\r\nstatic void mv_prime_ep(struct mv_ep *ep, struct mv_req *req)\r\n{\r\nstruct mv_dqh *dqh = ep->dqh;\r\nu32 bit_pos;\r\ndqh->next_dtd_ptr = req->head->td_dma\r\n& EP_QUEUE_HEAD_NEXT_POINTER_MASK;\r\ndqh->size_ioc_int_sts &= ~(DTD_STATUS_ACTIVE | DTD_STATUS_HALTED);\r\nwmb();\r\nbit_pos = 1 << (((ep_dir(ep) == EP_DIR_OUT) ? 0 : 16) + ep->ep_num);\r\nwritel(bit_pos, &ep->udc->op_regs->epprime);\r\n}\r\nstatic int mv_ep_dequeue(struct usb_ep *_ep, struct usb_request *_req)\r\n{\r\nstruct mv_ep *ep = container_of(_ep, struct mv_ep, ep);\r\nstruct mv_req *req;\r\nstruct mv_udc *udc = ep->udc;\r\nunsigned long flags;\r\nint stopped, ret = 0;\r\nu32 epctrlx;\r\nif (!_ep || !_req)\r\nreturn -EINVAL;\r\nspin_lock_irqsave(&ep->udc->lock, flags);\r\nstopped = ep->stopped;\r\nep->stopped = 1;\r\nepctrlx = readl(&udc->op_regs->epctrlx[ep->ep_num]);\r\nif (ep_dir(ep) == EP_DIR_IN)\r\nepctrlx &= ~EPCTRL_TX_ENABLE;\r\nelse\r\nepctrlx &= ~EPCTRL_RX_ENABLE;\r\nwritel(epctrlx, &udc->op_regs->epctrlx[ep->ep_num]);\r\nlist_for_each_entry(req, &ep->queue, queue) {\r\nif (&req->req == _req)\r\nbreak;\r\n}\r\nif (&req->req != _req) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nif (ep->queue.next == &req->queue) {\r\n_req->status = -ECONNRESET;\r\nmv_ep_fifo_flush(_ep);\r\nif (req->queue.next != &ep->queue) {\r\nstruct mv_req *next_req;\r\nnext_req = list_entry(req->queue.next,\r\nstruct mv_req, queue);\r\nmv_prime_ep(ep, next_req);\r\n} else {\r\nstruct mv_dqh *qh;\r\nqh = ep->dqh;\r\nqh->next_dtd_ptr = 1;\r\nqh->size_ioc_int_sts = 0;\r\n}\r\n} else {\r\nstruct mv_req *prev_req;\r\nprev_req = list_entry(req->queue.prev, struct mv_req, queue);\r\nwritel(readl(&req->tail->dtd_next),\r\n&prev_req->tail->dtd_next);\r\n}\r\ndone(ep, req, -ECONNRESET);\r\nout:\r\nepctrlx = readl(&udc->op_regs->epctrlx[ep->ep_num]);\r\nif (ep_dir(ep) == EP_DIR_IN)\r\nepctrlx |= EPCTRL_TX_ENABLE;\r\nelse\r\nepctrlx |= EPCTRL_RX_ENABLE;\r\nwritel(epctrlx, &udc->op_regs->epctrlx[ep->ep_num]);\r\nep->stopped = stopped;\r\nspin_unlock_irqrestore(&ep->udc->lock, flags);\r\nreturn ret;\r\n}\r\nstatic void ep_set_stall(struct mv_udc *udc, u8 ep_num, u8 direction, int stall)\r\n{\r\nu32 epctrlx;\r\nepctrlx = readl(&udc->op_regs->epctrlx[ep_num]);\r\nif (stall) {\r\nif (direction == EP_DIR_IN)\r\nepctrlx |= EPCTRL_TX_EP_STALL;\r\nelse\r\nepctrlx |= EPCTRL_RX_EP_STALL;\r\n} else {\r\nif (direction == EP_DIR_IN) {\r\nepctrlx &= ~EPCTRL_TX_EP_STALL;\r\nepctrlx |= EPCTRL_TX_DATA_TOGGLE_RST;\r\n} else {\r\nepctrlx &= ~EPCTRL_RX_EP_STALL;\r\nepctrlx |= EPCTRL_RX_DATA_TOGGLE_RST;\r\n}\r\n}\r\nwritel(epctrlx, &udc->op_regs->epctrlx[ep_num]);\r\n}\r\nstatic int ep_is_stall(struct mv_udc *udc, u8 ep_num, u8 direction)\r\n{\r\nu32 epctrlx;\r\nepctrlx = readl(&udc->op_regs->epctrlx[ep_num]);\r\nif (direction == EP_DIR_OUT)\r\nreturn (epctrlx & EPCTRL_RX_EP_STALL) ? 1 : 0;\r\nelse\r\nreturn (epctrlx & EPCTRL_TX_EP_STALL) ? 1 : 0;\r\n}\r\nstatic int mv_ep_set_halt_wedge(struct usb_ep *_ep, int halt, int wedge)\r\n{\r\nstruct mv_ep *ep;\r\nunsigned long flags = 0;\r\nint status = 0;\r\nstruct mv_udc *udc;\r\nep = container_of(_ep, struct mv_ep, ep);\r\nudc = ep->udc;\r\nif (!_ep || !ep->ep.desc) {\r\nstatus = -EINVAL;\r\ngoto out;\r\n}\r\nif (ep->ep.desc->bmAttributes == USB_ENDPOINT_XFER_ISOC) {\r\nstatus = -EOPNOTSUPP;\r\ngoto out;\r\n}\r\nif (halt && (ep_dir(ep) == EP_DIR_IN) && !list_empty(&ep->queue)) {\r\nstatus = -EAGAIN;\r\ngoto out;\r\n}\r\nspin_lock_irqsave(&ep->udc->lock, flags);\r\nep_set_stall(udc, ep->ep_num, ep_dir(ep), halt);\r\nif (halt && wedge)\r\nep->wedge = 1;\r\nelse if (!halt)\r\nep->wedge = 0;\r\nspin_unlock_irqrestore(&ep->udc->lock, flags);\r\nif (ep->ep_num == 0) {\r\nudc->ep0_state = WAIT_FOR_SETUP;\r\nudc->ep0_dir = EP_DIR_OUT;\r\n}\r\nout:\r\nreturn status;\r\n}\r\nstatic int mv_ep_set_halt(struct usb_ep *_ep, int halt)\r\n{\r\nreturn mv_ep_set_halt_wedge(_ep, halt, 0);\r\n}\r\nstatic int mv_ep_set_wedge(struct usb_ep *_ep)\r\n{\r\nreturn mv_ep_set_halt_wedge(_ep, 1, 1);\r\n}\r\nstatic void udc_clock_enable(struct mv_udc *udc)\r\n{\r\nclk_prepare_enable(udc->clk);\r\n}\r\nstatic void udc_clock_disable(struct mv_udc *udc)\r\n{\r\nclk_disable_unprepare(udc->clk);\r\n}\r\nstatic void udc_stop(struct mv_udc *udc)\r\n{\r\nu32 tmp;\r\ntmp = readl(&udc->op_regs->usbintr);\r\ntmp &= ~(USBINTR_INT_EN | USBINTR_ERR_INT_EN |\r\nUSBINTR_PORT_CHANGE_DETECT_EN | USBINTR_RESET_EN);\r\nwritel(tmp, &udc->op_regs->usbintr);\r\nudc->stopped = 1;\r\ntmp = readl(&udc->op_regs->usbcmd);\r\ntmp &= ~USBCMD_RUN_STOP;\r\nwritel(tmp, &udc->op_regs->usbcmd);\r\n}\r\nstatic void udc_start(struct mv_udc *udc)\r\n{\r\nu32 usbintr;\r\nusbintr = USBINTR_INT_EN | USBINTR_ERR_INT_EN\r\n| USBINTR_PORT_CHANGE_DETECT_EN\r\n| USBINTR_RESET_EN | USBINTR_DEVICE_SUSPEND;\r\nwritel(usbintr, &udc->op_regs->usbintr);\r\nudc->stopped = 0;\r\nwritel(USBCMD_RUN_STOP, &udc->op_regs->usbcmd);\r\n}\r\nstatic int udc_reset(struct mv_udc *udc)\r\n{\r\nunsigned int loops;\r\nu32 tmp, portsc;\r\ntmp = readl(&udc->op_regs->usbcmd);\r\ntmp &= ~USBCMD_RUN_STOP;\r\nwritel(tmp, &udc->op_regs->usbcmd);\r\nwritel(USBCMD_CTRL_RESET, &udc->op_regs->usbcmd);\r\nloops = LOOPS(RESET_TIMEOUT);\r\nwhile (readl(&udc->op_regs->usbcmd) & USBCMD_CTRL_RESET) {\r\nif (loops == 0) {\r\ndev_err(&udc->dev->dev,\r\n"Wait for RESET completed TIMEOUT\n");\r\nreturn -ETIMEDOUT;\r\n}\r\nloops--;\r\nudelay(LOOPS_USEC);\r\n}\r\ntmp = readl(&udc->op_regs->usbmode);\r\ntmp |= USBMODE_CTRL_MODE_DEVICE;\r\ntmp |= USBMODE_SETUP_LOCK_OFF;\r\nwritel(tmp, &udc->op_regs->usbmode);\r\nwritel(0x0, &udc->op_regs->epsetupstat);\r\nwritel(udc->ep_dqh_dma & USB_EP_LIST_ADDRESS_MASK,\r\n&udc->op_regs->eplistaddr);\r\nportsc = readl(&udc->op_regs->portsc[0]);\r\nif (readl(&udc->cap_regs->hcsparams) & HCSPARAMS_PPC)\r\nportsc &= (~PORTSCX_W1C_BITS | ~PORTSCX_PORT_POWER);\r\nif (udc->force_fs)\r\nportsc |= PORTSCX_FORCE_FULL_SPEED_CONNECT;\r\nelse\r\nportsc &= (~PORTSCX_FORCE_FULL_SPEED_CONNECT);\r\nwritel(portsc, &udc->op_regs->portsc[0]);\r\ntmp = readl(&udc->op_regs->epctrlx[0]);\r\ntmp &= ~(EPCTRL_TX_EP_STALL | EPCTRL_RX_EP_STALL);\r\nwritel(tmp, &udc->op_regs->epctrlx[0]);\r\nreturn 0;\r\n}\r\nstatic int mv_udc_enable_internal(struct mv_udc *udc)\r\n{\r\nint retval;\r\nif (udc->active)\r\nreturn 0;\r\ndev_dbg(&udc->dev->dev, "enable udc\n");\r\nudc_clock_enable(udc);\r\nif (udc->pdata->phy_init) {\r\nretval = udc->pdata->phy_init(udc->phy_regs);\r\nif (retval) {\r\ndev_err(&udc->dev->dev,\r\n"init phy error %d\n", retval);\r\nudc_clock_disable(udc);\r\nreturn retval;\r\n}\r\n}\r\nudc->active = 1;\r\nreturn 0;\r\n}\r\nstatic int mv_udc_enable(struct mv_udc *udc)\r\n{\r\nif (udc->clock_gating)\r\nreturn mv_udc_enable_internal(udc);\r\nreturn 0;\r\n}\r\nstatic void mv_udc_disable_internal(struct mv_udc *udc)\r\n{\r\nif (udc->active) {\r\ndev_dbg(&udc->dev->dev, "disable udc\n");\r\nif (udc->pdata->phy_deinit)\r\nudc->pdata->phy_deinit(udc->phy_regs);\r\nudc_clock_disable(udc);\r\nudc->active = 0;\r\n}\r\n}\r\nstatic void mv_udc_disable(struct mv_udc *udc)\r\n{\r\nif (udc->clock_gating)\r\nmv_udc_disable_internal(udc);\r\n}\r\nstatic int mv_udc_get_frame(struct usb_gadget *gadget)\r\n{\r\nstruct mv_udc *udc;\r\nu16 retval;\r\nif (!gadget)\r\nreturn -ENODEV;\r\nudc = container_of(gadget, struct mv_udc, gadget);\r\nretval = readl(&udc->op_regs->frindex) & USB_FRINDEX_MASKS;\r\nreturn retval;\r\n}\r\nstatic int mv_udc_wakeup(struct usb_gadget *gadget)\r\n{\r\nstruct mv_udc *udc = container_of(gadget, struct mv_udc, gadget);\r\nu32 portsc;\r\nif (!udc->remote_wakeup)\r\nreturn -ENOTSUPP;\r\nportsc = readl(&udc->op_regs->portsc);\r\nif (!(portsc & PORTSCX_PORT_SUSPEND))\r\nreturn 0;\r\nportsc |= PORTSCX_PORT_FORCE_RESUME;\r\nwritel(portsc, &udc->op_regs->portsc[0]);\r\nreturn 0;\r\n}\r\nstatic int mv_udc_vbus_session(struct usb_gadget *gadget, int is_active)\r\n{\r\nstruct mv_udc *udc;\r\nunsigned long flags;\r\nint retval = 0;\r\nudc = container_of(gadget, struct mv_udc, gadget);\r\nspin_lock_irqsave(&udc->lock, flags);\r\nudc->vbus_active = (is_active != 0);\r\ndev_dbg(&udc->dev->dev, "%s: softconnect %d, vbus_active %d\n",\r\n__func__, udc->softconnect, udc->vbus_active);\r\nif (udc->driver && udc->softconnect && udc->vbus_active) {\r\nretval = mv_udc_enable(udc);\r\nif (retval == 0) {\r\nudc_reset(udc);\r\nep0_reset(udc);\r\nudc_start(udc);\r\n}\r\n} else if (udc->driver && udc->softconnect) {\r\nif (!udc->active)\r\ngoto out;\r\nstop_activity(udc, udc->driver);\r\nudc_stop(udc);\r\nmv_udc_disable(udc);\r\n}\r\nout:\r\nspin_unlock_irqrestore(&udc->lock, flags);\r\nreturn retval;\r\n}\r\nstatic int mv_udc_pullup(struct usb_gadget *gadget, int is_on)\r\n{\r\nstruct mv_udc *udc;\r\nunsigned long flags;\r\nint retval = 0;\r\nudc = container_of(gadget, struct mv_udc, gadget);\r\nspin_lock_irqsave(&udc->lock, flags);\r\nudc->softconnect = (is_on != 0);\r\ndev_dbg(&udc->dev->dev, "%s: softconnect %d, vbus_active %d\n",\r\n__func__, udc->softconnect, udc->vbus_active);\r\nif (udc->driver && udc->softconnect && udc->vbus_active) {\r\nretval = mv_udc_enable(udc);\r\nif (retval == 0) {\r\nudc_reset(udc);\r\nep0_reset(udc);\r\nudc_start(udc);\r\n}\r\n} else if (udc->driver && udc->vbus_active) {\r\nstop_activity(udc, udc->driver);\r\nudc_stop(udc);\r\nmv_udc_disable(udc);\r\n}\r\nspin_unlock_irqrestore(&udc->lock, flags);\r\nreturn retval;\r\n}\r\nstatic int eps_init(struct mv_udc *udc)\r\n{\r\nstruct mv_ep *ep;\r\nchar name[14];\r\nint i;\r\nep = &udc->eps[0];\r\nep->udc = udc;\r\nstrncpy(ep->name, "ep0", sizeof(ep->name));\r\nep->ep.name = ep->name;\r\nep->ep.ops = &mv_ep_ops;\r\nep->wedge = 0;\r\nep->stopped = 0;\r\nusb_ep_set_maxpacket_limit(&ep->ep, EP0_MAX_PKT_SIZE);\r\nep->ep_num = 0;\r\nep->ep.desc = &mv_ep0_desc;\r\nINIT_LIST_HEAD(&ep->queue);\r\nep->ep_type = USB_ENDPOINT_XFER_CONTROL;\r\nfor (i = 2; i < udc->max_eps * 2; i++) {\r\nep = &udc->eps[i];\r\nif (i % 2) {\r\nsnprintf(name, sizeof(name), "ep%din", i / 2);\r\nep->direction = EP_DIR_IN;\r\n} else {\r\nsnprintf(name, sizeof(name), "ep%dout", i / 2);\r\nep->direction = EP_DIR_OUT;\r\n}\r\nep->udc = udc;\r\nstrncpy(ep->name, name, sizeof(ep->name));\r\nep->ep.name = ep->name;\r\nep->ep.ops = &mv_ep_ops;\r\nep->stopped = 0;\r\nusb_ep_set_maxpacket_limit(&ep->ep, (unsigned short) ~0);\r\nep->ep_num = i / 2;\r\nINIT_LIST_HEAD(&ep->queue);\r\nlist_add_tail(&ep->ep.ep_list, &udc->gadget.ep_list);\r\nep->dqh = &udc->ep_dqh[i];\r\n}\r\nreturn 0;\r\n}\r\nstatic void nuke(struct mv_ep *ep, int status)\r\n{\r\nep->stopped = 1;\r\nmv_ep_fifo_flush(&ep->ep);\r\nwhile (!list_empty(&ep->queue)) {\r\nstruct mv_req *req = NULL;\r\nreq = list_entry(ep->queue.next, struct mv_req, queue);\r\ndone(ep, req, status);\r\n}\r\n}\r\nstatic void gadget_reset(struct mv_udc *udc, struct usb_gadget_driver *driver)\r\n{\r\nstruct mv_ep *ep;\r\nnuke(&udc->eps[0], -ESHUTDOWN);\r\nlist_for_each_entry(ep, &udc->gadget.ep_list, ep.ep_list) {\r\nnuke(ep, -ESHUTDOWN);\r\n}\r\nif (driver) {\r\nspin_unlock(&udc->lock);\r\nusb_gadget_udc_reset(&udc->gadget, driver);\r\nspin_lock(&udc->lock);\r\n}\r\n}\r\nstatic void stop_activity(struct mv_udc *udc, struct usb_gadget_driver *driver)\r\n{\r\nstruct mv_ep *ep;\r\nnuke(&udc->eps[0], -ESHUTDOWN);\r\nlist_for_each_entry(ep, &udc->gadget.ep_list, ep.ep_list) {\r\nnuke(ep, -ESHUTDOWN);\r\n}\r\nif (driver) {\r\nspin_unlock(&udc->lock);\r\ndriver->disconnect(&udc->gadget);\r\nspin_lock(&udc->lock);\r\n}\r\n}\r\nstatic int mv_udc_start(struct usb_gadget *gadget,\r\nstruct usb_gadget_driver *driver)\r\n{\r\nstruct mv_udc *udc;\r\nint retval = 0;\r\nunsigned long flags;\r\nudc = container_of(gadget, struct mv_udc, gadget);\r\nif (udc->driver)\r\nreturn -EBUSY;\r\nspin_lock_irqsave(&udc->lock, flags);\r\ndriver->driver.bus = NULL;\r\nudc->driver = driver;\r\nudc->usb_state = USB_STATE_ATTACHED;\r\nudc->ep0_state = WAIT_FOR_SETUP;\r\nudc->ep0_dir = EP_DIR_OUT;\r\nspin_unlock_irqrestore(&udc->lock, flags);\r\nif (udc->transceiver) {\r\nretval = otg_set_peripheral(udc->transceiver->otg,\r\n&udc->gadget);\r\nif (retval) {\r\ndev_err(&udc->dev->dev,\r\n"unable to register peripheral to otg\n");\r\nudc->driver = NULL;\r\nreturn retval;\r\n}\r\n}\r\nif (udc->qwork)\r\nqueue_work(udc->qwork, &udc->vbus_work);\r\nreturn 0;\r\n}\r\nstatic int mv_udc_stop(struct usb_gadget *gadget)\r\n{\r\nstruct mv_udc *udc;\r\nunsigned long flags;\r\nudc = container_of(gadget, struct mv_udc, gadget);\r\nspin_lock_irqsave(&udc->lock, flags);\r\nmv_udc_enable(udc);\r\nudc_stop(udc);\r\nudc->gadget.speed = USB_SPEED_UNKNOWN;\r\nstop_activity(udc, NULL);\r\nmv_udc_disable(udc);\r\nspin_unlock_irqrestore(&udc->lock, flags);\r\nudc->driver = NULL;\r\nreturn 0;\r\n}\r\nstatic void mv_set_ptc(struct mv_udc *udc, u32 mode)\r\n{\r\nu32 portsc;\r\nportsc = readl(&udc->op_regs->portsc[0]);\r\nportsc |= mode << 16;\r\nwritel(portsc, &udc->op_regs->portsc[0]);\r\n}\r\nstatic void prime_status_complete(struct usb_ep *ep, struct usb_request *_req)\r\n{\r\nstruct mv_ep *mvep = container_of(ep, struct mv_ep, ep);\r\nstruct mv_req *req = container_of(_req, struct mv_req, req);\r\nstruct mv_udc *udc;\r\nunsigned long flags;\r\nudc = mvep->udc;\r\ndev_info(&udc->dev->dev, "switch to test mode %d\n", req->test_mode);\r\nspin_lock_irqsave(&udc->lock, flags);\r\nif (req->test_mode) {\r\nmv_set_ptc(udc, req->test_mode);\r\nreq->test_mode = 0;\r\n}\r\nspin_unlock_irqrestore(&udc->lock, flags);\r\n}\r\nstatic int\r\nudc_prime_status(struct mv_udc *udc, u8 direction, u16 status, bool empty)\r\n{\r\nint retval = 0;\r\nstruct mv_req *req;\r\nstruct mv_ep *ep;\r\nep = &udc->eps[0];\r\nudc->ep0_dir = direction;\r\nudc->ep0_state = WAIT_FOR_OUT_STATUS;\r\nreq = udc->status_req;\r\nif (empty == false) {\r\n*((u16 *) req->req.buf) = cpu_to_le16(status);\r\nreq->req.length = 2;\r\n} else\r\nreq->req.length = 0;\r\nreq->ep = ep;\r\nreq->req.status = -EINPROGRESS;\r\nreq->req.actual = 0;\r\nif (udc->test_mode) {\r\nreq->req.complete = prime_status_complete;\r\nreq->test_mode = udc->test_mode;\r\nudc->test_mode = 0;\r\n} else\r\nreq->req.complete = NULL;\r\nreq->dtd_count = 0;\r\nif (req->req.dma == DMA_ADDR_INVALID) {\r\nreq->req.dma = dma_map_single(ep->udc->gadget.dev.parent,\r\nreq->req.buf, req->req.length,\r\nep_dir(ep) ? DMA_TO_DEVICE : DMA_FROM_DEVICE);\r\nreq->mapped = 1;\r\n}\r\nif (!req_to_dtd(req)) {\r\nretval = queue_dtd(ep, req);\r\nif (retval) {\r\ndev_err(&udc->dev->dev,\r\n"Failed to queue dtd when prime status\n");\r\ngoto out;\r\n}\r\n} else{\r\nretval = -ENOMEM;\r\ndev_err(&udc->dev->dev,\r\n"Failed to dma_pool_alloc when prime status\n");\r\ngoto out;\r\n}\r\nlist_add_tail(&req->queue, &ep->queue);\r\nreturn 0;\r\nout:\r\nusb_gadget_unmap_request(&udc->gadget, &req->req, ep_dir(ep));\r\nreturn retval;\r\n}\r\nstatic void mv_udc_testmode(struct mv_udc *udc, u16 index)\r\n{\r\nif (index <= TEST_FORCE_EN) {\r\nudc->test_mode = index;\r\nif (udc_prime_status(udc, EP_DIR_IN, 0, true))\r\nep0_stall(udc);\r\n} else\r\ndev_err(&udc->dev->dev,\r\n"This test mode(%d) is not supported\n", index);\r\n}\r\nstatic void ch9setaddress(struct mv_udc *udc, struct usb_ctrlrequest *setup)\r\n{\r\nudc->dev_addr = (u8)setup->wValue;\r\nudc->usb_state = USB_STATE_ADDRESS;\r\nif (udc_prime_status(udc, EP_DIR_IN, 0, true))\r\nep0_stall(udc);\r\n}\r\nstatic void ch9getstatus(struct mv_udc *udc, u8 ep_num,\r\nstruct usb_ctrlrequest *setup)\r\n{\r\nu16 status = 0;\r\nint retval;\r\nif ((setup->bRequestType & (USB_DIR_IN | USB_TYPE_MASK))\r\n!= (USB_DIR_IN | USB_TYPE_STANDARD))\r\nreturn;\r\nif ((setup->bRequestType & USB_RECIP_MASK) == USB_RECIP_DEVICE) {\r\nstatus = 1 << USB_DEVICE_SELF_POWERED;\r\nstatus |= udc->remote_wakeup << USB_DEVICE_REMOTE_WAKEUP;\r\n} else if ((setup->bRequestType & USB_RECIP_MASK)\r\n== USB_RECIP_INTERFACE) {\r\nstatus = 0;\r\n} else if ((setup->bRequestType & USB_RECIP_MASK)\r\n== USB_RECIP_ENDPOINT) {\r\nu8 ep_num, direction;\r\nep_num = setup->wIndex & USB_ENDPOINT_NUMBER_MASK;\r\ndirection = (setup->wIndex & USB_ENDPOINT_DIR_MASK)\r\n? EP_DIR_IN : EP_DIR_OUT;\r\nstatus = ep_is_stall(udc, ep_num, direction)\r\n<< USB_ENDPOINT_HALT;\r\n}\r\nretval = udc_prime_status(udc, EP_DIR_IN, status, false);\r\nif (retval)\r\nep0_stall(udc);\r\nelse\r\nudc->ep0_state = DATA_STATE_XMIT;\r\n}\r\nstatic void ch9clearfeature(struct mv_udc *udc, struct usb_ctrlrequest *setup)\r\n{\r\nu8 ep_num;\r\nu8 direction;\r\nstruct mv_ep *ep;\r\nif ((setup->bRequestType & (USB_TYPE_MASK | USB_RECIP_MASK))\r\n== ((USB_TYPE_STANDARD | USB_RECIP_DEVICE))) {\r\nswitch (setup->wValue) {\r\ncase USB_DEVICE_REMOTE_WAKEUP:\r\nudc->remote_wakeup = 0;\r\nbreak;\r\ndefault:\r\ngoto out;\r\n}\r\n} else if ((setup->bRequestType & (USB_TYPE_MASK | USB_RECIP_MASK))\r\n== ((USB_TYPE_STANDARD | USB_RECIP_ENDPOINT))) {\r\nswitch (setup->wValue) {\r\ncase USB_ENDPOINT_HALT:\r\nep_num = setup->wIndex & USB_ENDPOINT_NUMBER_MASK;\r\ndirection = (setup->wIndex & USB_ENDPOINT_DIR_MASK)\r\n? EP_DIR_IN : EP_DIR_OUT;\r\nif (setup->wValue != 0 || setup->wLength != 0\r\n|| ep_num > udc->max_eps)\r\ngoto out;\r\nep = &udc->eps[ep_num * 2 + direction];\r\nif (ep->wedge == 1)\r\nbreak;\r\nspin_unlock(&udc->lock);\r\nep_set_stall(udc, ep_num, direction, 0);\r\nspin_lock(&udc->lock);\r\nbreak;\r\ndefault:\r\ngoto out;\r\n}\r\n} else\r\ngoto out;\r\nif (udc_prime_status(udc, EP_DIR_IN, 0, true))\r\nep0_stall(udc);\r\nout:\r\nreturn;\r\n}\r\nstatic void ch9setfeature(struct mv_udc *udc, struct usb_ctrlrequest *setup)\r\n{\r\nu8 ep_num;\r\nu8 direction;\r\nif ((setup->bRequestType & (USB_TYPE_MASK | USB_RECIP_MASK))\r\n== ((USB_TYPE_STANDARD | USB_RECIP_DEVICE))) {\r\nswitch (setup->wValue) {\r\ncase USB_DEVICE_REMOTE_WAKEUP:\r\nudc->remote_wakeup = 1;\r\nbreak;\r\ncase USB_DEVICE_TEST_MODE:\r\nif (setup->wIndex & 0xFF\r\n|| udc->gadget.speed != USB_SPEED_HIGH)\r\nep0_stall(udc);\r\nif (udc->usb_state != USB_STATE_CONFIGURED\r\n&& udc->usb_state != USB_STATE_ADDRESS\r\n&& udc->usb_state != USB_STATE_DEFAULT)\r\nep0_stall(udc);\r\nmv_udc_testmode(udc, (setup->wIndex >> 8));\r\ngoto out;\r\ndefault:\r\ngoto out;\r\n}\r\n} else if ((setup->bRequestType & (USB_TYPE_MASK | USB_RECIP_MASK))\r\n== ((USB_TYPE_STANDARD | USB_RECIP_ENDPOINT))) {\r\nswitch (setup->wValue) {\r\ncase USB_ENDPOINT_HALT:\r\nep_num = setup->wIndex & USB_ENDPOINT_NUMBER_MASK;\r\ndirection = (setup->wIndex & USB_ENDPOINT_DIR_MASK)\r\n? EP_DIR_IN : EP_DIR_OUT;\r\nif (setup->wValue != 0 || setup->wLength != 0\r\n|| ep_num > udc->max_eps)\r\ngoto out;\r\nspin_unlock(&udc->lock);\r\nep_set_stall(udc, ep_num, direction, 1);\r\nspin_lock(&udc->lock);\r\nbreak;\r\ndefault:\r\ngoto out;\r\n}\r\n} else\r\ngoto out;\r\nif (udc_prime_status(udc, EP_DIR_IN, 0, true))\r\nep0_stall(udc);\r\nout:\r\nreturn;\r\n}\r\nstatic void handle_setup_packet(struct mv_udc *udc, u8 ep_num,\r\nstruct usb_ctrlrequest *setup)\r\n__releases(&ep->udc->lock\r\nstatic void ep0_req_complete(struct mv_udc *udc,\r\nstruct mv_ep *ep0, struct mv_req *req)\r\n{\r\nu32 new_addr;\r\nif (udc->usb_state == USB_STATE_ADDRESS) {\r\nnew_addr = (u32)udc->dev_addr;\r\nwritel(new_addr << USB_DEVICE_ADDRESS_BIT_SHIFT,\r\n&udc->op_regs->deviceaddr);\r\n}\r\ndone(ep0, req, 0);\r\nswitch (udc->ep0_state) {\r\ncase DATA_STATE_XMIT:\r\nif (udc_prime_status(udc, EP_DIR_OUT, 0, true))\r\nep0_stall(udc);\r\nbreak;\r\ncase DATA_STATE_RECV:\r\nif (udc_prime_status(udc, EP_DIR_IN, 0 , true))\r\nep0_stall(udc);\r\nbreak;\r\ncase WAIT_FOR_OUT_STATUS:\r\nudc->ep0_state = WAIT_FOR_SETUP;\r\nbreak;\r\ncase WAIT_FOR_SETUP:\r\ndev_err(&udc->dev->dev, "unexpect ep0 packets\n");\r\nbreak;\r\ndefault:\r\nep0_stall(udc);\r\nbreak;\r\n}\r\n}\r\nstatic void get_setup_data(struct mv_udc *udc, u8 ep_num, u8 *buffer_ptr)\r\n{\r\nu32 temp;\r\nstruct mv_dqh *dqh;\r\ndqh = &udc->ep_dqh[ep_num * 2 + EP_DIR_OUT];\r\nwritel((1 << ep_num), &udc->op_regs->epsetupstat);\r\ndo {\r\ntemp = readl(&udc->op_regs->usbcmd);\r\nwritel(temp | USBCMD_SETUP_TRIPWIRE_SET, &udc->op_regs->usbcmd);\r\nmemcpy(buffer_ptr, (u8 *) dqh->setup_buffer, 8);\r\n} while (!(readl(&udc->op_regs->usbcmd) & USBCMD_SETUP_TRIPWIRE_SET));\r\ntemp = readl(&udc->op_regs->usbcmd);\r\nwritel(temp & ~USBCMD_SETUP_TRIPWIRE_SET, &udc->op_regs->usbcmd);\r\n}\r\nstatic void irq_process_tr_complete(struct mv_udc *udc)\r\n{\r\nu32 tmp, bit_pos;\r\nint i, ep_num = 0, direction = 0;\r\nstruct mv_ep *curr_ep;\r\nstruct mv_req *curr_req, *temp_req;\r\nint status;\r\ntmp = readl(&udc->op_regs->epsetupstat);\r\nif (tmp) {\r\nfor (i = 0; i < udc->max_eps; i++) {\r\nif (tmp & (1 << i)) {\r\nget_setup_data(udc, i,\r\n(u8 *)(&udc->local_setup_buff));\r\nhandle_setup_packet(udc, i,\r\n&udc->local_setup_buff);\r\n}\r\n}\r\n}\r\ntmp = readl(&udc->op_regs->epcomplete);\r\nif (!tmp)\r\nreturn;\r\nwritel(tmp, &udc->op_regs->epcomplete);\r\nfor (i = 0; i < udc->max_eps * 2; i++) {\r\nep_num = i >> 1;\r\ndirection = i % 2;\r\nbit_pos = 1 << (ep_num + 16 * direction);\r\nif (!(bit_pos & tmp))\r\ncontinue;\r\nif (i == 1)\r\ncurr_ep = &udc->eps[0];\r\nelse\r\ncurr_ep = &udc->eps[i];\r\nlist_for_each_entry_safe(curr_req, temp_req,\r\n&curr_ep->queue, queue) {\r\nstatus = process_ep_req(udc, i, curr_req);\r\nif (status)\r\nbreak;\r\ncurr_req->req.status = status;\r\nif (ep_num == 0) {\r\nep0_req_complete(udc, curr_ep, curr_req);\r\nbreak;\r\n} else {\r\ndone(curr_ep, curr_req, status);\r\n}\r\n}\r\n}\r\n}\r\nstatic void irq_process_reset(struct mv_udc *udc)\r\n{\r\nu32 tmp;\r\nunsigned int loops;\r\nudc->ep0_dir = EP_DIR_OUT;\r\nudc->ep0_state = WAIT_FOR_SETUP;\r\nudc->remote_wakeup = 0;\r\ntmp = readl(&udc->op_regs->deviceaddr);\r\ntmp &= ~(USB_DEVICE_ADDRESS_MASK);\r\nwritel(tmp, &udc->op_regs->deviceaddr);\r\ntmp = readl(&udc->op_regs->epsetupstat);\r\nwritel(tmp, &udc->op_regs->epsetupstat);\r\ntmp = readl(&udc->op_regs->epcomplete);\r\nwritel(tmp, &udc->op_regs->epcomplete);\r\nloops = LOOPS(PRIME_TIMEOUT);\r\nwhile (readl(&udc->op_regs->epprime) & 0xFFFFFFFF) {\r\nif (loops == 0) {\r\ndev_err(&udc->dev->dev,\r\n"Timeout for ENDPTPRIME = 0x%x\n",\r\nreadl(&udc->op_regs->epprime));\r\nbreak;\r\n}\r\nloops--;\r\nudelay(LOOPS_USEC);\r\n}\r\nwritel((u32)~0, &udc->op_regs->epflush);\r\nif (readl(&udc->op_regs->portsc[0]) & PORTSCX_PORT_RESET) {\r\ndev_info(&udc->dev->dev, "usb bus reset\n");\r\nudc->usb_state = USB_STATE_DEFAULT;\r\ngadget_reset(udc, udc->driver);\r\n} else {\r\ndev_info(&udc->dev->dev, "USB reset portsc 0x%x\n",\r\nreadl(&udc->op_regs->portsc));\r\nudc_reset(udc);\r\nstop_activity(udc, udc->driver);\r\nep0_reset(udc);\r\nudc_start(udc);\r\nudc->usb_state = USB_STATE_ATTACHED;\r\n}\r\n}\r\nstatic void handle_bus_resume(struct mv_udc *udc)\r\n{\r\nudc->usb_state = udc->resume_state;\r\nudc->resume_state = 0;\r\nif (udc->driver) {\r\nif (udc->driver->resume) {\r\nspin_unlock(&udc->lock);\r\nudc->driver->resume(&udc->gadget);\r\nspin_lock(&udc->lock);\r\n}\r\n}\r\n}\r\nstatic void irq_process_suspend(struct mv_udc *udc)\r\n{\r\nudc->resume_state = udc->usb_state;\r\nudc->usb_state = USB_STATE_SUSPENDED;\r\nif (udc->driver->suspend) {\r\nspin_unlock(&udc->lock);\r\nudc->driver->suspend(&udc->gadget);\r\nspin_lock(&udc->lock);\r\n}\r\n}\r\nstatic void irq_process_port_change(struct mv_udc *udc)\r\n{\r\nu32 portsc;\r\nportsc = readl(&udc->op_regs->portsc[0]);\r\nif (!(portsc & PORTSCX_PORT_RESET)) {\r\nu32 speed = portsc & PORTSCX_PORT_SPEED_MASK;\r\nswitch (speed) {\r\ncase PORTSCX_PORT_SPEED_HIGH:\r\nudc->gadget.speed = USB_SPEED_HIGH;\r\nbreak;\r\ncase PORTSCX_PORT_SPEED_FULL:\r\nudc->gadget.speed = USB_SPEED_FULL;\r\nbreak;\r\ncase PORTSCX_PORT_SPEED_LOW:\r\nudc->gadget.speed = USB_SPEED_LOW;\r\nbreak;\r\ndefault:\r\nudc->gadget.speed = USB_SPEED_UNKNOWN;\r\nbreak;\r\n}\r\n}\r\nif (portsc & PORTSCX_PORT_SUSPEND) {\r\nudc->resume_state = udc->usb_state;\r\nudc->usb_state = USB_STATE_SUSPENDED;\r\nif (udc->driver->suspend) {\r\nspin_unlock(&udc->lock);\r\nudc->driver->suspend(&udc->gadget);\r\nspin_lock(&udc->lock);\r\n}\r\n}\r\nif (!(portsc & PORTSCX_PORT_SUSPEND)\r\n&& udc->usb_state == USB_STATE_SUSPENDED) {\r\nhandle_bus_resume(udc);\r\n}\r\nif (!udc->resume_state)\r\nudc->usb_state = USB_STATE_DEFAULT;\r\n}\r\nstatic void irq_process_error(struct mv_udc *udc)\r\n{\r\nudc->errors++;\r\n}\r\nstatic irqreturn_t mv_udc_irq(int irq, void *dev)\r\n{\r\nstruct mv_udc *udc = (struct mv_udc *)dev;\r\nu32 status, intr;\r\nif (udc->stopped)\r\nreturn IRQ_NONE;\r\nspin_lock(&udc->lock);\r\nstatus = readl(&udc->op_regs->usbsts);\r\nintr = readl(&udc->op_regs->usbintr);\r\nstatus &= intr;\r\nif (status == 0) {\r\nspin_unlock(&udc->lock);\r\nreturn IRQ_NONE;\r\n}\r\nwritel(status, &udc->op_regs->usbsts);\r\nif (status & USBSTS_ERR)\r\nirq_process_error(udc);\r\nif (status & USBSTS_RESET)\r\nirq_process_reset(udc);\r\nif (status & USBSTS_PORT_CHANGE)\r\nirq_process_port_change(udc);\r\nif (status & USBSTS_INT)\r\nirq_process_tr_complete(udc);\r\nif (status & USBSTS_SUSPEND)\r\nirq_process_suspend(udc);\r\nspin_unlock(&udc->lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t mv_udc_vbus_irq(int irq, void *dev)\r\n{\r\nstruct mv_udc *udc = (struct mv_udc *)dev;\r\nif (udc->qwork)\r\nqueue_work(udc->qwork, &udc->vbus_work);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void mv_udc_vbus_work(struct work_struct *work)\r\n{\r\nstruct mv_udc *udc;\r\nunsigned int vbus;\r\nudc = container_of(work, struct mv_udc, vbus_work);\r\nif (!udc->pdata->vbus)\r\nreturn;\r\nvbus = udc->pdata->vbus->poll();\r\ndev_info(&udc->dev->dev, "vbus is %d\n", vbus);\r\nif (vbus == VBUS_HIGH)\r\nmv_udc_vbus_session(&udc->gadget, 1);\r\nelse if (vbus == VBUS_LOW)\r\nmv_udc_vbus_session(&udc->gadget, 0);\r\n}\r\nstatic void gadget_release(struct device *_dev)\r\n{\r\nstruct mv_udc *udc;\r\nudc = dev_get_drvdata(_dev);\r\ncomplete(udc->done);\r\n}\r\nstatic int mv_udc_remove(struct platform_device *pdev)\r\n{\r\nstruct mv_udc *udc;\r\nudc = platform_get_drvdata(pdev);\r\nusb_del_gadget_udc(&udc->gadget);\r\nif (udc->qwork) {\r\nflush_workqueue(udc->qwork);\r\ndestroy_workqueue(udc->qwork);\r\n}\r\nif (udc->dtd_pool)\r\ndma_pool_destroy(udc->dtd_pool);\r\nif (udc->ep_dqh)\r\ndma_free_coherent(&pdev->dev, udc->ep_dqh_size,\r\nudc->ep_dqh, udc->ep_dqh_dma);\r\nmv_udc_disable(udc);\r\nwait_for_completion(udc->done);\r\nreturn 0;\r\n}\r\nstatic int mv_udc_probe(struct platform_device *pdev)\r\n{\r\nstruct mv_usb_platform_data *pdata = dev_get_platdata(&pdev->dev);\r\nstruct mv_udc *udc;\r\nint retval = 0;\r\nstruct resource *r;\r\nsize_t size;\r\nif (pdata == NULL) {\r\ndev_err(&pdev->dev, "missing platform_data\n");\r\nreturn -ENODEV;\r\n}\r\nudc = devm_kzalloc(&pdev->dev, sizeof(*udc), GFP_KERNEL);\r\nif (udc == NULL)\r\nreturn -ENOMEM;\r\nudc->done = &release_done;\r\nudc->pdata = dev_get_platdata(&pdev->dev);\r\nspin_lock_init(&udc->lock);\r\nudc->dev = pdev;\r\nif (pdata->mode == MV_USB_MODE_OTG) {\r\nudc->transceiver = devm_usb_get_phy(&pdev->dev,\r\nUSB_PHY_TYPE_USB2);\r\nif (IS_ERR(udc->transceiver)) {\r\nretval = PTR_ERR(udc->transceiver);\r\nif (retval == -ENXIO)\r\nreturn retval;\r\nudc->transceiver = NULL;\r\nreturn -EPROBE_DEFER;\r\n}\r\n}\r\nudc->clk = devm_clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(udc->clk))\r\nreturn PTR_ERR(udc->clk);\r\nr = platform_get_resource_byname(udc->dev, IORESOURCE_MEM, "capregs");\r\nif (r == NULL) {\r\ndev_err(&pdev->dev, "no I/O memory resource defined\n");\r\nreturn -ENODEV;\r\n}\r\nudc->cap_regs = (struct mv_cap_regs __iomem *)\r\ndevm_ioremap(&pdev->dev, r->start, resource_size(r));\r\nif (udc->cap_regs == NULL) {\r\ndev_err(&pdev->dev, "failed to map I/O memory\n");\r\nreturn -EBUSY;\r\n}\r\nr = platform_get_resource_byname(udc->dev, IORESOURCE_MEM, "phyregs");\r\nif (r == NULL) {\r\ndev_err(&pdev->dev, "no phy I/O memory resource defined\n");\r\nreturn -ENODEV;\r\n}\r\nudc->phy_regs = ioremap(r->start, resource_size(r));\r\nif (udc->phy_regs == NULL) {\r\ndev_err(&pdev->dev, "failed to map phy I/O memory\n");\r\nreturn -EBUSY;\r\n}\r\nretval = mv_udc_enable_internal(udc);\r\nif (retval)\r\nreturn retval;\r\nudc->op_regs =\r\n(struct mv_op_regs __iomem *)((unsigned long)udc->cap_regs\r\n+ (readl(&udc->cap_regs->caplength_hciversion)\r\n& CAPLENGTH_MASK));\r\nudc->max_eps = readl(&udc->cap_regs->dccparams) & DCCPARAMS_DEN_MASK;\r\nudc_stop(udc);\r\nwritel(0xFFFFFFFF, &udc->op_regs->usbsts);\r\nsize = udc->max_eps * sizeof(struct mv_dqh) *2;\r\nsize = (size + DQH_ALIGNMENT - 1) & ~(DQH_ALIGNMENT - 1);\r\nudc->ep_dqh = dma_alloc_coherent(&pdev->dev, size,\r\n&udc->ep_dqh_dma, GFP_KERNEL);\r\nif (udc->ep_dqh == NULL) {\r\ndev_err(&pdev->dev, "allocate dQH memory failed\n");\r\nretval = -ENOMEM;\r\ngoto err_disable_clock;\r\n}\r\nudc->ep_dqh_size = size;\r\nudc->dtd_pool = dma_pool_create("mv_dtd",\r\n&pdev->dev,\r\nsizeof(struct mv_dtd),\r\nDTD_ALIGNMENT,\r\nDMA_BOUNDARY);\r\nif (!udc->dtd_pool) {\r\nretval = -ENOMEM;\r\ngoto err_free_dma;\r\n}\r\nsize = udc->max_eps * sizeof(struct mv_ep) *2;\r\nudc->eps = devm_kzalloc(&pdev->dev, size, GFP_KERNEL);\r\nif (udc->eps == NULL) {\r\nretval = -ENOMEM;\r\ngoto err_destroy_dma;\r\n}\r\nudc->status_req = devm_kzalloc(&pdev->dev, sizeof(struct mv_req),\r\nGFP_KERNEL);\r\nif (!udc->status_req) {\r\nretval = -ENOMEM;\r\ngoto err_destroy_dma;\r\n}\r\nINIT_LIST_HEAD(&udc->status_req->queue);\r\nudc->status_req->req.buf = kzalloc(8, GFP_KERNEL);\r\nudc->status_req->req.dma = DMA_ADDR_INVALID;\r\nudc->resume_state = USB_STATE_NOTATTACHED;\r\nudc->usb_state = USB_STATE_POWERED;\r\nudc->ep0_dir = EP_DIR_OUT;\r\nudc->remote_wakeup = 0;\r\nr = platform_get_resource(udc->dev, IORESOURCE_IRQ, 0);\r\nif (r == NULL) {\r\ndev_err(&pdev->dev, "no IRQ resource defined\n");\r\nretval = -ENODEV;\r\ngoto err_destroy_dma;\r\n}\r\nudc->irq = r->start;\r\nif (devm_request_irq(&pdev->dev, udc->irq, mv_udc_irq,\r\nIRQF_SHARED, driver_name, udc)) {\r\ndev_err(&pdev->dev, "Request irq %d for UDC failed\n",\r\nudc->irq);\r\nretval = -ENODEV;\r\ngoto err_destroy_dma;\r\n}\r\nudc->gadget.ops = &mv_ops;\r\nudc->gadget.ep0 = &udc->eps[0].ep;\r\nINIT_LIST_HEAD(&udc->gadget.ep_list);\r\nudc->gadget.speed = USB_SPEED_UNKNOWN;\r\nudc->gadget.max_speed = USB_SPEED_HIGH;\r\nudc->gadget.name = driver_name;\r\neps_init(udc);\r\nif (udc->transceiver)\r\nudc->clock_gating = 1;\r\nelse if (pdata->vbus) {\r\nudc->clock_gating = 1;\r\nretval = devm_request_threaded_irq(&pdev->dev,\r\npdata->vbus->irq, NULL,\r\nmv_udc_vbus_irq, IRQF_ONESHOT, "vbus", udc);\r\nif (retval) {\r\ndev_info(&pdev->dev,\r\n"Can not request irq for VBUS, "\r\n"disable clock gating\n");\r\nudc->clock_gating = 0;\r\n}\r\nudc->qwork = create_singlethread_workqueue("mv_udc_queue");\r\nif (!udc->qwork) {\r\ndev_err(&pdev->dev, "cannot create workqueue\n");\r\nretval = -ENOMEM;\r\ngoto err_destroy_dma;\r\n}\r\nINIT_WORK(&udc->vbus_work, mv_udc_vbus_work);\r\n}\r\nif (udc->clock_gating)\r\nmv_udc_disable_internal(udc);\r\nelse\r\nudc->vbus_active = 1;\r\nretval = usb_add_gadget_udc_release(&pdev->dev, &udc->gadget,\r\ngadget_release);\r\nif (retval)\r\ngoto err_create_workqueue;\r\nplatform_set_drvdata(pdev, udc);\r\ndev_info(&pdev->dev, "successful probe UDC device %s clock gating.\n",\r\nudc->clock_gating ? "with" : "without");\r\nreturn 0;\r\nerr_create_workqueue:\r\ndestroy_workqueue(udc->qwork);\r\nerr_destroy_dma:\r\ndma_pool_destroy(udc->dtd_pool);\r\nerr_free_dma:\r\ndma_free_coherent(&pdev->dev, udc->ep_dqh_size,\r\nudc->ep_dqh, udc->ep_dqh_dma);\r\nerr_disable_clock:\r\nmv_udc_disable_internal(udc);\r\nreturn retval;\r\n}\r\nstatic int mv_udc_suspend(struct device *dev)\r\n{\r\nstruct mv_udc *udc;\r\nudc = dev_get_drvdata(dev);\r\nif (udc->transceiver)\r\nreturn 0;\r\nif (udc->pdata->vbus && udc->pdata->vbus->poll)\r\nif (udc->pdata->vbus->poll() == VBUS_HIGH) {\r\ndev_info(&udc->dev->dev, "USB cable is connected!\n");\r\nreturn -EAGAIN;\r\n}\r\nif (!udc->clock_gating) {\r\nudc_stop(udc);\r\nspin_lock_irq(&udc->lock);\r\nstop_activity(udc, udc->driver);\r\nspin_unlock_irq(&udc->lock);\r\nmv_udc_disable_internal(udc);\r\n}\r\nreturn 0;\r\n}\r\nstatic int mv_udc_resume(struct device *dev)\r\n{\r\nstruct mv_udc *udc;\r\nint retval;\r\nudc = dev_get_drvdata(dev);\r\nif (udc->transceiver)\r\nreturn 0;\r\nif (!udc->clock_gating) {\r\nretval = mv_udc_enable_internal(udc);\r\nif (retval)\r\nreturn retval;\r\nif (udc->driver && udc->softconnect) {\r\nudc_reset(udc);\r\nep0_reset(udc);\r\nudc_start(udc);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void mv_udc_shutdown(struct platform_device *pdev)\r\n{\r\nstruct mv_udc *udc;\r\nu32 mode;\r\nudc = platform_get_drvdata(pdev);\r\nmv_udc_enable(udc);\r\nmode = readl(&udc->op_regs->usbmode);\r\nmode &= ~3;\r\nwritel(mode, &udc->op_regs->usbmode);\r\nmv_udc_disable(udc);\r\n}
