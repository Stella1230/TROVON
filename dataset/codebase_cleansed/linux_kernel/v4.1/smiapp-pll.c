static inline uint32_t clk_div_even(uint32_t a)\r\n{\r\nreturn max_t(uint32_t, 1, a & ~1);\r\n}\r\nstatic inline uint32_t clk_div_even_up(uint32_t a)\r\n{\r\nif (a == 1)\r\nreturn 1;\r\nreturn (a + 1) & ~1;\r\n}\r\nstatic inline uint32_t is_one_or_even(uint32_t a)\r\n{\r\nif (a == 1)\r\nreturn 1;\r\nif (a & 1)\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic int bounds_check(struct device *dev, uint32_t val,\r\nuint32_t min, uint32_t max, char *str)\r\n{\r\nif (val >= min && val <= max)\r\nreturn 0;\r\ndev_dbg(dev, "%s out of bounds: %d (%d--%d)\n", str, val, min, max);\r\nreturn -EINVAL;\r\n}\r\nstatic void print_pll(struct device *dev, struct smiapp_pll *pll)\r\n{\r\ndev_dbg(dev, "pre_pll_clk_div\t%u\n", pll->pre_pll_clk_div);\r\ndev_dbg(dev, "pll_multiplier \t%u\n", pll->pll_multiplier);\r\nif (!(pll->flags & SMIAPP_PLL_FLAG_NO_OP_CLOCKS)) {\r\ndev_dbg(dev, "op_sys_clk_div \t%u\n", pll->op.sys_clk_div);\r\ndev_dbg(dev, "op_pix_clk_div \t%u\n", pll->op.pix_clk_div);\r\n}\r\ndev_dbg(dev, "vt_sys_clk_div \t%u\n", pll->vt.sys_clk_div);\r\ndev_dbg(dev, "vt_pix_clk_div \t%u\n", pll->vt.pix_clk_div);\r\ndev_dbg(dev, "ext_clk_freq_hz \t%u\n", pll->ext_clk_freq_hz);\r\ndev_dbg(dev, "pll_ip_clk_freq_hz \t%u\n", pll->pll_ip_clk_freq_hz);\r\ndev_dbg(dev, "pll_op_clk_freq_hz \t%u\n", pll->pll_op_clk_freq_hz);\r\nif (!(pll->flags & SMIAPP_PLL_FLAG_NO_OP_CLOCKS)) {\r\ndev_dbg(dev, "op_sys_clk_freq_hz \t%u\n",\r\npll->op.sys_clk_freq_hz);\r\ndev_dbg(dev, "op_pix_clk_freq_hz \t%u\n",\r\npll->op.pix_clk_freq_hz);\r\n}\r\ndev_dbg(dev, "vt_sys_clk_freq_hz \t%u\n", pll->vt.sys_clk_freq_hz);\r\ndev_dbg(dev, "vt_pix_clk_freq_hz \t%u\n", pll->vt.pix_clk_freq_hz);\r\n}\r\nstatic int check_all_bounds(struct device *dev,\r\nconst struct smiapp_pll_limits *limits,\r\nconst struct smiapp_pll_branch_limits *op_limits,\r\nstruct smiapp_pll *pll,\r\nstruct smiapp_pll_branch *op_pll)\r\n{\r\nint rval;\r\nrval = bounds_check(dev, pll->pll_ip_clk_freq_hz,\r\nlimits->min_pll_ip_freq_hz,\r\nlimits->max_pll_ip_freq_hz,\r\n"pll_ip_clk_freq_hz");\r\nif (!rval)\r\nrval = bounds_check(\r\ndev, pll->pll_multiplier,\r\nlimits->min_pll_multiplier, limits->max_pll_multiplier,\r\n"pll_multiplier");\r\nif (!rval)\r\nrval = bounds_check(\r\ndev, pll->pll_op_clk_freq_hz,\r\nlimits->min_pll_op_freq_hz, limits->max_pll_op_freq_hz,\r\n"pll_op_clk_freq_hz");\r\nif (!rval)\r\nrval = bounds_check(\r\ndev, op_pll->sys_clk_div,\r\nop_limits->min_sys_clk_div, op_limits->max_sys_clk_div,\r\n"op_sys_clk_div");\r\nif (!rval)\r\nrval = bounds_check(\r\ndev, op_pll->sys_clk_freq_hz,\r\nop_limits->min_sys_clk_freq_hz,\r\nop_limits->max_sys_clk_freq_hz,\r\n"op_sys_clk_freq_hz");\r\nif (!rval)\r\nrval = bounds_check(\r\ndev, op_pll->pix_clk_freq_hz,\r\nop_limits->min_pix_clk_freq_hz,\r\nop_limits->max_pix_clk_freq_hz,\r\n"op_pix_clk_freq_hz");\r\nif (pll->flags & SMIAPP_PLL_FLAG_NO_OP_CLOCKS)\r\nreturn rval;\r\nif (!rval)\r\nrval = bounds_check(\r\ndev, pll->vt.sys_clk_freq_hz,\r\nlimits->vt.min_sys_clk_freq_hz,\r\nlimits->vt.max_sys_clk_freq_hz,\r\n"vt_sys_clk_freq_hz");\r\nif (!rval)\r\nrval = bounds_check(\r\ndev, pll->vt.pix_clk_freq_hz,\r\nlimits->vt.min_pix_clk_freq_hz,\r\nlimits->vt.max_pix_clk_freq_hz,\r\n"vt_pix_clk_freq_hz");\r\nreturn rval;\r\n}\r\nstatic int __smiapp_pll_calculate(\r\nstruct device *dev, const struct smiapp_pll_limits *limits,\r\nconst struct smiapp_pll_branch_limits *op_limits,\r\nstruct smiapp_pll *pll, struct smiapp_pll_branch *op_pll, uint32_t mul,\r\nuint32_t div, uint32_t lane_op_clock_ratio)\r\n{\r\nuint32_t sys_div;\r\nuint32_t best_pix_div = INT_MAX >> 1;\r\nuint32_t vt_op_binning_div;\r\nuint32_t more_mul_min, more_mul_max;\r\nuint32_t more_mul_factor;\r\nuint32_t min_vt_div, max_vt_div, vt_div;\r\nuint32_t min_sys_div, max_sys_div;\r\nunsigned int i;\r\ndev_dbg(dev, "pre_pll_clk_div %u\n", pll->pre_pll_clk_div);\r\nmore_mul_max = limits->max_pll_multiplier / mul;\r\ndev_dbg(dev, "more_mul_max: max_pll_multiplier check: %u\n",\r\nmore_mul_max);\r\nmore_mul_max =\r\nmin_t(uint32_t,\r\nmore_mul_max,\r\nlimits->max_pll_op_freq_hz\r\n/ (pll->ext_clk_freq_hz / pll->pre_pll_clk_div * mul));\r\ndev_dbg(dev, "more_mul_max: max_pll_op_freq_hz check: %u\n",\r\nmore_mul_max);\r\nmore_mul_max = min(more_mul_max,\r\nop_limits->max_sys_clk_div * pll->pre_pll_clk_div\r\n/ div);\r\ndev_dbg(dev, "more_mul_max: max_op_sys_clk_div check: %u\n",\r\nmore_mul_max);\r\nmore_mul_max = min(more_mul_max,\r\nDIV_ROUND_UP(limits->max_pll_multiplier, mul));\r\ndev_dbg(dev, "more_mul_max: min_pll_multiplier check: %u\n",\r\nmore_mul_max);\r\nmore_mul_min = DIV_ROUND_UP(limits->min_pll_op_freq_hz,\r\npll->ext_clk_freq_hz / pll->pre_pll_clk_div\r\n* mul);\r\ndev_dbg(dev, "more_mul_min: min_pll_op_freq_hz check: %u\n",\r\nmore_mul_min);\r\nmore_mul_min = max(more_mul_min,\r\nDIV_ROUND_UP(limits->min_pll_multiplier, mul));\r\ndev_dbg(dev, "more_mul_min: min_pll_multiplier check: %u\n",\r\nmore_mul_min);\r\nif (more_mul_min > more_mul_max) {\r\ndev_dbg(dev,\r\n"unable to compute more_mul_min and more_mul_max\n");\r\nreturn -EINVAL;\r\n}\r\nmore_mul_factor = lcm(div, pll->pre_pll_clk_div) / div;\r\ndev_dbg(dev, "more_mul_factor: %u\n", more_mul_factor);\r\nmore_mul_factor = lcm(more_mul_factor, op_limits->min_sys_clk_div);\r\ndev_dbg(dev, "more_mul_factor: min_op_sys_clk_div: %d\n",\r\nmore_mul_factor);\r\ni = roundup(more_mul_min, more_mul_factor);\r\nif (!is_one_or_even(i))\r\ni <<= 1;\r\ndev_dbg(dev, "final more_mul: %u\n", i);\r\nif (i > more_mul_max) {\r\ndev_dbg(dev, "final more_mul is bad, max %u\n", more_mul_max);\r\nreturn -EINVAL;\r\n}\r\npll->pll_multiplier = mul * i;\r\nop_pll->sys_clk_div = div * i / pll->pre_pll_clk_div;\r\ndev_dbg(dev, "op_sys_clk_div: %u\n", op_pll->sys_clk_div);\r\npll->pll_ip_clk_freq_hz = pll->ext_clk_freq_hz\r\n/ pll->pre_pll_clk_div;\r\npll->pll_op_clk_freq_hz = pll->pll_ip_clk_freq_hz\r\n* pll->pll_multiplier;\r\nop_pll->sys_clk_freq_hz =\r\npll->pll_op_clk_freq_hz / op_pll->sys_clk_div;\r\nop_pll->pix_clk_div = pll->bits_per_pixel;\r\ndev_dbg(dev, "op_pix_clk_div: %u\n", op_pll->pix_clk_div);\r\nop_pll->pix_clk_freq_hz =\r\nop_pll->sys_clk_freq_hz / op_pll->pix_clk_div;\r\nif (pll->flags & SMIAPP_PLL_FLAG_NO_OP_CLOCKS) {\r\ngoto out_skip_vt_calc;\r\n}\r\nif (limits->min_line_length_pck_bin > limits->min_line_length_pck\r\n/ pll->binning_horizontal)\r\nvt_op_binning_div = pll->binning_horizontal;\r\nelse\r\nvt_op_binning_div = 1;\r\ndev_dbg(dev, "vt_op_binning_div: %u\n", vt_op_binning_div);\r\ndev_dbg(dev, "scale_m: %u\n", pll->scale_m);\r\nmin_vt_div = DIV_ROUND_UP(op_pll->pix_clk_div * op_pll->sys_clk_div\r\n* pll->scale_n,\r\nlane_op_clock_ratio * vt_op_binning_div\r\n* pll->scale_m);\r\ndev_dbg(dev, "min_vt_div: %u\n", min_vt_div);\r\nmin_vt_div = max(min_vt_div,\r\nDIV_ROUND_UP(pll->pll_op_clk_freq_hz,\r\nlimits->vt.max_pix_clk_freq_hz));\r\ndev_dbg(dev, "min_vt_div: max_vt_pix_clk_freq_hz: %u\n",\r\nmin_vt_div);\r\nmin_vt_div = max_t(uint32_t, min_vt_div,\r\nlimits->vt.min_pix_clk_div\r\n* limits->vt.min_sys_clk_div);\r\ndev_dbg(dev, "min_vt_div: min_vt_clk_div: %u\n", min_vt_div);\r\nmax_vt_div = limits->vt.max_sys_clk_div * limits->vt.max_pix_clk_div;\r\ndev_dbg(dev, "max_vt_div: %u\n", max_vt_div);\r\nmax_vt_div = min(max_vt_div,\r\nDIV_ROUND_UP(pll->pll_op_clk_freq_hz,\r\nlimits->vt.min_pix_clk_freq_hz));\r\ndev_dbg(dev, "max_vt_div: min_vt_pix_clk_freq_hz: %u\n",\r\nmax_vt_div);\r\nmin_sys_div = limits->vt.min_sys_clk_div;\r\ndev_dbg(dev, "min_sys_div: %u\n", min_sys_div);\r\nmin_sys_div = max(min_sys_div,\r\nDIV_ROUND_UP(min_vt_div,\r\nlimits->vt.max_pix_clk_div));\r\ndev_dbg(dev, "min_sys_div: max_vt_pix_clk_div: %u\n", min_sys_div);\r\nmin_sys_div = max(min_sys_div,\r\npll->pll_op_clk_freq_hz\r\n/ limits->vt.max_sys_clk_freq_hz);\r\ndev_dbg(dev, "min_sys_div: max_pll_op_clk_freq_hz: %u\n", min_sys_div);\r\nmin_sys_div = clk_div_even_up(min_sys_div);\r\ndev_dbg(dev, "min_sys_div: one or even: %u\n", min_sys_div);\r\nmax_sys_div = limits->vt.max_sys_clk_div;\r\ndev_dbg(dev, "max_sys_div: %u\n", max_sys_div);\r\nmax_sys_div = min(max_sys_div,\r\nDIV_ROUND_UP(max_vt_div,\r\nlimits->vt.min_pix_clk_div));\r\ndev_dbg(dev, "max_sys_div: min_vt_pix_clk_div: %u\n", max_sys_div);\r\nmax_sys_div = min(max_sys_div,\r\nDIV_ROUND_UP(pll->pll_op_clk_freq_hz,\r\nlimits->vt.min_pix_clk_freq_hz));\r\ndev_dbg(dev, "max_sys_div: min_vt_pix_clk_freq_hz: %u\n", max_sys_div);\r\nfor (vt_div = min_vt_div; vt_div <= max_vt_div;\r\nvt_div += 2 - (vt_div & 1)) {\r\nfor (sys_div = min_sys_div;\r\nsys_div <= max_sys_div;\r\nsys_div += 2 - (sys_div & 1)) {\r\nuint16_t pix_div = DIV_ROUND_UP(vt_div, sys_div);\r\nif (pix_div < limits->vt.min_pix_clk_div\r\n|| pix_div > limits->vt.max_pix_clk_div) {\r\ndev_dbg(dev,\r\n"pix_div %u too small or too big (%u--%u)\n",\r\npix_div,\r\nlimits->vt.min_pix_clk_div,\r\nlimits->vt.max_pix_clk_div);\r\ncontinue;\r\n}\r\nif (pix_div * sys_div\r\n<= roundup(min_vt_div, best_pix_div))\r\nbest_pix_div = pix_div;\r\n}\r\nif (best_pix_div < INT_MAX >> 1)\r\nbreak;\r\n}\r\npll->vt.sys_clk_div = DIV_ROUND_UP(min_vt_div, best_pix_div);\r\npll->vt.pix_clk_div = best_pix_div;\r\npll->vt.sys_clk_freq_hz =\r\npll->pll_op_clk_freq_hz / pll->vt.sys_clk_div;\r\npll->vt.pix_clk_freq_hz =\r\npll->vt.sys_clk_freq_hz / pll->vt.pix_clk_div;\r\nout_skip_vt_calc:\r\npll->pixel_rate_csi =\r\nop_pll->pix_clk_freq_hz * lane_op_clock_ratio;\r\npll->pixel_rate_pixel_array = pll->vt.pix_clk_freq_hz;\r\nreturn check_all_bounds(dev, limits, op_limits, pll, op_pll);\r\n}\r\nint smiapp_pll_calculate(struct device *dev,\r\nconst struct smiapp_pll_limits *limits,\r\nstruct smiapp_pll *pll)\r\n{\r\nconst struct smiapp_pll_branch_limits *op_limits = &limits->op;\r\nstruct smiapp_pll_branch *op_pll = &pll->op;\r\nuint16_t min_pre_pll_clk_div;\r\nuint16_t max_pre_pll_clk_div;\r\nuint32_t lane_op_clock_ratio;\r\nuint32_t mul, div;\r\nunsigned int i;\r\nint rval = -EINVAL;\r\nif (pll->flags & SMIAPP_PLL_FLAG_NO_OP_CLOCKS) {\r\nop_limits = &limits->vt;\r\nop_pll = &pll->vt;\r\n}\r\nif (pll->flags & SMIAPP_PLL_FLAG_OP_PIX_CLOCK_PER_LANE)\r\nlane_op_clock_ratio = pll->csi2.lanes;\r\nelse\r\nlane_op_clock_ratio = 1;\r\ndev_dbg(dev, "lane_op_clock_ratio: %u\n", lane_op_clock_ratio);\r\ndev_dbg(dev, "binning: %ux%u\n", pll->binning_horizontal,\r\npll->binning_vertical);\r\nswitch (pll->bus_type) {\r\ncase SMIAPP_PLL_BUS_TYPE_CSI2:\r\npll->pll_op_clk_freq_hz = pll->link_freq * 2\r\n* (pll->csi2.lanes / lane_op_clock_ratio);\r\nbreak;\r\ncase SMIAPP_PLL_BUS_TYPE_PARALLEL:\r\npll->pll_op_clk_freq_hz = pll->link_freq * pll->bits_per_pixel\r\n/ DIV_ROUND_UP(pll->bits_per_pixel,\r\npll->parallel.bus_width);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\ndev_dbg(dev, "min / max pre_pll_clk_div: %u / %u\n",\r\nlimits->min_pre_pll_clk_div, limits->max_pre_pll_clk_div);\r\nmax_pre_pll_clk_div =\r\nmin_t(uint16_t, limits->max_pre_pll_clk_div,\r\nclk_div_even(pll->ext_clk_freq_hz /\r\nlimits->min_pll_ip_freq_hz));\r\nmin_pre_pll_clk_div =\r\nmax_t(uint16_t, limits->min_pre_pll_clk_div,\r\nclk_div_even_up(\r\nDIV_ROUND_UP(pll->ext_clk_freq_hz,\r\nlimits->max_pll_ip_freq_hz)));\r\ndev_dbg(dev, "pre-pll check: min / max pre_pll_clk_div: %u / %u\n",\r\nmin_pre_pll_clk_div, max_pre_pll_clk_div);\r\ni = gcd(pll->pll_op_clk_freq_hz, pll->ext_clk_freq_hz);\r\nmul = div_u64(pll->pll_op_clk_freq_hz, i);\r\ndiv = pll->ext_clk_freq_hz / i;\r\ndev_dbg(dev, "mul %u / div %u\n", mul, div);\r\nmin_pre_pll_clk_div =\r\nmax_t(uint16_t, min_pre_pll_clk_div,\r\nclk_div_even_up(\r\nDIV_ROUND_UP(mul * pll->ext_clk_freq_hz,\r\nlimits->max_pll_op_freq_hz)));\r\ndev_dbg(dev, "pll_op check: min / max pre_pll_clk_div: %u / %u\n",\r\nmin_pre_pll_clk_div, max_pre_pll_clk_div);\r\nfor (pll->pre_pll_clk_div = min_pre_pll_clk_div;\r\npll->pre_pll_clk_div <= max_pre_pll_clk_div;\r\npll->pre_pll_clk_div += 2 - (pll->pre_pll_clk_div & 1)) {\r\nrval = __smiapp_pll_calculate(dev, limits, op_limits, pll,\r\nop_pll, mul, div,\r\nlane_op_clock_ratio);\r\nif (rval)\r\ncontinue;\r\nprint_pll(dev, pll);\r\nreturn 0;\r\n}\r\ndev_info(dev, "unable to compute pre_pll divisor\n");\r\nreturn rval;\r\n}
