static inline void update_capa_timer(struct obd_capa *ocapa, unsigned long expiry)\r\n{\r\nif (time_before(expiry, ll_capa_timer.expires) ||\r\n!timer_pending(&ll_capa_timer)) {\r\nmod_timer(&ll_capa_timer, expiry);\r\nDEBUG_CAPA(D_SEC, &ocapa->c_capa,\r\n"ll_capa_timer update: %lu/%lu by", expiry, jiffies);\r\n}\r\n}\r\nstatic inline unsigned long capa_renewal_time(struct obd_capa *ocapa)\r\n{\r\nreturn cfs_time_sub(ocapa->c_expiry,\r\ncfs_time_seconds(ocapa->c_capa.lc_timeout) / 2);\r\n}\r\nstatic inline int capa_is_to_expire(struct obd_capa *ocapa)\r\n{\r\nreturn time_before_eq(capa_renewal_time(ocapa), cfs_time_current());\r\n}\r\nstatic inline int have_expired_capa(void)\r\n{\r\nstruct obd_capa *ocapa = NULL;\r\nint expired = 0;\r\nspin_lock(&capa_lock);\r\nif (!list_empty(ll_capa_list)) {\r\nocapa = list_entry(ll_capa_list->next, struct obd_capa,\r\nc_list);\r\nexpired = capa_is_to_expire(ocapa);\r\nif (!expired)\r\nupdate_capa_timer(ocapa, capa_renewal_time(ocapa));\r\n} else if (!list_empty(&ll_idle_capas)) {\r\nocapa = list_entry(ll_idle_capas.next, struct obd_capa,\r\nc_list);\r\nexpired = capa_is_expired(ocapa);\r\nif (!expired)\r\nupdate_capa_timer(ocapa, ocapa->c_expiry);\r\n}\r\nspin_unlock(&capa_lock);\r\nif (expired)\r\nDEBUG_CAPA(D_SEC, &ocapa->c_capa, "expired");\r\nreturn expired;\r\n}\r\nstatic void sort_add_capa(struct obd_capa *ocapa, struct list_head *head)\r\n{\r\nstruct obd_capa *tmp;\r\nstruct list_head *before = NULL;\r\nlist_for_each_entry_reverse(tmp, head, c_list) {\r\nif (cfs_time_aftereq(ocapa->c_expiry, tmp->c_expiry)) {\r\nbefore = &tmp->c_list;\r\nbreak;\r\n}\r\n}\r\nLASSERT(&ocapa->c_list != before);\r\nlist_add(&ocapa->c_list, before ?: head);\r\n}\r\nstatic inline int obd_capa_open_count(struct obd_capa *oc)\r\n{\r\nstruct ll_inode_info *lli = ll_i2info(oc->u.cli.inode);\r\nreturn atomic_read(&lli->lli_open_count);\r\n}\r\nstatic void ll_delete_capa(struct obd_capa *ocapa)\r\n{\r\nstruct ll_inode_info *lli = ll_i2info(ocapa->u.cli.inode);\r\nif (capa_for_mds(&ocapa->c_capa)) {\r\nLASSERT(lli->lli_mds_capa == ocapa);\r\nlli->lli_mds_capa = NULL;\r\n} else if (capa_for_oss(&ocapa->c_capa)) {\r\nlist_del_init(&ocapa->u.cli.lli_list);\r\n}\r\nDEBUG_CAPA(D_SEC, &ocapa->c_capa, "free client");\r\nlist_del_init(&ocapa->c_list);\r\ncapa_count[CAPA_SITE_CLIENT]--;\r\ncapa_put(ocapa);\r\n}\r\nstatic int capa_thread_main(void *unused)\r\n{\r\nstruct obd_capa *ocapa, *tmp, *next;\r\nstruct inode *inode = NULL;\r\nstruct l_wait_info lwi = { 0 };\r\nint rc;\r\nthread_set_flags(&ll_capa_thread, SVC_RUNNING);\r\nwake_up(&ll_capa_thread.t_ctl_waitq);\r\nwhile (1) {\r\nl_wait_event(ll_capa_thread.t_ctl_waitq,\r\n!thread_is_running(&ll_capa_thread) ||\r\nhave_expired_capa(),\r\n&lwi);\r\nif (!thread_is_running(&ll_capa_thread))\r\nbreak;\r\nnext = NULL;\r\nspin_lock(&capa_lock);\r\nlist_for_each_entry_safe(ocapa, tmp, ll_capa_list, c_list) {\r\n__u64 ibits;\r\nLASSERT(ocapa->c_capa.lc_opc != CAPA_OPC_OSS_TRUNC);\r\nif (!capa_is_to_expire(ocapa)) {\r\nnext = ocapa;\r\nbreak;\r\n}\r\nlist_del_init(&ocapa->c_list);\r\nibits = MDS_INODELOCK_LOOKUP;\r\nif (capa_for_mds(&ocapa->c_capa) &&\r\n!S_ISDIR(ocapa->u.cli.inode->i_mode) &&\r\nobd_capa_open_count(ocapa) == 0 &&\r\n!ll_have_md_lock(ocapa->u.cli.inode,\r\n&ibits, LCK_MINMODE)) {\r\nDEBUG_CAPA(D_SEC, &ocapa->c_capa,\r\n"skip renewal for");\r\nsort_add_capa(ocapa, &ll_idle_capas);\r\ncontinue;\r\n}\r\nif (capa_for_oss(&ocapa->c_capa) &&\r\nobd_capa_open_count(ocapa) == 0) {\r\nsort_add_capa(ocapa, &ll_idle_capas);\r\ncontinue;\r\n}\r\ninode = igrab(ocapa->u.cli.inode);\r\nif (inode == NULL) {\r\nDEBUG_CAPA(D_ERROR, &ocapa->c_capa,\r\n"igrab failed for");\r\ncontinue;\r\n}\r\ncapa_get(ocapa);\r\nll_capa_renewed++;\r\nspin_unlock(&capa_lock);\r\nrc = md_renew_capa(ll_i2mdexp(inode), ocapa,\r\nll_update_capa);\r\nspin_lock(&capa_lock);\r\nif (rc) {\r\nDEBUG_CAPA(D_ERROR, &ocapa->c_capa,\r\n"renew failed: %d", rc);\r\nll_capa_renewal_failed++;\r\n}\r\n}\r\nif (next)\r\nupdate_capa_timer(next, capa_renewal_time(next));\r\nlist_for_each_entry_safe(ocapa, tmp, &ll_idle_capas,\r\nc_list) {\r\nif (!capa_is_expired(ocapa)) {\r\nif (!next)\r\nupdate_capa_timer(ocapa,\r\nocapa->c_expiry);\r\nbreak;\r\n}\r\nif (atomic_read(&ocapa->c_refc) > 1) {\r\nDEBUG_CAPA(D_SEC, &ocapa->c_capa,\r\n"expired(c_refc %d), don't release",\r\natomic_read(&ocapa->c_refc));\r\nlist_del_init(&ocapa->c_list);\r\ncontinue;\r\n}\r\nDEBUG_CAPA(D_SEC, &ocapa->c_capa, "release expired");\r\nll_delete_capa(ocapa);\r\n}\r\nspin_unlock(&capa_lock);\r\n}\r\nthread_set_flags(&ll_capa_thread, SVC_STOPPED);\r\nwake_up(&ll_capa_thread.t_ctl_waitq);\r\nreturn 0;\r\n}\r\nvoid ll_capa_timer_callback(unsigned long unused)\r\n{\r\nwake_up(&ll_capa_thread.t_ctl_waitq);\r\n}\r\nint ll_capa_thread_start(void)\r\n{\r\nstruct task_struct *task;\r\ninit_waitqueue_head(&ll_capa_thread.t_ctl_waitq);\r\ntask = kthread_run(capa_thread_main, NULL, "ll_capa");\r\nif (IS_ERR(task)) {\r\nCERROR("cannot start expired capa thread: rc %ld\n",\r\nPTR_ERR(task));\r\nreturn PTR_ERR(task);\r\n}\r\nwait_event(ll_capa_thread.t_ctl_waitq,\r\nthread_is_running(&ll_capa_thread));\r\nreturn 0;\r\n}\r\nvoid ll_capa_thread_stop(void)\r\n{\r\nthread_set_flags(&ll_capa_thread, SVC_STOPPING);\r\nwake_up(&ll_capa_thread.t_ctl_waitq);\r\nwait_event(ll_capa_thread.t_ctl_waitq,\r\nthread_is_stopped(&ll_capa_thread));\r\n}\r\nstruct obd_capa *ll_osscapa_get(struct inode *inode, __u64 opc)\r\n{\r\nstruct ll_inode_info *lli = ll_i2info(inode);\r\nstruct obd_capa *ocapa;\r\nint found = 0;\r\nif ((ll_i2sbi(inode)->ll_flags & LL_SBI_OSS_CAPA) == 0)\r\nreturn NULL;\r\nLASSERT(opc == CAPA_OPC_OSS_WRITE || opc == CAPA_OPC_OSS_RW ||\r\nopc == CAPA_OPC_OSS_TRUNC);\r\nspin_lock(&capa_lock);\r\nlist_for_each_entry(ocapa, &lli->lli_oss_capas, u.cli.lli_list) {\r\nif (capa_is_expired(ocapa))\r\ncontinue;\r\nif ((opc & CAPA_OPC_OSS_WRITE) &&\r\ncapa_opc_supported(&ocapa->c_capa, CAPA_OPC_OSS_WRITE)) {\r\nfound = 1;\r\nbreak;\r\n} else if ((opc & CAPA_OPC_OSS_READ) &&\r\ncapa_opc_supported(&ocapa->c_capa,\r\nCAPA_OPC_OSS_READ)) {\r\nfound = 1;\r\nbreak;\r\n} else if ((opc & CAPA_OPC_OSS_TRUNC) &&\r\ncapa_opc_supported(&ocapa->c_capa, opc)) {\r\nfound = 1;\r\nbreak;\r\n}\r\n}\r\nif (found) {\r\nLASSERT(lu_fid_eq(capa_fid(&ocapa->c_capa),\r\nll_inode2fid(inode)));\r\nLASSERT(ocapa->c_site == CAPA_SITE_CLIENT);\r\ncapa_get(ocapa);\r\nDEBUG_CAPA(D_SEC, &ocapa->c_capa, "found client");\r\n} else {\r\nocapa = NULL;\r\nif (atomic_read(&ll_capa_debug)) {\r\nCERROR("no capability for "DFID" opc %#llx\n",\r\nPFID(&lli->lli_fid), opc);\r\natomic_set(&ll_capa_debug, 0);\r\n}\r\n}\r\nspin_unlock(&capa_lock);\r\nreturn ocapa;\r\n}\r\nstruct obd_capa *ll_mdscapa_get(struct inode *inode)\r\n{\r\nstruct ll_inode_info *lli = ll_i2info(inode);\r\nstruct obd_capa *ocapa;\r\nLASSERT(inode != NULL);\r\nif ((ll_i2sbi(inode)->ll_flags & LL_SBI_MDS_CAPA) == 0)\r\nreturn NULL;\r\nspin_lock(&capa_lock);\r\nocapa = capa_get(lli->lli_mds_capa);\r\nspin_unlock(&capa_lock);\r\nif (!ocapa && atomic_read(&ll_capa_debug)) {\r\nCERROR("no mds capability for "DFID"\n", PFID(&lli->lli_fid));\r\natomic_set(&ll_capa_debug, 0);\r\n}\r\nreturn ocapa;\r\n}\r\nstatic struct obd_capa *do_add_mds_capa(struct inode *inode,\r\nstruct obd_capa *ocapa)\r\n{\r\nstruct ll_inode_info *lli = ll_i2info(inode);\r\nstruct obd_capa *old = lli->lli_mds_capa;\r\nstruct lustre_capa *capa = &ocapa->c_capa;\r\nif (!old) {\r\nocapa->u.cli.inode = inode;\r\nlli->lli_mds_capa = ocapa;\r\ncapa_count[CAPA_SITE_CLIENT]++;\r\nDEBUG_CAPA(D_SEC, capa, "add MDS");\r\n} else {\r\nspin_lock(&old->c_lock);\r\nold->c_capa = *capa;\r\nspin_unlock(&old->c_lock);\r\nDEBUG_CAPA(D_SEC, capa, "update MDS");\r\ncapa_put(ocapa);\r\nocapa = old;\r\n}\r\nreturn ocapa;\r\n}\r\nstatic struct obd_capa *do_lookup_oss_capa(struct inode *inode, int opc)\r\n{\r\nstruct ll_inode_info *lli = ll_i2info(inode);\r\nstruct obd_capa *ocapa;\r\nlist_for_each_entry(ocapa, &lli->lli_oss_capas, u.cli.lli_list) {\r\nif ((capa_opc(&ocapa->c_capa) & opc) != opc)\r\ncontinue;\r\nLASSERT(lu_fid_eq(capa_fid(&ocapa->c_capa),\r\nll_inode2fid(inode)));\r\nLASSERT(ocapa->c_site == CAPA_SITE_CLIENT);\r\nDEBUG_CAPA(D_SEC, &ocapa->c_capa, "found client");\r\nreturn ocapa;\r\n}\r\nreturn NULL;\r\n}\r\nstatic inline void inode_add_oss_capa(struct inode *inode,\r\nstruct obd_capa *ocapa)\r\n{\r\nstruct ll_inode_info *lli = ll_i2info(inode);\r\nstruct obd_capa *tmp;\r\nstruct list_head *next = NULL;\r\nlist_for_each_entry(tmp, &lli->lli_oss_capas, u.cli.lli_list) {\r\nif (cfs_time_after(ocapa->c_expiry, tmp->c_expiry)) {\r\nnext = &tmp->u.cli.lli_list;\r\nbreak;\r\n}\r\n}\r\nLASSERT(&ocapa->u.cli.lli_list != next);\r\nlist_move_tail(&ocapa->u.cli.lli_list, next ?: &lli->lli_oss_capas);\r\n}\r\nstatic struct obd_capa *do_add_oss_capa(struct inode *inode,\r\nstruct obd_capa *ocapa)\r\n{\r\nstruct obd_capa *old;\r\nstruct lustre_capa *capa = &ocapa->c_capa;\r\nLASSERTF(S_ISREG(inode->i_mode),\r\n"inode has oss capa, but not regular file, mode: %d\n",\r\ninode->i_mode);\r\nold = do_lookup_oss_capa(inode, capa_opc(capa) & CAPA_OPC_OSS_ONLY);\r\nif (!old) {\r\nocapa->u.cli.inode = inode;\r\nINIT_LIST_HEAD(&ocapa->u.cli.lli_list);\r\ncapa_count[CAPA_SITE_CLIENT]++;\r\nDEBUG_CAPA(D_SEC, capa, "add OSS");\r\n} else {\r\nspin_lock(&old->c_lock);\r\nold->c_capa = *capa;\r\nspin_unlock(&old->c_lock);\r\nDEBUG_CAPA(D_SEC, capa, "update OSS");\r\ncapa_put(ocapa);\r\nocapa = old;\r\n}\r\ninode_add_oss_capa(inode, ocapa);\r\nreturn ocapa;\r\n}\r\nstruct obd_capa *ll_add_capa(struct inode *inode, struct obd_capa *ocapa)\r\n{\r\nspin_lock(&capa_lock);\r\nocapa = capa_for_mds(&ocapa->c_capa) ? do_add_mds_capa(inode, ocapa) :\r\ndo_add_oss_capa(inode, ocapa);\r\nif (ocapa->c_capa.lc_opc != CAPA_OPC_OSS_TRUNC) {\r\nset_capa_expiry(ocapa);\r\nlist_del_init(&ocapa->c_list);\r\nsort_add_capa(ocapa, ll_capa_list);\r\nupdate_capa_timer(ocapa, capa_renewal_time(ocapa));\r\n}\r\nspin_unlock(&capa_lock);\r\natomic_set(&ll_capa_debug, 1);\r\nreturn ocapa;\r\n}\r\nstatic inline void delay_capa_renew(struct obd_capa *oc, unsigned long delay)\r\n{\r\noc->c_expiry = cfs_time_add(oc->c_expiry, cfs_time_seconds(delay));\r\n}\r\nstatic int ll_update_capa(struct obd_capa *ocapa, struct lustre_capa *capa)\r\n{\r\nstruct inode *inode = ocapa->u.cli.inode;\r\nint rc = 0;\r\nLASSERT(ocapa);\r\nif (IS_ERR(capa)) {\r\nrc = PTR_ERR(capa);\r\nspin_lock(&capa_lock);\r\nif (rc == -ENOENT) {\r\nDEBUG_CAPA(D_SEC, &ocapa->c_capa,\r\n"renewal canceled because object removed");\r\nll_capa_renewal_noent++;\r\n} else {\r\nll_capa_renewal_failed++;\r\nif (rc == -EIO && !capa_is_expired(ocapa)) {\r\ndelay_capa_renew(ocapa, 120);\r\nDEBUG_CAPA(D_ERROR, &ocapa->c_capa,\r\n"renewal failed: -EIO, retry in 2 mins");\r\nll_capa_renewal_retries++;\r\ngoto retry;\r\n} else {\r\nDEBUG_CAPA(D_ERROR, &ocapa->c_capa,\r\n"renewal failed(rc: %d) for", rc);\r\n}\r\n}\r\nlist_del_init(&ocapa->c_list);\r\nsort_add_capa(ocapa, &ll_idle_capas);\r\nspin_unlock(&capa_lock);\r\ncapa_put(ocapa);\r\niput(inode);\r\nreturn rc;\r\n}\r\nspin_lock(&ocapa->c_lock);\r\nLASSERT(!memcmp(&ocapa->c_capa, capa,\r\noffsetof(struct lustre_capa, lc_opc)));\r\nocapa->c_capa = *capa;\r\nset_capa_expiry(ocapa);\r\nspin_unlock(&ocapa->c_lock);\r\nspin_lock(&capa_lock);\r\nif (capa_for_oss(capa))\r\ninode_add_oss_capa(inode, ocapa);\r\nDEBUG_CAPA(D_SEC, capa, "renew");\r\nretry:\r\nlist_del_init(&ocapa->c_list);\r\nsort_add_capa(ocapa, ll_capa_list);\r\nupdate_capa_timer(ocapa, capa_renewal_time(ocapa));\r\nspin_unlock(&capa_lock);\r\ncapa_put(ocapa);\r\niput(inode);\r\nreturn rc;\r\n}\r\nvoid ll_capa_open(struct inode *inode)\r\n{\r\nstruct ll_inode_info *lli = ll_i2info(inode);\r\nif ((ll_i2sbi(inode)->ll_flags & (LL_SBI_MDS_CAPA | LL_SBI_OSS_CAPA))\r\n== 0)\r\nreturn;\r\nif (!S_ISREG(inode->i_mode))\r\nreturn;\r\natomic_inc(&lli->lli_open_count);\r\n}\r\nvoid ll_capa_close(struct inode *inode)\r\n{\r\nstruct ll_inode_info *lli = ll_i2info(inode);\r\nif ((ll_i2sbi(inode)->ll_flags & (LL_SBI_MDS_CAPA | LL_SBI_OSS_CAPA))\r\n== 0)\r\nreturn;\r\nif (!S_ISREG(inode->i_mode))\r\nreturn;\r\natomic_dec(&lli->lli_open_count);\r\n}\r\nvoid ll_truncate_free_capa(struct obd_capa *ocapa)\r\n{\r\nif (!ocapa)\r\nreturn;\r\nLASSERT(ocapa->c_capa.lc_opc & CAPA_OPC_OSS_TRUNC);\r\nDEBUG_CAPA(D_SEC, &ocapa->c_capa, "free truncate");\r\ncapa_put(ocapa);\r\nif (likely(ocapa->c_capa.lc_opc == CAPA_OPC_OSS_TRUNC)) {\r\nspin_lock(&capa_lock);\r\nll_delete_capa(ocapa);\r\nspin_unlock(&capa_lock);\r\n}\r\n}\r\nvoid ll_clear_inode_capas(struct inode *inode)\r\n{\r\nstruct ll_inode_info *lli = ll_i2info(inode);\r\nstruct obd_capa *ocapa, *tmp;\r\nspin_lock(&capa_lock);\r\nocapa = lli->lli_mds_capa;\r\nif (ocapa)\r\nll_delete_capa(ocapa);\r\nlist_for_each_entry_safe(ocapa, tmp, &lli->lli_oss_capas,\r\nu.cli.lli_list)\r\nll_delete_capa(ocapa);\r\nspin_unlock(&capa_lock);\r\n}\r\nvoid ll_print_capa_stat(struct ll_sb_info *sbi)\r\n{\r\nif (sbi->ll_flags & (LL_SBI_MDS_CAPA | LL_SBI_OSS_CAPA))\r\nLCONSOLE_INFO("Fid capabilities renewed: %llu\n"\r\n"Fid capabilities renewal ENOENT: %llu\n"\r\n"Fid capabilities failed to renew: %llu\n"\r\n"Fid capabilities renewal retries: %llu\n",\r\nll_capa_renewed, ll_capa_renewal_noent,\r\nll_capa_renewal_failed, ll_capa_renewal_retries);\r\n}
