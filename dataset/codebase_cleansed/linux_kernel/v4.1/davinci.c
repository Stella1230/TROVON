static inline void phy_on(void)\r\n{\r\nu32 phy_ctrl = __raw_readl(USB_PHY_CTRL);\r\nphy_ctrl &= ~(USBPHY_OSCPDWN | USBPHY_OTGPDWN | USBPHY_PHYPDWN);\r\nphy_ctrl |= USBPHY_SESNDEN | USBPHY_VBDTCTEN | USBPHY_PHYPLLON;\r\n__raw_writel(phy_ctrl, USB_PHY_CTRL);\r\nwhile ((__raw_readl(USB_PHY_CTRL) & USBPHY_PHYCLKGD) == 0)\r\ncpu_relax();\r\n}\r\nstatic inline void phy_off(void)\r\n{\r\nu32 phy_ctrl = __raw_readl(USB_PHY_CTRL);\r\nphy_ctrl &= ~(USBPHY_SESNDEN | USBPHY_VBDTCTEN | USBPHY_PHYPLLON);\r\nphy_ctrl |= USBPHY_OSCPDWN | USBPHY_OTGPDWN | USBPHY_PHYPDWN;\r\n__raw_writel(phy_ctrl, USB_PHY_CTRL);\r\n}\r\nstatic void davinci_musb_enable(struct musb *musb)\r\n{\r\nu32 tmp, old, val;\r\ntmp = (musb->epmask & DAVINCI_USB_TX_ENDPTS_MASK)\r\n<< DAVINCI_USB_TXINT_SHIFT;\r\nmusb_writel(musb->ctrl_base, DAVINCI_USB_INT_MASK_SET_REG, tmp);\r\nold = tmp;\r\ntmp = (musb->epmask & (0xfffe & DAVINCI_USB_RX_ENDPTS_MASK))\r\n<< DAVINCI_USB_RXINT_SHIFT;\r\nmusb_writel(musb->ctrl_base, DAVINCI_USB_INT_MASK_SET_REG, tmp);\r\ntmp |= old;\r\nval = ~MUSB_INTR_SOF;\r\ntmp |= ((val & 0x01ff) << DAVINCI_USB_USBINT_SHIFT);\r\nmusb_writel(musb->ctrl_base, DAVINCI_USB_INT_MASK_SET_REG, tmp);\r\nif (is_dma_capable() && !dma_off)\r\nprintk(KERN_WARNING "%s %s: dma not reactivated\n",\r\n__FILE__, __func__);\r\nelse\r\ndma_off = 0;\r\nmusb_writel(musb->ctrl_base, DAVINCI_USB_INT_SET_REG,\r\nDAVINCI_INTR_DRVVBUS << DAVINCI_USB_USBINT_SHIFT);\r\n}\r\nstatic void davinci_musb_disable(struct musb *musb)\r\n{\r\nmusb_writel(musb->ctrl_base, DAVINCI_USB_INT_MASK_CLR_REG,\r\nDAVINCI_USB_USBINT_MASK\r\n| DAVINCI_USB_TXINT_MASK\r\n| DAVINCI_USB_RXINT_MASK);\r\nmusb_writeb(musb->mregs, MUSB_DEVCTL, 0);\r\nmusb_writel(musb->ctrl_base, DAVINCI_USB_EOI_REG, 0);\r\nif (is_dma_capable() && !dma_off)\r\nWARNING("dma still active\n");\r\n}\r\nstatic void evm_deferred_drvvbus(struct work_struct *ignored)\r\n{\r\ngpio_set_value_cansleep(GPIO_nVBUS_DRV, vbus_state);\r\nvbus_state = !vbus_state;\r\n}\r\nstatic void davinci_musb_source_power(struct musb *musb, int is_on, int immediate)\r\n{\r\n#ifdef CONFIG_MACH_DAVINCI_EVM\r\nif (is_on)\r\nis_on = 1;\r\nif (vbus_state == is_on)\r\nreturn;\r\nvbus_state = !is_on;\r\nif (machine_is_davinci_evm()) {\r\nstatic DECLARE_WORK(evm_vbus_work, evm_deferred_drvvbus);\r\nif (immediate)\r\ngpio_set_value_cansleep(GPIO_nVBUS_DRV, vbus_state);\r\nelse\r\nschedule_work(&evm_vbus_work);\r\n}\r\nif (immediate)\r\nvbus_state = is_on;\r\n#endif\r\n}\r\nstatic void davinci_musb_set_vbus(struct musb *musb, int is_on)\r\n{\r\nWARN_ON(is_on && is_peripheral_active(musb));\r\ndavinci_musb_source_power(musb, is_on, 0);\r\n}\r\nstatic void otg_timer(unsigned long _musb)\r\n{\r\nstruct musb *musb = (void *)_musb;\r\nvoid __iomem *mregs = musb->mregs;\r\nu8 devctl;\r\nunsigned long flags;\r\ndevctl = musb_readb(mregs, MUSB_DEVCTL);\r\ndev_dbg(musb->controller, "poll devctl %02x (%s)\n", devctl,\r\nusb_otg_state_string(musb->xceiv->otg->state));\r\nspin_lock_irqsave(&musb->lock, flags);\r\nswitch (musb->xceiv->otg->state) {\r\ncase OTG_STATE_A_WAIT_VFALL:\r\nif (devctl & MUSB_DEVCTL_VBUS) {\r\nmod_timer(&otg_workaround, jiffies + POLL_SECONDS * HZ);\r\nbreak;\r\n}\r\nmusb->xceiv->otg->state = OTG_STATE_A_WAIT_VRISE;\r\nmusb_writel(musb->ctrl_base, DAVINCI_USB_INT_SET_REG,\r\nMUSB_INTR_VBUSERROR << DAVINCI_USB_USBINT_SHIFT);\r\nbreak;\r\ncase OTG_STATE_B_IDLE:\r\nmusb_writeb(mregs, MUSB_DEVCTL,\r\ndevctl | MUSB_DEVCTL_SESSION);\r\ndevctl = musb_readb(mregs, MUSB_DEVCTL);\r\nif (devctl & MUSB_DEVCTL_BDEVICE)\r\nmod_timer(&otg_workaround, jiffies + POLL_SECONDS * HZ);\r\nelse\r\nmusb->xceiv->otg->state = OTG_STATE_A_IDLE;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nspin_unlock_irqrestore(&musb->lock, flags);\r\n}\r\nstatic irqreturn_t davinci_musb_interrupt(int irq, void *__hci)\r\n{\r\nunsigned long flags;\r\nirqreturn_t retval = IRQ_NONE;\r\nstruct musb *musb = __hci;\r\nstruct usb_otg *otg = musb->xceiv->otg;\r\nvoid __iomem *tibase = musb->ctrl_base;\r\nstruct cppi *cppi;\r\nu32 tmp;\r\nspin_lock_irqsave(&musb->lock, flags);\r\ncppi = container_of(musb->dma_controller, struct cppi, controller);\r\nif (is_cppi_enabled() && musb->dma_controller && !cppi->irq)\r\nretval = cppi_interrupt(irq, __hci);\r\ntmp = musb_readl(tibase, DAVINCI_USB_INT_SRC_MASKED_REG);\r\nmusb_writel(tibase, DAVINCI_USB_INT_SRC_CLR_REG, tmp);\r\ndev_dbg(musb->controller, "IRQ %08x\n", tmp);\r\nmusb->int_rx = (tmp & DAVINCI_USB_RXINT_MASK)\r\n>> DAVINCI_USB_RXINT_SHIFT;\r\nmusb->int_tx = (tmp & DAVINCI_USB_TXINT_MASK)\r\n>> DAVINCI_USB_TXINT_SHIFT;\r\nmusb->int_usb = (tmp & DAVINCI_USB_USBINT_MASK)\r\n>> DAVINCI_USB_USBINT_SHIFT;\r\nif (tmp & (DAVINCI_INTR_DRVVBUS << DAVINCI_USB_USBINT_SHIFT)) {\r\nint drvvbus = musb_readl(tibase, DAVINCI_USB_STAT_REG);\r\nvoid __iomem *mregs = musb->mregs;\r\nu8 devctl = musb_readb(mregs, MUSB_DEVCTL);\r\nint err = musb->int_usb & MUSB_INTR_VBUSERROR;\r\nerr = musb->int_usb & MUSB_INTR_VBUSERROR;\r\nif (err) {\r\nmusb->int_usb &= ~MUSB_INTR_VBUSERROR;\r\nmusb->xceiv->otg->state = OTG_STATE_A_WAIT_VFALL;\r\nmod_timer(&otg_workaround, jiffies + POLL_SECONDS * HZ);\r\nWARNING("VBUS error workaround (delay coming)\n");\r\n} else if (drvvbus) {\r\nMUSB_HST_MODE(musb);\r\notg->default_a = 1;\r\nmusb->xceiv->otg->state = OTG_STATE_A_WAIT_VRISE;\r\nportstate(musb->port1_status |= USB_PORT_STAT_POWER);\r\ndel_timer(&otg_workaround);\r\n} else {\r\nmusb->is_active = 0;\r\nMUSB_DEV_MODE(musb);\r\notg->default_a = 0;\r\nmusb->xceiv->otg->state = OTG_STATE_B_IDLE;\r\nportstate(musb->port1_status &= ~USB_PORT_STAT_POWER);\r\n}\r\ndavinci_musb_source_power(musb, drvvbus, 0);\r\ndev_dbg(musb->controller, "VBUS %s (%s)%s, devctl %02x\n",\r\ndrvvbus ? "on" : "off",\r\nusb_otg_state_string(musb->xceiv->otg->state),\r\nerr ? " ERROR" : "",\r\ndevctl);\r\nretval = IRQ_HANDLED;\r\n}\r\nif (musb->int_tx || musb->int_rx || musb->int_usb)\r\nretval |= musb_interrupt(musb);\r\nmusb_writel(tibase, DAVINCI_USB_EOI_REG, 0);\r\nif (musb->xceiv->otg->state == OTG_STATE_B_IDLE)\r\nmod_timer(&otg_workaround, jiffies + POLL_SECONDS * HZ);\r\nspin_unlock_irqrestore(&musb->lock, flags);\r\nreturn retval;\r\n}\r\nstatic int davinci_musb_set_mode(struct musb *musb, u8 mode)\r\n{\r\nreturn -EIO;\r\n}\r\nstatic int davinci_musb_init(struct musb *musb)\r\n{\r\nvoid __iomem *tibase = musb->ctrl_base;\r\nu32 revision;\r\nint ret = -ENODEV;\r\nmusb->xceiv = usb_get_phy(USB_PHY_TYPE_USB2);\r\nif (IS_ERR_OR_NULL(musb->xceiv)) {\r\nret = -EPROBE_DEFER;\r\ngoto unregister;\r\n}\r\nmusb->mregs += DAVINCI_BASE_OFFSET;\r\nrevision = musb_readl(tibase, DAVINCI_USB_VERSION_REG);\r\nif (revision == 0)\r\ngoto fail;\r\nsetup_timer(&otg_workaround, otg_timer, (unsigned long) musb);\r\ndavinci_musb_source_power(musb, 0, 1);\r\nif (machine_is_davinci_dm355_evm()) {\r\nu32 phy_ctrl = __raw_readl(USB_PHY_CTRL);\r\nphy_ctrl &= ~(3 << 9);\r\nphy_ctrl |= USBPHY_DATAPOL;\r\n__raw_writel(phy_ctrl, USB_PHY_CTRL);\r\n}\r\nif (cpu_is_davinci_dm355()) {\r\nu32 deepsleep = __raw_readl(DM355_DEEPSLEEP);\r\ndeepsleep &= ~DRVVBUS_FORCE;\r\n__raw_writel(deepsleep, DM355_DEEPSLEEP);\r\n}\r\nmusb_writel(tibase, DAVINCI_USB_CTRL_REG, 0x1);\r\nphy_on();\r\nmsleep(5);\r\npr_debug("DaVinci OTG revision %08x phy %03x control %02x\n",\r\nrevision, __raw_readl(USB_PHY_CTRL),\r\nmusb_readb(tibase, DAVINCI_USB_CTRL_REG));\r\nmusb->isr = davinci_musb_interrupt;\r\nreturn 0;\r\nfail:\r\nusb_put_phy(musb->xceiv);\r\nunregister:\r\nusb_phy_generic_unregister();\r\nreturn ret;\r\n}\r\nstatic int davinci_musb_exit(struct musb *musb)\r\n{\r\ndel_timer_sync(&otg_workaround);\r\nif (cpu_is_davinci_dm355()) {\r\nu32 deepsleep = __raw_readl(DM355_DEEPSLEEP);\r\ndeepsleep &= ~DRVVBUS_FORCE;\r\ndeepsleep |= DRVVBUS_OVERRIDE;\r\n__raw_writel(deepsleep, DM355_DEEPSLEEP);\r\n}\r\ndavinci_musb_source_power(musb, 0 , 1);\r\nif (musb->xceiv->otg->default_a) {\r\nint maxdelay = 30;\r\nu8 devctl, warn = 0;\r\ndo {\r\ndevctl = musb_readb(musb->mregs, MUSB_DEVCTL);\r\nif (!(devctl & MUSB_DEVCTL_VBUS))\r\nbreak;\r\nif ((devctl & MUSB_DEVCTL_VBUS) != warn) {\r\nwarn = devctl & MUSB_DEVCTL_VBUS;\r\ndev_dbg(musb->controller, "VBUS %d\n",\r\nwarn >> MUSB_DEVCTL_VBUS_SHIFT);\r\n}\r\nmsleep(1000);\r\nmaxdelay--;\r\n} while (maxdelay > 0);\r\nif (devctl & MUSB_DEVCTL_VBUS)\r\ndev_dbg(musb->controller, "VBUS off timeout (devctl %02x)\n", devctl);\r\n}\r\nphy_off();\r\nusb_put_phy(musb->xceiv);\r\nreturn 0;\r\n}\r\nstatic int davinci_probe(struct platform_device *pdev)\r\n{\r\nstruct resource musb_resources[3];\r\nstruct musb_hdrc_platform_data *pdata = dev_get_platdata(&pdev->dev);\r\nstruct platform_device *musb;\r\nstruct davinci_glue *glue;\r\nstruct platform_device_info pinfo;\r\nstruct clk *clk;\r\nint ret = -ENOMEM;\r\nglue = devm_kzalloc(&pdev->dev, sizeof(*glue), GFP_KERNEL);\r\nif (!glue)\r\ngoto err0;\r\nclk = devm_clk_get(&pdev->dev, "usb");\r\nif (IS_ERR(clk)) {\r\ndev_err(&pdev->dev, "failed to get clock\n");\r\nret = PTR_ERR(clk);\r\ngoto err0;\r\n}\r\nret = clk_enable(clk);\r\nif (ret) {\r\ndev_err(&pdev->dev, "failed to enable clock\n");\r\ngoto err0;\r\n}\r\nglue->dev = &pdev->dev;\r\nglue->clk = clk;\r\npdata->platform_ops = &davinci_ops;\r\nusb_phy_generic_register();\r\nplatform_set_drvdata(pdev, glue);\r\nmemset(musb_resources, 0x00, sizeof(*musb_resources) *\r\nARRAY_SIZE(musb_resources));\r\nmusb_resources[0].name = pdev->resource[0].name;\r\nmusb_resources[0].start = pdev->resource[0].start;\r\nmusb_resources[0].end = pdev->resource[0].end;\r\nmusb_resources[0].flags = pdev->resource[0].flags;\r\nmusb_resources[1].name = pdev->resource[1].name;\r\nmusb_resources[1].start = pdev->resource[1].start;\r\nmusb_resources[1].end = pdev->resource[1].end;\r\nmusb_resources[1].flags = pdev->resource[1].flags;\r\nmusb_resources[2].name = pdev->resource[2].name;\r\nmusb_resources[2].start = pdev->resource[2].start;\r\nmusb_resources[2].end = pdev->resource[2].end;\r\nmusb_resources[2].flags = pdev->resource[2].flags;\r\npinfo = davinci_dev_info;\r\npinfo.parent = &pdev->dev;\r\npinfo.res = musb_resources;\r\npinfo.num_res = ARRAY_SIZE(musb_resources);\r\npinfo.data = pdata;\r\npinfo.size_data = sizeof(*pdata);\r\nglue->musb = musb = platform_device_register_full(&pinfo);\r\nif (IS_ERR(musb)) {\r\nret = PTR_ERR(musb);\r\ndev_err(&pdev->dev, "failed to register musb device: %d\n", ret);\r\ngoto err1;\r\n}\r\nreturn 0;\r\nerr1:\r\nclk_disable(clk);\r\nerr0:\r\nreturn ret;\r\n}\r\nstatic int davinci_remove(struct platform_device *pdev)\r\n{\r\nstruct davinci_glue *glue = platform_get_drvdata(pdev);\r\nplatform_device_unregister(glue->musb);\r\nusb_phy_generic_unregister();\r\nclk_disable(glue->clk);\r\nreturn 0;\r\n}
