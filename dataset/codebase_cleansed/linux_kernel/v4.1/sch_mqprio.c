static void mqprio_destroy(struct Qdisc *sch)\r\n{\r\nstruct net_device *dev = qdisc_dev(sch);\r\nstruct mqprio_sched *priv = qdisc_priv(sch);\r\nunsigned int ntx;\r\nif (priv->qdiscs) {\r\nfor (ntx = 0;\r\nntx < dev->num_tx_queues && priv->qdiscs[ntx];\r\nntx++)\r\nqdisc_destroy(priv->qdiscs[ntx]);\r\nkfree(priv->qdiscs);\r\n}\r\nif (priv->hw_owned && dev->netdev_ops->ndo_setup_tc)\r\ndev->netdev_ops->ndo_setup_tc(dev, 0);\r\nelse\r\nnetdev_set_num_tc(dev, 0);\r\n}\r\nstatic int mqprio_parse_opt(struct net_device *dev, struct tc_mqprio_qopt *qopt)\r\n{\r\nint i, j;\r\nif (qopt->num_tc > TC_MAX_QUEUE)\r\nreturn -EINVAL;\r\nfor (i = 0; i < TC_BITMASK + 1; i++) {\r\nif (qopt->prio_tc_map[i] >= qopt->num_tc)\r\nreturn -EINVAL;\r\n}\r\nif (qopt->hw && !dev->netdev_ops->ndo_setup_tc)\r\nreturn -EINVAL;\r\nif (qopt->hw)\r\nreturn 0;\r\nfor (i = 0; i < qopt->num_tc; i++) {\r\nunsigned int last = qopt->offset[i] + qopt->count[i];\r\nif (qopt->offset[i] >= dev->real_num_tx_queues ||\r\n!qopt->count[i] ||\r\nlast > dev->real_num_tx_queues)\r\nreturn -EINVAL;\r\nfor (j = i + 1; j < qopt->num_tc; j++) {\r\nif (last > qopt->offset[j])\r\nreturn -EINVAL;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int mqprio_init(struct Qdisc *sch, struct nlattr *opt)\r\n{\r\nstruct net_device *dev = qdisc_dev(sch);\r\nstruct mqprio_sched *priv = qdisc_priv(sch);\r\nstruct netdev_queue *dev_queue;\r\nstruct Qdisc *qdisc;\r\nint i, err = -EOPNOTSUPP;\r\nstruct tc_mqprio_qopt *qopt = NULL;\r\nBUILD_BUG_ON(TC_MAX_QUEUE != TC_QOPT_MAX_QUEUE);\r\nBUILD_BUG_ON(TC_BITMASK != TC_QOPT_BITMASK);\r\nif (sch->parent != TC_H_ROOT)\r\nreturn -EOPNOTSUPP;\r\nif (!netif_is_multiqueue(dev))\r\nreturn -EOPNOTSUPP;\r\nif (!opt || nla_len(opt) < sizeof(*qopt))\r\nreturn -EINVAL;\r\nqopt = nla_data(opt);\r\nif (mqprio_parse_opt(dev, qopt))\r\nreturn -EINVAL;\r\npriv->qdiscs = kcalloc(dev->num_tx_queues, sizeof(priv->qdiscs[0]),\r\nGFP_KERNEL);\r\nif (priv->qdiscs == NULL) {\r\nerr = -ENOMEM;\r\ngoto err;\r\n}\r\nfor (i = 0; i < dev->num_tx_queues; i++) {\r\ndev_queue = netdev_get_tx_queue(dev, i);\r\nqdisc = qdisc_create_dflt(dev_queue, default_qdisc_ops,\r\nTC_H_MAKE(TC_H_MAJ(sch->handle),\r\nTC_H_MIN(i + 1)));\r\nif (qdisc == NULL) {\r\nerr = -ENOMEM;\r\ngoto err;\r\n}\r\npriv->qdiscs[i] = qdisc;\r\nqdisc->flags |= TCQ_F_ONETXQUEUE;\r\n}\r\nif (qopt->hw) {\r\npriv->hw_owned = 1;\r\nerr = dev->netdev_ops->ndo_setup_tc(dev, qopt->num_tc);\r\nif (err)\r\ngoto err;\r\n} else {\r\nnetdev_set_num_tc(dev, qopt->num_tc);\r\nfor (i = 0; i < qopt->num_tc; i++)\r\nnetdev_set_tc_queue(dev, i,\r\nqopt->count[i], qopt->offset[i]);\r\n}\r\nfor (i = 0; i < TC_BITMASK + 1; i++)\r\nnetdev_set_prio_tc_map(dev, i, qopt->prio_tc_map[i]);\r\nsch->flags |= TCQ_F_MQROOT;\r\nreturn 0;\r\nerr:\r\nmqprio_destroy(sch);\r\nreturn err;\r\n}\r\nstatic void mqprio_attach(struct Qdisc *sch)\r\n{\r\nstruct net_device *dev = qdisc_dev(sch);\r\nstruct mqprio_sched *priv = qdisc_priv(sch);\r\nstruct Qdisc *qdisc, *old;\r\nunsigned int ntx;\r\nfor (ntx = 0; ntx < dev->num_tx_queues; ntx++) {\r\nqdisc = priv->qdiscs[ntx];\r\nold = dev_graft_qdisc(qdisc->dev_queue, qdisc);\r\nif (old)\r\nqdisc_destroy(old);\r\nif (ntx < dev->real_num_tx_queues)\r\nqdisc_list_add(qdisc);\r\n}\r\nkfree(priv->qdiscs);\r\npriv->qdiscs = NULL;\r\n}\r\nstatic struct netdev_queue *mqprio_queue_get(struct Qdisc *sch,\r\nunsigned long cl)\r\n{\r\nstruct net_device *dev = qdisc_dev(sch);\r\nunsigned long ntx = cl - 1 - netdev_get_num_tc(dev);\r\nif (ntx >= dev->num_tx_queues)\r\nreturn NULL;\r\nreturn netdev_get_tx_queue(dev, ntx);\r\n}\r\nstatic int mqprio_graft(struct Qdisc *sch, unsigned long cl, struct Qdisc *new,\r\nstruct Qdisc **old)\r\n{\r\nstruct net_device *dev = qdisc_dev(sch);\r\nstruct netdev_queue *dev_queue = mqprio_queue_get(sch, cl);\r\nif (!dev_queue)\r\nreturn -EINVAL;\r\nif (dev->flags & IFF_UP)\r\ndev_deactivate(dev);\r\n*old = dev_graft_qdisc(dev_queue, new);\r\nif (new)\r\nnew->flags |= TCQ_F_ONETXQUEUE;\r\nif (dev->flags & IFF_UP)\r\ndev_activate(dev);\r\nreturn 0;\r\n}\r\nstatic int mqprio_dump(struct Qdisc *sch, struct sk_buff *skb)\r\n{\r\nstruct net_device *dev = qdisc_dev(sch);\r\nstruct mqprio_sched *priv = qdisc_priv(sch);\r\nunsigned char *b = skb_tail_pointer(skb);\r\nstruct tc_mqprio_qopt opt = { 0 };\r\nstruct Qdisc *qdisc;\r\nunsigned int i;\r\nsch->q.qlen = 0;\r\nmemset(&sch->bstats, 0, sizeof(sch->bstats));\r\nmemset(&sch->qstats, 0, sizeof(sch->qstats));\r\nfor (i = 0; i < dev->num_tx_queues; i++) {\r\nqdisc = rtnl_dereference(netdev_get_tx_queue(dev, i)->qdisc);\r\nspin_lock_bh(qdisc_lock(qdisc));\r\nsch->q.qlen += qdisc->q.qlen;\r\nsch->bstats.bytes += qdisc->bstats.bytes;\r\nsch->bstats.packets += qdisc->bstats.packets;\r\nsch->qstats.backlog += qdisc->qstats.backlog;\r\nsch->qstats.drops += qdisc->qstats.drops;\r\nsch->qstats.requeues += qdisc->qstats.requeues;\r\nsch->qstats.overlimits += qdisc->qstats.overlimits;\r\nspin_unlock_bh(qdisc_lock(qdisc));\r\n}\r\nopt.num_tc = netdev_get_num_tc(dev);\r\nmemcpy(opt.prio_tc_map, dev->prio_tc_map, sizeof(opt.prio_tc_map));\r\nopt.hw = priv->hw_owned;\r\nfor (i = 0; i < netdev_get_num_tc(dev); i++) {\r\nopt.count[i] = dev->tc_to_txq[i].count;\r\nopt.offset[i] = dev->tc_to_txq[i].offset;\r\n}\r\nif (nla_put(skb, TCA_OPTIONS, sizeof(opt), &opt))\r\ngoto nla_put_failure;\r\nreturn skb->len;\r\nnla_put_failure:\r\nnlmsg_trim(skb, b);\r\nreturn -1;\r\n}\r\nstatic struct Qdisc *mqprio_leaf(struct Qdisc *sch, unsigned long cl)\r\n{\r\nstruct netdev_queue *dev_queue = mqprio_queue_get(sch, cl);\r\nif (!dev_queue)\r\nreturn NULL;\r\nreturn dev_queue->qdisc_sleeping;\r\n}\r\nstatic unsigned long mqprio_get(struct Qdisc *sch, u32 classid)\r\n{\r\nstruct net_device *dev = qdisc_dev(sch);\r\nunsigned int ntx = TC_H_MIN(classid);\r\nif (ntx > dev->num_tx_queues + netdev_get_num_tc(dev))\r\nreturn 0;\r\nreturn ntx;\r\n}\r\nstatic void mqprio_put(struct Qdisc *sch, unsigned long cl)\r\n{\r\n}\r\nstatic int mqprio_dump_class(struct Qdisc *sch, unsigned long cl,\r\nstruct sk_buff *skb, struct tcmsg *tcm)\r\n{\r\nstruct net_device *dev = qdisc_dev(sch);\r\nif (cl <= netdev_get_num_tc(dev)) {\r\ntcm->tcm_parent = TC_H_ROOT;\r\ntcm->tcm_info = 0;\r\n} else {\r\nint i;\r\nstruct netdev_queue *dev_queue;\r\ndev_queue = mqprio_queue_get(sch, cl);\r\ntcm->tcm_parent = 0;\r\nfor (i = 0; i < netdev_get_num_tc(dev); i++) {\r\nstruct netdev_tc_txq tc = dev->tc_to_txq[i];\r\nint q_idx = cl - netdev_get_num_tc(dev);\r\nif (q_idx > tc.offset &&\r\nq_idx <= tc.offset + tc.count) {\r\ntcm->tcm_parent =\r\nTC_H_MAKE(TC_H_MAJ(sch->handle),\r\nTC_H_MIN(i + 1));\r\nbreak;\r\n}\r\n}\r\ntcm->tcm_info = dev_queue->qdisc_sleeping->handle;\r\n}\r\ntcm->tcm_handle |= TC_H_MIN(cl);\r\nreturn 0;\r\n}\r\nstatic int mqprio_dump_class_stats(struct Qdisc *sch, unsigned long cl,\r\nstruct gnet_dump *d)\r\n__releases(d->lock)\r\n__acquires(d->lock)\r\n{\r\nstruct net_device *dev = qdisc_dev(sch);\r\nif (cl <= netdev_get_num_tc(dev)) {\r\nint i;\r\n__u32 qlen = 0;\r\nstruct Qdisc *qdisc;\r\nstruct gnet_stats_queue qstats = {0};\r\nstruct gnet_stats_basic_packed bstats = {0};\r\nstruct netdev_tc_txq tc = dev->tc_to_txq[cl - 1];\r\nspin_unlock_bh(d->lock);\r\nfor (i = tc.offset; i < tc.offset + tc.count; i++) {\r\nstruct netdev_queue *q = netdev_get_tx_queue(dev, i);\r\nqdisc = rtnl_dereference(q->qdisc);\r\nspin_lock_bh(qdisc_lock(qdisc));\r\nqlen += qdisc->q.qlen;\r\nbstats.bytes += qdisc->bstats.bytes;\r\nbstats.packets += qdisc->bstats.packets;\r\nqstats.backlog += qdisc->qstats.backlog;\r\nqstats.drops += qdisc->qstats.drops;\r\nqstats.requeues += qdisc->qstats.requeues;\r\nqstats.overlimits += qdisc->qstats.overlimits;\r\nspin_unlock_bh(qdisc_lock(qdisc));\r\n}\r\nspin_lock_bh(d->lock);\r\nif (gnet_stats_copy_basic(d, NULL, &bstats) < 0 ||\r\ngnet_stats_copy_queue(d, NULL, &qstats, qlen) < 0)\r\nreturn -1;\r\n} else {\r\nstruct netdev_queue *dev_queue = mqprio_queue_get(sch, cl);\r\nsch = dev_queue->qdisc_sleeping;\r\nif (gnet_stats_copy_basic(d, NULL, &sch->bstats) < 0 ||\r\ngnet_stats_copy_queue(d, NULL,\r\n&sch->qstats, sch->q.qlen) < 0)\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic void mqprio_walk(struct Qdisc *sch, struct qdisc_walker *arg)\r\n{\r\nstruct net_device *dev = qdisc_dev(sch);\r\nunsigned long ntx;\r\nif (arg->stop)\r\nreturn;\r\narg->count = arg->skip;\r\nfor (ntx = arg->skip;\r\nntx < dev->num_tx_queues + netdev_get_num_tc(dev);\r\nntx++) {\r\nif (arg->fn(sch, ntx + 1, arg) < 0) {\r\narg->stop = 1;\r\nbreak;\r\n}\r\narg->count++;\r\n}\r\n}\r\nstatic int __init mqprio_module_init(void)\r\n{\r\nreturn register_qdisc(&mqprio_qdisc_ops);\r\n}\r\nstatic void __exit mqprio_module_exit(void)\r\n{\r\nunregister_qdisc(&mqprio_qdisc_ops);\r\n}
