ax25_dev *ax25_addr_ax25dev(ax25_address *addr)\r\n{\r\nax25_dev *ax25_dev, *res = NULL;\r\nspin_lock_bh(&ax25_dev_lock);\r\nfor (ax25_dev = ax25_dev_list; ax25_dev != NULL; ax25_dev = ax25_dev->next)\r\nif (ax25cmp(addr, (ax25_address *)ax25_dev->dev->dev_addr) == 0) {\r\nres = ax25_dev;\r\n}\r\nspin_unlock_bh(&ax25_dev_lock);\r\nreturn res;\r\n}\r\nvoid ax25_dev_device_up(struct net_device *dev)\r\n{\r\nax25_dev *ax25_dev;\r\nif ((ax25_dev = kzalloc(sizeof(*ax25_dev), GFP_ATOMIC)) == NULL) {\r\nprintk(KERN_ERR "AX.25: ax25_dev_device_up - out of memory\n");\r\nreturn;\r\n}\r\ndev->ax25_ptr = ax25_dev;\r\nax25_dev->dev = dev;\r\ndev_hold(dev);\r\nax25_dev->forward = NULL;\r\nax25_dev->values[AX25_VALUES_IPDEFMODE] = AX25_DEF_IPDEFMODE;\r\nax25_dev->values[AX25_VALUES_AXDEFMODE] = AX25_DEF_AXDEFMODE;\r\nax25_dev->values[AX25_VALUES_BACKOFF] = AX25_DEF_BACKOFF;\r\nax25_dev->values[AX25_VALUES_CONMODE] = AX25_DEF_CONMODE;\r\nax25_dev->values[AX25_VALUES_WINDOW] = AX25_DEF_WINDOW;\r\nax25_dev->values[AX25_VALUES_EWINDOW] = AX25_DEF_EWINDOW;\r\nax25_dev->values[AX25_VALUES_T1] = AX25_DEF_T1;\r\nax25_dev->values[AX25_VALUES_T2] = AX25_DEF_T2;\r\nax25_dev->values[AX25_VALUES_T3] = AX25_DEF_T3;\r\nax25_dev->values[AX25_VALUES_IDLE] = AX25_DEF_IDLE;\r\nax25_dev->values[AX25_VALUES_N2] = AX25_DEF_N2;\r\nax25_dev->values[AX25_VALUES_PACLEN] = AX25_DEF_PACLEN;\r\nax25_dev->values[AX25_VALUES_PROTOCOL] = AX25_DEF_PROTOCOL;\r\nax25_dev->values[AX25_VALUES_DS_TIMEOUT]= AX25_DEF_DS_TIMEOUT;\r\n#if defined(CONFIG_AX25_DAMA_SLAVE) || defined(CONFIG_AX25_DAMA_MASTER)\r\nax25_ds_setup_timer(ax25_dev);\r\n#endif\r\nspin_lock_bh(&ax25_dev_lock);\r\nax25_dev->next = ax25_dev_list;\r\nax25_dev_list = ax25_dev;\r\nspin_unlock_bh(&ax25_dev_lock);\r\nax25_register_dev_sysctl(ax25_dev);\r\n}\r\nvoid ax25_dev_device_down(struct net_device *dev)\r\n{\r\nax25_dev *s, *ax25_dev;\r\nif ((ax25_dev = ax25_dev_ax25dev(dev)) == NULL)\r\nreturn;\r\nax25_unregister_dev_sysctl(ax25_dev);\r\nspin_lock_bh(&ax25_dev_lock);\r\n#ifdef CONFIG_AX25_DAMA_SLAVE\r\nax25_ds_del_timer(ax25_dev);\r\n#endif\r\nfor (s = ax25_dev_list; s != NULL; s = s->next)\r\nif (s->forward == dev)\r\ns->forward = NULL;\r\nif ((s = ax25_dev_list) == ax25_dev) {\r\nax25_dev_list = s->next;\r\nspin_unlock_bh(&ax25_dev_lock);\r\ndev_put(dev);\r\nkfree(ax25_dev);\r\nreturn;\r\n}\r\nwhile (s != NULL && s->next != NULL) {\r\nif (s->next == ax25_dev) {\r\ns->next = ax25_dev->next;\r\nspin_unlock_bh(&ax25_dev_lock);\r\ndev_put(dev);\r\nkfree(ax25_dev);\r\nreturn;\r\n}\r\ns = s->next;\r\n}\r\nspin_unlock_bh(&ax25_dev_lock);\r\ndev->ax25_ptr = NULL;\r\n}\r\nint ax25_fwd_ioctl(unsigned int cmd, struct ax25_fwd_struct *fwd)\r\n{\r\nax25_dev *ax25_dev, *fwd_dev;\r\nif ((ax25_dev = ax25_addr_ax25dev(&fwd->port_from)) == NULL)\r\nreturn -EINVAL;\r\nswitch (cmd) {\r\ncase SIOCAX25ADDFWD:\r\nif ((fwd_dev = ax25_addr_ax25dev(&fwd->port_to)) == NULL)\r\nreturn -EINVAL;\r\nif (ax25_dev->forward != NULL)\r\nreturn -EINVAL;\r\nax25_dev->forward = fwd_dev->dev;\r\nbreak;\r\ncase SIOCAX25DELFWD:\r\nif (ax25_dev->forward == NULL)\r\nreturn -EINVAL;\r\nax25_dev->forward = NULL;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstruct net_device *ax25_fwd_dev(struct net_device *dev)\r\n{\r\nax25_dev *ax25_dev;\r\nif ((ax25_dev = ax25_dev_ax25dev(dev)) == NULL)\r\nreturn dev;\r\nif (ax25_dev->forward == NULL)\r\nreturn dev;\r\nreturn ax25_dev->forward;\r\n}\r\nvoid __exit ax25_dev_free(void)\r\n{\r\nax25_dev *s, *ax25_dev;\r\nspin_lock_bh(&ax25_dev_lock);\r\nax25_dev = ax25_dev_list;\r\nwhile (ax25_dev != NULL) {\r\ns = ax25_dev;\r\ndev_put(ax25_dev->dev);\r\nax25_dev = ax25_dev->next;\r\nkfree(s);\r\n}\r\nax25_dev_list = NULL;\r\nspin_unlock_bh(&ax25_dev_lock);\r\n}
