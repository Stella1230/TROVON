static inline void\r\nnoritake_update_irq_hw(int irq, int mask)\r\n{\r\nint port = 0x54a;\r\nif (irq >= 32) {\r\nmask >>= 16;\r\nport = 0x54c;\r\n}\r\noutw(mask, port);\r\n}\r\nstatic void\r\nnoritake_enable_irq(struct irq_data *d)\r\n{\r\nnoritake_update_irq_hw(d->irq, cached_irq_mask |= 1 << (d->irq - 16));\r\n}\r\nstatic void\r\nnoritake_disable_irq(struct irq_data *d)\r\n{\r\nnoritake_update_irq_hw(d->irq, cached_irq_mask &= ~(1 << (d->irq - 16)));\r\n}\r\nstatic void\r\nnoritake_device_interrupt(unsigned long vector)\r\n{\r\nunsigned long pld;\r\nunsigned int i;\r\npld = (((unsigned long) inw(0x54c) << 32)\r\n| ((unsigned long) inw(0x54a) << 16)\r\n| ((unsigned long) inb(0xa0) << 8)\r\n| inb(0x20));\r\nwhile (pld) {\r\ni = ffz(~pld);\r\npld &= pld - 1;\r\nif (i < 16) {\r\nisa_device_interrupt(vector);\r\n} else {\r\nhandle_irq(i);\r\n}\r\n}\r\n}\r\nstatic void\r\nnoritake_srm_device_interrupt(unsigned long vector)\r\n{\r\nint irq;\r\nirq = (vector - 0x800) >> 4;\r\nif (irq >= 16)\r\nirq = irq + 1;\r\nhandle_irq(irq);\r\n}\r\nstatic void __init\r\nnoritake_init_irq(void)\r\n{\r\nlong i;\r\nif (alpha_using_srm)\r\nalpha_mv.device_interrupt = noritake_srm_device_interrupt;\r\noutw(0, 0x54a);\r\noutw(0, 0x54c);\r\nfor (i = 16; i < 48; ++i) {\r\nirq_set_chip_and_handler(i, &noritake_irq_type,\r\nhandle_level_irq);\r\nirq_set_status_flags(i, IRQ_LEVEL);\r\n}\r\ninit_i8259a_irqs();\r\ncommon_init_isa_dma();\r\n}\r\nstatic int __init\r\nnoritake_map_irq(const struct pci_dev *dev, u8 slot, u8 pin)\r\n{\r\nstatic char irq_tab[15][5] __initdata = {\r\n{ 16+1, 16+1, 16+1, 16+1, 16+1},\r\n{ -1, -1, -1, -1, -1},\r\n{ -1, -1, -1, -1, -1},\r\n{ -1, -1, -1, -1, -1},\r\n{ -1, -1, -1, -1, -1},\r\n{ -1, -1, -1, -1, -1},\r\n{ 16+2, 16+2, 16+3, 32+2, 32+3},\r\n{ 16+4, 16+4, 16+5, 32+4, 32+5},\r\n{ 16+6, 16+6, 16+7, 32+6, 32+7},\r\n{ 16+8, 16+8, 16+9, 32+8, 32+9},\r\n{ 16+1, 16+1, 16+1, 16+1, 16+1},\r\n{ 16+8, 16+8, 16+9, 32+8, 32+9},\r\n{16+10, 16+10, 16+11, 32+10, 32+11},\r\n{16+12, 16+12, 16+13, 32+12, 32+13},\r\n{16+14, 16+14, 16+15, 32+14, 32+15},\r\n};\r\nconst long min_idsel = 5, max_idsel = 19, irqs_per_slot = 5;\r\nreturn COMMON_TABLE_LOOKUP;\r\n}\r\nstatic u8 __init\r\nnoritake_swizzle(struct pci_dev *dev, u8 *pinp)\r\n{\r\nint slot, pin = *pinp;\r\nif (dev->bus->number == 0) {\r\nslot = PCI_SLOT(dev->devfn);\r\n}\r\nelse if (PCI_SLOT(dev->bus->self->devfn) == 8) {\r\nslot = PCI_SLOT(dev->devfn) + 15;\r\n}\r\nelse\r\n{\r\ndo {\r\nif (PCI_SLOT(dev->bus->self->devfn) == 8) {\r\nslot = PCI_SLOT(dev->devfn) + 15;\r\nbreak;\r\n}\r\npin = pci_swizzle_interrupt_pin(dev, pin);\r\ndev = dev->bus->self;\r\nslot = PCI_SLOT(dev->devfn);\r\n} while (dev->bus->self);\r\n}\r\n*pinp = pin;\r\nreturn slot;\r\n}\r\nstatic void\r\nnoritake_apecs_machine_check(unsigned long vector, unsigned long la_ptr)\r\n{\r\n#define MCHK_NO_DEVSEL 0x205U\r\n#define MCHK_NO_TABT 0x204U\r\nstruct el_common *mchk_header;\r\nunsigned int code;\r\nmchk_header = (struct el_common *)la_ptr;\r\nmb();\r\nmb();\r\ndraina();\r\napecs_pci_clr_err();\r\nwrmces(0x7);\r\nmb();\r\ncode = mchk_header->code;\r\nprocess_mcheck_info(vector, la_ptr, "NORITAKE APECS",\r\n(mcheck_expected(0)\r\n&& (code == MCHK_NO_DEVSEL\r\n|| code == MCHK_NO_TABT)));\r\n}
