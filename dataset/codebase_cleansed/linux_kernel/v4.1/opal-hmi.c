static void print_hmi_event_info(struct OpalHMIEvent *hmi_evt)\r\n{\r\nconst char *level, *sevstr, *error_info;\r\nstatic const char *hmi_error_types[] = {\r\n"Malfunction Alert",\r\n"Processor Recovery done",\r\n"Processor recovery occurred again",\r\n"Processor recovery occurred for masked error",\r\n"Timer facility experienced an error",\r\n"TFMR SPR is corrupted",\r\n"UPS (Uniterrupted Power System) Overflow indication",\r\n"An XSCOM operation failure",\r\n"An XSCOM operation completed",\r\n"SCOM has set a reserved FIR bit to cause recovery",\r\n"Debug trigger has set a reserved FIR bit to cause recovery",\r\n"A hypervisor resource error occurred"\r\n};\r\nif (hmi_evt->version < OpalHMIEvt_V1) {\r\npr_err("HMI Interrupt, Unknown event version %d !\n",\r\nhmi_evt->version);\r\nreturn;\r\n}\r\nswitch (hmi_evt->severity) {\r\ncase OpalHMI_SEV_NO_ERROR:\r\nlevel = KERN_INFO;\r\nsevstr = "Harmless";\r\nbreak;\r\ncase OpalHMI_SEV_WARNING:\r\nlevel = KERN_WARNING;\r\nsevstr = "";\r\nbreak;\r\ncase OpalHMI_SEV_ERROR_SYNC:\r\nlevel = KERN_ERR;\r\nsevstr = "Severe";\r\nbreak;\r\ncase OpalHMI_SEV_FATAL:\r\ndefault:\r\nlevel = KERN_ERR;\r\nsevstr = "Fatal";\r\nbreak;\r\n}\r\nprintk("%s%s Hypervisor Maintenance interrupt [%s]\n",\r\nlevel, sevstr,\r\nhmi_evt->disposition == OpalHMI_DISPOSITION_RECOVERED ?\r\n"Recovered" : "Not recovered");\r\nerror_info = hmi_evt->type < ARRAY_SIZE(hmi_error_types) ?\r\nhmi_error_types[hmi_evt->type]\r\n: "Unknown";\r\nprintk("%s Error detail: %s\n", level, error_info);\r\nprintk("%s HMER: %016llx\n", level, be64_to_cpu(hmi_evt->hmer));\r\nif ((hmi_evt->type == OpalHMI_ERROR_TFAC) ||\r\n(hmi_evt->type == OpalHMI_ERROR_TFMR_PARITY))\r\nprintk("%s TFMR: %016llx\n", level,\r\nbe64_to_cpu(hmi_evt->tfmr));\r\n}\r\nstatic void hmi_event_handler(struct work_struct *work)\r\n{\r\nunsigned long flags;\r\nstruct OpalHMIEvent *hmi_evt;\r\nstruct OpalHmiEvtNode *msg_node;\r\nuint8_t disposition;\r\nspin_lock_irqsave(&opal_hmi_evt_lock, flags);\r\nwhile (!list_empty(&opal_hmi_evt_list)) {\r\nmsg_node = list_entry(opal_hmi_evt_list.next,\r\nstruct OpalHmiEvtNode, list);\r\nlist_del(&msg_node->list);\r\nspin_unlock_irqrestore(&opal_hmi_evt_lock, flags);\r\nhmi_evt = (struct OpalHMIEvent *) &msg_node->hmi_evt;\r\nprint_hmi_event_info(hmi_evt);\r\ndisposition = hmi_evt->disposition;\r\nkfree(msg_node);\r\nif (disposition != OpalHMI_DISPOSITION_RECOVERED)\r\npanic("Unrecoverable HMI exception");\r\nspin_lock_irqsave(&opal_hmi_evt_lock, flags);\r\n}\r\nspin_unlock_irqrestore(&opal_hmi_evt_lock, flags);\r\n}\r\nstatic int opal_handle_hmi_event(struct notifier_block *nb,\r\nunsigned long msg_type, void *msg)\r\n{\r\nunsigned long flags;\r\nstruct OpalHMIEvent *hmi_evt;\r\nstruct opal_msg *hmi_msg = msg;\r\nstruct OpalHmiEvtNode *msg_node;\r\nif (msg_type != OPAL_MSG_HMI_EVT)\r\nreturn 0;\r\nhmi_evt = (struct OpalHMIEvent *)&hmi_msg->params[0];\r\nmsg_node = kzalloc(sizeof(*msg_node), GFP_ATOMIC);\r\nif (!msg_node) {\r\npr_err("HMI: out of memory, Opal message event not handled\n");\r\nreturn -ENOMEM;\r\n}\r\nmemcpy(&msg_node->hmi_evt, hmi_evt, sizeof(struct OpalHMIEvent));\r\nspin_lock_irqsave(&opal_hmi_evt_lock, flags);\r\nlist_add(&msg_node->list, &opal_hmi_evt_list);\r\nspin_unlock_irqrestore(&opal_hmi_evt_lock, flags);\r\nschedule_work(&hmi_event_work);\r\nreturn 0;\r\n}\r\nstatic int __init opal_hmi_handler_init(void)\r\n{\r\nint ret;\r\nif (!opal_hmi_handler_nb_init) {\r\nret = opal_message_notifier_register(\r\nOPAL_MSG_HMI_EVT, &opal_hmi_handler_nb);\r\nif (ret) {\r\npr_err("%s: Can't register OPAL event notifier (%d)\n",\r\n__func__, ret);\r\nreturn ret;\r\n}\r\nopal_hmi_handler_nb_init = 1;\r\n}\r\nreturn 0;\r\n}
