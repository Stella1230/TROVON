static void rtsx_usb_sg_timed_out(unsigned long data)\r\n{\r\nstruct rtsx_ucr *ucr = (struct rtsx_ucr *)data;\r\ndev_dbg(&ucr->pusb_intf->dev, "%s: sg transfer timed out", __func__);\r\nusb_sg_cancel(&ucr->current_sg);\r\nucr->current_sg.status = -ETIMEDOUT;\r\n}\r\nstatic int rtsx_usb_bulk_transfer_sglist(struct rtsx_ucr *ucr,\r\nunsigned int pipe, struct scatterlist *sg, int num_sg,\r\nunsigned int length, unsigned int *act_len, int timeout)\r\n{\r\nint ret;\r\ndev_dbg(&ucr->pusb_intf->dev, "%s: xfer %u bytes, %d entries\n",\r\n__func__, length, num_sg);\r\nret = usb_sg_init(&ucr->current_sg, ucr->pusb_dev, pipe, 0,\r\nsg, num_sg, length, GFP_NOIO);\r\nif (ret)\r\nreturn ret;\r\nucr->sg_timer.expires = jiffies + msecs_to_jiffies(timeout);\r\nadd_timer(&ucr->sg_timer);\r\nusb_sg_wait(&ucr->current_sg);\r\ndel_timer_sync(&ucr->sg_timer);\r\nif (act_len)\r\n*act_len = ucr->current_sg.bytes;\r\nreturn ucr->current_sg.status;\r\n}\r\nint rtsx_usb_transfer_data(struct rtsx_ucr *ucr, unsigned int pipe,\r\nvoid *buf, unsigned int len, int num_sg,\r\nunsigned int *act_len, int timeout)\r\n{\r\nif (timeout < 600)\r\ntimeout = 600;\r\nif (num_sg)\r\nreturn rtsx_usb_bulk_transfer_sglist(ucr, pipe,\r\n(struct scatterlist *)buf, num_sg, len, act_len,\r\ntimeout);\r\nelse\r\nreturn usb_bulk_msg(ucr->pusb_dev, pipe, buf, len, act_len,\r\ntimeout);\r\n}\r\nstatic inline void rtsx_usb_seq_cmd_hdr(struct rtsx_ucr *ucr,\r\nu16 addr, u16 len, u8 seq_type)\r\n{\r\nrtsx_usb_cmd_hdr_tag(ucr);\r\nucr->cmd_buf[PACKET_TYPE] = seq_type;\r\nucr->cmd_buf[5] = (u8)(len >> 8);\r\nucr->cmd_buf[6] = (u8)len;\r\nucr->cmd_buf[8] = (u8)(addr >> 8);\r\nucr->cmd_buf[9] = (u8)addr;\r\nif (seq_type == SEQ_WRITE)\r\nucr->cmd_buf[STAGE_FLAG] = 0;\r\nelse\r\nucr->cmd_buf[STAGE_FLAG] = STAGE_R;\r\n}\r\nstatic int rtsx_usb_seq_write_register(struct rtsx_ucr *ucr,\r\nu16 addr, u16 len, u8 *data)\r\n{\r\nu16 cmd_len = ALIGN(SEQ_WRITE_DATA_OFFSET + len, 4);\r\nif (!data)\r\nreturn -EINVAL;\r\nif (cmd_len > IOBUF_SIZE)\r\nreturn -EINVAL;\r\nrtsx_usb_seq_cmd_hdr(ucr, addr, len, SEQ_WRITE);\r\nmemcpy(ucr->cmd_buf + SEQ_WRITE_DATA_OFFSET, data, len);\r\nreturn rtsx_usb_transfer_data(ucr,\r\nusb_sndbulkpipe(ucr->pusb_dev, EP_BULK_OUT),\r\nucr->cmd_buf, cmd_len, 0, NULL, 100);\r\n}\r\nstatic int rtsx_usb_seq_read_register(struct rtsx_ucr *ucr,\r\nu16 addr, u16 len, u8 *data)\r\n{\r\nint i, ret;\r\nu16 rsp_len = round_down(len, 4);\r\nu16 res_len = len - rsp_len;\r\nif (!data)\r\nreturn -EINVAL;\r\nif (rsp_len) {\r\nrtsx_usb_seq_cmd_hdr(ucr, addr, len, SEQ_READ);\r\nret = rtsx_usb_transfer_data(ucr,\r\nusb_sndbulkpipe(ucr->pusb_dev, EP_BULK_OUT),\r\nucr->cmd_buf, 12, 0, NULL, 100);\r\nif (ret)\r\nreturn ret;\r\nret = rtsx_usb_transfer_data(ucr,\r\nusb_rcvbulkpipe(ucr->pusb_dev, EP_BULK_IN),\r\ndata, rsp_len, 0, NULL, 100);\r\nif (ret)\r\nreturn ret;\r\n}\r\nfor (i = 0; i < res_len; i++) {\r\nret = rtsx_usb_read_register(ucr, addr + rsp_len + i,\r\ndata + rsp_len + i);\r\nif (ret)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nint rtsx_usb_read_ppbuf(struct rtsx_ucr *ucr, u8 *buf, int buf_len)\r\n{\r\nreturn rtsx_usb_seq_read_register(ucr, PPBUF_BASE2, (u16)buf_len, buf);\r\n}\r\nint rtsx_usb_write_ppbuf(struct rtsx_ucr *ucr, u8 *buf, int buf_len)\r\n{\r\nreturn rtsx_usb_seq_write_register(ucr, PPBUF_BASE2, (u16)buf_len, buf);\r\n}\r\nint rtsx_usb_ep0_write_register(struct rtsx_ucr *ucr, u16 addr,\r\nu8 mask, u8 data)\r\n{\r\nu16 value, index;\r\naddr |= EP0_WRITE_REG_CMD << EP0_OP_SHIFT;\r\nvalue = swab16(addr);\r\nindex = mask | data << 8;\r\nreturn usb_control_msg(ucr->pusb_dev,\r\nusb_sndctrlpipe(ucr->pusb_dev, 0), RTSX_USB_REQ_REG_OP,\r\nUSB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\r\nvalue, index, NULL, 0, 100);\r\n}\r\nint rtsx_usb_ep0_read_register(struct rtsx_ucr *ucr, u16 addr, u8 *data)\r\n{\r\nu16 value;\r\nu8 *buf;\r\nint ret;\r\nif (!data)\r\nreturn -EINVAL;\r\nbuf = kzalloc(sizeof(u8), GFP_KERNEL);\r\nif (!buf)\r\nreturn -ENOMEM;\r\naddr |= EP0_READ_REG_CMD << EP0_OP_SHIFT;\r\nvalue = swab16(addr);\r\nret = usb_control_msg(ucr->pusb_dev,\r\nusb_rcvctrlpipe(ucr->pusb_dev, 0), RTSX_USB_REQ_REG_OP,\r\nUSB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\r\nvalue, 0, buf, 1, 100);\r\n*data = *buf;\r\nkfree(buf);\r\nreturn ret;\r\n}\r\nvoid rtsx_usb_add_cmd(struct rtsx_ucr *ucr, u8 cmd_type, u16 reg_addr,\r\nu8 mask, u8 data)\r\n{\r\nint i;\r\nif (ucr->cmd_idx < (IOBUF_SIZE - CMD_OFFSET) / 4) {\r\ni = CMD_OFFSET + ucr->cmd_idx * 4;\r\nucr->cmd_buf[i++] = ((cmd_type & 0x03) << 6) |\r\n(u8)((reg_addr >> 8) & 0x3F);\r\nucr->cmd_buf[i++] = (u8)reg_addr;\r\nucr->cmd_buf[i++] = mask;\r\nucr->cmd_buf[i++] = data;\r\nucr->cmd_idx++;\r\n}\r\n}\r\nint rtsx_usb_send_cmd(struct rtsx_ucr *ucr, u8 flag, int timeout)\r\n{\r\nint ret;\r\nucr->cmd_buf[CNT_H] = (u8)(ucr->cmd_idx >> 8);\r\nucr->cmd_buf[CNT_L] = (u8)(ucr->cmd_idx);\r\nucr->cmd_buf[STAGE_FLAG] = flag;\r\nret = rtsx_usb_transfer_data(ucr,\r\nusb_sndbulkpipe(ucr->pusb_dev, EP_BULK_OUT),\r\nucr->cmd_buf, ucr->cmd_idx * 4 + CMD_OFFSET,\r\n0, NULL, timeout);\r\nif (ret) {\r\nrtsx_usb_clear_fsm_err(ucr);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nint rtsx_usb_get_rsp(struct rtsx_ucr *ucr, int rsp_len, int timeout)\r\n{\r\nif (rsp_len <= 0)\r\nreturn -EINVAL;\r\nrsp_len = ALIGN(rsp_len, 4);\r\nreturn rtsx_usb_transfer_data(ucr,\r\nusb_rcvbulkpipe(ucr->pusb_dev, EP_BULK_IN),\r\nucr->rsp_buf, rsp_len, 0, NULL, timeout);\r\n}\r\nstatic int rtsx_usb_get_status_with_bulk(struct rtsx_ucr *ucr, u16 *status)\r\n{\r\nint ret;\r\nrtsx_usb_init_cmd(ucr);\r\nrtsx_usb_add_cmd(ucr, READ_REG_CMD, CARD_EXIST, 0x00, 0x00);\r\nrtsx_usb_add_cmd(ucr, READ_REG_CMD, OCPSTAT, 0x00, 0x00);\r\nret = rtsx_usb_send_cmd(ucr, MODE_CR, 100);\r\nif (ret)\r\nreturn ret;\r\nret = rtsx_usb_get_rsp(ucr, 2, 100);\r\nif (ret)\r\nreturn ret;\r\n*status = ((ucr->rsp_buf[0] >> 2) & 0x0f) |\r\n((ucr->rsp_buf[1] & 0x03) << 4);\r\nreturn 0;\r\n}\r\nint rtsx_usb_get_card_status(struct rtsx_ucr *ucr, u16 *status)\r\n{\r\nint ret;\r\nu16 *buf;\r\nif (!status)\r\nreturn -EINVAL;\r\nif (polling_pipe == 0) {\r\nbuf = kzalloc(sizeof(u16), GFP_KERNEL);\r\nif (!buf)\r\nreturn -ENOMEM;\r\nret = usb_control_msg(ucr->pusb_dev,\r\nusb_rcvctrlpipe(ucr->pusb_dev, 0),\r\nRTSX_USB_REQ_POLL,\r\nUSB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\r\n0, 0, buf, 2, 100);\r\n*status = *buf;\r\nkfree(buf);\r\n} else {\r\nret = rtsx_usb_get_status_with_bulk(ucr, status);\r\n}\r\nif (ret < 0)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nstatic int rtsx_usb_write_phy_register(struct rtsx_ucr *ucr, u8 addr, u8 val)\r\n{\r\ndev_dbg(&ucr->pusb_intf->dev, "Write 0x%x to phy register 0x%x\n",\r\nval, addr);\r\nrtsx_usb_init_cmd(ucr);\r\nrtsx_usb_add_cmd(ucr, WRITE_REG_CMD, HS_VSTAIN, 0xFF, val);\r\nrtsx_usb_add_cmd(ucr, WRITE_REG_CMD, HS_VCONTROL, 0xFF, addr & 0x0F);\r\nrtsx_usb_add_cmd(ucr, WRITE_REG_CMD, HS_VLOADM, 0xFF, 0x00);\r\nrtsx_usb_add_cmd(ucr, WRITE_REG_CMD, HS_VLOADM, 0xFF, 0x00);\r\nrtsx_usb_add_cmd(ucr, WRITE_REG_CMD, HS_VLOADM, 0xFF, 0x01);\r\nrtsx_usb_add_cmd(ucr, WRITE_REG_CMD, HS_VCONTROL,\r\n0xFF, (addr >> 4) & 0x0F);\r\nrtsx_usb_add_cmd(ucr, WRITE_REG_CMD, HS_VLOADM, 0xFF, 0x00);\r\nrtsx_usb_add_cmd(ucr, WRITE_REG_CMD, HS_VLOADM, 0xFF, 0x00);\r\nrtsx_usb_add_cmd(ucr, WRITE_REG_CMD, HS_VLOADM, 0xFF, 0x01);\r\nreturn rtsx_usb_send_cmd(ucr, MODE_C, 100);\r\n}\r\nint rtsx_usb_write_register(struct rtsx_ucr *ucr, u16 addr, u8 mask, u8 data)\r\n{\r\nrtsx_usb_init_cmd(ucr);\r\nrtsx_usb_add_cmd(ucr, WRITE_REG_CMD, addr, mask, data);\r\nreturn rtsx_usb_send_cmd(ucr, MODE_C, 100);\r\n}\r\nint rtsx_usb_read_register(struct rtsx_ucr *ucr, u16 addr, u8 *data)\r\n{\r\nint ret;\r\nif (data != NULL)\r\n*data = 0;\r\nrtsx_usb_init_cmd(ucr);\r\nrtsx_usb_add_cmd(ucr, READ_REG_CMD, addr, 0, 0);\r\nret = rtsx_usb_send_cmd(ucr, MODE_CR, 100);\r\nif (ret)\r\nreturn ret;\r\nret = rtsx_usb_get_rsp(ucr, 1, 100);\r\nif (ret)\r\nreturn ret;\r\nif (data != NULL)\r\n*data = ucr->rsp_buf[0];\r\nreturn 0;\r\n}\r\nstatic inline u8 double_ssc_depth(u8 depth)\r\n{\r\nreturn (depth > 1) ? (depth - 1) : depth;\r\n}\r\nstatic u8 revise_ssc_depth(u8 ssc_depth, u8 div)\r\n{\r\nif (div > CLK_DIV_1) {\r\nif (ssc_depth > div - 1)\r\nssc_depth -= (div - 1);\r\nelse\r\nssc_depth = SSC_DEPTH_2M;\r\n}\r\nreturn ssc_depth;\r\n}\r\nint rtsx_usb_switch_clock(struct rtsx_ucr *ucr, unsigned int card_clock,\r\nu8 ssc_depth, bool initial_mode, bool double_clk, bool vpclk)\r\n{\r\nint ret;\r\nu8 n, clk_divider, mcu_cnt, div;\r\nif (!card_clock) {\r\nucr->cur_clk = 0;\r\nreturn 0;\r\n}\r\nif (initial_mode) {\r\nclk_divider = SD_CLK_DIVIDE_128;\r\ncard_clock = 30000000;\r\n} else {\r\nclk_divider = SD_CLK_DIVIDE_0;\r\n}\r\nret = rtsx_usb_write_register(ucr, SD_CFG1,\r\nSD_CLK_DIVIDE_MASK, clk_divider);\r\nif (ret < 0)\r\nreturn ret;\r\ncard_clock /= 1000000;\r\ndev_dbg(&ucr->pusb_intf->dev,\r\n"Switch card clock to %dMHz\n", card_clock);\r\nif (!initial_mode && double_clk)\r\ncard_clock *= 2;\r\ndev_dbg(&ucr->pusb_intf->dev,\r\n"Internal SSC clock: %dMHz (cur_clk = %d)\n",\r\ncard_clock, ucr->cur_clk);\r\nif (card_clock == ucr->cur_clk)\r\nreturn 0;\r\nn = card_clock - 2;\r\nif ((card_clock <= 2) || (n > MAX_DIV_N))\r\nreturn -EINVAL;\r\nmcu_cnt = 60/card_clock + 3;\r\nif (mcu_cnt > 15)\r\nmcu_cnt = 15;\r\ndiv = CLK_DIV_1;\r\nwhile (n < MIN_DIV_N && div < CLK_DIV_4) {\r\nn = (n + 2) * 2 - 2;\r\ndiv++;\r\n}\r\ndev_dbg(&ucr->pusb_intf->dev, "n = %d, div = %d\n", n, div);\r\nif (double_clk)\r\nssc_depth = double_ssc_depth(ssc_depth);\r\nssc_depth = revise_ssc_depth(ssc_depth, div);\r\ndev_dbg(&ucr->pusb_intf->dev, "ssc_depth = %d\n", ssc_depth);\r\nrtsx_usb_init_cmd(ucr);\r\nrtsx_usb_add_cmd(ucr, WRITE_REG_CMD, CLK_DIV, CLK_CHANGE, CLK_CHANGE);\r\nrtsx_usb_add_cmd(ucr, WRITE_REG_CMD, CLK_DIV,\r\n0x3F, (div << 4) | mcu_cnt);\r\nrtsx_usb_add_cmd(ucr, WRITE_REG_CMD, SSC_CTL1, SSC_RSTB, 0);\r\nrtsx_usb_add_cmd(ucr, WRITE_REG_CMD, SSC_CTL2,\r\nSSC_DEPTH_MASK, ssc_depth);\r\nrtsx_usb_add_cmd(ucr, WRITE_REG_CMD, SSC_DIV_N_0, 0xFF, n);\r\nrtsx_usb_add_cmd(ucr, WRITE_REG_CMD, SSC_CTL1, SSC_RSTB, SSC_RSTB);\r\nif (vpclk) {\r\nrtsx_usb_add_cmd(ucr, WRITE_REG_CMD, SD_VPCLK0_CTL,\r\nPHASE_NOT_RESET, 0);\r\nrtsx_usb_add_cmd(ucr, WRITE_REG_CMD, SD_VPCLK0_CTL,\r\nPHASE_NOT_RESET, PHASE_NOT_RESET);\r\n}\r\nret = rtsx_usb_send_cmd(ucr, MODE_C, 2000);\r\nif (ret < 0)\r\nreturn ret;\r\nret = rtsx_usb_write_register(ucr, SSC_CTL1, 0xff,\r\nSSC_RSTB | SSC_8X_EN | SSC_SEL_4M);\r\nif (ret < 0)\r\nreturn ret;\r\nusleep_range(100, 1000);\r\nret = rtsx_usb_write_register(ucr, CLK_DIV, CLK_CHANGE, 0);\r\nif (ret < 0)\r\nreturn ret;\r\nucr->cur_clk = card_clock;\r\nreturn 0;\r\n}\r\nint rtsx_usb_card_exclusive_check(struct rtsx_ucr *ucr, int card)\r\n{\r\nint ret;\r\nu16 val;\r\nu16 cd_mask[] = {\r\n[RTSX_USB_SD_CARD] = (CD_MASK & ~SD_CD),\r\n[RTSX_USB_MS_CARD] = (CD_MASK & ~MS_CD)\r\n};\r\nret = rtsx_usb_get_card_status(ucr, &val);\r\nif (ret)\r\nreturn 0;\r\nif (val & cd_mask[card])\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nstatic int rtsx_usb_reset_chip(struct rtsx_ucr *ucr)\r\n{\r\nint ret;\r\nu8 val;\r\nrtsx_usb_init_cmd(ucr);\r\nif (CHECK_PKG(ucr, LQFP48)) {\r\nrtsx_usb_add_cmd(ucr, WRITE_REG_CMD, CARD_PWR_CTL,\r\nLDO3318_PWR_MASK, LDO_SUSPEND);\r\nrtsx_usb_add_cmd(ucr, WRITE_REG_CMD, CARD_PWR_CTL,\r\nFORCE_LDO_POWERB, FORCE_LDO_POWERB);\r\nrtsx_usb_add_cmd(ucr, WRITE_REG_CMD, CARD_PULL_CTL1,\r\n0x30, 0x10);\r\nrtsx_usb_add_cmd(ucr, WRITE_REG_CMD, CARD_PULL_CTL5,\r\n0x03, 0x01);\r\nrtsx_usb_add_cmd(ucr, WRITE_REG_CMD, CARD_PULL_CTL6,\r\n0x0C, 0x04);\r\n}\r\nrtsx_usb_add_cmd(ucr, WRITE_REG_CMD, SYS_DUMMY0, NYET_MSAK, NYET_EN);\r\nrtsx_usb_add_cmd(ucr, WRITE_REG_CMD, CD_DEGLITCH_WIDTH, 0xFF, 0x08);\r\nrtsx_usb_add_cmd(ucr, WRITE_REG_CMD,\r\nCD_DEGLITCH_EN, XD_CD_DEGLITCH_EN, 0x0);\r\nrtsx_usb_add_cmd(ucr, WRITE_REG_CMD, SD30_DRIVE_SEL,\r\nSD30_DRIVE_MASK, DRIVER_TYPE_D);\r\nrtsx_usb_add_cmd(ucr, WRITE_REG_CMD,\r\nCARD_DRIVE_SEL, SD20_DRIVE_MASK, 0x0);\r\nrtsx_usb_add_cmd(ucr, WRITE_REG_CMD, LDO_POWER_CFG, 0xE0, 0x0);\r\nif (ucr->is_rts5179)\r\nrtsx_usb_add_cmd(ucr, WRITE_REG_CMD,\r\nCARD_PULL_CTL5, 0x03, 0x01);\r\nrtsx_usb_add_cmd(ucr, WRITE_REG_CMD, CARD_DMA1_CTL,\r\nEXTEND_DMA1_ASYNC_SIGNAL, EXTEND_DMA1_ASYNC_SIGNAL);\r\nrtsx_usb_add_cmd(ucr, WRITE_REG_CMD, CARD_INT_PEND,\r\nXD_INT | MS_INT | SD_INT,\r\nXD_INT | MS_INT | SD_INT);\r\nret = rtsx_usb_send_cmd(ucr, MODE_C, 100);\r\nif (ret)\r\nreturn ret;\r\nrtsx_usb_read_register(ucr, CFG_MODE, &val);\r\nif ((val & XTAL_FREE) || ((val & CLK_MODE_MASK) == CLK_MODE_NON_XTAL)) {\r\nret = rtsx_usb_write_phy_register(ucr, 0xC2, 0x7C);\r\nif (ret)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int rtsx_usb_init_chip(struct rtsx_ucr *ucr)\r\n{\r\nint ret;\r\nu8 val;\r\nrtsx_usb_clear_fsm_err(ucr);\r\nret = rtsx_usb_write_register(ucr,\r\nFPDCTL, SSC_POWER_MASK, SSC_POWER_ON);\r\nif (ret)\r\nreturn ret;\r\nusleep_range(100, 1000);\r\nret = rtsx_usb_write_register(ucr, CLK_DIV, CLK_CHANGE, 0x00);\r\nif (ret)\r\nreturn ret;\r\nret = rtsx_usb_read_register(ucr, HW_VERSION, &val);\r\nif (ret)\r\nreturn ret;\r\nucr->ic_version = val & HW_VER_MASK;\r\nret = rtsx_usb_read_register(ucr, CARD_SHARE_MODE, &val);\r\nif (ret)\r\nreturn ret;\r\nif (val & CARD_SHARE_LQFP_SEL) {\r\nucr->package = LQFP48;\r\ndev_dbg(&ucr->pusb_intf->dev, "Package: LQFP48\n");\r\n} else {\r\nucr->package = QFN24;\r\ndev_dbg(&ucr->pusb_intf->dev, "Package: QFN24\n");\r\n}\r\nrtsx_usb_read_register(ucr, CFG_MODE_1, &val);\r\nif (val & RTS5179) {\r\nucr->is_rts5179 = true;\r\ndev_dbg(&ucr->pusb_intf->dev, "Device is rts5179\n");\r\n} else {\r\nucr->is_rts5179 = false;\r\n}\r\nreturn rtsx_usb_reset_chip(ucr);\r\n}\r\nstatic int rtsx_usb_probe(struct usb_interface *intf,\r\nconst struct usb_device_id *id)\r\n{\r\nstruct usb_device *usb_dev = interface_to_usbdev(intf);\r\nstruct rtsx_ucr *ucr;\r\nint ret;\r\ndev_dbg(&intf->dev,\r\n": Realtek USB Card Reader found at bus %03d address %03d\n",\r\nusb_dev->bus->busnum, usb_dev->devnum);\r\nucr = devm_kzalloc(&intf->dev, sizeof(*ucr), GFP_KERNEL);\r\nif (!ucr)\r\nreturn -ENOMEM;\r\nucr->pusb_dev = usb_dev;\r\nucr->iobuf = usb_alloc_coherent(ucr->pusb_dev, IOBUF_SIZE,\r\nGFP_KERNEL, &ucr->iobuf_dma);\r\nif (!ucr->iobuf)\r\nreturn -ENOMEM;\r\nusb_set_intfdata(intf, ucr);\r\nucr->vendor_id = id->idVendor;\r\nucr->product_id = id->idProduct;\r\nucr->cmd_buf = ucr->rsp_buf = ucr->iobuf;\r\nmutex_init(&ucr->dev_mutex);\r\nucr->pusb_intf = intf;\r\nret = rtsx_usb_init_chip(ucr);\r\nif (ret)\r\ngoto out_init_fail;\r\nsetup_timer(&ucr->sg_timer, rtsx_usb_sg_timed_out, (unsigned long) ucr);\r\nret = mfd_add_hotplug_devices(&intf->dev, rtsx_usb_cells,\r\nARRAY_SIZE(rtsx_usb_cells));\r\nif (ret)\r\ngoto out_init_fail;\r\n#ifdef CONFIG_PM\r\nintf->needs_remote_wakeup = 1;\r\nusb_enable_autosuspend(usb_dev);\r\n#endif\r\nreturn 0;\r\nout_init_fail:\r\nusb_free_coherent(ucr->pusb_dev, IOBUF_SIZE, ucr->iobuf,\r\nucr->iobuf_dma);\r\nreturn ret;\r\n}\r\nstatic void rtsx_usb_disconnect(struct usb_interface *intf)\r\n{\r\nstruct rtsx_ucr *ucr = (struct rtsx_ucr *)usb_get_intfdata(intf);\r\ndev_dbg(&intf->dev, "%s called\n", __func__);\r\nmfd_remove_devices(&intf->dev);\r\nusb_set_intfdata(ucr->pusb_intf, NULL);\r\nusb_free_coherent(ucr->pusb_dev, IOBUF_SIZE, ucr->iobuf,\r\nucr->iobuf_dma);\r\n}\r\nstatic int rtsx_usb_suspend(struct usb_interface *intf, pm_message_t message)\r\n{\r\nstruct rtsx_ucr *ucr =\r\n(struct rtsx_ucr *)usb_get_intfdata(intf);\r\nu16 val = 0;\r\ndev_dbg(&intf->dev, "%s called with pm message 0x%04x\n",\r\n__func__, message.event);\r\nif (PMSG_IS_AUTO(message)) {\r\nif (mutex_trylock(&ucr->dev_mutex)) {\r\nrtsx_usb_get_card_status(ucr, &val);\r\nmutex_unlock(&ucr->dev_mutex);\r\nif (val & (SD_CD | MS_CD))\r\nreturn -EAGAIN;\r\n} else {\r\nreturn -EAGAIN;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int rtsx_usb_resume(struct usb_interface *intf)\r\n{\r\nreturn 0;\r\n}\r\nstatic int rtsx_usb_reset_resume(struct usb_interface *intf)\r\n{\r\nstruct rtsx_ucr *ucr =\r\n(struct rtsx_ucr *)usb_get_intfdata(intf);\r\nrtsx_usb_reset_chip(ucr);\r\nreturn 0;\r\n}\r\nstatic int rtsx_usb_pre_reset(struct usb_interface *intf)\r\n{\r\nstruct rtsx_ucr *ucr = (struct rtsx_ucr *)usb_get_intfdata(intf);\r\nmutex_lock(&ucr->dev_mutex);\r\nreturn 0;\r\n}\r\nstatic int rtsx_usb_post_reset(struct usb_interface *intf)\r\n{\r\nstruct rtsx_ucr *ucr = (struct rtsx_ucr *)usb_get_intfdata(intf);\r\nmutex_unlock(&ucr->dev_mutex);\r\nreturn 0;\r\n}
