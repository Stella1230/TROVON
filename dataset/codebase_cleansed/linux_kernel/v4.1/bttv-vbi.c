static int vbi_buffer_setup(struct videobuf_queue *q,\r\nunsigned int *count, unsigned int *size)\r\n{\r\nstruct bttv_fh *fh = q->priv_data;\r\nstruct bttv *btv = fh->btv;\r\nif (0 == *count)\r\n*count = vbibufs;\r\n*size = IMAGE_SIZE(&fh->vbi_fmt.fmt);\r\ndprintk("setup: samples=%u start=%d,%d count=%u,%u\n",\r\nfh->vbi_fmt.fmt.samples_per_line,\r\nfh->vbi_fmt.fmt.start[0],\r\nfh->vbi_fmt.fmt.start[1],\r\nfh->vbi_fmt.fmt.count[0],\r\nfh->vbi_fmt.fmt.count[1]);\r\nreturn 0;\r\n}\r\nstatic int vbi_buffer_prepare(struct videobuf_queue *q,\r\nstruct videobuf_buffer *vb,\r\nenum v4l2_field field)\r\n{\r\nstruct bttv_fh *fh = q->priv_data;\r\nstruct bttv *btv = fh->btv;\r\nstruct bttv_buffer *buf = container_of(vb,struct bttv_buffer,vb);\r\nconst struct bttv_tvnorm *tvnorm;\r\nunsigned int skip_lines0, skip_lines1, min_vdelay;\r\nint redo_dma_risc;\r\nint rc;\r\nbuf->vb.size = IMAGE_SIZE(&fh->vbi_fmt.fmt);\r\nif (0 != buf->vb.baddr && buf->vb.bsize < buf->vb.size)\r\nreturn -EINVAL;\r\ntvnorm = fh->vbi_fmt.tvnorm;\r\nskip_lines0 = 0;\r\nskip_lines1 = 0;\r\nif (fh->vbi_fmt.fmt.count[0] > 0)\r\nskip_lines0 = max(0, (fh->vbi_fmt.fmt.start[0]\r\n- tvnorm->vbistart[0]));\r\nif (fh->vbi_fmt.fmt.count[1] > 0)\r\nskip_lines1 = max(0, (fh->vbi_fmt.fmt.start[1]\r\n- tvnorm->vbistart[1]));\r\nredo_dma_risc = 0;\r\nif (buf->vbi_skip[0] != skip_lines0 ||\r\nbuf->vbi_skip[1] != skip_lines1 ||\r\nbuf->vbi_count[0] != fh->vbi_fmt.fmt.count[0] ||\r\nbuf->vbi_count[1] != fh->vbi_fmt.fmt.count[1]) {\r\nbuf->vbi_skip[0] = skip_lines0;\r\nbuf->vbi_skip[1] = skip_lines1;\r\nbuf->vbi_count[0] = fh->vbi_fmt.fmt.count[0];\r\nbuf->vbi_count[1] = fh->vbi_fmt.fmt.count[1];\r\nredo_dma_risc = 1;\r\n}\r\nif (VIDEOBUF_NEEDS_INIT == buf->vb.state) {\r\nredo_dma_risc = 1;\r\nif (0 != (rc = videobuf_iolock(q, &buf->vb, NULL)))\r\ngoto fail;\r\n}\r\nif (redo_dma_risc) {\r\nunsigned int bpl, padding, offset;\r\nstruct videobuf_dmabuf *dma=videobuf_to_dma(&buf->vb);\r\nbpl = 2044;\r\npadding = VBI_BPL - bpl;\r\nif (fh->vbi_fmt.fmt.count[0] > 0) {\r\nrc = bttv_risc_packed(btv, &buf->top,\r\ndma->sglist,\r\n0, bpl,\r\npadding, skip_lines0,\r\nfh->vbi_fmt.fmt.count[0]);\r\nif (0 != rc)\r\ngoto fail;\r\n}\r\nif (fh->vbi_fmt.fmt.count[1] > 0) {\r\noffset = fh->vbi_fmt.fmt.count[0] * VBI_BPL;\r\nrc = bttv_risc_packed(btv, &buf->bottom,\r\ndma->sglist,\r\noffset, bpl,\r\npadding, skip_lines1,\r\nfh->vbi_fmt.fmt.count[1]);\r\nif (0 != rc)\r\ngoto fail;\r\n}\r\n}\r\nmin_vdelay = MIN_VDELAY;\r\nif (fh->vbi_fmt.end >= tvnorm->cropcap.bounds.top)\r\nmin_vdelay += fh->vbi_fmt.end - tvnorm->cropcap.bounds.top;\r\nbuf->geo.vdelay = min_vdelay;\r\nbuf->vb.state = VIDEOBUF_PREPARED;\r\nbuf->vb.field = field;\r\ndprintk("buf prepare %p: top=%p bottom=%p field=%s\n",\r\nvb, &buf->top, &buf->bottom,\r\nv4l2_field_names[buf->vb.field]);\r\nreturn 0;\r\nfail:\r\nbttv_dma_free(q,btv,buf);\r\nreturn rc;\r\n}\r\nstatic void\r\nvbi_buffer_queue(struct videobuf_queue *q, struct videobuf_buffer *vb)\r\n{\r\nstruct bttv_fh *fh = q->priv_data;\r\nstruct bttv *btv = fh->btv;\r\nstruct bttv_buffer *buf = container_of(vb,struct bttv_buffer,vb);\r\ndprintk("queue %p\n",vb);\r\nbuf->vb.state = VIDEOBUF_QUEUED;\r\nlist_add_tail(&buf->vb.queue,&btv->vcapture);\r\nif (NULL == btv->cvbi) {\r\nfh->btv->loop_irq |= 4;\r\nbttv_set_dma(btv,0x0c);\r\n}\r\n}\r\nstatic void vbi_buffer_release(struct videobuf_queue *q, struct videobuf_buffer *vb)\r\n{\r\nstruct bttv_fh *fh = q->priv_data;\r\nstruct bttv *btv = fh->btv;\r\nstruct bttv_buffer *buf = container_of(vb,struct bttv_buffer,vb);\r\ndprintk("free %p\n",vb);\r\nbttv_dma_free(q,fh->btv,buf);\r\n}\r\nstatic int try_fmt(struct v4l2_vbi_format *f, const struct bttv_tvnorm *tvnorm,\r\n__s32 crop_start)\r\n{\r\n__s32 min_start, max_start, max_end, f2_offset;\r\nunsigned int i;\r\nmin_start = tvnorm->vbistart[0];\r\nmax_start = (crop_start >> 1) - 1;\r\nmax_end = (tvnorm->cropcap.bounds.top\r\n+ tvnorm->cropcap.bounds.height) >> 1;\r\nif (min_start > max_start)\r\nreturn -EBUSY;\r\nBUG_ON(max_start >= max_end);\r\nf->sampling_rate = tvnorm->Fsc;\r\nf->samples_per_line = VBI_BPL;\r\nf->sample_format = V4L2_PIX_FMT_GREY;\r\nf->offset = VBI_OFFSET;\r\nf2_offset = tvnorm->vbistart[1] - tvnorm->vbistart[0];\r\nfor (i = 0; i < 2; ++i) {\r\nif (0 == f->count[i]) {\r\n} else {\r\ns64 start, count;\r\nstart = clamp(f->start[i], min_start, max_start);\r\ncount = (s64) f->start[i] + f->count[i] - start;\r\nf->start[i] = start;\r\nf->count[i] = clamp(count, (s64) 1,\r\nmax_end - start);\r\n}\r\nmin_start += f2_offset;\r\nmax_start += f2_offset;\r\nmax_end += f2_offset;\r\n}\r\nif (0 == (f->count[0] | f->count[1])) {\r\nf->start[0] = tvnorm->vbistart[0];\r\nf->start[1] = tvnorm->vbistart[1];\r\nf->count[0] = 1;\r\nf->count[1] = 1;\r\n}\r\nf->flags = 0;\r\nf->reserved[0] = 0;\r\nf->reserved[1] = 0;\r\nreturn 0;\r\n}\r\nint bttv_try_fmt_vbi_cap(struct file *file, void *f, struct v4l2_format *frt)\r\n{\r\nstruct bttv_fh *fh = f;\r\nstruct bttv *btv = fh->btv;\r\nconst struct bttv_tvnorm *tvnorm;\r\n__s32 crop_start;\r\nmutex_lock(&btv->lock);\r\ntvnorm = &bttv_tvnorms[btv->tvnorm];\r\ncrop_start = btv->crop_start;\r\nmutex_unlock(&btv->lock);\r\nreturn try_fmt(&frt->fmt.vbi, tvnorm, crop_start);\r\n}\r\nint bttv_s_fmt_vbi_cap(struct file *file, void *f, struct v4l2_format *frt)\r\n{\r\nstruct bttv_fh *fh = f;\r\nstruct bttv *btv = fh->btv;\r\nconst struct bttv_tvnorm *tvnorm;\r\n__s32 start1, end;\r\nint rc;\r\nmutex_lock(&btv->lock);\r\nrc = -EBUSY;\r\nif (fh->resources & RESOURCE_VBI)\r\ngoto fail;\r\ntvnorm = &bttv_tvnorms[btv->tvnorm];\r\nrc = try_fmt(&frt->fmt.vbi, tvnorm, btv->crop_start);\r\nif (0 != rc)\r\ngoto fail;\r\nstart1 = frt->fmt.vbi.start[1] - tvnorm->vbistart[1] +\r\ntvnorm->vbistart[0];\r\nend = max(frt->fmt.vbi.start[0], start1) * 2 + 2;\r\nmutex_lock(&fh->vbi.vb_lock);\r\nfh->vbi_fmt.fmt = frt->fmt.vbi;\r\nfh->vbi_fmt.tvnorm = tvnorm;\r\nfh->vbi_fmt.end = end;\r\nmutex_unlock(&fh->vbi.vb_lock);\r\nrc = 0;\r\nfail:\r\nmutex_unlock(&btv->lock);\r\nreturn rc;\r\n}\r\nint bttv_g_fmt_vbi_cap(struct file *file, void *f, struct v4l2_format *frt)\r\n{\r\nstruct bttv_fh *fh = f;\r\nconst struct bttv_tvnorm *tvnorm;\r\nfrt->fmt.vbi = fh->vbi_fmt.fmt;\r\ntvnorm = &bttv_tvnorms[fh->btv->tvnorm];\r\nif (tvnorm != fh->vbi_fmt.tvnorm) {\r\n__s32 max_end;\r\nunsigned int i;\r\nmax_end = (tvnorm->cropcap.bounds.top\r\n+ tvnorm->cropcap.bounds.height) >> 1;\r\nfrt->fmt.vbi.sampling_rate = tvnorm->Fsc;\r\nfor (i = 0; i < 2; ++i) {\r\n__s32 new_start;\r\nnew_start = frt->fmt.vbi.start[i]\r\n+ tvnorm->vbistart[i]\r\n- fh->vbi_fmt.tvnorm->vbistart[i];\r\nfrt->fmt.vbi.start[i] = min(new_start, max_end - 1);\r\nfrt->fmt.vbi.count[i] =\r\nmin((__s32) frt->fmt.vbi.count[i],\r\nmax_end - frt->fmt.vbi.start[i]);\r\nmax_end += tvnorm->vbistart[1]\r\n- tvnorm->vbistart[0];\r\n}\r\n}\r\nreturn 0;\r\n}\r\nvoid bttv_vbi_fmt_reset(struct bttv_vbi_fmt *f, unsigned int norm)\r\n{\r\nconst struct bttv_tvnorm *tvnorm;\r\nunsigned int real_samples_per_line;\r\nunsigned int real_count;\r\ntvnorm = &bttv_tvnorms[norm];\r\nf->fmt.sampling_rate = tvnorm->Fsc;\r\nf->fmt.samples_per_line = VBI_BPL;\r\nf->fmt.sample_format = V4L2_PIX_FMT_GREY;\r\nf->fmt.offset = VBI_OFFSET;\r\nf->fmt.start[0] = tvnorm->vbistart[0];\r\nf->fmt.start[1] = tvnorm->vbistart[1];\r\nf->fmt.count[0] = VBI_DEFLINES;\r\nf->fmt.count[1] = VBI_DEFLINES;\r\nf->fmt.flags = 0;\r\nf->fmt.reserved[0] = 0;\r\nf->fmt.reserved[1] = 0;\r\nreal_samples_per_line = 1024 + tvnorm->vbipack * 4;\r\nreal_count = ((tvnorm->cropcap.defrect.top >> 1)\r\n- tvnorm->vbistart[0]);\r\nBUG_ON(real_samples_per_line > VBI_BPL);\r\nBUG_ON(real_count > VBI_DEFLINES);\r\nf->tvnorm = tvnorm;\r\nf->end = tvnorm->vbistart[0] * 2 + 2;\r\n}
