static inline void __iomem *spi_reg(struct orion_spi *orion_spi, u32 reg)\r\n{\r\nreturn orion_spi->base + reg;\r\n}\r\nstatic inline void\r\norion_spi_setbits(struct orion_spi *orion_spi, u32 reg, u32 mask)\r\n{\r\nvoid __iomem *reg_addr = spi_reg(orion_spi, reg);\r\nu32 val;\r\nval = readl(reg_addr);\r\nval |= mask;\r\nwritel(val, reg_addr);\r\n}\r\nstatic inline void\r\norion_spi_clrbits(struct orion_spi *orion_spi, u32 reg, u32 mask)\r\n{\r\nvoid __iomem *reg_addr = spi_reg(orion_spi, reg);\r\nu32 val;\r\nval = readl(reg_addr);\r\nval &= ~mask;\r\nwritel(val, reg_addr);\r\n}\r\nstatic int orion_spi_baudrate_set(struct spi_device *spi, unsigned int speed)\r\n{\r\nu32 tclk_hz;\r\nu32 rate;\r\nu32 prescale;\r\nu32 reg;\r\nstruct orion_spi *orion_spi;\r\nconst struct orion_spi_dev *devdata;\r\norion_spi = spi_master_get_devdata(spi->master);\r\ndevdata = orion_spi->devdata;\r\ntclk_hz = clk_get_rate(orion_spi->clk);\r\nif (devdata->typ == ARMADA_SPI) {\r\nunsigned int clk, spr, sppr, sppr2, err;\r\nunsigned int best_spr, best_sppr, best_err;\r\nbest_err = speed;\r\nbest_spr = 0;\r\nbest_sppr = 0;\r\nfor (sppr = 0; sppr < 8; sppr++) {\r\nsppr2 = 0x1 << sppr;\r\nspr = tclk_hz / sppr2;\r\nspr = DIV_ROUND_UP(spr, speed);\r\nif ((spr == 0) || (spr > 15))\r\ncontinue;\r\nclk = tclk_hz / (spr * sppr2);\r\nerr = speed - clk;\r\nif (err < best_err) {\r\nbest_spr = spr;\r\nbest_sppr = sppr;\r\nbest_err = err;\r\n}\r\n}\r\nif ((best_sppr == 0) && (best_spr == 0))\r\nreturn -EINVAL;\r\nprescale = ((best_sppr & 0x6) << 5) |\r\n((best_sppr & 0x1) << 4) | best_spr;\r\n} else {\r\nrate = DIV_ROUND_UP(tclk_hz, speed);\r\nrate = roundup(rate, 2);\r\nif (rate > 30)\r\nreturn -EINVAL;\r\nif (rate < 4)\r\nrate = 4;\r\nprescale = 0x10 + rate/2;\r\n}\r\nreg = readl(spi_reg(orion_spi, ORION_SPI_IF_CONFIG_REG));\r\nreg = ((reg & ~devdata->prescale_mask) | prescale);\r\nwritel(reg, spi_reg(orion_spi, ORION_SPI_IF_CONFIG_REG));\r\nreturn 0;\r\n}\r\nstatic void\r\norion_spi_mode_set(struct spi_device *spi)\r\n{\r\nu32 reg;\r\nstruct orion_spi *orion_spi;\r\norion_spi = spi_master_get_devdata(spi->master);\r\nreg = readl(spi_reg(orion_spi, ORION_SPI_IF_CONFIG_REG));\r\nreg &= ~ORION_SPI_MODE_MASK;\r\nif (spi->mode & SPI_CPOL)\r\nreg |= ORION_SPI_MODE_CPOL;\r\nif (spi->mode & SPI_CPHA)\r\nreg |= ORION_SPI_MODE_CPHA;\r\nwritel(reg, spi_reg(orion_spi, ORION_SPI_IF_CONFIG_REG));\r\n}\r\nstatic int\r\norion_spi_setup_transfer(struct spi_device *spi, struct spi_transfer *t)\r\n{\r\nstruct orion_spi *orion_spi;\r\nunsigned int speed = spi->max_speed_hz;\r\nunsigned int bits_per_word = spi->bits_per_word;\r\nint rc;\r\norion_spi = spi_master_get_devdata(spi->master);\r\nif ((t != NULL) && t->speed_hz)\r\nspeed = t->speed_hz;\r\nif ((t != NULL) && t->bits_per_word)\r\nbits_per_word = t->bits_per_word;\r\norion_spi_mode_set(spi);\r\nrc = orion_spi_baudrate_set(spi, speed);\r\nif (rc)\r\nreturn rc;\r\nif (bits_per_word == 16)\r\norion_spi_setbits(orion_spi, ORION_SPI_IF_CONFIG_REG,\r\nORION_SPI_IF_8_16_BIT_MODE);\r\nelse\r\norion_spi_clrbits(orion_spi, ORION_SPI_IF_CONFIG_REG,\r\nORION_SPI_IF_8_16_BIT_MODE);\r\nreturn 0;\r\n}\r\nstatic void orion_spi_set_cs(struct spi_device *spi, bool enable)\r\n{\r\nstruct orion_spi *orion_spi;\r\norion_spi = spi_master_get_devdata(spi->master);\r\norion_spi_clrbits(orion_spi, ORION_SPI_IF_CTRL_REG, ORION_SPI_CS_MASK);\r\norion_spi_setbits(orion_spi, ORION_SPI_IF_CTRL_REG,\r\nORION_SPI_CS(spi->chip_select));\r\nif (!enable)\r\norion_spi_setbits(orion_spi, ORION_SPI_IF_CTRL_REG, 0x1);\r\nelse\r\norion_spi_clrbits(orion_spi, ORION_SPI_IF_CTRL_REG, 0x1);\r\n}\r\nstatic inline int orion_spi_wait_till_ready(struct orion_spi *orion_spi)\r\n{\r\nint i;\r\nfor (i = 0; i < ORION_SPI_WAIT_RDY_MAX_LOOP; i++) {\r\nif (readl(spi_reg(orion_spi, ORION_SPI_INT_CAUSE_REG)))\r\nreturn 1;\r\nudelay(1);\r\n}\r\nreturn -1;\r\n}\r\nstatic inline int\r\norion_spi_write_read_8bit(struct spi_device *spi,\r\nconst u8 **tx_buf, u8 **rx_buf)\r\n{\r\nvoid __iomem *tx_reg, *rx_reg, *int_reg;\r\nstruct orion_spi *orion_spi;\r\norion_spi = spi_master_get_devdata(spi->master);\r\ntx_reg = spi_reg(orion_spi, ORION_SPI_DATA_OUT_REG);\r\nrx_reg = spi_reg(orion_spi, ORION_SPI_DATA_IN_REG);\r\nint_reg = spi_reg(orion_spi, ORION_SPI_INT_CAUSE_REG);\r\nwritel(0x0, int_reg);\r\nif (tx_buf && *tx_buf)\r\nwritel(*(*tx_buf)++, tx_reg);\r\nelse\r\nwritel(0, tx_reg);\r\nif (orion_spi_wait_till_ready(orion_spi) < 0) {\r\ndev_err(&spi->dev, "TXS timed out\n");\r\nreturn -1;\r\n}\r\nif (rx_buf && *rx_buf)\r\n*(*rx_buf)++ = readl(rx_reg);\r\nreturn 1;\r\n}\r\nstatic inline int\r\norion_spi_write_read_16bit(struct spi_device *spi,\r\nconst u16 **tx_buf, u16 **rx_buf)\r\n{\r\nvoid __iomem *tx_reg, *rx_reg, *int_reg;\r\nstruct orion_spi *orion_spi;\r\norion_spi = spi_master_get_devdata(spi->master);\r\ntx_reg = spi_reg(orion_spi, ORION_SPI_DATA_OUT_REG);\r\nrx_reg = spi_reg(orion_spi, ORION_SPI_DATA_IN_REG);\r\nint_reg = spi_reg(orion_spi, ORION_SPI_INT_CAUSE_REG);\r\nwritel(0x0, int_reg);\r\nif (tx_buf && *tx_buf)\r\nwritel(__cpu_to_le16(get_unaligned((*tx_buf)++)), tx_reg);\r\nelse\r\nwritel(0, tx_reg);\r\nif (orion_spi_wait_till_ready(orion_spi) < 0) {\r\ndev_err(&spi->dev, "TXS timed out\n");\r\nreturn -1;\r\n}\r\nif (rx_buf && *rx_buf)\r\nput_unaligned(__le16_to_cpu(readl(rx_reg)), (*rx_buf)++);\r\nreturn 1;\r\n}\r\nstatic unsigned int\r\norion_spi_write_read(struct spi_device *spi, struct spi_transfer *xfer)\r\n{\r\nunsigned int count;\r\nint word_len;\r\nword_len = spi->bits_per_word;\r\ncount = xfer->len;\r\nif (word_len == 8) {\r\nconst u8 *tx = xfer->tx_buf;\r\nu8 *rx = xfer->rx_buf;\r\ndo {\r\nif (orion_spi_write_read_8bit(spi, &tx, &rx) < 0)\r\ngoto out;\r\ncount--;\r\n} while (count);\r\n} else if (word_len == 16) {\r\nconst u16 *tx = xfer->tx_buf;\r\nu16 *rx = xfer->rx_buf;\r\ndo {\r\nif (orion_spi_write_read_16bit(spi, &tx, &rx) < 0)\r\ngoto out;\r\ncount -= 2;\r\n} while (count);\r\n}\r\nout:\r\nreturn xfer->len - count;\r\n}\r\nstatic int orion_spi_transfer_one(struct spi_master *master,\r\nstruct spi_device *spi,\r\nstruct spi_transfer *t)\r\n{\r\nint status = 0;\r\nstatus = orion_spi_setup_transfer(spi, t);\r\nif (status < 0)\r\nreturn status;\r\nif (t->len)\r\norion_spi_write_read(spi, t);\r\nreturn status;\r\n}\r\nstatic int orion_spi_setup(struct spi_device *spi)\r\n{\r\nreturn orion_spi_setup_transfer(spi, NULL);\r\n}\r\nstatic int orion_spi_reset(struct orion_spi *orion_spi)\r\n{\r\norion_spi_clrbits(orion_spi, ORION_SPI_IF_CTRL_REG, 0x1);\r\nreturn 0;\r\n}\r\nstatic int orion_spi_probe(struct platform_device *pdev)\r\n{\r\nconst struct of_device_id *of_id;\r\nconst struct orion_spi_dev *devdata;\r\nstruct spi_master *master;\r\nstruct orion_spi *spi;\r\nstruct resource *r;\r\nunsigned long tclk_hz;\r\nint status = 0;\r\nmaster = spi_alloc_master(&pdev->dev, sizeof(*spi));\r\nif (master == NULL) {\r\ndev_dbg(&pdev->dev, "master allocation failed\n");\r\nreturn -ENOMEM;\r\n}\r\nif (pdev->id != -1)\r\nmaster->bus_num = pdev->id;\r\nif (pdev->dev.of_node) {\r\nu32 cell_index;\r\nif (!of_property_read_u32(pdev->dev.of_node, "cell-index",\r\n&cell_index))\r\nmaster->bus_num = cell_index;\r\n}\r\nmaster->mode_bits = SPI_CPHA | SPI_CPOL;\r\nmaster->set_cs = orion_spi_set_cs;\r\nmaster->transfer_one = orion_spi_transfer_one;\r\nmaster->num_chipselect = ORION_NUM_CHIPSELECTS;\r\nmaster->setup = orion_spi_setup;\r\nmaster->bits_per_word_mask = SPI_BPW_MASK(8) | SPI_BPW_MASK(16);\r\nmaster->auto_runtime_pm = true;\r\nplatform_set_drvdata(pdev, master);\r\nspi = spi_master_get_devdata(master);\r\nspi->master = master;\r\nof_id = of_match_device(orion_spi_of_match_table, &pdev->dev);\r\ndevdata = (of_id) ? of_id->data : &orion_spi_dev_data;\r\nspi->devdata = devdata;\r\nspi->clk = devm_clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(spi->clk)) {\r\nstatus = PTR_ERR(spi->clk);\r\ngoto out;\r\n}\r\nstatus = clk_prepare_enable(spi->clk);\r\nif (status)\r\ngoto out;\r\ntclk_hz = clk_get_rate(spi->clk);\r\nmaster->max_speed_hz = DIV_ROUND_UP(tclk_hz, devdata->min_divisor);\r\nmaster->min_speed_hz = DIV_ROUND_UP(tclk_hz, devdata->max_divisor);\r\nr = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nspi->base = devm_ioremap_resource(&pdev->dev, r);\r\nif (IS_ERR(spi->base)) {\r\nstatus = PTR_ERR(spi->base);\r\ngoto out_rel_clk;\r\n}\r\npm_runtime_set_active(&pdev->dev);\r\npm_runtime_use_autosuspend(&pdev->dev);\r\npm_runtime_set_autosuspend_delay(&pdev->dev, SPI_AUTOSUSPEND_TIMEOUT);\r\npm_runtime_enable(&pdev->dev);\r\nstatus = orion_spi_reset(spi);\r\nif (status < 0)\r\ngoto out_rel_pm;\r\npm_runtime_mark_last_busy(&pdev->dev);\r\npm_runtime_put_autosuspend(&pdev->dev);\r\nmaster->dev.of_node = pdev->dev.of_node;\r\nstatus = spi_register_master(master);\r\nif (status < 0)\r\ngoto out_rel_pm;\r\nreturn status;\r\nout_rel_pm:\r\npm_runtime_disable(&pdev->dev);\r\nout_rel_clk:\r\nclk_disable_unprepare(spi->clk);\r\nout:\r\nspi_master_put(master);\r\nreturn status;\r\n}\r\nstatic int orion_spi_remove(struct platform_device *pdev)\r\n{\r\nstruct spi_master *master = platform_get_drvdata(pdev);\r\nstruct orion_spi *spi = spi_master_get_devdata(master);\r\npm_runtime_get_sync(&pdev->dev);\r\nclk_disable_unprepare(spi->clk);\r\nspi_unregister_master(master);\r\npm_runtime_disable(&pdev->dev);\r\nreturn 0;\r\n}\r\nstatic int orion_spi_runtime_suspend(struct device *dev)\r\n{\r\nstruct spi_master *master = dev_get_drvdata(dev);\r\nstruct orion_spi *spi = spi_master_get_devdata(master);\r\nclk_disable_unprepare(spi->clk);\r\nreturn 0;\r\n}\r\nstatic int orion_spi_runtime_resume(struct device *dev)\r\n{\r\nstruct spi_master *master = dev_get_drvdata(dev);\r\nstruct orion_spi *spi = spi_master_get_devdata(master);\r\nreturn clk_prepare_enable(spi->clk);\r\n}
