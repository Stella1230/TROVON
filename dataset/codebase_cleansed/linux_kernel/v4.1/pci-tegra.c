static inline struct tegra_msi *to_tegra_msi(struct msi_controller *chip)\r\n{\r\nreturn container_of(chip, struct tegra_msi, chip);\r\n}\r\nstatic inline struct tegra_pcie *sys_to_pcie(struct pci_sys_data *sys)\r\n{\r\nreturn sys->private_data;\r\n}\r\nstatic inline void afi_writel(struct tegra_pcie *pcie, u32 value,\r\nunsigned long offset)\r\n{\r\nwritel(value, pcie->afi + offset);\r\n}\r\nstatic inline u32 afi_readl(struct tegra_pcie *pcie, unsigned long offset)\r\n{\r\nreturn readl(pcie->afi + offset);\r\n}\r\nstatic inline void pads_writel(struct tegra_pcie *pcie, u32 value,\r\nunsigned long offset)\r\n{\r\nwritel(value, pcie->pads + offset);\r\n}\r\nstatic inline u32 pads_readl(struct tegra_pcie *pcie, unsigned long offset)\r\n{\r\nreturn readl(pcie->pads + offset);\r\n}\r\nstatic unsigned long tegra_pcie_conf_offset(unsigned int devfn, int where)\r\n{\r\nreturn ((where & 0xf00) << 8) | (PCI_SLOT(devfn) << 11) |\r\n(PCI_FUNC(devfn) << 8) | (where & 0xfc);\r\n}\r\nstatic struct tegra_pcie_bus *tegra_pcie_bus_alloc(struct tegra_pcie *pcie,\r\nunsigned int busnr)\r\n{\r\npgprot_t prot = L_PTE_PRESENT | L_PTE_YOUNG | L_PTE_DIRTY | L_PTE_XN |\r\nL_PTE_MT_DEV_SHARED | L_PTE_SHARED;\r\nphys_addr_t cs = pcie->cs->start;\r\nstruct tegra_pcie_bus *bus;\r\nunsigned int i;\r\nint err;\r\nbus = kzalloc(sizeof(*bus), GFP_KERNEL);\r\nif (!bus)\r\nreturn ERR_PTR(-ENOMEM);\r\nINIT_LIST_HEAD(&bus->list);\r\nbus->nr = busnr;\r\nbus->area = get_vm_area(SZ_1M, VM_IOREMAP);\r\nif (!bus->area) {\r\nerr = -ENOMEM;\r\ngoto free;\r\n}\r\nfor (i = 0; i < 16; i++) {\r\nunsigned long virt = (unsigned long)bus->area->addr +\r\ni * SZ_64K;\r\nphys_addr_t phys = cs + i * SZ_16M + busnr * SZ_64K;\r\nerr = ioremap_page_range(virt, virt + SZ_64K, phys, prot);\r\nif (err < 0) {\r\ndev_err(pcie->dev, "ioremap_page_range() failed: %d\n",\r\nerr);\r\ngoto unmap;\r\n}\r\n}\r\nreturn bus;\r\nunmap:\r\nvunmap(bus->area->addr);\r\nfree:\r\nkfree(bus);\r\nreturn ERR_PTR(err);\r\n}\r\nstatic void __iomem *tegra_pcie_bus_map(struct tegra_pcie *pcie,\r\nunsigned int busnr)\r\n{\r\nstruct tegra_pcie_bus *bus;\r\nlist_for_each_entry(bus, &pcie->buses, list)\r\nif (bus->nr == busnr)\r\nreturn (void __iomem *)bus->area->addr;\r\nbus = tegra_pcie_bus_alloc(pcie, busnr);\r\nif (IS_ERR(bus))\r\nreturn NULL;\r\nlist_add_tail(&bus->list, &pcie->buses);\r\nreturn (void __iomem *)bus->area->addr;\r\n}\r\nstatic void __iomem *tegra_pcie_conf_address(struct pci_bus *bus,\r\nunsigned int devfn,\r\nint where)\r\n{\r\nstruct tegra_pcie *pcie = sys_to_pcie(bus->sysdata);\r\nvoid __iomem *addr = NULL;\r\nif (bus->number == 0) {\r\nunsigned int slot = PCI_SLOT(devfn);\r\nstruct tegra_pcie_port *port;\r\nlist_for_each_entry(port, &pcie->ports, list) {\r\nif (port->index + 1 == slot) {\r\naddr = port->base + (where & ~3);\r\nbreak;\r\n}\r\n}\r\n} else {\r\naddr = tegra_pcie_bus_map(pcie, bus->number);\r\nif (!addr) {\r\ndev_err(pcie->dev,\r\n"failed to map cfg. space for bus %u\n",\r\nbus->number);\r\nreturn NULL;\r\n}\r\naddr += tegra_pcie_conf_offset(devfn, where);\r\n}\r\nreturn addr;\r\n}\r\nstatic unsigned long tegra_pcie_port_get_pex_ctrl(struct tegra_pcie_port *port)\r\n{\r\nunsigned long ret = 0;\r\nswitch (port->index) {\r\ncase 0:\r\nret = AFI_PEX0_CTRL;\r\nbreak;\r\ncase 1:\r\nret = AFI_PEX1_CTRL;\r\nbreak;\r\ncase 2:\r\nret = AFI_PEX2_CTRL;\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic void tegra_pcie_port_reset(struct tegra_pcie_port *port)\r\n{\r\nunsigned long ctrl = tegra_pcie_port_get_pex_ctrl(port);\r\nunsigned long value;\r\nvalue = afi_readl(port->pcie, ctrl);\r\nvalue &= ~AFI_PEX_CTRL_RST;\r\nafi_writel(port->pcie, value, ctrl);\r\nusleep_range(1000, 2000);\r\nvalue = afi_readl(port->pcie, ctrl);\r\nvalue |= AFI_PEX_CTRL_RST;\r\nafi_writel(port->pcie, value, ctrl);\r\n}\r\nstatic void tegra_pcie_port_enable(struct tegra_pcie_port *port)\r\n{\r\nconst struct tegra_pcie_soc_data *soc = port->pcie->soc_data;\r\nunsigned long ctrl = tegra_pcie_port_get_pex_ctrl(port);\r\nunsigned long value;\r\nvalue = afi_readl(port->pcie, ctrl);\r\nvalue |= AFI_PEX_CTRL_REFCLK_EN;\r\nif (soc->has_pex_clkreq_en)\r\nvalue |= AFI_PEX_CTRL_CLKREQ_EN;\r\nvalue |= AFI_PEX_CTRL_OVERRIDE_EN;\r\nafi_writel(port->pcie, value, ctrl);\r\ntegra_pcie_port_reset(port);\r\n}\r\nstatic void tegra_pcie_port_disable(struct tegra_pcie_port *port)\r\n{\r\nconst struct tegra_pcie_soc_data *soc = port->pcie->soc_data;\r\nunsigned long ctrl = tegra_pcie_port_get_pex_ctrl(port);\r\nunsigned long value;\r\nvalue = afi_readl(port->pcie, ctrl);\r\nvalue &= ~AFI_PEX_CTRL_RST;\r\nafi_writel(port->pcie, value, ctrl);\r\nvalue = afi_readl(port->pcie, ctrl);\r\nif (soc->has_pex_clkreq_en)\r\nvalue &= ~AFI_PEX_CTRL_CLKREQ_EN;\r\nvalue &= ~AFI_PEX_CTRL_REFCLK_EN;\r\nafi_writel(port->pcie, value, ctrl);\r\n}\r\nstatic void tegra_pcie_port_free(struct tegra_pcie_port *port)\r\n{\r\nstruct tegra_pcie *pcie = port->pcie;\r\ndevm_iounmap(pcie->dev, port->base);\r\ndevm_release_mem_region(pcie->dev, port->regs.start,\r\nresource_size(&port->regs));\r\nlist_del(&port->list);\r\ndevm_kfree(pcie->dev, port);\r\n}\r\nstatic void tegra_pcie_fixup_class(struct pci_dev *dev)\r\n{\r\ndev->class = PCI_CLASS_BRIDGE_PCI << 8;\r\n}\r\nstatic void tegra_pcie_relax_enable(struct pci_dev *dev)\r\n{\r\npcie_capability_set_word(dev, PCI_EXP_DEVCTL, PCI_EXP_DEVCTL_RELAX_EN);\r\n}\r\nstatic int tegra_pcie_setup(int nr, struct pci_sys_data *sys)\r\n{\r\nstruct tegra_pcie *pcie = sys_to_pcie(sys);\r\nint err;\r\nerr = devm_request_resource(pcie->dev, &pcie->all, &pcie->mem);\r\nif (err < 0)\r\nreturn err;\r\nerr = devm_request_resource(pcie->dev, &pcie->all, &pcie->prefetch);\r\nif (err)\r\nreturn err;\r\npci_add_resource_offset(&sys->resources, &pcie->mem, sys->mem_offset);\r\npci_add_resource_offset(&sys->resources, &pcie->prefetch,\r\nsys->mem_offset);\r\npci_add_resource(&sys->resources, &pcie->busn);\r\npci_ioremap_io(pcie->pio.start, pcie->io.start);\r\nreturn 1;\r\n}\r\nstatic int tegra_pcie_map_irq(const struct pci_dev *pdev, u8 slot, u8 pin)\r\n{\r\nstruct tegra_pcie *pcie = sys_to_pcie(pdev->bus->sysdata);\r\nint irq;\r\ntegra_cpuidle_pcie_irqs_in_use();\r\nirq = of_irq_parse_and_map_pci(pdev, slot, pin);\r\nif (!irq)\r\nirq = pcie->irq;\r\nreturn irq;\r\n}\r\nstatic struct pci_bus *tegra_pcie_scan_bus(int nr, struct pci_sys_data *sys)\r\n{\r\nstruct tegra_pcie *pcie = sys_to_pcie(sys);\r\nstruct pci_bus *bus;\r\nbus = pci_create_root_bus(pcie->dev, sys->busnr, &tegra_pcie_ops, sys,\r\n&sys->resources);\r\nif (!bus)\r\nreturn NULL;\r\npci_scan_child_bus(bus);\r\nreturn bus;\r\n}\r\nstatic irqreturn_t tegra_pcie_isr(int irq, void *arg)\r\n{\r\nconst char *err_msg[] = {\r\n"Unknown",\r\n"AXI slave error",\r\n"AXI decode error",\r\n"Target abort",\r\n"Master abort",\r\n"Invalid write",\r\n"Legacy interrupt",\r\n"Response decoding error",\r\n"AXI response decoding error",\r\n"Transaction timeout",\r\n"Slot present pin change",\r\n"Slot clock request change",\r\n"TMS clock ramp change",\r\n"TMS ready for power down",\r\n"Peer2Peer error",\r\n};\r\nstruct tegra_pcie *pcie = arg;\r\nu32 code, signature;\r\ncode = afi_readl(pcie, AFI_INTR_CODE) & AFI_INTR_CODE_MASK;\r\nsignature = afi_readl(pcie, AFI_INTR_SIGNATURE);\r\nafi_writel(pcie, 0, AFI_INTR_CODE);\r\nif (code == AFI_INTR_LEGACY)\r\nreturn IRQ_NONE;\r\nif (code >= ARRAY_SIZE(err_msg))\r\ncode = 0;\r\nif (code == AFI_INTR_MASTER_ABORT)\r\ndev_dbg(pcie->dev, "%s, signature: %08x\n", err_msg[code],\r\nsignature);\r\nelse\r\ndev_err(pcie->dev, "%s, signature: %08x\n", err_msg[code],\r\nsignature);\r\nif (code == AFI_INTR_TARGET_ABORT || code == AFI_INTR_MASTER_ABORT ||\r\ncode == AFI_INTR_FPCI_DECODE_ERROR) {\r\nu32 fpci = afi_readl(pcie, AFI_UPPER_FPCI_ADDRESS) & 0xff;\r\nu64 address = (u64)fpci << 32 | (signature & 0xfffffffc);\r\nif (code == AFI_INTR_MASTER_ABORT)\r\ndev_dbg(pcie->dev, " FPCI address: %10llx\n", address);\r\nelse\r\ndev_err(pcie->dev, " FPCI address: %10llx\n", address);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void tegra_pcie_setup_translations(struct tegra_pcie *pcie)\r\n{\r\nu32 fpci_bar, size, axi_address;\r\nfpci_bar = 0xfe100000;\r\nsize = resource_size(pcie->cs);\r\naxi_address = pcie->cs->start;\r\nafi_writel(pcie, axi_address, AFI_AXI_BAR0_START);\r\nafi_writel(pcie, size >> 12, AFI_AXI_BAR0_SZ);\r\nafi_writel(pcie, fpci_bar, AFI_FPCI_BAR0);\r\nfpci_bar = 0xfdfc0000;\r\nsize = resource_size(&pcie->io);\r\naxi_address = pcie->io.start;\r\nafi_writel(pcie, axi_address, AFI_AXI_BAR1_START);\r\nafi_writel(pcie, size >> 12, AFI_AXI_BAR1_SZ);\r\nafi_writel(pcie, fpci_bar, AFI_FPCI_BAR1);\r\nfpci_bar = (((pcie->prefetch.start >> 12) & 0x0fffffff) << 4) | 0x1;\r\nsize = resource_size(&pcie->prefetch);\r\naxi_address = pcie->prefetch.start;\r\nafi_writel(pcie, axi_address, AFI_AXI_BAR2_START);\r\nafi_writel(pcie, size >> 12, AFI_AXI_BAR2_SZ);\r\nafi_writel(pcie, fpci_bar, AFI_FPCI_BAR2);\r\nfpci_bar = (((pcie->mem.start >> 12) & 0x0fffffff) << 4) | 0x1;\r\nsize = resource_size(&pcie->mem);\r\naxi_address = pcie->mem.start;\r\nafi_writel(pcie, axi_address, AFI_AXI_BAR3_START);\r\nafi_writel(pcie, size >> 12, AFI_AXI_BAR3_SZ);\r\nafi_writel(pcie, fpci_bar, AFI_FPCI_BAR3);\r\nafi_writel(pcie, 0, AFI_AXI_BAR4_START);\r\nafi_writel(pcie, 0, AFI_AXI_BAR4_SZ);\r\nafi_writel(pcie, 0, AFI_FPCI_BAR4);\r\nafi_writel(pcie, 0, AFI_AXI_BAR5_START);\r\nafi_writel(pcie, 0, AFI_AXI_BAR5_SZ);\r\nafi_writel(pcie, 0, AFI_FPCI_BAR5);\r\nafi_writel(pcie, PHYS_OFFSET, AFI_CACHE_BAR0_ST);\r\nafi_writel(pcie, 0, AFI_CACHE_BAR0_SZ);\r\nafi_writel(pcie, 0, AFI_CACHE_BAR1_ST);\r\nafi_writel(pcie, 0, AFI_CACHE_BAR1_SZ);\r\nafi_writel(pcie, 0, AFI_MSI_FPCI_BAR_ST);\r\nafi_writel(pcie, 0, AFI_MSI_BAR_SZ);\r\nafi_writel(pcie, 0, AFI_MSI_AXI_BAR_ST);\r\nafi_writel(pcie, 0, AFI_MSI_BAR_SZ);\r\n}\r\nstatic int tegra_pcie_pll_wait(struct tegra_pcie *pcie, unsigned long timeout)\r\n{\r\nconst struct tegra_pcie_soc_data *soc = pcie->soc_data;\r\nu32 value;\r\ntimeout = jiffies + msecs_to_jiffies(timeout);\r\nwhile (time_before(jiffies, timeout)) {\r\nvalue = pads_readl(pcie, soc->pads_pll_ctl);\r\nif (value & PADS_PLL_CTL_LOCKDET)\r\nreturn 0;\r\n}\r\nreturn -ETIMEDOUT;\r\n}\r\nstatic int tegra_pcie_phy_enable(struct tegra_pcie *pcie)\r\n{\r\nconst struct tegra_pcie_soc_data *soc = pcie->soc_data;\r\nu32 value;\r\nint err;\r\npads_writel(pcie, 0x0, PADS_CTL_SEL);\r\nvalue = pads_readl(pcie, PADS_CTL);\r\nvalue |= PADS_CTL_IDDQ_1L;\r\npads_writel(pcie, value, PADS_CTL);\r\nvalue = pads_readl(pcie, soc->pads_pll_ctl);\r\nvalue &= ~(PADS_PLL_CTL_REFCLK_MASK | PADS_PLL_CTL_TXCLKREF_MASK);\r\nvalue |= PADS_PLL_CTL_REFCLK_INTERNAL_CML | soc->tx_ref_sel;\r\npads_writel(pcie, value, soc->pads_pll_ctl);\r\nvalue = pads_readl(pcie, soc->pads_pll_ctl);\r\nvalue &= ~PADS_PLL_CTL_RST_B4SM;\r\npads_writel(pcie, value, soc->pads_pll_ctl);\r\nusleep_range(20, 100);\r\nvalue = pads_readl(pcie, soc->pads_pll_ctl);\r\nvalue |= PADS_PLL_CTL_RST_B4SM;\r\npads_writel(pcie, value, soc->pads_pll_ctl);\r\nvalue = PADS_REFCLK_CFG_VALUE | (PADS_REFCLK_CFG_VALUE << 16);\r\npads_writel(pcie, value, PADS_REFCLK_CFG0);\r\nif (soc->num_ports > 2)\r\npads_writel(pcie, PADS_REFCLK_CFG_VALUE, PADS_REFCLK_CFG1);\r\nerr = tegra_pcie_pll_wait(pcie, 500);\r\nif (err < 0) {\r\ndev_err(pcie->dev, "PLL failed to lock: %d\n", err);\r\nreturn err;\r\n}\r\nvalue = pads_readl(pcie, PADS_CTL);\r\nvalue &= ~PADS_CTL_IDDQ_1L;\r\npads_writel(pcie, value, PADS_CTL);\r\nvalue = pads_readl(pcie, PADS_CTL);\r\nvalue |= PADS_CTL_TX_DATA_EN_1L | PADS_CTL_RX_DATA_EN_1L;\r\npads_writel(pcie, value, PADS_CTL);\r\nreturn 0;\r\n}\r\nstatic int tegra_pcie_enable_controller(struct tegra_pcie *pcie)\r\n{\r\nconst struct tegra_pcie_soc_data *soc = pcie->soc_data;\r\nstruct tegra_pcie_port *port;\r\nunsigned long value;\r\nint err;\r\nif (pcie->phy) {\r\nvalue = afi_readl(pcie, AFI_PLLE_CONTROL);\r\nvalue &= ~AFI_PLLE_CONTROL_BYPASS_PADS2PLLE_CONTROL;\r\nvalue |= AFI_PLLE_CONTROL_PADS2PLLE_CONTROL_EN;\r\nafi_writel(pcie, value, AFI_PLLE_CONTROL);\r\n}\r\nif (soc->has_pex_bias_ctrl)\r\nafi_writel(pcie, 0, AFI_PEXBIAS_CTRL_0);\r\nvalue = afi_readl(pcie, AFI_PCIE_CONFIG);\r\nvalue &= ~AFI_PCIE_CONFIG_SM2TMS0_XBAR_CONFIG_MASK;\r\nvalue |= AFI_PCIE_CONFIG_PCIE_DISABLE_ALL | pcie->xbar_config;\r\nlist_for_each_entry(port, &pcie->ports, list)\r\nvalue &= ~AFI_PCIE_CONFIG_PCIE_DISABLE(port->index);\r\nafi_writel(pcie, value, AFI_PCIE_CONFIG);\r\nif (soc->has_gen2) {\r\nvalue = afi_readl(pcie, AFI_FUSE);\r\nvalue &= ~AFI_FUSE_PCIE_T0_GEN2_DIS;\r\nafi_writel(pcie, value, AFI_FUSE);\r\n} else {\r\nvalue = afi_readl(pcie, AFI_FUSE);\r\nvalue |= AFI_FUSE_PCIE_T0_GEN2_DIS;\r\nafi_writel(pcie, value, AFI_FUSE);\r\n}\r\nif (!pcie->phy)\r\nerr = tegra_pcie_phy_enable(pcie);\r\nelse\r\nerr = phy_power_on(pcie->phy);\r\nif (err < 0) {\r\ndev_err(pcie->dev, "failed to power on PHY: %d\n", err);\r\nreturn err;\r\n}\r\nreset_control_deassert(pcie->pcie_xrst);\r\nvalue = afi_readl(pcie, AFI_CONFIGURATION);\r\nvalue |= AFI_CONFIGURATION_EN_FPCI;\r\nafi_writel(pcie, value, AFI_CONFIGURATION);\r\nvalue = AFI_INTR_EN_INI_SLVERR | AFI_INTR_EN_INI_DECERR |\r\nAFI_INTR_EN_TGT_SLVERR | AFI_INTR_EN_TGT_DECERR |\r\nAFI_INTR_EN_TGT_WRERR | AFI_INTR_EN_DFPCI_DECERR;\r\nif (soc->has_intr_prsnt_sense)\r\nvalue |= AFI_INTR_EN_PRSNT_SENSE;\r\nafi_writel(pcie, value, AFI_AFI_INTR_ENABLE);\r\nafi_writel(pcie, 0xffffffff, AFI_SM_INTR_ENABLE);\r\nafi_writel(pcie, AFI_INTR_MASK_INT_MASK, AFI_INTR_MASK);\r\nafi_writel(pcie, 0, AFI_FPCI_ERROR_MASKS);\r\nreturn 0;\r\n}\r\nstatic void tegra_pcie_power_off(struct tegra_pcie *pcie)\r\n{\r\nint err;\r\nerr = phy_power_off(pcie->phy);\r\nif (err < 0)\r\ndev_warn(pcie->dev, "failed to power off PHY: %d\n", err);\r\nreset_control_assert(pcie->pcie_xrst);\r\nreset_control_assert(pcie->afi_rst);\r\nreset_control_assert(pcie->pex_rst);\r\ntegra_powergate_power_off(TEGRA_POWERGATE_PCIE);\r\nerr = regulator_bulk_disable(pcie->num_supplies, pcie->supplies);\r\nif (err < 0)\r\ndev_warn(pcie->dev, "failed to disable regulators: %d\n", err);\r\n}\r\nstatic int tegra_pcie_power_on(struct tegra_pcie *pcie)\r\n{\r\nconst struct tegra_pcie_soc_data *soc = pcie->soc_data;\r\nint err;\r\nreset_control_assert(pcie->pcie_xrst);\r\nreset_control_assert(pcie->afi_rst);\r\nreset_control_assert(pcie->pex_rst);\r\ntegra_powergate_power_off(TEGRA_POWERGATE_PCIE);\r\nerr = regulator_bulk_enable(pcie->num_supplies, pcie->supplies);\r\nif (err < 0)\r\ndev_err(pcie->dev, "failed to enable regulators: %d\n", err);\r\nerr = tegra_powergate_sequence_power_up(TEGRA_POWERGATE_PCIE,\r\npcie->pex_clk,\r\npcie->pex_rst);\r\nif (err) {\r\ndev_err(pcie->dev, "powerup sequence failed: %d\n", err);\r\nreturn err;\r\n}\r\nreset_control_deassert(pcie->afi_rst);\r\nerr = clk_prepare_enable(pcie->afi_clk);\r\nif (err < 0) {\r\ndev_err(pcie->dev, "failed to enable AFI clock: %d\n", err);\r\nreturn err;\r\n}\r\nif (soc->has_cml_clk) {\r\nerr = clk_prepare_enable(pcie->cml_clk);\r\nif (err < 0) {\r\ndev_err(pcie->dev, "failed to enable CML clock: %d\n",\r\nerr);\r\nreturn err;\r\n}\r\n}\r\nerr = clk_prepare_enable(pcie->pll_e);\r\nif (err < 0) {\r\ndev_err(pcie->dev, "failed to enable PLLE clock: %d\n", err);\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic int tegra_pcie_clocks_get(struct tegra_pcie *pcie)\r\n{\r\nconst struct tegra_pcie_soc_data *soc = pcie->soc_data;\r\npcie->pex_clk = devm_clk_get(pcie->dev, "pex");\r\nif (IS_ERR(pcie->pex_clk))\r\nreturn PTR_ERR(pcie->pex_clk);\r\npcie->afi_clk = devm_clk_get(pcie->dev, "afi");\r\nif (IS_ERR(pcie->afi_clk))\r\nreturn PTR_ERR(pcie->afi_clk);\r\npcie->pll_e = devm_clk_get(pcie->dev, "pll_e");\r\nif (IS_ERR(pcie->pll_e))\r\nreturn PTR_ERR(pcie->pll_e);\r\nif (soc->has_cml_clk) {\r\npcie->cml_clk = devm_clk_get(pcie->dev, "cml");\r\nif (IS_ERR(pcie->cml_clk))\r\nreturn PTR_ERR(pcie->cml_clk);\r\n}\r\nreturn 0;\r\n}\r\nstatic int tegra_pcie_resets_get(struct tegra_pcie *pcie)\r\n{\r\npcie->pex_rst = devm_reset_control_get(pcie->dev, "pex");\r\nif (IS_ERR(pcie->pex_rst))\r\nreturn PTR_ERR(pcie->pex_rst);\r\npcie->afi_rst = devm_reset_control_get(pcie->dev, "afi");\r\nif (IS_ERR(pcie->afi_rst))\r\nreturn PTR_ERR(pcie->afi_rst);\r\npcie->pcie_xrst = devm_reset_control_get(pcie->dev, "pcie_x");\r\nif (IS_ERR(pcie->pcie_xrst))\r\nreturn PTR_ERR(pcie->pcie_xrst);\r\nreturn 0;\r\n}\r\nstatic int tegra_pcie_get_resources(struct tegra_pcie *pcie)\r\n{\r\nstruct platform_device *pdev = to_platform_device(pcie->dev);\r\nstruct resource *pads, *afi, *res;\r\nint err;\r\nerr = tegra_pcie_clocks_get(pcie);\r\nif (err) {\r\ndev_err(&pdev->dev, "failed to get clocks: %d\n", err);\r\nreturn err;\r\n}\r\nerr = tegra_pcie_resets_get(pcie);\r\nif (err) {\r\ndev_err(&pdev->dev, "failed to get resets: %d\n", err);\r\nreturn err;\r\n}\r\npcie->phy = devm_phy_optional_get(pcie->dev, "pcie");\r\nif (IS_ERR(pcie->phy)) {\r\nerr = PTR_ERR(pcie->phy);\r\ndev_err(&pdev->dev, "failed to get PHY: %d\n", err);\r\nreturn err;\r\n}\r\nerr = phy_init(pcie->phy);\r\nif (err < 0) {\r\ndev_err(&pdev->dev, "failed to initialize PHY: %d\n", err);\r\nreturn err;\r\n}\r\nerr = tegra_pcie_power_on(pcie);\r\nif (err) {\r\ndev_err(&pdev->dev, "failed to power up: %d\n", err);\r\nreturn err;\r\n}\r\npads = platform_get_resource_byname(pdev, IORESOURCE_MEM, "pads");\r\npcie->pads = devm_ioremap_resource(&pdev->dev, pads);\r\nif (IS_ERR(pcie->pads)) {\r\nerr = PTR_ERR(pcie->pads);\r\ngoto poweroff;\r\n}\r\nafi = platform_get_resource_byname(pdev, IORESOURCE_MEM, "afi");\r\npcie->afi = devm_ioremap_resource(&pdev->dev, afi);\r\nif (IS_ERR(pcie->afi)) {\r\nerr = PTR_ERR(pcie->afi);\r\ngoto poweroff;\r\n}\r\nres = platform_get_resource_byname(pdev, IORESOURCE_MEM, "cs");\r\nif (!res) {\r\nerr = -EADDRNOTAVAIL;\r\ngoto poweroff;\r\n}\r\npcie->cs = devm_request_mem_region(pcie->dev, res->start,\r\nresource_size(res), res->name);\r\nif (!pcie->cs) {\r\nerr = -EADDRNOTAVAIL;\r\ngoto poweroff;\r\n}\r\nerr = platform_get_irq_byname(pdev, "intr");\r\nif (err < 0) {\r\ndev_err(&pdev->dev, "failed to get IRQ: %d\n", err);\r\ngoto poweroff;\r\n}\r\npcie->irq = err;\r\nerr = request_irq(pcie->irq, tegra_pcie_isr, IRQF_SHARED, "PCIE", pcie);\r\nif (err) {\r\ndev_err(&pdev->dev, "failed to register IRQ: %d\n", err);\r\ngoto poweroff;\r\n}\r\nreturn 0;\r\npoweroff:\r\ntegra_pcie_power_off(pcie);\r\nreturn err;\r\n}\r\nstatic int tegra_pcie_put_resources(struct tegra_pcie *pcie)\r\n{\r\nint err;\r\nif (pcie->irq > 0)\r\nfree_irq(pcie->irq, pcie);\r\ntegra_pcie_power_off(pcie);\r\nerr = phy_exit(pcie->phy);\r\nif (err < 0)\r\ndev_err(pcie->dev, "failed to teardown PHY: %d\n", err);\r\nreturn 0;\r\n}\r\nstatic int tegra_msi_alloc(struct tegra_msi *chip)\r\n{\r\nint msi;\r\nmutex_lock(&chip->lock);\r\nmsi = find_first_zero_bit(chip->used, INT_PCI_MSI_NR);\r\nif (msi < INT_PCI_MSI_NR)\r\nset_bit(msi, chip->used);\r\nelse\r\nmsi = -ENOSPC;\r\nmutex_unlock(&chip->lock);\r\nreturn msi;\r\n}\r\nstatic void tegra_msi_free(struct tegra_msi *chip, unsigned long irq)\r\n{\r\nstruct device *dev = chip->chip.dev;\r\nmutex_lock(&chip->lock);\r\nif (!test_bit(irq, chip->used))\r\ndev_err(dev, "trying to free unused MSI#%lu\n", irq);\r\nelse\r\nclear_bit(irq, chip->used);\r\nmutex_unlock(&chip->lock);\r\n}\r\nstatic irqreturn_t tegra_pcie_msi_irq(int irq, void *data)\r\n{\r\nstruct tegra_pcie *pcie = data;\r\nstruct tegra_msi *msi = &pcie->msi;\r\nunsigned int i, processed = 0;\r\nfor (i = 0; i < 8; i++) {\r\nunsigned long reg = afi_readl(pcie, AFI_MSI_VEC0 + i * 4);\r\nwhile (reg) {\r\nunsigned int offset = find_first_bit(&reg, 32);\r\nunsigned int index = i * 32 + offset;\r\nunsigned int irq;\r\nafi_writel(pcie, 1 << offset, AFI_MSI_VEC0 + i * 4);\r\nirq = irq_find_mapping(msi->domain, index);\r\nif (irq) {\r\nif (test_bit(index, msi->used))\r\ngeneric_handle_irq(irq);\r\nelse\r\ndev_info(pcie->dev, "unhandled MSI\n");\r\n} else {\r\ndev_info(pcie->dev, "unexpected MSI\n");\r\n}\r\nreg = afi_readl(pcie, AFI_MSI_VEC0 + i * 4);\r\nprocessed++;\r\n}\r\n}\r\nreturn processed > 0 ? IRQ_HANDLED : IRQ_NONE;\r\n}\r\nstatic int tegra_msi_setup_irq(struct msi_controller *chip,\r\nstruct pci_dev *pdev, struct msi_desc *desc)\r\n{\r\nstruct tegra_msi *msi = to_tegra_msi(chip);\r\nstruct msi_msg msg;\r\nunsigned int irq;\r\nint hwirq;\r\nhwirq = tegra_msi_alloc(msi);\r\nif (hwirq < 0)\r\nreturn hwirq;\r\nirq = irq_create_mapping(msi->domain, hwirq);\r\nif (!irq) {\r\ntegra_msi_free(msi, hwirq);\r\nreturn -EINVAL;\r\n}\r\nirq_set_msi_desc(irq, desc);\r\nmsg.address_lo = virt_to_phys((void *)msi->pages);\r\nmsg.address_hi = 0;\r\nmsg.data = hwirq;\r\npci_write_msi_msg(irq, &msg);\r\nreturn 0;\r\n}\r\nstatic void tegra_msi_teardown_irq(struct msi_controller *chip,\r\nunsigned int irq)\r\n{\r\nstruct tegra_msi *msi = to_tegra_msi(chip);\r\nstruct irq_data *d = irq_get_irq_data(irq);\r\nirq_hw_number_t hwirq = irqd_to_hwirq(d);\r\nirq_dispose_mapping(irq);\r\ntegra_msi_free(msi, hwirq);\r\n}\r\nstatic int tegra_msi_map(struct irq_domain *domain, unsigned int irq,\r\nirq_hw_number_t hwirq)\r\n{\r\nirq_set_chip_and_handler(irq, &tegra_msi_irq_chip, handle_simple_irq);\r\nirq_set_chip_data(irq, domain->host_data);\r\nset_irq_flags(irq, IRQF_VALID);\r\ntegra_cpuidle_pcie_irqs_in_use();\r\nreturn 0;\r\n}\r\nstatic int tegra_pcie_enable_msi(struct tegra_pcie *pcie)\r\n{\r\nstruct platform_device *pdev = to_platform_device(pcie->dev);\r\nconst struct tegra_pcie_soc_data *soc = pcie->soc_data;\r\nstruct tegra_msi *msi = &pcie->msi;\r\nunsigned long base;\r\nint err;\r\nu32 reg;\r\nmutex_init(&msi->lock);\r\nmsi->chip.dev = pcie->dev;\r\nmsi->chip.setup_irq = tegra_msi_setup_irq;\r\nmsi->chip.teardown_irq = tegra_msi_teardown_irq;\r\nmsi->domain = irq_domain_add_linear(pcie->dev->of_node, INT_PCI_MSI_NR,\r\n&msi_domain_ops, &msi->chip);\r\nif (!msi->domain) {\r\ndev_err(&pdev->dev, "failed to create IRQ domain\n");\r\nreturn -ENOMEM;\r\n}\r\nerr = platform_get_irq_byname(pdev, "msi");\r\nif (err < 0) {\r\ndev_err(&pdev->dev, "failed to get IRQ: %d\n", err);\r\ngoto err;\r\n}\r\nmsi->irq = err;\r\nerr = request_irq(msi->irq, tegra_pcie_msi_irq, 0,\r\ntegra_msi_irq_chip.name, pcie);\r\nif (err < 0) {\r\ndev_err(&pdev->dev, "failed to request IRQ: %d\n", err);\r\ngoto err;\r\n}\r\nmsi->pages = __get_free_pages(GFP_KERNEL, 0);\r\nbase = virt_to_phys((void *)msi->pages);\r\nafi_writel(pcie, base >> soc->msi_base_shift, AFI_MSI_FPCI_BAR_ST);\r\nafi_writel(pcie, base, AFI_MSI_AXI_BAR_ST);\r\nafi_writel(pcie, 1, AFI_MSI_BAR_SZ);\r\nafi_writel(pcie, 0xffffffff, AFI_MSI_EN_VEC0);\r\nafi_writel(pcie, 0xffffffff, AFI_MSI_EN_VEC1);\r\nafi_writel(pcie, 0xffffffff, AFI_MSI_EN_VEC2);\r\nafi_writel(pcie, 0xffffffff, AFI_MSI_EN_VEC3);\r\nafi_writel(pcie, 0xffffffff, AFI_MSI_EN_VEC4);\r\nafi_writel(pcie, 0xffffffff, AFI_MSI_EN_VEC5);\r\nafi_writel(pcie, 0xffffffff, AFI_MSI_EN_VEC6);\r\nafi_writel(pcie, 0xffffffff, AFI_MSI_EN_VEC7);\r\nreg = afi_readl(pcie, AFI_INTR_MASK);\r\nreg |= AFI_INTR_MASK_MSI_MASK;\r\nafi_writel(pcie, reg, AFI_INTR_MASK);\r\nreturn 0;\r\nerr:\r\nirq_domain_remove(msi->domain);\r\nreturn err;\r\n}\r\nstatic int tegra_pcie_disable_msi(struct tegra_pcie *pcie)\r\n{\r\nstruct tegra_msi *msi = &pcie->msi;\r\nunsigned int i, irq;\r\nu32 value;\r\nvalue = afi_readl(pcie, AFI_INTR_MASK);\r\nvalue &= ~AFI_INTR_MASK_MSI_MASK;\r\nafi_writel(pcie, value, AFI_INTR_MASK);\r\nafi_writel(pcie, 0, AFI_MSI_EN_VEC0);\r\nafi_writel(pcie, 0, AFI_MSI_EN_VEC1);\r\nafi_writel(pcie, 0, AFI_MSI_EN_VEC2);\r\nafi_writel(pcie, 0, AFI_MSI_EN_VEC3);\r\nafi_writel(pcie, 0, AFI_MSI_EN_VEC4);\r\nafi_writel(pcie, 0, AFI_MSI_EN_VEC5);\r\nafi_writel(pcie, 0, AFI_MSI_EN_VEC6);\r\nafi_writel(pcie, 0, AFI_MSI_EN_VEC7);\r\nfree_pages(msi->pages, 0);\r\nif (msi->irq > 0)\r\nfree_irq(msi->irq, pcie);\r\nfor (i = 0; i < INT_PCI_MSI_NR; i++) {\r\nirq = irq_find_mapping(msi->domain, i);\r\nif (irq > 0)\r\nirq_dispose_mapping(irq);\r\n}\r\nirq_domain_remove(msi->domain);\r\nreturn 0;\r\n}\r\nstatic int tegra_pcie_get_xbar_config(struct tegra_pcie *pcie, u32 lanes,\r\nu32 *xbar)\r\n{\r\nstruct device_node *np = pcie->dev->of_node;\r\nif (of_device_is_compatible(np, "nvidia,tegra124-pcie")) {\r\nswitch (lanes) {\r\ncase 0x0000104:\r\ndev_info(pcie->dev, "4x1, 1x1 configuration\n");\r\n*xbar = AFI_PCIE_CONFIG_SM2TMS0_XBAR_CONFIG_X4_X1;\r\nreturn 0;\r\ncase 0x0000102:\r\ndev_info(pcie->dev, "2x1, 1x1 configuration\n");\r\n*xbar = AFI_PCIE_CONFIG_SM2TMS0_XBAR_CONFIG_X2_X1;\r\nreturn 0;\r\n}\r\n} else if (of_device_is_compatible(np, "nvidia,tegra30-pcie")) {\r\nswitch (lanes) {\r\ncase 0x00000204:\r\ndev_info(pcie->dev, "4x1, 2x1 configuration\n");\r\n*xbar = AFI_PCIE_CONFIG_SM2TMS0_XBAR_CONFIG_420;\r\nreturn 0;\r\ncase 0x00020202:\r\ndev_info(pcie->dev, "2x3 configuration\n");\r\n*xbar = AFI_PCIE_CONFIG_SM2TMS0_XBAR_CONFIG_222;\r\nreturn 0;\r\ncase 0x00010104:\r\ndev_info(pcie->dev, "4x1, 1x2 configuration\n");\r\n*xbar = AFI_PCIE_CONFIG_SM2TMS0_XBAR_CONFIG_411;\r\nreturn 0;\r\n}\r\n} else if (of_device_is_compatible(np, "nvidia,tegra20-pcie")) {\r\nswitch (lanes) {\r\ncase 0x00000004:\r\ndev_info(pcie->dev, "single-mode configuration\n");\r\n*xbar = AFI_PCIE_CONFIG_SM2TMS0_XBAR_CONFIG_SINGLE;\r\nreturn 0;\r\ncase 0x00000202:\r\ndev_info(pcie->dev, "dual-mode configuration\n");\r\n*xbar = AFI_PCIE_CONFIG_SM2TMS0_XBAR_CONFIG_DUAL;\r\nreturn 0;\r\n}\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic bool of_regulator_bulk_available(struct device_node *np,\r\nstruct regulator_bulk_data *supplies,\r\nunsigned int num_supplies)\r\n{\r\nchar property[32];\r\nunsigned int i;\r\nfor (i = 0; i < num_supplies; i++) {\r\nsnprintf(property, 32, "%s-supply", supplies[i].supply);\r\nif (of_find_property(np, property, NULL) == NULL)\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\nstatic int tegra_pcie_get_legacy_regulators(struct tegra_pcie *pcie)\r\n{\r\nstruct device_node *np = pcie->dev->of_node;\r\nif (of_device_is_compatible(np, "nvidia,tegra30-pcie"))\r\npcie->num_supplies = 3;\r\nelse if (of_device_is_compatible(np, "nvidia,tegra20-pcie"))\r\npcie->num_supplies = 2;\r\nif (pcie->num_supplies == 0) {\r\ndev_err(pcie->dev, "device %s not supported in legacy mode\n",\r\nnp->full_name);\r\nreturn -ENODEV;\r\n}\r\npcie->supplies = devm_kcalloc(pcie->dev, pcie->num_supplies,\r\nsizeof(*pcie->supplies),\r\nGFP_KERNEL);\r\nif (!pcie->supplies)\r\nreturn -ENOMEM;\r\npcie->supplies[0].supply = "pex-clk";\r\npcie->supplies[1].supply = "vdd";\r\nif (pcie->num_supplies > 2)\r\npcie->supplies[2].supply = "avdd";\r\nreturn devm_regulator_bulk_get(pcie->dev, pcie->num_supplies,\r\npcie->supplies);\r\n}\r\nstatic int tegra_pcie_get_regulators(struct tegra_pcie *pcie, u32 lane_mask)\r\n{\r\nstruct device_node *np = pcie->dev->of_node;\r\nunsigned int i = 0;\r\nif (of_device_is_compatible(np, "nvidia,tegra124-pcie")) {\r\npcie->num_supplies = 7;\r\npcie->supplies = devm_kcalloc(pcie->dev, pcie->num_supplies,\r\nsizeof(*pcie->supplies),\r\nGFP_KERNEL);\r\nif (!pcie->supplies)\r\nreturn -ENOMEM;\r\npcie->supplies[i++].supply = "avddio-pex";\r\npcie->supplies[i++].supply = "dvddio-pex";\r\npcie->supplies[i++].supply = "avdd-pex-pll";\r\npcie->supplies[i++].supply = "hvdd-pex";\r\npcie->supplies[i++].supply = "hvdd-pex-pll-e";\r\npcie->supplies[i++].supply = "vddio-pex-ctl";\r\npcie->supplies[i++].supply = "avdd-pll-erefe";\r\n} else if (of_device_is_compatible(np, "nvidia,tegra30-pcie")) {\r\nbool need_pexa = false, need_pexb = false;\r\nif (lane_mask & 0x0f)\r\nneed_pexa = true;\r\nif (lane_mask & 0x30)\r\nneed_pexb = true;\r\npcie->num_supplies = 4 + (need_pexa ? 2 : 0) +\r\n(need_pexb ? 2 : 0);\r\npcie->supplies = devm_kcalloc(pcie->dev, pcie->num_supplies,\r\nsizeof(*pcie->supplies),\r\nGFP_KERNEL);\r\nif (!pcie->supplies)\r\nreturn -ENOMEM;\r\npcie->supplies[i++].supply = "avdd-pex-pll";\r\npcie->supplies[i++].supply = "hvdd-pex";\r\npcie->supplies[i++].supply = "vddio-pex-ctl";\r\npcie->supplies[i++].supply = "avdd-plle";\r\nif (need_pexa) {\r\npcie->supplies[i++].supply = "avdd-pexa";\r\npcie->supplies[i++].supply = "vdd-pexa";\r\n}\r\nif (need_pexb) {\r\npcie->supplies[i++].supply = "avdd-pexb";\r\npcie->supplies[i++].supply = "vdd-pexb";\r\n}\r\n} else if (of_device_is_compatible(np, "nvidia,tegra20-pcie")) {\r\npcie->num_supplies = 5;\r\npcie->supplies = devm_kcalloc(pcie->dev, pcie->num_supplies,\r\nsizeof(*pcie->supplies),\r\nGFP_KERNEL);\r\nif (!pcie->supplies)\r\nreturn -ENOMEM;\r\npcie->supplies[0].supply = "avdd-pex";\r\npcie->supplies[1].supply = "vdd-pex";\r\npcie->supplies[2].supply = "avdd-pex-pll";\r\npcie->supplies[3].supply = "avdd-plle";\r\npcie->supplies[4].supply = "vddio-pex-clk";\r\n}\r\nif (of_regulator_bulk_available(pcie->dev->of_node, pcie->supplies,\r\npcie->num_supplies))\r\nreturn devm_regulator_bulk_get(pcie->dev, pcie->num_supplies,\r\npcie->supplies);\r\ndev_info(pcie->dev, "using legacy DT binding for power supplies\n");\r\ndevm_kfree(pcie->dev, pcie->supplies);\r\npcie->num_supplies = 0;\r\nreturn tegra_pcie_get_legacy_regulators(pcie);\r\n}\r\nstatic int tegra_pcie_parse_dt(struct tegra_pcie *pcie)\r\n{\r\nconst struct tegra_pcie_soc_data *soc = pcie->soc_data;\r\nstruct device_node *np = pcie->dev->of_node, *port;\r\nstruct of_pci_range_parser parser;\r\nstruct of_pci_range range;\r\nu32 lanes = 0, mask = 0;\r\nunsigned int lane = 0;\r\nstruct resource res;\r\nint err;\r\nmemset(&pcie->all, 0, sizeof(pcie->all));\r\npcie->all.flags = IORESOURCE_MEM;\r\npcie->all.name = np->full_name;\r\npcie->all.start = ~0;\r\npcie->all.end = 0;\r\nif (of_pci_range_parser_init(&parser, np)) {\r\ndev_err(pcie->dev, "missing \"ranges\" property\n");\r\nreturn -EINVAL;\r\n}\r\nfor_each_of_pci_range(&parser, &range) {\r\nerr = of_pci_range_to_resource(&range, np, &res);\r\nif (err < 0)\r\nreturn err;\r\nswitch (res.flags & IORESOURCE_TYPE_BITS) {\r\ncase IORESOURCE_IO:\r\nmemcpy(&pcie->pio, &res, sizeof(res));\r\npcie->pio.name = np->full_name;\r\npcie->io.start = range.cpu_addr;\r\npcie->io.end = range.cpu_addr + range.size - 1;\r\npcie->io.flags = IORESOURCE_MEM;\r\npcie->io.name = "I/O";\r\nmemcpy(&res, &pcie->io, sizeof(res));\r\nbreak;\r\ncase IORESOURCE_MEM:\r\nif (res.flags & IORESOURCE_PREFETCH) {\r\nmemcpy(&pcie->prefetch, &res, sizeof(res));\r\npcie->prefetch.name = "prefetchable";\r\n} else {\r\nmemcpy(&pcie->mem, &res, sizeof(res));\r\npcie->mem.name = "non-prefetchable";\r\n}\r\nbreak;\r\n}\r\nif (res.start <= pcie->all.start)\r\npcie->all.start = res.start;\r\nif (res.end >= pcie->all.end)\r\npcie->all.end = res.end;\r\n}\r\nerr = devm_request_resource(pcie->dev, &iomem_resource, &pcie->all);\r\nif (err < 0)\r\nreturn err;\r\nerr = of_pci_parse_bus_range(np, &pcie->busn);\r\nif (err < 0) {\r\ndev_err(pcie->dev, "failed to parse ranges property: %d\n",\r\nerr);\r\npcie->busn.name = np->name;\r\npcie->busn.start = 0;\r\npcie->busn.end = 0xff;\r\npcie->busn.flags = IORESOURCE_BUS;\r\n}\r\nfor_each_child_of_node(np, port) {\r\nstruct tegra_pcie_port *rp;\r\nunsigned int index;\r\nu32 value;\r\nerr = of_pci_get_devfn(port);\r\nif (err < 0) {\r\ndev_err(pcie->dev, "failed to parse address: %d\n",\r\nerr);\r\nreturn err;\r\n}\r\nindex = PCI_SLOT(err);\r\nif (index < 1 || index > soc->num_ports) {\r\ndev_err(pcie->dev, "invalid port number: %d\n", index);\r\nreturn -EINVAL;\r\n}\r\nindex--;\r\nerr = of_property_read_u32(port, "nvidia,num-lanes", &value);\r\nif (err < 0) {\r\ndev_err(pcie->dev, "failed to parse # of lanes: %d\n",\r\nerr);\r\nreturn err;\r\n}\r\nif (value > 16) {\r\ndev_err(pcie->dev, "invalid # of lanes: %u\n", value);\r\nreturn -EINVAL;\r\n}\r\nlanes |= value << (index << 3);\r\nif (!of_device_is_available(port)) {\r\nlane += value;\r\ncontinue;\r\n}\r\nmask |= ((1 << value) - 1) << lane;\r\nlane += value;\r\nrp = devm_kzalloc(pcie->dev, sizeof(*rp), GFP_KERNEL);\r\nif (!rp)\r\nreturn -ENOMEM;\r\nerr = of_address_to_resource(port, 0, &rp->regs);\r\nif (err < 0) {\r\ndev_err(pcie->dev, "failed to parse address: %d\n",\r\nerr);\r\nreturn err;\r\n}\r\nINIT_LIST_HEAD(&rp->list);\r\nrp->index = index;\r\nrp->lanes = value;\r\nrp->pcie = pcie;\r\nrp->base = devm_ioremap_resource(pcie->dev, &rp->regs);\r\nif (IS_ERR(rp->base))\r\nreturn PTR_ERR(rp->base);\r\nlist_add_tail(&rp->list, &pcie->ports);\r\n}\r\nerr = tegra_pcie_get_xbar_config(pcie, lanes, &pcie->xbar_config);\r\nif (err < 0) {\r\ndev_err(pcie->dev, "invalid lane configuration\n");\r\nreturn err;\r\n}\r\nerr = tegra_pcie_get_regulators(pcie, mask);\r\nif (err < 0)\r\nreturn err;\r\nreturn 0;\r\n}\r\nstatic bool tegra_pcie_port_check_link(struct tegra_pcie_port *port)\r\n{\r\nunsigned int retries = 3;\r\nunsigned long value;\r\nvalue = readl(port->base + RP_PRIV_MISC);\r\nvalue &= ~RP_PRIV_MISC_PRSNT_MAP_EP_ABSNT;\r\nvalue |= RP_PRIV_MISC_PRSNT_MAP_EP_PRSNT;\r\nwritel(value, port->base + RP_PRIV_MISC);\r\ndo {\r\nunsigned int timeout = TEGRA_PCIE_LINKUP_TIMEOUT;\r\ndo {\r\nvalue = readl(port->base + RP_VEND_XP);\r\nif (value & RP_VEND_XP_DL_UP)\r\nbreak;\r\nusleep_range(1000, 2000);\r\n} while (--timeout);\r\nif (!timeout) {\r\ndev_err(port->pcie->dev, "link %u down, retrying\n",\r\nport->index);\r\ngoto retry;\r\n}\r\ntimeout = TEGRA_PCIE_LINKUP_TIMEOUT;\r\ndo {\r\nvalue = readl(port->base + RP_LINK_CONTROL_STATUS);\r\nif (value & RP_LINK_CONTROL_STATUS_DL_LINK_ACTIVE)\r\nreturn true;\r\nusleep_range(1000, 2000);\r\n} while (--timeout);\r\nretry:\r\ntegra_pcie_port_reset(port);\r\n} while (--retries);\r\nreturn false;\r\n}\r\nstatic int tegra_pcie_enable(struct tegra_pcie *pcie)\r\n{\r\nstruct tegra_pcie_port *port, *tmp;\r\nstruct hw_pci hw;\r\nlist_for_each_entry_safe(port, tmp, &pcie->ports, list) {\r\ndev_info(pcie->dev, "probing port %u, using %u lanes\n",\r\nport->index, port->lanes);\r\ntegra_pcie_port_enable(port);\r\nif (tegra_pcie_port_check_link(port))\r\ncontinue;\r\ndev_info(pcie->dev, "link %u down, ignoring\n", port->index);\r\ntegra_pcie_port_disable(port);\r\ntegra_pcie_port_free(port);\r\n}\r\nmemset(&hw, 0, sizeof(hw));\r\n#ifdef CONFIG_PCI_MSI\r\nhw.msi_ctrl = &pcie->msi.chip;\r\n#endif\r\nhw.nr_controllers = 1;\r\nhw.private_data = (void **)&pcie;\r\nhw.setup = tegra_pcie_setup;\r\nhw.map_irq = tegra_pcie_map_irq;\r\nhw.scan = tegra_pcie_scan_bus;\r\nhw.ops = &tegra_pcie_ops;\r\npci_common_init_dev(pcie->dev, &hw);\r\nreturn 0;\r\n}\r\nstatic void *tegra_pcie_ports_seq_start(struct seq_file *s, loff_t *pos)\r\n{\r\nstruct tegra_pcie *pcie = s->private;\r\nif (list_empty(&pcie->ports))\r\nreturn NULL;\r\nseq_printf(s, "Index Status\n");\r\nreturn seq_list_start(&pcie->ports, *pos);\r\n}\r\nstatic void *tegra_pcie_ports_seq_next(struct seq_file *s, void *v, loff_t *pos)\r\n{\r\nstruct tegra_pcie *pcie = s->private;\r\nreturn seq_list_next(v, &pcie->ports, pos);\r\n}\r\nstatic void tegra_pcie_ports_seq_stop(struct seq_file *s, void *v)\r\n{\r\n}\r\nstatic int tegra_pcie_ports_seq_show(struct seq_file *s, void *v)\r\n{\r\nbool up = false, active = false;\r\nstruct tegra_pcie_port *port;\r\nunsigned int value;\r\nport = list_entry(v, struct tegra_pcie_port, list);\r\nvalue = readl(port->base + RP_VEND_XP);\r\nif (value & RP_VEND_XP_DL_UP)\r\nup = true;\r\nvalue = readl(port->base + RP_LINK_CONTROL_STATUS);\r\nif (value & RP_LINK_CONTROL_STATUS_DL_LINK_ACTIVE)\r\nactive = true;\r\nseq_printf(s, "%2u ", port->index);\r\nif (up)\r\nseq_printf(s, "up");\r\nif (active) {\r\nif (up)\r\nseq_printf(s, ", ");\r\nseq_printf(s, "active");\r\n}\r\nseq_printf(s, "\n");\r\nreturn 0;\r\n}\r\nstatic int tegra_pcie_ports_open(struct inode *inode, struct file *file)\r\n{\r\nstruct tegra_pcie *pcie = inode->i_private;\r\nstruct seq_file *s;\r\nint err;\r\nerr = seq_open(file, &tegra_pcie_ports_seq_ops);\r\nif (err)\r\nreturn err;\r\ns = file->private_data;\r\ns->private = pcie;\r\nreturn 0;\r\n}\r\nstatic int tegra_pcie_debugfs_init(struct tegra_pcie *pcie)\r\n{\r\nstruct dentry *file;\r\npcie->debugfs = debugfs_create_dir("pcie", NULL);\r\nif (!pcie->debugfs)\r\nreturn -ENOMEM;\r\nfile = debugfs_create_file("ports", S_IFREG | S_IRUGO, pcie->debugfs,\r\npcie, &tegra_pcie_ports_ops);\r\nif (!file)\r\ngoto remove;\r\nreturn 0;\r\nremove:\r\ndebugfs_remove_recursive(pcie->debugfs);\r\npcie->debugfs = NULL;\r\nreturn -ENOMEM;\r\n}\r\nstatic int tegra_pcie_probe(struct platform_device *pdev)\r\n{\r\nconst struct of_device_id *match;\r\nstruct tegra_pcie *pcie;\r\nint err;\r\nmatch = of_match_device(tegra_pcie_of_match, &pdev->dev);\r\nif (!match)\r\nreturn -ENODEV;\r\npcie = devm_kzalloc(&pdev->dev, sizeof(*pcie), GFP_KERNEL);\r\nif (!pcie)\r\nreturn -ENOMEM;\r\nINIT_LIST_HEAD(&pcie->buses);\r\nINIT_LIST_HEAD(&pcie->ports);\r\npcie->soc_data = match->data;\r\npcie->dev = &pdev->dev;\r\nerr = tegra_pcie_parse_dt(pcie);\r\nif (err < 0)\r\nreturn err;\r\npcibios_min_mem = 0;\r\nerr = tegra_pcie_get_resources(pcie);\r\nif (err < 0) {\r\ndev_err(&pdev->dev, "failed to request resources: %d\n", err);\r\nreturn err;\r\n}\r\nerr = tegra_pcie_enable_controller(pcie);\r\nif (err)\r\ngoto put_resources;\r\ntegra_pcie_setup_translations(pcie);\r\nif (IS_ENABLED(CONFIG_PCI_MSI)) {\r\nerr = tegra_pcie_enable_msi(pcie);\r\nif (err < 0) {\r\ndev_err(&pdev->dev,\r\n"failed to enable MSI support: %d\n",\r\nerr);\r\ngoto put_resources;\r\n}\r\n}\r\nerr = tegra_pcie_enable(pcie);\r\nif (err < 0) {\r\ndev_err(&pdev->dev, "failed to enable PCIe ports: %d\n", err);\r\ngoto disable_msi;\r\n}\r\nif (IS_ENABLED(CONFIG_DEBUG_FS)) {\r\nerr = tegra_pcie_debugfs_init(pcie);\r\nif (err < 0)\r\ndev_err(&pdev->dev, "failed to setup debugfs: %d\n",\r\nerr);\r\n}\r\nplatform_set_drvdata(pdev, pcie);\r\nreturn 0;\r\ndisable_msi:\r\nif (IS_ENABLED(CONFIG_PCI_MSI))\r\ntegra_pcie_disable_msi(pcie);\r\nput_resources:\r\ntegra_pcie_put_resources(pcie);\r\nreturn err;\r\n}
