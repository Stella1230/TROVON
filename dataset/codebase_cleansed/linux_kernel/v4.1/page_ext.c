static bool __init invoke_need_callbacks(void)\r\n{\r\nint i;\r\nint entries = ARRAY_SIZE(page_ext_ops);\r\nfor (i = 0; i < entries; i++) {\r\nif (page_ext_ops[i]->need && page_ext_ops[i]->need())\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic void __init invoke_init_callbacks(void)\r\n{\r\nint i;\r\nint entries = ARRAY_SIZE(page_ext_ops);\r\nfor (i = 0; i < entries; i++) {\r\nif (page_ext_ops[i]->init)\r\npage_ext_ops[i]->init();\r\n}\r\n}\r\nvoid __meminit pgdat_page_ext_init(struct pglist_data *pgdat)\r\n{\r\npgdat->node_page_ext = NULL;\r\n}\r\nstruct page_ext *lookup_page_ext(struct page *page)\r\n{\r\nunsigned long pfn = page_to_pfn(page);\r\nunsigned long offset;\r\nstruct page_ext *base;\r\nbase = NODE_DATA(page_to_nid(page))->node_page_ext;\r\n#ifdef CONFIG_DEBUG_VM\r\nif (unlikely(!base))\r\nreturn NULL;\r\n#endif\r\noffset = pfn - round_down(node_start_pfn(page_to_nid(page)),\r\nMAX_ORDER_NR_PAGES);\r\nreturn base + offset;\r\n}\r\nstatic int __init alloc_node_page_ext(int nid)\r\n{\r\nstruct page_ext *base;\r\nunsigned long table_size;\r\nunsigned long nr_pages;\r\nnr_pages = NODE_DATA(nid)->node_spanned_pages;\r\nif (!nr_pages)\r\nreturn 0;\r\nif (!IS_ALIGNED(node_start_pfn(nid), MAX_ORDER_NR_PAGES) ||\r\n!IS_ALIGNED(node_end_pfn(nid), MAX_ORDER_NR_PAGES))\r\nnr_pages += MAX_ORDER_NR_PAGES;\r\ntable_size = sizeof(struct page_ext) * nr_pages;\r\nbase = memblock_virt_alloc_try_nid_nopanic(\r\ntable_size, PAGE_SIZE, __pa(MAX_DMA_ADDRESS),\r\nBOOTMEM_ALLOC_ACCESSIBLE, nid);\r\nif (!base)\r\nreturn -ENOMEM;\r\nNODE_DATA(nid)->node_page_ext = base;\r\ntotal_usage += table_size;\r\nreturn 0;\r\n}\r\nvoid __init page_ext_init_flatmem(void)\r\n{\r\nint nid, fail;\r\nif (!invoke_need_callbacks())\r\nreturn;\r\nfor_each_online_node(nid) {\r\nfail = alloc_node_page_ext(nid);\r\nif (fail)\r\ngoto fail;\r\n}\r\npr_info("allocated %ld bytes of page_ext\n", total_usage);\r\ninvoke_init_callbacks();\r\nreturn;\r\nfail:\r\npr_crit("allocation of page_ext failed.\n");\r\npanic("Out of memory");\r\n}\r\nstruct page_ext *lookup_page_ext(struct page *page)\r\n{\r\nunsigned long pfn = page_to_pfn(page);\r\nstruct mem_section *section = __pfn_to_section(pfn);\r\n#ifdef CONFIG_DEBUG_VM\r\nif (!section->page_ext)\r\nreturn NULL;\r\n#endif\r\nreturn section->page_ext + pfn;\r\n}\r\nstatic void *__meminit alloc_page_ext(size_t size, int nid)\r\n{\r\ngfp_t flags = GFP_KERNEL | __GFP_ZERO | __GFP_NOWARN;\r\nvoid *addr = NULL;\r\naddr = alloc_pages_exact_nid(nid, size, flags);\r\nif (addr) {\r\nkmemleak_alloc(addr, size, 1, flags);\r\nreturn addr;\r\n}\r\nif (node_state(nid, N_HIGH_MEMORY))\r\naddr = vzalloc_node(size, nid);\r\nelse\r\naddr = vzalloc(size);\r\nreturn addr;\r\n}\r\nstatic int __meminit init_section_page_ext(unsigned long pfn, int nid)\r\n{\r\nstruct mem_section *section;\r\nstruct page_ext *base;\r\nunsigned long table_size;\r\nsection = __pfn_to_section(pfn);\r\nif (section->page_ext)\r\nreturn 0;\r\ntable_size = sizeof(struct page_ext) * PAGES_PER_SECTION;\r\nbase = alloc_page_ext(table_size, nid);\r\nkmemleak_not_leak(base);\r\nif (!base) {\r\npr_err("page ext allocation failure\n");\r\nreturn -ENOMEM;\r\n}\r\npfn &= PAGE_SECTION_MASK;\r\nsection->page_ext = base - pfn;\r\ntotal_usage += table_size;\r\nreturn 0;\r\n}\r\nstatic void free_page_ext(void *addr)\r\n{\r\nif (is_vmalloc_addr(addr)) {\r\nvfree(addr);\r\n} else {\r\nstruct page *page = virt_to_page(addr);\r\nsize_t table_size;\r\ntable_size = sizeof(struct page_ext) * PAGES_PER_SECTION;\r\nBUG_ON(PageReserved(page));\r\nfree_pages_exact(addr, table_size);\r\n}\r\n}\r\nstatic void __free_page_ext(unsigned long pfn)\r\n{\r\nstruct mem_section *ms;\r\nstruct page_ext *base;\r\nms = __pfn_to_section(pfn);\r\nif (!ms || !ms->page_ext)\r\nreturn;\r\nbase = ms->page_ext + pfn;\r\nfree_page_ext(base);\r\nms->page_ext = NULL;\r\n}\r\nstatic int __meminit online_page_ext(unsigned long start_pfn,\r\nunsigned long nr_pages,\r\nint nid)\r\n{\r\nunsigned long start, end, pfn;\r\nint fail = 0;\r\nstart = SECTION_ALIGN_DOWN(start_pfn);\r\nend = SECTION_ALIGN_UP(start_pfn + nr_pages);\r\nif (nid == -1) {\r\nnid = pfn_to_nid(start_pfn);\r\nVM_BUG_ON(!node_state(nid, N_ONLINE));\r\n}\r\nfor (pfn = start; !fail && pfn < end; pfn += PAGES_PER_SECTION) {\r\nif (!pfn_present(pfn))\r\ncontinue;\r\nfail = init_section_page_ext(pfn, nid);\r\n}\r\nif (!fail)\r\nreturn 0;\r\nfor (pfn = start; pfn < end; pfn += PAGES_PER_SECTION)\r\n__free_page_ext(pfn);\r\nreturn -ENOMEM;\r\n}\r\nstatic int __meminit offline_page_ext(unsigned long start_pfn,\r\nunsigned long nr_pages, int nid)\r\n{\r\nunsigned long start, end, pfn;\r\nstart = SECTION_ALIGN_DOWN(start_pfn);\r\nend = SECTION_ALIGN_UP(start_pfn + nr_pages);\r\nfor (pfn = start; pfn < end; pfn += PAGES_PER_SECTION)\r\n__free_page_ext(pfn);\r\nreturn 0;\r\n}\r\nstatic int __meminit page_ext_callback(struct notifier_block *self,\r\nunsigned long action, void *arg)\r\n{\r\nstruct memory_notify *mn = arg;\r\nint ret = 0;\r\nswitch (action) {\r\ncase MEM_GOING_ONLINE:\r\nret = online_page_ext(mn->start_pfn,\r\nmn->nr_pages, mn->status_change_nid);\r\nbreak;\r\ncase MEM_OFFLINE:\r\noffline_page_ext(mn->start_pfn,\r\nmn->nr_pages, mn->status_change_nid);\r\nbreak;\r\ncase MEM_CANCEL_ONLINE:\r\noffline_page_ext(mn->start_pfn,\r\nmn->nr_pages, mn->status_change_nid);\r\nbreak;\r\ncase MEM_GOING_OFFLINE:\r\nbreak;\r\ncase MEM_ONLINE:\r\ncase MEM_CANCEL_OFFLINE:\r\nbreak;\r\n}\r\nreturn notifier_from_errno(ret);\r\n}\r\nvoid __init page_ext_init(void)\r\n{\r\nunsigned long pfn;\r\nint nid;\r\nif (!invoke_need_callbacks())\r\nreturn;\r\nfor_each_node_state(nid, N_MEMORY) {\r\nunsigned long start_pfn, end_pfn;\r\nstart_pfn = node_start_pfn(nid);\r\nend_pfn = node_end_pfn(nid);\r\nfor (pfn = start_pfn; pfn < end_pfn;\r\npfn = ALIGN(pfn + 1, PAGES_PER_SECTION)) {\r\nif (!pfn_valid(pfn))\r\ncontinue;\r\nif (pfn_to_nid(pfn) != nid)\r\ncontinue;\r\nif (init_section_page_ext(pfn, nid))\r\ngoto oom;\r\n}\r\n}\r\nhotplug_memory_notifier(page_ext_callback, 0);\r\npr_info("allocated %ld bytes of page_ext\n", total_usage);\r\ninvoke_init_callbacks();\r\nreturn;\r\noom:\r\npanic("Out of memory");\r\n}\r\nvoid __meminit pgdat_page_ext_init(struct pglist_data *pgdat)\r\n{\r\n}
