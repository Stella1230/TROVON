int kv_notify_message_to_smu(struct radeon_device *rdev, u32 id)\r\n{\r\nu32 i;\r\nu32 tmp = 0;\r\nWREG32(SMC_MESSAGE_0, id & SMC_MSG_MASK);\r\nfor (i = 0; i < rdev->usec_timeout; i++) {\r\nif ((RREG32(SMC_RESP_0) & SMC_RESP_MASK) != 0)\r\nbreak;\r\nudelay(1);\r\n}\r\ntmp = RREG32(SMC_RESP_0) & SMC_RESP_MASK;\r\nif (tmp != 1) {\r\nif (tmp == 0xFF)\r\nreturn -EINVAL;\r\nelse if (tmp == 0xFE)\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nint kv_dpm_get_enable_mask(struct radeon_device *rdev, u32 *enable_mask)\r\n{\r\nint ret;\r\nret = kv_notify_message_to_smu(rdev, PPSMC_MSG_SCLKDPM_GetEnabledMask);\r\nif (ret == 0)\r\n*enable_mask = RREG32_SMC(SMC_SYSCON_MSG_ARG_0);\r\nreturn ret;\r\n}\r\nint kv_send_msg_to_smc_with_parameter(struct radeon_device *rdev,\r\nPPSMC_Msg msg, u32 parameter)\r\n{\r\nWREG32(SMC_MSG_ARG_0, parameter);\r\nreturn kv_notify_message_to_smu(rdev, msg);\r\n}\r\nstatic int kv_set_smc_sram_address(struct radeon_device *rdev,\r\nu32 smc_address, u32 limit)\r\n{\r\nif (smc_address & 3)\r\nreturn -EINVAL;\r\nif ((smc_address + 3) > limit)\r\nreturn -EINVAL;\r\nWREG32(SMC_IND_INDEX_0, smc_address);\r\nWREG32_P(SMC_IND_ACCESS_CNTL, 0, ~AUTO_INCREMENT_IND_0);\r\nreturn 0;\r\n}\r\nint kv_read_smc_sram_dword(struct radeon_device *rdev, u32 smc_address,\r\nu32 *value, u32 limit)\r\n{\r\nint ret;\r\nret = kv_set_smc_sram_address(rdev, smc_address, limit);\r\nif (ret)\r\nreturn ret;\r\n*value = RREG32(SMC_IND_DATA_0);\r\nreturn 0;\r\n}\r\nint kv_smc_dpm_enable(struct radeon_device *rdev, bool enable)\r\n{\r\nif (enable)\r\nreturn kv_notify_message_to_smu(rdev, PPSMC_MSG_DPM_Enable);\r\nelse\r\nreturn kv_notify_message_to_smu(rdev, PPSMC_MSG_DPM_Disable);\r\n}\r\nint kv_smc_bapm_enable(struct radeon_device *rdev, bool enable)\r\n{\r\nif (enable)\r\nreturn kv_notify_message_to_smu(rdev, PPSMC_MSG_EnableBAPM);\r\nelse\r\nreturn kv_notify_message_to_smu(rdev, PPSMC_MSG_DisableBAPM);\r\n}\r\nint kv_copy_bytes_to_smc(struct radeon_device *rdev,\r\nu32 smc_start_address,\r\nconst u8 *src, u32 byte_count, u32 limit)\r\n{\r\nint ret;\r\nu32 data, original_data, addr, extra_shift, t_byte, count, mask;\r\nif ((smc_start_address + byte_count) > limit)\r\nreturn -EINVAL;\r\naddr = smc_start_address;\r\nt_byte = addr & 3;\r\nif (t_byte != 0) {\r\naddr -= t_byte;\r\nret = kv_set_smc_sram_address(rdev, addr, limit);\r\nif (ret)\r\nreturn ret;\r\noriginal_data = RREG32(SMC_IND_DATA_0);\r\ndata = 0;\r\nmask = 0;\r\ncount = 4;\r\nwhile (count > 0) {\r\nif (t_byte > 0) {\r\nmask = (mask << 8) | 0xff;\r\nt_byte--;\r\n} else if (byte_count > 0) {\r\ndata = (data << 8) + *src++;\r\nbyte_count--;\r\nmask <<= 8;\r\n} else {\r\ndata <<= 8;\r\nmask = (mask << 8) | 0xff;\r\n}\r\ncount--;\r\n}\r\ndata |= original_data & mask;\r\nret = kv_set_smc_sram_address(rdev, addr, limit);\r\nif (ret)\r\nreturn ret;\r\nWREG32(SMC_IND_DATA_0, data);\r\naddr += 4;\r\n}\r\nwhile (byte_count >= 4) {\r\ndata = (src[0] << 24) + (src[1] << 16) + (src[2] << 8) + src[3];\r\nret = kv_set_smc_sram_address(rdev, addr, limit);\r\nif (ret)\r\nreturn ret;\r\nWREG32(SMC_IND_DATA_0, data);\r\nsrc += 4;\r\nbyte_count -= 4;\r\naddr += 4;\r\n}\r\nif (byte_count > 0) {\r\ndata = 0;\r\nret = kv_set_smc_sram_address(rdev, addr, limit);\r\nif (ret)\r\nreturn ret;\r\noriginal_data= RREG32(SMC_IND_DATA_0);\r\nextra_shift = 8 * (4 - byte_count);\r\nwhile (byte_count > 0) {\r\ndata = (data << 8) + *src++;\r\nbyte_count--;\r\n}\r\ndata <<= extra_shift;\r\ndata |= (original_data & ~((~0UL) << extra_shift));\r\nret = kv_set_smc_sram_address(rdev, addr, limit);\r\nif (ret)\r\nreturn ret;\r\nWREG32(SMC_IND_DATA_0, data);\r\n}\r\nreturn 0;\r\n}
