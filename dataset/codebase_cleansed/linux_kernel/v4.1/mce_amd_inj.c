static int toggle_hw_mce_inject(unsigned int cpu, bool enable)\r\n{\r\nu32 l, h;\r\nint err;\r\nerr = rdmsr_on_cpu(cpu, MSR_K7_HWCR, &l, &h);\r\nif (err) {\r\npr_err("%s: error reading HWCR\n", __func__);\r\nreturn err;\r\n}\r\nenable ? (l |= BIT(18)) : (l &= ~BIT(18));\r\nerr = wrmsr_on_cpu(cpu, MSR_K7_HWCR, l, h);\r\nif (err)\r\npr_err("%s: error writing HWCR\n", __func__);\r\nreturn err;\r\n}\r\nstatic int flags_get(void *data, u64 *val)\r\n{\r\nstruct mce *m = (struct mce *)data;\r\n*val = m->inject_flags;\r\nreturn 0;\r\n}\r\nstatic int flags_set(void *data, u64 val)\r\n{\r\nstruct mce *m = (struct mce *)data;\r\nm->inject_flags = (u8)val;\r\nreturn 0;\r\n}\r\nstatic int inj_extcpu_set(void *data, u64 val)\r\n{\r\nstruct mce *m = (struct mce *)data;\r\nif (val >= nr_cpu_ids || !cpu_online(val)) {\r\npr_err("%s: Invalid CPU: %llu\n", __func__, val);\r\nreturn -EINVAL;\r\n}\r\nm->extcpu = val;\r\nreturn 0;\r\n}\r\nstatic void trigger_mce(void *info)\r\n{\r\nasm volatile("int $18");\r\n}\r\nstatic void do_inject(void)\r\n{\r\nu64 mcg_status = 0;\r\nunsigned int cpu = i_mce.extcpu;\r\nu8 b = i_mce.bank;\r\nif (!(i_mce.inject_flags & MCJ_EXCEPTION)) {\r\namd_decode_mce(NULL, 0, &i_mce);\r\nreturn;\r\n}\r\nget_online_cpus();\r\nif (!cpu_online(cpu))\r\ngoto err;\r\nmcg_status = MCG_STATUS_MCIP | MCG_STATUS_EIPV;\r\nif (!(i_mce.status & MCI_STATUS_PCC))\r\nmcg_status |= MCG_STATUS_RIPV;\r\ntoggle_hw_mce_inject(cpu, true);\r\nwrmsr_on_cpu(cpu, MSR_IA32_MCG_STATUS,\r\n(u32)mcg_status, (u32)(mcg_status >> 32));\r\nwrmsr_on_cpu(cpu, MSR_IA32_MCx_STATUS(b),\r\n(u32)i_mce.status, (u32)(i_mce.status >> 32));\r\nwrmsr_on_cpu(cpu, MSR_IA32_MCx_ADDR(b),\r\n(u32)i_mce.addr, (u32)(i_mce.addr >> 32));\r\nwrmsr_on_cpu(cpu, MSR_IA32_MCx_MISC(b),\r\n(u32)i_mce.misc, (u32)(i_mce.misc >> 32));\r\ntoggle_hw_mce_inject(cpu, false);\r\nsmp_call_function_single(cpu, trigger_mce, NULL, 0);\r\nerr:\r\nput_online_cpus();\r\n}\r\nstatic int inj_bank_set(void *data, u64 val)\r\n{\r\nstruct mce *m = (struct mce *)data;\r\nif (val > 5) {\r\nif (boot_cpu_data.x86 != 0x15 || val > 6) {\r\npr_err("Non-existent MCE bank: %llu\n", val);\r\nreturn -EINVAL;\r\n}\r\n}\r\nm->bank = val;\r\ndo_inject();\r\nreturn 0;\r\n}\r\nstatic int inj_bank_get(void *data, u64 *val)\r\n{\r\nstruct mce *m = (struct mce *)data;\r\n*val = m->bank;\r\nreturn 0;\r\n}\r\nstatic int __init init_mce_inject(void)\r\n{\r\nint i;\r\ndfs_inj = debugfs_create_dir("mce-inject", NULL);\r\nif (!dfs_inj)\r\nreturn -EINVAL;\r\nfor (i = 0; i < ARRAY_SIZE(dfs_fls); i++) {\r\ndfs_fls[i].d = debugfs_create_file(dfs_fls[i].name,\r\nS_IRUSR | S_IWUSR,\r\ndfs_inj,\r\n&i_mce,\r\ndfs_fls[i].fops);\r\nif (!dfs_fls[i].d)\r\ngoto err_dfs_add;\r\n}\r\nreturn 0;\r\nerr_dfs_add:\r\nwhile (--i >= 0)\r\ndebugfs_remove(dfs_fls[i].d);\r\ndebugfs_remove(dfs_inj);\r\ndfs_inj = NULL;\r\nreturn -ENOMEM;\r\n}\r\nstatic void __exit exit_mce_inject(void)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(dfs_fls); i++)\r\ndebugfs_remove(dfs_fls[i].d);\r\nmemset(&dfs_fls, 0, sizeof(dfs_fls));\r\ndebugfs_remove(dfs_inj);\r\ndfs_inj = NULL;\r\n}
