static int\r\nget_resource(u8 *rscs, unsigned int amount,\r\nunsigned int multi, unsigned int *ridx)\r\n{\r\nint i, j, k, n;\r\nfor (i = 0, n = multi; i < amount; i++) {\r\nj = i / 8;\r\nk = i % 8;\r\nif (rscs[j] & ((u8)1 << k)) {\r\nn = multi;\r\ncontinue;\r\n}\r\nif (!(--n))\r\nbreak;\r\n}\r\nif (i >= amount) {\r\nreturn -ENOENT;\r\n}\r\nfor (n = multi; n > 0; n--) {\r\nj = i / 8;\r\nk = i % 8;\r\nrscs[j] |= ((u8)1 << k);\r\ni--;\r\n}\r\n*ridx = i + 1;\r\nreturn 0;\r\n}\r\nstatic int put_resource(u8 *rscs, unsigned int multi, unsigned int idx)\r\n{\r\nunsigned int i, j, k, n;\r\nfor (n = multi, i = idx; n > 0; n--) {\r\nj = i / 8;\r\nk = i % 8;\r\nrscs[j] &= ~((u8)1 << k);\r\ni++;\r\n}\r\nreturn 0;\r\n}\r\nint mgr_get_resource(struct rsc_mgr *mgr, unsigned int n, unsigned int *ridx)\r\n{\r\nint err;\r\nif (n > mgr->avail)\r\nreturn -ENOENT;\r\nerr = get_resource(mgr->rscs, mgr->amount, n, ridx);\r\nif (!err)\r\nmgr->avail -= n;\r\nreturn err;\r\n}\r\nint mgr_put_resource(struct rsc_mgr *mgr, unsigned int n, unsigned int idx)\r\n{\r\nput_resource(mgr->rscs, n, idx);\r\nmgr->avail += n;\r\nreturn 0;\r\n}\r\nstatic int rsc_index(const struct rsc *rsc)\r\n{\r\nreturn rsc->conj;\r\n}\r\nstatic int audio_ring_slot(const struct rsc *rsc)\r\n{\r\nreturn (rsc->conj << 4) + offset_in_audio_slot_block[rsc->type];\r\n}\r\nstatic int rsc_next_conj(struct rsc *rsc)\r\n{\r\nunsigned int i;\r\nfor (i = 0; (i < 8) && (!(rsc->msr & (0x1 << i))); )\r\ni++;\r\nrsc->conj += (AUDIO_SLOT_BLOCK_NUM >> i);\r\nreturn rsc->conj;\r\n}\r\nstatic int rsc_master(struct rsc *rsc)\r\n{\r\nreturn rsc->conj = rsc->idx;\r\n}\r\nint\r\nrsc_init(struct rsc *rsc, u32 idx, enum RSCTYP type, u32 msr, struct hw *hw)\r\n{\r\nint err = 0;\r\nrsc->idx = idx;\r\nrsc->conj = idx;\r\nrsc->type = type;\r\nrsc->msr = msr;\r\nrsc->hw = hw;\r\nrsc->ops = &rsc_generic_ops;\r\nif (!hw) {\r\nrsc->ctrl_blk = NULL;\r\nreturn 0;\r\n}\r\nswitch (type) {\r\ncase SRC:\r\nerr = hw->src_rsc_get_ctrl_blk(&rsc->ctrl_blk);\r\nbreak;\r\ncase AMIXER:\r\nerr = hw->amixer_rsc_get_ctrl_blk(&rsc->ctrl_blk);\r\nbreak;\r\ncase SRCIMP:\r\ncase SUM:\r\ncase DAIO:\r\nbreak;\r\ndefault:\r\ndev_err(((struct hw *)hw)->card->dev,\r\n"Invalid resource type value %d!\n", type);\r\nreturn -EINVAL;\r\n}\r\nif (err) {\r\ndev_err(((struct hw *)hw)->card->dev,\r\n"Failed to get resource control block!\n");\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nint rsc_uninit(struct rsc *rsc)\r\n{\r\nif ((NULL != rsc->hw) && (NULL != rsc->ctrl_blk)) {\r\nswitch (rsc->type) {\r\ncase SRC:\r\nrsc->hw->src_rsc_put_ctrl_blk(rsc->ctrl_blk);\r\nbreak;\r\ncase AMIXER:\r\nrsc->hw->amixer_rsc_put_ctrl_blk(rsc->ctrl_blk);\r\nbreak;\r\ncase SUM:\r\ncase DAIO:\r\nbreak;\r\ndefault:\r\ndev_err(((struct hw *)rsc->hw)->card->dev,\r\n"Invalid resource type value %d!\n",\r\nrsc->type);\r\nbreak;\r\n}\r\nrsc->hw = rsc->ctrl_blk = NULL;\r\n}\r\nrsc->idx = rsc->conj = 0;\r\nrsc->type = NUM_RSCTYP;\r\nrsc->msr = 0;\r\nreturn 0;\r\n}\r\nint rsc_mgr_init(struct rsc_mgr *mgr, enum RSCTYP type,\r\nunsigned int amount, struct hw *hw)\r\n{\r\nint err = 0;\r\nmgr->type = NUM_RSCTYP;\r\nmgr->rscs = kzalloc(((amount + 8 - 1) / 8), GFP_KERNEL);\r\nif (!mgr->rscs)\r\nreturn -ENOMEM;\r\nswitch (type) {\r\ncase SRC:\r\nerr = hw->src_mgr_get_ctrl_blk(&mgr->ctrl_blk);\r\nbreak;\r\ncase SRCIMP:\r\nerr = hw->srcimp_mgr_get_ctrl_blk(&mgr->ctrl_blk);\r\nbreak;\r\ncase AMIXER:\r\nerr = hw->amixer_mgr_get_ctrl_blk(&mgr->ctrl_blk);\r\nbreak;\r\ncase DAIO:\r\nerr = hw->daio_mgr_get_ctrl_blk(hw, &mgr->ctrl_blk);\r\nbreak;\r\ncase SUM:\r\nbreak;\r\ndefault:\r\ndev_err(hw->card->dev,\r\n"Invalid resource type value %d!\n", type);\r\nerr = -EINVAL;\r\ngoto error;\r\n}\r\nif (err) {\r\ndev_err(hw->card->dev,\r\n"Failed to get manager control block!\n");\r\ngoto error;\r\n}\r\nmgr->type = type;\r\nmgr->avail = mgr->amount = amount;\r\nmgr->hw = hw;\r\nreturn 0;\r\nerror:\r\nkfree(mgr->rscs);\r\nreturn err;\r\n}\r\nint rsc_mgr_uninit(struct rsc_mgr *mgr)\r\n{\r\nif (NULL != mgr->rscs) {\r\nkfree(mgr->rscs);\r\nmgr->rscs = NULL;\r\n}\r\nif ((NULL != mgr->hw) && (NULL != mgr->ctrl_blk)) {\r\nswitch (mgr->type) {\r\ncase SRC:\r\nmgr->hw->src_mgr_put_ctrl_blk(mgr->ctrl_blk);\r\nbreak;\r\ncase SRCIMP:\r\nmgr->hw->srcimp_mgr_put_ctrl_blk(mgr->ctrl_blk);\r\nbreak;\r\ncase AMIXER:\r\nmgr->hw->amixer_mgr_put_ctrl_blk(mgr->ctrl_blk);\r\nbreak;\r\ncase DAIO:\r\nmgr->hw->daio_mgr_put_ctrl_blk(mgr->ctrl_blk);\r\nbreak;\r\ncase SUM:\r\nbreak;\r\ndefault:\r\ndev_err(((struct hw *)mgr->hw)->card->dev,\r\n"Invalid resource type value %d!\n",\r\nmgr->type);\r\nbreak;\r\n}\r\nmgr->hw = mgr->ctrl_blk = NULL;\r\n}\r\nmgr->type = NUM_RSCTYP;\r\nmgr->avail = mgr->amount = 0;\r\nreturn 0;\r\n}
