static int\r\nreg_write(struct tc90522_state *state, const struct reg_val *regs, int num)\r\n{\r\nint i, ret;\r\nstruct i2c_msg msg;\r\nret = 0;\r\nmsg.addr = state->i2c_client->addr;\r\nmsg.flags = 0;\r\nmsg.len = 2;\r\nfor (i = 0; i < num; i++) {\r\nmsg.buf = (u8 *)&regs[i];\r\nret = i2c_transfer(state->i2c_client->adapter, &msg, 1);\r\nif (ret == 0)\r\nret = -EIO;\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int reg_read(struct tc90522_state *state, u8 reg, u8 *val, u8 len)\r\n{\r\nstruct i2c_msg msgs[2] = {\r\n{\r\n.addr = state->i2c_client->addr,\r\n.flags = 0,\r\n.buf = &reg,\r\n.len = 1,\r\n},\r\n{\r\n.addr = state->i2c_client->addr,\r\n.flags = I2C_M_RD,\r\n.buf = val,\r\n.len = len,\r\n},\r\n};\r\nint ret;\r\nret = i2c_transfer(state->i2c_client->adapter, msgs, ARRAY_SIZE(msgs));\r\nif (ret == ARRAY_SIZE(msgs))\r\nret = 0;\r\nelse if (ret >= 0)\r\nret = -EIO;\r\nreturn ret;\r\n}\r\nstatic struct tc90522_state *cfg_to_state(struct tc90522_config *c)\r\n{\r\nreturn container_of(c, struct tc90522_state, cfg);\r\n}\r\nstatic int tc90522s_set_tsid(struct dvb_frontend *fe)\r\n{\r\nstruct reg_val set_tsid[] = {\r\n{ 0x8f, 00 },\r\n{ 0x90, 00 }\r\n};\r\nset_tsid[0].val = (fe->dtv_property_cache.stream_id & 0xff00) >> 8;\r\nset_tsid[1].val = fe->dtv_property_cache.stream_id & 0xff;\r\nreturn reg_write(fe->demodulator_priv, set_tsid, ARRAY_SIZE(set_tsid));\r\n}\r\nstatic int tc90522t_set_layers(struct dvb_frontend *fe)\r\n{\r\nstruct reg_val rv;\r\nu8 laysel;\r\nlaysel = ~fe->dtv_property_cache.isdbt_layer_enabled & 0x07;\r\nlaysel = (laysel & 0x01) << 2 | (laysel & 0x02) | (laysel & 0x04) >> 2;\r\nrv.reg = 0x71;\r\nrv.val = laysel;\r\nreturn reg_write(fe->demodulator_priv, &rv, 1);\r\n}\r\nstatic int tc90522s_read_status(struct dvb_frontend *fe, fe_status_t *status)\r\n{\r\nstruct tc90522_state *state;\r\nint ret;\r\nu8 reg;\r\nstate = fe->demodulator_priv;\r\nret = reg_read(state, 0xc3, &reg, 1);\r\nif (ret < 0)\r\nreturn ret;\r\n*status = 0;\r\nif (reg & 0x80)\r\nreturn 0;\r\n*status |= FE_HAS_SIGNAL;\r\nif (reg & 0x60)\r\nreturn 0;\r\n*status |= FE_HAS_CARRIER | FE_HAS_VITERBI | FE_HAS_SYNC;\r\nif (reg & 0x10)\r\nreturn 0;\r\nif (reg_read(state, 0xc5, &reg, 1) < 0 || !(reg & 0x03))\r\nreturn 0;\r\n*status |= FE_HAS_LOCK;\r\nreturn 0;\r\n}\r\nstatic int tc90522t_read_status(struct dvb_frontend *fe, fe_status_t *status)\r\n{\r\nstruct tc90522_state *state;\r\nint ret;\r\nu8 reg;\r\nstate = fe->demodulator_priv;\r\nret = reg_read(state, 0x96, &reg, 1);\r\nif (ret < 0)\r\nreturn ret;\r\n*status = 0;\r\nif (reg & 0xe0) {\r\n*status = FE_HAS_SIGNAL | FE_HAS_CARRIER | FE_HAS_VITERBI\r\n| FE_HAS_SYNC | FE_HAS_LOCK;\r\nreturn 0;\r\n}\r\nret = reg_read(state, 0x80, &reg, 1);\r\nif (ret < 0)\r\nreturn ret;\r\nif (reg & 0xf0)\r\nreturn 0;\r\n*status |= FE_HAS_SIGNAL | FE_HAS_CARRIER;\r\nif (reg & 0x0c)\r\nreturn 0;\r\n*status |= FE_HAS_SYNC | FE_HAS_VITERBI;\r\nif (reg & 0x02)\r\nreturn 0;\r\n*status |= FE_HAS_LOCK;\r\nreturn 0;\r\n}\r\nstatic int tc90522s_get_frontend(struct dvb_frontend *fe)\r\n{\r\nstruct tc90522_state *state;\r\nstruct dtv_frontend_properties *c;\r\nstruct dtv_fe_stats *stats;\r\nint ret, i;\r\nint layers;\r\nu8 val[10];\r\nu32 cndat;\r\nstate = fe->demodulator_priv;\r\nc = &fe->dtv_property_cache;\r\nc->delivery_system = SYS_ISDBS;\r\nc->symbol_rate = 28860000;\r\nlayers = 0;\r\nret = reg_read(state, 0xe6, val, 5);\r\nif (ret == 0) {\r\nu8 v;\r\nc->stream_id = val[0] << 8 | val[1];\r\nv = (val[2] & 0x70) >> 4;\r\nc->modulation = (v == 7) ? PSK_8 : QPSK;\r\nc->fec_inner = fec_conv_sat[v];\r\nc->layer[0].fec = c->fec_inner;\r\nc->layer[0].modulation = c->modulation;\r\nc->layer[0].segment_count = val[3] & 0x3f;\r\nv = (val[2] & 0x07);\r\nc->layer[1].fec = fec_conv_sat[v];\r\nif (v == 0)\r\nc->layer[1].segment_count = 0;\r\nelse\r\nc->layer[1].segment_count = val[4] & 0x3f;\r\nc->layer[1].modulation = QPSK;\r\nlayers = (v > 0) ? 2 : 1;\r\n}\r\nstats = &c->strength;\r\nstats->len = 0;\r\nif (fe->ops.tuner_ops.get_rf_strength) {\r\nu16 dummy;\r\nfe->ops.tuner_ops.get_rf_strength(fe, &dummy);\r\n}\r\nstats = &c->cnr;\r\nstats->len = 1;\r\nstats->stat[0].scale = FE_SCALE_NOT_AVAILABLE;\r\ncndat = 0;\r\nret = reg_read(state, 0xbc, val, 2);\r\nif (ret == 0)\r\ncndat = val[0] << 8 | val[1];\r\nif (cndat >= 3000) {\r\nu32 p, p4;\r\ns64 cn;\r\ncndat -= 3000;\r\np = int_sqrt(cndat << 16);\r\np4 = cndat * cndat;\r\ncn = div64_s64(-16346LL * p4 * p, 10) >> 35;\r\ncn += (14341LL * p4) >> 21;\r\ncn -= (50259LL * cndat * p) >> 23;\r\ncn += (88977LL * cndat) >> 9;\r\ncn -= (89565LL * p) >> 11;\r\ncn += 58857 << 3;\r\nstats->stat[0].svalue = cn >> 3;\r\nstats->stat[0].scale = FE_SCALE_DECIBEL;\r\n}\r\nstats = &c->post_bit_error;\r\nmemset(stats, 0, sizeof(*stats));\r\nstats->len = layers;\r\nret = reg_read(state, 0xeb, val, 10);\r\nif (ret < 0)\r\nfor (i = 0; i < layers; i++)\r\nstats->stat[i].scale = FE_SCALE_NOT_AVAILABLE;\r\nelse {\r\nfor (i = 0; i < layers; i++) {\r\nstats->stat[i].scale = FE_SCALE_COUNTER;\r\nstats->stat[i].uvalue = val[i * 5] << 16\r\n| val[i * 5 + 1] << 8 | val[i * 5 + 2];\r\n}\r\n}\r\nstats = &c->post_bit_count;\r\nmemset(stats, 0, sizeof(*stats));\r\nstats->len = layers;\r\nif (ret < 0)\r\nfor (i = 0; i < layers; i++)\r\nstats->stat[i].scale = FE_SCALE_NOT_AVAILABLE;\r\nelse {\r\nfor (i = 0; i < layers; i++) {\r\nstats->stat[i].scale = FE_SCALE_COUNTER;\r\nstats->stat[i].uvalue =\r\nval[i * 5 + 3] << 8 | val[i * 5 + 4];\r\nstats->stat[i].uvalue *= 204 * 8;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int tc90522t_get_frontend(struct dvb_frontend *fe)\r\n{\r\nstruct tc90522_state *state;\r\nstruct dtv_frontend_properties *c;\r\nstruct dtv_fe_stats *stats;\r\nint ret, i;\r\nint layers;\r\nu8 val[15], mode;\r\nu32 cndat;\r\nstate = fe->demodulator_priv;\r\nc = &fe->dtv_property_cache;\r\nc->delivery_system = SYS_ISDBT;\r\nc->bandwidth_hz = 6000000;\r\nmode = 1;\r\nret = reg_read(state, 0xb0, val, 1);\r\nif (ret == 0) {\r\nmode = (val[0] & 0xc0) >> 2;\r\nc->transmission_mode = tm_conv[mode];\r\nc->guard_interval = (val[0] & 0x30) >> 4;\r\n}\r\nret = reg_read(state, 0xb2, val, 6);\r\nlayers = 0;\r\nif (ret == 0) {\r\nu8 v;\r\nc->isdbt_partial_reception = val[0] & 0x01;\r\nc->isdbt_sb_mode = (val[0] & 0xc0) == 0x40;\r\nv = (val[2] & 0x78) >> 3;\r\nif (v == 0x0f)\r\nc->layer[0].segment_count = 0;\r\nelse {\r\nlayers++;\r\nc->layer[0].segment_count = v;\r\nc->layer[0].fec = fec_conv_ter[(val[1] & 0x1c) >> 2];\r\nc->layer[0].modulation = mod_conv[(val[1] & 0xe0) >> 5];\r\nv = (val[1] & 0x03) << 1 | (val[2] & 0x80) >> 7;\r\nc->layer[0].interleaving = v;\r\n}\r\nv = (val[3] & 0x03) << 1 | (val[4] & 0xc0) >> 6;\r\nif (v == 0x0f)\r\nc->layer[1].segment_count = 0;\r\nelse {\r\nlayers++;\r\nc->layer[1].segment_count = v;\r\nc->layer[1].fec = fec_conv_ter[(val[3] & 0xe0) >> 5];\r\nc->layer[1].modulation = mod_conv[(val[2] & 0x07)];\r\nc->layer[1].interleaving = (val[3] & 0x1c) >> 2;\r\n}\r\nv = (val[5] & 0x1e) >> 1;\r\nif (v == 0x0f)\r\nc->layer[2].segment_count = 0;\r\nelse {\r\nlayers++;\r\nc->layer[2].segment_count = v;\r\nc->layer[2].fec = fec_conv_ter[(val[4] & 0x07)];\r\nc->layer[2].modulation = mod_conv[(val[4] & 0x38) >> 3];\r\nc->layer[2].interleaving = (val[5] & 0xe0) >> 5;\r\n}\r\n}\r\nstats = &c->strength;\r\nstats->len = 0;\r\nif (fe->ops.tuner_ops.get_rf_strength) {\r\nu16 dummy;\r\nfe->ops.tuner_ops.get_rf_strength(fe, &dummy);\r\n}\r\nstats = &c->cnr;\r\nstats->len = 1;\r\nstats->stat[0].scale = FE_SCALE_NOT_AVAILABLE;\r\ncndat = 0;\r\nret = reg_read(state, 0x8b, val, 3);\r\nif (ret == 0)\r\ncndat = val[0] << 16 | val[1] << 8 | val[2];\r\nif (cndat != 0) {\r\nu32 p, tmp;\r\ns64 cn;\r\np = intlog10(5505024) - intlog10(cndat);\r\np *= 10;\r\ncn = 24772;\r\ncn += div64_s64(43827LL * p, 10) >> 24;\r\ntmp = p >> 8;\r\ncn += div64_s64(3184LL * tmp * tmp, 10) >> 32;\r\ntmp = p >> 13;\r\ncn -= div64_s64(128LL * tmp * tmp * tmp, 10) >> 33;\r\ntmp = p >> 18;\r\ncn += div64_s64(192LL * tmp * tmp * tmp * tmp, 1000) >> 24;\r\nstats->stat[0].svalue = cn >> 3;\r\nstats->stat[0].scale = FE_SCALE_DECIBEL;\r\n}\r\nstats = &c->post_bit_error;\r\nmemset(stats, 0, sizeof(*stats));\r\nstats->len = layers;\r\nret = reg_read(state, 0x9d, val, 15);\r\nif (ret < 0)\r\nfor (i = 0; i < layers; i++)\r\nstats->stat[i].scale = FE_SCALE_NOT_AVAILABLE;\r\nelse {\r\nfor (i = 0; i < layers; i++) {\r\nstats->stat[i].scale = FE_SCALE_COUNTER;\r\nstats->stat[i].uvalue = val[i * 3] << 16\r\n| val[i * 3 + 1] << 8 | val[i * 3 + 2];\r\n}\r\n}\r\nstats = &c->post_bit_count;\r\nmemset(stats, 0, sizeof(*stats));\r\nstats->len = layers;\r\nif (ret < 0)\r\nfor (i = 0; i < layers; i++)\r\nstats->stat[i].scale = FE_SCALE_NOT_AVAILABLE;\r\nelse {\r\nfor (i = 0; i < layers; i++) {\r\nstats->stat[i].scale = FE_SCALE_COUNTER;\r\nstats->stat[i].uvalue =\r\nval[9 + i * 2] << 8 | val[9 + i * 2 + 1];\r\nstats->stat[i].uvalue *= 204 * 8;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int tc90522_set_frontend(struct dvb_frontend *fe)\r\n{\r\nstruct tc90522_state *state;\r\nint ret;\r\nstate = fe->demodulator_priv;\r\nif (fe->ops.tuner_ops.set_params)\r\nret = fe->ops.tuner_ops.set_params(fe);\r\nelse\r\nret = -ENODEV;\r\nif (ret < 0)\r\ngoto failed;\r\nif (fe->ops.delsys[0] == SYS_ISDBS) {\r\nret = tc90522s_set_tsid(fe);\r\nif (ret < 0)\r\ngoto failed;\r\nret = reg_write(state, &reset_sat, 1);\r\n} else {\r\nret = tc90522t_set_layers(fe);\r\nif (ret < 0)\r\ngoto failed;\r\nret = reg_write(state, &reset_ter, 1);\r\n}\r\nif (ret < 0)\r\ngoto failed;\r\nreturn 0;\r\nfailed:\r\ndev_warn(&state->tuner_i2c.dev, "(%s) failed. [adap%d-fe%d]\n",\r\n__func__, fe->dvb->num, fe->id);\r\nreturn ret;\r\n}\r\nstatic int tc90522_get_tune_settings(struct dvb_frontend *fe,\r\nstruct dvb_frontend_tune_settings *settings)\r\n{\r\nif (fe->ops.delsys[0] == SYS_ISDBS) {\r\nsettings->min_delay_ms = 250;\r\nsettings->step_size = 1000;\r\nsettings->max_drift = settings->step_size * 2;\r\n} else {\r\nsettings->min_delay_ms = 400;\r\nsettings->step_size = 142857;\r\nsettings->max_drift = settings->step_size;\r\n}\r\nreturn 0;\r\n}\r\nstatic int tc90522_set_if_agc(struct dvb_frontend *fe, bool on)\r\n{\r\nstruct reg_val agc_sat[] = {\r\n{ 0x0a, 0x00 },\r\n{ 0x10, 0x30 },\r\n{ 0x11, 0x00 },\r\n{ 0x03, 0x01 },\r\n};\r\nstruct reg_val agc_ter[] = {\r\n{ 0x25, 0x00 },\r\n{ 0x23, 0x4c },\r\n{ 0x01, 0x40 },\r\n};\r\nstruct tc90522_state *state;\r\nstruct reg_val *rv;\r\nint num;\r\nstate = fe->demodulator_priv;\r\nif (fe->ops.delsys[0] == SYS_ISDBS) {\r\nagc_sat[0].val = on ? 0xff : 0x00;\r\nagc_sat[1].val |= 0x80;\r\nagc_sat[1].val |= on ? 0x01 : 0x00;\r\nagc_sat[2].val |= on ? 0x40 : 0x00;\r\nrv = agc_sat;\r\nnum = ARRAY_SIZE(agc_sat);\r\n} else {\r\nagc_ter[0].val = on ? 0x40 : 0x00;\r\nagc_ter[1].val |= on ? 0x00 : 0x01;\r\nrv = agc_ter;\r\nnum = ARRAY_SIZE(agc_ter);\r\n}\r\nreturn reg_write(state, rv, num);\r\n}\r\nstatic int tc90522_sleep(struct dvb_frontend *fe)\r\n{\r\nstruct tc90522_state *state;\r\nint ret;\r\nstate = fe->demodulator_priv;\r\nif (fe->ops.delsys[0] == SYS_ISDBS)\r\nret = reg_write(state, &sleep_sat, 1);\r\nelse {\r\nret = reg_write(state, &sleep_ter, 1);\r\nif (ret == 0 && fe->ops.set_lna &&\r\nfe->dtv_property_cache.lna == LNA_AUTO) {\r\nfe->dtv_property_cache.lna = 0;\r\nret = fe->ops.set_lna(fe);\r\nfe->dtv_property_cache.lna = LNA_AUTO;\r\n}\r\n}\r\nif (ret < 0)\r\ndev_warn(&state->tuner_i2c.dev,\r\n"(%s) failed. [adap%d-fe%d]\n",\r\n__func__, fe->dvb->num, fe->id);\r\nreturn ret;\r\n}\r\nstatic int tc90522_init(struct dvb_frontend *fe)\r\n{\r\nstruct tc90522_state *state;\r\nint ret;\r\nstate = fe->demodulator_priv;\r\nif (fe->ops.delsys[0] == SYS_ISDBS)\r\nret = reg_write(state, &wakeup_sat, 1);\r\nelse {\r\nret = reg_write(state, &wakeup_ter, 1);\r\nif (ret == 0 && fe->ops.set_lna &&\r\nfe->dtv_property_cache.lna == LNA_AUTO) {\r\nfe->dtv_property_cache.lna = 1;\r\nret = fe->ops.set_lna(fe);\r\nfe->dtv_property_cache.lna = LNA_AUTO;\r\n}\r\n}\r\nif (ret < 0) {\r\ndev_warn(&state->tuner_i2c.dev,\r\n"(%s) failed. [adap%d-fe%d]\n",\r\n__func__, fe->dvb->num, fe->id);\r\nreturn ret;\r\n}\r\nif (fe->dtv_property_cache.isdbt_layer_enabled == 0)\r\nfe->dtv_property_cache.isdbt_layer_enabled = 7;\r\nreturn tc90522_set_if_agc(fe, true);\r\n}\r\nstatic int\r\ntc90522_master_xfer(struct i2c_adapter *adap, struct i2c_msg *msgs, int num)\r\n{\r\nstruct tc90522_state *state;\r\nstruct i2c_msg *new_msgs;\r\nint i, j;\r\nint ret, rd_num;\r\nu8 wbuf[256];\r\nu8 *p, *bufend;\r\nif (num <= 0)\r\nreturn -EINVAL;\r\nrd_num = 0;\r\nfor (i = 0; i < num; i++)\r\nif (msgs[i].flags & I2C_M_RD)\r\nrd_num++;\r\nnew_msgs = kmalloc(sizeof(*new_msgs) * (num + rd_num), GFP_KERNEL);\r\nif (!new_msgs)\r\nreturn -ENOMEM;\r\nstate = i2c_get_adapdata(adap);\r\np = wbuf;\r\nbufend = wbuf + sizeof(wbuf);\r\nfor (i = 0, j = 0; i < num; i++, j++) {\r\nnew_msgs[j].addr = state->i2c_client->addr;\r\nnew_msgs[j].flags = msgs[i].flags;\r\nif (msgs[i].flags & I2C_M_RD) {\r\nnew_msgs[j].flags &= ~I2C_M_RD;\r\nif (p + 2 > bufend)\r\nbreak;\r\np[0] = TC90522_I2C_THRU_REG;\r\np[1] = msgs[i].addr << 1 | 0x01;\r\nnew_msgs[j].buf = p;\r\nnew_msgs[j].len = 2;\r\np += 2;\r\nj++;\r\nnew_msgs[j].addr = state->i2c_client->addr;\r\nnew_msgs[j].flags = msgs[i].flags;\r\nnew_msgs[j].buf = msgs[i].buf;\r\nnew_msgs[j].len = msgs[i].len;\r\ncontinue;\r\n}\r\nif (p + msgs[i].len + 2 > bufend)\r\nbreak;\r\np[0] = TC90522_I2C_THRU_REG;\r\np[1] = msgs[i].addr << 1;\r\nmemcpy(p + 2, msgs[i].buf, msgs[i].len);\r\nnew_msgs[j].buf = p;\r\nnew_msgs[j].len = msgs[i].len + 2;\r\np += new_msgs[j].len;\r\n}\r\nif (i < num)\r\nret = -ENOMEM;\r\nelse\r\nret = i2c_transfer(state->i2c_client->adapter, new_msgs, j);\r\nif (ret >= 0 && ret < j)\r\nret = -EIO;\r\nkfree(new_msgs);\r\nreturn (ret == j) ? num : ret;\r\n}\r\nstatic u32 tc90522_functionality(struct i2c_adapter *adap)\r\n{\r\nreturn I2C_FUNC_I2C;\r\n}\r\nstatic int tc90522_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct tc90522_state *state;\r\nstruct tc90522_config *cfg;\r\nconst struct dvb_frontend_ops *ops;\r\nstruct i2c_adapter *adap;\r\nint ret;\r\nstate = kzalloc(sizeof(*state), GFP_KERNEL);\r\nif (!state)\r\nreturn -ENOMEM;\r\nstate->i2c_client = client;\r\ncfg = client->dev.platform_data;\r\nmemcpy(&state->cfg, cfg, sizeof(state->cfg));\r\ncfg->fe = state->cfg.fe = &state->fe;\r\nops = id->driver_data == 0 ? &tc90522_ops_sat : &tc90522_ops_ter;\r\nmemcpy(&state->fe.ops, ops, sizeof(*ops));\r\nstate->fe.demodulator_priv = state;\r\nadap = &state->tuner_i2c;\r\nadap->owner = THIS_MODULE;\r\nadap->algo = &tc90522_tuner_i2c_algo;\r\nadap->dev.parent = &client->dev;\r\nstrlcpy(adap->name, "tc90522_sub", sizeof(adap->name));\r\ni2c_set_adapdata(adap, state);\r\nret = i2c_add_adapter(adap);\r\nif (ret < 0)\r\ngoto err;\r\ncfg->tuner_i2c = state->cfg.tuner_i2c = adap;\r\ni2c_set_clientdata(client, &state->cfg);\r\ndev_info(&client->dev, "Toshiba TC90522 attached.\n");\r\nreturn 0;\r\nerr:\r\nkfree(state);\r\nreturn ret;\r\n}\r\nstatic int tc90522_remove(struct i2c_client *client)\r\n{\r\nstruct tc90522_state *state;\r\nstate = cfg_to_state(i2c_get_clientdata(client));\r\ni2c_del_adapter(&state->tuner_i2c);\r\nkfree(state);\r\nreturn 0;\r\n}
