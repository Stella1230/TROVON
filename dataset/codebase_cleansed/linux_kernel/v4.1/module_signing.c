static struct public_key_signature *mod_make_digest(enum hash_algo hash,\r\nconst void *mod,\r\nunsigned long modlen)\r\n{\r\nstruct public_key_signature *pks;\r\nstruct crypto_shash *tfm;\r\nstruct shash_desc *desc;\r\nsize_t digest_size, desc_size;\r\nint ret;\r\npr_devel("==>%s()\n", __func__);\r\ntfm = crypto_alloc_shash(hash_algo_name[hash], 0, 0);\r\nif (IS_ERR(tfm))\r\nreturn (PTR_ERR(tfm) == -ENOENT) ? ERR_PTR(-ENOPKG) : ERR_CAST(tfm);\r\ndesc_size = crypto_shash_descsize(tfm) + sizeof(*desc);\r\ndigest_size = crypto_shash_digestsize(tfm);\r\nret = -ENOMEM;\r\npks = kzalloc(digest_size + sizeof(*pks) + desc_size, GFP_KERNEL);\r\nif (!pks)\r\ngoto error_no_pks;\r\npks->pkey_hash_algo = hash;\r\npks->digest = (u8 *)pks + sizeof(*pks) + desc_size;\r\npks->digest_size = digest_size;\r\ndesc = (void *)pks + sizeof(*pks);\r\ndesc->tfm = tfm;\r\ndesc->flags = CRYPTO_TFM_REQ_MAY_SLEEP;\r\nret = crypto_shash_init(desc);\r\nif (ret < 0)\r\ngoto error;\r\nret = crypto_shash_finup(desc, mod, modlen, pks->digest);\r\nif (ret < 0)\r\ngoto error;\r\ncrypto_free_shash(tfm);\r\npr_devel("<==%s() = ok\n", __func__);\r\nreturn pks;\r\nerror:\r\nkfree(pks);\r\nerror_no_pks:\r\ncrypto_free_shash(tfm);\r\npr_devel("<==%s() = %d\n", __func__, ret);\r\nreturn ERR_PTR(ret);\r\n}\r\nstatic int mod_extract_mpi_array(struct public_key_signature *pks,\r\nconst void *data, size_t len)\r\n{\r\nsize_t nbytes;\r\nMPI mpi;\r\nif (len < 3)\r\nreturn -EBADMSG;\r\nnbytes = ((const u8 *)data)[0] << 8 | ((const u8 *)data)[1];\r\ndata += 2;\r\nlen -= 2;\r\nif (len != nbytes)\r\nreturn -EBADMSG;\r\nmpi = mpi_read_raw_data(data, nbytes);\r\nif (!mpi)\r\nreturn -ENOMEM;\r\npks->mpi[0] = mpi;\r\npks->nr_mpi = 1;\r\nreturn 0;\r\n}\r\nstatic struct key *request_asymmetric_key(const char *signer, size_t signer_len,\r\nconst u8 *key_id, size_t key_id_len)\r\n{\r\nkey_ref_t key;\r\nsize_t i;\r\nchar *id, *q;\r\npr_devel("==>%s(,%zu,,%zu)\n", __func__, signer_len, key_id_len);\r\nid = kmalloc(signer_len + 2 + key_id_len * 2 + 1, GFP_KERNEL);\r\nif (!id)\r\nreturn ERR_PTR(-ENOKEY);\r\nmemcpy(id, signer, signer_len);\r\nq = id + signer_len;\r\n*q++ = ':';\r\n*q++ = ' ';\r\nfor (i = 0; i < key_id_len; i++) {\r\n*q++ = hex_asc[*key_id >> 4];\r\n*q++ = hex_asc[*key_id++ & 0x0f];\r\n}\r\n*q = 0;\r\npr_debug("Look up: \"%s\"\n", id);\r\nkey = keyring_search(make_key_ref(system_trusted_keyring, 1),\r\n&key_type_asymmetric, id);\r\nif (IS_ERR(key))\r\npr_warn("Request for unknown module key '%s' err %ld\n",\r\nid, PTR_ERR(key));\r\nkfree(id);\r\nif (IS_ERR(key)) {\r\nswitch (PTR_ERR(key)) {\r\ncase -EACCES:\r\ncase -ENOTDIR:\r\ncase -EAGAIN:\r\nreturn ERR_PTR(-ENOKEY);\r\ndefault:\r\nreturn ERR_CAST(key);\r\n}\r\n}\r\npr_devel("<==%s() = 0 [%x]\n", __func__, key_serial(key_ref_to_ptr(key)));\r\nreturn key_ref_to_ptr(key);\r\n}\r\nint mod_verify_sig(const void *mod, unsigned long *_modlen)\r\n{\r\nstruct public_key_signature *pks;\r\nstruct module_signature ms;\r\nstruct key *key;\r\nconst void *sig;\r\nsize_t modlen = *_modlen, sig_len;\r\nint ret;\r\npr_devel("==>%s(,%zu)\n", __func__, modlen);\r\nif (modlen <= sizeof(ms))\r\nreturn -EBADMSG;\r\nmemcpy(&ms, mod + (modlen - sizeof(ms)), sizeof(ms));\r\nmodlen -= sizeof(ms);\r\nsig_len = be32_to_cpu(ms.sig_len);\r\nif (sig_len >= modlen)\r\nreturn -EBADMSG;\r\nmodlen -= sig_len;\r\nif ((size_t)ms.signer_len + ms.key_id_len >= modlen)\r\nreturn -EBADMSG;\r\nmodlen -= (size_t)ms.signer_len + ms.key_id_len;\r\n*_modlen = modlen;\r\nsig = mod + modlen;\r\nif (ms.algo != PKEY_ALGO_RSA ||\r\nms.id_type != PKEY_ID_X509)\r\nreturn -ENOPKG;\r\nif (ms.hash >= PKEY_HASH__LAST ||\r\n!hash_algo_name[ms.hash])\r\nreturn -ENOPKG;\r\nkey = request_asymmetric_key(sig, ms.signer_len,\r\nsig + ms.signer_len, ms.key_id_len);\r\nif (IS_ERR(key))\r\nreturn PTR_ERR(key);\r\npks = mod_make_digest(ms.hash, mod, modlen);\r\nif (IS_ERR(pks)) {\r\nret = PTR_ERR(pks);\r\ngoto error_put_key;\r\n}\r\nret = mod_extract_mpi_array(pks, sig + ms.signer_len + ms.key_id_len,\r\nsig_len);\r\nif (ret < 0)\r\ngoto error_free_pks;\r\nret = verify_signature(key, pks);\r\npr_devel("verify_signature() = %d\n", ret);\r\nerror_free_pks:\r\nmpi_free(pks->rsa.s);\r\nkfree(pks);\r\nerror_put_key:\r\nkey_put(key);\r\npr_devel("<==%s() = %d\n", __func__, ret);\r\nreturn ret;\r\n}
