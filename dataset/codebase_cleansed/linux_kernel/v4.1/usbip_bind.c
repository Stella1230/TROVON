void usbip_bind_usage(void)\r\n{\r\nprintf("usage: %s", usbip_bind_usage_string);\r\n}\r\nstatic int bind_usbip(char *busid)\r\n{\r\nchar attr_name[] = "bind";\r\nchar bind_attr_path[SYSFS_PATH_MAX];\r\nint rc = -1;\r\nsnprintf(bind_attr_path, sizeof(bind_attr_path), "%s/%s/%s/%s/%s/%s",\r\nSYSFS_MNT_PATH, SYSFS_BUS_NAME, SYSFS_BUS_TYPE,\r\nSYSFS_DRIVERS_NAME, USBIP_HOST_DRV_NAME, attr_name);\r\nrc = write_sysfs_attribute(bind_attr_path, busid, strlen(busid));\r\nif (rc < 0) {\r\nerr("error binding device %s to driver: %s", busid,\r\nstrerror(errno));\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int unbind_other(char *busid)\r\n{\r\nenum unbind_status status = UNBIND_ST_OK;\r\nchar attr_name[] = "unbind";\r\nchar unbind_attr_path[SYSFS_PATH_MAX];\r\nint rc = -1;\r\nstruct udev *udev;\r\nstruct udev_device *dev;\r\nconst char *driver;\r\nconst char *bDevClass;\r\nudev = udev_new();\r\ndev = udev_device_new_from_subsystem_sysname(udev, "usb", busid);\r\nif (!dev) {\r\ndbg("unable to find device with bus ID %s", busid);\r\ngoto err_close_busid_dev;\r\n}\r\nbDevClass = udev_device_get_sysattr_value(dev, "bDeviceClass");\r\nif (!bDevClass) {\r\ndbg("unable to get bDevClass device attribute");\r\ngoto err_close_busid_dev;\r\n}\r\nif (!strncmp(bDevClass, "09", strlen(bDevClass))) {\r\ndbg("skip unbinding of hub");\r\ngoto err_close_busid_dev;\r\n}\r\ndriver = udev_device_get_driver(dev);\r\nif (!driver) {\r\ngoto out;\r\n}\r\nif (!strncmp(USBIP_HOST_DRV_NAME, driver,\r\nstrlen(USBIP_HOST_DRV_NAME))) {\r\nstatus = UNBIND_ST_USBIP_HOST;\r\ngoto out;\r\n}\r\nsnprintf(unbind_attr_path, sizeof(unbind_attr_path), "%s/%s/%s/%s/%s/%s",\r\nSYSFS_MNT_PATH, SYSFS_BUS_NAME, SYSFS_BUS_TYPE,\r\nSYSFS_DRIVERS_NAME, driver, attr_name);\r\nrc = write_sysfs_attribute(unbind_attr_path, busid, strlen(busid));\r\nif (rc < 0) {\r\nerr("error unbinding device %s from driver", busid);\r\ngoto err_close_busid_dev;\r\n}\r\ngoto out;\r\nerr_close_busid_dev:\r\nstatus = UNBIND_ST_FAILED;\r\nout:\r\nudev_device_unref(dev);\r\nudev_unref(udev);\r\nreturn status;\r\n}\r\nstatic int bind_device(char *busid)\r\n{\r\nint rc;\r\nstruct udev *udev;\r\nstruct udev_device *dev;\r\nudev = udev_new();\r\ndev = udev_device_new_from_subsystem_sysname(udev, "usb", busid);\r\nif (!dev) {\r\nerr("device with the specified bus ID does not exist");\r\nreturn -1;\r\n}\r\nudev_unref(udev);\r\nrc = unbind_other(busid);\r\nif (rc == UNBIND_ST_FAILED) {\r\nerr("could not unbind driver from device on busid %s", busid);\r\nreturn -1;\r\n} else if (rc == UNBIND_ST_USBIP_HOST) {\r\nerr("device on busid %s is already bound to %s", busid,\r\nUSBIP_HOST_DRV_NAME);\r\nreturn -1;\r\n}\r\nrc = modify_match_busid(busid, 1);\r\nif (rc < 0) {\r\nerr("unable to bind device on %s", busid);\r\nreturn -1;\r\n}\r\nrc = bind_usbip(busid);\r\nif (rc < 0) {\r\nerr("could not bind device to %s", USBIP_HOST_DRV_NAME);\r\nmodify_match_busid(busid, 0);\r\nreturn -1;\r\n}\r\ninfo("bind device on busid %s: complete", busid);\r\nreturn 0;\r\n}\r\nint usbip_bind(int argc, char *argv[])\r\n{\r\nstatic const struct option opts[] = {\r\n{ "busid", required_argument, NULL, 'b' },\r\n{ NULL, 0, NULL, 0 }\r\n};\r\nint opt;\r\nint ret = -1;\r\nfor (;;) {\r\nopt = getopt_long(argc, argv, "b:", opts, NULL);\r\nif (opt == -1)\r\nbreak;\r\nswitch (opt) {\r\ncase 'b':\r\nret = bind_device(optarg);\r\ngoto out;\r\ndefault:\r\ngoto err_out;\r\n}\r\n}\r\nerr_out:\r\nusbip_bind_usage();\r\nout:\r\nreturn ret;\r\n}
