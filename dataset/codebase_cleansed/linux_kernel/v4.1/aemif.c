static inline unsigned int davinci_aemif_readl(void __iomem *base, int offset)\r\n{\r\nreturn readl_relaxed(base + offset);\r\n}\r\nstatic inline void davinci_aemif_writel(void __iomem *base,\r\nint offset, unsigned long value)\r\n{\r\nwritel_relaxed(value, base + offset);\r\n}\r\nstatic int aemif_calc_rate(int wanted, unsigned long clk, int max)\r\n{\r\nint result;\r\nresult = DIV_ROUND_UP((wanted * clk), NSEC_PER_MSEC) - 1;\r\npr_debug("%s: result %d from %ld, %d\n", __func__, result, clk, wanted);\r\nif (result < 0)\r\nresult = 0;\r\nelse if (result > max)\r\nresult = -EINVAL;\r\nreturn result;\r\n}\r\nstatic int davinci_aemif_setup_timing(struct davinci_aemif_timing *t,\r\nvoid __iomem *base, unsigned cs,\r\nunsigned long clkrate)\r\n{\r\nunsigned set, val;\r\nint ta, rhold, rstrobe, rsetup, whold, wstrobe, wsetup;\r\nunsigned offset = A1CR_OFFSET + cs * 4;\r\nif (!t)\r\nreturn 0;\r\nclkrate /= 1000;\r\nta = aemif_calc_rate(t->ta, clkrate, TA_MAX);\r\nrhold = aemif_calc_rate(t->rhold, clkrate, RHOLD_MAX);\r\nrstrobe = aemif_calc_rate(t->rstrobe, clkrate, RSTROBE_MAX);\r\nrsetup = aemif_calc_rate(t->rsetup, clkrate, RSETUP_MAX);\r\nwhold = aemif_calc_rate(t->whold, clkrate, WHOLD_MAX);\r\nwstrobe = aemif_calc_rate(t->wstrobe, clkrate, WSTROBE_MAX);\r\nwsetup = aemif_calc_rate(t->wsetup, clkrate, WSETUP_MAX);\r\nif (ta < 0 || rhold < 0 || rstrobe < 0 || rsetup < 0 ||\r\nwhold < 0 || wstrobe < 0 || wsetup < 0) {\r\npr_err("%s: cannot get suitable timings\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nset = TA(ta) | RHOLD(rhold) | RSTROBE(rstrobe) | RSETUP(rsetup) |\r\nWHOLD(whold) | WSTROBE(wstrobe) | WSETUP(wsetup);\r\nval = __raw_readl(base + offset);\r\nval &= ~TIMING_MASK;\r\nval |= set;\r\n__raw_writel(val, base + offset);\r\nreturn 0;\r\n}\r\nint davinci_aemif_setup(struct platform_device *pdev)\r\n{\r\nstruct davinci_nand_pdata *pdata = dev_get_platdata(&pdev->dev);\r\nuint32_t val;\r\nunsigned long clkrate;\r\nstruct resource *res;\r\nvoid __iomem *base;\r\nstruct clk *clk;\r\nint ret = 0;\r\nclk = clk_get(&pdev->dev, "aemif");\r\nif (IS_ERR(clk)) {\r\nret = PTR_ERR(clk);\r\ndev_dbg(&pdev->dev, "unable to get AEMIF clock, err %d\n", ret);\r\nreturn ret;\r\n}\r\nret = clk_prepare_enable(clk);\r\nif (ret < 0) {\r\ndev_dbg(&pdev->dev, "unable to enable AEMIF clock, err %d\n",\r\nret);\r\ngoto err_put;\r\n}\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 1);\r\nif (!res) {\r\ndev_err(&pdev->dev, "cannot get IORESOURCE_MEM\n");\r\nret = -ENOMEM;\r\ngoto err;\r\n}\r\nbase = ioremap(res->start, resource_size(res));\r\nif (!base) {\r\ndev_err(&pdev->dev, "ioremap failed for resource %pR\n", res);\r\nret = -ENOMEM;\r\ngoto err;\r\n}\r\nval = davinci_aemif_readl(base, A1CR_OFFSET + pdev->id * 4);\r\nval &= ~(ACR_ASIZE_MASK | ACR_EW_MASK | ACR_SS_MASK);\r\nif (pdata->options & NAND_BUSWIDTH_16)\r\nval |= 0x1;\r\ndavinci_aemif_writel(base, A1CR_OFFSET + pdev->id * 4, val);\r\nclkrate = clk_get_rate(clk);\r\nif (pdata->timing)\r\nret = davinci_aemif_setup_timing(pdata->timing, base, pdev->id,\r\nclkrate);\r\nif (ret < 0)\r\ndev_dbg(&pdev->dev, "NAND timing values setup fail\n");\r\niounmap(base);\r\nerr:\r\nclk_disable_unprepare(clk);\r\nerr_put:\r\nclk_put(clk);\r\nreturn ret;\r\n}
