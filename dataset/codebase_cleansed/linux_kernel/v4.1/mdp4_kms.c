static int mdp4_hw_init(struct msm_kms *kms)\r\n{\r\nstruct mdp4_kms *mdp4_kms = to_mdp4_kms(to_mdp_kms(kms));\r\nstruct drm_device *dev = mdp4_kms->dev;\r\nuint32_t version, major, minor, dmap_cfg, vg_cfg;\r\nunsigned long clk;\r\nint ret = 0;\r\npm_runtime_get_sync(dev->dev);\r\nmdp4_enable(mdp4_kms);\r\nversion = mdp4_read(mdp4_kms, REG_MDP4_VERSION);\r\nmdp4_disable(mdp4_kms);\r\nmajor = FIELD(version, MDP4_VERSION_MAJOR);\r\nminor = FIELD(version, MDP4_VERSION_MINOR);\r\nDBG("found MDP4 version v%d.%d", major, minor);\r\nif (major != 4) {\r\ndev_err(dev->dev, "unexpected MDP version: v%d.%d\n",\r\nmajor, minor);\r\nret = -ENXIO;\r\ngoto out;\r\n}\r\nmdp4_kms->rev = minor;\r\nif (mdp4_kms->dsi_pll_vdda) {\r\nif ((mdp4_kms->rev == 2) || (mdp4_kms->rev == 4)) {\r\nret = regulator_set_voltage(mdp4_kms->dsi_pll_vdda,\r\n1200000, 1200000);\r\nif (ret) {\r\ndev_err(dev->dev,\r\n"failed to set dsi_pll_vdda voltage: %d\n", ret);\r\ngoto out;\r\n}\r\n}\r\n}\r\nif (mdp4_kms->dsi_pll_vddio) {\r\nif (mdp4_kms->rev == 2) {\r\nret = regulator_set_voltage(mdp4_kms->dsi_pll_vddio,\r\n1800000, 1800000);\r\nif (ret) {\r\ndev_err(dev->dev,\r\n"failed to set dsi_pll_vddio voltage: %d\n", ret);\r\ngoto out;\r\n}\r\n}\r\n}\r\nif (mdp4_kms->rev > 1) {\r\nmdp4_write(mdp4_kms, REG_MDP4_CS_CONTROLLER0, 0x0707ffff);\r\nmdp4_write(mdp4_kms, REG_MDP4_CS_CONTROLLER1, 0x03073f3f);\r\n}\r\nmdp4_write(mdp4_kms, REG_MDP4_PORTMAP_MODE, 0x3);\r\nmdp4_write(mdp4_kms, REG_MDP4_READ_CNFG, 0x02222);\r\nclk = clk_get_rate(mdp4_kms->clk);\r\nif ((mdp4_kms->rev >= 1) || (clk >= 90000000)) {\r\ndmap_cfg = 0x47;\r\nvg_cfg = 0x47;\r\n} else {\r\ndmap_cfg = 0x27;\r\nvg_cfg = 0x43;\r\n}\r\nDBG("fetch config: dmap=%02x, vg=%02x", dmap_cfg, vg_cfg);\r\nmdp4_write(mdp4_kms, REG_MDP4_DMA_FETCH_CONFIG(DMA_P), dmap_cfg);\r\nmdp4_write(mdp4_kms, REG_MDP4_DMA_FETCH_CONFIG(DMA_E), dmap_cfg);\r\nmdp4_write(mdp4_kms, REG_MDP4_PIPE_FETCH_CONFIG(VG1), vg_cfg);\r\nmdp4_write(mdp4_kms, REG_MDP4_PIPE_FETCH_CONFIG(VG2), vg_cfg);\r\nmdp4_write(mdp4_kms, REG_MDP4_PIPE_FETCH_CONFIG(RGB1), vg_cfg);\r\nmdp4_write(mdp4_kms, REG_MDP4_PIPE_FETCH_CONFIG(RGB2), vg_cfg);\r\nif (mdp4_kms->rev >= 2)\r\nmdp4_write(mdp4_kms, REG_MDP4_LAYERMIXER_IN_CFG_UPDATE_METHOD, 1);\r\nmdp4_write(mdp4_kms, REG_MDP4_LAYERMIXER_IN_CFG, 0);\r\nmdp4_write(mdp4_kms, REG_MDP4_PIPE_OP_MODE(VG1), 0);\r\nmdp4_write(mdp4_kms, REG_MDP4_PIPE_OP_MODE(VG2), 0);\r\nmdp4_write(mdp4_kms, REG_MDP4_DMA_P_OP_MODE, 0);\r\nmdp4_write(mdp4_kms, REG_MDP4_DMA_S_OP_MODE, 0);\r\nmdp4_write(mdp4_kms, REG_MDP4_OVLP_CSC_CONFIG(1), 0);\r\nmdp4_write(mdp4_kms, REG_MDP4_OVLP_CSC_CONFIG(2), 0);\r\nif (mdp4_kms->rev > 1)\r\nmdp4_write(mdp4_kms, REG_MDP4_RESET_STATUS, 1);\r\nout:\r\npm_runtime_put_sync(dev->dev);\r\nreturn ret;\r\n}\r\nstatic void mdp4_prepare_commit(struct msm_kms *kms, struct drm_atomic_state *state)\r\n{\r\nstruct mdp4_kms *mdp4_kms = to_mdp4_kms(to_mdp_kms(kms));\r\nint i, ncrtcs = state->dev->mode_config.num_crtc;\r\nmdp4_enable(mdp4_kms);\r\nfor (i = 0; i < ncrtcs; i++) {\r\nstruct drm_crtc *crtc = state->crtcs[i];\r\nif (!crtc)\r\ncontinue;\r\ndrm_crtc_vblank_get(crtc);\r\n}\r\n}\r\nstatic void mdp4_complete_commit(struct msm_kms *kms, struct drm_atomic_state *state)\r\n{\r\nstruct mdp4_kms *mdp4_kms = to_mdp4_kms(to_mdp_kms(kms));\r\nint i, ncrtcs = state->dev->mode_config.num_crtc;\r\nfor (i = 0; i < ncrtcs; i++) {\r\nstruct drm_crtc *crtc = state->crtcs[i];\r\nif (!crtc)\r\ncontinue;\r\ndrm_crtc_vblank_put(crtc);\r\n}\r\nmdp4_disable(mdp4_kms);\r\n}\r\nstatic long mdp4_round_pixclk(struct msm_kms *kms, unsigned long rate,\r\nstruct drm_encoder *encoder)\r\n{\r\nreturn mdp4_dtv_round_pixclk(encoder, rate);\r\n}\r\nstatic void mdp4_preclose(struct msm_kms *kms, struct drm_file *file)\r\n{\r\nstruct mdp4_kms *mdp4_kms = to_mdp4_kms(to_mdp_kms(kms));\r\nstruct msm_drm_private *priv = mdp4_kms->dev->dev_private;\r\nunsigned i;\r\nfor (i = 0; i < priv->num_crtcs; i++)\r\nmdp4_crtc_cancel_pending_flip(priv->crtcs[i], file);\r\n}\r\nstatic void mdp4_destroy(struct msm_kms *kms)\r\n{\r\nstruct mdp4_kms *mdp4_kms = to_mdp4_kms(to_mdp_kms(kms));\r\nif (mdp4_kms->blank_cursor_iova)\r\nmsm_gem_put_iova(mdp4_kms->blank_cursor_bo, mdp4_kms->id);\r\nif (mdp4_kms->blank_cursor_bo)\r\ndrm_gem_object_unreference_unlocked(mdp4_kms->blank_cursor_bo);\r\nkfree(mdp4_kms);\r\n}\r\nint mdp4_disable(struct mdp4_kms *mdp4_kms)\r\n{\r\nDBG("");\r\nclk_disable_unprepare(mdp4_kms->clk);\r\nif (mdp4_kms->pclk)\r\nclk_disable_unprepare(mdp4_kms->pclk);\r\nclk_disable_unprepare(mdp4_kms->lut_clk);\r\nif (mdp4_kms->axi_clk)\r\nclk_disable_unprepare(mdp4_kms->axi_clk);\r\nreturn 0;\r\n}\r\nint mdp4_enable(struct mdp4_kms *mdp4_kms)\r\n{\r\nDBG("");\r\nclk_prepare_enable(mdp4_kms->clk);\r\nif (mdp4_kms->pclk)\r\nclk_prepare_enable(mdp4_kms->pclk);\r\nclk_prepare_enable(mdp4_kms->lut_clk);\r\nif (mdp4_kms->axi_clk)\r\nclk_prepare_enable(mdp4_kms->axi_clk);\r\nreturn 0;\r\n}\r\nstatic struct drm_panel *detect_panel(struct drm_device *dev, const char *name)\r\n{\r\nstruct device_node *n;\r\nstruct drm_panel *panel = NULL;\r\nn = of_parse_phandle(dev->dev->of_node, name, 0);\r\nif (n) {\r\npanel = of_drm_find_panel(n);\r\nif (!panel)\r\npanel = ERR_PTR(-EPROBE_DEFER);\r\n}\r\nreturn panel;\r\n}\r\nstatic struct drm_panel *detect_panel(struct drm_device *dev, const char *name)\r\n{\r\n}\r\nstatic int modeset_init(struct mdp4_kms *mdp4_kms)\r\n{\r\nstruct drm_device *dev = mdp4_kms->dev;\r\nstruct msm_drm_private *priv = dev->dev_private;\r\nstruct drm_plane *plane;\r\nstruct drm_crtc *crtc;\r\nstruct drm_encoder *encoder;\r\nstruct drm_connector *connector;\r\nstruct drm_panel *panel;\r\nint ret;\r\nplane = mdp4_plane_init(dev, VG1, false);\r\nif (IS_ERR(plane)) {\r\ndev_err(dev->dev, "failed to construct plane for VG1\n");\r\nret = PTR_ERR(plane);\r\ngoto fail;\r\n}\r\npriv->planes[priv->num_planes++] = plane;\r\nplane = mdp4_plane_init(dev, VG2, false);\r\nif (IS_ERR(plane)) {\r\ndev_err(dev->dev, "failed to construct plane for VG2\n");\r\nret = PTR_ERR(plane);\r\ngoto fail;\r\n}\r\npriv->planes[priv->num_planes++] = plane;\r\npanel = detect_panel(dev, "qcom,lvds-panel");\r\nif (IS_ERR(panel)) {\r\nret = PTR_ERR(panel);\r\ndev_err(dev->dev, "failed to detect LVDS panel: %d\n", ret);\r\ngoto fail;\r\n}\r\nplane = mdp4_plane_init(dev, RGB2, true);\r\nif (IS_ERR(plane)) {\r\ndev_err(dev->dev, "failed to construct plane for RGB2\n");\r\nret = PTR_ERR(plane);\r\ngoto fail;\r\n}\r\ncrtc = mdp4_crtc_init(dev, plane, priv->num_crtcs, 0, DMA_P);\r\nif (IS_ERR(crtc)) {\r\ndev_err(dev->dev, "failed to construct crtc for DMA_P\n");\r\nret = PTR_ERR(crtc);\r\ngoto fail;\r\n}\r\nencoder = mdp4_lcdc_encoder_init(dev, panel);\r\nif (IS_ERR(encoder)) {\r\ndev_err(dev->dev, "failed to construct LCDC encoder\n");\r\nret = PTR_ERR(encoder);\r\ngoto fail;\r\n}\r\nencoder->possible_crtcs = 1 << priv->num_crtcs;\r\npriv->crtcs[priv->num_crtcs++] = crtc;\r\npriv->encoders[priv->num_encoders++] = encoder;\r\nconnector = mdp4_lvds_connector_init(dev, panel, encoder);\r\nif (IS_ERR(connector)) {\r\nret = PTR_ERR(connector);\r\ndev_err(dev->dev, "failed to initialize LVDS connector: %d\n", ret);\r\ngoto fail;\r\n}\r\npriv->connectors[priv->num_connectors++] = connector;\r\nplane = mdp4_plane_init(dev, RGB1, true);\r\nif (IS_ERR(plane)) {\r\ndev_err(dev->dev, "failed to construct plane for RGB1\n");\r\nret = PTR_ERR(plane);\r\ngoto fail;\r\n}\r\ncrtc = mdp4_crtc_init(dev, plane, priv->num_crtcs, 1, DMA_E);\r\nif (IS_ERR(crtc)) {\r\ndev_err(dev->dev, "failed to construct crtc for DMA_E\n");\r\nret = PTR_ERR(crtc);\r\ngoto fail;\r\n}\r\nencoder = mdp4_dtv_encoder_init(dev);\r\nif (IS_ERR(encoder)) {\r\ndev_err(dev->dev, "failed to construct DTV encoder\n");\r\nret = PTR_ERR(encoder);\r\ngoto fail;\r\n}\r\nencoder->possible_crtcs = 1 << priv->num_crtcs;\r\npriv->crtcs[priv->num_crtcs++] = crtc;\r\npriv->encoders[priv->num_encoders++] = encoder;\r\nif (priv->hdmi) {\r\nret = hdmi_modeset_init(priv->hdmi, dev, encoder);\r\nif (ret) {\r\ndev_err(dev->dev, "failed to initialize HDMI: %d\n", ret);\r\ngoto fail;\r\n}\r\n}\r\nreturn 0;\r\nfail:\r\nreturn ret;\r\n}\r\nstruct msm_kms *mdp4_kms_init(struct drm_device *dev)\r\n{\r\nstruct platform_device *pdev = dev->platformdev;\r\nstruct mdp4_platform_config *config = mdp4_get_config(pdev);\r\nstruct mdp4_kms *mdp4_kms;\r\nstruct msm_kms *kms = NULL;\r\nstruct msm_mmu *mmu;\r\nint ret;\r\nmdp4_kms = kzalloc(sizeof(*mdp4_kms), GFP_KERNEL);\r\nif (!mdp4_kms) {\r\ndev_err(dev->dev, "failed to allocate kms\n");\r\nret = -ENOMEM;\r\ngoto fail;\r\n}\r\nmdp_kms_init(&mdp4_kms->base, &kms_funcs);\r\nkms = &mdp4_kms->base.base;\r\nmdp4_kms->dev = dev;\r\nmdp4_kms->mmio = msm_ioremap(pdev, NULL, "MDP4");\r\nif (IS_ERR(mdp4_kms->mmio)) {\r\nret = PTR_ERR(mdp4_kms->mmio);\r\ngoto fail;\r\n}\r\nmdp4_kms->dsi_pll_vdda =\r\ndevm_regulator_get_optional(&pdev->dev, "dsi_pll_vdda");\r\nif (IS_ERR(mdp4_kms->dsi_pll_vdda))\r\nmdp4_kms->dsi_pll_vdda = NULL;\r\nmdp4_kms->dsi_pll_vddio =\r\ndevm_regulator_get_optional(&pdev->dev, "dsi_pll_vddio");\r\nif (IS_ERR(mdp4_kms->dsi_pll_vddio))\r\nmdp4_kms->dsi_pll_vddio = NULL;\r\nmdp4_kms->vdd = devm_regulator_get_exclusive(&pdev->dev, "vdd");\r\nif (IS_ERR(mdp4_kms->vdd))\r\nmdp4_kms->vdd = NULL;\r\nif (mdp4_kms->vdd) {\r\nret = regulator_enable(mdp4_kms->vdd);\r\nif (ret) {\r\ndev_err(dev->dev, "failed to enable regulator vdd: %d\n", ret);\r\ngoto fail;\r\n}\r\n}\r\nmdp4_kms->clk = devm_clk_get(&pdev->dev, "core_clk");\r\nif (IS_ERR(mdp4_kms->clk)) {\r\ndev_err(dev->dev, "failed to get core_clk\n");\r\nret = PTR_ERR(mdp4_kms->clk);\r\ngoto fail;\r\n}\r\nmdp4_kms->pclk = devm_clk_get(&pdev->dev, "iface_clk");\r\nif (IS_ERR(mdp4_kms->pclk))\r\nmdp4_kms->pclk = NULL;\r\nmdp4_kms->lut_clk = devm_clk_get(&pdev->dev, "lut_clk");\r\nif (IS_ERR(mdp4_kms->lut_clk)) {\r\ndev_err(dev->dev, "failed to get lut_clk\n");\r\nret = PTR_ERR(mdp4_kms->lut_clk);\r\ngoto fail;\r\n}\r\nmdp4_kms->axi_clk = devm_clk_get(&pdev->dev, "mdp_axi_clk");\r\nif (IS_ERR(mdp4_kms->axi_clk)) {\r\ndev_err(dev->dev, "failed to get axi_clk\n");\r\nret = PTR_ERR(mdp4_kms->axi_clk);\r\ngoto fail;\r\n}\r\nclk_set_rate(mdp4_kms->clk, config->max_clk);\r\nclk_set_rate(mdp4_kms->lut_clk, config->max_clk);\r\nmdp4_enable(mdp4_kms);\r\nmdp4_write(mdp4_kms, REG_MDP4_DTV_ENABLE, 0);\r\nmdp4_write(mdp4_kms, REG_MDP4_LCDC_ENABLE, 0);\r\nmdp4_write(mdp4_kms, REG_MDP4_DSI_ENABLE, 0);\r\nmdp4_disable(mdp4_kms);\r\nmdelay(16);\r\nif (config->iommu) {\r\nmmu = msm_iommu_new(&pdev->dev, config->iommu);\r\nif (IS_ERR(mmu)) {\r\nret = PTR_ERR(mmu);\r\ngoto fail;\r\n}\r\nret = mmu->funcs->attach(mmu, iommu_ports,\r\nARRAY_SIZE(iommu_ports));\r\nif (ret)\r\ngoto fail;\r\n} else {\r\ndev_info(dev->dev, "no iommu, fallback to phys "\r\n"contig buffers for scanout\n");\r\nmmu = NULL;\r\n}\r\nmdp4_kms->id = msm_register_mmu(dev, mmu);\r\nif (mdp4_kms->id < 0) {\r\nret = mdp4_kms->id;\r\ndev_err(dev->dev, "failed to register mdp4 iommu: %d\n", ret);\r\ngoto fail;\r\n}\r\nret = modeset_init(mdp4_kms);\r\nif (ret) {\r\ndev_err(dev->dev, "modeset_init failed: %d\n", ret);\r\ngoto fail;\r\n}\r\nmutex_lock(&dev->struct_mutex);\r\nmdp4_kms->blank_cursor_bo = msm_gem_new(dev, SZ_16K, MSM_BO_WC);\r\nmutex_unlock(&dev->struct_mutex);\r\nif (IS_ERR(mdp4_kms->blank_cursor_bo)) {\r\nret = PTR_ERR(mdp4_kms->blank_cursor_bo);\r\ndev_err(dev->dev, "could not allocate blank-cursor bo: %d\n", ret);\r\nmdp4_kms->blank_cursor_bo = NULL;\r\ngoto fail;\r\n}\r\nret = msm_gem_get_iova(mdp4_kms->blank_cursor_bo, mdp4_kms->id,\r\n&mdp4_kms->blank_cursor_iova);\r\nif (ret) {\r\ndev_err(dev->dev, "could not pin blank-cursor bo: %d\n", ret);\r\ngoto fail;\r\n}\r\nreturn kms;\r\nfail:\r\nif (kms)\r\nmdp4_destroy(kms);\r\nreturn ERR_PTR(ret);\r\n}\r\nstatic struct mdp4_platform_config *mdp4_get_config(struct platform_device *dev)\r\n{\r\nstatic struct mdp4_platform_config config = {};\r\n#ifdef CONFIG_OF\r\nconfig.max_clk = 266667000;\r\nconfig.iommu = iommu_domain_alloc(&platform_bus_type);\r\n#else\r\nif (cpu_is_apq8064())\r\nconfig.max_clk = 266667000;\r\nelse\r\nconfig.max_clk = 200000000;\r\nconfig.iommu = msm_get_iommu_domain(DISPLAY_READ_DOMAIN);\r\n#endif\r\nreturn &config;\r\n}
