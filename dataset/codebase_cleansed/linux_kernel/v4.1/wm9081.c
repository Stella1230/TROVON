static bool wm9081_volatile_register(struct device *dev, unsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase WM9081_SOFTWARE_RESET:\r\ncase WM9081_INTERRUPT_STATUS:\r\nreturn true;\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nstatic bool wm9081_readable_register(struct device *dev, unsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase WM9081_SOFTWARE_RESET:\r\ncase WM9081_ANALOGUE_LINEOUT:\r\ncase WM9081_ANALOGUE_SPEAKER_PGA:\r\ncase WM9081_VMID_CONTROL:\r\ncase WM9081_BIAS_CONTROL_1:\r\ncase WM9081_ANALOGUE_MIXER:\r\ncase WM9081_ANTI_POP_CONTROL:\r\ncase WM9081_ANALOGUE_SPEAKER_1:\r\ncase WM9081_ANALOGUE_SPEAKER_2:\r\ncase WM9081_POWER_MANAGEMENT:\r\ncase WM9081_CLOCK_CONTROL_1:\r\ncase WM9081_CLOCK_CONTROL_2:\r\ncase WM9081_CLOCK_CONTROL_3:\r\ncase WM9081_FLL_CONTROL_1:\r\ncase WM9081_FLL_CONTROL_2:\r\ncase WM9081_FLL_CONTROL_3:\r\ncase WM9081_FLL_CONTROL_4:\r\ncase WM9081_FLL_CONTROL_5:\r\ncase WM9081_AUDIO_INTERFACE_1:\r\ncase WM9081_AUDIO_INTERFACE_2:\r\ncase WM9081_AUDIO_INTERFACE_3:\r\ncase WM9081_AUDIO_INTERFACE_4:\r\ncase WM9081_INTERRUPT_STATUS:\r\ncase WM9081_INTERRUPT_STATUS_MASK:\r\ncase WM9081_INTERRUPT_POLARITY:\r\ncase WM9081_INTERRUPT_CONTROL:\r\ncase WM9081_DAC_DIGITAL_1:\r\ncase WM9081_DAC_DIGITAL_2:\r\ncase WM9081_DRC_1:\r\ncase WM9081_DRC_2:\r\ncase WM9081_DRC_3:\r\ncase WM9081_DRC_4:\r\ncase WM9081_WRITE_SEQUENCER_1:\r\ncase WM9081_WRITE_SEQUENCER_2:\r\ncase WM9081_MW_SLAVE_1:\r\ncase WM9081_EQ_1:\r\ncase WM9081_EQ_2:\r\ncase WM9081_EQ_3:\r\ncase WM9081_EQ_4:\r\ncase WM9081_EQ_5:\r\ncase WM9081_EQ_6:\r\ncase WM9081_EQ_7:\r\ncase WM9081_EQ_8:\r\ncase WM9081_EQ_9:\r\ncase WM9081_EQ_10:\r\ncase WM9081_EQ_11:\r\ncase WM9081_EQ_12:\r\ncase WM9081_EQ_13:\r\ncase WM9081_EQ_14:\r\ncase WM9081_EQ_15:\r\ncase WM9081_EQ_16:\r\ncase WM9081_EQ_17:\r\ncase WM9081_EQ_18:\r\ncase WM9081_EQ_19:\r\ncase WM9081_EQ_20:\r\nreturn true;\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nstatic int wm9081_reset(struct regmap *map)\r\n{\r\nreturn regmap_write(map, WM9081_SOFTWARE_RESET, 0x9081);\r\n}\r\nstatic int speaker_mode_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_codec *codec = snd_soc_kcontrol_codec(kcontrol);\r\nunsigned int reg;\r\nreg = snd_soc_read(codec, WM9081_ANALOGUE_SPEAKER_2);\r\nif (reg & WM9081_SPK_MODE)\r\nucontrol->value.integer.value[0] = 1;\r\nelse\r\nucontrol->value.integer.value[0] = 0;\r\nreturn 0;\r\n}\r\nstatic int speaker_mode_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_codec *codec = snd_soc_kcontrol_codec(kcontrol);\r\nunsigned int reg_pwr = snd_soc_read(codec, WM9081_POWER_MANAGEMENT);\r\nunsigned int reg2 = snd_soc_read(codec, WM9081_ANALOGUE_SPEAKER_2);\r\nif (ucontrol->value.integer.value[0] ==\r\n((reg2 & WM9081_SPK_MODE) != 0))\r\nreturn 0;\r\nif (reg_pwr & WM9081_SPK_ENA)\r\nreturn -EINVAL;\r\nif (ucontrol->value.integer.value[0]) {\r\nreg2 &= ~(WM9081_SPK_INV_MUTE | WM9081_OUT_SPK_CTRL);\r\nreg2 |= WM9081_SPK_MODE;\r\n} else {\r\nreg2 |= WM9081_SPK_INV_MUTE | WM9081_OUT_SPK_CTRL;\r\nreg2 &= ~WM9081_SPK_MODE;\r\n}\r\nsnd_soc_write(codec, WM9081_ANALOGUE_SPEAKER_2, reg2);\r\nreturn 0;\r\n}\r\nstatic int fll_factors(struct _fll_div *fll_div, unsigned int Fref,\r\nunsigned int Fout)\r\n{\r\nu64 Kpart;\r\nunsigned int K, Ndiv, Nmod, target;\r\nunsigned int div;\r\nint i;\r\ndiv = 1;\r\nwhile ((Fref / div) > 13500000) {\r\ndiv *= 2;\r\nif (div > 8) {\r\npr_err("Can't scale %dMHz input down to <=13.5MHz\n",\r\nFref);\r\nreturn -EINVAL;\r\n}\r\n}\r\nfll_div->fll_clk_ref_div = div / 2;\r\npr_debug("Fref=%u Fout=%u\n", Fref, Fout);\r\nFref /= div;\r\ndiv = 0;\r\ntarget = Fout * 2;\r\nwhile (target < 90000000) {\r\ndiv++;\r\ntarget *= 2;\r\nif (div > 7) {\r\npr_err("Unable to find FLL_OUTDIV for Fout=%uHz\n",\r\nFout);\r\nreturn -EINVAL;\r\n}\r\n}\r\nfll_div->fll_outdiv = div;\r\npr_debug("Fvco=%dHz\n", target);\r\nfor (i = 0; i < ARRAY_SIZE(fll_fratios); i++) {\r\nif (fll_fratios[i].min <= Fref && Fref <= fll_fratios[i].max) {\r\nfll_div->fll_fratio = fll_fratios[i].fll_fratio;\r\ntarget /= fll_fratios[i].ratio;\r\nbreak;\r\n}\r\n}\r\nif (i == ARRAY_SIZE(fll_fratios)) {\r\npr_err("Unable to find FLL_FRATIO for Fref=%uHz\n", Fref);\r\nreturn -EINVAL;\r\n}\r\nNdiv = target / Fref;\r\nfll_div->n = Ndiv;\r\nNmod = target % Fref;\r\npr_debug("Nmod=%d\n", Nmod);\r\nKpart = FIXED_FLL_SIZE * (long long)Nmod;\r\ndo_div(Kpart, Fref);\r\nK = Kpart & 0xFFFFFFFF;\r\nif ((K % 10) >= 5)\r\nK += 5;\r\nfll_div->k = K / 10;\r\npr_debug("N=%x K=%x FLL_FRATIO=%x FLL_OUTDIV=%x FLL_CLK_REF_DIV=%x\n",\r\nfll_div->n, fll_div->k,\r\nfll_div->fll_fratio, fll_div->fll_outdiv,\r\nfll_div->fll_clk_ref_div);\r\nreturn 0;\r\n}\r\nstatic int wm9081_set_fll(struct snd_soc_codec *codec, int fll_id,\r\nunsigned int Fref, unsigned int Fout)\r\n{\r\nstruct wm9081_priv *wm9081 = snd_soc_codec_get_drvdata(codec);\r\nu16 reg1, reg4, reg5;\r\nstruct _fll_div fll_div;\r\nint ret;\r\nint clk_sys_reg;\r\nif (Fref == wm9081->fll_fref && Fout == wm9081->fll_fout)\r\nreturn 0;\r\nif (Fout == 0) {\r\ndev_dbg(codec->dev, "FLL disabled\n");\r\nwm9081->fll_fref = 0;\r\nwm9081->fll_fout = 0;\r\nreturn 0;\r\n}\r\nret = fll_factors(&fll_div, Fref, Fout);\r\nif (ret != 0)\r\nreturn ret;\r\nreg5 = snd_soc_read(codec, WM9081_FLL_CONTROL_5);\r\nreg5 &= ~WM9081_FLL_CLK_SRC_MASK;\r\nswitch (fll_id) {\r\ncase WM9081_SYSCLK_FLL_MCLK:\r\nreg5 |= 0x1;\r\nbreak;\r\ndefault:\r\ndev_err(codec->dev, "Unknown FLL ID %d\n", fll_id);\r\nreturn -EINVAL;\r\n}\r\nclk_sys_reg = snd_soc_read(codec, WM9081_CLOCK_CONTROL_3);\r\nif (clk_sys_reg & WM9081_CLK_SYS_ENA)\r\nsnd_soc_write(codec, WM9081_CLOCK_CONTROL_3,\r\nclk_sys_reg & ~WM9081_CLK_SYS_ENA);\r\nreg1 = snd_soc_read(codec, WM9081_FLL_CONTROL_1);\r\nreg1 &= ~WM9081_FLL_ENA;\r\nsnd_soc_write(codec, WM9081_FLL_CONTROL_1, reg1);\r\nif (fll_div.k)\r\nreg1 |= WM9081_FLL_FRAC_MASK;\r\nelse\r\nreg1 &= ~WM9081_FLL_FRAC_MASK;\r\nsnd_soc_write(codec, WM9081_FLL_CONTROL_1, reg1);\r\nsnd_soc_write(codec, WM9081_FLL_CONTROL_2,\r\n(fll_div.fll_outdiv << WM9081_FLL_OUTDIV_SHIFT) |\r\n(fll_div.fll_fratio << WM9081_FLL_FRATIO_SHIFT));\r\nsnd_soc_write(codec, WM9081_FLL_CONTROL_3, fll_div.k);\r\nreg4 = snd_soc_read(codec, WM9081_FLL_CONTROL_4);\r\nreg4 &= ~WM9081_FLL_N_MASK;\r\nreg4 |= fll_div.n << WM9081_FLL_N_SHIFT;\r\nsnd_soc_write(codec, WM9081_FLL_CONTROL_4, reg4);\r\nreg5 &= ~WM9081_FLL_CLK_REF_DIV_MASK;\r\nreg5 |= fll_div.fll_clk_ref_div << WM9081_FLL_CLK_REF_DIV_SHIFT;\r\nsnd_soc_write(codec, WM9081_FLL_CONTROL_5, reg5);\r\nsnd_soc_update_bits(codec, WM9081_FLL_CONTROL_4,\r\nWM9081_FLL_GAIN_MASK, 0);\r\nsnd_soc_write(codec, WM9081_FLL_CONTROL_1, reg1 | WM9081_FLL_ENA);\r\nif (clk_sys_reg & WM9081_CLK_SYS_ENA)\r\nsnd_soc_write(codec, WM9081_CLOCK_CONTROL_3, clk_sys_reg);\r\ndev_dbg(codec->dev, "FLL enabled at %dHz->%dHz\n", Fref, Fout);\r\nwm9081->fll_fref = Fref;\r\nwm9081->fll_fout = Fout;\r\nreturn 0;\r\n}\r\nstatic int configure_clock(struct snd_soc_codec *codec)\r\n{\r\nstruct wm9081_priv *wm9081 = snd_soc_codec_get_drvdata(codec);\r\nint new_sysclk, i, target;\r\nunsigned int reg;\r\nint ret = 0;\r\nint mclkdiv = 0;\r\nint fll = 0;\r\nswitch (wm9081->sysclk_source) {\r\ncase WM9081_SYSCLK_MCLK:\r\nif (wm9081->mclk_rate > 12225000) {\r\nmclkdiv = 1;\r\nwm9081->sysclk_rate = wm9081->mclk_rate / 2;\r\n} else {\r\nwm9081->sysclk_rate = wm9081->mclk_rate;\r\n}\r\nwm9081_set_fll(codec, WM9081_SYSCLK_FLL_MCLK, 0, 0);\r\nbreak;\r\ncase WM9081_SYSCLK_FLL_MCLK:\r\nif (wm9081->master && wm9081->bclk) {\r\nfor (i = 0; i < ARRAY_SIZE(clk_sys_rates); i++) {\r\ntarget = wm9081->fs * clk_sys_rates[i].ratio;\r\nnew_sysclk = target;\r\nif (target >= wm9081->bclk &&\r\ntarget > 3000000)\r\nbreak;\r\n}\r\nif (i == ARRAY_SIZE(clk_sys_rates))\r\nreturn -EINVAL;\r\n} else if (wm9081->fs) {\r\nfor (i = 0; i < ARRAY_SIZE(clk_sys_rates); i++) {\r\nnew_sysclk = clk_sys_rates[i].ratio\r\n* wm9081->fs;\r\nif (new_sysclk > 3000000)\r\nbreak;\r\n}\r\nif (i == ARRAY_SIZE(clk_sys_rates))\r\nreturn -EINVAL;\r\n} else {\r\nnew_sysclk = 12288000;\r\n}\r\nret = wm9081_set_fll(codec, WM9081_SYSCLK_FLL_MCLK,\r\nwm9081->mclk_rate, new_sysclk);\r\nif (ret == 0) {\r\nwm9081->sysclk_rate = new_sysclk;\r\nfll = 1;\r\n} else {\r\nwm9081->sysclk_rate = wm9081->mclk_rate;\r\n}\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreg = snd_soc_read(codec, WM9081_CLOCK_CONTROL_1);\r\nif (mclkdiv)\r\nreg |= WM9081_MCLKDIV2;\r\nelse\r\nreg &= ~WM9081_MCLKDIV2;\r\nsnd_soc_write(codec, WM9081_CLOCK_CONTROL_1, reg);\r\nreg = snd_soc_read(codec, WM9081_CLOCK_CONTROL_3);\r\nif (fll)\r\nreg |= WM9081_CLK_SRC_SEL;\r\nelse\r\nreg &= ~WM9081_CLK_SRC_SEL;\r\nsnd_soc_write(codec, WM9081_CLOCK_CONTROL_3, reg);\r\ndev_dbg(codec->dev, "CLK_SYS is %dHz\n", wm9081->sysclk_rate);\r\nreturn ret;\r\n}\r\nstatic int clk_sys_event(struct snd_soc_dapm_widget *w,\r\nstruct snd_kcontrol *kcontrol, int event)\r\n{\r\nstruct snd_soc_codec *codec = snd_soc_dapm_to_codec(w->dapm);\r\nstruct wm9081_priv *wm9081 = snd_soc_codec_get_drvdata(codec);\r\nswitch (wm9081->sysclk_source) {\r\ncase WM9081_SYSCLK_MCLK:\r\ndev_dbg(codec->dev, "Using %dHz MCLK\n", wm9081->mclk_rate);\r\nbreak;\r\ncase WM9081_SYSCLK_FLL_MCLK:\r\ndev_dbg(codec->dev, "Using %dHz MCLK with FLL\n",\r\nwm9081->mclk_rate);\r\nbreak;\r\ndefault:\r\ndev_err(codec->dev, "System clock not configured\n");\r\nreturn -EINVAL;\r\n}\r\nswitch (event) {\r\ncase SND_SOC_DAPM_PRE_PMU:\r\nconfigure_clock(codec);\r\nbreak;\r\ncase SND_SOC_DAPM_POST_PMD:\r\nwm9081_set_fll(codec, 0, 0, 0);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int wm9081_set_bias_level(struct snd_soc_codec *codec,\r\nenum snd_soc_bias_level level)\r\n{\r\nstruct wm9081_priv *wm9081 = snd_soc_codec_get_drvdata(codec);\r\nswitch (level) {\r\ncase SND_SOC_BIAS_ON:\r\nbreak;\r\ncase SND_SOC_BIAS_PREPARE:\r\nsnd_soc_update_bits(codec, WM9081_VMID_CONTROL,\r\nWM9081_VMID_SEL_MASK, 0x2);\r\nsnd_soc_update_bits(codec, WM9081_BIAS_CONTROL_1,\r\nWM9081_STBY_BIAS_ENA, 0);\r\nbreak;\r\ncase SND_SOC_BIAS_STANDBY:\r\nif (codec->dapm.bias_level == SND_SOC_BIAS_OFF) {\r\nregcache_cache_only(wm9081->regmap, false);\r\nregcache_sync(wm9081->regmap);\r\nsnd_soc_update_bits(codec, WM9081_ANTI_POP_CONTROL,\r\nWM9081_LINEOUT_DISCH, 0);\r\nsnd_soc_update_bits(codec, WM9081_BIAS_CONTROL_1,\r\nWM9081_BIAS_SRC | WM9081_BIAS_ENA,\r\nWM9081_BIAS_SRC | WM9081_BIAS_ENA);\r\nsnd_soc_update_bits(codec, WM9081_VMID_CONTROL,\r\nWM9081_VMID_RAMP |\r\nWM9081_VMID_SEL_MASK,\r\nWM9081_VMID_RAMP | 0x6);\r\nmdelay(100);\r\nsnd_soc_update_bits(codec, WM9081_VMID_CONTROL,\r\nWM9081_VMID_RAMP, 0);\r\nsnd_soc_update_bits(codec, WM9081_BIAS_CONTROL_1,\r\nWM9081_BIAS_SRC, 0);\r\n}\r\nsnd_soc_update_bits(codec, WM9081_VMID_CONTROL,\r\nWM9081_VMID_SEL_MASK, 0x04);\r\nsnd_soc_update_bits(codec, WM9081_BIAS_CONTROL_1,\r\nWM9081_STBY_BIAS_ENA,\r\nWM9081_STBY_BIAS_ENA);\r\nbreak;\r\ncase SND_SOC_BIAS_OFF:\r\nsnd_soc_update_bits(codec, WM9081_BIAS_CONTROL_1,\r\nWM9081_BIAS_SRC | WM9081_BIAS_ENA,\r\nWM9081_BIAS_SRC);\r\nsnd_soc_update_bits(codec, WM9081_VMID_CONTROL,\r\nWM9081_VMID_RAMP | WM9081_VMID_SEL_MASK,\r\nWM9081_VMID_RAMP);\r\nsnd_soc_update_bits(codec, WM9081_ANTI_POP_CONTROL,\r\nWM9081_LINEOUT_DISCH,\r\nWM9081_LINEOUT_DISCH);\r\nregcache_cache_only(wm9081->regmap, true);\r\nbreak;\r\n}\r\ncodec->dapm.bias_level = level;\r\nreturn 0;\r\n}\r\nstatic int wm9081_set_dai_fmt(struct snd_soc_dai *dai,\r\nunsigned int fmt)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nstruct wm9081_priv *wm9081 = snd_soc_codec_get_drvdata(codec);\r\nunsigned int aif2 = snd_soc_read(codec, WM9081_AUDIO_INTERFACE_2);\r\naif2 &= ~(WM9081_AIF_BCLK_INV | WM9081_AIF_LRCLK_INV |\r\nWM9081_BCLK_DIR | WM9081_LRCLK_DIR | WM9081_AIF_FMT_MASK);\r\nswitch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {\r\ncase SND_SOC_DAIFMT_CBS_CFS:\r\nwm9081->master = 0;\r\nbreak;\r\ncase SND_SOC_DAIFMT_CBS_CFM:\r\naif2 |= WM9081_LRCLK_DIR;\r\nwm9081->master = 1;\r\nbreak;\r\ncase SND_SOC_DAIFMT_CBM_CFS:\r\naif2 |= WM9081_BCLK_DIR;\r\nwm9081->master = 1;\r\nbreak;\r\ncase SND_SOC_DAIFMT_CBM_CFM:\r\naif2 |= WM9081_LRCLK_DIR | WM9081_BCLK_DIR;\r\nwm9081->master = 1;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\r\ncase SND_SOC_DAIFMT_DSP_B:\r\naif2 |= WM9081_AIF_LRCLK_INV;\r\ncase SND_SOC_DAIFMT_DSP_A:\r\naif2 |= 0x3;\r\nbreak;\r\ncase SND_SOC_DAIFMT_I2S:\r\naif2 |= 0x2;\r\nbreak;\r\ncase SND_SOC_DAIFMT_RIGHT_J:\r\nbreak;\r\ncase SND_SOC_DAIFMT_LEFT_J:\r\naif2 |= 0x1;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\r\ncase SND_SOC_DAIFMT_DSP_A:\r\ncase SND_SOC_DAIFMT_DSP_B:\r\nswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\r\ncase SND_SOC_DAIFMT_NB_NF:\r\nbreak;\r\ncase SND_SOC_DAIFMT_IB_NF:\r\naif2 |= WM9081_AIF_BCLK_INV;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ncase SND_SOC_DAIFMT_I2S:\r\ncase SND_SOC_DAIFMT_RIGHT_J:\r\ncase SND_SOC_DAIFMT_LEFT_J:\r\nswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\r\ncase SND_SOC_DAIFMT_NB_NF:\r\nbreak;\r\ncase SND_SOC_DAIFMT_IB_IF:\r\naif2 |= WM9081_AIF_BCLK_INV | WM9081_AIF_LRCLK_INV;\r\nbreak;\r\ncase SND_SOC_DAIFMT_IB_NF:\r\naif2 |= WM9081_AIF_BCLK_INV;\r\nbreak;\r\ncase SND_SOC_DAIFMT_NB_IF:\r\naif2 |= WM9081_AIF_LRCLK_INV;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nsnd_soc_write(codec, WM9081_AUDIO_INTERFACE_2, aif2);\r\nreturn 0;\r\n}\r\nstatic int wm9081_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nstruct wm9081_priv *wm9081 = snd_soc_codec_get_drvdata(codec);\r\nint ret, i, best, best_val, cur_val;\r\nunsigned int clk_ctrl2, aif1, aif2, aif3, aif4;\r\nclk_ctrl2 = snd_soc_read(codec, WM9081_CLOCK_CONTROL_2);\r\nclk_ctrl2 &= ~(WM9081_CLK_SYS_RATE_MASK | WM9081_SAMPLE_RATE_MASK);\r\naif1 = snd_soc_read(codec, WM9081_AUDIO_INTERFACE_1);\r\naif2 = snd_soc_read(codec, WM9081_AUDIO_INTERFACE_2);\r\naif2 &= ~WM9081_AIF_WL_MASK;\r\naif3 = snd_soc_read(codec, WM9081_AUDIO_INTERFACE_3);\r\naif3 &= ~WM9081_BCLK_DIV_MASK;\r\naif4 = snd_soc_read(codec, WM9081_AUDIO_INTERFACE_4);\r\naif4 &= ~WM9081_LRCLK_RATE_MASK;\r\nwm9081->fs = params_rate(params);\r\nif (wm9081->tdm_width) {\r\nint slots = ((aif1 & WM9081_AIFDAC_TDM_MODE_MASK) >>\r\nWM9081_AIFDAC_TDM_MODE_SHIFT) + 1;\r\nwm9081->bclk = wm9081->fs * wm9081->tdm_width * slots;\r\n} else {\r\nwm9081->bclk = 2 * wm9081->fs;\r\nswitch (params_width(params)) {\r\ncase 16:\r\nwm9081->bclk *= 16;\r\nbreak;\r\ncase 20:\r\nwm9081->bclk *= 20;\r\naif2 |= 0x4;\r\nbreak;\r\ncase 24:\r\nwm9081->bclk *= 24;\r\naif2 |= 0x8;\r\nbreak;\r\ncase 32:\r\nwm9081->bclk *= 32;\r\naif2 |= 0xc;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\ndev_dbg(codec->dev, "Target BCLK is %dHz\n", wm9081->bclk);\r\nret = configure_clock(codec);\r\nif (ret != 0)\r\nreturn ret;\r\nbest = 0;\r\nbest_val = abs((wm9081->sysclk_rate / clk_sys_rates[0].ratio)\r\n- wm9081->fs);\r\nfor (i = 1; i < ARRAY_SIZE(clk_sys_rates); i++) {\r\ncur_val = abs((wm9081->sysclk_rate /\r\nclk_sys_rates[i].ratio) - wm9081->fs);\r\nif (cur_val < best_val) {\r\nbest = i;\r\nbest_val = cur_val;\r\n}\r\n}\r\ndev_dbg(codec->dev, "Selected CLK_SYS_RATIO of %d\n",\r\nclk_sys_rates[best].ratio);\r\nclk_ctrl2 |= (clk_sys_rates[best].clk_sys_rate\r\n<< WM9081_CLK_SYS_RATE_SHIFT);\r\nbest = 0;\r\nbest_val = abs(wm9081->fs - sample_rates[0].rate);\r\nfor (i = 1; i < ARRAY_SIZE(sample_rates); i++) {\r\ncur_val = abs(wm9081->fs - sample_rates[i].rate);\r\nif (cur_val < best_val) {\r\nbest = i;\r\nbest_val = cur_val;\r\n}\r\n}\r\ndev_dbg(codec->dev, "Selected SAMPLE_RATE of %dHz\n",\r\nsample_rates[best].rate);\r\nclk_ctrl2 |= (sample_rates[best].sample_rate\r\n<< WM9081_SAMPLE_RATE_SHIFT);\r\nbest = 0;\r\nbest_val = INT_MAX;\r\nfor (i = 0; i < ARRAY_SIZE(bclk_divs); i++) {\r\ncur_val = ((wm9081->sysclk_rate * 10) / bclk_divs[i].div)\r\n- wm9081->bclk;\r\nif (cur_val < 0)\r\nbreak;\r\nif (cur_val < best_val) {\r\nbest = i;\r\nbest_val = cur_val;\r\n}\r\n}\r\nwm9081->bclk = (wm9081->sysclk_rate * 10) / bclk_divs[best].div;\r\ndev_dbg(codec->dev, "Selected BCLK_DIV of %d for %dHz BCLK\n",\r\nbclk_divs[best].div, wm9081->bclk);\r\naif3 |= bclk_divs[best].bclk_div;\r\ndev_dbg(codec->dev, "LRCLK_RATE is %d\n", wm9081->bclk / wm9081->fs);\r\naif4 |= wm9081->bclk / wm9081->fs;\r\nif (wm9081->pdata.num_retune_configs) {\r\nstruct wm9081_pdata *pdata = &wm9081->pdata;\r\nstruct wm9081_retune_mobile_setting *s;\r\nint eq1;\r\nbest = 0;\r\nbest_val = abs(pdata->retune_configs[0].rate - wm9081->fs);\r\nfor (i = 0; i < pdata->num_retune_configs; i++) {\r\ncur_val = abs(pdata->retune_configs[i].rate -\r\nwm9081->fs);\r\nif (cur_val < best_val) {\r\nbest_val = cur_val;\r\nbest = i;\r\n}\r\n}\r\ns = &pdata->retune_configs[best];\r\ndev_dbg(codec->dev, "ReTune Mobile %s tuned for %dHz\n",\r\ns->name, s->rate);\r\neq1 = snd_soc_read(codec, WM9081_EQ_1) & WM9081_EQ_ENA;\r\nif (eq1 & WM9081_EQ_ENA)\r\nsnd_soc_write(codec, WM9081_EQ_1, 0);\r\nfor (i = 1; i < ARRAY_SIZE(s->config); i++)\r\nsnd_soc_write(codec, WM9081_EQ_1 + i, s->config[i]);\r\neq1 |= (s->config[0] & ~WM9081_EQ_ENA);\r\nsnd_soc_write(codec, WM9081_EQ_1, eq1);\r\n}\r\nsnd_soc_write(codec, WM9081_CLOCK_CONTROL_2, clk_ctrl2);\r\nsnd_soc_write(codec, WM9081_AUDIO_INTERFACE_2, aif2);\r\nsnd_soc_write(codec, WM9081_AUDIO_INTERFACE_3, aif3);\r\nsnd_soc_write(codec, WM9081_AUDIO_INTERFACE_4, aif4);\r\nreturn 0;\r\n}\r\nstatic int wm9081_digital_mute(struct snd_soc_dai *codec_dai, int mute)\r\n{\r\nstruct snd_soc_codec *codec = codec_dai->codec;\r\nunsigned int reg;\r\nreg = snd_soc_read(codec, WM9081_DAC_DIGITAL_2);\r\nif (mute)\r\nreg |= WM9081_DAC_MUTE;\r\nelse\r\nreg &= ~WM9081_DAC_MUTE;\r\nsnd_soc_write(codec, WM9081_DAC_DIGITAL_2, reg);\r\nreturn 0;\r\n}\r\nstatic int wm9081_set_sysclk(struct snd_soc_codec *codec, int clk_id,\r\nint source, unsigned int freq, int dir)\r\n{\r\nstruct wm9081_priv *wm9081 = snd_soc_codec_get_drvdata(codec);\r\nswitch (clk_id) {\r\ncase WM9081_SYSCLK_MCLK:\r\ncase WM9081_SYSCLK_FLL_MCLK:\r\nwm9081->sysclk_source = clk_id;\r\nwm9081->mclk_rate = freq;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int wm9081_set_tdm_slot(struct snd_soc_dai *dai,\r\nunsigned int tx_mask, unsigned int rx_mask, int slots, int slot_width)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nstruct wm9081_priv *wm9081 = snd_soc_codec_get_drvdata(codec);\r\nunsigned int aif1 = snd_soc_read(codec, WM9081_AUDIO_INTERFACE_1);\r\naif1 &= ~(WM9081_AIFDAC_TDM_SLOT_MASK | WM9081_AIFDAC_TDM_MODE_MASK);\r\nif (slots < 0 || slots > 4)\r\nreturn -EINVAL;\r\nwm9081->tdm_width = slot_width;\r\nif (slots == 0)\r\nslots = 1;\r\naif1 |= (slots - 1) << WM9081_AIFDAC_TDM_MODE_SHIFT;\r\nswitch (rx_mask) {\r\ncase 1:\r\nbreak;\r\ncase 2:\r\naif1 |= 0x10;\r\nbreak;\r\ncase 4:\r\naif1 |= 0x20;\r\nbreak;\r\ncase 8:\r\naif1 |= 0x30;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nsnd_soc_write(codec, WM9081_AUDIO_INTERFACE_1, aif1);\r\nreturn 0;\r\n}\r\nstatic int wm9081_probe(struct snd_soc_codec *codec)\r\n{\r\nstruct wm9081_priv *wm9081 = snd_soc_codec_get_drvdata(codec);\r\nsnd_soc_update_bits(codec, WM9081_ANALOGUE_LINEOUT,\r\nWM9081_LINEOUTZC, WM9081_LINEOUTZC);\r\nsnd_soc_update_bits(codec, WM9081_ANALOGUE_SPEAKER_PGA,\r\nWM9081_SPKPGAZC, WM9081_SPKPGAZC);\r\nif (!wm9081->pdata.num_retune_configs) {\r\ndev_dbg(codec->dev,\r\n"No ReTune Mobile data, using normal EQ\n");\r\nsnd_soc_add_codec_controls(codec, wm9081_eq_controls,\r\nARRAY_SIZE(wm9081_eq_controls));\r\n}\r\nreturn 0;\r\n}\r\nstatic int wm9081_i2c_probe(struct i2c_client *i2c,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct wm9081_priv *wm9081;\r\nunsigned int reg;\r\nint ret;\r\nwm9081 = devm_kzalloc(&i2c->dev, sizeof(struct wm9081_priv),\r\nGFP_KERNEL);\r\nif (wm9081 == NULL)\r\nreturn -ENOMEM;\r\ni2c_set_clientdata(i2c, wm9081);\r\nwm9081->regmap = devm_regmap_init_i2c(i2c, &wm9081_regmap);\r\nif (IS_ERR(wm9081->regmap)) {\r\nret = PTR_ERR(wm9081->regmap);\r\ndev_err(&i2c->dev, "regmap_init() failed: %d\n", ret);\r\nreturn ret;\r\n}\r\nret = regmap_read(wm9081->regmap, WM9081_SOFTWARE_RESET, &reg);\r\nif (ret != 0) {\r\ndev_err(&i2c->dev, "Failed to read chip ID: %d\n", ret);\r\nreturn ret;\r\n}\r\nif (reg != 0x9081) {\r\ndev_err(&i2c->dev, "Device is not a WM9081: ID=0x%x\n", reg);\r\nreturn -EINVAL;\r\n}\r\nret = wm9081_reset(wm9081->regmap);\r\nif (ret < 0) {\r\ndev_err(&i2c->dev, "Failed to issue reset\n");\r\nreturn ret;\r\n}\r\nif (dev_get_platdata(&i2c->dev))\r\nmemcpy(&wm9081->pdata, dev_get_platdata(&i2c->dev),\r\nsizeof(wm9081->pdata));\r\nreg = 0;\r\nif (wm9081->pdata.irq_high)\r\nreg |= WM9081_IRQ_POL;\r\nif (!wm9081->pdata.irq_cmos)\r\nreg |= WM9081_IRQ_OP_CTRL;\r\nregmap_update_bits(wm9081->regmap, WM9081_INTERRUPT_CONTROL,\r\nWM9081_IRQ_POL | WM9081_IRQ_OP_CTRL, reg);\r\nregcache_cache_only(wm9081->regmap, true);\r\nret = snd_soc_register_codec(&i2c->dev,\r\n&soc_codec_dev_wm9081, &wm9081_dai, 1);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nstatic int wm9081_i2c_remove(struct i2c_client *client)\r\n{\r\nsnd_soc_unregister_codec(&client->dev);\r\nreturn 0;\r\n}
