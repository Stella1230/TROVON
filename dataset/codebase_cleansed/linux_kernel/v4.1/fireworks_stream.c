static int\r\ninit_stream(struct snd_efw *efw, struct amdtp_stream *stream)\r\n{\r\nstruct cmp_connection *conn;\r\nenum cmp_direction c_dir;\r\nenum amdtp_stream_direction s_dir;\r\nint err;\r\nif (stream == &efw->tx_stream) {\r\nconn = &efw->out_conn;\r\nc_dir = CMP_OUTPUT;\r\ns_dir = AMDTP_IN_STREAM;\r\n} else {\r\nconn = &efw->in_conn;\r\nc_dir = CMP_INPUT;\r\ns_dir = AMDTP_OUT_STREAM;\r\n}\r\nerr = cmp_connection_init(conn, efw->unit, c_dir, 0);\r\nif (err < 0)\r\ngoto end;\r\nerr = amdtp_stream_init(stream, efw->unit, s_dir, CIP_BLOCKING);\r\nif (err < 0) {\r\namdtp_stream_destroy(stream);\r\ncmp_connection_destroy(conn);\r\n}\r\nend:\r\nreturn err;\r\n}\r\nstatic void\r\nstop_stream(struct snd_efw *efw, struct amdtp_stream *stream)\r\n{\r\namdtp_stream_pcm_abort(stream);\r\namdtp_stream_stop(stream);\r\nif (stream == &efw->tx_stream)\r\ncmp_connection_break(&efw->out_conn);\r\nelse\r\ncmp_connection_break(&efw->in_conn);\r\n}\r\nstatic int\r\nstart_stream(struct snd_efw *efw, struct amdtp_stream *stream,\r\nunsigned int sampling_rate)\r\n{\r\nstruct cmp_connection *conn;\r\nunsigned int mode, pcm_channels, midi_ports;\r\nint err;\r\nerr = snd_efw_get_multiplier_mode(sampling_rate, &mode);\r\nif (err < 0)\r\ngoto end;\r\nif (stream == &efw->tx_stream) {\r\nconn = &efw->out_conn;\r\npcm_channels = efw->pcm_capture_channels[mode];\r\nmidi_ports = efw->midi_out_ports;\r\n} else {\r\nconn = &efw->in_conn;\r\npcm_channels = efw->pcm_playback_channels[mode];\r\nmidi_ports = efw->midi_in_ports;\r\n}\r\namdtp_stream_set_parameters(stream, sampling_rate,\r\npcm_channels, midi_ports);\r\nerr = cmp_connection_establish(conn,\r\namdtp_stream_get_max_payload(stream));\r\nif (err < 0)\r\ngoto end;\r\nerr = amdtp_stream_start(stream,\r\nconn->resources.channel,\r\nconn->speed);\r\nif (err < 0) {\r\nstop_stream(efw, stream);\r\ngoto end;\r\n}\r\nif (!amdtp_stream_wait_callback(stream, CALLBACK_TIMEOUT)) {\r\nstop_stream(efw, stream);\r\nerr = -ETIMEDOUT;\r\n}\r\nend:\r\nreturn err;\r\n}\r\nstatic void\r\ndestroy_stream(struct snd_efw *efw, struct amdtp_stream *stream)\r\n{\r\nstruct cmp_connection *conn;\r\nif (stream == &efw->tx_stream)\r\nconn = &efw->out_conn;\r\nelse\r\nconn = &efw->in_conn;\r\namdtp_stream_destroy(stream);\r\ncmp_connection_destroy(&efw->out_conn);\r\n}\r\nstatic int\r\nget_sync_mode(struct snd_efw *efw, enum cip_flags *sync_mode)\r\n{\r\nenum snd_efw_clock_source clock_source;\r\nint err;\r\nerr = snd_efw_command_get_clock_source(efw, &clock_source);\r\nif (err < 0)\r\nreturn err;\r\nif (clock_source == SND_EFW_CLOCK_SOURCE_SYTMATCH)\r\nreturn -ENOSYS;\r\n*sync_mode = CIP_SYNC_TO_DEVICE;\r\nreturn 0;\r\n}\r\nstatic int\r\ncheck_connection_used_by_others(struct snd_efw *efw, struct amdtp_stream *s)\r\n{\r\nstruct cmp_connection *conn;\r\nbool used;\r\nint err;\r\nif (s == &efw->tx_stream)\r\nconn = &efw->out_conn;\r\nelse\r\nconn = &efw->in_conn;\r\nerr = cmp_connection_check_used(conn, &used);\r\nif ((err >= 0) && used && !amdtp_stream_running(s)) {\r\ndev_err(&efw->unit->device,\r\n"Connection established by others: %cPCR[%d]\n",\r\n(conn->direction == CMP_OUTPUT) ? 'o' : 'i',\r\nconn->pcr_index);\r\nerr = -EBUSY;\r\n}\r\nreturn err;\r\n}\r\nint snd_efw_stream_init_duplex(struct snd_efw *efw)\r\n{\r\nint err;\r\nerr = init_stream(efw, &efw->tx_stream);\r\nif (err < 0)\r\ngoto end;\r\nefw->tx_stream.flags |= CIP_EMPTY_WITH_TAG0;\r\nefw->tx_stream.flags |= CIP_DBC_IS_END_EVENT;\r\nefw->tx_stream.flags |= CIP_SKIP_DBC_ZERO_CHECK;\r\nif (efw->is_af9)\r\nefw->tx_stream.flags |= CIP_WRONG_DBS;\r\nif (efw->firmware_version == 0x5050000)\r\nefw->tx_stream.tx_dbc_interval = 8;\r\nerr = init_stream(efw, &efw->rx_stream);\r\nif (err < 0) {\r\ndestroy_stream(efw, &efw->tx_stream);\r\ngoto end;\r\n}\r\nerr = snd_efw_command_set_tx_mode(efw, SND_EFW_TRANSPORT_MODE_IEC61883);\r\nif (err < 0) {\r\ndestroy_stream(efw, &efw->tx_stream);\r\ndestroy_stream(efw, &efw->rx_stream);\r\n}\r\nend:\r\nreturn err;\r\n}\r\nint snd_efw_stream_start_duplex(struct snd_efw *efw, unsigned int rate)\r\n{\r\nstruct amdtp_stream *master, *slave;\r\natomic_t *slave_substreams;\r\nenum cip_flags sync_mode;\r\nunsigned int curr_rate;\r\nint err = 0;\r\nmutex_lock(&efw->mutex);\r\nif ((atomic_read(&efw->playback_substreams) == 0) &&\r\n(atomic_read(&efw->capture_substreams) == 0))\r\ngoto end;\r\nerr = get_sync_mode(efw, &sync_mode);\r\nif (err < 0)\r\ngoto end;\r\nif (sync_mode == CIP_SYNC_TO_DEVICE) {\r\nmaster = &efw->tx_stream;\r\nslave = &efw->rx_stream;\r\nslave_substreams = &efw->playback_substreams;\r\n} else {\r\nmaster = &efw->rx_stream;\r\nslave = &efw->tx_stream;\r\nslave_substreams = &efw->capture_substreams;\r\n}\r\nerr = check_connection_used_by_others(efw, master);\r\nif (err < 0)\r\ngoto end;\r\nif (amdtp_streaming_error(slave))\r\nstop_stream(efw, slave);\r\nif (amdtp_streaming_error(master))\r\nstop_stream(efw, master);\r\nerr = snd_efw_command_get_sampling_rate(efw, &curr_rate);\r\nif (err < 0)\r\ngoto end;\r\nif (rate == 0)\r\nrate = curr_rate;\r\nif (rate != curr_rate) {\r\nstop_stream(efw, slave);\r\nstop_stream(efw, master);\r\n}\r\nif (!amdtp_stream_running(master)) {\r\namdtp_stream_set_sync(sync_mode, master, slave);\r\nefw->master = master;\r\nerr = snd_efw_command_set_sampling_rate(efw, rate);\r\nif (err < 0)\r\ngoto end;\r\nerr = start_stream(efw, master, rate);\r\nif (err < 0) {\r\ndev_err(&efw->unit->device,\r\n"fail to start AMDTP master stream:%d\n", err);\r\ngoto end;\r\n}\r\n}\r\nif (atomic_read(slave_substreams) > 0 && !amdtp_stream_running(slave)) {\r\nerr = start_stream(efw, slave, rate);\r\nif (err < 0) {\r\ndev_err(&efw->unit->device,\r\n"fail to start AMDTP slave stream:%d\n", err);\r\nstop_stream(efw, master);\r\n}\r\n}\r\nend:\r\nmutex_unlock(&efw->mutex);\r\nreturn err;\r\n}\r\nvoid snd_efw_stream_stop_duplex(struct snd_efw *efw)\r\n{\r\nstruct amdtp_stream *master, *slave;\r\natomic_t *master_substreams, *slave_substreams;\r\nif (efw->master == &efw->rx_stream) {\r\nslave = &efw->tx_stream;\r\nmaster = &efw->rx_stream;\r\nslave_substreams = &efw->capture_substreams;\r\nmaster_substreams = &efw->playback_substreams;\r\n} else {\r\nslave = &efw->rx_stream;\r\nmaster = &efw->tx_stream;\r\nslave_substreams = &efw->playback_substreams;\r\nmaster_substreams = &efw->capture_substreams;\r\n}\r\nmutex_lock(&efw->mutex);\r\nif (atomic_read(slave_substreams) == 0) {\r\nstop_stream(efw, slave);\r\nif (atomic_read(master_substreams) == 0)\r\nstop_stream(efw, master);\r\n}\r\nmutex_unlock(&efw->mutex);\r\n}\r\nvoid snd_efw_stream_update_duplex(struct snd_efw *efw)\r\n{\r\nif ((cmp_connection_update(&efw->out_conn) < 0) ||\r\n(cmp_connection_update(&efw->in_conn) < 0)) {\r\nmutex_lock(&efw->mutex);\r\nstop_stream(efw, &efw->rx_stream);\r\nstop_stream(efw, &efw->tx_stream);\r\nmutex_unlock(&efw->mutex);\r\n} else {\r\namdtp_stream_update(&efw->rx_stream);\r\namdtp_stream_update(&efw->tx_stream);\r\n}\r\n}\r\nvoid snd_efw_stream_destroy_duplex(struct snd_efw *efw)\r\n{\r\ndestroy_stream(efw, &efw->rx_stream);\r\ndestroy_stream(efw, &efw->tx_stream);\r\n}\r\nvoid snd_efw_stream_lock_changed(struct snd_efw *efw)\r\n{\r\nefw->dev_lock_changed = true;\r\nwake_up(&efw->hwdep_wait);\r\n}\r\nint snd_efw_stream_lock_try(struct snd_efw *efw)\r\n{\r\nint err;\r\nspin_lock_irq(&efw->lock);\r\nif (efw->dev_lock_count < 0) {\r\nerr = -EBUSY;\r\ngoto end;\r\n}\r\nif (efw->dev_lock_count++ == 0)\r\nsnd_efw_stream_lock_changed(efw);\r\nerr = 0;\r\nend:\r\nspin_unlock_irq(&efw->lock);\r\nreturn err;\r\n}\r\nvoid snd_efw_stream_lock_release(struct snd_efw *efw)\r\n{\r\nspin_lock_irq(&efw->lock);\r\nif (WARN_ON(efw->dev_lock_count <= 0))\r\ngoto end;\r\nif (--efw->dev_lock_count == 0)\r\nsnd_efw_stream_lock_changed(efw);\r\nend:\r\nspin_unlock_irq(&efw->lock);\r\n}
