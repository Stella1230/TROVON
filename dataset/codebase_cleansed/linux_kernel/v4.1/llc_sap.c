static int llc_mac_header_len(unsigned short devtype)\r\n{\r\nswitch (devtype) {\r\ncase ARPHRD_ETHER:\r\ncase ARPHRD_LOOPBACK:\r\nreturn sizeof(struct ethhdr);\r\n}\r\nreturn 0;\r\n}\r\nstruct sk_buff *llc_alloc_frame(struct sock *sk, struct net_device *dev,\r\nu8 type, u32 data_size)\r\n{\r\nint hlen = type == LLC_PDU_TYPE_U ? 3 : 4;\r\nstruct sk_buff *skb;\r\nhlen += llc_mac_header_len(dev->type);\r\nskb = alloc_skb(hlen + data_size, GFP_ATOMIC);\r\nif (skb) {\r\nskb_reset_mac_header(skb);\r\nskb_reserve(skb, hlen);\r\nskb_reset_network_header(skb);\r\nskb_reset_transport_header(skb);\r\nskb->protocol = htons(ETH_P_802_2);\r\nskb->dev = dev;\r\nif (sk != NULL)\r\nskb_set_owner_w(skb, sk);\r\n}\r\nreturn skb;\r\n}\r\nvoid llc_save_primitive(struct sock *sk, struct sk_buff *skb, u8 prim)\r\n{\r\nstruct sockaddr_llc *addr;\r\naddr = llc_ui_skb_cb(skb);\r\nmemset(addr, 0, sizeof(*addr));\r\naddr->sllc_family = sk->sk_family;\r\naddr->sllc_arphrd = skb->dev->type;\r\naddr->sllc_test = prim == LLC_TEST_PRIM;\r\naddr->sllc_xid = prim == LLC_XID_PRIM;\r\naddr->sllc_ua = prim == LLC_DATAUNIT_PRIM;\r\nllc_pdu_decode_sa(skb, addr->sllc_mac);\r\nllc_pdu_decode_ssap(skb, &addr->sllc_sap);\r\n}\r\nvoid llc_sap_rtn_pdu(struct llc_sap *sap, struct sk_buff *skb)\r\n{\r\nstruct llc_sap_state_ev *ev = llc_sap_ev(skb);\r\nstruct llc_pdu_un *pdu = llc_pdu_un_hdr(skb);\r\nswitch (LLC_U_PDU_RSP(pdu)) {\r\ncase LLC_1_PDU_CMD_TEST:\r\nev->prim = LLC_TEST_PRIM; break;\r\ncase LLC_1_PDU_CMD_XID:\r\nev->prim = LLC_XID_PRIM; break;\r\ncase LLC_1_PDU_CMD_UI:\r\nev->prim = LLC_DATAUNIT_PRIM; break;\r\n}\r\nev->ind_cfm_flag = LLC_IND;\r\n}\r\nstatic struct llc_sap_state_trans *llc_find_sap_trans(struct llc_sap *sap,\r\nstruct sk_buff *skb)\r\n{\r\nint i = 0;\r\nstruct llc_sap_state_trans *rc = NULL;\r\nstruct llc_sap_state_trans **next_trans;\r\nstruct llc_sap_state *curr_state = &llc_sap_state_table[sap->state - 1];\r\nfor (next_trans = curr_state->transitions; next_trans[i]->ev; i++)\r\nif (!next_trans[i]->ev(sap, skb)) {\r\nrc = next_trans[i];\r\nbreak;\r\n}\r\nreturn rc;\r\n}\r\nstatic int llc_exec_sap_trans_actions(struct llc_sap *sap,\r\nstruct llc_sap_state_trans *trans,\r\nstruct sk_buff *skb)\r\n{\r\nint rc = 0;\r\nconst llc_sap_action_t *next_action = trans->ev_actions;\r\nfor (; next_action && *next_action; next_action++)\r\nif ((*next_action)(sap, skb))\r\nrc = 1;\r\nreturn rc;\r\n}\r\nstatic int llc_sap_next_state(struct llc_sap *sap, struct sk_buff *skb)\r\n{\r\nint rc = 1;\r\nstruct llc_sap_state_trans *trans;\r\nif (sap->state > LLC_NR_SAP_STATES)\r\ngoto out;\r\ntrans = llc_find_sap_trans(sap, skb);\r\nif (!trans)\r\ngoto out;\r\nrc = llc_exec_sap_trans_actions(sap, trans, skb);\r\nif (rc)\r\ngoto out;\r\nsap->state = trans->next_state;\r\nout:\r\nreturn rc;\r\n}\r\nstatic void llc_sap_state_process(struct llc_sap *sap, struct sk_buff *skb)\r\n{\r\nstruct llc_sap_state_ev *ev = llc_sap_ev(skb);\r\nskb_get(skb);\r\nev->ind_cfm_flag = 0;\r\nllc_sap_next_state(sap, skb);\r\nif (ev->ind_cfm_flag == LLC_IND) {\r\nif (skb->sk->sk_state == TCP_LISTEN)\r\nkfree_skb(skb);\r\nelse {\r\nllc_save_primitive(skb->sk, skb, ev->prim);\r\nif (sock_queue_rcv_skb(skb->sk, skb))\r\nkfree_skb(skb);\r\n}\r\n}\r\nkfree_skb(skb);\r\n}\r\nvoid llc_build_and_send_test_pkt(struct llc_sap *sap,\r\nstruct sk_buff *skb, u8 *dmac, u8 dsap)\r\n{\r\nstruct llc_sap_state_ev *ev = llc_sap_ev(skb);\r\nev->saddr.lsap = sap->laddr.lsap;\r\nev->daddr.lsap = dsap;\r\nmemcpy(ev->saddr.mac, skb->dev->dev_addr, IFHWADDRLEN);\r\nmemcpy(ev->daddr.mac, dmac, IFHWADDRLEN);\r\nev->type = LLC_SAP_EV_TYPE_PRIM;\r\nev->prim = LLC_TEST_PRIM;\r\nev->prim_type = LLC_PRIM_TYPE_REQ;\r\nllc_sap_state_process(sap, skb);\r\n}\r\nvoid llc_build_and_send_xid_pkt(struct llc_sap *sap, struct sk_buff *skb,\r\nu8 *dmac, u8 dsap)\r\n{\r\nstruct llc_sap_state_ev *ev = llc_sap_ev(skb);\r\nev->saddr.lsap = sap->laddr.lsap;\r\nev->daddr.lsap = dsap;\r\nmemcpy(ev->saddr.mac, skb->dev->dev_addr, IFHWADDRLEN);\r\nmemcpy(ev->daddr.mac, dmac, IFHWADDRLEN);\r\nev->type = LLC_SAP_EV_TYPE_PRIM;\r\nev->prim = LLC_XID_PRIM;\r\nev->prim_type = LLC_PRIM_TYPE_REQ;\r\nllc_sap_state_process(sap, skb);\r\n}\r\nstatic void llc_sap_rcv(struct llc_sap *sap, struct sk_buff *skb,\r\nstruct sock *sk)\r\n{\r\nstruct llc_sap_state_ev *ev = llc_sap_ev(skb);\r\nev->type = LLC_SAP_EV_TYPE_PDU;\r\nev->reason = 0;\r\nskb->sk = sk;\r\nllc_sap_state_process(sap, skb);\r\n}\r\nstatic inline bool llc_dgram_match(const struct llc_sap *sap,\r\nconst struct llc_addr *laddr,\r\nconst struct sock *sk)\r\n{\r\nstruct llc_sock *llc = llc_sk(sk);\r\nreturn sk->sk_type == SOCK_DGRAM &&\r\nllc->laddr.lsap == laddr->lsap &&\r\nether_addr_equal(llc->laddr.mac, laddr->mac);\r\n}\r\nstatic struct sock *llc_lookup_dgram(struct llc_sap *sap,\r\nconst struct llc_addr *laddr)\r\n{\r\nstruct sock *rc;\r\nstruct hlist_nulls_node *node;\r\nint slot = llc_sk_laddr_hashfn(sap, laddr);\r\nstruct hlist_nulls_head *laddr_hb = &sap->sk_laddr_hash[slot];\r\nrcu_read_lock_bh();\r\nagain:\r\nsk_nulls_for_each_rcu(rc, node, laddr_hb) {\r\nif (llc_dgram_match(sap, laddr, rc)) {\r\nif (unlikely(!atomic_inc_not_zero(&rc->sk_refcnt)))\r\ngoto again;\r\nif (unlikely(llc_sk(rc)->sap != sap ||\r\n!llc_dgram_match(sap, laddr, rc))) {\r\nsock_put(rc);\r\ncontinue;\r\n}\r\ngoto found;\r\n}\r\n}\r\nrc = NULL;\r\nif (unlikely(get_nulls_value(node) != slot))\r\ngoto again;\r\nfound:\r\nrcu_read_unlock_bh();\r\nreturn rc;\r\n}\r\nstatic inline bool llc_mcast_match(const struct llc_sap *sap,\r\nconst struct llc_addr *laddr,\r\nconst struct sk_buff *skb,\r\nconst struct sock *sk)\r\n{\r\nstruct llc_sock *llc = llc_sk(sk);\r\nreturn sk->sk_type == SOCK_DGRAM &&\r\nllc->laddr.lsap == laddr->lsap &&\r\nllc->dev == skb->dev;\r\n}\r\nstatic void llc_do_mcast(struct llc_sap *sap, struct sk_buff *skb,\r\nstruct sock **stack, int count)\r\n{\r\nstruct sk_buff *skb1;\r\nint i;\r\nfor (i = 0; i < count; i++) {\r\nskb1 = skb_clone(skb, GFP_ATOMIC);\r\nif (!skb1) {\r\nsock_put(stack[i]);\r\ncontinue;\r\n}\r\nllc_sap_rcv(sap, skb1, stack[i]);\r\nsock_put(stack[i]);\r\n}\r\n}\r\nstatic void llc_sap_mcast(struct llc_sap *sap,\r\nconst struct llc_addr *laddr,\r\nstruct sk_buff *skb)\r\n{\r\nint i = 0, count = 256 / sizeof(struct sock *);\r\nstruct sock *sk, *stack[count];\r\nstruct llc_sock *llc;\r\nstruct hlist_head *dev_hb = llc_sk_dev_hash(sap, skb->dev->ifindex);\r\nspin_lock_bh(&sap->sk_lock);\r\nhlist_for_each_entry(llc, dev_hb, dev_hash_node) {\r\nsk = &llc->sk;\r\nif (!llc_mcast_match(sap, laddr, skb, sk))\r\ncontinue;\r\nsock_hold(sk);\r\nif (i < count)\r\nstack[i++] = sk;\r\nelse {\r\nllc_do_mcast(sap, skb, stack, i);\r\ni = 0;\r\n}\r\n}\r\nspin_unlock_bh(&sap->sk_lock);\r\nllc_do_mcast(sap, skb, stack, i);\r\n}\r\nvoid llc_sap_handler(struct llc_sap *sap, struct sk_buff *skb)\r\n{\r\nstruct llc_addr laddr;\r\nllc_pdu_decode_da(skb, laddr.mac);\r\nllc_pdu_decode_dsap(skb, &laddr.lsap);\r\nif (is_multicast_ether_addr(laddr.mac)) {\r\nllc_sap_mcast(sap, &laddr, skb);\r\nkfree_skb(skb);\r\n} else {\r\nstruct sock *sk = llc_lookup_dgram(sap, &laddr);\r\nif (sk) {\r\nllc_sap_rcv(sap, skb, sk);\r\nsock_put(sk);\r\n} else\r\nkfree_skb(skb);\r\n}\r\n}
