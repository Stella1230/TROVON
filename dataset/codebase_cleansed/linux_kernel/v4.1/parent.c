int\r\nnvkm_parent_sclass(struct nvkm_object *parent, u16 handle,\r\nstruct nvkm_object **pengine,\r\nstruct nvkm_oclass **poclass)\r\n{\r\nstruct nvkm_sclass *sclass;\r\nstruct nvkm_engine *engine;\r\nstruct nvkm_oclass *oclass;\r\nu64 mask;\r\nsclass = nv_parent(parent)->sclass;\r\nwhile (sclass) {\r\nif ((sclass->oclass->handle & 0xffff) == handle) {\r\n*pengine = &parent->engine->subdev.object;\r\n*poclass = sclass->oclass;\r\nreturn 0;\r\n}\r\nsclass = sclass->sclass;\r\n}\r\nmask = nv_parent(parent)->engine;\r\nwhile (mask) {\r\nint i = __ffs64(mask);\r\nif (nv_iclass(parent, NV_CLIENT_CLASS))\r\nengine = nv_engine(nv_client(parent)->device);\r\nelse\r\nengine = nvkm_engine(parent, i);\r\nif (engine) {\r\noclass = engine->sclass;\r\nwhile (oclass->ofuncs) {\r\nif ((oclass->handle & 0xffff) == handle) {\r\n*pengine = nv_object(engine);\r\n*poclass = oclass;\r\nreturn 0;\r\n}\r\noclass++;\r\n}\r\n}\r\nmask &= ~(1ULL << i);\r\n}\r\nreturn -EINVAL;\r\n}\r\nint\r\nnvkm_parent_lclass(struct nvkm_object *parent, u32 *lclass, int size)\r\n{\r\nstruct nvkm_sclass *sclass;\r\nstruct nvkm_engine *engine;\r\nstruct nvkm_oclass *oclass;\r\nint nr = -1, i;\r\nu64 mask;\r\nsclass = nv_parent(parent)->sclass;\r\nwhile (sclass) {\r\nif (++nr < size)\r\nlclass[nr] = sclass->oclass->handle & 0xffff;\r\nsclass = sclass->sclass;\r\n}\r\nmask = nv_parent(parent)->engine;\r\nwhile (i = __ffs64(mask), mask) {\r\nengine = nvkm_engine(parent, i);\r\nif (engine && (oclass = engine->sclass)) {\r\nwhile (oclass->ofuncs) {\r\nif (++nr < size)\r\nlclass[nr] = oclass->handle & 0xffff;\r\noclass++;\r\n}\r\n}\r\nmask &= ~(1ULL << i);\r\n}\r\nreturn nr + 1;\r\n}\r\nint\r\nnvkm_parent_create_(struct nvkm_object *parent, struct nvkm_object *engine,\r\nstruct nvkm_oclass *oclass, u32 pclass,\r\nstruct nvkm_oclass *sclass, u64 engcls,\r\nint size, void **pobject)\r\n{\r\nstruct nvkm_parent *object;\r\nstruct nvkm_sclass *nclass;\r\nint ret;\r\nret = nvkm_object_create_(parent, engine, oclass, pclass |\r\nNV_PARENT_CLASS, size, pobject);\r\nobject = *pobject;\r\nif (ret)\r\nreturn ret;\r\nwhile (sclass && sclass->ofuncs) {\r\nnclass = kzalloc(sizeof(*nclass), GFP_KERNEL);\r\nif (!nclass)\r\nreturn -ENOMEM;\r\nnclass->sclass = object->sclass;\r\nobject->sclass = nclass;\r\nnclass->engine = engine ? nv_engine(engine) : NULL;\r\nnclass->oclass = sclass;\r\nsclass++;\r\n}\r\nobject->engine = engcls;\r\nreturn 0;\r\n}\r\nvoid\r\nnvkm_parent_destroy(struct nvkm_parent *parent)\r\n{\r\nstruct nvkm_sclass *sclass;\r\nwhile ((sclass = parent->sclass)) {\r\nparent->sclass = sclass->sclass;\r\nkfree(sclass);\r\n}\r\nnvkm_object_destroy(&parent->object);\r\n}\r\nvoid\r\n_nvkm_parent_dtor(struct nvkm_object *object)\r\n{\r\nnvkm_parent_destroy(nv_parent(object));\r\n}
