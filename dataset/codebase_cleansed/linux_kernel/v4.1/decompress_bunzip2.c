static unsigned int INIT get_bits(struct bunzip_data *bd, char bits_wanted)\r\n{\r\nunsigned int bits = 0;\r\nwhile (bd->inbufBitCount < bits_wanted) {\r\nif (bd->inbufPos == bd->inbufCount) {\r\nif (bd->io_error)\r\nreturn 0;\r\nbd->inbufCount = bd->fill(bd->inbuf, BZIP2_IOBUF_SIZE);\r\nif (bd->inbufCount <= 0) {\r\nbd->io_error = RETVAL_UNEXPECTED_INPUT_EOF;\r\nreturn 0;\r\n}\r\nbd->inbufPos = 0;\r\n}\r\nif (bd->inbufBitCount >= 24) {\r\nbits = bd->inbufBits&((1 << bd->inbufBitCount)-1);\r\nbits_wanted -= bd->inbufBitCount;\r\nbits <<= bits_wanted;\r\nbd->inbufBitCount = 0;\r\n}\r\nbd->inbufBits = (bd->inbufBits << 8)|bd->inbuf[bd->inbufPos++];\r\nbd->inbufBitCount += 8;\r\n}\r\nbd->inbufBitCount -= bits_wanted;\r\nbits |= (bd->inbufBits >> bd->inbufBitCount)&((1 << bits_wanted)-1);\r\nreturn bits;\r\n}\r\nstatic int INIT get_next_block(struct bunzip_data *bd)\r\n{\r\nstruct group_data *hufGroup = NULL;\r\nint *base = NULL;\r\nint *limit = NULL;\r\nint dbufCount, nextSym, dbufSize, groupCount, selector,\r\ni, j, k, t, runPos, symCount, symTotal, nSelectors, *byteCount;\r\nunsigned char uc, *symToByte, *mtfSymbol, *selectors;\r\nunsigned int *dbuf, origPtr;\r\ndbuf = bd->dbuf;\r\ndbufSize = bd->dbufSize;\r\nselectors = bd->selectors;\r\nbyteCount = bd->byteCount;\r\nsymToByte = bd->symToByte;\r\nmtfSymbol = bd->mtfSymbol;\r\ni = get_bits(bd, 24);\r\nj = get_bits(bd, 24);\r\nbd->headerCRC = get_bits(bd, 32);\r\nif ((i == 0x177245) && (j == 0x385090))\r\nreturn RETVAL_LAST_BLOCK;\r\nif ((i != 0x314159) || (j != 0x265359))\r\nreturn RETVAL_NOT_BZIP_DATA;\r\nif (get_bits(bd, 1))\r\nreturn RETVAL_OBSOLETE_INPUT;\r\norigPtr = get_bits(bd, 24);\r\nif (origPtr >= dbufSize)\r\nreturn RETVAL_DATA_ERROR;\r\nt = get_bits(bd, 16);\r\nsymTotal = 0;\r\nfor (i = 0; i < 16; i++) {\r\nif (t&(1 << (15-i))) {\r\nk = get_bits(bd, 16);\r\nfor (j = 0; j < 16; j++)\r\nif (k&(1 << (15-j)))\r\nsymToByte[symTotal++] = (16*i)+j;\r\n}\r\n}\r\ngroupCount = get_bits(bd, 3);\r\nif (groupCount < 2 || groupCount > MAX_GROUPS)\r\nreturn RETVAL_DATA_ERROR;\r\nnSelectors = get_bits(bd, 15);\r\nif (!nSelectors)\r\nreturn RETVAL_DATA_ERROR;\r\nfor (i = 0; i < groupCount; i++)\r\nmtfSymbol[i] = i;\r\nfor (i = 0; i < nSelectors; i++) {\r\nfor (j = 0; get_bits(bd, 1); j++)\r\nif (j >= groupCount)\r\nreturn RETVAL_DATA_ERROR;\r\nuc = mtfSymbol[j];\r\nfor (; j; j--)\r\nmtfSymbol[j] = mtfSymbol[j-1];\r\nmtfSymbol[0] = selectors[i] = uc;\r\n}\r\nsymCount = symTotal+2;\r\nfor (j = 0; j < groupCount; j++) {\r\nunsigned char length[MAX_SYMBOLS], temp[MAX_HUFCODE_BITS+1];\r\nint minLen, maxLen, pp;\r\nt = get_bits(bd, 5)-1;\r\nfor (i = 0; i < symCount; i++) {\r\nfor (;;) {\r\nif (((unsigned)t) > (MAX_HUFCODE_BITS-1))\r\nreturn RETVAL_DATA_ERROR;\r\nk = get_bits(bd, 2);\r\nif (k < 2) {\r\nbd->inbufBitCount++;\r\nbreak;\r\n}\r\nt += (((k+1)&2)-1);\r\n}\r\nlength[i] = t+1;\r\n}\r\nminLen = maxLen = length[0];\r\nfor (i = 1; i < symCount; i++) {\r\nif (length[i] > maxLen)\r\nmaxLen = length[i];\r\nelse if (length[i] < minLen)\r\nminLen = length[i];\r\n}\r\nhufGroup = bd->groups+j;\r\nhufGroup->minLen = minLen;\r\nhufGroup->maxLen = maxLen;\r\nbase = hufGroup->base-1;\r\nlimit = hufGroup->limit-1;\r\npp = 0;\r\nfor (i = minLen; i <= maxLen; i++) {\r\ntemp[i] = limit[i] = 0;\r\nfor (t = 0; t < symCount; t++)\r\nif (length[t] == i)\r\nhufGroup->permute[pp++] = t;\r\n}\r\nfor (i = 0; i < symCount; i++)\r\ntemp[length[i]]++;\r\npp = t = 0;\r\nfor (i = minLen; i < maxLen; i++) {\r\npp += temp[i];\r\nlimit[i] = (pp << (maxLen - i)) - 1;\r\npp <<= 1;\r\nbase[i+1] = pp-(t += temp[i]);\r\n}\r\nlimit[maxLen+1] = INT_MAX;\r\nlimit[maxLen] = pp+temp[maxLen]-1;\r\nbase[minLen] = 0;\r\n}\r\nfor (i = 0; i < 256; i++) {\r\nbyteCount[i] = 0;\r\nmtfSymbol[i] = (unsigned char)i;\r\n}\r\nrunPos = dbufCount = symCount = selector = 0;\r\nfor (;;) {\r\nif (!(symCount--)) {\r\nsymCount = GROUP_SIZE-1;\r\nif (selector >= nSelectors)\r\nreturn RETVAL_DATA_ERROR;\r\nhufGroup = bd->groups+selectors[selector++];\r\nbase = hufGroup->base-1;\r\nlimit = hufGroup->limit-1;\r\n}\r\nwhile (bd->inbufBitCount < hufGroup->maxLen) {\r\nif (bd->inbufPos == bd->inbufCount) {\r\nj = get_bits(bd, hufGroup->maxLen);\r\ngoto got_huff_bits;\r\n}\r\nbd->inbufBits =\r\n(bd->inbufBits << 8)|bd->inbuf[bd->inbufPos++];\r\nbd->inbufBitCount += 8;\r\n};\r\nbd->inbufBitCount -= hufGroup->maxLen;\r\nj = (bd->inbufBits >> bd->inbufBitCount)&\r\n((1 << hufGroup->maxLen)-1);\r\ngot_huff_bits:\r\ni = hufGroup->minLen;\r\nwhile (j > limit[i])\r\n++i;\r\nbd->inbufBitCount += (hufGroup->maxLen - i);\r\nif ((i > hufGroup->maxLen)\r\n|| (((unsigned)(j = (j>>(hufGroup->maxLen-i))-base[i]))\r\n>= MAX_SYMBOLS))\r\nreturn RETVAL_DATA_ERROR;\r\nnextSym = hufGroup->permute[j];\r\nif (((unsigned)nextSym) <= SYMBOL_RUNB) {\r\nif (!runPos) {\r\nrunPos = 1;\r\nt = 0;\r\n}\r\nt += (runPos << nextSym);\r\nrunPos <<= 1;\r\ncontinue;\r\n}\r\nif (runPos) {\r\nrunPos = 0;\r\nif (dbufCount+t >= dbufSize)\r\nreturn RETVAL_DATA_ERROR;\r\nuc = symToByte[mtfSymbol[0]];\r\nbyteCount[uc] += t;\r\nwhile (t--)\r\ndbuf[dbufCount++] = uc;\r\n}\r\nif (nextSym > symTotal)\r\nbreak;\r\nif (dbufCount >= dbufSize)\r\nreturn RETVAL_DATA_ERROR;\r\ni = nextSym - 1;\r\nuc = mtfSymbol[i];\r\ndo {\r\nmtfSymbol[i] = mtfSymbol[i-1];\r\n} while (--i);\r\nmtfSymbol[0] = uc;\r\nuc = symToByte[uc];\r\nbyteCount[uc]++;\r\ndbuf[dbufCount++] = (unsigned int)uc;\r\n}\r\nj = 0;\r\nfor (i = 0; i < 256; i++) {\r\nk = j+byteCount[i];\r\nbyteCount[i] = j;\r\nj = k;\r\n}\r\nfor (i = 0; i < dbufCount; i++) {\r\nuc = (unsigned char)(dbuf[i] & 0xff);\r\ndbuf[byteCount[uc]] |= (i << 8);\r\nbyteCount[uc]++;\r\n}\r\nif (dbufCount) {\r\nif (origPtr >= dbufCount)\r\nreturn RETVAL_DATA_ERROR;\r\nbd->writePos = dbuf[origPtr];\r\nbd->writeCurrent = (unsigned char)(bd->writePos&0xff);\r\nbd->writePos >>= 8;\r\nbd->writeRunCountdown = 5;\r\n}\r\nbd->writeCount = dbufCount;\r\nreturn RETVAL_OK;\r\n}\r\nstatic int INIT read_bunzip(struct bunzip_data *bd, char *outbuf, int len)\r\n{\r\nconst unsigned int *dbuf;\r\nint pos, xcurrent, previous, gotcount;\r\nif (bd->writeCount < 0)\r\nreturn bd->writeCount;\r\ngotcount = 0;\r\ndbuf = bd->dbuf;\r\npos = bd->writePos;\r\nxcurrent = bd->writeCurrent;\r\nif (bd->writeCopies) {\r\n--bd->writeCopies;\r\nfor (;;) {\r\nif (gotcount >= len) {\r\nbd->writePos = pos;\r\nbd->writeCurrent = xcurrent;\r\nbd->writeCopies++;\r\nreturn len;\r\n}\r\noutbuf[gotcount++] = xcurrent;\r\nbd->writeCRC = (((bd->writeCRC) << 8)\r\n^bd->crc32Table[((bd->writeCRC) >> 24)\r\n^xcurrent]);\r\nif (bd->writeCopies) {\r\n--bd->writeCopies;\r\ncontinue;\r\n}\r\ndecode_next_byte:\r\nif (!bd->writeCount--)\r\nbreak;\r\nprevious = xcurrent;\r\npos = dbuf[pos];\r\nxcurrent = pos&0xff;\r\npos >>= 8;\r\nif (--bd->writeRunCountdown) {\r\nif (xcurrent != previous)\r\nbd->writeRunCountdown = 4;\r\n} else {\r\nbd->writeCopies = xcurrent;\r\nxcurrent = previous;\r\nbd->writeRunCountdown = 5;\r\nif (!bd->writeCopies)\r\ngoto decode_next_byte;\r\n--bd->writeCopies;\r\n}\r\n}\r\nbd->writeCRC = ~bd->writeCRC;\r\nbd->totalCRC = ((bd->totalCRC << 1) |\r\n(bd->totalCRC >> 31)) ^ bd->writeCRC;\r\nif (bd->writeCRC != bd->headerCRC) {\r\nbd->totalCRC = bd->headerCRC+1;\r\nreturn RETVAL_LAST_BLOCK;\r\n}\r\n}\r\nprevious = get_next_block(bd);\r\nif (previous) {\r\nbd->writeCount = previous;\r\nreturn (previous != RETVAL_LAST_BLOCK) ? previous : gotcount;\r\n}\r\nbd->writeCRC = 0xffffffffUL;\r\npos = bd->writePos;\r\nxcurrent = bd->writeCurrent;\r\ngoto decode_next_byte;\r\n}\r\nstatic long INIT nofill(void *buf, unsigned long len)\r\n{\r\nreturn -1;\r\n}\r\nstatic int INIT start_bunzip(struct bunzip_data **bdp, void *inbuf, long len,\r\nlong (*fill)(void*, unsigned long))\r\n{\r\nstruct bunzip_data *bd;\r\nunsigned int i, j, c;\r\nconst unsigned int BZh0 =\r\n(((unsigned int)'B') << 24)+(((unsigned int)'Z') << 16)\r\n+(((unsigned int)'h') << 8)+(unsigned int)'0';\r\ni = sizeof(struct bunzip_data);\r\nbd = *bdp = malloc(i);\r\nif (!bd)\r\nreturn RETVAL_OUT_OF_MEMORY;\r\nmemset(bd, 0, sizeof(struct bunzip_data));\r\nbd->inbuf = inbuf;\r\nbd->inbufCount = len;\r\nif (fill != NULL)\r\nbd->fill = fill;\r\nelse\r\nbd->fill = nofill;\r\nfor (i = 0; i < 256; i++) {\r\nc = i << 24;\r\nfor (j = 8; j; j--)\r\nc = c&0x80000000 ? (c << 1)^0x04c11db7 : (c << 1);\r\nbd->crc32Table[i] = c;\r\n}\r\ni = get_bits(bd, 32);\r\nif (((unsigned int)(i-BZh0-1)) >= 9)\r\nreturn RETVAL_NOT_BZIP_DATA;\r\nbd->dbufSize = 100000*(i-BZh0);\r\nbd->dbuf = large_malloc(bd->dbufSize * sizeof(int));\r\nif (!bd->dbuf)\r\nreturn RETVAL_OUT_OF_MEMORY;\r\nreturn RETVAL_OK;\r\n}\r\nSTATIC int INIT bunzip2(unsigned char *buf, long len,\r\nlong (*fill)(void*, unsigned long),\r\nlong (*flush)(void*, unsigned long),\r\nunsigned char *outbuf,\r\nlong *pos,\r\nvoid(*error)(char *x))\r\n{\r\nstruct bunzip_data *bd;\r\nint i = -1;\r\nunsigned char *inbuf;\r\nif (flush)\r\noutbuf = malloc(BZIP2_IOBUF_SIZE);\r\nif (!outbuf) {\r\nerror("Could not allocate output buffer");\r\nreturn RETVAL_OUT_OF_MEMORY;\r\n}\r\nif (buf)\r\ninbuf = buf;\r\nelse\r\ninbuf = malloc(BZIP2_IOBUF_SIZE);\r\nif (!inbuf) {\r\nerror("Could not allocate input buffer");\r\ni = RETVAL_OUT_OF_MEMORY;\r\ngoto exit_0;\r\n}\r\ni = start_bunzip(&bd, inbuf, len, fill);\r\nif (!i) {\r\nfor (;;) {\r\ni = read_bunzip(bd, outbuf, BZIP2_IOBUF_SIZE);\r\nif (i <= 0)\r\nbreak;\r\nif (!flush)\r\noutbuf += i;\r\nelse\r\nif (i != flush(outbuf, i)) {\r\ni = RETVAL_UNEXPECTED_OUTPUT_EOF;\r\nbreak;\r\n}\r\n}\r\n}\r\nif (i == RETVAL_LAST_BLOCK) {\r\nif (bd->headerCRC != bd->totalCRC)\r\nerror("Data integrity error when decompressing.");\r\nelse\r\ni = RETVAL_OK;\r\n} else if (i == RETVAL_UNEXPECTED_OUTPUT_EOF) {\r\nerror("Compressed file ends unexpectedly");\r\n}\r\nif (!bd)\r\ngoto exit_1;\r\nif (bd->dbuf)\r\nlarge_free(bd->dbuf);\r\nif (pos)\r\n*pos = bd->inbufPos;\r\nfree(bd);\r\nexit_1:\r\nif (!buf)\r\nfree(inbuf);\r\nexit_0:\r\nif (flush)\r\nfree(outbuf);\r\nreturn i;\r\n}\r\nSTATIC int INIT decompress(unsigned char *buf, long len,\r\nlong (*fill)(void*, unsigned long),\r\nlong (*flush)(void*, unsigned long),\r\nunsigned char *outbuf,\r\nlong *pos,\r\nvoid(*error)(char *x))\r\n{\r\nreturn bunzip2(buf, len - 4, fill, flush, outbuf, pos, error);\r\n}
