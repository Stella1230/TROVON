static inline bool is_brightness_ctrl_by_pwm(enum lp8788_bl_ctrl_mode mode)\r\n{\r\nreturn mode == LP8788_BL_COMB_PWM_BASED;\r\n}\r\nstatic inline bool is_brightness_ctrl_by_register(enum lp8788_bl_ctrl_mode mode)\r\n{\r\nreturn mode == LP8788_BL_REGISTER_ONLY ||\r\nmode == LP8788_BL_COMB_REGISTER_BASED;\r\n}\r\nstatic int lp8788_backlight_configure(struct lp8788_bl *bl)\r\n{\r\nstruct lp8788_backlight_platform_data *pdata = bl->pdata;\r\nstruct lp8788_bl_config *cfg = &default_bl_config;\r\nint ret;\r\nu8 val;\r\nif (pdata) {\r\ncfg->bl_mode = pdata->bl_mode;\r\ncfg->dim_mode = pdata->dim_mode;\r\ncfg->full_scale = pdata->full_scale;\r\ncfg->rise_time = pdata->rise_time;\r\ncfg->fall_time = pdata->fall_time;\r\ncfg->pwm_pol = pdata->pwm_pol;\r\n}\r\nval = (cfg->rise_time << LP8788_BL_RAMP_RISE_SHIFT) | cfg->fall_time;\r\nret = lp8788_write_byte(bl->lp, LP8788_BL_RAMP, val);\r\nif (ret)\r\nreturn ret;\r\nval = (cfg->full_scale << LP8788_BL_FULLSCALE_SHIFT) |\r\n(cfg->dim_mode << LP8788_BL_DIM_MODE_SHIFT);\r\nswitch (cfg->bl_mode) {\r\ncase LP8788_BL_REGISTER_ONLY:\r\nval |= LP8788_BL_EN;\r\nbreak;\r\ncase LP8788_BL_COMB_PWM_BASED:\r\ncase LP8788_BL_COMB_REGISTER_BASED:\r\nval |= LP8788_BL_EN | LP8788_BL_PWM_INPUT_EN |\r\n(cfg->pwm_pol << LP8788_BL_PWM_POLARITY_SHIFT);\r\nbreak;\r\ndefault:\r\ndev_err(bl->lp->dev, "invalid mode: %d\n", cfg->bl_mode);\r\nreturn -EINVAL;\r\n}\r\nbl->mode = cfg->bl_mode;\r\nreturn lp8788_write_byte(bl->lp, LP8788_BL_CONFIG, val);\r\n}\r\nstatic void lp8788_pwm_ctrl(struct lp8788_bl *bl, int br, int max_br)\r\n{\r\nunsigned int period;\r\nunsigned int duty;\r\nstruct device *dev;\r\nstruct pwm_device *pwm;\r\nif (!bl->pdata)\r\nreturn;\r\nperiod = bl->pdata->period_ns;\r\nduty = br * period / max_br;\r\ndev = bl->lp->dev;\r\nif (!bl->pwm) {\r\npwm = devm_pwm_get(dev, LP8788_DEV_BACKLIGHT);\r\nif (IS_ERR(pwm)) {\r\ndev_err(dev, "can not get PWM device\n");\r\nreturn;\r\n}\r\nbl->pwm = pwm;\r\n}\r\npwm_config(bl->pwm, duty, period);\r\nif (duty)\r\npwm_enable(bl->pwm);\r\nelse\r\npwm_disable(bl->pwm);\r\n}\r\nstatic int lp8788_bl_update_status(struct backlight_device *bl_dev)\r\n{\r\nstruct lp8788_bl *bl = bl_get_data(bl_dev);\r\nenum lp8788_bl_ctrl_mode mode = bl->mode;\r\nif (bl_dev->props.state & BL_CORE_SUSPENDED)\r\nbl_dev->props.brightness = 0;\r\nif (is_brightness_ctrl_by_pwm(mode)) {\r\nint brt = bl_dev->props.brightness;\r\nint max = bl_dev->props.max_brightness;\r\nlp8788_pwm_ctrl(bl, brt, max);\r\n} else if (is_brightness_ctrl_by_register(mode)) {\r\nu8 brt = bl_dev->props.brightness;\r\nlp8788_write_byte(bl->lp, LP8788_BL_BRIGHTNESS, brt);\r\n}\r\nreturn 0;\r\n}\r\nstatic int lp8788_backlight_register(struct lp8788_bl *bl)\r\n{\r\nstruct backlight_device *bl_dev;\r\nstruct backlight_properties props;\r\nstruct lp8788_backlight_platform_data *pdata = bl->pdata;\r\nint init_brt;\r\nchar *name;\r\nprops.type = BACKLIGHT_PLATFORM;\r\nprops.max_brightness = MAX_BRIGHTNESS;\r\nif (pdata)\r\ninit_brt = min_t(int, pdata->initial_brightness,\r\nprops.max_brightness);\r\nelse\r\ninit_brt = 0;\r\nprops.brightness = init_brt;\r\nif (!pdata || !pdata->name)\r\nname = DEFAULT_BL_NAME;\r\nelse\r\nname = pdata->name;\r\nbl_dev = backlight_device_register(name, bl->lp->dev, bl,\r\n&lp8788_bl_ops, &props);\r\nif (IS_ERR(bl_dev))\r\nreturn PTR_ERR(bl_dev);\r\nbl->bl_dev = bl_dev;\r\nreturn 0;\r\n}\r\nstatic void lp8788_backlight_unregister(struct lp8788_bl *bl)\r\n{\r\nstruct backlight_device *bl_dev = bl->bl_dev;\r\nif (bl_dev)\r\nbacklight_device_unregister(bl_dev);\r\n}\r\nstatic ssize_t lp8788_get_bl_ctl_mode(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct lp8788_bl *bl = dev_get_drvdata(dev);\r\nenum lp8788_bl_ctrl_mode mode = bl->mode;\r\nchar *strmode;\r\nif (is_brightness_ctrl_by_pwm(mode))\r\nstrmode = "PWM based";\r\nelse if (is_brightness_ctrl_by_register(mode))\r\nstrmode = "Register based";\r\nelse\r\nstrmode = "Invalid mode";\r\nreturn scnprintf(buf, PAGE_SIZE, "%s\n", strmode);\r\n}\r\nstatic int lp8788_backlight_probe(struct platform_device *pdev)\r\n{\r\nstruct lp8788 *lp = dev_get_drvdata(pdev->dev.parent);\r\nstruct lp8788_bl *bl;\r\nint ret;\r\nbl = devm_kzalloc(lp->dev, sizeof(struct lp8788_bl), GFP_KERNEL);\r\nif (!bl)\r\nreturn -ENOMEM;\r\nbl->lp = lp;\r\nif (lp->pdata)\r\nbl->pdata = lp->pdata->bl_pdata;\r\nplatform_set_drvdata(pdev, bl);\r\nret = lp8788_backlight_configure(bl);\r\nif (ret) {\r\ndev_err(lp->dev, "backlight config err: %d\n", ret);\r\ngoto err_dev;\r\n}\r\nret = lp8788_backlight_register(bl);\r\nif (ret) {\r\ndev_err(lp->dev, "register backlight err: %d\n", ret);\r\ngoto err_dev;\r\n}\r\nret = sysfs_create_group(&pdev->dev.kobj, &lp8788_attr_group);\r\nif (ret) {\r\ndev_err(lp->dev, "register sysfs err: %d\n", ret);\r\ngoto err_sysfs;\r\n}\r\nbacklight_update_status(bl->bl_dev);\r\nreturn 0;\r\nerr_sysfs:\r\nlp8788_backlight_unregister(bl);\r\nerr_dev:\r\nreturn ret;\r\n}\r\nstatic int lp8788_backlight_remove(struct platform_device *pdev)\r\n{\r\nstruct lp8788_bl *bl = platform_get_drvdata(pdev);\r\nstruct backlight_device *bl_dev = bl->bl_dev;\r\nbl_dev->props.brightness = 0;\r\nbacklight_update_status(bl_dev);\r\nsysfs_remove_group(&pdev->dev.kobj, &lp8788_attr_group);\r\nlp8788_backlight_unregister(bl);\r\nreturn 0;\r\n}
