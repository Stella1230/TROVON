static int ir_xmp_decode(struct rc_dev *dev, struct ir_raw_event ev)\r\n{\r\nstruct xmp_dec *data = &dev->raw->xmp;\r\nif (!(dev->enabled_protocols & RC_BIT_XMP))\r\nreturn 0;\r\nif (!is_timing_event(ev)) {\r\nif (ev.reset)\r\ndata->state = STATE_INACTIVE;\r\nreturn 0;\r\n}\r\nIR_dprintk(2, "XMP decode started at state %d %d (%uus %s)\n",\r\ndata->state, data->count, TO_US(ev.duration), TO_STR(ev.pulse));\r\nswitch (data->state) {\r\ncase STATE_INACTIVE:\r\nif (!ev.pulse)\r\nbreak;\r\nif (eq_margin(ev.duration, XMP_LEADER, XMP_UNIT / 2)) {\r\ndata->count = 0;\r\ndata->state = STATE_NIBBLE_SPACE;\r\n}\r\nreturn 0;\r\ncase STATE_LEADER_PULSE:\r\nif (!ev.pulse)\r\nbreak;\r\nif (eq_margin(ev.duration, XMP_LEADER, XMP_UNIT / 2))\r\ndata->state = STATE_NIBBLE_SPACE;\r\nreturn 0;\r\ncase STATE_NIBBLE_SPACE:\r\nif (ev.pulse)\r\nbreak;\r\nif (geq_margin(ev.duration, XMP_TRAILER_SPACE, XMP_NIBBLE_PREFIX)) {\r\nint divider, i;\r\nu8 addr, subaddr, subaddr2, toggle, oem, obc1, obc2, sum1, sum2;\r\nu32 *n;\r\nu32 scancode;\r\nif (data->count != 16) {\r\nIR_dprintk(2, "received TRAILER period at index %d: %u\n",\r\ndata->count, ev.duration);\r\ndata->state = STATE_INACTIVE;\r\nreturn -EINVAL;\r\n}\r\nn = data->durations;\r\ndivider = (n[3] - XMP_NIBBLE_PREFIX) / 15 - 2000;\r\nif (divider < 50) {\r\nIR_dprintk(2, "divider to small %d.\n", divider);\r\ndata->state = STATE_INACTIVE;\r\nreturn -EINVAL;\r\n}\r\nfor (i = 0; i < 16; i++)\r\nn[i] = (n[i] - XMP_NIBBLE_PREFIX) / divider;\r\nsum1 = (15 + n[0] + n[1] + n[2] + n[3] +\r\nn[4] + n[5] + n[6] + n[7]) % 16;\r\nsum2 = (15 + n[8] + n[9] + n[10] + n[11] +\r\nn[12] + n[13] + n[14] + n[15]) % 16;\r\nif (sum1 != 15 || sum2 != 15) {\r\nIR_dprintk(2, "checksum errors sum1=0x%X sum2=0x%X\n",\r\nsum1, sum2);\r\ndata->state = STATE_INACTIVE;\r\nreturn -EINVAL;\r\n}\r\nsubaddr = n[0] << 4 | n[2];\r\nsubaddr2 = n[8] << 4 | n[11];\r\noem = n[4] << 4 | n[5];\r\naddr = n[6] << 4 | n[7];\r\ntoggle = n[10];\r\nobc1 = n[12] << 4 | n[13];\r\nobc2 = n[14] << 4 | n[15];\r\nif (subaddr != subaddr2) {\r\nIR_dprintk(2, "subaddress nibbles mismatch 0x%02X != 0x%02X\n",\r\nsubaddr, subaddr2);\r\ndata->state = STATE_INACTIVE;\r\nreturn -EINVAL;\r\n}\r\nif (oem != 0x44)\r\nIR_dprintk(1, "Warning: OEM nibbles 0x%02X. Expected 0x44\n",\r\noem);\r\nscancode = addr << 24 | subaddr << 16 |\r\nobc1 << 8 | obc2;\r\nIR_dprintk(1, "XMP scancode 0x%06x\n", scancode);\r\nif (toggle == 0) {\r\nrc_keydown(dev, RC_TYPE_XMP, scancode, 0);\r\n} else {\r\nrc_repeat(dev);\r\nIR_dprintk(1, "Repeat last key\n");\r\n}\r\ndata->state = STATE_INACTIVE;\r\nreturn 0;\r\n} else if (geq_margin(ev.duration, XMP_HALFFRAME_SPACE, XMP_NIBBLE_PREFIX)) {\r\nif (data->count == 16) {\r\nIR_dprintk(2, "received half frame pulse at index %d. Probably a final frame key-up event: %u\n",\r\ndata->count, ev.duration);\r\ndata->count = 8;\r\n}\r\nelse if (data->count != 8)\r\nIR_dprintk(2, "received half frame pulse at index %d: %u\n",\r\ndata->count, ev.duration);\r\ndata->state = STATE_LEADER_PULSE;\r\nreturn 0;\r\n} else if (geq_margin(ev.duration, XMP_NIBBLE_PREFIX, XMP_UNIT)) {\r\nif (data->count == 16) {\r\nIR_dprintk(2, "to many pulses (%d) ignoring: %u\n",\r\ndata->count, ev.duration);\r\ndata->state = STATE_INACTIVE;\r\nreturn -EINVAL;\r\n}\r\ndata->durations[data->count] = ev.duration;\r\ndata->count++;\r\ndata->state = STATE_LEADER_PULSE;\r\nreturn 0;\r\n}\r\nbreak;\r\n}\r\nIR_dprintk(1, "XMP decode failed at count %d state %d (%uus %s)\n",\r\ndata->count, data->state, TO_US(ev.duration), TO_STR(ev.pulse));\r\ndata->state = STATE_INACTIVE;\r\nreturn -EINVAL;\r\n}\r\nstatic int __init ir_xmp_decode_init(void)\r\n{\r\nir_raw_handler_register(&xmp_handler);\r\nprintk(KERN_INFO "IR XMP protocol handler initialized\n");\r\nreturn 0;\r\n}\r\nstatic void __exit ir_xmp_decode_exit(void)\r\n{\r\nir_raw_handler_unregister(&xmp_handler);\r\n}
