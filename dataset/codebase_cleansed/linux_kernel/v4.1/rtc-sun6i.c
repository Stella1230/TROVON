static irqreturn_t sun6i_rtc_alarmirq(int irq, void *id)\r\n{\r\nstruct sun6i_rtc_dev *chip = (struct sun6i_rtc_dev *) id;\r\nu32 val;\r\nval = readl(chip->base + SUN6I_ALRM_IRQ_STA);\r\nif (val & SUN6I_ALRM_IRQ_STA_CNT_IRQ_PEND) {\r\nval |= SUN6I_ALRM_IRQ_STA_CNT_IRQ_PEND;\r\nwritel(val, chip->base + SUN6I_ALRM_IRQ_STA);\r\nrtc_update_irq(chip->rtc, 1, RTC_AF | RTC_IRQF);\r\nreturn IRQ_HANDLED;\r\n}\r\nreturn IRQ_NONE;\r\n}\r\nstatic void sun6i_rtc_setaie(int to, struct sun6i_rtc_dev *chip)\r\n{\r\nu32 alrm_val = 0;\r\nu32 alrm_irq_val = 0;\r\nu32 alrm_wake_val = 0;\r\nif (to) {\r\nalrm_val = SUN6I_ALRM_EN_CNT_EN;\r\nalrm_irq_val = SUN6I_ALRM_IRQ_EN_CNT_IRQ_EN;\r\nalrm_wake_val = SUN6I_ALARM_CONFIG_WAKEUP;\r\n} else {\r\nwritel(SUN6I_ALRM_IRQ_STA_CNT_IRQ_PEND,\r\nchip->base + SUN6I_ALRM_IRQ_STA);\r\n}\r\nwritel(alrm_val, chip->base + SUN6I_ALRM_EN);\r\nwritel(alrm_irq_val, chip->base + SUN6I_ALRM_IRQ_EN);\r\nwritel(alrm_wake_val, chip->base + SUN6I_ALARM_CONFIG);\r\n}\r\nstatic int sun6i_rtc_gettime(struct device *dev, struct rtc_time *rtc_tm)\r\n{\r\nstruct sun6i_rtc_dev *chip = dev_get_drvdata(dev);\r\nu32 date, time;\r\ndo {\r\ndate = readl(chip->base + SUN6I_RTC_YMD);\r\ntime = readl(chip->base + SUN6I_RTC_HMS);\r\n} while ((date != readl(chip->base + SUN6I_RTC_YMD)) ||\r\n(time != readl(chip->base + SUN6I_RTC_HMS)));\r\nrtc_tm->tm_sec = SUN6I_TIME_GET_SEC_VALUE(time);\r\nrtc_tm->tm_min = SUN6I_TIME_GET_MIN_VALUE(time);\r\nrtc_tm->tm_hour = SUN6I_TIME_GET_HOUR_VALUE(time);\r\nrtc_tm->tm_mday = SUN6I_DATE_GET_DAY_VALUE(date);\r\nrtc_tm->tm_mon = SUN6I_DATE_GET_MON_VALUE(date);\r\nrtc_tm->tm_year = SUN6I_DATE_GET_YEAR_VALUE(date);\r\nrtc_tm->tm_mon -= 1;\r\nrtc_tm->tm_year += SUN6I_YEAR_OFF;\r\nreturn rtc_valid_tm(rtc_tm);\r\n}\r\nstatic int sun6i_rtc_getalarm(struct device *dev, struct rtc_wkalrm *wkalrm)\r\n{\r\nstruct sun6i_rtc_dev *chip = dev_get_drvdata(dev);\r\nu32 alrm_st;\r\nu32 alrm_en;\r\nalrm_en = readl(chip->base + SUN6I_ALRM_IRQ_EN);\r\nalrm_st = readl(chip->base + SUN6I_ALRM_IRQ_STA);\r\nwkalrm->enabled = !!(alrm_en & SUN6I_ALRM_EN_CNT_EN);\r\nwkalrm->pending = !!(alrm_st & SUN6I_ALRM_EN_CNT_EN);\r\nrtc_time_to_tm(chip->alarm, &wkalrm->time);\r\nreturn 0;\r\n}\r\nstatic int sun6i_rtc_setalarm(struct device *dev, struct rtc_wkalrm *wkalrm)\r\n{\r\nstruct sun6i_rtc_dev *chip = dev_get_drvdata(dev);\r\nstruct rtc_time *alrm_tm = &wkalrm->time;\r\nstruct rtc_time tm_now;\r\nunsigned long time_now = 0;\r\nunsigned long time_set = 0;\r\nunsigned long time_gap = 0;\r\nint ret = 0;\r\nret = sun6i_rtc_gettime(dev, &tm_now);\r\nif (ret < 0) {\r\ndev_err(dev, "Error in getting time\n");\r\nreturn -EINVAL;\r\n}\r\nrtc_tm_to_time(alrm_tm, &time_set);\r\nrtc_tm_to_time(&tm_now, &time_now);\r\nif (time_set <= time_now) {\r\ndev_err(dev, "Date to set in the past\n");\r\nreturn -EINVAL;\r\n}\r\ntime_gap = time_set - time_now;\r\nif (time_gap > U32_MAX) {\r\ndev_err(dev, "Date too far in the future\n");\r\nreturn -EINVAL;\r\n}\r\nsun6i_rtc_setaie(0, chip);\r\nwritel(0, chip->base + SUN6I_ALRM_COUNTER);\r\nusleep_range(100, 300);\r\nwritel(time_gap, chip->base + SUN6I_ALRM_COUNTER);\r\nchip->alarm = time_set;\r\nsun6i_rtc_setaie(wkalrm->enabled, chip);\r\nreturn 0;\r\n}\r\nstatic int sun6i_rtc_wait(struct sun6i_rtc_dev *chip, int offset,\r\nunsigned int mask, unsigned int ms_timeout)\r\n{\r\nconst unsigned long timeout = jiffies + msecs_to_jiffies(ms_timeout);\r\nu32 reg;\r\ndo {\r\nreg = readl(chip->base + offset);\r\nreg &= mask;\r\nif (!reg)\r\nreturn 0;\r\n} while (time_before(jiffies, timeout));\r\nreturn -ETIMEDOUT;\r\n}\r\nstatic int sun6i_rtc_settime(struct device *dev, struct rtc_time *rtc_tm)\r\n{\r\nstruct sun6i_rtc_dev *chip = dev_get_drvdata(dev);\r\nu32 date = 0;\r\nu32 time = 0;\r\nint year;\r\nyear = rtc_tm->tm_year + 1900;\r\nif (year < SUN6I_YEAR_MIN || year > SUN6I_YEAR_MAX) {\r\ndev_err(dev, "rtc only supports year in range %d - %d\n",\r\nSUN6I_YEAR_MIN, SUN6I_YEAR_MAX);\r\nreturn -EINVAL;\r\n}\r\nrtc_tm->tm_year -= SUN6I_YEAR_OFF;\r\nrtc_tm->tm_mon += 1;\r\ndate = SUN6I_DATE_SET_DAY_VALUE(rtc_tm->tm_mday) |\r\nSUN6I_DATE_SET_MON_VALUE(rtc_tm->tm_mon) |\r\nSUN6I_DATE_SET_YEAR_VALUE(rtc_tm->tm_year);\r\nif (is_leap_year(year))\r\ndate |= SUN6I_LEAP_SET_VALUE(1);\r\ntime = SUN6I_TIME_SET_SEC_VALUE(rtc_tm->tm_sec) |\r\nSUN6I_TIME_SET_MIN_VALUE(rtc_tm->tm_min) |\r\nSUN6I_TIME_SET_HOUR_VALUE(rtc_tm->tm_hour);\r\nif (sun6i_rtc_wait(chip, SUN6I_LOSC_CTRL,\r\nSUN6I_LOSC_CTRL_ACC_MASK, 50)) {\r\ndev_err(dev, "rtc is still busy.\n");\r\nreturn -EBUSY;\r\n}\r\nwritel(time, chip->base + SUN6I_RTC_HMS);\r\nif (sun6i_rtc_wait(chip, SUN6I_LOSC_CTRL,\r\nSUN6I_LOSC_CTRL_RTC_HMS_ACC, 50)) {\r\ndev_err(dev, "Failed to set rtc time.\n");\r\nreturn -ETIMEDOUT;\r\n}\r\nwritel(date, chip->base + SUN6I_RTC_YMD);\r\nif (sun6i_rtc_wait(chip, SUN6I_LOSC_CTRL,\r\nSUN6I_LOSC_CTRL_RTC_YMD_ACC, 50)) {\r\ndev_err(dev, "Failed to set rtc time.\n");\r\nreturn -ETIMEDOUT;\r\n}\r\nreturn 0;\r\n}\r\nstatic int sun6i_rtc_alarm_irq_enable(struct device *dev, unsigned int enabled)\r\n{\r\nstruct sun6i_rtc_dev *chip = dev_get_drvdata(dev);\r\nif (!enabled)\r\nsun6i_rtc_setaie(enabled, chip);\r\nreturn 0;\r\n}\r\nstatic int sun6i_rtc_probe(struct platform_device *pdev)\r\n{\r\nstruct sun6i_rtc_dev *chip;\r\nstruct resource *res;\r\nint ret;\r\nchip = devm_kzalloc(&pdev->dev, sizeof(*chip), GFP_KERNEL);\r\nif (!chip)\r\nreturn -ENOMEM;\r\nplatform_set_drvdata(pdev, chip);\r\nchip->dev = &pdev->dev;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nchip->base = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(chip->base))\r\nreturn PTR_ERR(chip->base);\r\nchip->irq = platform_get_irq(pdev, 0);\r\nif (chip->irq < 0) {\r\ndev_err(&pdev->dev, "No IRQ resource\n");\r\nreturn chip->irq;\r\n}\r\nret = devm_request_irq(&pdev->dev, chip->irq, sun6i_rtc_alarmirq,\r\n0, dev_name(&pdev->dev), chip);\r\nif (ret) {\r\ndev_err(&pdev->dev, "Could not request IRQ\n");\r\nreturn ret;\r\n}\r\nwritel(0, chip->base + SUN6I_ALRM_COUNTER);\r\nwritel(0, chip->base + SUN6I_ALRM_EN);\r\nwritel(0, chip->base + SUN6I_ALRM_IRQ_EN);\r\nwritel(0, chip->base + SUN6I_ALRM1_EN);\r\nwritel(0, chip->base + SUN6I_ALRM1_IRQ_EN);\r\nwritel(SUN6I_ALRM_IRQ_STA_CNT_IRQ_PEND,\r\nchip->base + SUN6I_ALRM_IRQ_STA);\r\nwritel(SUN6I_ALRM1_IRQ_STA_WEEK_IRQ_PEND,\r\nchip->base + SUN6I_ALRM1_IRQ_STA);\r\nwritel(0, chip->base + SUN6I_ALARM_CONFIG);\r\nchip->rtc = rtc_device_register("rtc-sun6i", &pdev->dev,\r\n&sun6i_rtc_ops, THIS_MODULE);\r\nif (IS_ERR(chip->rtc)) {\r\ndev_err(&pdev->dev, "unable to register device\n");\r\nreturn PTR_ERR(chip->rtc);\r\n}\r\ndev_info(&pdev->dev, "RTC enabled\n");\r\nreturn 0;\r\n}\r\nstatic int sun6i_rtc_remove(struct platform_device *pdev)\r\n{\r\nstruct sun6i_rtc_dev *chip = platform_get_drvdata(pdev);\r\nrtc_device_unregister(chip->rtc);\r\nreturn 0;\r\n}
