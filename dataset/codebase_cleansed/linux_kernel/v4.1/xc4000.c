static int xc_send_i2c_data(struct xc4000_priv *priv, u8 *buf, int len)\r\n{\r\nstruct i2c_msg msg = { .addr = priv->i2c_props.addr,\r\n.flags = 0, .buf = buf, .len = len };\r\nif (i2c_transfer(priv->i2c_props.adap, &msg, 1) != 1) {\r\nif (priv->ignore_i2c_write_errors == 0) {\r\nprintk(KERN_ERR "xc4000: I2C write failed (len=%i)\n",\r\nlen);\r\nif (len == 4) {\r\nprintk(KERN_ERR "bytes %*ph\n", 4, buf);\r\n}\r\nreturn -EREMOTEIO;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int xc4000_tuner_reset(struct dvb_frontend *fe)\r\n{\r\nstruct xc4000_priv *priv = fe->tuner_priv;\r\nint ret;\r\ndprintk(1, "%s()\n", __func__);\r\nif (fe->callback) {\r\nret = fe->callback(((fe->dvb) && (fe->dvb->priv)) ?\r\nfe->dvb->priv :\r\npriv->i2c_props.adap->algo_data,\r\nDVB_FRONTEND_COMPONENT_TUNER,\r\nXC4000_TUNER_RESET, 0);\r\nif (ret) {\r\nprintk(KERN_ERR "xc4000: reset failed\n");\r\nreturn -EREMOTEIO;\r\n}\r\n} else {\r\nprintk(KERN_ERR "xc4000: no tuner reset callback function, "\r\n"fatal\n");\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int xc_write_reg(struct xc4000_priv *priv, u16 regAddr, u16 i2cData)\r\n{\r\nu8 buf[4];\r\nint result;\r\nbuf[0] = (regAddr >> 8) & 0xFF;\r\nbuf[1] = regAddr & 0xFF;\r\nbuf[2] = (i2cData >> 8) & 0xFF;\r\nbuf[3] = i2cData & 0xFF;\r\nresult = xc_send_i2c_data(priv, buf, 4);\r\nreturn result;\r\n}\r\nstatic int xc_load_i2c_sequence(struct dvb_frontend *fe, const u8 *i2c_sequence)\r\n{\r\nstruct xc4000_priv *priv = fe->tuner_priv;\r\nint i, nbytes_to_send, result;\r\nunsigned int len, pos, index;\r\nu8 buf[XC_MAX_I2C_WRITE_LENGTH];\r\nindex = 0;\r\nwhile ((i2c_sequence[index] != 0xFF) ||\r\n(i2c_sequence[index + 1] != 0xFF)) {\r\nlen = i2c_sequence[index] * 256 + i2c_sequence[index+1];\r\nif (len == 0x0000) {\r\nindex += 2;\r\n} else if (len & 0x8000) {\r\nmsleep(len & 0x7FFF);\r\nindex += 2;\r\n} else {\r\nindex += 2;\r\nbuf[0] = i2c_sequence[index];\r\nbuf[1] = i2c_sequence[index + 1];\r\npos = 2;\r\nwhile (pos < len) {\r\nif ((len - pos) > XC_MAX_I2C_WRITE_LENGTH - 2)\r\nnbytes_to_send =\r\nXC_MAX_I2C_WRITE_LENGTH;\r\nelse\r\nnbytes_to_send = (len - pos + 2);\r\nfor (i = 2; i < nbytes_to_send; i++) {\r\nbuf[i] = i2c_sequence[index + pos +\r\ni - 2];\r\n}\r\nresult = xc_send_i2c_data(priv, buf,\r\nnbytes_to_send);\r\nif (result != 0)\r\nreturn result;\r\npos += nbytes_to_send - 2;\r\n}\r\nindex += len;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int xc_set_tv_standard(struct xc4000_priv *priv,\r\nu16 video_mode, u16 audio_mode)\r\n{\r\nint ret;\r\ndprintk(1, "%s(0x%04x,0x%04x)\n", __func__, video_mode, audio_mode);\r\ndprintk(1, "%s() Standard = %s\n",\r\n__func__,\r\nxc4000_standard[priv->video_standard].Name);\r\npriv->ignore_i2c_write_errors = 1;\r\nret = xc_write_reg(priv, XREG_VIDEO_MODE, video_mode);\r\nif (ret == 0)\r\nret = xc_write_reg(priv, XREG_AUDIO_MODE, audio_mode);\r\npriv->ignore_i2c_write_errors = 0;\r\nreturn ret;\r\n}\r\nstatic int xc_set_signal_source(struct xc4000_priv *priv, u16 rf_mode)\r\n{\r\ndprintk(1, "%s(%d) Source = %s\n", __func__, rf_mode,\r\nrf_mode == XC_RF_MODE_AIR ? "ANTENNA" : "CABLE");\r\nif ((rf_mode != XC_RF_MODE_AIR) && (rf_mode != XC_RF_MODE_CABLE)) {\r\nrf_mode = XC_RF_MODE_CABLE;\r\nprintk(KERN_ERR\r\n"%s(), Invalid mode, defaulting to CABLE",\r\n__func__);\r\n}\r\nreturn xc_write_reg(priv, XREG_SIGNALSOURCE, rf_mode);\r\n}\r\nstatic int xc_set_rf_frequency(struct xc4000_priv *priv, u32 freq_hz)\r\n{\r\nu16 freq_code;\r\ndprintk(1, "%s(%u)\n", __func__, freq_hz);\r\nif ((freq_hz > xc4000_tuner_ops.info.frequency_max) ||\r\n(freq_hz < xc4000_tuner_ops.info.frequency_min))\r\nreturn -EINVAL;\r\nfreq_code = (u16)(freq_hz / 15625);\r\nreturn xc_write_reg(priv, XREG_RF_FREQ, freq_code);\r\n}\r\nstatic int xc_get_adc_envelope(struct xc4000_priv *priv, u16 *adc_envelope)\r\n{\r\nreturn xc4000_readreg(priv, XREG_ADC_ENV, adc_envelope);\r\n}\r\nstatic int xc_get_frequency_error(struct xc4000_priv *priv, u32 *freq_error_hz)\r\n{\r\nint result;\r\nu16 regData;\r\nu32 tmp;\r\nresult = xc4000_readreg(priv, XREG_FREQ_ERROR, &regData);\r\nif (result != 0)\r\nreturn result;\r\ntmp = (u32)regData & 0xFFFFU;\r\ntmp = (tmp < 0x8000U ? tmp : 0x10000U - tmp);\r\n(*freq_error_hz) = tmp * 15625;\r\nreturn result;\r\n}\r\nstatic int xc_get_lock_status(struct xc4000_priv *priv, u16 *lock_status)\r\n{\r\nreturn xc4000_readreg(priv, XREG_LOCK, lock_status);\r\n}\r\nstatic int xc_get_version(struct xc4000_priv *priv,\r\nu8 *hw_majorversion, u8 *hw_minorversion,\r\nu8 *fw_majorversion, u8 *fw_minorversion)\r\n{\r\nu16 data;\r\nint result;\r\nresult = xc4000_readreg(priv, XREG_VERSION, &data);\r\nif (result != 0)\r\nreturn result;\r\n(*hw_majorversion) = (data >> 12) & 0x0F;\r\n(*hw_minorversion) = (data >> 8) & 0x0F;\r\n(*fw_majorversion) = (data >> 4) & 0x0F;\r\n(*fw_minorversion) = data & 0x0F;\r\nreturn 0;\r\n}\r\nstatic int xc_get_hsync_freq(struct xc4000_priv *priv, u32 *hsync_freq_hz)\r\n{\r\nu16 regData;\r\nint result;\r\nresult = xc4000_readreg(priv, XREG_HSYNC_FREQ, &regData);\r\nif (result != 0)\r\nreturn result;\r\n(*hsync_freq_hz) = ((regData & 0x0fff) * 763)/100;\r\nreturn result;\r\n}\r\nstatic int xc_get_frame_lines(struct xc4000_priv *priv, u16 *frame_lines)\r\n{\r\nreturn xc4000_readreg(priv, XREG_FRAME_LINES, frame_lines);\r\n}\r\nstatic int xc_get_quality(struct xc4000_priv *priv, u16 *quality)\r\n{\r\nreturn xc4000_readreg(priv, XREG_QUALITY, quality);\r\n}\r\nstatic int xc_get_signal_level(struct xc4000_priv *priv, u16 *signal)\r\n{\r\nreturn xc4000_readreg(priv, XREG_SIGNAL_LEVEL, signal);\r\n}\r\nstatic int xc_get_noise_level(struct xc4000_priv *priv, u16 *noise)\r\n{\r\nreturn xc4000_readreg(priv, XREG_NOISE_LEVEL, noise);\r\n}\r\nstatic u16 xc_wait_for_lock(struct xc4000_priv *priv)\r\n{\r\nu16 lock_state = 0;\r\nint watchdog_count = 40;\r\nwhile ((lock_state == 0) && (watchdog_count > 0)) {\r\nxc_get_lock_status(priv, &lock_state);\r\nif (lock_state != 1) {\r\nmsleep(5);\r\nwatchdog_count--;\r\n}\r\n}\r\nreturn lock_state;\r\n}\r\nstatic int xc_tune_channel(struct xc4000_priv *priv, u32 freq_hz)\r\n{\r\nint found = 1;\r\nint result;\r\ndprintk(1, "%s(%u)\n", __func__, freq_hz);\r\npriv->ignore_i2c_write_errors = 1;\r\nresult = xc_set_rf_frequency(priv, freq_hz);\r\npriv->ignore_i2c_write_errors = 0;\r\nif (result != 0)\r\nreturn 0;\r\nif ((priv->cur_fw.type & (FM | DTV6 | DTV7 | DTV78 | DTV8)) == 0) {\r\nif (xc_wait_for_lock(priv) != 1)\r\nfound = 0;\r\n}\r\nmsleep(debug ? 100 : 10);\r\nif (debug)\r\nxc_debug_dump(priv);\r\nreturn found;\r\n}\r\nstatic int xc4000_readreg(struct xc4000_priv *priv, u16 reg, u16 *val)\r\n{\r\nu8 buf[2] = { reg >> 8, reg & 0xff };\r\nu8 bval[2] = { 0, 0 };\r\nstruct i2c_msg msg[2] = {\r\n{ .addr = priv->i2c_props.addr,\r\n.flags = 0, .buf = &buf[0], .len = 2 },\r\n{ .addr = priv->i2c_props.addr,\r\n.flags = I2C_M_RD, .buf = &bval[0], .len = 2 },\r\n};\r\nif (i2c_transfer(priv->i2c_props.adap, msg, 2) != 2) {\r\nprintk(KERN_ERR "xc4000: I2C read failed\n");\r\nreturn -EREMOTEIO;\r\n}\r\n*val = (bval[0] << 8) | bval[1];\r\nreturn 0;\r\n}\r\nstatic void dump_firm_type_and_int_freq(unsigned int type, u16 int_freq)\r\n{\r\nif (type & BASE)\r\nprintk(KERN_CONT "BASE ");\r\nif (type & INIT1)\r\nprintk(KERN_CONT "INIT1 ");\r\nif (type & F8MHZ)\r\nprintk(KERN_CONT "F8MHZ ");\r\nif (type & MTS)\r\nprintk(KERN_CONT "MTS ");\r\nif (type & D2620)\r\nprintk(KERN_CONT "D2620 ");\r\nif (type & D2633)\r\nprintk(KERN_CONT "D2633 ");\r\nif (type & DTV6)\r\nprintk(KERN_CONT "DTV6 ");\r\nif (type & QAM)\r\nprintk(KERN_CONT "QAM ");\r\nif (type & DTV7)\r\nprintk(KERN_CONT "DTV7 ");\r\nif (type & DTV78)\r\nprintk(KERN_CONT "DTV78 ");\r\nif (type & DTV8)\r\nprintk(KERN_CONT "DTV8 ");\r\nif (type & FM)\r\nprintk(KERN_CONT "FM ");\r\nif (type & INPUT1)\r\nprintk(KERN_CONT "INPUT1 ");\r\nif (type & LCD)\r\nprintk(KERN_CONT "LCD ");\r\nif (type & NOGD)\r\nprintk(KERN_CONT "NOGD ");\r\nif (type & MONO)\r\nprintk(KERN_CONT "MONO ");\r\nif (type & ATSC)\r\nprintk(KERN_CONT "ATSC ");\r\nif (type & IF)\r\nprintk(KERN_CONT "IF ");\r\nif (type & LG60)\r\nprintk(KERN_CONT "LG60 ");\r\nif (type & ATI638)\r\nprintk(KERN_CONT "ATI638 ");\r\nif (type & OREN538)\r\nprintk(KERN_CONT "OREN538 ");\r\nif (type & OREN36)\r\nprintk(KERN_CONT "OREN36 ");\r\nif (type & TOYOTA388)\r\nprintk(KERN_CONT "TOYOTA388 ");\r\nif (type & TOYOTA794)\r\nprintk(KERN_CONT "TOYOTA794 ");\r\nif (type & DIBCOM52)\r\nprintk(KERN_CONT "DIBCOM52 ");\r\nif (type & ZARLINK456)\r\nprintk(KERN_CONT "ZARLINK456 ");\r\nif (type & CHINA)\r\nprintk(KERN_CONT "CHINA ");\r\nif (type & F6MHZ)\r\nprintk(KERN_CONT "F6MHZ ");\r\nif (type & INPUT2)\r\nprintk(KERN_CONT "INPUT2 ");\r\nif (type & SCODE)\r\nprintk(KERN_CONT "SCODE ");\r\nif (type & HAS_IF)\r\nprintk(KERN_CONT "HAS_IF_%d ", int_freq);\r\n}\r\nstatic int seek_firmware(struct dvb_frontend *fe, unsigned int type,\r\nv4l2_std_id *id)\r\n{\r\nstruct xc4000_priv *priv = fe->tuner_priv;\r\nint i, best_i = -1;\r\nunsigned int best_nr_diffs = 255U;\r\nif (!priv->firm) {\r\nprintk(KERN_ERR "Error! firmware not loaded\n");\r\nreturn -EINVAL;\r\n}\r\nif (((type & ~SCODE) == 0) && (*id == 0))\r\n*id = V4L2_STD_PAL;\r\nfor (i = 0; i < priv->firm_size; i++) {\r\nv4l2_std_id id_diff_mask =\r\n(priv->firm[i].id ^ (*id)) & (*id);\r\nunsigned int type_diff_mask =\r\n(priv->firm[i].type ^ type)\r\n& (BASE_TYPES | DTV_TYPES | LCD | NOGD | MONO | SCODE);\r\nunsigned int nr_diffs;\r\nif (type_diff_mask\r\n& (BASE | INIT1 | FM | DTV6 | DTV7 | DTV78 | DTV8 | SCODE))\r\ncontinue;\r\nnr_diffs = hweight64(id_diff_mask) + hweight32(type_diff_mask);\r\nif (!nr_diffs)\r\ngoto found;\r\nif (nr_diffs < best_nr_diffs) {\r\nbest_nr_diffs = nr_diffs;\r\nbest_i = i;\r\n}\r\n}\r\nif (best_i < 0) {\r\ni = -ENOENT;\r\ngoto ret;\r\n}\r\nif (best_nr_diffs > 0U) {\r\nprintk(KERN_WARNING\r\n"Selecting best matching firmware (%u bits differ) for "\r\n"type=(%x), id %016llx:\n",\r\nbest_nr_diffs, type, (unsigned long long)*id);\r\ni = best_i;\r\n}\r\nfound:\r\n*id = priv->firm[i].id;\r\nret:\r\nif (debug) {\r\nprintk(KERN_DEBUG "%s firmware for type=",\r\n(i < 0) ? "Can't find" : "Found");\r\ndump_firm_type(type);\r\nprintk(KERN_DEBUG "(%x), id %016llx.\n", type, (unsigned long long)*id);\r\n}\r\nreturn i;\r\n}\r\nstatic int load_firmware(struct dvb_frontend *fe, unsigned int type,\r\nv4l2_std_id *id)\r\n{\r\nstruct xc4000_priv *priv = fe->tuner_priv;\r\nint pos, rc;\r\nunsigned char *p;\r\npos = seek_firmware(fe, type, id);\r\nif (pos < 0)\r\nreturn pos;\r\np = priv->firm[pos].ptr;\r\npriv->ignore_i2c_write_errors = 1;\r\nrc = xc_load_i2c_sequence(fe, p);\r\npriv->ignore_i2c_write_errors = 0;\r\nreturn rc;\r\n}\r\nstatic int xc4000_fwupload(struct dvb_frontend *fe)\r\n{\r\nstruct xc4000_priv *priv = fe->tuner_priv;\r\nconst struct firmware *fw = NULL;\r\nconst unsigned char *p, *endp;\r\nint rc = 0;\r\nint n, n_array;\r\nchar name[33];\r\nconst char *fname;\r\nif (firmware_name[0] != '\0') {\r\nfname = firmware_name;\r\ndprintk(1, "Reading custom firmware %s\n", fname);\r\nrc = request_firmware(&fw, fname,\r\npriv->i2c_props.adap->dev.parent);\r\n} else {\r\nfname = XC4000_DEFAULT_FIRMWARE_NEW;\r\ndprintk(1, "Trying to read firmware %s\n", fname);\r\nrc = request_firmware(&fw, fname,\r\npriv->i2c_props.adap->dev.parent);\r\nif (rc == -ENOENT) {\r\nfname = XC4000_DEFAULT_FIRMWARE;\r\ndprintk(1, "Trying to read firmware %s\n", fname);\r\nrc = request_firmware(&fw, fname,\r\npriv->i2c_props.adap->dev.parent);\r\n}\r\n}\r\nif (rc < 0) {\r\nif (rc == -ENOENT)\r\nprintk(KERN_ERR "Error: firmware %s not found.\n", fname);\r\nelse\r\nprintk(KERN_ERR "Error %d while requesting firmware %s\n",\r\nrc, fname);\r\nreturn rc;\r\n}\r\ndprintk(1, "Loading Firmware: %s\n", fname);\r\np = fw->data;\r\nendp = p + fw->size;\r\nif (fw->size < sizeof(name) - 1 + 2 + 2) {\r\nprintk(KERN_ERR "Error: firmware file %s has invalid size!\n",\r\nfname);\r\ngoto corrupt;\r\n}\r\nmemcpy(name, p, sizeof(name) - 1);\r\nname[sizeof(name) - 1] = '\0';\r\np += sizeof(name) - 1;\r\npriv->firm_version = get_unaligned_le16(p);\r\np += 2;\r\nn_array = get_unaligned_le16(p);\r\np += 2;\r\ndprintk(1, "Loading %d firmware images from %s, type: %s, ver %d.%d\n",\r\nn_array, fname, name,\r\npriv->firm_version >> 8, priv->firm_version & 0xff);\r\npriv->firm = kcalloc(n_array, sizeof(*priv->firm), GFP_KERNEL);\r\nif (priv->firm == NULL) {\r\nprintk(KERN_ERR "Not enough memory to load firmware file.\n");\r\nrc = -ENOMEM;\r\ngoto done;\r\n}\r\npriv->firm_size = n_array;\r\nn = -1;\r\nwhile (p < endp) {\r\n__u32 type, size;\r\nv4l2_std_id id;\r\n__u16 int_freq = 0;\r\nn++;\r\nif (n >= n_array) {\r\nprintk(KERN_ERR "More firmware images in file than "\r\n"were expected!\n");\r\ngoto corrupt;\r\n}\r\nif (endp - p < sizeof(type) + sizeof(id) + sizeof(size))\r\ngoto header;\r\ntype = get_unaligned_le32(p);\r\np += sizeof(type);\r\nid = get_unaligned_le64(p);\r\np += sizeof(id);\r\nif (type & HAS_IF) {\r\nint_freq = get_unaligned_le16(p);\r\np += sizeof(int_freq);\r\nif (endp - p < sizeof(size))\r\ngoto header;\r\n}\r\nsize = get_unaligned_le32(p);\r\np += sizeof(size);\r\nif (!size || size > endp - p) {\r\nprintk(KERN_ERR "Firmware type (%x), id %llx is corrupted (size=%d, expected %d)\n",\r\ntype, (unsigned long long)id,\r\n(unsigned)(endp - p), size);\r\ngoto corrupt;\r\n}\r\npriv->firm[n].ptr = kzalloc(size, GFP_KERNEL);\r\nif (priv->firm[n].ptr == NULL) {\r\nprintk(KERN_ERR "Not enough memory to load firmware file.\n");\r\nrc = -ENOMEM;\r\ngoto done;\r\n}\r\nif (debug) {\r\nprintk(KERN_DEBUG "Reading firmware type ");\r\ndump_firm_type_and_int_freq(type, int_freq);\r\nprintk(KERN_DEBUG "(%x), id %llx, size=%d.\n",\r\ntype, (unsigned long long)id, size);\r\n}\r\nmemcpy(priv->firm[n].ptr, p, size);\r\npriv->firm[n].type = type;\r\npriv->firm[n].id = id;\r\npriv->firm[n].size = size;\r\npriv->firm[n].int_freq = int_freq;\r\np += size;\r\n}\r\nif (n + 1 != priv->firm_size) {\r\nprintk(KERN_ERR "Firmware file is incomplete!\n");\r\ngoto corrupt;\r\n}\r\ngoto done;\r\nheader:\r\nprintk(KERN_ERR "Firmware header is incomplete!\n");\r\ncorrupt:\r\nrc = -EINVAL;\r\nprintk(KERN_ERR "Error: firmware file is corrupted!\n");\r\ndone:\r\nrelease_firmware(fw);\r\nif (rc == 0)\r\ndprintk(1, "Firmware files loaded.\n");\r\nreturn rc;\r\n}\r\nstatic int load_scode(struct dvb_frontend *fe, unsigned int type,\r\nv4l2_std_id *id, __u16 int_freq, int scode)\r\n{\r\nstruct xc4000_priv *priv = fe->tuner_priv;\r\nint pos, rc;\r\nunsigned char *p;\r\nu8 scode_buf[13];\r\nu8 indirect_mode[5];\r\ndprintk(1, "%s called int_freq=%d\n", __func__, int_freq);\r\nif (!int_freq) {\r\npos = seek_firmware(fe, type, id);\r\nif (pos < 0)\r\nreturn pos;\r\n} else {\r\nfor (pos = 0; pos < priv->firm_size; pos++) {\r\nif ((priv->firm[pos].int_freq == int_freq) &&\r\n(priv->firm[pos].type & HAS_IF))\r\nbreak;\r\n}\r\nif (pos == priv->firm_size)\r\nreturn -ENOENT;\r\n}\r\np = priv->firm[pos].ptr;\r\nif (priv->firm[pos].size != 12 * 16 || scode >= 16)\r\nreturn -EINVAL;\r\np += 12 * scode;\r\nif (debug) {\r\ntuner_info("Loading SCODE for type=");\r\ndump_firm_type_and_int_freq(priv->firm[pos].type,\r\npriv->firm[pos].int_freq);\r\nprintk(KERN_CONT "(%x), id %016llx.\n", priv->firm[pos].type,\r\n(unsigned long long)*id);\r\n}\r\nscode_buf[0] = 0x00;\r\nmemcpy(&scode_buf[1], p, 12);\r\nrc = xc_write_reg(priv, XREG_DIRECTSITTING_MODE, 0);\r\nif (rc < 0) {\r\nprintk(KERN_ERR "failed to put device into direct mode!\n");\r\nreturn -EIO;\r\n}\r\nrc = xc_send_i2c_data(priv, scode_buf, 13);\r\nif (rc != 0) {\r\nprintk(KERN_ERR "Failed to set scode %d\n", rc);\r\n}\r\nmemset(indirect_mode, 0, sizeof(indirect_mode));\r\nindirect_mode[4] = 0x88;\r\nxc_send_i2c_data(priv, indirect_mode, sizeof(indirect_mode));\r\nmsleep(10);\r\nreturn 0;\r\n}\r\nstatic int check_firmware(struct dvb_frontend *fe, unsigned int type,\r\nv4l2_std_id std, __u16 int_freq)\r\n{\r\nstruct xc4000_priv *priv = fe->tuner_priv;\r\nstruct firmware_properties new_fw;\r\nint rc = 0, is_retry = 0;\r\nu16 hwmodel;\r\nv4l2_std_id std0;\r\nu8 hw_major = 0, hw_minor = 0, fw_major = 0, fw_minor = 0;\r\ndprintk(1, "%s called\n", __func__);\r\nif (!priv->firm) {\r\nrc = xc4000_fwupload(fe);\r\nif (rc < 0)\r\nreturn rc;\r\n}\r\nretry:\r\nnew_fw.type = type;\r\nnew_fw.id = std;\r\nnew_fw.std_req = std;\r\nnew_fw.scode_table = SCODE;\r\nnew_fw.scode_nr = 0;\r\nnew_fw.int_freq = int_freq;\r\ndprintk(1, "checking firmware, user requested type=");\r\nif (debug) {\r\ndump_firm_type(new_fw.type);\r\nprintk(KERN_CONT "(%x), id %016llx, ", new_fw.type,\r\n(unsigned long long)new_fw.std_req);\r\nif (!int_freq)\r\nprintk(KERN_CONT "scode_tbl ");\r\nelse\r\nprintk(KERN_CONT "int_freq %d, ", new_fw.int_freq);\r\nprintk(KERN_CONT "scode_nr %d\n", new_fw.scode_nr);\r\n}\r\nif (priv->cur_fw.type & BASE) {\r\ndprintk(1, "BASE firmware not changed.\n");\r\ngoto skip_base;\r\n}\r\nmemset(&priv->cur_fw, 0, sizeof(priv->cur_fw));\r\nrc = xc4000_tuner_reset(fe);\r\nif (rc < 0)\r\ngoto fail;\r\nstd0 = 0;\r\nrc = load_firmware(fe, BASE, &std0);\r\nif (rc < 0) {\r\nprintk(KERN_ERR "Error %d while loading base firmware\n", rc);\r\ngoto fail;\r\n}\r\ndprintk(1, "Load init1 firmware, if exists\n");\r\nrc = load_firmware(fe, BASE | INIT1, &std0);\r\nif (rc == -ENOENT)\r\nrc = load_firmware(fe, BASE | INIT1, &std0);\r\nif (rc < 0 && rc != -ENOENT) {\r\ntuner_err("Error %d while loading init1 firmware\n",\r\nrc);\r\ngoto fail;\r\n}\r\nskip_base:\r\nif (priv->cur_fw.type == (BASE | new_fw.type) &&\r\npriv->cur_fw.std_req == std) {\r\ndprintk(1, "Std-specific firmware already loaded.\n");\r\ngoto skip_std_specific;\r\n}\r\npriv->cur_fw.scode_table = 0;\r\nrc = load_firmware(fe, new_fw.type, &new_fw.id);\r\nif (rc < 0)\r\ngoto fail;\r\nskip_std_specific:\r\nif (priv->cur_fw.scode_table == new_fw.scode_table &&\r\npriv->cur_fw.scode_nr == new_fw.scode_nr) {\r\ndprintk(1, "SCODE firmware already loaded.\n");\r\ngoto check_device;\r\n}\r\nrc = load_scode(fe, new_fw.type | new_fw.scode_table, &new_fw.id,\r\nnew_fw.int_freq, new_fw.scode_nr);\r\nif (rc != 0)\r\ndprintk(1, "load scode failed %d\n", rc);\r\ncheck_device:\r\nrc = xc4000_readreg(priv, XREG_PRODUCT_ID, &hwmodel);\r\nif (xc_get_version(priv, &hw_major, &hw_minor, &fw_major,\r\n&fw_minor) != 0) {\r\nprintk(KERN_ERR "Unable to read tuner registers.\n");\r\ngoto fail;\r\n}\r\ndprintk(1, "Device is Xceive %d version %d.%d, "\r\n"firmware version %d.%d\n",\r\nhwmodel, hw_major, hw_minor, fw_major, fw_minor);\r\nif (priv->firm_version != ((fw_major << 8) | fw_minor)) {\r\nprintk(KERN_WARNING\r\n"Incorrect readback of firmware version %d.%d.\n",\r\nfw_major, fw_minor);\r\ngoto fail;\r\n}\r\nif (priv->hwmodel == 0 &&\r\n(hwmodel == XC_PRODUCT_ID_XC4000 ||\r\nhwmodel == XC_PRODUCT_ID_XC4100)) {\r\npriv->hwmodel = hwmodel;\r\npriv->hwvers = (hw_major << 8) | hw_minor;\r\n} else if (priv->hwmodel == 0 || priv->hwmodel != hwmodel ||\r\npriv->hwvers != ((hw_major << 8) | hw_minor)) {\r\nprintk(KERN_WARNING\r\n"Read invalid device hardware information - tuner "\r\n"hung?\n");\r\ngoto fail;\r\n}\r\npriv->cur_fw = new_fw;\r\npriv->cur_fw.type |= BASE;\r\nreturn 0;\r\nfail:\r\nmemset(&priv->cur_fw, 0, sizeof(priv->cur_fw));\r\nif (!is_retry) {\r\nmsleep(50);\r\nis_retry = 1;\r\ndprintk(1, "Retrying firmware load\n");\r\ngoto retry;\r\n}\r\nif (rc == -ENOENT)\r\nrc = -EINVAL;\r\nreturn rc;\r\n}\r\nstatic void xc_debug_dump(struct xc4000_priv *priv)\r\n{\r\nu16 adc_envelope;\r\nu32 freq_error_hz = 0;\r\nu16 lock_status;\r\nu32 hsync_freq_hz = 0;\r\nu16 frame_lines;\r\nu16 quality;\r\nu16 signal = 0;\r\nu16 noise = 0;\r\nu8 hw_majorversion = 0, hw_minorversion = 0;\r\nu8 fw_majorversion = 0, fw_minorversion = 0;\r\nxc_get_adc_envelope(priv, &adc_envelope);\r\ndprintk(1, "*** ADC envelope (0-1023) = %d\n", adc_envelope);\r\nxc_get_frequency_error(priv, &freq_error_hz);\r\ndprintk(1, "*** Frequency error = %d Hz\n", freq_error_hz);\r\nxc_get_lock_status(priv, &lock_status);\r\ndprintk(1, "*** Lock status (0-Wait, 1-Locked, 2-No-signal) = %d\n",\r\nlock_status);\r\nxc_get_version(priv, &hw_majorversion, &hw_minorversion,\r\n&fw_majorversion, &fw_minorversion);\r\ndprintk(1, "*** HW: V%02x.%02x, FW: V%02x.%02x\n",\r\nhw_majorversion, hw_minorversion,\r\nfw_majorversion, fw_minorversion);\r\nif (priv->video_standard < XC4000_DTV6) {\r\nxc_get_hsync_freq(priv, &hsync_freq_hz);\r\ndprintk(1, "*** Horizontal sync frequency = %d Hz\n",\r\nhsync_freq_hz);\r\nxc_get_frame_lines(priv, &frame_lines);\r\ndprintk(1, "*** Frame lines = %d\n", frame_lines);\r\n}\r\nxc_get_quality(priv, &quality);\r\ndprintk(1, "*** Quality (0:<8dB, 7:>56dB) = %d\n", quality);\r\nxc_get_signal_level(priv, &signal);\r\ndprintk(1, "*** Signal level = -%ddB (%d)\n", signal >> 8, signal);\r\nxc_get_noise_level(priv, &noise);\r\ndprintk(1, "*** Noise level = %ddB (%d)\n", noise >> 8, noise);\r\n}\r\nstatic int xc4000_set_params(struct dvb_frontend *fe)\r\n{\r\nstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\r\nu32 delsys = c->delivery_system;\r\nu32 bw = c->bandwidth_hz;\r\nstruct xc4000_priv *priv = fe->tuner_priv;\r\nunsigned int type;\r\nint ret = -EREMOTEIO;\r\ndprintk(1, "%s() frequency=%d (Hz)\n", __func__, c->frequency);\r\nmutex_lock(&priv->lock);\r\nswitch (delsys) {\r\ncase SYS_ATSC:\r\ndprintk(1, "%s() VSB modulation\n", __func__);\r\npriv->rf_mode = XC_RF_MODE_AIR;\r\npriv->freq_offset = 1750000;\r\npriv->video_standard = XC4000_DTV6;\r\ntype = DTV6;\r\nbreak;\r\ncase SYS_DVBC_ANNEX_B:\r\ndprintk(1, "%s() QAM modulation\n", __func__);\r\npriv->rf_mode = XC_RF_MODE_CABLE;\r\npriv->freq_offset = 1750000;\r\npriv->video_standard = XC4000_DTV6;\r\ntype = DTV6;\r\nbreak;\r\ncase SYS_DVBT:\r\ncase SYS_DVBT2:\r\ndprintk(1, "%s() OFDM\n", __func__);\r\nif (bw == 0) {\r\nif (c->frequency < 400000000) {\r\npriv->freq_offset = 2250000;\r\n} else {\r\npriv->freq_offset = 2750000;\r\n}\r\npriv->video_standard = XC4000_DTV7_8;\r\ntype = DTV78;\r\n} else if (bw <= 6000000) {\r\npriv->video_standard = XC4000_DTV6;\r\npriv->freq_offset = 1750000;\r\ntype = DTV6;\r\n} else if (bw <= 7000000) {\r\npriv->video_standard = XC4000_DTV7;\r\npriv->freq_offset = 2250000;\r\ntype = DTV7;\r\n} else {\r\npriv->video_standard = XC4000_DTV8;\r\npriv->freq_offset = 2750000;\r\ntype = DTV8;\r\n}\r\npriv->rf_mode = XC_RF_MODE_AIR;\r\nbreak;\r\ndefault:\r\nprintk(KERN_ERR "xc4000 delivery system not supported!\n");\r\nret = -EINVAL;\r\ngoto fail;\r\n}\r\npriv->freq_hz = c->frequency - priv->freq_offset;\r\ndprintk(1, "%s() frequency=%d (compensated)\n",\r\n__func__, priv->freq_hz);\r\nif (check_firmware(fe, type, 0, priv->if_khz) != 0)\r\ngoto fail;\r\npriv->bandwidth = c->bandwidth_hz;\r\nret = xc_set_signal_source(priv, priv->rf_mode);\r\nif (ret != 0) {\r\nprintk(KERN_ERR "xc4000: xc_set_signal_source(%d) failed\n",\r\npriv->rf_mode);\r\ngoto fail;\r\n} else {\r\nu16 video_mode, audio_mode;\r\nvideo_mode = xc4000_standard[priv->video_standard].video_mode;\r\naudio_mode = xc4000_standard[priv->video_standard].audio_mode;\r\nif (type == DTV6 && priv->firm_version != 0x0102)\r\nvideo_mode |= 0x0001;\r\nret = xc_set_tv_standard(priv, video_mode, audio_mode);\r\nif (ret != 0) {\r\nprintk(KERN_ERR "xc4000: xc_set_tv_standard failed\n");\r\n}\r\n}\r\nif (xc_write_reg(priv, XREG_D_CODE, 0) == 0)\r\nret = 0;\r\nif (priv->dvb_amplitude != 0) {\r\nif (xc_write_reg(priv, XREG_AMPLITUDE,\r\n(priv->firm_version != 0x0102 ||\r\npriv->dvb_amplitude != 134 ?\r\npriv->dvb_amplitude : 132)) != 0)\r\nret = -EREMOTEIO;\r\n}\r\nif (priv->set_smoothedcvbs != 0) {\r\nif (xc_write_reg(priv, XREG_SMOOTHEDCVBS, 1) != 0)\r\nret = -EREMOTEIO;\r\n}\r\nif (ret != 0) {\r\nprintk(KERN_ERR "xc4000: setting registers failed\n");\r\n}\r\nxc_tune_channel(priv, priv->freq_hz);\r\nret = 0;\r\nfail:\r\nmutex_unlock(&priv->lock);\r\nreturn ret;\r\n}\r\nstatic int xc4000_set_analog_params(struct dvb_frontend *fe,\r\nstruct analog_parameters *params)\r\n{\r\nstruct xc4000_priv *priv = fe->tuner_priv;\r\nunsigned int type = 0;\r\nint ret = -EREMOTEIO;\r\nif (params->mode == V4L2_TUNER_RADIO) {\r\ndprintk(1, "%s() frequency=%d (in units of 62.5Hz)\n",\r\n__func__, params->frequency);\r\nmutex_lock(&priv->lock);\r\nparams->std = 0;\r\npriv->freq_hz = params->frequency * 125L / 2;\r\nif (audio_std & XC4000_AUDIO_STD_INPUT1) {\r\npriv->video_standard = XC4000_FM_Radio_INPUT1;\r\ntype = FM | INPUT1;\r\n} else {\r\npriv->video_standard = XC4000_FM_Radio_INPUT2;\r\ntype = FM | INPUT2;\r\n}\r\ngoto tune_channel;\r\n}\r\ndprintk(1, "%s() frequency=%d (in units of 62.5khz)\n",\r\n__func__, params->frequency);\r\nmutex_lock(&priv->lock);\r\npriv->freq_hz = params->frequency * 62500;\r\nparams->std &= V4L2_STD_ALL;\r\nif (!params->std)\r\nparams->std = V4L2_STD_PAL_BG;\r\nif (audio_std & XC4000_AUDIO_STD_MONO)\r\ntype = MONO;\r\nif (params->std & V4L2_STD_MN) {\r\nparams->std = V4L2_STD_MN;\r\nif (audio_std & XC4000_AUDIO_STD_MONO) {\r\npriv->video_standard = XC4000_MN_NTSC_PAL_Mono;\r\n} else if (audio_std & XC4000_AUDIO_STD_A2) {\r\nparams->std |= V4L2_STD_A2;\r\npriv->video_standard = XC4000_MN_NTSC_PAL_A2;\r\n} else {\r\nparams->std |= V4L2_STD_BTSC;\r\npriv->video_standard = XC4000_MN_NTSC_PAL_BTSC;\r\n}\r\ngoto tune_channel;\r\n}\r\nif (params->std & V4L2_STD_PAL_BG) {\r\nparams->std = V4L2_STD_PAL_BG;\r\nif (audio_std & XC4000_AUDIO_STD_MONO) {\r\npriv->video_standard = XC4000_BG_PAL_MONO;\r\n} else if (!(audio_std & XC4000_AUDIO_STD_A2)) {\r\nif (!(audio_std & XC4000_AUDIO_STD_B)) {\r\nparams->std |= V4L2_STD_NICAM_A;\r\npriv->video_standard = XC4000_BG_PAL_NICAM;\r\n} else {\r\nparams->std |= V4L2_STD_NICAM_B;\r\npriv->video_standard = XC4000_BG_PAL_NICAM;\r\n}\r\n} else {\r\nif (!(audio_std & XC4000_AUDIO_STD_B)) {\r\nparams->std |= V4L2_STD_A2_A;\r\npriv->video_standard = XC4000_BG_PAL_A2;\r\n} else {\r\nparams->std |= V4L2_STD_A2_B;\r\npriv->video_standard = XC4000_BG_PAL_A2;\r\n}\r\n}\r\ngoto tune_channel;\r\n}\r\nif (params->std & V4L2_STD_PAL_I) {\r\nparams->std = V4L2_STD_PAL_I | V4L2_STD_NICAM;\r\nif (audio_std & XC4000_AUDIO_STD_MONO)\r\npriv->video_standard = XC4000_I_PAL_NICAM_MONO;\r\nelse\r\npriv->video_standard = XC4000_I_PAL_NICAM;\r\ngoto tune_channel;\r\n}\r\nif (params->std & V4L2_STD_PAL_DK) {\r\nparams->std = V4L2_STD_PAL_DK;\r\nif (audio_std & XC4000_AUDIO_STD_MONO) {\r\npriv->video_standard = XC4000_DK_PAL_MONO;\r\n} else if (audio_std & XC4000_AUDIO_STD_A2) {\r\nparams->std |= V4L2_STD_A2;\r\npriv->video_standard = XC4000_DK_PAL_A2;\r\n} else {\r\nparams->std |= V4L2_STD_NICAM;\r\npriv->video_standard = XC4000_DK_PAL_NICAM;\r\n}\r\ngoto tune_channel;\r\n}\r\nif (params->std & V4L2_STD_SECAM_DK) {\r\nparams->std = V4L2_STD_SECAM_DK | V4L2_STD_A2;\r\nif (audio_std & XC4000_AUDIO_STD_L) {\r\ntype = 0;\r\npriv->video_standard = XC4000_DK_SECAM_NICAM;\r\n} else if (audio_std & XC4000_AUDIO_STD_MONO) {\r\npriv->video_standard = XC4000_DK_SECAM_A2MONO;\r\n} else if (audio_std & XC4000_AUDIO_STD_K3) {\r\nparams->std |= V4L2_STD_SECAM_K3;\r\npriv->video_standard = XC4000_DK_SECAM_A2LDK3;\r\n} else {\r\npriv->video_standard = XC4000_DK_SECAM_A2DK1;\r\n}\r\ngoto tune_channel;\r\n}\r\nif (params->std & V4L2_STD_SECAM_L) {\r\ntype = 0;\r\nparams->std = V4L2_STD_SECAM_L | V4L2_STD_NICAM;\r\npriv->video_standard = XC4000_L_SECAM_NICAM;\r\ngoto tune_channel;\r\n}\r\nif (params->std & V4L2_STD_SECAM_LC) {\r\ntype = 0;\r\nparams->std = V4L2_STD_SECAM_LC | V4L2_STD_NICAM;\r\npriv->video_standard = XC4000_LC_SECAM_NICAM;\r\ngoto tune_channel;\r\n}\r\ntune_channel:\r\npriv->rf_mode = XC_RF_MODE_CABLE;\r\nif (check_firmware(fe, type, params->std,\r\nxc4000_standard[priv->video_standard].int_freq) != 0)\r\ngoto fail;\r\nret = xc_set_signal_source(priv, priv->rf_mode);\r\nif (ret != 0) {\r\nprintk(KERN_ERR\r\n"xc4000: xc_set_signal_source(%d) failed\n",\r\npriv->rf_mode);\r\ngoto fail;\r\n} else {\r\nu16 video_mode, audio_mode;\r\nvideo_mode = xc4000_standard[priv->video_standard].video_mode;\r\naudio_mode = xc4000_standard[priv->video_standard].audio_mode;\r\nif (priv->video_standard < XC4000_BG_PAL_A2) {\r\nif (type & NOGD)\r\nvideo_mode &= 0xFF7F;\r\n} else if (priv->video_standard < XC4000_I_PAL_NICAM) {\r\nif (priv->firm_version == 0x0102)\r\nvideo_mode &= 0xFEFF;\r\nif (audio_std & XC4000_AUDIO_STD_B)\r\nvideo_mode |= 0x0080;\r\n}\r\nret = xc_set_tv_standard(priv, video_mode, audio_mode);\r\nif (ret != 0) {\r\nprintk(KERN_ERR "xc4000: xc_set_tv_standard failed\n");\r\ngoto fail;\r\n}\r\n}\r\nif (xc_write_reg(priv, XREG_D_CODE, 0) == 0)\r\nret = 0;\r\nif (xc_write_reg(priv, XREG_AMPLITUDE, 1) != 0)\r\nret = -EREMOTEIO;\r\nif (priv->set_smoothedcvbs != 0) {\r\nif (xc_write_reg(priv, XREG_SMOOTHEDCVBS, 1) != 0)\r\nret = -EREMOTEIO;\r\n}\r\nif (ret != 0) {\r\nprintk(KERN_ERR "xc4000: setting registers failed\n");\r\ngoto fail;\r\n}\r\nxc_tune_channel(priv, priv->freq_hz);\r\nret = 0;\r\nfail:\r\nmutex_unlock(&priv->lock);\r\nreturn ret;\r\n}\r\nstatic int xc4000_get_signal(struct dvb_frontend *fe, u16 *strength)\r\n{\r\nstruct xc4000_priv *priv = fe->tuner_priv;\r\nu16 value = 0;\r\nint rc;\r\nmutex_lock(&priv->lock);\r\nrc = xc4000_readreg(priv, XREG_SIGNAL_LEVEL, &value);\r\nmutex_unlock(&priv->lock);\r\nif (rc < 0)\r\ngoto ret;\r\ntuner_dbg("Signal strength: -%ddB (%05d)\n", value >> 8, value);\r\nif ((priv->video_standard == XC4000_DTV6) ||\r\n(priv->video_standard == XC4000_DTV7) ||\r\n(priv->video_standard == XC4000_DTV7_8) ||\r\n(priv->video_standard == XC4000_DTV8))\r\ngoto digital;\r\nmutex_lock(&priv->lock);\r\nrc = xc4000_readreg(priv, XREG_NOISE_LEVEL, &value);\r\nmutex_unlock(&priv->lock);\r\ntuner_dbg("Noise level: %ddB (%05d)\n", value >> 8, value);\r\nif (value >= 0x2000) {\r\nvalue = 0;\r\n} else {\r\nvalue = ~value << 3;\r\n}\r\ngoto ret;\r\ndigital:\r\nif (value <= 0x3200) {\r\nvalue = 0xffff;\r\n} else if (value >= 0x713A) {\r\nvalue = 0;\r\n} else {\r\nvalue = ~(value - 0x3200) << 2;\r\n}\r\nret:\r\n*strength = value;\r\nreturn rc;\r\n}\r\nstatic int xc4000_get_frequency(struct dvb_frontend *fe, u32 *freq)\r\n{\r\nstruct xc4000_priv *priv = fe->tuner_priv;\r\n*freq = priv->freq_hz + priv->freq_offset;\r\nif (debug) {\r\nmutex_lock(&priv->lock);\r\nif ((priv->cur_fw.type\r\n& (BASE | FM | DTV6 | DTV7 | DTV78 | DTV8)) == BASE) {\r\nu16 snr = 0;\r\nif (xc4000_readreg(priv, XREG_SNR, &snr) == 0) {\r\nmutex_unlock(&priv->lock);\r\ndprintk(1, "%s() freq = %u, SNR = %d\n",\r\n__func__, *freq, snr);\r\nreturn 0;\r\n}\r\n}\r\nmutex_unlock(&priv->lock);\r\n}\r\ndprintk(1, "%s()\n", __func__);\r\nreturn 0;\r\n}\r\nstatic int xc4000_get_bandwidth(struct dvb_frontend *fe, u32 *bw)\r\n{\r\nstruct xc4000_priv *priv = fe->tuner_priv;\r\ndprintk(1, "%s()\n", __func__);\r\n*bw = priv->bandwidth;\r\nreturn 0;\r\n}\r\nstatic int xc4000_get_status(struct dvb_frontend *fe, u32 *status)\r\n{\r\nstruct xc4000_priv *priv = fe->tuner_priv;\r\nu16 lock_status = 0;\r\nmutex_lock(&priv->lock);\r\nif (priv->cur_fw.type & BASE)\r\nxc_get_lock_status(priv, &lock_status);\r\n*status = (lock_status == 1 ?\r\nTUNER_STATUS_LOCKED | TUNER_STATUS_STEREO : 0);\r\nif (priv->cur_fw.type & (DTV6 | DTV7 | DTV78 | DTV8))\r\n*status &= (~TUNER_STATUS_STEREO);\r\nmutex_unlock(&priv->lock);\r\ndprintk(2, "%s() lock_status = %d\n", __func__, lock_status);\r\nreturn 0;\r\n}\r\nstatic int xc4000_sleep(struct dvb_frontend *fe)\r\n{\r\nstruct xc4000_priv *priv = fe->tuner_priv;\r\nint ret = 0;\r\ndprintk(1, "%s()\n", __func__);\r\nmutex_lock(&priv->lock);\r\nif ((no_poweroff == 2 ||\r\n(no_poweroff == 0 && priv->default_pm != 0)) &&\r\n(priv->cur_fw.type & BASE) != 0) {\r\npriv->cur_fw.type = XC_POWERED_DOWN;\r\nif (xc_write_reg(priv, XREG_POWER_DOWN, 0) != 0) {\r\nprintk(KERN_ERR\r\n"xc4000: %s() unable to shutdown tuner\n",\r\n__func__);\r\nret = -EREMOTEIO;\r\n}\r\nmsleep(20);\r\n}\r\nmutex_unlock(&priv->lock);\r\nreturn ret;\r\n}\r\nstatic int xc4000_init(struct dvb_frontend *fe)\r\n{\r\ndprintk(1, "%s()\n", __func__);\r\nreturn 0;\r\n}\r\nstatic int xc4000_release(struct dvb_frontend *fe)\r\n{\r\nstruct xc4000_priv *priv = fe->tuner_priv;\r\ndprintk(1, "%s()\n", __func__);\r\nmutex_lock(&xc4000_list_mutex);\r\nif (priv)\r\nhybrid_tuner_release_state(priv);\r\nmutex_unlock(&xc4000_list_mutex);\r\nfe->tuner_priv = NULL;\r\nreturn 0;\r\n}\r\nstruct dvb_frontend *xc4000_attach(struct dvb_frontend *fe,\r\nstruct i2c_adapter *i2c,\r\nstruct xc4000_config *cfg)\r\n{\r\nstruct xc4000_priv *priv = NULL;\r\nint instance;\r\nu16 id = 0;\r\ndprintk(1, "%s(%d-%04x)\n", __func__,\r\ni2c ? i2c_adapter_id(i2c) : -1,\r\ncfg ? cfg->i2c_address : -1);\r\nmutex_lock(&xc4000_list_mutex);\r\ninstance = hybrid_tuner_request_state(struct xc4000_priv, priv,\r\nhybrid_tuner_instance_list,\r\ni2c, cfg->i2c_address, "xc4000");\r\nswitch (instance) {\r\ncase 0:\r\ngoto fail;\r\ncase 1:\r\npriv->bandwidth = 6000000;\r\npriv->if_khz = 4560;\r\npriv->default_pm = 0;\r\npriv->dvb_amplitude = 134;\r\npriv->set_smoothedcvbs = 1;\r\nmutex_init(&priv->lock);\r\nfe->tuner_priv = priv;\r\nbreak;\r\ndefault:\r\nfe->tuner_priv = priv;\r\nbreak;\r\n}\r\nif (cfg->if_khz != 0) {\r\npriv->if_khz = cfg->if_khz;\r\npriv->default_pm = cfg->default_pm;\r\npriv->dvb_amplitude = cfg->dvb_amplitude;\r\npriv->set_smoothedcvbs = cfg->set_smoothedcvbs;\r\n}\r\nif (instance == 1) {\r\nif (xc4000_readreg(priv, XREG_PRODUCT_ID, &id) != 0)\r\ngoto fail;\r\n} else {\r\nid = ((priv->cur_fw.type & BASE) != 0 ?\r\npriv->hwmodel : XC_PRODUCT_ID_FW_NOT_LOADED);\r\n}\r\nswitch (id) {\r\ncase XC_PRODUCT_ID_XC4000:\r\ncase XC_PRODUCT_ID_XC4100:\r\nprintk(KERN_INFO\r\n"xc4000: Successfully identified at address 0x%02x\n",\r\ncfg->i2c_address);\r\nprintk(KERN_INFO\r\n"xc4000: Firmware has been loaded previously\n");\r\nbreak;\r\ncase XC_PRODUCT_ID_FW_NOT_LOADED:\r\nprintk(KERN_INFO\r\n"xc4000: Successfully identified at address 0x%02x\n",\r\ncfg->i2c_address);\r\nprintk(KERN_INFO\r\n"xc4000: Firmware has not been loaded previously\n");\r\nbreak;\r\ndefault:\r\nprintk(KERN_ERR\r\n"xc4000: Device not found at addr 0x%02x (0x%x)\n",\r\ncfg->i2c_address, id);\r\ngoto fail;\r\n}\r\nmutex_unlock(&xc4000_list_mutex);\r\nmemcpy(&fe->ops.tuner_ops, &xc4000_tuner_ops,\r\nsizeof(struct dvb_tuner_ops));\r\nif (instance == 1) {\r\nint ret;\r\nmutex_lock(&priv->lock);\r\nret = xc4000_fwupload(fe);\r\nmutex_unlock(&priv->lock);\r\nif (ret != 0)\r\ngoto fail2;\r\n}\r\nreturn fe;\r\nfail:\r\nmutex_unlock(&xc4000_list_mutex);\r\nfail2:\r\nxc4000_release(fe);\r\nreturn NULL;\r\n}
