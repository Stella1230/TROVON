static inline struct pcie_port *sys_to_pcie(struct pci_sys_data *sys)\r\n{\r\nBUG_ON(!sys->private_data);\r\nreturn sys->private_data;\r\n}\r\nint dw_pcie_cfg_read(void __iomem *addr, int where, int size, u32 *val)\r\n{\r\n*val = readl(addr);\r\nif (size == 1)\r\n*val = (*val >> (8 * (where & 3))) & 0xff;\r\nelse if (size == 2)\r\n*val = (*val >> (8 * (where & 3))) & 0xffff;\r\nelse if (size != 4)\r\nreturn PCIBIOS_BAD_REGISTER_NUMBER;\r\nreturn PCIBIOS_SUCCESSFUL;\r\n}\r\nint dw_pcie_cfg_write(void __iomem *addr, int where, int size, u32 val)\r\n{\r\nif (size == 4)\r\nwritel(val, addr);\r\nelse if (size == 2)\r\nwritew(val, addr + (where & 2));\r\nelse if (size == 1)\r\nwriteb(val, addr + (where & 3));\r\nelse\r\nreturn PCIBIOS_BAD_REGISTER_NUMBER;\r\nreturn PCIBIOS_SUCCESSFUL;\r\n}\r\nstatic inline void dw_pcie_readl_rc(struct pcie_port *pp, u32 reg, u32 *val)\r\n{\r\nif (pp->ops->readl_rc)\r\npp->ops->readl_rc(pp, pp->dbi_base + reg, val);\r\nelse\r\n*val = readl(pp->dbi_base + reg);\r\n}\r\nstatic inline void dw_pcie_writel_rc(struct pcie_port *pp, u32 val, u32 reg)\r\n{\r\nif (pp->ops->writel_rc)\r\npp->ops->writel_rc(pp, val, pp->dbi_base + reg);\r\nelse\r\nwritel(val, pp->dbi_base + reg);\r\n}\r\nstatic int dw_pcie_rd_own_conf(struct pcie_port *pp, int where, int size,\r\nu32 *val)\r\n{\r\nint ret;\r\nif (pp->ops->rd_own_conf)\r\nret = pp->ops->rd_own_conf(pp, where, size, val);\r\nelse\r\nret = dw_pcie_cfg_read(pp->dbi_base + (where & ~0x3), where,\r\nsize, val);\r\nreturn ret;\r\n}\r\nstatic int dw_pcie_wr_own_conf(struct pcie_port *pp, int where, int size,\r\nu32 val)\r\n{\r\nint ret;\r\nif (pp->ops->wr_own_conf)\r\nret = pp->ops->wr_own_conf(pp, where, size, val);\r\nelse\r\nret = dw_pcie_cfg_write(pp->dbi_base + (where & ~0x3), where,\r\nsize, val);\r\nreturn ret;\r\n}\r\nirqreturn_t dw_handle_msi_irq(struct pcie_port *pp)\r\n{\r\nunsigned long val;\r\nint i, pos, irq;\r\nirqreturn_t ret = IRQ_NONE;\r\nfor (i = 0; i < MAX_MSI_CTRLS; i++) {\r\ndw_pcie_rd_own_conf(pp, PCIE_MSI_INTR0_STATUS + i * 12, 4,\r\n(u32 *)&val);\r\nif (val) {\r\nret = IRQ_HANDLED;\r\npos = 0;\r\nwhile ((pos = find_next_bit(&val, 32, pos)) != 32) {\r\nirq = irq_find_mapping(pp->irq_domain,\r\ni * 32 + pos);\r\ndw_pcie_wr_own_conf(pp,\r\nPCIE_MSI_INTR0_STATUS + i * 12,\r\n4, 1 << pos);\r\ngeneric_handle_irq(irq);\r\npos++;\r\n}\r\n}\r\n}\r\nreturn ret;\r\n}\r\nvoid dw_pcie_msi_init(struct pcie_port *pp)\r\n{\r\npp->msi_data = __get_free_pages(GFP_KERNEL, 0);\r\ndw_pcie_wr_own_conf(pp, PCIE_MSI_ADDR_LO, 4,\r\nvirt_to_phys((void *)pp->msi_data));\r\ndw_pcie_wr_own_conf(pp, PCIE_MSI_ADDR_HI, 4, 0);\r\n}\r\nstatic void dw_pcie_msi_clear_irq(struct pcie_port *pp, int irq)\r\n{\r\nunsigned int res, bit, val;\r\nres = (irq / 32) * 12;\r\nbit = irq % 32;\r\ndw_pcie_rd_own_conf(pp, PCIE_MSI_INTR0_ENABLE + res, 4, &val);\r\nval &= ~(1 << bit);\r\ndw_pcie_wr_own_conf(pp, PCIE_MSI_INTR0_ENABLE + res, 4, val);\r\n}\r\nstatic void clear_irq_range(struct pcie_port *pp, unsigned int irq_base,\r\nunsigned int nvec, unsigned int pos)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < nvec; i++) {\r\nirq_set_msi_desc_off(irq_base, i, NULL);\r\nif (pp->ops->msi_clear_irq)\r\npp->ops->msi_clear_irq(pp, pos + i);\r\nelse\r\ndw_pcie_msi_clear_irq(pp, pos + i);\r\n}\r\nbitmap_release_region(pp->msi_irq_in_use, pos, order_base_2(nvec));\r\n}\r\nstatic void dw_pcie_msi_set_irq(struct pcie_port *pp, int irq)\r\n{\r\nunsigned int res, bit, val;\r\nres = (irq / 32) * 12;\r\nbit = irq % 32;\r\ndw_pcie_rd_own_conf(pp, PCIE_MSI_INTR0_ENABLE + res, 4, &val);\r\nval |= 1 << bit;\r\ndw_pcie_wr_own_conf(pp, PCIE_MSI_INTR0_ENABLE + res, 4, val);\r\n}\r\nstatic int assign_irq(int no_irqs, struct msi_desc *desc, int *pos)\r\n{\r\nint irq, pos0, i;\r\nstruct pcie_port *pp = sys_to_pcie(desc->dev->bus->sysdata);\r\npos0 = bitmap_find_free_region(pp->msi_irq_in_use, MAX_MSI_IRQS,\r\norder_base_2(no_irqs));\r\nif (pos0 < 0)\r\ngoto no_valid_irq;\r\nirq = irq_find_mapping(pp->irq_domain, pos0);\r\nif (!irq)\r\ngoto no_valid_irq;\r\nfor (i = 0; i < no_irqs; i++) {\r\nif (irq_set_msi_desc_off(irq, i, desc) != 0) {\r\nclear_irq_range(pp, irq, i, pos0);\r\ngoto no_valid_irq;\r\n}\r\nif (pp->ops->msi_set_irq)\r\npp->ops->msi_set_irq(pp, pos0 + i);\r\nelse\r\ndw_pcie_msi_set_irq(pp, pos0 + i);\r\n}\r\n*pos = pos0;\r\nreturn irq;\r\nno_valid_irq:\r\n*pos = pos0;\r\nreturn -ENOSPC;\r\n}\r\nstatic int dw_msi_setup_irq(struct msi_controller *chip, struct pci_dev *pdev,\r\nstruct msi_desc *desc)\r\n{\r\nint irq, pos;\r\nstruct msi_msg msg;\r\nstruct pcie_port *pp = sys_to_pcie(pdev->bus->sysdata);\r\nif (desc->msi_attrib.is_msix)\r\nreturn -EINVAL;\r\nirq = assign_irq(1, desc, &pos);\r\nif (irq < 0)\r\nreturn irq;\r\nif (pp->ops->get_msi_addr)\r\nmsg.address_lo = pp->ops->get_msi_addr(pp);\r\nelse\r\nmsg.address_lo = virt_to_phys((void *)pp->msi_data);\r\nmsg.address_hi = 0x0;\r\nif (pp->ops->get_msi_data)\r\nmsg.data = pp->ops->get_msi_data(pp, pos);\r\nelse\r\nmsg.data = pos;\r\npci_write_msi_msg(irq, &msg);\r\nreturn 0;\r\n}\r\nstatic void dw_msi_teardown_irq(struct msi_controller *chip, unsigned int irq)\r\n{\r\nstruct irq_data *data = irq_get_irq_data(irq);\r\nstruct msi_desc *msi = irq_data_get_msi(data);\r\nstruct pcie_port *pp = sys_to_pcie(msi->dev->bus->sysdata);\r\nclear_irq_range(pp, irq, 1, data->hwirq);\r\n}\r\nint dw_pcie_link_up(struct pcie_port *pp)\r\n{\r\nif (pp->ops->link_up)\r\nreturn pp->ops->link_up(pp);\r\nelse\r\nreturn 0;\r\n}\r\nstatic int dw_pcie_msi_map(struct irq_domain *domain, unsigned int irq,\r\nirq_hw_number_t hwirq)\r\n{\r\nirq_set_chip_and_handler(irq, &dw_msi_irq_chip, handle_simple_irq);\r\nirq_set_chip_data(irq, domain->host_data);\r\nset_irq_flags(irq, IRQF_VALID);\r\nreturn 0;\r\n}\r\nint dw_pcie_host_init(struct pcie_port *pp)\r\n{\r\nstruct device_node *np = pp->dev->of_node;\r\nstruct platform_device *pdev = to_platform_device(pp->dev);\r\nstruct of_pci_range range;\r\nstruct of_pci_range_parser parser;\r\nstruct resource *cfg_res;\r\nu32 val, na, ns;\r\nconst __be32 *addrp;\r\nint i, index, ret;\r\nof_property_read_u32(np, "#address-cells", &na);\r\nns = of_n_size_cells(np);\r\ncfg_res = platform_get_resource_byname(pdev, IORESOURCE_MEM, "config");\r\nif (cfg_res) {\r\npp->cfg0_size = resource_size(cfg_res)/2;\r\npp->cfg1_size = resource_size(cfg_res)/2;\r\npp->cfg0_base = cfg_res->start;\r\npp->cfg1_base = cfg_res->start + pp->cfg0_size;\r\nindex = of_property_match_string(np, "reg-names", "config");\r\naddrp = of_get_address(np, index, NULL, NULL);\r\npp->cfg0_mod_base = of_read_number(addrp, ns);\r\npp->cfg1_mod_base = pp->cfg0_mod_base + pp->cfg0_size;\r\n} else {\r\ndev_err(pp->dev, "missing *config* reg space\n");\r\n}\r\nif (of_pci_range_parser_init(&parser, np)) {\r\ndev_err(pp->dev, "missing ranges property\n");\r\nreturn -EINVAL;\r\n}\r\nfor_each_of_pci_range(&parser, &range) {\r\nunsigned long restype = range.flags & IORESOURCE_TYPE_BITS;\r\nif (restype == IORESOURCE_IO) {\r\nof_pci_range_to_resource(&range, np, &pp->io);\r\npp->io.name = "I/O";\r\npp->io.start = max_t(resource_size_t,\r\nPCIBIOS_MIN_IO,\r\nrange.pci_addr + global_io_offset);\r\npp->io.end = min_t(resource_size_t,\r\nIO_SPACE_LIMIT,\r\nrange.pci_addr + range.size\r\n+ global_io_offset - 1);\r\npp->io_size = resource_size(&pp->io);\r\npp->io_bus_addr = range.pci_addr;\r\npp->io_base = range.cpu_addr;\r\npp->io_mod_base = of_read_number(parser.range -\r\nparser.np + na, ns);\r\n}\r\nif (restype == IORESOURCE_MEM) {\r\nof_pci_range_to_resource(&range, np, &pp->mem);\r\npp->mem.name = "MEM";\r\npp->mem_size = resource_size(&pp->mem);\r\npp->mem_bus_addr = range.pci_addr;\r\npp->mem_mod_base = of_read_number(parser.range -\r\nparser.np + na, ns);\r\n}\r\nif (restype == 0) {\r\nof_pci_range_to_resource(&range, np, &pp->cfg);\r\npp->cfg0_size = resource_size(&pp->cfg)/2;\r\npp->cfg1_size = resource_size(&pp->cfg)/2;\r\npp->cfg0_base = pp->cfg.start;\r\npp->cfg1_base = pp->cfg.start + pp->cfg0_size;\r\npp->cfg0_mod_base = of_read_number(parser.range -\r\nparser.np + na, ns);\r\npp->cfg1_mod_base = pp->cfg0_mod_base +\r\npp->cfg0_size;\r\n}\r\n}\r\nret = of_pci_parse_bus_range(np, &pp->busn);\r\nif (ret < 0) {\r\npp->busn.name = np->name;\r\npp->busn.start = 0;\r\npp->busn.end = 0xff;\r\npp->busn.flags = IORESOURCE_BUS;\r\ndev_dbg(pp->dev, "failed to parse bus-range property: %d, using default %pR\n",\r\nret, &pp->busn);\r\n}\r\nif (!pp->dbi_base) {\r\npp->dbi_base = devm_ioremap(pp->dev, pp->cfg.start,\r\nresource_size(&pp->cfg));\r\nif (!pp->dbi_base) {\r\ndev_err(pp->dev, "error with ioremap\n");\r\nreturn -ENOMEM;\r\n}\r\n}\r\npp->mem_base = pp->mem.start;\r\nif (!pp->va_cfg0_base) {\r\npp->va_cfg0_base = devm_ioremap(pp->dev, pp->cfg0_base,\r\npp->cfg0_size);\r\nif (!pp->va_cfg0_base) {\r\ndev_err(pp->dev, "error with ioremap in function\n");\r\nreturn -ENOMEM;\r\n}\r\n}\r\nif (!pp->va_cfg1_base) {\r\npp->va_cfg1_base = devm_ioremap(pp->dev, pp->cfg1_base,\r\npp->cfg1_size);\r\nif (!pp->va_cfg1_base) {\r\ndev_err(pp->dev, "error with ioremap\n");\r\nreturn -ENOMEM;\r\n}\r\n}\r\nif (of_property_read_u32(np, "num-lanes", &pp->lanes)) {\r\ndev_err(pp->dev, "Failed to parse the number of lanes\n");\r\nreturn -EINVAL;\r\n}\r\nif (IS_ENABLED(CONFIG_PCI_MSI)) {\r\nif (!pp->ops->msi_host_init) {\r\npp->irq_domain = irq_domain_add_linear(pp->dev->of_node,\r\nMAX_MSI_IRQS, &msi_domain_ops,\r\n&dw_pcie_msi_chip);\r\nif (!pp->irq_domain) {\r\ndev_err(pp->dev, "irq domain init failed\n");\r\nreturn -ENXIO;\r\n}\r\nfor (i = 0; i < MAX_MSI_IRQS; i++)\r\nirq_create_mapping(pp->irq_domain, i);\r\n} else {\r\nret = pp->ops->msi_host_init(pp, &dw_pcie_msi_chip);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\n}\r\nif (pp->ops->host_init)\r\npp->ops->host_init(pp);\r\ndw_pcie_wr_own_conf(pp, PCI_BASE_ADDRESS_0, 4, 0);\r\ndw_pcie_wr_own_conf(pp, PCI_CLASS_DEVICE, 2, PCI_CLASS_BRIDGE_PCI);\r\ndw_pcie_rd_own_conf(pp, PCIE_LINK_WIDTH_SPEED_CONTROL, 4, &val);\r\nval |= PORT_LOGIC_SPEED_CHANGE;\r\ndw_pcie_wr_own_conf(pp, PCIE_LINK_WIDTH_SPEED_CONTROL, 4, val);\r\n#ifdef CONFIG_PCI_MSI\r\ndw_pcie_msi_chip.dev = pp->dev;\r\ndw_pci.msi_ctrl = &dw_pcie_msi_chip;\r\n#endif\r\ndw_pci.nr_controllers = 1;\r\ndw_pci.private_data = (void **)&pp;\r\npci_common_init_dev(pp->dev, &dw_pci);\r\nreturn 0;\r\n}\r\nstatic void dw_pcie_prog_viewport_cfg0(struct pcie_port *pp, u32 busdev)\r\n{\r\ndw_pcie_writel_rc(pp, PCIE_ATU_REGION_OUTBOUND | PCIE_ATU_REGION_INDEX0,\r\nPCIE_ATU_VIEWPORT);\r\ndw_pcie_writel_rc(pp, pp->cfg0_mod_base, PCIE_ATU_LOWER_BASE);\r\ndw_pcie_writel_rc(pp, (pp->cfg0_mod_base >> 32), PCIE_ATU_UPPER_BASE);\r\ndw_pcie_writel_rc(pp, pp->cfg0_mod_base + pp->cfg0_size - 1,\r\nPCIE_ATU_LIMIT);\r\ndw_pcie_writel_rc(pp, busdev, PCIE_ATU_LOWER_TARGET);\r\ndw_pcie_writel_rc(pp, 0, PCIE_ATU_UPPER_TARGET);\r\ndw_pcie_writel_rc(pp, PCIE_ATU_TYPE_CFG0, PCIE_ATU_CR1);\r\ndw_pcie_writel_rc(pp, PCIE_ATU_ENABLE, PCIE_ATU_CR2);\r\n}\r\nstatic void dw_pcie_prog_viewport_cfg1(struct pcie_port *pp, u32 busdev)\r\n{\r\ndw_pcie_writel_rc(pp, PCIE_ATU_REGION_OUTBOUND | PCIE_ATU_REGION_INDEX1,\r\nPCIE_ATU_VIEWPORT);\r\ndw_pcie_writel_rc(pp, PCIE_ATU_TYPE_CFG1, PCIE_ATU_CR1);\r\ndw_pcie_writel_rc(pp, pp->cfg1_mod_base, PCIE_ATU_LOWER_BASE);\r\ndw_pcie_writel_rc(pp, (pp->cfg1_mod_base >> 32), PCIE_ATU_UPPER_BASE);\r\ndw_pcie_writel_rc(pp, pp->cfg1_mod_base + pp->cfg1_size - 1,\r\nPCIE_ATU_LIMIT);\r\ndw_pcie_writel_rc(pp, busdev, PCIE_ATU_LOWER_TARGET);\r\ndw_pcie_writel_rc(pp, 0, PCIE_ATU_UPPER_TARGET);\r\ndw_pcie_writel_rc(pp, PCIE_ATU_ENABLE, PCIE_ATU_CR2);\r\n}\r\nstatic void dw_pcie_prog_viewport_mem_outbound(struct pcie_port *pp)\r\n{\r\ndw_pcie_writel_rc(pp, PCIE_ATU_REGION_OUTBOUND | PCIE_ATU_REGION_INDEX0,\r\nPCIE_ATU_VIEWPORT);\r\ndw_pcie_writel_rc(pp, PCIE_ATU_TYPE_MEM, PCIE_ATU_CR1);\r\ndw_pcie_writel_rc(pp, pp->mem_mod_base, PCIE_ATU_LOWER_BASE);\r\ndw_pcie_writel_rc(pp, (pp->mem_mod_base >> 32), PCIE_ATU_UPPER_BASE);\r\ndw_pcie_writel_rc(pp, pp->mem_mod_base + pp->mem_size - 1,\r\nPCIE_ATU_LIMIT);\r\ndw_pcie_writel_rc(pp, pp->mem_bus_addr, PCIE_ATU_LOWER_TARGET);\r\ndw_pcie_writel_rc(pp, upper_32_bits(pp->mem_bus_addr),\r\nPCIE_ATU_UPPER_TARGET);\r\ndw_pcie_writel_rc(pp, PCIE_ATU_ENABLE, PCIE_ATU_CR2);\r\n}\r\nstatic void dw_pcie_prog_viewport_io_outbound(struct pcie_port *pp)\r\n{\r\ndw_pcie_writel_rc(pp, PCIE_ATU_REGION_OUTBOUND | PCIE_ATU_REGION_INDEX1,\r\nPCIE_ATU_VIEWPORT);\r\ndw_pcie_writel_rc(pp, PCIE_ATU_TYPE_IO, PCIE_ATU_CR1);\r\ndw_pcie_writel_rc(pp, pp->io_mod_base, PCIE_ATU_LOWER_BASE);\r\ndw_pcie_writel_rc(pp, (pp->io_mod_base >> 32), PCIE_ATU_UPPER_BASE);\r\ndw_pcie_writel_rc(pp, pp->io_mod_base + pp->io_size - 1,\r\nPCIE_ATU_LIMIT);\r\ndw_pcie_writel_rc(pp, pp->io_bus_addr, PCIE_ATU_LOWER_TARGET);\r\ndw_pcie_writel_rc(pp, upper_32_bits(pp->io_bus_addr),\r\nPCIE_ATU_UPPER_TARGET);\r\ndw_pcie_writel_rc(pp, PCIE_ATU_ENABLE, PCIE_ATU_CR2);\r\n}\r\nstatic int dw_pcie_rd_other_conf(struct pcie_port *pp, struct pci_bus *bus,\r\nu32 devfn, int where, int size, u32 *val)\r\n{\r\nint ret = PCIBIOS_SUCCESSFUL;\r\nu32 address, busdev;\r\nbusdev = PCIE_ATU_BUS(bus->number) | PCIE_ATU_DEV(PCI_SLOT(devfn)) |\r\nPCIE_ATU_FUNC(PCI_FUNC(devfn));\r\naddress = where & ~0x3;\r\nif (bus->parent->number == pp->root_bus_nr) {\r\ndw_pcie_prog_viewport_cfg0(pp, busdev);\r\nret = dw_pcie_cfg_read(pp->va_cfg0_base + address, where, size,\r\nval);\r\ndw_pcie_prog_viewport_mem_outbound(pp);\r\n} else {\r\ndw_pcie_prog_viewport_cfg1(pp, busdev);\r\nret = dw_pcie_cfg_read(pp->va_cfg1_base + address, where, size,\r\nval);\r\ndw_pcie_prog_viewport_io_outbound(pp);\r\n}\r\nreturn ret;\r\n}\r\nstatic int dw_pcie_wr_other_conf(struct pcie_port *pp, struct pci_bus *bus,\r\nu32 devfn, int where, int size, u32 val)\r\n{\r\nint ret = PCIBIOS_SUCCESSFUL;\r\nu32 address, busdev;\r\nbusdev = PCIE_ATU_BUS(bus->number) | PCIE_ATU_DEV(PCI_SLOT(devfn)) |\r\nPCIE_ATU_FUNC(PCI_FUNC(devfn));\r\naddress = where & ~0x3;\r\nif (bus->parent->number == pp->root_bus_nr) {\r\ndw_pcie_prog_viewport_cfg0(pp, busdev);\r\nret = dw_pcie_cfg_write(pp->va_cfg0_base + address, where, size,\r\nval);\r\ndw_pcie_prog_viewport_mem_outbound(pp);\r\n} else {\r\ndw_pcie_prog_viewport_cfg1(pp, busdev);\r\nret = dw_pcie_cfg_write(pp->va_cfg1_base + address, where, size,\r\nval);\r\ndw_pcie_prog_viewport_io_outbound(pp);\r\n}\r\nreturn ret;\r\n}\r\nstatic int dw_pcie_valid_config(struct pcie_port *pp,\r\nstruct pci_bus *bus, int dev)\r\n{\r\nif (bus->number != pp->root_bus_nr) {\r\nif (!dw_pcie_link_up(pp))\r\nreturn 0;\r\n}\r\nif (bus->number == pp->root_bus_nr && dev > 0)\r\nreturn 0;\r\nif (bus->primary == pp->root_bus_nr && dev > 0)\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic int dw_pcie_rd_conf(struct pci_bus *bus, u32 devfn, int where,\r\nint size, u32 *val)\r\n{\r\nstruct pcie_port *pp = sys_to_pcie(bus->sysdata);\r\nint ret;\r\nif (dw_pcie_valid_config(pp, bus, PCI_SLOT(devfn)) == 0) {\r\n*val = 0xffffffff;\r\nreturn PCIBIOS_DEVICE_NOT_FOUND;\r\n}\r\nif (bus->number != pp->root_bus_nr)\r\nif (pp->ops->rd_other_conf)\r\nret = pp->ops->rd_other_conf(pp, bus, devfn,\r\nwhere, size, val);\r\nelse\r\nret = dw_pcie_rd_other_conf(pp, bus, devfn,\r\nwhere, size, val);\r\nelse\r\nret = dw_pcie_rd_own_conf(pp, where, size, val);\r\nreturn ret;\r\n}\r\nstatic int dw_pcie_wr_conf(struct pci_bus *bus, u32 devfn,\r\nint where, int size, u32 val)\r\n{\r\nstruct pcie_port *pp = sys_to_pcie(bus->sysdata);\r\nint ret;\r\nif (dw_pcie_valid_config(pp, bus, PCI_SLOT(devfn)) == 0)\r\nreturn PCIBIOS_DEVICE_NOT_FOUND;\r\nif (bus->number != pp->root_bus_nr)\r\nif (pp->ops->wr_other_conf)\r\nret = pp->ops->wr_other_conf(pp, bus, devfn,\r\nwhere, size, val);\r\nelse\r\nret = dw_pcie_wr_other_conf(pp, bus, devfn,\r\nwhere, size, val);\r\nelse\r\nret = dw_pcie_wr_own_conf(pp, where, size, val);\r\nreturn ret;\r\n}\r\nstatic int dw_pcie_setup(int nr, struct pci_sys_data *sys)\r\n{\r\nstruct pcie_port *pp;\r\npp = sys_to_pcie(sys);\r\nif (global_io_offset < SZ_1M && pp->io_size > 0) {\r\nsys->io_offset = global_io_offset - pp->io_bus_addr;\r\npci_ioremap_io(global_io_offset, pp->io_base);\r\nglobal_io_offset += SZ_64K;\r\npci_add_resource_offset(&sys->resources, &pp->io,\r\nsys->io_offset);\r\n}\r\nsys->mem_offset = pp->mem.start - pp->mem_bus_addr;\r\npci_add_resource_offset(&sys->resources, &pp->mem, sys->mem_offset);\r\npci_add_resource(&sys->resources, &pp->busn);\r\nreturn 1;\r\n}\r\nstatic struct pci_bus *dw_pcie_scan_bus(int nr, struct pci_sys_data *sys)\r\n{\r\nstruct pci_bus *bus;\r\nstruct pcie_port *pp = sys_to_pcie(sys);\r\npp->root_bus_nr = sys->busnr;\r\nbus = pci_create_root_bus(pp->dev, sys->busnr,\r\n&dw_pcie_ops, sys, &sys->resources);\r\nif (!bus)\r\nreturn NULL;\r\npci_scan_child_bus(bus);\r\nif (bus && pp->ops->scan_bus)\r\npp->ops->scan_bus(pp);\r\nreturn bus;\r\n}\r\nstatic int dw_pcie_map_irq(const struct pci_dev *dev, u8 slot, u8 pin)\r\n{\r\nstruct pcie_port *pp = sys_to_pcie(dev->bus->sysdata);\r\nint irq;\r\nirq = of_irq_parse_and_map_pci(dev, slot, pin);\r\nif (!irq)\r\nirq = pp->irq;\r\nreturn irq;\r\n}\r\nvoid dw_pcie_setup_rc(struct pcie_port *pp)\r\n{\r\nu32 val;\r\nu32 membase;\r\nu32 memlimit;\r\ndw_pcie_readl_rc(pp, PCIE_PORT_LINK_CONTROL, &val);\r\nval &= ~PORT_LINK_MODE_MASK;\r\nswitch (pp->lanes) {\r\ncase 1:\r\nval |= PORT_LINK_MODE_1_LANES;\r\nbreak;\r\ncase 2:\r\nval |= PORT_LINK_MODE_2_LANES;\r\nbreak;\r\ncase 4:\r\nval |= PORT_LINK_MODE_4_LANES;\r\nbreak;\r\n}\r\ndw_pcie_writel_rc(pp, val, PCIE_PORT_LINK_CONTROL);\r\ndw_pcie_readl_rc(pp, PCIE_LINK_WIDTH_SPEED_CONTROL, &val);\r\nval &= ~PORT_LOGIC_LINK_WIDTH_MASK;\r\nswitch (pp->lanes) {\r\ncase 1:\r\nval |= PORT_LOGIC_LINK_WIDTH_1_LANES;\r\nbreak;\r\ncase 2:\r\nval |= PORT_LOGIC_LINK_WIDTH_2_LANES;\r\nbreak;\r\ncase 4:\r\nval |= PORT_LOGIC_LINK_WIDTH_4_LANES;\r\nbreak;\r\n}\r\ndw_pcie_writel_rc(pp, val, PCIE_LINK_WIDTH_SPEED_CONTROL);\r\ndw_pcie_writel_rc(pp, 0x00000004, PCI_BASE_ADDRESS_0);\r\ndw_pcie_writel_rc(pp, 0x00000000, PCI_BASE_ADDRESS_1);\r\ndw_pcie_readl_rc(pp, PCI_INTERRUPT_LINE, &val);\r\nval &= 0xffff00ff;\r\nval |= 0x00000100;\r\ndw_pcie_writel_rc(pp, val, PCI_INTERRUPT_LINE);\r\ndw_pcie_readl_rc(pp, PCI_PRIMARY_BUS, &val);\r\nval &= 0xff000000;\r\nval |= 0x00010100;\r\ndw_pcie_writel_rc(pp, val, PCI_PRIMARY_BUS);\r\nmembase = ((u32)pp->mem_base & 0xfff00000) >> 16;\r\nmemlimit = (pp->mem_size + (u32)pp->mem_base) & 0xfff00000;\r\nval = memlimit | membase;\r\ndw_pcie_writel_rc(pp, val, PCI_MEMORY_BASE);\r\ndw_pcie_readl_rc(pp, PCI_COMMAND, &val);\r\nval &= 0xffff0000;\r\nval |= PCI_COMMAND_IO | PCI_COMMAND_MEMORY |\r\nPCI_COMMAND_MASTER | PCI_COMMAND_SERR;\r\ndw_pcie_writel_rc(pp, val, PCI_COMMAND);\r\n}
