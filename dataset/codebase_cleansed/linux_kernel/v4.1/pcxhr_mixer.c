static int pcxhr_update_analog_audio_level(struct snd_pcxhr *chip,\r\nint is_capture, int channel)\r\n{\r\nint err, vol;\r\nstruct pcxhr_rmh rmh;\r\npcxhr_init_rmh(&rmh, CMD_ACCESS_IO_WRITE);\r\nif (is_capture) {\r\nrmh.cmd[0] |= IO_NUM_REG_IN_ANA_LEVEL;\r\nrmh.cmd[2] = chip->analog_capture_volume[channel];\r\n} else {\r\nrmh.cmd[0] |= IO_NUM_REG_OUT_ANA_LEVEL;\r\nif (chip->analog_playback_active[channel])\r\nvol = chip->analog_playback_volume[channel];\r\nelse\r\nvol = PCXHR_LINE_PLAYBACK_LEVEL_MIN;\r\nrmh.cmd[2] = PCXHR_LINE_PLAYBACK_LEVEL_MAX - vol;\r\n}\r\nrmh.cmd[1] = 1 << ((2 * chip->chip_idx) + channel);\r\nrmh.cmd_len = 3;\r\nerr = pcxhr_send_msg(chip->mgr, &rmh);\r\nif (err < 0) {\r\ndev_dbg(chip->card->dev,\r\n"error update_analog_audio_level card(%d)"\r\n" is_capture(%d) err(%x)\n",\r\nchip->chip_idx, is_capture, err);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int pcxhr_analog_vol_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nstruct snd_pcxhr *chip = snd_kcontrol_chip(kcontrol);\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\r\nuinfo->count = 2;\r\nif (kcontrol->private_value == 0) {\r\nif (chip->mgr->is_hr_stereo) {\r\nuinfo->value.integer.min =\r\nHR222_LINE_PLAYBACK_LEVEL_MIN;\r\nuinfo->value.integer.max =\r\nHR222_LINE_PLAYBACK_LEVEL_MAX;\r\n} else {\r\nuinfo->value.integer.min =\r\nPCXHR_LINE_PLAYBACK_LEVEL_MIN;\r\nuinfo->value.integer.max =\r\nPCXHR_LINE_PLAYBACK_LEVEL_MAX;\r\n}\r\n} else {\r\nif (chip->mgr->is_hr_stereo) {\r\nuinfo->value.integer.min =\r\nHR222_LINE_CAPTURE_LEVEL_MIN;\r\nuinfo->value.integer.max =\r\nHR222_LINE_CAPTURE_LEVEL_MAX;\r\n} else {\r\nuinfo->value.integer.min =\r\nPCXHR_LINE_CAPTURE_LEVEL_MIN;\r\nuinfo->value.integer.max =\r\nPCXHR_LINE_CAPTURE_LEVEL_MAX;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int pcxhr_analog_vol_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_pcxhr *chip = snd_kcontrol_chip(kcontrol);\r\nmutex_lock(&chip->mgr->mixer_mutex);\r\nif (kcontrol->private_value == 0) {\r\nucontrol->value.integer.value[0] = chip->analog_playback_volume[0];\r\nucontrol->value.integer.value[1] = chip->analog_playback_volume[1];\r\n} else {\r\nucontrol->value.integer.value[0] = chip->analog_capture_volume[0];\r\nucontrol->value.integer.value[1] = chip->analog_capture_volume[1];\r\n}\r\nmutex_unlock(&chip->mgr->mixer_mutex);\r\nreturn 0;\r\n}\r\nstatic int pcxhr_analog_vol_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_pcxhr *chip = snd_kcontrol_chip(kcontrol);\r\nint changed = 0;\r\nint is_capture, i;\r\nmutex_lock(&chip->mgr->mixer_mutex);\r\nis_capture = (kcontrol->private_value != 0);\r\nfor (i = 0; i < 2; i++) {\r\nint new_volume = ucontrol->value.integer.value[i];\r\nint *stored_volume = is_capture ?\r\n&chip->analog_capture_volume[i] :\r\n&chip->analog_playback_volume[i];\r\nif (is_capture) {\r\nif (chip->mgr->is_hr_stereo) {\r\nif (new_volume < HR222_LINE_CAPTURE_LEVEL_MIN ||\r\nnew_volume > HR222_LINE_CAPTURE_LEVEL_MAX)\r\ncontinue;\r\n} else {\r\nif (new_volume < PCXHR_LINE_CAPTURE_LEVEL_MIN ||\r\nnew_volume > PCXHR_LINE_CAPTURE_LEVEL_MAX)\r\ncontinue;\r\n}\r\n} else {\r\nif (chip->mgr->is_hr_stereo) {\r\nif (new_volume < HR222_LINE_PLAYBACK_LEVEL_MIN ||\r\nnew_volume > HR222_LINE_PLAYBACK_LEVEL_MAX)\r\ncontinue;\r\n} else {\r\nif (new_volume < PCXHR_LINE_PLAYBACK_LEVEL_MIN ||\r\nnew_volume > PCXHR_LINE_PLAYBACK_LEVEL_MAX)\r\ncontinue;\r\n}\r\n}\r\nif (*stored_volume != new_volume) {\r\n*stored_volume = new_volume;\r\nchanged = 1;\r\nif (chip->mgr->is_hr_stereo)\r\nhr222_update_analog_audio_level(chip,\r\nis_capture, i);\r\nelse\r\npcxhr_update_analog_audio_level(chip,\r\nis_capture, i);\r\n}\r\n}\r\nmutex_unlock(&chip->mgr->mixer_mutex);\r\nreturn changed;\r\n}\r\nstatic int pcxhr_audio_sw_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_pcxhr *chip = snd_kcontrol_chip(kcontrol);\r\nmutex_lock(&chip->mgr->mixer_mutex);\r\nucontrol->value.integer.value[0] = chip->analog_playback_active[0];\r\nucontrol->value.integer.value[1] = chip->analog_playback_active[1];\r\nmutex_unlock(&chip->mgr->mixer_mutex);\r\nreturn 0;\r\n}\r\nstatic int pcxhr_audio_sw_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_pcxhr *chip = snd_kcontrol_chip(kcontrol);\r\nint i, changed = 0;\r\nmutex_lock(&chip->mgr->mixer_mutex);\r\nfor(i = 0; i < 2; i++) {\r\nif (chip->analog_playback_active[i] !=\r\nucontrol->value.integer.value[i]) {\r\nchip->analog_playback_active[i] =\r\n!!ucontrol->value.integer.value[i];\r\nchanged = 1;\r\nif (chip->mgr->is_hr_stereo)\r\nhr222_update_analog_audio_level(chip, 0, i);\r\nelse\r\npcxhr_update_analog_audio_level(chip, 0, i);\r\n}\r\n}\r\nmutex_unlock(&chip->mgr->mixer_mutex);\r\nreturn changed;\r\n}\r\nstatic int pcxhr_update_playback_stream_level(struct snd_pcxhr* chip, int idx)\r\n{\r\nint err;\r\nstruct pcxhr_rmh rmh;\r\nstruct pcxhr_pipe *pipe = &chip->playback_pipe;\r\nint left, right;\r\nif (chip->digital_playback_active[idx][0])\r\nleft = chip->digital_playback_volume[idx][0];\r\nelse\r\nleft = PCXHR_DIGITAL_LEVEL_MIN;\r\nif (chip->digital_playback_active[idx][1])\r\nright = chip->digital_playback_volume[idx][1];\r\nelse\r\nright = PCXHR_DIGITAL_LEVEL_MIN;\r\npcxhr_init_rmh(&rmh, CMD_STREAM_OUT_LEVEL_ADJUST);\r\npcxhr_set_pipe_cmd_params(&rmh, 0, pipe->first_audio, 0, 1<<idx);\r\nrmh.cmd[0] |= MORE_THAN_ONE_STREAM_LEVEL;\r\nrmh.cmd[2] = VALID_STREAM_PAN_LEVEL_MASK | VALID_STREAM_LEVEL_1_MASK;\r\nrmh.cmd[2] |= (left << 10);\r\nrmh.cmd[3] = VALID_STREAM_PAN_LEVEL_MASK | VALID_STREAM_LEVEL_2_MASK;\r\nrmh.cmd[3] |= right;\r\nrmh.cmd_len = 4;\r\nerr = pcxhr_send_msg(chip->mgr, &rmh);\r\nif (err < 0) {\r\ndev_dbg(chip->card->dev, "error update_playback_stream_level "\r\n"card(%d) err(%x)\n", chip->chip_idx, err);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int pcxhr_update_audio_pipe_level(struct snd_pcxhr *chip,\r\nint capture, int channel)\r\n{\r\nint err;\r\nstruct pcxhr_rmh rmh;\r\nstruct pcxhr_pipe *pipe;\r\nif (capture)\r\npipe = &chip->capture_pipe[0];\r\nelse\r\npipe = &chip->playback_pipe;\r\npcxhr_init_rmh(&rmh, CMD_AUDIO_LEVEL_ADJUST);\r\npcxhr_set_pipe_cmd_params(&rmh, capture, 0, 0,\r\n1 << (channel + pipe->first_audio));\r\nif (capture) {\r\nrmh.cmd[0] |= VALID_AUDIO_IO_DIGITAL_LEVEL;\r\nrmh.cmd[2] = chip->digital_capture_volume[channel];\r\n} else {\r\nrmh.cmd[0] |= VALID_AUDIO_IO_MONITOR_LEVEL |\r\nVALID_AUDIO_IO_MUTE_MONITOR_1;\r\nrmh.cmd[2] = chip->monitoring_volume[channel] << 10;\r\nif (chip->monitoring_active[channel] == 0)\r\nrmh.cmd[2] |= AUDIO_IO_HAS_MUTE_MONITOR_1;\r\n}\r\nrmh.cmd_len = 3;\r\nerr = pcxhr_send_msg(chip->mgr, &rmh);\r\nif (err < 0) {\r\ndev_dbg(chip->card->dev,\r\n"error update_audio_level(%d) err=%x\n",\r\nchip->chip_idx, err);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int pcxhr_digital_vol_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\r\nuinfo->count = 2;\r\nuinfo->value.integer.min = PCXHR_DIGITAL_LEVEL_MIN;\r\nuinfo->value.integer.max = PCXHR_DIGITAL_LEVEL_MAX;\r\nreturn 0;\r\n}\r\nstatic int pcxhr_pcm_vol_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_pcxhr *chip = snd_kcontrol_chip(kcontrol);\r\nint idx = snd_ctl_get_ioffidx(kcontrol, &ucontrol->id);\r\nint *stored_volume;\r\nint is_capture = kcontrol->private_value;\r\nmutex_lock(&chip->mgr->mixer_mutex);\r\nif (is_capture)\r\nstored_volume = chip->digital_capture_volume;\r\nelse\r\nstored_volume = chip->digital_playback_volume[idx];\r\nucontrol->value.integer.value[0] = stored_volume[0];\r\nucontrol->value.integer.value[1] = stored_volume[1];\r\nmutex_unlock(&chip->mgr->mixer_mutex);\r\nreturn 0;\r\n}\r\nstatic int pcxhr_pcm_vol_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_pcxhr *chip = snd_kcontrol_chip(kcontrol);\r\nint idx = snd_ctl_get_ioffidx(kcontrol, &ucontrol->id);\r\nint changed = 0;\r\nint is_capture = kcontrol->private_value;\r\nint *stored_volume;\r\nint i;\r\nmutex_lock(&chip->mgr->mixer_mutex);\r\nif (is_capture)\r\nstored_volume = chip->digital_capture_volume;\r\nelse\r\nstored_volume = chip->digital_playback_volume[idx];\r\nfor (i = 0; i < 2; i++) {\r\nint vol = ucontrol->value.integer.value[i];\r\nif (vol < PCXHR_DIGITAL_LEVEL_MIN ||\r\nvol > PCXHR_DIGITAL_LEVEL_MAX)\r\ncontinue;\r\nif (stored_volume[i] != vol) {\r\nstored_volume[i] = vol;\r\nchanged = 1;\r\nif (is_capture)\r\npcxhr_update_audio_pipe_level(chip, 1, i);\r\n}\r\n}\r\nif (!is_capture && changed)\r\npcxhr_update_playback_stream_level(chip, idx);\r\nmutex_unlock(&chip->mgr->mixer_mutex);\r\nreturn changed;\r\n}\r\nstatic int pcxhr_pcm_sw_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_pcxhr *chip = snd_kcontrol_chip(kcontrol);\r\nint idx = snd_ctl_get_ioffidx(kcontrol, &ucontrol->id);\r\nmutex_lock(&chip->mgr->mixer_mutex);\r\nucontrol->value.integer.value[0] = chip->digital_playback_active[idx][0];\r\nucontrol->value.integer.value[1] = chip->digital_playback_active[idx][1];\r\nmutex_unlock(&chip->mgr->mixer_mutex);\r\nreturn 0;\r\n}\r\nstatic int pcxhr_pcm_sw_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_pcxhr *chip = snd_kcontrol_chip(kcontrol);\r\nint changed = 0;\r\nint idx = snd_ctl_get_ioffidx(kcontrol, &ucontrol->id);\r\nint i, j;\r\nmutex_lock(&chip->mgr->mixer_mutex);\r\nj = idx;\r\nfor (i = 0; i < 2; i++) {\r\nif (chip->digital_playback_active[j][i] !=\r\nucontrol->value.integer.value[i]) {\r\nchip->digital_playback_active[j][i] =\r\n!!ucontrol->value.integer.value[i];\r\nchanged = 1;\r\n}\r\n}\r\nif (changed)\r\npcxhr_update_playback_stream_level(chip, idx);\r\nmutex_unlock(&chip->mgr->mixer_mutex);\r\nreturn changed;\r\n}\r\nstatic int pcxhr_monitor_vol_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_pcxhr *chip = snd_kcontrol_chip(kcontrol);\r\nmutex_lock(&chip->mgr->mixer_mutex);\r\nucontrol->value.integer.value[0] = chip->monitoring_volume[0];\r\nucontrol->value.integer.value[1] = chip->monitoring_volume[1];\r\nmutex_unlock(&chip->mgr->mixer_mutex);\r\nreturn 0;\r\n}\r\nstatic int pcxhr_monitor_vol_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_pcxhr *chip = snd_kcontrol_chip(kcontrol);\r\nint changed = 0;\r\nint i;\r\nmutex_lock(&chip->mgr->mixer_mutex);\r\nfor (i = 0; i < 2; i++) {\r\nif (chip->monitoring_volume[i] !=\r\nucontrol->value.integer.value[i]) {\r\nchip->monitoring_volume[i] =\r\nucontrol->value.integer.value[i];\r\nif (chip->monitoring_active[i])\r\npcxhr_update_audio_pipe_level(chip, 0, i);\r\nchanged = 1;\r\n}\r\n}\r\nmutex_unlock(&chip->mgr->mixer_mutex);\r\nreturn changed;\r\n}\r\nstatic int pcxhr_monitor_sw_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_pcxhr *chip = snd_kcontrol_chip(kcontrol);\r\nmutex_lock(&chip->mgr->mixer_mutex);\r\nucontrol->value.integer.value[0] = chip->monitoring_active[0];\r\nucontrol->value.integer.value[1] = chip->monitoring_active[1];\r\nmutex_unlock(&chip->mgr->mixer_mutex);\r\nreturn 0;\r\n}\r\nstatic int pcxhr_monitor_sw_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_pcxhr *chip = snd_kcontrol_chip(kcontrol);\r\nint changed = 0;\r\nint i;\r\nmutex_lock(&chip->mgr->mixer_mutex);\r\nfor (i = 0; i < 2; i++) {\r\nif (chip->monitoring_active[i] !=\r\nucontrol->value.integer.value[i]) {\r\nchip->monitoring_active[i] =\r\n!!ucontrol->value.integer.value[i];\r\nchanged |= (1<<i);\r\n}\r\n}\r\nif (changed & 0x01)\r\npcxhr_update_audio_pipe_level(chip, 0, 0);\r\nif (changed & 0x02)\r\npcxhr_update_audio_pipe_level(chip, 0, 1);\r\nmutex_unlock(&chip->mgr->mixer_mutex);\r\nreturn (changed != 0);\r\n}\r\nstatic int pcxhr_set_audio_source(struct snd_pcxhr* chip)\r\n{\r\nstruct pcxhr_rmh rmh;\r\nunsigned int mask, reg;\r\nunsigned int codec;\r\nint err, changed;\r\nswitch (chip->chip_idx) {\r\ncase 0 : mask = PCXHR_SOURCE_AUDIO01_UER; codec = CS8420_01_CS; break;\r\ncase 1 : mask = PCXHR_SOURCE_AUDIO23_UER; codec = CS8420_23_CS; break;\r\ncase 2 : mask = PCXHR_SOURCE_AUDIO45_UER; codec = CS8420_45_CS; break;\r\ncase 3 : mask = PCXHR_SOURCE_AUDIO67_UER; codec = CS8420_67_CS; break;\r\ndefault: return -EINVAL;\r\n}\r\nif (chip->audio_capture_source != 0) {\r\nreg = mask;\r\n} else {\r\nreg = 0;\r\n}\r\npcxhr_write_io_num_reg_cont(chip->mgr, mask, reg, &changed);\r\nif (changed) {\r\npcxhr_init_rmh(&rmh, CMD_RESYNC_AUDIO_INPUTS);\r\nrmh.cmd[0] |= (1 << chip->chip_idx);\r\nerr = pcxhr_send_msg(chip->mgr, &rmh);\r\nif (err)\r\nreturn err;\r\n}\r\nif (chip->mgr->board_aes_in_192k) {\r\nint i;\r\nunsigned int src_config = 0xC0;\r\nfor (i = 0; (i < 4) && (i < chip->mgr->capture_chips); i++) {\r\nif (chip->mgr->chip[i]->audio_capture_source == 2)\r\nsrc_config |= (1 << (3 - i));\r\n}\r\npcxhr_init_rmh(&rmh, CMD_ACCESS_IO_WRITE);\r\nrmh.cmd_len = 2;\r\nrmh.cmd[0] |= IO_NUM_REG_CONFIG_SRC;\r\nrmh.cmd[1] = src_config;\r\nerr = pcxhr_send_msg(chip->mgr, &rmh);\r\n} else {\r\nint use_src = 0;\r\nif (chip->audio_capture_source == 2)\r\nuse_src = 1;\r\npcxhr_init_rmh(&rmh, CMD_ACCESS_IO_WRITE);\r\nrmh.cmd_len = 3;\r\nrmh.cmd[0] |= IO_NUM_UER_CHIP_REG;\r\nrmh.cmd[1] = codec;\r\nrmh.cmd[2] = ((CS8420_DATA_FLOW_CTL & CHIP_SIG_AND_MAP_SPI) |\r\n(use_src ? 0x41 : 0x54));\r\nerr = pcxhr_send_msg(chip->mgr, &rmh);\r\nif (err)\r\nreturn err;\r\nrmh.cmd[2] = ((CS8420_CLOCK_SRC_CTL & CHIP_SIG_AND_MAP_SPI) |\r\n(use_src ? 0x41 : 0x49));\r\nerr = pcxhr_send_msg(chip->mgr, &rmh);\r\n}\r\nreturn err;\r\n}\r\nstatic int pcxhr_audio_src_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nstatic const char *texts[5] = {\r\n"Line", "Digital", "Digi+SRC", "Mic", "Line+Mic"\r\n};\r\nint i;\r\nstruct snd_pcxhr *chip = snd_kcontrol_chip(kcontrol);\r\ni = 2;\r\nif (chip->mgr->board_has_aes1) {\r\ni = 3;\r\nif (chip->mgr->board_has_mic)\r\ni = 5;\r\n}\r\nreturn snd_ctl_enum_info(uinfo, 1, i, texts);\r\n}\r\nstatic int pcxhr_audio_src_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_pcxhr *chip = snd_kcontrol_chip(kcontrol);\r\nucontrol->value.enumerated.item[0] = chip->audio_capture_source;\r\nreturn 0;\r\n}\r\nstatic int pcxhr_audio_src_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_pcxhr *chip = snd_kcontrol_chip(kcontrol);\r\nint ret = 0;\r\nint i = 2;\r\nif (chip->mgr->board_has_aes1) {\r\ni = 3;\r\nif (chip->mgr->board_has_mic)\r\ni = 5;\r\n}\r\nif (ucontrol->value.enumerated.item[0] >= i)\r\nreturn -EINVAL;\r\nmutex_lock(&chip->mgr->mixer_mutex);\r\nif (chip->audio_capture_source != ucontrol->value.enumerated.item[0]) {\r\nchip->audio_capture_source = ucontrol->value.enumerated.item[0];\r\nif (chip->mgr->is_hr_stereo)\r\nhr222_set_audio_source(chip);\r\nelse\r\npcxhr_set_audio_source(chip);\r\nret = 1;\r\n}\r\nmutex_unlock(&chip->mgr->mixer_mutex);\r\nreturn ret;\r\n}\r\nstatic int pcxhr_clock_type_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nstatic const char *textsPCXHR[7] = {\r\n"Internal", "WordClock", "AES Sync",\r\n"AES 1", "AES 2", "AES 3", "AES 4"\r\n};\r\nstatic const char *textsHR22[3] = {\r\n"Internal", "AES Sync", "AES 1"\r\n};\r\nconst char **texts;\r\nstruct pcxhr_mgr *mgr = snd_kcontrol_chip(kcontrol);\r\nint clock_items = 2;\r\nif (mgr->board_has_aes1) {\r\nclock_items += mgr->capture_chips;\r\nif (!mgr->is_hr_stereo)\r\nclock_items += 1;\r\n}\r\nif (mgr->is_hr_stereo) {\r\ntexts = textsHR22;\r\nsnd_BUG_ON(clock_items > (HR22_CLOCK_TYPE_MAX+1));\r\n} else {\r\ntexts = textsPCXHR;\r\nsnd_BUG_ON(clock_items > (PCXHR_CLOCK_TYPE_MAX+1));\r\n}\r\nreturn snd_ctl_enum_info(uinfo, 1, clock_items, texts);\r\n}\r\nstatic int pcxhr_clock_type_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct pcxhr_mgr *mgr = snd_kcontrol_chip(kcontrol);\r\nucontrol->value.enumerated.item[0] = mgr->use_clock_type;\r\nreturn 0;\r\n}\r\nstatic int pcxhr_clock_type_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct pcxhr_mgr *mgr = snd_kcontrol_chip(kcontrol);\r\nint rate, ret = 0;\r\nunsigned int clock_items = 2;\r\nif (mgr->board_has_aes1) {\r\nclock_items += mgr->capture_chips;\r\nif (!mgr->is_hr_stereo)\r\nclock_items += 1;\r\n}\r\nif (ucontrol->value.enumerated.item[0] >= clock_items)\r\nreturn -EINVAL;\r\nmutex_lock(&mgr->mixer_mutex);\r\nif (mgr->use_clock_type != ucontrol->value.enumerated.item[0]) {\r\nmutex_lock(&mgr->setup_mutex);\r\nmgr->use_clock_type = ucontrol->value.enumerated.item[0];\r\nrate = 0;\r\nif (mgr->use_clock_type != PCXHR_CLOCK_TYPE_INTERNAL) {\r\npcxhr_get_external_clock(mgr, mgr->use_clock_type,\r\n&rate);\r\n} else {\r\nrate = mgr->sample_rate;\r\nif (!rate)\r\nrate = 48000;\r\n}\r\nif (rate) {\r\npcxhr_set_clock(mgr, rate);\r\nif (mgr->sample_rate)\r\nmgr->sample_rate = rate;\r\n}\r\nmutex_unlock(&mgr->setup_mutex);\r\nret = 1;\r\n}\r\nmutex_unlock(&mgr->mixer_mutex);\r\nreturn ret;\r\n}\r\nstatic int pcxhr_clock_rate_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nstruct pcxhr_mgr *mgr = snd_kcontrol_chip(kcontrol);\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\r\nuinfo->count = 3 + mgr->capture_chips;\r\nuinfo->value.integer.min = 0;\r\nuinfo->value.integer.max = 192000;\r\nreturn 0;\r\n}\r\nstatic int pcxhr_clock_rate_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct pcxhr_mgr *mgr = snd_kcontrol_chip(kcontrol);\r\nint i, err, rate;\r\nmutex_lock(&mgr->mixer_mutex);\r\nfor(i = 0; i < 3 + mgr->capture_chips; i++) {\r\nif (i == PCXHR_CLOCK_TYPE_INTERNAL)\r\nrate = mgr->sample_rate_real;\r\nelse {\r\nerr = pcxhr_get_external_clock(mgr, i, &rate);\r\nif (err)\r\nbreak;\r\n}\r\nucontrol->value.integer.value[i] = rate;\r\n}\r\nmutex_unlock(&mgr->mixer_mutex);\r\nreturn 0;\r\n}\r\nstatic int pcxhr_iec958_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_IEC958;\r\nuinfo->count = 1;\r\nreturn 0;\r\n}\r\nstatic int pcxhr_iec958_capture_byte(struct snd_pcxhr *chip,\r\nint aes_idx, unsigned char *aes_bits)\r\n{\r\nint i, err;\r\nunsigned char temp;\r\nstruct pcxhr_rmh rmh;\r\npcxhr_init_rmh(&rmh, CMD_ACCESS_IO_READ);\r\nrmh.cmd[0] |= IO_NUM_UER_CHIP_REG;\r\nswitch (chip->chip_idx) {\r\ncase 0: rmh.cmd[1] = CS8420_01_CS; break;\r\ncase 1: rmh.cmd[1] = CS8420_23_CS; break;\r\ncase 2: rmh.cmd[1] = CS8420_45_CS; break;\r\ncase 3: rmh.cmd[1] = CS8420_67_CS; break;\r\ndefault: return -EINVAL;\r\n}\r\nif (chip->mgr->board_aes_in_192k) {\r\nswitch (aes_idx) {\r\ncase 0: rmh.cmd[2] = CS8416_CSB0; break;\r\ncase 1: rmh.cmd[2] = CS8416_CSB1; break;\r\ncase 2: rmh.cmd[2] = CS8416_CSB2; break;\r\ncase 3: rmh.cmd[2] = CS8416_CSB3; break;\r\ncase 4: rmh.cmd[2] = CS8416_CSB4; break;\r\ndefault: return -EINVAL;\r\n}\r\n} else {\r\nswitch (aes_idx) {\r\ncase 0: rmh.cmd[2] = CS8420_CSB0; break;\r\ncase 1: rmh.cmd[2] = CS8420_CSB1; break;\r\ncase 2: rmh.cmd[2] = CS8420_CSB2; break;\r\ncase 3: rmh.cmd[2] = CS8420_CSB3; break;\r\ncase 4: rmh.cmd[2] = CS8420_CSB4; break;\r\ndefault: return -EINVAL;\r\n}\r\n}\r\nrmh.cmd[1] &= 0x0fffff;\r\nrmh.cmd[2] &= CHIP_SIG_AND_MAP_SPI;\r\nrmh.cmd_len = 3;\r\nerr = pcxhr_send_msg(chip->mgr, &rmh);\r\nif (err)\r\nreturn err;\r\nif (chip->mgr->board_aes_in_192k) {\r\ntemp = (unsigned char)rmh.stat[1];\r\n} else {\r\ntemp = 0;\r\nfor (i = 0; i < 8; i++) {\r\ntemp <<= 1;\r\nif (rmh.stat[1] & (1 << i))\r\ntemp |= 1;\r\n}\r\n}\r\ndev_dbg(chip->card->dev, "read iec958 AES %d byte %d = 0x%x\n",\r\nchip->chip_idx, aes_idx, temp);\r\n*aes_bits = temp;\r\nreturn 0;\r\n}\r\nstatic int pcxhr_iec958_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_pcxhr *chip = snd_kcontrol_chip(kcontrol);\r\nunsigned char aes_bits;\r\nint i, err;\r\nmutex_lock(&chip->mgr->mixer_mutex);\r\nfor(i = 0; i < 5; i++) {\r\nif (kcontrol->private_value == 0)\r\naes_bits = chip->aes_bits[i];\r\nelse {\r\nif (chip->mgr->is_hr_stereo)\r\nerr = hr222_iec958_capture_byte(chip, i,\r\n&aes_bits);\r\nelse\r\nerr = pcxhr_iec958_capture_byte(chip, i,\r\n&aes_bits);\r\nif (err)\r\nbreak;\r\n}\r\nucontrol->value.iec958.status[i] = aes_bits;\r\n}\r\nmutex_unlock(&chip->mgr->mixer_mutex);\r\nreturn 0;\r\n}\r\nstatic int pcxhr_iec958_mask_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nint i;\r\nfor (i = 0; i < 5; i++)\r\nucontrol->value.iec958.status[i] = 0xff;\r\nreturn 0;\r\n}\r\nstatic int pcxhr_iec958_update_byte(struct snd_pcxhr *chip,\r\nint aes_idx, unsigned char aes_bits)\r\n{\r\nint i, err, cmd;\r\nunsigned char new_bits = aes_bits;\r\nunsigned char old_bits = chip->aes_bits[aes_idx];\r\nstruct pcxhr_rmh rmh;\r\nfor (i = 0; i < 8; i++) {\r\nif ((old_bits & 0x01) != (new_bits & 0x01)) {\r\ncmd = chip->chip_idx & 0x03;\r\nif (chip->chip_idx > 3)\r\ncmd |= 1 << 22;\r\ncmd |= ((aes_idx << 3) + i) << 2;\r\ncmd |= (new_bits & 0x01) << 23;\r\npcxhr_init_rmh(&rmh, CMD_ACCESS_IO_WRITE);\r\nrmh.cmd[0] |= IO_NUM_REG_CUER;\r\nrmh.cmd[1] = cmd;\r\nrmh.cmd_len = 2;\r\ndev_dbg(chip->card->dev,\r\n"write iec958 AES %d byte %d bit %d (cmd %x)\n",\r\nchip->chip_idx, aes_idx, i, cmd);\r\nerr = pcxhr_send_msg(chip->mgr, &rmh);\r\nif (err)\r\nreturn err;\r\n}\r\nold_bits >>= 1;\r\nnew_bits >>= 1;\r\n}\r\nchip->aes_bits[aes_idx] = aes_bits;\r\nreturn 0;\r\n}\r\nstatic int pcxhr_iec958_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_pcxhr *chip = snd_kcontrol_chip(kcontrol);\r\nint i, changed = 0;\r\nmutex_lock(&chip->mgr->mixer_mutex);\r\nfor (i = 0; i < 5; i++) {\r\nif (ucontrol->value.iec958.status[i] != chip->aes_bits[i]) {\r\nif (chip->mgr->is_hr_stereo)\r\nhr222_iec958_update_byte(chip, i,\r\nucontrol->value.iec958.status[i]);\r\nelse\r\npcxhr_iec958_update_byte(chip, i,\r\nucontrol->value.iec958.status[i]);\r\nchanged = 1;\r\n}\r\n}\r\nmutex_unlock(&chip->mgr->mixer_mutex);\r\nreturn changed;\r\n}\r\nstatic void pcxhr_init_audio_levels(struct snd_pcxhr *chip)\r\n{\r\nint i;\r\nfor (i = 0; i < 2; i++) {\r\nif (chip->nb_streams_play) {\r\nint j;\r\nfor (j = 0; j < PCXHR_PLAYBACK_STREAMS; j++) {\r\nchip->digital_playback_active[j][i] = 1;\r\nchip->digital_playback_volume[j][i] =\r\nPCXHR_DIGITAL_ZERO_LEVEL;\r\n}\r\nchip->aes_bits[0] = (IEC958_AES0_PROFESSIONAL |\r\nIEC958_AES0_PRO_FS_48000);\r\n#ifdef CONFIG_SND_DEBUG\r\nchip->analog_playback_active[i] = 1;\r\nif (chip->mgr->is_hr_stereo)\r\nchip->analog_playback_volume[i] =\r\nHR222_LINE_PLAYBACK_ZERO_LEVEL;\r\nelse {\r\nchip->analog_playback_volume[i] =\r\nPCXHR_LINE_PLAYBACK_ZERO_LEVEL;\r\npcxhr_update_analog_audio_level(chip, 0, i);\r\n}\r\n#endif\r\nif (chip->mgr->is_hr_stereo)\r\nhr222_update_analog_audio_level(chip, 0, i);\r\n}\r\nif (chip->nb_streams_capt) {\r\nchip->digital_capture_volume[i] =\r\nPCXHR_DIGITAL_ZERO_LEVEL;\r\nchip->analog_capture_active = 1;\r\n#ifdef CONFIG_SND_DEBUG\r\nif (chip->mgr->is_hr_stereo)\r\nchip->analog_capture_volume[i] =\r\nHR222_LINE_CAPTURE_ZERO_LEVEL;\r\nelse {\r\nchip->analog_capture_volume[i] =\r\nPCXHR_LINE_CAPTURE_ZERO_LEVEL;\r\npcxhr_update_analog_audio_level(chip, 1, i);\r\n}\r\n#endif\r\nif (chip->mgr->is_hr_stereo)\r\nhr222_update_analog_audio_level(chip, 1, i);\r\n}\r\n}\r\nreturn;\r\n}\r\nint pcxhr_create_mixer(struct pcxhr_mgr *mgr)\r\n{\r\nstruct snd_pcxhr *chip;\r\nint err, i;\r\nmutex_init(&mgr->mixer_mutex);\r\nfor (i = 0; i < mgr->num_cards; i++) {\r\nstruct snd_kcontrol_new temp;\r\nchip = mgr->chip[i];\r\nif (chip->nb_streams_play) {\r\ntemp = pcxhr_control_analog_level;\r\ntemp.name = "Master Playback Volume";\r\ntemp.private_value = 0;\r\nif (mgr->is_hr_stereo)\r\ntemp.tlv.p = db_scale_a_hr222_playback;\r\nelse\r\ntemp.tlv.p = db_scale_analog_playback;\r\nerr = snd_ctl_add(chip->card,\r\nsnd_ctl_new1(&temp, chip));\r\nif (err < 0)\r\nreturn err;\r\nerr = snd_ctl_add(chip->card,\r\nsnd_ctl_new1(&pcxhr_control_output_switch,\r\nchip));\r\nif (err < 0)\r\nreturn err;\r\ntemp = snd_pcxhr_pcm_vol;\r\ntemp.name = "PCM Playback Volume";\r\ntemp.count = PCXHR_PLAYBACK_STREAMS;\r\ntemp.private_value = 0;\r\nerr = snd_ctl_add(chip->card,\r\nsnd_ctl_new1(&temp, chip));\r\nif (err < 0)\r\nreturn err;\r\nerr = snd_ctl_add(chip->card,\r\nsnd_ctl_new1(&pcxhr_control_pcm_switch, chip));\r\nif (err < 0)\r\nreturn err;\r\nerr = snd_ctl_add(chip->card,\r\nsnd_ctl_new1(&pcxhr_control_playback_iec958_mask,\r\nchip));\r\nif (err < 0)\r\nreturn err;\r\nerr = snd_ctl_add(chip->card,\r\nsnd_ctl_new1(&pcxhr_control_playback_iec958,\r\nchip));\r\nif (err < 0)\r\nreturn err;\r\n}\r\nif (chip->nb_streams_capt) {\r\ntemp = pcxhr_control_analog_level;\r\ntemp.name = "Line Capture Volume";\r\ntemp.private_value = 1;\r\nif (mgr->is_hr_stereo)\r\ntemp.tlv.p = db_scale_a_hr222_capture;\r\nelse\r\ntemp.tlv.p = db_scale_analog_capture;\r\nerr = snd_ctl_add(chip->card,\r\nsnd_ctl_new1(&temp, chip));\r\nif (err < 0)\r\nreturn err;\r\ntemp = snd_pcxhr_pcm_vol;\r\ntemp.name = "PCM Capture Volume";\r\ntemp.count = 1;\r\ntemp.private_value = 1;\r\nerr = snd_ctl_add(chip->card,\r\nsnd_ctl_new1(&temp, chip));\r\nif (err < 0)\r\nreturn err;\r\nerr = snd_ctl_add(chip->card,\r\nsnd_ctl_new1(&pcxhr_control_audio_src, chip));\r\nif (err < 0)\r\nreturn err;\r\nerr = snd_ctl_add(chip->card,\r\nsnd_ctl_new1(&pcxhr_control_capture_iec958_mask,\r\nchip));\r\nif (err < 0)\r\nreturn err;\r\nerr = snd_ctl_add(chip->card,\r\nsnd_ctl_new1(&pcxhr_control_capture_iec958,\r\nchip));\r\nif (err < 0)\r\nreturn err;\r\nif (mgr->is_hr_stereo) {\r\nerr = hr222_add_mic_controls(chip);\r\nif (err < 0)\r\nreturn err;\r\n}\r\n}\r\nif (chip->nb_streams_capt > 0 && chip->nb_streams_play > 0) {\r\nerr = snd_ctl_add(chip->card,\r\nsnd_ctl_new1(&pcxhr_control_monitor_vol, chip));\r\nif (err < 0)\r\nreturn err;\r\nerr = snd_ctl_add(chip->card,\r\nsnd_ctl_new1(&pcxhr_control_monitor_sw, chip));\r\nif (err < 0)\r\nreturn err;\r\n}\r\nif (i == 0) {\r\nerr = snd_ctl_add(chip->card,\r\nsnd_ctl_new1(&pcxhr_control_clock_type, mgr));\r\nif (err < 0)\r\nreturn err;\r\nerr = snd_ctl_add(chip->card,\r\nsnd_ctl_new1(&pcxhr_control_clock_rate, mgr));\r\nif (err < 0)\r\nreturn err;\r\n}\r\npcxhr_init_audio_levels(chip);\r\n}\r\nreturn 0;\r\n}
