static int\r\nprocessor_set_pstate (\r\nu32 value)\r\n{\r\ns64 retval;\r\npr_debug("processor_set_pstate\n");\r\nretval = ia64_pal_set_pstate((u64)value);\r\nif (retval) {\r\npr_debug("Failed to set freq to 0x%x, with error 0x%lx\n",\r\nvalue, retval);\r\nreturn -ENODEV;\r\n}\r\nreturn (int)retval;\r\n}\r\nstatic int\r\nprocessor_get_pstate (\r\nu32 *value)\r\n{\r\nu64 pstate_index = 0;\r\ns64 retval;\r\npr_debug("processor_get_pstate\n");\r\nretval = ia64_pal_get_pstate(&pstate_index,\r\nPAL_GET_PSTATE_TYPE_INSTANT);\r\n*value = (u32) pstate_index;\r\nif (retval)\r\npr_debug("Failed to get current freq with "\r\n"error 0x%lx, idx 0x%x\n", retval, *value);\r\nreturn (int)retval;\r\n}\r\nstatic unsigned\r\nextract_clock (\r\nstruct cpufreq_acpi_io *data,\r\nunsigned value,\r\nunsigned int cpu)\r\n{\r\nunsigned long i;\r\npr_debug("extract_clock\n");\r\nfor (i = 0; i < data->acpi_data.state_count; i++) {\r\nif (value == data->acpi_data.states[i].status)\r\nreturn data->acpi_data.states[i].core_frequency;\r\n}\r\nreturn data->acpi_data.states[i-1].core_frequency;\r\n}\r\nstatic unsigned int\r\nprocessor_get_freq (\r\nstruct cpufreq_acpi_io *data,\r\nunsigned int cpu)\r\n{\r\nint ret = 0;\r\nu32 value = 0;\r\ncpumask_t saved_mask;\r\nunsigned long clock_freq;\r\npr_debug("processor_get_freq\n");\r\nsaved_mask = current->cpus_allowed;\r\nset_cpus_allowed_ptr(current, cpumask_of(cpu));\r\nif (smp_processor_id() != cpu)\r\ngoto migrate_end;\r\nret = processor_get_pstate(&value);\r\nif (ret) {\r\nset_cpus_allowed_ptr(current, &saved_mask);\r\nprintk(KERN_WARNING "get performance failed with error %d\n",\r\nret);\r\nret = 0;\r\ngoto migrate_end;\r\n}\r\nclock_freq = extract_clock(data, value, cpu);\r\nret = (clock_freq*1000);\r\nmigrate_end:\r\nset_cpus_allowed_ptr(current, &saved_mask);\r\nreturn ret;\r\n}\r\nstatic int\r\nprocessor_set_freq (\r\nstruct cpufreq_acpi_io *data,\r\nstruct cpufreq_policy *policy,\r\nint state)\r\n{\r\nint ret = 0;\r\nu32 value = 0;\r\ncpumask_t saved_mask;\r\nint retval;\r\npr_debug("processor_set_freq\n");\r\nsaved_mask = current->cpus_allowed;\r\nset_cpus_allowed_ptr(current, cpumask_of(policy->cpu));\r\nif (smp_processor_id() != policy->cpu) {\r\nretval = -EAGAIN;\r\ngoto migrate_end;\r\n}\r\nif (state == data->acpi_data.state) {\r\nif (unlikely(data->resume)) {\r\npr_debug("Called after resume, resetting to P%d\n", state);\r\ndata->resume = 0;\r\n} else {\r\npr_debug("Already at target state (P%d)\n", state);\r\nretval = 0;\r\ngoto migrate_end;\r\n}\r\n}\r\npr_debug("Transitioning from P%d to P%d\n",\r\ndata->acpi_data.state, state);\r\nvalue = (u32) data->acpi_data.states[state].control;\r\npr_debug("Transitioning to state: 0x%08x\n", value);\r\nret = processor_set_pstate(value);\r\nif (ret) {\r\nprintk(KERN_WARNING "Transition failed with error %d\n", ret);\r\nretval = -ENODEV;\r\ngoto migrate_end;\r\n}\r\ndata->acpi_data.state = state;\r\nretval = 0;\r\nmigrate_end:\r\nset_cpus_allowed_ptr(current, &saved_mask);\r\nreturn (retval);\r\n}\r\nstatic unsigned int\r\nacpi_cpufreq_get (\r\nunsigned int cpu)\r\n{\r\nstruct cpufreq_acpi_io *data = acpi_io_data[cpu];\r\npr_debug("acpi_cpufreq_get\n");\r\nreturn processor_get_freq(data, cpu);\r\n}\r\nstatic int\r\nacpi_cpufreq_target (\r\nstruct cpufreq_policy *policy,\r\nunsigned int index)\r\n{\r\nreturn processor_set_freq(acpi_io_data[policy->cpu], policy, index);\r\n}\r\nstatic int\r\nacpi_cpufreq_cpu_init (\r\nstruct cpufreq_policy *policy)\r\n{\r\nunsigned int i;\r\nunsigned int cpu = policy->cpu;\r\nstruct cpufreq_acpi_io *data;\r\nunsigned int result = 0;\r\npr_debug("acpi_cpufreq_cpu_init\n");\r\ndata = kzalloc(sizeof(*data), GFP_KERNEL);\r\nif (!data)\r\nreturn (-ENOMEM);\r\nacpi_io_data[cpu] = data;\r\nresult = acpi_processor_register_performance(&data->acpi_data, cpu);\r\nif (result)\r\ngoto err_free;\r\nif (data->acpi_data.state_count <= 1) {\r\npr_debug("No P-States\n");\r\nresult = -ENODEV;\r\ngoto err_unreg;\r\n}\r\nif ((data->acpi_data.control_register.space_id !=\r\nACPI_ADR_SPACE_FIXED_HARDWARE) ||\r\n(data->acpi_data.status_register.space_id !=\r\nACPI_ADR_SPACE_FIXED_HARDWARE)) {\r\npr_debug("Unsupported address space [%d, %d]\n",\r\n(u32) (data->acpi_data.control_register.space_id),\r\n(u32) (data->acpi_data.status_register.space_id));\r\nresult = -ENODEV;\r\ngoto err_unreg;\r\n}\r\ndata->freq_table = kzalloc(sizeof(*data->freq_table) *\r\n(data->acpi_data.state_count + 1),\r\nGFP_KERNEL);\r\nif (!data->freq_table) {\r\nresult = -ENOMEM;\r\ngoto err_unreg;\r\n}\r\npolicy->cpuinfo.transition_latency = 0;\r\nfor (i=0; i<data->acpi_data.state_count; i++) {\r\nif ((data->acpi_data.states[i].transition_latency * 1000) >\r\npolicy->cpuinfo.transition_latency) {\r\npolicy->cpuinfo.transition_latency =\r\ndata->acpi_data.states[i].transition_latency * 1000;\r\n}\r\n}\r\nfor (i = 0; i <= data->acpi_data.state_count; i++)\r\n{\r\nif (i < data->acpi_data.state_count) {\r\ndata->freq_table[i].frequency =\r\ndata->acpi_data.states[i].core_frequency * 1000;\r\n} else {\r\ndata->freq_table[i].frequency = CPUFREQ_TABLE_END;\r\n}\r\n}\r\nresult = cpufreq_table_validate_and_show(policy, data->freq_table);\r\nif (result) {\r\ngoto err_freqfree;\r\n}\r\nacpi_processor_notify_smm(THIS_MODULE);\r\nprintk(KERN_INFO "acpi-cpufreq: CPU%u - ACPI performance management "\r\n"activated.\n", cpu);\r\nfor (i = 0; i < data->acpi_data.state_count; i++)\r\npr_debug(" %cP%d: %d MHz, %d mW, %d uS, %d uS, 0x%x 0x%x\n",\r\n(i == data->acpi_data.state?'*':' '), i,\r\n(u32) data->acpi_data.states[i].core_frequency,\r\n(u32) data->acpi_data.states[i].power,\r\n(u32) data->acpi_data.states[i].transition_latency,\r\n(u32) data->acpi_data.states[i].bus_master_latency,\r\n(u32) data->acpi_data.states[i].status,\r\n(u32) data->acpi_data.states[i].control);\r\ndata->resume = 1;\r\nreturn (result);\r\nerr_freqfree:\r\nkfree(data->freq_table);\r\nerr_unreg:\r\nacpi_processor_unregister_performance(&data->acpi_data, cpu);\r\nerr_free:\r\nkfree(data);\r\nacpi_io_data[cpu] = NULL;\r\nreturn (result);\r\n}\r\nstatic int\r\nacpi_cpufreq_cpu_exit (\r\nstruct cpufreq_policy *policy)\r\n{\r\nstruct cpufreq_acpi_io *data = acpi_io_data[policy->cpu];\r\npr_debug("acpi_cpufreq_cpu_exit\n");\r\nif (data) {\r\nacpi_io_data[policy->cpu] = NULL;\r\nacpi_processor_unregister_performance(&data->acpi_data,\r\npolicy->cpu);\r\nkfree(data);\r\n}\r\nreturn (0);\r\n}\r\nstatic int __init\r\nacpi_cpufreq_init (void)\r\n{\r\npr_debug("acpi_cpufreq_init\n");\r\nreturn cpufreq_register_driver(&acpi_cpufreq_driver);\r\n}\r\nstatic void __exit\r\nacpi_cpufreq_exit (void)\r\n{\r\npr_debug("acpi_cpufreq_exit\n");\r\ncpufreq_unregister_driver(&acpi_cpufreq_driver);\r\nreturn;\r\n}
