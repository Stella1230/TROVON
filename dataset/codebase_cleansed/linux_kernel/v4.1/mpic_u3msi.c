static void mpic_u3msi_mask_irq(struct irq_data *data)\r\n{\r\npci_msi_mask_irq(data);\r\nmpic_mask_irq(data);\r\n}\r\nstatic void mpic_u3msi_unmask_irq(struct irq_data *data)\r\n{\r\nmpic_unmask_irq(data);\r\npci_msi_unmask_irq(data);\r\n}\r\nstatic u64 read_ht_magic_addr(struct pci_dev *pdev, unsigned int pos)\r\n{\r\nu8 flags;\r\nu32 tmp;\r\nu64 addr;\r\npci_read_config_byte(pdev, pos + HT_MSI_FLAGS, &flags);\r\nif (flags & HT_MSI_FLAGS_FIXED)\r\nreturn HT_MSI_FIXED_ADDR;\r\npci_read_config_dword(pdev, pos + HT_MSI_ADDR_LO, &tmp);\r\naddr = tmp & HT_MSI_ADDR_LO_MASK;\r\npci_read_config_dword(pdev, pos + HT_MSI_ADDR_HI, &tmp);\r\naddr = addr | ((u64)tmp << 32);\r\nreturn addr;\r\n}\r\nstatic u64 find_ht_magic_addr(struct pci_dev *pdev, unsigned int hwirq)\r\n{\r\nstruct pci_bus *bus;\r\nunsigned int pos;\r\nfor (bus = pdev->bus; bus && bus->self; bus = bus->parent) {\r\npos = pci_find_ht_capability(bus->self, HT_CAPTYPE_MSI_MAPPING);\r\nif (pos)\r\nreturn read_ht_magic_addr(bus->self, pos);\r\n}\r\nreturn 0;\r\n}\r\nstatic u64 find_u4_magic_addr(struct pci_dev *pdev, unsigned int hwirq)\r\n{\r\nstruct pci_controller *hose = pci_bus_to_host(pdev->bus);\r\nif (of_device_is_compatible(hose->dn, "u4-pcie") ||\r\nof_device_is_compatible(hose->dn, "U4-pcie"))\r\nreturn 0xf8004000 | (hwirq << 4);\r\nreturn 0;\r\n}\r\nstatic void u3msi_teardown_msi_irqs(struct pci_dev *pdev)\r\n{\r\nstruct msi_desc *entry;\r\nlist_for_each_entry(entry, &pdev->msi_list, list) {\r\nif (entry->irq == NO_IRQ)\r\ncontinue;\r\nirq_set_msi_desc(entry->irq, NULL);\r\nmsi_bitmap_free_hwirqs(&msi_mpic->msi_bitmap,\r\nvirq_to_hw(entry->irq), 1);\r\nirq_dispose_mapping(entry->irq);\r\n}\r\nreturn;\r\n}\r\nstatic int u3msi_setup_msi_irqs(struct pci_dev *pdev, int nvec, int type)\r\n{\r\nunsigned int virq;\r\nstruct msi_desc *entry;\r\nstruct msi_msg msg;\r\nu64 addr;\r\nint hwirq;\r\nif (type == PCI_CAP_ID_MSIX)\r\npr_debug("u3msi: MSI-X untested, trying anyway.\n");\r\nif (find_ht_magic_addr(pdev, 0) == 0 &&\r\nfind_u4_magic_addr(pdev, 0) == 0) {\r\npr_debug("u3msi: no magic address found for %s\n",\r\npci_name(pdev));\r\nreturn -ENXIO;\r\n}\r\nlist_for_each_entry(entry, &pdev->msi_list, list) {\r\nhwirq = msi_bitmap_alloc_hwirqs(&msi_mpic->msi_bitmap, 1);\r\nif (hwirq < 0) {\r\npr_debug("u3msi: failed allocating hwirq\n");\r\nreturn hwirq;\r\n}\r\naddr = find_ht_magic_addr(pdev, hwirq);\r\nif (addr == 0)\r\naddr = find_u4_magic_addr(pdev, hwirq);\r\nmsg.address_lo = addr & 0xFFFFFFFF;\r\nmsg.address_hi = addr >> 32;\r\nvirq = irq_create_mapping(msi_mpic->irqhost, hwirq);\r\nif (virq == NO_IRQ) {\r\npr_debug("u3msi: failed mapping hwirq 0x%x\n", hwirq);\r\nmsi_bitmap_free_hwirqs(&msi_mpic->msi_bitmap, hwirq, 1);\r\nreturn -ENOSPC;\r\n}\r\nirq_set_msi_desc(virq, entry);\r\nirq_set_chip(virq, &mpic_u3msi_chip);\r\nirq_set_irq_type(virq, IRQ_TYPE_EDGE_RISING);\r\npr_debug("u3msi: allocated virq 0x%x (hw 0x%x) addr 0x%lx\n",\r\nvirq, hwirq, (unsigned long)addr);\r\nprintk("u3msi: allocated virq 0x%x (hw 0x%x) addr 0x%lx\n",\r\nvirq, hwirq, (unsigned long)addr);\r\nmsg.data = hwirq;\r\npci_write_msi_msg(virq, &msg);\r\nhwirq++;\r\n}\r\nreturn 0;\r\n}\r\nint mpic_u3msi_init(struct mpic *mpic)\r\n{\r\nint rc;\r\nrc = mpic_msi_init_allocator(mpic);\r\nif (rc) {\r\npr_debug("u3msi: Error allocating bitmap!\n");\r\nreturn rc;\r\n}\r\npr_debug("u3msi: Registering MPIC U3 MSI callbacks.\n");\r\nBUG_ON(msi_mpic);\r\nmsi_mpic = mpic;\r\nWARN_ON(ppc_md.setup_msi_irqs);\r\nppc_md.setup_msi_irqs = u3msi_setup_msi_irqs;\r\nppc_md.teardown_msi_irqs = u3msi_teardown_msi_irqs;\r\nreturn 0;\r\n}
