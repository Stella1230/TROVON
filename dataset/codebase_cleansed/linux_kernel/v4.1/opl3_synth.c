int snd_opl3_open(struct snd_hwdep * hw, struct file *file)\r\n{\r\nreturn 0;\r\n}\r\nint snd_opl3_ioctl(struct snd_hwdep * hw, struct file *file,\r\nunsigned int cmd, unsigned long arg)\r\n{\r\nstruct snd_opl3 *opl3 = hw->private_data;\r\nvoid __user *argp = (void __user *)arg;\r\nif (snd_BUG_ON(!opl3))\r\nreturn -EINVAL;\r\nswitch (cmd) {\r\ncase SNDRV_DM_FM_IOCTL_INFO:\r\n{\r\nstruct snd_dm_fm_info info;\r\ninfo.fm_mode = opl3->fm_mode;\r\ninfo.rhythm = opl3->rhythm;\r\nif (copy_to_user(argp, &info, sizeof(struct snd_dm_fm_info)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\ncase SNDRV_DM_FM_IOCTL_RESET:\r\n#ifdef CONFIG_SND_OSSEMUL\r\ncase SNDRV_DM_FM_OSS_IOCTL_RESET:\r\n#endif\r\nsnd_opl3_reset(opl3);\r\nreturn 0;\r\ncase SNDRV_DM_FM_IOCTL_PLAY_NOTE:\r\n#ifdef CONFIG_SND_OSSEMUL\r\ncase SNDRV_DM_FM_OSS_IOCTL_PLAY_NOTE:\r\n#endif\r\n{\r\nstruct snd_dm_fm_note note;\r\nif (copy_from_user(&note, argp, sizeof(struct snd_dm_fm_note)))\r\nreturn -EFAULT;\r\nreturn snd_opl3_play_note(opl3, &note);\r\n}\r\ncase SNDRV_DM_FM_IOCTL_SET_VOICE:\r\n#ifdef CONFIG_SND_OSSEMUL\r\ncase SNDRV_DM_FM_OSS_IOCTL_SET_VOICE:\r\n#endif\r\n{\r\nstruct snd_dm_fm_voice voice;\r\nif (copy_from_user(&voice, argp, sizeof(struct snd_dm_fm_voice)))\r\nreturn -EFAULT;\r\nreturn snd_opl3_set_voice(opl3, &voice);\r\n}\r\ncase SNDRV_DM_FM_IOCTL_SET_PARAMS:\r\n#ifdef CONFIG_SND_OSSEMUL\r\ncase SNDRV_DM_FM_OSS_IOCTL_SET_PARAMS:\r\n#endif\r\n{\r\nstruct snd_dm_fm_params params;\r\nif (copy_from_user(&params, argp, sizeof(struct snd_dm_fm_params)))\r\nreturn -EFAULT;\r\nreturn snd_opl3_set_params(opl3, &params);\r\n}\r\ncase SNDRV_DM_FM_IOCTL_SET_MODE:\r\n#ifdef CONFIG_SND_OSSEMUL\r\ncase SNDRV_DM_FM_OSS_IOCTL_SET_MODE:\r\n#endif\r\nreturn snd_opl3_set_mode(opl3, (int) arg);\r\ncase SNDRV_DM_FM_IOCTL_SET_CONNECTION:\r\n#ifdef CONFIG_SND_OSSEMUL\r\ncase SNDRV_DM_FM_OSS_IOCTL_SET_OPL:\r\n#endif\r\nreturn snd_opl3_set_connection(opl3, (int) arg);\r\n#ifdef OPL3_SUPPORT_SYNTH\r\ncase SNDRV_DM_FM_IOCTL_CLEAR_PATCHES:\r\nsnd_opl3_clear_patches(opl3);\r\nreturn 0;\r\n#endif\r\n#ifdef CONFIG_SND_DEBUG\r\ndefault:\r\nsnd_printk(KERN_WARNING "unknown IOCTL: 0x%x\n", cmd);\r\n#endif\r\n}\r\nreturn -ENOTTY;\r\n}\r\nint snd_opl3_release(struct snd_hwdep * hw, struct file *file)\r\n{\r\nstruct snd_opl3 *opl3 = hw->private_data;\r\nsnd_opl3_reset(opl3);\r\nreturn 0;\r\n}\r\nlong snd_opl3_write(struct snd_hwdep *hw, const char __user *buf, long count,\r\nloff_t *offset)\r\n{\r\nstruct snd_opl3 *opl3 = hw->private_data;\r\nlong result = 0;\r\nint err = 0;\r\nstruct sbi_patch inst;\r\nwhile (count >= sizeof(inst)) {\r\nunsigned char type;\r\nif (copy_from_user(&inst, buf, sizeof(inst)))\r\nreturn -EFAULT;\r\nif (!memcmp(inst.key, FM_KEY_SBI, 4) ||\r\n!memcmp(inst.key, FM_KEY_2OP, 4))\r\ntype = FM_PATCH_OPL2;\r\nelse if (!memcmp(inst.key, FM_KEY_4OP, 4))\r\ntype = FM_PATCH_OPL3;\r\nelse\r\nbreak;\r\nerr = snd_opl3_load_patch(opl3, inst.prog, inst.bank, type,\r\ninst.name, inst.extension,\r\ninst.data);\r\nif (err < 0)\r\nbreak;\r\nresult += sizeof(inst);\r\ncount -= sizeof(inst);\r\n}\r\nreturn result > 0 ? result : err;\r\n}\r\nint snd_opl3_load_patch(struct snd_opl3 *opl3,\r\nint prog, int bank, int type,\r\nconst char *name,\r\nconst unsigned char *ext,\r\nconst unsigned char *data)\r\n{\r\nstruct fm_patch *patch;\r\nint i;\r\npatch = snd_opl3_find_patch(opl3, prog, bank, 1);\r\nif (!patch)\r\nreturn -ENOMEM;\r\npatch->type = type;\r\nfor (i = 0; i < 2; i++) {\r\npatch->inst.op[i].am_vib = data[AM_VIB + i];\r\npatch->inst.op[i].ksl_level = data[KSL_LEVEL + i];\r\npatch->inst.op[i].attack_decay = data[ATTACK_DECAY + i];\r\npatch->inst.op[i].sustain_release = data[SUSTAIN_RELEASE + i];\r\npatch->inst.op[i].wave_select = data[WAVE_SELECT + i];\r\n}\r\npatch->inst.feedback_connection[0] = data[CONNECTION];\r\nif (type == FM_PATCH_OPL3) {\r\nfor (i = 0; i < 2; i++) {\r\npatch->inst.op[i+2].am_vib =\r\ndata[OFFSET_4OP + AM_VIB + i];\r\npatch->inst.op[i+2].ksl_level =\r\ndata[OFFSET_4OP + KSL_LEVEL + i];\r\npatch->inst.op[i+2].attack_decay =\r\ndata[OFFSET_4OP + ATTACK_DECAY + i];\r\npatch->inst.op[i+2].sustain_release =\r\ndata[OFFSET_4OP + SUSTAIN_RELEASE + i];\r\npatch->inst.op[i+2].wave_select =\r\ndata[OFFSET_4OP + WAVE_SELECT + i];\r\n}\r\npatch->inst.feedback_connection[1] =\r\ndata[OFFSET_4OP + CONNECTION];\r\n}\r\nif (ext) {\r\npatch->inst.echo_delay = ext[0];\r\npatch->inst.echo_atten = ext[1];\r\npatch->inst.chorus_spread = ext[2];\r\npatch->inst.trnsps = ext[3];\r\npatch->inst.fix_dur = ext[4];\r\npatch->inst.modes = ext[5];\r\npatch->inst.fix_key = ext[6];\r\n}\r\nif (name)\r\nstrlcpy(patch->name, name, sizeof(patch->name));\r\nreturn 0;\r\n}\r\nstruct fm_patch *snd_opl3_find_patch(struct snd_opl3 *opl3, int prog, int bank,\r\nint create_patch)\r\n{\r\nunsigned int key = (prog + bank) % OPL3_PATCH_HASH_SIZE;\r\nstruct fm_patch *patch;\r\nfor (patch = opl3->patch_table[key]; patch; patch = patch->next) {\r\nif (patch->prog == prog && patch->bank == bank)\r\nreturn patch;\r\n}\r\nif (!create_patch)\r\nreturn NULL;\r\npatch = kzalloc(sizeof(*patch), GFP_KERNEL);\r\nif (!patch)\r\nreturn NULL;\r\npatch->prog = prog;\r\npatch->bank = bank;\r\npatch->next = opl3->patch_table[key];\r\nopl3->patch_table[key] = patch;\r\nreturn patch;\r\n}\r\nvoid snd_opl3_clear_patches(struct snd_opl3 *opl3)\r\n{\r\nint i;\r\nfor (i = 0; i < OPL3_PATCH_HASH_SIZE; i++) {\r\nstruct fm_patch *patch, *next;\r\nfor (patch = opl3->patch_table[i]; patch; patch = next) {\r\nnext = patch->next;\r\nkfree(patch);\r\n}\r\n}\r\nmemset(opl3->patch_table, 0, sizeof(opl3->patch_table));\r\n}\r\nvoid snd_opl3_reset(struct snd_opl3 * opl3)\r\n{\r\nunsigned short opl3_reg;\r\nunsigned short reg_side;\r\nunsigned char voice_offset;\r\nint max_voices, i;\r\nmax_voices = (opl3->hardware < OPL3_HW_OPL3) ?\r\nMAX_OPL2_VOICES : MAX_OPL3_VOICES;\r\nfor (i = 0; i < max_voices; i++) {\r\nif (i < MAX_OPL2_VOICES) {\r\nreg_side = OPL3_LEFT;\r\nvoice_offset = i;\r\n} else {\r\nreg_side = OPL3_RIGHT;\r\nvoice_offset = i - MAX_OPL2_VOICES;\r\n}\r\nopl3_reg = reg_side | (OPL3_REG_KSL_LEVEL + snd_opl3_regmap[voice_offset][0]);\r\nopl3->command(opl3, opl3_reg, OPL3_TOTAL_LEVEL_MASK);\r\nopl3_reg = reg_side | (OPL3_REG_KSL_LEVEL + snd_opl3_regmap[voice_offset][1]);\r\nopl3->command(opl3, opl3_reg, OPL3_TOTAL_LEVEL_MASK);\r\nopl3_reg = reg_side | (OPL3_REG_KEYON_BLOCK + voice_offset);\r\nopl3->command(opl3, opl3_reg, 0x00);\r\n}\r\nopl3->max_voices = MAX_OPL2_VOICES;\r\nopl3->fm_mode = SNDRV_DM_FM_MODE_OPL2;\r\nopl3->command(opl3, OPL3_LEFT | OPL3_REG_TEST, OPL3_ENABLE_WAVE_SELECT);\r\nopl3->command(opl3, OPL3_LEFT | OPL3_REG_PERCUSSION, 0x00);\r\nopl3->rhythm = 0;\r\n}\r\nstatic int snd_opl3_play_note(struct snd_opl3 * opl3, struct snd_dm_fm_note * note)\r\n{\r\nunsigned short reg_side;\r\nunsigned char voice_offset;\r\nunsigned short opl3_reg;\r\nunsigned char reg_val;\r\nif (note->voice >= ((opl3->fm_mode == SNDRV_DM_FM_MODE_OPL3) ?\r\nMAX_OPL3_VOICES : MAX_OPL2_VOICES))\r\nreturn -EINVAL;\r\nif (note->voice < MAX_OPL2_VOICES) {\r\nreg_side = OPL3_LEFT;\r\nvoice_offset = note->voice;\r\n} else {\r\nreg_side = OPL3_RIGHT;\r\nvoice_offset = note->voice - MAX_OPL2_VOICES;\r\n}\r\nreg_val = (unsigned char) note->fnum;\r\nopl3_reg = reg_side | (OPL3_REG_FNUM_LOW + voice_offset);\r\nopl3->command(opl3, opl3_reg, reg_val);\r\nreg_val = 0x00;\r\nif (note->key_on)\r\nreg_val |= OPL3_KEYON_BIT;\r\nreg_val |= (note->octave << 2) & OPL3_BLOCKNUM_MASK;\r\nreg_val |= (unsigned char) (note->fnum >> 8) & OPL3_FNUM_HIGH_MASK;\r\nopl3_reg = reg_side | (OPL3_REG_KEYON_BLOCK + voice_offset);\r\nopl3->command(opl3, opl3_reg, reg_val);\r\nreturn 0;\r\n}\r\nstatic int snd_opl3_set_voice(struct snd_opl3 * opl3, struct snd_dm_fm_voice * voice)\r\n{\r\nunsigned short reg_side;\r\nunsigned char op_offset;\r\nunsigned char voice_offset;\r\nunsigned short opl3_reg;\r\nunsigned char reg_val;\r\nif (voice->op > 1)\r\nreturn -EINVAL;\r\nif (voice->voice >= ((opl3->fm_mode == SNDRV_DM_FM_MODE_OPL3) ?\r\nMAX_OPL3_VOICES : MAX_OPL2_VOICES))\r\nreturn -EINVAL;\r\nif (voice->voice < MAX_OPL2_VOICES) {\r\nreg_side = OPL3_LEFT;\r\nvoice_offset = voice->voice;\r\n} else {\r\nreg_side = OPL3_RIGHT;\r\nvoice_offset = voice->voice - MAX_OPL2_VOICES;\r\n}\r\nop_offset = snd_opl3_regmap[voice_offset][voice->op];\r\nreg_val = 0x00;\r\nif (voice->am)\r\nreg_val |= OPL3_TREMOLO_ON;\r\nif (voice->vibrato)\r\nreg_val |= OPL3_VIBRATO_ON;\r\nif (voice->do_sustain)\r\nreg_val |= OPL3_SUSTAIN_ON;\r\nif (voice->kbd_scale)\r\nreg_val |= OPL3_KSR;\r\nreg_val |= voice->harmonic & OPL3_MULTIPLE_MASK;\r\nopl3_reg = reg_side | (OPL3_REG_AM_VIB + op_offset);\r\nopl3->command(opl3, opl3_reg, reg_val);\r\nreg_val = (voice->scale_level << 6) & OPL3_KSL_MASK;\r\nreg_val |= ~voice->volume & OPL3_TOTAL_LEVEL_MASK;\r\nopl3_reg = reg_side | (OPL3_REG_KSL_LEVEL + op_offset);\r\nopl3->command(opl3, opl3_reg, reg_val);\r\nreg_val = (voice->attack << 4) & OPL3_ATTACK_MASK;\r\nreg_val |= voice->decay & OPL3_DECAY_MASK;\r\nopl3_reg = reg_side | (OPL3_REG_ATTACK_DECAY + op_offset);\r\nopl3->command(opl3, opl3_reg, reg_val);\r\nreg_val = (voice->sustain << 4) & OPL3_SUSTAIN_MASK;\r\nreg_val |= voice->release & OPL3_RELEASE_MASK;\r\nopl3_reg = reg_side | (OPL3_REG_SUSTAIN_RELEASE + op_offset);\r\nopl3->command(opl3, opl3_reg, reg_val);\r\nreg_val = (voice->feedback << 1) & OPL3_FEEDBACK_MASK;\r\nif (voice->connection)\r\nreg_val |= OPL3_CONNECTION_BIT;\r\nif (opl3->fm_mode == SNDRV_DM_FM_MODE_OPL3) {\r\nif (voice->left)\r\nreg_val |= OPL3_VOICE_TO_LEFT;\r\nif (voice->right)\r\nreg_val |= OPL3_VOICE_TO_RIGHT;\r\n}\r\nopl3_reg = reg_side | (OPL3_REG_FEEDBACK_CONNECTION + voice_offset);\r\nopl3->command(opl3, opl3_reg, reg_val);\r\nreg_val = voice->waveform & OPL3_WAVE_SELECT_MASK;\r\nopl3_reg = reg_side | (OPL3_REG_WAVE_SELECT + op_offset);\r\nopl3->command(opl3, opl3_reg, reg_val);\r\nreturn 0;\r\n}\r\nstatic int snd_opl3_set_params(struct snd_opl3 * opl3, struct snd_dm_fm_params * params)\r\n{\r\nunsigned char reg_val;\r\nreg_val = 0x00;\r\nif (params->kbd_split)\r\nreg_val |= OPL3_KEYBOARD_SPLIT;\r\nopl3->command(opl3, OPL3_LEFT | OPL3_REG_KBD_SPLIT, reg_val);\r\nreg_val = 0x00;\r\nif (params->am_depth)\r\nreg_val |= OPL3_TREMOLO_DEPTH;\r\nif (params->vib_depth)\r\nreg_val |= OPL3_VIBRATO_DEPTH;\r\nif (params->rhythm) {\r\nreg_val |= OPL3_PERCUSSION_ENABLE;\r\nopl3->rhythm = 1;\r\n} else {\r\nopl3->rhythm = 0;\r\n}\r\nif (params->bass)\r\nreg_val |= OPL3_BASSDRUM_ON;\r\nif (params->snare)\r\nreg_val |= OPL3_SNAREDRUM_ON;\r\nif (params->tomtom)\r\nreg_val |= OPL3_TOMTOM_ON;\r\nif (params->cymbal)\r\nreg_val |= OPL3_CYMBAL_ON;\r\nif (params->hihat)\r\nreg_val |= OPL3_HIHAT_ON;\r\nopl3->command(opl3, OPL3_LEFT | OPL3_REG_PERCUSSION, reg_val);\r\nreturn 0;\r\n}\r\nstatic int snd_opl3_set_mode(struct snd_opl3 * opl3, int mode)\r\n{\r\nif ((mode == SNDRV_DM_FM_MODE_OPL3) && (opl3->hardware < OPL3_HW_OPL3))\r\nreturn -EINVAL;\r\nopl3->fm_mode = mode;\r\nif (opl3->hardware >= OPL3_HW_OPL3)\r\nopl3->command(opl3, OPL3_RIGHT | OPL3_REG_CONNECTION_SELECT, 0x00);\r\nreturn 0;\r\n}\r\nstatic int snd_opl3_set_connection(struct snd_opl3 * opl3, int connection)\r\n{\r\nunsigned char reg_val;\r\nif (opl3->fm_mode != SNDRV_DM_FM_MODE_OPL3)\r\nreturn -EINVAL;\r\nreg_val = connection & (OPL3_RIGHT_4OP_0 | OPL3_RIGHT_4OP_1 | OPL3_RIGHT_4OP_2 |\r\nOPL3_LEFT_4OP_0 | OPL3_LEFT_4OP_1 | OPL3_LEFT_4OP_2);\r\nopl3->command(opl3, OPL3_RIGHT | OPL3_REG_CONNECTION_SELECT, reg_val);\r\nreturn 0;\r\n}
