int zlib_deflateInit2(\r\nz_streamp strm,\r\nint level,\r\nint method,\r\nint windowBits,\r\nint memLevel,\r\nint strategy\r\n)\r\n{\r\ndeflate_state *s;\r\nint noheader = 0;\r\ndeflate_workspace *mem;\r\nchar *next;\r\nush *overlay;\r\nif (strm == NULL) return Z_STREAM_ERROR;\r\nstrm->msg = NULL;\r\nif (level == Z_DEFAULT_COMPRESSION) level = 6;\r\nmem = (deflate_workspace *) strm->workspace;\r\nif (windowBits < 0) {\r\nnoheader = 1;\r\nwindowBits = -windowBits;\r\n}\r\nif (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method != Z_DEFLATED ||\r\nwindowBits < 9 || windowBits > 15 || level < 0 || level > 9 ||\r\nstrategy < 0 || strategy > Z_HUFFMAN_ONLY) {\r\nreturn Z_STREAM_ERROR;\r\n}\r\nnext = (char *) mem;\r\nnext += sizeof(*mem);\r\nmem->window_memory = (Byte *) next;\r\nnext += zlib_deflate_window_memsize(windowBits);\r\nmem->prev_memory = (Pos *) next;\r\nnext += zlib_deflate_prev_memsize(windowBits);\r\nmem->head_memory = (Pos *) next;\r\nnext += zlib_deflate_head_memsize(memLevel);\r\nmem->overlay_memory = next;\r\ns = (deflate_state *) &(mem->deflate_memory);\r\nstrm->state = (struct internal_state *)s;\r\ns->strm = strm;\r\ns->noheader = noheader;\r\ns->w_bits = windowBits;\r\ns->w_size = 1 << s->w_bits;\r\ns->w_mask = s->w_size - 1;\r\ns->hash_bits = memLevel + 7;\r\ns->hash_size = 1 << s->hash_bits;\r\ns->hash_mask = s->hash_size - 1;\r\ns->hash_shift = ((s->hash_bits+MIN_MATCH-1)/MIN_MATCH);\r\ns->window = (Byte *) mem->window_memory;\r\ns->prev = (Pos *) mem->prev_memory;\r\ns->head = (Pos *) mem->head_memory;\r\ns->lit_bufsize = 1 << (memLevel + 6);\r\noverlay = (ush *) mem->overlay_memory;\r\ns->pending_buf = (uch *) overlay;\r\ns->pending_buf_size = (ulg)s->lit_bufsize * (sizeof(ush)+2L);\r\ns->d_buf = overlay + s->lit_bufsize/sizeof(ush);\r\ns->l_buf = s->pending_buf + (1+sizeof(ush))*s->lit_bufsize;\r\ns->level = level;\r\ns->strategy = strategy;\r\ns->method = (Byte)method;\r\nreturn zlib_deflateReset(strm);\r\n}\r\nint zlib_deflateReset(\r\nz_streamp strm\r\n)\r\n{\r\ndeflate_state *s;\r\nif (strm == NULL || strm->state == NULL)\r\nreturn Z_STREAM_ERROR;\r\nstrm->total_in = strm->total_out = 0;\r\nstrm->msg = NULL;\r\nstrm->data_type = Z_UNKNOWN;\r\ns = (deflate_state *)strm->state;\r\ns->pending = 0;\r\ns->pending_out = s->pending_buf;\r\nif (s->noheader < 0) {\r\ns->noheader = 0;\r\n}\r\ns->status = s->noheader ? BUSY_STATE : INIT_STATE;\r\nstrm->adler = 1;\r\ns->last_flush = Z_NO_FLUSH;\r\nzlib_tr_init(s);\r\nlm_init(s);\r\nreturn Z_OK;\r\n}\r\nstatic void putShortMSB(\r\ndeflate_state *s,\r\nuInt b\r\n)\r\n{\r\nput_byte(s, (Byte)(b >> 8));\r\nput_byte(s, (Byte)(b & 0xff));\r\n}\r\nstatic void flush_pending(\r\nz_streamp strm\r\n)\r\n{\r\ndeflate_state *s = (deflate_state *) strm->state;\r\nunsigned len = s->pending;\r\nif (len > strm->avail_out) len = strm->avail_out;\r\nif (len == 0) return;\r\nif (strm->next_out != NULL) {\r\nmemcpy(strm->next_out, s->pending_out, len);\r\nstrm->next_out += len;\r\n}\r\ns->pending_out += len;\r\nstrm->total_out += len;\r\nstrm->avail_out -= len;\r\ns->pending -= len;\r\nif (s->pending == 0) {\r\ns->pending_out = s->pending_buf;\r\n}\r\n}\r\nint zlib_deflate(\r\nz_streamp strm,\r\nint flush\r\n)\r\n{\r\nint old_flush;\r\ndeflate_state *s;\r\nif (strm == NULL || strm->state == NULL ||\r\nflush > Z_FINISH || flush < 0) {\r\nreturn Z_STREAM_ERROR;\r\n}\r\ns = (deflate_state *) strm->state;\r\nif ((strm->next_in == NULL && strm->avail_in != 0) ||\r\n(s->status == FINISH_STATE && flush != Z_FINISH)) {\r\nreturn Z_STREAM_ERROR;\r\n}\r\nif (strm->avail_out == 0) return Z_BUF_ERROR;\r\ns->strm = strm;\r\nold_flush = s->last_flush;\r\ns->last_flush = flush;\r\nif (s->status == INIT_STATE) {\r\nuInt header = (Z_DEFLATED + ((s->w_bits-8)<<4)) << 8;\r\nuInt level_flags = (s->level-1) >> 1;\r\nif (level_flags > 3) level_flags = 3;\r\nheader |= (level_flags << 6);\r\nif (s->strstart != 0) header |= PRESET_DICT;\r\nheader += 31 - (header % 31);\r\ns->status = BUSY_STATE;\r\nputShortMSB(s, header);\r\nif (s->strstart != 0) {\r\nputShortMSB(s, (uInt)(strm->adler >> 16));\r\nputShortMSB(s, (uInt)(strm->adler & 0xffff));\r\n}\r\nstrm->adler = 1L;\r\n}\r\nif (s->pending != 0) {\r\nflush_pending(strm);\r\nif (strm->avail_out == 0) {\r\ns->last_flush = -1;\r\nreturn Z_OK;\r\n}\r\n} else if (strm->avail_in == 0 && flush <= old_flush &&\r\nflush != Z_FINISH) {\r\nreturn Z_BUF_ERROR;\r\n}\r\nif (s->status == FINISH_STATE && strm->avail_in != 0) {\r\nreturn Z_BUF_ERROR;\r\n}\r\nif (strm->avail_in != 0 || s->lookahead != 0 ||\r\n(flush != Z_NO_FLUSH && s->status != FINISH_STATE)) {\r\nblock_state bstate;\r\nbstate = (*(configuration_table[s->level].func))(s, flush);\r\nif (bstate == finish_started || bstate == finish_done) {\r\ns->status = FINISH_STATE;\r\n}\r\nif (bstate == need_more || bstate == finish_started) {\r\nif (strm->avail_out == 0) {\r\ns->last_flush = -1;\r\n}\r\nreturn Z_OK;\r\n}\r\nif (bstate == block_done) {\r\nif (flush == Z_PARTIAL_FLUSH) {\r\nzlib_tr_align(s);\r\n} else if (flush == Z_PACKET_FLUSH) {\r\nzlib_tr_stored_type_only(s);\r\n} else {\r\nzlib_tr_stored_block(s, (char*)0, 0L, 0);\r\nif (flush == Z_FULL_FLUSH) {\r\nCLEAR_HASH(s);\r\n}\r\n}\r\nflush_pending(strm);\r\nif (strm->avail_out == 0) {\r\ns->last_flush = -1;\r\nreturn Z_OK;\r\n}\r\n}\r\n}\r\nAssert(strm->avail_out > 0, "bug2");\r\nif (flush != Z_FINISH) return Z_OK;\r\nif (s->noheader) return Z_STREAM_END;\r\nputShortMSB(s, (uInt)(strm->adler >> 16));\r\nputShortMSB(s, (uInt)(strm->adler & 0xffff));\r\nflush_pending(strm);\r\ns->noheader = -1;\r\nreturn s->pending != 0 ? Z_OK : Z_STREAM_END;\r\n}\r\nint zlib_deflateEnd(\r\nz_streamp strm\r\n)\r\n{\r\nint status;\r\ndeflate_state *s;\r\nif (strm == NULL || strm->state == NULL) return Z_STREAM_ERROR;\r\ns = (deflate_state *) strm->state;\r\nstatus = s->status;\r\nif (status != INIT_STATE && status != BUSY_STATE &&\r\nstatus != FINISH_STATE) {\r\nreturn Z_STREAM_ERROR;\r\n}\r\nstrm->state = NULL;\r\nreturn status == BUSY_STATE ? Z_DATA_ERROR : Z_OK;\r\n}\r\nstatic int read_buf(\r\nz_streamp strm,\r\nByte *buf,\r\nunsigned size\r\n)\r\n{\r\nunsigned len = strm->avail_in;\r\nif (len > size) len = size;\r\nif (len == 0) return 0;\r\nstrm->avail_in -= len;\r\nif (!((deflate_state *)(strm->state))->noheader) {\r\nstrm->adler = zlib_adler32(strm->adler, strm->next_in, len);\r\n}\r\nmemcpy(buf, strm->next_in, len);\r\nstrm->next_in += len;\r\nstrm->total_in += len;\r\nreturn (int)len;\r\n}\r\nstatic void lm_init(\r\ndeflate_state *s\r\n)\r\n{\r\ns->window_size = (ulg)2L*s->w_size;\r\nCLEAR_HASH(s);\r\ns->max_lazy_match = configuration_table[s->level].max_lazy;\r\ns->good_match = configuration_table[s->level].good_length;\r\ns->nice_match = configuration_table[s->level].nice_length;\r\ns->max_chain_length = configuration_table[s->level].max_chain;\r\ns->strstart = 0;\r\ns->block_start = 0L;\r\ns->lookahead = 0;\r\ns->match_length = s->prev_length = MIN_MATCH-1;\r\ns->match_available = 0;\r\ns->ins_h = 0;\r\n}\r\nstatic uInt longest_match(\r\ndeflate_state *s,\r\nIPos cur_match\r\n)\r\n{\r\nunsigned chain_length = s->max_chain_length;\r\nregister Byte *scan = s->window + s->strstart;\r\nregister Byte *match;\r\nregister int len;\r\nint best_len = s->prev_length;\r\nint nice_match = s->nice_match;\r\nIPos limit = s->strstart > (IPos)MAX_DIST(s) ?\r\ns->strstart - (IPos)MAX_DIST(s) : NIL;\r\nPos *prev = s->prev;\r\nuInt wmask = s->w_mask;\r\n#ifdef UNALIGNED_OK\r\nregister Byte *strend = s->window + s->strstart + MAX_MATCH - 1;\r\nregister ush scan_start = *(ush*)scan;\r\nregister ush scan_end = *(ush*)(scan+best_len-1);\r\n#else\r\nregister Byte *strend = s->window + s->strstart + MAX_MATCH;\r\nregister Byte scan_end1 = scan[best_len-1];\r\nregister Byte scan_end = scan[best_len];\r\n#endif\r\nAssert(s->hash_bits >= 8 && MAX_MATCH == 258, "Code too clever");\r\nif (s->prev_length >= s->good_match) {\r\nchain_length >>= 2;\r\n}\r\nif ((uInt)nice_match > s->lookahead) nice_match = s->lookahead;\r\nAssert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, "need lookahead");\r\ndo {\r\nAssert(cur_match < s->strstart, "no future");\r\nmatch = s->window + cur_match;\r\n#if (defined(UNALIGNED_OK) && MAX_MATCH == 258)\r\nif (*(ush*)(match+best_len-1) != scan_end ||\r\n*(ush*)match != scan_start) continue;\r\nAssert(scan[2] == match[2], "scan[2]?");\r\nscan++, match++;\r\ndo {\r\n} while (*(ush*)(scan+=2) == *(ush*)(match+=2) &&\r\n*(ush*)(scan+=2) == *(ush*)(match+=2) &&\r\n*(ush*)(scan+=2) == *(ush*)(match+=2) &&\r\n*(ush*)(scan+=2) == *(ush*)(match+=2) &&\r\nscan < strend);\r\nAssert(scan <= s->window+(unsigned)(s->window_size-1), "wild scan");\r\nif (*scan == *match) scan++;\r\nlen = (MAX_MATCH - 1) - (int)(strend-scan);\r\nscan = strend - (MAX_MATCH-1);\r\n#else\r\nif (match[best_len] != scan_end ||\r\nmatch[best_len-1] != scan_end1 ||\r\n*match != *scan ||\r\n*++match != scan[1]) continue;\r\nscan += 2, match++;\r\nAssert(*scan == *match, "match[2]?");\r\ndo {\r\n} while (*++scan == *++match && *++scan == *++match &&\r\n*++scan == *++match && *++scan == *++match &&\r\n*++scan == *++match && *++scan == *++match &&\r\n*++scan == *++match && *++scan == *++match &&\r\nscan < strend);\r\nAssert(scan <= s->window+(unsigned)(s->window_size-1), "wild scan");\r\nlen = MAX_MATCH - (int)(strend - scan);\r\nscan = strend - MAX_MATCH;\r\n#endif\r\nif (len > best_len) {\r\ns->match_start = cur_match;\r\nbest_len = len;\r\nif (len >= nice_match) break;\r\n#ifdef UNALIGNED_OK\r\nscan_end = *(ush*)(scan+best_len-1);\r\n#else\r\nscan_end1 = scan[best_len-1];\r\nscan_end = scan[best_len];\r\n#endif\r\n}\r\n} while ((cur_match = prev[cur_match & wmask]) > limit\r\n&& --chain_length != 0);\r\nif ((uInt)best_len <= s->lookahead) return best_len;\r\nreturn s->lookahead;\r\n}\r\nstatic void check_match(\r\ndeflate_state *s,\r\nIPos start,\r\nIPos match,\r\nint length\r\n)\r\n{\r\nif (memcmp((char *)s->window + match,\r\n(char *)s->window + start, length) != EQUAL) {\r\nfprintf(stderr, " start %u, match %u, length %d\n",\r\nstart, match, length);\r\ndo {\r\nfprintf(stderr, "%c%c", s->window[match++], s->window[start++]);\r\n} while (--length != 0);\r\nz_error("invalid match");\r\n}\r\nif (z_verbose > 1) {\r\nfprintf(stderr,"\\[%d,%d]", start-match, length);\r\ndo { putc(s->window[start++], stderr); } while (--length != 0);\r\n}\r\n}\r\nstatic void fill_window(\r\ndeflate_state *s\r\n)\r\n{\r\nregister unsigned n, m;\r\nregister Pos *p;\r\nunsigned more;\r\nuInt wsize = s->w_size;\r\ndo {\r\nmore = (unsigned)(s->window_size -(ulg)s->lookahead -(ulg)s->strstart);\r\nif (more == 0 && s->strstart == 0 && s->lookahead == 0) {\r\nmore = wsize;\r\n} else if (more == (unsigned)(-1)) {\r\nmore--;\r\n} else if (s->strstart >= wsize+MAX_DIST(s)) {\r\nmemcpy((char *)s->window, (char *)s->window+wsize,\r\n(unsigned)wsize);\r\ns->match_start -= wsize;\r\ns->strstart -= wsize;\r\ns->block_start -= (long) wsize;\r\nn = s->hash_size;\r\np = &s->head[n];\r\ndo {\r\nm = *--p;\r\n*p = (Pos)(m >= wsize ? m-wsize : NIL);\r\n} while (--n);\r\nn = wsize;\r\np = &s->prev[n];\r\ndo {\r\nm = *--p;\r\n*p = (Pos)(m >= wsize ? m-wsize : NIL);\r\n} while (--n);\r\nmore += wsize;\r\n}\r\nif (s->strm->avail_in == 0) return;\r\nAssert(more >= 2, "more < 2");\r\nn = read_buf(s->strm, s->window + s->strstart + s->lookahead, more);\r\ns->lookahead += n;\r\nif (s->lookahead >= MIN_MATCH) {\r\ns->ins_h = s->window[s->strstart];\r\nUPDATE_HASH(s, s->ins_h, s->window[s->strstart+1]);\r\n#if MIN_MATCH != 3\r\nCall UPDATE_HASH() MIN_MATCH-3 more times\r\n#endif\r\n}\r\n} while (s->lookahead < MIN_LOOKAHEAD && s->strm->avail_in != 0);\r\n}\r\nstatic block_state deflate_stored(\r\ndeflate_state *s,\r\nint flush\r\n)\r\n{\r\nulg max_block_size = 0xffff;\r\nulg max_start;\r\nif (max_block_size > s->pending_buf_size - 5) {\r\nmax_block_size = s->pending_buf_size - 5;\r\n}\r\nfor (;;) {\r\nif (s->lookahead <= 1) {\r\nAssert(s->strstart < s->w_size+MAX_DIST(s) ||\r\ns->block_start >= (long)s->w_size, "slide too late");\r\nfill_window(s);\r\nif (s->lookahead == 0 && flush == Z_NO_FLUSH) return need_more;\r\nif (s->lookahead == 0) break;\r\n}\r\nAssert(s->block_start >= 0L, "block gone");\r\ns->strstart += s->lookahead;\r\ns->lookahead = 0;\r\nmax_start = s->block_start + max_block_size;\r\nif (s->strstart == 0 || (ulg)s->strstart >= max_start) {\r\ns->lookahead = (uInt)(s->strstart - max_start);\r\ns->strstart = (uInt)max_start;\r\nFLUSH_BLOCK(s, 0);\r\n}\r\nif (s->strstart - (uInt)s->block_start >= MAX_DIST(s)) {\r\nFLUSH_BLOCK(s, 0);\r\n}\r\n}\r\nFLUSH_BLOCK(s, flush == Z_FINISH);\r\nreturn flush == Z_FINISH ? finish_done : block_done;\r\n}\r\nstatic block_state deflate_fast(\r\ndeflate_state *s,\r\nint flush\r\n)\r\n{\r\nIPos hash_head = NIL;\r\nint bflush;\r\nfor (;;) {\r\nif (s->lookahead < MIN_LOOKAHEAD) {\r\nfill_window(s);\r\nif (s->lookahead < MIN_LOOKAHEAD && flush == Z_NO_FLUSH) {\r\nreturn need_more;\r\n}\r\nif (s->lookahead == 0) break;\r\n}\r\nif (s->lookahead >= MIN_MATCH) {\r\nINSERT_STRING(s, s->strstart, hash_head);\r\n}\r\nif (hash_head != NIL && s->strstart - hash_head <= MAX_DIST(s)) {\r\nif (s->strategy != Z_HUFFMAN_ONLY) {\r\ns->match_length = longest_match (s, hash_head);\r\n}\r\n}\r\nif (s->match_length >= MIN_MATCH) {\r\ncheck_match(s, s->strstart, s->match_start, s->match_length);\r\nbflush = zlib_tr_tally(s, s->strstart - s->match_start,\r\ns->match_length - MIN_MATCH);\r\ns->lookahead -= s->match_length;\r\nif (s->match_length <= s->max_insert_length &&\r\ns->lookahead >= MIN_MATCH) {\r\ns->match_length--;\r\ndo {\r\ns->strstart++;\r\nINSERT_STRING(s, s->strstart, hash_head);\r\n} while (--s->match_length != 0);\r\ns->strstart++;\r\n} else {\r\ns->strstart += s->match_length;\r\ns->match_length = 0;\r\ns->ins_h = s->window[s->strstart];\r\nUPDATE_HASH(s, s->ins_h, s->window[s->strstart+1]);\r\n#if MIN_MATCH != 3\r\nCall UPDATE_HASH() MIN_MATCH-3 more times\r\n#endif\r\n}\r\n} else {\r\nTracevv((stderr,"%c", s->window[s->strstart]));\r\nbflush = zlib_tr_tally (s, 0, s->window[s->strstart]);\r\ns->lookahead--;\r\ns->strstart++;\r\n}\r\nif (bflush) FLUSH_BLOCK(s, 0);\r\n}\r\nFLUSH_BLOCK(s, flush == Z_FINISH);\r\nreturn flush == Z_FINISH ? finish_done : block_done;\r\n}\r\nstatic block_state deflate_slow(\r\ndeflate_state *s,\r\nint flush\r\n)\r\n{\r\nIPos hash_head = NIL;\r\nint bflush;\r\nfor (;;) {\r\nif (s->lookahead < MIN_LOOKAHEAD) {\r\nfill_window(s);\r\nif (s->lookahead < MIN_LOOKAHEAD && flush == Z_NO_FLUSH) {\r\nreturn need_more;\r\n}\r\nif (s->lookahead == 0) break;\r\n}\r\nif (s->lookahead >= MIN_MATCH) {\r\nINSERT_STRING(s, s->strstart, hash_head);\r\n}\r\ns->prev_length = s->match_length, s->prev_match = s->match_start;\r\ns->match_length = MIN_MATCH-1;\r\nif (hash_head != NIL && s->prev_length < s->max_lazy_match &&\r\ns->strstart - hash_head <= MAX_DIST(s)) {\r\nif (s->strategy != Z_HUFFMAN_ONLY) {\r\ns->match_length = longest_match (s, hash_head);\r\n}\r\nif (s->match_length <= 5 && (s->strategy == Z_FILTERED ||\r\n(s->match_length == MIN_MATCH &&\r\ns->strstart - s->match_start > TOO_FAR))) {\r\ns->match_length = MIN_MATCH-1;\r\n}\r\n}\r\nif (s->prev_length >= MIN_MATCH && s->match_length <= s->prev_length) {\r\nuInt max_insert = s->strstart + s->lookahead - MIN_MATCH;\r\ncheck_match(s, s->strstart-1, s->prev_match, s->prev_length);\r\nbflush = zlib_tr_tally(s, s->strstart -1 - s->prev_match,\r\ns->prev_length - MIN_MATCH);\r\ns->lookahead -= s->prev_length-1;\r\ns->prev_length -= 2;\r\ndo {\r\nif (++s->strstart <= max_insert) {\r\nINSERT_STRING(s, s->strstart, hash_head);\r\n}\r\n} while (--s->prev_length != 0);\r\ns->match_available = 0;\r\ns->match_length = MIN_MATCH-1;\r\ns->strstart++;\r\nif (bflush) FLUSH_BLOCK(s, 0);\r\n} else if (s->match_available) {\r\nTracevv((stderr,"%c", s->window[s->strstart-1]));\r\nif (zlib_tr_tally (s, 0, s->window[s->strstart-1])) {\r\nFLUSH_BLOCK_ONLY(s, 0);\r\n}\r\ns->strstart++;\r\ns->lookahead--;\r\nif (s->strm->avail_out == 0) return need_more;\r\n} else {\r\ns->match_available = 1;\r\ns->strstart++;\r\ns->lookahead--;\r\n}\r\n}\r\nAssert (flush != Z_NO_FLUSH, "no flush?");\r\nif (s->match_available) {\r\nTracevv((stderr,"%c", s->window[s->strstart-1]));\r\nzlib_tr_tally (s, 0, s->window[s->strstart-1]);\r\ns->match_available = 0;\r\n}\r\nFLUSH_BLOCK(s, flush == Z_FINISH);\r\nreturn flush == Z_FINISH ? finish_done : block_done;\r\n}\r\nint zlib_deflate_workspacesize(int windowBits, int memLevel)\r\n{\r\nif (windowBits < 0)\r\nwindowBits = -windowBits;\r\nBUG_ON(memLevel < 1 || memLevel > MAX_MEM_LEVEL || windowBits < 9 ||\r\nwindowBits > 15);\r\nreturn sizeof(deflate_workspace)\r\n+ zlib_deflate_window_memsize(windowBits)\r\n+ zlib_deflate_prev_memsize(windowBits)\r\n+ zlib_deflate_head_memsize(memLevel)\r\n+ zlib_deflate_overlay_memsize(memLevel);\r\n}
