static inline void append_dec_op1(u32 *desc, u32 type)\r\n{\r\nu32 *jump_cmd, *uncond_jump_cmd;\r\nif ((type & OP_ALG_ALGSEL_MASK) != OP_ALG_ALGSEL_AES) {\r\nappend_operation(desc, type | OP_ALG_AS_INITFINAL |\r\nOP_ALG_DECRYPT);\r\nreturn;\r\n}\r\njump_cmd = append_jump(desc, JUMP_TEST_ALL | JUMP_COND_SHRD);\r\nappend_operation(desc, type | OP_ALG_AS_INITFINAL |\r\nOP_ALG_DECRYPT);\r\nuncond_jump_cmd = append_jump(desc, JUMP_TEST_ALL);\r\nset_jump_tgt_here(desc, jump_cmd);\r\nappend_operation(desc, type | OP_ALG_AS_INITFINAL |\r\nOP_ALG_DECRYPT | OP_ALG_AAI_DK);\r\nset_jump_tgt_here(desc, uncond_jump_cmd);\r\n}\r\nstatic inline void aead_append_src_dst(u32 *desc, u32 msg_type)\r\n{\r\nappend_seq_fifo_store(desc, 0, FIFOST_TYPE_MESSAGE_DATA | KEY_VLF);\r\nappend_seq_fifo_load(desc, 0, FIFOLD_CLASS_BOTH |\r\nKEY_VLF | msg_type | FIFOLD_TYPE_LASTBOTH);\r\n}\r\nstatic inline void aead_append_ld_iv(u32 *desc, int ivsize, int ivoffset)\r\n{\r\nappend_seq_load(desc, ivsize, LDST_CLASS_1_CCB |\r\nLDST_SRCDST_BYTE_CONTEXT |\r\n(ivoffset << LDST_OFFSET_SHIFT));\r\nappend_move(desc, MOVE_SRC_CLASS1CTX | MOVE_DEST_CLASS2INFIFO |\r\n(ivoffset << MOVE_OFFSET_SHIFT) | ivsize);\r\n}\r\nstatic inline void ablkcipher_append_src_dst(u32 *desc)\r\n{\r\nappend_math_add(desc, VARSEQOUTLEN, SEQINLEN, REG0, CAAM_CMD_SZ);\r\nappend_math_add(desc, VARSEQINLEN, SEQINLEN, REG0, CAAM_CMD_SZ);\r\nappend_seq_fifo_load(desc, 0, FIFOLD_CLASS_CLASS1 |\r\nKEY_VLF | FIFOLD_TYPE_MSG | FIFOLD_TYPE_LAST1);\r\nappend_seq_fifo_store(desc, 0, FIFOST_TYPE_MESSAGE_DATA | KEY_VLF);\r\n}\r\nstatic void append_key_aead(u32 *desc, struct caam_ctx *ctx,\r\nint keys_fit_inline, bool is_rfc3686)\r\n{\r\nu32 *nonce;\r\nunsigned int enckeylen = ctx->enckeylen;\r\nif (is_rfc3686)\r\nenckeylen -= CTR_RFC3686_NONCE_SIZE;\r\nif (keys_fit_inline) {\r\nappend_key_as_imm(desc, ctx->key, ctx->split_key_pad_len,\r\nctx->split_key_len, CLASS_2 |\r\nKEY_DEST_MDHA_SPLIT | KEY_ENC);\r\nappend_key_as_imm(desc, (void *)ctx->key +\r\nctx->split_key_pad_len, enckeylen,\r\nenckeylen, CLASS_1 | KEY_DEST_CLASS_REG);\r\n} else {\r\nappend_key(desc, ctx->key_dma, ctx->split_key_len, CLASS_2 |\r\nKEY_DEST_MDHA_SPLIT | KEY_ENC);\r\nappend_key(desc, ctx->key_dma + ctx->split_key_pad_len,\r\nenckeylen, CLASS_1 | KEY_DEST_CLASS_REG);\r\n}\r\nif (is_rfc3686) {\r\nnonce = (u32 *)((void *)ctx->key + ctx->split_key_pad_len +\r\nenckeylen);\r\nappend_load_imm_u32(desc, *nonce, LDST_CLASS_IND_CCB |\r\nLDST_SRCDST_BYTE_OUTFIFO | LDST_IMM);\r\nappend_move(desc,\r\nMOVE_SRC_OUTFIFO |\r\nMOVE_DEST_CLASS1CTX |\r\n(16 << MOVE_OFFSET_SHIFT) |\r\n(CTR_RFC3686_NONCE_SIZE << MOVE_LEN_SHIFT));\r\n}\r\n}\r\nstatic void init_sh_desc_key_aead(u32 *desc, struct caam_ctx *ctx,\r\nint keys_fit_inline, bool is_rfc3686)\r\n{\r\nu32 *key_jump_cmd;\r\ninit_sh_desc(desc, HDR_SHARE_SERIAL | HDR_SAVECTX);\r\nkey_jump_cmd = append_jump(desc, JUMP_JSL | JUMP_TEST_ALL |\r\nJUMP_COND_SHRD);\r\nappend_key_aead(desc, ctx, keys_fit_inline, is_rfc3686);\r\nset_jump_tgt_here(desc, key_jump_cmd);\r\n}\r\nstatic int aead_null_set_sh_desc(struct crypto_aead *aead)\r\n{\r\nstruct aead_tfm *tfm = &aead->base.crt_aead;\r\nstruct caam_ctx *ctx = crypto_aead_ctx(aead);\r\nstruct device *jrdev = ctx->jrdev;\r\nbool keys_fit_inline = false;\r\nu32 *key_jump_cmd, *jump_cmd, *read_move_cmd, *write_move_cmd;\r\nu32 *desc;\r\nif (DESC_AEAD_NULL_ENC_LEN + DESC_JOB_IO_LEN +\r\nctx->split_key_pad_len <= CAAM_DESC_BYTES_MAX)\r\nkeys_fit_inline = true;\r\ndesc = ctx->sh_desc_enc;\r\ninit_sh_desc(desc, HDR_SHARE_SERIAL);\r\nkey_jump_cmd = append_jump(desc, JUMP_JSL | JUMP_TEST_ALL |\r\nJUMP_COND_SHRD);\r\nif (keys_fit_inline)\r\nappend_key_as_imm(desc, ctx->key, ctx->split_key_pad_len,\r\nctx->split_key_len, CLASS_2 |\r\nKEY_DEST_MDHA_SPLIT | KEY_ENC);\r\nelse\r\nappend_key(desc, ctx->key_dma, ctx->split_key_len, CLASS_2 |\r\nKEY_DEST_MDHA_SPLIT | KEY_ENC);\r\nset_jump_tgt_here(desc, key_jump_cmd);\r\nappend_math_sub_imm_u32(desc, REG3, SEQOUTLEN, IMM, ctx->authsize);\r\nappend_math_sub(desc, VARSEQINLEN, SEQINLEN, REG3, CAAM_CMD_SZ);\r\nappend_seq_fifo_load(desc, 0, FIFOLD_CLASS_CLASS2 | FIFOLD_TYPE_MSG |\r\nKEY_VLF);\r\nappend_math_add(desc, VARSEQINLEN, ZERO, REG3, CAAM_CMD_SZ);\r\nappend_math_add(desc, VARSEQOUTLEN, ZERO, REG3, CAAM_CMD_SZ);\r\nread_move_cmd = append_move(desc, MOVE_SRC_DESCBUF |\r\nMOVE_DEST_MATH3 |\r\n(0x6 << MOVE_LEN_SHIFT));\r\nwrite_move_cmd = append_move(desc, MOVE_SRC_MATH3 |\r\nMOVE_DEST_DESCBUF |\r\nMOVE_WAITCOMP |\r\n(0x8 << MOVE_LEN_SHIFT));\r\nappend_operation(desc, ctx->class2_alg_type |\r\nOP_ALG_AS_INITFINAL | OP_ALG_ENCRYPT);\r\naead_append_src_dst(desc, FIFOLD_TYPE_MSG | FIFOLD_TYPE_FLUSH1);\r\nset_move_tgt_here(desc, read_move_cmd);\r\nset_move_tgt_here(desc, write_move_cmd);\r\nappend_cmd(desc, CMD_LOAD | DISABLE_AUTO_INFO_FIFO);\r\nappend_move(desc, MOVE_SRC_INFIFO_CL | MOVE_DEST_OUTFIFO |\r\nMOVE_AUX_LS);\r\nappend_seq_store(desc, ctx->authsize, LDST_CLASS_2_CCB |\r\nLDST_SRCDST_BYTE_CONTEXT);\r\nctx->sh_desc_enc_dma = dma_map_single(jrdev, desc,\r\ndesc_bytes(desc),\r\nDMA_TO_DEVICE);\r\nif (dma_mapping_error(jrdev, ctx->sh_desc_enc_dma)) {\r\ndev_err(jrdev, "unable to map shared descriptor\n");\r\nreturn -ENOMEM;\r\n}\r\n#ifdef DEBUG\r\nprint_hex_dump(KERN_ERR,\r\n"aead null enc shdesc@"__stringify(__LINE__)": ",\r\nDUMP_PREFIX_ADDRESS, 16, 4, desc,\r\ndesc_bytes(desc), 1);\r\n#endif\r\nkeys_fit_inline = false;\r\nif (DESC_AEAD_NULL_DEC_LEN + DESC_JOB_IO_LEN +\r\nctx->split_key_pad_len <= CAAM_DESC_BYTES_MAX)\r\nkeys_fit_inline = true;\r\ndesc = ctx->sh_desc_dec;\r\ninit_sh_desc(desc, HDR_SHARE_SERIAL);\r\nkey_jump_cmd = append_jump(desc, JUMP_JSL | JUMP_TEST_ALL |\r\nJUMP_COND_SHRD);\r\nif (keys_fit_inline)\r\nappend_key_as_imm(desc, ctx->key, ctx->split_key_pad_len,\r\nctx->split_key_len, CLASS_2 |\r\nKEY_DEST_MDHA_SPLIT | KEY_ENC);\r\nelse\r\nappend_key(desc, ctx->key_dma, ctx->split_key_len, CLASS_2 |\r\nKEY_DEST_MDHA_SPLIT | KEY_ENC);\r\nset_jump_tgt_here(desc, key_jump_cmd);\r\nappend_operation(desc, ctx->class2_alg_type |\r\nOP_ALG_AS_INITFINAL | OP_ALG_DECRYPT | OP_ALG_ICV_ON);\r\nappend_math_sub_imm_u32(desc, REG3, SEQINLEN, IMM,\r\nctx->authsize + tfm->ivsize);\r\nappend_math_sub(desc, REG2, SEQOUTLEN, REG0, CAAM_CMD_SZ);\r\nappend_math_sub(desc, VARSEQINLEN, REG3, REG2, CAAM_CMD_SZ);\r\nappend_seq_fifo_load(desc, 0, FIFOLD_CLASS_CLASS2 | FIFOLD_TYPE_MSG |\r\nKEY_VLF);\r\nappend_math_add(desc, VARSEQINLEN, ZERO, REG2, CAAM_CMD_SZ);\r\nappend_math_add(desc, VARSEQOUTLEN, ZERO, REG2, CAAM_CMD_SZ);\r\nread_move_cmd = append_move(desc, MOVE_SRC_DESCBUF |\r\nMOVE_DEST_MATH2 |\r\n(0x6 << MOVE_LEN_SHIFT));\r\nwrite_move_cmd = append_move(desc, MOVE_SRC_MATH2 |\r\nMOVE_DEST_DESCBUF |\r\nMOVE_WAITCOMP |\r\n(0x8 << MOVE_LEN_SHIFT));\r\naead_append_src_dst(desc, FIFOLD_TYPE_MSG | FIFOLD_TYPE_FLUSH1);\r\njump_cmd = append_jump(desc, JUMP_TEST_ALL);\r\nset_jump_tgt_here(desc, jump_cmd);\r\nset_move_tgt_here(desc, read_move_cmd);\r\nset_move_tgt_here(desc, write_move_cmd);\r\nappend_cmd(desc, CMD_LOAD | DISABLE_AUTO_INFO_FIFO);\r\nappend_move(desc, MOVE_SRC_INFIFO_CL | MOVE_DEST_OUTFIFO |\r\nMOVE_AUX_LS);\r\nappend_cmd(desc, CMD_LOAD | ENABLE_AUTO_INFO_FIFO);\r\nappend_seq_fifo_load(desc, ctx->authsize, FIFOLD_CLASS_CLASS2 |\r\nFIFOLD_TYPE_LAST2 | FIFOLD_TYPE_ICV);\r\nctx->sh_desc_dec_dma = dma_map_single(jrdev, desc,\r\ndesc_bytes(desc),\r\nDMA_TO_DEVICE);\r\nif (dma_mapping_error(jrdev, ctx->sh_desc_dec_dma)) {\r\ndev_err(jrdev, "unable to map shared descriptor\n");\r\nreturn -ENOMEM;\r\n}\r\n#ifdef DEBUG\r\nprint_hex_dump(KERN_ERR,\r\n"aead null dec shdesc@"__stringify(__LINE__)": ",\r\nDUMP_PREFIX_ADDRESS, 16, 4, desc,\r\ndesc_bytes(desc), 1);\r\n#endif\r\nreturn 0;\r\n}\r\nstatic int aead_set_sh_desc(struct crypto_aead *aead)\r\n{\r\nstruct aead_tfm *tfm = &aead->base.crt_aead;\r\nstruct caam_ctx *ctx = crypto_aead_ctx(aead);\r\nstruct crypto_tfm *ctfm = crypto_aead_tfm(aead);\r\nconst char *alg_name = crypto_tfm_alg_name(ctfm);\r\nstruct device *jrdev = ctx->jrdev;\r\nbool keys_fit_inline;\r\nu32 geniv, moveiv;\r\nu32 ctx1_iv_off = 0;\r\nu32 *desc;\r\nconst bool ctr_mode = ((ctx->class1_alg_type & OP_ALG_AAI_MASK) ==\r\nOP_ALG_AAI_CTR_MOD128);\r\nconst bool is_rfc3686 = (ctr_mode &&\r\n(strstr(alg_name, "rfc3686") != NULL));\r\nif (!ctx->authsize)\r\nreturn 0;\r\nif (!ctx->enckeylen)\r\nreturn aead_null_set_sh_desc(aead);\r\nif (ctr_mode)\r\nctx1_iv_off = 16;\r\nif (is_rfc3686)\r\nctx1_iv_off = 16 + CTR_RFC3686_NONCE_SIZE;\r\nkeys_fit_inline = false;\r\nif (DESC_AEAD_ENC_LEN + DESC_JOB_IO_LEN +\r\nctx->split_key_pad_len + ctx->enckeylen +\r\n(is_rfc3686 ? DESC_AEAD_CTR_RFC3686_LEN : 0) <=\r\nCAAM_DESC_BYTES_MAX)\r\nkeys_fit_inline = true;\r\ndesc = ctx->sh_desc_enc;\r\ninit_sh_desc_key_aead(desc, ctx, keys_fit_inline, is_rfc3686);\r\nappend_operation(desc, ctx->class2_alg_type |\r\nOP_ALG_AS_INITFINAL | OP_ALG_ENCRYPT);\r\nappend_math_sub_imm_u32(desc, REG3, SEQOUTLEN, IMM, ctx->authsize);\r\nappend_math_sub_imm_u32(desc, REG2, SEQINLEN, IMM, tfm->ivsize);\r\nappend_math_sub(desc, VARSEQINLEN, REG2, REG3, CAAM_CMD_SZ);\r\nappend_seq_fifo_load(desc, 0, FIFOLD_CLASS_CLASS2 | FIFOLD_TYPE_MSG |\r\nKEY_VLF);\r\naead_append_ld_iv(desc, tfm->ivsize, ctx1_iv_off);\r\nif (is_rfc3686)\r\nappend_load_imm_u32(desc, be32_to_cpu(1), LDST_IMM |\r\nLDST_CLASS_1_CCB |\r\nLDST_SRCDST_BYTE_CONTEXT |\r\n((ctx1_iv_off + CTR_RFC3686_IV_SIZE) <<\r\nLDST_OFFSET_SHIFT));\r\nappend_operation(desc, ctx->class1_alg_type |\r\nOP_ALG_AS_INITFINAL | OP_ALG_ENCRYPT);\r\nappend_math_add(desc, VARSEQINLEN, ZERO, REG3, CAAM_CMD_SZ);\r\nappend_math_add(desc, VARSEQOUTLEN, ZERO, REG3, CAAM_CMD_SZ);\r\naead_append_src_dst(desc, FIFOLD_TYPE_MSG1OUT2);\r\nappend_seq_store(desc, ctx->authsize, LDST_CLASS_2_CCB |\r\nLDST_SRCDST_BYTE_CONTEXT);\r\nctx->sh_desc_enc_dma = dma_map_single(jrdev, desc,\r\ndesc_bytes(desc),\r\nDMA_TO_DEVICE);\r\nif (dma_mapping_error(jrdev, ctx->sh_desc_enc_dma)) {\r\ndev_err(jrdev, "unable to map shared descriptor\n");\r\nreturn -ENOMEM;\r\n}\r\n#ifdef DEBUG\r\nprint_hex_dump(KERN_ERR, "aead enc shdesc@"__stringify(__LINE__)": ",\r\nDUMP_PREFIX_ADDRESS, 16, 4, desc,\r\ndesc_bytes(desc), 1);\r\n#endif\r\nkeys_fit_inline = false;\r\nif (DESC_AEAD_DEC_LEN + DESC_JOB_IO_LEN +\r\nctx->split_key_pad_len + ctx->enckeylen +\r\n(is_rfc3686 ? DESC_AEAD_CTR_RFC3686_LEN : 0) <=\r\nCAAM_DESC_BYTES_MAX)\r\nkeys_fit_inline = true;\r\ndesc = ctx->sh_desc_dec;\r\ninit_sh_desc_key_aead(desc, ctx, keys_fit_inline, is_rfc3686);\r\nappend_operation(desc, ctx->class2_alg_type |\r\nOP_ALG_AS_INITFINAL | OP_ALG_DECRYPT | OP_ALG_ICV_ON);\r\nappend_math_sub_imm_u32(desc, REG3, SEQINLEN, IMM,\r\nctx->authsize + tfm->ivsize);\r\nappend_math_sub(desc, REG2, SEQOUTLEN, REG0, CAAM_CMD_SZ);\r\nappend_math_sub(desc, VARSEQINLEN, REG3, REG2, CAAM_CMD_SZ);\r\nappend_seq_fifo_load(desc, 0, FIFOLD_CLASS_CLASS2 | FIFOLD_TYPE_MSG |\r\nKEY_VLF);\r\naead_append_ld_iv(desc, tfm->ivsize, ctx1_iv_off);\r\nif (is_rfc3686)\r\nappend_load_imm_u32(desc, be32_to_cpu(1), LDST_IMM |\r\nLDST_CLASS_1_CCB |\r\nLDST_SRCDST_BYTE_CONTEXT |\r\n((ctx1_iv_off + CTR_RFC3686_IV_SIZE) <<\r\nLDST_OFFSET_SHIFT));\r\nif (ctr_mode)\r\nappend_operation(desc, ctx->class1_alg_type |\r\nOP_ALG_AS_INITFINAL | OP_ALG_DECRYPT);\r\nelse\r\nappend_dec_op1(desc, ctx->class1_alg_type);\r\nappend_math_add(desc, VARSEQINLEN, ZERO, REG2, CAAM_CMD_SZ);\r\nappend_math_add(desc, VARSEQOUTLEN, ZERO, REG2, CAAM_CMD_SZ);\r\naead_append_src_dst(desc, FIFOLD_TYPE_MSG);\r\nappend_seq_fifo_load(desc, ctx->authsize, FIFOLD_CLASS_CLASS2 |\r\nFIFOLD_TYPE_LAST2 | FIFOLD_TYPE_ICV);\r\nctx->sh_desc_dec_dma = dma_map_single(jrdev, desc,\r\ndesc_bytes(desc),\r\nDMA_TO_DEVICE);\r\nif (dma_mapping_error(jrdev, ctx->sh_desc_dec_dma)) {\r\ndev_err(jrdev, "unable to map shared descriptor\n");\r\nreturn -ENOMEM;\r\n}\r\n#ifdef DEBUG\r\nprint_hex_dump(KERN_ERR, "aead dec shdesc@"__stringify(__LINE__)": ",\r\nDUMP_PREFIX_ADDRESS, 16, 4, desc,\r\ndesc_bytes(desc), 1);\r\n#endif\r\nkeys_fit_inline = false;\r\nif (DESC_AEAD_GIVENC_LEN + DESC_JOB_IO_LEN +\r\nctx->split_key_pad_len + ctx->enckeylen +\r\n(is_rfc3686 ? DESC_AEAD_CTR_RFC3686_LEN : 0) <=\r\nCAAM_DESC_BYTES_MAX)\r\nkeys_fit_inline = true;\r\ndesc = ctx->sh_desc_givenc;\r\ninit_sh_desc_key_aead(desc, ctx, keys_fit_inline, is_rfc3686);\r\ngeniv = NFIFOENTRY_STYPE_PAD | NFIFOENTRY_DEST_DECO |\r\nNFIFOENTRY_DTYPE_MSG | NFIFOENTRY_LC1 |\r\nNFIFOENTRY_PTYPE_RND | (tfm->ivsize << NFIFOENTRY_DLEN_SHIFT);\r\nappend_load_imm_u32(desc, geniv, LDST_CLASS_IND_CCB |\r\nLDST_SRCDST_WORD_INFO_FIFO | LDST_IMM);\r\nappend_cmd(desc, CMD_LOAD | DISABLE_AUTO_INFO_FIFO);\r\nappend_move(desc, MOVE_WAITCOMP |\r\nMOVE_SRC_INFIFO | MOVE_DEST_CLASS1CTX |\r\n(ctx1_iv_off << MOVE_OFFSET_SHIFT) |\r\n(tfm->ivsize << MOVE_LEN_SHIFT));\r\nappend_cmd(desc, CMD_LOAD | ENABLE_AUTO_INFO_FIFO);\r\nappend_move(desc, MOVE_SRC_CLASS1CTX | MOVE_DEST_OUTFIFO |\r\n(ctx1_iv_off << MOVE_OFFSET_SHIFT) |\r\n(tfm->ivsize << MOVE_LEN_SHIFT));\r\nappend_operation(desc, ctx->class2_alg_type |\r\nOP_ALG_AS_INITFINAL | OP_ALG_ENCRYPT);\r\nappend_math_sub_imm_u32(desc, REG3, SEQOUTLEN, IMM, ctx->authsize);\r\nappend_math_sub(desc, VARSEQINLEN, SEQINLEN, REG3, CAAM_CMD_SZ);\r\nappend_seq_fifo_load(desc, 0, FIFOLD_CLASS_CLASS2 | FIFOLD_TYPE_MSG |\r\nKEY_VLF);\r\nmoveiv = NFIFOENTRY_STYPE_OFIFO | NFIFOENTRY_DEST_CLASS2 |\r\nNFIFOENTRY_DTYPE_MSG | (tfm->ivsize << NFIFOENTRY_DLEN_SHIFT);\r\nappend_load_imm_u32(desc, moveiv, LDST_CLASS_IND_CCB |\r\nLDST_SRCDST_WORD_INFO_FIFO | LDST_IMM);\r\nappend_load_imm_u32(desc, tfm->ivsize, LDST_CLASS_2_CCB |\r\nLDST_SRCDST_WORD_DATASZ_REG | LDST_IMM);\r\nif (is_rfc3686)\r\nappend_load_imm_u32(desc, be32_to_cpu(1), LDST_IMM |\r\nLDST_CLASS_1_CCB |\r\nLDST_SRCDST_BYTE_CONTEXT |\r\n((ctx1_iv_off + CTR_RFC3686_IV_SIZE) <<\r\nLDST_OFFSET_SHIFT));\r\nappend_operation(desc, ctx->class1_alg_type |\r\nOP_ALG_AS_INITFINAL | OP_ALG_ENCRYPT);\r\nappend_math_add(desc, VARSEQOUTLEN, SEQINLEN, REG0, CAAM_CMD_SZ);\r\nappend_seq_fifo_load(desc, tfm->ivsize,\r\nFIFOLD_CLASS_SKIP);\r\nappend_math_add(desc, VARSEQINLEN, SEQINLEN, REG0, CAAM_CMD_SZ);\r\naead_append_src_dst(desc, FIFOLD_TYPE_MSG1OUT2);\r\nappend_seq_store(desc, ctx->authsize, LDST_CLASS_2_CCB |\r\nLDST_SRCDST_BYTE_CONTEXT);\r\nctx->sh_desc_givenc_dma = dma_map_single(jrdev, desc,\r\ndesc_bytes(desc),\r\nDMA_TO_DEVICE);\r\nif (dma_mapping_error(jrdev, ctx->sh_desc_givenc_dma)) {\r\ndev_err(jrdev, "unable to map shared descriptor\n");\r\nreturn -ENOMEM;\r\n}\r\n#ifdef DEBUG\r\nprint_hex_dump(KERN_ERR, "aead givenc shdesc@"__stringify(__LINE__)": ",\r\nDUMP_PREFIX_ADDRESS, 16, 4, desc,\r\ndesc_bytes(desc), 1);\r\n#endif\r\nreturn 0;\r\n}\r\nstatic int aead_setauthsize(struct crypto_aead *authenc,\r\nunsigned int authsize)\r\n{\r\nstruct caam_ctx *ctx = crypto_aead_ctx(authenc);\r\nctx->authsize = authsize;\r\naead_set_sh_desc(authenc);\r\nreturn 0;\r\n}\r\nstatic int gcm_set_sh_desc(struct crypto_aead *aead)\r\n{\r\nstruct aead_tfm *tfm = &aead->base.crt_aead;\r\nstruct caam_ctx *ctx = crypto_aead_ctx(aead);\r\nstruct device *jrdev = ctx->jrdev;\r\nbool keys_fit_inline = false;\r\nu32 *key_jump_cmd, *zero_payload_jump_cmd,\r\n*zero_assoc_jump_cmd1, *zero_assoc_jump_cmd2;\r\nu32 *desc;\r\nif (!ctx->enckeylen || !ctx->authsize)\r\nreturn 0;\r\nif (DESC_GCM_ENC_LEN + DESC_JOB_IO_LEN +\r\nctx->enckeylen <= CAAM_DESC_BYTES_MAX)\r\nkeys_fit_inline = true;\r\ndesc = ctx->sh_desc_enc;\r\ninit_sh_desc(desc, HDR_SHARE_SERIAL);\r\nkey_jump_cmd = append_jump(desc, JUMP_JSL | JUMP_TEST_ALL |\r\nJUMP_COND_SHRD | JUMP_COND_SELF);\r\nif (keys_fit_inline)\r\nappend_key_as_imm(desc, (void *)ctx->key, ctx->enckeylen,\r\nctx->enckeylen, CLASS_1 | KEY_DEST_CLASS_REG);\r\nelse\r\nappend_key(desc, ctx->key_dma, ctx->enckeylen,\r\nCLASS_1 | KEY_DEST_CLASS_REG);\r\nset_jump_tgt_here(desc, key_jump_cmd);\r\nappend_operation(desc, ctx->class1_alg_type |\r\nOP_ALG_AS_INITFINAL | OP_ALG_ENCRYPT);\r\nappend_math_sub_imm_u32(desc, REG3, SEQOUTLEN, IMM, ctx->authsize);\r\nappend_math_sub_imm_u32(desc, REG2, SEQINLEN, IMM, tfm->ivsize);\r\nappend_math_sub(desc, REG1, REG2, REG3, CAAM_CMD_SZ);\r\nappend_math_add(desc, VARSEQOUTLEN, ZERO, REG3, CAAM_CMD_SZ);\r\nzero_payload_jump_cmd = append_jump(desc, JUMP_TEST_ALL |\r\nJUMP_COND_MATH_Z);\r\nappend_seq_fifo_load(desc, tfm->ivsize, FIFOLD_CLASS_CLASS1 |\r\nFIFOLD_TYPE_IV | FIFOLD_TYPE_FLUSH1);\r\nappend_math_add(desc, VARSEQINLEN, ZERO, REG1, CAAM_CMD_SZ);\r\nzero_assoc_jump_cmd1 = append_jump(desc, JUMP_TEST_ALL |\r\nJUMP_COND_MATH_Z);\r\nappend_seq_fifo_load(desc, 0, FIFOLD_CLASS_CLASS1 | FIFOLDST_VLF |\r\nFIFOLD_TYPE_AAD | FIFOLD_TYPE_FLUSH1);\r\nset_jump_tgt_here(desc, zero_assoc_jump_cmd1);\r\nappend_math_add(desc, VARSEQINLEN, ZERO, REG3, CAAM_CMD_SZ);\r\nappend_seq_fifo_store(desc, 0, FIFOST_TYPE_MESSAGE_DATA | FIFOLDST_VLF);\r\nappend_seq_fifo_load(desc, 0, FIFOLD_CLASS_CLASS1 | FIFOLDST_VLF |\r\nFIFOLD_TYPE_MSG | FIFOLD_TYPE_LAST1);\r\nappend_jump(desc, JUMP_TEST_ALL | 7);\r\nset_jump_tgt_here(desc, zero_payload_jump_cmd);\r\nappend_math_add(desc, VARSEQINLEN, ZERO, REG1, CAAM_CMD_SZ);\r\nzero_assoc_jump_cmd2 = append_jump(desc, JUMP_TEST_ALL |\r\nJUMP_COND_MATH_Z);\r\nappend_seq_fifo_load(desc, tfm->ivsize, FIFOLD_CLASS_CLASS1 |\r\nFIFOLD_TYPE_IV | FIFOLD_TYPE_FLUSH1);\r\nappend_seq_fifo_load(desc, 0, FIFOLD_CLASS_CLASS1 | FIFOLDST_VLF |\r\nFIFOLD_TYPE_AAD | FIFOLD_TYPE_LAST1);\r\nappend_jump(desc, JUMP_TEST_ALL | 2);\r\nset_jump_tgt_here(desc, zero_assoc_jump_cmd2);\r\nappend_seq_fifo_load(desc, tfm->ivsize, FIFOLD_CLASS_CLASS1 |\r\nFIFOLD_TYPE_IV | FIFOLD_TYPE_FLUSH1 |\r\nFIFOLD_TYPE_LAST1);\r\nappend_seq_store(desc, ctx->authsize, LDST_CLASS_1_CCB |\r\nLDST_SRCDST_BYTE_CONTEXT);\r\nctx->sh_desc_enc_dma = dma_map_single(jrdev, desc,\r\ndesc_bytes(desc),\r\nDMA_TO_DEVICE);\r\nif (dma_mapping_error(jrdev, ctx->sh_desc_enc_dma)) {\r\ndev_err(jrdev, "unable to map shared descriptor\n");\r\nreturn -ENOMEM;\r\n}\r\n#ifdef DEBUG\r\nprint_hex_dump(KERN_ERR, "gcm enc shdesc@"__stringify(__LINE__)": ",\r\nDUMP_PREFIX_ADDRESS, 16, 4, desc,\r\ndesc_bytes(desc), 1);\r\n#endif\r\nkeys_fit_inline = false;\r\nif (DESC_GCM_DEC_LEN + DESC_JOB_IO_LEN +\r\nctx->enckeylen <= CAAM_DESC_BYTES_MAX)\r\nkeys_fit_inline = true;\r\ndesc = ctx->sh_desc_dec;\r\ninit_sh_desc(desc, HDR_SHARE_SERIAL);\r\nkey_jump_cmd = append_jump(desc, JUMP_JSL |\r\nJUMP_TEST_ALL | JUMP_COND_SHRD |\r\nJUMP_COND_SELF);\r\nif (keys_fit_inline)\r\nappend_key_as_imm(desc, (void *)ctx->key, ctx->enckeylen,\r\nctx->enckeylen, CLASS_1 | KEY_DEST_CLASS_REG);\r\nelse\r\nappend_key(desc, ctx->key_dma, ctx->enckeylen,\r\nCLASS_1 | KEY_DEST_CLASS_REG);\r\nset_jump_tgt_here(desc, key_jump_cmd);\r\nappend_operation(desc, ctx->class1_alg_type |\r\nOP_ALG_AS_INITFINAL | OP_ALG_DECRYPT | OP_ALG_ICV_ON);\r\nappend_math_sub_imm_u32(desc, REG3, SEQINLEN, IMM,\r\nctx->authsize + tfm->ivsize);\r\nappend_math_sub(desc, REG2, SEQOUTLEN, REG0, CAAM_CMD_SZ);\r\nappend_math_sub(desc, REG1, REG3, REG2, CAAM_CMD_SZ);\r\nappend_seq_fifo_load(desc, tfm->ivsize, FIFOLD_CLASS_CLASS1 |\r\nFIFOLD_TYPE_IV | FIFOLD_TYPE_FLUSH1);\r\nappend_math_add(desc, VARSEQOUTLEN, ZERO, REG2, CAAM_CMD_SZ);\r\nzero_payload_jump_cmd = append_jump(desc, JUMP_TEST_ALL |\r\nJUMP_COND_MATH_Z);\r\nappend_math_add(desc, VARSEQINLEN, ZERO, REG1, CAAM_CMD_SZ);\r\nzero_assoc_jump_cmd1 = append_jump(desc, JUMP_TEST_ALL |\r\nJUMP_COND_MATH_Z);\r\nappend_seq_fifo_load(desc, 0, FIFOLD_CLASS_CLASS1 | FIFOLDST_VLF |\r\nFIFOLD_TYPE_AAD | FIFOLD_TYPE_FLUSH1);\r\nset_jump_tgt_here(desc, zero_assoc_jump_cmd1);\r\nappend_math_add(desc, VARSEQINLEN, ZERO, REG2, CAAM_CMD_SZ);\r\nappend_seq_fifo_store(desc, 0, FIFOST_TYPE_MESSAGE_DATA | FIFOLDST_VLF);\r\nappend_seq_fifo_load(desc, 0, FIFOLD_CLASS_CLASS1 | FIFOLDST_VLF |\r\nFIFOLD_TYPE_MSG | FIFOLD_TYPE_FLUSH1);\r\nappend_jump(desc, JUMP_TEST_ALL | 4);\r\nset_jump_tgt_here(desc, zero_payload_jump_cmd);\r\nappend_math_add(desc, VARSEQINLEN, ZERO, REG1, CAAM_CMD_SZ);\r\nzero_assoc_jump_cmd2 = append_jump(desc, JUMP_TEST_ALL |\r\nJUMP_COND_MATH_Z);\r\nappend_seq_fifo_load(desc, 0, FIFOLD_CLASS_CLASS1 | FIFOLDST_VLF |\r\nFIFOLD_TYPE_AAD | FIFOLD_TYPE_FLUSH1);\r\nset_jump_tgt_here(desc, zero_assoc_jump_cmd2);\r\nappend_seq_fifo_load(desc, ctx->authsize, FIFOLD_CLASS_CLASS1 |\r\nFIFOLD_TYPE_ICV | FIFOLD_TYPE_LAST1);\r\nctx->sh_desc_dec_dma = dma_map_single(jrdev, desc,\r\ndesc_bytes(desc),\r\nDMA_TO_DEVICE);\r\nif (dma_mapping_error(jrdev, ctx->sh_desc_dec_dma)) {\r\ndev_err(jrdev, "unable to map shared descriptor\n");\r\nreturn -ENOMEM;\r\n}\r\n#ifdef DEBUG\r\nprint_hex_dump(KERN_ERR, "gcm dec shdesc@"__stringify(__LINE__)": ",\r\nDUMP_PREFIX_ADDRESS, 16, 4, desc,\r\ndesc_bytes(desc), 1);\r\n#endif\r\nreturn 0;\r\n}\r\nstatic int gcm_setauthsize(struct crypto_aead *authenc, unsigned int authsize)\r\n{\r\nstruct caam_ctx *ctx = crypto_aead_ctx(authenc);\r\nctx->authsize = authsize;\r\ngcm_set_sh_desc(authenc);\r\nreturn 0;\r\n}\r\nstatic int rfc4106_set_sh_desc(struct crypto_aead *aead)\r\n{\r\nstruct aead_tfm *tfm = &aead->base.crt_aead;\r\nstruct caam_ctx *ctx = crypto_aead_ctx(aead);\r\nstruct device *jrdev = ctx->jrdev;\r\nbool keys_fit_inline = false;\r\nu32 *key_jump_cmd, *move_cmd, *write_iv_cmd;\r\nu32 *desc;\r\nu32 geniv;\r\nif (!ctx->enckeylen || !ctx->authsize)\r\nreturn 0;\r\nif (DESC_RFC4106_ENC_LEN + DESC_JOB_IO_LEN +\r\nctx->enckeylen <= CAAM_DESC_BYTES_MAX)\r\nkeys_fit_inline = true;\r\ndesc = ctx->sh_desc_enc;\r\ninit_sh_desc(desc, HDR_SHARE_SERIAL);\r\nkey_jump_cmd = append_jump(desc, JUMP_JSL | JUMP_TEST_ALL |\r\nJUMP_COND_SHRD);\r\nif (keys_fit_inline)\r\nappend_key_as_imm(desc, (void *)ctx->key, ctx->enckeylen,\r\nctx->enckeylen, CLASS_1 | KEY_DEST_CLASS_REG);\r\nelse\r\nappend_key(desc, ctx->key_dma, ctx->enckeylen,\r\nCLASS_1 | KEY_DEST_CLASS_REG);\r\nset_jump_tgt_here(desc, key_jump_cmd);\r\nappend_operation(desc, ctx->class1_alg_type |\r\nOP_ALG_AS_INITFINAL | OP_ALG_ENCRYPT);\r\nappend_math_sub_imm_u32(desc, REG3, SEQOUTLEN, IMM, ctx->authsize);\r\nappend_math_add(desc, VARSEQOUTLEN, ZERO, REG3, CAAM_CMD_SZ);\r\nappend_math_sub_imm_u32(desc, REG2, SEQINLEN, IMM, tfm->ivsize);\r\nappend_math_sub(desc, VARSEQINLEN, REG2, REG3, CAAM_CMD_SZ);\r\nappend_fifo_load_as_imm(desc, (void *)(ctx->key + ctx->enckeylen),\r\n4, FIFOLD_CLASS_CLASS1 | FIFOLD_TYPE_IV);\r\nappend_seq_fifo_load(desc, tfm->ivsize, FIFOLD_CLASS_CLASS1 |\r\nFIFOLD_TYPE_IV | FIFOLD_TYPE_FLUSH1);\r\nappend_seq_fifo_load(desc, 0, FIFOLD_CLASS_CLASS1 | FIFOLDST_VLF |\r\nFIFOLD_TYPE_AAD | FIFOLD_TYPE_FLUSH1);\r\nappend_math_add(desc, VARSEQINLEN, ZERO, REG3, CAAM_CMD_SZ);\r\nappend_seq_fifo_store(desc, 0, FIFOST_TYPE_MESSAGE_DATA | FIFOLDST_VLF);\r\nappend_seq_fifo_load(desc, 0, FIFOLD_CLASS_CLASS1 | FIFOLDST_VLF |\r\nFIFOLD_TYPE_MSG | FIFOLD_TYPE_LAST1);\r\nappend_seq_store(desc, ctx->authsize, LDST_CLASS_1_CCB |\r\nLDST_SRCDST_BYTE_CONTEXT);\r\nctx->sh_desc_enc_dma = dma_map_single(jrdev, desc,\r\ndesc_bytes(desc),\r\nDMA_TO_DEVICE);\r\nif (dma_mapping_error(jrdev, ctx->sh_desc_enc_dma)) {\r\ndev_err(jrdev, "unable to map shared descriptor\n");\r\nreturn -ENOMEM;\r\n}\r\n#ifdef DEBUG\r\nprint_hex_dump(KERN_ERR, "rfc4106 enc shdesc@"__stringify(__LINE__)": ",\r\nDUMP_PREFIX_ADDRESS, 16, 4, desc,\r\ndesc_bytes(desc), 1);\r\n#endif\r\nkeys_fit_inline = false;\r\nif (DESC_RFC4106_DEC_LEN + DESC_JOB_IO_LEN +\r\nctx->enckeylen <= CAAM_DESC_BYTES_MAX)\r\nkeys_fit_inline = true;\r\ndesc = ctx->sh_desc_dec;\r\ninit_sh_desc(desc, HDR_SHARE_SERIAL);\r\nkey_jump_cmd = append_jump(desc, JUMP_JSL |\r\nJUMP_TEST_ALL | JUMP_COND_SHRD);\r\nif (keys_fit_inline)\r\nappend_key_as_imm(desc, (void *)ctx->key, ctx->enckeylen,\r\nctx->enckeylen, CLASS_1 | KEY_DEST_CLASS_REG);\r\nelse\r\nappend_key(desc, ctx->key_dma, ctx->enckeylen,\r\nCLASS_1 | KEY_DEST_CLASS_REG);\r\nset_jump_tgt_here(desc, key_jump_cmd);\r\nappend_operation(desc, ctx->class1_alg_type |\r\nOP_ALG_AS_INITFINAL | OP_ALG_DECRYPT | OP_ALG_ICV_ON);\r\nappend_math_sub_imm_u32(desc, REG3, SEQINLEN, IMM,\r\nctx->authsize + tfm->ivsize);\r\nappend_math_sub(desc, REG2, SEQOUTLEN, REG0, CAAM_CMD_SZ);\r\nappend_math_sub(desc, VARSEQINLEN, REG3, REG2, CAAM_CMD_SZ);\r\nappend_math_sub(desc, VARSEQOUTLEN, SEQOUTLEN, REG0, CAAM_CMD_SZ);\r\nappend_fifo_load_as_imm(desc, (void *)(ctx->key + ctx->enckeylen),\r\n4, FIFOLD_CLASS_CLASS1 | FIFOLD_TYPE_IV);\r\nappend_seq_fifo_load(desc, tfm->ivsize, FIFOLD_CLASS_CLASS1 |\r\nFIFOLD_TYPE_IV | FIFOLD_TYPE_FLUSH1);\r\nappend_seq_fifo_load(desc, 0, FIFOLD_CLASS_CLASS1 | FIFOLDST_VLF |\r\nFIFOLD_TYPE_AAD | FIFOLD_TYPE_FLUSH1);\r\nappend_math_add(desc, VARSEQINLEN, ZERO, REG2, CAAM_CMD_SZ);\r\nappend_seq_fifo_store(desc, 0, FIFOST_TYPE_MESSAGE_DATA | FIFOLDST_VLF);\r\nappend_seq_fifo_load(desc, 0, FIFOLD_CLASS_CLASS1 | FIFOLDST_VLF |\r\nFIFOLD_TYPE_MSG | FIFOLD_TYPE_FLUSH1);\r\nappend_seq_fifo_load(desc, ctx->authsize, FIFOLD_CLASS_CLASS1 |\r\nFIFOLD_TYPE_ICV | FIFOLD_TYPE_LAST1);\r\nctx->sh_desc_dec_dma = dma_map_single(jrdev, desc,\r\ndesc_bytes(desc),\r\nDMA_TO_DEVICE);\r\nif (dma_mapping_error(jrdev, ctx->sh_desc_dec_dma)) {\r\ndev_err(jrdev, "unable to map shared descriptor\n");\r\nreturn -ENOMEM;\r\n}\r\n#ifdef DEBUG\r\nprint_hex_dump(KERN_ERR, "rfc4106 dec shdesc@"__stringify(__LINE__)": ",\r\nDUMP_PREFIX_ADDRESS, 16, 4, desc,\r\ndesc_bytes(desc), 1);\r\n#endif\r\nkeys_fit_inline = false;\r\nif (DESC_RFC4106_GIVENC_LEN + DESC_JOB_IO_LEN +\r\nctx->split_key_pad_len + ctx->enckeylen <=\r\nCAAM_DESC_BYTES_MAX)\r\nkeys_fit_inline = true;\r\ndesc = ctx->sh_desc_givenc;\r\ninit_sh_desc(desc, HDR_SHARE_SERIAL);\r\nkey_jump_cmd = append_jump(desc, JUMP_JSL | JUMP_TEST_ALL |\r\nJUMP_COND_SHRD);\r\nif (keys_fit_inline)\r\nappend_key_as_imm(desc, (void *)ctx->key, ctx->enckeylen,\r\nctx->enckeylen, CLASS_1 | KEY_DEST_CLASS_REG);\r\nelse\r\nappend_key(desc, ctx->key_dma, ctx->enckeylen,\r\nCLASS_1 | KEY_DEST_CLASS_REG);\r\nset_jump_tgt_here(desc, key_jump_cmd);\r\ngeniv = NFIFOENTRY_STYPE_PAD | NFIFOENTRY_DEST_DECO |\r\nNFIFOENTRY_DTYPE_MSG | NFIFOENTRY_LC1 |\r\nNFIFOENTRY_PTYPE_RND | (tfm->ivsize << NFIFOENTRY_DLEN_SHIFT);\r\nappend_load_imm_u32(desc, geniv, LDST_CLASS_IND_CCB |\r\nLDST_SRCDST_WORD_INFO_FIFO | LDST_IMM);\r\nappend_cmd(desc, CMD_LOAD | DISABLE_AUTO_INFO_FIFO);\r\nmove_cmd = append_move(desc, MOVE_SRC_INFIFO | MOVE_DEST_DESCBUF |\r\n(tfm->ivsize << MOVE_LEN_SHIFT));\r\nappend_cmd(desc, CMD_LOAD | ENABLE_AUTO_INFO_FIFO);\r\nwrite_iv_cmd = append_move(desc, MOVE_SRC_DESCBUF | MOVE_DEST_OUTFIFO |\r\n(tfm->ivsize << MOVE_LEN_SHIFT));\r\nappend_operation(desc, ctx->class1_alg_type |\r\nOP_ALG_AS_INITFINAL | OP_ALG_ENCRYPT);\r\nappend_math_sub_imm_u32(desc, REG3, SEQOUTLEN, IMM, ctx->authsize);\r\nappend_math_sub(desc, VARSEQINLEN, SEQINLEN, REG3, CAAM_CMD_SZ);\r\nappend_math_add(desc, VARSEQOUTLEN, REG3, REG0, CAAM_CMD_SZ);\r\nappend_cmd(desc, CMD_FIFO_LOAD | FIFOLD_CLASS_CLASS1 | FIFOLD_TYPE_IV |\r\nFIFOLD_TYPE_FLUSH1 | IMMEDIATE | 12);\r\nappend_data(desc, (void *)(ctx->key + ctx->enckeylen), 4);\r\nset_move_tgt_here(desc, move_cmd);\r\nset_move_tgt_here(desc, write_iv_cmd);\r\nappend_cmd(desc, 0x00000000);\r\nappend_cmd(desc, 0x00000000);\r\nappend_seq_fifo_load(desc, tfm->ivsize, FIFOLD_CLASS_SKIP);\r\nappend_seq_fifo_load(desc, 0, FIFOLD_CLASS_CLASS1 | FIFOLDST_VLF |\r\nFIFOLD_TYPE_AAD | FIFOLD_TYPE_FLUSH1);\r\nappend_math_add(desc, VARSEQINLEN, SEQINLEN, REG0, CAAM_CMD_SZ);\r\nappend_seq_fifo_store(desc, 0, FIFOST_TYPE_MESSAGE_DATA | FIFOLDST_VLF);\r\nappend_seq_fifo_load(desc, 0, FIFOLD_CLASS_CLASS1 | FIFOLDST_VLF |\r\nFIFOLD_TYPE_MSG | FIFOLD_TYPE_LAST1);\r\nappend_seq_store(desc, ctx->authsize, LDST_CLASS_1_CCB |\r\nLDST_SRCDST_BYTE_CONTEXT);\r\nctx->sh_desc_givenc_dma = dma_map_single(jrdev, desc,\r\ndesc_bytes(desc),\r\nDMA_TO_DEVICE);\r\nif (dma_mapping_error(jrdev, ctx->sh_desc_givenc_dma)) {\r\ndev_err(jrdev, "unable to map shared descriptor\n");\r\nreturn -ENOMEM;\r\n}\r\n#ifdef DEBUG\r\nprint_hex_dump(KERN_ERR,\r\n"rfc4106 givenc shdesc@"__stringify(__LINE__)": ",\r\nDUMP_PREFIX_ADDRESS, 16, 4, desc,\r\ndesc_bytes(desc), 1);\r\n#endif\r\nreturn 0;\r\n}\r\nstatic int rfc4106_setauthsize(struct crypto_aead *authenc,\r\nunsigned int authsize)\r\n{\r\nstruct caam_ctx *ctx = crypto_aead_ctx(authenc);\r\nctx->authsize = authsize;\r\nrfc4106_set_sh_desc(authenc);\r\nreturn 0;\r\n}\r\nstatic int rfc4543_set_sh_desc(struct crypto_aead *aead)\r\n{\r\nstruct aead_tfm *tfm = &aead->base.crt_aead;\r\nstruct caam_ctx *ctx = crypto_aead_ctx(aead);\r\nstruct device *jrdev = ctx->jrdev;\r\nbool keys_fit_inline = false;\r\nu32 *key_jump_cmd, *write_iv_cmd, *write_aad_cmd;\r\nu32 *read_move_cmd, *write_move_cmd;\r\nu32 *desc;\r\nu32 geniv;\r\nif (!ctx->enckeylen || !ctx->authsize)\r\nreturn 0;\r\nif (DESC_RFC4543_ENC_LEN + DESC_JOB_IO_LEN +\r\nctx->enckeylen <= CAAM_DESC_BYTES_MAX)\r\nkeys_fit_inline = true;\r\ndesc = ctx->sh_desc_enc;\r\ninit_sh_desc(desc, HDR_SHARE_SERIAL);\r\nkey_jump_cmd = append_jump(desc, JUMP_JSL | JUMP_TEST_ALL |\r\nJUMP_COND_SHRD);\r\nif (keys_fit_inline)\r\nappend_key_as_imm(desc, (void *)ctx->key, ctx->enckeylen,\r\nctx->enckeylen, CLASS_1 | KEY_DEST_CLASS_REG);\r\nelse\r\nappend_key(desc, ctx->key_dma, ctx->enckeylen,\r\nCLASS_1 | KEY_DEST_CLASS_REG);\r\nset_jump_tgt_here(desc, key_jump_cmd);\r\nappend_operation(desc, ctx->class1_alg_type |\r\nOP_ALG_AS_INITFINAL | OP_ALG_ENCRYPT);\r\nappend_cmd(desc, CMD_SEQ_LOAD | LDST_SRCDST_WORD_DECO_MATH1 |\r\nLDST_CLASS_DECO | tfm->ivsize);\r\nappend_jump(desc, JUMP_TEST_ALL | JUMP_COND_CALM |\r\n(1 << JUMP_OFFSET_SHIFT));\r\nwrite_iv_cmd = append_move(desc, MOVE_SRC_MATH1 | MOVE_DEST_DESCBUF |\r\n(tfm->ivsize << MOVE_LEN_SHIFT));\r\nwrite_aad_cmd = append_move(desc, MOVE_SRC_MATH1 | MOVE_DEST_DESCBUF |\r\n(tfm->ivsize << MOVE_LEN_SHIFT));\r\nappend_math_sub_imm_u32(desc, REG3, SEQOUTLEN, IMM, ctx->authsize);\r\nappend_math_sub(desc, VARSEQINLEN, SEQINLEN, REG3, CAAM_CMD_SZ);\r\nappend_cmd(desc, CMD_FIFO_LOAD | FIFOLD_CLASS_CLASS1 | IMMEDIATE |\r\nFIFOLD_TYPE_IV | FIFOLD_TYPE_FLUSH1 | (4 + tfm->ivsize));\r\nappend_data(desc, (void *)(ctx->key + ctx->enckeylen), 4);\r\nset_move_tgt_here(desc, write_iv_cmd);\r\nappend_cmd(desc, 0x00000000);\r\nappend_cmd(desc, 0x00000000);\r\nappend_seq_fifo_load(desc, 0, FIFOLD_CLASS_CLASS1 | FIFOLDST_VLF |\r\nFIFOLD_TYPE_AAD);\r\nappend_math_add(desc, VARSEQINLEN, ZERO, REG3, CAAM_CMD_SZ);\r\nappend_math_add(desc, VARSEQOUTLEN, ZERO, REG3, CAAM_CMD_SZ);\r\nread_move_cmd = append_move(desc, MOVE_SRC_DESCBUF | MOVE_DEST_MATH3 |\r\n(0x6 << MOVE_LEN_SHIFT));\r\nwrite_move_cmd = append_move(desc, MOVE_SRC_MATH3 | MOVE_DEST_DESCBUF |\r\n(0x8 << MOVE_LEN_SHIFT));\r\nappend_cmd(desc, CMD_FIFO_LOAD | FIFOLD_CLASS_CLASS1 | IMMEDIATE |\r\nFIFOLD_TYPE_AAD | tfm->ivsize);\r\nset_move_tgt_here(desc, write_aad_cmd);\r\nappend_cmd(desc, 0x00000000);\r\nappend_cmd(desc, 0x00000000);\r\naead_append_src_dst(desc, FIFOLD_TYPE_AAD);\r\nset_move_tgt_here(desc, read_move_cmd);\r\nset_move_tgt_here(desc, write_move_cmd);\r\nappend_cmd(desc, CMD_LOAD | DISABLE_AUTO_INFO_FIFO);\r\nappend_move(desc, MOVE_SRC_INFIFO_CL | MOVE_DEST_OUTFIFO);\r\nappend_seq_store(desc, ctx->authsize, LDST_CLASS_1_CCB |\r\nLDST_SRCDST_BYTE_CONTEXT);\r\nctx->sh_desc_enc_dma = dma_map_single(jrdev, desc,\r\ndesc_bytes(desc),\r\nDMA_TO_DEVICE);\r\nif (dma_mapping_error(jrdev, ctx->sh_desc_enc_dma)) {\r\ndev_err(jrdev, "unable to map shared descriptor\n");\r\nreturn -ENOMEM;\r\n}\r\n#ifdef DEBUG\r\nprint_hex_dump(KERN_ERR, "rfc4543 enc shdesc@"__stringify(__LINE__)": ",\r\nDUMP_PREFIX_ADDRESS, 16, 4, desc,\r\ndesc_bytes(desc), 1);\r\n#endif\r\nkeys_fit_inline = false;\r\nif (DESC_RFC4543_DEC_LEN + DESC_JOB_IO_LEN +\r\nctx->enckeylen <= CAAM_DESC_BYTES_MAX)\r\nkeys_fit_inline = true;\r\ndesc = ctx->sh_desc_dec;\r\ninit_sh_desc(desc, HDR_SHARE_SERIAL);\r\nkey_jump_cmd = append_jump(desc, JUMP_JSL |\r\nJUMP_TEST_ALL | JUMP_COND_SHRD);\r\nif (keys_fit_inline)\r\nappend_key_as_imm(desc, (void *)ctx->key, ctx->enckeylen,\r\nctx->enckeylen, CLASS_1 | KEY_DEST_CLASS_REG);\r\nelse\r\nappend_key(desc, ctx->key_dma, ctx->enckeylen,\r\nCLASS_1 | KEY_DEST_CLASS_REG);\r\nset_jump_tgt_here(desc, key_jump_cmd);\r\nappend_operation(desc, ctx->class1_alg_type |\r\nOP_ALG_AS_INITFINAL | OP_ALG_DECRYPT | OP_ALG_ICV_ON);\r\nappend_cmd(desc, CMD_SEQ_LOAD | LDST_SRCDST_WORD_DECO_MATH1 |\r\nLDST_CLASS_DECO | tfm->ivsize);\r\nappend_jump(desc, JUMP_TEST_ALL | JUMP_COND_CALM |\r\n(1 << JUMP_OFFSET_SHIFT));\r\nappend_math_sub_imm_u32(desc, REG3, SEQINLEN, IMM, ctx->authsize);\r\nwrite_iv_cmd = append_move(desc, MOVE_SRC_MATH1 | MOVE_DEST_DESCBUF |\r\n(tfm->ivsize << MOVE_LEN_SHIFT));\r\nwrite_aad_cmd = append_move(desc, MOVE_SRC_MATH1 | MOVE_DEST_DESCBUF |\r\n(tfm->ivsize << MOVE_LEN_SHIFT));\r\nappend_math_sub(desc, REG2, SEQOUTLEN, REG0, CAAM_CMD_SZ);\r\nappend_math_sub(desc, VARSEQINLEN, REG3, REG2, CAAM_CMD_SZ);\r\nread_move_cmd = append_move(desc, MOVE_SRC_DESCBUF | MOVE_DEST_MATH3 |\r\n(0x6 << MOVE_LEN_SHIFT));\r\nwrite_move_cmd = append_move(desc, MOVE_SRC_MATH3 | MOVE_DEST_DESCBUF |\r\n(0x8 << MOVE_LEN_SHIFT));\r\nappend_cmd(desc, CMD_FIFO_LOAD | FIFOLD_CLASS_CLASS1 | IMMEDIATE |\r\nFIFOLD_TYPE_IV | FIFOLD_TYPE_FLUSH1 | (4 + tfm->ivsize));\r\nappend_data(desc, (void *)(ctx->key + ctx->enckeylen), 4);\r\nset_move_tgt_here(desc, write_iv_cmd);\r\nappend_cmd(desc, 0x00000000);\r\nappend_cmd(desc, 0x00000000);\r\nappend_seq_fifo_load(desc, 0, FIFOLD_CLASS_CLASS1 | FIFOLDST_VLF |\r\nFIFOLD_TYPE_AAD);\r\nappend_math_add(desc, VARSEQINLEN, ZERO, REG2, CAAM_CMD_SZ);\r\nappend_math_add(desc, VARSEQOUTLEN, ZERO, REG2, CAAM_CMD_SZ);\r\nappend_cmd(desc, CMD_FIFO_LOAD | FIFOLD_CLASS_CLASS1 | IMMEDIATE |\r\nFIFOLD_TYPE_AAD | tfm->ivsize);\r\nset_move_tgt_here(desc, write_aad_cmd);\r\nappend_cmd(desc, 0x00000000);\r\nappend_cmd(desc, 0x00000000);\r\nappend_seq_fifo_store(desc, 0, FIFOST_TYPE_MESSAGE_DATA | FIFOLDST_VLF);\r\nappend_seq_fifo_load(desc, 0, FIFOLD_CLASS_BOTH | FIFOLDST_VLF |\r\nFIFOLD_TYPE_AAD | FIFOLD_TYPE_LAST2FLUSH1);\r\nset_move_tgt_here(desc, read_move_cmd);\r\nset_move_tgt_here(desc, write_move_cmd);\r\nappend_cmd(desc, CMD_LOAD | DISABLE_AUTO_INFO_FIFO);\r\nappend_move(desc, MOVE_SRC_INFIFO_CL | MOVE_DEST_OUTFIFO);\r\nappend_cmd(desc, CMD_LOAD | ENABLE_AUTO_INFO_FIFO);\r\nappend_seq_fifo_load(desc, ctx->authsize, FIFOLD_CLASS_CLASS1 |\r\nFIFOLD_TYPE_ICV | FIFOLD_TYPE_LAST1);\r\nctx->sh_desc_dec_dma = dma_map_single(jrdev, desc,\r\ndesc_bytes(desc),\r\nDMA_TO_DEVICE);\r\nif (dma_mapping_error(jrdev, ctx->sh_desc_dec_dma)) {\r\ndev_err(jrdev, "unable to map shared descriptor\n");\r\nreturn -ENOMEM;\r\n}\r\n#ifdef DEBUG\r\nprint_hex_dump(KERN_ERR, "rfc4543 dec shdesc@"__stringify(__LINE__)": ",\r\nDUMP_PREFIX_ADDRESS, 16, 4, desc,\r\ndesc_bytes(desc), 1);\r\n#endif\r\nkeys_fit_inline = false;\r\nif (DESC_RFC4543_GIVENC_LEN + DESC_JOB_IO_LEN +\r\nctx->enckeylen <= CAAM_DESC_BYTES_MAX)\r\nkeys_fit_inline = true;\r\ndesc = ctx->sh_desc_givenc;\r\ninit_sh_desc(desc, HDR_SHARE_SERIAL);\r\nkey_jump_cmd = append_jump(desc, JUMP_JSL | JUMP_TEST_ALL |\r\nJUMP_COND_SHRD);\r\nif (keys_fit_inline)\r\nappend_key_as_imm(desc, (void *)ctx->key, ctx->enckeylen,\r\nctx->enckeylen, CLASS_1 | KEY_DEST_CLASS_REG);\r\nelse\r\nappend_key(desc, ctx->key_dma, ctx->enckeylen,\r\nCLASS_1 | KEY_DEST_CLASS_REG);\r\nset_jump_tgt_here(desc, key_jump_cmd);\r\ngeniv = NFIFOENTRY_STYPE_PAD | NFIFOENTRY_DEST_DECO |\r\nNFIFOENTRY_DTYPE_MSG | NFIFOENTRY_LC1 |\r\nNFIFOENTRY_PTYPE_RND | (tfm->ivsize << NFIFOENTRY_DLEN_SHIFT);\r\nappend_load_imm_u32(desc, geniv, LDST_CLASS_IND_CCB |\r\nLDST_SRCDST_WORD_INFO_FIFO | LDST_IMM);\r\nappend_cmd(desc, CMD_LOAD | DISABLE_AUTO_INFO_FIFO);\r\nappend_move(desc, MOVE_SRC_INFIFO | MOVE_DEST_MATH1 |\r\n(tfm->ivsize << MOVE_LEN_SHIFT));\r\nappend_cmd(desc, CMD_LOAD | ENABLE_AUTO_INFO_FIFO);\r\nwrite_iv_cmd = append_move(desc, MOVE_SRC_MATH1 | MOVE_DEST_DESCBUF |\r\n(tfm->ivsize << MOVE_LEN_SHIFT));\r\nwrite_aad_cmd = append_move(desc, MOVE_SRC_MATH1 | MOVE_DEST_DESCBUF |\r\n(tfm->ivsize << MOVE_LEN_SHIFT));\r\nappend_move(desc, MOVE_SRC_MATH1 | MOVE_DEST_OUTFIFO |\r\n(tfm->ivsize << MOVE_LEN_SHIFT));\r\nappend_operation(desc, ctx->class1_alg_type |\r\nOP_ALG_AS_INITFINAL | OP_ALG_ENCRYPT);\r\nappend_math_sub_imm_u32(desc, REG3, SEQOUTLEN, IMM, ctx->authsize);\r\nappend_math_sub(desc, VARSEQINLEN, SEQINLEN, REG3, CAAM_CMD_SZ);\r\nappend_math_add(desc, VARSEQOUTLEN, REG3, REG0, CAAM_CMD_SZ);\r\nread_move_cmd = append_move(desc, MOVE_SRC_DESCBUF | MOVE_DEST_MATH3 |\r\n(0x6 << MOVE_LEN_SHIFT));\r\nwrite_move_cmd = append_move(desc, MOVE_SRC_MATH3 | MOVE_DEST_DESCBUF |\r\n(0x8 << MOVE_LEN_SHIFT));\r\nappend_cmd(desc, CMD_FIFO_LOAD | FIFOLD_CLASS_CLASS1 | IMMEDIATE |\r\nFIFOLD_TYPE_IV | FIFOLD_TYPE_FLUSH1 | (4 + tfm->ivsize));\r\nappend_data(desc, (void *)(ctx->key + ctx->enckeylen), 4);\r\nset_move_tgt_here(desc, write_iv_cmd);\r\nappend_cmd(desc, 0x00000000);\r\nappend_cmd(desc, 0x00000000);\r\nappend_seq_fifo_load(desc, tfm->ivsize, FIFOLD_CLASS_SKIP);\r\nappend_seq_fifo_load(desc, 0, FIFOLD_CLASS_CLASS1 | FIFOLDST_VLF |\r\nFIFOLD_TYPE_AAD);\r\nappend_math_add(desc, VARSEQINLEN, SEQINLEN, REG0, CAAM_CMD_SZ);\r\nappend_cmd(desc, CMD_FIFO_LOAD | FIFOLD_CLASS_CLASS1 | IMMEDIATE |\r\nFIFOLD_TYPE_AAD | tfm->ivsize);\r\nset_move_tgt_here(desc, write_aad_cmd);\r\nappend_cmd(desc, 0x00000000);\r\nappend_cmd(desc, 0x00000000);\r\naead_append_src_dst(desc, FIFOLD_TYPE_AAD);\r\nset_move_tgt_here(desc, read_move_cmd);\r\nset_move_tgt_here(desc, write_move_cmd);\r\nappend_cmd(desc, CMD_LOAD | DISABLE_AUTO_INFO_FIFO);\r\nappend_move(desc, MOVE_SRC_INFIFO_CL | MOVE_DEST_OUTFIFO);\r\nappend_seq_store(desc, ctx->authsize, LDST_CLASS_1_CCB |\r\nLDST_SRCDST_BYTE_CONTEXT);\r\nctx->sh_desc_givenc_dma = dma_map_single(jrdev, desc,\r\ndesc_bytes(desc),\r\nDMA_TO_DEVICE);\r\nif (dma_mapping_error(jrdev, ctx->sh_desc_givenc_dma)) {\r\ndev_err(jrdev, "unable to map shared descriptor\n");\r\nreturn -ENOMEM;\r\n}\r\n#ifdef DEBUG\r\nprint_hex_dump(KERN_ERR,\r\n"rfc4543 givenc shdesc@"__stringify(__LINE__)": ",\r\nDUMP_PREFIX_ADDRESS, 16, 4, desc,\r\ndesc_bytes(desc), 1);\r\n#endif\r\nreturn 0;\r\n}\r\nstatic int rfc4543_setauthsize(struct crypto_aead *authenc,\r\nunsigned int authsize)\r\n{\r\nstruct caam_ctx *ctx = crypto_aead_ctx(authenc);\r\nctx->authsize = authsize;\r\nrfc4543_set_sh_desc(authenc);\r\nreturn 0;\r\n}\r\nstatic u32 gen_split_aead_key(struct caam_ctx *ctx, const u8 *key_in,\r\nu32 authkeylen)\r\n{\r\nreturn gen_split_key(ctx->jrdev, ctx->key, ctx->split_key_len,\r\nctx->split_key_pad_len, key_in, authkeylen,\r\nctx->alg_op);\r\n}\r\nstatic int aead_setkey(struct crypto_aead *aead,\r\nconst u8 *key, unsigned int keylen)\r\n{\r\nstatic const u8 mdpadlen[] = { 16, 20, 32, 32, 64, 64 };\r\nstruct caam_ctx *ctx = crypto_aead_ctx(aead);\r\nstruct device *jrdev = ctx->jrdev;\r\nstruct crypto_authenc_keys keys;\r\nint ret = 0;\r\nif (crypto_authenc_extractkeys(&keys, key, keylen) != 0)\r\ngoto badkey;\r\nctx->split_key_len = mdpadlen[(ctx->alg_op & OP_ALG_ALGSEL_SUBMASK) >>\r\nOP_ALG_ALGSEL_SHIFT] * 2;\r\nctx->split_key_pad_len = ALIGN(ctx->split_key_len, 16);\r\nif (ctx->split_key_pad_len + keys.enckeylen > CAAM_MAX_KEY_SIZE)\r\ngoto badkey;\r\n#ifdef DEBUG\r\nprintk(KERN_ERR "keylen %d enckeylen %d authkeylen %d\n",\r\nkeys.authkeylen + keys.enckeylen, keys.enckeylen,\r\nkeys.authkeylen);\r\nprintk(KERN_ERR "split_key_len %d split_key_pad_len %d\n",\r\nctx->split_key_len, ctx->split_key_pad_len);\r\nprint_hex_dump(KERN_ERR, "key in @"__stringify(__LINE__)": ",\r\nDUMP_PREFIX_ADDRESS, 16, 4, key, keylen, 1);\r\n#endif\r\nret = gen_split_aead_key(ctx, keys.authkey, keys.authkeylen);\r\nif (ret) {\r\ngoto badkey;\r\n}\r\nmemcpy(ctx->key + ctx->split_key_pad_len, keys.enckey, keys.enckeylen);\r\nctx->key_dma = dma_map_single(jrdev, ctx->key, ctx->split_key_pad_len +\r\nkeys.enckeylen, DMA_TO_DEVICE);\r\nif (dma_mapping_error(jrdev, ctx->key_dma)) {\r\ndev_err(jrdev, "unable to map key i/o memory\n");\r\nreturn -ENOMEM;\r\n}\r\n#ifdef DEBUG\r\nprint_hex_dump(KERN_ERR, "ctx.key@"__stringify(__LINE__)": ",\r\nDUMP_PREFIX_ADDRESS, 16, 4, ctx->key,\r\nctx->split_key_pad_len + keys.enckeylen, 1);\r\n#endif\r\nctx->enckeylen = keys.enckeylen;\r\nret = aead_set_sh_desc(aead);\r\nif (ret) {\r\ndma_unmap_single(jrdev, ctx->key_dma, ctx->split_key_pad_len +\r\nkeys.enckeylen, DMA_TO_DEVICE);\r\n}\r\nreturn ret;\r\nbadkey:\r\ncrypto_aead_set_flags(aead, CRYPTO_TFM_RES_BAD_KEY_LEN);\r\nreturn -EINVAL;\r\n}\r\nstatic int gcm_setkey(struct crypto_aead *aead,\r\nconst u8 *key, unsigned int keylen)\r\n{\r\nstruct caam_ctx *ctx = crypto_aead_ctx(aead);\r\nstruct device *jrdev = ctx->jrdev;\r\nint ret = 0;\r\n#ifdef DEBUG\r\nprint_hex_dump(KERN_ERR, "key in @"__stringify(__LINE__)": ",\r\nDUMP_PREFIX_ADDRESS, 16, 4, key, keylen, 1);\r\n#endif\r\nmemcpy(ctx->key, key, keylen);\r\nctx->key_dma = dma_map_single(jrdev, ctx->key, keylen,\r\nDMA_TO_DEVICE);\r\nif (dma_mapping_error(jrdev, ctx->key_dma)) {\r\ndev_err(jrdev, "unable to map key i/o memory\n");\r\nreturn -ENOMEM;\r\n}\r\nctx->enckeylen = keylen;\r\nret = gcm_set_sh_desc(aead);\r\nif (ret) {\r\ndma_unmap_single(jrdev, ctx->key_dma, ctx->enckeylen,\r\nDMA_TO_DEVICE);\r\n}\r\nreturn ret;\r\n}\r\nstatic int rfc4106_setkey(struct crypto_aead *aead,\r\nconst u8 *key, unsigned int keylen)\r\n{\r\nstruct caam_ctx *ctx = crypto_aead_ctx(aead);\r\nstruct device *jrdev = ctx->jrdev;\r\nint ret = 0;\r\nif (keylen < 4)\r\nreturn -EINVAL;\r\n#ifdef DEBUG\r\nprint_hex_dump(KERN_ERR, "key in @"__stringify(__LINE__)": ",\r\nDUMP_PREFIX_ADDRESS, 16, 4, key, keylen, 1);\r\n#endif\r\nmemcpy(ctx->key, key, keylen);\r\nctx->enckeylen = keylen - 4;\r\nctx->key_dma = dma_map_single(jrdev, ctx->key, ctx->enckeylen,\r\nDMA_TO_DEVICE);\r\nif (dma_mapping_error(jrdev, ctx->key_dma)) {\r\ndev_err(jrdev, "unable to map key i/o memory\n");\r\nreturn -ENOMEM;\r\n}\r\nret = rfc4106_set_sh_desc(aead);\r\nif (ret) {\r\ndma_unmap_single(jrdev, ctx->key_dma, ctx->enckeylen,\r\nDMA_TO_DEVICE);\r\n}\r\nreturn ret;\r\n}\r\nstatic int rfc4543_setkey(struct crypto_aead *aead,\r\nconst u8 *key, unsigned int keylen)\r\n{\r\nstruct caam_ctx *ctx = crypto_aead_ctx(aead);\r\nstruct device *jrdev = ctx->jrdev;\r\nint ret = 0;\r\nif (keylen < 4)\r\nreturn -EINVAL;\r\n#ifdef DEBUG\r\nprint_hex_dump(KERN_ERR, "key in @"__stringify(__LINE__)": ",\r\nDUMP_PREFIX_ADDRESS, 16, 4, key, keylen, 1);\r\n#endif\r\nmemcpy(ctx->key, key, keylen);\r\nctx->enckeylen = keylen - 4;\r\nctx->key_dma = dma_map_single(jrdev, ctx->key, ctx->enckeylen,\r\nDMA_TO_DEVICE);\r\nif (dma_mapping_error(jrdev, ctx->key_dma)) {\r\ndev_err(jrdev, "unable to map key i/o memory\n");\r\nreturn -ENOMEM;\r\n}\r\nret = rfc4543_set_sh_desc(aead);\r\nif (ret) {\r\ndma_unmap_single(jrdev, ctx->key_dma, ctx->enckeylen,\r\nDMA_TO_DEVICE);\r\n}\r\nreturn ret;\r\n}\r\nstatic int ablkcipher_setkey(struct crypto_ablkcipher *ablkcipher,\r\nconst u8 *key, unsigned int keylen)\r\n{\r\nstruct caam_ctx *ctx = crypto_ablkcipher_ctx(ablkcipher);\r\nstruct ablkcipher_tfm *crt = &ablkcipher->base.crt_ablkcipher;\r\nstruct crypto_tfm *tfm = crypto_ablkcipher_tfm(ablkcipher);\r\nconst char *alg_name = crypto_tfm_alg_name(tfm);\r\nstruct device *jrdev = ctx->jrdev;\r\nint ret = 0;\r\nu32 *key_jump_cmd;\r\nu32 *desc;\r\nu32 *nonce;\r\nu32 geniv;\r\nu32 ctx1_iv_off = 0;\r\nconst bool ctr_mode = ((ctx->class1_alg_type & OP_ALG_AAI_MASK) ==\r\nOP_ALG_AAI_CTR_MOD128);\r\nconst bool is_rfc3686 = (ctr_mode &&\r\n(strstr(alg_name, "rfc3686") != NULL));\r\n#ifdef DEBUG\r\nprint_hex_dump(KERN_ERR, "key in @"__stringify(__LINE__)": ",\r\nDUMP_PREFIX_ADDRESS, 16, 4, key, keylen, 1);\r\n#endif\r\nif (ctr_mode)\r\nctx1_iv_off = 16;\r\nif (is_rfc3686) {\r\nctx1_iv_off = 16 + CTR_RFC3686_NONCE_SIZE;\r\nkeylen -= CTR_RFC3686_NONCE_SIZE;\r\n}\r\nmemcpy(ctx->key, key, keylen);\r\nctx->key_dma = dma_map_single(jrdev, ctx->key, keylen,\r\nDMA_TO_DEVICE);\r\nif (dma_mapping_error(jrdev, ctx->key_dma)) {\r\ndev_err(jrdev, "unable to map key i/o memory\n");\r\nreturn -ENOMEM;\r\n}\r\nctx->enckeylen = keylen;\r\ndesc = ctx->sh_desc_enc;\r\ninit_sh_desc(desc, HDR_SHARE_SERIAL | HDR_SAVECTX);\r\nkey_jump_cmd = append_jump(desc, JUMP_JSL | JUMP_TEST_ALL |\r\nJUMP_COND_SHRD);\r\nappend_key_as_imm(desc, (void *)ctx->key, ctx->enckeylen,\r\nctx->enckeylen, CLASS_1 |\r\nKEY_DEST_CLASS_REG);\r\nif (is_rfc3686) {\r\nnonce = (u32 *)(key + keylen);\r\nappend_load_imm_u32(desc, *nonce, LDST_CLASS_IND_CCB |\r\nLDST_SRCDST_BYTE_OUTFIFO | LDST_IMM);\r\nappend_move(desc, MOVE_WAITCOMP |\r\nMOVE_SRC_OUTFIFO |\r\nMOVE_DEST_CLASS1CTX |\r\n(16 << MOVE_OFFSET_SHIFT) |\r\n(CTR_RFC3686_NONCE_SIZE << MOVE_LEN_SHIFT));\r\n}\r\nset_jump_tgt_here(desc, key_jump_cmd);\r\nappend_seq_load(desc, crt->ivsize, LDST_SRCDST_BYTE_CONTEXT |\r\nLDST_CLASS_1_CCB | (ctx1_iv_off << LDST_OFFSET_SHIFT));\r\nif (is_rfc3686)\r\nappend_load_imm_u32(desc, be32_to_cpu(1), LDST_IMM |\r\nLDST_CLASS_1_CCB |\r\nLDST_SRCDST_BYTE_CONTEXT |\r\n((ctx1_iv_off + CTR_RFC3686_IV_SIZE) <<\r\nLDST_OFFSET_SHIFT));\r\nappend_operation(desc, ctx->class1_alg_type |\r\nOP_ALG_AS_INITFINAL | OP_ALG_ENCRYPT);\r\nablkcipher_append_src_dst(desc);\r\nctx->sh_desc_enc_dma = dma_map_single(jrdev, desc,\r\ndesc_bytes(desc),\r\nDMA_TO_DEVICE);\r\nif (dma_mapping_error(jrdev, ctx->sh_desc_enc_dma)) {\r\ndev_err(jrdev, "unable to map shared descriptor\n");\r\nreturn -ENOMEM;\r\n}\r\n#ifdef DEBUG\r\nprint_hex_dump(KERN_ERR,\r\n"ablkcipher enc shdesc@"__stringify(__LINE__)": ",\r\nDUMP_PREFIX_ADDRESS, 16, 4, desc,\r\ndesc_bytes(desc), 1);\r\n#endif\r\ndesc = ctx->sh_desc_dec;\r\ninit_sh_desc(desc, HDR_SHARE_SERIAL | HDR_SAVECTX);\r\nkey_jump_cmd = append_jump(desc, JUMP_JSL | JUMP_TEST_ALL |\r\nJUMP_COND_SHRD);\r\nappend_key_as_imm(desc, (void *)ctx->key, ctx->enckeylen,\r\nctx->enckeylen, CLASS_1 |\r\nKEY_DEST_CLASS_REG);\r\nif (is_rfc3686) {\r\nnonce = (u32 *)(key + keylen);\r\nappend_load_imm_u32(desc, *nonce, LDST_CLASS_IND_CCB |\r\nLDST_SRCDST_BYTE_OUTFIFO | LDST_IMM);\r\nappend_move(desc, MOVE_WAITCOMP |\r\nMOVE_SRC_OUTFIFO |\r\nMOVE_DEST_CLASS1CTX |\r\n(16 << MOVE_OFFSET_SHIFT) |\r\n(CTR_RFC3686_NONCE_SIZE << MOVE_LEN_SHIFT));\r\n}\r\nset_jump_tgt_here(desc, key_jump_cmd);\r\nappend_seq_load(desc, crt->ivsize, LDST_SRCDST_BYTE_CONTEXT |\r\nLDST_CLASS_1_CCB | (ctx1_iv_off << LDST_OFFSET_SHIFT));\r\nif (is_rfc3686)\r\nappend_load_imm_u32(desc, be32_to_cpu(1), LDST_IMM |\r\nLDST_CLASS_1_CCB |\r\nLDST_SRCDST_BYTE_CONTEXT |\r\n((ctx1_iv_off + CTR_RFC3686_IV_SIZE) <<\r\nLDST_OFFSET_SHIFT));\r\nif (ctr_mode)\r\nappend_operation(desc, ctx->class1_alg_type |\r\nOP_ALG_AS_INITFINAL | OP_ALG_DECRYPT);\r\nelse\r\nappend_dec_op1(desc, ctx->class1_alg_type);\r\nablkcipher_append_src_dst(desc);\r\nctx->sh_desc_dec_dma = dma_map_single(jrdev, desc,\r\ndesc_bytes(desc),\r\nDMA_TO_DEVICE);\r\nif (dma_mapping_error(jrdev, ctx->sh_desc_dec_dma)) {\r\ndev_err(jrdev, "unable to map shared descriptor\n");\r\nreturn -ENOMEM;\r\n}\r\n#ifdef DEBUG\r\nprint_hex_dump(KERN_ERR,\r\n"ablkcipher dec shdesc@"__stringify(__LINE__)": ",\r\nDUMP_PREFIX_ADDRESS, 16, 4, desc,\r\ndesc_bytes(desc), 1);\r\n#endif\r\ndesc = ctx->sh_desc_givenc;\r\ninit_sh_desc(desc, HDR_SHARE_SERIAL | HDR_SAVECTX);\r\nkey_jump_cmd = append_jump(desc, JUMP_JSL | JUMP_TEST_ALL |\r\nJUMP_COND_SHRD);\r\nappend_key_as_imm(desc, (void *)ctx->key, ctx->enckeylen,\r\nctx->enckeylen, CLASS_1 |\r\nKEY_DEST_CLASS_REG);\r\nif (is_rfc3686) {\r\nnonce = (u32 *)(key + keylen);\r\nappend_load_imm_u32(desc, *nonce, LDST_CLASS_IND_CCB |\r\nLDST_SRCDST_BYTE_OUTFIFO | LDST_IMM);\r\nappend_move(desc, MOVE_WAITCOMP |\r\nMOVE_SRC_OUTFIFO |\r\nMOVE_DEST_CLASS1CTX |\r\n(16 << MOVE_OFFSET_SHIFT) |\r\n(CTR_RFC3686_NONCE_SIZE << MOVE_LEN_SHIFT));\r\n}\r\nset_jump_tgt_here(desc, key_jump_cmd);\r\ngeniv = NFIFOENTRY_STYPE_PAD | NFIFOENTRY_DEST_DECO |\r\nNFIFOENTRY_DTYPE_MSG | NFIFOENTRY_LC1 |\r\nNFIFOENTRY_PTYPE_RND | (crt->ivsize << NFIFOENTRY_DLEN_SHIFT);\r\nappend_load_imm_u32(desc, geniv, LDST_CLASS_IND_CCB |\r\nLDST_SRCDST_WORD_INFO_FIFO | LDST_IMM);\r\nappend_cmd(desc, CMD_LOAD | DISABLE_AUTO_INFO_FIFO);\r\nappend_move(desc, MOVE_WAITCOMP |\r\nMOVE_SRC_INFIFO |\r\nMOVE_DEST_CLASS1CTX |\r\n(crt->ivsize << MOVE_LEN_SHIFT) |\r\n(ctx1_iv_off << MOVE_OFFSET_SHIFT));\r\nappend_cmd(desc, CMD_LOAD | ENABLE_AUTO_INFO_FIFO);\r\nappend_seq_store(desc, crt->ivsize,\r\nLDST_SRCDST_BYTE_CONTEXT | LDST_CLASS_1_CCB |\r\n(ctx1_iv_off << LDST_OFFSET_SHIFT));\r\nif (is_rfc3686)\r\nappend_load_imm_u32(desc, (u32)1, LDST_IMM |\r\nLDST_CLASS_1_CCB |\r\nLDST_SRCDST_BYTE_CONTEXT |\r\n((ctx1_iv_off + CTR_RFC3686_IV_SIZE) <<\r\nLDST_OFFSET_SHIFT));\r\nif (ctx1_iv_off)\r\nappend_jump(desc, JUMP_JSL | JUMP_TEST_ALL | JUMP_COND_NCP |\r\n(1 << JUMP_OFFSET_SHIFT));\r\nappend_operation(desc, ctx->class1_alg_type |\r\nOP_ALG_AS_INITFINAL | OP_ALG_ENCRYPT);\r\nablkcipher_append_src_dst(desc);\r\nctx->sh_desc_givenc_dma = dma_map_single(jrdev, desc,\r\ndesc_bytes(desc),\r\nDMA_TO_DEVICE);\r\nif (dma_mapping_error(jrdev, ctx->sh_desc_givenc_dma)) {\r\ndev_err(jrdev, "unable to map shared descriptor\n");\r\nreturn -ENOMEM;\r\n}\r\n#ifdef DEBUG\r\nprint_hex_dump(KERN_ERR,\r\n"ablkcipher givenc shdesc@" __stringify(__LINE__) ": ",\r\nDUMP_PREFIX_ADDRESS, 16, 4, desc,\r\ndesc_bytes(desc), 1);\r\n#endif\r\nreturn ret;\r\n}\r\nstatic void caam_unmap(struct device *dev, struct scatterlist *src,\r\nstruct scatterlist *dst, int src_nents,\r\nbool src_chained, int dst_nents, bool dst_chained,\r\ndma_addr_t iv_dma, int ivsize, dma_addr_t sec4_sg_dma,\r\nint sec4_sg_bytes)\r\n{\r\nif (dst != src) {\r\ndma_unmap_sg_chained(dev, src, src_nents ? : 1, DMA_TO_DEVICE,\r\nsrc_chained);\r\ndma_unmap_sg_chained(dev, dst, dst_nents ? : 1, DMA_FROM_DEVICE,\r\ndst_chained);\r\n} else {\r\ndma_unmap_sg_chained(dev, src, src_nents ? : 1,\r\nDMA_BIDIRECTIONAL, src_chained);\r\n}\r\nif (iv_dma)\r\ndma_unmap_single(dev, iv_dma, ivsize, DMA_TO_DEVICE);\r\nif (sec4_sg_bytes)\r\ndma_unmap_single(dev, sec4_sg_dma, sec4_sg_bytes,\r\nDMA_TO_DEVICE);\r\n}\r\nstatic void aead_unmap(struct device *dev,\r\nstruct aead_edesc *edesc,\r\nstruct aead_request *req)\r\n{\r\nstruct crypto_aead *aead = crypto_aead_reqtfm(req);\r\nint ivsize = crypto_aead_ivsize(aead);\r\ndma_unmap_sg_chained(dev, req->assoc, edesc->assoc_nents,\r\nDMA_TO_DEVICE, edesc->assoc_chained);\r\ncaam_unmap(dev, req->src, req->dst,\r\nedesc->src_nents, edesc->src_chained, edesc->dst_nents,\r\nedesc->dst_chained, edesc->iv_dma, ivsize,\r\nedesc->sec4_sg_dma, edesc->sec4_sg_bytes);\r\n}\r\nstatic void ablkcipher_unmap(struct device *dev,\r\nstruct ablkcipher_edesc *edesc,\r\nstruct ablkcipher_request *req)\r\n{\r\nstruct crypto_ablkcipher *ablkcipher = crypto_ablkcipher_reqtfm(req);\r\nint ivsize = crypto_ablkcipher_ivsize(ablkcipher);\r\ncaam_unmap(dev, req->src, req->dst,\r\nedesc->src_nents, edesc->src_chained, edesc->dst_nents,\r\nedesc->dst_chained, edesc->iv_dma, ivsize,\r\nedesc->sec4_sg_dma, edesc->sec4_sg_bytes);\r\n}\r\nstatic void aead_encrypt_done(struct device *jrdev, u32 *desc, u32 err,\r\nvoid *context)\r\n{\r\nstruct aead_request *req = context;\r\nstruct aead_edesc *edesc;\r\n#ifdef DEBUG\r\nstruct crypto_aead *aead = crypto_aead_reqtfm(req);\r\nstruct caam_ctx *ctx = crypto_aead_ctx(aead);\r\nint ivsize = crypto_aead_ivsize(aead);\r\ndev_err(jrdev, "%s %d: err 0x%x\n", __func__, __LINE__, err);\r\n#endif\r\nedesc = (struct aead_edesc *)((char *)desc -\r\noffsetof(struct aead_edesc, hw_desc));\r\nif (err)\r\ncaam_jr_strstatus(jrdev, err);\r\naead_unmap(jrdev, edesc, req);\r\n#ifdef DEBUG\r\nprint_hex_dump(KERN_ERR, "assoc @"__stringify(__LINE__)": ",\r\nDUMP_PREFIX_ADDRESS, 16, 4, sg_virt(req->assoc),\r\nreq->assoclen , 1);\r\nprint_hex_dump(KERN_ERR, "dstiv @"__stringify(__LINE__)": ",\r\nDUMP_PREFIX_ADDRESS, 16, 4, sg_virt(req->src) - ivsize,\r\nedesc->src_nents ? 100 : ivsize, 1);\r\nprint_hex_dump(KERN_ERR, "dst @"__stringify(__LINE__)": ",\r\nDUMP_PREFIX_ADDRESS, 16, 4, sg_virt(req->src),\r\nedesc->src_nents ? 100 : req->cryptlen +\r\nctx->authsize + 4, 1);\r\n#endif\r\nkfree(edesc);\r\naead_request_complete(req, err);\r\n}\r\nstatic void aead_decrypt_done(struct device *jrdev, u32 *desc, u32 err,\r\nvoid *context)\r\n{\r\nstruct aead_request *req = context;\r\nstruct aead_edesc *edesc;\r\n#ifdef DEBUG\r\nstruct crypto_aead *aead = crypto_aead_reqtfm(req);\r\nstruct caam_ctx *ctx = crypto_aead_ctx(aead);\r\nint ivsize = crypto_aead_ivsize(aead);\r\ndev_err(jrdev, "%s %d: err 0x%x\n", __func__, __LINE__, err);\r\n#endif\r\nedesc = (struct aead_edesc *)((char *)desc -\r\noffsetof(struct aead_edesc, hw_desc));\r\n#ifdef DEBUG\r\nprint_hex_dump(KERN_ERR, "dstiv @"__stringify(__LINE__)": ",\r\nDUMP_PREFIX_ADDRESS, 16, 4, req->iv,\r\nivsize, 1);\r\nprint_hex_dump(KERN_ERR, "dst @"__stringify(__LINE__)": ",\r\nDUMP_PREFIX_ADDRESS, 16, 4, sg_virt(req->dst),\r\nreq->cryptlen - ctx->authsize, 1);\r\n#endif\r\nif (err)\r\ncaam_jr_strstatus(jrdev, err);\r\naead_unmap(jrdev, edesc, req);\r\nif ((err & JRSTA_CCBERR_ERRID_MASK) == JRSTA_CCBERR_ERRID_ICVCHK)\r\nerr = -EBADMSG;\r\n#ifdef DEBUG\r\nprint_hex_dump(KERN_ERR, "iphdrout@"__stringify(__LINE__)": ",\r\nDUMP_PREFIX_ADDRESS, 16, 4,\r\n((char *)sg_virt(req->assoc) - sizeof(struct iphdr)),\r\nsizeof(struct iphdr) + req->assoclen +\r\n((req->cryptlen > 1500) ? 1500 : req->cryptlen) +\r\nctx->authsize + 36, 1);\r\nif (!err && edesc->sec4_sg_bytes) {\r\nstruct scatterlist *sg = sg_last(req->src, edesc->src_nents);\r\nprint_hex_dump(KERN_ERR, "sglastout@"__stringify(__LINE__)": ",\r\nDUMP_PREFIX_ADDRESS, 16, 4, sg_virt(sg),\r\nsg->length + ctx->authsize + 16, 1);\r\n}\r\n#endif\r\nkfree(edesc);\r\naead_request_complete(req, err);\r\n}\r\nstatic void ablkcipher_encrypt_done(struct device *jrdev, u32 *desc, u32 err,\r\nvoid *context)\r\n{\r\nstruct ablkcipher_request *req = context;\r\nstruct ablkcipher_edesc *edesc;\r\n#ifdef DEBUG\r\nstruct crypto_ablkcipher *ablkcipher = crypto_ablkcipher_reqtfm(req);\r\nint ivsize = crypto_ablkcipher_ivsize(ablkcipher);\r\ndev_err(jrdev, "%s %d: err 0x%x\n", __func__, __LINE__, err);\r\n#endif\r\nedesc = (struct ablkcipher_edesc *)((char *)desc -\r\noffsetof(struct ablkcipher_edesc, hw_desc));\r\nif (err)\r\ncaam_jr_strstatus(jrdev, err);\r\n#ifdef DEBUG\r\nprint_hex_dump(KERN_ERR, "dstiv @"__stringify(__LINE__)": ",\r\nDUMP_PREFIX_ADDRESS, 16, 4, req->info,\r\nedesc->src_nents > 1 ? 100 : ivsize, 1);\r\nprint_hex_dump(KERN_ERR, "dst @"__stringify(__LINE__)": ",\r\nDUMP_PREFIX_ADDRESS, 16, 4, sg_virt(req->src),\r\nedesc->dst_nents > 1 ? 100 : req->nbytes, 1);\r\n#endif\r\nablkcipher_unmap(jrdev, edesc, req);\r\nkfree(edesc);\r\nablkcipher_request_complete(req, err);\r\n}\r\nstatic void ablkcipher_decrypt_done(struct device *jrdev, u32 *desc, u32 err,\r\nvoid *context)\r\n{\r\nstruct ablkcipher_request *req = context;\r\nstruct ablkcipher_edesc *edesc;\r\n#ifdef DEBUG\r\nstruct crypto_ablkcipher *ablkcipher = crypto_ablkcipher_reqtfm(req);\r\nint ivsize = crypto_ablkcipher_ivsize(ablkcipher);\r\ndev_err(jrdev, "%s %d: err 0x%x\n", __func__, __LINE__, err);\r\n#endif\r\nedesc = (struct ablkcipher_edesc *)((char *)desc -\r\noffsetof(struct ablkcipher_edesc, hw_desc));\r\nif (err)\r\ncaam_jr_strstatus(jrdev, err);\r\n#ifdef DEBUG\r\nprint_hex_dump(KERN_ERR, "dstiv @"__stringify(__LINE__)": ",\r\nDUMP_PREFIX_ADDRESS, 16, 4, req->info,\r\nivsize, 1);\r\nprint_hex_dump(KERN_ERR, "dst @"__stringify(__LINE__)": ",\r\nDUMP_PREFIX_ADDRESS, 16, 4, sg_virt(req->src),\r\nedesc->dst_nents > 1 ? 100 : req->nbytes, 1);\r\n#endif\r\nablkcipher_unmap(jrdev, edesc, req);\r\nkfree(edesc);\r\nablkcipher_request_complete(req, err);\r\n}\r\nstatic void init_aead_job(u32 *sh_desc, dma_addr_t ptr,\r\nstruct aead_edesc *edesc,\r\nstruct aead_request *req,\r\nbool all_contig, bool encrypt)\r\n{\r\nstruct crypto_aead *aead = crypto_aead_reqtfm(req);\r\nstruct caam_ctx *ctx = crypto_aead_ctx(aead);\r\nint ivsize = crypto_aead_ivsize(aead);\r\nint authsize = ctx->authsize;\r\nu32 *desc = edesc->hw_desc;\r\nu32 out_options = 0, in_options;\r\ndma_addr_t dst_dma, src_dma;\r\nint len, sec4_sg_index = 0;\r\nbool is_gcm = false;\r\n#ifdef DEBUG\r\ndebug("assoclen %d cryptlen %d authsize %d\n",\r\nreq->assoclen, req->cryptlen, authsize);\r\nprint_hex_dump(KERN_ERR, "assoc @"__stringify(__LINE__)": ",\r\nDUMP_PREFIX_ADDRESS, 16, 4, sg_virt(req->assoc),\r\nreq->assoclen , 1);\r\nprint_hex_dump(KERN_ERR, "presciv@"__stringify(__LINE__)": ",\r\nDUMP_PREFIX_ADDRESS, 16, 4, req->iv,\r\nedesc->src_nents ? 100 : ivsize, 1);\r\nprint_hex_dump(KERN_ERR, "src @"__stringify(__LINE__)": ",\r\nDUMP_PREFIX_ADDRESS, 16, 4, sg_virt(req->src),\r\nedesc->src_nents ? 100 : req->cryptlen, 1);\r\nprint_hex_dump(KERN_ERR, "shrdesc@"__stringify(__LINE__)": ",\r\nDUMP_PREFIX_ADDRESS, 16, 4, sh_desc,\r\ndesc_bytes(sh_desc), 1);\r\n#endif\r\nif (((ctx->class1_alg_type & OP_ALG_ALGSEL_MASK) ==\r\nOP_ALG_ALGSEL_AES) &&\r\n((ctx->class1_alg_type & OP_ALG_AAI_MASK) == OP_ALG_AAI_GCM))\r\nis_gcm = true;\r\nlen = desc_len(sh_desc);\r\ninit_job_desc_shared(desc, ptr, len, HDR_SHARE_DEFER | HDR_REVERSE);\r\nif (all_contig) {\r\nif (is_gcm)\r\nsrc_dma = edesc->iv_dma;\r\nelse\r\nsrc_dma = sg_dma_address(req->assoc);\r\nin_options = 0;\r\n} else {\r\nsrc_dma = edesc->sec4_sg_dma;\r\nsec4_sg_index += (edesc->assoc_nents ? : 1) + 1 +\r\n(edesc->src_nents ? : 1);\r\nin_options = LDST_SGF;\r\n}\r\nappend_seq_in_ptr(desc, src_dma, req->assoclen + ivsize + req->cryptlen,\r\nin_options);\r\nif (likely(req->src == req->dst)) {\r\nif (all_contig) {\r\ndst_dma = sg_dma_address(req->src);\r\n} else {\r\ndst_dma = src_dma + sizeof(struct sec4_sg_entry) *\r\n((edesc->assoc_nents ? : 1) + 1);\r\nout_options = LDST_SGF;\r\n}\r\n} else {\r\nif (!edesc->dst_nents) {\r\ndst_dma = sg_dma_address(req->dst);\r\n} else {\r\ndst_dma = edesc->sec4_sg_dma +\r\nsec4_sg_index *\r\nsizeof(struct sec4_sg_entry);\r\nout_options = LDST_SGF;\r\n}\r\n}\r\nif (encrypt)\r\nappend_seq_out_ptr(desc, dst_dma, req->cryptlen + authsize,\r\nout_options);\r\nelse\r\nappend_seq_out_ptr(desc, dst_dma, req->cryptlen - authsize,\r\nout_options);\r\n}\r\nstatic void init_aead_giv_job(u32 *sh_desc, dma_addr_t ptr,\r\nstruct aead_edesc *edesc,\r\nstruct aead_request *req,\r\nint contig)\r\n{\r\nstruct crypto_aead *aead = crypto_aead_reqtfm(req);\r\nstruct caam_ctx *ctx = crypto_aead_ctx(aead);\r\nint ivsize = crypto_aead_ivsize(aead);\r\nint authsize = ctx->authsize;\r\nu32 *desc = edesc->hw_desc;\r\nu32 out_options = 0, in_options;\r\ndma_addr_t dst_dma, src_dma;\r\nint len, sec4_sg_index = 0;\r\nbool is_gcm = false;\r\n#ifdef DEBUG\r\ndebug("assoclen %d cryptlen %d authsize %d\n",\r\nreq->assoclen, req->cryptlen, authsize);\r\nprint_hex_dump(KERN_ERR, "assoc @"__stringify(__LINE__)": ",\r\nDUMP_PREFIX_ADDRESS, 16, 4, sg_virt(req->assoc),\r\nreq->assoclen , 1);\r\nprint_hex_dump(KERN_ERR, "presciv@"__stringify(__LINE__)": ",\r\nDUMP_PREFIX_ADDRESS, 16, 4, req->iv, ivsize, 1);\r\nprint_hex_dump(KERN_ERR, "src @"__stringify(__LINE__)": ",\r\nDUMP_PREFIX_ADDRESS, 16, 4, sg_virt(req->src),\r\nedesc->src_nents > 1 ? 100 : req->cryptlen, 1);\r\nprint_hex_dump(KERN_ERR, "shrdesc@"__stringify(__LINE__)": ",\r\nDUMP_PREFIX_ADDRESS, 16, 4, sh_desc,\r\ndesc_bytes(sh_desc), 1);\r\n#endif\r\nif (((ctx->class1_alg_type & OP_ALG_ALGSEL_MASK) ==\r\nOP_ALG_ALGSEL_AES) &&\r\n((ctx->class1_alg_type & OP_ALG_AAI_MASK) == OP_ALG_AAI_GCM))\r\nis_gcm = true;\r\nlen = desc_len(sh_desc);\r\ninit_job_desc_shared(desc, ptr, len, HDR_SHARE_DEFER | HDR_REVERSE);\r\nif (contig & GIV_SRC_CONTIG) {\r\nif (is_gcm)\r\nsrc_dma = edesc->iv_dma;\r\nelse\r\nsrc_dma = sg_dma_address(req->assoc);\r\nin_options = 0;\r\n} else {\r\nsrc_dma = edesc->sec4_sg_dma;\r\nsec4_sg_index += edesc->assoc_nents + 1 + edesc->src_nents;\r\nin_options = LDST_SGF;\r\n}\r\nappend_seq_in_ptr(desc, src_dma, req->assoclen + ivsize + req->cryptlen,\r\nin_options);\r\nif (contig & GIV_DST_CONTIG) {\r\ndst_dma = edesc->iv_dma;\r\n} else {\r\nif (likely(req->src == req->dst)) {\r\ndst_dma = src_dma + sizeof(struct sec4_sg_entry) *\r\n(edesc->assoc_nents +\r\n(is_gcm ? 1 + edesc->src_nents : 0));\r\nout_options = LDST_SGF;\r\n} else {\r\ndst_dma = edesc->sec4_sg_dma +\r\nsec4_sg_index *\r\nsizeof(struct sec4_sg_entry);\r\nout_options = LDST_SGF;\r\n}\r\n}\r\nappend_seq_out_ptr(desc, dst_dma, ivsize + req->cryptlen + authsize,\r\nout_options);\r\n}\r\nstatic void init_ablkcipher_job(u32 *sh_desc, dma_addr_t ptr,\r\nstruct ablkcipher_edesc *edesc,\r\nstruct ablkcipher_request *req,\r\nbool iv_contig)\r\n{\r\nstruct crypto_ablkcipher *ablkcipher = crypto_ablkcipher_reqtfm(req);\r\nint ivsize = crypto_ablkcipher_ivsize(ablkcipher);\r\nu32 *desc = edesc->hw_desc;\r\nu32 out_options = 0, in_options;\r\ndma_addr_t dst_dma, src_dma;\r\nint len, sec4_sg_index = 0;\r\n#ifdef DEBUG\r\nprint_hex_dump(KERN_ERR, "presciv@"__stringify(__LINE__)": ",\r\nDUMP_PREFIX_ADDRESS, 16, 4, req->info,\r\nivsize, 1);\r\nprint_hex_dump(KERN_ERR, "src @"__stringify(__LINE__)": ",\r\nDUMP_PREFIX_ADDRESS, 16, 4, sg_virt(req->src),\r\nedesc->src_nents ? 100 : req->nbytes, 1);\r\n#endif\r\nlen = desc_len(sh_desc);\r\ninit_job_desc_shared(desc, ptr, len, HDR_SHARE_DEFER | HDR_REVERSE);\r\nif (iv_contig) {\r\nsrc_dma = edesc->iv_dma;\r\nin_options = 0;\r\n} else {\r\nsrc_dma = edesc->sec4_sg_dma;\r\nsec4_sg_index += edesc->src_nents + 1;\r\nin_options = LDST_SGF;\r\n}\r\nappend_seq_in_ptr(desc, src_dma, req->nbytes + ivsize, in_options);\r\nif (likely(req->src == req->dst)) {\r\nif (!edesc->src_nents && iv_contig) {\r\ndst_dma = sg_dma_address(req->src);\r\n} else {\r\ndst_dma = edesc->sec4_sg_dma +\r\nsizeof(struct sec4_sg_entry);\r\nout_options = LDST_SGF;\r\n}\r\n} else {\r\nif (!edesc->dst_nents) {\r\ndst_dma = sg_dma_address(req->dst);\r\n} else {\r\ndst_dma = edesc->sec4_sg_dma +\r\nsec4_sg_index * sizeof(struct sec4_sg_entry);\r\nout_options = LDST_SGF;\r\n}\r\n}\r\nappend_seq_out_ptr(desc, dst_dma, req->nbytes, out_options);\r\n}\r\nstatic void init_ablkcipher_giv_job(u32 *sh_desc, dma_addr_t ptr,\r\nstruct ablkcipher_edesc *edesc,\r\nstruct ablkcipher_request *req,\r\nbool iv_contig)\r\n{\r\nstruct crypto_ablkcipher *ablkcipher = crypto_ablkcipher_reqtfm(req);\r\nint ivsize = crypto_ablkcipher_ivsize(ablkcipher);\r\nu32 *desc = edesc->hw_desc;\r\nu32 out_options, in_options;\r\ndma_addr_t dst_dma, src_dma;\r\nint len, sec4_sg_index = 0;\r\n#ifdef DEBUG\r\nprint_hex_dump(KERN_ERR, "presciv@" __stringify(__LINE__) ": ",\r\nDUMP_PREFIX_ADDRESS, 16, 4, req->info,\r\nivsize, 1);\r\nprint_hex_dump(KERN_ERR, "src @" __stringify(__LINE__) ": ",\r\nDUMP_PREFIX_ADDRESS, 16, 4, sg_virt(req->src),\r\nedesc->src_nents ? 100 : req->nbytes, 1);\r\n#endif\r\nlen = desc_len(sh_desc);\r\ninit_job_desc_shared(desc, ptr, len, HDR_SHARE_DEFER | HDR_REVERSE);\r\nif (!edesc->src_nents) {\r\nsrc_dma = sg_dma_address(req->src);\r\nin_options = 0;\r\n} else {\r\nsrc_dma = edesc->sec4_sg_dma;\r\nsec4_sg_index += edesc->src_nents;\r\nin_options = LDST_SGF;\r\n}\r\nappend_seq_in_ptr(desc, src_dma, req->nbytes, in_options);\r\nif (iv_contig) {\r\ndst_dma = edesc->iv_dma;\r\nout_options = 0;\r\n} else {\r\ndst_dma = edesc->sec4_sg_dma +\r\nsec4_sg_index * sizeof(struct sec4_sg_entry);\r\nout_options = LDST_SGF;\r\n}\r\nappend_seq_out_ptr(desc, dst_dma, req->nbytes + ivsize, out_options);\r\n}\r\nstatic struct aead_edesc *aead_edesc_alloc(struct aead_request *req,\r\nint desc_bytes, bool *all_contig_ptr,\r\nbool encrypt)\r\n{\r\nstruct crypto_aead *aead = crypto_aead_reqtfm(req);\r\nstruct caam_ctx *ctx = crypto_aead_ctx(aead);\r\nstruct device *jrdev = ctx->jrdev;\r\ngfp_t flags = (req->base.flags & (CRYPTO_TFM_REQ_MAY_BACKLOG |\r\nCRYPTO_TFM_REQ_MAY_SLEEP)) ? GFP_KERNEL : GFP_ATOMIC;\r\nint assoc_nents, src_nents, dst_nents = 0;\r\nstruct aead_edesc *edesc;\r\ndma_addr_t iv_dma = 0;\r\nint sgc;\r\nbool all_contig = true;\r\nbool assoc_chained = false, src_chained = false, dst_chained = false;\r\nint ivsize = crypto_aead_ivsize(aead);\r\nint sec4_sg_index, sec4_sg_len = 0, sec4_sg_bytes;\r\nunsigned int authsize = ctx->authsize;\r\nbool is_gcm = false;\r\nassoc_nents = sg_count(req->assoc, req->assoclen, &assoc_chained);\r\nif (unlikely(req->dst != req->src)) {\r\nsrc_nents = sg_count(req->src, req->cryptlen, &src_chained);\r\ndst_nents = sg_count(req->dst,\r\nreq->cryptlen +\r\n(encrypt ? authsize : (-authsize)),\r\n&dst_chained);\r\n} else {\r\nsrc_nents = sg_count(req->src,\r\nreq->cryptlen +\r\n(encrypt ? authsize : 0),\r\n&src_chained);\r\n}\r\nsgc = dma_map_sg_chained(jrdev, req->assoc, assoc_nents ? : 1,\r\nDMA_TO_DEVICE, assoc_chained);\r\nif (likely(req->src == req->dst)) {\r\nsgc = dma_map_sg_chained(jrdev, req->src, src_nents ? : 1,\r\nDMA_BIDIRECTIONAL, src_chained);\r\n} else {\r\nsgc = dma_map_sg_chained(jrdev, req->src, src_nents ? : 1,\r\nDMA_TO_DEVICE, src_chained);\r\nsgc = dma_map_sg_chained(jrdev, req->dst, dst_nents ? : 1,\r\nDMA_FROM_DEVICE, dst_chained);\r\n}\r\niv_dma = dma_map_single(jrdev, req->iv, ivsize, DMA_TO_DEVICE);\r\nif (dma_mapping_error(jrdev, iv_dma)) {\r\ndev_err(jrdev, "unable to map IV\n");\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nif (((ctx->class1_alg_type & OP_ALG_ALGSEL_MASK) ==\r\nOP_ALG_ALGSEL_AES) &&\r\n((ctx->class1_alg_type & OP_ALG_AAI_MASK) == OP_ALG_AAI_GCM))\r\nis_gcm = true;\r\nif (is_gcm)\r\nall_contig = (!assoc_nents &&\r\niv_dma + ivsize == sg_dma_address(req->assoc) &&\r\n!src_nents && sg_dma_address(req->assoc) +\r\nreq->assoclen == sg_dma_address(req->src));\r\nelse\r\nall_contig = (!assoc_nents && sg_dma_address(req->assoc) +\r\nreq->assoclen == iv_dma && !src_nents &&\r\niv_dma + ivsize == sg_dma_address(req->src));\r\nif (!all_contig) {\r\nassoc_nents = assoc_nents ? : 1;\r\nsrc_nents = src_nents ? : 1;\r\nsec4_sg_len = assoc_nents + 1 + src_nents;\r\n}\r\nsec4_sg_len += dst_nents;\r\nsec4_sg_bytes = sec4_sg_len * sizeof(struct sec4_sg_entry);\r\nedesc = kmalloc(sizeof(struct aead_edesc) + desc_bytes +\r\nsec4_sg_bytes, GFP_DMA | flags);\r\nif (!edesc) {\r\ndev_err(jrdev, "could not allocate extended descriptor\n");\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nedesc->assoc_nents = assoc_nents;\r\nedesc->assoc_chained = assoc_chained;\r\nedesc->src_nents = src_nents;\r\nedesc->src_chained = src_chained;\r\nedesc->dst_nents = dst_nents;\r\nedesc->dst_chained = dst_chained;\r\nedesc->iv_dma = iv_dma;\r\nedesc->sec4_sg_bytes = sec4_sg_bytes;\r\nedesc->sec4_sg = (void *)edesc + sizeof(struct aead_edesc) +\r\ndesc_bytes;\r\n*all_contig_ptr = all_contig;\r\nsec4_sg_index = 0;\r\nif (!all_contig) {\r\nif (!is_gcm) {\r\nsg_to_sec4_sg(req->assoc,\r\nassoc_nents,\r\nedesc->sec4_sg +\r\nsec4_sg_index, 0);\r\nsec4_sg_index += assoc_nents;\r\n}\r\ndma_to_sec4_sg_one(edesc->sec4_sg + sec4_sg_index,\r\niv_dma, ivsize, 0);\r\nsec4_sg_index += 1;\r\nif (is_gcm) {\r\nsg_to_sec4_sg(req->assoc,\r\nassoc_nents,\r\nedesc->sec4_sg +\r\nsec4_sg_index, 0);\r\nsec4_sg_index += assoc_nents;\r\n}\r\nsg_to_sec4_sg_last(req->src,\r\nsrc_nents,\r\nedesc->sec4_sg +\r\nsec4_sg_index, 0);\r\nsec4_sg_index += src_nents;\r\n}\r\nif (dst_nents) {\r\nsg_to_sec4_sg_last(req->dst, dst_nents,\r\nedesc->sec4_sg + sec4_sg_index, 0);\r\n}\r\nedesc->sec4_sg_dma = dma_map_single(jrdev, edesc->sec4_sg,\r\nsec4_sg_bytes, DMA_TO_DEVICE);\r\nif (dma_mapping_error(jrdev, edesc->sec4_sg_dma)) {\r\ndev_err(jrdev, "unable to map S/G table\n");\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nreturn edesc;\r\n}\r\nstatic int aead_encrypt(struct aead_request *req)\r\n{\r\nstruct aead_edesc *edesc;\r\nstruct crypto_aead *aead = crypto_aead_reqtfm(req);\r\nstruct caam_ctx *ctx = crypto_aead_ctx(aead);\r\nstruct device *jrdev = ctx->jrdev;\r\nbool all_contig;\r\nu32 *desc;\r\nint ret = 0;\r\nedesc = aead_edesc_alloc(req, DESC_JOB_IO_LEN *\r\nCAAM_CMD_SZ, &all_contig, true);\r\nif (IS_ERR(edesc))\r\nreturn PTR_ERR(edesc);\r\ninit_aead_job(ctx->sh_desc_enc, ctx->sh_desc_enc_dma, edesc, req,\r\nall_contig, true);\r\n#ifdef DEBUG\r\nprint_hex_dump(KERN_ERR, "aead jobdesc@"__stringify(__LINE__)": ",\r\nDUMP_PREFIX_ADDRESS, 16, 4, edesc->hw_desc,\r\ndesc_bytes(edesc->hw_desc), 1);\r\n#endif\r\ndesc = edesc->hw_desc;\r\nret = caam_jr_enqueue(jrdev, desc, aead_encrypt_done, req);\r\nif (!ret) {\r\nret = -EINPROGRESS;\r\n} else {\r\naead_unmap(jrdev, edesc, req);\r\nkfree(edesc);\r\n}\r\nreturn ret;\r\n}\r\nstatic int aead_decrypt(struct aead_request *req)\r\n{\r\nstruct aead_edesc *edesc;\r\nstruct crypto_aead *aead = crypto_aead_reqtfm(req);\r\nstruct caam_ctx *ctx = crypto_aead_ctx(aead);\r\nstruct device *jrdev = ctx->jrdev;\r\nbool all_contig;\r\nu32 *desc;\r\nint ret = 0;\r\nedesc = aead_edesc_alloc(req, DESC_JOB_IO_LEN *\r\nCAAM_CMD_SZ, &all_contig, false);\r\nif (IS_ERR(edesc))\r\nreturn PTR_ERR(edesc);\r\n#ifdef DEBUG\r\nprint_hex_dump(KERN_ERR, "dec src@"__stringify(__LINE__)": ",\r\nDUMP_PREFIX_ADDRESS, 16, 4, sg_virt(req->src),\r\nreq->cryptlen, 1);\r\n#endif\r\ninit_aead_job(ctx->sh_desc_dec,\r\nctx->sh_desc_dec_dma, edesc, req, all_contig, false);\r\n#ifdef DEBUG\r\nprint_hex_dump(KERN_ERR, "aead jobdesc@"__stringify(__LINE__)": ",\r\nDUMP_PREFIX_ADDRESS, 16, 4, edesc->hw_desc,\r\ndesc_bytes(edesc->hw_desc), 1);\r\n#endif\r\ndesc = edesc->hw_desc;\r\nret = caam_jr_enqueue(jrdev, desc, aead_decrypt_done, req);\r\nif (!ret) {\r\nret = -EINPROGRESS;\r\n} else {\r\naead_unmap(jrdev, edesc, req);\r\nkfree(edesc);\r\n}\r\nreturn ret;\r\n}\r\nstatic struct aead_edesc *aead_giv_edesc_alloc(struct aead_givcrypt_request\r\n*greq, int desc_bytes,\r\nu32 *contig_ptr)\r\n{\r\nstruct aead_request *req = &greq->areq;\r\nstruct crypto_aead *aead = crypto_aead_reqtfm(req);\r\nstruct caam_ctx *ctx = crypto_aead_ctx(aead);\r\nstruct device *jrdev = ctx->jrdev;\r\ngfp_t flags = (req->base.flags & (CRYPTO_TFM_REQ_MAY_BACKLOG |\r\nCRYPTO_TFM_REQ_MAY_SLEEP)) ? GFP_KERNEL : GFP_ATOMIC;\r\nint assoc_nents, src_nents, dst_nents = 0;\r\nstruct aead_edesc *edesc;\r\ndma_addr_t iv_dma = 0;\r\nint sgc;\r\nu32 contig = GIV_SRC_CONTIG | GIV_DST_CONTIG;\r\nint ivsize = crypto_aead_ivsize(aead);\r\nbool assoc_chained = false, src_chained = false, dst_chained = false;\r\nint sec4_sg_index, sec4_sg_len = 0, sec4_sg_bytes;\r\nbool is_gcm = false;\r\nassoc_nents = sg_count(req->assoc, req->assoclen, &assoc_chained);\r\nsrc_nents = sg_count(req->src, req->cryptlen, &src_chained);\r\nif (unlikely(req->dst != req->src))\r\ndst_nents = sg_count(req->dst, req->cryptlen + ctx->authsize,\r\n&dst_chained);\r\nsgc = dma_map_sg_chained(jrdev, req->assoc, assoc_nents ? : 1,\r\nDMA_TO_DEVICE, assoc_chained);\r\nif (likely(req->src == req->dst)) {\r\nsgc = dma_map_sg_chained(jrdev, req->src, src_nents ? : 1,\r\nDMA_BIDIRECTIONAL, src_chained);\r\n} else {\r\nsgc = dma_map_sg_chained(jrdev, req->src, src_nents ? : 1,\r\nDMA_TO_DEVICE, src_chained);\r\nsgc = dma_map_sg_chained(jrdev, req->dst, dst_nents ? : 1,\r\nDMA_FROM_DEVICE, dst_chained);\r\n}\r\niv_dma = dma_map_single(jrdev, greq->giv, ivsize, DMA_TO_DEVICE);\r\nif (dma_mapping_error(jrdev, iv_dma)) {\r\ndev_err(jrdev, "unable to map IV\n");\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nif (((ctx->class1_alg_type & OP_ALG_ALGSEL_MASK) ==\r\nOP_ALG_ALGSEL_AES) &&\r\n((ctx->class1_alg_type & OP_ALG_AAI_MASK) == OP_ALG_AAI_GCM))\r\nis_gcm = true;\r\nif (is_gcm) {\r\nif (assoc_nents || iv_dma + ivsize !=\r\nsg_dma_address(req->assoc) || src_nents ||\r\nsg_dma_address(req->assoc) + req->assoclen !=\r\nsg_dma_address(req->src))\r\ncontig &= ~GIV_SRC_CONTIG;\r\n} else {\r\nif (assoc_nents ||\r\nsg_dma_address(req->assoc) + req->assoclen != iv_dma ||\r\nsrc_nents || iv_dma + ivsize != sg_dma_address(req->src))\r\ncontig &= ~GIV_SRC_CONTIG;\r\n}\r\nif (dst_nents || iv_dma + ivsize != sg_dma_address(req->dst))\r\ncontig &= ~GIV_DST_CONTIG;\r\nif (!(contig & GIV_SRC_CONTIG)) {\r\nassoc_nents = assoc_nents ? : 1;\r\nsrc_nents = src_nents ? : 1;\r\nsec4_sg_len += assoc_nents + 1 + src_nents;\r\nif (req->src == req->dst &&\r\n(src_nents || iv_dma + ivsize != sg_dma_address(req->src)))\r\ncontig &= ~GIV_DST_CONTIG;\r\n}\r\nif (is_gcm && req->src == req->dst && !(contig & GIV_DST_CONTIG))\r\nsec4_sg_len += 1 + src_nents;\r\nif (unlikely(req->src != req->dst)) {\r\ndst_nents = dst_nents ? : 1;\r\nsec4_sg_len += 1 + dst_nents;\r\n}\r\nsec4_sg_bytes = sec4_sg_len * sizeof(struct sec4_sg_entry);\r\nedesc = kmalloc(sizeof(struct aead_edesc) + desc_bytes +\r\nsec4_sg_bytes, GFP_DMA | flags);\r\nif (!edesc) {\r\ndev_err(jrdev, "could not allocate extended descriptor\n");\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nedesc->assoc_nents = assoc_nents;\r\nedesc->assoc_chained = assoc_chained;\r\nedesc->src_nents = src_nents;\r\nedesc->src_chained = src_chained;\r\nedesc->dst_nents = dst_nents;\r\nedesc->dst_chained = dst_chained;\r\nedesc->iv_dma = iv_dma;\r\nedesc->sec4_sg_bytes = sec4_sg_bytes;\r\nedesc->sec4_sg = (void *)edesc + sizeof(struct aead_edesc) +\r\ndesc_bytes;\r\n*contig_ptr = contig;\r\nsec4_sg_index = 0;\r\nif (!(contig & GIV_SRC_CONTIG)) {\r\nif (!is_gcm) {\r\nsg_to_sec4_sg(req->assoc, assoc_nents,\r\nedesc->sec4_sg + sec4_sg_index, 0);\r\nsec4_sg_index += assoc_nents;\r\n}\r\ndma_to_sec4_sg_one(edesc->sec4_sg + sec4_sg_index,\r\niv_dma, ivsize, 0);\r\nsec4_sg_index += 1;\r\nif (is_gcm) {\r\nsg_to_sec4_sg(req->assoc, assoc_nents,\r\nedesc->sec4_sg + sec4_sg_index, 0);\r\nsec4_sg_index += assoc_nents;\r\n}\r\nsg_to_sec4_sg_last(req->src, src_nents,\r\nedesc->sec4_sg +\r\nsec4_sg_index, 0);\r\nsec4_sg_index += src_nents;\r\n}\r\nif (is_gcm && req->src == req->dst && !(contig & GIV_DST_CONTIG)) {\r\ndma_to_sec4_sg_one(edesc->sec4_sg + sec4_sg_index,\r\niv_dma, ivsize, 0);\r\nsec4_sg_index += 1;\r\nsg_to_sec4_sg_last(req->src, src_nents,\r\nedesc->sec4_sg + sec4_sg_index, 0);\r\n}\r\nif (unlikely(req->src != req->dst && !(contig & GIV_DST_CONTIG))) {\r\ndma_to_sec4_sg_one(edesc->sec4_sg + sec4_sg_index,\r\niv_dma, ivsize, 0);\r\nsec4_sg_index += 1;\r\nsg_to_sec4_sg_last(req->dst, dst_nents,\r\nedesc->sec4_sg + sec4_sg_index, 0);\r\n}\r\nedesc->sec4_sg_dma = dma_map_single(jrdev, edesc->sec4_sg,\r\nsec4_sg_bytes, DMA_TO_DEVICE);\r\nif (dma_mapping_error(jrdev, edesc->sec4_sg_dma)) {\r\ndev_err(jrdev, "unable to map S/G table\n");\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nreturn edesc;\r\n}\r\nstatic int aead_givencrypt(struct aead_givcrypt_request *areq)\r\n{\r\nstruct aead_request *req = &areq->areq;\r\nstruct aead_edesc *edesc;\r\nstruct crypto_aead *aead = crypto_aead_reqtfm(req);\r\nstruct caam_ctx *ctx = crypto_aead_ctx(aead);\r\nstruct device *jrdev = ctx->jrdev;\r\nu32 contig;\r\nu32 *desc;\r\nint ret = 0;\r\nedesc = aead_giv_edesc_alloc(areq, DESC_JOB_IO_LEN *\r\nCAAM_CMD_SZ, &contig);\r\nif (IS_ERR(edesc))\r\nreturn PTR_ERR(edesc);\r\n#ifdef DEBUG\r\nprint_hex_dump(KERN_ERR, "giv src@"__stringify(__LINE__)": ",\r\nDUMP_PREFIX_ADDRESS, 16, 4, sg_virt(req->src),\r\nreq->cryptlen, 1);\r\n#endif\r\ninit_aead_giv_job(ctx->sh_desc_givenc,\r\nctx->sh_desc_givenc_dma, edesc, req, contig);\r\n#ifdef DEBUG\r\nprint_hex_dump(KERN_ERR, "aead jobdesc@"__stringify(__LINE__)": ",\r\nDUMP_PREFIX_ADDRESS, 16, 4, edesc->hw_desc,\r\ndesc_bytes(edesc->hw_desc), 1);\r\n#endif\r\ndesc = edesc->hw_desc;\r\nret = caam_jr_enqueue(jrdev, desc, aead_encrypt_done, req);\r\nif (!ret) {\r\nret = -EINPROGRESS;\r\n} else {\r\naead_unmap(jrdev, edesc, req);\r\nkfree(edesc);\r\n}\r\nreturn ret;\r\n}\r\nstatic int aead_null_givencrypt(struct aead_givcrypt_request *areq)\r\n{\r\nreturn aead_encrypt(&areq->areq);\r\n}\r\nstatic struct ablkcipher_edesc *ablkcipher_edesc_alloc(struct ablkcipher_request\r\n*req, int desc_bytes,\r\nbool *iv_contig_out)\r\n{\r\nstruct crypto_ablkcipher *ablkcipher = crypto_ablkcipher_reqtfm(req);\r\nstruct caam_ctx *ctx = crypto_ablkcipher_ctx(ablkcipher);\r\nstruct device *jrdev = ctx->jrdev;\r\ngfp_t flags = (req->base.flags & (CRYPTO_TFM_REQ_MAY_BACKLOG |\r\nCRYPTO_TFM_REQ_MAY_SLEEP)) ?\r\nGFP_KERNEL : GFP_ATOMIC;\r\nint src_nents, dst_nents = 0, sec4_sg_bytes;\r\nstruct ablkcipher_edesc *edesc;\r\ndma_addr_t iv_dma = 0;\r\nbool iv_contig = false;\r\nint sgc;\r\nint ivsize = crypto_ablkcipher_ivsize(ablkcipher);\r\nbool src_chained = false, dst_chained = false;\r\nint sec4_sg_index;\r\nsrc_nents = sg_count(req->src, req->nbytes, &src_chained);\r\nif (req->dst != req->src)\r\ndst_nents = sg_count(req->dst, req->nbytes, &dst_chained);\r\nif (likely(req->src == req->dst)) {\r\nsgc = dma_map_sg_chained(jrdev, req->src, src_nents ? : 1,\r\nDMA_BIDIRECTIONAL, src_chained);\r\n} else {\r\nsgc = dma_map_sg_chained(jrdev, req->src, src_nents ? : 1,\r\nDMA_TO_DEVICE, src_chained);\r\nsgc = dma_map_sg_chained(jrdev, req->dst, dst_nents ? : 1,\r\nDMA_FROM_DEVICE, dst_chained);\r\n}\r\niv_dma = dma_map_single(jrdev, req->info, ivsize, DMA_TO_DEVICE);\r\nif (dma_mapping_error(jrdev, iv_dma)) {\r\ndev_err(jrdev, "unable to map IV\n");\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nif (!src_nents && iv_dma + ivsize == sg_dma_address(req->src))\r\niv_contig = true;\r\nelse\r\nsrc_nents = src_nents ? : 1;\r\nsec4_sg_bytes = ((iv_contig ? 0 : 1) + src_nents + dst_nents) *\r\nsizeof(struct sec4_sg_entry);\r\nedesc = kmalloc(sizeof(struct ablkcipher_edesc) + desc_bytes +\r\nsec4_sg_bytes, GFP_DMA | flags);\r\nif (!edesc) {\r\ndev_err(jrdev, "could not allocate extended descriptor\n");\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nedesc->src_nents = src_nents;\r\nedesc->src_chained = src_chained;\r\nedesc->dst_nents = dst_nents;\r\nedesc->dst_chained = dst_chained;\r\nedesc->sec4_sg_bytes = sec4_sg_bytes;\r\nedesc->sec4_sg = (void *)edesc + sizeof(struct ablkcipher_edesc) +\r\ndesc_bytes;\r\nsec4_sg_index = 0;\r\nif (!iv_contig) {\r\ndma_to_sec4_sg_one(edesc->sec4_sg, iv_dma, ivsize, 0);\r\nsg_to_sec4_sg_last(req->src, src_nents,\r\nedesc->sec4_sg + 1, 0);\r\nsec4_sg_index += 1 + src_nents;\r\n}\r\nif (dst_nents) {\r\nsg_to_sec4_sg_last(req->dst, dst_nents,\r\nedesc->sec4_sg + sec4_sg_index, 0);\r\n}\r\nedesc->sec4_sg_dma = dma_map_single(jrdev, edesc->sec4_sg,\r\nsec4_sg_bytes, DMA_TO_DEVICE);\r\nif (dma_mapping_error(jrdev, edesc->sec4_sg_dma)) {\r\ndev_err(jrdev, "unable to map S/G table\n");\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nedesc->iv_dma = iv_dma;\r\n#ifdef DEBUG\r\nprint_hex_dump(KERN_ERR, "ablkcipher sec4_sg@"__stringify(__LINE__)": ",\r\nDUMP_PREFIX_ADDRESS, 16, 4, edesc->sec4_sg,\r\nsec4_sg_bytes, 1);\r\n#endif\r\n*iv_contig_out = iv_contig;\r\nreturn edesc;\r\n}\r\nstatic int ablkcipher_encrypt(struct ablkcipher_request *req)\r\n{\r\nstruct ablkcipher_edesc *edesc;\r\nstruct crypto_ablkcipher *ablkcipher = crypto_ablkcipher_reqtfm(req);\r\nstruct caam_ctx *ctx = crypto_ablkcipher_ctx(ablkcipher);\r\nstruct device *jrdev = ctx->jrdev;\r\nbool iv_contig;\r\nu32 *desc;\r\nint ret = 0;\r\nedesc = ablkcipher_edesc_alloc(req, DESC_JOB_IO_LEN *\r\nCAAM_CMD_SZ, &iv_contig);\r\nif (IS_ERR(edesc))\r\nreturn PTR_ERR(edesc);\r\ninit_ablkcipher_job(ctx->sh_desc_enc,\r\nctx->sh_desc_enc_dma, edesc, req, iv_contig);\r\n#ifdef DEBUG\r\nprint_hex_dump(KERN_ERR, "ablkcipher jobdesc@"__stringify(__LINE__)": ",\r\nDUMP_PREFIX_ADDRESS, 16, 4, edesc->hw_desc,\r\ndesc_bytes(edesc->hw_desc), 1);\r\n#endif\r\ndesc = edesc->hw_desc;\r\nret = caam_jr_enqueue(jrdev, desc, ablkcipher_encrypt_done, req);\r\nif (!ret) {\r\nret = -EINPROGRESS;\r\n} else {\r\nablkcipher_unmap(jrdev, edesc, req);\r\nkfree(edesc);\r\n}\r\nreturn ret;\r\n}\r\nstatic int ablkcipher_decrypt(struct ablkcipher_request *req)\r\n{\r\nstruct ablkcipher_edesc *edesc;\r\nstruct crypto_ablkcipher *ablkcipher = crypto_ablkcipher_reqtfm(req);\r\nstruct caam_ctx *ctx = crypto_ablkcipher_ctx(ablkcipher);\r\nstruct device *jrdev = ctx->jrdev;\r\nbool iv_contig;\r\nu32 *desc;\r\nint ret = 0;\r\nedesc = ablkcipher_edesc_alloc(req, DESC_JOB_IO_LEN *\r\nCAAM_CMD_SZ, &iv_contig);\r\nif (IS_ERR(edesc))\r\nreturn PTR_ERR(edesc);\r\ninit_ablkcipher_job(ctx->sh_desc_dec,\r\nctx->sh_desc_dec_dma, edesc, req, iv_contig);\r\ndesc = edesc->hw_desc;\r\n#ifdef DEBUG\r\nprint_hex_dump(KERN_ERR, "ablkcipher jobdesc@"__stringify(__LINE__)": ",\r\nDUMP_PREFIX_ADDRESS, 16, 4, edesc->hw_desc,\r\ndesc_bytes(edesc->hw_desc), 1);\r\n#endif\r\nret = caam_jr_enqueue(jrdev, desc, ablkcipher_decrypt_done, req);\r\nif (!ret) {\r\nret = -EINPROGRESS;\r\n} else {\r\nablkcipher_unmap(jrdev, edesc, req);\r\nkfree(edesc);\r\n}\r\nreturn ret;\r\n}\r\nstatic struct ablkcipher_edesc *ablkcipher_giv_edesc_alloc(\r\nstruct skcipher_givcrypt_request *greq,\r\nint desc_bytes,\r\nbool *iv_contig_out)\r\n{\r\nstruct ablkcipher_request *req = &greq->creq;\r\nstruct crypto_ablkcipher *ablkcipher = crypto_ablkcipher_reqtfm(req);\r\nstruct caam_ctx *ctx = crypto_ablkcipher_ctx(ablkcipher);\r\nstruct device *jrdev = ctx->jrdev;\r\ngfp_t flags = (req->base.flags & (CRYPTO_TFM_REQ_MAY_BACKLOG |\r\nCRYPTO_TFM_REQ_MAY_SLEEP)) ?\r\nGFP_KERNEL : GFP_ATOMIC;\r\nint src_nents, dst_nents = 0, sec4_sg_bytes;\r\nstruct ablkcipher_edesc *edesc;\r\ndma_addr_t iv_dma = 0;\r\nbool iv_contig = false;\r\nint sgc;\r\nint ivsize = crypto_ablkcipher_ivsize(ablkcipher);\r\nbool src_chained = false, dst_chained = false;\r\nint sec4_sg_index;\r\nsrc_nents = sg_count(req->src, req->nbytes, &src_chained);\r\nif (unlikely(req->dst != req->src))\r\ndst_nents = sg_count(req->dst, req->nbytes, &dst_chained);\r\nif (likely(req->src == req->dst)) {\r\nsgc = dma_map_sg_chained(jrdev, req->src, src_nents ? : 1,\r\nDMA_BIDIRECTIONAL, src_chained);\r\n} else {\r\nsgc = dma_map_sg_chained(jrdev, req->src, src_nents ? : 1,\r\nDMA_TO_DEVICE, src_chained);\r\nsgc = dma_map_sg_chained(jrdev, req->dst, dst_nents ? : 1,\r\nDMA_FROM_DEVICE, dst_chained);\r\n}\r\niv_dma = dma_map_single(jrdev, greq->giv, ivsize, DMA_TO_DEVICE);\r\nif (dma_mapping_error(jrdev, iv_dma)) {\r\ndev_err(jrdev, "unable to map IV\n");\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nif (!dst_nents && iv_dma + ivsize == sg_dma_address(req->dst))\r\niv_contig = true;\r\nelse\r\ndst_nents = dst_nents ? : 1;\r\nsec4_sg_bytes = ((iv_contig ? 0 : 1) + src_nents + dst_nents) *\r\nsizeof(struct sec4_sg_entry);\r\nedesc = kmalloc(sizeof(*edesc) + desc_bytes +\r\nsec4_sg_bytes, GFP_DMA | flags);\r\nif (!edesc) {\r\ndev_err(jrdev, "could not allocate extended descriptor\n");\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nedesc->src_nents = src_nents;\r\nedesc->src_chained = src_chained;\r\nedesc->dst_nents = dst_nents;\r\nedesc->dst_chained = dst_chained;\r\nedesc->sec4_sg_bytes = sec4_sg_bytes;\r\nedesc->sec4_sg = (void *)edesc + sizeof(struct ablkcipher_edesc) +\r\ndesc_bytes;\r\nsec4_sg_index = 0;\r\nif (src_nents) {\r\nsg_to_sec4_sg_last(req->src, src_nents, edesc->sec4_sg, 0);\r\nsec4_sg_index += src_nents;\r\n}\r\nif (!iv_contig) {\r\ndma_to_sec4_sg_one(edesc->sec4_sg + sec4_sg_index,\r\niv_dma, ivsize, 0);\r\nsec4_sg_index += 1;\r\nsg_to_sec4_sg_last(req->dst, dst_nents,\r\nedesc->sec4_sg + sec4_sg_index, 0);\r\n}\r\nedesc->sec4_sg_dma = dma_map_single(jrdev, edesc->sec4_sg,\r\nsec4_sg_bytes, DMA_TO_DEVICE);\r\nif (dma_mapping_error(jrdev, edesc->sec4_sg_dma)) {\r\ndev_err(jrdev, "unable to map S/G table\n");\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nedesc->iv_dma = iv_dma;\r\n#ifdef DEBUG\r\nprint_hex_dump(KERN_ERR,\r\n"ablkcipher sec4_sg@" __stringify(__LINE__) ": ",\r\nDUMP_PREFIX_ADDRESS, 16, 4, edesc->sec4_sg,\r\nsec4_sg_bytes, 1);\r\n#endif\r\n*iv_contig_out = iv_contig;\r\nreturn edesc;\r\n}\r\nstatic int ablkcipher_givencrypt(struct skcipher_givcrypt_request *creq)\r\n{\r\nstruct ablkcipher_request *req = &creq->creq;\r\nstruct ablkcipher_edesc *edesc;\r\nstruct crypto_ablkcipher *ablkcipher = crypto_ablkcipher_reqtfm(req);\r\nstruct caam_ctx *ctx = crypto_ablkcipher_ctx(ablkcipher);\r\nstruct device *jrdev = ctx->jrdev;\r\nbool iv_contig;\r\nu32 *desc;\r\nint ret = 0;\r\nedesc = ablkcipher_giv_edesc_alloc(creq, DESC_JOB_IO_LEN *\r\nCAAM_CMD_SZ, &iv_contig);\r\nif (IS_ERR(edesc))\r\nreturn PTR_ERR(edesc);\r\ninit_ablkcipher_giv_job(ctx->sh_desc_givenc, ctx->sh_desc_givenc_dma,\r\nedesc, req, iv_contig);\r\n#ifdef DEBUG\r\nprint_hex_dump(KERN_ERR,\r\n"ablkcipher jobdesc@" __stringify(__LINE__) ": ",\r\nDUMP_PREFIX_ADDRESS, 16, 4, edesc->hw_desc,\r\ndesc_bytes(edesc->hw_desc), 1);\r\n#endif\r\ndesc = edesc->hw_desc;\r\nret = caam_jr_enqueue(jrdev, desc, ablkcipher_encrypt_done, req);\r\nif (!ret) {\r\nret = -EINPROGRESS;\r\n} else {\r\nablkcipher_unmap(jrdev, edesc, req);\r\nkfree(edesc);\r\n}\r\nreturn ret;\r\n}\r\nstatic int caam_cra_init(struct crypto_tfm *tfm)\r\n{\r\nstruct crypto_alg *alg = tfm->__crt_alg;\r\nstruct caam_crypto_alg *caam_alg =\r\ncontainer_of(alg, struct caam_crypto_alg, crypto_alg);\r\nstruct caam_ctx *ctx = crypto_tfm_ctx(tfm);\r\nctx->jrdev = caam_jr_alloc();\r\nif (IS_ERR(ctx->jrdev)) {\r\npr_err("Job Ring Device allocation for transform failed\n");\r\nreturn PTR_ERR(ctx->jrdev);\r\n}\r\nctx->class1_alg_type = OP_TYPE_CLASS1_ALG | caam_alg->class1_alg_type;\r\nctx->class2_alg_type = OP_TYPE_CLASS2_ALG | caam_alg->class2_alg_type;\r\nctx->alg_op = OP_TYPE_CLASS2_ALG | caam_alg->alg_op;\r\nreturn 0;\r\n}\r\nstatic void caam_cra_exit(struct crypto_tfm *tfm)\r\n{\r\nstruct caam_ctx *ctx = crypto_tfm_ctx(tfm);\r\nif (ctx->sh_desc_enc_dma &&\r\n!dma_mapping_error(ctx->jrdev, ctx->sh_desc_enc_dma))\r\ndma_unmap_single(ctx->jrdev, ctx->sh_desc_enc_dma,\r\ndesc_bytes(ctx->sh_desc_enc), DMA_TO_DEVICE);\r\nif (ctx->sh_desc_dec_dma &&\r\n!dma_mapping_error(ctx->jrdev, ctx->sh_desc_dec_dma))\r\ndma_unmap_single(ctx->jrdev, ctx->sh_desc_dec_dma,\r\ndesc_bytes(ctx->sh_desc_dec), DMA_TO_DEVICE);\r\nif (ctx->sh_desc_givenc_dma &&\r\n!dma_mapping_error(ctx->jrdev, ctx->sh_desc_givenc_dma))\r\ndma_unmap_single(ctx->jrdev, ctx->sh_desc_givenc_dma,\r\ndesc_bytes(ctx->sh_desc_givenc),\r\nDMA_TO_DEVICE);\r\nif (ctx->key_dma &&\r\n!dma_mapping_error(ctx->jrdev, ctx->key_dma))\r\ndma_unmap_single(ctx->jrdev, ctx->key_dma,\r\nctx->enckeylen + ctx->split_key_pad_len,\r\nDMA_TO_DEVICE);\r\ncaam_jr_free(ctx->jrdev);\r\n}\r\nstatic void __exit caam_algapi_exit(void)\r\n{\r\nstruct caam_crypto_alg *t_alg, *n;\r\nif (!alg_list.next)\r\nreturn;\r\nlist_for_each_entry_safe(t_alg, n, &alg_list, entry) {\r\ncrypto_unregister_alg(&t_alg->crypto_alg);\r\nlist_del(&t_alg->entry);\r\nkfree(t_alg);\r\n}\r\n}\r\nstatic struct caam_crypto_alg *caam_alg_alloc(struct caam_alg_template\r\n*template)\r\n{\r\nstruct caam_crypto_alg *t_alg;\r\nstruct crypto_alg *alg;\r\nt_alg = kzalloc(sizeof(struct caam_crypto_alg), GFP_KERNEL);\r\nif (!t_alg) {\r\npr_err("failed to allocate t_alg\n");\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nalg = &t_alg->crypto_alg;\r\nsnprintf(alg->cra_name, CRYPTO_MAX_ALG_NAME, "%s", template->name);\r\nsnprintf(alg->cra_driver_name, CRYPTO_MAX_ALG_NAME, "%s",\r\ntemplate->driver_name);\r\nalg->cra_module = THIS_MODULE;\r\nalg->cra_init = caam_cra_init;\r\nalg->cra_exit = caam_cra_exit;\r\nalg->cra_priority = CAAM_CRA_PRIORITY;\r\nalg->cra_blocksize = template->blocksize;\r\nalg->cra_alignmask = 0;\r\nalg->cra_ctxsize = sizeof(struct caam_ctx);\r\nalg->cra_flags = CRYPTO_ALG_ASYNC | CRYPTO_ALG_KERN_DRIVER_ONLY |\r\ntemplate->type;\r\nswitch (template->type) {\r\ncase CRYPTO_ALG_TYPE_GIVCIPHER:\r\nalg->cra_type = &crypto_givcipher_type;\r\nalg->cra_ablkcipher = template->template_ablkcipher;\r\nbreak;\r\ncase CRYPTO_ALG_TYPE_ABLKCIPHER:\r\nalg->cra_type = &crypto_ablkcipher_type;\r\nalg->cra_ablkcipher = template->template_ablkcipher;\r\nbreak;\r\ncase CRYPTO_ALG_TYPE_AEAD:\r\nalg->cra_type = &crypto_aead_type;\r\nalg->cra_aead = template->template_aead;\r\nbreak;\r\n}\r\nt_alg->class1_alg_type = template->class1_alg_type;\r\nt_alg->class2_alg_type = template->class2_alg_type;\r\nt_alg->alg_op = template->alg_op;\r\nreturn t_alg;\r\n}\r\nstatic int __init caam_algapi_init(void)\r\n{\r\nstruct device_node *dev_node;\r\nstruct platform_device *pdev;\r\nstruct device *ctrldev;\r\nvoid *priv;\r\nint i = 0, err = 0;\r\ndev_node = of_find_compatible_node(NULL, NULL, "fsl,sec-v4.0");\r\nif (!dev_node) {\r\ndev_node = of_find_compatible_node(NULL, NULL, "fsl,sec4.0");\r\nif (!dev_node)\r\nreturn -ENODEV;\r\n}\r\npdev = of_find_device_by_node(dev_node);\r\nif (!pdev) {\r\nof_node_put(dev_node);\r\nreturn -ENODEV;\r\n}\r\nctrldev = &pdev->dev;\r\npriv = dev_get_drvdata(ctrldev);\r\nof_node_put(dev_node);\r\nif (!priv)\r\nreturn -ENODEV;\r\nINIT_LIST_HEAD(&alg_list);\r\nfor (i = 0; i < ARRAY_SIZE(driver_algs); i++) {\r\nstruct caam_crypto_alg *t_alg;\r\nt_alg = caam_alg_alloc(&driver_algs[i]);\r\nif (IS_ERR(t_alg)) {\r\nerr = PTR_ERR(t_alg);\r\npr_warn("%s alg allocation failed\n",\r\ndriver_algs[i].driver_name);\r\ncontinue;\r\n}\r\nerr = crypto_register_alg(&t_alg->crypto_alg);\r\nif (err) {\r\npr_warn("%s alg registration failed\n",\r\nt_alg->crypto_alg.cra_driver_name);\r\nkfree(t_alg);\r\n} else\r\nlist_add_tail(&t_alg->entry, &alg_list);\r\n}\r\nif (!list_empty(&alg_list))\r\npr_info("caam algorithms registered in /proc/crypto\n");\r\nreturn err;\r\n}
