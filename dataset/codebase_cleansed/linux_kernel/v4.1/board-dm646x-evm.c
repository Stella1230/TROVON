static int cpld_reg0_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nif (HAS_ATA) {\r\nu8 data;\r\nstruct i2c_msg msg[2] = {\r\n{\r\n.addr = client->addr,\r\n.flags = I2C_M_RD,\r\n.len = 1,\r\n.buf = &data,\r\n},\r\n{\r\n.addr = client->addr,\r\n.flags = 0,\r\n.len = 1,\r\n.buf = &data,\r\n},\r\n};\r\ni2c_transfer(client->adapter, msg, 1);\r\ndata &= ~(DM646X_EVM_ATA_RST | DM646X_EVM_ATA_PWD);\r\ni2c_transfer(client->adapter, msg + 1, 1);\r\n}\r\nreturn 0;\r\n}\r\nstatic int evm_led_setup(struct i2c_client *client, int gpio,\r\nunsigned int ngpio, void *c)\r\n{\r\nstruct gpio_led *leds = evm_leds;\r\nint status;\r\nwhile (ngpio--) {\r\nleds->gpio = gpio++;\r\nleds++;\r\n}\r\nevm_led_dev = platform_device_alloc("leds-gpio", 0);\r\nplatform_device_add_data(evm_led_dev, &evm_led_data,\r\nsizeof(evm_led_data));\r\nevm_led_dev->dev.parent = &client->dev;\r\nstatus = platform_device_add(evm_led_dev);\r\nif (status < 0) {\r\nplatform_device_put(evm_led_dev);\r\nevm_led_dev = NULL;\r\n}\r\nreturn status;\r\n}\r\nstatic int evm_led_teardown(struct i2c_client *client, int gpio,\r\nunsigned ngpio, void *c)\r\n{\r\nif (evm_led_dev) {\r\nplatform_device_unregister(evm_led_dev);\r\nevm_led_dev = NULL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int evm_sw_setup(struct i2c_client *client, int gpio,\r\nunsigned ngpio, void *c)\r\n{\r\nint status;\r\nint i;\r\nchar label[10];\r\nfor (i = 0; i < 4; ++i) {\r\nsnprintf(label, 10, "user_sw%d", i);\r\nstatus = gpio_request(gpio, label);\r\nif (status)\r\ngoto out_free;\r\nevm_sw_gpio[i] = gpio++;\r\nstatus = gpio_direction_input(evm_sw_gpio[i]);\r\nif (status) {\r\ngpio_free(evm_sw_gpio[i]);\r\nevm_sw_gpio[i] = -EINVAL;\r\ngoto out_free;\r\n}\r\nstatus = gpio_export(evm_sw_gpio[i], 0);\r\nif (status) {\r\ngpio_free(evm_sw_gpio[i]);\r\nevm_sw_gpio[i] = -EINVAL;\r\ngoto out_free;\r\n}\r\n}\r\nreturn status;\r\nout_free:\r\nfor (i = 0; i < 4; ++i) {\r\nif (evm_sw_gpio[i] != -EINVAL) {\r\ngpio_free(evm_sw_gpio[i]);\r\nevm_sw_gpio[i] = -EINVAL;\r\n}\r\n}\r\nreturn status;\r\n}\r\nstatic int evm_sw_teardown(struct i2c_client *client, int gpio,\r\nunsigned ngpio, void *c)\r\n{\r\nint i;\r\nfor (i = 0; i < 4; ++i) {\r\nif (evm_sw_gpio[i] != -EINVAL) {\r\ngpio_unexport(evm_sw_gpio[i]);\r\ngpio_free(evm_sw_gpio[i]);\r\nevm_sw_gpio[i] = -EINVAL;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int evm_pcf_setup(struct i2c_client *client, int gpio,\r\nunsigned int ngpio, void *c)\r\n{\r\nint status;\r\nif (ngpio < 8)\r\nreturn -EINVAL;\r\nstatus = evm_sw_setup(client, gpio, 4, c);\r\nif (status)\r\nreturn status;\r\nreturn evm_led_setup(client, gpio+4, 4, c);\r\n}\r\nstatic int evm_pcf_teardown(struct i2c_client *client, int gpio,\r\nunsigned int ngpio, void *c)\r\n{\r\nBUG_ON(ngpio < 8);\r\nevm_sw_teardown(client, gpio, 4, c);\r\nevm_led_teardown(client, gpio+4, 4, c);\r\nreturn 0;\r\n}\r\nstatic int cpld_video_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\ncpld_client = client;\r\nreturn 0;\r\n}\r\nstatic int cpld_video_remove(struct i2c_client *client)\r\n{\r\ncpld_client = NULL;\r\nreturn 0;\r\n}\r\nstatic void evm_init_cpld(void)\r\n{\r\ni2c_add_driver(&cpld_video_driver);\r\n}\r\nstatic int set_vpif_clock(int mux_mode, int hd)\r\n{\r\nunsigned long flags;\r\nunsigned int value;\r\nint val = 0;\r\nint err = 0;\r\nif (!cpld_client)\r\nreturn -ENXIO;\r\nspin_lock_irqsave(&vpif_reg_lock, flags);\r\nvalue = __raw_readl(DAVINCI_SYSMOD_VIRT(SYSMOD_VSCLKDIS));\r\nvalue |= (VIDCH3CLK | VIDCH2CLK);\r\n__raw_writel(value, DAVINCI_SYSMOD_VIRT(SYSMOD_VSCLKDIS));\r\nspin_unlock_irqrestore(&vpif_reg_lock, flags);\r\nval = i2c_smbus_read_byte(cpld_client);\r\nif (val < 0)\r\nreturn val;\r\nif (mux_mode == 1)\r\nval &= ~0x40;\r\nelse\r\nval |= 0x40;\r\nerr = i2c_smbus_write_byte(cpld_client, val);\r\nif (err)\r\nreturn err;\r\nvalue = __raw_readl(DAVINCI_SYSMOD_VIRT(SYSMOD_VIDCLKCTL));\r\nvalue &= ~(VCH2CLK_MASK);\r\nvalue &= ~(VCH3CLK_MASK);\r\nif (hd >= 1)\r\nvalue |= (VCH2CLK_SYSCLK8 | VCH3CLK_SYSCLK8);\r\nelse\r\nvalue |= (VCH2CLK_AUXCLK | VCH3CLK_AUXCLK);\r\n__raw_writel(value, DAVINCI_SYSMOD_VIRT(SYSMOD_VIDCLKCTL));\r\nspin_lock_irqsave(&vpif_reg_lock, flags);\r\nvalue = __raw_readl(DAVINCI_SYSMOD_VIRT(SYSMOD_VSCLKDIS));\r\nvalue &= ~(VIDCH3CLK | VIDCH2CLK);\r\n__raw_writel(value, DAVINCI_SYSMOD_VIRT(SYSMOD_VSCLKDIS));\r\nspin_unlock_irqrestore(&vpif_reg_lock, flags);\r\nreturn 0;\r\n}\r\nstatic int setup_vpif_input_path(int channel, const char *sub_dev_name)\r\n{\r\nint err = 0;\r\nint val;\r\nif (channel != 0)\r\nreturn 0;\r\nif (!cpld_client)\r\nreturn -ENXIO;\r\nval = i2c_smbus_read_byte(cpld_client);\r\nif (val < 0)\r\nreturn val;\r\nif (!strcmp(sub_dev_name, TVP5147_CH0) ||\r\n!strcmp(sub_dev_name, TVP5147_CH1))\r\nval &= TVP5147_INPUT;\r\nelse\r\nval |= TVP7002_INPUT;\r\nerr = i2c_smbus_write_byte(cpld_client, val);\r\nif (err)\r\nreturn err;\r\nreturn 0;\r\n}\r\nstatic int setup_vpif_input_channel_mode(int mux_mode)\r\n{\r\nunsigned long flags;\r\nint err = 0;\r\nint val;\r\nu32 value;\r\nif (!cpld_client)\r\nreturn -ENXIO;\r\nval = i2c_smbus_read_byte(cpld_client);\r\nif (val < 0)\r\nreturn val;\r\nspin_lock_irqsave(&vpif_reg_lock, flags);\r\nvalue = __raw_readl(DAVINCI_SYSMOD_VIRT(SYSMOD_VIDCLKCTL));\r\nif (mux_mode) {\r\nval &= VPIF_INPUT_TWO_CHANNEL;\r\nvalue |= VIDCH1CLK;\r\n} else {\r\nval |= VPIF_INPUT_ONE_CHANNEL;\r\nvalue &= ~VIDCH1CLK;\r\n}\r\n__raw_writel(value, DAVINCI_SYSMOD_VIRT(SYSMOD_VIDCLKCTL));\r\nspin_unlock_irqrestore(&vpif_reg_lock, flags);\r\nerr = i2c_smbus_write_byte(cpld_client, val);\r\nif (err)\r\nreturn err;\r\nreturn 0;\r\n}\r\nstatic void __init evm_init_video(void)\r\n{\r\nspin_lock_init(&vpif_reg_lock);\r\ndm646x_setup_vpif(&dm646x_vpif_display_config,\r\n&dm646x_vpif_capture_cfg);\r\n}\r\nstatic void __init evm_init_i2c(void)\r\n{\r\ndavinci_init_i2c(&i2c_pdata);\r\ni2c_add_driver(&dm6467evm_cpld_driver);\r\ni2c_register_board_info(1, i2c_info, ARRAY_SIZE(i2c_info));\r\nevm_init_cpld();\r\nevm_init_video();\r\n}\r\nstatic void __init davinci_map_io(void)\r\n{\r\ndm646x_init();\r\nif (machine_is_davinci_dm6467tevm())\r\ndavinci_set_refclk_rate(DM6467T_EVM_REF_FREQ);\r\n}\r\nstatic __init void evm_init(void)\r\n{\r\nint ret;\r\nstruct davinci_soc_info *soc_info = &davinci_soc_info;\r\nret = dm646x_gpio_register();\r\nif (ret)\r\npr_warn("%s: GPIO init failed: %d\n", __func__, ret);\r\nevm_init_i2c();\r\ndavinci_serial_init(dm646x_serial_device);\r\ndm646x_init_mcasp0(&dm646x_evm_snd_data[0]);\r\ndm646x_init_mcasp1(&dm646x_evm_snd_data[1]);\r\nif (machine_is_davinci_dm6467tevm())\r\ndavinci_nand_data.timing = &dm6467tevm_nandflash_timing;\r\nplatform_device_register(&davinci_nand_device);\r\nif (davinci_aemif_setup(&davinci_nand_device))\r\npr_warn("%s: Cannot configure AEMIF.\n", __func__);\r\ndm646x_init_edma(dm646x_edma_rsv);\r\nif (HAS_ATA)\r\ndavinci_init_ide();\r\nsoc_info->emac_pdata->phy_id = DM646X_EVM_PHY_ID;\r\n}
