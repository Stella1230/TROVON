static int __mfp_config_gpio(unsigned gpio, unsigned long c)\r\n{\r\nunsigned long gafr, mask = GPIO_bit(gpio);\r\nint bank = gpio_to_bank(gpio);\r\nint uorl = !!(gpio & 0x10);\r\nint shft = (gpio & 0xf) << 1;\r\nint fn = MFP_AF(c);\r\nint is_out = (c & MFP_DIR_OUT) ? 1 : 0;\r\nif (fn > 3)\r\nreturn -EINVAL;\r\ngafr = (uorl == 0) ? GAFR_L(bank) : GAFR_U(bank);\r\ngafr = (gafr & ~(0x3 << shft)) | (fn << shft);\r\nif (uorl == 0)\r\nGAFR_L(bank) = gafr;\r\nelse\r\nGAFR_U(bank) = gafr;\r\nif (is_out ^ gpio_desc[gpio].dir_inverted)\r\nGPDR(gpio) |= mask;\r\nelse\r\nGPDR(gpio) &= ~mask;\r\nswitch (c & MFP_LPM_STATE_MASK) {\r\ncase MFP_LPM_DRIVE_HIGH:\r\nPGSR(bank) |= mask;\r\nis_out = 1;\r\nbreak;\r\ncase MFP_LPM_DRIVE_LOW:\r\nPGSR(bank) &= ~mask;\r\nis_out = 1;\r\nbreak;\r\ncase MFP_LPM_INPUT:\r\ncase MFP_LPM_DEFAULT:\r\nbreak;\r\ndefault:\r\npr_warn("%s: GPIO%d: unsupported low power mode\n",\r\n__func__, gpio);\r\nbreak;\r\n}\r\nif (is_out ^ gpio_desc[gpio].dir_inverted)\r\ngpdr_lpm[bank] |= mask;\r\nelse\r\ngpdr_lpm[bank] &= ~mask;\r\nif ((c & MFP_LPM_CAN_WAKEUP) && !gpio_desc[gpio].can_wakeup) {\r\npr_warn("%s: GPIO%d unable to wakeup\n", __func__, gpio);\r\nreturn -EINVAL;\r\n}\r\nif ((c & MFP_LPM_CAN_WAKEUP) && is_out) {\r\npr_warn("%s: output GPIO%d unable to wakeup\n", __func__, gpio);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic inline int __mfp_validate(int mfp)\r\n{\r\nint gpio = mfp_to_gpio(mfp);\r\nif ((mfp > MFP_PIN_GPIO127) || !gpio_desc[gpio].valid) {\r\npr_warn("%s: GPIO%d is invalid pin\n", __func__, gpio);\r\nreturn -1;\r\n}\r\nreturn gpio;\r\n}\r\nvoid pxa2xx_mfp_config(unsigned long *mfp_cfgs, int num)\r\n{\r\nunsigned long flags;\r\nunsigned long *c;\r\nint i, gpio;\r\nfor (i = 0, c = mfp_cfgs; i < num; i++, c++) {\r\ngpio = __mfp_validate(MFP_PIN(*c));\r\nif (gpio < 0)\r\ncontinue;\r\nlocal_irq_save(flags);\r\ngpio_desc[gpio].config = *c;\r\n__mfp_config_gpio(gpio, *c);\r\nlocal_irq_restore(flags);\r\n}\r\n}\r\nvoid pxa2xx_mfp_set_lpm(int mfp, unsigned long lpm)\r\n{\r\nunsigned long flags, c;\r\nint gpio;\r\ngpio = __mfp_validate(mfp);\r\nif (gpio < 0)\r\nreturn;\r\nlocal_irq_save(flags);\r\nc = gpio_desc[gpio].config;\r\nc = (c & ~MFP_LPM_STATE_MASK) | lpm;\r\n__mfp_config_gpio(gpio, c);\r\nlocal_irq_restore(flags);\r\n}\r\nint gpio_set_wake(unsigned int gpio, unsigned int on)\r\n{\r\nstruct gpio_desc *d;\r\nunsigned long c, mux_taken;\r\nif (gpio > mfp_to_gpio(MFP_PIN_GPIO127))\r\nreturn -EINVAL;\r\nd = &gpio_desc[gpio];\r\nc = d->config;\r\nif (!d->valid)\r\nreturn -EINVAL;\r\nif (d->keypad_gpio && (MFP_AF(d->config) == 0) &&\r\n(d->config & MFP_LPM_CAN_WAKEUP)) {\r\nif (on)\r\nPKWR |= d->mask;\r\nelse\r\nPKWR &= ~d->mask;\r\nreturn 0;\r\n}\r\nmux_taken = (PWER & d->mux_mask) & (~d->mask);\r\nif (on && mux_taken)\r\nreturn -EBUSY;\r\nif (d->can_wakeup && (c & MFP_LPM_CAN_WAKEUP)) {\r\nif (on) {\r\nPWER = (PWER & ~d->mux_mask) | d->mask;\r\nif (c & MFP_LPM_EDGE_RISE)\r\nPRER |= d->mask;\r\nelse\r\nPRER &= ~d->mask;\r\nif (c & MFP_LPM_EDGE_FALL)\r\nPFER |= d->mask;\r\nelse\r\nPFER &= ~d->mask;\r\n} else {\r\nPWER &= ~d->mask;\r\nPRER &= ~d->mask;\r\nPFER &= ~d->mask;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void __init pxa25x_mfp_init(void)\r\n{\r\nint i;\r\n#ifdef CONFIG_CPU_PXA26x\r\npxa_last_gpio = 89;\r\n#else\r\npxa_last_gpio = 84;\r\n#endif\r\nfor (i = 0; i <= pxa_last_gpio; i++)\r\ngpio_desc[i].valid = 1;\r\nfor (i = 0; i <= 15; i++) {\r\ngpio_desc[i].can_wakeup = 1;\r\ngpio_desc[i].mask = GPIO_bit(i);\r\n}\r\nfor (i = 86; i <= pxa_last_gpio; i++)\r\ngpio_desc[i].dir_inverted = 1;\r\n}\r\nstatic inline void pxa25x_mfp_init(void) {}\r\nint keypad_set_wake(unsigned int on)\r\n{\r\nunsigned int i, gpio, mask = 0;\r\nstruct gpio_desc *d;\r\nfor (i = 0; i < ARRAY_SIZE(pxa27x_pkwr_gpio); i++) {\r\ngpio = pxa27x_pkwr_gpio[i];\r\nd = &gpio_desc[gpio];\r\nif (MFP_AF(d->config) == 0)\r\ncontinue;\r\nif (d->config & MFP_LPM_CAN_WAKEUP)\r\nmask |= gpio_desc[gpio].mask;\r\n}\r\nif (on)\r\nPKWR |= mask;\r\nelse\r\nPKWR &= ~mask;\r\nreturn 0;\r\n}\r\nstatic void __init pxa27x_mfp_init(void)\r\n{\r\nint i, gpio;\r\npxa_last_gpio = 120;\r\nfor (i = 0; i <= pxa_last_gpio; i++) {\r\nif (i == 2 || i == 5 || i == 6 || i == 7 || i == 8)\r\ncontinue;\r\ngpio_desc[i].valid = 1;\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(pxa27x_pkwr_gpio); i++) {\r\ngpio = pxa27x_pkwr_gpio[i];\r\ngpio_desc[gpio].can_wakeup = 1;\r\ngpio_desc[gpio].keypad_gpio = 1;\r\ngpio_desc[gpio].mask = 1 << i;\r\n}\r\nfor (i = 0; i <= 15; i++) {\r\nif (GPIO_bit(i) & 0x1e4)\r\ncontinue;\r\ngpio_desc[i].can_wakeup = 1;\r\ngpio_desc[i].mask = GPIO_bit(i);\r\n}\r\ngpio_desc[35].can_wakeup = 1;\r\ngpio_desc[35].mask = PWER_WE35;\r\nINIT_GPIO_DESC_MUXED(WEMUX3, 31);\r\nINIT_GPIO_DESC_MUXED(WEMUX3, 113);\r\nINIT_GPIO_DESC_MUXED(WEMUX2, 38);\r\nINIT_GPIO_DESC_MUXED(WEMUX2, 53);\r\nINIT_GPIO_DESC_MUXED(WEMUX2, 40);\r\nINIT_GPIO_DESC_MUXED(WEMUX2, 36);\r\n}\r\nstatic inline void pxa27x_mfp_init(void) {}\r\nstatic int pxa2xx_mfp_suspend(void)\r\n{\r\nint i;\r\nfor (i = 0; i < pxa_last_gpio; i++) {\r\nif ((gpio_desc[i].config & MFP_LPM_KEEP_OUTPUT) &&\r\n(GPDR(i) & GPIO_bit(i))) {\r\nif (GPLR(i) & GPIO_bit(i))\r\nPGSR(gpio_to_bank(i)) |= GPIO_bit(i);\r\nelse\r\nPGSR(gpio_to_bank(i)) &= ~GPIO_bit(i);\r\n}\r\n}\r\nfor (i = 0; i <= gpio_to_bank(pxa_last_gpio); i++) {\r\nsaved_gafr[0][i] = GAFR_L(i);\r\nsaved_gafr[1][i] = GAFR_U(i);\r\nsaved_gpdr[i] = GPDR(i * 32);\r\nsaved_gplr[i] = GPLR(i * 32);\r\nsaved_pgsr[i] = PGSR(i);\r\nGPSR(i * 32) = PGSR(i);\r\nGPCR(i * 32) = ~PGSR(i);\r\n}\r\nfor (i = 0; i < pxa_last_gpio; i++) {\r\nif ((gpdr_lpm[gpio_to_bank(i)] & GPIO_bit(i)) ||\r\n((gpio_desc[i].config & MFP_LPM_KEEP_OUTPUT) &&\r\n(saved_gpdr[gpio_to_bank(i)] & GPIO_bit(i))))\r\nGPDR(i) |= GPIO_bit(i);\r\nelse\r\nGPDR(i) &= ~GPIO_bit(i);\r\n}\r\nreturn 0;\r\n}\r\nstatic void pxa2xx_mfp_resume(void)\r\n{\r\nint i;\r\nfor (i = 0; i <= gpio_to_bank(pxa_last_gpio); i++) {\r\nGAFR_L(i) = saved_gafr[0][i];\r\nGAFR_U(i) = saved_gafr[1][i];\r\nGPSR(i * 32) = saved_gplr[i];\r\nGPCR(i * 32) = ~saved_gplr[i];\r\nGPDR(i * 32) = saved_gpdr[i];\r\nPGSR(i) = saved_pgsr[i];\r\n}\r\nPSSR = PSSR_RDH | PSSR_PH;\r\n}\r\nstatic int __init pxa2xx_mfp_init(void)\r\n{\r\nint i;\r\nif (!cpu_is_pxa2xx())\r\nreturn 0;\r\nif (cpu_is_pxa25x())\r\npxa25x_mfp_init();\r\nif (cpu_is_pxa27x())\r\npxa27x_mfp_init();\r\nPSSR = PSSR_RDH;\r\nfor (i = 0; i <= gpio_to_bank(pxa_last_gpio); i++)\r\ngpdr_lpm[i] = GPDR(i * 32);\r\nreturn 0;\r\n}
