static int\r\nlnet_ptl_match_type(unsigned int index, lnet_process_id_t match_id,\r\n__u64 mbits, __u64 ignore_bits)\r\n{\r\nstruct lnet_portal *ptl = the_lnet.ln_portals[index];\r\nint unique;\r\nunique = ignore_bits == 0 &&\r\nmatch_id.nid != LNET_NID_ANY &&\r\nmatch_id.pid != LNET_PID_ANY;\r\nLASSERT(!lnet_ptl_is_unique(ptl) || !lnet_ptl_is_wildcard(ptl));\r\nif (likely(lnet_ptl_is_unique(ptl) || lnet_ptl_is_wildcard(ptl)))\r\ngoto match;\r\nlnet_ptl_lock(ptl);\r\nif (unlikely(lnet_ptl_is_unique(ptl) || lnet_ptl_is_wildcard(ptl))) {\r\nlnet_ptl_unlock(ptl);\r\ngoto match;\r\n}\r\nif (unique)\r\nlnet_ptl_setopt(ptl, LNET_PTL_MATCH_UNIQUE);\r\nelse\r\nlnet_ptl_setopt(ptl, LNET_PTL_MATCH_WILDCARD);\r\nlnet_ptl_unlock(ptl);\r\nreturn 1;\r\nmatch:\r\nif ((lnet_ptl_is_unique(ptl) && !unique) ||\r\n(lnet_ptl_is_wildcard(ptl) && unique))\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic void\r\nlnet_ptl_enable_mt(struct lnet_portal *ptl, int cpt)\r\n{\r\nstruct lnet_match_table *mtable = ptl->ptl_mtables[cpt];\r\nint i;\r\nLASSERT(lnet_ptl_is_wildcard(ptl));\r\nmtable->mt_enabled = 1;\r\nptl->ptl_mt_maps[ptl->ptl_mt_nmaps] = cpt;\r\nfor (i = ptl->ptl_mt_nmaps - 1; i >= 0; i--) {\r\nLASSERT(ptl->ptl_mt_maps[i] != cpt);\r\nif (ptl->ptl_mt_maps[i] < cpt)\r\nbreak;\r\nptl->ptl_mt_maps[i + 1] = ptl->ptl_mt_maps[i];\r\nptl->ptl_mt_maps[i] = cpt;\r\n}\r\nptl->ptl_mt_nmaps++;\r\n}\r\nstatic void\r\nlnet_ptl_disable_mt(struct lnet_portal *ptl, int cpt)\r\n{\r\nstruct lnet_match_table *mtable = ptl->ptl_mtables[cpt];\r\nint i;\r\nLASSERT(lnet_ptl_is_wildcard(ptl));\r\nif (LNET_CPT_NUMBER == 1)\r\nreturn;\r\nmtable->mt_enabled = 0;\r\nLASSERT(ptl->ptl_mt_nmaps > 0 &&\r\nptl->ptl_mt_nmaps <= LNET_CPT_NUMBER);\r\nptl->ptl_mt_nmaps--;\r\nfor (i = 0; i < ptl->ptl_mt_nmaps; i++) {\r\nif (ptl->ptl_mt_maps[i] >= cpt)\r\nptl->ptl_mt_maps[i] = ptl->ptl_mt_maps[i + 1];\r\n}\r\n}\r\nstatic int\r\nlnet_try_match_md(lnet_libmd_t *md,\r\nstruct lnet_match_info *info, struct lnet_msg *msg)\r\n{\r\nunsigned int offset;\r\nunsigned int mlength;\r\nlnet_me_t *me = md->md_me;\r\nif (lnet_md_exhausted(md))\r\nreturn LNET_MATCHMD_NONE | LNET_MATCHMD_EXHAUSTED;\r\nif ((md->md_options & info->mi_opc) == 0)\r\nreturn LNET_MATCHMD_NONE;\r\nif (me->me_match_id.nid != LNET_NID_ANY &&\r\nme->me_match_id.nid != info->mi_id.nid)\r\nreturn LNET_MATCHMD_NONE;\r\nif (me->me_match_id.pid != LNET_PID_ANY &&\r\nme->me_match_id.pid != info->mi_id.pid)\r\nreturn LNET_MATCHMD_NONE;\r\nif (((me->me_match_bits ^ info->mi_mbits) & ~me->me_ignore_bits) != 0)\r\nreturn LNET_MATCHMD_NONE;\r\nif ((md->md_options & LNET_MD_MANAGE_REMOTE) == 0)\r\noffset = md->md_offset;\r\nelse\r\noffset = info->mi_roffset;\r\nif ((md->md_options & LNET_MD_MAX_SIZE) != 0) {\r\nmlength = md->md_max_size;\r\nLASSERT(md->md_offset + mlength <= md->md_length);\r\n} else {\r\nmlength = md->md_length - offset;\r\n}\r\nif (info->mi_rlength <= mlength) {\r\nmlength = info->mi_rlength;\r\n} else if ((md->md_options & LNET_MD_TRUNCATE) == 0) {\r\nCERROR("Matching packet from %s, match %llu length %d too big: %d left, %d allowed\n",\r\nlibcfs_id2str(info->mi_id), info->mi_mbits,\r\ninfo->mi_rlength, md->md_length - offset, mlength);\r\nreturn LNET_MATCHMD_DROP;\r\n}\r\nCDEBUG(D_NET, "Incoming %s index %x from %s of length %d/%d into md %#llx [%d] + %d\n",\r\n(info->mi_opc == LNET_MD_OP_PUT) ? "put" : "get",\r\ninfo->mi_portal, libcfs_id2str(info->mi_id), mlength,\r\ninfo->mi_rlength, md->md_lh.lh_cookie, md->md_niov, offset);\r\nlnet_msg_attach_md(msg, md, offset, mlength);\r\nmd->md_offset = offset + mlength;\r\nif (!lnet_md_exhausted(md))\r\nreturn LNET_MATCHMD_OK;\r\nif ((md->md_flags & LNET_MD_FLAG_AUTO_UNLINK) != 0)\r\nlnet_md_unlink(md);\r\nreturn LNET_MATCHMD_OK | LNET_MATCHMD_EXHAUSTED;\r\n}\r\nstatic struct lnet_match_table *\r\nlnet_match2mt(struct lnet_portal *ptl, lnet_process_id_t id, __u64 mbits)\r\n{\r\nif (LNET_CPT_NUMBER == 1)\r\nreturn ptl->ptl_mtables[0];\r\nreturn lnet_ptl_is_unique(ptl) ?\r\nptl->ptl_mtables[lnet_cpt_of_nid(id.nid)] : NULL;\r\n}\r\nstruct lnet_match_table *\r\nlnet_mt_of_attach(unsigned int index, lnet_process_id_t id,\r\n__u64 mbits, __u64 ignore_bits, lnet_ins_pos_t pos)\r\n{\r\nstruct lnet_portal *ptl;\r\nstruct lnet_match_table *mtable;\r\nLASSERT(index < the_lnet.ln_nportals);\r\nif (!lnet_ptl_match_type(index, id, mbits, ignore_bits))\r\nreturn NULL;\r\nptl = the_lnet.ln_portals[index];\r\nmtable = lnet_match2mt(ptl, id, mbits);\r\nif (mtable != NULL)\r\nreturn mtable;\r\nswitch (pos) {\r\ndefault:\r\nreturn NULL;\r\ncase LNET_INS_BEFORE:\r\ncase LNET_INS_AFTER:\r\nreturn ptl->ptl_mtables[ptl->ptl_index % LNET_CPT_NUMBER];\r\ncase LNET_INS_LOCAL:\r\nreturn ptl->ptl_mtables[lnet_cpt_current()];\r\n}\r\n}\r\nstatic struct lnet_match_table *\r\nlnet_mt_of_match(struct lnet_match_info *info, struct lnet_msg *msg)\r\n{\r\nstruct lnet_match_table *mtable;\r\nstruct lnet_portal *ptl;\r\nunsigned int nmaps;\r\nunsigned int rotor;\r\nunsigned int cpt;\r\nbool routed;\r\nLASSERT(info->mi_portal < the_lnet.ln_nportals);\r\nptl = the_lnet.ln_portals[info->mi_portal];\r\nLASSERT(lnet_ptl_is_wildcard(ptl) || lnet_ptl_is_unique(ptl));\r\nmtable = lnet_match2mt(ptl, info->mi_id, info->mi_mbits);\r\nif (mtable != NULL)\r\nreturn mtable;\r\nrouted = LNET_NIDNET(msg->msg_hdr.src_nid) !=\r\nLNET_NIDNET(msg->msg_hdr.dest_nid);\r\nif (portal_rotor == LNET_PTL_ROTOR_OFF ||\r\n(portal_rotor != LNET_PTL_ROTOR_ON && !routed)) {\r\ncpt = lnet_cpt_current();\r\nif (ptl->ptl_mtables[cpt]->mt_enabled)\r\nreturn ptl->ptl_mtables[cpt];\r\n}\r\nrotor = ptl->ptl_rotor++;\r\nif (portal_rotor == LNET_PTL_ROTOR_HASH_RT && routed)\r\ncpt = lnet_cpt_of_nid(msg->msg_hdr.src_nid);\r\nelse\r\ncpt = rotor % LNET_CPT_NUMBER;\r\nif (!ptl->ptl_mtables[cpt]->mt_enabled) {\r\nnmaps = ptl->ptl_mt_nmaps;\r\nif (nmaps != 0) {\r\ncpt = ptl->ptl_mt_maps[rotor % nmaps];\r\n}\r\n}\r\nreturn ptl->ptl_mtables[cpt];\r\n}\r\nstatic int\r\nlnet_mt_test_exhausted(struct lnet_match_table *mtable, int pos)\r\n{\r\n__u64 *bmap;\r\nint i;\r\nif (!lnet_ptl_is_wildcard(the_lnet.ln_portals[mtable->mt_portal]))\r\nreturn 0;\r\nif (pos < 0) {\r\nfor (i = 0; i < LNET_MT_EXHAUSTED_BMAP; i++) {\r\nif (mtable->mt_exhausted[i] != (__u64)(-1))\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nLASSERT(pos <= LNET_MT_HASH_IGNORE);\r\nbmap = &mtable->mt_exhausted[pos >> LNET_MT_BITS_U64];\r\npos &= (1 << LNET_MT_BITS_U64) - 1;\r\nreturn ((*bmap) & (1ULL << pos)) != 0;\r\n}\r\nstatic void\r\nlnet_mt_set_exhausted(struct lnet_match_table *mtable, int pos, int exhausted)\r\n{\r\n__u64 *bmap;\r\nLASSERT(lnet_ptl_is_wildcard(the_lnet.ln_portals[mtable->mt_portal]));\r\nLASSERT(pos <= LNET_MT_HASH_IGNORE);\r\nbmap = &mtable->mt_exhausted[pos >> LNET_MT_BITS_U64];\r\npos &= (1 << LNET_MT_BITS_U64) - 1;\r\nif (!exhausted)\r\n*bmap &= ~(1ULL << pos);\r\nelse\r\n*bmap |= 1ULL << pos;\r\n}\r\nstruct list_head *\r\nlnet_mt_match_head(struct lnet_match_table *mtable,\r\nlnet_process_id_t id, __u64 mbits)\r\n{\r\nstruct lnet_portal *ptl = the_lnet.ln_portals[mtable->mt_portal];\r\nif (lnet_ptl_is_wildcard(ptl)) {\r\nreturn &mtable->mt_mhash[mbits & LNET_MT_HASH_MASK];\r\n} else {\r\nunsigned long hash = mbits + id.nid + id.pid;\r\nLASSERT(lnet_ptl_is_unique(ptl));\r\nhash = hash_long(hash, LNET_MT_HASH_BITS);\r\nreturn &mtable->mt_mhash[hash];\r\n}\r\n}\r\nint\r\nlnet_mt_match_md(struct lnet_match_table *mtable,\r\nstruct lnet_match_info *info, struct lnet_msg *msg)\r\n{\r\nstruct list_head *head;\r\nlnet_me_t *me;\r\nlnet_me_t *tmp;\r\nint exhausted = 0;\r\nint rc;\r\nif (!list_empty(&mtable->mt_mhash[LNET_MT_HASH_IGNORE]))\r\nhead = &mtable->mt_mhash[LNET_MT_HASH_IGNORE];\r\nelse\r\nhead = lnet_mt_match_head(mtable, info->mi_id, info->mi_mbits);\r\nagain:\r\nif (lnet_ptl_is_wildcard(the_lnet.ln_portals[mtable->mt_portal]))\r\nexhausted = LNET_MATCHMD_EXHAUSTED;\r\nlist_for_each_entry_safe(me, tmp, head, me_list) {\r\nif (me->me_md == NULL)\r\ncontinue;\r\nLASSERT(me == me->me_md->md_me);\r\nrc = lnet_try_match_md(me->me_md, info, msg);\r\nif ((rc & LNET_MATCHMD_EXHAUSTED) == 0)\r\nexhausted = 0;\r\nif ((rc & LNET_MATCHMD_FINISH) != 0) {\r\nreturn rc & ~LNET_MATCHMD_EXHAUSTED;\r\n}\r\n}\r\nif (exhausted == LNET_MATCHMD_EXHAUSTED) {\r\nlnet_mt_set_exhausted(mtable, head - mtable->mt_mhash, 1);\r\nif (!lnet_mt_test_exhausted(mtable, -1))\r\nexhausted = 0;\r\n}\r\nif (exhausted == 0 && head == &mtable->mt_mhash[LNET_MT_HASH_IGNORE]) {\r\nhead = lnet_mt_match_head(mtable, info->mi_id, info->mi_mbits);\r\ngoto again;\r\n}\r\nif (info->mi_opc == LNET_MD_OP_GET ||\r\n!lnet_ptl_is_lazy(the_lnet.ln_portals[info->mi_portal]))\r\nreturn LNET_MATCHMD_DROP | exhausted;\r\nreturn LNET_MATCHMD_NONE | exhausted;\r\n}\r\nstatic int\r\nlnet_ptl_match_early(struct lnet_portal *ptl, struct lnet_msg *msg)\r\n{\r\nint rc;\r\nif (likely(lnet_ptl_is_wildcard(ptl) || lnet_ptl_is_unique(ptl)))\r\nreturn 0;\r\nlnet_ptl_lock(ptl);\r\nif (lnet_ptl_is_wildcard(ptl) || lnet_ptl_is_unique(ptl)) {\r\nlnet_ptl_unlock(ptl);\r\nreturn 0;\r\n}\r\nif (lnet_ptl_is_lazy(ptl)) {\r\nif (msg->msg_rx_ready_delay) {\r\nmsg->msg_rx_delayed = 1;\r\nlist_add_tail(&msg->msg_list,\r\n&ptl->ptl_msg_delayed);\r\n}\r\nrc = LNET_MATCHMD_NONE;\r\n} else {\r\nrc = LNET_MATCHMD_DROP;\r\n}\r\nlnet_ptl_unlock(ptl);\r\nreturn rc;\r\n}\r\nstatic int\r\nlnet_ptl_match_delay(struct lnet_portal *ptl,\r\nstruct lnet_match_info *info, struct lnet_msg *msg)\r\n{\r\nint first = ptl->ptl_mt_maps[0];\r\nint rc = 0;\r\nint i;\r\nLASSERT(lnet_ptl_is_wildcard(ptl));\r\nfor (i = 0; i < LNET_CPT_NUMBER; i++) {\r\nstruct lnet_match_table *mtable;\r\nint cpt;\r\ncpt = (first + i) % LNET_CPT_NUMBER;\r\nmtable = ptl->ptl_mtables[cpt];\r\nif (i != 0 && i != LNET_CPT_NUMBER - 1 && !mtable->mt_enabled)\r\ncontinue;\r\nlnet_res_lock(cpt);\r\nlnet_ptl_lock(ptl);\r\nif (i == 0) {\r\nlist_add_tail(&msg->msg_list,\r\n&ptl->ptl_msg_stealing);\r\n}\r\nif (!list_empty(&msg->msg_list)) {\r\nrc = lnet_mt_match_md(mtable, info, msg);\r\nif ((rc & LNET_MATCHMD_EXHAUSTED) != 0 &&\r\nmtable->mt_enabled)\r\nlnet_ptl_disable_mt(ptl, cpt);\r\nif ((rc & LNET_MATCHMD_FINISH) != 0)\r\nlist_del_init(&msg->msg_list);\r\n} else {\r\nrc = msg->msg_md == NULL ?\r\nLNET_MATCHMD_DROP : LNET_MATCHMD_OK;\r\n}\r\nif (!list_empty(&msg->msg_list) &&\r\n(i == LNET_CPT_NUMBER - 1 ||\r\nptl->ptl_mt_nmaps == 0 ||\r\n(ptl->ptl_mt_nmaps == 1 &&\r\nptl->ptl_mt_maps[0] == cpt))) {\r\nlist_del_init(&msg->msg_list);\r\nif (lnet_ptl_is_lazy(ptl)) {\r\nmsg->msg_rx_delayed = 1;\r\nlist_add_tail(&msg->msg_list,\r\n&ptl->ptl_msg_delayed);\r\nrc = LNET_MATCHMD_NONE;\r\n} else {\r\nrc = LNET_MATCHMD_DROP;\r\n}\r\n}\r\nlnet_ptl_unlock(ptl);\r\nlnet_res_unlock(cpt);\r\nif ((rc & LNET_MATCHMD_FINISH) != 0 || msg->msg_rx_delayed)\r\nbreak;\r\n}\r\nreturn rc;\r\n}\r\nint\r\nlnet_ptl_match_md(struct lnet_match_info *info, struct lnet_msg *msg)\r\n{\r\nstruct lnet_match_table *mtable;\r\nstruct lnet_portal *ptl;\r\nint rc;\r\nCDEBUG(D_NET, "Request from %s of length %d into portal %d MB=%#llx\n",\r\nlibcfs_id2str(info->mi_id), info->mi_rlength, info->mi_portal,\r\ninfo->mi_mbits);\r\nif (info->mi_portal >= the_lnet.ln_nportals) {\r\nCERROR("Invalid portal %d not in [0-%d]\n",\r\ninfo->mi_portal, the_lnet.ln_nportals);\r\nreturn LNET_MATCHMD_DROP;\r\n}\r\nptl = the_lnet.ln_portals[info->mi_portal];\r\nrc = lnet_ptl_match_early(ptl, msg);\r\nif (rc != 0)\r\nreturn rc;\r\nmtable = lnet_mt_of_match(info, msg);\r\nlnet_res_lock(mtable->mt_cpt);\r\nif (the_lnet.ln_shutdown) {\r\nrc = LNET_MATCHMD_DROP;\r\ngoto out1;\r\n}\r\nrc = lnet_mt_match_md(mtable, info, msg);\r\nif ((rc & LNET_MATCHMD_EXHAUSTED) != 0 && mtable->mt_enabled) {\r\nlnet_ptl_lock(ptl);\r\nlnet_ptl_disable_mt(ptl, mtable->mt_cpt);\r\nlnet_ptl_unlock(ptl);\r\n}\r\nif ((rc & LNET_MATCHMD_FINISH) != 0)\r\ngoto out1;\r\nif (!msg->msg_rx_ready_delay)\r\ngoto out1;\r\nLASSERT(lnet_ptl_is_lazy(ptl));\r\nLASSERT(!msg->msg_rx_delayed);\r\nif (lnet_ptl_is_unique(ptl) || LNET_CPT_NUMBER == 1) {\r\nlnet_ptl_lock(ptl);\r\nmsg->msg_rx_delayed = 1;\r\nlist_add_tail(&msg->msg_list, &ptl->ptl_msg_delayed);\r\nlnet_ptl_unlock(ptl);\r\nlnet_res_unlock(mtable->mt_cpt);\r\n} else {\r\nlnet_res_unlock(mtable->mt_cpt);\r\nrc = lnet_ptl_match_delay(ptl, info, msg);\r\n}\r\nif (msg->msg_rx_delayed) {\r\nCDEBUG(D_NET,\r\n"Delaying %s from %s ptl %d MB %#llx off %d len %d\n",\r\ninfo->mi_opc == LNET_MD_OP_PUT ? "PUT" : "GET",\r\nlibcfs_id2str(info->mi_id), info->mi_portal,\r\ninfo->mi_mbits, info->mi_roffset, info->mi_rlength);\r\n}\r\ngoto out0;\r\nout1:\r\nlnet_res_unlock(mtable->mt_cpt);\r\nout0:\r\nreturn rc & ~LNET_MATCHMD_EXHAUSTED;\r\n}\r\nvoid\r\nlnet_ptl_detach_md(lnet_me_t *me, lnet_libmd_t *md)\r\n{\r\nLASSERT(me->me_md == md && md->md_me == me);\r\nme->me_md = NULL;\r\nmd->md_me = NULL;\r\n}\r\nvoid\r\nlnet_ptl_attach_md(lnet_me_t *me, lnet_libmd_t *md,\r\nstruct list_head *matches, struct list_head *drops)\r\n{\r\nstruct lnet_portal *ptl = the_lnet.ln_portals[me->me_portal];\r\nstruct lnet_match_table *mtable;\r\nstruct list_head *head;\r\nlnet_msg_t *tmp;\r\nlnet_msg_t *msg;\r\nint exhausted = 0;\r\nint cpt;\r\nLASSERT(md->md_refcount == 0);\r\nme->me_md = md;\r\nmd->md_me = me;\r\ncpt = lnet_cpt_of_cookie(md->md_lh.lh_cookie);\r\nmtable = ptl->ptl_mtables[cpt];\r\nif (list_empty(&ptl->ptl_msg_stealing) &&\r\nlist_empty(&ptl->ptl_msg_delayed) &&\r\n!lnet_mt_test_exhausted(mtable, me->me_pos))\r\nreturn;\r\nlnet_ptl_lock(ptl);\r\nhead = &ptl->ptl_msg_stealing;\r\nagain:\r\nlist_for_each_entry_safe(msg, tmp, head, msg_list) {\r\nstruct lnet_match_info info;\r\nlnet_hdr_t *hdr;\r\nint rc;\r\nLASSERT(msg->msg_rx_delayed || head == &ptl->ptl_msg_stealing);\r\nhdr = &msg->msg_hdr;\r\ninfo.mi_id.nid = hdr->src_nid;\r\ninfo.mi_id.pid = hdr->src_pid;\r\ninfo.mi_opc = LNET_MD_OP_PUT;\r\ninfo.mi_portal = hdr->msg.put.ptl_index;\r\ninfo.mi_rlength = hdr->payload_length;\r\ninfo.mi_roffset = hdr->msg.put.offset;\r\ninfo.mi_mbits = hdr->msg.put.match_bits;\r\nrc = lnet_try_match_md(md, &info, msg);\r\nexhausted = (rc & LNET_MATCHMD_EXHAUSTED) != 0;\r\nif ((rc & LNET_MATCHMD_NONE) != 0) {\r\nif (exhausted)\r\nbreak;\r\ncontinue;\r\n}\r\nLASSERT((rc & LNET_MATCHMD_FINISH) != 0);\r\nlist_del_init(&msg->msg_list);\r\nif (head == &ptl->ptl_msg_stealing) {\r\nif (exhausted)\r\nbreak;\r\ncontinue;\r\n}\r\nif ((rc & LNET_MATCHMD_OK) != 0) {\r\nlist_add_tail(&msg->msg_list, matches);\r\nCDEBUG(D_NET, "Resuming delayed PUT from %s portal %d match %llu offset %d length %d.\n",\r\nlibcfs_id2str(info.mi_id),\r\ninfo.mi_portal, info.mi_mbits,\r\ninfo.mi_roffset, info.mi_rlength);\r\n} else {\r\nlist_add_tail(&msg->msg_list, drops);\r\n}\r\nif (exhausted)\r\nbreak;\r\n}\r\nif (!exhausted && head == &ptl->ptl_msg_stealing) {\r\nhead = &ptl->ptl_msg_delayed;\r\ngoto again;\r\n}\r\nif (lnet_ptl_is_wildcard(ptl) && !exhausted) {\r\nlnet_mt_set_exhausted(mtable, me->me_pos, 0);\r\nif (!mtable->mt_enabled)\r\nlnet_ptl_enable_mt(ptl, cpt);\r\n}\r\nlnet_ptl_unlock(ptl);\r\n}\r\nstatic void\r\nlnet_ptl_cleanup(struct lnet_portal *ptl)\r\n{\r\nstruct lnet_match_table *mtable;\r\nint i;\r\nif (ptl->ptl_mtables == NULL)\r\nreturn;\r\nLASSERT(list_empty(&ptl->ptl_msg_delayed));\r\nLASSERT(list_empty(&ptl->ptl_msg_stealing));\r\ncfs_percpt_for_each(mtable, i, ptl->ptl_mtables) {\r\nstruct list_head *mhash;\r\nlnet_me_t *me;\r\nint j;\r\nif (mtable->mt_mhash == NULL)\r\ncontinue;\r\nmhash = mtable->mt_mhash;\r\nfor (j = 0; j < LNET_MT_HASH_SIZE + 1; j++) {\r\nwhile (!list_empty(&mhash[j])) {\r\nme = list_entry(mhash[j].next,\r\nlnet_me_t, me_list);\r\nCERROR("Active ME %p on exit\n", me);\r\nlist_del(&me->me_list);\r\nlnet_me_free(me);\r\n}\r\n}\r\nLIBCFS_FREE(mhash, sizeof(*mhash) * (LNET_MT_HASH_SIZE + 1));\r\n}\r\ncfs_percpt_free(ptl->ptl_mtables);\r\nptl->ptl_mtables = NULL;\r\n}\r\nstatic int\r\nlnet_ptl_setup(struct lnet_portal *ptl, int index)\r\n{\r\nstruct lnet_match_table *mtable;\r\nstruct list_head *mhash;\r\nint i;\r\nint j;\r\nptl->ptl_mtables = cfs_percpt_alloc(lnet_cpt_table(),\r\nsizeof(struct lnet_match_table));\r\nif (ptl->ptl_mtables == NULL) {\r\nCERROR("Failed to create match table for portal %d\n", index);\r\nreturn -ENOMEM;\r\n}\r\nptl->ptl_index = index;\r\nINIT_LIST_HEAD(&ptl->ptl_msg_delayed);\r\nINIT_LIST_HEAD(&ptl->ptl_msg_stealing);\r\nspin_lock_init(&ptl->ptl_lock);\r\ncfs_percpt_for_each(mtable, i, ptl->ptl_mtables) {\r\nLIBCFS_CPT_ALLOC(mhash, lnet_cpt_table(), i,\r\nsizeof(*mhash) * (LNET_MT_HASH_SIZE + 1));\r\nif (mhash == NULL) {\r\nCERROR("Failed to create match hash for portal %d\n",\r\nindex);\r\ngoto failed;\r\n}\r\nmemset(&mtable->mt_exhausted[0], -1,\r\nsizeof(mtable->mt_exhausted[0]) *\r\nLNET_MT_EXHAUSTED_BMAP);\r\nmtable->mt_mhash = mhash;\r\nfor (j = 0; j < LNET_MT_HASH_SIZE + 1; j++)\r\nINIT_LIST_HEAD(&mhash[j]);\r\nmtable->mt_portal = index;\r\nmtable->mt_cpt = i;\r\n}\r\nreturn 0;\r\nfailed:\r\nlnet_ptl_cleanup(ptl);\r\nreturn -ENOMEM;\r\n}\r\nvoid\r\nlnet_portals_destroy(void)\r\n{\r\nint i;\r\nif (the_lnet.ln_portals == NULL)\r\nreturn;\r\nfor (i = 0; i < the_lnet.ln_nportals; i++)\r\nlnet_ptl_cleanup(the_lnet.ln_portals[i]);\r\ncfs_array_free(the_lnet.ln_portals);\r\nthe_lnet.ln_portals = NULL;\r\n}\r\nint\r\nlnet_portals_create(void)\r\n{\r\nint size;\r\nint i;\r\nsize = offsetof(struct lnet_portal, ptl_mt_maps[LNET_CPT_NUMBER]);\r\nthe_lnet.ln_nportals = MAX_PORTALS;\r\nthe_lnet.ln_portals = cfs_array_alloc(the_lnet.ln_nportals, size);\r\nif (the_lnet.ln_portals == NULL) {\r\nCERROR("Failed to allocate portals table\n");\r\nreturn -ENOMEM;\r\n}\r\nfor (i = 0; i < the_lnet.ln_nportals; i++) {\r\nif (lnet_ptl_setup(the_lnet.ln_portals[i], i)) {\r\nlnet_portals_destroy();\r\nreturn -ENOMEM;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nint\r\nLNetSetLazyPortal(int portal)\r\n{\r\nstruct lnet_portal *ptl;\r\nif (portal < 0 || portal >= the_lnet.ln_nportals)\r\nreturn -EINVAL;\r\nCDEBUG(D_NET, "Setting portal %d lazy\n", portal);\r\nptl = the_lnet.ln_portals[portal];\r\nlnet_res_lock(LNET_LOCK_EX);\r\nlnet_ptl_lock(ptl);\r\nlnet_ptl_setopt(ptl, LNET_PTL_LAZY);\r\nlnet_ptl_unlock(ptl);\r\nlnet_res_unlock(LNET_LOCK_EX);\r\nreturn 0;\r\n}\r\nint\r\nLNetClearLazyPortal(int portal)\r\n{\r\nstruct lnet_portal *ptl;\r\nLIST_HEAD (zombies);\r\nif (portal < 0 || portal >= the_lnet.ln_nportals)\r\nreturn -EINVAL;\r\nptl = the_lnet.ln_portals[portal];\r\nlnet_res_lock(LNET_LOCK_EX);\r\nlnet_ptl_lock(ptl);\r\nif (!lnet_ptl_is_lazy(ptl)) {\r\nlnet_ptl_unlock(ptl);\r\nlnet_res_unlock(LNET_LOCK_EX);\r\nreturn 0;\r\n}\r\nif (the_lnet.ln_shutdown)\r\nCWARN("Active lazy portal %d on exit\n", portal);\r\nelse\r\nCDEBUG(D_NET, "clearing portal %d lazy\n", portal);\r\nlist_splice_init(&ptl->ptl_msg_delayed, &zombies);\r\nlnet_ptl_unsetopt(ptl, LNET_PTL_LAZY);\r\nlnet_ptl_unlock(ptl);\r\nlnet_res_unlock(LNET_LOCK_EX);\r\nlnet_drop_delayed_msg_list(&zombies, "Clearing lazy portal attr");\r\nreturn 0;\r\n}
