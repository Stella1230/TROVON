static void display_event(struct usb_functionfs_event *event)\r\n{\r\nstatic const char *const names[] = {\r\n[FUNCTIONFS_BIND] = "BIND",\r\n[FUNCTIONFS_UNBIND] = "UNBIND",\r\n[FUNCTIONFS_ENABLE] = "ENABLE",\r\n[FUNCTIONFS_DISABLE] = "DISABLE",\r\n[FUNCTIONFS_SETUP] = "SETUP",\r\n[FUNCTIONFS_SUSPEND] = "SUSPEND",\r\n[FUNCTIONFS_RESUME] = "RESUME",\r\n};\r\nswitch (event->type) {\r\ncase FUNCTIONFS_BIND:\r\ncase FUNCTIONFS_UNBIND:\r\ncase FUNCTIONFS_ENABLE:\r\ncase FUNCTIONFS_DISABLE:\r\ncase FUNCTIONFS_SETUP:\r\ncase FUNCTIONFS_SUSPEND:\r\ncase FUNCTIONFS_RESUME:\r\nprintf("Event %s\n", names[event->type]);\r\n}\r\n}\r\nstatic void handle_ep0(int ep0, bool *ready)\r\n{\r\nstruct usb_functionfs_event event;\r\nint ret;\r\nstruct pollfd pfds[1];\r\npfds[0].fd = ep0;\r\npfds[0].events = POLLIN;\r\nret = poll(pfds, 1, 0);\r\nif (ret && (pfds[0].revents & POLLIN)) {\r\nret = read(ep0, &event, sizeof(event));\r\nif (!ret) {\r\nperror("unable to read event from ep0");\r\nreturn;\r\n}\r\ndisplay_event(&event);\r\nswitch (event.type) {\r\ncase FUNCTIONFS_SETUP:\r\nif (event.u.setup.bRequestType & USB_DIR_IN)\r\nwrite(ep0, NULL, 0);\r\nelse\r\nread(ep0, NULL, 0);\r\nbreak;\r\ncase FUNCTIONFS_ENABLE:\r\n*ready = true;\r\nbreak;\r\ncase FUNCTIONFS_DISABLE:\r\n*ready = false;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\n}\r\nint main(int argc, char *argv[])\r\n{\r\nint i, ret;\r\nchar *ep_path;\r\nint ep0;\r\nint ep[2];\r\nio_context_t ctx;\r\nint evfd;\r\nfd_set rfds;\r\nchar *buf_in, *buf_out;\r\nstruct iocb *iocb_in, *iocb_out;\r\nint req_in = 0, req_out = 0;\r\nbool ready;\r\nif (argc != 2) {\r\nprintf("ffs directory not specified!\n");\r\nreturn 1;\r\n}\r\nep_path = malloc(strlen(argv[1]) + 4 + 1 );\r\nif (!ep_path) {\r\nperror("malloc");\r\nreturn 1;\r\n}\r\nsprintf(ep_path, "%s/ep0", argv[1]);\r\nep0 = open(ep_path, O_RDWR);\r\nif (ep0 < 0) {\r\nperror("unable to open ep0");\r\nreturn 1;\r\n}\r\nif (write(ep0, &descriptors, sizeof(descriptors)) < 0) {\r\nperror("unable do write descriptors");\r\nreturn 1;\r\n}\r\nif (write(ep0, &strings, sizeof(strings)) < 0) {\r\nperror("unable to write strings");\r\nreturn 1;\r\n}\r\nfor (i = 0; i < 2; ++i) {\r\nsprintf(ep_path, "%s/ep%d", argv[1], i+1);\r\nep[i] = open(ep_path, O_RDWR);\r\nif (ep[i] < 0) {\r\nprintf("unable to open ep%d: %s\n", i+1,\r\nstrerror(errno));\r\nreturn 1;\r\n}\r\n}\r\nfree(ep_path);\r\nmemset(&ctx, 0, sizeof(ctx));\r\nif (io_setup(2, &ctx) < 0) {\r\nperror("unable to setup aio");\r\nreturn 1;\r\n}\r\nevfd = eventfd(0, 0);\r\nif (evfd < 0) {\r\nperror("unable to open eventfd");\r\nreturn 1;\r\n}\r\nbuf_in = malloc(BUF_LEN);\r\nbuf_out = malloc(BUF_LEN);\r\niocb_in = malloc(sizeof(*iocb_in));\r\niocb_out = malloc(sizeof(*iocb_out));\r\nwhile (1) {\r\nFD_ZERO(&rfds);\r\nFD_SET(ep0, &rfds);\r\nFD_SET(evfd, &rfds);\r\nret = select(((ep0 > evfd) ? ep0 : evfd)+1,\r\n&rfds, NULL, NULL, NULL);\r\nif (ret < 0) {\r\nif (errno == EINTR)\r\ncontinue;\r\nperror("select");\r\nbreak;\r\n}\r\nif (FD_ISSET(ep0, &rfds))\r\nhandle_ep0(ep0, &ready);\r\nif (!ready)\r\ncontinue;\r\nif (FD_ISSET(evfd, &rfds)) {\r\nuint64_t ev_cnt;\r\nret = read(evfd, &ev_cnt, sizeof(ev_cnt));\r\nif (ret < 0) {\r\nperror("unable to read eventfd");\r\nbreak;\r\n}\r\nstruct io_event e[2];\r\nret = io_getevents(ctx, 1, 2, e, NULL);\r\nfor (i = 0; i < ret; ++i) {\r\nif (e[i].obj->aio_fildes == ep[0]) {\r\nprintf("ev=in; ret=%lu\n", e[i].res);\r\nreq_in = 0;\r\n} else if (e[i].obj->aio_fildes == ep[1]) {\r\nprintf("ev=out; ret=%lu\n", e[i].res);\r\nreq_out = 0;\r\n}\r\n}\r\n}\r\nif (!req_in) {\r\nio_prep_pwrite(iocb_in, ep[0], buf_in, BUF_LEN, 0);\r\niocb_in->u.c.flags |= IOCB_FLAG_RESFD;\r\niocb_in->u.c.resfd = evfd;\r\nret = io_submit(ctx, 1, &iocb_in);\r\nif (ret >= 0) {\r\nreq_in = 1;\r\nprintf("submit: in\n");\r\n} else\r\nperror("unable to submit request");\r\n}\r\nif (!req_out) {\r\nio_prep_pread(iocb_out, ep[1], buf_out, BUF_LEN, 0);\r\niocb_out->u.c.flags |= IOCB_FLAG_RESFD;\r\niocb_out->u.c.resfd = evfd;\r\nret = io_submit(ctx, 1, &iocb_out);\r\nif (ret >= 0) {\r\nreq_out = 1;\r\nprintf("submit: out\n");\r\n} else\r\nperror("unable to submit request");\r\n}\r\n}\r\nio_destroy(ctx);\r\nfree(buf_in);\r\nfree(buf_out);\r\nfree(iocb_in);\r\nfree(iocb_out);\r\nfor (i = 0; i < 2; ++i)\r\nclose(ep[i]);\r\nclose(ep0);\r\nreturn 0;\r\n}
