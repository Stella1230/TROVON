ssize_t cyapa_smbus_read_block(struct cyapa *cyapa, u8 cmd, size_t len,\r\nu8 *values)\r\n{\r\nssize_t ret;\r\nu8 index;\r\nu8 smbus_cmd;\r\nu8 *buf;\r\nstruct i2c_client *client = cyapa->client;\r\nif (!(SMBUS_BYTE_BLOCK_CMD_MASK & cmd))\r\nreturn -EINVAL;\r\nif (SMBUS_GROUP_BLOCK_CMD_MASK & cmd) {\r\nsmbus_cmd = SMBUS_ENCODE_RW(cmd, SMBUS_READ);\r\nret = i2c_smbus_read_block_data(client, smbus_cmd, values);\r\ngoto out;\r\n}\r\nret = 0;\r\nfor (index = 0; index * I2C_SMBUS_BLOCK_MAX < len; index++) {\r\nsmbus_cmd = SMBUS_ENCODE_IDX(cmd, index);\r\nsmbus_cmd = SMBUS_ENCODE_RW(smbus_cmd, SMBUS_READ);\r\nbuf = values + I2C_SMBUS_BLOCK_MAX * index;\r\nret = i2c_smbus_read_block_data(client, smbus_cmd, buf);\r\nif (ret < 0)\r\ngoto out;\r\n}\r\nout:\r\nreturn ret > 0 ? len : ret;\r\n}\r\nstatic s32 cyapa_read_byte(struct cyapa *cyapa, u8 cmd_idx)\r\n{\r\nu8 cmd;\r\nif (cyapa->smbus) {\r\ncmd = cyapa_smbus_cmds[cmd_idx].cmd;\r\ncmd = SMBUS_ENCODE_RW(cmd, SMBUS_READ);\r\n} else {\r\ncmd = cyapa_i2c_cmds[cmd_idx].cmd;\r\n}\r\nreturn i2c_smbus_read_byte_data(cyapa->client, cmd);\r\n}\r\nstatic s32 cyapa_write_byte(struct cyapa *cyapa, u8 cmd_idx, u8 value)\r\n{\r\nu8 cmd;\r\nif (cyapa->smbus) {\r\ncmd = cyapa_smbus_cmds[cmd_idx].cmd;\r\ncmd = SMBUS_ENCODE_RW(cmd, SMBUS_WRITE);\r\n} else {\r\ncmd = cyapa_i2c_cmds[cmd_idx].cmd;\r\n}\r\nreturn i2c_smbus_write_byte_data(cyapa->client, cmd, value);\r\n}\r\nssize_t cyapa_i2c_reg_read_block(struct cyapa *cyapa, u8 reg, size_t len,\r\nu8 *values)\r\n{\r\nreturn i2c_smbus_read_i2c_block_data(cyapa->client, reg, len, values);\r\n}\r\nstatic ssize_t cyapa_i2c_reg_write_block(struct cyapa *cyapa, u8 reg,\r\nsize_t len, const u8 *values)\r\n{\r\nreturn i2c_smbus_write_i2c_block_data(cyapa->client, reg, len, values);\r\n}\r\nssize_t cyapa_read_block(struct cyapa *cyapa, u8 cmd_idx, u8 *values)\r\n{\r\nu8 cmd;\r\nsize_t len;\r\nif (cyapa->smbus) {\r\ncmd = cyapa_smbus_cmds[cmd_idx].cmd;\r\nlen = cyapa_smbus_cmds[cmd_idx].len;\r\nreturn cyapa_smbus_read_block(cyapa, cmd, len, values);\r\n}\r\ncmd = cyapa_i2c_cmds[cmd_idx].cmd;\r\nlen = cyapa_i2c_cmds[cmd_idx].len;\r\nreturn cyapa_i2c_reg_read_block(cyapa, cmd, len, values);\r\n}\r\nstatic int cyapa_gen3_state_parse(struct cyapa *cyapa, u8 *reg_data, int len)\r\n{\r\ncyapa->state = CYAPA_STATE_NO_DEVICE;\r\nif (reg_data[REG_BL_FILE] == BL_FILE &&\r\nreg_data[REG_BL_ERROR] == BL_ERROR_NO_ERR_IDLE &&\r\n(reg_data[REG_BL_STATUS] ==\r\n(BL_STATUS_RUNNING | BL_STATUS_CSUM_VALID) ||\r\nreg_data[REG_BL_STATUS] == BL_STATUS_RUNNING)) {\r\ncyapa->gen = CYAPA_GEN3;\r\ncyapa->state = CYAPA_STATE_BL_IDLE;\r\n} else if (reg_data[REG_BL_FILE] == BL_FILE &&\r\n(reg_data[REG_BL_STATUS] & BL_STATUS_RUNNING) ==\r\nBL_STATUS_RUNNING) {\r\ncyapa->gen = CYAPA_GEN3;\r\nif (reg_data[REG_BL_STATUS] & BL_STATUS_BUSY) {\r\ncyapa->state = CYAPA_STATE_BL_BUSY;\r\n} else {\r\nif ((reg_data[REG_BL_ERROR] & BL_ERROR_BOOTLOADING) ==\r\nBL_ERROR_BOOTLOADING)\r\ncyapa->state = CYAPA_STATE_BL_ACTIVE;\r\nelse\r\ncyapa->state = CYAPA_STATE_BL_IDLE;\r\n}\r\n} else if ((reg_data[REG_OP_STATUS] & OP_STATUS_SRC) &&\r\n(reg_data[REG_OP_DATA1] & OP_DATA_VALID)) {\r\nif (GEN3_FINGER_NUM(reg_data[REG_OP_DATA1]) <=\r\nGEN3_MAX_FINGERS) {\r\ncyapa->gen = CYAPA_GEN3;\r\ncyapa->state = CYAPA_STATE_OP;\r\n}\r\n} else if (reg_data[REG_OP_STATUS] == 0x0C &&\r\nreg_data[REG_OP_DATA1] == 0x08) {\r\ncyapa->gen = CYAPA_GEN3;\r\ncyapa->state = CYAPA_STATE_OP;\r\n} else if (reg_data[REG_BL_STATUS] &\r\n(BL_STATUS_RUNNING | BL_STATUS_BUSY)) {\r\ncyapa->gen = CYAPA_GEN3;\r\ncyapa->state = CYAPA_STATE_BL_BUSY;\r\n}\r\nif (cyapa->gen == CYAPA_GEN3 && (cyapa->state == CYAPA_STATE_OP ||\r\ncyapa->state == CYAPA_STATE_BL_IDLE ||\r\ncyapa->state == CYAPA_STATE_BL_ACTIVE ||\r\ncyapa->state == CYAPA_STATE_BL_BUSY))\r\nreturn 0;\r\nreturn -EAGAIN;\r\n}\r\nstatic int cyapa_gen3_bl_enter(struct cyapa *cyapa)\r\n{\r\nint error;\r\nint waiting_time;\r\nerror = cyapa_poll_state(cyapa, 500);\r\nif (error)\r\nreturn error;\r\nif (cyapa->state == CYAPA_STATE_BL_IDLE) {\r\nreturn 0;\r\n}\r\nif (cyapa->state != CYAPA_STATE_OP)\r\nreturn -EAGAIN;\r\ncyapa->operational = false;\r\ncyapa->state = CYAPA_STATE_NO_DEVICE;\r\nerror = cyapa_write_byte(cyapa, CYAPA_CMD_SOFT_RESET, 0x01);\r\nif (error)\r\nreturn -EIO;\r\nusleep_range(25000, 50000);\r\nwaiting_time = 2000;\r\ndo {\r\nerror = cyapa_poll_state(cyapa, 500);\r\nif (error) {\r\nif (error == -ETIMEDOUT) {\r\nwaiting_time -= 500;\r\ncontinue;\r\n}\r\nreturn error;\r\n}\r\nif ((cyapa->state == CYAPA_STATE_BL_IDLE) &&\r\n!(cyapa->status[REG_BL_STATUS] & BL_STATUS_WATCHDOG))\r\nbreak;\r\nmsleep(100);\r\nwaiting_time -= 100;\r\n} while (waiting_time > 0);\r\nif ((cyapa->state != CYAPA_STATE_BL_IDLE) ||\r\n(cyapa->status[REG_BL_STATUS] & BL_STATUS_WATCHDOG))\r\nreturn -EAGAIN;\r\nreturn 0;\r\n}\r\nstatic int cyapa_gen3_bl_activate(struct cyapa *cyapa)\r\n{\r\nint error;\r\nerror = cyapa_i2c_reg_write_block(cyapa, 0, sizeof(bl_activate),\r\nbl_activate);\r\nif (error)\r\nreturn error;\r\nmsleep(2000);\r\nerror = cyapa_poll_state(cyapa, 11000);\r\nif (error)\r\nreturn error;\r\nif (cyapa->state != CYAPA_STATE_BL_ACTIVE)\r\nreturn -EAGAIN;\r\nreturn 0;\r\n}\r\nstatic int cyapa_gen3_bl_deactivate(struct cyapa *cyapa)\r\n{\r\nint error;\r\nerror = cyapa_i2c_reg_write_block(cyapa, 0, sizeof(bl_deactivate),\r\nbl_deactivate);\r\nif (error)\r\nreturn error;\r\nmsleep(100);\r\nerror = cyapa_poll_state(cyapa, 500);\r\nif (error)\r\nreturn error;\r\nif (cyapa->state != CYAPA_STATE_BL_IDLE)\r\nreturn -EAGAIN;\r\nreturn 0;\r\n}\r\nstatic int cyapa_gen3_bl_exit(struct cyapa *cyapa)\r\n{\r\nint error;\r\nerror = cyapa_i2c_reg_write_block(cyapa, 0, sizeof(bl_exit), bl_exit);\r\nif (error)\r\nreturn error;\r\nusleep_range(50000, 100000);\r\nerror = cyapa_poll_state(cyapa, 4000);\r\nif (error < 0)\r\nreturn error;\r\nif (cyapa->state != CYAPA_STATE_OP)\r\nreturn -EAGAIN;\r\nreturn 0;\r\n}\r\nstatic u16 cyapa_gen3_csum(const u8 *buf, size_t count)\r\n{\r\nint i;\r\nu16 csum = 0;\r\nfor (i = 0; i < count; i++)\r\ncsum += buf[i];\r\nreturn csum;\r\n}\r\nstatic int cyapa_gen3_check_fw(struct cyapa *cyapa, const struct firmware *fw)\r\n{\r\nstruct device *dev = &cyapa->client->dev;\r\nu16 csum;\r\nu16 csum_expected;\r\nif (fw->size != CYAPA_FW_SIZE) {\r\ndev_err(dev, "invalid firmware size = %zu, expected %u.\n",\r\nfw->size, CYAPA_FW_SIZE);\r\nreturn -EINVAL;\r\n}\r\ncsum_expected = (fw->data[0] << 8) | fw->data[1];\r\ncsum = cyapa_gen3_csum(&fw->data[2], CYAPA_FW_HDR_SIZE - 2);\r\nif (csum != csum_expected) {\r\ndev_err(dev, "%s %04x, expected: %04x\n",\r\n"invalid firmware header checksum = ",\r\ncsum, csum_expected);\r\nreturn -EINVAL;\r\n}\r\ncsum_expected = (fw->data[CYAPA_FW_HDR_SIZE - 2] << 8) |\r\nfw->data[CYAPA_FW_HDR_SIZE - 1];\r\ncsum = cyapa_gen3_csum(&fw->data[CYAPA_FW_HDR_SIZE],\r\nCYAPA_FW_DATA_SIZE);\r\nif (csum != csum_expected) {\r\ndev_err(dev, "%s %04x, expected: %04x\n",\r\n"invalid firmware header checksum = ",\r\ncsum, csum_expected);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int cyapa_gen3_write_buffer(struct cyapa *cyapa,\r\nconst u8 *buf, size_t len)\r\n{\r\nint error;\r\nsize_t i;\r\nunsigned char cmd[CYAPA_CMD_LEN + 1];\r\nsize_t cmd_len;\r\nfor (i = 0; i < len; i += CYAPA_CMD_LEN) {\r\nconst u8 *payload = &buf[i];\r\ncmd_len = (len - i >= CYAPA_CMD_LEN) ? CYAPA_CMD_LEN : len - i;\r\ncmd[0] = i;\r\nmemcpy(&cmd[1], payload, cmd_len);\r\nerror = cyapa_i2c_reg_write_block(cyapa, 0, cmd_len + 1, cmd);\r\nif (error)\r\nreturn error;\r\n}\r\nreturn 0;\r\n}\r\nstatic int cyapa_gen3_write_fw_block(struct cyapa *cyapa,\r\nu16 block, const u8 *data)\r\n{\r\nint ret;\r\nstruct gen3_write_block_cmd write_block_cmd;\r\nu8 status[BL_STATUS_SIZE];\r\nint tries;\r\nu8 bl_status, bl_error;\r\nwrite_block_cmd.checksum_seed = GEN3_BL_CMD_CHECKSUM_SEED;\r\nwrite_block_cmd.cmd_code = GEN3_BL_CMD_WRITE_BLOCK;\r\nmemcpy(write_block_cmd.key, security_key, sizeof(security_key));\r\nput_unaligned_be16(block, &write_block_cmd.block_num);\r\nmemcpy(write_block_cmd.block_data, data, CYAPA_FW_BLOCK_SIZE);\r\nwrite_block_cmd.block_checksum = cyapa_gen3_csum(\r\nwrite_block_cmd.block_data, CYAPA_FW_BLOCK_SIZE);\r\nwrite_block_cmd.cmd_checksum = cyapa_gen3_csum((u8 *)&write_block_cmd,\r\nsizeof(write_block_cmd) - 1);\r\nret = cyapa_gen3_write_buffer(cyapa, (u8 *)&write_block_cmd,\r\nsizeof(write_block_cmd));\r\nif (ret)\r\nreturn ret;\r\ntries = 11;\r\ndo {\r\nusleep_range(10000, 20000);\r\nret = cyapa_i2c_reg_read_block(cyapa, BL_HEAD_OFFSET,\r\nBL_STATUS_SIZE, status);\r\nif (ret != BL_STATUS_SIZE)\r\nreturn (ret < 0) ? ret : -EIO;\r\n} while ((status[REG_BL_STATUS] & BL_STATUS_BUSY) && --tries);\r\nbl_status = status[REG_BL_STATUS] & ~BL_STATUS_REV_MASK;\r\nbl_error = status[REG_BL_ERROR] & ~BL_ERROR_RESERVED;\r\nif (bl_status & BL_STATUS_BUSY)\r\nret = -ETIMEDOUT;\r\nelse if (bl_status != BL_STATUS_RUNNING ||\r\nbl_error != BL_ERROR_BOOTLOADING)\r\nret = -EIO;\r\nelse\r\nret = 0;\r\nreturn ret;\r\n}\r\nstatic int cyapa_gen3_write_blocks(struct cyapa *cyapa,\r\nsize_t start_block, size_t block_count,\r\nconst u8 *image_data)\r\n{\r\nint error;\r\nint i;\r\nfor (i = 0; i < block_count; i++) {\r\nsize_t block = start_block + i;\r\nsize_t addr = i * CYAPA_FW_BLOCK_SIZE;\r\nconst u8 *data = &image_data[addr];\r\nerror = cyapa_gen3_write_fw_block(cyapa, block, data);\r\nif (error)\r\nreturn error;\r\n}\r\nreturn 0;\r\n}\r\nstatic int cyapa_gen3_do_fw_update(struct cyapa *cyapa,\r\nconst struct firmware *fw)\r\n{\r\nstruct device *dev = &cyapa->client->dev;\r\nint error;\r\nerror = cyapa_gen3_write_blocks(cyapa,\r\nCYAPA_FW_DATA_BLOCK_START, CYAPA_FW_DATA_BLOCK_COUNT,\r\n&fw->data[CYAPA_FW_HDR_BLOCK_COUNT * CYAPA_FW_BLOCK_SIZE]);\r\nif (error) {\r\ndev_err(dev, "FW update aborted, write image: %d\n", error);\r\nreturn error;\r\n}\r\nerror = cyapa_gen3_write_blocks(cyapa,\r\nCYAPA_FW_HDR_BLOCK_START, CYAPA_FW_HDR_BLOCK_COUNT,\r\n&fw->data[0]);\r\nif (error) {\r\ndev_err(dev, "FW update aborted, write checksum: %d\n", error);\r\nreturn error;\r\n}\r\nreturn 0;\r\n}\r\nstatic ssize_t cyapa_gen3_do_calibrate(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct cyapa *cyapa = dev_get_drvdata(dev);\r\nint tries;\r\nint ret;\r\nret = cyapa_read_byte(cyapa, CYAPA_CMD_DEV_STATUS);\r\nif (ret < 0) {\r\ndev_err(dev, "Error reading dev status: %d\n", ret);\r\ngoto out;\r\n}\r\nif ((ret & CYAPA_DEV_NORMAL) != CYAPA_DEV_NORMAL) {\r\ndev_warn(dev, "Trackpad device is busy, device state: 0x%02x\n",\r\nret);\r\nret = -EAGAIN;\r\ngoto out;\r\n}\r\nret = cyapa_write_byte(cyapa, CYAPA_CMD_SOFT_RESET,\r\nOP_RECALIBRATION_MASK);\r\nif (ret < 0) {\r\ndev_err(dev, "Failed to send calibrate command: %d\n",\r\nret);\r\ngoto out;\r\n}\r\ntries = 20;\r\ndo {\r\nusleep_range(100000, 200000);\r\nret = cyapa_read_byte(cyapa, CYAPA_CMD_DEV_STATUS);\r\nif (ret < 0) {\r\ndev_err(dev, "Error reading dev status: %d\n",\r\nret);\r\ngoto out;\r\n}\r\nif ((ret & CYAPA_DEV_NORMAL) == CYAPA_DEV_NORMAL)\r\nbreak;\r\n} while (--tries);\r\nif (tries == 0) {\r\ndev_err(dev, "Failed to calibrate. Timeout.\n");\r\nret = -ETIMEDOUT;\r\ngoto out;\r\n}\r\ndev_dbg(dev, "Calibration successful.\n");\r\nout:\r\nreturn ret < 0 ? ret : count;\r\n}\r\nstatic ssize_t cyapa_gen3_show_baseline(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct cyapa *cyapa = dev_get_drvdata(dev);\r\nint max_baseline, min_baseline;\r\nint tries;\r\nint ret;\r\nret = cyapa_read_byte(cyapa, CYAPA_CMD_DEV_STATUS);\r\nif (ret < 0) {\r\ndev_err(dev, "Error reading dev status. err = %d\n", ret);\r\ngoto out;\r\n}\r\nif ((ret & CYAPA_DEV_NORMAL) != CYAPA_DEV_NORMAL) {\r\ndev_warn(dev, "Trackpad device is busy. device state = 0x%x\n",\r\nret);\r\nret = -EAGAIN;\r\ngoto out;\r\n}\r\nret = cyapa_write_byte(cyapa, CYAPA_CMD_SOFT_RESET,\r\nOP_REPORT_BASELINE_MASK);\r\nif (ret < 0) {\r\ndev_err(dev, "Failed to send report baseline command. %d\n",\r\nret);\r\ngoto out;\r\n}\r\ntries = 3;\r\ndo {\r\nusleep_range(10000, 20000);\r\nret = cyapa_read_byte(cyapa, CYAPA_CMD_DEV_STATUS);\r\nif (ret < 0) {\r\ndev_err(dev, "Error reading dev status. err = %d\n",\r\nret);\r\ngoto out;\r\n}\r\nif ((ret & CYAPA_DEV_NORMAL) == CYAPA_DEV_NORMAL)\r\nbreak;\r\n} while (--tries);\r\nif (tries == 0) {\r\ndev_err(dev, "Device timed out going to Normal state.\n");\r\nret = -ETIMEDOUT;\r\ngoto out;\r\n}\r\nret = cyapa_read_byte(cyapa, CYAPA_CMD_MAX_BASELINE);\r\nif (ret < 0) {\r\ndev_err(dev, "Failed to read max baseline. err = %d\n", ret);\r\ngoto out;\r\n}\r\nmax_baseline = ret;\r\nret = cyapa_read_byte(cyapa, CYAPA_CMD_MIN_BASELINE);\r\nif (ret < 0) {\r\ndev_err(dev, "Failed to read min baseline. err = %d\n", ret);\r\ngoto out;\r\n}\r\nmin_baseline = ret;\r\ndev_dbg(dev, "Baseline report successful. Max: %d Min: %d\n",\r\nmax_baseline, min_baseline);\r\nret = scnprintf(buf, PAGE_SIZE, "%d %d\n", max_baseline, min_baseline);\r\nout:\r\nreturn ret;\r\n}\r\nstatic u16 cyapa_get_wait_time_for_pwr_cmd(u8 pwr_mode)\r\n{\r\nswitch (pwr_mode) {\r\ncase PWR_MODE_FULL_ACTIVE: return 20;\r\ncase PWR_MODE_BTN_ONLY: return 20;\r\ncase PWR_MODE_OFF: return 20;\r\ndefault: return cyapa_pwr_cmd_to_sleep_time(pwr_mode) + 50;\r\n}\r\n}\r\nstatic int cyapa_gen3_set_power_mode(struct cyapa *cyapa, u8 power_mode,\r\nu16 always_unused)\r\n{\r\nint ret;\r\nu8 power;\r\nint tries;\r\nu16 sleep_time;\r\nalways_unused = 0;\r\nif (cyapa->state != CYAPA_STATE_OP)\r\nreturn 0;\r\ntries = SET_POWER_MODE_TRIES;\r\nwhile (tries--) {\r\nret = cyapa_read_byte(cyapa, CYAPA_CMD_POWER_MODE);\r\nif (ret >= 0)\r\nbreak;\r\nusleep_range(SET_POWER_MODE_DELAY, 2 * SET_POWER_MODE_DELAY);\r\n}\r\nif (ret < 0)\r\nreturn ret;\r\nif ((ret & PWR_MODE_MASK) == power_mode)\r\nreturn 0;\r\nsleep_time = cyapa_get_wait_time_for_pwr_cmd(ret & PWR_MODE_MASK);\r\npower = ret;\r\npower &= ~PWR_MODE_MASK;\r\npower |= power_mode & PWR_MODE_MASK;\r\ntries = SET_POWER_MODE_TRIES;\r\nwhile (tries--) {\r\nret = cyapa_write_byte(cyapa, CYAPA_CMD_POWER_MODE, power);\r\nif (!ret)\r\nbreak;\r\nusleep_range(SET_POWER_MODE_DELAY, 2 * SET_POWER_MODE_DELAY);\r\n}\r\nmsleep(sleep_time);\r\nreturn ret;\r\n}\r\nstatic int cyapa_gen3_get_query_data(struct cyapa *cyapa)\r\n{\r\nu8 query_data[QUERY_DATA_SIZE];\r\nint ret;\r\nif (cyapa->state != CYAPA_STATE_OP)\r\nreturn -EBUSY;\r\nret = cyapa_read_block(cyapa, CYAPA_CMD_GROUP_QUERY, query_data);\r\nif (ret != QUERY_DATA_SIZE)\r\nreturn (ret < 0) ? ret : -EIO;\r\nmemcpy(&cyapa->product_id[0], &query_data[0], 5);\r\ncyapa->product_id[5] = '-';\r\nmemcpy(&cyapa->product_id[6], &query_data[5], 6);\r\ncyapa->product_id[12] = '-';\r\nmemcpy(&cyapa->product_id[13], &query_data[11], 2);\r\ncyapa->product_id[15] = '\0';\r\ncyapa->fw_maj_ver = query_data[15];\r\ncyapa->fw_min_ver = query_data[16];\r\ncyapa->btn_capability = query_data[19] & CAPABILITY_BTN_MASK;\r\ncyapa->gen = query_data[20] & 0x0f;\r\ncyapa->max_abs_x = ((query_data[21] & 0xf0) << 4) | query_data[22];\r\ncyapa->max_abs_y = ((query_data[21] & 0x0f) << 8) | query_data[23];\r\ncyapa->physical_size_x =\r\n((query_data[24] & 0xf0) << 4) | query_data[25];\r\ncyapa->physical_size_y =\r\n((query_data[24] & 0x0f) << 8) | query_data[26];\r\ncyapa->max_z = 255;\r\nreturn 0;\r\n}\r\nstatic int cyapa_gen3_bl_query_data(struct cyapa *cyapa)\r\n{\r\nu8 bl_data[CYAPA_CMD_LEN];\r\nint ret;\r\nret = cyapa_i2c_reg_read_block(cyapa, 0, CYAPA_CMD_LEN, bl_data);\r\nif (ret != CYAPA_CMD_LEN)\r\nreturn (ret < 0) ? ret : -EIO;\r\nif (bl_data[REG_BL_STATUS] ==\r\n(BL_STATUS_RUNNING | BL_STATUS_CSUM_VALID)) {\r\ncyapa->fw_maj_ver = bl_data[GEN3_BL_IDLE_FW_MAJ_VER_OFFSET];\r\ncyapa->fw_min_ver = bl_data[GEN3_BL_IDLE_FW_MIN_VER_OFFSET];\r\n}\r\nreturn 0;\r\n}\r\nstatic int cyapa_gen3_do_operational_check(struct cyapa *cyapa)\r\n{\r\nstruct device *dev = &cyapa->client->dev;\r\nint error;\r\nswitch (cyapa->state) {\r\ncase CYAPA_STATE_BL_ACTIVE:\r\nerror = cyapa_gen3_bl_deactivate(cyapa);\r\nif (error) {\r\ndev_err(dev, "failed to bl_deactivate: %d\n", error);\r\nreturn error;\r\n}\r\ncase CYAPA_STATE_BL_IDLE:\r\ncyapa_gen3_bl_query_data(cyapa);\r\nerror = cyapa_gen3_bl_exit(cyapa);\r\nif (error) {\r\ndev_err(dev, "failed to bl_exit: %d\n", error);\r\nreturn error;\r\n}\r\ncase CYAPA_STATE_OP:\r\nerror = cyapa_gen3_set_power_mode(cyapa,\r\nPWR_MODE_FULL_ACTIVE, 0);\r\nif (error)\r\ndev_err(dev, "%s: set full power mode failed: %d\n",\r\n__func__, error);\r\nerror = cyapa_gen3_get_query_data(cyapa);\r\nif (error < 0)\r\nreturn error;\r\nif (cyapa->gen != CYAPA_GEN3) {\r\ndev_err(dev, "unsupported protocol version (%d)",\r\ncyapa->gen);\r\nreturn -EINVAL;\r\n}\r\nif (memcmp(cyapa->product_id, product_id,\r\nstrlen(product_id)) != 0) {\r\ndev_err(dev, "unsupported product ID (%s)\n",\r\ncyapa->product_id);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\ndefault:\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic bool cyapa_gen3_irq_cmd_handler(struct cyapa *cyapa)\r\n{\r\nif (cyapa->gen != CYAPA_GEN3)\r\nreturn true;\r\nif (cyapa->operational)\r\nreturn true;\r\nreturn false;\r\n}\r\nstatic int cyapa_gen3_irq_handler(struct cyapa *cyapa)\r\n{\r\nstruct input_dev *input = cyapa->input;\r\nstruct device *dev = &cyapa->client->dev;\r\nstruct cyapa_reg_data data;\r\nint num_fingers;\r\nint ret;\r\nint i;\r\nret = cyapa_read_block(cyapa, CYAPA_CMD_GROUP_DATA, (u8 *)&data);\r\nif (ret != sizeof(data)) {\r\ndev_err(dev, "failed to read report data, (%d)\n", ret);\r\nreturn -EINVAL;\r\n}\r\nif ((data.device_status & OP_STATUS_SRC) != OP_STATUS_SRC ||\r\n(data.device_status & OP_STATUS_DEV) != CYAPA_DEV_NORMAL ||\r\n(data.finger_btn & OP_DATA_VALID) != OP_DATA_VALID) {\r\ndev_err(dev, "invalid device state bytes, %02x %02x\n",\r\ndata.device_status, data.finger_btn);\r\nreturn -EINVAL;\r\n}\r\nnum_fingers = (data.finger_btn >> 4) & 0x0f;\r\nfor (i = 0; i < num_fingers; i++) {\r\nconst struct cyapa_touch *touch = &data.touches[i];\r\nint slot = touch->id - 1;\r\ninput_mt_slot(input, slot);\r\ninput_mt_report_slot_state(input, MT_TOOL_FINGER, true);\r\ninput_report_abs(input, ABS_MT_POSITION_X,\r\n((touch->xy_hi & 0xf0) << 4) | touch->x_lo);\r\ninput_report_abs(input, ABS_MT_POSITION_Y,\r\n((touch->xy_hi & 0x0f) << 8) | touch->y_lo);\r\ninput_report_abs(input, ABS_MT_PRESSURE, touch->pressure);\r\n}\r\ninput_mt_sync_frame(input);\r\nif (cyapa->btn_capability & CAPABILITY_LEFT_BTN_MASK)\r\ninput_report_key(input, BTN_LEFT,\r\n!!(data.finger_btn & OP_DATA_LEFT_BTN));\r\nif (cyapa->btn_capability & CAPABILITY_MIDDLE_BTN_MASK)\r\ninput_report_key(input, BTN_MIDDLE,\r\n!!(data.finger_btn & OP_DATA_MIDDLE_BTN));\r\nif (cyapa->btn_capability & CAPABILITY_RIGHT_BTN_MASK)\r\ninput_report_key(input, BTN_RIGHT,\r\n!!(data.finger_btn & OP_DATA_RIGHT_BTN));\r\ninput_sync(input);\r\nreturn 0;\r\n}\r\nstatic int cyapa_gen3_initialize(struct cyapa *cyapa) { return 0; }\r\nstatic int cyapa_gen3_bl_initiate(struct cyapa *cyapa,\r\nconst struct firmware *fw) { return 0; }\r\nstatic int cyapa_gen3_empty_output_data(struct cyapa *cyapa,\r\nu8 *buf, int *len, cb_sort func) { return 0; }
