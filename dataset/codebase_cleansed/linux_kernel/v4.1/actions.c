static void action_fifo_init(struct action_fifo *fifo)\r\n{\r\nfifo->head = 0;\r\nfifo->tail = 0;\r\n}\r\nstatic bool action_fifo_is_empty(const struct action_fifo *fifo)\r\n{\r\nreturn (fifo->head == fifo->tail);\r\n}\r\nstatic struct deferred_action *action_fifo_get(struct action_fifo *fifo)\r\n{\r\nif (action_fifo_is_empty(fifo))\r\nreturn NULL;\r\nreturn &fifo->fifo[fifo->tail++];\r\n}\r\nstatic struct deferred_action *action_fifo_put(struct action_fifo *fifo)\r\n{\r\nif (fifo->head >= DEFERRED_ACTION_FIFO_SIZE - 1)\r\nreturn NULL;\r\nreturn &fifo->fifo[fifo->head++];\r\n}\r\nstatic struct deferred_action *add_deferred_actions(struct sk_buff *skb,\r\nconst struct sw_flow_key *key,\r\nconst struct nlattr *attr)\r\n{\r\nstruct action_fifo *fifo;\r\nstruct deferred_action *da;\r\nfifo = this_cpu_ptr(action_fifos);\r\nda = action_fifo_put(fifo);\r\nif (da) {\r\nda->skb = skb;\r\nda->actions = attr;\r\nda->pkt_key = *key;\r\n}\r\nreturn da;\r\n}\r\nstatic void invalidate_flow_key(struct sw_flow_key *key)\r\n{\r\nkey->eth.type = htons(0);\r\n}\r\nstatic bool is_flow_key_valid(const struct sw_flow_key *key)\r\n{\r\nreturn !!key->eth.type;\r\n}\r\nstatic int push_mpls(struct sk_buff *skb, struct sw_flow_key *key,\r\nconst struct ovs_action_push_mpls *mpls)\r\n{\r\n__be32 *new_mpls_lse;\r\nstruct ethhdr *hdr;\r\nif (skb->encapsulation)\r\nreturn -ENOTSUPP;\r\nif (skb_cow_head(skb, MPLS_HLEN) < 0)\r\nreturn -ENOMEM;\r\nskb_push(skb, MPLS_HLEN);\r\nmemmove(skb_mac_header(skb) - MPLS_HLEN, skb_mac_header(skb),\r\nskb->mac_len);\r\nskb_reset_mac_header(skb);\r\nnew_mpls_lse = (__be32 *)skb_mpls_header(skb);\r\n*new_mpls_lse = mpls->mpls_lse;\r\nif (skb->ip_summed == CHECKSUM_COMPLETE)\r\nskb->csum = csum_add(skb->csum, csum_partial(new_mpls_lse,\r\nMPLS_HLEN, 0));\r\nhdr = eth_hdr(skb);\r\nhdr->h_proto = mpls->mpls_ethertype;\r\nif (!skb->inner_protocol)\r\nskb_set_inner_protocol(skb, skb->protocol);\r\nskb->protocol = mpls->mpls_ethertype;\r\ninvalidate_flow_key(key);\r\nreturn 0;\r\n}\r\nstatic int pop_mpls(struct sk_buff *skb, struct sw_flow_key *key,\r\nconst __be16 ethertype)\r\n{\r\nstruct ethhdr *hdr;\r\nint err;\r\nerr = skb_ensure_writable(skb, skb->mac_len + MPLS_HLEN);\r\nif (unlikely(err))\r\nreturn err;\r\nskb_postpull_rcsum(skb, skb_mpls_header(skb), MPLS_HLEN);\r\nmemmove(skb_mac_header(skb) + MPLS_HLEN, skb_mac_header(skb),\r\nskb->mac_len);\r\n__skb_pull(skb, MPLS_HLEN);\r\nskb_reset_mac_header(skb);\r\nhdr = (struct ethhdr *)(skb_mpls_header(skb) - ETH_HLEN);\r\nhdr->h_proto = ethertype;\r\nif (eth_p_mpls(skb->protocol))\r\nskb->protocol = ethertype;\r\ninvalidate_flow_key(key);\r\nreturn 0;\r\n}\r\nstatic int set_mpls(struct sk_buff *skb, struct sw_flow_key *flow_key,\r\nconst __be32 *mpls_lse, const __be32 *mask)\r\n{\r\n__be32 *stack;\r\n__be32 lse;\r\nint err;\r\nerr = skb_ensure_writable(skb, skb->mac_len + MPLS_HLEN);\r\nif (unlikely(err))\r\nreturn err;\r\nstack = (__be32 *)skb_mpls_header(skb);\r\nlse = MASKED(*stack, *mpls_lse, *mask);\r\nif (skb->ip_summed == CHECKSUM_COMPLETE) {\r\n__be32 diff[] = { ~(*stack), lse };\r\nskb->csum = ~csum_partial((char *)diff, sizeof(diff),\r\n~skb->csum);\r\n}\r\n*stack = lse;\r\nflow_key->mpls.top_lse = lse;\r\nreturn 0;\r\n}\r\nstatic int pop_vlan(struct sk_buff *skb, struct sw_flow_key *key)\r\n{\r\nint err;\r\nerr = skb_vlan_pop(skb);\r\nif (skb_vlan_tag_present(skb))\r\ninvalidate_flow_key(key);\r\nelse\r\nkey->eth.tci = 0;\r\nreturn err;\r\n}\r\nstatic int push_vlan(struct sk_buff *skb, struct sw_flow_key *key,\r\nconst struct ovs_action_push_vlan *vlan)\r\n{\r\nif (skb_vlan_tag_present(skb))\r\ninvalidate_flow_key(key);\r\nelse\r\nkey->eth.tci = vlan->vlan_tci;\r\nreturn skb_vlan_push(skb, vlan->vlan_tpid,\r\nntohs(vlan->vlan_tci) & ~VLAN_TAG_PRESENT);\r\n}\r\nstatic void ether_addr_copy_masked(u8 *dst_, const u8 *src_, const u8 *mask_)\r\n{\r\nu16 *dst = (u16 *)dst_;\r\nconst u16 *src = (const u16 *)src_;\r\nconst u16 *mask = (const u16 *)mask_;\r\nSET_MASKED(dst[0], src[0], mask[0]);\r\nSET_MASKED(dst[1], src[1], mask[1]);\r\nSET_MASKED(dst[2], src[2], mask[2]);\r\n}\r\nstatic int set_eth_addr(struct sk_buff *skb, struct sw_flow_key *flow_key,\r\nconst struct ovs_key_ethernet *key,\r\nconst struct ovs_key_ethernet *mask)\r\n{\r\nint err;\r\nerr = skb_ensure_writable(skb, ETH_HLEN);\r\nif (unlikely(err))\r\nreturn err;\r\nskb_postpull_rcsum(skb, eth_hdr(skb), ETH_ALEN * 2);\r\nether_addr_copy_masked(eth_hdr(skb)->h_source, key->eth_src,\r\nmask->eth_src);\r\nether_addr_copy_masked(eth_hdr(skb)->h_dest, key->eth_dst,\r\nmask->eth_dst);\r\novs_skb_postpush_rcsum(skb, eth_hdr(skb), ETH_ALEN * 2);\r\nether_addr_copy(flow_key->eth.src, eth_hdr(skb)->h_source);\r\nether_addr_copy(flow_key->eth.dst, eth_hdr(skb)->h_dest);\r\nreturn 0;\r\n}\r\nstatic void set_ip_addr(struct sk_buff *skb, struct iphdr *nh,\r\n__be32 *addr, __be32 new_addr)\r\n{\r\nint transport_len = skb->len - skb_transport_offset(skb);\r\nif (nh->protocol == IPPROTO_TCP) {\r\nif (likely(transport_len >= sizeof(struct tcphdr)))\r\ninet_proto_csum_replace4(&tcp_hdr(skb)->check, skb,\r\n*addr, new_addr, 1);\r\n} else if (nh->protocol == IPPROTO_UDP) {\r\nif (likely(transport_len >= sizeof(struct udphdr))) {\r\nstruct udphdr *uh = udp_hdr(skb);\r\nif (uh->check || skb->ip_summed == CHECKSUM_PARTIAL) {\r\ninet_proto_csum_replace4(&uh->check, skb,\r\n*addr, new_addr, 1);\r\nif (!uh->check)\r\nuh->check = CSUM_MANGLED_0;\r\n}\r\n}\r\n}\r\ncsum_replace4(&nh->check, *addr, new_addr);\r\nskb_clear_hash(skb);\r\n*addr = new_addr;\r\n}\r\nstatic void update_ipv6_checksum(struct sk_buff *skb, u8 l4_proto,\r\n__be32 addr[4], const __be32 new_addr[4])\r\n{\r\nint transport_len = skb->len - skb_transport_offset(skb);\r\nif (l4_proto == NEXTHDR_TCP) {\r\nif (likely(transport_len >= sizeof(struct tcphdr)))\r\ninet_proto_csum_replace16(&tcp_hdr(skb)->check, skb,\r\naddr, new_addr, 1);\r\n} else if (l4_proto == NEXTHDR_UDP) {\r\nif (likely(transport_len >= sizeof(struct udphdr))) {\r\nstruct udphdr *uh = udp_hdr(skb);\r\nif (uh->check || skb->ip_summed == CHECKSUM_PARTIAL) {\r\ninet_proto_csum_replace16(&uh->check, skb,\r\naddr, new_addr, 1);\r\nif (!uh->check)\r\nuh->check = CSUM_MANGLED_0;\r\n}\r\n}\r\n} else if (l4_proto == NEXTHDR_ICMP) {\r\nif (likely(transport_len >= sizeof(struct icmp6hdr)))\r\ninet_proto_csum_replace16(&icmp6_hdr(skb)->icmp6_cksum,\r\nskb, addr, new_addr, 1);\r\n}\r\n}\r\nstatic void mask_ipv6_addr(const __be32 old[4], const __be32 addr[4],\r\nconst __be32 mask[4], __be32 masked[4])\r\n{\r\nmasked[0] = MASKED(old[0], addr[0], mask[0]);\r\nmasked[1] = MASKED(old[1], addr[1], mask[1]);\r\nmasked[2] = MASKED(old[2], addr[2], mask[2]);\r\nmasked[3] = MASKED(old[3], addr[3], mask[3]);\r\n}\r\nstatic void set_ipv6_addr(struct sk_buff *skb, u8 l4_proto,\r\n__be32 addr[4], const __be32 new_addr[4],\r\nbool recalculate_csum)\r\n{\r\nif (recalculate_csum)\r\nupdate_ipv6_checksum(skb, l4_proto, addr, new_addr);\r\nskb_clear_hash(skb);\r\nmemcpy(addr, new_addr, sizeof(__be32[4]));\r\n}\r\nstatic void set_ipv6_fl(struct ipv6hdr *nh, u32 fl, u32 mask)\r\n{\r\nSET_MASKED(nh->flow_lbl[0], (u8)(fl >> 16), (u8)(mask >> 16));\r\nSET_MASKED(nh->flow_lbl[1], (u8)(fl >> 8), (u8)(mask >> 8));\r\nSET_MASKED(nh->flow_lbl[2], (u8)fl, (u8)mask);\r\n}\r\nstatic void set_ip_ttl(struct sk_buff *skb, struct iphdr *nh, u8 new_ttl,\r\nu8 mask)\r\n{\r\nnew_ttl = MASKED(nh->ttl, new_ttl, mask);\r\ncsum_replace2(&nh->check, htons(nh->ttl << 8), htons(new_ttl << 8));\r\nnh->ttl = new_ttl;\r\n}\r\nstatic int set_ipv4(struct sk_buff *skb, struct sw_flow_key *flow_key,\r\nconst struct ovs_key_ipv4 *key,\r\nconst struct ovs_key_ipv4 *mask)\r\n{\r\nstruct iphdr *nh;\r\n__be32 new_addr;\r\nint err;\r\nerr = skb_ensure_writable(skb, skb_network_offset(skb) +\r\nsizeof(struct iphdr));\r\nif (unlikely(err))\r\nreturn err;\r\nnh = ip_hdr(skb);\r\nif (mask->ipv4_src) {\r\nnew_addr = MASKED(nh->saddr, key->ipv4_src, mask->ipv4_src);\r\nif (unlikely(new_addr != nh->saddr)) {\r\nset_ip_addr(skb, nh, &nh->saddr, new_addr);\r\nflow_key->ipv4.addr.src = new_addr;\r\n}\r\n}\r\nif (mask->ipv4_dst) {\r\nnew_addr = MASKED(nh->daddr, key->ipv4_dst, mask->ipv4_dst);\r\nif (unlikely(new_addr != nh->daddr)) {\r\nset_ip_addr(skb, nh, &nh->daddr, new_addr);\r\nflow_key->ipv4.addr.dst = new_addr;\r\n}\r\n}\r\nif (mask->ipv4_tos) {\r\nipv4_change_dsfield(nh, ~mask->ipv4_tos, key->ipv4_tos);\r\nflow_key->ip.tos = nh->tos;\r\n}\r\nif (mask->ipv4_ttl) {\r\nset_ip_ttl(skb, nh, key->ipv4_ttl, mask->ipv4_ttl);\r\nflow_key->ip.ttl = nh->ttl;\r\n}\r\nreturn 0;\r\n}\r\nstatic bool is_ipv6_mask_nonzero(const __be32 addr[4])\r\n{\r\nreturn !!(addr[0] | addr[1] | addr[2] | addr[3]);\r\n}\r\nstatic int set_ipv6(struct sk_buff *skb, struct sw_flow_key *flow_key,\r\nconst struct ovs_key_ipv6 *key,\r\nconst struct ovs_key_ipv6 *mask)\r\n{\r\nstruct ipv6hdr *nh;\r\nint err;\r\nerr = skb_ensure_writable(skb, skb_network_offset(skb) +\r\nsizeof(struct ipv6hdr));\r\nif (unlikely(err))\r\nreturn err;\r\nnh = ipv6_hdr(skb);\r\nif (is_ipv6_mask_nonzero(mask->ipv6_src)) {\r\n__be32 *saddr = (__be32 *)&nh->saddr;\r\n__be32 masked[4];\r\nmask_ipv6_addr(saddr, key->ipv6_src, mask->ipv6_src, masked);\r\nif (unlikely(memcmp(saddr, masked, sizeof(masked)))) {\r\nset_ipv6_addr(skb, key->ipv6_proto, saddr, masked,\r\ntrue);\r\nmemcpy(&flow_key->ipv6.addr.src, masked,\r\nsizeof(flow_key->ipv6.addr.src));\r\n}\r\n}\r\nif (is_ipv6_mask_nonzero(mask->ipv6_dst)) {\r\nunsigned int offset = 0;\r\nint flags = IP6_FH_F_SKIP_RH;\r\nbool recalc_csum = true;\r\n__be32 *daddr = (__be32 *)&nh->daddr;\r\n__be32 masked[4];\r\nmask_ipv6_addr(daddr, key->ipv6_dst, mask->ipv6_dst, masked);\r\nif (unlikely(memcmp(daddr, masked, sizeof(masked)))) {\r\nif (ipv6_ext_hdr(nh->nexthdr))\r\nrecalc_csum = (ipv6_find_hdr(skb, &offset,\r\nNEXTHDR_ROUTING,\r\nNULL, &flags)\r\n!= NEXTHDR_ROUTING);\r\nset_ipv6_addr(skb, key->ipv6_proto, daddr, masked,\r\nrecalc_csum);\r\nmemcpy(&flow_key->ipv6.addr.dst, masked,\r\nsizeof(flow_key->ipv6.addr.dst));\r\n}\r\n}\r\nif (mask->ipv6_tclass) {\r\nipv6_change_dsfield(nh, ~mask->ipv6_tclass, key->ipv6_tclass);\r\nflow_key->ip.tos = ipv6_get_dsfield(nh);\r\n}\r\nif (mask->ipv6_label) {\r\nset_ipv6_fl(nh, ntohl(key->ipv6_label),\r\nntohl(mask->ipv6_label));\r\nflow_key->ipv6.label =\r\n*(__be32 *)nh & htonl(IPV6_FLOWINFO_FLOWLABEL);\r\n}\r\nif (mask->ipv6_hlimit) {\r\nSET_MASKED(nh->hop_limit, key->ipv6_hlimit, mask->ipv6_hlimit);\r\nflow_key->ip.ttl = nh->hop_limit;\r\n}\r\nreturn 0;\r\n}\r\nstatic void set_tp_port(struct sk_buff *skb, __be16 *port,\r\n__be16 new_port, __sum16 *check)\r\n{\r\ninet_proto_csum_replace2(check, skb, *port, new_port, 0);\r\n*port = new_port;\r\n}\r\nstatic int set_udp(struct sk_buff *skb, struct sw_flow_key *flow_key,\r\nconst struct ovs_key_udp *key,\r\nconst struct ovs_key_udp *mask)\r\n{\r\nstruct udphdr *uh;\r\n__be16 src, dst;\r\nint err;\r\nerr = skb_ensure_writable(skb, skb_transport_offset(skb) +\r\nsizeof(struct udphdr));\r\nif (unlikely(err))\r\nreturn err;\r\nuh = udp_hdr(skb);\r\nsrc = MASKED(uh->source, key->udp_src, mask->udp_src);\r\ndst = MASKED(uh->dest, key->udp_dst, mask->udp_dst);\r\nif (uh->check && skb->ip_summed != CHECKSUM_PARTIAL) {\r\nif (likely(src != uh->source)) {\r\nset_tp_port(skb, &uh->source, src, &uh->check);\r\nflow_key->tp.src = src;\r\n}\r\nif (likely(dst != uh->dest)) {\r\nset_tp_port(skb, &uh->dest, dst, &uh->check);\r\nflow_key->tp.dst = dst;\r\n}\r\nif (unlikely(!uh->check))\r\nuh->check = CSUM_MANGLED_0;\r\n} else {\r\nuh->source = src;\r\nuh->dest = dst;\r\nflow_key->tp.src = src;\r\nflow_key->tp.dst = dst;\r\n}\r\nskb_clear_hash(skb);\r\nreturn 0;\r\n}\r\nstatic int set_tcp(struct sk_buff *skb, struct sw_flow_key *flow_key,\r\nconst struct ovs_key_tcp *key,\r\nconst struct ovs_key_tcp *mask)\r\n{\r\nstruct tcphdr *th;\r\n__be16 src, dst;\r\nint err;\r\nerr = skb_ensure_writable(skb, skb_transport_offset(skb) +\r\nsizeof(struct tcphdr));\r\nif (unlikely(err))\r\nreturn err;\r\nth = tcp_hdr(skb);\r\nsrc = MASKED(th->source, key->tcp_src, mask->tcp_src);\r\nif (likely(src != th->source)) {\r\nset_tp_port(skb, &th->source, src, &th->check);\r\nflow_key->tp.src = src;\r\n}\r\ndst = MASKED(th->dest, key->tcp_dst, mask->tcp_dst);\r\nif (likely(dst != th->dest)) {\r\nset_tp_port(skb, &th->dest, dst, &th->check);\r\nflow_key->tp.dst = dst;\r\n}\r\nskb_clear_hash(skb);\r\nreturn 0;\r\n}\r\nstatic int set_sctp(struct sk_buff *skb, struct sw_flow_key *flow_key,\r\nconst struct ovs_key_sctp *key,\r\nconst struct ovs_key_sctp *mask)\r\n{\r\nunsigned int sctphoff = skb_transport_offset(skb);\r\nstruct sctphdr *sh;\r\n__le32 old_correct_csum, new_csum, old_csum;\r\nint err;\r\nerr = skb_ensure_writable(skb, sctphoff + sizeof(struct sctphdr));\r\nif (unlikely(err))\r\nreturn err;\r\nsh = sctp_hdr(skb);\r\nold_csum = sh->checksum;\r\nold_correct_csum = sctp_compute_cksum(skb, sctphoff);\r\nsh->source = MASKED(sh->source, key->sctp_src, mask->sctp_src);\r\nsh->dest = MASKED(sh->dest, key->sctp_dst, mask->sctp_dst);\r\nnew_csum = sctp_compute_cksum(skb, sctphoff);\r\nsh->checksum = old_csum ^ old_correct_csum ^ new_csum;\r\nskb_clear_hash(skb);\r\nflow_key->tp.src = sh->source;\r\nflow_key->tp.dst = sh->dest;\r\nreturn 0;\r\n}\r\nstatic void do_output(struct datapath *dp, struct sk_buff *skb, int out_port)\r\n{\r\nstruct vport *vport = ovs_vport_rcu(dp, out_port);\r\nif (likely(vport))\r\novs_vport_send(vport, skb);\r\nelse\r\nkfree_skb(skb);\r\n}\r\nstatic int output_userspace(struct datapath *dp, struct sk_buff *skb,\r\nstruct sw_flow_key *key, const struct nlattr *attr)\r\n{\r\nstruct ovs_tunnel_info info;\r\nstruct dp_upcall_info upcall;\r\nconst struct nlattr *a;\r\nint rem;\r\nupcall.cmd = OVS_PACKET_CMD_ACTION;\r\nupcall.userdata = NULL;\r\nupcall.portid = 0;\r\nupcall.egress_tun_info = NULL;\r\nfor (a = nla_data(attr), rem = nla_len(attr); rem > 0;\r\na = nla_next(a, &rem)) {\r\nswitch (nla_type(a)) {\r\ncase OVS_USERSPACE_ATTR_USERDATA:\r\nupcall.userdata = a;\r\nbreak;\r\ncase OVS_USERSPACE_ATTR_PID:\r\nupcall.portid = nla_get_u32(a);\r\nbreak;\r\ncase OVS_USERSPACE_ATTR_EGRESS_TUN_PORT: {\r\nstruct vport *vport;\r\nvport = ovs_vport_rcu(dp, nla_get_u32(a));\r\nif (vport) {\r\nint err;\r\nerr = ovs_vport_get_egress_tun_info(vport, skb,\r\n&info);\r\nif (!err)\r\nupcall.egress_tun_info = &info;\r\n}\r\nbreak;\r\n}\r\n}\r\n}\r\nreturn ovs_dp_upcall(dp, skb, key, &upcall);\r\n}\r\nstatic int sample(struct datapath *dp, struct sk_buff *skb,\r\nstruct sw_flow_key *key, const struct nlattr *attr)\r\n{\r\nconst struct nlattr *acts_list = NULL;\r\nconst struct nlattr *a;\r\nint rem;\r\nfor (a = nla_data(attr), rem = nla_len(attr); rem > 0;\r\na = nla_next(a, &rem)) {\r\nswitch (nla_type(a)) {\r\ncase OVS_SAMPLE_ATTR_PROBABILITY:\r\nif (prandom_u32() >= nla_get_u32(a))\r\nreturn 0;\r\nbreak;\r\ncase OVS_SAMPLE_ATTR_ACTIONS:\r\nacts_list = a;\r\nbreak;\r\n}\r\n}\r\nrem = nla_len(acts_list);\r\na = nla_data(acts_list);\r\nif (unlikely(!rem))\r\nreturn 0;\r\nif (likely(nla_type(a) == OVS_ACTION_ATTR_USERSPACE &&\r\nnla_is_last(a, rem)))\r\nreturn output_userspace(dp, skb, key, a);\r\nskb = skb_clone(skb, GFP_ATOMIC);\r\nif (!skb)\r\nreturn 0;\r\nif (!add_deferred_actions(skb, key, a)) {\r\nif (net_ratelimit())\r\npr_warn("%s: deferred actions limit reached, dropping sample action\n",\r\novs_dp_name(dp));\r\nkfree_skb(skb);\r\n}\r\nreturn 0;\r\n}\r\nstatic void execute_hash(struct sk_buff *skb, struct sw_flow_key *key,\r\nconst struct nlattr *attr)\r\n{\r\nstruct ovs_action_hash *hash_act = nla_data(attr);\r\nu32 hash = 0;\r\nhash = skb_get_hash(skb);\r\nhash = jhash_1word(hash, hash_act->hash_basis);\r\nif (!hash)\r\nhash = 0x1;\r\nkey->ovs_flow_hash = hash;\r\n}\r\nstatic int execute_set_action(struct sk_buff *skb,\r\nstruct sw_flow_key *flow_key,\r\nconst struct nlattr *a)\r\n{\r\nif (nla_type(a) == OVS_KEY_ATTR_TUNNEL_INFO) {\r\nOVS_CB(skb)->egress_tun_info = nla_data(a);\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int execute_masked_set_action(struct sk_buff *skb,\r\nstruct sw_flow_key *flow_key,\r\nconst struct nlattr *a)\r\n{\r\nint err = 0;\r\nswitch (nla_type(a)) {\r\ncase OVS_KEY_ATTR_PRIORITY:\r\nSET_MASKED(skb->priority, nla_get_u32(a), *get_mask(a, u32 *));\r\nflow_key->phy.priority = skb->priority;\r\nbreak;\r\ncase OVS_KEY_ATTR_SKB_MARK:\r\nSET_MASKED(skb->mark, nla_get_u32(a), *get_mask(a, u32 *));\r\nflow_key->phy.skb_mark = skb->mark;\r\nbreak;\r\ncase OVS_KEY_ATTR_TUNNEL_INFO:\r\nerr = -EINVAL;\r\nbreak;\r\ncase OVS_KEY_ATTR_ETHERNET:\r\nerr = set_eth_addr(skb, flow_key, nla_data(a),\r\nget_mask(a, struct ovs_key_ethernet *));\r\nbreak;\r\ncase OVS_KEY_ATTR_IPV4:\r\nerr = set_ipv4(skb, flow_key, nla_data(a),\r\nget_mask(a, struct ovs_key_ipv4 *));\r\nbreak;\r\ncase OVS_KEY_ATTR_IPV6:\r\nerr = set_ipv6(skb, flow_key, nla_data(a),\r\nget_mask(a, struct ovs_key_ipv6 *));\r\nbreak;\r\ncase OVS_KEY_ATTR_TCP:\r\nerr = set_tcp(skb, flow_key, nla_data(a),\r\nget_mask(a, struct ovs_key_tcp *));\r\nbreak;\r\ncase OVS_KEY_ATTR_UDP:\r\nerr = set_udp(skb, flow_key, nla_data(a),\r\nget_mask(a, struct ovs_key_udp *));\r\nbreak;\r\ncase OVS_KEY_ATTR_SCTP:\r\nerr = set_sctp(skb, flow_key, nla_data(a),\r\nget_mask(a, struct ovs_key_sctp *));\r\nbreak;\r\ncase OVS_KEY_ATTR_MPLS:\r\nerr = set_mpls(skb, flow_key, nla_data(a), get_mask(a,\r\n__be32 *));\r\nbreak;\r\n}\r\nreturn err;\r\n}\r\nstatic int execute_recirc(struct datapath *dp, struct sk_buff *skb,\r\nstruct sw_flow_key *key,\r\nconst struct nlattr *a, int rem)\r\n{\r\nstruct deferred_action *da;\r\nif (!is_flow_key_valid(key)) {\r\nint err;\r\nerr = ovs_flow_key_update(skb, key);\r\nif (err)\r\nreturn err;\r\n}\r\nBUG_ON(!is_flow_key_valid(key));\r\nif (!nla_is_last(a, rem)) {\r\nskb = skb_clone(skb, GFP_ATOMIC);\r\nif (!skb)\r\nreturn 0;\r\n}\r\nda = add_deferred_actions(skb, key, NULL);\r\nif (da) {\r\nda->pkt_key.recirc_id = nla_get_u32(a);\r\n} else {\r\nkfree_skb(skb);\r\nif (net_ratelimit())\r\npr_warn("%s: deferred action limit reached, drop recirc action\n",\r\novs_dp_name(dp));\r\n}\r\nreturn 0;\r\n}\r\nstatic int do_execute_actions(struct datapath *dp, struct sk_buff *skb,\r\nstruct sw_flow_key *key,\r\nconst struct nlattr *attr, int len)\r\n{\r\nint prev_port = -1;\r\nconst struct nlattr *a;\r\nint rem;\r\nfor (a = attr, rem = len; rem > 0;\r\na = nla_next(a, &rem)) {\r\nint err = 0;\r\nif (unlikely(prev_port != -1)) {\r\nstruct sk_buff *out_skb = skb_clone(skb, GFP_ATOMIC);\r\nif (out_skb)\r\ndo_output(dp, out_skb, prev_port);\r\nprev_port = -1;\r\n}\r\nswitch (nla_type(a)) {\r\ncase OVS_ACTION_ATTR_OUTPUT:\r\nprev_port = nla_get_u32(a);\r\nbreak;\r\ncase OVS_ACTION_ATTR_USERSPACE:\r\noutput_userspace(dp, skb, key, a);\r\nbreak;\r\ncase OVS_ACTION_ATTR_HASH:\r\nexecute_hash(skb, key, a);\r\nbreak;\r\ncase OVS_ACTION_ATTR_PUSH_MPLS:\r\nerr = push_mpls(skb, key, nla_data(a));\r\nbreak;\r\ncase OVS_ACTION_ATTR_POP_MPLS:\r\nerr = pop_mpls(skb, key, nla_get_be16(a));\r\nbreak;\r\ncase OVS_ACTION_ATTR_PUSH_VLAN:\r\nerr = push_vlan(skb, key, nla_data(a));\r\nbreak;\r\ncase OVS_ACTION_ATTR_POP_VLAN:\r\nerr = pop_vlan(skb, key);\r\nbreak;\r\ncase OVS_ACTION_ATTR_RECIRC:\r\nerr = execute_recirc(dp, skb, key, a, rem);\r\nif (nla_is_last(a, rem)) {\r\nreturn err;\r\n}\r\nbreak;\r\ncase OVS_ACTION_ATTR_SET:\r\nerr = execute_set_action(skb, key, nla_data(a));\r\nbreak;\r\ncase OVS_ACTION_ATTR_SET_MASKED:\r\ncase OVS_ACTION_ATTR_SET_TO_MASKED:\r\nerr = execute_masked_set_action(skb, key, nla_data(a));\r\nbreak;\r\ncase OVS_ACTION_ATTR_SAMPLE:\r\nerr = sample(dp, skb, key, a);\r\nbreak;\r\n}\r\nif (unlikely(err)) {\r\nkfree_skb(skb);\r\nreturn err;\r\n}\r\n}\r\nif (prev_port != -1)\r\ndo_output(dp, skb, prev_port);\r\nelse\r\nconsume_skb(skb);\r\nreturn 0;\r\n}\r\nstatic void process_deferred_actions(struct datapath *dp)\r\n{\r\nstruct action_fifo *fifo = this_cpu_ptr(action_fifos);\r\nif (action_fifo_is_empty(fifo))\r\nreturn;\r\ndo {\r\nstruct deferred_action *da = action_fifo_get(fifo);\r\nstruct sk_buff *skb = da->skb;\r\nstruct sw_flow_key *key = &da->pkt_key;\r\nconst struct nlattr *actions = da->actions;\r\nif (actions)\r\ndo_execute_actions(dp, skb, key, actions,\r\nnla_len(actions));\r\nelse\r\novs_dp_process_packet(skb, key);\r\n} while (!action_fifo_is_empty(fifo));\r\naction_fifo_init(fifo);\r\n}\r\nint ovs_execute_actions(struct datapath *dp, struct sk_buff *skb,\r\nconst struct sw_flow_actions *acts,\r\nstruct sw_flow_key *key)\r\n{\r\nint level = this_cpu_read(exec_actions_level);\r\nint err;\r\nthis_cpu_inc(exec_actions_level);\r\nOVS_CB(skb)->egress_tun_info = NULL;\r\nerr = do_execute_actions(dp, skb, key,\r\nacts->actions, acts->actions_len);\r\nif (!level)\r\nprocess_deferred_actions(dp);\r\nthis_cpu_dec(exec_actions_level);\r\nreturn err;\r\n}\r\nint action_fifos_init(void)\r\n{\r\naction_fifos = alloc_percpu(struct action_fifo);\r\nif (!action_fifos)\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nvoid action_fifos_exit(void)\r\n{\r\nfree_percpu(action_fifos);\r\n}
