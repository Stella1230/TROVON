static void psb_driver_lastclose(struct drm_device *dev)\r\n{\r\nint ret;\r\nstruct drm_psb_private *dev_priv = dev->dev_private;\r\nstruct psb_fbdev *fbdev = dev_priv->fbdev;\r\nret = drm_fb_helper_restore_fbdev_mode_unlocked(&fbdev->psb_fb_helper);\r\nif (ret)\r\nDRM_DEBUG("failed to restore crtc mode\n");\r\nreturn;\r\n}\r\nstatic int psb_do_init(struct drm_device *dev)\r\n{\r\nstruct drm_psb_private *dev_priv = dev->dev_private;\r\nstruct psb_gtt *pg = &dev_priv->gtt;\r\nuint32_t stolen_gtt;\r\nif (pg->mmu_gatt_start & 0x0FFFFFFF) {\r\ndev_err(dev->dev, "Gatt must be 256M aligned. This is a bug.\n");\r\nreturn -EINVAL;\r\n}\r\nstolen_gtt = (pg->stolen_size >> PAGE_SHIFT) * 4;\r\nstolen_gtt = (stolen_gtt + PAGE_SIZE - 1) >> PAGE_SHIFT;\r\nstolen_gtt = (stolen_gtt < pg->gtt_pages) ? stolen_gtt : pg->gtt_pages;\r\ndev_priv->gatt_free_offset = pg->mmu_gatt_start +\r\n(stolen_gtt << PAGE_SHIFT) * 1024;\r\nspin_lock_init(&dev_priv->irqmask_lock);\r\nspin_lock_init(&dev_priv->lock_2d);\r\nPSB_WSGX32(0x00000000, PSB_CR_BIF_BANK0);\r\nPSB_WSGX32(0x00000000, PSB_CR_BIF_BANK1);\r\nPSB_RSGX32(PSB_CR_BIF_BANK1);\r\nPSB_WSGX32((PSB_RSGX32(PSB_CR_BIF_CTRL) & ~_PSB_MMU_ER_MASK),\r\nPSB_CR_BIF_CTRL);\r\nPSB_RSGX32(PSB_CR_BIF_CTRL);\r\npsb_spank(dev_priv);\r\nPSB_WSGX32(pg->gatt_start, PSB_CR_BIF_TWOD_REQ_BASE);\r\nPSB_RSGX32(PSB_CR_BIF_TWOD_REQ_BASE);\r\nreturn 0;\r\n}\r\nstatic int psb_driver_unload(struct drm_device *dev)\r\n{\r\nstruct drm_psb_private *dev_priv = dev->dev_private;\r\nif (dev_priv) {\r\nif (dev_priv->backlight_device)\r\ngma_backlight_exit(dev);\r\npsb_modeset_cleanup(dev);\r\nif (dev_priv->ops->chip_teardown)\r\ndev_priv->ops->chip_teardown(dev);\r\npsb_intel_opregion_fini(dev);\r\nif (dev_priv->pf_pd) {\r\npsb_mmu_free_pagedir(dev_priv->pf_pd);\r\ndev_priv->pf_pd = NULL;\r\n}\r\nif (dev_priv->mmu) {\r\nstruct psb_gtt *pg = &dev_priv->gtt;\r\ndown_read(&pg->sem);\r\npsb_mmu_remove_pfn_sequence(\r\npsb_mmu_get_default_pd\r\n(dev_priv->mmu),\r\npg->mmu_gatt_start,\r\ndev_priv->vram_stolen_size >> PAGE_SHIFT);\r\nup_read(&pg->sem);\r\npsb_mmu_driver_takedown(dev_priv->mmu);\r\ndev_priv->mmu = NULL;\r\n}\r\npsb_gtt_takedown(dev);\r\nif (dev_priv->scratch_page) {\r\nset_pages_wb(dev_priv->scratch_page, 1);\r\n__free_page(dev_priv->scratch_page);\r\ndev_priv->scratch_page = NULL;\r\n}\r\nif (dev_priv->vdc_reg) {\r\niounmap(dev_priv->vdc_reg);\r\ndev_priv->vdc_reg = NULL;\r\n}\r\nif (dev_priv->sgx_reg) {\r\niounmap(dev_priv->sgx_reg);\r\ndev_priv->sgx_reg = NULL;\r\n}\r\nif (dev_priv->aux_reg) {\r\niounmap(dev_priv->aux_reg);\r\ndev_priv->aux_reg = NULL;\r\n}\r\nif (dev_priv->aux_pdev)\r\npci_dev_put(dev_priv->aux_pdev);\r\nif (dev_priv->lpc_pdev)\r\npci_dev_put(dev_priv->lpc_pdev);\r\npsb_intel_destroy_bios(dev);\r\nkfree(dev_priv);\r\ndev->dev_private = NULL;\r\n}\r\ngma_power_uninit(dev);\r\nreturn 0;\r\n}\r\nstatic int psb_driver_load(struct drm_device *dev, unsigned long flags)\r\n{\r\nstruct drm_psb_private *dev_priv;\r\nunsigned long resource_start, resource_len;\r\nunsigned long irqflags;\r\nint ret = -ENOMEM;\r\nstruct drm_connector *connector;\r\nstruct gma_encoder *gma_encoder;\r\nstruct psb_gtt *pg;\r\ndev_priv = kzalloc(sizeof(*dev_priv), GFP_KERNEL);\r\nif (dev_priv == NULL)\r\nreturn -ENOMEM;\r\ndev_priv->ops = (struct psb_ops *)flags;\r\ndev_priv->dev = dev;\r\ndev->dev_private = (void *) dev_priv;\r\npg = &dev_priv->gtt;\r\npci_set_master(dev->pdev);\r\ndev_priv->num_pipe = dev_priv->ops->pipes;\r\nresource_start = pci_resource_start(dev->pdev, PSB_MMIO_RESOURCE);\r\ndev_priv->vdc_reg =\r\nioremap(resource_start + PSB_VDC_OFFSET, PSB_VDC_SIZE);\r\nif (!dev_priv->vdc_reg)\r\ngoto out_err;\r\ndev_priv->sgx_reg = ioremap(resource_start + dev_priv->ops->sgx_offset,\r\nPSB_SGX_SIZE);\r\nif (!dev_priv->sgx_reg)\r\ngoto out_err;\r\nif (IS_MRST(dev)) {\r\ndev_priv->aux_pdev = pci_get_bus_and_slot(0, PCI_DEVFN(3, 0));\r\nif (dev_priv->aux_pdev) {\r\nresource_start = pci_resource_start(dev_priv->aux_pdev,\r\nPSB_AUX_RESOURCE);\r\nresource_len = pci_resource_len(dev_priv->aux_pdev,\r\nPSB_AUX_RESOURCE);\r\ndev_priv->aux_reg = ioremap_nocache(resource_start,\r\nresource_len);\r\nif (!dev_priv->aux_reg)\r\ngoto out_err;\r\nDRM_DEBUG_KMS("Found aux vdc");\r\n} else {\r\ndev_priv->aux_reg = dev_priv->vdc_reg;\r\nDRM_DEBUG_KMS("Couldn't find aux pci device");\r\n}\r\ndev_priv->gmbus_reg = dev_priv->aux_reg;\r\ndev_priv->lpc_pdev = pci_get_bus_and_slot(0, PCI_DEVFN(31, 0));\r\nif (dev_priv->lpc_pdev) {\r\npci_read_config_word(dev_priv->lpc_pdev, PSB_LPC_GBA,\r\n&dev_priv->lpc_gpio_base);\r\npci_write_config_dword(dev_priv->lpc_pdev, PSB_LPC_GBA,\r\n(u32)dev_priv->lpc_gpio_base | (1L<<31));\r\npci_read_config_word(dev_priv->lpc_pdev, PSB_LPC_GBA,\r\n&dev_priv->lpc_gpio_base);\r\ndev_priv->lpc_gpio_base &= 0xffc0;\r\nif (dev_priv->lpc_gpio_base)\r\nDRM_DEBUG_KMS("Found LPC GPIO at 0x%04x\n",\r\ndev_priv->lpc_gpio_base);\r\nelse {\r\npci_dev_put(dev_priv->lpc_pdev);\r\ndev_priv->lpc_pdev = NULL;\r\n}\r\n}\r\n} else {\r\ndev_priv->gmbus_reg = dev_priv->vdc_reg;\r\n}\r\npsb_intel_opregion_setup(dev);\r\nret = dev_priv->ops->chip_setup(dev);\r\nif (ret)\r\ngoto out_err;\r\ngma_power_init(dev);\r\nret = -ENOMEM;\r\ndev_priv->scratch_page = alloc_page(GFP_DMA32 | __GFP_ZERO);\r\nif (!dev_priv->scratch_page)\r\ngoto out_err;\r\nset_pages_uc(dev_priv->scratch_page, 1);\r\nret = psb_gtt_init(dev, 0);\r\nif (ret)\r\ngoto out_err;\r\ndev_priv->mmu = psb_mmu_driver_init(dev, 1, 0, 0);\r\nif (!dev_priv->mmu)\r\ngoto out_err;\r\ndev_priv->pf_pd = psb_mmu_alloc_pd(dev_priv->mmu, 1, 0);\r\nif (!dev_priv->pf_pd)\r\ngoto out_err;\r\nret = psb_do_init(dev);\r\nif (ret)\r\nreturn ret;\r\ndown_read(&pg->sem);\r\nret = psb_mmu_insert_pfn_sequence(psb_mmu_get_default_pd(dev_priv->mmu),\r\ndev_priv->stolen_base >> PAGE_SHIFT,\r\npg->gatt_start,\r\npg->stolen_size >> PAGE_SHIFT, 0);\r\nup_read(&pg->sem);\r\npsb_mmu_set_pd_context(psb_mmu_get_default_pd(dev_priv->mmu), 0);\r\npsb_mmu_set_pd_context(dev_priv->pf_pd, 1);\r\nPSB_WSGX32(0x20000000, PSB_CR_PDS_EXEC_BASE);\r\nPSB_WSGX32(0x30000000, PSB_CR_BIF_3D_REQ_BASE);\r\nacpi_video_register();\r\nret = drm_vblank_init(dev, dev_priv->num_pipe);\r\nif (ret)\r\ngoto out_err;\r\ndev_priv->vdc_irq_mask = 0;\r\ndev_priv->pipestat[0] = 0;\r\ndev_priv->pipestat[1] = 0;\r\ndev_priv->pipestat[2] = 0;\r\nspin_lock_irqsave(&dev_priv->irqmask_lock, irqflags);\r\nPSB_WVDC32(0xFFFFFFFF, PSB_HWSTAM);\r\nPSB_WVDC32(0x00000000, PSB_INT_ENABLE_R);\r\nPSB_WVDC32(0xFFFFFFFF, PSB_INT_MASK_R);\r\nspin_unlock_irqrestore(&dev_priv->irqmask_lock, irqflags);\r\ndrm_irq_install(dev, dev->pdev->irq);\r\ndev->vblank_disable_allowed = true;\r\ndev->max_vblank_count = 0xffffff;\r\ndev->driver->get_vblank_counter = psb_get_vblank_counter;\r\npsb_modeset_init(dev);\r\npsb_fbdev_init(dev);\r\ndrm_kms_helper_poll_init(dev);\r\nlist_for_each_entry(connector, &dev->mode_config.connector_list,\r\nhead) {\r\ngma_encoder = gma_attached_encoder(connector);\r\nswitch (gma_encoder->type) {\r\ncase INTEL_OUTPUT_LVDS:\r\ncase INTEL_OUTPUT_MIPI:\r\nret = gma_backlight_init(dev);\r\nbreak;\r\n}\r\n}\r\nif (ret)\r\nreturn ret;\r\npsb_intel_opregion_enable_asle(dev);\r\n#if 0\r\npm_runtime_enable(&dev->pdev->dev);\r\npm_runtime_set_active(&dev->pdev->dev);\r\n#endif\r\nreturn 0;\r\nout_err:\r\npsb_driver_unload(dev);\r\nreturn ret;\r\n}\r\nstatic int psb_driver_device_is_agp(struct drm_device *dev)\r\n{\r\nreturn 0;\r\n}\r\nstatic inline void get_brightness(struct backlight_device *bd)\r\n{\r\n#ifdef CONFIG_BACKLIGHT_CLASS_DEVICE\r\nif (bd) {\r\nbd->props.brightness = bd->ops->get_brightness(bd);\r\nbacklight_update_status(bd);\r\n}\r\n#endif\r\n}\r\nstatic long psb_unlocked_ioctl(struct file *filp, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\nstruct drm_file *file_priv = filp->private_data;\r\nstruct drm_device *dev = file_priv->minor->dev;\r\nstruct drm_psb_private *dev_priv = dev->dev_private;\r\nstatic unsigned int runtime_allowed;\r\nif (runtime_allowed == 1 && dev_priv->is_lvds_on) {\r\nruntime_allowed++;\r\npm_runtime_allow(&dev->pdev->dev);\r\ndev_priv->rpm_enabled = 1;\r\n}\r\nreturn drm_ioctl(filp, cmd, arg);\r\n}\r\nstatic void psb_driver_preclose(struct drm_device *dev, struct drm_file *priv)\r\n{\r\n}\r\nstatic int psb_pci_probe(struct pci_dev *pdev, const struct pci_device_id *ent)\r\n{\r\nreturn drm_get_pci_dev(pdev, ent, &driver);\r\n}\r\nstatic void psb_pci_remove(struct pci_dev *pdev)\r\n{\r\nstruct drm_device *dev = pci_get_drvdata(pdev);\r\ndrm_put_dev(dev);\r\n}\r\nstatic int __init psb_init(void)\r\n{\r\nreturn drm_pci_init(&driver, &psb_pci_driver);\r\n}\r\nstatic void __exit psb_exit(void)\r\n{\r\ndrm_pci_exit(&driver, &psb_pci_driver);\r\n}
