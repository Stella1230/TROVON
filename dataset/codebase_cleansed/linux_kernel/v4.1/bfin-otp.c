static ssize_t bfin_otp_read(struct file *file, char __user *buff, size_t count, loff_t *pos)\r\n{\r\nssize_t bytes_done;\r\nu32 page, flags, ret;\r\nu64 content;\r\nstampit();\r\nif (count % sizeof(u64))\r\nreturn -EMSGSIZE;\r\nif (mutex_lock_interruptible(&bfin_otp_lock))\r\nreturn -ERESTARTSYS;\r\nbytes_done = 0;\r\npage = *pos / (sizeof(u64) * 2);\r\nwhile (bytes_done < count) {\r\nflags = (*pos % (sizeof(u64) * 2) ? OTP_UPPER_HALF : OTP_LOWER_HALF);\r\nstamp("processing page %i (0x%x:%s)", page, flags,\r\n(flags & OTP_UPPER_HALF ? "upper" : "lower"));\r\nret = bfrom_OtpRead(page, flags, &content);\r\nif (ret & OTP_MASTER_ERROR) {\r\nstamp("error from otp: 0x%x", ret);\r\nbytes_done = -EIO;\r\nbreak;\r\n}\r\nif (copy_to_user(buff + bytes_done, &content, sizeof(content))) {\r\nbytes_done = -EFAULT;\r\nbreak;\r\n}\r\nif (flags & OTP_UPPER_HALF)\r\n++page;\r\nbytes_done += sizeof(content);\r\n*pos += sizeof(content);\r\n}\r\nmutex_unlock(&bfin_otp_lock);\r\nreturn bytes_done;\r\n}\r\nstatic u32 bfin_otp_init_timing(void)\r\n{\r\nu32 tp1, tp2, tp3, timing;\r\ntp1 = get_sclk() / 1000000;\r\ntp2 = (2 * get_sclk() / 10000000) << 8;\r\ntp3 = (0x1401) << 15;\r\ntiming = tp1 | tp2 | tp3;\r\nif (bfrom_OtpCommand(OTP_INIT, timing))\r\nreturn 0;\r\nreturn timing;\r\n}\r\nstatic void bfin_otp_deinit_timing(u32 timing)\r\n{\r\nbfrom_OtpCommand(OTP_CLOSE, 0);\r\nbfrom_OtpCommand(OTP_INIT, timing & ~(-1 << 15));\r\nbfrom_OtpCommand(OTP_CLOSE, 0);\r\n}\r\nstatic ssize_t bfin_otp_write(struct file *filp, const char __user *buff, size_t count, loff_t *pos)\r\n{\r\nssize_t bytes_done;\r\nu32 timing, page, base_flags, flags, ret;\r\nu64 content;\r\nif (!allow_writes)\r\nreturn -EACCES;\r\nif (count % sizeof(u64))\r\nreturn -EMSGSIZE;\r\nif (mutex_lock_interruptible(&bfin_otp_lock))\r\nreturn -ERESTARTSYS;\r\nstampit();\r\ntiming = bfin_otp_init_timing();\r\nif (timing == 0) {\r\nmutex_unlock(&bfin_otp_lock);\r\nreturn -EIO;\r\n}\r\nbase_flags = OTP_CHECK_FOR_PREV_WRITE;\r\nbytes_done = 0;\r\npage = *pos / (sizeof(u64) * 2);\r\nwhile (bytes_done < count) {\r\nflags = base_flags | (*pos % (sizeof(u64) * 2) ? OTP_UPPER_HALF : OTP_LOWER_HALF);\r\nstamp("processing page %i (0x%x:%s) from %p", page, flags,\r\n(flags & OTP_UPPER_HALF ? "upper" : "lower"), buff + bytes_done);\r\nif (copy_from_user(&content, buff + bytes_done, sizeof(content))) {\r\nbytes_done = -EFAULT;\r\nbreak;\r\n}\r\nret = bfrom_OtpWrite(page, flags, &content);\r\nif (ret & OTP_MASTER_ERROR) {\r\nstamp("error from otp: 0x%x", ret);\r\nbytes_done = -EIO;\r\nbreak;\r\n}\r\nif (flags & OTP_UPPER_HALF)\r\n++page;\r\nbytes_done += sizeof(content);\r\n*pos += sizeof(content);\r\n}\r\nbfin_otp_deinit_timing(timing);\r\nmutex_unlock(&bfin_otp_lock);\r\nreturn bytes_done;\r\n}\r\nstatic long bfin_otp_ioctl(struct file *filp, unsigned cmd, unsigned long arg)\r\n{\r\nstampit();\r\nswitch (cmd) {\r\ncase OTPLOCK: {\r\nu32 timing;\r\nint ret = -EIO;\r\nif (!allow_writes)\r\nreturn -EACCES;\r\nif (mutex_lock_interruptible(&bfin_otp_lock))\r\nreturn -ERESTARTSYS;\r\ntiming = bfin_otp_init_timing();\r\nif (timing) {\r\nu32 otp_result = bfrom_OtpWrite(arg, OTP_LOCK, NULL);\r\nstamp("locking page %lu resulted in 0x%x", arg, otp_result);\r\nif (!(otp_result & OTP_MASTER_ERROR))\r\nret = 0;\r\nbfin_otp_deinit_timing(timing);\r\n}\r\nmutex_unlock(&bfin_otp_lock);\r\nreturn ret;\r\n}\r\ncase MEMLOCK:\r\nallow_writes = false;\r\nreturn 0;\r\ncase MEMUNLOCK:\r\nallow_writes = true;\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int __init bfin_otp_init(void)\r\n{\r\nint ret;\r\nstampit();\r\nret = misc_register(&bfin_otp_misc_device);\r\nif (ret) {\r\npr_init(KERN_ERR PFX "unable to register a misc device\n");\r\nreturn ret;\r\n}\r\npr_init(KERN_INFO PFX "initialized\n");\r\nreturn 0;\r\n}\r\nstatic void __exit bfin_otp_exit(void)\r\n{\r\nstampit();\r\nmisc_deregister(&bfin_otp_misc_device);\r\n}
