static inline void set_scan_rate(struct synaptics_i2c *touch, int scan_rate)\r\n{\r\ntouch->scan_ms = MSEC_PER_SEC / scan_rate;\r\ntouch->scan_rate_param = scan_rate;\r\n}\r\nstatic s32 synaptics_i2c_reg_get(struct i2c_client *client, u16 reg)\r\n{\r\nint ret;\r\nret = i2c_smbus_write_byte_data(client, PAGE_SEL_REG, reg >> 8);\r\nif (ret == 0)\r\nret = i2c_smbus_read_byte_data(client, reg & 0xff);\r\nreturn ret;\r\n}\r\nstatic s32 synaptics_i2c_reg_set(struct i2c_client *client, u16 reg, u8 val)\r\n{\r\nint ret;\r\nret = i2c_smbus_write_byte_data(client, PAGE_SEL_REG, reg >> 8);\r\nif (ret == 0)\r\nret = i2c_smbus_write_byte_data(client, reg & 0xff, val);\r\nreturn ret;\r\n}\r\nstatic s32 synaptics_i2c_word_get(struct i2c_client *client, u16 reg)\r\n{\r\nint ret;\r\nret = i2c_smbus_write_byte_data(client, PAGE_SEL_REG, reg >> 8);\r\nif (ret == 0)\r\nret = i2c_smbus_read_word_data(client, reg & 0xff);\r\nreturn ret;\r\n}\r\nstatic int synaptics_i2c_config(struct i2c_client *client)\r\n{\r\nint ret, control;\r\nu8 int_en;\r\nret = synaptics_i2c_reg_set(client, DEV_CONTROL_REG, 0xc1);\r\nif (ret)\r\nreturn ret;\r\nint_en = (polling_req) ? 0 : INT_ENA_ABS_MSK | INT_ENA_REL_MSK;\r\nret = synaptics_i2c_reg_set(client, INTERRUPT_EN_REG, int_en);\r\nif (ret)\r\nreturn ret;\r\ncontrol = synaptics_i2c_reg_get(client, GENERAL_2D_CONTROL_REG);\r\ncontrol |= no_decel ? 1 << NO_DECELERATION : 0;\r\ncontrol |= reduce_report ? 1 << REDUCE_REPORTING : 0;\r\ncontrol |= no_filter ? 1 << NO_FILTER : 0;\r\nret = synaptics_i2c_reg_set(client, GENERAL_2D_CONTROL_REG, control);\r\nif (ret)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nstatic int synaptics_i2c_reset_config(struct i2c_client *client)\r\n{\r\nint ret;\r\nret = synaptics_i2c_reg_set(client, DEV_COMMAND_REG, RESET_COMMAND);\r\nif (ret) {\r\ndev_err(&client->dev, "Unable to reset device\n");\r\n} else {\r\nmsleep(SOFT_RESET_DELAY_MS);\r\nret = synaptics_i2c_config(client);\r\nif (ret)\r\ndev_err(&client->dev, "Unable to config device\n");\r\n}\r\nreturn ret;\r\n}\r\nstatic int synaptics_i2c_check_error(struct i2c_client *client)\r\n{\r\nint status, ret = 0;\r\nstatus = i2c_smbus_read_byte_data(client, DEVICE_STATUS_REG) &\r\n(CONFIGURED_MSK | ERROR_MSK);\r\nif (status != CONFIGURED_MSK)\r\nret = synaptics_i2c_reset_config(client);\r\nreturn ret;\r\n}\r\nstatic bool synaptics_i2c_get_input(struct synaptics_i2c *touch)\r\n{\r\nstruct input_dev *input = touch->input;\r\nint xy_delta, gesture;\r\ns32 data;\r\ns8 x_delta, y_delta;\r\nif (synaptics_i2c_check_error(touch->client))\r\nreturn 0;\r\ndata = synaptics_i2c_reg_get(touch->client, DATA_REG0);\r\ngesture = (data >> GESTURE) & 0x1;\r\nxy_delta = synaptics_i2c_word_get(touch->client, REL_X_REG) & 0xffff;\r\nx_delta = xy_delta & 0xff;\r\ny_delta = (xy_delta >> REGISTER_LENGTH) & 0xff;\r\ninput_report_key(input, BTN_LEFT, gesture);\r\ninput_report_rel(input, REL_X, x_delta);\r\ninput_report_rel(input, REL_Y, -y_delta);\r\ninput_sync(input);\r\nreturn xy_delta || gesture;\r\n}\r\nstatic void synaptics_i2c_reschedule_work(struct synaptics_i2c *touch,\r\nunsigned long delay)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&touch->lock, flags);\r\nmod_delayed_work(system_wq, &touch->dwork, delay);\r\nspin_unlock_irqrestore(&touch->lock, flags);\r\n}\r\nstatic irqreturn_t synaptics_i2c_irq(int irq, void *dev_id)\r\n{\r\nstruct synaptics_i2c *touch = dev_id;\r\nsynaptics_i2c_reschedule_work(touch, 0);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void synaptics_i2c_check_params(struct synaptics_i2c *touch)\r\n{\r\nbool reset = false;\r\nif (scan_rate != touch->scan_rate_param)\r\nset_scan_rate(touch, scan_rate);\r\nif (no_decel != touch->no_decel_param) {\r\ntouch->no_decel_param = no_decel;\r\nreset = true;\r\n}\r\nif (no_filter != touch->no_filter_param) {\r\ntouch->no_filter_param = no_filter;\r\nreset = true;\r\n}\r\nif (reduce_report != touch->reduce_report_param) {\r\ntouch->reduce_report_param = reduce_report;\r\nreset = true;\r\n}\r\nif (reset)\r\nsynaptics_i2c_reset_config(touch->client);\r\n}\r\nstatic unsigned long synaptics_i2c_adjust_delay(struct synaptics_i2c *touch,\r\nbool have_data)\r\n{\r\nunsigned long delay, nodata_count_thres;\r\nif (polling_req) {\r\ndelay = touch->scan_ms;\r\nif (have_data) {\r\ntouch->no_data_count = 0;\r\n} else {\r\nnodata_count_thres = NO_DATA_THRES / touch->scan_ms;\r\nif (touch->no_data_count < nodata_count_thres)\r\ntouch->no_data_count++;\r\nelse\r\ndelay = NO_DATA_SLEEP_MSECS;\r\n}\r\nreturn msecs_to_jiffies(delay);\r\n} else {\r\ndelay = msecs_to_jiffies(THREAD_IRQ_SLEEP_MSECS);\r\nreturn round_jiffies_relative(delay);\r\n}\r\n}\r\nstatic void synaptics_i2c_work_handler(struct work_struct *work)\r\n{\r\nbool have_data;\r\nstruct synaptics_i2c *touch =\r\ncontainer_of(work, struct synaptics_i2c, dwork.work);\r\nunsigned long delay;\r\nsynaptics_i2c_check_params(touch);\r\nhave_data = synaptics_i2c_get_input(touch);\r\ndelay = synaptics_i2c_adjust_delay(touch, have_data);\r\nsynaptics_i2c_reschedule_work(touch, delay);\r\n}\r\nstatic int synaptics_i2c_open(struct input_dev *input)\r\n{\r\nstruct synaptics_i2c *touch = input_get_drvdata(input);\r\nint ret;\r\nret = synaptics_i2c_reset_config(touch->client);\r\nif (ret)\r\nreturn ret;\r\nif (polling_req)\r\nsynaptics_i2c_reschedule_work(touch,\r\nmsecs_to_jiffies(NO_DATA_SLEEP_MSECS));\r\nreturn 0;\r\n}\r\nstatic void synaptics_i2c_close(struct input_dev *input)\r\n{\r\nstruct synaptics_i2c *touch = input_get_drvdata(input);\r\nif (!polling_req)\r\nsynaptics_i2c_reg_set(touch->client, INTERRUPT_EN_REG, 0);\r\ncancel_delayed_work_sync(&touch->dwork);\r\nsynaptics_i2c_reg_set(touch->client, DEV_CONTROL_REG, DEEP_SLEEP);\r\n}\r\nstatic void synaptics_i2c_set_input_params(struct synaptics_i2c *touch)\r\n{\r\nstruct input_dev *input = touch->input;\r\ninput->name = touch->client->name;\r\ninput->phys = touch->client->adapter->name;\r\ninput->id.bustype = BUS_I2C;\r\ninput->id.version = synaptics_i2c_word_get(touch->client,\r\nINFO_QUERY_REG0);\r\ninput->dev.parent = &touch->client->dev;\r\ninput->open = synaptics_i2c_open;\r\ninput->close = synaptics_i2c_close;\r\ninput_set_drvdata(input, touch);\r\n__set_bit(EV_REL, input->evbit);\r\n__set_bit(REL_X, input->relbit);\r\n__set_bit(REL_Y, input->relbit);\r\n__set_bit(EV_KEY, input->evbit);\r\n__set_bit(BTN_LEFT, input->keybit);\r\n}\r\nstatic struct synaptics_i2c *synaptics_i2c_touch_create(struct i2c_client *client)\r\n{\r\nstruct synaptics_i2c *touch;\r\ntouch = kzalloc(sizeof(struct synaptics_i2c), GFP_KERNEL);\r\nif (!touch)\r\nreturn NULL;\r\ntouch->client = client;\r\ntouch->no_decel_param = no_decel;\r\ntouch->scan_rate_param = scan_rate;\r\nset_scan_rate(touch, scan_rate);\r\nINIT_DELAYED_WORK(&touch->dwork, synaptics_i2c_work_handler);\r\nspin_lock_init(&touch->lock);\r\nreturn touch;\r\n}\r\nstatic int synaptics_i2c_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *dev_id)\r\n{\r\nint ret;\r\nstruct synaptics_i2c *touch;\r\ntouch = synaptics_i2c_touch_create(client);\r\nif (!touch)\r\nreturn -ENOMEM;\r\nret = synaptics_i2c_reset_config(client);\r\nif (ret)\r\ngoto err_mem_free;\r\nif (client->irq < 1)\r\npolling_req = true;\r\ntouch->input = input_allocate_device();\r\nif (!touch->input) {\r\nret = -ENOMEM;\r\ngoto err_mem_free;\r\n}\r\nsynaptics_i2c_set_input_params(touch);\r\nif (!polling_req) {\r\ndev_dbg(&touch->client->dev,\r\n"Requesting IRQ: %d\n", touch->client->irq);\r\nret = request_irq(touch->client->irq, synaptics_i2c_irq,\r\nIRQ_TYPE_EDGE_FALLING,\r\nDRIVER_NAME, touch);\r\nif (ret) {\r\ndev_warn(&touch->client->dev,\r\n"IRQ request failed: %d, "\r\n"falling back to polling\n", ret);\r\npolling_req = true;\r\nsynaptics_i2c_reg_set(touch->client,\r\nINTERRUPT_EN_REG, 0);\r\n}\r\n}\r\nif (polling_req)\r\ndev_dbg(&touch->client->dev,\r\n"Using polling at rate: %d times/sec\n", scan_rate);\r\nret = input_register_device(touch->input);\r\nif (ret) {\r\ndev_err(&client->dev,\r\n"Input device register failed: %d\n", ret);\r\ngoto err_input_free;\r\n}\r\ni2c_set_clientdata(client, touch);\r\nreturn 0;\r\nerr_input_free:\r\ninput_free_device(touch->input);\r\nerr_mem_free:\r\nkfree(touch);\r\nreturn ret;\r\n}\r\nstatic int synaptics_i2c_remove(struct i2c_client *client)\r\n{\r\nstruct synaptics_i2c *touch = i2c_get_clientdata(client);\r\nif (!polling_req)\r\nfree_irq(client->irq, touch);\r\ninput_unregister_device(touch->input);\r\nkfree(touch);\r\nreturn 0;\r\n}\r\nstatic int __maybe_unused synaptics_i2c_suspend(struct device *dev)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct synaptics_i2c *touch = i2c_get_clientdata(client);\r\ncancel_delayed_work_sync(&touch->dwork);\r\nsynaptics_i2c_reg_set(touch->client, DEV_CONTROL_REG, DEEP_SLEEP);\r\nreturn 0;\r\n}\r\nstatic int __maybe_unused synaptics_i2c_resume(struct device *dev)\r\n{\r\nint ret;\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct synaptics_i2c *touch = i2c_get_clientdata(client);\r\nret = synaptics_i2c_reset_config(client);\r\nif (ret)\r\nreturn ret;\r\nsynaptics_i2c_reschedule_work(touch,\r\nmsecs_to_jiffies(NO_DATA_SLEEP_MSECS));\r\nreturn 0;\r\n}
