static void ia_init_rtn_q (IARTN_Q *que)\r\n{\r\nque->next = NULL;\r\nque->tail = NULL;\r\n}\r\nstatic void ia_enque_head_rtn_q (IARTN_Q *que, IARTN_Q * data)\r\n{\r\ndata->next = NULL;\r\nif (que->next == NULL)\r\nque->next = que->tail = data;\r\nelse {\r\ndata->next = que->next;\r\nque->next = data;\r\n}\r\nreturn;\r\n}\r\nstatic int ia_enque_rtn_q (IARTN_Q *que, struct desc_tbl_t data) {\r\nIARTN_Q *entry = kmalloc(sizeof(*entry), GFP_ATOMIC);\r\nif (!entry) return -1;\r\nentry->data = data;\r\nentry->next = NULL;\r\nif (que->next == NULL)\r\nque->next = que->tail = entry;\r\nelse {\r\nque->tail->next = entry;\r\nque->tail = que->tail->next;\r\n}\r\nreturn 1;\r\n}\r\nstatic IARTN_Q * ia_deque_rtn_q (IARTN_Q *que) {\r\nIARTN_Q *tmpdata;\r\nif (que->next == NULL)\r\nreturn NULL;\r\ntmpdata = que->next;\r\nif ( que->next == que->tail)\r\nque->next = que->tail = NULL;\r\nelse\r\nque->next = que->next->next;\r\nreturn tmpdata;\r\n}\r\nstatic void ia_hack_tcq(IADEV *dev) {\r\nu_short desc1;\r\nu_short tcq_wr;\r\nstruct ia_vcc *iavcc_r = NULL;\r\ntcq_wr = readl(dev->seg_reg+TCQ_WR_PTR) & 0xffff;\r\nwhile (dev->host_tcq_wr != tcq_wr) {\r\ndesc1 = *(u_short *)(dev->seg_ram + dev->host_tcq_wr);\r\nif (!desc1) ;\r\nelse if (!dev->desc_tbl[desc1 -1].timestamp) {\r\nIF_ABR(printk(" Desc %d is reset at %ld\n", desc1 -1, jiffies);)\r\n*(u_short *) (dev->seg_ram + dev->host_tcq_wr) = 0;\r\n}\r\nelse if (dev->desc_tbl[desc1 -1].timestamp) {\r\nif (!(iavcc_r = dev->desc_tbl[desc1 -1].iavcc)) {\r\nprintk("IA: Fatal err in get_desc\n");\r\ncontinue;\r\n}\r\niavcc_r->vc_desc_cnt--;\r\ndev->desc_tbl[desc1 -1].timestamp = 0;\r\nIF_EVENT(printk("ia_hack: return_q skb = 0x%p desc = %d\n",\r\ndev->desc_tbl[desc1 -1].txskb, desc1);)\r\nif (iavcc_r->pcr < dev->rate_limit) {\r\nIA_SKB_STATE (dev->desc_tbl[desc1-1].txskb) |= IA_TX_DONE;\r\nif (ia_enque_rtn_q(&dev->tx_return_q, dev->desc_tbl[desc1 -1]) < 0)\r\nprintk("ia_hack_tcq: No memory available\n");\r\n}\r\ndev->desc_tbl[desc1 -1].iavcc = NULL;\r\ndev->desc_tbl[desc1 -1].txskb = NULL;\r\n}\r\ndev->host_tcq_wr += 2;\r\nif (dev->host_tcq_wr > dev->ffL.tcq_ed)\r\ndev->host_tcq_wr = dev->ffL.tcq_st;\r\n}\r\n}\r\nstatic u16 get_desc (IADEV *dev, struct ia_vcc *iavcc) {\r\nu_short desc_num, i;\r\nstruct sk_buff *skb;\r\nstruct ia_vcc *iavcc_r = NULL;\r\nunsigned long delta;\r\nstatic unsigned long timer = 0;\r\nint ltimeout;\r\nia_hack_tcq (dev);\r\nif((time_after(jiffies,timer+50)) || ((dev->ffL.tcq_rd==dev->host_tcq_wr))) {\r\ntimer = jiffies;\r\ni=0;\r\nwhile (i < dev->num_tx_desc) {\r\nif (!dev->desc_tbl[i].timestamp) {\r\ni++;\r\ncontinue;\r\n}\r\nltimeout = dev->desc_tbl[i].iavcc->ltimeout;\r\ndelta = jiffies - dev->desc_tbl[i].timestamp;\r\nif (delta >= ltimeout) {\r\nIF_ABR(printk("RECOVER run!! desc_tbl %d = %d delta = %ld, time = %ld\n", i,dev->desc_tbl[i].timestamp, delta, jiffies);)\r\nif (dev->ffL.tcq_rd == dev->ffL.tcq_st)\r\ndev->ffL.tcq_rd = dev->ffL.tcq_ed;\r\nelse\r\ndev->ffL.tcq_rd -= 2;\r\n*(u_short *)(dev->seg_ram + dev->ffL.tcq_rd) = i+1;\r\nif (!(skb = dev->desc_tbl[i].txskb) ||\r\n!(iavcc_r = dev->desc_tbl[i].iavcc))\r\nprintk("Fatal err, desc table vcc or skb is NULL\n");\r\nelse\r\niavcc_r->vc_desc_cnt--;\r\ndev->desc_tbl[i].timestamp = 0;\r\ndev->desc_tbl[i].iavcc = NULL;\r\ndev->desc_tbl[i].txskb = NULL;\r\n}\r\ni++;\r\n}\r\n}\r\nif (dev->ffL.tcq_rd == dev->host_tcq_wr)\r\nreturn 0xFFFF;\r\ndesc_num = *(u_short *)(dev->seg_ram + dev->ffL.tcq_rd);\r\nwhile (!desc_num || (dev->desc_tbl[desc_num -1]).timestamp) {\r\ndev->ffL.tcq_rd += 2;\r\nif (dev->ffL.tcq_rd > dev->ffL.tcq_ed)\r\ndev->ffL.tcq_rd = dev->ffL.tcq_st;\r\nif (dev->ffL.tcq_rd == dev->host_tcq_wr)\r\nreturn 0xFFFF;\r\ndesc_num = *(u_short *)(dev->seg_ram + dev->ffL.tcq_rd);\r\n}\r\ndev->desc_tbl[desc_num -1].timestamp = jiffies;\r\nreturn desc_num;\r\n}\r\nstatic void clear_lockup (struct atm_vcc *vcc, IADEV *dev) {\r\nu_char foundLockUp;\r\nvcstatus_t *vcstatus;\r\nu_short *shd_tbl;\r\nu_short tempCellSlot, tempFract;\r\nstruct main_vc *abr_vc = (struct main_vc *)dev->MAIN_VC_TABLE_ADDR;\r\nstruct ext_vc *eabr_vc = (struct ext_vc *)dev->EXT_VC_TABLE_ADDR;\r\nu_int i;\r\nif (vcc->qos.txtp.traffic_class == ATM_ABR) {\r\nvcstatus = (vcstatus_t *) &(dev->testTable[vcc->vci]->vc_status);\r\nvcstatus->cnt++;\r\nfoundLockUp = 0;\r\nif( vcstatus->cnt == 0x05 ) {\r\nabr_vc += vcc->vci;\r\neabr_vc += vcc->vci;\r\nif( eabr_vc->last_desc ) {\r\nif( (abr_vc->status & 0x07) == ABR_STATE ) {\r\nudelay(10);\r\nif ((eabr_vc->last_desc)&&((abr_vc->status & 0x07)==ABR_STATE))\r\nfoundLockUp = 1;\r\n}\r\nelse {\r\ntempCellSlot = abr_vc->last_cell_slot;\r\ntempFract = abr_vc->fraction;\r\nif((tempCellSlot == dev->testTable[vcc->vci]->lastTime)\r\n&& (tempFract == dev->testTable[vcc->vci]->fract))\r\nfoundLockUp = 1;\r\ndev->testTable[vcc->vci]->lastTime = tempCellSlot;\r\ndev->testTable[vcc->vci]->fract = tempFract;\r\n}\r\n}\r\nvcstatus->cnt = 0;\r\n}\r\nif (foundLockUp) {\r\nIF_ABR(printk("LOCK UP found\n");)\r\nwritew(0xFFFD, dev->seg_reg+MODE_REG_0);\r\nudelay(10);\r\nabr_vc->status &= 0xFFF8;\r\nabr_vc->status |= 0x0001;\r\nshd_tbl = (u_short *)dev->ABR_SCHED_TABLE_ADDR;\r\nfor( i = 0; ((i < dev->num_vc) && (shd_tbl[i])); i++ );\r\nif (i < dev->num_vc)\r\nshd_tbl[i] = vcc->vci;\r\nelse\r\nIF_ERR(printk("ABR Seg. may not continue on VC %x\n",vcc->vci);)\r\nwritew(T_ONLINE, dev->seg_reg+MODE_REG_0);\r\nwritew(~(TRANSMIT_DONE|TCQ_NOT_EMPTY), dev->seg_reg+SEG_MASK_REG);\r\nwritew(TRANSMIT_DONE, dev->seg_reg+SEG_INTR_STATUS_REG);\r\nvcstatus->cnt = 0;\r\n}\r\n}\r\n}\r\nstatic u16\r\ncellrate_to_float(u32 cr)\r\n{\r\n#define NZ 0x4000\r\n#define M_BITS 9\r\n#define E_BITS 5\r\n#define M_MASK 0x1ff\r\n#define E_MASK 0x1f\r\nu16 flot;\r\nu32 tmp = cr & 0x00ffffff;\r\nint i = 0;\r\nif (cr == 0)\r\nreturn 0;\r\nwhile (tmp != 1) {\r\ntmp >>= 1;\r\ni++;\r\n}\r\nif (i == M_BITS)\r\nflot = NZ | (i << M_BITS) | (cr & M_MASK);\r\nelse if (i < M_BITS)\r\nflot = NZ | (i << M_BITS) | ((cr << (M_BITS - i)) & M_MASK);\r\nelse\r\nflot = NZ | (i << M_BITS) | ((cr >> (i - M_BITS)) & M_MASK);\r\nreturn flot;\r\n}\r\nstatic void init_abr_vc (IADEV *dev, srv_cls_param_t *srv_p) {\r\nsrv_p->class_type = ATM_ABR;\r\nsrv_p->pcr = dev->LineRate;\r\nsrv_p->mcr = 0;\r\nsrv_p->icr = 0x055cb7;\r\nsrv_p->tbe = 0xffffff;\r\nsrv_p->frtt = 0x3a;\r\nsrv_p->rif = 0xf;\r\nsrv_p->rdf = 0xb;\r\nsrv_p->nrm = 0x4;\r\nsrv_p->trm = 0x7;\r\nsrv_p->cdf = 0x3;\r\nsrv_p->adtf = 50;\r\n}\r\nstatic int\r\nia_open_abr_vc(IADEV *dev, srv_cls_param_t *srv_p,\r\nstruct atm_vcc *vcc, u8 flag)\r\n{\r\nf_vc_abr_entry *f_abr_vc;\r\nr_vc_abr_entry *r_abr_vc;\r\nu32 icr;\r\nu8 trm, nrm, crm;\r\nu16 adtf, air, *ptr16;\r\nf_abr_vc =(f_vc_abr_entry *)dev->MAIN_VC_TABLE_ADDR;\r\nf_abr_vc += vcc->vci;\r\nswitch (flag) {\r\ncase 1:\r\n#if 0\r\nif (srv_p->pcr == 0)\r\nreturn INVALID_PCR;\r\nif (srv_p->pcr > dev->LineRate)\r\nsrv_p->pcr = dev->LineRate;\r\nif ((srv_p->mcr + dev->sum_mcr) > dev->LineRate)\r\nreturn MCR_UNAVAILABLE;\r\nif (srv_p->mcr > srv_p->pcr)\r\nreturn INVALID_MCR;\r\nif (!(srv_p->icr))\r\nsrv_p->icr = srv_p->pcr;\r\nif ((srv_p->icr < srv_p->mcr) || (srv_p->icr > srv_p->pcr))\r\nreturn INVALID_ICR;\r\nif ((srv_p->tbe < MIN_TBE) || (srv_p->tbe > MAX_TBE))\r\nreturn INVALID_TBE;\r\nif ((srv_p->frtt < MIN_FRTT) || (srv_p->frtt > MAX_FRTT))\r\nreturn INVALID_FRTT;\r\nif (srv_p->nrm > MAX_NRM)\r\nreturn INVALID_NRM;\r\nif (srv_p->trm > MAX_TRM)\r\nreturn INVALID_TRM;\r\nif (srv_p->adtf > MAX_ADTF)\r\nreturn INVALID_ADTF;\r\nelse if (srv_p->adtf == 0)\r\nsrv_p->adtf = 1;\r\nif (srv_p->cdf > MAX_CDF)\r\nreturn INVALID_CDF;\r\nif (srv_p->rif > MAX_RIF)\r\nreturn INVALID_RIF;\r\nif (srv_p->rdf > MAX_RDF)\r\nreturn INVALID_RDF;\r\n#endif\r\nmemset ((caddr_t)f_abr_vc, 0, sizeof(*f_abr_vc));\r\nf_abr_vc->f_vc_type = ABR;\r\nnrm = 2 << srv_p->nrm;\r\nf_abr_vc->f_nrm = nrm << 8 | nrm;\r\ntrm = 100000/(2 << (16 - srv_p->trm));\r\nif ( trm == 0) trm = 1;\r\nf_abr_vc->f_nrmexp =(((srv_p->nrm +1) & 0x0f) << 12)|(MRM << 8) | trm;\r\ncrm = srv_p->tbe / nrm;\r\nif (crm == 0) crm = 1;\r\nf_abr_vc->f_crm = crm & 0xff;\r\nf_abr_vc->f_pcr = cellrate_to_float(srv_p->pcr);\r\nicr = min( srv_p->icr, (srv_p->tbe > srv_p->frtt) ?\r\n((srv_p->tbe/srv_p->frtt)*1000000) :\r\n(1000000/(srv_p->frtt/srv_p->tbe)));\r\nf_abr_vc->f_icr = cellrate_to_float(icr);\r\nadtf = (10000 * srv_p->adtf)/8192;\r\nif (adtf == 0) adtf = 1;\r\nf_abr_vc->f_cdf = ((7 - srv_p->cdf) << 12 | adtf) & 0xfff;\r\nf_abr_vc->f_mcr = cellrate_to_float(srv_p->mcr);\r\nf_abr_vc->f_acr = f_abr_vc->f_icr;\r\nf_abr_vc->f_status = 0x0042;\r\nbreak;\r\ncase 0:\r\nptr16 = (u_short *)(dev->reass_ram + REASS_TABLE*dev->memSize);\r\n*(ptr16 + vcc->vci) = NO_AAL5_PKT | REASS_ABR;\r\nr_abr_vc = (r_vc_abr_entry*)(dev->reass_ram+ABR_VC_TABLE*dev->memSize);\r\nr_abr_vc += vcc->vci;\r\nr_abr_vc->r_status_rdf = (15 - srv_p->rdf) & 0x000f;\r\nair = srv_p->pcr << (15 - srv_p->rif);\r\nif (air == 0) air = 1;\r\nr_abr_vc->r_air = cellrate_to_float(air);\r\ndev->testTable[vcc->vci]->vc_status = VC_ACTIVE | VC_ABR;\r\ndev->sum_mcr += srv_p->mcr;\r\ndev->n_abr++;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ia_cbr_setup (IADEV *dev, struct atm_vcc *vcc) {\r\nu32 rateLow=0, rateHigh, rate;\r\nint entries;\r\nstruct ia_vcc *ia_vcc;\r\nint idealSlot =0, testSlot, toBeAssigned, inc;\r\nu32 spacing;\r\nu16 *SchedTbl, *TstSchedTbl;\r\nu16 cbrVC, vcIndex;\r\nu32 fracSlot = 0;\r\nu32 sp_mod = 0;\r\nu32 sp_mod2 = 0;\r\nif (vcc->qos.txtp.max_pcr <= 0) {\r\nIF_ERR(printk("PCR for CBR not defined\n");)\r\nreturn -1;\r\n}\r\nrate = vcc->qos.txtp.max_pcr;\r\nentries = rate / dev->Granularity;\r\nIF_CBR(printk("CBR: CBR entries=0x%x for rate=0x%x & Gran=0x%x\n",\r\nentries, rate, dev->Granularity);)\r\nif (entries < 1)\r\nIF_CBR(printk("CBR: Bandwidth smaller than granularity of CBR table\n");)\r\nrateLow = entries * dev->Granularity;\r\nrateHigh = (entries + 1) * dev->Granularity;\r\nif (3*(rate - rateLow) > (rateHigh - rate))\r\nentries++;\r\nif (entries > dev->CbrRemEntries) {\r\nIF_CBR(printk("CBR: Not enough bandwidth to support this PCR.\n");)\r\nIF_CBR(printk("Entries = 0x%x, CbrRemEntries = 0x%x.\n",\r\nentries, dev->CbrRemEntries);)\r\nreturn -EBUSY;\r\n}\r\nia_vcc = INPH_IA_VCC(vcc);\r\nia_vcc->NumCbrEntry = entries;\r\ndev->sum_mcr += entries * dev->Granularity;\r\ncbrVC = 0;\r\nspacing = dev->CbrTotEntries / entries;\r\nsp_mod = dev->CbrTotEntries % entries;\r\ntoBeAssigned = entries;\r\nfracSlot = 0;\r\nvcIndex = vcc->vci;\r\nIF_CBR(printk("Vci=0x%x,Spacing=0x%x,Sp_mod=0x%x\n",vcIndex,spacing,sp_mod);)\r\nwhile (toBeAssigned)\r\n{\r\nif (toBeAssigned == entries)\r\n{\r\nidealSlot = dev->CbrEntryPt;\r\ndev->CbrEntryPt += 2;\r\nif (dev->CbrEntryPt >= dev->CbrTotEntries)\r\ndev->CbrEntryPt -= dev->CbrTotEntries;\r\n} else {\r\nidealSlot += (u32)(spacing + fracSlot);\r\nfracSlot = ((sp_mod + sp_mod2) / entries);\r\nsp_mod2 = ((sp_mod + sp_mod2) % entries);\r\n}\r\nif (idealSlot >= (int)dev->CbrTotEntries)\r\nidealSlot -= dev->CbrTotEntries;\r\nSchedTbl = (u16*)(dev->seg_ram+CBR_SCHED_TABLE*dev->memSize);\r\ninc = 0;\r\ntestSlot = idealSlot;\r\nTstSchedTbl = (u16*)(SchedTbl+testSlot);\r\nIF_CBR(printk("CBR Testslot 0x%x AT Location 0x%p, NumToAssign=%d\n",\r\ntestSlot, TstSchedTbl,toBeAssigned);)\r\nmemcpy((caddr_t)&cbrVC,(caddr_t)TstSchedTbl,sizeof(cbrVC));\r\nwhile (cbrVC)\r\n{\r\ninc++;\r\ntestSlot = idealSlot - inc;\r\nif (testSlot < 0) {\r\ntestSlot += dev->CbrTotEntries;\r\nIF_CBR(printk("Testslot Wrap. STable Start=0x%p,Testslot=%d\n",\r\nSchedTbl,testSlot);)\r\n}\r\nTstSchedTbl = (u16 *)(SchedTbl + testSlot);\r\nmemcpy((caddr_t)&cbrVC,(caddr_t)TstSchedTbl,sizeof(cbrVC));\r\nif (!cbrVC)\r\nbreak;\r\ntestSlot = idealSlot + inc;\r\nif (testSlot >= (int)dev->CbrTotEntries) {\r\ntestSlot -= dev->CbrTotEntries;\r\nIF_CBR(printk("TotCbrEntries=%d",dev->CbrTotEntries);)\r\nIF_CBR(printk(" Testslot=0x%x ToBeAssgned=%d\n",\r\ntestSlot, toBeAssigned);)\r\n}\r\nTstSchedTbl = (u16*)(SchedTbl + testSlot);\r\nIF_CBR(printk("Reading CBR Tbl from 0x%p, CbrVal=0x%x Iteration %d\n",\r\nTstSchedTbl,cbrVC,inc);)\r\nmemcpy((caddr_t)&cbrVC,(caddr_t)TstSchedTbl,sizeof(cbrVC));\r\n}\r\nmemcpy((caddr_t)TstSchedTbl, (caddr_t)&vcIndex, sizeof(*TstSchedTbl));\r\ndev->CbrRemEntries--;\r\ntoBeAssigned--;\r\n}\r\ndev->NumEnabledCBR++;\r\nif (dev->NumEnabledCBR == 1) {\r\nwritew((CBR_EN | UBR_EN | ABR_EN | (0x23 << 2)), dev->seg_reg+STPARMS);\r\nIF_CBR(printk("CBR is enabled\n");)\r\n}\r\nreturn 0;\r\n}\r\nstatic void ia_cbrVc_close (struct atm_vcc *vcc) {\r\nIADEV *iadev;\r\nu16 *SchedTbl, NullVci = 0;\r\nu32 i, NumFound;\r\niadev = INPH_IA_DEV(vcc->dev);\r\niadev->NumEnabledCBR--;\r\nSchedTbl = (u16*)(iadev->seg_ram+CBR_SCHED_TABLE*iadev->memSize);\r\nif (iadev->NumEnabledCBR == 0) {\r\nwritew((UBR_EN | ABR_EN | (0x23 << 2)), iadev->seg_reg+STPARMS);\r\nIF_CBR (printk("CBR support disabled\n");)\r\n}\r\nNumFound = 0;\r\nfor (i=0; i < iadev->CbrTotEntries; i++)\r\n{\r\nif (*SchedTbl == vcc->vci) {\r\niadev->CbrRemEntries++;\r\n*SchedTbl = NullVci;\r\nIF_CBR(NumFound++;)\r\n}\r\nSchedTbl++;\r\n}\r\nIF_CBR(printk("Exit ia_cbrVc_close, NumRemoved=%d\n",NumFound);)\r\n}\r\nstatic int ia_avail_descs(IADEV *iadev) {\r\nint tmp = 0;\r\nia_hack_tcq(iadev);\r\nif (iadev->host_tcq_wr >= iadev->ffL.tcq_rd)\r\ntmp = (iadev->host_tcq_wr - iadev->ffL.tcq_rd) / 2;\r\nelse\r\ntmp = (iadev->ffL.tcq_ed - iadev->ffL.tcq_rd + 2 + iadev->host_tcq_wr -\r\niadev->ffL.tcq_st) / 2;\r\nreturn tmp;\r\n}\r\nstatic int ia_que_tx (IADEV *iadev) {\r\nstruct sk_buff *skb;\r\nint num_desc;\r\nstruct atm_vcc *vcc;\r\nnum_desc = ia_avail_descs(iadev);\r\nwhile (num_desc && (skb = skb_dequeue(&iadev->tx_backlog))) {\r\nif (!(vcc = ATM_SKB(skb)->vcc)) {\r\ndev_kfree_skb_any(skb);\r\nprintk("ia_que_tx: Null vcc\n");\r\nbreak;\r\n}\r\nif (!test_bit(ATM_VF_READY,&vcc->flags)) {\r\ndev_kfree_skb_any(skb);\r\nprintk("Free the SKB on closed vci %d \n", vcc->vci);\r\nbreak;\r\n}\r\nif (ia_pkt_tx (vcc, skb)) {\r\nskb_queue_head(&iadev->tx_backlog, skb);\r\n}\r\nnum_desc--;\r\n}\r\nreturn 0;\r\n}\r\nstatic void ia_tx_poll (IADEV *iadev) {\r\nstruct atm_vcc *vcc = NULL;\r\nstruct sk_buff *skb = NULL, *skb1 = NULL;\r\nstruct ia_vcc *iavcc;\r\nIARTN_Q * rtne;\r\nia_hack_tcq(iadev);\r\nwhile ( (rtne = ia_deque_rtn_q(&iadev->tx_return_q))) {\r\nskb = rtne->data.txskb;\r\nif (!skb) {\r\nprintk("ia_tx_poll: skb is null\n");\r\ngoto out;\r\n}\r\nvcc = ATM_SKB(skb)->vcc;\r\nif (!vcc) {\r\nprintk("ia_tx_poll: vcc is null\n");\r\ndev_kfree_skb_any(skb);\r\ngoto out;\r\n}\r\niavcc = INPH_IA_VCC(vcc);\r\nif (!iavcc) {\r\nprintk("ia_tx_poll: iavcc is null\n");\r\ndev_kfree_skb_any(skb);\r\ngoto out;\r\n}\r\nskb1 = skb_dequeue(&iavcc->txing_skb);\r\nwhile (skb1 && (skb1 != skb)) {\r\nif (!(IA_SKB_STATE(skb1) & IA_TX_DONE)) {\r\nprintk("IA_tx_intr: Vci %d lost pkt!!!\n", vcc->vci);\r\n}\r\nIF_ERR(printk("Release the SKB not match\n");)\r\nif ((vcc->pop) && (skb1->len != 0))\r\n{\r\nvcc->pop(vcc, skb1);\r\nIF_EVENT(printk("Tansmit Done - skb 0x%lx return\n",\r\n(long)skb1);)\r\n}\r\nelse\r\ndev_kfree_skb_any(skb1);\r\nskb1 = skb_dequeue(&iavcc->txing_skb);\r\n}\r\nif (!skb1) {\r\nIF_EVENT(printk("IA: Vci %d - skb not found requed\n",vcc->vci);)\r\nia_enque_head_rtn_q (&iadev->tx_return_q, rtne);\r\nbreak;\r\n}\r\nif ((vcc->pop) && (skb->len != 0))\r\n{\r\nvcc->pop(vcc, skb);\r\nIF_EVENT(printk("Tx Done - skb 0x%lx return\n",(long)skb);)\r\n}\r\nelse\r\ndev_kfree_skb_any(skb);\r\nkfree(rtne);\r\n}\r\nia_que_tx(iadev);\r\nout:\r\nreturn;\r\n}\r\nstatic u16 ia_eeprom_get (IADEV *iadev, u32 addr)\r\n{\r\nu_short val;\r\nu32 t;\r\nint i;\r\nNVRAM_CMD(IAREAD + addr);\r\nval = 0;\r\nfor (i=15; i>=0; i--) {\r\nNVRAM_CLKIN(t);\r\nval |= (t << i);\r\n}\r\nNVRAM_CLR_CE;\r\nCFG_AND(~NVDI);\r\nreturn val;\r\n}\r\nstatic void ia_hw_type(IADEV *iadev) {\r\nu_short memType = ia_eeprom_get(iadev, 25);\r\niadev->memType = memType;\r\nif ((memType & MEM_SIZE_MASK) == MEM_SIZE_1M) {\r\niadev->num_tx_desc = IA_TX_BUF;\r\niadev->tx_buf_sz = IA_TX_BUF_SZ;\r\niadev->num_rx_desc = IA_RX_BUF;\r\niadev->rx_buf_sz = IA_RX_BUF_SZ;\r\n} else if ((memType & MEM_SIZE_MASK) == MEM_SIZE_512K) {\r\nif (IA_TX_BUF == DFL_TX_BUFFERS)\r\niadev->num_tx_desc = IA_TX_BUF / 2;\r\nelse\r\niadev->num_tx_desc = IA_TX_BUF;\r\niadev->tx_buf_sz = IA_TX_BUF_SZ;\r\nif (IA_RX_BUF == DFL_RX_BUFFERS)\r\niadev->num_rx_desc = IA_RX_BUF / 2;\r\nelse\r\niadev->num_rx_desc = IA_RX_BUF;\r\niadev->rx_buf_sz = IA_RX_BUF_SZ;\r\n}\r\nelse {\r\nif (IA_TX_BUF == DFL_TX_BUFFERS)\r\niadev->num_tx_desc = IA_TX_BUF / 8;\r\nelse\r\niadev->num_tx_desc = IA_TX_BUF;\r\niadev->tx_buf_sz = IA_TX_BUF_SZ;\r\nif (IA_RX_BUF == DFL_RX_BUFFERS)\r\niadev->num_rx_desc = IA_RX_BUF / 8;\r\nelse\r\niadev->num_rx_desc = IA_RX_BUF;\r\niadev->rx_buf_sz = IA_RX_BUF_SZ;\r\n}\r\niadev->rx_pkt_ram = TX_PACKET_RAM + (iadev->num_tx_desc * iadev->tx_buf_sz);\r\nIF_INIT(printk("BUF: tx=%d,sz=%d rx=%d sz= %d rx_pkt_ram=%d\n",\r\niadev->num_tx_desc, iadev->tx_buf_sz, iadev->num_rx_desc,\r\niadev->rx_buf_sz, iadev->rx_pkt_ram);)\r\n#if 0\r\nif ((memType & FE_MASK) == FE_SINGLE_MODE) {\r\niadev->phy_type = PHY_OC3C_S;\r\nelse if ((memType & FE_MASK) == FE_UTP_OPTION)\r\niadev->phy_type = PHY_UTP155;\r\nelse\r\niadev->phy_type = PHY_OC3C_M;\r\n#endif\r\niadev->phy_type = memType & FE_MASK;\r\nIF_INIT(printk("memType = 0x%x iadev->phy_type = 0x%x\n",\r\nmemType,iadev->phy_type);)\r\nif (iadev->phy_type == FE_25MBIT_PHY)\r\niadev->LineRate = (u32)(((25600000/8)*26)/(27*53));\r\nelse if (iadev->phy_type == FE_DS3_PHY)\r\niadev->LineRate = (u32)(((44736000/8)*26)/(27*53));\r\nelse if (iadev->phy_type == FE_E3_PHY)\r\niadev->LineRate = (u32)(((34368000/8)*26)/(27*53));\r\nelse\r\niadev->LineRate = (u32)(ATM_OC3_PCR);\r\nIF_INIT(printk("iadev->LineRate = %d \n", iadev->LineRate);)\r\n}\r\nstatic u32 ia_phy_read32(struct iadev_priv *ia, unsigned int reg)\r\n{\r\nreturn readl(ia->phy + (reg >> 2));\r\n}\r\nstatic void ia_phy_write32(struct iadev_priv *ia, unsigned int reg, u32 val)\r\n{\r\nwritel(val, ia->phy + (reg >> 2));\r\n}\r\nstatic void ia_frontend_intr(struct iadev_priv *iadev)\r\n{\r\nu32 status;\r\nif (iadev->phy_type & FE_25MBIT_PHY) {\r\nstatus = ia_phy_read32(iadev, MB25_INTR_STATUS);\r\niadev->carrier_detect = (status & MB25_IS_GSB) ? 1 : 0;\r\n} else if (iadev->phy_type & FE_DS3_PHY) {\r\nia_phy_read32(iadev, SUNI_DS3_FRM_INTR_STAT);\r\nstatus = ia_phy_read32(iadev, SUNI_DS3_FRM_STAT);\r\niadev->carrier_detect = (status & SUNI_DS3_LOSV) ? 0 : 1;\r\n} else if (iadev->phy_type & FE_E3_PHY) {\r\nia_phy_read32(iadev, SUNI_E3_FRM_MAINT_INTR_IND);\r\nstatus = ia_phy_read32(iadev, SUNI_E3_FRM_FRAM_INTR_IND_STAT);\r\niadev->carrier_detect = (status & SUNI_E3_LOS) ? 0 : 1;\r\n} else {\r\nstatus = ia_phy_read32(iadev, SUNI_RSOP_STATUS);\r\niadev->carrier_detect = (status & SUNI_LOSV) ? 0 : 1;\r\n}\r\nprintk(KERN_INFO "IA: SUNI carrier %s\n",\r\niadev->carrier_detect ? "detected" : "lost signal");\r\n}\r\nstatic void ia_mb25_init(struct iadev_priv *iadev)\r\n{\r\n#if 0\r\nmb25->mb25_master_ctrl = MB25_MC_DRIC | MB25_MC_DREC | MB25_MC_ENABLED;\r\n#endif\r\nia_phy_write32(iadev, MB25_MASTER_CTRL, MB25_MC_DRIC | MB25_MC_DREC);\r\nia_phy_write32(iadev, MB25_DIAG_CONTROL, 0);\r\niadev->carrier_detect =\r\n(ia_phy_read32(iadev, MB25_INTR_STATUS) & MB25_IS_GSB) ? 1 : 0;\r\n}\r\nstatic void ia_phy_write(struct iadev_priv *iadev,\r\nconst struct ia_reg *regs, int len)\r\n{\r\nwhile (len--) {\r\nia_phy_write32(iadev, regs->reg, regs->val);\r\nregs++;\r\n}\r\n}\r\nstatic void ia_suni_pm7345_init_ds3(struct iadev_priv *iadev)\r\n{\r\nstatic const struct ia_reg suni_ds3_init [] = {\r\n{ SUNI_DS3_FRM_INTR_ENBL, 0x17 },\r\n{ SUNI_DS3_FRM_CFG, 0x01 },\r\n{ SUNI_DS3_TRAN_CFG, 0x01 },\r\n{ SUNI_CONFIG, 0 },\r\n{ SUNI_SPLR_CFG, 0 },\r\n{ SUNI_SPLT_CFG, 0 }\r\n};\r\nu32 status;\r\nstatus = ia_phy_read32(iadev, SUNI_DS3_FRM_STAT);\r\niadev->carrier_detect = (status & SUNI_DS3_LOSV) ? 0 : 1;\r\nia_phy_write(iadev, suni_ds3_init, ARRAY_SIZE(suni_ds3_init));\r\n}\r\nstatic void ia_suni_pm7345_init_e3(struct iadev_priv *iadev)\r\n{\r\nstatic const struct ia_reg suni_e3_init [] = {\r\n{ SUNI_E3_FRM_FRAM_OPTIONS, 0x04 },\r\n{ SUNI_E3_FRM_MAINT_OPTIONS, 0x20 },\r\n{ SUNI_E3_FRM_FRAM_INTR_ENBL, 0x1d },\r\n{ SUNI_E3_FRM_MAINT_INTR_ENBL, 0x30 },\r\n{ SUNI_E3_TRAN_STAT_DIAG_OPTIONS, 0 },\r\n{ SUNI_E3_TRAN_FRAM_OPTIONS, 0x01 },\r\n{ SUNI_CONFIG, SUNI_PM7345_E3ENBL },\r\n{ SUNI_SPLR_CFG, 0x41 },\r\n{ SUNI_SPLT_CFG, 0x41 }\r\n};\r\nu32 status;\r\nstatus = ia_phy_read32(iadev, SUNI_E3_FRM_FRAM_INTR_IND_STAT);\r\niadev->carrier_detect = (status & SUNI_E3_LOS) ? 0 : 1;\r\nia_phy_write(iadev, suni_e3_init, ARRAY_SIZE(suni_e3_init));\r\n}\r\nstatic void ia_suni_pm7345_init(struct iadev_priv *iadev)\r\n{\r\nstatic const struct ia_reg suni_init [] = {\r\n{ SUNI_INTR_ENBL, 0x28 },\r\n{ SUNI_ID_RESET, 0 },\r\n{ SUNI_MASTER_TEST, 0 },\r\n{ SUNI_RXCP_CTRL, 0x2c },\r\n{ SUNI_RXCP_FCTRL, 0x81 },\r\n{ SUNI_RXCP_IDLE_PAT_H1, 0 },\r\n{ SUNI_RXCP_IDLE_PAT_H2, 0 },\r\n{ SUNI_RXCP_IDLE_PAT_H3, 0 },\r\n{ SUNI_RXCP_IDLE_PAT_H4, 0x01 },\r\n{ SUNI_RXCP_IDLE_MASK_H1, 0xff },\r\n{ SUNI_RXCP_IDLE_MASK_H2, 0xff },\r\n{ SUNI_RXCP_IDLE_MASK_H3, 0xff },\r\n{ SUNI_RXCP_IDLE_MASK_H4, 0xfe },\r\n{ SUNI_RXCP_CELL_PAT_H1, 0 },\r\n{ SUNI_RXCP_CELL_PAT_H2, 0 },\r\n{ SUNI_RXCP_CELL_PAT_H3, 0 },\r\n{ SUNI_RXCP_CELL_PAT_H4, 0x01 },\r\n{ SUNI_RXCP_CELL_MASK_H1, 0xff },\r\n{ SUNI_RXCP_CELL_MASK_H2, 0xff },\r\n{ SUNI_RXCP_CELL_MASK_H3, 0xff },\r\n{ SUNI_RXCP_CELL_MASK_H4, 0xff },\r\n{ SUNI_TXCP_CTRL, 0xa4 },\r\n{ SUNI_TXCP_INTR_EN_STS, 0x10 },\r\n{ SUNI_TXCP_IDLE_PAT_H5, 0x55 }\r\n};\r\nif (iadev->phy_type & FE_DS3_PHY)\r\nia_suni_pm7345_init_ds3(iadev);\r\nelse\r\nia_suni_pm7345_init_e3(iadev);\r\nia_phy_write(iadev, suni_init, ARRAY_SIZE(suni_init));\r\nia_phy_write32(iadev, SUNI_CONFIG, ia_phy_read32(iadev, SUNI_CONFIG) &\r\n~(SUNI_PM7345_LLB | SUNI_PM7345_CLB |\r\nSUNI_PM7345_DLB | SUNI_PM7345_PLB));\r\n#ifdef __SNMP__\r\nsuni_pm7345->suni_rxcp_intr_en_sts |= SUNI_OOCDE;\r\n#endif\r\nreturn;\r\n}\r\nstatic void xdump( u_char* cp, int length, char* prefix )\r\n{\r\nint col, count;\r\nu_char prntBuf[120];\r\nu_char* pBuf = prntBuf;\r\ncount = 0;\r\nwhile(count < length){\r\npBuf += sprintf( pBuf, "%s", prefix );\r\nfor(col = 0;count + col < length && col < 16; col++){\r\nif (col != 0 && (col % 4) == 0)\r\npBuf += sprintf( pBuf, " " );\r\npBuf += sprintf( pBuf, "%02X ", cp[count + col] );\r\n}\r\nwhile(col++ < 16){\r\nif ((col % 4) == 0)\r\nsprintf( pBuf, " " );\r\npBuf += sprintf( pBuf, " " );\r\n}\r\npBuf += sprintf( pBuf, " " );\r\nfor(col = 0;count + col < length && col < 16; col++){\r\nif (isprint((int)cp[count + col]))\r\npBuf += sprintf( pBuf, "%c", cp[count + col] );\r\nelse\r\npBuf += sprintf( pBuf, "." );\r\n}\r\nprintk("%s\n", prntBuf);\r\ncount += col;\r\npBuf = prntBuf;\r\n}\r\n}\r\nstatic void desc_dbg(IADEV *iadev) {\r\nu_short tcq_wr_ptr, tcq_st_ptr, tcq_ed_ptr;\r\nu32 i;\r\nvoid __iomem *tmp;\r\ntcq_wr_ptr = readw(iadev->seg_reg+TCQ_WR_PTR);\r\nprintk("B_tcq_wr = 0x%x desc = %d last desc = %d\n",\r\ntcq_wr_ptr, readw(iadev->seg_ram+tcq_wr_ptr),\r\nreadw(iadev->seg_ram+tcq_wr_ptr-2));\r\nprintk(" host_tcq_wr = 0x%x host_tcq_rd = 0x%x \n", iadev->host_tcq_wr,\r\niadev->ffL.tcq_rd);\r\ntcq_st_ptr = readw(iadev->seg_reg+TCQ_ST_ADR);\r\ntcq_ed_ptr = readw(iadev->seg_reg+TCQ_ED_ADR);\r\nprintk("tcq_st_ptr = 0x%x tcq_ed_ptr = 0x%x \n", tcq_st_ptr, tcq_ed_ptr);\r\ni = 0;\r\nwhile (tcq_st_ptr != tcq_ed_ptr) {\r\ntmp = iadev->seg_ram+tcq_st_ptr;\r\nprintk("TCQ slot %d desc = %d Addr = %p\n", i++, readw(tmp), tmp);\r\ntcq_st_ptr += 2;\r\n}\r\nfor(i=0; i <iadev->num_tx_desc; i++)\r\nprintk("Desc_tbl[%d] = %d \n", i, iadev->desc_tbl[i].timestamp);\r\n}\r\nstatic void rx_excp_rcvd(struct atm_dev *dev)\r\n{\r\n#if 0\r\nIADEV *iadev;\r\nu_short state;\r\nu_short excpq_rd_ptr;\r\nint vci, error = 1;\r\niadev = INPH_IA_DEV(dev);\r\nstate = readl(iadev->reass_reg + STATE_REG) & 0xffff;\r\nwhile((state & EXCPQ_EMPTY) != EXCPQ_EMPTY)\r\n{ printk("state = %x \n", state);\r\nexcpq_rd_ptr = readw(iadev->reass_reg + EXCP_Q_RD_PTR) & 0xffff;\r\nprintk("state = %x excpq_rd_ptr = %x \n", state, excpq_rd_ptr);\r\nif (excpq_rd_ptr == *(u16*)(iadev->reass_reg + EXCP_Q_WR_PTR))\r\nIF_ERR(printk("excpq_rd_ptr is wrong!!!\n");)\r\nvci = readw(iadev->reass_ram+excpq_rd_ptr);\r\nerror = readw(iadev->reass_ram+excpq_rd_ptr+2) & 0x0007;\r\nexcpq_rd_ptr += 4;\r\nif (excpq_rd_ptr > (readw(iadev->reass_reg + EXCP_Q_ED_ADR)& 0xffff))\r\nexcpq_rd_ptr = readw(iadev->reass_reg + EXCP_Q_ST_ADR)& 0xffff;\r\nwritew( excpq_rd_ptr, iadev->reass_reg + EXCP_Q_RD_PTR);\r\nstate = readl(iadev->reass_reg + STATE_REG) & 0xffff;\r\n}\r\n#endif\r\n}\r\nstatic void free_desc(struct atm_dev *dev, int desc)\r\n{\r\nIADEV *iadev;\r\niadev = INPH_IA_DEV(dev);\r\nwritew(desc, iadev->reass_ram+iadev->rfL.fdq_wr);\r\niadev->rfL.fdq_wr +=2;\r\nif (iadev->rfL.fdq_wr > iadev->rfL.fdq_ed)\r\niadev->rfL.fdq_wr = iadev->rfL.fdq_st;\r\nwritew(iadev->rfL.fdq_wr, iadev->reass_reg+FREEQ_WR_PTR);\r\n}\r\nstatic int rx_pkt(struct atm_dev *dev)\r\n{\r\nIADEV *iadev;\r\nstruct atm_vcc *vcc;\r\nunsigned short status;\r\nstruct rx_buf_desc __iomem *buf_desc_ptr;\r\nint desc;\r\nstruct dle* wr_ptr;\r\nint len;\r\nstruct sk_buff *skb;\r\nu_int buf_addr, dma_addr;\r\niadev = INPH_IA_DEV(dev);\r\nif (iadev->rfL.pcq_rd == (readw(iadev->reass_reg+PCQ_WR_PTR)&0xffff))\r\n{\r\nprintk(KERN_ERR DEV_LABEL "(itf %d) Receive queue empty\n", dev->number);\r\nreturn -EINVAL;\r\n}\r\ndesc = readw(iadev->reass_ram+iadev->rfL.pcq_rd) & 0x1fff;\r\nIF_RX(printk("reass_ram = %p iadev->rfL.pcq_rd = 0x%x desc = %d\n",\r\niadev->reass_ram, iadev->rfL.pcq_rd, desc);\r\nprintk(" pcq_wr_ptr = 0x%x\n",\r\nreadw(iadev->reass_reg+PCQ_WR_PTR)&0xffff);)\r\nif ( iadev->rfL.pcq_rd== iadev->rfL.pcq_ed)\r\niadev->rfL.pcq_rd = iadev->rfL.pcq_st;\r\nelse\r\niadev->rfL.pcq_rd += 2;\r\nwritew(iadev->rfL.pcq_rd, iadev->reass_reg+PCQ_RD_PTR);\r\nbuf_desc_ptr = iadev->RX_DESC_BASE_ADDR;\r\nbuf_desc_ptr += desc;\r\nif (!desc || (desc > iadev->num_rx_desc) ||\r\n((buf_desc_ptr->vc_index & 0xffff) > iadev->num_vc)) {\r\nfree_desc(dev, desc);\r\nIF_ERR(printk("IA: bad descriptor desc = %d \n", desc);)\r\nreturn -1;\r\n}\r\nvcc = iadev->rx_open[buf_desc_ptr->vc_index & 0xffff];\r\nif (!vcc)\r\n{\r\nfree_desc(dev, desc);\r\nprintk("IA: null vcc, drop PDU\n");\r\nreturn -1;\r\n}\r\nstatus = (u_short) (buf_desc_ptr->desc_mode);\r\nif (status & (RX_CER | RX_PTE | RX_OFL))\r\n{\r\natomic_inc(&vcc->stats->rx_err);\r\nIF_ERR(printk("IA: bad packet, dropping it");)\r\nif (status & RX_CER) {\r\nIF_ERR(printk(" cause: packet CRC error\n");)\r\n}\r\nelse if (status & RX_PTE) {\r\nIF_ERR(printk(" cause: packet time out\n");)\r\n}\r\nelse {\r\nIF_ERR(printk(" cause: buffer overflow\n");)\r\n}\r\ngoto out_free_desc;\r\n}\r\nbuf_addr = (buf_desc_ptr->buf_start_hi << 16) | buf_desc_ptr->buf_start_lo;\r\ndma_addr = (buf_desc_ptr->dma_start_hi << 16) | buf_desc_ptr->dma_start_lo;\r\nlen = dma_addr - buf_addr;\r\nif (len > iadev->rx_buf_sz) {\r\nprintk("Over %d bytes sdu received, dropped!!!\n", iadev->rx_buf_sz);\r\natomic_inc(&vcc->stats->rx_err);\r\ngoto out_free_desc;\r\n}\r\nif (!(skb = atm_alloc_charge(vcc, len, GFP_ATOMIC))) {\r\nif (vcc->vci < 32)\r\nprintk("Drop control packets\n");\r\ngoto out_free_desc;\r\n}\r\nskb_put(skb,len);\r\nATM_SKB(skb)->vcc = vcc;\r\nATM_DESC(skb) = desc;\r\nskb_queue_tail(&iadev->rx_dma_q, skb);\r\nwr_ptr = iadev->rx_dle_q.write;\r\nwr_ptr->sys_pkt_addr = dma_map_single(&iadev->pci->dev, skb->data,\r\nlen, DMA_FROM_DEVICE);\r\nwr_ptr->local_pkt_addr = buf_addr;\r\nwr_ptr->bytes = len;\r\nwr_ptr->mode = DMA_INT_ENABLE;\r\nif(++wr_ptr == iadev->rx_dle_q.end)\r\nwr_ptr = iadev->rx_dle_q.start;\r\niadev->rx_dle_q.write = wr_ptr;\r\nudelay(1);\r\nwritel(1, iadev->dma+IPHASE5575_RX_COUNTER);\r\nout: return 0;\r\nout_free_desc:\r\nfree_desc(dev, desc);\r\ngoto out;\r\n}\r\nstatic void rx_intr(struct atm_dev *dev)\r\n{\r\nIADEV *iadev;\r\nu_short status;\r\nu_short state, i;\r\niadev = INPH_IA_DEV(dev);\r\nstatus = readl(iadev->reass_reg+REASS_INTR_STATUS_REG) & 0xffff;\r\nIF_EVENT(printk("rx_intr: status = 0x%x\n", status);)\r\nif (status & RX_PKT_RCVD)\r\n{\r\nstate = readl(iadev->reass_reg + STATE_REG) & 0xffff;\r\nIF_EVENT(printk("Rx intr status: RX_PKT_RCVD %08x\n", status);)\r\nwhile(!(state & PCQ_EMPTY))\r\n{\r\nrx_pkt(dev);\r\nstate = readl(iadev->reass_reg + STATE_REG) & 0xffff;\r\n}\r\niadev->rxing = 1;\r\n}\r\nif (status & RX_FREEQ_EMPT)\r\n{\r\nif (iadev->rxing) {\r\niadev->rx_tmp_cnt = iadev->rx_pkt_cnt;\r\niadev->rx_tmp_jif = jiffies;\r\niadev->rxing = 0;\r\n}\r\nelse if ((time_after(jiffies, iadev->rx_tmp_jif + 50)) &&\r\n((iadev->rx_pkt_cnt - iadev->rx_tmp_cnt) == 0)) {\r\nfor (i = 1; i <= iadev->num_rx_desc; i++)\r\nfree_desc(dev, i);\r\nprintk("Test logic RUN!!!!\n");\r\nwritew( ~(RX_FREEQ_EMPT|RX_EXCP_RCVD),iadev->reass_reg+REASS_MASK_REG);\r\niadev->rxing = 1;\r\n}\r\nIF_EVENT(printk("Rx intr status: RX_FREEQ_EMPT %08x\n", status);)\r\n}\r\nif (status & RX_EXCP_RCVD)\r\n{\r\nIF_EVENT(printk("Rx intr status: RX_EXCP_RCVD %08x\n", status);)\r\nrx_excp_rcvd(dev);\r\n}\r\nif (status & RX_RAW_RCVD)\r\n{\r\nIF_EVENT(printk("Rx intr status: RX_RAW_RCVD %08x\n", status);)\r\n}\r\n}\r\nstatic void rx_dle_intr(struct atm_dev *dev)\r\n{\r\nIADEV *iadev;\r\nstruct atm_vcc *vcc;\r\nstruct sk_buff *skb;\r\nint desc;\r\nu_short state;\r\nstruct dle *dle, *cur_dle;\r\nu_int dle_lp;\r\nint len;\r\niadev = INPH_IA_DEV(dev);\r\ndle = iadev->rx_dle_q.read;\r\ndle_lp = readl(iadev->dma+IPHASE5575_RX_LIST_ADDR) & (sizeof(struct dle)*DLE_ENTRIES - 1);\r\ncur_dle = (struct dle*)(iadev->rx_dle_q.start + (dle_lp >> 4));\r\nwhile(dle != cur_dle)\r\n{\r\nskb = skb_dequeue(&iadev->rx_dma_q);\r\nif (!skb)\r\ngoto INCR_DLE;\r\ndesc = ATM_DESC(skb);\r\nfree_desc(dev, desc);\r\nif (!(len = skb->len))\r\n{\r\nprintk("rx_dle_intr: skb len 0\n");\r\ndev_kfree_skb_any(skb);\r\n}\r\nelse\r\n{\r\nstruct cpcs_trailer *trailer;\r\nu_short length;\r\nstruct ia_vcc *ia_vcc;\r\ndma_unmap_single(&iadev->pci->dev, iadev->rx_dle_q.write->sys_pkt_addr,\r\nlen, DMA_FROM_DEVICE);\r\nvcc = ATM_SKB(skb)->vcc;\r\nif (!vcc) {\r\nprintk("IA: null vcc\n");\r\ndev_kfree_skb_any(skb);\r\ngoto INCR_DLE;\r\n}\r\nia_vcc = INPH_IA_VCC(vcc);\r\nif (ia_vcc == NULL)\r\n{\r\natomic_inc(&vcc->stats->rx_err);\r\natm_return(vcc, skb->truesize);\r\ndev_kfree_skb_any(skb);\r\ngoto INCR_DLE;\r\n}\r\ntrailer = (struct cpcs_trailer*)((u_char *)skb->data +\r\nskb->len - sizeof(*trailer));\r\nlength = swap_byte_order(trailer->length);\r\nif ((length > iadev->rx_buf_sz) || (length >\r\n(skb->len - sizeof(struct cpcs_trailer))))\r\n{\r\natomic_inc(&vcc->stats->rx_err);\r\nIF_ERR(printk("rx_dle_intr: Bad AAL5 trailer %d (skb len %d)",\r\nlength, skb->len);)\r\natm_return(vcc, skb->truesize);\r\ndev_kfree_skb_any(skb);\r\ngoto INCR_DLE;\r\n}\r\nskb_trim(skb, length);\r\nIF_RXPKT(printk("\nDmad Recvd data: len = %d \n", skb->len);\r\nxdump(skb->data, skb->len, "RX: ");\r\nprintk("\n");)\r\nIF_RX(printk("rx_dle_intr: skb push");)\r\nvcc->push(vcc,skb);\r\natomic_inc(&vcc->stats->rx);\r\niadev->rx_pkt_cnt++;\r\n}\r\nINCR_DLE:\r\nif (++dle == iadev->rx_dle_q.end)\r\ndle = iadev->rx_dle_q.start;\r\n}\r\niadev->rx_dle_q.read = dle;\r\nif (!iadev->rxing) {\r\nstate = readl(iadev->reass_reg + STATE_REG) & 0xffff;\r\nif (!(state & FREEQ_EMPTY)) {\r\nstate = readl(iadev->reass_reg + REASS_MASK_REG) & 0xffff;\r\nwritel(state & ~(RX_FREEQ_EMPT | RX_PKT_RCVD),\r\niadev->reass_reg+REASS_MASK_REG);\r\niadev->rxing++;\r\n}\r\n}\r\n}\r\nstatic int open_rx(struct atm_vcc *vcc)\r\n{\r\nIADEV *iadev;\r\nu_short __iomem *vc_table;\r\nu_short __iomem *reass_ptr;\r\nIF_EVENT(printk("iadev: open_rx %d.%d\n", vcc->vpi, vcc->vci);)\r\nif (vcc->qos.rxtp.traffic_class == ATM_NONE) return 0;\r\niadev = INPH_IA_DEV(vcc->dev);\r\nif (vcc->qos.rxtp.traffic_class == ATM_ABR) {\r\nif (iadev->phy_type & FE_25MBIT_PHY) {\r\nprintk("IA: ABR not support\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\nvc_table = iadev->reass_ram+RX_VC_TABLE*iadev->memSize;\r\nvc_table += vcc->vci;\r\n*vc_table = vcc->vci << 6;\r\nif ((vcc->qos.rxtp.traffic_class == ATM_ABR) ||\r\n(vcc->qos.txtp.traffic_class == ATM_ABR))\r\n{\r\nsrv_cls_param_t srv_p;\r\ninit_abr_vc(iadev, &srv_p);\r\nia_open_abr_vc(iadev, &srv_p, vcc, 0);\r\n}\r\nelse {\r\nreass_ptr = iadev->reass_ram+REASS_TABLE*iadev->memSize;\r\nreass_ptr += vcc->vci;\r\n*reass_ptr = NO_AAL5_PKT;\r\n}\r\nif (iadev->rx_open[vcc->vci])\r\nprintk(KERN_CRIT DEV_LABEL "(itf %d): VCI %d already open\n",\r\nvcc->dev->number, vcc->vci);\r\niadev->rx_open[vcc->vci] = vcc;\r\nreturn 0;\r\n}\r\nstatic int rx_init(struct atm_dev *dev)\r\n{\r\nIADEV *iadev;\r\nstruct rx_buf_desc __iomem *buf_desc_ptr;\r\nunsigned long rx_pkt_start = 0;\r\nvoid *dle_addr;\r\nstruct abr_vc_table *abr_vc_table;\r\nu16 *vc_table;\r\nu16 *reass_table;\r\nint i,j, vcsize_sel;\r\nu_short freeq_st_adr;\r\nu_short *freeq_start;\r\niadev = INPH_IA_DEV(dev);\r\ndle_addr = dma_alloc_coherent(&iadev->pci->dev, DLE_TOTAL_SIZE,\r\n&iadev->rx_dle_dma, GFP_KERNEL);\r\nif (!dle_addr) {\r\nprintk(KERN_ERR DEV_LABEL "can't allocate DLEs\n");\r\ngoto err_out;\r\n}\r\niadev->rx_dle_q.start = (struct dle *)dle_addr;\r\niadev->rx_dle_q.read = iadev->rx_dle_q.start;\r\niadev->rx_dle_q.write = iadev->rx_dle_q.start;\r\niadev->rx_dle_q.end = (struct dle*)((unsigned long)dle_addr+sizeof(struct dle)*DLE_ENTRIES);\r\nwritel(iadev->rx_dle_dma & 0xfffff000,\r\niadev->dma + IPHASE5575_RX_LIST_ADDR);\r\nIF_INIT(printk("Tx Dle list addr: 0x%p value: 0x%0x\n",\r\niadev->dma+IPHASE5575_TX_LIST_ADDR,\r\nreadl(iadev->dma + IPHASE5575_TX_LIST_ADDR));\r\nprintk("Rx Dle list addr: 0x%p value: 0x%0x\n",\r\niadev->dma+IPHASE5575_RX_LIST_ADDR,\r\nreadl(iadev->dma + IPHASE5575_RX_LIST_ADDR));)\r\nwritew(0xffff, iadev->reass_reg+REASS_MASK_REG);\r\nwritew(0, iadev->reass_reg+MODE_REG);\r\nwritew(RESET_REASS, iadev->reass_reg+REASS_COMMAND_REG);\r\nwritew(RX_DESC_BASE >> 16, iadev->reass_reg+REASS_DESC_BASE);\r\nwritew(iadev->rx_buf_sz, iadev->reass_reg+BUF_SIZE);\r\niadev->RX_DESC_BASE_ADDR = iadev->reass_ram+RX_DESC_BASE*iadev->memSize;\r\nbuf_desc_ptr = iadev->RX_DESC_BASE_ADDR;\r\nmemset_io(buf_desc_ptr, 0, sizeof(*buf_desc_ptr));\r\nbuf_desc_ptr++;\r\nrx_pkt_start = iadev->rx_pkt_ram;\r\nfor(i=1; i<=iadev->num_rx_desc; i++)\r\n{\r\nmemset_io(buf_desc_ptr, 0, sizeof(*buf_desc_ptr));\r\nbuf_desc_ptr->buf_start_hi = rx_pkt_start >> 16;\r\nbuf_desc_ptr->buf_start_lo = rx_pkt_start & 0x0000ffff;\r\nbuf_desc_ptr++;\r\nrx_pkt_start += iadev->rx_buf_sz;\r\n}\r\nIF_INIT(printk("Rx Buffer desc ptr: 0x%p\n", buf_desc_ptr);)\r\ni = FREE_BUF_DESC_Q*iadev->memSize;\r\nwritew(i >> 16, iadev->reass_reg+REASS_QUEUE_BASE);\r\nwritew(i, iadev->reass_reg+FREEQ_ST_ADR);\r\nwritew(i+iadev->num_rx_desc*sizeof(u_short),\r\niadev->reass_reg+FREEQ_ED_ADR);\r\nwritew(i, iadev->reass_reg+FREEQ_RD_PTR);\r\nwritew(i+iadev->num_rx_desc*sizeof(u_short),\r\niadev->reass_reg+FREEQ_WR_PTR);\r\nfreeq_st_adr = readw(iadev->reass_reg+FREEQ_ST_ADR);\r\nfreeq_start = (u_short *)(iadev->reass_ram+freeq_st_adr);\r\nfor(i=1; i<=iadev->num_rx_desc; i++)\r\n{\r\n*freeq_start = (u_short)i;\r\nfreeq_start++;\r\n}\r\nIF_INIT(printk("freeq_start: 0x%p\n", freeq_start);)\r\ni = (PKT_COMP_Q * iadev->memSize) & 0xffff;\r\nwritew(i, iadev->reass_reg+PCQ_ST_ADR);\r\nwritew(i+iadev->num_vc*sizeof(u_short), iadev->reass_reg+PCQ_ED_ADR);\r\nwritew(i, iadev->reass_reg+PCQ_RD_PTR);\r\nwritew(i, iadev->reass_reg+PCQ_WR_PTR);\r\ni = (EXCEPTION_Q * iadev->memSize) & 0xffff;\r\nwritew(i, iadev->reass_reg+EXCP_Q_ST_ADR);\r\nwritew(i + NUM_RX_EXCP * sizeof(RX_ERROR_Q),\r\niadev->reass_reg+EXCP_Q_ED_ADR);\r\nwritew(i, iadev->reass_reg+EXCP_Q_RD_PTR);\r\nwritew(i, iadev->reass_reg+EXCP_Q_WR_PTR);\r\niadev->rfL.fdq_st = readw(iadev->reass_reg+FREEQ_ST_ADR) & 0xffff;\r\niadev->rfL.fdq_ed = readw(iadev->reass_reg+FREEQ_ED_ADR) & 0xffff ;\r\niadev->rfL.fdq_rd = readw(iadev->reass_reg+FREEQ_RD_PTR) & 0xffff;\r\niadev->rfL.fdq_wr = readw(iadev->reass_reg+FREEQ_WR_PTR) & 0xffff;\r\niadev->rfL.pcq_st = readw(iadev->reass_reg+PCQ_ST_ADR) & 0xffff;\r\niadev->rfL.pcq_ed = readw(iadev->reass_reg+PCQ_ED_ADR) & 0xffff;\r\niadev->rfL.pcq_rd = readw(iadev->reass_reg+PCQ_RD_PTR) & 0xffff;\r\niadev->rfL.pcq_wr = readw(iadev->reass_reg+PCQ_WR_PTR) & 0xffff;\r\nIF_INIT(printk("INIT:pcq_st:0x%x pcq_ed:0x%x pcq_rd:0x%x pcq_wr:0x%x",\r\niadev->rfL.pcq_st, iadev->rfL.pcq_ed, iadev->rfL.pcq_rd,\r\niadev->rfL.pcq_wr);)\r\ni = REASS_TABLE * iadev->memSize;\r\nwritew((i >> 3), iadev->reass_reg+REASS_TABLE_BASE);\r\nreass_table = (u16 *)(iadev->reass_ram+i);\r\nj = REASS_TABLE_SZ * iadev->memSize;\r\nfor(i=0; i < j; i++)\r\n*reass_table++ = NO_AAL5_PKT;\r\ni = 8*1024;\r\nvcsize_sel = 0;\r\nwhile (i != iadev->num_vc) {\r\ni /= 2;\r\nvcsize_sel++;\r\n}\r\ni = RX_VC_TABLE * iadev->memSize;\r\nwritew(((i>>3) & 0xfff8) | vcsize_sel, iadev->reass_reg+VC_LKUP_BASE);\r\nvc_table = (u16 *)(iadev->reass_ram+RX_VC_TABLE*iadev->memSize);\r\nj = RX_VC_TABLE_SZ * iadev->memSize;\r\nfor(i = 0; i < j; i++)\r\n{\r\n*vc_table = (i << 6) | 15;\r\nvc_table++;\r\n}\r\ni = ABR_VC_TABLE * iadev->memSize;\r\nwritew(i >> 3, iadev->reass_reg+ABR_LKUP_BASE);\r\ni = ABR_VC_TABLE * iadev->memSize;\r\nabr_vc_table = (struct abr_vc_table *)(iadev->reass_ram+i);\r\nj = REASS_TABLE_SZ * iadev->memSize;\r\nmemset ((char*)abr_vc_table, 0, j * sizeof(*abr_vc_table));\r\nfor(i = 0; i < j; i++) {\r\nabr_vc_table->rdf = 0x0003;\r\nabr_vc_table->air = 0x5eb1;\r\nabr_vc_table++;\r\n}\r\nwritew(0xff00, iadev->reass_reg+VP_FILTER);\r\nwritew(0, iadev->reass_reg+XTRA_RM_OFFSET);\r\nwritew(0x1, iadev->reass_reg+PROTOCOL_ID);\r\nwritew(0xF6F8, iadev->reass_reg+PKT_TM_CNT );\r\ni = (j >> 6) & 0xFF;\r\nj += 2 * (j - 1);\r\ni |= ((j << 2) & 0xFF00);\r\nwritew(i, iadev->reass_reg+TMOUT_RANGE);\r\nfor(i=0; i<iadev->num_tx_desc;i++)\r\niadev->desc_tbl[i].timestamp = 0;\r\nreadw(iadev->reass_reg+REASS_INTR_STATUS_REG);\r\nwritew(~(RX_FREEQ_EMPT|RX_PKT_RCVD), iadev->reass_reg+REASS_MASK_REG);\r\nskb_queue_head_init(&iadev->rx_dma_q);\r\niadev->rx_free_desc_qhead = NULL;\r\niadev->rx_open = kzalloc(4 * iadev->num_vc, GFP_KERNEL);\r\nif (!iadev->rx_open) {\r\nprintk(KERN_ERR DEV_LABEL "itf %d couldn't get free page\n",\r\ndev->number);\r\ngoto err_free_dle;\r\n}\r\niadev->rxing = 1;\r\niadev->rx_pkt_cnt = 0;\r\nwritew(R_ONLINE, iadev->reass_reg+MODE_REG);\r\nreturn 0;\r\nerr_free_dle:\r\ndma_free_coherent(&iadev->pci->dev, DLE_TOTAL_SIZE, iadev->rx_dle_q.start,\r\niadev->rx_dle_dma);\r\nerr_out:\r\nreturn -ENOMEM;\r\n}\r\nstatic void tx_intr(struct atm_dev *dev)\r\n{\r\nIADEV *iadev;\r\nunsigned short status;\r\nunsigned long flags;\r\niadev = INPH_IA_DEV(dev);\r\nstatus = readl(iadev->seg_reg+SEG_INTR_STATUS_REG);\r\nif (status & TRANSMIT_DONE){\r\nIF_EVENT(printk("Tansmit Done Intr logic run\n");)\r\nspin_lock_irqsave(&iadev->tx_lock, flags);\r\nia_tx_poll(iadev);\r\nspin_unlock_irqrestore(&iadev->tx_lock, flags);\r\nwritew(TRANSMIT_DONE, iadev->seg_reg+SEG_INTR_STATUS_REG);\r\nif (iadev->close_pending)\r\nwake_up(&iadev->close_wait);\r\n}\r\nif (status & TCQ_NOT_EMPTY)\r\n{\r\nIF_EVENT(printk("TCQ_NOT_EMPTY int received\n");)\r\n}\r\n}\r\nstatic void tx_dle_intr(struct atm_dev *dev)\r\n{\r\nIADEV *iadev;\r\nstruct dle *dle, *cur_dle;\r\nstruct sk_buff *skb;\r\nstruct atm_vcc *vcc;\r\nstruct ia_vcc *iavcc;\r\nu_int dle_lp;\r\nunsigned long flags;\r\niadev = INPH_IA_DEV(dev);\r\nspin_lock_irqsave(&iadev->tx_lock, flags);\r\ndle = iadev->tx_dle_q.read;\r\ndle_lp = readl(iadev->dma+IPHASE5575_TX_LIST_ADDR) &\r\n(sizeof(struct dle)*DLE_ENTRIES - 1);\r\ncur_dle = (struct dle*)(iadev->tx_dle_q.start + (dle_lp >> 4));\r\nwhile (dle != cur_dle)\r\n{\r\nskb = skb_dequeue(&iadev->tx_dma_q);\r\nif (!skb) break;\r\nif (!((dle - iadev->tx_dle_q.start)%(2*sizeof(struct dle)))) {\r\ndma_unmap_single(&iadev->pci->dev, dle->sys_pkt_addr, skb->len,\r\nDMA_TO_DEVICE);\r\n}\r\nvcc = ATM_SKB(skb)->vcc;\r\nif (!vcc) {\r\nprintk("tx_dle_intr: vcc is null\n");\r\nspin_unlock_irqrestore(&iadev->tx_lock, flags);\r\ndev_kfree_skb_any(skb);\r\nreturn;\r\n}\r\niavcc = INPH_IA_VCC(vcc);\r\nif (!iavcc) {\r\nprintk("tx_dle_intr: iavcc is null\n");\r\nspin_unlock_irqrestore(&iadev->tx_lock, flags);\r\ndev_kfree_skb_any(skb);\r\nreturn;\r\n}\r\nif (vcc->qos.txtp.pcr >= iadev->rate_limit) {\r\nif ((vcc->pop) && (skb->len != 0))\r\n{\r\nvcc->pop(vcc, skb);\r\n}\r\nelse {\r\ndev_kfree_skb_any(skb);\r\n}\r\n}\r\nelse {\r\nIA_SKB_STATE(skb) |= IA_DLED;\r\nskb_queue_tail(&iavcc->txing_skb, skb);\r\n}\r\nIF_EVENT(printk("tx_dle_intr: enque skb = 0x%p \n", skb);)\r\nif (++dle == iadev->tx_dle_q.end)\r\ndle = iadev->tx_dle_q.start;\r\n}\r\niadev->tx_dle_q.read = dle;\r\nspin_unlock_irqrestore(&iadev->tx_lock, flags);\r\n}\r\nstatic int open_tx(struct atm_vcc *vcc)\r\n{\r\nstruct ia_vcc *ia_vcc;\r\nIADEV *iadev;\r\nstruct main_vc *vc;\r\nstruct ext_vc *evc;\r\nint ret;\r\nIF_EVENT(printk("iadev: open_tx entered vcc->vci = %d\n", vcc->vci);)\r\nif (vcc->qos.txtp.traffic_class == ATM_NONE) return 0;\r\niadev = INPH_IA_DEV(vcc->dev);\r\nif (iadev->phy_type & FE_25MBIT_PHY) {\r\nif (vcc->qos.txtp.traffic_class == ATM_ABR) {\r\nprintk("IA: ABR not support\n");\r\nreturn -EINVAL;\r\n}\r\nif (vcc->qos.txtp.traffic_class == ATM_CBR) {\r\nprintk("IA: CBR not support\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\nia_vcc = INPH_IA_VCC(vcc);\r\nmemset((caddr_t)ia_vcc, 0, sizeof(*ia_vcc));\r\nif (vcc->qos.txtp.max_sdu >\r\n(iadev->tx_buf_sz - sizeof(struct cpcs_trailer))){\r\nprintk("IA: SDU size over (%d) the configured SDU size %d\n",\r\nvcc->qos.txtp.max_sdu,iadev->tx_buf_sz);\r\nvcc->dev_data = NULL;\r\nkfree(ia_vcc);\r\nreturn -EINVAL;\r\n}\r\nia_vcc->vc_desc_cnt = 0;\r\nia_vcc->txing = 1;\r\nif (vcc->qos.txtp.max_pcr == ATM_MAX_PCR)\r\nvcc->qos.txtp.pcr = iadev->LineRate;\r\nelse if ((vcc->qos.txtp.max_pcr == 0)&&( vcc->qos.txtp.pcr <= 0))\r\nvcc->qos.txtp.pcr = iadev->LineRate;\r\nelse if ((vcc->qos.txtp.max_pcr > vcc->qos.txtp.pcr) && (vcc->qos.txtp.max_pcr> 0))\r\nvcc->qos.txtp.pcr = vcc->qos.txtp.max_pcr;\r\nif (vcc->qos.txtp.pcr > iadev->LineRate)\r\nvcc->qos.txtp.pcr = iadev->LineRate;\r\nia_vcc->pcr = vcc->qos.txtp.pcr;\r\nif (ia_vcc->pcr > (iadev->LineRate / 6) ) ia_vcc->ltimeout = HZ / 10;\r\nelse if (ia_vcc->pcr > (iadev->LineRate / 130)) ia_vcc->ltimeout = HZ;\r\nelse if (ia_vcc->pcr <= 170) ia_vcc->ltimeout = 16 * HZ;\r\nelse ia_vcc->ltimeout = 2700 * HZ / ia_vcc->pcr;\r\nif (ia_vcc->pcr < iadev->rate_limit)\r\nskb_queue_head_init (&ia_vcc->txing_skb);\r\nif (ia_vcc->pcr < iadev->rate_limit) {\r\nstruct sock *sk = sk_atm(vcc);\r\nif (vcc->qos.txtp.max_sdu != 0) {\r\nif (ia_vcc->pcr > 60000)\r\nsk->sk_sndbuf = vcc->qos.txtp.max_sdu * 5;\r\nelse if (ia_vcc->pcr > 2000)\r\nsk->sk_sndbuf = vcc->qos.txtp.max_sdu * 4;\r\nelse\r\nsk->sk_sndbuf = vcc->qos.txtp.max_sdu * 3;\r\n}\r\nelse\r\nsk->sk_sndbuf = 24576;\r\n}\r\nvc = (struct main_vc *)iadev->MAIN_VC_TABLE_ADDR;\r\nevc = (struct ext_vc *)iadev->EXT_VC_TABLE_ADDR;\r\nvc += vcc->vci;\r\nevc += vcc->vci;\r\nmemset((caddr_t)vc, 0, sizeof(*vc));\r\nmemset((caddr_t)evc, 0, sizeof(*evc));\r\nevc->atm_hdr1 = (vcc->vci >> 12) & 0x000f;\r\nevc->atm_hdr2 = (vcc->vci & 0x0fff) << 4;\r\nif (vcc->qos.txtp.traffic_class == ATM_UBR)\r\n{\r\nvc->type = UBR;\r\nvc->status = CRC_APPEND;\r\nvc->acr = cellrate_to_float(iadev->LineRate);\r\nif (vcc->qos.txtp.pcr > 0)\r\nvc->acr = cellrate_to_float(vcc->qos.txtp.pcr);\r\nIF_UBR(printk("UBR: txtp.pcr = 0x%x f_rate = 0x%x\n",\r\nvcc->qos.txtp.max_pcr,vc->acr);)\r\n}\r\nelse if (vcc->qos.txtp.traffic_class == ATM_ABR)\r\n{ srv_cls_param_t srv_p;\r\nIF_ABR(printk("Tx ABR VCC\n");)\r\ninit_abr_vc(iadev, &srv_p);\r\nif (vcc->qos.txtp.pcr > 0)\r\nsrv_p.pcr = vcc->qos.txtp.pcr;\r\nif (vcc->qos.txtp.min_pcr > 0) {\r\nint tmpsum = iadev->sum_mcr+iadev->sum_cbr+vcc->qos.txtp.min_pcr;\r\nif (tmpsum > iadev->LineRate)\r\nreturn -EBUSY;\r\nsrv_p.mcr = vcc->qos.txtp.min_pcr;\r\niadev->sum_mcr += vcc->qos.txtp.min_pcr;\r\n}\r\nelse srv_p.mcr = 0;\r\nif (vcc->qos.txtp.icr)\r\nsrv_p.icr = vcc->qos.txtp.icr;\r\nif (vcc->qos.txtp.tbe)\r\nsrv_p.tbe = vcc->qos.txtp.tbe;\r\nif (vcc->qos.txtp.frtt)\r\nsrv_p.frtt = vcc->qos.txtp.frtt;\r\nif (vcc->qos.txtp.rif)\r\nsrv_p.rif = vcc->qos.txtp.rif;\r\nif (vcc->qos.txtp.rdf)\r\nsrv_p.rdf = vcc->qos.txtp.rdf;\r\nif (vcc->qos.txtp.nrm_pres)\r\nsrv_p.nrm = vcc->qos.txtp.nrm;\r\nif (vcc->qos.txtp.trm_pres)\r\nsrv_p.trm = vcc->qos.txtp.trm;\r\nif (vcc->qos.txtp.adtf_pres)\r\nsrv_p.adtf = vcc->qos.txtp.adtf;\r\nif (vcc->qos.txtp.cdf_pres)\r\nsrv_p.cdf = vcc->qos.txtp.cdf;\r\nif (srv_p.icr > srv_p.pcr)\r\nsrv_p.icr = srv_p.pcr;\r\nIF_ABR(printk("ABR:vcc->qos.txtp.max_pcr = %d mcr = %d\n",\r\nsrv_p.pcr, srv_p.mcr);)\r\nia_open_abr_vc(iadev, &srv_p, vcc, 1);\r\n} else if (vcc->qos.txtp.traffic_class == ATM_CBR) {\r\nif (iadev->phy_type & FE_25MBIT_PHY) {\r\nprintk("IA: CBR not support\n");\r\nreturn -EINVAL;\r\n}\r\nif (vcc->qos.txtp.max_pcr > iadev->LineRate) {\r\nIF_CBR(printk("PCR is not available\n");)\r\nreturn -1;\r\n}\r\nvc->type = CBR;\r\nvc->status = CRC_APPEND;\r\nif ((ret = ia_cbr_setup (iadev, vcc)) < 0) {\r\nreturn ret;\r\n}\r\n}\r\nelse\r\nprintk("iadev: Non UBR, ABR and CBR traffic not supportedn");\r\niadev->testTable[vcc->vci]->vc_status |= VC_ACTIVE;\r\nIF_EVENT(printk("ia open_tx returning \n");)\r\nreturn 0;\r\n}\r\nstatic int tx_init(struct atm_dev *dev)\r\n{\r\nIADEV *iadev;\r\nstruct tx_buf_desc *buf_desc_ptr;\r\nunsigned int tx_pkt_start;\r\nvoid *dle_addr;\r\nint i;\r\nu_short tcq_st_adr;\r\nu_short *tcq_start;\r\nu_short prq_st_adr;\r\nu_short *prq_start;\r\nstruct main_vc *vc;\r\nstruct ext_vc *evc;\r\nu_short tmp16;\r\nu32 vcsize_sel;\r\niadev = INPH_IA_DEV(dev);\r\nspin_lock_init(&iadev->tx_lock);\r\nIF_INIT(printk("Tx MASK REG: 0x%0x\n",\r\nreadw(iadev->seg_reg+SEG_MASK_REG));)\r\ndle_addr = dma_alloc_coherent(&iadev->pci->dev, DLE_TOTAL_SIZE,\r\n&iadev->tx_dle_dma, GFP_KERNEL);\r\nif (!dle_addr) {\r\nprintk(KERN_ERR DEV_LABEL "can't allocate DLEs\n");\r\ngoto err_out;\r\n}\r\niadev->tx_dle_q.start = (struct dle*)dle_addr;\r\niadev->tx_dle_q.read = iadev->tx_dle_q.start;\r\niadev->tx_dle_q.write = iadev->tx_dle_q.start;\r\niadev->tx_dle_q.end = (struct dle*)((unsigned long)dle_addr+sizeof(struct dle)*DLE_ENTRIES);\r\nwritel(iadev->tx_dle_dma & 0xfffff000,\r\niadev->dma + IPHASE5575_TX_LIST_ADDR);\r\nwritew(0xffff, iadev->seg_reg+SEG_MASK_REG);\r\nwritew(0, iadev->seg_reg+MODE_REG_0);\r\nwritew(RESET_SEG, iadev->seg_reg+SEG_COMMAND_REG);\r\niadev->MAIN_VC_TABLE_ADDR = iadev->seg_ram+MAIN_VC_TABLE*iadev->memSize;\r\niadev->EXT_VC_TABLE_ADDR = iadev->seg_ram+EXT_VC_TABLE*iadev->memSize;\r\niadev->ABR_SCHED_TABLE_ADDR=iadev->seg_ram+ABR_SCHED_TABLE*iadev->memSize;\r\nwritew(TX_DESC_BASE, iadev->seg_reg+SEG_DESC_BASE);\r\nbuf_desc_ptr =(struct tx_buf_desc *)(iadev->seg_ram+TX_DESC_BASE);\r\nmemset((caddr_t)buf_desc_ptr, 0, sizeof(*buf_desc_ptr));\r\nbuf_desc_ptr++;\r\ntx_pkt_start = TX_PACKET_RAM;\r\nfor(i=1; i<=iadev->num_tx_desc; i++)\r\n{\r\nmemset((caddr_t)buf_desc_ptr, 0, sizeof(*buf_desc_ptr));\r\nbuf_desc_ptr->desc_mode = AAL5;\r\nbuf_desc_ptr->buf_start_hi = tx_pkt_start >> 16;\r\nbuf_desc_ptr->buf_start_lo = tx_pkt_start & 0x0000ffff;\r\nbuf_desc_ptr++;\r\ntx_pkt_start += iadev->tx_buf_sz;\r\n}\r\niadev->tx_buf = kmalloc(iadev->num_tx_desc*sizeof(struct cpcs_trailer_desc), GFP_KERNEL);\r\nif (!iadev->tx_buf) {\r\nprintk(KERN_ERR DEV_LABEL " couldn't get mem\n");\r\ngoto err_free_dle;\r\n}\r\nfor (i= 0; i< iadev->num_tx_desc; i++)\r\n{\r\nstruct cpcs_trailer *cpcs;\r\ncpcs = kmalloc(sizeof(*cpcs), GFP_KERNEL|GFP_DMA);\r\nif(!cpcs) {\r\nprintk(KERN_ERR DEV_LABEL " couldn't get freepage\n");\r\ngoto err_free_tx_bufs;\r\n}\r\niadev->tx_buf[i].cpcs = cpcs;\r\niadev->tx_buf[i].dma_addr = dma_map_single(&iadev->pci->dev,\r\ncpcs,\r\nsizeof(*cpcs),\r\nDMA_TO_DEVICE);\r\n}\r\niadev->desc_tbl = kmalloc(iadev->num_tx_desc *\r\nsizeof(struct desc_tbl_t), GFP_KERNEL);\r\nif (!iadev->desc_tbl) {\r\nprintk(KERN_ERR DEV_LABEL " couldn't get mem\n");\r\ngoto err_free_all_tx_bufs;\r\n}\r\ni = TX_COMP_Q * iadev->memSize;\r\nwritew(i >> 16, iadev->seg_reg+SEG_QUEUE_BASE);\r\nwritew(i, iadev->seg_reg+TCQ_ST_ADR);\r\nwritew(i, iadev->seg_reg+TCQ_RD_PTR);\r\nwritew(i+iadev->num_tx_desc*sizeof(u_short),iadev->seg_reg+TCQ_WR_PTR);\r\niadev->host_tcq_wr = i + iadev->num_tx_desc*sizeof(u_short);\r\nwritew(i+2 * iadev->num_tx_desc * sizeof(u_short),\r\niadev->seg_reg+TCQ_ED_ADR);\r\ntcq_st_adr = readw(iadev->seg_reg+TCQ_ST_ADR);\r\ntcq_start = (u_short *)(iadev->seg_ram+tcq_st_adr);\r\nfor(i=1; i<=iadev->num_tx_desc; i++)\r\n{\r\n*tcq_start = (u_short)i;\r\ntcq_start++;\r\n}\r\ni = PKT_RDY_Q * iadev->memSize;\r\nwritew(i, iadev->seg_reg+PRQ_ST_ADR);\r\nwritew(i+2 * iadev->num_tx_desc * sizeof(u_short),\r\niadev->seg_reg+PRQ_ED_ADR);\r\nwritew(i, iadev->seg_reg+PRQ_RD_PTR);\r\nwritew(i, iadev->seg_reg+PRQ_WR_PTR);\r\niadev->ffL.prq_st = readw(iadev->seg_reg+PRQ_ST_ADR) & 0xffff;\r\niadev->ffL.prq_ed = readw(iadev->seg_reg+PRQ_ED_ADR) & 0xffff;\r\niadev->ffL.prq_wr = readw(iadev->seg_reg+PRQ_WR_PTR) & 0xffff;\r\niadev->ffL.tcq_st = readw(iadev->seg_reg+TCQ_ST_ADR) & 0xffff;\r\niadev->ffL.tcq_ed = readw(iadev->seg_reg+TCQ_ED_ADR) & 0xffff;\r\niadev->ffL.tcq_rd = readw(iadev->seg_reg+TCQ_RD_PTR) & 0xffff;\r\nprq_st_adr = readw(iadev->seg_reg+PRQ_ST_ADR);\r\nprq_start = (u_short *)(iadev->seg_ram+prq_st_adr);\r\nfor(i=1; i<=iadev->num_tx_desc; i++)\r\n{\r\n*prq_start = (u_short)0;\r\nprq_start++;\r\n}\r\nIF_INIT(printk("Start CBR Init\n");)\r\n#if 1\r\nwritew(0,iadev->seg_reg+CBR_PTR_BASE);\r\n#else\r\ntmp16 = (iadev->seg_ram+CBR_SCHED_TABLE*iadev->memSize)>>17;\r\nIF_INIT(printk("cbr_ptr_base = 0x%x ", tmp16);)\r\nwritew(tmp16,iadev->seg_reg+CBR_PTR_BASE);\r\n#endif\r\nIF_INIT(printk("value in register = 0x%x\n",\r\nreadw(iadev->seg_reg+CBR_PTR_BASE));)\r\ntmp16 = (CBR_SCHED_TABLE*iadev->memSize) >> 1;\r\nwritew(tmp16, iadev->seg_reg+CBR_TAB_BEG);\r\nIF_INIT(printk("cbr_tab_beg = 0x%x in reg = 0x%x \n", tmp16,\r\nreadw(iadev->seg_reg+CBR_TAB_BEG));)\r\nwritew(tmp16, iadev->seg_reg+CBR_TAB_END+1);\r\ntmp16 = (CBR_SCHED_TABLE*iadev->memSize + iadev->num_vc*6 - 2) >> 1;\r\nwritew(tmp16, iadev->seg_reg+CBR_TAB_END);\r\nIF_INIT(printk("iadev->seg_reg = 0x%p CBR_PTR_BASE = 0x%x\n",\r\niadev->seg_reg, readw(iadev->seg_reg+CBR_PTR_BASE));)\r\nIF_INIT(printk("CBR_TAB_BEG = 0x%x, CBR_TAB_END = 0x%x, CBR_PTR = 0x%x\n",\r\nreadw(iadev->seg_reg+CBR_TAB_BEG), readw(iadev->seg_reg+CBR_TAB_END),\r\nreadw(iadev->seg_reg+CBR_TAB_END+1));)\r\nmemset_io(iadev->seg_ram+CBR_SCHED_TABLE*iadev->memSize,\r\n0, iadev->num_vc*6);\r\niadev->CbrRemEntries = iadev->CbrTotEntries = iadev->num_vc*3;\r\niadev->CbrEntryPt = 0;\r\niadev->Granularity = MAX_ATM_155 / iadev->CbrTotEntries;\r\niadev->NumEnabledCBR = 0;\r\nvcsize_sel = 0;\r\ni = 8*1024;\r\nwhile (i != iadev->num_vc) {\r\ni /= 2;\r\nvcsize_sel++;\r\n}\r\ni = MAIN_VC_TABLE * iadev->memSize;\r\nwritew(vcsize_sel | ((i >> 8) & 0xfff8),iadev->seg_reg+VCT_BASE);\r\ni = EXT_VC_TABLE * iadev->memSize;\r\nwritew((i >> 8) & 0xfffe, iadev->seg_reg+VCTE_BASE);\r\ni = UBR_SCHED_TABLE * iadev->memSize;\r\nwritew((i & 0xffff) >> 11, iadev->seg_reg+UBR_SBPTR_BASE);\r\ni = UBR_WAIT_Q * iadev->memSize;\r\nwritew((i >> 7) & 0xffff, iadev->seg_reg+UBRWQ_BASE);\r\nmemset((caddr_t)(iadev->seg_ram+UBR_SCHED_TABLE*iadev->memSize),\r\n0, iadev->num_vc*8);\r\ni = ABR_SCHED_TABLE * iadev->memSize;\r\nwritew((i >> 11) & 0xffff, iadev->seg_reg+ABR_SBPTR_BASE);\r\ni = ABR_WAIT_Q * iadev->memSize;\r\nwritew((i >> 7) & 0xffff, iadev->seg_reg+ABRWQ_BASE);\r\ni = ABR_SCHED_TABLE*iadev->memSize;\r\nmemset((caddr_t)(iadev->seg_ram+i), 0, iadev->num_vc*4);\r\nvc = (struct main_vc *)iadev->MAIN_VC_TABLE_ADDR;\r\nevc = (struct ext_vc *)iadev->EXT_VC_TABLE_ADDR;\r\niadev->testTable = kmalloc(sizeof(long)*iadev->num_vc, GFP_KERNEL);\r\nif (!iadev->testTable) {\r\nprintk("Get freepage failed\n");\r\ngoto err_free_desc_tbl;\r\n}\r\nfor(i=0; i<iadev->num_vc; i++)\r\n{\r\nmemset((caddr_t)vc, 0, sizeof(*vc));\r\nmemset((caddr_t)evc, 0, sizeof(*evc));\r\niadev->testTable[i] = kmalloc(sizeof(struct testTable_t),\r\nGFP_KERNEL);\r\nif (!iadev->testTable[i])\r\ngoto err_free_test_tables;\r\niadev->testTable[i]->lastTime = 0;\r\niadev->testTable[i]->fract = 0;\r\niadev->testTable[i]->vc_status = VC_UBR;\r\nvc++;\r\nevc++;\r\n}\r\nif (iadev->phy_type & FE_25MBIT_PHY) {\r\nwritew(RATE25, iadev->seg_reg+MAXRATE);\r\nwritew((UBR_EN | (0x23 << 2)), iadev->seg_reg+STPARMS);\r\n}\r\nelse {\r\nwritew(cellrate_to_float(iadev->LineRate),iadev->seg_reg+MAXRATE);\r\nwritew((UBR_EN | ABR_EN | (0x23 << 2)), iadev->seg_reg+STPARMS);\r\n}\r\nwritew(0, iadev->seg_reg+IDLEHEADHI);\r\nwritew(0, iadev->seg_reg+IDLEHEADLO);\r\nwritew(0xaa00, iadev->seg_reg+ABRUBR_ARB);\r\niadev->close_pending = 0;\r\ninit_waitqueue_head(&iadev->close_wait);\r\ninit_waitqueue_head(&iadev->timeout_wait);\r\nskb_queue_head_init(&iadev->tx_dma_q);\r\nia_init_rtn_q(&iadev->tx_return_q);\r\nwritew(RM_TYPE_4_0, iadev->seg_reg+RM_TYPE);\r\nskb_queue_head_init (&iadev->tx_backlog);\r\nwritew(MODE_REG_1_VAL, iadev->seg_reg+MODE_REG_1);\r\nwritew(T_ONLINE, iadev->seg_reg+MODE_REG_0);\r\nreadw(iadev->seg_reg+SEG_INTR_STATUS_REG);\r\nwritew(~(TRANSMIT_DONE | TCQ_NOT_EMPTY), iadev->seg_reg+SEG_MASK_REG);\r\nwritew(TRANSMIT_DONE, iadev->seg_reg+SEG_INTR_STATUS_REG);\r\niadev->tx_pkt_cnt = 0;\r\niadev->rate_limit = iadev->LineRate / 3;\r\nreturn 0;\r\nerr_free_test_tables:\r\nwhile (--i >= 0)\r\nkfree(iadev->testTable[i]);\r\nkfree(iadev->testTable);\r\nerr_free_desc_tbl:\r\nkfree(iadev->desc_tbl);\r\nerr_free_all_tx_bufs:\r\ni = iadev->num_tx_desc;\r\nerr_free_tx_bufs:\r\nwhile (--i >= 0) {\r\nstruct cpcs_trailer_desc *desc = iadev->tx_buf + i;\r\ndma_unmap_single(&iadev->pci->dev, desc->dma_addr,\r\nsizeof(*desc->cpcs), DMA_TO_DEVICE);\r\nkfree(desc->cpcs);\r\n}\r\nkfree(iadev->tx_buf);\r\nerr_free_dle:\r\ndma_free_coherent(&iadev->pci->dev, DLE_TOTAL_SIZE, iadev->tx_dle_q.start,\r\niadev->tx_dle_dma);\r\nerr_out:\r\nreturn -ENOMEM;\r\n}\r\nstatic irqreturn_t ia_int(int irq, void *dev_id)\r\n{\r\nstruct atm_dev *dev;\r\nIADEV *iadev;\r\nunsigned int status;\r\nint handled = 0;\r\ndev = dev_id;\r\niadev = INPH_IA_DEV(dev);\r\nwhile( (status = readl(iadev->reg+IPHASE5575_BUS_STATUS_REG) & 0x7f))\r\n{\r\nhandled = 1;\r\nIF_EVENT(printk("ia_int: status = 0x%x\n", status);)\r\nif (status & STAT_REASSINT)\r\n{\r\nIF_EVENT(printk("REASSINT Bus status reg: %08x\n", status);)\r\nrx_intr(dev);\r\n}\r\nif (status & STAT_DLERINT)\r\n{\r\nwritel(STAT_DLERINT, iadev->reg + IPHASE5575_BUS_STATUS_REG);\r\nrx_dle_intr(dev);\r\n}\r\nif (status & STAT_SEGINT)\r\n{\r\nIF_EVENT(printk("IA: tx_intr \n");)\r\ntx_intr(dev);\r\n}\r\nif (status & STAT_DLETINT)\r\n{\r\nwritel(STAT_DLETINT, iadev->reg + IPHASE5575_BUS_STATUS_REG);\r\ntx_dle_intr(dev);\r\n}\r\nif (status & (STAT_FEINT | STAT_ERRINT | STAT_MARKINT))\r\n{\r\nif (status & STAT_FEINT)\r\nia_frontend_intr(iadev);\r\n}\r\n}\r\nreturn IRQ_RETVAL(handled);\r\n}\r\nstatic int get_esi(struct atm_dev *dev)\r\n{\r\nIADEV *iadev;\r\nint i;\r\nu32 mac1;\r\nu16 mac2;\r\niadev = INPH_IA_DEV(dev);\r\nmac1 = cpu_to_be32(le32_to_cpu(readl(\r\niadev->reg+IPHASE5575_MAC1)));\r\nmac2 = cpu_to_be16(le16_to_cpu(readl(iadev->reg+IPHASE5575_MAC2)));\r\nIF_INIT(printk("ESI: 0x%08x%04x\n", mac1, mac2);)\r\nfor (i=0; i<MAC1_LEN; i++)\r\ndev->esi[i] = mac1 >>(8*(MAC1_LEN-1-i));\r\nfor (i=0; i<MAC2_LEN; i++)\r\ndev->esi[i+MAC1_LEN] = mac2 >>(8*(MAC2_LEN - 1 -i));\r\nreturn 0;\r\n}\r\nstatic int reset_sar(struct atm_dev *dev)\r\n{\r\nIADEV *iadev;\r\nint i, error = 1;\r\nunsigned int pci[64];\r\niadev = INPH_IA_DEV(dev);\r\nfor(i=0; i<64; i++)\r\nif ((error = pci_read_config_dword(iadev->pci,\r\ni*4, &pci[i])) != PCIBIOS_SUCCESSFUL)\r\nreturn error;\r\nwritel(0, iadev->reg+IPHASE5575_EXT_RESET);\r\nfor(i=0; i<64; i++)\r\nif ((error = pci_write_config_dword(iadev->pci,\r\ni*4, pci[i])) != PCIBIOS_SUCCESSFUL)\r\nreturn error;\r\nudelay(5);\r\nreturn 0;\r\n}\r\nstatic int ia_init(struct atm_dev *dev)\r\n{\r\nIADEV *iadev;\r\nunsigned long real_base;\r\nvoid __iomem *base;\r\nunsigned short command;\r\nint error, i;\r\nIF_INIT(printk(">ia_init\n");)\r\ndev->ci_range.vpi_bits = 0;\r\ndev->ci_range.vci_bits = NR_VCI_LD;\r\niadev = INPH_IA_DEV(dev);\r\nreal_base = pci_resource_start (iadev->pci, 0);\r\niadev->irq = iadev->pci->irq;\r\nerror = pci_read_config_word(iadev->pci, PCI_COMMAND, &command);\r\nif (error) {\r\nprintk(KERN_ERR DEV_LABEL "(itf %d): init error 0x%x\n",\r\ndev->number,error);\r\nreturn -EINVAL;\r\n}\r\nIF_INIT(printk(DEV_LABEL "(itf %d): rev.%d,realbase=0x%lx,irq=%d\n",\r\ndev->number, iadev->pci->revision, real_base, iadev->irq);)\r\niadev->pci_map_size = pci_resource_len(iadev->pci, 0);\r\nif (iadev->pci_map_size == 0x100000){\r\niadev->num_vc = 4096;\r\ndev->ci_range.vci_bits = NR_VCI_4K_LD;\r\niadev->memSize = 4;\r\n}\r\nelse if (iadev->pci_map_size == 0x40000) {\r\niadev->num_vc = 1024;\r\niadev->memSize = 1;\r\n}\r\nelse {\r\nprintk("Unknown pci_map_size = 0x%x\n", iadev->pci_map_size);\r\nreturn -EINVAL;\r\n}\r\nIF_INIT(printk (DEV_LABEL "map size: %i\n", iadev->pci_map_size);)\r\npci_set_master(iadev->pci);\r\nudelay(10);\r\nbase = ioremap(real_base,iadev->pci_map_size);\r\nif (!base)\r\n{\r\nprintk(DEV_LABEL " (itf %d): can't set up page mapping\n",\r\ndev->number);\r\nreturn -ENOMEM;\r\n}\r\nIF_INIT(printk(DEV_LABEL " (itf %d): rev.%d,base=%p,irq=%d\n",\r\ndev->number, iadev->pci->revision, base, iadev->irq);)\r\niadev->mem = iadev->pci_map_size /2;\r\niadev->real_base = real_base;\r\niadev->base = base;\r\niadev->reg = base + REG_BASE;\r\niadev->seg_reg = base + SEG_BASE;\r\niadev->reass_reg = base + REASS_BASE;\r\niadev->phy = base + PHY_BASE;\r\niadev->dma = base + PHY_BASE;\r\niadev->ram = base + ACTUAL_RAM_BASE;\r\niadev->seg_ram = base + ACTUAL_SEG_RAM_BASE;\r\niadev->reass_ram = base + ACTUAL_REASS_RAM_BASE;\r\nIF_INIT(printk("Base addrs: %p %p %p \n %p %p %p %p\n",\r\niadev->reg,iadev->seg_reg,iadev->reass_reg,\r\niadev->phy, iadev->ram, iadev->seg_ram,\r\niadev->reass_ram);)\r\nerror = get_esi(dev);\r\nif (error) {\r\niounmap(iadev->base);\r\nreturn error;\r\n}\r\nprintk("IA: ");\r\nfor (i=0; i < ESI_LEN; i++)\r\nprintk("%s%02X",i ? "-" : "",dev->esi[i]);\r\nprintk("\n");\r\nif (reset_sar(dev)) {\r\niounmap(iadev->base);\r\nprintk("IA: reset SAR fail, please try again\n");\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic void ia_update_stats(IADEV *iadev) {\r\nif (!iadev->carrier_detect)\r\nreturn;\r\niadev->rx_cell_cnt += readw(iadev->reass_reg+CELL_CTR0)&0xffff;\r\niadev->rx_cell_cnt += (readw(iadev->reass_reg+CELL_CTR1) & 0xffff) << 16;\r\niadev->drop_rxpkt += readw(iadev->reass_reg + DRP_PKT_CNTR ) & 0xffff;\r\niadev->drop_rxcell += readw(iadev->reass_reg + ERR_CNTR) & 0xffff;\r\niadev->tx_cell_cnt += readw(iadev->seg_reg + CELL_CTR_LO_AUTO)&0xffff;\r\niadev->tx_cell_cnt += (readw(iadev->seg_reg+CELL_CTR_HIGH_AUTO)&0xffff)<<16;\r\nreturn;\r\n}\r\nstatic void ia_led_timer(unsigned long arg) {\r\nunsigned long flags;\r\nstatic u_char blinking[8] = {0, 0, 0, 0, 0, 0, 0, 0};\r\nu_char i;\r\nstatic u32 ctrl_reg;\r\nfor (i = 0; i < iadev_count; i++) {\r\nif (ia_dev[i]) {\r\nctrl_reg = readl(ia_dev[i]->reg+IPHASE5575_BUS_CONTROL_REG);\r\nif (blinking[i] == 0) {\r\nblinking[i]++;\r\nctrl_reg &= (~CTRL_LED);\r\nwritel(ctrl_reg, ia_dev[i]->reg+IPHASE5575_BUS_CONTROL_REG);\r\nia_update_stats(ia_dev[i]);\r\n}\r\nelse {\r\nblinking[i] = 0;\r\nctrl_reg |= CTRL_LED;\r\nwritel(ctrl_reg, ia_dev[i]->reg+IPHASE5575_BUS_CONTROL_REG);\r\nspin_lock_irqsave(&ia_dev[i]->tx_lock, flags);\r\nif (ia_dev[i]->close_pending)\r\nwake_up(&ia_dev[i]->close_wait);\r\nia_tx_poll(ia_dev[i]);\r\nspin_unlock_irqrestore(&ia_dev[i]->tx_lock, flags);\r\n}\r\n}\r\n}\r\nmod_timer(&ia_timer, jiffies + HZ / 4);\r\nreturn;\r\n}\r\nstatic void ia_phy_put(struct atm_dev *dev, unsigned char value,\r\nunsigned long addr)\r\n{\r\nwritel(value, INPH_IA_DEV(dev)->phy+addr);\r\n}\r\nstatic unsigned char ia_phy_get(struct atm_dev *dev, unsigned long addr)\r\n{\r\nreturn readl(INPH_IA_DEV(dev)->phy+addr);\r\n}\r\nstatic void ia_free_tx(IADEV *iadev)\r\n{\r\nint i;\r\nkfree(iadev->desc_tbl);\r\nfor (i = 0; i < iadev->num_vc; i++)\r\nkfree(iadev->testTable[i]);\r\nkfree(iadev->testTable);\r\nfor (i = 0; i < iadev->num_tx_desc; i++) {\r\nstruct cpcs_trailer_desc *desc = iadev->tx_buf + i;\r\ndma_unmap_single(&iadev->pci->dev, desc->dma_addr,\r\nsizeof(*desc->cpcs), DMA_TO_DEVICE);\r\nkfree(desc->cpcs);\r\n}\r\nkfree(iadev->tx_buf);\r\ndma_free_coherent(&iadev->pci->dev, DLE_TOTAL_SIZE, iadev->tx_dle_q.start,\r\niadev->tx_dle_dma);\r\n}\r\nstatic void ia_free_rx(IADEV *iadev)\r\n{\r\nkfree(iadev->rx_open);\r\ndma_free_coherent(&iadev->pci->dev, DLE_TOTAL_SIZE, iadev->rx_dle_q.start,\r\niadev->rx_dle_dma);\r\n}\r\nstatic int ia_start(struct atm_dev *dev)\r\n{\r\nIADEV *iadev;\r\nint error;\r\nunsigned char phy;\r\nu32 ctrl_reg;\r\nIF_EVENT(printk(">ia_start\n");)\r\niadev = INPH_IA_DEV(dev);\r\nif (request_irq(iadev->irq, &ia_int, IRQF_SHARED, DEV_LABEL, dev)) {\r\nprintk(KERN_ERR DEV_LABEL "(itf %d): IRQ%d is already in use\n",\r\ndev->number, iadev->irq);\r\nerror = -EAGAIN;\r\ngoto err_out;\r\n}\r\nif ((error = pci_write_config_word(iadev->pci,\r\nPCI_COMMAND,\r\nPCI_COMMAND_MEMORY | PCI_COMMAND_MASTER )))\r\n{\r\nprintk(KERN_ERR DEV_LABEL "(itf %d): can't enable memory+"\r\n"master (0x%x)\n",dev->number, error);\r\nerror = -EIO;\r\ngoto err_free_irq;\r\n}\r\nudelay(10);\r\nIF_INIT(printk("Bus ctrl reg: %08x\n",\r\nreadl(iadev->reg+IPHASE5575_BUS_CONTROL_REG));)\r\nctrl_reg = readl(iadev->reg+IPHASE5575_BUS_CONTROL_REG);\r\nctrl_reg = (ctrl_reg & (CTRL_LED | CTRL_FE_RST))\r\n| CTRL_B8\r\n| CTRL_B16\r\n| CTRL_B32\r\n| CTRL_B48\r\n| CTRL_B64\r\n| CTRL_B128\r\n| CTRL_ERRMASK\r\n| CTRL_DLETMASK\r\n| CTRL_DLERMASK\r\n| CTRL_SEGMASK\r\n| CTRL_REASSMASK\r\n| CTRL_FEMASK\r\n| CTRL_CSPREEMPT;\r\nwritel(ctrl_reg, iadev->reg+IPHASE5575_BUS_CONTROL_REG);\r\nIF_INIT(printk("Bus ctrl reg after initializing: %08x\n",\r\nreadl(iadev->reg+IPHASE5575_BUS_CONTROL_REG));\r\nprintk("Bus status reg after init: %08x\n",\r\nreadl(iadev->reg+IPHASE5575_BUS_STATUS_REG));)\r\nia_hw_type(iadev);\r\nerror = tx_init(dev);\r\nif (error)\r\ngoto err_free_irq;\r\nerror = rx_init(dev);\r\nif (error)\r\ngoto err_free_tx;\r\nctrl_reg = readl(iadev->reg+IPHASE5575_BUS_CONTROL_REG);\r\nwritel(ctrl_reg | CTRL_FE_RST, iadev->reg+IPHASE5575_BUS_CONTROL_REG);\r\nIF_INIT(printk("Bus ctrl reg after initializing: %08x\n",\r\nreadl(iadev->reg+IPHASE5575_BUS_CONTROL_REG));)\r\nphy = 0;\r\nIF_INIT (\r\nif ((phy=ia_phy_get(dev,0)) == 0x30)\r\nprintk("IA: pm5346,rev.%d\n",phy&0x0f);\r\nelse\r\nprintk("IA: utopia,rev.%0x\n",phy);)\r\nif (iadev->phy_type & FE_25MBIT_PHY)\r\nia_mb25_init(iadev);\r\nelse if (iadev->phy_type & (FE_DS3_PHY | FE_E3_PHY))\r\nia_suni_pm7345_init(iadev);\r\nelse {\r\nerror = suni_init(dev);\r\nif (error)\r\ngoto err_free_rx;\r\nif (dev->phy->start) {\r\nerror = dev->phy->start(dev);\r\nif (error)\r\ngoto err_free_rx;\r\n}\r\nia_frontend_intr(iadev);\r\n}\r\nreturn 0;\r\nerr_free_rx:\r\nia_free_rx(iadev);\r\nerr_free_tx:\r\nia_free_tx(iadev);\r\nerr_free_irq:\r\nfree_irq(iadev->irq, dev);\r\nerr_out:\r\nreturn error;\r\n}\r\nstatic void ia_close(struct atm_vcc *vcc)\r\n{\r\nDEFINE_WAIT(wait);\r\nu16 *vc_table;\r\nIADEV *iadev;\r\nstruct ia_vcc *ia_vcc;\r\nstruct sk_buff *skb = NULL;\r\nstruct sk_buff_head tmp_tx_backlog, tmp_vcc_backlog;\r\nunsigned long closetime, flags;\r\niadev = INPH_IA_DEV(vcc->dev);\r\nia_vcc = INPH_IA_VCC(vcc);\r\nif (!ia_vcc) return;\r\nIF_EVENT(printk("ia_close: ia_vcc->vc_desc_cnt = %d vci = %d\n",\r\nia_vcc->vc_desc_cnt,vcc->vci);)\r\nclear_bit(ATM_VF_READY,&vcc->flags);\r\nskb_queue_head_init (&tmp_tx_backlog);\r\nskb_queue_head_init (&tmp_vcc_backlog);\r\nif (vcc->qos.txtp.traffic_class != ATM_NONE) {\r\niadev->close_pending++;\r\nprepare_to_wait(&iadev->timeout_wait, &wait, TASK_UNINTERRUPTIBLE);\r\nschedule_timeout(50);\r\nfinish_wait(&iadev->timeout_wait, &wait);\r\nspin_lock_irqsave(&iadev->tx_lock, flags);\r\nwhile((skb = skb_dequeue(&iadev->tx_backlog))) {\r\nif (ATM_SKB(skb)->vcc == vcc){\r\nif (vcc->pop) vcc->pop(vcc, skb);\r\nelse dev_kfree_skb_any(skb);\r\n}\r\nelse\r\nskb_queue_tail(&tmp_tx_backlog, skb);\r\n}\r\nwhile((skb = skb_dequeue(&tmp_tx_backlog)))\r\nskb_queue_tail(&iadev->tx_backlog, skb);\r\nIF_EVENT(printk("IA TX Done decs_cnt = %d\n", ia_vcc->vc_desc_cnt);)\r\nclosetime = 300000 / ia_vcc->pcr;\r\nif (closetime == 0)\r\nclosetime = 1;\r\nspin_unlock_irqrestore(&iadev->tx_lock, flags);\r\nwait_event_timeout(iadev->close_wait, (ia_vcc->vc_desc_cnt <= 0), closetime);\r\nspin_lock_irqsave(&iadev->tx_lock, flags);\r\niadev->close_pending--;\r\niadev->testTable[vcc->vci]->lastTime = 0;\r\niadev->testTable[vcc->vci]->fract = 0;\r\niadev->testTable[vcc->vci]->vc_status = VC_UBR;\r\nif (vcc->qos.txtp.traffic_class == ATM_ABR) {\r\nif (vcc->qos.txtp.min_pcr > 0)\r\niadev->sum_mcr -= vcc->qos.txtp.min_pcr;\r\n}\r\nif (vcc->qos.txtp.traffic_class == ATM_CBR) {\r\nia_vcc = INPH_IA_VCC(vcc);\r\niadev->sum_mcr -= ia_vcc->NumCbrEntry*iadev->Granularity;\r\nia_cbrVc_close (vcc);\r\n}\r\nspin_unlock_irqrestore(&iadev->tx_lock, flags);\r\n}\r\nif (vcc->qos.rxtp.traffic_class != ATM_NONE) {\r\nvc_table = (u16 *)(iadev->reass_ram+REASS_TABLE*iadev->memSize);\r\nvc_table += vcc->vci;\r\n*vc_table = NO_AAL5_PKT;\r\nvc_table = (u16 *)(iadev->reass_ram+RX_VC_TABLE*iadev->memSize);\r\nvc_table += vcc->vci;\r\n*vc_table = (vcc->vci << 6) | 15;\r\nif (vcc->qos.rxtp.traffic_class == ATM_ABR) {\r\nstruct abr_vc_table __iomem *abr_vc_table =\r\n(iadev->reass_ram+ABR_VC_TABLE*iadev->memSize);\r\nabr_vc_table += vcc->vci;\r\nabr_vc_table->rdf = 0x0003;\r\nabr_vc_table->air = 0x5eb1;\r\n}\r\nrx_dle_intr(vcc->dev);\r\niadev->rx_open[vcc->vci] = NULL;\r\n}\r\nkfree(INPH_IA_VCC(vcc));\r\nia_vcc = NULL;\r\nvcc->dev_data = NULL;\r\nclear_bit(ATM_VF_ADDR,&vcc->flags);\r\nreturn;\r\n}\r\nstatic int ia_open(struct atm_vcc *vcc)\r\n{\r\nstruct ia_vcc *ia_vcc;\r\nint error;\r\nif (!test_bit(ATM_VF_PARTIAL,&vcc->flags))\r\n{\r\nIF_EVENT(printk("ia: not partially allocated resources\n");)\r\nvcc->dev_data = NULL;\r\n}\r\nif (vcc->vci != ATM_VPI_UNSPEC && vcc->vpi != ATM_VCI_UNSPEC)\r\n{\r\nIF_EVENT(printk("iphase open: unspec part\n");)\r\nset_bit(ATM_VF_ADDR,&vcc->flags);\r\n}\r\nif (vcc->qos.aal != ATM_AAL5)\r\nreturn -EINVAL;\r\nIF_EVENT(printk(DEV_LABEL "(itf %d): open %d.%d\n",\r\nvcc->dev->number, vcc->vpi, vcc->vci);)\r\nia_vcc = kmalloc(sizeof(*ia_vcc), GFP_KERNEL);\r\nif (!ia_vcc) return -ENOMEM;\r\nvcc->dev_data = ia_vcc;\r\nif ((error = open_rx(vcc)))\r\n{\r\nIF_EVENT(printk("iadev: error in open_rx, closing\n");)\r\nia_close(vcc);\r\nreturn error;\r\n}\r\nif ((error = open_tx(vcc)))\r\n{\r\nIF_EVENT(printk("iadev: error in open_tx, closing\n");)\r\nia_close(vcc);\r\nreturn error;\r\n}\r\nset_bit(ATM_VF_READY,&vcc->flags);\r\n#if 0\r\n{\r\nstatic u8 first = 1;\r\nif (first) {\r\nia_timer.expires = jiffies + 3*HZ;\r\nadd_timer(&ia_timer);\r\nfirst = 0;\r\n}\r\n}\r\n#endif\r\nIF_EVENT(printk("ia open returning\n");)\r\nreturn 0;\r\n}\r\nstatic int ia_change_qos(struct atm_vcc *vcc, struct atm_qos *qos, int flags)\r\n{\r\nIF_EVENT(printk(">ia_change_qos\n");)\r\nreturn 0;\r\n}\r\nstatic int ia_ioctl(struct atm_dev *dev, unsigned int cmd, void __user *arg)\r\n{\r\nIA_CMDBUF ia_cmds;\r\nIADEV *iadev;\r\nint i, board;\r\nu16 __user *tmps;\r\nIF_EVENT(printk(">ia_ioctl\n");)\r\nif (cmd != IA_CMD) {\r\nif (!dev->phy->ioctl) return -EINVAL;\r\nreturn dev->phy->ioctl(dev,cmd,arg);\r\n}\r\nif (copy_from_user(&ia_cmds, arg, sizeof ia_cmds)) return -EFAULT;\r\nboard = ia_cmds.status;\r\nif ((board < 0) || (board > iadev_count))\r\nboard = 0;\r\niadev = ia_dev[board];\r\nswitch (ia_cmds.cmd) {\r\ncase MEMDUMP:\r\n{\r\nswitch (ia_cmds.sub_cmd) {\r\ncase MEMDUMP_DEV:\r\nif (!capable(CAP_NET_ADMIN)) return -EPERM;\r\nif (copy_to_user(ia_cmds.buf, iadev, sizeof(IADEV)))\r\nreturn -EFAULT;\r\nia_cmds.status = 0;\r\nbreak;\r\ncase MEMDUMP_SEGREG:\r\nif (!capable(CAP_NET_ADMIN)) return -EPERM;\r\ntmps = (u16 __user *)ia_cmds.buf;\r\nfor(i=0; i<0x80; i+=2, tmps++)\r\nif(put_user((u16)(readl(iadev->seg_reg+i) & 0xffff), tmps)) return -EFAULT;\r\nia_cmds.status = 0;\r\nia_cmds.len = 0x80;\r\nbreak;\r\ncase MEMDUMP_REASSREG:\r\nif (!capable(CAP_NET_ADMIN)) return -EPERM;\r\ntmps = (u16 __user *)ia_cmds.buf;\r\nfor(i=0; i<0x80; i+=2, tmps++)\r\nif(put_user((u16)(readl(iadev->reass_reg+i) & 0xffff), tmps)) return -EFAULT;\r\nia_cmds.status = 0;\r\nia_cmds.len = 0x80;\r\nbreak;\r\ncase MEMDUMP_FFL:\r\n{\r\nia_regs_t *regs_local;\r\nffredn_t *ffL;\r\nrfredn_t *rfL;\r\nif (!capable(CAP_NET_ADMIN)) return -EPERM;\r\nregs_local = kmalloc(sizeof(*regs_local), GFP_KERNEL);\r\nif (!regs_local) return -ENOMEM;\r\nffL = &regs_local->ffredn;\r\nrfL = &regs_local->rfredn;\r\nfor (i=0; i<(sizeof (rfredn_t))/4; i++)\r\n((u_int *)rfL)[i] = readl(iadev->reass_reg + i) & 0xffff;\r\nfor (i=0; i<(sizeof (ffredn_t))/4; i++)\r\n((u_int *)ffL)[i] = readl(iadev->seg_reg + i) & 0xffff;\r\nif (copy_to_user(ia_cmds.buf, regs_local,sizeof(ia_regs_t))) {\r\nkfree(regs_local);\r\nreturn -EFAULT;\r\n}\r\nkfree(regs_local);\r\nprintk("Board %d registers dumped\n", board);\r\nia_cmds.status = 0;\r\n}\r\nbreak;\r\ncase READ_REG:\r\n{\r\nif (!capable(CAP_NET_ADMIN)) return -EPERM;\r\ndesc_dbg(iadev);\r\nia_cmds.status = 0;\r\n}\r\nbreak;\r\ncase 0x6:\r\n{\r\nia_cmds.status = 0;\r\nprintk("skb = 0x%lx\n", (long)skb_peek(&iadev->tx_backlog));\r\nprintk("rtn_q: 0x%lx\n",(long)ia_deque_rtn_q(&iadev->tx_return_q));\r\n}\r\nbreak;\r\ncase 0x8:\r\n{\r\nstruct k_sonet_stats *stats;\r\nstats = &PRIV(_ia_dev[board])->sonet_stats;\r\nprintk("section_bip: %d\n", atomic_read(&stats->section_bip));\r\nprintk("line_bip : %d\n", atomic_read(&stats->line_bip));\r\nprintk("path_bip : %d\n", atomic_read(&stats->path_bip));\r\nprintk("line_febe : %d\n", atomic_read(&stats->line_febe));\r\nprintk("path_febe : %d\n", atomic_read(&stats->path_febe));\r\nprintk("corr_hcs : %d\n", atomic_read(&stats->corr_hcs));\r\nprintk("uncorr_hcs : %d\n", atomic_read(&stats->uncorr_hcs));\r\nprintk("tx_cells : %d\n", atomic_read(&stats->tx_cells));\r\nprintk("rx_cells : %d\n", atomic_read(&stats->rx_cells));\r\n}\r\nia_cmds.status = 0;\r\nbreak;\r\ncase 0x9:\r\nif (!capable(CAP_NET_ADMIN)) return -EPERM;\r\nfor (i = 1; i <= iadev->num_rx_desc; i++)\r\nfree_desc(_ia_dev[board], i);\r\nwritew( ~(RX_FREEQ_EMPT | RX_EXCP_RCVD),\r\niadev->reass_reg+REASS_MASK_REG);\r\niadev->rxing = 1;\r\nia_cmds.status = 0;\r\nbreak;\r\ncase 0xb:\r\nif (!capable(CAP_NET_ADMIN)) return -EPERM;\r\nia_frontend_intr(iadev);\r\nbreak;\r\ncase 0xa:\r\nif (!capable(CAP_NET_ADMIN)) return -EPERM;\r\n{\r\nia_cmds.status = 0;\r\nIADebugFlag = ia_cmds.maddr;\r\nprintk("New debug option loaded\n");\r\n}\r\nbreak;\r\ndefault:\r\nia_cmds.status = 0;\r\nbreak;\r\n}\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ia_getsockopt(struct atm_vcc *vcc, int level, int optname,\r\nvoid __user *optval, int optlen)\r\n{\r\nIF_EVENT(printk(">ia_getsockopt\n");)\r\nreturn -EINVAL;\r\n}\r\nstatic int ia_setsockopt(struct atm_vcc *vcc, int level, int optname,\r\nvoid __user *optval, unsigned int optlen)\r\n{\r\nIF_EVENT(printk(">ia_setsockopt\n");)\r\nreturn -EINVAL;\r\n}\r\nstatic int ia_pkt_tx (struct atm_vcc *vcc, struct sk_buff *skb) {\r\nIADEV *iadev;\r\nstruct dle *wr_ptr;\r\nstruct tx_buf_desc __iomem *buf_desc_ptr;\r\nint desc;\r\nint comp_code;\r\nint total_len;\r\nstruct cpcs_trailer *trailer;\r\nstruct ia_vcc *iavcc;\r\niadev = INPH_IA_DEV(vcc->dev);\r\niavcc = INPH_IA_VCC(vcc);\r\nif (!iavcc->txing) {\r\nprintk("discard packet on closed VC\n");\r\nif (vcc->pop)\r\nvcc->pop(vcc, skb);\r\nelse\r\ndev_kfree_skb_any(skb);\r\nreturn 0;\r\n}\r\nif (skb->len > iadev->tx_buf_sz - 8) {\r\nprintk("Transmit size over tx buffer size\n");\r\nif (vcc->pop)\r\nvcc->pop(vcc, skb);\r\nelse\r\ndev_kfree_skb_any(skb);\r\nreturn 0;\r\n}\r\nif ((unsigned long)skb->data & 3) {\r\nprintk("Misaligned SKB\n");\r\nif (vcc->pop)\r\nvcc->pop(vcc, skb);\r\nelse\r\ndev_kfree_skb_any(skb);\r\nreturn 0;\r\n}\r\ndesc = get_desc (iadev, iavcc);\r\nif (desc == 0xffff)\r\nreturn 1;\r\ncomp_code = desc >> 13;\r\ndesc &= 0x1fff;\r\nif ((desc == 0) || (desc > iadev->num_tx_desc))\r\n{\r\nIF_ERR(printk(DEV_LABEL "invalid desc for send: %d\n", desc);)\r\natomic_inc(&vcc->stats->tx);\r\nif (vcc->pop)\r\nvcc->pop(vcc, skb);\r\nelse\r\ndev_kfree_skb_any(skb);\r\nreturn 0;\r\n}\r\nif (comp_code)\r\n{\r\nIF_ERR(printk(DEV_LABEL "send desc:%d completion code %d error\n",\r\ndesc, comp_code);)\r\n}\r\niavcc->vc_desc_cnt++;\r\niadev->desc_tbl[desc-1].iavcc = iavcc;\r\niadev->desc_tbl[desc-1].txskb = skb;\r\nIA_SKB_STATE(skb) = 0;\r\niadev->ffL.tcq_rd += 2;\r\nif (iadev->ffL.tcq_rd > iadev->ffL.tcq_ed)\r\niadev->ffL.tcq_rd = iadev->ffL.tcq_st;\r\nwritew(iadev->ffL.tcq_rd, iadev->seg_reg+TCQ_RD_PTR);\r\n*(u16*)(iadev->seg_ram+iadev->ffL.prq_wr) = desc;\r\niadev->ffL.prq_wr += 2;\r\nif (iadev->ffL.prq_wr > iadev->ffL.prq_ed)\r\niadev->ffL.prq_wr = iadev->ffL.prq_st;\r\ntotal_len = skb->len + sizeof(struct cpcs_trailer);\r\ntotal_len = ((total_len + 47) / 48) * 48;\r\nIF_TX(printk("ia packet len:%d padding:%d\n", total_len, total_len - skb->len);)\r\ntrailer = iadev->tx_buf[desc-1].cpcs;\r\nIF_TX(printk("Sent: skb = 0x%p skb->data: 0x%p len: %d, desc: %d\n",\r\nskb, skb->data, skb->len, desc);)\r\ntrailer->control = 0;\r\ntrailer->length = ((skb->len & 0xff) << 8) | ((skb->len & 0xff00) >> 8);\r\ntrailer->crc32 = 0;\r\nIF_TXPKT(printk("Sent data: len = %d MsgNum = %d\n",\r\nskb->len, tcnter++);\r\nxdump(skb->data, skb->len, "TX: ");\r\nprintk("\n");)\r\nbuf_desc_ptr = iadev->seg_ram+TX_DESC_BASE;\r\nbuf_desc_ptr += desc;\r\nbuf_desc_ptr->desc_mode = AAL5 | EOM_EN | APP_CRC32 | CMPL_INT;\r\nwritew(TRANSMIT_DONE, iadev->seg_reg+SEG_INTR_STATUS_REG);\r\nbuf_desc_ptr->vc_index = vcc->vci;\r\nbuf_desc_ptr->bytes = total_len;\r\nif (vcc->qos.txtp.traffic_class == ATM_ABR)\r\nclear_lockup (vcc, iadev);\r\nwr_ptr = iadev->tx_dle_q.write;\r\nmemset((caddr_t)wr_ptr, 0, sizeof(*wr_ptr));\r\nwr_ptr->sys_pkt_addr = dma_map_single(&iadev->pci->dev, skb->data,\r\nskb->len, DMA_TO_DEVICE);\r\nwr_ptr->local_pkt_addr = (buf_desc_ptr->buf_start_hi << 16) |\r\nbuf_desc_ptr->buf_start_lo;\r\nwr_ptr->bytes = skb->len;\r\nif ((wr_ptr->bytes >> 2) == 0xb)\r\nwr_ptr->bytes = 0x30;\r\nwr_ptr->mode = TX_DLE_PSI;\r\nwr_ptr->prq_wr_ptr_data = 0;\r\nif (++wr_ptr == iadev->tx_dle_q.end)\r\nwr_ptr = iadev->tx_dle_q.start;\r\nwr_ptr->sys_pkt_addr = iadev->tx_buf[desc-1].dma_addr;\r\nwr_ptr->local_pkt_addr = ((buf_desc_ptr->buf_start_hi << 16) |\r\nbuf_desc_ptr->buf_start_lo) + total_len - sizeof(struct cpcs_trailer);\r\nwr_ptr->bytes = sizeof(struct cpcs_trailer);\r\nwr_ptr->mode = DMA_INT_ENABLE;\r\nwr_ptr->prq_wr_ptr_data = iadev->ffL.prq_wr;\r\nif (++wr_ptr == iadev->tx_dle_q.end)\r\nwr_ptr = iadev->tx_dle_q.start;\r\niadev->tx_dle_q.write = wr_ptr;\r\nATM_DESC(skb) = vcc->vci;\r\nskb_queue_tail(&iadev->tx_dma_q, skb);\r\natomic_inc(&vcc->stats->tx);\r\niadev->tx_pkt_cnt++;\r\nwritel(2, iadev->dma+IPHASE5575_TX_COUNTER);\r\n#if 0\r\nif (atomic_read(&vcc->stats->tx) % 20 == 0) {\r\nif (iavcc->vc_desc_cnt > 10) {\r\nvcc->tx_quota = vcc->tx_quota * 3 / 4;\r\nprintk("Tx1: vcc->tx_quota = %d \n", (u32)vcc->tx_quota );\r\niavcc->flow_inc = -1;\r\niavcc->saved_tx_quota = vcc->tx_quota;\r\n} else if ((iavcc->flow_inc < 0) && (iavcc->vc_desc_cnt < 3)) {\r\nprintk("Tx2: vcc->tx_quota = %d \n", (u32)vcc->tx_quota );\r\niavcc->flow_inc = 0;\r\n}\r\n}\r\n#endif\r\nIF_TX(printk("ia send done\n");)\r\nreturn 0;\r\n}\r\nstatic int ia_send(struct atm_vcc *vcc, struct sk_buff *skb)\r\n{\r\nIADEV *iadev;\r\nunsigned long flags;\r\niadev = INPH_IA_DEV(vcc->dev);\r\nif ((!skb)||(skb->len>(iadev->tx_buf_sz-sizeof(struct cpcs_trailer))))\r\n{\r\nif (!skb)\r\nprintk(KERN_CRIT "null skb in ia_send\n");\r\nelse dev_kfree_skb_any(skb);\r\nreturn -EINVAL;\r\n}\r\nspin_lock_irqsave(&iadev->tx_lock, flags);\r\nif (!test_bit(ATM_VF_READY,&vcc->flags)){\r\ndev_kfree_skb_any(skb);\r\nspin_unlock_irqrestore(&iadev->tx_lock, flags);\r\nreturn -EINVAL;\r\n}\r\nATM_SKB(skb)->vcc = vcc;\r\nif (skb_peek(&iadev->tx_backlog)) {\r\nskb_queue_tail(&iadev->tx_backlog, skb);\r\n}\r\nelse {\r\nif (ia_pkt_tx (vcc, skb)) {\r\nskb_queue_tail(&iadev->tx_backlog, skb);\r\n}\r\n}\r\nspin_unlock_irqrestore(&iadev->tx_lock, flags);\r\nreturn 0;\r\n}\r\nstatic int ia_proc_read(struct atm_dev *dev,loff_t *pos,char *page)\r\n{\r\nint left = *pos, n;\r\nchar *tmpPtr;\r\nIADEV *iadev = INPH_IA_DEV(dev);\r\nif(!left--) {\r\nif (iadev->phy_type == FE_25MBIT_PHY) {\r\nn = sprintf(page, " Board Type : Iphase5525-1KVC-128K\n");\r\nreturn n;\r\n}\r\nif (iadev->phy_type == FE_DS3_PHY)\r\nn = sprintf(page, " Board Type : Iphase-ATM-DS3");\r\nelse if (iadev->phy_type == FE_E3_PHY)\r\nn = sprintf(page, " Board Type : Iphase-ATM-E3");\r\nelse if (iadev->phy_type == FE_UTP_OPTION)\r\nn = sprintf(page, " Board Type : Iphase-ATM-UTP155");\r\nelse\r\nn = sprintf(page, " Board Type : Iphase-ATM-OC3");\r\ntmpPtr = page + n;\r\nif (iadev->pci_map_size == 0x40000)\r\nn += sprintf(tmpPtr, "-1KVC-");\r\nelse\r\nn += sprintf(tmpPtr, "-4KVC-");\r\ntmpPtr = page + n;\r\nif ((iadev->memType & MEM_SIZE_MASK) == MEM_SIZE_1M)\r\nn += sprintf(tmpPtr, "1M \n");\r\nelse if ((iadev->memType & MEM_SIZE_MASK) == MEM_SIZE_512K)\r\nn += sprintf(tmpPtr, "512K\n");\r\nelse\r\nn += sprintf(tmpPtr, "128K\n");\r\nreturn n;\r\n}\r\nif (!left) {\r\nreturn sprintf(page, " Number of Tx Buffer: %u\n"\r\n" Size of Tx Buffer : %u\n"\r\n" Number of Rx Buffer: %u\n"\r\n" Size of Rx Buffer : %u\n"\r\n" Packets Receiverd : %u\n"\r\n" Packets Transmitted: %u\n"\r\n" Cells Received : %u\n"\r\n" Cells Transmitted : %u\n"\r\n" Board Dropped Cells: %u\n"\r\n" Board Dropped Pkts : %u\n",\r\niadev->num_tx_desc, iadev->tx_buf_sz,\r\niadev->num_rx_desc, iadev->rx_buf_sz,\r\niadev->rx_pkt_cnt, iadev->tx_pkt_cnt,\r\niadev->rx_cell_cnt, iadev->tx_cell_cnt,\r\niadev->drop_rxcell, iadev->drop_rxpkt);\r\n}\r\nreturn 0;\r\n}\r\nstatic int ia_init_one(struct pci_dev *pdev, const struct pci_device_id *ent)\r\n{\r\nstruct atm_dev *dev;\r\nIADEV *iadev;\r\nint ret;\r\niadev = kzalloc(sizeof(*iadev), GFP_KERNEL);\r\nif (!iadev) {\r\nret = -ENOMEM;\r\ngoto err_out;\r\n}\r\niadev->pci = pdev;\r\nIF_INIT(printk("ia detected at bus:%d dev: %d function:%d\n",\r\npdev->bus->number, PCI_SLOT(pdev->devfn), PCI_FUNC(pdev->devfn));)\r\nif (pci_enable_device(pdev)) {\r\nret = -ENODEV;\r\ngoto err_out_free_iadev;\r\n}\r\ndev = atm_dev_register(DEV_LABEL, &pdev->dev, &ops, -1, NULL);\r\nif (!dev) {\r\nret = -ENOMEM;\r\ngoto err_out_disable_dev;\r\n}\r\ndev->dev_data = iadev;\r\nIF_INIT(printk(DEV_LABEL "registered at (itf :%d)\n", dev->number);)\r\nIF_INIT(printk("dev_id = 0x%p iadev->LineRate = %d \n", dev,\r\niadev->LineRate);)\r\npci_set_drvdata(pdev, dev);\r\nia_dev[iadev_count] = iadev;\r\n_ia_dev[iadev_count] = dev;\r\niadev_count++;\r\nif (ia_init(dev) || ia_start(dev)) {\r\nIF_INIT(printk("IA register failed!\n");)\r\niadev_count--;\r\nia_dev[iadev_count] = NULL;\r\n_ia_dev[iadev_count] = NULL;\r\nret = -EINVAL;\r\ngoto err_out_deregister_dev;\r\n}\r\nIF_EVENT(printk("iadev_count = %d\n", iadev_count);)\r\niadev->next_board = ia_boards;\r\nia_boards = dev;\r\nreturn 0;\r\nerr_out_deregister_dev:\r\natm_dev_deregister(dev);\r\nerr_out_disable_dev:\r\npci_disable_device(pdev);\r\nerr_out_free_iadev:\r\nkfree(iadev);\r\nerr_out:\r\nreturn ret;\r\n}\r\nstatic void ia_remove_one(struct pci_dev *pdev)\r\n{\r\nstruct atm_dev *dev = pci_get_drvdata(pdev);\r\nIADEV *iadev = INPH_IA_DEV(dev);\r\nia_phy_put(dev, ia_phy_get(dev, SUNI_RSOP_CIE) & ~(SUNI_RSOP_CIE_LOSE),\r\nSUNI_RSOP_CIE);\r\nudelay(1);\r\nif (dev->phy && dev->phy->stop)\r\ndev->phy->stop(dev);\r\nfree_irq(iadev->irq, dev);\r\niadev_count--;\r\nia_dev[iadev_count] = NULL;\r\n_ia_dev[iadev_count] = NULL;\r\nIF_EVENT(printk("deregistering iav at (itf:%d)\n", dev->number);)\r\natm_dev_deregister(dev);\r\niounmap(iadev->base);\r\npci_disable_device(pdev);\r\nia_free_rx(iadev);\r\nia_free_tx(iadev);\r\nkfree(iadev);\r\n}\r\nstatic int __init ia_module_init(void)\r\n{\r\nint ret;\r\nret = pci_register_driver(&ia_driver);\r\nif (ret >= 0) {\r\nia_timer.expires = jiffies + 3*HZ;\r\nadd_timer(&ia_timer);\r\n} else\r\nprintk(KERN_ERR DEV_LABEL ": no adapter found\n");\r\nreturn ret;\r\n}\r\nstatic void __exit ia_module_exit(void)\r\n{\r\npci_unregister_driver(&ia_driver);\r\ndel_timer(&ia_timer);\r\n}
