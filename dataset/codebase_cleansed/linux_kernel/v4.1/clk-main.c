static irqreturn_t clk_main_osc_irq_handler(int irq, void *dev_id)\r\n{\r\nstruct clk_main_osc *osc = dev_id;\r\nwake_up(&osc->wait);\r\ndisable_irq_nosync(osc->irq);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int clk_main_osc_prepare(struct clk_hw *hw)\r\n{\r\nstruct clk_main_osc *osc = to_clk_main_osc(hw);\r\nstruct at91_pmc *pmc = osc->pmc;\r\nu32 tmp;\r\ntmp = pmc_read(pmc, AT91_CKGR_MOR) & ~MOR_KEY_MASK;\r\nif (tmp & AT91_PMC_OSCBYPASS)\r\nreturn 0;\r\nif (!(tmp & AT91_PMC_MOSCEN)) {\r\ntmp |= AT91_PMC_MOSCEN | AT91_PMC_KEY;\r\npmc_write(pmc, AT91_CKGR_MOR, tmp);\r\n}\r\nwhile (!(pmc_read(pmc, AT91_PMC_SR) & AT91_PMC_MOSCS)) {\r\nenable_irq(osc->irq);\r\nwait_event(osc->wait,\r\npmc_read(pmc, AT91_PMC_SR) & AT91_PMC_MOSCS);\r\n}\r\nreturn 0;\r\n}\r\nstatic void clk_main_osc_unprepare(struct clk_hw *hw)\r\n{\r\nstruct clk_main_osc *osc = to_clk_main_osc(hw);\r\nstruct at91_pmc *pmc = osc->pmc;\r\nu32 tmp = pmc_read(pmc, AT91_CKGR_MOR);\r\nif (tmp & AT91_PMC_OSCBYPASS)\r\nreturn;\r\nif (!(tmp & AT91_PMC_MOSCEN))\r\nreturn;\r\ntmp &= ~(AT91_PMC_KEY | AT91_PMC_MOSCEN);\r\npmc_write(pmc, AT91_CKGR_MOR, tmp | AT91_PMC_KEY);\r\n}\r\nstatic int clk_main_osc_is_prepared(struct clk_hw *hw)\r\n{\r\nstruct clk_main_osc *osc = to_clk_main_osc(hw);\r\nstruct at91_pmc *pmc = osc->pmc;\r\nu32 tmp = pmc_read(pmc, AT91_CKGR_MOR);\r\nif (tmp & AT91_PMC_OSCBYPASS)\r\nreturn 1;\r\nreturn !!((pmc_read(pmc, AT91_PMC_SR) & AT91_PMC_MOSCS) &&\r\n(pmc_read(pmc, AT91_CKGR_MOR) & AT91_PMC_MOSCEN));\r\n}\r\nstatic struct clk * __init\r\nat91_clk_register_main_osc(struct at91_pmc *pmc,\r\nunsigned int irq,\r\nconst char *name,\r\nconst char *parent_name,\r\nbool bypass)\r\n{\r\nint ret;\r\nstruct clk_main_osc *osc;\r\nstruct clk *clk = NULL;\r\nstruct clk_init_data init;\r\nif (!pmc || !irq || !name || !parent_name)\r\nreturn ERR_PTR(-EINVAL);\r\nosc = kzalloc(sizeof(*osc), GFP_KERNEL);\r\nif (!osc)\r\nreturn ERR_PTR(-ENOMEM);\r\ninit.name = name;\r\ninit.ops = &main_osc_ops;\r\ninit.parent_names = &parent_name;\r\ninit.num_parents = 1;\r\ninit.flags = CLK_IGNORE_UNUSED;\r\nosc->hw.init = &init;\r\nosc->pmc = pmc;\r\nosc->irq = irq;\r\ninit_waitqueue_head(&osc->wait);\r\nirq_set_status_flags(osc->irq, IRQ_NOAUTOEN);\r\nret = request_irq(osc->irq, clk_main_osc_irq_handler,\r\nIRQF_TRIGGER_HIGH, name, osc);\r\nif (ret)\r\nreturn ERR_PTR(ret);\r\nif (bypass)\r\npmc_write(pmc, AT91_CKGR_MOR,\r\n(pmc_read(pmc, AT91_CKGR_MOR) &\r\n~(MOR_KEY_MASK | AT91_PMC_MOSCEN)) |\r\nAT91_PMC_OSCBYPASS | AT91_PMC_KEY);\r\nclk = clk_register(NULL, &osc->hw);\r\nif (IS_ERR(clk)) {\r\nfree_irq(irq, osc);\r\nkfree(osc);\r\n}\r\nreturn clk;\r\n}\r\nvoid __init of_at91rm9200_clk_main_osc_setup(struct device_node *np,\r\nstruct at91_pmc *pmc)\r\n{\r\nstruct clk *clk;\r\nunsigned int irq;\r\nconst char *name = np->name;\r\nconst char *parent_name;\r\nbool bypass;\r\nof_property_read_string(np, "clock-output-names", &name);\r\nbypass = of_property_read_bool(np, "atmel,osc-bypass");\r\nparent_name = of_clk_get_parent_name(np, 0);\r\nirq = irq_of_parse_and_map(np, 0);\r\nif (!irq)\r\nreturn;\r\nclk = at91_clk_register_main_osc(pmc, irq, name, parent_name, bypass);\r\nif (IS_ERR(clk))\r\nreturn;\r\nof_clk_add_provider(np, of_clk_src_simple_get, clk);\r\n}\r\nstatic irqreturn_t clk_main_rc_osc_irq_handler(int irq, void *dev_id)\r\n{\r\nstruct clk_main_rc_osc *osc = dev_id;\r\nwake_up(&osc->wait);\r\ndisable_irq_nosync(osc->irq);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int clk_main_rc_osc_prepare(struct clk_hw *hw)\r\n{\r\nstruct clk_main_rc_osc *osc = to_clk_main_rc_osc(hw);\r\nstruct at91_pmc *pmc = osc->pmc;\r\nu32 tmp;\r\ntmp = pmc_read(pmc, AT91_CKGR_MOR) & ~MOR_KEY_MASK;\r\nif (!(tmp & AT91_PMC_MOSCRCEN)) {\r\ntmp |= AT91_PMC_MOSCRCEN | AT91_PMC_KEY;\r\npmc_write(pmc, AT91_CKGR_MOR, tmp);\r\n}\r\nwhile (!(pmc_read(pmc, AT91_PMC_SR) & AT91_PMC_MOSCRCS)) {\r\nenable_irq(osc->irq);\r\nwait_event(osc->wait,\r\npmc_read(pmc, AT91_PMC_SR) & AT91_PMC_MOSCRCS);\r\n}\r\nreturn 0;\r\n}\r\nstatic void clk_main_rc_osc_unprepare(struct clk_hw *hw)\r\n{\r\nstruct clk_main_rc_osc *osc = to_clk_main_rc_osc(hw);\r\nstruct at91_pmc *pmc = osc->pmc;\r\nu32 tmp = pmc_read(pmc, AT91_CKGR_MOR);\r\nif (!(tmp & AT91_PMC_MOSCRCEN))\r\nreturn;\r\ntmp &= ~(MOR_KEY_MASK | AT91_PMC_MOSCRCEN);\r\npmc_write(pmc, AT91_CKGR_MOR, tmp | AT91_PMC_KEY);\r\n}\r\nstatic int clk_main_rc_osc_is_prepared(struct clk_hw *hw)\r\n{\r\nstruct clk_main_rc_osc *osc = to_clk_main_rc_osc(hw);\r\nstruct at91_pmc *pmc = osc->pmc;\r\nreturn !!((pmc_read(pmc, AT91_PMC_SR) & AT91_PMC_MOSCRCS) &&\r\n(pmc_read(pmc, AT91_CKGR_MOR) & AT91_PMC_MOSCRCEN));\r\n}\r\nstatic unsigned long clk_main_rc_osc_recalc_rate(struct clk_hw *hw,\r\nunsigned long parent_rate)\r\n{\r\nstruct clk_main_rc_osc *osc = to_clk_main_rc_osc(hw);\r\nreturn osc->frequency;\r\n}\r\nstatic unsigned long clk_main_rc_osc_recalc_accuracy(struct clk_hw *hw,\r\nunsigned long parent_acc)\r\n{\r\nstruct clk_main_rc_osc *osc = to_clk_main_rc_osc(hw);\r\nreturn osc->accuracy;\r\n}\r\nstatic struct clk * __init\r\nat91_clk_register_main_rc_osc(struct at91_pmc *pmc,\r\nunsigned int irq,\r\nconst char *name,\r\nu32 frequency, u32 accuracy)\r\n{\r\nint ret;\r\nstruct clk_main_rc_osc *osc;\r\nstruct clk *clk = NULL;\r\nstruct clk_init_data init;\r\nif (!pmc || !irq || !name || !frequency)\r\nreturn ERR_PTR(-EINVAL);\r\nosc = kzalloc(sizeof(*osc), GFP_KERNEL);\r\nif (!osc)\r\nreturn ERR_PTR(-ENOMEM);\r\ninit.name = name;\r\ninit.ops = &main_rc_osc_ops;\r\ninit.parent_names = NULL;\r\ninit.num_parents = 0;\r\ninit.flags = CLK_IS_ROOT | CLK_IGNORE_UNUSED;\r\nosc->hw.init = &init;\r\nosc->pmc = pmc;\r\nosc->irq = irq;\r\nosc->frequency = frequency;\r\nosc->accuracy = accuracy;\r\ninit_waitqueue_head(&osc->wait);\r\nirq_set_status_flags(osc->irq, IRQ_NOAUTOEN);\r\nret = request_irq(osc->irq, clk_main_rc_osc_irq_handler,\r\nIRQF_TRIGGER_HIGH, name, osc);\r\nif (ret)\r\nreturn ERR_PTR(ret);\r\nclk = clk_register(NULL, &osc->hw);\r\nif (IS_ERR(clk)) {\r\nfree_irq(irq, osc);\r\nkfree(osc);\r\n}\r\nreturn clk;\r\n}\r\nvoid __init of_at91sam9x5_clk_main_rc_osc_setup(struct device_node *np,\r\nstruct at91_pmc *pmc)\r\n{\r\nstruct clk *clk;\r\nunsigned int irq;\r\nu32 frequency = 0;\r\nu32 accuracy = 0;\r\nconst char *name = np->name;\r\nof_property_read_string(np, "clock-output-names", &name);\r\nof_property_read_u32(np, "clock-frequency", &frequency);\r\nof_property_read_u32(np, "clock-accuracy", &accuracy);\r\nirq = irq_of_parse_and_map(np, 0);\r\nif (!irq)\r\nreturn;\r\nclk = at91_clk_register_main_rc_osc(pmc, irq, name, frequency,\r\naccuracy);\r\nif (IS_ERR(clk))\r\nreturn;\r\nof_clk_add_provider(np, of_clk_src_simple_get, clk);\r\n}\r\nstatic int clk_main_probe_frequency(struct at91_pmc *pmc)\r\n{\r\nunsigned long prep_time, timeout;\r\nu32 tmp;\r\ntimeout = jiffies + usecs_to_jiffies(MAINFRDY_TIMEOUT);\r\ndo {\r\nprep_time = jiffies;\r\ntmp = pmc_read(pmc, AT91_CKGR_MCFR);\r\nif (tmp & AT91_PMC_MAINRDY)\r\nreturn 0;\r\nusleep_range(MAINF_LOOP_MIN_WAIT, MAINF_LOOP_MAX_WAIT);\r\n} while (time_before(prep_time, timeout));\r\nreturn -ETIMEDOUT;\r\n}\r\nstatic unsigned long clk_main_recalc_rate(struct at91_pmc *pmc,\r\nunsigned long parent_rate)\r\n{\r\nu32 tmp;\r\nif (parent_rate)\r\nreturn parent_rate;\r\npr_warn("Main crystal frequency not set, using approximate value\n");\r\ntmp = pmc_read(pmc, AT91_CKGR_MCFR);\r\nif (!(tmp & AT91_PMC_MAINRDY))\r\nreturn 0;\r\nreturn ((tmp & AT91_PMC_MAINF) * SLOW_CLOCK_FREQ) / MAINF_DIV;\r\n}\r\nstatic int clk_rm9200_main_prepare(struct clk_hw *hw)\r\n{\r\nstruct clk_rm9200_main *clkmain = to_clk_rm9200_main(hw);\r\nreturn clk_main_probe_frequency(clkmain->pmc);\r\n}\r\nstatic int clk_rm9200_main_is_prepared(struct clk_hw *hw)\r\n{\r\nstruct clk_rm9200_main *clkmain = to_clk_rm9200_main(hw);\r\nreturn !!(pmc_read(clkmain->pmc, AT91_CKGR_MCFR) & AT91_PMC_MAINRDY);\r\n}\r\nstatic unsigned long clk_rm9200_main_recalc_rate(struct clk_hw *hw,\r\nunsigned long parent_rate)\r\n{\r\nstruct clk_rm9200_main *clkmain = to_clk_rm9200_main(hw);\r\nreturn clk_main_recalc_rate(clkmain->pmc, parent_rate);\r\n}\r\nstatic struct clk * __init\r\nat91_clk_register_rm9200_main(struct at91_pmc *pmc,\r\nconst char *name,\r\nconst char *parent_name)\r\n{\r\nstruct clk_rm9200_main *clkmain;\r\nstruct clk *clk = NULL;\r\nstruct clk_init_data init;\r\nif (!pmc || !name)\r\nreturn ERR_PTR(-EINVAL);\r\nif (!parent_name)\r\nreturn ERR_PTR(-EINVAL);\r\nclkmain = kzalloc(sizeof(*clkmain), GFP_KERNEL);\r\nif (!clkmain)\r\nreturn ERR_PTR(-ENOMEM);\r\ninit.name = name;\r\ninit.ops = &rm9200_main_ops;\r\ninit.parent_names = &parent_name;\r\ninit.num_parents = 1;\r\ninit.flags = 0;\r\nclkmain->hw.init = &init;\r\nclkmain->pmc = pmc;\r\nclk = clk_register(NULL, &clkmain->hw);\r\nif (IS_ERR(clk))\r\nkfree(clkmain);\r\nreturn clk;\r\n}\r\nvoid __init of_at91rm9200_clk_main_setup(struct device_node *np,\r\nstruct at91_pmc *pmc)\r\n{\r\nstruct clk *clk;\r\nconst char *parent_name;\r\nconst char *name = np->name;\r\nparent_name = of_clk_get_parent_name(np, 0);\r\nof_property_read_string(np, "clock-output-names", &name);\r\nclk = at91_clk_register_rm9200_main(pmc, name, parent_name);\r\nif (IS_ERR(clk))\r\nreturn;\r\nof_clk_add_provider(np, of_clk_src_simple_get, clk);\r\n}\r\nstatic irqreturn_t clk_sam9x5_main_irq_handler(int irq, void *dev_id)\r\n{\r\nstruct clk_sam9x5_main *clkmain = dev_id;\r\nwake_up(&clkmain->wait);\r\ndisable_irq_nosync(clkmain->irq);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int clk_sam9x5_main_prepare(struct clk_hw *hw)\r\n{\r\nstruct clk_sam9x5_main *clkmain = to_clk_sam9x5_main(hw);\r\nstruct at91_pmc *pmc = clkmain->pmc;\r\nwhile (!(pmc_read(pmc, AT91_PMC_SR) & AT91_PMC_MOSCSELS)) {\r\nenable_irq(clkmain->irq);\r\nwait_event(clkmain->wait,\r\npmc_read(pmc, AT91_PMC_SR) & AT91_PMC_MOSCSELS);\r\n}\r\nreturn clk_main_probe_frequency(pmc);\r\n}\r\nstatic int clk_sam9x5_main_is_prepared(struct clk_hw *hw)\r\n{\r\nstruct clk_sam9x5_main *clkmain = to_clk_sam9x5_main(hw);\r\nreturn !!(pmc_read(clkmain->pmc, AT91_PMC_SR) & AT91_PMC_MOSCSELS);\r\n}\r\nstatic unsigned long clk_sam9x5_main_recalc_rate(struct clk_hw *hw,\r\nunsigned long parent_rate)\r\n{\r\nstruct clk_sam9x5_main *clkmain = to_clk_sam9x5_main(hw);\r\nreturn clk_main_recalc_rate(clkmain->pmc, parent_rate);\r\n}\r\nstatic int clk_sam9x5_main_set_parent(struct clk_hw *hw, u8 index)\r\n{\r\nstruct clk_sam9x5_main *clkmain = to_clk_sam9x5_main(hw);\r\nstruct at91_pmc *pmc = clkmain->pmc;\r\nu32 tmp;\r\nif (index > 1)\r\nreturn -EINVAL;\r\ntmp = pmc_read(pmc, AT91_CKGR_MOR) & ~MOR_KEY_MASK;\r\nif (index && !(tmp & AT91_PMC_MOSCSEL))\r\npmc_write(pmc, AT91_CKGR_MOR, tmp | AT91_PMC_MOSCSEL);\r\nelse if (!index && (tmp & AT91_PMC_MOSCSEL))\r\npmc_write(pmc, AT91_CKGR_MOR, tmp & ~AT91_PMC_MOSCSEL);\r\nwhile (!(pmc_read(pmc, AT91_PMC_SR) & AT91_PMC_MOSCSELS)) {\r\nenable_irq(clkmain->irq);\r\nwait_event(clkmain->wait,\r\npmc_read(pmc, AT91_PMC_SR) & AT91_PMC_MOSCSELS);\r\n}\r\nreturn 0;\r\n}\r\nstatic u8 clk_sam9x5_main_get_parent(struct clk_hw *hw)\r\n{\r\nstruct clk_sam9x5_main *clkmain = to_clk_sam9x5_main(hw);\r\nreturn !!(pmc_read(clkmain->pmc, AT91_CKGR_MOR) & AT91_PMC_MOSCEN);\r\n}\r\nstatic struct clk * __init\r\nat91_clk_register_sam9x5_main(struct at91_pmc *pmc,\r\nunsigned int irq,\r\nconst char *name,\r\nconst char **parent_names,\r\nint num_parents)\r\n{\r\nint ret;\r\nstruct clk_sam9x5_main *clkmain;\r\nstruct clk *clk = NULL;\r\nstruct clk_init_data init;\r\nif (!pmc || !irq || !name)\r\nreturn ERR_PTR(-EINVAL);\r\nif (!parent_names || !num_parents)\r\nreturn ERR_PTR(-EINVAL);\r\nclkmain = kzalloc(sizeof(*clkmain), GFP_KERNEL);\r\nif (!clkmain)\r\nreturn ERR_PTR(-ENOMEM);\r\ninit.name = name;\r\ninit.ops = &sam9x5_main_ops;\r\ninit.parent_names = parent_names;\r\ninit.num_parents = num_parents;\r\ninit.flags = CLK_SET_PARENT_GATE;\r\nclkmain->hw.init = &init;\r\nclkmain->pmc = pmc;\r\nclkmain->irq = irq;\r\nclkmain->parent = !!(pmc_read(clkmain->pmc, AT91_CKGR_MOR) &\r\nAT91_PMC_MOSCEN);\r\ninit_waitqueue_head(&clkmain->wait);\r\nirq_set_status_flags(clkmain->irq, IRQ_NOAUTOEN);\r\nret = request_irq(clkmain->irq, clk_sam9x5_main_irq_handler,\r\nIRQF_TRIGGER_HIGH, name, clkmain);\r\nif (ret)\r\nreturn ERR_PTR(ret);\r\nclk = clk_register(NULL, &clkmain->hw);\r\nif (IS_ERR(clk)) {\r\nfree_irq(clkmain->irq, clkmain);\r\nkfree(clkmain);\r\n}\r\nreturn clk;\r\n}\r\nvoid __init of_at91sam9x5_clk_main_setup(struct device_node *np,\r\nstruct at91_pmc *pmc)\r\n{\r\nstruct clk *clk;\r\nconst char *parent_names[2];\r\nint num_parents;\r\nunsigned int irq;\r\nconst char *name = np->name;\r\nint i;\r\nnum_parents = of_count_phandle_with_args(np, "clocks", "#clock-cells");\r\nif (num_parents <= 0 || num_parents > 2)\r\nreturn;\r\nfor (i = 0; i < num_parents; ++i) {\r\nparent_names[i] = of_clk_get_parent_name(np, i);\r\nif (!parent_names[i])\r\nreturn;\r\n}\r\nof_property_read_string(np, "clock-output-names", &name);\r\nirq = irq_of_parse_and_map(np, 0);\r\nif (!irq)\r\nreturn;\r\nclk = at91_clk_register_sam9x5_main(pmc, irq, name, parent_names,\r\nnum_parents);\r\nif (IS_ERR(clk))\r\nreturn;\r\nof_clk_add_provider(np, of_clk_src_simple_get, clk);\r\n}
