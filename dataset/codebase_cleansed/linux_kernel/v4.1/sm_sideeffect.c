static void sctp_do_ecn_ce_work(struct sctp_association *asoc,\r\n__u32 lowest_tsn)\r\n{\r\nasoc->last_ecne_tsn = lowest_tsn;\r\nasoc->need_ecne = 1;\r\n}\r\nstatic struct sctp_chunk *sctp_do_ecn_ecne_work(struct sctp_association *asoc,\r\n__u32 lowest_tsn,\r\nstruct sctp_chunk *chunk)\r\n{\r\nstruct sctp_chunk *repl;\r\nif (TSN_lt(asoc->last_cwr_tsn, lowest_tsn)) {\r\nstruct sctp_transport *transport;\r\ntransport = sctp_assoc_lookup_tsn(asoc, lowest_tsn);\r\nif (transport)\r\nsctp_transport_lower_cwnd(transport,\r\nSCTP_LOWER_CWND_ECNE);\r\nasoc->last_cwr_tsn = lowest_tsn;\r\n}\r\nrepl = sctp_make_cwr(asoc, asoc->last_cwr_tsn, chunk);\r\nreturn repl;\r\n}\r\nstatic void sctp_do_ecn_cwr_work(struct sctp_association *asoc,\r\n__u32 lowest_tsn)\r\n{\r\nasoc->need_ecne = 0;\r\n}\r\nstatic int sctp_gen_sack(struct sctp_association *asoc, int force,\r\nsctp_cmd_seq_t *commands)\r\n{\r\n__u32 ctsn, max_tsn_seen;\r\nstruct sctp_chunk *sack;\r\nstruct sctp_transport *trans = asoc->peer.last_data_from;\r\nint error = 0;\r\nif (force ||\r\n(!trans && (asoc->param_flags & SPP_SACKDELAY_DISABLE)) ||\r\n(trans && (trans->param_flags & SPP_SACKDELAY_DISABLE)))\r\nasoc->peer.sack_needed = 1;\r\nctsn = sctp_tsnmap_get_ctsn(&asoc->peer.tsn_map);\r\nmax_tsn_seen = sctp_tsnmap_get_max_tsn_seen(&asoc->peer.tsn_map);\r\nif (max_tsn_seen != ctsn)\r\nasoc->peer.sack_needed = 1;\r\nif (!asoc->peer.sack_needed) {\r\nasoc->peer.sack_cnt++;\r\nif (trans) {\r\nif (asoc->peer.sack_cnt >= trans->sackfreq - 1)\r\nasoc->peer.sack_needed = 1;\r\nasoc->timeouts[SCTP_EVENT_TIMEOUT_SACK] =\r\ntrans->sackdelay;\r\n} else {\r\nif (asoc->peer.sack_cnt >= asoc->sackfreq - 1)\r\nasoc->peer.sack_needed = 1;\r\nasoc->timeouts[SCTP_EVENT_TIMEOUT_SACK] =\r\nasoc->sackdelay;\r\n}\r\nsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_RESTART,\r\nSCTP_TO(SCTP_EVENT_TIMEOUT_SACK));\r\n} else {\r\nasoc->a_rwnd = asoc->rwnd;\r\nsack = sctp_make_sack(asoc);\r\nif (!sack)\r\ngoto nomem;\r\nasoc->peer.sack_needed = 0;\r\nasoc->peer.sack_cnt = 0;\r\nsctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(sack));\r\nsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_STOP,\r\nSCTP_TO(SCTP_EVENT_TIMEOUT_SACK));\r\n}\r\nreturn error;\r\nnomem:\r\nerror = -ENOMEM;\r\nreturn error;\r\n}\r\nvoid sctp_generate_t3_rtx_event(unsigned long peer)\r\n{\r\nint error;\r\nstruct sctp_transport *transport = (struct sctp_transport *) peer;\r\nstruct sctp_association *asoc = transport->asoc;\r\nstruct net *net = sock_net(asoc->base.sk);\r\nbh_lock_sock(asoc->base.sk);\r\nif (sock_owned_by_user(asoc->base.sk)) {\r\npr_debug("%s: sock is busy\n", __func__);\r\nif (!mod_timer(&transport->T3_rtx_timer, jiffies + (HZ/20)))\r\nsctp_transport_hold(transport);\r\ngoto out_unlock;\r\n}\r\nif (transport->dead)\r\ngoto out_unlock;\r\nerror = sctp_do_sm(net, SCTP_EVENT_T_TIMEOUT,\r\nSCTP_ST_TIMEOUT(SCTP_EVENT_TIMEOUT_T3_RTX),\r\nasoc->state,\r\nasoc->ep, asoc,\r\ntransport, GFP_ATOMIC);\r\nif (error)\r\nasoc->base.sk->sk_err = -error;\r\nout_unlock:\r\nbh_unlock_sock(asoc->base.sk);\r\nsctp_transport_put(transport);\r\n}\r\nstatic void sctp_generate_timeout_event(struct sctp_association *asoc,\r\nsctp_event_timeout_t timeout_type)\r\n{\r\nstruct net *net = sock_net(asoc->base.sk);\r\nint error = 0;\r\nbh_lock_sock(asoc->base.sk);\r\nif (sock_owned_by_user(asoc->base.sk)) {\r\npr_debug("%s: sock is busy: timer %d\n", __func__,\r\ntimeout_type);\r\nif (!mod_timer(&asoc->timers[timeout_type], jiffies + (HZ/20)))\r\nsctp_association_hold(asoc);\r\ngoto out_unlock;\r\n}\r\nif (asoc->base.dead)\r\ngoto out_unlock;\r\nerror = sctp_do_sm(net, SCTP_EVENT_T_TIMEOUT,\r\nSCTP_ST_TIMEOUT(timeout_type),\r\nasoc->state, asoc->ep, asoc,\r\n(void *)timeout_type, GFP_ATOMIC);\r\nif (error)\r\nasoc->base.sk->sk_err = -error;\r\nout_unlock:\r\nbh_unlock_sock(asoc->base.sk);\r\nsctp_association_put(asoc);\r\n}\r\nstatic void sctp_generate_t1_cookie_event(unsigned long data)\r\n{\r\nstruct sctp_association *asoc = (struct sctp_association *) data;\r\nsctp_generate_timeout_event(asoc, SCTP_EVENT_TIMEOUT_T1_COOKIE);\r\n}\r\nstatic void sctp_generate_t1_init_event(unsigned long data)\r\n{\r\nstruct sctp_association *asoc = (struct sctp_association *) data;\r\nsctp_generate_timeout_event(asoc, SCTP_EVENT_TIMEOUT_T1_INIT);\r\n}\r\nstatic void sctp_generate_t2_shutdown_event(unsigned long data)\r\n{\r\nstruct sctp_association *asoc = (struct sctp_association *) data;\r\nsctp_generate_timeout_event(asoc, SCTP_EVENT_TIMEOUT_T2_SHUTDOWN);\r\n}\r\nstatic void sctp_generate_t4_rto_event(unsigned long data)\r\n{\r\nstruct sctp_association *asoc = (struct sctp_association *) data;\r\nsctp_generate_timeout_event(asoc, SCTP_EVENT_TIMEOUT_T4_RTO);\r\n}\r\nstatic void sctp_generate_t5_shutdown_guard_event(unsigned long data)\r\n{\r\nstruct sctp_association *asoc = (struct sctp_association *)data;\r\nsctp_generate_timeout_event(asoc,\r\nSCTP_EVENT_TIMEOUT_T5_SHUTDOWN_GUARD);\r\n}\r\nstatic void sctp_generate_autoclose_event(unsigned long data)\r\n{\r\nstruct sctp_association *asoc = (struct sctp_association *) data;\r\nsctp_generate_timeout_event(asoc, SCTP_EVENT_TIMEOUT_AUTOCLOSE);\r\n}\r\nvoid sctp_generate_heartbeat_event(unsigned long data)\r\n{\r\nint error = 0;\r\nstruct sctp_transport *transport = (struct sctp_transport *) data;\r\nstruct sctp_association *asoc = transport->asoc;\r\nstruct net *net = sock_net(asoc->base.sk);\r\nbh_lock_sock(asoc->base.sk);\r\nif (sock_owned_by_user(asoc->base.sk)) {\r\npr_debug("%s: sock is busy\n", __func__);\r\nif (!mod_timer(&transport->hb_timer, jiffies + (HZ/20)))\r\nsctp_transport_hold(transport);\r\ngoto out_unlock;\r\n}\r\nif (transport->dead)\r\ngoto out_unlock;\r\nerror = sctp_do_sm(net, SCTP_EVENT_T_TIMEOUT,\r\nSCTP_ST_TIMEOUT(SCTP_EVENT_TIMEOUT_HEARTBEAT),\r\nasoc->state, asoc->ep, asoc,\r\ntransport, GFP_ATOMIC);\r\nif (error)\r\nasoc->base.sk->sk_err = -error;\r\nout_unlock:\r\nbh_unlock_sock(asoc->base.sk);\r\nsctp_transport_put(transport);\r\n}\r\nvoid sctp_generate_proto_unreach_event(unsigned long data)\r\n{\r\nstruct sctp_transport *transport = (struct sctp_transport *) data;\r\nstruct sctp_association *asoc = transport->asoc;\r\nstruct net *net = sock_net(asoc->base.sk);\r\nbh_lock_sock(asoc->base.sk);\r\nif (sock_owned_by_user(asoc->base.sk)) {\r\npr_debug("%s: sock is busy\n", __func__);\r\nif (!mod_timer(&transport->proto_unreach_timer,\r\njiffies + (HZ/20)))\r\nsctp_association_hold(asoc);\r\ngoto out_unlock;\r\n}\r\nif (asoc->base.dead)\r\ngoto out_unlock;\r\nsctp_do_sm(net, SCTP_EVENT_T_OTHER,\r\nSCTP_ST_OTHER(SCTP_EVENT_ICMP_PROTO_UNREACH),\r\nasoc->state, asoc->ep, asoc, transport, GFP_ATOMIC);\r\nout_unlock:\r\nbh_unlock_sock(asoc->base.sk);\r\nsctp_association_put(asoc);\r\n}\r\nstatic void sctp_generate_sack_event(unsigned long data)\r\n{\r\nstruct sctp_association *asoc = (struct sctp_association *) data;\r\nsctp_generate_timeout_event(asoc, SCTP_EVENT_TIMEOUT_SACK);\r\n}\r\nstatic void sctp_do_8_2_transport_strike(sctp_cmd_seq_t *commands,\r\nstruct sctp_association *asoc,\r\nstruct sctp_transport *transport,\r\nint is_hb)\r\n{\r\nif (!is_hb) {\r\nasoc->overall_error_count++;\r\nif (transport->state != SCTP_INACTIVE)\r\ntransport->error_count++;\r\n} else if (transport->hb_sent) {\r\nif (transport->state != SCTP_UNCONFIRMED)\r\nasoc->overall_error_count++;\r\nif (transport->state != SCTP_INACTIVE)\r\ntransport->error_count++;\r\n}\r\nif ((transport->state == SCTP_ACTIVE) &&\r\n(asoc->pf_retrans < transport->pathmaxrxt) &&\r\n(transport->error_count > asoc->pf_retrans)) {\r\nsctp_assoc_control_transport(asoc, transport,\r\nSCTP_TRANSPORT_PF,\r\n0);\r\nsctp_cmd_hb_timer_update(commands, transport);\r\n}\r\nif (transport->state != SCTP_INACTIVE &&\r\n(transport->error_count > transport->pathmaxrxt)) {\r\npr_debug("%s: association:%p transport addr:%pISpc failed\n",\r\n__func__, asoc, &transport->ipaddr.sa);\r\nsctp_assoc_control_transport(asoc, transport,\r\nSCTP_TRANSPORT_DOWN,\r\nSCTP_FAILED_THRESHOLD);\r\n}\r\nif (!is_hb || transport->hb_sent) {\r\ntransport->rto = min((transport->rto * 2), transport->asoc->rto_max);\r\nsctp_max_rto(asoc, transport);\r\n}\r\n}\r\nstatic void sctp_cmd_init_failed(sctp_cmd_seq_t *commands,\r\nstruct sctp_association *asoc,\r\nunsigned int error)\r\n{\r\nstruct sctp_ulpevent *event;\r\nevent = sctp_ulpevent_make_assoc_change(asoc, 0, SCTP_CANT_STR_ASSOC,\r\n(__u16)error, 0, 0, NULL,\r\nGFP_ATOMIC);\r\nif (event)\r\nsctp_add_cmd_sf(commands, SCTP_CMD_EVENT_ULP,\r\nSCTP_ULPEVENT(event));\r\nsctp_add_cmd_sf(commands, SCTP_CMD_NEW_STATE,\r\nSCTP_STATE(SCTP_STATE_CLOSED));\r\nasoc->outqueue.error = error;\r\nsctp_add_cmd_sf(commands, SCTP_CMD_DELETE_TCB, SCTP_NULL());\r\n}\r\nstatic void sctp_cmd_assoc_failed(sctp_cmd_seq_t *commands,\r\nstruct sctp_association *asoc,\r\nsctp_event_t event_type,\r\nsctp_subtype_t subtype,\r\nstruct sctp_chunk *chunk,\r\nunsigned int error)\r\n{\r\nstruct sctp_ulpevent *event;\r\nstruct sctp_chunk *abort;\r\nsctp_ulpq_abort_pd(&asoc->ulpq, GFP_ATOMIC);\r\nif (event_type == SCTP_EVENT_T_CHUNK && subtype.chunk == SCTP_CID_ABORT)\r\nevent = sctp_ulpevent_make_assoc_change(asoc, 0, SCTP_COMM_LOST,\r\n(__u16)error, 0, 0, chunk,\r\nGFP_ATOMIC);\r\nelse\r\nevent = sctp_ulpevent_make_assoc_change(asoc, 0, SCTP_COMM_LOST,\r\n(__u16)error, 0, 0, NULL,\r\nGFP_ATOMIC);\r\nif (event)\r\nsctp_add_cmd_sf(commands, SCTP_CMD_EVENT_ULP,\r\nSCTP_ULPEVENT(event));\r\nif (asoc->overall_error_count >= asoc->max_retrans) {\r\nabort = sctp_make_violation_max_retrans(asoc, chunk);\r\nif (abort)\r\nsctp_add_cmd_sf(commands, SCTP_CMD_REPLY,\r\nSCTP_CHUNK(abort));\r\n}\r\nsctp_add_cmd_sf(commands, SCTP_CMD_NEW_STATE,\r\nSCTP_STATE(SCTP_STATE_CLOSED));\r\nasoc->outqueue.error = error;\r\nsctp_add_cmd_sf(commands, SCTP_CMD_DELETE_TCB, SCTP_NULL());\r\n}\r\nstatic int sctp_cmd_process_init(sctp_cmd_seq_t *commands,\r\nstruct sctp_association *asoc,\r\nstruct sctp_chunk *chunk,\r\nsctp_init_chunk_t *peer_init,\r\ngfp_t gfp)\r\n{\r\nint error;\r\nif (!sctp_process_init(asoc, chunk, sctp_source(chunk), peer_init, gfp))\r\nerror = -ENOMEM;\r\nelse\r\nerror = 0;\r\nreturn error;\r\n}\r\nstatic void sctp_cmd_hb_timers_start(sctp_cmd_seq_t *cmds,\r\nstruct sctp_association *asoc)\r\n{\r\nstruct sctp_transport *t;\r\nlist_for_each_entry(t, &asoc->peer.transport_addr_list, transports) {\r\nif (!mod_timer(&t->hb_timer, sctp_transport_timeout(t)))\r\nsctp_transport_hold(t);\r\n}\r\n}\r\nstatic void sctp_cmd_hb_timers_stop(sctp_cmd_seq_t *cmds,\r\nstruct sctp_association *asoc)\r\n{\r\nstruct sctp_transport *t;\r\nlist_for_each_entry(t, &asoc->peer.transport_addr_list,\r\ntransports) {\r\nif (del_timer(&t->hb_timer))\r\nsctp_transport_put(t);\r\n}\r\n}\r\nstatic void sctp_cmd_t3_rtx_timers_stop(sctp_cmd_seq_t *cmds,\r\nstruct sctp_association *asoc)\r\n{\r\nstruct sctp_transport *t;\r\nlist_for_each_entry(t, &asoc->peer.transport_addr_list,\r\ntransports) {\r\nif (del_timer(&t->T3_rtx_timer))\r\nsctp_transport_put(t);\r\n}\r\n}\r\nstatic void sctp_cmd_hb_timer_update(sctp_cmd_seq_t *cmds,\r\nstruct sctp_transport *t)\r\n{\r\nif (!mod_timer(&t->hb_timer, sctp_transport_timeout(t)))\r\nsctp_transport_hold(t);\r\n}\r\nstatic void sctp_cmd_transport_on(sctp_cmd_seq_t *cmds,\r\nstruct sctp_association *asoc,\r\nstruct sctp_transport *t,\r\nstruct sctp_chunk *chunk)\r\n{\r\nsctp_sender_hb_info_t *hbinfo;\r\nint was_unconfirmed = 0;\r\nt->error_count = 0;\r\nif (t->asoc->state != SCTP_STATE_SHUTDOWN_PENDING)\r\nt->asoc->overall_error_count = 0;\r\nt->hb_sent = 0;\r\nif ((t->state == SCTP_INACTIVE) || (t->state == SCTP_UNCONFIRMED)) {\r\nwas_unconfirmed = 1;\r\nsctp_assoc_control_transport(asoc, t, SCTP_TRANSPORT_UP,\r\nSCTP_HEARTBEAT_SUCCESS);\r\n}\r\nif (t->state == SCTP_PF)\r\nsctp_assoc_control_transport(asoc, t, SCTP_TRANSPORT_UP,\r\nSCTP_HEARTBEAT_SUCCESS);\r\nif (t->dst)\r\ndst_confirm(t->dst);\r\nif (t->rto_pending == 0)\r\nt->rto_pending = 1;\r\nhbinfo = (sctp_sender_hb_info_t *) chunk->skb->data;\r\nsctp_transport_update_rto(t, (jiffies - hbinfo->sent_at));\r\nif (!mod_timer(&t->hb_timer, sctp_transport_timeout(t)))\r\nsctp_transport_hold(t);\r\nif (was_unconfirmed && asoc->peer.transport_count == 1)\r\nsctp_transport_immediate_rtx(t);\r\n}\r\nstatic int sctp_cmd_process_sack(sctp_cmd_seq_t *cmds,\r\nstruct sctp_association *asoc,\r\nstruct sctp_chunk *chunk)\r\n{\r\nint err = 0;\r\nif (sctp_outq_sack(&asoc->outqueue, chunk)) {\r\nstruct net *net = sock_net(asoc->base.sk);\r\nerr = sctp_do_sm(net, SCTP_EVENT_T_OTHER,\r\nSCTP_ST_OTHER(SCTP_EVENT_NO_PENDING_TSN),\r\nasoc->state, asoc->ep, asoc, NULL,\r\nGFP_ATOMIC);\r\n}\r\nreturn err;\r\n}\r\nstatic void sctp_cmd_setup_t2(sctp_cmd_seq_t *cmds,\r\nstruct sctp_association *asoc,\r\nstruct sctp_chunk *chunk)\r\n{\r\nstruct sctp_transport *t;\r\nif (chunk->transport)\r\nt = chunk->transport;\r\nelse {\r\nt = sctp_assoc_choose_alter_transport(asoc,\r\nasoc->shutdown_last_sent_to);\r\nchunk->transport = t;\r\n}\r\nasoc->shutdown_last_sent_to = t;\r\nasoc->timeouts[SCTP_EVENT_TIMEOUT_T2_SHUTDOWN] = t->rto;\r\n}\r\nstatic void sctp_cmd_new_state(sctp_cmd_seq_t *cmds,\r\nstruct sctp_association *asoc,\r\nsctp_state_t state)\r\n{\r\nstruct sock *sk = asoc->base.sk;\r\nasoc->state = state;\r\npr_debug("%s: asoc:%p[%s]\n", __func__, asoc, sctp_state_tbl[state]);\r\nif (sctp_style(sk, TCP)) {\r\nif (sctp_state(asoc, ESTABLISHED) && sctp_sstate(sk, CLOSED))\r\nsk->sk_state = SCTP_SS_ESTABLISHED;\r\nif (sctp_state(asoc, SHUTDOWN_RECEIVED) &&\r\nsctp_sstate(sk, ESTABLISHED))\r\nsk->sk_shutdown |= RCV_SHUTDOWN;\r\n}\r\nif (sctp_state(asoc, COOKIE_WAIT)) {\r\nasoc->timeouts[SCTP_EVENT_TIMEOUT_T1_INIT] =\r\nasoc->rto_initial;\r\nasoc->timeouts[SCTP_EVENT_TIMEOUT_T1_COOKIE] =\r\nasoc->rto_initial;\r\n}\r\nif (sctp_state(asoc, ESTABLISHED) ||\r\nsctp_state(asoc, CLOSED) ||\r\nsctp_state(asoc, SHUTDOWN_RECEIVED)) {\r\nif (waitqueue_active(&asoc->wait))\r\nwake_up_interruptible(&asoc->wait);\r\nif (!sctp_style(sk, UDP))\r\nsk->sk_state_change(sk);\r\n}\r\n}\r\nstatic void sctp_cmd_delete_tcb(sctp_cmd_seq_t *cmds,\r\nstruct sctp_association *asoc)\r\n{\r\nstruct sock *sk = asoc->base.sk;\r\nif (sctp_style(sk, TCP) && sctp_sstate(sk, LISTENING) &&\r\n(!asoc->temp) && (sk->sk_shutdown != SHUTDOWN_MASK))\r\nreturn;\r\nsctp_unhash_established(asoc);\r\nsctp_association_free(asoc);\r\n}\r\nstatic void sctp_cmd_setup_t4(sctp_cmd_seq_t *cmds,\r\nstruct sctp_association *asoc,\r\nstruct sctp_chunk *chunk)\r\n{\r\nstruct sctp_transport *t;\r\nt = sctp_assoc_choose_alter_transport(asoc, chunk->transport);\r\nasoc->timeouts[SCTP_EVENT_TIMEOUT_T4_RTO] = t->rto;\r\nchunk->transport = t;\r\n}\r\nstatic void sctp_cmd_process_operr(sctp_cmd_seq_t *cmds,\r\nstruct sctp_association *asoc,\r\nstruct sctp_chunk *chunk)\r\n{\r\nstruct sctp_errhdr *err_hdr;\r\nstruct sctp_ulpevent *ev;\r\nwhile (chunk->chunk_end > chunk->skb->data) {\r\nerr_hdr = (struct sctp_errhdr *)(chunk->skb->data);\r\nev = sctp_ulpevent_make_remote_error(asoc, chunk, 0,\r\nGFP_ATOMIC);\r\nif (!ev)\r\nreturn;\r\nsctp_ulpq_tail_event(&asoc->ulpq, ev);\r\nswitch (err_hdr->cause) {\r\ncase SCTP_ERROR_UNKNOWN_CHUNK:\r\n{\r\nsctp_chunkhdr_t *unk_chunk_hdr;\r\nunk_chunk_hdr = (sctp_chunkhdr_t *)err_hdr->variable;\r\nswitch (unk_chunk_hdr->type) {\r\ncase SCTP_CID_ASCONF:\r\nif (asoc->peer.asconf_capable == 0)\r\nbreak;\r\nasoc->peer.asconf_capable = 0;\r\nsctp_add_cmd_sf(cmds, SCTP_CMD_TIMER_STOP,\r\nSCTP_TO(SCTP_EVENT_TIMEOUT_T4_RTO));\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nbreak;\r\n}\r\ndefault:\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic void sctp_cmd_process_fwdtsn(struct sctp_ulpq *ulpq,\r\nstruct sctp_chunk *chunk)\r\n{\r\nstruct sctp_fwdtsn_skip *skip;\r\nsctp_walk_fwdtsn(skip, chunk) {\r\nsctp_ulpq_skip(ulpq, ntohs(skip->stream), ntohs(skip->ssn));\r\n}\r\n}\r\nstatic void sctp_cmd_del_non_primary(struct sctp_association *asoc)\r\n{\r\nstruct sctp_transport *t;\r\nstruct list_head *pos;\r\nstruct list_head *temp;\r\nlist_for_each_safe(pos, temp, &asoc->peer.transport_addr_list) {\r\nt = list_entry(pos, struct sctp_transport, transports);\r\nif (!sctp_cmp_addr_exact(&t->ipaddr,\r\n&asoc->peer.primary_addr)) {\r\nsctp_assoc_del_peer(asoc, &t->ipaddr);\r\n}\r\n}\r\n}\r\nstatic void sctp_cmd_set_sk_err(struct sctp_association *asoc, int error)\r\n{\r\nstruct sock *sk = asoc->base.sk;\r\nif (!sctp_style(sk, UDP))\r\nsk->sk_err = error;\r\n}\r\nstatic void sctp_cmd_assoc_change(sctp_cmd_seq_t *commands,\r\nstruct sctp_association *asoc,\r\nu8 state)\r\n{\r\nstruct sctp_ulpevent *ev;\r\nev = sctp_ulpevent_make_assoc_change(asoc, 0, state, 0,\r\nasoc->c.sinit_num_ostreams,\r\nasoc->c.sinit_max_instreams,\r\nNULL, GFP_ATOMIC);\r\nif (ev)\r\nsctp_ulpq_tail_event(&asoc->ulpq, ev);\r\n}\r\nstatic void sctp_cmd_adaptation_ind(sctp_cmd_seq_t *commands,\r\nstruct sctp_association *asoc)\r\n{\r\nstruct sctp_ulpevent *ev;\r\nev = sctp_ulpevent_make_adaptation_indication(asoc, GFP_ATOMIC);\r\nif (ev)\r\nsctp_ulpq_tail_event(&asoc->ulpq, ev);\r\n}\r\nstatic void sctp_cmd_t1_timer_update(struct sctp_association *asoc,\r\nsctp_event_timeout_t timer,\r\nchar *name)\r\n{\r\nstruct sctp_transport *t;\r\nt = asoc->init_last_sent_to;\r\nasoc->init_err_counter++;\r\nif (t->init_sent_count > (asoc->init_cycle + 1)) {\r\nasoc->timeouts[timer] *= 2;\r\nif (asoc->timeouts[timer] > asoc->max_init_timeo) {\r\nasoc->timeouts[timer] = asoc->max_init_timeo;\r\n}\r\nasoc->init_cycle++;\r\npr_debug("%s: T1[%s] timeout adjustment init_err_counter:%d"\r\n" cycle:%d timeout:%ld\n", __func__, name,\r\nasoc->init_err_counter, asoc->init_cycle,\r\nasoc->timeouts[timer]);\r\n}\r\n}\r\nstatic int sctp_cmd_send_msg(struct sctp_association *asoc,\r\nstruct sctp_datamsg *msg)\r\n{\r\nstruct sctp_chunk *chunk;\r\nint error = 0;\r\nlist_for_each_entry(chunk, &msg->chunks, frag_list) {\r\nerror = sctp_outq_tail(&asoc->outqueue, chunk);\r\nif (error)\r\nbreak;\r\n}\r\nreturn error;\r\n}\r\nstatic void sctp_cmd_send_asconf(struct sctp_association *asoc)\r\n{\r\nstruct net *net = sock_net(asoc->base.sk);\r\nif (!list_empty(&asoc->addip_chunk_list)) {\r\nstruct list_head *entry = asoc->addip_chunk_list.next;\r\nstruct sctp_chunk *asconf = list_entry(entry,\r\nstruct sctp_chunk, list);\r\nlist_del_init(entry);\r\nsctp_chunk_hold(asconf);\r\nif (sctp_primitive_ASCONF(net, asoc, asconf))\r\nsctp_chunk_free(asconf);\r\nelse\r\nasoc->addip_last_asconf = asconf;\r\n}\r\n}\r\nint sctp_do_sm(struct net *net, sctp_event_t event_type, sctp_subtype_t subtype,\r\nsctp_state_t state,\r\nstruct sctp_endpoint *ep,\r\nstruct sctp_association *asoc,\r\nvoid *event_arg,\r\ngfp_t gfp)\r\n{\r\nsctp_cmd_seq_t commands;\r\nconst sctp_sm_table_entry_t *state_fn;\r\nsctp_disposition_t status;\r\nint error = 0;\r\ntypedef const char *(printfn_t)(sctp_subtype_t);\r\nstatic printfn_t *table[] = {\r\nNULL, sctp_cname, sctp_tname, sctp_oname, sctp_pname,\r\n};\r\nprintfn_t *debug_fn __attribute__ ((unused)) = table[event_type];\r\nstate_fn = sctp_sm_lookup_event(net, event_type, state, subtype);\r\nsctp_init_cmd_seq(&commands);\r\ndebug_pre_sfn();\r\nstatus = state_fn->fn(net, ep, asoc, subtype, event_arg, &commands);\r\ndebug_post_sfn();\r\nerror = sctp_side_effects(event_type, subtype, state,\r\nep, asoc, event_arg, status,\r\n&commands, gfp);\r\ndebug_post_sfx();\r\nreturn error;\r\n}\r\nstatic int sctp_side_effects(sctp_event_t event_type, sctp_subtype_t subtype,\r\nsctp_state_t state,\r\nstruct sctp_endpoint *ep,\r\nstruct sctp_association *asoc,\r\nvoid *event_arg,\r\nsctp_disposition_t status,\r\nsctp_cmd_seq_t *commands,\r\ngfp_t gfp)\r\n{\r\nint error;\r\nif (0 != (error = sctp_cmd_interpreter(event_type, subtype, state,\r\nep, asoc,\r\nevent_arg, status,\r\ncommands, gfp)))\r\ngoto bail;\r\nswitch (status) {\r\ncase SCTP_DISPOSITION_DISCARD:\r\npr_debug("%s: ignored sctp protocol event - state:%d, "\r\n"event_type:%d, event_id:%d\n", __func__, state,\r\nevent_type, subtype.chunk);\r\nbreak;\r\ncase SCTP_DISPOSITION_NOMEM:\r\nerror = -ENOMEM;\r\nbreak;\r\ncase SCTP_DISPOSITION_DELETE_TCB:\r\nbreak;\r\ncase SCTP_DISPOSITION_CONSUME:\r\ncase SCTP_DISPOSITION_ABORT:\r\nbreak;\r\ncase SCTP_DISPOSITION_VIOLATION:\r\nnet_err_ratelimited("protocol violation state %d chunkid %d\n",\r\nstate, subtype.chunk);\r\nbreak;\r\ncase SCTP_DISPOSITION_NOT_IMPL:\r\npr_warn("unimplemented feature in state %d, event_type %d, event_id %d\n",\r\nstate, event_type, subtype.chunk);\r\nbreak;\r\ncase SCTP_DISPOSITION_BUG:\r\npr_err("bug in state %d, event_type %d, event_id %d\n",\r\nstate, event_type, subtype.chunk);\r\nBUG();\r\nbreak;\r\ndefault:\r\npr_err("impossible disposition %d in state %d, event_type %d, event_id %d\n",\r\nstatus, state, event_type, subtype.chunk);\r\nBUG();\r\nbreak;\r\n}\r\nbail:\r\nreturn error;\r\n}\r\nstatic int sctp_cmd_interpreter(sctp_event_t event_type,\r\nsctp_subtype_t subtype,\r\nsctp_state_t state,\r\nstruct sctp_endpoint *ep,\r\nstruct sctp_association *asoc,\r\nvoid *event_arg,\r\nsctp_disposition_t status,\r\nsctp_cmd_seq_t *commands,\r\ngfp_t gfp)\r\n{\r\nint error = 0;\r\nint force;\r\nsctp_cmd_t *cmd;\r\nstruct sctp_chunk *new_obj;\r\nstruct sctp_chunk *chunk = NULL;\r\nstruct sctp_packet *packet;\r\nstruct timer_list *timer;\r\nunsigned long timeout;\r\nstruct sctp_transport *t;\r\nstruct sctp_sackhdr sackh;\r\nint local_cork = 0;\r\nif (SCTP_EVENT_T_TIMEOUT != event_type)\r\nchunk = event_arg;\r\nwhile (NULL != (cmd = sctp_next_cmd(commands))) {\r\nswitch (cmd->verb) {\r\ncase SCTP_CMD_NOP:\r\nbreak;\r\ncase SCTP_CMD_NEW_ASOC:\r\nif (local_cork) {\r\nsctp_outq_uncork(&asoc->outqueue);\r\nlocal_cork = 0;\r\n}\r\nasoc = cmd->obj.asoc;\r\nBUG_ON(asoc->peer.primary_path == NULL);\r\nsctp_endpoint_add_asoc(ep, asoc);\r\nsctp_hash_established(asoc);\r\nbreak;\r\ncase SCTP_CMD_UPDATE_ASSOC:\r\nsctp_assoc_update(asoc, cmd->obj.asoc);\r\nbreak;\r\ncase SCTP_CMD_PURGE_OUTQUEUE:\r\nsctp_outq_teardown(&asoc->outqueue);\r\nbreak;\r\ncase SCTP_CMD_DELETE_TCB:\r\nif (local_cork) {\r\nsctp_outq_uncork(&asoc->outqueue);\r\nlocal_cork = 0;\r\n}\r\nsctp_cmd_delete_tcb(commands, asoc);\r\nasoc = NULL;\r\nbreak;\r\ncase SCTP_CMD_NEW_STATE:\r\nsctp_cmd_new_state(commands, asoc, cmd->obj.state);\r\nbreak;\r\ncase SCTP_CMD_REPORT_TSN:\r\nerror = sctp_tsnmap_mark(&asoc->peer.tsn_map,\r\ncmd->obj.u32, NULL);\r\nbreak;\r\ncase SCTP_CMD_REPORT_FWDTSN:\r\nsctp_tsnmap_skip(&asoc->peer.tsn_map, cmd->obj.u32);\r\nsctp_ulpq_reasm_flushtsn(&asoc->ulpq, cmd->obj.u32);\r\nsctp_ulpq_abort_pd(&asoc->ulpq, GFP_ATOMIC);\r\nbreak;\r\ncase SCTP_CMD_PROCESS_FWDTSN:\r\nsctp_cmd_process_fwdtsn(&asoc->ulpq, cmd->obj.chunk);\r\nbreak;\r\ncase SCTP_CMD_GEN_SACK:\r\nforce = cmd->obj.i32;\r\nerror = sctp_gen_sack(asoc, force, commands);\r\nbreak;\r\ncase SCTP_CMD_PROCESS_SACK:\r\nerror = sctp_cmd_process_sack(commands, asoc,\r\ncmd->obj.chunk);\r\nbreak;\r\ncase SCTP_CMD_GEN_INIT_ACK:\r\nnew_obj = sctp_make_init_ack(asoc, chunk, GFP_ATOMIC,\r\n0);\r\nif (!new_obj)\r\ngoto nomem;\r\nsctp_add_cmd_sf(commands, SCTP_CMD_REPLY,\r\nSCTP_CHUNK(new_obj));\r\nbreak;\r\ncase SCTP_CMD_PEER_INIT:\r\nerror = sctp_cmd_process_init(commands, asoc, chunk,\r\ncmd->obj.init, gfp);\r\nbreak;\r\ncase SCTP_CMD_GEN_COOKIE_ECHO:\r\nnew_obj = sctp_make_cookie_echo(asoc, chunk);\r\nif (!new_obj) {\r\nif (cmd->obj.chunk)\r\nsctp_chunk_free(cmd->obj.chunk);\r\ngoto nomem;\r\n}\r\nsctp_add_cmd_sf(commands, SCTP_CMD_REPLY,\r\nSCTP_CHUNK(new_obj));\r\nif (cmd->obj.chunk)\r\nsctp_add_cmd_sf(commands, SCTP_CMD_REPLY,\r\nSCTP_CHUNK(cmd->obj.chunk));\r\nif (new_obj->transport) {\r\nnew_obj->transport->init_sent_count++;\r\nasoc->init_last_sent_to = new_obj->transport;\r\n}\r\nif ((asoc->peer.retran_path !=\r\nasoc->peer.primary_path) &&\r\n(asoc->init_err_counter > 0)) {\r\nsctp_add_cmd_sf(commands,\r\nSCTP_CMD_FORCE_PRIM_RETRAN,\r\nSCTP_NULL());\r\n}\r\nbreak;\r\ncase SCTP_CMD_GEN_SHUTDOWN:\r\nasoc->overall_error_count = 0;\r\nnew_obj = sctp_make_shutdown(asoc, chunk);\r\nif (!new_obj)\r\ngoto nomem;\r\nsctp_add_cmd_sf(commands, SCTP_CMD_REPLY,\r\nSCTP_CHUNK(new_obj));\r\nbreak;\r\ncase SCTP_CMD_CHUNK_ULP:\r\npr_debug("%s: sm_sideff: chunk_up:%p, ulpq:%p\n",\r\n__func__, cmd->obj.chunk, &asoc->ulpq);\r\nsctp_ulpq_tail_data(&asoc->ulpq, cmd->obj.chunk,\r\nGFP_ATOMIC);\r\nbreak;\r\ncase SCTP_CMD_EVENT_ULP:\r\npr_debug("%s: sm_sideff: event_up:%p, ulpq:%p\n",\r\n__func__, cmd->obj.ulpevent, &asoc->ulpq);\r\nsctp_ulpq_tail_event(&asoc->ulpq, cmd->obj.ulpevent);\r\nbreak;\r\ncase SCTP_CMD_REPLY:\r\nif (!asoc->outqueue.cork) {\r\nsctp_outq_cork(&asoc->outqueue);\r\nlocal_cork = 1;\r\n}\r\nerror = sctp_outq_tail(&asoc->outqueue, cmd->obj.chunk);\r\nbreak;\r\ncase SCTP_CMD_SEND_PKT:\r\npacket = cmd->obj.packet;\r\nsctp_packet_transmit(packet);\r\nsctp_ootb_pkt_free(packet);\r\nbreak;\r\ncase SCTP_CMD_T1_RETRAN:\r\nsctp_retransmit(&asoc->outqueue, cmd->obj.transport,\r\nSCTP_RTXR_T1_RTX);\r\nbreak;\r\ncase SCTP_CMD_RETRAN:\r\nsctp_retransmit(&asoc->outqueue, cmd->obj.transport,\r\nSCTP_RTXR_T3_RTX);\r\nbreak;\r\ncase SCTP_CMD_ECN_CE:\r\nsctp_do_ecn_ce_work(asoc, cmd->obj.u32);\r\nbreak;\r\ncase SCTP_CMD_ECN_ECNE:\r\nnew_obj = sctp_do_ecn_ecne_work(asoc, cmd->obj.u32,\r\nchunk);\r\nif (new_obj)\r\nsctp_add_cmd_sf(commands, SCTP_CMD_REPLY,\r\nSCTP_CHUNK(new_obj));\r\nbreak;\r\ncase SCTP_CMD_ECN_CWR:\r\nsctp_do_ecn_cwr_work(asoc, cmd->obj.u32);\r\nbreak;\r\ncase SCTP_CMD_SETUP_T2:\r\nsctp_cmd_setup_t2(commands, asoc, cmd->obj.chunk);\r\nbreak;\r\ncase SCTP_CMD_TIMER_START_ONCE:\r\ntimer = &asoc->timers[cmd->obj.to];\r\nif (timer_pending(timer))\r\nbreak;\r\ncase SCTP_CMD_TIMER_START:\r\ntimer = &asoc->timers[cmd->obj.to];\r\ntimeout = asoc->timeouts[cmd->obj.to];\r\nBUG_ON(!timeout);\r\ntimer->expires = jiffies + timeout;\r\nsctp_association_hold(asoc);\r\nadd_timer(timer);\r\nbreak;\r\ncase SCTP_CMD_TIMER_RESTART:\r\ntimer = &asoc->timers[cmd->obj.to];\r\ntimeout = asoc->timeouts[cmd->obj.to];\r\nif (!mod_timer(timer, jiffies + timeout))\r\nsctp_association_hold(asoc);\r\nbreak;\r\ncase SCTP_CMD_TIMER_STOP:\r\ntimer = &asoc->timers[cmd->obj.to];\r\nif (del_timer(timer))\r\nsctp_association_put(asoc);\r\nbreak;\r\ncase SCTP_CMD_INIT_CHOOSE_TRANSPORT:\r\nchunk = cmd->obj.chunk;\r\nt = sctp_assoc_choose_alter_transport(asoc,\r\nasoc->init_last_sent_to);\r\nasoc->init_last_sent_to = t;\r\nchunk->transport = t;\r\nt->init_sent_count++;\r\nsctp_assoc_set_primary(asoc, t);\r\nbreak;\r\ncase SCTP_CMD_INIT_RESTART:\r\nsctp_cmd_t1_timer_update(asoc,\r\nSCTP_EVENT_TIMEOUT_T1_INIT,\r\n"INIT");\r\nsctp_add_cmd_sf(commands, SCTP_CMD_TIMER_RESTART,\r\nSCTP_TO(SCTP_EVENT_TIMEOUT_T1_INIT));\r\nbreak;\r\ncase SCTP_CMD_COOKIEECHO_RESTART:\r\nsctp_cmd_t1_timer_update(asoc,\r\nSCTP_EVENT_TIMEOUT_T1_COOKIE,\r\n"COOKIE");\r\nlist_for_each_entry(t, &asoc->peer.transport_addr_list,\r\ntransports) {\r\nsctp_retransmit_mark(&asoc->outqueue, t,\r\nSCTP_RTXR_T1_RTX);\r\n}\r\nsctp_add_cmd_sf(commands,\r\nSCTP_CMD_TIMER_RESTART,\r\nSCTP_TO(SCTP_EVENT_TIMEOUT_T1_COOKIE));\r\nbreak;\r\ncase SCTP_CMD_INIT_FAILED:\r\nsctp_cmd_init_failed(commands, asoc, cmd->obj.err);\r\nbreak;\r\ncase SCTP_CMD_ASSOC_FAILED:\r\nsctp_cmd_assoc_failed(commands, asoc, event_type,\r\nsubtype, chunk, cmd->obj.err);\r\nbreak;\r\ncase SCTP_CMD_INIT_COUNTER_INC:\r\nasoc->init_err_counter++;\r\nbreak;\r\ncase SCTP_CMD_INIT_COUNTER_RESET:\r\nasoc->init_err_counter = 0;\r\nasoc->init_cycle = 0;\r\nlist_for_each_entry(t, &asoc->peer.transport_addr_list,\r\ntransports) {\r\nt->init_sent_count = 0;\r\n}\r\nbreak;\r\ncase SCTP_CMD_REPORT_DUP:\r\nsctp_tsnmap_mark_dup(&asoc->peer.tsn_map,\r\ncmd->obj.u32);\r\nbreak;\r\ncase SCTP_CMD_REPORT_BAD_TAG:\r\npr_debug("%s: vtag mismatch!\n", __func__);\r\nbreak;\r\ncase SCTP_CMD_STRIKE:\r\nsctp_do_8_2_transport_strike(commands, asoc,\r\ncmd->obj.transport, 0);\r\nbreak;\r\ncase SCTP_CMD_TRANSPORT_IDLE:\r\nt = cmd->obj.transport;\r\nsctp_transport_lower_cwnd(t, SCTP_LOWER_CWND_INACTIVE);\r\nbreak;\r\ncase SCTP_CMD_TRANSPORT_HB_SENT:\r\nt = cmd->obj.transport;\r\nsctp_do_8_2_transport_strike(commands, asoc,\r\nt, 1);\r\nt->hb_sent = 1;\r\nbreak;\r\ncase SCTP_CMD_TRANSPORT_ON:\r\nt = cmd->obj.transport;\r\nsctp_cmd_transport_on(commands, asoc, t, chunk);\r\nbreak;\r\ncase SCTP_CMD_HB_TIMERS_START:\r\nsctp_cmd_hb_timers_start(commands, asoc);\r\nbreak;\r\ncase SCTP_CMD_HB_TIMER_UPDATE:\r\nt = cmd->obj.transport;\r\nsctp_cmd_hb_timer_update(commands, t);\r\nbreak;\r\ncase SCTP_CMD_HB_TIMERS_STOP:\r\nsctp_cmd_hb_timers_stop(commands, asoc);\r\nbreak;\r\ncase SCTP_CMD_REPORT_ERROR:\r\nerror = cmd->obj.error;\r\nbreak;\r\ncase SCTP_CMD_PROCESS_CTSN:\r\nsackh.cum_tsn_ack = cmd->obj.be32;\r\nsackh.a_rwnd = asoc->peer.rwnd +\r\nasoc->outqueue.outstanding_bytes;\r\nsackh.num_gap_ack_blocks = 0;\r\nsackh.num_dup_tsns = 0;\r\nchunk->subh.sack_hdr = &sackh;\r\nsctp_add_cmd_sf(commands, SCTP_CMD_PROCESS_SACK,\r\nSCTP_CHUNK(chunk));\r\nbreak;\r\ncase SCTP_CMD_DISCARD_PACKET:\r\nchunk->pdiscard = 1;\r\nif (asoc) {\r\nsctp_outq_uncork(&asoc->outqueue);\r\nlocal_cork = 0;\r\n}\r\nbreak;\r\ncase SCTP_CMD_RTO_PENDING:\r\nt = cmd->obj.transport;\r\nt->rto_pending = 1;\r\nbreak;\r\ncase SCTP_CMD_PART_DELIVER:\r\nsctp_ulpq_partial_delivery(&asoc->ulpq, GFP_ATOMIC);\r\nbreak;\r\ncase SCTP_CMD_RENEGE:\r\nsctp_ulpq_renege(&asoc->ulpq, cmd->obj.chunk,\r\nGFP_ATOMIC);\r\nbreak;\r\ncase SCTP_CMD_SETUP_T4:\r\nsctp_cmd_setup_t4(commands, asoc, cmd->obj.chunk);\r\nbreak;\r\ncase SCTP_CMD_PROCESS_OPERR:\r\nsctp_cmd_process_operr(commands, asoc, chunk);\r\nbreak;\r\ncase SCTP_CMD_CLEAR_INIT_TAG:\r\nasoc->peer.i.init_tag = 0;\r\nbreak;\r\ncase SCTP_CMD_DEL_NON_PRIMARY:\r\nsctp_cmd_del_non_primary(asoc);\r\nbreak;\r\ncase SCTP_CMD_T3_RTX_TIMERS_STOP:\r\nsctp_cmd_t3_rtx_timers_stop(commands, asoc);\r\nbreak;\r\ncase SCTP_CMD_FORCE_PRIM_RETRAN:\r\nt = asoc->peer.retran_path;\r\nasoc->peer.retran_path = asoc->peer.primary_path;\r\nerror = sctp_outq_uncork(&asoc->outqueue);\r\nlocal_cork = 0;\r\nasoc->peer.retran_path = t;\r\nbreak;\r\ncase SCTP_CMD_SET_SK_ERR:\r\nsctp_cmd_set_sk_err(asoc, cmd->obj.error);\r\nbreak;\r\ncase SCTP_CMD_ASSOC_CHANGE:\r\nsctp_cmd_assoc_change(commands, asoc,\r\ncmd->obj.u8);\r\nbreak;\r\ncase SCTP_CMD_ADAPTATION_IND:\r\nsctp_cmd_adaptation_ind(commands, asoc);\r\nbreak;\r\ncase SCTP_CMD_ASSOC_SHKEY:\r\nerror = sctp_auth_asoc_init_active_key(asoc,\r\nGFP_ATOMIC);\r\nbreak;\r\ncase SCTP_CMD_UPDATE_INITTAG:\r\nasoc->peer.i.init_tag = cmd->obj.u32;\r\nbreak;\r\ncase SCTP_CMD_SEND_MSG:\r\nif (!asoc->outqueue.cork) {\r\nsctp_outq_cork(&asoc->outqueue);\r\nlocal_cork = 1;\r\n}\r\nerror = sctp_cmd_send_msg(asoc, cmd->obj.msg);\r\nbreak;\r\ncase SCTP_CMD_SEND_NEXT_ASCONF:\r\nsctp_cmd_send_asconf(asoc);\r\nbreak;\r\ncase SCTP_CMD_PURGE_ASCONF_QUEUE:\r\nsctp_asconf_queue_teardown(asoc);\r\nbreak;\r\ncase SCTP_CMD_SET_ASOC:\r\nasoc = cmd->obj.asoc;\r\nbreak;\r\ndefault:\r\npr_warn("Impossible command: %u\n",\r\ncmd->verb);\r\nbreak;\r\n}\r\nif (error)\r\nbreak;\r\n}\r\nout:\r\nif (asoc && SCTP_EVENT_T_CHUNK == event_type && chunk) {\r\nif (chunk->end_of_packet || chunk->singleton)\r\nerror = sctp_outq_uncork(&asoc->outqueue);\r\n} else if (local_cork)\r\nerror = sctp_outq_uncork(&asoc->outqueue);\r\nreturn error;\r\nnomem:\r\nerror = -ENOMEM;\r\ngoto out;\r\n}
