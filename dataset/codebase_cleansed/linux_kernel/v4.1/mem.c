static int __init check_tmpfs(const char *dir)\r\n{\r\nstruct statfs st;\r\nprintf("Checking if %s is on tmpfs...", dir);\r\nif (statfs(dir, &st) < 0) {\r\nprintf("%s\n", strerror(errno));\r\n} else if (st.f_type != TMPFS_MAGIC) {\r\nprintf("no\n");\r\n} else {\r\nprintf("OK\n");\r\nreturn 0;\r\n}\r\nreturn -1;\r\n}\r\nstatic char * __init choose_tempdir(void)\r\n{\r\nstatic const char * const vars[] = {\r\n"TMPDIR",\r\n"TMP",\r\n"TEMP",\r\nNULL\r\n};\r\nstatic const char fallback_dir[] = "/tmp";\r\nstatic const char * const tmpfs_dirs[] = {\r\n"/dev/shm",\r\nfallback_dir,\r\nNULL\r\n};\r\nint i;\r\nconst char *dir;\r\nprintf("Checking environment variables for a tempdir...");\r\nfor (i = 0; vars[i]; i++) {\r\ndir = getenv(vars[i]);\r\nif ((dir != NULL) && (*dir != '\0')) {\r\nprintf("%s\n", dir);\r\nif (check_tmpfs(dir) >= 0)\r\ngoto done;\r\nelse\r\ngoto warn;\r\n}\r\n}\r\nprintf("none found\n");\r\nfor (i = 0; tmpfs_dirs[i]; i++) {\r\ndir = tmpfs_dirs[i];\r\nif (check_tmpfs(dir) >= 0)\r\ngoto done;\r\n}\r\ndir = fallback_dir;\r\nwarn:\r\nprintf("Warning: tempdir %s is not on tmpfs\n", dir);\r\ndone:\r\nreturn strdup(dir);\r\n}\r\nstatic int __init make_tempfile(const char *template)\r\n{\r\nchar *tempname;\r\nint fd;\r\nif (tempdir == NULL) {\r\ntempdir = choose_tempdir();\r\nif (tempdir == NULL) {\r\nfprintf(stderr, "Failed to choose tempdir: %s\n",\r\nstrerror(errno));\r\nreturn -1;\r\n}\r\n}\r\ntempname = malloc(strlen(tempdir) + strlen(template) + 1);\r\nif (tempname == NULL)\r\nreturn -1;\r\nstrcpy(tempname, tempdir);\r\nstrcat(tempname, template);\r\nfd = mkstemp(tempname);\r\nif (fd < 0) {\r\nfprintf(stderr, "open - cannot create %s: %s\n", tempname,\r\nstrerror(errno));\r\ngoto out;\r\n}\r\nif (unlink(tempname) < 0) {\r\nperror("unlink");\r\ngoto close;\r\n}\r\nfree(tempname);\r\nreturn fd;\r\nclose:\r\nclose(fd);\r\nout:\r\nfree(tempname);\r\nreturn -1;\r\n}\r\nstatic int __init create_tmp_file(unsigned long long len)\r\n{\r\nint fd, err;\r\nchar zero;\r\nfd = make_tempfile(TEMPNAME_TEMPLATE);\r\nif (fd < 0)\r\nexit(1);\r\nerr = fchmod(fd, 0777);\r\nif (err < 0) {\r\nperror("fchmod");\r\nexit(1);\r\n}\r\nif (lseek64(fd, len - 1, SEEK_SET) < 0) {\r\nperror("lseek64");\r\nexit(1);\r\n}\r\nzero = 0;\r\nerr = write(fd, &zero, 1);\r\nif (err != 1) {\r\nperror("write");\r\nexit(1);\r\n}\r\nreturn fd;\r\n}\r\nint __init create_mem_file(unsigned long long len)\r\n{\r\nint err, fd;\r\nfd = create_tmp_file(len);\r\nerr = os_set_exec_close(fd);\r\nif (err < 0) {\r\nerrno = -err;\r\nperror("exec_close");\r\n}\r\nreturn fd;\r\n}\r\nvoid __init check_tmpexec(void)\r\n{\r\nvoid *addr;\r\nint err, fd = create_tmp_file(UM_KERN_PAGE_SIZE);\r\naddr = mmap(NULL, UM_KERN_PAGE_SIZE,\r\nPROT_READ | PROT_WRITE | PROT_EXEC, MAP_PRIVATE, fd, 0);\r\nprintf("Checking PROT_EXEC mmap in %s...", tempdir);\r\nif (addr == MAP_FAILED) {\r\nerr = errno;\r\nprintf("%s\n", strerror(err));\r\nclose(fd);\r\nif (err == EPERM)\r\nprintf("%s must be not mounted noexec\n", tempdir);\r\nexit(1);\r\n}\r\nprintf("OK\n");\r\nmunmap(addr, UM_KERN_PAGE_SIZE);\r\nclose(fd);\r\n}
