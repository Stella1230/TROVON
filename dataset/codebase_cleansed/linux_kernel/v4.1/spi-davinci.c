static void davinci_spi_rx_buf_u8(u32 data, struct davinci_spi *dspi)\r\n{\r\nif (dspi->rx) {\r\nu8 *rx = dspi->rx;\r\n*rx++ = (u8)data;\r\ndspi->rx = rx;\r\n}\r\n}\r\nstatic void davinci_spi_rx_buf_u16(u32 data, struct davinci_spi *dspi)\r\n{\r\nif (dspi->rx) {\r\nu16 *rx = dspi->rx;\r\n*rx++ = (u16)data;\r\ndspi->rx = rx;\r\n}\r\n}\r\nstatic u32 davinci_spi_tx_buf_u8(struct davinci_spi *dspi)\r\n{\r\nu32 data = 0;\r\nif (dspi->tx) {\r\nconst u8 *tx = dspi->tx;\r\ndata = *tx++;\r\ndspi->tx = tx;\r\n}\r\nreturn data;\r\n}\r\nstatic u32 davinci_spi_tx_buf_u16(struct davinci_spi *dspi)\r\n{\r\nu32 data = 0;\r\nif (dspi->tx) {\r\nconst u16 *tx = dspi->tx;\r\ndata = *tx++;\r\ndspi->tx = tx;\r\n}\r\nreturn data;\r\n}\r\nstatic inline void set_io_bits(void __iomem *addr, u32 bits)\r\n{\r\nu32 v = ioread32(addr);\r\nv |= bits;\r\niowrite32(v, addr);\r\n}\r\nstatic inline void clear_io_bits(void __iomem *addr, u32 bits)\r\n{\r\nu32 v = ioread32(addr);\r\nv &= ~bits;\r\niowrite32(v, addr);\r\n}\r\nstatic void davinci_spi_chipselect(struct spi_device *spi, int value)\r\n{\r\nstruct davinci_spi *dspi;\r\nstruct davinci_spi_platform_data *pdata;\r\nstruct davinci_spi_config *spicfg = spi->controller_data;\r\nu8 chip_sel = spi->chip_select;\r\nu16 spidat1 = CS_DEFAULT;\r\nbool gpio_chipsel = false;\r\nint gpio;\r\ndspi = spi_master_get_devdata(spi->master);\r\npdata = &dspi->pdata;\r\nif (spi->cs_gpio >= 0) {\r\ngpio_chipsel = true;\r\ngpio = spi->cs_gpio;\r\n}\r\nif (spicfg->wdelay)\r\nspidat1 |= SPIDAT1_WDEL;\r\nif (gpio_chipsel) {\r\nif (value == BITBANG_CS_ACTIVE)\r\ngpio_set_value(gpio, spi->mode & SPI_CS_HIGH);\r\nelse\r\ngpio_set_value(gpio, !(spi->mode & SPI_CS_HIGH));\r\n} else {\r\nif (value == BITBANG_CS_ACTIVE) {\r\nspidat1 |= SPIDAT1_CSHOLD_MASK;\r\nspidat1 &= ~(0x1 << chip_sel);\r\n}\r\n}\r\niowrite16(spidat1, dspi->base + SPIDAT1 + 2);\r\n}\r\nstatic inline int davinci_spi_get_prescale(struct davinci_spi *dspi,\r\nu32 max_speed_hz)\r\n{\r\nint ret;\r\nret = DIV_ROUND_UP(clk_get_rate(dspi->clk), max_speed_hz);\r\nif (ret < 3 || ret > 256)\r\nreturn -EINVAL;\r\nreturn ret - 1;\r\n}\r\nstatic int davinci_spi_setup_transfer(struct spi_device *spi,\r\nstruct spi_transfer *t)\r\n{\r\nstruct davinci_spi *dspi;\r\nstruct davinci_spi_config *spicfg;\r\nu8 bits_per_word = 0;\r\nu32 hz = 0, spifmt = 0;\r\nint prescale;\r\ndspi = spi_master_get_devdata(spi->master);\r\nspicfg = spi->controller_data;\r\nif (!spicfg)\r\nspicfg = &davinci_spi_default_cfg;\r\nif (t) {\r\nbits_per_word = t->bits_per_word;\r\nhz = t->speed_hz;\r\n}\r\nif (!bits_per_word)\r\nbits_per_word = spi->bits_per_word;\r\nif (bits_per_word <= 8) {\r\ndspi->get_rx = davinci_spi_rx_buf_u8;\r\ndspi->get_tx = davinci_spi_tx_buf_u8;\r\ndspi->bytes_per_word[spi->chip_select] = 1;\r\n} else {\r\ndspi->get_rx = davinci_spi_rx_buf_u16;\r\ndspi->get_tx = davinci_spi_tx_buf_u16;\r\ndspi->bytes_per_word[spi->chip_select] = 2;\r\n}\r\nif (!hz)\r\nhz = spi->max_speed_hz;\r\nprescale = davinci_spi_get_prescale(dspi, hz);\r\nif (prescale < 0)\r\nreturn prescale;\r\nspifmt = (prescale << SPIFMT_PRESCALE_SHIFT) | (bits_per_word & 0x1f);\r\nif (spi->mode & SPI_LSB_FIRST)\r\nspifmt |= SPIFMT_SHIFTDIR_MASK;\r\nif (spi->mode & SPI_CPOL)\r\nspifmt |= SPIFMT_POLARITY_MASK;\r\nif (!(spi->mode & SPI_CPHA))\r\nspifmt |= SPIFMT_PHASE_MASK;\r\nif (spicfg->wdelay)\r\nspifmt |= ((spicfg->wdelay << SPIFMT_WDELAY_SHIFT)\r\n& SPIFMT_WDELAY_MASK);\r\nif (dspi->version == SPI_VERSION_2) {\r\nu32 delay = 0;\r\nif (spicfg->odd_parity)\r\nspifmt |= SPIFMT_ODD_PARITY_MASK;\r\nif (spicfg->parity_enable)\r\nspifmt |= SPIFMT_PARITYENA_MASK;\r\nif (spicfg->timer_disable) {\r\nspifmt |= SPIFMT_DISTIMER_MASK;\r\n} else {\r\ndelay |= (spicfg->c2tdelay << SPIDELAY_C2TDELAY_SHIFT)\r\n& SPIDELAY_C2TDELAY_MASK;\r\ndelay |= (spicfg->t2cdelay << SPIDELAY_T2CDELAY_SHIFT)\r\n& SPIDELAY_T2CDELAY_MASK;\r\n}\r\nif (spi->mode & SPI_READY) {\r\nspifmt |= SPIFMT_WAITENA_MASK;\r\ndelay |= (spicfg->t2edelay << SPIDELAY_T2EDELAY_SHIFT)\r\n& SPIDELAY_T2EDELAY_MASK;\r\ndelay |= (spicfg->c2edelay << SPIDELAY_C2EDELAY_SHIFT)\r\n& SPIDELAY_C2EDELAY_MASK;\r\n}\r\niowrite32(delay, dspi->base + SPIDELAY);\r\n}\r\niowrite32(spifmt, dspi->base + SPIFMT0);\r\nreturn 0;\r\n}\r\nstatic int davinci_spi_of_setup(struct spi_device *spi)\r\n{\r\nstruct davinci_spi_config *spicfg = spi->controller_data;\r\nstruct device_node *np = spi->dev.of_node;\r\nu32 prop;\r\nif (spicfg == NULL && np) {\r\nspicfg = kzalloc(sizeof(*spicfg), GFP_KERNEL);\r\nif (!spicfg)\r\nreturn -ENOMEM;\r\n*spicfg = davinci_spi_default_cfg;\r\nif (!of_property_read_u32(np, "ti,spi-wdelay", &prop))\r\nspicfg->wdelay = (u8)prop;\r\nspi->controller_data = spicfg;\r\n}\r\nreturn 0;\r\n}\r\nstatic int davinci_spi_setup(struct spi_device *spi)\r\n{\r\nint retval = 0;\r\nstruct davinci_spi *dspi;\r\nstruct davinci_spi_platform_data *pdata;\r\nstruct spi_master *master = spi->master;\r\nstruct device_node *np = spi->dev.of_node;\r\nbool internal_cs = true;\r\ndspi = spi_master_get_devdata(spi->master);\r\npdata = &dspi->pdata;\r\nif (!(spi->mode & SPI_NO_CS)) {\r\nif (np && (master->cs_gpios != NULL) && (spi->cs_gpio >= 0)) {\r\nretval = gpio_direction_output(\r\nspi->cs_gpio, !(spi->mode & SPI_CS_HIGH));\r\ninternal_cs = false;\r\n} else if (pdata->chip_sel &&\r\nspi->chip_select < pdata->num_chipselect &&\r\npdata->chip_sel[spi->chip_select] != SPI_INTERN_CS) {\r\nspi->cs_gpio = pdata->chip_sel[spi->chip_select];\r\nretval = gpio_direction_output(\r\nspi->cs_gpio, !(spi->mode & SPI_CS_HIGH));\r\ninternal_cs = false;\r\n}\r\nif (retval) {\r\ndev_err(&spi->dev, "GPIO %d setup failed (%d)\n",\r\nspi->cs_gpio, retval);\r\nreturn retval;\r\n}\r\nif (internal_cs)\r\nset_io_bits(dspi->base + SPIPC0, 1 << spi->chip_select);\r\n}\r\nif (spi->mode & SPI_READY)\r\nset_io_bits(dspi->base + SPIPC0, SPIPC0_SPIENA_MASK);\r\nif (spi->mode & SPI_LOOP)\r\nset_io_bits(dspi->base + SPIGCR1, SPIGCR1_LOOPBACK_MASK);\r\nelse\r\nclear_io_bits(dspi->base + SPIGCR1, SPIGCR1_LOOPBACK_MASK);\r\nreturn davinci_spi_of_setup(spi);\r\n}\r\nstatic void davinci_spi_cleanup(struct spi_device *spi)\r\n{\r\nstruct davinci_spi_config *spicfg = spi->controller_data;\r\nspi->controller_data = NULL;\r\nif (spi->dev.of_node)\r\nkfree(spicfg);\r\n}\r\nstatic int davinci_spi_check_error(struct davinci_spi *dspi, int int_status)\r\n{\r\nstruct device *sdev = dspi->bitbang.master->dev.parent;\r\nif (int_status & SPIFLG_TIMEOUT_MASK) {\r\ndev_dbg(sdev, "SPI Time-out Error\n");\r\nreturn -ETIMEDOUT;\r\n}\r\nif (int_status & SPIFLG_DESYNC_MASK) {\r\ndev_dbg(sdev, "SPI Desynchronization Error\n");\r\nreturn -EIO;\r\n}\r\nif (int_status & SPIFLG_BITERR_MASK) {\r\ndev_dbg(sdev, "SPI Bit error\n");\r\nreturn -EIO;\r\n}\r\nif (dspi->version == SPI_VERSION_2) {\r\nif (int_status & SPIFLG_DLEN_ERR_MASK) {\r\ndev_dbg(sdev, "SPI Data Length Error\n");\r\nreturn -EIO;\r\n}\r\nif (int_status & SPIFLG_PARERR_MASK) {\r\ndev_dbg(sdev, "SPI Parity Error\n");\r\nreturn -EIO;\r\n}\r\nif (int_status & SPIFLG_OVRRUN_MASK) {\r\ndev_dbg(sdev, "SPI Data Overrun error\n");\r\nreturn -EIO;\r\n}\r\nif (int_status & SPIFLG_BUF_INIT_ACTIVE_MASK) {\r\ndev_dbg(sdev, "SPI Buffer Init Active\n");\r\nreturn -EBUSY;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int davinci_spi_process_events(struct davinci_spi *dspi)\r\n{\r\nu32 buf, status, errors = 0, spidat1;\r\nbuf = ioread32(dspi->base + SPIBUF);\r\nif (dspi->rcount > 0 && !(buf & SPIBUF_RXEMPTY_MASK)) {\r\ndspi->get_rx(buf & 0xFFFF, dspi);\r\ndspi->rcount--;\r\n}\r\nstatus = ioread32(dspi->base + SPIFLG);\r\nif (unlikely(status & SPIFLG_ERROR_MASK)) {\r\nerrors = status & SPIFLG_ERROR_MASK;\r\ngoto out;\r\n}\r\nif (dspi->wcount > 0 && !(buf & SPIBUF_TXFULL_MASK)) {\r\nspidat1 = ioread32(dspi->base + SPIDAT1);\r\ndspi->wcount--;\r\nspidat1 &= ~0xFFFF;\r\nspidat1 |= 0xFFFF & dspi->get_tx(dspi);\r\niowrite32(spidat1, dspi->base + SPIDAT1);\r\n}\r\nout:\r\nreturn errors;\r\n}\r\nstatic void davinci_spi_dma_rx_callback(void *data)\r\n{\r\nstruct davinci_spi *dspi = (struct davinci_spi *)data;\r\ndspi->rcount = 0;\r\nif (!dspi->wcount && !dspi->rcount)\r\ncomplete(&dspi->done);\r\n}\r\nstatic void davinci_spi_dma_tx_callback(void *data)\r\n{\r\nstruct davinci_spi *dspi = (struct davinci_spi *)data;\r\ndspi->wcount = 0;\r\nif (!dspi->wcount && !dspi->rcount)\r\ncomplete(&dspi->done);\r\n}\r\nstatic int davinci_spi_bufs(struct spi_device *spi, struct spi_transfer *t)\r\n{\r\nstruct davinci_spi *dspi;\r\nint data_type, ret = -ENOMEM;\r\nu32 tx_data, spidat1;\r\nu32 errors = 0;\r\nstruct davinci_spi_config *spicfg;\r\nstruct davinci_spi_platform_data *pdata;\r\nunsigned uninitialized_var(rx_buf_count);\r\nvoid *dummy_buf = NULL;\r\nstruct scatterlist sg_rx, sg_tx;\r\ndspi = spi_master_get_devdata(spi->master);\r\npdata = &dspi->pdata;\r\nspicfg = (struct davinci_spi_config *)spi->controller_data;\r\nif (!spicfg)\r\nspicfg = &davinci_spi_default_cfg;\r\ndata_type = dspi->bytes_per_word[spi->chip_select];\r\ndspi->tx = t->tx_buf;\r\ndspi->rx = t->rx_buf;\r\ndspi->wcount = t->len / data_type;\r\ndspi->rcount = dspi->wcount;\r\nspidat1 = ioread32(dspi->base + SPIDAT1);\r\nclear_io_bits(dspi->base + SPIGCR1, SPIGCR1_POWERDOWN_MASK);\r\nset_io_bits(dspi->base + SPIGCR1, SPIGCR1_SPIENA_MASK);\r\nreinit_completion(&dspi->done);\r\nif (spicfg->io_type == SPI_IO_TYPE_INTR)\r\nset_io_bits(dspi->base + SPIINT, SPIINT_MASKINT);\r\nif (spicfg->io_type != SPI_IO_TYPE_DMA) {\r\ndspi->wcount--;\r\ntx_data = dspi->get_tx(dspi);\r\nspidat1 &= 0xFFFF0000;\r\nspidat1 |= tx_data & 0xFFFF;\r\niowrite32(spidat1, dspi->base + SPIDAT1);\r\n} else {\r\nstruct dma_slave_config dma_rx_conf = {\r\n.direction = DMA_DEV_TO_MEM,\r\n.src_addr = (unsigned long)dspi->pbase + SPIBUF,\r\n.src_addr_width = data_type,\r\n.src_maxburst = 1,\r\n};\r\nstruct dma_slave_config dma_tx_conf = {\r\n.direction = DMA_MEM_TO_DEV,\r\n.dst_addr = (unsigned long)dspi->pbase + SPIDAT1,\r\n.dst_addr_width = data_type,\r\n.dst_maxburst = 1,\r\n};\r\nstruct dma_async_tx_descriptor *rxdesc;\r\nstruct dma_async_tx_descriptor *txdesc;\r\nvoid *buf;\r\ndummy_buf = kzalloc(t->len, GFP_KERNEL);\r\nif (!dummy_buf)\r\ngoto err_alloc_dummy_buf;\r\ndmaengine_slave_config(dspi->dma_rx, &dma_rx_conf);\r\ndmaengine_slave_config(dspi->dma_tx, &dma_tx_conf);\r\nsg_init_table(&sg_rx, 1);\r\nif (!t->rx_buf)\r\nbuf = dummy_buf;\r\nelse\r\nbuf = t->rx_buf;\r\nt->rx_dma = dma_map_single(&spi->dev, buf,\r\nt->len, DMA_FROM_DEVICE);\r\nif (!t->rx_dma) {\r\nret = -EFAULT;\r\ngoto err_rx_map;\r\n}\r\nsg_dma_address(&sg_rx) = t->rx_dma;\r\nsg_dma_len(&sg_rx) = t->len;\r\nsg_init_table(&sg_tx, 1);\r\nif (!t->tx_buf)\r\nbuf = dummy_buf;\r\nelse\r\nbuf = (void *)t->tx_buf;\r\nt->tx_dma = dma_map_single(&spi->dev, buf,\r\nt->len, DMA_TO_DEVICE);\r\nif (!t->tx_dma) {\r\nret = -EFAULT;\r\ngoto err_tx_map;\r\n}\r\nsg_dma_address(&sg_tx) = t->tx_dma;\r\nsg_dma_len(&sg_tx) = t->len;\r\nrxdesc = dmaengine_prep_slave_sg(dspi->dma_rx,\r\n&sg_rx, 1, DMA_DEV_TO_MEM,\r\nDMA_PREP_INTERRUPT | DMA_CTRL_ACK);\r\nif (!rxdesc)\r\ngoto err_desc;\r\ntxdesc = dmaengine_prep_slave_sg(dspi->dma_tx,\r\n&sg_tx, 1, DMA_MEM_TO_DEV,\r\nDMA_PREP_INTERRUPT | DMA_CTRL_ACK);\r\nif (!txdesc)\r\ngoto err_desc;\r\nrxdesc->callback = davinci_spi_dma_rx_callback;\r\nrxdesc->callback_param = (void *)dspi;\r\ntxdesc->callback = davinci_spi_dma_tx_callback;\r\ntxdesc->callback_param = (void *)dspi;\r\nif (pdata->cshold_bug)\r\niowrite16(spidat1 >> 16, dspi->base + SPIDAT1 + 2);\r\ndmaengine_submit(rxdesc);\r\ndmaengine_submit(txdesc);\r\ndma_async_issue_pending(dspi->dma_rx);\r\ndma_async_issue_pending(dspi->dma_tx);\r\nset_io_bits(dspi->base + SPIINT, SPIINT_DMA_REQ_EN);\r\n}\r\nif (spicfg->io_type != SPI_IO_TYPE_POLL) {\r\nwait_for_completion_interruptible(&(dspi->done));\r\n} else {\r\nwhile (dspi->rcount > 0 || dspi->wcount > 0) {\r\nerrors = davinci_spi_process_events(dspi);\r\nif (errors)\r\nbreak;\r\ncpu_relax();\r\n}\r\n}\r\nclear_io_bits(dspi->base + SPIINT, SPIINT_MASKALL);\r\nif (spicfg->io_type == SPI_IO_TYPE_DMA) {\r\nclear_io_bits(dspi->base + SPIINT, SPIINT_DMA_REQ_EN);\r\ndma_unmap_single(&spi->dev, t->rx_dma,\r\nt->len, DMA_FROM_DEVICE);\r\ndma_unmap_single(&spi->dev, t->tx_dma,\r\nt->len, DMA_TO_DEVICE);\r\nkfree(dummy_buf);\r\n}\r\nclear_io_bits(dspi->base + SPIGCR1, SPIGCR1_SPIENA_MASK);\r\nset_io_bits(dspi->base + SPIGCR1, SPIGCR1_POWERDOWN_MASK);\r\nif (errors) {\r\nret = davinci_spi_check_error(dspi, errors);\r\nWARN(!ret, "%s: error reported but no error found!\n",\r\ndev_name(&spi->dev));\r\nreturn ret;\r\n}\r\nif (dspi->rcount != 0 || dspi->wcount != 0) {\r\ndev_err(&spi->dev, "SPI data transfer error\n");\r\nreturn -EIO;\r\n}\r\nreturn t->len;\r\nerr_desc:\r\ndma_unmap_single(&spi->dev, t->tx_dma, t->len, DMA_TO_DEVICE);\r\nerr_tx_map:\r\ndma_unmap_single(&spi->dev, t->rx_dma, t->len, DMA_FROM_DEVICE);\r\nerr_rx_map:\r\nkfree(dummy_buf);\r\nerr_alloc_dummy_buf:\r\nreturn ret;\r\n}\r\nstatic irqreturn_t dummy_thread_fn(s32 irq, void *data)\r\n{\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t davinci_spi_irq(s32 irq, void *data)\r\n{\r\nstruct davinci_spi *dspi = data;\r\nint status;\r\nstatus = davinci_spi_process_events(dspi);\r\nif (unlikely(status != 0))\r\nclear_io_bits(dspi->base + SPIINT, SPIINT_MASKINT);\r\nif ((!dspi->rcount && !dspi->wcount) || status)\r\ncomplete(&dspi->done);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int davinci_spi_request_dma(struct davinci_spi *dspi)\r\n{\r\ndma_cap_mask_t mask;\r\nstruct device *sdev = dspi->bitbang.master->dev.parent;\r\nint r;\r\ndma_cap_zero(mask);\r\ndma_cap_set(DMA_SLAVE, mask);\r\ndspi->dma_rx = dma_request_channel(mask, edma_filter_fn,\r\n&dspi->dma_rx_chnum);\r\nif (!dspi->dma_rx) {\r\ndev_err(sdev, "request RX DMA channel failed\n");\r\nr = -ENODEV;\r\ngoto rx_dma_failed;\r\n}\r\ndspi->dma_tx = dma_request_channel(mask, edma_filter_fn,\r\n&dspi->dma_tx_chnum);\r\nif (!dspi->dma_tx) {\r\ndev_err(sdev, "request TX DMA channel failed\n");\r\nr = -ENODEV;\r\ngoto tx_dma_failed;\r\n}\r\nreturn 0;\r\ntx_dma_failed:\r\ndma_release_channel(dspi->dma_rx);\r\nrx_dma_failed:\r\nreturn r;\r\n}\r\nstatic int spi_davinci_get_pdata(struct platform_device *pdev,\r\nstruct davinci_spi *dspi)\r\n{\r\nstruct device_node *node = pdev->dev.of_node;\r\nstruct davinci_spi_platform_data *pdata;\r\nunsigned int num_cs, intr_line = 0;\r\nconst struct of_device_id *match;\r\npdata = &dspi->pdata;\r\npdata->version = SPI_VERSION_1;\r\nmatch = of_match_device(davinci_spi_of_match, &pdev->dev);\r\nif (!match)\r\nreturn -ENODEV;\r\nif (match->data == (void *)SPI_VERSION_2)\r\npdata->version = SPI_VERSION_2;\r\nnum_cs = 1;\r\nof_property_read_u32(node, "num-cs", &num_cs);\r\npdata->num_chipselect = num_cs;\r\nof_property_read_u32(node, "ti,davinci-spi-intr-line", &intr_line);\r\npdata->intr_line = intr_line;\r\nreturn 0;\r\n}\r\nstatic struct davinci_spi_platform_data\r\n*spi_davinci_get_pdata(struct platform_device *pdev,\r\nstruct davinci_spi *dspi)\r\n{\r\nreturn -ENODEV;\r\n}\r\nstatic int davinci_spi_probe(struct platform_device *pdev)\r\n{\r\nstruct spi_master *master;\r\nstruct davinci_spi *dspi;\r\nstruct davinci_spi_platform_data *pdata;\r\nstruct resource *r;\r\nresource_size_t dma_rx_chan = SPI_NO_RESOURCE;\r\nresource_size_t dma_tx_chan = SPI_NO_RESOURCE;\r\nint ret = 0;\r\nu32 spipc0;\r\nmaster = spi_alloc_master(&pdev->dev, sizeof(struct davinci_spi));\r\nif (master == NULL) {\r\nret = -ENOMEM;\r\ngoto err;\r\n}\r\nplatform_set_drvdata(pdev, master);\r\ndspi = spi_master_get_devdata(master);\r\nif (dev_get_platdata(&pdev->dev)) {\r\npdata = dev_get_platdata(&pdev->dev);\r\ndspi->pdata = *pdata;\r\n} else {\r\nret = spi_davinci_get_pdata(pdev, dspi);\r\nif (ret < 0)\r\ngoto free_master;\r\n}\r\npdata = &dspi->pdata;\r\ndspi->bytes_per_word = devm_kzalloc(&pdev->dev,\r\nsizeof(*dspi->bytes_per_word) *\r\npdata->num_chipselect, GFP_KERNEL);\r\nif (dspi->bytes_per_word == NULL) {\r\nret = -ENOMEM;\r\ngoto free_master;\r\n}\r\nr = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (r == NULL) {\r\nret = -ENOENT;\r\ngoto free_master;\r\n}\r\ndspi->pbase = r->start;\r\ndspi->base = devm_ioremap_resource(&pdev->dev, r);\r\nif (IS_ERR(dspi->base)) {\r\nret = PTR_ERR(dspi->base);\r\ngoto free_master;\r\n}\r\ndspi->irq = platform_get_irq(pdev, 0);\r\nif (dspi->irq <= 0) {\r\nret = -EINVAL;\r\ngoto free_master;\r\n}\r\nret = devm_request_threaded_irq(&pdev->dev, dspi->irq, davinci_spi_irq,\r\ndummy_thread_fn, 0, dev_name(&pdev->dev), dspi);\r\nif (ret)\r\ngoto free_master;\r\ndspi->bitbang.master = master;\r\ndspi->clk = devm_clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(dspi->clk)) {\r\nret = -ENODEV;\r\ngoto free_master;\r\n}\r\nclk_prepare_enable(dspi->clk);\r\nmaster->dev.of_node = pdev->dev.of_node;\r\nmaster->bus_num = pdev->id;\r\nmaster->num_chipselect = pdata->num_chipselect;\r\nmaster->bits_per_word_mask = SPI_BPW_RANGE_MASK(2, 16);\r\nmaster->setup = davinci_spi_setup;\r\nmaster->cleanup = davinci_spi_cleanup;\r\ndspi->bitbang.chipselect = davinci_spi_chipselect;\r\ndspi->bitbang.setup_transfer = davinci_spi_setup_transfer;\r\ndspi->version = pdata->version;\r\ndspi->bitbang.flags = SPI_NO_CS | SPI_LSB_FIRST | SPI_LOOP;\r\nif (dspi->version == SPI_VERSION_2)\r\ndspi->bitbang.flags |= SPI_READY;\r\nif (pdev->dev.of_node) {\r\nint i;\r\nfor (i = 0; i < pdata->num_chipselect; i++) {\r\nint cs_gpio = of_get_named_gpio(pdev->dev.of_node,\r\n"cs-gpios", i);\r\nif (cs_gpio == -EPROBE_DEFER) {\r\nret = cs_gpio;\r\ngoto free_clk;\r\n}\r\nif (gpio_is_valid(cs_gpio)) {\r\nret = devm_gpio_request(&pdev->dev, cs_gpio,\r\ndev_name(&pdev->dev));\r\nif (ret)\r\ngoto free_clk;\r\n}\r\n}\r\n}\r\nr = platform_get_resource(pdev, IORESOURCE_DMA, 0);\r\nif (r)\r\ndma_rx_chan = r->start;\r\nr = platform_get_resource(pdev, IORESOURCE_DMA, 1);\r\nif (r)\r\ndma_tx_chan = r->start;\r\ndspi->bitbang.txrx_bufs = davinci_spi_bufs;\r\nif (dma_rx_chan != SPI_NO_RESOURCE &&\r\ndma_tx_chan != SPI_NO_RESOURCE) {\r\ndspi->dma_rx_chnum = dma_rx_chan;\r\ndspi->dma_tx_chnum = dma_tx_chan;\r\nret = davinci_spi_request_dma(dspi);\r\nif (ret)\r\ngoto free_clk;\r\ndev_info(&pdev->dev, "DMA: supported\n");\r\ndev_info(&pdev->dev, "DMA: RX channel: %pa, TX channel: %pa, event queue: %d\n",\r\n&dma_rx_chan, &dma_tx_chan,\r\npdata->dma_event_q);\r\n}\r\ndspi->get_rx = davinci_spi_rx_buf_u8;\r\ndspi->get_tx = davinci_spi_tx_buf_u8;\r\ninit_completion(&dspi->done);\r\niowrite32(0, dspi->base + SPIGCR0);\r\nudelay(100);\r\niowrite32(1, dspi->base + SPIGCR0);\r\nspipc0 = SPIPC0_DIFUN_MASK | SPIPC0_DOFUN_MASK | SPIPC0_CLKFUN_MASK;\r\niowrite32(spipc0, dspi->base + SPIPC0);\r\nif (pdata->intr_line)\r\niowrite32(SPI_INTLVL_1, dspi->base + SPILVL);\r\nelse\r\niowrite32(SPI_INTLVL_0, dspi->base + SPILVL);\r\niowrite32(CS_DEFAULT, dspi->base + SPIDEF);\r\nset_io_bits(dspi->base + SPIGCR1, SPIGCR1_CLKMOD_MASK);\r\nset_io_bits(dspi->base + SPIGCR1, SPIGCR1_MASTER_MASK);\r\nset_io_bits(dspi->base + SPIGCR1, SPIGCR1_POWERDOWN_MASK);\r\nret = spi_bitbang_start(&dspi->bitbang);\r\nif (ret)\r\ngoto free_dma;\r\ndev_info(&pdev->dev, "Controller at 0x%p\n", dspi->base);\r\nreturn ret;\r\nfree_dma:\r\ndma_release_channel(dspi->dma_rx);\r\ndma_release_channel(dspi->dma_tx);\r\nfree_clk:\r\nclk_disable_unprepare(dspi->clk);\r\nfree_master:\r\nspi_master_put(master);\r\nerr:\r\nreturn ret;\r\n}\r\nstatic int davinci_spi_remove(struct platform_device *pdev)\r\n{\r\nstruct davinci_spi *dspi;\r\nstruct spi_master *master;\r\nmaster = platform_get_drvdata(pdev);\r\ndspi = spi_master_get_devdata(master);\r\nspi_bitbang_stop(&dspi->bitbang);\r\nclk_disable_unprepare(dspi->clk);\r\nspi_master_put(master);\r\nreturn 0;\r\n}
