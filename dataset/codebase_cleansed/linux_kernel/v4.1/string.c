s64 perf_atoll(const char *str)\r\n{\r\ns64 length;\r\nchar *p;\r\nchar c;\r\nif (!isdigit(str[0]))\r\ngoto out_err;\r\nlength = strtoll(str, &p, 10);\r\nswitch (c = *p++) {\r\ncase 'b': case 'B':\r\nif (*p)\r\ngoto out_err;\r\ncase '\0':\r\nreturn length;\r\ndefault:\r\ngoto out_err;\r\ncase 'k': case 'K':\r\nlength <<= 10;\r\nbreak;\r\ncase 'm': case 'M':\r\nlength <<= 20;\r\nbreak;\r\ncase 'g': case 'G':\r\nlength <<= 30;\r\nbreak;\r\ncase 't': case 'T':\r\nlength <<= 40;\r\nbreak;\r\n}\r\nif (islower(c)) {\r\nif (strcmp(p, "b") != 0)\r\ngoto out_err;\r\n} else {\r\nif (strcmp(p, "B") != 0)\r\ngoto out_err;\r\n}\r\nreturn length;\r\nout_err:\r\nreturn -1;\r\n}\r\nstatic const char *skip_sep(const char *cp)\r\n{\r\nwhile (*cp && isspace(*cp))\r\ncp++;\r\nreturn cp;\r\n}\r\nstatic const char *skip_arg(const char *cp)\r\n{\r\nwhile (*cp && !isspace(*cp))\r\ncp++;\r\nreturn cp;\r\n}\r\nstatic int count_argc(const char *str)\r\n{\r\nint count = 0;\r\nwhile (*str) {\r\nstr = skip_sep(str);\r\nif (*str) {\r\ncount++;\r\nstr = skip_arg(str);\r\n}\r\n}\r\nreturn count;\r\n}\r\nvoid argv_free(char **argv)\r\n{\r\nchar **p;\r\nfor (p = argv; *p; p++)\r\nzfree(p);\r\nfree(argv);\r\n}\r\nchar **argv_split(const char *str, int *argcp)\r\n{\r\nint argc = count_argc(str);\r\nchar **argv = zalloc(sizeof(*argv) * (argc+1));\r\nchar **argvp;\r\nif (argv == NULL)\r\ngoto out;\r\nif (argcp)\r\n*argcp = argc;\r\nargvp = argv;\r\nwhile (*str) {\r\nstr = skip_sep(str);\r\nif (*str) {\r\nconst char *p = str;\r\nchar *t;\r\nstr = skip_arg(str);\r\nt = strndup(p, str-p);\r\nif (t == NULL)\r\ngoto fail;\r\n*argvp++ = t;\r\n}\r\n}\r\n*argvp = NULL;\r\nout:\r\nreturn argv;\r\nfail:\r\nargv_free(argv);\r\nreturn NULL;\r\n}\r\nstatic bool __match_charclass(const char *pat, char c, const char **npat)\r\n{\r\nbool complement = false, ret = true;\r\nif (*pat == '!') {\r\ncomplement = true;\r\npat++;\r\n}\r\nif (*pat++ == c)\r\ngoto end;\r\nwhile (*pat && *pat != ']') {\r\nif (*pat == '-' && *(pat + 1) != ']') {\r\nif (*(pat - 1) <= c && c <= *(pat + 1))\r\ngoto end;\r\nif (*(pat - 1) > *(pat + 1))\r\ngoto error;\r\npat += 2;\r\n} else if (*pat++ == c)\r\ngoto end;\r\n}\r\nif (!*pat)\r\ngoto error;\r\nret = false;\r\nend:\r\nwhile (*pat && *pat != ']')\r\npat++;\r\nif (!*pat)\r\ngoto error;\r\n*npat = pat + 1;\r\nreturn complement ? !ret : ret;\r\nerror:\r\nreturn false;\r\n}\r\nstatic bool __match_glob(const char *str, const char *pat, bool ignore_space)\r\n{\r\nwhile (*str && *pat && *pat != '*') {\r\nif (ignore_space) {\r\nif (isspace(*str)) {\r\nstr++;\r\ncontinue;\r\n}\r\nif (isspace(*pat)) {\r\npat++;\r\ncontinue;\r\n}\r\n}\r\nif (*pat == '?') {\r\nstr++;\r\npat++;\r\ncontinue;\r\n} else if (*pat == '[')\r\nif (__match_charclass(pat + 1, *str, &pat)) {\r\nstr++;\r\ncontinue;\r\n} else\r\nreturn false;\r\nelse if (*pat == '\\')\r\npat++;\r\nif (*str++ != *pat++)\r\nreturn false;\r\n}\r\nif (*pat == '*') {\r\nwhile (*pat == '*')\r\npat++;\r\nif (!*pat)\r\nreturn true;\r\nwhile (*str)\r\nif (__match_glob(str++, pat, ignore_space))\r\nreturn true;\r\n}\r\nreturn !*str && !*pat;\r\n}\r\nbool strglobmatch(const char *str, const char *pat)\r\n{\r\nreturn __match_glob(str, pat, false);\r\n}\r\nbool strlazymatch(const char *str, const char *pat)\r\n{\r\nreturn __match_glob(str, pat, true);\r\n}\r\nint strtailcmp(const char *s1, const char *s2)\r\n{\r\nint i1 = strlen(s1);\r\nint i2 = strlen(s2);\r\nwhile (--i1 >= 0 && --i2 >= 0) {\r\nif (s1[i1] != s2[i2])\r\nreturn s1[i1] - s2[i2];\r\n}\r\nreturn 0;\r\n}\r\nchar *strxfrchar(char *s, char from, char to)\r\n{\r\nchar *p = s;\r\nwhile ((p = strchr(p, from)) != NULL)\r\n*p++ = to;\r\nreturn s;\r\n}\r\nchar *ltrim(char *s)\r\n{\r\nint len = strlen(s);\r\nwhile (len && isspace(*s)) {\r\nlen--;\r\ns++;\r\n}\r\nreturn s;\r\n}\r\nchar *rtrim(char *s)\r\n{\r\nsize_t size = strlen(s);\r\nchar *end;\r\nif (!size)\r\nreturn s;\r\nend = s + size - 1;\r\nwhile (end >= s && isspace(*end))\r\nend--;\r\n*(end + 1) = '\0';\r\nreturn s;\r\n}\r\nvoid *memdup(const void *src, size_t len)\r\n{\r\nvoid *p;\r\np = malloc(len);\r\nif (p)\r\nmemcpy(p, src, len);\r\nreturn p;\r\n}
