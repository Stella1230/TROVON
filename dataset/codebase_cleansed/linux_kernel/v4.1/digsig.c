int integrity_digsig_verify(const unsigned int id, const char *sig, int siglen,\r\nconst char *digest, int digestlen)\r\n{\r\nif (id >= INTEGRITY_KEYRING_MAX)\r\nreturn -EINVAL;\r\nif (!keyring[id]) {\r\nkeyring[id] =\r\nrequest_key(&key_type_keyring, keyring_name[id], NULL);\r\nif (IS_ERR(keyring[id])) {\r\nint err = PTR_ERR(keyring[id]);\r\npr_err("no %s keyring: %d\n", keyring_name[id], err);\r\nkeyring[id] = NULL;\r\nreturn err;\r\n}\r\n}\r\nswitch (sig[1]) {\r\ncase 1:\r\nreturn digsig_verify(keyring[id], sig + 1, siglen - 1,\r\ndigest, digestlen);\r\ncase 2:\r\nreturn asymmetric_verify(keyring[id], sig, siglen,\r\ndigest, digestlen);\r\n}\r\nreturn -EOPNOTSUPP;\r\n}\r\nint __init integrity_init_keyring(const unsigned int id)\r\n{\r\nconst struct cred *cred = current_cred();\r\nint err = 0;\r\nkeyring[id] = keyring_alloc(keyring_name[id], KUIDT_INIT(0),\r\nKGIDT_INIT(0), cred,\r\n((KEY_POS_ALL & ~KEY_POS_SETATTR) |\r\nKEY_USR_VIEW | KEY_USR_READ |\r\nKEY_USR_WRITE | KEY_USR_SEARCH),\r\nKEY_ALLOC_NOT_IN_QUOTA, NULL);\r\nif (!IS_ERR(keyring[id]))\r\nset_bit(KEY_FLAG_TRUSTED_ONLY, &keyring[id]->flags);\r\nelse {\r\nerr = PTR_ERR(keyring[id]);\r\npr_info("Can't allocate %s keyring (%d)\n",\r\nkeyring_name[id], err);\r\nkeyring[id] = NULL;\r\n}\r\nreturn err;\r\n}\r\nint __init integrity_load_x509(const unsigned int id, char *path)\r\n{\r\nkey_ref_t key;\r\nchar *data;\r\nint rc;\r\nif (!keyring[id])\r\nreturn -EINVAL;\r\nrc = integrity_read_file(path, &data);\r\nif (rc < 0)\r\nreturn rc;\r\nkey = key_create_or_update(make_key_ref(keyring[id], 1),\r\n"asymmetric",\r\nNULL,\r\ndata,\r\nrc,\r\n((KEY_POS_ALL & ~KEY_POS_SETATTR) |\r\nKEY_USR_VIEW | KEY_USR_READ),\r\nKEY_ALLOC_NOT_IN_QUOTA | KEY_ALLOC_TRUSTED);\r\nif (IS_ERR(key)) {\r\nrc = PTR_ERR(key);\r\npr_err("Problem loading X.509 certificate (%d): %s\n",\r\nrc, path);\r\n} else {\r\npr_notice("Loaded X.509 cert '%s': %s\n",\r\nkey_ref_to_ptr(key)->description, path);\r\nkey_ref_put(key);\r\n}\r\nkfree(data);\r\nreturn 0;\r\n}
