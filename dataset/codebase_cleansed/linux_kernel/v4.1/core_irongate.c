static int\r\nmk_conf_addr(struct pci_bus *pbus, unsigned int device_fn, int where,\r\nunsigned long *pci_addr, unsigned char *type1)\r\n{\r\nunsigned long addr;\r\nu8 bus = pbus->number;\r\nDBG_CFG(("mk_conf_addr(bus=%d ,device_fn=0x%x, where=0x%x, "\r\n"pci_addr=0x%p, type1=0x%p)\n",\r\nbus, device_fn, where, pci_addr, type1));\r\n*type1 = (bus != 0);\r\naddr = (bus << 16) | (device_fn << 8) | where;\r\naddr |= IRONGATE_CONF;\r\n*pci_addr = addr;\r\nDBG_CFG(("mk_conf_addr: returning pci_addr 0x%lx\n", addr));\r\nreturn 0;\r\n}\r\nstatic int\r\nirongate_read_config(struct pci_bus *bus, unsigned int devfn, int where,\r\nint size, u32 *value)\r\n{\r\nunsigned long addr;\r\nunsigned char type1;\r\nif (mk_conf_addr(bus, devfn, where, &addr, &type1))\r\nreturn PCIBIOS_DEVICE_NOT_FOUND;\r\nswitch (size) {\r\ncase 1:\r\n*value = __kernel_ldbu(*(vucp)addr);\r\nbreak;\r\ncase 2:\r\n*value = __kernel_ldwu(*(vusp)addr);\r\nbreak;\r\ncase 4:\r\n*value = *(vuip)addr;\r\nbreak;\r\n}\r\nreturn PCIBIOS_SUCCESSFUL;\r\n}\r\nstatic int\r\nirongate_write_config(struct pci_bus *bus, unsigned int devfn, int where,\r\nint size, u32 value)\r\n{\r\nunsigned long addr;\r\nunsigned char type1;\r\nif (mk_conf_addr(bus, devfn, where, &addr, &type1))\r\nreturn PCIBIOS_DEVICE_NOT_FOUND;\r\nswitch (size) {\r\ncase 1:\r\n__kernel_stb(value, *(vucp)addr);\r\nmb();\r\n__kernel_ldbu(*(vucp)addr);\r\nbreak;\r\ncase 2:\r\n__kernel_stw(value, *(vusp)addr);\r\nmb();\r\n__kernel_ldwu(*(vusp)addr);\r\nbreak;\r\ncase 4:\r\n*(vuip)addr = value;\r\nmb();\r\n*(vuip)addr;\r\nbreak;\r\n}\r\nreturn PCIBIOS_SUCCESSFUL;\r\n}\r\nint\r\nirongate_pci_clr_err(void)\r\n{\r\nunsigned int nmi_ctl=0;\r\nunsigned int IRONGATE_jd;\r\nagain:\r\nIRONGATE_jd = IRONGATE0->stat_cmd;\r\nprintk("Iron stat_cmd %x\n", IRONGATE_jd);\r\nIRONGATE0->stat_cmd = IRONGATE_jd;\r\nmb();\r\nIRONGATE_jd = IRONGATE0->stat_cmd;\r\nIRONGATE_jd = *IronECC;\r\nprintk("Iron ECC %x\n", IRONGATE_jd);\r\n*IronECC = IRONGATE_jd;\r\nmb();\r\nIRONGATE_jd = *IronECC;\r\nnmi_ctl = inb(0x61);\r\nnmi_ctl |= 0x0c;\r\noutb(nmi_ctl, 0x61);\r\nnmi_ctl &= ~0x0c;\r\noutb(nmi_ctl, 0x61);\r\nIRONGATE_jd = *IronECC;\r\nif (IRONGATE_jd & 0x300) goto again;\r\nreturn 0;\r\n}\r\nstatic void __init\r\nalbacore_init_arch(void)\r\n{\r\nunsigned long memtop = max_low_pfn << PAGE_SHIFT;\r\nunsigned long pci_mem = (memtop + 0x1000000UL) & ~0xffffffUL;\r\nstruct percpu_struct *cpu;\r\nint pal_rev, pal_var;\r\ncpu = (struct percpu_struct*)((char*)hwrpb + hwrpb->processor_offset);\r\npal_rev = cpu->pal_revision & 0xffff;\r\npal_var = (cpu->pal_revision >> 16) & 0xff;\r\nif (alpha_using_srm &&\r\n(pal_rev < 0x13e || (pal_rev == 0x13e && pal_var < 2)))\r\nprintk(KERN_WARNING "WARNING! Upgrade to SRM A5.6-19 "\r\n"or later\n");\r\nif (pci_mem > IRONGATE_3GB)\r\npci_mem = IRONGATE_3GB;\r\nIRONGATE0->pci_mem = pci_mem;\r\nalpha_mv.min_mem_address = pci_mem;\r\nif (memtop > pci_mem) {\r\n#ifdef CONFIG_BLK_DEV_INITRD\r\nextern unsigned long initrd_start, initrd_end;\r\nextern void *move_initrd(unsigned long);\r\nif (initrd_end && __pa(initrd_end) > pci_mem) {\r\nunsigned long size;\r\nsize = initrd_end - initrd_start;\r\nfree_bootmem_node(NODE_DATA(0), __pa(initrd_start),\r\nPAGE_ALIGN(size));\r\nif (!move_initrd(pci_mem))\r\nprintk("irongate_init_arch: initrd too big "\r\n"(%ldK)\ndisabling initrd\n",\r\nsize / 1024);\r\n}\r\n#endif\r\nreserve_bootmem_node(NODE_DATA(0), pci_mem, memtop -\r\npci_mem, BOOTMEM_DEFAULT);\r\nprintk("irongate_init_arch: temporarily reserving "\r\n"region %08lx-%08lx for PCI\n", pci_mem, memtop - 1);\r\n}\r\n}\r\nstatic void __init\r\nirongate_setup_agp(void)\r\n{\r\nIRONGATE0->agpva = IRONGATE0->agpva & ~0xf;\r\nalpha_agpgart_size = 0;\r\n}\r\nvoid __init\r\nirongate_init_arch(void)\r\n{\r\nstruct pci_controller *hose;\r\nint amd761 = (IRONGATE0->dev_vendor >> 16) > 0x7006;\r\nIronECC = amd761 ? &IRONGATE0->bacsr54_eccms761 : &IRONGATE0->dramms;\r\nirongate_pci_clr_err();\r\nif (amd761)\r\nalbacore_init_arch();\r\nirongate_setup_agp();\r\npci_isa_hose = hose = alloc_pci_controller();\r\nhose->io_space = &ioport_resource;\r\nhose->mem_space = &iomem_resource;\r\nhose->index = 0;\r\nhose->sparse_mem_base = 0;\r\nhose->sparse_io_base = 0;\r\nhose->dense_mem_base\r\n= (IRONGATE_MEM & 0xffffffffffUL) | 0x80000000000UL;\r\nhose->dense_io_base\r\n= (IRONGATE_IO & 0xffffffffffUL) | 0x80000000000UL;\r\nhose->sg_isa = hose->sg_pci = NULL;\r\n__direct_map_base = 0;\r\n__direct_map_size = 0xffffffff;\r\n}\r\nvoid __iomem *\r\nirongate_ioremap(unsigned long addr, unsigned long size)\r\n{\r\nstruct vm_struct *area;\r\nunsigned long vaddr;\r\nunsigned long baddr, last;\r\nu32 *mmio_regs, *gatt_pages, *cur_gatt, pte;\r\nunsigned long gart_bus_addr;\r\nif (!alpha_agpgart_size)\r\nreturn (void __iomem *)(addr + IRONGATE_MEM);\r\ngart_bus_addr = (unsigned long)IRONGATE0->bar0 &\r\nPCI_BASE_ADDRESS_MEM_MASK;\r\ndo {\r\nif (addr >= gart_bus_addr && addr + size - 1 <\r\ngart_bus_addr + alpha_agpgart_size)\r\nbreak;\r\nreturn (void __iomem *)(addr + IRONGATE_MEM);\r\n} while(0);\r\nmmio_regs = (u32 *)(((unsigned long)IRONGATE0->bar1 &\r\nPCI_BASE_ADDRESS_MEM_MASK) + IRONGATE_MEM);\r\ngatt_pages = (u32 *)(phys_to_virt(mmio_regs[1]));\r\nif (addr & ~PAGE_MASK) {\r\nprintk("AGP ioremap failed... addr not page aligned (0x%lx)\n",\r\naddr);\r\nreturn (void __iomem *)(addr + IRONGATE_MEM);\r\n}\r\nlast = addr + size - 1;\r\nsize = PAGE_ALIGN(last) - addr;\r\n#if 0\r\nprintk("irongate_ioremap(0x%lx, 0x%lx)\n", addr, size);\r\nprintk("irongate_ioremap: gart_bus_addr 0x%lx\n", gart_bus_addr);\r\nprintk("irongate_ioremap: gart_aper_size 0x%lx\n", gart_aper_size);\r\nprintk("irongate_ioremap: mmio_regs %p\n", mmio_regs);\r\nprintk("irongate_ioremap: gatt_pages %p\n", gatt_pages);\r\nfor(baddr = addr; baddr <= last; baddr += PAGE_SIZE)\r\n{\r\ncur_gatt = phys_to_virt(GET_GATT(baddr) & ~1);\r\npte = cur_gatt[GET_GATT_OFF(baddr)] & ~1;\r\nprintk("irongate_ioremap: cur_gatt %p pte 0x%x\n",\r\ncur_gatt, pte);\r\n}\r\n#endif\r\narea = get_vm_area(size, VM_IOREMAP);\r\nif (!area) return NULL;\r\nfor(baddr = addr, vaddr = (unsigned long)area->addr;\r\nbaddr <= last;\r\nbaddr += PAGE_SIZE, vaddr += PAGE_SIZE)\r\n{\r\ncur_gatt = phys_to_virt(GET_GATT(baddr) & ~1);\r\npte = cur_gatt[GET_GATT_OFF(baddr)] & ~1;\r\nif (__alpha_remap_area_pages(vaddr,\r\npte, PAGE_SIZE, 0)) {\r\nprintk("AGP ioremap: FAILED to map...\n");\r\nvfree(area->addr);\r\nreturn NULL;\r\n}\r\n}\r\nflush_tlb_all();\r\nvaddr = (unsigned long)area->addr + (addr & ~PAGE_MASK);\r\n#if 0\r\nprintk("irongate_ioremap(0x%lx, 0x%lx) returning 0x%lx\n",\r\naddr, size, vaddr);\r\n#endif\r\nreturn (void __iomem *)vaddr;\r\n}\r\nvoid\r\nirongate_iounmap(volatile void __iomem *xaddr)\r\n{\r\nunsigned long addr = (unsigned long) xaddr;\r\nif (((long)addr >> 41) == -2)\r\nreturn;\r\nif (addr)\r\nreturn vfree((void *)(PAGE_MASK & addr));\r\n}
