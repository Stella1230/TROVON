static inline struct dwapb_gpio_port *\r\nto_dwapb_gpio_port(struct bgpio_chip *bgc)\r\n{\r\nreturn container_of(bgc, struct dwapb_gpio_port, bgc);\r\n}\r\nstatic inline u32 dwapb_read(struct dwapb_gpio *gpio, unsigned int offset)\r\n{\r\nstruct bgpio_chip *bgc = &gpio->ports[0].bgc;\r\nvoid __iomem *reg_base = gpio->regs;\r\nreturn bgc->read_reg(reg_base + offset);\r\n}\r\nstatic inline void dwapb_write(struct dwapb_gpio *gpio, unsigned int offset,\r\nu32 val)\r\n{\r\nstruct bgpio_chip *bgc = &gpio->ports[0].bgc;\r\nvoid __iomem *reg_base = gpio->regs;\r\nbgc->write_reg(reg_base + offset, val);\r\n}\r\nstatic int dwapb_gpio_to_irq(struct gpio_chip *gc, unsigned offset)\r\n{\r\nstruct bgpio_chip *bgc = to_bgpio_chip(gc);\r\nstruct dwapb_gpio_port *port = to_dwapb_gpio_port(bgc);\r\nstruct dwapb_gpio *gpio = port->gpio;\r\nreturn irq_find_mapping(gpio->domain, offset);\r\n}\r\nstatic void dwapb_toggle_trigger(struct dwapb_gpio *gpio, unsigned int offs)\r\n{\r\nu32 v = dwapb_read(gpio, GPIO_INT_POLARITY);\r\nif (gpio_get_value(gpio->ports[0].bgc.gc.base + offs))\r\nv &= ~BIT(offs);\r\nelse\r\nv |= BIT(offs);\r\ndwapb_write(gpio, GPIO_INT_POLARITY, v);\r\n}\r\nstatic u32 dwapb_do_irq(struct dwapb_gpio *gpio)\r\n{\r\nu32 irq_status = readl_relaxed(gpio->regs + GPIO_INTSTATUS);\r\nu32 ret = irq_status;\r\nwhile (irq_status) {\r\nint hwirq = fls(irq_status) - 1;\r\nint gpio_irq = irq_find_mapping(gpio->domain, hwirq);\r\ngeneric_handle_irq(gpio_irq);\r\nirq_status &= ~BIT(hwirq);\r\nif ((irq_get_trigger_type(gpio_irq) & IRQ_TYPE_SENSE_MASK)\r\n== IRQ_TYPE_EDGE_BOTH)\r\ndwapb_toggle_trigger(gpio, hwirq);\r\n}\r\nreturn ret;\r\n}\r\nstatic void dwapb_irq_handler(u32 irq, struct irq_desc *desc)\r\n{\r\nstruct dwapb_gpio *gpio = irq_get_handler_data(irq);\r\nstruct irq_chip *chip = irq_desc_get_chip(desc);\r\ndwapb_do_irq(gpio);\r\nif (chip->irq_eoi)\r\nchip->irq_eoi(irq_desc_get_irq_data(desc));\r\n}\r\nstatic void dwapb_irq_enable(struct irq_data *d)\r\n{\r\nstruct irq_chip_generic *igc = irq_data_get_irq_chip_data(d);\r\nstruct dwapb_gpio *gpio = igc->private;\r\nstruct bgpio_chip *bgc = &gpio->ports[0].bgc;\r\nunsigned long flags;\r\nu32 val;\r\nspin_lock_irqsave(&bgc->lock, flags);\r\nval = dwapb_read(gpio, GPIO_INTEN);\r\nval |= BIT(d->hwirq);\r\ndwapb_write(gpio, GPIO_INTEN, val);\r\nspin_unlock_irqrestore(&bgc->lock, flags);\r\n}\r\nstatic void dwapb_irq_disable(struct irq_data *d)\r\n{\r\nstruct irq_chip_generic *igc = irq_data_get_irq_chip_data(d);\r\nstruct dwapb_gpio *gpio = igc->private;\r\nstruct bgpio_chip *bgc = &gpio->ports[0].bgc;\r\nunsigned long flags;\r\nu32 val;\r\nspin_lock_irqsave(&bgc->lock, flags);\r\nval = dwapb_read(gpio, GPIO_INTEN);\r\nval &= ~BIT(d->hwirq);\r\ndwapb_write(gpio, GPIO_INTEN, val);\r\nspin_unlock_irqrestore(&bgc->lock, flags);\r\n}\r\nstatic int dwapb_irq_reqres(struct irq_data *d)\r\n{\r\nstruct irq_chip_generic *igc = irq_data_get_irq_chip_data(d);\r\nstruct dwapb_gpio *gpio = igc->private;\r\nstruct bgpio_chip *bgc = &gpio->ports[0].bgc;\r\nif (gpiochip_lock_as_irq(&bgc->gc, irqd_to_hwirq(d))) {\r\ndev_err(gpio->dev, "unable to lock HW IRQ %lu for IRQ\n",\r\nirqd_to_hwirq(d));\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic void dwapb_irq_relres(struct irq_data *d)\r\n{\r\nstruct irq_chip_generic *igc = irq_data_get_irq_chip_data(d);\r\nstruct dwapb_gpio *gpio = igc->private;\r\nstruct bgpio_chip *bgc = &gpio->ports[0].bgc;\r\ngpiochip_unlock_as_irq(&bgc->gc, irqd_to_hwirq(d));\r\n}\r\nstatic int dwapb_irq_set_type(struct irq_data *d, u32 type)\r\n{\r\nstruct irq_chip_generic *igc = irq_data_get_irq_chip_data(d);\r\nstruct dwapb_gpio *gpio = igc->private;\r\nstruct bgpio_chip *bgc = &gpio->ports[0].bgc;\r\nint bit = d->hwirq;\r\nunsigned long level, polarity, flags;\r\nif (type & ~(IRQ_TYPE_EDGE_RISING | IRQ_TYPE_EDGE_FALLING |\r\nIRQ_TYPE_LEVEL_HIGH | IRQ_TYPE_LEVEL_LOW))\r\nreturn -EINVAL;\r\nspin_lock_irqsave(&bgc->lock, flags);\r\nlevel = dwapb_read(gpio, GPIO_INTTYPE_LEVEL);\r\npolarity = dwapb_read(gpio, GPIO_INT_POLARITY);\r\nswitch (type) {\r\ncase IRQ_TYPE_EDGE_BOTH:\r\nlevel |= BIT(bit);\r\ndwapb_toggle_trigger(gpio, bit);\r\nbreak;\r\ncase IRQ_TYPE_EDGE_RISING:\r\nlevel |= BIT(bit);\r\npolarity |= BIT(bit);\r\nbreak;\r\ncase IRQ_TYPE_EDGE_FALLING:\r\nlevel |= BIT(bit);\r\npolarity &= ~BIT(bit);\r\nbreak;\r\ncase IRQ_TYPE_LEVEL_HIGH:\r\nlevel &= ~BIT(bit);\r\npolarity |= BIT(bit);\r\nbreak;\r\ncase IRQ_TYPE_LEVEL_LOW:\r\nlevel &= ~BIT(bit);\r\npolarity &= ~BIT(bit);\r\nbreak;\r\n}\r\nirq_setup_alt_chip(d, type);\r\ndwapb_write(gpio, GPIO_INTTYPE_LEVEL, level);\r\ndwapb_write(gpio, GPIO_INT_POLARITY, polarity);\r\nspin_unlock_irqrestore(&bgc->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int dwapb_gpio_set_debounce(struct gpio_chip *gc,\r\nunsigned offset, unsigned debounce)\r\n{\r\nstruct bgpio_chip *bgc = to_bgpio_chip(gc);\r\nstruct dwapb_gpio_port *port = to_dwapb_gpio_port(bgc);\r\nstruct dwapb_gpio *gpio = port->gpio;\r\nunsigned long flags, val_deb;\r\nunsigned long mask = bgc->pin2mask(bgc, offset);\r\nspin_lock_irqsave(&bgc->lock, flags);\r\nval_deb = dwapb_read(gpio, GPIO_PORTA_DEBOUNCE);\r\nif (debounce)\r\ndwapb_write(gpio, GPIO_PORTA_DEBOUNCE, val_deb | mask);\r\nelse\r\ndwapb_write(gpio, GPIO_PORTA_DEBOUNCE, val_deb & ~mask);\r\nspin_unlock_irqrestore(&bgc->lock, flags);\r\nreturn 0;\r\n}\r\nstatic irqreturn_t dwapb_irq_handler_mfd(int irq, void *dev_id)\r\n{\r\nu32 worked;\r\nstruct dwapb_gpio *gpio = dev_id;\r\nworked = dwapb_do_irq(gpio);\r\nreturn worked ? IRQ_HANDLED : IRQ_NONE;\r\n}\r\nstatic void dwapb_configure_irqs(struct dwapb_gpio *gpio,\r\nstruct dwapb_gpio_port *port,\r\nstruct dwapb_port_property *pp)\r\n{\r\nstruct gpio_chip *gc = &port->bgc.gc;\r\nstruct device_node *node = pp->node;\r\nstruct irq_chip_generic *irq_gc = NULL;\r\nunsigned int hwirq, ngpio = gc->ngpio;\r\nstruct irq_chip_type *ct;\r\nint err, i;\r\ngpio->domain = irq_domain_add_linear(node, ngpio,\r\n&irq_generic_chip_ops, gpio);\r\nif (!gpio->domain)\r\nreturn;\r\nerr = irq_alloc_domain_generic_chips(gpio->domain, ngpio, 2,\r\n"gpio-dwapb", handle_level_irq,\r\nIRQ_NOREQUEST, 0,\r\nIRQ_GC_INIT_NESTED_LOCK);\r\nif (err) {\r\ndev_info(gpio->dev, "irq_alloc_domain_generic_chips failed\n");\r\nirq_domain_remove(gpio->domain);\r\ngpio->domain = NULL;\r\nreturn;\r\n}\r\nirq_gc = irq_get_domain_generic_chip(gpio->domain, 0);\r\nif (!irq_gc) {\r\nirq_domain_remove(gpio->domain);\r\ngpio->domain = NULL;\r\nreturn;\r\n}\r\nirq_gc->reg_base = gpio->regs;\r\nirq_gc->private = gpio;\r\nfor (i = 0; i < 2; i++) {\r\nct = &irq_gc->chip_types[i];\r\nct->chip.irq_ack = irq_gc_ack_set_bit;\r\nct->chip.irq_mask = irq_gc_mask_set_bit;\r\nct->chip.irq_unmask = irq_gc_mask_clr_bit;\r\nct->chip.irq_set_type = dwapb_irq_set_type;\r\nct->chip.irq_enable = dwapb_irq_enable;\r\nct->chip.irq_disable = dwapb_irq_disable;\r\nct->chip.irq_request_resources = dwapb_irq_reqres;\r\nct->chip.irq_release_resources = dwapb_irq_relres;\r\nct->regs.ack = GPIO_PORTA_EOI;\r\nct->regs.mask = GPIO_INTMASK;\r\nct->type = IRQ_TYPE_LEVEL_MASK;\r\n}\r\nirq_gc->chip_types[0].type = IRQ_TYPE_LEVEL_MASK;\r\nirq_gc->chip_types[1].type = IRQ_TYPE_EDGE_BOTH;\r\nirq_gc->chip_types[1].handler = handle_edge_irq;\r\nif (!pp->irq_shared) {\r\nirq_set_chained_handler(pp->irq, dwapb_irq_handler);\r\nirq_set_handler_data(pp->irq, gpio);\r\n} else {\r\nerr = devm_request_irq(gpio->dev, pp->irq,\r\ndwapb_irq_handler_mfd,\r\nIRQF_SHARED, "gpio-dwapb-mfd", gpio);\r\nif (err) {\r\ndev_err(gpio->dev, "error requesting IRQ\n");\r\nirq_domain_remove(gpio->domain);\r\ngpio->domain = NULL;\r\nreturn;\r\n}\r\n}\r\nfor (hwirq = 0 ; hwirq < ngpio ; hwirq++)\r\nirq_create_mapping(gpio->domain, hwirq);\r\nport->bgc.gc.to_irq = dwapb_gpio_to_irq;\r\n}\r\nstatic void dwapb_irq_teardown(struct dwapb_gpio *gpio)\r\n{\r\nstruct dwapb_gpio_port *port = &gpio->ports[0];\r\nstruct gpio_chip *gc = &port->bgc.gc;\r\nunsigned int ngpio = gc->ngpio;\r\nirq_hw_number_t hwirq;\r\nif (!gpio->domain)\r\nreturn;\r\nfor (hwirq = 0 ; hwirq < ngpio ; hwirq++)\r\nirq_dispose_mapping(irq_find_mapping(gpio->domain, hwirq));\r\nirq_domain_remove(gpio->domain);\r\ngpio->domain = NULL;\r\n}\r\nstatic int dwapb_gpio_add_port(struct dwapb_gpio *gpio,\r\nstruct dwapb_port_property *pp,\r\nunsigned int offs)\r\n{\r\nstruct dwapb_gpio_port *port;\r\nvoid __iomem *dat, *set, *dirout;\r\nint err;\r\nport = &gpio->ports[offs];\r\nport->gpio = gpio;\r\nport->idx = pp->idx;\r\n#ifdef CONFIG_PM_SLEEP\r\nport->ctx = devm_kzalloc(gpio->dev, sizeof(*port->ctx), GFP_KERNEL);\r\nif (!port->ctx)\r\nreturn -ENOMEM;\r\n#endif\r\ndat = gpio->regs + GPIO_EXT_PORTA + (pp->idx * GPIO_EXT_PORT_SIZE);\r\nset = gpio->regs + GPIO_SWPORTA_DR + (pp->idx * GPIO_SWPORT_DR_SIZE);\r\ndirout = gpio->regs + GPIO_SWPORTA_DDR +\r\n(pp->idx * GPIO_SWPORT_DDR_SIZE);\r\nerr = bgpio_init(&port->bgc, gpio->dev, 4, dat, set, NULL, dirout,\r\nNULL, false);\r\nif (err) {\r\ndev_err(gpio->dev, "failed to init gpio chip for %s\n",\r\npp->name);\r\nreturn err;\r\n}\r\n#ifdef CONFIG_OF_GPIO\r\nport->bgc.gc.of_node = pp->node;\r\n#endif\r\nport->bgc.gc.ngpio = pp->ngpio;\r\nport->bgc.gc.base = pp->gpio_base;\r\nif (pp->idx == 0)\r\nport->bgc.gc.set_debounce = dwapb_gpio_set_debounce;\r\nif (pp->irq)\r\ndwapb_configure_irqs(gpio, port, pp);\r\nerr = gpiochip_add(&port->bgc.gc);\r\nif (err)\r\ndev_err(gpio->dev, "failed to register gpiochip for %s\n",\r\npp->name);\r\nelse\r\nport->is_registered = true;\r\nreturn err;\r\n}\r\nstatic void dwapb_gpio_unregister(struct dwapb_gpio *gpio)\r\n{\r\nunsigned int m;\r\nfor (m = 0; m < gpio->nr_ports; ++m)\r\nif (gpio->ports[m].is_registered)\r\ngpiochip_remove(&gpio->ports[m].bgc.gc);\r\n}\r\nstatic struct dwapb_platform_data *\r\ndwapb_gpio_get_pdata_of(struct device *dev)\r\n{\r\nstruct device_node *node, *port_np;\r\nstruct dwapb_platform_data *pdata;\r\nstruct dwapb_port_property *pp;\r\nint nports;\r\nint i;\r\nnode = dev->of_node;\r\nif (!IS_ENABLED(CONFIG_OF_GPIO) || !node)\r\nreturn ERR_PTR(-ENODEV);\r\nnports = of_get_child_count(node);\r\nif (nports == 0)\r\nreturn ERR_PTR(-ENODEV);\r\npdata = devm_kzalloc(dev, sizeof(*pdata), GFP_KERNEL);\r\nif (!pdata)\r\nreturn ERR_PTR(-ENOMEM);\r\npdata->properties = devm_kcalloc(dev, nports, sizeof(*pp), GFP_KERNEL);\r\nif (!pdata->properties)\r\nreturn ERR_PTR(-ENOMEM);\r\npdata->nports = nports;\r\ni = 0;\r\nfor_each_child_of_node(node, port_np) {\r\npp = &pdata->properties[i++];\r\npp->node = port_np;\r\nif (of_property_read_u32(port_np, "reg", &pp->idx) ||\r\npp->idx >= DWAPB_MAX_PORTS) {\r\ndev_err(dev, "missing/invalid port index for %s\n",\r\nport_np->full_name);\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nif (of_property_read_u32(port_np, "snps,nr-gpios",\r\n&pp->ngpio)) {\r\ndev_info(dev, "failed to get number of gpios for %s\n",\r\nport_np->full_name);\r\npp->ngpio = 32;\r\n}\r\nif (pp->idx == 0 &&\r\nof_property_read_bool(port_np, "interrupt-controller")) {\r\npp->irq = irq_of_parse_and_map(port_np, 0);\r\nif (!pp->irq) {\r\ndev_warn(dev, "no irq for bank %s\n",\r\nport_np->full_name);\r\n}\r\n}\r\npp->irq_shared = false;\r\npp->gpio_base = -1;\r\npp->name = port_np->full_name;\r\n}\r\nreturn pdata;\r\n}\r\nstatic int dwapb_gpio_probe(struct platform_device *pdev)\r\n{\r\nunsigned int i;\r\nstruct resource *res;\r\nstruct dwapb_gpio *gpio;\r\nint err;\r\nstruct device *dev = &pdev->dev;\r\nstruct dwapb_platform_data *pdata = dev_get_platdata(dev);\r\nif (!pdata) {\r\npdata = dwapb_gpio_get_pdata_of(dev);\r\nif (IS_ERR(pdata))\r\nreturn PTR_ERR(pdata);\r\n}\r\nif (!pdata->nports)\r\nreturn -ENODEV;\r\ngpio = devm_kzalloc(&pdev->dev, sizeof(*gpio), GFP_KERNEL);\r\nif (!gpio)\r\nreturn -ENOMEM;\r\ngpio->dev = &pdev->dev;\r\ngpio->nr_ports = pdata->nports;\r\ngpio->ports = devm_kcalloc(&pdev->dev, gpio->nr_ports,\r\nsizeof(*gpio->ports), GFP_KERNEL);\r\nif (!gpio->ports)\r\nreturn -ENOMEM;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\ngpio->regs = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(gpio->regs))\r\nreturn PTR_ERR(gpio->regs);\r\nfor (i = 0; i < gpio->nr_ports; i++) {\r\nerr = dwapb_gpio_add_port(gpio, &pdata->properties[i], i);\r\nif (err)\r\ngoto out_unregister;\r\n}\r\nplatform_set_drvdata(pdev, gpio);\r\nreturn 0;\r\nout_unregister:\r\ndwapb_gpio_unregister(gpio);\r\ndwapb_irq_teardown(gpio);\r\nreturn err;\r\n}\r\nstatic int dwapb_gpio_remove(struct platform_device *pdev)\r\n{\r\nstruct dwapb_gpio *gpio = platform_get_drvdata(pdev);\r\ndwapb_gpio_unregister(gpio);\r\ndwapb_irq_teardown(gpio);\r\nreturn 0;\r\n}\r\nstatic int dwapb_gpio_suspend(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct dwapb_gpio *gpio = platform_get_drvdata(pdev);\r\nstruct bgpio_chip *bgc = &gpio->ports[0].bgc;\r\nunsigned long flags;\r\nint i;\r\nspin_lock_irqsave(&bgc->lock, flags);\r\nfor (i = 0; i < gpio->nr_ports; i++) {\r\nunsigned int offset;\r\nunsigned int idx = gpio->ports[i].idx;\r\nstruct dwapb_context *ctx = gpio->ports[i].ctx;\r\nBUG_ON(!ctx);\r\noffset = GPIO_SWPORTA_DDR + idx * GPIO_SWPORT_DDR_SIZE;\r\nctx->dir = dwapb_read(gpio, offset);\r\noffset = GPIO_SWPORTA_DR + idx * GPIO_SWPORT_DR_SIZE;\r\nctx->data = dwapb_read(gpio, offset);\r\noffset = GPIO_EXT_PORTA + idx * GPIO_EXT_PORT_SIZE;\r\nctx->ext = dwapb_read(gpio, offset);\r\nif (idx == 0) {\r\nctx->int_mask = dwapb_read(gpio, GPIO_INTMASK);\r\nctx->int_en = dwapb_read(gpio, GPIO_INTEN);\r\nctx->int_pol = dwapb_read(gpio, GPIO_INT_POLARITY);\r\nctx->int_type = dwapb_read(gpio, GPIO_INTTYPE_LEVEL);\r\nctx->int_deb = dwapb_read(gpio, GPIO_PORTA_DEBOUNCE);\r\ndwapb_write(gpio, GPIO_INTMASK, 0xffffffff);\r\n}\r\n}\r\nspin_unlock_irqrestore(&bgc->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int dwapb_gpio_resume(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct dwapb_gpio *gpio = platform_get_drvdata(pdev);\r\nstruct bgpio_chip *bgc = &gpio->ports[0].bgc;\r\nunsigned long flags;\r\nint i;\r\nspin_lock_irqsave(&bgc->lock, flags);\r\nfor (i = 0; i < gpio->nr_ports; i++) {\r\nunsigned int offset;\r\nunsigned int idx = gpio->ports[i].idx;\r\nstruct dwapb_context *ctx = gpio->ports[i].ctx;\r\nBUG_ON(!ctx);\r\noffset = GPIO_SWPORTA_DR + idx * GPIO_SWPORT_DR_SIZE;\r\ndwapb_write(gpio, offset, ctx->data);\r\noffset = GPIO_SWPORTA_DDR + idx * GPIO_SWPORT_DDR_SIZE;\r\ndwapb_write(gpio, offset, ctx->dir);\r\noffset = GPIO_EXT_PORTA + idx * GPIO_EXT_PORT_SIZE;\r\ndwapb_write(gpio, offset, ctx->ext);\r\nif (idx == 0) {\r\ndwapb_write(gpio, GPIO_INTTYPE_LEVEL, ctx->int_type);\r\ndwapb_write(gpio, GPIO_INT_POLARITY, ctx->int_pol);\r\ndwapb_write(gpio, GPIO_PORTA_DEBOUNCE, ctx->int_deb);\r\ndwapb_write(gpio, GPIO_INTEN, ctx->int_en);\r\ndwapb_write(gpio, GPIO_INTMASK, ctx->int_mask);\r\ndwapb_write(gpio, GPIO_PORTA_EOI, 0xffffffff);\r\n}\r\n}\r\nspin_unlock_irqrestore(&bgc->lock, flags);\r\nreturn 0;\r\n}
