void ocrdma_get_guid(struct ocrdma_dev *dev, u8 *guid)\r\n{\r\nu8 mac_addr[6];\r\nmemcpy(&mac_addr[0], &dev->nic_info.mac_addr[0], ETH_ALEN);\r\nguid[0] = mac_addr[0] ^ 2;\r\nguid[1] = mac_addr[1];\r\nguid[2] = mac_addr[2];\r\nguid[3] = 0xff;\r\nguid[4] = 0xfe;\r\nguid[5] = mac_addr[3];\r\nguid[6] = mac_addr[4];\r\nguid[7] = mac_addr[5];\r\n}\r\nstatic bool ocrdma_add_sgid(struct ocrdma_dev *dev, union ib_gid *new_sgid)\r\n{\r\nint i;\r\nunsigned long flags;\r\nmemset(&ocrdma_zero_sgid, 0, sizeof(union ib_gid));\r\nspin_lock_irqsave(&dev->sgid_lock, flags);\r\nfor (i = 0; i < OCRDMA_MAX_SGID; i++) {\r\nif (!memcmp(&dev->sgid_tbl[i], &ocrdma_zero_sgid,\r\nsizeof(union ib_gid))) {\r\nmemcpy(&dev->sgid_tbl[i], new_sgid,\r\nsizeof(union ib_gid));\r\nspin_unlock_irqrestore(&dev->sgid_lock, flags);\r\nreturn true;\r\n} else if (!memcmp(&dev->sgid_tbl[i], new_sgid,\r\nsizeof(union ib_gid))) {\r\nspin_unlock_irqrestore(&dev->sgid_lock, flags);\r\nreturn false;\r\n}\r\n}\r\nspin_unlock_irqrestore(&dev->sgid_lock, flags);\r\nreturn false;\r\n}\r\nstatic bool ocrdma_del_sgid(struct ocrdma_dev *dev, union ib_gid *sgid)\r\n{\r\nint found = false;\r\nint i;\r\nunsigned long flags;\r\nspin_lock_irqsave(&dev->sgid_lock, flags);\r\nfor (i = 1; i < OCRDMA_MAX_SGID; i++) {\r\nif (!memcmp(&dev->sgid_tbl[i], sgid, sizeof(union ib_gid))) {\r\nmemset(&dev->sgid_tbl[i], 0, sizeof(union ib_gid));\r\nfound = true;\r\nbreak;\r\n}\r\n}\r\nspin_unlock_irqrestore(&dev->sgid_lock, flags);\r\nreturn found;\r\n}\r\nstatic int ocrdma_addr_event(unsigned long event, struct net_device *netdev,\r\nunion ib_gid *gid)\r\n{\r\nstruct ib_event gid_event;\r\nstruct ocrdma_dev *dev;\r\nbool found = false;\r\nbool updated = false;\r\nbool is_vlan = false;\r\nis_vlan = netdev->priv_flags & IFF_802_1Q_VLAN;\r\nif (is_vlan)\r\nnetdev = rdma_vlan_dev_real_dev(netdev);\r\nrcu_read_lock();\r\nlist_for_each_entry_rcu(dev, &ocrdma_dev_list, entry) {\r\nif (dev->nic_info.netdev == netdev) {\r\nfound = true;\r\nbreak;\r\n}\r\n}\r\nrcu_read_unlock();\r\nif (!found)\r\nreturn NOTIFY_DONE;\r\nmutex_lock(&dev->dev_lock);\r\nswitch (event) {\r\ncase NETDEV_UP:\r\nupdated = ocrdma_add_sgid(dev, gid);\r\nbreak;\r\ncase NETDEV_DOWN:\r\nupdated = ocrdma_del_sgid(dev, gid);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif (updated) {\r\ngid_event.device = &dev->ibdev;\r\ngid_event.element.port_num = 1;\r\ngid_event.event = IB_EVENT_GID_CHANGE;\r\nib_dispatch_event(&gid_event);\r\n}\r\nmutex_unlock(&dev->dev_lock);\r\nreturn NOTIFY_OK;\r\n}\r\nstatic int ocrdma_inetaddr_event(struct notifier_block *notifier,\r\nunsigned long event, void *ptr)\r\n{\r\nstruct in_ifaddr *ifa = ptr;\r\nunion ib_gid gid;\r\nstruct net_device *netdev = ifa->ifa_dev->dev;\r\nipv6_addr_set_v4mapped(ifa->ifa_address, (struct in6_addr *)&gid);\r\nreturn ocrdma_addr_event(event, netdev, &gid);\r\n}\r\nstatic int ocrdma_inet6addr_event(struct notifier_block *notifier,\r\nunsigned long event, void *ptr)\r\n{\r\nstruct inet6_ifaddr *ifa = (struct inet6_ifaddr *)ptr;\r\nunion ib_gid *gid = (union ib_gid *)&ifa->addr;\r\nstruct net_device *netdev = ifa->idev->dev;\r\nreturn ocrdma_addr_event(event, netdev, gid);\r\n}\r\nstatic enum rdma_link_layer ocrdma_link_layer(struct ib_device *device,\r\nu8 port_num)\r\n{\r\nreturn IB_LINK_LAYER_ETHERNET;\r\n}\r\nstatic int ocrdma_register_device(struct ocrdma_dev *dev)\r\n{\r\nstrlcpy(dev->ibdev.name, "ocrdma%d", IB_DEVICE_NAME_MAX);\r\nocrdma_get_guid(dev, (u8 *)&dev->ibdev.node_guid);\r\nmemcpy(dev->ibdev.node_desc, OCRDMA_NODE_DESC,\r\nsizeof(OCRDMA_NODE_DESC));\r\ndev->ibdev.owner = THIS_MODULE;\r\ndev->ibdev.uverbs_abi_ver = OCRDMA_ABI_VERSION;\r\ndev->ibdev.uverbs_cmd_mask =\r\nOCRDMA_UVERBS(GET_CONTEXT) |\r\nOCRDMA_UVERBS(QUERY_DEVICE) |\r\nOCRDMA_UVERBS(QUERY_PORT) |\r\nOCRDMA_UVERBS(ALLOC_PD) |\r\nOCRDMA_UVERBS(DEALLOC_PD) |\r\nOCRDMA_UVERBS(REG_MR) |\r\nOCRDMA_UVERBS(DEREG_MR) |\r\nOCRDMA_UVERBS(CREATE_COMP_CHANNEL) |\r\nOCRDMA_UVERBS(CREATE_CQ) |\r\nOCRDMA_UVERBS(RESIZE_CQ) |\r\nOCRDMA_UVERBS(DESTROY_CQ) |\r\nOCRDMA_UVERBS(REQ_NOTIFY_CQ) |\r\nOCRDMA_UVERBS(CREATE_QP) |\r\nOCRDMA_UVERBS(MODIFY_QP) |\r\nOCRDMA_UVERBS(QUERY_QP) |\r\nOCRDMA_UVERBS(DESTROY_QP) |\r\nOCRDMA_UVERBS(POLL_CQ) |\r\nOCRDMA_UVERBS(POST_SEND) |\r\nOCRDMA_UVERBS(POST_RECV);\r\ndev->ibdev.uverbs_cmd_mask |=\r\nOCRDMA_UVERBS(CREATE_AH) |\r\nOCRDMA_UVERBS(MODIFY_AH) |\r\nOCRDMA_UVERBS(QUERY_AH) |\r\nOCRDMA_UVERBS(DESTROY_AH);\r\ndev->ibdev.node_type = RDMA_NODE_IB_CA;\r\ndev->ibdev.phys_port_cnt = 1;\r\ndev->ibdev.num_comp_vectors = dev->eq_cnt;\r\ndev->ibdev.query_device = ocrdma_query_device;\r\ndev->ibdev.query_port = ocrdma_query_port;\r\ndev->ibdev.modify_port = ocrdma_modify_port;\r\ndev->ibdev.query_gid = ocrdma_query_gid;\r\ndev->ibdev.get_link_layer = ocrdma_link_layer;\r\ndev->ibdev.alloc_pd = ocrdma_alloc_pd;\r\ndev->ibdev.dealloc_pd = ocrdma_dealloc_pd;\r\ndev->ibdev.create_cq = ocrdma_create_cq;\r\ndev->ibdev.destroy_cq = ocrdma_destroy_cq;\r\ndev->ibdev.resize_cq = ocrdma_resize_cq;\r\ndev->ibdev.create_qp = ocrdma_create_qp;\r\ndev->ibdev.modify_qp = ocrdma_modify_qp;\r\ndev->ibdev.query_qp = ocrdma_query_qp;\r\ndev->ibdev.destroy_qp = ocrdma_destroy_qp;\r\ndev->ibdev.query_pkey = ocrdma_query_pkey;\r\ndev->ibdev.create_ah = ocrdma_create_ah;\r\ndev->ibdev.destroy_ah = ocrdma_destroy_ah;\r\ndev->ibdev.query_ah = ocrdma_query_ah;\r\ndev->ibdev.modify_ah = ocrdma_modify_ah;\r\ndev->ibdev.poll_cq = ocrdma_poll_cq;\r\ndev->ibdev.post_send = ocrdma_post_send;\r\ndev->ibdev.post_recv = ocrdma_post_recv;\r\ndev->ibdev.req_notify_cq = ocrdma_arm_cq;\r\ndev->ibdev.get_dma_mr = ocrdma_get_dma_mr;\r\ndev->ibdev.reg_phys_mr = ocrdma_reg_kernel_mr;\r\ndev->ibdev.dereg_mr = ocrdma_dereg_mr;\r\ndev->ibdev.reg_user_mr = ocrdma_reg_user_mr;\r\ndev->ibdev.alloc_fast_reg_mr = ocrdma_alloc_frmr;\r\ndev->ibdev.alloc_fast_reg_page_list = ocrdma_alloc_frmr_page_list;\r\ndev->ibdev.free_fast_reg_page_list = ocrdma_free_frmr_page_list;\r\ndev->ibdev.alloc_ucontext = ocrdma_alloc_ucontext;\r\ndev->ibdev.dealloc_ucontext = ocrdma_dealloc_ucontext;\r\ndev->ibdev.mmap = ocrdma_mmap;\r\ndev->ibdev.dma_device = &dev->nic_info.pdev->dev;\r\ndev->ibdev.process_mad = ocrdma_process_mad;\r\nif (ocrdma_get_asic_type(dev) == OCRDMA_ASIC_GEN_SKH_R) {\r\ndev->ibdev.uverbs_cmd_mask |=\r\nOCRDMA_UVERBS(CREATE_SRQ) |\r\nOCRDMA_UVERBS(MODIFY_SRQ) |\r\nOCRDMA_UVERBS(QUERY_SRQ) |\r\nOCRDMA_UVERBS(DESTROY_SRQ) |\r\nOCRDMA_UVERBS(POST_SRQ_RECV);\r\ndev->ibdev.create_srq = ocrdma_create_srq;\r\ndev->ibdev.modify_srq = ocrdma_modify_srq;\r\ndev->ibdev.query_srq = ocrdma_query_srq;\r\ndev->ibdev.destroy_srq = ocrdma_destroy_srq;\r\ndev->ibdev.post_srq_recv = ocrdma_post_srq_recv;\r\n}\r\nreturn ib_register_device(&dev->ibdev, NULL);\r\n}\r\nstatic int ocrdma_alloc_resources(struct ocrdma_dev *dev)\r\n{\r\nmutex_init(&dev->dev_lock);\r\ndev->sgid_tbl = kzalloc(sizeof(union ib_gid) *\r\nOCRDMA_MAX_SGID, GFP_KERNEL);\r\nif (!dev->sgid_tbl)\r\ngoto alloc_err;\r\nspin_lock_init(&dev->sgid_lock);\r\ndev->cq_tbl = kzalloc(sizeof(struct ocrdma_cq *) *\r\nOCRDMA_MAX_CQ, GFP_KERNEL);\r\nif (!dev->cq_tbl)\r\ngoto alloc_err;\r\nif (dev->attr.max_qp) {\r\ndev->qp_tbl = kzalloc(sizeof(struct ocrdma_qp *) *\r\nOCRDMA_MAX_QP, GFP_KERNEL);\r\nif (!dev->qp_tbl)\r\ngoto alloc_err;\r\n}\r\ndev->stag_arr = kzalloc(sizeof(u64) * OCRDMA_MAX_STAG, GFP_KERNEL);\r\nif (dev->stag_arr == NULL)\r\ngoto alloc_err;\r\nocrdma_alloc_pd_pool(dev);\r\nspin_lock_init(&dev->av_tbl.lock);\r\nspin_lock_init(&dev->flush_q_lock);\r\nreturn 0;\r\nalloc_err:\r\npr_err("%s(%d) error.\n", __func__, dev->id);\r\nreturn -ENOMEM;\r\n}\r\nstatic void ocrdma_free_resources(struct ocrdma_dev *dev)\r\n{\r\nkfree(dev->stag_arr);\r\nkfree(dev->qp_tbl);\r\nkfree(dev->cq_tbl);\r\nkfree(dev->sgid_tbl);\r\n}\r\nstatic ssize_t show_rev(struct device *device, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct ocrdma_dev *dev = dev_get_drvdata(device);\r\nreturn scnprintf(buf, PAGE_SIZE, "0x%x\n", dev->nic_info.pdev->vendor);\r\n}\r\nstatic ssize_t show_fw_ver(struct device *device, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct ocrdma_dev *dev = dev_get_drvdata(device);\r\nreturn scnprintf(buf, PAGE_SIZE, "%s\n", &dev->attr.fw_ver[0]);\r\n}\r\nstatic ssize_t show_hca_type(struct device *device,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct ocrdma_dev *dev = dev_get_drvdata(device);\r\nreturn scnprintf(buf, PAGE_SIZE, "%s\n", &dev->model_number[0]);\r\n}\r\nstatic void ocrdma_remove_sysfiles(struct ocrdma_dev *dev)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(ocrdma_attributes); i++)\r\ndevice_remove_file(&dev->ibdev.dev, ocrdma_attributes[i]);\r\n}\r\nstatic void ocrdma_add_default_sgid(struct ocrdma_dev *dev)\r\n{\r\nunion ib_gid *sgid = &dev->sgid_tbl[0];\r\nsgid->global.subnet_prefix = cpu_to_be64(0xfe80000000000000LL);\r\nocrdma_get_guid(dev, &sgid->raw[8]);\r\n}\r\nstatic void ocrdma_init_ipv4_gids(struct ocrdma_dev *dev,\r\nstruct net_device *net)\r\n{\r\nstruct in_device *in_dev;\r\nunion ib_gid gid;\r\nin_dev = in_dev_get(net);\r\nif (in_dev) {\r\nfor_ifa(in_dev) {\r\nipv6_addr_set_v4mapped(ifa->ifa_address,\r\n(struct in6_addr *)&gid);\r\nocrdma_add_sgid(dev, &gid);\r\n}\r\nendfor_ifa(in_dev);\r\nin_dev_put(in_dev);\r\n}\r\n}\r\nstatic void ocrdma_init_ipv6_gids(struct ocrdma_dev *dev,\r\nstruct net_device *net)\r\n{\r\n#if IS_ENABLED(CONFIG_IPV6)\r\nstruct inet6_dev *in6_dev;\r\nunion ib_gid *pgid;\r\nstruct inet6_ifaddr *ifp;\r\nin6_dev = in6_dev_get(net);\r\nif (in6_dev) {\r\nread_lock_bh(&in6_dev->lock);\r\nlist_for_each_entry(ifp, &in6_dev->addr_list, if_list) {\r\npgid = (union ib_gid *)&ifp->addr;\r\nocrdma_add_sgid(dev, pgid);\r\n}\r\nread_unlock_bh(&in6_dev->lock);\r\nin6_dev_put(in6_dev);\r\n}\r\n#endif\r\n}\r\nstatic void ocrdma_init_gid_table(struct ocrdma_dev *dev)\r\n{\r\nstruct net_device *net_dev;\r\nfor_each_netdev(&init_net, net_dev) {\r\nstruct net_device *real_dev = rdma_vlan_dev_real_dev(net_dev) ?\r\nrdma_vlan_dev_real_dev(net_dev) : net_dev;\r\nif (real_dev == dev->nic_info.netdev) {\r\nocrdma_add_default_sgid(dev);\r\nocrdma_init_ipv4_gids(dev, net_dev);\r\nocrdma_init_ipv6_gids(dev, net_dev);\r\n}\r\n}\r\n}\r\nstatic struct ocrdma_dev *ocrdma_add(struct be_dev_info *dev_info)\r\n{\r\nint status = 0, i;\r\nstruct ocrdma_dev *dev;\r\ndev = (struct ocrdma_dev *)ib_alloc_device(sizeof(struct ocrdma_dev));\r\nif (!dev) {\r\npr_err("Unable to allocate ib device\n");\r\nreturn NULL;\r\n}\r\ndev->mbx_cmd = kzalloc(sizeof(struct ocrdma_mqe_emb_cmd), GFP_KERNEL);\r\nif (!dev->mbx_cmd)\r\ngoto idr_err;\r\nmemcpy(&dev->nic_info, dev_info, sizeof(*dev_info));\r\ndev->id = idr_alloc(&ocrdma_dev_id, NULL, 0, 0, GFP_KERNEL);\r\nif (dev->id < 0)\r\ngoto idr_err;\r\nstatus = ocrdma_init_hw(dev);\r\nif (status)\r\ngoto init_err;\r\nstatus = ocrdma_alloc_resources(dev);\r\nif (status)\r\ngoto alloc_err;\r\nocrdma_init_service_level(dev);\r\nocrdma_init_gid_table(dev);\r\nstatus = ocrdma_register_device(dev);\r\nif (status)\r\ngoto alloc_err;\r\nfor (i = 0; i < ARRAY_SIZE(ocrdma_attributes); i++)\r\nif (device_create_file(&dev->ibdev.dev, ocrdma_attributes[i]))\r\ngoto sysfs_err;\r\nspin_lock(&ocrdma_devlist_lock);\r\nlist_add_tail_rcu(&dev->entry, &ocrdma_dev_list);\r\nspin_unlock(&ocrdma_devlist_lock);\r\nocrdma_add_port_stats(dev);\r\nINIT_DELAYED_WORK(&dev->eqd_work, ocrdma_eqd_set_task);\r\nschedule_delayed_work(&dev->eqd_work, msecs_to_jiffies(1000));\r\npr_info("%s %s: %s \"%s\" port %d\n",\r\ndev_name(&dev->nic_info.pdev->dev), hca_name(dev),\r\nport_speed_string(dev), dev->model_number,\r\ndev->hba_port_num);\r\npr_info("%s ocrdma%d driver loaded successfully\n",\r\ndev_name(&dev->nic_info.pdev->dev), dev->id);\r\nreturn dev;\r\nsysfs_err:\r\nocrdma_remove_sysfiles(dev);\r\nalloc_err:\r\nocrdma_free_resources(dev);\r\nocrdma_cleanup_hw(dev);\r\ninit_err:\r\nidr_remove(&ocrdma_dev_id, dev->id);\r\nidr_err:\r\nkfree(dev->mbx_cmd);\r\nib_dealloc_device(&dev->ibdev);\r\npr_err("%s() leaving. ret=%d\n", __func__, status);\r\nreturn NULL;\r\n}\r\nstatic void ocrdma_remove_free(struct rcu_head *rcu)\r\n{\r\nstruct ocrdma_dev *dev = container_of(rcu, struct ocrdma_dev, rcu);\r\nidr_remove(&ocrdma_dev_id, dev->id);\r\nkfree(dev->mbx_cmd);\r\nib_dealloc_device(&dev->ibdev);\r\n}\r\nstatic void ocrdma_remove(struct ocrdma_dev *dev)\r\n{\r\ncancel_delayed_work_sync(&dev->eqd_work);\r\nocrdma_remove_sysfiles(dev);\r\nib_unregister_device(&dev->ibdev);\r\nocrdma_rem_port_stats(dev);\r\nspin_lock(&ocrdma_devlist_lock);\r\nlist_del_rcu(&dev->entry);\r\nspin_unlock(&ocrdma_devlist_lock);\r\nocrdma_free_resources(dev);\r\nocrdma_cleanup_hw(dev);\r\ncall_rcu(&dev->rcu, ocrdma_remove_free);\r\n}\r\nstatic int ocrdma_open(struct ocrdma_dev *dev)\r\n{\r\nstruct ib_event port_event;\r\nport_event.event = IB_EVENT_PORT_ACTIVE;\r\nport_event.element.port_num = 1;\r\nport_event.device = &dev->ibdev;\r\nib_dispatch_event(&port_event);\r\nreturn 0;\r\n}\r\nstatic int ocrdma_close(struct ocrdma_dev *dev)\r\n{\r\nint i;\r\nstruct ocrdma_qp *qp, **cur_qp;\r\nstruct ib_event err_event;\r\nstruct ib_qp_attr attrs;\r\nint attr_mask = IB_QP_STATE;\r\nattrs.qp_state = IB_QPS_ERR;\r\nmutex_lock(&dev->dev_lock);\r\nif (dev->qp_tbl) {\r\ncur_qp = dev->qp_tbl;\r\nfor (i = 0; i < OCRDMA_MAX_QP; i++) {\r\nqp = cur_qp[i];\r\nif (qp && qp->ibqp.qp_type != IB_QPT_GSI) {\r\n_ocrdma_modify_qp(&qp->ibqp, &attrs, attr_mask);\r\nerr_event.event = IB_EVENT_QP_FATAL;\r\nerr_event.element.qp = &qp->ibqp;\r\nerr_event.device = &dev->ibdev;\r\nib_dispatch_event(&err_event);\r\n}\r\n}\r\n}\r\nmutex_unlock(&dev->dev_lock);\r\nerr_event.event = IB_EVENT_PORT_ERR;\r\nerr_event.element.port_num = 1;\r\nerr_event.device = &dev->ibdev;\r\nib_dispatch_event(&err_event);\r\nreturn 0;\r\n}\r\nstatic void ocrdma_shutdown(struct ocrdma_dev *dev)\r\n{\r\nocrdma_close(dev);\r\nocrdma_remove(dev);\r\n}\r\nstatic void ocrdma_event_handler(struct ocrdma_dev *dev, u32 event)\r\n{\r\nswitch (event) {\r\ncase BE_DEV_UP:\r\nocrdma_open(dev);\r\nbreak;\r\ncase BE_DEV_DOWN:\r\nocrdma_close(dev);\r\nbreak;\r\ncase BE_DEV_SHUTDOWN:\r\nocrdma_shutdown(dev);\r\nbreak;\r\n}\r\n}\r\nstatic void ocrdma_unregister_inet6addr_notifier(void)\r\n{\r\n#if IS_ENABLED(CONFIG_IPV6)\r\nunregister_inet6addr_notifier(&ocrdma_inet6addr_notifier);\r\n#endif\r\n}\r\nstatic void ocrdma_unregister_inetaddr_notifier(void)\r\n{\r\nunregister_inetaddr_notifier(&ocrdma_inetaddr_notifier);\r\n}\r\nstatic int __init ocrdma_init_module(void)\r\n{\r\nint status;\r\nocrdma_init_debugfs();\r\nstatus = register_inetaddr_notifier(&ocrdma_inetaddr_notifier);\r\nif (status)\r\nreturn status;\r\n#if IS_ENABLED(CONFIG_IPV6)\r\nstatus = register_inet6addr_notifier(&ocrdma_inet6addr_notifier);\r\nif (status)\r\ngoto err_notifier6;\r\n#endif\r\nstatus = be_roce_register_driver(&ocrdma_drv);\r\nif (status)\r\ngoto err_be_reg;\r\nreturn 0;\r\nerr_be_reg:\r\n#if IS_ENABLED(CONFIG_IPV6)\r\nocrdma_unregister_inet6addr_notifier();\r\nerr_notifier6:\r\n#endif\r\nocrdma_unregister_inetaddr_notifier();\r\nreturn status;\r\n}\r\nstatic void __exit ocrdma_exit_module(void)\r\n{\r\nbe_roce_unregister_driver(&ocrdma_drv);\r\nocrdma_unregister_inet6addr_notifier();\r\nocrdma_unregister_inetaddr_notifier();\r\nocrdma_rem_debugfs();\r\n}
