static int lgdt3305_write_reg(struct lgdt3305_state *state, u16 reg, u8 val)\r\n{\r\nint ret;\r\nu8 buf[] = { reg >> 8, reg & 0xff, val };\r\nstruct i2c_msg msg = {\r\n.addr = state->cfg->i2c_addr, .flags = 0,\r\n.buf = buf, .len = 3,\r\n};\r\nlg_reg("reg: 0x%04x, val: 0x%02x\n", reg, val);\r\nret = i2c_transfer(state->i2c_adap, &msg, 1);\r\nif (ret != 1) {\r\nlg_err("error (addr %02x %02x <- %02x, err = %i)\n",\r\nmsg.buf[0], msg.buf[1], msg.buf[2], ret);\r\nif (ret < 0)\r\nreturn ret;\r\nelse\r\nreturn -EREMOTEIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic int lgdt3305_read_reg(struct lgdt3305_state *state, u16 reg, u8 *val)\r\n{\r\nint ret;\r\nu8 reg_buf[] = { reg >> 8, reg & 0xff };\r\nstruct i2c_msg msg[] = {\r\n{ .addr = state->cfg->i2c_addr,\r\n.flags = 0, .buf = reg_buf, .len = 2 },\r\n{ .addr = state->cfg->i2c_addr,\r\n.flags = I2C_M_RD, .buf = val, .len = 1 },\r\n};\r\nlg_reg("reg: 0x%04x\n", reg);\r\nret = i2c_transfer(state->i2c_adap, msg, 2);\r\nif (ret != 2) {\r\nlg_err("error (addr %02x reg %04x error (ret == %i)\n",\r\nstate->cfg->i2c_addr, reg, ret);\r\nif (ret < 0)\r\nreturn ret;\r\nelse\r\nreturn -EREMOTEIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic int lgdt3305_set_reg_bit(struct lgdt3305_state *state,\r\nu16 reg, int bit, int onoff)\r\n{\r\nu8 val;\r\nint ret;\r\nlg_reg("reg: 0x%04x, bit: %d, level: %d\n", reg, bit, onoff);\r\nret = lgdt3305_read_reg(state, reg, &val);\r\nif (lg_fail(ret))\r\ngoto fail;\r\nval &= ~(1 << bit);\r\nval |= (onoff & 1) << bit;\r\nret = lgdt3305_write_reg(state, reg, val);\r\nfail:\r\nreturn ret;\r\n}\r\nstatic int lgdt3305_write_regs(struct lgdt3305_state *state,\r\nstruct lgdt3305_reg *regs, int len)\r\n{\r\nint i, ret;\r\nlg_reg("writing %d registers...\n", len);\r\nfor (i = 0; i < len - 1; i++) {\r\nret = lgdt3305_write_reg(state, regs[i].reg, regs[i].val);\r\nif (lg_fail(ret))\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int lgdt3305_soft_reset(struct lgdt3305_state *state)\r\n{\r\nint ret;\r\nlg_dbg("\n");\r\nret = lgdt3305_set_reg_bit(state, LGDT3305_GEN_CTRL_3, 0, 0);\r\nif (lg_fail(ret))\r\ngoto fail;\r\nmsleep(20);\r\nret = lgdt3305_set_reg_bit(state, LGDT3305_GEN_CTRL_3, 0, 1);\r\nfail:\r\nreturn ret;\r\n}\r\nstatic inline int lgdt3305_mpeg_mode(struct lgdt3305_state *state,\r\nenum lgdt3305_mpeg_mode mode)\r\n{\r\nlg_dbg("(%d)\n", mode);\r\nreturn lgdt3305_set_reg_bit(state, LGDT3305_TP_CTRL_1, 5, mode);\r\n}\r\nstatic int lgdt3305_mpeg_mode_polarity(struct lgdt3305_state *state)\r\n{\r\nu8 val;\r\nint ret;\r\nenum lgdt3305_tp_clock_edge edge = state->cfg->tpclk_edge;\r\nenum lgdt3305_tp_clock_mode mode = state->cfg->tpclk_mode;\r\nenum lgdt3305_tp_valid_polarity valid = state->cfg->tpvalid_polarity;\r\nlg_dbg("edge = %d, valid = %d\n", edge, valid);\r\nret = lgdt3305_read_reg(state, LGDT3305_TP_CTRL_1, &val);\r\nif (lg_fail(ret))\r\ngoto fail;\r\nval &= ~0x09;\r\nif (edge)\r\nval |= 0x08;\r\nif (mode)\r\nval |= 0x40;\r\nif (valid)\r\nval |= 0x01;\r\nret = lgdt3305_write_reg(state, LGDT3305_TP_CTRL_1, val);\r\nif (lg_fail(ret))\r\ngoto fail;\r\nret = lgdt3305_soft_reset(state);\r\nfail:\r\nreturn ret;\r\n}\r\nstatic int lgdt3305_set_modulation(struct lgdt3305_state *state,\r\nstruct dtv_frontend_properties *p)\r\n{\r\nu8 opermode;\r\nint ret;\r\nlg_dbg("\n");\r\nret = lgdt3305_read_reg(state, LGDT3305_GEN_CTRL_1, &opermode);\r\nif (lg_fail(ret))\r\ngoto fail;\r\nopermode &= ~0x03;\r\nswitch (p->modulation) {\r\ncase VSB_8:\r\nopermode |= 0x03;\r\nbreak;\r\ncase QAM_64:\r\nopermode |= 0x00;\r\nbreak;\r\ncase QAM_256:\r\nopermode |= 0x01;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nret = lgdt3305_write_reg(state, LGDT3305_GEN_CTRL_1, opermode);\r\nfail:\r\nreturn ret;\r\n}\r\nstatic int lgdt3305_set_filter_extension(struct lgdt3305_state *state,\r\nstruct dtv_frontend_properties *p)\r\n{\r\nint val;\r\nswitch (p->modulation) {\r\ncase VSB_8:\r\nval = 0;\r\nbreak;\r\ncase QAM_64:\r\ncase QAM_256:\r\nval = 1;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nlg_dbg("val = %d\n", val);\r\nreturn lgdt3305_set_reg_bit(state, 0x043f, 2, val);\r\n}\r\nstatic int lgdt3305_passband_digital_agc(struct lgdt3305_state *state,\r\nstruct dtv_frontend_properties *p)\r\n{\r\nu16 agc_ref;\r\nswitch (p->modulation) {\r\ncase VSB_8:\r\nagc_ref = 0x32c4;\r\nbreak;\r\ncase QAM_64:\r\nagc_ref = 0x2a00;\r\nbreak;\r\ncase QAM_256:\r\nagc_ref = 0x2a80;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nlg_dbg("agc ref: 0x%04x\n", agc_ref);\r\nlgdt3305_write_reg(state, LGDT3305_DGTL_AGC_REF_1, agc_ref >> 8);\r\nlgdt3305_write_reg(state, LGDT3305_DGTL_AGC_REF_2, agc_ref & 0xff);\r\nreturn 0;\r\n}\r\nstatic int lgdt3305_rfagc_loop(struct lgdt3305_state *state,\r\nstruct dtv_frontend_properties *p)\r\n{\r\nu16 ifbw, rfbw, agcdelay;\r\nswitch (p->modulation) {\r\ncase VSB_8:\r\nagcdelay = 0x04c0;\r\nrfbw = 0x8000;\r\nifbw = 0x8000;\r\nbreak;\r\ncase QAM_64:\r\ncase QAM_256:\r\nagcdelay = 0x046b;\r\nrfbw = 0x8889;\r\nif (state->cfg->demod_chip == LGDT3304)\r\nifbw = 0x6666;\r\nelse\r\nifbw = 0x8888;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (state->cfg->rf_agc_loop) {\r\nlg_dbg("agcdelay: 0x%04x, rfbw: 0x%04x\n", agcdelay, rfbw);\r\nlgdt3305_write_reg(state, LGDT3305_AGC_DELAY_PT_1,\r\nagcdelay >> 8);\r\nlgdt3305_write_reg(state, LGDT3305_AGC_DELAY_PT_2,\r\nagcdelay & 0xff);\r\nlgdt3305_write_reg(state, LGDT3305_RFAGC_LOOP_FLTR_BW_1,\r\nrfbw >> 8);\r\nlgdt3305_write_reg(state, LGDT3305_RFAGC_LOOP_FLTR_BW_2,\r\nrfbw & 0xff);\r\n} else {\r\nlg_dbg("ifbw: 0x%04x\n", ifbw);\r\nlgdt3305_write_reg(state, LGDT3305_IFBW_1, ifbw >> 8);\r\nlgdt3305_write_reg(state, LGDT3305_IFBW_2, ifbw & 0xff);\r\n}\r\nreturn 0;\r\n}\r\nstatic int lgdt3305_agc_setup(struct lgdt3305_state *state,\r\nstruct dtv_frontend_properties *p)\r\n{\r\nint lockdten, acqen;\r\nswitch (p->modulation) {\r\ncase VSB_8:\r\nlockdten = 0;\r\nacqen = 0;\r\nbreak;\r\ncase QAM_64:\r\ncase QAM_256:\r\nlockdten = 1;\r\nacqen = 1;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nlg_dbg("lockdten = %d, acqen = %d\n", lockdten, acqen);\r\nswitch (state->cfg->demod_chip) {\r\ncase LGDT3304:\r\nlgdt3305_write_reg(state, 0x0314, 0xe1 | lockdten << 1);\r\nlgdt3305_set_reg_bit(state, 0x030e, 2, acqen);\r\nbreak;\r\ncase LGDT3305:\r\nlgdt3305_write_reg(state, LGDT3305_AGC_CTRL_4, 0xe1 | lockdten << 1);\r\nlgdt3305_set_reg_bit(state, LGDT3305_AGC_CTRL_1, 2, acqen);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn lgdt3305_rfagc_loop(state, p);\r\n}\r\nstatic int lgdt3305_set_agc_power_ref(struct lgdt3305_state *state,\r\nstruct dtv_frontend_properties *p)\r\n{\r\nu16 usref = 0;\r\nswitch (p->modulation) {\r\ncase VSB_8:\r\nif (state->cfg->usref_8vsb)\r\nusref = state->cfg->usref_8vsb;\r\nbreak;\r\ncase QAM_64:\r\nif (state->cfg->usref_qam64)\r\nusref = state->cfg->usref_qam64;\r\nbreak;\r\ncase QAM_256:\r\nif (state->cfg->usref_qam256)\r\nusref = state->cfg->usref_qam256;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (usref) {\r\nlg_dbg("set manual mode: 0x%04x\n", usref);\r\nlgdt3305_set_reg_bit(state, LGDT3305_AGC_CTRL_1, 3, 1);\r\nlgdt3305_write_reg(state, LGDT3305_AGC_POWER_REF_1,\r\n0xff & (usref >> 8));\r\nlgdt3305_write_reg(state, LGDT3305_AGC_POWER_REF_2,\r\n0xff & (usref >> 0));\r\n}\r\nreturn 0;\r\n}\r\nstatic int lgdt3305_spectral_inversion(struct lgdt3305_state *state,\r\nstruct dtv_frontend_properties *p,\r\nint inversion)\r\n{\r\nint ret;\r\nlg_dbg("(%d)\n", inversion);\r\nswitch (p->modulation) {\r\ncase VSB_8:\r\nret = lgdt3305_write_reg(state, LGDT3305_CR_CTRL_7,\r\ninversion ? 0xf9 : 0x79);\r\nbreak;\r\ncase QAM_64:\r\ncase QAM_256:\r\nret = lgdt3305_write_reg(state, LGDT3305_FEC_BLOCK_CTRL,\r\ninversion ? 0xfd : 0xff);\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\n}\r\nreturn ret;\r\n}\r\nstatic int lgdt3305_set_if(struct lgdt3305_state *state,\r\nstruct dtv_frontend_properties *p)\r\n{\r\nu16 if_freq_khz;\r\nu8 nco1, nco2, nco3, nco4;\r\nu64 nco;\r\nswitch (p->modulation) {\r\ncase VSB_8:\r\nif_freq_khz = state->cfg->vsb_if_khz;\r\nbreak;\r\ncase QAM_64:\r\ncase QAM_256:\r\nif_freq_khz = state->cfg->qam_if_khz;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nnco = if_freq_khz / 10;\r\nswitch (p->modulation) {\r\ncase VSB_8:\r\nnco <<= 24;\r\ndo_div(nco, 625);\r\nbreak;\r\ncase QAM_64:\r\ncase QAM_256:\r\nnco <<= 28;\r\ndo_div(nco, 625);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nnco1 = (nco >> 24) & 0x3f;\r\nnco1 |= 0x40;\r\nnco2 = (nco >> 16) & 0xff;\r\nnco3 = (nco >> 8) & 0xff;\r\nnco4 = nco & 0xff;\r\nlgdt3305_write_reg(state, LGDT3305_CR_CTR_FREQ_1, nco1);\r\nlgdt3305_write_reg(state, LGDT3305_CR_CTR_FREQ_2, nco2);\r\nlgdt3305_write_reg(state, LGDT3305_CR_CTR_FREQ_3, nco3);\r\nlgdt3305_write_reg(state, LGDT3305_CR_CTR_FREQ_4, nco4);\r\nlg_dbg("%d KHz -> [%02x%02x%02x%02x]\n",\r\nif_freq_khz, nco1, nco2, nco3, nco4);\r\nreturn 0;\r\n}\r\nstatic int lgdt3305_i2c_gate_ctrl(struct dvb_frontend *fe, int enable)\r\n{\r\nstruct lgdt3305_state *state = fe->demodulator_priv;\r\nif (state->cfg->deny_i2c_rptr)\r\nreturn 0;\r\nlg_dbg("(%d)\n", enable);\r\nreturn lgdt3305_set_reg_bit(state, LGDT3305_GEN_CTRL_2, 5,\r\nenable ? 0 : 1);\r\n}\r\nstatic int lgdt3305_sleep(struct dvb_frontend *fe)\r\n{\r\nstruct lgdt3305_state *state = fe->demodulator_priv;\r\nu8 gen_ctrl_3, gen_ctrl_4;\r\nlg_dbg("\n");\r\ngen_ctrl_3 = read_reg(state, LGDT3305_GEN_CTRL_3);\r\ngen_ctrl_4 = read_reg(state, LGDT3305_GEN_CTRL_4);\r\ngen_ctrl_3 &= ~0x01;\r\ngen_ctrl_3 |= 0x02;\r\ngen_ctrl_3 |= 0x04;\r\ngen_ctrl_4 &= ~0x01;\r\ngen_ctrl_4 &= ~0x02;\r\nlgdt3305_write_reg(state, LGDT3305_GEN_CTRL_3, gen_ctrl_3);\r\nlgdt3305_write_reg(state, LGDT3305_GEN_CTRL_4, gen_ctrl_4);\r\nreturn 0;\r\n}\r\nstatic int lgdt3305_init(struct dvb_frontend *fe)\r\n{\r\nstruct lgdt3305_state *state = fe->demodulator_priv;\r\nint ret;\r\nstatic struct lgdt3305_reg lgdt3304_init_data[] = {\r\n{ .reg = LGDT3305_GEN_CTRL_1, .val = 0x03, },\r\n{ .reg = 0x000d, .val = 0x02, },\r\n{ .reg = 0x000e, .val = 0x02, },\r\n{ .reg = LGDT3305_DGTL_AGC_REF_1, .val = 0x32, },\r\n{ .reg = LGDT3305_DGTL_AGC_REF_2, .val = 0xc4, },\r\n{ .reg = LGDT3305_CR_CTR_FREQ_1, .val = 0x00, },\r\n{ .reg = LGDT3305_CR_CTR_FREQ_2, .val = 0x00, },\r\n{ .reg = LGDT3305_CR_CTR_FREQ_3, .val = 0x00, },\r\n{ .reg = LGDT3305_CR_CTR_FREQ_4, .val = 0x00, },\r\n{ .reg = LGDT3305_CR_CTRL_7, .val = 0xf9, },\r\n{ .reg = 0x0112, .val = 0x17, },\r\n{ .reg = 0x0113, .val = 0x15, },\r\n{ .reg = 0x0114, .val = 0x18, },\r\n{ .reg = 0x0115, .val = 0xff, },\r\n{ .reg = 0x0116, .val = 0x3c, },\r\n{ .reg = 0x0214, .val = 0x67, },\r\n{ .reg = 0x0424, .val = 0x8d, },\r\n{ .reg = 0x0427, .val = 0x12, },\r\n{ .reg = 0x0428, .val = 0x4f, },\r\n{ .reg = LGDT3305_IFBW_1, .val = 0x80, },\r\n{ .reg = LGDT3305_IFBW_2, .val = 0x00, },\r\n{ .reg = 0x030a, .val = 0x08, },\r\n{ .reg = 0x030b, .val = 0x9b, },\r\n{ .reg = 0x030d, .val = 0x00, },\r\n{ .reg = 0x030e, .val = 0x1c, },\r\n{ .reg = 0x0314, .val = 0xe1, },\r\n{ .reg = 0x000d, .val = 0x82, },\r\n{ .reg = LGDT3305_TP_CTRL_1, .val = 0x5b, },\r\n{ .reg = LGDT3305_TP_CTRL_1, .val = 0x5b, },\r\n};\r\nstatic struct lgdt3305_reg lgdt3305_init_data[] = {\r\n{ .reg = LGDT3305_GEN_CTRL_1, .val = 0x03, },\r\n{ .reg = LGDT3305_GEN_CTRL_2, .val = 0xb0, },\r\n{ .reg = LGDT3305_GEN_CTRL_3, .val = 0x01, },\r\n{ .reg = LGDT3305_GEN_CONTROL, .val = 0x6f, },\r\n{ .reg = LGDT3305_GEN_CTRL_4, .val = 0x03, },\r\n{ .reg = LGDT3305_DGTL_AGC_REF_1, .val = 0x32, },\r\n{ .reg = LGDT3305_DGTL_AGC_REF_2, .val = 0xc4, },\r\n{ .reg = LGDT3305_CR_CTR_FREQ_1, .val = 0x00, },\r\n{ .reg = LGDT3305_CR_CTR_FREQ_2, .val = 0x00, },\r\n{ .reg = LGDT3305_CR_CTR_FREQ_3, .val = 0x00, },\r\n{ .reg = LGDT3305_CR_CTR_FREQ_4, .val = 0x00, },\r\n{ .reg = LGDT3305_CR_CTRL_7, .val = 0x79, },\r\n{ .reg = LGDT3305_AGC_POWER_REF_1, .val = 0x32, },\r\n{ .reg = LGDT3305_AGC_POWER_REF_2, .val = 0xc4, },\r\n{ .reg = LGDT3305_AGC_DELAY_PT_1, .val = 0x0d, },\r\n{ .reg = LGDT3305_AGC_DELAY_PT_2, .val = 0x30, },\r\n{ .reg = LGDT3305_RFAGC_LOOP_FLTR_BW_1, .val = 0x80, },\r\n{ .reg = LGDT3305_RFAGC_LOOP_FLTR_BW_2, .val = 0x00, },\r\n{ .reg = LGDT3305_IFBW_1, .val = 0x80, },\r\n{ .reg = LGDT3305_IFBW_2, .val = 0x00, },\r\n{ .reg = LGDT3305_AGC_CTRL_1, .val = 0x30, },\r\n{ .reg = LGDT3305_AGC_CTRL_4, .val = 0x61, },\r\n{ .reg = LGDT3305_FEC_BLOCK_CTRL, .val = 0xff, },\r\n{ .reg = LGDT3305_TP_CTRL_1, .val = 0x1b, },\r\n};\r\nlg_dbg("\n");\r\nswitch (state->cfg->demod_chip) {\r\ncase LGDT3304:\r\nret = lgdt3305_write_regs(state, lgdt3304_init_data,\r\nARRAY_SIZE(lgdt3304_init_data));\r\nbreak;\r\ncase LGDT3305:\r\nret = lgdt3305_write_regs(state, lgdt3305_init_data,\r\nARRAY_SIZE(lgdt3305_init_data));\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\n}\r\nif (lg_fail(ret))\r\ngoto fail;\r\nret = lgdt3305_soft_reset(state);\r\nfail:\r\nreturn ret;\r\n}\r\nstatic int lgdt3304_set_parameters(struct dvb_frontend *fe)\r\n{\r\nstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\r\nstruct lgdt3305_state *state = fe->demodulator_priv;\r\nint ret;\r\nlg_dbg("(%d, %d)\n", p->frequency, p->modulation);\r\nif (fe->ops.tuner_ops.set_params) {\r\nret = fe->ops.tuner_ops.set_params(fe);\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 0);\r\nif (lg_fail(ret))\r\ngoto fail;\r\nstate->current_frequency = p->frequency;\r\n}\r\nret = lgdt3305_set_modulation(state, p);\r\nif (lg_fail(ret))\r\ngoto fail;\r\nret = lgdt3305_passband_digital_agc(state, p);\r\nif (lg_fail(ret))\r\ngoto fail;\r\nret = lgdt3305_agc_setup(state, p);\r\nif (lg_fail(ret))\r\ngoto fail;\r\nswitch (p->modulation) {\r\ncase VSB_8:\r\nlgdt3305_write_reg(state, 0x030d, 0x00);\r\nlgdt3305_write_reg(state, LGDT3305_CR_CTR_FREQ_1, 0x4f);\r\nlgdt3305_write_reg(state, LGDT3305_CR_CTR_FREQ_2, 0x0c);\r\nlgdt3305_write_reg(state, LGDT3305_CR_CTR_FREQ_3, 0xac);\r\nlgdt3305_write_reg(state, LGDT3305_CR_CTR_FREQ_4, 0xba);\r\nbreak;\r\ncase QAM_64:\r\ncase QAM_256:\r\nlgdt3305_write_reg(state, 0x030d, 0x14);\r\nret = lgdt3305_set_if(state, p);\r\nif (lg_fail(ret))\r\ngoto fail;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nret = lgdt3305_spectral_inversion(state, p,\r\nstate->cfg->spectral_inversion\r\n? 1 : 0);\r\nif (lg_fail(ret))\r\ngoto fail;\r\nstate->current_modulation = p->modulation;\r\nret = lgdt3305_mpeg_mode(state, state->cfg->mpeg_mode);\r\nif (lg_fail(ret))\r\ngoto fail;\r\nret = lgdt3305_mpeg_mode_polarity(state);\r\nfail:\r\nreturn ret;\r\n}\r\nstatic int lgdt3305_set_parameters(struct dvb_frontend *fe)\r\n{\r\nstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\r\nstruct lgdt3305_state *state = fe->demodulator_priv;\r\nint ret;\r\nlg_dbg("(%d, %d)\n", p->frequency, p->modulation);\r\nif (fe->ops.tuner_ops.set_params) {\r\nret = fe->ops.tuner_ops.set_params(fe);\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 0);\r\nif (lg_fail(ret))\r\ngoto fail;\r\nstate->current_frequency = p->frequency;\r\n}\r\nret = lgdt3305_set_modulation(state, p);\r\nif (lg_fail(ret))\r\ngoto fail;\r\nret = lgdt3305_passband_digital_agc(state, p);\r\nif (lg_fail(ret))\r\ngoto fail;\r\nret = lgdt3305_set_agc_power_ref(state, p);\r\nif (lg_fail(ret))\r\ngoto fail;\r\nret = lgdt3305_agc_setup(state, p);\r\nif (lg_fail(ret))\r\ngoto fail;\r\nret = lgdt3305_write_reg(state, LGDT3305_GEN_CONTROL, 0x2f);\r\nif (lg_fail(ret))\r\ngoto fail;\r\nret = lgdt3305_set_reg_bit(state, LGDT3305_CR_CTR_FREQ_1, 6, 1);\r\nif (lg_fail(ret))\r\ngoto fail;\r\nret = lgdt3305_set_if(state, p);\r\nif (lg_fail(ret))\r\ngoto fail;\r\nret = lgdt3305_spectral_inversion(state, p,\r\nstate->cfg->spectral_inversion\r\n? 1 : 0);\r\nif (lg_fail(ret))\r\ngoto fail;\r\nret = lgdt3305_set_filter_extension(state, p);\r\nif (lg_fail(ret))\r\ngoto fail;\r\nstate->current_modulation = p->modulation;\r\nret = lgdt3305_mpeg_mode(state, state->cfg->mpeg_mode);\r\nif (lg_fail(ret))\r\ngoto fail;\r\nret = lgdt3305_mpeg_mode_polarity(state);\r\nfail:\r\nreturn ret;\r\n}\r\nstatic int lgdt3305_get_frontend(struct dvb_frontend *fe)\r\n{\r\nstruct dtv_frontend_properties *p = &fe->dtv_property_cache;\r\nstruct lgdt3305_state *state = fe->demodulator_priv;\r\nlg_dbg("\n");\r\np->modulation = state->current_modulation;\r\np->frequency = state->current_frequency;\r\nreturn 0;\r\n}\r\nstatic int lgdt3305_read_cr_lock_status(struct lgdt3305_state *state,\r\nint *locked)\r\n{\r\nu8 val;\r\nint ret;\r\nchar *cr_lock_state = "";\r\n*locked = 0;\r\nret = lgdt3305_read_reg(state, LGDT3305_CR_LOCK_STATUS, &val);\r\nif (lg_fail(ret))\r\ngoto fail;\r\nswitch (state->current_modulation) {\r\ncase QAM_256:\r\ncase QAM_64:\r\nif (val & (1 << 1))\r\n*locked = 1;\r\nswitch (val & 0x07) {\r\ncase 0:\r\ncr_lock_state = "QAM UNLOCK";\r\nbreak;\r\ncase 4:\r\ncr_lock_state = "QAM 1stLock";\r\nbreak;\r\ncase 6:\r\ncr_lock_state = "QAM 2ndLock";\r\nbreak;\r\ncase 7:\r\ncr_lock_state = "QAM FinalLock";\r\nbreak;\r\ndefault:\r\ncr_lock_state = "CLOCKQAM-INVALID!";\r\nbreak;\r\n}\r\nbreak;\r\ncase VSB_8:\r\nif (val & (1 << 7)) {\r\n*locked = 1;\r\ncr_lock_state = "CLOCKVSB";\r\n}\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\n}\r\nlg_dbg("(%d) %s\n", *locked, cr_lock_state);\r\nfail:\r\nreturn ret;\r\n}\r\nstatic int lgdt3305_read_fec_lock_status(struct lgdt3305_state *state,\r\nint *locked)\r\n{\r\nu8 val;\r\nint ret, mpeg_lock, fec_lock, viterbi_lock;\r\n*locked = 0;\r\nswitch (state->current_modulation) {\r\ncase QAM_256:\r\ncase QAM_64:\r\nret = lgdt3305_read_reg(state,\r\nLGDT3305_FEC_LOCK_STATUS, &val);\r\nif (lg_fail(ret))\r\ngoto fail;\r\nmpeg_lock = (val & (1 << 0)) ? 1 : 0;\r\nfec_lock = (val & (1 << 2)) ? 1 : 0;\r\nviterbi_lock = (val & (1 << 3)) ? 1 : 0;\r\n*locked = mpeg_lock && fec_lock && viterbi_lock;\r\nlg_dbg("(%d) %s%s%s\n", *locked,\r\nmpeg_lock ? "mpeg lock " : "",\r\nfec_lock ? "fec lock " : "",\r\nviterbi_lock ? "viterbi lock" : "");\r\nbreak;\r\ncase VSB_8:\r\ndefault:\r\nret = -EINVAL;\r\n}\r\nfail:\r\nreturn ret;\r\n}\r\nstatic int lgdt3305_read_status(struct dvb_frontend *fe, fe_status_t *status)\r\n{\r\nstruct lgdt3305_state *state = fe->demodulator_priv;\r\nu8 val;\r\nint ret, signal, inlock, nofecerr, snrgood,\r\ncr_lock, fec_lock, sync_lock;\r\n*status = 0;\r\nret = lgdt3305_read_reg(state, LGDT3305_GEN_STATUS, &val);\r\nif (lg_fail(ret))\r\ngoto fail;\r\nsignal = (val & (1 << 4)) ? 1 : 0;\r\ninlock = (val & (1 << 3)) ? 0 : 1;\r\nsync_lock = (val & (1 << 2)) ? 1 : 0;\r\nnofecerr = (val & (1 << 1)) ? 1 : 0;\r\nsnrgood = (val & (1 << 0)) ? 1 : 0;\r\nlg_dbg("%s%s%s%s%s\n",\r\nsignal ? "SIGNALEXIST " : "",\r\ninlock ? "INLOCK " : "",\r\nsync_lock ? "SYNCLOCK " : "",\r\nnofecerr ? "NOFECERR " : "",\r\nsnrgood ? "SNRGOOD " : "");\r\nret = lgdt3305_read_cr_lock_status(state, &cr_lock);\r\nif (lg_fail(ret))\r\ngoto fail;\r\nif (signal)\r\n*status |= FE_HAS_SIGNAL;\r\nif (cr_lock)\r\n*status |= FE_HAS_CARRIER;\r\nif (nofecerr)\r\n*status |= FE_HAS_VITERBI;\r\nif (sync_lock)\r\n*status |= FE_HAS_SYNC;\r\nswitch (state->current_modulation) {\r\ncase QAM_256:\r\ncase QAM_64:\r\nif (((LGDT3304 == state->cfg->demod_chip)) && (cr_lock))\r\n*status |= FE_HAS_SIGNAL;\r\nret = lgdt3305_read_fec_lock_status(state, &fec_lock);\r\nif (lg_fail(ret))\r\ngoto fail;\r\nif (fec_lock)\r\n*status |= FE_HAS_LOCK;\r\nbreak;\r\ncase VSB_8:\r\nif (inlock)\r\n*status |= FE_HAS_LOCK;\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\n}\r\nfail:\r\nreturn ret;\r\n}\r\nstatic u32 calculate_snr(u32 mse, u32 c)\r\n{\r\nif (mse == 0)\r\nreturn 0;\r\nmse = intlog10(mse);\r\nif (mse > c) {\r\nreturn 0;\r\n}\r\nreturn 10*(c - mse);\r\n}\r\nstatic int lgdt3305_read_snr(struct dvb_frontend *fe, u16 *snr)\r\n{\r\nstruct lgdt3305_state *state = fe->demodulator_priv;\r\nu32 noise;\r\nu32 c;\r\nswitch (state->current_modulation) {\r\ncase VSB_8:\r\n#ifdef USE_PTMSE\r\nnoise = ((read_reg(state, LGDT3305_PT_MSE_1) & 0x07) << 16) |\r\n(read_reg(state, LGDT3305_PT_MSE_2) << 8) |\r\n(read_reg(state, LGDT3305_PT_MSE_3) & 0xff);\r\nc = 73957994;\r\n#else\r\nnoise = ((read_reg(state, LGDT3305_EQ_MSE_1) & 0x0f) << 16) |\r\n(read_reg(state, LGDT3305_EQ_MSE_2) << 8) |\r\n(read_reg(state, LGDT3305_EQ_MSE_3) & 0xff);\r\nc = 73957994;\r\n#endif\r\nbreak;\r\ncase QAM_64:\r\ncase QAM_256:\r\nnoise = (read_reg(state, LGDT3305_CR_MSE_1) << 8) |\r\n(read_reg(state, LGDT3305_CR_MSE_2) & 0xff);\r\nc = (state->current_modulation == QAM_64) ?\r\n97939837 : 98026066;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nstate->snr = calculate_snr(noise, c);\r\n*snr = (state->snr / ((1 << 24) / 10));\r\nlg_dbg("noise = 0x%08x, snr = %d.%02d dB\n", noise,\r\nstate->snr >> 24, (((state->snr >> 8) & 0xffff) * 100) >> 16);\r\nreturn 0;\r\n}\r\nstatic int lgdt3305_read_signal_strength(struct dvb_frontend *fe,\r\nu16 *strength)\r\n{\r\nstruct lgdt3305_state *state = fe->demodulator_priv;\r\nu16 snr;\r\nint ret;\r\n*strength = 0;\r\nret = fe->ops.read_snr(fe, &snr);\r\nif (lg_fail(ret))\r\ngoto fail;\r\nif (state->snr >= 8960 * 0x10000)\r\n*strength = 0xffff;\r\nelse\r\n*strength = state->snr / 8960;\r\nfail:\r\nreturn ret;\r\n}\r\nstatic int lgdt3305_read_ber(struct dvb_frontend *fe, u32 *ber)\r\n{\r\n*ber = 0;\r\nreturn 0;\r\n}\r\nstatic int lgdt3305_read_ucblocks(struct dvb_frontend *fe, u32 *ucblocks)\r\n{\r\nstruct lgdt3305_state *state = fe->demodulator_priv;\r\n*ucblocks =\r\n(read_reg(state, LGDT3305_FEC_PKT_ERR_1) << 8) |\r\n(read_reg(state, LGDT3305_FEC_PKT_ERR_2) & 0xff);\r\nreturn 0;\r\n}\r\nstatic int lgdt3305_get_tune_settings(struct dvb_frontend *fe,\r\nstruct dvb_frontend_tune_settings\r\n*fe_tune_settings)\r\n{\r\nfe_tune_settings->min_delay_ms = 500;\r\nlg_dbg("\n");\r\nreturn 0;\r\n}\r\nstatic void lgdt3305_release(struct dvb_frontend *fe)\r\n{\r\nstruct lgdt3305_state *state = fe->demodulator_priv;\r\nlg_dbg("\n");\r\nkfree(state);\r\n}\r\nstruct dvb_frontend *lgdt3305_attach(const struct lgdt3305_config *config,\r\nstruct i2c_adapter *i2c_adap)\r\n{\r\nstruct lgdt3305_state *state = NULL;\r\nint ret;\r\nu8 val;\r\nlg_dbg("(%d-%04x)\n",\r\ni2c_adap ? i2c_adapter_id(i2c_adap) : 0,\r\nconfig ? config->i2c_addr : 0);\r\nstate = kzalloc(sizeof(struct lgdt3305_state), GFP_KERNEL);\r\nif (state == NULL)\r\ngoto fail;\r\nstate->cfg = config;\r\nstate->i2c_adap = i2c_adap;\r\nswitch (config->demod_chip) {\r\ncase LGDT3304:\r\nmemcpy(&state->frontend.ops, &lgdt3304_ops,\r\nsizeof(struct dvb_frontend_ops));\r\nbreak;\r\ncase LGDT3305:\r\nmemcpy(&state->frontend.ops, &lgdt3305_ops,\r\nsizeof(struct dvb_frontend_ops));\r\nbreak;\r\ndefault:\r\ngoto fail;\r\n}\r\nstate->frontend.demodulator_priv = state;\r\nret = lgdt3305_read_reg(state, LGDT3305_GEN_CTRL_2, &val);\r\nif ((lg_fail(ret)) | (val == 0))\r\ngoto fail;\r\nret = lgdt3305_write_reg(state, 0x0808, 0x80);\r\nif (lg_fail(ret))\r\ngoto fail;\r\nret = lgdt3305_read_reg(state, 0x0808, &val);\r\nif ((lg_fail(ret)) | (val != 0x80))\r\ngoto fail;\r\nret = lgdt3305_write_reg(state, 0x0808, 0x00);\r\nif (lg_fail(ret))\r\ngoto fail;\r\nstate->current_frequency = -1;\r\nstate->current_modulation = -1;\r\nreturn &state->frontend;\r\nfail:\r\nlg_warn("unable to detect %s hardware\n",\r\nconfig->demod_chip ? "LGDT3304" : "LGDT3305");\r\nkfree(state);\r\nreturn NULL;\r\n}
