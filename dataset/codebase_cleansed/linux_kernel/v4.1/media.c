int tulip_mdio_read(struct net_device *dev, int phy_id, int location)\r\n{\r\nstruct tulip_private *tp = netdev_priv(dev);\r\nint i;\r\nint read_cmd = (0xf6 << 10) | ((phy_id & 0x1f) << 5) | location;\r\nint retval = 0;\r\nvoid __iomem *ioaddr = tp->base_addr;\r\nvoid __iomem *mdio_addr = ioaddr + CSR9;\r\nunsigned long flags;\r\nif (location & ~0x1f)\r\nreturn 0xffff;\r\nif (tp->chip_id == COMET && phy_id == 30) {\r\nif (comet_miireg2offset[location])\r\nreturn ioread32(ioaddr + comet_miireg2offset[location]);\r\nreturn 0xffff;\r\n}\r\nspin_lock_irqsave(&tp->mii_lock, flags);\r\nif (tp->chip_id == LC82C168) {\r\niowrite32(0x60020000 + (phy_id<<23) + (location<<18), ioaddr + 0xA0);\r\nioread32(ioaddr + 0xA0);\r\nioread32(ioaddr + 0xA0);\r\nfor (i = 1000; i >= 0; --i) {\r\nbarrier();\r\nif ( ! ((retval = ioread32(ioaddr + 0xA0)) & 0x80000000))\r\nbreak;\r\n}\r\nspin_unlock_irqrestore(&tp->mii_lock, flags);\r\nreturn retval & 0xffff;\r\n}\r\nfor (i = 32; i >= 0; i--) {\r\niowrite32(MDIO_ENB | MDIO_DATA_WRITE1, mdio_addr);\r\nmdio_delay();\r\niowrite32(MDIO_ENB | MDIO_DATA_WRITE1 | MDIO_SHIFT_CLK, mdio_addr);\r\nmdio_delay();\r\n}\r\nfor (i = 15; i >= 0; i--) {\r\nint dataval = (read_cmd & (1 << i)) ? MDIO_DATA_WRITE1 : 0;\r\niowrite32(MDIO_ENB | dataval, mdio_addr);\r\nmdio_delay();\r\niowrite32(MDIO_ENB | dataval | MDIO_SHIFT_CLK, mdio_addr);\r\nmdio_delay();\r\n}\r\nfor (i = 19; i > 0; i--) {\r\niowrite32(MDIO_ENB_IN, mdio_addr);\r\nmdio_delay();\r\nretval = (retval << 1) | ((ioread32(mdio_addr) & MDIO_DATA_READ) ? 1 : 0);\r\niowrite32(MDIO_ENB_IN | MDIO_SHIFT_CLK, mdio_addr);\r\nmdio_delay();\r\n}\r\nspin_unlock_irqrestore(&tp->mii_lock, flags);\r\nreturn (retval>>1) & 0xffff;\r\n}\r\nvoid tulip_mdio_write(struct net_device *dev, int phy_id, int location, int val)\r\n{\r\nstruct tulip_private *tp = netdev_priv(dev);\r\nint i;\r\nint cmd = (0x5002 << 16) | ((phy_id & 0x1f) << 23) | (location<<18) | (val & 0xffff);\r\nvoid __iomem *ioaddr = tp->base_addr;\r\nvoid __iomem *mdio_addr = ioaddr + CSR9;\r\nunsigned long flags;\r\nif (location & ~0x1f)\r\nreturn;\r\nif (tp->chip_id == COMET && phy_id == 30) {\r\nif (comet_miireg2offset[location])\r\niowrite32(val, ioaddr + comet_miireg2offset[location]);\r\nreturn;\r\n}\r\nspin_lock_irqsave(&tp->mii_lock, flags);\r\nif (tp->chip_id == LC82C168) {\r\niowrite32(cmd, ioaddr + 0xA0);\r\nfor (i = 1000; i >= 0; --i) {\r\nbarrier();\r\nif ( ! (ioread32(ioaddr + 0xA0) & 0x80000000))\r\nbreak;\r\n}\r\nspin_unlock_irqrestore(&tp->mii_lock, flags);\r\nreturn;\r\n}\r\nfor (i = 32; i >= 0; i--) {\r\niowrite32(MDIO_ENB | MDIO_DATA_WRITE1, mdio_addr);\r\nmdio_delay();\r\niowrite32(MDIO_ENB | MDIO_DATA_WRITE1 | MDIO_SHIFT_CLK, mdio_addr);\r\nmdio_delay();\r\n}\r\nfor (i = 31; i >= 0; i--) {\r\nint dataval = (cmd & (1 << i)) ? MDIO_DATA_WRITE1 : 0;\r\niowrite32(MDIO_ENB | dataval, mdio_addr);\r\nmdio_delay();\r\niowrite32(MDIO_ENB | dataval | MDIO_SHIFT_CLK, mdio_addr);\r\nmdio_delay();\r\n}\r\nfor (i = 2; i > 0; i--) {\r\niowrite32(MDIO_ENB_IN, mdio_addr);\r\nmdio_delay();\r\niowrite32(MDIO_ENB_IN | MDIO_SHIFT_CLK, mdio_addr);\r\nmdio_delay();\r\n}\r\nspin_unlock_irqrestore(&tp->mii_lock, flags);\r\n}\r\nvoid tulip_select_media(struct net_device *dev, int startup)\r\n{\r\nstruct tulip_private *tp = netdev_priv(dev);\r\nvoid __iomem *ioaddr = tp->base_addr;\r\nstruct mediatable *mtable = tp->mtable;\r\nu32 new_csr6;\r\nint i;\r\nif (mtable) {\r\nstruct medialeaf *mleaf = &mtable->mleaf[tp->cur_index];\r\nunsigned char *p = mleaf->leafdata;\r\nswitch (mleaf->type) {\r\ncase 0:\r\nif (tulip_debug > 1)\r\nnetdev_dbg(dev, "Using a 21140 non-MII transceiver with control setting %02x\n",\r\np[1]);\r\ndev->if_port = p[0];\r\nif (startup)\r\niowrite32(mtable->csr12dir | 0x100, ioaddr + CSR12);\r\niowrite32(p[1], ioaddr + CSR12);\r\nnew_csr6 = 0x02000000 | ((p[2] & 0x71) << 18);\r\nbreak;\r\ncase 2: case 4: {\r\nu16 setup[5];\r\nu32 csr13val, csr14val, csr15dir, csr15val;\r\nfor (i = 0; i < 5; i++)\r\nsetup[i] = get_u16(&p[i*2 + 1]);\r\ndev->if_port = p[0] & MEDIA_MASK;\r\nif (tulip_media_cap[dev->if_port] & MediaAlwaysFD)\r\ntp->full_duplex = 1;\r\nif (startup && mtable->has_reset) {\r\nstruct medialeaf *rleaf = &mtable->mleaf[mtable->has_reset];\r\nunsigned char *rst = rleaf->leafdata;\r\nif (tulip_debug > 1)\r\nnetdev_dbg(dev, "Resetting the transceiver\n");\r\nfor (i = 0; i < rst[0]; i++)\r\niowrite32(get_u16(rst + 1 + (i<<1)) << 16, ioaddr + CSR15);\r\n}\r\nif (tulip_debug > 1)\r\nnetdev_dbg(dev, "21143 non-MII %s transceiver control %04x/%04x\n",\r\nmedianame[dev->if_port],\r\nsetup[0], setup[1]);\r\nif (p[0] & 0x40) {\r\ncsr13val = setup[0];\r\ncsr14val = setup[1];\r\ncsr15dir = (setup[3]<<16) | setup[2];\r\ncsr15val = (setup[4]<<16) | setup[2];\r\niowrite32(0, ioaddr + CSR13);\r\niowrite32(csr14val, ioaddr + CSR14);\r\niowrite32(csr15dir, ioaddr + CSR15);\r\niowrite32(csr15val, ioaddr + CSR15);\r\niowrite32(csr13val, ioaddr + CSR13);\r\n} else {\r\ncsr13val = 1;\r\ncsr14val = 0;\r\ncsr15dir = (setup[0]<<16) | 0x0008;\r\ncsr15val = (setup[1]<<16) | 0x0008;\r\nif (dev->if_port <= 4)\r\ncsr14val = t21142_csr14[dev->if_port];\r\nif (startup) {\r\niowrite32(0, ioaddr + CSR13);\r\niowrite32(csr14val, ioaddr + CSR14);\r\n}\r\niowrite32(csr15dir, ioaddr + CSR15);\r\niowrite32(csr15val, ioaddr + CSR15);\r\nif (startup) iowrite32(csr13val, ioaddr + CSR13);\r\n}\r\nif (tulip_debug > 1)\r\nnetdev_dbg(dev, "Setting CSR15 to %08x/%08x\n",\r\ncsr15dir, csr15val);\r\nif (mleaf->type == 4)\r\nnew_csr6 = 0x82020000 | ((setup[2] & 0x71) << 18);\r\nelse\r\nnew_csr6 = 0x82420000;\r\nbreak;\r\n}\r\ncase 1: case 3: {\r\nint phy_num = p[0];\r\nint init_length = p[1];\r\nu16 *misc_info, tmp_info;\r\ndev->if_port = 11;\r\nnew_csr6 = 0x020E0000;\r\nif (mleaf->type == 3) {\r\nu16 *init_sequence = (u16*)(p+2);\r\nu16 *reset_sequence = &((u16*)(p+3))[init_length];\r\nint reset_length = p[2 + init_length*2];\r\nmisc_info = reset_sequence + reset_length;\r\nif (startup) {\r\nint timeout = 10;\r\nfor (i = 0; i < reset_length; i++)\r\niowrite32(get_u16(&reset_sequence[i]) << 16, ioaddr + CSR15);\r\nioread32(ioaddr + CSR15);\r\nudelay(500);\r\nwhile (timeout-- &&\r\n(tulip_mdio_read (dev, phy_num, MII_BMCR) & BMCR_RESET))\r\nudelay(100);\r\n}\r\nfor (i = 0; i < init_length; i++)\r\niowrite32(get_u16(&init_sequence[i]) << 16, ioaddr + CSR15);\r\nioread32(ioaddr + CSR15);\r\n} else {\r\nu8 *init_sequence = p + 2;\r\nu8 *reset_sequence = p + 3 + init_length;\r\nint reset_length = p[2 + init_length];\r\nmisc_info = (u16*)(reset_sequence + reset_length);\r\nif (startup) {\r\nint timeout = 10;\r\niowrite32(mtable->csr12dir | 0x100, ioaddr + CSR12);\r\nfor (i = 0; i < reset_length; i++)\r\niowrite32(reset_sequence[i], ioaddr + CSR12);\r\nioread32(ioaddr + CSR12);\r\nudelay(500);\r\nwhile (timeout-- &&\r\n(tulip_mdio_read (dev, phy_num, MII_BMCR) & BMCR_RESET))\r\nudelay(100);\r\n}\r\nfor (i = 0; i < init_length; i++)\r\niowrite32(init_sequence[i], ioaddr + CSR12);\r\nioread32(ioaddr + CSR12);\r\n}\r\ntmp_info = get_u16(&misc_info[1]);\r\nif (tmp_info)\r\ntp->advertising[phy_num] = tmp_info | 1;\r\nif (tmp_info && startup < 2) {\r\nif (tp->mii_advertise == 0)\r\ntp->mii_advertise = tp->advertising[phy_num];\r\nif (tulip_debug > 1)\r\nnetdev_dbg(dev, " Advertising %04x on MII %d\n",\r\ntp->mii_advertise,\r\ntp->phys[phy_num]);\r\ntulip_mdio_write(dev, tp->phys[phy_num], 4, tp->mii_advertise);\r\n}\r\nbreak;\r\n}\r\ncase 5: case 6: {\r\nu16 setup[5];\r\nnew_csr6 = 0;\r\nfor (i = 0; i < 5; i++)\r\nsetup[i] = get_u16(&p[i*2 + 1]);\r\nif (startup && mtable->has_reset) {\r\nstruct medialeaf *rleaf = &mtable->mleaf[mtable->has_reset];\r\nunsigned char *rst = rleaf->leafdata;\r\nif (tulip_debug > 1)\r\nnetdev_dbg(dev, "Resetting the transceiver\n");\r\nfor (i = 0; i < rst[0]; i++)\r\niowrite32(get_u16(rst + 1 + (i<<1)) << 16, ioaddr + CSR15);\r\n}\r\nbreak;\r\n}\r\ndefault:\r\nnetdev_dbg(dev, " Invalid media table selection %d\n",\r\nmleaf->type);\r\nnew_csr6 = 0x020E0000;\r\n}\r\nif (tulip_debug > 1)\r\nnetdev_dbg(dev, "Using media type %s, CSR12 is %02x\n",\r\nmedianame[dev->if_port],\r\nioread32(ioaddr + CSR12) & 0xff);\r\n} else if (tp->chip_id == LC82C168) {\r\nif (startup && ! tp->medialock)\r\ndev->if_port = tp->mii_cnt ? 11 : 0;\r\nif (tulip_debug > 1)\r\nnetdev_dbg(dev, "PNIC PHY status is %3.3x, media %s\n",\r\nioread32(ioaddr + 0xB8),\r\nmedianame[dev->if_port]);\r\nif (tp->mii_cnt) {\r\nnew_csr6 = 0x810C0000;\r\niowrite32(0x0001, ioaddr + CSR15);\r\niowrite32(0x0201B07A, ioaddr + 0xB8);\r\n} else if (startup) {\r\niowrite32(0x32, ioaddr + CSR12);\r\nnew_csr6 = 0x00420000;\r\niowrite32(0x0001B078, ioaddr + 0xB8);\r\niowrite32(0x0201B078, ioaddr + 0xB8);\r\n} else if (dev->if_port == 3 || dev->if_port == 5) {\r\niowrite32(0x33, ioaddr + CSR12);\r\nnew_csr6 = 0x01860000;\r\niowrite32(startup ? 0x0201F868 : 0x0001F868, ioaddr + 0xB8);\r\n} else {\r\niowrite32(0x32, ioaddr + CSR12);\r\nnew_csr6 = 0x00420000;\r\niowrite32(0x1F078, ioaddr + 0xB8);\r\n}\r\n} else {\r\nif (tp->default_port == 0)\r\ndev->if_port = tp->mii_cnt ? 11 : 3;\r\nif (tulip_media_cap[dev->if_port] & MediaIsMII) {\r\nnew_csr6 = 0x020E0000;\r\n} else if (tulip_media_cap[dev->if_port] & MediaIsFx) {\r\nnew_csr6 = 0x02860000;\r\n} else\r\nnew_csr6 = 0x03860000;\r\nif (tulip_debug > 1)\r\nnetdev_dbg(dev, "No media description table, assuming %s transceiver, CSR12 %02x\n",\r\nmedianame[dev->if_port],\r\nioread32(ioaddr + CSR12));\r\n}\r\ntp->csr6 = new_csr6 | (tp->csr6 & 0xfdff) | (tp->full_duplex ? 0x0200 : 0);\r\nmdelay(1);\r\n}\r\nint tulip_check_duplex(struct net_device *dev)\r\n{\r\nstruct tulip_private *tp = netdev_priv(dev);\r\nunsigned int bmsr, lpa, negotiated, new_csr6;\r\nbmsr = tulip_mdio_read(dev, tp->phys[0], MII_BMSR);\r\nlpa = tulip_mdio_read(dev, tp->phys[0], MII_LPA);\r\nif (tulip_debug > 1)\r\ndev_info(&dev->dev, "MII status %04x, Link partner report %04x\n",\r\nbmsr, lpa);\r\nif (bmsr == 0xffff)\r\nreturn -2;\r\nif ((bmsr & BMSR_LSTATUS) == 0) {\r\nint new_bmsr = tulip_mdio_read(dev, tp->phys[0], MII_BMSR);\r\nif ((new_bmsr & BMSR_LSTATUS) == 0) {\r\nif (tulip_debug > 1)\r\ndev_info(&dev->dev,\r\n"No link beat on the MII interface, status %04x\n",\r\nnew_bmsr);\r\nreturn -1;\r\n}\r\n}\r\nnegotiated = lpa & tp->advertising[0];\r\ntp->full_duplex = mii_duplex(tp->full_duplex_lock, negotiated);\r\nnew_csr6 = tp->csr6;\r\nif (negotiated & LPA_100) new_csr6 &= ~TxThreshold;\r\nelse new_csr6 |= TxThreshold;\r\nif (tp->full_duplex) new_csr6 |= FullDuplex;\r\nelse new_csr6 &= ~FullDuplex;\r\nif (new_csr6 != tp->csr6) {\r\ntp->csr6 = new_csr6;\r\ntulip_restart_rxtx(tp);\r\nif (tulip_debug > 0)\r\ndev_info(&dev->dev,\r\n"Setting %s-duplex based on MII#%d link partner capability of %04x\n",\r\ntp->full_duplex ? "full" : "half",\r\ntp->phys[0], lpa);\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nvoid tulip_find_mii(struct net_device *dev, int board_idx)\r\n{\r\nstruct tulip_private *tp = netdev_priv(dev);\r\nint phyn, phy_idx = 0;\r\nint mii_reg0;\r\nint mii_advert;\r\nunsigned int to_advert, new_bmcr, ane_switch;\r\nfor (phyn = 1; phyn <= 32 && phy_idx < ARRAY_SIZE(tp->phys); phyn++) {\r\nint phy = phyn & 0x1f;\r\nint mii_status = tulip_mdio_read (dev, phy, MII_BMSR);\r\nif ((mii_status & 0x8301) == 0x8001 ||\r\n((mii_status & BMSR_100BASE4) == 0 &&\r\n(mii_status & 0x7800) != 0)) {\r\n} else {\r\ncontinue;\r\n}\r\nmii_reg0 = tulip_mdio_read (dev, phy, MII_BMCR);\r\nmii_advert = tulip_mdio_read (dev, phy, MII_ADVERTISE);\r\nane_switch = 0;\r\nif ((mii_advert & ADVERTISE_ALL) == 0) {\r\nunsigned int tmpadv = tulip_mdio_read (dev, phy, MII_BMSR);\r\nmii_advert = ((tmpadv >> 6) & 0x3e0) | 1;\r\n}\r\nif (tp->mii_advertise) {\r\ntp->advertising[phy_idx] =\r\nto_advert = tp->mii_advertise;\r\n} else if (tp->advertising[phy_idx]) {\r\nto_advert = tp->advertising[phy_idx];\r\n} else {\r\ntp->advertising[phy_idx] =\r\ntp->mii_advertise =\r\nto_advert = mii_advert;\r\n}\r\ntp->phys[phy_idx++] = phy;\r\npr_info("tulip%d: MII transceiver #%d config %04x status %04x advertising %04x\n",\r\nboard_idx, phy, mii_reg0, mii_status, mii_advert);\r\nif (mii_advert != to_advert) {\r\npr_debug("tulip%d: Advertising %04x on PHY %d, previously advertising %04x\n",\r\nboard_idx, to_advert, phy, mii_advert);\r\ntulip_mdio_write (dev, phy, 4, to_advert);\r\n}\r\nif (tp->default_port == 0) {\r\nnew_bmcr = mii_reg0 | BMCR_ANENABLE;\r\nif (new_bmcr != mii_reg0) {\r\nnew_bmcr |= BMCR_ANRESTART;\r\nane_switch = 1;\r\n}\r\n}\r\nelse {\r\nnew_bmcr = mii_reg0 & ~BMCR_ANENABLE;\r\nif (new_bmcr != mii_reg0)\r\nane_switch = 1;\r\n}\r\nnew_bmcr &= ~(BMCR_CTST | BMCR_FULLDPLX | BMCR_ISOLATE |\r\nBMCR_PDOWN | BMCR_SPEED100 | BMCR_LOOPBACK |\r\nBMCR_RESET);\r\nif (tp->full_duplex)\r\nnew_bmcr |= BMCR_FULLDPLX;\r\nif (tulip_media_cap[tp->default_port] & MediaIs100)\r\nnew_bmcr |= BMCR_SPEED100;\r\nif (new_bmcr != mii_reg0) {\r\nif (ane_switch) {\r\ntulip_mdio_write (dev, phy, MII_BMCR, new_bmcr);\r\nudelay (10);\r\n}\r\ntulip_mdio_write (dev, phy, MII_BMCR, new_bmcr);\r\n}\r\n}\r\ntp->mii_cnt = phy_idx;\r\nif (tp->mtable && tp->mtable->has_mii && phy_idx == 0) {\r\npr_info("tulip%d: ***WARNING***: No MII transceiver found!\n",\r\nboard_idx);\r\ntp->phys[0] = 1;\r\n}\r\n}
