static void register_emulation_hooks(struct insn_emulation_ops *ops)\r\n{\r\nstruct undef_hook *hook;\r\nBUG_ON(!ops->hooks);\r\nfor (hook = ops->hooks; hook->instr_mask; hook++)\r\nregister_undef_hook(hook);\r\npr_notice("Registered %s emulation handler\n", ops->name);\r\n}\r\nstatic void remove_emulation_hooks(struct insn_emulation_ops *ops)\r\n{\r\nstruct undef_hook *hook;\r\nBUG_ON(!ops->hooks);\r\nfor (hook = ops->hooks; hook->instr_mask; hook++)\r\nunregister_undef_hook(hook);\r\npr_notice("Removed %s emulation handler\n", ops->name);\r\n}\r\nstatic void enable_insn_hw_mode(void *data)\r\n{\r\nstruct insn_emulation *insn = (struct insn_emulation *)data;\r\nif (insn->ops->set_hw_mode)\r\ninsn->ops->set_hw_mode(true);\r\n}\r\nstatic void disable_insn_hw_mode(void *data)\r\n{\r\nstruct insn_emulation *insn = (struct insn_emulation *)data;\r\nif (insn->ops->set_hw_mode)\r\ninsn->ops->set_hw_mode(false);\r\n}\r\nstatic int run_all_cpu_set_hw_mode(struct insn_emulation *insn, bool enable)\r\n{\r\nif (!insn->ops->set_hw_mode)\r\nreturn -EINVAL;\r\nif (enable)\r\non_each_cpu(enable_insn_hw_mode, (void *)insn, true);\r\nelse\r\non_each_cpu(disable_insn_hw_mode, (void *)insn, true);\r\nreturn 0;\r\n}\r\nstatic int run_all_insn_set_hw_mode(unsigned long cpu)\r\n{\r\nint rc = 0;\r\nunsigned long flags;\r\nstruct insn_emulation *insn;\r\nraw_spin_lock_irqsave(&insn_emulation_lock, flags);\r\nlist_for_each_entry(insn, &insn_emulation, node) {\r\nbool enable = (insn->current_mode == INSN_HW);\r\nif (insn->ops->set_hw_mode && insn->ops->set_hw_mode(enable)) {\r\npr_warn("CPU[%ld] cannot support the emulation of %s",\r\ncpu, insn->ops->name);\r\nrc = -EINVAL;\r\n}\r\n}\r\nraw_spin_unlock_irqrestore(&insn_emulation_lock, flags);\r\nreturn rc;\r\n}\r\nstatic int update_insn_emulation_mode(struct insn_emulation *insn,\r\nenum insn_emulation_mode prev)\r\n{\r\nint ret = 0;\r\nswitch (prev) {\r\ncase INSN_UNDEF:\r\nbreak;\r\ncase INSN_EMULATE:\r\nremove_emulation_hooks(insn->ops);\r\nbreak;\r\ncase INSN_HW:\r\nif (!run_all_cpu_set_hw_mode(insn, false))\r\npr_notice("Disabled %s support\n", insn->ops->name);\r\nbreak;\r\n}\r\nswitch (insn->current_mode) {\r\ncase INSN_UNDEF:\r\nbreak;\r\ncase INSN_EMULATE:\r\nregister_emulation_hooks(insn->ops);\r\nbreak;\r\ncase INSN_HW:\r\nret = run_all_cpu_set_hw_mode(insn, true);\r\nif (!ret)\r\npr_notice("Enabled %s support\n", insn->ops->name);\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic void register_insn_emulation(struct insn_emulation_ops *ops)\r\n{\r\nunsigned long flags;\r\nstruct insn_emulation *insn;\r\ninsn = kzalloc(sizeof(*insn), GFP_KERNEL);\r\ninsn->ops = ops;\r\ninsn->min = INSN_UNDEF;\r\nswitch (ops->status) {\r\ncase INSN_DEPRECATED:\r\ninsn->current_mode = INSN_EMULATE;\r\nrun_all_cpu_set_hw_mode(insn, false);\r\ninsn->max = INSN_HW;\r\nbreak;\r\ncase INSN_OBSOLETE:\r\ninsn->current_mode = INSN_UNDEF;\r\ninsn->max = INSN_EMULATE;\r\nbreak;\r\n}\r\nraw_spin_lock_irqsave(&insn_emulation_lock, flags);\r\nlist_add(&insn->node, &insn_emulation);\r\nnr_insn_emulated++;\r\nraw_spin_unlock_irqrestore(&insn_emulation_lock, flags);\r\nupdate_insn_emulation_mode(insn, INSN_UNDEF);\r\n}\r\nstatic int emulation_proc_handler(struct ctl_table *table, int write,\r\nvoid __user *buffer, size_t *lenp,\r\nloff_t *ppos)\r\n{\r\nint ret = 0;\r\nstruct insn_emulation *insn = (struct insn_emulation *) table->data;\r\nenum insn_emulation_mode prev_mode = insn->current_mode;\r\ntable->data = &insn->current_mode;\r\nret = proc_dointvec_minmax(table, write, buffer, lenp, ppos);\r\nif (ret || !write || prev_mode == insn->current_mode)\r\ngoto ret;\r\nret = update_insn_emulation_mode(insn, prev_mode);\r\nif (ret) {\r\ninsn->current_mode = prev_mode;\r\nupdate_insn_emulation_mode(insn, INSN_UNDEF);\r\n}\r\nret:\r\ntable->data = insn;\r\nreturn ret;\r\n}\r\nstatic void register_insn_emulation_sysctl(struct ctl_table *table)\r\n{\r\nunsigned long flags;\r\nint i = 0;\r\nstruct insn_emulation *insn;\r\nstruct ctl_table *insns_sysctl, *sysctl;\r\ninsns_sysctl = kzalloc(sizeof(*sysctl) * (nr_insn_emulated + 1),\r\nGFP_KERNEL);\r\nraw_spin_lock_irqsave(&insn_emulation_lock, flags);\r\nlist_for_each_entry(insn, &insn_emulation, node) {\r\nsysctl = &insns_sysctl[i];\r\nsysctl->mode = 0644;\r\nsysctl->maxlen = sizeof(int);\r\nsysctl->procname = insn->ops->name;\r\nsysctl->data = insn;\r\nsysctl->extra1 = &insn->min;\r\nsysctl->extra2 = &insn->max;\r\nsysctl->proc_handler = emulation_proc_handler;\r\ni++;\r\n}\r\nraw_spin_unlock_irqrestore(&insn_emulation_lock, flags);\r\ntable->child = insns_sysctl;\r\nregister_sysctl_table(table);\r\n}\r\nstatic void set_segfault(struct pt_regs *regs, unsigned long addr)\r\n{\r\nsiginfo_t info;\r\ndown_read(&current->mm->mmap_sem);\r\nif (find_vma(current->mm, addr) == NULL)\r\ninfo.si_code = SEGV_MAPERR;\r\nelse\r\ninfo.si_code = SEGV_ACCERR;\r\nup_read(&current->mm->mmap_sem);\r\ninfo.si_signo = SIGSEGV;\r\ninfo.si_errno = 0;\r\ninfo.si_addr = (void *) instruction_pointer(regs);\r\npr_debug("SWP{B} emulation: access caused memory abort!\n");\r\narm64_notify_die("Illegal memory access", regs, &info, 0);\r\n}\r\nstatic int emulate_swpX(unsigned int address, unsigned int *data,\r\nunsigned int type)\r\n{\r\nunsigned int res = 0;\r\nif ((type != TYPE_SWPB) && (address & 0x3)) {\r\npr_debug("SWP instruction on unaligned pointer!\n");\r\nreturn -EFAULT;\r\n}\r\nwhile (1) {\r\nunsigned long temp;\r\nif (type == TYPE_SWPB)\r\n__user_swpb_asm(*data, address, res, temp);\r\nelse\r\n__user_swp_asm(*data, address, res, temp);\r\nif (likely(res != -EAGAIN) || signal_pending(current))\r\nbreak;\r\ncond_resched();\r\n}\r\nreturn res;\r\n}\r\nstatic int swp_handler(struct pt_regs *regs, u32 instr)\r\n{\r\nu32 destreg, data, type, address = 0;\r\nint rn, rt2, res = 0;\r\nperf_sw_event(PERF_COUNT_SW_EMULATION_FAULTS, 1, regs, regs->pc);\r\ntype = instr & TYPE_SWPB;\r\nswitch (arm_check_condition(instr, regs->pstate)) {\r\ncase ARM_OPCODE_CONDTEST_PASS:\r\nbreak;\r\ncase ARM_OPCODE_CONDTEST_FAIL:\r\ngoto ret;\r\ncase ARM_OPCODE_CONDTEST_UNCOND:\r\nreturn -EFAULT;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nrn = aarch32_insn_extract_reg_num(instr, A32_RN_OFFSET);\r\nrt2 = aarch32_insn_extract_reg_num(instr, A32_RT2_OFFSET);\r\naddress = (u32)regs->user_regs.regs[rn];\r\ndata = (u32)regs->user_regs.regs[rt2];\r\ndestreg = aarch32_insn_extract_reg_num(instr, A32_RT_OFFSET);\r\npr_debug("addr in r%d->0x%08x, dest is r%d, source in r%d->0x%08x)\n",\r\nrn, address, destreg,\r\naarch32_insn_extract_reg_num(instr, A32_RT2_OFFSET), data);\r\nif (!access_ok(VERIFY_WRITE, (address & ~3), 4)) {\r\npr_debug("SWP{B} emulation: access to 0x%08x not allowed!\n",\r\naddress);\r\ngoto fault;\r\n}\r\nres = emulate_swpX(address, &data, type);\r\nif (res == -EFAULT)\r\ngoto fault;\r\nelse if (res == 0)\r\nregs->user_regs.regs[destreg] = data;\r\nret:\r\nif (type == TYPE_SWPB)\r\ntrace_instruction_emulation("swpb", regs->pc);\r\nelse\r\ntrace_instruction_emulation("swp", regs->pc);\r\npr_warn_ratelimited("\"%s\" (%ld) uses obsolete SWP{B} instruction at 0x%llx\n",\r\ncurrent->comm, (unsigned long)current->pid, regs->pc);\r\nregs->pc += 4;\r\nreturn 0;\r\nfault:\r\nset_segfault(regs, address);\r\nreturn 0;\r\n}\r\nstatic int cp15barrier_handler(struct pt_regs *regs, u32 instr)\r\n{\r\nperf_sw_event(PERF_COUNT_SW_EMULATION_FAULTS, 1, regs, regs->pc);\r\nswitch (arm_check_condition(instr, regs->pstate)) {\r\ncase ARM_OPCODE_CONDTEST_PASS:\r\nbreak;\r\ncase ARM_OPCODE_CONDTEST_FAIL:\r\ngoto ret;\r\ncase ARM_OPCODE_CONDTEST_UNCOND:\r\nreturn -EFAULT;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (aarch32_insn_mcr_extract_crm(instr)) {\r\ncase 10:\r\nif (aarch32_insn_mcr_extract_opc2(instr) == 5) {\r\ndmb(sy);\r\ntrace_instruction_emulation(\r\n"mcr p15, 0, Rt, c7, c10, 5 ; dmb", regs->pc);\r\n} else {\r\ndsb(sy);\r\ntrace_instruction_emulation(\r\n"mcr p15, 0, Rt, c7, c10, 4 ; dsb", regs->pc);\r\n}\r\nbreak;\r\ncase 5:\r\ntrace_instruction_emulation(\r\n"mcr p15, 0, Rt, c7, c5, 4 ; isb", regs->pc);\r\nbreak;\r\n}\r\nret:\r\npr_warn_ratelimited("\"%s\" (%ld) uses deprecated CP15 Barrier instruction at 0x%llx\n",\r\ncurrent->comm, (unsigned long)current->pid, regs->pc);\r\nregs->pc += 4;\r\nreturn 0;\r\n}\r\nstatic inline void config_sctlr_el1(u32 clear, u32 set)\r\n{\r\nu32 val;\r\nasm volatile("mrs %0, sctlr_el1" : "=r" (val));\r\nval &= ~clear;\r\nval |= set;\r\nasm volatile("msr sctlr_el1, %0" : : "r" (val));\r\n}\r\nstatic int cp15_barrier_set_hw_mode(bool enable)\r\n{\r\nif (enable)\r\nconfig_sctlr_el1(0, SCTLR_EL1_CP15BEN);\r\nelse\r\nconfig_sctlr_el1(SCTLR_EL1_CP15BEN, 0);\r\nreturn 0;\r\n}\r\nstatic int setend_set_hw_mode(bool enable)\r\n{\r\nif (!cpu_supports_mixed_endian_el0())\r\nreturn -EINVAL;\r\nif (enable)\r\nconfig_sctlr_el1(SCTLR_EL1_SED, 0);\r\nelse\r\nconfig_sctlr_el1(0, SCTLR_EL1_SED);\r\nreturn 0;\r\n}\r\nstatic int compat_setend_handler(struct pt_regs *regs, u32 big_endian)\r\n{\r\nchar *insn;\r\nperf_sw_event(PERF_COUNT_SW_EMULATION_FAULTS, 1, regs, regs->pc);\r\nif (big_endian) {\r\ninsn = "setend be";\r\nregs->pstate |= COMPAT_PSR_E_BIT;\r\n} else {\r\ninsn = "setend le";\r\nregs->pstate &= ~COMPAT_PSR_E_BIT;\r\n}\r\ntrace_instruction_emulation(insn, regs->pc);\r\npr_warn_ratelimited("\"%s\" (%ld) uses deprecated setend instruction at 0x%llx\n",\r\ncurrent->comm, (unsigned long)current->pid, regs->pc);\r\nreturn 0;\r\n}\r\nstatic int a32_setend_handler(struct pt_regs *regs, u32 instr)\r\n{\r\nint rc = compat_setend_handler(regs, (instr >> 9) & 1);\r\nregs->pc += 4;\r\nreturn rc;\r\n}\r\nstatic int t16_setend_handler(struct pt_regs *regs, u32 instr)\r\n{\r\nint rc = compat_setend_handler(regs, (instr >> 3) & 1);\r\nregs->pc += 2;\r\nreturn rc;\r\n}\r\nstatic int insn_cpu_hotplug_notify(struct notifier_block *b,\r\nunsigned long action, void *hcpu)\r\n{\r\nint rc = 0;\r\nif ((action & ~CPU_TASKS_FROZEN) == CPU_STARTING)\r\nrc = run_all_insn_set_hw_mode((unsigned long)hcpu);\r\nreturn notifier_from_errno(rc);\r\n}\r\nstatic int __init armv8_deprecated_init(void)\r\n{\r\nif (IS_ENABLED(CONFIG_SWP_EMULATION))\r\nregister_insn_emulation(&swp_ops);\r\nif (IS_ENABLED(CONFIG_CP15_BARRIER_EMULATION))\r\nregister_insn_emulation(&cp15_barrier_ops);\r\nif (IS_ENABLED(CONFIG_SETEND_EMULATION)) {\r\nif(system_supports_mixed_endian_el0())\r\nregister_insn_emulation(&setend_ops);\r\nelse\r\npr_info("setend instruction emulation is not supported on the system");\r\n}\r\nregister_cpu_notifier(&insn_cpu_hotplug_notifier);\r\nregister_insn_emulation_sysctl(ctl_abi);\r\nreturn 0;\r\n}
