static int get_tj_max(u32 *tj_max)\r\n{\r\nu32 eax, edx;\r\nu32 val;\r\nint err;\r\nerr = rdmsr_safe(MSR_IA32_TEMPERATURE_TARGET, &eax, &edx);\r\nif (err)\r\ngoto err_ret;\r\nelse {\r\nval = (eax >> 16) & 0xff;\r\nif (val)\r\n*tj_max = val * 1000;\r\nelse {\r\nerr = -EINVAL;\r\ngoto err_ret;\r\n}\r\n}\r\nreturn 0;\r\nerr_ret:\r\n*tj_max = 0;\r\nreturn err;\r\n}\r\nstatic int sys_get_trip_temp(struct thermal_zone_device *tzd,\r\nint trip, unsigned long *temp)\r\n{\r\nint status;\r\nu32 out;\r\nstruct soc_sensor_entry *aux_entry;\r\naux_entry = tzd->devdata;\r\nif (!trip) {\r\n*temp = aux_entry->tj_max - crit_offset;\r\nreturn 0;\r\n}\r\nmutex_lock(&aux_update_mutex);\r\nstatus = iosf_mbi_read(BT_MBI_UNIT_PMC, BT_MBI_BUNIT_READ,\r\nSOC_DTS_OFFSET_PTPS, &out);\r\nmutex_unlock(&aux_update_mutex);\r\nif (status)\r\nreturn status;\r\nout = (out >> (trip * 8)) & SOC_DTS_TJMAX_ENCODING;\r\nif (!out)\r\n*temp = 0;\r\nelse\r\n*temp = aux_entry->tj_max - out * 1000;\r\nreturn 0;\r\n}\r\nstatic int update_trip_temp(struct soc_sensor_entry *aux_entry,\r\nint thres_index, unsigned long temp)\r\n{\r\nint status;\r\nu32 temp_out;\r\nu32 out;\r\nu32 store_ptps;\r\nu32 store_ptmc;\r\nu32 store_te_out;\r\nu32 te_out;\r\nu32 int_enable_bit = SOC_DTS_TE_APICA_ENABLE |\r\nSOC_DTS_TE_MSI_ENABLE;\r\ntemp_out = (aux_entry->tj_max - temp) / 1000;\r\nstatus = iosf_mbi_read(BT_MBI_UNIT_PMC, BT_MBI_BUNIT_READ,\r\nSOC_DTS_OFFSET_PTPS, &store_ptps);\r\nif (status)\r\nreturn status;\r\nout = (store_ptps & ~(0xFF << (thres_index * 8)));\r\nout |= (temp_out & 0xFF) << (thres_index * 8);\r\nstatus = iosf_mbi_write(BT_MBI_UNIT_PMC, BT_MBI_BUNIT_WRITE,\r\nSOC_DTS_OFFSET_PTPS, out);\r\nif (status)\r\nreturn status;\r\npr_debug("update_trip_temp PTPS = %x\n", out);\r\nstatus = iosf_mbi_read(BT_MBI_UNIT_PMC, BT_MBI_BUNIT_READ,\r\nSOC_DTS_OFFSET_PTMC, &out);\r\nif (status)\r\ngoto err_restore_ptps;\r\nstore_ptmc = out;\r\nstatus = iosf_mbi_read(BT_MBI_UNIT_PMC, BT_MBI_BUNIT_READ,\r\nSOC_DTS_TE_AUX0 + thres_index,\r\n&te_out);\r\nif (status)\r\ngoto err_restore_ptmc;\r\nstore_te_out = te_out;\r\nout |= (SOC_DTS_CPU_MODULE0_ENABLE_BIT |\r\nSOC_DTS_CPU_MODULE1_ENABLE_BIT);\r\nif (temp) {\r\nif (thres_index)\r\nout |= SOC_DTS_AUX1_ENABLE_BIT;\r\nelse\r\nout |= SOC_DTS_AUX0_ENABLE_BIT;\r\nte_out |= int_enable_bit;\r\n} else {\r\nif (thres_index)\r\nout &= ~SOC_DTS_AUX1_ENABLE_BIT;\r\nelse\r\nout &= ~SOC_DTS_AUX0_ENABLE_BIT;\r\nte_out &= ~int_enable_bit;\r\n}\r\nstatus = iosf_mbi_write(BT_MBI_UNIT_PMC, BT_MBI_BUNIT_WRITE,\r\nSOC_DTS_OFFSET_PTMC, out);\r\nif (status)\r\ngoto err_restore_te_out;\r\nstatus = iosf_mbi_write(BT_MBI_UNIT_PMC, BT_MBI_BUNIT_WRITE,\r\nSOC_DTS_TE_AUX0 + thres_index,\r\nte_out);\r\nif (status)\r\ngoto err_restore_te_out;\r\nreturn 0;\r\nerr_restore_te_out:\r\niosf_mbi_write(BT_MBI_UNIT_PMC, BT_MBI_BUNIT_WRITE,\r\nSOC_DTS_OFFSET_PTMC, store_te_out);\r\nerr_restore_ptmc:\r\niosf_mbi_write(BT_MBI_UNIT_PMC, BT_MBI_BUNIT_WRITE,\r\nSOC_DTS_OFFSET_PTMC, store_ptmc);\r\nerr_restore_ptps:\r\niosf_mbi_write(BT_MBI_UNIT_PMC, BT_MBI_BUNIT_WRITE,\r\nSOC_DTS_OFFSET_PTPS, store_ptps);\r\nreturn status;\r\n}\r\nstatic int sys_set_trip_temp(struct thermal_zone_device *tzd, int trip,\r\nunsigned long temp)\r\n{\r\nstruct soc_sensor_entry *aux_entry = tzd->devdata;\r\nint status;\r\nif (temp > (aux_entry->tj_max - crit_offset))\r\nreturn -EINVAL;\r\nmutex_lock(&aux_update_mutex);\r\nstatus = update_trip_temp(tzd->devdata, trip, temp);\r\nmutex_unlock(&aux_update_mutex);\r\nreturn status;\r\n}\r\nstatic int sys_get_trip_type(struct thermal_zone_device *thermal,\r\nint trip, enum thermal_trip_type *type)\r\n{\r\nif (trip)\r\n*type = THERMAL_TRIP_PASSIVE;\r\nelse\r\n*type = THERMAL_TRIP_CRITICAL;\r\nreturn 0;\r\n}\r\nstatic int sys_get_curr_temp(struct thermal_zone_device *tzd,\r\nunsigned long *temp)\r\n{\r\nint status;\r\nu32 out;\r\nstruct soc_sensor_entry *aux_entry;\r\naux_entry = tzd->devdata;\r\nstatus = iosf_mbi_read(BT_MBI_UNIT_PMC, BT_MBI_BUNIT_READ,\r\nSOC_DTS_OFFSET_TEMP, &out);\r\nif (status)\r\nreturn status;\r\nout = (out & aux_entry->temp_mask) >> aux_entry->temp_shift;\r\nout -= SOC_DTS_TJMAX_ENCODING;\r\n*temp = aux_entry->tj_max - out * 1000;\r\nreturn 0;\r\n}\r\nstatic void free_soc_dts(struct soc_sensor_entry *aux_entry)\r\n{\r\nif (aux_entry) {\r\niosf_mbi_write(BT_MBI_UNIT_PMC, BT_MBI_BUNIT_WRITE,\r\nSOC_DTS_OFFSET_ENABLE, aux_entry->store_status);\r\nthermal_zone_device_unregister(aux_entry->tzone);\r\nkfree(aux_entry);\r\n}\r\n}\r\nstatic int soc_dts_enable(int id)\r\n{\r\nu32 out;\r\nint ret;\r\nret = iosf_mbi_read(BT_MBI_UNIT_PMC, BT_MBI_BUNIT_READ,\r\nSOC_DTS_OFFSET_ENABLE, &out);\r\nif (ret)\r\nreturn ret;\r\nif (!(out & BIT(id))) {\r\nout |= BIT(id);\r\nret = iosf_mbi_write(BT_MBI_UNIT_PMC, BT_MBI_BUNIT_WRITE,\r\nSOC_DTS_OFFSET_ENABLE, out);\r\nif (ret)\r\nreturn ret;\r\n}\r\nreturn ret;\r\n}\r\nstatic struct soc_sensor_entry *alloc_soc_dts(int id, u32 tj_max,\r\nbool notification_support)\r\n{\r\nstruct soc_sensor_entry *aux_entry;\r\nchar name[10];\r\nint trip_count = 0;\r\nint trip_mask = 0;\r\nint err;\r\naux_entry = kzalloc(sizeof(*aux_entry), GFP_KERNEL);\r\nif (!aux_entry) {\r\nerr = -ENOMEM;\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nerr = iosf_mbi_read(BT_MBI_UNIT_PMC, BT_MBI_BUNIT_READ,\r\nSOC_DTS_OFFSET_ENABLE,\r\n&aux_entry->store_status);\r\nif (err)\r\ngoto err_ret;\r\naux_entry->id = id;\r\naux_entry->tj_max = tj_max;\r\naux_entry->temp_mask = 0x00FF << (id * 8);\r\naux_entry->temp_shift = id * 8;\r\nif (notification_support) {\r\ntrip_count = SOC_MAX_DTS_TRIPS;\r\ntrip_mask = 0x02;\r\n}\r\nsnprintf(name, sizeof(name), "soc_dts%d", id);\r\naux_entry->tzone = thermal_zone_device_register(name,\r\ntrip_count,\r\ntrip_mask,\r\naux_entry, &tzone_ops,\r\nNULL, 0, 0);\r\nif (IS_ERR(aux_entry->tzone)) {\r\nerr = PTR_ERR(aux_entry->tzone);\r\ngoto err_ret;\r\n}\r\nerr = soc_dts_enable(id);\r\nif (err)\r\ngoto err_aux_status;\r\nreturn aux_entry;\r\nerr_aux_status:\r\nthermal_zone_device_unregister(aux_entry->tzone);\r\nerr_ret:\r\nkfree(aux_entry);\r\nreturn ERR_PTR(err);\r\n}\r\nstatic void proc_thermal_interrupt(void)\r\n{\r\nu32 sticky_out;\r\nint status;\r\nu32 ptmc_out;\r\nunsigned long flags;\r\nspin_lock_irqsave(&intr_notify_lock, flags);\r\nstatus = iosf_mbi_read(BT_MBI_UNIT_PMC, BT_MBI_BUNIT_READ,\r\nSOC_DTS_OFFSET_PTMC, &ptmc_out);\r\nptmc_out |= SOC_DTS_PTMC_APIC_DEASSERT_BIT;\r\nstatus = iosf_mbi_write(BT_MBI_UNIT_PMC, BT_MBI_BUNIT_WRITE,\r\nSOC_DTS_OFFSET_PTMC, ptmc_out);\r\nstatus = iosf_mbi_read(BT_MBI_UNIT_PMC, BT_MBI_BUNIT_READ,\r\nSOC_DTS_OFFSET_PTTSS, &sticky_out);\r\npr_debug("status %d PTTSS %x\n", status, sticky_out);\r\nif (sticky_out & SOC_DTS_TRIP_MASK) {\r\nint i;\r\nstatus = iosf_mbi_write(BT_MBI_UNIT_PMC, BT_MBI_BUNIT_WRITE,\r\nSOC_DTS_OFFSET_PTTSS, sticky_out);\r\nspin_unlock_irqrestore(&intr_notify_lock, flags);\r\nfor (i = 0; i < SOC_MAX_DTS_SENSORS; ++i) {\r\npr_debug("TZD update for zone %d\n", i);\r\nthermal_zone_device_update(soc_dts[i]->tzone);\r\n}\r\n} else\r\nspin_unlock_irqrestore(&intr_notify_lock, flags);\r\n}\r\nstatic irqreturn_t soc_irq_thread_fn(int irq, void *dev_data)\r\n{\r\nproc_thermal_interrupt();\r\npr_debug("proc_thermal_interrupt\n");\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int __init intel_soc_thermal_init(void)\r\n{\r\nu32 tj_max;\r\nint err = 0;\r\nint i;\r\nconst struct x86_cpu_id *match_cpu;\r\nmatch_cpu = x86_match_cpu(soc_thermal_ids);\r\nif (!match_cpu)\r\nreturn -ENODEV;\r\nif (get_tj_max(&tj_max))\r\nreturn -EINVAL;\r\nsoc_dts_thres_irq = (int)match_cpu->driver_data;\r\nfor (i = 0; i < SOC_MAX_DTS_SENSORS; ++i) {\r\nsoc_dts[i] = alloc_soc_dts(i, tj_max,\r\nsoc_dts_thres_irq ? true : false);\r\nif (IS_ERR(soc_dts[i])) {\r\nerr = PTR_ERR(soc_dts[i]);\r\ngoto err_free;\r\n}\r\n}\r\nspin_lock_init(&intr_notify_lock);\r\nif (soc_dts_thres_irq) {\r\nerr = request_threaded_irq(soc_dts_thres_irq, NULL,\r\nsoc_irq_thread_fn,\r\nIRQF_TRIGGER_RISING | IRQF_ONESHOT,\r\n"soc_dts", soc_dts);\r\nif (err) {\r\npr_err("request_threaded_irq ret %d\n", err);\r\ngoto err_free;\r\n}\r\n}\r\nfor (i = 0; i < SOC_MAX_DTS_SENSORS; ++i) {\r\nerr = update_trip_temp(soc_dts[i], 0, tj_max - crit_offset);\r\nif (err)\r\ngoto err_trip_temp;\r\n}\r\nreturn 0;\r\nerr_trip_temp:\r\ni = SOC_MAX_DTS_SENSORS;\r\nif (soc_dts_thres_irq)\r\nfree_irq(soc_dts_thres_irq, soc_dts);\r\nerr_free:\r\nwhile (--i >= 0)\r\nfree_soc_dts(soc_dts[i]);\r\nreturn err;\r\n}\r\nstatic void __exit intel_soc_thermal_exit(void)\r\n{\r\nint i;\r\nfor (i = 0; i < SOC_MAX_DTS_SENSORS; ++i)\r\nupdate_trip_temp(soc_dts[i], 0, 0);\r\nif (soc_dts_thres_irq)\r\nfree_irq(soc_dts_thres_irq, soc_dts);\r\nfor (i = 0; i < SOC_MAX_DTS_SENSORS; ++i)\r\nfree_soc_dts(soc_dts[i]);\r\n}
