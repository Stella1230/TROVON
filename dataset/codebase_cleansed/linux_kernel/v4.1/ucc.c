int ucc_set_qe_mux_mii_mng(unsigned int ucc_num)\r\n{\r\nunsigned long flags;\r\nif (ucc_num > UCC_MAX_NUM - 1)\r\nreturn -EINVAL;\r\nspin_lock_irqsave(&cmxgcr_lock, flags);\r\nclrsetbits_be32(&qe_immr->qmx.cmxgcr, QE_CMXGCR_MII_ENET_MNG,\r\nucc_num << QE_CMXGCR_MII_ENET_MNG_SHIFT);\r\nspin_unlock_irqrestore(&cmxgcr_lock, flags);\r\nreturn 0;\r\n}\r\nint ucc_set_type(unsigned int ucc_num, enum ucc_speed_type speed)\r\n{\r\nu8 __iomem *guemr;\r\nswitch (ucc_num) {\r\ncase 0: guemr = &qe_immr->ucc1.slow.guemr;\r\nbreak;\r\ncase 1: guemr = &qe_immr->ucc2.slow.guemr;\r\nbreak;\r\ncase 2: guemr = &qe_immr->ucc3.slow.guemr;\r\nbreak;\r\ncase 3: guemr = &qe_immr->ucc4.slow.guemr;\r\nbreak;\r\ncase 4: guemr = &qe_immr->ucc5.slow.guemr;\r\nbreak;\r\ncase 5: guemr = &qe_immr->ucc6.slow.guemr;\r\nbreak;\r\ncase 6: guemr = &qe_immr->ucc7.slow.guemr;\r\nbreak;\r\ncase 7: guemr = &qe_immr->ucc8.slow.guemr;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nclrsetbits_8(guemr, UCC_GUEMR_MODE_MASK,\r\nUCC_GUEMR_SET_RESERVED3 | speed);\r\nreturn 0;\r\n}\r\nstatic void get_cmxucr_reg(unsigned int ucc_num, __be32 __iomem **cmxucr,\r\nunsigned int *reg_num, unsigned int *shift)\r\n{\r\nunsigned int cmx = ((ucc_num & 1) << 1) + (ucc_num > 3);\r\n*reg_num = cmx + 1;\r\n*cmxucr = &qe_immr->qmx.cmxucr[cmx];\r\n*shift = 16 - 8 * (ucc_num & 2);\r\n}\r\nint ucc_mux_set_grant_tsa_bkpt(unsigned int ucc_num, int set, u32 mask)\r\n{\r\n__be32 __iomem *cmxucr;\r\nunsigned int reg_num;\r\nunsigned int shift;\r\nif (ucc_num > UCC_MAX_NUM - 1)\r\nreturn -EINVAL;\r\nget_cmxucr_reg(ucc_num, &cmxucr, &reg_num, &shift);\r\nif (set)\r\nsetbits32(cmxucr, mask << shift);\r\nelse\r\nclrbits32(cmxucr, mask << shift);\r\nreturn 0;\r\n}\r\nint ucc_set_qe_mux_rxtx(unsigned int ucc_num, enum qe_clock clock,\r\nenum comm_dir mode)\r\n{\r\n__be32 __iomem *cmxucr;\r\nunsigned int reg_num;\r\nunsigned int shift;\r\nu32 clock_bits = 0;\r\nif (ucc_num > UCC_MAX_NUM - 1)\r\nreturn -EINVAL;\r\nif (!((mode == COMM_DIR_RX) || (mode == COMM_DIR_TX)))\r\nreturn -EINVAL;\r\nget_cmxucr_reg(ucc_num, &cmxucr, &reg_num, &shift);\r\nswitch (reg_num) {\r\ncase 1:\r\nswitch (clock) {\r\ncase QE_BRG1: clock_bits = 1; break;\r\ncase QE_BRG2: clock_bits = 2; break;\r\ncase QE_BRG7: clock_bits = 3; break;\r\ncase QE_BRG8: clock_bits = 4; break;\r\ncase QE_CLK9: clock_bits = 5; break;\r\ncase QE_CLK10: clock_bits = 6; break;\r\ncase QE_CLK11: clock_bits = 7; break;\r\ncase QE_CLK12: clock_bits = 8; break;\r\ncase QE_CLK15: clock_bits = 9; break;\r\ncase QE_CLK16: clock_bits = 10; break;\r\ndefault: break;\r\n}\r\nbreak;\r\ncase 2:\r\nswitch (clock) {\r\ncase QE_BRG5: clock_bits = 1; break;\r\ncase QE_BRG6: clock_bits = 2; break;\r\ncase QE_BRG7: clock_bits = 3; break;\r\ncase QE_BRG8: clock_bits = 4; break;\r\ncase QE_CLK13: clock_bits = 5; break;\r\ncase QE_CLK14: clock_bits = 6; break;\r\ncase QE_CLK19: clock_bits = 7; break;\r\ncase QE_CLK20: clock_bits = 8; break;\r\ncase QE_CLK15: clock_bits = 9; break;\r\ncase QE_CLK16: clock_bits = 10; break;\r\ndefault: break;\r\n}\r\nbreak;\r\ncase 3:\r\nswitch (clock) {\r\ncase QE_BRG9: clock_bits = 1; break;\r\ncase QE_BRG10: clock_bits = 2; break;\r\ncase QE_BRG15: clock_bits = 3; break;\r\ncase QE_BRG16: clock_bits = 4; break;\r\ncase QE_CLK3: clock_bits = 5; break;\r\ncase QE_CLK4: clock_bits = 6; break;\r\ncase QE_CLK17: clock_bits = 7; break;\r\ncase QE_CLK18: clock_bits = 8; break;\r\ncase QE_CLK7: clock_bits = 9; break;\r\ncase QE_CLK8: clock_bits = 10; break;\r\ncase QE_CLK16: clock_bits = 11; break;\r\ndefault: break;\r\n}\r\nbreak;\r\ncase 4:\r\nswitch (clock) {\r\ncase QE_BRG13: clock_bits = 1; break;\r\ncase QE_BRG14: clock_bits = 2; break;\r\ncase QE_BRG15: clock_bits = 3; break;\r\ncase QE_BRG16: clock_bits = 4; break;\r\ncase QE_CLK5: clock_bits = 5; break;\r\ncase QE_CLK6: clock_bits = 6; break;\r\ncase QE_CLK21: clock_bits = 7; break;\r\ncase QE_CLK22: clock_bits = 8; break;\r\ncase QE_CLK7: clock_bits = 9; break;\r\ncase QE_CLK8: clock_bits = 10; break;\r\ncase QE_CLK16: clock_bits = 11; break;\r\ndefault: break;\r\n}\r\nbreak;\r\ndefault: break;\r\n}\r\nif (!clock_bits)\r\nreturn -ENOENT;\r\nif (mode == COMM_DIR_RX)\r\nshift += 4;\r\nclrsetbits_be32(cmxucr, QE_CMXUCR_TX_CLK_SRC_MASK << shift,\r\nclock_bits << shift);\r\nreturn 0;\r\n}
