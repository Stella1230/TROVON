static int gact_net_rand(struct tcf_gact *gact)\r\n{\r\nif (!gact->tcfg_pval || prandom_u32() % gact->tcfg_pval)\r\nreturn gact->tcf_action;\r\nreturn gact->tcfg_paction;\r\n}\r\nstatic int gact_determ(struct tcf_gact *gact)\r\n{\r\nif (!gact->tcfg_pval || gact->tcf_bstats.packets % gact->tcfg_pval)\r\nreturn gact->tcf_action;\r\nreturn gact->tcfg_paction;\r\n}\r\nstatic int tcf_gact_init(struct net *net, struct nlattr *nla,\r\nstruct nlattr *est, struct tc_action *a,\r\nint ovr, int bind)\r\n{\r\nstruct nlattr *tb[TCA_GACT_MAX + 1];\r\nstruct tc_gact *parm;\r\nstruct tcf_gact *gact;\r\nint ret = 0;\r\nint err;\r\n#ifdef CONFIG_GACT_PROB\r\nstruct tc_gact_p *p_parm = NULL;\r\n#endif\r\nif (nla == NULL)\r\nreturn -EINVAL;\r\nerr = nla_parse_nested(tb, TCA_GACT_MAX, nla, gact_policy);\r\nif (err < 0)\r\nreturn err;\r\nif (tb[TCA_GACT_PARMS] == NULL)\r\nreturn -EINVAL;\r\nparm = nla_data(tb[TCA_GACT_PARMS]);\r\n#ifndef CONFIG_GACT_PROB\r\nif (tb[TCA_GACT_PROB] != NULL)\r\nreturn -EOPNOTSUPP;\r\n#else\r\nif (tb[TCA_GACT_PROB]) {\r\np_parm = nla_data(tb[TCA_GACT_PROB]);\r\nif (p_parm->ptype >= MAX_RAND)\r\nreturn -EINVAL;\r\n}\r\n#endif\r\nif (!tcf_hash_check(parm->index, a, bind)) {\r\nret = tcf_hash_create(parm->index, est, a, sizeof(*gact), bind);\r\nif (ret)\r\nreturn ret;\r\nret = ACT_P_CREATED;\r\n} else {\r\nif (bind)\r\nreturn 0;\r\ntcf_hash_release(a, bind);\r\nif (!ovr)\r\nreturn -EEXIST;\r\n}\r\ngact = to_gact(a);\r\nspin_lock_bh(&gact->tcf_lock);\r\ngact->tcf_action = parm->action;\r\n#ifdef CONFIG_GACT_PROB\r\nif (p_parm) {\r\ngact->tcfg_paction = p_parm->paction;\r\ngact->tcfg_pval = p_parm->pval;\r\ngact->tcfg_ptype = p_parm->ptype;\r\n}\r\n#endif\r\nspin_unlock_bh(&gact->tcf_lock);\r\nif (ret == ACT_P_CREATED)\r\ntcf_hash_insert(a);\r\nreturn ret;\r\n}\r\nstatic int tcf_gact(struct sk_buff *skb, const struct tc_action *a,\r\nstruct tcf_result *res)\r\n{\r\nstruct tcf_gact *gact = a->priv;\r\nint action = TC_ACT_SHOT;\r\nspin_lock(&gact->tcf_lock);\r\n#ifdef CONFIG_GACT_PROB\r\nif (gact->tcfg_ptype)\r\naction = gact_rand[gact->tcfg_ptype](gact);\r\nelse\r\naction = gact->tcf_action;\r\n#else\r\naction = gact->tcf_action;\r\n#endif\r\ngact->tcf_bstats.bytes += qdisc_pkt_len(skb);\r\ngact->tcf_bstats.packets++;\r\nif (action == TC_ACT_SHOT)\r\ngact->tcf_qstats.drops++;\r\ngact->tcf_tm.lastuse = jiffies;\r\nspin_unlock(&gact->tcf_lock);\r\nreturn action;\r\n}\r\nstatic int tcf_gact_dump(struct sk_buff *skb, struct tc_action *a, int bind, int ref)\r\n{\r\nunsigned char *b = skb_tail_pointer(skb);\r\nstruct tcf_gact *gact = a->priv;\r\nstruct tc_gact opt = {\r\n.index = gact->tcf_index,\r\n.refcnt = gact->tcf_refcnt - ref,\r\n.bindcnt = gact->tcf_bindcnt - bind,\r\n.action = gact->tcf_action,\r\n};\r\nstruct tcf_t t;\r\nif (nla_put(skb, TCA_GACT_PARMS, sizeof(opt), &opt))\r\ngoto nla_put_failure;\r\n#ifdef CONFIG_GACT_PROB\r\nif (gact->tcfg_ptype) {\r\nstruct tc_gact_p p_opt = {\r\n.paction = gact->tcfg_paction,\r\n.pval = gact->tcfg_pval,\r\n.ptype = gact->tcfg_ptype,\r\n};\r\nif (nla_put(skb, TCA_GACT_PROB, sizeof(p_opt), &p_opt))\r\ngoto nla_put_failure;\r\n}\r\n#endif\r\nt.install = jiffies_to_clock_t(jiffies - gact->tcf_tm.install);\r\nt.lastuse = jiffies_to_clock_t(jiffies - gact->tcf_tm.lastuse);\r\nt.expires = jiffies_to_clock_t(gact->tcf_tm.expires);\r\nif (nla_put(skb, TCA_GACT_TM, sizeof(t), &t))\r\ngoto nla_put_failure;\r\nreturn skb->len;\r\nnla_put_failure:\r\nnlmsg_trim(skb, b);\r\nreturn -1;\r\n}\r\nstatic int __init gact_init_module(void)\r\n{\r\n#ifdef CONFIG_GACT_PROB\r\npr_info("GACT probability on\n");\r\n#else\r\npr_info("GACT probability NOT on\n");\r\n#endif\r\nreturn tcf_register_action(&act_gact_ops, GACT_TAB_MASK);\r\n}\r\nstatic void __exit gact_cleanup_module(void)\r\n{\r\ntcf_unregister_action(&act_gact_ops);\r\n}
