static inline void i2s_write_reg(void __iomem *io_base, int reg, u32 val)\r\n{\r\nwritel(val, io_base + reg);\r\n}\r\nstatic inline u32 i2s_read_reg(void __iomem *io_base, int reg)\r\n{\r\nreturn readl(io_base + reg);\r\n}\r\nstatic inline void i2s_disable_channels(struct dw_i2s_dev *dev, u32 stream)\r\n{\r\nu32 i = 0;\r\nif (stream == SNDRV_PCM_STREAM_PLAYBACK) {\r\nfor (i = 0; i < 4; i++)\r\ni2s_write_reg(dev->i2s_base, TER(i), 0);\r\n} else {\r\nfor (i = 0; i < 4; i++)\r\ni2s_write_reg(dev->i2s_base, RER(i), 0);\r\n}\r\n}\r\nstatic inline void i2s_clear_irqs(struct dw_i2s_dev *dev, u32 stream)\r\n{\r\nu32 i = 0;\r\nif (stream == SNDRV_PCM_STREAM_PLAYBACK) {\r\nfor (i = 0; i < 4; i++)\r\ni2s_write_reg(dev->i2s_base, TOR(i), 0);\r\n} else {\r\nfor (i = 0; i < 4; i++)\r\ni2s_write_reg(dev->i2s_base, ROR(i), 0);\r\n}\r\n}\r\nstatic void i2s_start(struct dw_i2s_dev *dev,\r\nstruct snd_pcm_substream *substream)\r\n{\r\ni2s_write_reg(dev->i2s_base, IER, 1);\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\r\ni2s_write_reg(dev->i2s_base, ITER, 1);\r\nelse\r\ni2s_write_reg(dev->i2s_base, IRER, 1);\r\ni2s_write_reg(dev->i2s_base, CER, 1);\r\n}\r\nstatic void i2s_stop(struct dw_i2s_dev *dev,\r\nstruct snd_pcm_substream *substream)\r\n{\r\nu32 i = 0, irq;\r\ni2s_clear_irqs(dev, substream->stream);\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\r\ni2s_write_reg(dev->i2s_base, ITER, 0);\r\nfor (i = 0; i < 4; i++) {\r\nirq = i2s_read_reg(dev->i2s_base, IMR(i));\r\ni2s_write_reg(dev->i2s_base, IMR(i), irq | 0x30);\r\n}\r\n} else {\r\ni2s_write_reg(dev->i2s_base, IRER, 0);\r\nfor (i = 0; i < 4; i++) {\r\nirq = i2s_read_reg(dev->i2s_base, IMR(i));\r\ni2s_write_reg(dev->i2s_base, IMR(i), irq | 0x03);\r\n}\r\n}\r\nif (!dev->active) {\r\ni2s_write_reg(dev->i2s_base, CER, 0);\r\ni2s_write_reg(dev->i2s_base, IER, 0);\r\n}\r\n}\r\nstatic int dw_i2s_startup(struct snd_pcm_substream *substream,\r\nstruct snd_soc_dai *cpu_dai)\r\n{\r\nstruct dw_i2s_dev *dev = snd_soc_dai_get_drvdata(cpu_dai);\r\nunion dw_i2s_snd_dma_data *dma_data = NULL;\r\nif (!(dev->capability & DWC_I2S_RECORD) &&\r\n(substream->stream == SNDRV_PCM_STREAM_CAPTURE))\r\nreturn -EINVAL;\r\nif (!(dev->capability & DWC_I2S_PLAY) &&\r\n(substream->stream == SNDRV_PCM_STREAM_PLAYBACK))\r\nreturn -EINVAL;\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\r\ndma_data = &dev->play_dma_data;\r\nelse if (substream->stream == SNDRV_PCM_STREAM_CAPTURE)\r\ndma_data = &dev->capture_dma_data;\r\nsnd_soc_dai_set_dma_data(cpu_dai, substream, (void *)dma_data);\r\nreturn 0;\r\n}\r\nstatic int dw_i2s_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params, struct snd_soc_dai *dai)\r\n{\r\nstruct dw_i2s_dev *dev = snd_soc_dai_get_drvdata(dai);\r\nstruct i2s_clk_config_data *config = &dev->config;\r\nu32 ccr, xfer_resolution, ch_reg, irq;\r\nint ret;\r\nswitch (params_format(params)) {\r\ncase SNDRV_PCM_FORMAT_S16_LE:\r\nconfig->data_width = 16;\r\nccr = 0x00;\r\nxfer_resolution = 0x02;\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S24_LE:\r\nconfig->data_width = 24;\r\nccr = 0x08;\r\nxfer_resolution = 0x04;\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S32_LE:\r\nconfig->data_width = 32;\r\nccr = 0x10;\r\nxfer_resolution = 0x05;\r\nbreak;\r\ndefault:\r\ndev_err(dev->dev, "designware-i2s: unsuppted PCM fmt");\r\nreturn -EINVAL;\r\n}\r\nconfig->chan_nr = params_channels(params);\r\nswitch (config->chan_nr) {\r\ncase EIGHT_CHANNEL_SUPPORT:\r\ncase SIX_CHANNEL_SUPPORT:\r\ncase FOUR_CHANNEL_SUPPORT:\r\ncase TWO_CHANNEL_SUPPORT:\r\nbreak;\r\ndefault:\r\ndev_err(dev->dev, "channel not supported\n");\r\nreturn -EINVAL;\r\n}\r\ni2s_disable_channels(dev, substream->stream);\r\nfor (ch_reg = 0; ch_reg < (config->chan_nr / 2); ch_reg++) {\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\r\ni2s_write_reg(dev->i2s_base, TCR(ch_reg),\r\nxfer_resolution);\r\ni2s_write_reg(dev->i2s_base, TFCR(ch_reg), 0x02);\r\nirq = i2s_read_reg(dev->i2s_base, IMR(ch_reg));\r\ni2s_write_reg(dev->i2s_base, IMR(ch_reg), irq & ~0x30);\r\ni2s_write_reg(dev->i2s_base, TER(ch_reg), 1);\r\n} else {\r\ni2s_write_reg(dev->i2s_base, RCR(ch_reg),\r\nxfer_resolution);\r\ni2s_write_reg(dev->i2s_base, RFCR(ch_reg), 0x07);\r\nirq = i2s_read_reg(dev->i2s_base, IMR(ch_reg));\r\ni2s_write_reg(dev->i2s_base, IMR(ch_reg), irq & ~0x03);\r\ni2s_write_reg(dev->i2s_base, RER(ch_reg), 1);\r\n}\r\n}\r\ni2s_write_reg(dev->i2s_base, CCR, ccr);\r\nconfig->sample_rate = params_rate(params);\r\nif (dev->i2s_clk_cfg) {\r\nret = dev->i2s_clk_cfg(config);\r\nif (ret < 0) {\r\ndev_err(dev->dev, "runtime audio clk config fail\n");\r\nreturn ret;\r\n}\r\n} else {\r\nu32 bitclk = config->sample_rate * config->data_width * 2;\r\nret = clk_set_rate(dev->clk, bitclk);\r\nif (ret) {\r\ndev_err(dev->dev, "Can't set I2S clock rate: %d\n",\r\nret);\r\nreturn ret;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void dw_i2s_shutdown(struct snd_pcm_substream *substream,\r\nstruct snd_soc_dai *dai)\r\n{\r\nsnd_soc_dai_set_dma_data(dai, substream, NULL);\r\n}\r\nstatic int dw_i2s_prepare(struct snd_pcm_substream *substream,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct dw_i2s_dev *dev = snd_soc_dai_get_drvdata(dai);\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\r\ni2s_write_reg(dev->i2s_base, TXFFR, 1);\r\nelse\r\ni2s_write_reg(dev->i2s_base, RXFFR, 1);\r\nreturn 0;\r\n}\r\nstatic int dw_i2s_trigger(struct snd_pcm_substream *substream,\r\nint cmd, struct snd_soc_dai *dai)\r\n{\r\nstruct dw_i2s_dev *dev = snd_soc_dai_get_drvdata(dai);\r\nint ret = 0;\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\ncase SNDRV_PCM_TRIGGER_RESUME:\r\ncase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\r\ndev->active++;\r\ni2s_start(dev, substream);\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\ncase SNDRV_PCM_TRIGGER_SUSPEND:\r\ncase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\r\ndev->active--;\r\ni2s_stop(dev, substream);\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int dw_i2s_suspend(struct snd_soc_dai *dai)\r\n{\r\nstruct dw_i2s_dev *dev = snd_soc_dai_get_drvdata(dai);\r\nclk_disable(dev->clk);\r\nreturn 0;\r\n}\r\nstatic int dw_i2s_resume(struct snd_soc_dai *dai)\r\n{\r\nstruct dw_i2s_dev *dev = snd_soc_dai_get_drvdata(dai);\r\nclk_enable(dev->clk);\r\nreturn 0;\r\n}\r\nstatic int dw_configure_dai(struct dw_i2s_dev *dev,\r\nstruct snd_soc_dai_driver *dw_i2s_dai,\r\nunsigned int rates)\r\n{\r\nu32 comp1 = i2s_read_reg(dev->i2s_base, I2S_COMP_PARAM_1);\r\nu32 comp2 = i2s_read_reg(dev->i2s_base, I2S_COMP_PARAM_2);\r\nu32 idx;\r\nif (COMP1_TX_ENABLED(comp1)) {\r\ndev_dbg(dev->dev, " designware: play supported\n");\r\nidx = COMP1_TX_WORDSIZE_0(comp1);\r\nif (WARN_ON(idx >= ARRAY_SIZE(formats)))\r\nreturn -EINVAL;\r\ndw_i2s_dai->playback.channels_min = MIN_CHANNEL_NUM;\r\ndw_i2s_dai->playback.channels_max =\r\n1 << (COMP1_TX_CHANNELS(comp1) + 1);\r\ndw_i2s_dai->playback.formats = formats[idx];\r\ndw_i2s_dai->playback.rates = rates;\r\n}\r\nif (COMP1_RX_ENABLED(comp1)) {\r\ndev_dbg(dev->dev, "designware: record supported\n");\r\nidx = COMP2_RX_WORDSIZE_0(comp2);\r\nif (WARN_ON(idx >= ARRAY_SIZE(formats)))\r\nreturn -EINVAL;\r\ndw_i2s_dai->capture.channels_min = MIN_CHANNEL_NUM;\r\ndw_i2s_dai->capture.channels_max =\r\n1 << (COMP1_RX_CHANNELS(comp1) + 1);\r\ndw_i2s_dai->capture.formats = formats[idx];\r\ndw_i2s_dai->capture.rates = rates;\r\n}\r\nreturn 0;\r\n}\r\nstatic int dw_configure_dai_by_pd(struct dw_i2s_dev *dev,\r\nstruct snd_soc_dai_driver *dw_i2s_dai,\r\nstruct resource *res,\r\nconst struct i2s_platform_data *pdata)\r\n{\r\nu32 comp1 = i2s_read_reg(dev->i2s_base, I2S_COMP_PARAM_1);\r\nu32 idx = COMP1_APB_DATA_WIDTH(comp1);\r\nint ret;\r\nif (WARN_ON(idx >= ARRAY_SIZE(bus_widths)))\r\nreturn -EINVAL;\r\nret = dw_configure_dai(dev, dw_i2s_dai, pdata->snd_rates);\r\nif (ret < 0)\r\nreturn ret;\r\ndev->play_dma_data.pd.data = pdata->play_dma_data;\r\ndev->capture_dma_data.pd.data = pdata->capture_dma_data;\r\ndev->play_dma_data.pd.addr = res->start + I2S_TXDMA;\r\ndev->capture_dma_data.pd.addr = res->start + I2S_RXDMA;\r\ndev->play_dma_data.pd.max_burst = 16;\r\ndev->capture_dma_data.pd.max_burst = 16;\r\ndev->play_dma_data.pd.addr_width = bus_widths[idx];\r\ndev->capture_dma_data.pd.addr_width = bus_widths[idx];\r\ndev->play_dma_data.pd.filter = pdata->filter;\r\ndev->capture_dma_data.pd.filter = pdata->filter;\r\nreturn 0;\r\n}\r\nstatic int dw_configure_dai_by_dt(struct dw_i2s_dev *dev,\r\nstruct snd_soc_dai_driver *dw_i2s_dai,\r\nstruct resource *res)\r\n{\r\nu32 comp1 = i2s_read_reg(dev->i2s_base, I2S_COMP_PARAM_1);\r\nu32 comp2 = i2s_read_reg(dev->i2s_base, I2S_COMP_PARAM_2);\r\nu32 fifo_depth = 1 << (1 + COMP1_FIFO_DEPTH_GLOBAL(comp1));\r\nu32 idx = COMP1_APB_DATA_WIDTH(comp1);\r\nu32 idx2;\r\nint ret;\r\nif (WARN_ON(idx >= ARRAY_SIZE(bus_widths)))\r\nreturn -EINVAL;\r\nret = dw_configure_dai(dev, dw_i2s_dai, SNDRV_PCM_RATE_8000_192000);\r\nif (ret < 0)\r\nreturn ret;\r\nif (COMP1_TX_ENABLED(comp1)) {\r\nidx2 = COMP1_TX_WORDSIZE_0(comp1);\r\ndev->capability |= DWC_I2S_PLAY;\r\ndev->play_dma_data.dt.addr = res->start + I2S_TXDMA;\r\ndev->play_dma_data.dt.addr_width = bus_widths[idx];\r\ndev->play_dma_data.dt.chan_name = "TX";\r\ndev->play_dma_data.dt.fifo_size = fifo_depth *\r\n(fifo_width[idx2]) >> 8;\r\ndev->play_dma_data.dt.maxburst = 16;\r\n}\r\nif (COMP1_RX_ENABLED(comp1)) {\r\nidx2 = COMP2_RX_WORDSIZE_0(comp2);\r\ndev->capability |= DWC_I2S_RECORD;\r\ndev->capture_dma_data.dt.addr = res->start + I2S_RXDMA;\r\ndev->capture_dma_data.dt.addr_width = bus_widths[idx];\r\ndev->capture_dma_data.dt.chan_name = "RX";\r\ndev->capture_dma_data.dt.fifo_size = fifo_depth *\r\n(fifo_width[idx2] >> 8);\r\ndev->capture_dma_data.dt.maxburst = 16;\r\n}\r\nreturn 0;\r\n}\r\nstatic int dw_i2s_probe(struct platform_device *pdev)\r\n{\r\nconst struct i2s_platform_data *pdata = pdev->dev.platform_data;\r\nstruct dw_i2s_dev *dev;\r\nstruct resource *res;\r\nint ret;\r\nstruct snd_soc_dai_driver *dw_i2s_dai;\r\ndev = devm_kzalloc(&pdev->dev, sizeof(*dev), GFP_KERNEL);\r\nif (!dev) {\r\ndev_warn(&pdev->dev, "kzalloc fail\n");\r\nreturn -ENOMEM;\r\n}\r\ndw_i2s_dai = devm_kzalloc(&pdev->dev, sizeof(*dw_i2s_dai), GFP_KERNEL);\r\nif (!dw_i2s_dai)\r\nreturn -ENOMEM;\r\ndw_i2s_dai->ops = &dw_i2s_dai_ops;\r\ndw_i2s_dai->suspend = dw_i2s_suspend;\r\ndw_i2s_dai->resume = dw_i2s_resume;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\ndev->i2s_base = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(dev->i2s_base))\r\nreturn PTR_ERR(dev->i2s_base);\r\ndev->dev = &pdev->dev;\r\nif (pdata) {\r\nret = dw_configure_dai_by_pd(dev, dw_i2s_dai, res, pdata);\r\nif (ret < 0)\r\nreturn ret;\r\ndev->capability = pdata->cap;\r\ndev->i2s_clk_cfg = pdata->i2s_clk_cfg;\r\nif (!dev->i2s_clk_cfg) {\r\ndev_err(&pdev->dev, "no clock configure method\n");\r\nreturn -ENODEV;\r\n}\r\ndev->clk = devm_clk_get(&pdev->dev, NULL);\r\n} else {\r\nret = dw_configure_dai_by_dt(dev, dw_i2s_dai, res);\r\nif (ret < 0)\r\nreturn ret;\r\ndev->clk = devm_clk_get(&pdev->dev, "i2sclk");\r\n}\r\nif (IS_ERR(dev->clk))\r\nreturn PTR_ERR(dev->clk);\r\nret = clk_prepare_enable(dev->clk);\r\nif (ret < 0)\r\nreturn ret;\r\ndev_set_drvdata(&pdev->dev, dev);\r\nret = devm_snd_soc_register_component(&pdev->dev, &dw_i2s_component,\r\ndw_i2s_dai, 1);\r\nif (ret != 0) {\r\ndev_err(&pdev->dev, "not able to register dai\n");\r\ngoto err_clk_disable;\r\n}\r\nif (!pdata) {\r\nret = devm_snd_dmaengine_pcm_register(&pdev->dev, NULL, 0);\r\nif (ret) {\r\ndev_err(&pdev->dev,\r\n"Could not register PCM: %d\n", ret);\r\ngoto err_clk_disable;\r\n}\r\n}\r\nreturn 0;\r\nerr_clk_disable:\r\nclk_disable_unprepare(dev->clk);\r\nreturn ret;\r\n}\r\nstatic int dw_i2s_remove(struct platform_device *pdev)\r\n{\r\nstruct dw_i2s_dev *dev = dev_get_drvdata(&pdev->dev);\r\nclk_disable_unprepare(dev->clk);\r\nreturn 0;\r\n}
