static int c2_query_device(struct ib_device *ibdev,\r\nstruct ib_device_attr *props)\r\n{\r\nstruct c2_dev *c2dev = to_c2dev(ibdev);\r\npr_debug("%s:%u\n", __func__, __LINE__);\r\n*props = c2dev->props;\r\nreturn 0;\r\n}\r\nstatic int c2_query_port(struct ib_device *ibdev,\r\nu8 port, struct ib_port_attr *props)\r\n{\r\npr_debug("%s:%u\n", __func__, __LINE__);\r\nprops->max_mtu = IB_MTU_4096;\r\nprops->lid = 0;\r\nprops->lmc = 0;\r\nprops->sm_lid = 0;\r\nprops->sm_sl = 0;\r\nprops->state = IB_PORT_ACTIVE;\r\nprops->phys_state = 0;\r\nprops->port_cap_flags =\r\nIB_PORT_CM_SUP |\r\nIB_PORT_REINIT_SUP |\r\nIB_PORT_VENDOR_CLASS_SUP | IB_PORT_BOOT_MGMT_SUP;\r\nprops->gid_tbl_len = 1;\r\nprops->pkey_tbl_len = 1;\r\nprops->qkey_viol_cntr = 0;\r\nprops->active_width = 1;\r\nprops->active_speed = IB_SPEED_SDR;\r\nreturn 0;\r\n}\r\nstatic int c2_query_pkey(struct ib_device *ibdev,\r\nu8 port, u16 index, u16 * pkey)\r\n{\r\npr_debug("%s:%u\n", __func__, __LINE__);\r\n*pkey = 0;\r\nreturn 0;\r\n}\r\nstatic int c2_query_gid(struct ib_device *ibdev, u8 port,\r\nint index, union ib_gid *gid)\r\n{\r\nstruct c2_dev *c2dev = to_c2dev(ibdev);\r\npr_debug("%s:%u\n", __func__, __LINE__);\r\nmemset(&(gid->raw[0]), 0, sizeof(gid->raw));\r\nmemcpy(&(gid->raw[0]), c2dev->pseudo_netdev->dev_addr, 6);\r\nreturn 0;\r\n}\r\nstatic struct ib_ucontext *c2_alloc_ucontext(struct ib_device *ibdev,\r\nstruct ib_udata *udata)\r\n{\r\nstruct c2_ucontext *context;\r\npr_debug("%s:%u\n", __func__, __LINE__);\r\ncontext = kmalloc(sizeof(*context), GFP_KERNEL);\r\nif (!context)\r\nreturn ERR_PTR(-ENOMEM);\r\nreturn &context->ibucontext;\r\n}\r\nstatic int c2_dealloc_ucontext(struct ib_ucontext *context)\r\n{\r\npr_debug("%s:%u\n", __func__, __LINE__);\r\nkfree(context);\r\nreturn 0;\r\n}\r\nstatic int c2_mmap_uar(struct ib_ucontext *context, struct vm_area_struct *vma)\r\n{\r\npr_debug("%s:%u\n", __func__, __LINE__);\r\nreturn -ENOSYS;\r\n}\r\nstatic struct ib_pd *c2_alloc_pd(struct ib_device *ibdev,\r\nstruct ib_ucontext *context,\r\nstruct ib_udata *udata)\r\n{\r\nstruct c2_pd *pd;\r\nint err;\r\npr_debug("%s:%u\n", __func__, __LINE__);\r\npd = kmalloc(sizeof(*pd), GFP_KERNEL);\r\nif (!pd)\r\nreturn ERR_PTR(-ENOMEM);\r\nerr = c2_pd_alloc(to_c2dev(ibdev), !context, pd);\r\nif (err) {\r\nkfree(pd);\r\nreturn ERR_PTR(err);\r\n}\r\nif (context) {\r\nif (ib_copy_to_udata(udata, &pd->pd_id, sizeof(__u32))) {\r\nc2_pd_free(to_c2dev(ibdev), pd);\r\nkfree(pd);\r\nreturn ERR_PTR(-EFAULT);\r\n}\r\n}\r\nreturn &pd->ibpd;\r\n}\r\nstatic int c2_dealloc_pd(struct ib_pd *pd)\r\n{\r\npr_debug("%s:%u\n", __func__, __LINE__);\r\nc2_pd_free(to_c2dev(pd->device), to_c2pd(pd));\r\nkfree(pd);\r\nreturn 0;\r\n}\r\nstatic struct ib_ah *c2_ah_create(struct ib_pd *pd, struct ib_ah_attr *ah_attr)\r\n{\r\npr_debug("%s:%u\n", __func__, __LINE__);\r\nreturn ERR_PTR(-ENOSYS);\r\n}\r\nstatic int c2_ah_destroy(struct ib_ah *ah)\r\n{\r\npr_debug("%s:%u\n", __func__, __LINE__);\r\nreturn -ENOSYS;\r\n}\r\nstatic void c2_add_ref(struct ib_qp *ibqp)\r\n{\r\nstruct c2_qp *qp;\r\nBUG_ON(!ibqp);\r\nqp = to_c2qp(ibqp);\r\natomic_inc(&qp->refcount);\r\n}\r\nstatic void c2_rem_ref(struct ib_qp *ibqp)\r\n{\r\nstruct c2_qp *qp;\r\nBUG_ON(!ibqp);\r\nqp = to_c2qp(ibqp);\r\nif (atomic_dec_and_test(&qp->refcount))\r\nwake_up(&qp->wait);\r\n}\r\nstruct ib_qp *c2_get_qp(struct ib_device *device, int qpn)\r\n{\r\nstruct c2_dev* c2dev = to_c2dev(device);\r\nstruct c2_qp *qp;\r\nqp = c2_find_qpn(c2dev, qpn);\r\npr_debug("%s Returning QP=%p for QPN=%d, device=%p, refcount=%d\n",\r\n__func__, qp, qpn, device,\r\n(qp?atomic_read(&qp->refcount):0));\r\nreturn (qp?&qp->ibqp:NULL);\r\n}\r\nstatic struct ib_qp *c2_create_qp(struct ib_pd *pd,\r\nstruct ib_qp_init_attr *init_attr,\r\nstruct ib_udata *udata)\r\n{\r\nstruct c2_qp *qp;\r\nint err;\r\npr_debug("%s:%u\n", __func__, __LINE__);\r\nif (init_attr->create_flags)\r\nreturn ERR_PTR(-EINVAL);\r\nswitch (init_attr->qp_type) {\r\ncase IB_QPT_RC:\r\nqp = kzalloc(sizeof(*qp), GFP_KERNEL);\r\nif (!qp) {\r\npr_debug("%s: Unable to allocate QP\n", __func__);\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nspin_lock_init(&qp->lock);\r\nif (pd->uobject) {\r\n}\r\nerr = c2_alloc_qp(to_c2dev(pd->device),\r\nto_c2pd(pd), init_attr, qp);\r\nif (err && pd->uobject) {\r\n}\r\nbreak;\r\ndefault:\r\npr_debug("%s: Invalid QP type: %d\n", __func__,\r\ninit_attr->qp_type);\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nif (err) {\r\nkfree(qp);\r\nreturn ERR_PTR(err);\r\n}\r\nreturn &qp->ibqp;\r\n}\r\nstatic int c2_destroy_qp(struct ib_qp *ib_qp)\r\n{\r\nstruct c2_qp *qp = to_c2qp(ib_qp);\r\npr_debug("%s:%u qp=%p,qp->state=%d\n",\r\n__func__, __LINE__, ib_qp, qp->state);\r\nc2_free_qp(to_c2dev(ib_qp->device), qp);\r\nkfree(qp);\r\nreturn 0;\r\n}\r\nstatic struct ib_cq *c2_create_cq(struct ib_device *ibdev, int entries, int vector,\r\nstruct ib_ucontext *context,\r\nstruct ib_udata *udata)\r\n{\r\nstruct c2_cq *cq;\r\nint err;\r\ncq = kmalloc(sizeof(*cq), GFP_KERNEL);\r\nif (!cq) {\r\npr_debug("%s: Unable to allocate CQ\n", __func__);\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nerr = c2_init_cq(to_c2dev(ibdev), entries, NULL, cq);\r\nif (err) {\r\npr_debug("%s: error initializing CQ\n", __func__);\r\nkfree(cq);\r\nreturn ERR_PTR(err);\r\n}\r\nreturn &cq->ibcq;\r\n}\r\nstatic int c2_destroy_cq(struct ib_cq *ib_cq)\r\n{\r\nstruct c2_cq *cq = to_c2cq(ib_cq);\r\npr_debug("%s:%u\n", __func__, __LINE__);\r\nc2_free_cq(to_c2dev(ib_cq->device), cq);\r\nkfree(cq);\r\nreturn 0;\r\n}\r\nstatic inline u32 c2_convert_access(int acc)\r\n{\r\nreturn (acc & IB_ACCESS_REMOTE_WRITE ? C2_ACF_REMOTE_WRITE : 0) |\r\n(acc & IB_ACCESS_REMOTE_READ ? C2_ACF_REMOTE_READ : 0) |\r\n(acc & IB_ACCESS_LOCAL_WRITE ? C2_ACF_LOCAL_WRITE : 0) |\r\nC2_ACF_LOCAL_READ | C2_ACF_WINDOW_BIND;\r\n}\r\nstatic struct ib_mr *c2_reg_phys_mr(struct ib_pd *ib_pd,\r\nstruct ib_phys_buf *buffer_list,\r\nint num_phys_buf, int acc, u64 * iova_start)\r\n{\r\nstruct c2_mr *mr;\r\nu64 *page_list;\r\nu32 total_len;\r\nint err, i, j, k, page_shift, pbl_depth;\r\npbl_depth = 0;\r\ntotal_len = 0;\r\npage_shift = PAGE_SHIFT;\r\nif (num_phys_buf == 1)\r\npage_shift += 3;\r\nfor (i = 0; i < num_phys_buf; i++) {\r\nif (buffer_list[i].addr & ~PAGE_MASK) {\r\npr_debug("Unaligned Memory Buffer: 0x%x\n",\r\n(unsigned int) buffer_list[i].addr);\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nif (!buffer_list[i].size) {\r\npr_debug("Invalid Buffer Size\n");\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\ntotal_len += buffer_list[i].size;\r\npbl_depth += ALIGN(buffer_list[i].size,\r\n(1 << page_shift)) >> page_shift;\r\n}\r\npage_list = vmalloc(sizeof(u64) * pbl_depth);\r\nif (!page_list) {\r\npr_debug("couldn't vmalloc page_list of size %zd\n",\r\n(sizeof(u64) * pbl_depth));\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nfor (i = 0, j = 0; i < num_phys_buf; i++) {\r\nint naddrs;\r\nnaddrs = ALIGN(buffer_list[i].size,\r\n(1 << page_shift)) >> page_shift;\r\nfor (k = 0; k < naddrs; k++)\r\npage_list[j++] = (buffer_list[i].addr +\r\n(k << page_shift));\r\n}\r\nmr = kmalloc(sizeof(*mr), GFP_KERNEL);\r\nif (!mr) {\r\nvfree(page_list);\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nmr->pd = to_c2pd(ib_pd);\r\nmr->umem = NULL;\r\npr_debug("%s - page shift %d, pbl_depth %d, total_len %u, "\r\n"*iova_start %llx, first pa %llx, last pa %llx\n",\r\n__func__, page_shift, pbl_depth, total_len,\r\n(unsigned long long) *iova_start,\r\n(unsigned long long) page_list[0],\r\n(unsigned long long) page_list[pbl_depth-1]);\r\nerr = c2_nsmr_register_phys_kern(to_c2dev(ib_pd->device), page_list,\r\n(1 << page_shift), pbl_depth,\r\ntotal_len, 0, iova_start,\r\nc2_convert_access(acc), mr);\r\nvfree(page_list);\r\nif (err) {\r\nkfree(mr);\r\nreturn ERR_PTR(err);\r\n}\r\nreturn &mr->ibmr;\r\n}\r\nstatic struct ib_mr *c2_get_dma_mr(struct ib_pd *pd, int acc)\r\n{\r\nstruct ib_phys_buf bl;\r\nu64 kva = 0;\r\npr_debug("%s:%u\n", __func__, __LINE__);\r\nbl.size = 0xffffffff;\r\nbl.addr = 0;\r\nreturn c2_reg_phys_mr(pd, &bl, 1, acc, &kva);\r\n}\r\nstatic struct ib_mr *c2_reg_user_mr(struct ib_pd *pd, u64 start, u64 length,\r\nu64 virt, int acc, struct ib_udata *udata)\r\n{\r\nu64 *pages;\r\nu64 kva = 0;\r\nint shift, n, len;\r\nint i, k, entry;\r\nint err = 0;\r\nstruct scatterlist *sg;\r\nstruct c2_pd *c2pd = to_c2pd(pd);\r\nstruct c2_mr *c2mr;\r\npr_debug("%s:%u\n", __func__, __LINE__);\r\nc2mr = kmalloc(sizeof(*c2mr), GFP_KERNEL);\r\nif (!c2mr)\r\nreturn ERR_PTR(-ENOMEM);\r\nc2mr->pd = c2pd;\r\nc2mr->umem = ib_umem_get(pd->uobject->context, start, length, acc, 0);\r\nif (IS_ERR(c2mr->umem)) {\r\nerr = PTR_ERR(c2mr->umem);\r\nkfree(c2mr);\r\nreturn ERR_PTR(err);\r\n}\r\nshift = ffs(c2mr->umem->page_size) - 1;\r\nn = c2mr->umem->nmap;\r\npages = kmalloc(n * sizeof(u64), GFP_KERNEL);\r\nif (!pages) {\r\nerr = -ENOMEM;\r\ngoto err;\r\n}\r\ni = 0;\r\nfor_each_sg(c2mr->umem->sg_head.sgl, sg, c2mr->umem->nmap, entry) {\r\nlen = sg_dma_len(sg) >> shift;\r\nfor (k = 0; k < len; ++k) {\r\npages[i++] =\r\nsg_dma_address(sg) +\r\n(c2mr->umem->page_size * k);\r\n}\r\n}\r\nkva = virt;\r\nerr = c2_nsmr_register_phys_kern(to_c2dev(pd->device),\r\npages,\r\nc2mr->umem->page_size,\r\ni,\r\nlength,\r\nib_umem_offset(c2mr->umem),\r\n&kva,\r\nc2_convert_access(acc),\r\nc2mr);\r\nkfree(pages);\r\nif (err)\r\ngoto err;\r\nreturn &c2mr->ibmr;\r\nerr:\r\nib_umem_release(c2mr->umem);\r\nkfree(c2mr);\r\nreturn ERR_PTR(err);\r\n}\r\nstatic int c2_dereg_mr(struct ib_mr *ib_mr)\r\n{\r\nstruct c2_mr *mr = to_c2mr(ib_mr);\r\nint err;\r\npr_debug("%s:%u\n", __func__, __LINE__);\r\nerr = c2_stag_dealloc(to_c2dev(ib_mr->device), ib_mr->lkey);\r\nif (err)\r\npr_debug("c2_stag_dealloc failed: %d\n", err);\r\nelse {\r\nif (mr->umem)\r\nib_umem_release(mr->umem);\r\nkfree(mr);\r\n}\r\nreturn err;\r\n}\r\nstatic ssize_t show_rev(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct c2_dev *c2dev = container_of(dev, struct c2_dev, ibdev.dev);\r\npr_debug("%s:%u\n", __func__, __LINE__);\r\nreturn sprintf(buf, "%x\n", c2dev->props.hw_ver);\r\n}\r\nstatic ssize_t show_fw_ver(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct c2_dev *c2dev = container_of(dev, struct c2_dev, ibdev.dev);\r\npr_debug("%s:%u\n", __func__, __LINE__);\r\nreturn sprintf(buf, "%x.%x.%x\n",\r\n(int) (c2dev->props.fw_ver >> 32),\r\n(int) (c2dev->props.fw_ver >> 16) & 0xffff,\r\n(int) (c2dev->props.fw_ver & 0xffff));\r\n}\r\nstatic ssize_t show_hca(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\npr_debug("%s:%u\n", __func__, __LINE__);\r\nreturn sprintf(buf, "AMSO1100\n");\r\n}\r\nstatic ssize_t show_board(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\npr_debug("%s:%u\n", __func__, __LINE__);\r\nreturn sprintf(buf, "%.*s\n", 32, "AMSO1100 Board ID");\r\n}\r\nstatic int c2_modify_qp(struct ib_qp *ibqp, struct ib_qp_attr *attr,\r\nint attr_mask, struct ib_udata *udata)\r\n{\r\nint err;\r\nerr =\r\nc2_qp_modify(to_c2dev(ibqp->device), to_c2qp(ibqp), attr,\r\nattr_mask);\r\nreturn err;\r\n}\r\nstatic int c2_multicast_attach(struct ib_qp *ibqp, union ib_gid *gid, u16 lid)\r\n{\r\npr_debug("%s:%u\n", __func__, __LINE__);\r\nreturn -ENOSYS;\r\n}\r\nstatic int c2_multicast_detach(struct ib_qp *ibqp, union ib_gid *gid, u16 lid)\r\n{\r\npr_debug("%s:%u\n", __func__, __LINE__);\r\nreturn -ENOSYS;\r\n}\r\nstatic int c2_process_mad(struct ib_device *ibdev,\r\nint mad_flags,\r\nu8 port_num,\r\nstruct ib_wc *in_wc,\r\nstruct ib_grh *in_grh,\r\nstruct ib_mad *in_mad, struct ib_mad *out_mad)\r\n{\r\npr_debug("%s:%u\n", __func__, __LINE__);\r\nreturn -ENOSYS;\r\n}\r\nstatic int c2_connect(struct iw_cm_id *cm_id, struct iw_cm_conn_param *iw_param)\r\n{\r\npr_debug("%s:%u\n", __func__, __LINE__);\r\nreturn c2_llp_connect(cm_id, iw_param);\r\n}\r\nstatic int c2_accept(struct iw_cm_id *cm_id, struct iw_cm_conn_param *iw_param)\r\n{\r\npr_debug("%s:%u\n", __func__, __LINE__);\r\nreturn c2_llp_accept(cm_id, iw_param);\r\n}\r\nstatic int c2_reject(struct iw_cm_id *cm_id, const void *pdata, u8 pdata_len)\r\n{\r\nint err;\r\npr_debug("%s:%u\n", __func__, __LINE__);\r\nerr = c2_llp_reject(cm_id, pdata, pdata_len);\r\nreturn err;\r\n}\r\nstatic int c2_service_create(struct iw_cm_id *cm_id, int backlog)\r\n{\r\nint err;\r\npr_debug("%s:%u\n", __func__, __LINE__);\r\nerr = c2_llp_service_create(cm_id, backlog);\r\npr_debug("%s:%u err=%d\n",\r\n__func__, __LINE__,\r\nerr);\r\nreturn err;\r\n}\r\nstatic int c2_service_destroy(struct iw_cm_id *cm_id)\r\n{\r\nint err;\r\npr_debug("%s:%u\n", __func__, __LINE__);\r\nerr = c2_llp_service_destroy(cm_id);\r\nreturn err;\r\n}\r\nstatic int c2_pseudo_up(struct net_device *netdev)\r\n{\r\nstruct in_device *ind;\r\nstruct c2_dev *c2dev = netdev->ml_priv;\r\nind = in_dev_get(netdev);\r\nif (!ind)\r\nreturn 0;\r\npr_debug("adding...\n");\r\nfor_ifa(ind) {\r\n#ifdef DEBUG\r\nu8 *ip = (u8 *) & ifa->ifa_address;\r\npr_debug("%s: %d.%d.%d.%d\n",\r\nifa->ifa_label, ip[0], ip[1], ip[2], ip[3]);\r\n#endif\r\nc2_add_addr(c2dev, ifa->ifa_address, ifa->ifa_mask);\r\n}\r\nendfor_ifa(ind);\r\nin_dev_put(ind);\r\nreturn 0;\r\n}\r\nstatic int c2_pseudo_down(struct net_device *netdev)\r\n{\r\nstruct in_device *ind;\r\nstruct c2_dev *c2dev = netdev->ml_priv;\r\nind = in_dev_get(netdev);\r\nif (!ind)\r\nreturn 0;\r\npr_debug("deleting...\n");\r\nfor_ifa(ind) {\r\n#ifdef DEBUG\r\nu8 *ip = (u8 *) & ifa->ifa_address;\r\npr_debug("%s: %d.%d.%d.%d\n",\r\nifa->ifa_label, ip[0], ip[1], ip[2], ip[3]);\r\n#endif\r\nc2_del_addr(c2dev, ifa->ifa_address, ifa->ifa_mask);\r\n}\r\nendfor_ifa(ind);\r\nin_dev_put(ind);\r\nreturn 0;\r\n}\r\nstatic int c2_pseudo_xmit_frame(struct sk_buff *skb, struct net_device *netdev)\r\n{\r\nkfree_skb(skb);\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic int c2_pseudo_change_mtu(struct net_device *netdev, int new_mtu)\r\n{\r\nif (new_mtu < ETH_ZLEN || new_mtu > ETH_JUMBO_MTU)\r\nreturn -EINVAL;\r\nnetdev->mtu = new_mtu;\r\nreturn 0;\r\n}\r\nstatic void setup(struct net_device *netdev)\r\n{\r\nnetdev->netdev_ops = &c2_pseudo_netdev_ops;\r\nnetdev->watchdog_timeo = 0;\r\nnetdev->type = ARPHRD_ETHER;\r\nnetdev->mtu = 1500;\r\nnetdev->hard_header_len = ETH_HLEN;\r\nnetdev->addr_len = ETH_ALEN;\r\nnetdev->tx_queue_len = 0;\r\nnetdev->flags |= IFF_NOARP;\r\n}\r\nstatic struct net_device *c2_pseudo_netdev_init(struct c2_dev *c2dev)\r\n{\r\nchar name[IFNAMSIZ];\r\nstruct net_device *netdev;\r\nstrcpy(name, "iw");\r\nstrcat(name, &c2dev->netdev->name[3]);\r\nnetdev = alloc_netdev(0, name, NET_NAME_UNKNOWN, setup);\r\nif (!netdev) {\r\nprintk(KERN_ERR PFX "%s - etherdev alloc failed",\r\n__func__);\r\nreturn NULL;\r\n}\r\nnetdev->ml_priv = c2dev;\r\nSET_NETDEV_DEV(netdev, &c2dev->pcidev->dev);\r\nmemcpy_fromio(netdev->dev_addr, c2dev->kva + C2_REGS_RDMA_ENADDR, 6);\r\npr_debug("%s: MAC %pM\n", netdev->name, netdev->dev_addr);\r\n#if 0\r\nnetif_stop_queue(netdev);\r\n#endif\r\nreturn netdev;\r\n}\r\nint c2_register_device(struct c2_dev *dev)\r\n{\r\nint ret = -ENOMEM;\r\nint i;\r\ndev->pseudo_netdev = c2_pseudo_netdev_init(dev);\r\nif (!dev->pseudo_netdev)\r\ngoto out;\r\nret = register_netdev(dev->pseudo_netdev);\r\nif (ret)\r\ngoto out_free_netdev;\r\npr_debug("%s:%u\n", __func__, __LINE__);\r\nstrlcpy(dev->ibdev.name, "amso%d", IB_DEVICE_NAME_MAX);\r\ndev->ibdev.owner = THIS_MODULE;\r\ndev->ibdev.uverbs_cmd_mask =\r\n(1ull << IB_USER_VERBS_CMD_GET_CONTEXT) |\r\n(1ull << IB_USER_VERBS_CMD_QUERY_DEVICE) |\r\n(1ull << IB_USER_VERBS_CMD_QUERY_PORT) |\r\n(1ull << IB_USER_VERBS_CMD_ALLOC_PD) |\r\n(1ull << IB_USER_VERBS_CMD_DEALLOC_PD) |\r\n(1ull << IB_USER_VERBS_CMD_REG_MR) |\r\n(1ull << IB_USER_VERBS_CMD_DEREG_MR) |\r\n(1ull << IB_USER_VERBS_CMD_CREATE_COMP_CHANNEL) |\r\n(1ull << IB_USER_VERBS_CMD_CREATE_CQ) |\r\n(1ull << IB_USER_VERBS_CMD_DESTROY_CQ) |\r\n(1ull << IB_USER_VERBS_CMD_REQ_NOTIFY_CQ) |\r\n(1ull << IB_USER_VERBS_CMD_CREATE_QP) |\r\n(1ull << IB_USER_VERBS_CMD_MODIFY_QP) |\r\n(1ull << IB_USER_VERBS_CMD_POLL_CQ) |\r\n(1ull << IB_USER_VERBS_CMD_DESTROY_QP) |\r\n(1ull << IB_USER_VERBS_CMD_POST_SEND) |\r\n(1ull << IB_USER_VERBS_CMD_POST_RECV);\r\ndev->ibdev.node_type = RDMA_NODE_RNIC;\r\nmemset(&dev->ibdev.node_guid, 0, sizeof(dev->ibdev.node_guid));\r\nmemcpy(&dev->ibdev.node_guid, dev->pseudo_netdev->dev_addr, 6);\r\ndev->ibdev.phys_port_cnt = 1;\r\ndev->ibdev.num_comp_vectors = 1;\r\ndev->ibdev.dma_device = &dev->pcidev->dev;\r\ndev->ibdev.query_device = c2_query_device;\r\ndev->ibdev.query_port = c2_query_port;\r\ndev->ibdev.query_pkey = c2_query_pkey;\r\ndev->ibdev.query_gid = c2_query_gid;\r\ndev->ibdev.alloc_ucontext = c2_alloc_ucontext;\r\ndev->ibdev.dealloc_ucontext = c2_dealloc_ucontext;\r\ndev->ibdev.mmap = c2_mmap_uar;\r\ndev->ibdev.alloc_pd = c2_alloc_pd;\r\ndev->ibdev.dealloc_pd = c2_dealloc_pd;\r\ndev->ibdev.create_ah = c2_ah_create;\r\ndev->ibdev.destroy_ah = c2_ah_destroy;\r\ndev->ibdev.create_qp = c2_create_qp;\r\ndev->ibdev.modify_qp = c2_modify_qp;\r\ndev->ibdev.destroy_qp = c2_destroy_qp;\r\ndev->ibdev.create_cq = c2_create_cq;\r\ndev->ibdev.destroy_cq = c2_destroy_cq;\r\ndev->ibdev.poll_cq = c2_poll_cq;\r\ndev->ibdev.get_dma_mr = c2_get_dma_mr;\r\ndev->ibdev.reg_phys_mr = c2_reg_phys_mr;\r\ndev->ibdev.reg_user_mr = c2_reg_user_mr;\r\ndev->ibdev.dereg_mr = c2_dereg_mr;\r\ndev->ibdev.alloc_fmr = NULL;\r\ndev->ibdev.unmap_fmr = NULL;\r\ndev->ibdev.dealloc_fmr = NULL;\r\ndev->ibdev.map_phys_fmr = NULL;\r\ndev->ibdev.attach_mcast = c2_multicast_attach;\r\ndev->ibdev.detach_mcast = c2_multicast_detach;\r\ndev->ibdev.process_mad = c2_process_mad;\r\ndev->ibdev.req_notify_cq = c2_arm_cq;\r\ndev->ibdev.post_send = c2_post_send;\r\ndev->ibdev.post_recv = c2_post_receive;\r\ndev->ibdev.iwcm = kmalloc(sizeof(*dev->ibdev.iwcm), GFP_KERNEL);\r\nif (dev->ibdev.iwcm == NULL) {\r\nret = -ENOMEM;\r\ngoto out_unregister_netdev;\r\n}\r\ndev->ibdev.iwcm->add_ref = c2_add_ref;\r\ndev->ibdev.iwcm->rem_ref = c2_rem_ref;\r\ndev->ibdev.iwcm->get_qp = c2_get_qp;\r\ndev->ibdev.iwcm->connect = c2_connect;\r\ndev->ibdev.iwcm->accept = c2_accept;\r\ndev->ibdev.iwcm->reject = c2_reject;\r\ndev->ibdev.iwcm->create_listen = c2_service_create;\r\ndev->ibdev.iwcm->destroy_listen = c2_service_destroy;\r\nret = ib_register_device(&dev->ibdev, NULL);\r\nif (ret)\r\ngoto out_free_iwcm;\r\nfor (i = 0; i < ARRAY_SIZE(c2_dev_attributes); ++i) {\r\nret = device_create_file(&dev->ibdev.dev,\r\nc2_dev_attributes[i]);\r\nif (ret)\r\ngoto out_unregister_ibdev;\r\n}\r\ngoto out;\r\nout_unregister_ibdev:\r\nib_unregister_device(&dev->ibdev);\r\nout_free_iwcm:\r\nkfree(dev->ibdev.iwcm);\r\nout_unregister_netdev:\r\nunregister_netdev(dev->pseudo_netdev);\r\nout_free_netdev:\r\nfree_netdev(dev->pseudo_netdev);\r\nout:\r\npr_debug("%s:%u ret=%d\n", __func__, __LINE__, ret);\r\nreturn ret;\r\n}\r\nvoid c2_unregister_device(struct c2_dev *dev)\r\n{\r\npr_debug("%s:%u\n", __func__, __LINE__);\r\nunregister_netdev(dev->pseudo_netdev);\r\nfree_netdev(dev->pseudo_netdev);\r\nib_unregister_device(&dev->ibdev);\r\n}
