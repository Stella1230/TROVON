static int edid_size(const u8 *edid, int data_size)\r\n{\r\nif (data_size < EDID_LENGTH)\r\nreturn 0;\r\nreturn (edid[0x7e] + 1) * EDID_LENGTH;\r\n}\r\nstatic void *edid_load(struct drm_connector *connector, const char *name,\r\nconst char *connector_name)\r\n{\r\nconst struct firmware *fw = NULL;\r\nconst u8 *fwdata;\r\nu8 *edid;\r\nint fwsize, builtin;\r\nint i, valid_extensions = 0;\r\nbool print_bad_edid = !connector->bad_edid_counter || (drm_debug & DRM_UT_KMS);\r\nbuiltin = 0;\r\nfor (i = 0; i < GENERIC_EDIDS; i++) {\r\nif (strcmp(name, generic_edid_name[i]) == 0) {\r\nfwdata = generic_edid[i];\r\nfwsize = sizeof(generic_edid[i]);\r\nbuiltin = 1;\r\nbreak;\r\n}\r\n}\r\nif (!builtin) {\r\nstruct platform_device *pdev;\r\nint err;\r\npdev = platform_device_register_simple(connector_name, -1, NULL, 0);\r\nif (IS_ERR(pdev)) {\r\nDRM_ERROR("Failed to register EDID firmware platform device "\r\n"for connector \"%s\"\n", connector_name);\r\nreturn ERR_CAST(pdev);\r\n}\r\nerr = request_firmware(&fw, name, &pdev->dev);\r\nplatform_device_unregister(pdev);\r\nif (err) {\r\nDRM_ERROR("Requesting EDID firmware \"%s\" failed (err=%d)\n",\r\nname, err);\r\nreturn ERR_PTR(err);\r\n}\r\nfwdata = fw->data;\r\nfwsize = fw->size;\r\n}\r\nif (edid_size(fwdata, fwsize) != fwsize) {\r\nDRM_ERROR("Size of EDID firmware \"%s\" is invalid "\r\n"(expected %d, got %d\n", name,\r\nedid_size(fwdata, fwsize), (int)fwsize);\r\nedid = ERR_PTR(-EINVAL);\r\ngoto out;\r\n}\r\nedid = kmemdup(fwdata, fwsize, GFP_KERNEL);\r\nif (edid == NULL) {\r\nedid = ERR_PTR(-ENOMEM);\r\ngoto out;\r\n}\r\nif (!drm_edid_block_valid(edid, 0, print_bad_edid)) {\r\nconnector->bad_edid_counter++;\r\nDRM_ERROR("Base block of EDID firmware \"%s\" is invalid ",\r\nname);\r\nkfree(edid);\r\nedid = ERR_PTR(-EINVAL);\r\ngoto out;\r\n}\r\nfor (i = 1; i <= edid[0x7e]; i++) {\r\nif (i != valid_extensions + 1)\r\nmemcpy(edid + (valid_extensions + 1) * EDID_LENGTH,\r\nedid + i * EDID_LENGTH, EDID_LENGTH);\r\nif (drm_edid_block_valid(edid + i * EDID_LENGTH, i, print_bad_edid))\r\nvalid_extensions++;\r\n}\r\nif (valid_extensions != edid[0x7e]) {\r\nu8 *new_edid;\r\nedid[EDID_LENGTH-1] += edid[0x7e] - valid_extensions;\r\nDRM_INFO("Found %d valid extensions instead of %d in EDID data "\r\n"\"%s\" for connector \"%s\"\n", valid_extensions,\r\nedid[0x7e], name, connector_name);\r\nedid[0x7e] = valid_extensions;\r\nnew_edid = krealloc(edid, (valid_extensions + 1) * EDID_LENGTH,\r\nGFP_KERNEL);\r\nif (new_edid)\r\nedid = new_edid;\r\n}\r\nDRM_INFO("Got %s EDID base block and %d extension%s from "\r\n"\"%s\" for connector \"%s\"\n", builtin ? "built-in" :\r\n"external", valid_extensions, valid_extensions == 1 ? "" : "s",\r\nname, connector_name);\r\nout:\r\nrelease_firmware(fw);\r\nreturn edid;\r\n}\r\nint drm_load_edid_firmware(struct drm_connector *connector)\r\n{\r\nconst char *connector_name = connector->name;\r\nchar *edidname = edid_firmware, *last, *colon;\r\nint ret;\r\nstruct edid *edid;\r\nif (*edidname == '\0')\r\nreturn 0;\r\ncolon = strchr(edidname, ':');\r\nif (colon != NULL) {\r\nif (strncmp(connector_name, edidname, colon - edidname))\r\nreturn 0;\r\nedidname = colon + 1;\r\nif (*edidname == '\0')\r\nreturn 0;\r\n}\r\nlast = edidname + strlen(edidname) - 1;\r\nif (*last == '\n')\r\n*last = '\0';\r\nedid = edid_load(connector, edidname, connector_name);\r\nif (IS_ERR_OR_NULL(edid))\r\nreturn 0;\r\ndrm_mode_connector_update_edid_property(connector, edid);\r\nret = drm_add_edid_modes(connector, edid);\r\ndrm_edid_to_eld(connector, edid);\r\nkfree(edid);\r\nreturn ret;\r\n}
