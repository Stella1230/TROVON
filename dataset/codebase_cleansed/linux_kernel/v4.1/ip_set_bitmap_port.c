static inline u16\r\nport_to_id(const struct bitmap_port *m, u16 port)\r\n{\r\nreturn port - m->first_port;\r\n}\r\nstatic inline int\r\nbitmap_port_do_test(const struct bitmap_port_adt_elem *e,\r\nconst struct bitmap_port *map, size_t dsize)\r\n{\r\nreturn !!test_bit(e->id, map->members);\r\n}\r\nstatic inline int\r\nbitmap_port_gc_test(u16 id, const struct bitmap_port *map, size_t dsize)\r\n{\r\nreturn !!test_bit(id, map->members);\r\n}\r\nstatic inline int\r\nbitmap_port_do_add(const struct bitmap_port_adt_elem *e,\r\nstruct bitmap_port *map, u32 flags, size_t dsize)\r\n{\r\nreturn !!test_and_set_bit(e->id, map->members);\r\n}\r\nstatic inline int\r\nbitmap_port_do_del(const struct bitmap_port_adt_elem *e,\r\nstruct bitmap_port *map)\r\n{\r\nreturn !test_and_clear_bit(e->id, map->members);\r\n}\r\nstatic inline int\r\nbitmap_port_do_list(struct sk_buff *skb, const struct bitmap_port *map, u32 id,\r\nsize_t dsize)\r\n{\r\nreturn nla_put_net16(skb, IPSET_ATTR_PORT,\r\nhtons(map->first_port + id));\r\n}\r\nstatic inline int\r\nbitmap_port_do_head(struct sk_buff *skb, const struct bitmap_port *map)\r\n{\r\nreturn nla_put_net16(skb, IPSET_ATTR_PORT, htons(map->first_port)) ||\r\nnla_put_net16(skb, IPSET_ATTR_PORT_TO, htons(map->last_port));\r\n}\r\nstatic int\r\nbitmap_port_kadt(struct ip_set *set, const struct sk_buff *skb,\r\nconst struct xt_action_param *par,\r\nenum ipset_adt adt, struct ip_set_adt_opt *opt)\r\n{\r\nstruct bitmap_port *map = set->data;\r\nipset_adtfn adtfn = set->variant->adt[adt];\r\nstruct bitmap_port_adt_elem e = { .id = 0 };\r\nstruct ip_set_ext ext = IP_SET_INIT_KEXT(skb, opt, set);\r\n__be16 __port;\r\nu16 port = 0;\r\nif (!ip_set_get_ip_port(skb, opt->family,\r\nopt->flags & IPSET_DIM_ONE_SRC, &__port))\r\nreturn -EINVAL;\r\nport = ntohs(__port);\r\nif (port < map->first_port || port > map->last_port)\r\nreturn -IPSET_ERR_BITMAP_RANGE;\r\ne.id = port_to_id(map, port);\r\nreturn adtfn(set, &e, &ext, &opt->ext, opt->cmdflags);\r\n}\r\nstatic int\r\nbitmap_port_uadt(struct ip_set *set, struct nlattr *tb[],\r\nenum ipset_adt adt, u32 *lineno, u32 flags, bool retried)\r\n{\r\nstruct bitmap_port *map = set->data;\r\nipset_adtfn adtfn = set->variant->adt[adt];\r\nstruct bitmap_port_adt_elem e = { .id = 0 };\r\nstruct ip_set_ext ext = IP_SET_INIT_UEXT(set);\r\nu32 port;\r\nu16 port_to;\r\nint ret = 0;\r\nif (unlikely(!ip_set_attr_netorder(tb, IPSET_ATTR_PORT) ||\r\n!ip_set_optattr_netorder(tb, IPSET_ATTR_PORT_TO) ||\r\n!ip_set_optattr_netorder(tb, IPSET_ATTR_TIMEOUT) ||\r\n!ip_set_optattr_netorder(tb, IPSET_ATTR_PACKETS) ||\r\n!ip_set_optattr_netorder(tb, IPSET_ATTR_BYTES) ||\r\n!ip_set_optattr_netorder(tb, IPSET_ATTR_SKBMARK) ||\r\n!ip_set_optattr_netorder(tb, IPSET_ATTR_SKBPRIO) ||\r\n!ip_set_optattr_netorder(tb, IPSET_ATTR_SKBQUEUE)))\r\nreturn -IPSET_ERR_PROTOCOL;\r\nif (tb[IPSET_ATTR_LINENO])\r\n*lineno = nla_get_u32(tb[IPSET_ATTR_LINENO]);\r\nport = ip_set_get_h16(tb[IPSET_ATTR_PORT]);\r\nif (port < map->first_port || port > map->last_port)\r\nreturn -IPSET_ERR_BITMAP_RANGE;\r\nret = ip_set_get_extensions(set, tb, &ext);\r\nif (ret)\r\nreturn ret;\r\nif (adt == IPSET_TEST) {\r\ne.id = port_to_id(map, port);\r\nreturn adtfn(set, &e, &ext, &ext, flags);\r\n}\r\nif (tb[IPSET_ATTR_PORT_TO]) {\r\nport_to = ip_set_get_h16(tb[IPSET_ATTR_PORT_TO]);\r\nif (port > port_to) {\r\nswap(port, port_to);\r\nif (port < map->first_port)\r\nreturn -IPSET_ERR_BITMAP_RANGE;\r\n}\r\n} else\r\nport_to = port;\r\nif (port_to > map->last_port)\r\nreturn -IPSET_ERR_BITMAP_RANGE;\r\nfor (; port <= port_to; port++) {\r\ne.id = port_to_id(map, port);\r\nret = adtfn(set, &e, &ext, &ext, flags);\r\nif (ret && !ip_set_eexist(ret, flags))\r\nreturn ret;\r\nelse\r\nret = 0;\r\n}\r\nreturn ret;\r\n}\r\nstatic bool\r\nbitmap_port_same_set(const struct ip_set *a, const struct ip_set *b)\r\n{\r\nconst struct bitmap_port *x = a->data;\r\nconst struct bitmap_port *y = b->data;\r\nreturn x->first_port == y->first_port &&\r\nx->last_port == y->last_port &&\r\na->timeout == b->timeout &&\r\na->extensions == b->extensions;\r\n}\r\nstatic bool\r\ninit_map_port(struct ip_set *set, struct bitmap_port *map,\r\nu16 first_port, u16 last_port)\r\n{\r\nmap->members = ip_set_alloc(map->memsize);\r\nif (!map->members)\r\nreturn false;\r\nif (set->dsize) {\r\nmap->extensions = ip_set_alloc(set->dsize * map->elements);\r\nif (!map->extensions) {\r\nkfree(map->members);\r\nreturn false;\r\n}\r\n}\r\nmap->first_port = first_port;\r\nmap->last_port = last_port;\r\nset->timeout = IPSET_NO_TIMEOUT;\r\nset->data = map;\r\nset->family = NFPROTO_UNSPEC;\r\nreturn true;\r\n}\r\nstatic int\r\nbitmap_port_create(struct net *net, struct ip_set *set, struct nlattr *tb[],\r\nu32 flags)\r\n{\r\nstruct bitmap_port *map;\r\nu16 first_port, last_port;\r\nif (unlikely(!ip_set_attr_netorder(tb, IPSET_ATTR_PORT) ||\r\n!ip_set_attr_netorder(tb, IPSET_ATTR_PORT_TO) ||\r\n!ip_set_optattr_netorder(tb, IPSET_ATTR_TIMEOUT) ||\r\n!ip_set_optattr_netorder(tb, IPSET_ATTR_CADT_FLAGS)))\r\nreturn -IPSET_ERR_PROTOCOL;\r\nfirst_port = ip_set_get_h16(tb[IPSET_ATTR_PORT]);\r\nlast_port = ip_set_get_h16(tb[IPSET_ATTR_PORT_TO]);\r\nif (first_port > last_port) {\r\nu16 tmp = first_port;\r\nfirst_port = last_port;\r\nlast_port = tmp;\r\n}\r\nmap = kzalloc(sizeof(*map), GFP_KERNEL);\r\nif (!map)\r\nreturn -ENOMEM;\r\nmap->elements = last_port - first_port + 1;\r\nmap->memsize = bitmap_bytes(0, map->elements);\r\nset->variant = &bitmap_port;\r\nset->dsize = ip_set_elem_len(set, tb, 0);\r\nif (!init_map_port(set, map, first_port, last_port)) {\r\nkfree(map);\r\nreturn -ENOMEM;\r\n}\r\nif (tb[IPSET_ATTR_TIMEOUT]) {\r\nset->timeout = ip_set_timeout_uget(tb[IPSET_ATTR_TIMEOUT]);\r\nbitmap_port_gc_init(set, bitmap_port_gc);\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init\r\nbitmap_port_init(void)\r\n{\r\nreturn ip_set_type_register(&bitmap_port_type);\r\n}\r\nstatic void __exit\r\nbitmap_port_fini(void)\r\n{\r\nip_set_type_unregister(&bitmap_port_type);\r\n}
