static int rtl2832_sdr_wr_regs(struct rtl2832_sdr_dev *dev, u16 reg,\r\nconst u8 *val, int len)\r\n{\r\nstruct platform_device *pdev = dev->pdev;\r\nstruct rtl2832_sdr_platform_data *pdata = pdev->dev.platform_data;\r\nstruct i2c_client *client = pdata->i2c_client;\r\nreturn pdata->bulk_write(client, reg, val, len);\r\n}\r\nstatic int rtl2832_sdr_wr_reg(struct rtl2832_sdr_dev *dev, u16 reg, u8 val)\r\n{\r\nreturn rtl2832_sdr_wr_regs(dev, reg, &val, 1);\r\n}\r\nstatic int rtl2832_sdr_wr_reg_mask(struct rtl2832_sdr_dev *dev, u16 reg,\r\nu8 val, u8 mask)\r\n{\r\nstruct platform_device *pdev = dev->pdev;\r\nstruct rtl2832_sdr_platform_data *pdata = pdev->dev.platform_data;\r\nstruct i2c_client *client = pdata->i2c_client;\r\nreturn pdata->update_bits(client, reg, mask, val);\r\n}\r\nstatic struct rtl2832_sdr_frame_buf *rtl2832_sdr_get_next_fill_buf(\r\nstruct rtl2832_sdr_dev *dev)\r\n{\r\nunsigned long flags;\r\nstruct rtl2832_sdr_frame_buf *buf = NULL;\r\nspin_lock_irqsave(&dev->queued_bufs_lock, flags);\r\nif (list_empty(&dev->queued_bufs))\r\ngoto leave;\r\nbuf = list_entry(dev->queued_bufs.next,\r\nstruct rtl2832_sdr_frame_buf, list);\r\nlist_del(&buf->list);\r\nleave:\r\nspin_unlock_irqrestore(&dev->queued_bufs_lock, flags);\r\nreturn buf;\r\n}\r\nstatic unsigned int rtl2832_sdr_convert_stream(struct rtl2832_sdr_dev *dev,\r\nvoid *dst, const u8 *src, unsigned int src_len)\r\n{\r\nstruct platform_device *pdev = dev->pdev;\r\nunsigned int dst_len;\r\nif (dev->pixelformat == V4L2_SDR_FMT_CU8) {\r\nmemcpy(dst, src, src_len);\r\ndst_len = src_len;\r\n} else if (dev->pixelformat == V4L2_SDR_FMT_CU16LE) {\r\nunsigned int i;\r\nu16 *u16dst = dst;\r\nfor (i = 0; i < src_len; i++)\r\n*u16dst++ = (src[i] << 8) | (src[i] >> 0);\r\ndst_len = 2 * src_len;\r\n} else {\r\ndst_len = 0;\r\n}\r\nif (unlikely(time_is_before_jiffies(dev->jiffies_next))) {\r\n#define MSECS 10000UL\r\nunsigned int msecs = jiffies_to_msecs(jiffies -\r\ndev->jiffies_next + msecs_to_jiffies(MSECS));\r\nunsigned int samples = dev->sample - dev->sample_measured;\r\ndev->jiffies_next = jiffies + msecs_to_jiffies(MSECS);\r\ndev->sample_measured = dev->sample;\r\ndev_dbg(&pdev->dev,\r\n"slen=%u samples=%u msecs=%u sample rate=%lu\n",\r\nsrc_len, samples, msecs, samples * 1000UL / msecs);\r\n}\r\ndev->sample += src_len / 2;\r\nreturn dst_len;\r\n}\r\nstatic void rtl2832_sdr_urb_complete(struct urb *urb)\r\n{\r\nstruct rtl2832_sdr_dev *dev = urb->context;\r\nstruct platform_device *pdev = dev->pdev;\r\nstruct rtl2832_sdr_frame_buf *fbuf;\r\ndev_dbg_ratelimited(&pdev->dev, "status=%d length=%d/%d errors=%d\n",\r\nurb->status, urb->actual_length,\r\nurb->transfer_buffer_length, urb->error_count);\r\nswitch (urb->status) {\r\ncase 0:\r\ncase -ETIMEDOUT:\r\nbreak;\r\ncase -ECONNRESET:\r\ncase -ENOENT:\r\ncase -ESHUTDOWN:\r\nreturn;\r\ndefault:\r\ndev_err_ratelimited(&pdev->dev, "urb failed=%d\n", urb->status);\r\nbreak;\r\n}\r\nif (likely(urb->actual_length > 0)) {\r\nvoid *ptr;\r\nunsigned int len;\r\nfbuf = rtl2832_sdr_get_next_fill_buf(dev);\r\nif (unlikely(fbuf == NULL)) {\r\ndev->vb_full++;\r\ndev_notice_ratelimited(&pdev->dev,\r\n"videobuf is full, %d packets dropped\n",\r\ndev->vb_full);\r\ngoto skip;\r\n}\r\nptr = vb2_plane_vaddr(&fbuf->vb, 0);\r\nlen = rtl2832_sdr_convert_stream(dev, ptr, urb->transfer_buffer,\r\nurb->actual_length);\r\nvb2_set_plane_payload(&fbuf->vb, 0, len);\r\nv4l2_get_timestamp(&fbuf->vb.v4l2_buf.timestamp);\r\nfbuf->vb.v4l2_buf.sequence = dev->sequence++;\r\nvb2_buffer_done(&fbuf->vb, VB2_BUF_STATE_DONE);\r\n}\r\nskip:\r\nusb_submit_urb(urb, GFP_ATOMIC);\r\n}\r\nstatic int rtl2832_sdr_kill_urbs(struct rtl2832_sdr_dev *dev)\r\n{\r\nstruct platform_device *pdev = dev->pdev;\r\nint i;\r\nfor (i = dev->urbs_submitted - 1; i >= 0; i--) {\r\ndev_dbg(&pdev->dev, "kill urb=%d\n", i);\r\nusb_kill_urb(dev->urb_list[i]);\r\n}\r\ndev->urbs_submitted = 0;\r\nreturn 0;\r\n}\r\nstatic int rtl2832_sdr_submit_urbs(struct rtl2832_sdr_dev *dev)\r\n{\r\nstruct platform_device *pdev = dev->pdev;\r\nint i, ret;\r\nfor (i = 0; i < dev->urbs_initialized; i++) {\r\ndev_dbg(&pdev->dev, "submit urb=%d\n", i);\r\nret = usb_submit_urb(dev->urb_list[i], GFP_ATOMIC);\r\nif (ret) {\r\ndev_err(&pdev->dev,\r\n"Could not submit urb no. %d - get them all back\n",\r\ni);\r\nrtl2832_sdr_kill_urbs(dev);\r\nreturn ret;\r\n}\r\ndev->urbs_submitted++;\r\n}\r\nreturn 0;\r\n}\r\nstatic int rtl2832_sdr_free_stream_bufs(struct rtl2832_sdr_dev *dev)\r\n{\r\nstruct platform_device *pdev = dev->pdev;\r\nif (dev->flags & USB_STATE_URB_BUF) {\r\nwhile (dev->buf_num) {\r\ndev->buf_num--;\r\ndev_dbg(&pdev->dev, "free buf=%d\n", dev->buf_num);\r\nusb_free_coherent(dev->udev, dev->buf_size,\r\ndev->buf_list[dev->buf_num],\r\ndev->dma_addr[dev->buf_num]);\r\n}\r\n}\r\ndev->flags &= ~USB_STATE_URB_BUF;\r\nreturn 0;\r\n}\r\nstatic int rtl2832_sdr_alloc_stream_bufs(struct rtl2832_sdr_dev *dev)\r\n{\r\nstruct platform_device *pdev = dev->pdev;\r\ndev->buf_num = 0;\r\ndev->buf_size = BULK_BUFFER_SIZE;\r\ndev_dbg(&pdev->dev, "all in all I will use %u bytes for streaming\n",\r\nMAX_BULK_BUFS * BULK_BUFFER_SIZE);\r\nfor (dev->buf_num = 0; dev->buf_num < MAX_BULK_BUFS; dev->buf_num++) {\r\ndev->buf_list[dev->buf_num] = usb_alloc_coherent(dev->udev,\r\nBULK_BUFFER_SIZE, GFP_ATOMIC,\r\n&dev->dma_addr[dev->buf_num]);\r\nif (!dev->buf_list[dev->buf_num]) {\r\ndev_dbg(&pdev->dev, "alloc buf=%d failed\n",\r\ndev->buf_num);\r\nrtl2832_sdr_free_stream_bufs(dev);\r\nreturn -ENOMEM;\r\n}\r\ndev_dbg(&pdev->dev, "alloc buf=%d %p (dma %llu)\n",\r\ndev->buf_num, dev->buf_list[dev->buf_num],\r\n(long long)dev->dma_addr[dev->buf_num]);\r\ndev->flags |= USB_STATE_URB_BUF;\r\n}\r\nreturn 0;\r\n}\r\nstatic int rtl2832_sdr_free_urbs(struct rtl2832_sdr_dev *dev)\r\n{\r\nstruct platform_device *pdev = dev->pdev;\r\nint i;\r\nrtl2832_sdr_kill_urbs(dev);\r\nfor (i = dev->urbs_initialized - 1; i >= 0; i--) {\r\nif (dev->urb_list[i]) {\r\ndev_dbg(&pdev->dev, "free urb=%d\n", i);\r\nusb_free_urb(dev->urb_list[i]);\r\n}\r\n}\r\ndev->urbs_initialized = 0;\r\nreturn 0;\r\n}\r\nstatic int rtl2832_sdr_alloc_urbs(struct rtl2832_sdr_dev *dev)\r\n{\r\nstruct platform_device *pdev = dev->pdev;\r\nint i, j;\r\nfor (i = 0; i < MAX_BULK_BUFS; i++) {\r\ndev_dbg(&pdev->dev, "alloc urb=%d\n", i);\r\ndev->urb_list[i] = usb_alloc_urb(0, GFP_ATOMIC);\r\nif (!dev->urb_list[i]) {\r\ndev_dbg(&pdev->dev, "failed\n");\r\nfor (j = 0; j < i; j++)\r\nusb_free_urb(dev->urb_list[j]);\r\nreturn -ENOMEM;\r\n}\r\nusb_fill_bulk_urb(dev->urb_list[i],\r\ndev->udev,\r\nusb_rcvbulkpipe(dev->udev, 0x81),\r\ndev->buf_list[i],\r\nBULK_BUFFER_SIZE,\r\nrtl2832_sdr_urb_complete, dev);\r\ndev->urb_list[i]->transfer_flags = URB_NO_TRANSFER_DMA_MAP;\r\ndev->urb_list[i]->transfer_dma = dev->dma_addr[i];\r\ndev->urbs_initialized++;\r\n}\r\nreturn 0;\r\n}\r\nstatic void rtl2832_sdr_cleanup_queued_bufs(struct rtl2832_sdr_dev *dev)\r\n{\r\nstruct platform_device *pdev = dev->pdev;\r\nunsigned long flags;\r\ndev_dbg(&pdev->dev, "\n");\r\nspin_lock_irqsave(&dev->queued_bufs_lock, flags);\r\nwhile (!list_empty(&dev->queued_bufs)) {\r\nstruct rtl2832_sdr_frame_buf *buf;\r\nbuf = list_entry(dev->queued_bufs.next,\r\nstruct rtl2832_sdr_frame_buf, list);\r\nlist_del(&buf->list);\r\nvb2_buffer_done(&buf->vb, VB2_BUF_STATE_ERROR);\r\n}\r\nspin_unlock_irqrestore(&dev->queued_bufs_lock, flags);\r\n}\r\nstatic int rtl2832_sdr_querycap(struct file *file, void *fh,\r\nstruct v4l2_capability *cap)\r\n{\r\nstruct rtl2832_sdr_dev *dev = video_drvdata(file);\r\nstruct platform_device *pdev = dev->pdev;\r\ndev_dbg(&pdev->dev, "\n");\r\nstrlcpy(cap->driver, KBUILD_MODNAME, sizeof(cap->driver));\r\nstrlcpy(cap->card, dev->vdev.name, sizeof(cap->card));\r\nusb_make_path(dev->udev, cap->bus_info, sizeof(cap->bus_info));\r\ncap->device_caps = V4L2_CAP_SDR_CAPTURE | V4L2_CAP_STREAMING |\r\nV4L2_CAP_READWRITE | V4L2_CAP_TUNER;\r\ncap->capabilities = cap->device_caps | V4L2_CAP_DEVICE_CAPS;\r\nreturn 0;\r\n}\r\nstatic int rtl2832_sdr_queue_setup(struct vb2_queue *vq,\r\nconst struct v4l2_format *fmt, unsigned int *nbuffers,\r\nunsigned int *nplanes, unsigned int sizes[], void *alloc_ctxs[])\r\n{\r\nstruct rtl2832_sdr_dev *dev = vb2_get_drv_priv(vq);\r\nstruct platform_device *pdev = dev->pdev;\r\ndev_dbg(&pdev->dev, "nbuffers=%d\n", *nbuffers);\r\nif (vq->num_buffers + *nbuffers < 8)\r\n*nbuffers = 8 - vq->num_buffers;\r\n*nplanes = 1;\r\nsizes[0] = PAGE_ALIGN(dev->buffersize);\r\ndev_dbg(&pdev->dev, "nbuffers=%d sizes[0]=%d\n", *nbuffers, sizes[0]);\r\nreturn 0;\r\n}\r\nstatic int rtl2832_sdr_buf_prepare(struct vb2_buffer *vb)\r\n{\r\nstruct rtl2832_sdr_dev *dev = vb2_get_drv_priv(vb->vb2_queue);\r\nif (!dev->udev)\r\nreturn -ENODEV;\r\nreturn 0;\r\n}\r\nstatic void rtl2832_sdr_buf_queue(struct vb2_buffer *vb)\r\n{\r\nstruct rtl2832_sdr_dev *dev = vb2_get_drv_priv(vb->vb2_queue);\r\nstruct rtl2832_sdr_frame_buf *buf =\r\ncontainer_of(vb, struct rtl2832_sdr_frame_buf, vb);\r\nunsigned long flags;\r\nif (!dev->udev) {\r\nvb2_buffer_done(&buf->vb, VB2_BUF_STATE_ERROR);\r\nreturn;\r\n}\r\nspin_lock_irqsave(&dev->queued_bufs_lock, flags);\r\nlist_add_tail(&buf->list, &dev->queued_bufs);\r\nspin_unlock_irqrestore(&dev->queued_bufs_lock, flags);\r\n}\r\nstatic int rtl2832_sdr_set_adc(struct rtl2832_sdr_dev *dev)\r\n{\r\nstruct platform_device *pdev = dev->pdev;\r\nstruct rtl2832_sdr_platform_data *pdata = pdev->dev.platform_data;\r\nstruct dvb_frontend *fe = pdata->dvb_frontend;\r\nint ret;\r\nunsigned int f_sr, f_if;\r\nu8 buf[4], u8tmp1, u8tmp2;\r\nu64 u64tmp;\r\nu32 u32tmp;\r\ndev_dbg(&pdev->dev, "f_adc=%u\n", dev->f_adc);\r\nif (!test_bit(POWER_ON, &dev->flags))\r\nreturn 0;\r\nif (dev->f_adc == 0)\r\nreturn 0;\r\nf_sr = dev->f_adc;\r\nret = rtl2832_sdr_wr_regs(dev, 0x13e, "\x00\x00", 2);\r\nif (ret)\r\ngoto err;\r\nret = rtl2832_sdr_wr_regs(dev, 0x115, "\x00\x00\x00\x00", 4);\r\nif (ret)\r\ngoto err;\r\nif (fe->ops.tuner_ops.get_if_frequency)\r\nret = fe->ops.tuner_ops.get_if_frequency(fe, &f_if);\r\nelse\r\nret = -EINVAL;\r\nif (ret)\r\ngoto err;\r\nu64tmp = f_if % pdata->clk;\r\nu64tmp *= 0x400000;\r\nu64tmp = div_u64(u64tmp, pdata->clk);\r\nu64tmp = -u64tmp;\r\nu32tmp = u64tmp & 0x3fffff;\r\ndev_dbg(&pdev->dev, "f_if=%u if_ctl=%08x\n", f_if, u32tmp);\r\nbuf[0] = (u32tmp >> 16) & 0xff;\r\nbuf[1] = (u32tmp >> 8) & 0xff;\r\nbuf[2] = (u32tmp >> 0) & 0xff;\r\nret = rtl2832_sdr_wr_regs(dev, 0x119, buf, 3);\r\nif (ret)\r\ngoto err;\r\nif (f_if) {\r\nu8tmp1 = 0x1a;\r\nu8tmp2 = 0x8d;\r\n} else {\r\nu8tmp1 = 0x1b;\r\nu8tmp2 = 0xcd;\r\n}\r\nret = rtl2832_sdr_wr_reg(dev, 0x1b1, u8tmp1);\r\nif (ret)\r\ngoto err;\r\nret = rtl2832_sdr_wr_reg(dev, 0x008, u8tmp2);\r\nif (ret)\r\ngoto err;\r\nret = rtl2832_sdr_wr_reg(dev, 0x006, 0x80);\r\nif (ret)\r\ngoto err;\r\nu32tmp = div_u64(pdata->clk * 0x400000ULL, f_sr * 4U);\r\nu32tmp <<= 2;\r\nbuf[0] = (u32tmp >> 24) & 0xff;\r\nbuf[1] = (u32tmp >> 16) & 0xff;\r\nbuf[2] = (u32tmp >> 8) & 0xff;\r\nbuf[3] = (u32tmp >> 0) & 0xff;\r\nret = rtl2832_sdr_wr_regs(dev, 0x19f, buf, 4);\r\nif (ret)\r\ngoto err;\r\nret = rtl2832_sdr_wr_regs(dev, 0x11c,\r\n"\xca\xdc\xd7\xd8\xe0\xf2\x0e\x35\x06\x50\x9c\x0d\x71\x11\x14\x71\x74\x19\x41\xa5",\r\n20);\r\nif (ret)\r\ngoto err;\r\nret = rtl2832_sdr_wr_regs(dev, 0x017, "\x11\x10", 2);\r\nif (ret)\r\ngoto err;\r\nret = rtl2832_sdr_wr_regs(dev, 0x019, "\x05", 1);\r\nif (ret)\r\ngoto err;\r\nret = rtl2832_sdr_wr_regs(dev, 0x01a, "\x1b\x16\x0d\x06\x01\xff", 6);\r\nif (ret)\r\ngoto err;\r\nret = rtl2832_sdr_wr_regs(dev, 0x192, "\x00\xf0\x0f", 3);\r\nif (ret)\r\ngoto err;\r\nret = rtl2832_sdr_wr_regs(dev, 0x061, "\x60", 1);\r\nif (ret)\r\ngoto err;\r\nswitch (pdata->tuner) {\r\ncase RTL2832_SDR_TUNER_E4000:\r\nret = rtl2832_sdr_wr_regs(dev, 0x112, "\x5a", 1);\r\nret = rtl2832_sdr_wr_regs(dev, 0x102, "\x40", 1);\r\nret = rtl2832_sdr_wr_regs(dev, 0x103, "\x5a", 1);\r\nret = rtl2832_sdr_wr_regs(dev, 0x1c7, "\x30", 1);\r\nret = rtl2832_sdr_wr_regs(dev, 0x104, "\xd0", 1);\r\nret = rtl2832_sdr_wr_regs(dev, 0x105, "\xbe", 1);\r\nret = rtl2832_sdr_wr_regs(dev, 0x1c8, "\x18", 1);\r\nret = rtl2832_sdr_wr_regs(dev, 0x106, "\x35", 1);\r\nret = rtl2832_sdr_wr_regs(dev, 0x1c9, "\x21", 1);\r\nret = rtl2832_sdr_wr_regs(dev, 0x1ca, "\x21", 1);\r\nret = rtl2832_sdr_wr_regs(dev, 0x1cb, "\x00", 1);\r\nret = rtl2832_sdr_wr_regs(dev, 0x107, "\x40", 1);\r\nret = rtl2832_sdr_wr_regs(dev, 0x1cd, "\x10", 1);\r\nret = rtl2832_sdr_wr_regs(dev, 0x1ce, "\x10", 1);\r\nret = rtl2832_sdr_wr_regs(dev, 0x108, "\x80", 1);\r\nret = rtl2832_sdr_wr_regs(dev, 0x109, "\x7f", 1);\r\nret = rtl2832_sdr_wr_regs(dev, 0x10a, "\x80", 1);\r\nret = rtl2832_sdr_wr_regs(dev, 0x10b, "\x7f", 1);\r\nret = rtl2832_sdr_wr_regs(dev, 0x00e, "\xfc", 1);\r\nret = rtl2832_sdr_wr_regs(dev, 0x00e, "\xfc", 1);\r\nret = rtl2832_sdr_wr_regs(dev, 0x011, "\xd4", 1);\r\nret = rtl2832_sdr_wr_regs(dev, 0x1e5, "\xf0", 1);\r\nret = rtl2832_sdr_wr_regs(dev, 0x1d9, "\x00", 1);\r\nret = rtl2832_sdr_wr_regs(dev, 0x1db, "\x00", 1);\r\nret = rtl2832_sdr_wr_regs(dev, 0x1dd, "\x14", 1);\r\nret = rtl2832_sdr_wr_regs(dev, 0x1de, "\xec", 1);\r\nret = rtl2832_sdr_wr_regs(dev, 0x1d8, "\x0c", 1);\r\nret = rtl2832_sdr_wr_regs(dev, 0x1e6, "\x02", 1);\r\nret = rtl2832_sdr_wr_regs(dev, 0x1d7, "\x09", 1);\r\nret = rtl2832_sdr_wr_regs(dev, 0x00d, "\x83", 1);\r\nret = rtl2832_sdr_wr_regs(dev, 0x010, "\x49", 1);\r\nret = rtl2832_sdr_wr_regs(dev, 0x00d, "\x87", 1);\r\nret = rtl2832_sdr_wr_regs(dev, 0x00d, "\x85", 1);\r\nret = rtl2832_sdr_wr_regs(dev, 0x013, "\x02", 1);\r\nbreak;\r\ncase RTL2832_SDR_TUNER_FC0012:\r\ncase RTL2832_SDR_TUNER_FC0013:\r\nret = rtl2832_sdr_wr_regs(dev, 0x112, "\x5a", 1);\r\nret = rtl2832_sdr_wr_regs(dev, 0x102, "\x40", 1);\r\nret = rtl2832_sdr_wr_regs(dev, 0x103, "\x5a", 1);\r\nret = rtl2832_sdr_wr_regs(dev, 0x1c7, "\x2c", 1);\r\nret = rtl2832_sdr_wr_regs(dev, 0x104, "\xcc", 1);\r\nret = rtl2832_sdr_wr_regs(dev, 0x105, "\xbe", 1);\r\nret = rtl2832_sdr_wr_regs(dev, 0x1c8, "\x16", 1);\r\nret = rtl2832_sdr_wr_regs(dev, 0x106, "\x35", 1);\r\nret = rtl2832_sdr_wr_regs(dev, 0x1c9, "\x21", 1);\r\nret = rtl2832_sdr_wr_regs(dev, 0x1ca, "\x21", 1);\r\nret = rtl2832_sdr_wr_regs(dev, 0x1cb, "\x00", 1);\r\nret = rtl2832_sdr_wr_regs(dev, 0x107, "\x40", 1);\r\nret = rtl2832_sdr_wr_regs(dev, 0x1cd, "\x10", 1);\r\nret = rtl2832_sdr_wr_regs(dev, 0x1ce, "\x10", 1);\r\nret = rtl2832_sdr_wr_regs(dev, 0x108, "\x80", 1);\r\nret = rtl2832_sdr_wr_regs(dev, 0x109, "\x7f", 1);\r\nret = rtl2832_sdr_wr_regs(dev, 0x10a, "\x80", 1);\r\nret = rtl2832_sdr_wr_regs(dev, 0x10b, "\x7f", 1);\r\nret = rtl2832_sdr_wr_regs(dev, 0x00e, "\xfc", 1);\r\nret = rtl2832_sdr_wr_regs(dev, 0x00e, "\xfc", 1);\r\nret = rtl2832_sdr_wr_regs(dev, 0x011, "\xe9\xbf", 2);\r\nret = rtl2832_sdr_wr_regs(dev, 0x1e5, "\xf0", 1);\r\nret = rtl2832_sdr_wr_regs(dev, 0x1d9, "\x00", 1);\r\nret = rtl2832_sdr_wr_regs(dev, 0x1db, "\x00", 1);\r\nret = rtl2832_sdr_wr_regs(dev, 0x1dd, "\x11", 1);\r\nret = rtl2832_sdr_wr_regs(dev, 0x1de, "\xef", 1);\r\nret = rtl2832_sdr_wr_regs(dev, 0x1d8, "\x0c", 1);\r\nret = rtl2832_sdr_wr_regs(dev, 0x1e6, "\x02", 1);\r\nret = rtl2832_sdr_wr_regs(dev, 0x1d7, "\x09", 1);\r\nbreak;\r\ncase RTL2832_SDR_TUNER_R820T:\r\ncase RTL2832_SDR_TUNER_R828D:\r\nret = rtl2832_sdr_wr_regs(dev, 0x112, "\x5a", 1);\r\nret = rtl2832_sdr_wr_regs(dev, 0x102, "\x40", 1);\r\nret = rtl2832_sdr_wr_regs(dev, 0x115, "\x01", 1);\r\nret = rtl2832_sdr_wr_regs(dev, 0x103, "\x80", 1);\r\nret = rtl2832_sdr_wr_regs(dev, 0x1c7, "\x24", 1);\r\nret = rtl2832_sdr_wr_regs(dev, 0x104, "\xcc", 1);\r\nret = rtl2832_sdr_wr_regs(dev, 0x105, "\xbe", 1);\r\nret = rtl2832_sdr_wr_regs(dev, 0x1c8, "\x14", 1);\r\nret = rtl2832_sdr_wr_regs(dev, 0x106, "\x35", 1);\r\nret = rtl2832_sdr_wr_regs(dev, 0x1c9, "\x21", 1);\r\nret = rtl2832_sdr_wr_regs(dev, 0x1ca, "\x21", 1);\r\nret = rtl2832_sdr_wr_regs(dev, 0x1cb, "\x00", 1);\r\nret = rtl2832_sdr_wr_regs(dev, 0x107, "\x40", 1);\r\nret = rtl2832_sdr_wr_regs(dev, 0x1cd, "\x10", 1);\r\nret = rtl2832_sdr_wr_regs(dev, 0x1ce, "\x10", 1);\r\nret = rtl2832_sdr_wr_regs(dev, 0x108, "\x80", 1);\r\nret = rtl2832_sdr_wr_regs(dev, 0x109, "\x7f", 1);\r\nret = rtl2832_sdr_wr_regs(dev, 0x10a, "\x80", 1);\r\nret = rtl2832_sdr_wr_regs(dev, 0x10b, "\x7f", 1);\r\nret = rtl2832_sdr_wr_regs(dev, 0x00e, "\xfc", 1);\r\nret = rtl2832_sdr_wr_regs(dev, 0x00e, "\xfc", 1);\r\nret = rtl2832_sdr_wr_regs(dev, 0x011, "\xf4", 1);\r\nbreak;\r\ndefault:\r\ndev_notice(&pdev->dev, "Unsupported tuner\n");\r\n}\r\nret = rtl2832_sdr_wr_reg_mask(dev, 0x101, 0x04, 0x04);\r\nif (ret)\r\ngoto err;\r\nret = rtl2832_sdr_wr_reg_mask(dev, 0x101, 0x00, 0x04);\r\nif (ret)\r\ngoto err;\r\nerr:\r\nreturn ret;\r\n}\r\nstatic void rtl2832_sdr_unset_adc(struct rtl2832_sdr_dev *dev)\r\n{\r\nstruct platform_device *pdev = dev->pdev;\r\nint ret;\r\ndev_dbg(&pdev->dev, "\n");\r\nret = rtl2832_sdr_wr_regs(dev, 0x061, "\xe0", 1);\r\nif (ret)\r\ngoto err;\r\nret = rtl2832_sdr_wr_regs(dev, 0x019, "\x20", 1);\r\nif (ret)\r\ngoto err;\r\nret = rtl2832_sdr_wr_regs(dev, 0x017, "\x11\x10", 2);\r\nif (ret)\r\ngoto err;\r\nret = rtl2832_sdr_wr_regs(dev, 0x192, "\x00\x0f\xff", 3);\r\nif (ret)\r\ngoto err;\r\nret = rtl2832_sdr_wr_regs(dev, 0x13e, "\x40\x00", 2);\r\nif (ret)\r\ngoto err;\r\nret = rtl2832_sdr_wr_regs(dev, 0x115, "\x06\x3f\xce\xcc", 4);\r\nif (ret)\r\ngoto err;\r\nerr:\r\nreturn;\r\n}\r\nstatic int rtl2832_sdr_set_tuner_freq(struct rtl2832_sdr_dev *dev)\r\n{\r\nstruct platform_device *pdev = dev->pdev;\r\nstruct rtl2832_sdr_platform_data *pdata = pdev->dev.platform_data;\r\nstruct dvb_frontend *fe = pdata->dvb_frontend;\r\nstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\r\nstruct v4l2_ctrl *bandwidth_auto;\r\nstruct v4l2_ctrl *bandwidth;\r\nif (dev->f_tuner == 0)\r\nreturn 0;\r\nbandwidth_auto = v4l2_ctrl_find(&dev->hdl,\r\nV4L2_CID_RF_TUNER_BANDWIDTH_AUTO);\r\nbandwidth = v4l2_ctrl_find(&dev->hdl, V4L2_CID_RF_TUNER_BANDWIDTH);\r\nif (v4l2_ctrl_g_ctrl(bandwidth_auto)) {\r\nc->bandwidth_hz = dev->f_adc;\r\nv4l2_ctrl_s_ctrl(bandwidth, dev->f_adc);\r\n} else {\r\nc->bandwidth_hz = v4l2_ctrl_g_ctrl(bandwidth);\r\n}\r\nc->frequency = dev->f_tuner;\r\nc->delivery_system = SYS_DVBT;\r\ndev_dbg(&pdev->dev, "frequency=%u bandwidth=%d\n",\r\nc->frequency, c->bandwidth_hz);\r\nif (!test_bit(POWER_ON, &dev->flags))\r\nreturn 0;\r\nif (fe->ops.tuner_ops.set_params)\r\nfe->ops.tuner_ops.set_params(fe);\r\nreturn 0;\r\n}\r\nstatic int rtl2832_sdr_set_tuner(struct rtl2832_sdr_dev *dev)\r\n{\r\nstruct platform_device *pdev = dev->pdev;\r\nstruct rtl2832_sdr_platform_data *pdata = pdev->dev.platform_data;\r\nstruct dvb_frontend *fe = pdata->dvb_frontend;\r\ndev_dbg(&pdev->dev, "\n");\r\nif (fe->ops.tuner_ops.init)\r\nfe->ops.tuner_ops.init(fe);\r\nreturn 0;\r\n}\r\nstatic void rtl2832_sdr_unset_tuner(struct rtl2832_sdr_dev *dev)\r\n{\r\nstruct platform_device *pdev = dev->pdev;\r\nstruct rtl2832_sdr_platform_data *pdata = pdev->dev.platform_data;\r\nstruct dvb_frontend *fe = pdata->dvb_frontend;\r\ndev_dbg(&pdev->dev, "\n");\r\nif (fe->ops.tuner_ops.sleep)\r\nfe->ops.tuner_ops.sleep(fe);\r\nreturn;\r\n}\r\nstatic int rtl2832_sdr_start_streaming(struct vb2_queue *vq, unsigned int count)\r\n{\r\nstruct rtl2832_sdr_dev *dev = vb2_get_drv_priv(vq);\r\nstruct platform_device *pdev = dev->pdev;\r\nstruct rtl2832_sdr_platform_data *pdata = pdev->dev.platform_data;\r\nstruct dvb_usb_device *d = pdata->dvb_usb_device;\r\nint ret;\r\ndev_dbg(&pdev->dev, "\n");\r\nif (!dev->udev)\r\nreturn -ENODEV;\r\nif (mutex_lock_interruptible(&dev->v4l2_lock))\r\nreturn -ERESTARTSYS;\r\nif (d->props->power_ctrl)\r\nd->props->power_ctrl(d, 1);\r\nif (d->props->frontend_ctrl)\r\nd->props->frontend_ctrl(pdata->dvb_frontend, 1);\r\nset_bit(POWER_ON, &dev->flags);\r\nret = rtl2832_sdr_set_tuner(dev);\r\nif (ret)\r\ngoto err;\r\nret = rtl2832_sdr_set_tuner_freq(dev);\r\nif (ret)\r\ngoto err;\r\nret = rtl2832_sdr_set_adc(dev);\r\nif (ret)\r\ngoto err;\r\nret = rtl2832_sdr_alloc_stream_bufs(dev);\r\nif (ret)\r\ngoto err;\r\nret = rtl2832_sdr_alloc_urbs(dev);\r\nif (ret)\r\ngoto err;\r\ndev->sequence = 0;\r\nret = rtl2832_sdr_submit_urbs(dev);\r\nif (ret)\r\ngoto err;\r\nerr:\r\nmutex_unlock(&dev->v4l2_lock);\r\nreturn ret;\r\n}\r\nstatic void rtl2832_sdr_stop_streaming(struct vb2_queue *vq)\r\n{\r\nstruct rtl2832_sdr_dev *dev = vb2_get_drv_priv(vq);\r\nstruct platform_device *pdev = dev->pdev;\r\nstruct rtl2832_sdr_platform_data *pdata = pdev->dev.platform_data;\r\nstruct dvb_usb_device *d = pdata->dvb_usb_device;\r\ndev_dbg(&pdev->dev, "\n");\r\nmutex_lock(&dev->v4l2_lock);\r\nrtl2832_sdr_kill_urbs(dev);\r\nrtl2832_sdr_free_urbs(dev);\r\nrtl2832_sdr_free_stream_bufs(dev);\r\nrtl2832_sdr_cleanup_queued_bufs(dev);\r\nrtl2832_sdr_unset_adc(dev);\r\nrtl2832_sdr_unset_tuner(dev);\r\nclear_bit(POWER_ON, &dev->flags);\r\nif (d->props->frontend_ctrl)\r\nd->props->frontend_ctrl(pdata->dvb_frontend, 0);\r\nif (d->props->power_ctrl)\r\nd->props->power_ctrl(d, 0);\r\nmutex_unlock(&dev->v4l2_lock);\r\n}\r\nstatic int rtl2832_sdr_g_tuner(struct file *file, void *priv,\r\nstruct v4l2_tuner *v)\r\n{\r\nstruct rtl2832_sdr_dev *dev = video_drvdata(file);\r\nstruct platform_device *pdev = dev->pdev;\r\ndev_dbg(&pdev->dev, "index=%d type=%d\n", v->index, v->type);\r\nif (v->index == 0) {\r\nstrlcpy(v->name, "ADC: Realtek RTL2832", sizeof(v->name));\r\nv->type = V4L2_TUNER_ADC;\r\nv->capability = V4L2_TUNER_CAP_1HZ | V4L2_TUNER_CAP_FREQ_BANDS;\r\nv->rangelow = 300000;\r\nv->rangehigh = 3200000;\r\n} else if (v->index == 1) {\r\nstrlcpy(v->name, "RF: <unknown>", sizeof(v->name));\r\nv->type = V4L2_TUNER_RF;\r\nv->capability = V4L2_TUNER_CAP_1HZ | V4L2_TUNER_CAP_FREQ_BANDS;\r\nv->rangelow = 50000000;\r\nv->rangehigh = 2000000000;\r\n} else {\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int rtl2832_sdr_s_tuner(struct file *file, void *priv,\r\nconst struct v4l2_tuner *v)\r\n{\r\nstruct rtl2832_sdr_dev *dev = video_drvdata(file);\r\nstruct platform_device *pdev = dev->pdev;\r\ndev_dbg(&pdev->dev, "\n");\r\nif (v->index > 1)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int rtl2832_sdr_enum_freq_bands(struct file *file, void *priv,\r\nstruct v4l2_frequency_band *band)\r\n{\r\nstruct rtl2832_sdr_dev *dev = video_drvdata(file);\r\nstruct platform_device *pdev = dev->pdev;\r\ndev_dbg(&pdev->dev, "tuner=%d type=%d index=%d\n",\r\nband->tuner, band->type, band->index);\r\nif (band->tuner == 0) {\r\nif (band->index >= ARRAY_SIZE(bands_adc))\r\nreturn -EINVAL;\r\n*band = bands_adc[band->index];\r\n} else if (band->tuner == 1) {\r\nif (band->index >= ARRAY_SIZE(bands_fm))\r\nreturn -EINVAL;\r\n*band = bands_fm[band->index];\r\n} else {\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int rtl2832_sdr_g_frequency(struct file *file, void *priv,\r\nstruct v4l2_frequency *f)\r\n{\r\nstruct rtl2832_sdr_dev *dev = video_drvdata(file);\r\nstruct platform_device *pdev = dev->pdev;\r\nint ret = 0;\r\ndev_dbg(&pdev->dev, "tuner=%d type=%d\n", f->tuner, f->type);\r\nif (f->tuner == 0) {\r\nf->frequency = dev->f_adc;\r\nf->type = V4L2_TUNER_ADC;\r\n} else if (f->tuner == 1) {\r\nf->frequency = dev->f_tuner;\r\nf->type = V4L2_TUNER_RF;\r\n} else {\r\nreturn -EINVAL;\r\n}\r\nreturn ret;\r\n}\r\nstatic int rtl2832_sdr_s_frequency(struct file *file, void *priv,\r\nconst struct v4l2_frequency *f)\r\n{\r\nstruct rtl2832_sdr_dev *dev = video_drvdata(file);\r\nstruct platform_device *pdev = dev->pdev;\r\nint ret, band;\r\ndev_dbg(&pdev->dev, "tuner=%d type=%d frequency=%u\n",\r\nf->tuner, f->type, f->frequency);\r\n#define BAND_ADC_0 ((bands_adc[0].rangehigh + bands_adc[1].rangelow) / 2)\r\n#define BAND_ADC_1 ((bands_adc[1].rangehigh + bands_adc[2].rangelow) / 2)\r\nif (f->tuner == 0 && f->type == V4L2_TUNER_ADC) {\r\nif (f->frequency < BAND_ADC_0)\r\nband = 0;\r\nelse if (f->frequency < BAND_ADC_1)\r\nband = 1;\r\nelse\r\nband = 2;\r\ndev->f_adc = clamp_t(unsigned int, f->frequency,\r\nbands_adc[band].rangelow,\r\nbands_adc[band].rangehigh);\r\ndev_dbg(&pdev->dev, "ADC frequency=%u Hz\n", dev->f_adc);\r\nret = rtl2832_sdr_set_adc(dev);\r\n} else if (f->tuner == 1) {\r\ndev->f_tuner = clamp_t(unsigned int, f->frequency,\r\nbands_fm[0].rangelow,\r\nbands_fm[0].rangehigh);\r\ndev_dbg(&pdev->dev, "RF frequency=%u Hz\n", f->frequency);\r\nret = rtl2832_sdr_set_tuner_freq(dev);\r\n} else {\r\nret = -EINVAL;\r\n}\r\nreturn ret;\r\n}\r\nstatic int rtl2832_sdr_enum_fmt_sdr_cap(struct file *file, void *priv,\r\nstruct v4l2_fmtdesc *f)\r\n{\r\nstruct rtl2832_sdr_dev *dev = video_drvdata(file);\r\nstruct platform_device *pdev = dev->pdev;\r\ndev_dbg(&pdev->dev, "\n");\r\nif (f->index >= dev->num_formats)\r\nreturn -EINVAL;\r\nstrlcpy(f->description, formats[f->index].name, sizeof(f->description));\r\nf->pixelformat = formats[f->index].pixelformat;\r\nreturn 0;\r\n}\r\nstatic int rtl2832_sdr_g_fmt_sdr_cap(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct rtl2832_sdr_dev *dev = video_drvdata(file);\r\nstruct platform_device *pdev = dev->pdev;\r\ndev_dbg(&pdev->dev, "\n");\r\nf->fmt.sdr.pixelformat = dev->pixelformat;\r\nf->fmt.sdr.buffersize = dev->buffersize;\r\nmemset(f->fmt.sdr.reserved, 0, sizeof(f->fmt.sdr.reserved));\r\nreturn 0;\r\n}\r\nstatic int rtl2832_sdr_s_fmt_sdr_cap(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct rtl2832_sdr_dev *dev = video_drvdata(file);\r\nstruct platform_device *pdev = dev->pdev;\r\nstruct vb2_queue *q = &dev->vb_queue;\r\nint i;\r\ndev_dbg(&pdev->dev, "pixelformat fourcc %4.4s\n",\r\n(char *)&f->fmt.sdr.pixelformat);\r\nif (vb2_is_busy(q))\r\nreturn -EBUSY;\r\nmemset(f->fmt.sdr.reserved, 0, sizeof(f->fmt.sdr.reserved));\r\nfor (i = 0; i < dev->num_formats; i++) {\r\nif (formats[i].pixelformat == f->fmt.sdr.pixelformat) {\r\ndev->pixelformat = formats[i].pixelformat;\r\ndev->buffersize = formats[i].buffersize;\r\nf->fmt.sdr.buffersize = formats[i].buffersize;\r\nreturn 0;\r\n}\r\n}\r\ndev->pixelformat = formats[0].pixelformat;\r\ndev->buffersize = formats[0].buffersize;\r\nf->fmt.sdr.pixelformat = formats[0].pixelformat;\r\nf->fmt.sdr.buffersize = formats[0].buffersize;\r\nreturn 0;\r\n}\r\nstatic int rtl2832_sdr_try_fmt_sdr_cap(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct rtl2832_sdr_dev *dev = video_drvdata(file);\r\nstruct platform_device *pdev = dev->pdev;\r\nint i;\r\ndev_dbg(&pdev->dev, "pixelformat fourcc %4.4s\n",\r\n(char *)&f->fmt.sdr.pixelformat);\r\nmemset(f->fmt.sdr.reserved, 0, sizeof(f->fmt.sdr.reserved));\r\nfor (i = 0; i < dev->num_formats; i++) {\r\nif (formats[i].pixelformat == f->fmt.sdr.pixelformat) {\r\nf->fmt.sdr.buffersize = formats[i].buffersize;\r\nreturn 0;\r\n}\r\n}\r\nf->fmt.sdr.pixelformat = formats[0].pixelformat;\r\nf->fmt.sdr.buffersize = formats[0].buffersize;\r\nreturn 0;\r\n}\r\nstatic int rtl2832_sdr_s_ctrl(struct v4l2_ctrl *ctrl)\r\n{\r\nstruct rtl2832_sdr_dev *dev =\r\ncontainer_of(ctrl->handler, struct rtl2832_sdr_dev,\r\nhdl);\r\nstruct platform_device *pdev = dev->pdev;\r\nstruct rtl2832_sdr_platform_data *pdata = pdev->dev.platform_data;\r\nstruct dvb_frontend *fe = pdata->dvb_frontend;\r\nstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\r\nint ret;\r\ndev_dbg(&pdev->dev, "id=%d name=%s val=%d min=%lld max=%lld step=%lld\n",\r\nctrl->id, ctrl->name, ctrl->val, ctrl->minimum, ctrl->maximum,\r\nctrl->step);\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_RF_TUNER_BANDWIDTH_AUTO:\r\ncase V4L2_CID_RF_TUNER_BANDWIDTH:\r\nif (dev->bandwidth_auto->val) {\r\ns32 val = dev->f_adc + div_u64(dev->bandwidth->step, 2);\r\nu32 offset;\r\nval = clamp_t(s32, val, dev->bandwidth->minimum,\r\ndev->bandwidth->maximum);\r\noffset = val - dev->bandwidth->minimum;\r\noffset = dev->bandwidth->step *\r\ndiv_u64(offset, dev->bandwidth->step);\r\ndev->bandwidth->val = dev->bandwidth->minimum + offset;\r\n}\r\nc->bandwidth_hz = dev->bandwidth->val;\r\nif (!test_bit(POWER_ON, &dev->flags))\r\nreturn 0;\r\nif (fe->ops.tuner_ops.set_params)\r\nret = fe->ops.tuner_ops.set_params(fe);\r\nelse\r\nret = 0;\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\n}\r\nreturn ret;\r\n}\r\nstatic void rtl2832_sdr_video_release(struct v4l2_device *v)\r\n{\r\nstruct rtl2832_sdr_dev *dev =\r\ncontainer_of(v, struct rtl2832_sdr_dev, v4l2_dev);\r\nstruct platform_device *pdev = dev->pdev;\r\ndev_dbg(&pdev->dev, "\n");\r\nv4l2_ctrl_handler_free(&dev->hdl);\r\nv4l2_device_unregister(&dev->v4l2_dev);\r\nkfree(dev);\r\n}\r\nstatic int rtl2832_sdr_probe(struct platform_device *pdev)\r\n{\r\nstruct rtl2832_sdr_dev *dev;\r\nstruct rtl2832_sdr_platform_data *pdata = pdev->dev.platform_data;\r\nconst struct v4l2_ctrl_ops *ops = &rtl2832_sdr_ctrl_ops;\r\nstruct v4l2_subdev *subdev;\r\nint ret;\r\ndev_dbg(&pdev->dev, "\n");\r\nif (!pdata) {\r\ndev_err(&pdev->dev, "Cannot proceed without platform data\n");\r\nret = -EINVAL;\r\ngoto err;\r\n}\r\nif (!pdev->dev.parent->driver) {\r\ndev_dbg(&pdev->dev, "No parent device\n");\r\nret = -EINVAL;\r\ngoto err;\r\n}\r\nif (!try_module_get(pdev->dev.parent->driver->owner)) {\r\ndev_err(&pdev->dev, "Refcount fail");\r\nret = -EINVAL;\r\ngoto err;\r\n}\r\ndev = kzalloc(sizeof(*dev), GFP_KERNEL);\r\nif (dev == NULL) {\r\nret = -ENOMEM;\r\ngoto err_module_put;\r\n}\r\nsubdev = pdata->v4l2_subdev;\r\ndev->pdev = pdev;\r\ndev->udev = pdata->dvb_usb_device->udev;\r\ndev->f_adc = bands_adc[0].rangelow;\r\ndev->f_tuner = bands_fm[0].rangelow;\r\ndev->pixelformat = formats[0].pixelformat;\r\ndev->buffersize = formats[0].buffersize;\r\ndev->num_formats = NUM_FORMATS;\r\nif (!rtl2832_sdr_emulated_fmt)\r\ndev->num_formats -= 1;\r\nmutex_init(&dev->v4l2_lock);\r\nmutex_init(&dev->vb_queue_lock);\r\nspin_lock_init(&dev->queued_bufs_lock);\r\nINIT_LIST_HEAD(&dev->queued_bufs);\r\ndev->vb_queue.type = V4L2_BUF_TYPE_SDR_CAPTURE;\r\ndev->vb_queue.io_modes = VB2_MMAP | VB2_USERPTR | VB2_READ;\r\ndev->vb_queue.drv_priv = dev;\r\ndev->vb_queue.buf_struct_size = sizeof(struct rtl2832_sdr_frame_buf);\r\ndev->vb_queue.ops = &rtl2832_sdr_vb2_ops;\r\ndev->vb_queue.mem_ops = &vb2_vmalloc_memops;\r\ndev->vb_queue.timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;\r\nret = vb2_queue_init(&dev->vb_queue);\r\nif (ret) {\r\ndev_err(&pdev->dev, "Could not initialize vb2 queue\n");\r\ngoto err_kfree;\r\n}\r\nswitch (pdata->tuner) {\r\ncase RTL2832_SDR_TUNER_E4000:\r\nv4l2_ctrl_handler_init(&dev->hdl, 9);\r\nif (subdev)\r\nv4l2_ctrl_add_handler(&dev->hdl, subdev->ctrl_handler, NULL);\r\nbreak;\r\ncase RTL2832_SDR_TUNER_R820T:\r\ncase RTL2832_SDR_TUNER_R828D:\r\nv4l2_ctrl_handler_init(&dev->hdl, 2);\r\ndev->bandwidth_auto = v4l2_ctrl_new_std(&dev->hdl, ops,\r\nV4L2_CID_RF_TUNER_BANDWIDTH_AUTO,\r\n0, 1, 1, 1);\r\ndev->bandwidth = v4l2_ctrl_new_std(&dev->hdl, ops,\r\nV4L2_CID_RF_TUNER_BANDWIDTH,\r\n0, 8000000, 100000, 0);\r\nv4l2_ctrl_auto_cluster(2, &dev->bandwidth_auto, 0, false);\r\nbreak;\r\ncase RTL2832_SDR_TUNER_FC0012:\r\ncase RTL2832_SDR_TUNER_FC0013:\r\nv4l2_ctrl_handler_init(&dev->hdl, 2);\r\ndev->bandwidth_auto = v4l2_ctrl_new_std(&dev->hdl, ops,\r\nV4L2_CID_RF_TUNER_BANDWIDTH_AUTO,\r\n0, 1, 1, 1);\r\ndev->bandwidth = v4l2_ctrl_new_std(&dev->hdl, ops,\r\nV4L2_CID_RF_TUNER_BANDWIDTH,\r\n6000000, 8000000, 1000000,\r\n6000000);\r\nv4l2_ctrl_auto_cluster(2, &dev->bandwidth_auto, 0, false);\r\nbreak;\r\ndefault:\r\nv4l2_ctrl_handler_init(&dev->hdl, 0);\r\ndev_err(&pdev->dev, "Unsupported tuner\n");\r\ngoto err_v4l2_ctrl_handler_free;\r\n}\r\nif (dev->hdl.error) {\r\nret = dev->hdl.error;\r\ndev_err(&pdev->dev, "Could not initialize controls\n");\r\ngoto err_v4l2_ctrl_handler_free;\r\n}\r\ndev->vdev = rtl2832_sdr_template;\r\ndev->vdev.queue = &dev->vb_queue;\r\ndev->vdev.queue->lock = &dev->vb_queue_lock;\r\nvideo_set_drvdata(&dev->vdev, dev);\r\ndev->v4l2_dev.release = rtl2832_sdr_video_release;\r\nret = v4l2_device_register(&pdev->dev, &dev->v4l2_dev);\r\nif (ret) {\r\ndev_err(&pdev->dev, "Failed to register v4l2-device %d\n", ret);\r\ngoto err_v4l2_ctrl_handler_free;\r\n}\r\ndev->v4l2_dev.ctrl_handler = &dev->hdl;\r\ndev->vdev.v4l2_dev = &dev->v4l2_dev;\r\ndev->vdev.lock = &dev->v4l2_lock;\r\ndev->vdev.vfl_dir = VFL_DIR_RX;\r\nret = video_register_device(&dev->vdev, VFL_TYPE_SDR, -1);\r\nif (ret) {\r\ndev_err(&pdev->dev, "Failed to register as video device %d\n",\r\nret);\r\ngoto err_v4l2_device_unregister;\r\n}\r\ndev_info(&pdev->dev, "Registered as %s\n",\r\nvideo_device_node_name(&dev->vdev));\r\ndev_info(&pdev->dev, "Realtek RTL2832 SDR attached\n");\r\ndev_notice(&pdev->dev,\r\n"SDR API is still slightly experimental and functionality changes may follow\n");\r\nplatform_set_drvdata(pdev, dev);\r\nreturn 0;\r\nerr_v4l2_device_unregister:\r\nv4l2_device_unregister(&dev->v4l2_dev);\r\nerr_v4l2_ctrl_handler_free:\r\nv4l2_ctrl_handler_free(&dev->hdl);\r\nerr_kfree:\r\nkfree(dev);\r\nerr_module_put:\r\nmodule_put(pdev->dev.parent->driver->owner);\r\nerr:\r\nreturn ret;\r\n}\r\nstatic int rtl2832_sdr_remove(struct platform_device *pdev)\r\n{\r\nstruct rtl2832_sdr_dev *dev = platform_get_drvdata(pdev);\r\ndev_dbg(&pdev->dev, "\n");\r\nmutex_lock(&dev->vb_queue_lock);\r\nmutex_lock(&dev->v4l2_lock);\r\ndev->udev = NULL;\r\nv4l2_device_disconnect(&dev->v4l2_dev);\r\nvideo_unregister_device(&dev->vdev);\r\nmutex_unlock(&dev->v4l2_lock);\r\nmutex_unlock(&dev->vb_queue_lock);\r\nv4l2_device_put(&dev->v4l2_dev);\r\nmodule_put(pdev->dev.parent->driver->owner);\r\nreturn 0;\r\n}
