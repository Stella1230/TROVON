struct rtc_device *alarmtimer_get_rtcdev(void)\r\n{\r\nunsigned long flags;\r\nstruct rtc_device *ret;\r\nspin_lock_irqsave(&rtcdev_lock, flags);\r\nret = rtcdev;\r\nspin_unlock_irqrestore(&rtcdev_lock, flags);\r\nreturn ret;\r\n}\r\nstatic int alarmtimer_rtc_add_device(struct device *dev,\r\nstruct class_interface *class_intf)\r\n{\r\nunsigned long flags;\r\nstruct rtc_device *rtc = to_rtc_device(dev);\r\nif (rtcdev)\r\nreturn -EBUSY;\r\nif (!rtc->ops->set_alarm)\r\nreturn -1;\r\nif (!device_may_wakeup(rtc->dev.parent))\r\nreturn -1;\r\nspin_lock_irqsave(&rtcdev_lock, flags);\r\nif (!rtcdev) {\r\nrtcdev = rtc;\r\nget_device(dev);\r\n}\r\nspin_unlock_irqrestore(&rtcdev_lock, flags);\r\nreturn 0;\r\n}\r\nstatic inline void alarmtimer_rtc_timer_init(void)\r\n{\r\nrtc_timer_init(&rtctimer, NULL, NULL);\r\n}\r\nstatic int alarmtimer_rtc_interface_setup(void)\r\n{\r\nalarmtimer_rtc_interface.class = rtc_class;\r\nreturn class_interface_register(&alarmtimer_rtc_interface);\r\n}\r\nstatic void alarmtimer_rtc_interface_remove(void)\r\n{\r\nclass_interface_unregister(&alarmtimer_rtc_interface);\r\n}\r\nstruct rtc_device *alarmtimer_get_rtcdev(void)\r\n{\r\nreturn NULL;\r\n}\r\nstatic inline int alarmtimer_rtc_interface_setup(void) { return 0; }\r\nstatic inline void alarmtimer_rtc_interface_remove(void) { }\r\nstatic inline void alarmtimer_rtc_timer_init(void) { }\r\nstatic void alarmtimer_enqueue(struct alarm_base *base, struct alarm *alarm)\r\n{\r\nif (alarm->state & ALARMTIMER_STATE_ENQUEUED)\r\ntimerqueue_del(&base->timerqueue, &alarm->node);\r\ntimerqueue_add(&base->timerqueue, &alarm->node);\r\nalarm->state |= ALARMTIMER_STATE_ENQUEUED;\r\n}\r\nstatic void alarmtimer_dequeue(struct alarm_base *base, struct alarm *alarm)\r\n{\r\nif (!(alarm->state & ALARMTIMER_STATE_ENQUEUED))\r\nreturn;\r\ntimerqueue_del(&base->timerqueue, &alarm->node);\r\nalarm->state &= ~ALARMTIMER_STATE_ENQUEUED;\r\n}\r\nstatic enum hrtimer_restart alarmtimer_fired(struct hrtimer *timer)\r\n{\r\nstruct alarm *alarm = container_of(timer, struct alarm, timer);\r\nstruct alarm_base *base = &alarm_bases[alarm->type];\r\nunsigned long flags;\r\nint ret = HRTIMER_NORESTART;\r\nint restart = ALARMTIMER_NORESTART;\r\nspin_lock_irqsave(&base->lock, flags);\r\nalarmtimer_dequeue(base, alarm);\r\nspin_unlock_irqrestore(&base->lock, flags);\r\nif (alarm->function)\r\nrestart = alarm->function(alarm, base->gettime());\r\nspin_lock_irqsave(&base->lock, flags);\r\nif (restart != ALARMTIMER_NORESTART) {\r\nhrtimer_set_expires(&alarm->timer, alarm->node.expires);\r\nalarmtimer_enqueue(base, alarm);\r\nret = HRTIMER_RESTART;\r\n}\r\nspin_unlock_irqrestore(&base->lock, flags);\r\nreturn ret;\r\n}\r\nktime_t alarm_expires_remaining(const struct alarm *alarm)\r\n{\r\nstruct alarm_base *base = &alarm_bases[alarm->type];\r\nreturn ktime_sub(alarm->node.expires, base->gettime());\r\n}\r\nstatic int alarmtimer_suspend(struct device *dev)\r\n{\r\nstruct rtc_time tm;\r\nktime_t min, now;\r\nunsigned long flags;\r\nstruct rtc_device *rtc;\r\nint i;\r\nint ret;\r\nspin_lock_irqsave(&freezer_delta_lock, flags);\r\nmin = freezer_delta;\r\nfreezer_delta = ktime_set(0, 0);\r\nspin_unlock_irqrestore(&freezer_delta_lock, flags);\r\nrtc = alarmtimer_get_rtcdev();\r\nif (!rtc)\r\nreturn 0;\r\nfor (i = 0; i < ALARM_NUMTYPE; i++) {\r\nstruct alarm_base *base = &alarm_bases[i];\r\nstruct timerqueue_node *next;\r\nktime_t delta;\r\nspin_lock_irqsave(&base->lock, flags);\r\nnext = timerqueue_getnext(&base->timerqueue);\r\nspin_unlock_irqrestore(&base->lock, flags);\r\nif (!next)\r\ncontinue;\r\ndelta = ktime_sub(next->expires, base->gettime());\r\nif (!min.tv64 || (delta.tv64 < min.tv64))\r\nmin = delta;\r\n}\r\nif (min.tv64 == 0)\r\nreturn 0;\r\nif (ktime_to_ns(min) < 2 * NSEC_PER_SEC) {\r\n__pm_wakeup_event(ws, 2 * MSEC_PER_SEC);\r\nreturn -EBUSY;\r\n}\r\nrtc_timer_cancel(rtc, &rtctimer);\r\nrtc_read_time(rtc, &tm);\r\nnow = rtc_tm_to_ktime(tm);\r\nnow = ktime_add(now, min);\r\nret = rtc_timer_start(rtc, &rtctimer, now, ktime_set(0, 0));\r\nif (ret < 0)\r\n__pm_wakeup_event(ws, MSEC_PER_SEC);\r\nreturn ret;\r\n}\r\nstatic int alarmtimer_suspend(struct device *dev)\r\n{\r\nreturn 0;\r\n}\r\nstatic void alarmtimer_freezerset(ktime_t absexp, enum alarmtimer_type type)\r\n{\r\nktime_t delta;\r\nunsigned long flags;\r\nstruct alarm_base *base = &alarm_bases[type];\r\ndelta = ktime_sub(absexp, base->gettime());\r\nspin_lock_irqsave(&freezer_delta_lock, flags);\r\nif (!freezer_delta.tv64 || (delta.tv64 < freezer_delta.tv64))\r\nfreezer_delta = delta;\r\nspin_unlock_irqrestore(&freezer_delta_lock, flags);\r\n}\r\nint alarm_start(struct alarm *alarm, ktime_t start)\r\n{\r\nstruct alarm_base *base = &alarm_bases[alarm->type];\r\nunsigned long flags;\r\nint ret;\r\nspin_lock_irqsave(&base->lock, flags);\r\nalarm->node.expires = start;\r\nalarmtimer_enqueue(base, alarm);\r\nret = hrtimer_start(&alarm->timer, alarm->node.expires,\r\nHRTIMER_MODE_ABS);\r\nspin_unlock_irqrestore(&base->lock, flags);\r\nreturn ret;\r\n}\r\nint alarm_start_relative(struct alarm *alarm, ktime_t start)\r\n{\r\nstruct alarm_base *base = &alarm_bases[alarm->type];\r\nstart = ktime_add(start, base->gettime());\r\nreturn alarm_start(alarm, start);\r\n}\r\nvoid alarm_restart(struct alarm *alarm)\r\n{\r\nstruct alarm_base *base = &alarm_bases[alarm->type];\r\nunsigned long flags;\r\nspin_lock_irqsave(&base->lock, flags);\r\nhrtimer_set_expires(&alarm->timer, alarm->node.expires);\r\nhrtimer_restart(&alarm->timer);\r\nalarmtimer_enqueue(base, alarm);\r\nspin_unlock_irqrestore(&base->lock, flags);\r\n}\r\nint alarm_try_to_cancel(struct alarm *alarm)\r\n{\r\nstruct alarm_base *base = &alarm_bases[alarm->type];\r\nunsigned long flags;\r\nint ret;\r\nspin_lock_irqsave(&base->lock, flags);\r\nret = hrtimer_try_to_cancel(&alarm->timer);\r\nif (ret >= 0)\r\nalarmtimer_dequeue(base, alarm);\r\nspin_unlock_irqrestore(&base->lock, flags);\r\nreturn ret;\r\n}\r\nint alarm_cancel(struct alarm *alarm)\r\n{\r\nfor (;;) {\r\nint ret = alarm_try_to_cancel(alarm);\r\nif (ret >= 0)\r\nreturn ret;\r\ncpu_relax();\r\n}\r\n}\r\nu64 alarm_forward(struct alarm *alarm, ktime_t now, ktime_t interval)\r\n{\r\nu64 overrun = 1;\r\nktime_t delta;\r\ndelta = ktime_sub(now, alarm->node.expires);\r\nif (delta.tv64 < 0)\r\nreturn 0;\r\nif (unlikely(delta.tv64 >= interval.tv64)) {\r\ns64 incr = ktime_to_ns(interval);\r\noverrun = ktime_divns(delta, incr);\r\nalarm->node.expires = ktime_add_ns(alarm->node.expires,\r\nincr*overrun);\r\nif (alarm->node.expires.tv64 > now.tv64)\r\nreturn overrun;\r\noverrun++;\r\n}\r\nalarm->node.expires = ktime_add(alarm->node.expires, interval);\r\nreturn overrun;\r\n}\r\nu64 alarm_forward_now(struct alarm *alarm, ktime_t interval)\r\n{\r\nstruct alarm_base *base = &alarm_bases[alarm->type];\r\nreturn alarm_forward(alarm, base->gettime(), interval);\r\n}\r\nstatic enum alarmtimer_type clock2alarm(clockid_t clockid)\r\n{\r\nif (clockid == CLOCK_REALTIME_ALARM)\r\nreturn ALARM_REALTIME;\r\nif (clockid == CLOCK_BOOTTIME_ALARM)\r\nreturn ALARM_BOOTTIME;\r\nreturn -1;\r\n}\r\nstatic enum alarmtimer_restart alarm_handle_timer(struct alarm *alarm,\r\nktime_t now)\r\n{\r\nunsigned long flags;\r\nstruct k_itimer *ptr = container_of(alarm, struct k_itimer,\r\nit.alarm.alarmtimer);\r\nenum alarmtimer_restart result = ALARMTIMER_NORESTART;\r\nspin_lock_irqsave(&ptr->it_lock, flags);\r\nif ((ptr->it_sigev_notify & ~SIGEV_THREAD_ID) != SIGEV_NONE) {\r\nif (posix_timer_event(ptr, 0) != 0)\r\nptr->it_overrun++;\r\n}\r\nif (ptr->it.alarm.interval.tv64) {\r\nptr->it_overrun += alarm_forward(alarm, now,\r\nptr->it.alarm.interval);\r\nresult = ALARMTIMER_RESTART;\r\n}\r\nspin_unlock_irqrestore(&ptr->it_lock, flags);\r\nreturn result;\r\n}\r\nstatic int alarm_clock_getres(const clockid_t which_clock, struct timespec *tp)\r\n{\r\nclockid_t baseid = alarm_bases[clock2alarm(which_clock)].base_clockid;\r\nif (!alarmtimer_get_rtcdev())\r\nreturn -EINVAL;\r\nreturn hrtimer_get_res(baseid, tp);\r\n}\r\nstatic int alarm_clock_get(clockid_t which_clock, struct timespec *tp)\r\n{\r\nstruct alarm_base *base = &alarm_bases[clock2alarm(which_clock)];\r\nif (!alarmtimer_get_rtcdev())\r\nreturn -EINVAL;\r\n*tp = ktime_to_timespec(base->gettime());\r\nreturn 0;\r\n}\r\nstatic int alarm_timer_create(struct k_itimer *new_timer)\r\n{\r\nenum alarmtimer_type type;\r\nstruct alarm_base *base;\r\nif (!alarmtimer_get_rtcdev())\r\nreturn -ENOTSUPP;\r\nif (!capable(CAP_WAKE_ALARM))\r\nreturn -EPERM;\r\ntype = clock2alarm(new_timer->it_clock);\r\nbase = &alarm_bases[type];\r\nalarm_init(&new_timer->it.alarm.alarmtimer, type, alarm_handle_timer);\r\nreturn 0;\r\n}\r\nstatic void alarm_timer_get(struct k_itimer *timr,\r\nstruct itimerspec *cur_setting)\r\n{\r\nktime_t relative_expiry_time =\r\nalarm_expires_remaining(&(timr->it.alarm.alarmtimer));\r\nif (ktime_to_ns(relative_expiry_time) > 0) {\r\ncur_setting->it_value = ktime_to_timespec(relative_expiry_time);\r\n} else {\r\ncur_setting->it_value.tv_sec = 0;\r\ncur_setting->it_value.tv_nsec = 0;\r\n}\r\ncur_setting->it_interval = ktime_to_timespec(timr->it.alarm.interval);\r\n}\r\nstatic int alarm_timer_del(struct k_itimer *timr)\r\n{\r\nif (!rtcdev)\r\nreturn -ENOTSUPP;\r\nif (alarm_try_to_cancel(&timr->it.alarm.alarmtimer) < 0)\r\nreturn TIMER_RETRY;\r\nreturn 0;\r\n}\r\nstatic int alarm_timer_set(struct k_itimer *timr, int flags,\r\nstruct itimerspec *new_setting,\r\nstruct itimerspec *old_setting)\r\n{\r\nktime_t exp;\r\nif (!rtcdev)\r\nreturn -ENOTSUPP;\r\nif (flags & ~TIMER_ABSTIME)\r\nreturn -EINVAL;\r\nif (old_setting)\r\nalarm_timer_get(timr, old_setting);\r\nif (alarm_try_to_cancel(&timr->it.alarm.alarmtimer) < 0)\r\nreturn TIMER_RETRY;\r\ntimr->it.alarm.interval = timespec_to_ktime(new_setting->it_interval);\r\nexp = timespec_to_ktime(new_setting->it_value);\r\nif (flags != TIMER_ABSTIME) {\r\nktime_t now;\r\nnow = alarm_bases[timr->it.alarm.alarmtimer.type].gettime();\r\nexp = ktime_add(now, exp);\r\n}\r\nalarm_start(&timr->it.alarm.alarmtimer, exp);\r\nreturn 0;\r\n}\r\nstatic enum alarmtimer_restart alarmtimer_nsleep_wakeup(struct alarm *alarm,\r\nktime_t now)\r\n{\r\nstruct task_struct *task = (struct task_struct *)alarm->data;\r\nalarm->data = NULL;\r\nif (task)\r\nwake_up_process(task);\r\nreturn ALARMTIMER_NORESTART;\r\n}\r\nstatic int alarmtimer_do_nsleep(struct alarm *alarm, ktime_t absexp)\r\n{\r\nalarm->data = (void *)current;\r\ndo {\r\nset_current_state(TASK_INTERRUPTIBLE);\r\nalarm_start(alarm, absexp);\r\nif (likely(alarm->data))\r\nschedule();\r\nalarm_cancel(alarm);\r\n} while (alarm->data && !signal_pending(current));\r\n__set_current_state(TASK_RUNNING);\r\nreturn (alarm->data == NULL);\r\n}\r\nstatic int update_rmtp(ktime_t exp, enum alarmtimer_type type,\r\nstruct timespec __user *rmtp)\r\n{\r\nstruct timespec rmt;\r\nktime_t rem;\r\nrem = ktime_sub(exp, alarm_bases[type].gettime());\r\nif (rem.tv64 <= 0)\r\nreturn 0;\r\nrmt = ktime_to_timespec(rem);\r\nif (copy_to_user(rmtp, &rmt, sizeof(*rmtp)))\r\nreturn -EFAULT;\r\nreturn 1;\r\n}\r\nstatic long __sched alarm_timer_nsleep_restart(struct restart_block *restart)\r\n{\r\nenum alarmtimer_type type = restart->nanosleep.clockid;\r\nktime_t exp;\r\nstruct timespec __user *rmtp;\r\nstruct alarm alarm;\r\nint ret = 0;\r\nexp.tv64 = restart->nanosleep.expires;\r\nalarm_init(&alarm, type, alarmtimer_nsleep_wakeup);\r\nif (alarmtimer_do_nsleep(&alarm, exp))\r\ngoto out;\r\nif (freezing(current))\r\nalarmtimer_freezerset(exp, type);\r\nrmtp = restart->nanosleep.rmtp;\r\nif (rmtp) {\r\nret = update_rmtp(exp, type, rmtp);\r\nif (ret <= 0)\r\ngoto out;\r\n}\r\nret = -ERESTART_RESTARTBLOCK;\r\nout:\r\nreturn ret;\r\n}\r\nstatic int alarm_timer_nsleep(const clockid_t which_clock, int flags,\r\nstruct timespec *tsreq, struct timespec __user *rmtp)\r\n{\r\nenum alarmtimer_type type = clock2alarm(which_clock);\r\nstruct alarm alarm;\r\nktime_t exp;\r\nint ret = 0;\r\nstruct restart_block *restart;\r\nif (!alarmtimer_get_rtcdev())\r\nreturn -ENOTSUPP;\r\nif (flags & ~TIMER_ABSTIME)\r\nreturn -EINVAL;\r\nif (!capable(CAP_WAKE_ALARM))\r\nreturn -EPERM;\r\nalarm_init(&alarm, type, alarmtimer_nsleep_wakeup);\r\nexp = timespec_to_ktime(*tsreq);\r\nif (flags != TIMER_ABSTIME) {\r\nktime_t now = alarm_bases[type].gettime();\r\nexp = ktime_add(now, exp);\r\n}\r\nif (alarmtimer_do_nsleep(&alarm, exp))\r\ngoto out;\r\nif (freezing(current))\r\nalarmtimer_freezerset(exp, type);\r\nif (flags == TIMER_ABSTIME) {\r\nret = -ERESTARTNOHAND;\r\ngoto out;\r\n}\r\nif (rmtp) {\r\nret = update_rmtp(exp, type, rmtp);\r\nif (ret <= 0)\r\ngoto out;\r\n}\r\nrestart = &current->restart_block;\r\nrestart->fn = alarm_timer_nsleep_restart;\r\nrestart->nanosleep.clockid = type;\r\nrestart->nanosleep.expires = exp.tv64;\r\nrestart->nanosleep.rmtp = rmtp;\r\nret = -ERESTART_RESTARTBLOCK;\r\nout:\r\nreturn ret;\r\n}\r\nstatic int __init alarmtimer_init(void)\r\n{\r\nstruct platform_device *pdev;\r\nint error = 0;\r\nint i;\r\nstruct k_clock alarm_clock = {\r\n.clock_getres = alarm_clock_getres,\r\n.clock_get = alarm_clock_get,\r\n.timer_create = alarm_timer_create,\r\n.timer_set = alarm_timer_set,\r\n.timer_del = alarm_timer_del,\r\n.timer_get = alarm_timer_get,\r\n.nsleep = alarm_timer_nsleep,\r\n};\r\nalarmtimer_rtc_timer_init();\r\nposix_timers_register_clock(CLOCK_REALTIME_ALARM, &alarm_clock);\r\nposix_timers_register_clock(CLOCK_BOOTTIME_ALARM, &alarm_clock);\r\nalarm_bases[ALARM_REALTIME].base_clockid = CLOCK_REALTIME;\r\nalarm_bases[ALARM_REALTIME].gettime = &ktime_get_real;\r\nalarm_bases[ALARM_BOOTTIME].base_clockid = CLOCK_BOOTTIME;\r\nalarm_bases[ALARM_BOOTTIME].gettime = &ktime_get_boottime;\r\nfor (i = 0; i < ALARM_NUMTYPE; i++) {\r\ntimerqueue_init_head(&alarm_bases[i].timerqueue);\r\nspin_lock_init(&alarm_bases[i].lock);\r\n}\r\nerror = alarmtimer_rtc_interface_setup();\r\nif (error)\r\nreturn error;\r\nerror = platform_driver_register(&alarmtimer_driver);\r\nif (error)\r\ngoto out_if;\r\npdev = platform_device_register_simple("alarmtimer", -1, NULL, 0);\r\nif (IS_ERR(pdev)) {\r\nerror = PTR_ERR(pdev);\r\ngoto out_drv;\r\n}\r\nws = wakeup_source_register("alarmtimer");\r\nreturn 0;\r\nout_drv:\r\nplatform_driver_unregister(&alarmtimer_driver);\r\nout_if:\r\nalarmtimer_rtc_interface_remove();\r\nreturn error;\r\n}
