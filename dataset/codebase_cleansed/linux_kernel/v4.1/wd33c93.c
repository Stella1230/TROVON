static inline uchar\r\nread_wd33c93(const wd33c93_regs regs, uchar reg_num)\r\n{\r\nuchar data;\r\noutb(reg_num, regs.SASR);\r\ndata = inb(regs.SCMD);\r\nreturn data;\r\n}\r\nstatic inline unsigned long\r\nread_wd33c93_count(const wd33c93_regs regs)\r\n{\r\nunsigned long value;\r\noutb(WD_TRANSFER_COUNT_MSB, regs.SASR);\r\nvalue = inb(regs.SCMD) << 16;\r\nvalue |= inb(regs.SCMD) << 8;\r\nvalue |= inb(regs.SCMD);\r\nreturn value;\r\n}\r\nstatic inline uchar\r\nread_aux_stat(const wd33c93_regs regs)\r\n{\r\nreturn inb(regs.SASR);\r\n}\r\nstatic inline void\r\nwrite_wd33c93(const wd33c93_regs regs, uchar reg_num, uchar value)\r\n{\r\noutb(reg_num, regs.SASR);\r\noutb(value, regs.SCMD);\r\n}\r\nstatic inline void\r\nwrite_wd33c93_count(const wd33c93_regs regs, unsigned long value)\r\n{\r\noutb(WD_TRANSFER_COUNT_MSB, regs.SASR);\r\noutb((value >> 16) & 0xff, regs.SCMD);\r\noutb((value >> 8) & 0xff, regs.SCMD);\r\noutb( value & 0xff, regs.SCMD);\r\n}\r\nstatic inline void\r\nwrite_wd33c93_cdb(const wd33c93_regs regs, uint len, uchar cmnd[])\r\n{\r\nint i;\r\noutb(WD_CDB_1, regs.SASR);\r\nfor (i=0; i<len; i++)\r\noutb(cmnd[i], regs.SCMD);\r\n}\r\nstatic inline uchar\r\nread_wd33c93(const wd33c93_regs regs, uchar reg_num)\r\n{\r\n*regs.SASR = reg_num;\r\nmb();\r\nreturn (*regs.SCMD);\r\n}\r\nstatic unsigned long\r\nread_wd33c93_count(const wd33c93_regs regs)\r\n{\r\nunsigned long value;\r\n*regs.SASR = WD_TRANSFER_COUNT_MSB;\r\nmb();\r\nvalue = *regs.SCMD << 16;\r\nvalue |= *regs.SCMD << 8;\r\nvalue |= *regs.SCMD;\r\nmb();\r\nreturn value;\r\n}\r\nstatic inline uchar\r\nread_aux_stat(const wd33c93_regs regs)\r\n{\r\nreturn *regs.SASR;\r\n}\r\nstatic inline void\r\nwrite_wd33c93(const wd33c93_regs regs, uchar reg_num, uchar value)\r\n{\r\n*regs.SASR = reg_num;\r\nmb();\r\n*regs.SCMD = value;\r\nmb();\r\n}\r\nstatic void\r\nwrite_wd33c93_count(const wd33c93_regs regs, unsigned long value)\r\n{\r\n*regs.SASR = WD_TRANSFER_COUNT_MSB;\r\nmb();\r\n*regs.SCMD = value >> 16;\r\n*regs.SCMD = value >> 8;\r\n*regs.SCMD = value;\r\nmb();\r\n}\r\nstatic inline void\r\nwrite_wd33c93_cmd(const wd33c93_regs regs, uchar cmd)\r\n{\r\n*regs.SASR = WD_COMMAND;\r\nmb();\r\n*regs.SCMD = cmd;\r\nmb();\r\n}\r\nstatic inline void\r\nwrite_wd33c93_cdb(const wd33c93_regs regs, uint len, uchar cmnd[])\r\n{\r\nint i;\r\n*regs.SASR = WD_CDB_1;\r\nfor (i = 0; i < len; i++)\r\n*regs.SCMD = cmnd[i];\r\n}\r\nstatic inline uchar\r\nread_1_byte(const wd33c93_regs regs)\r\n{\r\nuchar asr;\r\nuchar x = 0;\r\nwrite_wd33c93(regs, WD_CONTROL, CTRL_IDI | CTRL_EDI | CTRL_POLLED);\r\nwrite_wd33c93_cmd(regs, WD_CMD_TRANS_INFO | 0x80);\r\ndo {\r\nasr = read_aux_stat(regs);\r\nif (asr & ASR_DBR)\r\nx = read_wd33c93(regs, WD_DATA);\r\n} while (!(asr & ASR_INT));\r\nreturn x;\r\n}\r\nstatic int\r\nround_period(unsigned int period, const struct sx_period *sx_table)\r\n{\r\nint x;\r\nfor (x = 1; sx_table[x].period_ns; x++) {\r\nif ((period <= sx_table[x - 0].period_ns) &&\r\n(period > sx_table[x - 1].period_ns)) {\r\nreturn x;\r\n}\r\n}\r\nreturn 7;\r\n}\r\nstatic uchar\r\ncalc_sync_xfer(unsigned int period, unsigned int offset, unsigned int fast,\r\nconst struct sx_period *sx_table)\r\n{\r\nuchar result;\r\nif (offset && fast) {\r\nfast = STR_FSS;\r\nperiod *= 2;\r\n} else {\r\nfast = 0;\r\n}\r\nperiod *= 4;\r\nresult = sx_table[round_period(period,sx_table)].reg_value;\r\nresult |= (offset < OPTIMUM_SX_OFF) ? offset : OPTIMUM_SX_OFF;\r\nresult |= fast;\r\nreturn result;\r\n}\r\nstatic inline void\r\ncalc_sync_msg(unsigned int period, unsigned int offset, unsigned int fast,\r\nuchar msg[2])\r\n{\r\nperiod /= 4;\r\nif (offset && fast)\r\nperiod /= 2;\r\nmsg[0] = period;\r\nmsg[1] = offset;\r\n}\r\nstatic int\r\nwd33c93_queuecommand_lck(struct scsi_cmnd *cmd,\r\nvoid (*done)(struct scsi_cmnd *))\r\n{\r\nstruct WD33C93_hostdata *hostdata;\r\nstruct scsi_cmnd *tmp;\r\nhostdata = (struct WD33C93_hostdata *) cmd->device->host->hostdata;\r\nDB(DB_QUEUE_COMMAND,\r\nprintk("Q-%d-%02x( ", cmd->device->id, cmd->cmnd[0]))\r\ncmd->host_scribble = NULL;\r\ncmd->scsi_done = done;\r\ncmd->result = 0;\r\nif (scsi_bufflen(cmd)) {\r\ncmd->SCp.buffer = scsi_sglist(cmd);\r\ncmd->SCp.buffers_residual = scsi_sg_count(cmd) - 1;\r\ncmd->SCp.ptr = sg_virt(cmd->SCp.buffer);\r\ncmd->SCp.this_residual = cmd->SCp.buffer->length;\r\n} else {\r\ncmd->SCp.buffer = NULL;\r\ncmd->SCp.buffers_residual = 0;\r\ncmd->SCp.ptr = NULL;\r\ncmd->SCp.this_residual = 0;\r\n}\r\ncmd->SCp.Status = ILLEGAL_STATUS_BYTE;\r\nspin_lock_irq(&hostdata->lock);\r\nif (!(hostdata->input_Q) || (cmd->cmnd[0] == REQUEST_SENSE)) {\r\ncmd->host_scribble = (uchar *) hostdata->input_Q;\r\nhostdata->input_Q = cmd;\r\n} else {\r\nfor (tmp = (struct scsi_cmnd *) hostdata->input_Q;\r\ntmp->host_scribble;\r\ntmp = (struct scsi_cmnd *) tmp->host_scribble) ;\r\ntmp->host_scribble = (uchar *) cmd;\r\n}\r\nwd33c93_execute(cmd->device->host);\r\nDB(DB_QUEUE_COMMAND, printk(")Q "))\r\nspin_unlock_irq(&hostdata->lock);\r\nreturn 0;\r\n}\r\nstatic void\r\nwd33c93_execute(struct Scsi_Host *instance)\r\n{\r\nstruct WD33C93_hostdata *hostdata =\r\n(struct WD33C93_hostdata *) instance->hostdata;\r\nconst wd33c93_regs regs = hostdata->regs;\r\nstruct scsi_cmnd *cmd, *prev;\r\nDB(DB_EXECUTE, printk("EX("))\r\nif (hostdata->selecting || hostdata->connected) {\r\nDB(DB_EXECUTE, printk(")EX-0 "))\r\nreturn;\r\n}\r\ncmd = (struct scsi_cmnd *) hostdata->input_Q;\r\nprev = NULL;\r\nwhile (cmd) {\r\nif (!(hostdata->busy[cmd->device->id] &\r\n(1 << (cmd->device->lun & 0xff))))\r\nbreak;\r\nprev = cmd;\r\ncmd = (struct scsi_cmnd *) cmd->host_scribble;\r\n}\r\nif (!cmd) {\r\nDB(DB_EXECUTE, printk(")EX-1 "))\r\nreturn;\r\n}\r\nif (prev)\r\nprev->host_scribble = cmd->host_scribble;\r\nelse\r\nhostdata->input_Q = (struct scsi_cmnd *) cmd->host_scribble;\r\n#ifdef PROC_STATISTICS\r\nhostdata->cmd_cnt[cmd->device->id]++;\r\n#endif\r\nif (cmd->sc_data_direction == DMA_TO_DEVICE)\r\nwrite_wd33c93(regs, WD_DESTINATION_ID, cmd->device->id);\r\nelse\r\nwrite_wd33c93(regs, WD_DESTINATION_ID, cmd->device->id | DSTID_DPD);\r\ncmd->SCp.phase = 0;\r\nif (hostdata->disconnect == DIS_NEVER)\r\ngoto no;\r\nif (hostdata->disconnect == DIS_ALWAYS)\r\ngoto yes;\r\nif (cmd->device->type == 1)\r\ngoto yes;\r\nif (hostdata->disconnected_Q)\r\ngoto yes;\r\nif (!(hostdata->input_Q))\r\ngoto no;\r\nfor (prev = (struct scsi_cmnd *) hostdata->input_Q; prev;\r\nprev = (struct scsi_cmnd *) prev->host_scribble) {\r\nif ((prev->device->id != cmd->device->id) ||\r\n(prev->device->lun != cmd->device->lun)) {\r\nfor (prev = (struct scsi_cmnd *) hostdata->input_Q; prev;\r\nprev = (struct scsi_cmnd *) prev->host_scribble)\r\nprev->SCp.phase = 1;\r\ngoto yes;\r\n}\r\n}\r\ngoto no;\r\nyes:\r\ncmd->SCp.phase = 1;\r\n#ifdef PROC_STATISTICS\r\nhostdata->disc_allowed_cnt[cmd->device->id]++;\r\n#endif\r\nno:\r\nwrite_wd33c93(regs, WD_SOURCE_ID, ((cmd->SCp.phase) ? SRCID_ER : 0));\r\nwrite_wd33c93(regs, WD_TARGET_LUN, (u8)cmd->device->lun);\r\nwrite_wd33c93(regs, WD_SYNCHRONOUS_TRANSFER,\r\nhostdata->sync_xfer[cmd->device->id]);\r\nhostdata->busy[cmd->device->id] |= (1 << (cmd->device->lun & 0xFF));\r\nif ((hostdata->level2 == L2_NONE) ||\r\n(hostdata->sync_stat[cmd->device->id] == SS_UNSET)) {\r\nhostdata->selecting = cmd;\r\nif (hostdata->sync_stat[cmd->device->id] == SS_UNSET)\r\nhostdata->sync_stat[cmd->device->id] = SS_FIRST;\r\nhostdata->state = S_SELECTING;\r\nwrite_wd33c93_count(regs, 0);\r\nwrite_wd33c93_cmd(regs, WD_CMD_SEL_ATN);\r\n} else {\r\nhostdata->connected = cmd;\r\nwrite_wd33c93(regs, WD_COMMAND_PHASE, 0);\r\nwrite_wd33c93_cdb(regs, cmd->cmd_len, cmd->cmnd);\r\nwrite_wd33c93(regs, WD_OWN_ID, cmd->cmd_len);\r\nif ((cmd->SCp.phase == 0) && (hostdata->no_dma == 0)) {\r\nif (hostdata->dma_setup(cmd,\r\n(cmd->sc_data_direction == DMA_TO_DEVICE) ?\r\nDATA_OUT_DIR : DATA_IN_DIR))\r\nwrite_wd33c93_count(regs, 0);\r\nelse {\r\nwrite_wd33c93_count(regs,\r\ncmd->SCp.this_residual);\r\nwrite_wd33c93(regs, WD_CONTROL,\r\nCTRL_IDI | CTRL_EDI | hostdata->dma_mode);\r\nhostdata->dma = D_DMA_RUNNING;\r\n}\r\n} else\r\nwrite_wd33c93_count(regs, 0);\r\nhostdata->state = S_RUNNING_LEVEL2;\r\nwrite_wd33c93_cmd(regs, WD_CMD_SEL_ATN_XFER);\r\n}\r\nDB(DB_EXECUTE,\r\nprintk("%s)EX-2 ", (cmd->SCp.phase) ? "d:" : ""))\r\n}\r\nstatic void\r\ntransfer_pio(const wd33c93_regs regs, uchar * buf, int cnt,\r\nint data_in_dir, struct WD33C93_hostdata *hostdata)\r\n{\r\nuchar asr;\r\nDB(DB_TRANSFER,\r\nprintk("(%p,%d,%s:", buf, cnt, data_in_dir ? "in" : "out"))\r\nwrite_wd33c93(regs, WD_CONTROL, CTRL_IDI | CTRL_EDI | CTRL_POLLED);\r\nwrite_wd33c93_count(regs, cnt);\r\nwrite_wd33c93_cmd(regs, WD_CMD_TRANS_INFO);\r\nif (data_in_dir) {\r\ndo {\r\nasr = read_aux_stat(regs);\r\nif (asr & ASR_DBR)\r\n*buf++ = read_wd33c93(regs, WD_DATA);\r\n} while (!(asr & ASR_INT));\r\n} else {\r\ndo {\r\nasr = read_aux_stat(regs);\r\nif (asr & ASR_DBR)\r\nwrite_wd33c93(regs, WD_DATA, *buf++);\r\n} while (!(asr & ASR_INT));\r\n}\r\n}\r\nstatic void\r\ntransfer_bytes(const wd33c93_regs regs, struct scsi_cmnd *cmd,\r\nint data_in_dir)\r\n{\r\nstruct WD33C93_hostdata *hostdata;\r\nunsigned long length;\r\nhostdata = (struct WD33C93_hostdata *) cmd->device->host->hostdata;\r\nif (!cmd->SCp.this_residual && cmd->SCp.buffers_residual) {\r\n++cmd->SCp.buffer;\r\n--cmd->SCp.buffers_residual;\r\ncmd->SCp.this_residual = cmd->SCp.buffer->length;\r\ncmd->SCp.ptr = sg_virt(cmd->SCp.buffer);\r\n}\r\nif (!cmd->SCp.this_residual)\r\nreturn;\r\nwrite_wd33c93(regs, WD_SYNCHRONOUS_TRANSFER,\r\nhostdata->sync_xfer[cmd->device->id]);\r\nif (hostdata->no_dma || hostdata->dma_setup(cmd, data_in_dir)) {\r\n#ifdef PROC_STATISTICS\r\nhostdata->pio_cnt++;\r\n#endif\r\ntransfer_pio(regs, (uchar *) cmd->SCp.ptr,\r\ncmd->SCp.this_residual, data_in_dir, hostdata);\r\nlength = cmd->SCp.this_residual;\r\ncmd->SCp.this_residual = read_wd33c93_count(regs);\r\ncmd->SCp.ptr += (length - cmd->SCp.this_residual);\r\n}\r\nelse {\r\n#ifdef PROC_STATISTICS\r\nhostdata->dma_cnt++;\r\n#endif\r\nwrite_wd33c93(regs, WD_CONTROL, CTRL_IDI | CTRL_EDI | hostdata->dma_mode);\r\nwrite_wd33c93_count(regs, cmd->SCp.this_residual);\r\nif ((hostdata->level2 >= L2_DATA) ||\r\n(hostdata->level2 == L2_BASIC && cmd->SCp.phase == 0)) {\r\nwrite_wd33c93(regs, WD_COMMAND_PHASE, 0x45);\r\nwrite_wd33c93_cmd(regs, WD_CMD_SEL_ATN_XFER);\r\nhostdata->state = S_RUNNING_LEVEL2;\r\n} else\r\nwrite_wd33c93_cmd(regs, WD_CMD_TRANS_INFO);\r\nhostdata->dma = D_DMA_RUNNING;\r\n}\r\n}\r\nvoid\r\nwd33c93_intr(struct Scsi_Host *instance)\r\n{\r\nstruct WD33C93_hostdata *hostdata =\r\n(struct WD33C93_hostdata *) instance->hostdata;\r\nconst wd33c93_regs regs = hostdata->regs;\r\nstruct scsi_cmnd *patch, *cmd;\r\nuchar asr, sr, phs, id, lun, *ucp, msg;\r\nunsigned long length, flags;\r\nasr = read_aux_stat(regs);\r\nif (!(asr & ASR_INT) || (asr & ASR_BSY))\r\nreturn;\r\nspin_lock_irqsave(&hostdata->lock, flags);\r\n#ifdef PROC_STATISTICS\r\nhostdata->int_cnt++;\r\n#endif\r\ncmd = (struct scsi_cmnd *) hostdata->connected;\r\nsr = read_wd33c93(regs, WD_SCSI_STATUS);\r\nphs = read_wd33c93(regs, WD_COMMAND_PHASE);\r\nDB(DB_INTR, printk("{%02x:%02x-", asr, sr))\r\nif (hostdata->dma == D_DMA_RUNNING) {\r\nDB(DB_TRANSFER,\r\nprintk("[%p/%d:", cmd->SCp.ptr, cmd->SCp.this_residual))\r\nhostdata->dma_stop(cmd->device->host, cmd, 1);\r\nhostdata->dma = D_DMA_OFF;\r\nlength = cmd->SCp.this_residual;\r\ncmd->SCp.this_residual = read_wd33c93_count(regs);\r\ncmd->SCp.ptr += (length - cmd->SCp.this_residual);\r\nDB(DB_TRANSFER,\r\nprintk("%p/%d]", cmd->SCp.ptr, cmd->SCp.this_residual))\r\n}\r\nswitch (sr) {\r\ncase CSR_TIMEOUT:\r\nDB(DB_INTR, printk("TIMEOUT"))\r\nif (hostdata->state == S_RUNNING_LEVEL2)\r\nhostdata->connected = NULL;\r\nelse {\r\ncmd = (struct scsi_cmnd *) hostdata->selecting;\r\nhostdata->selecting = NULL;\r\n}\r\ncmd->result = DID_NO_CONNECT << 16;\r\nhostdata->busy[cmd->device->id] &= ~(1 << (cmd->device->lun & 0xff));\r\nhostdata->state = S_UNCONNECTED;\r\ncmd->scsi_done(cmd);\r\nspin_unlock_irqrestore(&hostdata->lock, flags);\r\nwd33c93_execute(instance);\r\nbreak;\r\ncase CSR_SELECT:\r\nDB(DB_INTR, printk("SELECT"))\r\nhostdata->connected = cmd =\r\n(struct scsi_cmnd *) hostdata->selecting;\r\nhostdata->selecting = NULL;\r\nhostdata->outgoing_msg[0] = IDENTIFY(0, cmd->device->lun);\r\nif (cmd->SCp.phase)\r\nhostdata->outgoing_msg[0] |= 0x40;\r\nif (hostdata->sync_stat[cmd->device->id] == SS_FIRST) {\r\nhostdata->sync_stat[cmd->device->id] = SS_WAITING;\r\nhostdata->outgoing_msg[1] = EXTENDED_MESSAGE;\r\nhostdata->outgoing_msg[2] = 3;\r\nhostdata->outgoing_msg[3] = EXTENDED_SDTR;\r\nif (hostdata->no_sync & (1 << cmd->device->id)) {\r\ncalc_sync_msg(hostdata->default_sx_per, 0,\r\n0, hostdata->outgoing_msg + 4);\r\n} else {\r\ncalc_sync_msg(optimum_sx_per(hostdata),\r\nOPTIMUM_SX_OFF,\r\nhostdata->fast,\r\nhostdata->outgoing_msg + 4);\r\n}\r\nhostdata->outgoing_len = 6;\r\n#ifdef SYNC_DEBUG\r\nucp = hostdata->outgoing_msg + 1;\r\nprintk(" sending SDTR %02x03%02x%02x%02x ",\r\nucp[0], ucp[2], ucp[3], ucp[4]);\r\n#endif\r\n} else\r\nhostdata->outgoing_len = 1;\r\nhostdata->state = S_CONNECTED;\r\nspin_unlock_irqrestore(&hostdata->lock, flags);\r\nbreak;\r\ncase CSR_XFER_DONE | PHS_DATA_IN:\r\ncase CSR_UNEXP | PHS_DATA_IN:\r\ncase CSR_SRV_REQ | PHS_DATA_IN:\r\nDB(DB_INTR,\r\nprintk("IN-%d.%d", cmd->SCp.this_residual,\r\ncmd->SCp.buffers_residual))\r\ntransfer_bytes(regs, cmd, DATA_IN_DIR);\r\nif (hostdata->state != S_RUNNING_LEVEL2)\r\nhostdata->state = S_CONNECTED;\r\nspin_unlock_irqrestore(&hostdata->lock, flags);\r\nbreak;\r\ncase CSR_XFER_DONE | PHS_DATA_OUT:\r\ncase CSR_UNEXP | PHS_DATA_OUT:\r\ncase CSR_SRV_REQ | PHS_DATA_OUT:\r\nDB(DB_INTR,\r\nprintk("OUT-%d.%d", cmd->SCp.this_residual,\r\ncmd->SCp.buffers_residual))\r\ntransfer_bytes(regs, cmd, DATA_OUT_DIR);\r\nif (hostdata->state != S_RUNNING_LEVEL2)\r\nhostdata->state = S_CONNECTED;\r\nspin_unlock_irqrestore(&hostdata->lock, flags);\r\nbreak;\r\ncase CSR_XFER_DONE | PHS_COMMAND:\r\ncase CSR_UNEXP | PHS_COMMAND:\r\ncase CSR_SRV_REQ | PHS_COMMAND:\r\nDB(DB_INTR, printk("CMND-%02x", cmd->cmnd[0]))\r\ntransfer_pio(regs, cmd->cmnd, cmd->cmd_len, DATA_OUT_DIR,\r\nhostdata);\r\nhostdata->state = S_CONNECTED;\r\nspin_unlock_irqrestore(&hostdata->lock, flags);\r\nbreak;\r\ncase CSR_XFER_DONE | PHS_STATUS:\r\ncase CSR_UNEXP | PHS_STATUS:\r\ncase CSR_SRV_REQ | PHS_STATUS:\r\nDB(DB_INTR, printk("STATUS="))\r\ncmd->SCp.Status = read_1_byte(regs);\r\nDB(DB_INTR, printk("%02x", cmd->SCp.Status))\r\nif (hostdata->level2 >= L2_BASIC) {\r\nsr = read_wd33c93(regs, WD_SCSI_STATUS);\r\nudelay(7);\r\nhostdata->state = S_RUNNING_LEVEL2;\r\nwrite_wd33c93(regs, WD_COMMAND_PHASE, 0x50);\r\nwrite_wd33c93_cmd(regs, WD_CMD_SEL_ATN_XFER);\r\n} else {\r\nhostdata->state = S_CONNECTED;\r\n}\r\nspin_unlock_irqrestore(&hostdata->lock, flags);\r\nbreak;\r\ncase CSR_XFER_DONE | PHS_MESS_IN:\r\ncase CSR_UNEXP | PHS_MESS_IN:\r\ncase CSR_SRV_REQ | PHS_MESS_IN:\r\nDB(DB_INTR, printk("MSG_IN="))\r\nmsg = read_1_byte(regs);\r\nsr = read_wd33c93(regs, WD_SCSI_STATUS);\r\nudelay(7);\r\nhostdata->incoming_msg[hostdata->incoming_ptr] = msg;\r\nif (hostdata->incoming_msg[0] == EXTENDED_MESSAGE)\r\nmsg = EXTENDED_MESSAGE;\r\nelse\r\nhostdata->incoming_ptr = 0;\r\ncmd->SCp.Message = msg;\r\nswitch (msg) {\r\ncase COMMAND_COMPLETE:\r\nDB(DB_INTR, printk("CCMP"))\r\nwrite_wd33c93_cmd(regs, WD_CMD_NEGATE_ACK);\r\nhostdata->state = S_PRE_CMP_DISC;\r\nbreak;\r\ncase SAVE_POINTERS:\r\nDB(DB_INTR, printk("SDP"))\r\nwrite_wd33c93_cmd(regs, WD_CMD_NEGATE_ACK);\r\nhostdata->state = S_CONNECTED;\r\nbreak;\r\ncase RESTORE_POINTERS:\r\nDB(DB_INTR, printk("RDP"))\r\nif (hostdata->level2 >= L2_BASIC) {\r\nwrite_wd33c93(regs, WD_COMMAND_PHASE, 0x45);\r\nwrite_wd33c93_cmd(regs, WD_CMD_SEL_ATN_XFER);\r\nhostdata->state = S_RUNNING_LEVEL2;\r\n} else {\r\nwrite_wd33c93_cmd(regs, WD_CMD_NEGATE_ACK);\r\nhostdata->state = S_CONNECTED;\r\n}\r\nbreak;\r\ncase DISCONNECT:\r\nDB(DB_INTR, printk("DIS"))\r\ncmd->device->disconnect = 1;\r\nwrite_wd33c93_cmd(regs, WD_CMD_NEGATE_ACK);\r\nhostdata->state = S_PRE_TMP_DISC;\r\nbreak;\r\ncase MESSAGE_REJECT:\r\nDB(DB_INTR, printk("REJ"))\r\n#ifdef SYNC_DEBUG\r\nprintk("-REJ-");\r\n#endif\r\nif (hostdata->sync_stat[cmd->device->id] == SS_WAITING) {\r\nhostdata->sync_stat[cmd->device->id] = SS_SET;\r\nhostdata->sync_xfer[cmd->device->id] =\r\ncalc_sync_xfer(hostdata->default_sx_per\r\n/ 4, 0, 0, hostdata->sx_table);\r\n}\r\nwrite_wd33c93_cmd(regs, WD_CMD_NEGATE_ACK);\r\nhostdata->state = S_CONNECTED;\r\nbreak;\r\ncase EXTENDED_MESSAGE:\r\nDB(DB_INTR, printk("EXT"))\r\nucp = hostdata->incoming_msg;\r\n#ifdef SYNC_DEBUG\r\nprintk("%02x", ucp[hostdata->incoming_ptr]);\r\n#endif\r\nif ((hostdata->incoming_ptr >= 2) &&\r\n(hostdata->incoming_ptr == (ucp[1] + 1))) {\r\nswitch (ucp[2]) {\r\ncase EXTENDED_SDTR:\r\nid = calc_sync_xfer(hostdata->\r\ndefault_sx_per / 4, 0,\r\n0, hostdata->sx_table);\r\nif (hostdata->sync_stat[cmd->device->id] !=\r\nSS_WAITING) {\r\nwrite_wd33c93_cmd(regs, WD_CMD_ASSERT_ATN);\r\nhostdata->outgoing_msg[0] =\r\nEXTENDED_MESSAGE;\r\nhostdata->outgoing_msg[1] = 3;\r\nhostdata->outgoing_msg[2] =\r\nEXTENDED_SDTR;\r\ncalc_sync_msg(hostdata->\r\ndefault_sx_per, 0,\r\n0, hostdata->outgoing_msg + 3);\r\nhostdata->outgoing_len = 5;\r\n} else {\r\nif (ucp[4])\r\nid = calc_sync_xfer(ucp[3], ucp[4],\r\nhostdata->fast,\r\nhostdata->sx_table);\r\nelse if (ucp[3])\r\nid = calc_sync_xfer(ucp[3], ucp[4],\r\n0, hostdata->sx_table);\r\n}\r\nhostdata->sync_xfer[cmd->device->id] = id;\r\n#ifdef SYNC_DEBUG\r\nprintk(" sync_xfer=%02x\n",\r\nhostdata->sync_xfer[cmd->device->id]);\r\n#endif\r\nhostdata->sync_stat[cmd->device->id] =\r\nSS_SET;\r\nwrite_wd33c93_cmd(regs,\r\nWD_CMD_NEGATE_ACK);\r\nhostdata->state = S_CONNECTED;\r\nbreak;\r\ncase EXTENDED_WDTR:\r\nwrite_wd33c93_cmd(regs, WD_CMD_ASSERT_ATN);\r\nprintk("sending WDTR ");\r\nhostdata->outgoing_msg[0] =\r\nEXTENDED_MESSAGE;\r\nhostdata->outgoing_msg[1] = 2;\r\nhostdata->outgoing_msg[2] =\r\nEXTENDED_WDTR;\r\nhostdata->outgoing_msg[3] = 0;\r\nhostdata->outgoing_len = 4;\r\nwrite_wd33c93_cmd(regs,\r\nWD_CMD_NEGATE_ACK);\r\nhostdata->state = S_CONNECTED;\r\nbreak;\r\ndefault:\r\nwrite_wd33c93_cmd(regs, WD_CMD_ASSERT_ATN);\r\nprintk\r\n("Rejecting Unknown Extended Message(%02x). ",\r\nucp[2]);\r\nhostdata->outgoing_msg[0] =\r\nMESSAGE_REJECT;\r\nhostdata->outgoing_len = 1;\r\nwrite_wd33c93_cmd(regs,\r\nWD_CMD_NEGATE_ACK);\r\nhostdata->state = S_CONNECTED;\r\nbreak;\r\n}\r\nhostdata->incoming_ptr = 0;\r\n}\r\nelse {\r\nhostdata->incoming_ptr++;\r\nwrite_wd33c93_cmd(regs, WD_CMD_NEGATE_ACK);\r\nhostdata->state = S_CONNECTED;\r\n}\r\nbreak;\r\ndefault:\r\nprintk("Rejecting Unknown Message(%02x) ", msg);\r\nwrite_wd33c93_cmd(regs, WD_CMD_ASSERT_ATN);\r\nhostdata->outgoing_msg[0] = MESSAGE_REJECT;\r\nhostdata->outgoing_len = 1;\r\nwrite_wd33c93_cmd(regs, WD_CMD_NEGATE_ACK);\r\nhostdata->state = S_CONNECTED;\r\n}\r\nspin_unlock_irqrestore(&hostdata->lock, flags);\r\nbreak;\r\ncase CSR_SEL_XFER_DONE:\r\nwrite_wd33c93(regs, WD_SOURCE_ID, SRCID_ER);\r\nif (phs == 0x60) {\r\nDB(DB_INTR, printk("SX-DONE"))\r\ncmd->SCp.Message = COMMAND_COMPLETE;\r\nlun = read_wd33c93(regs, WD_TARGET_LUN);\r\nDB(DB_INTR, printk(":%d.%d", cmd->SCp.Status, lun))\r\nhostdata->connected = NULL;\r\nhostdata->busy[cmd->device->id] &= ~(1 << (cmd->device->lun & 0xff));\r\nhostdata->state = S_UNCONNECTED;\r\nif (cmd->SCp.Status == ILLEGAL_STATUS_BYTE)\r\ncmd->SCp.Status = lun;\r\nif (cmd->cmnd[0] == REQUEST_SENSE\r\n&& cmd->SCp.Status != GOOD)\r\ncmd->result =\r\n(cmd->\r\nresult & 0x00ffff) | (DID_ERROR << 16);\r\nelse\r\ncmd->result =\r\ncmd->SCp.Status | (cmd->SCp.Message << 8);\r\ncmd->scsi_done(cmd);\r\nspin_unlock_irqrestore(&hostdata->lock, flags);\r\nwd33c93_execute(instance);\r\n} else {\r\nprintk\r\n("%02x:%02x:%02x: Unknown SEL_XFER_DONE phase!!---",\r\nasr, sr, phs);\r\nspin_unlock_irqrestore(&hostdata->lock, flags);\r\n}\r\nbreak;\r\ncase CSR_SDP:\r\nDB(DB_INTR, printk("SDP"))\r\nhostdata->state = S_RUNNING_LEVEL2;\r\nwrite_wd33c93(regs, WD_COMMAND_PHASE, 0x41);\r\nwrite_wd33c93_cmd(regs, WD_CMD_SEL_ATN_XFER);\r\nspin_unlock_irqrestore(&hostdata->lock, flags);\r\nbreak;\r\ncase CSR_XFER_DONE | PHS_MESS_OUT:\r\ncase CSR_UNEXP | PHS_MESS_OUT:\r\ncase CSR_SRV_REQ | PHS_MESS_OUT:\r\nDB(DB_INTR, printk("MSG_OUT="))\r\nif (hostdata->outgoing_len == 0) {\r\nhostdata->outgoing_len = 1;\r\nhostdata->outgoing_msg[0] = NOP;\r\n}\r\ntransfer_pio(regs, hostdata->outgoing_msg,\r\nhostdata->outgoing_len, DATA_OUT_DIR, hostdata);\r\nDB(DB_INTR, printk("%02x", hostdata->outgoing_msg[0]))\r\nhostdata->outgoing_len = 0;\r\nhostdata->state = S_CONNECTED;\r\nspin_unlock_irqrestore(&hostdata->lock, flags);\r\nbreak;\r\ncase CSR_UNEXP_DISC:\r\nwrite_wd33c93(regs, WD_SOURCE_ID, SRCID_ER);\r\nif (cmd == NULL) {\r\nprintk(" - Already disconnected! ");\r\nhostdata->state = S_UNCONNECTED;\r\nspin_unlock_irqrestore(&hostdata->lock, flags);\r\nreturn;\r\n}\r\nDB(DB_INTR, printk("UNEXP_DISC"))\r\nhostdata->connected = NULL;\r\nhostdata->busy[cmd->device->id] &= ~(1 << (cmd->device->lun & 0xff));\r\nhostdata->state = S_UNCONNECTED;\r\nif (cmd->cmnd[0] == REQUEST_SENSE && cmd->SCp.Status != GOOD)\r\ncmd->result =\r\n(cmd->result & 0x00ffff) | (DID_ERROR << 16);\r\nelse\r\ncmd->result = cmd->SCp.Status | (cmd->SCp.Message << 8);\r\ncmd->scsi_done(cmd);\r\nspin_unlock_irqrestore(&hostdata->lock, flags);\r\nwd33c93_execute(instance);\r\nbreak;\r\ncase CSR_DISC:\r\nwrite_wd33c93(regs, WD_SOURCE_ID, SRCID_ER);\r\nDB(DB_INTR, printk("DISC"))\r\nif (cmd == NULL) {\r\nprintk(" - Already disconnected! ");\r\nhostdata->state = S_UNCONNECTED;\r\n}\r\nswitch (hostdata->state) {\r\ncase S_PRE_CMP_DISC:\r\nhostdata->connected = NULL;\r\nhostdata->busy[cmd->device->id] &= ~(1 << (cmd->device->lun & 0xff));\r\nhostdata->state = S_UNCONNECTED;\r\nDB(DB_INTR, printk(":%d", cmd->SCp.Status))\r\nif (cmd->cmnd[0] == REQUEST_SENSE\r\n&& cmd->SCp.Status != GOOD)\r\ncmd->result =\r\n(cmd->\r\nresult & 0x00ffff) | (DID_ERROR << 16);\r\nelse\r\ncmd->result =\r\ncmd->SCp.Status | (cmd->SCp.Message << 8);\r\ncmd->scsi_done(cmd);\r\nbreak;\r\ncase S_PRE_TMP_DISC:\r\ncase S_RUNNING_LEVEL2:\r\ncmd->host_scribble = (uchar *) hostdata->disconnected_Q;\r\nhostdata->disconnected_Q = cmd;\r\nhostdata->connected = NULL;\r\nhostdata->state = S_UNCONNECTED;\r\n#ifdef PROC_STATISTICS\r\nhostdata->disc_done_cnt[cmd->device->id]++;\r\n#endif\r\nbreak;\r\ndefault:\r\nprintk("*** Unexpected DISCONNECT interrupt! ***");\r\nhostdata->state = S_UNCONNECTED;\r\n}\r\nspin_unlock_irqrestore(&hostdata->lock, flags);\r\nwd33c93_execute(instance);\r\nbreak;\r\ncase CSR_RESEL_AM:\r\ncase CSR_RESEL:\r\nDB(DB_INTR, printk("RESEL%s", sr == CSR_RESEL_AM ? "_AM" : ""))\r\nif (hostdata->level2 <= L2_NONE) {\r\nif (hostdata->selecting) {\r\ncmd = (struct scsi_cmnd *) hostdata->selecting;\r\nhostdata->selecting = NULL;\r\nhostdata->busy[cmd->device->id] &= ~(1 << (cmd->device->lun & 0xff));\r\ncmd->host_scribble =\r\n(uchar *) hostdata->input_Q;\r\nhostdata->input_Q = cmd;\r\n}\r\n}\r\nelse {\r\nif (cmd) {\r\nif (phs == 0x00) {\r\nhostdata->busy[cmd->device->id] &=\r\n~(1 << (cmd->device->lun & 0xff));\r\ncmd->host_scribble =\r\n(uchar *) hostdata->input_Q;\r\nhostdata->input_Q = cmd;\r\n} else {\r\nprintk\r\n("---%02x:%02x:%02x-TROUBLE: Intrusive ReSelect!---",\r\nasr, sr, phs);\r\nwhile (1)\r\nprintk("\r");\r\n}\r\n}\r\n}\r\nid = read_wd33c93(regs, WD_SOURCE_ID);\r\nid &= SRCID_MASK;\r\nif (sr == CSR_RESEL_AM) {\r\nlun = read_wd33c93(regs, WD_DATA);\r\nif (hostdata->level2 < L2_RESELECT)\r\nwrite_wd33c93_cmd(regs, WD_CMD_NEGATE_ACK);\r\nlun &= 7;\r\n} else {\r\nfor (lun = 255; lun; lun--) {\r\nif ((asr = read_aux_stat(regs)) & ASR_INT)\r\nbreak;\r\nudelay(10);\r\n}\r\nif (!(asr & ASR_INT)) {\r\nprintk\r\n("wd33c93: Reselected without IDENTIFY\n");\r\nlun = 0;\r\n} else {\r\nsr = read_wd33c93(regs, WD_SCSI_STATUS);\r\nudelay(7);\r\nif (sr == (CSR_ABORT | PHS_MESS_IN) ||\r\nsr == (CSR_UNEXP | PHS_MESS_IN) ||\r\nsr == (CSR_SRV_REQ | PHS_MESS_IN)) {\r\nlun = read_1_byte(regs);\r\nasr = read_aux_stat(regs);\r\nif (!(asr & ASR_INT)) {\r\nudelay(10);\r\nasr = read_aux_stat(regs);\r\nif (!(asr & ASR_INT))\r\nprintk\r\n("wd33c93: No int after LUN on RESEL (%02x)\n",\r\nasr);\r\n}\r\nsr = read_wd33c93(regs, WD_SCSI_STATUS);\r\nudelay(7);\r\nif (sr != CSR_MSGIN)\r\nprintk\r\n("wd33c93: Not paused with ACK on RESEL (%02x)\n",\r\nsr);\r\nlun &= 7;\r\nwrite_wd33c93_cmd(regs,\r\nWD_CMD_NEGATE_ACK);\r\n} else {\r\nprintk\r\n("wd33c93: Not MSG_IN on reselect (%02x)\n",\r\nsr);\r\nlun = 0;\r\n}\r\n}\r\n}\r\ncmd = (struct scsi_cmnd *) hostdata->disconnected_Q;\r\npatch = NULL;\r\nwhile (cmd) {\r\nif (id == cmd->device->id && lun == (u8)cmd->device->lun)\r\nbreak;\r\npatch = cmd;\r\ncmd = (struct scsi_cmnd *) cmd->host_scribble;\r\n}\r\nif (!cmd) {\r\nprintk\r\n("---TROUBLE: target %d.%d not in disconnect queue---",\r\nid, (u8)lun);\r\nspin_unlock_irqrestore(&hostdata->lock, flags);\r\nreturn;\r\n}\r\nif (patch)\r\npatch->host_scribble = cmd->host_scribble;\r\nelse\r\nhostdata->disconnected_Q =\r\n(struct scsi_cmnd *) cmd->host_scribble;\r\nhostdata->connected = cmd;\r\nif (cmd->sc_data_direction == DMA_TO_DEVICE)\r\nwrite_wd33c93(regs, WD_DESTINATION_ID, cmd->device->id);\r\nelse\r\nwrite_wd33c93(regs, WD_DESTINATION_ID,\r\ncmd->device->id | DSTID_DPD);\r\nif (hostdata->level2 >= L2_RESELECT) {\r\nwrite_wd33c93_count(regs, 0);\r\nwrite_wd33c93(regs, WD_COMMAND_PHASE, 0x45);\r\nwrite_wd33c93_cmd(regs, WD_CMD_SEL_ATN_XFER);\r\nhostdata->state = S_RUNNING_LEVEL2;\r\n} else\r\nhostdata->state = S_CONNECTED;\r\nspin_unlock_irqrestore(&hostdata->lock, flags);\r\nbreak;\r\ndefault:\r\nprintk("--UNKNOWN INTERRUPT:%02x:%02x:%02x--", asr, sr, phs);\r\nspin_unlock_irqrestore(&hostdata->lock, flags);\r\n}\r\nDB(DB_INTR, printk("} "))\r\n}\r\nstatic void\r\nreset_wd33c93(struct Scsi_Host *instance)\r\n{\r\nstruct WD33C93_hostdata *hostdata =\r\n(struct WD33C93_hostdata *) instance->hostdata;\r\nconst wd33c93_regs regs = hostdata->regs;\r\nuchar sr;\r\n#ifdef CONFIG_SGI_IP22\r\n{\r\nint busycount = 0;\r\nextern void sgiwd93_reset(unsigned long);\r\nwhile ((read_aux_stat(regs) & ASR_BSY) && busycount++ < 100)\r\nudelay (10);\r\nif (read_aux_stat(regs) & ASR_BSY)\r\nsgiwd93_reset(instance->base);\r\n}\r\n#endif\r\nwrite_wd33c93(regs, WD_OWN_ID, OWNID_EAF | OWNID_RAF |\r\ninstance->this_id | hostdata->clock_freq);\r\nwrite_wd33c93(regs, WD_CONTROL, CTRL_IDI | CTRL_EDI | CTRL_POLLED);\r\nwrite_wd33c93(regs, WD_SYNCHRONOUS_TRANSFER,\r\ncalc_sync_xfer(hostdata->default_sx_per / 4,\r\nDEFAULT_SX_OFF, 0, hostdata->sx_table));\r\nwrite_wd33c93(regs, WD_COMMAND, WD_CMD_RESET);\r\n#ifdef CONFIG_MVME147_SCSI\r\nudelay(25);\r\n#endif\r\nwhile (!(read_aux_stat(regs) & ASR_INT))\r\n;\r\nsr = read_wd33c93(regs, WD_SCSI_STATUS);\r\nhostdata->microcode = read_wd33c93(regs, WD_CDB_1);\r\nif (sr == 0x00)\r\nhostdata->chip = C_WD33C93;\r\nelse if (sr == 0x01) {\r\nwrite_wd33c93(regs, WD_QUEUE_TAG, 0xa5);\r\nsr = read_wd33c93(regs, WD_QUEUE_TAG);\r\nif (sr == 0xa5) {\r\nhostdata->chip = C_WD33C93B;\r\nwrite_wd33c93(regs, WD_QUEUE_TAG, 0);\r\n} else\r\nhostdata->chip = C_WD33C93A;\r\n} else\r\nhostdata->chip = C_UNKNOWN_CHIP;\r\nif (hostdata->chip != C_WD33C93B)\r\nhostdata->fast = 0;\r\nwrite_wd33c93(regs, WD_TIMEOUT_PERIOD, TIMEOUT_PERIOD_VALUE);\r\nwrite_wd33c93(regs, WD_CONTROL, CTRL_IDI | CTRL_EDI | CTRL_POLLED);\r\n}\r\nint\r\nwd33c93_host_reset(struct scsi_cmnd * SCpnt)\r\n{\r\nstruct Scsi_Host *instance;\r\nstruct WD33C93_hostdata *hostdata;\r\nint i;\r\ninstance = SCpnt->device->host;\r\nhostdata = (struct WD33C93_hostdata *) instance->hostdata;\r\nprintk("scsi%d: reset. ", instance->host_no);\r\ndisable_irq(instance->irq);\r\nhostdata->dma_stop(instance, NULL, 0);\r\nfor (i = 0; i < 8; i++) {\r\nhostdata->busy[i] = 0;\r\nhostdata->sync_xfer[i] =\r\ncalc_sync_xfer(DEFAULT_SX_PER / 4, DEFAULT_SX_OFF,\r\n0, hostdata->sx_table);\r\nhostdata->sync_stat[i] = SS_UNSET;\r\n}\r\nhostdata->input_Q = NULL;\r\nhostdata->selecting = NULL;\r\nhostdata->connected = NULL;\r\nhostdata->disconnected_Q = NULL;\r\nhostdata->state = S_UNCONNECTED;\r\nhostdata->dma = D_DMA_OFF;\r\nhostdata->incoming_ptr = 0;\r\nhostdata->outgoing_len = 0;\r\nreset_wd33c93(instance);\r\nSCpnt->result = DID_RESET << 16;\r\nenable_irq(instance->irq);\r\nreturn SUCCESS;\r\n}\r\nint\r\nwd33c93_abort(struct scsi_cmnd * cmd)\r\n{\r\nstruct Scsi_Host *instance;\r\nstruct WD33C93_hostdata *hostdata;\r\nwd33c93_regs regs;\r\nstruct scsi_cmnd *tmp, *prev;\r\ndisable_irq(cmd->device->host->irq);\r\ninstance = cmd->device->host;\r\nhostdata = (struct WD33C93_hostdata *) instance->hostdata;\r\nregs = hostdata->regs;\r\ntmp = (struct scsi_cmnd *) hostdata->input_Q;\r\nprev = NULL;\r\nwhile (tmp) {\r\nif (tmp == cmd) {\r\nif (prev)\r\nprev->host_scribble = cmd->host_scribble;\r\nelse\r\nhostdata->input_Q =\r\n(struct scsi_cmnd *) cmd->host_scribble;\r\ncmd->host_scribble = NULL;\r\ncmd->result = DID_ABORT << 16;\r\nprintk\r\n("scsi%d: Abort - removing command from input_Q. ",\r\ninstance->host_no);\r\nenable_irq(cmd->device->host->irq);\r\ncmd->scsi_done(cmd);\r\nreturn SUCCESS;\r\n}\r\nprev = tmp;\r\ntmp = (struct scsi_cmnd *) tmp->host_scribble;\r\n}\r\nif (hostdata->connected == cmd) {\r\nuchar sr, asr;\r\nunsigned long timeout;\r\nprintk("scsi%d: Aborting connected command - ",\r\ninstance->host_no);\r\nprintk("stopping DMA - ");\r\nif (hostdata->dma == D_DMA_RUNNING) {\r\nhostdata->dma_stop(instance, cmd, 0);\r\nhostdata->dma = D_DMA_OFF;\r\n}\r\nprintk("sending wd33c93 ABORT command - ");\r\nwrite_wd33c93(regs, WD_CONTROL,\r\nCTRL_IDI | CTRL_EDI | CTRL_POLLED);\r\nwrite_wd33c93_cmd(regs, WD_CMD_ABORT);\r\nprintk("flushing fifo - ");\r\ntimeout = 1000000;\r\ndo {\r\nasr = read_aux_stat(regs);\r\nif (asr & ASR_DBR)\r\nread_wd33c93(regs, WD_DATA);\r\n} while (!(asr & ASR_INT) && timeout-- > 0);\r\nsr = read_wd33c93(regs, WD_SCSI_STATUS);\r\nprintk\r\n("asr=%02x, sr=%02x, %ld bytes un-transferred (timeout=%ld) - ",\r\nasr, sr, read_wd33c93_count(regs), timeout);\r\nprintk("sending wd33c93 DISCONNECT command - ");\r\nwrite_wd33c93_cmd(regs, WD_CMD_DISCONNECT);\r\ntimeout = 1000000;\r\nasr = read_aux_stat(regs);\r\nwhile ((asr & ASR_CIP) && timeout-- > 0)\r\nasr = read_aux_stat(regs);\r\nsr = read_wd33c93(regs, WD_SCSI_STATUS);\r\nprintk("asr=%02x, sr=%02x.", asr, sr);\r\nhostdata->busy[cmd->device->id] &= ~(1 << (cmd->device->lun & 0xff));\r\nhostdata->connected = NULL;\r\nhostdata->state = S_UNCONNECTED;\r\ncmd->result = DID_ABORT << 16;\r\nwd33c93_execute(instance);\r\nenable_irq(cmd->device->host->irq);\r\ncmd->scsi_done(cmd);\r\nreturn SUCCESS;\r\n}\r\ntmp = (struct scsi_cmnd *) hostdata->disconnected_Q;\r\nwhile (tmp) {\r\nif (tmp == cmd) {\r\nprintk\r\n("scsi%d: Abort - command found on disconnected_Q - ",\r\ninstance->host_no);\r\nprintk("Abort SNOOZE. ");\r\nenable_irq(cmd->device->host->irq);\r\nreturn FAILED;\r\n}\r\ntmp = (struct scsi_cmnd *) tmp->host_scribble;\r\n}\r\nwd33c93_execute(instance);\r\nenable_irq(cmd->device->host->irq);\r\nprintk("scsi%d: warning : SCSI command probably completed successfully"\r\n" before abortion. ", instance->host_no);\r\nreturn FAILED;\r\n}\r\nstatic int\r\nwd33c93_setup(char *str)\r\n{\r\nint i;\r\nchar *p1, *p2;\r\np1 = setup_buffer;\r\n*p1 = '\0';\r\nif (str)\r\nstrncpy(p1, str, SETUP_BUFFER_SIZE - strlen(setup_buffer));\r\nsetup_buffer[SETUP_BUFFER_SIZE - 1] = '\0';\r\np1 = setup_buffer;\r\ni = 0;\r\nwhile (*p1 && (i < MAX_SETUP_ARGS)) {\r\np2 = strchr(p1, ',');\r\nif (p2) {\r\n*p2 = '\0';\r\nif (p1 != p2)\r\nsetup_args[i] = p1;\r\np1 = p2 + 1;\r\ni++;\r\n} else {\r\nsetup_args[i] = p1;\r\nbreak;\r\n}\r\n}\r\nfor (i = 0; i < MAX_SETUP_ARGS; i++)\r\nsetup_used[i] = 0;\r\ndone_setup = 1;\r\nreturn 1;\r\n}\r\nstatic int\r\ncheck_setup_args(char *key, int *flags, int *val, char *buf)\r\n{\r\nint x;\r\nchar *cp;\r\nfor (x = 0; x < MAX_SETUP_ARGS; x++) {\r\nif (setup_used[x])\r\ncontinue;\r\nif (!strncmp(setup_args[x], key, strlen(key)))\r\nbreak;\r\nif (!strncmp(setup_args[x], "next", strlen("next")))\r\nreturn 0;\r\n}\r\nif (x == MAX_SETUP_ARGS)\r\nreturn 0;\r\nsetup_used[x] = 1;\r\ncp = setup_args[x] + strlen(key);\r\n*val = -1;\r\nif (*cp != ':')\r\nreturn ++x;\r\ncp++;\r\nif ((*cp >= '0') && (*cp <= '9')) {\r\n*val = simple_strtoul(cp, NULL, 0);\r\n}\r\nreturn ++x;\r\n}\r\nstatic inline unsigned int\r\nround_4(unsigned int x)\r\n{\r\nswitch (x & 3) {\r\ncase 1: --x;\r\nbreak;\r\ncase 2: ++x;\r\ncase 3: ++x;\r\n}\r\nreturn x;\r\n}\r\nstatic void\r\ncalc_sx_table(unsigned int mhz, struct sx_period sx_table[9])\r\n{\r\nunsigned int d, i;\r\nif (mhz < 11)\r\nd = 2;\r\nelse if (mhz < 16)\r\nd = 3;\r\nelse\r\nd = 4;\r\nd = (100000 * d) / 2 / mhz;\r\nsx_table[0].period_ns = 1;\r\nsx_table[0].reg_value = 0x20;\r\nfor (i = 1; i < 8; i++) {\r\nsx_table[i].period_ns = round_4((i+1)*d / 100);\r\nsx_table[i].reg_value = (i+1)*0x10;\r\n}\r\nsx_table[7].reg_value = 0;\r\nsx_table[8].period_ns = 0;\r\nsx_table[8].reg_value = 0;\r\n}\r\nstatic uchar\r\nset_clk_freq(int freq, int *mhz)\r\n{\r\nint x = freq;\r\nif (WD33C93_FS_8_10 == freq)\r\nfreq = 8;\r\nelse if (WD33C93_FS_12_15 == freq)\r\nfreq = 12;\r\nelse if (WD33C93_FS_16_20 == freq)\r\nfreq = 16;\r\nelse if (freq > 7 && freq < 11)\r\nx = WD33C93_FS_8_10;\r\nelse if (freq > 11 && freq < 16)\r\nx = WD33C93_FS_12_15;\r\nelse if (freq > 15 && freq < 21)\r\nx = WD33C93_FS_16_20;\r\nelse {\r\nx = WD33C93_FS_8_10;\r\nfreq = 8;\r\n}\r\n*mhz = freq;\r\nreturn x;\r\n}\r\nstatic inline void set_resync ( struct WD33C93_hostdata *hd, int mask )\r\n{\r\nint i;\r\nfor (i = 0; i < 8; i++)\r\nif (mask & (1 << i))\r\nhd->sync_stat[i] = SS_UNSET;\r\n}\r\nvoid\r\nwd33c93_init(struct Scsi_Host *instance, const wd33c93_regs regs,\r\ndma_setup_t setup, dma_stop_t stop, int clock_freq)\r\n{\r\nstruct WD33C93_hostdata *hostdata;\r\nint i;\r\nint flags;\r\nint val;\r\nchar buf[32];\r\nif (!done_setup && setup_strings)\r\nwd33c93_setup(setup_strings);\r\nhostdata = (struct WD33C93_hostdata *) instance->hostdata;\r\nhostdata->regs = regs;\r\nhostdata->clock_freq = set_clk_freq(clock_freq, &i);\r\ncalc_sx_table(i, hostdata->sx_table);\r\nhostdata->dma_setup = setup;\r\nhostdata->dma_stop = stop;\r\nhostdata->dma_bounce_buffer = NULL;\r\nhostdata->dma_bounce_len = 0;\r\nfor (i = 0; i < 8; i++) {\r\nhostdata->busy[i] = 0;\r\nhostdata->sync_xfer[i] =\r\ncalc_sync_xfer(DEFAULT_SX_PER / 4, DEFAULT_SX_OFF,\r\n0, hostdata->sx_table);\r\nhostdata->sync_stat[i] = SS_UNSET;\r\n#ifdef PROC_STATISTICS\r\nhostdata->cmd_cnt[i] = 0;\r\nhostdata->disc_allowed_cnt[i] = 0;\r\nhostdata->disc_done_cnt[i] = 0;\r\n#endif\r\n}\r\nhostdata->input_Q = NULL;\r\nhostdata->selecting = NULL;\r\nhostdata->connected = NULL;\r\nhostdata->disconnected_Q = NULL;\r\nhostdata->state = S_UNCONNECTED;\r\nhostdata->dma = D_DMA_OFF;\r\nhostdata->level2 = L2_BASIC;\r\nhostdata->disconnect = DIS_ADAPTIVE;\r\nhostdata->args = DEBUG_DEFAULTS;\r\nhostdata->incoming_ptr = 0;\r\nhostdata->outgoing_len = 0;\r\nhostdata->default_sx_per = DEFAULT_SX_PER;\r\nhostdata->no_dma = 0;\r\n#ifdef PROC_INTERFACE\r\nhostdata->proc = PR_VERSION | PR_INFO | PR_STATISTICS |\r\nPR_CONNECTED | PR_INPUTQ | PR_DISCQ | PR_STOP;\r\n#ifdef PROC_STATISTICS\r\nhostdata->dma_cnt = 0;\r\nhostdata->pio_cnt = 0;\r\nhostdata->int_cnt = 0;\r\n#endif\r\n#endif\r\nif (check_setup_args("clock", &flags, &val, buf)) {\r\nhostdata->clock_freq = set_clk_freq(val, &val);\r\ncalc_sx_table(val, hostdata->sx_table);\r\n}\r\nif (check_setup_args("nosync", &flags, &val, buf))\r\nhostdata->no_sync = val;\r\nif (check_setup_args("nodma", &flags, &val, buf))\r\nhostdata->no_dma = (val == -1) ? 1 : val;\r\nif (check_setup_args("period", &flags, &val, buf))\r\nhostdata->default_sx_per =\r\nhostdata->sx_table[round_period((unsigned int) val,\r\nhostdata->sx_table)].period_ns;\r\nif (check_setup_args("disconnect", &flags, &val, buf)) {\r\nif ((val >= DIS_NEVER) && (val <= DIS_ALWAYS))\r\nhostdata->disconnect = val;\r\nelse\r\nhostdata->disconnect = DIS_ADAPTIVE;\r\n}\r\nif (check_setup_args("level2", &flags, &val, buf))\r\nhostdata->level2 = val;\r\nif (check_setup_args("debug", &flags, &val, buf))\r\nhostdata->args = val & DB_MASK;\r\nif (check_setup_args("burst", &flags, &val, buf))\r\nhostdata->dma_mode = val ? CTRL_BURST:CTRL_DMA;\r\nif (WD33C93_FS_16_20 == hostdata->clock_freq\r\n&& check_setup_args("fast", &flags, &val, buf))\r\nhostdata->fast = !!val;\r\nif ((i = check_setup_args("next", &flags, &val, buf))) {\r\nwhile (i)\r\nsetup_used[--i] = 1;\r\n}\r\n#ifdef PROC_INTERFACE\r\nif (check_setup_args("proc", &flags, &val, buf))\r\nhostdata->proc = val;\r\n#endif\r\nspin_lock_irq(&hostdata->lock);\r\nreset_wd33c93(instance);\r\nspin_unlock_irq(&hostdata->lock);\r\nprintk("wd33c93-%d: chip=%s/%d no_sync=0x%x no_dma=%d",\r\ninstance->host_no,\r\n(hostdata->chip == C_WD33C93) ? "WD33c93" : (hostdata->chip ==\r\nC_WD33C93A) ?\r\n"WD33c93A" : (hostdata->chip ==\r\nC_WD33C93B) ? "WD33c93B" : "unknown",\r\nhostdata->microcode, hostdata->no_sync, hostdata->no_dma);\r\n#ifdef DEBUGGING_ON\r\nprintk(" debug_flags=0x%02x\n", hostdata->args);\r\n#else\r\nprintk(" debugging=OFF\n");\r\n#endif\r\nprintk(" setup_args=");\r\nfor (i = 0; i < MAX_SETUP_ARGS; i++)\r\nprintk("%s,", setup_args[i]);\r\nprintk("\n");\r\nprintk(" Version %s - %s\n", WD33C93_VERSION, WD33C93_DATE);\r\n}\r\nint wd33c93_write_info(struct Scsi_Host *instance, char *buf, int len)\r\n{\r\n#ifdef PROC_INTERFACE\r\nchar *bp;\r\nstruct WD33C93_hostdata *hd;\r\nint x;\r\nhd = (struct WD33C93_hostdata *) instance->hostdata;\r\nbuf[len] = '\0';\r\nfor (bp = buf; *bp; ) {\r\nwhile (',' == *bp || ' ' == *bp)\r\n++bp;\r\nif (!strncmp(bp, "debug:", 6)) {\r\nhd->args = simple_strtoul(bp+6, &bp, 0) & DB_MASK;\r\n} else if (!strncmp(bp, "disconnect:", 11)) {\r\nx = simple_strtoul(bp+11, &bp, 0);\r\nif (x < DIS_NEVER || x > DIS_ALWAYS)\r\nx = DIS_ADAPTIVE;\r\nhd->disconnect = x;\r\n} else if (!strncmp(bp, "period:", 7)) {\r\nx = simple_strtoul(bp+7, &bp, 0);\r\nhd->default_sx_per =\r\nhd->sx_table[round_period((unsigned int) x,\r\nhd->sx_table)].period_ns;\r\n} else if (!strncmp(bp, "resync:", 7)) {\r\nset_resync(hd, (int)simple_strtoul(bp+7, &bp, 0));\r\n} else if (!strncmp(bp, "proc:", 5)) {\r\nhd->proc = simple_strtoul(bp+5, &bp, 0);\r\n} else if (!strncmp(bp, "nodma:", 6)) {\r\nhd->no_dma = simple_strtoul(bp+6, &bp, 0);\r\n} else if (!strncmp(bp, "level2:", 7)) {\r\nhd->level2 = simple_strtoul(bp+7, &bp, 0);\r\n} else if (!strncmp(bp, "burst:", 6)) {\r\nhd->dma_mode =\r\nsimple_strtol(bp+6, &bp, 0) ? CTRL_BURST:CTRL_DMA;\r\n} else if (!strncmp(bp, "fast:", 5)) {\r\nx = !!simple_strtol(bp+5, &bp, 0);\r\nif (x != hd->fast)\r\nset_resync(hd, 0xff);\r\nhd->fast = x;\r\n} else if (!strncmp(bp, "nosync:", 7)) {\r\nx = simple_strtoul(bp+7, &bp, 0);\r\nset_resync(hd, x ^ hd->no_sync);\r\nhd->no_sync = x;\r\n} else {\r\nbreak;\r\n}\r\n}\r\nreturn len;\r\n#else\r\nreturn 0;\r\n#endif\r\n}\r\nint\r\nwd33c93_show_info(struct seq_file *m, struct Scsi_Host *instance)\r\n{\r\n#ifdef PROC_INTERFACE\r\nstruct WD33C93_hostdata *hd;\r\nstruct scsi_cmnd *cmd;\r\nint x;\r\nhd = (struct WD33C93_hostdata *) instance->hostdata;\r\nspin_lock_irq(&hd->lock);\r\nif (hd->proc & PR_VERSION)\r\nseq_printf(m, "\nVersion %s - %s.",\r\nWD33C93_VERSION, WD33C93_DATE);\r\nif (hd->proc & PR_INFO) {\r\nseq_printf(m, "\nclock_freq=%02x no_sync=%02x no_dma=%d"\r\n" dma_mode=%02x fast=%d",\r\nhd->clock_freq, hd->no_sync, hd->no_dma, hd->dma_mode, hd->fast);\r\nseq_puts(m, "\nsync_xfer[] = ");\r\nfor (x = 0; x < 7; x++)\r\nseq_printf(m, "\t%02x", hd->sync_xfer[x]);\r\nseq_puts(m, "\nsync_stat[] = ");\r\nfor (x = 0; x < 7; x++)\r\nseq_printf(m, "\t%02x", hd->sync_stat[x]);\r\n}\r\n#ifdef PROC_STATISTICS\r\nif (hd->proc & PR_STATISTICS) {\r\nseq_puts(m, "\ncommands issued: ");\r\nfor (x = 0; x < 7; x++)\r\nseq_printf(m, "\t%ld", hd->cmd_cnt[x]);\r\nseq_puts(m, "\ndisconnects allowed:");\r\nfor (x = 0; x < 7; x++)\r\nseq_printf(m, "\t%ld", hd->disc_allowed_cnt[x]);\r\nseq_puts(m, "\ndisconnects done: ");\r\nfor (x = 0; x < 7; x++)\r\nseq_printf(m, "\t%ld", hd->disc_done_cnt[x]);\r\nseq_printf(m,\r\n"\ninterrupts: %ld, DATA_PHASE ints: %ld DMA, %ld PIO",\r\nhd->int_cnt, hd->dma_cnt, hd->pio_cnt);\r\n}\r\n#endif\r\nif (hd->proc & PR_CONNECTED) {\r\nseq_puts(m, "\nconnected: ");\r\nif (hd->connected) {\r\ncmd = (struct scsi_cmnd *) hd->connected;\r\nseq_printf(m, " %d:%llu(%02x)",\r\ncmd->device->id, cmd->device->lun, cmd->cmnd[0]);\r\n}\r\n}\r\nif (hd->proc & PR_INPUTQ) {\r\nseq_puts(m, "\ninput_Q: ");\r\ncmd = (struct scsi_cmnd *) hd->input_Q;\r\nwhile (cmd) {\r\nseq_printf(m, " %d:%llu(%02x)",\r\ncmd->device->id, cmd->device->lun, cmd->cmnd[0]);\r\ncmd = (struct scsi_cmnd *) cmd->host_scribble;\r\n}\r\n}\r\nif (hd->proc & PR_DISCQ) {\r\nseq_puts(m, "\ndisconnected_Q:");\r\ncmd = (struct scsi_cmnd *) hd->disconnected_Q;\r\nwhile (cmd) {\r\nseq_printf(m, " %d:%llu(%02x)",\r\ncmd->device->id, cmd->device->lun, cmd->cmnd[0]);\r\ncmd = (struct scsi_cmnd *) cmd->host_scribble;\r\n}\r\n}\r\nseq_putc(m, '\n');\r\nspin_unlock_irq(&hd->lock);\r\n#endif\r\nreturn 0;\r\n}
