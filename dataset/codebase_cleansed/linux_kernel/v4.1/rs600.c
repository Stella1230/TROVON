static bool avivo_is_in_vblank(struct radeon_device *rdev, int crtc)\r\n{\r\nif (RREG32(AVIVO_D1CRTC_STATUS + crtc_offsets[crtc]) & AVIVO_D1CRTC_V_BLANK)\r\nreturn true;\r\nelse\r\nreturn false;\r\n}\r\nstatic bool avivo_is_counter_moving(struct radeon_device *rdev, int crtc)\r\n{\r\nu32 pos1, pos2;\r\npos1 = RREG32(AVIVO_D1CRTC_STATUS_POSITION + crtc_offsets[crtc]);\r\npos2 = RREG32(AVIVO_D1CRTC_STATUS_POSITION + crtc_offsets[crtc]);\r\nif (pos1 != pos2)\r\nreturn true;\r\nelse\r\nreturn false;\r\n}\r\nvoid avivo_wait_for_vblank(struct radeon_device *rdev, int crtc)\r\n{\r\nunsigned i = 0;\r\nif (crtc >= rdev->num_crtc)\r\nreturn;\r\nif (!(RREG32(AVIVO_D1CRTC_CONTROL + crtc_offsets[crtc]) & AVIVO_CRTC_EN))\r\nreturn;\r\nwhile (avivo_is_in_vblank(rdev, crtc)) {\r\nif (i++ % 100 == 0) {\r\nif (!avivo_is_counter_moving(rdev, crtc))\r\nbreak;\r\n}\r\n}\r\nwhile (!avivo_is_in_vblank(rdev, crtc)) {\r\nif (i++ % 100 == 0) {\r\nif (!avivo_is_counter_moving(rdev, crtc))\r\nbreak;\r\n}\r\n}\r\n}\r\nvoid rs600_page_flip(struct radeon_device *rdev, int crtc_id, u64 crtc_base)\r\n{\r\nstruct radeon_crtc *radeon_crtc = rdev->mode_info.crtcs[crtc_id];\r\nu32 tmp = RREG32(AVIVO_D1GRPH_UPDATE + radeon_crtc->crtc_offset);\r\nint i;\r\ntmp |= AVIVO_D1GRPH_UPDATE_LOCK;\r\nWREG32(AVIVO_D1GRPH_UPDATE + radeon_crtc->crtc_offset, tmp);\r\nWREG32(AVIVO_D1GRPH_SECONDARY_SURFACE_ADDRESS + radeon_crtc->crtc_offset,\r\n(u32)crtc_base);\r\nWREG32(AVIVO_D1GRPH_PRIMARY_SURFACE_ADDRESS + radeon_crtc->crtc_offset,\r\n(u32)crtc_base);\r\nfor (i = 0; i < rdev->usec_timeout; i++) {\r\nif (RREG32(AVIVO_D1GRPH_UPDATE + radeon_crtc->crtc_offset) & AVIVO_D1GRPH_SURFACE_UPDATE_PENDING)\r\nbreak;\r\nudelay(1);\r\n}\r\nDRM_DEBUG("Update pending now high. Unlocking vupdate_lock.\n");\r\ntmp &= ~AVIVO_D1GRPH_UPDATE_LOCK;\r\nWREG32(AVIVO_D1GRPH_UPDATE + radeon_crtc->crtc_offset, tmp);\r\n}\r\nbool rs600_page_flip_pending(struct radeon_device *rdev, int crtc_id)\r\n{\r\nstruct radeon_crtc *radeon_crtc = rdev->mode_info.crtcs[crtc_id];\r\nreturn !!(RREG32(AVIVO_D1GRPH_UPDATE + radeon_crtc->crtc_offset) &\r\nAVIVO_D1GRPH_SURFACE_UPDATE_PENDING);\r\n}\r\nvoid avivo_program_fmt(struct drm_encoder *encoder)\r\n{\r\nstruct drm_device *dev = encoder->dev;\r\nstruct radeon_device *rdev = dev->dev_private;\r\nstruct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);\r\nstruct drm_connector *connector = radeon_get_connector_for_encoder(encoder);\r\nint bpc = 0;\r\nu32 tmp = 0;\r\nenum radeon_connector_dither dither = RADEON_FMT_DITHER_DISABLE;\r\nif (connector) {\r\nstruct radeon_connector *radeon_connector = to_radeon_connector(connector);\r\nbpc = radeon_get_monitor_bpc(connector);\r\ndither = radeon_connector->dither;\r\n}\r\nif (radeon_encoder->devices & ATOM_DEVICE_LCD_SUPPORT)\r\nreturn;\r\nif (bpc == 0)\r\nreturn;\r\nswitch (bpc) {\r\ncase 6:\r\nif (dither == RADEON_FMT_DITHER_ENABLE)\r\ntmp |= AVIVO_TMDS_BIT_DEPTH_CONTROL_SPATIAL_DITHER_EN;\r\nelse\r\ntmp |= AVIVO_TMDS_BIT_DEPTH_CONTROL_TRUNCATE_EN;\r\nbreak;\r\ncase 8:\r\nif (dither == RADEON_FMT_DITHER_ENABLE)\r\ntmp |= (AVIVO_TMDS_BIT_DEPTH_CONTROL_SPATIAL_DITHER_EN |\r\nAVIVO_TMDS_BIT_DEPTH_CONTROL_SPATIAL_DITHER_DEPTH);\r\nelse\r\ntmp |= (AVIVO_TMDS_BIT_DEPTH_CONTROL_TRUNCATE_EN |\r\nAVIVO_TMDS_BIT_DEPTH_CONTROL_TRUNCATE_DEPTH);\r\nbreak;\r\ncase 10:\r\ndefault:\r\nbreak;\r\n}\r\nswitch (radeon_encoder->encoder_id) {\r\ncase ENCODER_OBJECT_ID_INTERNAL_KLDSCP_TMDS1:\r\nWREG32(AVIVO_TMDSA_BIT_DEPTH_CONTROL, tmp);\r\nbreak;\r\ncase ENCODER_OBJECT_ID_INTERNAL_LVTM1:\r\nWREG32(AVIVO_LVTMA_BIT_DEPTH_CONTROL, tmp);\r\nbreak;\r\ncase ENCODER_OBJECT_ID_INTERNAL_KLDSCP_DVO1:\r\nWREG32(AVIVO_DVOA_BIT_DEPTH_CONTROL, tmp);\r\nbreak;\r\ncase ENCODER_OBJECT_ID_INTERNAL_DDI:\r\nWREG32(AVIVO_DDIA_BIT_DEPTH_CONTROL, tmp);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nvoid rs600_pm_misc(struct radeon_device *rdev)\r\n{\r\nint requested_index = rdev->pm.requested_power_state_index;\r\nstruct radeon_power_state *ps = &rdev->pm.power_state[requested_index];\r\nstruct radeon_voltage *voltage = &ps->clock_info[0].voltage;\r\nu32 tmp, dyn_pwrmgt_sclk_length, dyn_sclk_vol_cntl;\r\nu32 hdp_dyn_cntl, dyn_backbias_cntl;\r\nif ((voltage->type == VOLTAGE_GPIO) && (voltage->gpio.valid)) {\r\nif (ps->misc & ATOM_PM_MISCINFO_VOLTAGE_DROP_SUPPORT) {\r\ntmp = RREG32(voltage->gpio.reg);\r\nif (voltage->active_high)\r\ntmp |= voltage->gpio.mask;\r\nelse\r\ntmp &= ~(voltage->gpio.mask);\r\nWREG32(voltage->gpio.reg, tmp);\r\nif (voltage->delay)\r\nudelay(voltage->delay);\r\n} else {\r\ntmp = RREG32(voltage->gpio.reg);\r\nif (voltage->active_high)\r\ntmp &= ~voltage->gpio.mask;\r\nelse\r\ntmp |= voltage->gpio.mask;\r\nWREG32(voltage->gpio.reg, tmp);\r\nif (voltage->delay)\r\nudelay(voltage->delay);\r\n}\r\n} else if (voltage->type == VOLTAGE_VDDC)\r\nradeon_atom_set_voltage(rdev, voltage->vddc_id, SET_VOLTAGE_TYPE_ASIC_VDDC);\r\ndyn_pwrmgt_sclk_length = RREG32_PLL(DYN_PWRMGT_SCLK_LENGTH);\r\ndyn_pwrmgt_sclk_length &= ~REDUCED_POWER_SCLK_HILEN(0xf);\r\ndyn_pwrmgt_sclk_length &= ~REDUCED_POWER_SCLK_LOLEN(0xf);\r\nif (ps->misc & ATOM_PM_MISCINFO_ASIC_REDUCED_SPEED_SCLK_EN) {\r\nif (ps->misc & ATOM_PM_MISCINFO_DYNAMIC_CLOCK_DIVIDER_BY_2) {\r\ndyn_pwrmgt_sclk_length |= REDUCED_POWER_SCLK_HILEN(2);\r\ndyn_pwrmgt_sclk_length |= REDUCED_POWER_SCLK_LOLEN(2);\r\n} else if (ps->misc & ATOM_PM_MISCINFO_DYNAMIC_CLOCK_DIVIDER_BY_4) {\r\ndyn_pwrmgt_sclk_length |= REDUCED_POWER_SCLK_HILEN(4);\r\ndyn_pwrmgt_sclk_length |= REDUCED_POWER_SCLK_LOLEN(4);\r\n}\r\n} else {\r\ndyn_pwrmgt_sclk_length |= REDUCED_POWER_SCLK_HILEN(1);\r\ndyn_pwrmgt_sclk_length |= REDUCED_POWER_SCLK_LOLEN(1);\r\n}\r\nWREG32_PLL(DYN_PWRMGT_SCLK_LENGTH, dyn_pwrmgt_sclk_length);\r\ndyn_sclk_vol_cntl = RREG32_PLL(DYN_SCLK_VOL_CNTL);\r\nif (ps->misc & ATOM_PM_MISCINFO_ASIC_DYNAMIC_VOLTAGE_EN) {\r\ndyn_sclk_vol_cntl |= IO_CG_VOLTAGE_DROP;\r\nif (voltage->delay) {\r\ndyn_sclk_vol_cntl |= VOLTAGE_DROP_SYNC;\r\ndyn_sclk_vol_cntl |= VOLTAGE_DELAY_SEL(voltage->delay);\r\n} else\r\ndyn_sclk_vol_cntl &= ~VOLTAGE_DROP_SYNC;\r\n} else\r\ndyn_sclk_vol_cntl &= ~IO_CG_VOLTAGE_DROP;\r\nWREG32_PLL(DYN_SCLK_VOL_CNTL, dyn_sclk_vol_cntl);\r\nhdp_dyn_cntl = RREG32_PLL(HDP_DYN_CNTL);\r\nif (ps->misc & ATOM_PM_MISCINFO_DYNAMIC_HDP_BLOCK_EN)\r\nhdp_dyn_cntl &= ~HDP_FORCEON;\r\nelse\r\nhdp_dyn_cntl |= HDP_FORCEON;\r\nWREG32_PLL(HDP_DYN_CNTL, hdp_dyn_cntl);\r\n#if 0\r\nmc_host_dyn_cntl = RREG32_PLL(MC_HOST_DYN_CNTL);\r\nif (ps->misc & ATOM_PM_MISCINFO_DYNAMIC_MC_HOST_BLOCK_EN)\r\nmc_host_dyn_cntl &= ~MC_HOST_FORCEON;\r\nelse\r\nmc_host_dyn_cntl |= MC_HOST_FORCEON;\r\nWREG32_PLL(MC_HOST_DYN_CNTL, mc_host_dyn_cntl);\r\n#endif\r\ndyn_backbias_cntl = RREG32_PLL(DYN_BACKBIAS_CNTL);\r\nif (ps->misc & ATOM_PM_MISCINFO2_DYNAMIC_BACK_BIAS_EN)\r\ndyn_backbias_cntl |= IO_CG_BACKBIAS_EN;\r\nelse\r\ndyn_backbias_cntl &= ~IO_CG_BACKBIAS_EN;\r\nWREG32_PLL(DYN_BACKBIAS_CNTL, dyn_backbias_cntl);\r\nif ((rdev->flags & RADEON_IS_PCIE) &&\r\n!(rdev->flags & RADEON_IS_IGP) &&\r\nrdev->asic->pm.set_pcie_lanes &&\r\n(ps->pcie_lanes !=\r\nrdev->pm.power_state[rdev->pm.current_power_state_index].pcie_lanes)) {\r\nradeon_set_pcie_lanes(rdev,\r\nps->pcie_lanes);\r\nDRM_DEBUG("Setting: p: %d\n", ps->pcie_lanes);\r\n}\r\n}\r\nvoid rs600_pm_prepare(struct radeon_device *rdev)\r\n{\r\nstruct drm_device *ddev = rdev->ddev;\r\nstruct drm_crtc *crtc;\r\nstruct radeon_crtc *radeon_crtc;\r\nu32 tmp;\r\nlist_for_each_entry(crtc, &ddev->mode_config.crtc_list, head) {\r\nradeon_crtc = to_radeon_crtc(crtc);\r\nif (radeon_crtc->enabled) {\r\ntmp = RREG32(AVIVO_D1CRTC_CONTROL + radeon_crtc->crtc_offset);\r\ntmp |= AVIVO_CRTC_DISP_READ_REQUEST_DISABLE;\r\nWREG32(AVIVO_D1CRTC_CONTROL + radeon_crtc->crtc_offset, tmp);\r\n}\r\n}\r\n}\r\nvoid rs600_pm_finish(struct radeon_device *rdev)\r\n{\r\nstruct drm_device *ddev = rdev->ddev;\r\nstruct drm_crtc *crtc;\r\nstruct radeon_crtc *radeon_crtc;\r\nu32 tmp;\r\nlist_for_each_entry(crtc, &ddev->mode_config.crtc_list, head) {\r\nradeon_crtc = to_radeon_crtc(crtc);\r\nif (radeon_crtc->enabled) {\r\ntmp = RREG32(AVIVO_D1CRTC_CONTROL + radeon_crtc->crtc_offset);\r\ntmp &= ~AVIVO_CRTC_DISP_READ_REQUEST_DISABLE;\r\nWREG32(AVIVO_D1CRTC_CONTROL + radeon_crtc->crtc_offset, tmp);\r\n}\r\n}\r\n}\r\nbool rs600_hpd_sense(struct radeon_device *rdev, enum radeon_hpd_id hpd)\r\n{\r\nu32 tmp;\r\nbool connected = false;\r\nswitch (hpd) {\r\ncase RADEON_HPD_1:\r\ntmp = RREG32(R_007D04_DC_HOT_PLUG_DETECT1_INT_STATUS);\r\nif (G_007D04_DC_HOT_PLUG_DETECT1_SENSE(tmp))\r\nconnected = true;\r\nbreak;\r\ncase RADEON_HPD_2:\r\ntmp = RREG32(R_007D14_DC_HOT_PLUG_DETECT2_INT_STATUS);\r\nif (G_007D14_DC_HOT_PLUG_DETECT2_SENSE(tmp))\r\nconnected = true;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn connected;\r\n}\r\nvoid rs600_hpd_set_polarity(struct radeon_device *rdev,\r\nenum radeon_hpd_id hpd)\r\n{\r\nu32 tmp;\r\nbool connected = rs600_hpd_sense(rdev, hpd);\r\nswitch (hpd) {\r\ncase RADEON_HPD_1:\r\ntmp = RREG32(R_007D08_DC_HOT_PLUG_DETECT1_INT_CONTROL);\r\nif (connected)\r\ntmp &= ~S_007D08_DC_HOT_PLUG_DETECT1_INT_POLARITY(1);\r\nelse\r\ntmp |= S_007D08_DC_HOT_PLUG_DETECT1_INT_POLARITY(1);\r\nWREG32(R_007D08_DC_HOT_PLUG_DETECT1_INT_CONTROL, tmp);\r\nbreak;\r\ncase RADEON_HPD_2:\r\ntmp = RREG32(R_007D18_DC_HOT_PLUG_DETECT2_INT_CONTROL);\r\nif (connected)\r\ntmp &= ~S_007D18_DC_HOT_PLUG_DETECT2_INT_POLARITY(1);\r\nelse\r\ntmp |= S_007D18_DC_HOT_PLUG_DETECT2_INT_POLARITY(1);\r\nWREG32(R_007D18_DC_HOT_PLUG_DETECT2_INT_CONTROL, tmp);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nvoid rs600_hpd_init(struct radeon_device *rdev)\r\n{\r\nstruct drm_device *dev = rdev->ddev;\r\nstruct drm_connector *connector;\r\nunsigned enable = 0;\r\nlist_for_each_entry(connector, &dev->mode_config.connector_list, head) {\r\nstruct radeon_connector *radeon_connector = to_radeon_connector(connector);\r\nswitch (radeon_connector->hpd.hpd) {\r\ncase RADEON_HPD_1:\r\nWREG32(R_007D00_DC_HOT_PLUG_DETECT1_CONTROL,\r\nS_007D00_DC_HOT_PLUG_DETECT1_EN(1));\r\nbreak;\r\ncase RADEON_HPD_2:\r\nWREG32(R_007D10_DC_HOT_PLUG_DETECT2_CONTROL,\r\nS_007D10_DC_HOT_PLUG_DETECT2_EN(1));\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nenable |= 1 << radeon_connector->hpd.hpd;\r\nradeon_hpd_set_polarity(rdev, radeon_connector->hpd.hpd);\r\n}\r\nradeon_irq_kms_enable_hpd(rdev, enable);\r\n}\r\nvoid rs600_hpd_fini(struct radeon_device *rdev)\r\n{\r\nstruct drm_device *dev = rdev->ddev;\r\nstruct drm_connector *connector;\r\nunsigned disable = 0;\r\nlist_for_each_entry(connector, &dev->mode_config.connector_list, head) {\r\nstruct radeon_connector *radeon_connector = to_radeon_connector(connector);\r\nswitch (radeon_connector->hpd.hpd) {\r\ncase RADEON_HPD_1:\r\nWREG32(R_007D00_DC_HOT_PLUG_DETECT1_CONTROL,\r\nS_007D00_DC_HOT_PLUG_DETECT1_EN(0));\r\nbreak;\r\ncase RADEON_HPD_2:\r\nWREG32(R_007D10_DC_HOT_PLUG_DETECT2_CONTROL,\r\nS_007D10_DC_HOT_PLUG_DETECT2_EN(0));\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\ndisable |= 1 << radeon_connector->hpd.hpd;\r\n}\r\nradeon_irq_kms_disable_hpd(rdev, disable);\r\n}\r\nint rs600_asic_reset(struct radeon_device *rdev)\r\n{\r\nstruct rv515_mc_save save;\r\nu32 status, tmp;\r\nint ret = 0;\r\nstatus = RREG32(R_000E40_RBBM_STATUS);\r\nif (!G_000E40_GUI_ACTIVE(status)) {\r\nreturn 0;\r\n}\r\nrv515_mc_stop(rdev, &save);\r\nstatus = RREG32(R_000E40_RBBM_STATUS);\r\ndev_info(rdev->dev, "(%s:%d) RBBM_STATUS=0x%08X\n", __func__, __LINE__, status);\r\nWREG32(RADEON_CP_CSQ_CNTL, 0);\r\ntmp = RREG32(RADEON_CP_RB_CNTL);\r\nWREG32(RADEON_CP_RB_CNTL, tmp | RADEON_RB_RPTR_WR_ENA);\r\nWREG32(RADEON_CP_RB_RPTR_WR, 0);\r\nWREG32(RADEON_CP_RB_WPTR, 0);\r\nWREG32(RADEON_CP_RB_CNTL, tmp);\r\npci_save_state(rdev->pdev);\r\npci_clear_master(rdev->pdev);\r\nmdelay(1);\r\nWREG32(R_0000F0_RBBM_SOFT_RESET, S_0000F0_SOFT_RESET_VAP(1) |\r\nS_0000F0_SOFT_RESET_GA(1));\r\nRREG32(R_0000F0_RBBM_SOFT_RESET);\r\nmdelay(500);\r\nWREG32(R_0000F0_RBBM_SOFT_RESET, 0);\r\nmdelay(1);\r\nstatus = RREG32(R_000E40_RBBM_STATUS);\r\ndev_info(rdev->dev, "(%s:%d) RBBM_STATUS=0x%08X\n", __func__, __LINE__, status);\r\nWREG32(R_0000F0_RBBM_SOFT_RESET, S_0000F0_SOFT_RESET_CP(1));\r\nRREG32(R_0000F0_RBBM_SOFT_RESET);\r\nmdelay(500);\r\nWREG32(R_0000F0_RBBM_SOFT_RESET, 0);\r\nmdelay(1);\r\nstatus = RREG32(R_000E40_RBBM_STATUS);\r\ndev_info(rdev->dev, "(%s:%d) RBBM_STATUS=0x%08X\n", __func__, __LINE__, status);\r\nWREG32(R_0000F0_RBBM_SOFT_RESET, S_0000F0_SOFT_RESET_MC(1));\r\nRREG32(R_0000F0_RBBM_SOFT_RESET);\r\nmdelay(500);\r\nWREG32(R_0000F0_RBBM_SOFT_RESET, 0);\r\nmdelay(1);\r\nstatus = RREG32(R_000E40_RBBM_STATUS);\r\ndev_info(rdev->dev, "(%s:%d) RBBM_STATUS=0x%08X\n", __func__, __LINE__, status);\r\npci_restore_state(rdev->pdev);\r\nif (G_000E40_GA_BUSY(status) || G_000E40_VAP_BUSY(status)) {\r\ndev_err(rdev->dev, "failed to reset GPU\n");\r\nret = -1;\r\n} else\r\ndev_info(rdev->dev, "GPU reset succeed\n");\r\nrv515_mc_resume(rdev, &save);\r\nreturn ret;\r\n}\r\nvoid rs600_gart_tlb_flush(struct radeon_device *rdev)\r\n{\r\nuint32_t tmp;\r\ntmp = RREG32_MC(R_000100_MC_PT0_CNTL);\r\ntmp &= C_000100_INVALIDATE_ALL_L1_TLBS & C_000100_INVALIDATE_L2_CACHE;\r\nWREG32_MC(R_000100_MC_PT0_CNTL, tmp);\r\ntmp = RREG32_MC(R_000100_MC_PT0_CNTL);\r\ntmp |= S_000100_INVALIDATE_ALL_L1_TLBS(1) | S_000100_INVALIDATE_L2_CACHE(1);\r\nWREG32_MC(R_000100_MC_PT0_CNTL, tmp);\r\ntmp = RREG32_MC(R_000100_MC_PT0_CNTL);\r\ntmp &= C_000100_INVALIDATE_ALL_L1_TLBS & C_000100_INVALIDATE_L2_CACHE;\r\nWREG32_MC(R_000100_MC_PT0_CNTL, tmp);\r\ntmp = RREG32_MC(R_000100_MC_PT0_CNTL);\r\n}\r\nstatic int rs600_gart_init(struct radeon_device *rdev)\r\n{\r\nint r;\r\nif (rdev->gart.robj) {\r\nWARN(1, "RS600 GART already initialized\n");\r\nreturn 0;\r\n}\r\nr = radeon_gart_init(rdev);\r\nif (r) {\r\nreturn r;\r\n}\r\nrdev->gart.table_size = rdev->gart.num_gpu_pages * 8;\r\nreturn radeon_gart_table_vram_alloc(rdev);\r\n}\r\nstatic int rs600_gart_enable(struct radeon_device *rdev)\r\n{\r\nu32 tmp;\r\nint r, i;\r\nif (rdev->gart.robj == NULL) {\r\ndev_err(rdev->dev, "No VRAM object for PCIE GART.\n");\r\nreturn -EINVAL;\r\n}\r\nr = radeon_gart_table_vram_pin(rdev);\r\nif (r)\r\nreturn r;\r\ntmp = RREG32(RADEON_BUS_CNTL) & ~RS600_BUS_MASTER_DIS;\r\nWREG32(RADEON_BUS_CNTL, tmp);\r\nWREG32_MC(R_000100_MC_PT0_CNTL,\r\n(S_000100_EFFECTIVE_L2_CACHE_SIZE(6) |\r\nS_000100_EFFECTIVE_L2_QUEUE_SIZE(6)));\r\nfor (i = 0; i < 19; i++) {\r\nWREG32_MC(R_00016C_MC_PT0_CLIENT0_CNTL + i,\r\nS_00016C_ENABLE_TRANSLATION_MODE_OVERRIDE(1) |\r\nS_00016C_SYSTEM_ACCESS_MODE_MASK(\r\nV_00016C_SYSTEM_ACCESS_MODE_NOT_IN_SYS) |\r\nS_00016C_SYSTEM_APERTURE_UNMAPPED_ACCESS(\r\nV_00016C_SYSTEM_APERTURE_UNMAPPED_PASSTHROUGH) |\r\nS_00016C_EFFECTIVE_L1_CACHE_SIZE(3) |\r\nS_00016C_ENABLE_FRAGMENT_PROCESSING(1) |\r\nS_00016C_EFFECTIVE_L1_QUEUE_SIZE(3));\r\n}\r\nWREG32_MC(R_000102_MC_PT0_CONTEXT0_CNTL,\r\nS_000102_ENABLE_PAGE_TABLE(1) |\r\nS_000102_PAGE_TABLE_DEPTH(V_000102_PAGE_TABLE_FLAT));\r\nfor (i = 1; i < 8; i++)\r\nWREG32_MC(R_000102_MC_PT0_CONTEXT0_CNTL + i, 0);\r\nWREG32_MC(R_00012C_MC_PT0_CONTEXT0_FLAT_BASE_ADDR,\r\nrdev->gart.table_addr);\r\nWREG32_MC(R_00013C_MC_PT0_CONTEXT0_FLAT_START_ADDR, rdev->mc.gtt_start);\r\nWREG32_MC(R_00014C_MC_PT0_CONTEXT0_FLAT_END_ADDR, rdev->mc.gtt_end);\r\nWREG32_MC(R_00011C_MC_PT0_CONTEXT0_DEFAULT_READ_ADDR, 0);\r\nWREG32_MC(R_000112_MC_PT0_SYSTEM_APERTURE_LOW_ADDR, rdev->mc.vram_start);\r\nWREG32_MC(R_000114_MC_PT0_SYSTEM_APERTURE_HIGH_ADDR, rdev->mc.vram_end);\r\ntmp = RREG32_MC(R_000100_MC_PT0_CNTL);\r\nWREG32_MC(R_000100_MC_PT0_CNTL, (tmp | S_000100_ENABLE_PT(1)));\r\ntmp = RREG32_MC(R_000009_MC_CNTL1);\r\nWREG32_MC(R_000009_MC_CNTL1, (tmp | S_000009_ENABLE_PAGE_TABLES(1)));\r\nrs600_gart_tlb_flush(rdev);\r\nDRM_INFO("PCIE GART of %uM enabled (table at 0x%016llX).\n",\r\n(unsigned)(rdev->mc.gtt_size >> 20),\r\n(unsigned long long)rdev->gart.table_addr);\r\nrdev->gart.ready = true;\r\nreturn 0;\r\n}\r\nstatic void rs600_gart_disable(struct radeon_device *rdev)\r\n{\r\nu32 tmp;\r\nWREG32_MC(R_000100_MC_PT0_CNTL, 0);\r\ntmp = RREG32_MC(R_000009_MC_CNTL1);\r\nWREG32_MC(R_000009_MC_CNTL1, tmp & C_000009_ENABLE_PAGE_TABLES);\r\nradeon_gart_table_vram_unpin(rdev);\r\n}\r\nstatic void rs600_gart_fini(struct radeon_device *rdev)\r\n{\r\nradeon_gart_fini(rdev);\r\nrs600_gart_disable(rdev);\r\nradeon_gart_table_vram_free(rdev);\r\n}\r\nuint64_t rs600_gart_get_page_entry(uint64_t addr, uint32_t flags)\r\n{\r\naddr = addr & 0xFFFFFFFFFFFFF000ULL;\r\naddr |= R600_PTE_SYSTEM;\r\nif (flags & RADEON_GART_PAGE_VALID)\r\naddr |= R600_PTE_VALID;\r\nif (flags & RADEON_GART_PAGE_READ)\r\naddr |= R600_PTE_READABLE;\r\nif (flags & RADEON_GART_PAGE_WRITE)\r\naddr |= R600_PTE_WRITEABLE;\r\nif (flags & RADEON_GART_PAGE_SNOOP)\r\naddr |= R600_PTE_SNOOPED;\r\nreturn addr;\r\n}\r\nvoid rs600_gart_set_page(struct radeon_device *rdev, unsigned i,\r\nuint64_t entry)\r\n{\r\nvoid __iomem *ptr = (void *)rdev->gart.ptr;\r\nwriteq(entry, ptr + (i * 8));\r\n}\r\nint rs600_irq_set(struct radeon_device *rdev)\r\n{\r\nuint32_t tmp = 0;\r\nuint32_t mode_int = 0;\r\nu32 hpd1 = RREG32(R_007D08_DC_HOT_PLUG_DETECT1_INT_CONTROL) &\r\n~S_007D08_DC_HOT_PLUG_DETECT1_INT_EN(1);\r\nu32 hpd2 = RREG32(R_007D18_DC_HOT_PLUG_DETECT2_INT_CONTROL) &\r\n~S_007D18_DC_HOT_PLUG_DETECT2_INT_EN(1);\r\nu32 hdmi0;\r\nif (ASIC_IS_DCE2(rdev))\r\nhdmi0 = RREG32(R_007408_HDMI0_AUDIO_PACKET_CONTROL) &\r\n~S_007408_HDMI0_AZ_FORMAT_WTRIG_MASK(1);\r\nelse\r\nhdmi0 = 0;\r\nif (!rdev->irq.installed) {\r\nWARN(1, "Can't enable IRQ/MSI because no handler is installed\n");\r\nWREG32(R_000040_GEN_INT_CNTL, 0);\r\nreturn -EINVAL;\r\n}\r\nif (atomic_read(&rdev->irq.ring_int[RADEON_RING_TYPE_GFX_INDEX])) {\r\ntmp |= S_000040_SW_INT_EN(1);\r\n}\r\nif (rdev->irq.crtc_vblank_int[0] ||\r\natomic_read(&rdev->irq.pflip[0])) {\r\nmode_int |= S_006540_D1MODE_VBLANK_INT_MASK(1);\r\n}\r\nif (rdev->irq.crtc_vblank_int[1] ||\r\natomic_read(&rdev->irq.pflip[1])) {\r\nmode_int |= S_006540_D2MODE_VBLANK_INT_MASK(1);\r\n}\r\nif (rdev->irq.hpd[0]) {\r\nhpd1 |= S_007D08_DC_HOT_PLUG_DETECT1_INT_EN(1);\r\n}\r\nif (rdev->irq.hpd[1]) {\r\nhpd2 |= S_007D18_DC_HOT_PLUG_DETECT2_INT_EN(1);\r\n}\r\nif (rdev->irq.afmt[0]) {\r\nhdmi0 |= S_007408_HDMI0_AZ_FORMAT_WTRIG_MASK(1);\r\n}\r\nWREG32(R_000040_GEN_INT_CNTL, tmp);\r\nWREG32(R_006540_DxMODE_INT_MASK, mode_int);\r\nWREG32(R_007D08_DC_HOT_PLUG_DETECT1_INT_CONTROL, hpd1);\r\nWREG32(R_007D18_DC_HOT_PLUG_DETECT2_INT_CONTROL, hpd2);\r\nif (ASIC_IS_DCE2(rdev))\r\nWREG32(R_007408_HDMI0_AUDIO_PACKET_CONTROL, hdmi0);\r\nRREG32(R_000040_GEN_INT_CNTL);\r\nreturn 0;\r\n}\r\nstatic inline u32 rs600_irq_ack(struct radeon_device *rdev)\r\n{\r\nuint32_t irqs = RREG32(R_000044_GEN_INT_STATUS);\r\nuint32_t irq_mask = S_000044_SW_INT(1);\r\nu32 tmp;\r\nif (G_000044_DISPLAY_INT_STAT(irqs)) {\r\nrdev->irq.stat_regs.r500.disp_int = RREG32(R_007EDC_DISP_INTERRUPT_STATUS);\r\nif (G_007EDC_LB_D1_VBLANK_INTERRUPT(rdev->irq.stat_regs.r500.disp_int)) {\r\nWREG32(R_006534_D1MODE_VBLANK_STATUS,\r\nS_006534_D1MODE_VBLANK_ACK(1));\r\n}\r\nif (G_007EDC_LB_D2_VBLANK_INTERRUPT(rdev->irq.stat_regs.r500.disp_int)) {\r\nWREG32(R_006D34_D2MODE_VBLANK_STATUS,\r\nS_006D34_D2MODE_VBLANK_ACK(1));\r\n}\r\nif (G_007EDC_DC_HOT_PLUG_DETECT1_INTERRUPT(rdev->irq.stat_regs.r500.disp_int)) {\r\ntmp = RREG32(R_007D08_DC_HOT_PLUG_DETECT1_INT_CONTROL);\r\ntmp |= S_007D08_DC_HOT_PLUG_DETECT1_INT_ACK(1);\r\nWREG32(R_007D08_DC_HOT_PLUG_DETECT1_INT_CONTROL, tmp);\r\n}\r\nif (G_007EDC_DC_HOT_PLUG_DETECT2_INTERRUPT(rdev->irq.stat_regs.r500.disp_int)) {\r\ntmp = RREG32(R_007D18_DC_HOT_PLUG_DETECT2_INT_CONTROL);\r\ntmp |= S_007D18_DC_HOT_PLUG_DETECT2_INT_ACK(1);\r\nWREG32(R_007D18_DC_HOT_PLUG_DETECT2_INT_CONTROL, tmp);\r\n}\r\n} else {\r\nrdev->irq.stat_regs.r500.disp_int = 0;\r\n}\r\nif (ASIC_IS_DCE2(rdev)) {\r\nrdev->irq.stat_regs.r500.hdmi0_status = RREG32(R_007404_HDMI0_STATUS) &\r\nS_007404_HDMI0_AZ_FORMAT_WTRIG(1);\r\nif (G_007404_HDMI0_AZ_FORMAT_WTRIG(rdev->irq.stat_regs.r500.hdmi0_status)) {\r\ntmp = RREG32(R_007408_HDMI0_AUDIO_PACKET_CONTROL);\r\ntmp |= S_007408_HDMI0_AZ_FORMAT_WTRIG_ACK(1);\r\nWREG32(R_007408_HDMI0_AUDIO_PACKET_CONTROL, tmp);\r\n}\r\n} else\r\nrdev->irq.stat_regs.r500.hdmi0_status = 0;\r\nif (irqs) {\r\nWREG32(R_000044_GEN_INT_STATUS, irqs);\r\n}\r\nreturn irqs & irq_mask;\r\n}\r\nvoid rs600_irq_disable(struct radeon_device *rdev)\r\n{\r\nu32 hdmi0 = RREG32(R_007408_HDMI0_AUDIO_PACKET_CONTROL) &\r\n~S_007408_HDMI0_AZ_FORMAT_WTRIG_MASK(1);\r\nWREG32(R_007408_HDMI0_AUDIO_PACKET_CONTROL, hdmi0);\r\nWREG32(R_000040_GEN_INT_CNTL, 0);\r\nWREG32(R_006540_DxMODE_INT_MASK, 0);\r\nmdelay(1);\r\nrs600_irq_ack(rdev);\r\n}\r\nint rs600_irq_process(struct radeon_device *rdev)\r\n{\r\nu32 status, msi_rearm;\r\nbool queue_hotplug = false;\r\nbool queue_hdmi = false;\r\nstatus = rs600_irq_ack(rdev);\r\nif (!status &&\r\n!rdev->irq.stat_regs.r500.disp_int &&\r\n!rdev->irq.stat_regs.r500.hdmi0_status) {\r\nreturn IRQ_NONE;\r\n}\r\nwhile (status ||\r\nrdev->irq.stat_regs.r500.disp_int ||\r\nrdev->irq.stat_regs.r500.hdmi0_status) {\r\nif (G_000044_SW_INT(status)) {\r\nradeon_fence_process(rdev, RADEON_RING_TYPE_GFX_INDEX);\r\n}\r\nif (G_007EDC_LB_D1_VBLANK_INTERRUPT(rdev->irq.stat_regs.r500.disp_int)) {\r\nif (rdev->irq.crtc_vblank_int[0]) {\r\ndrm_handle_vblank(rdev->ddev, 0);\r\nrdev->pm.vblank_sync = true;\r\nwake_up(&rdev->irq.vblank_queue);\r\n}\r\nif (atomic_read(&rdev->irq.pflip[0]))\r\nradeon_crtc_handle_vblank(rdev, 0);\r\n}\r\nif (G_007EDC_LB_D2_VBLANK_INTERRUPT(rdev->irq.stat_regs.r500.disp_int)) {\r\nif (rdev->irq.crtc_vblank_int[1]) {\r\ndrm_handle_vblank(rdev->ddev, 1);\r\nrdev->pm.vblank_sync = true;\r\nwake_up(&rdev->irq.vblank_queue);\r\n}\r\nif (atomic_read(&rdev->irq.pflip[1]))\r\nradeon_crtc_handle_vblank(rdev, 1);\r\n}\r\nif (G_007EDC_DC_HOT_PLUG_DETECT1_INTERRUPT(rdev->irq.stat_regs.r500.disp_int)) {\r\nqueue_hotplug = true;\r\nDRM_DEBUG("HPD1\n");\r\n}\r\nif (G_007EDC_DC_HOT_PLUG_DETECT2_INTERRUPT(rdev->irq.stat_regs.r500.disp_int)) {\r\nqueue_hotplug = true;\r\nDRM_DEBUG("HPD2\n");\r\n}\r\nif (G_007404_HDMI0_AZ_FORMAT_WTRIG(rdev->irq.stat_regs.r500.hdmi0_status)) {\r\nqueue_hdmi = true;\r\nDRM_DEBUG("HDMI0\n");\r\n}\r\nstatus = rs600_irq_ack(rdev);\r\n}\r\nif (queue_hotplug)\r\nschedule_work(&rdev->hotplug_work);\r\nif (queue_hdmi)\r\nschedule_work(&rdev->audio_work);\r\nif (rdev->msi_enabled) {\r\nswitch (rdev->family) {\r\ncase CHIP_RS600:\r\ncase CHIP_RS690:\r\ncase CHIP_RS740:\r\nmsi_rearm = RREG32(RADEON_BUS_CNTL) & ~RS600_MSI_REARM;\r\nWREG32(RADEON_BUS_CNTL, msi_rearm);\r\nWREG32(RADEON_BUS_CNTL, msi_rearm | RS600_MSI_REARM);\r\nbreak;\r\ndefault:\r\nWREG32(RADEON_MSI_REARM_EN, RV370_MSI_REARM_EN);\r\nbreak;\r\n}\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nu32 rs600_get_vblank_counter(struct radeon_device *rdev, int crtc)\r\n{\r\nif (crtc == 0)\r\nreturn RREG32(R_0060A4_D1CRTC_STATUS_FRAME_COUNT);\r\nelse\r\nreturn RREG32(R_0068A4_D2CRTC_STATUS_FRAME_COUNT);\r\n}\r\nint rs600_mc_wait_for_idle(struct radeon_device *rdev)\r\n{\r\nunsigned i;\r\nfor (i = 0; i < rdev->usec_timeout; i++) {\r\nif (G_000000_MC_IDLE(RREG32_MC(R_000000_MC_STATUS)))\r\nreturn 0;\r\nudelay(1);\r\n}\r\nreturn -1;\r\n}\r\nstatic void rs600_gpu_init(struct radeon_device *rdev)\r\n{\r\nr420_pipes_init(rdev);\r\nif (rs600_mc_wait_for_idle(rdev))\r\ndev_warn(rdev->dev, "Wait MC idle timeout before updating MC.\n");\r\n}\r\nstatic void rs600_mc_init(struct radeon_device *rdev)\r\n{\r\nu64 base;\r\nrdev->mc.aper_base = pci_resource_start(rdev->pdev, 0);\r\nrdev->mc.aper_size = pci_resource_len(rdev->pdev, 0);\r\nrdev->mc.vram_is_ddr = true;\r\nrdev->mc.vram_width = 128;\r\nrdev->mc.real_vram_size = RREG32(RADEON_CONFIG_MEMSIZE);\r\nrdev->mc.mc_vram_size = rdev->mc.real_vram_size;\r\nrdev->mc.visible_vram_size = rdev->mc.aper_size;\r\nrdev->mc.igp_sideport_enabled = radeon_atombios_sideport_present(rdev);\r\nbase = RREG32_MC(R_000004_MC_FB_LOCATION);\r\nbase = G_000004_MC_FB_START(base) << 16;\r\nradeon_vram_location(rdev, &rdev->mc, base);\r\nrdev->mc.gtt_base_align = 0;\r\nradeon_gtt_location(rdev, &rdev->mc);\r\nradeon_update_bandwidth_info(rdev);\r\n}\r\nvoid rs600_bandwidth_update(struct radeon_device *rdev)\r\n{\r\nstruct drm_display_mode *mode0 = NULL;\r\nstruct drm_display_mode *mode1 = NULL;\r\nu32 d1mode_priority_a_cnt, d2mode_priority_a_cnt;\r\nif (!rdev->mode_info.mode_config_initialized)\r\nreturn;\r\nradeon_update_display_priority(rdev);\r\nif (rdev->mode_info.crtcs[0]->base.enabled)\r\nmode0 = &rdev->mode_info.crtcs[0]->base.mode;\r\nif (rdev->mode_info.crtcs[1]->base.enabled)\r\nmode1 = &rdev->mode_info.crtcs[1]->base.mode;\r\nrs690_line_buffer_adjust(rdev, mode0, mode1);\r\nif (rdev->disp_priority == 2) {\r\nd1mode_priority_a_cnt = RREG32(R_006548_D1MODE_PRIORITY_A_CNT);\r\nd2mode_priority_a_cnt = RREG32(R_006D48_D2MODE_PRIORITY_A_CNT);\r\nd1mode_priority_a_cnt |= S_006548_D1MODE_PRIORITY_A_ALWAYS_ON(1);\r\nd2mode_priority_a_cnt |= S_006D48_D2MODE_PRIORITY_A_ALWAYS_ON(1);\r\nWREG32(R_006548_D1MODE_PRIORITY_A_CNT, d1mode_priority_a_cnt);\r\nWREG32(R_00654C_D1MODE_PRIORITY_B_CNT, d1mode_priority_a_cnt);\r\nWREG32(R_006D48_D2MODE_PRIORITY_A_CNT, d2mode_priority_a_cnt);\r\nWREG32(R_006D4C_D2MODE_PRIORITY_B_CNT, d2mode_priority_a_cnt);\r\n}\r\n}\r\nuint32_t rs600_mc_rreg(struct radeon_device *rdev, uint32_t reg)\r\n{\r\nunsigned long flags;\r\nu32 r;\r\nspin_lock_irqsave(&rdev->mc_idx_lock, flags);\r\nWREG32(R_000070_MC_IND_INDEX, S_000070_MC_IND_ADDR(reg) |\r\nS_000070_MC_IND_CITF_ARB0(1));\r\nr = RREG32(R_000074_MC_IND_DATA);\r\nspin_unlock_irqrestore(&rdev->mc_idx_lock, flags);\r\nreturn r;\r\n}\r\nvoid rs600_mc_wreg(struct radeon_device *rdev, uint32_t reg, uint32_t v)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&rdev->mc_idx_lock, flags);\r\nWREG32(R_000070_MC_IND_INDEX, S_000070_MC_IND_ADDR(reg) |\r\nS_000070_MC_IND_CITF_ARB0(1) | S_000070_MC_IND_WR_EN(1));\r\nWREG32(R_000074_MC_IND_DATA, v);\r\nspin_unlock_irqrestore(&rdev->mc_idx_lock, flags);\r\n}\r\nstatic void rs600_debugfs(struct radeon_device *rdev)\r\n{\r\nif (r100_debugfs_rbbm_init(rdev))\r\nDRM_ERROR("Failed to register debugfs file for RBBM !\n");\r\n}\r\nvoid rs600_set_safe_registers(struct radeon_device *rdev)\r\n{\r\nrdev->config.r300.reg_safe_bm = rs600_reg_safe_bm;\r\nrdev->config.r300.reg_safe_bm_size = ARRAY_SIZE(rs600_reg_safe_bm);\r\n}\r\nstatic void rs600_mc_program(struct radeon_device *rdev)\r\n{\r\nstruct rv515_mc_save save;\r\nrv515_mc_stop(rdev, &save);\r\nif (rs600_mc_wait_for_idle(rdev))\r\ndev_warn(rdev->dev, "Wait MC idle timeout before updating MC.\n");\r\nWREG32_MC(R_000005_MC_AGP_LOCATION, 0x0FFFFFFF);\r\nWREG32_MC(R_000006_AGP_BASE, 0);\r\nWREG32_MC(R_000007_AGP_BASE_2, 0);\r\nWREG32_MC(R_000004_MC_FB_LOCATION,\r\nS_000004_MC_FB_START(rdev->mc.vram_start >> 16) |\r\nS_000004_MC_FB_TOP(rdev->mc.vram_end >> 16));\r\nWREG32(R_000134_HDP_FB_LOCATION,\r\nS_000134_HDP_FB_START(rdev->mc.vram_start >> 16));\r\nrv515_mc_resume(rdev, &save);\r\n}\r\nstatic int rs600_startup(struct radeon_device *rdev)\r\n{\r\nint r;\r\nrs600_mc_program(rdev);\r\nrv515_clock_startup(rdev);\r\nrs600_gpu_init(rdev);\r\nr = rs600_gart_enable(rdev);\r\nif (r)\r\nreturn r;\r\nr = radeon_wb_init(rdev);\r\nif (r)\r\nreturn r;\r\nr = radeon_fence_driver_start_ring(rdev, RADEON_RING_TYPE_GFX_INDEX);\r\nif (r) {\r\ndev_err(rdev->dev, "failed initializing CP fences (%d).\n", r);\r\nreturn r;\r\n}\r\nif (!rdev->irq.installed) {\r\nr = radeon_irq_kms_init(rdev);\r\nif (r)\r\nreturn r;\r\n}\r\nrs600_irq_set(rdev);\r\nrdev->config.r300.hdp_cntl = RREG32(RADEON_HOST_PATH_CNTL);\r\nr = r100_cp_init(rdev, 1024 * 1024);\r\nif (r) {\r\ndev_err(rdev->dev, "failed initializing CP (%d).\n", r);\r\nreturn r;\r\n}\r\nr = radeon_ib_pool_init(rdev);\r\nif (r) {\r\ndev_err(rdev->dev, "IB initialization failed (%d).\n", r);\r\nreturn r;\r\n}\r\nr = radeon_audio_init(rdev);\r\nif (r) {\r\ndev_err(rdev->dev, "failed initializing audio\n");\r\nreturn r;\r\n}\r\nreturn 0;\r\n}\r\nint rs600_resume(struct radeon_device *rdev)\r\n{\r\nint r;\r\nrs600_gart_disable(rdev);\r\nrv515_clock_startup(rdev);\r\nif (radeon_asic_reset(rdev)) {\r\ndev_warn(rdev->dev, "GPU reset failed ! (0xE40=0x%08X, 0x7C0=0x%08X)\n",\r\nRREG32(R_000E40_RBBM_STATUS),\r\nRREG32(R_0007C0_CP_STAT));\r\n}\r\natom_asic_init(rdev->mode_info.atom_context);\r\nrv515_clock_startup(rdev);\r\nradeon_surface_init(rdev);\r\nrdev->accel_working = true;\r\nr = rs600_startup(rdev);\r\nif (r) {\r\nrdev->accel_working = false;\r\n}\r\nreturn r;\r\n}\r\nint rs600_suspend(struct radeon_device *rdev)\r\n{\r\nradeon_pm_suspend(rdev);\r\nradeon_audio_fini(rdev);\r\nr100_cp_disable(rdev);\r\nradeon_wb_disable(rdev);\r\nrs600_irq_disable(rdev);\r\nrs600_gart_disable(rdev);\r\nreturn 0;\r\n}\r\nvoid rs600_fini(struct radeon_device *rdev)\r\n{\r\nradeon_pm_fini(rdev);\r\nradeon_audio_fini(rdev);\r\nr100_cp_fini(rdev);\r\nradeon_wb_fini(rdev);\r\nradeon_ib_pool_fini(rdev);\r\nradeon_gem_fini(rdev);\r\nrs600_gart_fini(rdev);\r\nradeon_irq_kms_fini(rdev);\r\nradeon_fence_driver_fini(rdev);\r\nradeon_bo_fini(rdev);\r\nradeon_atombios_fini(rdev);\r\nkfree(rdev->bios);\r\nrdev->bios = NULL;\r\n}\r\nint rs600_init(struct radeon_device *rdev)\r\n{\r\nint r;\r\nrv515_vga_render_disable(rdev);\r\nradeon_scratch_init(rdev);\r\nradeon_surface_init(rdev);\r\nr100_restore_sanity(rdev);\r\nif (!radeon_get_bios(rdev)) {\r\nif (ASIC_IS_AVIVO(rdev))\r\nreturn -EINVAL;\r\n}\r\nif (rdev->is_atom_bios) {\r\nr = radeon_atombios_init(rdev);\r\nif (r)\r\nreturn r;\r\n} else {\r\ndev_err(rdev->dev, "Expecting atombios for RS600 GPU\n");\r\nreturn -EINVAL;\r\n}\r\nif (radeon_asic_reset(rdev)) {\r\ndev_warn(rdev->dev,\r\n"GPU reset failed ! (0xE40=0x%08X, 0x7C0=0x%08X)\n",\r\nRREG32(R_000E40_RBBM_STATUS),\r\nRREG32(R_0007C0_CP_STAT));\r\n}\r\nif (radeon_boot_test_post_card(rdev) == false)\r\nreturn -EINVAL;\r\nradeon_get_clock_info(rdev->ddev);\r\nrs600_mc_init(rdev);\r\nrs600_debugfs(rdev);\r\nr = radeon_fence_driver_init(rdev);\r\nif (r)\r\nreturn r;\r\nr = radeon_bo_init(rdev);\r\nif (r)\r\nreturn r;\r\nr = rs600_gart_init(rdev);\r\nif (r)\r\nreturn r;\r\nrs600_set_safe_registers(rdev);\r\nradeon_pm_init(rdev);\r\nrdev->accel_working = true;\r\nr = rs600_startup(rdev);\r\nif (r) {\r\ndev_err(rdev->dev, "Disabling GPU acceleration\n");\r\nr100_cp_fini(rdev);\r\nradeon_wb_fini(rdev);\r\nradeon_ib_pool_fini(rdev);\r\nrs600_gart_fini(rdev);\r\nradeon_irq_kms_fini(rdev);\r\nrdev->accel_working = false;\r\n}\r\nreturn 0;\r\n}
