void mwifiex_init_11h_params(struct mwifiex_private *priv)\r\n{\r\npriv->state_11h.is_11h_enabled = true;\r\npriv->state_11h.is_11h_active = false;\r\n}\r\ninline int mwifiex_is_11h_active(struct mwifiex_private *priv)\r\n{\r\nreturn priv->state_11h.is_11h_active;\r\n}\r\nstatic void\r\nmwifiex_11h_process_infra_join(struct mwifiex_private *priv, u8 **buffer,\r\nstruct mwifiex_bssdescriptor *bss_desc)\r\n{\r\nstruct mwifiex_ie_types_header *ie_header;\r\nstruct mwifiex_ie_types_pwr_capability *cap;\r\nstruct mwifiex_ie_types_local_pwr_constraint *constraint;\r\nstruct ieee80211_supported_band *sband;\r\nu8 radio_type;\r\nint i;\r\nif (!buffer || !(*buffer))\r\nreturn;\r\nradio_type = mwifiex_band_to_radio_type((u8) bss_desc->bss_band);\r\nsband = priv->wdev.wiphy->bands[radio_type];\r\ncap = (struct mwifiex_ie_types_pwr_capability *)*buffer;\r\ncap->header.type = cpu_to_le16(WLAN_EID_PWR_CAPABILITY);\r\ncap->header.len = cpu_to_le16(2);\r\ncap->min_pwr = 0;\r\ncap->max_pwr = 0;\r\n*buffer += sizeof(*cap);\r\nconstraint = (struct mwifiex_ie_types_local_pwr_constraint *)*buffer;\r\nconstraint->header.type = cpu_to_le16(WLAN_EID_PWR_CONSTRAINT);\r\nconstraint->header.len = cpu_to_le16(2);\r\nconstraint->chan = bss_desc->channel;\r\nconstraint->constraint = bss_desc->local_constraint;\r\n*buffer += sizeof(*constraint);\r\nie_header = (struct mwifiex_ie_types_header *)*buffer;\r\nie_header->type = cpu_to_le16(TLV_TYPE_PASSTHROUGH);\r\nie_header->len = cpu_to_le16(2 * sband->n_channels + 2);\r\n*buffer += sizeof(*ie_header);\r\n*(*buffer)++ = WLAN_EID_SUPPORTED_CHANNELS;\r\n*(*buffer)++ = 2 * sband->n_channels;\r\nfor (i = 0; i < sband->n_channels; i++) {\r\n*(*buffer)++ = ieee80211_frequency_to_channel(\r\nsband->channels[i].center_freq);\r\n*(*buffer)++ = 1;\r\n}\r\n}\r\nint mwifiex_11h_activate(struct mwifiex_private *priv, bool flag)\r\n{\r\nu32 enable = flag;\r\nif ((GET_BSS_ROLE(priv) == MWIFIEX_BSS_ROLE_UAP) && enable)\r\nenable |= MWIFIEX_MASTER_RADAR_DET_MASK;\r\nreturn mwifiex_send_cmd(priv, HostCmd_CMD_802_11_SNMP_MIB,\r\nHostCmd_ACT_GEN_SET, DOT11H_I, &enable, true);\r\n}\r\nvoid mwifiex_11h_process_join(struct mwifiex_private *priv, u8 **buffer,\r\nstruct mwifiex_bssdescriptor *bss_desc)\r\n{\r\nif (bss_desc->sensed_11h) {\r\nmwifiex_11h_activate(priv, true);\r\npriv->state_11h.is_11h_active = true;\r\nbss_desc->cap_info_bitmap |= WLAN_CAPABILITY_SPECTRUM_MGMT;\r\nmwifiex_11h_process_infra_join(priv, buffer, bss_desc);\r\n} else {\r\nmwifiex_11h_activate(priv, false);\r\npriv->state_11h.is_11h_active = false;\r\nbss_desc->cap_info_bitmap &= ~WLAN_CAPABILITY_SPECTRUM_MGMT;\r\n}\r\n}\r\nvoid mwifiex_dfs_cac_work_queue(struct work_struct *work)\r\n{\r\nstruct cfg80211_chan_def chandef;\r\nstruct delayed_work *delayed_work =\r\ncontainer_of(work, struct delayed_work, work);\r\nstruct mwifiex_private *priv =\r\ncontainer_of(delayed_work, struct mwifiex_private,\r\ndfs_cac_work);\r\nif (WARN_ON(!priv))\r\nreturn;\r\nchandef = priv->dfs_chandef;\r\nif (priv->wdev.cac_started) {\r\ndev_dbg(priv->adapter->dev,\r\n"CAC timer finished; No radar detected\n");\r\ncfg80211_cac_event(priv->netdev, &chandef,\r\nNL80211_RADAR_CAC_FINISHED,\r\nGFP_KERNEL);\r\n}\r\n}\r\nint mwifiex_cmd_issue_chan_report_request(struct mwifiex_private *priv,\r\nstruct host_cmd_ds_command *cmd,\r\nvoid *data_buf)\r\n{\r\nstruct host_cmd_ds_chan_rpt_req *cr_req = &cmd->params.chan_rpt_req;\r\nstruct mwifiex_radar_params *radar_params = (void *)data_buf;\r\ncmd->command = cpu_to_le16(HostCmd_CMD_CHAN_REPORT_REQUEST);\r\ncmd->size = cpu_to_le16(S_DS_GEN);\r\nle16_add_cpu(&cmd->size, sizeof(struct host_cmd_ds_chan_rpt_req));\r\ncr_req->chan_desc.start_freq = cpu_to_le16(MWIFIEX_A_BAND_START_FREQ);\r\ncr_req->chan_desc.chan_num = radar_params->chandef->chan->hw_value;\r\ncr_req->chan_desc.chan_width = radar_params->chandef->width;\r\ncr_req->msec_dwell_time = cpu_to_le32(radar_params->cac_time_ms);\r\ndev_dbg(priv->adapter->dev,\r\n"11h: issuing DFS Radar check for channel=%d\n",\r\nradar_params->chandef->chan->hw_value);\r\nreturn 0;\r\n}\r\nvoid mwifiex_abort_cac(struct mwifiex_private *priv)\r\n{\r\nif (priv->wdev.cac_started) {\r\ndev_dbg(priv->adapter->dev,\r\n"Aborting delayed work for CAC.\n");\r\ncancel_delayed_work_sync(&priv->dfs_cac_work);\r\ncfg80211_cac_event(priv->netdev, &priv->dfs_chandef,\r\nNL80211_RADAR_CAC_ABORTED, GFP_KERNEL);\r\n}\r\n}\r\nint mwifiex_11h_handle_chanrpt_ready(struct mwifiex_private *priv,\r\nstruct sk_buff *skb)\r\n{\r\nstruct host_cmd_ds_chan_rpt_event *rpt_event;\r\nstruct mwifiex_ie_types_chan_rpt_data *rpt;\r\nu8 *evt_buf;\r\nu16 event_len, tlv_len;\r\nrpt_event = (void *)(skb->data + sizeof(u32));\r\nevent_len = skb->len - (sizeof(struct host_cmd_ds_chan_rpt_event)+\r\nsizeof(u32));\r\nif (le32_to_cpu(rpt_event->result) != HostCmd_RESULT_OK) {\r\ndev_err(priv->adapter->dev, "Error in channel report event\n");\r\nreturn -1;\r\n}\r\nevt_buf = (void *)&rpt_event->tlvbuf;\r\nwhile (event_len >= sizeof(struct mwifiex_ie_types_header)) {\r\nrpt = (void *)&rpt_event->tlvbuf;\r\ntlv_len = le16_to_cpu(rpt->header.len);\r\nswitch (le16_to_cpu(rpt->header.type)) {\r\ncase TLV_TYPE_CHANRPT_11H_BASIC:\r\nif (rpt->map.radar) {\r\ndev_notice(priv->adapter->dev,\r\n"RADAR Detected on channel %d!\n",\r\npriv->dfs_chandef.chan->hw_value);\r\ncancel_delayed_work_sync(&priv->dfs_cac_work);\r\ncfg80211_cac_event(priv->netdev,\r\n&priv->dfs_chandef,\r\nNL80211_RADAR_DETECTED,\r\nGFP_KERNEL);\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nevt_buf += (tlv_len + sizeof(rpt->header));\r\nevent_len -= (tlv_len + sizeof(rpt->header));\r\n}\r\nreturn 0;\r\n}\r\nint mwifiex_11h_handle_radar_detected(struct mwifiex_private *priv,\r\nstruct sk_buff *skb)\r\n{\r\nstruct mwifiex_radar_det_event *rdr_event;\r\nrdr_event = (void *)(skb->data + sizeof(u32));\r\nif (le32_to_cpu(rdr_event->passed)) {\r\ndev_notice(priv->adapter->dev,\r\n"radar detected; indicating kernel\n");\r\ncfg80211_radar_event(priv->adapter->wiphy, &priv->dfs_chandef,\r\nGFP_KERNEL);\r\ndev_dbg(priv->adapter->dev, "regdomain: %d\n",\r\nrdr_event->reg_domain);\r\ndev_dbg(priv->adapter->dev, "radar detection type: %d\n",\r\nrdr_event->det_type);\r\n} else {\r\ndev_dbg(priv->adapter->dev, "false radar detection event!\n");\r\n}\r\nreturn 0;\r\n}\r\nvoid mwifiex_dfs_chan_sw_work_queue(struct work_struct *work)\r\n{\r\nstruct mwifiex_uap_bss_param *bss_cfg;\r\nstruct delayed_work *delayed_work =\r\ncontainer_of(work, struct delayed_work, work);\r\nstruct mwifiex_private *priv =\r\ncontainer_of(delayed_work, struct mwifiex_private,\r\ndfs_chan_sw_work);\r\nif (WARN_ON(!priv))\r\nreturn;\r\nbss_cfg = &priv->bss_cfg;\r\nif (!bss_cfg->beacon_period) {\r\ndev_err(priv->adapter->dev,\r\n"channel switch: AP already stopped\n");\r\nreturn;\r\n}\r\nmwifiex_uap_set_channel(bss_cfg, priv->dfs_chandef);\r\nif (mwifiex_config_start_uap(priv, bss_cfg)) {\r\ndev_dbg(priv->adapter->dev,\r\n"Failed to start AP after channel switch\n");\r\nreturn;\r\n}\r\ndev_notice(priv->adapter->dev,\r\n"indicating channel switch completion to kernel\n");\r\ncfg80211_ch_switch_notify(priv->netdev, &priv->dfs_chandef);\r\n}
