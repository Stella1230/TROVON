static int src_set_state(struct src *src, unsigned int state)\r\n{\r\nstruct hw *hw;\r\nhw = src->rsc.hw;\r\nhw->src_set_state(src->rsc.ctrl_blk, state);\r\nreturn 0;\r\n}\r\nstatic int src_set_bm(struct src *src, unsigned int bm)\r\n{\r\nstruct hw *hw;\r\nhw = src->rsc.hw;\r\nhw->src_set_bm(src->rsc.ctrl_blk, bm);\r\nreturn 0;\r\n}\r\nstatic int src_set_sf(struct src *src, unsigned int sf)\r\n{\r\nstruct hw *hw;\r\nhw = src->rsc.hw;\r\nhw->src_set_sf(src->rsc.ctrl_blk, sf);\r\nreturn 0;\r\n}\r\nstatic int src_set_pm(struct src *src, unsigned int pm)\r\n{\r\nstruct hw *hw;\r\nhw = src->rsc.hw;\r\nhw->src_set_pm(src->rsc.ctrl_blk, pm);\r\nreturn 0;\r\n}\r\nstatic int src_set_rom(struct src *src, unsigned int rom)\r\n{\r\nstruct hw *hw;\r\nhw = src->rsc.hw;\r\nhw->src_set_rom(src->rsc.ctrl_blk, rom);\r\nreturn 0;\r\n}\r\nstatic int src_set_vo(struct src *src, unsigned int vo)\r\n{\r\nstruct hw *hw;\r\nhw = src->rsc.hw;\r\nhw->src_set_vo(src->rsc.ctrl_blk, vo);\r\nreturn 0;\r\n}\r\nstatic int src_set_st(struct src *src, unsigned int st)\r\n{\r\nstruct hw *hw;\r\nhw = src->rsc.hw;\r\nhw->src_set_st(src->rsc.ctrl_blk, st);\r\nreturn 0;\r\n}\r\nstatic int src_set_bp(struct src *src, unsigned int bp)\r\n{\r\nstruct hw *hw;\r\nhw = src->rsc.hw;\r\nhw->src_set_bp(src->rsc.ctrl_blk, bp);\r\nreturn 0;\r\n}\r\nstatic int src_set_cisz(struct src *src, unsigned int cisz)\r\n{\r\nstruct hw *hw;\r\nhw = src->rsc.hw;\r\nhw->src_set_cisz(src->rsc.ctrl_blk, cisz);\r\nreturn 0;\r\n}\r\nstatic int src_set_ca(struct src *src, unsigned int ca)\r\n{\r\nstruct hw *hw;\r\nhw = src->rsc.hw;\r\nhw->src_set_ca(src->rsc.ctrl_blk, ca);\r\nreturn 0;\r\n}\r\nstatic int src_set_sa(struct src *src, unsigned int sa)\r\n{\r\nstruct hw *hw;\r\nhw = src->rsc.hw;\r\nhw->src_set_sa(src->rsc.ctrl_blk, sa);\r\nreturn 0;\r\n}\r\nstatic int src_set_la(struct src *src, unsigned int la)\r\n{\r\nstruct hw *hw;\r\nhw = src->rsc.hw;\r\nhw->src_set_la(src->rsc.ctrl_blk, la);\r\nreturn 0;\r\n}\r\nstatic int src_set_pitch(struct src *src, unsigned int pitch)\r\n{\r\nstruct hw *hw;\r\nhw = src->rsc.hw;\r\nhw->src_set_pitch(src->rsc.ctrl_blk, pitch);\r\nreturn 0;\r\n}\r\nstatic int src_set_clear_zbufs(struct src *src)\r\n{\r\nstruct hw *hw;\r\nhw = src->rsc.hw;\r\nhw->src_set_clear_zbufs(src->rsc.ctrl_blk, 1);\r\nreturn 0;\r\n}\r\nstatic int src_commit_write(struct src *src)\r\n{\r\nstruct hw *hw;\r\nint i;\r\nunsigned int dirty = 0;\r\nhw = src->rsc.hw;\r\nsrc->rsc.ops->master(&src->rsc);\r\nif (src->rsc.msr > 1) {\r\ndirty = hw->src_get_dirty(src->rsc.ctrl_blk) & conj_mask;\r\n}\r\nhw->src_commit_write(hw, src->rsc.ops->index(&src->rsc),\r\nsrc->rsc.ctrl_blk);\r\nif (MEMWR == src->mode)\r\nreturn 0;\r\nfor (i = 1; i < src->rsc.msr; i++) {\r\nsrc->rsc.ops->next_conj(&src->rsc);\r\nhw->src_set_dirty(src->rsc.ctrl_blk, dirty);\r\nhw->src_commit_write(hw, src->rsc.ops->index(&src->rsc),\r\nsrc->rsc.ctrl_blk);\r\n}\r\nsrc->rsc.ops->master(&src->rsc);\r\nreturn 0;\r\n}\r\nstatic int src_get_ca(struct src *src)\r\n{\r\nstruct hw *hw;\r\nhw = src->rsc.hw;\r\nreturn hw->src_get_ca(hw, src->rsc.ops->index(&src->rsc),\r\nsrc->rsc.ctrl_blk);\r\n}\r\nstatic int src_init(struct src *src)\r\n{\r\nsrc_default_config[src->mode](src);\r\nreturn 0;\r\n}\r\nstatic struct src *src_next_interleave(struct src *src)\r\n{\r\nreturn src->intlv;\r\n}\r\nstatic int src_default_config_memrd(struct src *src)\r\n{\r\nstruct hw *hw = src->rsc.hw;\r\nunsigned int rsr, msr;\r\nhw->src_set_state(src->rsc.ctrl_blk, SRC_STATE_OFF);\r\nhw->src_set_bm(src->rsc.ctrl_blk, 1);\r\nfor (rsr = 0, msr = src->rsc.msr; msr > 1; msr >>= 1)\r\nrsr++;\r\nhw->src_set_rsr(src->rsc.ctrl_blk, rsr);\r\nhw->src_set_sf(src->rsc.ctrl_blk, SRC_SF_S16);\r\nhw->src_set_wr(src->rsc.ctrl_blk, 0);\r\nhw->src_set_pm(src->rsc.ctrl_blk, 0);\r\nhw->src_set_rom(src->rsc.ctrl_blk, 0);\r\nhw->src_set_vo(src->rsc.ctrl_blk, 0);\r\nhw->src_set_st(src->rsc.ctrl_blk, 0);\r\nhw->src_set_ilsz(src->rsc.ctrl_blk, src->multi - 1);\r\nhw->src_set_cisz(src->rsc.ctrl_blk, 0x80);\r\nhw->src_set_sa(src->rsc.ctrl_blk, 0x0);\r\nhw->src_set_la(src->rsc.ctrl_blk, 0x1000);\r\nhw->src_set_ca(src->rsc.ctrl_blk, 0x80);\r\nhw->src_set_pitch(src->rsc.ctrl_blk, 0x1000000);\r\nhw->src_set_clear_zbufs(src->rsc.ctrl_blk, 1);\r\nsrc->rsc.ops->master(&src->rsc);\r\nhw->src_commit_write(hw, src->rsc.ops->index(&src->rsc),\r\nsrc->rsc.ctrl_blk);\r\nfor (msr = 1; msr < src->rsc.msr; msr++) {\r\nsrc->rsc.ops->next_conj(&src->rsc);\r\nhw->src_set_pitch(src->rsc.ctrl_blk, 0x1000000);\r\nhw->src_commit_write(hw, src->rsc.ops->index(&src->rsc),\r\nsrc->rsc.ctrl_blk);\r\n}\r\nsrc->rsc.ops->master(&src->rsc);\r\nreturn 0;\r\n}\r\nstatic int src_default_config_memwr(struct src *src)\r\n{\r\nstruct hw *hw = src->rsc.hw;\r\nhw->src_set_state(src->rsc.ctrl_blk, SRC_STATE_OFF);\r\nhw->src_set_bm(src->rsc.ctrl_blk, 1);\r\nhw->src_set_rsr(src->rsc.ctrl_blk, 0);\r\nhw->src_set_sf(src->rsc.ctrl_blk, SRC_SF_S16);\r\nhw->src_set_wr(src->rsc.ctrl_blk, 1);\r\nhw->src_set_pm(src->rsc.ctrl_blk, 0);\r\nhw->src_set_rom(src->rsc.ctrl_blk, 0);\r\nhw->src_set_vo(src->rsc.ctrl_blk, 0);\r\nhw->src_set_st(src->rsc.ctrl_blk, 0);\r\nhw->src_set_ilsz(src->rsc.ctrl_blk, 0);\r\nhw->src_set_cisz(src->rsc.ctrl_blk, 0x80);\r\nhw->src_set_sa(src->rsc.ctrl_blk, 0x0);\r\nhw->src_set_la(src->rsc.ctrl_blk, 0x1000);\r\nhw->src_set_ca(src->rsc.ctrl_blk, 0x80);\r\nhw->src_set_pitch(src->rsc.ctrl_blk, 0x1000000);\r\nhw->src_set_clear_zbufs(src->rsc.ctrl_blk, 1);\r\nsrc->rsc.ops->master(&src->rsc);\r\nhw->src_commit_write(hw, src->rsc.ops->index(&src->rsc),\r\nsrc->rsc.ctrl_blk);\r\nreturn 0;\r\n}\r\nstatic int src_default_config_arcrw(struct src *src)\r\n{\r\nstruct hw *hw = src->rsc.hw;\r\nunsigned int rsr, msr;\r\nunsigned int dirty;\r\nhw->src_set_state(src->rsc.ctrl_blk, SRC_STATE_OFF);\r\nhw->src_set_bm(src->rsc.ctrl_blk, 0);\r\nfor (rsr = 0, msr = src->rsc.msr; msr > 1; msr >>= 1)\r\nrsr++;\r\nhw->src_set_rsr(src->rsc.ctrl_blk, rsr);\r\nhw->src_set_sf(src->rsc.ctrl_blk, SRC_SF_F32);\r\nhw->src_set_wr(src->rsc.ctrl_blk, 0);\r\nhw->src_set_pm(src->rsc.ctrl_blk, 0);\r\nhw->src_set_rom(src->rsc.ctrl_blk, 0);\r\nhw->src_set_vo(src->rsc.ctrl_blk, 0);\r\nhw->src_set_st(src->rsc.ctrl_blk, 0);\r\nhw->src_set_ilsz(src->rsc.ctrl_blk, 0);\r\nhw->src_set_cisz(src->rsc.ctrl_blk, 0x80);\r\nhw->src_set_sa(src->rsc.ctrl_blk, 0x0);\r\nhw->src_set_la(src->rsc.ctrl_blk, 0x1000);\r\nhw->src_set_ca(src->rsc.ctrl_blk, 0x80);\r\nhw->src_set_pitch(src->rsc.ctrl_blk, 0x1000000);\r\nhw->src_set_clear_zbufs(src->rsc.ctrl_blk, 1);\r\ndirty = hw->src_get_dirty(src->rsc.ctrl_blk);\r\nsrc->rsc.ops->master(&src->rsc);\r\nfor (msr = 0; msr < src->rsc.msr; msr++) {\r\nhw->src_set_dirty(src->rsc.ctrl_blk, dirty);\r\nhw->src_commit_write(hw, src->rsc.ops->index(&src->rsc),\r\nsrc->rsc.ctrl_blk);\r\nsrc->rsc.ops->next_conj(&src->rsc);\r\n}\r\nsrc->rsc.ops->master(&src->rsc);\r\nreturn 0;\r\n}\r\nstatic int\r\nsrc_rsc_init(struct src *src, u32 idx,\r\nconst struct src_desc *desc, struct src_mgr *mgr)\r\n{\r\nint err;\r\nint i, n;\r\nstruct src *p;\r\nn = (MEMRD == desc->mode) ? desc->multi : 1;\r\nfor (i = 0, p = src; i < n; i++, p++) {\r\nerr = rsc_init(&p->rsc, idx + i, SRC, desc->msr, mgr->mgr.hw);\r\nif (err)\r\ngoto error1;\r\np->ops = &src_rsc_ops;\r\np->multi = (0 == i) ? desc->multi : 1;\r\np->mode = desc->mode;\r\nsrc_default_config[desc->mode](p);\r\nmgr->src_enable(mgr, p);\r\np->intlv = p + 1;\r\n}\r\n(--p)->intlv = NULL;\r\nmgr->commit_write(mgr);\r\nreturn 0;\r\nerror1:\r\nfor (i--, p--; i >= 0; i--, p--) {\r\nmgr->src_disable(mgr, p);\r\nrsc_uninit(&p->rsc);\r\n}\r\nmgr->commit_write(mgr);\r\nreturn err;\r\n}\r\nstatic int src_rsc_uninit(struct src *src, struct src_mgr *mgr)\r\n{\r\nint i, n;\r\nstruct src *p;\r\nn = (MEMRD == src->mode) ? src->multi : 1;\r\nfor (i = 0, p = src; i < n; i++, p++) {\r\nmgr->src_disable(mgr, p);\r\nrsc_uninit(&p->rsc);\r\np->multi = 0;\r\np->ops = NULL;\r\np->mode = NUM_SRCMODES;\r\np->intlv = NULL;\r\n}\r\nmgr->commit_write(mgr);\r\nreturn 0;\r\n}\r\nstatic int\r\nget_src_rsc(struct src_mgr *mgr, const struct src_desc *desc, struct src **rsrc)\r\n{\r\nunsigned int idx = SRC_RESOURCE_NUM;\r\nint err;\r\nstruct src *src;\r\nunsigned long flags;\r\n*rsrc = NULL;\r\nspin_lock_irqsave(&mgr->mgr_lock, flags);\r\nif (MEMRD == desc->mode)\r\nerr = mgr_get_resource(&mgr->mgr, desc->multi, &idx);\r\nelse\r\nerr = mgr_get_resource(&mgr->mgr, 1, &idx);\r\nspin_unlock_irqrestore(&mgr->mgr_lock, flags);\r\nif (err) {\r\ndev_err(mgr->card->dev,\r\n"Can't meet SRC resource request!\n");\r\nreturn err;\r\n}\r\nif (MEMRD == desc->mode)\r\nsrc = kcalloc(desc->multi, sizeof(*src), GFP_KERNEL);\r\nelse\r\nsrc = kzalloc(sizeof(*src), GFP_KERNEL);\r\nif (!src) {\r\nerr = -ENOMEM;\r\ngoto error1;\r\n}\r\nerr = src_rsc_init(src, idx, desc, mgr);\r\nif (err)\r\ngoto error2;\r\n*rsrc = src;\r\nreturn 0;\r\nerror2:\r\nkfree(src);\r\nerror1:\r\nspin_lock_irqsave(&mgr->mgr_lock, flags);\r\nif (MEMRD == desc->mode)\r\nmgr_put_resource(&mgr->mgr, desc->multi, idx);\r\nelse\r\nmgr_put_resource(&mgr->mgr, 1, idx);\r\nspin_unlock_irqrestore(&mgr->mgr_lock, flags);\r\nreturn err;\r\n}\r\nstatic int put_src_rsc(struct src_mgr *mgr, struct src *src)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&mgr->mgr_lock, flags);\r\nsrc->rsc.ops->master(&src->rsc);\r\nif (MEMRD == src->mode)\r\nmgr_put_resource(&mgr->mgr, src->multi,\r\nsrc->rsc.ops->index(&src->rsc));\r\nelse\r\nmgr_put_resource(&mgr->mgr, 1, src->rsc.ops->index(&src->rsc));\r\nspin_unlock_irqrestore(&mgr->mgr_lock, flags);\r\nsrc_rsc_uninit(src, mgr);\r\nkfree(src);\r\nreturn 0;\r\n}\r\nstatic int src_enable_s(struct src_mgr *mgr, struct src *src)\r\n{\r\nstruct hw *hw = mgr->mgr.hw;\r\nint i;\r\nsrc->rsc.ops->master(&src->rsc);\r\nfor (i = 0; i < src->rsc.msr; i++) {\r\nhw->src_mgr_enbs_src(mgr->mgr.ctrl_blk,\r\nsrc->rsc.ops->index(&src->rsc));\r\nsrc->rsc.ops->next_conj(&src->rsc);\r\n}\r\nsrc->rsc.ops->master(&src->rsc);\r\nreturn 0;\r\n}\r\nstatic int src_enable(struct src_mgr *mgr, struct src *src)\r\n{\r\nstruct hw *hw = mgr->mgr.hw;\r\nint i;\r\nsrc->rsc.ops->master(&src->rsc);\r\nfor (i = 0; i < src->rsc.msr; i++) {\r\nhw->src_mgr_enb_src(mgr->mgr.ctrl_blk,\r\nsrc->rsc.ops->index(&src->rsc));\r\nsrc->rsc.ops->next_conj(&src->rsc);\r\n}\r\nsrc->rsc.ops->master(&src->rsc);\r\nreturn 0;\r\n}\r\nstatic int src_disable(struct src_mgr *mgr, struct src *src)\r\n{\r\nstruct hw *hw = mgr->mgr.hw;\r\nint i;\r\nsrc->rsc.ops->master(&src->rsc);\r\nfor (i = 0; i < src->rsc.msr; i++) {\r\nhw->src_mgr_dsb_src(mgr->mgr.ctrl_blk,\r\nsrc->rsc.ops->index(&src->rsc));\r\nsrc->rsc.ops->next_conj(&src->rsc);\r\n}\r\nsrc->rsc.ops->master(&src->rsc);\r\nreturn 0;\r\n}\r\nstatic int src_mgr_commit_write(struct src_mgr *mgr)\r\n{\r\nstruct hw *hw = mgr->mgr.hw;\r\nhw->src_mgr_commit_write(hw, mgr->mgr.ctrl_blk);\r\nreturn 0;\r\n}\r\nint src_mgr_create(struct hw *hw, struct src_mgr **rsrc_mgr)\r\n{\r\nint err, i;\r\nstruct src_mgr *src_mgr;\r\n*rsrc_mgr = NULL;\r\nsrc_mgr = kzalloc(sizeof(*src_mgr), GFP_KERNEL);\r\nif (!src_mgr)\r\nreturn -ENOMEM;\r\nerr = rsc_mgr_init(&src_mgr->mgr, SRC, SRC_RESOURCE_NUM, hw);\r\nif (err)\r\ngoto error1;\r\nspin_lock_init(&src_mgr->mgr_lock);\r\nconj_mask = hw->src_dirty_conj_mask();\r\nsrc_mgr->get_src = get_src_rsc;\r\nsrc_mgr->put_src = put_src_rsc;\r\nsrc_mgr->src_enable_s = src_enable_s;\r\nsrc_mgr->src_enable = src_enable;\r\nsrc_mgr->src_disable = src_disable;\r\nsrc_mgr->commit_write = src_mgr_commit_write;\r\nsrc_mgr->card = hw->card;\r\nfor (i = 0; i < 256; i++)\r\nhw->src_mgr_dsb_src(src_mgr->mgr.ctrl_blk, i);\r\nhw->src_mgr_commit_write(hw, src_mgr->mgr.ctrl_blk);\r\n*rsrc_mgr = src_mgr;\r\nreturn 0;\r\nerror1:\r\nkfree(src_mgr);\r\nreturn err;\r\n}\r\nint src_mgr_destroy(struct src_mgr *src_mgr)\r\n{\r\nrsc_mgr_uninit(&src_mgr->mgr);\r\nkfree(src_mgr);\r\nreturn 0;\r\n}\r\nstatic int srcimp_master(struct rsc *rsc)\r\n{\r\nrsc->conj = 0;\r\nreturn rsc->idx = container_of(rsc, struct srcimp, rsc)->idx[0];\r\n}\r\nstatic int srcimp_next_conj(struct rsc *rsc)\r\n{\r\nrsc->conj++;\r\nreturn container_of(rsc, struct srcimp, rsc)->idx[rsc->conj];\r\n}\r\nstatic int srcimp_index(const struct rsc *rsc)\r\n{\r\nreturn container_of(rsc, struct srcimp, rsc)->idx[rsc->conj];\r\n}\r\nstatic int srcimp_map(struct srcimp *srcimp, struct src *src, struct rsc *input)\r\n{\r\nstruct imapper *entry;\r\nint i;\r\nsrcimp->rsc.ops->master(&srcimp->rsc);\r\nsrc->rsc.ops->master(&src->rsc);\r\ninput->ops->master(input);\r\nfor (i = 0; i < srcimp->rsc.msr; i++) {\r\nentry = &srcimp->imappers[i];\r\nentry->slot = input->ops->output_slot(input);\r\nentry->user = src->rsc.ops->index(&src->rsc);\r\nentry->addr = srcimp->rsc.ops->index(&srcimp->rsc);\r\nsrcimp->mgr->imap_add(srcimp->mgr, entry);\r\nsrcimp->mapped |= (0x1 << i);\r\nsrcimp->rsc.ops->next_conj(&srcimp->rsc);\r\ninput->ops->next_conj(input);\r\n}\r\nsrcimp->rsc.ops->master(&srcimp->rsc);\r\ninput->ops->master(input);\r\nreturn 0;\r\n}\r\nstatic int srcimp_unmap(struct srcimp *srcimp)\r\n{\r\nint i;\r\nfor (i = 0; i < srcimp->rsc.msr; i++) {\r\nif (srcimp->mapped & (0x1 << i)) {\r\nsrcimp->mgr->imap_delete(srcimp->mgr,\r\n&srcimp->imappers[i]);\r\nsrcimp->mapped &= ~(0x1 << i);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int srcimp_rsc_init(struct srcimp *srcimp,\r\nconst struct srcimp_desc *desc,\r\nstruct srcimp_mgr *mgr)\r\n{\r\nint err;\r\nerr = rsc_init(&srcimp->rsc, srcimp->idx[0],\r\nSRCIMP, desc->msr, mgr->mgr.hw);\r\nif (err)\r\nreturn err;\r\nsrcimp->imappers = kzalloc(sizeof(struct imapper)*desc->msr,\r\nGFP_KERNEL);\r\nif (!srcimp->imappers) {\r\nerr = -ENOMEM;\r\ngoto error1;\r\n}\r\nsrcimp->rsc.ops = &srcimp_basic_rsc_ops;\r\nsrcimp->ops = &srcimp_ops;\r\nsrcimp->mgr = mgr;\r\nsrcimp->rsc.ops->master(&srcimp->rsc);\r\nreturn 0;\r\nerror1:\r\nrsc_uninit(&srcimp->rsc);\r\nreturn err;\r\n}\r\nstatic int srcimp_rsc_uninit(struct srcimp *srcimp)\r\n{\r\nif (NULL != srcimp->imappers) {\r\nkfree(srcimp->imappers);\r\nsrcimp->imappers = NULL;\r\n}\r\nsrcimp->ops = NULL;\r\nsrcimp->mgr = NULL;\r\nrsc_uninit(&srcimp->rsc);\r\nreturn 0;\r\n}\r\nstatic int get_srcimp_rsc(struct srcimp_mgr *mgr,\r\nconst struct srcimp_desc *desc,\r\nstruct srcimp **rsrcimp)\r\n{\r\nint err, i;\r\nunsigned int idx;\r\nstruct srcimp *srcimp;\r\nunsigned long flags;\r\n*rsrcimp = NULL;\r\nsrcimp = kzalloc(sizeof(*srcimp), GFP_KERNEL);\r\nif (!srcimp)\r\nreturn -ENOMEM;\r\nerr = 0;\r\nspin_lock_irqsave(&mgr->mgr_lock, flags);\r\nfor (i = 0; i < desc->msr; i++) {\r\nerr = mgr_get_resource(&mgr->mgr, 1, &idx);\r\nif (err)\r\nbreak;\r\nsrcimp->idx[i] = idx;\r\n}\r\nspin_unlock_irqrestore(&mgr->mgr_lock, flags);\r\nif (err) {\r\ndev_err(mgr->card->dev,\r\n"Can't meet SRCIMP resource request!\n");\r\ngoto error1;\r\n}\r\nerr = srcimp_rsc_init(srcimp, desc, mgr);\r\nif (err)\r\ngoto error1;\r\n*rsrcimp = srcimp;\r\nreturn 0;\r\nerror1:\r\nspin_lock_irqsave(&mgr->mgr_lock, flags);\r\nfor (i--; i >= 0; i--)\r\nmgr_put_resource(&mgr->mgr, 1, srcimp->idx[i]);\r\nspin_unlock_irqrestore(&mgr->mgr_lock, flags);\r\nkfree(srcimp);\r\nreturn err;\r\n}\r\nstatic int put_srcimp_rsc(struct srcimp_mgr *mgr, struct srcimp *srcimp)\r\n{\r\nunsigned long flags;\r\nint i;\r\nspin_lock_irqsave(&mgr->mgr_lock, flags);\r\nfor (i = 0; i < srcimp->rsc.msr; i++)\r\nmgr_put_resource(&mgr->mgr, 1, srcimp->idx[i]);\r\nspin_unlock_irqrestore(&mgr->mgr_lock, flags);\r\nsrcimp_rsc_uninit(srcimp);\r\nkfree(srcimp);\r\nreturn 0;\r\n}\r\nstatic int srcimp_map_op(void *data, struct imapper *entry)\r\n{\r\nstruct rsc_mgr *mgr = &((struct srcimp_mgr *)data)->mgr;\r\nstruct hw *hw = mgr->hw;\r\nhw->srcimp_mgr_set_imaparc(mgr->ctrl_blk, entry->slot);\r\nhw->srcimp_mgr_set_imapuser(mgr->ctrl_blk, entry->user);\r\nhw->srcimp_mgr_set_imapnxt(mgr->ctrl_blk, entry->next);\r\nhw->srcimp_mgr_set_imapaddr(mgr->ctrl_blk, entry->addr);\r\nhw->srcimp_mgr_commit_write(mgr->hw, mgr->ctrl_blk);\r\nreturn 0;\r\n}\r\nstatic int srcimp_imap_add(struct srcimp_mgr *mgr, struct imapper *entry)\r\n{\r\nunsigned long flags;\r\nint err;\r\nspin_lock_irqsave(&mgr->imap_lock, flags);\r\nif ((0 == entry->addr) && (mgr->init_imap_added)) {\r\ninput_mapper_delete(&mgr->imappers,\r\nmgr->init_imap, srcimp_map_op, mgr);\r\nmgr->init_imap_added = 0;\r\n}\r\nerr = input_mapper_add(&mgr->imappers, entry, srcimp_map_op, mgr);\r\nspin_unlock_irqrestore(&mgr->imap_lock, flags);\r\nreturn err;\r\n}\r\nstatic int srcimp_imap_delete(struct srcimp_mgr *mgr, struct imapper *entry)\r\n{\r\nunsigned long flags;\r\nint err;\r\nspin_lock_irqsave(&mgr->imap_lock, flags);\r\nerr = input_mapper_delete(&mgr->imappers, entry, srcimp_map_op, mgr);\r\nif (list_empty(&mgr->imappers)) {\r\ninput_mapper_add(&mgr->imappers, mgr->init_imap,\r\nsrcimp_map_op, mgr);\r\nmgr->init_imap_added = 1;\r\n}\r\nspin_unlock_irqrestore(&mgr->imap_lock, flags);\r\nreturn err;\r\n}\r\nint srcimp_mgr_create(struct hw *hw, struct srcimp_mgr **rsrcimp_mgr)\r\n{\r\nint err;\r\nstruct srcimp_mgr *srcimp_mgr;\r\nstruct imapper *entry;\r\n*rsrcimp_mgr = NULL;\r\nsrcimp_mgr = kzalloc(sizeof(*srcimp_mgr), GFP_KERNEL);\r\nif (!srcimp_mgr)\r\nreturn -ENOMEM;\r\nerr = rsc_mgr_init(&srcimp_mgr->mgr, SRCIMP, SRCIMP_RESOURCE_NUM, hw);\r\nif (err)\r\ngoto error1;\r\nspin_lock_init(&srcimp_mgr->mgr_lock);\r\nspin_lock_init(&srcimp_mgr->imap_lock);\r\nINIT_LIST_HEAD(&srcimp_mgr->imappers);\r\nentry = kzalloc(sizeof(*entry), GFP_KERNEL);\r\nif (!entry) {\r\nerr = -ENOMEM;\r\ngoto error2;\r\n}\r\nentry->slot = entry->addr = entry->next = entry->user = 0;\r\nlist_add(&entry->list, &srcimp_mgr->imappers);\r\nsrcimp_mgr->init_imap = entry;\r\nsrcimp_mgr->init_imap_added = 1;\r\nsrcimp_mgr->get_srcimp = get_srcimp_rsc;\r\nsrcimp_mgr->put_srcimp = put_srcimp_rsc;\r\nsrcimp_mgr->imap_add = srcimp_imap_add;\r\nsrcimp_mgr->imap_delete = srcimp_imap_delete;\r\nsrcimp_mgr->card = hw->card;\r\n*rsrcimp_mgr = srcimp_mgr;\r\nreturn 0;\r\nerror2:\r\nrsc_mgr_uninit(&srcimp_mgr->mgr);\r\nerror1:\r\nkfree(srcimp_mgr);\r\nreturn err;\r\n}\r\nint srcimp_mgr_destroy(struct srcimp_mgr *srcimp_mgr)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&srcimp_mgr->imap_lock, flags);\r\nfree_input_mapper_list(&srcimp_mgr->imappers);\r\nspin_unlock_irqrestore(&srcimp_mgr->imap_lock, flags);\r\nrsc_mgr_uninit(&srcimp_mgr->mgr);\r\nkfree(srcimp_mgr);\r\nreturn 0;\r\n}
