static inline int get_n_events_by_type(int type)\r\n{\r\nBUG_ON(type != EV_SW && type != EV_KEY);\r\nreturn (type == EV_KEY) ? KEY_CNT : SW_CNT;\r\n}\r\nstatic void gpio_keys_disable_button(struct gpio_button_data *bdata)\r\n{\r\nif (!bdata->disabled) {\r\ndisable_irq(bdata->irq);\r\nif (gpio_is_valid(bdata->button->gpio))\r\ncancel_delayed_work_sync(&bdata->work);\r\nelse\r\ndel_timer_sync(&bdata->release_timer);\r\nbdata->disabled = true;\r\n}\r\n}\r\nstatic void gpio_keys_enable_button(struct gpio_button_data *bdata)\r\n{\r\nif (bdata->disabled) {\r\nenable_irq(bdata->irq);\r\nbdata->disabled = false;\r\n}\r\n}\r\nstatic ssize_t gpio_keys_attr_show_helper(struct gpio_keys_drvdata *ddata,\r\nchar *buf, unsigned int type,\r\nbool only_disabled)\r\n{\r\nint n_events = get_n_events_by_type(type);\r\nunsigned long *bits;\r\nssize_t ret;\r\nint i;\r\nbits = kcalloc(BITS_TO_LONGS(n_events), sizeof(*bits), GFP_KERNEL);\r\nif (!bits)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < ddata->pdata->nbuttons; i++) {\r\nstruct gpio_button_data *bdata = &ddata->data[i];\r\nif (bdata->button->type != type)\r\ncontinue;\r\nif (only_disabled && !bdata->disabled)\r\ncontinue;\r\n__set_bit(bdata->button->code, bits);\r\n}\r\nret = scnprintf(buf, PAGE_SIZE - 1, "%*pbl", n_events, bits);\r\nbuf[ret++] = '\n';\r\nbuf[ret] = '\0';\r\nkfree(bits);\r\nreturn ret;\r\n}\r\nstatic ssize_t gpio_keys_attr_store_helper(struct gpio_keys_drvdata *ddata,\r\nconst char *buf, unsigned int type)\r\n{\r\nint n_events = get_n_events_by_type(type);\r\nunsigned long *bits;\r\nssize_t error;\r\nint i;\r\nbits = kcalloc(BITS_TO_LONGS(n_events), sizeof(*bits), GFP_KERNEL);\r\nif (!bits)\r\nreturn -ENOMEM;\r\nerror = bitmap_parselist(buf, bits, n_events);\r\nif (error)\r\ngoto out;\r\nfor (i = 0; i < ddata->pdata->nbuttons; i++) {\r\nstruct gpio_button_data *bdata = &ddata->data[i];\r\nif (bdata->button->type != type)\r\ncontinue;\r\nif (test_bit(bdata->button->code, bits) &&\r\n!bdata->button->can_disable) {\r\nerror = -EINVAL;\r\ngoto out;\r\n}\r\n}\r\nmutex_lock(&ddata->disable_lock);\r\nfor (i = 0; i < ddata->pdata->nbuttons; i++) {\r\nstruct gpio_button_data *bdata = &ddata->data[i];\r\nif (bdata->button->type != type)\r\ncontinue;\r\nif (test_bit(bdata->button->code, bits))\r\ngpio_keys_disable_button(bdata);\r\nelse\r\ngpio_keys_enable_button(bdata);\r\n}\r\nmutex_unlock(&ddata->disable_lock);\r\nout:\r\nkfree(bits);\r\nreturn error;\r\n}\r\nstatic void gpio_keys_gpio_report_event(struct gpio_button_data *bdata)\r\n{\r\nconst struct gpio_keys_button *button = bdata->button;\r\nstruct input_dev *input = bdata->input;\r\nunsigned int type = button->type ?: EV_KEY;\r\nint state = (gpio_get_value_cansleep(button->gpio) ? 1 : 0) ^ button->active_low;\r\nif (type == EV_ABS) {\r\nif (state)\r\ninput_event(input, type, button->code, button->value);\r\n} else {\r\ninput_event(input, type, button->code, !!state);\r\n}\r\ninput_sync(input);\r\n}\r\nstatic void gpio_keys_gpio_work_func(struct work_struct *work)\r\n{\r\nstruct gpio_button_data *bdata =\r\ncontainer_of(work, struct gpio_button_data, work.work);\r\ngpio_keys_gpio_report_event(bdata);\r\nif (bdata->button->wakeup)\r\npm_relax(bdata->input->dev.parent);\r\n}\r\nstatic irqreturn_t gpio_keys_gpio_isr(int irq, void *dev_id)\r\n{\r\nstruct gpio_button_data *bdata = dev_id;\r\nBUG_ON(irq != bdata->irq);\r\nif (bdata->button->wakeup)\r\npm_stay_awake(bdata->input->dev.parent);\r\nmod_delayed_work(system_wq,\r\n&bdata->work,\r\nmsecs_to_jiffies(bdata->software_debounce));\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void gpio_keys_irq_timer(unsigned long _data)\r\n{\r\nstruct gpio_button_data *bdata = (struct gpio_button_data *)_data;\r\nstruct input_dev *input = bdata->input;\r\nunsigned long flags;\r\nspin_lock_irqsave(&bdata->lock, flags);\r\nif (bdata->key_pressed) {\r\ninput_event(input, EV_KEY, bdata->button->code, 0);\r\ninput_sync(input);\r\nbdata->key_pressed = false;\r\n}\r\nspin_unlock_irqrestore(&bdata->lock, flags);\r\n}\r\nstatic irqreturn_t gpio_keys_irq_isr(int irq, void *dev_id)\r\n{\r\nstruct gpio_button_data *bdata = dev_id;\r\nconst struct gpio_keys_button *button = bdata->button;\r\nstruct input_dev *input = bdata->input;\r\nunsigned long flags;\r\nBUG_ON(irq != bdata->irq);\r\nspin_lock_irqsave(&bdata->lock, flags);\r\nif (!bdata->key_pressed) {\r\nif (bdata->button->wakeup)\r\npm_wakeup_event(bdata->input->dev.parent, 0);\r\ninput_event(input, EV_KEY, button->code, 1);\r\ninput_sync(input);\r\nif (!bdata->release_delay) {\r\ninput_event(input, EV_KEY, button->code, 0);\r\ninput_sync(input);\r\ngoto out;\r\n}\r\nbdata->key_pressed = true;\r\n}\r\nif (bdata->release_delay)\r\nmod_timer(&bdata->release_timer,\r\njiffies + msecs_to_jiffies(bdata->release_delay));\r\nout:\r\nspin_unlock_irqrestore(&bdata->lock, flags);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void gpio_keys_quiesce_key(void *data)\r\n{\r\nstruct gpio_button_data *bdata = data;\r\nif (gpio_is_valid(bdata->button->gpio))\r\ncancel_delayed_work_sync(&bdata->work);\r\nelse\r\ndel_timer_sync(&bdata->release_timer);\r\n}\r\nstatic int gpio_keys_setup_key(struct platform_device *pdev,\r\nstruct input_dev *input,\r\nstruct gpio_button_data *bdata,\r\nconst struct gpio_keys_button *button)\r\n{\r\nconst char *desc = button->desc ? button->desc : "gpio_keys";\r\nstruct device *dev = &pdev->dev;\r\nirq_handler_t isr;\r\nunsigned long irqflags;\r\nint irq;\r\nint error;\r\nbdata->input = input;\r\nbdata->button = button;\r\nspin_lock_init(&bdata->lock);\r\nif (gpio_is_valid(button->gpio)) {\r\nerror = devm_gpio_request_one(&pdev->dev, button->gpio,\r\nGPIOF_IN, desc);\r\nif (error < 0) {\r\ndev_err(dev, "Failed to request GPIO %d, error %d\n",\r\nbutton->gpio, error);\r\nreturn error;\r\n}\r\nif (button->debounce_interval) {\r\nerror = gpio_set_debounce(button->gpio,\r\nbutton->debounce_interval * 1000);\r\nif (error < 0)\r\nbdata->software_debounce =\r\nbutton->debounce_interval;\r\n}\r\nif (button->irq) {\r\nbdata->irq = button->irq;\r\n} else {\r\nirq = gpio_to_irq(button->gpio);\r\nif (irq < 0) {\r\nerror = irq;\r\ndev_err(dev,\r\n"Unable to get irq number for GPIO %d, error %d\n",\r\nbutton->gpio, error);\r\nreturn error;\r\n}\r\nbdata->irq = irq;\r\n}\r\nINIT_DELAYED_WORK(&bdata->work, gpio_keys_gpio_work_func);\r\nisr = gpio_keys_gpio_isr;\r\nirqflags = IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING;\r\n} else {\r\nif (!button->irq) {\r\ndev_err(dev, "No IRQ specified\n");\r\nreturn -EINVAL;\r\n}\r\nbdata->irq = button->irq;\r\nif (button->type && button->type != EV_KEY) {\r\ndev_err(dev, "Only EV_KEY allowed for IRQ buttons.\n");\r\nreturn -EINVAL;\r\n}\r\nbdata->release_delay = button->debounce_interval;\r\nsetup_timer(&bdata->release_timer,\r\ngpio_keys_irq_timer, (unsigned long)bdata);\r\nisr = gpio_keys_irq_isr;\r\nirqflags = 0;\r\n}\r\ninput_set_capability(input, button->type ?: EV_KEY, button->code);\r\nerror = devm_add_action(&pdev->dev, gpio_keys_quiesce_key, bdata);\r\nif (error) {\r\ndev_err(&pdev->dev,\r\n"failed to register quiesce action, error: %d\n",\r\nerror);\r\nreturn error;\r\n}\r\nif (!button->can_disable)\r\nirqflags |= IRQF_SHARED;\r\nerror = devm_request_any_context_irq(&pdev->dev, bdata->irq,\r\nisr, irqflags, desc, bdata);\r\nif (error < 0) {\r\ndev_err(dev, "Unable to claim irq %d; error %d\n",\r\nbdata->irq, error);\r\nreturn error;\r\n}\r\nreturn 0;\r\n}\r\nstatic void gpio_keys_report_state(struct gpio_keys_drvdata *ddata)\r\n{\r\nstruct input_dev *input = ddata->input;\r\nint i;\r\nfor (i = 0; i < ddata->pdata->nbuttons; i++) {\r\nstruct gpio_button_data *bdata = &ddata->data[i];\r\nif (gpio_is_valid(bdata->button->gpio))\r\ngpio_keys_gpio_report_event(bdata);\r\n}\r\ninput_sync(input);\r\n}\r\nstatic int gpio_keys_open(struct input_dev *input)\r\n{\r\nstruct gpio_keys_drvdata *ddata = input_get_drvdata(input);\r\nconst struct gpio_keys_platform_data *pdata = ddata->pdata;\r\nint error;\r\nif (pdata->enable) {\r\nerror = pdata->enable(input->dev.parent);\r\nif (error)\r\nreturn error;\r\n}\r\ngpio_keys_report_state(ddata);\r\nreturn 0;\r\n}\r\nstatic void gpio_keys_close(struct input_dev *input)\r\n{\r\nstruct gpio_keys_drvdata *ddata = input_get_drvdata(input);\r\nconst struct gpio_keys_platform_data *pdata = ddata->pdata;\r\nif (pdata->disable)\r\npdata->disable(input->dev.parent);\r\n}\r\nstatic struct gpio_keys_platform_data *\r\ngpio_keys_get_devtree_pdata(struct device *dev)\r\n{\r\nstruct device_node *node, *pp;\r\nstruct gpio_keys_platform_data *pdata;\r\nstruct gpio_keys_button *button;\r\nint error;\r\nint nbuttons;\r\nint i;\r\nnode = dev->of_node;\r\nif (!node)\r\nreturn ERR_PTR(-ENODEV);\r\nnbuttons = of_get_child_count(node);\r\nif (nbuttons == 0)\r\nreturn ERR_PTR(-ENODEV);\r\npdata = devm_kzalloc(dev,\r\nsizeof(*pdata) + nbuttons * sizeof(*button),\r\nGFP_KERNEL);\r\nif (!pdata)\r\nreturn ERR_PTR(-ENOMEM);\r\npdata->buttons = (struct gpio_keys_button *)(pdata + 1);\r\npdata->nbuttons = nbuttons;\r\npdata->rep = !!of_get_property(node, "autorepeat", NULL);\r\ni = 0;\r\nfor_each_child_of_node(node, pp) {\r\nenum of_gpio_flags flags;\r\nbutton = &pdata->buttons[i++];\r\nbutton->gpio = of_get_gpio_flags(pp, 0, &flags);\r\nif (button->gpio < 0) {\r\nerror = button->gpio;\r\nif (error != -ENOENT) {\r\nif (error != -EPROBE_DEFER)\r\ndev_err(dev,\r\n"Failed to get gpio flags, error: %d\n",\r\nerror);\r\nreturn ERR_PTR(error);\r\n}\r\n} else {\r\nbutton->active_low = flags & OF_GPIO_ACTIVE_LOW;\r\n}\r\nbutton->irq = irq_of_parse_and_map(pp, 0);\r\nif (!gpio_is_valid(button->gpio) && !button->irq) {\r\ndev_err(dev, "Found button without gpios or irqs\n");\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nif (of_property_read_u32(pp, "linux,code", &button->code)) {\r\ndev_err(dev, "Button without keycode: 0x%x\n",\r\nbutton->gpio);\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nbutton->desc = of_get_property(pp, "label", NULL);\r\nif (of_property_read_u32(pp, "linux,input-type", &button->type))\r\nbutton->type = EV_KEY;\r\nbutton->wakeup = !!of_get_property(pp, "gpio-key,wakeup", NULL);\r\nbutton->can_disable = !!of_get_property(pp, "linux,can-disable", NULL);\r\nif (of_property_read_u32(pp, "debounce-interval",\r\n&button->debounce_interval))\r\nbutton->debounce_interval = 5;\r\n}\r\nif (pdata->nbuttons == 0)\r\nreturn ERR_PTR(-EINVAL);\r\nreturn pdata;\r\n}\r\nstatic inline struct gpio_keys_platform_data *\r\ngpio_keys_get_devtree_pdata(struct device *dev)\r\n{\r\nreturn ERR_PTR(-ENODEV);\r\n}\r\nstatic int gpio_keys_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nconst struct gpio_keys_platform_data *pdata = dev_get_platdata(dev);\r\nstruct gpio_keys_drvdata *ddata;\r\nstruct input_dev *input;\r\nsize_t size;\r\nint i, error;\r\nint wakeup = 0;\r\nif (!pdata) {\r\npdata = gpio_keys_get_devtree_pdata(dev);\r\nif (IS_ERR(pdata))\r\nreturn PTR_ERR(pdata);\r\n}\r\nsize = sizeof(struct gpio_keys_drvdata) +\r\npdata->nbuttons * sizeof(struct gpio_button_data);\r\nddata = devm_kzalloc(dev, size, GFP_KERNEL);\r\nif (!ddata) {\r\ndev_err(dev, "failed to allocate state\n");\r\nreturn -ENOMEM;\r\n}\r\ninput = devm_input_allocate_device(dev);\r\nif (!input) {\r\ndev_err(dev, "failed to allocate input device\n");\r\nreturn -ENOMEM;\r\n}\r\nddata->pdata = pdata;\r\nddata->input = input;\r\nmutex_init(&ddata->disable_lock);\r\nplatform_set_drvdata(pdev, ddata);\r\ninput_set_drvdata(input, ddata);\r\ninput->name = pdata->name ? : pdev->name;\r\ninput->phys = "gpio-keys/input0";\r\ninput->dev.parent = &pdev->dev;\r\ninput->open = gpio_keys_open;\r\ninput->close = gpio_keys_close;\r\ninput->id.bustype = BUS_HOST;\r\ninput->id.vendor = 0x0001;\r\ninput->id.product = 0x0001;\r\ninput->id.version = 0x0100;\r\nif (pdata->rep)\r\n__set_bit(EV_REP, input->evbit);\r\nfor (i = 0; i < pdata->nbuttons; i++) {\r\nconst struct gpio_keys_button *button = &pdata->buttons[i];\r\nstruct gpio_button_data *bdata = &ddata->data[i];\r\nerror = gpio_keys_setup_key(pdev, input, bdata, button);\r\nif (error)\r\nreturn error;\r\nif (button->wakeup)\r\nwakeup = 1;\r\n}\r\nerror = sysfs_create_group(&pdev->dev.kobj, &gpio_keys_attr_group);\r\nif (error) {\r\ndev_err(dev, "Unable to export keys/switches, error: %d\n",\r\nerror);\r\nreturn error;\r\n}\r\nerror = input_register_device(input);\r\nif (error) {\r\ndev_err(dev, "Unable to register input device, error: %d\n",\r\nerror);\r\ngoto err_remove_group;\r\n}\r\ndevice_init_wakeup(&pdev->dev, wakeup);\r\nreturn 0;\r\nerr_remove_group:\r\nsysfs_remove_group(&pdev->dev.kobj, &gpio_keys_attr_group);\r\nreturn error;\r\n}\r\nstatic int gpio_keys_remove(struct platform_device *pdev)\r\n{\r\nsysfs_remove_group(&pdev->dev.kobj, &gpio_keys_attr_group);\r\ndevice_init_wakeup(&pdev->dev, 0);\r\nreturn 0;\r\n}\r\nstatic int gpio_keys_suspend(struct device *dev)\r\n{\r\nstruct gpio_keys_drvdata *ddata = dev_get_drvdata(dev);\r\nstruct input_dev *input = ddata->input;\r\nint i;\r\nif (device_may_wakeup(dev)) {\r\nfor (i = 0; i < ddata->pdata->nbuttons; i++) {\r\nstruct gpio_button_data *bdata = &ddata->data[i];\r\nif (bdata->button->wakeup)\r\nenable_irq_wake(bdata->irq);\r\n}\r\n} else {\r\nmutex_lock(&input->mutex);\r\nif (input->users)\r\ngpio_keys_close(input);\r\nmutex_unlock(&input->mutex);\r\n}\r\nreturn 0;\r\n}\r\nstatic int gpio_keys_resume(struct device *dev)\r\n{\r\nstruct gpio_keys_drvdata *ddata = dev_get_drvdata(dev);\r\nstruct input_dev *input = ddata->input;\r\nint error = 0;\r\nint i;\r\nif (device_may_wakeup(dev)) {\r\nfor (i = 0; i < ddata->pdata->nbuttons; i++) {\r\nstruct gpio_button_data *bdata = &ddata->data[i];\r\nif (bdata->button->wakeup)\r\ndisable_irq_wake(bdata->irq);\r\n}\r\n} else {\r\nmutex_lock(&input->mutex);\r\nif (input->users)\r\nerror = gpio_keys_open(input);\r\nmutex_unlock(&input->mutex);\r\n}\r\nif (error)\r\nreturn error;\r\ngpio_keys_report_state(ddata);\r\nreturn 0;\r\n}\r\nstatic int __init gpio_keys_init(void)\r\n{\r\nreturn platform_driver_register(&gpio_keys_device_driver);\r\n}\r\nstatic void __exit gpio_keys_exit(void)\r\n{\r\nplatform_driver_unregister(&gpio_keys_device_driver);\r\n}
