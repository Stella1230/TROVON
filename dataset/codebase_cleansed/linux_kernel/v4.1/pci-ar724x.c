static inline bool ar724x_pci_check_link(struct ar724x_pci_controller *apc)\r\n{\r\nu32 reset;\r\nreset = __raw_readl(apc->ctrl_base + AR724X_PCI_REG_RESET);\r\nreturn reset & AR724X_PCI_RESET_LINK_UP;\r\n}\r\nstatic inline struct ar724x_pci_controller *\r\npci_bus_to_ar724x_controller(struct pci_bus *bus)\r\n{\r\nstruct pci_controller *hose;\r\nhose = (struct pci_controller *) bus->sysdata;\r\nreturn container_of(hose, struct ar724x_pci_controller, pci_controller);\r\n}\r\nstatic int ar724x_pci_local_write(struct ar724x_pci_controller *apc,\r\nint where, int size, u32 value)\r\n{\r\nvoid __iomem *base;\r\nu32 data;\r\nint s;\r\nWARN_ON(where & (size - 1));\r\nif (!apc->link_up)\r\nreturn PCIBIOS_DEVICE_NOT_FOUND;\r\nbase = apc->crp_base;\r\ndata = __raw_readl(base + (where & ~3));\r\nswitch (size) {\r\ncase 1:\r\ns = ((where & 3) * 8);\r\ndata &= ~(0xff << s);\r\ndata |= ((value & 0xff) << s);\r\nbreak;\r\ncase 2:\r\ns = ((where & 2) * 8);\r\ndata &= ~(0xffff << s);\r\ndata |= ((value & 0xffff) << s);\r\nbreak;\r\ncase 4:\r\ndata = value;\r\nbreak;\r\ndefault:\r\nreturn PCIBIOS_BAD_REGISTER_NUMBER;\r\n}\r\n__raw_writel(data, base + (where & ~3));\r\n__raw_readl(base + (where & ~3));\r\nreturn PCIBIOS_SUCCESSFUL;\r\n}\r\nstatic int ar724x_pci_read(struct pci_bus *bus, unsigned int devfn, int where,\r\nint size, uint32_t *value)\r\n{\r\nstruct ar724x_pci_controller *apc;\r\nvoid __iomem *base;\r\nu32 data;\r\napc = pci_bus_to_ar724x_controller(bus);\r\nif (!apc->link_up)\r\nreturn PCIBIOS_DEVICE_NOT_FOUND;\r\nif (devfn)\r\nreturn PCIBIOS_DEVICE_NOT_FOUND;\r\nbase = apc->devcfg_base;\r\ndata = __raw_readl(base + (where & ~3));\r\nswitch (size) {\r\ncase 1:\r\nif (where & 1)\r\ndata >>= 8;\r\nif (where & 2)\r\ndata >>= 16;\r\ndata &= 0xff;\r\nbreak;\r\ncase 2:\r\nif (where & 2)\r\ndata >>= 16;\r\ndata &= 0xffff;\r\nbreak;\r\ncase 4:\r\nbreak;\r\ndefault:\r\nreturn PCIBIOS_BAD_REGISTER_NUMBER;\r\n}\r\nif (where == PCI_BASE_ADDRESS_0 && size == 4 &&\r\napc->bar0_is_cached) {\r\n*value = apc->bar0_value;\r\n} else {\r\n*value = data;\r\n}\r\nreturn PCIBIOS_SUCCESSFUL;\r\n}\r\nstatic int ar724x_pci_write(struct pci_bus *bus, unsigned int devfn, int where,\r\nint size, uint32_t value)\r\n{\r\nstruct ar724x_pci_controller *apc;\r\nvoid __iomem *base;\r\nu32 data;\r\nint s;\r\napc = pci_bus_to_ar724x_controller(bus);\r\nif (!apc->link_up)\r\nreturn PCIBIOS_DEVICE_NOT_FOUND;\r\nif (devfn)\r\nreturn PCIBIOS_DEVICE_NOT_FOUND;\r\nif (soc_is_ar7240() && where == PCI_BASE_ADDRESS_0 && size == 4) {\r\nif (value != 0xffffffff) {\r\napc->bar0_is_cached = true;\r\napc->bar0_value = value;\r\nvalue = AR7240_BAR0_WAR_VALUE;\r\n} else {\r\napc->bar0_is_cached = false;\r\n}\r\n}\r\nbase = apc->devcfg_base;\r\ndata = __raw_readl(base + (where & ~3));\r\nswitch (size) {\r\ncase 1:\r\ns = ((where & 3) * 8);\r\ndata &= ~(0xff << s);\r\ndata |= ((value & 0xff) << s);\r\nbreak;\r\ncase 2:\r\ns = ((where & 2) * 8);\r\ndata &= ~(0xffff << s);\r\ndata |= ((value & 0xffff) << s);\r\nbreak;\r\ncase 4:\r\ndata = value;\r\nbreak;\r\ndefault:\r\nreturn PCIBIOS_BAD_REGISTER_NUMBER;\r\n}\r\n__raw_writel(data, base + (where & ~3));\r\n__raw_readl(base + (where & ~3));\r\nreturn PCIBIOS_SUCCESSFUL;\r\n}\r\nstatic void ar724x_pci_irq_handler(unsigned int irq, struct irq_desc *desc)\r\n{\r\nstruct ar724x_pci_controller *apc;\r\nvoid __iomem *base;\r\nu32 pending;\r\napc = irq_get_handler_data(irq);\r\nbase = apc->ctrl_base;\r\npending = __raw_readl(base + AR724X_PCI_REG_INT_STATUS) &\r\n__raw_readl(base + AR724X_PCI_REG_INT_MASK);\r\nif (pending & AR724X_PCI_INT_DEV0)\r\ngeneric_handle_irq(apc->irq_base + 0);\r\nelse\r\nspurious_interrupt();\r\n}\r\nstatic void ar724x_pci_irq_unmask(struct irq_data *d)\r\n{\r\nstruct ar724x_pci_controller *apc;\r\nvoid __iomem *base;\r\nint offset;\r\nu32 t;\r\napc = irq_data_get_irq_chip_data(d);\r\nbase = apc->ctrl_base;\r\noffset = apc->irq_base - d->irq;\r\nswitch (offset) {\r\ncase 0:\r\nt = __raw_readl(base + AR724X_PCI_REG_INT_MASK);\r\n__raw_writel(t | AR724X_PCI_INT_DEV0,\r\nbase + AR724X_PCI_REG_INT_MASK);\r\n__raw_readl(base + AR724X_PCI_REG_INT_MASK);\r\n}\r\n}\r\nstatic void ar724x_pci_irq_mask(struct irq_data *d)\r\n{\r\nstruct ar724x_pci_controller *apc;\r\nvoid __iomem *base;\r\nint offset;\r\nu32 t;\r\napc = irq_data_get_irq_chip_data(d);\r\nbase = apc->ctrl_base;\r\noffset = apc->irq_base - d->irq;\r\nswitch (offset) {\r\ncase 0:\r\nt = __raw_readl(base + AR724X_PCI_REG_INT_MASK);\r\n__raw_writel(t & ~AR724X_PCI_INT_DEV0,\r\nbase + AR724X_PCI_REG_INT_MASK);\r\n__raw_readl(base + AR724X_PCI_REG_INT_MASK);\r\nt = __raw_readl(base + AR724X_PCI_REG_INT_STATUS);\r\n__raw_writel(t | AR724X_PCI_INT_DEV0,\r\nbase + AR724X_PCI_REG_INT_STATUS);\r\n__raw_readl(base + AR724X_PCI_REG_INT_STATUS);\r\n}\r\n}\r\nstatic void ar724x_pci_irq_init(struct ar724x_pci_controller *apc,\r\nint id)\r\n{\r\nvoid __iomem *base;\r\nint i;\r\nbase = apc->ctrl_base;\r\n__raw_writel(0, base + AR724X_PCI_REG_INT_MASK);\r\n__raw_writel(0, base + AR724X_PCI_REG_INT_STATUS);\r\napc->irq_base = ATH79_PCI_IRQ_BASE + (id * AR724X_PCI_IRQ_COUNT);\r\nfor (i = apc->irq_base;\r\ni < apc->irq_base + AR724X_PCI_IRQ_COUNT; i++) {\r\nirq_set_chip_and_handler(i, &ar724x_pci_irq_chip,\r\nhandle_level_irq);\r\nirq_set_chip_data(i, apc);\r\n}\r\nirq_set_handler_data(apc->irq, apc);\r\nirq_set_chained_handler(apc->irq, ar724x_pci_irq_handler);\r\n}\r\nstatic int ar724x_pci_probe(struct platform_device *pdev)\r\n{\r\nstruct ar724x_pci_controller *apc;\r\nstruct resource *res;\r\nint id;\r\nid = pdev->id;\r\nif (id == -1)\r\nid = 0;\r\napc = devm_kzalloc(&pdev->dev, sizeof(struct ar724x_pci_controller),\r\nGFP_KERNEL);\r\nif (!apc)\r\nreturn -ENOMEM;\r\nres = platform_get_resource_byname(pdev, IORESOURCE_MEM, "ctrl_base");\r\napc->ctrl_base = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(apc->ctrl_base))\r\nreturn PTR_ERR(apc->ctrl_base);\r\nres = platform_get_resource_byname(pdev, IORESOURCE_MEM, "cfg_base");\r\napc->devcfg_base = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(apc->devcfg_base))\r\nreturn PTR_ERR(apc->devcfg_base);\r\nres = platform_get_resource_byname(pdev, IORESOURCE_MEM, "crp_base");\r\napc->crp_base = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(apc->crp_base))\r\nreturn PTR_ERR(apc->crp_base);\r\napc->irq = platform_get_irq(pdev, 0);\r\nif (apc->irq < 0)\r\nreturn -EINVAL;\r\nres = platform_get_resource_byname(pdev, IORESOURCE_IO, "io_base");\r\nif (!res)\r\nreturn -EINVAL;\r\napc->io_res.parent = res;\r\napc->io_res.name = "PCI IO space";\r\napc->io_res.start = res->start;\r\napc->io_res.end = res->end;\r\napc->io_res.flags = IORESOURCE_IO;\r\nres = platform_get_resource_byname(pdev, IORESOURCE_MEM, "mem_base");\r\nif (!res)\r\nreturn -EINVAL;\r\napc->mem_res.parent = res;\r\napc->mem_res.name = "PCI memory space";\r\napc->mem_res.start = res->start;\r\napc->mem_res.end = res->end;\r\napc->mem_res.flags = IORESOURCE_MEM;\r\napc->pci_controller.pci_ops = &ar724x_pci_ops;\r\napc->pci_controller.io_resource = &apc->io_res;\r\napc->pci_controller.mem_resource = &apc->mem_res;\r\napc->link_up = ar724x_pci_check_link(apc);\r\nif (!apc->link_up)\r\ndev_warn(&pdev->dev, "PCIe link is down\n");\r\nar724x_pci_irq_init(apc, id);\r\nar724x_pci_local_write(apc, PCI_COMMAND, 4, AR724X_PCI_CMD_INIT);\r\nregister_pci_controller(&apc->pci_controller);\r\nreturn 0;\r\n}\r\nstatic int __init ar724x_pci_init(void)\r\n{\r\nreturn platform_driver_register(&ar724x_pci_driver);\r\n}
