static int omap_prefetch_enable(int cs, int fifo_th, int dma_mode,\r\nunsigned int u32_count, int is_write, struct omap_nand_info *info)\r\n{\r\nu32 val;\r\nif (fifo_th > PREFETCH_FIFOTHRESHOLD_MAX)\r\nreturn -1;\r\nif (readl(info->reg.gpmc_prefetch_control))\r\nreturn -EBUSY;\r\nwritel(u32_count, info->reg.gpmc_prefetch_config2);\r\nval = ((cs << PREFETCH_CONFIG1_CS_SHIFT) |\r\nPREFETCH_FIFOTHRESHOLD(fifo_th) | ENABLE_PREFETCH |\r\n(dma_mode << DMA_MPU_MODE_SHIFT) | (0x1 & is_write));\r\nwritel(val, info->reg.gpmc_prefetch_config1);\r\nwritel(0x1, info->reg.gpmc_prefetch_control);\r\nreturn 0;\r\n}\r\nstatic int omap_prefetch_reset(int cs, struct omap_nand_info *info)\r\n{\r\nu32 config1;\r\nconfig1 = readl(info->reg.gpmc_prefetch_config1);\r\nif (((config1 >> PREFETCH_CONFIG1_CS_SHIFT) & CS_MASK) != cs)\r\nreturn -EINVAL;\r\nwritel(0x0, info->reg.gpmc_prefetch_control);\r\nwritel(0x0, info->reg.gpmc_prefetch_config1);\r\nreturn 0;\r\n}\r\nstatic void omap_hwcontrol(struct mtd_info *mtd, int cmd, unsigned int ctrl)\r\n{\r\nstruct omap_nand_info *info = container_of(mtd,\r\nstruct omap_nand_info, mtd);\r\nif (cmd != NAND_CMD_NONE) {\r\nif (ctrl & NAND_CLE)\r\nwriteb(cmd, info->reg.gpmc_nand_command);\r\nelse if (ctrl & NAND_ALE)\r\nwriteb(cmd, info->reg.gpmc_nand_address);\r\nelse\r\nwriteb(cmd, info->reg.gpmc_nand_data);\r\n}\r\n}\r\nstatic void omap_read_buf8(struct mtd_info *mtd, u_char *buf, int len)\r\n{\r\nstruct nand_chip *nand = mtd->priv;\r\nioread8_rep(nand->IO_ADDR_R, buf, len);\r\n}\r\nstatic void omap_write_buf8(struct mtd_info *mtd, const u_char *buf, int len)\r\n{\r\nstruct omap_nand_info *info = container_of(mtd,\r\nstruct omap_nand_info, mtd);\r\nu_char *p = (u_char *)buf;\r\nu32 status = 0;\r\nwhile (len--) {\r\niowrite8(*p++, info->nand.IO_ADDR_W);\r\ndo {\r\nstatus = readl(info->reg.gpmc_status) &\r\nSTATUS_BUFF_EMPTY;\r\n} while (!status);\r\n}\r\n}\r\nstatic void omap_read_buf16(struct mtd_info *mtd, u_char *buf, int len)\r\n{\r\nstruct nand_chip *nand = mtd->priv;\r\nioread16_rep(nand->IO_ADDR_R, buf, len / 2);\r\n}\r\nstatic void omap_write_buf16(struct mtd_info *mtd, const u_char * buf, int len)\r\n{\r\nstruct omap_nand_info *info = container_of(mtd,\r\nstruct omap_nand_info, mtd);\r\nu16 *p = (u16 *) buf;\r\nu32 status = 0;\r\nlen >>= 1;\r\nwhile (len--) {\r\niowrite16(*p++, info->nand.IO_ADDR_W);\r\ndo {\r\nstatus = readl(info->reg.gpmc_status) &\r\nSTATUS_BUFF_EMPTY;\r\n} while (!status);\r\n}\r\n}\r\nstatic void omap_read_buf_pref(struct mtd_info *mtd, u_char *buf, int len)\r\n{\r\nstruct omap_nand_info *info = container_of(mtd,\r\nstruct omap_nand_info, mtd);\r\nuint32_t r_count = 0;\r\nint ret = 0;\r\nu32 *p = (u32 *)buf;\r\nif (len % 4) {\r\nif (info->nand.options & NAND_BUSWIDTH_16)\r\nomap_read_buf16(mtd, buf, len % 4);\r\nelse\r\nomap_read_buf8(mtd, buf, len % 4);\r\np = (u32 *) (buf + len % 4);\r\nlen -= len % 4;\r\n}\r\nret = omap_prefetch_enable(info->gpmc_cs,\r\nPREFETCH_FIFOTHRESHOLD_MAX, 0x0, len, 0x0, info);\r\nif (ret) {\r\nif (info->nand.options & NAND_BUSWIDTH_16)\r\nomap_read_buf16(mtd, (u_char *)p, len);\r\nelse\r\nomap_read_buf8(mtd, (u_char *)p, len);\r\n} else {\r\ndo {\r\nr_count = readl(info->reg.gpmc_prefetch_status);\r\nr_count = PREFETCH_STATUS_FIFO_CNT(r_count);\r\nr_count = r_count >> 2;\r\nioread32_rep(info->nand.IO_ADDR_R, p, r_count);\r\np += r_count;\r\nlen -= r_count << 2;\r\n} while (len);\r\nomap_prefetch_reset(info->gpmc_cs, info);\r\n}\r\n}\r\nstatic void omap_write_buf_pref(struct mtd_info *mtd,\r\nconst u_char *buf, int len)\r\n{\r\nstruct omap_nand_info *info = container_of(mtd,\r\nstruct omap_nand_info, mtd);\r\nuint32_t w_count = 0;\r\nint i = 0, ret = 0;\r\nu16 *p = (u16 *)buf;\r\nunsigned long tim, limit;\r\nu32 val;\r\nif (len % 2 != 0) {\r\nwriteb(*buf, info->nand.IO_ADDR_W);\r\np = (u16 *)(buf + 1);\r\nlen--;\r\n}\r\nret = omap_prefetch_enable(info->gpmc_cs,\r\nPREFETCH_FIFOTHRESHOLD_MAX, 0x0, len, 0x1, info);\r\nif (ret) {\r\nif (info->nand.options & NAND_BUSWIDTH_16)\r\nomap_write_buf16(mtd, (u_char *)p, len);\r\nelse\r\nomap_write_buf8(mtd, (u_char *)p, len);\r\n} else {\r\nwhile (len) {\r\nw_count = readl(info->reg.gpmc_prefetch_status);\r\nw_count = PREFETCH_STATUS_FIFO_CNT(w_count);\r\nw_count = w_count >> 1;\r\nfor (i = 0; (i < w_count) && len; i++, len -= 2)\r\niowrite16(*p++, info->nand.IO_ADDR_W);\r\n}\r\ntim = 0;\r\nlimit = (loops_per_jiffy *\r\nmsecs_to_jiffies(OMAP_NAND_TIMEOUT_MS));\r\ndo {\r\ncpu_relax();\r\nval = readl(info->reg.gpmc_prefetch_status);\r\nval = PREFETCH_STATUS_COUNT(val);\r\n} while (val && (tim++ < limit));\r\nomap_prefetch_reset(info->gpmc_cs, info);\r\n}\r\n}\r\nstatic void omap_nand_dma_callback(void *data)\r\n{\r\ncomplete((struct completion *) data);\r\n}\r\nstatic inline int omap_nand_dma_transfer(struct mtd_info *mtd, void *addr,\r\nunsigned int len, int is_write)\r\n{\r\nstruct omap_nand_info *info = container_of(mtd,\r\nstruct omap_nand_info, mtd);\r\nstruct dma_async_tx_descriptor *tx;\r\nenum dma_data_direction dir = is_write ? DMA_TO_DEVICE :\r\nDMA_FROM_DEVICE;\r\nstruct scatterlist sg;\r\nunsigned long tim, limit;\r\nunsigned n;\r\nint ret;\r\nu32 val;\r\nif (addr >= high_memory) {\r\nstruct page *p1;\r\nif (((size_t)addr & PAGE_MASK) !=\r\n((size_t)(addr + len - 1) & PAGE_MASK))\r\ngoto out_copy;\r\np1 = vmalloc_to_page(addr);\r\nif (!p1)\r\ngoto out_copy;\r\naddr = page_address(p1) + ((size_t)addr & ~PAGE_MASK);\r\n}\r\nsg_init_one(&sg, addr, len);\r\nn = dma_map_sg(info->dma->device->dev, &sg, 1, dir);\r\nif (n == 0) {\r\ndev_err(&info->pdev->dev,\r\n"Couldn't DMA map a %d byte buffer\n", len);\r\ngoto out_copy;\r\n}\r\ntx = dmaengine_prep_slave_sg(info->dma, &sg, n,\r\nis_write ? DMA_MEM_TO_DEV : DMA_DEV_TO_MEM,\r\nDMA_PREP_INTERRUPT | DMA_CTRL_ACK);\r\nif (!tx)\r\ngoto out_copy_unmap;\r\ntx->callback = omap_nand_dma_callback;\r\ntx->callback_param = &info->comp;\r\ndmaengine_submit(tx);\r\nret = omap_prefetch_enable(info->gpmc_cs,\r\nPREFETCH_FIFOTHRESHOLD_MAX, 0x1, len, is_write, info);\r\nif (ret)\r\ngoto out_copy_unmap;\r\ninit_completion(&info->comp);\r\ndma_async_issue_pending(info->dma);\r\nwait_for_completion(&info->comp);\r\ntim = 0;\r\nlimit = (loops_per_jiffy * msecs_to_jiffies(OMAP_NAND_TIMEOUT_MS));\r\ndo {\r\ncpu_relax();\r\nval = readl(info->reg.gpmc_prefetch_status);\r\nval = PREFETCH_STATUS_COUNT(val);\r\n} while (val && (tim++ < limit));\r\nomap_prefetch_reset(info->gpmc_cs, info);\r\ndma_unmap_sg(info->dma->device->dev, &sg, 1, dir);\r\nreturn 0;\r\nout_copy_unmap:\r\ndma_unmap_sg(info->dma->device->dev, &sg, 1, dir);\r\nout_copy:\r\nif (info->nand.options & NAND_BUSWIDTH_16)\r\nis_write == 0 ? omap_read_buf16(mtd, (u_char *) addr, len)\r\n: omap_write_buf16(mtd, (u_char *) addr, len);\r\nelse\r\nis_write == 0 ? omap_read_buf8(mtd, (u_char *) addr, len)\r\n: omap_write_buf8(mtd, (u_char *) addr, len);\r\nreturn 0;\r\n}\r\nstatic void omap_read_buf_dma_pref(struct mtd_info *mtd, u_char *buf, int len)\r\n{\r\nif (len <= mtd->oobsize)\r\nomap_read_buf_pref(mtd, buf, len);\r\nelse\r\nomap_nand_dma_transfer(mtd, buf, len, 0x0);\r\n}\r\nstatic void omap_write_buf_dma_pref(struct mtd_info *mtd,\r\nconst u_char *buf, int len)\r\n{\r\nif (len <= mtd->oobsize)\r\nomap_write_buf_pref(mtd, buf, len);\r\nelse\r\nomap_nand_dma_transfer(mtd, (u_char *) buf, len, 0x1);\r\n}\r\nstatic irqreturn_t omap_nand_irq(int this_irq, void *dev)\r\n{\r\nstruct omap_nand_info *info = (struct omap_nand_info *) dev;\r\nu32 bytes;\r\nbytes = readl(info->reg.gpmc_prefetch_status);\r\nbytes = PREFETCH_STATUS_FIFO_CNT(bytes);\r\nbytes = bytes & 0xFFFC;\r\nif (info->iomode == OMAP_NAND_IO_WRITE) {\r\nif (this_irq == info->gpmc_irq_count)\r\ngoto done;\r\nif (info->buf_len && (info->buf_len < bytes))\r\nbytes = info->buf_len;\r\nelse if (!info->buf_len)\r\nbytes = 0;\r\niowrite32_rep(info->nand.IO_ADDR_W,\r\n(u32 *)info->buf, bytes >> 2);\r\ninfo->buf = info->buf + bytes;\r\ninfo->buf_len -= bytes;\r\n} else {\r\nioread32_rep(info->nand.IO_ADDR_R,\r\n(u32 *)info->buf, bytes >> 2);\r\ninfo->buf = info->buf + bytes;\r\nif (this_irq == info->gpmc_irq_count)\r\ngoto done;\r\n}\r\nreturn IRQ_HANDLED;\r\ndone:\r\ncomplete(&info->comp);\r\ndisable_irq_nosync(info->gpmc_irq_fifo);\r\ndisable_irq_nosync(info->gpmc_irq_count);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void omap_read_buf_irq_pref(struct mtd_info *mtd, u_char *buf, int len)\r\n{\r\nstruct omap_nand_info *info = container_of(mtd,\r\nstruct omap_nand_info, mtd);\r\nint ret = 0;\r\nif (len <= mtd->oobsize) {\r\nomap_read_buf_pref(mtd, buf, len);\r\nreturn;\r\n}\r\ninfo->iomode = OMAP_NAND_IO_READ;\r\ninfo->buf = buf;\r\ninit_completion(&info->comp);\r\nret = omap_prefetch_enable(info->gpmc_cs,\r\nPREFETCH_FIFOTHRESHOLD_MAX/2, 0x0, len, 0x0, info);\r\nif (ret)\r\ngoto out_copy;\r\ninfo->buf_len = len;\r\nenable_irq(info->gpmc_irq_count);\r\nenable_irq(info->gpmc_irq_fifo);\r\nwait_for_completion(&info->comp);\r\nomap_prefetch_reset(info->gpmc_cs, info);\r\nreturn;\r\nout_copy:\r\nif (info->nand.options & NAND_BUSWIDTH_16)\r\nomap_read_buf16(mtd, buf, len);\r\nelse\r\nomap_read_buf8(mtd, buf, len);\r\n}\r\nstatic void omap_write_buf_irq_pref(struct mtd_info *mtd,\r\nconst u_char *buf, int len)\r\n{\r\nstruct omap_nand_info *info = container_of(mtd,\r\nstruct omap_nand_info, mtd);\r\nint ret = 0;\r\nunsigned long tim, limit;\r\nu32 val;\r\nif (len <= mtd->oobsize) {\r\nomap_write_buf_pref(mtd, buf, len);\r\nreturn;\r\n}\r\ninfo->iomode = OMAP_NAND_IO_WRITE;\r\ninfo->buf = (u_char *) buf;\r\ninit_completion(&info->comp);\r\nret = omap_prefetch_enable(info->gpmc_cs,\r\n(PREFETCH_FIFOTHRESHOLD_MAX * 3) / 8, 0x0, len, 0x1, info);\r\nif (ret)\r\ngoto out_copy;\r\ninfo->buf_len = len;\r\nenable_irq(info->gpmc_irq_count);\r\nenable_irq(info->gpmc_irq_fifo);\r\nwait_for_completion(&info->comp);\r\ntim = 0;\r\nlimit = (loops_per_jiffy * msecs_to_jiffies(OMAP_NAND_TIMEOUT_MS));\r\ndo {\r\nval = readl(info->reg.gpmc_prefetch_status);\r\nval = PREFETCH_STATUS_COUNT(val);\r\ncpu_relax();\r\n} while (val && (tim++ < limit));\r\nomap_prefetch_reset(info->gpmc_cs, info);\r\nreturn;\r\nout_copy:\r\nif (info->nand.options & NAND_BUSWIDTH_16)\r\nomap_write_buf16(mtd, buf, len);\r\nelse\r\nomap_write_buf8(mtd, buf, len);\r\n}\r\nstatic void gen_true_ecc(u8 *ecc_buf)\r\n{\r\nu32 tmp = ecc_buf[0] | (ecc_buf[1] << 16) |\r\n((ecc_buf[2] & 0xF0) << 20) | ((ecc_buf[2] & 0x0F) << 8);\r\necc_buf[0] = ~(P64o(tmp) | P64e(tmp) | P32o(tmp) | P32e(tmp) |\r\nP16o(tmp) | P16e(tmp) | P8o(tmp) | P8e(tmp));\r\necc_buf[1] = ~(P1024o(tmp) | P1024e(tmp) | P512o(tmp) | P512e(tmp) |\r\nP256o(tmp) | P256e(tmp) | P128o(tmp) | P128e(tmp));\r\necc_buf[2] = ~(P4o(tmp) | P4e(tmp) | P2o(tmp) | P2e(tmp) | P1o(tmp) |\r\nP1e(tmp) | P2048o(tmp) | P2048e(tmp));\r\n}\r\nstatic int omap_compare_ecc(u8 *ecc_data1,\r\nu8 *ecc_data2,\r\nu8 *page_data)\r\n{\r\nuint i;\r\nu8 tmp0_bit[8], tmp1_bit[8], tmp2_bit[8];\r\nu8 comp0_bit[8], comp1_bit[8], comp2_bit[8];\r\nu8 ecc_bit[24];\r\nu8 ecc_sum = 0;\r\nu8 find_bit = 0;\r\nuint find_byte = 0;\r\nint isEccFF;\r\nisEccFF = ((*(u32 *)ecc_data1 & 0xFFFFFF) == 0xFFFFFF);\r\ngen_true_ecc(ecc_data1);\r\ngen_true_ecc(ecc_data2);\r\nfor (i = 0; i <= 2; i++) {\r\n*(ecc_data1 + i) = ~(*(ecc_data1 + i));\r\n*(ecc_data2 + i) = ~(*(ecc_data2 + i));\r\n}\r\nfor (i = 0; i < 8; i++) {\r\ntmp0_bit[i] = *ecc_data1 % 2;\r\n*ecc_data1 = *ecc_data1 / 2;\r\n}\r\nfor (i = 0; i < 8; i++) {\r\ntmp1_bit[i] = *(ecc_data1 + 1) % 2;\r\n*(ecc_data1 + 1) = *(ecc_data1 + 1) / 2;\r\n}\r\nfor (i = 0; i < 8; i++) {\r\ntmp2_bit[i] = *(ecc_data1 + 2) % 2;\r\n*(ecc_data1 + 2) = *(ecc_data1 + 2) / 2;\r\n}\r\nfor (i = 0; i < 8; i++) {\r\ncomp0_bit[i] = *ecc_data2 % 2;\r\n*ecc_data2 = *ecc_data2 / 2;\r\n}\r\nfor (i = 0; i < 8; i++) {\r\ncomp1_bit[i] = *(ecc_data2 + 1) % 2;\r\n*(ecc_data2 + 1) = *(ecc_data2 + 1) / 2;\r\n}\r\nfor (i = 0; i < 8; i++) {\r\ncomp2_bit[i] = *(ecc_data2 + 2) % 2;\r\n*(ecc_data2 + 2) = *(ecc_data2 + 2) / 2;\r\n}\r\nfor (i = 0; i < 6; i++)\r\necc_bit[i] = tmp2_bit[i + 2] ^ comp2_bit[i + 2];\r\nfor (i = 0; i < 8; i++)\r\necc_bit[i + 6] = tmp0_bit[i] ^ comp0_bit[i];\r\nfor (i = 0; i < 8; i++)\r\necc_bit[i + 14] = tmp1_bit[i] ^ comp1_bit[i];\r\necc_bit[22] = tmp2_bit[0] ^ comp2_bit[0];\r\necc_bit[23] = tmp2_bit[1] ^ comp2_bit[1];\r\nfor (i = 0; i < 24; i++)\r\necc_sum += ecc_bit[i];\r\nswitch (ecc_sum) {\r\ncase 0:\r\nreturn 0;\r\ncase 1:\r\npr_debug("ECC UNCORRECTED_ERROR 1\n");\r\nreturn -1;\r\ncase 11:\r\npr_debug("ECC UNCORRECTED_ERROR B\n");\r\nreturn -1;\r\ncase 12:\r\nfind_byte = (ecc_bit[23] << 8) +\r\n(ecc_bit[21] << 7) +\r\n(ecc_bit[19] << 6) +\r\n(ecc_bit[17] << 5) +\r\n(ecc_bit[15] << 4) +\r\n(ecc_bit[13] << 3) +\r\n(ecc_bit[11] << 2) +\r\n(ecc_bit[9] << 1) +\r\necc_bit[7];\r\nfind_bit = (ecc_bit[5] << 2) + (ecc_bit[3] << 1) + ecc_bit[1];\r\npr_debug("Correcting single bit ECC error at offset: "\r\n"%d, bit: %d\n", find_byte, find_bit);\r\npage_data[find_byte] ^= (1 << find_bit);\r\nreturn 1;\r\ndefault:\r\nif (isEccFF) {\r\nif (ecc_data2[0] == 0 &&\r\necc_data2[1] == 0 &&\r\necc_data2[2] == 0)\r\nreturn 0;\r\n}\r\npr_debug("UNCORRECTED_ERROR default\n");\r\nreturn -1;\r\n}\r\n}\r\nstatic int omap_correct_data(struct mtd_info *mtd, u_char *dat,\r\nu_char *read_ecc, u_char *calc_ecc)\r\n{\r\nstruct omap_nand_info *info = container_of(mtd, struct omap_nand_info,\r\nmtd);\r\nint blockCnt = 0, i = 0, ret = 0;\r\nint stat = 0;\r\nif ((info->nand.ecc.mode == NAND_ECC_HW) &&\r\n(info->nand.ecc.size == 2048))\r\nblockCnt = 4;\r\nelse\r\nblockCnt = 1;\r\nfor (i = 0; i < blockCnt; i++) {\r\nif (memcmp(read_ecc, calc_ecc, 3) != 0) {\r\nret = omap_compare_ecc(read_ecc, calc_ecc, dat);\r\nif (ret < 0)\r\nreturn ret;\r\nstat += ret;\r\n}\r\nread_ecc += 3;\r\ncalc_ecc += 3;\r\ndat += 512;\r\n}\r\nreturn stat;\r\n}\r\nstatic int omap_calculate_ecc(struct mtd_info *mtd, const u_char *dat,\r\nu_char *ecc_code)\r\n{\r\nstruct omap_nand_info *info = container_of(mtd, struct omap_nand_info,\r\nmtd);\r\nu32 val;\r\nval = readl(info->reg.gpmc_ecc_config);\r\nif (((val >> ECC_CONFIG_CS_SHIFT) & CS_MASK) != info->gpmc_cs)\r\nreturn -EINVAL;\r\nval = readl(info->reg.gpmc_ecc1_result);\r\n*ecc_code++ = val;\r\n*ecc_code++ = val >> 16;\r\n*ecc_code++ = ((val >> 8) & 0x0f) | ((val >> 20) & 0xf0);\r\nreturn 0;\r\n}\r\nstatic void omap_enable_hwecc(struct mtd_info *mtd, int mode)\r\n{\r\nstruct omap_nand_info *info = container_of(mtd, struct omap_nand_info,\r\nmtd);\r\nstruct nand_chip *chip = mtd->priv;\r\nunsigned int dev_width = (chip->options & NAND_BUSWIDTH_16) ? 1 : 0;\r\nu32 val;\r\nval = ECCCLEAR | ECC1;\r\nwritel(val, info->reg.gpmc_ecc_control);\r\nval = ((((info->nand.ecc.size >> 1) - 1) << ECCSIZE1_SHIFT) |\r\nECC1RESULTSIZE);\r\nwritel(val, info->reg.gpmc_ecc_size_config);\r\nswitch (mode) {\r\ncase NAND_ECC_READ:\r\ncase NAND_ECC_WRITE:\r\nwritel(ECCCLEAR | ECC1, info->reg.gpmc_ecc_control);\r\nbreak;\r\ncase NAND_ECC_READSYN:\r\nwritel(ECCCLEAR, info->reg.gpmc_ecc_control);\r\nbreak;\r\ndefault:\r\ndev_info(&info->pdev->dev,\r\n"error: unrecognized Mode[%d]!\n", mode);\r\nbreak;\r\n}\r\nval = (dev_width << 7) | (info->gpmc_cs << 1) | (0x1);\r\nwritel(val, info->reg.gpmc_ecc_config);\r\n}\r\nstatic int omap_wait(struct mtd_info *mtd, struct nand_chip *chip)\r\n{\r\nstruct nand_chip *this = mtd->priv;\r\nstruct omap_nand_info *info = container_of(mtd, struct omap_nand_info,\r\nmtd);\r\nunsigned long timeo = jiffies;\r\nint status, state = this->state;\r\nif (state == FL_ERASING)\r\ntimeo += msecs_to_jiffies(400);\r\nelse\r\ntimeo += msecs_to_jiffies(20);\r\nwriteb(NAND_CMD_STATUS & 0xFF, info->reg.gpmc_nand_command);\r\nwhile (time_before(jiffies, timeo)) {\r\nstatus = readb(info->reg.gpmc_nand_data);\r\nif (status & NAND_STATUS_READY)\r\nbreak;\r\ncond_resched();\r\n}\r\nstatus = readb(info->reg.gpmc_nand_data);\r\nreturn status;\r\n}\r\nstatic int omap_dev_ready(struct mtd_info *mtd)\r\n{\r\nunsigned int val = 0;\r\nstruct omap_nand_info *info = container_of(mtd, struct omap_nand_info,\r\nmtd);\r\nval = readl(info->reg.gpmc_status);\r\nif ((val & 0x100) == 0x100) {\r\nreturn 1;\r\n} else {\r\nreturn 0;\r\n}\r\n}\r\nstatic void __maybe_unused omap_enable_hwecc_bch(struct mtd_info *mtd, int mode)\r\n{\r\nunsigned int bch_type;\r\nunsigned int dev_width, nsectors;\r\nstruct omap_nand_info *info = container_of(mtd, struct omap_nand_info,\r\nmtd);\r\nenum omap_ecc ecc_opt = info->ecc_opt;\r\nstruct nand_chip *chip = mtd->priv;\r\nu32 val, wr_mode;\r\nunsigned int ecc_size1, ecc_size0;\r\nswitch (ecc_opt) {\r\ncase OMAP_ECC_BCH4_CODE_HW_DETECTION_SW:\r\nbch_type = 0;\r\nnsectors = 1;\r\nwr_mode = BCH_WRAPMODE_6;\r\necc_size0 = BCH_ECC_SIZE0;\r\necc_size1 = BCH_ECC_SIZE1;\r\nbreak;\r\ncase OMAP_ECC_BCH4_CODE_HW:\r\nbch_type = 0;\r\nnsectors = chip->ecc.steps;\r\nif (mode == NAND_ECC_READ) {\r\nwr_mode = BCH_WRAPMODE_1;\r\necc_size0 = BCH4R_ECC_SIZE0;\r\necc_size1 = BCH4R_ECC_SIZE1;\r\n} else {\r\nwr_mode = BCH_WRAPMODE_6;\r\necc_size0 = BCH_ECC_SIZE0;\r\necc_size1 = BCH_ECC_SIZE1;\r\n}\r\nbreak;\r\ncase OMAP_ECC_BCH8_CODE_HW_DETECTION_SW:\r\nbch_type = 1;\r\nnsectors = 1;\r\nwr_mode = BCH_WRAPMODE_6;\r\necc_size0 = BCH_ECC_SIZE0;\r\necc_size1 = BCH_ECC_SIZE1;\r\nbreak;\r\ncase OMAP_ECC_BCH8_CODE_HW:\r\nbch_type = 1;\r\nnsectors = chip->ecc.steps;\r\nif (mode == NAND_ECC_READ) {\r\nwr_mode = BCH_WRAPMODE_1;\r\necc_size0 = BCH8R_ECC_SIZE0;\r\necc_size1 = BCH8R_ECC_SIZE1;\r\n} else {\r\nwr_mode = BCH_WRAPMODE_6;\r\necc_size0 = BCH_ECC_SIZE0;\r\necc_size1 = BCH_ECC_SIZE1;\r\n}\r\nbreak;\r\ncase OMAP_ECC_BCH16_CODE_HW:\r\nbch_type = 0x2;\r\nnsectors = chip->ecc.steps;\r\nif (mode == NAND_ECC_READ) {\r\nwr_mode = 0x01;\r\necc_size0 = 52;\r\necc_size1 = 0;\r\n} else {\r\nwr_mode = 0x01;\r\necc_size0 = 0;\r\necc_size1 = 52;\r\n}\r\nbreak;\r\ndefault:\r\nreturn;\r\n}\r\nwritel(ECC1, info->reg.gpmc_ecc_control);\r\nval = (ecc_size1 << ECCSIZE1_SHIFT) | (ecc_size0 << ECCSIZE0_SHIFT);\r\nwritel(val, info->reg.gpmc_ecc_size_config);\r\ndev_width = (chip->options & NAND_BUSWIDTH_16) ? 1 : 0;\r\nval = ((1 << 16) |\r\n(bch_type << 12) |\r\n(wr_mode << 8) |\r\n(dev_width << 7) |\r\n(((nsectors-1) & 0x7) << 4) |\r\n(info->gpmc_cs << 1) |\r\n(0x1));\r\nwritel(val, info->reg.gpmc_ecc_config);\r\nwritel(ECCCLEAR | ECC1, info->reg.gpmc_ecc_control);\r\n}\r\nstatic int __maybe_unused omap_calculate_ecc_bch(struct mtd_info *mtd,\r\nconst u_char *dat, u_char *ecc_calc)\r\n{\r\nstruct omap_nand_info *info = container_of(mtd, struct omap_nand_info,\r\nmtd);\r\nint eccbytes = info->nand.ecc.bytes;\r\nstruct gpmc_nand_regs *gpmc_regs = &info->reg;\r\nu8 *ecc_code;\r\nunsigned long nsectors, bch_val1, bch_val2, bch_val3, bch_val4;\r\nu32 val;\r\nint i, j;\r\nnsectors = ((readl(info->reg.gpmc_ecc_config) >> 4) & 0x7) + 1;\r\nfor (i = 0; i < nsectors; i++) {\r\necc_code = ecc_calc;\r\nswitch (info->ecc_opt) {\r\ncase OMAP_ECC_BCH8_CODE_HW_DETECTION_SW:\r\ncase OMAP_ECC_BCH8_CODE_HW:\r\nbch_val1 = readl(gpmc_regs->gpmc_bch_result0[i]);\r\nbch_val2 = readl(gpmc_regs->gpmc_bch_result1[i]);\r\nbch_val3 = readl(gpmc_regs->gpmc_bch_result2[i]);\r\nbch_val4 = readl(gpmc_regs->gpmc_bch_result3[i]);\r\n*ecc_code++ = (bch_val4 & 0xFF);\r\n*ecc_code++ = ((bch_val3 >> 24) & 0xFF);\r\n*ecc_code++ = ((bch_val3 >> 16) & 0xFF);\r\n*ecc_code++ = ((bch_val3 >> 8) & 0xFF);\r\n*ecc_code++ = (bch_val3 & 0xFF);\r\n*ecc_code++ = ((bch_val2 >> 24) & 0xFF);\r\n*ecc_code++ = ((bch_val2 >> 16) & 0xFF);\r\n*ecc_code++ = ((bch_val2 >> 8) & 0xFF);\r\n*ecc_code++ = (bch_val2 & 0xFF);\r\n*ecc_code++ = ((bch_val1 >> 24) & 0xFF);\r\n*ecc_code++ = ((bch_val1 >> 16) & 0xFF);\r\n*ecc_code++ = ((bch_val1 >> 8) & 0xFF);\r\n*ecc_code++ = (bch_val1 & 0xFF);\r\nbreak;\r\ncase OMAP_ECC_BCH4_CODE_HW_DETECTION_SW:\r\ncase OMAP_ECC_BCH4_CODE_HW:\r\nbch_val1 = readl(gpmc_regs->gpmc_bch_result0[i]);\r\nbch_val2 = readl(gpmc_regs->gpmc_bch_result1[i]);\r\n*ecc_code++ = ((bch_val2 >> 12) & 0xFF);\r\n*ecc_code++ = ((bch_val2 >> 4) & 0xFF);\r\n*ecc_code++ = ((bch_val2 & 0xF) << 4) |\r\n((bch_val1 >> 28) & 0xF);\r\n*ecc_code++ = ((bch_val1 >> 20) & 0xFF);\r\n*ecc_code++ = ((bch_val1 >> 12) & 0xFF);\r\n*ecc_code++ = ((bch_val1 >> 4) & 0xFF);\r\n*ecc_code++ = ((bch_val1 & 0xF) << 4);\r\nbreak;\r\ncase OMAP_ECC_BCH16_CODE_HW:\r\nval = readl(gpmc_regs->gpmc_bch_result6[i]);\r\necc_code[0] = ((val >> 8) & 0xFF);\r\necc_code[1] = ((val >> 0) & 0xFF);\r\nval = readl(gpmc_regs->gpmc_bch_result5[i]);\r\necc_code[2] = ((val >> 24) & 0xFF);\r\necc_code[3] = ((val >> 16) & 0xFF);\r\necc_code[4] = ((val >> 8) & 0xFF);\r\necc_code[5] = ((val >> 0) & 0xFF);\r\nval = readl(gpmc_regs->gpmc_bch_result4[i]);\r\necc_code[6] = ((val >> 24) & 0xFF);\r\necc_code[7] = ((val >> 16) & 0xFF);\r\necc_code[8] = ((val >> 8) & 0xFF);\r\necc_code[9] = ((val >> 0) & 0xFF);\r\nval = readl(gpmc_regs->gpmc_bch_result3[i]);\r\necc_code[10] = ((val >> 24) & 0xFF);\r\necc_code[11] = ((val >> 16) & 0xFF);\r\necc_code[12] = ((val >> 8) & 0xFF);\r\necc_code[13] = ((val >> 0) & 0xFF);\r\nval = readl(gpmc_regs->gpmc_bch_result2[i]);\r\necc_code[14] = ((val >> 24) & 0xFF);\r\necc_code[15] = ((val >> 16) & 0xFF);\r\necc_code[16] = ((val >> 8) & 0xFF);\r\necc_code[17] = ((val >> 0) & 0xFF);\r\nval = readl(gpmc_regs->gpmc_bch_result1[i]);\r\necc_code[18] = ((val >> 24) & 0xFF);\r\necc_code[19] = ((val >> 16) & 0xFF);\r\necc_code[20] = ((val >> 8) & 0xFF);\r\necc_code[21] = ((val >> 0) & 0xFF);\r\nval = readl(gpmc_regs->gpmc_bch_result0[i]);\r\necc_code[22] = ((val >> 24) & 0xFF);\r\necc_code[23] = ((val >> 16) & 0xFF);\r\necc_code[24] = ((val >> 8) & 0xFF);\r\necc_code[25] = ((val >> 0) & 0xFF);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (info->ecc_opt) {\r\ncase OMAP_ECC_BCH4_CODE_HW_DETECTION_SW:\r\nfor (j = 0; j < eccbytes; j++)\r\necc_calc[j] ^= bch4_polynomial[j];\r\nbreak;\r\ncase OMAP_ECC_BCH4_CODE_HW:\r\necc_calc[eccbytes - 1] = 0x0;\r\nbreak;\r\ncase OMAP_ECC_BCH8_CODE_HW_DETECTION_SW:\r\nfor (j = 0; j < eccbytes; j++)\r\necc_calc[j] ^= bch8_polynomial[j];\r\nbreak;\r\ncase OMAP_ECC_BCH8_CODE_HW:\r\necc_calc[eccbytes - 1] = 0x0;\r\nbreak;\r\ncase OMAP_ECC_BCH16_CODE_HW:\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\necc_calc += eccbytes;\r\n}\r\nreturn 0;\r\n}\r\nstatic int erased_sector_bitflips(u_char *data, u_char *oob,\r\nstruct omap_nand_info *info)\r\n{\r\nint flip_bits = 0, i;\r\nfor (i = 0; i < info->nand.ecc.size; i++) {\r\nflip_bits += hweight8(~data[i]);\r\nif (flip_bits > info->nand.ecc.strength)\r\nreturn 0;\r\n}\r\nfor (i = 0; i < info->nand.ecc.bytes - 1; i++) {\r\nflip_bits += hweight8(~oob[i]);\r\nif (flip_bits > info->nand.ecc.strength)\r\nreturn 0;\r\n}\r\nif (flip_bits) {\r\nmemset(data, 0xFF, info->nand.ecc.size);\r\nmemset(oob, 0xFF, info->nand.ecc.bytes);\r\n}\r\nreturn flip_bits;\r\n}\r\nstatic int omap_elm_correct_data(struct mtd_info *mtd, u_char *data,\r\nu_char *read_ecc, u_char *calc_ecc)\r\n{\r\nstruct omap_nand_info *info = container_of(mtd, struct omap_nand_info,\r\nmtd);\r\nstruct nand_ecc_ctrl *ecc = &info->nand.ecc;\r\nint eccsteps = info->nand.ecc.steps;\r\nint i , j, stat = 0;\r\nint eccflag, actual_eccbytes;\r\nstruct elm_errorvec err_vec[ERROR_VECTOR_MAX];\r\nu_char *ecc_vec = calc_ecc;\r\nu_char *spare_ecc = read_ecc;\r\nu_char *erased_ecc_vec;\r\nu_char *buf;\r\nint bitflip_count;\r\nbool is_error_reported = false;\r\nu32 bit_pos, byte_pos, error_max, pos;\r\nint err;\r\nswitch (info->ecc_opt) {\r\ncase OMAP_ECC_BCH4_CODE_HW:\r\nactual_eccbytes = ecc->bytes - 1;\r\nerased_ecc_vec = bch4_vector;\r\nbreak;\r\ncase OMAP_ECC_BCH8_CODE_HW:\r\nactual_eccbytes = ecc->bytes - 1;\r\nerased_ecc_vec = bch8_vector;\r\nbreak;\r\ncase OMAP_ECC_BCH16_CODE_HW:\r\nactual_eccbytes = ecc->bytes;\r\nerased_ecc_vec = bch16_vector;\r\nbreak;\r\ndefault:\r\ndev_err(&info->pdev->dev, "invalid driver configuration\n");\r\nreturn -EINVAL;\r\n}\r\nmemset(err_vec, 0, sizeof(err_vec));\r\nfor (i = 0; i < eccsteps ; i++) {\r\neccflag = 0;\r\nfor (j = 0; j < actual_eccbytes; j++) {\r\nif (calc_ecc[j] != 0) {\r\neccflag = 1;\r\nbreak;\r\n}\r\n}\r\nif (eccflag == 1) {\r\nif (memcmp(calc_ecc, erased_ecc_vec,\r\nactual_eccbytes) == 0) {\r\n} else {\r\nbuf = &data[info->nand.ecc.size * i];\r\nbitflip_count = erased_sector_bitflips(\r\nbuf, read_ecc, info);\r\nif (bitflip_count) {\r\nstat += bitflip_count;\r\n} else {\r\nerr_vec[i].error_reported = true;\r\nis_error_reported = true;\r\n}\r\n}\r\n}\r\ncalc_ecc += ecc->bytes;\r\nread_ecc += ecc->bytes;\r\n}\r\nif (!is_error_reported)\r\nreturn stat;\r\nelm_decode_bch_error_page(info->elm_dev, ecc_vec, err_vec);\r\nerr = 0;\r\nfor (i = 0; i < eccsteps; i++) {\r\nif (err_vec[i].error_uncorrectable) {\r\ndev_err(&info->pdev->dev,\r\n"uncorrectable bit-flips found\n");\r\nerr = -EBADMSG;\r\n} else if (err_vec[i].error_reported) {\r\nfor (j = 0; j < err_vec[i].error_count; j++) {\r\nswitch (info->ecc_opt) {\r\ncase OMAP_ECC_BCH4_CODE_HW:\r\npos = err_vec[i].error_loc[j] +\r\nBCH4_BIT_PAD;\r\nbreak;\r\ncase OMAP_ECC_BCH8_CODE_HW:\r\ncase OMAP_ECC_BCH16_CODE_HW:\r\npos = err_vec[i].error_loc[j];\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nerror_max = (ecc->size + actual_eccbytes) * 8;\r\nbit_pos = pos % 8;\r\nbyte_pos = (error_max - pos - 1) / 8;\r\nif (pos < error_max) {\r\nif (byte_pos < 512) {\r\npr_debug("bitflip@dat[%d]=%x\n",\r\nbyte_pos, data[byte_pos]);\r\ndata[byte_pos] ^= 1 << bit_pos;\r\n} else {\r\npr_debug("bitflip@oob[%d]=%x\n",\r\n(byte_pos - 512),\r\nspare_ecc[byte_pos - 512]);\r\nspare_ecc[byte_pos - 512] ^=\r\n1 << bit_pos;\r\n}\r\n} else {\r\ndev_err(&info->pdev->dev,\r\n"invalid bit-flip @ %d:%d\n",\r\nbyte_pos, bit_pos);\r\nerr = -EBADMSG;\r\n}\r\n}\r\n}\r\nstat += err_vec[i].error_count;\r\ndata += ecc->size;\r\nspare_ecc += ecc->bytes;\r\n}\r\nreturn (err) ? err : stat;\r\n}\r\nstatic int omap_write_page_bch(struct mtd_info *mtd, struct nand_chip *chip,\r\nconst uint8_t *buf, int oob_required)\r\n{\r\nint i;\r\nuint8_t *ecc_calc = chip->buffers->ecccalc;\r\nuint32_t *eccpos = chip->ecc.layout->eccpos;\r\nchip->ecc.hwctl(mtd, NAND_ECC_WRITE);\r\nchip->write_buf(mtd, buf, mtd->writesize);\r\nchip->ecc.calculate(mtd, buf, &ecc_calc[0]);\r\nfor (i = 0; i < chip->ecc.total; i++)\r\nchip->oob_poi[eccpos[i]] = ecc_calc[i];\r\nchip->write_buf(mtd, chip->oob_poi, mtd->oobsize);\r\nreturn 0;\r\n}\r\nstatic int omap_read_page_bch(struct mtd_info *mtd, struct nand_chip *chip,\r\nuint8_t *buf, int oob_required, int page)\r\n{\r\nuint8_t *ecc_calc = chip->buffers->ecccalc;\r\nuint8_t *ecc_code = chip->buffers->ecccode;\r\nuint32_t *eccpos = chip->ecc.layout->eccpos;\r\nuint8_t *oob = &chip->oob_poi[eccpos[0]];\r\nuint32_t oob_pos = mtd->writesize + chip->ecc.layout->eccpos[0];\r\nint stat;\r\nunsigned int max_bitflips = 0;\r\nchip->ecc.hwctl(mtd, NAND_ECC_READ);\r\nchip->read_buf(mtd, buf, mtd->writesize);\r\nchip->cmdfunc(mtd, NAND_CMD_RNDOUT, oob_pos, -1);\r\nchip->read_buf(mtd, oob, chip->ecc.total);\r\nchip->ecc.calculate(mtd, buf, ecc_calc);\r\nmemcpy(ecc_code, &chip->oob_poi[eccpos[0]], chip->ecc.total);\r\nstat = chip->ecc.correct(mtd, buf, ecc_code, ecc_calc);\r\nif (stat < 0) {\r\nmtd->ecc_stats.failed++;\r\n} else {\r\nmtd->ecc_stats.corrected += stat;\r\nmax_bitflips = max_t(unsigned int, max_bitflips, stat);\r\n}\r\nreturn max_bitflips;\r\n}\r\nstatic bool is_elm_present(struct omap_nand_info *info,\r\nstruct device_node *elm_node)\r\n{\r\nstruct platform_device *pdev;\r\nif (!elm_node) {\r\ndev_err(&info->pdev->dev, "ELM devicetree node not found\n");\r\nreturn false;\r\n}\r\npdev = of_find_device_by_node(elm_node);\r\nif (!pdev) {\r\ndev_err(&info->pdev->dev, "ELM device not found\n");\r\nreturn false;\r\n}\r\ninfo->elm_dev = &pdev->dev;\r\nreturn true;\r\n}\r\nstatic bool omap2_nand_ecc_check(struct omap_nand_info *info,\r\nstruct omap_nand_platform_data *pdata)\r\n{\r\nbool ecc_needs_bch, ecc_needs_omap_bch, ecc_needs_elm;\r\nswitch (info->ecc_opt) {\r\ncase OMAP_ECC_BCH4_CODE_HW_DETECTION_SW:\r\ncase OMAP_ECC_BCH8_CODE_HW_DETECTION_SW:\r\necc_needs_omap_bch = false;\r\necc_needs_bch = true;\r\necc_needs_elm = false;\r\nbreak;\r\ncase OMAP_ECC_BCH4_CODE_HW:\r\ncase OMAP_ECC_BCH8_CODE_HW:\r\ncase OMAP_ECC_BCH16_CODE_HW:\r\necc_needs_omap_bch = true;\r\necc_needs_bch = false;\r\necc_needs_elm = true;\r\nbreak;\r\ndefault:\r\necc_needs_omap_bch = false;\r\necc_needs_bch = false;\r\necc_needs_elm = false;\r\nbreak;\r\n}\r\nif (ecc_needs_bch && !IS_ENABLED(CONFIG_MTD_NAND_ECC_BCH)) {\r\ndev_err(&info->pdev->dev,\r\n"CONFIG_MTD_NAND_ECC_BCH not enabled\n");\r\nreturn false;\r\n}\r\nif (ecc_needs_omap_bch && !IS_ENABLED(CONFIG_MTD_NAND_OMAP_BCH)) {\r\ndev_err(&info->pdev->dev,\r\n"CONFIG_MTD_NAND_OMAP_BCH not enabled\n");\r\nreturn false;\r\n}\r\nif (ecc_needs_elm && !is_elm_present(info, pdata->elm_of_node)) {\r\ndev_err(&info->pdev->dev, "ELM not available\n");\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\nstatic int omap_nand_probe(struct platform_device *pdev)\r\n{\r\nstruct omap_nand_info *info;\r\nstruct omap_nand_platform_data *pdata;\r\nstruct mtd_info *mtd;\r\nstruct nand_chip *nand_chip;\r\nstruct nand_ecclayout *ecclayout;\r\nint err;\r\nint i;\r\ndma_cap_mask_t mask;\r\nunsigned sig;\r\nunsigned oob_index;\r\nstruct resource *res;\r\nstruct mtd_part_parser_data ppdata = {};\r\npdata = dev_get_platdata(&pdev->dev);\r\nif (pdata == NULL) {\r\ndev_err(&pdev->dev, "platform data missing\n");\r\nreturn -ENODEV;\r\n}\r\ninfo = devm_kzalloc(&pdev->dev, sizeof(struct omap_nand_info),\r\nGFP_KERNEL);\r\nif (!info)\r\nreturn -ENOMEM;\r\nplatform_set_drvdata(pdev, info);\r\ninfo->pdev = pdev;\r\ninfo->gpmc_cs = pdata->cs;\r\ninfo->reg = pdata->reg;\r\ninfo->of_node = pdata->of_node;\r\ninfo->ecc_opt = pdata->ecc_opt;\r\nmtd = &info->mtd;\r\nmtd->priv = &info->nand;\r\nmtd->name = dev_name(&pdev->dev);\r\nmtd->owner = THIS_MODULE;\r\nnand_chip = &info->nand;\r\nnand_chip->ecc.priv = NULL;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nnand_chip->IO_ADDR_R = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(nand_chip->IO_ADDR_R))\r\nreturn PTR_ERR(nand_chip->IO_ADDR_R);\r\ninfo->phys_base = res->start;\r\nnand_chip->controller = &omap_gpmc_controller;\r\nnand_chip->IO_ADDR_W = nand_chip->IO_ADDR_R;\r\nnand_chip->cmd_ctrl = omap_hwcontrol;\r\nif (pdata->dev_ready) {\r\nnand_chip->dev_ready = omap_dev_ready;\r\nnand_chip->chip_delay = 0;\r\n} else {\r\nnand_chip->waitfunc = omap_wait;\r\nnand_chip->chip_delay = 50;\r\n}\r\nif (pdata->flash_bbt)\r\nnand_chip->bbt_options |= NAND_BBT_USE_FLASH | NAND_BBT_NO_OOB;\r\nelse\r\nnand_chip->options |= NAND_SKIP_BBTSCAN;\r\nnand_chip->options |= pdata->devsize & NAND_BUSWIDTH_16;\r\nif (nand_scan_ident(mtd, 1, NULL)) {\r\ndev_err(&info->pdev->dev, "scan failed, may be bus-width mismatch\n");\r\nerr = -ENXIO;\r\ngoto return_error;\r\n}\r\nswitch (pdata->xfer_type) {\r\ncase NAND_OMAP_PREFETCH_POLLED:\r\nnand_chip->read_buf = omap_read_buf_pref;\r\nnand_chip->write_buf = omap_write_buf_pref;\r\nbreak;\r\ncase NAND_OMAP_POLLED:\r\nbreak;\r\ncase NAND_OMAP_PREFETCH_DMA:\r\ndma_cap_zero(mask);\r\ndma_cap_set(DMA_SLAVE, mask);\r\nsig = OMAP24XX_DMA_GPMC;\r\ninfo->dma = dma_request_channel(mask, omap_dma_filter_fn, &sig);\r\nif (!info->dma) {\r\ndev_err(&pdev->dev, "DMA engine request failed\n");\r\nerr = -ENXIO;\r\ngoto return_error;\r\n} else {\r\nstruct dma_slave_config cfg;\r\nmemset(&cfg, 0, sizeof(cfg));\r\ncfg.src_addr = info->phys_base;\r\ncfg.dst_addr = info->phys_base;\r\ncfg.src_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;\r\ncfg.dst_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;\r\ncfg.src_maxburst = 16;\r\ncfg.dst_maxburst = 16;\r\nerr = dmaengine_slave_config(info->dma, &cfg);\r\nif (err) {\r\ndev_err(&pdev->dev, "DMA engine slave config failed: %d\n",\r\nerr);\r\ngoto return_error;\r\n}\r\nnand_chip->read_buf = omap_read_buf_dma_pref;\r\nnand_chip->write_buf = omap_write_buf_dma_pref;\r\n}\r\nbreak;\r\ncase NAND_OMAP_PREFETCH_IRQ:\r\ninfo->gpmc_irq_fifo = platform_get_irq(pdev, 0);\r\nif (info->gpmc_irq_fifo <= 0) {\r\ndev_err(&pdev->dev, "error getting fifo irq\n");\r\nerr = -ENODEV;\r\ngoto return_error;\r\n}\r\nerr = devm_request_irq(&pdev->dev, info->gpmc_irq_fifo,\r\nomap_nand_irq, IRQF_SHARED,\r\n"gpmc-nand-fifo", info);\r\nif (err) {\r\ndev_err(&pdev->dev, "requesting irq(%d) error:%d",\r\ninfo->gpmc_irq_fifo, err);\r\ninfo->gpmc_irq_fifo = 0;\r\ngoto return_error;\r\n}\r\ninfo->gpmc_irq_count = platform_get_irq(pdev, 1);\r\nif (info->gpmc_irq_count <= 0) {\r\ndev_err(&pdev->dev, "error getting count irq\n");\r\nerr = -ENODEV;\r\ngoto return_error;\r\n}\r\nerr = devm_request_irq(&pdev->dev, info->gpmc_irq_count,\r\nomap_nand_irq, IRQF_SHARED,\r\n"gpmc-nand-count", info);\r\nif (err) {\r\ndev_err(&pdev->dev, "requesting irq(%d) error:%d",\r\ninfo->gpmc_irq_count, err);\r\ninfo->gpmc_irq_count = 0;\r\ngoto return_error;\r\n}\r\nnand_chip->read_buf = omap_read_buf_irq_pref;\r\nnand_chip->write_buf = omap_write_buf_irq_pref;\r\nbreak;\r\ndefault:\r\ndev_err(&pdev->dev,\r\n"xfer_type(%d) not supported!\n", pdata->xfer_type);\r\nerr = -EINVAL;\r\ngoto return_error;\r\n}\r\nif (!omap2_nand_ecc_check(info, pdata)) {\r\nerr = -EINVAL;\r\ngoto return_error;\r\n}\r\necclayout = &info->oobinfo;\r\nswitch (info->ecc_opt) {\r\ncase OMAP_ECC_HAM1_CODE_SW:\r\nnand_chip->ecc.mode = NAND_ECC_SOFT;\r\nbreak;\r\ncase OMAP_ECC_HAM1_CODE_HW:\r\npr_info("nand: using OMAP_ECC_HAM1_CODE_HW\n");\r\nnand_chip->ecc.mode = NAND_ECC_HW;\r\nnand_chip->ecc.bytes = 3;\r\nnand_chip->ecc.size = 512;\r\nnand_chip->ecc.strength = 1;\r\nnand_chip->ecc.calculate = omap_calculate_ecc;\r\nnand_chip->ecc.hwctl = omap_enable_hwecc;\r\nnand_chip->ecc.correct = omap_correct_data;\r\necclayout->eccbytes = nand_chip->ecc.bytes *\r\n(mtd->writesize /\r\nnand_chip->ecc.size);\r\nif (nand_chip->options & NAND_BUSWIDTH_16)\r\noob_index = BADBLOCK_MARKER_LENGTH;\r\nelse\r\noob_index = 1;\r\nfor (i = 0; i < ecclayout->eccbytes; i++, oob_index++)\r\necclayout->eccpos[i] = oob_index;\r\necclayout->oobfree->offset =\r\necclayout->eccpos[ecclayout->eccbytes - 1] + 1;\r\nbreak;\r\ncase OMAP_ECC_BCH4_CODE_HW_DETECTION_SW:\r\npr_info("nand: using OMAP_ECC_BCH4_CODE_HW_DETECTION_SW\n");\r\nnand_chip->ecc.mode = NAND_ECC_HW;\r\nnand_chip->ecc.size = 512;\r\nnand_chip->ecc.bytes = 7;\r\nnand_chip->ecc.strength = 4;\r\nnand_chip->ecc.hwctl = omap_enable_hwecc_bch;\r\nnand_chip->ecc.correct = nand_bch_correct_data;\r\nnand_chip->ecc.calculate = omap_calculate_ecc_bch;\r\necclayout->eccbytes = nand_chip->ecc.bytes *\r\n(mtd->writesize /\r\nnand_chip->ecc.size);\r\noob_index = BADBLOCK_MARKER_LENGTH;\r\nfor (i = 0; i < ecclayout->eccbytes; i++, oob_index++) {\r\necclayout->eccpos[i] = oob_index;\r\nif (((i + 1) % nand_chip->ecc.bytes) == 0)\r\noob_index++;\r\n}\r\necclayout->oobfree->offset = 1 +\r\necclayout->eccpos[ecclayout->eccbytes - 1] + 1;\r\nnand_chip->ecc.priv = nand_bch_init(mtd,\r\nnand_chip->ecc.size,\r\nnand_chip->ecc.bytes,\r\n&ecclayout);\r\nif (!nand_chip->ecc.priv) {\r\ndev_err(&info->pdev->dev, "unable to use BCH library\n");\r\nerr = -EINVAL;\r\ngoto return_error;\r\n}\r\nbreak;\r\ncase OMAP_ECC_BCH4_CODE_HW:\r\npr_info("nand: using OMAP_ECC_BCH4_CODE_HW ECC scheme\n");\r\nnand_chip->ecc.mode = NAND_ECC_HW;\r\nnand_chip->ecc.size = 512;\r\nnand_chip->ecc.bytes = 7 + 1;\r\nnand_chip->ecc.strength = 4;\r\nnand_chip->ecc.hwctl = omap_enable_hwecc_bch;\r\nnand_chip->ecc.correct = omap_elm_correct_data;\r\nnand_chip->ecc.calculate = omap_calculate_ecc_bch;\r\nnand_chip->ecc.read_page = omap_read_page_bch;\r\nnand_chip->ecc.write_page = omap_write_page_bch;\r\necclayout->eccbytes = nand_chip->ecc.bytes *\r\n(mtd->writesize /\r\nnand_chip->ecc.size);\r\noob_index = BADBLOCK_MARKER_LENGTH;\r\nfor (i = 0; i < ecclayout->eccbytes; i++, oob_index++)\r\necclayout->eccpos[i] = oob_index;\r\necclayout->oobfree->offset =\r\necclayout->eccpos[ecclayout->eccbytes - 1] + 1;\r\nerr = elm_config(info->elm_dev, BCH4_ECC,\r\ninfo->mtd.writesize / nand_chip->ecc.size,\r\nnand_chip->ecc.size, nand_chip->ecc.bytes);\r\nif (err < 0)\r\ngoto return_error;\r\nbreak;\r\ncase OMAP_ECC_BCH8_CODE_HW_DETECTION_SW:\r\npr_info("nand: using OMAP_ECC_BCH8_CODE_HW_DETECTION_SW\n");\r\nnand_chip->ecc.mode = NAND_ECC_HW;\r\nnand_chip->ecc.size = 512;\r\nnand_chip->ecc.bytes = 13;\r\nnand_chip->ecc.strength = 8;\r\nnand_chip->ecc.hwctl = omap_enable_hwecc_bch;\r\nnand_chip->ecc.correct = nand_bch_correct_data;\r\nnand_chip->ecc.calculate = omap_calculate_ecc_bch;\r\necclayout->eccbytes = nand_chip->ecc.bytes *\r\n(mtd->writesize /\r\nnand_chip->ecc.size);\r\noob_index = BADBLOCK_MARKER_LENGTH;\r\nfor (i = 0; i < ecclayout->eccbytes; i++, oob_index++) {\r\necclayout->eccpos[i] = oob_index;\r\nif (((i + 1) % nand_chip->ecc.bytes) == 0)\r\noob_index++;\r\n}\r\necclayout->oobfree->offset = 1 +\r\necclayout->eccpos[ecclayout->eccbytes - 1] + 1;\r\nnand_chip->ecc.priv = nand_bch_init(mtd,\r\nnand_chip->ecc.size,\r\nnand_chip->ecc.bytes,\r\n&ecclayout);\r\nif (!nand_chip->ecc.priv) {\r\ndev_err(&info->pdev->dev, "unable to use BCH library\n");\r\nerr = -EINVAL;\r\ngoto return_error;\r\n}\r\nbreak;\r\ncase OMAP_ECC_BCH8_CODE_HW:\r\npr_info("nand: using OMAP_ECC_BCH8_CODE_HW ECC scheme\n");\r\nnand_chip->ecc.mode = NAND_ECC_HW;\r\nnand_chip->ecc.size = 512;\r\nnand_chip->ecc.bytes = 13 + 1;\r\nnand_chip->ecc.strength = 8;\r\nnand_chip->ecc.hwctl = omap_enable_hwecc_bch;\r\nnand_chip->ecc.correct = omap_elm_correct_data;\r\nnand_chip->ecc.calculate = omap_calculate_ecc_bch;\r\nnand_chip->ecc.read_page = omap_read_page_bch;\r\nnand_chip->ecc.write_page = omap_write_page_bch;\r\nerr = elm_config(info->elm_dev, BCH8_ECC,\r\ninfo->mtd.writesize / nand_chip->ecc.size,\r\nnand_chip->ecc.size, nand_chip->ecc.bytes);\r\nif (err < 0)\r\ngoto return_error;\r\necclayout->eccbytes = nand_chip->ecc.bytes *\r\n(mtd->writesize /\r\nnand_chip->ecc.size);\r\noob_index = BADBLOCK_MARKER_LENGTH;\r\nfor (i = 0; i < ecclayout->eccbytes; i++, oob_index++)\r\necclayout->eccpos[i] = oob_index;\r\necclayout->oobfree->offset =\r\necclayout->eccpos[ecclayout->eccbytes - 1] + 1;\r\nbreak;\r\ncase OMAP_ECC_BCH16_CODE_HW:\r\npr_info("using OMAP_ECC_BCH16_CODE_HW ECC scheme\n");\r\nnand_chip->ecc.mode = NAND_ECC_HW;\r\nnand_chip->ecc.size = 512;\r\nnand_chip->ecc.bytes = 26;\r\nnand_chip->ecc.strength = 16;\r\nnand_chip->ecc.hwctl = omap_enable_hwecc_bch;\r\nnand_chip->ecc.correct = omap_elm_correct_data;\r\nnand_chip->ecc.calculate = omap_calculate_ecc_bch;\r\nnand_chip->ecc.read_page = omap_read_page_bch;\r\nnand_chip->ecc.write_page = omap_write_page_bch;\r\nerr = elm_config(info->elm_dev, BCH16_ECC,\r\ninfo->mtd.writesize / nand_chip->ecc.size,\r\nnand_chip->ecc.size, nand_chip->ecc.bytes);\r\nif (err < 0)\r\ngoto return_error;\r\necclayout->eccbytes = nand_chip->ecc.bytes *\r\n(mtd->writesize /\r\nnand_chip->ecc.size);\r\noob_index = BADBLOCK_MARKER_LENGTH;\r\nfor (i = 0; i < ecclayout->eccbytes; i++, oob_index++)\r\necclayout->eccpos[i] = oob_index;\r\necclayout->oobfree->offset =\r\necclayout->eccpos[ecclayout->eccbytes - 1] + 1;\r\nbreak;\r\ndefault:\r\ndev_err(&info->pdev->dev, "invalid or unsupported ECC scheme\n");\r\nerr = -EINVAL;\r\ngoto return_error;\r\n}\r\nif (info->ecc_opt == OMAP_ECC_HAM1_CODE_SW)\r\ngoto scan_tail;\r\necclayout->oobfree->length = mtd->oobsize - ecclayout->oobfree->offset;\r\nif (mtd->oobsize < (ecclayout->eccbytes + BADBLOCK_MARKER_LENGTH)) {\r\ndev_err(&info->pdev->dev,\r\n"not enough OOB bytes required = %d, available=%d\n",\r\necclayout->eccbytes, mtd->oobsize);\r\nerr = -EINVAL;\r\ngoto return_error;\r\n}\r\nnand_chip->ecc.layout = ecclayout;\r\nscan_tail:\r\nif (nand_scan_tail(mtd)) {\r\nerr = -ENXIO;\r\ngoto return_error;\r\n}\r\nppdata.of_node = pdata->of_node;\r\nmtd_device_parse_register(mtd, NULL, &ppdata, pdata->parts,\r\npdata->nr_parts);\r\nplatform_set_drvdata(pdev, mtd);\r\nreturn 0;\r\nreturn_error:\r\nif (info->dma)\r\ndma_release_channel(info->dma);\r\nif (nand_chip->ecc.priv) {\r\nnand_bch_free(nand_chip->ecc.priv);\r\nnand_chip->ecc.priv = NULL;\r\n}\r\nreturn err;\r\n}\r\nstatic int omap_nand_remove(struct platform_device *pdev)\r\n{\r\nstruct mtd_info *mtd = platform_get_drvdata(pdev);\r\nstruct nand_chip *nand_chip = mtd->priv;\r\nstruct omap_nand_info *info = container_of(mtd, struct omap_nand_info,\r\nmtd);\r\nif (nand_chip->ecc.priv) {\r\nnand_bch_free(nand_chip->ecc.priv);\r\nnand_chip->ecc.priv = NULL;\r\n}\r\nif (info->dma)\r\ndma_release_channel(info->dma);\r\nnand_release(mtd);\r\nreturn 0;\r\n}
