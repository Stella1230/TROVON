const char *acpi_power_state_string(int state)\r\n{\r\nswitch (state) {\r\ncase ACPI_STATE_D0:\r\nreturn "D0";\r\ncase ACPI_STATE_D1:\r\nreturn "D1";\r\ncase ACPI_STATE_D2:\r\nreturn "D2";\r\ncase ACPI_STATE_D3_HOT:\r\nreturn "D3hot";\r\ncase ACPI_STATE_D3_COLD:\r\nreturn "D3cold";\r\ndefault:\r\nreturn "(unknown)";\r\n}\r\n}\r\nint acpi_device_get_power(struct acpi_device *device, int *state)\r\n{\r\nint result = ACPI_STATE_UNKNOWN;\r\nif (!device || !state)\r\nreturn -EINVAL;\r\nif (!device->flags.power_manageable) {\r\n*state = device->parent ?\r\ndevice->parent->power.state : ACPI_STATE_D0;\r\ngoto out;\r\n}\r\nif (device->power.flags.power_resources) {\r\nint error = acpi_power_get_inferred_state(device, &result);\r\nif (error)\r\nreturn error;\r\n}\r\nif (device->power.flags.explicit_get) {\r\nacpi_handle handle = device->handle;\r\nunsigned long long psc;\r\nacpi_status status;\r\nstatus = acpi_evaluate_integer(handle, "_PSC", NULL, &psc);\r\nif (ACPI_FAILURE(status))\r\nreturn -ENODEV;\r\nif (psc > result && psc < ACPI_STATE_D3_COLD)\r\nresult = psc;\r\nelse if (result == ACPI_STATE_UNKNOWN)\r\nresult = psc > ACPI_STATE_D2 ? ACPI_STATE_D3_COLD : psc;\r\n}\r\nif (!device->power.flags.ignore_parent && device->parent\r\n&& device->parent->power.state == ACPI_STATE_UNKNOWN\r\n&& result == ACPI_STATE_D0)\r\ndevice->parent->power.state = ACPI_STATE_D0;\r\n*state = result;\r\nout:\r\nACPI_DEBUG_PRINT((ACPI_DB_INFO, "Device [%s] power state is %s\n",\r\ndevice->pnp.bus_id, acpi_power_state_string(*state)));\r\nreturn 0;\r\n}\r\nstatic int acpi_dev_pm_explicit_set(struct acpi_device *adev, int state)\r\n{\r\nif (adev->power.states[state].flags.explicit_set) {\r\nchar method[5] = { '_', 'P', 'S', '0' + state, '\0' };\r\nacpi_status status;\r\nstatus = acpi_evaluate_object(adev->handle, method, NULL, NULL);\r\nif (ACPI_FAILURE(status))\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\n}\r\nint acpi_device_set_power(struct acpi_device *device, int state)\r\n{\r\nint result = 0;\r\nbool cut_power = false;\r\nif (!device || !device->flags.power_manageable\r\n|| (state < ACPI_STATE_D0) || (state > ACPI_STATE_D3_COLD))\r\nreturn -EINVAL;\r\nif (state == device->power.state) {\r\nACPI_DEBUG_PRINT((ACPI_DB_INFO, "Device [%s] already in %s\n",\r\ndevice->pnp.bus_id,\r\nacpi_power_state_string(state)));\r\nreturn 0;\r\n}\r\nif (!device->power.states[state].flags.valid) {\r\ndev_warn(&device->dev, "Power state %s not supported\n",\r\nacpi_power_state_string(state));\r\nreturn -ENODEV;\r\n}\r\nif (!device->power.flags.ignore_parent &&\r\ndevice->parent && (state < device->parent->power.state)) {\r\ndev_warn(&device->dev,\r\n"Cannot transition to power state %s for parent in %s\n",\r\nacpi_power_state_string(state),\r\nacpi_power_state_string(device->parent->power.state));\r\nreturn -ENODEV;\r\n}\r\nif (state == ACPI_STATE_D3_COLD\r\n&& device->power.states[ACPI_STATE_D3_COLD].flags.os_accessible) {\r\nstate = ACPI_STATE_D3_HOT;\r\ncut_power = true;\r\n}\r\nif (state < device->power.state && state != ACPI_STATE_D0\r\n&& device->power.state >= ACPI_STATE_D3_HOT) {\r\ndev_warn(&device->dev,\r\n"Cannot transition to non-D0 state from D3\n");\r\nreturn -ENODEV;\r\n}\r\nif (device->power.flags.power_resources) {\r\nresult = acpi_power_transition(device, state);\r\nif (result)\r\ngoto end;\r\n}\r\nresult = acpi_dev_pm_explicit_set(device, state);\r\nif (result)\r\ngoto end;\r\nif (cut_power) {\r\ndevice->power.state = state;\r\nstate = ACPI_STATE_D3_COLD;\r\nresult = acpi_power_transition(device, state);\r\n}\r\nend:\r\nif (result) {\r\ndev_warn(&device->dev, "Failed to change power state to %s\n",\r\nacpi_power_state_string(state));\r\n} else {\r\ndevice->power.state = state;\r\nACPI_DEBUG_PRINT((ACPI_DB_INFO,\r\n"Device [%s] transitioned to %s\n",\r\ndevice->pnp.bus_id,\r\nacpi_power_state_string(state)));\r\n}\r\nreturn result;\r\n}\r\nint acpi_bus_set_power(acpi_handle handle, int state)\r\n{\r\nstruct acpi_device *device;\r\nint result;\r\nresult = acpi_bus_get_device(handle, &device);\r\nif (result)\r\nreturn result;\r\nreturn acpi_device_set_power(device, state);\r\n}\r\nint acpi_bus_init_power(struct acpi_device *device)\r\n{\r\nint state;\r\nint result;\r\nif (!device)\r\nreturn -EINVAL;\r\ndevice->power.state = ACPI_STATE_UNKNOWN;\r\nif (!acpi_device_is_present(device))\r\nreturn -ENXIO;\r\nresult = acpi_device_get_power(device, &state);\r\nif (result)\r\nreturn result;\r\nif (state < ACPI_STATE_D3_COLD && device->power.flags.power_resources) {\r\nresult = acpi_power_on_resources(device, state);\r\nif (result)\r\nreturn result;\r\nresult = acpi_dev_pm_explicit_set(device, state);\r\nif (result)\r\nreturn result;\r\n} else if (state == ACPI_STATE_UNKNOWN) {\r\nstate = ACPI_STATE_D0;\r\n}\r\ndevice->power.state = state;\r\nreturn 0;\r\n}\r\nint acpi_device_fix_up_power(struct acpi_device *device)\r\n{\r\nint ret = 0;\r\nif (!device->power.flags.power_resources\r\n&& !device->power.flags.explicit_get\r\n&& device->power.state == ACPI_STATE_D0)\r\nret = acpi_dev_pm_explicit_set(device, ACPI_STATE_D0);\r\nreturn ret;\r\n}\r\nint acpi_device_update_power(struct acpi_device *device, int *state_p)\r\n{\r\nint state;\r\nint result;\r\nif (device->power.state == ACPI_STATE_UNKNOWN) {\r\nresult = acpi_bus_init_power(device);\r\nif (!result && state_p)\r\n*state_p = device->power.state;\r\nreturn result;\r\n}\r\nresult = acpi_device_get_power(device, &state);\r\nif (result)\r\nreturn result;\r\nif (state == ACPI_STATE_UNKNOWN) {\r\nstate = ACPI_STATE_D0;\r\nresult = acpi_device_set_power(device, state);\r\nif (result)\r\nreturn result;\r\n} else {\r\nif (device->power.flags.power_resources) {\r\nresult = acpi_power_transition(device, state);\r\nif (result)\r\nreturn result;\r\n}\r\ndevice->power.state = state;\r\n}\r\nif (state_p)\r\n*state_p = state;\r\nreturn 0;\r\n}\r\nint acpi_bus_update_power(acpi_handle handle, int *state_p)\r\n{\r\nstruct acpi_device *device;\r\nint result;\r\nresult = acpi_bus_get_device(handle, &device);\r\nreturn result ? result : acpi_device_update_power(device, state_p);\r\n}\r\nbool acpi_bus_power_manageable(acpi_handle handle)\r\n{\r\nstruct acpi_device *device;\r\nint result;\r\nresult = acpi_bus_get_device(handle, &device);\r\nreturn result ? false : device->flags.power_manageable;\r\n}\r\nstatic void acpi_pm_notify_handler(acpi_handle handle, u32 val, void *not_used)\r\n{\r\nstruct acpi_device *adev;\r\nif (val != ACPI_NOTIFY_DEVICE_WAKE)\r\nreturn;\r\nadev = acpi_bus_get_acpi_device(handle);\r\nif (!adev)\r\nreturn;\r\nmutex_lock(&acpi_pm_notifier_lock);\r\nif (adev->wakeup.flags.notifier_present) {\r\n__pm_wakeup_event(adev->wakeup.ws, 0);\r\nif (adev->wakeup.context.work.func)\r\nqueue_pm_work(&adev->wakeup.context.work);\r\n}\r\nmutex_unlock(&acpi_pm_notifier_lock);\r\nacpi_bus_put_acpi_device(adev);\r\n}\r\nacpi_status acpi_add_pm_notifier(struct acpi_device *adev, struct device *dev,\r\nvoid (*work_func)(struct work_struct *work))\r\n{\r\nacpi_status status = AE_ALREADY_EXISTS;\r\nif (!dev && !work_func)\r\nreturn AE_BAD_PARAMETER;\r\nmutex_lock(&acpi_pm_notifier_lock);\r\nif (adev->wakeup.flags.notifier_present)\r\ngoto out;\r\nadev->wakeup.ws = wakeup_source_register(dev_name(&adev->dev));\r\nadev->wakeup.context.dev = dev;\r\nif (work_func)\r\nINIT_WORK(&adev->wakeup.context.work, work_func);\r\nstatus = acpi_install_notify_handler(adev->handle, ACPI_SYSTEM_NOTIFY,\r\nacpi_pm_notify_handler, NULL);\r\nif (ACPI_FAILURE(status))\r\ngoto out;\r\nadev->wakeup.flags.notifier_present = true;\r\nout:\r\nmutex_unlock(&acpi_pm_notifier_lock);\r\nreturn status;\r\n}\r\nacpi_status acpi_remove_pm_notifier(struct acpi_device *adev)\r\n{\r\nacpi_status status = AE_BAD_PARAMETER;\r\nmutex_lock(&acpi_pm_notifier_lock);\r\nif (!adev->wakeup.flags.notifier_present)\r\ngoto out;\r\nstatus = acpi_remove_notify_handler(adev->handle,\r\nACPI_SYSTEM_NOTIFY,\r\nacpi_pm_notify_handler);\r\nif (ACPI_FAILURE(status))\r\ngoto out;\r\nif (adev->wakeup.context.work.func) {\r\ncancel_work_sync(&adev->wakeup.context.work);\r\nadev->wakeup.context.work.func = NULL;\r\n}\r\nadev->wakeup.context.dev = NULL;\r\nwakeup_source_unregister(adev->wakeup.ws);\r\nadev->wakeup.flags.notifier_present = false;\r\nout:\r\nmutex_unlock(&acpi_pm_notifier_lock);\r\nreturn status;\r\n}\r\nbool acpi_bus_can_wakeup(acpi_handle handle)\r\n{\r\nstruct acpi_device *device;\r\nint result;\r\nresult = acpi_bus_get_device(handle, &device);\r\nreturn result ? false : device->wakeup.flags.valid;\r\n}\r\nstatic int acpi_dev_pm_get_state(struct device *dev, struct acpi_device *adev,\r\nu32 target_state, int *d_min_p, int *d_max_p)\r\n{\r\nchar method[] = { '_', 'S', '0' + target_state, 'D', '\0' };\r\nacpi_handle handle = adev->handle;\r\nunsigned long long ret;\r\nint d_min, d_max;\r\nbool wakeup = false;\r\nacpi_status status;\r\nd_min = ACPI_STATE_D0;\r\nd_max = ACPI_STATE_D3_COLD;\r\nif (target_state > ACPI_STATE_S0) {\r\nret = d_min;\r\nstatus = acpi_evaluate_integer(handle, method, NULL, &ret);\r\nif ((ACPI_FAILURE(status) && status != AE_NOT_FOUND)\r\n|| ret > ACPI_STATE_D3_COLD)\r\nreturn -ENODATA;\r\nif (!adev->power.states[ret].flags.valid) {\r\nif (ret == ACPI_STATE_D3_HOT)\r\nret = ACPI_STATE_D3_COLD;\r\nelse\r\nreturn -ENODATA;\r\n}\r\nd_min = ret;\r\nwakeup = device_may_wakeup(dev) && adev->wakeup.flags.valid\r\n&& adev->wakeup.sleep_state >= target_state;\r\n} else if (dev_pm_qos_flags(dev, PM_QOS_FLAG_REMOTE_WAKEUP) !=\r\nPM_QOS_FLAGS_NONE) {\r\nwakeup = adev->wakeup.flags.valid;\r\n}\r\nif (wakeup) {\r\nmethod[3] = 'W';\r\nstatus = acpi_evaluate_integer(handle, method, NULL, &ret);\r\nif (status == AE_NOT_FOUND) {\r\nif (target_state > ACPI_STATE_S0)\r\nd_max = d_min;\r\n} else if (ACPI_SUCCESS(status) && ret <= ACPI_STATE_D3_COLD) {\r\nif (!adev->power.states[ret].flags.valid)\r\nret = ACPI_STATE_D3_COLD;\r\nd_max = ret > d_min ? ret : d_min;\r\n} else {\r\nreturn -ENODATA;\r\n}\r\n}\r\nif (d_min_p)\r\n*d_min_p = d_min;\r\nif (d_max_p)\r\n*d_max_p = d_max;\r\nreturn 0;\r\n}\r\nint acpi_pm_device_sleep_state(struct device *dev, int *d_min_p, int d_max_in)\r\n{\r\nstruct acpi_device *adev;\r\nint ret, d_min, d_max;\r\nif (d_max_in < ACPI_STATE_D0 || d_max_in > ACPI_STATE_D3_COLD)\r\nreturn -EINVAL;\r\nif (d_max_in > ACPI_STATE_D3_HOT) {\r\nenum pm_qos_flags_status stat;\r\nstat = dev_pm_qos_flags(dev, PM_QOS_FLAG_NO_POWER_OFF);\r\nif (stat == PM_QOS_FLAGS_ALL)\r\nd_max_in = ACPI_STATE_D3_HOT;\r\n}\r\nadev = ACPI_COMPANION(dev);\r\nif (!adev) {\r\ndev_dbg(dev, "ACPI companion missing in %s!\n", __func__);\r\nreturn -ENODEV;\r\n}\r\nret = acpi_dev_pm_get_state(dev, adev, acpi_target_system_state(),\r\n&d_min, &d_max);\r\nif (ret)\r\nreturn ret;\r\nif (d_max_in < d_min)\r\nreturn -EINVAL;\r\nif (d_max > d_max_in) {\r\nfor (d_max = d_max_in; d_max > d_min; d_max--) {\r\nif (adev->power.states[d_max].flags.valid)\r\nbreak;\r\n}\r\n}\r\nif (d_min_p)\r\n*d_min_p = d_min;\r\nreturn d_max;\r\n}\r\nstatic void acpi_pm_notify_work_func(struct work_struct *work)\r\n{\r\nstruct device *dev;\r\ndev = container_of(work, struct acpi_device_wakeup_context, work)->dev;\r\nif (dev) {\r\npm_wakeup_event(dev, 0);\r\npm_runtime_resume(dev);\r\n}\r\n}\r\nstatic int acpi_device_wakeup(struct acpi_device *adev, u32 target_state,\r\nbool enable)\r\n{\r\nstruct acpi_device_wakeup *wakeup = &adev->wakeup;\r\nif (enable) {\r\nacpi_status res;\r\nint error;\r\nerror = acpi_enable_wakeup_device_power(adev, target_state);\r\nif (error)\r\nreturn error;\r\nif (adev->wakeup.flags.enabled)\r\nreturn 0;\r\nres = acpi_enable_gpe(wakeup->gpe_device, wakeup->gpe_number);\r\nif (ACPI_SUCCESS(res)) {\r\nadev->wakeup.flags.enabled = 1;\r\n} else {\r\nacpi_disable_wakeup_device_power(adev);\r\nreturn -EIO;\r\n}\r\n} else {\r\nif (adev->wakeup.flags.enabled) {\r\nacpi_disable_gpe(wakeup->gpe_device, wakeup->gpe_number);\r\nadev->wakeup.flags.enabled = 0;\r\n}\r\nacpi_disable_wakeup_device_power(adev);\r\n}\r\nreturn 0;\r\n}\r\nint acpi_pm_device_run_wake(struct device *phys_dev, bool enable)\r\n{\r\nstruct acpi_device *adev;\r\nif (!device_run_wake(phys_dev))\r\nreturn -EINVAL;\r\nadev = ACPI_COMPANION(phys_dev);\r\nif (!adev) {\r\ndev_dbg(phys_dev, "ACPI companion missing in %s!\n", __func__);\r\nreturn -ENODEV;\r\n}\r\nreturn acpi_device_wakeup(adev, ACPI_STATE_S0, enable);\r\n}\r\nint acpi_pm_device_sleep_wake(struct device *dev, bool enable)\r\n{\r\nstruct acpi_device *adev;\r\nint error;\r\nif (!device_can_wakeup(dev))\r\nreturn -EINVAL;\r\nadev = ACPI_COMPANION(dev);\r\nif (!adev) {\r\ndev_dbg(dev, "ACPI companion missing in %s!\n", __func__);\r\nreturn -ENODEV;\r\n}\r\nerror = acpi_device_wakeup(adev, acpi_target_system_state(), enable);\r\nif (!error)\r\ndev_info(dev, "System wakeup %s by ACPI\n",\r\nenable ? "enabled" : "disabled");\r\nreturn error;\r\n}\r\nstatic int acpi_dev_pm_low_power(struct device *dev, struct acpi_device *adev,\r\nu32 system_state)\r\n{\r\nint ret, state;\r\nif (!acpi_device_power_manageable(adev))\r\nreturn 0;\r\nret = acpi_dev_pm_get_state(dev, adev, system_state, NULL, &state);\r\nreturn ret ? ret : acpi_device_set_power(adev, state);\r\n}\r\nstatic int acpi_dev_pm_full_power(struct acpi_device *adev)\r\n{\r\nreturn acpi_device_power_manageable(adev) ?\r\nacpi_device_set_power(adev, ACPI_STATE_D0) : 0;\r\n}\r\nint acpi_dev_runtime_suspend(struct device *dev)\r\n{\r\nstruct acpi_device *adev = ACPI_COMPANION(dev);\r\nbool remote_wakeup;\r\nint error;\r\nif (!adev)\r\nreturn 0;\r\nremote_wakeup = dev_pm_qos_flags(dev, PM_QOS_FLAG_REMOTE_WAKEUP) >\r\nPM_QOS_FLAGS_NONE;\r\nerror = acpi_device_wakeup(adev, ACPI_STATE_S0, remote_wakeup);\r\nif (remote_wakeup && error)\r\nreturn -EAGAIN;\r\nerror = acpi_dev_pm_low_power(dev, adev, ACPI_STATE_S0);\r\nif (error)\r\nacpi_device_wakeup(adev, ACPI_STATE_S0, false);\r\nreturn error;\r\n}\r\nint acpi_dev_runtime_resume(struct device *dev)\r\n{\r\nstruct acpi_device *adev = ACPI_COMPANION(dev);\r\nint error;\r\nif (!adev)\r\nreturn 0;\r\nerror = acpi_dev_pm_full_power(adev);\r\nacpi_device_wakeup(adev, ACPI_STATE_S0, false);\r\nreturn error;\r\n}\r\nint acpi_subsys_runtime_suspend(struct device *dev)\r\n{\r\nint ret = pm_generic_runtime_suspend(dev);\r\nreturn ret ? ret : acpi_dev_runtime_suspend(dev);\r\n}\r\nint acpi_subsys_runtime_resume(struct device *dev)\r\n{\r\nint ret = acpi_dev_runtime_resume(dev);\r\nreturn ret ? ret : pm_generic_runtime_resume(dev);\r\n}\r\nint acpi_dev_suspend_late(struct device *dev)\r\n{\r\nstruct acpi_device *adev = ACPI_COMPANION(dev);\r\nu32 target_state;\r\nbool wakeup;\r\nint error;\r\nif (!adev)\r\nreturn 0;\r\ntarget_state = acpi_target_system_state();\r\nwakeup = device_may_wakeup(dev) && acpi_device_can_wakeup(adev);\r\nerror = acpi_device_wakeup(adev, target_state, wakeup);\r\nif (wakeup && error)\r\nreturn error;\r\nerror = acpi_dev_pm_low_power(dev, adev, target_state);\r\nif (error)\r\nacpi_device_wakeup(adev, ACPI_STATE_UNKNOWN, false);\r\nreturn error;\r\n}\r\nint acpi_dev_resume_early(struct device *dev)\r\n{\r\nstruct acpi_device *adev = ACPI_COMPANION(dev);\r\nint error;\r\nif (!adev)\r\nreturn 0;\r\nerror = acpi_dev_pm_full_power(adev);\r\nacpi_device_wakeup(adev, ACPI_STATE_UNKNOWN, false);\r\nreturn error;\r\n}\r\nint acpi_subsys_prepare(struct device *dev)\r\n{\r\nstruct acpi_device *adev = ACPI_COMPANION(dev);\r\nu32 sys_target;\r\nint ret, state;\r\nret = pm_generic_prepare(dev);\r\nif (ret < 0)\r\nreturn ret;\r\nif (!adev || !pm_runtime_suspended(dev)\r\n|| device_may_wakeup(dev) != !!adev->wakeup.prepare_count)\r\nreturn 0;\r\nsys_target = acpi_target_system_state();\r\nif (sys_target == ACPI_STATE_S0)\r\nreturn 1;\r\nif (adev->power.flags.dsw_present)\r\nreturn 0;\r\nret = acpi_dev_pm_get_state(dev, adev, sys_target, NULL, &state);\r\nreturn !ret && state == adev->power.state;\r\n}\r\nvoid acpi_subsys_complete(struct device *dev)\r\n{\r\nif (dev->power.direct_complete)\r\npm_request_resume(dev);\r\n}\r\nint acpi_subsys_suspend(struct device *dev)\r\n{\r\npm_runtime_resume(dev);\r\nreturn pm_generic_suspend(dev);\r\n}\r\nint acpi_subsys_suspend_late(struct device *dev)\r\n{\r\nint ret = pm_generic_suspend_late(dev);\r\nreturn ret ? ret : acpi_dev_suspend_late(dev);\r\n}\r\nint acpi_subsys_resume_early(struct device *dev)\r\n{\r\nint ret = acpi_dev_resume_early(dev);\r\nreturn ret ? ret : pm_generic_resume_early(dev);\r\n}\r\nint acpi_subsys_freeze(struct device *dev)\r\n{\r\npm_runtime_resume(dev);\r\nreturn pm_generic_freeze(dev);\r\n}\r\nstatic void acpi_dev_pm_detach(struct device *dev, bool power_off)\r\n{\r\nstruct acpi_device *adev = ACPI_COMPANION(dev);\r\nif (adev && dev->pm_domain == &acpi_general_pm_domain) {\r\ndev->pm_domain = NULL;\r\nacpi_remove_pm_notifier(adev);\r\nif (power_off) {\r\ndev_pm_qos_hide_latency_limit(dev);\r\ndev_pm_qos_hide_flags(dev);\r\nacpi_device_wakeup(adev, ACPI_STATE_S0, false);\r\nacpi_dev_pm_low_power(dev, adev, ACPI_STATE_S0);\r\n}\r\n}\r\n}\r\nint acpi_dev_pm_attach(struct device *dev, bool power_on)\r\n{\r\nstruct acpi_device *adev = ACPI_COMPANION(dev);\r\nif (!adev)\r\nreturn -ENODEV;\r\nif (dev->pm_domain)\r\nreturn -EEXIST;\r\nacpi_add_pm_notifier(adev, dev, acpi_pm_notify_work_func);\r\ndev->pm_domain = &acpi_general_pm_domain;\r\nif (power_on) {\r\nacpi_dev_pm_full_power(adev);\r\nacpi_device_wakeup(adev, ACPI_STATE_S0, false);\r\n}\r\ndev->pm_domain->detach = acpi_dev_pm_detach;\r\nreturn 0;\r\n}
