static int si476x_codec_set_dai_fmt(struct snd_soc_dai *codec_dai,\r\nunsigned int fmt)\r\n{\r\nstruct si476x_core *core = i2c_mfd_cell_to_core(codec_dai->dev);\r\nint err;\r\nu16 format = 0;\r\nif ((fmt & SND_SOC_DAIFMT_MASTER_MASK) != SND_SOC_DAIFMT_CBS_CFS)\r\nreturn -EINVAL;\r\nswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\r\ncase SND_SOC_DAIFMT_DSP_A:\r\nformat |= SI476X_DAUDIO_MODE_DSP_A;\r\nbreak;\r\ncase SND_SOC_DAIFMT_DSP_B:\r\nformat |= SI476X_DAUDIO_MODE_DSP_B;\r\nbreak;\r\ncase SND_SOC_DAIFMT_I2S:\r\nformat |= SI476X_DAUDIO_MODE_I2S;\r\nbreak;\r\ncase SND_SOC_DAIFMT_RIGHT_J:\r\nformat |= SI476X_DAUDIO_MODE_RIGHT_J;\r\nbreak;\r\ncase SND_SOC_DAIFMT_LEFT_J:\r\nformat |= SI476X_DAUDIO_MODE_LEFT_J;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\r\ncase SND_SOC_DAIFMT_DSP_A:\r\ncase SND_SOC_DAIFMT_DSP_B:\r\nswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\r\ncase SND_SOC_DAIFMT_NB_NF:\r\nbreak;\r\ncase SND_SOC_DAIFMT_IB_NF:\r\nformat |= SI476X_DAUDIO_MODE_IB;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ncase SND_SOC_DAIFMT_I2S:\r\ncase SND_SOC_DAIFMT_RIGHT_J:\r\ncase SND_SOC_DAIFMT_LEFT_J:\r\nswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\r\ncase SND_SOC_DAIFMT_NB_NF:\r\nbreak;\r\ncase SND_SOC_DAIFMT_IB_IF:\r\nformat |= SI476X_DAUDIO_MODE_IB |\r\nSI476X_DAUDIO_MODE_IF;\r\nbreak;\r\ncase SND_SOC_DAIFMT_IB_NF:\r\nformat |= SI476X_DAUDIO_MODE_IB;\r\nbreak;\r\ncase SND_SOC_DAIFMT_NB_IF:\r\nformat |= SI476X_DAUDIO_MODE_IF;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nsi476x_core_lock(core);\r\nerr = snd_soc_update_bits(codec_dai->codec, SI476X_DIGITAL_IO_OUTPUT_FORMAT,\r\nSI476X_DIGITAL_IO_OUTPUT_FORMAT_MASK,\r\nformat);\r\nsi476x_core_unlock(core);\r\nif (err < 0) {\r\ndev_err(codec_dai->codec->dev, "Failed to set output format\n");\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic int si476x_codec_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct si476x_core *core = i2c_mfd_cell_to_core(dai->dev);\r\nint rate, width, err;\r\nrate = params_rate(params);\r\nif (rate < 32000 || rate > 48000) {\r\ndev_err(dai->codec->dev, "Rate: %d is not supported\n", rate);\r\nreturn -EINVAL;\r\n}\r\nswitch (params_width(params)) {\r\ncase 8:\r\nwidth = SI476X_PCM_FORMAT_S8;\r\nbreak;\r\ncase 16:\r\nwidth = SI476X_PCM_FORMAT_S16_LE;\r\nbreak;\r\ncase 20:\r\nwidth = SI476X_PCM_FORMAT_S20_3LE;\r\nbreak;\r\ncase 24:\r\nwidth = SI476X_PCM_FORMAT_S24_LE;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nsi476x_core_lock(core);\r\nerr = snd_soc_write(dai->codec, SI476X_DIGITAL_IO_OUTPUT_SAMPLE_RATE,\r\nrate);\r\nif (err < 0) {\r\ndev_err(dai->codec->dev, "Failed to set sample rate\n");\r\ngoto out;\r\n}\r\nerr = snd_soc_update_bits(dai->codec, SI476X_DIGITAL_IO_OUTPUT_FORMAT,\r\nSI476X_DIGITAL_IO_OUTPUT_WIDTH_MASK,\r\n(width << SI476X_DIGITAL_IO_SLOT_SIZE_SHIFT) |\r\n(width << SI476X_DIGITAL_IO_SAMPLE_SIZE_SHIFT));\r\nif (err < 0) {\r\ndev_err(dai->codec->dev, "Failed to set output width\n");\r\ngoto out;\r\n}\r\nout:\r\nsi476x_core_unlock(core);\r\nreturn err;\r\n}\r\nstatic struct regmap *si476x_get_regmap(struct device *dev)\r\n{\r\nreturn dev_get_regmap(dev->parent, NULL);\r\n}\r\nstatic int si476x_platform_probe(struct platform_device *pdev)\r\n{\r\nreturn snd_soc_register_codec(&pdev->dev, &soc_codec_dev_si476x,\r\n&si476x_dai, 1);\r\n}\r\nstatic int si476x_platform_remove(struct platform_device *pdev)\r\n{\r\nsnd_soc_unregister_codec(&pdev->dev);\r\nreturn 0;\r\n}
