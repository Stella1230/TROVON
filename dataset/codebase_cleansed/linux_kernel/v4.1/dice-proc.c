static int dice_proc_read_mem(struct snd_dice *dice, void *buffer,\r\nunsigned int offset_q, unsigned int quadlets)\r\n{\r\nunsigned int i;\r\nint err;\r\nerr = snd_fw_transaction(dice->unit, TCODE_READ_BLOCK_REQUEST,\r\nDICE_PRIVATE_SPACE + 4 * offset_q,\r\nbuffer, 4 * quadlets, 0);\r\nif (err < 0)\r\nreturn err;\r\nfor (i = 0; i < quadlets; ++i)\r\nbe32_to_cpus(&((u32 *)buffer)[i]);\r\nreturn 0;\r\n}\r\nstatic const char *str_from_array(const char *const strs[], unsigned int count,\r\nunsigned int i)\r\n{\r\nif (i < count)\r\nreturn strs[i];\r\nreturn "(unknown)";\r\n}\r\nstatic void dice_proc_fixup_string(char *s, unsigned int size)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < size; i += 4)\r\ncpu_to_le32s((u32 *)(s + i));\r\nfor (i = 0; i < size - 2; ++i) {\r\nif (s[i] == '\0')\r\nreturn;\r\nif (s[i] == '\\' && s[i + 1] == '\\') {\r\ns[i + 2] = '\0';\r\nreturn;\r\n}\r\n}\r\ns[size - 1] = '\0';\r\n}\r\nstatic void dice_proc_read(struct snd_info_entry *entry,\r\nstruct snd_info_buffer *buffer)\r\n{\r\nstatic const char *const section_names[5] = {\r\n"global", "tx", "rx", "ext_sync", "unused2"\r\n};\r\nstatic const char *const clock_sources[] = {\r\n"aes1", "aes2", "aes3", "aes4", "aes", "adat", "tdif",\r\n"wc", "arx1", "arx2", "arx3", "arx4", "internal"\r\n};\r\nstatic const char *const rates[] = {\r\n"32000", "44100", "48000", "88200", "96000", "176400", "192000",\r\n"any low", "any mid", "any high", "none"\r\n};\r\nstruct snd_dice *dice = entry->private_data;\r\nu32 sections[ARRAY_SIZE(section_names) * 2];\r\nstruct {\r\nu32 number;\r\nu32 size;\r\n} tx_rx_header;\r\nunion {\r\nstruct {\r\nu32 owner_hi, owner_lo;\r\nu32 notification;\r\nchar nick_name[NICK_NAME_SIZE];\r\nu32 clock_select;\r\nu32 enable;\r\nu32 status;\r\nu32 extended_status;\r\nu32 sample_rate;\r\nu32 version;\r\nu32 clock_caps;\r\nchar clock_source_names[CLOCK_SOURCE_NAMES_SIZE];\r\n} global;\r\nstruct {\r\nu32 iso;\r\nu32 number_audio;\r\nu32 number_midi;\r\nu32 speed;\r\nchar names[TX_NAMES_SIZE];\r\nu32 ac3_caps;\r\nu32 ac3_enable;\r\n} tx;\r\nstruct {\r\nu32 iso;\r\nu32 seq_start;\r\nu32 number_audio;\r\nu32 number_midi;\r\nchar names[RX_NAMES_SIZE];\r\nu32 ac3_caps;\r\nu32 ac3_enable;\r\n} rx;\r\nstruct {\r\nu32 clock_source;\r\nu32 locked;\r\nu32 rate;\r\nu32 adat_user_data;\r\n} ext_sync;\r\n} buf;\r\nunsigned int quadlets, stream, i;\r\nif (dice_proc_read_mem(dice, sections, 0, ARRAY_SIZE(sections)) < 0)\r\nreturn;\r\nsnd_iprintf(buffer, "sections:\n");\r\nfor (i = 0; i < ARRAY_SIZE(section_names); ++i)\r\nsnd_iprintf(buffer, " %s: offset %u, size %u\n",\r\nsection_names[i],\r\nsections[i * 2], sections[i * 2 + 1]);\r\nquadlets = min_t(u32, sections[1], sizeof(buf.global) / 4);\r\nif (dice_proc_read_mem(dice, &buf.global, sections[0], quadlets) < 0)\r\nreturn;\r\nsnd_iprintf(buffer, "global:\n");\r\nsnd_iprintf(buffer, " owner: %04x:%04x%08x\n",\r\nbuf.global.owner_hi >> 16,\r\nbuf.global.owner_hi & 0xffff, buf.global.owner_lo);\r\nsnd_iprintf(buffer, " notification: %08x\n", buf.global.notification);\r\ndice_proc_fixup_string(buf.global.nick_name, NICK_NAME_SIZE);\r\nsnd_iprintf(buffer, " nick name: %s\n", buf.global.nick_name);\r\nsnd_iprintf(buffer, " clock select: %s %s\n",\r\nstr_from_array(clock_sources, ARRAY_SIZE(clock_sources),\r\nbuf.global.clock_select & CLOCK_SOURCE_MASK),\r\nstr_from_array(rates, ARRAY_SIZE(rates),\r\n(buf.global.clock_select & CLOCK_RATE_MASK)\r\n>> CLOCK_RATE_SHIFT));\r\nsnd_iprintf(buffer, " enable: %u\n", buf.global.enable);\r\nsnd_iprintf(buffer, " status: %slocked %s\n",\r\nbuf.global.status & STATUS_SOURCE_LOCKED ? "" : "un",\r\nstr_from_array(rates, ARRAY_SIZE(rates),\r\n(buf.global.status &\r\nSTATUS_NOMINAL_RATE_MASK)\r\n>> CLOCK_RATE_SHIFT));\r\nsnd_iprintf(buffer, " ext status: %08x\n", buf.global.extended_status);\r\nsnd_iprintf(buffer, " sample rate: %u\n", buf.global.sample_rate);\r\nsnd_iprintf(buffer, " version: %u.%u.%u.%u\n",\r\n(buf.global.version >> 24) & 0xff,\r\n(buf.global.version >> 16) & 0xff,\r\n(buf.global.version >> 8) & 0xff,\r\n(buf.global.version >> 0) & 0xff);\r\nif (quadlets >= 90) {\r\nsnd_iprintf(buffer, " clock caps:");\r\nfor (i = 0; i <= 6; ++i)\r\nif (buf.global.clock_caps & (1 << i))\r\nsnd_iprintf(buffer, " %s", rates[i]);\r\nfor (i = 0; i <= 12; ++i)\r\nif (buf.global.clock_caps & (1 << (16 + i)))\r\nsnd_iprintf(buffer, " %s", clock_sources[i]);\r\nsnd_iprintf(buffer, "\n");\r\ndice_proc_fixup_string(buf.global.clock_source_names,\r\nCLOCK_SOURCE_NAMES_SIZE);\r\nsnd_iprintf(buffer, " clock source names: %s\n",\r\nbuf.global.clock_source_names);\r\n}\r\nif (dice_proc_read_mem(dice, &tx_rx_header, sections[2], 2) < 0)\r\nreturn;\r\nquadlets = min_t(u32, tx_rx_header.size, sizeof(buf.tx) / 4);\r\nfor (stream = 0; stream < tx_rx_header.number; ++stream) {\r\nif (dice_proc_read_mem(dice, &buf.tx, sections[2] + 2 +\r\nstream * tx_rx_header.size,\r\nquadlets) < 0)\r\nbreak;\r\nsnd_iprintf(buffer, "tx %u:\n", stream);\r\nsnd_iprintf(buffer, " iso channel: %d\n", (int)buf.tx.iso);\r\nsnd_iprintf(buffer, " audio channels: %u\n",\r\nbuf.tx.number_audio);\r\nsnd_iprintf(buffer, " midi ports: %u\n", buf.tx.number_midi);\r\nsnd_iprintf(buffer, " speed: S%u\n", 100u << buf.tx.speed);\r\nif (quadlets >= 68) {\r\ndice_proc_fixup_string(buf.tx.names, TX_NAMES_SIZE);\r\nsnd_iprintf(buffer, " names: %s\n", buf.tx.names);\r\n}\r\nif (quadlets >= 70) {\r\nsnd_iprintf(buffer, " ac3 caps: %08x\n",\r\nbuf.tx.ac3_caps);\r\nsnd_iprintf(buffer, " ac3 enable: %08x\n",\r\nbuf.tx.ac3_enable);\r\n}\r\n}\r\nif (dice_proc_read_mem(dice, &tx_rx_header, sections[4], 2) < 0)\r\nreturn;\r\nquadlets = min_t(u32, tx_rx_header.size, sizeof(buf.rx) / 4);\r\nfor (stream = 0; stream < tx_rx_header.number; ++stream) {\r\nif (dice_proc_read_mem(dice, &buf.rx, sections[4] + 2 +\r\nstream * tx_rx_header.size,\r\nquadlets) < 0)\r\nbreak;\r\nsnd_iprintf(buffer, "rx %u:\n", stream);\r\nsnd_iprintf(buffer, " iso channel: %d\n", (int)buf.rx.iso);\r\nsnd_iprintf(buffer, " sequence start: %u\n", buf.rx.seq_start);\r\nsnd_iprintf(buffer, " audio channels: %u\n",\r\nbuf.rx.number_audio);\r\nsnd_iprintf(buffer, " midi ports: %u\n", buf.rx.number_midi);\r\nif (quadlets >= 68) {\r\ndice_proc_fixup_string(buf.rx.names, RX_NAMES_SIZE);\r\nsnd_iprintf(buffer, " names: %s\n", buf.rx.names);\r\n}\r\nif (quadlets >= 70) {\r\nsnd_iprintf(buffer, " ac3 caps: %08x\n",\r\nbuf.rx.ac3_caps);\r\nsnd_iprintf(buffer, " ac3 enable: %08x\n",\r\nbuf.rx.ac3_enable);\r\n}\r\n}\r\nquadlets = min_t(u32, sections[7], sizeof(buf.ext_sync) / 4);\r\nif (quadlets >= 4) {\r\nif (dice_proc_read_mem(dice, &buf.ext_sync,\r\nsections[6], 4) < 0)\r\nreturn;\r\nsnd_iprintf(buffer, "ext status:\n");\r\nsnd_iprintf(buffer, " clock source: %s\n",\r\nstr_from_array(clock_sources,\r\nARRAY_SIZE(clock_sources),\r\nbuf.ext_sync.clock_source));\r\nsnd_iprintf(buffer, " locked: %u\n", buf.ext_sync.locked);\r\nsnd_iprintf(buffer, " rate: %s\n",\r\nstr_from_array(rates, ARRAY_SIZE(rates),\r\nbuf.ext_sync.rate));\r\nsnd_iprintf(buffer, " adat user data: ");\r\nif (buf.ext_sync.adat_user_data & ADAT_USER_DATA_NO_DATA)\r\nsnd_iprintf(buffer, "-\n");\r\nelse\r\nsnd_iprintf(buffer, "%x\n",\r\nbuf.ext_sync.adat_user_data);\r\n}\r\n}\r\nvoid snd_dice_create_proc(struct snd_dice *dice)\r\n{\r\nstruct snd_info_entry *entry;\r\nif (!snd_card_proc_new(dice->card, "dice", &entry))\r\nsnd_info_set_text_ops(entry, dice, dice_proc_read);\r\n}
