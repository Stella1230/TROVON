static const uint32_t *sti_hqvdp_get_formats(struct sti_layer *layer)\r\n{\r\nreturn hqvdp_supported_formats;\r\n}\r\nstatic unsigned int sti_hqvdp_get_nb_formats(struct sti_layer *layer)\r\n{\r\nreturn ARRAY_SIZE(hqvdp_supported_formats);\r\n}\r\nstatic int sti_hqvdp_get_free_cmd(struct sti_hqvdp *hqvdp)\r\n{\r\nint curr_cmd, next_cmd;\r\ndma_addr_t cmd = hqvdp->hqvdp_cmd_paddr;\r\nint i;\r\ncurr_cmd = readl(hqvdp->regs + HQVDP_MBX_CURRENT_CMD);\r\nnext_cmd = readl(hqvdp->regs + HQVDP_MBX_NEXT_CMD);\r\nfor (i = 0; i < NB_VDP_CMD; i++) {\r\nif ((cmd != curr_cmd) && (cmd != next_cmd))\r\nreturn i * sizeof(struct sti_hqvdp_cmd);\r\ncmd += sizeof(struct sti_hqvdp_cmd);\r\n}\r\nreturn -1;\r\n}\r\nstatic int sti_hqvdp_get_curr_cmd(struct sti_hqvdp *hqvdp)\r\n{\r\nint curr_cmd;\r\ndma_addr_t cmd = hqvdp->hqvdp_cmd_paddr;\r\nunsigned int i;\r\ncurr_cmd = readl(hqvdp->regs + HQVDP_MBX_CURRENT_CMD);\r\nfor (i = 0; i < NB_VDP_CMD; i++) {\r\nif (cmd == curr_cmd)\r\nreturn i * sizeof(struct sti_hqvdp_cmd);\r\ncmd += sizeof(struct sti_hqvdp_cmd);\r\n}\r\nreturn -1;\r\n}\r\nstatic void sti_hqvdp_update_hvsrc(enum sti_hvsrc_orient orient, int scale,\r\nstruct sti_hqvdp_hvsrc *hvsrc)\r\n{\r\nconst int *coef_c, *coef_y;\r\nint shift_c, shift_y;\r\nif (scale < SCALE_MAX_FOR_LEG_LUT_F) {\r\ncoef_y = coef_lut_f_y_legacy;\r\ncoef_c = coef_lut_f_c_legacy;\r\nshift_y = SHIFT_LUT_F_Y_LEGACY;\r\nshift_c = SHIFT_LUT_F_C_LEGACY;\r\n} else if (scale < SCALE_MAX_FOR_LEG_LUT_E) {\r\ncoef_y = coef_lut_e_y_legacy;\r\ncoef_c = coef_lut_e_c_legacy;\r\nshift_y = SHIFT_LUT_E_Y_LEGACY;\r\nshift_c = SHIFT_LUT_E_C_LEGACY;\r\n} else if (scale < SCALE_MAX_FOR_LEG_LUT_D) {\r\ncoef_y = coef_lut_d_y_legacy;\r\ncoef_c = coef_lut_d_c_legacy;\r\nshift_y = SHIFT_LUT_D_Y_LEGACY;\r\nshift_c = SHIFT_LUT_D_C_LEGACY;\r\n} else if (scale < SCALE_MAX_FOR_LEG_LUT_C) {\r\ncoef_y = coef_lut_c_y_legacy;\r\ncoef_c = coef_lut_c_c_legacy;\r\nshift_y = SHIFT_LUT_C_Y_LEGACY;\r\nshift_c = SHIFT_LUT_C_C_LEGACY;\r\n} else if (scale == SCALE_MAX_FOR_LEG_LUT_C) {\r\ncoef_y = coef_c = coef_lut_b;\r\nshift_y = shift_c = SHIFT_LUT_B;\r\n} else {\r\ncoef_y = coef_c = coef_lut_a_legacy;\r\nshift_y = shift_c = SHIFT_LUT_A_LEGACY;\r\n}\r\nif (orient == HVSRC_HORI) {\r\nhvsrc->hori_shift = (shift_c << 16) | shift_y;\r\nmemcpy(hvsrc->yh_coef, coef_y, sizeof(hvsrc->yh_coef));\r\nmemcpy(hvsrc->ch_coef, coef_c, sizeof(hvsrc->ch_coef));\r\n} else {\r\nhvsrc->vert_shift = (shift_c << 16) | shift_y;\r\nmemcpy(hvsrc->yv_coef, coef_y, sizeof(hvsrc->yv_coef));\r\nmemcpy(hvsrc->cv_coef, coef_c, sizeof(hvsrc->cv_coef));\r\n}\r\n}\r\nstatic bool sti_hqvdp_check_hw_scaling(struct sti_layer *layer)\r\n{\r\nstruct sti_hqvdp *hqvdp = to_sti_hqvdp(layer);\r\nunsigned long lfw;\r\nunsigned int inv_zy;\r\nlfw = layer->mode->htotal * (clk_get_rate(hqvdp->clk) / 1000000);\r\nlfw /= max(layer->src_w, layer->dst_w) * layer->mode->clock / 1000;\r\ninv_zy = DIV_ROUND_UP(layer->src_h, layer->dst_h);\r\nreturn (inv_zy <= lfw) ? true : false;\r\n}\r\nstatic int sti_hqvdp_prepare_layer(struct sti_layer *layer, bool first_prepare)\r\n{\r\nstruct sti_hqvdp *hqvdp = to_sti_hqvdp(layer);\r\nstruct sti_hqvdp_cmd *cmd;\r\nint scale_h, scale_v;\r\nint cmd_offset;\r\ndev_dbg(hqvdp->dev, "%s %s\n", __func__, sti_layer_to_str(layer));\r\nhqvdp->vid_plane->funcs->update_plane(hqvdp->vid_plane,\r\nlayer->crtc, layer->fb,\r\nlayer->dst_x, layer->dst_y,\r\nlayer->dst_w, layer->dst_h,\r\nlayer->src_x, layer->src_y,\r\nlayer->src_w, layer->src_h);\r\ncmd_offset = sti_hqvdp_get_free_cmd(hqvdp);\r\nif (cmd_offset == -1) {\r\nDRM_ERROR("No available hqvdp_cmd now\n");\r\nreturn -EBUSY;\r\n}\r\ncmd = hqvdp->hqvdp_cmd + cmd_offset;\r\nif (!sti_hqvdp_check_hw_scaling(layer)) {\r\nDRM_ERROR("Scaling beyond HW capabilities\n");\r\nreturn -EINVAL;\r\n}\r\ncmd->top.config = TOP_CONFIG_PROGRESSIVE;\r\ncmd->top.mem_format = TOP_MEM_FORMAT_DFLT;\r\ncmd->hvsrc.param_ctrl = HVSRC_PARAM_CTRL_DFLT;\r\ncmd->csdi.config = CSDI_CONFIG_PROG;\r\ncmd->iqi.config = IQI_CONFIG_DFLT;\r\ncmd->iqi.con_bri = IQI_CON_BRI_DFLT;\r\ncmd->iqi.sat_gain = IQI_SAT_GAIN_DFLT;\r\ncmd->iqi.pxf_conf = IQI_PXF_CONF_DFLT;\r\ncmd->top.current_luma = (u32) layer->paddr + layer->offsets[0];\r\ncmd->top.current_chroma = (u32) layer->paddr + layer->offsets[1];\r\ncmd->top.luma_processed_pitch = cmd->top.luma_src_pitch =\r\nlayer->pitches[0];\r\ncmd->top.chroma_processed_pitch = cmd->top.chroma_src_pitch =\r\nlayer->pitches[1];\r\nlayer->dst_w = ALIGN(layer->dst_w, 2);\r\nlayer->dst_h = ALIGN(layer->dst_h, 2);\r\nif ((layer->src_w > MAX_WIDTH) || (layer->src_w < MIN_WIDTH) ||\r\n(layer->src_h > MAX_HEIGHT) || (layer->src_h < MIN_HEIGHT) ||\r\n(layer->dst_w > MAX_WIDTH) || (layer->dst_w < MIN_WIDTH) ||\r\n(layer->dst_h > MAX_HEIGHT) || (layer->dst_h < MIN_HEIGHT)) {\r\nDRM_ERROR("Invalid in/out size %dx%d -> %dx%d\n",\r\nlayer->src_w, layer->src_h,\r\nlayer->dst_w, layer->dst_h);\r\nreturn -EINVAL;\r\n}\r\ncmd->top.input_viewport_size = cmd->top.input_frame_size =\r\nlayer->src_h << 16 | layer->src_w;\r\ncmd->hvsrc.output_picture_size = layer->dst_h << 16 | layer->dst_w;\r\ncmd->top.input_viewport_ori = layer->src_y << 16 | layer->src_x;\r\nif (layer->fb->flags & DRM_MODE_FB_INTERLACED) {\r\ncmd->top.config = TOP_CONFIG_INTER_TOP;\r\ncmd->top.input_frame_size = (layer->src_h / 2) << 16 |\r\nlayer->src_w;\r\ncmd->top.luma_processed_pitch *= 2;\r\ncmd->top.luma_src_pitch *= 2;\r\ncmd->top.chroma_processed_pitch *= 2;\r\ncmd->top.chroma_src_pitch *= 2;\r\ncmd->csdi.config = CSDI_CONFIG_INTER_DIR;\r\ncmd->csdi.config2 = CSDI_CONFIG2_DFLT;\r\ncmd->csdi.dcdi_config = CSDI_DCDI_CONFIG_DFLT;\r\n}\r\nscale_h = SCALE_FACTOR * layer->dst_w / layer->src_w;\r\nsti_hqvdp_update_hvsrc(HVSRC_HORI, scale_h, &cmd->hvsrc);\r\nscale_v = SCALE_FACTOR * layer->dst_h / layer->src_h;\r\nsti_hqvdp_update_hvsrc(HVSRC_VERT, scale_v, &cmd->hvsrc);\r\nif (first_prepare) {\r\nif (clk_prepare_enable(hqvdp->clk_pix_main)) {\r\nDRM_ERROR("Failed to prepare/enable pix main clk\n");\r\nreturn -ENXIO;\r\n}\r\nif ((layer->fb->flags & DRM_MODE_FB_INTERLACED) &&\r\nsti_vtg_register_client(hqvdp->vtg,\r\n&hqvdp->vtg_nb, layer->mixer_id)) {\r\nDRM_ERROR("Cannot register VTG notifier\n");\r\nreturn -ENXIO;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int sti_hqvdp_commit_layer(struct sti_layer *layer)\r\n{\r\nstruct sti_hqvdp *hqvdp = to_sti_hqvdp(layer);\r\nint cmd_offset;\r\ndev_dbg(hqvdp->dev, "%s %s\n", __func__, sti_layer_to_str(layer));\r\ncmd_offset = sti_hqvdp_get_free_cmd(hqvdp);\r\nif (cmd_offset == -1) {\r\nDRM_ERROR("No available hqvdp_cmd now\n");\r\nreturn -EBUSY;\r\n}\r\nwritel(hqvdp->hqvdp_cmd_paddr + cmd_offset,\r\nhqvdp->regs + HQVDP_MBX_NEXT_CMD);\r\nhqvdp->curr_field_count++;\r\nif (layer->fb->flags & DRM_MODE_FB_INTERLACED)\r\nhqvdp->btm_field_pending = true;\r\ndev_dbg(hqvdp->dev, "%s Posted command:0x%x\n",\r\n__func__, hqvdp->hqvdp_cmd_paddr + cmd_offset);\r\nreturn 0;\r\n}\r\nstatic int sti_hqvdp_disable_layer(struct sti_layer *layer)\r\n{\r\nstruct sti_hqvdp *hqvdp = to_sti_hqvdp(layer);\r\nint i;\r\nDRM_DEBUG_DRIVER("%s\n", sti_layer_to_str(layer));\r\nif ((layer->fb->flags & DRM_MODE_FB_INTERLACED) &&\r\nsti_vtg_unregister_client(hqvdp->vtg, &hqvdp->vtg_nb))\r\nDRM_DEBUG_DRIVER("Warning: cannot unregister VTG notifier\n");\r\nwritel(0, hqvdp->regs + HQVDP_MBX_NEXT_CMD);\r\nfor (i = 0; i < POLL_MAX_ATTEMPT; i++) {\r\nif (readl(hqvdp->regs + HQVDP_MBX_INFO_XP70)\r\n& INFO_XP70_FW_READY)\r\nbreak;\r\nmsleep(POLL_DELAY_MS);\r\n}\r\nclk_disable_unprepare(hqvdp->clk_pix_main);\r\nif (i == POLL_MAX_ATTEMPT) {\r\nDRM_ERROR("XP70 could not revert to idle\n");\r\nreturn -ENXIO;\r\n}\r\nhqvdp->vid_plane->funcs->disable_plane(hqvdp->vid_plane);\r\nreturn 0;\r\n}\r\nint sti_hqvdp_vtg_cb(struct notifier_block *nb, unsigned long evt, void *data)\r\n{\r\nstruct sti_hqvdp *hqvdp = container_of(nb, struct sti_hqvdp, vtg_nb);\r\nint btm_cmd_offset, top_cmd_offest;\r\nstruct sti_hqvdp_cmd *btm_cmd, *top_cmd;\r\nif ((evt != VTG_TOP_FIELD_EVENT) && (evt != VTG_BOTTOM_FIELD_EVENT)) {\r\nDRM_DEBUG_DRIVER("Unknown event\n");\r\nreturn 0;\r\n}\r\nif (hqvdp->btm_field_pending) {\r\nbtm_cmd_offset = sti_hqvdp_get_free_cmd(hqvdp);\r\ntop_cmd_offest = sti_hqvdp_get_curr_cmd(hqvdp);\r\nif ((btm_cmd_offset == -1) || (top_cmd_offest == -1)) {\r\nDRM_ERROR("Cannot get cmds, skip btm field\n");\r\nreturn -EBUSY;\r\n}\r\nbtm_cmd = hqvdp->hqvdp_cmd + btm_cmd_offset;\r\ntop_cmd = hqvdp->hqvdp_cmd + top_cmd_offest;\r\nmemcpy(btm_cmd, top_cmd, sizeof(*btm_cmd));\r\nbtm_cmd->top.config = TOP_CONFIG_INTER_BTM;\r\nbtm_cmd->top.current_luma +=\r\nbtm_cmd->top.luma_src_pitch / 2;\r\nbtm_cmd->top.current_chroma +=\r\nbtm_cmd->top.chroma_src_pitch / 2;\r\nwritel(hqvdp->hqvdp_cmd_paddr + btm_cmd_offset,\r\nhqvdp->regs + HQVDP_MBX_NEXT_CMD);\r\nhqvdp->curr_field_count++;\r\nhqvdp->btm_field_pending = false;\r\ndev_dbg(hqvdp->dev, "%s Posted command:0x%x\n",\r\n__func__, hqvdp->hqvdp_cmd_paddr);\r\n}\r\nreturn 0;\r\n}\r\nstatic struct drm_plane *sti_hqvdp_find_vid(struct drm_device *dev, int id)\r\n{\r\nstruct drm_plane *plane;\r\nlist_for_each_entry(plane, &dev->mode_config.plane_list, head) {\r\nstruct sti_layer *layer = to_sti_layer(plane);\r\nif (layer->desc == id)\r\nreturn plane;\r\n}\r\nreturn NULL;\r\n}\r\nstatic void sti_hqvd_init(struct sti_layer *layer)\r\n{\r\nstruct sti_hqvdp *hqvdp = to_sti_hqvdp(layer);\r\nint size;\r\nhqvdp->vid_plane = sti_hqvdp_find_vid(hqvdp->drm_dev, STI_VID_0);\r\nif (!hqvdp->vid_plane) {\r\nDRM_ERROR("Cannot find Main video layer\n");\r\nreturn;\r\n}\r\nhqvdp->vtg_nb.notifier_call = sti_hqvdp_vtg_cb;\r\nsize = NB_VDP_CMD * sizeof(struct sti_hqvdp_cmd);\r\nhqvdp->hqvdp_cmd = dma_alloc_writecombine(hqvdp->dev, size,\r\n&hqvdp->hqvdp_cmd_paddr,\r\nGFP_KERNEL | GFP_DMA);\r\nif (!hqvdp->hqvdp_cmd) {\r\nDRM_ERROR("Failed to allocate memory for VDP cmd\n");\r\nreturn;\r\n}\r\nmemset(hqvdp->hqvdp_cmd, 0, size);\r\n}\r\nstruct sti_layer *sti_hqvdp_create(struct device *dev)\r\n{\r\nstruct sti_hqvdp *hqvdp = dev_get_drvdata(dev);\r\nhqvdp->layer.ops = &hqvdp_ops;\r\nreturn &hqvdp->layer;\r\n}\r\nstatic void sti_hqvdp_init_plugs(struct sti_hqvdp *hqvdp)\r\n{\r\nwritel(PLUG_PAGE_SIZE_256, hqvdp->regs + HQVDP_RD_PLUG_PAGE_SIZE);\r\nwritel(PLUG_MIN_OPC_8, hqvdp->regs + HQVDP_RD_PLUG_MIN_OPC);\r\nwritel(PLUG_MAX_OPC_64, hqvdp->regs + HQVDP_RD_PLUG_MAX_OPC);\r\nwritel(PLUG_MAX_CHK_2X, hqvdp->regs + HQVDP_RD_PLUG_MAX_CHK);\r\nwritel(PLUG_MAX_MSG_1X, hqvdp->regs + HQVDP_RD_PLUG_MAX_MSG);\r\nwritel(PLUG_MIN_SPACE_1, hqvdp->regs + HQVDP_RD_PLUG_MIN_SPACE);\r\nwritel(PLUG_CONTROL_ENABLE, hqvdp->regs + HQVDP_RD_PLUG_CONTROL);\r\nwritel(PLUG_PAGE_SIZE_256, hqvdp->regs + HQVDP_WR_PLUG_PAGE_SIZE);\r\nwritel(PLUG_MIN_OPC_8, hqvdp->regs + HQVDP_WR_PLUG_MIN_OPC);\r\nwritel(PLUG_MAX_OPC_64, hqvdp->regs + HQVDP_WR_PLUG_MAX_OPC);\r\nwritel(PLUG_MAX_CHK_2X, hqvdp->regs + HQVDP_WR_PLUG_MAX_CHK);\r\nwritel(PLUG_MAX_MSG_1X, hqvdp->regs + HQVDP_WR_PLUG_MAX_MSG);\r\nwritel(PLUG_MIN_SPACE_1, hqvdp->regs + HQVDP_WR_PLUG_MIN_SPACE);\r\nwritel(PLUG_CONTROL_ENABLE, hqvdp->regs + HQVDP_WR_PLUG_CONTROL);\r\n}\r\nstatic void sti_hqvdp_start_xp70(const struct firmware *firmware, void *ctxt)\r\n{\r\nstruct sti_hqvdp *hqvdp = ctxt;\r\nu32 *fw_rd_plug, *fw_wr_plug, *fw_pmem, *fw_dmem;\r\nu8 *data;\r\nint i;\r\nstruct fw_header {\r\nint rd_size;\r\nint wr_size;\r\nint pmem_size;\r\nint dmem_size;\r\n} *header;\r\nDRM_DEBUG_DRIVER("\n");\r\nif (!firmware) {\r\nDRM_ERROR("Firmware not available\n");\r\nreturn;\r\n}\r\nheader = (struct fw_header *) firmware->data;\r\nif (firmware->size < sizeof(*header)) {\r\nDRM_ERROR("Invalid firmware size (%d)\n", firmware->size);\r\ngoto out;\r\n}\r\nif ((sizeof(*header) + header->rd_size + header->wr_size +\r\nheader->pmem_size + header->dmem_size) != firmware->size) {\r\nDRM_ERROR("Invalid fmw structure (%d+%d+%d+%d+%d != %d)\n",\r\nsizeof(*header), header->rd_size, header->wr_size,\r\nheader->pmem_size, header->dmem_size,\r\nfirmware->size);\r\ngoto out;\r\n}\r\ndata = (u8 *) firmware->data;\r\ndata += sizeof(*header);\r\nfw_rd_plug = (void *) data;\r\ndata += header->rd_size;\r\nfw_wr_plug = (void *) data;\r\ndata += header->wr_size;\r\nfw_pmem = (void *) data;\r\ndata += header->pmem_size;\r\nfw_dmem = (void *) data;\r\nif (clk_prepare_enable(hqvdp->clk))\r\nDRM_ERROR("Failed to prepare/enable HQVDP clk\n");\r\nwritel(SW_RESET_CTRL_FULL, hqvdp->regs + HQVDP_MBX_SW_RESET_CTRL);\r\nfor (i = 0; i < POLL_MAX_ATTEMPT; i++) {\r\nif (readl(hqvdp->regs + HQVDP_MBX_STARTUP_CTRL1)\r\n& STARTUP_CTRL1_RST_DONE)\r\nbreak;\r\nmsleep(POLL_DELAY_MS);\r\n}\r\nif (i == POLL_MAX_ATTEMPT) {\r\nDRM_ERROR("Could not reset\n");\r\ngoto out;\r\n}\r\nfor (i = 0; i < header->rd_size / 4; i++)\r\nwritel(fw_rd_plug[i], hqvdp->regs + HQVDP_RD_PLUG + i * 4);\r\nfor (i = 0; i < header->wr_size / 4; i++)\r\nwritel(fw_wr_plug[i], hqvdp->regs + HQVDP_WR_PLUG + i * 4);\r\nsti_hqvdp_init_plugs(hqvdp);\r\nwritel(STARTUP_CTRL1_AUTH_IDLE, hqvdp->regs + HQVDP_MBX_STARTUP_CTRL1);\r\nwritel(SOFT_VSYNC_SW_CTRL_IRQ, hqvdp->regs + HQVDP_MBX_SOFT_VSYNC);\r\nwritel(0, hqvdp->regs + HQVDP_MBX_NEXT_CMD);\r\nfor (i = 0; i < header->pmem_size / 4; i++)\r\nwritel(fw_pmem[i], hqvdp->regs + HQVDP_PMEM + i * 4);\r\nfor (i = 0; i < header->dmem_size / 4; i++)\r\nwritel(fw_dmem[i], hqvdp->regs + HQVDP_DMEM + i * 4);\r\nwritel(STARTUP_CTRL2_FETCH_EN, hqvdp->regs + HQVDP_MBX_STARTUP_CTRL2);\r\nfor (i = 0; i < POLL_MAX_ATTEMPT; i++) {\r\nif (readl(hqvdp->regs + HQVDP_MBX_INFO_XP70)\r\n& INFO_XP70_FW_READY)\r\nbreak;\r\nmsleep(POLL_DELAY_MS);\r\n}\r\nif (i == POLL_MAX_ATTEMPT) {\r\nDRM_ERROR("Could not boot\n");\r\ngoto out;\r\n}\r\nwritel(SOFT_VSYNC_HW, hqvdp->regs + HQVDP_MBX_SOFT_VSYNC);\r\nDRM_INFO("HQVDP XP70 started\n");\r\nout:\r\nrelease_firmware(firmware);\r\n}\r\nint sti_hqvdp_bind(struct device *dev, struct device *master, void *data)\r\n{\r\nstruct sti_hqvdp *hqvdp = dev_get_drvdata(dev);\r\nstruct drm_device *drm_dev = data;\r\nstruct sti_layer *layer;\r\nint err;\r\nDRM_DEBUG_DRIVER("\n");\r\nhqvdp->drm_dev = drm_dev;\r\nerr = request_firmware_nowait(THIS_MODULE, FW_ACTION_HOTPLUG,\r\nHQVDP_FMW_NAME, hqvdp->dev,\r\nGFP_KERNEL, hqvdp, sti_hqvdp_start_xp70);\r\nif (err) {\r\nDRM_ERROR("Can't get HQVDP firmware\n");\r\nreturn err;\r\n}\r\nlayer = sti_layer_create(hqvdp->dev, STI_HQVDP_0, hqvdp->regs);\r\nif (!layer) {\r\nDRM_ERROR("Can't create HQVDP plane\n");\r\nreturn -ENOMEM;\r\n}\r\nsti_drm_plane_init(drm_dev, layer, 1, DRM_PLANE_TYPE_OVERLAY);\r\nreturn 0;\r\n}\r\nstatic void sti_hqvdp_unbind(struct device *dev,\r\nstruct device *master, void *data)\r\n{\r\n}\r\nstatic int sti_hqvdp_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct device_node *vtg_np;\r\nstruct sti_hqvdp *hqvdp;\r\nstruct resource *res;\r\nDRM_DEBUG_DRIVER("\n");\r\nhqvdp = devm_kzalloc(dev, sizeof(*hqvdp), GFP_KERNEL);\r\nif (!hqvdp) {\r\nDRM_ERROR("Failed to allocate HQVDP context\n");\r\nreturn -ENOMEM;\r\n}\r\nhqvdp->dev = dev;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (res == NULL) {\r\nDRM_ERROR("Get memory resource failed\n");\r\nreturn -ENXIO;\r\n}\r\nhqvdp->regs = devm_ioremap(dev, res->start, resource_size(res));\r\nif (hqvdp->regs == NULL) {\r\nDRM_ERROR("Register mapping failed\n");\r\nreturn -ENXIO;\r\n}\r\nhqvdp->clk = devm_clk_get(dev, "hqvdp");\r\nhqvdp->clk_pix_main = devm_clk_get(dev, "pix_main");\r\nif (IS_ERR(hqvdp->clk) || IS_ERR(hqvdp->clk_pix_main)) {\r\nDRM_ERROR("Cannot get clocks\n");\r\nreturn -ENXIO;\r\n}\r\nhqvdp->reset = devm_reset_control_get(dev, "hqvdp");\r\nif (!IS_ERR(hqvdp->reset))\r\nreset_control_deassert(hqvdp->reset);\r\nvtg_np = of_parse_phandle(pdev->dev.of_node, "st,vtg", 0);\r\nif (vtg_np)\r\nhqvdp->vtg = of_vtg_find(vtg_np);\r\nplatform_set_drvdata(pdev, hqvdp);\r\nreturn component_add(&pdev->dev, &sti_hqvdp_ops);\r\n}\r\nstatic int sti_hqvdp_remove(struct platform_device *pdev)\r\n{\r\ncomponent_del(&pdev->dev, &sti_hqvdp_ops);\r\nreturn 0;\r\n}
