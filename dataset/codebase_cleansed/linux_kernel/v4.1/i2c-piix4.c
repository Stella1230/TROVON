static int piix4_setup(struct pci_dev *PIIX4_dev,\r\nconst struct pci_device_id *id)\r\n{\r\nunsigned char temp;\r\nunsigned short piix4_smba;\r\nif ((PIIX4_dev->vendor == PCI_VENDOR_ID_SERVERWORKS) &&\r\n(PIIX4_dev->device == PCI_DEVICE_ID_SERVERWORKS_CSB5))\r\nsrvrworks_csb5_delay = 1;\r\nif (dmi_check_system(piix4_dmi_blacklist)) {\r\ndev_err(&PIIX4_dev->dev,\r\n"Accessing the SMBus on this system is unsafe!\n");\r\nreturn -EPERM;\r\n}\r\nif (dmi_check_system(piix4_dmi_ibm) &&\r\nPIIX4_dev->vendor == PCI_VENDOR_ID_INTEL) {\r\ndev_err(&PIIX4_dev->dev, "IBM system detected; this module "\r\n"may corrupt your serial eeprom! Refusing to load "\r\n"module!\n");\r\nreturn -EPERM;\r\n}\r\nif (force_addr) {\r\npiix4_smba = force_addr & 0xfff0;\r\nforce = 0;\r\n} else {\r\npci_read_config_word(PIIX4_dev, SMBBA, &piix4_smba);\r\npiix4_smba &= 0xfff0;\r\nif(piix4_smba == 0) {\r\ndev_err(&PIIX4_dev->dev, "SMBus base address "\r\n"uninitialized - upgrade BIOS or use "\r\n"force_addr=0xaddr\n");\r\nreturn -ENODEV;\r\n}\r\n}\r\nif (acpi_check_region(piix4_smba, SMBIOSIZE, piix4_driver.name))\r\nreturn -ENODEV;\r\nif (!request_region(piix4_smba, SMBIOSIZE, piix4_driver.name)) {\r\ndev_err(&PIIX4_dev->dev, "SMBus region 0x%x already in use!\n",\r\npiix4_smba);\r\nreturn -EBUSY;\r\n}\r\npci_read_config_byte(PIIX4_dev, SMBHSTCFG, &temp);\r\nif (force_addr) {\r\npci_write_config_byte(PIIX4_dev, SMBHSTCFG, temp & 0xfe);\r\npci_write_config_word(PIIX4_dev, SMBBA, piix4_smba);\r\npci_write_config_byte(PIIX4_dev, SMBHSTCFG, temp | 0x01);\r\ndev_info(&PIIX4_dev->dev, "WARNING: SMBus interface set to "\r\n"new address %04x!\n", piix4_smba);\r\n} else if ((temp & 1) == 0) {\r\nif (force) {\r\npci_write_config_byte(PIIX4_dev, SMBHSTCFG,\r\ntemp | 1);\r\ndev_notice(&PIIX4_dev->dev,\r\n"WARNING: SMBus interface has been FORCEFULLY ENABLED!\n");\r\n} else {\r\ndev_err(&PIIX4_dev->dev,\r\n"SMBus Host Controller not enabled!\n");\r\nrelease_region(piix4_smba, SMBIOSIZE);\r\nreturn -ENODEV;\r\n}\r\n}\r\nif (((temp & 0x0E) == 8) || ((temp & 0x0E) == 2))\r\ndev_dbg(&PIIX4_dev->dev, "Using IRQ for SMBus\n");\r\nelse if ((temp & 0x0E) == 0)\r\ndev_dbg(&PIIX4_dev->dev, "Using SMI# for SMBus\n");\r\nelse\r\ndev_err(&PIIX4_dev->dev, "Illegal Interrupt configuration "\r\n"(or code out of date)!\n");\r\npci_read_config_byte(PIIX4_dev, SMBREV, &temp);\r\ndev_info(&PIIX4_dev->dev,\r\n"SMBus Host Controller at 0x%x, revision %d\n",\r\npiix4_smba, temp);\r\nreturn piix4_smba;\r\n}\r\nstatic int piix4_setup_sb800(struct pci_dev *PIIX4_dev,\r\nconst struct pci_device_id *id, u8 aux)\r\n{\r\nunsigned short piix4_smba;\r\nunsigned short smba_idx = 0xcd6;\r\nu8 smba_en_lo, smba_en_hi, smb_en, smb_en_status;\r\nu8 i2ccfg, i2ccfg_offset = 0x10;\r\nif (force || force_addr) {\r\ndev_err(&PIIX4_dev->dev, "SMBus does not support "\r\n"forcing address!\n");\r\nreturn -EINVAL;\r\n}\r\nif ((PIIX4_dev->vendor == PCI_VENDOR_ID_AMD &&\r\nPIIX4_dev->device == PCI_DEVICE_ID_AMD_HUDSON2_SMBUS &&\r\nPIIX4_dev->revision >= 0x41) ||\r\n(PIIX4_dev->vendor == PCI_VENDOR_ID_AMD &&\r\nPIIX4_dev->device == 0x790b &&\r\nPIIX4_dev->revision >= 0x49))\r\nsmb_en = 0x00;\r\nelse\r\nsmb_en = (aux) ? 0x28 : 0x2c;\r\nif (!request_region(smba_idx, 2, "smba_idx")) {\r\ndev_err(&PIIX4_dev->dev, "SMBus base address index region "\r\n"0x%x already in use!\n", smba_idx);\r\nreturn -EBUSY;\r\n}\r\noutb_p(smb_en, smba_idx);\r\nsmba_en_lo = inb_p(smba_idx + 1);\r\noutb_p(smb_en + 1, smba_idx);\r\nsmba_en_hi = inb_p(smba_idx + 1);\r\nrelease_region(smba_idx, 2);\r\nif (!smb_en) {\r\nsmb_en_status = smba_en_lo & 0x10;\r\npiix4_smba = smba_en_hi << 8;\r\nif (aux)\r\npiix4_smba |= 0x20;\r\n} else {\r\nsmb_en_status = smba_en_lo & 0x01;\r\npiix4_smba = ((smba_en_hi << 8) | smba_en_lo) & 0xffe0;\r\n}\r\nif (!smb_en_status) {\r\ndev_err(&PIIX4_dev->dev,\r\n"SMBus Host Controller not enabled!\n");\r\nreturn -ENODEV;\r\n}\r\nif (acpi_check_region(piix4_smba, SMBIOSIZE, piix4_driver.name))\r\nreturn -ENODEV;\r\nif (!request_region(piix4_smba, SMBIOSIZE, piix4_driver.name)) {\r\ndev_err(&PIIX4_dev->dev, "SMBus region 0x%x already in use!\n",\r\npiix4_smba);\r\nreturn -EBUSY;\r\n}\r\nif (aux) {\r\ndev_info(&PIIX4_dev->dev,\r\n"Auxiliary SMBus Host Controller at 0x%x\n",\r\npiix4_smba);\r\nreturn piix4_smba;\r\n}\r\nif (!request_region(piix4_smba + i2ccfg_offset, 1, "i2ccfg")) {\r\ndev_err(&PIIX4_dev->dev, "SMBus I2C bus config region "\r\n"0x%x already in use!\n", piix4_smba + i2ccfg_offset);\r\nrelease_region(piix4_smba, SMBIOSIZE);\r\nreturn -EBUSY;\r\n}\r\ni2ccfg = inb_p(piix4_smba + i2ccfg_offset);\r\nrelease_region(piix4_smba + i2ccfg_offset, 1);\r\nif (i2ccfg & 1)\r\ndev_dbg(&PIIX4_dev->dev, "Using IRQ for SMBus\n");\r\nelse\r\ndev_dbg(&PIIX4_dev->dev, "Using SMI# for SMBus\n");\r\ndev_info(&PIIX4_dev->dev,\r\n"SMBus Host Controller at 0x%x, revision %d\n",\r\npiix4_smba, i2ccfg >> 4);\r\nreturn piix4_smba;\r\n}\r\nstatic int piix4_setup_aux(struct pci_dev *PIIX4_dev,\r\nconst struct pci_device_id *id,\r\nunsigned short base_reg_addr)\r\n{\r\nunsigned short piix4_smba;\r\npci_read_config_word(PIIX4_dev, base_reg_addr, &piix4_smba);\r\nif ((piix4_smba & 1) == 0) {\r\ndev_dbg(&PIIX4_dev->dev,\r\n"Auxiliary SMBus controller not enabled\n");\r\nreturn -ENODEV;\r\n}\r\npiix4_smba &= 0xfff0;\r\nif (piix4_smba == 0) {\r\ndev_dbg(&PIIX4_dev->dev,\r\n"Auxiliary SMBus base address uninitialized\n");\r\nreturn -ENODEV;\r\n}\r\nif (acpi_check_region(piix4_smba, SMBIOSIZE, piix4_driver.name))\r\nreturn -ENODEV;\r\nif (!request_region(piix4_smba, SMBIOSIZE, piix4_driver.name)) {\r\ndev_err(&PIIX4_dev->dev, "Auxiliary SMBus region 0x%x "\r\n"already in use!\n", piix4_smba);\r\nreturn -EBUSY;\r\n}\r\ndev_info(&PIIX4_dev->dev,\r\n"Auxiliary SMBus Host Controller at 0x%x\n",\r\npiix4_smba);\r\nreturn piix4_smba;\r\n}\r\nstatic int piix4_transaction(struct i2c_adapter *piix4_adapter)\r\n{\r\nstruct i2c_piix4_adapdata *adapdata = i2c_get_adapdata(piix4_adapter);\r\nunsigned short piix4_smba = adapdata->smba;\r\nint temp;\r\nint result = 0;\r\nint timeout = 0;\r\ndev_dbg(&piix4_adapter->dev, "Transaction (pre): CNT=%02x, CMD=%02x, "\r\n"ADD=%02x, DAT0=%02x, DAT1=%02x\n", inb_p(SMBHSTCNT),\r\ninb_p(SMBHSTCMD), inb_p(SMBHSTADD), inb_p(SMBHSTDAT0),\r\ninb_p(SMBHSTDAT1));\r\nif ((temp = inb_p(SMBHSTSTS)) != 0x00) {\r\ndev_dbg(&piix4_adapter->dev, "SMBus busy (%02x). "\r\n"Resetting...\n", temp);\r\noutb_p(temp, SMBHSTSTS);\r\nif ((temp = inb_p(SMBHSTSTS)) != 0x00) {\r\ndev_err(&piix4_adapter->dev, "Failed! (%02x)\n", temp);\r\nreturn -EBUSY;\r\n} else {\r\ndev_dbg(&piix4_adapter->dev, "Successful!\n");\r\n}\r\n}\r\noutb_p(inb(SMBHSTCNT) | 0x040, SMBHSTCNT);\r\nif (srvrworks_csb5_delay)\r\nmsleep(2);\r\nelse\r\nmsleep(1);\r\nwhile ((++timeout < MAX_TIMEOUT) &&\r\n((temp = inb_p(SMBHSTSTS)) & 0x01))\r\nmsleep(1);\r\nif (timeout == MAX_TIMEOUT) {\r\ndev_err(&piix4_adapter->dev, "SMBus Timeout!\n");\r\nresult = -ETIMEDOUT;\r\n}\r\nif (temp & 0x10) {\r\nresult = -EIO;\r\ndev_err(&piix4_adapter->dev, "Error: Failed bus transaction\n");\r\n}\r\nif (temp & 0x08) {\r\nresult = -EIO;\r\ndev_dbg(&piix4_adapter->dev, "Bus collision! SMBus may be "\r\n"locked until next hard reset. (sorry!)\n");\r\n}\r\nif (temp & 0x04) {\r\nresult = -ENXIO;\r\ndev_dbg(&piix4_adapter->dev, "Error: no response!\n");\r\n}\r\nif (inb_p(SMBHSTSTS) != 0x00)\r\noutb_p(inb(SMBHSTSTS), SMBHSTSTS);\r\nif ((temp = inb_p(SMBHSTSTS)) != 0x00) {\r\ndev_err(&piix4_adapter->dev, "Failed reset at end of "\r\n"transaction (%02x)\n", temp);\r\n}\r\ndev_dbg(&piix4_adapter->dev, "Transaction (post): CNT=%02x, CMD=%02x, "\r\n"ADD=%02x, DAT0=%02x, DAT1=%02x\n", inb_p(SMBHSTCNT),\r\ninb_p(SMBHSTCMD), inb_p(SMBHSTADD), inb_p(SMBHSTDAT0),\r\ninb_p(SMBHSTDAT1));\r\nreturn result;\r\n}\r\nstatic s32 piix4_access(struct i2c_adapter * adap, u16 addr,\r\nunsigned short flags, char read_write,\r\nu8 command, int size, union i2c_smbus_data * data)\r\n{\r\nstruct i2c_piix4_adapdata *adapdata = i2c_get_adapdata(adap);\r\nunsigned short piix4_smba = adapdata->smba;\r\nint i, len;\r\nint status;\r\nswitch (size) {\r\ncase I2C_SMBUS_QUICK:\r\noutb_p((addr << 1) | read_write,\r\nSMBHSTADD);\r\nsize = PIIX4_QUICK;\r\nbreak;\r\ncase I2C_SMBUS_BYTE:\r\noutb_p((addr << 1) | read_write,\r\nSMBHSTADD);\r\nif (read_write == I2C_SMBUS_WRITE)\r\noutb_p(command, SMBHSTCMD);\r\nsize = PIIX4_BYTE;\r\nbreak;\r\ncase I2C_SMBUS_BYTE_DATA:\r\noutb_p((addr << 1) | read_write,\r\nSMBHSTADD);\r\noutb_p(command, SMBHSTCMD);\r\nif (read_write == I2C_SMBUS_WRITE)\r\noutb_p(data->byte, SMBHSTDAT0);\r\nsize = PIIX4_BYTE_DATA;\r\nbreak;\r\ncase I2C_SMBUS_WORD_DATA:\r\noutb_p((addr << 1) | read_write,\r\nSMBHSTADD);\r\noutb_p(command, SMBHSTCMD);\r\nif (read_write == I2C_SMBUS_WRITE) {\r\noutb_p(data->word & 0xff, SMBHSTDAT0);\r\noutb_p((data->word & 0xff00) >> 8, SMBHSTDAT1);\r\n}\r\nsize = PIIX4_WORD_DATA;\r\nbreak;\r\ncase I2C_SMBUS_BLOCK_DATA:\r\noutb_p((addr << 1) | read_write,\r\nSMBHSTADD);\r\noutb_p(command, SMBHSTCMD);\r\nif (read_write == I2C_SMBUS_WRITE) {\r\nlen = data->block[0];\r\nif (len == 0 || len > I2C_SMBUS_BLOCK_MAX)\r\nreturn -EINVAL;\r\noutb_p(len, SMBHSTDAT0);\r\ni = inb_p(SMBHSTCNT);\r\nfor (i = 1; i <= len; i++)\r\noutb_p(data->block[i], SMBBLKDAT);\r\n}\r\nsize = PIIX4_BLOCK_DATA;\r\nbreak;\r\ndefault:\r\ndev_warn(&adap->dev, "Unsupported transaction %d\n", size);\r\nreturn -EOPNOTSUPP;\r\n}\r\noutb_p((size & 0x1C) + (ENABLE_INT9 & 1), SMBHSTCNT);\r\nstatus = piix4_transaction(adap);\r\nif (status)\r\nreturn status;\r\nif ((read_write == I2C_SMBUS_WRITE) || (size == PIIX4_QUICK))\r\nreturn 0;\r\nswitch (size) {\r\ncase PIIX4_BYTE:\r\ncase PIIX4_BYTE_DATA:\r\ndata->byte = inb_p(SMBHSTDAT0);\r\nbreak;\r\ncase PIIX4_WORD_DATA:\r\ndata->word = inb_p(SMBHSTDAT0) + (inb_p(SMBHSTDAT1) << 8);\r\nbreak;\r\ncase PIIX4_BLOCK_DATA:\r\ndata->block[0] = inb_p(SMBHSTDAT0);\r\nif (data->block[0] == 0 || data->block[0] > I2C_SMBUS_BLOCK_MAX)\r\nreturn -EPROTO;\r\ni = inb_p(SMBHSTCNT);\r\nfor (i = 1; i <= data->block[0]; i++)\r\ndata->block[i] = inb_p(SMBBLKDAT);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic u32 piix4_func(struct i2c_adapter *adapter)\r\n{\r\nreturn I2C_FUNC_SMBUS_QUICK | I2C_FUNC_SMBUS_BYTE |\r\nI2C_FUNC_SMBUS_BYTE_DATA | I2C_FUNC_SMBUS_WORD_DATA |\r\nI2C_FUNC_SMBUS_BLOCK_DATA;\r\n}\r\nstatic int piix4_add_adapter(struct pci_dev *dev, unsigned short smba,\r\nstruct i2c_adapter **padap)\r\n{\r\nstruct i2c_adapter *adap;\r\nstruct i2c_piix4_adapdata *adapdata;\r\nint retval;\r\nadap = kzalloc(sizeof(*adap), GFP_KERNEL);\r\nif (adap == NULL) {\r\nrelease_region(smba, SMBIOSIZE);\r\nreturn -ENOMEM;\r\n}\r\nadap->owner = THIS_MODULE;\r\nadap->class = I2C_CLASS_HWMON | I2C_CLASS_SPD;\r\nadap->algo = &smbus_algorithm;\r\nadapdata = kzalloc(sizeof(*adapdata), GFP_KERNEL);\r\nif (adapdata == NULL) {\r\nkfree(adap);\r\nrelease_region(smba, SMBIOSIZE);\r\nreturn -ENOMEM;\r\n}\r\nadapdata->smba = smba;\r\nadap->dev.parent = &dev->dev;\r\nsnprintf(adap->name, sizeof(adap->name),\r\n"SMBus PIIX4 adapter at %04x", smba);\r\ni2c_set_adapdata(adap, adapdata);\r\nretval = i2c_add_adapter(adap);\r\nif (retval) {\r\ndev_err(&dev->dev, "Couldn't register adapter!\n");\r\nkfree(adapdata);\r\nkfree(adap);\r\nrelease_region(smba, SMBIOSIZE);\r\nreturn retval;\r\n}\r\n*padap = adap;\r\nreturn 0;\r\n}\r\nstatic int piix4_probe(struct pci_dev *dev, const struct pci_device_id *id)\r\n{\r\nint retval;\r\nif ((dev->vendor == PCI_VENDOR_ID_ATI &&\r\ndev->device == PCI_DEVICE_ID_ATI_SBX00_SMBUS &&\r\ndev->revision >= 0x40) ||\r\ndev->vendor == PCI_VENDOR_ID_AMD)\r\nretval = piix4_setup_sb800(dev, id, 0);\r\nelse\r\nretval = piix4_setup(dev, id);\r\nif (retval < 0)\r\nreturn retval;\r\nretval = piix4_add_adapter(dev, retval, &piix4_main_adapter);\r\nif (retval < 0)\r\nreturn retval;\r\nretval = -ENODEV;\r\nif (dev->vendor == PCI_VENDOR_ID_ATI &&\r\ndev->device == PCI_DEVICE_ID_ATI_SBX00_SMBUS) {\r\nif (dev->revision < 0x40) {\r\nretval = piix4_setup_aux(dev, id, 0x58);\r\n} else {\r\nretval = piix4_setup_sb800(dev, id, 1);\r\n}\r\n}\r\nif (dev->vendor == PCI_VENDOR_ID_AMD &&\r\ndev->device == PCI_DEVICE_ID_AMD_HUDSON2_SMBUS) {\r\nretval = piix4_setup_sb800(dev, id, 1);\r\n}\r\nif (retval > 0) {\r\npiix4_add_adapter(dev, retval, &piix4_aux_adapter);\r\n}\r\nreturn 0;\r\n}\r\nstatic void piix4_adap_remove(struct i2c_adapter *adap)\r\n{\r\nstruct i2c_piix4_adapdata *adapdata = i2c_get_adapdata(adap);\r\nif (adapdata->smba) {\r\ni2c_del_adapter(adap);\r\nrelease_region(adapdata->smba, SMBIOSIZE);\r\nkfree(adapdata);\r\nkfree(adap);\r\n}\r\n}\r\nstatic void piix4_remove(struct pci_dev *dev)\r\n{\r\nif (piix4_main_adapter) {\r\npiix4_adap_remove(piix4_main_adapter);\r\npiix4_main_adapter = NULL;\r\n}\r\nif (piix4_aux_adapter) {\r\npiix4_adap_remove(piix4_aux_adapter);\r\npiix4_aux_adapter = NULL;\r\n}\r\n}
