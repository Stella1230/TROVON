static void transmit_chars_putchar(struct uart_port *port, struct circ_buf *xmit)\r\n{\r\nwhile (!uart_circ_empty(xmit)) {\r\nlong status = sun4v_con_putchar(xmit->buf[xmit->tail]);\r\nif (status != HV_EOK)\r\nbreak;\r\nxmit->tail = (xmit->tail + 1) & (UART_XMIT_SIZE - 1);\r\nport->icount.tx++;\r\n}\r\n}\r\nstatic void transmit_chars_write(struct uart_port *port, struct circ_buf *xmit)\r\n{\r\nwhile (!uart_circ_empty(xmit)) {\r\nunsigned long ra = __pa(xmit->buf + xmit->tail);\r\nunsigned long len, status, sent;\r\nlen = CIRC_CNT_TO_END(xmit->head, xmit->tail,\r\nUART_XMIT_SIZE);\r\nstatus = sun4v_con_write(ra, len, &sent);\r\nif (status != HV_EOK)\r\nbreak;\r\nxmit->tail = (xmit->tail + sent) & (UART_XMIT_SIZE - 1);\r\nport->icount.tx += sent;\r\n}\r\n}\r\nstatic int receive_chars_getchar(struct uart_port *port)\r\n{\r\nint saw_console_brk = 0;\r\nint limit = 10000;\r\nwhile (limit-- > 0) {\r\nlong status;\r\nlong c = sun4v_con_getchar(&status);\r\nif (status == HV_EWOULDBLOCK)\r\nbreak;\r\nif (c == CON_BREAK) {\r\nif (uart_handle_break(port))\r\ncontinue;\r\nsaw_console_brk = 1;\r\nc = 0;\r\n}\r\nif (c == CON_HUP) {\r\nhung_up = 1;\r\nuart_handle_dcd_change(port, 0);\r\n} else if (hung_up) {\r\nhung_up = 0;\r\nuart_handle_dcd_change(port, 1);\r\n}\r\nif (port->state == NULL) {\r\nuart_handle_sysrq_char(port, c);\r\ncontinue;\r\n}\r\nport->icount.rx++;\r\nif (uart_handle_sysrq_char(port, c))\r\ncontinue;\r\ntty_insert_flip_char(&port->state->port, c, TTY_NORMAL);\r\n}\r\nreturn saw_console_brk;\r\n}\r\nstatic int receive_chars_read(struct uart_port *port)\r\n{\r\nint saw_console_brk = 0;\r\nint limit = 10000;\r\nwhile (limit-- > 0) {\r\nunsigned long ra = __pa(con_read_page);\r\nunsigned long bytes_read, i;\r\nlong stat = sun4v_con_read(ra, PAGE_SIZE, &bytes_read);\r\nif (stat != HV_EOK) {\r\nbytes_read = 0;\r\nif (stat == CON_BREAK) {\r\nif (uart_handle_break(port))\r\ncontinue;\r\nsaw_console_brk = 1;\r\n*con_read_page = 0;\r\nbytes_read = 1;\r\n} else if (stat == CON_HUP) {\r\nhung_up = 1;\r\nuart_handle_dcd_change(port, 0);\r\ncontinue;\r\n} else {\r\nbreak;\r\n}\r\n}\r\nif (hung_up) {\r\nhung_up = 0;\r\nuart_handle_dcd_change(port, 1);\r\n}\r\nfor (i = 0; i < bytes_read; i++)\r\nuart_handle_sysrq_char(port, con_read_page[i]);\r\nif (port->state == NULL)\r\ncontinue;\r\nport->icount.rx += bytes_read;\r\ntty_insert_flip_string(&port->state->port, con_read_page,\r\nbytes_read);\r\n}\r\nreturn saw_console_brk;\r\n}\r\nstatic struct tty_port *receive_chars(struct uart_port *port)\r\n{\r\nstruct tty_port *tport = NULL;\r\nif (port->state != NULL)\r\ntport = &port->state->port;\r\nif (sunhv_ops->receive_chars(port))\r\nsun_do_break();\r\nreturn tport;\r\n}\r\nstatic void transmit_chars(struct uart_port *port)\r\n{\r\nstruct circ_buf *xmit;\r\nif (!port->state)\r\nreturn;\r\nxmit = &port->state->xmit;\r\nif (uart_circ_empty(xmit) || uart_tx_stopped(port))\r\nreturn;\r\nsunhv_ops->transmit_chars(port, xmit);\r\nif (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)\r\nuart_write_wakeup(port);\r\n}\r\nstatic irqreturn_t sunhv_interrupt(int irq, void *dev_id)\r\n{\r\nstruct uart_port *port = dev_id;\r\nstruct tty_port *tport;\r\nunsigned long flags;\r\nspin_lock_irqsave(&port->lock, flags);\r\ntport = receive_chars(port);\r\ntransmit_chars(port);\r\nspin_unlock_irqrestore(&port->lock, flags);\r\nif (tport)\r\ntty_flip_buffer_push(tport);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic unsigned int sunhv_tx_empty(struct uart_port *port)\r\n{\r\nreturn TIOCSER_TEMT;\r\n}\r\nstatic void sunhv_set_mctrl(struct uart_port *port, unsigned int mctrl)\r\n{\r\nreturn;\r\n}\r\nstatic unsigned int sunhv_get_mctrl(struct uart_port *port)\r\n{\r\nreturn TIOCM_DSR | TIOCM_CAR | TIOCM_CTS;\r\n}\r\nstatic void sunhv_stop_tx(struct uart_port *port)\r\n{\r\nreturn;\r\n}\r\nstatic void sunhv_start_tx(struct uart_port *port)\r\n{\r\ntransmit_chars(port);\r\n}\r\nstatic void sunhv_send_xchar(struct uart_port *port, char ch)\r\n{\r\nunsigned long flags;\r\nint limit = 10000;\r\nif (ch == __DISABLED_CHAR)\r\nreturn;\r\nspin_lock_irqsave(&port->lock, flags);\r\nwhile (limit-- > 0) {\r\nlong status = sun4v_con_putchar(ch);\r\nif (status == HV_EOK)\r\nbreak;\r\nudelay(1);\r\n}\r\nspin_unlock_irqrestore(&port->lock, flags);\r\n}\r\nstatic void sunhv_stop_rx(struct uart_port *port)\r\n{\r\n}\r\nstatic void sunhv_break_ctl(struct uart_port *port, int break_state)\r\n{\r\nif (break_state) {\r\nunsigned long flags;\r\nint limit = 10000;\r\nspin_lock_irqsave(&port->lock, flags);\r\nwhile (limit-- > 0) {\r\nlong status = sun4v_con_putchar(CON_BREAK);\r\nif (status == HV_EOK)\r\nbreak;\r\nudelay(1);\r\n}\r\nspin_unlock_irqrestore(&port->lock, flags);\r\n}\r\n}\r\nstatic int sunhv_startup(struct uart_port *port)\r\n{\r\nreturn 0;\r\n}\r\nstatic void sunhv_shutdown(struct uart_port *port)\r\n{\r\n}\r\nstatic void sunhv_set_termios(struct uart_port *port, struct ktermios *termios,\r\nstruct ktermios *old)\r\n{\r\nunsigned int baud = uart_get_baud_rate(port, termios, old, 0, 4000000);\r\nunsigned int quot = uart_get_divisor(port, baud);\r\nunsigned int iflag, cflag;\r\nunsigned long flags;\r\nspin_lock_irqsave(&port->lock, flags);\r\niflag = termios->c_iflag;\r\ncflag = termios->c_cflag;\r\nport->ignore_status_mask = 0;\r\nif (iflag & IGNBRK)\r\nport->ignore_status_mask |= IGNORE_BREAK;\r\nif ((cflag & CREAD) == 0)\r\nport->ignore_status_mask |= IGNORE_ALL;\r\nuart_update_timeout(port, cflag,\r\n(port->uartclk / (16 * quot)));\r\nspin_unlock_irqrestore(&port->lock, flags);\r\n}\r\nstatic const char *sunhv_type(struct uart_port *port)\r\n{\r\nreturn "SUN4V HCONS";\r\n}\r\nstatic void sunhv_release_port(struct uart_port *port)\r\n{\r\n}\r\nstatic int sunhv_request_port(struct uart_port *port)\r\n{\r\nreturn 0;\r\n}\r\nstatic void sunhv_config_port(struct uart_port *port, int flags)\r\n{\r\n}\r\nstatic int sunhv_verify_port(struct uart_port *port, struct serial_struct *ser)\r\n{\r\nreturn -EINVAL;\r\n}\r\nstatic int fill_con_write_page(const char *s, unsigned int n,\r\nunsigned long *page_bytes)\r\n{\r\nconst char *orig_s = s;\r\nchar *p = con_write_page;\r\nint left = PAGE_SIZE;\r\nwhile (n--) {\r\nif (*s == '\n') {\r\nif (left < 2)\r\nbreak;\r\n*p++ = '\r';\r\nleft--;\r\n} else if (left < 1)\r\nbreak;\r\n*p++ = *s++;\r\nleft--;\r\n}\r\n*page_bytes = p - con_write_page;\r\nreturn s - orig_s;\r\n}\r\nstatic void sunhv_console_write_paged(struct console *con, const char *s, unsigned n)\r\n{\r\nstruct uart_port *port = sunhv_port;\r\nunsigned long flags;\r\nint locked = 1;\r\nif (port->sysrq || oops_in_progress)\r\nlocked = spin_trylock_irqsave(&port->lock, flags);\r\nelse\r\nspin_lock_irqsave(&port->lock, flags);\r\nwhile (n > 0) {\r\nunsigned long ra = __pa(con_write_page);\r\nunsigned long page_bytes;\r\nunsigned int cpy = fill_con_write_page(s, n,\r\n&page_bytes);\r\nn -= cpy;\r\ns += cpy;\r\nwhile (page_bytes > 0) {\r\nunsigned long written;\r\nint limit = 1000000;\r\nwhile (limit--) {\r\nunsigned long stat;\r\nstat = sun4v_con_write(ra, page_bytes,\r\n&written);\r\nif (stat == HV_EOK)\r\nbreak;\r\nudelay(1);\r\n}\r\nif (limit < 0)\r\nbreak;\r\npage_bytes -= written;\r\nra += written;\r\n}\r\n}\r\nif (locked)\r\nspin_unlock_irqrestore(&port->lock, flags);\r\n}\r\nstatic inline void sunhv_console_putchar(struct uart_port *port, char c)\r\n{\r\nint limit = 1000000;\r\nwhile (limit-- > 0) {\r\nlong status = sun4v_con_putchar(c);\r\nif (status == HV_EOK)\r\nbreak;\r\nudelay(1);\r\n}\r\n}\r\nstatic void sunhv_console_write_bychar(struct console *con, const char *s, unsigned n)\r\n{\r\nstruct uart_port *port = sunhv_port;\r\nunsigned long flags;\r\nint i, locked = 1;\r\nif (port->sysrq || oops_in_progress)\r\nlocked = spin_trylock_irqsave(&port->lock, flags);\r\nelse\r\nspin_lock_irqsave(&port->lock, flags);\r\nif (port->sysrq) {\r\nlocked = 0;\r\n} else if (oops_in_progress) {\r\nlocked = spin_trylock(&port->lock);\r\n} else\r\nspin_lock(&port->lock);\r\nfor (i = 0; i < n; i++) {\r\nif (*s == '\n')\r\nsunhv_console_putchar(port, '\r');\r\nsunhv_console_putchar(port, *s++);\r\n}\r\nif (locked)\r\nspin_unlock_irqrestore(&port->lock, flags);\r\n}\r\nstatic int hv_probe(struct platform_device *op)\r\n{\r\nstruct uart_port *port;\r\nunsigned long minor;\r\nint err;\r\nif (op->archdata.irqs[0] == 0xffffffff)\r\nreturn -ENODEV;\r\nport = kzalloc(sizeof(struct uart_port), GFP_KERNEL);\r\nif (unlikely(!port))\r\nreturn -ENOMEM;\r\nminor = 1;\r\nif (sun4v_hvapi_register(HV_GRP_CORE, 1, &minor) == 0 &&\r\nminor >= 1) {\r\nerr = -ENOMEM;\r\ncon_write_page = kzalloc(PAGE_SIZE, GFP_KERNEL);\r\nif (!con_write_page)\r\ngoto out_free_port;\r\ncon_read_page = kzalloc(PAGE_SIZE, GFP_KERNEL);\r\nif (!con_read_page)\r\ngoto out_free_con_write_page;\r\nsunhv_console.write = sunhv_console_write_paged;\r\nsunhv_ops = &bywrite_ops;\r\n}\r\nsunhv_port = port;\r\nport->line = 0;\r\nport->ops = &sunhv_pops;\r\nport->type = PORT_SUNHV;\r\nport->uartclk = ( 29491200 / 16 );\r\nport->membase = (unsigned char __iomem *) __pa(port);\r\nport->irq = op->archdata.irqs[0];\r\nport->dev = &op->dev;\r\nerr = sunserial_register_minors(&sunhv_reg, 1);\r\nif (err)\r\ngoto out_free_con_read_page;\r\nsunserial_console_match(&sunhv_console, op->dev.of_node,\r\n&sunhv_reg, port->line, false);\r\nerr = uart_add_one_port(&sunhv_reg, port);\r\nif (err)\r\ngoto out_unregister_driver;\r\nerr = request_irq(port->irq, sunhv_interrupt, 0, "hvcons", port);\r\nif (err)\r\ngoto out_remove_port;\r\nplatform_set_drvdata(op, port);\r\nreturn 0;\r\nout_remove_port:\r\nuart_remove_one_port(&sunhv_reg, port);\r\nout_unregister_driver:\r\nsunserial_unregister_minors(&sunhv_reg, 1);\r\nout_free_con_read_page:\r\nkfree(con_read_page);\r\nout_free_con_write_page:\r\nkfree(con_write_page);\r\nout_free_port:\r\nkfree(port);\r\nsunhv_port = NULL;\r\nreturn err;\r\n}\r\nstatic int hv_remove(struct platform_device *dev)\r\n{\r\nstruct uart_port *port = platform_get_drvdata(dev);\r\nfree_irq(port->irq, port);\r\nuart_remove_one_port(&sunhv_reg, port);\r\nsunserial_unregister_minors(&sunhv_reg, 1);\r\nkfree(port);\r\nsunhv_port = NULL;\r\nreturn 0;\r\n}\r\nstatic int __init sunhv_init(void)\r\n{\r\nif (tlb_type != hypervisor)\r\nreturn -ENODEV;\r\nreturn platform_driver_register(&hv_driver);\r\n}\r\nstatic void __exit sunhv_exit(void)\r\n{\r\nplatform_driver_unregister(&hv_driver);\r\n}
