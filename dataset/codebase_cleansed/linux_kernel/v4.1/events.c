void request_out_callback(lnet_event_t *ev)\r\n{\r\nstruct ptlrpc_cb_id *cbid = ev->md.user_ptr;\r\nstruct ptlrpc_request *req = cbid->cbid_arg;\r\nLASSERT(ev->type == LNET_EVENT_SEND ||\r\nev->type == LNET_EVENT_UNLINK);\r\nLASSERT(ev->unlinked);\r\nDEBUG_REQ(D_NET, req, "type %d, status %d", ev->type, ev->status);\r\nsptlrpc_request_out_callback(req);\r\nspin_lock(&req->rq_lock);\r\nreq->rq_real_sent = get_seconds();\r\nif (ev->unlinked)\r\nreq->rq_req_unlink = 0;\r\nif (ev->type == LNET_EVENT_UNLINK || ev->status != 0) {\r\nreq->rq_net_err = 1;\r\nptlrpc_client_wake_req(req);\r\n}\r\nspin_unlock(&req->rq_lock);\r\nptlrpc_req_finished(req);\r\n}\r\nvoid reply_in_callback(lnet_event_t *ev)\r\n{\r\nstruct ptlrpc_cb_id *cbid = ev->md.user_ptr;\r\nstruct ptlrpc_request *req = cbid->cbid_arg;\r\nDEBUG_REQ(D_NET, req, "type %d, status %d", ev->type, ev->status);\r\nLASSERT(ev->type == LNET_EVENT_PUT || ev->type == LNET_EVENT_UNLINK);\r\nLASSERT(ev->md.start == req->rq_repbuf);\r\nLASSERT(ev->offset + ev->mlength <= req->rq_repbuf_len);\r\nLASSERT((ev->md.options & LNET_MD_MANAGE_REMOTE) != 0);\r\nspin_lock(&req->rq_lock);\r\nreq->rq_receiving_reply = 0;\r\nreq->rq_early = 0;\r\nif (ev->unlinked)\r\nreq->rq_reply_unlink = 0;\r\nif (ev->status)\r\ngoto out_wake;\r\nif (ev->type == LNET_EVENT_UNLINK) {\r\nLASSERT(ev->unlinked);\r\nDEBUG_REQ(D_NET, req, "unlink");\r\ngoto out_wake;\r\n}\r\nif (ev->mlength < ev->rlength) {\r\nCDEBUG(D_RPCTRACE, "truncate req %p rpc %d - %d+%d\n", req,\r\nreq->rq_replen, ev->rlength, ev->offset);\r\nreq->rq_reply_truncate = 1;\r\nreq->rq_replied = 1;\r\nreq->rq_status = -EOVERFLOW;\r\nreq->rq_nob_received = ev->rlength + ev->offset;\r\ngoto out_wake;\r\n}\r\nif ((ev->offset == 0) &&\r\n((lustre_msghdr_get_flags(req->rq_reqmsg) & MSGHDR_AT_SUPPORT))) {\r\nDEBUG_REQ(D_ADAPTTO, req,\r\n"Early reply received: mlen=%u offset=%d replen=%d replied=%d unlinked=%d",\r\nev->mlength, ev->offset,\r\nreq->rq_replen, req->rq_replied, ev->unlinked);\r\nreq->rq_early_count++;\r\nif (req->rq_replied)\r\ngoto out_wake;\r\nreq->rq_early = 1;\r\nreq->rq_reply_off = ev->offset;\r\nreq->rq_nob_received = ev->mlength;\r\nreq->rq_receiving_reply = 1;\r\n} else {\r\nreq->rq_rep_swab_mask = 0;\r\nreq->rq_replied = 1;\r\nreq->rq_resend = 0;\r\nreq->rq_reply_off = ev->offset;\r\nreq->rq_nob_received = ev->mlength;\r\nDEBUG_REQ(D_INFO, req,\r\n"reply in flags=%x mlen=%u offset=%d replen=%d",\r\nlustre_msg_get_flags(req->rq_reqmsg),\r\nev->mlength, ev->offset, req->rq_replen);\r\n}\r\nreq->rq_import->imp_last_reply_time = get_seconds();\r\nout_wake:\r\nptlrpc_client_wake_req(req);\r\nspin_unlock(&req->rq_lock);\r\n}\r\nvoid client_bulk_callback(lnet_event_t *ev)\r\n{\r\nstruct ptlrpc_cb_id *cbid = ev->md.user_ptr;\r\nstruct ptlrpc_bulk_desc *desc = cbid->cbid_arg;\r\nstruct ptlrpc_request *req;\r\nLASSERT((desc->bd_type == BULK_PUT_SINK &&\r\nev->type == LNET_EVENT_PUT) ||\r\n(desc->bd_type == BULK_GET_SOURCE &&\r\nev->type == LNET_EVENT_GET) ||\r\nev->type == LNET_EVENT_UNLINK);\r\nLASSERT(ev->unlinked);\r\nif (CFS_FAIL_CHECK_ORSET(OBD_FAIL_PTLRPC_CLIENT_BULK_CB, CFS_FAIL_ONCE))\r\nev->status = -EIO;\r\nif (CFS_FAIL_CHECK_ORSET(OBD_FAIL_PTLRPC_CLIENT_BULK_CB2,\r\nCFS_FAIL_ONCE))\r\nev->status = -EIO;\r\nCDEBUG((ev->status == 0) ? D_NET : D_ERROR,\r\n"event type %d, status %d, desc %p\n",\r\nev->type, ev->status, desc);\r\nspin_lock(&desc->bd_lock);\r\nreq = desc->bd_req;\r\nLASSERT(desc->bd_md_count > 0);\r\ndesc->bd_md_count--;\r\nif (ev->type != LNET_EVENT_UNLINK && ev->status == 0) {\r\ndesc->bd_nob_transferred += ev->mlength;\r\ndesc->bd_sender = ev->sender;\r\n} else {\r\nspin_lock(&req->rq_lock);\r\nreq->rq_net_err = 1;\r\nspin_unlock(&req->rq_lock);\r\n}\r\nif (ev->status != 0)\r\ndesc->bd_failure = 1;\r\nif (desc->bd_md_count == 0)\r\nptlrpc_client_wake_req(desc->bd_req);\r\nspin_unlock(&desc->bd_lock);\r\n}\r\nstatic void ptlrpc_req_add_history(struct ptlrpc_service_part *svcpt,\r\nstruct ptlrpc_request *req)\r\n{\r\n__u64 sec = req->rq_arrival_time.tv_sec;\r\n__u32 usec = req->rq_arrival_time.tv_usec >> 4;\r\n__u64 new_seq;\r\nnew_seq = (sec << REQS_SEC_SHIFT) |\r\n(usec << REQS_USEC_SHIFT) |\r\n(svcpt->scp_cpt < 0 ? 0 : svcpt->scp_cpt);\r\nif (new_seq > svcpt->scp_hist_seq) {\r\nsvcpt->scp_hist_seq = new_seq;\r\n} else {\r\nLASSERT(REQS_SEQ_SHIFT(svcpt) < REQS_USEC_SHIFT);\r\nsvcpt->scp_hist_seq += (1U << REQS_SEQ_SHIFT(svcpt));\r\nnew_seq = svcpt->scp_hist_seq;\r\n}\r\nreq->rq_history_seq = new_seq;\r\nlist_add_tail(&req->rq_history_list, &svcpt->scp_hist_reqs);\r\n}\r\nvoid request_in_callback(lnet_event_t *ev)\r\n{\r\nstruct ptlrpc_cb_id *cbid = ev->md.user_ptr;\r\nstruct ptlrpc_request_buffer_desc *rqbd = cbid->cbid_arg;\r\nstruct ptlrpc_service_part *svcpt = rqbd->rqbd_svcpt;\r\nstruct ptlrpc_service *service = svcpt->scp_service;\r\nstruct ptlrpc_request *req;\r\nLASSERT(ev->type == LNET_EVENT_PUT ||\r\nev->type == LNET_EVENT_UNLINK);\r\nLASSERT((char *)ev->md.start >= rqbd->rqbd_buffer);\r\nLASSERT((char *)ev->md.start + ev->offset + ev->mlength <=\r\nrqbd->rqbd_buffer + service->srv_buf_size);\r\nCDEBUG((ev->status == 0) ? D_NET : D_ERROR,\r\n"event type %d, status %d, service %s\n",\r\nev->type, ev->status, service->srv_name);\r\nif (ev->unlinked) {\r\nreq = &rqbd->rqbd_req;\r\nmemset(req, 0, sizeof(*req));\r\n} else {\r\nLASSERT(ev->type == LNET_EVENT_PUT);\r\nif (ev->status != 0) {\r\nreturn;\r\n}\r\nreq = ptlrpc_request_cache_alloc(GFP_ATOMIC);\r\nif (req == NULL) {\r\nCERROR("Can't allocate incoming request descriptor: Dropping %s RPC from %s\n",\r\nservice->srv_name,\r\nlibcfs_id2str(ev->initiator));\r\nreturn;\r\n}\r\n}\r\nreq->rq_xid = ev->match_bits;\r\nreq->rq_reqbuf = ev->md.start + ev->offset;\r\nif (ev->type == LNET_EVENT_PUT && ev->status == 0)\r\nreq->rq_reqdata_len = ev->mlength;\r\ndo_gettimeofday(&req->rq_arrival_time);\r\nreq->rq_peer = ev->initiator;\r\nreq->rq_self = ev->target.nid;\r\nreq->rq_rqbd = rqbd;\r\nreq->rq_phase = RQ_PHASE_NEW;\r\nspin_lock_init(&req->rq_lock);\r\nINIT_LIST_HEAD(&req->rq_timed_list);\r\nINIT_LIST_HEAD(&req->rq_exp_list);\r\natomic_set(&req->rq_refcount, 1);\r\nif (ev->type == LNET_EVENT_PUT)\r\nCDEBUG(D_INFO, "incoming req@%p x%llu msgsize %u\n",\r\nreq, req->rq_xid, ev->mlength);\r\nCDEBUG(D_RPCTRACE, "peer: %s\n", libcfs_id2str(req->rq_peer));\r\nspin_lock(&svcpt->scp_lock);\r\nptlrpc_req_add_history(svcpt, req);\r\nif (ev->unlinked) {\r\nsvcpt->scp_nrqbds_posted--;\r\nCDEBUG(D_INFO, "Buffer complete: %d buffers still posted\n",\r\nsvcpt->scp_nrqbds_posted);\r\nif (test_req_buffer_pressure &&\r\nev->type != LNET_EVENT_UNLINK &&\r\nsvcpt->scp_nrqbds_posted == 0)\r\nCWARN("All %s request buffers busy\n",\r\nservice->srv_name);\r\n} else {\r\nrqbd->rqbd_refcount++;\r\n}\r\nlist_add_tail(&req->rq_list, &svcpt->scp_req_incoming);\r\nsvcpt->scp_nreqs_incoming++;\r\nwake_up(&svcpt->scp_waitq);\r\nspin_unlock(&svcpt->scp_lock);\r\n}\r\nvoid reply_out_callback(lnet_event_t *ev)\r\n{\r\nstruct ptlrpc_cb_id *cbid = ev->md.user_ptr;\r\nstruct ptlrpc_reply_state *rs = cbid->cbid_arg;\r\nstruct ptlrpc_service_part *svcpt = rs->rs_svcpt;\r\nLASSERT(ev->type == LNET_EVENT_SEND ||\r\nev->type == LNET_EVENT_ACK ||\r\nev->type == LNET_EVENT_UNLINK);\r\nif (!rs->rs_difficult) {\r\nLASSERT(ev->unlinked);\r\nptlrpc_rs_decref(rs);\r\nreturn;\r\n}\r\nLASSERT(rs->rs_on_net);\r\nif (ev->unlinked) {\r\nspin_lock(&svcpt->scp_rep_lock);\r\nspin_lock(&rs->rs_lock);\r\nrs->rs_on_net = 0;\r\nif (!rs->rs_no_ack ||\r\nrs->rs_transno <=\r\nrs->rs_export->exp_obd->obd_last_committed)\r\nptlrpc_schedule_difficult_reply(rs);\r\nspin_unlock(&rs->rs_lock);\r\nspin_unlock(&svcpt->scp_rep_lock);\r\n}\r\n}\r\nstatic void ptlrpc_master_callback(lnet_event_t *ev)\r\n{\r\nstruct ptlrpc_cb_id *cbid = ev->md.user_ptr;\r\nvoid (*callback)(lnet_event_t *ev) = cbid->cbid_fn;\r\nLASSERT(cbid->cbid_arg != LP_POISON);\r\nLASSERT(callback == request_out_callback ||\r\ncallback == reply_in_callback ||\r\ncallback == client_bulk_callback ||\r\ncallback == request_in_callback ||\r\ncallback == reply_out_callback);\r\ncallback(ev);\r\n}\r\nint ptlrpc_uuid_to_peer(struct obd_uuid *uuid,\r\nlnet_process_id_t *peer, lnet_nid_t *self)\r\n{\r\nint best_dist = 0;\r\n__u32 best_order = 0;\r\nint count = 0;\r\nint rc = -ENOENT;\r\nint portals_compatibility;\r\nint dist;\r\n__u32 order;\r\nlnet_nid_t dst_nid;\r\nlnet_nid_t src_nid;\r\nportals_compatibility = LNetCtl(IOC_LIBCFS_PORTALS_COMPATIBILITY, NULL);\r\npeer->pid = LUSTRE_SRV_LNET_PID;\r\nwhile (lustre_uuid_to_peer(uuid->uuid, &dst_nid, count++) == 0) {\r\ndist = LNetDist(dst_nid, &src_nid, &order);\r\nif (dist < 0)\r\ncontinue;\r\nif (dist == 0) {\r\npeer->nid = *self = LNET_MKNID(LNET_MKNET(LOLND, 0), 0);\r\nrc = 0;\r\nbreak;\r\n}\r\nif (rc < 0 ||\r\ndist < best_dist ||\r\n(dist == best_dist && order < best_order)) {\r\nbest_dist = dist;\r\nbest_order = order;\r\nif (portals_compatibility > 1) {\r\ndst_nid = LNET_MKNID(0, LNET_NIDADDR(dst_nid));\r\nsrc_nid = LNET_MKNID(0, LNET_NIDADDR(src_nid));\r\n}\r\npeer->nid = dst_nid;\r\n*self = src_nid;\r\nrc = 0;\r\n}\r\n}\r\nCDEBUG(D_NET, "%s->%s\n", uuid->uuid, libcfs_id2str(*peer));\r\nreturn rc;\r\n}\r\nvoid ptlrpc_ni_fini(void)\r\n{\r\nwait_queue_head_t waitq;\r\nstruct l_wait_info lwi;\r\nint rc;\r\nint retries;\r\nfor (retries = 0;; retries++) {\r\nrc = LNetEQFree(ptlrpc_eq_h);\r\nswitch (rc) {\r\ndefault:\r\nLBUG();\r\ncase 0:\r\nLNetNIFini();\r\nreturn;\r\ncase -EBUSY:\r\nif (retries != 0)\r\nCWARN("Event queue still busy\n");\r\ninit_waitqueue_head(&waitq);\r\nlwi = LWI_TIMEOUT(cfs_time_seconds(2), NULL, NULL);\r\nl_wait_event(waitq, 0, &lwi);\r\nbreak;\r\n}\r\n}\r\n}\r\nlnet_pid_t ptl_get_pid(void)\r\n{\r\nlnet_pid_t pid;\r\npid = LUSTRE_SRV_LNET_PID;\r\nreturn pid;\r\n}\r\nint ptlrpc_ni_init(void)\r\n{\r\nint rc;\r\nlnet_pid_t pid;\r\npid = ptl_get_pid();\r\nCDEBUG(D_NET, "My pid is: %x\n", pid);\r\nrc = LNetNIInit(pid);\r\nif (rc < 0) {\r\nCDEBUG(D_NET, "Can't init network interface: %d\n", rc);\r\nreturn -ENOENT;\r\n}\r\nrc = LNetEQAlloc(0, ptlrpc_master_callback, &ptlrpc_eq_h);\r\nif (rc == 0)\r\nreturn 0;\r\nCERROR("Failed to allocate event queue: %d\n", rc);\r\nLNetNIFini();\r\nreturn -ENOMEM;\r\n}\r\nint ptlrpc_init_portals(void)\r\n{\r\nint rc = ptlrpc_ni_init();\r\nif (rc != 0) {\r\nCERROR("network initialisation failed\n");\r\nreturn -EIO;\r\n}\r\nrc = ptlrpcd_addref();\r\nif (rc == 0)\r\nreturn 0;\r\nCERROR("rpcd initialisation failed\n");\r\nptlrpc_ni_fini();\r\nreturn rc;\r\n}\r\nvoid ptlrpc_exit_portals(void)\r\n{\r\nptlrpcd_decref();\r\nptlrpc_ni_fini();\r\n}
