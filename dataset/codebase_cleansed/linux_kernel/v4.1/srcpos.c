static char *dirname(const char *path)\r\n{\r\nconst char *slash = strrchr(path, '/');\r\nif (slash) {\r\nint len = slash - path;\r\nchar *dir = xmalloc(len + 1);\r\nmemcpy(dir, path, len);\r\ndir[len] = '\0';\r\nreturn dir;\r\n}\r\nreturn NULL;\r\n}\r\nstatic char *try_open(const char *dirname, const char *fname, FILE **fp)\r\n{\r\nchar *fullname;\r\nif (!dirname || fname[0] == '/')\r\nfullname = xstrdup(fname);\r\nelse\r\nfullname = join_path(dirname, fname);\r\n*fp = fopen(fullname, "r");\r\nif (!*fp) {\r\nfree(fullname);\r\nfullname = NULL;\r\n}\r\nreturn fullname;\r\n}\r\nstatic char *fopen_any_on_path(const char *fname, FILE **fp)\r\n{\r\nconst char *cur_dir = NULL;\r\nstruct search_path *node;\r\nchar *fullname;\r\nassert(fp);\r\nif (current_srcfile)\r\ncur_dir = current_srcfile->dir;\r\nfullname = try_open(cur_dir, fname, fp);\r\nfor (node = search_path_head; !*fp && node; node = node->next)\r\nfullname = try_open(node->dirname, fname, fp);\r\nreturn fullname;\r\n}\r\nFILE *srcfile_relative_open(const char *fname, char **fullnamep)\r\n{\r\nFILE *f;\r\nchar *fullname;\r\nif (streq(fname, "-")) {\r\nf = stdin;\r\nfullname = xstrdup("<stdin>");\r\n} else {\r\nfullname = fopen_any_on_path(fname, &f);\r\nif (!f)\r\ndie("Couldn't open \"%s\": %s\n", fname,\r\nstrerror(errno));\r\n}\r\nif (depfile)\r\nfprintf(depfile, " %s", fullname);\r\nif (fullnamep)\r\n*fullnamep = fullname;\r\nelse\r\nfree(fullname);\r\nreturn f;\r\n}\r\nvoid srcfile_push(const char *fname)\r\n{\r\nstruct srcfile_state *srcfile;\r\nif (srcfile_depth++ >= MAX_SRCFILE_DEPTH)\r\ndie("Includes nested too deeply");\r\nsrcfile = xmalloc(sizeof(*srcfile));\r\nsrcfile->f = srcfile_relative_open(fname, &srcfile->name);\r\nsrcfile->dir = dirname(srcfile->name);\r\nsrcfile->prev = current_srcfile;\r\nsrcfile->lineno = 1;\r\nsrcfile->colno = 1;\r\ncurrent_srcfile = srcfile;\r\n}\r\nint srcfile_pop(void)\r\n{\r\nstruct srcfile_state *srcfile = current_srcfile;\r\nassert(srcfile);\r\ncurrent_srcfile = srcfile->prev;\r\nif (fclose(srcfile->f))\r\ndie("Error closing \"%s\": %s\n", srcfile->name,\r\nstrerror(errno));\r\nreturn current_srcfile ? 1 : 0;\r\n}\r\nvoid srcfile_add_search_path(const char *dirname)\r\n{\r\nstruct search_path *node;\r\nnode = xmalloc(sizeof(*node));\r\nnode->next = NULL;\r\nnode->dirname = xstrdup(dirname);\r\nif (search_path_tail)\r\n*search_path_tail = node;\r\nelse\r\nsearch_path_head = node;\r\nsearch_path_tail = &node->next;\r\n}\r\nvoid srcpos_update(struct srcpos *pos, const char *text, int len)\r\n{\r\nint i;\r\npos->file = current_srcfile;\r\npos->first_line = current_srcfile->lineno;\r\npos->first_column = current_srcfile->colno;\r\nfor (i = 0; i < len; i++)\r\nif (text[i] == '\n') {\r\ncurrent_srcfile->lineno++;\r\ncurrent_srcfile->colno = 1;\r\n} else if (text[i] == '\t') {\r\ncurrent_srcfile->colno =\r\nALIGN(current_srcfile->colno, TAB_SIZE);\r\n} else {\r\ncurrent_srcfile->colno++;\r\n}\r\npos->last_line = current_srcfile->lineno;\r\npos->last_column = current_srcfile->colno;\r\n}\r\nstruct srcpos *\r\nsrcpos_copy(struct srcpos *pos)\r\n{\r\nstruct srcpos *pos_new;\r\npos_new = xmalloc(sizeof(struct srcpos));\r\nmemcpy(pos_new, pos, sizeof(struct srcpos));\r\nreturn pos_new;\r\n}\r\nvoid\r\nsrcpos_dump(struct srcpos *pos)\r\n{\r\nprintf("file : \"%s\"\n",\r\npos->file ? (char *) pos->file : "<no file>");\r\nprintf("first_line : %d\n", pos->first_line);\r\nprintf("first_column: %d\n", pos->first_column);\r\nprintf("last_line : %d\n", pos->last_line);\r\nprintf("last_column : %d\n", pos->last_column);\r\nprintf("file : %s\n", pos->file->name);\r\n}\r\nchar *\r\nsrcpos_string(struct srcpos *pos)\r\n{\r\nconst char *fname = "<no-file>";\r\nchar *pos_str;\r\nint rc;\r\nif (pos)\r\nfname = pos->file->name;\r\nif (pos->first_line != pos->last_line)\r\nrc = asprintf(&pos_str, "%s:%d.%d-%d.%d", fname,\r\npos->first_line, pos->first_column,\r\npos->last_line, pos->last_column);\r\nelse if (pos->first_column != pos->last_column)\r\nrc = asprintf(&pos_str, "%s:%d.%d-%d", fname,\r\npos->first_line, pos->first_column,\r\npos->last_column);\r\nelse\r\nrc = asprintf(&pos_str, "%s:%d.%d", fname,\r\npos->first_line, pos->first_column);\r\nif (rc == -1)\r\ndie("Couldn't allocate in srcpos string");\r\nreturn pos_str;\r\n}\r\nvoid\r\nsrcpos_verror(struct srcpos *pos, char const *fmt, va_list va)\r\n{\r\nconst char *srcstr;\r\nsrcstr = srcpos_string(pos);\r\nfprintf(stderr, "Error: %s ", srcstr);\r\nvfprintf(stderr, fmt, va);\r\nfprintf(stderr, "\n");\r\n}\r\nvoid\r\nsrcpos_error(struct srcpos *pos, char const *fmt, ...)\r\n{\r\nva_list va;\r\nva_start(va, fmt);\r\nsrcpos_verror(pos, fmt, va);\r\nva_end(va);\r\n}\r\nvoid\r\nsrcpos_warn(struct srcpos *pos, char const *fmt, ...)\r\n{\r\nconst char *srcstr;\r\nva_list va;\r\nva_start(va, fmt);\r\nsrcstr = srcpos_string(pos);\r\nfprintf(stderr, "Warning: %s ", srcstr);\r\nvfprintf(stderr, fmt, va);\r\nfprintf(stderr, "\n");\r\nva_end(va);\r\n}\r\nvoid srcpos_set_line(char *f, int l)\r\n{\r\ncurrent_srcfile->name = f;\r\ncurrent_srcfile->lineno = l;\r\n}
