static int snd_gusextreme_match(struct device *dev, unsigned int n)\r\n{\r\nreturn enable[n];\r\n}\r\nstatic int snd_gusextreme_es1688_create(struct snd_card *card,\r\nstruct snd_es1688 *chip,\r\nstruct device *dev, unsigned int n)\r\n{\r\nstatic long possible_ports[] = {0x220, 0x240, 0x260};\r\nstatic int possible_irqs[] = {5, 9, 10, 7, -1};\r\nstatic int possible_dmas[] = {1, 3, 0, -1};\r\nint i, error;\r\nif (irq[n] == SNDRV_AUTO_IRQ) {\r\nirq[n] = snd_legacy_find_free_irq(possible_irqs);\r\nif (irq[n] < 0) {\r\ndev_err(dev, "unable to find a free IRQ for ES1688\n");\r\nreturn -EBUSY;\r\n}\r\n}\r\nif (dma8[n] == SNDRV_AUTO_DMA) {\r\ndma8[n] = snd_legacy_find_free_dma(possible_dmas);\r\nif (dma8[n] < 0) {\r\ndev_err(dev, "unable to find a free DMA for ES1688\n");\r\nreturn -EBUSY;\r\n}\r\n}\r\nif (port[n] != SNDRV_AUTO_PORT)\r\nreturn snd_es1688_create(card, chip, port[n], mpu_port[n],\r\nirq[n], mpu_irq[n], dma8[n], ES1688_HW_1688);\r\ni = 0;\r\ndo {\r\nport[n] = possible_ports[i];\r\nerror = snd_es1688_create(card, chip, port[n], mpu_port[n],\r\nirq[n], mpu_irq[n], dma8[n], ES1688_HW_1688);\r\n} while (error < 0 && ++i < ARRAY_SIZE(possible_ports));\r\nreturn error;\r\n}\r\nstatic int snd_gusextreme_gus_card_create(struct snd_card *card,\r\nstruct device *dev, unsigned int n,\r\nstruct snd_gus_card **rgus)\r\n{\r\nstatic int possible_irqs[] = {11, 12, 15, 9, 5, 7, 3, -1};\r\nstatic int possible_dmas[] = {5, 6, 7, 3, 1, -1};\r\nif (gf1_irq[n] == SNDRV_AUTO_IRQ) {\r\ngf1_irq[n] = snd_legacy_find_free_irq(possible_irqs);\r\nif (gf1_irq[n] < 0) {\r\ndev_err(dev, "unable to find a free IRQ for GF1\n");\r\nreturn -EBUSY;\r\n}\r\n}\r\nif (dma1[n] == SNDRV_AUTO_DMA) {\r\ndma1[n] = snd_legacy_find_free_dma(possible_dmas);\r\nif (dma1[n] < 0) {\r\ndev_err(dev, "unable to find a free DMA for GF1\n");\r\nreturn -EBUSY;\r\n}\r\n}\r\nreturn snd_gus_create(card, gf1_port[n], gf1_irq[n], dma1[n], -1,\r\n0, channels[n], pcm_channels[n], 0, rgus);\r\n}\r\nstatic int snd_gusextreme_detect(struct snd_gus_card *gus,\r\nstruct snd_es1688 *es1688)\r\n{\r\nunsigned long flags;\r\nunsigned char d;\r\nspin_lock_irqsave(&es1688->mixer_lock, flags);\r\nsnd_es1688_mixer_write(es1688, 0x40, 0x0b);\r\nspin_unlock_irqrestore(&es1688->mixer_lock, flags);\r\nspin_lock_irqsave(&es1688->reg_lock, flags);\r\noutb(gus->gf1.port & 0x040 ? 2 : 0, ES1688P(es1688, INIT1));\r\noutb(0, 0x201);\r\noutb(gus->gf1.port & 0x020 ? 2 : 0, ES1688P(es1688, INIT1));\r\noutb(0, 0x201);\r\noutb(gus->gf1.port & 0x010 ? 3 : 1, ES1688P(es1688, INIT1));\r\nspin_unlock_irqrestore(&es1688->reg_lock, flags);\r\nudelay(100);\r\nsnd_gf1_i_write8(gus, SNDRV_GF1_GB_RESET, 0);\r\nif (((d = snd_gf1_i_look8(gus, SNDRV_GF1_GB_RESET)) & 0x07) != 0) {\r\nsnd_printdd("[0x%lx] check 1 failed - 0x%x\n", gus->gf1.port, d);\r\nreturn -EIO;\r\n}\r\nudelay(160);\r\nsnd_gf1_i_write8(gus, SNDRV_GF1_GB_RESET, 1);\r\nudelay(160);\r\nif (((d = snd_gf1_i_look8(gus, SNDRV_GF1_GB_RESET)) & 0x07) != 1) {\r\nsnd_printdd("[0x%lx] check 2 failed - 0x%x\n", gus->gf1.port, d);\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_gusextreme_mixer(struct snd_card *card)\r\n{\r\nstruct snd_ctl_elem_id id1, id2;\r\nint error;\r\nmemset(&id1, 0, sizeof(id1));\r\nmemset(&id2, 0, sizeof(id2));\r\nid1.iface = id2.iface = SNDRV_CTL_ELEM_IFACE_MIXER;\r\nstrcpy(id1.name, "Aux Playback Volume");\r\nstrcpy(id2.name, "Synth Playback Volume");\r\nerror = snd_ctl_rename_id(card, &id1, &id2);\r\nif (error < 0)\r\nreturn error;\r\nstrcpy(id1.name, "Master Playback Switch");\r\nstrcpy(id2.name, "Synth Playback Switch");\r\nerror = snd_ctl_rename_id(card, &id1, &id2);\r\nif (error < 0)\r\nreturn error;\r\nreturn 0;\r\n}\r\nstatic int snd_gusextreme_probe(struct device *dev, unsigned int n)\r\n{\r\nstruct snd_card *card;\r\nstruct snd_gus_card *gus;\r\nstruct snd_es1688 *es1688;\r\nstruct snd_opl3 *opl3;\r\nint error;\r\nerror = snd_card_new(dev, index[n], id[n], THIS_MODULE,\r\nsizeof(struct snd_es1688), &card);\r\nif (error < 0)\r\nreturn error;\r\nes1688 = card->private_data;\r\nif (mpu_port[n] == SNDRV_AUTO_PORT)\r\nmpu_port[n] = 0;\r\nif (mpu_irq[n] > 15)\r\nmpu_irq[n] = -1;\r\nerror = snd_gusextreme_es1688_create(card, es1688, dev, n);\r\nif (error < 0)\r\ngoto out;\r\nif (gf1_port[n] < 0)\r\ngf1_port[n] = es1688->port + 0x20;\r\nerror = snd_gusextreme_gus_card_create(card, dev, n, &gus);\r\nif (error < 0)\r\ngoto out;\r\nerror = snd_gusextreme_detect(gus, es1688);\r\nif (error < 0)\r\ngoto out;\r\ngus->joystick_dac = joystick_dac[n];\r\nerror = snd_gus_initialize(gus);\r\nif (error < 0)\r\ngoto out;\r\nerror = -ENODEV;\r\nif (!gus->ess_flag) {\r\ndev_err(dev, "GUS Extreme soundcard was not "\r\n"detected at 0x%lx\n", gus->gf1.port);\r\ngoto out;\r\n}\r\ngus->codec_flag = 1;\r\nerror = snd_es1688_pcm(card, es1688, 0);\r\nif (error < 0)\r\ngoto out;\r\nerror = snd_es1688_mixer(card, es1688);\r\nif (error < 0)\r\ngoto out;\r\nsnd_component_add(card, "ES1688");\r\nif (pcm_channels[n] > 0) {\r\nerror = snd_gf1_pcm_new(gus, 1, 1);\r\nif (error < 0)\r\ngoto out;\r\n}\r\nerror = snd_gf1_new_mixer(gus);\r\nif (error < 0)\r\ngoto out;\r\nerror = snd_gusextreme_mixer(card);\r\nif (error < 0)\r\ngoto out;\r\nif (snd_opl3_create(card, es1688->port, es1688->port + 2,\r\nOPL3_HW_OPL3, 0, &opl3) < 0)\r\ndev_warn(dev, "opl3 not detected at 0x%lx\n", es1688->port);\r\nelse {\r\nerror = snd_opl3_hwdep_new(opl3, 0, 2, NULL);\r\nif (error < 0)\r\ngoto out;\r\n}\r\nif (es1688->mpu_port >= 0x300) {\r\nerror = snd_mpu401_uart_new(card, 0, MPU401_HW_ES1688,\r\nes1688->mpu_port, 0, mpu_irq[n], NULL);\r\nif (error < 0)\r\ngoto out;\r\n}\r\nsprintf(card->longname, "Gravis UltraSound Extreme at 0x%lx, "\r\n"irq %i&%i, dma %i&%i", es1688->port,\r\ngus->gf1.irq, es1688->irq, gus->gf1.dma1, es1688->dma8);\r\nerror = snd_card_register(card);\r\nif (error < 0)\r\ngoto out;\r\ndev_set_drvdata(dev, card);\r\nreturn 0;\r\nout: snd_card_free(card);\r\nreturn error;\r\n}\r\nstatic int snd_gusextreme_remove(struct device *dev, unsigned int n)\r\n{\r\nsnd_card_free(dev_get_drvdata(dev));\r\nreturn 0;\r\n}\r\nstatic int __init alsa_card_gusextreme_init(void)\r\n{\r\nreturn isa_register_driver(&snd_gusextreme_driver, SNDRV_CARDS);\r\n}\r\nstatic void __exit alsa_card_gusextreme_exit(void)\r\n{\r\nisa_unregister_driver(&snd_gusextreme_driver);\r\n}
