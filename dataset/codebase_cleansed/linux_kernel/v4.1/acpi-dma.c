static int acpi_dma_parse_resource_group(const struct acpi_csrt_group *grp,\r\nstruct acpi_device *adev, struct acpi_dma *adma)\r\n{\r\nconst struct acpi_csrt_shared_info *si;\r\nstruct list_head resource_list;\r\nstruct resource_entry *rentry;\r\nresource_size_t mem = 0, irq = 0;\r\nint ret;\r\nif (grp->shared_info_length != sizeof(struct acpi_csrt_shared_info))\r\nreturn -ENODEV;\r\nINIT_LIST_HEAD(&resource_list);\r\nret = acpi_dev_get_resources(adev, &resource_list, NULL, NULL);\r\nif (ret <= 0)\r\nreturn 0;\r\nlist_for_each_entry(rentry, &resource_list, node) {\r\nif (resource_type(rentry->res) == IORESOURCE_MEM)\r\nmem = rentry->res->start;\r\nelse if (resource_type(rentry->res) == IORESOURCE_IRQ)\r\nirq = rentry->res->start;\r\n}\r\nacpi_dev_free_resource_list(&resource_list);\r\nif (mem == 0 && irq == 0)\r\nreturn 0;\r\nsi = (const struct acpi_csrt_shared_info *)&grp[1];\r\nif (si->mmio_base_low != mem || si->gsi_interrupt != irq)\r\nreturn 0;\r\ndev_dbg(&adev->dev, "matches with %.4s%04X (rev %u)\n",\r\n(char *)&grp->vendor_id, grp->device_id, grp->revision);\r\nif (si->base_request_line == 0 && si->num_handshake_signals == 0)\r\nreturn 0;\r\nadma->base_request_line = si->base_request_line;\r\nadma->end_request_line = si->base_request_line +\r\nsi->num_handshake_signals - 1;\r\ndev_dbg(&adev->dev, "request line base: 0x%04x end: 0x%04x\n",\r\nadma->base_request_line, adma->end_request_line);\r\nreturn 1;\r\n}\r\nstatic void acpi_dma_parse_csrt(struct acpi_device *adev, struct acpi_dma *adma)\r\n{\r\nstruct acpi_csrt_group *grp, *end;\r\nstruct acpi_table_csrt *csrt;\r\nacpi_status status;\r\nint ret;\r\nstatus = acpi_get_table(ACPI_SIG_CSRT, 0,\r\n(struct acpi_table_header **)&csrt);\r\nif (ACPI_FAILURE(status)) {\r\nif (status != AE_NOT_FOUND)\r\ndev_warn(&adev->dev, "failed to get the CSRT table\n");\r\nreturn;\r\n}\r\ngrp = (struct acpi_csrt_group *)(csrt + 1);\r\nend = (struct acpi_csrt_group *)((void *)csrt + csrt->header.length);\r\nwhile (grp < end) {\r\nret = acpi_dma_parse_resource_group(grp, adev, adma);\r\nif (ret < 0) {\r\ndev_warn(&adev->dev,\r\n"error in parsing resource group\n");\r\nreturn;\r\n}\r\ngrp = (struct acpi_csrt_group *)((void *)grp + grp->length);\r\n}\r\n}\r\nint acpi_dma_controller_free(struct device *dev)\r\n{\r\nstruct acpi_dma *adma;\r\nif (!dev)\r\nreturn -EINVAL;\r\nmutex_lock(&acpi_dma_lock);\r\nlist_for_each_entry(adma, &acpi_dma_list, dma_controllers)\r\nif (adma->dev == dev) {\r\nlist_del(&adma->dma_controllers);\r\nmutex_unlock(&acpi_dma_lock);\r\nkfree(adma);\r\nreturn 0;\r\n}\r\nmutex_unlock(&acpi_dma_lock);\r\nreturn -ENODEV;\r\n}\r\nstatic void devm_acpi_dma_release(struct device *dev, void *res)\r\n{\r\nacpi_dma_controller_free(dev);\r\n}\r\nvoid devm_acpi_dma_controller_free(struct device *dev)\r\n{\r\nWARN_ON(devres_release(dev, devm_acpi_dma_release, NULL, NULL));\r\n}\r\nstatic int acpi_dma_update_dma_spec(struct acpi_dma *adma,\r\nstruct acpi_dma_spec *dma_spec)\r\n{\r\ndma_spec->dev = adma->dev;\r\nif (adma->base_request_line == 0 && adma->end_request_line == 0)\r\nreturn 0;\r\nif (dma_spec->slave_id < adma->base_request_line ||\r\ndma_spec->slave_id > adma->end_request_line)\r\nreturn -1;\r\ndma_spec->slave_id -= adma->base_request_line;\r\nreturn 1;\r\n}\r\nstatic int acpi_dma_parse_fixed_dma(struct acpi_resource *res, void *data)\r\n{\r\nstruct acpi_dma_parser_data *pdata = data;\r\nif (res->type == ACPI_RESOURCE_TYPE_FIXED_DMA) {\r\nstruct acpi_resource_fixed_dma *dma = &res->data.fixed_dma;\r\nif (pdata->n++ == pdata->index) {\r\npdata->dma_spec.chan_id = dma->channels;\r\npdata->dma_spec.slave_id = dma->request_lines;\r\n}\r\n}\r\nreturn 1;\r\n}\r\nstruct dma_chan *acpi_dma_request_slave_chan_by_index(struct device *dev,\r\nsize_t index)\r\n{\r\nstruct acpi_dma_parser_data pdata;\r\nstruct acpi_dma_spec *dma_spec = &pdata.dma_spec;\r\nstruct list_head resource_list;\r\nstruct acpi_device *adev;\r\nstruct acpi_dma *adma;\r\nstruct dma_chan *chan = NULL;\r\nint found;\r\nif (!dev || !ACPI_HANDLE(dev))\r\nreturn ERR_PTR(-ENODEV);\r\nif (acpi_bus_get_device(ACPI_HANDLE(dev), &adev))\r\nreturn ERR_PTR(-ENODEV);\r\nmemset(&pdata, 0, sizeof(pdata));\r\npdata.index = index;\r\ndma_spec->chan_id = -1;\r\ndma_spec->slave_id = -1;\r\nINIT_LIST_HEAD(&resource_list);\r\nacpi_dev_get_resources(adev, &resource_list,\r\nacpi_dma_parse_fixed_dma, &pdata);\r\nacpi_dev_free_resource_list(&resource_list);\r\nif (dma_spec->slave_id < 0 || dma_spec->chan_id < 0)\r\nreturn ERR_PTR(-ENODEV);\r\nmutex_lock(&acpi_dma_lock);\r\nlist_for_each_entry(adma, &acpi_dma_list, dma_controllers) {\r\nfound = acpi_dma_update_dma_spec(adma, dma_spec);\r\nif (found < 0)\r\ncontinue;\r\nchan = adma->acpi_dma_xlate(dma_spec, adma);\r\nif (found > 0 || chan)\r\nbreak;\r\n}\r\nmutex_unlock(&acpi_dma_lock);\r\nreturn chan ? chan : ERR_PTR(-EPROBE_DEFER);\r\n}\r\nstruct dma_chan *acpi_dma_request_slave_chan_by_name(struct device *dev,\r\nconst char *name)\r\n{\r\nsize_t index;\r\nif (!strcmp(name, "tx"))\r\nindex = 0;\r\nelse if (!strcmp(name, "rx"))\r\nindex = 1;\r\nelse\r\nreturn ERR_PTR(-ENODEV);\r\nreturn acpi_dma_request_slave_chan_by_index(dev, index);\r\n}\r\nstruct dma_chan *acpi_dma_simple_xlate(struct acpi_dma_spec *dma_spec,\r\nstruct acpi_dma *adma)\r\n{\r\nstruct acpi_dma_filter_info *info = adma->data;\r\nif (!info || !info->filter_fn)\r\nreturn NULL;\r\nreturn dma_request_channel(info->dma_cap, info->filter_fn, dma_spec);\r\n}
