static int armada_debugfs_gem_linear_show(struct seq_file *m, void *data)\r\n{\r\nstruct drm_info_node *node = m->private;\r\nstruct drm_device *dev = node->minor->dev;\r\nstruct armada_private *priv = dev->dev_private;\r\nint ret;\r\nmutex_lock(&dev->struct_mutex);\r\nret = drm_mm_dump_table(m, &priv->linear);\r\nmutex_unlock(&dev->struct_mutex);\r\nreturn ret;\r\n}\r\nstatic int armada_debugfs_reg_show(struct seq_file *m, void *data)\r\n{\r\nstruct drm_device *dev = m->private;\r\nstruct armada_private *priv = dev->dev_private;\r\nint n, i;\r\nif (priv) {\r\nfor (n = 0; n < ARRAY_SIZE(priv->dcrtc); n++) {\r\nstruct armada_crtc *dcrtc = priv->dcrtc[n];\r\nif (!dcrtc)\r\ncontinue;\r\nfor (i = 0x84; i <= 0x1c4; i += 4) {\r\nuint32_t v = readl_relaxed(dcrtc->base + i);\r\nseq_printf(m, "%u: 0x%04x: 0x%08x\n", n, i, v);\r\n}\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int armada_debugfs_reg_r_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, armada_debugfs_reg_show, inode->i_private);\r\n}\r\nstatic int armada_debugfs_write(struct file *file, const char __user *ptr,\r\nsize_t len, loff_t *off)\r\n{\r\nstruct drm_device *dev = file->private_data;\r\nstruct armada_private *priv = dev->dev_private;\r\nstruct armada_crtc *dcrtc = priv->dcrtc[0];\r\nchar buf[32], *p;\r\nuint32_t reg, val;\r\nint ret;\r\nif (*off != 0)\r\nreturn 0;\r\nif (len > sizeof(buf) - 1)\r\nlen = sizeof(buf) - 1;\r\nret = strncpy_from_user(buf, ptr, len);\r\nif (ret < 0)\r\nreturn ret;\r\nbuf[len] = '\0';\r\nreg = simple_strtoul(buf, &p, 16);\r\nif (!isspace(*p))\r\nreturn -EINVAL;\r\nval = simple_strtoul(p + 1, NULL, 16);\r\nif (reg >= 0x84 && reg <= 0x1c4)\r\nwritel(val, dcrtc->base + reg);\r\nreturn len;\r\n}\r\nstatic int drm_add_fake_info_node(struct drm_minor *minor, struct dentry *ent,\r\nconst void *key)\r\n{\r\nstruct drm_info_node *node;\r\nnode = kmalloc(sizeof(struct drm_info_node), GFP_KERNEL);\r\nif (node == NULL) {\r\ndebugfs_remove(ent);\r\nreturn -ENOMEM;\r\n}\r\nnode->minor = minor;\r\nnode->dent = ent;\r\nnode->info_ent = (void *) key;\r\nmutex_lock(&minor->debugfs_lock);\r\nlist_add(&node->list, &minor->debugfs_list);\r\nmutex_unlock(&minor->debugfs_lock);\r\nreturn 0;\r\n}\r\nstatic int armada_debugfs_create(struct dentry *root, struct drm_minor *minor,\r\nconst char *name, umode_t mode, const struct file_operations *fops)\r\n{\r\nstruct dentry *de;\r\nde = debugfs_create_file(name, mode, root, minor->dev, fops);\r\nreturn drm_add_fake_info_node(minor, de, fops);\r\n}\r\nint armada_drm_debugfs_init(struct drm_minor *minor)\r\n{\r\nint ret;\r\nret = drm_debugfs_create_files(armada_debugfs_list,\r\nARMADA_DEBUGFS_ENTRIES,\r\nminor->debugfs_root, minor);\r\nif (ret)\r\nreturn ret;\r\nret = armada_debugfs_create(minor->debugfs_root, minor,\r\n"reg", S_IFREG | S_IRUSR, &fops_reg_r);\r\nif (ret)\r\ngoto err_1;\r\nret = armada_debugfs_create(minor->debugfs_root, minor,\r\n"reg_wr", S_IFREG | S_IWUSR, &fops_reg_w);\r\nif (ret)\r\ngoto err_2;\r\nreturn ret;\r\nerr_2:\r\ndrm_debugfs_remove_files((struct drm_info_list *)&fops_reg_r, 1, minor);\r\nerr_1:\r\ndrm_debugfs_remove_files(armada_debugfs_list, ARMADA_DEBUGFS_ENTRIES,\r\nminor);\r\nreturn ret;\r\n}\r\nvoid armada_drm_debugfs_cleanup(struct drm_minor *minor)\r\n{\r\ndrm_debugfs_remove_files((struct drm_info_list *)&fops_reg_w, 1, minor);\r\ndrm_debugfs_remove_files((struct drm_info_list *)&fops_reg_r, 1, minor);\r\ndrm_debugfs_remove_files(armada_debugfs_list, ARMADA_DEBUGFS_ENTRIES,\r\nminor);\r\n}
