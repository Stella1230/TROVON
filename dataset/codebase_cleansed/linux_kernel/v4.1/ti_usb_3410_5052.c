static int ti_startup(struct usb_serial *serial)\r\n{\r\nstruct ti_device *tdev;\r\nstruct usb_device *dev = serial->dev;\r\nint status;\r\ndev_dbg(&dev->dev,\r\n"%s - product 0x%4X, num configurations %d, configuration value %d\n",\r\n__func__, le16_to_cpu(dev->descriptor.idProduct),\r\ndev->descriptor.bNumConfigurations,\r\ndev->actconfig->desc.bConfigurationValue);\r\ntdev = kzalloc(sizeof(struct ti_device), GFP_KERNEL);\r\nif (!tdev)\r\nreturn -ENOMEM;\r\nmutex_init(&tdev->td_open_close_lock);\r\ntdev->td_serial = serial;\r\nusb_set_serial_data(serial, tdev);\r\nif (serial->type == &ti_1port_device)\r\ntdev->td_is_3410 = 1;\r\ndev_dbg(&dev->dev, "%s - device type is %s\n", __func__,\r\ntdev->td_is_3410 ? "3410" : "5052");\r\nif (dev->descriptor.bNumConfigurations == 1) {\r\nstatus = ti_download_firmware(tdev);\r\nif (status != 0)\r\ngoto free_tdev;\r\nif (tdev->td_is_3410) {\r\nmsleep_interruptible(100);\r\nusb_reset_device(dev);\r\n}\r\nstatus = -ENODEV;\r\ngoto free_tdev;\r\n}\r\nif (dev->actconfig->desc.bConfigurationValue == TI_BOOT_CONFIG) {\r\nstatus = usb_driver_set_configuration(dev, TI_ACTIVE_CONFIG);\r\nstatus = status ? status : -ENODEV;\r\ngoto free_tdev;\r\n}\r\nreturn 0;\r\nfree_tdev:\r\nkfree(tdev);\r\nusb_set_serial_data(serial, NULL);\r\nreturn status;\r\n}\r\nstatic void ti_release(struct usb_serial *serial)\r\n{\r\nstruct ti_device *tdev = usb_get_serial_data(serial);\r\nkfree(tdev);\r\n}\r\nstatic int ti_port_probe(struct usb_serial_port *port)\r\n{\r\nstruct ti_port *tport;\r\ntport = kzalloc(sizeof(*tport), GFP_KERNEL);\r\nif (!tport)\r\nreturn -ENOMEM;\r\nspin_lock_init(&tport->tp_lock);\r\nif (port == port->serial->port[0])\r\ntport->tp_uart_base_addr = TI_UART1_BASE_ADDR;\r\nelse\r\ntport->tp_uart_base_addr = TI_UART2_BASE_ADDR;\r\nport->port.closing_wait = msecs_to_jiffies(10 * closing_wait);\r\ntport->tp_port = port;\r\ntport->tp_tdev = usb_get_serial_data(port->serial);\r\ntport->tp_uart_mode = 0;\r\nusb_set_serial_port_data(port, tport);\r\nport->port.drain_delay = 3;\r\nreturn 0;\r\n}\r\nstatic int ti_port_remove(struct usb_serial_port *port)\r\n{\r\nstruct ti_port *tport;\r\ntport = usb_get_serial_port_data(port);\r\nkfree(tport);\r\nreturn 0;\r\n}\r\nstatic int ti_open(struct tty_struct *tty, struct usb_serial_port *port)\r\n{\r\nstruct ti_port *tport = usb_get_serial_port_data(port);\r\nstruct ti_device *tdev;\r\nstruct usb_device *dev;\r\nstruct urb *urb;\r\nint port_number;\r\nint status;\r\n__u16 open_settings = (__u8)(TI_PIPE_MODE_CONTINOUS |\r\nTI_PIPE_TIMEOUT_ENABLE |\r\n(TI_TRANSFER_TIMEOUT << 2));\r\nif (tport == NULL)\r\nreturn -ENODEV;\r\ndev = port->serial->dev;\r\ntdev = tport->tp_tdev;\r\nif (mutex_lock_interruptible(&tdev->td_open_close_lock))\r\nreturn -ERESTARTSYS;\r\nport_number = port->port_number;\r\ntport->tp_msr = 0;\r\ntport->tp_shadow_mcr |= (TI_MCR_RTS | TI_MCR_DTR);\r\nif (tdev->td_open_port_count == 0) {\r\ndev_dbg(&port->dev, "%s - start interrupt in urb\n", __func__);\r\nurb = tdev->td_serial->port[0]->interrupt_in_urb;\r\nif (!urb) {\r\ndev_err(&port->dev, "%s - no interrupt urb\n", __func__);\r\nstatus = -EINVAL;\r\ngoto release_lock;\r\n}\r\nurb->context = tdev;\r\nstatus = usb_submit_urb(urb, GFP_KERNEL);\r\nif (status) {\r\ndev_err(&port->dev, "%s - submit interrupt urb failed, %d\n", __func__, status);\r\ngoto release_lock;\r\n}\r\n}\r\nif (tty)\r\nti_set_termios(tty, port, &tty->termios);\r\ndev_dbg(&port->dev, "%s - sending TI_OPEN_PORT\n", __func__);\r\nstatus = ti_command_out_sync(tdev, TI_OPEN_PORT,\r\n(__u8)(TI_UART1_PORT + port_number), open_settings, NULL, 0);\r\nif (status) {\r\ndev_err(&port->dev, "%s - cannot send open command, %d\n",\r\n__func__, status);\r\ngoto unlink_int_urb;\r\n}\r\ndev_dbg(&port->dev, "%s - sending TI_START_PORT\n", __func__);\r\nstatus = ti_command_out_sync(tdev, TI_START_PORT,\r\n(__u8)(TI_UART1_PORT + port_number), 0, NULL, 0);\r\nif (status) {\r\ndev_err(&port->dev, "%s - cannot send start command, %d\n",\r\n__func__, status);\r\ngoto unlink_int_urb;\r\n}\r\ndev_dbg(&port->dev, "%s - sending TI_PURGE_PORT\n", __func__);\r\nstatus = ti_command_out_sync(tdev, TI_PURGE_PORT,\r\n(__u8)(TI_UART1_PORT + port_number), TI_PURGE_INPUT, NULL, 0);\r\nif (status) {\r\ndev_err(&port->dev, "%s - cannot clear input buffers, %d\n",\r\n__func__, status);\r\ngoto unlink_int_urb;\r\n}\r\nstatus = ti_command_out_sync(tdev, TI_PURGE_PORT,\r\n(__u8)(TI_UART1_PORT + port_number), TI_PURGE_OUTPUT, NULL, 0);\r\nif (status) {\r\ndev_err(&port->dev, "%s - cannot clear output buffers, %d\n",\r\n__func__, status);\r\ngoto unlink_int_urb;\r\n}\r\nusb_clear_halt(dev, port->write_urb->pipe);\r\nusb_clear_halt(dev, port->read_urb->pipe);\r\nif (tty)\r\nti_set_termios(tty, port, &tty->termios);\r\ndev_dbg(&port->dev, "%s - sending TI_OPEN_PORT (2)\n", __func__);\r\nstatus = ti_command_out_sync(tdev, TI_OPEN_PORT,\r\n(__u8)(TI_UART1_PORT + port_number), open_settings, NULL, 0);\r\nif (status) {\r\ndev_err(&port->dev, "%s - cannot send open command (2), %d\n",\r\n__func__, status);\r\ngoto unlink_int_urb;\r\n}\r\ndev_dbg(&port->dev, "%s - sending TI_START_PORT (2)\n", __func__);\r\nstatus = ti_command_out_sync(tdev, TI_START_PORT,\r\n(__u8)(TI_UART1_PORT + port_number), 0, NULL, 0);\r\nif (status) {\r\ndev_err(&port->dev, "%s - cannot send start command (2), %d\n",\r\n__func__, status);\r\ngoto unlink_int_urb;\r\n}\r\ndev_dbg(&port->dev, "%s - start read urb\n", __func__);\r\nurb = port->read_urb;\r\nif (!urb) {\r\ndev_err(&port->dev, "%s - no read urb\n", __func__);\r\nstatus = -EINVAL;\r\ngoto unlink_int_urb;\r\n}\r\ntport->tp_read_urb_state = TI_READ_URB_RUNNING;\r\nurb->context = tport;\r\nstatus = usb_submit_urb(urb, GFP_KERNEL);\r\nif (status) {\r\ndev_err(&port->dev, "%s - submit read urb failed, %d\n",\r\n__func__, status);\r\ngoto unlink_int_urb;\r\n}\r\ntport->tp_is_open = 1;\r\n++tdev->td_open_port_count;\r\ngoto release_lock;\r\nunlink_int_urb:\r\nif (tdev->td_open_port_count == 0)\r\nusb_kill_urb(port->serial->port[0]->interrupt_in_urb);\r\nrelease_lock:\r\nmutex_unlock(&tdev->td_open_close_lock);\r\ndev_dbg(&port->dev, "%s - exit %d\n", __func__, status);\r\nreturn status;\r\n}\r\nstatic void ti_close(struct usb_serial_port *port)\r\n{\r\nstruct ti_device *tdev;\r\nstruct ti_port *tport;\r\nint port_number;\r\nint status;\r\nint do_unlock;\r\nunsigned long flags;\r\ntdev = usb_get_serial_data(port->serial);\r\ntport = usb_get_serial_port_data(port);\r\nif (tdev == NULL || tport == NULL)\r\nreturn;\r\ntport->tp_is_open = 0;\r\nusb_kill_urb(port->read_urb);\r\nusb_kill_urb(port->write_urb);\r\ntport->tp_write_urb_in_use = 0;\r\nspin_lock_irqsave(&tport->tp_lock, flags);\r\nkfifo_reset_out(&port->write_fifo);\r\nspin_unlock_irqrestore(&tport->tp_lock, flags);\r\nport_number = port->port_number;\r\ndev_dbg(&port->dev, "%s - sending TI_CLOSE_PORT\n", __func__);\r\nstatus = ti_command_out_sync(tdev, TI_CLOSE_PORT,\r\n(__u8)(TI_UART1_PORT + port_number), 0, NULL, 0);\r\nif (status)\r\ndev_err(&port->dev,\r\n"%s - cannot send close port command, %d\n"\r\n, __func__, status);\r\ndo_unlock = !mutex_lock_interruptible(&tdev->td_open_close_lock);\r\n--tport->tp_tdev->td_open_port_count;\r\nif (tport->tp_tdev->td_open_port_count <= 0) {\r\nusb_kill_urb(port->serial->port[0]->interrupt_in_urb);\r\ntport->tp_tdev->td_open_port_count = 0;\r\n}\r\nif (do_unlock)\r\nmutex_unlock(&tdev->td_open_close_lock);\r\n}\r\nstatic int ti_write(struct tty_struct *tty, struct usb_serial_port *port,\r\nconst unsigned char *data, int count)\r\n{\r\nstruct ti_port *tport = usb_get_serial_port_data(port);\r\nif (count == 0) {\r\ndev_dbg(&port->dev, "%s - write request of 0 bytes\n", __func__);\r\nreturn 0;\r\n}\r\nif (tport == NULL || !tport->tp_is_open)\r\nreturn -ENODEV;\r\ncount = kfifo_in_locked(&port->write_fifo, data, count,\r\n&tport->tp_lock);\r\nti_send(tport);\r\nreturn count;\r\n}\r\nstatic int ti_write_room(struct tty_struct *tty)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\nstruct ti_port *tport = usb_get_serial_port_data(port);\r\nint room = 0;\r\nunsigned long flags;\r\nif (tport == NULL)\r\nreturn 0;\r\nspin_lock_irqsave(&tport->tp_lock, flags);\r\nroom = kfifo_avail(&port->write_fifo);\r\nspin_unlock_irqrestore(&tport->tp_lock, flags);\r\ndev_dbg(&port->dev, "%s - returns %d\n", __func__, room);\r\nreturn room;\r\n}\r\nstatic int ti_chars_in_buffer(struct tty_struct *tty)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\nstruct ti_port *tport = usb_get_serial_port_data(port);\r\nint chars = 0;\r\nunsigned long flags;\r\nif (tport == NULL)\r\nreturn 0;\r\nspin_lock_irqsave(&tport->tp_lock, flags);\r\nchars = kfifo_len(&port->write_fifo);\r\nspin_unlock_irqrestore(&tport->tp_lock, flags);\r\ndev_dbg(&port->dev, "%s - returns %d\n", __func__, chars);\r\nreturn chars;\r\n}\r\nstatic bool ti_tx_empty(struct usb_serial_port *port)\r\n{\r\nstruct ti_port *tport = usb_get_serial_port_data(port);\r\nint ret;\r\nu8 lsr;\r\nret = ti_get_lsr(tport, &lsr);\r\nif (!ret && !(lsr & TI_LSR_TX_EMPTY))\r\nreturn false;\r\nreturn true;\r\n}\r\nstatic void ti_throttle(struct tty_struct *tty)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\nstruct ti_port *tport = usb_get_serial_port_data(port);\r\nif (tport == NULL)\r\nreturn;\r\nif (I_IXOFF(tty) || C_CRTSCTS(tty))\r\nti_stop_read(tport, tty);\r\n}\r\nstatic void ti_unthrottle(struct tty_struct *tty)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\nstruct ti_port *tport = usb_get_serial_port_data(port);\r\nint status;\r\nif (tport == NULL)\r\nreturn;\r\nif (I_IXOFF(tty) || C_CRTSCTS(tty)) {\r\nstatus = ti_restart_read(tport, tty);\r\nif (status)\r\ndev_err(&port->dev, "%s - cannot restart read, %d\n",\r\n__func__, status);\r\n}\r\n}\r\nstatic int ti_ioctl(struct tty_struct *tty,\r\nunsigned int cmd, unsigned long arg)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\nstruct ti_port *tport = usb_get_serial_port_data(port);\r\nif (tport == NULL)\r\nreturn -ENODEV;\r\nswitch (cmd) {\r\ncase TIOCGSERIAL:\r\ndev_dbg(&port->dev, "%s - TIOCGSERIAL\n", __func__);\r\nreturn ti_get_serial_info(tport,\r\n(struct serial_struct __user *)arg);\r\ncase TIOCSSERIAL:\r\ndev_dbg(&port->dev, "%s - TIOCSSERIAL\n", __func__);\r\nreturn ti_set_serial_info(tty, tport,\r\n(struct serial_struct __user *)arg);\r\n}\r\nreturn -ENOIOCTLCMD;\r\n}\r\nstatic void ti_set_termios(struct tty_struct *tty,\r\nstruct usb_serial_port *port, struct ktermios *old_termios)\r\n{\r\nstruct ti_port *tport = usb_get_serial_port_data(port);\r\nstruct ti_uart_config *config;\r\ntcflag_t cflag, iflag;\r\nint baud;\r\nint status;\r\nint port_number = port->port_number;\r\nunsigned int mcr;\r\ncflag = tty->termios.c_cflag;\r\niflag = tty->termios.c_iflag;\r\ndev_dbg(&port->dev, "%s - cflag %08x, iflag %08x\n", __func__, cflag, iflag);\r\ndev_dbg(&port->dev, "%s - old clfag %08x, old iflag %08x\n", __func__,\r\nold_termios->c_cflag, old_termios->c_iflag);\r\nif (tport == NULL)\r\nreturn;\r\nconfig = kmalloc(sizeof(*config), GFP_KERNEL);\r\nif (!config)\r\nreturn;\r\nconfig->wFlags = 0;\r\nconfig->wFlags |= TI_UART_ENABLE_MS_INTS;\r\nconfig->wFlags |= TI_UART_ENABLE_AUTO_START_DMA;\r\nconfig->bUartMode = (__u8)(tport->tp_uart_mode);\r\nswitch (cflag & CSIZE) {\r\ncase CS5:\r\nconfig->bDataBits = TI_UART_5_DATA_BITS;\r\nbreak;\r\ncase CS6:\r\nconfig->bDataBits = TI_UART_6_DATA_BITS;\r\nbreak;\r\ncase CS7:\r\nconfig->bDataBits = TI_UART_7_DATA_BITS;\r\nbreak;\r\ndefault:\r\ncase CS8:\r\nconfig->bDataBits = TI_UART_8_DATA_BITS;\r\nbreak;\r\n}\r\ntty->termios.c_cflag &= ~CMSPAR;\r\nif (cflag & PARENB) {\r\nif (cflag & PARODD) {\r\nconfig->wFlags |= TI_UART_ENABLE_PARITY_CHECKING;\r\nconfig->bParity = TI_UART_ODD_PARITY;\r\n} else {\r\nconfig->wFlags |= TI_UART_ENABLE_PARITY_CHECKING;\r\nconfig->bParity = TI_UART_EVEN_PARITY;\r\n}\r\n} else {\r\nconfig->wFlags &= ~TI_UART_ENABLE_PARITY_CHECKING;\r\nconfig->bParity = TI_UART_NO_PARITY;\r\n}\r\nif (cflag & CSTOPB)\r\nconfig->bStopBits = TI_UART_2_STOP_BITS;\r\nelse\r\nconfig->bStopBits = TI_UART_1_STOP_BITS;\r\nif (cflag & CRTSCTS) {\r\nif ((cflag & CBAUD) != B0)\r\nconfig->wFlags |= TI_UART_ENABLE_RTS_IN;\r\nconfig->wFlags |= TI_UART_ENABLE_CTS_OUT;\r\n} else {\r\nti_restart_read(tport, tty);\r\n}\r\nif (I_IXOFF(tty) || I_IXON(tty)) {\r\nconfig->cXon = START_CHAR(tty);\r\nconfig->cXoff = STOP_CHAR(tty);\r\nif (I_IXOFF(tty))\r\nconfig->wFlags |= TI_UART_ENABLE_X_IN;\r\nelse\r\nti_restart_read(tport, tty);\r\nif (I_IXON(tty))\r\nconfig->wFlags |= TI_UART_ENABLE_X_OUT;\r\n}\r\nbaud = tty_get_baud_rate(tty);\r\nif (!baud)\r\nbaud = 9600;\r\nif (tport->tp_tdev->td_is_3410)\r\nconfig->wBaudRate = (__u16)((923077 + baud/2) / baud);\r\nelse\r\nconfig->wBaudRate = (__u16)((461538 + baud/2) / baud);\r\nif ((cflag & CBAUD) != B0)\r\ntty_encode_baud_rate(tty, baud, baud);\r\ndev_dbg(&port->dev,\r\n"%s - BaudRate=%d, wBaudRate=%d, wFlags=0x%04X, bDataBits=%d, bParity=%d, bStopBits=%d, cXon=%d, cXoff=%d, bUartMode=%d\n",\r\n__func__, baud, config->wBaudRate, config->wFlags,\r\nconfig->bDataBits, config->bParity, config->bStopBits,\r\nconfig->cXon, config->cXoff, config->bUartMode);\r\ncpu_to_be16s(&config->wBaudRate);\r\ncpu_to_be16s(&config->wFlags);\r\nstatus = ti_command_out_sync(tport->tp_tdev, TI_SET_CONFIG,\r\n(__u8)(TI_UART1_PORT + port_number), 0, (__u8 *)config,\r\nsizeof(*config));\r\nif (status)\r\ndev_err(&port->dev, "%s - cannot set config on port %d, %d\n",\r\n__func__, port_number, status);\r\nmcr = tport->tp_shadow_mcr;\r\nif ((cflag & CBAUD) == B0)\r\nmcr &= ~(TI_MCR_DTR | TI_MCR_RTS);\r\nstatus = ti_set_mcr(tport, mcr);\r\nif (status)\r\ndev_err(&port->dev,\r\n"%s - cannot set modem control on port %d, %d\n",\r\n__func__, port_number, status);\r\nkfree(config);\r\n}\r\nstatic int ti_tiocmget(struct tty_struct *tty)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\nstruct ti_port *tport = usb_get_serial_port_data(port);\r\nunsigned int result;\r\nunsigned int msr;\r\nunsigned int mcr;\r\nunsigned long flags;\r\nif (tport == NULL)\r\nreturn -ENODEV;\r\nspin_lock_irqsave(&tport->tp_lock, flags);\r\nmsr = tport->tp_msr;\r\nmcr = tport->tp_shadow_mcr;\r\nspin_unlock_irqrestore(&tport->tp_lock, flags);\r\nresult = ((mcr & TI_MCR_DTR) ? TIOCM_DTR : 0)\r\n| ((mcr & TI_MCR_RTS) ? TIOCM_RTS : 0)\r\n| ((mcr & TI_MCR_LOOP) ? TIOCM_LOOP : 0)\r\n| ((msr & TI_MSR_CTS) ? TIOCM_CTS : 0)\r\n| ((msr & TI_MSR_CD) ? TIOCM_CAR : 0)\r\n| ((msr & TI_MSR_RI) ? TIOCM_RI : 0)\r\n| ((msr & TI_MSR_DSR) ? TIOCM_DSR : 0);\r\ndev_dbg(&port->dev, "%s - 0x%04X\n", __func__, result);\r\nreturn result;\r\n}\r\nstatic int ti_tiocmset(struct tty_struct *tty,\r\nunsigned int set, unsigned int clear)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\nstruct ti_port *tport = usb_get_serial_port_data(port);\r\nunsigned int mcr;\r\nunsigned long flags;\r\nif (tport == NULL)\r\nreturn -ENODEV;\r\nspin_lock_irqsave(&tport->tp_lock, flags);\r\nmcr = tport->tp_shadow_mcr;\r\nif (set & TIOCM_RTS)\r\nmcr |= TI_MCR_RTS;\r\nif (set & TIOCM_DTR)\r\nmcr |= TI_MCR_DTR;\r\nif (set & TIOCM_LOOP)\r\nmcr |= TI_MCR_LOOP;\r\nif (clear & TIOCM_RTS)\r\nmcr &= ~TI_MCR_RTS;\r\nif (clear & TIOCM_DTR)\r\nmcr &= ~TI_MCR_DTR;\r\nif (clear & TIOCM_LOOP)\r\nmcr &= ~TI_MCR_LOOP;\r\nspin_unlock_irqrestore(&tport->tp_lock, flags);\r\nreturn ti_set_mcr(tport, mcr);\r\n}\r\nstatic void ti_break(struct tty_struct *tty, int break_state)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\nstruct ti_port *tport = usb_get_serial_port_data(port);\r\nint status;\r\ndev_dbg(&port->dev, "%s - state = %d\n", __func__, break_state);\r\nif (tport == NULL)\r\nreturn;\r\nstatus = ti_write_byte(port, tport->tp_tdev,\r\ntport->tp_uart_base_addr + TI_UART_OFFSET_LCR,\r\nTI_LCR_BREAK, break_state == -1 ? TI_LCR_BREAK : 0);\r\nif (status)\r\ndev_dbg(&port->dev, "%s - error setting break, %d\n", __func__, status);\r\n}\r\nstatic void ti_interrupt_callback(struct urb *urb)\r\n{\r\nstruct ti_device *tdev = urb->context;\r\nstruct usb_serial_port *port;\r\nstruct usb_serial *serial = tdev->td_serial;\r\nstruct ti_port *tport;\r\nstruct device *dev = &urb->dev->dev;\r\nunsigned char *data = urb->transfer_buffer;\r\nint length = urb->actual_length;\r\nint port_number;\r\nint function;\r\nint status = urb->status;\r\nint retval;\r\n__u8 msr;\r\nswitch (status) {\r\ncase 0:\r\nbreak;\r\ncase -ECONNRESET:\r\ncase -ENOENT:\r\ncase -ESHUTDOWN:\r\ndev_dbg(dev, "%s - urb shutting down, %d\n", __func__, status);\r\ntdev->td_urb_error = 1;\r\nreturn;\r\ndefault:\r\ndev_err(dev, "%s - nonzero urb status, %d\n", __func__, status);\r\ntdev->td_urb_error = 1;\r\ngoto exit;\r\n}\r\nif (length != 2) {\r\ndev_dbg(dev, "%s - bad packet size, %d\n", __func__, length);\r\ngoto exit;\r\n}\r\nif (data[0] == TI_CODE_HARDWARE_ERROR) {\r\ndev_err(dev, "%s - hardware error, %d\n", __func__, data[1]);\r\ngoto exit;\r\n}\r\nport_number = TI_GET_PORT_FROM_CODE(data[0]);\r\nfunction = TI_GET_FUNC_FROM_CODE(data[0]);\r\ndev_dbg(dev, "%s - port_number %d, function %d, data 0x%02X\n",\r\n__func__, port_number, function, data[1]);\r\nif (port_number >= serial->num_ports) {\r\ndev_err(dev, "%s - bad port number, %d\n",\r\n__func__, port_number);\r\ngoto exit;\r\n}\r\nport = serial->port[port_number];\r\ntport = usb_get_serial_port_data(port);\r\nif (!tport)\r\ngoto exit;\r\nswitch (function) {\r\ncase TI_CODE_DATA_ERROR:\r\ndev_err(dev, "%s - DATA ERROR, port %d, data 0x%02X\n",\r\n__func__, port_number, data[1]);\r\nbreak;\r\ncase TI_CODE_MODEM_STATUS:\r\nmsr = data[1];\r\ndev_dbg(dev, "%s - port %d, msr 0x%02X\n", __func__, port_number, msr);\r\nti_handle_new_msr(tport, msr);\r\nbreak;\r\ndefault:\r\ndev_err(dev, "%s - unknown interrupt code, 0x%02X\n",\r\n__func__, data[1]);\r\nbreak;\r\n}\r\nexit:\r\nretval = usb_submit_urb(urb, GFP_ATOMIC);\r\nif (retval)\r\ndev_err(dev, "%s - resubmit interrupt urb failed, %d\n",\r\n__func__, retval);\r\n}\r\nstatic void ti_bulk_in_callback(struct urb *urb)\r\n{\r\nstruct ti_port *tport = urb->context;\r\nstruct usb_serial_port *port = tport->tp_port;\r\nstruct device *dev = &urb->dev->dev;\r\nint status = urb->status;\r\nint retval = 0;\r\nswitch (status) {\r\ncase 0:\r\nbreak;\r\ncase -ECONNRESET:\r\ncase -ENOENT:\r\ncase -ESHUTDOWN:\r\ndev_dbg(dev, "%s - urb shutting down, %d\n", __func__, status);\r\ntport->tp_tdev->td_urb_error = 1;\r\nreturn;\r\ndefault:\r\ndev_err(dev, "%s - nonzero urb status, %d\n",\r\n__func__, status);\r\ntport->tp_tdev->td_urb_error = 1;\r\n}\r\nif (status == -EPIPE)\r\ngoto exit;\r\nif (status) {\r\ndev_err(dev, "%s - stopping read!\n", __func__);\r\nreturn;\r\n}\r\nif (urb->actual_length) {\r\nusb_serial_debug_data(dev, __func__, urb->actual_length,\r\nurb->transfer_buffer);\r\nif (!tport->tp_is_open)\r\ndev_dbg(dev, "%s - port closed, dropping data\n",\r\n__func__);\r\nelse\r\nti_recv(port, urb->transfer_buffer, urb->actual_length);\r\nspin_lock(&tport->tp_lock);\r\nport->icount.rx += urb->actual_length;\r\nspin_unlock(&tport->tp_lock);\r\n}\r\nexit:\r\nspin_lock(&tport->tp_lock);\r\nif (tport->tp_read_urb_state == TI_READ_URB_RUNNING)\r\nretval = usb_submit_urb(urb, GFP_ATOMIC);\r\nelse if (tport->tp_read_urb_state == TI_READ_URB_STOPPING)\r\ntport->tp_read_urb_state = TI_READ_URB_STOPPED;\r\nspin_unlock(&tport->tp_lock);\r\nif (retval)\r\ndev_err(dev, "%s - resubmit read urb failed, %d\n",\r\n__func__, retval);\r\n}\r\nstatic void ti_bulk_out_callback(struct urb *urb)\r\n{\r\nstruct ti_port *tport = urb->context;\r\nstruct usb_serial_port *port = tport->tp_port;\r\nint status = urb->status;\r\ntport->tp_write_urb_in_use = 0;\r\nswitch (status) {\r\ncase 0:\r\nbreak;\r\ncase -ECONNRESET:\r\ncase -ENOENT:\r\ncase -ESHUTDOWN:\r\ndev_dbg(&port->dev, "%s - urb shutting down, %d\n", __func__, status);\r\ntport->tp_tdev->td_urb_error = 1;\r\nreturn;\r\ndefault:\r\ndev_err_console(port, "%s - nonzero urb status, %d\n",\r\n__func__, status);\r\ntport->tp_tdev->td_urb_error = 1;\r\n}\r\nti_send(tport);\r\n}\r\nstatic void ti_recv(struct usb_serial_port *port, unsigned char *data,\r\nint length)\r\n{\r\nint cnt;\r\ndo {\r\ncnt = tty_insert_flip_string(&port->port, data, length);\r\nif (cnt < length) {\r\ndev_err(&port->dev, "%s - dropping data, %d bytes lost\n",\r\n__func__, length - cnt);\r\nif (cnt == 0)\r\nbreak;\r\n}\r\ntty_flip_buffer_push(&port->port);\r\ndata += cnt;\r\nlength -= cnt;\r\n} while (length > 0);\r\n}\r\nstatic void ti_send(struct ti_port *tport)\r\n{\r\nint count, result;\r\nstruct usb_serial_port *port = tport->tp_port;\r\nunsigned long flags;\r\nspin_lock_irqsave(&tport->tp_lock, flags);\r\nif (tport->tp_write_urb_in_use)\r\ngoto unlock;\r\ncount = kfifo_out(&port->write_fifo,\r\nport->write_urb->transfer_buffer,\r\nport->bulk_out_size);\r\nif (count == 0)\r\ngoto unlock;\r\ntport->tp_write_urb_in_use = 1;\r\nspin_unlock_irqrestore(&tport->tp_lock, flags);\r\nusb_serial_debug_data(&port->dev, __func__, count,\r\nport->write_urb->transfer_buffer);\r\nusb_fill_bulk_urb(port->write_urb, port->serial->dev,\r\nusb_sndbulkpipe(port->serial->dev,\r\nport->bulk_out_endpointAddress),\r\nport->write_urb->transfer_buffer, count,\r\nti_bulk_out_callback, tport);\r\nresult = usb_submit_urb(port->write_urb, GFP_ATOMIC);\r\nif (result) {\r\ndev_err_console(port, "%s - submit write urb failed, %d\n",\r\n__func__, result);\r\ntport->tp_write_urb_in_use = 0;\r\n} else {\r\nspin_lock_irqsave(&tport->tp_lock, flags);\r\nport->icount.tx += count;\r\nspin_unlock_irqrestore(&tport->tp_lock, flags);\r\n}\r\ntty_port_tty_wakeup(&port->port);\r\nreturn;\r\nunlock:\r\nspin_unlock_irqrestore(&tport->tp_lock, flags);\r\nreturn;\r\n}\r\nstatic int ti_set_mcr(struct ti_port *tport, unsigned int mcr)\r\n{\r\nunsigned long flags;\r\nint status;\r\nstatus = ti_write_byte(tport->tp_port, tport->tp_tdev,\r\ntport->tp_uart_base_addr + TI_UART_OFFSET_MCR,\r\nTI_MCR_RTS | TI_MCR_DTR | TI_MCR_LOOP, mcr);\r\nspin_lock_irqsave(&tport->tp_lock, flags);\r\nif (!status)\r\ntport->tp_shadow_mcr = mcr;\r\nspin_unlock_irqrestore(&tport->tp_lock, flags);\r\nreturn status;\r\n}\r\nstatic int ti_get_lsr(struct ti_port *tport, u8 *lsr)\r\n{\r\nint size, status;\r\nstruct ti_device *tdev = tport->tp_tdev;\r\nstruct usb_serial_port *port = tport->tp_port;\r\nint port_number = port->port_number;\r\nstruct ti_port_status *data;\r\nsize = sizeof(struct ti_port_status);\r\ndata = kmalloc(size, GFP_KERNEL);\r\nif (!data)\r\nreturn -ENOMEM;\r\nstatus = ti_command_in_sync(tdev, TI_GET_PORT_STATUS,\r\n(__u8)(TI_UART1_PORT+port_number), 0, (__u8 *)data, size);\r\nif (status) {\r\ndev_err(&port->dev,\r\n"%s - get port status command failed, %d\n",\r\n__func__, status);\r\ngoto free_data;\r\n}\r\ndev_dbg(&port->dev, "%s - lsr 0x%02X\n", __func__, data->bLSR);\r\n*lsr = data->bLSR;\r\nfree_data:\r\nkfree(data);\r\nreturn status;\r\n}\r\nstatic int ti_get_serial_info(struct ti_port *tport,\r\nstruct serial_struct __user *ret_arg)\r\n{\r\nstruct usb_serial_port *port = tport->tp_port;\r\nstruct serial_struct ret_serial;\r\nunsigned cwait;\r\nif (!ret_arg)\r\nreturn -EFAULT;\r\ncwait = port->port.closing_wait;\r\nif (cwait != ASYNC_CLOSING_WAIT_NONE)\r\ncwait = jiffies_to_msecs(cwait) / 10;\r\nmemset(&ret_serial, 0, sizeof(ret_serial));\r\nret_serial.type = PORT_16550A;\r\nret_serial.line = port->minor;\r\nret_serial.port = port->port_number;\r\nret_serial.flags = tport->tp_flags;\r\nret_serial.xmit_fifo_size = kfifo_size(&port->write_fifo);\r\nret_serial.baud_base = tport->tp_tdev->td_is_3410 ? 921600 : 460800;\r\nret_serial.closing_wait = cwait;\r\nif (copy_to_user(ret_arg, &ret_serial, sizeof(*ret_arg)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int ti_set_serial_info(struct tty_struct *tty, struct ti_port *tport,\r\nstruct serial_struct __user *new_arg)\r\n{\r\nstruct serial_struct new_serial;\r\nunsigned cwait;\r\nif (copy_from_user(&new_serial, new_arg, sizeof(new_serial)))\r\nreturn -EFAULT;\r\ncwait = new_serial.closing_wait;\r\nif (cwait != ASYNC_CLOSING_WAIT_NONE)\r\ncwait = msecs_to_jiffies(10 * new_serial.closing_wait);\r\ntport->tp_flags = new_serial.flags & TI_SET_SERIAL_FLAGS;\r\ntport->tp_port->port.closing_wait = cwait;\r\nreturn 0;\r\n}\r\nstatic void ti_handle_new_msr(struct ti_port *tport, __u8 msr)\r\n{\r\nstruct async_icount *icount;\r\nstruct tty_struct *tty;\r\nunsigned long flags;\r\ndev_dbg(&tport->tp_port->dev, "%s - msr 0x%02X\n", __func__, msr);\r\nif (msr & TI_MSR_DELTA_MASK) {\r\nspin_lock_irqsave(&tport->tp_lock, flags);\r\nicount = &tport->tp_port->icount;\r\nif (msr & TI_MSR_DELTA_CTS)\r\nicount->cts++;\r\nif (msr & TI_MSR_DELTA_DSR)\r\nicount->dsr++;\r\nif (msr & TI_MSR_DELTA_CD)\r\nicount->dcd++;\r\nif (msr & TI_MSR_DELTA_RI)\r\nicount->rng++;\r\nwake_up_interruptible(&tport->tp_port->port.delta_msr_wait);\r\nspin_unlock_irqrestore(&tport->tp_lock, flags);\r\n}\r\ntport->tp_msr = msr & TI_MSR_MASK;\r\ntty = tty_port_tty_get(&tport->tp_port->port);\r\nif (tty && C_CRTSCTS(tty)) {\r\nif (msr & TI_MSR_CTS)\r\ntty_wakeup(tty);\r\n}\r\ntty_kref_put(tty);\r\n}\r\nstatic void ti_stop_read(struct ti_port *tport, struct tty_struct *tty)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&tport->tp_lock, flags);\r\nif (tport->tp_read_urb_state == TI_READ_URB_RUNNING)\r\ntport->tp_read_urb_state = TI_READ_URB_STOPPING;\r\nspin_unlock_irqrestore(&tport->tp_lock, flags);\r\n}\r\nstatic int ti_restart_read(struct ti_port *tport, struct tty_struct *tty)\r\n{\r\nstruct urb *urb;\r\nint status = 0;\r\nunsigned long flags;\r\nspin_lock_irqsave(&tport->tp_lock, flags);\r\nif (tport->tp_read_urb_state == TI_READ_URB_STOPPED) {\r\ntport->tp_read_urb_state = TI_READ_URB_RUNNING;\r\nurb = tport->tp_port->read_urb;\r\nspin_unlock_irqrestore(&tport->tp_lock, flags);\r\nurb->context = tport;\r\nstatus = usb_submit_urb(urb, GFP_KERNEL);\r\n} else {\r\ntport->tp_read_urb_state = TI_READ_URB_RUNNING;\r\nspin_unlock_irqrestore(&tport->tp_lock, flags);\r\n}\r\nreturn status;\r\n}\r\nstatic int ti_command_out_sync(struct ti_device *tdev, __u8 command,\r\n__u16 moduleid, __u16 value, __u8 *data, int size)\r\n{\r\nint status;\r\nstatus = usb_control_msg(tdev->td_serial->dev,\r\nusb_sndctrlpipe(tdev->td_serial->dev, 0), command,\r\n(USB_TYPE_VENDOR | USB_RECIP_DEVICE | USB_DIR_OUT),\r\nvalue, moduleid, data, size, 1000);\r\nif (status == size)\r\nstatus = 0;\r\nif (status > 0)\r\nstatus = -ECOMM;\r\nreturn status;\r\n}\r\nstatic int ti_command_in_sync(struct ti_device *tdev, __u8 command,\r\n__u16 moduleid, __u16 value, __u8 *data, int size)\r\n{\r\nint status;\r\nstatus = usb_control_msg(tdev->td_serial->dev,\r\nusb_rcvctrlpipe(tdev->td_serial->dev, 0), command,\r\n(USB_TYPE_VENDOR | USB_RECIP_DEVICE | USB_DIR_IN),\r\nvalue, moduleid, data, size, 1000);\r\nif (status == size)\r\nstatus = 0;\r\nif (status > 0)\r\nstatus = -ECOMM;\r\nreturn status;\r\n}\r\nstatic int ti_write_byte(struct usb_serial_port *port,\r\nstruct ti_device *tdev, unsigned long addr,\r\n__u8 mask, __u8 byte)\r\n{\r\nint status;\r\nunsigned int size;\r\nstruct ti_write_data_bytes *data;\r\ndev_dbg(&port->dev, "%s - addr 0x%08lX, mask 0x%02X, byte 0x%02X\n", __func__,\r\naddr, mask, byte);\r\nsize = sizeof(struct ti_write_data_bytes) + 2;\r\ndata = kmalloc(size, GFP_KERNEL);\r\nif (!data)\r\nreturn -ENOMEM;\r\ndata->bAddrType = TI_RW_DATA_ADDR_XDATA;\r\ndata->bDataType = TI_RW_DATA_BYTE;\r\ndata->bDataCounter = 1;\r\ndata->wBaseAddrHi = cpu_to_be16(addr>>16);\r\ndata->wBaseAddrLo = cpu_to_be16(addr);\r\ndata->bData[0] = mask;\r\ndata->bData[1] = byte;\r\nstatus = ti_command_out_sync(tdev, TI_WRITE_DATA, TI_RAM_PORT, 0,\r\n(__u8 *)data, size);\r\nif (status < 0)\r\ndev_err(&port->dev, "%s - failed, %d\n", __func__, status);\r\nkfree(data);\r\nreturn status;\r\n}\r\nstatic int ti_do_download(struct usb_device *dev, int pipe,\r\nu8 *buffer, int size)\r\n{\r\nint pos;\r\nu8 cs = 0;\r\nint done;\r\nstruct ti_firmware_header *header;\r\nint status = 0;\r\nint len;\r\nfor (pos = sizeof(struct ti_firmware_header); pos < size; pos++)\r\ncs = (__u8)(cs + buffer[pos]);\r\nheader = (struct ti_firmware_header *)buffer;\r\nheader->wLength = cpu_to_le16((__u16)(size\r\n- sizeof(struct ti_firmware_header)));\r\nheader->bCheckSum = cs;\r\ndev_dbg(&dev->dev, "%s - downloading firmware\n", __func__);\r\nfor (pos = 0; pos < size; pos += done) {\r\nlen = min(size - pos, TI_DOWNLOAD_MAX_PACKET_SIZE);\r\nstatus = usb_bulk_msg(dev, pipe, buffer + pos, len,\r\n&done, 1000);\r\nif (status)\r\nbreak;\r\n}\r\nreturn status;\r\n}\r\nstatic int ti_download_firmware(struct ti_device *tdev)\r\n{\r\nint status;\r\nint buffer_size;\r\n__u8 *buffer;\r\nstruct usb_device *dev = tdev->td_serial->dev;\r\nunsigned int pipe = usb_sndbulkpipe(dev,\r\ntdev->td_serial->port[0]->bulk_out_endpointAddress);\r\nconst struct firmware *fw_p;\r\nchar buf[32];\r\nsprintf(buf, "ti_usb-v%04x-p%04x.fw",\r\nle16_to_cpu(dev->descriptor.idVendor),\r\nle16_to_cpu(dev->descriptor.idProduct));\r\nstatus = request_firmware(&fw_p, buf, &dev->dev);\r\nif (status != 0) {\r\nbuf[0] = '\0';\r\nif (le16_to_cpu(dev->descriptor.idVendor) == MTS_VENDOR_ID) {\r\nswitch (le16_to_cpu(dev->descriptor.idProduct)) {\r\ncase MTS_CDMA_PRODUCT_ID:\r\nstrcpy(buf, "mts_cdma.fw");\r\nbreak;\r\ncase MTS_GSM_PRODUCT_ID:\r\nstrcpy(buf, "mts_gsm.fw");\r\nbreak;\r\ncase MTS_EDGE_PRODUCT_ID:\r\nstrcpy(buf, "mts_edge.fw");\r\nbreak;\r\ncase MTS_MT9234MU_PRODUCT_ID:\r\nstrcpy(buf, "mts_mt9234mu.fw");\r\nbreak;\r\ncase MTS_MT9234ZBA_PRODUCT_ID:\r\nstrcpy(buf, "mts_mt9234zba.fw");\r\nbreak;\r\ncase MTS_MT9234ZBAOLD_PRODUCT_ID:\r\nstrcpy(buf, "mts_mt9234zba.fw");\r\nbreak; }\r\n}\r\nif (buf[0] == '\0') {\r\nif (tdev->td_is_3410)\r\nstrcpy(buf, "ti_3410.fw");\r\nelse\r\nstrcpy(buf, "ti_5052.fw");\r\n}\r\nstatus = request_firmware(&fw_p, buf, &dev->dev);\r\n}\r\nif (status) {\r\ndev_err(&dev->dev, "%s - firmware not found\n", __func__);\r\nreturn -ENOENT;\r\n}\r\nif (fw_p->size > TI_FIRMWARE_BUF_SIZE) {\r\ndev_err(&dev->dev, "%s - firmware too large %zu\n", __func__, fw_p->size);\r\nrelease_firmware(fw_p);\r\nreturn -ENOENT;\r\n}\r\nbuffer_size = TI_FIRMWARE_BUF_SIZE + sizeof(struct ti_firmware_header);\r\nbuffer = kmalloc(buffer_size, GFP_KERNEL);\r\nif (buffer) {\r\nmemcpy(buffer, fw_p->data, fw_p->size);\r\nmemset(buffer + fw_p->size, 0xff, buffer_size - fw_p->size);\r\nstatus = ti_do_download(dev, pipe, buffer, fw_p->size);\r\nkfree(buffer);\r\n} else {\r\nstatus = -ENOMEM;\r\n}\r\nrelease_firmware(fw_p);\r\nif (status) {\r\ndev_err(&dev->dev, "%s - error downloading firmware, %d\n",\r\n__func__, status);\r\nreturn status;\r\n}\r\ndev_dbg(&dev->dev, "%s - download successful\n", __func__);\r\nreturn 0;\r\n}
