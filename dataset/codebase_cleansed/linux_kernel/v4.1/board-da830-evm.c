static int da830_evm_usb_set_power(unsigned port, int on)\r\n{\r\ngpio_set_value(ON_BD_USB_DRV, on);\r\nreturn 0;\r\n}\r\nstatic int da830_evm_usb_get_power(unsigned port)\r\n{\r\nreturn gpio_get_value(ON_BD_USB_DRV);\r\n}\r\nstatic int da830_evm_usb_get_oci(unsigned port)\r\n{\r\nreturn !gpio_get_value(ON_BD_USB_OVC);\r\n}\r\nstatic int da830_evm_usb_ocic_notify(da8xx_ocic_handler_t handler)\r\n{\r\nint irq = gpio_to_irq(ON_BD_USB_OVC);\r\nint error = 0;\r\nif (handler != NULL) {\r\nda830_evm_usb_ocic_handler = handler;\r\nerror = request_irq(irq, da830_evm_usb_ocic_irq,\r\nIRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING,\r\n"OHCI over-current indicator", NULL);\r\nif (error)\r\npr_err("%s: could not request IRQ to watch over-current indicator changes\n",\r\n__func__);\r\n} else\r\nfree_irq(irq, NULL);\r\nreturn error;\r\n}\r\nstatic irqreturn_t da830_evm_usb_ocic_irq(int irq, void *dev_id)\r\n{\r\nda830_evm_usb_ocic_handler(&da830_evm_usb11_pdata, 1);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic __init void da830_evm_usb_init(void)\r\n{\r\nu32 cfgchip2;\r\nint ret;\r\ncfgchip2 = __raw_readl(DA8XX_SYSCFG0_VIRT(DA8XX_CFGCHIP2_REG));\r\ncfgchip2 &= ~CFGCHIP2_REFFREQ;\r\ncfgchip2 |= CFGCHIP2_REFFREQ_24MHZ;\r\ncfgchip2 &= ~CFGCHIP2_USB1PHYCLKMUX;\r\ncfgchip2 |= CFGCHIP2_USB2PHYCLKMUX;\r\ncfgchip2 &= ~CFGCHIP2_OTGMODE;\r\n#ifdef CONFIG_USB_MUSB_HOST\r\ncfgchip2 |= CFGCHIP2_FORCE_HOST;\r\n#else\r\ncfgchip2 |= CFGCHIP2_SESENDEN | CFGCHIP2_VBDTCTEN;\r\n#endif\r\n__raw_writel(cfgchip2, DA8XX_SYSCFG0_VIRT(DA8XX_CFGCHIP2_REG));\r\nret = davinci_cfg_reg(DA830_USB0_DRVVBUS);\r\nif (ret)\r\npr_warn("%s: USB 2.0 PinMux setup failed: %d\n", __func__, ret);\r\nelse {\r\nret = da8xx_register_usb20(1000, 3);\r\nif (ret)\r\npr_warn("%s: USB 2.0 registration failed: %d\n",\r\n__func__, ret);\r\n}\r\nret = davinci_cfg_reg_list(da830_evm_usb11_pins);\r\nif (ret) {\r\npr_warn("%s: USB 1.1 PinMux setup failed: %d\n", __func__, ret);\r\nreturn;\r\n}\r\nret = gpio_request(ON_BD_USB_DRV, "ON_BD_USB_DRV");\r\nif (ret) {\r\npr_err("%s: failed to request GPIO for USB 1.1 port power control: %d\n",\r\n__func__, ret);\r\nreturn;\r\n}\r\ngpio_direction_output(ON_BD_USB_DRV, 0);\r\nret = gpio_request(ON_BD_USB_OVC, "ON_BD_USB_OVC");\r\nif (ret) {\r\npr_err("%s: failed to request GPIO for USB 1.1 port over-current indicator: %d\n",\r\n__func__, ret);\r\nreturn;\r\n}\r\ngpio_direction_input(ON_BD_USB_OVC);\r\nret = da8xx_register_usb11(&da830_evm_usb11_pdata);\r\nif (ret)\r\npr_warn("%s: USB 1.1 registration failed: %d\n", __func__, ret);\r\n}\r\nstatic int da830_evm_mmc_get_ro(int index)\r\n{\r\nreturn gpio_get_value(DA830_MMCSD_WP_PIN);\r\n}\r\nstatic int da830_evm_mmc_get_cd(int index)\r\n{\r\nreturn !gpio_get_value(DA830_MMCSD_CD_PIN);\r\n}\r\nstatic inline void da830_evm_init_mmc(void)\r\n{\r\nint ret;\r\nret = davinci_cfg_reg_list(da830_evm_mmc_sd_pins);\r\nif (ret) {\r\npr_warn("%s: mmc/sd mux setup failed: %d\n", __func__, ret);\r\nreturn;\r\n}\r\nret = gpio_request(DA830_MMCSD_WP_PIN, "MMC WP");\r\nif (ret) {\r\npr_warn("%s: can not open GPIO %d\n",\r\n__func__, DA830_MMCSD_WP_PIN);\r\nreturn;\r\n}\r\ngpio_direction_input(DA830_MMCSD_WP_PIN);\r\nret = gpio_request(DA830_MMCSD_CD_PIN, "MMC CD\n");\r\nif (ret) {\r\npr_warn("%s: can not open GPIO %d\n",\r\n__func__, DA830_MMCSD_CD_PIN);\r\nreturn;\r\n}\r\ngpio_direction_input(DA830_MMCSD_CD_PIN);\r\nret = da8xx_register_mmcsd0(&da830_evm_mmc_config);\r\nif (ret) {\r\npr_warn("%s: mmc/sd registration failed: %d\n", __func__, ret);\r\ngpio_free(DA830_MMCSD_WP_PIN);\r\n}\r\n}\r\nstatic inline void da830_evm_init_nand(int mux_mode)\r\n{\r\nint ret;\r\nif (HAS_MMC) {\r\npr_warn("WARNING: both MMC/SD and NAND are enabled, but they share AEMIF pins\n"\r\n"\tDisable MMC/SD for NAND support\n");\r\nreturn;\r\n}\r\nret = davinci_cfg_reg_list(da830_evm_emif25_pins);\r\nif (ret)\r\npr_warn("%s: emif25 mux setup failed: %d\n", __func__, ret);\r\nret = platform_device_register(&da830_evm_nand_device);\r\nif (ret)\r\npr_warn("%s: NAND device not registered\n", __func__);\r\nif (davinci_aemif_setup(&da830_evm_nand_device))\r\npr_warn("%s: Cannot configure AEMIF\n", __func__);\r\ngpio_direction_output(mux_mode, 1);\r\n}\r\nstatic inline void da830_evm_init_nand(int mux_mode) { }\r\nstatic inline void da830_evm_init_lcdc(int mux_mode)\r\n{\r\nint ret;\r\nret = davinci_cfg_reg_list(da830_lcdcntl_pins);\r\nif (ret)\r\npr_warn("%s: lcdcntl mux setup failed: %d\n", __func__, ret);\r\nret = da8xx_register_lcdc(&sharp_lcd035q3dg01_pdata);\r\nif (ret)\r\npr_warn("%s: lcd setup failed: %d\n", __func__, ret);\r\ngpio_direction_output(mux_mode, 0);\r\n}\r\nstatic inline void da830_evm_init_lcdc(int mux_mode) { }\r\nstatic int __init da830_evm_ui_expander_setup(struct i2c_client *client,\r\nint gpio, unsigned ngpio, void *context)\r\n{\r\ngpio_request(gpio + 6, "UI MUX_MODE");\r\ngpio_direction_output(gpio + 6, 0);\r\nda830_evm_init_lcdc(gpio + 6);\r\nda830_evm_init_nand(gpio + 6);\r\nreturn 0;\r\n}\r\nstatic int da830_evm_ui_expander_teardown(struct i2c_client *client, int gpio,\r\nunsigned ngpio, void *context)\r\n{\r\ngpio_free(gpio + 6);\r\nreturn 0;\r\n}\r\nstatic __init void da830_evm_init(void)\r\n{\r\nstruct davinci_soc_info *soc_info = &davinci_soc_info;\r\nint ret;\r\nret = da830_register_gpio();\r\nif (ret)\r\npr_warn("%s: GPIO init failed: %d\n", __func__, ret);\r\nret = da830_register_edma(da830_edma_rsv);\r\nif (ret)\r\npr_warn("%s: edma registration failed: %d\n", __func__, ret);\r\nret = davinci_cfg_reg_list(da830_i2c0_pins);\r\nif (ret)\r\npr_warn("%s: i2c0 mux setup failed: %d\n", __func__, ret);\r\nret = da8xx_register_i2c(0, &da830_evm_i2c_0_pdata);\r\nif (ret)\r\npr_warn("%s: i2c0 registration failed: %d\n", __func__, ret);\r\nda830_evm_usb_init();\r\nsoc_info->emac_pdata->rmii_en = 1;\r\nsoc_info->emac_pdata->phy_id = DA830_EVM_PHY_ID;\r\nret = davinci_cfg_reg_list(da830_cpgmac_pins);\r\nif (ret)\r\npr_warn("%s: cpgmac mux setup failed: %d\n", __func__, ret);\r\nret = da8xx_register_emac();\r\nif (ret)\r\npr_warn("%s: emac registration failed: %d\n", __func__, ret);\r\nret = da8xx_register_watchdog();\r\nif (ret)\r\npr_warn("%s: watchdog registration failed: %d\n",\r\n__func__, ret);\r\ndavinci_serial_init(da8xx_serial_device);\r\ni2c_register_board_info(1, da830_evm_i2c_devices,\r\nARRAY_SIZE(da830_evm_i2c_devices));\r\nret = davinci_cfg_reg_list(da830_evm_mcasp1_pins);\r\nif (ret)\r\npr_warn("%s: mcasp1 mux setup failed: %d\n", __func__, ret);\r\nda8xx_register_mcasp(1, &da830_evm_snd_data);\r\nda830_evm_init_mmc();\r\nret = da8xx_register_rtc();\r\nif (ret)\r\npr_warn("%s: rtc setup failed: %d\n", __func__, ret);\r\nret = spi_register_board_info(da830evm_spi_info,\r\nARRAY_SIZE(da830evm_spi_info));\r\nif (ret)\r\npr_warn("%s: spi info registration failed: %d\n",\r\n__func__, ret);\r\nret = da8xx_register_spi_bus(0, ARRAY_SIZE(da830evm_spi_info));\r\nif (ret)\r\npr_warn("%s: spi 0 registration failed: %d\n", __func__, ret);\r\n}\r\nstatic int __init da830_evm_console_init(void)\r\n{\r\nif (!machine_is_davinci_da830_evm())\r\nreturn 0;\r\nreturn add_preferred_console("ttyS", 2, "115200");\r\n}\r\nstatic void __init da830_evm_map_io(void)\r\n{\r\nda830_init();\r\n}
