static void release_slot(struct hotplug_slot *hotplug_slot)\r\n{\r\nstruct slot *slot = hotplug_slot->private;\r\nctrl_dbg(slot->ctrl, "%s: physical_slot = %s\n",\r\n__func__, hotplug_slot_name(hotplug_slot));\r\nkfree(hotplug_slot->ops);\r\nkfree(hotplug_slot->info);\r\nkfree(hotplug_slot);\r\n}\r\nstatic int init_slot(struct controller *ctrl)\r\n{\r\nstruct slot *slot = ctrl->slot;\r\nstruct hotplug_slot *hotplug = NULL;\r\nstruct hotplug_slot_info *info = NULL;\r\nstruct hotplug_slot_ops *ops = NULL;\r\nchar name[SLOT_NAME_SIZE];\r\nint retval = -ENOMEM;\r\nhotplug = kzalloc(sizeof(*hotplug), GFP_KERNEL);\r\nif (!hotplug)\r\ngoto out;\r\ninfo = kzalloc(sizeof(*info), GFP_KERNEL);\r\nif (!info)\r\ngoto out;\r\nops = kzalloc(sizeof(*ops), GFP_KERNEL);\r\nif (!ops)\r\ngoto out;\r\nops->enable_slot = enable_slot;\r\nops->disable_slot = disable_slot;\r\nops->get_power_status = get_power_status;\r\nops->get_adapter_status = get_adapter_status;\r\nops->reset_slot = reset_slot;\r\nif (MRL_SENS(ctrl))\r\nops->get_latch_status = get_latch_status;\r\nif (ATTN_LED(ctrl)) {\r\nops->get_attention_status = get_attention_status;\r\nops->set_attention_status = set_attention_status;\r\n}\r\nhotplug->info = info;\r\nhotplug->private = slot;\r\nhotplug->release = &release_slot;\r\nhotplug->ops = ops;\r\nslot->hotplug_slot = hotplug;\r\nsnprintf(name, SLOT_NAME_SIZE, "%u", PSN(ctrl));\r\nctrl_dbg(ctrl, "Registering domain:bus:dev=%04x:%02x:00 sun=%x\n",\r\npci_domain_nr(ctrl->pcie->port->subordinate),\r\nctrl->pcie->port->subordinate->number, PSN(ctrl));\r\nretval = pci_hp_register(hotplug,\r\nctrl->pcie->port->subordinate, 0, name);\r\nif (retval)\r\nctrl_err(ctrl,\r\n"pci_hp_register failed with error %d\n", retval);\r\nout:\r\nif (retval) {\r\nkfree(ops);\r\nkfree(info);\r\nkfree(hotplug);\r\n}\r\nreturn retval;\r\n}\r\nstatic void cleanup_slot(struct controller *ctrl)\r\n{\r\npci_hp_deregister(ctrl->slot->hotplug_slot);\r\n}\r\nstatic int set_attention_status(struct hotplug_slot *hotplug_slot, u8 status)\r\n{\r\nstruct slot *slot = hotplug_slot->private;\r\nctrl_dbg(slot->ctrl, "%s: physical_slot = %s\n",\r\n__func__, slot_name(slot));\r\npciehp_set_attention_status(slot, status);\r\nreturn 0;\r\n}\r\nstatic int enable_slot(struct hotplug_slot *hotplug_slot)\r\n{\r\nstruct slot *slot = hotplug_slot->private;\r\nctrl_dbg(slot->ctrl, "%s: physical_slot = %s\n",\r\n__func__, slot_name(slot));\r\nreturn pciehp_sysfs_enable_slot(slot);\r\n}\r\nstatic int disable_slot(struct hotplug_slot *hotplug_slot)\r\n{\r\nstruct slot *slot = hotplug_slot->private;\r\nctrl_dbg(slot->ctrl, "%s: physical_slot = %s\n",\r\n__func__, slot_name(slot));\r\nreturn pciehp_sysfs_disable_slot(slot);\r\n}\r\nstatic int get_power_status(struct hotplug_slot *hotplug_slot, u8 *value)\r\n{\r\nstruct slot *slot = hotplug_slot->private;\r\nctrl_dbg(slot->ctrl, "%s: physical_slot = %s\n",\r\n__func__, slot_name(slot));\r\npciehp_get_power_status(slot, value);\r\nreturn 0;\r\n}\r\nstatic int get_attention_status(struct hotplug_slot *hotplug_slot, u8 *value)\r\n{\r\nstruct slot *slot = hotplug_slot->private;\r\nctrl_dbg(slot->ctrl, "%s: physical_slot = %s\n",\r\n__func__, slot_name(slot));\r\npciehp_get_attention_status(slot, value);\r\nreturn 0;\r\n}\r\nstatic int get_latch_status(struct hotplug_slot *hotplug_slot, u8 *value)\r\n{\r\nstruct slot *slot = hotplug_slot->private;\r\nctrl_dbg(slot->ctrl, "%s: physical_slot = %s\n",\r\n__func__, slot_name(slot));\r\npciehp_get_latch_status(slot, value);\r\nreturn 0;\r\n}\r\nstatic int get_adapter_status(struct hotplug_slot *hotplug_slot, u8 *value)\r\n{\r\nstruct slot *slot = hotplug_slot->private;\r\nctrl_dbg(slot->ctrl, "%s: physical_slot = %s\n",\r\n__func__, slot_name(slot));\r\npciehp_get_adapter_status(slot, value);\r\nreturn 0;\r\n}\r\nstatic int reset_slot(struct hotplug_slot *hotplug_slot, int probe)\r\n{\r\nstruct slot *slot = hotplug_slot->private;\r\nctrl_dbg(slot->ctrl, "%s: physical_slot = %s\n",\r\n__func__, slot_name(slot));\r\nreturn pciehp_reset_slot(slot, probe);\r\n}\r\nstatic int pciehp_probe(struct pcie_device *dev)\r\n{\r\nint rc;\r\nstruct controller *ctrl;\r\nstruct slot *slot;\r\nu8 occupied, poweron;\r\nif (pciehp_force)\r\ndev_info(&dev->device,\r\n"Bypassing BIOS check for pciehp use on %s\n",\r\npci_name(dev->port));\r\nelse if (pciehp_acpi_slot_detection_check(dev->port))\r\ngoto err_out_none;\r\nif (!dev->port->subordinate) {\r\ndev_err(&dev->device,\r\n"Hotplug bridge without secondary bus, ignoring\n");\r\ngoto err_out_none;\r\n}\r\nctrl = pcie_init(dev);\r\nif (!ctrl) {\r\ndev_err(&dev->device, "Controller initialization failed\n");\r\ngoto err_out_none;\r\n}\r\nset_service_data(dev, ctrl);\r\nrc = init_slot(ctrl);\r\nif (rc) {\r\nif (rc == -EBUSY)\r\nctrl_warn(ctrl, "Slot already registered by another hotplug driver\n");\r\nelse\r\nctrl_err(ctrl, "Slot initialization failed\n");\r\ngoto err_out_release_ctlr;\r\n}\r\nrc = pcie_init_notification(ctrl);\r\nif (rc) {\r\nctrl_err(ctrl, "Notification initialization failed\n");\r\ngoto err_out_free_ctrl_slot;\r\n}\r\nslot = ctrl->slot;\r\npciehp_get_adapter_status(slot, &occupied);\r\npciehp_get_power_status(slot, &poweron);\r\nif (occupied && pciehp_force) {\r\nmutex_lock(&slot->hotplug_lock);\r\npciehp_enable_slot(slot);\r\nmutex_unlock(&slot->hotplug_lock);\r\n}\r\nif (!occupied && poweron && POWER_CTRL(ctrl))\r\npciehp_power_off_slot(slot);\r\nreturn 0;\r\nerr_out_free_ctrl_slot:\r\ncleanup_slot(ctrl);\r\nerr_out_release_ctlr:\r\npciehp_release_ctrl(ctrl);\r\nerr_out_none:\r\nreturn -ENODEV;\r\n}\r\nstatic void pciehp_remove(struct pcie_device *dev)\r\n{\r\nstruct controller *ctrl = get_service_data(dev);\r\ncleanup_slot(ctrl);\r\npciehp_release_ctrl(ctrl);\r\n}\r\nstatic int pciehp_suspend(struct pcie_device *dev)\r\n{\r\nreturn 0;\r\n}\r\nstatic int pciehp_resume(struct pcie_device *dev)\r\n{\r\nstruct controller *ctrl;\r\nstruct slot *slot;\r\nu8 status;\r\nctrl = get_service_data(dev);\r\npcie_enable_notification(ctrl);\r\nslot = ctrl->slot;\r\npciehp_get_adapter_status(slot, &status);\r\nmutex_lock(&slot->hotplug_lock);\r\nif (status)\r\npciehp_enable_slot(slot);\r\nelse\r\npciehp_disable_slot(slot);\r\nmutex_unlock(&slot->hotplug_lock);\r\nreturn 0;\r\n}\r\nstatic int __init pcied_init(void)\r\n{\r\nint retval = 0;\r\npciehp_firmware_init();\r\nretval = pcie_port_service_register(&hpdriver_portdrv);\r\ndbg("pcie_port_service_register = %d\n", retval);\r\ninfo(DRIVER_DESC " version: " DRIVER_VERSION "\n");\r\nif (retval)\r\ndbg("Failure to register service\n");\r\nreturn retval;\r\n}\r\nstatic void __exit pcied_cleanup(void)\r\n{\r\ndbg("unload_pciehpd()\n");\r\npcie_port_service_unregister(&hpdriver_portdrv);\r\ninfo(DRIVER_DESC " version: " DRIVER_VERSION " unloaded\n");\r\n}
