void release_cis_mem(struct pcmcia_socket *s)\r\n{\r\nmutex_lock(&s->ops_mutex);\r\nif (s->cis_mem.flags & MAP_ACTIVE) {\r\ns->cis_mem.flags &= ~MAP_ACTIVE;\r\ns->ops->set_mem_map(s, &s->cis_mem);\r\nif (s->cis_mem.res) {\r\nrelease_resource(s->cis_mem.res);\r\nkfree(s->cis_mem.res);\r\ns->cis_mem.res = NULL;\r\n}\r\niounmap(s->cis_virt);\r\ns->cis_virt = NULL;\r\n}\r\nmutex_unlock(&s->ops_mutex);\r\n}\r\nstatic void __iomem *set_cis_map(struct pcmcia_socket *s,\r\nunsigned int card_offset, unsigned int flags)\r\n{\r\npccard_mem_map *mem = &s->cis_mem;\r\nint ret;\r\nif (!(s->features & SS_CAP_STATIC_MAP) && (mem->res == NULL)) {\r\nmem->res = pcmcia_find_mem_region(0, s->map_size,\r\ns->map_size, 0, s);\r\nif (mem->res == NULL) {\r\ndev_printk(KERN_NOTICE, &s->dev,\r\n"cs: unable to map card memory!\n");\r\nreturn NULL;\r\n}\r\ns->cis_virt = NULL;\r\n}\r\nif (!(s->features & SS_CAP_STATIC_MAP) && (!s->cis_virt))\r\ns->cis_virt = ioremap(mem->res->start, s->map_size);\r\nmem->card_start = card_offset;\r\nmem->flags = flags;\r\nret = s->ops->set_mem_map(s, mem);\r\nif (ret) {\r\niounmap(s->cis_virt);\r\ns->cis_virt = NULL;\r\nreturn NULL;\r\n}\r\nif (s->features & SS_CAP_STATIC_MAP) {\r\nif (s->cis_virt)\r\niounmap(s->cis_virt);\r\ns->cis_virt = ioremap(mem->static_start, s->map_size);\r\n}\r\nreturn s->cis_virt;\r\n}\r\nint pcmcia_read_cis_mem(struct pcmcia_socket *s, int attr, u_int addr,\r\nu_int len, void *ptr)\r\n{\r\nvoid __iomem *sys, *end;\r\nunsigned char *buf = ptr;\r\ndev_dbg(&s->dev, "pcmcia_read_cis_mem(%d, %#x, %u)\n", attr, addr, len);\r\nif (attr & IS_INDIRECT) {\r\nu_char flags = ICTRL0_COMMON|ICTRL0_AUTOINC|ICTRL0_BYTEGRAN;\r\nif (attr & IS_ATTR) {\r\naddr *= 2;\r\nflags = ICTRL0_AUTOINC;\r\n}\r\nsys = set_cis_map(s, 0, MAP_ACTIVE |\r\n((cis_width) ? MAP_16BIT : 0));\r\nif (!sys) {\r\ndev_dbg(&s->dev, "could not map memory\n");\r\nmemset(ptr, 0xff, len);\r\nreturn -1;\r\n}\r\nwriteb(flags, sys+CISREG_ICTRL0);\r\nwriteb(addr & 0xff, sys+CISREG_IADDR0);\r\nwriteb((addr>>8) & 0xff, sys+CISREG_IADDR1);\r\nwriteb((addr>>16) & 0xff, sys+CISREG_IADDR2);\r\nwriteb((addr>>24) & 0xff, sys+CISREG_IADDR3);\r\nfor ( ; len > 0; len--, buf++)\r\n*buf = readb(sys+CISREG_IDATA0);\r\n} else {\r\nu_int inc = 1, card_offset, flags;\r\nif (addr > CISTPL_MAX_CIS_SIZE) {\r\ndev_dbg(&s->dev,\r\n"attempt to read CIS mem at addr %#x", addr);\r\nmemset(ptr, 0xff, len);\r\nreturn -1;\r\n}\r\nflags = MAP_ACTIVE | ((cis_width) ? MAP_16BIT : 0);\r\nif (attr) {\r\nflags |= MAP_ATTRIB;\r\ninc++;\r\naddr *= 2;\r\n}\r\ncard_offset = addr & ~(s->map_size-1);\r\nwhile (len) {\r\nsys = set_cis_map(s, card_offset, flags);\r\nif (!sys) {\r\ndev_dbg(&s->dev, "could not map memory\n");\r\nmemset(ptr, 0xff, len);\r\nreturn -1;\r\n}\r\nend = sys + s->map_size;\r\nsys = sys + (addr & (s->map_size-1));\r\nfor ( ; len > 0; len--, buf++, sys += inc) {\r\nif (sys == end)\r\nbreak;\r\n*buf = readb(sys);\r\n}\r\ncard_offset += s->map_size;\r\naddr = 0;\r\n}\r\n}\r\ndev_dbg(&s->dev, " %#2.2x %#2.2x %#2.2x %#2.2x ...\n",\r\n*(u_char *)(ptr+0), *(u_char *)(ptr+1),\r\n*(u_char *)(ptr+2), *(u_char *)(ptr+3));\r\nreturn 0;\r\n}\r\nint pcmcia_write_cis_mem(struct pcmcia_socket *s, int attr, u_int addr,\r\nu_int len, void *ptr)\r\n{\r\nvoid __iomem *sys, *end;\r\nunsigned char *buf = ptr;\r\ndev_dbg(&s->dev,\r\n"pcmcia_write_cis_mem(%d, %#x, %u)\n", attr, addr, len);\r\nif (attr & IS_INDIRECT) {\r\nu_char flags = ICTRL0_COMMON|ICTRL0_AUTOINC|ICTRL0_BYTEGRAN;\r\nif (attr & IS_ATTR) {\r\naddr *= 2;\r\nflags = ICTRL0_AUTOINC;\r\n}\r\nsys = set_cis_map(s, 0, MAP_ACTIVE |\r\n((cis_width) ? MAP_16BIT : 0));\r\nif (!sys) {\r\ndev_dbg(&s->dev, "could not map memory\n");\r\nreturn -EINVAL;\r\n}\r\nwriteb(flags, sys+CISREG_ICTRL0);\r\nwriteb(addr & 0xff, sys+CISREG_IADDR0);\r\nwriteb((addr>>8) & 0xff, sys+CISREG_IADDR1);\r\nwriteb((addr>>16) & 0xff, sys+CISREG_IADDR2);\r\nwriteb((addr>>24) & 0xff, sys+CISREG_IADDR3);\r\nfor ( ; len > 0; len--, buf++)\r\nwriteb(*buf, sys+CISREG_IDATA0);\r\n} else {\r\nu_int inc = 1, card_offset, flags;\r\nflags = MAP_ACTIVE | ((cis_width) ? MAP_16BIT : 0);\r\nif (attr & IS_ATTR) {\r\nflags |= MAP_ATTRIB;\r\ninc++;\r\naddr *= 2;\r\n}\r\ncard_offset = addr & ~(s->map_size-1);\r\nwhile (len) {\r\nsys = set_cis_map(s, card_offset, flags);\r\nif (!sys) {\r\ndev_dbg(&s->dev, "could not map memory\n");\r\nreturn -EINVAL;\r\n}\r\nend = sys + s->map_size;\r\nsys = sys + (addr & (s->map_size-1));\r\nfor ( ; len > 0; len--, buf++, sys += inc) {\r\nif (sys == end)\r\nbreak;\r\nwriteb(*buf, sys);\r\n}\r\ncard_offset += s->map_size;\r\naddr = 0;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int read_cis_cache(struct pcmcia_socket *s, int attr, u_int addr,\r\nsize_t len, void *ptr)\r\n{\r\nstruct cis_cache_entry *cis;\r\nint ret = 0;\r\nif (s->state & SOCKET_CARDBUS)\r\nreturn -EINVAL;\r\nmutex_lock(&s->ops_mutex);\r\nif (s->fake_cis) {\r\nif (s->fake_cis_len >= addr+len)\r\nmemcpy(ptr, s->fake_cis+addr, len);\r\nelse {\r\nmemset(ptr, 0xff, len);\r\nret = -EINVAL;\r\n}\r\nmutex_unlock(&s->ops_mutex);\r\nreturn ret;\r\n}\r\nlist_for_each_entry(cis, &s->cis_cache, node) {\r\nif (cis->addr == addr && cis->len == len && cis->attr == attr) {\r\nmemcpy(ptr, cis->cache, len);\r\nmutex_unlock(&s->ops_mutex);\r\nreturn 0;\r\n}\r\n}\r\nret = pcmcia_read_cis_mem(s, attr, addr, len, ptr);\r\nif (ret == 0) {\r\ncis = kmalloc(sizeof(struct cis_cache_entry) + len, GFP_KERNEL);\r\nif (cis) {\r\ncis->addr = addr;\r\ncis->len = len;\r\ncis->attr = attr;\r\nmemcpy(cis->cache, ptr, len);\r\nlist_add(&cis->node, &s->cis_cache);\r\n}\r\n}\r\nmutex_unlock(&s->ops_mutex);\r\nreturn ret;\r\n}\r\nstatic void\r\nremove_cis_cache(struct pcmcia_socket *s, int attr, u_int addr, u_int len)\r\n{\r\nstruct cis_cache_entry *cis;\r\nmutex_lock(&s->ops_mutex);\r\nlist_for_each_entry(cis, &s->cis_cache, node)\r\nif (cis->addr == addr && cis->len == len && cis->attr == attr) {\r\nlist_del(&cis->node);\r\nkfree(cis);\r\nbreak;\r\n}\r\nmutex_unlock(&s->ops_mutex);\r\n}\r\nvoid destroy_cis_cache(struct pcmcia_socket *s)\r\n{\r\nstruct list_head *l, *n;\r\nstruct cis_cache_entry *cis;\r\nlist_for_each_safe(l, n, &s->cis_cache) {\r\ncis = list_entry(l, struct cis_cache_entry, node);\r\nlist_del(&cis->node);\r\nkfree(cis);\r\n}\r\n}\r\nint verify_cis_cache(struct pcmcia_socket *s)\r\n{\r\nstruct cis_cache_entry *cis;\r\nchar *buf;\r\nint ret;\r\nif (s->state & SOCKET_CARDBUS)\r\nreturn -EINVAL;\r\nbuf = kmalloc(256, GFP_KERNEL);\r\nif (buf == NULL) {\r\ndev_printk(KERN_WARNING, &s->dev,\r\n"no memory for verifying CIS\n");\r\nreturn -ENOMEM;\r\n}\r\nmutex_lock(&s->ops_mutex);\r\nlist_for_each_entry(cis, &s->cis_cache, node) {\r\nint len = cis->len;\r\nif (len > 256)\r\nlen = 256;\r\nret = pcmcia_read_cis_mem(s, cis->attr, cis->addr, len, buf);\r\nif (ret || memcmp(buf, cis->cache, len) != 0) {\r\nkfree(buf);\r\nmutex_unlock(&s->ops_mutex);\r\nreturn -1;\r\n}\r\n}\r\nkfree(buf);\r\nmutex_unlock(&s->ops_mutex);\r\nreturn 0;\r\n}\r\nint pcmcia_replace_cis(struct pcmcia_socket *s,\r\nconst u8 *data, const size_t len)\r\n{\r\nif (len > CISTPL_MAX_CIS_SIZE) {\r\ndev_printk(KERN_WARNING, &s->dev, "replacement CIS too big\n");\r\nreturn -EINVAL;\r\n}\r\nmutex_lock(&s->ops_mutex);\r\nkfree(s->fake_cis);\r\ns->fake_cis = kmalloc(len, GFP_KERNEL);\r\nif (s->fake_cis == NULL) {\r\ndev_printk(KERN_WARNING, &s->dev, "no memory to replace CIS\n");\r\nmutex_unlock(&s->ops_mutex);\r\nreturn -ENOMEM;\r\n}\r\ns->fake_cis_len = len;\r\nmemcpy(s->fake_cis, data, len);\r\ndev_info(&s->dev, "Using replacement CIS\n");\r\nmutex_unlock(&s->ops_mutex);\r\nreturn 0;\r\n}\r\nint pccard_get_first_tuple(struct pcmcia_socket *s, unsigned int function,\r\ntuple_t *tuple)\r\n{\r\nif (!s)\r\nreturn -EINVAL;\r\nif (!(s->state & SOCKET_PRESENT) || (s->state & SOCKET_CARDBUS))\r\nreturn -ENODEV;\r\ntuple->TupleLink = tuple->Flags = 0;\r\ntuple->CISOffset = tuple->LinkOffset = 0;\r\nSPACE(tuple->Flags) = HAS_LINK(tuple->Flags) = 1;\r\nif ((s->functions > 1) && !(tuple->Attributes & TUPLE_RETURN_COMMON)) {\r\ncisdata_t req = tuple->DesiredTuple;\r\ntuple->DesiredTuple = CISTPL_LONGLINK_MFC;\r\nif (pccard_get_next_tuple(s, function, tuple) == 0) {\r\ntuple->DesiredTuple = CISTPL_LINKTARGET;\r\nif (pccard_get_next_tuple(s, function, tuple) != 0)\r\nreturn -ENOSPC;\r\n} else\r\ntuple->CISOffset = tuple->TupleLink = 0;\r\ntuple->DesiredTuple = req;\r\n}\r\nreturn pccard_get_next_tuple(s, function, tuple);\r\n}\r\nstatic int follow_link(struct pcmcia_socket *s, tuple_t *tuple)\r\n{\r\nu_char link[5];\r\nu_int ofs;\r\nint ret;\r\nif (MFC_FN(tuple->Flags)) {\r\nret = read_cis_cache(s, LINK_SPACE(tuple->Flags),\r\ntuple->LinkOffset, 5, link);\r\nif (ret)\r\nreturn -1;\r\nofs = get_unaligned_le32(link + 1);\r\nSPACE(tuple->Flags) = (link[0] == CISTPL_MFC_ATTR);\r\ntuple->LinkOffset += 5;\r\nMFC_FN(tuple->Flags)--;\r\n} else if (HAS_LINK(tuple->Flags)) {\r\nofs = tuple->LinkOffset;\r\nSPACE(tuple->Flags) = LINK_SPACE(tuple->Flags);\r\nHAS_LINK(tuple->Flags) = 0;\r\n} else\r\nreturn -1;\r\nif (SPACE(tuple->Flags)) {\r\nret = read_cis_cache(s, SPACE(tuple->Flags), ofs, 5, link);\r\nif (ret)\r\nreturn -1;\r\nif ((link[0] == CISTPL_LINKTARGET) && (link[1] >= 3) &&\r\n(strncmp(link+2, "CIS", 3) == 0))\r\nreturn ofs;\r\nremove_cis_cache(s, SPACE(tuple->Flags), ofs, 5);\r\nofs = ofs >> 1;\r\n}\r\nret = read_cis_cache(s, SPACE(tuple->Flags), ofs, 5, link);\r\nif (ret)\r\nreturn -1;\r\nif ((link[0] == CISTPL_LINKTARGET) && (link[1] >= 3) &&\r\n(strncmp(link+2, "CIS", 3) == 0))\r\nreturn ofs;\r\nremove_cis_cache(s, SPACE(tuple->Flags), ofs, 5);\r\nreturn -1;\r\n}\r\nint pccard_get_next_tuple(struct pcmcia_socket *s, unsigned int function,\r\ntuple_t *tuple)\r\n{\r\nu_char link[2], tmp;\r\nint ofs, i, attr;\r\nint ret;\r\nif (!s)\r\nreturn -EINVAL;\r\nif (!(s->state & SOCKET_PRESENT) || (s->state & SOCKET_CARDBUS))\r\nreturn -ENODEV;\r\nlink[1] = tuple->TupleLink;\r\nofs = tuple->CISOffset + tuple->TupleLink;\r\nattr = SPACE(tuple->Flags);\r\nfor (i = 0; i < MAX_TUPLES; i++) {\r\nif (link[1] == 0xff)\r\nlink[0] = CISTPL_END;\r\nelse {\r\nret = read_cis_cache(s, attr, ofs, 2, link);\r\nif (ret)\r\nreturn -1;\r\nif (link[0] == CISTPL_NULL) {\r\nofs++;\r\ncontinue;\r\n}\r\n}\r\nif (link[0] == CISTPL_END) {\r\nofs = follow_link(s, tuple);\r\nif (ofs < 0)\r\nreturn -ENOSPC;\r\nattr = SPACE(tuple->Flags);\r\nret = read_cis_cache(s, attr, ofs, 2, link);\r\nif (ret)\r\nreturn -1;\r\n}\r\nif ((link[0] == CISTPL_LONGLINK_A) ||\r\n(link[0] == CISTPL_LONGLINK_C) ||\r\n(link[0] == CISTPL_LONGLINK_MFC) ||\r\n(link[0] == CISTPL_LINKTARGET) ||\r\n(link[0] == CISTPL_INDIRECT) ||\r\n(link[0] == CISTPL_NO_LINK)) {\r\nswitch (link[0]) {\r\ncase CISTPL_LONGLINK_A:\r\nHAS_LINK(tuple->Flags) = 1;\r\nLINK_SPACE(tuple->Flags) = attr | IS_ATTR;\r\nret = read_cis_cache(s, attr, ofs+2, 4,\r\n&tuple->LinkOffset);\r\nif (ret)\r\nreturn -1;\r\nbreak;\r\ncase CISTPL_LONGLINK_C:\r\nHAS_LINK(tuple->Flags) = 1;\r\nLINK_SPACE(tuple->Flags) = attr & ~IS_ATTR;\r\nret = read_cis_cache(s, attr, ofs+2, 4,\r\n&tuple->LinkOffset);\r\nif (ret)\r\nreturn -1;\r\nbreak;\r\ncase CISTPL_INDIRECT:\r\nHAS_LINK(tuple->Flags) = 1;\r\nLINK_SPACE(tuple->Flags) = IS_ATTR |\r\nIS_INDIRECT;\r\ntuple->LinkOffset = 0;\r\nbreak;\r\ncase CISTPL_LONGLINK_MFC:\r\ntuple->LinkOffset = ofs + 3;\r\nLINK_SPACE(tuple->Flags) = attr;\r\nif (function == BIND_FN_ALL) {\r\nret = read_cis_cache(s, attr, ofs+2,\r\n1, &tmp);\r\nif (ret)\r\nreturn -1;\r\nMFC_FN(tuple->Flags) = tmp;\r\n} else {\r\nMFC_FN(tuple->Flags) = 1;\r\ntuple->LinkOffset += function * 5;\r\n}\r\nbreak;\r\ncase CISTPL_NO_LINK:\r\nHAS_LINK(tuple->Flags) = 0;\r\nbreak;\r\n}\r\nif ((tuple->Attributes & TUPLE_RETURN_LINK) &&\r\n(tuple->DesiredTuple == RETURN_FIRST_TUPLE))\r\nbreak;\r\n} else\r\nif (tuple->DesiredTuple == RETURN_FIRST_TUPLE)\r\nbreak;\r\nif (link[0] == tuple->DesiredTuple)\r\nbreak;\r\nofs += link[1] + 2;\r\n}\r\nif (i == MAX_TUPLES) {\r\ndev_dbg(&s->dev, "cs: overrun in pcmcia_get_next_tuple\n");\r\nreturn -ENOSPC;\r\n}\r\ntuple->TupleCode = link[0];\r\ntuple->TupleLink = link[1];\r\ntuple->CISOffset = ofs + 2;\r\nreturn 0;\r\n}\r\nint pccard_get_tuple_data(struct pcmcia_socket *s, tuple_t *tuple)\r\n{\r\nu_int len;\r\nint ret;\r\nif (!s)\r\nreturn -EINVAL;\r\nif (tuple->TupleLink < tuple->TupleOffset)\r\nreturn -ENOSPC;\r\nlen = tuple->TupleLink - tuple->TupleOffset;\r\ntuple->TupleDataLen = tuple->TupleLink;\r\nif (len == 0)\r\nreturn 0;\r\nret = read_cis_cache(s, SPACE(tuple->Flags),\r\ntuple->CISOffset + tuple->TupleOffset,\r\nmin(len, (u_int) tuple->TupleDataMax),\r\ntuple->TupleData);\r\nif (ret)\r\nreturn -1;\r\nreturn 0;\r\n}\r\nstatic int parse_device(tuple_t *tuple, cistpl_device_t *device)\r\n{\r\nint i;\r\nu_char scale;\r\nu_char *p, *q;\r\np = (u_char *)tuple->TupleData;\r\nq = p + tuple->TupleDataLen;\r\ndevice->ndev = 0;\r\nfor (i = 0; i < CISTPL_MAX_DEVICES; i++) {\r\nif (*p == 0xff)\r\nbreak;\r\ndevice->dev[i].type = (*p >> 4);\r\ndevice->dev[i].wp = (*p & 0x08) ? 1 : 0;\r\nswitch (*p & 0x07) {\r\ncase 0:\r\ndevice->dev[i].speed = 0;\r\nbreak;\r\ncase 1:\r\ndevice->dev[i].speed = 250;\r\nbreak;\r\ncase 2:\r\ndevice->dev[i].speed = 200;\r\nbreak;\r\ncase 3:\r\ndevice->dev[i].speed = 150;\r\nbreak;\r\ncase 4:\r\ndevice->dev[i].speed = 100;\r\nbreak;\r\ncase 7:\r\nif (++p == q)\r\nreturn -EINVAL;\r\ndevice->dev[i].speed = SPEED_CVT(*p);\r\nwhile (*p & 0x80)\r\nif (++p == q)\r\nreturn -EINVAL;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (++p == q)\r\nreturn -EINVAL;\r\nif (*p == 0xff)\r\nbreak;\r\nscale = *p & 7;\r\nif (scale == 7)\r\nreturn -EINVAL;\r\ndevice->dev[i].size = ((*p >> 3) + 1) * (512 << (scale*2));\r\ndevice->ndev++;\r\nif (++p == q)\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int parse_checksum(tuple_t *tuple, cistpl_checksum_t *csum)\r\n{\r\nu_char *p;\r\nif (tuple->TupleDataLen < 5)\r\nreturn -EINVAL;\r\np = (u_char *) tuple->TupleData;\r\ncsum->addr = tuple->CISOffset + get_unaligned_le16(p) - 2;\r\ncsum->len = get_unaligned_le16(p + 2);\r\ncsum->sum = *(p + 4);\r\nreturn 0;\r\n}\r\nstatic int parse_longlink(tuple_t *tuple, cistpl_longlink_t *link)\r\n{\r\nif (tuple->TupleDataLen < 4)\r\nreturn -EINVAL;\r\nlink->addr = get_unaligned_le32(tuple->TupleData);\r\nreturn 0;\r\n}\r\nstatic int parse_longlink_mfc(tuple_t *tuple, cistpl_longlink_mfc_t *link)\r\n{\r\nu_char *p;\r\nint i;\r\np = (u_char *)tuple->TupleData;\r\nlink->nfn = *p; p++;\r\nif (tuple->TupleDataLen <= link->nfn*5)\r\nreturn -EINVAL;\r\nfor (i = 0; i < link->nfn; i++) {\r\nlink->fn[i].space = *p; p++;\r\nlink->fn[i].addr = get_unaligned_le32(p);\r\np += 4;\r\n}\r\nreturn 0;\r\n}\r\nstatic int parse_strings(u_char *p, u_char *q, int max,\r\nchar *s, u_char *ofs, u_char *found)\r\n{\r\nint i, j, ns;\r\nif (p == q)\r\nreturn -EINVAL;\r\nns = 0; j = 0;\r\nfor (i = 0; i < max; i++) {\r\nif (*p == 0xff)\r\nbreak;\r\nofs[i] = j;\r\nns++;\r\nfor (;;) {\r\ns[j++] = (*p == 0xff) ? '\0' : *p;\r\nif ((*p == '\0') || (*p == 0xff))\r\nbreak;\r\nif (++p == q)\r\nreturn -EINVAL;\r\n}\r\nif ((*p == 0xff) || (++p == q))\r\nbreak;\r\n}\r\nif (found) {\r\n*found = ns;\r\nreturn 0;\r\n}\r\nreturn (ns == max) ? 0 : -EINVAL;\r\n}\r\nstatic int parse_vers_1(tuple_t *tuple, cistpl_vers_1_t *vers_1)\r\n{\r\nu_char *p, *q;\r\np = (u_char *)tuple->TupleData;\r\nq = p + tuple->TupleDataLen;\r\nvers_1->major = *p; p++;\r\nvers_1->minor = *p; p++;\r\nif (p >= q)\r\nreturn -EINVAL;\r\nreturn parse_strings(p, q, CISTPL_VERS_1_MAX_PROD_STRINGS,\r\nvers_1->str, vers_1->ofs, &vers_1->ns);\r\n}\r\nstatic int parse_altstr(tuple_t *tuple, cistpl_altstr_t *altstr)\r\n{\r\nu_char *p, *q;\r\np = (u_char *)tuple->TupleData;\r\nq = p + tuple->TupleDataLen;\r\nreturn parse_strings(p, q, CISTPL_MAX_ALTSTR_STRINGS,\r\naltstr->str, altstr->ofs, &altstr->ns);\r\n}\r\nstatic int parse_jedec(tuple_t *tuple, cistpl_jedec_t *jedec)\r\n{\r\nu_char *p, *q;\r\nint nid;\r\np = (u_char *)tuple->TupleData;\r\nq = p + tuple->TupleDataLen;\r\nfor (nid = 0; nid < CISTPL_MAX_DEVICES; nid++) {\r\nif (p > q-2)\r\nbreak;\r\njedec->id[nid].mfr = p[0];\r\njedec->id[nid].info = p[1];\r\np += 2;\r\n}\r\njedec->nid = nid;\r\nreturn 0;\r\n}\r\nstatic int parse_manfid(tuple_t *tuple, cistpl_manfid_t *m)\r\n{\r\nif (tuple->TupleDataLen < 4)\r\nreturn -EINVAL;\r\nm->manf = get_unaligned_le16(tuple->TupleData);\r\nm->card = get_unaligned_le16(tuple->TupleData + 2);\r\nreturn 0;\r\n}\r\nstatic int parse_funcid(tuple_t *tuple, cistpl_funcid_t *f)\r\n{\r\nu_char *p;\r\nif (tuple->TupleDataLen < 2)\r\nreturn -EINVAL;\r\np = (u_char *)tuple->TupleData;\r\nf->func = p[0];\r\nf->sysinit = p[1];\r\nreturn 0;\r\n}\r\nstatic int parse_funce(tuple_t *tuple, cistpl_funce_t *f)\r\n{\r\nu_char *p;\r\nint i;\r\nif (tuple->TupleDataLen < 1)\r\nreturn -EINVAL;\r\np = (u_char *)tuple->TupleData;\r\nf->type = p[0];\r\nfor (i = 1; i < tuple->TupleDataLen; i++)\r\nf->data[i-1] = p[i];\r\nreturn 0;\r\n}\r\nstatic int parse_config(tuple_t *tuple, cistpl_config_t *config)\r\n{\r\nint rasz, rmsz, i;\r\nu_char *p;\r\np = (u_char *)tuple->TupleData;\r\nrasz = *p & 0x03;\r\nrmsz = (*p & 0x3c) >> 2;\r\nif (tuple->TupleDataLen < rasz+rmsz+4)\r\nreturn -EINVAL;\r\nconfig->last_idx = *(++p);\r\np++;\r\nconfig->base = 0;\r\nfor (i = 0; i <= rasz; i++)\r\nconfig->base += p[i] << (8*i);\r\np += rasz+1;\r\nfor (i = 0; i < 4; i++)\r\nconfig->rmask[i] = 0;\r\nfor (i = 0; i <= rmsz; i++)\r\nconfig->rmask[i>>2] += p[i] << (8*(i%4));\r\nconfig->subtuples = tuple->TupleDataLen - (rasz+rmsz+4);\r\nreturn 0;\r\n}\r\nstatic u_char *parse_power(u_char *p, u_char *q, cistpl_power_t *pwr)\r\n{\r\nint i;\r\nu_int scale;\r\nif (p == q)\r\nreturn NULL;\r\npwr->present = *p;\r\npwr->flags = 0;\r\np++;\r\nfor (i = 0; i < 7; i++)\r\nif (pwr->present & (1<<i)) {\r\nif (p == q)\r\nreturn NULL;\r\npwr->param[i] = POWER_CVT(*p);\r\nscale = POWER_SCALE(*p);\r\nwhile (*p & 0x80) {\r\nif (++p == q)\r\nreturn NULL;\r\nif ((*p & 0x7f) < 100)\r\npwr->param[i] +=\r\n(*p & 0x7f) * scale / 100;\r\nelse if (*p == 0x7d)\r\npwr->flags |= CISTPL_POWER_HIGHZ_OK;\r\nelse if (*p == 0x7e)\r\npwr->param[i] = 0;\r\nelse if (*p == 0x7f)\r\npwr->flags |= CISTPL_POWER_HIGHZ_REQ;\r\nelse\r\nreturn NULL;\r\n}\r\np++;\r\n}\r\nreturn p;\r\n}\r\nstatic u_char *parse_timing(u_char *p, u_char *q, cistpl_timing_t *timing)\r\n{\r\nu_char scale;\r\nif (p == q)\r\nreturn NULL;\r\nscale = *p;\r\nif ((scale & 3) != 3) {\r\nif (++p == q)\r\nreturn NULL;\r\ntiming->wait = SPEED_CVT(*p);\r\ntiming->waitscale = exponent[scale & 3];\r\n} else\r\ntiming->wait = 0;\r\nscale >>= 2;\r\nif ((scale & 7) != 7) {\r\nif (++p == q)\r\nreturn NULL;\r\ntiming->ready = SPEED_CVT(*p);\r\ntiming->rdyscale = exponent[scale & 7];\r\n} else\r\ntiming->ready = 0;\r\nscale >>= 3;\r\nif (scale != 7) {\r\nif (++p == q)\r\nreturn NULL;\r\ntiming->reserved = SPEED_CVT(*p);\r\ntiming->rsvscale = exponent[scale];\r\n} else\r\ntiming->reserved = 0;\r\np++;\r\nreturn p;\r\n}\r\nstatic u_char *parse_io(u_char *p, u_char *q, cistpl_io_t *io)\r\n{\r\nint i, j, bsz, lsz;\r\nif (p == q)\r\nreturn NULL;\r\nio->flags = *p;\r\nif (!(*p & 0x80)) {\r\nio->nwin = 1;\r\nio->win[0].base = 0;\r\nio->win[0].len = (1 << (io->flags & CISTPL_IO_LINES_MASK));\r\nreturn p+1;\r\n}\r\nif (++p == q)\r\nreturn NULL;\r\nio->nwin = (*p & 0x0f) + 1;\r\nbsz = (*p & 0x30) >> 4;\r\nif (bsz == 3)\r\nbsz++;\r\nlsz = (*p & 0xc0) >> 6;\r\nif (lsz == 3)\r\nlsz++;\r\np++;\r\nfor (i = 0; i < io->nwin; i++) {\r\nio->win[i].base = 0;\r\nio->win[i].len = 1;\r\nfor (j = 0; j < bsz; j++, p++) {\r\nif (p == q)\r\nreturn NULL;\r\nio->win[i].base += *p << (j*8);\r\n}\r\nfor (j = 0; j < lsz; j++, p++) {\r\nif (p == q)\r\nreturn NULL;\r\nio->win[i].len += *p << (j*8);\r\n}\r\n}\r\nreturn p;\r\n}\r\nstatic u_char *parse_mem(u_char *p, u_char *q, cistpl_mem_t *mem)\r\n{\r\nint i, j, asz, lsz, has_ha;\r\nu_int len, ca, ha;\r\nif (p == q)\r\nreturn NULL;\r\nmem->nwin = (*p & 0x07) + 1;\r\nlsz = (*p & 0x18) >> 3;\r\nasz = (*p & 0x60) >> 5;\r\nhas_ha = (*p & 0x80);\r\nif (++p == q)\r\nreturn NULL;\r\nfor (i = 0; i < mem->nwin; i++) {\r\nlen = ca = ha = 0;\r\nfor (j = 0; j < lsz; j++, p++) {\r\nif (p == q)\r\nreturn NULL;\r\nlen += *p << (j*8);\r\n}\r\nfor (j = 0; j < asz; j++, p++) {\r\nif (p == q)\r\nreturn NULL;\r\nca += *p << (j*8);\r\n}\r\nif (has_ha)\r\nfor (j = 0; j < asz; j++, p++) {\r\nif (p == q)\r\nreturn NULL;\r\nha += *p << (j*8);\r\n}\r\nmem->win[i].len = len << 8;\r\nmem->win[i].card_addr = ca << 8;\r\nmem->win[i].host_addr = ha << 8;\r\n}\r\nreturn p;\r\n}\r\nstatic u_char *parse_irq(u_char *p, u_char *q, cistpl_irq_t *irq)\r\n{\r\nif (p == q)\r\nreturn NULL;\r\nirq->IRQInfo1 = *p; p++;\r\nif (irq->IRQInfo1 & IRQ_INFO2_VALID) {\r\nif (p+2 > q)\r\nreturn NULL;\r\nirq->IRQInfo2 = (p[1]<<8) + p[0];\r\np += 2;\r\n}\r\nreturn p;\r\n}\r\nstatic int parse_cftable_entry(tuple_t *tuple,\r\ncistpl_cftable_entry_t *entry)\r\n{\r\nu_char *p, *q, features;\r\np = tuple->TupleData;\r\nq = p + tuple->TupleDataLen;\r\nentry->index = *p & 0x3f;\r\nentry->flags = 0;\r\nif (*p & 0x40)\r\nentry->flags |= CISTPL_CFTABLE_DEFAULT;\r\nif (*p & 0x80) {\r\nif (++p == q)\r\nreturn -EINVAL;\r\nif (*p & 0x10)\r\nentry->flags |= CISTPL_CFTABLE_BVDS;\r\nif (*p & 0x20)\r\nentry->flags |= CISTPL_CFTABLE_WP;\r\nif (*p & 0x40)\r\nentry->flags |= CISTPL_CFTABLE_RDYBSY;\r\nif (*p & 0x80)\r\nentry->flags |= CISTPL_CFTABLE_MWAIT;\r\nentry->interface = *p & 0x0f;\r\n} else\r\nentry->interface = 0;\r\nif (++p == q)\r\nreturn -EINVAL;\r\nfeatures = *p; p++;\r\nif ((features & 3) > 0) {\r\np = parse_power(p, q, &entry->vcc);\r\nif (p == NULL)\r\nreturn -EINVAL;\r\n} else\r\nentry->vcc.present = 0;\r\nif ((features & 3) > 1) {\r\np = parse_power(p, q, &entry->vpp1);\r\nif (p == NULL)\r\nreturn -EINVAL;\r\n} else\r\nentry->vpp1.present = 0;\r\nif ((features & 3) > 2) {\r\np = parse_power(p, q, &entry->vpp2);\r\nif (p == NULL)\r\nreturn -EINVAL;\r\n} else\r\nentry->vpp2.present = 0;\r\nif (features & 0x04) {\r\np = parse_timing(p, q, &entry->timing);\r\nif (p == NULL)\r\nreturn -EINVAL;\r\n} else {\r\nentry->timing.wait = 0;\r\nentry->timing.ready = 0;\r\nentry->timing.reserved = 0;\r\n}\r\nif (features & 0x08) {\r\np = parse_io(p, q, &entry->io);\r\nif (p == NULL)\r\nreturn -EINVAL;\r\n} else\r\nentry->io.nwin = 0;\r\nif (features & 0x10) {\r\np = parse_irq(p, q, &entry->irq);\r\nif (p == NULL)\r\nreturn -EINVAL;\r\n} else\r\nentry->irq.IRQInfo1 = 0;\r\nswitch (features & 0x60) {\r\ncase 0x00:\r\nentry->mem.nwin = 0;\r\nbreak;\r\ncase 0x20:\r\nentry->mem.nwin = 1;\r\nentry->mem.win[0].len = get_unaligned_le16(p) << 8;\r\nentry->mem.win[0].card_addr = 0;\r\nentry->mem.win[0].host_addr = 0;\r\np += 2;\r\nif (p > q)\r\nreturn -EINVAL;\r\nbreak;\r\ncase 0x40:\r\nentry->mem.nwin = 1;\r\nentry->mem.win[0].len = get_unaligned_le16(p) << 8;\r\nentry->mem.win[0].card_addr = get_unaligned_le16(p + 2) << 8;\r\nentry->mem.win[0].host_addr = 0;\r\np += 4;\r\nif (p > q)\r\nreturn -EINVAL;\r\nbreak;\r\ncase 0x60:\r\np = parse_mem(p, q, &entry->mem);\r\nif (p == NULL)\r\nreturn -EINVAL;\r\nbreak;\r\n}\r\nif (features & 0x80) {\r\nif (p == q)\r\nreturn -EINVAL;\r\nentry->flags |= (*p << 8);\r\nwhile (*p & 0x80)\r\nif (++p == q)\r\nreturn -EINVAL;\r\np++;\r\n}\r\nentry->subtuples = q-p;\r\nreturn 0;\r\n}\r\nstatic int parse_device_geo(tuple_t *tuple, cistpl_device_geo_t *geo)\r\n{\r\nu_char *p, *q;\r\nint n;\r\np = (u_char *)tuple->TupleData;\r\nq = p + tuple->TupleDataLen;\r\nfor (n = 0; n < CISTPL_MAX_DEVICES; n++) {\r\nif (p > q-6)\r\nbreak;\r\ngeo->geo[n].buswidth = p[0];\r\ngeo->geo[n].erase_block = 1 << (p[1]-1);\r\ngeo->geo[n].read_block = 1 << (p[2]-1);\r\ngeo->geo[n].write_block = 1 << (p[3]-1);\r\ngeo->geo[n].partition = 1 << (p[4]-1);\r\ngeo->geo[n].interleave = 1 << (p[5]-1);\r\np += 6;\r\n}\r\ngeo->ngeo = n;\r\nreturn 0;\r\n}\r\nstatic int parse_vers_2(tuple_t *tuple, cistpl_vers_2_t *v2)\r\n{\r\nu_char *p, *q;\r\nif (tuple->TupleDataLen < 10)\r\nreturn -EINVAL;\r\np = tuple->TupleData;\r\nq = p + tuple->TupleDataLen;\r\nv2->vers = p[0];\r\nv2->comply = p[1];\r\nv2->dindex = get_unaligned_le16(p + 2);\r\nv2->vspec8 = p[6];\r\nv2->vspec9 = p[7];\r\nv2->nhdr = p[8];\r\np += 9;\r\nreturn parse_strings(p, q, 2, v2->str, &v2->vendor, NULL);\r\n}\r\nstatic int parse_org(tuple_t *tuple, cistpl_org_t *org)\r\n{\r\nu_char *p, *q;\r\nint i;\r\np = tuple->TupleData;\r\nq = p + tuple->TupleDataLen;\r\nif (p == q)\r\nreturn -EINVAL;\r\norg->data_org = *p;\r\nif (++p == q)\r\nreturn -EINVAL;\r\nfor (i = 0; i < 30; i++) {\r\norg->desc[i] = *p;\r\nif (*p == '\0')\r\nbreak;\r\nif (++p == q)\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int parse_format(tuple_t *tuple, cistpl_format_t *fmt)\r\n{\r\nu_char *p;\r\nif (tuple->TupleDataLen < 10)\r\nreturn -EINVAL;\r\np = tuple->TupleData;\r\nfmt->type = p[0];\r\nfmt->edc = p[1];\r\nfmt->offset = get_unaligned_le32(p + 2);\r\nfmt->length = get_unaligned_le32(p + 6);\r\nreturn 0;\r\n}\r\nint pcmcia_parse_tuple(tuple_t *tuple, cisparse_t *parse)\r\n{\r\nint ret = 0;\r\nif (tuple->TupleDataLen > tuple->TupleDataMax)\r\nreturn -EINVAL;\r\nswitch (tuple->TupleCode) {\r\ncase CISTPL_DEVICE:\r\ncase CISTPL_DEVICE_A:\r\nret = parse_device(tuple, &parse->device);\r\nbreak;\r\ncase CISTPL_CHECKSUM:\r\nret = parse_checksum(tuple, &parse->checksum);\r\nbreak;\r\ncase CISTPL_LONGLINK_A:\r\ncase CISTPL_LONGLINK_C:\r\nret = parse_longlink(tuple, &parse->longlink);\r\nbreak;\r\ncase CISTPL_LONGLINK_MFC:\r\nret = parse_longlink_mfc(tuple, &parse->longlink_mfc);\r\nbreak;\r\ncase CISTPL_VERS_1:\r\nret = parse_vers_1(tuple, &parse->version_1);\r\nbreak;\r\ncase CISTPL_ALTSTR:\r\nret = parse_altstr(tuple, &parse->altstr);\r\nbreak;\r\ncase CISTPL_JEDEC_A:\r\ncase CISTPL_JEDEC_C:\r\nret = parse_jedec(tuple, &parse->jedec);\r\nbreak;\r\ncase CISTPL_MANFID:\r\nret = parse_manfid(tuple, &parse->manfid);\r\nbreak;\r\ncase CISTPL_FUNCID:\r\nret = parse_funcid(tuple, &parse->funcid);\r\nbreak;\r\ncase CISTPL_FUNCE:\r\nret = parse_funce(tuple, &parse->funce);\r\nbreak;\r\ncase CISTPL_CONFIG:\r\nret = parse_config(tuple, &parse->config);\r\nbreak;\r\ncase CISTPL_CFTABLE_ENTRY:\r\nret = parse_cftable_entry(tuple, &parse->cftable_entry);\r\nbreak;\r\ncase CISTPL_DEVICE_GEO:\r\ncase CISTPL_DEVICE_GEO_A:\r\nret = parse_device_geo(tuple, &parse->device_geo);\r\nbreak;\r\ncase CISTPL_VERS_2:\r\nret = parse_vers_2(tuple, &parse->vers_2);\r\nbreak;\r\ncase CISTPL_ORG:\r\nret = parse_org(tuple, &parse->org);\r\nbreak;\r\ncase CISTPL_FORMAT:\r\ncase CISTPL_FORMAT_A:\r\nret = parse_format(tuple, &parse->format);\r\nbreak;\r\ncase CISTPL_NO_LINK:\r\ncase CISTPL_LINKTARGET:\r\nret = 0;\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nif (ret)\r\npr_debug("parse_tuple failed %d\n", ret);\r\nreturn ret;\r\n}\r\nint pccard_validate_cis(struct pcmcia_socket *s, unsigned int *info)\r\n{\r\ntuple_t *tuple;\r\ncisparse_t *p;\r\nunsigned int count = 0;\r\nint ret, reserved, dev_ok = 0, ident_ok = 0;\r\nif (!s)\r\nreturn -EINVAL;\r\nif (s->functions || !(s->state & SOCKET_PRESENT)) {\r\nWARN_ON(1);\r\nreturn -EINVAL;\r\n}\r\nmutex_lock(&s->ops_mutex);\r\ndestroy_cis_cache(s);\r\nmutex_unlock(&s->ops_mutex);\r\ntuple = kmalloc(sizeof(*tuple), GFP_KERNEL);\r\nif (tuple == NULL) {\r\ndev_warn(&s->dev, "no memory to validate CIS\n");\r\nreturn -ENOMEM;\r\n}\r\np = kmalloc(sizeof(*p), GFP_KERNEL);\r\nif (p == NULL) {\r\nkfree(tuple);\r\ndev_warn(&s->dev, "no memory to validate CIS\n");\r\nreturn -ENOMEM;\r\n}\r\ncount = reserved = 0;\r\ntuple->DesiredTuple = RETURN_FIRST_TUPLE;\r\ntuple->Attributes = TUPLE_RETURN_COMMON;\r\nret = pccard_get_first_tuple(s, BIND_FN_ALL, tuple);\r\nif (ret != 0)\r\ngoto done;\r\nif ((tuple->TupleCode == CISTPL_DEVICE) ||\r\n(!pccard_read_tuple(s, BIND_FN_ALL, CISTPL_CFTABLE_ENTRY, p)) ||\r\n(!pccard_read_tuple(s, BIND_FN_ALL, CISTPL_CFTABLE_ENTRY_CB, p)))\r\ndev_ok++;\r\nif ((pccard_read_tuple(s, BIND_FN_ALL, CISTPL_MANFID, p) == 0) ||\r\n(pccard_read_tuple(s, BIND_FN_ALL, CISTPL_VERS_1, p) == 0) ||\r\n(pccard_read_tuple(s, BIND_FN_ALL, CISTPL_VERS_2, p) != -ENOSPC))\r\nident_ok++;\r\nif (!dev_ok && !ident_ok)\r\ngoto done;\r\nfor (count = 1; count < MAX_TUPLES; count++) {\r\nret = pccard_get_next_tuple(s, BIND_FN_ALL, tuple);\r\nif (ret != 0)\r\nbreak;\r\nif (((tuple->TupleCode > 0x23) && (tuple->TupleCode < 0x40)) ||\r\n((tuple->TupleCode > 0x47) && (tuple->TupleCode < 0x80)) ||\r\n((tuple->TupleCode > 0x90) && (tuple->TupleCode < 0xff)))\r\nreserved++;\r\n}\r\nif ((count == MAX_TUPLES) || (reserved > 5) ||\r\n((!dev_ok || !ident_ok) && (count > 10)))\r\ncount = 0;\r\nret = 0;\r\ndone:\r\nif (!dev_ok || !ident_ok || !count) {\r\n#if defined(CONFIG_MTD_PCMCIA_ANONYMOUS)\r\nif (!dev_ok || !ident_ok) {\r\ndev_info(&s->dev, "no CIS, assuming an anonymous memory card.\n");\r\npcmcia_replace_cis(s, "\xFF", 1);\r\ncount = 1;\r\nret = 0;\r\n} else\r\n#endif\r\n{\r\nmutex_lock(&s->ops_mutex);\r\ndestroy_cis_cache(s);\r\nmutex_unlock(&s->ops_mutex);\r\nret = -EIO;\r\n}\r\n}\r\nif (info)\r\n*info = count;\r\nkfree(tuple);\r\nkfree(p);\r\nreturn ret;\r\n}\r\nstatic ssize_t pccard_extract_cis(struct pcmcia_socket *s, char *buf,\r\nloff_t off, size_t count)\r\n{\r\ntuple_t tuple;\r\nint status, i;\r\nloff_t pointer = 0;\r\nssize_t ret = 0;\r\nu_char *tuplebuffer;\r\nu_char *tempbuffer;\r\ntuplebuffer = kmalloc(sizeof(u_char) * 256, GFP_KERNEL);\r\nif (!tuplebuffer)\r\nreturn -ENOMEM;\r\ntempbuffer = kmalloc(sizeof(u_char) * 258, GFP_KERNEL);\r\nif (!tempbuffer) {\r\nret = -ENOMEM;\r\ngoto free_tuple;\r\n}\r\nmemset(&tuple, 0, sizeof(tuple_t));\r\ntuple.Attributes = TUPLE_RETURN_LINK | TUPLE_RETURN_COMMON;\r\ntuple.DesiredTuple = RETURN_FIRST_TUPLE;\r\ntuple.TupleOffset = 0;\r\nstatus = pccard_get_first_tuple(s, BIND_FN_ALL, &tuple);\r\nwhile (!status) {\r\ntuple.TupleData = tuplebuffer;\r\ntuple.TupleDataMax = 255;\r\nmemset(tuplebuffer, 0, sizeof(u_char) * 255);\r\nstatus = pccard_get_tuple_data(s, &tuple);\r\nif (status)\r\nbreak;\r\nif (off < (pointer + 2 + tuple.TupleDataLen)) {\r\ntempbuffer[0] = tuple.TupleCode & 0xff;\r\ntempbuffer[1] = tuple.TupleLink & 0xff;\r\nfor (i = 0; i < tuple.TupleDataLen; i++)\r\ntempbuffer[i + 2] = tuplebuffer[i] & 0xff;\r\nfor (i = 0; i < (2 + tuple.TupleDataLen); i++) {\r\nif (((i + pointer) >= off) &&\r\n(i + pointer) < (off + count)) {\r\nbuf[ret] = tempbuffer[i];\r\nret++;\r\n}\r\n}\r\n}\r\npointer += 2 + tuple.TupleDataLen;\r\nif (pointer >= (off + count))\r\nbreak;\r\nif (tuple.TupleCode == CISTPL_END)\r\nbreak;\r\nstatus = pccard_get_next_tuple(s, BIND_FN_ALL, &tuple);\r\n}\r\nkfree(tempbuffer);\r\nfree_tuple:\r\nkfree(tuplebuffer);\r\nreturn ret;\r\n}\r\nstatic ssize_t pccard_show_cis(struct file *filp, struct kobject *kobj,\r\nstruct bin_attribute *bin_attr,\r\nchar *buf, loff_t off, size_t count)\r\n{\r\nunsigned int size = 0x200;\r\nif (off >= size)\r\ncount = 0;\r\nelse {\r\nstruct pcmcia_socket *s;\r\nunsigned int chains = 1;\r\nif (off + count > size)\r\ncount = size - off;\r\ns = to_socket(container_of(kobj, struct device, kobj));\r\nif (!(s->state & SOCKET_PRESENT))\r\nreturn -ENODEV;\r\nif (!s->functions && pccard_validate_cis(s, &chains))\r\nreturn -EIO;\r\nif (!chains)\r\nreturn -ENODATA;\r\ncount = pccard_extract_cis(s, buf, off, count);\r\n}\r\nreturn count;\r\n}\r\nstatic ssize_t pccard_store_cis(struct file *filp, struct kobject *kobj,\r\nstruct bin_attribute *bin_attr,\r\nchar *buf, loff_t off, size_t count)\r\n{\r\nstruct pcmcia_socket *s;\r\nint error;\r\ns = to_socket(container_of(kobj, struct device, kobj));\r\nif (off)\r\nreturn -EINVAL;\r\nif (count >= CISTPL_MAX_CIS_SIZE)\r\nreturn -EINVAL;\r\nif (!(s->state & SOCKET_PRESENT))\r\nreturn -ENODEV;\r\nerror = pcmcia_replace_cis(s, buf, count);\r\nif (error)\r\nreturn -EIO;\r\npcmcia_parse_uevents(s, PCMCIA_UEVENT_REQUERY);\r\nreturn count;\r\n}
