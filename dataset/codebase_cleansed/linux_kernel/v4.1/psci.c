static unsigned long psci_affinity_mask(unsigned long affinity_level)\r\n{\r\nif (affinity_level <= 3)\r\nreturn MPIDR_HWID_BITMASK & AFFINITY_MASK(affinity_level);\r\nreturn 0;\r\n}\r\nstatic unsigned long kvm_psci_vcpu_suspend(struct kvm_vcpu *vcpu)\r\n{\r\nkvm_vcpu_block(vcpu);\r\nreturn PSCI_RET_SUCCESS;\r\n}\r\nstatic void kvm_psci_vcpu_off(struct kvm_vcpu *vcpu)\r\n{\r\nvcpu->arch.pause = true;\r\n}\r\nstatic unsigned long kvm_psci_vcpu_on(struct kvm_vcpu *source_vcpu)\r\n{\r\nstruct kvm *kvm = source_vcpu->kvm;\r\nstruct kvm_vcpu *vcpu = NULL;\r\nwait_queue_head_t *wq;\r\nunsigned long cpu_id;\r\nunsigned long context_id;\r\nphys_addr_t target_pc;\r\ncpu_id = *vcpu_reg(source_vcpu, 1) & MPIDR_HWID_BITMASK;\r\nif (vcpu_mode_is_32bit(source_vcpu))\r\ncpu_id &= ~((u32) 0);\r\nvcpu = kvm_mpidr_to_vcpu(kvm, cpu_id);\r\nif (!vcpu)\r\nreturn PSCI_RET_INVALID_PARAMS;\r\nif (!vcpu->arch.pause) {\r\nif (kvm_psci_version(source_vcpu) != KVM_ARM_PSCI_0_1)\r\nreturn PSCI_RET_ALREADY_ON;\r\nelse\r\nreturn PSCI_RET_INVALID_PARAMS;\r\n}\r\ntarget_pc = *vcpu_reg(source_vcpu, 2);\r\ncontext_id = *vcpu_reg(source_vcpu, 3);\r\nkvm_reset_vcpu(vcpu);\r\nif (vcpu_mode_is_32bit(vcpu) && (target_pc & 1)) {\r\ntarget_pc &= ~((phys_addr_t) 1);\r\nvcpu_set_thumb(vcpu);\r\n}\r\nif (kvm_vcpu_is_be(source_vcpu))\r\nkvm_vcpu_set_be(vcpu);\r\n*vcpu_pc(vcpu) = target_pc;\r\n*vcpu_reg(vcpu, 0) = context_id;\r\nvcpu->arch.pause = false;\r\nsmp_mb();\r\nwq = kvm_arch_vcpu_wq(vcpu);\r\nwake_up_interruptible(wq);\r\nreturn PSCI_RET_SUCCESS;\r\n}\r\nstatic unsigned long kvm_psci_vcpu_affinity_info(struct kvm_vcpu *vcpu)\r\n{\r\nint i;\r\nunsigned long mpidr;\r\nunsigned long target_affinity;\r\nunsigned long target_affinity_mask;\r\nunsigned long lowest_affinity_level;\r\nstruct kvm *kvm = vcpu->kvm;\r\nstruct kvm_vcpu *tmp;\r\ntarget_affinity = *vcpu_reg(vcpu, 1);\r\nlowest_affinity_level = *vcpu_reg(vcpu, 2);\r\ntarget_affinity_mask = psci_affinity_mask(lowest_affinity_level);\r\nif (!target_affinity_mask)\r\nreturn PSCI_RET_INVALID_PARAMS;\r\ntarget_affinity &= target_affinity_mask;\r\nkvm_for_each_vcpu(i, tmp, kvm) {\r\nmpidr = kvm_vcpu_get_mpidr_aff(tmp);\r\nif (((mpidr & target_affinity_mask) == target_affinity) &&\r\n!tmp->arch.pause) {\r\nreturn PSCI_0_2_AFFINITY_LEVEL_ON;\r\n}\r\n}\r\nreturn PSCI_0_2_AFFINITY_LEVEL_OFF;\r\n}\r\nstatic void kvm_prepare_system_event(struct kvm_vcpu *vcpu, u32 type)\r\n{\r\nint i;\r\nstruct kvm_vcpu *tmp;\r\nkvm_for_each_vcpu(i, tmp, vcpu->kvm) {\r\ntmp->arch.pause = true;\r\nkvm_vcpu_kick(tmp);\r\n}\r\nmemset(&vcpu->run->system_event, 0, sizeof(vcpu->run->system_event));\r\nvcpu->run->system_event.type = type;\r\nvcpu->run->exit_reason = KVM_EXIT_SYSTEM_EVENT;\r\n}\r\nstatic void kvm_psci_system_off(struct kvm_vcpu *vcpu)\r\n{\r\nkvm_prepare_system_event(vcpu, KVM_SYSTEM_EVENT_SHUTDOWN);\r\n}\r\nstatic void kvm_psci_system_reset(struct kvm_vcpu *vcpu)\r\n{\r\nkvm_prepare_system_event(vcpu, KVM_SYSTEM_EVENT_RESET);\r\n}\r\nint kvm_psci_version(struct kvm_vcpu *vcpu)\r\n{\r\nif (test_bit(KVM_ARM_VCPU_PSCI_0_2, vcpu->arch.features))\r\nreturn KVM_ARM_PSCI_0_2;\r\nreturn KVM_ARM_PSCI_0_1;\r\n}\r\nstatic int kvm_psci_0_2_call(struct kvm_vcpu *vcpu)\r\n{\r\nint ret = 1;\r\nunsigned long psci_fn = *vcpu_reg(vcpu, 0) & ~((u32) 0);\r\nunsigned long val;\r\nswitch (psci_fn) {\r\ncase PSCI_0_2_FN_PSCI_VERSION:\r\nval = 2;\r\nbreak;\r\ncase PSCI_0_2_FN_CPU_SUSPEND:\r\ncase PSCI_0_2_FN64_CPU_SUSPEND:\r\nval = kvm_psci_vcpu_suspend(vcpu);\r\nbreak;\r\ncase PSCI_0_2_FN_CPU_OFF:\r\nkvm_psci_vcpu_off(vcpu);\r\nval = PSCI_RET_SUCCESS;\r\nbreak;\r\ncase PSCI_0_2_FN_CPU_ON:\r\ncase PSCI_0_2_FN64_CPU_ON:\r\nval = kvm_psci_vcpu_on(vcpu);\r\nbreak;\r\ncase PSCI_0_2_FN_AFFINITY_INFO:\r\ncase PSCI_0_2_FN64_AFFINITY_INFO:\r\nval = kvm_psci_vcpu_affinity_info(vcpu);\r\nbreak;\r\ncase PSCI_0_2_FN_MIGRATE:\r\ncase PSCI_0_2_FN64_MIGRATE:\r\nval = PSCI_RET_NOT_SUPPORTED;\r\nbreak;\r\ncase PSCI_0_2_FN_MIGRATE_INFO_TYPE:\r\nval = PSCI_0_2_TOS_MP;\r\nbreak;\r\ncase PSCI_0_2_FN_MIGRATE_INFO_UP_CPU:\r\ncase PSCI_0_2_FN64_MIGRATE_INFO_UP_CPU:\r\nval = PSCI_RET_NOT_SUPPORTED;\r\nbreak;\r\ncase PSCI_0_2_FN_SYSTEM_OFF:\r\nkvm_psci_system_off(vcpu);\r\nval = PSCI_RET_INTERNAL_FAILURE;\r\nret = 0;\r\nbreak;\r\ncase PSCI_0_2_FN_SYSTEM_RESET:\r\nkvm_psci_system_reset(vcpu);\r\nval = PSCI_RET_INTERNAL_FAILURE;\r\nret = 0;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n*vcpu_reg(vcpu, 0) = val;\r\nreturn ret;\r\n}\r\nstatic int kvm_psci_0_1_call(struct kvm_vcpu *vcpu)\r\n{\r\nunsigned long psci_fn = *vcpu_reg(vcpu, 0) & ~((u32) 0);\r\nunsigned long val;\r\nswitch (psci_fn) {\r\ncase KVM_PSCI_FN_CPU_OFF:\r\nkvm_psci_vcpu_off(vcpu);\r\nval = PSCI_RET_SUCCESS;\r\nbreak;\r\ncase KVM_PSCI_FN_CPU_ON:\r\nval = kvm_psci_vcpu_on(vcpu);\r\nbreak;\r\ncase KVM_PSCI_FN_CPU_SUSPEND:\r\ncase KVM_PSCI_FN_MIGRATE:\r\nval = PSCI_RET_NOT_SUPPORTED;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n*vcpu_reg(vcpu, 0) = val;\r\nreturn 1;\r\n}\r\nint kvm_psci_call(struct kvm_vcpu *vcpu)\r\n{\r\nswitch (kvm_psci_version(vcpu)) {\r\ncase KVM_ARM_PSCI_0_2:\r\nreturn kvm_psci_0_2_call(vcpu);\r\ncase KVM_ARM_PSCI_0_1:\r\nreturn kvm_psci_0_1_call(vcpu);\r\ndefault:\r\nreturn -EINVAL;\r\n};\r\n}
