static ssize_t\r\naxon_ram_sysfs_ecc(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct platform_device *device = to_platform_device(dev);\r\nstruct axon_ram_bank *bank = device->dev.platform_data;\r\nBUG_ON(!bank);\r\nreturn sprintf(buf, "%ld\n", bank->ecc_counter);\r\n}\r\nstatic irqreturn_t\r\naxon_ram_irq_handler(int irq, void *dev)\r\n{\r\nstruct platform_device *device = dev;\r\nstruct axon_ram_bank *bank = device->dev.platform_data;\r\nBUG_ON(!bank);\r\ndev_err(&device->dev, "Correctable memory error occurred\n");\r\nbank->ecc_counter++;\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void\r\naxon_ram_make_request(struct request_queue *queue, struct bio *bio)\r\n{\r\nstruct axon_ram_bank *bank = bio->bi_bdev->bd_disk->private_data;\r\nunsigned long phys_mem, phys_end;\r\nvoid *user_mem;\r\nstruct bio_vec vec;\r\nunsigned int transfered;\r\nstruct bvec_iter iter;\r\nphys_mem = bank->io_addr + (bio->bi_iter.bi_sector <<\r\nAXON_RAM_SECTOR_SHIFT);\r\nphys_end = bank->io_addr + bank->size;\r\ntransfered = 0;\r\nbio_for_each_segment(vec, bio, iter) {\r\nif (unlikely(phys_mem + vec.bv_len > phys_end)) {\r\nbio_io_error(bio);\r\nreturn;\r\n}\r\nuser_mem = page_address(vec.bv_page) + vec.bv_offset;\r\nif (bio_data_dir(bio) == READ)\r\nmemcpy(user_mem, (void *) phys_mem, vec.bv_len);\r\nelse\r\nmemcpy((void *) phys_mem, user_mem, vec.bv_len);\r\nphys_mem += vec.bv_len;\r\ntransfered += vec.bv_len;\r\n}\r\nbio_endio(bio, 0);\r\n}\r\nstatic long\r\naxon_ram_direct_access(struct block_device *device, sector_t sector,\r\nvoid **kaddr, unsigned long *pfn, long size)\r\n{\r\nstruct axon_ram_bank *bank = device->bd_disk->private_data;\r\nloff_t offset = (loff_t)sector << AXON_RAM_SECTOR_SHIFT;\r\n*kaddr = (void *)(bank->ph_addr + offset);\r\n*pfn = virt_to_phys(*kaddr) >> PAGE_SHIFT;\r\nreturn bank->size - offset;\r\n}\r\nstatic int axon_ram_probe(struct platform_device *device)\r\n{\r\nstatic int axon_ram_bank_id = -1;\r\nstruct axon_ram_bank *bank;\r\nstruct resource resource;\r\nint rc = 0;\r\naxon_ram_bank_id++;\r\ndev_info(&device->dev, "Found memory controller on %s\n",\r\ndevice->dev.of_node->full_name);\r\nbank = kzalloc(sizeof(struct axon_ram_bank), GFP_KERNEL);\r\nif (bank == NULL) {\r\ndev_err(&device->dev, "Out of memory\n");\r\nrc = -ENOMEM;\r\ngoto failed;\r\n}\r\ndevice->dev.platform_data = bank;\r\nbank->device = device;\r\nif (of_address_to_resource(device->dev.of_node, 0, &resource) != 0) {\r\ndev_err(&device->dev, "Cannot access device tree\n");\r\nrc = -EFAULT;\r\ngoto failed;\r\n}\r\nbank->size = resource_size(&resource);\r\nif (bank->size == 0) {\r\ndev_err(&device->dev, "No DDR2 memory found for %s%d\n",\r\nAXON_RAM_DEVICE_NAME, axon_ram_bank_id);\r\nrc = -ENODEV;\r\ngoto failed;\r\n}\r\ndev_info(&device->dev, "Register DDR2 memory device %s%d with %luMB\n",\r\nAXON_RAM_DEVICE_NAME, axon_ram_bank_id, bank->size >> 20);\r\nbank->ph_addr = resource.start;\r\nbank->io_addr = (unsigned long) ioremap_prot(\r\nbank->ph_addr, bank->size, _PAGE_NO_CACHE);\r\nif (bank->io_addr == 0) {\r\ndev_err(&device->dev, "ioremap() failed\n");\r\nrc = -EFAULT;\r\ngoto failed;\r\n}\r\nbank->disk = alloc_disk(AXON_RAM_MINORS_PER_DISK);\r\nif (bank->disk == NULL) {\r\ndev_err(&device->dev, "Cannot register disk\n");\r\nrc = -EFAULT;\r\ngoto failed;\r\n}\r\nbank->disk->major = azfs_major;\r\nbank->disk->first_minor = azfs_minor;\r\nbank->disk->fops = &axon_ram_devops;\r\nbank->disk->private_data = bank;\r\nbank->disk->driverfs_dev = &device->dev;\r\nsprintf(bank->disk->disk_name, "%s%d",\r\nAXON_RAM_DEVICE_NAME, axon_ram_bank_id);\r\nbank->disk->queue = blk_alloc_queue(GFP_KERNEL);\r\nif (bank->disk->queue == NULL) {\r\ndev_err(&device->dev, "Cannot register disk queue\n");\r\nrc = -EFAULT;\r\ngoto failed;\r\n}\r\nset_capacity(bank->disk, bank->size >> AXON_RAM_SECTOR_SHIFT);\r\nblk_queue_make_request(bank->disk->queue, axon_ram_make_request);\r\nblk_queue_logical_block_size(bank->disk->queue, AXON_RAM_SECTOR_SIZE);\r\nadd_disk(bank->disk);\r\nbank->irq_id = irq_of_parse_and_map(device->dev.of_node, 0);\r\nif (bank->irq_id == NO_IRQ) {\r\ndev_err(&device->dev, "Cannot access ECC interrupt ID\n");\r\nrc = -EFAULT;\r\ngoto failed;\r\n}\r\nrc = request_irq(bank->irq_id, axon_ram_irq_handler,\r\nAXON_RAM_IRQ_FLAGS, bank->disk->disk_name, device);\r\nif (rc != 0) {\r\ndev_err(&device->dev, "Cannot register ECC interrupt handler\n");\r\nbank->irq_id = NO_IRQ;\r\nrc = -EFAULT;\r\ngoto failed;\r\n}\r\nrc = device_create_file(&device->dev, &dev_attr_ecc);\r\nif (rc != 0) {\r\ndev_err(&device->dev, "Cannot create sysfs file\n");\r\nrc = -EFAULT;\r\ngoto failed;\r\n}\r\nazfs_minor += bank->disk->minors;\r\nreturn 0;\r\nfailed:\r\nif (bank != NULL) {\r\nif (bank->irq_id != NO_IRQ)\r\nfree_irq(bank->irq_id, device);\r\nif (bank->disk != NULL) {\r\nif (bank->disk->major > 0)\r\nunregister_blkdev(bank->disk->major,\r\nbank->disk->disk_name);\r\ndel_gendisk(bank->disk);\r\n}\r\ndevice->dev.platform_data = NULL;\r\nif (bank->io_addr != 0)\r\niounmap((void __iomem *) bank->io_addr);\r\nkfree(bank);\r\n}\r\nreturn rc;\r\n}\r\nstatic int\r\naxon_ram_remove(struct platform_device *device)\r\n{\r\nstruct axon_ram_bank *bank = device->dev.platform_data;\r\nBUG_ON(!bank || !bank->disk);\r\ndevice_remove_file(&device->dev, &dev_attr_ecc);\r\nfree_irq(bank->irq_id, device);\r\ndel_gendisk(bank->disk);\r\niounmap((void __iomem *) bank->io_addr);\r\nkfree(bank);\r\nreturn 0;\r\n}\r\nstatic int __init\r\naxon_ram_init(void)\r\n{\r\nazfs_major = register_blkdev(azfs_major, AXON_RAM_DEVICE_NAME);\r\nif (azfs_major < 0) {\r\nprintk(KERN_ERR "%s cannot become block device major number\n",\r\nAXON_RAM_MODULE_NAME);\r\nreturn -EFAULT;\r\n}\r\nazfs_minor = 0;\r\nreturn platform_driver_register(&axon_ram_driver);\r\n}\r\nstatic void __exit\r\naxon_ram_exit(void)\r\n{\r\nplatform_driver_unregister(&axon_ram_driver);\r\nunregister_blkdev(azfs_major, AXON_RAM_DEVICE_NAME);\r\n}
