void\r\nmegasas_issue_dcmd(struct megasas_instance *instance, struct megasas_cmd *cmd)\r\n{\r\ninstance->instancet->fire_cmd(instance,\r\ncmd->frame_phys_addr, 0, instance->reg_set);\r\n}\r\nstruct megasas_cmd *megasas_get_cmd(struct megasas_instance\r\n*instance)\r\n{\r\nunsigned long flags;\r\nstruct megasas_cmd *cmd = NULL;\r\nspin_lock_irqsave(&instance->mfi_pool_lock, flags);\r\nif (!list_empty(&instance->cmd_pool)) {\r\ncmd = list_entry((&instance->cmd_pool)->next,\r\nstruct megasas_cmd, list);\r\nlist_del_init(&cmd->list);\r\natomic_set(&cmd->mfi_mpt_pthr, MFI_MPT_DETACHED);\r\n} else {\r\nprintk(KERN_ERR "megasas: Command pool empty!\n");\r\n}\r\nspin_unlock_irqrestore(&instance->mfi_pool_lock, flags);\r\nreturn cmd;\r\n}\r\ninline void\r\n__megasas_return_cmd(struct megasas_instance *instance, struct megasas_cmd *cmd)\r\n{\r\nif (atomic_read(&cmd->mfi_mpt_pthr) != MFI_MPT_DETACHED)\r\nreturn;\r\ncmd->scmd = NULL;\r\ncmd->frame_count = 0;\r\ncmd->is_wait_event = 0;\r\ncmd->mpt_pthr_cmd_blocked = NULL;\r\nif ((instance->pdev->device != PCI_DEVICE_ID_LSI_FUSION) &&\r\n(instance->pdev->device != PCI_DEVICE_ID_LSI_INVADER) &&\r\n(instance->pdev->device != PCI_DEVICE_ID_LSI_FURY) &&\r\n(reset_devices))\r\ncmd->frame->hdr.cmd = MFI_CMD_INVALID;\r\natomic_set(&cmd->mfi_mpt_pthr, MFI_LIST_ADDED);\r\nlist_add(&cmd->list, (&instance->cmd_pool)->next);\r\n}\r\ninline void\r\nmegasas_return_cmd(struct megasas_instance *instance, struct megasas_cmd *cmd)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&instance->mfi_pool_lock, flags);\r\n__megasas_return_cmd(instance, cmd);\r\nspin_unlock_irqrestore(&instance->mfi_pool_lock, flags);\r\n}\r\nstatic inline void\r\nmegasas_enable_intr_xscale(struct megasas_instance *instance)\r\n{\r\nstruct megasas_register_set __iomem *regs;\r\nregs = instance->reg_set;\r\nwritel(0, &(regs)->outbound_intr_mask);\r\nreadl(&regs->outbound_intr_mask);\r\n}\r\nstatic inline void\r\nmegasas_disable_intr_xscale(struct megasas_instance *instance)\r\n{\r\nstruct megasas_register_set __iomem *regs;\r\nu32 mask = 0x1f;\r\nregs = instance->reg_set;\r\nwritel(mask, &regs->outbound_intr_mask);\r\nreadl(&regs->outbound_intr_mask);\r\n}\r\nstatic u32\r\nmegasas_read_fw_status_reg_xscale(struct megasas_register_set __iomem * regs)\r\n{\r\nreturn readl(&(regs)->outbound_msg_0);\r\n}\r\nstatic int\r\nmegasas_clear_intr_xscale(struct megasas_register_set __iomem * regs)\r\n{\r\nu32 status;\r\nu32 mfiStatus = 0;\r\nstatus = readl(&regs->outbound_intr_status);\r\nif (status & MFI_OB_INTR_STATUS_MASK)\r\nmfiStatus = MFI_INTR_FLAG_REPLY_MESSAGE;\r\nif (status & MFI_XSCALE_OMR0_CHANGE_INTERRUPT)\r\nmfiStatus |= MFI_INTR_FLAG_FIRMWARE_STATE_CHANGE;\r\nif (mfiStatus)\r\nwritel(status, &regs->outbound_intr_status);\r\nreadl(&regs->outbound_intr_status);\r\nreturn mfiStatus;\r\n}\r\nstatic inline void\r\nmegasas_fire_cmd_xscale(struct megasas_instance *instance,\r\ndma_addr_t frame_phys_addr,\r\nu32 frame_count,\r\nstruct megasas_register_set __iomem *regs)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&instance->hba_lock, flags);\r\nwritel((frame_phys_addr >> 3)|(frame_count),\r\n&(regs)->inbound_queue_port);\r\nspin_unlock_irqrestore(&instance->hba_lock, flags);\r\n}\r\nstatic int\r\nmegasas_adp_reset_xscale(struct megasas_instance *instance,\r\nstruct megasas_register_set __iomem *regs)\r\n{\r\nu32 i;\r\nu32 pcidata;\r\nwritel(MFI_ADP_RESET, &regs->inbound_doorbell);\r\nfor (i = 0; i < 3; i++)\r\nmsleep(1000);\r\npcidata = 0;\r\npci_read_config_dword(instance->pdev, MFI_1068_PCSR_OFFSET, &pcidata);\r\nprintk(KERN_NOTICE "pcidata = %x\n", pcidata);\r\nif (pcidata & 0x2) {\r\nprintk(KERN_NOTICE "mfi 1068 offset read=%x\n", pcidata);\r\npcidata &= ~0x2;\r\npci_write_config_dword(instance->pdev,\r\nMFI_1068_PCSR_OFFSET, pcidata);\r\nfor (i = 0; i < 2; i++)\r\nmsleep(1000);\r\npcidata = 0;\r\npci_read_config_dword(instance->pdev,\r\nMFI_1068_FW_HANDSHAKE_OFFSET, &pcidata);\r\nprintk(KERN_NOTICE "1068 offset handshake read=%x\n", pcidata);\r\nif ((pcidata & 0xffff0000) == MFI_1068_FW_READY) {\r\nprintk(KERN_NOTICE "1068 offset pcidt=%x\n", pcidata);\r\npcidata = 0;\r\npci_write_config_dword(instance->pdev,\r\nMFI_1068_FW_HANDSHAKE_OFFSET, pcidata);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nmegasas_check_reset_xscale(struct megasas_instance *instance,\r\nstruct megasas_register_set __iomem *regs)\r\n{\r\nif ((instance->adprecovery != MEGASAS_HBA_OPERATIONAL) &&\r\n(le32_to_cpu(*instance->consumer) ==\r\nMEGASAS_ADPRESET_INPROG_SIGN))\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic inline void\r\nmegasas_enable_intr_ppc(struct megasas_instance *instance)\r\n{\r\nstruct megasas_register_set __iomem *regs;\r\nregs = instance->reg_set;\r\nwritel(0xFFFFFFFF, &(regs)->outbound_doorbell_clear);\r\nwritel(~0x80000000, &(regs)->outbound_intr_mask);\r\nreadl(&regs->outbound_intr_mask);\r\n}\r\nstatic inline void\r\nmegasas_disable_intr_ppc(struct megasas_instance *instance)\r\n{\r\nstruct megasas_register_set __iomem *regs;\r\nu32 mask = 0xFFFFFFFF;\r\nregs = instance->reg_set;\r\nwritel(mask, &regs->outbound_intr_mask);\r\nreadl(&regs->outbound_intr_mask);\r\n}\r\nstatic u32\r\nmegasas_read_fw_status_reg_ppc(struct megasas_register_set __iomem * regs)\r\n{\r\nreturn readl(&(regs)->outbound_scratch_pad);\r\n}\r\nstatic int\r\nmegasas_clear_intr_ppc(struct megasas_register_set __iomem * regs)\r\n{\r\nu32 status, mfiStatus = 0;\r\nstatus = readl(&regs->outbound_intr_status);\r\nif (status & MFI_REPLY_1078_MESSAGE_INTERRUPT)\r\nmfiStatus = MFI_INTR_FLAG_REPLY_MESSAGE;\r\nif (status & MFI_G2_OUTBOUND_DOORBELL_CHANGE_INTERRUPT)\r\nmfiStatus |= MFI_INTR_FLAG_FIRMWARE_STATE_CHANGE;\r\nwritel(status, &regs->outbound_doorbell_clear);\r\nreadl(&regs->outbound_doorbell_clear);\r\nreturn mfiStatus;\r\n}\r\nstatic inline void\r\nmegasas_fire_cmd_ppc(struct megasas_instance *instance,\r\ndma_addr_t frame_phys_addr,\r\nu32 frame_count,\r\nstruct megasas_register_set __iomem *regs)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&instance->hba_lock, flags);\r\nwritel((frame_phys_addr | (frame_count<<1))|1,\r\n&(regs)->inbound_queue_port);\r\nspin_unlock_irqrestore(&instance->hba_lock, flags);\r\n}\r\nstatic int\r\nmegasas_check_reset_ppc(struct megasas_instance *instance,\r\nstruct megasas_register_set __iomem *regs)\r\n{\r\nif (instance->adprecovery != MEGASAS_HBA_OPERATIONAL)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic inline void\r\nmegasas_enable_intr_skinny(struct megasas_instance *instance)\r\n{\r\nstruct megasas_register_set __iomem *regs;\r\nregs = instance->reg_set;\r\nwritel(0xFFFFFFFF, &(regs)->outbound_intr_mask);\r\nwritel(~MFI_SKINNY_ENABLE_INTERRUPT_MASK, &(regs)->outbound_intr_mask);\r\nreadl(&regs->outbound_intr_mask);\r\n}\r\nstatic inline void\r\nmegasas_disable_intr_skinny(struct megasas_instance *instance)\r\n{\r\nstruct megasas_register_set __iomem *regs;\r\nu32 mask = 0xFFFFFFFF;\r\nregs = instance->reg_set;\r\nwritel(mask, &regs->outbound_intr_mask);\r\nreadl(&regs->outbound_intr_mask);\r\n}\r\nstatic u32\r\nmegasas_read_fw_status_reg_skinny(struct megasas_register_set __iomem *regs)\r\n{\r\nreturn readl(&(regs)->outbound_scratch_pad);\r\n}\r\nstatic int\r\nmegasas_clear_intr_skinny(struct megasas_register_set __iomem *regs)\r\n{\r\nu32 status;\r\nu32 mfiStatus = 0;\r\nstatus = readl(&regs->outbound_intr_status);\r\nif (!(status & MFI_SKINNY_ENABLE_INTERRUPT_MASK)) {\r\nreturn 0;\r\n}\r\nif ((megasas_read_fw_status_reg_skinny(regs) & MFI_STATE_MASK) ==\r\nMFI_STATE_FAULT) {\r\nmfiStatus = MFI_INTR_FLAG_FIRMWARE_STATE_CHANGE;\r\n} else\r\nmfiStatus = MFI_INTR_FLAG_REPLY_MESSAGE;\r\nwritel(status, &regs->outbound_intr_status);\r\nreadl(&regs->outbound_intr_status);\r\nreturn mfiStatus;\r\n}\r\nstatic inline void\r\nmegasas_fire_cmd_skinny(struct megasas_instance *instance,\r\ndma_addr_t frame_phys_addr,\r\nu32 frame_count,\r\nstruct megasas_register_set __iomem *regs)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&instance->hba_lock, flags);\r\nwritel(upper_32_bits(frame_phys_addr),\r\n&(regs)->inbound_high_queue_port);\r\nwritel((lower_32_bits(frame_phys_addr) | (frame_count<<1))|1,\r\n&(regs)->inbound_low_queue_port);\r\nspin_unlock_irqrestore(&instance->hba_lock, flags);\r\n}\r\nstatic int\r\nmegasas_check_reset_skinny(struct megasas_instance *instance,\r\nstruct megasas_register_set __iomem *regs)\r\n{\r\nif (instance->adprecovery != MEGASAS_HBA_OPERATIONAL)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic inline void\r\nmegasas_enable_intr_gen2(struct megasas_instance *instance)\r\n{\r\nstruct megasas_register_set __iomem *regs;\r\nregs = instance->reg_set;\r\nwritel(0xFFFFFFFF, &(regs)->outbound_doorbell_clear);\r\nwritel(~MFI_GEN2_ENABLE_INTERRUPT_MASK, &(regs)->outbound_intr_mask);\r\nreadl(&regs->outbound_intr_mask);\r\n}\r\nstatic inline void\r\nmegasas_disable_intr_gen2(struct megasas_instance *instance)\r\n{\r\nstruct megasas_register_set __iomem *regs;\r\nu32 mask = 0xFFFFFFFF;\r\nregs = instance->reg_set;\r\nwritel(mask, &regs->outbound_intr_mask);\r\nreadl(&regs->outbound_intr_mask);\r\n}\r\nstatic u32\r\nmegasas_read_fw_status_reg_gen2(struct megasas_register_set __iomem *regs)\r\n{\r\nreturn readl(&(regs)->outbound_scratch_pad);\r\n}\r\nstatic int\r\nmegasas_clear_intr_gen2(struct megasas_register_set __iomem *regs)\r\n{\r\nu32 status;\r\nu32 mfiStatus = 0;\r\nstatus = readl(&regs->outbound_intr_status);\r\nif (status & MFI_INTR_FLAG_REPLY_MESSAGE) {\r\nmfiStatus = MFI_INTR_FLAG_REPLY_MESSAGE;\r\n}\r\nif (status & MFI_G2_OUTBOUND_DOORBELL_CHANGE_INTERRUPT) {\r\nmfiStatus |= MFI_INTR_FLAG_FIRMWARE_STATE_CHANGE;\r\n}\r\nif (mfiStatus)\r\nwritel(status, &regs->outbound_doorbell_clear);\r\nreadl(&regs->outbound_intr_status);\r\nreturn mfiStatus;\r\n}\r\nstatic inline void\r\nmegasas_fire_cmd_gen2(struct megasas_instance *instance,\r\ndma_addr_t frame_phys_addr,\r\nu32 frame_count,\r\nstruct megasas_register_set __iomem *regs)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&instance->hba_lock, flags);\r\nwritel((frame_phys_addr | (frame_count<<1))|1,\r\n&(regs)->inbound_queue_port);\r\nspin_unlock_irqrestore(&instance->hba_lock, flags);\r\n}\r\nstatic int\r\nmegasas_adp_reset_gen2(struct megasas_instance *instance,\r\nstruct megasas_register_set __iomem *reg_set)\r\n{\r\nu32 retry = 0 ;\r\nu32 HostDiag;\r\nu32 *seq_offset = &reg_set->seq_offset;\r\nu32 *hostdiag_offset = &reg_set->host_diag;\r\nif (instance->instancet == &megasas_instance_template_skinny) {\r\nseq_offset = &reg_set->fusion_seq_offset;\r\nhostdiag_offset = &reg_set->fusion_host_diag;\r\n}\r\nwritel(0, seq_offset);\r\nwritel(4, seq_offset);\r\nwritel(0xb, seq_offset);\r\nwritel(2, seq_offset);\r\nwritel(7, seq_offset);\r\nwritel(0xd, seq_offset);\r\nmsleep(1000);\r\nHostDiag = (u32)readl(hostdiag_offset);\r\nwhile ( !( HostDiag & DIAG_WRITE_ENABLE) ) {\r\nmsleep(100);\r\nHostDiag = (u32)readl(hostdiag_offset);\r\nprintk(KERN_NOTICE "RESETGEN2: retry=%x, hostdiag=%x\n",\r\nretry, HostDiag);\r\nif (retry++ >= 100)\r\nreturn 1;\r\n}\r\nprintk(KERN_NOTICE "ADP_RESET_GEN2: HostDiag=%x\n", HostDiag);\r\nwritel((HostDiag | DIAG_RESET_ADAPTER), hostdiag_offset);\r\nssleep(10);\r\nHostDiag = (u32)readl(hostdiag_offset);\r\nwhile ( ( HostDiag & DIAG_RESET_ADAPTER) ) {\r\nmsleep(100);\r\nHostDiag = (u32)readl(hostdiag_offset);\r\nprintk(KERN_NOTICE "RESET_GEN2: retry=%x, hostdiag=%x\n",\r\nretry, HostDiag);\r\nif (retry++ >= 1000)\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nmegasas_check_reset_gen2(struct megasas_instance *instance,\r\nstruct megasas_register_set __iomem *regs)\r\n{\r\nif (instance->adprecovery != MEGASAS_HBA_OPERATIONAL) {\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nint\r\nmegasas_issue_polled(struct megasas_instance *instance, struct megasas_cmd *cmd)\r\n{\r\nint seconds;\r\nstruct megasas_header *frame_hdr = &cmd->frame->hdr;\r\nframe_hdr->cmd_status = MFI_CMD_STATUS_POLL_MODE;\r\nframe_hdr->flags |= cpu_to_le16(MFI_FRAME_DONT_POST_IN_REPLY_QUEUE);\r\ninstance->instancet->issue_dcmd(instance, cmd);\r\nif (instance->requestorId)\r\nseconds = MEGASAS_ROUTINE_WAIT_TIME_VF;\r\nelse\r\nseconds = MFI_POLL_TIMEOUT_SECS;\r\nreturn wait_and_poll(instance, cmd, seconds);\r\n}\r\nint\r\nmegasas_issue_blocked_cmd(struct megasas_instance *instance,\r\nstruct megasas_cmd *cmd, int timeout)\r\n{\r\nint ret = 0;\r\ncmd->cmd_status = ENODATA;\r\ncmd->is_wait_event = 1;\r\ninstance->instancet->issue_dcmd(instance, cmd);\r\nif (timeout) {\r\nret = wait_event_timeout(instance->int_cmd_wait_q,\r\ncmd->cmd_status != ENODATA, timeout * HZ);\r\nif (!ret)\r\nreturn 1;\r\n} else\r\nwait_event(instance->int_cmd_wait_q,\r\ncmd->cmd_status != ENODATA);\r\nreturn 0;\r\n}\r\nstatic int\r\nmegasas_issue_blocked_abort_cmd(struct megasas_instance *instance,\r\nstruct megasas_cmd *cmd_to_abort, int timeout)\r\n{\r\nstruct megasas_cmd *cmd;\r\nstruct megasas_abort_frame *abort_fr;\r\nint ret = 0;\r\ncmd = megasas_get_cmd(instance);\r\nif (!cmd)\r\nreturn -1;\r\nabort_fr = &cmd->frame->abort;\r\nabort_fr->cmd = MFI_CMD_ABORT;\r\nabort_fr->cmd_status = 0xFF;\r\nabort_fr->flags = cpu_to_le16(0);\r\nabort_fr->abort_context = cpu_to_le32(cmd_to_abort->index);\r\nabort_fr->abort_mfi_phys_addr_lo =\r\ncpu_to_le32(lower_32_bits(cmd_to_abort->frame_phys_addr));\r\nabort_fr->abort_mfi_phys_addr_hi =\r\ncpu_to_le32(upper_32_bits(cmd_to_abort->frame_phys_addr));\r\ncmd->sync_cmd = 1;\r\ncmd->cmd_status = ENODATA;\r\ninstance->instancet->issue_dcmd(instance, cmd);\r\nif (timeout) {\r\nret = wait_event_timeout(instance->abort_cmd_wait_q,\r\ncmd->cmd_status != ENODATA, timeout * HZ);\r\nif (!ret) {\r\ndev_err(&instance->pdev->dev, "Command timedout"\r\n"from %s\n", __func__);\r\nreturn 1;\r\n}\r\n} else\r\nwait_event(instance->abort_cmd_wait_q,\r\ncmd->cmd_status != ENODATA);\r\ncmd->sync_cmd = 0;\r\nmegasas_return_cmd(instance, cmd);\r\nreturn 0;\r\n}\r\nstatic int\r\nmegasas_make_sgl32(struct megasas_instance *instance, struct scsi_cmnd *scp,\r\nunion megasas_sgl *mfi_sgl)\r\n{\r\nint i;\r\nint sge_count;\r\nstruct scatterlist *os_sgl;\r\nsge_count = scsi_dma_map(scp);\r\nBUG_ON(sge_count < 0);\r\nif (sge_count) {\r\nscsi_for_each_sg(scp, os_sgl, sge_count, i) {\r\nmfi_sgl->sge32[i].length = cpu_to_le32(sg_dma_len(os_sgl));\r\nmfi_sgl->sge32[i].phys_addr = cpu_to_le32(sg_dma_address(os_sgl));\r\n}\r\n}\r\nreturn sge_count;\r\n}\r\nstatic int\r\nmegasas_make_sgl64(struct megasas_instance *instance, struct scsi_cmnd *scp,\r\nunion megasas_sgl *mfi_sgl)\r\n{\r\nint i;\r\nint sge_count;\r\nstruct scatterlist *os_sgl;\r\nsge_count = scsi_dma_map(scp);\r\nBUG_ON(sge_count < 0);\r\nif (sge_count) {\r\nscsi_for_each_sg(scp, os_sgl, sge_count, i) {\r\nmfi_sgl->sge64[i].length = cpu_to_le32(sg_dma_len(os_sgl));\r\nmfi_sgl->sge64[i].phys_addr = cpu_to_le64(sg_dma_address(os_sgl));\r\n}\r\n}\r\nreturn sge_count;\r\n}\r\nstatic int\r\nmegasas_make_sgl_skinny(struct megasas_instance *instance,\r\nstruct scsi_cmnd *scp, union megasas_sgl *mfi_sgl)\r\n{\r\nint i;\r\nint sge_count;\r\nstruct scatterlist *os_sgl;\r\nsge_count = scsi_dma_map(scp);\r\nif (sge_count) {\r\nscsi_for_each_sg(scp, os_sgl, sge_count, i) {\r\nmfi_sgl->sge_skinny[i].length =\r\ncpu_to_le32(sg_dma_len(os_sgl));\r\nmfi_sgl->sge_skinny[i].phys_addr =\r\ncpu_to_le64(sg_dma_address(os_sgl));\r\nmfi_sgl->sge_skinny[i].flag = cpu_to_le32(0);\r\n}\r\n}\r\nreturn sge_count;\r\n}\r\nstatic u32 megasas_get_frame_count(struct megasas_instance *instance,\r\nu8 sge_count, u8 frame_type)\r\n{\r\nint num_cnt;\r\nint sge_bytes;\r\nu32 sge_sz;\r\nu32 frame_count=0;\r\nsge_sz = (IS_DMA64) ? sizeof(struct megasas_sge64) :\r\nsizeof(struct megasas_sge32);\r\nif (instance->flag_ieee) {\r\nsge_sz = sizeof(struct megasas_sge_skinny);\r\n}\r\nif (unlikely(frame_type == PTHRU_FRAME)) {\r\nif (instance->flag_ieee == 1) {\r\nnum_cnt = sge_count - 1;\r\n} else if (IS_DMA64)\r\nnum_cnt = sge_count - 1;\r\nelse\r\nnum_cnt = sge_count - 2;\r\n} else {\r\nif (instance->flag_ieee == 1) {\r\nnum_cnt = sge_count - 1;\r\n} else if (IS_DMA64)\r\nnum_cnt = sge_count - 2;\r\nelse\r\nnum_cnt = sge_count - 3;\r\n}\r\nif(num_cnt>0){\r\nsge_bytes = sge_sz * num_cnt;\r\nframe_count = (sge_bytes / MEGAMFI_FRAME_SIZE) +\r\n((sge_bytes % MEGAMFI_FRAME_SIZE) ? 1 : 0) ;\r\n}\r\nframe_count +=1;\r\nif (frame_count > 7)\r\nframe_count = 8;\r\nreturn frame_count;\r\n}\r\nstatic int\r\nmegasas_build_dcdb(struct megasas_instance *instance, struct scsi_cmnd *scp,\r\nstruct megasas_cmd *cmd)\r\n{\r\nu32 is_logical;\r\nu32 device_id;\r\nu16 flags = 0;\r\nstruct megasas_pthru_frame *pthru;\r\nis_logical = MEGASAS_IS_LOGICAL(scp);\r\ndevice_id = MEGASAS_DEV_INDEX(instance, scp);\r\npthru = (struct megasas_pthru_frame *)cmd->frame;\r\nif (scp->sc_data_direction == PCI_DMA_TODEVICE)\r\nflags = MFI_FRAME_DIR_WRITE;\r\nelse if (scp->sc_data_direction == PCI_DMA_FROMDEVICE)\r\nflags = MFI_FRAME_DIR_READ;\r\nelse if (scp->sc_data_direction == PCI_DMA_NONE)\r\nflags = MFI_FRAME_DIR_NONE;\r\nif (instance->flag_ieee == 1) {\r\nflags |= MFI_FRAME_IEEE;\r\n}\r\npthru->cmd = (is_logical) ? MFI_CMD_LD_SCSI_IO : MFI_CMD_PD_SCSI_IO;\r\npthru->cmd_status = 0x0;\r\npthru->scsi_status = 0x0;\r\npthru->target_id = device_id;\r\npthru->lun = scp->device->lun;\r\npthru->cdb_len = scp->cmd_len;\r\npthru->timeout = 0;\r\npthru->pad_0 = 0;\r\npthru->flags = cpu_to_le16(flags);\r\npthru->data_xfer_len = cpu_to_le32(scsi_bufflen(scp));\r\nmemcpy(pthru->cdb, scp->cmnd, scp->cmd_len);\r\nif (scp->device->type == TYPE_TAPE) {\r\nif ((scp->request->timeout / HZ) > 0xFFFF)\r\npthru->timeout = 0xFFFF;\r\nelse\r\npthru->timeout = cpu_to_le16(scp->request->timeout / HZ);\r\n}\r\nif (instance->flag_ieee == 1) {\r\npthru->flags |= cpu_to_le16(MFI_FRAME_SGL64);\r\npthru->sge_count = megasas_make_sgl_skinny(instance, scp,\r\n&pthru->sgl);\r\n} else if (IS_DMA64) {\r\npthru->flags |= cpu_to_le16(MFI_FRAME_SGL64);\r\npthru->sge_count = megasas_make_sgl64(instance, scp,\r\n&pthru->sgl);\r\n} else\r\npthru->sge_count = megasas_make_sgl32(instance, scp,\r\n&pthru->sgl);\r\nif (pthru->sge_count > instance->max_num_sge) {\r\nprintk(KERN_ERR "megasas: DCDB two many SGE NUM=%x\n",\r\npthru->sge_count);\r\nreturn 0;\r\n}\r\npthru->sense_len = SCSI_SENSE_BUFFERSIZE;\r\npthru->sense_buf_phys_addr_hi =\r\ncpu_to_le32(upper_32_bits(cmd->sense_phys_addr));\r\npthru->sense_buf_phys_addr_lo =\r\ncpu_to_le32(lower_32_bits(cmd->sense_phys_addr));\r\ncmd->frame_count = megasas_get_frame_count(instance, pthru->sge_count,\r\nPTHRU_FRAME);\r\nreturn cmd->frame_count;\r\n}\r\nstatic int\r\nmegasas_build_ldio(struct megasas_instance *instance, struct scsi_cmnd *scp,\r\nstruct megasas_cmd *cmd)\r\n{\r\nu32 device_id;\r\nu8 sc = scp->cmnd[0];\r\nu16 flags = 0;\r\nstruct megasas_io_frame *ldio;\r\ndevice_id = MEGASAS_DEV_INDEX(instance, scp);\r\nldio = (struct megasas_io_frame *)cmd->frame;\r\nif (scp->sc_data_direction == PCI_DMA_TODEVICE)\r\nflags = MFI_FRAME_DIR_WRITE;\r\nelse if (scp->sc_data_direction == PCI_DMA_FROMDEVICE)\r\nflags = MFI_FRAME_DIR_READ;\r\nif (instance->flag_ieee == 1) {\r\nflags |= MFI_FRAME_IEEE;\r\n}\r\nldio->cmd = (sc & 0x02) ? MFI_CMD_LD_WRITE : MFI_CMD_LD_READ;\r\nldio->cmd_status = 0x0;\r\nldio->scsi_status = 0x0;\r\nldio->target_id = device_id;\r\nldio->timeout = 0;\r\nldio->reserved_0 = 0;\r\nldio->pad_0 = 0;\r\nldio->flags = cpu_to_le16(flags);\r\nldio->start_lba_hi = 0;\r\nldio->access_byte = (scp->cmd_len != 6) ? scp->cmnd[1] : 0;\r\nif (scp->cmd_len == 6) {\r\nldio->lba_count = cpu_to_le32((u32) scp->cmnd[4]);\r\nldio->start_lba_lo = cpu_to_le32(((u32) scp->cmnd[1] << 16) |\r\n((u32) scp->cmnd[2] << 8) |\r\n(u32) scp->cmnd[3]);\r\nldio->start_lba_lo &= cpu_to_le32(0x1FFFFF);\r\n}\r\nelse if (scp->cmd_len == 10) {\r\nldio->lba_count = cpu_to_le32((u32) scp->cmnd[8] |\r\n((u32) scp->cmnd[7] << 8));\r\nldio->start_lba_lo = cpu_to_le32(((u32) scp->cmnd[2] << 24) |\r\n((u32) scp->cmnd[3] << 16) |\r\n((u32) scp->cmnd[4] << 8) |\r\n(u32) scp->cmnd[5]);\r\n}\r\nelse if (scp->cmd_len == 12) {\r\nldio->lba_count = cpu_to_le32(((u32) scp->cmnd[6] << 24) |\r\n((u32) scp->cmnd[7] << 16) |\r\n((u32) scp->cmnd[8] << 8) |\r\n(u32) scp->cmnd[9]);\r\nldio->start_lba_lo = cpu_to_le32(((u32) scp->cmnd[2] << 24) |\r\n((u32) scp->cmnd[3] << 16) |\r\n((u32) scp->cmnd[4] << 8) |\r\n(u32) scp->cmnd[5]);\r\n}\r\nelse if (scp->cmd_len == 16) {\r\nldio->lba_count = cpu_to_le32(((u32) scp->cmnd[10] << 24) |\r\n((u32) scp->cmnd[11] << 16) |\r\n((u32) scp->cmnd[12] << 8) |\r\n(u32) scp->cmnd[13]);\r\nldio->start_lba_lo = cpu_to_le32(((u32) scp->cmnd[6] << 24) |\r\n((u32) scp->cmnd[7] << 16) |\r\n((u32) scp->cmnd[8] << 8) |\r\n(u32) scp->cmnd[9]);\r\nldio->start_lba_hi = cpu_to_le32(((u32) scp->cmnd[2] << 24) |\r\n((u32) scp->cmnd[3] << 16) |\r\n((u32) scp->cmnd[4] << 8) |\r\n(u32) scp->cmnd[5]);\r\n}\r\nif (instance->flag_ieee) {\r\nldio->flags |= cpu_to_le16(MFI_FRAME_SGL64);\r\nldio->sge_count = megasas_make_sgl_skinny(instance, scp,\r\n&ldio->sgl);\r\n} else if (IS_DMA64) {\r\nldio->flags |= cpu_to_le16(MFI_FRAME_SGL64);\r\nldio->sge_count = megasas_make_sgl64(instance, scp, &ldio->sgl);\r\n} else\r\nldio->sge_count = megasas_make_sgl32(instance, scp, &ldio->sgl);\r\nif (ldio->sge_count > instance->max_num_sge) {\r\nprintk(KERN_ERR "megasas: build_ld_io: sge_count = %x\n",\r\nldio->sge_count);\r\nreturn 0;\r\n}\r\nldio->sense_len = SCSI_SENSE_BUFFERSIZE;\r\nldio->sense_buf_phys_addr_hi = 0;\r\nldio->sense_buf_phys_addr_lo = cpu_to_le32(cmd->sense_phys_addr);\r\ncmd->frame_count = megasas_get_frame_count(instance,\r\nldio->sge_count, IO_FRAME);\r\nreturn cmd->frame_count;\r\n}\r\ninline int megasas_cmd_type(struct scsi_cmnd *cmd)\r\n{\r\nint ret;\r\nswitch (cmd->cmnd[0]) {\r\ncase READ_10:\r\ncase WRITE_10:\r\ncase READ_12:\r\ncase WRITE_12:\r\ncase READ_6:\r\ncase WRITE_6:\r\ncase READ_16:\r\ncase WRITE_16:\r\nret = (MEGASAS_IS_LOGICAL(cmd)) ?\r\nREAD_WRITE_LDIO : READ_WRITE_SYSPDIO;\r\nbreak;\r\ndefault:\r\nret = (MEGASAS_IS_LOGICAL(cmd)) ?\r\nNON_READ_WRITE_LDIO : NON_READ_WRITE_SYSPDIO;\r\n}\r\nreturn ret;\r\n}\r\nstatic inline void\r\nmegasas_dump_pending_frames(struct megasas_instance *instance)\r\n{\r\nstruct megasas_cmd *cmd;\r\nint i,n;\r\nunion megasas_sgl *mfi_sgl;\r\nstruct megasas_io_frame *ldio;\r\nstruct megasas_pthru_frame *pthru;\r\nu32 sgcount;\r\nu32 max_cmd = instance->max_fw_cmds;\r\nprintk(KERN_ERR "\nmegasas[%d]: Dumping Frame Phys Address of all pending cmds in FW\n",instance->host->host_no);\r\nprintk(KERN_ERR "megasas[%d]: Total OS Pending cmds : %d\n",instance->host->host_no,atomic_read(&instance->fw_outstanding));\r\nif (IS_DMA64)\r\nprintk(KERN_ERR "\nmegasas[%d]: 64 bit SGLs were sent to FW\n",instance->host->host_no);\r\nelse\r\nprintk(KERN_ERR "\nmegasas[%d]: 32 bit SGLs were sent to FW\n",instance->host->host_no);\r\nprintk(KERN_ERR "megasas[%d]: Pending OS cmds in FW : \n",instance->host->host_no);\r\nfor (i = 0; i < max_cmd; i++) {\r\ncmd = instance->cmd_list[i];\r\nif(!cmd->scmd)\r\ncontinue;\r\nprintk(KERN_ERR "megasas[%d]: Frame addr :0x%08lx : ",instance->host->host_no,(unsigned long)cmd->frame_phys_addr);\r\nif (megasas_cmd_type(cmd->scmd) == READ_WRITE_LDIO) {\r\nldio = (struct megasas_io_frame *)cmd->frame;\r\nmfi_sgl = &ldio->sgl;\r\nsgcount = ldio->sge_count;\r\nprintk(KERN_ERR "megasas[%d]: frame count : 0x%x, Cmd : 0x%x, Tgt id : 0x%x,"\r\n" lba lo : 0x%x, lba_hi : 0x%x, sense_buf addr : 0x%x,sge count : 0x%x\n",\r\ninstance->host->host_no, cmd->frame_count, ldio->cmd, ldio->target_id,\r\nle32_to_cpu(ldio->start_lba_lo), le32_to_cpu(ldio->start_lba_hi),\r\nle32_to_cpu(ldio->sense_buf_phys_addr_lo), sgcount);\r\n}\r\nelse {\r\npthru = (struct megasas_pthru_frame *) cmd->frame;\r\nmfi_sgl = &pthru->sgl;\r\nsgcount = pthru->sge_count;\r\nprintk(KERN_ERR "megasas[%d]: frame count : 0x%x, Cmd : 0x%x, Tgt id : 0x%x, "\r\n"lun : 0x%x, cdb_len : 0x%x, data xfer len : 0x%x, sense_buf addr : 0x%x,sge count : 0x%x\n",\r\ninstance->host->host_no, cmd->frame_count, pthru->cmd, pthru->target_id,\r\npthru->lun, pthru->cdb_len, le32_to_cpu(pthru->data_xfer_len),\r\nle32_to_cpu(pthru->sense_buf_phys_addr_lo), sgcount);\r\n}\r\nif(megasas_dbg_lvl & MEGASAS_DBG_LVL){\r\nfor (n = 0; n < sgcount; n++){\r\nif (IS_DMA64)\r\nprintk(KERN_ERR "megasas: sgl len : 0x%x, sgl addr : 0x%llx ",\r\nle32_to_cpu(mfi_sgl->sge64[n].length),\r\nle64_to_cpu(mfi_sgl->sge64[n].phys_addr));\r\nelse\r\nprintk(KERN_ERR "megasas: sgl len : 0x%x, sgl addr : 0x%x ",\r\nle32_to_cpu(mfi_sgl->sge32[n].length),\r\nle32_to_cpu(mfi_sgl->sge32[n].phys_addr));\r\n}\r\n}\r\nprintk(KERN_ERR "\n");\r\n}\r\nprintk(KERN_ERR "\nmegasas[%d]: Pending Internal cmds in FW : \n",instance->host->host_no);\r\nfor (i = 0; i < max_cmd; i++) {\r\ncmd = instance->cmd_list[i];\r\nif(cmd->sync_cmd == 1){\r\nprintk(KERN_ERR "0x%08lx : ", (unsigned long)cmd->frame_phys_addr);\r\n}\r\n}\r\nprintk(KERN_ERR "megasas[%d]: Dumping Done.\n\n",instance->host->host_no);\r\n}\r\nu32\r\nmegasas_build_and_issue_cmd(struct megasas_instance *instance,\r\nstruct scsi_cmnd *scmd)\r\n{\r\nstruct megasas_cmd *cmd;\r\nu32 frame_count;\r\ncmd = megasas_get_cmd(instance);\r\nif (!cmd)\r\nreturn SCSI_MLQUEUE_HOST_BUSY;\r\nif (megasas_cmd_type(scmd) == READ_WRITE_LDIO)\r\nframe_count = megasas_build_ldio(instance, scmd, cmd);\r\nelse\r\nframe_count = megasas_build_dcdb(instance, scmd, cmd);\r\nif (!frame_count)\r\ngoto out_return_cmd;\r\ncmd->scmd = scmd;\r\nscmd->SCp.ptr = (char *)cmd;\r\natomic_inc(&instance->fw_outstanding);\r\ninstance->instancet->fire_cmd(instance, cmd->frame_phys_addr,\r\ncmd->frame_count-1, instance->reg_set);\r\nreturn 0;\r\nout_return_cmd:\r\nmegasas_return_cmd(instance, cmd);\r\nreturn 1;\r\n}\r\nstatic int\r\nmegasas_queue_command(struct Scsi_Host *shost, struct scsi_cmnd *scmd)\r\n{\r\nstruct megasas_instance *instance;\r\nunsigned long flags;\r\ninstance = (struct megasas_instance *)\r\nscmd->device->host->hostdata;\r\nif (instance->unload == 1) {\r\nscmd->result = DID_NO_CONNECT << 16;\r\nscmd->scsi_done(scmd);\r\nreturn 0;\r\n}\r\nif (instance->issuepend_done == 0)\r\nreturn SCSI_MLQUEUE_HOST_BUSY;\r\nspin_lock_irqsave(&instance->hba_lock, flags);\r\nif (instance->adprecovery == MEGASAS_ADPRESET_SM_INFAULT) {\r\nif (megasas_check_mpio_paths(instance, scmd) ==\r\n(DID_RESET << 16)) {\r\nspin_unlock_irqrestore(&instance->hba_lock, flags);\r\nreturn SCSI_MLQUEUE_HOST_BUSY;\r\n} else {\r\nspin_unlock_irqrestore(&instance->hba_lock, flags);\r\nscmd->result = DID_NO_CONNECT << 16;\r\nscmd->scsi_done(scmd);\r\nreturn 0;\r\n}\r\n}\r\nif (instance->adprecovery == MEGASAS_HW_CRITICAL_ERROR) {\r\nspin_unlock_irqrestore(&instance->hba_lock, flags);\r\nscmd->result = DID_NO_CONNECT << 16;\r\nscmd->scsi_done(scmd);\r\nreturn 0;\r\n}\r\nif (instance->adprecovery != MEGASAS_HBA_OPERATIONAL) {\r\nspin_unlock_irqrestore(&instance->hba_lock, flags);\r\nreturn SCSI_MLQUEUE_HOST_BUSY;\r\n}\r\nspin_unlock_irqrestore(&instance->hba_lock, flags);\r\nscmd->result = 0;\r\nif (MEGASAS_IS_LOGICAL(scmd) &&\r\n(scmd->device->id >= instance->fw_supported_vd_count ||\r\nscmd->device->lun)) {\r\nscmd->result = DID_BAD_TARGET << 16;\r\ngoto out_done;\r\n}\r\nswitch (scmd->cmnd[0]) {\r\ncase SYNCHRONIZE_CACHE:\r\nscmd->result = DID_OK << 16;\r\ngoto out_done;\r\ndefault:\r\nbreak;\r\n}\r\nif (instance->instancet->build_and_issue_cmd(instance, scmd)) {\r\nprintk(KERN_ERR "megasas: Err returned from build_and_issue_cmd\n");\r\nreturn SCSI_MLQUEUE_HOST_BUSY;\r\n}\r\nreturn 0;\r\nout_done:\r\nscmd->scsi_done(scmd);\r\nreturn 0;\r\n}\r\nstatic struct megasas_instance *megasas_lookup_instance(u16 host_no)\r\n{\r\nint i;\r\nfor (i = 0; i < megasas_mgmt_info.max_index; i++) {\r\nif ((megasas_mgmt_info.instance[i]) &&\r\n(megasas_mgmt_info.instance[i]->host->host_no == host_no))\r\nreturn megasas_mgmt_info.instance[i];\r\n}\r\nreturn NULL;\r\n}\r\nstatic int megasas_slave_configure(struct scsi_device *sdev)\r\n{\r\nblk_queue_rq_timeout(sdev->request_queue,\r\nMEGASAS_DEFAULT_CMD_TIMEOUT * HZ);\r\nreturn 0;\r\n}\r\nstatic int megasas_slave_alloc(struct scsi_device *sdev)\r\n{\r\nu16 pd_index = 0;\r\nstruct megasas_instance *instance ;\r\ninstance = megasas_lookup_instance(sdev->host->host_no);\r\nif (sdev->channel < MEGASAS_MAX_PD_CHANNELS) {\r\npd_index =\r\n(sdev->channel * MEGASAS_MAX_DEV_PER_CHANNEL) +\r\nsdev->id;\r\nif (instance->pd_list[pd_index].driveState ==\r\nMR_PD_STATE_SYSTEM) {\r\nreturn 0;\r\n}\r\nreturn -ENXIO;\r\n}\r\nreturn 0;\r\n}\r\nvoid megasas_complete_outstanding_ioctls(struct megasas_instance *instance)\r\n{\r\nint i;\r\nstruct megasas_cmd *cmd_mfi;\r\nstruct megasas_cmd_fusion *cmd_fusion;\r\nstruct fusion_context *fusion = instance->ctrl_context;\r\nif (fusion) {\r\nfor (i = 0; i < instance->max_fw_cmds; i++) {\r\ncmd_fusion = fusion->cmd_list[i];\r\nif (cmd_fusion->sync_cmd_idx != (u32)ULONG_MAX) {\r\ncmd_mfi = instance->cmd_list[cmd_fusion->sync_cmd_idx];\r\nif (cmd_mfi->sync_cmd &&\r\ncmd_mfi->frame->hdr.cmd != MFI_CMD_ABORT)\r\nmegasas_complete_cmd(instance,\r\ncmd_mfi, DID_OK);\r\n}\r\n}\r\n} else {\r\nfor (i = 0; i < instance->max_fw_cmds; i++) {\r\ncmd_mfi = instance->cmd_list[i];\r\nif (cmd_mfi->sync_cmd && cmd_mfi->frame->hdr.cmd !=\r\nMFI_CMD_ABORT)\r\nmegasas_complete_cmd(instance, cmd_mfi, DID_OK);\r\n}\r\n}\r\n}\r\nvoid megaraid_sas_kill_hba(struct megasas_instance *instance)\r\n{\r\ninstance->adprecovery = MEGASAS_HW_CRITICAL_ERROR;\r\nmsleep(1000);\r\nif ((instance->pdev->device == PCI_DEVICE_ID_LSI_SAS0073SKINNY) ||\r\n(instance->pdev->device == PCI_DEVICE_ID_LSI_SAS0071SKINNY) ||\r\n(instance->pdev->device == PCI_DEVICE_ID_LSI_FUSION) ||\r\n(instance->pdev->device == PCI_DEVICE_ID_LSI_PLASMA) ||\r\n(instance->pdev->device == PCI_DEVICE_ID_LSI_INVADER) ||\r\n(instance->pdev->device == PCI_DEVICE_ID_LSI_FURY)) {\r\nwritel(MFI_STOP_ADP,\r\n&instance->reg_set->doorbell);\r\nreadl(&instance->reg_set->doorbell);\r\nif (instance->mpio && instance->requestorId)\r\nmemset(instance->ld_ids, 0xff, MEGASAS_MAX_LD_IDS);\r\n} else {\r\nwritel(MFI_STOP_ADP,\r\n&instance->reg_set->inbound_doorbell);\r\n}\r\nmegasas_complete_outstanding_ioctls(instance);\r\n}\r\nvoid\r\nmegasas_check_and_restore_queue_depth(struct megasas_instance *instance)\r\n{\r\nunsigned long flags;\r\nif (instance->flag & MEGASAS_FW_BUSY\r\n&& time_after(jiffies, instance->last_time + 5 * HZ)\r\n&& atomic_read(&instance->fw_outstanding) <\r\ninstance->throttlequeuedepth + 1) {\r\nspin_lock_irqsave(instance->host->host_lock, flags);\r\ninstance->flag &= ~MEGASAS_FW_BUSY;\r\ninstance->host->can_queue = instance->max_scsi_cmds;\r\nspin_unlock_irqrestore(instance->host->host_lock, flags);\r\n}\r\n}\r\nstatic void megasas_complete_cmd_dpc(unsigned long instance_addr)\r\n{\r\nu32 producer;\r\nu32 consumer;\r\nu32 context;\r\nstruct megasas_cmd *cmd;\r\nstruct megasas_instance *instance =\r\n(struct megasas_instance *)instance_addr;\r\nunsigned long flags;\r\nif (instance->adprecovery == MEGASAS_HW_CRITICAL_ERROR )\r\nreturn;\r\nspin_lock_irqsave(&instance->completion_lock, flags);\r\nproducer = le32_to_cpu(*instance->producer);\r\nconsumer = le32_to_cpu(*instance->consumer);\r\nwhile (consumer != producer) {\r\ncontext = le32_to_cpu(instance->reply_queue[consumer]);\r\nif (context >= instance->max_fw_cmds) {\r\nprintk(KERN_ERR "Unexpected context value %x\n",\r\ncontext);\r\nBUG();\r\n}\r\ncmd = instance->cmd_list[context];\r\nmegasas_complete_cmd(instance, cmd, DID_OK);\r\nconsumer++;\r\nif (consumer == (instance->max_fw_cmds + 1)) {\r\nconsumer = 0;\r\n}\r\n}\r\n*instance->consumer = cpu_to_le32(producer);\r\nspin_unlock_irqrestore(&instance->completion_lock, flags);\r\nmegasas_check_and_restore_queue_depth(instance);\r\n}\r\nvoid megasas_start_timer(struct megasas_instance *instance,\r\nstruct timer_list *timer,\r\nvoid *fn, unsigned long interval)\r\n{\r\ninit_timer(timer);\r\ntimer->expires = jiffies + interval;\r\ntimer->data = (unsigned long)instance;\r\ntimer->function = fn;\r\nadd_timer(timer);\r\n}\r\nvoid megasas_do_ocr(struct megasas_instance *instance)\r\n{\r\nif ((instance->pdev->device == PCI_DEVICE_ID_LSI_SAS1064R) ||\r\n(instance->pdev->device == PCI_DEVICE_ID_DELL_PERC5) ||\r\n(instance->pdev->device == PCI_DEVICE_ID_LSI_VERDE_ZCR)) {\r\n*instance->consumer = cpu_to_le32(MEGASAS_ADPRESET_INPROG_SIGN);\r\n}\r\ninstance->instancet->disable_intr(instance);\r\ninstance->adprecovery = MEGASAS_ADPRESET_SM_INFAULT;\r\ninstance->issuepend_done = 0;\r\natomic_set(&instance->fw_outstanding, 0);\r\nmegasas_internal_reset_defer_cmds(instance);\r\nprocess_fw_state_change_wq(&instance->work_init);\r\n}\r\nstatic int megasas_get_ld_vf_affiliation_111(struct megasas_instance *instance,\r\nint initial)\r\n{\r\nstruct megasas_cmd *cmd;\r\nstruct megasas_dcmd_frame *dcmd;\r\nstruct MR_LD_VF_AFFILIATION_111 *new_affiliation_111 = NULL;\r\ndma_addr_t new_affiliation_111_h;\r\nint ld, retval = 0;\r\nu8 thisVf;\r\ncmd = megasas_get_cmd(instance);\r\nif (!cmd) {\r\nprintk(KERN_DEBUG "megasas: megasas_get_ld_vf_affiliation_111:"\r\n"Failed to get cmd for scsi%d.\n",\r\ninstance->host->host_no);\r\nreturn -ENOMEM;\r\n}\r\ndcmd = &cmd->frame->dcmd;\r\nif (!instance->vf_affiliation_111) {\r\nprintk(KERN_WARNING "megasas: SR-IOV: Couldn't get LD/VF "\r\n"affiliation for scsi%d.\n", instance->host->host_no);\r\nmegasas_return_cmd(instance, cmd);\r\nreturn -ENOMEM;\r\n}\r\nif (initial)\r\nmemset(instance->vf_affiliation_111, 0,\r\nsizeof(struct MR_LD_VF_AFFILIATION_111));\r\nelse {\r\nnew_affiliation_111 =\r\npci_alloc_consistent(instance->pdev,\r\nsizeof(struct MR_LD_VF_AFFILIATION_111),\r\n&new_affiliation_111_h);\r\nif (!new_affiliation_111) {\r\nprintk(KERN_DEBUG "megasas: SR-IOV: Couldn't allocate "\r\n"memory for new affiliation for scsi%d.\n",\r\ninstance->host->host_no);\r\nmegasas_return_cmd(instance, cmd);\r\nreturn -ENOMEM;\r\n}\r\nmemset(new_affiliation_111, 0,\r\nsizeof(struct MR_LD_VF_AFFILIATION_111));\r\n}\r\nmemset(dcmd->mbox.b, 0, MFI_MBOX_SIZE);\r\ndcmd->cmd = MFI_CMD_DCMD;\r\ndcmd->cmd_status = 0xFF;\r\ndcmd->sge_count = 1;\r\ndcmd->flags = MFI_FRAME_DIR_BOTH;\r\ndcmd->timeout = 0;\r\ndcmd->pad_0 = 0;\r\ndcmd->data_xfer_len = sizeof(struct MR_LD_VF_AFFILIATION_111);\r\ndcmd->opcode = MR_DCMD_LD_VF_MAP_GET_ALL_LDS_111;\r\nif (initial)\r\ndcmd->sgl.sge32[0].phys_addr =\r\ninstance->vf_affiliation_111_h;\r\nelse\r\ndcmd->sgl.sge32[0].phys_addr = new_affiliation_111_h;\r\ndcmd->sgl.sge32[0].length =\r\nsizeof(struct MR_LD_VF_AFFILIATION_111);\r\nprintk(KERN_WARNING "megasas: SR-IOV: Getting LD/VF affiliation for "\r\n"scsi%d\n", instance->host->host_no);\r\nmegasas_issue_blocked_cmd(instance, cmd, 0);\r\nif (dcmd->cmd_status) {\r\nprintk(KERN_WARNING "megasas: SR-IOV: LD/VF affiliation DCMD"\r\n" failed with status 0x%x for scsi%d.\n",\r\ndcmd->cmd_status, instance->host->host_no);\r\nretval = 1;\r\ngoto out;\r\n}\r\nif (!initial) {\r\nthisVf = new_affiliation_111->thisVf;\r\nfor (ld = 0 ; ld < new_affiliation_111->vdCount; ld++)\r\nif (instance->vf_affiliation_111->map[ld].policy[thisVf] !=\r\nnew_affiliation_111->map[ld].policy[thisVf]) {\r\nprintk(KERN_WARNING "megasas: SR-IOV: "\r\n"Got new LD/VF affiliation "\r\n"for scsi%d.\n",\r\ninstance->host->host_no);\r\nmemcpy(instance->vf_affiliation_111,\r\nnew_affiliation_111,\r\nsizeof(struct MR_LD_VF_AFFILIATION_111));\r\nretval = 1;\r\ngoto out;\r\n}\r\n}\r\nout:\r\nif (new_affiliation_111) {\r\npci_free_consistent(instance->pdev,\r\nsizeof(struct MR_LD_VF_AFFILIATION_111),\r\nnew_affiliation_111,\r\nnew_affiliation_111_h);\r\n}\r\nif (instance->ctrl_context && cmd->mpt_pthr_cmd_blocked)\r\nmegasas_return_mfi_mpt_pthr(instance, cmd,\r\ncmd->mpt_pthr_cmd_blocked);\r\nelse\r\nmegasas_return_cmd(instance, cmd);\r\nreturn retval;\r\n}\r\nstatic int megasas_get_ld_vf_affiliation_12(struct megasas_instance *instance,\r\nint initial)\r\n{\r\nstruct megasas_cmd *cmd;\r\nstruct megasas_dcmd_frame *dcmd;\r\nstruct MR_LD_VF_AFFILIATION *new_affiliation = NULL;\r\nstruct MR_LD_VF_MAP *newmap = NULL, *savedmap = NULL;\r\ndma_addr_t new_affiliation_h;\r\nint i, j, retval = 0, found = 0, doscan = 0;\r\nu8 thisVf;\r\ncmd = megasas_get_cmd(instance);\r\nif (!cmd) {\r\nprintk(KERN_DEBUG "megasas: megasas_get_ld_vf_affiliation12: "\r\n"Failed to get cmd for scsi%d.\n",\r\ninstance->host->host_no);\r\nreturn -ENOMEM;\r\n}\r\ndcmd = &cmd->frame->dcmd;\r\nif (!instance->vf_affiliation) {\r\nprintk(KERN_WARNING "megasas: SR-IOV: Couldn't get LD/VF "\r\n"affiliation for scsi%d.\n", instance->host->host_no);\r\nmegasas_return_cmd(instance, cmd);\r\nreturn -ENOMEM;\r\n}\r\nif (initial)\r\nmemset(instance->vf_affiliation, 0, (MAX_LOGICAL_DRIVES + 1) *\r\nsizeof(struct MR_LD_VF_AFFILIATION));\r\nelse {\r\nnew_affiliation =\r\npci_alloc_consistent(instance->pdev,\r\n(MAX_LOGICAL_DRIVES + 1) *\r\nsizeof(struct MR_LD_VF_AFFILIATION),\r\n&new_affiliation_h);\r\nif (!new_affiliation) {\r\nprintk(KERN_DEBUG "megasas: SR-IOV: Couldn't allocate "\r\n"memory for new affiliation for scsi%d.\n",\r\ninstance->host->host_no);\r\nmegasas_return_cmd(instance, cmd);\r\nreturn -ENOMEM;\r\n}\r\nmemset(new_affiliation, 0, (MAX_LOGICAL_DRIVES + 1) *\r\nsizeof(struct MR_LD_VF_AFFILIATION));\r\n}\r\nmemset(dcmd->mbox.b, 0, MFI_MBOX_SIZE);\r\ndcmd->cmd = MFI_CMD_DCMD;\r\ndcmd->cmd_status = 0xFF;\r\ndcmd->sge_count = 1;\r\ndcmd->flags = MFI_FRAME_DIR_BOTH;\r\ndcmd->timeout = 0;\r\ndcmd->pad_0 = 0;\r\ndcmd->data_xfer_len = (MAX_LOGICAL_DRIVES + 1) *\r\nsizeof(struct MR_LD_VF_AFFILIATION);\r\ndcmd->opcode = MR_DCMD_LD_VF_MAP_GET_ALL_LDS;\r\nif (initial)\r\ndcmd->sgl.sge32[0].phys_addr = instance->vf_affiliation_h;\r\nelse\r\ndcmd->sgl.sge32[0].phys_addr = new_affiliation_h;\r\ndcmd->sgl.sge32[0].length = (MAX_LOGICAL_DRIVES + 1) *\r\nsizeof(struct MR_LD_VF_AFFILIATION);\r\nprintk(KERN_WARNING "megasas: SR-IOV: Getting LD/VF affiliation for "\r\n"scsi%d\n", instance->host->host_no);\r\nmegasas_issue_blocked_cmd(instance, cmd, 0);\r\nif (dcmd->cmd_status) {\r\nprintk(KERN_WARNING "megasas: SR-IOV: LD/VF affiliation DCMD"\r\n" failed with status 0x%x for scsi%d.\n",\r\ndcmd->cmd_status, instance->host->host_no);\r\nretval = 1;\r\ngoto out;\r\n}\r\nif (!initial) {\r\nif (!new_affiliation->ldCount) {\r\nprintk(KERN_WARNING "megasas: SR-IOV: Got new LD/VF "\r\n"affiliation for passive path for scsi%d.\n",\r\ninstance->host->host_no);\r\nretval = 1;\r\ngoto out;\r\n}\r\nnewmap = new_affiliation->map;\r\nsavedmap = instance->vf_affiliation->map;\r\nthisVf = new_affiliation->thisVf;\r\nfor (i = 0 ; i < new_affiliation->ldCount; i++) {\r\nfound = 0;\r\nfor (j = 0; j < instance->vf_affiliation->ldCount;\r\nj++) {\r\nif (newmap->ref.targetId ==\r\nsavedmap->ref.targetId) {\r\nfound = 1;\r\nif (newmap->policy[thisVf] !=\r\nsavedmap->policy[thisVf]) {\r\ndoscan = 1;\r\ngoto out;\r\n}\r\n}\r\nsavedmap = (struct MR_LD_VF_MAP *)\r\n((unsigned char *)savedmap +\r\nsavedmap->size);\r\n}\r\nif (!found && newmap->policy[thisVf] !=\r\nMR_LD_ACCESS_HIDDEN) {\r\ndoscan = 1;\r\ngoto out;\r\n}\r\nnewmap = (struct MR_LD_VF_MAP *)\r\n((unsigned char *)newmap + newmap->size);\r\n}\r\nnewmap = new_affiliation->map;\r\nsavedmap = instance->vf_affiliation->map;\r\nfor (i = 0 ; i < instance->vf_affiliation->ldCount; i++) {\r\nfound = 0;\r\nfor (j = 0 ; j < new_affiliation->ldCount; j++) {\r\nif (savedmap->ref.targetId ==\r\nnewmap->ref.targetId) {\r\nfound = 1;\r\nif (savedmap->policy[thisVf] !=\r\nnewmap->policy[thisVf]) {\r\ndoscan = 1;\r\ngoto out;\r\n}\r\n}\r\nnewmap = (struct MR_LD_VF_MAP *)\r\n((unsigned char *)newmap +\r\nnewmap->size);\r\n}\r\nif (!found && savedmap->policy[thisVf] !=\r\nMR_LD_ACCESS_HIDDEN) {\r\ndoscan = 1;\r\ngoto out;\r\n}\r\nsavedmap = (struct MR_LD_VF_MAP *)\r\n((unsigned char *)savedmap +\r\nsavedmap->size);\r\n}\r\n}\r\nout:\r\nif (doscan) {\r\nprintk(KERN_WARNING "megasas: SR-IOV: Got new LD/VF "\r\n"affiliation for scsi%d.\n", instance->host->host_no);\r\nmemcpy(instance->vf_affiliation, new_affiliation,\r\nnew_affiliation->size);\r\nretval = 1;\r\n}\r\nif (new_affiliation)\r\npci_free_consistent(instance->pdev,\r\n(MAX_LOGICAL_DRIVES + 1) *\r\nsizeof(struct MR_LD_VF_AFFILIATION),\r\nnew_affiliation, new_affiliation_h);\r\nif (instance->ctrl_context && cmd->mpt_pthr_cmd_blocked)\r\nmegasas_return_mfi_mpt_pthr(instance, cmd,\r\ncmd->mpt_pthr_cmd_blocked);\r\nelse\r\nmegasas_return_cmd(instance, cmd);\r\nreturn retval;\r\n}\r\nstatic int megasas_get_ld_vf_affiliation(struct megasas_instance *instance,\r\nint initial)\r\n{\r\nint retval;\r\nif (instance->PlasmaFW111)\r\nretval = megasas_get_ld_vf_affiliation_111(instance, initial);\r\nelse\r\nretval = megasas_get_ld_vf_affiliation_12(instance, initial);\r\nreturn retval;\r\n}\r\nint megasas_sriov_start_heartbeat(struct megasas_instance *instance,\r\nint initial)\r\n{\r\nstruct megasas_cmd *cmd;\r\nstruct megasas_dcmd_frame *dcmd;\r\nint retval = 0;\r\ncmd = megasas_get_cmd(instance);\r\nif (!cmd) {\r\nprintk(KERN_DEBUG "megasas: megasas_sriov_start_heartbeat: "\r\n"Failed to get cmd for scsi%d.\n",\r\ninstance->host->host_no);\r\nreturn -ENOMEM;\r\n}\r\ndcmd = &cmd->frame->dcmd;\r\nif (initial) {\r\ninstance->hb_host_mem =\r\npci_zalloc_consistent(instance->pdev,\r\nsizeof(struct MR_CTRL_HB_HOST_MEM),\r\n&instance->hb_host_mem_h);\r\nif (!instance->hb_host_mem) {\r\nprintk(KERN_DEBUG "megasas: SR-IOV: Couldn't allocate"\r\n" memory for heartbeat host memory for "\r\n"scsi%d.\n", instance->host->host_no);\r\nretval = -ENOMEM;\r\ngoto out;\r\n}\r\n}\r\nmemset(dcmd->mbox.b, 0, MFI_MBOX_SIZE);\r\ndcmd->mbox.s[0] = sizeof(struct MR_CTRL_HB_HOST_MEM);\r\ndcmd->cmd = MFI_CMD_DCMD;\r\ndcmd->cmd_status = 0xFF;\r\ndcmd->sge_count = 1;\r\ndcmd->flags = MFI_FRAME_DIR_BOTH;\r\ndcmd->timeout = 0;\r\ndcmd->pad_0 = 0;\r\ndcmd->data_xfer_len = sizeof(struct MR_CTRL_HB_HOST_MEM);\r\ndcmd->opcode = MR_DCMD_CTRL_SHARED_HOST_MEM_ALLOC;\r\ndcmd->sgl.sge32[0].phys_addr = instance->hb_host_mem_h;\r\ndcmd->sgl.sge32[0].length = sizeof(struct MR_CTRL_HB_HOST_MEM);\r\nprintk(KERN_WARNING "megasas: SR-IOV: Starting heartbeat for scsi%d\n",\r\ninstance->host->host_no);\r\nif (!megasas_issue_polled(instance, cmd)) {\r\nretval = 0;\r\n} else {\r\nprintk(KERN_WARNING "megasas: SR-IOV: MR_DCMD_CTRL_SHARED_HOST"\r\n"_MEM_ALLOC DCMD timed out for scsi%d\n",\r\ninstance->host->host_no);\r\nretval = 1;\r\ngoto out;\r\n}\r\nif (dcmd->cmd_status) {\r\nprintk(KERN_WARNING "megasas: SR-IOV: MR_DCMD_CTRL_SHARED_HOST"\r\n"_MEM_ALLOC DCMD failed with status 0x%x for scsi%d\n",\r\ndcmd->cmd_status,\r\ninstance->host->host_no);\r\nretval = 1;\r\ngoto out;\r\n}\r\nout:\r\nmegasas_return_cmd(instance, cmd);\r\nreturn retval;\r\n}\r\nvoid megasas_sriov_heartbeat_handler(unsigned long instance_addr)\r\n{\r\nstruct megasas_instance *instance =\r\n(struct megasas_instance *)instance_addr;\r\nif (instance->hb_host_mem->HB.fwCounter !=\r\ninstance->hb_host_mem->HB.driverCounter) {\r\ninstance->hb_host_mem->HB.driverCounter =\r\ninstance->hb_host_mem->HB.fwCounter;\r\nmod_timer(&instance->sriov_heartbeat_timer,\r\njiffies + MEGASAS_SRIOV_HEARTBEAT_INTERVAL_VF);\r\n} else {\r\nprintk(KERN_WARNING "megasas: SR-IOV: Heartbeat never "\r\n"completed for scsi%d\n", instance->host->host_no);\r\nschedule_work(&instance->work_init);\r\n}\r\n}\r\nstatic int megasas_wait_for_outstanding(struct megasas_instance *instance)\r\n{\r\nint i;\r\nu32 reset_index;\r\nu32 wait_time = MEGASAS_RESET_WAIT_TIME;\r\nu8 adprecovery;\r\nunsigned long flags;\r\nstruct list_head clist_local;\r\nstruct megasas_cmd *reset_cmd;\r\nu32 fw_state;\r\nu8 kill_adapter_flag;\r\nspin_lock_irqsave(&instance->hba_lock, flags);\r\nadprecovery = instance->adprecovery;\r\nspin_unlock_irqrestore(&instance->hba_lock, flags);\r\nif (adprecovery != MEGASAS_HBA_OPERATIONAL) {\r\nINIT_LIST_HEAD(&clist_local);\r\nspin_lock_irqsave(&instance->hba_lock, flags);\r\nlist_splice_init(&instance->internal_reset_pending_q,\r\n&clist_local);\r\nspin_unlock_irqrestore(&instance->hba_lock, flags);\r\nprintk(KERN_NOTICE "megasas: HBA reset wait ...\n");\r\nfor (i = 0; i < wait_time; i++) {\r\nmsleep(1000);\r\nspin_lock_irqsave(&instance->hba_lock, flags);\r\nadprecovery = instance->adprecovery;\r\nspin_unlock_irqrestore(&instance->hba_lock, flags);\r\nif (adprecovery == MEGASAS_HBA_OPERATIONAL)\r\nbreak;\r\n}\r\nif (adprecovery != MEGASAS_HBA_OPERATIONAL) {\r\nprintk(KERN_NOTICE "megasas: reset: Stopping HBA.\n");\r\nspin_lock_irqsave(&instance->hba_lock, flags);\r\ninstance->adprecovery = MEGASAS_HW_CRITICAL_ERROR;\r\nspin_unlock_irqrestore(&instance->hba_lock, flags);\r\nreturn FAILED;\r\n}\r\nreset_index = 0;\r\nwhile (!list_empty(&clist_local)) {\r\nreset_cmd = list_entry((&clist_local)->next,\r\nstruct megasas_cmd, list);\r\nlist_del_init(&reset_cmd->list);\r\nif (reset_cmd->scmd) {\r\nreset_cmd->scmd->result = DID_RESET << 16;\r\nprintk(KERN_NOTICE "%d:%p reset [%02x]\n",\r\nreset_index, reset_cmd,\r\nreset_cmd->scmd->cmnd[0]);\r\nreset_cmd->scmd->scsi_done(reset_cmd->scmd);\r\nmegasas_return_cmd(instance, reset_cmd);\r\n} else if (reset_cmd->sync_cmd) {\r\nprintk(KERN_NOTICE "megasas:%p synch cmds"\r\n"reset queue\n",\r\nreset_cmd);\r\nreset_cmd->cmd_status = ENODATA;\r\ninstance->instancet->fire_cmd(instance,\r\nreset_cmd->frame_phys_addr,\r\n0, instance->reg_set);\r\n} else {\r\nprintk(KERN_NOTICE "megasas: %p unexpected"\r\n"cmds lst\n",\r\nreset_cmd);\r\n}\r\nreset_index++;\r\n}\r\nreturn SUCCESS;\r\n}\r\nfor (i = 0; i < resetwaittime; i++) {\r\nint outstanding = atomic_read(&instance->fw_outstanding);\r\nif (!outstanding)\r\nbreak;\r\nif (!(i % MEGASAS_RESET_NOTICE_INTERVAL)) {\r\nprintk(KERN_NOTICE "megasas: [%2d]waiting for %d "\r\n"commands to complete\n",i,outstanding);\r\nmegasas_complete_cmd_dpc((unsigned long)instance);\r\n}\r\nmsleep(1000);\r\n}\r\ni = 0;\r\nkill_adapter_flag = 0;\r\ndo {\r\nfw_state = instance->instancet->read_fw_status_reg(\r\ninstance->reg_set) & MFI_STATE_MASK;\r\nif ((fw_state == MFI_STATE_FAULT) &&\r\n(instance->disableOnlineCtrlReset == 0)) {\r\nif (i == 3) {\r\nkill_adapter_flag = 2;\r\nbreak;\r\n}\r\nmegasas_do_ocr(instance);\r\nkill_adapter_flag = 1;\r\nmsleep(1000);\r\n}\r\ni++;\r\n} while (i <= 3);\r\nif (atomic_read(&instance->fw_outstanding) &&\r\n!kill_adapter_flag) {\r\nif (instance->disableOnlineCtrlReset == 0) {\r\nmegasas_do_ocr(instance);\r\nfor (i = 0; i < wait_time; i++) {\r\nint outstanding =\r\natomic_read(&instance->fw_outstanding);\r\nif (!outstanding)\r\nreturn SUCCESS;\r\nmsleep(1000);\r\n}\r\n}\r\n}\r\nif (atomic_read(&instance->fw_outstanding) ||\r\n(kill_adapter_flag == 2)) {\r\nprintk(KERN_NOTICE "megaraid_sas: pending cmds after reset\n");\r\nif ((instance->pdev->device ==\r\nPCI_DEVICE_ID_LSI_SAS0073SKINNY) ||\r\n(instance->pdev->device ==\r\nPCI_DEVICE_ID_LSI_SAS0071SKINNY)) {\r\nwritel(MFI_STOP_ADP,\r\n&instance->reg_set->doorbell);\r\n} else {\r\nwritel(MFI_STOP_ADP,\r\n&instance->reg_set->inbound_doorbell);\r\n}\r\nmegasas_dump_pending_frames(instance);\r\nspin_lock_irqsave(&instance->hba_lock, flags);\r\ninstance->adprecovery = MEGASAS_HW_CRITICAL_ERROR;\r\nspin_unlock_irqrestore(&instance->hba_lock, flags);\r\nreturn FAILED;\r\n}\r\nprintk(KERN_NOTICE "megaraid_sas: no pending cmds after reset\n");\r\nreturn SUCCESS;\r\n}\r\nstatic int megasas_generic_reset(struct scsi_cmnd *scmd)\r\n{\r\nint ret_val;\r\nstruct megasas_instance *instance;\r\ninstance = (struct megasas_instance *)scmd->device->host->hostdata;\r\nscmd_printk(KERN_NOTICE, scmd, "megasas: RESET cmd=%x retries=%x\n",\r\nscmd->cmnd[0], scmd->retries);\r\nif (instance->adprecovery == MEGASAS_HW_CRITICAL_ERROR) {\r\nprintk(KERN_ERR "megasas: cannot recover from previous reset "\r\n"failures\n");\r\nreturn FAILED;\r\n}\r\nret_val = megasas_wait_for_outstanding(instance);\r\nif (ret_val == SUCCESS)\r\nprintk(KERN_NOTICE "megasas: reset successful \n");\r\nelse\r\nprintk(KERN_ERR "megasas: failed to do reset\n");\r\nreturn ret_val;\r\n}\r\nstatic enum\r\nblk_eh_timer_return megasas_reset_timer(struct scsi_cmnd *scmd)\r\n{\r\nstruct megasas_instance *instance;\r\nunsigned long flags;\r\nif (time_after(jiffies, scmd->jiffies_at_alloc +\r\n(MEGASAS_DEFAULT_CMD_TIMEOUT * 2) * HZ)) {\r\nreturn BLK_EH_NOT_HANDLED;\r\n}\r\ninstance = (struct megasas_instance *)scmd->device->host->hostdata;\r\nif (!(instance->flag & MEGASAS_FW_BUSY)) {\r\nspin_lock_irqsave(instance->host->host_lock, flags);\r\ninstance->host->can_queue = instance->throttlequeuedepth;\r\ninstance->last_time = jiffies;\r\ninstance->flag |= MEGASAS_FW_BUSY;\r\nspin_unlock_irqrestore(instance->host->host_lock, flags);\r\n}\r\nreturn BLK_EH_RESET_TIMER;\r\n}\r\nstatic int megasas_reset_device(struct scsi_cmnd *scmd)\r\n{\r\nint ret;\r\nret = megasas_generic_reset(scmd);\r\nreturn ret;\r\n}\r\nstatic int megasas_reset_bus_host(struct scsi_cmnd *scmd)\r\n{\r\nint ret;\r\nstruct megasas_instance *instance;\r\ninstance = (struct megasas_instance *)scmd->device->host->hostdata;\r\nif ((instance->pdev->device == PCI_DEVICE_ID_LSI_FUSION) ||\r\n(instance->pdev->device == PCI_DEVICE_ID_LSI_PLASMA) ||\r\n(instance->pdev->device == PCI_DEVICE_ID_LSI_INVADER) ||\r\n(instance->pdev->device == PCI_DEVICE_ID_LSI_FURY))\r\nret = megasas_reset_fusion(scmd->device->host, 1);\r\nelse\r\nret = megasas_generic_reset(scmd);\r\nreturn ret;\r\n}\r\nstatic int\r\nmegasas_bios_param(struct scsi_device *sdev, struct block_device *bdev,\r\nsector_t capacity, int geom[])\r\n{\r\nint heads;\r\nint sectors;\r\nsector_t cylinders;\r\nunsigned long tmp;\r\nheads = 64;\r\nsectors = 32;\r\ntmp = heads * sectors;\r\ncylinders = capacity;\r\nsector_div(cylinders, tmp);\r\nif (capacity >= 0x200000) {\r\nheads = 255;\r\nsectors = 63;\r\ntmp = heads*sectors;\r\ncylinders = capacity;\r\nsector_div(cylinders, tmp);\r\n}\r\ngeom[0] = heads;\r\ngeom[1] = sectors;\r\ngeom[2] = cylinders;\r\nreturn 0;\r\n}\r\nstatic void\r\nmegasas_service_aen(struct megasas_instance *instance, struct megasas_cmd *cmd)\r\n{\r\nunsigned long flags;\r\nif ((!cmd->abort_aen) && (instance->unload == 0)) {\r\nspin_lock_irqsave(&poll_aen_lock, flags);\r\nmegasas_poll_wait_aen = 1;\r\nspin_unlock_irqrestore(&poll_aen_lock, flags);\r\nwake_up(&megasas_poll_wait);\r\nkill_fasync(&megasas_async_queue, SIGIO, POLL_IN);\r\n}\r\nelse\r\ncmd->abort_aen = 0;\r\ninstance->aen_cmd = NULL;\r\nif (instance->ctrl_context && cmd->mpt_pthr_cmd_blocked)\r\nmegasas_return_mfi_mpt_pthr(instance, cmd,\r\ncmd->mpt_pthr_cmd_blocked);\r\nelse\r\nmegasas_return_cmd(instance, cmd);\r\nif ((instance->unload == 0) &&\r\n((instance->issuepend_done == 1))) {\r\nstruct megasas_aen_event *ev;\r\nev = kzalloc(sizeof(*ev), GFP_ATOMIC);\r\nif (!ev) {\r\nprintk(KERN_ERR "megasas_service_aen: out of memory\n");\r\n} else {\r\nev->instance = instance;\r\ninstance->ev = ev;\r\nINIT_DELAYED_WORK(&ev->hotplug_work,\r\nmegasas_aen_polling);\r\nschedule_delayed_work(&ev->hotplug_work, 0);\r\n}\r\n}\r\n}\r\nstatic ssize_t\r\nmegasas_fw_crash_buffer_store(struct device *cdev,\r\nstruct device_attribute *attr, const char *buf, size_t count)\r\n{\r\nstruct Scsi_Host *shost = class_to_shost(cdev);\r\nstruct megasas_instance *instance =\r\n(struct megasas_instance *) shost->hostdata;\r\nint val = 0;\r\nunsigned long flags;\r\nif (kstrtoint(buf, 0, &val) != 0)\r\nreturn -EINVAL;\r\nspin_lock_irqsave(&instance->crashdump_lock, flags);\r\ninstance->fw_crash_buffer_offset = val;\r\nspin_unlock_irqrestore(&instance->crashdump_lock, flags);\r\nreturn strlen(buf);\r\n}\r\nstatic ssize_t\r\nmegasas_fw_crash_buffer_show(struct device *cdev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct Scsi_Host *shost = class_to_shost(cdev);\r\nstruct megasas_instance *instance =\r\n(struct megasas_instance *) shost->hostdata;\r\nu32 size;\r\nunsigned long buff_addr;\r\nunsigned long dmachunk = CRASH_DMA_BUF_SIZE;\r\nunsigned long src_addr;\r\nunsigned long flags;\r\nu32 buff_offset;\r\nspin_lock_irqsave(&instance->crashdump_lock, flags);\r\nbuff_offset = instance->fw_crash_buffer_offset;\r\nif (!instance->crash_dump_buf &&\r\n!((instance->fw_crash_state == AVAILABLE) ||\r\n(instance->fw_crash_state == COPYING))) {\r\ndev_err(&instance->pdev->dev,\r\n"Firmware crash dump is not available\n");\r\nspin_unlock_irqrestore(&instance->crashdump_lock, flags);\r\nreturn -EINVAL;\r\n}\r\nbuff_addr = (unsigned long) buf;\r\nif (buff_offset >\r\n(instance->fw_crash_buffer_size * dmachunk)) {\r\ndev_err(&instance->pdev->dev,\r\n"Firmware crash dump offset is out of range\n");\r\nspin_unlock_irqrestore(&instance->crashdump_lock, flags);\r\nreturn 0;\r\n}\r\nsize = (instance->fw_crash_buffer_size * dmachunk) - buff_offset;\r\nsize = (size >= PAGE_SIZE) ? (PAGE_SIZE - 1) : size;\r\nsrc_addr = (unsigned long)instance->crash_buf[buff_offset / dmachunk] +\r\n(buff_offset % dmachunk);\r\nmemcpy(buf, (void *)src_addr, size);\r\nspin_unlock_irqrestore(&instance->crashdump_lock, flags);\r\nreturn size;\r\n}\r\nstatic ssize_t\r\nmegasas_fw_crash_buffer_size_show(struct device *cdev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct Scsi_Host *shost = class_to_shost(cdev);\r\nstruct megasas_instance *instance =\r\n(struct megasas_instance *) shost->hostdata;\r\nreturn snprintf(buf, PAGE_SIZE, "%ld\n", (unsigned long)\r\n((instance->fw_crash_buffer_size) * 1024 * 1024)/PAGE_SIZE);\r\n}\r\nstatic ssize_t\r\nmegasas_fw_crash_state_store(struct device *cdev,\r\nstruct device_attribute *attr, const char *buf, size_t count)\r\n{\r\nstruct Scsi_Host *shost = class_to_shost(cdev);\r\nstruct megasas_instance *instance =\r\n(struct megasas_instance *) shost->hostdata;\r\nint val = 0;\r\nunsigned long flags;\r\nif (kstrtoint(buf, 0, &val) != 0)\r\nreturn -EINVAL;\r\nif ((val <= AVAILABLE || val > COPY_ERROR)) {\r\ndev_err(&instance->pdev->dev, "application updates invalid "\r\n"firmware crash state\n");\r\nreturn -EINVAL;\r\n}\r\ninstance->fw_crash_state = val;\r\nif ((val == COPIED) || (val == COPY_ERROR)) {\r\nspin_lock_irqsave(&instance->crashdump_lock, flags);\r\nmegasas_free_host_crash_buffer(instance);\r\nspin_unlock_irqrestore(&instance->crashdump_lock, flags);\r\nif (val == COPY_ERROR)\r\ndev_info(&instance->pdev->dev, "application failed to "\r\n"copy Firmware crash dump\n");\r\nelse\r\ndev_info(&instance->pdev->dev, "Firmware crash dump "\r\n"copied successfully\n");\r\n}\r\nreturn strlen(buf);\r\n}\r\nstatic ssize_t\r\nmegasas_fw_crash_state_show(struct device *cdev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct Scsi_Host *shost = class_to_shost(cdev);\r\nstruct megasas_instance *instance =\r\n(struct megasas_instance *) shost->hostdata;\r\nreturn snprintf(buf, PAGE_SIZE, "%d\n", instance->fw_crash_state);\r\n}\r\nstatic ssize_t\r\nmegasas_page_size_show(struct device *cdev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nreturn snprintf(buf, PAGE_SIZE, "%ld\n", (unsigned long)PAGE_SIZE - 1);\r\n}\r\nstatic void\r\nmegasas_complete_int_cmd(struct megasas_instance *instance,\r\nstruct megasas_cmd *cmd)\r\n{\r\ncmd->cmd_status = cmd->frame->io.cmd_status;\r\nif (cmd->cmd_status == ENODATA) {\r\ncmd->cmd_status = 0;\r\n}\r\nwake_up(&instance->int_cmd_wait_q);\r\n}\r\nstatic void\r\nmegasas_complete_abort(struct megasas_instance *instance,\r\nstruct megasas_cmd *cmd)\r\n{\r\nif (cmd->sync_cmd) {\r\ncmd->sync_cmd = 0;\r\ncmd->cmd_status = 0;\r\nwake_up(&instance->abort_cmd_wait_q);\r\n}\r\nreturn;\r\n}\r\nvoid\r\nmegasas_complete_cmd(struct megasas_instance *instance, struct megasas_cmd *cmd,\r\nu8 alt_status)\r\n{\r\nint exception = 0;\r\nstruct megasas_header *hdr = &cmd->frame->hdr;\r\nunsigned long flags;\r\nstruct fusion_context *fusion = instance->ctrl_context;\r\nu32 opcode;\r\ncmd->retry_for_fw_reset = 0;\r\nif (cmd->scmd)\r\ncmd->scmd->SCp.ptr = NULL;\r\nswitch (hdr->cmd) {\r\ncase MFI_CMD_INVALID:\r\nprintk(KERN_WARNING "megaraid_sas: MFI_CMD_INVALID command "\r\n"completed.\n");\r\nprintk(KERN_WARNING "megaraid_sas: If you have a controller "\r\n"other than PERC5, please upgrade your firmware.\n");\r\nbreak;\r\ncase MFI_CMD_PD_SCSI_IO:\r\ncase MFI_CMD_LD_SCSI_IO:\r\nif (cmd->sync_cmd) {\r\ncmd->sync_cmd = 0;\r\nmegasas_complete_int_cmd(instance, cmd);\r\nbreak;\r\n}\r\ncase MFI_CMD_LD_READ:\r\ncase MFI_CMD_LD_WRITE:\r\nif (alt_status) {\r\ncmd->scmd->result = alt_status << 16;\r\nexception = 1;\r\n}\r\nif (exception) {\r\natomic_dec(&instance->fw_outstanding);\r\nscsi_dma_unmap(cmd->scmd);\r\ncmd->scmd->scsi_done(cmd->scmd);\r\nmegasas_return_cmd(instance, cmd);\r\nbreak;\r\n}\r\nswitch (hdr->cmd_status) {\r\ncase MFI_STAT_OK:\r\ncmd->scmd->result = DID_OK << 16;\r\nbreak;\r\ncase MFI_STAT_SCSI_IO_FAILED:\r\ncase MFI_STAT_LD_INIT_IN_PROGRESS:\r\ncmd->scmd->result =\r\n(DID_ERROR << 16) | hdr->scsi_status;\r\nbreak;\r\ncase MFI_STAT_SCSI_DONE_WITH_ERROR:\r\ncmd->scmd->result = (DID_OK << 16) | hdr->scsi_status;\r\nif (hdr->scsi_status == SAM_STAT_CHECK_CONDITION) {\r\nmemset(cmd->scmd->sense_buffer, 0,\r\nSCSI_SENSE_BUFFERSIZE);\r\nmemcpy(cmd->scmd->sense_buffer, cmd->sense,\r\nhdr->sense_len);\r\ncmd->scmd->result |= DRIVER_SENSE << 24;\r\n}\r\nbreak;\r\ncase MFI_STAT_LD_OFFLINE:\r\ncase MFI_STAT_DEVICE_NOT_FOUND:\r\ncmd->scmd->result = DID_BAD_TARGET << 16;\r\nbreak;\r\ndefault:\r\nprintk(KERN_DEBUG "megasas: MFI FW status %#x\n",\r\nhdr->cmd_status);\r\ncmd->scmd->result = DID_ERROR << 16;\r\nbreak;\r\n}\r\natomic_dec(&instance->fw_outstanding);\r\nscsi_dma_unmap(cmd->scmd);\r\ncmd->scmd->scsi_done(cmd->scmd);\r\nmegasas_return_cmd(instance, cmd);\r\nbreak;\r\ncase MFI_CMD_SMP:\r\ncase MFI_CMD_STP:\r\ncase MFI_CMD_DCMD:\r\nopcode = le32_to_cpu(cmd->frame->dcmd.opcode);\r\nif ((opcode == MR_DCMD_LD_MAP_GET_INFO)\r\n&& (cmd->frame->dcmd.mbox.b[1] == 1)) {\r\nfusion->fast_path_io = 0;\r\nspin_lock_irqsave(instance->host->host_lock, flags);\r\nif (cmd->frame->hdr.cmd_status != 0) {\r\nif (cmd->frame->hdr.cmd_status !=\r\nMFI_STAT_NOT_FOUND)\r\nprintk(KERN_WARNING "megasas: map sync"\r\n"failed, status = 0x%x.\n",\r\ncmd->frame->hdr.cmd_status);\r\nelse {\r\nmegasas_return_mfi_mpt_pthr(instance,\r\ncmd, cmd->mpt_pthr_cmd_blocked);\r\nspin_unlock_irqrestore(\r\ninstance->host->host_lock,\r\nflags);\r\nbreak;\r\n}\r\n} else\r\ninstance->map_id++;\r\nmegasas_return_mfi_mpt_pthr(instance, cmd,\r\ncmd->mpt_pthr_cmd_blocked);\r\nif (MR_ValidateMapInfo(instance))\r\nfusion->fast_path_io = 1;\r\nelse\r\nfusion->fast_path_io = 0;\r\nmegasas_sync_map_info(instance);\r\nspin_unlock_irqrestore(instance->host->host_lock,\r\nflags);\r\nbreak;\r\n}\r\nif (opcode == MR_DCMD_CTRL_EVENT_GET_INFO ||\r\nopcode == MR_DCMD_CTRL_EVENT_GET) {\r\nspin_lock_irqsave(&poll_aen_lock, flags);\r\nmegasas_poll_wait_aen = 0;\r\nspin_unlock_irqrestore(&poll_aen_lock, flags);\r\n}\r\nif (opcode == MR_DCMD_CTRL_EVENT_WAIT)\r\nmegasas_service_aen(instance, cmd);\r\nelse\r\nmegasas_complete_int_cmd(instance, cmd);\r\nbreak;\r\ncase MFI_CMD_ABORT:\r\nmegasas_complete_abort(instance, cmd);\r\nbreak;\r\ndefault:\r\nprintk("megasas: Unknown command completed! [0x%X]\n",\r\nhdr->cmd);\r\nbreak;\r\n}\r\n}\r\nstatic inline void\r\nmegasas_issue_pending_cmds_again(struct megasas_instance *instance)\r\n{\r\nstruct megasas_cmd *cmd;\r\nstruct list_head clist_local;\r\nunion megasas_evt_class_locale class_locale;\r\nunsigned long flags;\r\nu32 seq_num;\r\nINIT_LIST_HEAD(&clist_local);\r\nspin_lock_irqsave(&instance->hba_lock, flags);\r\nlist_splice_init(&instance->internal_reset_pending_q, &clist_local);\r\nspin_unlock_irqrestore(&instance->hba_lock, flags);\r\nwhile (!list_empty(&clist_local)) {\r\ncmd = list_entry((&clist_local)->next,\r\nstruct megasas_cmd, list);\r\nlist_del_init(&cmd->list);\r\nif (cmd->sync_cmd || cmd->scmd) {\r\nprintk(KERN_NOTICE "megaraid_sas: command %p, %p:%d"\r\n"detected to be pending while HBA reset.\n",\r\ncmd, cmd->scmd, cmd->sync_cmd);\r\ncmd->retry_for_fw_reset++;\r\nif (cmd->retry_for_fw_reset == 3) {\r\nprintk(KERN_NOTICE "megaraid_sas: cmd %p, %p:%d"\r\n"was tried multiple times during reset."\r\n"Shutting down the HBA\n",\r\ncmd, cmd->scmd, cmd->sync_cmd);\r\ninstance->instancet->disable_intr(instance);\r\natomic_set(&instance->fw_reset_no_pci_access, 1);\r\nmegaraid_sas_kill_hba(instance);\r\nreturn;\r\n}\r\n}\r\nif (cmd->sync_cmd == 1) {\r\nif (cmd->scmd) {\r\nprintk(KERN_NOTICE "megaraid_sas: unexpected"\r\n"cmd attached to internal command!\n");\r\n}\r\nprintk(KERN_NOTICE "megasas: %p synchronous cmd"\r\n"on the internal reset queue,"\r\n"issue it again.\n", cmd);\r\ncmd->cmd_status = ENODATA;\r\ninstance->instancet->fire_cmd(instance,\r\ncmd->frame_phys_addr ,\r\n0, instance->reg_set);\r\n} else if (cmd->scmd) {\r\nprintk(KERN_NOTICE "megasas: %p scsi cmd [%02x]"\r\n"detected on the internal queue, issue again.\n",\r\ncmd, cmd->scmd->cmnd[0]);\r\natomic_inc(&instance->fw_outstanding);\r\ninstance->instancet->fire_cmd(instance,\r\ncmd->frame_phys_addr,\r\ncmd->frame_count-1, instance->reg_set);\r\n} else {\r\nprintk(KERN_NOTICE "megasas: %p unexpected cmd on the"\r\n"internal reset defer list while re-issue!!\n",\r\ncmd);\r\n}\r\n}\r\nif (instance->aen_cmd) {\r\nprintk(KERN_NOTICE "megaraid_sas: aen_cmd in def process\n");\r\nmegasas_return_cmd(instance, instance->aen_cmd);\r\ninstance->aen_cmd = NULL;\r\n}\r\nseq_num = instance->last_seq_num;\r\nclass_locale.members.reserved = 0;\r\nclass_locale.members.locale = MR_EVT_LOCALE_ALL;\r\nclass_locale.members.class = MR_EVT_CLASS_DEBUG;\r\nmegasas_register_aen(instance, seq_num, class_locale.word);\r\n}\r\nstatic void\r\nmegasas_internal_reset_defer_cmds(struct megasas_instance *instance)\r\n{\r\nstruct megasas_cmd *cmd;\r\nint i;\r\nu32 max_cmd = instance->max_fw_cmds;\r\nu32 defer_index;\r\nunsigned long flags;\r\ndefer_index = 0;\r\nspin_lock_irqsave(&instance->mfi_pool_lock, flags);\r\nfor (i = 0; i < max_cmd; i++) {\r\ncmd = instance->cmd_list[i];\r\nif (cmd->sync_cmd == 1 || cmd->scmd) {\r\nprintk(KERN_NOTICE "megasas: moving cmd[%d]:%p:%d:%p"\r\n"on the defer queue as internal\n",\r\ndefer_index, cmd, cmd->sync_cmd, cmd->scmd);\r\nif (!list_empty(&cmd->list)) {\r\nprintk(KERN_NOTICE "megaraid_sas: ERROR while"\r\n" moving this cmd:%p, %d %p, it was"\r\n"discovered on some list?\n",\r\ncmd, cmd->sync_cmd, cmd->scmd);\r\nlist_del_init(&cmd->list);\r\n}\r\ndefer_index++;\r\nlist_add_tail(&cmd->list,\r\n&instance->internal_reset_pending_q);\r\n}\r\n}\r\nspin_unlock_irqrestore(&instance->mfi_pool_lock, flags);\r\n}\r\nstatic void\r\nprocess_fw_state_change_wq(struct work_struct *work)\r\n{\r\nstruct megasas_instance *instance =\r\ncontainer_of(work, struct megasas_instance, work_init);\r\nu32 wait;\r\nunsigned long flags;\r\nif (instance->adprecovery != MEGASAS_ADPRESET_SM_INFAULT) {\r\nprintk(KERN_NOTICE "megaraid_sas: error, recovery st %x \n",\r\ninstance->adprecovery);\r\nreturn ;\r\n}\r\nif (instance->adprecovery == MEGASAS_ADPRESET_SM_INFAULT) {\r\nprintk(KERN_NOTICE "megaraid_sas: FW detected to be in fault"\r\n"state, restarting it...\n");\r\ninstance->instancet->disable_intr(instance);\r\natomic_set(&instance->fw_outstanding, 0);\r\natomic_set(&instance->fw_reset_no_pci_access, 1);\r\ninstance->instancet->adp_reset(instance, instance->reg_set);\r\natomic_set(&instance->fw_reset_no_pci_access, 0 );\r\nprintk(KERN_NOTICE "megaraid_sas: FW restarted successfully,"\r\n"initiating next stage...\n");\r\nprintk(KERN_NOTICE "megaraid_sas: HBA recovery state machine,"\r\n"state 2 starting...\n");\r\nfor (wait = 0; wait < 30; wait++) {\r\nmsleep(1000);\r\n}\r\nif (megasas_transition_to_ready(instance, 1)) {\r\nprintk(KERN_NOTICE "megaraid_sas:adapter not ready\n");\r\natomic_set(&instance->fw_reset_no_pci_access, 1);\r\nmegaraid_sas_kill_hba(instance);\r\nreturn ;\r\n}\r\nif ((instance->pdev->device == PCI_DEVICE_ID_LSI_SAS1064R) ||\r\n(instance->pdev->device == PCI_DEVICE_ID_DELL_PERC5) ||\r\n(instance->pdev->device == PCI_DEVICE_ID_LSI_VERDE_ZCR)\r\n) {\r\n*instance->consumer = *instance->producer;\r\n} else {\r\n*instance->consumer = 0;\r\n*instance->producer = 0;\r\n}\r\nmegasas_issue_init_mfi(instance);\r\nspin_lock_irqsave(&instance->hba_lock, flags);\r\ninstance->adprecovery = MEGASAS_HBA_OPERATIONAL;\r\nspin_unlock_irqrestore(&instance->hba_lock, flags);\r\ninstance->instancet->enable_intr(instance);\r\nmegasas_issue_pending_cmds_again(instance);\r\ninstance->issuepend_done = 1;\r\n}\r\nreturn ;\r\n}\r\nstatic int\r\nmegasas_deplete_reply_queue(struct megasas_instance *instance,\r\nu8 alt_status)\r\n{\r\nu32 mfiStatus;\r\nu32 fw_state;\r\nif ((mfiStatus = instance->instancet->check_reset(instance,\r\ninstance->reg_set)) == 1) {\r\nreturn IRQ_HANDLED;\r\n}\r\nif ((mfiStatus = instance->instancet->clear_intr(\r\ninstance->reg_set)\r\n) == 0) {\r\nif (!instance->msix_vectors)\r\nreturn IRQ_NONE;\r\n}\r\ninstance->mfiStatus = mfiStatus;\r\nif ((mfiStatus & MFI_INTR_FLAG_FIRMWARE_STATE_CHANGE)) {\r\nfw_state = instance->instancet->read_fw_status_reg(\r\ninstance->reg_set) & MFI_STATE_MASK;\r\nif (fw_state != MFI_STATE_FAULT) {\r\nprintk(KERN_NOTICE "megaraid_sas: fw state:%x\n",\r\nfw_state);\r\n}\r\nif ((fw_state == MFI_STATE_FAULT) &&\r\n(instance->disableOnlineCtrlReset == 0)) {\r\nprintk(KERN_NOTICE "megaraid_sas: wait adp restart\n");\r\nif ((instance->pdev->device ==\r\nPCI_DEVICE_ID_LSI_SAS1064R) ||\r\n(instance->pdev->device ==\r\nPCI_DEVICE_ID_DELL_PERC5) ||\r\n(instance->pdev->device ==\r\nPCI_DEVICE_ID_LSI_VERDE_ZCR)) {\r\n*instance->consumer =\r\ncpu_to_le32(MEGASAS_ADPRESET_INPROG_SIGN);\r\n}\r\ninstance->instancet->disable_intr(instance);\r\ninstance->adprecovery = MEGASAS_ADPRESET_SM_INFAULT;\r\ninstance->issuepend_done = 0;\r\natomic_set(&instance->fw_outstanding, 0);\r\nmegasas_internal_reset_defer_cmds(instance);\r\nprintk(KERN_NOTICE "megasas: fwState=%x, stage:%d\n",\r\nfw_state, instance->adprecovery);\r\nschedule_work(&instance->work_init);\r\nreturn IRQ_HANDLED;\r\n} else {\r\nprintk(KERN_NOTICE "megasas: fwstate:%x, dis_OCR=%x\n",\r\nfw_state, instance->disableOnlineCtrlReset);\r\n}\r\n}\r\ntasklet_schedule(&instance->isr_tasklet);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t megasas_isr(int irq, void *devp)\r\n{\r\nstruct megasas_irq_context *irq_context = devp;\r\nstruct megasas_instance *instance = irq_context->instance;\r\nunsigned long flags;\r\nirqreturn_t rc;\r\nif (atomic_read(&instance->fw_reset_no_pci_access))\r\nreturn IRQ_HANDLED;\r\nspin_lock_irqsave(&instance->hba_lock, flags);\r\nrc = megasas_deplete_reply_queue(instance, DID_OK);\r\nspin_unlock_irqrestore(&instance->hba_lock, flags);\r\nreturn rc;\r\n}\r\nint\r\nmegasas_transition_to_ready(struct megasas_instance *instance, int ocr)\r\n{\r\nint i;\r\nu8 max_wait;\r\nu32 fw_state;\r\nu32 cur_state;\r\nu32 abs_state, curr_abs_state;\r\nabs_state = instance->instancet->read_fw_status_reg(instance->reg_set);\r\nfw_state = abs_state & MFI_STATE_MASK;\r\nif (fw_state != MFI_STATE_READY)\r\nprintk(KERN_INFO "megasas: Waiting for FW to come to ready"\r\n" state\n");\r\nwhile (fw_state != MFI_STATE_READY) {\r\nswitch (fw_state) {\r\ncase MFI_STATE_FAULT:\r\nprintk(KERN_DEBUG "megasas: FW in FAULT state!!\n");\r\nif (ocr) {\r\nmax_wait = MEGASAS_RESET_WAIT_TIME;\r\ncur_state = MFI_STATE_FAULT;\r\nbreak;\r\n} else\r\nreturn -ENODEV;\r\ncase MFI_STATE_WAIT_HANDSHAKE:\r\nif ((instance->pdev->device ==\r\nPCI_DEVICE_ID_LSI_SAS0073SKINNY) ||\r\n(instance->pdev->device ==\r\nPCI_DEVICE_ID_LSI_SAS0071SKINNY) ||\r\n(instance->pdev->device ==\r\nPCI_DEVICE_ID_LSI_FUSION) ||\r\n(instance->pdev->device ==\r\nPCI_DEVICE_ID_LSI_PLASMA) ||\r\n(instance->pdev->device ==\r\nPCI_DEVICE_ID_LSI_INVADER) ||\r\n(instance->pdev->device ==\r\nPCI_DEVICE_ID_LSI_FURY)) {\r\nwritel(\r\nMFI_INIT_CLEAR_HANDSHAKE|MFI_INIT_HOTPLUG,\r\n&instance->reg_set->doorbell);\r\n} else {\r\nwritel(\r\nMFI_INIT_CLEAR_HANDSHAKE|MFI_INIT_HOTPLUG,\r\n&instance->reg_set->inbound_doorbell);\r\n}\r\nmax_wait = MEGASAS_RESET_WAIT_TIME;\r\ncur_state = MFI_STATE_WAIT_HANDSHAKE;\r\nbreak;\r\ncase MFI_STATE_BOOT_MESSAGE_PENDING:\r\nif ((instance->pdev->device ==\r\nPCI_DEVICE_ID_LSI_SAS0073SKINNY) ||\r\n(instance->pdev->device ==\r\nPCI_DEVICE_ID_LSI_SAS0071SKINNY) ||\r\n(instance->pdev->device ==\r\nPCI_DEVICE_ID_LSI_FUSION) ||\r\n(instance->pdev->device ==\r\nPCI_DEVICE_ID_LSI_PLASMA) ||\r\n(instance->pdev->device ==\r\nPCI_DEVICE_ID_LSI_INVADER) ||\r\n(instance->pdev->device ==\r\nPCI_DEVICE_ID_LSI_FURY)) {\r\nwritel(MFI_INIT_HOTPLUG,\r\n&instance->reg_set->doorbell);\r\n} else\r\nwritel(MFI_INIT_HOTPLUG,\r\n&instance->reg_set->inbound_doorbell);\r\nmax_wait = MEGASAS_RESET_WAIT_TIME;\r\ncur_state = MFI_STATE_BOOT_MESSAGE_PENDING;\r\nbreak;\r\ncase MFI_STATE_OPERATIONAL:\r\ninstance->instancet->disable_intr(instance);\r\nif ((instance->pdev->device ==\r\nPCI_DEVICE_ID_LSI_SAS0073SKINNY) ||\r\n(instance->pdev->device ==\r\nPCI_DEVICE_ID_LSI_SAS0071SKINNY) ||\r\n(instance->pdev->device\r\n== PCI_DEVICE_ID_LSI_FUSION) ||\r\n(instance->pdev->device\r\n== PCI_DEVICE_ID_LSI_PLASMA) ||\r\n(instance->pdev->device\r\n== PCI_DEVICE_ID_LSI_INVADER) ||\r\n(instance->pdev->device\r\n== PCI_DEVICE_ID_LSI_FURY)) {\r\nwritel(MFI_RESET_FLAGS,\r\n&instance->reg_set->doorbell);\r\nif ((instance->pdev->device ==\r\nPCI_DEVICE_ID_LSI_FUSION) ||\r\n(instance->pdev->device ==\r\nPCI_DEVICE_ID_LSI_PLASMA) ||\r\n(instance->pdev->device ==\r\nPCI_DEVICE_ID_LSI_INVADER) ||\r\n(instance->pdev->device ==\r\nPCI_DEVICE_ID_LSI_FURY)) {\r\nfor (i = 0; i < (10 * 1000); i += 20) {\r\nif (readl(\r\n&instance->\r\nreg_set->\r\ndoorbell) & 1)\r\nmsleep(20);\r\nelse\r\nbreak;\r\n}\r\n}\r\n} else\r\nwritel(MFI_RESET_FLAGS,\r\n&instance->reg_set->inbound_doorbell);\r\nmax_wait = MEGASAS_RESET_WAIT_TIME;\r\ncur_state = MFI_STATE_OPERATIONAL;\r\nbreak;\r\ncase MFI_STATE_UNDEFINED:\r\nmax_wait = MEGASAS_RESET_WAIT_TIME;\r\ncur_state = MFI_STATE_UNDEFINED;\r\nbreak;\r\ncase MFI_STATE_BB_INIT:\r\nmax_wait = MEGASAS_RESET_WAIT_TIME;\r\ncur_state = MFI_STATE_BB_INIT;\r\nbreak;\r\ncase MFI_STATE_FW_INIT:\r\nmax_wait = MEGASAS_RESET_WAIT_TIME;\r\ncur_state = MFI_STATE_FW_INIT;\r\nbreak;\r\ncase MFI_STATE_FW_INIT_2:\r\nmax_wait = MEGASAS_RESET_WAIT_TIME;\r\ncur_state = MFI_STATE_FW_INIT_2;\r\nbreak;\r\ncase MFI_STATE_DEVICE_SCAN:\r\nmax_wait = MEGASAS_RESET_WAIT_TIME;\r\ncur_state = MFI_STATE_DEVICE_SCAN;\r\nbreak;\r\ncase MFI_STATE_FLUSH_CACHE:\r\nmax_wait = MEGASAS_RESET_WAIT_TIME;\r\ncur_state = MFI_STATE_FLUSH_CACHE;\r\nbreak;\r\ndefault:\r\nprintk(KERN_DEBUG "megasas: Unknown state 0x%x\n",\r\nfw_state);\r\nreturn -ENODEV;\r\n}\r\nfor (i = 0; i < (max_wait * 1000); i++) {\r\ncurr_abs_state = instance->instancet->\r\nread_fw_status_reg(instance->reg_set);\r\nif (abs_state == curr_abs_state) {\r\nmsleep(1);\r\n} else\r\nbreak;\r\n}\r\nif (curr_abs_state == abs_state) {\r\nprintk(KERN_DEBUG "FW state [%d] hasn't changed "\r\n"in %d secs\n", fw_state, max_wait);\r\nreturn -ENODEV;\r\n}\r\nabs_state = curr_abs_state;\r\nfw_state = curr_abs_state & MFI_STATE_MASK;\r\n}\r\nprintk(KERN_INFO "megasas: FW now in Ready state\n");\r\nreturn 0;\r\n}\r\nstatic void megasas_teardown_frame_pool(struct megasas_instance *instance)\r\n{\r\nint i;\r\nu32 max_cmd = instance->max_mfi_cmds;\r\nstruct megasas_cmd *cmd;\r\nif (!instance->frame_dma_pool)\r\nreturn;\r\nfor (i = 0; i < max_cmd; i++) {\r\ncmd = instance->cmd_list[i];\r\nif (cmd->frame)\r\npci_pool_free(instance->frame_dma_pool, cmd->frame,\r\ncmd->frame_phys_addr);\r\nif (cmd->sense)\r\npci_pool_free(instance->sense_dma_pool, cmd->sense,\r\ncmd->sense_phys_addr);\r\n}\r\npci_pool_destroy(instance->frame_dma_pool);\r\npci_pool_destroy(instance->sense_dma_pool);\r\ninstance->frame_dma_pool = NULL;\r\ninstance->sense_dma_pool = NULL;\r\n}\r\nstatic int megasas_create_frame_pool(struct megasas_instance *instance)\r\n{\r\nint i;\r\nu32 max_cmd;\r\nu32 sge_sz;\r\nu32 total_sz;\r\nu32 frame_count;\r\nstruct megasas_cmd *cmd;\r\nmax_cmd = instance->max_mfi_cmds;\r\nsge_sz = (IS_DMA64) ? sizeof(struct megasas_sge64) :\r\nsizeof(struct megasas_sge32);\r\nif (instance->flag_ieee) {\r\nsge_sz = sizeof(struct megasas_sge_skinny);\r\n}\r\nframe_count = instance->ctrl_context ? (3 + 1) : (15 + 1);\r\ntotal_sz = MEGAMFI_FRAME_SIZE * frame_count;\r\ninstance->frame_dma_pool = pci_pool_create("megasas frame pool",\r\ninstance->pdev, total_sz, 256, 0);\r\nif (!instance->frame_dma_pool) {\r\nprintk(KERN_DEBUG "megasas: failed to setup frame pool\n");\r\nreturn -ENOMEM;\r\n}\r\ninstance->sense_dma_pool = pci_pool_create("megasas sense pool",\r\ninstance->pdev, 128, 4, 0);\r\nif (!instance->sense_dma_pool) {\r\nprintk(KERN_DEBUG "megasas: failed to setup sense pool\n");\r\npci_pool_destroy(instance->frame_dma_pool);\r\ninstance->frame_dma_pool = NULL;\r\nreturn -ENOMEM;\r\n}\r\nfor (i = 0; i < max_cmd; i++) {\r\ncmd = instance->cmd_list[i];\r\ncmd->frame = pci_pool_alloc(instance->frame_dma_pool,\r\nGFP_KERNEL, &cmd->frame_phys_addr);\r\ncmd->sense = pci_pool_alloc(instance->sense_dma_pool,\r\nGFP_KERNEL, &cmd->sense_phys_addr);\r\nif (!cmd->frame || !cmd->sense) {\r\nprintk(KERN_DEBUG "megasas: pci_pool_alloc failed \n");\r\nmegasas_teardown_frame_pool(instance);\r\nreturn -ENOMEM;\r\n}\r\nmemset(cmd->frame, 0, total_sz);\r\ncmd->frame->io.context = cpu_to_le32(cmd->index);\r\ncmd->frame->io.pad_0 = 0;\r\nif ((instance->pdev->device != PCI_DEVICE_ID_LSI_FUSION) &&\r\n(instance->pdev->device != PCI_DEVICE_ID_LSI_PLASMA) &&\r\n(instance->pdev->device != PCI_DEVICE_ID_LSI_INVADER) &&\r\n(instance->pdev->device != PCI_DEVICE_ID_LSI_FURY) &&\r\n(reset_devices))\r\ncmd->frame->hdr.cmd = MFI_CMD_INVALID;\r\n}\r\nreturn 0;\r\n}\r\nvoid megasas_free_cmds(struct megasas_instance *instance)\r\n{\r\nint i;\r\nmegasas_teardown_frame_pool(instance);\r\nfor (i = 0; i < instance->max_mfi_cmds; i++)\r\nkfree(instance->cmd_list[i]);\r\nkfree(instance->cmd_list);\r\ninstance->cmd_list = NULL;\r\nINIT_LIST_HEAD(&instance->cmd_pool);\r\n}\r\nint megasas_alloc_cmds(struct megasas_instance *instance)\r\n{\r\nint i;\r\nint j;\r\nu32 max_cmd;\r\nstruct megasas_cmd *cmd;\r\nstruct fusion_context *fusion;\r\nfusion = instance->ctrl_context;\r\nmax_cmd = instance->max_mfi_cmds;\r\ninstance->cmd_list = kcalloc(max_cmd, sizeof(struct megasas_cmd*), GFP_KERNEL);\r\nif (!instance->cmd_list) {\r\nprintk(KERN_DEBUG "megasas: out of memory\n");\r\nreturn -ENOMEM;\r\n}\r\nmemset(instance->cmd_list, 0, sizeof(struct megasas_cmd *) *max_cmd);\r\nfor (i = 0; i < max_cmd; i++) {\r\ninstance->cmd_list[i] = kmalloc(sizeof(struct megasas_cmd),\r\nGFP_KERNEL);\r\nif (!instance->cmd_list[i]) {\r\nfor (j = 0; j < i; j++)\r\nkfree(instance->cmd_list[j]);\r\nkfree(instance->cmd_list);\r\ninstance->cmd_list = NULL;\r\nreturn -ENOMEM;\r\n}\r\n}\r\nfor (i = 0; i < max_cmd; i++) {\r\ncmd = instance->cmd_list[i];\r\nmemset(cmd, 0, sizeof(struct megasas_cmd));\r\ncmd->index = i;\r\natomic_set(&cmd->mfi_mpt_pthr, MFI_LIST_ADDED);\r\ncmd->scmd = NULL;\r\ncmd->instance = instance;\r\nlist_add_tail(&cmd->list, &instance->cmd_pool);\r\n}\r\nif (megasas_create_frame_pool(instance)) {\r\nprintk(KERN_DEBUG "megasas: Error creating frame DMA pool\n");\r\nmegasas_free_cmds(instance);\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nmegasas_get_pd_list(struct megasas_instance *instance)\r\n{\r\nint ret = 0, pd_index = 0;\r\nstruct megasas_cmd *cmd;\r\nstruct megasas_dcmd_frame *dcmd;\r\nstruct MR_PD_LIST *ci;\r\nstruct MR_PD_ADDRESS *pd_addr;\r\ndma_addr_t ci_h = 0;\r\ncmd = megasas_get_cmd(instance);\r\nif (!cmd) {\r\nprintk(KERN_DEBUG "megasas (get_pd_list): Failed to get cmd\n");\r\nreturn -ENOMEM;\r\n}\r\ndcmd = &cmd->frame->dcmd;\r\nci = pci_alloc_consistent(instance->pdev,\r\nMEGASAS_MAX_PD * sizeof(struct MR_PD_LIST), &ci_h);\r\nif (!ci) {\r\nprintk(KERN_DEBUG "Failed to alloc mem for pd_list\n");\r\nmegasas_return_cmd(instance, cmd);\r\nreturn -ENOMEM;\r\n}\r\nmemset(ci, 0, sizeof(*ci));\r\nmemset(dcmd->mbox.b, 0, MFI_MBOX_SIZE);\r\ndcmd->mbox.b[0] = MR_PD_QUERY_TYPE_EXPOSED_TO_HOST;\r\ndcmd->mbox.b[1] = 0;\r\ndcmd->cmd = MFI_CMD_DCMD;\r\ndcmd->cmd_status = 0xFF;\r\ndcmd->sge_count = 1;\r\ndcmd->flags = cpu_to_le16(MFI_FRAME_DIR_READ);\r\ndcmd->timeout = 0;\r\ndcmd->pad_0 = 0;\r\ndcmd->data_xfer_len = cpu_to_le32(MEGASAS_MAX_PD * sizeof(struct MR_PD_LIST));\r\ndcmd->opcode = cpu_to_le32(MR_DCMD_PD_LIST_QUERY);\r\ndcmd->sgl.sge32[0].phys_addr = cpu_to_le32(ci_h);\r\ndcmd->sgl.sge32[0].length = cpu_to_le32(MEGASAS_MAX_PD * sizeof(struct MR_PD_LIST));\r\nif (instance->ctrl_context && !instance->mask_interrupts)\r\nret = megasas_issue_blocked_cmd(instance, cmd,\r\nMEGASAS_BLOCKED_CMD_TIMEOUT);\r\nelse\r\nret = megasas_issue_polled(instance, cmd);\r\npd_addr = ci->addr;\r\nif ( ret == 0 &&\r\n(le32_to_cpu(ci->count) <\r\n(MEGASAS_MAX_PD_CHANNELS * MEGASAS_MAX_DEV_PER_CHANNEL))) {\r\nmemset(instance->local_pd_list, 0,\r\nMEGASAS_MAX_PD * sizeof(struct megasas_pd_list));\r\nfor (pd_index = 0; pd_index < le32_to_cpu(ci->count); pd_index++) {\r\ninstance->local_pd_list[le16_to_cpu(pd_addr->deviceId)].tid =\r\nle16_to_cpu(pd_addr->deviceId);\r\ninstance->local_pd_list[le16_to_cpu(pd_addr->deviceId)].driveType =\r\npd_addr->scsiDevType;\r\ninstance->local_pd_list[le16_to_cpu(pd_addr->deviceId)].driveState =\r\nMR_PD_STATE_SYSTEM;\r\npd_addr++;\r\n}\r\nmemcpy(instance->pd_list, instance->local_pd_list,\r\nsizeof(instance->pd_list));\r\n}\r\npci_free_consistent(instance->pdev,\r\nMEGASAS_MAX_PD * sizeof(struct MR_PD_LIST),\r\nci, ci_h);\r\nif (instance->ctrl_context && cmd->mpt_pthr_cmd_blocked)\r\nmegasas_return_mfi_mpt_pthr(instance, cmd,\r\ncmd->mpt_pthr_cmd_blocked);\r\nelse\r\nmegasas_return_cmd(instance, cmd);\r\nreturn ret;\r\n}\r\nstatic int\r\nmegasas_get_ld_list(struct megasas_instance *instance)\r\n{\r\nint ret = 0, ld_index = 0, ids = 0;\r\nstruct megasas_cmd *cmd;\r\nstruct megasas_dcmd_frame *dcmd;\r\nstruct MR_LD_LIST *ci;\r\ndma_addr_t ci_h = 0;\r\nu32 ld_count;\r\ncmd = megasas_get_cmd(instance);\r\nif (!cmd) {\r\nprintk(KERN_DEBUG "megasas_get_ld_list: Failed to get cmd\n");\r\nreturn -ENOMEM;\r\n}\r\ndcmd = &cmd->frame->dcmd;\r\nci = pci_alloc_consistent(instance->pdev,\r\nsizeof(struct MR_LD_LIST),\r\n&ci_h);\r\nif (!ci) {\r\nprintk(KERN_DEBUG "Failed to alloc mem in get_ld_list\n");\r\nmegasas_return_cmd(instance, cmd);\r\nreturn -ENOMEM;\r\n}\r\nmemset(ci, 0, sizeof(*ci));\r\nmemset(dcmd->mbox.b, 0, MFI_MBOX_SIZE);\r\nif (instance->supportmax256vd)\r\ndcmd->mbox.b[0] = 1;\r\ndcmd->cmd = MFI_CMD_DCMD;\r\ndcmd->cmd_status = 0xFF;\r\ndcmd->sge_count = 1;\r\ndcmd->flags = cpu_to_le16(MFI_FRAME_DIR_READ);\r\ndcmd->timeout = 0;\r\ndcmd->data_xfer_len = cpu_to_le32(sizeof(struct MR_LD_LIST));\r\ndcmd->opcode = cpu_to_le32(MR_DCMD_LD_GET_LIST);\r\ndcmd->sgl.sge32[0].phys_addr = cpu_to_le32(ci_h);\r\ndcmd->sgl.sge32[0].length = cpu_to_le32(sizeof(struct MR_LD_LIST));\r\ndcmd->pad_0 = 0;\r\nif (instance->ctrl_context && !instance->mask_interrupts)\r\nret = megasas_issue_blocked_cmd(instance, cmd,\r\nMEGASAS_BLOCKED_CMD_TIMEOUT);\r\nelse\r\nret = megasas_issue_polled(instance, cmd);\r\nld_count = le32_to_cpu(ci->ldCount);\r\nif ((ret == 0) && (ld_count <= instance->fw_supported_vd_count)) {\r\nmemset(instance->ld_ids, 0xff, MAX_LOGICAL_DRIVES_EXT);\r\nfor (ld_index = 0; ld_index < ld_count; ld_index++) {\r\nif (ci->ldList[ld_index].state != 0) {\r\nids = ci->ldList[ld_index].ref.targetId;\r\ninstance->ld_ids[ids] =\r\nci->ldList[ld_index].ref.targetId;\r\n}\r\n}\r\n}\r\npci_free_consistent(instance->pdev,\r\nsizeof(struct MR_LD_LIST),\r\nci,\r\nci_h);\r\nif (instance->ctrl_context && cmd->mpt_pthr_cmd_blocked)\r\nmegasas_return_mfi_mpt_pthr(instance, cmd,\r\ncmd->mpt_pthr_cmd_blocked);\r\nelse\r\nmegasas_return_cmd(instance, cmd);\r\nreturn ret;\r\n}\r\nstatic int\r\nmegasas_ld_list_query(struct megasas_instance *instance, u8 query_type)\r\n{\r\nint ret = 0, ld_index = 0, ids = 0;\r\nstruct megasas_cmd *cmd;\r\nstruct megasas_dcmd_frame *dcmd;\r\nstruct MR_LD_TARGETID_LIST *ci;\r\ndma_addr_t ci_h = 0;\r\nu32 tgtid_count;\r\ncmd = megasas_get_cmd(instance);\r\nif (!cmd) {\r\nprintk(KERN_WARNING\r\n"megasas:(megasas_ld_list_query): Failed to get cmd\n");\r\nreturn -ENOMEM;\r\n}\r\ndcmd = &cmd->frame->dcmd;\r\nci = pci_alloc_consistent(instance->pdev,\r\nsizeof(struct MR_LD_TARGETID_LIST), &ci_h);\r\nif (!ci) {\r\nprintk(KERN_WARNING\r\n"megasas: Failed to alloc mem for ld_list_query\n");\r\nmegasas_return_cmd(instance, cmd);\r\nreturn -ENOMEM;\r\n}\r\nmemset(ci, 0, sizeof(*ci));\r\nmemset(dcmd->mbox.b, 0, MFI_MBOX_SIZE);\r\ndcmd->mbox.b[0] = query_type;\r\nif (instance->supportmax256vd)\r\ndcmd->mbox.b[2] = 1;\r\ndcmd->cmd = MFI_CMD_DCMD;\r\ndcmd->cmd_status = 0xFF;\r\ndcmd->sge_count = 1;\r\ndcmd->flags = cpu_to_le16(MFI_FRAME_DIR_READ);\r\ndcmd->timeout = 0;\r\ndcmd->data_xfer_len = cpu_to_le32(sizeof(struct MR_LD_TARGETID_LIST));\r\ndcmd->opcode = cpu_to_le32(MR_DCMD_LD_LIST_QUERY);\r\ndcmd->sgl.sge32[0].phys_addr = cpu_to_le32(ci_h);\r\ndcmd->sgl.sge32[0].length = cpu_to_le32(sizeof(struct MR_LD_TARGETID_LIST));\r\ndcmd->pad_0 = 0;\r\nif (instance->ctrl_context && !instance->mask_interrupts)\r\nret = megasas_issue_blocked_cmd(instance, cmd,\r\nMEGASAS_BLOCKED_CMD_TIMEOUT);\r\nelse\r\nret = megasas_issue_polled(instance, cmd);\r\ntgtid_count = le32_to_cpu(ci->count);\r\nif ((ret == 0) && (tgtid_count <= (instance->fw_supported_vd_count))) {\r\nmemset(instance->ld_ids, 0xff, MEGASAS_MAX_LD_IDS);\r\nfor (ld_index = 0; ld_index < tgtid_count; ld_index++) {\r\nids = ci->targetId[ld_index];\r\ninstance->ld_ids[ids] = ci->targetId[ld_index];\r\n}\r\n}\r\npci_free_consistent(instance->pdev, sizeof(struct MR_LD_TARGETID_LIST),\r\nci, ci_h);\r\nif (instance->ctrl_context && cmd->mpt_pthr_cmd_blocked)\r\nmegasas_return_mfi_mpt_pthr(instance, cmd,\r\ncmd->mpt_pthr_cmd_blocked);\r\nelse\r\nmegasas_return_cmd(instance, cmd);\r\nreturn ret;\r\n}\r\nstatic void megasas_update_ext_vd_details(struct megasas_instance *instance)\r\n{\r\nstruct fusion_context *fusion;\r\nu32 old_map_sz;\r\nu32 new_map_sz;\r\nfusion = instance->ctrl_context;\r\nif (!fusion)\r\nreturn;\r\ninstance->supportmax256vd =\r\ninstance->ctrl_info->adapterOperations3.supportMaxExtLDs;\r\nif (instance->ctrl_info->max_lds > 64)\r\ninstance->supportmax256vd = 1;\r\ninstance->drv_supported_vd_count = MEGASAS_MAX_LD_CHANNELS\r\n* MEGASAS_MAX_DEV_PER_CHANNEL;\r\ninstance->drv_supported_pd_count = MEGASAS_MAX_PD_CHANNELS\r\n* MEGASAS_MAX_DEV_PER_CHANNEL;\r\nif (instance->supportmax256vd) {\r\ninstance->fw_supported_vd_count = MAX_LOGICAL_DRIVES_EXT;\r\ninstance->fw_supported_pd_count = MAX_PHYSICAL_DEVICES;\r\n} else {\r\ninstance->fw_supported_vd_count = MAX_LOGICAL_DRIVES;\r\ninstance->fw_supported_pd_count = MAX_PHYSICAL_DEVICES;\r\n}\r\ndev_info(&instance->pdev->dev, "Firmware supports %d VD %d PD\n",\r\ninstance->fw_supported_vd_count,\r\ninstance->fw_supported_pd_count);\r\ndev_info(&instance->pdev->dev, "Driver supports %d VD %d PD\n",\r\ninstance->drv_supported_vd_count,\r\ninstance->drv_supported_pd_count);\r\nold_map_sz = sizeof(struct MR_FW_RAID_MAP) +\r\n(sizeof(struct MR_LD_SPAN_MAP) *\r\n(instance->fw_supported_vd_count - 1));\r\nnew_map_sz = sizeof(struct MR_FW_RAID_MAP_EXT);\r\nfusion->drv_map_sz = sizeof(struct MR_DRV_RAID_MAP) +\r\n(sizeof(struct MR_LD_SPAN_MAP) *\r\n(instance->drv_supported_vd_count - 1));\r\nfusion->max_map_sz = max(old_map_sz, new_map_sz);\r\nif (instance->supportmax256vd)\r\nfusion->current_map_sz = new_map_sz;\r\nelse\r\nfusion->current_map_sz = old_map_sz;\r\n}\r\nint\r\nmegasas_get_ctrl_info(struct megasas_instance *instance)\r\n{\r\nint ret = 0;\r\nstruct megasas_cmd *cmd;\r\nstruct megasas_dcmd_frame *dcmd;\r\nstruct megasas_ctrl_info *ci;\r\nstruct megasas_ctrl_info *ctrl_info;\r\ndma_addr_t ci_h = 0;\r\nctrl_info = instance->ctrl_info;\r\ncmd = megasas_get_cmd(instance);\r\nif (!cmd) {\r\nprintk(KERN_DEBUG "megasas: Failed to get a free cmd\n");\r\nreturn -ENOMEM;\r\n}\r\ndcmd = &cmd->frame->dcmd;\r\nci = pci_alloc_consistent(instance->pdev,\r\nsizeof(struct megasas_ctrl_info), &ci_h);\r\nif (!ci) {\r\nprintk(KERN_DEBUG "Failed to alloc mem for ctrl info\n");\r\nmegasas_return_cmd(instance, cmd);\r\nreturn -ENOMEM;\r\n}\r\nmemset(ci, 0, sizeof(*ci));\r\nmemset(dcmd->mbox.b, 0, MFI_MBOX_SIZE);\r\ndcmd->cmd = MFI_CMD_DCMD;\r\ndcmd->cmd_status = 0xFF;\r\ndcmd->sge_count = 1;\r\ndcmd->flags = cpu_to_le16(MFI_FRAME_DIR_READ);\r\ndcmd->timeout = 0;\r\ndcmd->pad_0 = 0;\r\ndcmd->data_xfer_len = cpu_to_le32(sizeof(struct megasas_ctrl_info));\r\ndcmd->opcode = cpu_to_le32(MR_DCMD_CTRL_GET_INFO);\r\ndcmd->sgl.sge32[0].phys_addr = cpu_to_le32(ci_h);\r\ndcmd->sgl.sge32[0].length = cpu_to_le32(sizeof(struct megasas_ctrl_info));\r\ndcmd->mbox.b[0] = 1;\r\nif (instance->ctrl_context && !instance->mask_interrupts)\r\nret = megasas_issue_blocked_cmd(instance, cmd,\r\nMEGASAS_BLOCKED_CMD_TIMEOUT);\r\nelse\r\nret = megasas_issue_polled(instance, cmd);\r\nif (!ret) {\r\nmemcpy(ctrl_info, ci, sizeof(struct megasas_ctrl_info));\r\nle32_to_cpus((u32 *)&ctrl_info->properties.OnOffProperties);\r\nle32_to_cpus((u32 *)&ctrl_info->adapterOperations2);\r\nle32_to_cpus((u32 *)&ctrl_info->adapterOperations3);\r\nmegasas_update_ext_vd_details(instance);\r\n}\r\npci_free_consistent(instance->pdev, sizeof(struct megasas_ctrl_info),\r\nci, ci_h);\r\nif (instance->ctrl_context && cmd->mpt_pthr_cmd_blocked)\r\nmegasas_return_mfi_mpt_pthr(instance, cmd,\r\ncmd->mpt_pthr_cmd_blocked);\r\nelse\r\nmegasas_return_cmd(instance, cmd);\r\nreturn ret;\r\n}\r\nint megasas_set_crash_dump_params(struct megasas_instance *instance,\r\nu8 crash_buf_state)\r\n{\r\nint ret = 0;\r\nstruct megasas_cmd *cmd;\r\nstruct megasas_dcmd_frame *dcmd;\r\ncmd = megasas_get_cmd(instance);\r\nif (!cmd) {\r\ndev_err(&instance->pdev->dev, "Failed to get a free cmd\n");\r\nreturn -ENOMEM;\r\n}\r\ndcmd = &cmd->frame->dcmd;\r\nmemset(dcmd->mbox.b, 0, MFI_MBOX_SIZE);\r\ndcmd->mbox.b[0] = crash_buf_state;\r\ndcmd->cmd = MFI_CMD_DCMD;\r\ndcmd->cmd_status = 0xFF;\r\ndcmd->sge_count = 1;\r\ndcmd->flags = cpu_to_le16(MFI_FRAME_DIR_NONE);\r\ndcmd->timeout = 0;\r\ndcmd->pad_0 = 0;\r\ndcmd->data_xfer_len = cpu_to_le32(CRASH_DMA_BUF_SIZE);\r\ndcmd->opcode = cpu_to_le32(MR_DCMD_CTRL_SET_CRASH_DUMP_PARAMS);\r\ndcmd->sgl.sge32[0].phys_addr = cpu_to_le32(instance->crash_dump_h);\r\ndcmd->sgl.sge32[0].length = cpu_to_le32(CRASH_DMA_BUF_SIZE);\r\nif (instance->ctrl_context && !instance->mask_interrupts)\r\nret = megasas_issue_blocked_cmd(instance, cmd,\r\nMEGASAS_BLOCKED_CMD_TIMEOUT);\r\nelse\r\nret = megasas_issue_polled(instance, cmd);\r\nif (instance->ctrl_context && cmd->mpt_pthr_cmd_blocked)\r\nmegasas_return_mfi_mpt_pthr(instance, cmd,\r\ncmd->mpt_pthr_cmd_blocked);\r\nelse\r\nmegasas_return_cmd(instance, cmd);\r\nreturn ret;\r\n}\r\nstatic int\r\nmegasas_issue_init_mfi(struct megasas_instance *instance)\r\n{\r\nu32 context;\r\nstruct megasas_cmd *cmd;\r\nstruct megasas_init_frame *init_frame;\r\nstruct megasas_init_queue_info *initq_info;\r\ndma_addr_t init_frame_h;\r\ndma_addr_t initq_info_h;\r\ncmd = megasas_get_cmd(instance);\r\ninit_frame = (struct megasas_init_frame *)cmd->frame;\r\ninitq_info = (struct megasas_init_queue_info *)\r\n((unsigned long)init_frame + 64);\r\ninit_frame_h = cmd->frame_phys_addr;\r\ninitq_info_h = init_frame_h + 64;\r\ncontext = init_frame->context;\r\nmemset(init_frame, 0, MEGAMFI_FRAME_SIZE);\r\nmemset(initq_info, 0, sizeof(struct megasas_init_queue_info));\r\ninit_frame->context = context;\r\ninitq_info->reply_queue_entries = cpu_to_le32(instance->max_fw_cmds + 1);\r\ninitq_info->reply_queue_start_phys_addr_lo = cpu_to_le32(instance->reply_queue_h);\r\ninitq_info->producer_index_phys_addr_lo = cpu_to_le32(instance->producer_h);\r\ninitq_info->consumer_index_phys_addr_lo = cpu_to_le32(instance->consumer_h);\r\ninit_frame->cmd = MFI_CMD_INIT;\r\ninit_frame->cmd_status = 0xFF;\r\ninit_frame->queue_info_new_phys_addr_lo =\r\ncpu_to_le32(lower_32_bits(initq_info_h));\r\ninit_frame->queue_info_new_phys_addr_hi =\r\ncpu_to_le32(upper_32_bits(initq_info_h));\r\ninit_frame->data_xfer_len = cpu_to_le32(sizeof(struct megasas_init_queue_info));\r\ninstance->instancet->disable_intr(instance);\r\nif (megasas_issue_polled(instance, cmd)) {\r\nprintk(KERN_ERR "megasas: Failed to init firmware\n");\r\nmegasas_return_cmd(instance, cmd);\r\ngoto fail_fw_init;\r\n}\r\nmegasas_return_cmd(instance, cmd);\r\nreturn 0;\r\nfail_fw_init:\r\nreturn -EINVAL;\r\n}\r\nstatic u32\r\nmegasas_init_adapter_mfi(struct megasas_instance *instance)\r\n{\r\nstruct megasas_register_set __iomem *reg_set;\r\nu32 context_sz;\r\nu32 reply_q_sz;\r\nreg_set = instance->reg_set;\r\ninstance->max_fw_cmds = instance->instancet->read_fw_status_reg(reg_set) & 0x00FFFF;\r\ninstance->max_fw_cmds = instance->max_fw_cmds-1;\r\ninstance->max_mfi_cmds = instance->max_fw_cmds;\r\ninstance->max_num_sge = (instance->instancet->read_fw_status_reg(reg_set) & 0xFF0000) >>\r\n0x10;\r\nif (megasas_alloc_cmds(instance))\r\ngoto fail_alloc_cmds;\r\ncontext_sz = sizeof(u32);\r\nreply_q_sz = context_sz * (instance->max_fw_cmds + 1);\r\ninstance->reply_queue = pci_alloc_consistent(instance->pdev,\r\nreply_q_sz,\r\n&instance->reply_queue_h);\r\nif (!instance->reply_queue) {\r\nprintk(KERN_DEBUG "megasas: Out of DMA mem for reply queue\n");\r\ngoto fail_reply_queue;\r\n}\r\nif (megasas_issue_init_mfi(instance))\r\ngoto fail_fw_init;\r\nif (megasas_get_ctrl_info(instance)) {\r\ndev_err(&instance->pdev->dev, "(%d): Could get controller info "\r\n"Fail from %s %d\n", instance->unique_id,\r\n__func__, __LINE__);\r\ngoto fail_fw_init;\r\n}\r\ninstance->fw_support_ieee = 0;\r\ninstance->fw_support_ieee =\r\n(instance->instancet->read_fw_status_reg(reg_set) &\r\n0x04000000);\r\nprintk(KERN_NOTICE "megasas_init_mfi: fw_support_ieee=%d",\r\ninstance->fw_support_ieee);\r\nif (instance->fw_support_ieee)\r\ninstance->flag_ieee = 1;\r\nreturn 0;\r\nfail_fw_init:\r\npci_free_consistent(instance->pdev, reply_q_sz,\r\ninstance->reply_queue, instance->reply_queue_h);\r\nfail_reply_queue:\r\nmegasas_free_cmds(instance);\r\nfail_alloc_cmds:\r\nreturn 1;\r\n}\r\nstatic int megasas_init_fw(struct megasas_instance *instance)\r\n{\r\nu32 max_sectors_1;\r\nu32 max_sectors_2;\r\nu32 tmp_sectors, msix_enable, scratch_pad_2;\r\nresource_size_t base_addr;\r\nstruct megasas_register_set __iomem *reg_set;\r\nstruct megasas_ctrl_info *ctrl_info = NULL;\r\nunsigned long bar_list;\r\nint i, loop, fw_msix_count = 0;\r\nstruct IOV_111 *iovPtr;\r\nbar_list = pci_select_bars(instance->pdev, IORESOURCE_MEM);\r\ninstance->bar = find_first_bit(&bar_list, sizeof(unsigned long));\r\nif (pci_request_selected_regions(instance->pdev, instance->bar,\r\n"megasas: LSI")) {\r\nprintk(KERN_DEBUG "megasas: IO memory region busy!\n");\r\nreturn -EBUSY;\r\n}\r\nbase_addr = pci_resource_start(instance->pdev, instance->bar);\r\ninstance->reg_set = ioremap_nocache(base_addr, 8192);\r\nif (!instance->reg_set) {\r\nprintk(KERN_DEBUG "megasas: Failed to map IO mem\n");\r\ngoto fail_ioremap;\r\n}\r\nreg_set = instance->reg_set;\r\nswitch (instance->pdev->device) {\r\ncase PCI_DEVICE_ID_LSI_FUSION:\r\ncase PCI_DEVICE_ID_LSI_PLASMA:\r\ncase PCI_DEVICE_ID_LSI_INVADER:\r\ncase PCI_DEVICE_ID_LSI_FURY:\r\ninstance->instancet = &megasas_instance_template_fusion;\r\nbreak;\r\ncase PCI_DEVICE_ID_LSI_SAS1078R:\r\ncase PCI_DEVICE_ID_LSI_SAS1078DE:\r\ninstance->instancet = &megasas_instance_template_ppc;\r\nbreak;\r\ncase PCI_DEVICE_ID_LSI_SAS1078GEN2:\r\ncase PCI_DEVICE_ID_LSI_SAS0079GEN2:\r\ninstance->instancet = &megasas_instance_template_gen2;\r\nbreak;\r\ncase PCI_DEVICE_ID_LSI_SAS0073SKINNY:\r\ncase PCI_DEVICE_ID_LSI_SAS0071SKINNY:\r\ninstance->instancet = &megasas_instance_template_skinny;\r\nbreak;\r\ncase PCI_DEVICE_ID_LSI_SAS1064R:\r\ncase PCI_DEVICE_ID_DELL_PERC5:\r\ndefault:\r\ninstance->instancet = &megasas_instance_template_xscale;\r\nbreak;\r\n}\r\nif (megasas_transition_to_ready(instance, 0)) {\r\natomic_set(&instance->fw_reset_no_pci_access, 1);\r\ninstance->instancet->adp_reset\r\n(instance, instance->reg_set);\r\natomic_set(&instance->fw_reset_no_pci_access, 0);\r\ndev_info(&instance->pdev->dev,\r\n"megasas: FW restarted successfully from %s!\n",\r\n__func__);\r\nssleep(30);\r\nif (megasas_transition_to_ready(instance, 0))\r\ngoto fail_ready_state;\r\n}\r\ninstance->reply_post_host_index_addr[0] =\r\n(u32 *)((u8 *)instance->reg_set +\r\nMPI2_REPLY_POST_HOST_INDEX_OFFSET);\r\nmsix_enable = (instance->instancet->read_fw_status_reg(reg_set) &\r\n0x4000000) >> 0x1a;\r\nif (msix_enable && !msix_disable) {\r\nscratch_pad_2 = readl\r\n(&instance->reg_set->outbound_scratch_pad_2);\r\nif ((instance->pdev->device == PCI_DEVICE_ID_LSI_FUSION) ||\r\n(instance->pdev->device == PCI_DEVICE_ID_LSI_PLASMA)) {\r\ninstance->msix_vectors = (scratch_pad_2\r\n& MR_MAX_REPLY_QUEUES_OFFSET) + 1;\r\nfw_msix_count = instance->msix_vectors;\r\nif (msix_vectors)\r\ninstance->msix_vectors =\r\nmin(msix_vectors,\r\ninstance->msix_vectors);\r\n} else if ((instance->pdev->device == PCI_DEVICE_ID_LSI_INVADER)\r\n|| (instance->pdev->device == PCI_DEVICE_ID_LSI_FURY)) {\r\ninstance->msix_vectors = ((scratch_pad_2\r\n& MR_MAX_REPLY_QUEUES_EXT_OFFSET)\r\n>> MR_MAX_REPLY_QUEUES_EXT_OFFSET_SHIFT) + 1;\r\nfw_msix_count = instance->msix_vectors;\r\nfor (loop = 1; loop < MR_MAX_MSIX_REG_ARRAY; loop++) {\r\ninstance->reply_post_host_index_addr[loop] =\r\n(u32 *)((u8 *)instance->reg_set +\r\nMPI2_SUP_REPLY_POST_HOST_INDEX_OFFSET\r\n+ (loop * 0x10));\r\n}\r\nif (msix_vectors)\r\ninstance->msix_vectors = min(msix_vectors,\r\ninstance->msix_vectors);\r\n} else\r\ninstance->msix_vectors = 1;\r\ninstance->msix_vectors = min(instance->msix_vectors,\r\n(unsigned int)num_online_cpus());\r\nfor (i = 0; i < instance->msix_vectors; i++)\r\ninstance->msixentry[i].entry = i;\r\ni = pci_enable_msix_range(instance->pdev, instance->msixentry,\r\n1, instance->msix_vectors);\r\nif (i > 0)\r\ninstance->msix_vectors = i;\r\nelse\r\ninstance->msix_vectors = 0;\r\ndev_info(&instance->pdev->dev, "[scsi%d]: FW supports"\r\n"<%d> MSIX vector,Online CPUs: <%d>,"\r\n"Current MSIX <%d>\n", instance->host->host_no,\r\nfw_msix_count, (unsigned int)num_online_cpus(),\r\ninstance->msix_vectors);\r\n}\r\ninstance->ctrl_info = kzalloc(sizeof(struct megasas_ctrl_info),\r\nGFP_KERNEL);\r\nif (instance->ctrl_info == NULL)\r\ngoto fail_init_adapter;\r\ninstance->fw_supported_vd_count = MAX_LOGICAL_DRIVES;\r\ninstance->fw_supported_pd_count = MAX_PHYSICAL_DEVICES;\r\nif (instance->instancet->init_adapter(instance))\r\ngoto fail_init_adapter;\r\nprintk(KERN_ERR "megasas: INIT adapter done\n");\r\nmemset(instance->pd_list, 0 ,\r\n(MEGASAS_MAX_PD * sizeof(struct megasas_pd_list)));\r\nif (megasas_get_pd_list(instance) < 0) {\r\nprintk(KERN_ERR "megasas: failed to get PD list\n");\r\ngoto fail_init_adapter;\r\n}\r\nmemset(instance->ld_ids, 0xff, MEGASAS_MAX_LD_IDS);\r\nif (megasas_ld_list_query(instance,\r\nMR_LD_QUERY_TYPE_EXPOSED_TO_HOST))\r\nmegasas_get_ld_list(instance);\r\ntmp_sectors = 0;\r\nctrl_info = instance->ctrl_info;\r\nmax_sectors_1 = (1 << ctrl_info->stripe_sz_ops.min) *\r\nle16_to_cpu(ctrl_info->max_strips_per_io);\r\nmax_sectors_2 = le32_to_cpu(ctrl_info->max_request_size);\r\ntmp_sectors = min_t(u32, max_sectors_1 , max_sectors_2);\r\nif (ctrl_info->memory_size) {\r\ninstance->is_imr = 0;\r\ndev_info(&instance->pdev->dev, "Controller type: MR,"\r\n"Memory size is: %dMB\n",\r\nle16_to_cpu(ctrl_info->memory_size));\r\n} else {\r\ninstance->is_imr = 1;\r\ndev_info(&instance->pdev->dev,\r\n"Controller type: iMR\n");\r\n}\r\ninstance->disableOnlineCtrlReset =\r\nctrl_info->properties.OnOffProperties.disableOnlineCtrlReset;\r\ninstance->mpio = ctrl_info->adapterOperations2.mpio;\r\ninstance->UnevenSpanSupport =\r\nctrl_info->adapterOperations2.supportUnevenSpans;\r\nif (instance->UnevenSpanSupport) {\r\nstruct fusion_context *fusion = instance->ctrl_context;\r\ndev_info(&instance->pdev->dev, "FW supports: "\r\n"UnevenSpanSupport=%x\n", instance->UnevenSpanSupport);\r\nif (MR_ValidateMapInfo(instance))\r\nfusion->fast_path_io = 1;\r\nelse\r\nfusion->fast_path_io = 0;\r\n}\r\nif (ctrl_info->host_interface.SRIOV) {\r\nif (!ctrl_info->adapterOperations2.activePassive)\r\ninstance->PlasmaFW111 = 1;\r\nif (!instance->PlasmaFW111)\r\ninstance->requestorId =\r\nctrl_info->iov.requestorId;\r\nelse {\r\niovPtr = (struct IOV_111 *)((unsigned char *)ctrl_info + IOV_111_OFFSET);\r\ninstance->requestorId = iovPtr->requestorId;\r\n}\r\ndev_warn(&instance->pdev->dev, "I am VF "\r\n"requestorId %d\n", instance->requestorId);\r\n}\r\ninstance->crash_dump_fw_support =\r\nctrl_info->adapterOperations3.supportCrashDump;\r\ninstance->crash_dump_drv_support =\r\n(instance->crash_dump_fw_support &&\r\ninstance->crash_dump_buf);\r\nif (instance->crash_dump_drv_support) {\r\ndev_info(&instance->pdev->dev, "Firmware Crash dump "\r\n"feature is supported\n");\r\nmegasas_set_crash_dump_params(instance,\r\nMR_CRASH_BUF_TURN_OFF);\r\n} else {\r\nif (instance->crash_dump_buf)\r\npci_free_consistent(instance->pdev,\r\nCRASH_DMA_BUF_SIZE,\r\ninstance->crash_dump_buf,\r\ninstance->crash_dump_h);\r\ninstance->crash_dump_buf = NULL;\r\n}\r\ninstance->secure_jbod_support =\r\nctrl_info->adapterOperations3.supportSecurityonJBOD;\r\nif (instance->secure_jbod_support)\r\ndev_info(&instance->pdev->dev, "Firmware supports Secure JBOD\n");\r\ninstance->max_sectors_per_req = instance->max_num_sge *\r\nPAGE_SIZE / 512;\r\nif (tmp_sectors && (instance->max_sectors_per_req > tmp_sectors))\r\ninstance->max_sectors_per_req = tmp_sectors;\r\nif (instance->ctrl_context) {\r\ninstance->max_scsi_cmds = instance->max_fw_cmds -\r\n(MEGASAS_FUSION_INTERNAL_CMDS +\r\nMEGASAS_FUSION_IOCTL_CMDS);\r\nsema_init(&instance->ioctl_sem, MEGASAS_FUSION_IOCTL_CMDS);\r\n} else if ((instance->pdev->device == PCI_DEVICE_ID_LSI_SAS0073SKINNY) ||\r\n(instance->pdev->device == PCI_DEVICE_ID_LSI_SAS0071SKINNY)) {\r\ninstance->max_scsi_cmds = instance->max_fw_cmds -\r\nMEGASAS_SKINNY_INT_CMDS;\r\nsema_init(&instance->ioctl_sem, MEGASAS_SKINNY_INT_CMDS);\r\n} else {\r\ninstance->max_scsi_cmds = instance->max_fw_cmds -\r\nMEGASAS_INT_CMDS;\r\nsema_init(&instance->ioctl_sem, (MEGASAS_INT_CMDS - 5));\r\n}\r\nif (throttlequeuedepth &&\r\nthrottlequeuedepth <= instance->max_scsi_cmds)\r\ninstance->throttlequeuedepth = throttlequeuedepth;\r\nelse\r\ninstance->throttlequeuedepth =\r\nMEGASAS_THROTTLE_QUEUE_DEPTH;\r\ntasklet_init(&instance->isr_tasklet, instance->instancet->tasklet,\r\n(unsigned long)instance);\r\nif (instance->requestorId) {\r\nif (!megasas_sriov_start_heartbeat(instance, 1))\r\nmegasas_start_timer(instance,\r\n&instance->sriov_heartbeat_timer,\r\nmegasas_sriov_heartbeat_handler,\r\nMEGASAS_SRIOV_HEARTBEAT_INTERVAL_VF);\r\nelse\r\ninstance->skip_heartbeat_timer_del = 1;\r\n}\r\nreturn 0;\r\nfail_init_adapter:\r\nfail_ready_state:\r\nkfree(instance->ctrl_info);\r\ninstance->ctrl_info = NULL;\r\niounmap(instance->reg_set);\r\nfail_ioremap:\r\npci_release_selected_regions(instance->pdev, instance->bar);\r\nreturn -EINVAL;\r\n}\r\nstatic void megasas_release_mfi(struct megasas_instance *instance)\r\n{\r\nu32 reply_q_sz = sizeof(u32) *(instance->max_mfi_cmds + 1);\r\nif (instance->reply_queue)\r\npci_free_consistent(instance->pdev, reply_q_sz,\r\ninstance->reply_queue, instance->reply_queue_h);\r\nmegasas_free_cmds(instance);\r\niounmap(instance->reg_set);\r\npci_release_selected_regions(instance->pdev, instance->bar);\r\n}\r\nstatic int\r\nmegasas_get_seq_num(struct megasas_instance *instance,\r\nstruct megasas_evt_log_info *eli)\r\n{\r\nstruct megasas_cmd *cmd;\r\nstruct megasas_dcmd_frame *dcmd;\r\nstruct megasas_evt_log_info *el_info;\r\ndma_addr_t el_info_h = 0;\r\ncmd = megasas_get_cmd(instance);\r\nif (!cmd) {\r\nreturn -ENOMEM;\r\n}\r\ndcmd = &cmd->frame->dcmd;\r\nel_info = pci_alloc_consistent(instance->pdev,\r\nsizeof(struct megasas_evt_log_info),\r\n&el_info_h);\r\nif (!el_info) {\r\nmegasas_return_cmd(instance, cmd);\r\nreturn -ENOMEM;\r\n}\r\nmemset(el_info, 0, sizeof(*el_info));\r\nmemset(dcmd->mbox.b, 0, MFI_MBOX_SIZE);\r\ndcmd->cmd = MFI_CMD_DCMD;\r\ndcmd->cmd_status = 0x0;\r\ndcmd->sge_count = 1;\r\ndcmd->flags = cpu_to_le16(MFI_FRAME_DIR_READ);\r\ndcmd->timeout = 0;\r\ndcmd->pad_0 = 0;\r\ndcmd->data_xfer_len = cpu_to_le32(sizeof(struct megasas_evt_log_info));\r\ndcmd->opcode = cpu_to_le32(MR_DCMD_CTRL_EVENT_GET_INFO);\r\ndcmd->sgl.sge32[0].phys_addr = cpu_to_le32(el_info_h);\r\ndcmd->sgl.sge32[0].length = cpu_to_le32(sizeof(struct megasas_evt_log_info));\r\nif (megasas_issue_blocked_cmd(instance, cmd, 30))\r\ndev_err(&instance->pdev->dev, "Command timedout"\r\n"from %s\n", __func__);\r\nelse {\r\neli->newest_seq_num = le32_to_cpu(el_info->newest_seq_num);\r\neli->oldest_seq_num = le32_to_cpu(el_info->oldest_seq_num);\r\neli->clear_seq_num = le32_to_cpu(el_info->clear_seq_num);\r\neli->shutdown_seq_num = le32_to_cpu(el_info->shutdown_seq_num);\r\neli->boot_seq_num = le32_to_cpu(el_info->boot_seq_num);\r\n}\r\npci_free_consistent(instance->pdev, sizeof(struct megasas_evt_log_info),\r\nel_info, el_info_h);\r\nif (instance->ctrl_context && cmd->mpt_pthr_cmd_blocked)\r\nmegasas_return_mfi_mpt_pthr(instance, cmd,\r\ncmd->mpt_pthr_cmd_blocked);\r\nelse\r\nmegasas_return_cmd(instance, cmd);\r\nreturn 0;\r\n}\r\nstatic int\r\nmegasas_register_aen(struct megasas_instance *instance, u32 seq_num,\r\nu32 class_locale_word)\r\n{\r\nint ret_val;\r\nstruct megasas_cmd *cmd;\r\nstruct megasas_dcmd_frame *dcmd;\r\nunion megasas_evt_class_locale curr_aen;\r\nunion megasas_evt_class_locale prev_aen;\r\ncurr_aen.word = class_locale_word;\r\nif (instance->aen_cmd) {\r\nprev_aen.word = instance->aen_cmd->frame->dcmd.mbox.w[1];\r\nprev_aen.members.locale = le16_to_cpu(prev_aen.members.locale);\r\nif ((prev_aen.members.class <= curr_aen.members.class) &&\r\n!((prev_aen.members.locale & curr_aen.members.locale) ^\r\ncurr_aen.members.locale)) {\r\nreturn 0;\r\n} else {\r\ncurr_aen.members.locale |= prev_aen.members.locale;\r\nif (prev_aen.members.class < curr_aen.members.class)\r\ncurr_aen.members.class = prev_aen.members.class;\r\ninstance->aen_cmd->abort_aen = 1;\r\nret_val = megasas_issue_blocked_abort_cmd(instance,\r\ninstance->\r\naen_cmd, 30);\r\nif (ret_val) {\r\nprintk(KERN_DEBUG "megasas: Failed to abort "\r\n"previous AEN command\n");\r\nreturn ret_val;\r\n}\r\n}\r\n}\r\ncmd = megasas_get_cmd(instance);\r\nif (!cmd)\r\nreturn -ENOMEM;\r\ndcmd = &cmd->frame->dcmd;\r\nmemset(instance->evt_detail, 0, sizeof(struct megasas_evt_detail));\r\nmemset(dcmd->mbox.b, 0, MFI_MBOX_SIZE);\r\ndcmd->cmd = MFI_CMD_DCMD;\r\ndcmd->cmd_status = 0x0;\r\ndcmd->sge_count = 1;\r\ndcmd->flags = cpu_to_le16(MFI_FRAME_DIR_READ);\r\ndcmd->timeout = 0;\r\ndcmd->pad_0 = 0;\r\ndcmd->data_xfer_len = cpu_to_le32(sizeof(struct megasas_evt_detail));\r\ndcmd->opcode = cpu_to_le32(MR_DCMD_CTRL_EVENT_WAIT);\r\ndcmd->mbox.w[0] = cpu_to_le32(seq_num);\r\ninstance->last_seq_num = seq_num;\r\ndcmd->mbox.w[1] = cpu_to_le32(curr_aen.word);\r\ndcmd->sgl.sge32[0].phys_addr = cpu_to_le32(instance->evt_detail_h);\r\ndcmd->sgl.sge32[0].length = cpu_to_le32(sizeof(struct megasas_evt_detail));\r\nif (instance->aen_cmd != NULL) {\r\nmegasas_return_cmd(instance, cmd);\r\nreturn 0;\r\n}\r\ninstance->aen_cmd = cmd;\r\ninstance->instancet->issue_dcmd(instance, cmd);\r\nreturn 0;\r\n}\r\nstatic int megasas_start_aen(struct megasas_instance *instance)\r\n{\r\nstruct megasas_evt_log_info eli;\r\nunion megasas_evt_class_locale class_locale;\r\nmemset(&eli, 0, sizeof(eli));\r\nif (megasas_get_seq_num(instance, &eli))\r\nreturn -1;\r\nclass_locale.members.reserved = 0;\r\nclass_locale.members.locale = MR_EVT_LOCALE_ALL;\r\nclass_locale.members.class = MR_EVT_CLASS_DEBUG;\r\nreturn megasas_register_aen(instance,\r\neli.newest_seq_num + 1,\r\nclass_locale.word);\r\n}\r\nstatic int megasas_io_attach(struct megasas_instance *instance)\r\n{\r\nstruct Scsi_Host *host = instance->host;\r\nhost->irq = instance->pdev->irq;\r\nhost->unique_id = instance->unique_id;\r\nhost->can_queue = instance->max_scsi_cmds;\r\nhost->this_id = instance->init_id;\r\nhost->sg_tablesize = instance->max_num_sge;\r\nif (instance->fw_support_ieee)\r\ninstance->max_sectors_per_req = MEGASAS_MAX_SECTORS_IEEE;\r\nif (max_sectors && max_sectors < instance->max_sectors_per_req)\r\ninstance->max_sectors_per_req = max_sectors;\r\nelse {\r\nif (max_sectors) {\r\nif (((instance->pdev->device ==\r\nPCI_DEVICE_ID_LSI_SAS1078GEN2) ||\r\n(instance->pdev->device ==\r\nPCI_DEVICE_ID_LSI_SAS0079GEN2)) &&\r\n(max_sectors <= MEGASAS_MAX_SECTORS)) {\r\ninstance->max_sectors_per_req = max_sectors;\r\n} else {\r\nprintk(KERN_INFO "megasas: max_sectors should be > 0"\r\n"and <= %d (or < 1MB for GEN2 controller)\n",\r\ninstance->max_sectors_per_req);\r\n}\r\n}\r\n}\r\nhost->max_sectors = instance->max_sectors_per_req;\r\nhost->cmd_per_lun = MEGASAS_DEFAULT_CMD_PER_LUN;\r\nhost->max_channel = MEGASAS_MAX_CHANNELS - 1;\r\nhost->max_id = MEGASAS_MAX_DEV_PER_CHANNEL;\r\nhost->max_lun = MEGASAS_MAX_LUN;\r\nhost->max_cmd_len = 16;\r\nif ((instance->pdev->device == PCI_DEVICE_ID_LSI_FUSION) ||\r\n(instance->pdev->device == PCI_DEVICE_ID_LSI_PLASMA) ||\r\n(instance->pdev->device == PCI_DEVICE_ID_LSI_INVADER) ||\r\n(instance->pdev->device == PCI_DEVICE_ID_LSI_FURY)) {\r\nhost->hostt->eh_device_reset_handler = NULL;\r\nhost->hostt->eh_bus_reset_handler = NULL;\r\n}\r\nif (scsi_add_host(host, &instance->pdev->dev)) {\r\nprintk(KERN_DEBUG "megasas: scsi_add_host failed\n");\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nmegasas_set_dma_mask(struct pci_dev *pdev)\r\n{\r\nif (IS_DMA64) {\r\nif (pci_set_dma_mask(pdev, DMA_BIT_MASK(64)) != 0) {\r\nif (pci_set_dma_mask(pdev, DMA_BIT_MASK(32)) != 0)\r\ngoto fail_set_dma_mask;\r\n}\r\n} else {\r\nif (pci_set_dma_mask(pdev, DMA_BIT_MASK(32)) != 0)\r\ngoto fail_set_dma_mask;\r\n}\r\nif (pci_set_consistent_dma_mask(pdev, DMA_BIT_MASK(32)) != 0) {\r\nif (!pci_set_dma_mask(pdev, DMA_BIT_MASK(32))\r\n&& !pci_set_consistent_dma_mask(pdev, DMA_BIT_MASK(32)))\r\ndev_info(&pdev->dev, "set 32bit DMA mask"\r\n"and 32 bit consistent mask\n");\r\nelse\r\ngoto fail_set_dma_mask;\r\n}\r\nreturn 0;\r\nfail_set_dma_mask:\r\nreturn 1;\r\n}\r\nstatic int megasas_probe_one(struct pci_dev *pdev,\r\nconst struct pci_device_id *id)\r\n{\r\nint rval, pos, i, j, cpu;\r\nstruct Scsi_Host *host;\r\nstruct megasas_instance *instance;\r\nu16 control = 0;\r\nstruct fusion_context *fusion = NULL;\r\nif (reset_devices) {\r\npos = pci_find_capability(pdev, PCI_CAP_ID_MSIX);\r\nif (pos) {\r\npci_read_config_word(pdev, pos + PCI_MSIX_FLAGS,\r\n&control);\r\nif (control & PCI_MSIX_FLAGS_ENABLE) {\r\ndev_info(&pdev->dev, "resetting MSI-X\n");\r\npci_write_config_word(pdev,\r\npos + PCI_MSIX_FLAGS,\r\ncontrol &\r\n~PCI_MSIX_FLAGS_ENABLE);\r\n}\r\n}\r\n}\r\nprintk(KERN_INFO "megasas: %#4.04x:%#4.04x:%#4.04x:%#4.04x: ",\r\npdev->vendor, pdev->device, pdev->subsystem_vendor,\r\npdev->subsystem_device);\r\nprintk("bus %d:slot %d:func %d\n",\r\npdev->bus->number, PCI_SLOT(pdev->devfn), PCI_FUNC(pdev->devfn));\r\nrval = pci_enable_device_mem(pdev);\r\nif (rval) {\r\nreturn rval;\r\n}\r\npci_set_master(pdev);\r\nif (megasas_set_dma_mask(pdev))\r\ngoto fail_set_dma_mask;\r\nhost = scsi_host_alloc(&megasas_template,\r\nsizeof(struct megasas_instance));\r\nif (!host) {\r\nprintk(KERN_DEBUG "megasas: scsi_host_alloc failed\n");\r\ngoto fail_alloc_instance;\r\n}\r\ninstance = (struct megasas_instance *)host->hostdata;\r\nmemset(instance, 0, sizeof(*instance));\r\natomic_set( &instance->fw_reset_no_pci_access, 0 );\r\ninstance->pdev = pdev;\r\nswitch (instance->pdev->device) {\r\ncase PCI_DEVICE_ID_LSI_FUSION:\r\ncase PCI_DEVICE_ID_LSI_PLASMA:\r\ncase PCI_DEVICE_ID_LSI_INVADER:\r\ncase PCI_DEVICE_ID_LSI_FURY:\r\n{\r\ninstance->ctrl_context_pages =\r\nget_order(sizeof(struct fusion_context));\r\ninstance->ctrl_context = (void *)__get_free_pages(GFP_KERNEL,\r\ninstance->ctrl_context_pages);\r\nif (!instance->ctrl_context) {\r\nprintk(KERN_DEBUG "megasas: Failed to allocate "\r\n"memory for Fusion context info\n");\r\ngoto fail_alloc_dma_buf;\r\n}\r\nfusion = instance->ctrl_context;\r\nmemset(fusion, 0,\r\n((1 << PAGE_SHIFT) << instance->ctrl_context_pages));\r\nINIT_LIST_HEAD(&fusion->cmd_pool);\r\nspin_lock_init(&fusion->mpt_pool_lock);\r\n}\r\nbreak;\r\ndefault:\r\ninstance->producer =\r\npci_alloc_consistent(pdev, sizeof(u32),\r\n&instance->producer_h);\r\ninstance->consumer =\r\npci_alloc_consistent(pdev, sizeof(u32),\r\n&instance->consumer_h);\r\nif (!instance->producer || !instance->consumer) {\r\nprintk(KERN_DEBUG "megasas: Failed to allocate"\r\n"memory for producer, consumer\n");\r\ngoto fail_alloc_dma_buf;\r\n}\r\n*instance->producer = 0;\r\n*instance->consumer = 0;\r\nbreak;\r\n}\r\ninstance->drv_buf_index = 0;\r\ninstance->drv_buf_alloc = 0;\r\ninstance->crash_dump_fw_support = 0;\r\ninstance->crash_dump_app_support = 0;\r\ninstance->fw_crash_state = UNAVAILABLE;\r\nspin_lock_init(&instance->crashdump_lock);\r\ninstance->crash_dump_buf = NULL;\r\nif (!reset_devices)\r\ninstance->crash_dump_buf = pci_alloc_consistent(pdev,\r\nCRASH_DMA_BUF_SIZE,\r\n&instance->crash_dump_h);\r\nif (!instance->crash_dump_buf)\r\ndev_err(&instance->pdev->dev, "Can't allocate Firmware "\r\n"crash dump DMA buffer\n");\r\nmegasas_poll_wait_aen = 0;\r\ninstance->flag_ieee = 0;\r\ninstance->ev = NULL;\r\ninstance->issuepend_done = 1;\r\ninstance->adprecovery = MEGASAS_HBA_OPERATIONAL;\r\ninstance->is_imr = 0;\r\ninstance->evt_detail = pci_alloc_consistent(pdev,\r\nsizeof(struct\r\nmegasas_evt_detail),\r\n&instance->evt_detail_h);\r\nif (!instance->evt_detail) {\r\nprintk(KERN_DEBUG "megasas: Failed to allocate memory for "\r\n"event detail structure\n");\r\ngoto fail_alloc_dma_buf;\r\n}\r\nINIT_LIST_HEAD(&instance->cmd_pool);\r\nINIT_LIST_HEAD(&instance->internal_reset_pending_q);\r\natomic_set(&instance->fw_outstanding,0);\r\ninit_waitqueue_head(&instance->int_cmd_wait_q);\r\ninit_waitqueue_head(&instance->abort_cmd_wait_q);\r\nspin_lock_init(&instance->mfi_pool_lock);\r\nspin_lock_init(&instance->hba_lock);\r\nspin_lock_init(&instance->completion_lock);\r\nmutex_init(&instance->aen_mutex);\r\nmutex_init(&instance->reset_mutex);\r\ninstance->host = host;\r\ninstance->unique_id = pdev->bus->number << 8 | pdev->devfn;\r\ninstance->init_id = MEGASAS_DEFAULT_INIT_ID;\r\ninstance->ctrl_info = NULL;\r\nif ((instance->pdev->device == PCI_DEVICE_ID_LSI_SAS0073SKINNY) ||\r\n(instance->pdev->device == PCI_DEVICE_ID_LSI_SAS0071SKINNY))\r\ninstance->flag_ieee = 1;\r\nmegasas_dbg_lvl = 0;\r\ninstance->flag = 0;\r\ninstance->unload = 1;\r\ninstance->last_time = 0;\r\ninstance->disableOnlineCtrlReset = 1;\r\ninstance->UnevenSpanSupport = 0;\r\nif ((instance->pdev->device == PCI_DEVICE_ID_LSI_FUSION) ||\r\n(instance->pdev->device == PCI_DEVICE_ID_LSI_PLASMA) ||\r\n(instance->pdev->device == PCI_DEVICE_ID_LSI_INVADER) ||\r\n(instance->pdev->device == PCI_DEVICE_ID_LSI_FURY)) {\r\nINIT_WORK(&instance->work_init, megasas_fusion_ocr_wq);\r\nINIT_WORK(&instance->crash_init, megasas_fusion_crash_dump_wq);\r\n} else\r\nINIT_WORK(&instance->work_init, process_fw_state_change_wq);\r\nif (megasas_init_fw(instance))\r\ngoto fail_init_mfi;\r\nif (instance->requestorId) {\r\nif (instance->PlasmaFW111) {\r\ninstance->vf_affiliation_111 =\r\npci_alloc_consistent(pdev, sizeof(struct MR_LD_VF_AFFILIATION_111),\r\n&instance->vf_affiliation_111_h);\r\nif (!instance->vf_affiliation_111)\r\nprintk(KERN_WARNING "megasas: Can't allocate "\r\n"memory for VF affiliation buffer\n");\r\n} else {\r\ninstance->vf_affiliation =\r\npci_alloc_consistent(pdev,\r\n(MAX_LOGICAL_DRIVES + 1) *\r\nsizeof(struct MR_LD_VF_AFFILIATION),\r\n&instance->vf_affiliation_h);\r\nif (!instance->vf_affiliation)\r\nprintk(KERN_WARNING "megasas: Can't allocate "\r\n"memory for VF affiliation buffer\n");\r\n}\r\n}\r\nretry_irq_register:\r\nif (instance->msix_vectors) {\r\ncpu = cpumask_first(cpu_online_mask);\r\nfor (i = 0; i < instance->msix_vectors; i++) {\r\ninstance->irq_context[i].instance = instance;\r\ninstance->irq_context[i].MSIxIndex = i;\r\nif (request_irq(instance->msixentry[i].vector,\r\ninstance->instancet->service_isr, 0,\r\n"megasas",\r\n&instance->irq_context[i])) {\r\nprintk(KERN_DEBUG "megasas: Failed to "\r\n"register IRQ for vector %d.\n", i);\r\nfor (j = 0; j < i; j++) {\r\nif (smp_affinity_enable)\r\nirq_set_affinity_hint(\r\ninstance->msixentry[j].vector, NULL);\r\nfree_irq(\r\ninstance->msixentry[j].vector,\r\n&instance->irq_context[j]);\r\n}\r\ninstance->msix_vectors = 0;\r\ngoto retry_irq_register;\r\n}\r\nif (smp_affinity_enable) {\r\nif (irq_set_affinity_hint(instance->msixentry[i].vector,\r\nget_cpu_mask(cpu)))\r\ndev_err(&instance->pdev->dev,\r\n"Error setting affinity hint "\r\n"for cpu %d\n", cpu);\r\ncpu = cpumask_next(cpu, cpu_online_mask);\r\n}\r\n}\r\n} else {\r\ninstance->irq_context[0].instance = instance;\r\ninstance->irq_context[0].MSIxIndex = 0;\r\nif (request_irq(pdev->irq, instance->instancet->service_isr,\r\nIRQF_SHARED, "megasas",\r\n&instance->irq_context[0])) {\r\nprintk(KERN_DEBUG "megasas: Failed to register IRQ\n");\r\ngoto fail_irq;\r\n}\r\n}\r\ninstance->instancet->enable_intr(instance);\r\npci_set_drvdata(pdev, instance);\r\nmegasas_mgmt_info.count++;\r\nmegasas_mgmt_info.instance[megasas_mgmt_info.max_index] = instance;\r\nmegasas_mgmt_info.max_index++;\r\nif (megasas_io_attach(instance))\r\ngoto fail_io_attach;\r\ninstance->unload = 0;\r\nscsi_scan_host(host);\r\nif (megasas_start_aen(instance)) {\r\nprintk(KERN_DEBUG "megasas: start aen failed\n");\r\ngoto fail_start_aen;\r\n}\r\nif (instance->requestorId)\r\nmegasas_get_ld_vf_affiliation(instance, 1);\r\nreturn 0;\r\nfail_start_aen:\r\nfail_io_attach:\r\nmegasas_mgmt_info.count--;\r\nmegasas_mgmt_info.instance[megasas_mgmt_info.max_index] = NULL;\r\nmegasas_mgmt_info.max_index--;\r\ninstance->instancet->disable_intr(instance);\r\nif (instance->msix_vectors)\r\nfor (i = 0; i < instance->msix_vectors; i++) {\r\nif (smp_affinity_enable)\r\nirq_set_affinity_hint(\r\ninstance->msixentry[i].vector, NULL);\r\nfree_irq(instance->msixentry[i].vector,\r\n&instance->irq_context[i]);\r\n}\r\nelse\r\nfree_irq(instance->pdev->irq, &instance->irq_context[0]);\r\nfail_irq:\r\nif ((instance->pdev->device == PCI_DEVICE_ID_LSI_FUSION) ||\r\n(instance->pdev->device == PCI_DEVICE_ID_LSI_PLASMA) ||\r\n(instance->pdev->device == PCI_DEVICE_ID_LSI_INVADER) ||\r\n(instance->pdev->device == PCI_DEVICE_ID_LSI_FURY))\r\nmegasas_release_fusion(instance);\r\nelse\r\nmegasas_release_mfi(instance);\r\nfail_init_mfi:\r\nif (instance->msix_vectors)\r\npci_disable_msix(instance->pdev);\r\nfail_alloc_dma_buf:\r\nif (instance->evt_detail)\r\npci_free_consistent(pdev, sizeof(struct megasas_evt_detail),\r\ninstance->evt_detail,\r\ninstance->evt_detail_h);\r\nif (instance->producer)\r\npci_free_consistent(pdev, sizeof(u32), instance->producer,\r\ninstance->producer_h);\r\nif (instance->consumer)\r\npci_free_consistent(pdev, sizeof(u32), instance->consumer,\r\ninstance->consumer_h);\r\nscsi_host_put(host);\r\nfail_alloc_instance:\r\nfail_set_dma_mask:\r\npci_disable_device(pdev);\r\nreturn -ENODEV;\r\n}\r\nstatic void megasas_flush_cache(struct megasas_instance *instance)\r\n{\r\nstruct megasas_cmd *cmd;\r\nstruct megasas_dcmd_frame *dcmd;\r\nif (instance->adprecovery == MEGASAS_HW_CRITICAL_ERROR)\r\nreturn;\r\ncmd = megasas_get_cmd(instance);\r\nif (!cmd)\r\nreturn;\r\ndcmd = &cmd->frame->dcmd;\r\nmemset(dcmd->mbox.b, 0, MFI_MBOX_SIZE);\r\ndcmd->cmd = MFI_CMD_DCMD;\r\ndcmd->cmd_status = 0x0;\r\ndcmd->sge_count = 0;\r\ndcmd->flags = cpu_to_le16(MFI_FRAME_DIR_NONE);\r\ndcmd->timeout = 0;\r\ndcmd->pad_0 = 0;\r\ndcmd->data_xfer_len = 0;\r\ndcmd->opcode = cpu_to_le32(MR_DCMD_CTRL_CACHE_FLUSH);\r\ndcmd->mbox.b[0] = MR_FLUSH_CTRL_CACHE | MR_FLUSH_DISK_CACHE;\r\nif (megasas_issue_blocked_cmd(instance, cmd, 30))\r\ndev_err(&instance->pdev->dev, "Command timedout"\r\n" from %s\n", __func__);\r\nif (instance->ctrl_context && cmd->mpt_pthr_cmd_blocked)\r\nmegasas_return_mfi_mpt_pthr(instance, cmd,\r\ncmd->mpt_pthr_cmd_blocked);\r\nelse\r\nmegasas_return_cmd(instance, cmd);\r\nreturn;\r\n}\r\nstatic void megasas_shutdown_controller(struct megasas_instance *instance,\r\nu32 opcode)\r\n{\r\nstruct megasas_cmd *cmd;\r\nstruct megasas_dcmd_frame *dcmd;\r\nif (instance->adprecovery == MEGASAS_HW_CRITICAL_ERROR)\r\nreturn;\r\ncmd = megasas_get_cmd(instance);\r\nif (!cmd)\r\nreturn;\r\nif (instance->aen_cmd)\r\nmegasas_issue_blocked_abort_cmd(instance,\r\ninstance->aen_cmd, 30);\r\nif (instance->map_update_cmd)\r\nmegasas_issue_blocked_abort_cmd(instance,\r\ninstance->map_update_cmd, 30);\r\ndcmd = &cmd->frame->dcmd;\r\nmemset(dcmd->mbox.b, 0, MFI_MBOX_SIZE);\r\ndcmd->cmd = MFI_CMD_DCMD;\r\ndcmd->cmd_status = 0x0;\r\ndcmd->sge_count = 0;\r\ndcmd->flags = cpu_to_le16(MFI_FRAME_DIR_NONE);\r\ndcmd->timeout = 0;\r\ndcmd->pad_0 = 0;\r\ndcmd->data_xfer_len = 0;\r\ndcmd->opcode = cpu_to_le32(opcode);\r\nif (megasas_issue_blocked_cmd(instance, cmd, 30))\r\ndev_err(&instance->pdev->dev, "Command timedout"\r\n"from %s\n", __func__);\r\nif (instance->ctrl_context && cmd->mpt_pthr_cmd_blocked)\r\nmegasas_return_mfi_mpt_pthr(instance, cmd,\r\ncmd->mpt_pthr_cmd_blocked);\r\nelse\r\nmegasas_return_cmd(instance, cmd);\r\nreturn;\r\n}\r\nstatic int\r\nmegasas_suspend(struct pci_dev *pdev, pm_message_t state)\r\n{\r\nstruct Scsi_Host *host;\r\nstruct megasas_instance *instance;\r\nint i;\r\ninstance = pci_get_drvdata(pdev);\r\nhost = instance->host;\r\ninstance->unload = 1;\r\nif (instance->requestorId && !instance->skip_heartbeat_timer_del)\r\ndel_timer_sync(&instance->sriov_heartbeat_timer);\r\nmegasas_flush_cache(instance);\r\nmegasas_shutdown_controller(instance, MR_DCMD_HIBERNATE_SHUTDOWN);\r\nif (instance->ev != NULL) {\r\nstruct megasas_aen_event *ev = instance->ev;\r\ncancel_delayed_work_sync(&ev->hotplug_work);\r\ninstance->ev = NULL;\r\n}\r\ntasklet_kill(&instance->isr_tasklet);\r\npci_set_drvdata(instance->pdev, instance);\r\ninstance->instancet->disable_intr(instance);\r\nif (instance->msix_vectors)\r\nfor (i = 0; i < instance->msix_vectors; i++) {\r\nif (smp_affinity_enable)\r\nirq_set_affinity_hint(\r\ninstance->msixentry[i].vector, NULL);\r\nfree_irq(instance->msixentry[i].vector,\r\n&instance->irq_context[i]);\r\n}\r\nelse\r\nfree_irq(instance->pdev->irq, &instance->irq_context[0]);\r\nif (instance->msix_vectors)\r\npci_disable_msix(instance->pdev);\r\npci_save_state(pdev);\r\npci_disable_device(pdev);\r\npci_set_power_state(pdev, pci_choose_state(pdev, state));\r\nreturn 0;\r\n}\r\nstatic int\r\nmegasas_resume(struct pci_dev *pdev)\r\n{\r\nint rval, i, j, cpu;\r\nstruct Scsi_Host *host;\r\nstruct megasas_instance *instance;\r\ninstance = pci_get_drvdata(pdev);\r\nhost = instance->host;\r\npci_set_power_state(pdev, PCI_D0);\r\npci_enable_wake(pdev, PCI_D0, 0);\r\npci_restore_state(pdev);\r\nrval = pci_enable_device_mem(pdev);\r\nif (rval) {\r\nprintk(KERN_ERR "megasas: Enable device failed\n");\r\nreturn rval;\r\n}\r\npci_set_master(pdev);\r\nif (megasas_set_dma_mask(pdev))\r\ngoto fail_set_dma_mask;\r\natomic_set(&instance->fw_outstanding, 0);\r\nif (megasas_transition_to_ready(instance, 0))\r\ngoto fail_ready_state;\r\nif (instance->msix_vectors &&\r\npci_enable_msix_exact(instance->pdev, instance->msixentry,\r\ninstance->msix_vectors))\r\ngoto fail_reenable_msix;\r\nswitch (instance->pdev->device) {\r\ncase PCI_DEVICE_ID_LSI_FUSION:\r\ncase PCI_DEVICE_ID_LSI_PLASMA:\r\ncase PCI_DEVICE_ID_LSI_INVADER:\r\ncase PCI_DEVICE_ID_LSI_FURY:\r\n{\r\nmegasas_reset_reply_desc(instance);\r\nif (megasas_ioc_init_fusion(instance)) {\r\nmegasas_free_cmds(instance);\r\nmegasas_free_cmds_fusion(instance);\r\ngoto fail_init_mfi;\r\n}\r\nif (!megasas_get_map_info(instance))\r\nmegasas_sync_map_info(instance);\r\n}\r\nbreak;\r\ndefault:\r\n*instance->producer = 0;\r\n*instance->consumer = 0;\r\nif (megasas_issue_init_mfi(instance))\r\ngoto fail_init_mfi;\r\nbreak;\r\n}\r\ntasklet_init(&instance->isr_tasklet, instance->instancet->tasklet,\r\n(unsigned long)instance);\r\nif (instance->msix_vectors) {\r\ncpu = cpumask_first(cpu_online_mask);\r\nfor (i = 0 ; i < instance->msix_vectors; i++) {\r\ninstance->irq_context[i].instance = instance;\r\ninstance->irq_context[i].MSIxIndex = i;\r\nif (request_irq(instance->msixentry[i].vector,\r\ninstance->instancet->service_isr, 0,\r\n"megasas",\r\n&instance->irq_context[i])) {\r\nprintk(KERN_DEBUG "megasas: Failed to "\r\n"register IRQ for vector %d.\n", i);\r\nfor (j = 0; j < i; j++) {\r\nif (smp_affinity_enable)\r\nirq_set_affinity_hint(\r\ninstance->msixentry[j].vector, NULL);\r\nfree_irq(\r\ninstance->msixentry[j].vector,\r\n&instance->irq_context[j]);\r\n}\r\ngoto fail_irq;\r\n}\r\nif (smp_affinity_enable) {\r\nif (irq_set_affinity_hint(instance->msixentry[i].vector,\r\nget_cpu_mask(cpu)))\r\ndev_err(&instance->pdev->dev, "Error "\r\n"setting affinity hint for cpu "\r\n"%d\n", cpu);\r\ncpu = cpumask_next(cpu, cpu_online_mask);\r\n}\r\n}\r\n} else {\r\ninstance->irq_context[0].instance = instance;\r\ninstance->irq_context[0].MSIxIndex = 0;\r\nif (request_irq(pdev->irq, instance->instancet->service_isr,\r\nIRQF_SHARED, "megasas",\r\n&instance->irq_context[0])) {\r\nprintk(KERN_DEBUG "megasas: Failed to register IRQ\n");\r\ngoto fail_irq;\r\n}\r\n}\r\nif (instance->requestorId) {\r\nif (!megasas_sriov_start_heartbeat(instance, 0))\r\nmegasas_start_timer(instance,\r\n&instance->sriov_heartbeat_timer,\r\nmegasas_sriov_heartbeat_handler,\r\nMEGASAS_SRIOV_HEARTBEAT_INTERVAL_VF);\r\nelse\r\ninstance->skip_heartbeat_timer_del = 1;\r\n}\r\ninstance->instancet->enable_intr(instance);\r\ninstance->unload = 0;\r\nif (megasas_start_aen(instance))\r\nprintk(KERN_ERR "megasas: Start AEN failed\n");\r\nreturn 0;\r\nfail_irq:\r\nfail_init_mfi:\r\nif (instance->evt_detail)\r\npci_free_consistent(pdev, sizeof(struct megasas_evt_detail),\r\ninstance->evt_detail,\r\ninstance->evt_detail_h);\r\nif (instance->producer)\r\npci_free_consistent(pdev, sizeof(u32), instance->producer,\r\ninstance->producer_h);\r\nif (instance->consumer)\r\npci_free_consistent(pdev, sizeof(u32), instance->consumer,\r\ninstance->consumer_h);\r\nscsi_host_put(host);\r\nfail_set_dma_mask:\r\nfail_ready_state:\r\nfail_reenable_msix:\r\npci_disable_device(pdev);\r\nreturn -ENODEV;\r\n}\r\nstatic void megasas_detach_one(struct pci_dev *pdev)\r\n{\r\nint i;\r\nstruct Scsi_Host *host;\r\nstruct megasas_instance *instance;\r\nstruct fusion_context *fusion;\r\ninstance = pci_get_drvdata(pdev);\r\ninstance->unload = 1;\r\nhost = instance->host;\r\nfusion = instance->ctrl_context;\r\nif (instance->requestorId && !instance->skip_heartbeat_timer_del)\r\ndel_timer_sync(&instance->sriov_heartbeat_timer);\r\nif (instance->fw_crash_state != UNAVAILABLE)\r\nmegasas_free_host_crash_buffer(instance);\r\nscsi_remove_host(instance->host);\r\nmegasas_flush_cache(instance);\r\nmegasas_shutdown_controller(instance, MR_DCMD_CTRL_SHUTDOWN);\r\nif (instance->ev != NULL) {\r\nstruct megasas_aen_event *ev = instance->ev;\r\ncancel_delayed_work_sync(&ev->hotplug_work);\r\ninstance->ev = NULL;\r\n}\r\nwake_up_all(&instance->int_cmd_wait_q);\r\ntasklet_kill(&instance->isr_tasklet);\r\nfor (i = 0; i < megasas_mgmt_info.max_index; i++) {\r\nif (megasas_mgmt_info.instance[i] == instance) {\r\nmegasas_mgmt_info.count--;\r\nmegasas_mgmt_info.instance[i] = NULL;\r\nbreak;\r\n}\r\n}\r\ninstance->instancet->disable_intr(instance);\r\nif (instance->msix_vectors)\r\nfor (i = 0; i < instance->msix_vectors; i++) {\r\nif (smp_affinity_enable)\r\nirq_set_affinity_hint(\r\ninstance->msixentry[i].vector, NULL);\r\nfree_irq(instance->msixentry[i].vector,\r\n&instance->irq_context[i]);\r\n}\r\nelse\r\nfree_irq(instance->pdev->irq, &instance->irq_context[0]);\r\nif (instance->msix_vectors)\r\npci_disable_msix(instance->pdev);\r\nswitch (instance->pdev->device) {\r\ncase PCI_DEVICE_ID_LSI_FUSION:\r\ncase PCI_DEVICE_ID_LSI_PLASMA:\r\ncase PCI_DEVICE_ID_LSI_INVADER:\r\ncase PCI_DEVICE_ID_LSI_FURY:\r\nmegasas_release_fusion(instance);\r\nfor (i = 0; i < 2 ; i++) {\r\nif (fusion->ld_map[i])\r\ndma_free_coherent(&instance->pdev->dev,\r\nfusion->max_map_sz,\r\nfusion->ld_map[i],\r\nfusion->ld_map_phys[i]);\r\nif (fusion->ld_drv_map[i])\r\nfree_pages((ulong)fusion->ld_drv_map[i],\r\nfusion->drv_map_pages);\r\n}\r\nfree_pages((ulong)instance->ctrl_context,\r\ninstance->ctrl_context_pages);\r\nbreak;\r\ndefault:\r\nmegasas_release_mfi(instance);\r\npci_free_consistent(pdev, sizeof(u32),\r\ninstance->producer,\r\ninstance->producer_h);\r\npci_free_consistent(pdev, sizeof(u32),\r\ninstance->consumer,\r\ninstance->consumer_h);\r\nbreak;\r\n}\r\nkfree(instance->ctrl_info);\r\nif (instance->evt_detail)\r\npci_free_consistent(pdev, sizeof(struct megasas_evt_detail),\r\ninstance->evt_detail, instance->evt_detail_h);\r\nif (instance->vf_affiliation)\r\npci_free_consistent(pdev, (MAX_LOGICAL_DRIVES + 1) *\r\nsizeof(struct MR_LD_VF_AFFILIATION),\r\ninstance->vf_affiliation,\r\ninstance->vf_affiliation_h);\r\nif (instance->vf_affiliation_111)\r\npci_free_consistent(pdev,\r\nsizeof(struct MR_LD_VF_AFFILIATION_111),\r\ninstance->vf_affiliation_111,\r\ninstance->vf_affiliation_111_h);\r\nif (instance->hb_host_mem)\r\npci_free_consistent(pdev, sizeof(struct MR_CTRL_HB_HOST_MEM),\r\ninstance->hb_host_mem,\r\ninstance->hb_host_mem_h);\r\nif (instance->crash_dump_buf)\r\npci_free_consistent(pdev, CRASH_DMA_BUF_SIZE,\r\ninstance->crash_dump_buf, instance->crash_dump_h);\r\nscsi_host_put(host);\r\npci_disable_device(pdev);\r\nreturn;\r\n}\r\nstatic void megasas_shutdown(struct pci_dev *pdev)\r\n{\r\nint i;\r\nstruct megasas_instance *instance = pci_get_drvdata(pdev);\r\ninstance->unload = 1;\r\nmegasas_flush_cache(instance);\r\nmegasas_shutdown_controller(instance, MR_DCMD_CTRL_SHUTDOWN);\r\ninstance->instancet->disable_intr(instance);\r\nif (instance->msix_vectors)\r\nfor (i = 0; i < instance->msix_vectors; i++) {\r\nif (smp_affinity_enable)\r\nirq_set_affinity_hint(\r\ninstance->msixentry[i].vector, NULL);\r\nfree_irq(instance->msixentry[i].vector,\r\n&instance->irq_context[i]);\r\n}\r\nelse\r\nfree_irq(instance->pdev->irq, &instance->irq_context[0]);\r\nif (instance->msix_vectors)\r\npci_disable_msix(instance->pdev);\r\n}\r\nstatic int megasas_mgmt_open(struct inode *inode, struct file *filep)\r\n{\r\nif (!capable(CAP_SYS_ADMIN))\r\nreturn -EACCES;\r\nreturn 0;\r\n}\r\nstatic int megasas_mgmt_fasync(int fd, struct file *filep, int mode)\r\n{\r\nint rc;\r\nmutex_lock(&megasas_async_queue_mutex);\r\nrc = fasync_helper(fd, filep, mode, &megasas_async_queue);\r\nmutex_unlock(&megasas_async_queue_mutex);\r\nif (rc >= 0) {\r\nfilep->private_data = filep;\r\nreturn 0;\r\n}\r\nprintk(KERN_DEBUG "megasas: fasync_helper failed [%d]\n", rc);\r\nreturn rc;\r\n}\r\nstatic unsigned int megasas_mgmt_poll(struct file *file, poll_table *wait)\r\n{\r\nunsigned int mask;\r\nunsigned long flags;\r\npoll_wait(file, &megasas_poll_wait, wait);\r\nspin_lock_irqsave(&poll_aen_lock, flags);\r\nif (megasas_poll_wait_aen)\r\nmask = (POLLIN | POLLRDNORM);\r\nelse\r\nmask = 0;\r\nmegasas_poll_wait_aen = 0;\r\nspin_unlock_irqrestore(&poll_aen_lock, flags);\r\nreturn mask;\r\n}\r\nstatic int megasas_set_crash_dump_params_ioctl(\r\nstruct megasas_cmd *cmd)\r\n{\r\nstruct megasas_instance *local_instance;\r\nint i, error = 0;\r\nint crash_support;\r\ncrash_support = cmd->frame->dcmd.mbox.w[0];\r\nfor (i = 0; i < megasas_mgmt_info.max_index; i++) {\r\nlocal_instance = megasas_mgmt_info.instance[i];\r\nif (local_instance && local_instance->crash_dump_drv_support) {\r\nif ((local_instance->adprecovery ==\r\nMEGASAS_HBA_OPERATIONAL) &&\r\n!megasas_set_crash_dump_params(local_instance,\r\ncrash_support)) {\r\nlocal_instance->crash_dump_app_support =\r\ncrash_support;\r\ndev_info(&local_instance->pdev->dev,\r\n"Application firmware crash "\r\n"dump mode set success\n");\r\nerror = 0;\r\n} else {\r\ndev_info(&local_instance->pdev->dev,\r\n"Application firmware crash "\r\n"dump mode set failed\n");\r\nerror = -1;\r\n}\r\n}\r\n}\r\nreturn error;\r\n}\r\nstatic int\r\nmegasas_mgmt_fw_ioctl(struct megasas_instance *instance,\r\nstruct megasas_iocpacket __user * user_ioc,\r\nstruct megasas_iocpacket *ioc)\r\n{\r\nstruct megasas_sge32 *kern_sge32;\r\nstruct megasas_cmd *cmd;\r\nvoid *kbuff_arr[MAX_IOCTL_SGE];\r\ndma_addr_t buf_handle = 0;\r\nint error = 0, i;\r\nvoid *sense = NULL;\r\ndma_addr_t sense_handle;\r\nunsigned long *sense_ptr;\r\nmemset(kbuff_arr, 0, sizeof(kbuff_arr));\r\nif (ioc->sge_count > MAX_IOCTL_SGE) {\r\nprintk(KERN_DEBUG "megasas: SGE count [%d] > max limit [%d]\n",\r\nioc->sge_count, MAX_IOCTL_SGE);\r\nreturn -EINVAL;\r\n}\r\ncmd = megasas_get_cmd(instance);\r\nif (!cmd) {\r\nprintk(KERN_DEBUG "megasas: Failed to get a cmd packet\n");\r\nreturn -ENOMEM;\r\n}\r\nmemcpy(cmd->frame, ioc->frame.raw, 2 * MEGAMFI_FRAME_SIZE);\r\ncmd->frame->hdr.context = cpu_to_le32(cmd->index);\r\ncmd->frame->hdr.pad_0 = 0;\r\ncmd->frame->hdr.flags &= cpu_to_le16(~(MFI_FRAME_IEEE |\r\nMFI_FRAME_SGL64 |\r\nMFI_FRAME_SENSE64));\r\nif (cmd->frame->dcmd.opcode == MR_DRIVER_SET_APP_CRASHDUMP_MODE) {\r\nerror = megasas_set_crash_dump_params_ioctl(cmd);\r\nmegasas_return_cmd(instance, cmd);\r\nreturn error;\r\n}\r\nkern_sge32 = (struct megasas_sge32 *)\r\n((unsigned long)cmd->frame + ioc->sgl_off);\r\nfor (i = 0; i < ioc->sge_count; i++) {\r\nif (!ioc->sgl[i].iov_len)\r\ncontinue;\r\nkbuff_arr[i] = dma_alloc_coherent(&instance->pdev->dev,\r\nioc->sgl[i].iov_len,\r\n&buf_handle, GFP_KERNEL);\r\nif (!kbuff_arr[i]) {\r\nprintk(KERN_DEBUG "megasas: Failed to alloc "\r\n"kernel SGL buffer for IOCTL \n");\r\nerror = -ENOMEM;\r\ngoto out;\r\n}\r\nkern_sge32[i].phys_addr = cpu_to_le32(buf_handle);\r\nkern_sge32[i].length = cpu_to_le32(ioc->sgl[i].iov_len);\r\nif (copy_from_user(kbuff_arr[i], ioc->sgl[i].iov_base,\r\n(u32) (ioc->sgl[i].iov_len))) {\r\nerror = -EFAULT;\r\ngoto out;\r\n}\r\n}\r\nif (ioc->sense_len) {\r\nsense = dma_alloc_coherent(&instance->pdev->dev, ioc->sense_len,\r\n&sense_handle, GFP_KERNEL);\r\nif (!sense) {\r\nerror = -ENOMEM;\r\ngoto out;\r\n}\r\nsense_ptr =\r\n(unsigned long *) ((unsigned long)cmd->frame + ioc->sense_off);\r\n*sense_ptr = cpu_to_le32(sense_handle);\r\n}\r\ncmd->sync_cmd = 1;\r\nmegasas_issue_blocked_cmd(instance, cmd, 0);\r\ncmd->sync_cmd = 0;\r\nif (instance->unload == 1) {\r\ndev_info(&instance->pdev->dev, "Driver unload is in progress "\r\n"don't submit data to application\n");\r\ngoto out;\r\n}\r\nfor (i = 0; i < ioc->sge_count; i++) {\r\nif (copy_to_user(ioc->sgl[i].iov_base, kbuff_arr[i],\r\nioc->sgl[i].iov_len)) {\r\nerror = -EFAULT;\r\ngoto out;\r\n}\r\n}\r\nif (ioc->sense_len) {\r\nsense_ptr = (unsigned long *) ((unsigned long)ioc->frame.raw +\r\nioc->sense_off);\r\nif (copy_to_user((void __user *)((unsigned long)(*sense_ptr)),\r\nsense, ioc->sense_len)) {\r\nprintk(KERN_ERR "megasas: Failed to copy out to user "\r\n"sense data\n");\r\nerror = -EFAULT;\r\ngoto out;\r\n}\r\n}\r\nif (copy_to_user(&user_ioc->frame.hdr.cmd_status,\r\n&cmd->frame->hdr.cmd_status, sizeof(u8))) {\r\nprintk(KERN_DEBUG "megasas: Error copying out cmd_status\n");\r\nerror = -EFAULT;\r\n}\r\nout:\r\nif (sense) {\r\ndma_free_coherent(&instance->pdev->dev, ioc->sense_len,\r\nsense, sense_handle);\r\n}\r\nfor (i = 0; i < ioc->sge_count; i++) {\r\nif (kbuff_arr[i])\r\ndma_free_coherent(&instance->pdev->dev,\r\nle32_to_cpu(kern_sge32[i].length),\r\nkbuff_arr[i],\r\nle32_to_cpu(kern_sge32[i].phys_addr));\r\nkbuff_arr[i] = NULL;\r\n}\r\nif (instance->ctrl_context && cmd->mpt_pthr_cmd_blocked)\r\nmegasas_return_mfi_mpt_pthr(instance, cmd,\r\ncmd->mpt_pthr_cmd_blocked);\r\nelse\r\nmegasas_return_cmd(instance, cmd);\r\nreturn error;\r\n}\r\nstatic int megasas_mgmt_ioctl_fw(struct file *file, unsigned long arg)\r\n{\r\nstruct megasas_iocpacket __user *user_ioc =\r\n(struct megasas_iocpacket __user *)arg;\r\nstruct megasas_iocpacket *ioc;\r\nstruct megasas_instance *instance;\r\nint error;\r\nint i;\r\nunsigned long flags;\r\nu32 wait_time = MEGASAS_RESET_WAIT_TIME;\r\nioc = kmalloc(sizeof(*ioc), GFP_KERNEL);\r\nif (!ioc)\r\nreturn -ENOMEM;\r\nif (copy_from_user(ioc, user_ioc, sizeof(*ioc))) {\r\nerror = -EFAULT;\r\ngoto out_kfree_ioc;\r\n}\r\ninstance = megasas_lookup_instance(ioc->host_no);\r\nif (!instance) {\r\nerror = -ENODEV;\r\ngoto out_kfree_ioc;\r\n}\r\nif (instance->requestorId)\r\nwait_time = MEGASAS_ROUTINE_WAIT_TIME_VF;\r\nif (instance->requestorId && !allow_vf_ioctls) {\r\nerror = -ENODEV;\r\ngoto out_kfree_ioc;\r\n}\r\nif (instance->adprecovery == MEGASAS_HW_CRITICAL_ERROR) {\r\nprintk(KERN_ERR "Controller in crit error\n");\r\nerror = -ENODEV;\r\ngoto out_kfree_ioc;\r\n}\r\nif (instance->unload == 1) {\r\nerror = -ENODEV;\r\ngoto out_kfree_ioc;\r\n}\r\nif (down_interruptible(&instance->ioctl_sem)) {\r\nerror = -ERESTARTSYS;\r\ngoto out_kfree_ioc;\r\n}\r\nfor (i = 0; i < wait_time; i++) {\r\nspin_lock_irqsave(&instance->hba_lock, flags);\r\nif (instance->adprecovery == MEGASAS_HBA_OPERATIONAL) {\r\nspin_unlock_irqrestore(&instance->hba_lock, flags);\r\nbreak;\r\n}\r\nspin_unlock_irqrestore(&instance->hba_lock, flags);\r\nif (!(i % MEGASAS_RESET_NOTICE_INTERVAL)) {\r\nprintk(KERN_NOTICE "megasas: waiting"\r\n"for controller reset to finish\n");\r\n}\r\nmsleep(1000);\r\n}\r\nspin_lock_irqsave(&instance->hba_lock, flags);\r\nif (instance->adprecovery != MEGASAS_HBA_OPERATIONAL) {\r\nspin_unlock_irqrestore(&instance->hba_lock, flags);\r\nprintk(KERN_ERR "megaraid_sas: timed out while"\r\n"waiting for HBA to recover\n");\r\nerror = -ENODEV;\r\ngoto out_up;\r\n}\r\nspin_unlock_irqrestore(&instance->hba_lock, flags);\r\nerror = megasas_mgmt_fw_ioctl(instance, user_ioc, ioc);\r\nout_up:\r\nup(&instance->ioctl_sem);\r\nout_kfree_ioc:\r\nkfree(ioc);\r\nreturn error;\r\n}\r\nstatic int megasas_mgmt_ioctl_aen(struct file *file, unsigned long arg)\r\n{\r\nstruct megasas_instance *instance;\r\nstruct megasas_aen aen;\r\nint error;\r\nint i;\r\nunsigned long flags;\r\nu32 wait_time = MEGASAS_RESET_WAIT_TIME;\r\nif (file->private_data != file) {\r\nprintk(KERN_DEBUG "megasas: fasync_helper was not "\r\n"called first\n");\r\nreturn -EINVAL;\r\n}\r\nif (copy_from_user(&aen, (void __user *)arg, sizeof(aen)))\r\nreturn -EFAULT;\r\ninstance = megasas_lookup_instance(aen.host_no);\r\nif (!instance)\r\nreturn -ENODEV;\r\nif (instance->adprecovery == MEGASAS_HW_CRITICAL_ERROR) {\r\nreturn -ENODEV;\r\n}\r\nif (instance->unload == 1) {\r\nreturn -ENODEV;\r\n}\r\nfor (i = 0; i < wait_time; i++) {\r\nspin_lock_irqsave(&instance->hba_lock, flags);\r\nif (instance->adprecovery == MEGASAS_HBA_OPERATIONAL) {\r\nspin_unlock_irqrestore(&instance->hba_lock,\r\nflags);\r\nbreak;\r\n}\r\nspin_unlock_irqrestore(&instance->hba_lock, flags);\r\nif (!(i % MEGASAS_RESET_NOTICE_INTERVAL)) {\r\nprintk(KERN_NOTICE "megasas: waiting for"\r\n"controller reset to finish\n");\r\n}\r\nmsleep(1000);\r\n}\r\nspin_lock_irqsave(&instance->hba_lock, flags);\r\nif (instance->adprecovery != MEGASAS_HBA_OPERATIONAL) {\r\nspin_unlock_irqrestore(&instance->hba_lock, flags);\r\nprintk(KERN_ERR "megaraid_sas: timed out while waiting"\r\n"for HBA to recover.\n");\r\nreturn -ENODEV;\r\n}\r\nspin_unlock_irqrestore(&instance->hba_lock, flags);\r\nmutex_lock(&instance->aen_mutex);\r\nerror = megasas_register_aen(instance, aen.seq_num,\r\naen.class_locale_word);\r\nmutex_unlock(&instance->aen_mutex);\r\nreturn error;\r\n}\r\nstatic long\r\nmegasas_mgmt_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\r\n{\r\nswitch (cmd) {\r\ncase MEGASAS_IOC_FIRMWARE:\r\nreturn megasas_mgmt_ioctl_fw(file, arg);\r\ncase MEGASAS_IOC_GET_AEN:\r\nreturn megasas_mgmt_ioctl_aen(file, arg);\r\n}\r\nreturn -ENOTTY;\r\n}\r\nstatic int megasas_mgmt_compat_ioctl_fw(struct file *file, unsigned long arg)\r\n{\r\nstruct compat_megasas_iocpacket __user *cioc =\r\n(struct compat_megasas_iocpacket __user *)arg;\r\nstruct megasas_iocpacket __user *ioc =\r\ncompat_alloc_user_space(sizeof(struct megasas_iocpacket));\r\nint i;\r\nint error = 0;\r\ncompat_uptr_t ptr;\r\nif (clear_user(ioc, sizeof(*ioc)))\r\nreturn -EFAULT;\r\nif (copy_in_user(&ioc->host_no, &cioc->host_no, sizeof(u16)) ||\r\ncopy_in_user(&ioc->sgl_off, &cioc->sgl_off, sizeof(u32)) ||\r\ncopy_in_user(&ioc->sense_off, &cioc->sense_off, sizeof(u32)) ||\r\ncopy_in_user(&ioc->sense_len, &cioc->sense_len, sizeof(u32)) ||\r\ncopy_in_user(ioc->frame.raw, cioc->frame.raw, 128) ||\r\ncopy_in_user(&ioc->sge_count, &cioc->sge_count, sizeof(u32)))\r\nreturn -EFAULT;\r\nif (ioc->sense_len) {\r\nvoid __user **sense_ioc_ptr =\r\n(void __user **)(ioc->frame.raw + ioc->sense_off);\r\ncompat_uptr_t *sense_cioc_ptr =\r\n(compat_uptr_t *)(cioc->frame.raw + cioc->sense_off);\r\nif (get_user(ptr, sense_cioc_ptr) ||\r\nput_user(compat_ptr(ptr), sense_ioc_ptr))\r\nreturn -EFAULT;\r\n}\r\nfor (i = 0; i < MAX_IOCTL_SGE; i++) {\r\nif (get_user(ptr, &cioc->sgl[i].iov_base) ||\r\nput_user(compat_ptr(ptr), &ioc->sgl[i].iov_base) ||\r\ncopy_in_user(&ioc->sgl[i].iov_len,\r\n&cioc->sgl[i].iov_len, sizeof(compat_size_t)))\r\nreturn -EFAULT;\r\n}\r\nerror = megasas_mgmt_ioctl_fw(file, (unsigned long)ioc);\r\nif (copy_in_user(&cioc->frame.hdr.cmd_status,\r\n&ioc->frame.hdr.cmd_status, sizeof(u8))) {\r\nprintk(KERN_DEBUG "megasas: error copy_in_user cmd_status\n");\r\nreturn -EFAULT;\r\n}\r\nreturn error;\r\n}\r\nstatic long\r\nmegasas_mgmt_compat_ioctl(struct file *file, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\nswitch (cmd) {\r\ncase MEGASAS_IOC_FIRMWARE32:\r\nreturn megasas_mgmt_compat_ioctl_fw(file, arg);\r\ncase MEGASAS_IOC_GET_AEN:\r\nreturn megasas_mgmt_ioctl_aen(file, arg);\r\n}\r\nreturn -ENOTTY;\r\n}\r\nstatic ssize_t megasas_sysfs_show_version(struct device_driver *dd, char *buf)\r\n{\r\nreturn snprintf(buf, strlen(MEGASAS_VERSION) + 2, "%s\n",\r\nMEGASAS_VERSION);\r\n}\r\nstatic ssize_t\r\nmegasas_sysfs_show_support_poll_for_event(struct device_driver *dd, char *buf)\r\n{\r\nreturn sprintf(buf, "%u\n", support_poll_for_event);\r\n}\r\nstatic ssize_t\r\nmegasas_sysfs_show_support_device_change(struct device_driver *dd, char *buf)\r\n{\r\nreturn sprintf(buf, "%u\n", support_device_change);\r\n}\r\nstatic ssize_t\r\nmegasas_sysfs_show_dbg_lvl(struct device_driver *dd, char *buf)\r\n{\r\nreturn sprintf(buf, "%u\n", megasas_dbg_lvl);\r\n}\r\nstatic ssize_t\r\nmegasas_sysfs_set_dbg_lvl(struct device_driver *dd, const char *buf, size_t count)\r\n{\r\nint retval = count;\r\nif(sscanf(buf,"%u",&megasas_dbg_lvl)<1){\r\nprintk(KERN_ERR "megasas: could not set dbg_lvl\n");\r\nretval = -EINVAL;\r\n}\r\nreturn retval;\r\n}\r\nstatic void\r\nmegasas_aen_polling(struct work_struct *work)\r\n{\r\nstruct megasas_aen_event *ev =\r\ncontainer_of(work, struct megasas_aen_event, hotplug_work.work);\r\nstruct megasas_instance *instance = ev->instance;\r\nunion megasas_evt_class_locale class_locale;\r\nstruct Scsi_Host *host;\r\nstruct scsi_device *sdev1;\r\nu16 pd_index = 0;\r\nu16 ld_index = 0;\r\nint i, j, doscan = 0;\r\nu32 seq_num, wait_time = MEGASAS_RESET_WAIT_TIME;\r\nint error;\r\nif (!instance) {\r\nprintk(KERN_ERR "invalid instance!\n");\r\nkfree(ev);\r\nreturn;\r\n}\r\nif (instance->requestorId)\r\nwait_time = MEGASAS_ROUTINE_WAIT_TIME_VF;\r\nfor (i = 0; i < wait_time; i++) {\r\nif (instance->adprecovery == MEGASAS_HBA_OPERATIONAL)\r\nbreak;\r\nif (!(i % MEGASAS_RESET_NOTICE_INTERVAL)) {\r\nprintk(KERN_NOTICE "megasas: %s waiting for "\r\n"controller reset to finish for scsi%d\n",\r\n__func__, instance->host->host_no);\r\n}\r\nmsleep(1000);\r\n}\r\ninstance->ev = NULL;\r\nhost = instance->host;\r\nif (instance->evt_detail) {\r\nswitch (le32_to_cpu(instance->evt_detail->code)) {\r\ncase MR_EVT_PD_INSERTED:\r\nif (megasas_get_pd_list(instance) == 0) {\r\nfor (i = 0; i < MEGASAS_MAX_PD_CHANNELS; i++) {\r\nfor (j = 0;\r\nj < MEGASAS_MAX_DEV_PER_CHANNEL;\r\nj++) {\r\npd_index =\r\n(i * MEGASAS_MAX_DEV_PER_CHANNEL) + j;\r\nsdev1 =\r\nscsi_device_lookup(host, i, j, 0);\r\nif (instance->pd_list[pd_index].driveState\r\n== MR_PD_STATE_SYSTEM) {\r\nif (!sdev1) {\r\nscsi_add_device(host, i, j, 0);\r\n}\r\nif (sdev1)\r\nscsi_device_put(sdev1);\r\n}\r\n}\r\n}\r\n}\r\ndoscan = 0;\r\nbreak;\r\ncase MR_EVT_PD_REMOVED:\r\nif (megasas_get_pd_list(instance) == 0) {\r\nfor (i = 0; i < MEGASAS_MAX_PD_CHANNELS; i++) {\r\nfor (j = 0;\r\nj < MEGASAS_MAX_DEV_PER_CHANNEL;\r\nj++) {\r\npd_index =\r\n(i * MEGASAS_MAX_DEV_PER_CHANNEL) + j;\r\nsdev1 =\r\nscsi_device_lookup(host, i, j, 0);\r\nif (instance->pd_list[pd_index].driveState\r\n== MR_PD_STATE_SYSTEM) {\r\nif (sdev1) {\r\nscsi_device_put(sdev1);\r\n}\r\n} else {\r\nif (sdev1) {\r\nscsi_remove_device(sdev1);\r\nscsi_device_put(sdev1);\r\n}\r\n}\r\n}\r\n}\r\n}\r\ndoscan = 0;\r\nbreak;\r\ncase MR_EVT_LD_OFFLINE:\r\ncase MR_EVT_CFG_CLEARED:\r\ncase MR_EVT_LD_DELETED:\r\nif (!instance->requestorId ||\r\n(instance->requestorId &&\r\nmegasas_get_ld_vf_affiliation(instance, 0))) {\r\nif (megasas_ld_list_query(instance,\r\nMR_LD_QUERY_TYPE_EXPOSED_TO_HOST))\r\nmegasas_get_ld_list(instance);\r\nfor (i = 0; i < MEGASAS_MAX_LD_CHANNELS; i++) {\r\nfor (j = 0;\r\nj < MEGASAS_MAX_DEV_PER_CHANNEL;\r\nj++) {\r\nld_index =\r\n(i * MEGASAS_MAX_DEV_PER_CHANNEL) + j;\r\nsdev1 = scsi_device_lookup(host, MEGASAS_MAX_PD_CHANNELS + i, j, 0);\r\nif (instance->ld_ids[ld_index]\r\n!= 0xff) {\r\nif (sdev1)\r\nscsi_device_put(sdev1);\r\n} else {\r\nif (sdev1) {\r\nscsi_remove_device(sdev1);\r\nscsi_device_put(sdev1);\r\n}\r\n}\r\n}\r\n}\r\ndoscan = 0;\r\n}\r\nbreak;\r\ncase MR_EVT_LD_CREATED:\r\nif (!instance->requestorId ||\r\n(instance->requestorId &&\r\nmegasas_get_ld_vf_affiliation(instance, 0))) {\r\nif (megasas_ld_list_query(instance,\r\nMR_LD_QUERY_TYPE_EXPOSED_TO_HOST))\r\nmegasas_get_ld_list(instance);\r\nfor (i = 0; i < MEGASAS_MAX_LD_CHANNELS; i++) {\r\nfor (j = 0;\r\nj < MEGASAS_MAX_DEV_PER_CHANNEL;\r\nj++) {\r\nld_index =\r\n(i * MEGASAS_MAX_DEV_PER_CHANNEL) + j;\r\nsdev1 = scsi_device_lookup(host, MEGASAS_MAX_PD_CHANNELS + i, j, 0);\r\nif (instance->ld_ids[ld_index]\r\n!= 0xff) {\r\nif (!sdev1)\r\nscsi_add_device(host, MEGASAS_MAX_PD_CHANNELS + i, j, 0);\r\n}\r\nif (sdev1)\r\nscsi_device_put(sdev1);\r\n}\r\n}\r\ndoscan = 0;\r\n}\r\nbreak;\r\ncase MR_EVT_CTRL_HOST_BUS_SCAN_REQUESTED:\r\ncase MR_EVT_FOREIGN_CFG_IMPORTED:\r\ncase MR_EVT_LD_STATE_CHANGE:\r\ndoscan = 1;\r\nbreak;\r\ndefault:\r\ndoscan = 0;\r\nbreak;\r\n}\r\n} else {\r\nprintk(KERN_ERR "invalid evt_detail!\n");\r\nkfree(ev);\r\nreturn;\r\n}\r\nif (doscan) {\r\nprintk(KERN_INFO "megaraid_sas: scanning for scsi%d...\n",\r\ninstance->host->host_no);\r\nif (megasas_get_pd_list(instance) == 0) {\r\nfor (i = 0; i < MEGASAS_MAX_PD_CHANNELS; i++) {\r\nfor (j = 0; j < MEGASAS_MAX_DEV_PER_CHANNEL; j++) {\r\npd_index = i*MEGASAS_MAX_DEV_PER_CHANNEL + j;\r\nsdev1 = scsi_device_lookup(host, i, j, 0);\r\nif (instance->pd_list[pd_index].driveState ==\r\nMR_PD_STATE_SYSTEM) {\r\nif (!sdev1) {\r\nscsi_add_device(host, i, j, 0);\r\n}\r\nif (sdev1)\r\nscsi_device_put(sdev1);\r\n} else {\r\nif (sdev1) {\r\nscsi_remove_device(sdev1);\r\nscsi_device_put(sdev1);\r\n}\r\n}\r\n}\r\n}\r\n}\r\nif (!instance->requestorId ||\r\n(instance->requestorId &&\r\nmegasas_get_ld_vf_affiliation(instance, 0))) {\r\nif (megasas_ld_list_query(instance,\r\nMR_LD_QUERY_TYPE_EXPOSED_TO_HOST))\r\nmegasas_get_ld_list(instance);\r\nfor (i = 0; i < MEGASAS_MAX_LD_CHANNELS; i++) {\r\nfor (j = 0; j < MEGASAS_MAX_DEV_PER_CHANNEL;\r\nj++) {\r\nld_index =\r\n(i * MEGASAS_MAX_DEV_PER_CHANNEL) + j;\r\nsdev1 = scsi_device_lookup(host,\r\nMEGASAS_MAX_PD_CHANNELS + i, j, 0);\r\nif (instance->ld_ids[ld_index]\r\n!= 0xff) {\r\nif (!sdev1)\r\nscsi_add_device(host, MEGASAS_MAX_PD_CHANNELS + i, j, 0);\r\nelse\r\nscsi_device_put(sdev1);\r\n} else {\r\nif (sdev1) {\r\nscsi_remove_device(sdev1);\r\nscsi_device_put(sdev1);\r\n}\r\n}\r\n}\r\n}\r\n}\r\n}\r\nif ( instance->aen_cmd != NULL ) {\r\nkfree(ev);\r\nreturn ;\r\n}\r\nseq_num = le32_to_cpu(instance->evt_detail->seq_num) + 1;\r\nclass_locale.members.reserved = 0;\r\nclass_locale.members.locale = MR_EVT_LOCALE_ALL;\r\nclass_locale.members.class = MR_EVT_CLASS_DEBUG;\r\nmutex_lock(&instance->aen_mutex);\r\nerror = megasas_register_aen(instance, seq_num,\r\nclass_locale.word);\r\nmutex_unlock(&instance->aen_mutex);\r\nif (error)\r\nprintk(KERN_ERR "register aen failed error %x\n", error);\r\nkfree(ev);\r\n}\r\nstatic int __init megasas_init(void)\r\n{\r\nint rval;\r\npr_info("megasas: %s\n", MEGASAS_VERSION);\r\nspin_lock_init(&poll_aen_lock);\r\nsupport_poll_for_event = 2;\r\nsupport_device_change = 1;\r\nmemset(&megasas_mgmt_info, 0, sizeof(megasas_mgmt_info));\r\nrval = register_chrdev(0, "megaraid_sas_ioctl", &megasas_mgmt_fops);\r\nif (rval < 0) {\r\nprintk(KERN_DEBUG "megasas: failed to open device node\n");\r\nreturn rval;\r\n}\r\nmegasas_mgmt_majorno = rval;\r\nrval = pci_register_driver(&megasas_pci_driver);\r\nif (rval) {\r\nprintk(KERN_DEBUG "megasas: PCI hotplug registration failed \n");\r\ngoto err_pcidrv;\r\n}\r\nrval = driver_create_file(&megasas_pci_driver.driver,\r\n&driver_attr_version);\r\nif (rval)\r\ngoto err_dcf_attr_ver;\r\nrval = driver_create_file(&megasas_pci_driver.driver,\r\n&driver_attr_support_poll_for_event);\r\nif (rval)\r\ngoto err_dcf_support_poll_for_event;\r\nrval = driver_create_file(&megasas_pci_driver.driver,\r\n&driver_attr_dbg_lvl);\r\nif (rval)\r\ngoto err_dcf_dbg_lvl;\r\nrval = driver_create_file(&megasas_pci_driver.driver,\r\n&driver_attr_support_device_change);\r\nif (rval)\r\ngoto err_dcf_support_device_change;\r\nreturn rval;\r\nerr_dcf_support_device_change:\r\ndriver_remove_file(&megasas_pci_driver.driver,\r\n&driver_attr_dbg_lvl);\r\nerr_dcf_dbg_lvl:\r\ndriver_remove_file(&megasas_pci_driver.driver,\r\n&driver_attr_support_poll_for_event);\r\nerr_dcf_support_poll_for_event:\r\ndriver_remove_file(&megasas_pci_driver.driver, &driver_attr_version);\r\nerr_dcf_attr_ver:\r\npci_unregister_driver(&megasas_pci_driver);\r\nerr_pcidrv:\r\nunregister_chrdev(megasas_mgmt_majorno, "megaraid_sas_ioctl");\r\nreturn rval;\r\n}\r\nstatic void __exit megasas_exit(void)\r\n{\r\ndriver_remove_file(&megasas_pci_driver.driver,\r\n&driver_attr_dbg_lvl);\r\ndriver_remove_file(&megasas_pci_driver.driver,\r\n&driver_attr_support_poll_for_event);\r\ndriver_remove_file(&megasas_pci_driver.driver,\r\n&driver_attr_support_device_change);\r\ndriver_remove_file(&megasas_pci_driver.driver, &driver_attr_version);\r\npci_unregister_driver(&megasas_pci_driver);\r\nunregister_chrdev(megasas_mgmt_majorno, "megaraid_sas_ioctl");\r\n}
