static inline u8\r\nsnd_nm256_readb(struct nm256 *chip, int offset)\r\n{\r\nreturn readb(chip->cport + offset);\r\n}\r\nstatic inline u16\r\nsnd_nm256_readw(struct nm256 *chip, int offset)\r\n{\r\nreturn readw(chip->cport + offset);\r\n}\r\nstatic inline u32\r\nsnd_nm256_readl(struct nm256 *chip, int offset)\r\n{\r\nreturn readl(chip->cport + offset);\r\n}\r\nstatic inline void\r\nsnd_nm256_writeb(struct nm256 *chip, int offset, u8 val)\r\n{\r\nwriteb(val, chip->cport + offset);\r\n}\r\nstatic inline void\r\nsnd_nm256_writew(struct nm256 *chip, int offset, u16 val)\r\n{\r\nwritew(val, chip->cport + offset);\r\n}\r\nstatic inline void\r\nsnd_nm256_writel(struct nm256 *chip, int offset, u32 val)\r\n{\r\nwritel(val, chip->cport + offset);\r\n}\r\nstatic inline void\r\nsnd_nm256_write_buffer(struct nm256 *chip, void *src, int offset, int size)\r\n{\r\noffset -= chip->buffer_start;\r\n#ifdef CONFIG_SND_DEBUG\r\nif (offset < 0 || offset >= chip->buffer_size) {\r\ndev_err(chip->card->dev,\r\n"write_buffer invalid offset = %d size = %d\n",\r\noffset, size);\r\nreturn;\r\n}\r\n#endif\r\nmemcpy_toio(chip->buffer + offset, src, size);\r\n}\r\nstatic u16\r\nsnd_nm256_get_start_offset(int which)\r\n{\r\nu16 offset = 0;\r\nwhile (which-- > 0)\r\noffset += coefficient_sizes[which];\r\nreturn offset;\r\n}\r\nstatic void\r\nsnd_nm256_load_one_coefficient(struct nm256 *chip, int stream, u32 port, int which)\r\n{\r\nu32 coeff_buf = chip->coeff_buf[stream];\r\nu16 offset = snd_nm256_get_start_offset(which);\r\nu16 size = coefficient_sizes[which];\r\nsnd_nm256_write_buffer(chip, coefficients + offset, coeff_buf, size);\r\nsnd_nm256_writel(chip, port, coeff_buf);\r\nif (stream == SNDRV_PCM_STREAM_PLAYBACK)\r\nsize--;\r\nsnd_nm256_writel(chip, port + 4, coeff_buf + size);\r\n}\r\nstatic void\r\nsnd_nm256_load_coefficient(struct nm256 *chip, int stream, int number)\r\n{\r\nu32 poffset = (stream == SNDRV_PCM_STREAM_CAPTURE ?\r\nNM_RECORD_ENABLE_REG : NM_PLAYBACK_ENABLE_REG);\r\nu32 addr = NM_COEFF_START_OFFSET;\r\naddr += (stream == SNDRV_PCM_STREAM_CAPTURE ?\r\nNM_RECORD_REG_OFFSET : NM_PLAYBACK_REG_OFFSET);\r\nif (snd_nm256_readb(chip, poffset) & 1) {\r\ndev_dbg(chip->card->dev,\r\n"NM256: Engine was enabled while loading coefficients!\n");\r\nreturn;\r\n}\r\nnumber &= 7;\r\nif (stream == SNDRV_PCM_STREAM_CAPTURE)\r\nnumber += 8;\r\nif (! chip->use_cache) {\r\nsnd_nm256_load_one_coefficient(chip, stream, addr, number);\r\nreturn;\r\n}\r\nif (! chip->coeffs_current) {\r\nsnd_nm256_write_buffer(chip, coefficients, chip->all_coeff_buf,\r\nNM_TOTAL_COEFF_COUNT * 4);\r\nchip->coeffs_current = 1;\r\n} else {\r\nu32 base = chip->all_coeff_buf;\r\nu32 offset = snd_nm256_get_start_offset(number);\r\nu32 end_offset = offset + coefficient_sizes[number];\r\nsnd_nm256_writel(chip, addr, base + offset);\r\nif (stream == SNDRV_PCM_STREAM_PLAYBACK)\r\nend_offset--;\r\nsnd_nm256_writel(chip, addr + 4, base + end_offset);\r\n}\r\n}\r\nstatic int\r\nsnd_nm256_fixed_rate(unsigned int rate)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < ARRAY_SIZE(samplerates); i++) {\r\nif (rate == samplerates[i])\r\nreturn i;\r\n}\r\nsnd_BUG();\r\nreturn 0;\r\n}\r\nstatic void\r\nsnd_nm256_set_format(struct nm256 *chip, struct nm256_stream *s,\r\nstruct snd_pcm_substream *substream)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nint rate_index = snd_nm256_fixed_rate(runtime->rate);\r\nunsigned char ratebits = (rate_index << 4) & NM_RATE_MASK;\r\ns->shift = 0;\r\nif (snd_pcm_format_width(runtime->format) == 16) {\r\nratebits |= NM_RATE_BITS_16;\r\ns->shift++;\r\n}\r\nif (runtime->channels > 1) {\r\nratebits |= NM_RATE_STEREO;\r\ns->shift++;\r\n}\r\nruntime->rate = samplerates[rate_index];\r\nswitch (substream->stream) {\r\ncase SNDRV_PCM_STREAM_PLAYBACK:\r\nsnd_nm256_load_coefficient(chip, 0, rate_index);\r\nsnd_nm256_writeb(chip,\r\nNM_PLAYBACK_REG_OFFSET + NM_RATE_REG_OFFSET,\r\nratebits);\r\nbreak;\r\ncase SNDRV_PCM_STREAM_CAPTURE:\r\nsnd_nm256_load_coefficient(chip, 1, rate_index);\r\nsnd_nm256_writeb(chip,\r\nNM_RECORD_REG_OFFSET + NM_RATE_REG_OFFSET,\r\nratebits);\r\nbreak;\r\n}\r\n}\r\nstatic int snd_nm256_acquire_irq(struct nm256 *chip)\r\n{\r\nmutex_lock(&chip->irq_mutex);\r\nif (chip->irq < 0) {\r\nif (request_irq(chip->pci->irq, chip->interrupt, IRQF_SHARED,\r\nKBUILD_MODNAME, chip)) {\r\ndev_err(chip->card->dev,\r\n"unable to grab IRQ %d\n", chip->pci->irq);\r\nmutex_unlock(&chip->irq_mutex);\r\nreturn -EBUSY;\r\n}\r\nchip->irq = chip->pci->irq;\r\n}\r\nchip->irq_acks++;\r\nmutex_unlock(&chip->irq_mutex);\r\nreturn 0;\r\n}\r\nstatic void snd_nm256_release_irq(struct nm256 *chip)\r\n{\r\nmutex_lock(&chip->irq_mutex);\r\nif (chip->irq_acks > 0)\r\nchip->irq_acks--;\r\nif (chip->irq_acks == 0 && chip->irq >= 0) {\r\nfree_irq(chip->irq, chip);\r\nchip->irq = -1;\r\n}\r\nmutex_unlock(&chip->irq_mutex);\r\n}\r\nstatic void snd_nm256_pcm_mark(struct nm256 *chip, struct nm256_stream *s, int reg)\r\n{\r\ns->cur_period++;\r\ns->cur_period %= s->periods;\r\nsnd_nm256_writel(chip, reg, s->buf + s->cur_period * s->period_size);\r\n}\r\nstatic void\r\nsnd_nm256_playback_start(struct nm256 *chip, struct nm256_stream *s,\r\nstruct snd_pcm_substream *substream)\r\n{\r\nsnd_nm256_writel(chip, NM_PBUFFER_START, s->buf);\r\nsnd_nm256_writel(chip, NM_PBUFFER_END, s->buf + s->dma_size - (1 << s->shift));\r\nsnd_nm256_writel(chip, NM_PBUFFER_CURRP, s->buf);\r\nsnd_nm256_playback_mark(chip, s);\r\nsnd_nm256_writeb(chip, NM_PLAYBACK_ENABLE_REG,\r\nNM_PLAYBACK_ENABLE_FLAG | NM_PLAYBACK_FREERUN);\r\nsnd_nm256_writew(chip, NM_AUDIO_MUTE_REG, 0x0);\r\n}\r\nstatic void\r\nsnd_nm256_capture_start(struct nm256 *chip, struct nm256_stream *s,\r\nstruct snd_pcm_substream *substream)\r\n{\r\nsnd_nm256_writel(chip, NM_RBUFFER_START, s->buf);\r\nsnd_nm256_writel(chip, NM_RBUFFER_END, s->buf + s->dma_size);\r\nsnd_nm256_writel(chip, NM_RBUFFER_CURRP, s->buf);\r\nsnd_nm256_capture_mark(chip, s);\r\nsnd_nm256_writeb(chip, NM_RECORD_ENABLE_REG,\r\nNM_RECORD_ENABLE_FLAG | NM_RECORD_FREERUN);\r\n}\r\nstatic void\r\nsnd_nm256_playback_stop(struct nm256 *chip)\r\n{\r\nsnd_nm256_writew(chip, NM_AUDIO_MUTE_REG,\r\nNM_AUDIO_MUTE_LEFT | NM_AUDIO_MUTE_RIGHT);\r\nsnd_nm256_writeb(chip, NM_PLAYBACK_ENABLE_REG, 0);\r\n}\r\nstatic void\r\nsnd_nm256_capture_stop(struct nm256 *chip)\r\n{\r\nsnd_nm256_writeb(chip, NM_RECORD_ENABLE_REG, 0);\r\n}\r\nstatic int\r\nsnd_nm256_playback_trigger(struct snd_pcm_substream *substream, int cmd)\r\n{\r\nstruct nm256 *chip = snd_pcm_substream_chip(substream);\r\nstruct nm256_stream *s = substream->runtime->private_data;\r\nint err = 0;\r\nif (snd_BUG_ON(!s))\r\nreturn -ENXIO;\r\nspin_lock(&chip->reg_lock);\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_RESUME:\r\ns->suspended = 0;\r\ncase SNDRV_PCM_TRIGGER_START:\r\nif (! s->running) {\r\nsnd_nm256_playback_start(chip, s, substream);\r\ns->running = 1;\r\n}\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_SUSPEND:\r\ns->suspended = 1;\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\nif (s->running) {\r\nsnd_nm256_playback_stop(chip);\r\ns->running = 0;\r\n}\r\nbreak;\r\ndefault:\r\nerr = -EINVAL;\r\nbreak;\r\n}\r\nspin_unlock(&chip->reg_lock);\r\nreturn err;\r\n}\r\nstatic int\r\nsnd_nm256_capture_trigger(struct snd_pcm_substream *substream, int cmd)\r\n{\r\nstruct nm256 *chip = snd_pcm_substream_chip(substream);\r\nstruct nm256_stream *s = substream->runtime->private_data;\r\nint err = 0;\r\nif (snd_BUG_ON(!s))\r\nreturn -ENXIO;\r\nspin_lock(&chip->reg_lock);\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\ncase SNDRV_PCM_TRIGGER_RESUME:\r\nif (! s->running) {\r\nsnd_nm256_capture_start(chip, s, substream);\r\ns->running = 1;\r\n}\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\ncase SNDRV_PCM_TRIGGER_SUSPEND:\r\nif (s->running) {\r\nsnd_nm256_capture_stop(chip);\r\ns->running = 0;\r\n}\r\nbreak;\r\ndefault:\r\nerr = -EINVAL;\r\nbreak;\r\n}\r\nspin_unlock(&chip->reg_lock);\r\nreturn err;\r\n}\r\nstatic int snd_nm256_pcm_prepare(struct snd_pcm_substream *substream)\r\n{\r\nstruct nm256 *chip = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct nm256_stream *s = runtime->private_data;\r\nif (snd_BUG_ON(!s))\r\nreturn -ENXIO;\r\ns->dma_size = frames_to_bytes(runtime, substream->runtime->buffer_size);\r\ns->period_size = frames_to_bytes(runtime, substream->runtime->period_size);\r\ns->periods = substream->runtime->periods;\r\ns->cur_period = 0;\r\nspin_lock_irq(&chip->reg_lock);\r\ns->running = 0;\r\nsnd_nm256_set_format(chip, s, substream);\r\nspin_unlock_irq(&chip->reg_lock);\r\nreturn 0;\r\n}\r\nstatic snd_pcm_uframes_t\r\nsnd_nm256_playback_pointer(struct snd_pcm_substream *substream)\r\n{\r\nstruct nm256 *chip = snd_pcm_substream_chip(substream);\r\nstruct nm256_stream *s = substream->runtime->private_data;\r\nunsigned long curp;\r\nif (snd_BUG_ON(!s))\r\nreturn 0;\r\ncurp = snd_nm256_readl(chip, NM_PBUFFER_CURRP) - (unsigned long)s->buf;\r\ncurp %= s->dma_size;\r\nreturn bytes_to_frames(substream->runtime, curp);\r\n}\r\nstatic snd_pcm_uframes_t\r\nsnd_nm256_capture_pointer(struct snd_pcm_substream *substream)\r\n{\r\nstruct nm256 *chip = snd_pcm_substream_chip(substream);\r\nstruct nm256_stream *s = substream->runtime->private_data;\r\nunsigned long curp;\r\nif (snd_BUG_ON(!s))\r\nreturn 0;\r\ncurp = snd_nm256_readl(chip, NM_RBUFFER_CURRP) - (unsigned long)s->buf;\r\ncurp %= s->dma_size;\r\nreturn bytes_to_frames(substream->runtime, curp);\r\n}\r\nstatic int\r\nsnd_nm256_playback_silence(struct snd_pcm_substream *substream,\r\nint channel,\r\nsnd_pcm_uframes_t pos,\r\nsnd_pcm_uframes_t count)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct nm256_stream *s = runtime->private_data;\r\ncount = frames_to_bytes(runtime, count);\r\npos = frames_to_bytes(runtime, pos);\r\nmemset_io(s->bufptr + pos, 0, count);\r\nreturn 0;\r\n}\r\nstatic int\r\nsnd_nm256_playback_copy(struct snd_pcm_substream *substream,\r\nint channel,\r\nsnd_pcm_uframes_t pos,\r\nvoid __user *src,\r\nsnd_pcm_uframes_t count)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct nm256_stream *s = runtime->private_data;\r\ncount = frames_to_bytes(runtime, count);\r\npos = frames_to_bytes(runtime, pos);\r\nif (copy_from_user_toio(s->bufptr + pos, src, count))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int\r\nsnd_nm256_capture_copy(struct snd_pcm_substream *substream,\r\nint channel,\r\nsnd_pcm_uframes_t pos,\r\nvoid __user *dst,\r\nsnd_pcm_uframes_t count)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct nm256_stream *s = runtime->private_data;\r\ncount = frames_to_bytes(runtime, count);\r\npos = frames_to_bytes(runtime, pos);\r\nif (copy_to_user_fromio(dst, s->bufptr + pos, count))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic void\r\nsnd_nm256_playback_update(struct nm256 *chip)\r\n{\r\nstruct nm256_stream *s;\r\ns = &chip->streams[SNDRV_PCM_STREAM_PLAYBACK];\r\nif (s->running && s->substream) {\r\nspin_unlock(&chip->reg_lock);\r\nsnd_pcm_period_elapsed(s->substream);\r\nspin_lock(&chip->reg_lock);\r\nsnd_nm256_playback_mark(chip, s);\r\n}\r\n}\r\nstatic void\r\nsnd_nm256_capture_update(struct nm256 *chip)\r\n{\r\nstruct nm256_stream *s;\r\ns = &chip->streams[SNDRV_PCM_STREAM_CAPTURE];\r\nif (s->running && s->substream) {\r\nspin_unlock(&chip->reg_lock);\r\nsnd_pcm_period_elapsed(s->substream);\r\nspin_lock(&chip->reg_lock);\r\nsnd_nm256_capture_mark(chip, s);\r\n}\r\n}\r\nstatic int snd_nm256_pcm_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *hw_params)\r\n{\r\nsubstream->runtime->dma_bytes = params_buffer_bytes(hw_params);\r\nreturn 0;\r\n}\r\nstatic void snd_nm256_setup_stream(struct nm256 *chip, struct nm256_stream *s,\r\nstruct snd_pcm_substream *substream,\r\nstruct snd_pcm_hardware *hw_ptr)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\ns->running = 0;\r\nruntime->hw = *hw_ptr;\r\nruntime->hw.buffer_bytes_max = s->bufsize;\r\nruntime->hw.period_bytes_max = s->bufsize / 2;\r\nruntime->dma_area = (void __force *) s->bufptr;\r\nruntime->dma_addr = s->bufptr_addr;\r\nruntime->dma_bytes = s->bufsize;\r\nruntime->private_data = s;\r\ns->substream = substream;\r\nsnd_pcm_hw_constraint_list(runtime, 0, SNDRV_PCM_HW_PARAM_RATE,\r\n&constraints_rates);\r\n}\r\nstatic int\r\nsnd_nm256_playback_open(struct snd_pcm_substream *substream)\r\n{\r\nstruct nm256 *chip = snd_pcm_substream_chip(substream);\r\nif (snd_nm256_acquire_irq(chip) < 0)\r\nreturn -EBUSY;\r\nsnd_nm256_setup_stream(chip, &chip->streams[SNDRV_PCM_STREAM_PLAYBACK],\r\nsubstream, &snd_nm256_playback);\r\nreturn 0;\r\n}\r\nstatic int\r\nsnd_nm256_capture_open(struct snd_pcm_substream *substream)\r\n{\r\nstruct nm256 *chip = snd_pcm_substream_chip(substream);\r\nif (snd_nm256_acquire_irq(chip) < 0)\r\nreturn -EBUSY;\r\nsnd_nm256_setup_stream(chip, &chip->streams[SNDRV_PCM_STREAM_CAPTURE],\r\nsubstream, &snd_nm256_capture);\r\nreturn 0;\r\n}\r\nstatic int\r\nsnd_nm256_playback_close(struct snd_pcm_substream *substream)\r\n{\r\nstruct nm256 *chip = snd_pcm_substream_chip(substream);\r\nsnd_nm256_release_irq(chip);\r\nreturn 0;\r\n}\r\nstatic int\r\nsnd_nm256_capture_close(struct snd_pcm_substream *substream)\r\n{\r\nstruct nm256 *chip = snd_pcm_substream_chip(substream);\r\nsnd_nm256_release_irq(chip);\r\nreturn 0;\r\n}\r\nstatic int\r\nsnd_nm256_pcm(struct nm256 *chip, int device)\r\n{\r\nstruct snd_pcm *pcm;\r\nint i, err;\r\nfor (i = 0; i < 2; i++) {\r\nstruct nm256_stream *s = &chip->streams[i];\r\ns->bufptr = chip->buffer + (s->buf - chip->buffer_start);\r\ns->bufptr_addr = chip->buffer_addr + (s->buf - chip->buffer_start);\r\n}\r\nerr = snd_pcm_new(chip->card, chip->card->driver, device,\r\n1, 1, &pcm);\r\nif (err < 0)\r\nreturn err;\r\nsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &snd_nm256_playback_ops);\r\nsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &snd_nm256_capture_ops);\r\npcm->private_data = chip;\r\npcm->info_flags = 0;\r\nchip->pcm = pcm;\r\nreturn 0;\r\n}\r\nstatic void\r\nsnd_nm256_init_chip(struct nm256 *chip)\r\n{\r\nsnd_nm256_writeb(chip, 0x0, 0x11);\r\nsnd_nm256_writew(chip, 0x214, 0);\r\n}\r\nstatic irqreturn_t\r\nsnd_nm256_intr_check(struct nm256 *chip)\r\n{\r\nif (chip->badintrcount++ > 1000) {\r\nif (chip->streams[SNDRV_PCM_STREAM_PLAYBACK].running)\r\nsnd_nm256_playback_stop(chip);\r\nif (chip->streams[SNDRV_PCM_STREAM_CAPTURE].running)\r\nsnd_nm256_capture_stop(chip);\r\nchip->badintrcount = 0;\r\nreturn IRQ_HANDLED;\r\n}\r\nreturn IRQ_NONE;\r\n}\r\nstatic irqreturn_t\r\nsnd_nm256_interrupt(int irq, void *dev_id)\r\n{\r\nstruct nm256 *chip = dev_id;\r\nu16 status;\r\nu8 cbyte;\r\nstatus = snd_nm256_readw(chip, NM_INT_REG);\r\nif (status == 0)\r\nreturn snd_nm256_intr_check(chip);\r\nchip->badintrcount = 0;\r\nspin_lock(&chip->reg_lock);\r\nif (status & NM_PLAYBACK_INT) {\r\nstatus &= ~NM_PLAYBACK_INT;\r\nNM_ACK_INT(chip, NM_PLAYBACK_INT);\r\nsnd_nm256_playback_update(chip);\r\n}\r\nif (status & NM_RECORD_INT) {\r\nstatus &= ~NM_RECORD_INT;\r\nNM_ACK_INT(chip, NM_RECORD_INT);\r\nsnd_nm256_capture_update(chip);\r\n}\r\nif (status & NM_MISC_INT_1) {\r\nstatus &= ~NM_MISC_INT_1;\r\nNM_ACK_INT(chip, NM_MISC_INT_1);\r\ndev_dbg(chip->card->dev, "NM256: Got misc interrupt #1\n");\r\nsnd_nm256_writew(chip, NM_INT_REG, 0x8000);\r\ncbyte = snd_nm256_readb(chip, 0x400);\r\nsnd_nm256_writeb(chip, 0x400, cbyte | 2);\r\n}\r\nif (status & NM_MISC_INT_2) {\r\nstatus &= ~NM_MISC_INT_2;\r\nNM_ACK_INT(chip, NM_MISC_INT_2);\r\ndev_dbg(chip->card->dev, "NM256: Got misc interrupt #2\n");\r\ncbyte = snd_nm256_readb(chip, 0x400);\r\nsnd_nm256_writeb(chip, 0x400, cbyte & ~2);\r\n}\r\nif (status) {\r\ndev_dbg(chip->card->dev,\r\n"NM256: Fire in the hole! Unknown status 0x%x\n",\r\nstatus);\r\nNM_ACK_INT(chip, status);\r\n}\r\nspin_unlock(&chip->reg_lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t\r\nsnd_nm256_interrupt_zx(int irq, void *dev_id)\r\n{\r\nstruct nm256 *chip = dev_id;\r\nu32 status;\r\nu8 cbyte;\r\nstatus = snd_nm256_readl(chip, NM_INT_REG);\r\nif (status == 0)\r\nreturn snd_nm256_intr_check(chip);\r\nchip->badintrcount = 0;\r\nspin_lock(&chip->reg_lock);\r\nif (status & NM2_PLAYBACK_INT) {\r\nstatus &= ~NM2_PLAYBACK_INT;\r\nNM2_ACK_INT(chip, NM2_PLAYBACK_INT);\r\nsnd_nm256_playback_update(chip);\r\n}\r\nif (status & NM2_RECORD_INT) {\r\nstatus &= ~NM2_RECORD_INT;\r\nNM2_ACK_INT(chip, NM2_RECORD_INT);\r\nsnd_nm256_capture_update(chip);\r\n}\r\nif (status & NM2_MISC_INT_1) {\r\nstatus &= ~NM2_MISC_INT_1;\r\nNM2_ACK_INT(chip, NM2_MISC_INT_1);\r\ndev_dbg(chip->card->dev, "NM256: Got misc interrupt #1\n");\r\ncbyte = snd_nm256_readb(chip, 0x400);\r\nsnd_nm256_writeb(chip, 0x400, cbyte | 2);\r\n}\r\nif (status & NM2_MISC_INT_2) {\r\nstatus &= ~NM2_MISC_INT_2;\r\nNM2_ACK_INT(chip, NM2_MISC_INT_2);\r\ndev_dbg(chip->card->dev, "NM256: Got misc interrupt #2\n");\r\ncbyte = snd_nm256_readb(chip, 0x400);\r\nsnd_nm256_writeb(chip, 0x400, cbyte & ~2);\r\n}\r\nif (status) {\r\ndev_dbg(chip->card->dev,\r\n"NM256: Fire in the hole! Unknown status 0x%x\n",\r\nstatus);\r\nNM2_ACK_INT(chip, status);\r\n}\r\nspin_unlock(&chip->reg_lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int\r\nsnd_nm256_ac97_ready(struct nm256 *chip)\r\n{\r\nint timeout = 10;\r\nu32 testaddr;\r\nu16 testb;\r\ntestaddr = chip->mixer_status_offset;\r\ntestb = chip->mixer_status_mask;\r\nwhile (timeout-- > 0) {\r\nif ((snd_nm256_readw(chip, testaddr) & testb) == 0)\r\nreturn 1;\r\nudelay(100);\r\n}\r\nreturn 0;\r\n}\r\nstatic int nm256_ac97_idx(unsigned short reg)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(nm256_ac97_init_val); i++)\r\nif (nm256_ac97_init_val[i].reg == reg)\r\nreturn i;\r\nreturn -1;\r\n}\r\nstatic unsigned short\r\nsnd_nm256_ac97_read(struct snd_ac97 *ac97, unsigned short reg)\r\n{\r\nstruct nm256 *chip = ac97->private_data;\r\nint idx = nm256_ac97_idx(reg);\r\nif (idx < 0)\r\nreturn 0;\r\nreturn chip->ac97_regs[idx];\r\n}\r\nstatic void\r\nsnd_nm256_ac97_write(struct snd_ac97 *ac97,\r\nunsigned short reg, unsigned short val)\r\n{\r\nstruct nm256 *chip = ac97->private_data;\r\nint tries = 2;\r\nint idx = nm256_ac97_idx(reg);\r\nu32 base;\r\nif (idx < 0)\r\nreturn;\r\nbase = chip->mixer_base;\r\nsnd_nm256_ac97_ready(chip);\r\nwhile (tries-- > 0) {\r\nsnd_nm256_writew(chip, base + reg, val);\r\nmsleep(1);\r\nif (snd_nm256_ac97_ready(chip)) {\r\nchip->ac97_regs[idx] = val;\r\nreturn;\r\n}\r\n}\r\ndev_dbg(chip->card->dev, "nm256: ac97 codec not ready..\n");\r\n}\r\nstatic void\r\nsnd_nm256_ac97_reset(struct snd_ac97 *ac97)\r\n{\r\nstruct nm256 *chip = ac97->private_data;\r\nsnd_nm256_writeb(chip, 0x6c0, 1);\r\nif (! chip->reset_workaround) {\r\nsnd_nm256_writeb(chip, 0x6cc, 0x87);\r\n}\r\nif (! chip->reset_workaround_2) {\r\nsnd_nm256_writeb(chip, 0x6cc, 0x80);\r\nsnd_nm256_writeb(chip, 0x6cc, 0x0);\r\n}\r\nif (! chip->in_resume) {\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(nm256_ac97_init_val); i++) {\r\nsnd_nm256_ac97_write(ac97, nm256_ac97_init_val[i].reg,\r\nnm256_ac97_init_val[i].value);\r\n}\r\n}\r\n}\r\nstatic int\r\nsnd_nm256_mixer(struct nm256 *chip)\r\n{\r\nstruct snd_ac97_bus *pbus;\r\nstruct snd_ac97_template ac97;\r\nint err;\r\nstatic struct snd_ac97_bus_ops ops = {\r\n.reset = snd_nm256_ac97_reset,\r\n.write = snd_nm256_ac97_write,\r\n.read = snd_nm256_ac97_read,\r\n};\r\nchip->ac97_regs = kcalloc(ARRAY_SIZE(nm256_ac97_init_val),\r\nsizeof(short), GFP_KERNEL);\r\nif (! chip->ac97_regs)\r\nreturn -ENOMEM;\r\nif ((err = snd_ac97_bus(chip->card, 0, &ops, NULL, &pbus)) < 0)\r\nreturn err;\r\nmemset(&ac97, 0, sizeof(ac97));\r\nac97.scaps = AC97_SCAP_AUDIO;\r\nac97.private_data = chip;\r\nac97.res_table = nm256_res_table;\r\npbus->no_vra = 1;\r\nerr = snd_ac97_mixer(pbus, &ac97, &chip->ac97);\r\nif (err < 0)\r\nreturn err;\r\nif (! (chip->ac97->id & (0xf0000000))) {\r\nsprintf(chip->card->mixername, "%s AC97", chip->card->driver);\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nsnd_nm256_peek_for_sig(struct nm256 *chip)\r\n{\r\nvoid __iomem *temp;\r\nunsigned long pointer_found = chip->buffer_end - 0x1400;\r\nu32 sig;\r\ntemp = ioremap_nocache(chip->buffer_addr + chip->buffer_end - 0x400, 16);\r\nif (temp == NULL) {\r\ndev_err(chip->card->dev,\r\n"Unable to scan for card signature in video RAM\n");\r\nreturn -EBUSY;\r\n}\r\nsig = readl(temp);\r\nif ((sig & NM_SIG_MASK) == NM_SIGNATURE) {\r\nu32 pointer = readl(temp + 4);\r\nif (pointer == 0xffffffff ||\r\npointer < chip->buffer_size ||\r\npointer > chip->buffer_end) {\r\ndev_err(chip->card->dev,\r\n"invalid signature found: 0x%x\n", pointer);\r\niounmap(temp);\r\nreturn -ENODEV;\r\n} else {\r\npointer_found = pointer;\r\ndev_info(chip->card->dev,\r\n"found card signature in video RAM: 0x%x\n",\r\npointer);\r\n}\r\n}\r\niounmap(temp);\r\nchip->buffer_end = pointer_found;\r\nreturn 0;\r\n}\r\nstatic int nm256_suspend(struct device *dev)\r\n{\r\nstruct snd_card *card = dev_get_drvdata(dev);\r\nstruct nm256 *chip = card->private_data;\r\nsnd_power_change_state(card, SNDRV_CTL_POWER_D3hot);\r\nsnd_pcm_suspend_all(chip->pcm);\r\nsnd_ac97_suspend(chip->ac97);\r\nchip->coeffs_current = 0;\r\nreturn 0;\r\n}\r\nstatic int nm256_resume(struct device *dev)\r\n{\r\nstruct snd_card *card = dev_get_drvdata(dev);\r\nstruct nm256 *chip = card->private_data;\r\nint i;\r\nchip->in_resume = 1;\r\nsnd_nm256_init_chip(chip);\r\nsnd_ac97_resume(chip->ac97);\r\nfor (i = 0; i < 2; i++) {\r\nstruct nm256_stream *s = &chip->streams[i];\r\nif (s->substream && s->suspended) {\r\nspin_lock_irq(&chip->reg_lock);\r\nsnd_nm256_set_format(chip, s, s->substream);\r\nspin_unlock_irq(&chip->reg_lock);\r\n}\r\n}\r\nsnd_power_change_state(card, SNDRV_CTL_POWER_D0);\r\nchip->in_resume = 0;\r\nreturn 0;\r\n}\r\nstatic int snd_nm256_free(struct nm256 *chip)\r\n{\r\nif (chip->streams[SNDRV_PCM_STREAM_PLAYBACK].running)\r\nsnd_nm256_playback_stop(chip);\r\nif (chip->streams[SNDRV_PCM_STREAM_CAPTURE].running)\r\nsnd_nm256_capture_stop(chip);\r\nif (chip->irq >= 0)\r\nfree_irq(chip->irq, chip);\r\niounmap(chip->cport);\r\niounmap(chip->buffer);\r\nrelease_and_free_resource(chip->res_cport);\r\nrelease_and_free_resource(chip->res_buffer);\r\npci_disable_device(chip->pci);\r\nkfree(chip->ac97_regs);\r\nkfree(chip);\r\nreturn 0;\r\n}\r\nstatic int snd_nm256_dev_free(struct snd_device *device)\r\n{\r\nstruct nm256 *chip = device->device_data;\r\nreturn snd_nm256_free(chip);\r\n}\r\nstatic int\r\nsnd_nm256_create(struct snd_card *card, struct pci_dev *pci,\r\nstruct nm256 **chip_ret)\r\n{\r\nstruct nm256 *chip;\r\nint err, pval;\r\nstatic struct snd_device_ops ops = {\r\n.dev_free = snd_nm256_dev_free,\r\n};\r\nu32 addr;\r\n*chip_ret = NULL;\r\nif ((err = pci_enable_device(pci)) < 0)\r\nreturn err;\r\nchip = kzalloc(sizeof(*chip), GFP_KERNEL);\r\nif (chip == NULL) {\r\npci_disable_device(pci);\r\nreturn -ENOMEM;\r\n}\r\nchip->card = card;\r\nchip->pci = pci;\r\nchip->use_cache = use_cache;\r\nspin_lock_init(&chip->reg_lock);\r\nchip->irq = -1;\r\nmutex_init(&chip->irq_mutex);\r\nchip->streams[SNDRV_PCM_STREAM_PLAYBACK].bufsize = playback_bufsize * 1024;\r\nchip->streams[SNDRV_PCM_STREAM_CAPTURE].bufsize = capture_bufsize * 1024;\r\nchip->buffer_addr = pci_resource_start(pci, 0);\r\nchip->cport_addr = pci_resource_start(pci, 1);\r\nchip->res_cport = request_mem_region(chip->cport_addr, NM_PORT2_SIZE,\r\ncard->driver);\r\nif (chip->res_cport == NULL) {\r\ndev_err(card->dev, "memory region 0x%lx (size 0x%x) busy\n",\r\nchip->cport_addr, NM_PORT2_SIZE);\r\nerr = -EBUSY;\r\ngoto __error;\r\n}\r\nchip->cport = ioremap_nocache(chip->cport_addr, NM_PORT2_SIZE);\r\nif (chip->cport == NULL) {\r\ndev_err(card->dev, "unable to map control port %lx\n",\r\nchip->cport_addr);\r\nerr = -ENOMEM;\r\ngoto __error;\r\n}\r\nif (!strcmp(card->driver, "NM256AV")) {\r\npval = snd_nm256_readw(chip, NM_MIXER_PRESENCE);\r\nif ((pval & NM_PRESENCE_MASK) != NM_PRESENCE_VALUE) {\r\nif (! force_ac97) {\r\ndev_err(card->dev,\r\n"no ac97 is found!\n");\r\ndev_err(card->dev,\r\n"force the driver to load by passing in the module parameter\n");\r\ndev_err(card->dev,\r\n" force_ac97=1\n");\r\ndev_err(card->dev,\r\n"or try sb16, opl3sa2, or cs423x drivers instead.\n");\r\nerr = -ENXIO;\r\ngoto __error;\r\n}\r\n}\r\nchip->buffer_end = 2560 * 1024;\r\nchip->interrupt = snd_nm256_interrupt;\r\nchip->mixer_status_offset = NM_MIXER_STATUS_OFFSET;\r\nchip->mixer_status_mask = NM_MIXER_READY_MASK;\r\n} else {\r\nif (snd_nm256_readb(chip, 0xa0b) != 0)\r\nchip->buffer_end = 6144 * 1024;\r\nelse\r\nchip->buffer_end = 4096 * 1024;\r\nchip->interrupt = snd_nm256_interrupt_zx;\r\nchip->mixer_status_offset = NM2_MIXER_STATUS_OFFSET;\r\nchip->mixer_status_mask = NM2_MIXER_READY_MASK;\r\n}\r\nchip->buffer_size = chip->streams[SNDRV_PCM_STREAM_PLAYBACK].bufsize +\r\nchip->streams[SNDRV_PCM_STREAM_CAPTURE].bufsize;\r\nif (chip->use_cache)\r\nchip->buffer_size += NM_TOTAL_COEFF_COUNT * 4;\r\nelse\r\nchip->buffer_size += NM_MAX_PLAYBACK_COEF_SIZE + NM_MAX_RECORD_COEF_SIZE;\r\nif (buffer_top >= chip->buffer_size && buffer_top < chip->buffer_end)\r\nchip->buffer_end = buffer_top;\r\nelse {\r\nif ((err = snd_nm256_peek_for_sig(chip)) < 0)\r\ngoto __error;\r\n}\r\nchip->buffer_start = chip->buffer_end - chip->buffer_size;\r\nchip->buffer_addr += chip->buffer_start;\r\ndev_info(card->dev, "Mapping port 1 from 0x%x - 0x%x\n",\r\nchip->buffer_start, chip->buffer_end);\r\nchip->res_buffer = request_mem_region(chip->buffer_addr,\r\nchip->buffer_size,\r\ncard->driver);\r\nif (chip->res_buffer == NULL) {\r\ndev_err(card->dev, "buffer 0x%lx (size 0x%x) busy\n",\r\nchip->buffer_addr, chip->buffer_size);\r\nerr = -EBUSY;\r\ngoto __error;\r\n}\r\nchip->buffer = ioremap_nocache(chip->buffer_addr, chip->buffer_size);\r\nif (chip->buffer == NULL) {\r\nerr = -ENOMEM;\r\ndev_err(card->dev, "unable to map ring buffer at %lx\n",\r\nchip->buffer_addr);\r\ngoto __error;\r\n}\r\naddr = chip->buffer_start;\r\nchip->streams[SNDRV_PCM_STREAM_PLAYBACK].buf = addr;\r\naddr += chip->streams[SNDRV_PCM_STREAM_PLAYBACK].bufsize;\r\nchip->streams[SNDRV_PCM_STREAM_CAPTURE].buf = addr;\r\naddr += chip->streams[SNDRV_PCM_STREAM_CAPTURE].bufsize;\r\nif (chip->use_cache) {\r\nchip->all_coeff_buf = addr;\r\n} else {\r\nchip->coeff_buf[SNDRV_PCM_STREAM_PLAYBACK] = addr;\r\naddr += NM_MAX_PLAYBACK_COEF_SIZE;\r\nchip->coeff_buf[SNDRV_PCM_STREAM_CAPTURE] = addr;\r\n}\r\nchip->mixer_base = NM_MIXER_OFFSET;\r\nchip->coeffs_current = 0;\r\nsnd_nm256_init_chip(chip);\r\nif ((err = snd_device_new(card, SNDRV_DEV_LOWLEVEL, chip, &ops)) < 0)\r\ngoto __error;\r\n*chip_ret = chip;\r\nreturn 0;\r\n__error:\r\nsnd_nm256_free(chip);\r\nreturn err;\r\n}\r\nstatic int snd_nm256_probe(struct pci_dev *pci,\r\nconst struct pci_device_id *pci_id)\r\n{\r\nstruct snd_card *card;\r\nstruct nm256 *chip;\r\nint err;\r\nconst struct snd_pci_quirk *q;\r\nq = snd_pci_quirk_lookup(pci, nm256_quirks);\r\nif (q) {\r\ndev_dbg(&pci->dev, "Enabled quirk for %s.\n",\r\nsnd_pci_quirk_name(q));\r\nswitch (q->value) {\r\ncase NM_BLACKLISTED:\r\ndev_info(&pci->dev,\r\n"The device is blacklisted. Loading stopped\n");\r\nreturn -ENODEV;\r\ncase NM_RESET_WORKAROUND_2:\r\nreset_workaround_2 = 1;\r\ncase NM_RESET_WORKAROUND:\r\nreset_workaround = 1;\r\nbreak;\r\n}\r\n}\r\nerr = snd_card_new(&pci->dev, index, id, THIS_MODULE, 0, &card);\r\nif (err < 0)\r\nreturn err;\r\nswitch (pci->device) {\r\ncase PCI_DEVICE_ID_NEOMAGIC_NM256AV_AUDIO:\r\nstrcpy(card->driver, "NM256AV");\r\nbreak;\r\ncase PCI_DEVICE_ID_NEOMAGIC_NM256ZX_AUDIO:\r\nstrcpy(card->driver, "NM256ZX");\r\nbreak;\r\ncase PCI_DEVICE_ID_NEOMAGIC_NM256XL_PLUS_AUDIO:\r\nstrcpy(card->driver, "NM256XL+");\r\nbreak;\r\ndefault:\r\ndev_err(&pci->dev, "invalid device id 0x%x\n", pci->device);\r\nsnd_card_free(card);\r\nreturn -EINVAL;\r\n}\r\nif (vaio_hack)\r\nbuffer_top = 0x25a800;\r\nif (playback_bufsize < 4)\r\nplayback_bufsize = 4;\r\nif (playback_bufsize > 128)\r\nplayback_bufsize = 128;\r\nif (capture_bufsize < 4)\r\ncapture_bufsize = 4;\r\nif (capture_bufsize > 128)\r\ncapture_bufsize = 128;\r\nif ((err = snd_nm256_create(card, pci, &chip)) < 0) {\r\nsnd_card_free(card);\r\nreturn err;\r\n}\r\ncard->private_data = chip;\r\nif (reset_workaround) {\r\ndev_dbg(&pci->dev, "reset_workaround activated\n");\r\nchip->reset_workaround = 1;\r\n}\r\nif (reset_workaround_2) {\r\ndev_dbg(&pci->dev, "reset_workaround_2 activated\n");\r\nchip->reset_workaround_2 = 1;\r\n}\r\nif ((err = snd_nm256_pcm(chip, 0)) < 0 ||\r\n(err = snd_nm256_mixer(chip)) < 0) {\r\nsnd_card_free(card);\r\nreturn err;\r\n}\r\nsprintf(card->shortname, "NeoMagic %s", card->driver);\r\nsprintf(card->longname, "%s at 0x%lx & 0x%lx, irq %d",\r\ncard->shortname,\r\nchip->buffer_addr, chip->cport_addr, chip->irq);\r\nif ((err = snd_card_register(card)) < 0) {\r\nsnd_card_free(card);\r\nreturn err;\r\n}\r\npci_set_drvdata(pci, card);\r\nreturn 0;\r\n}\r\nstatic void snd_nm256_remove(struct pci_dev *pci)\r\n{\r\nsnd_card_free(pci_get_drvdata(pci));\r\n}
