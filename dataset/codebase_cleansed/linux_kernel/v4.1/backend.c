struct agp_bridge_data *agp_backend_acquire(struct pci_dev *pdev)\r\n{\r\nstruct agp_bridge_data *bridge;\r\nbridge = agp_find_bridge(pdev);\r\nif (!bridge)\r\nreturn NULL;\r\nif (atomic_read(&bridge->agp_in_use))\r\nreturn NULL;\r\natomic_inc(&bridge->agp_in_use);\r\nreturn bridge;\r\n}\r\nvoid agp_backend_release(struct agp_bridge_data *bridge)\r\n{\r\nif (bridge)\r\natomic_dec(&bridge->agp_in_use);\r\n}\r\nstatic int agp_find_max(void)\r\n{\r\nlong memory, index, result;\r\n#if PAGE_SHIFT < 20\r\nmemory = totalram_pages >> (20 - PAGE_SHIFT);\r\n#else\r\nmemory = totalram_pages << (PAGE_SHIFT - 20);\r\n#endif\r\nindex = 1;\r\nwhile ((memory > maxes_table[index].mem) && (index < 8))\r\nindex++;\r\nresult = maxes_table[index - 1].agp +\r\n( (memory - maxes_table[index - 1].mem) *\r\n(maxes_table[index].agp - maxes_table[index - 1].agp)) /\r\n(maxes_table[index].mem - maxes_table[index - 1].mem);\r\nresult = result << (20 - PAGE_SHIFT);\r\nreturn result;\r\n}\r\nstatic int agp_backend_initialize(struct agp_bridge_data *bridge)\r\n{\r\nint size_value, rc, got_gatt=0, got_keylist=0;\r\nbridge->max_memory_agp = agp_find_max();\r\nbridge->version = &agp_current_version;\r\nif (bridge->driver->needs_scratch_page) {\r\nstruct page *page = bridge->driver->agp_alloc_page(bridge);\r\nif (!page) {\r\ndev_err(&bridge->dev->dev,\r\n"can't get memory for scratch page\n");\r\nreturn -ENOMEM;\r\n}\r\nbridge->scratch_page_page = page;\r\nbridge->scratch_page_dma = page_to_phys(page);\r\nbridge->scratch_page = bridge->driver->mask_memory(bridge,\r\nbridge->scratch_page_dma, 0);\r\n}\r\nsize_value = bridge->driver->fetch_size();\r\nif (size_value == 0) {\r\ndev_err(&bridge->dev->dev, "can't determine aperture size\n");\r\nrc = -EINVAL;\r\ngoto err_out;\r\n}\r\nif (bridge->driver->create_gatt_table(bridge)) {\r\ndev_err(&bridge->dev->dev,\r\n"can't get memory for graphics translation table\n");\r\nrc = -ENOMEM;\r\ngoto err_out;\r\n}\r\ngot_gatt = 1;\r\nbridge->key_list = vzalloc(PAGE_SIZE * 4);\r\nif (bridge->key_list == NULL) {\r\ndev_err(&bridge->dev->dev,\r\n"can't allocate memory for key lists\n");\r\nrc = -ENOMEM;\r\ngoto err_out;\r\n}\r\ngot_keylist = 1;\r\nif (bridge->driver->configure()) {\r\ndev_err(&bridge->dev->dev, "error configuring host chipset\n");\r\nrc = -EINVAL;\r\ngoto err_out;\r\n}\r\nINIT_LIST_HEAD(&bridge->mapped_list);\r\nspin_lock_init(&bridge->mapped_lock);\r\nreturn 0;\r\nerr_out:\r\nif (bridge->driver->needs_scratch_page) {\r\nstruct page *page = bridge->scratch_page_page;\r\nbridge->driver->agp_destroy_page(page, AGP_PAGE_DESTROY_UNMAP);\r\nbridge->driver->agp_destroy_page(page, AGP_PAGE_DESTROY_FREE);\r\n}\r\nif (got_gatt)\r\nbridge->driver->free_gatt_table(bridge);\r\nif (got_keylist) {\r\nvfree(bridge->key_list);\r\nbridge->key_list = NULL;\r\n}\r\nreturn rc;\r\n}\r\nstatic void agp_backend_cleanup(struct agp_bridge_data *bridge)\r\n{\r\nif (bridge->driver->cleanup)\r\nbridge->driver->cleanup();\r\nif (bridge->driver->free_gatt_table)\r\nbridge->driver->free_gatt_table(bridge);\r\nvfree(bridge->key_list);\r\nbridge->key_list = NULL;\r\nif (bridge->driver->agp_destroy_page &&\r\nbridge->driver->needs_scratch_page) {\r\nstruct page *page = bridge->scratch_page_page;\r\nbridge->driver->agp_destroy_page(page, AGP_PAGE_DESTROY_UNMAP);\r\nbridge->driver->agp_destroy_page(page, AGP_PAGE_DESTROY_FREE);\r\n}\r\n}\r\nstruct agp_bridge_data *agp_alloc_bridge(void)\r\n{\r\nstruct agp_bridge_data *bridge;\r\nbridge = kzalloc(sizeof(*bridge), GFP_KERNEL);\r\nif (!bridge)\r\nreturn NULL;\r\natomic_set(&bridge->agp_in_use, 0);\r\natomic_set(&bridge->current_memory_agp, 0);\r\nif (list_empty(&agp_bridges))\r\nagp_bridge = bridge;\r\nreturn bridge;\r\n}\r\nvoid agp_put_bridge(struct agp_bridge_data *bridge)\r\n{\r\nkfree(bridge);\r\nif (list_empty(&agp_bridges))\r\nagp_bridge = NULL;\r\n}\r\nint agp_add_bridge(struct agp_bridge_data *bridge)\r\n{\r\nint error;\r\nif (agp_off) {\r\nerror = -ENODEV;\r\ngoto err_put_bridge;\r\n}\r\nif (!bridge->dev) {\r\nprintk (KERN_DEBUG PFX "Erk, registering with no pci_dev!\n");\r\nerror = -EINVAL;\r\ngoto err_put_bridge;\r\n}\r\nif (!try_module_get(bridge->driver->owner)) {\r\ndev_info(&bridge->dev->dev, "can't lock chipset driver\n");\r\nerror = -EINVAL;\r\ngoto err_put_bridge;\r\n}\r\nerror = agp_backend_initialize(bridge);\r\nif (error) {\r\ndev_info(&bridge->dev->dev,\r\n"agp_backend_initialize() failed\n");\r\ngoto err_out;\r\n}\r\nif (list_empty(&agp_bridges)) {\r\nerror = agp_frontend_initialize();\r\nif (error) {\r\ndev_info(&bridge->dev->dev,\r\n"agp_frontend_initialize() failed\n");\r\ngoto frontend_err;\r\n}\r\ndev_info(&bridge->dev->dev, "AGP aperture is %dM @ 0x%lx\n",\r\nbridge->driver->fetch_size(), bridge->gart_bus_addr);\r\n}\r\nlist_add(&bridge->list, &agp_bridges);\r\nreturn 0;\r\nfrontend_err:\r\nagp_backend_cleanup(bridge);\r\nerr_out:\r\nmodule_put(bridge->driver->owner);\r\nerr_put_bridge:\r\nagp_put_bridge(bridge);\r\nreturn error;\r\n}\r\nvoid agp_remove_bridge(struct agp_bridge_data *bridge)\r\n{\r\nagp_backend_cleanup(bridge);\r\nlist_del(&bridge->list);\r\nif (list_empty(&agp_bridges))\r\nagp_frontend_cleanup();\r\nmodule_put(bridge->driver->owner);\r\n}\r\nstatic int __init agp_init(void)\r\n{\r\nif (!agp_off)\r\nprintk(KERN_INFO "Linux agpgart interface v%d.%d\n",\r\nAGPGART_VERSION_MAJOR, AGPGART_VERSION_MINOR);\r\nreturn 0;\r\n}\r\nstatic void __exit agp_exit(void)\r\n{\r\n}\r\nstatic __init int agp_setup(char *s)\r\n{\r\nif (!strcmp(s,"off"))\r\nagp_off = 1;\r\nif (!strcmp(s,"try_unsupported"))\r\nagp_try_unsupported_boot = 1;\r\nreturn 1;\r\n}
