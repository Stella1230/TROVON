static int drm_setup(struct drm_device * dev)\r\n{\r\nint ret;\r\nif (dev->driver->firstopen &&\r\n!drm_core_check_feature(dev, DRIVER_MODESET)) {\r\nret = dev->driver->firstopen(dev);\r\nif (ret != 0)\r\nreturn ret;\r\n}\r\nret = drm_legacy_dma_setup(dev);\r\nif (ret < 0)\r\nreturn ret;\r\nDRM_DEBUG("\n");\r\nreturn 0;\r\n}\r\nint drm_open(struct inode *inode, struct file *filp)\r\n{\r\nstruct drm_device *dev;\r\nstruct drm_minor *minor;\r\nint retcode;\r\nint need_setup = 0;\r\nminor = drm_minor_acquire(iminor(inode));\r\nif (IS_ERR(minor))\r\nreturn PTR_ERR(minor);\r\ndev = minor->dev;\r\nif (!dev->open_count++)\r\nneed_setup = 1;\r\nfilp->f_mapping = dev->anon_inode->i_mapping;\r\nretcode = drm_open_helper(filp, minor);\r\nif (retcode)\r\ngoto err_undo;\r\nif (need_setup) {\r\nretcode = drm_setup(dev);\r\nif (retcode)\r\ngoto err_undo;\r\n}\r\nreturn 0;\r\nerr_undo:\r\ndev->open_count--;\r\ndrm_minor_release(minor);\r\nreturn retcode;\r\n}\r\nstatic int drm_cpu_valid(void)\r\n{\r\n#if defined(__sparc__) && !defined(__sparc_v9__)\r\nreturn 0;\r\n#endif\r\nreturn 1;\r\n}\r\nstatic int drm_open_helper(struct file *filp, struct drm_minor *minor)\r\n{\r\nstruct drm_device *dev = minor->dev;\r\nstruct drm_file *priv;\r\nint ret;\r\nif (filp->f_flags & O_EXCL)\r\nreturn -EBUSY;\r\nif (!drm_cpu_valid())\r\nreturn -EINVAL;\r\nif (dev->switch_power_state != DRM_SWITCH_POWER_ON && dev->switch_power_state != DRM_SWITCH_POWER_DYNAMIC_OFF)\r\nreturn -EINVAL;\r\nDRM_DEBUG("pid = %d, minor = %d\n", task_pid_nr(current), minor->index);\r\npriv = kzalloc(sizeof(*priv), GFP_KERNEL);\r\nif (!priv)\r\nreturn -ENOMEM;\r\nfilp->private_data = priv;\r\npriv->filp = filp;\r\npriv->uid = current_euid();\r\npriv->pid = get_pid(task_pid(current));\r\npriv->minor = minor;\r\npriv->authenticated = capable(CAP_SYS_ADMIN);\r\npriv->lock_count = 0;\r\nINIT_LIST_HEAD(&priv->lhead);\r\nINIT_LIST_HEAD(&priv->fbs);\r\nmutex_init(&priv->fbs_lock);\r\nINIT_LIST_HEAD(&priv->event_list);\r\ninit_waitqueue_head(&priv->event_wait);\r\npriv->event_space = 4096;\r\nif (drm_core_check_feature(dev, DRIVER_GEM))\r\ndrm_gem_open(dev, priv);\r\nif (drm_core_check_feature(dev, DRIVER_PRIME))\r\ndrm_prime_init_file_private(&priv->prime);\r\nif (dev->driver->open) {\r\nret = dev->driver->open(dev, priv);\r\nif (ret < 0)\r\ngoto out_prime_destroy;\r\n}\r\nmutex_lock(&dev->master_mutex);\r\nif (drm_is_primary_client(priv) && !priv->minor->master) {\r\npriv->minor->master = drm_master_create(priv->minor);\r\nif (!priv->minor->master) {\r\nret = -ENOMEM;\r\ngoto out_close;\r\n}\r\npriv->is_master = 1;\r\npriv->master = drm_master_get(priv->minor->master);\r\npriv->authenticated = 1;\r\nif (dev->driver->master_create) {\r\nret = dev->driver->master_create(dev, priv->master);\r\nif (ret) {\r\ndrm_master_put(&priv->minor->master);\r\ndrm_master_put(&priv->master);\r\ngoto out_close;\r\n}\r\n}\r\nif (dev->driver->master_set) {\r\nret = dev->driver->master_set(dev, priv, true);\r\nif (ret) {\r\ndrm_master_put(&priv->minor->master);\r\ndrm_master_put(&priv->master);\r\ngoto out_close;\r\n}\r\n}\r\n} else if (drm_is_primary_client(priv)) {\r\npriv->master = drm_master_get(priv->minor->master);\r\n}\r\nmutex_unlock(&dev->master_mutex);\r\nmutex_lock(&dev->struct_mutex);\r\nlist_add(&priv->lhead, &dev->filelist);\r\nmutex_unlock(&dev->struct_mutex);\r\n#ifdef __alpha__\r\nif (!dev->hose) {\r\nstruct pci_dev *pci_dev;\r\npci_dev = pci_get_class(PCI_CLASS_DISPLAY_VGA << 8, NULL);\r\nif (pci_dev) {\r\ndev->hose = pci_dev->sysdata;\r\npci_dev_put(pci_dev);\r\n}\r\nif (!dev->hose) {\r\nstruct pci_bus *b = list_entry(pci_root_buses.next,\r\nstruct pci_bus, node);\r\nif (b)\r\ndev->hose = b->sysdata;\r\n}\r\n}\r\n#endif\r\nreturn 0;\r\nout_close:\r\nmutex_unlock(&dev->master_mutex);\r\nif (dev->driver->postclose)\r\ndev->driver->postclose(dev, priv);\r\nout_prime_destroy:\r\nif (drm_core_check_feature(dev, DRIVER_PRIME))\r\ndrm_prime_destroy_file_private(&priv->prime);\r\nif (drm_core_check_feature(dev, DRIVER_GEM))\r\ndrm_gem_release(dev, priv);\r\nput_pid(priv->pid);\r\nkfree(priv);\r\nfilp->private_data = NULL;\r\nreturn ret;\r\n}\r\nstatic void drm_master_release(struct drm_device *dev, struct file *filp)\r\n{\r\nstruct drm_file *file_priv = filp->private_data;\r\nif (drm_legacy_i_have_hw_lock(dev, file_priv)) {\r\nDRM_DEBUG("File %p released, freeing lock for context %d\n",\r\nfilp, _DRM_LOCKING_CONTEXT(file_priv->master->lock.hw_lock->lock));\r\ndrm_legacy_lock_free(&file_priv->master->lock,\r\n_DRM_LOCKING_CONTEXT(file_priv->master->lock.hw_lock->lock));\r\n}\r\n}\r\nstatic void drm_events_release(struct drm_file *file_priv)\r\n{\r\nstruct drm_device *dev = file_priv->minor->dev;\r\nstruct drm_pending_event *e, *et;\r\nstruct drm_pending_vblank_event *v, *vt;\r\nunsigned long flags;\r\nspin_lock_irqsave(&dev->event_lock, flags);\r\nlist_for_each_entry_safe(v, vt, &dev->vblank_event_list, base.link)\r\nif (v->base.file_priv == file_priv) {\r\nlist_del(&v->base.link);\r\ndrm_vblank_put(dev, v->pipe);\r\nv->base.destroy(&v->base);\r\n}\r\nlist_for_each_entry_safe(e, et, &file_priv->event_list, link) {\r\nlist_del(&e->link);\r\ne->destroy(e);\r\n}\r\nspin_unlock_irqrestore(&dev->event_lock, flags);\r\n}\r\nstatic void drm_legacy_dev_reinit(struct drm_device *dev)\r\n{\r\nif (drm_core_check_feature(dev, DRIVER_MODESET))\r\nreturn;\r\ndev->sigdata.lock = NULL;\r\ndev->context_flag = 0;\r\ndev->last_context = 0;\r\ndev->if_version = 0;\r\n}\r\nint drm_lastclose(struct drm_device * dev)\r\n{\r\nDRM_DEBUG("\n");\r\nif (dev->driver->lastclose)\r\ndev->driver->lastclose(dev);\r\nDRM_DEBUG("driver lastclose completed\n");\r\nif (dev->irq_enabled && !drm_core_check_feature(dev, DRIVER_MODESET))\r\ndrm_irq_uninstall(dev);\r\nmutex_lock(&dev->struct_mutex);\r\ndrm_agp_clear(dev);\r\ndrm_legacy_sg_cleanup(dev);\r\ndrm_legacy_vma_flush(dev);\r\ndrm_legacy_dma_takedown(dev);\r\nmutex_unlock(&dev->struct_mutex);\r\ndrm_legacy_dev_reinit(dev);\r\nDRM_DEBUG("lastclose completed\n");\r\nreturn 0;\r\n}\r\nint drm_release(struct inode *inode, struct file *filp)\r\n{\r\nstruct drm_file *file_priv = filp->private_data;\r\nstruct drm_minor *minor = file_priv->minor;\r\nstruct drm_device *dev = minor->dev;\r\nint retcode = 0;\r\nmutex_lock(&drm_global_mutex);\r\nDRM_DEBUG("open_count = %d\n", dev->open_count);\r\nmutex_lock(&dev->struct_mutex);\r\nlist_del(&file_priv->lhead);\r\nmutex_unlock(&dev->struct_mutex);\r\nif (dev->driver->preclose)\r\ndev->driver->preclose(dev, file_priv);\r\nDRM_DEBUG("pid = %d, device = 0x%lx, open_count = %d\n",\r\ntask_pid_nr(current),\r\n(long)old_encode_dev(file_priv->minor->kdev->devt),\r\ndev->open_count);\r\nif (file_priv->magic)\r\n(void) drm_remove_magic(file_priv->master, file_priv->magic);\r\nif (file_priv->minor->master)\r\ndrm_master_release(dev, filp);\r\nif (drm_core_check_feature(dev, DRIVER_HAVE_DMA))\r\ndrm_legacy_reclaim_buffers(dev, file_priv);\r\ndrm_events_release(file_priv);\r\nif (drm_core_check_feature(dev, DRIVER_MODESET))\r\ndrm_fb_release(file_priv);\r\nif (drm_core_check_feature(dev, DRIVER_GEM))\r\ndrm_gem_release(dev, file_priv);\r\ndrm_legacy_ctxbitmap_flush(dev, file_priv);\r\nmutex_lock(&dev->master_mutex);\r\nif (file_priv->is_master) {\r\nstruct drm_master *master = file_priv->master;\r\nmutex_lock(&dev->struct_mutex);\r\nif (master->lock.hw_lock) {\r\nif (dev->sigdata.lock == master->lock.hw_lock)\r\ndev->sigdata.lock = NULL;\r\nmaster->lock.hw_lock = NULL;\r\nmaster->lock.file_priv = NULL;\r\nwake_up_interruptible_all(&master->lock.lock_queue);\r\n}\r\nmutex_unlock(&dev->struct_mutex);\r\nif (file_priv->minor->master == file_priv->master) {\r\nif (dev->driver->master_drop)\r\ndev->driver->master_drop(dev, file_priv, true);\r\ndrm_master_put(&file_priv->minor->master);\r\n}\r\n}\r\nif (file_priv->master)\r\ndrm_master_put(&file_priv->master);\r\nfile_priv->is_master = 0;\r\nmutex_unlock(&dev->master_mutex);\r\nif (dev->driver->postclose)\r\ndev->driver->postclose(dev, file_priv);\r\nif (drm_core_check_feature(dev, DRIVER_PRIME))\r\ndrm_prime_destroy_file_private(&file_priv->prime);\r\nWARN_ON(!list_empty(&file_priv->event_list));\r\nput_pid(file_priv->pid);\r\nkfree(file_priv);\r\nif (!--dev->open_count) {\r\nretcode = drm_lastclose(dev);\r\nif (drm_device_is_unplugged(dev))\r\ndrm_put_dev(dev);\r\n}\r\nmutex_unlock(&drm_global_mutex);\r\ndrm_minor_release(minor);\r\nreturn retcode;\r\n}\r\nssize_t drm_read(struct file *filp, char __user *buffer,\r\nsize_t count, loff_t *offset)\r\n{\r\nstruct drm_file *file_priv = filp->private_data;\r\nstruct drm_device *dev = file_priv->minor->dev;\r\nssize_t ret = 0;\r\nif (!access_ok(VERIFY_WRITE, buffer, count))\r\nreturn -EFAULT;\r\nspin_lock_irq(&dev->event_lock);\r\nfor (;;) {\r\nif (list_empty(&file_priv->event_list)) {\r\nif (ret)\r\nbreak;\r\nif (filp->f_flags & O_NONBLOCK) {\r\nret = -EAGAIN;\r\nbreak;\r\n}\r\nspin_unlock_irq(&dev->event_lock);\r\nret = wait_event_interruptible(file_priv->event_wait,\r\n!list_empty(&file_priv->event_list));\r\nspin_lock_irq(&dev->event_lock);\r\nif (ret < 0)\r\nbreak;\r\nret = 0;\r\n} else {\r\nstruct drm_pending_event *e;\r\ne = list_first_entry(&file_priv->event_list,\r\nstruct drm_pending_event, link);\r\nif (e->event->length + ret > count)\r\nbreak;\r\nif (__copy_to_user_inatomic(buffer + ret,\r\ne->event, e->event->length)) {\r\nif (ret == 0)\r\nret = -EFAULT;\r\nbreak;\r\n}\r\nfile_priv->event_space += e->event->length;\r\nret += e->event->length;\r\nlist_del(&e->link);\r\ne->destroy(e);\r\n}\r\n}\r\nspin_unlock_irq(&dev->event_lock);\r\nreturn ret;\r\n}\r\nunsigned int drm_poll(struct file *filp, struct poll_table_struct *wait)\r\n{\r\nstruct drm_file *file_priv = filp->private_data;\r\nunsigned int mask = 0;\r\npoll_wait(filp, &file_priv->event_wait, wait);\r\nif (!list_empty(&file_priv->event_list))\r\nmask |= POLLIN | POLLRDNORM;\r\nreturn mask;\r\n}
