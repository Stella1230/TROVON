static u64 notrace pxa_read_sched_clock(void)\r\n{\r\nreturn timer_readl(OSCR);\r\n}\r\nstatic irqreturn_t\r\npxa_ost0_interrupt(int irq, void *dev_id)\r\n{\r\nstruct clock_event_device *c = dev_id;\r\ntimer_writel(timer_readl(OIER) & ~OIER_E0, OIER);\r\ntimer_writel(OSSR_M0, OSSR);\r\nc->event_handler(c);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int\r\npxa_osmr0_set_next_event(unsigned long delta, struct clock_event_device *dev)\r\n{\r\nunsigned long next, oscr;\r\ntimer_writel(timer_readl(OIER) | OIER_E0, OIER);\r\nnext = timer_readl(OSCR) + delta;\r\ntimer_writel(next, OSMR0);\r\noscr = timer_readl(OSCR);\r\nreturn (signed)(next - oscr) <= MIN_OSCR_DELTA ? -ETIME : 0;\r\n}\r\nstatic void\r\npxa_osmr0_set_mode(enum clock_event_mode mode, struct clock_event_device *dev)\r\n{\r\nswitch (mode) {\r\ncase CLOCK_EVT_MODE_ONESHOT:\r\ntimer_writel(timer_readl(OIER) & ~OIER_E0, OIER);\r\ntimer_writel(OSSR_M0, OSSR);\r\nbreak;\r\ncase CLOCK_EVT_MODE_UNUSED:\r\ncase CLOCK_EVT_MODE_SHUTDOWN:\r\ntimer_writel(timer_readl(OIER) & ~OIER_E0, OIER);\r\ntimer_writel(OSSR_M0, OSSR);\r\nbreak;\r\ncase CLOCK_EVT_MODE_RESUME:\r\ncase CLOCK_EVT_MODE_PERIODIC:\r\nbreak;\r\n}\r\n}\r\nstatic void pxa_timer_suspend(struct clock_event_device *cedev)\r\n{\r\nosmr[0] = timer_readl(OSMR0);\r\nosmr[1] = timer_readl(OSMR1);\r\nosmr[2] = timer_readl(OSMR2);\r\nosmr[3] = timer_readl(OSMR3);\r\noier = timer_readl(OIER);\r\noscr = timer_readl(OSCR);\r\n}\r\nstatic void pxa_timer_resume(struct clock_event_device *cedev)\r\n{\r\nif (osmr[0] - oscr < MIN_OSCR_DELTA)\r\nosmr[0] += MIN_OSCR_DELTA;\r\ntimer_writel(osmr[0], OSMR0);\r\ntimer_writel(osmr[1], OSMR1);\r\ntimer_writel(osmr[2], OSMR2);\r\ntimer_writel(osmr[3], OSMR3);\r\ntimer_writel(oier, OIER);\r\ntimer_writel(oscr, OSCR);\r\n}\r\nstatic void __init pxa_timer_common_init(int irq, unsigned long clock_tick_rate)\r\n{\r\ntimer_writel(0, OIER);\r\ntimer_writel(OSSR_M0 | OSSR_M1 | OSSR_M2 | OSSR_M3, OSSR);\r\nsched_clock_register(pxa_read_sched_clock, 32, clock_tick_rate);\r\nckevt_pxa_osmr0.cpumask = cpumask_of(0);\r\nsetup_irq(irq, &pxa_ost0_irq);\r\nclocksource_mmio_init(timer_base + OSCR, "oscr0", clock_tick_rate, 200,\r\n32, clocksource_mmio_readl_up);\r\nclockevents_config_and_register(&ckevt_pxa_osmr0, clock_tick_rate,\r\nMIN_OSCR_DELTA * 2, 0x7fffffff);\r\n}\r\nstatic void __init pxa_timer_dt_init(struct device_node *np)\r\n{\r\nstruct clk *clk;\r\nint irq;\r\ntimer_base = of_iomap(np, 0);\r\nif (!timer_base)\r\npanic("%s: unable to map resource\n", np->name);\r\nclk = of_clk_get(np, 0);\r\nif (IS_ERR(clk)) {\r\npr_crit("%s: unable to get clk\n", np->name);\r\nreturn;\r\n}\r\nclk_prepare_enable(clk);\r\nirq = irq_of_parse_and_map(np, 0);\r\nif (irq <= 0) {\r\npr_crit("%s: unable to parse OS-timer0 irq\n", np->name);\r\nreturn;\r\n}\r\npxa_timer_common_init(irq, clk_get_rate(clk));\r\n}\r\nvoid __init pxa_timer_nodt_init(int irq, void __iomem *base,\r\nunsigned long clock_tick_rate)\r\n{\r\nstruct clk *clk;\r\ntimer_base = base;\r\nclk = clk_get(NULL, "OSTIMER0");\r\nif (clk && !IS_ERR(clk))\r\nclk_prepare_enable(clk);\r\nelse\r\npr_crit("%s: unable to get clk\n", __func__);\r\npxa_timer_common_init(irq, clock_tick_rate);\r\n}
