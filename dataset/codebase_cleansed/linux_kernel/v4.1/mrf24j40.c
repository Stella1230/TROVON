static int write_short_reg(struct mrf24j40 *devrec, u8 reg, u8 value)\r\n{\r\nint ret;\r\nstruct spi_message msg;\r\nstruct spi_transfer xfer = {\r\n.len = 2,\r\n.tx_buf = devrec->buf,\r\n.rx_buf = devrec->buf,\r\n};\r\nspi_message_init(&msg);\r\nspi_message_add_tail(&xfer, &msg);\r\nmutex_lock(&devrec->buffer_mutex);\r\ndevrec->buf[0] = MRF24J40_WRITESHORT(reg);\r\ndevrec->buf[1] = value;\r\nret = spi_sync(devrec->spi, &msg);\r\nif (ret)\r\ndev_err(printdev(devrec),\r\n"SPI write Failed for short register 0x%hhx\n", reg);\r\nmutex_unlock(&devrec->buffer_mutex);\r\nreturn ret;\r\n}\r\nstatic int read_short_reg(struct mrf24j40 *devrec, u8 reg, u8 *val)\r\n{\r\nint ret = -1;\r\nstruct spi_message msg;\r\nstruct spi_transfer xfer = {\r\n.len = 2,\r\n.tx_buf = devrec->buf,\r\n.rx_buf = devrec->buf,\r\n};\r\nspi_message_init(&msg);\r\nspi_message_add_tail(&xfer, &msg);\r\nmutex_lock(&devrec->buffer_mutex);\r\ndevrec->buf[0] = MRF24J40_READSHORT(reg);\r\ndevrec->buf[1] = 0;\r\nret = spi_sync(devrec->spi, &msg);\r\nif (ret)\r\ndev_err(printdev(devrec),\r\n"SPI read Failed for short register 0x%hhx\n", reg);\r\nelse\r\n*val = devrec->buf[1];\r\nmutex_unlock(&devrec->buffer_mutex);\r\nreturn ret;\r\n}\r\nstatic int read_long_reg(struct mrf24j40 *devrec, u16 reg, u8 *value)\r\n{\r\nint ret;\r\nu16 cmd;\r\nstruct spi_message msg;\r\nstruct spi_transfer xfer = {\r\n.len = 3,\r\n.tx_buf = devrec->buf,\r\n.rx_buf = devrec->buf,\r\n};\r\nspi_message_init(&msg);\r\nspi_message_add_tail(&xfer, &msg);\r\ncmd = MRF24J40_READLONG(reg);\r\nmutex_lock(&devrec->buffer_mutex);\r\ndevrec->buf[0] = cmd >> 8 & 0xff;\r\ndevrec->buf[1] = cmd & 0xff;\r\ndevrec->buf[2] = 0;\r\nret = spi_sync(devrec->spi, &msg);\r\nif (ret)\r\ndev_err(printdev(devrec),\r\n"SPI read Failed for long register 0x%hx\n", reg);\r\nelse\r\n*value = devrec->buf[2];\r\nmutex_unlock(&devrec->buffer_mutex);\r\nreturn ret;\r\n}\r\nstatic int write_long_reg(struct mrf24j40 *devrec, u16 reg, u8 val)\r\n{\r\nint ret;\r\nu16 cmd;\r\nstruct spi_message msg;\r\nstruct spi_transfer xfer = {\r\n.len = 3,\r\n.tx_buf = devrec->buf,\r\n.rx_buf = devrec->buf,\r\n};\r\nspi_message_init(&msg);\r\nspi_message_add_tail(&xfer, &msg);\r\ncmd = MRF24J40_WRITELONG(reg);\r\nmutex_lock(&devrec->buffer_mutex);\r\ndevrec->buf[0] = cmd >> 8 & 0xff;\r\ndevrec->buf[1] = cmd & 0xff;\r\ndevrec->buf[2] = val;\r\nret = spi_sync(devrec->spi, &msg);\r\nif (ret)\r\ndev_err(printdev(devrec),\r\n"SPI write Failed for long register 0x%hx\n", reg);\r\nmutex_unlock(&devrec->buffer_mutex);\r\nreturn ret;\r\n}\r\nstatic int write_tx_buf(struct mrf24j40 *devrec, u16 reg,\r\nconst u8 *data, size_t length)\r\n{\r\nint ret;\r\nu16 cmd;\r\nu8 lengths[2];\r\nstruct spi_message msg;\r\nstruct spi_transfer addr_xfer = {\r\n.len = 2,\r\n.tx_buf = devrec->buf,\r\n};\r\nstruct spi_transfer lengths_xfer = {\r\n.len = 2,\r\n.tx_buf = &lengths,\r\n};\r\nstruct spi_transfer data_xfer = {\r\n.len = length,\r\n.tx_buf = data,\r\n};\r\nif (length > TX_FIFO_SIZE-2) {\r\ndev_err(printdev(devrec), "write_tx_buf() was passed too large a buffer. Performing short write.\n");\r\nlength = TX_FIFO_SIZE-2;\r\n}\r\nspi_message_init(&msg);\r\nspi_message_add_tail(&addr_xfer, &msg);\r\nspi_message_add_tail(&lengths_xfer, &msg);\r\nspi_message_add_tail(&data_xfer, &msg);\r\ncmd = MRF24J40_WRITELONG(reg);\r\nmutex_lock(&devrec->buffer_mutex);\r\ndevrec->buf[0] = cmd >> 8 & 0xff;\r\ndevrec->buf[1] = cmd & 0xff;\r\nlengths[0] = 0x0;\r\nlengths[1] = length;\r\nret = spi_sync(devrec->spi, &msg);\r\nif (ret)\r\ndev_err(printdev(devrec), "SPI write Failed for TX buf\n");\r\nmutex_unlock(&devrec->buffer_mutex);\r\nreturn ret;\r\n}\r\nstatic int mrf24j40_read_rx_buf(struct mrf24j40 *devrec,\r\nu8 *data, u8 *len, u8 *lqi)\r\n{\r\nu8 rx_len;\r\nu8 addr[2];\r\nu8 lqi_rssi[2];\r\nu16 cmd;\r\nint ret;\r\nstruct spi_message msg;\r\nstruct spi_transfer addr_xfer = {\r\n.len = 2,\r\n.tx_buf = &addr,\r\n};\r\nstruct spi_transfer data_xfer = {\r\n.len = 0x0,\r\n.rx_buf = data,\r\n};\r\nstruct spi_transfer status_xfer = {\r\n.len = 2,\r\n.rx_buf = &lqi_rssi,\r\n};\r\nret = read_long_reg(devrec, REG_RX_FIFO, &rx_len);\r\nif (ret)\r\ngoto out;\r\nif (rx_len > RX_FIFO_SIZE-1) {\r\ndev_err(printdev(devrec), "Invalid length read from device. Performing short read.\n");\r\nrx_len = RX_FIFO_SIZE-1;\r\n}\r\nif (rx_len > *len) {\r\ndev_err(printdev(devrec), "Buffer not big enough. Performing short read\n");\r\nrx_len = *len;\r\n}\r\ncmd = MRF24J40_READLONG(REG_RX_FIFO+1);\r\naddr[0] = cmd >> 8 & 0xff;\r\naddr[1] = cmd & 0xff;\r\ndata_xfer.len = rx_len;\r\nspi_message_init(&msg);\r\nspi_message_add_tail(&addr_xfer, &msg);\r\nspi_message_add_tail(&data_xfer, &msg);\r\nspi_message_add_tail(&status_xfer, &msg);\r\nret = spi_sync(devrec->spi, &msg);\r\nif (ret) {\r\ndev_err(printdev(devrec), "SPI RX Buffer Read Failed.\n");\r\ngoto out;\r\n}\r\n*lqi = lqi_rssi[0];\r\n*len = rx_len;\r\n#ifdef DEBUG\r\nprint_hex_dump(KERN_DEBUG, "mrf24j40 rx: ",\r\nDUMP_PREFIX_OFFSET, 16, 1, data, *len, 0);\r\npr_debug("mrf24j40 rx: lqi: %02hhx rssi: %02hhx\n",\r\nlqi_rssi[0], lqi_rssi[1]);\r\n#endif\r\nout:\r\nreturn ret;\r\n}\r\nstatic int mrf24j40_tx(struct ieee802154_hw *hw, struct sk_buff *skb)\r\n{\r\nstruct mrf24j40 *devrec = hw->priv;\r\nu8 val;\r\nint ret = 0;\r\ndev_dbg(printdev(devrec), "tx packet of %d bytes\n", skb->len);\r\nret = write_tx_buf(devrec, 0x000, skb->data, skb->len);\r\nif (ret)\r\ngoto err;\r\nreinit_completion(&devrec->tx_complete);\r\nret = read_short_reg(devrec, REG_TXNCON, &val);\r\nif (ret)\r\ngoto err;\r\nval |= 0x1;\r\nif (skb->data[0] & IEEE802154_FC_ACK_REQ)\r\nval |= 0x4;\r\nwrite_short_reg(devrec, REG_TXNCON, val);\r\nret = wait_for_completion_interruptible_timeout(\r\n&devrec->tx_complete,\r\n5 * HZ);\r\nif (ret == -ERESTARTSYS)\r\ngoto err;\r\nif (ret == 0) {\r\ndev_warn(printdev(devrec), "Timeout waiting for TX interrupt\n");\r\nret = -ETIMEDOUT;\r\ngoto err;\r\n}\r\nret = read_short_reg(devrec, REG_TXSTAT, &val);\r\nif (ret)\r\ngoto err;\r\nif (val & 0x1) {\r\ndev_dbg(printdev(devrec), "Error Sending. Retry count exceeded\n");\r\nret = -ECOMM;\r\n} else\r\ndev_dbg(printdev(devrec), "Packet Sent\n");\r\nerr:\r\nreturn ret;\r\n}\r\nstatic int mrf24j40_ed(struct ieee802154_hw *hw, u8 *level)\r\n{\r\npr_warn("mrf24j40: ed not implemented\n");\r\n*level = 0;\r\nreturn 0;\r\n}\r\nstatic int mrf24j40_start(struct ieee802154_hw *hw)\r\n{\r\nstruct mrf24j40 *devrec = hw->priv;\r\nu8 val;\r\nint ret;\r\ndev_dbg(printdev(devrec), "start\n");\r\nret = read_short_reg(devrec, REG_INTCON, &val);\r\nif (ret)\r\nreturn ret;\r\nval &= ~(0x1|0x8);\r\nwrite_short_reg(devrec, REG_INTCON, val);\r\nreturn 0;\r\n}\r\nstatic void mrf24j40_stop(struct ieee802154_hw *hw)\r\n{\r\nstruct mrf24j40 *devrec = hw->priv;\r\nu8 val;\r\nint ret;\r\ndev_dbg(printdev(devrec), "stop\n");\r\nret = read_short_reg(devrec, REG_INTCON, &val);\r\nif (ret)\r\nreturn;\r\nval |= 0x1|0x8;\r\nwrite_short_reg(devrec, REG_INTCON, val);\r\n}\r\nstatic int mrf24j40_set_channel(struct ieee802154_hw *hw, u8 page, u8 channel)\r\n{\r\nstruct mrf24j40 *devrec = hw->priv;\r\nu8 val;\r\nint ret;\r\ndev_dbg(printdev(devrec), "Set Channel %d\n", channel);\r\nWARN_ON(page != 0);\r\nWARN_ON(channel < MRF24J40_CHAN_MIN);\r\nWARN_ON(channel > MRF24J40_CHAN_MAX);\r\nval = (channel-11) << 4 | 0x03;\r\nwrite_long_reg(devrec, REG_RFCON0, val);\r\nret = read_short_reg(devrec, REG_RFCTL, &val);\r\nif (ret)\r\nreturn ret;\r\nval |= 0x04;\r\nwrite_short_reg(devrec, REG_RFCTL, val);\r\nval &= ~0x04;\r\nwrite_short_reg(devrec, REG_RFCTL, val);\r\nudelay(SET_CHANNEL_DELAY_US);\r\nreturn 0;\r\n}\r\nstatic int mrf24j40_filter(struct ieee802154_hw *hw,\r\nstruct ieee802154_hw_addr_filt *filt,\r\nunsigned long changed)\r\n{\r\nstruct mrf24j40 *devrec = hw->priv;\r\ndev_dbg(printdev(devrec), "filter\n");\r\nif (changed & IEEE802154_AFILT_SADDR_CHANGED) {\r\nu8 addrh, addrl;\r\naddrh = le16_to_cpu(filt->short_addr) >> 8 & 0xff;\r\naddrl = le16_to_cpu(filt->short_addr) & 0xff;\r\nwrite_short_reg(devrec, REG_SADRH, addrh);\r\nwrite_short_reg(devrec, REG_SADRL, addrl);\r\ndev_dbg(printdev(devrec),\r\n"Set short addr to %04hx\n", filt->short_addr);\r\n}\r\nif (changed & IEEE802154_AFILT_IEEEADDR_CHANGED) {\r\nu8 i, addr[8];\r\nmemcpy(addr, &filt->ieee_addr, 8);\r\nfor (i = 0; i < 8; i++)\r\nwrite_short_reg(devrec, REG_EADR0 + i, addr[i]);\r\n#ifdef DEBUG\r\npr_debug("Set long addr to: ");\r\nfor (i = 0; i < 8; i++)\r\npr_debug("%02hhx ", addr[7 - i]);\r\npr_debug("\n");\r\n#endif\r\n}\r\nif (changed & IEEE802154_AFILT_PANID_CHANGED) {\r\nu8 panidl, panidh;\r\npanidh = le16_to_cpu(filt->pan_id) >> 8 & 0xff;\r\npanidl = le16_to_cpu(filt->pan_id) & 0xff;\r\nwrite_short_reg(devrec, REG_PANIDH, panidh);\r\nwrite_short_reg(devrec, REG_PANIDL, panidl);\r\ndev_dbg(printdev(devrec), "Set PANID to %04hx\n", filt->pan_id);\r\n}\r\nif (changed & IEEE802154_AFILT_PANC_CHANGED) {\r\nu8 val;\r\nint ret;\r\nret = read_short_reg(devrec, REG_RXMCR, &val);\r\nif (ret)\r\nreturn ret;\r\nif (filt->pan_coord)\r\nval |= 0x8;\r\nelse\r\nval &= ~0x8;\r\nwrite_short_reg(devrec, REG_RXMCR, val);\r\ndev_dbg(printdev(devrec), "Set Pan Coord to %s\n",\r\nfilt->pan_coord ? "on" : "off");\r\n}\r\nreturn 0;\r\n}\r\nstatic int mrf24j40_handle_rx(struct mrf24j40 *devrec)\r\n{\r\nu8 len = RX_FIFO_SIZE;\r\nu8 lqi = 0;\r\nu8 val;\r\nint ret = 0;\r\nstruct sk_buff *skb;\r\nret = read_short_reg(devrec, REG_BBREG1, &val);\r\nif (ret)\r\ngoto out;\r\nval |= 4;\r\nwrite_short_reg(devrec, REG_BBREG1, val);\r\nskb = dev_alloc_skb(len);\r\nif (!skb) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nret = mrf24j40_read_rx_buf(devrec, skb_put(skb, len), &len, &lqi);\r\nif (ret < 0) {\r\ndev_err(printdev(devrec), "Failure reading RX FIFO\n");\r\nkfree_skb(skb);\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nskb_trim(skb, len-2);\r\nieee802154_rx_irqsafe(devrec->hw, skb, lqi);\r\ndev_dbg(printdev(devrec), "RX Handled\n");\r\nout:\r\nret = read_short_reg(devrec, REG_BBREG1, &val);\r\nif (ret)\r\nreturn ret;\r\nval &= ~0x4;\r\nwrite_short_reg(devrec, REG_BBREG1, val);\r\nreturn ret;\r\n}\r\nstatic irqreturn_t mrf24j40_isr(int irq, void *data)\r\n{\r\nstruct mrf24j40 *devrec = data;\r\nu8 intstat;\r\nint ret;\r\nret = read_short_reg(devrec, REG_INTSTAT, &intstat);\r\nif (ret)\r\ngoto out;\r\nif (intstat & 0x1)\r\ncomplete(&devrec->tx_complete);\r\nif (intstat & 0x8)\r\nmrf24j40_handle_rx(devrec);\r\nout:\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int mrf24j40_hw_init(struct mrf24j40 *devrec)\r\n{\r\nint ret;\r\nu8 val;\r\nret = write_short_reg(devrec, REG_SOFTRST, 0x07);\r\nif (ret)\r\ngoto err_ret;\r\nret = write_short_reg(devrec, REG_PACON2, 0x98);\r\nif (ret)\r\ngoto err_ret;\r\nret = write_short_reg(devrec, REG_TXSTBL, 0x95);\r\nif (ret)\r\ngoto err_ret;\r\nret = write_long_reg(devrec, REG_RFCON0, 0x03);\r\nif (ret)\r\ngoto err_ret;\r\nret = write_long_reg(devrec, REG_RFCON1, 0x01);\r\nif (ret)\r\ngoto err_ret;\r\nret = write_long_reg(devrec, REG_RFCON2, 0x80);\r\nif (ret)\r\ngoto err_ret;\r\nret = write_long_reg(devrec, REG_RFCON6, 0x90);\r\nif (ret)\r\ngoto err_ret;\r\nret = write_long_reg(devrec, REG_RFCON7, 0x80);\r\nif (ret)\r\ngoto err_ret;\r\nret = write_long_reg(devrec, REG_RFCON8, 0x10);\r\nif (ret)\r\ngoto err_ret;\r\nret = write_long_reg(devrec, REG_SLPCON1, 0x21);\r\nif (ret)\r\ngoto err_ret;\r\nret = write_short_reg(devrec, REG_BBREG2, 0x80);\r\nif (ret)\r\ngoto err_ret;\r\nret = write_short_reg(devrec, REG_CCAEDTH, 0x60);\r\nif (ret)\r\ngoto err_ret;\r\nret = write_short_reg(devrec, REG_BBREG6, 0x40);\r\nif (ret)\r\ngoto err_ret;\r\nret = write_short_reg(devrec, REG_RFCTL, 0x04);\r\nif (ret)\r\ngoto err_ret;\r\nret = write_short_reg(devrec, REG_RFCTL, 0x0);\r\nif (ret)\r\ngoto err_ret;\r\nudelay(192);\r\nret = read_short_reg(devrec, REG_RXMCR, &val);\r\nif (ret)\r\ngoto err_ret;\r\nval &= ~0x3;\r\nret = write_short_reg(devrec, REG_RXMCR, val);\r\nif (ret)\r\ngoto err_ret;\r\nif (spi_get_device_id(devrec->spi)->driver_data == MRF24J40MC) {\r\nread_long_reg(devrec, REG_TESTMODE, &val);\r\nval |= 0x7;\r\nwrite_long_reg(devrec, REG_TESTMODE, val);\r\nread_short_reg(devrec, REG_TRISGPIO, &val);\r\nval |= 0x8;\r\nwrite_short_reg(devrec, REG_TRISGPIO, val);\r\nread_short_reg(devrec, REG_GPIO, &val);\r\nval |= 0x8;\r\nwrite_short_reg(devrec, REG_GPIO, val);\r\nwrite_long_reg(devrec, REG_RFCON3, 0x28);\r\n}\r\nreturn 0;\r\nerr_ret:\r\nreturn ret;\r\n}\r\nstatic int mrf24j40_probe(struct spi_device *spi)\r\n{\r\nint ret = -ENOMEM;\r\nstruct mrf24j40 *devrec;\r\ndev_info(&spi->dev, "probe(). IRQ: %d\n", spi->irq);\r\ndevrec = devm_kzalloc(&spi->dev, sizeof(struct mrf24j40), GFP_KERNEL);\r\nif (!devrec)\r\ngoto err_ret;\r\ndevrec->buf = devm_kzalloc(&spi->dev, 3, GFP_KERNEL);\r\nif (!devrec->buf)\r\ngoto err_ret;\r\nspi->mode = SPI_MODE_0;\r\nif (spi->max_speed_hz > MAX_SPI_SPEED_HZ)\r\nspi->max_speed_hz = MAX_SPI_SPEED_HZ;\r\nmutex_init(&devrec->buffer_mutex);\r\ninit_completion(&devrec->tx_complete);\r\ndevrec->spi = spi;\r\nspi_set_drvdata(spi, devrec);\r\ndevrec->hw = ieee802154_alloc_hw(0, &mrf24j40_ops);\r\nif (!devrec->hw)\r\ngoto err_ret;\r\ndevrec->hw->priv = devrec;\r\ndevrec->hw->parent = &devrec->spi->dev;\r\ndevrec->hw->phy->channels_supported[0] = CHANNEL_MASK;\r\ndevrec->hw->flags = IEEE802154_HW_OMIT_CKSUM | IEEE802154_HW_AACK |\r\nIEEE802154_HW_AFILT;\r\ndev_dbg(printdev(devrec), "registered mrf24j40\n");\r\nret = ieee802154_register_hw(devrec->hw);\r\nif (ret)\r\ngoto err_register_device;\r\nret = mrf24j40_hw_init(devrec);\r\nif (ret)\r\ngoto err_hw_init;\r\nret = devm_request_threaded_irq(&spi->dev,\r\nspi->irq,\r\nNULL,\r\nmrf24j40_isr,\r\nIRQF_TRIGGER_LOW|IRQF_ONESHOT,\r\ndev_name(&spi->dev),\r\ndevrec);\r\nif (ret) {\r\ndev_err(printdev(devrec), "Unable to get IRQ");\r\ngoto err_irq;\r\n}\r\nreturn 0;\r\nerr_irq:\r\nerr_hw_init:\r\nieee802154_unregister_hw(devrec->hw);\r\nerr_register_device:\r\nieee802154_free_hw(devrec->hw);\r\nerr_ret:\r\nreturn ret;\r\n}\r\nstatic int mrf24j40_remove(struct spi_device *spi)\r\n{\r\nstruct mrf24j40 *devrec = spi_get_drvdata(spi);\r\ndev_dbg(printdev(devrec), "remove\n");\r\nieee802154_unregister_hw(devrec->hw);\r\nieee802154_free_hw(devrec->hw);\r\nreturn 0;\r\n}
