static inline void sfb_write(struct pmagbbfb_par *par, unsigned int reg, u32 v)\r\n{\r\nwritel(v, par->sfb + reg / 4);\r\n}\r\nstatic inline u32 sfb_read(struct pmagbbfb_par *par, unsigned int reg)\r\n{\r\nreturn readl(par->sfb + reg / 4);\r\n}\r\nstatic inline void dac_write(struct pmagbbfb_par *par, unsigned int reg, u8 v)\r\n{\r\nwriteb(v, par->dac + reg / 4);\r\n}\r\nstatic inline u8 dac_read(struct pmagbbfb_par *par, unsigned int reg)\r\n{\r\nreturn readb(par->dac + reg / 4);\r\n}\r\nstatic inline void gp0_write(struct pmagbbfb_par *par, u32 v)\r\n{\r\nwritel(v, par->mmio + PMAGB_B_GP0);\r\n}\r\nstatic int pmagbbfb_setcolreg(unsigned int regno, unsigned int red,\r\nunsigned int green, unsigned int blue,\r\nunsigned int transp, struct fb_info *info)\r\n{\r\nstruct pmagbbfb_par *par = info->par;\r\nif (regno >= info->cmap.len)\r\nreturn 1;\r\nred >>= 8;\r\ngreen >>= 8;\r\nblue >>= 8;\r\nmb();\r\ndac_write(par, BT459_ADDR_LO, regno);\r\ndac_write(par, BT459_ADDR_HI, 0x00);\r\nwmb();\r\ndac_write(par, BT459_CMAP, red);\r\nwmb();\r\ndac_write(par, BT459_CMAP, green);\r\nwmb();\r\ndac_write(par, BT459_CMAP, blue);\r\nreturn 0;\r\n}\r\nstatic void __init pmagbbfb_erase_cursor(struct fb_info *info)\r\n{\r\nstruct pmagbbfb_par *par = info->par;\r\nmb();\r\ndac_write(par, BT459_ADDR_LO, 0x00);\r\ndac_write(par, BT459_ADDR_HI, 0x03);\r\nwmb();\r\ndac_write(par, BT459_DATA, 0x00);\r\n}\r\nstatic void pmagbbfb_screen_setup(struct fb_info *info)\r\n{\r\nstruct pmagbbfb_par *par = info->par;\r\ninfo->var.xres = ((sfb_read(par, SFB_REG_VID_HOR) >>\r\nSFB_VID_HOR_PIX_SHIFT) & SFB_VID_HOR_PIX_MASK) * 4;\r\ninfo->var.xres_virtual = info->var.xres;\r\ninfo->var.yres = (sfb_read(par, SFB_REG_VID_VER) >>\r\nSFB_VID_VER_SL_SHIFT) & SFB_VID_VER_SL_MASK;\r\ninfo->var.yres_virtual = info->var.yres;\r\ninfo->var.left_margin = ((sfb_read(par, SFB_REG_VID_HOR) >>\r\nSFB_VID_HOR_BP_SHIFT) &\r\nSFB_VID_HOR_BP_MASK) * 4;\r\ninfo->var.right_margin = ((sfb_read(par, SFB_REG_VID_HOR) >>\r\nSFB_VID_HOR_FP_SHIFT) &\r\nSFB_VID_HOR_FP_MASK) * 4;\r\ninfo->var.upper_margin = (sfb_read(par, SFB_REG_VID_VER) >>\r\nSFB_VID_VER_BP_SHIFT) & SFB_VID_VER_BP_MASK;\r\ninfo->var.lower_margin = (sfb_read(par, SFB_REG_VID_VER) >>\r\nSFB_VID_VER_FP_SHIFT) & SFB_VID_VER_FP_MASK;\r\ninfo->var.hsync_len = ((sfb_read(par, SFB_REG_VID_HOR) >>\r\nSFB_VID_HOR_SYN_SHIFT) &\r\nSFB_VID_HOR_SYN_MASK) * 4;\r\ninfo->var.vsync_len = (sfb_read(par, SFB_REG_VID_VER) >>\r\nSFB_VID_VER_SYN_SHIFT) & SFB_VID_VER_SYN_MASK;\r\ninfo->fix.line_length = info->var.xres;\r\n}\r\nstatic void pmagbbfb_osc_setup(struct fb_info *info)\r\n{\r\nstatic unsigned int pmagbbfb_freqs[] = {\r\n130808, 119843, 104000, 92980, 74370, 72800,\r\n69197, 66000, 65000, 50350, 36000, 32000, 25175\r\n};\r\nstruct pmagbbfb_par *par = info->par;\r\nstruct tc_bus *tbus = to_tc_dev(info->device)->bus;\r\nu32 count0 = 8, count1 = 8, counttc = 16 * 256 + 8;\r\nu32 freq0, freq1, freqtc = tc_get_speed(tbus) / 250;\r\nint i, j;\r\ngp0_write(par, 0);\r\nfor (j = 0; j < 16; j++) {\r\nmb();\r\nsfb_write(par, SFB_REG_TCCLK_COUNT, 0);\r\nmb();\r\nfor (i = 0; i < 100; i++) {\r\nif (sfb_read(par, SFB_REG_TCCLK_COUNT) == 0)\r\nbreak;\r\nudelay(1);\r\n}\r\ncount0 += sfb_read(par, SFB_REG_VIDCLK_COUNT);\r\n}\r\ngp0_write(par, 1);\r\nfor (j = 0; j < 16; j++) {\r\nmb();\r\nsfb_write(par, SFB_REG_TCCLK_COUNT, 0);\r\nfor (i = 0; i < 100; i++) {\r\nif (sfb_read(par, SFB_REG_TCCLK_COUNT) == 0)\r\nbreak;\r\nudelay(1);\r\n}\r\ncount1 += sfb_read(par, SFB_REG_VIDCLK_COUNT);\r\n}\r\nfreq0 = (freqtc * count0 + counttc / 2) / counttc;\r\npar->osc0 = freq0;\r\nif (freq0 >= pmagbbfb_freqs[0] - (pmagbbfb_freqs[0] + 32) / 64 &&\r\nfreq0 <= pmagbbfb_freqs[0] + (pmagbbfb_freqs[0] + 32) / 64)\r\npar->osc0 = pmagbbfb_freqs[0];\r\nfreq1 = (par->osc0 * count1 + count0 / 2) / count0;\r\npar->osc1 = freq1;\r\nfor (i = 0; i < ARRAY_SIZE(pmagbbfb_freqs); i++)\r\nif (freq1 >= pmagbbfb_freqs[i] -\r\n(pmagbbfb_freqs[i] + 128) / 256 &&\r\nfreq1 <= pmagbbfb_freqs[i] +\r\n(pmagbbfb_freqs[i] + 128) / 256) {\r\npar->osc1 = pmagbbfb_freqs[i];\r\nbreak;\r\n}\r\nif (par->osc0 - par->osc1 <= (par->osc0 + par->osc1 + 256) / 512 ||\r\npar->osc1 - par->osc0 <= (par->osc0 + par->osc1 + 256) / 512)\r\npar->osc1 = 0;\r\ngp0_write(par, par->osc1 != 0);\r\ninfo->var.pixclock = par->osc1 ?\r\n(1000000000 + par->osc1 / 2) / par->osc1 :\r\n(1000000000 + par->osc0 / 2) / par->osc0;\r\n}\r\nstatic int pmagbbfb_probe(struct device *dev)\r\n{\r\nstruct tc_dev *tdev = to_tc_dev(dev);\r\nresource_size_t start, len;\r\nstruct fb_info *info;\r\nstruct pmagbbfb_par *par;\r\nchar freq0[12], freq1[12];\r\nu32 vid_base;\r\nint err;\r\ninfo = framebuffer_alloc(sizeof(struct pmagbbfb_par), dev);\r\nif (!info) {\r\nprintk(KERN_ERR "%s: Cannot allocate memory\n", dev_name(dev));\r\nreturn -ENOMEM;\r\n}\r\npar = info->par;\r\ndev_set_drvdata(dev, info);\r\nif (fb_alloc_cmap(&info->cmap, 256, 0) < 0) {\r\nprintk(KERN_ERR "%s: Cannot allocate color map\n",\r\ndev_name(dev));\r\nerr = -ENOMEM;\r\ngoto err_alloc;\r\n}\r\ninfo->fbops = &pmagbbfb_ops;\r\ninfo->fix = pmagbbfb_fix;\r\ninfo->var = pmagbbfb_defined;\r\ninfo->flags = FBINFO_DEFAULT;\r\nstart = tdev->resource.start;\r\nlen = tdev->resource.end - start + 1;\r\nif (!request_mem_region(start, len, dev_name(dev))) {\r\nprintk(KERN_ERR "%s: Cannot reserve FB region\n",\r\ndev_name(dev));\r\nerr = -EBUSY;\r\ngoto err_cmap;\r\n}\r\ninfo->fix.mmio_start = start;\r\npar->mmio = ioremap_nocache(info->fix.mmio_start, info->fix.mmio_len);\r\nif (!par->mmio) {\r\nprintk(KERN_ERR "%s: Cannot map MMIO\n", dev_name(dev));\r\nerr = -ENOMEM;\r\ngoto err_resource;\r\n}\r\npar->sfb = par->mmio + PMAGB_B_SFB;\r\npar->dac = par->mmio + PMAGB_B_BT459;\r\ninfo->fix.smem_start = start + PMAGB_B_FBMEM;\r\npar->smem = ioremap_nocache(info->fix.smem_start, info->fix.smem_len);\r\nif (!par->smem) {\r\nprintk(KERN_ERR "%s: Cannot map FB\n", dev_name(dev));\r\nerr = -ENOMEM;\r\ngoto err_mmio_map;\r\n}\r\nvid_base = sfb_read(par, SFB_REG_VID_BASE);\r\ninfo->screen_base = (void __iomem *)par->smem + vid_base * 0x1000;\r\ninfo->screen_size = info->fix.smem_len - 2 * vid_base * 0x1000;\r\npmagbbfb_erase_cursor(info);\r\npmagbbfb_screen_setup(info);\r\npmagbbfb_osc_setup(info);\r\nerr = register_framebuffer(info);\r\nif (err < 0) {\r\nprintk(KERN_ERR "%s: Cannot register framebuffer\n",\r\ndev_name(dev));\r\ngoto err_smem_map;\r\n}\r\nget_device(dev);\r\nsnprintf(freq0, sizeof(freq0), "%u.%03uMHz",\r\npar->osc0 / 1000, par->osc0 % 1000);\r\nsnprintf(freq1, sizeof(freq1), "%u.%03uMHz",\r\npar->osc1 / 1000, par->osc1 % 1000);\r\nfb_info(info, "%s frame buffer device at %s\n",\r\ninfo->fix.id, dev_name(dev));\r\nfb_info(info, "Osc0: %s, Osc1: %s, Osc%u selected\n",\r\nfreq0, par->osc1 ? freq1 : "disabled", par->osc1 != 0);\r\nreturn 0;\r\nerr_smem_map:\r\niounmap(par->smem);\r\nerr_mmio_map:\r\niounmap(par->mmio);\r\nerr_resource:\r\nrelease_mem_region(start, len);\r\nerr_cmap:\r\nfb_dealloc_cmap(&info->cmap);\r\nerr_alloc:\r\nframebuffer_release(info);\r\nreturn err;\r\n}\r\nstatic int __exit pmagbbfb_remove(struct device *dev)\r\n{\r\nstruct tc_dev *tdev = to_tc_dev(dev);\r\nstruct fb_info *info = dev_get_drvdata(dev);\r\nstruct pmagbbfb_par *par = info->par;\r\nresource_size_t start, len;\r\nput_device(dev);\r\nunregister_framebuffer(info);\r\niounmap(par->smem);\r\niounmap(par->mmio);\r\nstart = tdev->resource.start;\r\nlen = tdev->resource.end - start + 1;\r\nrelease_mem_region(start, len);\r\nfb_dealloc_cmap(&info->cmap);\r\nframebuffer_release(info);\r\nreturn 0;\r\n}\r\nstatic int __init pmagbbfb_init(void)\r\n{\r\n#ifndef MODULE\r\nif (fb_get_options("pmagbbfb", NULL))\r\nreturn -ENXIO;\r\n#endif\r\nreturn tc_register_driver(&pmagbbfb_driver);\r\n}\r\nstatic void __exit pmagbbfb_exit(void)\r\n{\r\ntc_unregister_driver(&pmagbbfb_driver);\r\n}
