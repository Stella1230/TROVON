static ssize_t reg_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct uio_info *info = platform_get_drvdata(pdev);\r\nstruct fsl_elbc_gpcm *priv = info->priv;\r\nstruct fsl_lbc_bank *bank = &priv->lbc->bank[priv->bank];\r\nif (attr == &dev_attr_reg_br) {\r\nreturn scnprintf(buf, PAGE_SIZE, "0x%08x\n",\r\nin_be32(&bank->br));\r\n} else if (attr == &dev_attr_reg_or) {\r\nreturn scnprintf(buf, PAGE_SIZE, "0x%08x\n",\r\nin_be32(&bank->or));\r\n}\r\nreturn 0;\r\n}\r\nstatic ssize_t reg_store(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct uio_info *info = platform_get_drvdata(pdev);\r\nstruct fsl_elbc_gpcm *priv = info->priv;\r\nstruct fsl_lbc_bank *bank = &priv->lbc->bank[priv->bank];\r\nunsigned long val;\r\nu32 reg_br_cur;\r\nu32 reg_or_cur;\r\nu32 reg_new;\r\nif (kstrtoul(buf, 0, &val) != 0)\r\nreturn -EINVAL;\r\nreg_new = (u32)val;\r\nreg_br_cur = in_be32(&bank->br);\r\nreg_or_cur = in_be32(&bank->or);\r\nif (attr == &dev_attr_reg_br) {\r\nif ((reg_br_cur & reg_or_cur & BR_BA) !=\r\n(reg_new & reg_or_cur & BR_BA)) {\r\nreturn -EINVAL;\r\n}\r\nif ((reg_new & BR_MSEL) != BR_MS_GPCM)\r\nreturn -EINVAL;\r\nout_be32(&bank->br, reg_new | BR_V);\r\n} else if (attr == &dev_attr_reg_or) {\r\nif ((reg_or_cur & OR_GPCM_AM) != (reg_new & OR_GPCM_AM))\r\nreturn -EINVAL;\r\nout_be32(&bank->or, reg_new);\r\n} else {\r\nreturn -EINVAL;\r\n}\r\nreturn count;\r\n}\r\nstatic irqreturn_t netx5152_irq_handler(int irq, struct uio_info *info)\r\n{\r\nvoid __iomem *reg_int_en = info->mem[0].internal_addr +\r\nDPM_HOST_WIN0_OFFSET +\r\nDPM_HOST_INT_EN0;\r\nvoid __iomem *reg_int_stat = info->mem[0].internal_addr +\r\nDPM_HOST_WIN0_OFFSET +\r\nDPM_HOST_INT_STAT0;\r\nif ((ioread32(reg_int_en) & ioread32(reg_int_stat) &\r\nDPM_HOST_INT_MASK) == 0) {\r\nreturn IRQ_NONE;\r\n}\r\niowrite32(ioread32(reg_int_en) & ~DPM_HOST_INT_GLOBAL_EN, reg_int_en);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void netx5152_init(struct uio_info *info)\r\n{\r\nunsigned long win0_offset = DPM_HOST_WIN0_OFFSET;\r\nstruct fsl_elbc_gpcm *priv = info->priv;\r\nconst void *prop;\r\nprop = of_get_property(priv->dev->of_node,\r\n"netx5152,init-win0-offset", NULL);\r\nif (prop)\r\nwin0_offset = of_read_ulong(prop, 1);\r\niowrite32(0, info->mem[0].internal_addr + win0_offset +\r\nDPM_HOST_INT_EN0);\r\n}\r\nstatic void netx5152_shutdown(struct uio_info *info, bool init_err)\r\n{\r\nif (init_err)\r\nreturn;\r\niowrite32(0, info->mem[0].internal_addr + DPM_HOST_WIN0_OFFSET +\r\nDPM_HOST_INT_EN0);\r\n}\r\nstatic void setup_periph(struct fsl_elbc_gpcm *priv,\r\nconst char *type)\r\n{\r\n#ifdef CONFIG_UIO_FSL_ELBC_GPCM_NETX5152\r\nif (strcmp(type, "netx5152") == 0) {\r\npriv->irq_handler = netx5152_irq_handler;\r\npriv->init = netx5152_init;\r\npriv->shutdown = netx5152_shutdown;\r\npriv->name = "netX 51/52";\r\nreturn;\r\n}\r\n#endif\r\n}\r\nstatic int check_of_data(struct fsl_elbc_gpcm *priv,\r\nstruct resource *res,\r\nu32 reg_br, u32 reg_or)\r\n{\r\nif (priv->bank >= MAX_BANKS) {\r\ndev_err(priv->dev, "invalid bank\n");\r\nreturn -ENODEV;\r\n}\r\nif ((reg_br & BR_MSEL) != BR_MS_GPCM) {\r\ndev_err(priv->dev, "unsupported mode\n");\r\nreturn -ENODEV;\r\n}\r\nif ((~(reg_or & OR_GPCM_AM) + 1) != resource_size(res)) {\r\ndev_err(priv->dev, "address mask / size mismatch\n");\r\nreturn -ENODEV;\r\n}\r\nif ((reg_br & reg_or & BR_BA) != fsl_lbc_addr(res->start)) {\r\ndev_err(priv->dev, "base address mismatch\n");\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\n}\r\nstatic int get_of_data(struct fsl_elbc_gpcm *priv, struct device_node *node,\r\nstruct resource *res, u32 *reg_br,\r\nu32 *reg_or, unsigned int *irq, char **name)\r\n{\r\nconst char *dt_name;\r\nconst char *type;\r\nint ret;\r\nret = of_address_to_resource(node, 0, res);\r\nif (ret) {\r\ndev_err(priv->dev, "failed to get resource\n");\r\nreturn ret;\r\n}\r\nret = of_property_read_u32(node, "reg", &priv->bank);\r\nif (ret) {\r\ndev_err(priv->dev, "failed to get bank number\n");\r\nreturn ret;\r\n}\r\nret = of_property_read_u32(node, "elbc-gpcm-br", reg_br);\r\nif (ret) {\r\ndev_err(priv->dev, "missing elbc-gpcm-br value\n");\r\nreturn ret;\r\n}\r\nret = of_property_read_u32(node, "elbc-gpcm-or", reg_or);\r\nif (ret) {\r\ndev_err(priv->dev, "missing elbc-gpcm-or value\n");\r\nreturn ret;\r\n}\r\npriv->name = "generic";\r\nif (of_property_read_string(node, "device_type", &type) == 0)\r\nsetup_periph(priv, type);\r\n*irq = irq_of_parse_and_map(node, 0);\r\nret = check_of_data(priv, res, *reg_br, *reg_or);\r\nif (ret)\r\nreturn ret;\r\nif (of_property_read_string(node, "uio_name", &dt_name) != 0)\r\ndt_name = "eLBC_GPCM";\r\n*name = kstrdup(dt_name, GFP_KERNEL);\r\nif (!*name)\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nstatic int uio_fsl_elbc_gpcm_probe(struct platform_device *pdev)\r\n{\r\nstruct device_node *node = pdev->dev.of_node;\r\nstruct fsl_elbc_gpcm *priv;\r\nstruct uio_info *info;\r\nchar *uio_name = NULL;\r\nstruct resource res;\r\nunsigned int irq;\r\nu32 reg_br_cur;\r\nu32 reg_or_cur;\r\nu32 reg_br_new;\r\nu32 reg_or_new;\r\nint ret;\r\nif (!fsl_lbc_ctrl_dev || !fsl_lbc_ctrl_dev->regs)\r\nreturn -ENODEV;\r\npriv = kzalloc(sizeof(*priv), GFP_KERNEL);\r\nif (!priv)\r\nreturn -ENOMEM;\r\npriv->dev = &pdev->dev;\r\npriv->lbc = fsl_lbc_ctrl_dev->regs;\r\nret = get_of_data(priv, node, &res, &reg_br_new, &reg_or_new,\r\n&irq, &uio_name);\r\nif (ret)\r\ngoto out_err0;\r\ninfo = kzalloc(sizeof(*info), GFP_KERNEL);\r\nif (!info) {\r\nret = -ENOMEM;\r\ngoto out_err0;\r\n}\r\nreg_br_cur = in_be32(&priv->lbc->bank[priv->bank].br);\r\nreg_or_cur = in_be32(&priv->lbc->bank[priv->bank].or);\r\nif ((reg_br_cur & BR_V)) {\r\nif ((reg_br_cur & BR_MSEL) != BR_MS_GPCM ||\r\n(reg_br_cur & reg_or_cur & BR_BA)\r\n!= fsl_lbc_addr(res.start)) {\r\ndev_err(priv->dev,\r\n"bank in use by another peripheral\n");\r\nret = -ENODEV;\r\ngoto out_err1;\r\n}\r\nif ((reg_br_cur & ~(BR_BA | BR_V)) !=\r\n(reg_br_new & ~(BR_BA | BR_V))) {\r\ndev_warn(priv->dev,\r\n"modifying BR settings: 0x%08x -> 0x%08x",\r\nreg_br_cur, reg_br_new);\r\n}\r\nif ((reg_or_cur & ~OR_GPCM_AM) != (reg_or_new & ~OR_GPCM_AM)) {\r\ndev_warn(priv->dev,\r\n"modifying OR settings: 0x%08x -> 0x%08x",\r\nreg_or_cur, reg_or_new);\r\n}\r\n}\r\nreg_br_new &= ~(BR_BA | BR_MSEL);\r\nreg_br_new |= fsl_lbc_addr(res.start) | BR_MS_GPCM | BR_V;\r\nout_be32(&priv->lbc->bank[priv->bank].or, reg_or_new);\r\nout_be32(&priv->lbc->bank[priv->bank].br, reg_br_new);\r\ninfo->mem[0].internal_addr = ioremap(res.start, resource_size(&res));\r\nif (!info->mem[0].internal_addr) {\r\ndev_err(priv->dev, "failed to map chip region\n");\r\nret = -ENODEV;\r\ngoto out_err1;\r\n}\r\nif (node->name)\r\ninfo->mem[0].name = kstrdup(node->name, GFP_KERNEL);\r\ninfo->mem[0].addr = res.start;\r\ninfo->mem[0].size = resource_size(&res);\r\ninfo->mem[0].memtype = UIO_MEM_PHYS;\r\ninfo->priv = priv;\r\ninfo->name = uio_name;\r\ninfo->version = "0.0.1";\r\nif (irq != NO_IRQ) {\r\nif (priv->irq_handler) {\r\ninfo->irq = irq;\r\ninfo->irq_flags = IRQF_SHARED;\r\ninfo->handler = priv->irq_handler;\r\n} else {\r\nirq = NO_IRQ;\r\ndev_warn(priv->dev, "ignoring irq, no handler\n");\r\n}\r\n}\r\nif (priv->init)\r\npriv->init(info);\r\nif (uio_register_device(priv->dev, info) != 0) {\r\ndev_err(priv->dev, "UIO registration failed\n");\r\nret = -ENODEV;\r\ngoto out_err2;\r\n}\r\nplatform_set_drvdata(pdev, info);\r\nret = device_create_file(priv->dev, &dev_attr_reg_br);\r\nif (ret)\r\ngoto out_err3;\r\nret = device_create_file(priv->dev, &dev_attr_reg_or);\r\nif (ret)\r\ngoto out_err4;\r\ndev_info(priv->dev,\r\n"eLBC/GPCM device (%s) at 0x%llx, bank %d, irq=%d\n",\r\npriv->name, (unsigned long long)res.start, priv->bank,\r\nirq != NO_IRQ ? irq : -1);\r\nreturn 0;\r\nout_err4:\r\ndevice_remove_file(priv->dev, &dev_attr_reg_br);\r\nout_err3:\r\nplatform_set_drvdata(pdev, NULL);\r\nuio_unregister_device(info);\r\nout_err2:\r\nif (priv->shutdown)\r\npriv->shutdown(info, true);\r\niounmap(info->mem[0].internal_addr);\r\nout_err1:\r\nkfree(info->mem[0].name);\r\nkfree(info);\r\nout_err0:\r\nkfree(uio_name);\r\nkfree(priv);\r\nreturn ret;\r\n}\r\nstatic int uio_fsl_elbc_gpcm_remove(struct platform_device *pdev)\r\n{\r\nstruct uio_info *info = platform_get_drvdata(pdev);\r\nstruct fsl_elbc_gpcm *priv = info->priv;\r\ndevice_remove_file(priv->dev, &dev_attr_reg_or);\r\ndevice_remove_file(priv->dev, &dev_attr_reg_br);\r\nplatform_set_drvdata(pdev, NULL);\r\nuio_unregister_device(info);\r\nif (priv->shutdown)\r\npriv->shutdown(info, false);\r\niounmap(info->mem[0].internal_addr);\r\nkfree(info->mem[0].name);\r\nkfree(info->name);\r\nkfree(info);\r\nkfree(priv);\r\nreturn 0;\r\n}\r\nstatic int __init uio_fsl_elbc_gpcm_init(void)\r\n{\r\nreturn platform_driver_register(&uio_fsl_elbc_gpcm_driver);\r\n}\r\nstatic void __exit uio_fsl_elbc_gpcm_exit(void)\r\n{\r\nplatform_driver_unregister(&uio_fsl_elbc_gpcm_driver);\r\n}
