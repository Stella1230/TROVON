static void lpss_uart_setup(struct lpss_private_data *pdata)\r\n{\r\nunsigned int offset;\r\nu32 val;\r\noffset = pdata->dev_desc->prv_offset + LPSS_TX_INT;\r\nval = readl(pdata->mmio_base + offset);\r\nwritel(val | LPSS_TX_INT_MASK, pdata->mmio_base + offset);\r\nval = readl(pdata->mmio_base + LPSS_UART_CPR);\r\nif (!(val & LPSS_UART_CPR_AFCE)) {\r\noffset = pdata->dev_desc->prv_offset + LPSS_GENERAL;\r\nval = readl(pdata->mmio_base + offset);\r\nval |= LPSS_GENERAL_UART_RTS_OVRD;\r\nwritel(val, pdata->mmio_base + offset);\r\n}\r\n}\r\nstatic void lpss_deassert_reset(struct lpss_private_data *pdata)\r\n{\r\nunsigned int offset;\r\nu32 val;\r\noffset = pdata->dev_desc->prv_offset + LPSS_RESETS;\r\nval = readl(pdata->mmio_base + offset);\r\nval |= LPSS_RESETS_RESET_APB | LPSS_RESETS_RESET_FUNC;\r\nwritel(val, pdata->mmio_base + offset);\r\n}\r\nstatic void byt_i2c_setup(struct lpss_private_data *pdata)\r\n{\r\nlpss_deassert_reset(pdata);\r\nif (readl(pdata->mmio_base + pdata->dev_desc->prv_offset))\r\npdata->fixed_clk_rate = 133000000;\r\nwritel(0, pdata->mmio_base + LPSS_I2C_ENABLE);\r\n}\r\nstatic int is_memory(struct acpi_resource *res, void *not_used)\r\n{\r\nstruct resource r;\r\nreturn !acpi_dev_resource_memory(res, &r);\r\n}\r\nstatic inline void lpt_register_clock_device(void)\r\n{\r\nlpss_clk_dev = platform_device_register_simple("clk-lpt", -1, NULL, 0);\r\n}\r\nstatic int register_device_clock(struct acpi_device *adev,\r\nstruct lpss_private_data *pdata)\r\n{\r\nconst struct lpss_device_desc *dev_desc = pdata->dev_desc;\r\nconst char *devname = dev_name(&adev->dev);\r\nstruct clk *clk = ERR_PTR(-ENODEV);\r\nstruct lpss_clk_data *clk_data;\r\nconst char *parent, *clk_name;\r\nvoid __iomem *prv_base;\r\nif (!lpss_clk_dev)\r\nlpt_register_clock_device();\r\nclk_data = platform_get_drvdata(lpss_clk_dev);\r\nif (!clk_data)\r\nreturn -ENODEV;\r\nclk = clk_data->clk;\r\nif (!pdata->mmio_base\r\n|| pdata->mmio_size < dev_desc->prv_offset + LPSS_CLK_SIZE)\r\nreturn -ENODATA;\r\nparent = clk_data->name;\r\nprv_base = pdata->mmio_base + dev_desc->prv_offset;\r\nif (pdata->fixed_clk_rate) {\r\nclk = clk_register_fixed_rate(NULL, devname, parent, 0,\r\npdata->fixed_clk_rate);\r\ngoto out;\r\n}\r\nif (dev_desc->flags & LPSS_CLK_GATE) {\r\nclk = clk_register_gate(NULL, devname, parent, 0,\r\nprv_base, 0, 0, NULL);\r\nparent = devname;\r\n}\r\nif (dev_desc->flags & LPSS_CLK_DIVIDER) {\r\nif (!readl(prv_base))\r\nwritel(LPSS_CLK_DIVIDER_DEF_MASK, prv_base);\r\nclk_name = kasprintf(GFP_KERNEL, "%s-div", devname);\r\nif (!clk_name)\r\nreturn -ENOMEM;\r\nclk = clk_register_fractional_divider(NULL, clk_name, parent,\r\n0, prv_base,\r\n1, 15, 16, 15, 0, NULL);\r\nparent = clk_name;\r\nclk_name = kasprintf(GFP_KERNEL, "%s-update", devname);\r\nif (!clk_name) {\r\nkfree(parent);\r\nreturn -ENOMEM;\r\n}\r\nclk = clk_register_gate(NULL, clk_name, parent,\r\nCLK_SET_RATE_PARENT | CLK_SET_RATE_GATE,\r\nprv_base, 31, 0, NULL);\r\nkfree(parent);\r\nkfree(clk_name);\r\n}\r\nout:\r\nif (IS_ERR(clk))\r\nreturn PTR_ERR(clk);\r\npdata->clk = clk;\r\nclk_register_clkdev(clk, dev_desc->clk_con_id, devname);\r\nreturn 0;\r\n}\r\nstatic int acpi_lpss_create_device(struct acpi_device *adev,\r\nconst struct acpi_device_id *id)\r\n{\r\nstruct lpss_device_desc *dev_desc;\r\nstruct lpss_private_data *pdata;\r\nstruct resource_entry *rentry;\r\nstruct list_head resource_list;\r\nstruct platform_device *pdev;\r\nint ret;\r\ndev_desc = (struct lpss_device_desc *)id->driver_data;\r\nif (!dev_desc) {\r\npdev = acpi_create_platform_device(adev);\r\nreturn IS_ERR_OR_NULL(pdev) ? PTR_ERR(pdev) : 1;\r\n}\r\npdata = kzalloc(sizeof(*pdata), GFP_KERNEL);\r\nif (!pdata)\r\nreturn -ENOMEM;\r\nINIT_LIST_HEAD(&resource_list);\r\nret = acpi_dev_get_resources(adev, &resource_list, is_memory, NULL);\r\nif (ret < 0)\r\ngoto err_out;\r\nlist_for_each_entry(rentry, &resource_list, node)\r\nif (resource_type(rentry->res) == IORESOURCE_MEM) {\r\nif (dev_desc->prv_size_override)\r\npdata->mmio_size = dev_desc->prv_size_override;\r\nelse\r\npdata->mmio_size = resource_size(rentry->res);\r\npdata->mmio_base = ioremap(rentry->res->start,\r\npdata->mmio_size);\r\nif (!pdata->mmio_base)\r\ngoto err_out;\r\nbreak;\r\n}\r\nacpi_dev_free_resource_list(&resource_list);\r\npdata->dev_desc = dev_desc;\r\nif (dev_desc->setup)\r\ndev_desc->setup(pdata);\r\nif (dev_desc->flags & LPSS_CLK) {\r\nret = register_device_clock(adev, pdata);\r\nif (ret) {\r\nret = 0;\r\ngoto err_out;\r\n}\r\n}\r\nret = acpi_device_fix_up_power(adev);\r\nif (ret) {\r\nret = 0;\r\ngoto err_out;\r\n}\r\nadev->driver_data = pdata;\r\npdev = acpi_create_platform_device(adev);\r\nif (!IS_ERR_OR_NULL(pdev)) {\r\nreturn 1;\r\n}\r\nret = PTR_ERR(pdev);\r\nadev->driver_data = NULL;\r\nerr_out:\r\nkfree(pdata);\r\nreturn ret;\r\n}\r\nstatic u32 __lpss_reg_read(struct lpss_private_data *pdata, unsigned int reg)\r\n{\r\nreturn readl(pdata->mmio_base + pdata->dev_desc->prv_offset + reg);\r\n}\r\nstatic void __lpss_reg_write(u32 val, struct lpss_private_data *pdata,\r\nunsigned int reg)\r\n{\r\nwritel(val, pdata->mmio_base + pdata->dev_desc->prv_offset + reg);\r\n}\r\nstatic int lpss_reg_read(struct device *dev, unsigned int reg, u32 *val)\r\n{\r\nstruct acpi_device *adev;\r\nstruct lpss_private_data *pdata;\r\nunsigned long flags;\r\nint ret;\r\nret = acpi_bus_get_device(ACPI_HANDLE(dev), &adev);\r\nif (WARN_ON(ret))\r\nreturn ret;\r\nspin_lock_irqsave(&dev->power.lock, flags);\r\nif (pm_runtime_suspended(dev)) {\r\nret = -EAGAIN;\r\ngoto out;\r\n}\r\npdata = acpi_driver_data(adev);\r\nif (WARN_ON(!pdata || !pdata->mmio_base)) {\r\nret = -ENODEV;\r\ngoto out;\r\n}\r\n*val = __lpss_reg_read(pdata, reg);\r\nout:\r\nspin_unlock_irqrestore(&dev->power.lock, flags);\r\nreturn ret;\r\n}\r\nstatic ssize_t lpss_ltr_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nu32 ltr_value = 0;\r\nunsigned int reg;\r\nint ret;\r\nreg = strcmp(attr->attr.name, "auto_ltr") ? LPSS_SW_LTR : LPSS_AUTO_LTR;\r\nret = lpss_reg_read(dev, reg, &ltr_value);\r\nif (ret)\r\nreturn ret;\r\nreturn snprintf(buf, PAGE_SIZE, "%08x\n", ltr_value);\r\n}\r\nstatic ssize_t lpss_ltr_mode_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nu32 ltr_mode = 0;\r\nchar *outstr;\r\nint ret;\r\nret = lpss_reg_read(dev, LPSS_GENERAL, &ltr_mode);\r\nif (ret)\r\nreturn ret;\r\noutstr = (ltr_mode & LPSS_GENERAL_LTR_MODE_SW) ? "sw" : "auto";\r\nreturn sprintf(buf, "%s\n", outstr);\r\n}\r\nstatic void acpi_lpss_set_ltr(struct device *dev, s32 val)\r\n{\r\nstruct lpss_private_data *pdata = acpi_driver_data(ACPI_COMPANION(dev));\r\nu32 ltr_mode, ltr_val;\r\nltr_mode = __lpss_reg_read(pdata, LPSS_GENERAL);\r\nif (val < 0) {\r\nif (ltr_mode & LPSS_GENERAL_LTR_MODE_SW) {\r\nltr_mode &= ~LPSS_GENERAL_LTR_MODE_SW;\r\n__lpss_reg_write(ltr_mode, pdata, LPSS_GENERAL);\r\n}\r\nreturn;\r\n}\r\nltr_val = __lpss_reg_read(pdata, LPSS_SW_LTR) & ~LPSS_LTR_SNOOP_MASK;\r\nif (val >= LPSS_LTR_SNOOP_LAT_CUTOFF) {\r\nltr_val |= LPSS_LTR_SNOOP_LAT_32US;\r\nval = LPSS_LTR_MAX_VAL;\r\n} else if (val > LPSS_LTR_MAX_VAL) {\r\nltr_val |= LPSS_LTR_SNOOP_LAT_32US | LPSS_LTR_SNOOP_REQ;\r\nval >>= LPSS_LTR_SNOOP_LAT_SHIFT;\r\n} else {\r\nltr_val |= LPSS_LTR_SNOOP_LAT_1US | LPSS_LTR_SNOOP_REQ;\r\n}\r\nltr_val |= val;\r\n__lpss_reg_write(ltr_val, pdata, LPSS_SW_LTR);\r\nif (!(ltr_mode & LPSS_GENERAL_LTR_MODE_SW)) {\r\nltr_mode |= LPSS_GENERAL_LTR_MODE_SW;\r\n__lpss_reg_write(ltr_mode, pdata, LPSS_GENERAL);\r\n}\r\n}\r\nstatic void acpi_lpss_save_ctx(struct device *dev,\r\nstruct lpss_private_data *pdata)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < LPSS_PRV_REG_COUNT; i++) {\r\nunsigned long offset = i * sizeof(u32);\r\npdata->prv_reg_ctx[i] = __lpss_reg_read(pdata, offset);\r\ndev_dbg(dev, "saving 0x%08x from LPSS reg at offset 0x%02lx\n",\r\npdata->prv_reg_ctx[i], offset);\r\n}\r\n}\r\nstatic void acpi_lpss_restore_ctx(struct device *dev,\r\nstruct lpss_private_data *pdata)\r\n{\r\nunsigned int i;\r\nmsleep(10);\r\nfor (i = 0; i < LPSS_PRV_REG_COUNT; i++) {\r\nunsigned long offset = i * sizeof(u32);\r\n__lpss_reg_write(pdata->prv_reg_ctx[i], pdata, offset);\r\ndev_dbg(dev, "restoring 0x%08x to LPSS reg at offset 0x%02lx\n",\r\npdata->prv_reg_ctx[i], offset);\r\n}\r\n}\r\nstatic int acpi_lpss_suspend_late(struct device *dev)\r\n{\r\nstruct lpss_private_data *pdata = acpi_driver_data(ACPI_COMPANION(dev));\r\nint ret;\r\nret = pm_generic_suspend_late(dev);\r\nif (ret)\r\nreturn ret;\r\nif (pdata->dev_desc->flags & LPSS_SAVE_CTX)\r\nacpi_lpss_save_ctx(dev, pdata);\r\nreturn acpi_dev_suspend_late(dev);\r\n}\r\nstatic int acpi_lpss_resume_early(struct device *dev)\r\n{\r\nstruct lpss_private_data *pdata = acpi_driver_data(ACPI_COMPANION(dev));\r\nint ret;\r\nret = acpi_dev_resume_early(dev);\r\nif (ret)\r\nreturn ret;\r\nif (pdata->dev_desc->flags & LPSS_SAVE_CTX)\r\nacpi_lpss_restore_ctx(dev, pdata);\r\nreturn pm_generic_resume_early(dev);\r\n}\r\nstatic int acpi_lpss_runtime_suspend(struct device *dev)\r\n{\r\nstruct lpss_private_data *pdata = acpi_driver_data(ACPI_COMPANION(dev));\r\nint ret;\r\nret = pm_generic_runtime_suspend(dev);\r\nif (ret)\r\nreturn ret;\r\nif (pdata->dev_desc->flags & LPSS_SAVE_CTX)\r\nacpi_lpss_save_ctx(dev, pdata);\r\nreturn acpi_dev_runtime_suspend(dev);\r\n}\r\nstatic int acpi_lpss_runtime_resume(struct device *dev)\r\n{\r\nstruct lpss_private_data *pdata = acpi_driver_data(ACPI_COMPANION(dev));\r\nint ret;\r\nret = acpi_dev_runtime_resume(dev);\r\nif (ret)\r\nreturn ret;\r\nif (pdata->dev_desc->flags & LPSS_SAVE_CTX)\r\nacpi_lpss_restore_ctx(dev, pdata);\r\nreturn pm_generic_runtime_resume(dev);\r\n}\r\nstatic int acpi_lpss_platform_notify(struct notifier_block *nb,\r\nunsigned long action, void *data)\r\n{\r\nstruct platform_device *pdev = to_platform_device(data);\r\nstruct lpss_private_data *pdata;\r\nstruct acpi_device *adev;\r\nconst struct acpi_device_id *id;\r\nid = acpi_match_device(acpi_lpss_device_ids, &pdev->dev);\r\nif (!id || !id->driver_data)\r\nreturn 0;\r\nif (acpi_bus_get_device(ACPI_HANDLE(&pdev->dev), &adev))\r\nreturn 0;\r\npdata = acpi_driver_data(adev);\r\nif (!pdata)\r\nreturn 0;\r\nif (pdata->mmio_base &&\r\npdata->mmio_size < pdata->dev_desc->prv_offset + LPSS_LTR_SIZE) {\r\ndev_err(&pdev->dev, "MMIO size insufficient to access LTR\n");\r\nreturn 0;\r\n}\r\nswitch (action) {\r\ncase BUS_NOTIFY_ADD_DEVICE:\r\npdev->dev.pm_domain = &acpi_lpss_pm_domain;\r\nif (pdata->dev_desc->flags & LPSS_LTR)\r\nreturn sysfs_create_group(&pdev->dev.kobj,\r\n&lpss_attr_group);\r\nbreak;\r\ncase BUS_NOTIFY_DEL_DEVICE:\r\nif (pdata->dev_desc->flags & LPSS_LTR)\r\nsysfs_remove_group(&pdev->dev.kobj, &lpss_attr_group);\r\npdev->dev.pm_domain = NULL;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic void acpi_lpss_bind(struct device *dev)\r\n{\r\nstruct lpss_private_data *pdata = acpi_driver_data(ACPI_COMPANION(dev));\r\nif (!pdata || !pdata->mmio_base || !(pdata->dev_desc->flags & LPSS_LTR))\r\nreturn;\r\nif (pdata->mmio_size >= pdata->dev_desc->prv_offset + LPSS_LTR_SIZE)\r\ndev->power.set_latency_tolerance = acpi_lpss_set_ltr;\r\nelse\r\ndev_err(dev, "MMIO size insufficient to access LTR\n");\r\n}\r\nstatic void acpi_lpss_unbind(struct device *dev)\r\n{\r\ndev->power.set_latency_tolerance = NULL;\r\n}\r\nvoid __init acpi_lpss_init(void)\r\n{\r\nif (!lpt_clk_init()) {\r\nbus_register_notifier(&platform_bus_type, &acpi_lpss_nb);\r\nacpi_scan_add_handler(&lpss_handler);\r\n}\r\n}\r\nvoid __init acpi_lpss_init(void)\r\n{\r\nacpi_scan_add_handler(&lpss_handler);\r\n}
