static int\r\nnv50_chan_create(struct nvif_object *disp, const u32 *oclass, u8 head,\r\nvoid *data, u32 size, struct nv50_chan *chan)\r\n{\r\nconst u32 handle = (oclass[0] << 16) | head;\r\nu32 sclass[8];\r\nint ret, i;\r\nret = nvif_object_sclass(disp, sclass, ARRAY_SIZE(sclass));\r\nWARN_ON(ret > ARRAY_SIZE(sclass));\r\nif (ret < 0)\r\nreturn ret;\r\nwhile (oclass[0]) {\r\nfor (i = 0; i < ARRAY_SIZE(sclass); i++) {\r\nif (sclass[i] == oclass[0]) {\r\nret = nvif_object_init(disp, NULL, handle,\r\noclass[0], data, size,\r\n&chan->user);\r\nif (ret == 0)\r\nnvif_object_map(&chan->user);\r\nreturn ret;\r\n}\r\n}\r\noclass++;\r\n}\r\nreturn -ENOSYS;\r\n}\r\nstatic void\r\nnv50_chan_destroy(struct nv50_chan *chan)\r\n{\r\nnvif_object_fini(&chan->user);\r\n}\r\nstatic void\r\nnv50_pioc_destroy(struct nv50_pioc *pioc)\r\n{\r\nnv50_chan_destroy(&pioc->base);\r\n}\r\nstatic int\r\nnv50_pioc_create(struct nvif_object *disp, const u32 *oclass, u8 head,\r\nvoid *data, u32 size, struct nv50_pioc *pioc)\r\n{\r\nreturn nv50_chan_create(disp, oclass, head, data, size, &pioc->base);\r\n}\r\nstatic int\r\nnv50_curs_create(struct nvif_object *disp, int head, struct nv50_curs *curs)\r\n{\r\nstruct nv50_disp_cursor_v0 args = {\r\n.head = head,\r\n};\r\nstatic const u32 oclass[] = {\r\nGK104_DISP_CURSOR,\r\nGF110_DISP_CURSOR,\r\nGT214_DISP_CURSOR,\r\nG82_DISP_CURSOR,\r\nNV50_DISP_CURSOR,\r\n0\r\n};\r\nreturn nv50_pioc_create(disp, oclass, head, &args, sizeof(args),\r\n&curs->base);\r\n}\r\nstatic int\r\nnv50_oimm_create(struct nvif_object *disp, int head, struct nv50_oimm *oimm)\r\n{\r\nstruct nv50_disp_cursor_v0 args = {\r\n.head = head,\r\n};\r\nstatic const u32 oclass[] = {\r\nGK104_DISP_OVERLAY,\r\nGF110_DISP_OVERLAY,\r\nGT214_DISP_OVERLAY,\r\nG82_DISP_OVERLAY,\r\nNV50_DISP_OVERLAY,\r\n0\r\n};\r\nreturn nv50_pioc_create(disp, oclass, head, &args, sizeof(args),\r\n&oimm->base);\r\n}\r\nstatic void\r\nnv50_dmac_destroy(struct nv50_dmac *dmac, struct nvif_object *disp)\r\n{\r\nnvif_object_fini(&dmac->vram);\r\nnvif_object_fini(&dmac->sync);\r\nnv50_chan_destroy(&dmac->base);\r\nif (dmac->ptr) {\r\nstruct pci_dev *pdev = nvxx_device(nvif_device(disp))->pdev;\r\npci_free_consistent(pdev, PAGE_SIZE, dmac->ptr, dmac->handle);\r\n}\r\n}\r\nstatic int\r\nnv50_dmac_create(struct nvif_object *disp, const u32 *oclass, u8 head,\r\nvoid *data, u32 size, u64 syncbuf,\r\nstruct nv50_dmac *dmac)\r\n{\r\nstruct nvif_device *device = nvif_device(disp);\r\nstruct nv50_disp_core_channel_dma_v0 *args = data;\r\nstruct nvif_object pushbuf;\r\nint ret;\r\nmutex_init(&dmac->lock);\r\ndmac->ptr = pci_alloc_consistent(nvxx_device(device)->pdev,\r\nPAGE_SIZE, &dmac->handle);\r\nif (!dmac->ptr)\r\nreturn -ENOMEM;\r\nret = nvif_object_init(nvif_object(device), NULL,\r\nargs->pushbuf, NV_DMA_FROM_MEMORY,\r\n&(struct nv_dma_v0) {\r\n.target = NV_DMA_V0_TARGET_PCI_US,\r\n.access = NV_DMA_V0_ACCESS_RD,\r\n.start = dmac->handle + 0x0000,\r\n.limit = dmac->handle + 0x0fff,\r\n}, sizeof(struct nv_dma_v0), &pushbuf);\r\nif (ret)\r\nreturn ret;\r\nret = nv50_chan_create(disp, oclass, head, data, size, &dmac->base);\r\nnvif_object_fini(&pushbuf);\r\nif (ret)\r\nreturn ret;\r\nret = nvif_object_init(&dmac->base.user, NULL, 0xf0000000,\r\nNV_DMA_IN_MEMORY,\r\n&(struct nv_dma_v0) {\r\n.target = NV_DMA_V0_TARGET_VRAM,\r\n.access = NV_DMA_V0_ACCESS_RDWR,\r\n.start = syncbuf + 0x0000,\r\n.limit = syncbuf + 0x0fff,\r\n}, sizeof(struct nv_dma_v0),\r\n&dmac->sync);\r\nif (ret)\r\nreturn ret;\r\nret = nvif_object_init(&dmac->base.user, NULL, 0xf0000001,\r\nNV_DMA_IN_MEMORY,\r\n&(struct nv_dma_v0) {\r\n.target = NV_DMA_V0_TARGET_VRAM,\r\n.access = NV_DMA_V0_ACCESS_RDWR,\r\n.start = 0,\r\n.limit = device->info.ram_user - 1,\r\n}, sizeof(struct nv_dma_v0),\r\n&dmac->vram);\r\nif (ret)\r\nreturn ret;\r\nreturn ret;\r\n}\r\nstatic int\r\nnv50_core_create(struct nvif_object *disp, u64 syncbuf, struct nv50_mast *core)\r\n{\r\nstruct nv50_disp_core_channel_dma_v0 args = {\r\n.pushbuf = 0xb0007d00,\r\n};\r\nstatic const u32 oclass[] = {\r\nGM204_DISP_CORE_CHANNEL_DMA,\r\nGM107_DISP_CORE_CHANNEL_DMA,\r\nGK110_DISP_CORE_CHANNEL_DMA,\r\nGK104_DISP_CORE_CHANNEL_DMA,\r\nGF110_DISP_CORE_CHANNEL_DMA,\r\nGT214_DISP_CORE_CHANNEL_DMA,\r\nGT206_DISP_CORE_CHANNEL_DMA,\r\nGT200_DISP_CORE_CHANNEL_DMA,\r\nG82_DISP_CORE_CHANNEL_DMA,\r\nNV50_DISP_CORE_CHANNEL_DMA,\r\n0\r\n};\r\nreturn nv50_dmac_create(disp, oclass, 0, &args, sizeof(args), syncbuf,\r\n&core->base);\r\n}\r\nstatic int\r\nnv50_base_create(struct nvif_object *disp, int head, u64 syncbuf,\r\nstruct nv50_sync *base)\r\n{\r\nstruct nv50_disp_base_channel_dma_v0 args = {\r\n.pushbuf = 0xb0007c00 | head,\r\n.head = head,\r\n};\r\nstatic const u32 oclass[] = {\r\nGK110_DISP_BASE_CHANNEL_DMA,\r\nGK104_DISP_BASE_CHANNEL_DMA,\r\nGF110_DISP_BASE_CHANNEL_DMA,\r\nGT214_DISP_BASE_CHANNEL_DMA,\r\nGT200_DISP_BASE_CHANNEL_DMA,\r\nG82_DISP_BASE_CHANNEL_DMA,\r\nNV50_DISP_BASE_CHANNEL_DMA,\r\n0\r\n};\r\nreturn nv50_dmac_create(disp, oclass, head, &args, sizeof(args),\r\nsyncbuf, &base->base);\r\n}\r\nstatic int\r\nnv50_ovly_create(struct nvif_object *disp, int head, u64 syncbuf,\r\nstruct nv50_ovly *ovly)\r\n{\r\nstruct nv50_disp_overlay_channel_dma_v0 args = {\r\n.pushbuf = 0xb0007e00 | head,\r\n.head = head,\r\n};\r\nstatic const u32 oclass[] = {\r\nGK104_DISP_OVERLAY_CONTROL_DMA,\r\nGF110_DISP_OVERLAY_CONTROL_DMA,\r\nGT214_DISP_OVERLAY_CHANNEL_DMA,\r\nGT200_DISP_OVERLAY_CHANNEL_DMA,\r\nG82_DISP_OVERLAY_CHANNEL_DMA,\r\nNV50_DISP_OVERLAY_CHANNEL_DMA,\r\n0\r\n};\r\nreturn nv50_dmac_create(disp, oclass, head, &args, sizeof(args),\r\nsyncbuf, &ovly->base);\r\n}\r\nstatic struct nv50_disp *\r\nnv50_disp(struct drm_device *dev)\r\n{\r\nreturn nouveau_display(dev)->priv;\r\n}\r\nstatic struct drm_crtc *\r\nnv50_display_crtc_get(struct drm_encoder *encoder)\r\n{\r\nreturn nouveau_encoder(encoder)->crtc;\r\n}\r\nstatic u32 *\r\nevo_wait(void *evoc, int nr)\r\n{\r\nstruct nv50_dmac *dmac = evoc;\r\nu32 put = nvif_rd32(&dmac->base.user, 0x0000) / 4;\r\nmutex_lock(&dmac->lock);\r\nif (put + nr >= (PAGE_SIZE / 4) - 8) {\r\ndmac->ptr[put] = 0x20000000;\r\nnvif_wr32(&dmac->base.user, 0x0000, 0x00000000);\r\nif (!nvxx_wait(&dmac->base.user, 0x0004, ~0, 0x00000000)) {\r\nmutex_unlock(&dmac->lock);\r\nnv_error(nvxx_object(&dmac->base.user), "channel stalled\n");\r\nreturn NULL;\r\n}\r\nput = 0;\r\n}\r\nreturn dmac->ptr + put;\r\n}\r\nstatic void\r\nevo_kick(u32 *push, void *evoc)\r\n{\r\nstruct nv50_dmac *dmac = evoc;\r\nnvif_wr32(&dmac->base.user, 0x0000, (push - dmac->ptr) << 2);\r\nmutex_unlock(&dmac->lock);\r\n}\r\nstatic bool\r\nevo_sync_wait(void *data)\r\n{\r\nif (nouveau_bo_rd32(data, EVO_MAST_NTFY) != 0x00000000)\r\nreturn true;\r\nusleep_range(1, 2);\r\nreturn false;\r\n}\r\nstatic int\r\nevo_sync(struct drm_device *dev)\r\n{\r\nstruct nvif_device *device = &nouveau_drm(dev)->device;\r\nstruct nv50_disp *disp = nv50_disp(dev);\r\nstruct nv50_mast *mast = nv50_mast(dev);\r\nu32 *push = evo_wait(mast, 8);\r\nif (push) {\r\nnouveau_bo_wr32(disp->sync, EVO_MAST_NTFY, 0x00000000);\r\nevo_mthd(push, 0x0084, 1);\r\nevo_data(push, 0x80000000 | EVO_MAST_NTFY);\r\nevo_mthd(push, 0x0080, 2);\r\nevo_data(push, 0x00000000);\r\nevo_data(push, 0x00000000);\r\nevo_kick(push, mast);\r\nif (nv_wait_cb(nvxx_device(device), evo_sync_wait, disp->sync))\r\nreturn 0;\r\n}\r\nreturn -EBUSY;\r\n}\r\nstruct nouveau_bo *\r\nnv50_display_crtc_sema(struct drm_device *dev, int crtc)\r\n{\r\nreturn nv50_disp(dev)->sync;\r\n}\r\nstatic bool\r\nnv50_display_flip_wait(void *data)\r\n{\r\nstruct nv50_display_flip *flip = data;\r\nif (nouveau_bo_rd32(flip->disp->sync, flip->chan->addr / 4) ==\r\nflip->chan->data)\r\nreturn true;\r\nusleep_range(1, 2);\r\nreturn false;\r\n}\r\nvoid\r\nnv50_display_flip_stop(struct drm_crtc *crtc)\r\n{\r\nstruct nvif_device *device = &nouveau_drm(crtc->dev)->device;\r\nstruct nv50_display_flip flip = {\r\n.disp = nv50_disp(crtc->dev),\r\n.chan = nv50_sync(crtc),\r\n};\r\nu32 *push;\r\npush = evo_wait(flip.chan, 8);\r\nif (push) {\r\nevo_mthd(push, 0x0084, 1);\r\nevo_data(push, 0x00000000);\r\nevo_mthd(push, 0x0094, 1);\r\nevo_data(push, 0x00000000);\r\nevo_mthd(push, 0x00c0, 1);\r\nevo_data(push, 0x00000000);\r\nevo_mthd(push, 0x0080, 1);\r\nevo_data(push, 0x00000000);\r\nevo_kick(push, flip.chan);\r\n}\r\nnv_wait_cb(nvxx_device(device), nv50_display_flip_wait, &flip);\r\n}\r\nint\r\nnv50_display_flip_next(struct drm_crtc *crtc, struct drm_framebuffer *fb,\r\nstruct nouveau_channel *chan, u32 swap_interval)\r\n{\r\nstruct nouveau_framebuffer *nv_fb = nouveau_framebuffer(fb);\r\nstruct nouveau_crtc *nv_crtc = nouveau_crtc(crtc);\r\nstruct nv50_head *head = nv50_head(crtc);\r\nstruct nv50_sync *sync = nv50_sync(crtc);\r\nu32 *push;\r\nint ret;\r\nif (crtc->primary->fb->width != fb->width ||\r\ncrtc->primary->fb->height != fb->height)\r\nreturn -EINVAL;\r\nswap_interval <<= 4;\r\nif (swap_interval == 0)\r\nswap_interval |= 0x100;\r\nif (chan == NULL)\r\nevo_sync(crtc->dev);\r\npush = evo_wait(sync, 128);\r\nif (unlikely(push == NULL))\r\nreturn -EBUSY;\r\nif (chan && chan->object->oclass < G82_CHANNEL_GPFIFO) {\r\nret = RING_SPACE(chan, 8);\r\nif (ret)\r\nreturn ret;\r\nBEGIN_NV04(chan, 0, NV11_SUBCHAN_DMA_SEMAPHORE, 2);\r\nOUT_RING (chan, NvEvoSema0 + nv_crtc->index);\r\nOUT_RING (chan, sync->addr ^ 0x10);\r\nBEGIN_NV04(chan, 0, NV11_SUBCHAN_SEMAPHORE_RELEASE, 1);\r\nOUT_RING (chan, sync->data + 1);\r\nBEGIN_NV04(chan, 0, NV11_SUBCHAN_SEMAPHORE_OFFSET, 2);\r\nOUT_RING (chan, sync->addr);\r\nOUT_RING (chan, sync->data);\r\n} else\r\nif (chan && chan->object->oclass < FERMI_CHANNEL_GPFIFO) {\r\nu64 addr = nv84_fence_crtc(chan, nv_crtc->index) + sync->addr;\r\nret = RING_SPACE(chan, 12);\r\nif (ret)\r\nreturn ret;\r\nBEGIN_NV04(chan, 0, NV11_SUBCHAN_DMA_SEMAPHORE, 1);\r\nOUT_RING (chan, chan->vram.handle);\r\nBEGIN_NV04(chan, 0, NV84_SUBCHAN_SEMAPHORE_ADDRESS_HIGH, 4);\r\nOUT_RING (chan, upper_32_bits(addr ^ 0x10));\r\nOUT_RING (chan, lower_32_bits(addr ^ 0x10));\r\nOUT_RING (chan, sync->data + 1);\r\nOUT_RING (chan, NV84_SUBCHAN_SEMAPHORE_TRIGGER_WRITE_LONG);\r\nBEGIN_NV04(chan, 0, NV84_SUBCHAN_SEMAPHORE_ADDRESS_HIGH, 4);\r\nOUT_RING (chan, upper_32_bits(addr));\r\nOUT_RING (chan, lower_32_bits(addr));\r\nOUT_RING (chan, sync->data);\r\nOUT_RING (chan, NV84_SUBCHAN_SEMAPHORE_TRIGGER_ACQUIRE_EQUAL);\r\n} else\r\nif (chan) {\r\nu64 addr = nv84_fence_crtc(chan, nv_crtc->index) + sync->addr;\r\nret = RING_SPACE(chan, 10);\r\nif (ret)\r\nreturn ret;\r\nBEGIN_NVC0(chan, 0, NV84_SUBCHAN_SEMAPHORE_ADDRESS_HIGH, 4);\r\nOUT_RING (chan, upper_32_bits(addr ^ 0x10));\r\nOUT_RING (chan, lower_32_bits(addr ^ 0x10));\r\nOUT_RING (chan, sync->data + 1);\r\nOUT_RING (chan, NV84_SUBCHAN_SEMAPHORE_TRIGGER_WRITE_LONG |\r\nNVC0_SUBCHAN_SEMAPHORE_TRIGGER_YIELD);\r\nBEGIN_NVC0(chan, 0, NV84_SUBCHAN_SEMAPHORE_ADDRESS_HIGH, 4);\r\nOUT_RING (chan, upper_32_bits(addr));\r\nOUT_RING (chan, lower_32_bits(addr));\r\nOUT_RING (chan, sync->data);\r\nOUT_RING (chan, NV84_SUBCHAN_SEMAPHORE_TRIGGER_ACQUIRE_EQUAL |\r\nNVC0_SUBCHAN_SEMAPHORE_TRIGGER_YIELD);\r\n}\r\nif (chan) {\r\nsync->addr ^= 0x10;\r\nsync->data++;\r\nFIRE_RING (chan);\r\n}\r\nevo_mthd(push, 0x0100, 1);\r\nevo_data(push, 0xfffe0000);\r\nevo_mthd(push, 0x0084, 1);\r\nevo_data(push, swap_interval);\r\nif (!(swap_interval & 0x00000100)) {\r\nevo_mthd(push, 0x00e0, 1);\r\nevo_data(push, 0x40000000);\r\n}\r\nevo_mthd(push, 0x0088, 4);\r\nevo_data(push, sync->addr);\r\nevo_data(push, sync->data++);\r\nevo_data(push, sync->data);\r\nevo_data(push, sync->base.sync.handle);\r\nevo_mthd(push, 0x00a0, 2);\r\nevo_data(push, 0x00000000);\r\nevo_data(push, 0x00000000);\r\nevo_mthd(push, 0x00c0, 1);\r\nevo_data(push, nv_fb->r_handle);\r\nevo_mthd(push, 0x0110, 2);\r\nevo_data(push, 0x00000000);\r\nevo_data(push, 0x00000000);\r\nif (nv50_vers(sync) < GF110_DISP_BASE_CHANNEL_DMA) {\r\nevo_mthd(push, 0x0800, 5);\r\nevo_data(push, nv_fb->nvbo->bo.offset >> 8);\r\nevo_data(push, 0);\r\nevo_data(push, (fb->height << 16) | fb->width);\r\nevo_data(push, nv_fb->r_pitch);\r\nevo_data(push, nv_fb->r_format);\r\n} else {\r\nevo_mthd(push, 0x0400, 5);\r\nevo_data(push, nv_fb->nvbo->bo.offset >> 8);\r\nevo_data(push, 0);\r\nevo_data(push, (fb->height << 16) | fb->width);\r\nevo_data(push, nv_fb->r_pitch);\r\nevo_data(push, nv_fb->r_format);\r\n}\r\nevo_mthd(push, 0x0080, 1);\r\nevo_data(push, 0x00000000);\r\nevo_kick(push, sync);\r\nnouveau_bo_ref(nv_fb->nvbo, &head->image);\r\nreturn 0;\r\n}\r\nstatic int\r\nnv50_crtc_set_dither(struct nouveau_crtc *nv_crtc, bool update)\r\n{\r\nstruct nv50_mast *mast = nv50_mast(nv_crtc->base.dev);\r\nstruct nouveau_connector *nv_connector;\r\nstruct drm_connector *connector;\r\nu32 *push, mode = 0x00;\r\nnv_connector = nouveau_crtc_connector_get(nv_crtc);\r\nconnector = &nv_connector->base;\r\nif (nv_connector->dithering_mode == DITHERING_MODE_AUTO) {\r\nif (nv_crtc->base.primary->fb->depth > connector->display_info.bpc * 3)\r\nmode = DITHERING_MODE_DYNAMIC2X2;\r\n} else {\r\nmode = nv_connector->dithering_mode;\r\n}\r\nif (nv_connector->dithering_depth == DITHERING_DEPTH_AUTO) {\r\nif (connector->display_info.bpc >= 8)\r\nmode |= DITHERING_DEPTH_8BPC;\r\n} else {\r\nmode |= nv_connector->dithering_depth;\r\n}\r\npush = evo_wait(mast, 4);\r\nif (push) {\r\nif (nv50_vers(mast) < GF110_DISP_CORE_CHANNEL_DMA) {\r\nevo_mthd(push, 0x08a0 + (nv_crtc->index * 0x0400), 1);\r\nevo_data(push, mode);\r\n} else\r\nif (nv50_vers(mast) < GK104_DISP_CORE_CHANNEL_DMA) {\r\nevo_mthd(push, 0x0490 + (nv_crtc->index * 0x0300), 1);\r\nevo_data(push, mode);\r\n} else {\r\nevo_mthd(push, 0x04a0 + (nv_crtc->index * 0x0300), 1);\r\nevo_data(push, mode);\r\n}\r\nif (update) {\r\nevo_mthd(push, 0x0080, 1);\r\nevo_data(push, 0x00000000);\r\n}\r\nevo_kick(push, mast);\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nnv50_crtc_set_scale(struct nouveau_crtc *nv_crtc, bool update)\r\n{\r\nstruct nv50_mast *mast = nv50_mast(nv_crtc->base.dev);\r\nstruct drm_display_mode *omode, *umode = &nv_crtc->base.mode;\r\nstruct drm_crtc *crtc = &nv_crtc->base;\r\nstruct nouveau_connector *nv_connector;\r\nint mode = DRM_MODE_SCALE_NONE;\r\nu32 oX, oY, *push;\r\nnv_connector = nouveau_crtc_connector_get(nv_crtc);\r\nif (nv_connector && nv_connector->native_mode) {\r\nmode = nv_connector->scaling_mode;\r\nif (nv_connector->scaling_full)\r\nmode = DRM_MODE_SCALE_FULLSCREEN;\r\n}\r\nif (mode != DRM_MODE_SCALE_NONE)\r\nomode = nv_connector->native_mode;\r\nelse\r\nomode = umode;\r\noX = omode->hdisplay;\r\noY = omode->vdisplay;\r\nif (omode->flags & DRM_MODE_FLAG_DBLSCAN)\r\noY *= 2;\r\nif (nv_connector && ( nv_connector->underscan == UNDERSCAN_ON ||\r\n(nv_connector->underscan == UNDERSCAN_AUTO &&\r\nnv_connector->edid &&\r\ndrm_detect_hdmi_monitor(nv_connector->edid)))) {\r\nu32 bX = nv_connector->underscan_hborder;\r\nu32 bY = nv_connector->underscan_vborder;\r\nu32 aspect = (oY << 19) / oX;\r\nif (bX) {\r\noX -= (bX * 2);\r\nif (bY) oY -= (bY * 2);\r\nelse oY = ((oX * aspect) + (aspect / 2)) >> 19;\r\n} else {\r\noX -= (oX >> 4) + 32;\r\nif (bY) oY -= (bY * 2);\r\nelse oY = ((oX * aspect) + (aspect / 2)) >> 19;\r\n}\r\n}\r\nswitch (mode) {\r\ncase DRM_MODE_SCALE_CENTER:\r\noX = min((u32)umode->hdisplay, oX);\r\noY = min((u32)umode->vdisplay, oY);\r\ncase DRM_MODE_SCALE_ASPECT:\r\nif (oY < oX) {\r\nu32 aspect = (umode->hdisplay << 19) / umode->vdisplay;\r\noX = ((oY * aspect) + (aspect / 2)) >> 19;\r\n} else {\r\nu32 aspect = (umode->vdisplay << 19) / umode->hdisplay;\r\noY = ((oX * aspect) + (aspect / 2)) >> 19;\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\npush = evo_wait(mast, 8);\r\nif (push) {\r\nif (nv50_vers(mast) < GF110_DISP_CORE_CHANNEL_DMA) {\r\nevo_mthd(push, 0x08d8 + (nv_crtc->index * 0x400), 2);\r\nevo_data(push, (oY << 16) | oX);\r\nevo_data(push, (oY << 16) | oX);\r\nevo_mthd(push, 0x08a4 + (nv_crtc->index * 0x400), 1);\r\nevo_data(push, 0x00000000);\r\nevo_mthd(push, 0x08c8 + (nv_crtc->index * 0x400), 1);\r\nevo_data(push, umode->vdisplay << 16 | umode->hdisplay);\r\n} else {\r\nevo_mthd(push, 0x04c0 + (nv_crtc->index * 0x300), 3);\r\nevo_data(push, (oY << 16) | oX);\r\nevo_data(push, (oY << 16) | oX);\r\nevo_data(push, (oY << 16) | oX);\r\nevo_mthd(push, 0x0494 + (nv_crtc->index * 0x300), 1);\r\nevo_data(push, 0x00000000);\r\nevo_mthd(push, 0x04b8 + (nv_crtc->index * 0x300), 1);\r\nevo_data(push, umode->vdisplay << 16 | umode->hdisplay);\r\n}\r\nevo_kick(push, mast);\r\nif (update) {\r\nnv50_display_flip_stop(crtc);\r\nnv50_display_flip_next(crtc, crtc->primary->fb,\r\nNULL, 1);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nnv50_crtc_set_raster_vblank_dmi(struct nouveau_crtc *nv_crtc, u32 usec)\r\n{\r\nstruct nv50_mast *mast = nv50_mast(nv_crtc->base.dev);\r\nu32 *push;\r\npush = evo_wait(mast, 8);\r\nif (!push)\r\nreturn -ENOMEM;\r\nevo_mthd(push, 0x0828 + (nv_crtc->index * 0x400), 1);\r\nevo_data(push, usec);\r\nevo_kick(push, mast);\r\nreturn 0;\r\n}\r\nstatic int\r\nnv50_crtc_set_color_vibrance(struct nouveau_crtc *nv_crtc, bool update)\r\n{\r\nstruct nv50_mast *mast = nv50_mast(nv_crtc->base.dev);\r\nu32 *push, hue, vib;\r\nint adj;\r\nadj = (nv_crtc->color_vibrance > 0) ? 50 : 0;\r\nvib = ((nv_crtc->color_vibrance * 2047 + adj) / 100) & 0xfff;\r\nhue = ((nv_crtc->vibrant_hue * 2047) / 100) & 0xfff;\r\npush = evo_wait(mast, 16);\r\nif (push) {\r\nif (nv50_vers(mast) < GF110_DISP_CORE_CHANNEL_DMA) {\r\nevo_mthd(push, 0x08a8 + (nv_crtc->index * 0x400), 1);\r\nevo_data(push, (hue << 20) | (vib << 8));\r\n} else {\r\nevo_mthd(push, 0x0498 + (nv_crtc->index * 0x300), 1);\r\nevo_data(push, (hue << 20) | (vib << 8));\r\n}\r\nif (update) {\r\nevo_mthd(push, 0x0080, 1);\r\nevo_data(push, 0x00000000);\r\n}\r\nevo_kick(push, mast);\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nnv50_crtc_set_image(struct nouveau_crtc *nv_crtc, struct drm_framebuffer *fb,\r\nint x, int y, bool update)\r\n{\r\nstruct nouveau_framebuffer *nvfb = nouveau_framebuffer(fb);\r\nstruct nv50_mast *mast = nv50_mast(nv_crtc->base.dev);\r\nu32 *push;\r\npush = evo_wait(mast, 16);\r\nif (push) {\r\nif (nv50_vers(mast) < GF110_DISP_CORE_CHANNEL_DMA) {\r\nevo_mthd(push, 0x0860 + (nv_crtc->index * 0x400), 1);\r\nevo_data(push, nvfb->nvbo->bo.offset >> 8);\r\nevo_mthd(push, 0x0868 + (nv_crtc->index * 0x400), 3);\r\nevo_data(push, (fb->height << 16) | fb->width);\r\nevo_data(push, nvfb->r_pitch);\r\nevo_data(push, nvfb->r_format);\r\nevo_mthd(push, 0x08c0 + (nv_crtc->index * 0x400), 1);\r\nevo_data(push, (y << 16) | x);\r\nif (nv50_vers(mast) > NV50_DISP_CORE_CHANNEL_DMA) {\r\nevo_mthd(push, 0x0874 + (nv_crtc->index * 0x400), 1);\r\nevo_data(push, nvfb->r_handle);\r\n}\r\n} else {\r\nevo_mthd(push, 0x0460 + (nv_crtc->index * 0x300), 1);\r\nevo_data(push, nvfb->nvbo->bo.offset >> 8);\r\nevo_mthd(push, 0x0468 + (nv_crtc->index * 0x300), 4);\r\nevo_data(push, (fb->height << 16) | fb->width);\r\nevo_data(push, nvfb->r_pitch);\r\nevo_data(push, nvfb->r_format);\r\nevo_data(push, nvfb->r_handle);\r\nevo_mthd(push, 0x04b0 + (nv_crtc->index * 0x300), 1);\r\nevo_data(push, (y << 16) | x);\r\n}\r\nif (update) {\r\nevo_mthd(push, 0x0080, 1);\r\nevo_data(push, 0x00000000);\r\n}\r\nevo_kick(push, mast);\r\n}\r\nnv_crtc->fb.handle = nvfb->r_handle;\r\nreturn 0;\r\n}\r\nstatic void\r\nnv50_crtc_cursor_show(struct nouveau_crtc *nv_crtc)\r\n{\r\nstruct nv50_mast *mast = nv50_mast(nv_crtc->base.dev);\r\nu32 *push = evo_wait(mast, 16);\r\nif (push) {\r\nif (nv50_vers(mast) < G82_DISP_CORE_CHANNEL_DMA) {\r\nevo_mthd(push, 0x0880 + (nv_crtc->index * 0x400), 2);\r\nevo_data(push, 0x85000000);\r\nevo_data(push, nv_crtc->cursor.nvbo->bo.offset >> 8);\r\n} else\r\nif (nv50_vers(mast) < GF110_DISP_CORE_CHANNEL_DMA) {\r\nevo_mthd(push, 0x0880 + (nv_crtc->index * 0x400), 2);\r\nevo_data(push, 0x85000000);\r\nevo_data(push, nv_crtc->cursor.nvbo->bo.offset >> 8);\r\nevo_mthd(push, 0x089c + (nv_crtc->index * 0x400), 1);\r\nevo_data(push, mast->base.vram.handle);\r\n} else {\r\nevo_mthd(push, 0x0480 + (nv_crtc->index * 0x300), 2);\r\nevo_data(push, 0x85000000);\r\nevo_data(push, nv_crtc->cursor.nvbo->bo.offset >> 8);\r\nevo_mthd(push, 0x048c + (nv_crtc->index * 0x300), 1);\r\nevo_data(push, mast->base.vram.handle);\r\n}\r\nevo_kick(push, mast);\r\n}\r\nnv_crtc->cursor.visible = true;\r\n}\r\nstatic void\r\nnv50_crtc_cursor_hide(struct nouveau_crtc *nv_crtc)\r\n{\r\nstruct nv50_mast *mast = nv50_mast(nv_crtc->base.dev);\r\nu32 *push = evo_wait(mast, 16);\r\nif (push) {\r\nif (nv50_vers(mast) < G82_DISP_CORE_CHANNEL_DMA) {\r\nevo_mthd(push, 0x0880 + (nv_crtc->index * 0x400), 1);\r\nevo_data(push, 0x05000000);\r\n} else\r\nif (nv50_vers(mast) < GF110_DISP_CORE_CHANNEL_DMA) {\r\nevo_mthd(push, 0x0880 + (nv_crtc->index * 0x400), 1);\r\nevo_data(push, 0x05000000);\r\nevo_mthd(push, 0x089c + (nv_crtc->index * 0x400), 1);\r\nevo_data(push, 0x00000000);\r\n} else {\r\nevo_mthd(push, 0x0480 + (nv_crtc->index * 0x300), 1);\r\nevo_data(push, 0x05000000);\r\nevo_mthd(push, 0x048c + (nv_crtc->index * 0x300), 1);\r\nevo_data(push, 0x00000000);\r\n}\r\nevo_kick(push, mast);\r\n}\r\nnv_crtc->cursor.visible = false;\r\n}\r\nstatic void\r\nnv50_crtc_cursor_show_hide(struct nouveau_crtc *nv_crtc, bool show, bool update)\r\n{\r\nstruct nv50_mast *mast = nv50_mast(nv_crtc->base.dev);\r\nif (show && nv_crtc->cursor.nvbo)\r\nnv50_crtc_cursor_show(nv_crtc);\r\nelse\r\nnv50_crtc_cursor_hide(nv_crtc);\r\nif (update) {\r\nu32 *push = evo_wait(mast, 2);\r\nif (push) {\r\nevo_mthd(push, 0x0080, 1);\r\nevo_data(push, 0x00000000);\r\nevo_kick(push, mast);\r\n}\r\n}\r\n}\r\nstatic void\r\nnv50_crtc_dpms(struct drm_crtc *crtc, int mode)\r\n{\r\n}\r\nstatic void\r\nnv50_crtc_prepare(struct drm_crtc *crtc)\r\n{\r\nstruct nouveau_crtc *nv_crtc = nouveau_crtc(crtc);\r\nstruct nv50_mast *mast = nv50_mast(crtc->dev);\r\nu32 *push;\r\nnv50_display_flip_stop(crtc);\r\npush = evo_wait(mast, 6);\r\nif (push) {\r\nif (nv50_vers(mast) < G82_DISP_CORE_CHANNEL_DMA) {\r\nevo_mthd(push, 0x0874 + (nv_crtc->index * 0x400), 1);\r\nevo_data(push, 0x00000000);\r\nevo_mthd(push, 0x0840 + (nv_crtc->index * 0x400), 1);\r\nevo_data(push, 0x40000000);\r\n} else\r\nif (nv50_vers(mast) < GF110_DISP_CORE_CHANNEL_DMA) {\r\nevo_mthd(push, 0x0874 + (nv_crtc->index * 0x400), 1);\r\nevo_data(push, 0x00000000);\r\nevo_mthd(push, 0x0840 + (nv_crtc->index * 0x400), 1);\r\nevo_data(push, 0x40000000);\r\nevo_mthd(push, 0x085c + (nv_crtc->index * 0x400), 1);\r\nevo_data(push, 0x00000000);\r\n} else {\r\nevo_mthd(push, 0x0474 + (nv_crtc->index * 0x300), 1);\r\nevo_data(push, 0x00000000);\r\nevo_mthd(push, 0x0440 + (nv_crtc->index * 0x300), 1);\r\nevo_data(push, 0x03000000);\r\nevo_mthd(push, 0x045c + (nv_crtc->index * 0x300), 1);\r\nevo_data(push, 0x00000000);\r\n}\r\nevo_kick(push, mast);\r\n}\r\nnv50_crtc_cursor_show_hide(nv_crtc, false, false);\r\n}\r\nstatic void\r\nnv50_crtc_commit(struct drm_crtc *crtc)\r\n{\r\nstruct nouveau_crtc *nv_crtc = nouveau_crtc(crtc);\r\nstruct nv50_mast *mast = nv50_mast(crtc->dev);\r\nu32 *push;\r\npush = evo_wait(mast, 32);\r\nif (push) {\r\nif (nv50_vers(mast) < G82_DISP_CORE_CHANNEL_DMA) {\r\nevo_mthd(push, 0x0874 + (nv_crtc->index * 0x400), 1);\r\nevo_data(push, nv_crtc->fb.handle);\r\nevo_mthd(push, 0x0840 + (nv_crtc->index * 0x400), 2);\r\nevo_data(push, 0xc0000000);\r\nevo_data(push, nv_crtc->lut.nvbo->bo.offset >> 8);\r\n} else\r\nif (nv50_vers(mast) < GF110_DISP_CORE_CHANNEL_DMA) {\r\nevo_mthd(push, 0x0874 + (nv_crtc->index * 0x400), 1);\r\nevo_data(push, nv_crtc->fb.handle);\r\nevo_mthd(push, 0x0840 + (nv_crtc->index * 0x400), 2);\r\nevo_data(push, 0xc0000000);\r\nevo_data(push, nv_crtc->lut.nvbo->bo.offset >> 8);\r\nevo_mthd(push, 0x085c + (nv_crtc->index * 0x400), 1);\r\nevo_data(push, mast->base.vram.handle);\r\n} else {\r\nevo_mthd(push, 0x0474 + (nv_crtc->index * 0x300), 1);\r\nevo_data(push, nv_crtc->fb.handle);\r\nevo_mthd(push, 0x0440 + (nv_crtc->index * 0x300), 4);\r\nevo_data(push, 0x83000000);\r\nevo_data(push, nv_crtc->lut.nvbo->bo.offset >> 8);\r\nevo_data(push, 0x00000000);\r\nevo_data(push, 0x00000000);\r\nevo_mthd(push, 0x045c + (nv_crtc->index * 0x300), 1);\r\nevo_data(push, mast->base.vram.handle);\r\nevo_mthd(push, 0x0430 + (nv_crtc->index * 0x300), 1);\r\nevo_data(push, 0xffffff00);\r\n}\r\nevo_kick(push, mast);\r\n}\r\nnv50_crtc_cursor_show_hide(nv_crtc, true, true);\r\nnv50_display_flip_next(crtc, crtc->primary->fb, NULL, 1);\r\n}\r\nstatic bool\r\nnv50_crtc_mode_fixup(struct drm_crtc *crtc, const struct drm_display_mode *mode,\r\nstruct drm_display_mode *adjusted_mode)\r\n{\r\ndrm_mode_set_crtcinfo(adjusted_mode, CRTC_INTERLACE_HALVE_V);\r\nreturn true;\r\n}\r\nstatic int\r\nnv50_crtc_swap_fbs(struct drm_crtc *crtc, struct drm_framebuffer *old_fb)\r\n{\r\nstruct nouveau_framebuffer *nvfb = nouveau_framebuffer(crtc->primary->fb);\r\nstruct nv50_head *head = nv50_head(crtc);\r\nint ret;\r\nret = nouveau_bo_pin(nvfb->nvbo, TTM_PL_FLAG_VRAM, true);\r\nif (ret == 0) {\r\nif (head->image)\r\nnouveau_bo_unpin(head->image);\r\nnouveau_bo_ref(nvfb->nvbo, &head->image);\r\n}\r\nreturn ret;\r\n}\r\nstatic int\r\nnv50_crtc_mode_set(struct drm_crtc *crtc, struct drm_display_mode *umode,\r\nstruct drm_display_mode *mode, int x, int y,\r\nstruct drm_framebuffer *old_fb)\r\n{\r\nstruct nv50_mast *mast = nv50_mast(crtc->dev);\r\nstruct nouveau_crtc *nv_crtc = nouveau_crtc(crtc);\r\nstruct nouveau_connector *nv_connector;\r\nu32 ilace = (mode->flags & DRM_MODE_FLAG_INTERLACE) ? 2 : 1;\r\nu32 vscan = (mode->flags & DRM_MODE_FLAG_DBLSCAN) ? 2 : 1;\r\nu32 hactive, hsynce, hbackp, hfrontp, hblanke, hblanks;\r\nu32 vactive, vsynce, vbackp, vfrontp, vblanke, vblanks;\r\nu32 vblan2e = 0, vblan2s = 1, vblankus = 0;\r\nu32 *push;\r\nint ret;\r\nhactive = mode->htotal;\r\nhsynce = mode->hsync_end - mode->hsync_start - 1;\r\nhbackp = mode->htotal - mode->hsync_end;\r\nhblanke = hsynce + hbackp;\r\nhfrontp = mode->hsync_start - mode->hdisplay;\r\nhblanks = mode->htotal - hfrontp - 1;\r\nvactive = mode->vtotal * vscan / ilace;\r\nvsynce = ((mode->vsync_end - mode->vsync_start) * vscan / ilace) - 1;\r\nvbackp = (mode->vtotal - mode->vsync_end) * vscan / ilace;\r\nvblanke = vsynce + vbackp;\r\nvfrontp = (mode->vsync_start - mode->vdisplay) * vscan / ilace;\r\nvblanks = vactive - vfrontp - 1;\r\nvblankus = (vactive - mode->vdisplay - 2) * hactive;\r\nvblankus *= 1000;\r\nvblankus /= mode->clock;\r\nif (mode->flags & DRM_MODE_FLAG_INTERLACE) {\r\nvblan2e = vactive + vsynce + vbackp;\r\nvblan2s = vblan2e + (mode->vdisplay * vscan / ilace);\r\nvactive = (vactive * 2) + 1;\r\n}\r\nret = nv50_crtc_swap_fbs(crtc, old_fb);\r\nif (ret)\r\nreturn ret;\r\npush = evo_wait(mast, 64);\r\nif (push) {\r\nif (nv50_vers(mast) < GF110_DISP_CORE_CHANNEL_DMA) {\r\nevo_mthd(push, 0x0804 + (nv_crtc->index * 0x400), 2);\r\nevo_data(push, 0x00800000 | mode->clock);\r\nevo_data(push, (ilace == 2) ? 2 : 0);\r\nevo_mthd(push, 0x0810 + (nv_crtc->index * 0x400), 6);\r\nevo_data(push, 0x00000000);\r\nevo_data(push, (vactive << 16) | hactive);\r\nevo_data(push, ( vsynce << 16) | hsynce);\r\nevo_data(push, (vblanke << 16) | hblanke);\r\nevo_data(push, (vblanks << 16) | hblanks);\r\nevo_data(push, (vblan2e << 16) | vblan2s);\r\nevo_mthd(push, 0x082c + (nv_crtc->index * 0x400), 1);\r\nevo_data(push, 0x00000000);\r\nevo_mthd(push, 0x0900 + (nv_crtc->index * 0x400), 2);\r\nevo_data(push, 0x00000311);\r\nevo_data(push, 0x00000100);\r\n} else {\r\nevo_mthd(push, 0x0410 + (nv_crtc->index * 0x300), 6);\r\nevo_data(push, 0x00000000);\r\nevo_data(push, (vactive << 16) | hactive);\r\nevo_data(push, ( vsynce << 16) | hsynce);\r\nevo_data(push, (vblanke << 16) | hblanke);\r\nevo_data(push, (vblanks << 16) | hblanks);\r\nevo_data(push, (vblan2e << 16) | vblan2s);\r\nevo_mthd(push, 0x042c + (nv_crtc->index * 0x300), 1);\r\nevo_data(push, 0x00000000);\r\nevo_mthd(push, 0x0450 + (nv_crtc->index * 0x300), 3);\r\nevo_data(push, mode->clock * 1000);\r\nevo_data(push, 0x00200000);\r\nevo_data(push, mode->clock * 1000);\r\nevo_mthd(push, 0x04d0 + (nv_crtc->index * 0x300), 2);\r\nevo_data(push, 0x00000311);\r\nevo_data(push, 0x00000100);\r\n}\r\nevo_kick(push, mast);\r\n}\r\nnv_connector = nouveau_crtc_connector_get(nv_crtc);\r\nnv50_crtc_set_dither(nv_crtc, false);\r\nnv50_crtc_set_scale(nv_crtc, false);\r\nif (nv50_vers(mast) < GF110_DISP_CORE_CHANNEL_DMA)\r\nnv50_crtc_set_raster_vblank_dmi(nv_crtc, vblankus);\r\nnv50_crtc_set_color_vibrance(nv_crtc, false);\r\nnv50_crtc_set_image(nv_crtc, crtc->primary->fb, x, y, false);\r\nreturn 0;\r\n}\r\nstatic int\r\nnv50_crtc_mode_set_base(struct drm_crtc *crtc, int x, int y,\r\nstruct drm_framebuffer *old_fb)\r\n{\r\nstruct nouveau_drm *drm = nouveau_drm(crtc->dev);\r\nstruct nouveau_crtc *nv_crtc = nouveau_crtc(crtc);\r\nint ret;\r\nif (!crtc->primary->fb) {\r\nNV_DEBUG(drm, "No FB bound\n");\r\nreturn 0;\r\n}\r\nret = nv50_crtc_swap_fbs(crtc, old_fb);\r\nif (ret)\r\nreturn ret;\r\nnv50_display_flip_stop(crtc);\r\nnv50_crtc_set_image(nv_crtc, crtc->primary->fb, x, y, true);\r\nnv50_display_flip_next(crtc, crtc->primary->fb, NULL, 1);\r\nreturn 0;\r\n}\r\nstatic int\r\nnv50_crtc_mode_set_base_atomic(struct drm_crtc *crtc,\r\nstruct drm_framebuffer *fb, int x, int y,\r\nenum mode_set_atomic state)\r\n{\r\nstruct nouveau_crtc *nv_crtc = nouveau_crtc(crtc);\r\nnv50_display_flip_stop(crtc);\r\nnv50_crtc_set_image(nv_crtc, fb, x, y, true);\r\nreturn 0;\r\n}\r\nstatic void\r\nnv50_crtc_lut_load(struct drm_crtc *crtc)\r\n{\r\nstruct nv50_disp *disp = nv50_disp(crtc->dev);\r\nstruct nouveau_crtc *nv_crtc = nouveau_crtc(crtc);\r\nvoid __iomem *lut = nvbo_kmap_obj_iovirtual(nv_crtc->lut.nvbo);\r\nint i;\r\nfor (i = 0; i < 256; i++) {\r\nu16 r = nv_crtc->lut.r[i] >> 2;\r\nu16 g = nv_crtc->lut.g[i] >> 2;\r\nu16 b = nv_crtc->lut.b[i] >> 2;\r\nif (disp->disp->oclass < GF110_DISP) {\r\nwritew(r + 0x0000, lut + (i * 0x08) + 0);\r\nwritew(g + 0x0000, lut + (i * 0x08) + 2);\r\nwritew(b + 0x0000, lut + (i * 0x08) + 4);\r\n} else {\r\nwritew(r + 0x6000, lut + (i * 0x20) + 0);\r\nwritew(g + 0x6000, lut + (i * 0x20) + 2);\r\nwritew(b + 0x6000, lut + (i * 0x20) + 4);\r\n}\r\n}\r\n}\r\nstatic void\r\nnv50_crtc_disable(struct drm_crtc *crtc)\r\n{\r\nstruct nv50_head *head = nv50_head(crtc);\r\nevo_sync(crtc->dev);\r\nif (head->image)\r\nnouveau_bo_unpin(head->image);\r\nnouveau_bo_ref(NULL, &head->image);\r\n}\r\nstatic int\r\nnv50_crtc_cursor_set(struct drm_crtc *crtc, struct drm_file *file_priv,\r\nuint32_t handle, uint32_t width, uint32_t height)\r\n{\r\nstruct nouveau_crtc *nv_crtc = nouveau_crtc(crtc);\r\nstruct drm_device *dev = crtc->dev;\r\nstruct drm_gem_object *gem = NULL;\r\nstruct nouveau_bo *nvbo = NULL;\r\nint ret = 0;\r\nif (handle) {\r\nif (width != 64 || height != 64)\r\nreturn -EINVAL;\r\ngem = drm_gem_object_lookup(dev, file_priv, handle);\r\nif (unlikely(!gem))\r\nreturn -ENOENT;\r\nnvbo = nouveau_gem_object(gem);\r\nret = nouveau_bo_pin(nvbo, TTM_PL_FLAG_VRAM, true);\r\n}\r\nif (ret == 0) {\r\nif (nv_crtc->cursor.nvbo)\r\nnouveau_bo_unpin(nv_crtc->cursor.nvbo);\r\nnouveau_bo_ref(nvbo, &nv_crtc->cursor.nvbo);\r\n}\r\ndrm_gem_object_unreference_unlocked(gem);\r\nnv50_crtc_cursor_show_hide(nv_crtc, true, true);\r\nreturn ret;\r\n}\r\nstatic int\r\nnv50_crtc_cursor_move(struct drm_crtc *crtc, int x, int y)\r\n{\r\nstruct nouveau_crtc *nv_crtc = nouveau_crtc(crtc);\r\nstruct nv50_curs *curs = nv50_curs(crtc);\r\nstruct nv50_chan *chan = nv50_chan(curs);\r\nnvif_wr32(&chan->user, 0x0084, (y << 16) | (x & 0xffff));\r\nnvif_wr32(&chan->user, 0x0080, 0x00000000);\r\nnv_crtc->cursor_saved_x = x;\r\nnv_crtc->cursor_saved_y = y;\r\nreturn 0;\r\n}\r\nstatic void\r\nnv50_crtc_gamma_set(struct drm_crtc *crtc, u16 *r, u16 *g, u16 *b,\r\nuint32_t start, uint32_t size)\r\n{\r\nstruct nouveau_crtc *nv_crtc = nouveau_crtc(crtc);\r\nu32 end = min_t(u32, start + size, 256);\r\nu32 i;\r\nfor (i = start; i < end; i++) {\r\nnv_crtc->lut.r[i] = r[i];\r\nnv_crtc->lut.g[i] = g[i];\r\nnv_crtc->lut.b[i] = b[i];\r\n}\r\nnv50_crtc_lut_load(crtc);\r\n}\r\nstatic void\r\nnv50_crtc_cursor_restore(struct nouveau_crtc *nv_crtc, int x, int y)\r\n{\r\nnv50_crtc_cursor_move(&nv_crtc->base, x, y);\r\nnv50_crtc_cursor_show_hide(nv_crtc, true, true);\r\n}\r\nstatic void\r\nnv50_crtc_destroy(struct drm_crtc *crtc)\r\n{\r\nstruct nouveau_crtc *nv_crtc = nouveau_crtc(crtc);\r\nstruct nv50_disp *disp = nv50_disp(crtc->dev);\r\nstruct nv50_head *head = nv50_head(crtc);\r\nstruct nv50_fbdma *fbdma;\r\nlist_for_each_entry(fbdma, &disp->fbdma, head) {\r\nnvif_object_fini(&fbdma->base[nv_crtc->index]);\r\n}\r\nnv50_dmac_destroy(&head->ovly.base, disp->disp);\r\nnv50_pioc_destroy(&head->oimm.base);\r\nnv50_dmac_destroy(&head->sync.base, disp->disp);\r\nnv50_pioc_destroy(&head->curs.base);\r\nif (head->image)\r\nnouveau_bo_unpin(head->image);\r\nnouveau_bo_ref(NULL, &head->image);\r\nif (nv_crtc->cursor.nvbo)\r\nnouveau_bo_unpin(nv_crtc->cursor.nvbo);\r\nnouveau_bo_ref(NULL, &nv_crtc->cursor.nvbo);\r\nnouveau_bo_unmap(nv_crtc->lut.nvbo);\r\nif (nv_crtc->lut.nvbo)\r\nnouveau_bo_unpin(nv_crtc->lut.nvbo);\r\nnouveau_bo_ref(NULL, &nv_crtc->lut.nvbo);\r\ndrm_crtc_cleanup(crtc);\r\nkfree(crtc);\r\n}\r\nstatic int\r\nnv50_crtc_create(struct drm_device *dev, int index)\r\n{\r\nstruct nv50_disp *disp = nv50_disp(dev);\r\nstruct nv50_head *head;\r\nstruct drm_crtc *crtc;\r\nint ret, i;\r\nhead = kzalloc(sizeof(*head), GFP_KERNEL);\r\nif (!head)\r\nreturn -ENOMEM;\r\nhead->base.index = index;\r\nhead->base.set_dither = nv50_crtc_set_dither;\r\nhead->base.set_scale = nv50_crtc_set_scale;\r\nhead->base.set_color_vibrance = nv50_crtc_set_color_vibrance;\r\nhead->base.color_vibrance = 50;\r\nhead->base.vibrant_hue = 0;\r\nhead->base.cursor.set_pos = nv50_crtc_cursor_restore;\r\nfor (i = 0; i < 256; i++) {\r\nhead->base.lut.r[i] = i << 8;\r\nhead->base.lut.g[i] = i << 8;\r\nhead->base.lut.b[i] = i << 8;\r\n}\r\ncrtc = &head->base.base;\r\ndrm_crtc_init(dev, crtc, &nv50_crtc_func);\r\ndrm_crtc_helper_add(crtc, &nv50_crtc_hfunc);\r\ndrm_mode_crtc_set_gamma_size(crtc, 256);\r\nret = nouveau_bo_new(dev, 8192, 0x100, TTM_PL_FLAG_VRAM,\r\n0, 0x0000, NULL, NULL, &head->base.lut.nvbo);\r\nif (!ret) {\r\nret = nouveau_bo_pin(head->base.lut.nvbo, TTM_PL_FLAG_VRAM, true);\r\nif (!ret) {\r\nret = nouveau_bo_map(head->base.lut.nvbo);\r\nif (ret)\r\nnouveau_bo_unpin(head->base.lut.nvbo);\r\n}\r\nif (ret)\r\nnouveau_bo_ref(NULL, &head->base.lut.nvbo);\r\n}\r\nif (ret)\r\ngoto out;\r\nret = nv50_curs_create(disp->disp, index, &head->curs);\r\nif (ret)\r\ngoto out;\r\nret = nv50_base_create(disp->disp, index, disp->sync->bo.offset,\r\n&head->sync);\r\nif (ret)\r\ngoto out;\r\nhead->sync.addr = EVO_FLIP_SEM0(index);\r\nhead->sync.data = 0x00000000;\r\nret = nv50_oimm_create(disp->disp, index, &head->oimm);\r\nif (ret)\r\ngoto out;\r\nret = nv50_ovly_create(disp->disp, index, disp->sync->bo.offset,\r\n&head->ovly);\r\nif (ret)\r\ngoto out;\r\nout:\r\nif (ret)\r\nnv50_crtc_destroy(crtc);\r\nreturn ret;\r\n}\r\nstatic bool\r\nnv50_encoder_mode_fixup(struct drm_encoder *encoder,\r\nconst struct drm_display_mode *mode,\r\nstruct drm_display_mode *adjusted_mode)\r\n{\r\nstruct nouveau_encoder *nv_encoder = nouveau_encoder(encoder);\r\nstruct nouveau_connector *nv_connector;\r\nnv_connector = nouveau_encoder_connector_get(nv_encoder);\r\nif (nv_connector && nv_connector->native_mode) {\r\nnv_connector->scaling_full = false;\r\nif (nv_connector->scaling_mode == DRM_MODE_SCALE_NONE) {\r\nswitch (nv_connector->type) {\r\ncase DCB_CONNECTOR_LVDS:\r\ncase DCB_CONNECTOR_LVDS_SPWG:\r\ncase DCB_CONNECTOR_eDP:\r\nif (adjusted_mode->type & DRM_MODE_TYPE_DRIVER)\r\nreturn true;\r\nnv_connector->scaling_full = true;\r\nbreak;\r\ndefault:\r\nreturn true;\r\n}\r\n}\r\ndrm_mode_copy(adjusted_mode, nv_connector->native_mode);\r\n}\r\nreturn true;\r\n}\r\nstatic void\r\nnv50_dac_dpms(struct drm_encoder *encoder, int mode)\r\n{\r\nstruct nouveau_encoder *nv_encoder = nouveau_encoder(encoder);\r\nstruct nv50_disp *disp = nv50_disp(encoder->dev);\r\nstruct {\r\nstruct nv50_disp_mthd_v1 base;\r\nstruct nv50_disp_dac_pwr_v0 pwr;\r\n} args = {\r\n.base.version = 1,\r\n.base.method = NV50_DISP_MTHD_V1_DAC_PWR,\r\n.base.hasht = nv_encoder->dcb->hasht,\r\n.base.hashm = nv_encoder->dcb->hashm,\r\n.pwr.state = 1,\r\n.pwr.data = 1,\r\n.pwr.vsync = (mode != DRM_MODE_DPMS_SUSPEND &&\r\nmode != DRM_MODE_DPMS_OFF),\r\n.pwr.hsync = (mode != DRM_MODE_DPMS_STANDBY &&\r\nmode != DRM_MODE_DPMS_OFF),\r\n};\r\nnvif_mthd(disp->disp, 0, &args, sizeof(args));\r\n}\r\nstatic void\r\nnv50_dac_commit(struct drm_encoder *encoder)\r\n{\r\n}\r\nstatic void\r\nnv50_dac_mode_set(struct drm_encoder *encoder, struct drm_display_mode *mode,\r\nstruct drm_display_mode *adjusted_mode)\r\n{\r\nstruct nv50_mast *mast = nv50_mast(encoder->dev);\r\nstruct nouveau_encoder *nv_encoder = nouveau_encoder(encoder);\r\nstruct nouveau_crtc *nv_crtc = nouveau_crtc(encoder->crtc);\r\nu32 *push;\r\nnv50_dac_dpms(encoder, DRM_MODE_DPMS_ON);\r\npush = evo_wait(mast, 8);\r\nif (push) {\r\nif (nv50_vers(mast) < GF110_DISP_CORE_CHANNEL_DMA) {\r\nu32 syncs = 0x00000000;\r\nif (mode->flags & DRM_MODE_FLAG_NHSYNC)\r\nsyncs |= 0x00000001;\r\nif (mode->flags & DRM_MODE_FLAG_NVSYNC)\r\nsyncs |= 0x00000002;\r\nevo_mthd(push, 0x0400 + (nv_encoder->or * 0x080), 2);\r\nevo_data(push, 1 << nv_crtc->index);\r\nevo_data(push, syncs);\r\n} else {\r\nu32 magic = 0x31ec6000 | (nv_crtc->index << 25);\r\nu32 syncs = 0x00000001;\r\nif (mode->flags & DRM_MODE_FLAG_NHSYNC)\r\nsyncs |= 0x00000008;\r\nif (mode->flags & DRM_MODE_FLAG_NVSYNC)\r\nsyncs |= 0x00000010;\r\nif (mode->flags & DRM_MODE_FLAG_INTERLACE)\r\nmagic |= 0x00000001;\r\nevo_mthd(push, 0x0404 + (nv_crtc->index * 0x300), 2);\r\nevo_data(push, syncs);\r\nevo_data(push, magic);\r\nevo_mthd(push, 0x0180 + (nv_encoder->or * 0x020), 1);\r\nevo_data(push, 1 << nv_crtc->index);\r\n}\r\nevo_kick(push, mast);\r\n}\r\nnv_encoder->crtc = encoder->crtc;\r\n}\r\nstatic void\r\nnv50_dac_disconnect(struct drm_encoder *encoder)\r\n{\r\nstruct nouveau_encoder *nv_encoder = nouveau_encoder(encoder);\r\nstruct nv50_mast *mast = nv50_mast(encoder->dev);\r\nconst int or = nv_encoder->or;\r\nu32 *push;\r\nif (nv_encoder->crtc) {\r\nnv50_crtc_prepare(nv_encoder->crtc);\r\npush = evo_wait(mast, 4);\r\nif (push) {\r\nif (nv50_vers(mast) < GF110_DISP_CORE_CHANNEL_DMA) {\r\nevo_mthd(push, 0x0400 + (or * 0x080), 1);\r\nevo_data(push, 0x00000000);\r\n} else {\r\nevo_mthd(push, 0x0180 + (or * 0x020), 1);\r\nevo_data(push, 0x00000000);\r\n}\r\nevo_kick(push, mast);\r\n}\r\n}\r\nnv_encoder->crtc = NULL;\r\n}\r\nstatic enum drm_connector_status\r\nnv50_dac_detect(struct drm_encoder *encoder, struct drm_connector *connector)\r\n{\r\nstruct nouveau_encoder *nv_encoder = nouveau_encoder(encoder);\r\nstruct nv50_disp *disp = nv50_disp(encoder->dev);\r\nstruct {\r\nstruct nv50_disp_mthd_v1 base;\r\nstruct nv50_disp_dac_load_v0 load;\r\n} args = {\r\n.base.version = 1,\r\n.base.method = NV50_DISP_MTHD_V1_DAC_LOAD,\r\n.base.hasht = nv_encoder->dcb->hasht,\r\n.base.hashm = nv_encoder->dcb->hashm,\r\n};\r\nint ret;\r\nargs.load.data = nouveau_drm(encoder->dev)->vbios.dactestval;\r\nif (args.load.data == 0)\r\nargs.load.data = 340;\r\nret = nvif_mthd(disp->disp, 0, &args, sizeof(args));\r\nif (ret || !args.load.load)\r\nreturn connector_status_disconnected;\r\nreturn connector_status_connected;\r\n}\r\nstatic void\r\nnv50_dac_destroy(struct drm_encoder *encoder)\r\n{\r\ndrm_encoder_cleanup(encoder);\r\nkfree(encoder);\r\n}\r\nstatic int\r\nnv50_dac_create(struct drm_connector *connector, struct dcb_output *dcbe)\r\n{\r\nstruct nouveau_drm *drm = nouveau_drm(connector->dev);\r\nstruct nvkm_i2c *i2c = nvxx_i2c(&drm->device);\r\nstruct nouveau_encoder *nv_encoder;\r\nstruct drm_encoder *encoder;\r\nint type = DRM_MODE_ENCODER_DAC;\r\nnv_encoder = kzalloc(sizeof(*nv_encoder), GFP_KERNEL);\r\nif (!nv_encoder)\r\nreturn -ENOMEM;\r\nnv_encoder->dcb = dcbe;\r\nnv_encoder->or = ffs(dcbe->or) - 1;\r\nnv_encoder->i2c = i2c->find(i2c, dcbe->i2c_index);\r\nencoder = to_drm_encoder(nv_encoder);\r\nencoder->possible_crtcs = dcbe->heads;\r\nencoder->possible_clones = 0;\r\ndrm_encoder_init(connector->dev, encoder, &nv50_dac_func, type);\r\ndrm_encoder_helper_add(encoder, &nv50_dac_hfunc);\r\ndrm_mode_connector_attach_encoder(connector, encoder);\r\nreturn 0;\r\n}\r\nstatic void\r\nnv50_audio_mode_set(struct drm_encoder *encoder, struct drm_display_mode *mode)\r\n{\r\nstruct nouveau_encoder *nv_encoder = nouveau_encoder(encoder);\r\nstruct nouveau_crtc *nv_crtc = nouveau_crtc(encoder->crtc);\r\nstruct nouveau_connector *nv_connector;\r\nstruct nv50_disp *disp = nv50_disp(encoder->dev);\r\nstruct __packed {\r\nstruct {\r\nstruct nv50_disp_mthd_v1 mthd;\r\nstruct nv50_disp_sor_hda_eld_v0 eld;\r\n} base;\r\nu8 data[sizeof(nv_connector->base.eld)];\r\n} args = {\r\n.base.mthd.version = 1,\r\n.base.mthd.method = NV50_DISP_MTHD_V1_SOR_HDA_ELD,\r\n.base.mthd.hasht = nv_encoder->dcb->hasht,\r\n.base.mthd.hashm = (0xf0ff & nv_encoder->dcb->hashm) |\r\n(0x0100 << nv_crtc->index),\r\n};\r\nnv_connector = nouveau_encoder_connector_get(nv_encoder);\r\nif (!drm_detect_monitor_audio(nv_connector->edid))\r\nreturn;\r\ndrm_edid_to_eld(&nv_connector->base, nv_connector->edid);\r\nmemcpy(args.data, nv_connector->base.eld, sizeof(args.data));\r\nnvif_mthd(disp->disp, 0, &args,\r\nsizeof(args.base) + drm_eld_size(args.data));\r\n}\r\nstatic void\r\nnv50_audio_disconnect(struct drm_encoder *encoder, struct nouveau_crtc *nv_crtc)\r\n{\r\nstruct nouveau_encoder *nv_encoder = nouveau_encoder(encoder);\r\nstruct nv50_disp *disp = nv50_disp(encoder->dev);\r\nstruct {\r\nstruct nv50_disp_mthd_v1 base;\r\nstruct nv50_disp_sor_hda_eld_v0 eld;\r\n} args = {\r\n.base.version = 1,\r\n.base.method = NV50_DISP_MTHD_V1_SOR_HDA_ELD,\r\n.base.hasht = nv_encoder->dcb->hasht,\r\n.base.hashm = (0xf0ff & nv_encoder->dcb->hashm) |\r\n(0x0100 << nv_crtc->index),\r\n};\r\nnvif_mthd(disp->disp, 0, &args, sizeof(args));\r\n}\r\nstatic void\r\nnv50_hdmi_mode_set(struct drm_encoder *encoder, struct drm_display_mode *mode)\r\n{\r\nstruct nouveau_encoder *nv_encoder = nouveau_encoder(encoder);\r\nstruct nouveau_crtc *nv_crtc = nouveau_crtc(encoder->crtc);\r\nstruct nv50_disp *disp = nv50_disp(encoder->dev);\r\nstruct {\r\nstruct nv50_disp_mthd_v1 base;\r\nstruct nv50_disp_sor_hdmi_pwr_v0 pwr;\r\n} args = {\r\n.base.version = 1,\r\n.base.method = NV50_DISP_MTHD_V1_SOR_HDMI_PWR,\r\n.base.hasht = nv_encoder->dcb->hasht,\r\n.base.hashm = (0xf0ff & nv_encoder->dcb->hashm) |\r\n(0x0100 << nv_crtc->index),\r\n.pwr.state = 1,\r\n.pwr.rekey = 56,\r\n};\r\nstruct nouveau_connector *nv_connector;\r\nu32 max_ac_packet;\r\nnv_connector = nouveau_encoder_connector_get(nv_encoder);\r\nif (!drm_detect_hdmi_monitor(nv_connector->edid))\r\nreturn;\r\nmax_ac_packet = mode->htotal - mode->hdisplay;\r\nmax_ac_packet -= args.pwr.rekey;\r\nmax_ac_packet -= 18;\r\nargs.pwr.max_ac_packet = max_ac_packet / 32;\r\nnvif_mthd(disp->disp, 0, &args, sizeof(args));\r\nnv50_audio_mode_set(encoder, mode);\r\n}\r\nstatic void\r\nnv50_hdmi_disconnect(struct drm_encoder *encoder, struct nouveau_crtc *nv_crtc)\r\n{\r\nstruct nouveau_encoder *nv_encoder = nouveau_encoder(encoder);\r\nstruct nv50_disp *disp = nv50_disp(encoder->dev);\r\nstruct {\r\nstruct nv50_disp_mthd_v1 base;\r\nstruct nv50_disp_sor_hdmi_pwr_v0 pwr;\r\n} args = {\r\n.base.version = 1,\r\n.base.method = NV50_DISP_MTHD_V1_SOR_HDMI_PWR,\r\n.base.hasht = nv_encoder->dcb->hasht,\r\n.base.hashm = (0xf0ff & nv_encoder->dcb->hashm) |\r\n(0x0100 << nv_crtc->index),\r\n};\r\nnvif_mthd(disp->disp, 0, &args, sizeof(args));\r\n}\r\nstatic void\r\nnv50_sor_dpms(struct drm_encoder *encoder, int mode)\r\n{\r\nstruct nouveau_encoder *nv_encoder = nouveau_encoder(encoder);\r\nstruct nv50_disp *disp = nv50_disp(encoder->dev);\r\nstruct {\r\nstruct nv50_disp_mthd_v1 base;\r\nstruct nv50_disp_sor_pwr_v0 pwr;\r\n} args = {\r\n.base.version = 1,\r\n.base.method = NV50_DISP_MTHD_V1_SOR_PWR,\r\n.base.hasht = nv_encoder->dcb->hasht,\r\n.base.hashm = nv_encoder->dcb->hashm,\r\n.pwr.state = mode == DRM_MODE_DPMS_ON,\r\n};\r\nstruct {\r\nstruct nv50_disp_mthd_v1 base;\r\nstruct nv50_disp_sor_dp_pwr_v0 pwr;\r\n} link = {\r\n.base.version = 1,\r\n.base.method = NV50_DISP_MTHD_V1_SOR_DP_PWR,\r\n.base.hasht = nv_encoder->dcb->hasht,\r\n.base.hashm = nv_encoder->dcb->hashm,\r\n.pwr.state = mode == DRM_MODE_DPMS_ON,\r\n};\r\nstruct drm_device *dev = encoder->dev;\r\nstruct drm_encoder *partner;\r\nnv_encoder->last_dpms = mode;\r\nlist_for_each_entry(partner, &dev->mode_config.encoder_list, head) {\r\nstruct nouveau_encoder *nv_partner = nouveau_encoder(partner);\r\nif (partner->encoder_type != DRM_MODE_ENCODER_TMDS)\r\ncontinue;\r\nif (nv_partner != nv_encoder &&\r\nnv_partner->dcb->or == nv_encoder->dcb->or) {\r\nif (nv_partner->last_dpms == DRM_MODE_DPMS_ON)\r\nreturn;\r\nbreak;\r\n}\r\n}\r\nif (nv_encoder->dcb->type == DCB_OUTPUT_DP) {\r\nargs.pwr.state = 1;\r\nnvif_mthd(disp->disp, 0, &args, sizeof(args));\r\nnvif_mthd(disp->disp, 0, &link, sizeof(link));\r\n} else {\r\nnvif_mthd(disp->disp, 0, &args, sizeof(args));\r\n}\r\n}\r\nstatic void\r\nnv50_sor_ctrl(struct nouveau_encoder *nv_encoder, u32 mask, u32 data)\r\n{\r\nstruct nv50_mast *mast = nv50_mast(nv_encoder->base.base.dev);\r\nu32 temp = (nv_encoder->ctrl & ~mask) | (data & mask), *push;\r\nif (temp != nv_encoder->ctrl && (push = evo_wait(mast, 2))) {\r\nif (nv50_vers(mast) < GF110_DISP_CORE_CHANNEL_DMA) {\r\nevo_mthd(push, 0x0600 + (nv_encoder->or * 0x40), 1);\r\nevo_data(push, (nv_encoder->ctrl = temp));\r\n} else {\r\nevo_mthd(push, 0x0200 + (nv_encoder->or * 0x20), 1);\r\nevo_data(push, (nv_encoder->ctrl = temp));\r\n}\r\nevo_kick(push, mast);\r\n}\r\n}\r\nstatic void\r\nnv50_sor_disconnect(struct drm_encoder *encoder)\r\n{\r\nstruct nouveau_encoder *nv_encoder = nouveau_encoder(encoder);\r\nstruct nouveau_crtc *nv_crtc = nouveau_crtc(nv_encoder->crtc);\r\nnv_encoder->last_dpms = DRM_MODE_DPMS_OFF;\r\nnv_encoder->crtc = NULL;\r\nif (nv_crtc) {\r\nnv50_crtc_prepare(&nv_crtc->base);\r\nnv50_sor_ctrl(nv_encoder, 1 << nv_crtc->index, 0);\r\nnv50_audio_disconnect(encoder, nv_crtc);\r\nnv50_hdmi_disconnect(&nv_encoder->base.base, nv_crtc);\r\n}\r\n}\r\nstatic void\r\nnv50_sor_commit(struct drm_encoder *encoder)\r\n{\r\n}\r\nstatic void\r\nnv50_sor_mode_set(struct drm_encoder *encoder, struct drm_display_mode *umode,\r\nstruct drm_display_mode *mode)\r\n{\r\nstruct nouveau_encoder *nv_encoder = nouveau_encoder(encoder);\r\nstruct nouveau_crtc *nv_crtc = nouveau_crtc(encoder->crtc);\r\nstruct {\r\nstruct nv50_disp_mthd_v1 base;\r\nstruct nv50_disp_sor_lvds_script_v0 lvds;\r\n} lvds = {\r\n.base.version = 1,\r\n.base.method = NV50_DISP_MTHD_V1_SOR_LVDS_SCRIPT,\r\n.base.hasht = nv_encoder->dcb->hasht,\r\n.base.hashm = nv_encoder->dcb->hashm,\r\n};\r\nstruct nv50_disp *disp = nv50_disp(encoder->dev);\r\nstruct nv50_mast *mast = nv50_mast(encoder->dev);\r\nstruct drm_device *dev = encoder->dev;\r\nstruct nouveau_drm *drm = nouveau_drm(dev);\r\nstruct nouveau_connector *nv_connector;\r\nstruct nvbios *bios = &drm->vbios;\r\nu32 mask, ctrl;\r\nu8 owner = 1 << nv_crtc->index;\r\nu8 proto = 0xf;\r\nu8 depth = 0x0;\r\nnv_connector = nouveau_encoder_connector_get(nv_encoder);\r\nnv_encoder->crtc = encoder->crtc;\r\nswitch (nv_encoder->dcb->type) {\r\ncase DCB_OUTPUT_TMDS:\r\nif (nv_encoder->dcb->sorconf.link & 1) {\r\nif (mode->clock < 165000)\r\nproto = 0x1;\r\nelse\r\nproto = 0x5;\r\n} else {\r\nproto = 0x2;\r\n}\r\nnv50_hdmi_mode_set(&nv_encoder->base.base, mode);\r\nbreak;\r\ncase DCB_OUTPUT_LVDS:\r\nproto = 0x0;\r\nif (bios->fp_no_ddc) {\r\nif (bios->fp.dual_link)\r\nlvds.lvds.script |= 0x0100;\r\nif (bios->fp.if_is_24bit)\r\nlvds.lvds.script |= 0x0200;\r\n} else {\r\nif (nv_connector->type == DCB_CONNECTOR_LVDS_SPWG) {\r\nif (((u8 *)nv_connector->edid)[121] == 2)\r\nlvds.lvds.script |= 0x0100;\r\n} else\r\nif (mode->clock >= bios->fp.duallink_transition_clk) {\r\nlvds.lvds.script |= 0x0100;\r\n}\r\nif (lvds.lvds.script & 0x0100) {\r\nif (bios->fp.strapless_is_24bit & 2)\r\nlvds.lvds.script |= 0x0200;\r\n} else {\r\nif (bios->fp.strapless_is_24bit & 1)\r\nlvds.lvds.script |= 0x0200;\r\n}\r\nif (nv_connector->base.display_info.bpc == 8)\r\nlvds.lvds.script |= 0x0200;\r\n}\r\nnvif_mthd(disp->disp, 0, &lvds, sizeof(lvds));\r\nbreak;\r\ncase DCB_OUTPUT_DP:\r\nif (nv_connector->base.display_info.bpc == 6) {\r\nnv_encoder->dp.datarate = mode->clock * 18 / 8;\r\ndepth = 0x2;\r\n} else\r\nif (nv_connector->base.display_info.bpc == 8) {\r\nnv_encoder->dp.datarate = mode->clock * 24 / 8;\r\ndepth = 0x5;\r\n} else {\r\nnv_encoder->dp.datarate = mode->clock * 30 / 8;\r\ndepth = 0x6;\r\n}\r\nif (nv_encoder->dcb->sorconf.link & 1)\r\nproto = 0x8;\r\nelse\r\nproto = 0x9;\r\nnv50_audio_mode_set(encoder, mode);\r\nbreak;\r\ndefault:\r\nBUG_ON(1);\r\nbreak;\r\n}\r\nnv50_sor_dpms(&nv_encoder->base.base, DRM_MODE_DPMS_ON);\r\nif (nv50_vers(mast) >= GF110_DISP) {\r\nu32 *push = evo_wait(mast, 3);\r\nif (push) {\r\nu32 magic = 0x31ec6000 | (nv_crtc->index << 25);\r\nu32 syncs = 0x00000001;\r\nif (mode->flags & DRM_MODE_FLAG_NHSYNC)\r\nsyncs |= 0x00000008;\r\nif (mode->flags & DRM_MODE_FLAG_NVSYNC)\r\nsyncs |= 0x00000010;\r\nif (mode->flags & DRM_MODE_FLAG_INTERLACE)\r\nmagic |= 0x00000001;\r\nevo_mthd(push, 0x0404 + (nv_crtc->index * 0x300), 2);\r\nevo_data(push, syncs | (depth << 6));\r\nevo_data(push, magic);\r\nevo_kick(push, mast);\r\n}\r\nctrl = proto << 8;\r\nmask = 0x00000f00;\r\n} else {\r\nctrl = (depth << 16) | (proto << 8);\r\nif (mode->flags & DRM_MODE_FLAG_NHSYNC)\r\nctrl |= 0x00001000;\r\nif (mode->flags & DRM_MODE_FLAG_NVSYNC)\r\nctrl |= 0x00002000;\r\nmask = 0x000f3f00;\r\n}\r\nnv50_sor_ctrl(nv_encoder, mask | owner, ctrl | owner);\r\n}\r\nstatic void\r\nnv50_sor_destroy(struct drm_encoder *encoder)\r\n{\r\ndrm_encoder_cleanup(encoder);\r\nkfree(encoder);\r\n}\r\nstatic int\r\nnv50_sor_create(struct drm_connector *connector, struct dcb_output *dcbe)\r\n{\r\nstruct nouveau_drm *drm = nouveau_drm(connector->dev);\r\nstruct nvkm_i2c *i2c = nvxx_i2c(&drm->device);\r\nstruct nouveau_encoder *nv_encoder;\r\nstruct drm_encoder *encoder;\r\nint type;\r\nswitch (dcbe->type) {\r\ncase DCB_OUTPUT_LVDS: type = DRM_MODE_ENCODER_LVDS; break;\r\ncase DCB_OUTPUT_TMDS:\r\ncase DCB_OUTPUT_DP:\r\ndefault:\r\ntype = DRM_MODE_ENCODER_TMDS;\r\nbreak;\r\n}\r\nnv_encoder = kzalloc(sizeof(*nv_encoder), GFP_KERNEL);\r\nif (!nv_encoder)\r\nreturn -ENOMEM;\r\nnv_encoder->dcb = dcbe;\r\nnv_encoder->or = ffs(dcbe->or) - 1;\r\nnv_encoder->i2c = i2c->find(i2c, dcbe->i2c_index);\r\nnv_encoder->last_dpms = DRM_MODE_DPMS_OFF;\r\nencoder = to_drm_encoder(nv_encoder);\r\nencoder->possible_crtcs = dcbe->heads;\r\nencoder->possible_clones = 0;\r\ndrm_encoder_init(connector->dev, encoder, &nv50_sor_func, type);\r\ndrm_encoder_helper_add(encoder, &nv50_sor_hfunc);\r\ndrm_mode_connector_attach_encoder(connector, encoder);\r\nreturn 0;\r\n}\r\nstatic void\r\nnv50_pior_dpms(struct drm_encoder *encoder, int mode)\r\n{\r\nstruct nouveau_encoder *nv_encoder = nouveau_encoder(encoder);\r\nstruct nv50_disp *disp = nv50_disp(encoder->dev);\r\nstruct {\r\nstruct nv50_disp_mthd_v1 base;\r\nstruct nv50_disp_pior_pwr_v0 pwr;\r\n} args = {\r\n.base.version = 1,\r\n.base.method = NV50_DISP_MTHD_V1_PIOR_PWR,\r\n.base.hasht = nv_encoder->dcb->hasht,\r\n.base.hashm = nv_encoder->dcb->hashm,\r\n.pwr.state = mode == DRM_MODE_DPMS_ON,\r\n.pwr.type = nv_encoder->dcb->type,\r\n};\r\nnvif_mthd(disp->disp, 0, &args, sizeof(args));\r\n}\r\nstatic bool\r\nnv50_pior_mode_fixup(struct drm_encoder *encoder,\r\nconst struct drm_display_mode *mode,\r\nstruct drm_display_mode *adjusted_mode)\r\n{\r\nif (!nv50_encoder_mode_fixup(encoder, mode, adjusted_mode))\r\nreturn false;\r\nadjusted_mode->clock *= 2;\r\nreturn true;\r\n}\r\nstatic void\r\nnv50_pior_commit(struct drm_encoder *encoder)\r\n{\r\n}\r\nstatic void\r\nnv50_pior_mode_set(struct drm_encoder *encoder, struct drm_display_mode *mode,\r\nstruct drm_display_mode *adjusted_mode)\r\n{\r\nstruct nv50_mast *mast = nv50_mast(encoder->dev);\r\nstruct nouveau_encoder *nv_encoder = nouveau_encoder(encoder);\r\nstruct nouveau_crtc *nv_crtc = nouveau_crtc(encoder->crtc);\r\nstruct nouveau_connector *nv_connector;\r\nu8 owner = 1 << nv_crtc->index;\r\nu8 proto, depth;\r\nu32 *push;\r\nnv_connector = nouveau_encoder_connector_get(nv_encoder);\r\nswitch (nv_connector->base.display_info.bpc) {\r\ncase 10: depth = 0x6; break;\r\ncase 8: depth = 0x5; break;\r\ncase 6: depth = 0x2; break;\r\ndefault: depth = 0x0; break;\r\n}\r\nswitch (nv_encoder->dcb->type) {\r\ncase DCB_OUTPUT_TMDS:\r\ncase DCB_OUTPUT_DP:\r\nproto = 0x0;\r\nbreak;\r\ndefault:\r\nBUG_ON(1);\r\nbreak;\r\n}\r\nnv50_pior_dpms(encoder, DRM_MODE_DPMS_ON);\r\npush = evo_wait(mast, 8);\r\nif (push) {\r\nif (nv50_vers(mast) < GF110_DISP_CORE_CHANNEL_DMA) {\r\nu32 ctrl = (depth << 16) | (proto << 8) | owner;\r\nif (mode->flags & DRM_MODE_FLAG_NHSYNC)\r\nctrl |= 0x00001000;\r\nif (mode->flags & DRM_MODE_FLAG_NVSYNC)\r\nctrl |= 0x00002000;\r\nevo_mthd(push, 0x0700 + (nv_encoder->or * 0x040), 1);\r\nevo_data(push, ctrl);\r\n}\r\nevo_kick(push, mast);\r\n}\r\nnv_encoder->crtc = encoder->crtc;\r\n}\r\nstatic void\r\nnv50_pior_disconnect(struct drm_encoder *encoder)\r\n{\r\nstruct nouveau_encoder *nv_encoder = nouveau_encoder(encoder);\r\nstruct nv50_mast *mast = nv50_mast(encoder->dev);\r\nconst int or = nv_encoder->or;\r\nu32 *push;\r\nif (nv_encoder->crtc) {\r\nnv50_crtc_prepare(nv_encoder->crtc);\r\npush = evo_wait(mast, 4);\r\nif (push) {\r\nif (nv50_vers(mast) < GF110_DISP_CORE_CHANNEL_DMA) {\r\nevo_mthd(push, 0x0700 + (or * 0x040), 1);\r\nevo_data(push, 0x00000000);\r\n}\r\nevo_kick(push, mast);\r\n}\r\n}\r\nnv_encoder->crtc = NULL;\r\n}\r\nstatic void\r\nnv50_pior_destroy(struct drm_encoder *encoder)\r\n{\r\ndrm_encoder_cleanup(encoder);\r\nkfree(encoder);\r\n}\r\nstatic int\r\nnv50_pior_create(struct drm_connector *connector, struct dcb_output *dcbe)\r\n{\r\nstruct nouveau_drm *drm = nouveau_drm(connector->dev);\r\nstruct nvkm_i2c *i2c = nvxx_i2c(&drm->device);\r\nstruct nvkm_i2c_port *ddc = NULL;\r\nstruct nouveau_encoder *nv_encoder;\r\nstruct drm_encoder *encoder;\r\nint type;\r\nswitch (dcbe->type) {\r\ncase DCB_OUTPUT_TMDS:\r\nddc = i2c->find_type(i2c, NV_I2C_TYPE_EXTDDC(dcbe->extdev));\r\ntype = DRM_MODE_ENCODER_TMDS;\r\nbreak;\r\ncase DCB_OUTPUT_DP:\r\nddc = i2c->find_type(i2c, NV_I2C_TYPE_EXTAUX(dcbe->extdev));\r\ntype = DRM_MODE_ENCODER_TMDS;\r\nbreak;\r\ndefault:\r\nreturn -ENODEV;\r\n}\r\nnv_encoder = kzalloc(sizeof(*nv_encoder), GFP_KERNEL);\r\nif (!nv_encoder)\r\nreturn -ENOMEM;\r\nnv_encoder->dcb = dcbe;\r\nnv_encoder->or = ffs(dcbe->or) - 1;\r\nnv_encoder->i2c = ddc;\r\nencoder = to_drm_encoder(nv_encoder);\r\nencoder->possible_crtcs = dcbe->heads;\r\nencoder->possible_clones = 0;\r\ndrm_encoder_init(connector->dev, encoder, &nv50_pior_func, type);\r\ndrm_encoder_helper_add(encoder, &nv50_pior_hfunc);\r\ndrm_mode_connector_attach_encoder(connector, encoder);\r\nreturn 0;\r\n}\r\nstatic void\r\nnv50_fbdma_fini(struct nv50_fbdma *fbdma)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(fbdma->base); i++)\r\nnvif_object_fini(&fbdma->base[i]);\r\nnvif_object_fini(&fbdma->core);\r\nlist_del(&fbdma->head);\r\nkfree(fbdma);\r\n}\r\nstatic int\r\nnv50_fbdma_init(struct drm_device *dev, u32 name, u64 offset, u64 length, u8 kind)\r\n{\r\nstruct nouveau_drm *drm = nouveau_drm(dev);\r\nstruct nv50_disp *disp = nv50_disp(dev);\r\nstruct nv50_mast *mast = nv50_mast(dev);\r\nstruct __attribute__ ((packed)) {\r\nstruct nv_dma_v0 base;\r\nunion {\r\nstruct nv50_dma_v0 nv50;\r\nstruct gf100_dma_v0 gf100;\r\nstruct gf110_dma_v0 gf110;\r\n};\r\n} args = {};\r\nstruct nv50_fbdma *fbdma;\r\nstruct drm_crtc *crtc;\r\nu32 size = sizeof(args.base);\r\nint ret;\r\nlist_for_each_entry(fbdma, &disp->fbdma, head) {\r\nif (fbdma->core.handle == name)\r\nreturn 0;\r\n}\r\nfbdma = kzalloc(sizeof(*fbdma), GFP_KERNEL);\r\nif (!fbdma)\r\nreturn -ENOMEM;\r\nlist_add(&fbdma->head, &disp->fbdma);\r\nargs.base.target = NV_DMA_V0_TARGET_VRAM;\r\nargs.base.access = NV_DMA_V0_ACCESS_RDWR;\r\nargs.base.start = offset;\r\nargs.base.limit = offset + length - 1;\r\nif (drm->device.info.chipset < 0x80) {\r\nargs.nv50.part = NV50_DMA_V0_PART_256;\r\nsize += sizeof(args.nv50);\r\n} else\r\nif (drm->device.info.chipset < 0xc0) {\r\nargs.nv50.part = NV50_DMA_V0_PART_256;\r\nargs.nv50.kind = kind;\r\nsize += sizeof(args.nv50);\r\n} else\r\nif (drm->device.info.chipset < 0xd0) {\r\nargs.gf100.kind = kind;\r\nsize += sizeof(args.gf100);\r\n} else {\r\nargs.gf110.page = GF110_DMA_V0_PAGE_LP;\r\nargs.gf110.kind = kind;\r\nsize += sizeof(args.gf110);\r\n}\r\nlist_for_each_entry(crtc, &dev->mode_config.crtc_list, head) {\r\nstruct nv50_head *head = nv50_head(crtc);\r\nint ret = nvif_object_init(&head->sync.base.base.user, NULL,\r\nname, NV_DMA_IN_MEMORY, &args, size,\r\n&fbdma->base[head->base.index]);\r\nif (ret) {\r\nnv50_fbdma_fini(fbdma);\r\nreturn ret;\r\n}\r\n}\r\nret = nvif_object_init(&mast->base.base.user, NULL, name,\r\nNV_DMA_IN_MEMORY, &args, size,\r\n&fbdma->core);\r\nif (ret) {\r\nnv50_fbdma_fini(fbdma);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic void\r\nnv50_fb_dtor(struct drm_framebuffer *fb)\r\n{\r\n}\r\nstatic int\r\nnv50_fb_ctor(struct drm_framebuffer *fb)\r\n{\r\nstruct nouveau_framebuffer *nv_fb = nouveau_framebuffer(fb);\r\nstruct nouveau_drm *drm = nouveau_drm(fb->dev);\r\nstruct nouveau_bo *nvbo = nv_fb->nvbo;\r\nstruct nv50_disp *disp = nv50_disp(fb->dev);\r\nu8 kind = nouveau_bo_tile_layout(nvbo) >> 8;\r\nu8 tile = nvbo->tile_mode;\r\nif (drm->device.info.chipset >= 0xc0)\r\ntile >>= 4;\r\nswitch (fb->depth) {\r\ncase 8: nv_fb->r_format = 0x1e00; break;\r\ncase 15: nv_fb->r_format = 0xe900; break;\r\ncase 16: nv_fb->r_format = 0xe800; break;\r\ncase 24:\r\ncase 32: nv_fb->r_format = 0xcf00; break;\r\ncase 30: nv_fb->r_format = 0xd100; break;\r\ndefault:\r\nNV_ERROR(drm, "unknown depth %d\n", fb->depth);\r\nreturn -EINVAL;\r\n}\r\nif (disp->disp->oclass < G82_DISP) {\r\nnv_fb->r_pitch = kind ? (((fb->pitches[0] / 4) << 4) | tile) :\r\n(fb->pitches[0] | 0x00100000);\r\nnv_fb->r_format |= kind << 16;\r\n} else\r\nif (disp->disp->oclass < GF110_DISP) {\r\nnv_fb->r_pitch = kind ? (((fb->pitches[0] / 4) << 4) | tile) :\r\n(fb->pitches[0] | 0x00100000);\r\n} else {\r\nnv_fb->r_pitch = kind ? (((fb->pitches[0] / 4) << 4) | tile) :\r\n(fb->pitches[0] | 0x01000000);\r\n}\r\nnv_fb->r_handle = 0xffff0000 | kind;\r\nreturn nv50_fbdma_init(fb->dev, nv_fb->r_handle, 0,\r\ndrm->device.info.ram_user, kind);\r\n}\r\nvoid\r\nnv50_display_fini(struct drm_device *dev)\r\n{\r\n}\r\nint\r\nnv50_display_init(struct drm_device *dev)\r\n{\r\nstruct nv50_disp *disp = nv50_disp(dev);\r\nstruct drm_crtc *crtc;\r\nu32 *push;\r\npush = evo_wait(nv50_mast(dev), 32);\r\nif (!push)\r\nreturn -EBUSY;\r\nlist_for_each_entry(crtc, &dev->mode_config.crtc_list, head) {\r\nstruct nv50_sync *sync = nv50_sync(crtc);\r\nnv50_crtc_lut_load(crtc);\r\nnouveau_bo_wr32(disp->sync, sync->addr / 4, sync->data);\r\n}\r\nevo_mthd(push, 0x0088, 1);\r\nevo_data(push, nv50_mast(dev)->base.sync.handle);\r\nevo_kick(push, nv50_mast(dev));\r\nreturn 0;\r\n}\r\nvoid\r\nnv50_display_destroy(struct drm_device *dev)\r\n{\r\nstruct nv50_disp *disp = nv50_disp(dev);\r\nstruct nv50_fbdma *fbdma, *fbtmp;\r\nlist_for_each_entry_safe(fbdma, fbtmp, &disp->fbdma, head) {\r\nnv50_fbdma_fini(fbdma);\r\n}\r\nnv50_dmac_destroy(&disp->mast.base, disp->disp);\r\nnouveau_bo_unmap(disp->sync);\r\nif (disp->sync)\r\nnouveau_bo_unpin(disp->sync);\r\nnouveau_bo_ref(NULL, &disp->sync);\r\nnouveau_display(dev)->priv = NULL;\r\nkfree(disp);\r\n}\r\nint\r\nnv50_display_create(struct drm_device *dev)\r\n{\r\nstruct nvif_device *device = &nouveau_drm(dev)->device;\r\nstruct nouveau_drm *drm = nouveau_drm(dev);\r\nstruct dcb_table *dcb = &drm->vbios.dcb;\r\nstruct drm_connector *connector, *tmp;\r\nstruct nv50_disp *disp;\r\nstruct dcb_output *dcbe;\r\nint crtcs, ret, i;\r\ndisp = kzalloc(sizeof(*disp), GFP_KERNEL);\r\nif (!disp)\r\nreturn -ENOMEM;\r\nINIT_LIST_HEAD(&disp->fbdma);\r\nnouveau_display(dev)->priv = disp;\r\nnouveau_display(dev)->dtor = nv50_display_destroy;\r\nnouveau_display(dev)->init = nv50_display_init;\r\nnouveau_display(dev)->fini = nv50_display_fini;\r\nnouveau_display(dev)->fb_ctor = nv50_fb_ctor;\r\nnouveau_display(dev)->fb_dtor = nv50_fb_dtor;\r\ndisp->disp = &nouveau_display(dev)->disp;\r\nret = nouveau_bo_new(dev, 4096, 0x1000, TTM_PL_FLAG_VRAM,\r\n0, 0x0000, NULL, NULL, &disp->sync);\r\nif (!ret) {\r\nret = nouveau_bo_pin(disp->sync, TTM_PL_FLAG_VRAM, true);\r\nif (!ret) {\r\nret = nouveau_bo_map(disp->sync);\r\nif (ret)\r\nnouveau_bo_unpin(disp->sync);\r\n}\r\nif (ret)\r\nnouveau_bo_ref(NULL, &disp->sync);\r\n}\r\nif (ret)\r\ngoto out;\r\nret = nv50_core_create(disp->disp, disp->sync->bo.offset,\r\n&disp->mast);\r\nif (ret)\r\ngoto out;\r\nif (disp->disp->oclass >= GF110_DISP)\r\ncrtcs = nvif_rd32(device, 0x022448);\r\nelse\r\ncrtcs = 2;\r\nfor (i = 0; i < crtcs; i++) {\r\nret = nv50_crtc_create(dev, i);\r\nif (ret)\r\ngoto out;\r\n}\r\nfor (i = 0, dcbe = &dcb->entry[0]; i < dcb->entries; i++, dcbe++) {\r\nconnector = nouveau_connector_create(dev, dcbe->connector);\r\nif (IS_ERR(connector))\r\ncontinue;\r\nif (dcbe->location == DCB_LOC_ON_CHIP) {\r\nswitch (dcbe->type) {\r\ncase DCB_OUTPUT_TMDS:\r\ncase DCB_OUTPUT_LVDS:\r\ncase DCB_OUTPUT_DP:\r\nret = nv50_sor_create(connector, dcbe);\r\nbreak;\r\ncase DCB_OUTPUT_ANALOG:\r\nret = nv50_dac_create(connector, dcbe);\r\nbreak;\r\ndefault:\r\nret = -ENODEV;\r\nbreak;\r\n}\r\n} else {\r\nret = nv50_pior_create(connector, dcbe);\r\n}\r\nif (ret) {\r\nNV_WARN(drm, "failed to create encoder %d/%d/%d: %d\n",\r\ndcbe->location, dcbe->type,\r\nffs(dcbe->or) - 1, ret);\r\nret = 0;\r\n}\r\n}\r\nlist_for_each_entry_safe(connector, tmp, &dev->mode_config.connector_list, head) {\r\nif (connector->encoder_ids[0])\r\ncontinue;\r\nNV_WARN(drm, "%s has no encoders, removing\n",\r\nconnector->name);\r\nconnector->funcs->destroy(connector);\r\n}\r\nout:\r\nif (ret)\r\nnv50_display_destroy(dev);\r\nreturn ret;\r\n}
