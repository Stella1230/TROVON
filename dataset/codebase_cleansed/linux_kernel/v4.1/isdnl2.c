static void\r\nset_peer_busy(struct Layer2 *l2) {\r\ntest_and_set_bit(FLG_PEER_BUSY, &l2->flag);\r\nif (!skb_queue_empty(&l2->i_queue) ||\r\n!skb_queue_empty(&l2->ui_queue))\r\ntest_and_set_bit(FLG_L2BLOCK, &l2->flag);\r\n}\r\nstatic void\r\nclear_peer_busy(struct Layer2 *l2) {\r\nif (test_and_clear_bit(FLG_PEER_BUSY, &l2->flag))\r\ntest_and_clear_bit(FLG_L2BLOCK, &l2->flag);\r\n}\r\nstatic void\r\nInitWin(struct Layer2 *l2)\r\n{\r\nint i;\r\nfor (i = 0; i < MAX_WINDOW; i++)\r\nl2->windowar[i] = NULL;\r\n}\r\nstatic int\r\nfreewin1(struct Layer2 *l2)\r\n{\r\nint i, cnt = 0;\r\nfor (i = 0; i < MAX_WINDOW; i++) {\r\nif (l2->windowar[i]) {\r\ncnt++;\r\ndev_kfree_skb(l2->windowar[i]);\r\nl2->windowar[i] = NULL;\r\n}\r\n}\r\nreturn cnt;\r\n}\r\nstatic inline void\r\nfreewin(struct PStack *st)\r\n{\r\nfreewin1(&st->l2);\r\n}\r\nstatic void\r\nReleaseWin(struct Layer2 *l2)\r\n{\r\nint cnt;\r\nif ((cnt = freewin1(l2)))\r\nprintk(KERN_WARNING "isdl2 freed %d skbuffs in release\n", cnt);\r\n}\r\nstatic inline unsigned int\r\ncansend(struct PStack *st)\r\n{\r\nunsigned int p1;\r\nif (test_bit(FLG_MOD128, &st->l2.flag))\r\np1 = (st->l2.vs - st->l2.va) % 128;\r\nelse\r\np1 = (st->l2.vs - st->l2.va) % 8;\r\nreturn ((p1 < st->l2.window) && !test_bit(FLG_PEER_BUSY, &st->l2.flag));\r\n}\r\nstatic inline void\r\nclear_exception(struct Layer2 *l2)\r\n{\r\ntest_and_clear_bit(FLG_ACK_PEND, &l2->flag);\r\ntest_and_clear_bit(FLG_REJEXC, &l2->flag);\r\ntest_and_clear_bit(FLG_OWN_BUSY, &l2->flag);\r\nclear_peer_busy(l2);\r\n}\r\nstatic inline int\r\nl2headersize(struct Layer2 *l2, int ui)\r\n{\r\nreturn (((test_bit(FLG_MOD128, &l2->flag) && (!ui)) ? 2 : 1) +\r\n(test_bit(FLG_LAPD, &l2->flag) ? 2 : 1));\r\n}\r\ninline int\r\nl2addrsize(struct Layer2 *l2)\r\n{\r\nreturn (test_bit(FLG_LAPD, &l2->flag) ? 2 : 1);\r\n}\r\nstatic int\r\nsethdraddr(struct Layer2 *l2, u_char *header, int rsp)\r\n{\r\nu_char *ptr = header;\r\nint crbit = rsp;\r\nif (test_bit(FLG_LAPD, &l2->flag)) {\r\n*ptr++ = (l2->sap << 2) | (rsp ? 2 : 0);\r\n*ptr++ = (l2->tei << 1) | 1;\r\nreturn (2);\r\n} else {\r\nif (test_bit(FLG_ORIG, &l2->flag))\r\ncrbit = !crbit;\r\nif (crbit)\r\n*ptr++ = 1;\r\nelse\r\n*ptr++ = 3;\r\nreturn (1);\r\n}\r\n}\r\nstatic inline void\r\nenqueue_super(struct PStack *st,\r\nstruct sk_buff *skb)\r\n{\r\nif (test_bit(FLG_LAPB, &st->l2.flag))\r\nst->l1.bcs->tx_cnt += skb->len;\r\nst->l2.l2l1(st, PH_DATA | REQUEST, skb);\r\n}\r\nstatic inline int\r\nIsUI(u_char *data)\r\n{\r\nreturn ((data[0] & 0xef) == UI);\r\n}\r\nstatic inline int\r\nIsUA(u_char *data)\r\n{\r\nreturn ((data[0] & 0xef) == UA);\r\n}\r\nstatic inline int\r\nIsDM(u_char *data)\r\n{\r\nreturn ((data[0] & 0xef) == DM);\r\n}\r\nstatic inline int\r\nIsDISC(u_char *data)\r\n{\r\nreturn ((data[0] & 0xef) == DISC);\r\n}\r\nstatic inline int\r\nIsSFrame(u_char *data, struct PStack *st)\r\n{\r\nregister u_char d = *data;\r\nif (!test_bit(FLG_MOD128, &st->l2.flag))\r\nd &= 0xf;\r\nreturn (((d & 0xf3) == 1) && ((d & 0x0c) != 0x0c));\r\n}\r\nstatic inline int\r\nIsSABME(u_char *data, struct PStack *st)\r\n{\r\nu_char d = data[0] & ~0x10;\r\nreturn (test_bit(FLG_MOD128, &st->l2.flag) ? d == SABME : d == SABM);\r\n}\r\nstatic inline int\r\nIsREJ(u_char *data, struct PStack *st)\r\n{\r\nreturn (test_bit(FLG_MOD128, &st->l2.flag) ? data[0] == REJ : (data[0] & 0xf) == REJ);\r\n}\r\nstatic inline int\r\nIsFRMR(u_char *data)\r\n{\r\nreturn ((data[0] & 0xef) == FRMR);\r\n}\r\nstatic inline int\r\nIsRNR(u_char *data, struct PStack *st)\r\n{\r\nreturn (test_bit(FLG_MOD128, &st->l2.flag) ? data[0] == RNR : (data[0] & 0xf) == RNR);\r\n}\r\nstatic int\r\niframe_error(struct PStack *st, struct sk_buff *skb)\r\n{\r\nint i = l2addrsize(&st->l2) + (test_bit(FLG_MOD128, &st->l2.flag) ? 2 : 1);\r\nint rsp = *skb->data & 0x2;\r\nif (test_bit(FLG_ORIG, &st->l2.flag))\r\nrsp = !rsp;\r\nif (rsp)\r\nreturn 'L';\r\nif (skb->len < i)\r\nreturn 'N';\r\nif ((skb->len - i) > st->l2.maxlen)\r\nreturn 'O';\r\nreturn 0;\r\n}\r\nstatic int\r\nsuper_error(struct PStack *st, struct sk_buff *skb)\r\n{\r\nif (skb->len != l2addrsize(&st->l2) +\r\n(test_bit(FLG_MOD128, &st->l2.flag) ? 2 : 1))\r\nreturn 'N';\r\nreturn 0;\r\n}\r\nstatic int\r\nunnum_error(struct PStack *st, struct sk_buff *skb, int wantrsp)\r\n{\r\nint rsp = (*skb->data & 0x2) >> 1;\r\nif (test_bit(FLG_ORIG, &st->l2.flag))\r\nrsp = !rsp;\r\nif (rsp != wantrsp)\r\nreturn 'L';\r\nif (skb->len != l2addrsize(&st->l2) + 1)\r\nreturn 'N';\r\nreturn 0;\r\n}\r\nstatic int\r\nUI_error(struct PStack *st, struct sk_buff *skb)\r\n{\r\nint rsp = *skb->data & 0x2;\r\nif (test_bit(FLG_ORIG, &st->l2.flag))\r\nrsp = !rsp;\r\nif (rsp)\r\nreturn 'L';\r\nif (skb->len > st->l2.maxlen + l2addrsize(&st->l2) + 1)\r\nreturn 'O';\r\nreturn 0;\r\n}\r\nstatic int\r\nFRMR_error(struct PStack *st, struct sk_buff *skb)\r\n{\r\nint headers = l2addrsize(&st->l2) + 1;\r\nu_char *datap = skb->data + headers;\r\nint rsp = *skb->data & 0x2;\r\nif (test_bit(FLG_ORIG, &st->l2.flag))\r\nrsp = !rsp;\r\nif (!rsp)\r\nreturn 'L';\r\nif (test_bit(FLG_MOD128, &st->l2.flag)) {\r\nif (skb->len < headers + 5)\r\nreturn 'N';\r\nelse\r\nl2m_debug(&st->l2.l2m, "FRMR information %2x %2x %2x %2x %2x",\r\ndatap[0], datap[1], datap[2],\r\ndatap[3], datap[4]);\r\n} else {\r\nif (skb->len < headers + 3)\r\nreturn 'N';\r\nelse\r\nl2m_debug(&st->l2.l2m, "FRMR information %2x %2x %2x",\r\ndatap[0], datap[1], datap[2]);\r\n}\r\nreturn 0;\r\n}\r\nstatic unsigned int\r\nlegalnr(struct PStack *st, unsigned int nr)\r\n{\r\nstruct Layer2 *l2 = &st->l2;\r\nif (test_bit(FLG_MOD128, &l2->flag))\r\nreturn ((nr - l2->va) % 128) <= ((l2->vs - l2->va) % 128);\r\nelse\r\nreturn ((nr - l2->va) % 8) <= ((l2->vs - l2->va) % 8);\r\n}\r\nstatic void\r\nsetva(struct PStack *st, unsigned int nr)\r\n{\r\nstruct Layer2 *l2 = &st->l2;\r\nint len;\r\nu_long flags;\r\nspin_lock_irqsave(&l2->lock, flags);\r\nwhile (l2->va != nr) {\r\n(l2->va)++;\r\nif (test_bit(FLG_MOD128, &l2->flag))\r\nl2->va %= 128;\r\nelse\r\nl2->va %= 8;\r\nlen = l2->windowar[l2->sow]->len;\r\nif (PACKET_NOACK == l2->windowar[l2->sow]->pkt_type)\r\nlen = -1;\r\ndev_kfree_skb(l2->windowar[l2->sow]);\r\nl2->windowar[l2->sow] = NULL;\r\nl2->sow = (l2->sow + 1) % l2->window;\r\nspin_unlock_irqrestore(&l2->lock, flags);\r\nif (test_bit(FLG_LLI_L2WAKEUP, &st->lli.flag) && (len >= 0))\r\nlli_writewakeup(st, len);\r\nspin_lock_irqsave(&l2->lock, flags);\r\n}\r\nspin_unlock_irqrestore(&l2->lock, flags);\r\n}\r\nstatic void\r\nsend_uframe(struct PStack *st, u_char cmd, u_char cr)\r\n{\r\nstruct sk_buff *skb;\r\nu_char tmp[MAX_HEADER_LEN];\r\nint i;\r\ni = sethdraddr(&st->l2, tmp, cr);\r\ntmp[i++] = cmd;\r\nif (!(skb = alloc_skb(i, GFP_ATOMIC))) {\r\nprintk(KERN_WARNING "isdl2 can't alloc sbbuff for send_uframe\n");\r\nreturn;\r\n}\r\nmemcpy(skb_put(skb, i), tmp, i);\r\nenqueue_super(st, skb);\r\n}\r\nstatic inline u_char\r\nget_PollFlag(struct PStack *st, struct sk_buff *skb)\r\n{\r\nreturn (skb->data[l2addrsize(&(st->l2))] & 0x10);\r\n}\r\nstatic inline u_char\r\nget_PollFlagFree(struct PStack *st, struct sk_buff *skb)\r\n{\r\nu_char PF;\r\nPF = get_PollFlag(st, skb);\r\ndev_kfree_skb(skb);\r\nreturn (PF);\r\n}\r\nstatic inline void\r\nstart_t200(struct PStack *st, int i)\r\n{\r\nFsmAddTimer(&st->l2.t200, st->l2.T200, EV_L2_T200, NULL, i);\r\ntest_and_set_bit(FLG_T200_RUN, &st->l2.flag);\r\n}\r\nstatic inline void\r\nrestart_t200(struct PStack *st, int i)\r\n{\r\nFsmRestartTimer(&st->l2.t200, st->l2.T200, EV_L2_T200, NULL, i);\r\ntest_and_set_bit(FLG_T200_RUN, &st->l2.flag);\r\n}\r\nstatic inline void\r\nstop_t200(struct PStack *st, int i)\r\n{\r\nif (test_and_clear_bit(FLG_T200_RUN, &st->l2.flag))\r\nFsmDelTimer(&st->l2.t200, i);\r\n}\r\nstatic inline void\r\nst5_dl_release_l2l3(struct PStack *st)\r\n{\r\nint pr;\r\nif (test_and_clear_bit(FLG_PEND_REL, &st->l2.flag))\r\npr = DL_RELEASE | CONFIRM;\r\nelse\r\npr = DL_RELEASE | INDICATION;\r\nst->l2.l2l3(st, pr, NULL);\r\n}\r\nstatic inline void\r\nlapb_dl_release_l2l3(struct PStack *st, int f)\r\n{\r\nif (test_bit(FLG_LAPB, &st->l2.flag))\r\nst->l2.l2l1(st, PH_DEACTIVATE | REQUEST, NULL);\r\nst->l2.l2l3(st, DL_RELEASE | f, NULL);\r\n}\r\nstatic void\r\nestablishlink(struct FsmInst *fi)\r\n{\r\nstruct PStack *st = fi->userdata;\r\nu_char cmd;\r\nclear_exception(&st->l2);\r\nst->l2.rc = 0;\r\ncmd = (test_bit(FLG_MOD128, &st->l2.flag) ? SABME : SABM) | 0x10;\r\nsend_uframe(st, cmd, CMD);\r\nFsmDelTimer(&st->l2.t203, 1);\r\nrestart_t200(st, 1);\r\ntest_and_clear_bit(FLG_PEND_REL, &st->l2.flag);\r\nfreewin(st);\r\nFsmChangeState(fi, ST_L2_5);\r\n}\r\nstatic void\r\nl2_mdl_error_ua(struct FsmInst *fi, int event, void *arg)\r\n{\r\nstruct sk_buff *skb = arg;\r\nstruct PStack *st = fi->userdata;\r\nif (get_PollFlagFree(st, skb))\r\nst->ma.layer(st, MDL_ERROR | INDICATION, (void *) 'C');\r\nelse\r\nst->ma.layer(st, MDL_ERROR | INDICATION, (void *) 'D');\r\n}\r\nstatic void\r\nl2_mdl_error_dm(struct FsmInst *fi, int event, void *arg)\r\n{\r\nstruct sk_buff *skb = arg;\r\nstruct PStack *st = fi->userdata;\r\nif (get_PollFlagFree(st, skb))\r\nst->ma.layer(st, MDL_ERROR | INDICATION, (void *) 'B');\r\nelse {\r\nst->ma.layer(st, MDL_ERROR | INDICATION, (void *) 'E');\r\nestablishlink(fi);\r\ntest_and_clear_bit(FLG_L3_INIT, &st->l2.flag);\r\n}\r\n}\r\nstatic void\r\nl2_st8_mdl_error_dm(struct FsmInst *fi, int event, void *arg)\r\n{\r\nstruct sk_buff *skb = arg;\r\nstruct PStack *st = fi->userdata;\r\nif (get_PollFlagFree(st, skb))\r\nst->ma.layer(st, MDL_ERROR | INDICATION, (void *) 'B');\r\nelse {\r\nst->ma.layer(st, MDL_ERROR | INDICATION, (void *) 'E');\r\n}\r\nestablishlink(fi);\r\ntest_and_clear_bit(FLG_L3_INIT, &st->l2.flag);\r\n}\r\nstatic void\r\nl2_go_st3(struct FsmInst *fi, int event, void *arg)\r\n{\r\nFsmChangeState(fi, ST_L2_3);\r\n}\r\nstatic void\r\nl2_mdl_assign(struct FsmInst *fi, int event, void *arg)\r\n{\r\nstruct PStack *st = fi->userdata;\r\nFsmChangeState(fi, ST_L2_3);\r\nst->l2.l2tei(st, MDL_ASSIGN | INDICATION, NULL);\r\n}\r\nstatic void\r\nl2_queue_ui_assign(struct FsmInst *fi, int event, void *arg)\r\n{\r\nstruct PStack *st = fi->userdata;\r\nstruct sk_buff *skb = arg;\r\nskb_queue_tail(&st->l2.ui_queue, skb);\r\nFsmChangeState(fi, ST_L2_2);\r\nst->l2.l2tei(st, MDL_ASSIGN | INDICATION, NULL);\r\n}\r\nstatic void\r\nl2_queue_ui(struct FsmInst *fi, int event, void *arg)\r\n{\r\nstruct PStack *st = fi->userdata;\r\nstruct sk_buff *skb = arg;\r\nskb_queue_tail(&st->l2.ui_queue, skb);\r\n}\r\nstatic void\r\ntx_ui(struct PStack *st)\r\n{\r\nstruct sk_buff *skb;\r\nu_char header[MAX_HEADER_LEN];\r\nint i;\r\ni = sethdraddr(&(st->l2), header, CMD);\r\nheader[i++] = UI;\r\nwhile ((skb = skb_dequeue(&st->l2.ui_queue))) {\r\nmemcpy(skb_push(skb, i), header, i);\r\nenqueue_ui(st, skb);\r\n}\r\n}\r\nstatic void\r\nl2_send_ui(struct FsmInst *fi, int event, void *arg)\r\n{\r\nstruct PStack *st = fi->userdata;\r\nstruct sk_buff *skb = arg;\r\nskb_queue_tail(&st->l2.ui_queue, skb);\r\ntx_ui(st);\r\n}\r\nstatic void\r\nl2_got_ui(struct FsmInst *fi, int event, void *arg)\r\n{\r\nstruct PStack *st = fi->userdata;\r\nstruct sk_buff *skb = arg;\r\nskb_pull(skb, l2headersize(&st->l2, 1));\r\nst->l2.l2l3(st, DL_UNIT_DATA | INDICATION, skb);\r\n}\r\nstatic void\r\nl2_establish(struct FsmInst *fi, int event, void *arg)\r\n{\r\nstruct PStack *st = fi->userdata;\r\nestablishlink(fi);\r\ntest_and_set_bit(FLG_L3_INIT, &st->l2.flag);\r\n}\r\nstatic void\r\nl2_discard_i_setl3(struct FsmInst *fi, int event, void *arg)\r\n{\r\nstruct PStack *st = fi->userdata;\r\nskb_queue_purge(&st->l2.i_queue);\r\ntest_and_set_bit(FLG_L3_INIT, &st->l2.flag);\r\ntest_and_clear_bit(FLG_PEND_REL, &st->l2.flag);\r\n}\r\nstatic void\r\nl2_l3_reestablish(struct FsmInst *fi, int event, void *arg)\r\n{\r\nstruct PStack *st = fi->userdata;\r\nskb_queue_purge(&st->l2.i_queue);\r\nestablishlink(fi);\r\ntest_and_set_bit(FLG_L3_INIT, &st->l2.flag);\r\n}\r\nstatic void\r\nl2_release(struct FsmInst *fi, int event, void *arg)\r\n{\r\nstruct PStack *st = fi->userdata;\r\nst->l2.l2l3(st, DL_RELEASE | CONFIRM, NULL);\r\n}\r\nstatic void\r\nl2_pend_rel(struct FsmInst *fi, int event, void *arg)\r\n{\r\nstruct PStack *st = fi->userdata;\r\ntest_and_set_bit(FLG_PEND_REL, &st->l2.flag);\r\n}\r\nstatic void\r\nl2_disconnect(struct FsmInst *fi, int event, void *arg)\r\n{\r\nstruct PStack *st = fi->userdata;\r\nskb_queue_purge(&st->l2.i_queue);\r\nfreewin(st);\r\nFsmChangeState(fi, ST_L2_6);\r\nst->l2.rc = 0;\r\nsend_uframe(st, DISC | 0x10, CMD);\r\nFsmDelTimer(&st->l2.t203, 1);\r\nrestart_t200(st, 2);\r\n}\r\nstatic void\r\nl2_start_multi(struct FsmInst *fi, int event, void *arg)\r\n{\r\nstruct PStack *st = fi->userdata;\r\nstruct sk_buff *skb = arg;\r\nsend_uframe(st, UA | get_PollFlagFree(st, skb), RSP);\r\nclear_exception(&st->l2);\r\nst->l2.vs = 0;\r\nst->l2.va = 0;\r\nst->l2.vr = 0;\r\nst->l2.sow = 0;\r\nFsmChangeState(fi, ST_L2_7);\r\nFsmAddTimer(&st->l2.t203, st->l2.T203, EV_L2_T203, NULL, 3);\r\nst->l2.l2l3(st, DL_ESTABLISH | INDICATION, NULL);\r\n}\r\nstatic void\r\nl2_send_UA(struct FsmInst *fi, int event, void *arg)\r\n{\r\nstruct PStack *st = fi->userdata;\r\nstruct sk_buff *skb = arg;\r\nsend_uframe(st, UA | get_PollFlagFree(st, skb), RSP);\r\n}\r\nstatic void\r\nl2_send_DM(struct FsmInst *fi, int event, void *arg)\r\n{\r\nstruct PStack *st = fi->userdata;\r\nstruct sk_buff *skb = arg;\r\nsend_uframe(st, DM | get_PollFlagFree(st, skb), RSP);\r\n}\r\nstatic void\r\nl2_restart_multi(struct FsmInst *fi, int event, void *arg)\r\n{\r\nstruct PStack *st = fi->userdata;\r\nstruct sk_buff *skb = arg;\r\nint est = 0, state;\r\nstate = fi->state;\r\nsend_uframe(st, UA | get_PollFlagFree(st, skb), RSP);\r\nst->ma.layer(st, MDL_ERROR | INDICATION, (void *) 'F');\r\nif (st->l2.vs != st->l2.va) {\r\nskb_queue_purge(&st->l2.i_queue);\r\nest = 1;\r\n}\r\nclear_exception(&st->l2);\r\nst->l2.vs = 0;\r\nst->l2.va = 0;\r\nst->l2.vr = 0;\r\nst->l2.sow = 0;\r\nFsmChangeState(fi, ST_L2_7);\r\nstop_t200(st, 3);\r\nFsmRestartTimer(&st->l2.t203, st->l2.T203, EV_L2_T203, NULL, 3);\r\nif (est)\r\nst->l2.l2l3(st, DL_ESTABLISH | INDICATION, NULL);\r\nif ((ST_L2_7 == state) || (ST_L2_8 == state))\r\nif (!skb_queue_empty(&st->l2.i_queue) && cansend(st))\r\nst->l2.l2l1(st, PH_PULL | REQUEST, NULL);\r\n}\r\nstatic void\r\nl2_stop_multi(struct FsmInst *fi, int event, void *arg)\r\n{\r\nstruct PStack *st = fi->userdata;\r\nstruct sk_buff *skb = arg;\r\nFsmChangeState(fi, ST_L2_4);\r\nFsmDelTimer(&st->l2.t203, 3);\r\nstop_t200(st, 4);\r\nsend_uframe(st, UA | get_PollFlagFree(st, skb), RSP);\r\nskb_queue_purge(&st->l2.i_queue);\r\nfreewin(st);\r\nlapb_dl_release_l2l3(st, INDICATION);\r\n}\r\nstatic void\r\nl2_connected(struct FsmInst *fi, int event, void *arg)\r\n{\r\nstruct PStack *st = fi->userdata;\r\nstruct sk_buff *skb = arg;\r\nint pr = -1;\r\nif (!get_PollFlag(st, skb)) {\r\nl2_mdl_error_ua(fi, event, arg);\r\nreturn;\r\n}\r\ndev_kfree_skb(skb);\r\nif (test_and_clear_bit(FLG_PEND_REL, &st->l2.flag))\r\nl2_disconnect(fi, event, arg);\r\nif (test_and_clear_bit(FLG_L3_INIT, &st->l2.flag)) {\r\npr = DL_ESTABLISH | CONFIRM;\r\n} else if (st->l2.vs != st->l2.va) {\r\nskb_queue_purge(&st->l2.i_queue);\r\npr = DL_ESTABLISH | INDICATION;\r\n}\r\nstop_t200(st, 5);\r\nst->l2.vr = 0;\r\nst->l2.vs = 0;\r\nst->l2.va = 0;\r\nst->l2.sow = 0;\r\nFsmChangeState(fi, ST_L2_7);\r\nFsmAddTimer(&st->l2.t203, st->l2.T203, EV_L2_T203, NULL, 4);\r\nif (pr != -1)\r\nst->l2.l2l3(st, pr, NULL);\r\nif (!skb_queue_empty(&st->l2.i_queue) && cansend(st))\r\nst->l2.l2l1(st, PH_PULL | REQUEST, NULL);\r\n}\r\nstatic void\r\nl2_released(struct FsmInst *fi, int event, void *arg)\r\n{\r\nstruct PStack *st = fi->userdata;\r\nstruct sk_buff *skb = arg;\r\nif (!get_PollFlag(st, skb)) {\r\nl2_mdl_error_ua(fi, event, arg);\r\nreturn;\r\n}\r\ndev_kfree_skb(skb);\r\nstop_t200(st, 6);\r\nlapb_dl_release_l2l3(st, CONFIRM);\r\nFsmChangeState(fi, ST_L2_4);\r\n}\r\nstatic void\r\nl2_reestablish(struct FsmInst *fi, int event, void *arg)\r\n{\r\nstruct PStack *st = fi->userdata;\r\nstruct sk_buff *skb = arg;\r\nif (!get_PollFlagFree(st, skb)) {\r\nestablishlink(fi);\r\ntest_and_set_bit(FLG_L3_INIT, &st->l2.flag);\r\n}\r\n}\r\nstatic void\r\nl2_st5_dm_release(struct FsmInst *fi, int event, void *arg)\r\n{\r\nstruct PStack *st = fi->userdata;\r\nstruct sk_buff *skb = arg;\r\nif (get_PollFlagFree(st, skb)) {\r\nstop_t200(st, 7);\r\nif (!test_bit(FLG_L3_INIT, &st->l2.flag))\r\nskb_queue_purge(&st->l2.i_queue);\r\nif (test_bit(FLG_LAPB, &st->l2.flag))\r\nst->l2.l2l1(st, PH_DEACTIVATE | REQUEST, NULL);\r\nst5_dl_release_l2l3(st);\r\nFsmChangeState(fi, ST_L2_4);\r\n}\r\n}\r\nstatic void\r\nl2_st6_dm_release(struct FsmInst *fi, int event, void *arg)\r\n{\r\nstruct PStack *st = fi->userdata;\r\nstruct sk_buff *skb = arg;\r\nif (get_PollFlagFree(st, skb)) {\r\nstop_t200(st, 8);\r\nlapb_dl_release_l2l3(st, CONFIRM);\r\nFsmChangeState(fi, ST_L2_4);\r\n}\r\n}\r\nstatic inline void\r\nenquiry_cr(struct PStack *st, u_char typ, u_char cr, u_char pf)\r\n{\r\nstruct sk_buff *skb;\r\nstruct Layer2 *l2;\r\nu_char tmp[MAX_HEADER_LEN];\r\nint i;\r\nl2 = &st->l2;\r\ni = sethdraddr(l2, tmp, cr);\r\nif (test_bit(FLG_MOD128, &l2->flag)) {\r\ntmp[i++] = typ;\r\ntmp[i++] = (l2->vr << 1) | (pf ? 1 : 0);\r\n} else\r\ntmp[i++] = (l2->vr << 5) | typ | (pf ? 0x10 : 0);\r\nif (!(skb = alloc_skb(i, GFP_ATOMIC))) {\r\nprintk(KERN_WARNING "isdl2 can't alloc sbbuff for enquiry_cr\n");\r\nreturn;\r\n}\r\nmemcpy(skb_put(skb, i), tmp, i);\r\nenqueue_super(st, skb);\r\n}\r\nstatic inline void\r\nenquiry_response(struct PStack *st)\r\n{\r\nif (test_bit(FLG_OWN_BUSY, &st->l2.flag))\r\nenquiry_cr(st, RNR, RSP, 1);\r\nelse\r\nenquiry_cr(st, RR, RSP, 1);\r\ntest_and_clear_bit(FLG_ACK_PEND, &st->l2.flag);\r\n}\r\nstatic inline void\r\ntransmit_enquiry(struct PStack *st)\r\n{\r\nif (test_bit(FLG_OWN_BUSY, &st->l2.flag))\r\nenquiry_cr(st, RNR, CMD, 1);\r\nelse\r\nenquiry_cr(st, RR, CMD, 1);\r\ntest_and_clear_bit(FLG_ACK_PEND, &st->l2.flag);\r\nstart_t200(st, 9);\r\n}\r\nstatic void\r\nnrerrorrecovery(struct FsmInst *fi)\r\n{\r\nstruct PStack *st = fi->userdata;\r\nst->ma.layer(st, MDL_ERROR | INDICATION, (void *) 'J');\r\nestablishlink(fi);\r\ntest_and_clear_bit(FLG_L3_INIT, &st->l2.flag);\r\n}\r\nstatic void\r\ninvoke_retransmission(struct PStack *st, unsigned int nr)\r\n{\r\nstruct Layer2 *l2 = &st->l2;\r\nu_int p1;\r\nu_long flags;\r\nspin_lock_irqsave(&l2->lock, flags);\r\nif (l2->vs != nr) {\r\nwhile (l2->vs != nr) {\r\n(l2->vs)--;\r\nif (test_bit(FLG_MOD128, &l2->flag)) {\r\nl2->vs %= 128;\r\np1 = (l2->vs - l2->va) % 128;\r\n} else {\r\nl2->vs %= 8;\r\np1 = (l2->vs - l2->va) % 8;\r\n}\r\np1 = (p1 + l2->sow) % l2->window;\r\nif (test_bit(FLG_LAPB, &l2->flag))\r\nst->l1.bcs->tx_cnt += l2->windowar[p1]->len + l2headersize(l2, 0);\r\nskb_queue_head(&l2->i_queue, l2->windowar[p1]);\r\nl2->windowar[p1] = NULL;\r\n}\r\nspin_unlock_irqrestore(&l2->lock, flags);\r\nst->l2.l2l1(st, PH_PULL | REQUEST, NULL);\r\nreturn;\r\n}\r\nspin_unlock_irqrestore(&l2->lock, flags);\r\n}\r\nstatic void\r\nl2_st7_got_super(struct FsmInst *fi, int event, void *arg)\r\n{\r\nstruct PStack *st = fi->userdata;\r\nstruct sk_buff *skb = arg;\r\nint PollFlag, rsp, typ = RR;\r\nunsigned int nr;\r\nstruct Layer2 *l2 = &st->l2;\r\nrsp = *skb->data & 0x2;\r\nif (test_bit(FLG_ORIG, &l2->flag))\r\nrsp = !rsp;\r\nskb_pull(skb, l2addrsize(l2));\r\nif (IsRNR(skb->data, st)) {\r\nset_peer_busy(l2);\r\ntyp = RNR;\r\n} else\r\nclear_peer_busy(l2);\r\nif (IsREJ(skb->data, st))\r\ntyp = REJ;\r\nif (test_bit(FLG_MOD128, &l2->flag)) {\r\nPollFlag = (skb->data[1] & 0x1) == 0x1;\r\nnr = skb->data[1] >> 1;\r\n} else {\r\nPollFlag = (skb->data[0] & 0x10);\r\nnr = (skb->data[0] >> 5) & 0x7;\r\n}\r\ndev_kfree_skb(skb);\r\nif (PollFlag) {\r\nif (rsp)\r\nst->ma.layer(st, MDL_ERROR | INDICATION, (void *) 'A');\r\nelse\r\nenquiry_response(st);\r\n}\r\nif (legalnr(st, nr)) {\r\nif (typ == REJ) {\r\nsetva(st, nr);\r\ninvoke_retransmission(st, nr);\r\nstop_t200(st, 10);\r\nif (FsmAddTimer(&st->l2.t203, st->l2.T203,\r\nEV_L2_T203, NULL, 6))\r\nl2m_debug(&st->l2.l2m, "Restart T203 ST7 REJ");\r\n} else if ((nr == l2->vs) && (typ == RR)) {\r\nsetva(st, nr);\r\nstop_t200(st, 11);\r\nFsmRestartTimer(&st->l2.t203, st->l2.T203,\r\nEV_L2_T203, NULL, 7);\r\n} else if ((l2->va != nr) || (typ == RNR)) {\r\nsetva(st, nr);\r\nif (typ != RR) FsmDelTimer(&st->l2.t203, 9);\r\nrestart_t200(st, 12);\r\n}\r\nif (!skb_queue_empty(&st->l2.i_queue) && (typ == RR))\r\nst->l2.l2l1(st, PH_PULL | REQUEST, NULL);\r\n} else\r\nnrerrorrecovery(fi);\r\n}\r\nstatic void\r\nl2_feed_i_if_reest(struct FsmInst *fi, int event, void *arg)\r\n{\r\nstruct PStack *st = fi->userdata;\r\nstruct sk_buff *skb = arg;\r\nif (test_bit(FLG_LAPB, &st->l2.flag))\r\nst->l1.bcs->tx_cnt += skb->len + l2headersize(&st->l2, 0);\r\nif (!test_bit(FLG_L3_INIT, &st->l2.flag))\r\nskb_queue_tail(&st->l2.i_queue, skb);\r\nelse\r\ndev_kfree_skb(skb);\r\n}\r\nstatic void\r\nl2_feed_i_pull(struct FsmInst *fi, int event, void *arg)\r\n{\r\nstruct PStack *st = fi->userdata;\r\nstruct sk_buff *skb = arg;\r\nif (test_bit(FLG_LAPB, &st->l2.flag))\r\nst->l1.bcs->tx_cnt += skb->len + l2headersize(&st->l2, 0);\r\nskb_queue_tail(&st->l2.i_queue, skb);\r\nst->l2.l2l1(st, PH_PULL | REQUEST, NULL);\r\n}\r\nstatic void\r\nl2_feed_iqueue(struct FsmInst *fi, int event, void *arg)\r\n{\r\nstruct PStack *st = fi->userdata;\r\nstruct sk_buff *skb = arg;\r\nif (test_bit(FLG_LAPB, &st->l2.flag))\r\nst->l1.bcs->tx_cnt += skb->len + l2headersize(&st->l2, 0);\r\nskb_queue_tail(&st->l2.i_queue, skb);\r\n}\r\nstatic void\r\nl2_got_iframe(struct FsmInst *fi, int event, void *arg)\r\n{\r\nstruct PStack *st = fi->userdata;\r\nstruct sk_buff *skb = arg;\r\nstruct Layer2 *l2 = &(st->l2);\r\nint PollFlag, ns, i;\r\nunsigned int nr;\r\ni = l2addrsize(l2);\r\nif (test_bit(FLG_MOD128, &l2->flag)) {\r\nPollFlag = ((skb->data[i + 1] & 0x1) == 0x1);\r\nns = skb->data[i] >> 1;\r\nnr = (skb->data[i + 1] >> 1) & 0x7f;\r\n} else {\r\nPollFlag = (skb->data[i] & 0x10);\r\nns = (skb->data[i] >> 1) & 0x7;\r\nnr = (skb->data[i] >> 5) & 0x7;\r\n}\r\nif (test_bit(FLG_OWN_BUSY, &l2->flag)) {\r\ndev_kfree_skb(skb);\r\nif (PollFlag) enquiry_response(st);\r\n} else if (l2->vr == ns) {\r\n(l2->vr)++;\r\nif (test_bit(FLG_MOD128, &l2->flag))\r\nl2->vr %= 128;\r\nelse\r\nl2->vr %= 8;\r\ntest_and_clear_bit(FLG_REJEXC, &l2->flag);\r\nif (PollFlag)\r\nenquiry_response(st);\r\nelse\r\ntest_and_set_bit(FLG_ACK_PEND, &l2->flag);\r\nskb_pull(skb, l2headersize(l2, 0));\r\nst->l2.l2l3(st, DL_DATA | INDICATION, skb);\r\n} else {\r\ndev_kfree_skb(skb);\r\nif (test_and_set_bit(FLG_REJEXC, &l2->flag)) {\r\nif (PollFlag)\r\nenquiry_response(st);\r\n} else {\r\nenquiry_cr(st, REJ, RSP, PollFlag);\r\ntest_and_clear_bit(FLG_ACK_PEND, &l2->flag);\r\n}\r\n}\r\nif (legalnr(st, nr)) {\r\nif (!test_bit(FLG_PEER_BUSY, &st->l2.flag) && (fi->state == ST_L2_7)) {\r\nif (nr == st->l2.vs) {\r\nstop_t200(st, 13);\r\nFsmRestartTimer(&st->l2.t203, st->l2.T203,\r\nEV_L2_T203, NULL, 7);\r\n} else if (nr != st->l2.va)\r\nrestart_t200(st, 14);\r\n}\r\nsetva(st, nr);\r\n} else {\r\nnrerrorrecovery(fi);\r\nreturn;\r\n}\r\nif (!skb_queue_empty(&st->l2.i_queue) && (fi->state == ST_L2_7))\r\nst->l2.l2l1(st, PH_PULL | REQUEST, NULL);\r\nif (test_and_clear_bit(FLG_ACK_PEND, &st->l2.flag))\r\nenquiry_cr(st, RR, RSP, 0);\r\n}\r\nstatic void\r\nl2_got_tei(struct FsmInst *fi, int event, void *arg)\r\n{\r\nstruct PStack *st = fi->userdata;\r\nst->l2.tei = (long) arg;\r\nif (fi->state == ST_L2_3) {\r\nestablishlink(fi);\r\ntest_and_set_bit(FLG_L3_INIT, &st->l2.flag);\r\n} else\r\nFsmChangeState(fi, ST_L2_4);\r\nif (!skb_queue_empty(&st->l2.ui_queue))\r\ntx_ui(st);\r\n}\r\nstatic void\r\nl2_st5_tout_200(struct FsmInst *fi, int event, void *arg)\r\n{\r\nstruct PStack *st = fi->userdata;\r\nif (test_bit(FLG_LAPD, &st->l2.flag) &&\r\ntest_bit(FLG_DCHAN_BUSY, &st->l2.flag)) {\r\nFsmAddTimer(&st->l2.t200, st->l2.T200, EV_L2_T200, NULL, 9);\r\n} else if (st->l2.rc == st->l2.N200) {\r\nFsmChangeState(fi, ST_L2_4);\r\ntest_and_clear_bit(FLG_T200_RUN, &st->l2.flag);\r\nskb_queue_purge(&st->l2.i_queue);\r\nst->ma.layer(st, MDL_ERROR | INDICATION, (void *) 'G');\r\nif (test_bit(FLG_LAPB, &st->l2.flag))\r\nst->l2.l2l1(st, PH_DEACTIVATE | REQUEST, NULL);\r\nst5_dl_release_l2l3(st);\r\n} else {\r\nst->l2.rc++;\r\nFsmAddTimer(&st->l2.t200, st->l2.T200, EV_L2_T200, NULL, 9);\r\nsend_uframe(st, (test_bit(FLG_MOD128, &st->l2.flag) ? SABME : SABM)\r\n| 0x10, CMD);\r\n}\r\n}\r\nstatic void\r\nl2_st6_tout_200(struct FsmInst *fi, int event, void *arg)\r\n{\r\nstruct PStack *st = fi->userdata;\r\nif (test_bit(FLG_LAPD, &st->l2.flag) &&\r\ntest_bit(FLG_DCHAN_BUSY, &st->l2.flag)) {\r\nFsmAddTimer(&st->l2.t200, st->l2.T200, EV_L2_T200, NULL, 9);\r\n} else if (st->l2.rc == st->l2.N200) {\r\nFsmChangeState(fi, ST_L2_4);\r\ntest_and_clear_bit(FLG_T200_RUN, &st->l2.flag);\r\nst->ma.layer(st, MDL_ERROR | INDICATION, (void *) 'H');\r\nlapb_dl_release_l2l3(st, CONFIRM);\r\n} else {\r\nst->l2.rc++;\r\nFsmAddTimer(&st->l2.t200, st->l2.T200, EV_L2_T200,\r\nNULL, 9);\r\nsend_uframe(st, DISC | 0x10, CMD);\r\n}\r\n}\r\nstatic void\r\nl2_st7_tout_200(struct FsmInst *fi, int event, void *arg)\r\n{\r\nstruct PStack *st = fi->userdata;\r\nif (test_bit(FLG_LAPD, &st->l2.flag) &&\r\ntest_bit(FLG_DCHAN_BUSY, &st->l2.flag)) {\r\nFsmAddTimer(&st->l2.t200, st->l2.T200, EV_L2_T200, NULL, 9);\r\nreturn;\r\n}\r\ntest_and_clear_bit(FLG_T200_RUN, &st->l2.flag);\r\nst->l2.rc = 0;\r\nFsmChangeState(fi, ST_L2_8);\r\ntransmit_enquiry(st);\r\nst->l2.rc++;\r\n}\r\nstatic void\r\nl2_st8_tout_200(struct FsmInst *fi, int event, void *arg)\r\n{\r\nstruct PStack *st = fi->userdata;\r\nif (test_bit(FLG_LAPD, &st->l2.flag) &&\r\ntest_bit(FLG_DCHAN_BUSY, &st->l2.flag)) {\r\nFsmAddTimer(&st->l2.t200, st->l2.T200, EV_L2_T200, NULL, 9);\r\nreturn;\r\n}\r\ntest_and_clear_bit(FLG_T200_RUN, &st->l2.flag);\r\nif (st->l2.rc == st->l2.N200) {\r\nst->ma.layer(st, MDL_ERROR | INDICATION, (void *) 'I');\r\nestablishlink(fi);\r\ntest_and_clear_bit(FLG_L3_INIT, &st->l2.flag);\r\n} else {\r\ntransmit_enquiry(st);\r\nst->l2.rc++;\r\n}\r\n}\r\nstatic void\r\nl2_st7_tout_203(struct FsmInst *fi, int event, void *arg)\r\n{\r\nstruct PStack *st = fi->userdata;\r\nif (test_bit(FLG_LAPD, &st->l2.flag) &&\r\ntest_bit(FLG_DCHAN_BUSY, &st->l2.flag)) {\r\nFsmAddTimer(&st->l2.t203, st->l2.T203, EV_L2_T203, NULL, 9);\r\nreturn;\r\n}\r\nFsmChangeState(fi, ST_L2_8);\r\ntransmit_enquiry(st);\r\nst->l2.rc = 0;\r\n}\r\nstatic void\r\nl2_pull_iqueue(struct FsmInst *fi, int event, void *arg)\r\n{\r\nstruct PStack *st = fi->userdata;\r\nstruct sk_buff *skb;\r\nstruct Layer2 *l2 = &st->l2;\r\nu_char header[MAX_HEADER_LEN];\r\nint i, hdr_space_needed;\r\nint unsigned p1;\r\nu_long flags;\r\nif (!cansend(st))\r\nreturn;\r\nskb = skb_dequeue(&l2->i_queue);\r\nif (!skb)\r\nreturn;\r\nhdr_space_needed = l2headersize(l2, 0);\r\nif (hdr_space_needed > skb_headroom(skb)) {\r\nstruct sk_buff *orig_skb = skb;\r\nskb = skb_realloc_headroom(skb, hdr_space_needed);\r\nif (!skb) {\r\ndev_kfree_skb(orig_skb);\r\nreturn;\r\n}\r\n}\r\nspin_lock_irqsave(&l2->lock, flags);\r\nif (test_bit(FLG_MOD128, &l2->flag))\r\np1 = (l2->vs - l2->va) % 128;\r\nelse\r\np1 = (l2->vs - l2->va) % 8;\r\np1 = (p1 + l2->sow) % l2->window;\r\nif (l2->windowar[p1]) {\r\nprintk(KERN_WARNING "isdnl2 try overwrite ack queue entry %d\n",\r\np1);\r\ndev_kfree_skb(l2->windowar[p1]);\r\n}\r\nl2->windowar[p1] = skb_clone(skb, GFP_ATOMIC);\r\ni = sethdraddr(&st->l2, header, CMD);\r\nif (test_bit(FLG_MOD128, &l2->flag)) {\r\nheader[i++] = l2->vs << 1;\r\nheader[i++] = l2->vr << 1;\r\nl2->vs = (l2->vs + 1) % 128;\r\n} else {\r\nheader[i++] = (l2->vr << 5) | (l2->vs << 1);\r\nl2->vs = (l2->vs + 1) % 8;\r\n}\r\nspin_unlock_irqrestore(&l2->lock, flags);\r\nmemcpy(skb_push(skb, i), header, i);\r\nst->l2.l2l1(st, PH_PULL | INDICATION, skb);\r\ntest_and_clear_bit(FLG_ACK_PEND, &st->l2.flag);\r\nif (!test_and_set_bit(FLG_T200_RUN, &st->l2.flag)) {\r\nFsmDelTimer(&st->l2.t203, 13);\r\nFsmAddTimer(&st->l2.t200, st->l2.T200, EV_L2_T200, NULL, 11);\r\n}\r\nif (!skb_queue_empty(&l2->i_queue) && cansend(st))\r\nst->l2.l2l1(st, PH_PULL | REQUEST, NULL);\r\n}\r\nstatic void\r\nl2_st8_got_super(struct FsmInst *fi, int event, void *arg)\r\n{\r\nstruct PStack *st = fi->userdata;\r\nstruct sk_buff *skb = arg;\r\nint PollFlag, rsp, rnr = 0;\r\nunsigned int nr;\r\nstruct Layer2 *l2 = &st->l2;\r\nrsp = *skb->data & 0x2;\r\nif (test_bit(FLG_ORIG, &l2->flag))\r\nrsp = !rsp;\r\nskb_pull(skb, l2addrsize(l2));\r\nif (IsRNR(skb->data, st)) {\r\nset_peer_busy(l2);\r\nrnr = 1;\r\n} else\r\nclear_peer_busy(l2);\r\nif (test_bit(FLG_MOD128, &l2->flag)) {\r\nPollFlag = (skb->data[1] & 0x1) == 0x1;\r\nnr = skb->data[1] >> 1;\r\n} else {\r\nPollFlag = (skb->data[0] & 0x10);\r\nnr = (skb->data[0] >> 5) & 0x7;\r\n}\r\ndev_kfree_skb(skb);\r\nif (rsp && PollFlag) {\r\nif (legalnr(st, nr)) {\r\nif (rnr) {\r\nrestart_t200(st, 15);\r\n} else {\r\nstop_t200(st, 16);\r\nFsmAddTimer(&l2->t203, l2->T203,\r\nEV_L2_T203, NULL, 5);\r\nsetva(st, nr);\r\n}\r\ninvoke_retransmission(st, nr);\r\nFsmChangeState(fi, ST_L2_7);\r\nif (!skb_queue_empty(&l2->i_queue) && cansend(st))\r\nst->l2.l2l1(st, PH_PULL | REQUEST, NULL);\r\n} else\r\nnrerrorrecovery(fi);\r\n} else {\r\nif (!rsp && PollFlag)\r\nenquiry_response(st);\r\nif (legalnr(st, nr)) {\r\nsetva(st, nr);\r\n} else\r\nnrerrorrecovery(fi);\r\n}\r\n}\r\nstatic void\r\nl2_got_FRMR(struct FsmInst *fi, int event, void *arg)\r\n{\r\nstruct PStack *st = fi->userdata;\r\nstruct sk_buff *skb = arg;\r\nskb_pull(skb, l2addrsize(&st->l2) + 1);\r\nif (!(skb->data[0] & 1) || ((skb->data[0] & 3) == 1) ||\r\n(IsUA(skb->data) && (fi->state == ST_L2_7))) {\r\nst->ma.layer(st, MDL_ERROR | INDICATION, (void *) 'K');\r\nestablishlink(fi);\r\ntest_and_clear_bit(FLG_L3_INIT, &st->l2.flag);\r\n}\r\ndev_kfree_skb(skb);\r\n}\r\nstatic void\r\nl2_st24_tei_remove(struct FsmInst *fi, int event, void *arg)\r\n{\r\nstruct PStack *st = fi->userdata;\r\nskb_queue_purge(&st->l2.ui_queue);\r\nst->l2.tei = -1;\r\nFsmChangeState(fi, ST_L2_1);\r\n}\r\nstatic void\r\nl2_st3_tei_remove(struct FsmInst *fi, int event, void *arg)\r\n{\r\nstruct PStack *st = fi->userdata;\r\nskb_queue_purge(&st->l2.ui_queue);\r\nst->l2.tei = -1;\r\nst->l2.l2l3(st, DL_RELEASE | INDICATION, NULL);\r\nFsmChangeState(fi, ST_L2_1);\r\n}\r\nstatic void\r\nl2_st5_tei_remove(struct FsmInst *fi, int event, void *arg)\r\n{\r\nstruct PStack *st = fi->userdata;\r\nskb_queue_purge(&st->l2.i_queue);\r\nskb_queue_purge(&st->l2.ui_queue);\r\nfreewin(st);\r\nst->l2.tei = -1;\r\nstop_t200(st, 17);\r\nst5_dl_release_l2l3(st);\r\nFsmChangeState(fi, ST_L2_1);\r\n}\r\nstatic void\r\nl2_st6_tei_remove(struct FsmInst *fi, int event, void *arg)\r\n{\r\nstruct PStack *st = fi->userdata;\r\nskb_queue_purge(&st->l2.ui_queue);\r\nst->l2.tei = -1;\r\nstop_t200(st, 18);\r\nst->l2.l2l3(st, DL_RELEASE | CONFIRM, NULL);\r\nFsmChangeState(fi, ST_L2_1);\r\n}\r\nstatic void\r\nl2_tei_remove(struct FsmInst *fi, int event, void *arg)\r\n{\r\nstruct PStack *st = fi->userdata;\r\nskb_queue_purge(&st->l2.i_queue);\r\nskb_queue_purge(&st->l2.ui_queue);\r\nfreewin(st);\r\nst->l2.tei = -1;\r\nstop_t200(st, 17);\r\nFsmDelTimer(&st->l2.t203, 19);\r\nst->l2.l2l3(st, DL_RELEASE | INDICATION, NULL);\r\nFsmChangeState(fi, ST_L2_1);\r\n}\r\nstatic void\r\nl2_st14_persistent_da(struct FsmInst *fi, int event, void *arg)\r\n{\r\nstruct PStack *st = fi->userdata;\r\nskb_queue_purge(&st->l2.i_queue);\r\nskb_queue_purge(&st->l2.ui_queue);\r\nif (test_and_clear_bit(FLG_ESTAB_PEND, &st->l2.flag))\r\nst->l2.l2l3(st, DL_RELEASE | INDICATION, NULL);\r\n}\r\nstatic void\r\nl2_st5_persistent_da(struct FsmInst *fi, int event, void *arg)\r\n{\r\nstruct PStack *st = fi->userdata;\r\nskb_queue_purge(&st->l2.i_queue);\r\nskb_queue_purge(&st->l2.ui_queue);\r\nfreewin(st);\r\nstop_t200(st, 19);\r\nst5_dl_release_l2l3(st);\r\nFsmChangeState(fi, ST_L2_4);\r\n}\r\nstatic void\r\nl2_st6_persistent_da(struct FsmInst *fi, int event, void *arg)\r\n{\r\nstruct PStack *st = fi->userdata;\r\nskb_queue_purge(&st->l2.ui_queue);\r\nstop_t200(st, 20);\r\nst->l2.l2l3(st, DL_RELEASE | CONFIRM, NULL);\r\nFsmChangeState(fi, ST_L2_4);\r\n}\r\nstatic void\r\nl2_persistent_da(struct FsmInst *fi, int event, void *arg)\r\n{\r\nstruct PStack *st = fi->userdata;\r\nskb_queue_purge(&st->l2.i_queue);\r\nskb_queue_purge(&st->l2.ui_queue);\r\nfreewin(st);\r\nstop_t200(st, 19);\r\nFsmDelTimer(&st->l2.t203, 19);\r\nst->l2.l2l3(st, DL_RELEASE | INDICATION, NULL);\r\nFsmChangeState(fi, ST_L2_4);\r\n}\r\nstatic void\r\nl2_set_own_busy(struct FsmInst *fi, int event, void *arg)\r\n{\r\nstruct PStack *st = fi->userdata;\r\nif (!test_and_set_bit(FLG_OWN_BUSY, &st->l2.flag)) {\r\nenquiry_cr(st, RNR, RSP, 0);\r\ntest_and_clear_bit(FLG_ACK_PEND, &st->l2.flag);\r\n}\r\n}\r\nstatic void\r\nl2_clear_own_busy(struct FsmInst *fi, int event, void *arg)\r\n{\r\nstruct PStack *st = fi->userdata;\r\nif (!test_and_clear_bit(FLG_OWN_BUSY, &st->l2.flag)) {\r\nenquiry_cr(st, RR, RSP, 0);\r\ntest_and_clear_bit(FLG_ACK_PEND, &st->l2.flag);\r\n}\r\n}\r\nstatic void\r\nl2_frame_error(struct FsmInst *fi, int event, void *arg)\r\n{\r\nstruct PStack *st = fi->userdata;\r\nst->ma.layer(st, MDL_ERROR | INDICATION, arg);\r\n}\r\nstatic void\r\nl2_frame_error_reest(struct FsmInst *fi, int event, void *arg)\r\n{\r\nstruct PStack *st = fi->userdata;\r\nst->ma.layer(st, MDL_ERROR | INDICATION, arg);\r\nestablishlink(fi);\r\ntest_and_clear_bit(FLG_L3_INIT, &st->l2.flag);\r\n}\r\nstatic void\r\nisdnl2_l1l2(struct PStack *st, int pr, void *arg)\r\n{\r\nstruct sk_buff *skb = arg;\r\nu_char *datap;\r\nint ret = 1, len;\r\nint c = 0;\r\nswitch (pr) {\r\ncase (PH_DATA | INDICATION):\r\ndatap = skb->data;\r\nlen = l2addrsize(&st->l2);\r\nif (skb->len > len)\r\ndatap += len;\r\nelse {\r\nFsmEvent(&st->l2.l2m, EV_L2_FRAME_ERROR, (void *) 'N');\r\ndev_kfree_skb(skb);\r\nreturn;\r\n}\r\nif (!(*datap & 1)) {\r\nif (!(c = iframe_error(st, skb)))\r\nret = FsmEvent(&st->l2.l2m, EV_L2_I, skb);\r\n} else if (IsSFrame(datap, st)) {\r\nif (!(c = super_error(st, skb)))\r\nret = FsmEvent(&st->l2.l2m, EV_L2_SUPER, skb);\r\n} else if (IsUI(datap)) {\r\nif (!(c = UI_error(st, skb)))\r\nret = FsmEvent(&st->l2.l2m, EV_L2_UI, skb);\r\n} else if (IsSABME(datap, st)) {\r\nif (!(c = unnum_error(st, skb, CMD)))\r\nret = FsmEvent(&st->l2.l2m, EV_L2_SABME, skb);\r\n} else if (IsUA(datap)) {\r\nif (!(c = unnum_error(st, skb, RSP)))\r\nret = FsmEvent(&st->l2.l2m, EV_L2_UA, skb);\r\n} else if (IsDISC(datap)) {\r\nif (!(c = unnum_error(st, skb, CMD)))\r\nret = FsmEvent(&st->l2.l2m, EV_L2_DISC, skb);\r\n} else if (IsDM(datap)) {\r\nif (!(c = unnum_error(st, skb, RSP)))\r\nret = FsmEvent(&st->l2.l2m, EV_L2_DM, skb);\r\n} else if (IsFRMR(datap)) {\r\nif (!(c = FRMR_error(st, skb)))\r\nret = FsmEvent(&st->l2.l2m, EV_L2_FRMR, skb);\r\n} else {\r\nFsmEvent(&st->l2.l2m, EV_L2_FRAME_ERROR, (void *) 'L');\r\ndev_kfree_skb(skb);\r\nret = 0;\r\n}\r\nif (c) {\r\ndev_kfree_skb(skb);\r\nFsmEvent(&st->l2.l2m, EV_L2_FRAME_ERROR, (void *)(long)c);\r\nret = 0;\r\n}\r\nif (ret)\r\ndev_kfree_skb(skb);\r\nbreak;\r\ncase (PH_PULL | CONFIRM):\r\nFsmEvent(&st->l2.l2m, EV_L2_ACK_PULL, arg);\r\nbreak;\r\ncase (PH_PAUSE | INDICATION):\r\ntest_and_set_bit(FLG_DCHAN_BUSY, &st->l2.flag);\r\nbreak;\r\ncase (PH_PAUSE | CONFIRM):\r\ntest_and_clear_bit(FLG_DCHAN_BUSY, &st->l2.flag);\r\nbreak;\r\ncase (PH_ACTIVATE | CONFIRM):\r\ncase (PH_ACTIVATE | INDICATION):\r\ntest_and_set_bit(FLG_L1_ACTIV, &st->l2.flag);\r\nif (test_and_clear_bit(FLG_ESTAB_PEND, &st->l2.flag))\r\nFsmEvent(&st->l2.l2m, EV_L2_DL_ESTABLISH_REQ, arg);\r\nbreak;\r\ncase (PH_DEACTIVATE | INDICATION):\r\ncase (PH_DEACTIVATE | CONFIRM):\r\ntest_and_clear_bit(FLG_L1_ACTIV, &st->l2.flag);\r\nFsmEvent(&st->l2.l2m, EV_L1_DEACTIVATE, arg);\r\nbreak;\r\ndefault:\r\nl2m_debug(&st->l2.l2m, "l2 unknown pr %04x", pr);\r\nbreak;\r\n}\r\n}\r\nstatic void\r\nisdnl2_l3l2(struct PStack *st, int pr, void *arg)\r\n{\r\nswitch (pr) {\r\ncase (DL_DATA | REQUEST):\r\nif (FsmEvent(&st->l2.l2m, EV_L2_DL_DATA, arg)) {\r\ndev_kfree_skb((struct sk_buff *) arg);\r\n}\r\nbreak;\r\ncase (DL_UNIT_DATA | REQUEST):\r\nif (FsmEvent(&st->l2.l2m, EV_L2_DL_UNIT_DATA, arg)) {\r\ndev_kfree_skb((struct sk_buff *) arg);\r\n}\r\nbreak;\r\ncase (DL_ESTABLISH | REQUEST):\r\nif (test_bit(FLG_L1_ACTIV, &st->l2.flag)) {\r\nif (test_bit(FLG_LAPD, &st->l2.flag) ||\r\ntest_bit(FLG_ORIG, &st->l2.flag)) {\r\nFsmEvent(&st->l2.l2m, EV_L2_DL_ESTABLISH_REQ, arg);\r\n}\r\n} else {\r\nif (test_bit(FLG_LAPD, &st->l2.flag) ||\r\ntest_bit(FLG_ORIG, &st->l2.flag)) {\r\ntest_and_set_bit(FLG_ESTAB_PEND, &st->l2.flag);\r\n}\r\nst->l2.l2l1(st, PH_ACTIVATE, NULL);\r\n}\r\nbreak;\r\ncase (DL_RELEASE | REQUEST):\r\nif (test_bit(FLG_LAPB, &st->l2.flag)) {\r\nst->l2.l2l1(st, PH_DEACTIVATE, NULL);\r\n}\r\nFsmEvent(&st->l2.l2m, EV_L2_DL_RELEASE_REQ, arg);\r\nbreak;\r\ncase (MDL_ASSIGN | REQUEST):\r\nFsmEvent(&st->l2.l2m, EV_L2_MDL_ASSIGN, arg);\r\nbreak;\r\ncase (MDL_REMOVE | REQUEST):\r\nFsmEvent(&st->l2.l2m, EV_L2_MDL_REMOVE, arg);\r\nbreak;\r\ncase (MDL_ERROR | RESPONSE):\r\nFsmEvent(&st->l2.l2m, EV_L2_MDL_ERROR, arg);\r\nbreak;\r\n}\r\n}\r\nvoid\r\nreleasestack_isdnl2(struct PStack *st)\r\n{\r\nFsmDelTimer(&st->l2.t200, 21);\r\nFsmDelTimer(&st->l2.t203, 16);\r\nskb_queue_purge(&st->l2.i_queue);\r\nskb_queue_purge(&st->l2.ui_queue);\r\nReleaseWin(&st->l2);\r\n}\r\nstatic void\r\nl2m_debug(struct FsmInst *fi, char *fmt, ...)\r\n{\r\nva_list args;\r\nstruct PStack *st = fi->userdata;\r\nva_start(args, fmt);\r\nVHiSax_putstatus(st->l1.hardware, st->l2.debug_id, fmt, args);\r\nva_end(args);\r\n}\r\nvoid\r\nsetstack_isdnl2(struct PStack *st, char *debug_id)\r\n{\r\nspin_lock_init(&st->l2.lock);\r\nst->l1.l1l2 = isdnl2_l1l2;\r\nst->l3.l3l2 = isdnl2_l3l2;\r\nskb_queue_head_init(&st->l2.i_queue);\r\nskb_queue_head_init(&st->l2.ui_queue);\r\nInitWin(&st->l2);\r\nst->l2.debug = 0;\r\nst->l2.l2m.fsm = &l2fsm;\r\nif (test_bit(FLG_LAPB, &st->l2.flag))\r\nst->l2.l2m.state = ST_L2_4;\r\nelse\r\nst->l2.l2m.state = ST_L2_1;\r\nst->l2.l2m.debug = 0;\r\nst->l2.l2m.userdata = st;\r\nst->l2.l2m.userint = 0;\r\nst->l2.l2m.printdebug = l2m_debug;\r\nstrcpy(st->l2.debug_id, debug_id);\r\nFsmInitTimer(&st->l2.l2m, &st->l2.t200);\r\nFsmInitTimer(&st->l2.l2m, &st->l2.t203);\r\n}\r\nstatic void\r\ntransl2_l3l2(struct PStack *st, int pr, void *arg)\r\n{\r\nswitch (pr) {\r\ncase (DL_DATA | REQUEST):\r\ncase (DL_UNIT_DATA | REQUEST):\r\nst->l2.l2l1(st, PH_DATA | REQUEST, arg);\r\nbreak;\r\ncase (DL_ESTABLISH | REQUEST):\r\nst->l2.l2l1(st, PH_ACTIVATE | REQUEST, NULL);\r\nbreak;\r\ncase (DL_RELEASE | REQUEST):\r\nst->l2.l2l1(st, PH_DEACTIVATE | REQUEST, NULL);\r\nbreak;\r\n}\r\n}\r\nvoid\r\nsetstack_transl2(struct PStack *st)\r\n{\r\nst->l3.l3l2 = transl2_l3l2;\r\n}\r\nvoid\r\nreleasestack_transl2(struct PStack *st)\r\n{\r\n}\r\nint __init\r\nIsdnl2New(void)\r\n{\r\nl2fsm.state_count = L2_STATE_COUNT;\r\nl2fsm.event_count = L2_EVENT_COUNT;\r\nl2fsm.strEvent = strL2Event;\r\nl2fsm.strState = strL2State;\r\nreturn FsmNew(&l2fsm, L2FnList, ARRAY_SIZE(L2FnList));\r\n}\r\nvoid\r\nIsdnl2Free(void)\r\n{\r\nFsmFree(&l2fsm);\r\n}
