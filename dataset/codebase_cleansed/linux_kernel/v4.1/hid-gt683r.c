static void gt683r_brightness_set(struct led_classdev *led_cdev,\r\nenum led_brightness brightness)\r\n{\r\nint i;\r\nstruct device *dev = led_cdev->dev->parent;\r\nstruct hid_device *hdev = container_of(dev, struct hid_device, dev);\r\nstruct gt683r_led *led = hid_get_drvdata(hdev);\r\nfor (i = 0; i < GT683R_LED_COUNT; i++) {\r\nif (led_cdev == &led->led_devs[i])\r\nbreak;\r\n}\r\nif (i < GT683R_LED_COUNT) {\r\nled->brightnesses[i] = brightness;\r\nschedule_work(&led->work);\r\n}\r\n}\r\nstatic ssize_t mode_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nu8 sysfs_mode;\r\nstruct hid_device *hdev = container_of(dev->parent,\r\nstruct hid_device, dev);\r\nstruct gt683r_led *led = hid_get_drvdata(hdev);\r\nif (led->mode == GT683R_LED_NORMAL)\r\nsysfs_mode = 0;\r\nelse if (led->mode == GT683R_LED_AUDIO)\r\nsysfs_mode = 1;\r\nelse\r\nsysfs_mode = 2;\r\nreturn scnprintf(buf, PAGE_SIZE, "%u\n", sysfs_mode);\r\n}\r\nstatic ssize_t mode_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nu8 sysfs_mode;\r\nstruct hid_device *hdev = container_of(dev->parent,\r\nstruct hid_device, dev);\r\nstruct gt683r_led *led = hid_get_drvdata(hdev);\r\nif (kstrtou8(buf, 10, &sysfs_mode) || sysfs_mode > 2)\r\nreturn -EINVAL;\r\nmutex_lock(&led->lock);\r\nif (sysfs_mode == 0)\r\nled->mode = GT683R_LED_NORMAL;\r\nelse if (sysfs_mode == 1)\r\nled->mode = GT683R_LED_AUDIO;\r\nelse\r\nled->mode = GT683R_LED_BREATHING;\r\nmutex_unlock(&led->lock);\r\nschedule_work(&led->work);\r\nreturn count;\r\n}\r\nstatic int gt683r_led_snd_msg(struct gt683r_led *led, u8 *msg)\r\n{\r\nint ret;\r\nret = hid_hw_raw_request(led->hdev, msg[0], msg, GT683R_BUFFER_SIZE,\r\nHID_FEATURE_REPORT, HID_REQ_SET_REPORT);\r\nif (ret != GT683R_BUFFER_SIZE) {\r\nhid_err(led->hdev,\r\n"failed to send set report request: %i\n", ret);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic int gt683r_leds_set(struct gt683r_led *led, u8 leds)\r\n{\r\nint ret;\r\nu8 *buffer;\r\nbuffer = kzalloc(GT683R_BUFFER_SIZE, GFP_KERNEL);\r\nif (!buffer)\r\nreturn -ENOMEM;\r\nbuffer[0] = 0x01;\r\nbuffer[1] = 0x02;\r\nbuffer[2] = 0x30;\r\nbuffer[3] = leds;\r\nret = gt683r_led_snd_msg(led, buffer);\r\nkfree(buffer);\r\nreturn ret;\r\n}\r\nstatic int gt683r_mode_set(struct gt683r_led *led, u8 mode)\r\n{\r\nint ret;\r\nu8 *buffer;\r\nbuffer = kzalloc(GT683R_BUFFER_SIZE, GFP_KERNEL);\r\nif (!buffer)\r\nreturn -ENOMEM;\r\nbuffer[0] = 0x01;\r\nbuffer[1] = 0x02;\r\nbuffer[2] = 0x20;\r\nbuffer[3] = mode;\r\nbuffer[4] = 0x01;\r\nret = gt683r_led_snd_msg(led, buffer);\r\nkfree(buffer);\r\nreturn ret;\r\n}\r\nstatic void gt683r_led_work(struct work_struct *work)\r\n{\r\nint i;\r\nu8 leds = 0;\r\nu8 mode;\r\nstruct gt683r_led *led = container_of(work, struct gt683r_led, work);\r\nmutex_lock(&led->lock);\r\nfor (i = 0; i < GT683R_LED_COUNT; i++) {\r\nif (led->brightnesses[i])\r\nleds |= BIT(i);\r\n}\r\nif (gt683r_leds_set(led, leds))\r\ngoto fail;\r\nif (leds)\r\nmode = led->mode;\r\nelse\r\nmode = GT683R_LED_OFF;\r\ngt683r_mode_set(led, mode);\r\nfail:\r\nmutex_unlock(&led->lock);\r\n}\r\nstatic int gt683r_led_probe(struct hid_device *hdev,\r\nconst struct hid_device_id *id)\r\n{\r\nint i;\r\nint ret;\r\nint name_sz;\r\nchar *name;\r\nstruct gt683r_led *led;\r\nled = devm_kzalloc(&hdev->dev, sizeof(*led), GFP_KERNEL);\r\nif (!led)\r\nreturn -ENOMEM;\r\nmutex_init(&led->lock);\r\nINIT_WORK(&led->work, gt683r_led_work);\r\nled->mode = GT683R_LED_NORMAL;\r\nled->hdev = hdev;\r\nhid_set_drvdata(hdev, led);\r\nret = hid_parse(hdev);\r\nif (ret) {\r\nhid_err(hdev, "hid parsing failed\n");\r\nreturn ret;\r\n}\r\nret = hid_hw_start(hdev, HID_CONNECT_HIDRAW);\r\nif (ret) {\r\nhid_err(hdev, "hw start failed\n");\r\nreturn ret;\r\n}\r\nfor (i = 0; i < GT683R_LED_COUNT; i++) {\r\nname_sz = strlen(dev_name(&hdev->dev)) +\r\nstrlen(gt683r_panel_names[i]) + 3;\r\nname = devm_kzalloc(&hdev->dev, name_sz, GFP_KERNEL);\r\nif (!name) {\r\nret = -ENOMEM;\r\ngoto fail;\r\n}\r\nsnprintf(name, name_sz, "%s::%s",\r\ndev_name(&hdev->dev), gt683r_panel_names[i]);\r\nled->led_devs[i].name = name;\r\nled->led_devs[i].max_brightness = 1;\r\nled->led_devs[i].brightness_set = gt683r_brightness_set;\r\nled->led_devs[i].groups = gt683r_led_groups;\r\nret = led_classdev_register(&hdev->dev, &led->led_devs[i]);\r\nif (ret) {\r\nhid_err(hdev, "could not register led device\n");\r\ngoto fail;\r\n}\r\n}\r\nreturn 0;\r\nfail:\r\nfor (i = i - 1; i >= 0; i--)\r\nled_classdev_unregister(&led->led_devs[i]);\r\nhid_hw_stop(hdev);\r\nreturn ret;\r\n}\r\nstatic void gt683r_led_remove(struct hid_device *hdev)\r\n{\r\nint i;\r\nstruct gt683r_led *led = hid_get_drvdata(hdev);\r\nfor (i = 0; i < GT683R_LED_COUNT; i++)\r\nled_classdev_unregister(&led->led_devs[i]);\r\nflush_work(&led->work);\r\nhid_hw_stop(hdev);\r\n}
