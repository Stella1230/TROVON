int can_ioctl(struct socket *sock, unsigned int cmd, unsigned long arg)\r\n{\r\nstruct sock *sk = sock->sk;\r\nswitch (cmd) {\r\ncase SIOCGSTAMP:\r\nreturn sock_get_timestamp(sk, (struct timeval __user *)arg);\r\ndefault:\r\nreturn -ENOIOCTLCMD;\r\n}\r\n}\r\nstatic void can_sock_destruct(struct sock *sk)\r\n{\r\nskb_queue_purge(&sk->sk_receive_queue);\r\n}\r\nstatic const struct can_proto *can_get_proto(int protocol)\r\n{\r\nconst struct can_proto *cp;\r\nrcu_read_lock();\r\ncp = rcu_dereference(proto_tab[protocol]);\r\nif (cp && !try_module_get(cp->prot->owner))\r\ncp = NULL;\r\nrcu_read_unlock();\r\nreturn cp;\r\n}\r\nstatic inline void can_put_proto(const struct can_proto *cp)\r\n{\r\nmodule_put(cp->prot->owner);\r\n}\r\nstatic int can_create(struct net *net, struct socket *sock, int protocol,\r\nint kern)\r\n{\r\nstruct sock *sk;\r\nconst struct can_proto *cp;\r\nint err = 0;\r\nsock->state = SS_UNCONNECTED;\r\nif (protocol < 0 || protocol >= CAN_NPROTO)\r\nreturn -EINVAL;\r\nif (!net_eq(net, &init_net))\r\nreturn -EAFNOSUPPORT;\r\ncp = can_get_proto(protocol);\r\n#ifdef CONFIG_MODULES\r\nif (!cp) {\r\nerr = request_module("can-proto-%d", protocol);\r\nif (err)\r\nprintk_ratelimited(KERN_ERR "can: request_module "\r\n"(can-proto-%d) failed.\n", protocol);\r\ncp = can_get_proto(protocol);\r\n}\r\n#endif\r\nif (!cp)\r\nreturn -EPROTONOSUPPORT;\r\nif (cp->type != sock->type) {\r\nerr = -EPROTOTYPE;\r\ngoto errout;\r\n}\r\nsock->ops = cp->ops;\r\nsk = sk_alloc(net, PF_CAN, GFP_KERNEL, cp->prot);\r\nif (!sk) {\r\nerr = -ENOMEM;\r\ngoto errout;\r\n}\r\nsock_init_data(sock, sk);\r\nsk->sk_destruct = can_sock_destruct;\r\nif (sk->sk_prot->init)\r\nerr = sk->sk_prot->init(sk);\r\nif (err) {\r\nsock_orphan(sk);\r\nsock_put(sk);\r\n}\r\nerrout:\r\ncan_put_proto(cp);\r\nreturn err;\r\n}\r\nint can_send(struct sk_buff *skb, int loop)\r\n{\r\nstruct sk_buff *newskb = NULL;\r\nstruct canfd_frame *cfd = (struct canfd_frame *)skb->data;\r\nint err = -EINVAL;\r\nif (skb->len == CAN_MTU) {\r\nskb->protocol = htons(ETH_P_CAN);\r\nif (unlikely(cfd->len > CAN_MAX_DLEN))\r\ngoto inval_skb;\r\n} else if (skb->len == CANFD_MTU) {\r\nskb->protocol = htons(ETH_P_CANFD);\r\nif (unlikely(cfd->len > CANFD_MAX_DLEN))\r\ngoto inval_skb;\r\n} else\r\ngoto inval_skb;\r\nif (unlikely(skb->len > skb->dev->mtu && cfd->len > CAN_MAX_DLEN)) {\r\nerr = -EMSGSIZE;\r\ngoto inval_skb;\r\n}\r\nif (unlikely(skb->dev->type != ARPHRD_CAN)) {\r\nerr = -EPERM;\r\ngoto inval_skb;\r\n}\r\nif (unlikely(!(skb->dev->flags & IFF_UP))) {\r\nerr = -ENETDOWN;\r\ngoto inval_skb;\r\n}\r\nskb->ip_summed = CHECKSUM_UNNECESSARY;\r\nskb_reset_mac_header(skb);\r\nskb_reset_network_header(skb);\r\nskb_reset_transport_header(skb);\r\nif (loop) {\r\nskb->pkt_type = PACKET_LOOPBACK;\r\nif (!(skb->dev->flags & IFF_ECHO)) {\r\nnewskb = skb_clone(skb, GFP_ATOMIC);\r\nif (!newskb) {\r\nkfree_skb(skb);\r\nreturn -ENOMEM;\r\n}\r\ncan_skb_set_owner(newskb, skb->sk);\r\nnewskb->ip_summed = CHECKSUM_UNNECESSARY;\r\nnewskb->pkt_type = PACKET_BROADCAST;\r\n}\r\n} else {\r\nskb->pkt_type = PACKET_HOST;\r\n}\r\nerr = dev_queue_xmit(skb);\r\nif (err > 0)\r\nerr = net_xmit_errno(err);\r\nif (err) {\r\nkfree_skb(newskb);\r\nreturn err;\r\n}\r\nif (newskb)\r\nnetif_rx_ni(newskb);\r\ncan_stats.tx_frames++;\r\ncan_stats.tx_frames_delta++;\r\nreturn 0;\r\ninval_skb:\r\nkfree_skb(skb);\r\nreturn err;\r\n}\r\nstatic struct dev_rcv_lists *find_dev_rcv_lists(struct net_device *dev)\r\n{\r\nif (!dev)\r\nreturn &can_rx_alldev_list;\r\nelse\r\nreturn (struct dev_rcv_lists *)dev->ml_priv;\r\n}\r\nstatic unsigned int effhash(canid_t can_id)\r\n{\r\nunsigned int hash;\r\nhash = can_id;\r\nhash ^= can_id >> CAN_EFF_RCV_HASH_BITS;\r\nhash ^= can_id >> (2 * CAN_EFF_RCV_HASH_BITS);\r\nreturn hash & ((1 << CAN_EFF_RCV_HASH_BITS) - 1);\r\n}\r\nstatic struct hlist_head *find_rcv_list(canid_t *can_id, canid_t *mask,\r\nstruct dev_rcv_lists *d)\r\n{\r\ncanid_t inv = *can_id & CAN_INV_FILTER;\r\nif (*mask & CAN_ERR_FLAG) {\r\n*mask &= CAN_ERR_MASK;\r\nreturn &d->rx[RX_ERR];\r\n}\r\n#define CAN_EFF_RTR_FLAGS (CAN_EFF_FLAG | CAN_RTR_FLAG)\r\nif ((*mask & CAN_EFF_FLAG) && !(*can_id & CAN_EFF_FLAG))\r\n*mask &= (CAN_SFF_MASK | CAN_EFF_RTR_FLAGS);\r\n*can_id &= *mask;\r\nif (inv)\r\nreturn &d->rx[RX_INV];\r\nif (!(*mask))\r\nreturn &d->rx[RX_ALL];\r\nif (((*mask & CAN_EFF_RTR_FLAGS) == CAN_EFF_RTR_FLAGS) &&\r\n!(*can_id & CAN_RTR_FLAG)) {\r\nif (*can_id & CAN_EFF_FLAG) {\r\nif (*mask == (CAN_EFF_MASK | CAN_EFF_RTR_FLAGS))\r\nreturn &d->rx_eff[effhash(*can_id)];\r\n} else {\r\nif (*mask == (CAN_SFF_MASK | CAN_EFF_RTR_FLAGS))\r\nreturn &d->rx_sff[*can_id];\r\n}\r\n}\r\nreturn &d->rx[RX_FIL];\r\n}\r\nint can_rx_register(struct net_device *dev, canid_t can_id, canid_t mask,\r\nvoid (*func)(struct sk_buff *, void *), void *data,\r\nchar *ident)\r\n{\r\nstruct receiver *r;\r\nstruct hlist_head *rl;\r\nstruct dev_rcv_lists *d;\r\nint err = 0;\r\nif (dev && dev->type != ARPHRD_CAN)\r\nreturn -ENODEV;\r\nr = kmem_cache_alloc(rcv_cache, GFP_KERNEL);\r\nif (!r)\r\nreturn -ENOMEM;\r\nspin_lock(&can_rcvlists_lock);\r\nd = find_dev_rcv_lists(dev);\r\nif (d) {\r\nrl = find_rcv_list(&can_id, &mask, d);\r\nr->can_id = can_id;\r\nr->mask = mask;\r\nr->matches = 0;\r\nr->func = func;\r\nr->data = data;\r\nr->ident = ident;\r\nhlist_add_head_rcu(&r->list, rl);\r\nd->entries++;\r\ncan_pstats.rcv_entries++;\r\nif (can_pstats.rcv_entries_max < can_pstats.rcv_entries)\r\ncan_pstats.rcv_entries_max = can_pstats.rcv_entries;\r\n} else {\r\nkmem_cache_free(rcv_cache, r);\r\nerr = -ENODEV;\r\n}\r\nspin_unlock(&can_rcvlists_lock);\r\nreturn err;\r\n}\r\nstatic void can_rx_delete_receiver(struct rcu_head *rp)\r\n{\r\nstruct receiver *r = container_of(rp, struct receiver, rcu);\r\nkmem_cache_free(rcv_cache, r);\r\n}\r\nvoid can_rx_unregister(struct net_device *dev, canid_t can_id, canid_t mask,\r\nvoid (*func)(struct sk_buff *, void *), void *data)\r\n{\r\nstruct receiver *r = NULL;\r\nstruct hlist_head *rl;\r\nstruct dev_rcv_lists *d;\r\nif (dev && dev->type != ARPHRD_CAN)\r\nreturn;\r\nspin_lock(&can_rcvlists_lock);\r\nd = find_dev_rcv_lists(dev);\r\nif (!d) {\r\npr_err("BUG: receive list not found for "\r\n"dev %s, id %03X, mask %03X\n",\r\nDNAME(dev), can_id, mask);\r\ngoto out;\r\n}\r\nrl = find_rcv_list(&can_id, &mask, d);\r\nhlist_for_each_entry_rcu(r, rl, list) {\r\nif (r->can_id == can_id && r->mask == mask &&\r\nr->func == func && r->data == data)\r\nbreak;\r\n}\r\nif (!r) {\r\nWARN(1, "BUG: receive list entry not found for dev %s, "\r\n"id %03X, mask %03X\n", DNAME(dev), can_id, mask);\r\ngoto out;\r\n}\r\nhlist_del_rcu(&r->list);\r\nd->entries--;\r\nif (can_pstats.rcv_entries > 0)\r\ncan_pstats.rcv_entries--;\r\nif (d->remove_on_zero_entries && !d->entries) {\r\nkfree(d);\r\ndev->ml_priv = NULL;\r\n}\r\nout:\r\nspin_unlock(&can_rcvlists_lock);\r\nif (r)\r\ncall_rcu(&r->rcu, can_rx_delete_receiver);\r\n}\r\nstatic inline void deliver(struct sk_buff *skb, struct receiver *r)\r\n{\r\nr->func(skb, r->data);\r\nr->matches++;\r\n}\r\nstatic int can_rcv_filter(struct dev_rcv_lists *d, struct sk_buff *skb)\r\n{\r\nstruct receiver *r;\r\nint matches = 0;\r\nstruct can_frame *cf = (struct can_frame *)skb->data;\r\ncanid_t can_id = cf->can_id;\r\nif (d->entries == 0)\r\nreturn 0;\r\nif (can_id & CAN_ERR_FLAG) {\r\nhlist_for_each_entry_rcu(r, &d->rx[RX_ERR], list) {\r\nif (can_id & r->mask) {\r\ndeliver(skb, r);\r\nmatches++;\r\n}\r\n}\r\nreturn matches;\r\n}\r\nhlist_for_each_entry_rcu(r, &d->rx[RX_ALL], list) {\r\ndeliver(skb, r);\r\nmatches++;\r\n}\r\nhlist_for_each_entry_rcu(r, &d->rx[RX_FIL], list) {\r\nif ((can_id & r->mask) == r->can_id) {\r\ndeliver(skb, r);\r\nmatches++;\r\n}\r\n}\r\nhlist_for_each_entry_rcu(r, &d->rx[RX_INV], list) {\r\nif ((can_id & r->mask) != r->can_id) {\r\ndeliver(skb, r);\r\nmatches++;\r\n}\r\n}\r\nif (can_id & CAN_RTR_FLAG)\r\nreturn matches;\r\nif (can_id & CAN_EFF_FLAG) {\r\nhlist_for_each_entry_rcu(r, &d->rx_eff[effhash(can_id)], list) {\r\nif (r->can_id == can_id) {\r\ndeliver(skb, r);\r\nmatches++;\r\n}\r\n}\r\n} else {\r\ncan_id &= CAN_SFF_MASK;\r\nhlist_for_each_entry_rcu(r, &d->rx_sff[can_id], list) {\r\ndeliver(skb, r);\r\nmatches++;\r\n}\r\n}\r\nreturn matches;\r\n}\r\nstatic void can_receive(struct sk_buff *skb, struct net_device *dev)\r\n{\r\nstruct dev_rcv_lists *d;\r\nint matches;\r\ncan_stats.rx_frames++;\r\ncan_stats.rx_frames_delta++;\r\nrcu_read_lock();\r\nmatches = can_rcv_filter(&can_rx_alldev_list, skb);\r\nd = find_dev_rcv_lists(dev);\r\nif (d)\r\nmatches += can_rcv_filter(d, skb);\r\nrcu_read_unlock();\r\nconsume_skb(skb);\r\nif (matches > 0) {\r\ncan_stats.matches++;\r\ncan_stats.matches_delta++;\r\n}\r\n}\r\nstatic int can_rcv(struct sk_buff *skb, struct net_device *dev,\r\nstruct packet_type *pt, struct net_device *orig_dev)\r\n{\r\nstruct canfd_frame *cfd = (struct canfd_frame *)skb->data;\r\nif (unlikely(!net_eq(dev_net(dev), &init_net)))\r\ngoto drop;\r\nif (WARN_ONCE(dev->type != ARPHRD_CAN ||\r\nskb->len != CAN_MTU ||\r\ncfd->len > CAN_MAX_DLEN,\r\n"PF_CAN: dropped non conform CAN skbuf: "\r\n"dev type %d, len %d, datalen %d\n",\r\ndev->type, skb->len, cfd->len))\r\ngoto drop;\r\ncan_receive(skb, dev);\r\nreturn NET_RX_SUCCESS;\r\ndrop:\r\nkfree_skb(skb);\r\nreturn NET_RX_DROP;\r\n}\r\nstatic int canfd_rcv(struct sk_buff *skb, struct net_device *dev,\r\nstruct packet_type *pt, struct net_device *orig_dev)\r\n{\r\nstruct canfd_frame *cfd = (struct canfd_frame *)skb->data;\r\nif (unlikely(!net_eq(dev_net(dev), &init_net)))\r\ngoto drop;\r\nif (WARN_ONCE(dev->type != ARPHRD_CAN ||\r\nskb->len != CANFD_MTU ||\r\ncfd->len > CANFD_MAX_DLEN,\r\n"PF_CAN: dropped non conform CAN FD skbuf: "\r\n"dev type %d, len %d, datalen %d\n",\r\ndev->type, skb->len, cfd->len))\r\ngoto drop;\r\ncan_receive(skb, dev);\r\nreturn NET_RX_SUCCESS;\r\ndrop:\r\nkfree_skb(skb);\r\nreturn NET_RX_DROP;\r\n}\r\nint can_proto_register(const struct can_proto *cp)\r\n{\r\nint proto = cp->protocol;\r\nint err = 0;\r\nif (proto < 0 || proto >= CAN_NPROTO) {\r\npr_err("can: protocol number %d out of range\n", proto);\r\nreturn -EINVAL;\r\n}\r\nerr = proto_register(cp->prot, 0);\r\nif (err < 0)\r\nreturn err;\r\nmutex_lock(&proto_tab_lock);\r\nif (proto_tab[proto]) {\r\npr_err("can: protocol %d already registered\n", proto);\r\nerr = -EBUSY;\r\n} else\r\nRCU_INIT_POINTER(proto_tab[proto], cp);\r\nmutex_unlock(&proto_tab_lock);\r\nif (err < 0)\r\nproto_unregister(cp->prot);\r\nreturn err;\r\n}\r\nvoid can_proto_unregister(const struct can_proto *cp)\r\n{\r\nint proto = cp->protocol;\r\nmutex_lock(&proto_tab_lock);\r\nBUG_ON(proto_tab[proto] != cp);\r\nRCU_INIT_POINTER(proto_tab[proto], NULL);\r\nmutex_unlock(&proto_tab_lock);\r\nsynchronize_rcu();\r\nproto_unregister(cp->prot);\r\n}\r\nstatic int can_notifier(struct notifier_block *nb, unsigned long msg,\r\nvoid *ptr)\r\n{\r\nstruct net_device *dev = netdev_notifier_info_to_dev(ptr);\r\nstruct dev_rcv_lists *d;\r\nif (!net_eq(dev_net(dev), &init_net))\r\nreturn NOTIFY_DONE;\r\nif (dev->type != ARPHRD_CAN)\r\nreturn NOTIFY_DONE;\r\nswitch (msg) {\r\ncase NETDEV_REGISTER:\r\nd = kzalloc(sizeof(*d), GFP_KERNEL);\r\nif (!d)\r\nreturn NOTIFY_DONE;\r\nBUG_ON(dev->ml_priv);\r\ndev->ml_priv = d;\r\nbreak;\r\ncase NETDEV_UNREGISTER:\r\nspin_lock(&can_rcvlists_lock);\r\nd = dev->ml_priv;\r\nif (d) {\r\nif (d->entries)\r\nd->remove_on_zero_entries = 1;\r\nelse {\r\nkfree(d);\r\ndev->ml_priv = NULL;\r\n}\r\n} else\r\npr_err("can: notifier: receive list not found for dev "\r\n"%s\n", dev->name);\r\nspin_unlock(&can_rcvlists_lock);\r\nbreak;\r\n}\r\nreturn NOTIFY_DONE;\r\n}\r\nstatic __init int can_init(void)\r\n{\r\nBUILD_BUG_ON(offsetof(struct can_frame, can_dlc) !=\r\noffsetof(struct canfd_frame, len) ||\r\noffsetof(struct can_frame, data) !=\r\noffsetof(struct canfd_frame, data));\r\npr_info("can: controller area network core (" CAN_VERSION_STRING ")\n");\r\nmemset(&can_rx_alldev_list, 0, sizeof(can_rx_alldev_list));\r\nrcv_cache = kmem_cache_create("can_receiver", sizeof(struct receiver),\r\n0, 0, NULL);\r\nif (!rcv_cache)\r\nreturn -ENOMEM;\r\nif (stats_timer) {\r\nsetup_timer(&can_stattimer, can_stat_update, 0);\r\nmod_timer(&can_stattimer, round_jiffies(jiffies + HZ));\r\n} else\r\ncan_stattimer.function = NULL;\r\ncan_init_proc();\r\nsock_register(&can_family_ops);\r\nregister_netdevice_notifier(&can_netdev_notifier);\r\ndev_add_pack(&can_packet);\r\ndev_add_pack(&canfd_packet);\r\nreturn 0;\r\n}\r\nstatic __exit void can_exit(void)\r\n{\r\nstruct net_device *dev;\r\nif (stats_timer)\r\ndel_timer_sync(&can_stattimer);\r\ncan_remove_proc();\r\ndev_remove_pack(&canfd_packet);\r\ndev_remove_pack(&can_packet);\r\nunregister_netdevice_notifier(&can_netdev_notifier);\r\nsock_unregister(PF_CAN);\r\nrcu_read_lock();\r\nfor_each_netdev_rcu(&init_net, dev) {\r\nif (dev->type == ARPHRD_CAN && dev->ml_priv) {\r\nstruct dev_rcv_lists *d = dev->ml_priv;\r\nBUG_ON(d->entries);\r\nkfree(d);\r\ndev->ml_priv = NULL;\r\n}\r\n}\r\nrcu_read_unlock();\r\nrcu_barrier();\r\nkmem_cache_destroy(rcv_cache);\r\n}
