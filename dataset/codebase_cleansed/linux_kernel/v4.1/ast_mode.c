static inline void ast_load_palette_index(struct ast_private *ast,\r\nu8 index, u8 red, u8 green,\r\nu8 blue)\r\n{\r\nast_io_write8(ast, AST_IO_DAC_INDEX_WRITE, index);\r\nast_io_read8(ast, AST_IO_SEQ_PORT);\r\nast_io_write8(ast, AST_IO_DAC_DATA, red);\r\nast_io_read8(ast, AST_IO_SEQ_PORT);\r\nast_io_write8(ast, AST_IO_DAC_DATA, green);\r\nast_io_read8(ast, AST_IO_SEQ_PORT);\r\nast_io_write8(ast, AST_IO_DAC_DATA, blue);\r\nast_io_read8(ast, AST_IO_SEQ_PORT);\r\n}\r\nstatic void ast_crtc_load_lut(struct drm_crtc *crtc)\r\n{\r\nstruct ast_private *ast = crtc->dev->dev_private;\r\nstruct ast_crtc *ast_crtc = to_ast_crtc(crtc);\r\nint i;\r\nif (!crtc->enabled)\r\nreturn;\r\nfor (i = 0; i < 256; i++)\r\nast_load_palette_index(ast, i, ast_crtc->lut_r[i],\r\nast_crtc->lut_g[i], ast_crtc->lut_b[i]);\r\n}\r\nstatic bool ast_get_vbios_mode_info(struct drm_crtc *crtc, struct drm_display_mode *mode,\r\nstruct drm_display_mode *adjusted_mode,\r\nstruct ast_vbios_mode_info *vbios_mode)\r\n{\r\nstruct ast_private *ast = crtc->dev->dev_private;\r\nu32 refresh_rate_index = 0, mode_id, color_index, refresh_rate;\r\nu32 hborder, vborder;\r\nbool check_sync;\r\nstruct ast_vbios_enhtable *best = NULL;\r\nswitch (crtc->primary->fb->bits_per_pixel) {\r\ncase 8:\r\nvbios_mode->std_table = &vbios_stdtable[VGAModeIndex];\r\ncolor_index = VGAModeIndex - 1;\r\nbreak;\r\ncase 16:\r\nvbios_mode->std_table = &vbios_stdtable[HiCModeIndex];\r\ncolor_index = HiCModeIndex;\r\nbreak;\r\ncase 24:\r\ncase 32:\r\nvbios_mode->std_table = &vbios_stdtable[TrueCModeIndex];\r\ncolor_index = TrueCModeIndex;\r\nbreak;\r\ndefault:\r\nreturn false;\r\n}\r\nswitch (crtc->mode.crtc_hdisplay) {\r\ncase 640:\r\nvbios_mode->enh_table = &res_640x480[refresh_rate_index];\r\nbreak;\r\ncase 800:\r\nvbios_mode->enh_table = &res_800x600[refresh_rate_index];\r\nbreak;\r\ncase 1024:\r\nvbios_mode->enh_table = &res_1024x768[refresh_rate_index];\r\nbreak;\r\ncase 1280:\r\nif (crtc->mode.crtc_vdisplay == 800)\r\nvbios_mode->enh_table = &res_1280x800[refresh_rate_index];\r\nelse\r\nvbios_mode->enh_table = &res_1280x1024[refresh_rate_index];\r\nbreak;\r\ncase 1360:\r\nvbios_mode->enh_table = &res_1360x768[refresh_rate_index];\r\nbreak;\r\ncase 1440:\r\nvbios_mode->enh_table = &res_1440x900[refresh_rate_index];\r\nbreak;\r\ncase 1600:\r\nif (crtc->mode.crtc_vdisplay == 900)\r\nvbios_mode->enh_table = &res_1600x900[refresh_rate_index];\r\nelse\r\nvbios_mode->enh_table = &res_1600x1200[refresh_rate_index];\r\nbreak;\r\ncase 1680:\r\nvbios_mode->enh_table = &res_1680x1050[refresh_rate_index];\r\nbreak;\r\ncase 1920:\r\nif (crtc->mode.crtc_vdisplay == 1080)\r\nvbios_mode->enh_table = &res_1920x1080[refresh_rate_index];\r\nelse\r\nvbios_mode->enh_table = &res_1920x1200[refresh_rate_index];\r\nbreak;\r\ndefault:\r\nreturn false;\r\n}\r\nrefresh_rate = drm_mode_vrefresh(mode);\r\ncheck_sync = vbios_mode->enh_table->flags & WideScreenMode;\r\ndo {\r\nstruct ast_vbios_enhtable *loop = vbios_mode->enh_table;\r\nwhile (loop->refresh_rate != 0xff) {\r\nif ((check_sync) &&\r\n(((mode->flags & DRM_MODE_FLAG_NVSYNC) &&\r\n(loop->flags & PVSync)) ||\r\n((mode->flags & DRM_MODE_FLAG_PVSYNC) &&\r\n(loop->flags & NVSync)) ||\r\n((mode->flags & DRM_MODE_FLAG_NHSYNC) &&\r\n(loop->flags & PHSync)) ||\r\n((mode->flags & DRM_MODE_FLAG_PHSYNC) &&\r\n(loop->flags & NHSync)))) {\r\nloop++;\r\ncontinue;\r\n}\r\nif (loop->refresh_rate <= refresh_rate\r\n&& (!best || loop->refresh_rate > best->refresh_rate))\r\nbest = loop;\r\nloop++;\r\n}\r\nif (best || !check_sync)\r\nbreak;\r\ncheck_sync = 0;\r\n} while (1);\r\nif (best)\r\nvbios_mode->enh_table = best;\r\nhborder = (vbios_mode->enh_table->flags & HBorder) ? 8 : 0;\r\nvborder = (vbios_mode->enh_table->flags & VBorder) ? 8 : 0;\r\nadjusted_mode->crtc_htotal = vbios_mode->enh_table->ht;\r\nadjusted_mode->crtc_hblank_start = vbios_mode->enh_table->hde + hborder;\r\nadjusted_mode->crtc_hblank_end = vbios_mode->enh_table->ht - hborder;\r\nadjusted_mode->crtc_hsync_start = vbios_mode->enh_table->hde + hborder +\r\nvbios_mode->enh_table->hfp;\r\nadjusted_mode->crtc_hsync_end = (vbios_mode->enh_table->hde + hborder +\r\nvbios_mode->enh_table->hfp +\r\nvbios_mode->enh_table->hsync);\r\nadjusted_mode->crtc_vtotal = vbios_mode->enh_table->vt;\r\nadjusted_mode->crtc_vblank_start = vbios_mode->enh_table->vde + vborder;\r\nadjusted_mode->crtc_vblank_end = vbios_mode->enh_table->vt - vborder;\r\nadjusted_mode->crtc_vsync_start = vbios_mode->enh_table->vde + vborder +\r\nvbios_mode->enh_table->vfp;\r\nadjusted_mode->crtc_vsync_end = (vbios_mode->enh_table->vde + vborder +\r\nvbios_mode->enh_table->vfp +\r\nvbios_mode->enh_table->vsync);\r\nrefresh_rate_index = vbios_mode->enh_table->refresh_rate_index;\r\nmode_id = vbios_mode->enh_table->mode_id;\r\nif (ast->chip == AST1180) {\r\n} else {\r\nast_set_index_reg(ast, AST_IO_CRTC_PORT, 0x8c, (u8)((color_index & 0xf) << 4));\r\nast_set_index_reg(ast, AST_IO_CRTC_PORT, 0x8d, refresh_rate_index & 0xff);\r\nast_set_index_reg(ast, AST_IO_CRTC_PORT, 0x8e, mode_id & 0xff);\r\nast_set_index_reg(ast, AST_IO_CRTC_PORT, 0x91, 0x00);\r\nif (vbios_mode->enh_table->flags & NewModeInfo) {\r\nast_set_index_reg(ast, AST_IO_CRTC_PORT, 0x91, 0xa8);\r\nast_set_index_reg(ast, AST_IO_CRTC_PORT, 0x92, crtc->primary->fb->bits_per_pixel);\r\nast_set_index_reg(ast, AST_IO_CRTC_PORT, 0x93, adjusted_mode->clock / 1000);\r\nast_set_index_reg(ast, AST_IO_CRTC_PORT, 0x94, adjusted_mode->crtc_hdisplay);\r\nast_set_index_reg(ast, AST_IO_CRTC_PORT, 0x95, adjusted_mode->crtc_hdisplay >> 8);\r\nast_set_index_reg(ast, AST_IO_CRTC_PORT, 0x96, adjusted_mode->crtc_vdisplay);\r\nast_set_index_reg(ast, AST_IO_CRTC_PORT, 0x97, adjusted_mode->crtc_vdisplay >> 8);\r\n}\r\n}\r\nreturn true;\r\n}\r\nstatic void ast_set_std_reg(struct drm_crtc *crtc, struct drm_display_mode *mode,\r\nstruct ast_vbios_mode_info *vbios_mode)\r\n{\r\nstruct ast_private *ast = crtc->dev->dev_private;\r\nstruct ast_vbios_stdtable *stdtable;\r\nu32 i;\r\nu8 jreg;\r\nstdtable = vbios_mode->std_table;\r\njreg = stdtable->misc;\r\nast_io_write8(ast, AST_IO_MISC_PORT_WRITE, jreg);\r\nast_set_index_reg(ast, AST_IO_SEQ_PORT, 0x00, 0x03);\r\nfor (i = 0; i < 4; i++) {\r\njreg = stdtable->seq[i];\r\nif (!i)\r\njreg |= 0x20;\r\nast_set_index_reg(ast, AST_IO_SEQ_PORT, (i + 1) , jreg);\r\n}\r\nast_set_index_reg_mask(ast, AST_IO_CRTC_PORT, 0x11, 0x7f, 0x00);\r\nfor (i = 0; i < 25; i++)\r\nast_set_index_reg(ast, AST_IO_CRTC_PORT, i, stdtable->crtc[i]);\r\njreg = ast_io_read8(ast, AST_IO_INPUT_STATUS1_READ);\r\nfor (i = 0; i < 20; i++) {\r\njreg = stdtable->ar[i];\r\nast_io_write8(ast, AST_IO_AR_PORT_WRITE, (u8)i);\r\nast_io_write8(ast, AST_IO_AR_PORT_WRITE, jreg);\r\n}\r\nast_io_write8(ast, AST_IO_AR_PORT_WRITE, 0x14);\r\nast_io_write8(ast, AST_IO_AR_PORT_WRITE, 0x00);\r\njreg = ast_io_read8(ast, AST_IO_INPUT_STATUS1_READ);\r\nast_io_write8(ast, AST_IO_AR_PORT_WRITE, 0x20);\r\nfor (i = 0; i < 9; i++)\r\nast_set_index_reg(ast, AST_IO_GR_PORT, i, stdtable->gr[i]);\r\n}\r\nstatic void ast_set_crtc_reg(struct drm_crtc *crtc, struct drm_display_mode *mode,\r\nstruct ast_vbios_mode_info *vbios_mode)\r\n{\r\nstruct ast_private *ast = crtc->dev->dev_private;\r\nu8 jreg05 = 0, jreg07 = 0, jreg09 = 0, jregAC = 0, jregAD = 0, jregAE = 0;\r\nu16 temp;\r\nast_set_index_reg_mask(ast, AST_IO_CRTC_PORT, 0x11, 0x7f, 0x00);\r\ntemp = (mode->crtc_htotal >> 3) - 5;\r\nif (temp & 0x100)\r\njregAC |= 0x01;\r\nast_set_index_reg_mask(ast, AST_IO_CRTC_PORT, 0x00, 0x00, temp);\r\ntemp = (mode->crtc_hdisplay >> 3) - 1;\r\nif (temp & 0x100)\r\njregAC |= 0x04;\r\nast_set_index_reg_mask(ast, AST_IO_CRTC_PORT, 0x01, 0x00, temp);\r\ntemp = (mode->crtc_hblank_start >> 3) - 1;\r\nif (temp & 0x100)\r\njregAC |= 0x10;\r\nast_set_index_reg_mask(ast, AST_IO_CRTC_PORT, 0x02, 0x00, temp);\r\ntemp = ((mode->crtc_hblank_end >> 3) - 1) & 0x7f;\r\nif (temp & 0x20)\r\njreg05 |= 0x80;\r\nif (temp & 0x40)\r\njregAD |= 0x01;\r\nast_set_index_reg_mask(ast, AST_IO_CRTC_PORT, 0x03, 0xE0, (temp & 0x1f));\r\ntemp = (mode->crtc_hsync_start >> 3) - 1;\r\nif (temp & 0x100)\r\njregAC |= 0x40;\r\nast_set_index_reg_mask(ast, AST_IO_CRTC_PORT, 0x04, 0x00, temp);\r\ntemp = ((mode->crtc_hsync_end >> 3) - 1) & 0x3f;\r\nif (temp & 0x20)\r\njregAD |= 0x04;\r\nast_set_index_reg_mask(ast, AST_IO_CRTC_PORT, 0x05, 0x60, (u8)((temp & 0x1f) | jreg05));\r\nast_set_index_reg_mask(ast, AST_IO_CRTC_PORT, 0xAC, 0x00, jregAC);\r\nast_set_index_reg_mask(ast, AST_IO_CRTC_PORT, 0xAD, 0x00, jregAD);\r\ntemp = (mode->crtc_vtotal) - 2;\r\nif (temp & 0x100)\r\njreg07 |= 0x01;\r\nif (temp & 0x200)\r\njreg07 |= 0x20;\r\nif (temp & 0x400)\r\njregAE |= 0x01;\r\nast_set_index_reg_mask(ast, AST_IO_CRTC_PORT, 0x06, 0x00, temp);\r\ntemp = (mode->crtc_vsync_start) - 1;\r\nif (temp & 0x100)\r\njreg07 |= 0x04;\r\nif (temp & 0x200)\r\njreg07 |= 0x80;\r\nif (temp & 0x400)\r\njregAE |= 0x08;\r\nast_set_index_reg_mask(ast, AST_IO_CRTC_PORT, 0x10, 0x00, temp);\r\ntemp = (mode->crtc_vsync_end - 1) & 0x3f;\r\nif (temp & 0x10)\r\njregAE |= 0x20;\r\nif (temp & 0x20)\r\njregAE |= 0x40;\r\nast_set_index_reg_mask(ast, AST_IO_CRTC_PORT, 0x11, 0x70, temp & 0xf);\r\ntemp = mode->crtc_vdisplay - 1;\r\nif (temp & 0x100)\r\njreg07 |= 0x02;\r\nif (temp & 0x200)\r\njreg07 |= 0x40;\r\nif (temp & 0x400)\r\njregAE |= 0x02;\r\nast_set_index_reg_mask(ast, AST_IO_CRTC_PORT, 0x12, 0x00, temp);\r\ntemp = mode->crtc_vblank_start - 1;\r\nif (temp & 0x100)\r\njreg07 |= 0x08;\r\nif (temp & 0x200)\r\njreg09 |= 0x20;\r\nif (temp & 0x400)\r\njregAE |= 0x04;\r\nast_set_index_reg_mask(ast, AST_IO_CRTC_PORT, 0x15, 0x00, temp);\r\ntemp = mode->crtc_vblank_end - 1;\r\nif (temp & 0x100)\r\njregAE |= 0x10;\r\nast_set_index_reg_mask(ast, AST_IO_CRTC_PORT, 0x16, 0x00, temp);\r\nast_set_index_reg_mask(ast, AST_IO_CRTC_PORT, 0x07, 0x00, jreg07);\r\nast_set_index_reg_mask(ast, AST_IO_CRTC_PORT, 0x09, 0xdf, jreg09);\r\nast_set_index_reg_mask(ast, AST_IO_CRTC_PORT, 0xAE, 0x00, (jregAE | 0x80));\r\nast_set_index_reg_mask(ast, AST_IO_CRTC_PORT, 0x11, 0x7f, 0x80);\r\n}\r\nstatic void ast_set_offset_reg(struct drm_crtc *crtc)\r\n{\r\nstruct ast_private *ast = crtc->dev->dev_private;\r\nu16 offset;\r\noffset = crtc->primary->fb->pitches[0] >> 3;\r\nast_set_index_reg(ast, AST_IO_CRTC_PORT, 0x13, (offset & 0xff));\r\nast_set_index_reg(ast, AST_IO_CRTC_PORT, 0xb0, (offset >> 8) & 0x3f);\r\n}\r\nstatic void ast_set_dclk_reg(struct drm_device *dev, struct drm_display_mode *mode,\r\nstruct ast_vbios_mode_info *vbios_mode)\r\n{\r\nstruct ast_private *ast = dev->dev_private;\r\nstruct ast_vbios_dclk_info *clk_info;\r\nclk_info = &dclk_table[vbios_mode->enh_table->dclk_index];\r\nast_set_index_reg_mask(ast, AST_IO_CRTC_PORT, 0xc0, 0x00, clk_info->param1);\r\nast_set_index_reg_mask(ast, AST_IO_CRTC_PORT, 0xc1, 0x00, clk_info->param2);\r\nast_set_index_reg_mask(ast, AST_IO_CRTC_PORT, 0xbb, 0x0f,\r\n(clk_info->param3 & 0x80) | ((clk_info->param3 & 0x3) << 4));\r\n}\r\nstatic void ast_set_ext_reg(struct drm_crtc *crtc, struct drm_display_mode *mode,\r\nstruct ast_vbios_mode_info *vbios_mode)\r\n{\r\nstruct ast_private *ast = crtc->dev->dev_private;\r\nu8 jregA0 = 0, jregA3 = 0, jregA8 = 0;\r\nswitch (crtc->primary->fb->bits_per_pixel) {\r\ncase 8:\r\njregA0 = 0x70;\r\njregA3 = 0x01;\r\njregA8 = 0x00;\r\nbreak;\r\ncase 15:\r\ncase 16:\r\njregA0 = 0x70;\r\njregA3 = 0x04;\r\njregA8 = 0x02;\r\nbreak;\r\ncase 32:\r\njregA0 = 0x70;\r\njregA3 = 0x08;\r\njregA8 = 0x02;\r\nbreak;\r\n}\r\nast_set_index_reg_mask(ast, AST_IO_CRTC_PORT, 0xa0, 0x8f, jregA0);\r\nast_set_index_reg_mask(ast, AST_IO_CRTC_PORT, 0xa3, 0xf0, jregA3);\r\nast_set_index_reg_mask(ast, AST_IO_CRTC_PORT, 0xa8, 0xfd, jregA8);\r\nif (ast->chip == AST2300 || ast->chip == AST2400) {\r\nast_set_index_reg(ast, AST_IO_CRTC_PORT, 0xa7, 0x78);\r\nast_set_index_reg(ast, AST_IO_CRTC_PORT, 0xa6, 0x60);\r\n} else if (ast->chip == AST2100 ||\r\nast->chip == AST1100 ||\r\nast->chip == AST2200 ||\r\nast->chip == AST2150) {\r\nast_set_index_reg(ast, AST_IO_CRTC_PORT, 0xa7, 0x3f);\r\nast_set_index_reg(ast, AST_IO_CRTC_PORT, 0xa6, 0x2f);\r\n} else {\r\nast_set_index_reg(ast, AST_IO_CRTC_PORT, 0xa7, 0x2f);\r\nast_set_index_reg(ast, AST_IO_CRTC_PORT, 0xa6, 0x1f);\r\n}\r\n}\r\nstatic void ast_set_sync_reg(struct drm_device *dev, struct drm_display_mode *mode,\r\nstruct ast_vbios_mode_info *vbios_mode)\r\n{\r\nstruct ast_private *ast = dev->dev_private;\r\nu8 jreg;\r\njreg = ast_io_read8(ast, AST_IO_MISC_PORT_READ);\r\njreg &= ~0xC0;\r\nif (vbios_mode->enh_table->flags & NVSync) jreg |= 0x80;\r\nif (vbios_mode->enh_table->flags & NHSync) jreg |= 0x40;\r\nast_io_write8(ast, AST_IO_MISC_PORT_WRITE, jreg);\r\n}\r\nstatic bool ast_set_dac_reg(struct drm_crtc *crtc, struct drm_display_mode *mode,\r\nstruct ast_vbios_mode_info *vbios_mode)\r\n{\r\nswitch (crtc->primary->fb->bits_per_pixel) {\r\ncase 8:\r\nbreak;\r\ndefault:\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\nstatic void ast_set_start_address_crt1(struct drm_crtc *crtc, unsigned offset)\r\n{\r\nstruct ast_private *ast = crtc->dev->dev_private;\r\nu32 addr;\r\naddr = offset >> 2;\r\nast_set_index_reg(ast, AST_IO_CRTC_PORT, 0x0d, (u8)(addr & 0xff));\r\nast_set_index_reg(ast, AST_IO_CRTC_PORT, 0x0c, (u8)((addr >> 8) & 0xff));\r\nast_set_index_reg(ast, AST_IO_CRTC_PORT, 0xaf, (u8)((addr >> 16) & 0xff));\r\n}\r\nstatic void ast_crtc_dpms(struct drm_crtc *crtc, int mode)\r\n{\r\nstruct ast_private *ast = crtc->dev->dev_private;\r\nif (ast->chip == AST1180)\r\nreturn;\r\nswitch (mode) {\r\ncase DRM_MODE_DPMS_ON:\r\ncase DRM_MODE_DPMS_STANDBY:\r\ncase DRM_MODE_DPMS_SUSPEND:\r\nast_set_index_reg_mask(ast, AST_IO_SEQ_PORT, 0x1, 0xdf, 0);\r\nif (ast->tx_chip_type == AST_TX_DP501)\r\nast_set_dp501_video_output(crtc->dev, 1);\r\nast_crtc_load_lut(crtc);\r\nbreak;\r\ncase DRM_MODE_DPMS_OFF:\r\nif (ast->tx_chip_type == AST_TX_DP501)\r\nast_set_dp501_video_output(crtc->dev, 0);\r\nast_set_index_reg_mask(ast, AST_IO_SEQ_PORT, 0x1, 0xdf, 0x20);\r\nbreak;\r\n}\r\n}\r\nstatic bool ast_crtc_mode_fixup(struct drm_crtc *crtc,\r\nconst struct drm_display_mode *mode,\r\nstruct drm_display_mode *adjusted_mode)\r\n{\r\nreturn true;\r\n}\r\nstatic int ast_crtc_do_set_base(struct drm_crtc *crtc,\r\nstruct drm_framebuffer *fb,\r\nint x, int y, int atomic)\r\n{\r\nstruct ast_private *ast = crtc->dev->dev_private;\r\nstruct drm_gem_object *obj;\r\nstruct ast_framebuffer *ast_fb;\r\nstruct ast_bo *bo;\r\nint ret;\r\nu64 gpu_addr;\r\nif (!atomic && fb) {\r\nast_fb = to_ast_framebuffer(fb);\r\nobj = ast_fb->obj;\r\nbo = gem_to_ast_bo(obj);\r\nret = ast_bo_reserve(bo, false);\r\nif (ret)\r\nreturn ret;\r\nast_bo_push_sysram(bo);\r\nast_bo_unreserve(bo);\r\n}\r\nast_fb = to_ast_framebuffer(crtc->primary->fb);\r\nobj = ast_fb->obj;\r\nbo = gem_to_ast_bo(obj);\r\nret = ast_bo_reserve(bo, false);\r\nif (ret)\r\nreturn ret;\r\nret = ast_bo_pin(bo, TTM_PL_FLAG_VRAM, &gpu_addr);\r\nif (ret) {\r\nast_bo_unreserve(bo);\r\nreturn ret;\r\n}\r\nif (&ast->fbdev->afb == ast_fb) {\r\nret = ttm_bo_kmap(&bo->bo, 0, bo->bo.num_pages, &bo->kmap);\r\nif (ret)\r\nDRM_ERROR("failed to kmap fbcon\n");\r\n}\r\nast_bo_unreserve(bo);\r\nast_set_start_address_crt1(crtc, (u32)gpu_addr);\r\nreturn 0;\r\n}\r\nstatic int ast_crtc_mode_set_base(struct drm_crtc *crtc, int x, int y,\r\nstruct drm_framebuffer *old_fb)\r\n{\r\nreturn ast_crtc_do_set_base(crtc, old_fb, x, y, 0);\r\n}\r\nstatic int ast_crtc_mode_set(struct drm_crtc *crtc,\r\nstruct drm_display_mode *mode,\r\nstruct drm_display_mode *adjusted_mode,\r\nint x, int y,\r\nstruct drm_framebuffer *old_fb)\r\n{\r\nstruct drm_device *dev = crtc->dev;\r\nstruct ast_private *ast = crtc->dev->dev_private;\r\nstruct ast_vbios_mode_info vbios_mode;\r\nbool ret;\r\nif (ast->chip == AST1180) {\r\nDRM_ERROR("AST 1180 modesetting not supported\n");\r\nreturn -EINVAL;\r\n}\r\nret = ast_get_vbios_mode_info(crtc, mode, adjusted_mode, &vbios_mode);\r\nif (ret == false)\r\nreturn -EINVAL;\r\nast_open_key(ast);\r\nast_set_index_reg_mask(ast, AST_IO_CRTC_PORT, 0xa1, 0xff, 0x04);\r\nast_set_std_reg(crtc, adjusted_mode, &vbios_mode);\r\nast_set_crtc_reg(crtc, adjusted_mode, &vbios_mode);\r\nast_set_offset_reg(crtc);\r\nast_set_dclk_reg(dev, adjusted_mode, &vbios_mode);\r\nast_set_ext_reg(crtc, adjusted_mode, &vbios_mode);\r\nast_set_sync_reg(dev, adjusted_mode, &vbios_mode);\r\nast_set_dac_reg(crtc, adjusted_mode, &vbios_mode);\r\nast_crtc_mode_set_base(crtc, x, y, old_fb);\r\nreturn 0;\r\n}\r\nstatic void ast_crtc_disable(struct drm_crtc *crtc)\r\n{\r\n}\r\nstatic void ast_crtc_prepare(struct drm_crtc *crtc)\r\n{\r\n}\r\nstatic void ast_crtc_commit(struct drm_crtc *crtc)\r\n{\r\nstruct ast_private *ast = crtc->dev->dev_private;\r\nast_set_index_reg_mask(ast, AST_IO_SEQ_PORT, 0x1, 0xdf, 0);\r\n}\r\nstatic void ast_crtc_reset(struct drm_crtc *crtc)\r\n{\r\n}\r\nstatic void ast_crtc_gamma_set(struct drm_crtc *crtc, u16 *red, u16 *green,\r\nu16 *blue, uint32_t start, uint32_t size)\r\n{\r\nstruct ast_crtc *ast_crtc = to_ast_crtc(crtc);\r\nint end = (start + size > 256) ? 256 : start + size, i;\r\nfor (i = start; i < end; i++) {\r\nast_crtc->lut_r[i] = red[i] >> 8;\r\nast_crtc->lut_g[i] = green[i] >> 8;\r\nast_crtc->lut_b[i] = blue[i] >> 8;\r\n}\r\nast_crtc_load_lut(crtc);\r\n}\r\nstatic void ast_crtc_destroy(struct drm_crtc *crtc)\r\n{\r\ndrm_crtc_cleanup(crtc);\r\nkfree(crtc);\r\n}\r\nstatic int ast_crtc_init(struct drm_device *dev)\r\n{\r\nstruct ast_crtc *crtc;\r\nint i;\r\ncrtc = kzalloc(sizeof(struct ast_crtc), GFP_KERNEL);\r\nif (!crtc)\r\nreturn -ENOMEM;\r\ndrm_crtc_init(dev, &crtc->base, &ast_crtc_funcs);\r\ndrm_mode_crtc_set_gamma_size(&crtc->base, 256);\r\ndrm_crtc_helper_add(&crtc->base, &ast_crtc_helper_funcs);\r\nfor (i = 0; i < 256; i++) {\r\ncrtc->lut_r[i] = i;\r\ncrtc->lut_g[i] = i;\r\ncrtc->lut_b[i] = i;\r\n}\r\nreturn 0;\r\n}\r\nstatic void ast_encoder_destroy(struct drm_encoder *encoder)\r\n{\r\ndrm_encoder_cleanup(encoder);\r\nkfree(encoder);\r\n}\r\nstatic struct drm_encoder *ast_best_single_encoder(struct drm_connector *connector)\r\n{\r\nint enc_id = connector->encoder_ids[0];\r\nif (enc_id)\r\nreturn drm_encoder_find(connector->dev, enc_id);\r\nreturn NULL;\r\n}\r\nstatic void ast_encoder_dpms(struct drm_encoder *encoder, int mode)\r\n{\r\n}\r\nstatic bool ast_mode_fixup(struct drm_encoder *encoder,\r\nconst struct drm_display_mode *mode,\r\nstruct drm_display_mode *adjusted_mode)\r\n{\r\nreturn true;\r\n}\r\nstatic void ast_encoder_mode_set(struct drm_encoder *encoder,\r\nstruct drm_display_mode *mode,\r\nstruct drm_display_mode *adjusted_mode)\r\n{\r\n}\r\nstatic void ast_encoder_prepare(struct drm_encoder *encoder)\r\n{\r\n}\r\nstatic void ast_encoder_commit(struct drm_encoder *encoder)\r\n{\r\n}\r\nstatic int ast_encoder_init(struct drm_device *dev)\r\n{\r\nstruct ast_encoder *ast_encoder;\r\nast_encoder = kzalloc(sizeof(struct ast_encoder), GFP_KERNEL);\r\nif (!ast_encoder)\r\nreturn -ENOMEM;\r\ndrm_encoder_init(dev, &ast_encoder->base, &ast_enc_funcs,\r\nDRM_MODE_ENCODER_DAC);\r\ndrm_encoder_helper_add(&ast_encoder->base, &ast_enc_helper_funcs);\r\nast_encoder->base.possible_crtcs = 1;\r\nreturn 0;\r\n}\r\nstatic int ast_get_modes(struct drm_connector *connector)\r\n{\r\nstruct ast_connector *ast_connector = to_ast_connector(connector);\r\nstruct ast_private *ast = connector->dev->dev_private;\r\nstruct edid *edid;\r\nint ret;\r\nbool flags = false;\r\nif (ast->tx_chip_type == AST_TX_DP501) {\r\nast->dp501_maxclk = 0xff;\r\nedid = kmalloc(128, GFP_KERNEL);\r\nif (!edid)\r\nreturn -ENOMEM;\r\nflags = ast_dp501_read_edid(connector->dev, (u8 *)edid);\r\nif (flags)\r\nast->dp501_maxclk = ast_get_dp501_max_clk(connector->dev);\r\nelse\r\nkfree(edid);\r\n}\r\nif (!flags)\r\nedid = drm_get_edid(connector, &ast_connector->i2c->adapter);\r\nif (edid) {\r\ndrm_mode_connector_update_edid_property(&ast_connector->base, edid);\r\nret = drm_add_edid_modes(connector, edid);\r\nkfree(edid);\r\nreturn ret;\r\n} else\r\ndrm_mode_connector_update_edid_property(&ast_connector->base, NULL);\r\nreturn 0;\r\n}\r\nstatic int ast_mode_valid(struct drm_connector *connector,\r\nstruct drm_display_mode *mode)\r\n{\r\nstruct ast_private *ast = connector->dev->dev_private;\r\nint flags = MODE_NOMODE;\r\nuint32_t jtemp;\r\nif (ast->support_wide_screen) {\r\nif ((mode->hdisplay == 1680) && (mode->vdisplay == 1050))\r\nreturn MODE_OK;\r\nif ((mode->hdisplay == 1280) && (mode->vdisplay == 800))\r\nreturn MODE_OK;\r\nif ((mode->hdisplay == 1440) && (mode->vdisplay == 900))\r\nreturn MODE_OK;\r\nif ((mode->hdisplay == 1360) && (mode->vdisplay == 768))\r\nreturn MODE_OK;\r\nif ((mode->hdisplay == 1600) && (mode->vdisplay == 900))\r\nreturn MODE_OK;\r\nif ((ast->chip == AST2100) || (ast->chip == AST2200) || (ast->chip == AST2300) || (ast->chip == AST2400) || (ast->chip == AST1180)) {\r\nif ((mode->hdisplay == 1920) && (mode->vdisplay == 1080))\r\nreturn MODE_OK;\r\nif ((mode->hdisplay == 1920) && (mode->vdisplay == 1200)) {\r\njtemp = ast_get_index_reg_mask(ast, AST_IO_CRTC_PORT, 0xd1, 0xff);\r\nif (jtemp & 0x01)\r\nreturn MODE_NOMODE;\r\nelse\r\nreturn MODE_OK;\r\n}\r\n}\r\n}\r\nswitch (mode->hdisplay) {\r\ncase 640:\r\nif (mode->vdisplay == 480) flags = MODE_OK;\r\nbreak;\r\ncase 800:\r\nif (mode->vdisplay == 600) flags = MODE_OK;\r\nbreak;\r\ncase 1024:\r\nif (mode->vdisplay == 768) flags = MODE_OK;\r\nbreak;\r\ncase 1280:\r\nif (mode->vdisplay == 1024) flags = MODE_OK;\r\nbreak;\r\ncase 1600:\r\nif (mode->vdisplay == 1200) flags = MODE_OK;\r\nbreak;\r\ndefault:\r\nreturn flags;\r\n}\r\nreturn flags;\r\n}\r\nstatic void ast_connector_destroy(struct drm_connector *connector)\r\n{\r\nstruct ast_connector *ast_connector = to_ast_connector(connector);\r\nast_i2c_destroy(ast_connector->i2c);\r\ndrm_connector_unregister(connector);\r\ndrm_connector_cleanup(connector);\r\nkfree(connector);\r\n}\r\nstatic enum drm_connector_status\r\nast_connector_detect(struct drm_connector *connector, bool force)\r\n{\r\nreturn connector_status_connected;\r\n}\r\nstatic int ast_connector_init(struct drm_device *dev)\r\n{\r\nstruct ast_connector *ast_connector;\r\nstruct drm_connector *connector;\r\nstruct drm_encoder *encoder;\r\nast_connector = kzalloc(sizeof(struct ast_connector), GFP_KERNEL);\r\nif (!ast_connector)\r\nreturn -ENOMEM;\r\nconnector = &ast_connector->base;\r\ndrm_connector_init(dev, connector, &ast_connector_funcs, DRM_MODE_CONNECTOR_VGA);\r\ndrm_connector_helper_add(connector, &ast_connector_helper_funcs);\r\nconnector->interlace_allowed = 0;\r\nconnector->doublescan_allowed = 0;\r\ndrm_connector_register(connector);\r\nconnector->polled = DRM_CONNECTOR_POLL_CONNECT;\r\nencoder = list_first_entry(&dev->mode_config.encoder_list, struct drm_encoder, head);\r\ndrm_mode_connector_attach_encoder(connector, encoder);\r\nast_connector->i2c = ast_i2c_create(dev);\r\nif (!ast_connector->i2c)\r\nDRM_ERROR("failed to add ddc bus for connector\n");\r\nreturn 0;\r\n}\r\nstatic int ast_cursor_init(struct drm_device *dev)\r\n{\r\nstruct ast_private *ast = dev->dev_private;\r\nint size;\r\nint ret;\r\nstruct drm_gem_object *obj;\r\nstruct ast_bo *bo;\r\nuint64_t gpu_addr;\r\nsize = (AST_HWC_SIZE + AST_HWC_SIGNATURE_SIZE) * AST_DEFAULT_HWC_NUM;\r\nret = ast_gem_create(dev, size, true, &obj);\r\nif (ret)\r\nreturn ret;\r\nbo = gem_to_ast_bo(obj);\r\nret = ast_bo_reserve(bo, false);\r\nif (unlikely(ret != 0))\r\ngoto fail;\r\nret = ast_bo_pin(bo, TTM_PL_FLAG_VRAM, &gpu_addr);\r\nast_bo_unreserve(bo);\r\nif (ret)\r\ngoto fail;\r\nret = ttm_bo_kmap(&bo->bo, 0, bo->bo.num_pages, &ast->cache_kmap);\r\nif (ret)\r\ngoto fail;\r\nast->cursor_cache = obj;\r\nast->cursor_cache_gpu_addr = gpu_addr;\r\nDRM_DEBUG_KMS("pinned cursor cache at %llx\n", ast->cursor_cache_gpu_addr);\r\nreturn 0;\r\nfail:\r\nreturn ret;\r\n}\r\nstatic void ast_cursor_fini(struct drm_device *dev)\r\n{\r\nstruct ast_private *ast = dev->dev_private;\r\nttm_bo_kunmap(&ast->cache_kmap);\r\ndrm_gem_object_unreference_unlocked(ast->cursor_cache);\r\n}\r\nint ast_mode_init(struct drm_device *dev)\r\n{\r\nast_cursor_init(dev);\r\nast_crtc_init(dev);\r\nast_encoder_init(dev);\r\nast_connector_init(dev);\r\nreturn 0;\r\n}\r\nvoid ast_mode_fini(struct drm_device *dev)\r\n{\r\nast_cursor_fini(dev);\r\n}\r\nstatic int get_clock(void *i2c_priv)\r\n{\r\nstruct ast_i2c_chan *i2c = i2c_priv;\r\nstruct ast_private *ast = i2c->dev->dev_private;\r\nuint32_t val;\r\nval = ast_get_index_reg_mask(ast, AST_IO_CRTC_PORT, 0xb7, 0x10) >> 4;\r\nreturn val & 1 ? 1 : 0;\r\n}\r\nstatic int get_data(void *i2c_priv)\r\n{\r\nstruct ast_i2c_chan *i2c = i2c_priv;\r\nstruct ast_private *ast = i2c->dev->dev_private;\r\nuint32_t val;\r\nval = ast_get_index_reg_mask(ast, AST_IO_CRTC_PORT, 0xb7, 0x20) >> 5;\r\nreturn val & 1 ? 1 : 0;\r\n}\r\nstatic void set_clock(void *i2c_priv, int clock)\r\n{\r\nstruct ast_i2c_chan *i2c = i2c_priv;\r\nstruct ast_private *ast = i2c->dev->dev_private;\r\nint i;\r\nu8 ujcrb7, jtemp;\r\nfor (i = 0; i < 0x10000; i++) {\r\nujcrb7 = ((clock & 0x01) ? 0 : 1);\r\nast_set_index_reg_mask(ast, AST_IO_CRTC_PORT, 0xb7, 0xfe, ujcrb7);\r\njtemp = ast_get_index_reg_mask(ast, AST_IO_CRTC_PORT, 0xb7, 0x01);\r\nif (ujcrb7 == jtemp)\r\nbreak;\r\n}\r\n}\r\nstatic void set_data(void *i2c_priv, int data)\r\n{\r\nstruct ast_i2c_chan *i2c = i2c_priv;\r\nstruct ast_private *ast = i2c->dev->dev_private;\r\nint i;\r\nu8 ujcrb7, jtemp;\r\nfor (i = 0; i < 0x10000; i++) {\r\nujcrb7 = ((data & 0x01) ? 0 : 1) << 2;\r\nast_set_index_reg_mask(ast, AST_IO_CRTC_PORT, 0xb7, 0xfb, ujcrb7);\r\njtemp = ast_get_index_reg_mask(ast, AST_IO_CRTC_PORT, 0xb7, 0x04);\r\nif (ujcrb7 == jtemp)\r\nbreak;\r\n}\r\n}\r\nstatic struct ast_i2c_chan *ast_i2c_create(struct drm_device *dev)\r\n{\r\nstruct ast_i2c_chan *i2c;\r\nint ret;\r\ni2c = kzalloc(sizeof(struct ast_i2c_chan), GFP_KERNEL);\r\nif (!i2c)\r\nreturn NULL;\r\ni2c->adapter.owner = THIS_MODULE;\r\ni2c->adapter.class = I2C_CLASS_DDC;\r\ni2c->adapter.dev.parent = &dev->pdev->dev;\r\ni2c->dev = dev;\r\ni2c_set_adapdata(&i2c->adapter, i2c);\r\nsnprintf(i2c->adapter.name, sizeof(i2c->adapter.name),\r\n"AST i2c bit bus");\r\ni2c->adapter.algo_data = &i2c->bit;\r\ni2c->bit.udelay = 20;\r\ni2c->bit.timeout = 2;\r\ni2c->bit.data = i2c;\r\ni2c->bit.setsda = set_data;\r\ni2c->bit.setscl = set_clock;\r\ni2c->bit.getsda = get_data;\r\ni2c->bit.getscl = get_clock;\r\nret = i2c_bit_add_bus(&i2c->adapter);\r\nif (ret) {\r\nDRM_ERROR("Failed to register bit i2c\n");\r\ngoto out_free;\r\n}\r\nreturn i2c;\r\nout_free:\r\nkfree(i2c);\r\nreturn NULL;\r\n}\r\nstatic void ast_i2c_destroy(struct ast_i2c_chan *i2c)\r\n{\r\nif (!i2c)\r\nreturn;\r\ni2c_del_adapter(&i2c->adapter);\r\nkfree(i2c);\r\n}\r\nstatic void ast_show_cursor(struct drm_crtc *crtc)\r\n{\r\nstruct ast_private *ast = crtc->dev->dev_private;\r\nu8 jreg;\r\njreg = 0x2;\r\njreg |= 1;\r\nast_set_index_reg_mask(ast, AST_IO_CRTC_PORT, 0xcb, 0xfc, jreg);\r\n}\r\nstatic void ast_hide_cursor(struct drm_crtc *crtc)\r\n{\r\nstruct ast_private *ast = crtc->dev->dev_private;\r\nast_set_index_reg_mask(ast, AST_IO_CRTC_PORT, 0xcb, 0xfc, 0x00);\r\n}\r\nstatic u32 copy_cursor_image(u8 *src, u8 *dst, int width, int height)\r\n{\r\nunion {\r\nu32 ul;\r\nu8 b[4];\r\n} srcdata32[2], data32;\r\nunion {\r\nu16 us;\r\nu8 b[2];\r\n} data16;\r\nu32 csum = 0;\r\ns32 alpha_dst_delta, last_alpha_dst_delta;\r\nu8 *srcxor, *dstxor;\r\nint i, j;\r\nu32 per_pixel_copy, two_pixel_copy;\r\nalpha_dst_delta = AST_MAX_HWC_WIDTH << 1;\r\nlast_alpha_dst_delta = alpha_dst_delta - (width << 1);\r\nsrcxor = src;\r\ndstxor = (u8 *)dst + last_alpha_dst_delta + (AST_MAX_HWC_HEIGHT - height) * alpha_dst_delta;\r\nper_pixel_copy = width & 1;\r\ntwo_pixel_copy = width >> 1;\r\nfor (j = 0; j < height; j++) {\r\nfor (i = 0; i < two_pixel_copy; i++) {\r\nsrcdata32[0].ul = *((u32 *)srcxor) & 0xf0f0f0f0;\r\nsrcdata32[1].ul = *((u32 *)(srcxor + 4)) & 0xf0f0f0f0;\r\ndata32.b[0] = srcdata32[0].b[1] | (srcdata32[0].b[0] >> 4);\r\ndata32.b[1] = srcdata32[0].b[3] | (srcdata32[0].b[2] >> 4);\r\ndata32.b[2] = srcdata32[1].b[1] | (srcdata32[1].b[0] >> 4);\r\ndata32.b[3] = srcdata32[1].b[3] | (srcdata32[1].b[2] >> 4);\r\nwritel(data32.ul, dstxor);\r\ncsum += data32.ul;\r\ndstxor += 4;\r\nsrcxor += 8;\r\n}\r\nfor (i = 0; i < per_pixel_copy; i++) {\r\nsrcdata32[0].ul = *((u32 *)srcxor) & 0xf0f0f0f0;\r\ndata16.b[0] = srcdata32[0].b[1] | (srcdata32[0].b[0] >> 4);\r\ndata16.b[1] = srcdata32[0].b[3] | (srcdata32[0].b[2] >> 4);\r\nwritew(data16.us, dstxor);\r\ncsum += (u32)data16.us;\r\ndstxor += 2;\r\nsrcxor += 4;\r\n}\r\ndstxor += last_alpha_dst_delta;\r\n}\r\nreturn csum;\r\n}\r\nstatic int ast_cursor_set(struct drm_crtc *crtc,\r\nstruct drm_file *file_priv,\r\nuint32_t handle,\r\nuint32_t width,\r\nuint32_t height)\r\n{\r\nstruct ast_private *ast = crtc->dev->dev_private;\r\nstruct ast_crtc *ast_crtc = to_ast_crtc(crtc);\r\nstruct drm_gem_object *obj;\r\nstruct ast_bo *bo;\r\nuint64_t gpu_addr;\r\nu32 csum;\r\nint ret;\r\nstruct ttm_bo_kmap_obj uobj_map;\r\nu8 *src, *dst;\r\nbool src_isiomem, dst_isiomem;\r\nif (!handle) {\r\nast_hide_cursor(crtc);\r\nreturn 0;\r\n}\r\nif (width > AST_MAX_HWC_WIDTH || height > AST_MAX_HWC_HEIGHT)\r\nreturn -EINVAL;\r\nobj = drm_gem_object_lookup(crtc->dev, file_priv, handle);\r\nif (!obj) {\r\nDRM_ERROR("Cannot find cursor object %x for crtc\n", handle);\r\nreturn -ENOENT;\r\n}\r\nbo = gem_to_ast_bo(obj);\r\nret = ast_bo_reserve(bo, false);\r\nif (ret)\r\ngoto fail;\r\nret = ttm_bo_kmap(&bo->bo, 0, bo->bo.num_pages, &uobj_map);\r\nsrc = ttm_kmap_obj_virtual(&uobj_map, &src_isiomem);\r\ndst = ttm_kmap_obj_virtual(&ast->cache_kmap, &dst_isiomem);\r\nif (src_isiomem == true)\r\nDRM_ERROR("src cursor bo should be in main memory\n");\r\nif (dst_isiomem == false)\r\nDRM_ERROR("dst bo should be in VRAM\n");\r\ndst += (AST_HWC_SIZE + AST_HWC_SIGNATURE_SIZE)*ast->next_cursor;\r\ncsum = copy_cursor_image(src, dst, width, height);\r\nttm_bo_kunmap(&uobj_map);\r\nast_bo_unreserve(bo);\r\n{\r\nu8 *dst = (u8 *)ast->cache_kmap.virtual + (AST_HWC_SIZE + AST_HWC_SIGNATURE_SIZE)*ast->next_cursor + AST_HWC_SIZE;\r\nwritel(csum, dst);\r\nwritel(width, dst + AST_HWC_SIGNATURE_SizeX);\r\nwritel(height, dst + AST_HWC_SIGNATURE_SizeY);\r\nwritel(0, dst + AST_HWC_SIGNATURE_HOTSPOTX);\r\nwritel(0, dst + AST_HWC_SIGNATURE_HOTSPOTY);\r\ngpu_addr = ast->cursor_cache_gpu_addr;\r\ngpu_addr += (AST_HWC_SIZE + AST_HWC_SIGNATURE_SIZE)*ast->next_cursor;\r\ngpu_addr >>= 3;\r\nast_set_index_reg(ast, AST_IO_CRTC_PORT, 0xc8, gpu_addr & 0xff);\r\nast_set_index_reg(ast, AST_IO_CRTC_PORT, 0xc9, (gpu_addr >> 8) & 0xff);\r\nast_set_index_reg(ast, AST_IO_CRTC_PORT, 0xca, (gpu_addr >> 16) & 0xff);\r\n}\r\nast_crtc->cursor_width = width;\r\nast_crtc->cursor_height = height;\r\nast_crtc->offset_x = AST_MAX_HWC_WIDTH - width;\r\nast_crtc->offset_y = AST_MAX_HWC_WIDTH - height;\r\nast->next_cursor = (ast->next_cursor + 1) % AST_DEFAULT_HWC_NUM;\r\nast_show_cursor(crtc);\r\ndrm_gem_object_unreference_unlocked(obj);\r\nreturn 0;\r\nfail:\r\ndrm_gem_object_unreference_unlocked(obj);\r\nreturn ret;\r\n}\r\nstatic int ast_cursor_move(struct drm_crtc *crtc,\r\nint x, int y)\r\n{\r\nstruct ast_crtc *ast_crtc = to_ast_crtc(crtc);\r\nstruct ast_private *ast = crtc->dev->dev_private;\r\nint x_offset, y_offset;\r\nu8 *sig;\r\nsig = (u8 *)ast->cache_kmap.virtual + (AST_HWC_SIZE + AST_HWC_SIGNATURE_SIZE)*ast->next_cursor + AST_HWC_SIZE;\r\nwritel(x, sig + AST_HWC_SIGNATURE_X);\r\nwritel(y, sig + AST_HWC_SIGNATURE_Y);\r\nx_offset = ast_crtc->offset_x;\r\ny_offset = ast_crtc->offset_y;\r\nif (x < 0) {\r\nx_offset = (-x) + ast_crtc->offset_x;\r\nx = 0;\r\n}\r\nif (y < 0) {\r\ny_offset = (-y) + ast_crtc->offset_y;\r\ny = 0;\r\n}\r\nast_set_index_reg(ast, AST_IO_CRTC_PORT, 0xc2, x_offset);\r\nast_set_index_reg(ast, AST_IO_CRTC_PORT, 0xc3, y_offset);\r\nast_set_index_reg(ast, AST_IO_CRTC_PORT, 0xc4, (x & 0xff));\r\nast_set_index_reg(ast, AST_IO_CRTC_PORT, 0xc5, ((x >> 8) & 0x0f));\r\nast_set_index_reg(ast, AST_IO_CRTC_PORT, 0xc6, (y & 0xff));\r\nast_set_index_reg(ast, AST_IO_CRTC_PORT, 0xc7, ((y >> 8) & 0x07));\r\nast_set_index_reg_mask(ast, AST_IO_CRTC_PORT, 0xCB, 0xFF, 0x00);\r\nreturn 0;\r\n}
