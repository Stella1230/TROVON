static inline unsigned int\r\noxygen_substream_channel(struct snd_pcm_substream *substream)\r\n{\r\nreturn (unsigned int)(uintptr_t)substream->runtime->private_data;\r\n}\r\nstatic int oxygen_open(struct snd_pcm_substream *substream,\r\nunsigned int channel)\r\n{\r\nstruct oxygen *chip = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nint err;\r\nruntime->private_data = (void *)(uintptr_t)channel;\r\nif (channel == PCM_B && chip->has_ac97_1 &&\r\n(chip->model.device_config & CAPTURE_2_FROM_AC97_1))\r\nruntime->hw = oxygen_ac97_hardware;\r\nelse\r\nruntime->hw = *oxygen_hardware[channel];\r\nswitch (channel) {\r\ncase PCM_C:\r\nif (chip->model.device_config & CAPTURE_1_FROM_SPDIF) {\r\nruntime->hw.rates &= ~(SNDRV_PCM_RATE_32000 |\r\nSNDRV_PCM_RATE_64000);\r\nruntime->hw.rate_min = 44100;\r\n}\r\ncase PCM_A:\r\ncase PCM_B:\r\nruntime->hw.fifo_size = 0;\r\nbreak;\r\ncase PCM_MULTICH:\r\nruntime->hw.channels_max = chip->model.dac_channels_pcm;\r\nbreak;\r\n}\r\nif (chip->model.pcm_hardware_filter)\r\nchip->model.pcm_hardware_filter(channel, &runtime->hw);\r\nerr = snd_pcm_hw_constraint_step(runtime, 0,\r\nSNDRV_PCM_HW_PARAM_PERIOD_BYTES, 32);\r\nif (err < 0)\r\nreturn err;\r\nerr = snd_pcm_hw_constraint_step(runtime, 0,\r\nSNDRV_PCM_HW_PARAM_BUFFER_BYTES, 32);\r\nif (err < 0)\r\nreturn err;\r\nif (runtime->hw.formats & SNDRV_PCM_FMTBIT_S32_LE) {\r\nerr = snd_pcm_hw_constraint_msbits(runtime, 0, 32, 24);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nif (runtime->hw.channels_max > 2) {\r\nerr = snd_pcm_hw_constraint_step(runtime, 0,\r\nSNDRV_PCM_HW_PARAM_CHANNELS,\r\n2);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nsnd_pcm_set_sync(substream);\r\nchip->streams[channel] = substream;\r\nmutex_lock(&chip->mutex);\r\nchip->pcm_active |= 1 << channel;\r\nif (channel == PCM_SPDIF) {\r\nchip->spdif_pcm_bits = chip->spdif_bits;\r\nchip->controls[CONTROL_SPDIF_PCM]->vd[0].access &=\r\n~SNDRV_CTL_ELEM_ACCESS_INACTIVE;\r\nsnd_ctl_notify(chip->card, SNDRV_CTL_EVENT_MASK_VALUE |\r\nSNDRV_CTL_EVENT_MASK_INFO,\r\n&chip->controls[CONTROL_SPDIF_PCM]->id);\r\n}\r\nmutex_unlock(&chip->mutex);\r\nreturn 0;\r\n}\r\nstatic int oxygen_rec_a_open(struct snd_pcm_substream *substream)\r\n{\r\nreturn oxygen_open(substream, PCM_A);\r\n}\r\nstatic int oxygen_rec_b_open(struct snd_pcm_substream *substream)\r\n{\r\nreturn oxygen_open(substream, PCM_B);\r\n}\r\nstatic int oxygen_rec_c_open(struct snd_pcm_substream *substream)\r\n{\r\nreturn oxygen_open(substream, PCM_C);\r\n}\r\nstatic int oxygen_spdif_open(struct snd_pcm_substream *substream)\r\n{\r\nreturn oxygen_open(substream, PCM_SPDIF);\r\n}\r\nstatic int oxygen_multich_open(struct snd_pcm_substream *substream)\r\n{\r\nreturn oxygen_open(substream, PCM_MULTICH);\r\n}\r\nstatic int oxygen_ac97_open(struct snd_pcm_substream *substream)\r\n{\r\nreturn oxygen_open(substream, PCM_AC97);\r\n}\r\nstatic int oxygen_close(struct snd_pcm_substream *substream)\r\n{\r\nstruct oxygen *chip = snd_pcm_substream_chip(substream);\r\nunsigned int channel = oxygen_substream_channel(substream);\r\nmutex_lock(&chip->mutex);\r\nchip->pcm_active &= ~(1 << channel);\r\nif (channel == PCM_SPDIF) {\r\nchip->controls[CONTROL_SPDIF_PCM]->vd[0].access |=\r\nSNDRV_CTL_ELEM_ACCESS_INACTIVE;\r\nsnd_ctl_notify(chip->card, SNDRV_CTL_EVENT_MASK_VALUE |\r\nSNDRV_CTL_EVENT_MASK_INFO,\r\n&chip->controls[CONTROL_SPDIF_PCM]->id);\r\n}\r\nif (channel == PCM_SPDIF || channel == PCM_MULTICH)\r\noxygen_update_spdif_source(chip);\r\nmutex_unlock(&chip->mutex);\r\nchip->streams[channel] = NULL;\r\nreturn 0;\r\n}\r\nstatic unsigned int oxygen_format(struct snd_pcm_hw_params *hw_params)\r\n{\r\nif (params_format(hw_params) == SNDRV_PCM_FORMAT_S32_LE)\r\nreturn OXYGEN_FORMAT_24;\r\nelse\r\nreturn OXYGEN_FORMAT_16;\r\n}\r\nstatic unsigned int oxygen_rate(struct snd_pcm_hw_params *hw_params)\r\n{\r\nswitch (params_rate(hw_params)) {\r\ncase 32000:\r\nreturn OXYGEN_RATE_32000;\r\ncase 44100:\r\nreturn OXYGEN_RATE_44100;\r\ndefault:\r\nreturn OXYGEN_RATE_48000;\r\ncase 64000:\r\nreturn OXYGEN_RATE_64000;\r\ncase 88200:\r\nreturn OXYGEN_RATE_88200;\r\ncase 96000:\r\nreturn OXYGEN_RATE_96000;\r\ncase 176400:\r\nreturn OXYGEN_RATE_176400;\r\ncase 192000:\r\nreturn OXYGEN_RATE_192000;\r\n}\r\n}\r\nstatic unsigned int oxygen_i2s_bits(struct snd_pcm_hw_params *hw_params)\r\n{\r\nif (params_format(hw_params) == SNDRV_PCM_FORMAT_S32_LE)\r\nreturn OXYGEN_I2S_BITS_24;\r\nelse\r\nreturn OXYGEN_I2S_BITS_16;\r\n}\r\nstatic unsigned int oxygen_play_channels(struct snd_pcm_hw_params *hw_params)\r\n{\r\nswitch (params_channels(hw_params)) {\r\ndefault:\r\nreturn OXYGEN_PLAY_CHANNELS_2;\r\ncase 4:\r\nreturn OXYGEN_PLAY_CHANNELS_4;\r\ncase 6:\r\nreturn OXYGEN_PLAY_CHANNELS_6;\r\ncase 8:\r\nreturn OXYGEN_PLAY_CHANNELS_8;\r\n}\r\n}\r\nstatic int oxygen_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *hw_params)\r\n{\r\nstruct oxygen *chip = snd_pcm_substream_chip(substream);\r\nunsigned int channel = oxygen_substream_channel(substream);\r\nint err;\r\nerr = snd_pcm_lib_malloc_pages(substream,\r\nparams_buffer_bytes(hw_params));\r\nif (err < 0)\r\nreturn err;\r\noxygen_write32(chip, channel_base_registers[channel],\r\n(u32)substream->runtime->dma_addr);\r\nif (channel == PCM_MULTICH) {\r\noxygen_write32(chip, OXYGEN_DMA_MULTICH_COUNT,\r\nparams_buffer_bytes(hw_params) / 4 - 1);\r\noxygen_write32(chip, OXYGEN_DMA_MULTICH_TCOUNT,\r\nparams_period_bytes(hw_params) / 4 - 1);\r\n} else {\r\noxygen_write16(chip, channel_base_registers[channel] + 4,\r\nparams_buffer_bytes(hw_params) / 4 - 1);\r\noxygen_write16(chip, channel_base_registers[channel] + 6,\r\nparams_period_bytes(hw_params) / 4 - 1);\r\n}\r\nreturn 0;\r\n}\r\nstatic u16 get_mclk(struct oxygen *chip, unsigned int channel,\r\nstruct snd_pcm_hw_params *params)\r\n{\r\nunsigned int mclks, shift;\r\nif (channel == PCM_MULTICH)\r\nmclks = chip->model.dac_mclks;\r\nelse\r\nmclks = chip->model.adc_mclks;\r\nif (params_rate(params) <= 48000)\r\nshift = 0;\r\nelse if (params_rate(params) <= 96000)\r\nshift = 2;\r\nelse\r\nshift = 4;\r\nreturn OXYGEN_I2S_MCLK(mclks >> shift);\r\n}\r\nstatic int oxygen_rec_a_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *hw_params)\r\n{\r\nstruct oxygen *chip = snd_pcm_substream_chip(substream);\r\nint err;\r\nerr = oxygen_hw_params(substream, hw_params);\r\nif (err < 0)\r\nreturn err;\r\nspin_lock_irq(&chip->reg_lock);\r\noxygen_write8_masked(chip, OXYGEN_REC_FORMAT,\r\noxygen_format(hw_params) << OXYGEN_REC_FORMAT_A_SHIFT,\r\nOXYGEN_REC_FORMAT_A_MASK);\r\noxygen_write16_masked(chip, OXYGEN_I2S_A_FORMAT,\r\noxygen_rate(hw_params) |\r\nchip->model.adc_i2s_format |\r\nget_mclk(chip, PCM_A, hw_params) |\r\noxygen_i2s_bits(hw_params),\r\nOXYGEN_I2S_RATE_MASK |\r\nOXYGEN_I2S_FORMAT_MASK |\r\nOXYGEN_I2S_MCLK_MASK |\r\nOXYGEN_I2S_BITS_MASK);\r\nspin_unlock_irq(&chip->reg_lock);\r\nmutex_lock(&chip->mutex);\r\nchip->model.set_adc_params(chip, hw_params);\r\nmutex_unlock(&chip->mutex);\r\nreturn 0;\r\n}\r\nstatic int oxygen_rec_b_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *hw_params)\r\n{\r\nstruct oxygen *chip = snd_pcm_substream_chip(substream);\r\nint is_ac97;\r\nint err;\r\nerr = oxygen_hw_params(substream, hw_params);\r\nif (err < 0)\r\nreturn err;\r\nis_ac97 = chip->has_ac97_1 &&\r\n(chip->model.device_config & CAPTURE_2_FROM_AC97_1);\r\nspin_lock_irq(&chip->reg_lock);\r\noxygen_write8_masked(chip, OXYGEN_REC_FORMAT,\r\noxygen_format(hw_params) << OXYGEN_REC_FORMAT_B_SHIFT,\r\nOXYGEN_REC_FORMAT_B_MASK);\r\nif (!is_ac97)\r\noxygen_write16_masked(chip, OXYGEN_I2S_B_FORMAT,\r\noxygen_rate(hw_params) |\r\nchip->model.adc_i2s_format |\r\nget_mclk(chip, PCM_B, hw_params) |\r\noxygen_i2s_bits(hw_params),\r\nOXYGEN_I2S_RATE_MASK |\r\nOXYGEN_I2S_FORMAT_MASK |\r\nOXYGEN_I2S_MCLK_MASK |\r\nOXYGEN_I2S_BITS_MASK);\r\nspin_unlock_irq(&chip->reg_lock);\r\nif (!is_ac97) {\r\nmutex_lock(&chip->mutex);\r\nchip->model.set_adc_params(chip, hw_params);\r\nmutex_unlock(&chip->mutex);\r\n}\r\nreturn 0;\r\n}\r\nstatic int oxygen_rec_c_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *hw_params)\r\n{\r\nstruct oxygen *chip = snd_pcm_substream_chip(substream);\r\nbool is_spdif;\r\nint err;\r\nerr = oxygen_hw_params(substream, hw_params);\r\nif (err < 0)\r\nreturn err;\r\nis_spdif = chip->model.device_config & CAPTURE_1_FROM_SPDIF;\r\nspin_lock_irq(&chip->reg_lock);\r\noxygen_write8_masked(chip, OXYGEN_REC_FORMAT,\r\noxygen_format(hw_params) << OXYGEN_REC_FORMAT_C_SHIFT,\r\nOXYGEN_REC_FORMAT_C_MASK);\r\nif (!is_spdif)\r\noxygen_write16_masked(chip, OXYGEN_I2S_C_FORMAT,\r\noxygen_rate(hw_params) |\r\nchip->model.adc_i2s_format |\r\nget_mclk(chip, PCM_B, hw_params) |\r\noxygen_i2s_bits(hw_params),\r\nOXYGEN_I2S_RATE_MASK |\r\nOXYGEN_I2S_FORMAT_MASK |\r\nOXYGEN_I2S_MCLK_MASK |\r\nOXYGEN_I2S_BITS_MASK);\r\nspin_unlock_irq(&chip->reg_lock);\r\nif (!is_spdif) {\r\nmutex_lock(&chip->mutex);\r\nchip->model.set_adc_params(chip, hw_params);\r\nmutex_unlock(&chip->mutex);\r\n}\r\nreturn 0;\r\n}\r\nstatic int oxygen_spdif_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *hw_params)\r\n{\r\nstruct oxygen *chip = snd_pcm_substream_chip(substream);\r\nint err;\r\nerr = oxygen_hw_params(substream, hw_params);\r\nif (err < 0)\r\nreturn err;\r\nmutex_lock(&chip->mutex);\r\nspin_lock_irq(&chip->reg_lock);\r\noxygen_clear_bits32(chip, OXYGEN_SPDIF_CONTROL,\r\nOXYGEN_SPDIF_OUT_ENABLE);\r\noxygen_write8_masked(chip, OXYGEN_PLAY_FORMAT,\r\noxygen_format(hw_params) << OXYGEN_SPDIF_FORMAT_SHIFT,\r\nOXYGEN_SPDIF_FORMAT_MASK);\r\noxygen_write32_masked(chip, OXYGEN_SPDIF_CONTROL,\r\noxygen_rate(hw_params) << OXYGEN_SPDIF_OUT_RATE_SHIFT,\r\nOXYGEN_SPDIF_OUT_RATE_MASK);\r\noxygen_update_spdif_source(chip);\r\nspin_unlock_irq(&chip->reg_lock);\r\nmutex_unlock(&chip->mutex);\r\nreturn 0;\r\n}\r\nstatic int oxygen_multich_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *hw_params)\r\n{\r\nstruct oxygen *chip = snd_pcm_substream_chip(substream);\r\nint err;\r\nerr = oxygen_hw_params(substream, hw_params);\r\nif (err < 0)\r\nreturn err;\r\nmutex_lock(&chip->mutex);\r\nspin_lock_irq(&chip->reg_lock);\r\noxygen_write8_masked(chip, OXYGEN_PLAY_CHANNELS,\r\noxygen_play_channels(hw_params),\r\nOXYGEN_PLAY_CHANNELS_MASK);\r\noxygen_write8_masked(chip, OXYGEN_PLAY_FORMAT,\r\noxygen_format(hw_params) << OXYGEN_MULTICH_FORMAT_SHIFT,\r\nOXYGEN_MULTICH_FORMAT_MASK);\r\noxygen_write16_masked(chip, OXYGEN_I2S_MULTICH_FORMAT,\r\noxygen_rate(hw_params) |\r\nchip->model.dac_i2s_format |\r\nget_mclk(chip, PCM_MULTICH, hw_params) |\r\noxygen_i2s_bits(hw_params),\r\nOXYGEN_I2S_RATE_MASK |\r\nOXYGEN_I2S_FORMAT_MASK |\r\nOXYGEN_I2S_MCLK_MASK |\r\nOXYGEN_I2S_BITS_MASK);\r\noxygen_update_spdif_source(chip);\r\nspin_unlock_irq(&chip->reg_lock);\r\nchip->model.set_dac_params(chip, hw_params);\r\noxygen_update_dac_routing(chip);\r\nmutex_unlock(&chip->mutex);\r\nreturn 0;\r\n}\r\nstatic int oxygen_hw_free(struct snd_pcm_substream *substream)\r\n{\r\nstruct oxygen *chip = snd_pcm_substream_chip(substream);\r\nunsigned int channel = oxygen_substream_channel(substream);\r\nunsigned int channel_mask = 1 << channel;\r\nspin_lock_irq(&chip->reg_lock);\r\nchip->interrupt_mask &= ~channel_mask;\r\noxygen_write16(chip, OXYGEN_INTERRUPT_MASK, chip->interrupt_mask);\r\noxygen_set_bits8(chip, OXYGEN_DMA_FLUSH, channel_mask);\r\noxygen_clear_bits8(chip, OXYGEN_DMA_FLUSH, channel_mask);\r\nspin_unlock_irq(&chip->reg_lock);\r\nreturn snd_pcm_lib_free_pages(substream);\r\n}\r\nstatic int oxygen_spdif_hw_free(struct snd_pcm_substream *substream)\r\n{\r\nstruct oxygen *chip = snd_pcm_substream_chip(substream);\r\nspin_lock_irq(&chip->reg_lock);\r\noxygen_clear_bits32(chip, OXYGEN_SPDIF_CONTROL,\r\nOXYGEN_SPDIF_OUT_ENABLE);\r\nspin_unlock_irq(&chip->reg_lock);\r\nreturn oxygen_hw_free(substream);\r\n}\r\nstatic int oxygen_prepare(struct snd_pcm_substream *substream)\r\n{\r\nstruct oxygen *chip = snd_pcm_substream_chip(substream);\r\nunsigned int channel = oxygen_substream_channel(substream);\r\nunsigned int channel_mask = 1 << channel;\r\nspin_lock_irq(&chip->reg_lock);\r\noxygen_set_bits8(chip, OXYGEN_DMA_FLUSH, channel_mask);\r\noxygen_clear_bits8(chip, OXYGEN_DMA_FLUSH, channel_mask);\r\nif (substream->runtime->no_period_wakeup)\r\nchip->interrupt_mask &= ~channel_mask;\r\nelse\r\nchip->interrupt_mask |= channel_mask;\r\noxygen_write16(chip, OXYGEN_INTERRUPT_MASK, chip->interrupt_mask);\r\nspin_unlock_irq(&chip->reg_lock);\r\nreturn 0;\r\n}\r\nstatic int oxygen_trigger(struct snd_pcm_substream *substream, int cmd)\r\n{\r\nstruct oxygen *chip = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_substream *s;\r\nunsigned int mask = 0;\r\nint pausing;\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\ncase SNDRV_PCM_TRIGGER_START:\r\ncase SNDRV_PCM_TRIGGER_SUSPEND:\r\npausing = 0;\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\r\ncase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\r\npausing = 1;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nsnd_pcm_group_for_each_entry(s, substream) {\r\nif (snd_pcm_substream_chip(s) == chip) {\r\nmask |= 1 << oxygen_substream_channel(s);\r\nsnd_pcm_trigger_done(s, substream);\r\n}\r\n}\r\nspin_lock(&chip->reg_lock);\r\nif (!pausing) {\r\nif (cmd == SNDRV_PCM_TRIGGER_START)\r\nchip->pcm_running |= mask;\r\nelse\r\nchip->pcm_running &= ~mask;\r\noxygen_write8(chip, OXYGEN_DMA_STATUS, chip->pcm_running);\r\n} else {\r\nif (cmd == SNDRV_PCM_TRIGGER_PAUSE_PUSH)\r\noxygen_set_bits8(chip, OXYGEN_DMA_PAUSE, mask);\r\nelse\r\noxygen_clear_bits8(chip, OXYGEN_DMA_PAUSE, mask);\r\n}\r\nspin_unlock(&chip->reg_lock);\r\nreturn 0;\r\n}\r\nstatic snd_pcm_uframes_t oxygen_pointer(struct snd_pcm_substream *substream)\r\n{\r\nstruct oxygen *chip = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nunsigned int channel = oxygen_substream_channel(substream);\r\nu32 curr_addr;\r\ncurr_addr = oxygen_read32(chip, channel_base_registers[channel]);\r\nreturn bytes_to_frames(runtime, curr_addr - (u32)runtime->dma_addr);\r\n}\r\nint oxygen_pcm_init(struct oxygen *chip)\r\n{\r\nstruct snd_pcm *pcm;\r\nint outs, ins;\r\nint err;\r\nouts = !!(chip->model.device_config & PLAYBACK_0_TO_I2S);\r\nins = !!(chip->model.device_config & (CAPTURE_0_FROM_I2S_1 |\r\nCAPTURE_0_FROM_I2S_2));\r\nif (outs | ins) {\r\nerr = snd_pcm_new(chip->card, "Multichannel",\r\n0, outs, ins, &pcm);\r\nif (err < 0)\r\nreturn err;\r\nif (outs)\r\nsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK,\r\n&oxygen_multich_ops);\r\nif (chip->model.device_config & CAPTURE_0_FROM_I2S_1)\r\nsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE,\r\n&oxygen_rec_a_ops);\r\nelse if (chip->model.device_config & CAPTURE_0_FROM_I2S_2)\r\nsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE,\r\n&oxygen_rec_b_ops);\r\npcm->private_data = chip;\r\nstrcpy(pcm->name, "Multichannel");\r\nif (outs)\r\nsnd_pcm_lib_preallocate_pages(pcm->streams[SNDRV_PCM_STREAM_PLAYBACK].substream,\r\nSNDRV_DMA_TYPE_DEV,\r\nsnd_dma_pci_data(chip->pci),\r\nDEFAULT_BUFFER_BYTES_MULTICH,\r\nBUFFER_BYTES_MAX_MULTICH);\r\nif (ins)\r\nsnd_pcm_lib_preallocate_pages(pcm->streams[SNDRV_PCM_STREAM_CAPTURE].substream,\r\nSNDRV_DMA_TYPE_DEV,\r\nsnd_dma_pci_data(chip->pci),\r\nDEFAULT_BUFFER_BYTES,\r\nBUFFER_BYTES_MAX);\r\n}\r\nouts = !!(chip->model.device_config & PLAYBACK_1_TO_SPDIF);\r\nins = !!(chip->model.device_config & CAPTURE_1_FROM_SPDIF);\r\nif (outs | ins) {\r\nerr = snd_pcm_new(chip->card, "Digital", 1, outs, ins, &pcm);\r\nif (err < 0)\r\nreturn err;\r\nif (outs)\r\nsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK,\r\n&oxygen_spdif_ops);\r\nif (ins)\r\nsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE,\r\n&oxygen_rec_c_ops);\r\npcm->private_data = chip;\r\nstrcpy(pcm->name, "Digital");\r\nsnd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_DEV,\r\nsnd_dma_pci_data(chip->pci),\r\nDEFAULT_BUFFER_BYTES,\r\nBUFFER_BYTES_MAX);\r\n}\r\nif (chip->has_ac97_1) {\r\nouts = !!(chip->model.device_config & PLAYBACK_2_TO_AC97_1);\r\nins = !!(chip->model.device_config & CAPTURE_2_FROM_AC97_1);\r\n} else {\r\nouts = 0;\r\nins = !!(chip->model.device_config & CAPTURE_2_FROM_I2S_2);\r\n}\r\nif (outs | ins) {\r\nerr = snd_pcm_new(chip->card, outs ? "AC97" : "Analog2",\r\n2, outs, ins, &pcm);\r\nif (err < 0)\r\nreturn err;\r\nif (outs) {\r\nsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK,\r\n&oxygen_ac97_ops);\r\noxygen_write8_masked(chip, OXYGEN_REC_ROUTING,\r\nOXYGEN_REC_B_ROUTE_AC97_1,\r\nOXYGEN_REC_B_ROUTE_MASK);\r\n}\r\nif (ins)\r\nsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE,\r\n&oxygen_rec_b_ops);\r\npcm->private_data = chip;\r\nstrcpy(pcm->name, outs ? "Front Panel" : "Analog 2");\r\nsnd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_DEV,\r\nsnd_dma_pci_data(chip->pci),\r\nDEFAULT_BUFFER_BYTES,\r\nBUFFER_BYTES_MAX);\r\n}\r\nins = !!(chip->model.device_config & CAPTURE_3_FROM_I2S_3);\r\nif (ins) {\r\nerr = snd_pcm_new(chip->card, "Analog3", 3, 0, ins, &pcm);\r\nif (err < 0)\r\nreturn err;\r\nsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE,\r\n&oxygen_rec_c_ops);\r\noxygen_write8_masked(chip, OXYGEN_REC_ROUTING,\r\nOXYGEN_REC_C_ROUTE_I2S_ADC_3,\r\nOXYGEN_REC_C_ROUTE_MASK);\r\npcm->private_data = chip;\r\nstrcpy(pcm->name, "Analog 3");\r\nsnd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_DEV,\r\nsnd_dma_pci_data(chip->pci),\r\nDEFAULT_BUFFER_BYTES,\r\nBUFFER_BYTES_MAX);\r\n}\r\nreturn 0;\r\n}
