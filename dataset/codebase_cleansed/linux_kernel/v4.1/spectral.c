static void send_fft_sample(struct ath10k *ar,\r\nconst struct fft_sample_tlv *fft_sample_tlv)\r\n{\r\nint length;\r\nif (!ar->spectral.rfs_chan_spec_scan)\r\nreturn;\r\nlength = __be16_to_cpu(fft_sample_tlv->length) +\r\nsizeof(*fft_sample_tlv);\r\nrelay_write(ar->spectral.rfs_chan_spec_scan, fft_sample_tlv, length);\r\n}\r\nstatic uint8_t get_max_exp(s8 max_index, u16 max_magnitude, size_t bin_len,\r\nu8 *data)\r\n{\r\nint dc_pos;\r\nu8 max_exp;\r\ndc_pos = bin_len / 2;\r\nif (dc_pos < max_index || -dc_pos >= max_index)\r\nreturn 0;\r\nfor (max_exp = 0; max_exp < 8; max_exp++) {\r\nif (data[dc_pos + max_index] == (max_magnitude >> max_exp))\r\nbreak;\r\n}\r\nif (data[dc_pos + max_index] != (max_magnitude >> max_exp))\r\nreturn 0;\r\nreturn max_exp;\r\n}\r\nint ath10k_spectral_process_fft(struct ath10k *ar,\r\nconst struct wmi_phyerr *phyerr,\r\nconst struct phyerr_fft_report *fftr,\r\nsize_t bin_len, u64 tsf)\r\n{\r\nstruct fft_sample_ath10k *fft_sample;\r\nu8 buf[sizeof(*fft_sample) + SPECTRAL_ATH10K_MAX_NUM_BINS];\r\nu16 freq1, freq2, total_gain_db, base_pwr_db, length, peak_mag;\r\nu32 reg0, reg1;\r\nu8 chain_idx, *bins;\r\nint dc_pos;\r\nfft_sample = (struct fft_sample_ath10k *)&buf;\r\nif (bin_len < 64 || bin_len > SPECTRAL_ATH10K_MAX_NUM_BINS)\r\nreturn -EINVAL;\r\nreg0 = __le32_to_cpu(fftr->reg0);\r\nreg1 = __le32_to_cpu(fftr->reg1);\r\nlength = sizeof(*fft_sample) - sizeof(struct fft_sample_tlv) + bin_len;\r\nfft_sample->tlv.type = ATH_FFT_SAMPLE_ATH10K;\r\nfft_sample->tlv.length = __cpu_to_be16(length);\r\nswitch (phyerr->chan_width_mhz) {\r\ncase 20:\r\nfft_sample->chan_width_mhz = 22;\r\nbreak;\r\ncase 40:\r\nfft_sample->chan_width_mhz = 44;\r\nbreak;\r\ncase 80:\r\nif (bin_len == 64)\r\nreturn -EINVAL;\r\nfft_sample->chan_width_mhz = 88;\r\nbreak;\r\ndefault:\r\nfft_sample->chan_width_mhz = phyerr->chan_width_mhz;\r\n}\r\nfft_sample->relpwr_db = MS(reg1, SEARCH_FFT_REPORT_REG1_RELPWR_DB);\r\nfft_sample->avgpwr_db = MS(reg1, SEARCH_FFT_REPORT_REG1_AVGPWR_DB);\r\npeak_mag = MS(reg1, SEARCH_FFT_REPORT_REG1_PEAK_MAG);\r\nfft_sample->max_magnitude = __cpu_to_be16(peak_mag);\r\nfft_sample->max_index = MS(reg0, SEARCH_FFT_REPORT_REG0_PEAK_SIDX);\r\nfft_sample->rssi = phyerr->rssi_combined;\r\ntotal_gain_db = MS(reg0, SEARCH_FFT_REPORT_REG0_TOTAL_GAIN_DB);\r\nbase_pwr_db = MS(reg0, SEARCH_FFT_REPORT_REG0_BASE_PWR_DB);\r\nfft_sample->total_gain_db = __cpu_to_be16(total_gain_db);\r\nfft_sample->base_pwr_db = __cpu_to_be16(base_pwr_db);\r\nfreq1 = __le16_to_cpu(phyerr->freq1);\r\nfreq2 = __le16_to_cpu(phyerr->freq2);\r\nfft_sample->freq1 = __cpu_to_be16(freq1);\r\nfft_sample->freq2 = __cpu_to_be16(freq2);\r\nchain_idx = MS(reg0, SEARCH_FFT_REPORT_REG0_FFT_CHN_IDX);\r\nfft_sample->noise = __cpu_to_be16(\r\n__le16_to_cpu(phyerr->nf_chains[chain_idx]));\r\nbins = (u8 *)fftr;\r\nbins += sizeof(*fftr);\r\nfft_sample->tsf = __cpu_to_be64(tsf);\r\nfft_sample->max_exp = get_max_exp(fft_sample->max_index, peak_mag,\r\nbin_len, bins);\r\nmemcpy(fft_sample->data, bins, bin_len);\r\ndc_pos = bin_len / 2;\r\nfft_sample->data[dc_pos] = (fft_sample->data[dc_pos + 1] +\r\nfft_sample->data[dc_pos - 1]) / 2;\r\nsend_fft_sample(ar, &fft_sample->tlv);\r\nreturn 0;\r\n}\r\nstatic struct ath10k_vif *ath10k_get_spectral_vdev(struct ath10k *ar)\r\n{\r\nstruct ath10k_vif *arvif;\r\nlockdep_assert_held(&ar->conf_mutex);\r\nif (list_empty(&ar->arvifs))\r\nreturn NULL;\r\nlist_for_each_entry(arvif, &ar->arvifs, list)\r\nif (arvif->spectral_enabled)\r\nreturn arvif;\r\nreturn list_first_entry(&ar->arvifs, typeof(*arvif), list);\r\n}\r\nstatic int ath10k_spectral_scan_trigger(struct ath10k *ar)\r\n{\r\nstruct ath10k_vif *arvif;\r\nint res;\r\nint vdev_id;\r\nlockdep_assert_held(&ar->conf_mutex);\r\narvif = ath10k_get_spectral_vdev(ar);\r\nif (!arvif)\r\nreturn -ENODEV;\r\nvdev_id = arvif->vdev_id;\r\nif (ar->spectral.mode == SPECTRAL_DISABLED)\r\nreturn 0;\r\nres = ath10k_wmi_vdev_spectral_enable(ar, vdev_id,\r\nWMI_SPECTRAL_TRIGGER_CMD_CLEAR,\r\nWMI_SPECTRAL_ENABLE_CMD_ENABLE);\r\nif (res < 0)\r\nreturn res;\r\nres = ath10k_wmi_vdev_spectral_enable(ar, vdev_id,\r\nWMI_SPECTRAL_TRIGGER_CMD_TRIGGER,\r\nWMI_SPECTRAL_ENABLE_CMD_ENABLE);\r\nif (res < 0)\r\nreturn res;\r\nreturn 0;\r\n}\r\nstatic int ath10k_spectral_scan_config(struct ath10k *ar,\r\nenum ath10k_spectral_mode mode)\r\n{\r\nstruct wmi_vdev_spectral_conf_arg arg;\r\nstruct ath10k_vif *arvif;\r\nint vdev_id, count, res = 0;\r\nlockdep_assert_held(&ar->conf_mutex);\r\narvif = ath10k_get_spectral_vdev(ar);\r\nif (!arvif)\r\nreturn -ENODEV;\r\nvdev_id = arvif->vdev_id;\r\narvif->spectral_enabled = (mode != SPECTRAL_DISABLED);\r\nar->spectral.mode = mode;\r\nres = ath10k_wmi_vdev_spectral_enable(ar, vdev_id,\r\nWMI_SPECTRAL_TRIGGER_CMD_CLEAR,\r\nWMI_SPECTRAL_ENABLE_CMD_DISABLE);\r\nif (res < 0) {\r\nath10k_warn(ar, "failed to enable spectral scan: %d\n", res);\r\nreturn res;\r\n}\r\nif (mode == SPECTRAL_DISABLED)\r\nreturn 0;\r\nif (mode == SPECTRAL_BACKGROUND)\r\ncount = WMI_SPECTRAL_COUNT_DEFAULT;\r\nelse\r\ncount = max_t(u8, 1, ar->spectral.config.count);\r\narg.vdev_id = vdev_id;\r\narg.scan_count = count;\r\narg.scan_period = WMI_SPECTRAL_PERIOD_DEFAULT;\r\narg.scan_priority = WMI_SPECTRAL_PRIORITY_DEFAULT;\r\narg.scan_fft_size = ar->spectral.config.fft_size;\r\narg.scan_gc_ena = WMI_SPECTRAL_GC_ENA_DEFAULT;\r\narg.scan_restart_ena = WMI_SPECTRAL_RESTART_ENA_DEFAULT;\r\narg.scan_noise_floor_ref = WMI_SPECTRAL_NOISE_FLOOR_REF_DEFAULT;\r\narg.scan_init_delay = WMI_SPECTRAL_INIT_DELAY_DEFAULT;\r\narg.scan_nb_tone_thr = WMI_SPECTRAL_NB_TONE_THR_DEFAULT;\r\narg.scan_str_bin_thr = WMI_SPECTRAL_STR_BIN_THR_DEFAULT;\r\narg.scan_wb_rpt_mode = WMI_SPECTRAL_WB_RPT_MODE_DEFAULT;\r\narg.scan_rssi_rpt_mode = WMI_SPECTRAL_RSSI_RPT_MODE_DEFAULT;\r\narg.scan_rssi_thr = WMI_SPECTRAL_RSSI_THR_DEFAULT;\r\narg.scan_pwr_format = WMI_SPECTRAL_PWR_FORMAT_DEFAULT;\r\narg.scan_rpt_mode = WMI_SPECTRAL_RPT_MODE_DEFAULT;\r\narg.scan_bin_scale = WMI_SPECTRAL_BIN_SCALE_DEFAULT;\r\narg.scan_dbm_adj = WMI_SPECTRAL_DBM_ADJ_DEFAULT;\r\narg.scan_chn_mask = WMI_SPECTRAL_CHN_MASK_DEFAULT;\r\nres = ath10k_wmi_vdev_spectral_conf(ar, &arg);\r\nif (res < 0) {\r\nath10k_warn(ar, "failed to configure spectral scan: %d\n", res);\r\nreturn res;\r\n}\r\nreturn 0;\r\n}\r\nstatic ssize_t read_file_spec_scan_ctl(struct file *file, char __user *user_buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct ath10k *ar = file->private_data;\r\nchar *mode = "";\r\nunsigned int len;\r\nenum ath10k_spectral_mode spectral_mode;\r\nmutex_lock(&ar->conf_mutex);\r\nspectral_mode = ar->spectral.mode;\r\nmutex_unlock(&ar->conf_mutex);\r\nswitch (spectral_mode) {\r\ncase SPECTRAL_DISABLED:\r\nmode = "disable";\r\nbreak;\r\ncase SPECTRAL_BACKGROUND:\r\nmode = "background";\r\nbreak;\r\ncase SPECTRAL_MANUAL:\r\nmode = "manual";\r\nbreak;\r\n}\r\nlen = strlen(mode);\r\nreturn simple_read_from_buffer(user_buf, count, ppos, mode, len);\r\n}\r\nstatic ssize_t write_file_spec_scan_ctl(struct file *file,\r\nconst char __user *user_buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct ath10k *ar = file->private_data;\r\nchar buf[32];\r\nssize_t len;\r\nint res;\r\nlen = min(count, sizeof(buf) - 1);\r\nif (copy_from_user(buf, user_buf, len))\r\nreturn -EFAULT;\r\nbuf[len] = '\0';\r\nmutex_lock(&ar->conf_mutex);\r\nif (strncmp("trigger", buf, 7) == 0) {\r\nif (ar->spectral.mode == SPECTRAL_MANUAL ||\r\nar->spectral.mode == SPECTRAL_BACKGROUND) {\r\nres = ath10k_spectral_scan_config(ar,\r\nar->spectral.mode);\r\nif (res < 0) {\r\nath10k_warn(ar, "failed to reconfigure spectral scan: %d\n",\r\nres);\r\n}\r\nres = ath10k_spectral_scan_trigger(ar);\r\nif (res < 0) {\r\nath10k_warn(ar, "failed to trigger spectral scan: %d\n",\r\nres);\r\n}\r\n} else {\r\nres = -EINVAL;\r\n}\r\n} else if (strncmp("background", buf, 9) == 0) {\r\nres = ath10k_spectral_scan_config(ar, SPECTRAL_BACKGROUND);\r\n} else if (strncmp("manual", buf, 6) == 0) {\r\nres = ath10k_spectral_scan_config(ar, SPECTRAL_MANUAL);\r\n} else if (strncmp("disable", buf, 7) == 0) {\r\nres = ath10k_spectral_scan_config(ar, SPECTRAL_DISABLED);\r\n} else {\r\nres = -EINVAL;\r\n}\r\nmutex_unlock(&ar->conf_mutex);\r\nif (res < 0)\r\nreturn res;\r\nreturn count;\r\n}\r\nstatic ssize_t read_file_spectral_count(struct file *file,\r\nchar __user *user_buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct ath10k *ar = file->private_data;\r\nchar buf[32];\r\nunsigned int len;\r\nu8 spectral_count;\r\nmutex_lock(&ar->conf_mutex);\r\nspectral_count = ar->spectral.config.count;\r\nmutex_unlock(&ar->conf_mutex);\r\nlen = sprintf(buf, "%d\n", spectral_count);\r\nreturn simple_read_from_buffer(user_buf, count, ppos, buf, len);\r\n}\r\nstatic ssize_t write_file_spectral_count(struct file *file,\r\nconst char __user *user_buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct ath10k *ar = file->private_data;\r\nunsigned long val;\r\nchar buf[32];\r\nssize_t len;\r\nlen = min(count, sizeof(buf) - 1);\r\nif (copy_from_user(buf, user_buf, len))\r\nreturn -EFAULT;\r\nbuf[len] = '\0';\r\nif (kstrtoul(buf, 0, &val))\r\nreturn -EINVAL;\r\nif (val < 0 || val > 255)\r\nreturn -EINVAL;\r\nmutex_lock(&ar->conf_mutex);\r\nar->spectral.config.count = val;\r\nmutex_unlock(&ar->conf_mutex);\r\nreturn count;\r\n}\r\nstatic ssize_t read_file_spectral_bins(struct file *file,\r\nchar __user *user_buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct ath10k *ar = file->private_data;\r\nchar buf[32];\r\nunsigned int len, bins, fft_size, bin_scale;\r\nmutex_lock(&ar->conf_mutex);\r\nfft_size = ar->spectral.config.fft_size;\r\nbin_scale = WMI_SPECTRAL_BIN_SCALE_DEFAULT;\r\nbins = 1 << (fft_size - bin_scale);\r\nmutex_unlock(&ar->conf_mutex);\r\nlen = sprintf(buf, "%d\n", bins);\r\nreturn simple_read_from_buffer(user_buf, count, ppos, buf, len);\r\n}\r\nstatic ssize_t write_file_spectral_bins(struct file *file,\r\nconst char __user *user_buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct ath10k *ar = file->private_data;\r\nunsigned long val;\r\nchar buf[32];\r\nssize_t len;\r\nlen = min(count, sizeof(buf) - 1);\r\nif (copy_from_user(buf, user_buf, len))\r\nreturn -EFAULT;\r\nbuf[len] = '\0';\r\nif (kstrtoul(buf, 0, &val))\r\nreturn -EINVAL;\r\nif (val < 64 || val > SPECTRAL_ATH10K_MAX_NUM_BINS)\r\nreturn -EINVAL;\r\nif (!is_power_of_2(val))\r\nreturn -EINVAL;\r\nmutex_lock(&ar->conf_mutex);\r\nar->spectral.config.fft_size = ilog2(val);\r\nar->spectral.config.fft_size += WMI_SPECTRAL_BIN_SCALE_DEFAULT;\r\nmutex_unlock(&ar->conf_mutex);\r\nreturn count;\r\n}\r\nstatic struct dentry *create_buf_file_handler(const char *filename,\r\nstruct dentry *parent,\r\numode_t mode,\r\nstruct rchan_buf *buf,\r\nint *is_global)\r\n{\r\nstruct dentry *buf_file;\r\nbuf_file = debugfs_create_file(filename, mode, parent, buf,\r\n&relay_file_operations);\r\n*is_global = 1;\r\nreturn buf_file;\r\n}\r\nstatic int remove_buf_file_handler(struct dentry *dentry)\r\n{\r\ndebugfs_remove(dentry);\r\nreturn 0;\r\n}\r\nint ath10k_spectral_start(struct ath10k *ar)\r\n{\r\nstruct ath10k_vif *arvif;\r\nlockdep_assert_held(&ar->conf_mutex);\r\nlist_for_each_entry(arvif, &ar->arvifs, list)\r\narvif->spectral_enabled = 0;\r\nar->spectral.mode = SPECTRAL_DISABLED;\r\nar->spectral.config.count = WMI_SPECTRAL_COUNT_DEFAULT;\r\nar->spectral.config.fft_size = WMI_SPECTRAL_FFT_SIZE_DEFAULT;\r\nreturn 0;\r\n}\r\nint ath10k_spectral_vif_stop(struct ath10k_vif *arvif)\r\n{\r\nif (!arvif->spectral_enabled)\r\nreturn 0;\r\nreturn ath10k_spectral_scan_config(arvif->ar, SPECTRAL_DISABLED);\r\n}\r\nint ath10k_spectral_create(struct ath10k *ar)\r\n{\r\nar->spectral.rfs_chan_spec_scan = relay_open("spectral_scan",\r\nar->debug.debugfs_phy,\r\n1024, 256,\r\n&rfs_spec_scan_cb, NULL);\r\ndebugfs_create_file("spectral_scan_ctl",\r\nS_IRUSR | S_IWUSR,\r\nar->debug.debugfs_phy, ar,\r\n&fops_spec_scan_ctl);\r\ndebugfs_create_file("spectral_count",\r\nS_IRUSR | S_IWUSR,\r\nar->debug.debugfs_phy, ar,\r\n&fops_spectral_count);\r\ndebugfs_create_file("spectral_bins",\r\nS_IRUSR | S_IWUSR,\r\nar->debug.debugfs_phy, ar,\r\n&fops_spectral_bins);\r\nreturn 0;\r\n}\r\nvoid ath10k_spectral_destroy(struct ath10k *ar)\r\n{\r\nif (ar->spectral.rfs_chan_spec_scan) {\r\nrelay_close(ar->spectral.rfs_chan_spec_scan);\r\nar->spectral.rfs_chan_spec_scan = NULL;\r\n}\r\n}
