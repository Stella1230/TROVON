static inline int raw_cpu_to_cluster(int cpu)\r\n{\r\nreturn topology_physical_package_id(cpu);\r\n}\r\nstatic inline int cpu_to_cluster(int cpu)\r\n{\r\nreturn is_bL_switching_enabled() ?\r\nMAX_CLUSTERS : raw_cpu_to_cluster(cpu);\r\n}\r\nstatic unsigned int find_cluster_maxfreq(int cluster)\r\n{\r\nint j;\r\nu32 max_freq = 0, cpu_freq;\r\nfor_each_online_cpu(j) {\r\ncpu_freq = per_cpu(cpu_last_req_freq, j);\r\nif ((cluster == per_cpu(physical_cluster, j)) &&\r\n(max_freq < cpu_freq))\r\nmax_freq = cpu_freq;\r\n}\r\npr_debug("%s: cluster: %d, max freq: %d\n", __func__, cluster,\r\nmax_freq);\r\nreturn max_freq;\r\n}\r\nstatic unsigned int clk_get_cpu_rate(unsigned int cpu)\r\n{\r\nu32 cur_cluster = per_cpu(physical_cluster, cpu);\r\nu32 rate = clk_get_rate(clk[cur_cluster]) / 1000;\r\nif (is_bL_switching_enabled())\r\nrate = VIRT_FREQ(cur_cluster, rate);\r\npr_debug("%s: cpu: %d, cluster: %d, freq: %u\n", __func__, cpu,\r\ncur_cluster, rate);\r\nreturn rate;\r\n}\r\nstatic unsigned int bL_cpufreq_get_rate(unsigned int cpu)\r\n{\r\nif (is_bL_switching_enabled()) {\r\npr_debug("%s: freq: %d\n", __func__, per_cpu(cpu_last_req_freq,\r\ncpu));\r\nreturn per_cpu(cpu_last_req_freq, cpu);\r\n} else {\r\nreturn clk_get_cpu_rate(cpu);\r\n}\r\n}\r\nstatic unsigned int\r\nbL_cpufreq_set_rate(u32 cpu, u32 old_cluster, u32 new_cluster, u32 rate)\r\n{\r\nu32 new_rate, prev_rate;\r\nint ret;\r\nbool bLs = is_bL_switching_enabled();\r\nmutex_lock(&cluster_lock[new_cluster]);\r\nif (bLs) {\r\nprev_rate = per_cpu(cpu_last_req_freq, cpu);\r\nper_cpu(cpu_last_req_freq, cpu) = rate;\r\nper_cpu(physical_cluster, cpu) = new_cluster;\r\nnew_rate = find_cluster_maxfreq(new_cluster);\r\nnew_rate = ACTUAL_FREQ(new_cluster, new_rate);\r\n} else {\r\nnew_rate = rate;\r\n}\r\npr_debug("%s: cpu: %d, old cluster: %d, new cluster: %d, freq: %d\n",\r\n__func__, cpu, old_cluster, new_cluster, new_rate);\r\nret = clk_set_rate(clk[new_cluster], new_rate * 1000);\r\nif (WARN_ON(ret)) {\r\npr_err("clk_set_rate failed: %d, new cluster: %d\n", ret,\r\nnew_cluster);\r\nif (bLs) {\r\nper_cpu(cpu_last_req_freq, cpu) = prev_rate;\r\nper_cpu(physical_cluster, cpu) = old_cluster;\r\n}\r\nmutex_unlock(&cluster_lock[new_cluster]);\r\nreturn ret;\r\n}\r\nmutex_unlock(&cluster_lock[new_cluster]);\r\nif (old_cluster != new_cluster) {\r\npr_debug("%s: cpu: %d, old cluster: %d, new cluster: %d\n",\r\n__func__, cpu, old_cluster, new_cluster);\r\nbL_switch_request(cpu, new_cluster);\r\nmutex_lock(&cluster_lock[old_cluster]);\r\nnew_rate = find_cluster_maxfreq(old_cluster);\r\nnew_rate = ACTUAL_FREQ(old_cluster, new_rate);\r\nif (new_rate) {\r\npr_debug("%s: Updating rate of old cluster: %d, to freq: %d\n",\r\n__func__, old_cluster, new_rate);\r\nif (clk_set_rate(clk[old_cluster], new_rate * 1000))\r\npr_err("%s: clk_set_rate failed: %d, old cluster: %d\n",\r\n__func__, ret, old_cluster);\r\n}\r\nmutex_unlock(&cluster_lock[old_cluster]);\r\n}\r\nreturn 0;\r\n}\r\nstatic int bL_cpufreq_set_target(struct cpufreq_policy *policy,\r\nunsigned int index)\r\n{\r\nu32 cpu = policy->cpu, cur_cluster, new_cluster, actual_cluster;\r\nunsigned int freqs_new;\r\ncur_cluster = cpu_to_cluster(cpu);\r\nnew_cluster = actual_cluster = per_cpu(physical_cluster, cpu);\r\nfreqs_new = freq_table[cur_cluster][index].frequency;\r\nif (is_bL_switching_enabled()) {\r\nif ((actual_cluster == A15_CLUSTER) &&\r\n(freqs_new < clk_big_min)) {\r\nnew_cluster = A7_CLUSTER;\r\n} else if ((actual_cluster == A7_CLUSTER) &&\r\n(freqs_new > clk_little_max)) {\r\nnew_cluster = A15_CLUSTER;\r\n}\r\n}\r\nreturn bL_cpufreq_set_rate(cpu, actual_cluster, new_cluster, freqs_new);\r\n}\r\nstatic inline u32 get_table_count(struct cpufreq_frequency_table *table)\r\n{\r\nint count;\r\nfor (count = 0; table[count].frequency != CPUFREQ_TABLE_END; count++)\r\n;\r\nreturn count;\r\n}\r\nstatic inline u32 get_table_min(struct cpufreq_frequency_table *table)\r\n{\r\nstruct cpufreq_frequency_table *pos;\r\nuint32_t min_freq = ~0;\r\ncpufreq_for_each_entry(pos, table)\r\nif (pos->frequency < min_freq)\r\nmin_freq = pos->frequency;\r\nreturn min_freq;\r\n}\r\nstatic inline u32 get_table_max(struct cpufreq_frequency_table *table)\r\n{\r\nstruct cpufreq_frequency_table *pos;\r\nuint32_t max_freq = 0;\r\ncpufreq_for_each_entry(pos, table)\r\nif (pos->frequency > max_freq)\r\nmax_freq = pos->frequency;\r\nreturn max_freq;\r\n}\r\nstatic int merge_cluster_tables(void)\r\n{\r\nint i, j, k = 0, count = 1;\r\nstruct cpufreq_frequency_table *table;\r\nfor (i = 0; i < MAX_CLUSTERS; i++)\r\ncount += get_table_count(freq_table[i]);\r\ntable = kzalloc(sizeof(*table) * count, GFP_KERNEL);\r\nif (!table)\r\nreturn -ENOMEM;\r\nfreq_table[MAX_CLUSTERS] = table;\r\nfor (i = MAX_CLUSTERS - 1; i >= 0; i--) {\r\nfor (j = 0; freq_table[i][j].frequency != CPUFREQ_TABLE_END;\r\nj++) {\r\ntable[k].frequency = VIRT_FREQ(i,\r\nfreq_table[i][j].frequency);\r\npr_debug("%s: index: %d, freq: %d\n", __func__, k,\r\ntable[k].frequency);\r\nk++;\r\n}\r\n}\r\ntable[k].driver_data = k;\r\ntable[k].frequency = CPUFREQ_TABLE_END;\r\npr_debug("%s: End, table: %p, count: %d\n", __func__, table, k);\r\nreturn 0;\r\n}\r\nstatic void _put_cluster_clk_and_freq_table(struct device *cpu_dev)\r\n{\r\nu32 cluster = raw_cpu_to_cluster(cpu_dev->id);\r\nif (!freq_table[cluster])\r\nreturn;\r\nclk_put(clk[cluster]);\r\ndev_pm_opp_free_cpufreq_table(cpu_dev, &freq_table[cluster]);\r\nif (arm_bL_ops->free_opp_table)\r\narm_bL_ops->free_opp_table(cpu_dev);\r\ndev_dbg(cpu_dev, "%s: cluster: %d\n", __func__, cluster);\r\n}\r\nstatic void put_cluster_clk_and_freq_table(struct device *cpu_dev)\r\n{\r\nu32 cluster = cpu_to_cluster(cpu_dev->id);\r\nint i;\r\nif (atomic_dec_return(&cluster_usage[cluster]))\r\nreturn;\r\nif (cluster < MAX_CLUSTERS)\r\nreturn _put_cluster_clk_and_freq_table(cpu_dev);\r\nfor_each_present_cpu(i) {\r\nstruct device *cdev = get_cpu_device(i);\r\nif (!cdev) {\r\npr_err("%s: failed to get cpu%d device\n", __func__, i);\r\nreturn;\r\n}\r\n_put_cluster_clk_and_freq_table(cdev);\r\n}\r\nkfree(freq_table[cluster]);\r\n}\r\nstatic int _get_cluster_clk_and_freq_table(struct device *cpu_dev)\r\n{\r\nu32 cluster = raw_cpu_to_cluster(cpu_dev->id);\r\nchar name[14] = "cpu-cluster.";\r\nint ret;\r\nif (freq_table[cluster])\r\nreturn 0;\r\nret = arm_bL_ops->init_opp_table(cpu_dev);\r\nif (ret) {\r\ndev_err(cpu_dev, "%s: init_opp_table failed, cpu: %d, err: %d\n",\r\n__func__, cpu_dev->id, ret);\r\ngoto out;\r\n}\r\nret = dev_pm_opp_init_cpufreq_table(cpu_dev, &freq_table[cluster]);\r\nif (ret) {\r\ndev_err(cpu_dev, "%s: failed to init cpufreq table, cpu: %d, err: %d\n",\r\n__func__, cpu_dev->id, ret);\r\ngoto free_opp_table;\r\n}\r\nname[12] = cluster + '0';\r\nclk[cluster] = clk_get(cpu_dev, name);\r\nif (!IS_ERR(clk[cluster])) {\r\ndev_dbg(cpu_dev, "%s: clk: %p & freq table: %p, cluster: %d\n",\r\n__func__, clk[cluster], freq_table[cluster],\r\ncluster);\r\nreturn 0;\r\n}\r\ndev_err(cpu_dev, "%s: Failed to get clk for cpu: %d, cluster: %d\n",\r\n__func__, cpu_dev->id, cluster);\r\nret = PTR_ERR(clk[cluster]);\r\ndev_pm_opp_free_cpufreq_table(cpu_dev, &freq_table[cluster]);\r\nfree_opp_table:\r\nif (arm_bL_ops->free_opp_table)\r\narm_bL_ops->free_opp_table(cpu_dev);\r\nout:\r\ndev_err(cpu_dev, "%s: Failed to get data for cluster: %d\n", __func__,\r\ncluster);\r\nreturn ret;\r\n}\r\nstatic int get_cluster_clk_and_freq_table(struct device *cpu_dev)\r\n{\r\nu32 cluster = cpu_to_cluster(cpu_dev->id);\r\nint i, ret;\r\nif (atomic_inc_return(&cluster_usage[cluster]) != 1)\r\nreturn 0;\r\nif (cluster < MAX_CLUSTERS) {\r\nret = _get_cluster_clk_and_freq_table(cpu_dev);\r\nif (ret)\r\natomic_dec(&cluster_usage[cluster]);\r\nreturn ret;\r\n}\r\nfor_each_present_cpu(i) {\r\nstruct device *cdev = get_cpu_device(i);\r\nif (!cdev) {\r\npr_err("%s: failed to get cpu%d device\n", __func__, i);\r\nreturn -ENODEV;\r\n}\r\nret = _get_cluster_clk_and_freq_table(cdev);\r\nif (ret)\r\ngoto put_clusters;\r\n}\r\nret = merge_cluster_tables();\r\nif (ret)\r\ngoto put_clusters;\r\nclk_big_min = get_table_min(freq_table[0]);\r\nclk_little_max = VIRT_FREQ(1, get_table_max(freq_table[1]));\r\npr_debug("%s: cluster: %d, clk_big_min: %d, clk_little_max: %d\n",\r\n__func__, cluster, clk_big_min, clk_little_max);\r\nreturn 0;\r\nput_clusters:\r\nfor_each_present_cpu(i) {\r\nstruct device *cdev = get_cpu_device(i);\r\nif (!cdev) {\r\npr_err("%s: failed to get cpu%d device\n", __func__, i);\r\nreturn -ENODEV;\r\n}\r\n_put_cluster_clk_and_freq_table(cdev);\r\n}\r\natomic_dec(&cluster_usage[cluster]);\r\nreturn ret;\r\n}\r\nstatic int bL_cpufreq_init(struct cpufreq_policy *policy)\r\n{\r\nu32 cur_cluster = cpu_to_cluster(policy->cpu);\r\nstruct device *cpu_dev;\r\nint ret;\r\ncpu_dev = get_cpu_device(policy->cpu);\r\nif (!cpu_dev) {\r\npr_err("%s: failed to get cpu%d device\n", __func__,\r\npolicy->cpu);\r\nreturn -ENODEV;\r\n}\r\nret = get_cluster_clk_and_freq_table(cpu_dev);\r\nif (ret)\r\nreturn ret;\r\nret = cpufreq_table_validate_and_show(policy, freq_table[cur_cluster]);\r\nif (ret) {\r\ndev_err(cpu_dev, "CPU %d, cluster: %d invalid freq table\n",\r\npolicy->cpu, cur_cluster);\r\nput_cluster_clk_and_freq_table(cpu_dev);\r\nreturn ret;\r\n}\r\nif (cur_cluster < MAX_CLUSTERS) {\r\nint cpu;\r\ncpumask_copy(policy->cpus, topology_core_cpumask(policy->cpu));\r\nfor_each_cpu(cpu, policy->cpus)\r\nper_cpu(physical_cluster, cpu) = cur_cluster;\r\n} else {\r\nper_cpu(physical_cluster, policy->cpu) = A15_CLUSTER;\r\n}\r\nif (arm_bL_ops->get_transition_latency)\r\npolicy->cpuinfo.transition_latency =\r\narm_bL_ops->get_transition_latency(cpu_dev);\r\nelse\r\npolicy->cpuinfo.transition_latency = CPUFREQ_ETERNAL;\r\nif (is_bL_switching_enabled())\r\nper_cpu(cpu_last_req_freq, policy->cpu) = clk_get_cpu_rate(policy->cpu);\r\ndev_info(cpu_dev, "%s: CPU %d initialized\n", __func__, policy->cpu);\r\nreturn 0;\r\n}\r\nstatic int bL_cpufreq_exit(struct cpufreq_policy *policy)\r\n{\r\nstruct device *cpu_dev;\r\ncpu_dev = get_cpu_device(policy->cpu);\r\nif (!cpu_dev) {\r\npr_err("%s: failed to get cpu%d device\n", __func__,\r\npolicy->cpu);\r\nreturn -ENODEV;\r\n}\r\nput_cluster_clk_and_freq_table(cpu_dev);\r\ndev_dbg(cpu_dev, "%s: Exited, cpu: %d\n", __func__, policy->cpu);\r\nreturn 0;\r\n}\r\nstatic int bL_cpufreq_switcher_notifier(struct notifier_block *nfb,\r\nunsigned long action, void *_arg)\r\n{\r\npr_debug("%s: action: %ld\n", __func__, action);\r\nswitch (action) {\r\ncase BL_NOTIFY_PRE_ENABLE:\r\ncase BL_NOTIFY_PRE_DISABLE:\r\ncpufreq_unregister_driver(&bL_cpufreq_driver);\r\nbreak;\r\ncase BL_NOTIFY_POST_ENABLE:\r\nset_switching_enabled(true);\r\ncpufreq_register_driver(&bL_cpufreq_driver);\r\nbreak;\r\ncase BL_NOTIFY_POST_DISABLE:\r\nset_switching_enabled(false);\r\ncpufreq_register_driver(&bL_cpufreq_driver);\r\nbreak;\r\ndefault:\r\nreturn NOTIFY_DONE;\r\n}\r\nreturn NOTIFY_OK;\r\n}\r\nint bL_cpufreq_register(struct cpufreq_arm_bL_ops *ops)\r\n{\r\nint ret, i;\r\nif (arm_bL_ops) {\r\npr_debug("%s: Already registered: %s, exiting\n", __func__,\r\narm_bL_ops->name);\r\nreturn -EBUSY;\r\n}\r\nif (!ops || !strlen(ops->name) || !ops->init_opp_table) {\r\npr_err("%s: Invalid arm_bL_ops, exiting\n", __func__);\r\nreturn -ENODEV;\r\n}\r\narm_bL_ops = ops;\r\nret = bL_switcher_get_enabled();\r\nset_switching_enabled(ret);\r\nfor (i = 0; i < MAX_CLUSTERS; i++)\r\nmutex_init(&cluster_lock[i]);\r\nret = cpufreq_register_driver(&bL_cpufreq_driver);\r\nif (ret) {\r\npr_info("%s: Failed registering platform driver: %s, err: %d\n",\r\n__func__, ops->name, ret);\r\narm_bL_ops = NULL;\r\n} else {\r\nret = bL_switcher_register_notifier(&bL_switcher_notifier);\r\nif (ret) {\r\ncpufreq_unregister_driver(&bL_cpufreq_driver);\r\narm_bL_ops = NULL;\r\n} else {\r\npr_info("%s: Registered platform driver: %s\n",\r\n__func__, ops->name);\r\n}\r\n}\r\nbL_switcher_put_enabled();\r\nreturn ret;\r\n}\r\nvoid bL_cpufreq_unregister(struct cpufreq_arm_bL_ops *ops)\r\n{\r\nif (arm_bL_ops != ops) {\r\npr_err("%s: Registered with: %s, can't unregister, exiting\n",\r\n__func__, arm_bL_ops->name);\r\nreturn;\r\n}\r\nbL_switcher_get_enabled();\r\nbL_switcher_unregister_notifier(&bL_switcher_notifier);\r\ncpufreq_unregister_driver(&bL_cpufreq_driver);\r\nbL_switcher_put_enabled();\r\npr_info("%s: Un-registered platform driver: %s\n", __func__,\r\narm_bL_ops->name);\r\narm_bL_ops = NULL;\r\n}
