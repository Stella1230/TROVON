static inline struct spear_snor_flash *get_flash_data(struct mtd_info *mtd)\r\n{\r\nreturn container_of(mtd, struct spear_snor_flash, mtd);\r\n}\r\nstatic int spear_smi_read_sr(struct spear_smi *dev, u32 bank)\r\n{\r\nint ret;\r\nu32 ctrlreg1;\r\nmutex_lock(&dev->lock);\r\ndev->status = 0;\r\nctrlreg1 = readl(dev->io_base + SMI_CR1);\r\nwritel(ctrlreg1 & ~(SW_MODE | WB_MODE), dev->io_base + SMI_CR1);\r\nwritel((bank << BANK_SHIFT) | RD_STATUS_REG | TFIE,\r\ndev->io_base + SMI_CR2);\r\nret = wait_event_interruptible_timeout(dev->cmd_complete,\r\ndev->status & TFF, SMI_CMD_TIMEOUT);\r\nif (ret > 0)\r\nret = dev->status & 0xffff;\r\nelse if (ret == 0)\r\nret = -ETIMEDOUT;\r\nwritel(ctrlreg1, dev->io_base + SMI_CR1);\r\nwritel(0, dev->io_base + SMI_CR2);\r\nmutex_unlock(&dev->lock);\r\nreturn ret;\r\n}\r\nstatic int spear_smi_wait_till_ready(struct spear_smi *dev, u32 bank,\r\nunsigned long timeout)\r\n{\r\nunsigned long finish;\r\nint status;\r\nfinish = jiffies + timeout;\r\ndo {\r\nstatus = spear_smi_read_sr(dev, bank);\r\nif (status < 0) {\r\nif (status == -ETIMEDOUT)\r\ncontinue;\r\nreturn status;\r\n} else if (!(status & SR_WIP)) {\r\nreturn 0;\r\n}\r\ncond_resched();\r\n} while (!time_after_eq(jiffies, finish));\r\ndev_err(&dev->pdev->dev, "smi controller is busy, timeout\n");\r\nreturn -EBUSY;\r\n}\r\nstatic irqreturn_t spear_smi_int_handler(int irq, void *dev_id)\r\n{\r\nu32 status = 0;\r\nstruct spear_smi *dev = dev_id;\r\nstatus = readl(dev->io_base + SMI_SR);\r\nif (unlikely(!status))\r\nreturn IRQ_NONE;\r\nwritel(0, dev->io_base + SMI_SR);\r\ndev->status |= status;\r\nwake_up_interruptible(&dev->cmd_complete);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void spear_smi_hw_init(struct spear_smi *dev)\r\n{\r\nunsigned long rate = 0;\r\nu32 prescale = 0;\r\nu32 val;\r\nrate = clk_get_rate(dev->clk);\r\nprescale = DIV_ROUND_UP(rate, dev->clk_rate);\r\nval = HOLD1 | BANK_EN | DSEL_TIME | (prescale << 8);\r\nmutex_lock(&dev->lock);\r\nwritel(0, dev->io_base + SMI_SR);\r\nwritel(val, dev->io_base + SMI_CR1);\r\nmutex_unlock(&dev->lock);\r\n}\r\nstatic int get_flash_index(u32 flash_id)\r\n{\r\nint index;\r\nfor (index = 0; index < ARRAY_SIZE(flash_devices); index++) {\r\nif (flash_devices[index].device_id == flash_id)\r\nreturn index;\r\n}\r\nreturn -ENODEV;\r\n}\r\nstatic int spear_smi_write_enable(struct spear_smi *dev, u32 bank)\r\n{\r\nint ret;\r\nu32 ctrlreg1;\r\nmutex_lock(&dev->lock);\r\ndev->status = 0;\r\nctrlreg1 = readl(dev->io_base + SMI_CR1);\r\nwritel(ctrlreg1 & ~SW_MODE, dev->io_base + SMI_CR1);\r\nwritel((bank << BANK_SHIFT) | WE | TFIE, dev->io_base + SMI_CR2);\r\nret = wait_event_interruptible_timeout(dev->cmd_complete,\r\ndev->status & TFF, SMI_CMD_TIMEOUT);\r\nwritel(ctrlreg1, dev->io_base + SMI_CR1);\r\nwritel(0, dev->io_base + SMI_CR2);\r\nif (ret == 0) {\r\nret = -EIO;\r\ndev_err(&dev->pdev->dev,\r\n"smi controller failed on write enable\n");\r\n} else if (ret > 0) {\r\nif (dev->status & (1 << (bank + WM_SHIFT)))\r\nret = 0;\r\nelse {\r\ndev_err(&dev->pdev->dev, "couldn't enable write\n");\r\nret = -EIO;\r\n}\r\n}\r\nmutex_unlock(&dev->lock);\r\nreturn ret;\r\n}\r\nstatic inline u32\r\nget_sector_erase_cmd(struct spear_snor_flash *flash, u32 offset)\r\n{\r\nu32 cmd;\r\nu8 *x = (u8 *)&cmd;\r\nx[0] = flash->erase_cmd;\r\nx[1] = offset >> 16;\r\nx[2] = offset >> 8;\r\nx[3] = offset;\r\nreturn cmd;\r\n}\r\nstatic int spear_smi_erase_sector(struct spear_smi *dev,\r\nu32 bank, u32 command, u32 bytes)\r\n{\r\nu32 ctrlreg1 = 0;\r\nint ret;\r\nret = spear_smi_wait_till_ready(dev, bank, SMI_MAX_TIME_OUT);\r\nif (ret)\r\nreturn ret;\r\nret = spear_smi_write_enable(dev, bank);\r\nif (ret)\r\nreturn ret;\r\nmutex_lock(&dev->lock);\r\nctrlreg1 = readl(dev->io_base + SMI_CR1);\r\nwritel((ctrlreg1 | SW_MODE) & ~WB_MODE, dev->io_base + SMI_CR1);\r\nwritel(command, dev->io_base + SMI_TR);\r\nwritel((bank << BANK_SHIFT) | SEND | TFIE | (bytes << TX_LEN_SHIFT),\r\ndev->io_base + SMI_CR2);\r\nret = wait_event_interruptible_timeout(dev->cmd_complete,\r\ndev->status & TFF, SMI_CMD_TIMEOUT);\r\nif (ret == 0) {\r\nret = -EIO;\r\ndev_err(&dev->pdev->dev, "sector erase failed\n");\r\n} else if (ret > 0)\r\nret = 0;\r\nwritel(ctrlreg1, dev->io_base + SMI_CR1);\r\nwritel(0, dev->io_base + SMI_CR2);\r\nmutex_unlock(&dev->lock);\r\nreturn ret;\r\n}\r\nstatic int spear_mtd_erase(struct mtd_info *mtd, struct erase_info *e_info)\r\n{\r\nstruct spear_snor_flash *flash = get_flash_data(mtd);\r\nstruct spear_smi *dev = mtd->priv;\r\nu32 addr, command, bank;\r\nint len, ret;\r\nif (!flash || !dev)\r\nreturn -ENODEV;\r\nbank = flash->bank;\r\nif (bank > dev->num_flashes - 1) {\r\ndev_err(&dev->pdev->dev, "Invalid Bank Num");\r\nreturn -EINVAL;\r\n}\r\naddr = e_info->addr;\r\nlen = e_info->len;\r\nmutex_lock(&flash->lock);\r\nwhile (len) {\r\ncommand = get_sector_erase_cmd(flash, addr);\r\nret = spear_smi_erase_sector(dev, bank, command, 4);\r\nif (ret) {\r\ne_info->state = MTD_ERASE_FAILED;\r\nmutex_unlock(&flash->lock);\r\nreturn ret;\r\n}\r\naddr += mtd->erasesize;\r\nlen -= mtd->erasesize;\r\n}\r\nmutex_unlock(&flash->lock);\r\ne_info->state = MTD_ERASE_DONE;\r\nmtd_erase_callback(e_info);\r\nreturn 0;\r\n}\r\nstatic int spear_mtd_read(struct mtd_info *mtd, loff_t from, size_t len,\r\nsize_t *retlen, u8 *buf)\r\n{\r\nstruct spear_snor_flash *flash = get_flash_data(mtd);\r\nstruct spear_smi *dev = mtd->priv;\r\nvoid __iomem *src;\r\nu32 ctrlreg1, val;\r\nint ret;\r\nif (!flash || !dev)\r\nreturn -ENODEV;\r\nif (flash->bank > dev->num_flashes - 1) {\r\ndev_err(&dev->pdev->dev, "Invalid Bank Num");\r\nreturn -EINVAL;\r\n}\r\nsrc = flash->base_addr + from;\r\nmutex_lock(&flash->lock);\r\nret = spear_smi_wait_till_ready(dev, flash->bank, SMI_MAX_TIME_OUT);\r\nif (ret) {\r\nmutex_unlock(&flash->lock);\r\nreturn ret;\r\n}\r\nmutex_lock(&dev->lock);\r\nctrlreg1 = val = readl(dev->io_base + SMI_CR1);\r\nval &= ~(SW_MODE | WB_MODE);\r\nif (flash->fast_mode)\r\nval |= FAST_MODE;\r\nwritel(val, dev->io_base + SMI_CR1);\r\nmemcpy_fromio(buf, src, len);\r\nwritel(ctrlreg1, dev->io_base + SMI_CR1);\r\nmutex_unlock(&dev->lock);\r\n*retlen = len;\r\nmutex_unlock(&flash->lock);\r\nreturn 0;\r\n}\r\nstatic inline int spear_smi_cpy_toio(struct spear_smi *dev, u32 bank,\r\nvoid __iomem *dest, const void *src, size_t len)\r\n{\r\nint ret;\r\nu32 ctrlreg1;\r\nret = spear_smi_wait_till_ready(dev, bank, SMI_MAX_TIME_OUT);\r\nif (ret)\r\nreturn ret;\r\nret = spear_smi_write_enable(dev, bank);\r\nif (ret)\r\nreturn ret;\r\nmutex_lock(&dev->lock);\r\nctrlreg1 = readl(dev->io_base + SMI_CR1);\r\nwritel((ctrlreg1 | WB_MODE) & ~SW_MODE, dev->io_base + SMI_CR1);\r\nmemcpy_toio(dest, src, len);\r\nwritel(ctrlreg1, dev->io_base + SMI_CR1);\r\nmutex_unlock(&dev->lock);\r\nreturn 0;\r\n}\r\nstatic int spear_mtd_write(struct mtd_info *mtd, loff_t to, size_t len,\r\nsize_t *retlen, const u8 *buf)\r\n{\r\nstruct spear_snor_flash *flash = get_flash_data(mtd);\r\nstruct spear_smi *dev = mtd->priv;\r\nvoid __iomem *dest;\r\nu32 page_offset, page_size;\r\nint ret;\r\nif (!flash || !dev)\r\nreturn -ENODEV;\r\nif (flash->bank > dev->num_flashes - 1) {\r\ndev_err(&dev->pdev->dev, "Invalid Bank Num");\r\nreturn -EINVAL;\r\n}\r\ndest = flash->base_addr + to;\r\nmutex_lock(&flash->lock);\r\npage_offset = (u32)to % flash->page_size;\r\nif (page_offset + len <= flash->page_size) {\r\nret = spear_smi_cpy_toio(dev, flash->bank, dest, buf, len);\r\nif (!ret)\r\n*retlen += len;\r\n} else {\r\nu32 i;\r\npage_size = flash->page_size - page_offset;\r\nret = spear_smi_cpy_toio(dev, flash->bank, dest, buf,\r\npage_size);\r\nif (ret)\r\ngoto err_write;\r\nelse\r\n*retlen += page_size;\r\nfor (i = page_size; i < len; i += page_size) {\r\npage_size = len - i;\r\nif (page_size > flash->page_size)\r\npage_size = flash->page_size;\r\nret = spear_smi_cpy_toio(dev, flash->bank, dest + i,\r\nbuf + i, page_size);\r\nif (ret)\r\nbreak;\r\nelse\r\n*retlen += page_size;\r\n}\r\n}\r\nerr_write:\r\nmutex_unlock(&flash->lock);\r\nreturn ret;\r\n}\r\nstatic int spear_smi_probe_flash(struct spear_smi *dev, u32 bank)\r\n{\r\nint ret;\r\nu32 val = 0;\r\nret = spear_smi_wait_till_ready(dev, bank, SMI_PROBE_TIMEOUT);\r\nif (ret)\r\nreturn ret;\r\nmutex_lock(&dev->lock);\r\ndev->status = 0;\r\nval = readl(dev->io_base + SMI_CR1);\r\nwritel(val | SW_MODE, dev->io_base + SMI_CR1);\r\nwritel(OPCODE_RDID, dev->io_base + SMI_TR);\r\nval = (bank << BANK_SHIFT) | SEND | (1 << TX_LEN_SHIFT) |\r\n(3 << RX_LEN_SHIFT) | TFIE;\r\nwritel(val, dev->io_base + SMI_CR2);\r\nret = wait_event_interruptible_timeout(dev->cmd_complete,\r\ndev->status & TFF, SMI_CMD_TIMEOUT);\r\nif (ret <= 0) {\r\nret = -ENODEV;\r\ngoto err_probe;\r\n}\r\nval = readl(dev->io_base + SMI_RR);\r\nval &= 0x00ffffff;\r\nret = get_flash_index(val);\r\nerr_probe:\r\nval = readl(dev->io_base + SMI_CR1);\r\nwritel(val & ~SW_MODE, dev->io_base + SMI_CR1);\r\nmutex_unlock(&dev->lock);\r\nreturn ret;\r\n}\r\nstatic int spear_smi_probe_config_dt(struct platform_device *pdev,\r\nstruct device_node *np)\r\n{\r\nstruct spear_smi_plat_data *pdata = dev_get_platdata(&pdev->dev);\r\nstruct device_node *pp = NULL;\r\nconst __be32 *addr;\r\nu32 val;\r\nint len;\r\nint i = 0;\r\nif (!np)\r\nreturn -ENODEV;\r\nof_property_read_u32(np, "clock-rate", &val);\r\npdata->clk_rate = val;\r\npdata->board_flash_info = devm_kzalloc(&pdev->dev,\r\nsizeof(*pdata->board_flash_info),\r\nGFP_KERNEL);\r\nwhile ((pp = of_get_next_child(np, pp))) {\r\nstruct spear_smi_flash_info *flash_info;\r\nflash_info = &pdata->board_flash_info[i];\r\npdata->np[i] = pp;\r\naddr = of_get_property(pp, "reg", &len);\r\npdata->board_flash_info->mem_base = be32_to_cpup(&addr[0]);\r\npdata->board_flash_info->size = be32_to_cpup(&addr[1]);\r\nif (of_get_property(pp, "st,smi-fast-mode", NULL))\r\npdata->board_flash_info->fast_mode = 1;\r\ni++;\r\n}\r\npdata->num_flashes = i;\r\nreturn 0;\r\n}\r\nstatic int spear_smi_probe_config_dt(struct platform_device *pdev,\r\nstruct device_node *np)\r\n{\r\nreturn -ENOSYS;\r\n}\r\nstatic int spear_smi_setup_banks(struct platform_device *pdev,\r\nu32 bank, struct device_node *np)\r\n{\r\nstruct spear_smi *dev = platform_get_drvdata(pdev);\r\nstruct mtd_part_parser_data ppdata = {};\r\nstruct spear_smi_flash_info *flash_info;\r\nstruct spear_smi_plat_data *pdata;\r\nstruct spear_snor_flash *flash;\r\nstruct mtd_partition *parts = NULL;\r\nint count = 0;\r\nint flash_index;\r\nint ret = 0;\r\npdata = dev_get_platdata(&pdev->dev);\r\nif (bank > pdata->num_flashes - 1)\r\nreturn -EINVAL;\r\nflash_info = &pdata->board_flash_info[bank];\r\nif (!flash_info)\r\nreturn -ENODEV;\r\nflash = devm_kzalloc(&pdev->dev, sizeof(*flash), GFP_ATOMIC);\r\nif (!flash)\r\nreturn -ENOMEM;\r\nflash->bank = bank;\r\nflash->fast_mode = flash_info->fast_mode ? 1 : 0;\r\nmutex_init(&flash->lock);\r\nflash_index = spear_smi_probe_flash(dev, bank);\r\nif (flash_index < 0) {\r\ndev_info(&dev->pdev->dev, "smi-nor%d not found\n", bank);\r\nreturn flash_index;\r\n}\r\nflash->base_addr = devm_ioremap(&pdev->dev, flash_info->mem_base,\r\nflash_info->size);\r\nif (!flash->base_addr)\r\nreturn -EIO;\r\ndev->flash[bank] = flash;\r\nflash->mtd.priv = dev;\r\nif (flash_info->name)\r\nflash->mtd.name = flash_info->name;\r\nelse\r\nflash->mtd.name = flash_devices[flash_index].name;\r\nflash->mtd.type = MTD_NORFLASH;\r\nflash->mtd.writesize = 1;\r\nflash->mtd.flags = MTD_CAP_NORFLASH;\r\nflash->mtd.size = flash_info->size;\r\nflash->mtd.erasesize = flash_devices[flash_index].sectorsize;\r\nflash->page_size = flash_devices[flash_index].pagesize;\r\nflash->mtd.writebufsize = flash->page_size;\r\nflash->erase_cmd = flash_devices[flash_index].erase_cmd;\r\nflash->mtd._erase = spear_mtd_erase;\r\nflash->mtd._read = spear_mtd_read;\r\nflash->mtd._write = spear_mtd_write;\r\nflash->dev_id = flash_devices[flash_index].device_id;\r\ndev_info(&dev->pdev->dev, "mtd .name=%s .size=%llx(%lluM)\n",\r\nflash->mtd.name, flash->mtd.size,\r\nflash->mtd.size / (1024 * 1024));\r\ndev_info(&dev->pdev->dev, ".erasesize = 0x%x(%uK)\n",\r\nflash->mtd.erasesize, flash->mtd.erasesize / 1024);\r\n#ifndef CONFIG_OF\r\nif (flash_info->partitions) {\r\nparts = flash_info->partitions;\r\ncount = flash_info->nr_partitions;\r\n}\r\n#endif\r\nppdata.of_node = np;\r\nret = mtd_device_parse_register(&flash->mtd, NULL, &ppdata, parts,\r\ncount);\r\nif (ret) {\r\ndev_err(&dev->pdev->dev, "Err MTD partition=%d\n", ret);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int spear_smi_probe(struct platform_device *pdev)\r\n{\r\nstruct device_node *np = pdev->dev.of_node;\r\nstruct spear_smi_plat_data *pdata = NULL;\r\nstruct spear_smi *dev;\r\nstruct resource *smi_base;\r\nint irq, ret = 0;\r\nint i;\r\nif (np) {\r\npdata = devm_kzalloc(&pdev->dev, sizeof(*pdata), GFP_KERNEL);\r\nif (!pdata) {\r\nret = -ENOMEM;\r\ngoto err;\r\n}\r\npdev->dev.platform_data = pdata;\r\nret = spear_smi_probe_config_dt(pdev, np);\r\nif (ret) {\r\nret = -ENODEV;\r\ndev_err(&pdev->dev, "no platform data\n");\r\ngoto err;\r\n}\r\n} else {\r\npdata = dev_get_platdata(&pdev->dev);\r\nif (!pdata) {\r\nret = -ENODEV;\r\ndev_err(&pdev->dev, "no platform data\n");\r\ngoto err;\r\n}\r\n}\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq < 0) {\r\nret = -ENODEV;\r\ndev_err(&pdev->dev, "invalid smi irq\n");\r\ngoto err;\r\n}\r\ndev = devm_kzalloc(&pdev->dev, sizeof(*dev), GFP_ATOMIC);\r\nif (!dev) {\r\nret = -ENOMEM;\r\ngoto err;\r\n}\r\nsmi_base = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\ndev->io_base = devm_ioremap_resource(&pdev->dev, smi_base);\r\nif (IS_ERR(dev->io_base)) {\r\nret = PTR_ERR(dev->io_base);\r\ngoto err;\r\n}\r\ndev->pdev = pdev;\r\ndev->clk_rate = pdata->clk_rate;\r\nif (dev->clk_rate > SMI_MAX_CLOCK_FREQ)\r\ndev->clk_rate = SMI_MAX_CLOCK_FREQ;\r\ndev->num_flashes = pdata->num_flashes;\r\nif (dev->num_flashes > MAX_NUM_FLASH_CHIP) {\r\ndev_err(&pdev->dev, "exceeding max number of flashes\n");\r\ndev->num_flashes = MAX_NUM_FLASH_CHIP;\r\n}\r\ndev->clk = devm_clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(dev->clk)) {\r\nret = PTR_ERR(dev->clk);\r\ngoto err;\r\n}\r\nret = clk_prepare_enable(dev->clk);\r\nif (ret)\r\ngoto err;\r\nret = devm_request_irq(&pdev->dev, irq, spear_smi_int_handler, 0,\r\npdev->name, dev);\r\nif (ret) {\r\ndev_err(&dev->pdev->dev, "SMI IRQ allocation failed\n");\r\ngoto err_irq;\r\n}\r\nmutex_init(&dev->lock);\r\ninit_waitqueue_head(&dev->cmd_complete);\r\nspear_smi_hw_init(dev);\r\nplatform_set_drvdata(pdev, dev);\r\nfor (i = 0; i < dev->num_flashes; i++) {\r\nret = spear_smi_setup_banks(pdev, i, pdata->np[i]);\r\nif (ret) {\r\ndev_err(&dev->pdev->dev, "bank setup failed\n");\r\ngoto err_irq;\r\n}\r\n}\r\nreturn 0;\r\nerr_irq:\r\nclk_disable_unprepare(dev->clk);\r\nerr:\r\nreturn ret;\r\n}\r\nstatic int spear_smi_remove(struct platform_device *pdev)\r\n{\r\nstruct spear_smi *dev;\r\nstruct spear_snor_flash *flash;\r\nint ret, i;\r\ndev = platform_get_drvdata(pdev);\r\nif (!dev) {\r\ndev_err(&pdev->dev, "dev is null\n");\r\nreturn -ENODEV;\r\n}\r\nfor (i = 0; i < dev->num_flashes; i++) {\r\nflash = dev->flash[i];\r\nif (!flash)\r\ncontinue;\r\nret = mtd_device_unregister(&flash->mtd);\r\nif (ret)\r\ndev_err(&pdev->dev, "error removing mtd\n");\r\n}\r\nclk_disable_unprepare(dev->clk);\r\nreturn 0;\r\n}\r\nstatic int spear_smi_suspend(struct device *dev)\r\n{\r\nstruct spear_smi *sdev = dev_get_drvdata(dev);\r\nif (sdev && sdev->clk)\r\nclk_disable_unprepare(sdev->clk);\r\nreturn 0;\r\n}\r\nstatic int spear_smi_resume(struct device *dev)\r\n{\r\nstruct spear_smi *sdev = dev_get_drvdata(dev);\r\nint ret = -EPERM;\r\nif (sdev && sdev->clk)\r\nret = clk_prepare_enable(sdev->clk);\r\nif (!ret)\r\nspear_smi_hw_init(sdev);\r\nreturn ret;\r\n}
