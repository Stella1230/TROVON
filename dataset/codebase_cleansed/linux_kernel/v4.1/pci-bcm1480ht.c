static inline u32 READCFG32(u32 addr)\r\n{\r\nreturn *(u32 *)(ht_cfg_space + (addr&~3));\r\n}\r\nstatic inline void WRITECFG32(u32 addr, u32 data)\r\n{\r\n*(u32 *)(ht_cfg_space + (addr & ~3)) = data;\r\n}\r\nstatic int bcm1480ht_can_access(struct pci_bus *bus, int devfn)\r\n{\r\nu32 devno;\r\nif (!(bcm1480ht_bus_status & (PCI_BUS_ENABLED | PCI_DEVICE_MODE)))\r\nreturn 0;\r\nif (bus->number == 0) {\r\ndevno = PCI_SLOT(devfn);\r\nif (bcm1480ht_bus_status & PCI_DEVICE_MODE)\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nstatic int bcm1480ht_pcibios_read(struct pci_bus *bus, unsigned int devfn,\r\nint where, int size, u32 * val)\r\n{\r\nu32 data = 0;\r\nif ((size == 2) && (where & 1))\r\nreturn PCIBIOS_BAD_REGISTER_NUMBER;\r\nelse if ((size == 4) && (where & 3))\r\nreturn PCIBIOS_BAD_REGISTER_NUMBER;\r\nif (bcm1480ht_can_access(bus, devfn))\r\ndata = READCFG32(CFGADDR(bus, devfn, where));\r\nelse\r\ndata = 0xFFFFFFFF;\r\nif (size == 1)\r\n*val = (data >> ((where & 3) << 3)) & 0xff;\r\nelse if (size == 2)\r\n*val = (data >> ((where & 3) << 3)) & 0xffff;\r\nelse\r\n*val = data;\r\nreturn PCIBIOS_SUCCESSFUL;\r\n}\r\nstatic int bcm1480ht_pcibios_write(struct pci_bus *bus, unsigned int devfn,\r\nint where, int size, u32 val)\r\n{\r\nu32 cfgaddr = CFGADDR(bus, devfn, where);\r\nu32 data = 0;\r\nif ((size == 2) && (where & 1))\r\nreturn PCIBIOS_BAD_REGISTER_NUMBER;\r\nelse if ((size == 4) && (where & 3))\r\nreturn PCIBIOS_BAD_REGISTER_NUMBER;\r\nif (!bcm1480ht_can_access(bus, devfn))\r\nreturn PCIBIOS_BAD_REGISTER_NUMBER;\r\ndata = READCFG32(cfgaddr);\r\nif (size == 1)\r\ndata = (data & ~(0xff << ((where & 3) << 3))) |\r\n(val << ((where & 3) << 3));\r\nelse if (size == 2)\r\ndata = (data & ~(0xffff << ((where & 3) << 3))) |\r\n(val << ((where & 3) << 3));\r\nelse\r\ndata = val;\r\nWRITECFG32(cfgaddr, data);\r\nreturn PCIBIOS_SUCCESSFUL;\r\n}\r\nstatic int bcm1480ht_pcibios_get_busno(void)\r\n{\r\nreturn 0;\r\n}\r\nstatic int __init bcm1480ht_pcibios_init(void)\r\n{\r\nht_cfg_space = ioremap(A_BCM1480_PHYS_HT_CFG_MATCH_BITS, 16*1024*1024);\r\nbcm1480ht_bus_status |= PCI_BUS_ENABLED;\r\nht_eoi_space = (unsigned long)\r\nioremap(A_BCM1480_PHYS_HT_SPECIAL_MATCH_BYTES,\r\n4 * 1024 * 1024);\r\nbcm1480ht_controller.io_map_base = (unsigned long)\r\nioremap(A_BCM1480_PHYS_HT_IO_MATCH_BYTES, 65536);\r\nbcm1480ht_controller.io_map_base -= bcm1480ht_controller.io_offset;\r\nregister_pci_controller(&bcm1480ht_controller);\r\nreturn 0;\r\n}
