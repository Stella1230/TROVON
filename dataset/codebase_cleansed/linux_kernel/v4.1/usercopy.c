unsigned long\r\n__generic_copy_to_user(void *to, const void *from, unsigned long n)\r\n{\r\nif (access_ok(VERIFY_WRITE, to, n))\r\n__copy_user(to, from, n);\r\nreturn n;\r\n}\r\nunsigned long\r\n__generic_copy_from_user(void *to, const void *from, unsigned long n)\r\n{\r\nif (access_ok(VERIFY_READ, from, n))\r\n__copy_user_zeroing(to, from, n);\r\nreturn n;\r\n}\r\nlong\r\n__strncpy_from_user(char *dst, const char *src, long count)\r\n{\r\nlong res;\r\n__do_strncpy_from_user(dst, src, count, res);\r\nreturn res;\r\n}\r\nlong\r\nstrncpy_from_user(char *dst, const char *src, long count)\r\n{\r\nlong res = -EFAULT;\r\nif (access_ok(VERIFY_READ, src, 1))\r\n__do_strncpy_from_user(dst, src, count, res);\r\nreturn res;\r\n}\r\nunsigned long\r\n__clear_user(void *to, unsigned long n)\r\n{\r\n__do_clear_user(to, n);\r\nreturn n;\r\n}\r\nunsigned long\r\nclear_user(void *to, unsigned long n)\r\n{\r\nif (access_ok(VERIFY_WRITE, to, n))\r\n__do_clear_user(to, n);\r\nreturn n;\r\n}\r\nlong strnlen_user(const char *s, long n)\r\n{\r\nunsigned long res, w;\r\nif (!__addr_ok(s))\r\nreturn 0;\r\nif (n < 0 || n + (u_long) s > current_thread_info()->addr_limit.seg)\r\nn = current_thread_info()->addr_limit.seg - (u_long)s;\r\nasm volatile(\r\n"0: cmp %4,%0\n"\r\n" beq 2f\n"\r\n"1: movbu (%0,%3),%1\n"\r\n" inc %0\n"\r\n" cmp 0,%1\n"\r\n" beq 3f\n"\r\n" bra 0b\n"\r\n"2: clr %0\n"\r\n"3:\n"\r\n".section .fixup,\"ax\"\n"\r\n"4: jmp 2b\n"\r\n".previous\n"\r\n".section __ex_table,\"a\"\n"\r\n" .balign 4\n"\r\n" .long 1b,4b\n"\r\n".previous\n"\r\n:"=d"(res), "=&r"(w)\r\n:"0"(0), "a"(s), "r"(n)\r\n: "memory", "cc");\r\nreturn res;\r\n}
