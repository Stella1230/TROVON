static void wait_for_dc_servo(struct snd_soc_codec *codec, unsigned int op)\r\n{\r\nstruct wm_hubs_data *hubs = snd_soc_codec_get_drvdata(codec);\r\nunsigned int reg;\r\nint count = 0;\r\nint timeout;\r\nunsigned int val;\r\nval = op | WM8993_DCS_ENA_CHAN_0 | WM8993_DCS_ENA_CHAN_1;\r\nsnd_soc_write(codec, WM8993_DC_SERVO_0, val);\r\ndev_dbg(codec->dev, "Waiting for DC servo...\n");\r\nif (hubs->dcs_done_irq)\r\ntimeout = 4;\r\nelse\r\ntimeout = 400;\r\ndo {\r\ncount++;\r\nif (hubs->dcs_done_irq)\r\nwait_for_completion_timeout(&hubs->dcs_done,\r\nmsecs_to_jiffies(250));\r\nelse\r\nmsleep(1);\r\nreg = snd_soc_read(codec, WM8993_DC_SERVO_0);\r\ndev_dbg(codec->dev, "DC servo: %x\n", reg);\r\n} while (reg & op && count < timeout);\r\nif (reg & op)\r\ndev_err(codec->dev, "Timed out waiting for DC Servo %x\n",\r\nop);\r\n}\r\nirqreturn_t wm_hubs_dcs_done(int irq, void *data)\r\n{\r\nstruct wm_hubs_data *hubs = data;\r\ncomplete(&hubs->dcs_done);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic bool wm_hubs_dac_hp_direct(struct snd_soc_codec *codec)\r\n{\r\nint reg;\r\nreg = snd_soc_read(codec, WM8993_OUTPUT_MIXER1);\r\nif (!(reg & WM8993_DACL_TO_HPOUT1L)) {\r\nif (reg & ~WM8993_DACL_TO_MIXOUTL) {\r\ndev_vdbg(codec->dev, "Analogue paths connected: %x\n",\r\nreg & ~WM8993_DACL_TO_HPOUT1L);\r\nreturn false;\r\n} else {\r\ndev_vdbg(codec->dev, "HPL connected to mixer\n");\r\n}\r\n} else {\r\ndev_vdbg(codec->dev, "HPL connected to DAC\n");\r\n}\r\nreg = snd_soc_read(codec, WM8993_OUTPUT_MIXER2);\r\nif (!(reg & WM8993_DACR_TO_HPOUT1R)) {\r\nif (reg & ~WM8993_DACR_TO_MIXOUTR) {\r\ndev_vdbg(codec->dev, "Analogue paths connected: %x\n",\r\nreg & ~WM8993_DACR_TO_HPOUT1R);\r\nreturn false;\r\n} else {\r\ndev_vdbg(codec->dev, "HPR connected to mixer\n");\r\n}\r\n} else {\r\ndev_vdbg(codec->dev, "HPR connected to DAC\n");\r\n}\r\nreturn true;\r\n}\r\nstatic bool wm_hubs_dcs_cache_get(struct snd_soc_codec *codec,\r\nstruct wm_hubs_dcs_cache **entry)\r\n{\r\nstruct wm_hubs_data *hubs = snd_soc_codec_get_drvdata(codec);\r\nstruct wm_hubs_dcs_cache *cache;\r\nunsigned int left, right;\r\nleft = snd_soc_read(codec, WM8993_LEFT_OUTPUT_VOLUME);\r\nleft &= WM8993_HPOUT1L_VOL_MASK;\r\nright = snd_soc_read(codec, WM8993_RIGHT_OUTPUT_VOLUME);\r\nright &= WM8993_HPOUT1R_VOL_MASK;\r\nlist_for_each_entry(cache, &hubs->dcs_cache, list) {\r\nif (cache->left != left || cache->right != right)\r\ncontinue;\r\n*entry = cache;\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic void wm_hubs_dcs_cache_set(struct snd_soc_codec *codec, u16 dcs_cfg)\r\n{\r\nstruct wm_hubs_data *hubs = snd_soc_codec_get_drvdata(codec);\r\nstruct wm_hubs_dcs_cache *cache;\r\nif (hubs->no_cache_dac_hp_direct)\r\nreturn;\r\ncache = devm_kzalloc(codec->dev, sizeof(*cache), GFP_KERNEL);\r\nif (!cache)\r\nreturn;\r\ncache->left = snd_soc_read(codec, WM8993_LEFT_OUTPUT_VOLUME);\r\ncache->left &= WM8993_HPOUT1L_VOL_MASK;\r\ncache->right = snd_soc_read(codec, WM8993_RIGHT_OUTPUT_VOLUME);\r\ncache->right &= WM8993_HPOUT1R_VOL_MASK;\r\ncache->dcs_cfg = dcs_cfg;\r\nlist_add_tail(&cache->list, &hubs->dcs_cache);\r\n}\r\nstatic int wm_hubs_read_dc_servo(struct snd_soc_codec *codec,\r\nu16 *reg_l, u16 *reg_r)\r\n{\r\nstruct wm_hubs_data *hubs = snd_soc_codec_get_drvdata(codec);\r\nu16 dcs_reg, reg;\r\nint ret = 0;\r\nswitch (hubs->dcs_readback_mode) {\r\ncase 2:\r\ndcs_reg = WM8994_DC_SERVO_4E;\r\nbreak;\r\ncase 1:\r\ndcs_reg = WM8994_DC_SERVO_READBACK;\r\nbreak;\r\ndefault:\r\ndcs_reg = WM8993_DC_SERVO_3;\r\nbreak;\r\n}\r\nswitch (hubs->dcs_readback_mode) {\r\ncase 0:\r\n*reg_l = snd_soc_read(codec, WM8993_DC_SERVO_READBACK_1)\r\n& WM8993_DCS_INTEG_CHAN_0_MASK;\r\n*reg_r = snd_soc_read(codec, WM8993_DC_SERVO_READBACK_2)\r\n& WM8993_DCS_INTEG_CHAN_1_MASK;\r\nbreak;\r\ncase 2:\r\ncase 1:\r\nreg = snd_soc_read(codec, dcs_reg);\r\n*reg_r = (reg & WM8993_DCS_DAC_WR_VAL_1_MASK)\r\n>> WM8993_DCS_DAC_WR_VAL_1_SHIFT;\r\n*reg_l = reg & WM8993_DCS_DAC_WR_VAL_0_MASK;\r\nbreak;\r\ndefault:\r\nWARN(1, "Unknown DCS readback method\n");\r\nret = -1;\r\n}\r\nreturn ret;\r\n}\r\nstatic void enable_dc_servo(struct snd_soc_codec *codec)\r\n{\r\nstruct wm_hubs_data *hubs = snd_soc_codec_get_drvdata(codec);\r\nstruct wm_hubs_dcs_cache *cache;\r\ns8 offset;\r\nu16 reg_l, reg_r, dcs_cfg, dcs_reg;\r\nswitch (hubs->dcs_readback_mode) {\r\ncase 2:\r\ndcs_reg = WM8994_DC_SERVO_4E;\r\nbreak;\r\ndefault:\r\ndcs_reg = WM8993_DC_SERVO_3;\r\nbreak;\r\n}\r\nif (wm_hubs_dac_hp_direct(codec) &&\r\nwm_hubs_dcs_cache_get(codec, &cache)) {\r\ndev_dbg(codec->dev, "Using cached DCS offset %x for %d,%d\n",\r\ncache->dcs_cfg, cache->left, cache->right);\r\nsnd_soc_write(codec, dcs_reg, cache->dcs_cfg);\r\nwait_for_dc_servo(codec,\r\nWM8993_DCS_TRIG_DAC_WR_0 |\r\nWM8993_DCS_TRIG_DAC_WR_1);\r\nreturn;\r\n}\r\nif (hubs->series_startup) {\r\nsnd_soc_update_bits(codec, WM8993_DC_SERVO_1,\r\nWM8993_DCS_SERIES_NO_01_MASK,\r\n32 << WM8993_DCS_SERIES_NO_01_SHIFT);\r\nwait_for_dc_servo(codec,\r\nWM8993_DCS_TRIG_SERIES_0 |\r\nWM8993_DCS_TRIG_SERIES_1);\r\n} else {\r\nwait_for_dc_servo(codec,\r\nWM8993_DCS_TRIG_STARTUP_0 |\r\nWM8993_DCS_TRIG_STARTUP_1);\r\n}\r\nif (wm_hubs_read_dc_servo(codec, &reg_l, &reg_r) < 0)\r\nreturn;\r\ndev_dbg(codec->dev, "DCS input: %x %x\n", reg_l, reg_r);\r\nif (hubs->dcs_codes_l || hubs->dcs_codes_r) {\r\ndev_dbg(codec->dev,\r\n"Applying %d/%d code DC servo correction\n",\r\nhubs->dcs_codes_l, hubs->dcs_codes_r);\r\noffset = (s8)reg_r;\r\ndev_dbg(codec->dev, "DCS right %d->%d\n", offset,\r\noffset + hubs->dcs_codes_r);\r\noffset += hubs->dcs_codes_r;\r\ndcs_cfg = (u8)offset << WM8993_DCS_DAC_WR_VAL_1_SHIFT;\r\noffset = (s8)reg_l;\r\ndev_dbg(codec->dev, "DCS left %d->%d\n", offset,\r\noffset + hubs->dcs_codes_l);\r\noffset += hubs->dcs_codes_l;\r\ndcs_cfg |= (u8)offset;\r\ndev_dbg(codec->dev, "DCS result: %x\n", dcs_cfg);\r\nsnd_soc_write(codec, dcs_reg, dcs_cfg);\r\nwait_for_dc_servo(codec,\r\nWM8993_DCS_TRIG_DAC_WR_0 |\r\nWM8993_DCS_TRIG_DAC_WR_1);\r\n} else {\r\ndcs_cfg = reg_r << WM8993_DCS_DAC_WR_VAL_1_SHIFT;\r\ndcs_cfg |= reg_l;\r\n}\r\nif (wm_hubs_dac_hp_direct(codec))\r\nwm_hubs_dcs_cache_set(codec, dcs_cfg);\r\n}\r\nstatic int wm8993_put_dc_servo(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_codec *codec = snd_soc_kcontrol_codec(kcontrol);\r\nstruct wm_hubs_data *hubs = snd_soc_codec_get_drvdata(codec);\r\nint ret;\r\nret = snd_soc_put_volsw(kcontrol, ucontrol);\r\nif (hubs->dcs_codes_l || hubs->dcs_codes_r || hubs->no_series_update)\r\nreturn ret;\r\nif (snd_soc_read(codec, WM8993_POWER_MANAGEMENT_1)\r\n& (WM8993_HPOUT1L_ENA | WM8993_HPOUT1R_ENA))\r\nsnd_soc_update_bits(codec,\r\nWM8993_DC_SERVO_0,\r\nWM8993_DCS_TRIG_SINGLE_0 |\r\nWM8993_DCS_TRIG_SINGLE_1,\r\nWM8993_DCS_TRIG_SINGLE_0 |\r\nWM8993_DCS_TRIG_SINGLE_1);\r\nreturn ret;\r\n}\r\nstatic int hp_supply_event(struct snd_soc_dapm_widget *w,\r\nstruct snd_kcontrol *kcontrol, int event)\r\n{\r\nstruct snd_soc_codec *codec = snd_soc_dapm_to_codec(w->dapm);\r\nstruct wm_hubs_data *hubs = snd_soc_codec_get_drvdata(codec);\r\nswitch (event) {\r\ncase SND_SOC_DAPM_PRE_PMU:\r\nswitch (hubs->hp_startup_mode) {\r\ncase 0:\r\nbreak;\r\ncase 1:\r\nsnd_soc_update_bits(codec, WM8993_POWER_MANAGEMENT_1,\r\nWM8993_HPOUT1L_ENA |\r\nWM8993_HPOUT1R_ENA,\r\nWM8993_HPOUT1L_ENA |\r\nWM8993_HPOUT1R_ENA);\r\nsnd_soc_update_bits(codec, WM8993_ANALOGUE_HP_0,\r\nWM8993_HPOUT1L_DLY |\r\nWM8993_HPOUT1R_DLY,\r\nWM8993_HPOUT1L_DLY |\r\nWM8993_HPOUT1R_DLY);\r\nbreak;\r\ndefault:\r\ndev_err(codec->dev, "Unknown HP startup mode %d\n",\r\nhubs->hp_startup_mode);\r\nbreak;\r\n}\r\nbreak;\r\ncase SND_SOC_DAPM_PRE_PMD:\r\nsnd_soc_update_bits(codec, WM8993_CHARGE_PUMP_1,\r\nWM8993_CP_ENA, 0);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int hp_event(struct snd_soc_dapm_widget *w,\r\nstruct snd_kcontrol *kcontrol, int event)\r\n{\r\nstruct snd_soc_codec *codec = snd_soc_dapm_to_codec(w->dapm);\r\nunsigned int reg = snd_soc_read(codec, WM8993_ANALOGUE_HP_0);\r\nswitch (event) {\r\ncase SND_SOC_DAPM_POST_PMU:\r\nsnd_soc_update_bits(codec, WM8993_CHARGE_PUMP_1,\r\nWM8993_CP_ENA, WM8993_CP_ENA);\r\nmsleep(5);\r\nsnd_soc_update_bits(codec, WM8993_POWER_MANAGEMENT_1,\r\nWM8993_HPOUT1L_ENA | WM8993_HPOUT1R_ENA,\r\nWM8993_HPOUT1L_ENA | WM8993_HPOUT1R_ENA);\r\nreg |= WM8993_HPOUT1L_DLY | WM8993_HPOUT1R_DLY;\r\nsnd_soc_write(codec, WM8993_ANALOGUE_HP_0, reg);\r\nsnd_soc_update_bits(codec, WM8993_DC_SERVO_1,\r\nWM8993_DCS_TIMER_PERIOD_01_MASK, 0);\r\nenable_dc_servo(codec);\r\nreg |= WM8993_HPOUT1R_OUTP | WM8993_HPOUT1R_RMV_SHORT |\r\nWM8993_HPOUT1L_OUTP | WM8993_HPOUT1L_RMV_SHORT;\r\nsnd_soc_write(codec, WM8993_ANALOGUE_HP_0, reg);\r\nbreak;\r\ncase SND_SOC_DAPM_PRE_PMD:\r\nsnd_soc_update_bits(codec, WM8993_ANALOGUE_HP_0,\r\nWM8993_HPOUT1L_OUTP |\r\nWM8993_HPOUT1R_OUTP |\r\nWM8993_HPOUT1L_RMV_SHORT |\r\nWM8993_HPOUT1R_RMV_SHORT, 0);\r\nsnd_soc_update_bits(codec, WM8993_ANALOGUE_HP_0,\r\nWM8993_HPOUT1L_DLY |\r\nWM8993_HPOUT1R_DLY, 0);\r\nsnd_soc_write(codec, WM8993_DC_SERVO_0, 0);\r\nsnd_soc_update_bits(codec, WM8993_POWER_MANAGEMENT_1,\r\nWM8993_HPOUT1L_ENA | WM8993_HPOUT1R_ENA,\r\n0);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int earpiece_event(struct snd_soc_dapm_widget *w,\r\nstruct snd_kcontrol *control, int event)\r\n{\r\nstruct snd_soc_codec *codec = snd_soc_dapm_to_codec(w->dapm);\r\nu16 reg = snd_soc_read(codec, WM8993_ANTIPOP1) & ~WM8993_HPOUT2_IN_ENA;\r\nswitch (event) {\r\ncase SND_SOC_DAPM_PRE_PMU:\r\nreg |= WM8993_HPOUT2_IN_ENA;\r\nsnd_soc_write(codec, WM8993_ANTIPOP1, reg);\r\nudelay(50);\r\nbreak;\r\ncase SND_SOC_DAPM_POST_PMD:\r\nsnd_soc_write(codec, WM8993_ANTIPOP1, reg);\r\nbreak;\r\ndefault:\r\nWARN(1, "Invalid event %d\n", event);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int lineout_event(struct snd_soc_dapm_widget *w,\r\nstruct snd_kcontrol *control, int event)\r\n{\r\nstruct snd_soc_codec *codec = snd_soc_dapm_to_codec(w->dapm);\r\nstruct wm_hubs_data *hubs = snd_soc_codec_get_drvdata(codec);\r\nbool *flag;\r\nswitch (w->shift) {\r\ncase WM8993_LINEOUT1N_ENA_SHIFT:\r\nflag = &hubs->lineout1n_ena;\r\nbreak;\r\ncase WM8993_LINEOUT1P_ENA_SHIFT:\r\nflag = &hubs->lineout1p_ena;\r\nbreak;\r\ncase WM8993_LINEOUT2N_ENA_SHIFT:\r\nflag = &hubs->lineout2n_ena;\r\nbreak;\r\ncase WM8993_LINEOUT2P_ENA_SHIFT:\r\nflag = &hubs->lineout2p_ena;\r\nbreak;\r\ndefault:\r\nWARN(1, "Unknown line output");\r\nreturn -EINVAL;\r\n}\r\n*flag = SND_SOC_DAPM_EVENT_ON(event);\r\nreturn 0;\r\n}\r\nstatic int micbias_event(struct snd_soc_dapm_widget *w,\r\nstruct snd_kcontrol *kcontrol, int event)\r\n{\r\nstruct snd_soc_codec *codec = snd_soc_dapm_to_codec(w->dapm);\r\nstruct wm_hubs_data *hubs = snd_soc_codec_get_drvdata(codec);\r\nswitch (w->shift) {\r\ncase WM8993_MICB1_ENA_SHIFT:\r\nif (hubs->micb1_delay)\r\nmsleep(hubs->micb1_delay);\r\nbreak;\r\ncase WM8993_MICB2_ENA_SHIFT:\r\nif (hubs->micb2_delay)\r\nmsleep(hubs->micb2_delay);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nvoid wm_hubs_update_class_w(struct snd_soc_codec *codec)\r\n{\r\nstruct wm_hubs_data *hubs = snd_soc_codec_get_drvdata(codec);\r\nint enable = WM8993_CP_DYN_V | WM8993_CP_DYN_FREQ;\r\nif (!wm_hubs_dac_hp_direct(codec))\r\nenable = false;\r\nif (hubs->check_class_w_digital && !hubs->check_class_w_digital(codec))\r\nenable = false;\r\ndev_vdbg(codec->dev, "Class W %s\n", enable ? "enabled" : "disabled");\r\nsnd_soc_update_bits(codec, WM8993_CLASS_W_0,\r\nWM8993_CP_DYN_V | WM8993_CP_DYN_FREQ, enable);\r\nsnd_soc_write(codec, WM8993_LEFT_OUTPUT_VOLUME,\r\nsnd_soc_read(codec, WM8993_LEFT_OUTPUT_VOLUME));\r\nsnd_soc_write(codec, WM8993_RIGHT_OUTPUT_VOLUME,\r\nsnd_soc_read(codec, WM8993_RIGHT_OUTPUT_VOLUME));\r\n}\r\nstatic int class_w_put_volsw(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_codec *codec = snd_soc_dapm_kcontrol_codec(kcontrol);\r\nint ret;\r\nret = snd_soc_dapm_put_volsw(kcontrol, ucontrol);\r\nwm_hubs_update_class_w(codec);\r\nreturn ret;\r\n}\r\nstatic int class_w_put_double(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_codec *codec = snd_soc_dapm_kcontrol_codec(kcontrol);\r\nint ret;\r\nret = snd_soc_dapm_put_enum_double(kcontrol, ucontrol);\r\nwm_hubs_update_class_w(codec);\r\nreturn ret;\r\n}\r\nint wm_hubs_add_analogue_controls(struct snd_soc_codec *codec)\r\n{\r\nstruct snd_soc_dapm_context *dapm = &codec->dapm;\r\nsnd_soc_update_bits(codec, WM8993_LEFT_LINE_INPUT_1_2_VOLUME,\r\nWM8993_IN1_VU, WM8993_IN1_VU);\r\nsnd_soc_update_bits(codec, WM8993_RIGHT_LINE_INPUT_1_2_VOLUME,\r\nWM8993_IN1_VU, WM8993_IN1_VU);\r\nsnd_soc_update_bits(codec, WM8993_LEFT_LINE_INPUT_3_4_VOLUME,\r\nWM8993_IN2_VU, WM8993_IN2_VU);\r\nsnd_soc_update_bits(codec, WM8993_RIGHT_LINE_INPUT_3_4_VOLUME,\r\nWM8993_IN2_VU, WM8993_IN2_VU);\r\nsnd_soc_update_bits(codec, WM8993_SPEAKER_VOLUME_LEFT,\r\nWM8993_SPKOUT_VU, WM8993_SPKOUT_VU);\r\nsnd_soc_update_bits(codec, WM8993_SPEAKER_VOLUME_RIGHT,\r\nWM8993_SPKOUT_VU, WM8993_SPKOUT_VU);\r\nsnd_soc_update_bits(codec, WM8993_LEFT_OUTPUT_VOLUME,\r\nWM8993_HPOUT1_VU | WM8993_HPOUT1L_ZC,\r\nWM8993_HPOUT1_VU | WM8993_HPOUT1L_ZC);\r\nsnd_soc_update_bits(codec, WM8993_RIGHT_OUTPUT_VOLUME,\r\nWM8993_HPOUT1_VU | WM8993_HPOUT1R_ZC,\r\nWM8993_HPOUT1_VU | WM8993_HPOUT1R_ZC);\r\nsnd_soc_update_bits(codec, WM8993_LEFT_OPGA_VOLUME,\r\nWM8993_MIXOUTL_ZC | WM8993_MIXOUT_VU,\r\nWM8993_MIXOUTL_ZC | WM8993_MIXOUT_VU);\r\nsnd_soc_update_bits(codec, WM8993_RIGHT_OPGA_VOLUME,\r\nWM8993_MIXOUTR_ZC | WM8993_MIXOUT_VU,\r\nWM8993_MIXOUTR_ZC | WM8993_MIXOUT_VU);\r\nsnd_soc_add_codec_controls(codec, analogue_snd_controls,\r\nARRAY_SIZE(analogue_snd_controls));\r\nsnd_soc_dapm_new_controls(dapm, analogue_dapm_widgets,\r\nARRAY_SIZE(analogue_dapm_widgets));\r\nreturn 0;\r\n}\r\nint wm_hubs_add_analogue_routes(struct snd_soc_codec *codec,\r\nint lineout1_diff, int lineout2_diff)\r\n{\r\nstruct wm_hubs_data *hubs = snd_soc_codec_get_drvdata(codec);\r\nstruct snd_soc_dapm_context *dapm = &codec->dapm;\r\nhubs->codec = codec;\r\nINIT_LIST_HEAD(&hubs->dcs_cache);\r\ninit_completion(&hubs->dcs_done);\r\nsnd_soc_dapm_add_routes(dapm, analogue_routes,\r\nARRAY_SIZE(analogue_routes));\r\nif (lineout1_diff)\r\nsnd_soc_dapm_add_routes(dapm,\r\nlineout1_diff_routes,\r\nARRAY_SIZE(lineout1_diff_routes));\r\nelse\r\nsnd_soc_dapm_add_routes(dapm,\r\nlineout1_se_routes,\r\nARRAY_SIZE(lineout1_se_routes));\r\nif (lineout2_diff)\r\nsnd_soc_dapm_add_routes(dapm,\r\nlineout2_diff_routes,\r\nARRAY_SIZE(lineout2_diff_routes));\r\nelse\r\nsnd_soc_dapm_add_routes(dapm,\r\nlineout2_se_routes,\r\nARRAY_SIZE(lineout2_se_routes));\r\nreturn 0;\r\n}\r\nint wm_hubs_handle_analogue_pdata(struct snd_soc_codec *codec,\r\nint lineout1_diff, int lineout2_diff,\r\nint lineout1fb, int lineout2fb,\r\nint jd_scthr, int jd_thr,\r\nint micbias1_delay, int micbias2_delay,\r\nint micbias1_lvl, int micbias2_lvl)\r\n{\r\nstruct wm_hubs_data *hubs = snd_soc_codec_get_drvdata(codec);\r\nhubs->lineout1_se = !lineout1_diff;\r\nhubs->lineout2_se = !lineout2_diff;\r\nhubs->micb1_delay = micbias1_delay;\r\nhubs->micb2_delay = micbias2_delay;\r\nif (!lineout1_diff)\r\nsnd_soc_update_bits(codec, WM8993_LINE_MIXER1,\r\nWM8993_LINEOUT1_MODE,\r\nWM8993_LINEOUT1_MODE);\r\nif (!lineout2_diff)\r\nsnd_soc_update_bits(codec, WM8993_LINE_MIXER2,\r\nWM8993_LINEOUT2_MODE,\r\nWM8993_LINEOUT2_MODE);\r\nif (!lineout1_diff && !lineout2_diff)\r\nsnd_soc_update_bits(codec, WM8993_ANTIPOP1,\r\nWM8993_LINEOUT_VMID_BUF_ENA,\r\nWM8993_LINEOUT_VMID_BUF_ENA);\r\nif (lineout1fb)\r\nsnd_soc_update_bits(codec, WM8993_ADDITIONAL_CONTROL,\r\nWM8993_LINEOUT1_FB, WM8993_LINEOUT1_FB);\r\nif (lineout2fb)\r\nsnd_soc_update_bits(codec, WM8993_ADDITIONAL_CONTROL,\r\nWM8993_LINEOUT2_FB, WM8993_LINEOUT2_FB);\r\nsnd_soc_update_bits(codec, WM8993_MICBIAS,\r\nWM8993_JD_SCTHR_MASK | WM8993_JD_THR_MASK |\r\nWM8993_MICB1_LVL | WM8993_MICB2_LVL,\r\njd_scthr << WM8993_JD_SCTHR_SHIFT |\r\njd_thr << WM8993_JD_THR_SHIFT |\r\nmicbias1_lvl |\r\nmicbias2_lvl << WM8993_MICB2_LVL_SHIFT);\r\nreturn 0;\r\n}\r\nvoid wm_hubs_vmid_ena(struct snd_soc_codec *codec)\r\n{\r\nstruct wm_hubs_data *hubs = snd_soc_codec_get_drvdata(codec);\r\nint val = 0;\r\nif (hubs->lineout1_se)\r\nval |= WM8993_LINEOUT1N_ENA | WM8993_LINEOUT1P_ENA;\r\nif (hubs->lineout2_se)\r\nval |= WM8993_LINEOUT2N_ENA | WM8993_LINEOUT2P_ENA;\r\nsnd_soc_update_bits(codec, WM8993_POWER_MANAGEMENT_3, val, val);\r\n}\r\nvoid wm_hubs_set_bias_level(struct snd_soc_codec *codec,\r\nenum snd_soc_bias_level level)\r\n{\r\nstruct wm_hubs_data *hubs = snd_soc_codec_get_drvdata(codec);\r\nint mask, val;\r\nswitch (level) {\r\ncase SND_SOC_BIAS_STANDBY:\r\nsnd_soc_update_bits(codec, WM8993_INPUTS_CLAMP_REG,\r\nWM8993_INPUTS_CLAMP, WM8993_INPUTS_CLAMP);\r\nbreak;\r\ncase SND_SOC_BIAS_ON:\r\nval = 0;\r\nmask = 0;\r\nif (hubs->lineout1_se)\r\nmask |= WM8993_LINEOUT1N_ENA | WM8993_LINEOUT1P_ENA;\r\nif (hubs->lineout2_se)\r\nmask |= WM8993_LINEOUT2N_ENA | WM8993_LINEOUT2P_ENA;\r\nif (hubs->lineout1_se && hubs->lineout1n_ena)\r\nval |= WM8993_LINEOUT1N_ENA;\r\nif (hubs->lineout1_se && hubs->lineout1p_ena)\r\nval |= WM8993_LINEOUT1P_ENA;\r\nif (hubs->lineout2_se && hubs->lineout2n_ena)\r\nval |= WM8993_LINEOUT2N_ENA;\r\nif (hubs->lineout2_se && hubs->lineout2p_ena)\r\nval |= WM8993_LINEOUT2P_ENA;\r\nsnd_soc_update_bits(codec, WM8993_POWER_MANAGEMENT_3,\r\nmask, val);\r\nsnd_soc_update_bits(codec, WM8993_INPUTS_CLAMP_REG,\r\nWM8993_INPUTS_CLAMP, 0);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}
