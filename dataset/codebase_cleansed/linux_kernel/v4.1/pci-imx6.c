static int pcie_phy_poll_ack(void __iomem *dbi_base, int exp_val)\r\n{\r\nu32 val;\r\nu32 max_iterations = 10;\r\nu32 wait_counter = 0;\r\ndo {\r\nval = readl(dbi_base + PCIE_PHY_STAT);\r\nval = (val >> PCIE_PHY_STAT_ACK_LOC) & 0x1;\r\nwait_counter++;\r\nif (val == exp_val)\r\nreturn 0;\r\nudelay(1);\r\n} while (wait_counter < max_iterations);\r\nreturn -ETIMEDOUT;\r\n}\r\nstatic int pcie_phy_wait_ack(void __iomem *dbi_base, int addr)\r\n{\r\nu32 val;\r\nint ret;\r\nval = addr << PCIE_PHY_CTRL_DATA_LOC;\r\nwritel(val, dbi_base + PCIE_PHY_CTRL);\r\nval |= (0x1 << PCIE_PHY_CTRL_CAP_ADR_LOC);\r\nwritel(val, dbi_base + PCIE_PHY_CTRL);\r\nret = pcie_phy_poll_ack(dbi_base, 1);\r\nif (ret)\r\nreturn ret;\r\nval = addr << PCIE_PHY_CTRL_DATA_LOC;\r\nwritel(val, dbi_base + PCIE_PHY_CTRL);\r\nret = pcie_phy_poll_ack(dbi_base, 0);\r\nif (ret)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nstatic int pcie_phy_read(void __iomem *dbi_base, int addr , int *data)\r\n{\r\nu32 val, phy_ctl;\r\nint ret;\r\nret = pcie_phy_wait_ack(dbi_base, addr);\r\nif (ret)\r\nreturn ret;\r\nphy_ctl = 0x1 << PCIE_PHY_CTRL_RD_LOC;\r\nwritel(phy_ctl, dbi_base + PCIE_PHY_CTRL);\r\nret = pcie_phy_poll_ack(dbi_base, 1);\r\nif (ret)\r\nreturn ret;\r\nval = readl(dbi_base + PCIE_PHY_STAT);\r\n*data = val & 0xffff;\r\nwritel(0x00, dbi_base + PCIE_PHY_CTRL);\r\nret = pcie_phy_poll_ack(dbi_base, 0);\r\nif (ret)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nstatic int pcie_phy_write(void __iomem *dbi_base, int addr, int data)\r\n{\r\nu32 var;\r\nint ret;\r\nret = pcie_phy_wait_ack(dbi_base, addr);\r\nif (ret)\r\nreturn ret;\r\nvar = data << PCIE_PHY_CTRL_DATA_LOC;\r\nwritel(var, dbi_base + PCIE_PHY_CTRL);\r\nvar |= (0x1 << PCIE_PHY_CTRL_CAP_DAT_LOC);\r\nwritel(var, dbi_base + PCIE_PHY_CTRL);\r\nret = pcie_phy_poll_ack(dbi_base, 1);\r\nif (ret)\r\nreturn ret;\r\nvar = data << PCIE_PHY_CTRL_DATA_LOC;\r\nwritel(var, dbi_base + PCIE_PHY_CTRL);\r\nret = pcie_phy_poll_ack(dbi_base, 0);\r\nif (ret)\r\nreturn ret;\r\nvar = 0x1 << PCIE_PHY_CTRL_WR_LOC;\r\nwritel(var, dbi_base + PCIE_PHY_CTRL);\r\nret = pcie_phy_poll_ack(dbi_base, 1);\r\nif (ret)\r\nreturn ret;\r\nvar = data << PCIE_PHY_CTRL_DATA_LOC;\r\nwritel(var, dbi_base + PCIE_PHY_CTRL);\r\nret = pcie_phy_poll_ack(dbi_base, 0);\r\nif (ret)\r\nreturn ret;\r\nwritel(0x0, dbi_base + PCIE_PHY_CTRL);\r\nreturn 0;\r\n}\r\nstatic int imx6q_pcie_abort_handler(unsigned long addr,\r\nunsigned int fsr, struct pt_regs *regs)\r\n{\r\nreturn 0;\r\n}\r\nstatic int imx6_pcie_assert_core_reset(struct pcie_port *pp)\r\n{\r\nstruct imx6_pcie *imx6_pcie = to_imx6_pcie(pp);\r\nu32 val, gpr1, gpr12;\r\nregmap_read(imx6_pcie->iomuxc_gpr, IOMUXC_GPR1, &gpr1);\r\nregmap_read(imx6_pcie->iomuxc_gpr, IOMUXC_GPR12, &gpr12);\r\nif ((gpr1 & IMX6Q_GPR1_PCIE_REF_CLK_EN) &&\r\n(gpr12 & IMX6Q_GPR12_PCIE_CTL_2)) {\r\nval = readl(pp->dbi_base + PCIE_PL_PFLR);\r\nval &= ~PCIE_PL_PFLR_LINK_STATE_MASK;\r\nval |= PCIE_PL_PFLR_FORCE_LINK;\r\nwritel(val, pp->dbi_base + PCIE_PL_PFLR);\r\nregmap_update_bits(imx6_pcie->iomuxc_gpr, IOMUXC_GPR12,\r\nIMX6Q_GPR12_PCIE_CTL_2, 0 << 10);\r\n}\r\nregmap_update_bits(imx6_pcie->iomuxc_gpr, IOMUXC_GPR1,\r\nIMX6Q_GPR1_PCIE_TEST_PD, 1 << 18);\r\nregmap_update_bits(imx6_pcie->iomuxc_gpr, IOMUXC_GPR1,\r\nIMX6Q_GPR1_PCIE_REF_CLK_EN, 0 << 16);\r\nreturn 0;\r\n}\r\nstatic int imx6_pcie_deassert_core_reset(struct pcie_port *pp)\r\n{\r\nstruct imx6_pcie *imx6_pcie = to_imx6_pcie(pp);\r\nint ret;\r\nret = clk_prepare_enable(imx6_pcie->pcie_phy);\r\nif (ret) {\r\ndev_err(pp->dev, "unable to enable pcie_phy clock\n");\r\ngoto err_pcie_phy;\r\n}\r\nret = clk_prepare_enable(imx6_pcie->pcie_bus);\r\nif (ret) {\r\ndev_err(pp->dev, "unable to enable pcie_bus clock\n");\r\ngoto err_pcie_bus;\r\n}\r\nret = clk_prepare_enable(imx6_pcie->pcie);\r\nif (ret) {\r\ndev_err(pp->dev, "unable to enable pcie clock\n");\r\ngoto err_pcie;\r\n}\r\nregmap_update_bits(imx6_pcie->iomuxc_gpr, IOMUXC_GPR1,\r\nIMX6Q_GPR1_PCIE_TEST_PD, 0 << 18);\r\nudelay(10);\r\nregmap_update_bits(imx6_pcie->iomuxc_gpr, IOMUXC_GPR1,\r\nIMX6Q_GPR1_PCIE_REF_CLK_EN, 1 << 16);\r\nusleep_range(200, 500);\r\nif (gpio_is_valid(imx6_pcie->reset_gpio)) {\r\ngpio_set_value(imx6_pcie->reset_gpio, 0);\r\nmsleep(100);\r\ngpio_set_value(imx6_pcie->reset_gpio, 1);\r\n}\r\nreturn 0;\r\nerr_pcie:\r\nclk_disable_unprepare(imx6_pcie->pcie_bus);\r\nerr_pcie_bus:\r\nclk_disable_unprepare(imx6_pcie->pcie_phy);\r\nerr_pcie_phy:\r\nreturn ret;\r\n}\r\nstatic void imx6_pcie_init_phy(struct pcie_port *pp)\r\n{\r\nstruct imx6_pcie *imx6_pcie = to_imx6_pcie(pp);\r\nregmap_update_bits(imx6_pcie->iomuxc_gpr, IOMUXC_GPR12,\r\nIMX6Q_GPR12_PCIE_CTL_2, 0 << 10);\r\nregmap_update_bits(imx6_pcie->iomuxc_gpr, IOMUXC_GPR12,\r\nIMX6Q_GPR12_DEVICE_TYPE, PCI_EXP_TYPE_ROOT_PORT << 12);\r\nregmap_update_bits(imx6_pcie->iomuxc_gpr, IOMUXC_GPR12,\r\nIMX6Q_GPR12_LOS_LEVEL, 9 << 4);\r\nregmap_update_bits(imx6_pcie->iomuxc_gpr, IOMUXC_GPR8,\r\nIMX6Q_GPR8_TX_DEEMPH_GEN1, 0 << 0);\r\nregmap_update_bits(imx6_pcie->iomuxc_gpr, IOMUXC_GPR8,\r\nIMX6Q_GPR8_TX_DEEMPH_GEN2_3P5DB, 0 << 6);\r\nregmap_update_bits(imx6_pcie->iomuxc_gpr, IOMUXC_GPR8,\r\nIMX6Q_GPR8_TX_DEEMPH_GEN2_6DB, 20 << 12);\r\nregmap_update_bits(imx6_pcie->iomuxc_gpr, IOMUXC_GPR8,\r\nIMX6Q_GPR8_TX_SWING_FULL, 127 << 18);\r\nregmap_update_bits(imx6_pcie->iomuxc_gpr, IOMUXC_GPR8,\r\nIMX6Q_GPR8_TX_SWING_LOW, 127 << 25);\r\n}\r\nstatic int imx6_pcie_wait_for_link(struct pcie_port *pp)\r\n{\r\nint count = 200;\r\nwhile (!dw_pcie_link_up(pp)) {\r\nusleep_range(100, 1000);\r\nif (--count)\r\ncontinue;\r\ndev_err(pp->dev, "phy link never came up\n");\r\ndev_dbg(pp->dev, "DEBUG_R0: 0x%08x, DEBUG_R1: 0x%08x\n",\r\nreadl(pp->dbi_base + PCIE_PHY_DEBUG_R0),\r\nreadl(pp->dbi_base + PCIE_PHY_DEBUG_R1));\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic irqreturn_t imx6_pcie_msi_handler(int irq, void *arg)\r\n{\r\nstruct pcie_port *pp = arg;\r\nreturn dw_handle_msi_irq(pp);\r\n}\r\nstatic int imx6_pcie_start_link(struct pcie_port *pp)\r\n{\r\nstruct imx6_pcie *imx6_pcie = to_imx6_pcie(pp);\r\nuint32_t tmp;\r\nint ret, count;\r\ntmp = readl(pp->dbi_base + PCIE_RC_LCR);\r\ntmp &= ~PCIE_RC_LCR_MAX_LINK_SPEEDS_MASK;\r\ntmp |= PCIE_RC_LCR_MAX_LINK_SPEEDS_GEN1;\r\nwritel(tmp, pp->dbi_base + PCIE_RC_LCR);\r\nregmap_update_bits(imx6_pcie->iomuxc_gpr, IOMUXC_GPR12,\r\nIMX6Q_GPR12_PCIE_CTL_2, 1 << 10);\r\nret = imx6_pcie_wait_for_link(pp);\r\nif (ret)\r\nreturn ret;\r\ntmp = readl(pp->dbi_base + PCIE_RC_LCR);\r\ntmp &= ~PCIE_RC_LCR_MAX_LINK_SPEEDS_MASK;\r\ntmp |= PCIE_RC_LCR_MAX_LINK_SPEEDS_GEN2;\r\nwritel(tmp, pp->dbi_base + PCIE_RC_LCR);\r\ntmp = readl(pp->dbi_base + PCIE_LINK_WIDTH_SPEED_CONTROL);\r\ntmp |= PORT_LOGIC_SPEED_CHANGE;\r\nwritel(tmp, pp->dbi_base + PCIE_LINK_WIDTH_SPEED_CONTROL);\r\ncount = 200;\r\nwhile (count--) {\r\ntmp = readl(pp->dbi_base + PCIE_LINK_WIDTH_SPEED_CONTROL);\r\nif (!(tmp & PORT_LOGIC_SPEED_CHANGE))\r\nbreak;\r\nusleep_range(100, 1000);\r\n}\r\nif (count)\r\nret = imx6_pcie_wait_for_link(pp);\r\nelse\r\nret = -EINVAL;\r\nif (ret) {\r\ndev_err(pp->dev, "Failed to bring link up!\n");\r\n} else {\r\ntmp = readl(pp->dbi_base + 0x80);\r\ndev_dbg(pp->dev, "Link up, Gen=%i\n", (tmp >> 16) & 0xf);\r\n}\r\nreturn ret;\r\n}\r\nstatic void imx6_pcie_host_init(struct pcie_port *pp)\r\n{\r\nimx6_pcie_assert_core_reset(pp);\r\nimx6_pcie_init_phy(pp);\r\nimx6_pcie_deassert_core_reset(pp);\r\ndw_pcie_setup_rc(pp);\r\nimx6_pcie_start_link(pp);\r\nif (IS_ENABLED(CONFIG_PCI_MSI))\r\ndw_pcie_msi_init(pp);\r\n}\r\nstatic void imx6_pcie_reset_phy(struct pcie_port *pp)\r\n{\r\nuint32_t temp;\r\npcie_phy_read(pp->dbi_base, PHY_RX_OVRD_IN_LO, &temp);\r\ntemp |= (PHY_RX_OVRD_IN_LO_RX_DATA_EN |\r\nPHY_RX_OVRD_IN_LO_RX_PLL_EN);\r\npcie_phy_write(pp->dbi_base, PHY_RX_OVRD_IN_LO, temp);\r\nusleep_range(2000, 3000);\r\npcie_phy_read(pp->dbi_base, PHY_RX_OVRD_IN_LO, &temp);\r\ntemp &= ~(PHY_RX_OVRD_IN_LO_RX_DATA_EN |\r\nPHY_RX_OVRD_IN_LO_RX_PLL_EN);\r\npcie_phy_write(pp->dbi_base, PHY_RX_OVRD_IN_LO, temp);\r\n}\r\nstatic int imx6_pcie_link_up(struct pcie_port *pp)\r\n{\r\nu32 rc, debug_r0, rx_valid;\r\nint count = 5;\r\nwhile (1) {\r\nrc = readl(pp->dbi_base + PCIE_PHY_DEBUG_R1);\r\nif (!(rc & PCIE_PHY_DEBUG_R1_XMLH_LINK_UP))\r\nbreak;\r\nif (!(rc & PCIE_PHY_DEBUG_R1_XMLH_LINK_IN_TRAINING))\r\nreturn 1;\r\nif (!count--)\r\nbreak;\r\ndev_dbg(pp->dev, "Link is up, but still in training\n");\r\nusleep_range(1000, 2000);\r\n}\r\npcie_phy_read(pp->dbi_base, PCIE_PHY_RX_ASIC_OUT, &rx_valid);\r\ndebug_r0 = readl(pp->dbi_base + PCIE_PHY_DEBUG_R0);\r\nif (rx_valid & 0x01)\r\nreturn 0;\r\nif ((debug_r0 & 0x3f) != 0x0d)\r\nreturn 0;\r\ndev_err(pp->dev, "transition to gen2 is stuck, reset PHY!\n");\r\ndev_dbg(pp->dev, "debug_r0=%08x debug_r1=%08x\n", debug_r0, rc);\r\nimx6_pcie_reset_phy(pp);\r\nreturn 0;\r\n}\r\nstatic int __init imx6_add_pcie_port(struct pcie_port *pp,\r\nstruct platform_device *pdev)\r\n{\r\nint ret;\r\nif (IS_ENABLED(CONFIG_PCI_MSI)) {\r\npp->msi_irq = platform_get_irq_byname(pdev, "msi");\r\nif (pp->msi_irq <= 0) {\r\ndev_err(&pdev->dev, "failed to get MSI irq\n");\r\nreturn -ENODEV;\r\n}\r\nret = devm_request_irq(&pdev->dev, pp->msi_irq,\r\nimx6_pcie_msi_handler,\r\nIRQF_SHARED, "mx6-pcie-msi", pp);\r\nif (ret) {\r\ndev_err(&pdev->dev, "failed to request MSI irq\n");\r\nreturn -ENODEV;\r\n}\r\n}\r\npp->root_bus_nr = -1;\r\npp->ops = &imx6_pcie_host_ops;\r\nret = dw_pcie_host_init(pp);\r\nif (ret) {\r\ndev_err(&pdev->dev, "failed to initialize host\n");\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init imx6_pcie_probe(struct platform_device *pdev)\r\n{\r\nstruct imx6_pcie *imx6_pcie;\r\nstruct pcie_port *pp;\r\nstruct device_node *np = pdev->dev.of_node;\r\nstruct resource *dbi_base;\r\nint ret;\r\nimx6_pcie = devm_kzalloc(&pdev->dev, sizeof(*imx6_pcie), GFP_KERNEL);\r\nif (!imx6_pcie)\r\nreturn -ENOMEM;\r\npp = &imx6_pcie->pp;\r\npp->dev = &pdev->dev;\r\nhook_fault_code(16 + 6, imx6q_pcie_abort_handler, SIGBUS, 0,\r\n"imprecise external abort");\r\ndbi_base = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\npp->dbi_base = devm_ioremap_resource(&pdev->dev, dbi_base);\r\nif (IS_ERR(pp->dbi_base))\r\nreturn PTR_ERR(pp->dbi_base);\r\nimx6_pcie->reset_gpio = of_get_named_gpio(np, "reset-gpio", 0);\r\nif (gpio_is_valid(imx6_pcie->reset_gpio)) {\r\nret = devm_gpio_request_one(&pdev->dev, imx6_pcie->reset_gpio,\r\nGPIOF_OUT_INIT_LOW, "PCIe reset");\r\nif (ret) {\r\ndev_err(&pdev->dev, "unable to get reset gpio\n");\r\nreturn ret;\r\n}\r\n}\r\nimx6_pcie->pcie_phy = devm_clk_get(&pdev->dev, "pcie_phy");\r\nif (IS_ERR(imx6_pcie->pcie_phy)) {\r\ndev_err(&pdev->dev,\r\n"pcie_phy clock source missing or invalid\n");\r\nreturn PTR_ERR(imx6_pcie->pcie_phy);\r\n}\r\nimx6_pcie->pcie_bus = devm_clk_get(&pdev->dev, "pcie_bus");\r\nif (IS_ERR(imx6_pcie->pcie_bus)) {\r\ndev_err(&pdev->dev,\r\n"pcie_bus clock source missing or invalid\n");\r\nreturn PTR_ERR(imx6_pcie->pcie_bus);\r\n}\r\nimx6_pcie->pcie = devm_clk_get(&pdev->dev, "pcie");\r\nif (IS_ERR(imx6_pcie->pcie)) {\r\ndev_err(&pdev->dev,\r\n"pcie clock source missing or invalid\n");\r\nreturn PTR_ERR(imx6_pcie->pcie);\r\n}\r\nimx6_pcie->iomuxc_gpr =\r\nsyscon_regmap_lookup_by_compatible("fsl,imx6q-iomuxc-gpr");\r\nif (IS_ERR(imx6_pcie->iomuxc_gpr)) {\r\ndev_err(&pdev->dev, "unable to find iomuxc registers\n");\r\nreturn PTR_ERR(imx6_pcie->iomuxc_gpr);\r\n}\r\nret = imx6_add_pcie_port(pp, pdev);\r\nif (ret < 0)\r\nreturn ret;\r\nplatform_set_drvdata(pdev, imx6_pcie);\r\nreturn 0;\r\n}\r\nstatic void imx6_pcie_shutdown(struct platform_device *pdev)\r\n{\r\nstruct imx6_pcie *imx6_pcie = platform_get_drvdata(pdev);\r\nimx6_pcie_assert_core_reset(&imx6_pcie->pp);\r\n}\r\nstatic int __init imx6_pcie_init(void)\r\n{\r\nreturn platform_driver_probe(&imx6_pcie_driver, imx6_pcie_probe);\r\n}
