static inline void pcm1796_write_spi(struct oxygen *chip, unsigned int codec,\r\nu8 reg, u8 value)\r\n{\r\nstatic const u8 codec_map[4] = {\r\n0, 1, 2, 4\r\n};\r\noxygen_write_spi(chip, OXYGEN_SPI_TRIGGER |\r\nOXYGEN_SPI_DATA_LENGTH_2 |\r\nOXYGEN_SPI_CLOCK_160 |\r\n(codec_map[codec] << OXYGEN_SPI_CODEC_SHIFT) |\r\nOXYGEN_SPI_CEN_LATCH_CLOCK_HI,\r\n(reg << 8) | value);\r\n}\r\nstatic inline void pcm1796_write_i2c(struct oxygen *chip, unsigned int codec,\r\nu8 reg, u8 value)\r\n{\r\noxygen_write_i2c(chip, I2C_DEVICE_PCM1796(codec), reg, value);\r\n}\r\nstatic void pcm1796_write(struct oxygen *chip, unsigned int codec,\r\nu8 reg, u8 value)\r\n{\r\nstruct xonar_pcm179x *data = chip->model_data;\r\nif ((chip->model.function_flags & OXYGEN_FUNCTION_2WIRE_SPI_MASK) ==\r\nOXYGEN_FUNCTION_SPI)\r\npcm1796_write_spi(chip, codec, reg, value);\r\nelse\r\npcm1796_write_i2c(chip, codec, reg, value);\r\nif ((unsigned int)(reg - PCM1796_REG_BASE)\r\n< ARRAY_SIZE(data->pcm1796_regs[codec]))\r\ndata->pcm1796_regs[codec][reg - PCM1796_REG_BASE] = value;\r\n}\r\nstatic void pcm1796_write_cached(struct oxygen *chip, unsigned int codec,\r\nu8 reg, u8 value)\r\n{\r\nstruct xonar_pcm179x *data = chip->model_data;\r\nif (value != data->pcm1796_regs[codec][reg - PCM1796_REG_BASE])\r\npcm1796_write(chip, codec, reg, value);\r\n}\r\nstatic void cs2000_write(struct oxygen *chip, u8 reg, u8 value)\r\n{\r\nstruct xonar_pcm179x *data = chip->model_data;\r\noxygen_write_i2c(chip, I2C_DEVICE_CS2000, reg, value);\r\ndata->cs2000_regs[reg] = value;\r\n}\r\nstatic void cs2000_write_cached(struct oxygen *chip, u8 reg, u8 value)\r\n{\r\nstruct xonar_pcm179x *data = chip->model_data;\r\nif (value != data->cs2000_regs[reg])\r\ncs2000_write(chip, reg, value);\r\n}\r\nstatic void pcm1796_registers_init(struct oxygen *chip)\r\n{\r\nstruct xonar_pcm179x *data = chip->model_data;\r\nunsigned int i;\r\ns8 gain_offset;\r\nmsleep(1);\r\ngain_offset = data->hp_active ? data->hp_gain_offset : 0;\r\nfor (i = 0; i < data->dacs; ++i) {\r\npcm1796_write(chip, i, 18,\r\ndata->pcm1796_regs[0][18 - PCM1796_REG_BASE]);\r\npcm1796_write(chip, i, 16, chip->dac_volume[i * 2]\r\n+ gain_offset);\r\npcm1796_write(chip, i, 17, chip->dac_volume[i * 2 + 1]\r\n+ gain_offset);\r\npcm1796_write(chip, i, 19,\r\ndata->pcm1796_regs[0][19 - PCM1796_REG_BASE]);\r\npcm1796_write(chip, i, 20,\r\ndata->pcm1796_regs[0][20 - PCM1796_REG_BASE]);\r\npcm1796_write(chip, i, 21, 0);\r\ngain_offset = 0;\r\n}\r\n}\r\nstatic void pcm1796_init(struct oxygen *chip)\r\n{\r\nstruct xonar_pcm179x *data = chip->model_data;\r\ndata->pcm1796_regs[0][18 - PCM1796_REG_BASE] =\r\nPCM1796_DMF_DISABLED | PCM1796_FMT_24_I2S | PCM1796_ATLD;\r\nif (!data->broken_i2c)\r\ndata->pcm1796_regs[0][18 - PCM1796_REG_BASE] |= PCM1796_MUTE;\r\ndata->pcm1796_regs[0][19 - PCM1796_REG_BASE] =\r\nPCM1796_FLT_SHARP | PCM1796_ATS_1;\r\ndata->pcm1796_regs[0][20 - PCM1796_REG_BASE] =\r\ndata->h6 ? PCM1796_OS_64 : PCM1796_OS_128;\r\npcm1796_registers_init(chip);\r\ndata->current_rate = 48000;\r\n}\r\nstatic void xonar_d2_init(struct oxygen *chip)\r\n{\r\nstruct xonar_pcm179x *data = chip->model_data;\r\ndata->generic.anti_pop_delay = 300;\r\ndata->generic.output_enable_bit = GPIO_D2_OUTPUT_ENABLE;\r\ndata->dacs = 4;\r\npcm1796_init(chip);\r\noxygen_set_bits16(chip, OXYGEN_GPIO_CONTROL, GPIO_D2_ALT);\r\noxygen_clear_bits16(chip, OXYGEN_GPIO_DATA, GPIO_D2_ALT);\r\noxygen_ac97_set_bits(chip, 0, CM9780_JACK, CM9780_FMIC2MIC);\r\nxonar_init_cs53x1(chip);\r\nxonar_enable_output(chip);\r\nsnd_component_add(chip->card, "PCM1796");\r\nsnd_component_add(chip->card, "CS5381");\r\n}\r\nstatic void xonar_d2x_init(struct oxygen *chip)\r\n{\r\nstruct xonar_pcm179x *data = chip->model_data;\r\ndata->generic.ext_power_reg = OXYGEN_GPIO_DATA;\r\ndata->generic.ext_power_int_reg = OXYGEN_GPIO_INTERRUPT_MASK;\r\ndata->generic.ext_power_bit = GPIO_D2X_EXT_POWER;\r\noxygen_clear_bits16(chip, OXYGEN_GPIO_CONTROL, GPIO_D2X_EXT_POWER);\r\nxonar_init_ext_power(chip);\r\nxonar_d2_init(chip);\r\n}\r\nstatic void xonar_hdav_init(struct oxygen *chip)\r\n{\r\nstruct xonar_hdav *data = chip->model_data;\r\noxygen_write16(chip, OXYGEN_2WIRE_BUS_STATUS,\r\nOXYGEN_2WIRE_LENGTH_8 |\r\nOXYGEN_2WIRE_INTERRUPT_MASK |\r\nOXYGEN_2WIRE_SPEED_STANDARD);\r\ndata->pcm179x.generic.anti_pop_delay = 100;\r\ndata->pcm179x.generic.output_enable_bit = GPIO_HDAV_OUTPUT_ENABLE;\r\ndata->pcm179x.generic.ext_power_reg = OXYGEN_GPI_DATA;\r\ndata->pcm179x.generic.ext_power_int_reg = OXYGEN_GPI_INTERRUPT_MASK;\r\ndata->pcm179x.generic.ext_power_bit = GPI_EXT_POWER;\r\ndata->pcm179x.dacs = chip->model.dac_channels_mixer / 2;\r\ndata->pcm179x.h6 = chip->model.dac_channels_mixer > 2;\r\npcm1796_init(chip);\r\noxygen_set_bits16(chip, OXYGEN_GPIO_CONTROL,\r\nGPIO_HDAV_MAGIC | GPIO_INPUT_ROUTE);\r\noxygen_clear_bits16(chip, OXYGEN_GPIO_DATA, GPIO_INPUT_ROUTE);\r\nxonar_init_cs53x1(chip);\r\nxonar_init_ext_power(chip);\r\nxonar_hdmi_init(chip, &data->hdmi);\r\nxonar_enable_output(chip);\r\nsnd_component_add(chip->card, "PCM1796");\r\nsnd_component_add(chip->card, "CS5381");\r\n}\r\nstatic void xonar_st_init_i2c(struct oxygen *chip)\r\n{\r\noxygen_write16(chip, OXYGEN_2WIRE_BUS_STATUS,\r\nOXYGEN_2WIRE_LENGTH_8 |\r\nOXYGEN_2WIRE_INTERRUPT_MASK |\r\nOXYGEN_2WIRE_SPEED_STANDARD);\r\n}\r\nstatic void xonar_st_init_common(struct oxygen *chip)\r\n{\r\nstruct xonar_pcm179x *data = chip->model_data;\r\ndata->generic.output_enable_bit = GPIO_ST_OUTPUT_ENABLE;\r\ndata->dacs = chip->model.dac_channels_mixer / 2;\r\ndata->h6 = chip->model.dac_channels_mixer > 2;\r\ndata->hp_gain_offset = 2*-18;\r\npcm1796_init(chip);\r\noxygen_set_bits16(chip, OXYGEN_GPIO_CONTROL,\r\nGPIO_INPUT_ROUTE | GPIO_ST_HP_REAR |\r\nGPIO_ST_MAGIC | GPIO_ST_HP);\r\noxygen_clear_bits16(chip, OXYGEN_GPIO_DATA,\r\nGPIO_INPUT_ROUTE | GPIO_ST_HP_REAR | GPIO_ST_HP);\r\nxonar_init_cs53x1(chip);\r\nxonar_enable_output(chip);\r\nsnd_component_add(chip->card, "PCM1792A");\r\nsnd_component_add(chip->card, "CS5381");\r\n}\r\nstatic void cs2000_registers_init(struct oxygen *chip)\r\n{\r\nstruct xonar_pcm179x *data = chip->model_data;\r\ncs2000_write(chip, CS2000_GLOBAL_CFG, CS2000_FREEZE);\r\ncs2000_write(chip, CS2000_DEV_CTRL, 0);\r\ncs2000_write(chip, CS2000_DEV_CFG_1,\r\nCS2000_R_MOD_SEL_1 |\r\n(0 << CS2000_R_SEL_SHIFT) |\r\nCS2000_AUX_OUT_SRC_REF_CLK |\r\nCS2000_EN_DEV_CFG_1);\r\ncs2000_write(chip, CS2000_DEV_CFG_2,\r\n(0 << CS2000_LOCK_CLK_SHIFT) |\r\nCS2000_FRAC_N_SRC_STATIC);\r\ncs2000_write(chip, CS2000_RATIO_0 + 0, 0x00);\r\ncs2000_write(chip, CS2000_RATIO_0 + 1, 0x10);\r\ncs2000_write(chip, CS2000_RATIO_0 + 2, 0x00);\r\ncs2000_write(chip, CS2000_RATIO_0 + 3, 0x00);\r\ncs2000_write(chip, CS2000_FUN_CFG_1,\r\ndata->cs2000_regs[CS2000_FUN_CFG_1]);\r\ncs2000_write(chip, CS2000_FUN_CFG_2, 0);\r\ncs2000_write(chip, CS2000_GLOBAL_CFG, CS2000_EN_DEV_CFG_2);\r\nmsleep(3);\r\n}\r\nstatic void xonar_st_init(struct oxygen *chip)\r\n{\r\nstruct xonar_pcm179x *data = chip->model_data;\r\ndata->generic.anti_pop_delay = 100;\r\ndata->h6 = chip->model.dac_channels_mixer > 2;\r\ndata->has_cs2000 = 1;\r\ndata->cs2000_regs[CS2000_FUN_CFG_1] = CS2000_REF_CLK_DIV_1;\r\ndata->broken_i2c = true;\r\noxygen_write16(chip, OXYGEN_I2S_A_FORMAT,\r\nOXYGEN_RATE_48000 |\r\nOXYGEN_I2S_FORMAT_I2S |\r\nOXYGEN_I2S_MCLK(data->h6 ? MCLK_256 : MCLK_512) |\r\nOXYGEN_I2S_BITS_16 |\r\nOXYGEN_I2S_MASTER |\r\nOXYGEN_I2S_BCLK_64);\r\nxonar_st_init_i2c(chip);\r\ncs2000_registers_init(chip);\r\nxonar_st_init_common(chip);\r\nsnd_component_add(chip->card, "CS2000");\r\n}\r\nstatic void xonar_stx_init(struct oxygen *chip)\r\n{\r\nstruct xonar_pcm179x *data = chip->model_data;\r\nxonar_st_init_i2c(chip);\r\ndata->generic.anti_pop_delay = 800;\r\ndata->generic.ext_power_reg = OXYGEN_GPI_DATA;\r\ndata->generic.ext_power_int_reg = OXYGEN_GPI_INTERRUPT_MASK;\r\ndata->generic.ext_power_bit = GPI_EXT_POWER;\r\nxonar_init_ext_power(chip);\r\nxonar_st_init_common(chip);\r\n}\r\nstatic void xonar_xense_init(struct oxygen *chip)\r\n{\r\nstruct xonar_pcm179x *data = chip->model_data;\r\ndata->generic.ext_power_reg = OXYGEN_GPI_DATA;\r\ndata->generic.ext_power_int_reg = OXYGEN_GPI_INTERRUPT_MASK;\r\ndata->generic.ext_power_bit = GPI_EXT_POWER;\r\nxonar_init_ext_power(chip);\r\ndata->generic.anti_pop_delay = 100;\r\ndata->has_cs2000 = 1;\r\ndata->cs2000_regs[CS2000_FUN_CFG_1] = CS2000_REF_CLK_DIV_1;\r\noxygen_write16(chip, OXYGEN_I2S_A_FORMAT,\r\nOXYGEN_RATE_48000 |\r\nOXYGEN_I2S_FORMAT_I2S |\r\nOXYGEN_I2S_MCLK(MCLK_512) |\r\nOXYGEN_I2S_BITS_16 |\r\nOXYGEN_I2S_MASTER |\r\nOXYGEN_I2S_BCLK_64);\r\nxonar_st_init_i2c(chip);\r\ncs2000_registers_init(chip);\r\ndata->generic.output_enable_bit = GPIO_XENSE_OUTPUT_ENABLE;\r\ndata->dacs = 1;\r\ndata->hp_gain_offset = 2*-18;\r\npcm1796_init(chip);\r\noxygen_set_bits16(chip, OXYGEN_GPIO_CONTROL,\r\nGPIO_INPUT_ROUTE | GPIO_ST_HP_REAR |\r\nGPIO_ST_MAGIC | GPIO_XENSE_SPEAKERS);\r\noxygen_clear_bits16(chip, OXYGEN_GPIO_DATA,\r\nGPIO_INPUT_ROUTE | GPIO_ST_HP_REAR |\r\nGPIO_XENSE_SPEAKERS);\r\nxonar_init_cs53x1(chip);\r\nxonar_enable_output(chip);\r\nsnd_component_add(chip->card, "PCM1796");\r\nsnd_component_add(chip->card, "CS5381");\r\nsnd_component_add(chip->card, "CS2000");\r\n}\r\nstatic void xonar_d2_cleanup(struct oxygen *chip)\r\n{\r\nxonar_disable_output(chip);\r\n}\r\nstatic void xonar_hdav_cleanup(struct oxygen *chip)\r\n{\r\nxonar_hdmi_cleanup(chip);\r\nxonar_disable_output(chip);\r\nmsleep(2);\r\n}\r\nstatic void xonar_st_cleanup(struct oxygen *chip)\r\n{\r\nxonar_disable_output(chip);\r\n}\r\nstatic void xonar_d2_suspend(struct oxygen *chip)\r\n{\r\nxonar_d2_cleanup(chip);\r\n}\r\nstatic void xonar_hdav_suspend(struct oxygen *chip)\r\n{\r\nxonar_hdav_cleanup(chip);\r\n}\r\nstatic void xonar_st_suspend(struct oxygen *chip)\r\n{\r\nxonar_st_cleanup(chip);\r\n}\r\nstatic void xonar_d2_resume(struct oxygen *chip)\r\n{\r\npcm1796_registers_init(chip);\r\nxonar_enable_output(chip);\r\n}\r\nstatic void xonar_hdav_resume(struct oxygen *chip)\r\n{\r\nstruct xonar_hdav *data = chip->model_data;\r\npcm1796_registers_init(chip);\r\nxonar_hdmi_resume(chip, &data->hdmi);\r\nxonar_enable_output(chip);\r\n}\r\nstatic void xonar_stx_resume(struct oxygen *chip)\r\n{\r\npcm1796_registers_init(chip);\r\nxonar_enable_output(chip);\r\n}\r\nstatic void xonar_st_resume(struct oxygen *chip)\r\n{\r\ncs2000_registers_init(chip);\r\nxonar_stx_resume(chip);\r\n}\r\nstatic void update_pcm1796_oversampling(struct oxygen *chip)\r\n{\r\nstruct xonar_pcm179x *data = chip->model_data;\r\nunsigned int i;\r\nu8 reg;\r\nif (data->current_rate <= 48000 && !data->h6)\r\nreg = PCM1796_OS_128;\r\nelse\r\nreg = PCM1796_OS_64;\r\nfor (i = 0; i < data->dacs; ++i)\r\npcm1796_write_cached(chip, i, 20, reg);\r\n}\r\nstatic void set_pcm1796_params(struct oxygen *chip,\r\nstruct snd_pcm_hw_params *params)\r\n{\r\nstruct xonar_pcm179x *data = chip->model_data;\r\nmsleep(1);\r\ndata->current_rate = params_rate(params);\r\nupdate_pcm1796_oversampling(chip);\r\n}\r\nstatic void update_pcm1796_volume(struct oxygen *chip)\r\n{\r\nstruct xonar_pcm179x *data = chip->model_data;\r\nunsigned int i;\r\ns8 gain_offset;\r\ngain_offset = data->hp_active ? data->hp_gain_offset : 0;\r\nfor (i = 0; i < data->dacs; ++i) {\r\npcm1796_write_cached(chip, i, 16, chip->dac_volume[i * 2]\r\n+ gain_offset);\r\npcm1796_write_cached(chip, i, 17, chip->dac_volume[i * 2 + 1]\r\n+ gain_offset);\r\ngain_offset = 0;\r\n}\r\n}\r\nstatic void update_pcm1796_mute(struct oxygen *chip)\r\n{\r\nstruct xonar_pcm179x *data = chip->model_data;\r\nunsigned int i;\r\nu8 value;\r\nvalue = PCM1796_DMF_DISABLED | PCM1796_FMT_24_I2S | PCM1796_ATLD;\r\nif (chip->dac_mute)\r\nvalue |= PCM1796_MUTE;\r\nfor (i = 0; i < data->dacs; ++i)\r\npcm1796_write_cached(chip, i, 18, value);\r\n}\r\nstatic void update_cs2000_rate(struct oxygen *chip, unsigned int rate)\r\n{\r\nstruct xonar_pcm179x *data = chip->model_data;\r\nu8 rate_mclk, reg;\r\nswitch (rate) {\r\ncase 32000:\r\ncase 64000:\r\nrate_mclk = OXYGEN_RATE_32000;\r\nbreak;\r\ncase 44100:\r\ncase 88200:\r\ncase 176400:\r\nrate_mclk = OXYGEN_RATE_44100;\r\nbreak;\r\ndefault:\r\ncase 48000:\r\ncase 96000:\r\ncase 192000:\r\nrate_mclk = OXYGEN_RATE_48000;\r\nbreak;\r\n}\r\nif (rate <= 96000 && (rate > 48000 || data->h6)) {\r\nrate_mclk |= OXYGEN_I2S_MCLK(MCLK_256);\r\nreg = CS2000_REF_CLK_DIV_1;\r\n} else {\r\nrate_mclk |= OXYGEN_I2S_MCLK(MCLK_512);\r\nreg = CS2000_REF_CLK_DIV_2;\r\n}\r\noxygen_write16_masked(chip, OXYGEN_I2S_A_FORMAT, rate_mclk,\r\nOXYGEN_I2S_RATE_MASK | OXYGEN_I2S_MCLK_MASK);\r\ncs2000_write_cached(chip, CS2000_FUN_CFG_1, reg);\r\nmsleep(3);\r\n}\r\nstatic void set_st_params(struct oxygen *chip,\r\nstruct snd_pcm_hw_params *params)\r\n{\r\nupdate_cs2000_rate(chip, params_rate(params));\r\nset_pcm1796_params(chip, params);\r\n}\r\nstatic void set_hdav_params(struct oxygen *chip,\r\nstruct snd_pcm_hw_params *params)\r\n{\r\nstruct xonar_hdav *data = chip->model_data;\r\nset_pcm1796_params(chip, params);\r\nxonar_set_hdmi_params(chip, &data->hdmi, params);\r\n}\r\nstatic int rolloff_info(struct snd_kcontrol *ctl,\r\nstruct snd_ctl_elem_info *info)\r\n{\r\nstatic const char *const names[2] = {\r\n"Sharp Roll-off", "Slow Roll-off"\r\n};\r\nreturn snd_ctl_enum_info(info, 1, 2, names);\r\n}\r\nstatic int rolloff_get(struct snd_kcontrol *ctl,\r\nstruct snd_ctl_elem_value *value)\r\n{\r\nstruct oxygen *chip = ctl->private_data;\r\nstruct xonar_pcm179x *data = chip->model_data;\r\nvalue->value.enumerated.item[0] =\r\n(data->pcm1796_regs[0][19 - PCM1796_REG_BASE] &\r\nPCM1796_FLT_MASK) != PCM1796_FLT_SHARP;\r\nreturn 0;\r\n}\r\nstatic int rolloff_put(struct snd_kcontrol *ctl,\r\nstruct snd_ctl_elem_value *value)\r\n{\r\nstruct oxygen *chip = ctl->private_data;\r\nstruct xonar_pcm179x *data = chip->model_data;\r\nunsigned int i;\r\nint changed;\r\nu8 reg;\r\nmutex_lock(&chip->mutex);\r\nreg = data->pcm1796_regs[0][19 - PCM1796_REG_BASE];\r\nreg &= ~PCM1796_FLT_MASK;\r\nif (!value->value.enumerated.item[0])\r\nreg |= PCM1796_FLT_SHARP;\r\nelse\r\nreg |= PCM1796_FLT_SLOW;\r\nchanged = reg != data->pcm1796_regs[0][19 - PCM1796_REG_BASE];\r\nif (changed) {\r\nfor (i = 0; i < data->dacs; ++i)\r\npcm1796_write(chip, i, 19, reg);\r\n}\r\nmutex_unlock(&chip->mutex);\r\nreturn changed;\r\n}\r\nstatic int st_output_switch_info(struct snd_kcontrol *ctl,\r\nstruct snd_ctl_elem_info *info)\r\n{\r\nstatic const char *const names[3] = {\r\n"Speakers", "Headphones", "FP Headphones"\r\n};\r\nreturn snd_ctl_enum_info(info, 1, 3, names);\r\n}\r\nstatic int st_output_switch_get(struct snd_kcontrol *ctl,\r\nstruct snd_ctl_elem_value *value)\r\n{\r\nstruct oxygen *chip = ctl->private_data;\r\nu16 gpio;\r\ngpio = oxygen_read16(chip, OXYGEN_GPIO_DATA);\r\nif (!(gpio & GPIO_ST_HP))\r\nvalue->value.enumerated.item[0] = 0;\r\nelse if (gpio & GPIO_ST_HP_REAR)\r\nvalue->value.enumerated.item[0] = 1;\r\nelse\r\nvalue->value.enumerated.item[0] = 2;\r\nreturn 0;\r\n}\r\nstatic int st_output_switch_put(struct snd_kcontrol *ctl,\r\nstruct snd_ctl_elem_value *value)\r\n{\r\nstruct oxygen *chip = ctl->private_data;\r\nstruct xonar_pcm179x *data = chip->model_data;\r\nu16 gpio_old, gpio;\r\nmutex_lock(&chip->mutex);\r\ngpio_old = oxygen_read16(chip, OXYGEN_GPIO_DATA);\r\ngpio = gpio_old;\r\nswitch (value->value.enumerated.item[0]) {\r\ncase 0:\r\ngpio &= ~(GPIO_ST_HP | GPIO_ST_HP_REAR);\r\nbreak;\r\ncase 1:\r\ngpio |= GPIO_ST_HP | GPIO_ST_HP_REAR;\r\nbreak;\r\ncase 2:\r\ngpio = (gpio | GPIO_ST_HP) & ~GPIO_ST_HP_REAR;\r\nbreak;\r\n}\r\noxygen_write16(chip, OXYGEN_GPIO_DATA, gpio);\r\ndata->hp_active = gpio & GPIO_ST_HP;\r\nupdate_pcm1796_volume(chip);\r\nmutex_unlock(&chip->mutex);\r\nreturn gpio != gpio_old;\r\n}\r\nstatic int st_hp_volume_offset_info(struct snd_kcontrol *ctl,\r\nstruct snd_ctl_elem_info *info)\r\n{\r\nstatic const char *const names[4] = {\r\n"< 32 ohms", "32-64 ohms", "64-300 ohms", "300-600 ohms"\r\n};\r\nreturn snd_ctl_enum_info(info, 1, 4, names);\r\n}\r\nstatic int st_hp_volume_offset_get(struct snd_kcontrol *ctl,\r\nstruct snd_ctl_elem_value *value)\r\n{\r\nstruct oxygen *chip = ctl->private_data;\r\nstruct xonar_pcm179x *data = chip->model_data;\r\nmutex_lock(&chip->mutex);\r\nif (data->hp_gain_offset < 2*-12)\r\nvalue->value.enumerated.item[0] = 0;\r\nelse if (data->hp_gain_offset < 2*-6)\r\nvalue->value.enumerated.item[0] = 1;\r\nelse if (data->hp_gain_offset < 0)\r\nvalue->value.enumerated.item[0] = 2;\r\nelse\r\nvalue->value.enumerated.item[0] = 3;\r\nmutex_unlock(&chip->mutex);\r\nreturn 0;\r\n}\r\nstatic int st_hp_volume_offset_put(struct snd_kcontrol *ctl,\r\nstruct snd_ctl_elem_value *value)\r\n{\r\nstatic const s8 offsets[] = { 2*-18, 2*-12, 2*-6, 0 };\r\nstruct oxygen *chip = ctl->private_data;\r\nstruct xonar_pcm179x *data = chip->model_data;\r\ns8 offset;\r\nint changed;\r\nif (value->value.enumerated.item[0] > 3)\r\nreturn -EINVAL;\r\noffset = offsets[value->value.enumerated.item[0]];\r\nmutex_lock(&chip->mutex);\r\nchanged = offset != data->hp_gain_offset;\r\nif (changed) {\r\ndata->hp_gain_offset = offset;\r\nupdate_pcm1796_volume(chip);\r\n}\r\nmutex_unlock(&chip->mutex);\r\nreturn changed;\r\n}\r\nstatic int xense_output_switch_get(struct snd_kcontrol *ctl,\r\nstruct snd_ctl_elem_value *value)\r\n{\r\nstruct oxygen *chip = ctl->private_data;\r\nu16 gpio;\r\ngpio = oxygen_read16(chip, OXYGEN_GPIO_DATA);\r\nif (gpio & GPIO_XENSE_SPEAKERS)\r\nvalue->value.enumerated.item[0] = 0;\r\nelse if (!(gpio & GPIO_XENSE_SPEAKERS) && (gpio & GPIO_ST_HP_REAR))\r\nvalue->value.enumerated.item[0] = 1;\r\nelse\r\nvalue->value.enumerated.item[0] = 2;\r\nreturn 0;\r\n}\r\nstatic int xense_output_switch_put(struct snd_kcontrol *ctl,\r\nstruct snd_ctl_elem_value *value)\r\n{\r\nstruct oxygen *chip = ctl->private_data;\r\nstruct xonar_pcm179x *data = chip->model_data;\r\nu16 gpio_old, gpio;\r\nmutex_lock(&chip->mutex);\r\ngpio_old = oxygen_read16(chip, OXYGEN_GPIO_DATA);\r\ngpio = gpio_old;\r\nswitch (value->value.enumerated.item[0]) {\r\ncase 0:\r\ngpio |= GPIO_XENSE_SPEAKERS | GPIO_ST_HP_REAR;\r\nbreak;\r\ncase 1:\r\ngpio = (gpio | GPIO_ST_HP_REAR) & ~GPIO_XENSE_SPEAKERS;\r\nbreak;\r\ncase 2:\r\ngpio &= ~(GPIO_XENSE_SPEAKERS | GPIO_ST_HP_REAR);\r\nbreak;\r\n}\r\noxygen_write16(chip, OXYGEN_GPIO_DATA, gpio);\r\ndata->hp_active = !(gpio & GPIO_XENSE_SPEAKERS);\r\nupdate_pcm1796_volume(chip);\r\nmutex_unlock(&chip->mutex);\r\nreturn gpio != gpio_old;\r\n}\r\nstatic void xonar_line_mic_ac97_switch(struct oxygen *chip,\r\nunsigned int reg, unsigned int mute)\r\n{\r\nif (reg == AC97_LINE) {\r\nspin_lock_irq(&chip->reg_lock);\r\noxygen_write16_masked(chip, OXYGEN_GPIO_DATA,\r\nmute ? GPIO_INPUT_ROUTE : 0,\r\nGPIO_INPUT_ROUTE);\r\nspin_unlock_irq(&chip->reg_lock);\r\n}\r\n}\r\nstatic int xonar_d2_control_filter(struct snd_kcontrol_new *template)\r\n{\r\nif (!strncmp(template->name, "CD Capture ", 11))\r\ntemplate->private_value ^= AC97_CD ^ AC97_VIDEO;\r\nreturn 0;\r\n}\r\nstatic int xonar_st_h6_control_filter(struct snd_kcontrol_new *template)\r\n{\r\nif (!strncmp(template->name, "Master Playback ", 16))\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic int add_pcm1796_controls(struct oxygen *chip)\r\n{\r\nstruct xonar_pcm179x *data = chip->model_data;\r\nint err;\r\nif (!data->broken_i2c) {\r\nerr = snd_ctl_add(chip->card,\r\nsnd_ctl_new1(&rolloff_control, chip));\r\nif (err < 0)\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic int xonar_d2_mixer_init(struct oxygen *chip)\r\n{\r\nint err;\r\nerr = snd_ctl_add(chip->card, snd_ctl_new1(&alt_switch, chip));\r\nif (err < 0)\r\nreturn err;\r\nerr = add_pcm1796_controls(chip);\r\nif (err < 0)\r\nreturn err;\r\nreturn 0;\r\n}\r\nstatic int xonar_hdav_mixer_init(struct oxygen *chip)\r\n{\r\nint err;\r\nerr = snd_ctl_add(chip->card, snd_ctl_new1(&hdav_hdmi_control, chip));\r\nif (err < 0)\r\nreturn err;\r\nerr = add_pcm1796_controls(chip);\r\nif (err < 0)\r\nreturn err;\r\nreturn 0;\r\n}\r\nstatic int xonar_st_mixer_init(struct oxygen *chip)\r\n{\r\nunsigned int i;\r\nint err;\r\nfor (i = 0; i < ARRAY_SIZE(st_controls); ++i) {\r\nerr = snd_ctl_add(chip->card,\r\nsnd_ctl_new1(&st_controls[i], chip));\r\nif (err < 0)\r\nreturn err;\r\n}\r\nerr = add_pcm1796_controls(chip);\r\nif (err < 0)\r\nreturn err;\r\nreturn 0;\r\n}\r\nstatic int xonar_xense_mixer_init(struct oxygen *chip)\r\n{\r\nunsigned int i;\r\nint err;\r\nfor (i = 0; i < ARRAY_SIZE(xense_controls); ++i) {\r\nerr = snd_ctl_add(chip->card,\r\nsnd_ctl_new1(&xense_controls[i], chip));\r\nif (err < 0)\r\nreturn err;\r\n}\r\nerr = add_pcm1796_controls(chip);\r\nif (err < 0)\r\nreturn err;\r\nreturn 0;\r\n}\r\nstatic void dump_pcm1796_registers(struct oxygen *chip,\r\nstruct snd_info_buffer *buffer)\r\n{\r\nstruct xonar_pcm179x *data = chip->model_data;\r\nunsigned int dac, i;\r\nfor (dac = 0; dac < data->dacs; ++dac) {\r\nsnd_iprintf(buffer, "\nPCM1796 %u:", dac + 1);\r\nfor (i = 0; i < 5; ++i)\r\nsnd_iprintf(buffer, " %02x",\r\ndata->pcm1796_regs[dac][i]);\r\n}\r\nsnd_iprintf(buffer, "\n");\r\n}\r\nstatic void dump_cs2000_registers(struct oxygen *chip,\r\nstruct snd_info_buffer *buffer)\r\n{\r\nstruct xonar_pcm179x *data = chip->model_data;\r\nunsigned int i;\r\nif (data->has_cs2000) {\r\nsnd_iprintf(buffer, "\nCS2000:\n00: ");\r\nfor (i = 1; i < 0x10; ++i)\r\nsnd_iprintf(buffer, " %02x", data->cs2000_regs[i]);\r\nsnd_iprintf(buffer, "\n10:");\r\nfor (i = 0x10; i < 0x1f; ++i)\r\nsnd_iprintf(buffer, " %02x", data->cs2000_regs[i]);\r\nsnd_iprintf(buffer, "\n");\r\n}\r\n}\r\nstatic void dump_st_registers(struct oxygen *chip,\r\nstruct snd_info_buffer *buffer)\r\n{\r\ndump_pcm1796_registers(chip, buffer);\r\ndump_cs2000_registers(chip, buffer);\r\n}\r\nint get_xonar_pcm179x_model(struct oxygen *chip,\r\nconst struct pci_device_id *id)\r\n{\r\nswitch (id->subdevice) {\r\ncase 0x8269:\r\nchip->model = model_xonar_d2;\r\nchip->model.shortname = "Xonar D2";\r\nbreak;\r\ncase 0x82b7:\r\nchip->model = model_xonar_d2;\r\nchip->model.shortname = "Xonar D2X";\r\nchip->model.init = xonar_d2x_init;\r\nbreak;\r\ncase 0x8314:\r\nchip->model = model_xonar_hdav;\r\noxygen_clear_bits16(chip, OXYGEN_GPIO_CONTROL, GPIO_DB_MASK);\r\nswitch (oxygen_read16(chip, OXYGEN_GPIO_DATA) & GPIO_DB_MASK) {\r\ndefault:\r\nchip->model.shortname = "Xonar HDAV1.3";\r\nbreak;\r\ncase GPIO_DB_H6:\r\nchip->model.shortname = "Xonar HDAV1.3+H6";\r\nchip->model.dac_channels_mixer = 8;\r\nchip->model.dac_mclks = OXYGEN_MCLKS(256, 128, 128);\r\nbreak;\r\n}\r\nbreak;\r\ncase 0x835d:\r\nchip->model = model_xonar_st;\r\noxygen_clear_bits16(chip, OXYGEN_GPIO_CONTROL, GPIO_DB_MASK);\r\nswitch (oxygen_read16(chip, OXYGEN_GPIO_DATA) & GPIO_DB_MASK) {\r\ndefault:\r\nchip->model.shortname = "Xonar ST";\r\nbreak;\r\ncase GPIO_DB_H6:\r\nchip->model.shortname = "Xonar ST+H6";\r\nchip->model.control_filter = xonar_st_h6_control_filter;\r\nchip->model.dac_channels_pcm = 8;\r\nchip->model.dac_channels_mixer = 8;\r\nchip->model.dac_volume_min = 255;\r\nchip->model.dac_mclks = OXYGEN_MCLKS(256, 128, 128);\r\nbreak;\r\n}\r\nbreak;\r\ncase 0x835c:\r\nchip->model = model_xonar_st;\r\nchip->model.shortname = "Xonar STX";\r\nchip->model.init = xonar_stx_init;\r\nchip->model.resume = xonar_stx_resume;\r\nchip->model.set_dac_params = set_pcm1796_params;\r\nbreak;\r\ncase 0x85f4:\r\nchip->model = model_xonar_st;\r\noxygen_clear_bits16(chip, OXYGEN_GPIO_CONTROL, GPIO_DB_MASK);\r\nswitch (oxygen_read16(chip, OXYGEN_GPIO_DATA) & GPIO_DB_MASK) {\r\ndefault:\r\nchip->model.shortname = "Xonar STX II";\r\nbreak;\r\ncase GPIO_DB_H6:\r\nchip->model.shortname = "Xonar STX II+H6";\r\nchip->model.dac_channels_pcm = 8;\r\nchip->model.dac_channels_mixer = 8;\r\nchip->model.dac_mclks = OXYGEN_MCLKS(256, 128, 128);\r\nbreak;\r\n}\r\nchip->model.init = xonar_stx_init;\r\nchip->model.resume = xonar_stx_resume;\r\nchip->model.set_dac_params = set_pcm1796_params;\r\nbreak;\r\ncase 0x8428:\r\nchip->model = model_xonar_st;\r\nchip->model.shortname = "Xonar Xense";\r\nchip->model.chip = "AV100";\r\nchip->model.init = xonar_xense_init;\r\nchip->model.mixer_init = xonar_xense_mixer_init;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}
