static int tsc2005_cmd(struct tsc2005 *ts, u8 cmd)\r\n{\r\nu8 tx = TSC2005_CMD | TSC2005_CMD_12BIT | cmd;\r\nstruct spi_transfer xfer = {\r\n.tx_buf = &tx,\r\n.len = 1,\r\n.bits_per_word = 8,\r\n};\r\nstruct spi_message msg;\r\nint error;\r\nspi_message_init(&msg);\r\nspi_message_add_tail(&xfer, &msg);\r\nerror = spi_sync(ts->spi, &msg);\r\nif (error) {\r\ndev_err(&ts->spi->dev, "%s: failed, command: %x, error: %d\n",\r\n__func__, cmd, error);\r\nreturn error;\r\n}\r\nreturn 0;\r\n}\r\nstatic int tsc2005_write(struct tsc2005 *ts, u8 reg, u16 value)\r\n{\r\nu32 tx = ((reg | TSC2005_REG_PND0) << 16) | value;\r\nstruct spi_transfer xfer = {\r\n.tx_buf = &tx,\r\n.len = 4,\r\n.bits_per_word = 24,\r\n};\r\nstruct spi_message msg;\r\nint error;\r\nspi_message_init(&msg);\r\nspi_message_add_tail(&xfer, &msg);\r\nerror = spi_sync(ts->spi, &msg);\r\nif (error) {\r\ndev_err(&ts->spi->dev,\r\n"%s: failed, register: %x, value: %x, error: %d\n",\r\n__func__, reg, value, error);\r\nreturn error;\r\n}\r\nreturn 0;\r\n}\r\nstatic void tsc2005_setup_read(struct tsc2005_spi_rd *rd, u8 reg, bool last)\r\n{\r\nmemset(rd, 0, sizeof(*rd));\r\nrd->spi_tx = (reg | TSC2005_REG_READ) << 16;\r\nrd->spi_xfer.tx_buf = &rd->spi_tx;\r\nrd->spi_xfer.rx_buf = &rd->spi_rx;\r\nrd->spi_xfer.len = 4;\r\nrd->spi_xfer.bits_per_word = 24;\r\nrd->spi_xfer.cs_change = !last;\r\n}\r\nstatic int tsc2005_read(struct tsc2005 *ts, u8 reg, u16 *value)\r\n{\r\nstruct tsc2005_spi_rd spi_rd;\r\nstruct spi_message msg;\r\nint error;\r\ntsc2005_setup_read(&spi_rd, reg, true);\r\nspi_message_init(&msg);\r\nspi_message_add_tail(&spi_rd.spi_xfer, &msg);\r\nerror = spi_sync(ts->spi, &msg);\r\nif (error)\r\nreturn error;\r\n*value = spi_rd.spi_rx;\r\nreturn 0;\r\n}\r\nstatic void tsc2005_update_pen_state(struct tsc2005 *ts,\r\nint x, int y, int pressure)\r\n{\r\nif (pressure) {\r\ninput_report_abs(ts->idev, ABS_X, x);\r\ninput_report_abs(ts->idev, ABS_Y, y);\r\ninput_report_abs(ts->idev, ABS_PRESSURE, pressure);\r\nif (!ts->pen_down) {\r\ninput_report_key(ts->idev, BTN_TOUCH, !!pressure);\r\nts->pen_down = true;\r\n}\r\n} else {\r\ninput_report_abs(ts->idev, ABS_PRESSURE, 0);\r\nif (ts->pen_down) {\r\ninput_report_key(ts->idev, BTN_TOUCH, 0);\r\nts->pen_down = false;\r\n}\r\n}\r\ninput_sync(ts->idev);\r\ndev_dbg(&ts->spi->dev, "point(%4d,%4d), pressure (%4d)\n", x, y,\r\npressure);\r\n}\r\nstatic irqreturn_t tsc2005_irq_thread(int irq, void *_ts)\r\n{\r\nstruct tsc2005 *ts = _ts;\r\nunsigned long flags;\r\nunsigned int pressure;\r\nu32 x, y;\r\nu32 z1, z2;\r\nint error;\r\nerror = spi_sync(ts->spi, &ts->spi_read_msg);\r\nif (unlikely(error))\r\ngoto out;\r\nx = ts->spi_x.spi_rx;\r\ny = ts->spi_y.spi_rx;\r\nz1 = ts->spi_z1.spi_rx;\r\nz2 = ts->spi_z2.spi_rx;\r\nif (unlikely(x > MAX_12BIT || y > MAX_12BIT))\r\ngoto out;\r\nif (unlikely(z1 == 0 || z2 > MAX_12BIT || z1 >= z2))\r\ngoto out;\r\nif (!ts->pen_down &&\r\nts->in_x == x && ts->in_y == y &&\r\nts->in_z1 == z1 && ts->in_z2 == z2) {\r\ngoto out;\r\n}\r\nts->in_x = x;\r\nts->in_y = y;\r\nts->in_z1 = z1;\r\nts->in_z2 = z2;\r\npressure = x * (z2 - z1) / z1;\r\npressure = pressure * ts->x_plate_ohm / 4096;\r\nif (unlikely(pressure > MAX_12BIT))\r\ngoto out;\r\nspin_lock_irqsave(&ts->lock, flags);\r\ntsc2005_update_pen_state(ts, x, y, pressure);\r\nmod_timer(&ts->penup_timer,\r\njiffies + msecs_to_jiffies(TSC2005_PENUP_TIME_MS));\r\nspin_unlock_irqrestore(&ts->lock, flags);\r\nts->last_valid_interrupt = jiffies;\r\nout:\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void tsc2005_penup_timer(unsigned long data)\r\n{\r\nstruct tsc2005 *ts = (struct tsc2005 *)data;\r\nunsigned long flags;\r\nspin_lock_irqsave(&ts->lock, flags);\r\ntsc2005_update_pen_state(ts, 0, 0, 0);\r\nspin_unlock_irqrestore(&ts->lock, flags);\r\n}\r\nstatic void tsc2005_start_scan(struct tsc2005 *ts)\r\n{\r\ntsc2005_write(ts, TSC2005_REG_CFR0, TSC2005_CFR0_INITVALUE);\r\ntsc2005_write(ts, TSC2005_REG_CFR1, TSC2005_CFR1_INITVALUE);\r\ntsc2005_write(ts, TSC2005_REG_CFR2, TSC2005_CFR2_INITVALUE);\r\ntsc2005_cmd(ts, TSC2005_CMD_NORMAL);\r\n}\r\nstatic void tsc2005_stop_scan(struct tsc2005 *ts)\r\n{\r\ntsc2005_cmd(ts, TSC2005_CMD_STOP);\r\n}\r\nstatic void tsc2005_set_reset(struct tsc2005 *ts, bool enable)\r\n{\r\nif (ts->reset_gpio >= 0)\r\ngpio_set_value(ts->reset_gpio, enable);\r\nelse if (ts->set_reset)\r\nts->set_reset(enable);\r\n}\r\nstatic void __tsc2005_disable(struct tsc2005 *ts)\r\n{\r\ntsc2005_stop_scan(ts);\r\ndisable_irq(ts->spi->irq);\r\ndel_timer_sync(&ts->penup_timer);\r\ncancel_delayed_work_sync(&ts->esd_work);\r\nenable_irq(ts->spi->irq);\r\n}\r\nstatic void __tsc2005_enable(struct tsc2005 *ts)\r\n{\r\ntsc2005_start_scan(ts);\r\nif (ts->esd_timeout && (ts->set_reset || ts->reset_gpio)) {\r\nts->last_valid_interrupt = jiffies;\r\nschedule_delayed_work(&ts->esd_work,\r\nround_jiffies_relative(\r\nmsecs_to_jiffies(ts->esd_timeout)));\r\n}\r\n}\r\nstatic ssize_t tsc2005_selftest_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct spi_device *spi = to_spi_device(dev);\r\nstruct tsc2005 *ts = spi_get_drvdata(spi);\r\nu16 temp_high;\r\nu16 temp_high_orig;\r\nu16 temp_high_test;\r\nbool success = true;\r\nint error;\r\nmutex_lock(&ts->mutex);\r\n__tsc2005_disable(ts);\r\nerror = tsc2005_read(ts, TSC2005_REG_TEMP_HIGH, &temp_high_orig);\r\nif (error) {\r\ndev_warn(dev, "selftest failed: read error %d\n", error);\r\nsuccess = false;\r\ngoto out;\r\n}\r\ntemp_high_test = (temp_high_orig - 1) & MAX_12BIT;\r\nerror = tsc2005_write(ts, TSC2005_REG_TEMP_HIGH, temp_high_test);\r\nif (error) {\r\ndev_warn(dev, "selftest failed: write error %d\n", error);\r\nsuccess = false;\r\ngoto out;\r\n}\r\nerror = tsc2005_read(ts, TSC2005_REG_TEMP_HIGH, &temp_high);\r\nif (error) {\r\ndev_warn(dev, "selftest failed: read error %d after write\n",\r\nerror);\r\nsuccess = false;\r\ngoto out;\r\n}\r\nif (temp_high != temp_high_test) {\r\ndev_warn(dev, "selftest failed: %d != %d\n",\r\ntemp_high, temp_high_test);\r\nsuccess = false;\r\n}\r\ntsc2005_set_reset(ts, false);\r\nusleep_range(100, 500);\r\ntsc2005_set_reset(ts, true);\r\nif (!success)\r\ngoto out;\r\nerror = tsc2005_read(ts, TSC2005_REG_TEMP_HIGH, &temp_high);\r\nif (error) {\r\ndev_warn(dev, "selftest failed: read error %d after reset\n",\r\nerror);\r\nsuccess = false;\r\ngoto out;\r\n}\r\nif (temp_high != temp_high_orig) {\r\ndev_warn(dev, "selftest failed after reset: %d != %d\n",\r\ntemp_high, temp_high_orig);\r\nsuccess = false;\r\n}\r\nout:\r\n__tsc2005_enable(ts);\r\nmutex_unlock(&ts->mutex);\r\nreturn sprintf(buf, "%d\n", success);\r\n}\r\nstatic umode_t tsc2005_attr_is_visible(struct kobject *kobj,\r\nstruct attribute *attr, int n)\r\n{\r\nstruct device *dev = container_of(kobj, struct device, kobj);\r\nstruct spi_device *spi = to_spi_device(dev);\r\nstruct tsc2005 *ts = spi_get_drvdata(spi);\r\numode_t mode = attr->mode;\r\nif (attr == &dev_attr_selftest.attr) {\r\nif (!ts->set_reset && !ts->reset_gpio)\r\nmode = 0;\r\n}\r\nreturn mode;\r\n}\r\nstatic void tsc2005_esd_work(struct work_struct *work)\r\n{\r\nstruct tsc2005 *ts = container_of(work, struct tsc2005, esd_work.work);\r\nint error;\r\nu16 r;\r\nif (!mutex_trylock(&ts->mutex)) {\r\ngoto reschedule;\r\n}\r\nif (time_is_after_jiffies(ts->last_valid_interrupt +\r\nmsecs_to_jiffies(ts->esd_timeout)))\r\ngoto out;\r\nerror = tsc2005_read(ts, TSC2005_REG_CFR0, &r);\r\nif (!error &&\r\n!((r ^ TSC2005_CFR0_INITVALUE) & TSC2005_CFR0_RW_MASK)) {\r\ngoto out;\r\n}\r\ndev_info(&ts->spi->dev, "TSC2005 not responding - resetting\n");\r\ndisable_irq(ts->spi->irq);\r\ndel_timer_sync(&ts->penup_timer);\r\ntsc2005_update_pen_state(ts, 0, 0, 0);\r\ntsc2005_set_reset(ts, false);\r\nusleep_range(100, 500);\r\ntsc2005_set_reset(ts, true);\r\nenable_irq(ts->spi->irq);\r\ntsc2005_start_scan(ts);\r\nout:\r\nmutex_unlock(&ts->mutex);\r\nreschedule:\r\nschedule_delayed_work(&ts->esd_work,\r\nround_jiffies_relative(\r\nmsecs_to_jiffies(ts->esd_timeout)));\r\n}\r\nstatic int tsc2005_open(struct input_dev *input)\r\n{\r\nstruct tsc2005 *ts = input_get_drvdata(input);\r\nmutex_lock(&ts->mutex);\r\nif (!ts->suspended)\r\n__tsc2005_enable(ts);\r\nts->opened = true;\r\nmutex_unlock(&ts->mutex);\r\nreturn 0;\r\n}\r\nstatic void tsc2005_close(struct input_dev *input)\r\n{\r\nstruct tsc2005 *ts = input_get_drvdata(input);\r\nmutex_lock(&ts->mutex);\r\nif (!ts->suspended)\r\n__tsc2005_disable(ts);\r\nts->opened = false;\r\nmutex_unlock(&ts->mutex);\r\n}\r\nstatic void tsc2005_setup_spi_xfer(struct tsc2005 *ts)\r\n{\r\ntsc2005_setup_read(&ts->spi_x, TSC2005_REG_X, false);\r\ntsc2005_setup_read(&ts->spi_y, TSC2005_REG_Y, false);\r\ntsc2005_setup_read(&ts->spi_z1, TSC2005_REG_Z1, false);\r\ntsc2005_setup_read(&ts->spi_z2, TSC2005_REG_Z2, true);\r\nspi_message_init(&ts->spi_read_msg);\r\nspi_message_add_tail(&ts->spi_x.spi_xfer, &ts->spi_read_msg);\r\nspi_message_add_tail(&ts->spi_y.spi_xfer, &ts->spi_read_msg);\r\nspi_message_add_tail(&ts->spi_z1.spi_xfer, &ts->spi_read_msg);\r\nspi_message_add_tail(&ts->spi_z2.spi_xfer, &ts->spi_read_msg);\r\n}\r\nstatic int tsc2005_probe(struct spi_device *spi)\r\n{\r\nconst struct tsc2005_platform_data *pdata = dev_get_platdata(&spi->dev);\r\nstruct device_node *np = spi->dev.of_node;\r\nstruct tsc2005 *ts;\r\nstruct input_dev *input_dev;\r\nunsigned int max_x = MAX_12BIT;\r\nunsigned int max_y = MAX_12BIT;\r\nunsigned int max_p = MAX_12BIT;\r\nunsigned int fudge_x = TSC2005_DEF_X_FUZZ;\r\nunsigned int fudge_y = TSC2005_DEF_Y_FUZZ;\r\nunsigned int fudge_p = TSC2005_DEF_P_FUZZ;\r\nunsigned int x_plate_ohm = TSC2005_DEF_RESISTOR;\r\nunsigned int esd_timeout;\r\nint error;\r\nif (!np && !pdata) {\r\ndev_err(&spi->dev, "no platform data\n");\r\nreturn -ENODEV;\r\n}\r\nif (spi->irq <= 0) {\r\ndev_err(&spi->dev, "no irq\n");\r\nreturn -ENODEV;\r\n}\r\nif (pdata) {\r\nfudge_x = pdata->ts_x_fudge;\r\nfudge_y = pdata->ts_y_fudge;\r\nfudge_p = pdata->ts_pressure_fudge;\r\nmax_x = pdata->ts_x_max;\r\nmax_y = pdata->ts_y_max;\r\nmax_p = pdata->ts_pressure_max;\r\nx_plate_ohm = pdata->ts_x_plate_ohm;\r\nesd_timeout = pdata->esd_timeout_ms;\r\n} else {\r\nx_plate_ohm = TSC2005_DEF_RESISTOR;\r\nof_property_read_u32(np, "ti,x-plate-ohms", &x_plate_ohm);\r\nesd_timeout = 0;\r\nof_property_read_u32(np, "ti,esd-recovery-timeout-ms",\r\n&esd_timeout);\r\n}\r\nspi->mode = SPI_MODE_0;\r\nspi->bits_per_word = 8;\r\nif (!spi->max_speed_hz)\r\nspi->max_speed_hz = TSC2005_SPI_MAX_SPEED_HZ;\r\nerror = spi_setup(spi);\r\nif (error)\r\nreturn error;\r\nts = devm_kzalloc(&spi->dev, sizeof(*ts), GFP_KERNEL);\r\nif (!ts)\r\nreturn -ENOMEM;\r\ninput_dev = devm_input_allocate_device(&spi->dev);\r\nif (!input_dev)\r\nreturn -ENOMEM;\r\nts->spi = spi;\r\nts->idev = input_dev;\r\nts->x_plate_ohm = x_plate_ohm;\r\nts->esd_timeout = esd_timeout;\r\nif (np) {\r\nts->reset_gpio = of_get_named_gpio(np, "reset-gpios", 0);\r\nif (ts->reset_gpio == -EPROBE_DEFER)\r\nreturn ts->reset_gpio;\r\nif (ts->reset_gpio < 0) {\r\ndev_err(&spi->dev, "error acquiring reset gpio: %d\n",\r\nts->reset_gpio);\r\nreturn ts->reset_gpio;\r\n}\r\nerror = devm_gpio_request_one(&spi->dev, ts->reset_gpio, 0,\r\n"reset-gpios");\r\nif (error) {\r\ndev_err(&spi->dev, "error requesting reset gpio: %d\n",\r\nerror);\r\nreturn error;\r\n}\r\nts->vio = devm_regulator_get(&spi->dev, "vio");\r\nif (IS_ERR(ts->vio)) {\r\nerror = PTR_ERR(ts->vio);\r\ndev_err(&spi->dev, "vio regulator missing (%d)", error);\r\nreturn error;\r\n}\r\n} else {\r\nts->reset_gpio = -1;\r\nts->set_reset = pdata->set_reset;\r\n}\r\nmutex_init(&ts->mutex);\r\nspin_lock_init(&ts->lock);\r\nsetup_timer(&ts->penup_timer, tsc2005_penup_timer, (unsigned long)ts);\r\nINIT_DELAYED_WORK(&ts->esd_work, tsc2005_esd_work);\r\ntsc2005_setup_spi_xfer(ts);\r\nsnprintf(ts->phys, sizeof(ts->phys),\r\n"%s/input-ts", dev_name(&spi->dev));\r\ninput_dev->name = "TSC2005 touchscreen";\r\ninput_dev->phys = ts->phys;\r\ninput_dev->id.bustype = BUS_SPI;\r\ninput_dev->dev.parent = &spi->dev;\r\ninput_dev->evbit[0] = BIT(EV_ABS) | BIT(EV_KEY);\r\ninput_dev->keybit[BIT_WORD(BTN_TOUCH)] = BIT_MASK(BTN_TOUCH);\r\ninput_set_abs_params(input_dev, ABS_X, 0, max_x, fudge_x, 0);\r\ninput_set_abs_params(input_dev, ABS_Y, 0, max_y, fudge_y, 0);\r\ninput_set_abs_params(input_dev, ABS_PRESSURE, 0, max_p, fudge_p, 0);\r\nif (np)\r\ntouchscreen_parse_of_params(input_dev);\r\ninput_dev->open = tsc2005_open;\r\ninput_dev->close = tsc2005_close;\r\ninput_set_drvdata(input_dev, ts);\r\ntsc2005_stop_scan(ts);\r\nerror = devm_request_threaded_irq(&spi->dev, spi->irq, NULL,\r\ntsc2005_irq_thread,\r\nIRQF_TRIGGER_RISING | IRQF_ONESHOT,\r\n"tsc2005", ts);\r\nif (error) {\r\ndev_err(&spi->dev, "Failed to request irq, err: %d\n", error);\r\nreturn error;\r\n}\r\nif (ts->vio) {\r\nerror = regulator_enable(ts->vio);\r\nif (error)\r\nreturn error;\r\n}\r\nspi_set_drvdata(spi, ts);\r\nerror = sysfs_create_group(&spi->dev.kobj, &tsc2005_attr_group);\r\nif (error) {\r\ndev_err(&spi->dev,\r\n"Failed to create sysfs attributes, err: %d\n", error);\r\ngoto disable_regulator;\r\n}\r\nerror = input_register_device(ts->idev);\r\nif (error) {\r\ndev_err(&spi->dev,\r\n"Failed to register input device, err: %d\n", error);\r\ngoto err_remove_sysfs;\r\n}\r\nirq_set_irq_wake(spi->irq, 1);\r\nreturn 0;\r\nerr_remove_sysfs:\r\nsysfs_remove_group(&spi->dev.kobj, &tsc2005_attr_group);\r\ndisable_regulator:\r\nif (ts->vio)\r\nregulator_disable(ts->vio);\r\nreturn error;\r\n}\r\nstatic int tsc2005_remove(struct spi_device *spi)\r\n{\r\nstruct tsc2005 *ts = spi_get_drvdata(spi);\r\nsysfs_remove_group(&spi->dev.kobj, &tsc2005_attr_group);\r\nif (ts->vio)\r\nregulator_disable(ts->vio);\r\nreturn 0;\r\n}\r\nstatic int __maybe_unused tsc2005_suspend(struct device *dev)\r\n{\r\nstruct spi_device *spi = to_spi_device(dev);\r\nstruct tsc2005 *ts = spi_get_drvdata(spi);\r\nmutex_lock(&ts->mutex);\r\nif (!ts->suspended && ts->opened)\r\n__tsc2005_disable(ts);\r\nts->suspended = true;\r\nmutex_unlock(&ts->mutex);\r\nreturn 0;\r\n}\r\nstatic int __maybe_unused tsc2005_resume(struct device *dev)\r\n{\r\nstruct spi_device *spi = to_spi_device(dev);\r\nstruct tsc2005 *ts = spi_get_drvdata(spi);\r\nmutex_lock(&ts->mutex);\r\nif (ts->suspended && ts->opened)\r\n__tsc2005_enable(ts);\r\nts->suspended = false;\r\nmutex_unlock(&ts->mutex);\r\nreturn 0;\r\n}
