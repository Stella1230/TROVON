static int set_target(struct cpufreq_policy *policy, unsigned int index)\r\n{\r\nstruct dev_pm_opp *opp;\r\nstruct cpufreq_frequency_table *freq_table = policy->freq_table;\r\nstruct clk *cpu_clk = policy->clk;\r\nstruct private_data *priv = policy->driver_data;\r\nstruct device *cpu_dev = priv->cpu_dev;\r\nstruct regulator *cpu_reg = priv->cpu_reg;\r\nunsigned long volt = 0, volt_old = 0, tol = 0;\r\nunsigned int old_freq, new_freq;\r\nlong freq_Hz, freq_exact;\r\nint ret;\r\nfreq_Hz = clk_round_rate(cpu_clk, freq_table[index].frequency * 1000);\r\nif (freq_Hz <= 0)\r\nfreq_Hz = freq_table[index].frequency * 1000;\r\nfreq_exact = freq_Hz;\r\nnew_freq = freq_Hz / 1000;\r\nold_freq = clk_get_rate(cpu_clk) / 1000;\r\nif (!IS_ERR(cpu_reg)) {\r\nunsigned long opp_freq;\r\nrcu_read_lock();\r\nopp = dev_pm_opp_find_freq_ceil(cpu_dev, &freq_Hz);\r\nif (IS_ERR(opp)) {\r\nrcu_read_unlock();\r\ndev_err(cpu_dev, "failed to find OPP for %ld\n",\r\nfreq_Hz);\r\nreturn PTR_ERR(opp);\r\n}\r\nvolt = dev_pm_opp_get_voltage(opp);\r\nopp_freq = dev_pm_opp_get_freq(opp);\r\nrcu_read_unlock();\r\ntol = volt * priv->voltage_tolerance / 100;\r\nvolt_old = regulator_get_voltage(cpu_reg);\r\ndev_dbg(cpu_dev, "Found OPP: %ld kHz, %ld uV\n",\r\nopp_freq / 1000, volt);\r\n}\r\ndev_dbg(cpu_dev, "%u MHz, %ld mV --> %u MHz, %ld mV\n",\r\nold_freq / 1000, (volt_old > 0) ? volt_old / 1000 : -1,\r\nnew_freq / 1000, volt ? volt / 1000 : -1);\r\nif (!IS_ERR(cpu_reg) && new_freq > old_freq) {\r\nret = regulator_set_voltage_tol(cpu_reg, volt, tol);\r\nif (ret) {\r\ndev_err(cpu_dev, "failed to scale voltage up: %d\n",\r\nret);\r\nreturn ret;\r\n}\r\n}\r\nret = clk_set_rate(cpu_clk, freq_exact);\r\nif (ret) {\r\ndev_err(cpu_dev, "failed to set clock rate: %d\n", ret);\r\nif (!IS_ERR(cpu_reg) && volt_old > 0)\r\nregulator_set_voltage_tol(cpu_reg, volt_old, tol);\r\nreturn ret;\r\n}\r\nif (!IS_ERR(cpu_reg) && new_freq < old_freq) {\r\nret = regulator_set_voltage_tol(cpu_reg, volt, tol);\r\nif (ret) {\r\ndev_err(cpu_dev, "failed to scale voltage down: %d\n",\r\nret);\r\nclk_set_rate(cpu_clk, old_freq * 1000);\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic int allocate_resources(int cpu, struct device **cdev,\r\nstruct regulator **creg, struct clk **cclk)\r\n{\r\nstruct device *cpu_dev;\r\nstruct regulator *cpu_reg;\r\nstruct clk *cpu_clk;\r\nint ret = 0;\r\nchar *reg_cpu0 = "cpu0", *reg_cpu = "cpu", *reg;\r\ncpu_dev = get_cpu_device(cpu);\r\nif (!cpu_dev) {\r\npr_err("failed to get cpu%d device\n", cpu);\r\nreturn -ENODEV;\r\n}\r\nif (!cpu)\r\nreg = reg_cpu0;\r\nelse\r\nreg = reg_cpu;\r\ntry_again:\r\ncpu_reg = regulator_get_optional(cpu_dev, reg);\r\nif (IS_ERR(cpu_reg)) {\r\nif (PTR_ERR(cpu_reg) == -EPROBE_DEFER) {\r\ndev_dbg(cpu_dev, "cpu%d regulator not ready, retry\n",\r\ncpu);\r\nreturn -EPROBE_DEFER;\r\n}\r\nif (reg == reg_cpu0) {\r\nreg = reg_cpu;\r\ngoto try_again;\r\n}\r\ndev_dbg(cpu_dev, "no regulator for cpu%d: %ld\n",\r\ncpu, PTR_ERR(cpu_reg));\r\n}\r\ncpu_clk = clk_get(cpu_dev, NULL);\r\nif (IS_ERR(cpu_clk)) {\r\nif (!IS_ERR(cpu_reg))\r\nregulator_put(cpu_reg);\r\nret = PTR_ERR(cpu_clk);\r\nif (ret == -EPROBE_DEFER)\r\ndev_dbg(cpu_dev, "cpu%d clock not ready, retry\n", cpu);\r\nelse\r\ndev_err(cpu_dev, "failed to get cpu%d clock: %d\n", cpu,\r\nret);\r\n} else {\r\n*cdev = cpu_dev;\r\n*creg = cpu_reg;\r\n*cclk = cpu_clk;\r\n}\r\nreturn ret;\r\n}\r\nstatic int cpufreq_init(struct cpufreq_policy *policy)\r\n{\r\nstruct cpufreq_dt_platform_data *pd;\r\nstruct cpufreq_frequency_table *freq_table;\r\nstruct device_node *np;\r\nstruct private_data *priv;\r\nstruct device *cpu_dev;\r\nstruct regulator *cpu_reg;\r\nstruct clk *cpu_clk;\r\nunsigned long min_uV = ~0, max_uV = 0;\r\nunsigned int transition_latency;\r\nint ret;\r\nret = allocate_resources(policy->cpu, &cpu_dev, &cpu_reg, &cpu_clk);\r\nif (ret) {\r\npr_err("%s: Failed to allocate resources: %d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nnp = of_node_get(cpu_dev->of_node);\r\nif (!np) {\r\ndev_err(cpu_dev, "failed to find cpu%d node\n", policy->cpu);\r\nret = -ENOENT;\r\ngoto out_put_reg_clk;\r\n}\r\nof_init_opp_table(cpu_dev);\r\nret = dev_pm_opp_get_opp_count(cpu_dev);\r\nif (ret <= 0) {\r\npr_debug("OPP table is not ready, deferring probe\n");\r\nret = -EPROBE_DEFER;\r\ngoto out_free_opp;\r\n}\r\npriv = kzalloc(sizeof(*priv), GFP_KERNEL);\r\nif (!priv) {\r\nret = -ENOMEM;\r\ngoto out_free_opp;\r\n}\r\nof_property_read_u32(np, "voltage-tolerance", &priv->voltage_tolerance);\r\nif (of_property_read_u32(np, "clock-latency", &transition_latency))\r\ntransition_latency = CPUFREQ_ETERNAL;\r\nif (!IS_ERR(cpu_reg)) {\r\nunsigned long opp_freq = 0;\r\nwhile (1) {\r\nstruct dev_pm_opp *opp;\r\nunsigned long opp_uV, tol_uV;\r\nrcu_read_lock();\r\nopp = dev_pm_opp_find_freq_ceil(cpu_dev, &opp_freq);\r\nif (IS_ERR(opp)) {\r\nrcu_read_unlock();\r\nbreak;\r\n}\r\nopp_uV = dev_pm_opp_get_voltage(opp);\r\nrcu_read_unlock();\r\ntol_uV = opp_uV * priv->voltage_tolerance / 100;\r\nif (regulator_is_supported_voltage(cpu_reg, opp_uV,\r\nopp_uV + tol_uV)) {\r\nif (opp_uV < min_uV)\r\nmin_uV = opp_uV;\r\nif (opp_uV > max_uV)\r\nmax_uV = opp_uV;\r\n} else {\r\ndev_pm_opp_disable(cpu_dev, opp_freq);\r\n}\r\nopp_freq++;\r\n}\r\nret = regulator_set_voltage_time(cpu_reg, min_uV, max_uV);\r\nif (ret > 0)\r\ntransition_latency += ret * 1000;\r\n}\r\nret = dev_pm_opp_init_cpufreq_table(cpu_dev, &freq_table);\r\nif (ret) {\r\npr_err("failed to init cpufreq table: %d\n", ret);\r\ngoto out_free_priv;\r\n}\r\npriv->cpu_dev = cpu_dev;\r\npriv->cpu_reg = cpu_reg;\r\npolicy->driver_data = priv;\r\npolicy->clk = cpu_clk;\r\nret = cpufreq_table_validate_and_show(policy, freq_table);\r\nif (ret) {\r\ndev_err(cpu_dev, "%s: invalid frequency table: %d\n", __func__,\r\nret);\r\ngoto out_free_cpufreq_table;\r\n}\r\npolicy->cpuinfo.transition_latency = transition_latency;\r\npd = cpufreq_get_driver_data();\r\nif (!pd || !pd->independent_clocks)\r\ncpumask_setall(policy->cpus);\r\nof_node_put(np);\r\nreturn 0;\r\nout_free_cpufreq_table:\r\ndev_pm_opp_free_cpufreq_table(cpu_dev, &freq_table);\r\nout_free_priv:\r\nkfree(priv);\r\nout_free_opp:\r\nof_free_opp_table(cpu_dev);\r\nof_node_put(np);\r\nout_put_reg_clk:\r\nclk_put(cpu_clk);\r\nif (!IS_ERR(cpu_reg))\r\nregulator_put(cpu_reg);\r\nreturn ret;\r\n}\r\nstatic int cpufreq_exit(struct cpufreq_policy *policy)\r\n{\r\nstruct private_data *priv = policy->driver_data;\r\ncpufreq_cooling_unregister(priv->cdev);\r\ndev_pm_opp_free_cpufreq_table(priv->cpu_dev, &policy->freq_table);\r\nof_free_opp_table(priv->cpu_dev);\r\nclk_put(policy->clk);\r\nif (!IS_ERR(priv->cpu_reg))\r\nregulator_put(priv->cpu_reg);\r\nkfree(priv);\r\nreturn 0;\r\n}\r\nstatic void cpufreq_ready(struct cpufreq_policy *policy)\r\n{\r\nstruct private_data *priv = policy->driver_data;\r\nstruct device_node *np = of_node_get(priv->cpu_dev->of_node);\r\nif (WARN_ON(!np))\r\nreturn;\r\nif (of_find_property(np, "#cooling-cells", NULL)) {\r\npriv->cdev = of_cpufreq_cooling_register(np,\r\npolicy->related_cpus);\r\nif (IS_ERR(priv->cdev)) {\r\ndev_err(priv->cpu_dev,\r\n"running cpufreq without cooling device: %ld\n",\r\nPTR_ERR(priv->cdev));\r\npriv->cdev = NULL;\r\n}\r\n}\r\nof_node_put(np);\r\n}\r\nstatic int dt_cpufreq_probe(struct platform_device *pdev)\r\n{\r\nstruct device *cpu_dev;\r\nstruct regulator *cpu_reg;\r\nstruct clk *cpu_clk;\r\nint ret;\r\nret = allocate_resources(0, &cpu_dev, &cpu_reg, &cpu_clk);\r\nif (ret)\r\nreturn ret;\r\nclk_put(cpu_clk);\r\nif (!IS_ERR(cpu_reg))\r\nregulator_put(cpu_reg);\r\ndt_cpufreq_driver.driver_data = dev_get_platdata(&pdev->dev);\r\nret = cpufreq_register_driver(&dt_cpufreq_driver);\r\nif (ret)\r\ndev_err(cpu_dev, "failed register driver: %d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int dt_cpufreq_remove(struct platform_device *pdev)\r\n{\r\ncpufreq_unregister_driver(&dt_cpufreq_driver);\r\nreturn 0;\r\n}
