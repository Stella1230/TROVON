void zpool_register_driver(struct zpool_driver *driver)\r\n{\r\nspin_lock(&drivers_lock);\r\natomic_set(&driver->refcount, 0);\r\nlist_add(&driver->list, &drivers_head);\r\nspin_unlock(&drivers_lock);\r\n}\r\nint zpool_unregister_driver(struct zpool_driver *driver)\r\n{\r\nint ret = 0, refcount;\r\nspin_lock(&drivers_lock);\r\nrefcount = atomic_read(&driver->refcount);\r\nWARN_ON(refcount < 0);\r\nif (refcount > 0)\r\nret = -EBUSY;\r\nelse\r\nlist_del(&driver->list);\r\nspin_unlock(&drivers_lock);\r\nreturn ret;\r\n}\r\nint zpool_evict(void *pool, unsigned long handle)\r\n{\r\nstruct zpool *zpool;\r\nspin_lock(&pools_lock);\r\nlist_for_each_entry(zpool, &pools_head, list) {\r\nif (zpool->pool == pool) {\r\nspin_unlock(&pools_lock);\r\nif (!zpool->ops || !zpool->ops->evict)\r\nreturn -EINVAL;\r\nreturn zpool->ops->evict(zpool, handle);\r\n}\r\n}\r\nspin_unlock(&pools_lock);\r\nreturn -ENOENT;\r\n}\r\nstatic struct zpool_driver *zpool_get_driver(char *type)\r\n{\r\nstruct zpool_driver *driver;\r\nspin_lock(&drivers_lock);\r\nlist_for_each_entry(driver, &drivers_head, list) {\r\nif (!strcmp(driver->type, type)) {\r\nbool got = try_module_get(driver->owner);\r\nif (got)\r\natomic_inc(&driver->refcount);\r\nspin_unlock(&drivers_lock);\r\nreturn got ? driver : NULL;\r\n}\r\n}\r\nspin_unlock(&drivers_lock);\r\nreturn NULL;\r\n}\r\nstatic void zpool_put_driver(struct zpool_driver *driver)\r\n{\r\natomic_dec(&driver->refcount);\r\nmodule_put(driver->owner);\r\n}\r\nstruct zpool *zpool_create_pool(char *type, char *name, gfp_t gfp,\r\nstruct zpool_ops *ops)\r\n{\r\nstruct zpool_driver *driver;\r\nstruct zpool *zpool;\r\npr_info("creating pool type %s\n", type);\r\ndriver = zpool_get_driver(type);\r\nif (!driver) {\r\nrequest_module("zpool-%s", type);\r\ndriver = zpool_get_driver(type);\r\n}\r\nif (!driver) {\r\npr_err("no driver for type %s\n", type);\r\nreturn NULL;\r\n}\r\nzpool = kmalloc(sizeof(*zpool), gfp);\r\nif (!zpool) {\r\npr_err("couldn't create zpool - out of memory\n");\r\nzpool_put_driver(driver);\r\nreturn NULL;\r\n}\r\nzpool->type = driver->type;\r\nzpool->driver = driver;\r\nzpool->pool = driver->create(name, gfp, ops);\r\nzpool->ops = ops;\r\nif (!zpool->pool) {\r\npr_err("couldn't create %s pool\n", type);\r\nzpool_put_driver(driver);\r\nkfree(zpool);\r\nreturn NULL;\r\n}\r\npr_info("created %s pool\n", type);\r\nspin_lock(&pools_lock);\r\nlist_add(&zpool->list, &pools_head);\r\nspin_unlock(&pools_lock);\r\nreturn zpool;\r\n}\r\nvoid zpool_destroy_pool(struct zpool *zpool)\r\n{\r\npr_info("destroying pool type %s\n", zpool->type);\r\nspin_lock(&pools_lock);\r\nlist_del(&zpool->list);\r\nspin_unlock(&pools_lock);\r\nzpool->driver->destroy(zpool->pool);\r\nzpool_put_driver(zpool->driver);\r\nkfree(zpool);\r\n}\r\nchar *zpool_get_type(struct zpool *zpool)\r\n{\r\nreturn zpool->type;\r\n}\r\nint zpool_malloc(struct zpool *zpool, size_t size, gfp_t gfp,\r\nunsigned long *handle)\r\n{\r\nreturn zpool->driver->malloc(zpool->pool, size, gfp, handle);\r\n}\r\nvoid zpool_free(struct zpool *zpool, unsigned long handle)\r\n{\r\nzpool->driver->free(zpool->pool, handle);\r\n}\r\nint zpool_shrink(struct zpool *zpool, unsigned int pages,\r\nunsigned int *reclaimed)\r\n{\r\nreturn zpool->driver->shrink(zpool->pool, pages, reclaimed);\r\n}\r\nvoid *zpool_map_handle(struct zpool *zpool, unsigned long handle,\r\nenum zpool_mapmode mapmode)\r\n{\r\nreturn zpool->driver->map(zpool->pool, handle, mapmode);\r\n}\r\nvoid zpool_unmap_handle(struct zpool *zpool, unsigned long handle)\r\n{\r\nzpool->driver->unmap(zpool->pool, handle);\r\n}\r\nu64 zpool_get_total_size(struct zpool *zpool)\r\n{\r\nreturn zpool->driver->total_size(zpool->pool);\r\n}\r\nstatic int __init init_zpool(void)\r\n{\r\npr_info("loaded\n");\r\nreturn 0;\r\n}\r\nstatic void __exit exit_zpool(void)\r\n{\r\npr_info("unloaded\n");\r\n}
