static int cpg_mstp_clock_endisable(struct clk_hw *hw, bool enable)\r\n{\r\nstruct mstp_clock *clock = to_mstp_clock(hw);\r\nstruct mstp_clock_group *group = clock->group;\r\nu32 bitmask = BIT(clock->bit_index);\r\nunsigned long flags;\r\nunsigned int i;\r\nu32 value;\r\nspin_lock_irqsave(&group->lock, flags);\r\nvalue = clk_readl(group->smstpcr);\r\nif (enable)\r\nvalue &= ~bitmask;\r\nelse\r\nvalue |= bitmask;\r\nclk_writel(value, group->smstpcr);\r\nspin_unlock_irqrestore(&group->lock, flags);\r\nif (!enable || !group->mstpsr)\r\nreturn 0;\r\nfor (i = 1000; i > 0; --i) {\r\nif (!(clk_readl(group->mstpsr) & bitmask))\r\nbreak;\r\ncpu_relax();\r\n}\r\nif (!i) {\r\npr_err("%s: failed to enable %p[%d]\n", __func__,\r\ngroup->smstpcr, clock->bit_index);\r\nreturn -ETIMEDOUT;\r\n}\r\nreturn 0;\r\n}\r\nstatic int cpg_mstp_clock_enable(struct clk_hw *hw)\r\n{\r\nreturn cpg_mstp_clock_endisable(hw, true);\r\n}\r\nstatic void cpg_mstp_clock_disable(struct clk_hw *hw)\r\n{\r\ncpg_mstp_clock_endisable(hw, false);\r\n}\r\nstatic int cpg_mstp_clock_is_enabled(struct clk_hw *hw)\r\n{\r\nstruct mstp_clock *clock = to_mstp_clock(hw);\r\nstruct mstp_clock_group *group = clock->group;\r\nu32 value;\r\nif (group->mstpsr)\r\nvalue = clk_readl(group->mstpsr);\r\nelse\r\nvalue = clk_readl(group->smstpcr);\r\nreturn !(value & BIT(clock->bit_index));\r\n}\r\nstatic struct clk * __init\r\ncpg_mstp_clock_register(const char *name, const char *parent_name,\r\nunsigned int index, struct mstp_clock_group *group)\r\n{\r\nstruct clk_init_data init;\r\nstruct mstp_clock *clock;\r\nstruct clk *clk;\r\nclock = kzalloc(sizeof(*clock), GFP_KERNEL);\r\nif (!clock) {\r\npr_err("%s: failed to allocate MSTP clock.\n", __func__);\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\ninit.name = name;\r\ninit.ops = &cpg_mstp_clock_ops;\r\ninit.flags = CLK_IS_BASIC | CLK_SET_RATE_PARENT;\r\ninit.parent_names = &parent_name;\r\ninit.num_parents = 1;\r\nclock->bit_index = index;\r\nclock->group = group;\r\nclock->hw.init = &init;\r\nclk = clk_register(NULL, &clock->hw);\r\nif (IS_ERR(clk))\r\nkfree(clock);\r\nreturn clk;\r\n}\r\nstatic void __init cpg_mstp_clocks_init(struct device_node *np)\r\n{\r\nstruct mstp_clock_group *group;\r\nconst char *idxname;\r\nstruct clk **clks;\r\nunsigned int i;\r\ngroup = kzalloc(sizeof(*group), GFP_KERNEL);\r\nclks = kmalloc(MSTP_MAX_CLOCKS * sizeof(*clks), GFP_KERNEL);\r\nif (group == NULL || clks == NULL) {\r\nkfree(group);\r\nkfree(clks);\r\npr_err("%s: failed to allocate group\n", __func__);\r\nreturn;\r\n}\r\nspin_lock_init(&group->lock);\r\ngroup->data.clks = clks;\r\ngroup->smstpcr = of_iomap(np, 0);\r\ngroup->mstpsr = of_iomap(np, 1);\r\nif (group->smstpcr == NULL) {\r\npr_err("%s: failed to remap SMSTPCR\n", __func__);\r\nkfree(group);\r\nkfree(clks);\r\nreturn;\r\n}\r\nfor (i = 0; i < MSTP_MAX_CLOCKS; ++i)\r\nclks[i] = ERR_PTR(-ENOENT);\r\nif (of_find_property(np, "clock-indices", &i))\r\nidxname = "clock-indices";\r\nelse\r\nidxname = "renesas,clock-indices";\r\nfor (i = 0; i < MSTP_MAX_CLOCKS; ++i) {\r\nconst char *parent_name;\r\nconst char *name;\r\nu32 clkidx;\r\nint ret;\r\nret = of_property_read_string_index(np, "clock-output-names",\r\ni, &name);\r\nif (ret < 0 || strlen(name) == 0)\r\ncontinue;\r\nparent_name = of_clk_get_parent_name(np, i);\r\nret = of_property_read_u32_index(np, idxname, i, &clkidx);\r\nif (parent_name == NULL || ret < 0)\r\nbreak;\r\nif (clkidx >= MSTP_MAX_CLOCKS) {\r\npr_err("%s: invalid clock %s %s index %u)\n",\r\n__func__, np->name, name, clkidx);\r\ncontinue;\r\n}\r\nclks[clkidx] = cpg_mstp_clock_register(name, parent_name,\r\nclkidx, group);\r\nif (!IS_ERR(clks[clkidx])) {\r\ngroup->data.clk_num = max(group->data.clk_num,\r\nclkidx + 1);\r\nclk_register_clkdev(clks[clkidx], name, NULL);\r\n} else {\r\npr_err("%s: failed to register %s %s clock (%ld)\n",\r\n__func__, np->name, name, PTR_ERR(clks[clkidx]));\r\n}\r\n}\r\nof_clk_add_provider(np, of_clk_src_onecell_get, &group->data);\r\n}
