static void mwifiex_restore_tdls_packets(struct mwifiex_private *priv,\r\nconst u8 *mac, u8 status)\r\n{\r\nstruct mwifiex_ra_list_tbl *ra_list;\r\nstruct list_head *tid_list;\r\nstruct sk_buff *skb, *tmp;\r\nstruct mwifiex_txinfo *tx_info;\r\nunsigned long flags;\r\nu32 tid;\r\nu8 tid_down;\r\ndev_dbg(priv->adapter->dev, "%s: %pM\n", __func__, mac);\r\nspin_lock_irqsave(&priv->wmm.ra_list_spinlock, flags);\r\nskb_queue_walk_safe(&priv->tdls_txq, skb, tmp) {\r\nif (!ether_addr_equal(mac, skb->data))\r\ncontinue;\r\n__skb_unlink(skb, &priv->tdls_txq);\r\ntx_info = MWIFIEX_SKB_TXCB(skb);\r\ntid = skb->priority;\r\ntid_down = mwifiex_wmm_downgrade_tid(priv, tid);\r\nif (status == TDLS_SETUP_COMPLETE) {\r\nra_list = mwifiex_wmm_get_queue_raptr(priv, tid, mac);\r\nra_list->tdls_link = true;\r\ntx_info->flags |= MWIFIEX_BUF_FLAG_TDLS_PKT;\r\n} else {\r\ntid_list = &priv->wmm.tid_tbl_ptr[tid_down].ra_list;\r\nif (!list_empty(tid_list))\r\nra_list = list_first_entry(tid_list,\r\nstruct mwifiex_ra_list_tbl, list);\r\nelse\r\nra_list = NULL;\r\ntx_info->flags &= ~MWIFIEX_BUF_FLAG_TDLS_PKT;\r\n}\r\nif (!ra_list) {\r\nmwifiex_write_data_complete(priv->adapter, skb, 0, -1);\r\ncontinue;\r\n}\r\nskb_queue_tail(&ra_list->skb_head, skb);\r\nra_list->ba_pkt_count++;\r\nra_list->total_pkt_count++;\r\nif (atomic_read(&priv->wmm.highest_queued_prio) <\r\ntos_to_tid_inv[tid_down])\r\natomic_set(&priv->wmm.highest_queued_prio,\r\ntos_to_tid_inv[tid_down]);\r\natomic_inc(&priv->wmm.tx_pkts_queued);\r\n}\r\nspin_unlock_irqrestore(&priv->wmm.ra_list_spinlock, flags);\r\nreturn;\r\n}\r\nstatic void mwifiex_hold_tdls_packets(struct mwifiex_private *priv,\r\nconst u8 *mac)\r\n{\r\nstruct mwifiex_ra_list_tbl *ra_list;\r\nstruct list_head *ra_list_head;\r\nstruct sk_buff *skb, *tmp;\r\nunsigned long flags;\r\nint i;\r\ndev_dbg(priv->adapter->dev, "%s: %pM\n", __func__, mac);\r\nspin_lock_irqsave(&priv->wmm.ra_list_spinlock, flags);\r\nfor (i = 0; i < MAX_NUM_TID; i++) {\r\nif (!list_empty(&priv->wmm.tid_tbl_ptr[i].ra_list)) {\r\nra_list_head = &priv->wmm.tid_tbl_ptr[i].ra_list;\r\nlist_for_each_entry(ra_list, ra_list_head, list) {\r\nskb_queue_walk_safe(&ra_list->skb_head, skb,\r\ntmp) {\r\nif (!ether_addr_equal(mac, skb->data))\r\ncontinue;\r\n__skb_unlink(skb, &ra_list->skb_head);\r\natomic_dec(&priv->wmm.tx_pkts_queued);\r\nra_list->total_pkt_count--;\r\nskb_queue_tail(&priv->tdls_txq, skb);\r\n}\r\n}\r\n}\r\n}\r\nspin_unlock_irqrestore(&priv->wmm.ra_list_spinlock, flags);\r\nreturn;\r\n}\r\nstatic int\r\nmwifiex_tdls_append_rates_ie(struct mwifiex_private *priv,\r\nstruct sk_buff *skb)\r\n{\r\nu8 rates[MWIFIEX_SUPPORTED_RATES], *pos;\r\nu16 rates_size, supp_rates_size, ext_rates_size;\r\nmemset(rates, 0, sizeof(rates));\r\nrates_size = mwifiex_get_supported_rates(priv, rates);\r\nsupp_rates_size = min_t(u16, rates_size, MWIFIEX_TDLS_SUPPORTED_RATES);\r\nif (skb_tailroom(skb) < rates_size + 4) {\r\ndev_err(priv->adapter->dev,\r\n"Insuffient space while adding rates\n");\r\nreturn -ENOMEM;\r\n}\r\npos = skb_put(skb, supp_rates_size + 2);\r\n*pos++ = WLAN_EID_SUPP_RATES;\r\n*pos++ = supp_rates_size;\r\nmemcpy(pos, rates, supp_rates_size);\r\nif (rates_size > MWIFIEX_TDLS_SUPPORTED_RATES) {\r\next_rates_size = rates_size - MWIFIEX_TDLS_SUPPORTED_RATES;\r\npos = skb_put(skb, ext_rates_size + 2);\r\n*pos++ = WLAN_EID_EXT_SUPP_RATES;\r\n*pos++ = ext_rates_size;\r\nmemcpy(pos, rates + MWIFIEX_TDLS_SUPPORTED_RATES,\r\next_rates_size);\r\n}\r\nreturn 0;\r\n}\r\nstatic void mwifiex_tdls_add_aid(struct mwifiex_private *priv,\r\nstruct sk_buff *skb)\r\n{\r\nstruct ieee_types_assoc_rsp *assoc_rsp;\r\nu8 *pos;\r\nassoc_rsp = (struct ieee_types_assoc_rsp *)&priv->assoc_rsp_buf;\r\npos = (void *)skb_put(skb, 4);\r\n*pos++ = WLAN_EID_AID;\r\n*pos++ = 2;\r\n*pos++ = le16_to_cpu(assoc_rsp->a_id);\r\nreturn;\r\n}\r\nstatic int mwifiex_tdls_add_vht_capab(struct mwifiex_private *priv,\r\nstruct sk_buff *skb)\r\n{\r\nstruct ieee80211_vht_cap vht_cap;\r\nu8 *pos;\r\npos = (void *)skb_put(skb, sizeof(struct ieee80211_vht_cap) + 2);\r\n*pos++ = WLAN_EID_VHT_CAPABILITY;\r\n*pos++ = sizeof(struct ieee80211_vht_cap);\r\nmemset(&vht_cap, 0, sizeof(struct ieee80211_vht_cap));\r\nmwifiex_fill_vht_cap_tlv(priv, &vht_cap, priv->curr_bss_params.band);\r\nmemcpy(pos, &vht_cap, sizeof(vht_cap));\r\nreturn 0;\r\n}\r\nstatic int\r\nmwifiex_tdls_add_ht_oper(struct mwifiex_private *priv, const u8 *mac,\r\nu8 vht_enabled, struct sk_buff *skb)\r\n{\r\nstruct ieee80211_ht_operation *ht_oper;\r\nstruct mwifiex_sta_node *sta_ptr;\r\nstruct mwifiex_bssdescriptor *bss_desc =\r\n&priv->curr_bss_params.bss_descriptor;\r\nu8 *pos;\r\nsta_ptr = mwifiex_get_sta_entry(priv, mac);\r\nif (unlikely(!sta_ptr)) {\r\ndev_warn(priv->adapter->dev,\r\n"TDLS peer station not found in list\n");\r\nreturn -1;\r\n}\r\npos = (void *)skb_put(skb, sizeof(struct ieee80211_ht_operation) + 2);\r\n*pos++ = WLAN_EID_HT_OPERATION;\r\n*pos++ = sizeof(struct ieee80211_ht_operation);\r\nht_oper = (void *)pos;\r\nht_oper->primary_chan = bss_desc->channel;\r\nif (ISSUPP_CHANWIDTH40(priv->adapter->hw_dot_11n_dev_cap) &&\r\nbss_desc->bcn_ht_cap &&\r\nISALLOWED_CHANWIDTH40(bss_desc->bcn_ht_oper->ht_param))\r\nht_oper->ht_param = bss_desc->bcn_ht_oper->ht_param;\r\nif (vht_enabled) {\r\nht_oper->ht_param =\r\nmwifiex_get_sec_chan_offset(bss_desc->channel);\r\nht_oper->ht_param |= BIT(2);\r\n}\r\nmemcpy(&sta_ptr->tdls_cap.ht_oper, ht_oper,\r\nsizeof(struct ieee80211_ht_operation));\r\nreturn 0;\r\n}\r\nstatic int mwifiex_tdls_add_vht_oper(struct mwifiex_private *priv,\r\nconst u8 *mac, struct sk_buff *skb)\r\n{\r\nstruct mwifiex_bssdescriptor *bss_desc;\r\nstruct ieee80211_vht_operation *vht_oper;\r\nstruct ieee80211_vht_cap *vht_cap, *ap_vht_cap = NULL;\r\nstruct mwifiex_sta_node *sta_ptr;\r\nstruct mwifiex_adapter *adapter = priv->adapter;\r\nu8 supp_chwd_set, peer_supp_chwd_set;\r\nu8 *pos, ap_supp_chwd_set, chan_bw;\r\nu16 mcs_map_user, mcs_map_resp, mcs_map_result;\r\nu16 mcs_user, mcs_resp, nss;\r\nu32 usr_vht_cap_info;\r\nbss_desc = &priv->curr_bss_params.bss_descriptor;\r\nsta_ptr = mwifiex_get_sta_entry(priv, mac);\r\nif (unlikely(!sta_ptr)) {\r\ndev_warn(adapter->dev, "TDLS peer station not found in list\n");\r\nreturn -1;\r\n}\r\nif (!mwifiex_is_bss_in_11ac_mode(priv)) {\r\nif (sta_ptr->tdls_cap.extcap.ext_capab[7] &\r\nWLAN_EXT_CAPA8_TDLS_WIDE_BW_ENABLED) {\r\ndev_dbg(adapter->dev,\r\n"TDLS peer doesn't support wider bandwitdh\n");\r\nreturn 0;\r\n}\r\n} else {\r\nap_vht_cap = bss_desc->bcn_vht_cap;\r\n}\r\npos = (void *)skb_put(skb, sizeof(struct ieee80211_vht_operation) + 2);\r\n*pos++ = WLAN_EID_VHT_OPERATION;\r\n*pos++ = sizeof(struct ieee80211_vht_operation);\r\nvht_oper = (struct ieee80211_vht_operation *)pos;\r\nif (bss_desc->bss_band & BAND_A)\r\nusr_vht_cap_info = adapter->usr_dot_11ac_dev_cap_a;\r\nelse\r\nusr_vht_cap_info = adapter->usr_dot_11ac_dev_cap_bg;\r\nvht_cap = &sta_ptr->tdls_cap.vhtcap;\r\nsupp_chwd_set = GET_VHTCAP_CHWDSET(usr_vht_cap_info);\r\npeer_supp_chwd_set =\r\nGET_VHTCAP_CHWDSET(le32_to_cpu(vht_cap->vht_cap_info));\r\nsupp_chwd_set = min_t(u8, supp_chwd_set, peer_supp_chwd_set);\r\nif (ap_vht_cap && sta_ptr->tdls_cap.extcap.ext_capab[7] &\r\nWLAN_EXT_CAPA8_TDLS_WIDE_BW_ENABLED) {\r\nap_supp_chwd_set =\r\nGET_VHTCAP_CHWDSET(le32_to_cpu(ap_vht_cap->vht_cap_info));\r\nsupp_chwd_set = min_t(u8, supp_chwd_set, ap_supp_chwd_set);\r\n}\r\nswitch (supp_chwd_set) {\r\ncase IEEE80211_VHT_CHANWIDTH_80MHZ:\r\nvht_oper->chan_width = IEEE80211_VHT_CHANWIDTH_80MHZ;\r\nbreak;\r\ncase IEEE80211_VHT_CHANWIDTH_160MHZ:\r\nvht_oper->chan_width = IEEE80211_VHT_CHANWIDTH_160MHZ;\r\nbreak;\r\ncase IEEE80211_VHT_CHANWIDTH_80P80MHZ:\r\nvht_oper->chan_width = IEEE80211_VHT_CHANWIDTH_80P80MHZ;\r\nbreak;\r\ndefault:\r\nvht_oper->chan_width = IEEE80211_VHT_CHANWIDTH_USE_HT;\r\nbreak;\r\n}\r\nmcs_map_user = GET_DEVRXMCSMAP(adapter->usr_dot_11ac_mcs_support);\r\nmcs_map_resp = le16_to_cpu(vht_cap->supp_mcs.rx_mcs_map);\r\nmcs_map_result = 0;\r\nfor (nss = 1; nss <= 8; nss++) {\r\nmcs_user = GET_VHTNSSMCS(mcs_map_user, nss);\r\nmcs_resp = GET_VHTNSSMCS(mcs_map_resp, nss);\r\nif ((mcs_user == IEEE80211_VHT_MCS_NOT_SUPPORTED) ||\r\n(mcs_resp == IEEE80211_VHT_MCS_NOT_SUPPORTED))\r\nSET_VHTNSSMCS(mcs_map_result, nss,\r\nIEEE80211_VHT_MCS_NOT_SUPPORTED);\r\nelse\r\nSET_VHTNSSMCS(mcs_map_result, nss,\r\nmin_t(u16, mcs_user, mcs_resp));\r\n}\r\nvht_oper->basic_mcs_set = cpu_to_le16(mcs_map_result);\r\nswitch (vht_oper->chan_width) {\r\ncase IEEE80211_VHT_CHANWIDTH_80MHZ:\r\nchan_bw = IEEE80211_VHT_CHANWIDTH_80MHZ;\r\nbreak;\r\ncase IEEE80211_VHT_CHANWIDTH_160MHZ:\r\nchan_bw = IEEE80211_VHT_CHANWIDTH_160MHZ;\r\nbreak;\r\ncase IEEE80211_VHT_CHANWIDTH_80P80MHZ:\r\nchan_bw = IEEE80211_VHT_CHANWIDTH_80MHZ;\r\nbreak;\r\ndefault:\r\nchan_bw = IEEE80211_VHT_CHANWIDTH_USE_HT;\r\nbreak;\r\n}\r\nvht_oper->center_freq_seg1_idx =\r\nmwifiex_get_center_freq_index(priv, BAND_AAC,\r\nbss_desc->channel,\r\nchan_bw);\r\nreturn 0;\r\n}\r\nstatic void mwifiex_tdls_add_ext_capab(struct mwifiex_private *priv,\r\nstruct sk_buff *skb)\r\n{\r\nstruct ieee_types_extcap *extcap;\r\nextcap = (void *)skb_put(skb, sizeof(struct ieee_types_extcap));\r\nextcap->ieee_hdr.element_id = WLAN_EID_EXT_CAPABILITY;\r\nextcap->ieee_hdr.len = 8;\r\nmemset(extcap->ext_capab, 0, 8);\r\nextcap->ext_capab[4] |= WLAN_EXT_CAPA5_TDLS_ENABLED;\r\nif (priv->adapter->is_hw_11ac_capable)\r\nextcap->ext_capab[7] |= WLAN_EXT_CAPA8_TDLS_WIDE_BW_ENABLED;\r\n}\r\nstatic void mwifiex_tdls_add_qos_capab(struct sk_buff *skb)\r\n{\r\nu8 *pos = (void *)skb_put(skb, 3);\r\n*pos++ = WLAN_EID_QOS_CAPA;\r\n*pos++ = 1;\r\n*pos++ = MWIFIEX_TDLS_DEF_QOS_CAPAB;\r\n}\r\nstatic void\r\nmwifiex_tdls_add_wmm_param_ie(struct mwifiex_private *priv, struct sk_buff *skb)\r\n{\r\nstruct ieee80211_wmm_param_ie *wmm;\r\nu8 ac_vi[] = {0x42, 0x43, 0x5e, 0x00};\r\nu8 ac_vo[] = {0x62, 0x32, 0x2f, 0x00};\r\nu8 ac_be[] = {0x03, 0xa4, 0x00, 0x00};\r\nu8 ac_bk[] = {0x27, 0xa4, 0x00, 0x00};\r\nwmm = (void *)skb_put(skb, sizeof(*wmm));\r\nmemset(wmm, 0, sizeof(*wmm));\r\nwmm->element_id = WLAN_EID_VENDOR_SPECIFIC;\r\nwmm->len = sizeof(*wmm) - 2;\r\nwmm->oui[0] = 0x00;\r\nwmm->oui[1] = 0x50;\r\nwmm->oui[2] = 0xf2;\r\nwmm->oui_type = 2;\r\nwmm->oui_subtype = 1;\r\nwmm->version = 1;\r\nwmm->qos_info = 0;\r\nmemcpy(&wmm->ac[0], ac_be, sizeof(ac_be));\r\nmemcpy(&wmm->ac[1], ac_bk, sizeof(ac_bk));\r\nmemcpy(&wmm->ac[2], ac_vi, sizeof(ac_vi));\r\nmemcpy(&wmm->ac[3], ac_vo, sizeof(ac_vo));\r\n}\r\nstatic void\r\nmwifiex_add_wmm_info_ie(struct mwifiex_private *priv, struct sk_buff *skb,\r\nu8 qosinfo)\r\n{\r\nu8 *buf;\r\nbuf = (void *)skb_put(skb, MWIFIEX_TDLS_WMM_INFO_SIZE +\r\nsizeof(struct ieee_types_header));\r\n*buf++ = WLAN_EID_VENDOR_SPECIFIC;\r\n*buf++ = 7;\r\n*buf++ = 0x00;\r\n*buf++ = 0x50;\r\n*buf++ = 0xf2;\r\n*buf++ = 2;\r\n*buf++ = 0;\r\n*buf++ = 1;\r\n*buf++ = qosinfo;\r\n}\r\nstatic int mwifiex_prep_tdls_encap_data(struct mwifiex_private *priv,\r\nconst u8 *peer, u8 action_code,\r\nu8 dialog_token,\r\nu16 status_code, struct sk_buff *skb)\r\n{\r\nstruct ieee80211_tdls_data *tf;\r\nint ret;\r\nu16 capab;\r\nstruct ieee80211_ht_cap *ht_cap;\r\nu8 radio, *pos;\r\ncapab = priv->curr_bss_params.bss_descriptor.cap_info_bitmap;\r\ntf = (void *)skb_put(skb, offsetof(struct ieee80211_tdls_data, u));\r\nmemcpy(tf->da, peer, ETH_ALEN);\r\nmemcpy(tf->sa, priv->curr_addr, ETH_ALEN);\r\ntf->ether_type = cpu_to_be16(ETH_P_TDLS);\r\ntf->payload_type = WLAN_TDLS_SNAP_RFTYPE;\r\nswitch (action_code) {\r\ncase WLAN_TDLS_SETUP_REQUEST:\r\ntf->category = WLAN_CATEGORY_TDLS;\r\ntf->action_code = WLAN_TDLS_SETUP_REQUEST;\r\nskb_put(skb, sizeof(tf->u.setup_req));\r\ntf->u.setup_req.dialog_token = dialog_token;\r\ntf->u.setup_req.capability = cpu_to_le16(capab);\r\nret = mwifiex_tdls_append_rates_ie(priv, skb);\r\nif (ret) {\r\ndev_kfree_skb_any(skb);\r\nreturn ret;\r\n}\r\npos = (void *)skb_put(skb, sizeof(struct ieee80211_ht_cap) + 2);\r\n*pos++ = WLAN_EID_HT_CAPABILITY;\r\n*pos++ = sizeof(struct ieee80211_ht_cap);\r\nht_cap = (void *)pos;\r\nradio = mwifiex_band_to_radio_type(priv->curr_bss_params.band);\r\nret = mwifiex_fill_cap_info(priv, radio, ht_cap);\r\nif (ret) {\r\ndev_kfree_skb_any(skb);\r\nreturn ret;\r\n}\r\nif (priv->adapter->is_hw_11ac_capable) {\r\nret = mwifiex_tdls_add_vht_capab(priv, skb);\r\nif (ret) {\r\ndev_kfree_skb_any(skb);\r\nreturn ret;\r\n}\r\nmwifiex_tdls_add_aid(priv, skb);\r\n}\r\nmwifiex_tdls_add_ext_capab(priv, skb);\r\nmwifiex_tdls_add_qos_capab(skb);\r\nmwifiex_add_wmm_info_ie(priv, skb, 0);\r\nbreak;\r\ncase WLAN_TDLS_SETUP_RESPONSE:\r\ntf->category = WLAN_CATEGORY_TDLS;\r\ntf->action_code = WLAN_TDLS_SETUP_RESPONSE;\r\nskb_put(skb, sizeof(tf->u.setup_resp));\r\ntf->u.setup_resp.status_code = cpu_to_le16(status_code);\r\ntf->u.setup_resp.dialog_token = dialog_token;\r\ntf->u.setup_resp.capability = cpu_to_le16(capab);\r\nret = mwifiex_tdls_append_rates_ie(priv, skb);\r\nif (ret) {\r\ndev_kfree_skb_any(skb);\r\nreturn ret;\r\n}\r\npos = (void *)skb_put(skb, sizeof(struct ieee80211_ht_cap) + 2);\r\n*pos++ = WLAN_EID_HT_CAPABILITY;\r\n*pos++ = sizeof(struct ieee80211_ht_cap);\r\nht_cap = (void *)pos;\r\nradio = mwifiex_band_to_radio_type(priv->curr_bss_params.band);\r\nret = mwifiex_fill_cap_info(priv, radio, ht_cap);\r\nif (ret) {\r\ndev_kfree_skb_any(skb);\r\nreturn ret;\r\n}\r\nif (priv->adapter->is_hw_11ac_capable) {\r\nret = mwifiex_tdls_add_vht_capab(priv, skb);\r\nif (ret) {\r\ndev_kfree_skb_any(skb);\r\nreturn ret;\r\n}\r\nmwifiex_tdls_add_aid(priv, skb);\r\n}\r\nmwifiex_tdls_add_ext_capab(priv, skb);\r\nmwifiex_tdls_add_qos_capab(skb);\r\nmwifiex_add_wmm_info_ie(priv, skb, 0);\r\nbreak;\r\ncase WLAN_TDLS_SETUP_CONFIRM:\r\ntf->category = WLAN_CATEGORY_TDLS;\r\ntf->action_code = WLAN_TDLS_SETUP_CONFIRM;\r\nskb_put(skb, sizeof(tf->u.setup_cfm));\r\ntf->u.setup_cfm.status_code = cpu_to_le16(status_code);\r\ntf->u.setup_cfm.dialog_token = dialog_token;\r\nmwifiex_tdls_add_wmm_param_ie(priv, skb);\r\nif (priv->adapter->is_hw_11ac_capable) {\r\nret = mwifiex_tdls_add_vht_oper(priv, peer, skb);\r\nif (ret) {\r\ndev_kfree_skb_any(skb);\r\nreturn ret;\r\n}\r\nret = mwifiex_tdls_add_ht_oper(priv, peer, 1, skb);\r\nif (ret) {\r\ndev_kfree_skb_any(skb);\r\nreturn ret;\r\n}\r\n} else {\r\nret = mwifiex_tdls_add_ht_oper(priv, peer, 0, skb);\r\nif (ret) {\r\ndev_kfree_skb_any(skb);\r\nreturn ret;\r\n}\r\n}\r\nbreak;\r\ncase WLAN_TDLS_TEARDOWN:\r\ntf->category = WLAN_CATEGORY_TDLS;\r\ntf->action_code = WLAN_TDLS_TEARDOWN;\r\nskb_put(skb, sizeof(tf->u.teardown));\r\ntf->u.teardown.reason_code = cpu_to_le16(status_code);\r\nbreak;\r\ncase WLAN_TDLS_DISCOVERY_REQUEST:\r\ntf->category = WLAN_CATEGORY_TDLS;\r\ntf->action_code = WLAN_TDLS_DISCOVERY_REQUEST;\r\nskb_put(skb, sizeof(tf->u.discover_req));\r\ntf->u.discover_req.dialog_token = dialog_token;\r\nbreak;\r\ndefault:\r\ndev_err(priv->adapter->dev, "Unknown TDLS frame type.\n");\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic void\r\nmwifiex_tdls_add_link_ie(struct sk_buff *skb, const u8 *src_addr,\r\nconst u8 *peer, const u8 *bssid)\r\n{\r\nstruct ieee80211_tdls_lnkie *lnkid;\r\nlnkid = (void *)skb_put(skb, sizeof(struct ieee80211_tdls_lnkie));\r\nlnkid->ie_type = WLAN_EID_LINK_ID;\r\nlnkid->ie_len = sizeof(struct ieee80211_tdls_lnkie) -\r\nsizeof(struct ieee_types_header);\r\nmemcpy(lnkid->bssid, bssid, ETH_ALEN);\r\nmemcpy(lnkid->init_sta, src_addr, ETH_ALEN);\r\nmemcpy(lnkid->resp_sta, peer, ETH_ALEN);\r\n}\r\nint mwifiex_send_tdls_data_frame(struct mwifiex_private *priv, const u8 *peer,\r\nu8 action_code, u8 dialog_token,\r\nu16 status_code, const u8 *extra_ies,\r\nsize_t extra_ies_len)\r\n{\r\nstruct sk_buff *skb;\r\nstruct mwifiex_txinfo *tx_info;\r\nint ret;\r\nu16 skb_len;\r\nskb_len = MWIFIEX_MIN_DATA_HEADER_LEN +\r\nmax(sizeof(struct ieee80211_mgmt),\r\nsizeof(struct ieee80211_tdls_data)) +\r\nMWIFIEX_MGMT_FRAME_HEADER_SIZE +\r\nMWIFIEX_SUPPORTED_RATES +\r\n3 +\r\nsizeof(struct ieee_types_extcap) +\r\nsizeof(struct ieee80211_ht_cap) +\r\nsizeof(struct ieee_types_bss_co_2040) +\r\nsizeof(struct ieee80211_ht_operation) +\r\nsizeof(struct ieee80211_tdls_lnkie) +\r\nsizeof(struct ieee80211_wmm_param_ie) +\r\nextra_ies_len;\r\nif (priv->adapter->is_hw_11ac_capable)\r\nskb_len += sizeof(struct ieee_types_vht_cap) +\r\nsizeof(struct ieee_types_vht_oper) +\r\nsizeof(struct ieee_types_aid);\r\nskb = dev_alloc_skb(skb_len);\r\nif (!skb) {\r\ndev_err(priv->adapter->dev,\r\n"allocate skb failed for management frame\n");\r\nreturn -ENOMEM;\r\n}\r\nskb_reserve(skb, MWIFIEX_MIN_DATA_HEADER_LEN);\r\nswitch (action_code) {\r\ncase WLAN_TDLS_SETUP_REQUEST:\r\ncase WLAN_TDLS_SETUP_CONFIRM:\r\ncase WLAN_TDLS_TEARDOWN:\r\ncase WLAN_TDLS_DISCOVERY_REQUEST:\r\nret = mwifiex_prep_tdls_encap_data(priv, peer, action_code,\r\ndialog_token, status_code,\r\nskb);\r\nif (ret) {\r\ndev_kfree_skb_any(skb);\r\nreturn ret;\r\n}\r\nif (extra_ies_len)\r\nmemcpy(skb_put(skb, extra_ies_len), extra_ies,\r\nextra_ies_len);\r\nmwifiex_tdls_add_link_ie(skb, priv->curr_addr, peer,\r\npriv->cfg_bssid);\r\nbreak;\r\ncase WLAN_TDLS_SETUP_RESPONSE:\r\nret = mwifiex_prep_tdls_encap_data(priv, peer, action_code,\r\ndialog_token, status_code,\r\nskb);\r\nif (ret) {\r\ndev_kfree_skb_any(skb);\r\nreturn ret;\r\n}\r\nif (extra_ies_len)\r\nmemcpy(skb_put(skb, extra_ies_len), extra_ies,\r\nextra_ies_len);\r\nmwifiex_tdls_add_link_ie(skb, peer, priv->curr_addr,\r\npriv->cfg_bssid);\r\nbreak;\r\n}\r\nswitch (action_code) {\r\ncase WLAN_TDLS_SETUP_REQUEST:\r\ncase WLAN_TDLS_SETUP_RESPONSE:\r\nskb->priority = MWIFIEX_PRIO_BK;\r\nbreak;\r\ndefault:\r\nskb->priority = MWIFIEX_PRIO_VI;\r\nbreak;\r\n}\r\ntx_info = MWIFIEX_SKB_TXCB(skb);\r\nmemset(tx_info, 0, sizeof(*tx_info));\r\ntx_info->bss_num = priv->bss_num;\r\ntx_info->bss_type = priv->bss_type;\r\n__net_timestamp(skb);\r\nmwifiex_queue_tx_pkt(priv, skb);\r\nreturn 0;\r\n}\r\nstatic int\r\nmwifiex_construct_tdls_action_frame(struct mwifiex_private *priv,\r\nconst u8 *peer,\r\nu8 action_code, u8 dialog_token,\r\nu16 status_code, struct sk_buff *skb)\r\n{\r\nstruct ieee80211_mgmt *mgmt;\r\nu8 bc_addr[] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};\r\nint ret;\r\nu16 capab;\r\nstruct ieee80211_ht_cap *ht_cap;\r\nu8 radio, *pos;\r\ncapab = priv->curr_bss_params.bss_descriptor.cap_info_bitmap;\r\nmgmt = (void *)skb_put(skb, offsetof(struct ieee80211_mgmt, u));\r\nmemset(mgmt, 0, 24);\r\nmemcpy(mgmt->da, peer, ETH_ALEN);\r\nmemcpy(mgmt->sa, priv->curr_addr, ETH_ALEN);\r\nmemcpy(mgmt->bssid, priv->cfg_bssid, ETH_ALEN);\r\nmgmt->frame_control = cpu_to_le16(IEEE80211_FTYPE_MGMT |\r\nIEEE80211_STYPE_ACTION);\r\npos = skb_put(skb, ETH_ALEN);\r\nswitch (action_code) {\r\ncase WLAN_PUB_ACTION_TDLS_DISCOVER_RES:\r\nskb_put(skb, sizeof(mgmt->u.action.u.tdls_discover_resp) + 1);\r\nmgmt->u.action.category = WLAN_CATEGORY_PUBLIC;\r\nmgmt->u.action.u.tdls_discover_resp.action_code =\r\nWLAN_PUB_ACTION_TDLS_DISCOVER_RES;\r\nmgmt->u.action.u.tdls_discover_resp.dialog_token =\r\ndialog_token;\r\nmgmt->u.action.u.tdls_discover_resp.capability =\r\ncpu_to_le16(capab);\r\nmemmove(pos + ETH_ALEN, &mgmt->u.action.category,\r\nsizeof(mgmt->u.action.u.tdls_discover_resp));\r\nmemcpy(pos, bc_addr, ETH_ALEN);\r\nret = mwifiex_tdls_append_rates_ie(priv, skb);\r\nif (ret) {\r\ndev_kfree_skb_any(skb);\r\nreturn ret;\r\n}\r\npos = (void *)skb_put(skb, sizeof(struct ieee80211_ht_cap) + 2);\r\n*pos++ = WLAN_EID_HT_CAPABILITY;\r\n*pos++ = sizeof(struct ieee80211_ht_cap);\r\nht_cap = (void *)pos;\r\nradio = mwifiex_band_to_radio_type(priv->curr_bss_params.band);\r\nret = mwifiex_fill_cap_info(priv, radio, ht_cap);\r\nif (ret) {\r\ndev_kfree_skb_any(skb);\r\nreturn ret;\r\n}\r\nif (priv->adapter->is_hw_11ac_capable) {\r\nret = mwifiex_tdls_add_vht_capab(priv, skb);\r\nif (ret) {\r\ndev_kfree_skb_any(skb);\r\nreturn ret;\r\n}\r\nmwifiex_tdls_add_aid(priv, skb);\r\n}\r\nmwifiex_tdls_add_ext_capab(priv, skb);\r\nmwifiex_tdls_add_qos_capab(skb);\r\nbreak;\r\ndefault:\r\ndev_err(priv->adapter->dev, "Unknown TDLS action frame type\n");\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nint mwifiex_send_tdls_action_frame(struct mwifiex_private *priv, const u8 *peer,\r\nu8 action_code, u8 dialog_token,\r\nu16 status_code, const u8 *extra_ies,\r\nsize_t extra_ies_len)\r\n{\r\nstruct sk_buff *skb;\r\nstruct mwifiex_txinfo *tx_info;\r\nu8 *pos;\r\nu32 pkt_type, tx_control;\r\nu16 pkt_len, skb_len;\r\nskb_len = MWIFIEX_MIN_DATA_HEADER_LEN +\r\nmax(sizeof(struct ieee80211_mgmt),\r\nsizeof(struct ieee80211_tdls_data)) +\r\nMWIFIEX_MGMT_FRAME_HEADER_SIZE +\r\nMWIFIEX_SUPPORTED_RATES +\r\nsizeof(struct ieee_types_extcap) +\r\nsizeof(struct ieee80211_ht_cap) +\r\nsizeof(struct ieee_types_bss_co_2040) +\r\nsizeof(struct ieee80211_ht_operation) +\r\nsizeof(struct ieee80211_tdls_lnkie) +\r\nextra_ies_len +\r\n3 +\r\nETH_ALEN;\r\nif (priv->adapter->is_hw_11ac_capable)\r\nskb_len += sizeof(struct ieee_types_vht_cap) +\r\nsizeof(struct ieee_types_vht_oper) +\r\nsizeof(struct ieee_types_aid);\r\nskb = dev_alloc_skb(skb_len);\r\nif (!skb) {\r\ndev_err(priv->adapter->dev,\r\n"allocate skb failed for management frame\n");\r\nreturn -ENOMEM;\r\n}\r\nskb_reserve(skb, MWIFIEX_MIN_DATA_HEADER_LEN);\r\npkt_type = PKT_TYPE_MGMT;\r\ntx_control = 0;\r\npos = skb_put(skb, MWIFIEX_MGMT_FRAME_HEADER_SIZE + sizeof(pkt_len));\r\nmemset(pos, 0, MWIFIEX_MGMT_FRAME_HEADER_SIZE + sizeof(pkt_len));\r\nmemcpy(pos, &pkt_type, sizeof(pkt_type));\r\nmemcpy(pos + sizeof(pkt_type), &tx_control, sizeof(tx_control));\r\nif (mwifiex_construct_tdls_action_frame(priv, peer, action_code,\r\ndialog_token, status_code,\r\nskb)) {\r\ndev_kfree_skb_any(skb);\r\nreturn -EINVAL;\r\n}\r\nif (extra_ies_len)\r\nmemcpy(skb_put(skb, extra_ies_len), extra_ies, extra_ies_len);\r\nmwifiex_tdls_add_link_ie(skb, peer, priv->curr_addr,\r\npriv->cfg_bssid);\r\nskb->priority = MWIFIEX_PRIO_VI;\r\ntx_info = MWIFIEX_SKB_TXCB(skb);\r\nmemset(tx_info, 0, sizeof(*tx_info));\r\ntx_info->bss_num = priv->bss_num;\r\ntx_info->bss_type = priv->bss_type;\r\ntx_info->flags |= MWIFIEX_BUF_FLAG_TDLS_PKT;\r\npkt_len = skb->len - MWIFIEX_MGMT_FRAME_HEADER_SIZE - sizeof(pkt_len);\r\nmemcpy(skb->data + MWIFIEX_MGMT_FRAME_HEADER_SIZE, &pkt_len,\r\nsizeof(pkt_len));\r\n__net_timestamp(skb);\r\nmwifiex_queue_tx_pkt(priv, skb);\r\nreturn 0;\r\n}\r\nvoid mwifiex_process_tdls_action_frame(struct mwifiex_private *priv,\r\nu8 *buf, int len)\r\n{\r\nstruct mwifiex_sta_node *sta_ptr;\r\nu8 *peer, *pos, *end;\r\nu8 i, action, basic;\r\n__le16 cap = 0;\r\nint ie_len = 0;\r\nif (len < (sizeof(struct ethhdr) + 3))\r\nreturn;\r\nif (*(buf + sizeof(struct ethhdr)) != WLAN_TDLS_SNAP_RFTYPE)\r\nreturn;\r\nif (*(buf + sizeof(struct ethhdr) + 1) != WLAN_CATEGORY_TDLS)\r\nreturn;\r\npeer = buf + ETH_ALEN;\r\naction = *(buf + sizeof(struct ethhdr) + 2);\r\ndev_dbg(priv->adapter->dev,\r\n"rx:tdls action: peer=%pM, action=%d\n", peer, action);\r\nswitch (action) {\r\ncase WLAN_TDLS_SETUP_REQUEST:\r\nif (len < (sizeof(struct ethhdr) + TDLS_REQ_FIX_LEN))\r\nreturn;\r\npos = buf + sizeof(struct ethhdr) + 4;\r\ncap = cpu_to_le16(*(u16 *)pos);\r\nie_len = len - sizeof(struct ethhdr) - TDLS_REQ_FIX_LEN;\r\npos += 2;\r\nbreak;\r\ncase WLAN_TDLS_SETUP_RESPONSE:\r\nif (len < (sizeof(struct ethhdr) + TDLS_RESP_FIX_LEN))\r\nreturn;\r\npos = buf + sizeof(struct ethhdr) + 6;\r\ncap = cpu_to_le16(*(u16 *)pos);\r\nie_len = len - sizeof(struct ethhdr) - TDLS_RESP_FIX_LEN;\r\npos += 2;\r\nbreak;\r\ncase WLAN_TDLS_SETUP_CONFIRM:\r\nif (len < (sizeof(struct ethhdr) + TDLS_CONFIRM_FIX_LEN))\r\nreturn;\r\npos = buf + sizeof(struct ethhdr) + TDLS_CONFIRM_FIX_LEN;\r\nie_len = len - sizeof(struct ethhdr) - TDLS_CONFIRM_FIX_LEN;\r\nbreak;\r\ndefault:\r\ndev_dbg(priv->adapter->dev, "Unknown TDLS frame type.\n");\r\nreturn;\r\n}\r\nsta_ptr = mwifiex_add_sta_entry(priv, peer);\r\nif (!sta_ptr)\r\nreturn;\r\nsta_ptr->tdls_cap.capab = cap;\r\nfor (end = pos + ie_len; pos + 1 < end; pos += 2 + pos[1]) {\r\nif (pos + 2 + pos[1] > end)\r\nbreak;\r\nswitch (*pos) {\r\ncase WLAN_EID_SUPP_RATES:\r\nsta_ptr->tdls_cap.rates_len = pos[1];\r\nfor (i = 0; i < pos[1]; i++)\r\nsta_ptr->tdls_cap.rates[i] = pos[i + 2];\r\nbreak;\r\ncase WLAN_EID_EXT_SUPP_RATES:\r\nbasic = sta_ptr->tdls_cap.rates_len;\r\nfor (i = 0; i < pos[1]; i++)\r\nsta_ptr->tdls_cap.rates[basic + i] = pos[i + 2];\r\nsta_ptr->tdls_cap.rates_len += pos[1];\r\nbreak;\r\ncase WLAN_EID_HT_CAPABILITY:\r\nmemcpy((u8 *)&sta_ptr->tdls_cap.ht_capb, pos,\r\nsizeof(struct ieee80211_ht_cap));\r\nsta_ptr->is_11n_enabled = 1;\r\nbreak;\r\ncase WLAN_EID_HT_OPERATION:\r\nmemcpy(&sta_ptr->tdls_cap.ht_oper, pos,\r\nsizeof(struct ieee80211_ht_operation));\r\nbreak;\r\ncase WLAN_EID_BSS_COEX_2040:\r\nsta_ptr->tdls_cap.coex_2040 = pos[2];\r\nbreak;\r\ncase WLAN_EID_EXT_CAPABILITY:\r\nmemcpy((u8 *)&sta_ptr->tdls_cap.extcap, pos,\r\nsizeof(struct ieee_types_header) +\r\nmin_t(u8, pos[1], 8));\r\nbreak;\r\ncase WLAN_EID_RSN:\r\nmemcpy((u8 *)&sta_ptr->tdls_cap.rsn_ie, pos,\r\nsizeof(struct ieee_types_header) +\r\nmin_t(u8, pos[1], IEEE_MAX_IE_SIZE -\r\nsizeof(struct ieee_types_header)));\r\nbreak;\r\ncase WLAN_EID_QOS_CAPA:\r\nsta_ptr->tdls_cap.qos_info = pos[2];\r\nbreak;\r\ncase WLAN_EID_VHT_OPERATION:\r\nif (priv->adapter->is_hw_11ac_capable)\r\nmemcpy(&sta_ptr->tdls_cap.vhtoper, pos,\r\nsizeof(struct ieee80211_vht_operation));\r\nbreak;\r\ncase WLAN_EID_VHT_CAPABILITY:\r\nif (priv->adapter->is_hw_11ac_capable) {\r\nmemcpy((u8 *)&sta_ptr->tdls_cap.vhtcap, pos,\r\nsizeof(struct ieee80211_vht_cap));\r\nsta_ptr->is_11ac_enabled = 1;\r\n}\r\nbreak;\r\ncase WLAN_EID_AID:\r\nif (priv->adapter->is_hw_11ac_capable)\r\nsta_ptr->tdls_cap.aid =\r\nle16_to_cpu(*(__le16 *)(pos + 2));\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nreturn;\r\n}\r\nstatic int\r\nmwifiex_tdls_process_config_link(struct mwifiex_private *priv, const u8 *peer)\r\n{\r\nstruct mwifiex_sta_node *sta_ptr;\r\nstruct mwifiex_ds_tdls_oper tdls_oper;\r\nmemset(&tdls_oper, 0, sizeof(struct mwifiex_ds_tdls_oper));\r\nsta_ptr = mwifiex_get_sta_entry(priv, peer);\r\nif (!sta_ptr || sta_ptr->tdls_status == TDLS_SETUP_FAILURE) {\r\ndev_err(priv->adapter->dev,\r\n"link absent for peer %pM; cannot config\n", peer);\r\nreturn -EINVAL;\r\n}\r\nmemcpy(&tdls_oper.peer_mac, peer, ETH_ALEN);\r\ntdls_oper.tdls_action = MWIFIEX_TDLS_CONFIG_LINK;\r\nreturn mwifiex_send_cmd(priv, HostCmd_CMD_TDLS_OPER,\r\nHostCmd_ACT_GEN_SET, 0, &tdls_oper, true);\r\n}\r\nstatic int\r\nmwifiex_tdls_process_create_link(struct mwifiex_private *priv, const u8 *peer)\r\n{\r\nstruct mwifiex_sta_node *sta_ptr;\r\nstruct mwifiex_ds_tdls_oper tdls_oper;\r\nmemset(&tdls_oper, 0, sizeof(struct mwifiex_ds_tdls_oper));\r\nsta_ptr = mwifiex_get_sta_entry(priv, peer);\r\nif (sta_ptr && sta_ptr->tdls_status == TDLS_SETUP_INPROGRESS) {\r\ndev_dbg(priv->adapter->dev,\r\n"Setup already in progress for peer %pM\n", peer);\r\nreturn 0;\r\n}\r\nsta_ptr = mwifiex_add_sta_entry(priv, peer);\r\nif (!sta_ptr)\r\nreturn -ENOMEM;\r\nsta_ptr->tdls_status = TDLS_SETUP_INPROGRESS;\r\nmwifiex_hold_tdls_packets(priv, peer);\r\nmemcpy(&tdls_oper.peer_mac, peer, ETH_ALEN);\r\ntdls_oper.tdls_action = MWIFIEX_TDLS_CREATE_LINK;\r\nreturn mwifiex_send_cmd(priv, HostCmd_CMD_TDLS_OPER,\r\nHostCmd_ACT_GEN_SET, 0, &tdls_oper, true);\r\n}\r\nstatic int\r\nmwifiex_tdls_process_disable_link(struct mwifiex_private *priv, const u8 *peer)\r\n{\r\nstruct mwifiex_sta_node *sta_ptr;\r\nstruct mwifiex_ds_tdls_oper tdls_oper;\r\nunsigned long flags;\r\nmemset(&tdls_oper, 0, sizeof(struct mwifiex_ds_tdls_oper));\r\nsta_ptr = mwifiex_get_sta_entry(priv, peer);\r\nif (sta_ptr) {\r\nif (sta_ptr->is_11n_enabled) {\r\nmwifiex_11n_cleanup_reorder_tbl(priv);\r\nspin_lock_irqsave(&priv->wmm.ra_list_spinlock,\r\nflags);\r\nmwifiex_11n_delete_all_tx_ba_stream_tbl(priv);\r\nspin_unlock_irqrestore(&priv->wmm.ra_list_spinlock,\r\nflags);\r\n}\r\nmwifiex_del_sta_entry(priv, peer);\r\n}\r\nmwifiex_restore_tdls_packets(priv, peer, TDLS_LINK_TEARDOWN);\r\nmwifiex_auto_tdls_update_peer_status(priv, peer, TDLS_NOT_SETUP);\r\nmemcpy(&tdls_oper.peer_mac, peer, ETH_ALEN);\r\ntdls_oper.tdls_action = MWIFIEX_TDLS_DISABLE_LINK;\r\nreturn mwifiex_send_cmd(priv, HostCmd_CMD_TDLS_OPER,\r\nHostCmd_ACT_GEN_SET, 0, &tdls_oper, true);\r\n}\r\nstatic int\r\nmwifiex_tdls_process_enable_link(struct mwifiex_private *priv, const u8 *peer)\r\n{\r\nstruct mwifiex_sta_node *sta_ptr;\r\nstruct ieee80211_mcs_info mcs;\r\nunsigned long flags;\r\nint i;\r\nsta_ptr = mwifiex_get_sta_entry(priv, peer);\r\nif (sta_ptr && (sta_ptr->tdls_status != TDLS_SETUP_FAILURE)) {\r\ndev_dbg(priv->adapter->dev,\r\n"tdls: enable link %pM success\n", peer);\r\nsta_ptr->tdls_status = TDLS_SETUP_COMPLETE;\r\nmcs = sta_ptr->tdls_cap.ht_capb.mcs;\r\nif (mcs.rx_mask[0] != 0xff)\r\nsta_ptr->is_11n_enabled = true;\r\nif (sta_ptr->is_11n_enabled) {\r\nif (le16_to_cpu(sta_ptr->tdls_cap.ht_capb.cap_info) &\r\nIEEE80211_HT_CAP_MAX_AMSDU)\r\nsta_ptr->max_amsdu =\r\nMWIFIEX_TX_DATA_BUF_SIZE_8K;\r\nelse\r\nsta_ptr->max_amsdu =\r\nMWIFIEX_TX_DATA_BUF_SIZE_4K;\r\nfor (i = 0; i < MAX_NUM_TID; i++)\r\nsta_ptr->ampdu_sta[i] =\r\npriv->aggr_prio_tbl[i].ampdu_user;\r\n} else {\r\nfor (i = 0; i < MAX_NUM_TID; i++)\r\nsta_ptr->ampdu_sta[i] = BA_STREAM_NOT_ALLOWED;\r\n}\r\nmemset(sta_ptr->rx_seq, 0xff, sizeof(sta_ptr->rx_seq));\r\nmwifiex_restore_tdls_packets(priv, peer, TDLS_SETUP_COMPLETE);\r\nmwifiex_auto_tdls_update_peer_status(priv, peer,\r\nTDLS_SETUP_COMPLETE);\r\n} else {\r\ndev_dbg(priv->adapter->dev,\r\n"tdls: enable link %pM failed\n", peer);\r\nif (sta_ptr) {\r\nmwifiex_11n_cleanup_reorder_tbl(priv);\r\nspin_lock_irqsave(&priv->wmm.ra_list_spinlock,\r\nflags);\r\nmwifiex_11n_delete_all_tx_ba_stream_tbl(priv);\r\nspin_unlock_irqrestore(&priv->wmm.ra_list_spinlock,\r\nflags);\r\nmwifiex_del_sta_entry(priv, peer);\r\n}\r\nmwifiex_restore_tdls_packets(priv, peer, TDLS_LINK_TEARDOWN);\r\nmwifiex_auto_tdls_update_peer_status(priv, peer,\r\nTDLS_NOT_SETUP);\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nint mwifiex_tdls_oper(struct mwifiex_private *priv, const u8 *peer, u8 action)\r\n{\r\nswitch (action) {\r\ncase MWIFIEX_TDLS_ENABLE_LINK:\r\nreturn mwifiex_tdls_process_enable_link(priv, peer);\r\ncase MWIFIEX_TDLS_DISABLE_LINK:\r\nreturn mwifiex_tdls_process_disable_link(priv, peer);\r\ncase MWIFIEX_TDLS_CREATE_LINK:\r\nreturn mwifiex_tdls_process_create_link(priv, peer);\r\ncase MWIFIEX_TDLS_CONFIG_LINK:\r\nreturn mwifiex_tdls_process_config_link(priv, peer);\r\n}\r\nreturn 0;\r\n}\r\nint mwifiex_get_tdls_link_status(struct mwifiex_private *priv, const u8 *mac)\r\n{\r\nstruct mwifiex_sta_node *sta_ptr;\r\nsta_ptr = mwifiex_get_sta_entry(priv, mac);\r\nif (sta_ptr)\r\nreturn sta_ptr->tdls_status;\r\nreturn TDLS_NOT_SETUP;\r\n}\r\nint mwifiex_get_tdls_list(struct mwifiex_private *priv,\r\nstruct tdls_peer_info *buf)\r\n{\r\nstruct mwifiex_sta_node *sta_ptr;\r\nstruct tdls_peer_info *peer = buf;\r\nint count = 0;\r\nunsigned long flags;\r\nif (!ISSUPP_TDLS_ENABLED(priv->adapter->fw_cap_info))\r\nreturn 0;\r\nif (!(priv->bss_type == MWIFIEX_BSS_TYPE_STA && priv->media_connected))\r\nreturn 0;\r\nspin_lock_irqsave(&priv->sta_list_spinlock, flags);\r\nlist_for_each_entry(sta_ptr, &priv->sta_list, list) {\r\nif (sta_ptr->tdls_status == TDLS_SETUP_COMPLETE) {\r\nether_addr_copy(peer->peer_addr, sta_ptr->mac_addr);\r\npeer++;\r\ncount++;\r\nif (count >= MWIFIEX_MAX_TDLS_PEER_SUPPORTED)\r\nbreak;\r\n}\r\n}\r\nspin_unlock_irqrestore(&priv->sta_list_spinlock, flags);\r\nreturn count;\r\n}\r\nvoid mwifiex_disable_all_tdls_links(struct mwifiex_private *priv)\r\n{\r\nstruct mwifiex_sta_node *sta_ptr;\r\nstruct mwifiex_ds_tdls_oper tdls_oper;\r\nunsigned long flags;\r\nif (list_empty(&priv->sta_list))\r\nreturn;\r\nlist_for_each_entry(sta_ptr, &priv->sta_list, list) {\r\nmemset(&tdls_oper, 0, sizeof(struct mwifiex_ds_tdls_oper));\r\nif (sta_ptr->is_11n_enabled) {\r\nmwifiex_11n_cleanup_reorder_tbl(priv);\r\nspin_lock_irqsave(&priv->wmm.ra_list_spinlock,\r\nflags);\r\nmwifiex_11n_delete_all_tx_ba_stream_tbl(priv);\r\nspin_unlock_irqrestore(&priv->wmm.ra_list_spinlock,\r\nflags);\r\n}\r\nmwifiex_restore_tdls_packets(priv, sta_ptr->mac_addr,\r\nTDLS_LINK_TEARDOWN);\r\nmemcpy(&tdls_oper.peer_mac, sta_ptr->mac_addr, ETH_ALEN);\r\ntdls_oper.tdls_action = MWIFIEX_TDLS_DISABLE_LINK;\r\nif (mwifiex_send_cmd(priv, HostCmd_CMD_TDLS_OPER,\r\nHostCmd_ACT_GEN_SET, 0, &tdls_oper, false))\r\ndev_warn(priv->adapter->dev,\r\n"Disable link failed for TDLS peer %pM",\r\nsta_ptr->mac_addr);\r\n}\r\nmwifiex_del_all_sta_list(priv);\r\n}\r\nint mwifiex_tdls_check_tx(struct mwifiex_private *priv, struct sk_buff *skb)\r\n{\r\nstruct mwifiex_auto_tdls_peer *peer;\r\nunsigned long flags;\r\nu8 mac[ETH_ALEN];\r\nether_addr_copy(mac, skb->data);\r\nspin_lock_irqsave(&priv->auto_tdls_lock, flags);\r\nlist_for_each_entry(peer, &priv->auto_tdls_list, list) {\r\nif (!memcmp(mac, peer->mac_addr, ETH_ALEN)) {\r\nif (peer->rssi <= MWIFIEX_TDLS_RSSI_HIGH &&\r\npeer->tdls_status == TDLS_NOT_SETUP &&\r\n(peer->failure_count <\r\nMWIFIEX_TDLS_MAX_FAIL_COUNT)) {\r\npeer->tdls_status = TDLS_SETUP_INPROGRESS;\r\ndev_dbg(priv->adapter->dev,\r\n"setup TDLS link, peer=%pM rssi=%d\n",\r\npeer->mac_addr, peer->rssi);\r\ncfg80211_tdls_oper_request(priv->netdev,\r\npeer->mac_addr,\r\nNL80211_TDLS_SETUP,\r\n0, GFP_ATOMIC);\r\npeer->do_setup = false;\r\npriv->check_tdls_tx = false;\r\n} else if (peer->failure_count <\r\nMWIFIEX_TDLS_MAX_FAIL_COUNT &&\r\npeer->do_discover) {\r\nmwifiex_send_tdls_data_frame(priv,\r\npeer->mac_addr,\r\nWLAN_TDLS_DISCOVERY_REQUEST,\r\n1, 0, NULL, 0);\r\npeer->do_discover = false;\r\n}\r\n}\r\n}\r\nspin_unlock_irqrestore(&priv->auto_tdls_lock, flags);\r\nreturn 0;\r\n}\r\nvoid mwifiex_flush_auto_tdls_list(struct mwifiex_private *priv)\r\n{\r\nstruct mwifiex_auto_tdls_peer *peer, *tmp_node;\r\nunsigned long flags;\r\nspin_lock_irqsave(&priv->auto_tdls_lock, flags);\r\nlist_for_each_entry_safe(peer, tmp_node, &priv->auto_tdls_list, list) {\r\nlist_del(&peer->list);\r\nkfree(peer);\r\n}\r\nINIT_LIST_HEAD(&priv->auto_tdls_list);\r\nspin_unlock_irqrestore(&priv->auto_tdls_lock, flags);\r\npriv->check_tdls_tx = false;\r\n}\r\nvoid mwifiex_add_auto_tdls_peer(struct mwifiex_private *priv, const u8 *mac)\r\n{\r\nstruct mwifiex_auto_tdls_peer *tdls_peer;\r\nunsigned long flags;\r\nif (!priv->adapter->auto_tdls)\r\nreturn;\r\nspin_lock_irqsave(&priv->auto_tdls_lock, flags);\r\nlist_for_each_entry(tdls_peer, &priv->auto_tdls_list, list) {\r\nif (!memcmp(tdls_peer->mac_addr, mac, ETH_ALEN)) {\r\ntdls_peer->tdls_status = TDLS_SETUP_INPROGRESS;\r\ntdls_peer->rssi_jiffies = jiffies;\r\nspin_unlock_irqrestore(&priv->auto_tdls_lock, flags);\r\nreturn;\r\n}\r\n}\r\ntdls_peer = kzalloc(sizeof(*tdls_peer), GFP_ATOMIC);\r\nif (tdls_peer) {\r\nether_addr_copy(tdls_peer->mac_addr, mac);\r\ntdls_peer->tdls_status = TDLS_SETUP_INPROGRESS;\r\ntdls_peer->rssi_jiffies = jiffies;\r\nINIT_LIST_HEAD(&tdls_peer->list);\r\nlist_add_tail(&tdls_peer->list, &priv->auto_tdls_list);\r\ndev_dbg(priv->adapter->dev, "Add auto TDLS peer= %pM to list\n",\r\nmac);\r\n}\r\nspin_unlock_irqrestore(&priv->auto_tdls_lock, flags);\r\n}\r\nvoid mwifiex_auto_tdls_update_peer_status(struct mwifiex_private *priv,\r\nconst u8 *mac, u8 link_status)\r\n{\r\nstruct mwifiex_auto_tdls_peer *peer;\r\nunsigned long flags;\r\nif (!priv->adapter->auto_tdls)\r\nreturn;\r\nspin_lock_irqsave(&priv->auto_tdls_lock, flags);\r\nlist_for_each_entry(peer, &priv->auto_tdls_list, list) {\r\nif (!memcmp(peer->mac_addr, mac, ETH_ALEN)) {\r\nif ((link_status == TDLS_NOT_SETUP) &&\r\n(peer->tdls_status == TDLS_SETUP_INPROGRESS))\r\npeer->failure_count++;\r\nelse if (link_status == TDLS_SETUP_COMPLETE)\r\npeer->failure_count = 0;\r\npeer->tdls_status = link_status;\r\nbreak;\r\n}\r\n}\r\nspin_unlock_irqrestore(&priv->auto_tdls_lock, flags);\r\n}\r\nvoid mwifiex_auto_tdls_update_peer_signal(struct mwifiex_private *priv,\r\nu8 *mac, s8 snr, s8 nflr)\r\n{\r\nstruct mwifiex_auto_tdls_peer *peer;\r\nunsigned long flags;\r\nif (!priv->adapter->auto_tdls)\r\nreturn;\r\nspin_lock_irqsave(&priv->auto_tdls_lock, flags);\r\nlist_for_each_entry(peer, &priv->auto_tdls_list, list) {\r\nif (!memcmp(peer->mac_addr, mac, ETH_ALEN)) {\r\npeer->rssi = nflr - snr;\r\npeer->rssi_jiffies = jiffies;\r\nbreak;\r\n}\r\n}\r\nspin_unlock_irqrestore(&priv->auto_tdls_lock, flags);\r\n}\r\nvoid mwifiex_check_auto_tdls(unsigned long context)\r\n{\r\nstruct mwifiex_private *priv = (struct mwifiex_private *)context;\r\nstruct mwifiex_auto_tdls_peer *tdls_peer;\r\nunsigned long flags;\r\nu16 reason = WLAN_REASON_TDLS_TEARDOWN_UNSPECIFIED;\r\nif (WARN_ON_ONCE(!priv || !priv->adapter)) {\r\npr_err("mwifiex: %s: adapter or private structure is NULL\n",\r\n__func__);\r\nreturn;\r\n}\r\nif (unlikely(!priv->adapter->auto_tdls))\r\nreturn;\r\nif (!priv->auto_tdls_timer_active) {\r\ndev_dbg(priv->adapter->dev,\r\n"auto TDLS timer inactive; return");\r\nreturn;\r\n}\r\npriv->check_tdls_tx = false;\r\nif (list_empty(&priv->auto_tdls_list)) {\r\nmod_timer(&priv->auto_tdls_timer,\r\njiffies +\r\nmsecs_to_jiffies(MWIFIEX_TIMER_10S));\r\nreturn;\r\n}\r\nspin_lock_irqsave(&priv->auto_tdls_lock, flags);\r\nlist_for_each_entry(tdls_peer, &priv->auto_tdls_list, list) {\r\nif ((jiffies - tdls_peer->rssi_jiffies) >\r\n(MWIFIEX_AUTO_TDLS_IDLE_TIME * HZ)) {\r\ntdls_peer->rssi = 0;\r\ntdls_peer->do_discover = true;\r\npriv->check_tdls_tx = true;\r\n}\r\nif (((tdls_peer->rssi >= MWIFIEX_TDLS_RSSI_LOW) ||\r\n!tdls_peer->rssi) &&\r\ntdls_peer->tdls_status == TDLS_SETUP_COMPLETE) {\r\ntdls_peer->tdls_status = TDLS_LINK_TEARDOWN;\r\ndev_dbg(priv->adapter->dev,\r\n"teardown TDLS link,peer=%pM rssi=%d\n",\r\ntdls_peer->mac_addr, -tdls_peer->rssi);\r\ntdls_peer->do_discover = true;\r\npriv->check_tdls_tx = true;\r\ncfg80211_tdls_oper_request(priv->netdev,\r\ntdls_peer->mac_addr,\r\nNL80211_TDLS_TEARDOWN,\r\nreason, GFP_ATOMIC);\r\n} else if (tdls_peer->rssi &&\r\ntdls_peer->rssi <= MWIFIEX_TDLS_RSSI_HIGH &&\r\ntdls_peer->tdls_status == TDLS_NOT_SETUP &&\r\ntdls_peer->failure_count <\r\nMWIFIEX_TDLS_MAX_FAIL_COUNT) {\r\npriv->check_tdls_tx = true;\r\ntdls_peer->do_setup = true;\r\ndev_dbg(priv->adapter->dev,\r\n"check TDLS with peer=%pM rssi=%d\n",\r\ntdls_peer->mac_addr, -tdls_peer->rssi);\r\n}\r\n}\r\nspin_unlock_irqrestore(&priv->auto_tdls_lock, flags);\r\nmod_timer(&priv->auto_tdls_timer,\r\njiffies + msecs_to_jiffies(MWIFIEX_TIMER_10S));\r\n}\r\nvoid mwifiex_setup_auto_tdls_timer(struct mwifiex_private *priv)\r\n{\r\nsetup_timer(&priv->auto_tdls_timer, mwifiex_check_auto_tdls,\r\n(unsigned long)priv);\r\npriv->auto_tdls_timer_active = true;\r\nmod_timer(&priv->auto_tdls_timer,\r\njiffies + msecs_to_jiffies(MWIFIEX_TIMER_10S));\r\n}\r\nvoid mwifiex_clean_auto_tdls(struct mwifiex_private *priv)\r\n{\r\nif (ISSUPP_TDLS_ENABLED(priv->adapter->fw_cap_info) &&\r\npriv->adapter->auto_tdls &&\r\npriv->bss_type == MWIFIEX_BSS_TYPE_STA) {\r\npriv->auto_tdls_timer_active = false;\r\ndel_timer(&priv->auto_tdls_timer);\r\nmwifiex_flush_auto_tdls_list(priv);\r\n}\r\n}
