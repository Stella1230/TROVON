static int get_idr(struct idr *idr, int *id)\r\n{\r\nint ret;\r\nmutex_lock(&cooling_cpufreq_lock);\r\nret = idr_alloc(idr, NULL, 0, 0, GFP_KERNEL);\r\nmutex_unlock(&cooling_cpufreq_lock);\r\nif (unlikely(ret < 0))\r\nreturn ret;\r\n*id = ret;\r\nreturn 0;\r\n}\r\nstatic void release_idr(struct idr *idr, int id)\r\n{\r\nmutex_lock(&cooling_cpufreq_lock);\r\nidr_remove(idr, id);\r\nmutex_unlock(&cooling_cpufreq_lock);\r\n}\r\nstatic unsigned long get_level(struct cpufreq_cooling_device *cpufreq_dev,\r\nunsigned int freq)\r\n{\r\nunsigned long level;\r\nfor (level = 0; level <= cpufreq_dev->max_level; level++) {\r\nif (freq == cpufreq_dev->freq_table[level])\r\nreturn level;\r\nif (freq > cpufreq_dev->freq_table[level])\r\nbreak;\r\n}\r\nreturn THERMAL_CSTATE_INVALID;\r\n}\r\nunsigned long cpufreq_cooling_get_level(unsigned int cpu, unsigned int freq)\r\n{\r\nstruct cpufreq_cooling_device *cpufreq_dev;\r\nmutex_lock(&cooling_cpufreq_lock);\r\nlist_for_each_entry(cpufreq_dev, &cpufreq_dev_list, node) {\r\nif (cpumask_test_cpu(cpu, &cpufreq_dev->allowed_cpus)) {\r\nmutex_unlock(&cooling_cpufreq_lock);\r\nreturn get_level(cpufreq_dev, freq);\r\n}\r\n}\r\nmutex_unlock(&cooling_cpufreq_lock);\r\npr_err("%s: cpu:%d not part of any cooling device\n", __func__, cpu);\r\nreturn THERMAL_CSTATE_INVALID;\r\n}\r\nstatic int cpufreq_thermal_notifier(struct notifier_block *nb,\r\nunsigned long event, void *data)\r\n{\r\nstruct cpufreq_policy *policy = data;\r\nunsigned long max_freq = 0;\r\nstruct cpufreq_cooling_device *cpufreq_dev;\r\nif (event != CPUFREQ_ADJUST)\r\nreturn 0;\r\nmutex_lock(&cooling_cpufreq_lock);\r\nlist_for_each_entry(cpufreq_dev, &cpufreq_dev_list, node) {\r\nif (!cpumask_test_cpu(policy->cpu,\r\n&cpufreq_dev->allowed_cpus))\r\ncontinue;\r\nmax_freq = cpufreq_dev->cpufreq_val;\r\nif (policy->max != max_freq)\r\ncpufreq_verify_within_limits(policy, 0, max_freq);\r\n}\r\nmutex_unlock(&cooling_cpufreq_lock);\r\nreturn 0;\r\n}\r\nstatic int cpufreq_get_max_state(struct thermal_cooling_device *cdev,\r\nunsigned long *state)\r\n{\r\nstruct cpufreq_cooling_device *cpufreq_device = cdev->devdata;\r\n*state = cpufreq_device->max_level;\r\nreturn 0;\r\n}\r\nstatic int cpufreq_get_cur_state(struct thermal_cooling_device *cdev,\r\nunsigned long *state)\r\n{\r\nstruct cpufreq_cooling_device *cpufreq_device = cdev->devdata;\r\n*state = cpufreq_device->cpufreq_state;\r\nreturn 0;\r\n}\r\nstatic int cpufreq_set_cur_state(struct thermal_cooling_device *cdev,\r\nunsigned long state)\r\n{\r\nstruct cpufreq_cooling_device *cpufreq_device = cdev->devdata;\r\nunsigned int cpu = cpumask_any(&cpufreq_device->allowed_cpus);\r\nunsigned int clip_freq;\r\nif (WARN_ON(state > cpufreq_device->max_level))\r\nreturn -EINVAL;\r\nif (cpufreq_device->cpufreq_state == state)\r\nreturn 0;\r\nclip_freq = cpufreq_device->freq_table[state];\r\ncpufreq_device->cpufreq_state = state;\r\ncpufreq_device->cpufreq_val = clip_freq;\r\ncpufreq_update_policy(cpu);\r\nreturn 0;\r\n}\r\nstatic unsigned int find_next_max(struct cpufreq_frequency_table *table,\r\nunsigned int prev_max)\r\n{\r\nstruct cpufreq_frequency_table *pos;\r\nunsigned int max = 0;\r\ncpufreq_for_each_valid_entry(pos, table) {\r\nif (pos->frequency > max && pos->frequency < prev_max)\r\nmax = pos->frequency;\r\n}\r\nreturn max;\r\n}\r\nstatic struct thermal_cooling_device *\r\n__cpufreq_cooling_register(struct device_node *np,\r\nconst struct cpumask *clip_cpus)\r\n{\r\nstruct thermal_cooling_device *cool_dev;\r\nstruct cpufreq_cooling_device *cpufreq_dev;\r\nchar dev_name[THERMAL_NAME_LENGTH];\r\nstruct cpufreq_frequency_table *pos, *table;\r\nunsigned int freq, i;\r\nint ret;\r\ntable = cpufreq_frequency_get_table(cpumask_first(clip_cpus));\r\nif (!table) {\r\npr_debug("%s: CPUFreq table not found\n", __func__);\r\nreturn ERR_PTR(-EPROBE_DEFER);\r\n}\r\ncpufreq_dev = kzalloc(sizeof(*cpufreq_dev), GFP_KERNEL);\r\nif (!cpufreq_dev)\r\nreturn ERR_PTR(-ENOMEM);\r\ncpufreq_for_each_valid_entry(pos, table)\r\ncpufreq_dev->max_level++;\r\ncpufreq_dev->freq_table = kmalloc(sizeof(*cpufreq_dev->freq_table) *\r\ncpufreq_dev->max_level, GFP_KERNEL);\r\nif (!cpufreq_dev->freq_table) {\r\ncool_dev = ERR_PTR(-ENOMEM);\r\ngoto free_cdev;\r\n}\r\ncpufreq_dev->max_level--;\r\ncpumask_copy(&cpufreq_dev->allowed_cpus, clip_cpus);\r\nret = get_idr(&cpufreq_idr, &cpufreq_dev->id);\r\nif (ret) {\r\ncool_dev = ERR_PTR(ret);\r\ngoto free_table;\r\n}\r\nsnprintf(dev_name, sizeof(dev_name), "thermal-cpufreq-%d",\r\ncpufreq_dev->id);\r\ncool_dev = thermal_of_cooling_device_register(np, dev_name, cpufreq_dev,\r\n&cpufreq_cooling_ops);\r\nif (IS_ERR(cool_dev))\r\ngoto remove_idr;\r\nfor (i = 0, freq = -1; i <= cpufreq_dev->max_level; i++) {\r\nfreq = find_next_max(table, freq);\r\ncpufreq_dev->freq_table[i] = freq;\r\nif (!freq)\r\npr_warn("%s: table has duplicate entries\n", __func__);\r\nelse\r\npr_debug("%s: freq:%u KHz\n", __func__, freq);\r\n}\r\ncpufreq_dev->cpufreq_val = cpufreq_dev->freq_table[0];\r\ncpufreq_dev->cool_dev = cool_dev;\r\nmutex_lock(&cooling_cpufreq_lock);\r\nif (list_empty(&cpufreq_dev_list))\r\ncpufreq_register_notifier(&thermal_cpufreq_notifier_block,\r\nCPUFREQ_POLICY_NOTIFIER);\r\nlist_add(&cpufreq_dev->node, &cpufreq_dev_list);\r\nmutex_unlock(&cooling_cpufreq_lock);\r\nreturn cool_dev;\r\nremove_idr:\r\nrelease_idr(&cpufreq_idr, cpufreq_dev->id);\r\nfree_table:\r\nkfree(cpufreq_dev->freq_table);\r\nfree_cdev:\r\nkfree(cpufreq_dev);\r\nreturn cool_dev;\r\n}\r\nstruct thermal_cooling_device *\r\ncpufreq_cooling_register(const struct cpumask *clip_cpus)\r\n{\r\nreturn __cpufreq_cooling_register(NULL, clip_cpus);\r\n}\r\nstruct thermal_cooling_device *\r\nof_cpufreq_cooling_register(struct device_node *np,\r\nconst struct cpumask *clip_cpus)\r\n{\r\nif (!np)\r\nreturn ERR_PTR(-EINVAL);\r\nreturn __cpufreq_cooling_register(np, clip_cpus);\r\n}\r\nvoid cpufreq_cooling_unregister(struct thermal_cooling_device *cdev)\r\n{\r\nstruct cpufreq_cooling_device *cpufreq_dev;\r\nif (!cdev)\r\nreturn;\r\ncpufreq_dev = cdev->devdata;\r\nmutex_lock(&cooling_cpufreq_lock);\r\nlist_del(&cpufreq_dev->node);\r\nif (list_empty(&cpufreq_dev_list))\r\ncpufreq_unregister_notifier(&thermal_cpufreq_notifier_block,\r\nCPUFREQ_POLICY_NOTIFIER);\r\nmutex_unlock(&cooling_cpufreq_lock);\r\nthermal_cooling_device_unregister(cpufreq_dev->cool_dev);\r\nrelease_idr(&cpufreq_idr, cpufreq_dev->id);\r\nkfree(cpufreq_dev->freq_table);\r\nkfree(cpufreq_dev);\r\n}
