struct asymmetric_key_id *asymmetric_key_generate_id(const void *val_1,\r\nsize_t len_1,\r\nconst void *val_2,\r\nsize_t len_2)\r\n{\r\nstruct asymmetric_key_id *kid;\r\nkid = kmalloc(sizeof(struct asymmetric_key_id) + len_1 + len_2,\r\nGFP_KERNEL);\r\nif (!kid)\r\nreturn ERR_PTR(-ENOMEM);\r\nkid->len = len_1 + len_2;\r\nmemcpy(kid->data, val_1, len_1);\r\nmemcpy(kid->data + len_1, val_2, len_2);\r\nreturn kid;\r\n}\r\nbool asymmetric_key_id_same(const struct asymmetric_key_id *kid1,\r\nconst struct asymmetric_key_id *kid2)\r\n{\r\nif (!kid1 || !kid2)\r\nreturn false;\r\nif (kid1->len != kid2->len)\r\nreturn false;\r\nreturn memcmp(kid1->data, kid2->data, kid1->len) == 0;\r\n}\r\nbool asymmetric_key_id_partial(const struct asymmetric_key_id *kid1,\r\nconst struct asymmetric_key_id *kid2)\r\n{\r\nif (!kid1 || !kid2)\r\nreturn false;\r\nif (kid1->len < kid2->len)\r\nreturn false;\r\nreturn memcmp(kid1->data + (kid1->len - kid2->len),\r\nkid2->data, kid2->len) == 0;\r\n}\r\nstatic bool asymmetric_match_key_ids(\r\nconst struct asymmetric_key_ids *kids,\r\nconst struct asymmetric_key_id *match_id,\r\nbool (*match)(const struct asymmetric_key_id *kid1,\r\nconst struct asymmetric_key_id *kid2))\r\n{\r\nint i;\r\nif (!kids || !match_id)\r\nreturn false;\r\nfor (i = 0; i < ARRAY_SIZE(kids->id); i++)\r\nif (match(kids->id[i], match_id))\r\nreturn true;\r\nreturn false;\r\n}\r\nstruct asymmetric_key_id *asymmetric_key_hex_to_key_id(const char *id)\r\n{\r\nstruct asymmetric_key_id *match_id;\r\nsize_t hexlen;\r\nint ret;\r\nif (!*id)\r\nreturn ERR_PTR(-EINVAL);\r\nhexlen = strlen(id);\r\nif (hexlen & 1)\r\nreturn ERR_PTR(-EINVAL);\r\nmatch_id = kmalloc(sizeof(struct asymmetric_key_id) + hexlen / 2,\r\nGFP_KERNEL);\r\nif (!match_id)\r\nreturn ERR_PTR(-ENOMEM);\r\nmatch_id->len = hexlen / 2;\r\nret = hex2bin(match_id->data, id, hexlen / 2);\r\nif (ret < 0) {\r\nkfree(match_id);\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nreturn match_id;\r\n}\r\nstatic bool asymmetric_key_cmp(const struct key *key,\r\nconst struct key_match_data *match_data)\r\n{\r\nconst struct asymmetric_key_ids *kids = asymmetric_key_ids(key);\r\nconst struct asymmetric_key_id *match_id = match_data->preparsed;\r\nreturn asymmetric_match_key_ids(kids, match_id,\r\nasymmetric_key_id_same);\r\n}\r\nstatic bool asymmetric_key_cmp_partial(const struct key *key,\r\nconst struct key_match_data *match_data)\r\n{\r\nconst struct asymmetric_key_ids *kids = asymmetric_key_ids(key);\r\nconst struct asymmetric_key_id *match_id = match_data->preparsed;\r\nreturn asymmetric_match_key_ids(kids, match_id,\r\nasymmetric_key_id_partial);\r\n}\r\nstatic int asymmetric_key_match_preparse(struct key_match_data *match_data)\r\n{\r\nstruct asymmetric_key_id *match_id;\r\nconst char *spec = match_data->raw_data;\r\nconst char *id;\r\nbool (*cmp)(const struct key *, const struct key_match_data *) =\r\nasymmetric_key_cmp;\r\nif (!spec || !*spec)\r\nreturn -EINVAL;\r\nif (spec[0] == 'i' &&\r\nspec[1] == 'd' &&\r\nspec[2] == ':') {\r\nid = spec + 3;\r\ncmp = asymmetric_key_cmp_partial;\r\n} else if (spec[0] == 'e' &&\r\nspec[1] == 'x' &&\r\nspec[2] == ':') {\r\nid = spec + 3;\r\n} else {\r\ngoto default_match;\r\n}\r\nmatch_id = asymmetric_key_hex_to_key_id(id);\r\nif (IS_ERR(match_id))\r\nreturn PTR_ERR(match_id);\r\nmatch_data->preparsed = match_id;\r\nmatch_data->cmp = cmp;\r\nmatch_data->lookup_type = KEYRING_SEARCH_LOOKUP_ITERATE;\r\nreturn 0;\r\ndefault_match:\r\nreturn 0;\r\n}\r\nstatic void asymmetric_key_match_free(struct key_match_data *match_data)\r\n{\r\nkfree(match_data->preparsed);\r\n}\r\nstatic void asymmetric_key_describe(const struct key *key, struct seq_file *m)\r\n{\r\nconst struct asymmetric_key_subtype *subtype = asymmetric_key_subtype(key);\r\nconst struct asymmetric_key_ids *kids = asymmetric_key_ids(key);\r\nconst struct asymmetric_key_id *kid;\r\nconst unsigned char *p;\r\nint n;\r\nseq_puts(m, key->description);\r\nif (subtype) {\r\nseq_puts(m, ": ");\r\nsubtype->describe(key, m);\r\nif (kids && kids->id[1]) {\r\nkid = kids->id[1];\r\nseq_putc(m, ' ');\r\nn = kid->len;\r\np = kid->data;\r\nif (n > 4) {\r\np += n - 4;\r\nn = 4;\r\n}\r\nseq_printf(m, "%*phN", n, p);\r\n}\r\nseq_puts(m, " [");\r\nseq_putc(m, ']');\r\n}\r\n}\r\nstatic int asymmetric_key_preparse(struct key_preparsed_payload *prep)\r\n{\r\nstruct asymmetric_key_parser *parser;\r\nint ret;\r\npr_devel("==>%s()\n", __func__);\r\nif (prep->datalen == 0)\r\nreturn -EINVAL;\r\ndown_read(&asymmetric_key_parsers_sem);\r\nret = -EBADMSG;\r\nlist_for_each_entry(parser, &asymmetric_key_parsers, link) {\r\npr_debug("Trying parser '%s'\n", parser->name);\r\nret = parser->parse(prep);\r\nif (ret != -EBADMSG) {\r\npr_debug("Parser recognised the format (ret %d)\n",\r\nret);\r\nbreak;\r\n}\r\n}\r\nup_read(&asymmetric_key_parsers_sem);\r\npr_devel("<==%s() = %d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nstatic void asymmetric_key_free_preparse(struct key_preparsed_payload *prep)\r\n{\r\nstruct asymmetric_key_subtype *subtype = prep->type_data[0];\r\nstruct asymmetric_key_ids *kids = prep->type_data[1];\r\nint i;\r\npr_devel("==>%s()\n", __func__);\r\nif (subtype) {\r\nsubtype->destroy(prep->payload[0]);\r\nmodule_put(subtype->owner);\r\n}\r\nif (kids) {\r\nfor (i = 0; i < ARRAY_SIZE(kids->id); i++)\r\nkfree(kids->id[i]);\r\nkfree(kids);\r\n}\r\nkfree(prep->description);\r\n}\r\nstatic void asymmetric_key_destroy(struct key *key)\r\n{\r\nstruct asymmetric_key_subtype *subtype = asymmetric_key_subtype(key);\r\nstruct asymmetric_key_ids *kids = key->type_data.p[1];\r\nif (subtype) {\r\nsubtype->destroy(key->payload.data);\r\nmodule_put(subtype->owner);\r\nkey->type_data.p[0] = NULL;\r\n}\r\nif (kids) {\r\nkfree(kids->id[0]);\r\nkfree(kids->id[1]);\r\nkfree(kids);\r\nkey->type_data.p[1] = NULL;\r\n}\r\n}\r\nint register_asymmetric_key_parser(struct asymmetric_key_parser *parser)\r\n{\r\nstruct asymmetric_key_parser *cursor;\r\nint ret;\r\ndown_write(&asymmetric_key_parsers_sem);\r\nlist_for_each_entry(cursor, &asymmetric_key_parsers, link) {\r\nif (strcmp(cursor->name, parser->name) == 0) {\r\npr_err("Asymmetric key parser '%s' already registered\n",\r\nparser->name);\r\nret = -EEXIST;\r\ngoto out;\r\n}\r\n}\r\nlist_add_tail(&parser->link, &asymmetric_key_parsers);\r\npr_notice("Asymmetric key parser '%s' registered\n", parser->name);\r\nret = 0;\r\nout:\r\nup_write(&asymmetric_key_parsers_sem);\r\nreturn ret;\r\n}\r\nvoid unregister_asymmetric_key_parser(struct asymmetric_key_parser *parser)\r\n{\r\ndown_write(&asymmetric_key_parsers_sem);\r\nlist_del(&parser->link);\r\nup_write(&asymmetric_key_parsers_sem);\r\npr_notice("Asymmetric key parser '%s' unregistered\n", parser->name);\r\n}\r\nstatic int __init asymmetric_key_init(void)\r\n{\r\nreturn register_key_type(&key_type_asymmetric);\r\n}\r\nstatic void __exit asymmetric_key_cleanup(void)\r\n{\r\nunregister_key_type(&key_type_asymmetric);\r\n}
