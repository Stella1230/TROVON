static int mcp3422_update_config(struct mcp3422 *adc, u8 newconfig)\r\n{\r\nint ret;\r\nmutex_lock(&adc->lock);\r\nret = i2c_master_send(adc->i2c, &newconfig, 1);\r\nif (ret > 0) {\r\nadc->config = newconfig;\r\nret = 0;\r\n}\r\nmutex_unlock(&adc->lock);\r\nreturn ret;\r\n}\r\nstatic int mcp3422_read(struct mcp3422 *adc, int *value, u8 *config)\r\n{\r\nint ret = 0;\r\nu8 sample_rate = MCP3422_SAMPLE_RATE(adc->config);\r\nu8 buf[4] = {0, 0, 0, 0};\r\nu32 temp;\r\nif (sample_rate == MCP3422_SRATE_3) {\r\nret = i2c_master_recv(adc->i2c, buf, 4);\r\ntemp = buf[0] << 16 | buf[1] << 8 | buf[2];\r\n*config = buf[3];\r\n} else {\r\nret = i2c_master_recv(adc->i2c, buf, 3);\r\ntemp = buf[0] << 8 | buf[1];\r\n*config = buf[2];\r\n}\r\n*value = sign_extend32(temp, mcp3422_sign_extend[sample_rate]);\r\nreturn ret;\r\n}\r\nstatic int mcp3422_read_channel(struct mcp3422 *adc,\r\nstruct iio_chan_spec const *channel, int *value)\r\n{\r\nint ret;\r\nu8 config;\r\nu8 req_channel = channel->channel;\r\nif (req_channel != MCP3422_CHANNEL(adc->config)) {\r\nconfig = adc->config;\r\nconfig &= ~MCP3422_CHANNEL_MASK;\r\nconfig |= MCP3422_CHANNEL_VALUE(req_channel);\r\nconfig &= ~MCP3422_PGA_MASK;\r\nconfig |= MCP3422_PGA_VALUE(adc->pga[req_channel]);\r\nret = mcp3422_update_config(adc, config);\r\nif (ret < 0)\r\nreturn ret;\r\nmsleep(mcp3422_read_times[MCP3422_SAMPLE_RATE(adc->config)]);\r\n}\r\nreturn mcp3422_read(adc, value, &config);\r\n}\r\nstatic int mcp3422_read_raw(struct iio_dev *iio,\r\nstruct iio_chan_spec const *channel, int *val1,\r\nint *val2, long mask)\r\n{\r\nstruct mcp3422 *adc = iio_priv(iio);\r\nint err;\r\nu8 sample_rate = MCP3422_SAMPLE_RATE(adc->config);\r\nu8 pga = MCP3422_PGA(adc->config);\r\nswitch (mask) {\r\ncase IIO_CHAN_INFO_RAW:\r\nerr = mcp3422_read_channel(adc, channel, val1);\r\nif (err < 0)\r\nreturn -EINVAL;\r\nreturn IIO_VAL_INT;\r\ncase IIO_CHAN_INFO_SCALE:\r\n*val1 = 0;\r\n*val2 = mcp3422_scales[sample_rate][pga];\r\nreturn IIO_VAL_INT_PLUS_NANO;\r\ncase IIO_CHAN_INFO_SAMP_FREQ:\r\n*val1 = mcp3422_sample_rates[MCP3422_SAMPLE_RATE(adc->config)];\r\nreturn IIO_VAL_INT;\r\ndefault:\r\nbreak;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int mcp3422_write_raw(struct iio_dev *iio,\r\nstruct iio_chan_spec const *channel, int val1,\r\nint val2, long mask)\r\n{\r\nstruct mcp3422 *adc = iio_priv(iio);\r\nu8 temp;\r\nu8 config = adc->config;\r\nu8 req_channel = channel->channel;\r\nu8 sample_rate = MCP3422_SAMPLE_RATE(config);\r\nu8 i;\r\nswitch (mask) {\r\ncase IIO_CHAN_INFO_SCALE:\r\nif (val1 != 0)\r\nreturn -EINVAL;\r\nfor (i = 0; i < ARRAY_SIZE(mcp3422_scales[0]); i++) {\r\nif (val2 == mcp3422_scales[sample_rate][i]) {\r\nadc->pga[req_channel] = i;\r\nconfig &= ~MCP3422_CHANNEL_MASK;\r\nconfig |= MCP3422_CHANNEL_VALUE(req_channel);\r\nconfig &= ~MCP3422_PGA_MASK;\r\nconfig |= MCP3422_PGA_VALUE(adc->pga[req_channel]);\r\nreturn mcp3422_update_config(adc, config);\r\n}\r\n}\r\nreturn -EINVAL;\r\ncase IIO_CHAN_INFO_SAMP_FREQ:\r\nswitch (val1) {\r\ncase 240:\r\ntemp = MCP3422_SRATE_240;\r\nbreak;\r\ncase 60:\r\ntemp = MCP3422_SRATE_60;\r\nbreak;\r\ncase 15:\r\ntemp = MCP3422_SRATE_15;\r\nbreak;\r\ncase 3:\r\nif (adc->id > 4)\r\nreturn -EINVAL;\r\ntemp = MCP3422_SRATE_3;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nconfig &= ~MCP3422_CHANNEL_MASK;\r\nconfig |= MCP3422_CHANNEL_VALUE(req_channel);\r\nconfig &= ~MCP3422_SRATE_MASK;\r\nconfig |= MCP3422_SAMPLE_RATE_VALUE(temp);\r\nreturn mcp3422_update_config(adc, config);\r\ndefault:\r\nbreak;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int mcp3422_write_raw_get_fmt(struct iio_dev *indio_dev,\r\nstruct iio_chan_spec const *chan, long mask)\r\n{\r\nswitch (mask) {\r\ncase IIO_CHAN_INFO_SCALE:\r\nreturn IIO_VAL_INT_PLUS_NANO;\r\ncase IIO_CHAN_INFO_SAMP_FREQ:\r\nreturn IIO_VAL_INT_PLUS_MICRO;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic ssize_t mcp3422_show_samp_freqs(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct mcp3422 *adc = iio_priv(dev_to_iio_dev(dev));\r\nif (adc->id > 4)\r\nreturn sprintf(buf, "240 60 15\n");\r\nreturn sprintf(buf, "240 60 15 3\n");\r\n}\r\nstatic ssize_t mcp3422_show_scales(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct mcp3422 *adc = iio_priv(dev_to_iio_dev(dev));\r\nu8 sample_rate = MCP3422_SAMPLE_RATE(adc->config);\r\nreturn sprintf(buf, "0.%09u 0.%09u 0.%09u 0.%09u\n",\r\nmcp3422_scales[sample_rate][0],\r\nmcp3422_scales[sample_rate][1],\r\nmcp3422_scales[sample_rate][2],\r\nmcp3422_scales[sample_rate][3]);\r\n}\r\nstatic int mcp3422_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct iio_dev *indio_dev;\r\nstruct mcp3422 *adc;\r\nint err;\r\nu8 config;\r\nif (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C))\r\nreturn -ENODEV;\r\nindio_dev = devm_iio_device_alloc(&client->dev, sizeof(*adc));\r\nif (!indio_dev)\r\nreturn -ENOMEM;\r\nadc = iio_priv(indio_dev);\r\nadc->i2c = client;\r\nadc->id = (u8)(id->driver_data);\r\nmutex_init(&adc->lock);\r\nindio_dev->dev.parent = &client->dev;\r\nindio_dev->name = dev_name(&client->dev);\r\nindio_dev->modes = INDIO_DIRECT_MODE;\r\nindio_dev->info = &mcp3422_info;\r\nswitch (adc->id) {\r\ncase 2:\r\ncase 3:\r\ncase 6:\r\ncase 7:\r\nindio_dev->channels = mcp3422_channels;\r\nindio_dev->num_channels = ARRAY_SIZE(mcp3422_channels);\r\nbreak;\r\ncase 4:\r\ncase 8:\r\nindio_dev->channels = mcp3424_channels;\r\nindio_dev->num_channels = ARRAY_SIZE(mcp3424_channels);\r\nbreak;\r\n}\r\nconfig = (MCP3422_CONT_SAMPLING\r\n| MCP3422_CHANNEL_VALUE(1)\r\n| MCP3422_PGA_VALUE(MCP3422_PGA_1)\r\n| MCP3422_SAMPLE_RATE_VALUE(MCP3422_SRATE_240));\r\nmcp3422_update_config(adc, config);\r\nerr = devm_iio_device_register(&client->dev, indio_dev);\r\nif (err < 0)\r\nreturn err;\r\ni2c_set_clientdata(client, indio_dev);\r\nreturn 0;\r\n}
