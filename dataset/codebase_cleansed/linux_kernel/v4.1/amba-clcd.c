static inline void clcdfb_sleep(unsigned int ms)\r\n{\r\nif (in_atomic()) {\r\nmdelay(ms);\r\n} else {\r\nmsleep(ms);\r\n}\r\n}\r\nstatic inline void clcdfb_set_start(struct clcd_fb *fb)\r\n{\r\nunsigned long ustart = fb->fb.fix.smem_start;\r\nunsigned long lstart;\r\nustart += fb->fb.var.yoffset * fb->fb.fix.line_length;\r\nlstart = ustart + fb->fb.var.yres * fb->fb.fix.line_length / 2;\r\nwritel(ustart, fb->regs + CLCD_UBAS);\r\nwritel(lstart, fb->regs + CLCD_LBAS);\r\n}\r\nstatic void clcdfb_disable(struct clcd_fb *fb)\r\n{\r\nu32 val;\r\nif (fb->board->disable)\r\nfb->board->disable(fb);\r\nval = readl(fb->regs + fb->off_cntl);\r\nif (val & CNTL_LCDPWR) {\r\nval &= ~CNTL_LCDPWR;\r\nwritel(val, fb->regs + fb->off_cntl);\r\nclcdfb_sleep(20);\r\n}\r\nif (val & CNTL_LCDEN) {\r\nval &= ~CNTL_LCDEN;\r\nwritel(val, fb->regs + fb->off_cntl);\r\n}\r\nif (fb->clk_enabled) {\r\nfb->clk_enabled = false;\r\nclk_disable(fb->clk);\r\n}\r\n}\r\nstatic void clcdfb_enable(struct clcd_fb *fb, u32 cntl)\r\n{\r\nif (!fb->clk_enabled) {\r\nfb->clk_enabled = true;\r\nclk_enable(fb->clk);\r\n}\r\ncntl |= CNTL_LCDEN;\r\nwritel(cntl, fb->regs + fb->off_cntl);\r\nclcdfb_sleep(20);\r\ncntl |= CNTL_LCDPWR;\r\nwritel(cntl, fb->regs + fb->off_cntl);\r\nif (fb->board->enable)\r\nfb->board->enable(fb);\r\n}\r\nstatic int\r\nclcdfb_set_bitfields(struct clcd_fb *fb, struct fb_var_screeninfo *var)\r\n{\r\nu32 caps;\r\nint ret = 0;\r\nif (fb->panel->caps && fb->board->caps)\r\ncaps = fb->panel->caps & fb->board->caps;\r\nelse {\r\ncaps = fb->panel->cntl & CNTL_BGR ?\r\nCLCD_CAP_BGR : CLCD_CAP_RGB;\r\ncaps &= ~CLCD_CAP_444;\r\n}\r\nif (!(fb->panel->cntl & CNTL_LCDTFT))\r\ncaps &= ~CLCD_CAP_888;\r\nmemset(&var->transp, 0, sizeof(var->transp));\r\nvar->red.msb_right = 0;\r\nvar->green.msb_right = 0;\r\nvar->blue.msb_right = 0;\r\nswitch (var->bits_per_pixel) {\r\ncase 1:\r\ncase 2:\r\ncase 4:\r\ncase 8:\r\ncaps &= CLCD_CAP_5551;\r\nif (!caps) {\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nvar->red.length = var->bits_per_pixel;\r\nvar->red.offset = 0;\r\nvar->green.length = var->bits_per_pixel;\r\nvar->green.offset = 0;\r\nvar->blue.length = var->bits_per_pixel;\r\nvar->blue.offset = 0;\r\nbreak;\r\ncase 16:\r\nif (!(caps & (CLCD_CAP_444 | CLCD_CAP_5551 | CLCD_CAP_565))) {\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nif (var->green.length == 4 && caps & CLCD_CAP_444)\r\ncaps &= CLCD_CAP_444;\r\nif (var->green.length == 5 && caps & CLCD_CAP_5551)\r\ncaps &= CLCD_CAP_5551;\r\nelse if (var->green.length == 6 && caps & CLCD_CAP_565)\r\ncaps &= CLCD_CAP_565;\r\nelse {\r\nif (caps & CLCD_CAP_565) {\r\nvar->green.length = 6;\r\ncaps &= CLCD_CAP_565;\r\n} else if (caps & CLCD_CAP_5551) {\r\nvar->green.length = 5;\r\ncaps &= CLCD_CAP_5551;\r\n} else {\r\nvar->green.length = 4;\r\ncaps &= CLCD_CAP_444;\r\n}\r\n}\r\nif (var->green.length >= 5) {\r\nvar->red.length = 5;\r\nvar->blue.length = 5;\r\n} else {\r\nvar->red.length = 4;\r\nvar->blue.length = 4;\r\n}\r\nbreak;\r\ncase 32:\r\ncaps &= CLCD_CAP_888;\r\nif (!caps) {\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nvar->red.length = 8;\r\nvar->green.length = 8;\r\nvar->blue.length = 8;\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nif (ret == 0 && var->bits_per_pixel >= 16) {\r\nbool bgr, rgb;\r\nbgr = caps & CLCD_CAP_BGR && var->blue.offset == 0;\r\nrgb = caps & CLCD_CAP_RGB && var->red.offset == 0;\r\nif (!bgr && !rgb)\r\nbgr = caps & CLCD_CAP_BGR;\r\nif (bgr) {\r\nvar->blue.offset = 0;\r\nvar->green.offset = var->blue.offset + var->blue.length;\r\nvar->red.offset = var->green.offset + var->green.length;\r\n} else {\r\nvar->red.offset = 0;\r\nvar->green.offset = var->red.offset + var->red.length;\r\nvar->blue.offset = var->green.offset + var->green.length;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic int clcdfb_check_var(struct fb_var_screeninfo *var, struct fb_info *info)\r\n{\r\nstruct clcd_fb *fb = to_clcd(info);\r\nint ret = -EINVAL;\r\nif (fb->board->check)\r\nret = fb->board->check(fb, var);\r\nif (ret == 0 &&\r\nvar->xres_virtual * var->bits_per_pixel / 8 *\r\nvar->yres_virtual > fb->fb.fix.smem_len)\r\nret = -EINVAL;\r\nif (ret == 0)\r\nret = clcdfb_set_bitfields(fb, var);\r\nreturn ret;\r\n}\r\nstatic int clcdfb_set_par(struct fb_info *info)\r\n{\r\nstruct clcd_fb *fb = to_clcd(info);\r\nstruct clcd_regs regs;\r\nfb->fb.fix.line_length = fb->fb.var.xres_virtual *\r\nfb->fb.var.bits_per_pixel / 8;\r\nif (fb->fb.var.bits_per_pixel <= 8)\r\nfb->fb.fix.visual = FB_VISUAL_PSEUDOCOLOR;\r\nelse\r\nfb->fb.fix.visual = FB_VISUAL_TRUECOLOR;\r\nfb->board->decode(fb, &regs);\r\nclcdfb_disable(fb);\r\nwritel(regs.tim0, fb->regs + CLCD_TIM0);\r\nwritel(regs.tim1, fb->regs + CLCD_TIM1);\r\nwritel(regs.tim2, fb->regs + CLCD_TIM2);\r\nwritel(regs.tim3, fb->regs + CLCD_TIM3);\r\nclcdfb_set_start(fb);\r\nclk_set_rate(fb->clk, (1000000000 / regs.pixclock) * 1000);\r\nfb->clcd_cntl = regs.cntl;\r\nclcdfb_enable(fb, regs.cntl);\r\n#ifdef DEBUG\r\nprintk(KERN_INFO\r\n"CLCD: Registers set to\n"\r\n" %08x %08x %08x %08x\n"\r\n" %08x %08x %08x %08x\n",\r\nreadl(fb->regs + CLCD_TIM0), readl(fb->regs + CLCD_TIM1),\r\nreadl(fb->regs + CLCD_TIM2), readl(fb->regs + CLCD_TIM3),\r\nreadl(fb->regs + CLCD_UBAS), readl(fb->regs + CLCD_LBAS),\r\nreadl(fb->regs + fb->off_ienb), readl(fb->regs + fb->off_cntl));\r\n#endif\r\nreturn 0;\r\n}\r\nstatic inline u32 convert_bitfield(int val, struct fb_bitfield *bf)\r\n{\r\nunsigned int mask = (1 << bf->length) - 1;\r\nreturn (val >> (16 - bf->length) & mask) << bf->offset;\r\n}\r\nstatic int\r\nclcdfb_setcolreg(unsigned int regno, unsigned int red, unsigned int green,\r\nunsigned int blue, unsigned int transp, struct fb_info *info)\r\n{\r\nstruct clcd_fb *fb = to_clcd(info);\r\nif (regno < 16)\r\nfb->cmap[regno] = convert_bitfield(transp, &fb->fb.var.transp) |\r\nconvert_bitfield(blue, &fb->fb.var.blue) |\r\nconvert_bitfield(green, &fb->fb.var.green) |\r\nconvert_bitfield(red, &fb->fb.var.red);\r\nif (fb->fb.fix.visual == FB_VISUAL_PSEUDOCOLOR && regno < 256) {\r\nint hw_reg = CLCD_PALETTE + ((regno * 2) & ~3);\r\nu32 val, mask, newval;\r\nnewval = (red >> 11) & 0x001f;\r\nnewval |= (green >> 6) & 0x03e0;\r\nnewval |= (blue >> 1) & 0x7c00;\r\nif (fb->clcd_cntl & CNTL_BEBO)\r\nregno ^= 1;\r\nif (regno & 1) {\r\nnewval <<= 16;\r\nmask = 0x0000ffff;\r\n} else {\r\nmask = 0xffff0000;\r\n}\r\nval = readl(fb->regs + hw_reg) & mask;\r\nwritel(val | newval, fb->regs + hw_reg);\r\n}\r\nreturn regno > 255;\r\n}\r\nstatic int clcdfb_blank(int blank_mode, struct fb_info *info)\r\n{\r\nstruct clcd_fb *fb = to_clcd(info);\r\nif (blank_mode != 0) {\r\nclcdfb_disable(fb);\r\n} else {\r\nclcdfb_enable(fb, fb->clcd_cntl);\r\n}\r\nreturn 0;\r\n}\r\nstatic int clcdfb_mmap(struct fb_info *info,\r\nstruct vm_area_struct *vma)\r\n{\r\nstruct clcd_fb *fb = to_clcd(info);\r\nunsigned long len, off = vma->vm_pgoff << PAGE_SHIFT;\r\nint ret = -EINVAL;\r\nlen = info->fix.smem_len;\r\nif (off <= len && vma->vm_end - vma->vm_start <= len - off &&\r\nfb->board->mmap)\r\nret = fb->board->mmap(fb, vma);\r\nreturn ret;\r\n}\r\nstatic int clcdfb_register(struct clcd_fb *fb)\r\n{\r\nint ret;\r\nif (amba_manf(fb->dev) == 0x41 && amba_part(fb->dev) == 0x111) {\r\nfb->off_ienb = CLCD_PL111_IENB;\r\nfb->off_cntl = CLCD_PL111_CNTL;\r\n} else {\r\n#ifdef CONFIG_ARCH_VERSATILE\r\nfb->off_ienb = CLCD_PL111_IENB;\r\nfb->off_cntl = CLCD_PL111_CNTL;\r\n#else\r\nfb->off_ienb = CLCD_PL110_IENB;\r\nfb->off_cntl = CLCD_PL110_CNTL;\r\n#endif\r\n}\r\nfb->clk = clk_get(&fb->dev->dev, NULL);\r\nif (IS_ERR(fb->clk)) {\r\nret = PTR_ERR(fb->clk);\r\ngoto out;\r\n}\r\nret = clk_prepare(fb->clk);\r\nif (ret)\r\ngoto free_clk;\r\nfb->fb.device = &fb->dev->dev;\r\nfb->fb.fix.mmio_start = fb->dev->res.start;\r\nfb->fb.fix.mmio_len = resource_size(&fb->dev->res);\r\nfb->regs = ioremap(fb->fb.fix.mmio_start, fb->fb.fix.mmio_len);\r\nif (!fb->regs) {\r\nprintk(KERN_ERR "CLCD: unable to remap registers\n");\r\nret = -ENOMEM;\r\ngoto clk_unprep;\r\n}\r\nfb->fb.fbops = &clcdfb_ops;\r\nfb->fb.flags = FBINFO_FLAG_DEFAULT;\r\nfb->fb.pseudo_palette = fb->cmap;\r\nstrncpy(fb->fb.fix.id, clcd_name, sizeof(fb->fb.fix.id));\r\nfb->fb.fix.type = FB_TYPE_PACKED_PIXELS;\r\nfb->fb.fix.type_aux = 0;\r\nfb->fb.fix.xpanstep = 0;\r\nfb->fb.fix.ypanstep = 0;\r\nfb->fb.fix.ywrapstep = 0;\r\nfb->fb.fix.accel = FB_ACCEL_NONE;\r\nfb->fb.var.xres = fb->panel->mode.xres;\r\nfb->fb.var.yres = fb->panel->mode.yres;\r\nfb->fb.var.xres_virtual = fb->panel->mode.xres;\r\nfb->fb.var.yres_virtual = fb->panel->mode.yres;\r\nfb->fb.var.bits_per_pixel = fb->panel->bpp;\r\nfb->fb.var.grayscale = fb->panel->grayscale;\r\nfb->fb.var.pixclock = fb->panel->mode.pixclock;\r\nfb->fb.var.left_margin = fb->panel->mode.left_margin;\r\nfb->fb.var.right_margin = fb->panel->mode.right_margin;\r\nfb->fb.var.upper_margin = fb->panel->mode.upper_margin;\r\nfb->fb.var.lower_margin = fb->panel->mode.lower_margin;\r\nfb->fb.var.hsync_len = fb->panel->mode.hsync_len;\r\nfb->fb.var.vsync_len = fb->panel->mode.vsync_len;\r\nfb->fb.var.sync = fb->panel->mode.sync;\r\nfb->fb.var.vmode = fb->panel->mode.vmode;\r\nfb->fb.var.activate = FB_ACTIVATE_NOW;\r\nfb->fb.var.nonstd = 0;\r\nfb->fb.var.height = fb->panel->height;\r\nfb->fb.var.width = fb->panel->width;\r\nfb->fb.var.accel_flags = 0;\r\nfb->fb.monspecs.hfmin = 0;\r\nfb->fb.monspecs.hfmax = 100000;\r\nfb->fb.monspecs.vfmin = 0;\r\nfb->fb.monspecs.vfmax = 400;\r\nfb->fb.monspecs.dclkmin = 1000000;\r\nfb->fb.monspecs.dclkmax = 100000000;\r\nclcdfb_set_bitfields(fb, &fb->fb.var);\r\nret = fb_alloc_cmap(&fb->fb.cmap, 256, 0);\r\nif (ret)\r\ngoto unmap;\r\nwritel(0, fb->regs + fb->off_ienb);\r\nfb_set_var(&fb->fb, &fb->fb.var);\r\ndev_info(&fb->dev->dev, "%s hardware, %s display\n",\r\nfb->board->name, fb->panel->mode.name);\r\nret = register_framebuffer(&fb->fb);\r\nif (ret == 0)\r\ngoto out;\r\nprintk(KERN_ERR "CLCD: cannot register framebuffer (%d)\n", ret);\r\nfb_dealloc_cmap(&fb->fb.cmap);\r\nunmap:\r\niounmap(fb->regs);\r\nclk_unprep:\r\nclk_unprepare(fb->clk);\r\nfree_clk:\r\nclk_put(fb->clk);\r\nout:\r\nreturn ret;\r\n}\r\nstatic int clcdfb_of_get_dpi_panel_mode(struct device_node *node,\r\nstruct fb_videomode *mode)\r\n{\r\nint err;\r\nstruct display_timing timing;\r\nstruct videomode video;\r\nerr = of_get_display_timing(node, "panel-timing", &timing);\r\nif (err)\r\nreturn err;\r\nvideomode_from_timing(&timing, &video);\r\nerr = fb_videomode_from_videomode(&video, mode);\r\nif (err)\r\nreturn err;\r\nreturn 0;\r\n}\r\nstatic int clcdfb_snprintf_mode(char *buf, int size, struct fb_videomode *mode)\r\n{\r\nreturn snprintf(buf, size, "%ux%u@%u", mode->xres, mode->yres,\r\nmode->refresh);\r\n}\r\nstatic int clcdfb_of_get_mode(struct device *dev, struct device_node *endpoint,\r\nstruct fb_videomode *mode)\r\n{\r\nint err;\r\nstruct device_node *panel;\r\nchar *name;\r\nint len;\r\npanel = of_graph_get_remote_port_parent(endpoint);\r\nif (!panel)\r\nreturn -ENODEV;\r\nif (of_device_is_compatible(panel, "panel-dpi"))\r\nerr = clcdfb_of_get_dpi_panel_mode(panel, mode);\r\nelse\r\nerr = -ENOENT;\r\nif (err)\r\nreturn err;\r\nlen = clcdfb_snprintf_mode(NULL, 0, mode);\r\nname = devm_kzalloc(dev, len + 1, GFP_KERNEL);\r\nif (!name)\r\nreturn -ENOMEM;\r\nclcdfb_snprintf_mode(name, len + 1, mode);\r\nmode->name = name;\r\nreturn 0;\r\n}\r\nstatic int clcdfb_of_init_tft_panel(struct clcd_fb *fb, u32 r0, u32 g0, u32 b0)\r\n{\r\nstatic struct {\r\nunsigned int part;\r\nu32 r0, g0, b0;\r\nu32 caps;\r\n} panels[] = {\r\n{ 0x110, 1, 7, 13, CLCD_CAP_5551 },\r\n{ 0x110, 0, 8, 16, CLCD_CAP_888 },\r\n{ 0x111, 4, 14, 20, CLCD_CAP_444 },\r\n{ 0x111, 3, 11, 19, CLCD_CAP_444 | CLCD_CAP_5551 },\r\n{ 0x111, 3, 10, 19, CLCD_CAP_444 | CLCD_CAP_5551 |\r\nCLCD_CAP_565 },\r\n{ 0x111, 0, 8, 16, CLCD_CAP_444 | CLCD_CAP_5551 |\r\nCLCD_CAP_565 | CLCD_CAP_888 },\r\n};\r\nint i;\r\nfb->panel->tim2 = TIM2_BCD | TIM2_IPC;\r\nfb->panel->cntl |= CNTL_LCDTFT | CNTL_LCDVCOMP(1);\r\nfb->panel->caps = 0;\r\nfor (i = 0; i < ARRAY_SIZE(panels) && !fb->panel->caps; i++) {\r\nif (amba_part(fb->dev) != panels[i].part)\r\ncontinue;\r\nif (g0 != panels[i].g0)\r\ncontinue;\r\nif (r0 == panels[i].r0 && b0 == panels[i].b0)\r\nfb->panel->caps = panels[i].caps;\r\n}\r\nreturn fb->panel->caps ? 0 : -EINVAL;\r\n}\r\nstatic int clcdfb_of_init_display(struct clcd_fb *fb)\r\n{\r\nstruct device_node *endpoint;\r\nint err;\r\nunsigned int bpp;\r\nu32 max_bandwidth;\r\nu32 tft_r0b0g0[3];\r\nfb->panel = devm_kzalloc(&fb->dev->dev, sizeof(*fb->panel), GFP_KERNEL);\r\nif (!fb->panel)\r\nreturn -ENOMEM;\r\nendpoint = of_graph_get_next_endpoint(fb->dev->dev.of_node, NULL);\r\nif (!endpoint)\r\nreturn -ENODEV;\r\nerr = clcdfb_of_get_mode(&fb->dev->dev, endpoint, &fb->panel->mode);\r\nif (err)\r\nreturn err;\r\nerr = of_property_read_u32(fb->dev->dev.of_node, "max-memory-bandwidth",\r\n&max_bandwidth);\r\nif (!err) {\r\nbpp = max_bandwidth / (1000 / 8)\r\n/ PICOS2KHZ(fb->panel->mode.pixclock);\r\nbpp = rounddown_pow_of_two(bpp);\r\nif (bpp > 32)\r\nbpp = 32;\r\n} else\r\nbpp = 32;\r\nfb->panel->bpp = bpp;\r\n#ifdef CONFIG_CPU_BIG_ENDIAN\r\nfb->panel->cntl |= CNTL_BEBO;\r\n#endif\r\nfb->panel->width = -1;\r\nfb->panel->height = -1;\r\nif (of_property_read_u32_array(endpoint,\r\n"arm,pl11x,tft-r0g0b0-pads",\r\ntft_r0b0g0, ARRAY_SIZE(tft_r0b0g0)) == 0)\r\nreturn clcdfb_of_init_tft_panel(fb, tft_r0b0g0[0],\r\ntft_r0b0g0[1], tft_r0b0g0[2]);\r\nreturn -ENOENT;\r\n}\r\nstatic int clcdfb_of_vram_setup(struct clcd_fb *fb)\r\n{\r\nint err;\r\nstruct device_node *memory;\r\nu64 size;\r\nerr = clcdfb_of_init_display(fb);\r\nif (err)\r\nreturn err;\r\nmemory = of_parse_phandle(fb->dev->dev.of_node, "memory-region", 0);\r\nif (!memory)\r\nreturn -ENODEV;\r\nfb->fb.screen_base = of_iomap(memory, 0);\r\nif (!fb->fb.screen_base)\r\nreturn -ENOMEM;\r\nfb->fb.fix.smem_start = of_translate_address(memory,\r\nof_get_address(memory, 0, &size, NULL));\r\nfb->fb.fix.smem_len = size;\r\nreturn 0;\r\n}\r\nstatic int clcdfb_of_vram_mmap(struct clcd_fb *fb, struct vm_area_struct *vma)\r\n{\r\nunsigned long off, user_size, kernel_size;\r\noff = vma->vm_pgoff << PAGE_SHIFT;\r\nuser_size = vma->vm_end - vma->vm_start;\r\nkernel_size = fb->fb.fix.smem_len;\r\nif (off >= kernel_size || user_size > (kernel_size - off))\r\nreturn -ENXIO;\r\nreturn remap_pfn_range(vma, vma->vm_start,\r\n__phys_to_pfn(fb->fb.fix.smem_start) + vma->vm_pgoff,\r\nuser_size,\r\npgprot_writecombine(vma->vm_page_prot));\r\n}\r\nstatic void clcdfb_of_vram_remove(struct clcd_fb *fb)\r\n{\r\niounmap(fb->fb.screen_base);\r\n}\r\nstatic int clcdfb_of_dma_setup(struct clcd_fb *fb)\r\n{\r\nunsigned long framesize;\r\ndma_addr_t dma;\r\nint err;\r\nerr = clcdfb_of_init_display(fb);\r\nif (err)\r\nreturn err;\r\nframesize = fb->panel->mode.xres * fb->panel->mode.yres *\r\nfb->panel->bpp / 8;\r\nfb->fb.screen_base = dma_alloc_coherent(&fb->dev->dev, framesize,\r\n&dma, GFP_KERNEL);\r\nif (!fb->fb.screen_base)\r\nreturn -ENOMEM;\r\nfb->fb.fix.smem_start = dma;\r\nfb->fb.fix.smem_len = framesize;\r\nreturn 0;\r\n}\r\nstatic int clcdfb_of_dma_mmap(struct clcd_fb *fb, struct vm_area_struct *vma)\r\n{\r\nreturn dma_mmap_writecombine(&fb->dev->dev, vma, fb->fb.screen_base,\r\nfb->fb.fix.smem_start, fb->fb.fix.smem_len);\r\n}\r\nstatic void clcdfb_of_dma_remove(struct clcd_fb *fb)\r\n{\r\ndma_free_coherent(&fb->dev->dev, fb->fb.fix.smem_len,\r\nfb->fb.screen_base, fb->fb.fix.smem_start);\r\n}\r\nstatic struct clcd_board *clcdfb_of_get_board(struct amba_device *dev)\r\n{\r\nstruct clcd_board *board = devm_kzalloc(&dev->dev, sizeof(*board),\r\nGFP_KERNEL);\r\nstruct device_node *node = dev->dev.of_node;\r\nif (!board)\r\nreturn NULL;\r\nboard->name = of_node_full_name(node);\r\nboard->caps = CLCD_CAP_ALL;\r\nboard->check = clcdfb_check;\r\nboard->decode = clcdfb_decode;\r\nif (of_find_property(node, "memory-region", NULL)) {\r\nboard->setup = clcdfb_of_vram_setup;\r\nboard->mmap = clcdfb_of_vram_mmap;\r\nboard->remove = clcdfb_of_vram_remove;\r\n} else {\r\nboard->setup = clcdfb_of_dma_setup;\r\nboard->mmap = clcdfb_of_dma_mmap;\r\nboard->remove = clcdfb_of_dma_remove;\r\n}\r\nreturn board;\r\n}\r\nstatic struct clcd_board *clcdfb_of_get_board(struct amba_device *dev)\r\n{\r\nreturn NULL;\r\n}\r\nstatic int clcdfb_probe(struct amba_device *dev, const struct amba_id *id)\r\n{\r\nstruct clcd_board *board = dev_get_platdata(&dev->dev);\r\nstruct clcd_fb *fb;\r\nint ret;\r\nif (!board)\r\nboard = clcdfb_of_get_board(dev);\r\nif (!board)\r\nreturn -EINVAL;\r\nret = dma_set_mask_and_coherent(&dev->dev, DMA_BIT_MASK(32));\r\nif (ret)\r\ngoto out;\r\nret = amba_request_regions(dev, NULL);\r\nif (ret) {\r\nprintk(KERN_ERR "CLCD: unable to reserve regs region\n");\r\ngoto out;\r\n}\r\nfb = kzalloc(sizeof(struct clcd_fb), GFP_KERNEL);\r\nif (!fb) {\r\nprintk(KERN_INFO "CLCD: could not allocate new clcd_fb struct\n");\r\nret = -ENOMEM;\r\ngoto free_region;\r\n}\r\nfb->dev = dev;\r\nfb->board = board;\r\ndev_info(&fb->dev->dev, "PL%03x rev%u at 0x%08llx\n",\r\namba_part(dev), amba_rev(dev),\r\n(unsigned long long)dev->res.start);\r\nret = fb->board->setup(fb);\r\nif (ret)\r\ngoto free_fb;\r\nret = clcdfb_register(fb);\r\nif (ret == 0) {\r\namba_set_drvdata(dev, fb);\r\ngoto out;\r\n}\r\nfb->board->remove(fb);\r\nfree_fb:\r\nkfree(fb);\r\nfree_region:\r\namba_release_regions(dev);\r\nout:\r\nreturn ret;\r\n}\r\nstatic int clcdfb_remove(struct amba_device *dev)\r\n{\r\nstruct clcd_fb *fb = amba_get_drvdata(dev);\r\nclcdfb_disable(fb);\r\nunregister_framebuffer(&fb->fb);\r\nif (fb->fb.cmap.len)\r\nfb_dealloc_cmap(&fb->fb.cmap);\r\niounmap(fb->regs);\r\nclk_unprepare(fb->clk);\r\nclk_put(fb->clk);\r\nfb->board->remove(fb);\r\nkfree(fb);\r\namba_release_regions(dev);\r\nreturn 0;\r\n}\r\nstatic int __init amba_clcdfb_init(void)\r\n{\r\nif (fb_get_options("ambafb", NULL))\r\nreturn -ENODEV;\r\nreturn amba_driver_register(&clcd_driver);\r\n}\r\nstatic void __exit amba_clcdfb_exit(void)\r\n{\r\namba_driver_unregister(&clcd_driver);\r\n}
