static int cmux_set_parent(struct clk_hw *hw, u8 idx)\r\n{\r\nstruct cmux_clk *clk = to_cmux_clk(hw);\r\nu32 clksel;\r\nclksel = ((idx / clk->clk_per_pll) << 2) + idx % clk->clk_per_pll;\r\nif (clk->flags & CLKSEL_ADJUST)\r\nclksel += 8;\r\nclksel = (clksel & 0xf) << CLKSEL_SHIFT;\r\niowrite32be(clksel, clk->reg);\r\nreturn 0;\r\n}\r\nstatic u8 cmux_get_parent(struct clk_hw *hw)\r\n{\r\nstruct cmux_clk *clk = to_cmux_clk(hw);\r\nu32 clksel;\r\nclksel = ioread32be(clk->reg);\r\nclksel = (clksel >> CLKSEL_SHIFT) & 0xf;\r\nif (clk->flags & CLKSEL_ADJUST)\r\nclksel -= 8;\r\nclksel = (clksel >> 2) * clk->clk_per_pll + clksel % 4;\r\nreturn clksel;\r\n}\r\nstatic void __init core_mux_init(struct device_node *np)\r\n{\r\nstruct clk *clk;\r\nstruct clk_init_data init;\r\nstruct cmux_clk *cmux_clk;\r\nstruct device_node *node;\r\nint rc, count, i;\r\nu32 offset;\r\nconst char *clk_name;\r\nconst char **parent_names;\r\nstruct of_phandle_args clkspec;\r\nrc = of_property_read_u32(np, "reg", &offset);\r\nif (rc) {\r\npr_err("%s: could not get reg property\n", np->name);\r\nreturn;\r\n}\r\ncount = of_property_count_strings(np, "clock-names");\r\nif (count < 0) {\r\npr_err("%s: get clock count error\n", np->name);\r\nreturn;\r\n}\r\nparent_names = kcalloc(count, sizeof(char *), GFP_KERNEL);\r\nif (!parent_names)\r\nreturn;\r\nfor (i = 0; i < count; i++)\r\nparent_names[i] = of_clk_get_parent_name(np, i);\r\ncmux_clk = kzalloc(sizeof(*cmux_clk), GFP_KERNEL);\r\nif (!cmux_clk)\r\ngoto err_name;\r\ncmux_clk->reg = of_iomap(np, 0);\r\nif (!cmux_clk->reg) {\r\npr_err("%s: could not map register\n", __func__);\r\ngoto err_clk;\r\n}\r\nrc = of_parse_phandle_with_args(np, "clocks", "#clock-cells", 0,\r\n&clkspec);\r\nif (rc) {\r\npr_err("%s: parse clock node error\n", __func__);\r\ngoto err_clk;\r\n}\r\ncmux_clk->clk_per_pll = of_property_count_strings(clkspec.np,\r\n"clock-output-names");\r\nof_node_put(clkspec.np);\r\nnode = of_find_compatible_node(NULL, NULL, "fsl,p4080-clockgen");\r\nif (node && (offset >= 0x80))\r\ncmux_clk->flags = CLKSEL_ADJUST;\r\nrc = of_property_read_string_index(np, "clock-output-names",\r\n0, &clk_name);\r\nif (rc) {\r\npr_err("%s: read clock names error\n", np->name);\r\ngoto err_clk;\r\n}\r\ninit.name = clk_name;\r\ninit.ops = &cmux_ops;\r\ninit.parent_names = parent_names;\r\ninit.num_parents = count;\r\ninit.flags = 0;\r\ncmux_clk->hw.init = &init;\r\nclk = clk_register(NULL, &cmux_clk->hw);\r\nif (IS_ERR(clk)) {\r\npr_err("%s: could not register clock\n", clk_name);\r\ngoto err_clk;\r\n}\r\nrc = of_clk_add_provider(np, of_clk_src_simple_get, clk);\r\nif (rc) {\r\npr_err("Could not register clock provider for node:%s\n",\r\nnp->name);\r\ngoto err_clk;\r\n}\r\ngoto err_name;\r\nerr_clk:\r\nkfree(cmux_clk);\r\nerr_name:\r\nkfree(parent_names);\r\n}\r\nstatic void __init core_pll_init(struct device_node *np)\r\n{\r\nu32 mult;\r\nint i, rc, count;\r\nconst char *clk_name, *parent_name;\r\nstruct clk_onecell_data *onecell_data;\r\nstruct clk **subclks;\r\nvoid __iomem *base;\r\nbase = of_iomap(np, 0);\r\nif (!base) {\r\npr_err("iomap error\n");\r\nreturn;\r\n}\r\nmult = ioread32be(base);\r\nif (mult & PLL_KILL) {\r\npr_debug("PLL:%s is disabled\n", np->name);\r\ngoto err_map;\r\n}\r\nmult = (mult >> 1) & 0x3f;\r\nparent_name = of_clk_get_parent_name(np, 0);\r\nif (!parent_name) {\r\npr_err("PLL: %s must have a parent\n", np->name);\r\ngoto err_map;\r\n}\r\ncount = of_property_count_strings(np, "clock-output-names");\r\nif (count < 0 || count > 4) {\r\npr_err("%s: clock is not supported\n", np->name);\r\ngoto err_map;\r\n}\r\nsubclks = kcalloc(count, sizeof(struct clk *), GFP_KERNEL);\r\nif (!subclks)\r\ngoto err_map;\r\nonecell_data = kmalloc(sizeof(*onecell_data), GFP_KERNEL);\r\nif (!onecell_data)\r\ngoto err_clks;\r\nfor (i = 0; i < count; i++) {\r\nrc = of_property_read_string_index(np, "clock-output-names",\r\ni, &clk_name);\r\nif (rc) {\r\npr_err("%s: could not get clock names\n", np->name);\r\ngoto err_cell;\r\n}\r\nif (count == 4)\r\nsubclks[i] = clk_register_fixed_factor(NULL, clk_name,\r\nparent_name, 0, mult, 1 + i);\r\nelse\r\nsubclks[i] = clk_register_fixed_factor(NULL, clk_name,\r\nparent_name, 0, mult, 1 << i);\r\nif (IS_ERR(subclks[i])) {\r\npr_err("%s: could not register clock\n", clk_name);\r\ngoto err_cell;\r\n}\r\n}\r\nonecell_data->clks = subclks;\r\nonecell_data->clk_num = count;\r\nrc = of_clk_add_provider(np, of_clk_src_onecell_get, onecell_data);\r\nif (rc) {\r\npr_err("Could not register clk provider for node:%s\n",\r\nnp->name);\r\ngoto err_cell;\r\n}\r\niounmap(base);\r\nreturn;\r\nerr_cell:\r\nkfree(onecell_data);\r\nerr_clks:\r\nkfree(subclks);\r\nerr_map:\r\niounmap(base);\r\n}\r\nstatic void __init sysclk_init(struct device_node *node)\r\n{\r\nstruct clk *clk;\r\nconst char *clk_name = node->name;\r\nstruct device_node *np = of_get_parent(node);\r\nu32 rate;\r\nif (!np) {\r\npr_err("could not get parent node\n");\r\nreturn;\r\n}\r\nif (of_property_read_u32(np, "clock-frequency", &rate)) {\r\nof_node_put(node);\r\nreturn;\r\n}\r\nof_property_read_string(np, "clock-output-names", &clk_name);\r\nclk = clk_register_fixed_rate(NULL, clk_name, NULL, CLK_IS_ROOT, rate);\r\nif (!IS_ERR(clk))\r\nof_clk_add_provider(np, of_clk_src_simple_get, clk);\r\n}\r\nstatic void __init pltfrm_pll_init(struct device_node *np)\r\n{\r\nvoid __iomem *base;\r\nuint32_t mult;\r\nconst char *parent_name, *clk_name;\r\nint i, _errno;\r\nstruct clk_onecell_data *cod;\r\nbase = of_iomap(np, 0);\r\nif (!base) {\r\npr_err("%s(): %s: of_iomap() failed\n", __func__, np->name);\r\nreturn;\r\n}\r\nmult = ioread32be(base);\r\niounmap(base);\r\nif (mult & PLL_KILL) {\r\npr_debug("%s(): %s: Disabled\n", __func__, np->name);\r\nreturn;\r\n}\r\nmult = (mult & GENMASK(6, 1)) >> 1;\r\nparent_name = of_clk_get_parent_name(np, 0);\r\nif (!parent_name) {\r\npr_err("%s(): %s: of_clk_get_parent_name() failed\n",\r\n__func__, np->name);\r\nreturn;\r\n}\r\ni = of_property_count_strings(np, "clock-output-names");\r\nif (i < 0) {\r\npr_err("%s(): %s: of_property_count_strings(clock-output-names) = %d\n",\r\n__func__, np->name, i);\r\nreturn;\r\n}\r\ncod = kmalloc(sizeof(*cod) + i * sizeof(struct clk *), GFP_KERNEL);\r\nif (!cod)\r\nreturn;\r\ncod->clks = (struct clk **)(cod + 1);\r\ncod->clk_num = i;\r\nfor (i = 0; i < cod->clk_num; i++) {\r\n_errno = of_property_read_string_index(np, "clock-output-names",\r\ni, &clk_name);\r\nif (_errno < 0) {\r\npr_err("%s(): %s: of_property_read_string_index(clock-output-names) = %d\n",\r\n__func__, np->name, _errno);\r\ngoto return_clk_unregister;\r\n}\r\ncod->clks[i] = clk_register_fixed_factor(NULL, clk_name,\r\nparent_name, 0, mult, 1 + i);\r\nif (IS_ERR(cod->clks[i])) {\r\npr_err("%s(): %s: clk_register_fixed_factor(%s) = %ld\n",\r\n__func__, np->name,\r\nclk_name, PTR_ERR(cod->clks[i]));\r\ngoto return_clk_unregister;\r\n}\r\n}\r\n_errno = of_clk_add_provider(np, of_clk_src_onecell_get, cod);\r\nif (_errno < 0) {\r\npr_err("%s(): %s: of_clk_add_provider() = %d\n",\r\n__func__, np->name, _errno);\r\ngoto return_clk_unregister;\r\n}\r\nreturn;\r\nreturn_clk_unregister:\r\nwhile (--i >= 0)\r\nclk_unregister(cod->clks[i]);\r\nkfree(cod);\r\n}
