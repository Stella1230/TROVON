static bool wm8993_volatile(struct device *dev, unsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase WM8993_SOFTWARE_RESET:\r\ncase WM8993_GPIO_CTRL_1:\r\ncase WM8993_DC_SERVO_0:\r\ncase WM8993_DC_SERVO_READBACK_0:\r\ncase WM8993_DC_SERVO_READBACK_1:\r\ncase WM8993_DC_SERVO_READBACK_2:\r\nreturn true;\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nstatic bool wm8993_readable(struct device *dev, unsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase WM8993_SOFTWARE_RESET:\r\ncase WM8993_POWER_MANAGEMENT_1:\r\ncase WM8993_POWER_MANAGEMENT_2:\r\ncase WM8993_POWER_MANAGEMENT_3:\r\ncase WM8993_AUDIO_INTERFACE_1:\r\ncase WM8993_AUDIO_INTERFACE_2:\r\ncase WM8993_CLOCKING_1:\r\ncase WM8993_CLOCKING_2:\r\ncase WM8993_AUDIO_INTERFACE_3:\r\ncase WM8993_AUDIO_INTERFACE_4:\r\ncase WM8993_DAC_CTRL:\r\ncase WM8993_LEFT_DAC_DIGITAL_VOLUME:\r\ncase WM8993_RIGHT_DAC_DIGITAL_VOLUME:\r\ncase WM8993_DIGITAL_SIDE_TONE:\r\ncase WM8993_ADC_CTRL:\r\ncase WM8993_LEFT_ADC_DIGITAL_VOLUME:\r\ncase WM8993_RIGHT_ADC_DIGITAL_VOLUME:\r\ncase WM8993_GPIO_CTRL_1:\r\ncase WM8993_GPIO1:\r\ncase WM8993_IRQ_DEBOUNCE:\r\ncase WM8993_GPIOCTRL_2:\r\ncase WM8993_GPIO_POL:\r\ncase WM8993_LEFT_LINE_INPUT_1_2_VOLUME:\r\ncase WM8993_LEFT_LINE_INPUT_3_4_VOLUME:\r\ncase WM8993_RIGHT_LINE_INPUT_1_2_VOLUME:\r\ncase WM8993_RIGHT_LINE_INPUT_3_4_VOLUME:\r\ncase WM8993_LEFT_OUTPUT_VOLUME:\r\ncase WM8993_RIGHT_OUTPUT_VOLUME:\r\ncase WM8993_LINE_OUTPUTS_VOLUME:\r\ncase WM8993_HPOUT2_VOLUME:\r\ncase WM8993_LEFT_OPGA_VOLUME:\r\ncase WM8993_RIGHT_OPGA_VOLUME:\r\ncase WM8993_SPKMIXL_ATTENUATION:\r\ncase WM8993_SPKMIXR_ATTENUATION:\r\ncase WM8993_SPKOUT_MIXERS:\r\ncase WM8993_SPKOUT_BOOST:\r\ncase WM8993_SPEAKER_VOLUME_LEFT:\r\ncase WM8993_SPEAKER_VOLUME_RIGHT:\r\ncase WM8993_INPUT_MIXER2:\r\ncase WM8993_INPUT_MIXER3:\r\ncase WM8993_INPUT_MIXER4:\r\ncase WM8993_INPUT_MIXER5:\r\ncase WM8993_INPUT_MIXER6:\r\ncase WM8993_OUTPUT_MIXER1:\r\ncase WM8993_OUTPUT_MIXER2:\r\ncase WM8993_OUTPUT_MIXER3:\r\ncase WM8993_OUTPUT_MIXER4:\r\ncase WM8993_OUTPUT_MIXER5:\r\ncase WM8993_OUTPUT_MIXER6:\r\ncase WM8993_HPOUT2_MIXER:\r\ncase WM8993_LINE_MIXER1:\r\ncase WM8993_LINE_MIXER2:\r\ncase WM8993_SPEAKER_MIXER:\r\ncase WM8993_ADDITIONAL_CONTROL:\r\ncase WM8993_ANTIPOP1:\r\ncase WM8993_ANTIPOP2:\r\ncase WM8993_MICBIAS:\r\ncase WM8993_FLL_CONTROL_1:\r\ncase WM8993_FLL_CONTROL_2:\r\ncase WM8993_FLL_CONTROL_3:\r\ncase WM8993_FLL_CONTROL_4:\r\ncase WM8993_FLL_CONTROL_5:\r\ncase WM8993_CLOCKING_3:\r\ncase WM8993_CLOCKING_4:\r\ncase WM8993_MW_SLAVE_CONTROL:\r\ncase WM8993_BUS_CONTROL_1:\r\ncase WM8993_WRITE_SEQUENCER_0:\r\ncase WM8993_WRITE_SEQUENCER_1:\r\ncase WM8993_WRITE_SEQUENCER_2:\r\ncase WM8993_WRITE_SEQUENCER_3:\r\ncase WM8993_WRITE_SEQUENCER_4:\r\ncase WM8993_WRITE_SEQUENCER_5:\r\ncase WM8993_CHARGE_PUMP_1:\r\ncase WM8993_CLASS_W_0:\r\ncase WM8993_DC_SERVO_0:\r\ncase WM8993_DC_SERVO_1:\r\ncase WM8993_DC_SERVO_3:\r\ncase WM8993_DC_SERVO_READBACK_0:\r\ncase WM8993_DC_SERVO_READBACK_1:\r\ncase WM8993_DC_SERVO_READBACK_2:\r\ncase WM8993_ANALOGUE_HP_0:\r\ncase WM8993_EQ1:\r\ncase WM8993_EQ2:\r\ncase WM8993_EQ3:\r\ncase WM8993_EQ4:\r\ncase WM8993_EQ5:\r\ncase WM8993_EQ6:\r\ncase WM8993_EQ7:\r\ncase WM8993_EQ8:\r\ncase WM8993_EQ9:\r\ncase WM8993_EQ10:\r\ncase WM8993_EQ11:\r\ncase WM8993_EQ12:\r\ncase WM8993_EQ13:\r\ncase WM8993_EQ14:\r\ncase WM8993_EQ15:\r\ncase WM8993_EQ16:\r\ncase WM8993_EQ17:\r\ncase WM8993_EQ18:\r\ncase WM8993_EQ19:\r\ncase WM8993_EQ20:\r\ncase WM8993_EQ21:\r\ncase WM8993_EQ22:\r\ncase WM8993_EQ23:\r\ncase WM8993_EQ24:\r\ncase WM8993_DIGITAL_PULLS:\r\ncase WM8993_DRC_CONTROL_1:\r\ncase WM8993_DRC_CONTROL_2:\r\ncase WM8993_DRC_CONTROL_3:\r\ncase WM8993_DRC_CONTROL_4:\r\nreturn true;\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nstatic int fll_factors(struct _fll_div *fll_div, unsigned int Fref,\r\nunsigned int Fout)\r\n{\r\nu64 Kpart;\r\nunsigned int K, Ndiv, Nmod, target;\r\nunsigned int div;\r\nint i;\r\ndiv = 1;\r\nfll_div->fll_clk_ref_div = 0;\r\nwhile ((Fref / div) > 13500000) {\r\ndiv *= 2;\r\nfll_div->fll_clk_ref_div++;\r\nif (div > 8) {\r\npr_err("Can't scale %dMHz input down to <=13.5MHz\n",\r\nFref);\r\nreturn -EINVAL;\r\n}\r\n}\r\npr_debug("Fref=%u Fout=%u\n", Fref, Fout);\r\nFref /= div;\r\ndiv = 0;\r\ntarget = Fout * 2;\r\nwhile (target < 90000000) {\r\ndiv++;\r\ntarget *= 2;\r\nif (div > 7) {\r\npr_err("Unable to find FLL_OUTDIV for Fout=%uHz\n",\r\nFout);\r\nreturn -EINVAL;\r\n}\r\n}\r\nfll_div->fll_outdiv = div;\r\npr_debug("Fvco=%dHz\n", target);\r\nfor (i = 0; i < ARRAY_SIZE(fll_fratios); i++) {\r\nif (fll_fratios[i].min <= Fref && Fref <= fll_fratios[i].max) {\r\nfll_div->fll_fratio = fll_fratios[i].fll_fratio;\r\ntarget /= fll_fratios[i].ratio;\r\nbreak;\r\n}\r\n}\r\nif (i == ARRAY_SIZE(fll_fratios)) {\r\npr_err("Unable to find FLL_FRATIO for Fref=%uHz\n", Fref);\r\nreturn -EINVAL;\r\n}\r\nNdiv = target / Fref;\r\nfll_div->n = Ndiv;\r\nNmod = target % Fref;\r\npr_debug("Nmod=%d\n", Nmod);\r\nKpart = FIXED_FLL_SIZE * (long long)Nmod;\r\ndo_div(Kpart, Fref);\r\nK = Kpart & 0xFFFFFFFF;\r\nif ((K % 10) >= 5)\r\nK += 5;\r\nfll_div->k = K / 10;\r\npr_debug("N=%x K=%x FLL_FRATIO=%x FLL_OUTDIV=%x FLL_CLK_REF_DIV=%x\n",\r\nfll_div->n, fll_div->k,\r\nfll_div->fll_fratio, fll_div->fll_outdiv,\r\nfll_div->fll_clk_ref_div);\r\nreturn 0;\r\n}\r\nstatic int _wm8993_set_fll(struct snd_soc_codec *codec, int fll_id, int source,\r\nunsigned int Fref, unsigned int Fout)\r\n{\r\nstruct wm8993_priv *wm8993 = snd_soc_codec_get_drvdata(codec);\r\nstruct i2c_client *i2c = to_i2c_client(codec->dev);\r\nu16 reg1, reg4, reg5;\r\nstruct _fll_div fll_div;\r\nunsigned int timeout;\r\nint ret;\r\nif (Fref == wm8993->fll_fref && Fout == wm8993->fll_fout)\r\nreturn 0;\r\nif (Fout == 0) {\r\ndev_dbg(codec->dev, "FLL disabled\n");\r\nwm8993->fll_fref = 0;\r\nwm8993->fll_fout = 0;\r\nreg1 = snd_soc_read(codec, WM8993_FLL_CONTROL_1);\r\nreg1 &= ~WM8993_FLL_ENA;\r\nsnd_soc_write(codec, WM8993_FLL_CONTROL_1, reg1);\r\nreturn 0;\r\n}\r\nret = fll_factors(&fll_div, Fref, Fout);\r\nif (ret != 0)\r\nreturn ret;\r\nreg5 = snd_soc_read(codec, WM8993_FLL_CONTROL_5);\r\nreg5 &= ~WM8993_FLL_CLK_SRC_MASK;\r\nswitch (fll_id) {\r\ncase WM8993_FLL_MCLK:\r\nbreak;\r\ncase WM8993_FLL_LRCLK:\r\nreg5 |= 1;\r\nbreak;\r\ncase WM8993_FLL_BCLK:\r\nreg5 |= 2;\r\nbreak;\r\ndefault:\r\ndev_err(codec->dev, "Unknown FLL ID %d\n", fll_id);\r\nreturn -EINVAL;\r\n}\r\nreg1 = snd_soc_read(codec, WM8993_FLL_CONTROL_1);\r\nreg1 &= ~WM8993_FLL_ENA;\r\nsnd_soc_write(codec, WM8993_FLL_CONTROL_1, reg1);\r\nif (fll_div.k)\r\nreg1 |= WM8993_FLL_FRAC_MASK;\r\nelse\r\nreg1 &= ~WM8993_FLL_FRAC_MASK;\r\nsnd_soc_write(codec, WM8993_FLL_CONTROL_1, reg1);\r\nsnd_soc_write(codec, WM8993_FLL_CONTROL_2,\r\n(fll_div.fll_outdiv << WM8993_FLL_OUTDIV_SHIFT) |\r\n(fll_div.fll_fratio << WM8993_FLL_FRATIO_SHIFT));\r\nsnd_soc_write(codec, WM8993_FLL_CONTROL_3, fll_div.k);\r\nreg4 = snd_soc_read(codec, WM8993_FLL_CONTROL_4);\r\nreg4 &= ~WM8993_FLL_N_MASK;\r\nreg4 |= fll_div.n << WM8993_FLL_N_SHIFT;\r\nsnd_soc_write(codec, WM8993_FLL_CONTROL_4, reg4);\r\nreg5 &= ~WM8993_FLL_CLK_REF_DIV_MASK;\r\nreg5 |= fll_div.fll_clk_ref_div << WM8993_FLL_CLK_REF_DIV_SHIFT;\r\nsnd_soc_write(codec, WM8993_FLL_CONTROL_5, reg5);\r\nif (i2c->irq)\r\ntimeout = msecs_to_jiffies(20);\r\nelse if (Fref < 1000000)\r\ntimeout = msecs_to_jiffies(3);\r\nelse\r\ntimeout = msecs_to_jiffies(1);\r\ntry_wait_for_completion(&wm8993->fll_lock);\r\nsnd_soc_write(codec, WM8993_FLL_CONTROL_1, reg1 | WM8993_FLL_ENA);\r\ntimeout = wait_for_completion_timeout(&wm8993->fll_lock, timeout);\r\nif (i2c->irq && !timeout)\r\ndev_warn(codec->dev, "Timed out waiting for FLL\n");\r\ndev_dbg(codec->dev, "FLL enabled at %dHz->%dHz\n", Fref, Fout);\r\nwm8993->fll_fref = Fref;\r\nwm8993->fll_fout = Fout;\r\nwm8993->fll_src = source;\r\nreturn 0;\r\n}\r\nstatic int wm8993_set_fll(struct snd_soc_dai *dai, int fll_id, int source,\r\nunsigned int Fref, unsigned int Fout)\r\n{\r\nreturn _wm8993_set_fll(dai->codec, fll_id, source, Fref, Fout);\r\n}\r\nstatic int configure_clock(struct snd_soc_codec *codec)\r\n{\r\nstruct wm8993_priv *wm8993 = snd_soc_codec_get_drvdata(codec);\r\nunsigned int reg;\r\nswitch (wm8993->sysclk_source) {\r\ncase WM8993_SYSCLK_MCLK:\r\ndev_dbg(codec->dev, "Using %dHz MCLK\n", wm8993->mclk_rate);\r\nreg = snd_soc_read(codec, WM8993_CLOCKING_2);\r\nreg &= ~(WM8993_MCLK_DIV | WM8993_SYSCLK_SRC);\r\nif (wm8993->mclk_rate > 13500000) {\r\nreg |= WM8993_MCLK_DIV;\r\nwm8993->sysclk_rate = wm8993->mclk_rate / 2;\r\n} else {\r\nreg &= ~WM8993_MCLK_DIV;\r\nwm8993->sysclk_rate = wm8993->mclk_rate;\r\n}\r\nsnd_soc_write(codec, WM8993_CLOCKING_2, reg);\r\nbreak;\r\ncase WM8993_SYSCLK_FLL:\r\ndev_dbg(codec->dev, "Using %dHz FLL clock\n",\r\nwm8993->fll_fout);\r\nreg = snd_soc_read(codec, WM8993_CLOCKING_2);\r\nreg |= WM8993_SYSCLK_SRC;\r\nif (wm8993->fll_fout > 13500000) {\r\nreg |= WM8993_MCLK_DIV;\r\nwm8993->sysclk_rate = wm8993->fll_fout / 2;\r\n} else {\r\nreg &= ~WM8993_MCLK_DIV;\r\nwm8993->sysclk_rate = wm8993->fll_fout;\r\n}\r\nsnd_soc_write(codec, WM8993_CLOCKING_2, reg);\r\nbreak;\r\ndefault:\r\ndev_err(codec->dev, "System clock not configured\n");\r\nreturn -EINVAL;\r\n}\r\ndev_dbg(codec->dev, "CLK_SYS is %dHz\n", wm8993->sysclk_rate);\r\nreturn 0;\r\n}\r\nstatic int clk_sys_event(struct snd_soc_dapm_widget *w,\r\nstruct snd_kcontrol *kcontrol, int event)\r\n{\r\nstruct snd_soc_codec *codec = snd_soc_dapm_to_codec(w->dapm);\r\nswitch (event) {\r\ncase SND_SOC_DAPM_PRE_PMU:\r\nreturn configure_clock(codec);\r\ncase SND_SOC_DAPM_POST_PMD:\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int wm8993_set_bias_level(struct snd_soc_codec *codec,\r\nenum snd_soc_bias_level level)\r\n{\r\nstruct wm8993_priv *wm8993 = snd_soc_codec_get_drvdata(codec);\r\nint ret;\r\nwm_hubs_set_bias_level(codec, level);\r\nswitch (level) {\r\ncase SND_SOC_BIAS_ON:\r\ncase SND_SOC_BIAS_PREPARE:\r\nsnd_soc_update_bits(codec, WM8993_POWER_MANAGEMENT_1,\r\nWM8993_VMID_SEL_MASK, 0x2);\r\nsnd_soc_update_bits(codec, WM8993_POWER_MANAGEMENT_2,\r\nWM8993_TSHUT_ENA, WM8993_TSHUT_ENA);\r\nbreak;\r\ncase SND_SOC_BIAS_STANDBY:\r\nif (codec->dapm.bias_level == SND_SOC_BIAS_OFF) {\r\nret = regulator_bulk_enable(ARRAY_SIZE(wm8993->supplies),\r\nwm8993->supplies);\r\nif (ret != 0)\r\nreturn ret;\r\nregcache_cache_only(wm8993->regmap, false);\r\nregcache_sync(wm8993->regmap);\r\nwm_hubs_vmid_ena(codec);\r\nsnd_soc_update_bits(codec, WM8993_ANTIPOP2,\r\nWM8993_STARTUP_BIAS_ENA |\r\nWM8993_VMID_BUF_ENA |\r\nWM8993_VMID_RAMP_MASK |\r\nWM8993_BIAS_SRC,\r\nWM8993_STARTUP_BIAS_ENA |\r\nWM8993_VMID_BUF_ENA |\r\nWM8993_VMID_RAMP_MASK |\r\nWM8993_BIAS_SRC);\r\nif (!wm8993->pdata.lineout1_diff ||\r\n!wm8993->pdata.lineout2_diff)\r\nsnd_soc_update_bits(codec, WM8993_ANTIPOP1,\r\nWM8993_LINEOUT_VMID_BUF_ENA,\r\nWM8993_LINEOUT_VMID_BUF_ENA);\r\nsnd_soc_update_bits(codec, WM8993_POWER_MANAGEMENT_1,\r\nWM8993_VMID_SEL_MASK |\r\nWM8993_BIAS_ENA,\r\nWM8993_BIAS_ENA | 0x2);\r\nmsleep(32);\r\nsnd_soc_update_bits(codec, WM8993_ANTIPOP2,\r\nWM8993_BIAS_SRC |\r\nWM8993_STARTUP_BIAS_ENA, 0);\r\n}\r\nsnd_soc_update_bits(codec, WM8993_POWER_MANAGEMENT_1,\r\nWM8993_VMID_SEL_MASK, 0x4);\r\nsnd_soc_update_bits(codec, WM8993_POWER_MANAGEMENT_2,\r\nWM8993_TSHUT_ENA, 0);\r\nbreak;\r\ncase SND_SOC_BIAS_OFF:\r\nsnd_soc_update_bits(codec, WM8993_ANTIPOP1,\r\nWM8993_LINEOUT_VMID_BUF_ENA, 0);\r\nsnd_soc_update_bits(codec, WM8993_POWER_MANAGEMENT_1,\r\nWM8993_VMID_SEL_MASK | WM8993_BIAS_ENA,\r\n0);\r\nsnd_soc_update_bits(codec, WM8993_ANTIPOP2,\r\nWM8993_STARTUP_BIAS_ENA |\r\nWM8993_VMID_BUF_ENA |\r\nWM8993_VMID_RAMP_MASK |\r\nWM8993_BIAS_SRC, 0);\r\nregcache_cache_only(wm8993->regmap, true);\r\nregcache_mark_dirty(wm8993->regmap);\r\nregulator_bulk_disable(ARRAY_SIZE(wm8993->supplies),\r\nwm8993->supplies);\r\nbreak;\r\n}\r\ncodec->dapm.bias_level = level;\r\nreturn 0;\r\n}\r\nstatic int wm8993_set_sysclk(struct snd_soc_dai *codec_dai,\r\nint clk_id, unsigned int freq, int dir)\r\n{\r\nstruct snd_soc_codec *codec = codec_dai->codec;\r\nstruct wm8993_priv *wm8993 = snd_soc_codec_get_drvdata(codec);\r\nswitch (clk_id) {\r\ncase WM8993_SYSCLK_MCLK:\r\nwm8993->mclk_rate = freq;\r\ncase WM8993_SYSCLK_FLL:\r\nwm8993->sysclk_source = clk_id;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int wm8993_set_dai_fmt(struct snd_soc_dai *dai,\r\nunsigned int fmt)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nstruct wm8993_priv *wm8993 = snd_soc_codec_get_drvdata(codec);\r\nunsigned int aif1 = snd_soc_read(codec, WM8993_AUDIO_INTERFACE_1);\r\nunsigned int aif4 = snd_soc_read(codec, WM8993_AUDIO_INTERFACE_4);\r\naif1 &= ~(WM8993_BCLK_DIR | WM8993_AIF_BCLK_INV |\r\nWM8993_AIF_LRCLK_INV | WM8993_AIF_FMT_MASK);\r\naif4 &= ~WM8993_LRCLK_DIR;\r\nswitch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {\r\ncase SND_SOC_DAIFMT_CBS_CFS:\r\nwm8993->master = 0;\r\nbreak;\r\ncase SND_SOC_DAIFMT_CBS_CFM:\r\naif4 |= WM8993_LRCLK_DIR;\r\nwm8993->master = 1;\r\nbreak;\r\ncase SND_SOC_DAIFMT_CBM_CFS:\r\naif1 |= WM8993_BCLK_DIR;\r\nwm8993->master = 1;\r\nbreak;\r\ncase SND_SOC_DAIFMT_CBM_CFM:\r\naif1 |= WM8993_BCLK_DIR;\r\naif4 |= WM8993_LRCLK_DIR;\r\nwm8993->master = 1;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\r\ncase SND_SOC_DAIFMT_DSP_B:\r\naif1 |= WM8993_AIF_LRCLK_INV;\r\ncase SND_SOC_DAIFMT_DSP_A:\r\naif1 |= 0x18;\r\nbreak;\r\ncase SND_SOC_DAIFMT_I2S:\r\naif1 |= 0x10;\r\nbreak;\r\ncase SND_SOC_DAIFMT_RIGHT_J:\r\nbreak;\r\ncase SND_SOC_DAIFMT_LEFT_J:\r\naif1 |= 0x8;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\r\ncase SND_SOC_DAIFMT_DSP_A:\r\ncase SND_SOC_DAIFMT_DSP_B:\r\nswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\r\ncase SND_SOC_DAIFMT_NB_NF:\r\nbreak;\r\ncase SND_SOC_DAIFMT_IB_NF:\r\naif1 |= WM8993_AIF_BCLK_INV;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ncase SND_SOC_DAIFMT_I2S:\r\ncase SND_SOC_DAIFMT_RIGHT_J:\r\ncase SND_SOC_DAIFMT_LEFT_J:\r\nswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\r\ncase SND_SOC_DAIFMT_NB_NF:\r\nbreak;\r\ncase SND_SOC_DAIFMT_IB_IF:\r\naif1 |= WM8993_AIF_BCLK_INV | WM8993_AIF_LRCLK_INV;\r\nbreak;\r\ncase SND_SOC_DAIFMT_IB_NF:\r\naif1 |= WM8993_AIF_BCLK_INV;\r\nbreak;\r\ncase SND_SOC_DAIFMT_NB_IF:\r\naif1 |= WM8993_AIF_LRCLK_INV;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nsnd_soc_write(codec, WM8993_AUDIO_INTERFACE_1, aif1);\r\nsnd_soc_write(codec, WM8993_AUDIO_INTERFACE_4, aif4);\r\nreturn 0;\r\n}\r\nstatic int wm8993_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nstruct wm8993_priv *wm8993 = snd_soc_codec_get_drvdata(codec);\r\nint ret, i, best, best_val, cur_val;\r\nunsigned int clocking1, clocking3, aif1, aif4;\r\nclocking1 = snd_soc_read(codec, WM8993_CLOCKING_1);\r\nclocking1 &= ~WM8993_BCLK_DIV_MASK;\r\nclocking3 = snd_soc_read(codec, WM8993_CLOCKING_3);\r\nclocking3 &= ~(WM8993_CLK_SYS_RATE_MASK | WM8993_SAMPLE_RATE_MASK);\r\naif1 = snd_soc_read(codec, WM8993_AUDIO_INTERFACE_1);\r\naif1 &= ~WM8993_AIF_WL_MASK;\r\naif4 = snd_soc_read(codec, WM8993_AUDIO_INTERFACE_4);\r\naif4 &= ~WM8993_LRCLK_RATE_MASK;\r\nwm8993->fs = params_rate(params);\r\nwm8993->bclk = 2 * wm8993->fs;\r\nif (wm8993->tdm_slots) {\r\ndev_dbg(codec->dev, "Configuring for %d %d bit TDM slots\n",\r\nwm8993->tdm_slots, wm8993->tdm_width);\r\nwm8993->bclk *= wm8993->tdm_width * wm8993->tdm_slots;\r\n} else {\r\nswitch (params_width(params)) {\r\ncase 16:\r\nwm8993->bclk *= 16;\r\nbreak;\r\ncase 20:\r\nwm8993->bclk *= 20;\r\naif1 |= 0x8;\r\nbreak;\r\ncase 24:\r\nwm8993->bclk *= 24;\r\naif1 |= 0x10;\r\nbreak;\r\ncase 32:\r\nwm8993->bclk *= 32;\r\naif1 |= 0x18;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\ndev_dbg(codec->dev, "Target BCLK is %dHz\n", wm8993->bclk);\r\nret = configure_clock(codec);\r\nif (ret != 0)\r\nreturn ret;\r\nbest = 0;\r\nbest_val = abs((wm8993->sysclk_rate / clk_sys_rates[0].ratio)\r\n- wm8993->fs);\r\nfor (i = 1; i < ARRAY_SIZE(clk_sys_rates); i++) {\r\ncur_val = abs((wm8993->sysclk_rate /\r\nclk_sys_rates[i].ratio) - wm8993->fs);\r\nif (cur_val < best_val) {\r\nbest = i;\r\nbest_val = cur_val;\r\n}\r\n}\r\ndev_dbg(codec->dev, "Selected CLK_SYS_RATIO of %d\n",\r\nclk_sys_rates[best].ratio);\r\nclocking3 |= (clk_sys_rates[best].clk_sys_rate\r\n<< WM8993_CLK_SYS_RATE_SHIFT);\r\nbest = 0;\r\nbest_val = abs(wm8993->fs - sample_rates[0].rate);\r\nfor (i = 1; i < ARRAY_SIZE(sample_rates); i++) {\r\ncur_val = abs(wm8993->fs - sample_rates[i].rate);\r\nif (cur_val < best_val) {\r\nbest = i;\r\nbest_val = cur_val;\r\n}\r\n}\r\ndev_dbg(codec->dev, "Selected SAMPLE_RATE of %dHz\n",\r\nsample_rates[best].rate);\r\nclocking3 |= (sample_rates[best].sample_rate\r\n<< WM8993_SAMPLE_RATE_SHIFT);\r\nbest = 0;\r\nbest_val = INT_MAX;\r\nfor (i = 0; i < ARRAY_SIZE(bclk_divs); i++) {\r\ncur_val = ((wm8993->sysclk_rate * 10) / bclk_divs[i].div)\r\n- wm8993->bclk;\r\nif (cur_val < 0)\r\nbreak;\r\nif (cur_val < best_val) {\r\nbest = i;\r\nbest_val = cur_val;\r\n}\r\n}\r\nwm8993->bclk = (wm8993->sysclk_rate * 10) / bclk_divs[best].div;\r\ndev_dbg(codec->dev, "Selected BCLK_DIV of %d for %dHz BCLK\n",\r\nbclk_divs[best].div, wm8993->bclk);\r\nclocking1 |= bclk_divs[best].bclk_div << WM8993_BCLK_DIV_SHIFT;\r\ndev_dbg(codec->dev, "LRCLK_RATE is %d\n", wm8993->bclk / wm8993->fs);\r\naif4 |= wm8993->bclk / wm8993->fs;\r\nsnd_soc_write(codec, WM8993_CLOCKING_1, clocking1);\r\nsnd_soc_write(codec, WM8993_CLOCKING_3, clocking3);\r\nsnd_soc_write(codec, WM8993_AUDIO_INTERFACE_1, aif1);\r\nsnd_soc_write(codec, WM8993_AUDIO_INTERFACE_4, aif4);\r\nif (wm8993->pdata.num_retune_configs) {\r\nu16 eq1 = snd_soc_read(codec, WM8993_EQ1);\r\nstruct wm8993_retune_mobile_setting *s;\r\nbest = 0;\r\nbest_val = abs(wm8993->pdata.retune_configs[0].rate\r\n- wm8993->fs);\r\nfor (i = 0; i < wm8993->pdata.num_retune_configs; i++) {\r\ncur_val = abs(wm8993->pdata.retune_configs[i].rate\r\n- wm8993->fs);\r\nif (cur_val < best_val) {\r\nbest_val = cur_val;\r\nbest = i;\r\n}\r\n}\r\ns = &wm8993->pdata.retune_configs[best];\r\ndev_dbg(codec->dev, "ReTune Mobile %s tuned for %dHz\n",\r\ns->name, s->rate);\r\nsnd_soc_update_bits(codec, WM8993_EQ1, WM8993_EQ_ENA, 0);\r\nfor (i = 1; i < ARRAY_SIZE(s->config); i++)\r\nsnd_soc_write(codec, WM8993_EQ1 + i, s->config[i]);\r\nsnd_soc_update_bits(codec, WM8993_EQ1, WM8993_EQ_ENA, eq1);\r\n}\r\nreturn 0;\r\n}\r\nstatic int wm8993_digital_mute(struct snd_soc_dai *codec_dai, int mute)\r\n{\r\nstruct snd_soc_codec *codec = codec_dai->codec;\r\nunsigned int reg;\r\nreg = snd_soc_read(codec, WM8993_DAC_CTRL);\r\nif (mute)\r\nreg |= WM8993_DAC_MUTE;\r\nelse\r\nreg &= ~WM8993_DAC_MUTE;\r\nsnd_soc_write(codec, WM8993_DAC_CTRL, reg);\r\nreturn 0;\r\n}\r\nstatic int wm8993_set_tdm_slot(struct snd_soc_dai *dai, unsigned int tx_mask,\r\nunsigned int rx_mask, int slots, int slot_width)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nstruct wm8993_priv *wm8993 = snd_soc_codec_get_drvdata(codec);\r\nint aif1 = 0;\r\nint aif2 = 0;\r\nif (slots == 0) {\r\nwm8993->tdm_slots = 0;\r\ngoto out;\r\n}\r\naif1 |= WM8993_AIFADC_TDM;\r\naif2 |= WM8993_AIFDAC_TDM;\r\nswitch (rx_mask) {\r\ncase 3:\r\nbreak;\r\ncase 0xc:\r\naif1 |= WM8993_AIFADC_TDM_CHAN;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (tx_mask) {\r\ncase 3:\r\nbreak;\r\ncase 0xc:\r\naif2 |= WM8993_AIFDAC_TDM_CHAN;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nout:\r\nwm8993->tdm_width = slot_width;\r\nwm8993->tdm_slots = slots / 2;\r\nsnd_soc_update_bits(codec, WM8993_AUDIO_INTERFACE_1,\r\nWM8993_AIFADC_TDM | WM8993_AIFADC_TDM_CHAN, aif1);\r\nsnd_soc_update_bits(codec, WM8993_AUDIO_INTERFACE_2,\r\nWM8993_AIFDAC_TDM | WM8993_AIFDAC_TDM_CHAN, aif2);\r\nreturn 0;\r\n}\r\nstatic irqreturn_t wm8993_irq(int irq, void *data)\r\n{\r\nstruct wm8993_priv *wm8993 = data;\r\nint mask, val, ret;\r\nret = regmap_read(wm8993->regmap, WM8993_GPIO_CTRL_1, &val);\r\nif (ret != 0) {\r\ndev_err(wm8993->dev, "Failed to read interrupt status: %d\n",\r\nret);\r\nreturn IRQ_NONE;\r\n}\r\nret = regmap_read(wm8993->regmap, WM8993_GPIOCTRL_2, &mask);\r\nif (ret != 0) {\r\ndev_err(wm8993->dev, "Failed to read interrupt mask: %d\n",\r\nret);\r\nreturn IRQ_NONE;\r\n}\r\nval &= ~(mask | WM8993_IRQ);\r\nif (!val)\r\nreturn IRQ_NONE;\r\nif (val & WM8993_TEMPOK_EINT)\r\ndev_crit(wm8993->dev, "Thermal warning\n");\r\nif (val & WM8993_FLL_LOCK_EINT) {\r\ndev_dbg(wm8993->dev, "FLL locked\n");\r\ncomplete(&wm8993->fll_lock);\r\n}\r\nret = regmap_write(wm8993->regmap, WM8993_GPIO_CTRL_1, val);\r\nif (ret != 0)\r\ndev_err(wm8993->dev, "Failed to ack interrupt: %d\n", ret);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int wm8993_probe(struct snd_soc_codec *codec)\r\n{\r\nstruct wm8993_priv *wm8993 = snd_soc_codec_get_drvdata(codec);\r\nstruct snd_soc_dapm_context *dapm = &codec->dapm;\r\nwm8993->hubs_data.hp_startup_mode = 1;\r\nwm8993->hubs_data.dcs_codes_l = -2;\r\nwm8993->hubs_data.dcs_codes_r = -2;\r\nwm8993->hubs_data.series_startup = 1;\r\nsnd_soc_update_bits(codec, WM8993_RIGHT_DAC_DIGITAL_VOLUME,\r\nWM8993_DAC_VU, WM8993_DAC_VU);\r\nsnd_soc_update_bits(codec, WM8993_RIGHT_ADC_DIGITAL_VOLUME,\r\nWM8993_ADC_VU, WM8993_ADC_VU);\r\nsnd_soc_update_bits(codec, WM8993_ANALOGUE_HP_0,\r\nWM8993_HPOUT1_AUTO_PU, 0);\r\nsnd_soc_update_bits(codec, WM8993_CLOCKING_4, WM8993_SR_MODE, 0);\r\nwm_hubs_handle_analogue_pdata(codec, wm8993->pdata.lineout1_diff,\r\nwm8993->pdata.lineout2_diff,\r\nwm8993->pdata.lineout1fb,\r\nwm8993->pdata.lineout2fb,\r\nwm8993->pdata.jd_scthr,\r\nwm8993->pdata.jd_thr,\r\nwm8993->pdata.micbias1_delay,\r\nwm8993->pdata.micbias2_delay,\r\nwm8993->pdata.micbias1_lvl,\r\nwm8993->pdata.micbias2_lvl);\r\nsnd_soc_add_codec_controls(codec, wm8993_snd_controls,\r\nARRAY_SIZE(wm8993_snd_controls));\r\nif (wm8993->pdata.num_retune_configs != 0) {\r\ndev_dbg(codec->dev, "Using ReTune Mobile\n");\r\n} else {\r\ndev_dbg(codec->dev, "No ReTune Mobile, using normal EQ\n");\r\nsnd_soc_add_codec_controls(codec, wm8993_eq_controls,\r\nARRAY_SIZE(wm8993_eq_controls));\r\n}\r\nsnd_soc_dapm_new_controls(dapm, wm8993_dapm_widgets,\r\nARRAY_SIZE(wm8993_dapm_widgets));\r\nwm_hubs_add_analogue_controls(codec);\r\nsnd_soc_dapm_add_routes(dapm, routes, ARRAY_SIZE(routes));\r\nwm_hubs_add_analogue_routes(codec, wm8993->pdata.lineout1_diff,\r\nwm8993->pdata.lineout2_diff);\r\nif (wm8993->pdata.lineout1_diff && wm8993->pdata.lineout2_diff)\r\ncodec->dapm.idle_bias_off = 1;\r\nreturn 0;\r\n}\r\nstatic int wm8993_suspend(struct snd_soc_codec *codec)\r\n{\r\nstruct wm8993_priv *wm8993 = snd_soc_codec_get_drvdata(codec);\r\nint fll_fout = wm8993->fll_fout;\r\nint fll_fref = wm8993->fll_fref;\r\nint ret;\r\nret = _wm8993_set_fll(codec, 0, 0, 0, 0);\r\nif (ret != 0) {\r\ndev_err(codec->dev, "Failed to stop FLL\n");\r\nreturn ret;\r\n}\r\nwm8993->fll_fout = fll_fout;\r\nwm8993->fll_fref = fll_fref;\r\nwm8993_set_bias_level(codec, SND_SOC_BIAS_OFF);\r\nreturn 0;\r\n}\r\nstatic int wm8993_resume(struct snd_soc_codec *codec)\r\n{\r\nstruct wm8993_priv *wm8993 = snd_soc_codec_get_drvdata(codec);\r\nint ret;\r\nwm8993_set_bias_level(codec, SND_SOC_BIAS_STANDBY);\r\nif (wm8993->fll_fout) {\r\nint fll_fout = wm8993->fll_fout;\r\nint fll_fref = wm8993->fll_fref;\r\nwm8993->fll_fref = 0;\r\nwm8993->fll_fout = 0;\r\nret = _wm8993_set_fll(codec, 0, wm8993->fll_src,\r\nfll_fref, fll_fout);\r\nif (ret != 0)\r\ndev_err(codec->dev, "Failed to restart FLL\n");\r\n}\r\nreturn 0;\r\n}\r\nstatic int wm8993_i2c_probe(struct i2c_client *i2c,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct wm8993_priv *wm8993;\r\nunsigned int reg;\r\nint ret, i;\r\nwm8993 = devm_kzalloc(&i2c->dev, sizeof(struct wm8993_priv),\r\nGFP_KERNEL);\r\nif (wm8993 == NULL)\r\nreturn -ENOMEM;\r\nwm8993->dev = &i2c->dev;\r\ninit_completion(&wm8993->fll_lock);\r\nwm8993->regmap = devm_regmap_init_i2c(i2c, &wm8993_regmap);\r\nif (IS_ERR(wm8993->regmap)) {\r\nret = PTR_ERR(wm8993->regmap);\r\ndev_err(&i2c->dev, "Failed to allocate regmap: %d\n", ret);\r\nreturn ret;\r\n}\r\ni2c_set_clientdata(i2c, wm8993);\r\nfor (i = 0; i < ARRAY_SIZE(wm8993->supplies); i++)\r\nwm8993->supplies[i].supply = wm8993_supply_names[i];\r\nret = devm_regulator_bulk_get(&i2c->dev, ARRAY_SIZE(wm8993->supplies),\r\nwm8993->supplies);\r\nif (ret != 0) {\r\ndev_err(&i2c->dev, "Failed to request supplies: %d\n", ret);\r\nreturn ret;\r\n}\r\nret = regulator_bulk_enable(ARRAY_SIZE(wm8993->supplies),\r\nwm8993->supplies);\r\nif (ret != 0) {\r\ndev_err(&i2c->dev, "Failed to enable supplies: %d\n", ret);\r\nreturn ret;\r\n}\r\nret = regmap_read(wm8993->regmap, WM8993_SOFTWARE_RESET, &reg);\r\nif (ret != 0) {\r\ndev_err(&i2c->dev, "Failed to read chip ID: %d\n", ret);\r\ngoto err_enable;\r\n}\r\nif (reg != 0x8993) {\r\ndev_err(&i2c->dev, "Invalid ID register value %x\n", reg);\r\nret = -EINVAL;\r\ngoto err_enable;\r\n}\r\nret = regmap_write(wm8993->regmap, WM8993_SOFTWARE_RESET, 0xffff);\r\nif (ret != 0)\r\ngoto err_enable;\r\nret = regmap_register_patch(wm8993->regmap, wm8993_regmap_patch,\r\nARRAY_SIZE(wm8993_regmap_patch));\r\nif (ret != 0)\r\ndev_warn(wm8993->dev, "Failed to apply regmap patch: %d\n",\r\nret);\r\nif (i2c->irq) {\r\nret = regmap_update_bits(wm8993->regmap, WM8993_GPIO1,\r\nWM8993_GPIO1_PD |\r\nWM8993_GPIO1_SEL_MASK, 7);\r\nif (ret != 0)\r\ngoto err_enable;\r\nret = request_threaded_irq(i2c->irq, NULL, wm8993_irq,\r\nIRQF_TRIGGER_HIGH | IRQF_ONESHOT,\r\n"wm8993", wm8993);\r\nif (ret != 0)\r\ngoto err_enable;\r\n}\r\nregulator_bulk_disable(ARRAY_SIZE(wm8993->supplies), wm8993->supplies);\r\nregcache_cache_only(wm8993->regmap, true);\r\nret = snd_soc_register_codec(&i2c->dev,\r\n&soc_codec_dev_wm8993, &wm8993_dai, 1);\r\nif (ret != 0) {\r\ndev_err(&i2c->dev, "Failed to register CODEC: %d\n", ret);\r\ngoto err_irq;\r\n}\r\nreturn 0;\r\nerr_irq:\r\nif (i2c->irq)\r\nfree_irq(i2c->irq, wm8993);\r\nerr_enable:\r\nregulator_bulk_disable(ARRAY_SIZE(wm8993->supplies), wm8993->supplies);\r\nreturn ret;\r\n}\r\nstatic int wm8993_i2c_remove(struct i2c_client *i2c)\r\n{\r\nstruct wm8993_priv *wm8993 = i2c_get_clientdata(i2c);\r\nsnd_soc_unregister_codec(&i2c->dev);\r\nif (i2c->irq)\r\nfree_irq(i2c->irq, wm8993);\r\nregulator_bulk_disable(ARRAY_SIZE(wm8993->supplies), wm8993->supplies);\r\nreturn 0;\r\n}
