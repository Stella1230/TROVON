static struct syscon *of_syscon_register(struct device_node *np)\r\n{\r\nstruct syscon *syscon;\r\nstruct regmap *regmap;\r\nvoid __iomem *base;\r\nint ret;\r\nstruct regmap_config syscon_config = syscon_regmap_config;\r\nif (!of_device_is_compatible(np, "syscon"))\r\nreturn ERR_PTR(-EINVAL);\r\nsyscon = kzalloc(sizeof(*syscon), GFP_KERNEL);\r\nif (!syscon)\r\nreturn ERR_PTR(-ENOMEM);\r\nbase = of_iomap(np, 0);\r\nif (!base) {\r\nret = -ENOMEM;\r\ngoto err_map;\r\n}\r\nif (of_property_read_bool(np, "big-endian"))\r\nsyscon_config.val_format_endian = REGMAP_ENDIAN_BIG;\r\nelse if (of_property_read_bool(np, "little-endian"))\r\nsyscon_config.val_format_endian = REGMAP_ENDIAN_LITTLE;\r\nregmap = regmap_init_mmio(NULL, base, &syscon_config);\r\nif (IS_ERR(regmap)) {\r\npr_err("regmap init failed\n");\r\nret = PTR_ERR(regmap);\r\ngoto err_regmap;\r\n}\r\nsyscon->regmap = regmap;\r\nsyscon->np = np;\r\nspin_lock(&syscon_list_slock);\r\nlist_add_tail(&syscon->list, &syscon_list);\r\nspin_unlock(&syscon_list_slock);\r\nreturn syscon;\r\nerr_regmap:\r\niounmap(base);\r\nerr_map:\r\nkfree(syscon);\r\nreturn ERR_PTR(ret);\r\n}\r\nstruct regmap *syscon_node_to_regmap(struct device_node *np)\r\n{\r\nstruct syscon *entry, *syscon = NULL;\r\nspin_lock(&syscon_list_slock);\r\nlist_for_each_entry(entry, &syscon_list, list)\r\nif (entry->np == np) {\r\nsyscon = entry;\r\nbreak;\r\n}\r\nspin_unlock(&syscon_list_slock);\r\nif (!syscon)\r\nsyscon = of_syscon_register(np);\r\nif (IS_ERR(syscon))\r\nreturn ERR_CAST(syscon);\r\nreturn syscon->regmap;\r\n}\r\nstruct regmap *syscon_regmap_lookup_by_compatible(const char *s)\r\n{\r\nstruct device_node *syscon_np;\r\nstruct regmap *regmap;\r\nsyscon_np = of_find_compatible_node(NULL, NULL, s);\r\nif (!syscon_np)\r\nreturn ERR_PTR(-ENODEV);\r\nregmap = syscon_node_to_regmap(syscon_np);\r\nof_node_put(syscon_np);\r\nreturn regmap;\r\n}\r\nstatic int syscon_match_pdevname(struct device *dev, void *data)\r\n{\r\nreturn !strcmp(dev_name(dev), (const char *)data);\r\n}\r\nstruct regmap *syscon_regmap_lookup_by_pdevname(const char *s)\r\n{\r\nstruct device *dev;\r\nstruct syscon *syscon;\r\ndev = driver_find_device(&syscon_driver.driver, NULL, (void *)s,\r\nsyscon_match_pdevname);\r\nif (!dev)\r\nreturn ERR_PTR(-EPROBE_DEFER);\r\nsyscon = dev_get_drvdata(dev);\r\nreturn syscon->regmap;\r\n}\r\nstruct regmap *syscon_regmap_lookup_by_phandle(struct device_node *np,\r\nconst char *property)\r\n{\r\nstruct device_node *syscon_np;\r\nstruct regmap *regmap;\r\nif (property)\r\nsyscon_np = of_parse_phandle(np, property, 0);\r\nelse\r\nsyscon_np = np;\r\nif (!syscon_np)\r\nreturn ERR_PTR(-ENODEV);\r\nregmap = syscon_node_to_regmap(syscon_np);\r\nof_node_put(syscon_np);\r\nreturn regmap;\r\n}\r\nstatic int syscon_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct syscon_platform_data *pdata = dev_get_platdata(dev);\r\nstruct syscon *syscon;\r\nstruct resource *res;\r\nvoid __iomem *base;\r\nsyscon = devm_kzalloc(dev, sizeof(*syscon), GFP_KERNEL);\r\nif (!syscon)\r\nreturn -ENOMEM;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!res)\r\nreturn -ENOENT;\r\nbase = devm_ioremap(dev, res->start, resource_size(res));\r\nif (!base)\r\nreturn -ENOMEM;\r\nsyscon_regmap_config.max_register = res->end - res->start - 3;\r\nif (pdata)\r\nsyscon_regmap_config.name = pdata->label;\r\nsyscon->regmap = devm_regmap_init_mmio(dev, base,\r\n&syscon_regmap_config);\r\nif (IS_ERR(syscon->regmap)) {\r\ndev_err(dev, "regmap init failed\n");\r\nreturn PTR_ERR(syscon->regmap);\r\n}\r\nplatform_set_drvdata(pdev, syscon);\r\ndev_dbg(dev, "regmap %pR registered\n", res);\r\nreturn 0;\r\n}\r\nstatic int __init syscon_init(void)\r\n{\r\nreturn platform_driver_register(&syscon_driver);\r\n}\r\nstatic void __exit syscon_exit(void)\r\n{\r\nplatform_driver_unregister(&syscon_driver);\r\n}
