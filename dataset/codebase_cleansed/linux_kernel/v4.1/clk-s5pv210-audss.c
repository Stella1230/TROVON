static int s5pv210_audss_clk_suspend(void)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(reg_save); i++)\r\nreg_save[i][1] = readl(reg_base + reg_save[i][0]);\r\nreturn 0;\r\n}\r\nstatic void s5pv210_audss_clk_resume(void)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(reg_save); i++)\r\nwritel(reg_save[i][1], reg_base + reg_save[i][0]);\r\n}\r\nstatic int s5pv210_audss_clk_probe(struct platform_device *pdev)\r\n{\r\nint i, ret = 0;\r\nstruct resource *res;\r\nconst char *mout_audss_p[2];\r\nconst char *mout_i2s_p[3];\r\nconst char *hclk_p;\r\nstruct clk *hclk, *pll_ref, *pll_in, *cdclk, *sclk_audio;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nreg_base = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(reg_base)) {\r\ndev_err(&pdev->dev, "failed to map audss registers\n");\r\nreturn PTR_ERR(reg_base);\r\n}\r\nclk_table = devm_kzalloc(&pdev->dev,\r\nsizeof(struct clk *) * AUDSS_MAX_CLKS,\r\nGFP_KERNEL);\r\nif (!clk_table)\r\nreturn -ENOMEM;\r\nclk_data.clks = clk_table;\r\nclk_data.clk_num = AUDSS_MAX_CLKS;\r\nhclk = devm_clk_get(&pdev->dev, "hclk");\r\nif (IS_ERR(hclk)) {\r\ndev_err(&pdev->dev, "failed to get hclk clock\n");\r\nreturn PTR_ERR(hclk);\r\n}\r\npll_in = devm_clk_get(&pdev->dev, "fout_epll");\r\nif (IS_ERR(pll_in)) {\r\ndev_err(&pdev->dev, "failed to get fout_epll clock\n");\r\nreturn PTR_ERR(pll_in);\r\n}\r\nsclk_audio = devm_clk_get(&pdev->dev, "sclk_audio0");\r\nif (IS_ERR(sclk_audio)) {\r\ndev_err(&pdev->dev, "failed to get sclk_audio0 clock\n");\r\nreturn PTR_ERR(sclk_audio);\r\n}\r\ncdclk = devm_clk_get(&pdev->dev, "iiscdclk0");\r\npll_ref = devm_clk_get(&pdev->dev, "xxti");\r\nif (!IS_ERR(pll_ref))\r\nmout_audss_p[0] = __clk_get_name(pll_ref);\r\nelse\r\nmout_audss_p[0] = "xxti";\r\nmout_audss_p[1] = __clk_get_name(pll_in);\r\nclk_table[CLK_MOUT_AUDSS] = clk_register_mux(NULL, "mout_audss",\r\nmout_audss_p, ARRAY_SIZE(mout_audss_p),\r\nCLK_SET_RATE_NO_REPARENT,\r\nreg_base + ASS_CLK_SRC, 0, 1, 0, &lock);\r\nmout_i2s_p[0] = "mout_audss";\r\nif (!IS_ERR(cdclk))\r\nmout_i2s_p[1] = __clk_get_name(cdclk);\r\nelse\r\nmout_i2s_p[1] = "iiscdclk0";\r\nmout_i2s_p[2] = __clk_get_name(sclk_audio);\r\nclk_table[CLK_MOUT_I2S_A] = clk_register_mux(NULL, "mout_i2s_audss",\r\nmout_i2s_p, ARRAY_SIZE(mout_i2s_p),\r\nCLK_SET_RATE_NO_REPARENT,\r\nreg_base + ASS_CLK_SRC, 2, 2, 0, &lock);\r\nclk_table[CLK_DOUT_AUD_BUS] = clk_register_divider(NULL,\r\n"dout_aud_bus", "mout_audss", 0,\r\nreg_base + ASS_CLK_DIV, 0, 4, 0, &lock);\r\nclk_table[CLK_DOUT_I2S_A] = clk_register_divider(NULL, "dout_i2s_audss",\r\n"mout_i2s_audss", 0, reg_base + ASS_CLK_DIV,\r\n4, 4, 0, &lock);\r\nclk_table[CLK_I2S] = clk_register_gate(NULL, "i2s_audss",\r\n"dout_i2s_audss", CLK_SET_RATE_PARENT,\r\nreg_base + ASS_CLK_GATE, 6, 0, &lock);\r\nhclk_p = __clk_get_name(hclk);\r\nclk_table[CLK_HCLK_I2S] = clk_register_gate(NULL, "hclk_i2s_audss",\r\nhclk_p, CLK_IGNORE_UNUSED,\r\nreg_base + ASS_CLK_GATE, 5, 0, &lock);\r\nclk_table[CLK_HCLK_UART] = clk_register_gate(NULL, "hclk_uart_audss",\r\nhclk_p, CLK_IGNORE_UNUSED,\r\nreg_base + ASS_CLK_GATE, 4, 0, &lock);\r\nclk_table[CLK_HCLK_HWA] = clk_register_gate(NULL, "hclk_hwa_audss",\r\nhclk_p, CLK_IGNORE_UNUSED,\r\nreg_base + ASS_CLK_GATE, 3, 0, &lock);\r\nclk_table[CLK_HCLK_DMA] = clk_register_gate(NULL, "hclk_dma_audss",\r\nhclk_p, CLK_IGNORE_UNUSED,\r\nreg_base + ASS_CLK_GATE, 2, 0, &lock);\r\nclk_table[CLK_HCLK_BUF] = clk_register_gate(NULL, "hclk_buf_audss",\r\nhclk_p, CLK_IGNORE_UNUSED,\r\nreg_base + ASS_CLK_GATE, 1, 0, &lock);\r\nclk_table[CLK_HCLK_RP] = clk_register_gate(NULL, "hclk_rp_audss",\r\nhclk_p, CLK_IGNORE_UNUSED,\r\nreg_base + ASS_CLK_GATE, 0, 0, &lock);\r\nfor (i = 0; i < clk_data.clk_num; i++) {\r\nif (IS_ERR(clk_table[i])) {\r\ndev_err(&pdev->dev, "failed to register clock %d\n", i);\r\nret = PTR_ERR(clk_table[i]);\r\ngoto unregister;\r\n}\r\n}\r\nret = of_clk_add_provider(pdev->dev.of_node, of_clk_src_onecell_get,\r\n&clk_data);\r\nif (ret) {\r\ndev_err(&pdev->dev, "failed to add clock provider\n");\r\ngoto unregister;\r\n}\r\n#ifdef CONFIG_PM_SLEEP\r\nregister_syscore_ops(&s5pv210_audss_clk_syscore_ops);\r\n#endif\r\nreturn 0;\r\nunregister:\r\nfor (i = 0; i < clk_data.clk_num; i++) {\r\nif (!IS_ERR(clk_table[i]))\r\nclk_unregister(clk_table[i]);\r\n}\r\nreturn ret;\r\n}\r\nstatic int s5pv210_audss_clk_remove(struct platform_device *pdev)\r\n{\r\nint i;\r\nof_clk_del_provider(pdev->dev.of_node);\r\nfor (i = 0; i < clk_data.clk_num; i++) {\r\nif (!IS_ERR(clk_table[i]))\r\nclk_unregister(clk_table[i]);\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init s5pv210_audss_clk_init(void)\r\n{\r\nreturn platform_driver_register(&s5pv210_audss_clk_driver);\r\n}\r\nstatic void __exit s5pv210_audss_clk_exit(void)\r\n{\r\nplatform_driver_unregister(&s5pv210_audss_clk_driver);\r\n}
