static bool aic31xx_volatile(struct device *dev, unsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase AIC31XX_PAGECTL:\r\ncase AIC31XX_RESET:\r\ncase AIC31XX_OT_FLAG:\r\ncase AIC31XX_ADCFLAG:\r\ncase AIC31XX_DACFLAG1:\r\ncase AIC31XX_DACFLAG2:\r\ncase AIC31XX_OFFLAG:\r\ncase AIC31XX_INTRDACFLAG:\r\ncase AIC31XX_INTRADCFLAG:\r\ncase AIC31XX_INTRDACFLAG2:\r\ncase AIC31XX_INTRADCFLAG2:\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic bool aic31xx_writeable(struct device *dev, unsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase AIC31XX_OT_FLAG:\r\ncase AIC31XX_ADCFLAG:\r\ncase AIC31XX_DACFLAG1:\r\ncase AIC31XX_DACFLAG2:\r\ncase AIC31XX_OFFLAG:\r\ncase AIC31XX_INTRDACFLAG:\r\ncase AIC31XX_INTRADCFLAG:\r\ncase AIC31XX_INTRDACFLAG2:\r\ncase AIC31XX_INTRADCFLAG2:\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\nstatic int aic31xx_wait_bits(struct aic31xx_priv *aic31xx, unsigned int reg,\r\nunsigned int mask, unsigned int wbits, int sleep,\r\nint count)\r\n{\r\nunsigned int bits;\r\nint counter = count;\r\nint ret = regmap_read(aic31xx->regmap, reg, &bits);\r\nwhile ((bits & mask) != wbits && counter && !ret) {\r\nusleep_range(sleep, sleep * 2);\r\nret = regmap_read(aic31xx->regmap, reg, &bits);\r\ncounter--;\r\n}\r\nif ((bits & mask) != wbits) {\r\ndev_err(aic31xx->dev,\r\n"%s: Failed! 0x%x was 0x%x expected 0x%x (%d, 0x%x, %d us)\n",\r\n__func__, reg, bits, wbits, ret, mask,\r\n(count - counter) * sleep);\r\nret = -1;\r\n}\r\nreturn ret;\r\n}\r\nstatic int aic31xx_dapm_power_event(struct snd_soc_dapm_widget *w,\r\nstruct snd_kcontrol *kcontrol, int event)\r\n{\r\nstruct snd_soc_codec *codec = snd_soc_dapm_to_codec(w->dapm);\r\nstruct aic31xx_priv *aic31xx = snd_soc_codec_get_drvdata(codec);\r\nunsigned int reg = AIC31XX_DACFLAG1;\r\nunsigned int mask;\r\nswitch (WIDGET_BIT(w->reg, w->shift)) {\r\ncase WIDGET_BIT(AIC31XX_DACSETUP, 7):\r\nmask = AIC31XX_LDACPWRSTATUS_MASK;\r\nbreak;\r\ncase WIDGET_BIT(AIC31XX_DACSETUP, 6):\r\nmask = AIC31XX_RDACPWRSTATUS_MASK;\r\nbreak;\r\ncase WIDGET_BIT(AIC31XX_HPDRIVER, 7):\r\nmask = AIC31XX_HPLDRVPWRSTATUS_MASK;\r\nbreak;\r\ncase WIDGET_BIT(AIC31XX_HPDRIVER, 6):\r\nmask = AIC31XX_HPRDRVPWRSTATUS_MASK;\r\nbreak;\r\ncase WIDGET_BIT(AIC31XX_SPKAMP, 7):\r\nmask = AIC31XX_SPLDRVPWRSTATUS_MASK;\r\nbreak;\r\ncase WIDGET_BIT(AIC31XX_SPKAMP, 6):\r\nmask = AIC31XX_SPRDRVPWRSTATUS_MASK;\r\nbreak;\r\ncase WIDGET_BIT(AIC31XX_ADCSETUP, 7):\r\nmask = AIC31XX_ADCPWRSTATUS_MASK;\r\nreg = AIC31XX_ADCFLAG;\r\nbreak;\r\ndefault:\r\ndev_err(codec->dev, "Unknown widget '%s' calling %s\n",\r\nw->name, __func__);\r\nreturn -EINVAL;\r\n}\r\nswitch (event) {\r\ncase SND_SOC_DAPM_POST_PMU:\r\nreturn aic31xx_wait_bits(aic31xx, reg, mask, mask, 5000, 100);\r\ncase SND_SOC_DAPM_POST_PMD:\r\nreturn aic31xx_wait_bits(aic31xx, reg, mask, 0, 5000, 100);\r\ndefault:\r\ndev_dbg(codec->dev,\r\n"Unhandled dapm widget event %d from %s\n",\r\nevent, w->name);\r\n}\r\nreturn 0;\r\n}\r\nstatic int mic_bias_event(struct snd_soc_dapm_widget *w,\r\nstruct snd_kcontrol *kcontrol, int event)\r\n{\r\nstruct snd_soc_codec *codec = snd_soc_dapm_to_codec(w->dapm);\r\nstruct aic31xx_priv *aic31xx = snd_soc_codec_get_drvdata(codec);\r\nswitch (event) {\r\ncase SND_SOC_DAPM_POST_PMU:\r\nsnd_soc_update_bits(codec, AIC31XX_MICBIAS,\r\nAIC31XX_MICBIAS_MASK,\r\naic31xx->pdata.micbias_vg <<\r\nAIC31XX_MICBIAS_SHIFT);\r\ndev_dbg(codec->dev, "%s: turned on\n", __func__);\r\nbreak;\r\ncase SND_SOC_DAPM_PRE_PMD:\r\nsnd_soc_update_bits(codec, AIC31XX_MICBIAS,\r\nAIC31XX_MICBIAS_MASK, 0);\r\ndev_dbg(codec->dev, "%s: turned off\n", __func__);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int aic31xx_add_controls(struct snd_soc_codec *codec)\r\n{\r\nint ret = 0;\r\nstruct aic31xx_priv *aic31xx = snd_soc_codec_get_drvdata(codec);\r\nif (aic31xx->pdata.codec_type & AIC31XX_STEREO_CLASS_D_BIT)\r\nret = snd_soc_add_codec_controls(\r\ncodec, aic311x_snd_controls,\r\nARRAY_SIZE(aic311x_snd_controls));\r\nelse\r\nret = snd_soc_add_codec_controls(\r\ncodec, aic310x_snd_controls,\r\nARRAY_SIZE(aic310x_snd_controls));\r\nreturn ret;\r\n}\r\nstatic int aic31xx_add_widgets(struct snd_soc_codec *codec)\r\n{\r\nstruct snd_soc_dapm_context *dapm = &codec->dapm;\r\nstruct aic31xx_priv *aic31xx = snd_soc_codec_get_drvdata(codec);\r\nint ret = 0;\r\nif (aic31xx->pdata.codec_type & AIC31XX_STEREO_CLASS_D_BIT) {\r\nret = snd_soc_dapm_new_controls(\r\ndapm, aic311x_dapm_widgets,\r\nARRAY_SIZE(aic311x_dapm_widgets));\r\nif (ret)\r\nreturn ret;\r\nret = snd_soc_dapm_add_routes(dapm, aic311x_audio_map,\r\nARRAY_SIZE(aic311x_audio_map));\r\nif (ret)\r\nreturn ret;\r\n} else {\r\nret = snd_soc_dapm_new_controls(\r\ndapm, aic310x_dapm_widgets,\r\nARRAY_SIZE(aic310x_dapm_widgets));\r\nif (ret)\r\nreturn ret;\r\nret = snd_soc_dapm_add_routes(dapm, aic310x_audio_map,\r\nARRAY_SIZE(aic310x_audio_map));\r\nif (ret)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int aic31xx_setup_pll(struct snd_soc_codec *codec,\r\nstruct snd_pcm_hw_params *params)\r\n{\r\nstruct aic31xx_priv *aic31xx = snd_soc_codec_get_drvdata(codec);\r\nint bclk_score = snd_soc_params_to_frame_size(params);\r\nint mclk_p = aic31xx->sysclk / aic31xx->p_div;\r\nint bclk_n = 0;\r\nint match = -1;\r\nint i;\r\nsnd_soc_update_bits(codec, AIC31XX_CLKMUX,\r\nAIC31XX_CODEC_CLKIN_MASK, AIC31XX_CODEC_CLKIN_PLL);\r\nsnd_soc_update_bits(codec, AIC31XX_IFACE2,\r\nAIC31XX_BDIVCLK_MASK, AIC31XX_DAC2BCLK);\r\nfor (i = 0; i < ARRAY_SIZE(aic31xx_divs); i++) {\r\nif (aic31xx_divs[i].rate == params_rate(params) &&\r\naic31xx_divs[i].mclk_p == mclk_p) {\r\nint s = (aic31xx_divs[i].dosr * aic31xx_divs[i].mdac) %\r\nsnd_soc_params_to_frame_size(params);\r\nint bn = (aic31xx_divs[i].dosr * aic31xx_divs[i].mdac) /\r\nsnd_soc_params_to_frame_size(params);\r\nif (s < bclk_score && bn > 0) {\r\nmatch = i;\r\nbclk_n = bn;\r\nbclk_score = s;\r\n}\r\n}\r\n}\r\nif (match == -1) {\r\ndev_err(codec->dev,\r\n"%s: Sample rate (%u) and format not supported\n",\r\n__func__, params_rate(params));\r\nreturn -EINVAL;\r\n}\r\nif (bclk_score != 0) {\r\ndev_warn(codec->dev, "Can not produce exact bitclock");\r\n}\r\ni = match;\r\nsnd_soc_update_bits(codec, AIC31XX_PLLPR, AIC31XX_PLL_MASK,\r\n(aic31xx->p_div << 4) | 0x01);\r\nsnd_soc_write(codec, AIC31XX_PLLJ, aic31xx_divs[i].pll_j);\r\nsnd_soc_write(codec, AIC31XX_PLLDMSB,\r\naic31xx_divs[i].pll_d >> 8);\r\nsnd_soc_write(codec, AIC31XX_PLLDLSB,\r\naic31xx_divs[i].pll_d & 0xff);\r\nsnd_soc_update_bits(codec, AIC31XX_NDAC, AIC31XX_PLL_MASK,\r\naic31xx_divs[i].ndac);\r\nsnd_soc_update_bits(codec, AIC31XX_MDAC, AIC31XX_PLL_MASK,\r\naic31xx_divs[i].mdac);\r\nsnd_soc_write(codec, AIC31XX_DOSRMSB, aic31xx_divs[i].dosr >> 8);\r\nsnd_soc_write(codec, AIC31XX_DOSRLSB, aic31xx_divs[i].dosr & 0xff);\r\nsnd_soc_update_bits(codec, AIC31XX_NADC, AIC31XX_PLL_MASK,\r\naic31xx_divs[i].nadc ? aic31xx_divs[i].nadc : 1);\r\nsnd_soc_update_bits(codec, AIC31XX_MADC, AIC31XX_PLL_MASK,\r\naic31xx_divs[i].madc ? aic31xx_divs[i].madc : 1);\r\nsnd_soc_write(codec, AIC31XX_AOSR, aic31xx_divs[i].aosr);\r\nsnd_soc_update_bits(codec, AIC31XX_BCLKN,\r\nAIC31XX_PLL_MASK, bclk_n);\r\naic31xx->rate_div_line = i;\r\ndev_dbg(codec->dev,\r\n"pll %d.%04d/%d dosr %d n %d m %d aosr %d n %d m %d bclk_n %d\n",\r\naic31xx_divs[i].pll_j, aic31xx_divs[i].pll_d,\r\naic31xx->p_div, aic31xx_divs[i].dosr,\r\naic31xx_divs[i].ndac, aic31xx_divs[i].mdac,\r\naic31xx_divs[i].aosr, aic31xx_divs[i].nadc,\r\naic31xx_divs[i].madc, bclk_n);\r\nreturn 0;\r\n}\r\nstatic int aic31xx_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nu8 data = 0;\r\ndev_dbg(codec->dev, "## %s: width %d rate %d\n",\r\n__func__, params_width(params),\r\nparams_rate(params));\r\nswitch (params_width(params)) {\r\ncase 16:\r\nbreak;\r\ncase 20:\r\ndata = (AIC31XX_WORD_LEN_20BITS <<\r\nAIC31XX_IFACE1_DATALEN_SHIFT);\r\nbreak;\r\ncase 24:\r\ndata = (AIC31XX_WORD_LEN_24BITS <<\r\nAIC31XX_IFACE1_DATALEN_SHIFT);\r\nbreak;\r\ncase 32:\r\ndata = (AIC31XX_WORD_LEN_32BITS <<\r\nAIC31XX_IFACE1_DATALEN_SHIFT);\r\nbreak;\r\ndefault:\r\ndev_err(codec->dev, "%s: Unsupported width %d\n",\r\n__func__, params_width(params));\r\nreturn -EINVAL;\r\n}\r\nsnd_soc_update_bits(codec, AIC31XX_IFACE1,\r\nAIC31XX_IFACE1_DATALEN_MASK,\r\ndata);\r\nreturn aic31xx_setup_pll(codec, params);\r\n}\r\nstatic int aic31xx_dac_mute(struct snd_soc_dai *codec_dai, int mute)\r\n{\r\nstruct snd_soc_codec *codec = codec_dai->codec;\r\nif (mute) {\r\nsnd_soc_update_bits(codec, AIC31XX_DACMUTE,\r\nAIC31XX_DACMUTE_MASK,\r\nAIC31XX_DACMUTE_MASK);\r\n} else {\r\nsnd_soc_update_bits(codec, AIC31XX_DACMUTE,\r\nAIC31XX_DACMUTE_MASK, 0x0);\r\n}\r\nreturn 0;\r\n}\r\nstatic int aic31xx_set_dai_fmt(struct snd_soc_dai *codec_dai,\r\nunsigned int fmt)\r\n{\r\nstruct snd_soc_codec *codec = codec_dai->codec;\r\nu8 iface_reg1 = 0;\r\nu8 iface_reg2 = 0;\r\nu8 dsp_a_val = 0;\r\ndev_dbg(codec->dev, "## %s: fmt = 0x%x\n", __func__, fmt);\r\nswitch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {\r\ncase SND_SOC_DAIFMT_CBM_CFM:\r\niface_reg1 |= AIC31XX_BCLK_MASTER | AIC31XX_WCLK_MASTER;\r\nbreak;\r\ndefault:\r\ndev_alert(codec->dev, "Invalid DAI master/slave interface\n");\r\nreturn -EINVAL;\r\n}\r\nswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\r\ncase SND_SOC_DAIFMT_I2S:\r\nbreak;\r\ncase SND_SOC_DAIFMT_DSP_A:\r\ndsp_a_val = 0x1;\r\ncase SND_SOC_DAIFMT_DSP_B:\r\nswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\r\ncase SND_SOC_DAIFMT_NB_NF:\r\niface_reg2 |= AIC31XX_BCLKINV_MASK;\r\nbreak;\r\ncase SND_SOC_DAIFMT_IB_NF:\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\niface_reg1 |= (AIC31XX_DSP_MODE <<\r\nAIC31XX_IFACE1_DATATYPE_SHIFT);\r\nbreak;\r\ncase SND_SOC_DAIFMT_RIGHT_J:\r\niface_reg1 |= (AIC31XX_RIGHT_JUSTIFIED_MODE <<\r\nAIC31XX_IFACE1_DATATYPE_SHIFT);\r\nbreak;\r\ncase SND_SOC_DAIFMT_LEFT_J:\r\niface_reg1 |= (AIC31XX_LEFT_JUSTIFIED_MODE <<\r\nAIC31XX_IFACE1_DATATYPE_SHIFT);\r\nbreak;\r\ndefault:\r\ndev_err(codec->dev, "Invalid DAI interface format\n");\r\nreturn -EINVAL;\r\n}\r\nsnd_soc_update_bits(codec, AIC31XX_IFACE1,\r\nAIC31XX_IFACE1_DATATYPE_MASK |\r\nAIC31XX_IFACE1_MASTER_MASK,\r\niface_reg1);\r\nsnd_soc_update_bits(codec, AIC31XX_DATA_OFFSET,\r\nAIC31XX_DATA_OFFSET_MASK,\r\ndsp_a_val);\r\nsnd_soc_update_bits(codec, AIC31XX_IFACE2,\r\nAIC31XX_BCLKINV_MASK,\r\niface_reg2);\r\nreturn 0;\r\n}\r\nstatic int aic31xx_set_dai_sysclk(struct snd_soc_dai *codec_dai,\r\nint clk_id, unsigned int freq, int dir)\r\n{\r\nstruct snd_soc_codec *codec = codec_dai->codec;\r\nstruct aic31xx_priv *aic31xx = snd_soc_codec_get_drvdata(codec);\r\nint i;\r\ndev_dbg(codec->dev, "## %s: clk_id = %d, freq = %d, dir = %d\n",\r\n__func__, clk_id, freq, dir);\r\nfor (i = 1; freq/i > 20000000 && i < 8; i++)\r\n;\r\nif (freq/i > 20000000) {\r\ndev_err(aic31xx->dev, "%s: Too high mclk frequency %u\n",\r\n__func__, freq);\r\nreturn -EINVAL;\r\n}\r\naic31xx->p_div = i;\r\nfor (i = 0; i < ARRAY_SIZE(aic31xx_divs) &&\r\naic31xx_divs[i].mclk_p != freq/aic31xx->p_div; i++)\r\n;\r\nif (i == ARRAY_SIZE(aic31xx_divs)) {\r\ndev_err(aic31xx->dev, "%s: Unsupported frequency %d\n",\r\n__func__, freq);\r\nreturn -EINVAL;\r\n}\r\nsnd_soc_update_bits(codec, AIC31XX_CLKMUX, AIC31XX_PLL_CLKIN_MASK,\r\nclk_id << AIC31XX_PLL_CLKIN_SHIFT);\r\naic31xx->sysclk = freq;\r\nreturn 0;\r\n}\r\nstatic int aic31xx_regulator_event(struct notifier_block *nb,\r\nunsigned long event, void *data)\r\n{\r\nstruct aic31xx_disable_nb *disable_nb =\r\ncontainer_of(nb, struct aic31xx_disable_nb, nb);\r\nstruct aic31xx_priv *aic31xx = disable_nb->aic31xx;\r\nif (event & REGULATOR_EVENT_DISABLE) {\r\nif (gpio_is_valid(aic31xx->pdata.gpio_reset))\r\ngpio_set_value(aic31xx->pdata.gpio_reset, 0);\r\nregcache_mark_dirty(aic31xx->regmap);\r\ndev_dbg(aic31xx->dev, "## %s: DISABLE received\n", __func__);\r\n}\r\nreturn 0;\r\n}\r\nstatic void aic31xx_clk_on(struct snd_soc_codec *codec)\r\n{\r\nstruct aic31xx_priv *aic31xx = snd_soc_codec_get_drvdata(codec);\r\nu8 mask = AIC31XX_PM_MASK;\r\nu8 on = AIC31XX_PM_MASK;\r\ndev_dbg(codec->dev, "codec clock -> on (rate %d)\n",\r\naic31xx_divs[aic31xx->rate_div_line].rate);\r\nsnd_soc_update_bits(codec, AIC31XX_PLLPR, mask, on);\r\nmdelay(10);\r\nsnd_soc_update_bits(codec, AIC31XX_NDAC, mask, on);\r\nsnd_soc_update_bits(codec, AIC31XX_MDAC, mask, on);\r\nif (aic31xx_divs[aic31xx->rate_div_line].nadc)\r\nsnd_soc_update_bits(codec, AIC31XX_NADC, mask, on);\r\nif (aic31xx_divs[aic31xx->rate_div_line].madc)\r\nsnd_soc_update_bits(codec, AIC31XX_MADC, mask, on);\r\nsnd_soc_update_bits(codec, AIC31XX_BCLKN, mask, on);\r\n}\r\nstatic void aic31xx_clk_off(struct snd_soc_codec *codec)\r\n{\r\nu8 mask = AIC31XX_PM_MASK;\r\nu8 off = 0;\r\ndev_dbg(codec->dev, "codec clock -> off\n");\r\nsnd_soc_update_bits(codec, AIC31XX_BCLKN, mask, off);\r\nsnd_soc_update_bits(codec, AIC31XX_MADC, mask, off);\r\nsnd_soc_update_bits(codec, AIC31XX_NADC, mask, off);\r\nsnd_soc_update_bits(codec, AIC31XX_MDAC, mask, off);\r\nsnd_soc_update_bits(codec, AIC31XX_NDAC, mask, off);\r\nsnd_soc_update_bits(codec, AIC31XX_PLLPR, mask, off);\r\n}\r\nstatic int aic31xx_power_on(struct snd_soc_codec *codec)\r\n{\r\nstruct aic31xx_priv *aic31xx = snd_soc_codec_get_drvdata(codec);\r\nint ret = 0;\r\nret = regulator_bulk_enable(ARRAY_SIZE(aic31xx->supplies),\r\naic31xx->supplies);\r\nif (ret)\r\nreturn ret;\r\nif (gpio_is_valid(aic31xx->pdata.gpio_reset)) {\r\ngpio_set_value(aic31xx->pdata.gpio_reset, 1);\r\nudelay(100);\r\n}\r\nregcache_cache_only(aic31xx->regmap, false);\r\nret = regcache_sync(aic31xx->regmap);\r\nif (ret != 0) {\r\ndev_err(codec->dev,\r\n"Failed to restore cache: %d\n", ret);\r\nregcache_cache_only(aic31xx->regmap, true);\r\nregulator_bulk_disable(ARRAY_SIZE(aic31xx->supplies),\r\naic31xx->supplies);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int aic31xx_power_off(struct snd_soc_codec *codec)\r\n{\r\nstruct aic31xx_priv *aic31xx = snd_soc_codec_get_drvdata(codec);\r\nint ret = 0;\r\nregcache_cache_only(aic31xx->regmap, true);\r\nret = regulator_bulk_disable(ARRAY_SIZE(aic31xx->supplies),\r\naic31xx->supplies);\r\nreturn ret;\r\n}\r\nstatic int aic31xx_set_bias_level(struct snd_soc_codec *codec,\r\nenum snd_soc_bias_level level)\r\n{\r\ndev_dbg(codec->dev, "## %s: %d -> %d\n", __func__,\r\ncodec->dapm.bias_level, level);\r\nswitch (level) {\r\ncase SND_SOC_BIAS_ON:\r\nbreak;\r\ncase SND_SOC_BIAS_PREPARE:\r\nif (codec->dapm.bias_level == SND_SOC_BIAS_STANDBY)\r\naic31xx_clk_on(codec);\r\nbreak;\r\ncase SND_SOC_BIAS_STANDBY:\r\nswitch (codec->dapm.bias_level) {\r\ncase SND_SOC_BIAS_OFF:\r\naic31xx_power_on(codec);\r\nbreak;\r\ncase SND_SOC_BIAS_PREPARE:\r\naic31xx_clk_off(codec);\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\nbreak;\r\ncase SND_SOC_BIAS_OFF:\r\nif (codec->dapm.bias_level == SND_SOC_BIAS_STANDBY)\r\naic31xx_power_off(codec);\r\nbreak;\r\n}\r\ncodec->dapm.bias_level = level;\r\nreturn 0;\r\n}\r\nstatic int aic31xx_codec_probe(struct snd_soc_codec *codec)\r\n{\r\nint ret = 0;\r\nstruct aic31xx_priv *aic31xx = snd_soc_codec_get_drvdata(codec);\r\nint i;\r\ndev_dbg(aic31xx->dev, "## %s\n", __func__);\r\naic31xx = snd_soc_codec_get_drvdata(codec);\r\naic31xx->codec = codec;\r\nfor (i = 0; i < ARRAY_SIZE(aic31xx->supplies); i++) {\r\naic31xx->disable_nb[i].nb.notifier_call =\r\naic31xx_regulator_event;\r\naic31xx->disable_nb[i].aic31xx = aic31xx;\r\nret = regulator_register_notifier(aic31xx->supplies[i].consumer,\r\n&aic31xx->disable_nb[i].nb);\r\nif (ret) {\r\ndev_err(codec->dev,\r\n"Failed to request regulator notifier: %d\n",\r\nret);\r\nreturn ret;\r\n}\r\n}\r\nregcache_cache_only(aic31xx->regmap, true);\r\nregcache_mark_dirty(aic31xx->regmap);\r\nret = aic31xx_add_controls(codec);\r\nif (ret)\r\nreturn ret;\r\nret = aic31xx_add_widgets(codec);\r\nreturn ret;\r\n}\r\nstatic int aic31xx_codec_remove(struct snd_soc_codec *codec)\r\n{\r\nstruct aic31xx_priv *aic31xx = snd_soc_codec_get_drvdata(codec);\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(aic31xx->supplies); i++)\r\nregulator_unregister_notifier(aic31xx->supplies[i].consumer,\r\n&aic31xx->disable_nb[i].nb);\r\nreturn 0;\r\n}\r\nstatic void aic31xx_pdata_from_of(struct aic31xx_priv *aic31xx)\r\n{\r\nstruct device_node *np = aic31xx->dev->of_node;\r\nunsigned int value = MICBIAS_2_0V;\r\nint ret;\r\nof_property_read_u32(np, "ai31xx-micbias-vg", &value);\r\nswitch (value) {\r\ncase MICBIAS_2_0V:\r\ncase MICBIAS_2_5V:\r\ncase MICBIAS_AVDDV:\r\naic31xx->pdata.micbias_vg = value;\r\nbreak;\r\ndefault:\r\ndev_err(aic31xx->dev,\r\n"Bad ai31xx-micbias-vg value %d DT\n",\r\nvalue);\r\naic31xx->pdata.micbias_vg = MICBIAS_2_0V;\r\n}\r\nret = of_get_named_gpio(np, "gpio-reset", 0);\r\nif (ret > 0)\r\naic31xx->pdata.gpio_reset = ret;\r\n}\r\nstatic void aic31xx_pdata_from_of(struct aic31xx_priv *aic31xx)\r\n{\r\n}\r\nstatic int aic31xx_device_init(struct aic31xx_priv *aic31xx)\r\n{\r\nint ret, i;\r\ndev_set_drvdata(aic31xx->dev, aic31xx);\r\nif (dev_get_platdata(aic31xx->dev))\r\nmemcpy(&aic31xx->pdata, dev_get_platdata(aic31xx->dev),\r\nsizeof(aic31xx->pdata));\r\nelse if (aic31xx->dev->of_node)\r\naic31xx_pdata_from_of(aic31xx);\r\nif (aic31xx->pdata.gpio_reset) {\r\nret = devm_gpio_request_one(aic31xx->dev,\r\naic31xx->pdata.gpio_reset,\r\nGPIOF_OUT_INIT_HIGH,\r\n"aic31xx-reset-pin");\r\nif (ret < 0) {\r\ndev_err(aic31xx->dev, "not able to acquire gpio\n");\r\nreturn ret;\r\n}\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(aic31xx->supplies); i++)\r\naic31xx->supplies[i].supply = aic31xx_supply_names[i];\r\nret = devm_regulator_bulk_get(aic31xx->dev,\r\nARRAY_SIZE(aic31xx->supplies),\r\naic31xx->supplies);\r\nif (ret != 0)\r\ndev_err(aic31xx->dev, "Failed to request supplies: %d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int aic31xx_i2c_probe(struct i2c_client *i2c,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct aic31xx_priv *aic31xx;\r\nint ret;\r\nconst struct regmap_config *regmap_config;\r\ndev_dbg(&i2c->dev, "## %s: %s codec_type = %d\n", __func__,\r\nid->name, (int) id->driver_data);\r\nregmap_config = &aic31xx_i2c_regmap;\r\naic31xx = devm_kzalloc(&i2c->dev, sizeof(*aic31xx), GFP_KERNEL);\r\nif (aic31xx == NULL)\r\nreturn -ENOMEM;\r\naic31xx->regmap = devm_regmap_init_i2c(i2c, regmap_config);\r\nif (IS_ERR(aic31xx->regmap)) {\r\nret = PTR_ERR(aic31xx->regmap);\r\ndev_err(&i2c->dev, "Failed to allocate register map: %d\n",\r\nret);\r\nreturn ret;\r\n}\r\naic31xx->dev = &i2c->dev;\r\naic31xx->pdata.codec_type = id->driver_data;\r\nret = aic31xx_device_init(aic31xx);\r\nif (ret)\r\nreturn ret;\r\nreturn snd_soc_register_codec(&i2c->dev, &soc_codec_driver_aic31xx,\r\naic31xx_dai_driver,\r\nARRAY_SIZE(aic31xx_dai_driver));\r\n}\r\nstatic int aic31xx_i2c_remove(struct i2c_client *i2c)\r\n{\r\nsnd_soc_unregister_codec(&i2c->dev);\r\nreturn 0;\r\n}
