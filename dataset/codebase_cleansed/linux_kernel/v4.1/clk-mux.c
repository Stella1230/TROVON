static u8 clk_mux_get_parent(struct clk_hw *hw)\r\n{\r\nstruct clk_mux *mux = to_clk_mux(hw);\r\nint num_parents = __clk_get_num_parents(hw->clk);\r\nu32 val;\r\nval = clk_readl(mux->reg) >> mux->shift;\r\nval &= mux->mask;\r\nif (mux->table) {\r\nint i;\r\nfor (i = 0; i < num_parents; i++)\r\nif (mux->table[i] == val)\r\nreturn i;\r\nreturn -EINVAL;\r\n}\r\nif (val && (mux->flags & CLK_MUX_INDEX_BIT))\r\nval = ffs(val) - 1;\r\nif (val && (mux->flags & CLK_MUX_INDEX_ONE))\r\nval--;\r\nif (val >= num_parents)\r\nreturn -EINVAL;\r\nreturn val;\r\n}\r\nstatic int clk_mux_set_parent(struct clk_hw *hw, u8 index)\r\n{\r\nstruct clk_mux *mux = to_clk_mux(hw);\r\nu32 val;\r\nunsigned long flags = 0;\r\nif (mux->table)\r\nindex = mux->table[index];\r\nelse {\r\nif (mux->flags & CLK_MUX_INDEX_BIT)\r\nindex = 1 << index;\r\nif (mux->flags & CLK_MUX_INDEX_ONE)\r\nindex++;\r\n}\r\nif (mux->lock)\r\nspin_lock_irqsave(mux->lock, flags);\r\nif (mux->flags & CLK_MUX_HIWORD_MASK) {\r\nval = mux->mask << (mux->shift + 16);\r\n} else {\r\nval = clk_readl(mux->reg);\r\nval &= ~(mux->mask << mux->shift);\r\n}\r\nval |= index << mux->shift;\r\nclk_writel(val, mux->reg);\r\nif (mux->lock)\r\nspin_unlock_irqrestore(mux->lock, flags);\r\nreturn 0;\r\n}\r\nstruct clk *clk_register_mux_table(struct device *dev, const char *name,\r\nconst char **parent_names, u8 num_parents, unsigned long flags,\r\nvoid __iomem *reg, u8 shift, u32 mask,\r\nu8 clk_mux_flags, u32 *table, spinlock_t *lock)\r\n{\r\nstruct clk_mux *mux;\r\nstruct clk *clk;\r\nstruct clk_init_data init;\r\nu8 width = 0;\r\nif (clk_mux_flags & CLK_MUX_HIWORD_MASK) {\r\nwidth = fls(mask) - ffs(mask) + 1;\r\nif (width + shift > 16) {\r\npr_err("mux value exceeds LOWORD field\n");\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\n}\r\nmux = kzalloc(sizeof(struct clk_mux), GFP_KERNEL);\r\nif (!mux) {\r\npr_err("%s: could not allocate mux clk\n", __func__);\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\ninit.name = name;\r\nif (clk_mux_flags & CLK_MUX_READ_ONLY)\r\ninit.ops = &clk_mux_ro_ops;\r\nelse\r\ninit.ops = &clk_mux_ops;\r\ninit.flags = flags | CLK_IS_BASIC;\r\ninit.parent_names = parent_names;\r\ninit.num_parents = num_parents;\r\nmux->reg = reg;\r\nmux->shift = shift;\r\nmux->mask = mask;\r\nmux->flags = clk_mux_flags;\r\nmux->lock = lock;\r\nmux->table = table;\r\nmux->hw.init = &init;\r\nclk = clk_register(dev, &mux->hw);\r\nif (IS_ERR(clk))\r\nkfree(mux);\r\nreturn clk;\r\n}\r\nstruct clk *clk_register_mux(struct device *dev, const char *name,\r\nconst char **parent_names, u8 num_parents, unsigned long flags,\r\nvoid __iomem *reg, u8 shift, u8 width,\r\nu8 clk_mux_flags, spinlock_t *lock)\r\n{\r\nu32 mask = BIT(width) - 1;\r\nreturn clk_register_mux_table(dev, name, parent_names, num_parents,\r\nflags, reg, shift, mask, clk_mux_flags,\r\nNULL, lock);\r\n}\r\nvoid clk_unregister_mux(struct clk *clk)\r\n{\r\nstruct clk_mux *mux;\r\nstruct clk_hw *hw;\r\nhw = __clk_get_hw(clk);\r\nif (!hw)\r\nreturn;\r\nmux = to_clk_mux(hw);\r\nclk_unregister(clk);\r\nkfree(mux);\r\n}
