static bool hip04_cluster_is_down(unsigned int cluster)\r\n{\r\nint i;\r\nfor (i = 0; i < HIP04_MAX_CPUS_PER_CLUSTER; i++)\r\nif (hip04_cpu_table[cluster][i])\r\nreturn false;\r\nreturn true;\r\n}\r\nstatic void hip04_set_snoop_filter(unsigned int cluster, unsigned int on)\r\n{\r\nunsigned long data;\r\nif (!fabric)\r\nBUG();\r\ndata = readl_relaxed(fabric + FAB_SF_MODE);\r\nif (on)\r\ndata |= 1 << cluster;\r\nelse\r\ndata &= ~(1 << cluster);\r\nwritel_relaxed(data, fabric + FAB_SF_MODE);\r\ndo {\r\ncpu_relax();\r\n} while (data != readl_relaxed(fabric + FAB_SF_MODE));\r\n}\r\nstatic int hip04_mcpm_power_up(unsigned int cpu, unsigned int cluster)\r\n{\r\nunsigned long data;\r\nvoid __iomem *sys_dreq, *sys_status;\r\nif (!sysctrl)\r\nreturn -ENODEV;\r\nif (cluster >= HIP04_MAX_CLUSTERS || cpu >= HIP04_MAX_CPUS_PER_CLUSTER)\r\nreturn -EINVAL;\r\nspin_lock_irq(&boot_lock);\r\nif (hip04_cpu_table[cluster][cpu])\r\ngoto out;\r\nsys_dreq = sysctrl + SC_CPU_RESET_DREQ(cluster);\r\nsys_status = sysctrl + SC_CPU_RESET_STATUS(cluster);\r\nif (hip04_cluster_is_down(cluster)) {\r\ndata = CLUSTER_DEBUG_RESET_BIT;\r\nwritel_relaxed(data, sys_dreq);\r\ndo {\r\ncpu_relax();\r\ndata = readl_relaxed(sys_status);\r\n} while (data & CLUSTER_DEBUG_RESET_STATUS);\r\n}\r\ndata = CORE_RESET_BIT(cpu) | NEON_RESET_BIT(cpu) | \\r\nCORE_DEBUG_RESET_BIT(cpu);\r\nwritel_relaxed(data, sys_dreq);\r\ndo {\r\ncpu_relax();\r\n} while (data == readl_relaxed(sys_status));\r\nudelay(20);\r\nout:\r\nhip04_cpu_table[cluster][cpu]++;\r\nspin_unlock_irq(&boot_lock);\r\nreturn 0;\r\n}\r\nstatic void hip04_mcpm_power_down(void)\r\n{\r\nunsigned int mpidr, cpu, cluster;\r\nbool skip_wfi = false, last_man = false;\r\nmpidr = read_cpuid_mpidr();\r\ncpu = MPIDR_AFFINITY_LEVEL(mpidr, 0);\r\ncluster = MPIDR_AFFINITY_LEVEL(mpidr, 1);\r\n__mcpm_cpu_going_down(cpu, cluster);\r\nspin_lock(&boot_lock);\r\nBUG_ON(__mcpm_cluster_state(cluster) != CLUSTER_UP);\r\nhip04_cpu_table[cluster][cpu]--;\r\nif (hip04_cpu_table[cluster][cpu] == 1) {\r\nskip_wfi = true;\r\n} else if (hip04_cpu_table[cluster][cpu] > 1) {\r\npr_err("Cluster %d CPU%d boots multiple times\n", cluster, cpu);\r\nBUG();\r\n}\r\nlast_man = hip04_cluster_is_down(cluster);\r\nif (last_man && __mcpm_outbound_enter_critical(cpu, cluster)) {\r\nspin_unlock(&boot_lock);\r\nasm volatile(\r\n"mcr p15, 1, %0, c15, c0, 3 \n\t"\r\n"isb \n\t"\r\n"dsb "\r\n: : "r" (0x400) );\r\nv7_exit_coherency_flush(all);\r\nhip04_set_snoop_filter(cluster, 0);\r\n__mcpm_outbound_leave_critical(cluster, CLUSTER_DOWN);\r\n} else {\r\nspin_unlock(&boot_lock);\r\nv7_exit_coherency_flush(louis);\r\n}\r\n__mcpm_cpu_down(cpu, cluster);\r\nif (!skip_wfi)\r\nwfi();\r\n}\r\nstatic int hip04_mcpm_wait_for_powerdown(unsigned int cpu, unsigned int cluster)\r\n{\r\nunsigned int data, tries, count;\r\nint ret = -ETIMEDOUT;\r\nBUG_ON(cluster >= HIP04_MAX_CLUSTERS ||\r\ncpu >= HIP04_MAX_CPUS_PER_CLUSTER);\r\ncount = TIMEOUT_MSEC / POLL_MSEC;\r\nspin_lock_irq(&boot_lock);\r\nfor (tries = 0; tries < count; tries++) {\r\nif (hip04_cpu_table[cluster][cpu]) {\r\nret = -EBUSY;\r\ngoto err;\r\n}\r\ncpu_relax();\r\ndata = readl_relaxed(sysctrl + SC_CPU_RESET_STATUS(cluster));\r\nif (data & CORE_WFI_STATUS(cpu))\r\nbreak;\r\nspin_unlock_irq(&boot_lock);\r\nmsleep(POLL_MSEC);\r\nspin_lock_irq(&boot_lock);\r\n}\r\nif (tries >= count)\r\ngoto err;\r\ndata = CORE_RESET_BIT(cpu) | NEON_RESET_BIT(cpu) | \\r\nCORE_DEBUG_RESET_BIT(cpu);\r\nwritel_relaxed(data, sysctrl + SC_CPU_RESET_REQ(cluster));\r\nfor (tries = 0; tries < count; tries++) {\r\ncpu_relax();\r\ndata = readl_relaxed(sysctrl + SC_CPU_RESET_STATUS(cluster));\r\nif (data & CORE_RESET_STATUS(cpu))\r\nbreak;\r\n}\r\nif (tries >= count)\r\ngoto err;\r\nspin_unlock_irq(&boot_lock);\r\nreturn 0;\r\nerr:\r\nspin_unlock_irq(&boot_lock);\r\nreturn ret;\r\n}\r\nstatic void hip04_mcpm_powered_up(void)\r\n{\r\nunsigned int mpidr, cpu, cluster;\r\nmpidr = read_cpuid_mpidr();\r\ncpu = MPIDR_AFFINITY_LEVEL(mpidr, 0);\r\ncluster = MPIDR_AFFINITY_LEVEL(mpidr, 1);\r\nspin_lock(&boot_lock);\r\nif (!hip04_cpu_table[cluster][cpu])\r\nhip04_cpu_table[cluster][cpu] = 1;\r\nspin_unlock(&boot_lock);\r\n}\r\nstatic void __naked hip04_mcpm_power_up_setup(unsigned int affinity_level)\r\n{\r\nasm volatile (" \n"\r\n" cmp r0, #0 \n"\r\n" bxeq lr \n"\r\n" adr r2, 2f \n"\r\n" ldmia r2, {r1, r3} \n"\r\n" sub r0, r2, r1 \n"\r\n" ldr r2, [r0, r3] \n"\r\n" mrc p15, 0, r0, c0, c0, 5 \n"\r\n" ubfx r1, r0, #8, #8 \n"\r\n" mov r0, #1 \n"\r\n" mov r3, r0, lsl r1 \n"\r\n" ldr r0, [r2, #"__stringify(FAB_SF_MODE)"] \n"\r\n" tst r0, r3 \n"\r\n" bxne lr \n"\r\n" orr r1, r0, r3 \n"\r\n" str r1, [r2, #"__stringify(FAB_SF_MODE)"] \n"\r\n"1: ldr r0, [r2, #"__stringify(FAB_SF_MODE)"] \n"\r\n" tst r0, r3 \n"\r\n" beq 1b \n"\r\n" bx lr \n"\r\n" .align 2 \n"\r\n"2: .word . \n"\r\n" .word fabric_phys_addr \n"\r\n);\r\n}\r\nstatic bool __init hip04_cpu_table_init(void)\r\n{\r\nunsigned int mpidr, cpu, cluster;\r\nmpidr = read_cpuid_mpidr();\r\ncpu = MPIDR_AFFINITY_LEVEL(mpidr, 0);\r\ncluster = MPIDR_AFFINITY_LEVEL(mpidr, 1);\r\nif (cluster >= HIP04_MAX_CLUSTERS ||\r\ncpu >= HIP04_MAX_CPUS_PER_CLUSTER) {\r\npr_err("%s: boot CPU is out of bound!\n", __func__);\r\nreturn false;\r\n}\r\nhip04_set_snoop_filter(cluster, 1);\r\nhip04_cpu_table[cluster][cpu] = 1;\r\nreturn true;\r\n}\r\nstatic int __init hip04_mcpm_init(void)\r\n{\r\nstruct device_node *np, *np_sctl, *np_fab;\r\nstruct resource fab_res;\r\nvoid __iomem *relocation;\r\nint ret = -ENODEV;\r\nnp = of_find_compatible_node(NULL, NULL, "hisilicon,hip04-bootwrapper");\r\nif (!np)\r\ngoto err;\r\nret = of_property_read_u32_array(np, "boot-method",\r\n&hip04_boot_method[0], 4);\r\nif (ret)\r\ngoto err;\r\nnp_sctl = of_find_compatible_node(NULL, NULL, "hisilicon,sysctrl");\r\nif (!np_sctl)\r\ngoto err;\r\nnp_fab = of_find_compatible_node(NULL, NULL, "hisilicon,hip04-fabric");\r\nif (!np_fab)\r\ngoto err;\r\nret = memblock_reserve(hip04_boot_method[0], hip04_boot_method[1]);\r\nif (ret)\r\ngoto err;\r\nrelocation = ioremap(hip04_boot_method[2], hip04_boot_method[3]);\r\nif (!relocation) {\r\npr_err("failed to map relocation space\n");\r\nret = -ENOMEM;\r\ngoto err_reloc;\r\n}\r\nsysctrl = of_iomap(np_sctl, 0);\r\nif (!sysctrl) {\r\npr_err("failed to get sysctrl base\n");\r\nret = -ENOMEM;\r\ngoto err_sysctrl;\r\n}\r\nret = of_address_to_resource(np_fab, 0, &fab_res);\r\nif (ret) {\r\npr_err("failed to get fabric base phys\n");\r\ngoto err_fabric;\r\n}\r\nfabric_phys_addr = fab_res.start;\r\nsync_cache_w(&fabric_phys_addr);\r\nfabric = of_iomap(np_fab, 0);\r\nif (!fabric) {\r\npr_err("failed to get fabric base\n");\r\nret = -ENOMEM;\r\ngoto err_fabric;\r\n}\r\nif (!hip04_cpu_table_init()) {\r\nret = -EINVAL;\r\ngoto err_table;\r\n}\r\nret = mcpm_platform_register(&hip04_mcpm_ops);\r\nif (ret) {\r\ngoto err_table;\r\n}\r\nwritel_relaxed(hip04_boot_method[0], relocation);\r\nwritel_relaxed(0xa5a5a5a5, relocation + 4);\r\nwritel_relaxed(virt_to_phys(mcpm_entry_point), relocation + 8);\r\nwritel_relaxed(0, relocation + 12);\r\niounmap(relocation);\r\nmcpm_sync_init(hip04_mcpm_power_up_setup);\r\nmcpm_smp_set_ops();\r\npr_info("HiP04 MCPM initialized\n");\r\nreturn ret;\r\nerr_table:\r\niounmap(fabric);\r\nerr_fabric:\r\niounmap(sysctrl);\r\nerr_sysctrl:\r\niounmap(relocation);\r\nerr_reloc:\r\nmemblock_free(hip04_boot_method[0], hip04_boot_method[1]);\r\nerr:\r\nreturn ret;\r\n}
