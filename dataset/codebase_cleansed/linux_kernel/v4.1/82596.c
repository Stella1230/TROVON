static inline void CA(struct net_device *dev)\r\n{\r\n#ifdef ENABLE_MVME16x_NET\r\nif (MACH_IS_MVME16x) {\r\n((struct i596_reg *) dev->base_addr)->ca = 1;\r\n}\r\n#endif\r\n#ifdef ENABLE_BVME6000_NET\r\nif (MACH_IS_BVME6000) {\r\nvolatile u32 i;\r\ni = *(volatile u32 *) (dev->base_addr);\r\n}\r\n#endif\r\n}\r\nstatic inline void MPU_PORT(struct net_device *dev, int c, volatile void *x)\r\n{\r\n#ifdef ENABLE_MVME16x_NET\r\nif (MACH_IS_MVME16x) {\r\nstruct i596_reg *p = (struct i596_reg *) (dev->base_addr);\r\np->porthi = ((c) | (u32) (x)) & 0xffff;\r\np->portlo = ((c) | (u32) (x)) >> 16;\r\n}\r\n#endif\r\n#ifdef ENABLE_BVME6000_NET\r\nif (MACH_IS_BVME6000) {\r\nu32 v = (u32) (c) | (u32) (x);\r\nv = ((u32) (v) << 16) | ((u32) (v) >> 16);\r\n*(volatile u32 *) dev->base_addr = v;\r\nudelay(1);\r\n*(volatile u32 *) dev->base_addr = v;\r\n}\r\n#endif\r\n}\r\nstatic inline int wait_istat(struct net_device *dev, struct i596_private *lp, int delcnt, char *str)\r\n{\r\nwhile (--delcnt && lp->iscp.stat)\r\nudelay(10);\r\nif (!delcnt) {\r\nprintk(KERN_ERR "%s: %s, status %4.4x, cmd %4.4x.\n",\r\ndev->name, str, lp->scb.status, lp->scb.command);\r\nreturn -1;\r\n}\r\nelse\r\nreturn 0;\r\n}\r\nstatic inline int wait_cmd(struct net_device *dev, struct i596_private *lp, int delcnt, char *str)\r\n{\r\nwhile (--delcnt && lp->scb.command)\r\nudelay(10);\r\nif (!delcnt) {\r\nprintk(KERN_ERR "%s: %s, status %4.4x, cmd %4.4x.\n",\r\ndev->name, str, lp->scb.status, lp->scb.command);\r\nreturn -1;\r\n}\r\nelse\r\nreturn 0;\r\n}\r\nstatic inline int wait_cfg(struct net_device *dev, struct i596_cmd *cmd, int delcnt, char *str)\r\n{\r\nvolatile struct i596_cmd *c = cmd;\r\nwhile (--delcnt && c->command)\r\nudelay(10);\r\nif (!delcnt) {\r\nprintk(KERN_ERR "%s: %s.\n", dev->name, str);\r\nreturn -1;\r\n}\r\nelse\r\nreturn 0;\r\n}\r\nstatic void i596_display_data(struct net_device *dev)\r\n{\r\nstruct i596_private *lp = dev->ml_priv;\r\nstruct i596_cmd *cmd;\r\nstruct i596_rfd *rfd;\r\nstruct i596_rbd *rbd;\r\nprintk(KERN_ERR "lp and scp at %p, .sysbus = %08lx, .iscp = %p\n",\r\n&lp->scp, lp->scp.sysbus, lp->scp.iscp);\r\nprintk(KERN_ERR "iscp at %p, iscp.stat = %08lx, .scb = %p\n",\r\n&lp->iscp, lp->iscp.stat, lp->iscp.scb);\r\nprintk(KERN_ERR "scb at %p, scb.status = %04x, .command = %04x,"\r\n" .cmd = %p, .rfd = %p\n",\r\n&lp->scb, lp->scb.status, lp->scb.command,\r\nlp->scb.cmd, lp->scb.rfd);\r\nprintk(KERN_ERR " errors: crc %lx, align %lx, resource %lx,"\r\n" over %lx, rcvdt %lx, short %lx\n",\r\nlp->scb.crc_err, lp->scb.align_err, lp->scb.resource_err,\r\nlp->scb.over_err, lp->scb.rcvdt_err, lp->scb.short_err);\r\ncmd = lp->cmd_head;\r\nwhile (cmd != I596_NULL) {\r\nprintk(KERN_ERR "cmd at %p, .status = %04x, .command = %04x, .b_next = %p\n",\r\ncmd, cmd->status, cmd->command, cmd->b_next);\r\ncmd = cmd->v_next;\r\n}\r\nrfd = lp->rfd_head;\r\nprintk(KERN_ERR "rfd_head = %p\n", rfd);\r\ndo {\r\nprintk(KERN_ERR " %p .stat %04x, .cmd %04x, b_next %p, rbd %p,"\r\n" count %04x\n",\r\nrfd, rfd->stat, rfd->cmd, rfd->b_next, rfd->rbd,\r\nrfd->count);\r\nrfd = rfd->v_next;\r\n} while (rfd != lp->rfd_head);\r\nrbd = lp->rbd_head;\r\nprintk(KERN_ERR "rbd_head = %p\n", rbd);\r\ndo {\r\nprintk(KERN_ERR " %p .count %04x, b_next %p, b_data %p, size %04x\n",\r\nrbd, rbd->count, rbd->b_next, rbd->b_data, rbd->size);\r\nrbd = rbd->v_next;\r\n} while (rbd != lp->rbd_head);\r\n}\r\nstatic irqreturn_t i596_error(int irq, void *dev_id)\r\n{\r\nstruct net_device *dev = dev_id;\r\n#ifdef ENABLE_MVME16x_NET\r\nif (MACH_IS_MVME16x) {\r\nvolatile unsigned char *pcc2 = (unsigned char *) 0xfff42000;\r\npcc2[0x28] = 1;\r\npcc2[0x2b] = 0x1d;\r\n}\r\n#endif\r\n#ifdef ENABLE_BVME6000_NET\r\nif (MACH_IS_BVME6000) {\r\nvolatile unsigned char *ethirq = (unsigned char *) BVME_ETHIRQ_REG;\r\n*ethirq = 1;\r\n*ethirq = 3;\r\n}\r\n#endif\r\nprintk(KERN_ERR "%s: Error interrupt\n", dev->name);\r\ni596_display_data(dev);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic inline void remove_rx_bufs(struct net_device *dev)\r\n{\r\nstruct i596_private *lp = dev->ml_priv;\r\nstruct i596_rbd *rbd;\r\nint i;\r\nfor (i = 0, rbd = lp->rbds; i < rx_ring_size; i++, rbd++) {\r\nif (rbd->skb == NULL)\r\nbreak;\r\ndev_kfree_skb(rbd->skb);\r\nrbd->skb = NULL;\r\n}\r\n}\r\nstatic inline int init_rx_bufs(struct net_device *dev)\r\n{\r\nstruct i596_private *lp = dev->ml_priv;\r\nint i;\r\nstruct i596_rfd *rfd;\r\nstruct i596_rbd *rbd;\r\nfor (i = 0, rbd = lp->rbds; i < rx_ring_size; i++, rbd++) {\r\nstruct sk_buff *skb = netdev_alloc_skb(dev, PKT_BUF_SZ);\r\nif (skb == NULL) {\r\nremove_rx_bufs(dev);\r\nreturn -ENOMEM;\r\n}\r\nrbd->v_next = rbd+1;\r\nrbd->b_next = WSWAPrbd(virt_to_bus(rbd+1));\r\nrbd->b_addr = WSWAPrbd(virt_to_bus(rbd));\r\nrbd->skb = skb;\r\nrbd->v_data = skb->data;\r\nrbd->b_data = WSWAPchar(virt_to_bus(skb->data));\r\nrbd->size = PKT_BUF_SZ;\r\n#ifdef __mc68000__\r\ncache_clear(virt_to_phys(skb->data), PKT_BUF_SZ);\r\n#endif\r\n}\r\nlp->rbd_head = lp->rbds;\r\nrbd = lp->rbds + rx_ring_size - 1;\r\nrbd->v_next = lp->rbds;\r\nrbd->b_next = WSWAPrbd(virt_to_bus(lp->rbds));\r\nfor (i = 0, rfd = lp->rfds; i < rx_ring_size; i++, rfd++) {\r\nrfd->rbd = I596_NULL;\r\nrfd->v_next = rfd+1;\r\nrfd->v_prev = rfd-1;\r\nrfd->b_next = WSWAPrfd(virt_to_bus(rfd+1));\r\nrfd->cmd = CMD_FLEX;\r\n}\r\nlp->rfd_head = lp->rfds;\r\nlp->scb.rfd = WSWAPrfd(virt_to_bus(lp->rfds));\r\nrfd = lp->rfds;\r\nrfd->rbd = lp->rbd_head;\r\nrfd->v_prev = lp->rfds + rx_ring_size - 1;\r\nrfd = lp->rfds + rx_ring_size - 1;\r\nrfd->v_next = lp->rfds;\r\nrfd->b_next = WSWAPrfd(virt_to_bus(lp->rfds));\r\nrfd->cmd = CMD_EOL|CMD_FLEX;\r\nreturn 0;\r\n}\r\nstatic void rebuild_rx_bufs(struct net_device *dev)\r\n{\r\nstruct i596_private *lp = dev->ml_priv;\r\nint i;\r\nfor (i = 0; i < rx_ring_size; i++) {\r\nlp->rfds[i].rbd = I596_NULL;\r\nlp->rfds[i].cmd = CMD_FLEX;\r\n}\r\nlp->rfds[rx_ring_size-1].cmd = CMD_EOL|CMD_FLEX;\r\nlp->rfd_head = lp->rfds;\r\nlp->scb.rfd = WSWAPrfd(virt_to_bus(lp->rfds));\r\nlp->rbd_head = lp->rbds;\r\nlp->rfds[0].rbd = WSWAPrbd(virt_to_bus(lp->rbds));\r\n}\r\nstatic int init_i596_mem(struct net_device *dev)\r\n{\r\nstruct i596_private *lp = dev->ml_priv;\r\nunsigned long flags;\r\nMPU_PORT(dev, PORT_RESET, NULL);\r\nudelay(100);\r\n#if defined(ENABLE_MVME16x_NET) || defined(ENABLE_BVME6000_NET)\r\n#ifdef ENABLE_MVME16x_NET\r\nif (MACH_IS_MVME16x) {\r\nvolatile unsigned char *pcc2 = (unsigned char *) 0xfff42000;\r\npcc2[0x28] = 1;\r\npcc2[0x2a] = 0x48;\r\npcc2[0x2b] = 0x08;\r\n}\r\n#endif\r\n#ifdef ENABLE_BVME6000_NET\r\nif (MACH_IS_BVME6000) {\r\nvolatile unsigned char *ethirq = (unsigned char *) BVME_ETHIRQ_REG;\r\n*ethirq = 1;\r\n}\r\n#endif\r\nMPU_PORT(dev, PORT_ALTSCP, (void *)virt_to_bus((void *)&lp->scp));\r\n#endif\r\nlp->last_cmd = jiffies;\r\n#ifdef ENABLE_MVME16x_NET\r\nif (MACH_IS_MVME16x)\r\nlp->scp.sysbus = 0x00000054;\r\n#endif\r\n#ifdef ENABLE_BVME6000_NET\r\nif (MACH_IS_BVME6000)\r\nlp->scp.sysbus = 0x0000004c;\r\n#endif\r\nlp->scp.iscp = WSWAPiscp(virt_to_bus((void *)&lp->iscp));\r\nlp->iscp.scb = WSWAPscb(virt_to_bus((void *)&lp->scb));\r\nlp->iscp.stat = ISCP_BUSY;\r\nlp->cmd_backlog = 0;\r\nlp->cmd_head = lp->scb.cmd = I596_NULL;\r\n#ifdef ENABLE_BVME6000_NET\r\nif (MACH_IS_BVME6000) {\r\nlp->scb.t_on = 7 * 25;\r\nlp->scb.t_off = 1 * 25;\r\n}\r\n#endif\r\nDEB(DEB_INIT,printk(KERN_DEBUG "%s: starting i82596.\n", dev->name));\r\nCA(dev);\r\nif (wait_istat(dev,lp,1000,"initialization timed out"))\r\ngoto failed;\r\nDEB(DEB_INIT,printk(KERN_DEBUG "%s: i82596 initialization successful\n", dev->name));\r\nrebuild_rx_bufs(dev);\r\nlp->scb.command = 0;\r\n#ifdef ENABLE_MVME16x_NET\r\nif (MACH_IS_MVME16x) {\r\nvolatile unsigned char *pcc2 = (unsigned char *) 0xfff42000;\r\npcc2[0x2a] = 0x55;\r\npcc2[0x2b] = 0x15;\r\n}\r\n#endif\r\n#ifdef ENABLE_BVME6000_NET\r\nif (MACH_IS_BVME6000) {\r\nvolatile unsigned char *ethirq = (unsigned char *) BVME_ETHIRQ_REG;\r\n*ethirq = 3;\r\n}\r\n#endif\r\nDEB(DEB_INIT,printk(KERN_DEBUG "%s: queuing CmdConfigure\n", dev->name));\r\nmemcpy(lp->cf_cmd.i596_config, init_setup, 14);\r\nlp->cf_cmd.cmd.command = CmdConfigure;\r\ni596_add_cmd(dev, &lp->cf_cmd.cmd);\r\nDEB(DEB_INIT,printk(KERN_DEBUG "%s: queuing CmdSASetup\n", dev->name));\r\nmemcpy(lp->sa_cmd.eth_addr, dev->dev_addr, ETH_ALEN);\r\nlp->sa_cmd.cmd.command = CmdSASetup;\r\ni596_add_cmd(dev, &lp->sa_cmd.cmd);\r\nDEB(DEB_INIT,printk(KERN_DEBUG "%s: queuing CmdTDR\n", dev->name));\r\nlp->tdr_cmd.cmd.command = CmdTDR;\r\ni596_add_cmd(dev, &lp->tdr_cmd.cmd);\r\nspin_lock_irqsave (&lp->lock, flags);\r\nif (wait_cmd(dev,lp,1000,"timed out waiting to issue RX_START")) {\r\nspin_unlock_irqrestore (&lp->lock, flags);\r\ngoto failed;\r\n}\r\nDEB(DEB_INIT,printk(KERN_DEBUG "%s: Issuing RX_START\n", dev->name));\r\nlp->scb.command = RX_START;\r\nCA(dev);\r\nspin_unlock_irqrestore (&lp->lock, flags);\r\nif (wait_cmd(dev,lp,1000,"RX_START not processed"))\r\ngoto failed;\r\nDEB(DEB_INIT,printk(KERN_DEBUG "%s: Receive unit started OK\n", dev->name));\r\nreturn 0;\r\nfailed:\r\nprintk(KERN_CRIT "%s: Failed to initialise 82596\n", dev->name);\r\nMPU_PORT(dev, PORT_RESET, NULL);\r\nreturn -1;\r\n}\r\nstatic inline int i596_rx(struct net_device *dev)\r\n{\r\nstruct i596_private *lp = dev->ml_priv;\r\nstruct i596_rfd *rfd;\r\nstruct i596_rbd *rbd;\r\nint frames = 0;\r\nDEB(DEB_RXFRAME,printk(KERN_DEBUG "i596_rx(), rfd_head %p, rbd_head %p\n",\r\nlp->rfd_head, lp->rbd_head));\r\nrfd = lp->rfd_head;\r\nwhile ((rfd->stat) & STAT_C) {\r\nif (rfd->rbd == I596_NULL)\r\nrbd = I596_NULL;\r\nelse if (rfd->rbd == lp->rbd_head->b_addr)\r\nrbd = lp->rbd_head;\r\nelse {\r\nprintk(KERN_CRIT "%s: rbd chain broken!\n", dev->name);\r\nrbd = I596_NULL;\r\n}\r\nDEB(DEB_RXFRAME, printk(KERN_DEBUG " rfd %p, rfd.rbd %p, rfd.stat %04x\n",\r\nrfd, rfd->rbd, rfd->stat));\r\nif (rbd != I596_NULL && ((rfd->stat) & STAT_OK)) {\r\nint pkt_len = rbd->count & 0x3fff;\r\nstruct sk_buff *skb = rbd->skb;\r\nint rx_in_place = 0;\r\nDEB(DEB_RXADDR,print_eth(rbd->v_data, "received"));\r\nframes++;\r\nif (pkt_len > rx_copybreak) {\r\nstruct sk_buff *newskb;\r\nnewskb = netdev_alloc_skb(dev, PKT_BUF_SZ);\r\nif (newskb == NULL) {\r\nskb = NULL;\r\ngoto memory_squeeze;\r\n}\r\nskb_put(skb, pkt_len);\r\nrx_in_place = 1;\r\nrbd->skb = newskb;\r\nrbd->v_data = newskb->data;\r\nrbd->b_data = WSWAPchar(virt_to_bus(newskb->data));\r\n#ifdef __mc68000__\r\ncache_clear(virt_to_phys(newskb->data), PKT_BUF_SZ);\r\n#endif\r\n} else {\r\nskb = netdev_alloc_skb(dev, pkt_len + 2);\r\n}\r\nmemory_squeeze:\r\nif (skb == NULL) {\r\ndev->stats.rx_dropped++;\r\n} else {\r\nif (!rx_in_place) {\r\nskb_reserve(skb, 2);\r\nmemcpy(skb_put(skb,pkt_len), rbd->v_data, pkt_len);\r\n}\r\nskb->protocol=eth_type_trans(skb,dev);\r\nskb->len = pkt_len;\r\n#ifdef __mc68000__\r\ncache_clear(virt_to_phys(rbd->skb->data),\r\npkt_len);\r\n#endif\r\nnetif_rx(skb);\r\ndev->stats.rx_packets++;\r\ndev->stats.rx_bytes+=pkt_len;\r\n}\r\n}\r\nelse {\r\nDEB(DEB_ERRORS, printk(KERN_DEBUG "%s: Error, rfd.stat = 0x%04x\n",\r\ndev->name, rfd->stat));\r\ndev->stats.rx_errors++;\r\nif ((rfd->stat) & 0x0001)\r\ndev->stats.collisions++;\r\nif ((rfd->stat) & 0x0080)\r\ndev->stats.rx_length_errors++;\r\nif ((rfd->stat) & 0x0100)\r\ndev->stats.rx_over_errors++;\r\nif ((rfd->stat) & 0x0200)\r\ndev->stats.rx_fifo_errors++;\r\nif ((rfd->stat) & 0x0400)\r\ndev->stats.rx_frame_errors++;\r\nif ((rfd->stat) & 0x0800)\r\ndev->stats.rx_crc_errors++;\r\nif ((rfd->stat) & 0x1000)\r\ndev->stats.rx_length_errors++;\r\n}\r\nif (rbd != I596_NULL && (rbd->count & 0x4000)) {\r\nrbd->count = 0;\r\nlp->rbd_head = rbd->v_next;\r\n}\r\nrfd->rbd = I596_NULL;\r\nrfd->stat = 0;\r\nrfd->cmd = CMD_EOL|CMD_FLEX;\r\nrfd->count = 0;\r\nrfd->v_prev->cmd = CMD_FLEX;\r\nlp->scb.rfd = rfd->b_next;\r\nlp->rfd_head = rfd->v_next;\r\nrfd = lp->rfd_head;\r\n}\r\nDEB(DEB_RXFRAME,printk(KERN_DEBUG "frames %d\n", frames));\r\nreturn 0;\r\n}\r\nstatic void i596_cleanup_cmd(struct net_device *dev, struct i596_private *lp)\r\n{\r\nstruct i596_cmd *ptr;\r\nwhile (lp->cmd_head != I596_NULL) {\r\nptr = lp->cmd_head;\r\nlp->cmd_head = ptr->v_next;\r\nlp->cmd_backlog--;\r\nswitch ((ptr->command) & 0x7) {\r\ncase CmdTx:\r\n{\r\nstruct tx_cmd *tx_cmd = (struct tx_cmd *) ptr;\r\nstruct sk_buff *skb = tx_cmd->skb;\r\ndev_kfree_skb(skb);\r\ndev->stats.tx_errors++;\r\ndev->stats.tx_aborted_errors++;\r\nptr->v_next = ptr->b_next = I596_NULL;\r\ntx_cmd->cmd.command = 0;\r\nbreak;\r\n}\r\ndefault:\r\nptr->v_next = ptr->b_next = I596_NULL;\r\n}\r\n}\r\nwait_cmd(dev,lp,100,"i596_cleanup_cmd timed out");\r\nlp->scb.cmd = I596_NULL;\r\n}\r\nstatic void i596_reset(struct net_device *dev, struct i596_private *lp,\r\nint ioaddr)\r\n{\r\nunsigned long flags;\r\nDEB(DEB_RESET,printk(KERN_DEBUG "i596_reset\n"));\r\nspin_lock_irqsave (&lp->lock, flags);\r\nwait_cmd(dev,lp,100,"i596_reset timed out");\r\nnetif_stop_queue(dev);\r\nlp->scb.command = CUC_ABORT | RX_ABORT;\r\nCA(dev);\r\nwait_cmd(dev,lp,1000,"i596_reset 2 timed out");\r\nspin_unlock_irqrestore (&lp->lock, flags);\r\ni596_cleanup_cmd(dev,lp);\r\ni596_rx(dev);\r\nnetif_start_queue(dev);\r\ninit_i596_mem(dev);\r\n}\r\nstatic void i596_add_cmd(struct net_device *dev, struct i596_cmd *cmd)\r\n{\r\nstruct i596_private *lp = dev->ml_priv;\r\nint ioaddr = dev->base_addr;\r\nunsigned long flags;\r\nDEB(DEB_ADDCMD,printk(KERN_DEBUG "i596_add_cmd\n"));\r\ncmd->status = 0;\r\ncmd->command |= (CMD_EOL | CMD_INTR);\r\ncmd->v_next = cmd->b_next = I596_NULL;\r\nspin_lock_irqsave (&lp->lock, flags);\r\nif (lp->cmd_head != I596_NULL) {\r\nlp->cmd_tail->v_next = cmd;\r\nlp->cmd_tail->b_next = WSWAPcmd(virt_to_bus(&cmd->status));\r\n} else {\r\nlp->cmd_head = cmd;\r\nwait_cmd(dev,lp,100,"i596_add_cmd timed out");\r\nlp->scb.cmd = WSWAPcmd(virt_to_bus(&cmd->status));\r\nlp->scb.command = CUC_START;\r\nCA(dev);\r\n}\r\nlp->cmd_tail = cmd;\r\nlp->cmd_backlog++;\r\nspin_unlock_irqrestore (&lp->lock, flags);\r\nif (lp->cmd_backlog > max_cmd_backlog) {\r\nunsigned long tickssofar = jiffies - lp->last_cmd;\r\nif (tickssofar < ticks_limit)\r\nreturn;\r\nprintk(KERN_NOTICE "%s: command unit timed out, status resetting.\n", dev->name);\r\ni596_reset(dev, lp, ioaddr);\r\n}\r\n}\r\nstatic int i596_open(struct net_device *dev)\r\n{\r\nint res = 0;\r\nDEB(DEB_OPEN,printk(KERN_DEBUG "%s: i596_open() irq %d.\n", dev->name, dev->irq));\r\nif (request_irq(dev->irq, i596_interrupt, 0, "i82596", dev)) {\r\nprintk(KERN_ERR "%s: IRQ %d not free\n", dev->name, dev->irq);\r\nreturn -EAGAIN;\r\n}\r\n#ifdef ENABLE_MVME16x_NET\r\nif (MACH_IS_MVME16x) {\r\nif (request_irq(0x56, i596_error, 0, "i82596_error", dev)) {\r\nres = -EAGAIN;\r\ngoto err_irq_dev;\r\n}\r\n}\r\n#endif\r\nres = init_rx_bufs(dev);\r\nif (res)\r\ngoto err_irq_56;\r\nnetif_start_queue(dev);\r\nif (init_i596_mem(dev)) {\r\nres = -EAGAIN;\r\ngoto err_queue;\r\n}\r\nreturn 0;\r\nerr_queue:\r\nnetif_stop_queue(dev);\r\nremove_rx_bufs(dev);\r\nerr_irq_56:\r\n#ifdef ENABLE_MVME16x_NET\r\nfree_irq(0x56, dev);\r\nerr_irq_dev:\r\n#endif\r\nfree_irq(dev->irq, dev);\r\nreturn res;\r\n}\r\nstatic void i596_tx_timeout (struct net_device *dev)\r\n{\r\nstruct i596_private *lp = dev->ml_priv;\r\nint ioaddr = dev->base_addr;\r\nDEB(DEB_ERRORS,printk(KERN_ERR "%s: transmit timed out, status resetting.\n",\r\ndev->name));\r\ndev->stats.tx_errors++;\r\nif (lp->last_restart == dev->stats.tx_packets) {\r\nDEB(DEB_ERRORS,printk(KERN_ERR "Resetting board.\n"));\r\ni596_reset (dev, lp, ioaddr);\r\n} else {\r\nDEB(DEB_ERRORS,printk(KERN_ERR "Kicking board.\n"));\r\nlp->scb.command = CUC_START | RX_START;\r\nCA (dev);\r\nlp->last_restart = dev->stats.tx_packets;\r\n}\r\ndev->trans_start = jiffies;\r\nnetif_wake_queue (dev);\r\n}\r\nstatic netdev_tx_t i596_start_xmit(struct sk_buff *skb, struct net_device *dev)\r\n{\r\nstruct i596_private *lp = dev->ml_priv;\r\nstruct tx_cmd *tx_cmd;\r\nstruct i596_tbd *tbd;\r\nshort length = skb->len;\r\nDEB(DEB_STARTTX,printk(KERN_DEBUG "%s: i596_start_xmit(%x,%p) called\n",\r\ndev->name, skb->len, skb->data));\r\nif (skb->len < ETH_ZLEN) {\r\nif (skb_padto(skb, ETH_ZLEN))\r\nreturn NETDEV_TX_OK;\r\nlength = ETH_ZLEN;\r\n}\r\nnetif_stop_queue(dev);\r\ntx_cmd = lp->tx_cmds + lp->next_tx_cmd;\r\ntbd = lp->tbds + lp->next_tx_cmd;\r\nif (tx_cmd->cmd.command) {\r\nprintk(KERN_NOTICE "%s: xmit ring full, dropping packet.\n",\r\ndev->name);\r\ndev->stats.tx_dropped++;\r\ndev_kfree_skb(skb);\r\n} else {\r\nif (++lp->next_tx_cmd == TX_RING_SIZE)\r\nlp->next_tx_cmd = 0;\r\ntx_cmd->tbd = WSWAPtbd(virt_to_bus(tbd));\r\ntbd->next = I596_NULL;\r\ntx_cmd->cmd.command = CMD_FLEX | CmdTx;\r\ntx_cmd->skb = skb;\r\ntx_cmd->pad = 0;\r\ntx_cmd->size = 0;\r\ntbd->pad = 0;\r\ntbd->size = EOF | length;\r\ntbd->data = WSWAPchar(virt_to_bus(skb->data));\r\n#ifdef __mc68000__\r\ncache_push(virt_to_phys(skb->data), length);\r\n#endif\r\nDEB(DEB_TXADDR,print_eth(skb->data, "tx-queued"));\r\ni596_add_cmd(dev, &tx_cmd->cmd);\r\ndev->stats.tx_packets++;\r\ndev->stats.tx_bytes += length;\r\n}\r\nnetif_start_queue(dev);\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic void print_eth(unsigned char *add, char *str)\r\n{\r\nprintk(KERN_DEBUG "i596 0x%p, %pM --> %pM %02X%02X, %s\n",\r\nadd, add + 6, add, add[12], add[13], str);\r\n}\r\nstruct net_device * __init i82596_probe(int unit)\r\n{\r\nstruct net_device *dev;\r\nint i;\r\nstruct i596_private *lp;\r\nchar eth_addr[8];\r\nstatic int probed;\r\nint err;\r\nif (probed)\r\nreturn ERR_PTR(-ENODEV);\r\nprobed++;\r\ndev = alloc_etherdev(0);\r\nif (!dev)\r\nreturn ERR_PTR(-ENOMEM);\r\nif (unit >= 0) {\r\nsprintf(dev->name, "eth%d", unit);\r\nnetdev_boot_setup_check(dev);\r\n} else {\r\ndev->base_addr = io;\r\ndev->irq = irq;\r\n}\r\n#ifdef ENABLE_MVME16x_NET\r\nif (MACH_IS_MVME16x) {\r\nif (mvme16x_config & MVME16x_CONFIG_NO_ETHERNET) {\r\nprintk(KERN_NOTICE "Ethernet probe disabled - chip not present\n");\r\nerr = -ENODEV;\r\ngoto out;\r\n}\r\nmemcpy(eth_addr, (void *) 0xfffc1f2c, ETH_ALEN);\r\ndev->base_addr = MVME_I596_BASE;\r\ndev->irq = (unsigned) MVME16x_IRQ_I596;\r\ngoto found;\r\n}\r\n#endif\r\n#ifdef ENABLE_BVME6000_NET\r\nif (MACH_IS_BVME6000) {\r\nvolatile unsigned char *rtc = (unsigned char *) BVME_RTC_BASE;\r\nunsigned char msr = rtc[3];\r\nint i;\r\nrtc[3] |= 0x80;\r\nfor (i = 0; i < 6; i++)\r\neth_addr[i] = rtc[i * 4 + 7];\r\nrtc[3] = msr;\r\ndev->base_addr = BVME_I596_BASE;\r\ndev->irq = (unsigned) BVME_IRQ_I596;\r\ngoto found;\r\n}\r\n#endif\r\nerr = -ENODEV;\r\ngoto out;\r\nfound:\r\ndev->mem_start = (int)__get_free_pages(GFP_ATOMIC, 0);\r\nif (!dev->mem_start) {\r\nerr = -ENOMEM;\r\ngoto out1;\r\n}\r\nDEB(DEB_PROBE,printk(KERN_INFO "%s: 82596 at %#3lx,", dev->name, dev->base_addr));\r\nfor (i = 0; i < 6; i++)\r\nDEB(DEB_PROBE,printk(" %2.2X", dev->dev_addr[i] = eth_addr[i]));\r\nDEB(DEB_PROBE,printk(" IRQ %d.\n", dev->irq));\r\nDEB(DEB_PROBE,printk(KERN_INFO "%s", version));\r\ndev->netdev_ops = &i596_netdev_ops;\r\ndev->watchdog_timeo = TX_TIMEOUT;\r\ndev->ml_priv = (void *)(dev->mem_start);\r\nlp = dev->ml_priv;\r\nDEB(DEB_INIT,printk(KERN_DEBUG "%s: lp at 0x%08lx (%zd bytes), "\r\n"lp->scb at 0x%08lx\n",\r\ndev->name, (unsigned long)lp,\r\nsizeof(struct i596_private), (unsigned long)&lp->scb));\r\nmemset((void *) lp, 0, sizeof(struct i596_private));\r\n#ifdef __mc68000__\r\ncache_push(virt_to_phys((void *)(dev->mem_start)), 4096);\r\ncache_clear(virt_to_phys((void *)(dev->mem_start)), 4096);\r\nkernel_set_cachemode((void *)(dev->mem_start), 4096, IOMAP_NOCACHE_SER);\r\n#endif\r\nlp->scb.command = 0;\r\nlp->scb.cmd = I596_NULL;\r\nlp->scb.rfd = I596_NULL;\r\nspin_lock_init(&lp->lock);\r\nerr = register_netdev(dev);\r\nif (err)\r\ngoto out2;\r\nreturn dev;\r\nout2:\r\n#ifdef __mc68000__\r\nkernel_set_cachemode((void *)(dev->mem_start), 4096,\r\nIOMAP_FULL_CACHING);\r\n#endif\r\nfree_page ((u32)(dev->mem_start));\r\nout1:\r\nout:\r\nfree_netdev(dev);\r\nreturn ERR_PTR(err);\r\n}\r\nstatic irqreturn_t i596_interrupt(int irq, void *dev_id)\r\n{\r\nstruct net_device *dev = dev_id;\r\nstruct i596_private *lp;\r\nshort ioaddr;\r\nunsigned short status, ack_cmd = 0;\r\nint handled = 0;\r\n#ifdef ENABLE_BVME6000_NET\r\nif (MACH_IS_BVME6000) {\r\nif (*(char *) BVME_LOCAL_IRQ_STAT & BVME_ETHERR) {\r\ni596_error(irq, dev_id);\r\nreturn IRQ_HANDLED;\r\n}\r\n}\r\n#endif\r\nif (dev == NULL) {\r\nprintk(KERN_ERR "i596_interrupt(): irq %d for unknown device.\n", irq);\r\nreturn IRQ_NONE;\r\n}\r\nioaddr = dev->base_addr;\r\nlp = dev->ml_priv;\r\nspin_lock (&lp->lock);\r\nwait_cmd(dev,lp,100,"i596 interrupt, timeout");\r\nstatus = lp->scb.status;\r\nDEB(DEB_INTS,printk(KERN_DEBUG "%s: i596 interrupt, IRQ %d, status %4.4x.\n",\r\ndev->name, irq, status));\r\nack_cmd = status & 0xf000;\r\nif ((status & 0x8000) || (status & 0x2000)) {\r\nstruct i596_cmd *ptr;\r\nhandled = 1;\r\nif ((status & 0x8000))\r\nDEB(DEB_INTS,printk(KERN_DEBUG "%s: i596 interrupt completed command.\n", dev->name));\r\nif ((status & 0x2000))\r\nDEB(DEB_INTS,printk(KERN_DEBUG "%s: i596 interrupt command unit inactive %x.\n", dev->name, status & 0x0700));\r\nwhile ((lp->cmd_head != I596_NULL) && (lp->cmd_head->status & STAT_C)) {\r\nptr = lp->cmd_head;\r\nDEB(DEB_STATUS,printk(KERN_DEBUG "cmd_head->status = %04x, ->command = %04x\n",\r\nlp->cmd_head->status, lp->cmd_head->command));\r\nlp->cmd_head = ptr->v_next;\r\nlp->cmd_backlog--;\r\nswitch ((ptr->command) & 0x7) {\r\ncase CmdTx:\r\n{\r\nstruct tx_cmd *tx_cmd = (struct tx_cmd *) ptr;\r\nstruct sk_buff *skb = tx_cmd->skb;\r\nif ((ptr->status) & STAT_OK) {\r\nDEB(DEB_TXADDR,print_eth(skb->data, "tx-done"));\r\n} else {\r\ndev->stats.tx_errors++;\r\nif ((ptr->status) & 0x0020)\r\ndev->stats.collisions++;\r\nif (!((ptr->status) & 0x0040))\r\ndev->stats.tx_heartbeat_errors++;\r\nif ((ptr->status) & 0x0400)\r\ndev->stats.tx_carrier_errors++;\r\nif ((ptr->status) & 0x0800)\r\ndev->stats.collisions++;\r\nif ((ptr->status) & 0x1000)\r\ndev->stats.tx_aborted_errors++;\r\n}\r\ndev_kfree_skb_irq(skb);\r\ntx_cmd->cmd.command = 0;\r\nbreak;\r\n}\r\ncase CmdTDR:\r\n{\r\nunsigned short status = ((struct tdr_cmd *)ptr)->status;\r\nif (status & 0x8000) {\r\nDEB(DEB_TDR,printk(KERN_INFO "%s: link ok.\n", dev->name));\r\n} else {\r\nif (status & 0x4000)\r\nprintk(KERN_ERR "%s: Transceiver problem.\n", dev->name);\r\nif (status & 0x2000)\r\nprintk(KERN_ERR "%s: Termination problem.\n", dev->name);\r\nif (status & 0x1000)\r\nprintk(KERN_ERR "%s: Short circuit.\n", dev->name);\r\nDEB(DEB_TDR,printk(KERN_INFO "%s: Time %d.\n", dev->name, status & 0x07ff));\r\n}\r\nbreak;\r\n}\r\ncase CmdConfigure:\r\ncase CmdMulticastList:\r\nptr->command = 0;\r\nbreak;\r\n}\r\nptr->v_next = ptr->b_next = I596_NULL;\r\nlp->last_cmd = jiffies;\r\n}\r\nptr = lp->cmd_head;\r\nwhile ((ptr != I596_NULL) && (ptr != lp->cmd_tail)) {\r\nptr->command &= 0x1fff;\r\nptr = ptr->v_next;\r\n}\r\nif ((lp->cmd_head != I596_NULL))\r\nack_cmd |= CUC_START;\r\nlp->scb.cmd = WSWAPcmd(virt_to_bus(&lp->cmd_head->status));\r\n}\r\nif ((status & 0x1000) || (status & 0x4000)) {\r\nif ((status & 0x4000))\r\nDEB(DEB_INTS,printk(KERN_DEBUG "%s: i596 interrupt received a frame.\n", dev->name));\r\ni596_rx(dev);\r\nif (status & 0x1000) {\r\nif (netif_running(dev)) {\r\nDEB(DEB_ERRORS,printk(KERN_ERR "%s: i596 interrupt receive unit inactive, status 0x%x\n", dev->name, status));\r\nack_cmd |= RX_START;\r\ndev->stats.rx_errors++;\r\ndev->stats.rx_fifo_errors++;\r\nrebuild_rx_bufs(dev);\r\n}\r\n}\r\n}\r\nwait_cmd(dev,lp,100,"i596 interrupt, timeout");\r\nlp->scb.command = ack_cmd;\r\n#ifdef ENABLE_MVME16x_NET\r\nif (MACH_IS_MVME16x) {\r\nvolatile unsigned char *pcc2 = (unsigned char *) 0xfff42000;\r\npcc2[0x2a] |= 0x08;\r\n}\r\n#endif\r\n#ifdef ENABLE_BVME6000_NET\r\nif (MACH_IS_BVME6000) {\r\nvolatile unsigned char *ethirq = (unsigned char *) BVME_ETHIRQ_REG;\r\n*ethirq = 1;\r\n*ethirq = 3;\r\n}\r\n#endif\r\nCA(dev);\r\nDEB(DEB_INTS,printk(KERN_DEBUG "%s: exiting interrupt.\n", dev->name));\r\nspin_unlock (&lp->lock);\r\nreturn IRQ_RETVAL(handled);\r\n}\r\nstatic int i596_close(struct net_device *dev)\r\n{\r\nstruct i596_private *lp = dev->ml_priv;\r\nunsigned long flags;\r\nnetif_stop_queue(dev);\r\nDEB(DEB_INIT,printk(KERN_DEBUG "%s: Shutting down ethercard, status was %4.4x.\n",\r\ndev->name, lp->scb.status));\r\nspin_lock_irqsave(&lp->lock, flags);\r\nwait_cmd(dev,lp,100,"close1 timed out");\r\nlp->scb.command = CUC_ABORT | RX_ABORT;\r\nCA(dev);\r\nwait_cmd(dev,lp,100,"close2 timed out");\r\nspin_unlock_irqrestore(&lp->lock, flags);\r\nDEB(DEB_STRUCT,i596_display_data(dev));\r\ni596_cleanup_cmd(dev,lp);\r\n#ifdef ENABLE_MVME16x_NET\r\nif (MACH_IS_MVME16x) {\r\nvolatile unsigned char *pcc2 = (unsigned char *) 0xfff42000;\r\npcc2[0x28] = 1;\r\npcc2[0x2a] = 0x40;\r\npcc2[0x2b] = 0x40;\r\n}\r\n#endif\r\n#ifdef ENABLE_BVME6000_NET\r\nif (MACH_IS_BVME6000) {\r\nvolatile unsigned char *ethirq = (unsigned char *) BVME_ETHIRQ_REG;\r\n*ethirq = 1;\r\n}\r\n#endif\r\n#ifdef ENABLE_MVME16x_NET\r\nfree_irq(0x56, dev);\r\n#endif\r\nfree_irq(dev->irq, dev);\r\nremove_rx_bufs(dev);\r\nreturn 0;\r\n}\r\nstatic void set_multicast_list(struct net_device *dev)\r\n{\r\nstruct i596_private *lp = dev->ml_priv;\r\nint config = 0, cnt;\r\nDEB(DEB_MULTI,printk(KERN_DEBUG "%s: set multicast list, %d entries, promisc %s, allmulti %s\n",\r\ndev->name, netdev_mc_count(dev),\r\ndev->flags & IFF_PROMISC ? "ON" : "OFF",\r\ndev->flags & IFF_ALLMULTI ? "ON" : "OFF"));\r\nif (wait_cfg(dev, &lp->cf_cmd.cmd, 1000, "config change request timed out"))\r\nreturn;\r\nif ((dev->flags & IFF_PROMISC) && !(lp->cf_cmd.i596_config[8] & 0x01)) {\r\nlp->cf_cmd.i596_config[8] |= 0x01;\r\nconfig = 1;\r\n}\r\nif (!(dev->flags & IFF_PROMISC) && (lp->cf_cmd.i596_config[8] & 0x01)) {\r\nlp->cf_cmd.i596_config[8] &= ~0x01;\r\nconfig = 1;\r\n}\r\nif ((dev->flags & IFF_ALLMULTI) && (lp->cf_cmd.i596_config[11] & 0x20)) {\r\nlp->cf_cmd.i596_config[11] &= ~0x20;\r\nconfig = 1;\r\n}\r\nif (!(dev->flags & IFF_ALLMULTI) && !(lp->cf_cmd.i596_config[11] & 0x20)) {\r\nlp->cf_cmd.i596_config[11] |= 0x20;\r\nconfig = 1;\r\n}\r\nif (config) {\r\nlp->cf_cmd.cmd.command = CmdConfigure;\r\ni596_add_cmd(dev, &lp->cf_cmd.cmd);\r\n}\r\ncnt = netdev_mc_count(dev);\r\nif (cnt > MAX_MC_CNT)\r\n{\r\ncnt = MAX_MC_CNT;\r\nprintk(KERN_ERR "%s: Only %d multicast addresses supported",\r\ndev->name, cnt);\r\n}\r\nif (!netdev_mc_empty(dev)) {\r\nstruct netdev_hw_addr *ha;\r\nunsigned char *cp;\r\nstruct mc_cmd *cmd;\r\nif (wait_cfg(dev, &lp->mc_cmd.cmd, 1000, "multicast list change request timed out"))\r\nreturn;\r\ncmd = &lp->mc_cmd;\r\ncmd->cmd.command = CmdMulticastList;\r\ncmd->mc_cnt = cnt * ETH_ALEN;\r\ncp = cmd->mc_addrs;\r\nnetdev_for_each_mc_addr(ha, dev) {\r\nif (!cnt--)\r\nbreak;\r\nmemcpy(cp, ha->addr, ETH_ALEN);\r\nif (i596_debug > 1)\r\nDEB(DEB_MULTI,printk(KERN_INFO "%s: Adding address %pM\n",\r\ndev->name, cp));\r\ncp += ETH_ALEN;\r\n}\r\ni596_add_cmd(dev, &cmd->cmd);\r\n}\r\n}\r\nint __init init_module(void)\r\n{\r\nif (debug >= 0)\r\ni596_debug = debug;\r\ndev_82596 = i82596_probe(-1);\r\nreturn PTR_ERR_OR_ZERO(dev_82596);\r\n}\r\nvoid __exit cleanup_module(void)\r\n{\r\nunregister_netdev(dev_82596);\r\n#ifdef __mc68000__\r\nkernel_set_cachemode((void *)(dev_82596->mem_start), 4096,\r\nIOMAP_FULL_CACHING);\r\n#endif\r\nfree_page ((u32)(dev_82596->mem_start));\r\nfree_netdev(dev_82596);\r\n}
