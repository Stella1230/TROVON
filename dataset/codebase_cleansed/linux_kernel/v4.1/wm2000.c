static int wm2000_write(struct i2c_client *i2c, unsigned int reg,\r\nunsigned int value)\r\n{\r\nstruct wm2000_priv *wm2000 = i2c_get_clientdata(i2c);\r\nreturn regmap_write(wm2000->regmap, reg, value);\r\n}\r\nstatic unsigned int wm2000_read(struct i2c_client *i2c, unsigned int r)\r\n{\r\nstruct wm2000_priv *wm2000 = i2c_get_clientdata(i2c);\r\nunsigned int val;\r\nint ret;\r\nret = regmap_read(wm2000->regmap, r, &val);\r\nif (ret < 0)\r\nreturn -1;\r\nreturn val;\r\n}\r\nstatic void wm2000_reset(struct wm2000_priv *wm2000)\r\n{\r\nstruct i2c_client *i2c = wm2000->i2c;\r\nwm2000_write(i2c, WM2000_REG_SYS_CTL2, WM2000_ANC_ENG_CLR);\r\nwm2000_write(i2c, WM2000_REG_SYS_CTL2, WM2000_RAM_CLR);\r\nwm2000_write(i2c, WM2000_REG_ID1, 0);\r\nwm2000->anc_mode = ANC_OFF;\r\n}\r\nstatic int wm2000_poll_bit(struct i2c_client *i2c,\r\nunsigned int reg, u8 mask)\r\n{\r\nint timeout = 4000;\r\nint val;\r\nval = wm2000_read(i2c, reg);\r\nwhile (!(val & mask) && --timeout) {\r\nmsleep(1);\r\nval = wm2000_read(i2c, reg);\r\n}\r\nif (timeout == 0)\r\nreturn 0;\r\nelse\r\nreturn 1;\r\n}\r\nstatic int wm2000_power_up(struct i2c_client *i2c, int analogue)\r\n{\r\nstruct wm2000_priv *wm2000 = dev_get_drvdata(&i2c->dev);\r\nunsigned long rate;\r\nint ret;\r\nif (WARN_ON(wm2000->anc_mode != ANC_OFF))\r\nreturn -EINVAL;\r\ndev_dbg(&i2c->dev, "Beginning power up\n");\r\nret = regulator_bulk_enable(WM2000_NUM_SUPPLIES, wm2000->supplies);\r\nif (ret != 0) {\r\ndev_err(&i2c->dev, "Failed to enable supplies: %d\n", ret);\r\nreturn ret;\r\n}\r\nrate = clk_get_rate(wm2000->mclk);\r\nif (rate <= 13500000) {\r\ndev_dbg(&i2c->dev, "Disabling MCLK divider\n");\r\nwm2000_write(i2c, WM2000_REG_SYS_CTL2,\r\nWM2000_MCLK_DIV2_ENA_CLR);\r\n} else {\r\ndev_dbg(&i2c->dev, "Enabling MCLK divider\n");\r\nwm2000_write(i2c, WM2000_REG_SYS_CTL2,\r\nWM2000_MCLK_DIV2_ENA_SET);\r\n}\r\nwm2000_write(i2c, WM2000_REG_SYS_CTL2, WM2000_ANC_ENG_CLR);\r\nwm2000_write(i2c, WM2000_REG_SYS_CTL2, WM2000_ANC_ENG_SET);\r\nif (!wm2000_poll_bit(i2c, WM2000_REG_ANC_STAT,\r\nWM2000_ANC_ENG_IDLE)) {\r\ndev_err(&i2c->dev, "ANC engine failed to reset\n");\r\nregulator_bulk_disable(WM2000_NUM_SUPPLIES, wm2000->supplies);\r\nreturn -ETIMEDOUT;\r\n}\r\nif (!wm2000_poll_bit(i2c, WM2000_REG_SYS_STATUS,\r\nWM2000_STATUS_BOOT_COMPLETE)) {\r\ndev_err(&i2c->dev, "ANC engine failed to initialise\n");\r\nregulator_bulk_disable(WM2000_NUM_SUPPLIES, wm2000->supplies);\r\nreturn -ETIMEDOUT;\r\n}\r\nwm2000_write(i2c, WM2000_REG_SYS_CTL2, WM2000_RAM_SET);\r\ndev_dbg(&i2c->dev, "Downloading %d bytes\n",\r\nwm2000->anc_download_size - 2);\r\nret = i2c_master_send(i2c, wm2000->anc_download,\r\nwm2000->anc_download_size);\r\nif (ret < 0) {\r\ndev_err(&i2c->dev, "i2c_transfer() failed: %d\n", ret);\r\nregulator_bulk_disable(WM2000_NUM_SUPPLIES, wm2000->supplies);\r\nreturn ret;\r\n}\r\nif (ret != wm2000->anc_download_size) {\r\ndev_err(&i2c->dev, "i2c_transfer() failed, %d != %d\n",\r\nret, wm2000->anc_download_size);\r\nregulator_bulk_disable(WM2000_NUM_SUPPLIES, wm2000->supplies);\r\nreturn -EIO;\r\n}\r\ndev_dbg(&i2c->dev, "Download complete\n");\r\nif (analogue) {\r\nwm2000_write(i2c, WM2000_REG_ANA_VMID_PU_TIME, 248 / 4);\r\nwm2000_write(i2c, WM2000_REG_SYS_MODE_CNTRL,\r\nWM2000_MODE_ANA_SEQ_INCLUDE |\r\nWM2000_MODE_MOUSE_ENABLE |\r\nWM2000_MODE_THERMAL_ENABLE);\r\n} else {\r\nwm2000_write(i2c, WM2000_REG_SYS_MODE_CNTRL,\r\nWM2000_MODE_MOUSE_ENABLE |\r\nWM2000_MODE_THERMAL_ENABLE);\r\n}\r\nret = wm2000_read(i2c, WM2000_REG_SPEECH_CLARITY);\r\nif (wm2000->speech_clarity)\r\nret |= WM2000_SPEECH_CLARITY;\r\nelse\r\nret &= ~WM2000_SPEECH_CLARITY;\r\nwm2000_write(i2c, WM2000_REG_SPEECH_CLARITY, ret);\r\nwm2000_write(i2c, WM2000_REG_SYS_START0, 0x33);\r\nwm2000_write(i2c, WM2000_REG_SYS_START1, 0x02);\r\nwm2000_write(i2c, WM2000_REG_SYS_CTL2, WM2000_ANC_INT_N_CLR);\r\nif (!wm2000_poll_bit(i2c, WM2000_REG_SYS_STATUS,\r\nWM2000_STATUS_MOUSE_ACTIVE)) {\r\ndev_err(&i2c->dev, "Timed out waiting for device\n");\r\nregulator_bulk_disable(WM2000_NUM_SUPPLIES, wm2000->supplies);\r\nreturn -ETIMEDOUT;\r\n}\r\ndev_dbg(&i2c->dev, "ANC active\n");\r\nif (analogue)\r\ndev_dbg(&i2c->dev, "Analogue active\n");\r\nwm2000->anc_mode = ANC_ACTIVE;\r\nreturn 0;\r\n}\r\nstatic int wm2000_power_down(struct i2c_client *i2c, int analogue)\r\n{\r\nstruct wm2000_priv *wm2000 = dev_get_drvdata(&i2c->dev);\r\nif (analogue) {\r\nwm2000_write(i2c, WM2000_REG_ANA_VMID_PD_TIME, 248 / 4);\r\nwm2000_write(i2c, WM2000_REG_SYS_MODE_CNTRL,\r\nWM2000_MODE_ANA_SEQ_INCLUDE |\r\nWM2000_MODE_POWER_DOWN);\r\n} else {\r\nwm2000_write(i2c, WM2000_REG_SYS_MODE_CNTRL,\r\nWM2000_MODE_POWER_DOWN);\r\n}\r\nif (!wm2000_poll_bit(i2c, WM2000_REG_SYS_STATUS,\r\nWM2000_STATUS_POWER_DOWN_COMPLETE)) {\r\ndev_err(&i2c->dev, "Timeout waiting for ANC power down\n");\r\nreturn -ETIMEDOUT;\r\n}\r\nif (!wm2000_poll_bit(i2c, WM2000_REG_ANC_STAT,\r\nWM2000_ANC_ENG_IDLE)) {\r\ndev_err(&i2c->dev, "Timeout waiting for ANC engine idle\n");\r\nreturn -ETIMEDOUT;\r\n}\r\nregulator_bulk_disable(WM2000_NUM_SUPPLIES, wm2000->supplies);\r\ndev_dbg(&i2c->dev, "powered off\n");\r\nwm2000->anc_mode = ANC_OFF;\r\nreturn 0;\r\n}\r\nstatic int wm2000_enter_bypass(struct i2c_client *i2c, int analogue)\r\n{\r\nstruct wm2000_priv *wm2000 = dev_get_drvdata(&i2c->dev);\r\nif (WARN_ON(wm2000->anc_mode != ANC_ACTIVE))\r\nreturn -EINVAL;\r\nif (analogue) {\r\nwm2000_write(i2c, WM2000_REG_SYS_MODE_CNTRL,\r\nWM2000_MODE_ANA_SEQ_INCLUDE |\r\nWM2000_MODE_THERMAL_ENABLE |\r\nWM2000_MODE_BYPASS_ENTRY);\r\n} else {\r\nwm2000_write(i2c, WM2000_REG_SYS_MODE_CNTRL,\r\nWM2000_MODE_THERMAL_ENABLE |\r\nWM2000_MODE_BYPASS_ENTRY);\r\n}\r\nif (!wm2000_poll_bit(i2c, WM2000_REG_SYS_STATUS,\r\nWM2000_STATUS_ANC_DISABLED)) {\r\ndev_err(&i2c->dev, "Timeout waiting for ANC disable\n");\r\nreturn -ETIMEDOUT;\r\n}\r\nif (!wm2000_poll_bit(i2c, WM2000_REG_ANC_STAT,\r\nWM2000_ANC_ENG_IDLE)) {\r\ndev_err(&i2c->dev, "Timeout waiting for ANC engine idle\n");\r\nreturn -ETIMEDOUT;\r\n}\r\nwm2000_write(i2c, WM2000_REG_SYS_CTL1, WM2000_SYS_STBY);\r\nwm2000_write(i2c, WM2000_REG_SYS_CTL2, WM2000_RAM_CLR);\r\nwm2000->anc_mode = ANC_BYPASS;\r\ndev_dbg(&i2c->dev, "bypass enabled\n");\r\nreturn 0;\r\n}\r\nstatic int wm2000_exit_bypass(struct i2c_client *i2c, int analogue)\r\n{\r\nstruct wm2000_priv *wm2000 = dev_get_drvdata(&i2c->dev);\r\nif (WARN_ON(wm2000->anc_mode != ANC_BYPASS))\r\nreturn -EINVAL;\r\nwm2000_write(i2c, WM2000_REG_SYS_CTL1, 0);\r\nif (analogue) {\r\nwm2000_write(i2c, WM2000_REG_SYS_MODE_CNTRL,\r\nWM2000_MODE_ANA_SEQ_INCLUDE |\r\nWM2000_MODE_MOUSE_ENABLE |\r\nWM2000_MODE_THERMAL_ENABLE);\r\n} else {\r\nwm2000_write(i2c, WM2000_REG_SYS_MODE_CNTRL,\r\nWM2000_MODE_MOUSE_ENABLE |\r\nWM2000_MODE_THERMAL_ENABLE);\r\n}\r\nwm2000_write(i2c, WM2000_REG_SYS_CTL2, WM2000_RAM_SET);\r\nwm2000_write(i2c, WM2000_REG_SYS_CTL2, WM2000_ANC_INT_N_CLR);\r\nif (!wm2000_poll_bit(i2c, WM2000_REG_SYS_STATUS,\r\nWM2000_STATUS_MOUSE_ACTIVE)) {\r\ndev_err(&i2c->dev, "Timed out waiting for MOUSE\n");\r\nreturn -ETIMEDOUT;\r\n}\r\nwm2000->anc_mode = ANC_ACTIVE;\r\ndev_dbg(&i2c->dev, "MOUSE active\n");\r\nreturn 0;\r\n}\r\nstatic int wm2000_enter_standby(struct i2c_client *i2c, int analogue)\r\n{\r\nstruct wm2000_priv *wm2000 = dev_get_drvdata(&i2c->dev);\r\nif (WARN_ON(wm2000->anc_mode != ANC_ACTIVE))\r\nreturn -EINVAL;\r\nif (analogue) {\r\nwm2000_write(i2c, WM2000_REG_ANA_VMID_PD_TIME, 248 / 4);\r\nwm2000_write(i2c, WM2000_REG_SYS_MODE_CNTRL,\r\nWM2000_MODE_ANA_SEQ_INCLUDE |\r\nWM2000_MODE_THERMAL_ENABLE |\r\nWM2000_MODE_STANDBY_ENTRY);\r\n} else {\r\nwm2000_write(i2c, WM2000_REG_SYS_MODE_CNTRL,\r\nWM2000_MODE_THERMAL_ENABLE |\r\nWM2000_MODE_STANDBY_ENTRY);\r\n}\r\nif (!wm2000_poll_bit(i2c, WM2000_REG_SYS_STATUS,\r\nWM2000_STATUS_ANC_DISABLED)) {\r\ndev_err(&i2c->dev,\r\n"Timed out waiting for ANC disable after 1ms\n");\r\nreturn -ETIMEDOUT;\r\n}\r\nif (!wm2000_poll_bit(i2c, WM2000_REG_ANC_STAT, WM2000_ANC_ENG_IDLE)) {\r\ndev_err(&i2c->dev,\r\n"Timed out waiting for standby\n");\r\nreturn -ETIMEDOUT;\r\n}\r\nwm2000_write(i2c, WM2000_REG_SYS_CTL1, WM2000_SYS_STBY);\r\nwm2000_write(i2c, WM2000_REG_SYS_CTL2, WM2000_RAM_CLR);\r\nwm2000->anc_mode = ANC_STANDBY;\r\ndev_dbg(&i2c->dev, "standby\n");\r\nif (analogue)\r\ndev_dbg(&i2c->dev, "Analogue disabled\n");\r\nreturn 0;\r\n}\r\nstatic int wm2000_exit_standby(struct i2c_client *i2c, int analogue)\r\n{\r\nstruct wm2000_priv *wm2000 = dev_get_drvdata(&i2c->dev);\r\nif (WARN_ON(wm2000->anc_mode != ANC_STANDBY))\r\nreturn -EINVAL;\r\nwm2000_write(i2c, WM2000_REG_SYS_CTL1, 0);\r\nif (analogue) {\r\nwm2000_write(i2c, WM2000_REG_ANA_VMID_PU_TIME, 248 / 4);\r\nwm2000_write(i2c, WM2000_REG_SYS_MODE_CNTRL,\r\nWM2000_MODE_ANA_SEQ_INCLUDE |\r\nWM2000_MODE_THERMAL_ENABLE |\r\nWM2000_MODE_MOUSE_ENABLE);\r\n} else {\r\nwm2000_write(i2c, WM2000_REG_SYS_MODE_CNTRL,\r\nWM2000_MODE_THERMAL_ENABLE |\r\nWM2000_MODE_MOUSE_ENABLE);\r\n}\r\nwm2000_write(i2c, WM2000_REG_SYS_CTL2, WM2000_RAM_SET);\r\nwm2000_write(i2c, WM2000_REG_SYS_CTL2, WM2000_ANC_INT_N_CLR);\r\nif (!wm2000_poll_bit(i2c, WM2000_REG_SYS_STATUS,\r\nWM2000_STATUS_MOUSE_ACTIVE)) {\r\ndev_err(&i2c->dev, "Timed out waiting for MOUSE\n");\r\nreturn -ETIMEDOUT;\r\n}\r\nwm2000->anc_mode = ANC_ACTIVE;\r\ndev_dbg(&i2c->dev, "MOUSE active\n");\r\nif (analogue)\r\ndev_dbg(&i2c->dev, "Analogue enabled\n");\r\nreturn 0;\r\n}\r\nstatic int wm2000_anc_transition(struct wm2000_priv *wm2000,\r\nenum wm2000_anc_mode mode)\r\n{\r\nstruct i2c_client *i2c = wm2000->i2c;\r\nint i, j;\r\nint ret;\r\nif (wm2000->anc_mode == mode)\r\nreturn 0;\r\nfor (i = 0; i < ARRAY_SIZE(anc_transitions); i++)\r\nif (anc_transitions[i].source == wm2000->anc_mode &&\r\nanc_transitions[i].dest == mode)\r\nbreak;\r\nif (i == ARRAY_SIZE(anc_transitions)) {\r\ndev_err(&i2c->dev, "No transition for %d->%d\n",\r\nwm2000->anc_mode, mode);\r\nreturn -EINVAL;\r\n}\r\nif (anc_transitions[i].source == ANC_OFF) {\r\nret = clk_prepare_enable(wm2000->mclk);\r\nif (ret != 0) {\r\ndev_err(&i2c->dev, "Failed to enable MCLK: %d\n", ret);\r\nreturn ret;\r\n}\r\n}\r\nfor (j = 0; j < ARRAY_SIZE(anc_transitions[j].step); j++) {\r\nif (!anc_transitions[i].step[j])\r\nbreak;\r\nret = anc_transitions[i].step[j](i2c,\r\nanc_transitions[i].analogue);\r\nif (ret != 0)\r\nreturn ret;\r\n}\r\nif (anc_transitions[i].dest == ANC_OFF)\r\nclk_disable_unprepare(wm2000->mclk);\r\nreturn ret;\r\n}\r\nstatic int wm2000_anc_set_mode(struct wm2000_priv *wm2000)\r\n{\r\nstruct i2c_client *i2c = wm2000->i2c;\r\nenum wm2000_anc_mode mode;\r\nif (wm2000->anc_eng_ena && wm2000->spk_ena)\r\nif (wm2000->anc_active)\r\nmode = ANC_ACTIVE;\r\nelse\r\nmode = ANC_BYPASS;\r\nelse\r\nmode = ANC_STANDBY;\r\ndev_dbg(&i2c->dev, "Set mode %d (enabled %d, mute %d, active %d)\n",\r\nmode, wm2000->anc_eng_ena, !wm2000->spk_ena,\r\nwm2000->anc_active);\r\nreturn wm2000_anc_transition(wm2000, mode);\r\n}\r\nstatic int wm2000_anc_mode_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_codec *codec = snd_soc_kcontrol_codec(kcontrol);\r\nstruct wm2000_priv *wm2000 = dev_get_drvdata(codec->dev);\r\nucontrol->value.integer.value[0] = wm2000->anc_active;\r\nreturn 0;\r\n}\r\nstatic int wm2000_anc_mode_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_codec *codec = snd_soc_kcontrol_codec(kcontrol);\r\nstruct wm2000_priv *wm2000 = dev_get_drvdata(codec->dev);\r\nint anc_active = ucontrol->value.integer.value[0];\r\nint ret;\r\nif (anc_active > 1)\r\nreturn -EINVAL;\r\nmutex_lock(&wm2000->lock);\r\nwm2000->anc_active = anc_active;\r\nret = wm2000_anc_set_mode(wm2000);\r\nmutex_unlock(&wm2000->lock);\r\nreturn ret;\r\n}\r\nstatic int wm2000_speaker_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_codec *codec = snd_soc_kcontrol_codec(kcontrol);\r\nstruct wm2000_priv *wm2000 = dev_get_drvdata(codec->dev);\r\nucontrol->value.integer.value[0] = wm2000->spk_ena;\r\nreturn 0;\r\n}\r\nstatic int wm2000_speaker_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_codec *codec = snd_soc_kcontrol_codec(kcontrol);\r\nstruct wm2000_priv *wm2000 = dev_get_drvdata(codec->dev);\r\nint val = ucontrol->value.integer.value[0];\r\nint ret;\r\nif (val > 1)\r\nreturn -EINVAL;\r\nmutex_lock(&wm2000->lock);\r\nwm2000->spk_ena = val;\r\nret = wm2000_anc_set_mode(wm2000);\r\nmutex_unlock(&wm2000->lock);\r\nreturn ret;\r\n}\r\nstatic int wm2000_anc_power_event(struct snd_soc_dapm_widget *w,\r\nstruct snd_kcontrol *kcontrol, int event)\r\n{\r\nstruct snd_soc_codec *codec = snd_soc_dapm_to_codec(w->dapm);\r\nstruct wm2000_priv *wm2000 = dev_get_drvdata(codec->dev);\r\nint ret;\r\nmutex_lock(&wm2000->lock);\r\nif (SND_SOC_DAPM_EVENT_ON(event))\r\nwm2000->anc_eng_ena = 1;\r\nif (SND_SOC_DAPM_EVENT_OFF(event))\r\nwm2000->anc_eng_ena = 0;\r\nret = wm2000_anc_set_mode(wm2000);\r\nmutex_unlock(&wm2000->lock);\r\nreturn ret;\r\n}\r\nstatic int wm2000_suspend(struct snd_soc_codec *codec)\r\n{\r\nstruct wm2000_priv *wm2000 = dev_get_drvdata(codec->dev);\r\nreturn wm2000_anc_transition(wm2000, ANC_OFF);\r\n}\r\nstatic int wm2000_resume(struct snd_soc_codec *codec)\r\n{\r\nstruct wm2000_priv *wm2000 = dev_get_drvdata(codec->dev);\r\nreturn wm2000_anc_set_mode(wm2000);\r\n}\r\nstatic bool wm2000_readable_reg(struct device *dev, unsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase WM2000_REG_SYS_START:\r\ncase WM2000_REG_ANC_GAIN_CTRL:\r\ncase WM2000_REG_MSE_TH1:\r\ncase WM2000_REG_MSE_TH2:\r\ncase WM2000_REG_SPEECH_CLARITY:\r\ncase WM2000_REG_SYS_WATCHDOG:\r\ncase WM2000_REG_ANA_VMID_PD_TIME:\r\ncase WM2000_REG_ANA_VMID_PU_TIME:\r\ncase WM2000_REG_CAT_FLTR_INDX:\r\ncase WM2000_REG_CAT_GAIN_0:\r\ncase WM2000_REG_SYS_STATUS:\r\ncase WM2000_REG_SYS_MODE_CNTRL:\r\ncase WM2000_REG_SYS_START0:\r\ncase WM2000_REG_SYS_START1:\r\ncase WM2000_REG_ID1:\r\ncase WM2000_REG_ID2:\r\ncase WM2000_REG_REVISON:\r\ncase WM2000_REG_SYS_CTL1:\r\ncase WM2000_REG_SYS_CTL2:\r\ncase WM2000_REG_ANC_STAT:\r\ncase WM2000_REG_IF_CTL:\r\ncase WM2000_REG_ANA_MIC_CTL:\r\ncase WM2000_REG_SPK_CTL:\r\nreturn true;\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nstatic int wm2000_probe(struct snd_soc_codec *codec)\r\n{\r\nstruct wm2000_priv *wm2000 = dev_get_drvdata(codec->dev);\r\nwm2000_anc_set_mode(wm2000);\r\nreturn 0;\r\n}\r\nstatic int wm2000_remove(struct snd_soc_codec *codec)\r\n{\r\nstruct wm2000_priv *wm2000 = dev_get_drvdata(codec->dev);\r\nreturn wm2000_anc_transition(wm2000, ANC_OFF);\r\n}\r\nstatic int wm2000_i2c_probe(struct i2c_client *i2c,\r\nconst struct i2c_device_id *i2c_id)\r\n{\r\nstruct wm2000_priv *wm2000;\r\nstruct wm2000_platform_data *pdata;\r\nconst char *filename;\r\nconst struct firmware *fw = NULL;\r\nint ret, i;\r\nint reg;\r\nu16 id;\r\nwm2000 = devm_kzalloc(&i2c->dev, sizeof(struct wm2000_priv),\r\nGFP_KERNEL);\r\nif (!wm2000)\r\nreturn -ENOMEM;\r\nmutex_init(&wm2000->lock);\r\ndev_set_drvdata(&i2c->dev, wm2000);\r\nwm2000->regmap = devm_regmap_init_i2c(i2c, &wm2000_regmap);\r\nif (IS_ERR(wm2000->regmap)) {\r\nret = PTR_ERR(wm2000->regmap);\r\ndev_err(&i2c->dev, "Failed to allocate register map: %d\n",\r\nret);\r\ngoto out;\r\n}\r\nfor (i = 0; i < WM2000_NUM_SUPPLIES; i++)\r\nwm2000->supplies[i].supply = wm2000_supplies[i];\r\nret = devm_regulator_bulk_get(&i2c->dev, WM2000_NUM_SUPPLIES,\r\nwm2000->supplies);\r\nif (ret != 0) {\r\ndev_err(&i2c->dev, "Failed to get supplies: %d\n", ret);\r\nreturn ret;\r\n}\r\nret = regulator_bulk_enable(WM2000_NUM_SUPPLIES, wm2000->supplies);\r\nif (ret != 0) {\r\ndev_err(&i2c->dev, "Failed to enable supplies: %d\n", ret);\r\nreturn ret;\r\n}\r\nreg = wm2000_read(i2c, WM2000_REG_ID1);\r\nid = reg << 8;\r\nreg = wm2000_read(i2c, WM2000_REG_ID2);\r\nid |= reg & 0xff;\r\nif (id != 0x2000) {\r\ndev_err(&i2c->dev, "Device is not a WM2000 - ID %x\n", id);\r\nret = -ENODEV;\r\ngoto err_supplies;\r\n}\r\nreg = wm2000_read(i2c, WM2000_REG_REVISON);\r\ndev_info(&i2c->dev, "revision %c\n", reg + 'A');\r\nwm2000->mclk = devm_clk_get(&i2c->dev, "MCLK");\r\nif (IS_ERR(wm2000->mclk)) {\r\nret = PTR_ERR(wm2000->mclk);\r\ndev_err(&i2c->dev, "Failed to get MCLK: %d\n", ret);\r\ngoto err_supplies;\r\n}\r\nfilename = "wm2000_anc.bin";\r\npdata = dev_get_platdata(&i2c->dev);\r\nif (pdata) {\r\nwm2000->speech_clarity = !pdata->speech_enh_disable;\r\nif (pdata->download_file)\r\nfilename = pdata->download_file;\r\n}\r\nret = request_firmware(&fw, filename, &i2c->dev);\r\nif (ret != 0) {\r\ndev_err(&i2c->dev, "Failed to acquire ANC data: %d\n", ret);\r\ngoto err_supplies;\r\n}\r\nwm2000->anc_download_size = fw->size + 2;\r\nwm2000->anc_download = devm_kzalloc(&i2c->dev,\r\nwm2000->anc_download_size,\r\nGFP_KERNEL);\r\nif (wm2000->anc_download == NULL) {\r\ndev_err(&i2c->dev, "Out of memory\n");\r\nret = -ENOMEM;\r\ngoto err_supplies;\r\n}\r\nwm2000->anc_download[0] = 0x80;\r\nwm2000->anc_download[1] = 0x00;\r\nmemcpy(wm2000->anc_download + 2, fw->data, fw->size);\r\nwm2000->anc_eng_ena = 1;\r\nwm2000->anc_active = 1;\r\nwm2000->spk_ena = 1;\r\nwm2000->i2c = i2c;\r\nwm2000_reset(wm2000);\r\nret = snd_soc_register_codec(&i2c->dev, &soc_codec_dev_wm2000, NULL, 0);\r\nerr_supplies:\r\nregulator_bulk_disable(WM2000_NUM_SUPPLIES, wm2000->supplies);\r\nout:\r\nrelease_firmware(fw);\r\nreturn ret;\r\n}\r\nstatic int wm2000_i2c_remove(struct i2c_client *i2c)\r\n{\r\nsnd_soc_unregister_codec(&i2c->dev);\r\nreturn 0;\r\n}
