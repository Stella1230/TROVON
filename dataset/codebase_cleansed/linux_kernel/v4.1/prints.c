static char *reiserfs_cpu_offset(struct cpu_key *key)\r\n{\r\nif (cpu_key_k_type(key) == TYPE_DIRENTRY)\r\nsprintf(off_buf, "%llu(%llu)",\r\n(unsigned long long)\r\nGET_HASH_VALUE(cpu_key_k_offset(key)),\r\n(unsigned long long)\r\nGET_GENERATION_NUMBER(cpu_key_k_offset(key)));\r\nelse\r\nsprintf(off_buf, "0x%Lx",\r\n(unsigned long long)cpu_key_k_offset(key));\r\nreturn off_buf;\r\n}\r\nstatic char *le_offset(struct reiserfs_key *key)\r\n{\r\nint version;\r\nversion = le_key_version(key);\r\nif (le_key_k_type(version, key) == TYPE_DIRENTRY)\r\nsprintf(off_buf, "%llu(%llu)",\r\n(unsigned long long)\r\nGET_HASH_VALUE(le_key_k_offset(version, key)),\r\n(unsigned long long)\r\nGET_GENERATION_NUMBER(le_key_k_offset(version, key)));\r\nelse\r\nsprintf(off_buf, "0x%Lx",\r\n(unsigned long long)le_key_k_offset(version, key));\r\nreturn off_buf;\r\n}\r\nstatic char *cpu_type(struct cpu_key *key)\r\n{\r\nif (cpu_key_k_type(key) == TYPE_STAT_DATA)\r\nreturn "SD";\r\nif (cpu_key_k_type(key) == TYPE_DIRENTRY)\r\nreturn "DIR";\r\nif (cpu_key_k_type(key) == TYPE_DIRECT)\r\nreturn "DIRECT";\r\nif (cpu_key_k_type(key) == TYPE_INDIRECT)\r\nreturn "IND";\r\nreturn "UNKNOWN";\r\n}\r\nstatic char *le_type(struct reiserfs_key *key)\r\n{\r\nint version;\r\nversion = le_key_version(key);\r\nif (le_key_k_type(version, key) == TYPE_STAT_DATA)\r\nreturn "SD";\r\nif (le_key_k_type(version, key) == TYPE_DIRENTRY)\r\nreturn "DIR";\r\nif (le_key_k_type(version, key) == TYPE_DIRECT)\r\nreturn "DIRECT";\r\nif (le_key_k_type(version, key) == TYPE_INDIRECT)\r\nreturn "IND";\r\nreturn "UNKNOWN";\r\n}\r\nstatic void sprintf_le_key(char *buf, struct reiserfs_key *key)\r\n{\r\nif (key)\r\nsprintf(buf, "[%d %d %s %s]", le32_to_cpu(key->k_dir_id),\r\nle32_to_cpu(key->k_objectid), le_offset(key),\r\nle_type(key));\r\nelse\r\nsprintf(buf, "[NULL]");\r\n}\r\nstatic void sprintf_cpu_key(char *buf, struct cpu_key *key)\r\n{\r\nif (key)\r\nsprintf(buf, "[%d %d %s %s]", key->on_disk_key.k_dir_id,\r\nkey->on_disk_key.k_objectid, reiserfs_cpu_offset(key),\r\ncpu_type(key));\r\nelse\r\nsprintf(buf, "[NULL]");\r\n}\r\nstatic void sprintf_de_head(char *buf, struct reiserfs_de_head *deh)\r\n{\r\nif (deh)\r\nsprintf(buf,\r\n"[offset=%d dir_id=%d objectid=%d location=%d state=%04x]",\r\ndeh_offset(deh), deh_dir_id(deh), deh_objectid(deh),\r\ndeh_location(deh), deh_state(deh));\r\nelse\r\nsprintf(buf, "[NULL]");\r\n}\r\nstatic void sprintf_item_head(char *buf, struct item_head *ih)\r\n{\r\nif (ih) {\r\nstrcpy(buf,\r\n(ih_version(ih) == KEY_FORMAT_3_6) ? "*3.6* " : "*3.5*");\r\nsprintf_le_key(buf + strlen(buf), &(ih->ih_key));\r\nsprintf(buf + strlen(buf), ", item_len %d, item_location %d, "\r\n"free_space(entry_count) %d",\r\nih_item_len(ih), ih_location(ih), ih_free_space(ih));\r\n} else\r\nsprintf(buf, "[NULL]");\r\n}\r\nstatic void sprintf_direntry(char *buf, struct reiserfs_dir_entry *de)\r\n{\r\nchar name[20];\r\nmemcpy(name, de->de_name, de->de_namelen > 19 ? 19 : de->de_namelen);\r\nname[de->de_namelen > 19 ? 19 : de->de_namelen] = 0;\r\nsprintf(buf, "\"%s\"==>[%d %d]", name, de->de_dir_id, de->de_objectid);\r\n}\r\nstatic void sprintf_block_head(char *buf, struct buffer_head *bh)\r\n{\r\nsprintf(buf, "level=%d, nr_items=%d, free_space=%d rdkey ",\r\nB_LEVEL(bh), B_NR_ITEMS(bh), B_FREE_SPACE(bh));\r\n}\r\nstatic void sprintf_buffer_head(char *buf, struct buffer_head *bh)\r\n{\r\nchar b[BDEVNAME_SIZE];\r\nsprintf(buf,\r\n"dev %s, size %zd, blocknr %llu, count %d, state 0x%lx, page %p, (%s, %s, %s)",\r\nbdevname(bh->b_bdev, b), bh->b_size,\r\n(unsigned long long)bh->b_blocknr, atomic_read(&(bh->b_count)),\r\nbh->b_state, bh->b_page,\r\nbuffer_uptodate(bh) ? "UPTODATE" : "!UPTODATE",\r\nbuffer_dirty(bh) ? "DIRTY" : "CLEAN",\r\nbuffer_locked(bh) ? "LOCKED" : "UNLOCKED");\r\n}\r\nstatic void sprintf_disk_child(char *buf, struct disk_child *dc)\r\n{\r\nsprintf(buf, "[dc_number=%d, dc_size=%u]", dc_block_number(dc),\r\ndc_size(dc));\r\n}\r\nstatic char *is_there_reiserfs_struct(char *fmt, int *what)\r\n{\r\nchar *k = fmt;\r\nwhile ((k = strchr(k, '%')) != NULL) {\r\nif (k[1] == 'k' || k[1] == 'K' || k[1] == 'h' || k[1] == 't' ||\r\nk[1] == 'z' || k[1] == 'b' || k[1] == 'y' || k[1] == 'a') {\r\n*what = k[1];\r\nbreak;\r\n}\r\nk++;\r\n}\r\nreturn k;\r\n}\r\nstatic void prepare_error_buf(const char *fmt, va_list args)\r\n{\r\nchar *fmt1 = fmt_buf;\r\nchar *k;\r\nchar *p = error_buf;\r\nint what;\r\nspin_lock(&error_lock);\r\nstrcpy(fmt1, fmt);\r\nwhile ((k = is_there_reiserfs_struct(fmt1, &what)) != NULL) {\r\n*k = 0;\r\np += vsprintf(p, fmt1, args);\r\nswitch (what) {\r\ncase 'k':\r\nsprintf_le_key(p, va_arg(args, struct reiserfs_key *));\r\nbreak;\r\ncase 'K':\r\nsprintf_cpu_key(p, va_arg(args, struct cpu_key *));\r\nbreak;\r\ncase 'h':\r\nsprintf_item_head(p, va_arg(args, struct item_head *));\r\nbreak;\r\ncase 't':\r\nsprintf_direntry(p,\r\nva_arg(args,\r\nstruct reiserfs_dir_entry *));\r\nbreak;\r\ncase 'y':\r\nsprintf_disk_child(p,\r\nva_arg(args, struct disk_child *));\r\nbreak;\r\ncase 'z':\r\nsprintf_block_head(p,\r\nva_arg(args, struct buffer_head *));\r\nbreak;\r\ncase 'b':\r\nsprintf_buffer_head(p,\r\nva_arg(args, struct buffer_head *));\r\nbreak;\r\ncase 'a':\r\nsprintf_de_head(p,\r\nva_arg(args,\r\nstruct reiserfs_de_head *));\r\nbreak;\r\n}\r\np += strlen(p);\r\nfmt1 = k + 2;\r\n}\r\nvsprintf(p, fmt1, args);\r\nspin_unlock(&error_lock);\r\n}\r\nvoid __reiserfs_warning(struct super_block *sb, const char *id,\r\nconst char *function, const char *fmt, ...)\r\n{\r\ndo_reiserfs_warning(fmt);\r\nif (sb)\r\nprintk(KERN_WARNING "REISERFS warning (device %s): %s%s%s: "\r\n"%s\n", sb->s_id, id ? id : "", id ? " " : "",\r\nfunction, error_buf);\r\nelse\r\nprintk(KERN_WARNING "REISERFS warning: %s%s%s: %s\n",\r\nid ? id : "", id ? " " : "", function, error_buf);\r\n}\r\nvoid reiserfs_info(struct super_block *sb, const char *fmt, ...)\r\n{\r\ndo_reiserfs_warning(fmt);\r\nif (sb)\r\nprintk(KERN_NOTICE "REISERFS (device %s): %s",\r\nsb->s_id, error_buf);\r\nelse\r\nprintk(KERN_NOTICE "REISERFS %s:", error_buf);\r\n}\r\nstatic void reiserfs_printk(const char *fmt, ...)\r\n{\r\ndo_reiserfs_warning(fmt);\r\nprintk(error_buf);\r\n}\r\nvoid reiserfs_debug(struct super_block *s, int level, const char *fmt, ...)\r\n{\r\n#ifdef CONFIG_REISERFS_CHECK\r\ndo_reiserfs_warning(fmt);\r\nif (s)\r\nprintk(KERN_DEBUG "REISERFS debug (device %s): %s\n",\r\ns->s_id, error_buf);\r\nelse\r\nprintk(KERN_DEBUG "REISERFS debug: %s\n", error_buf);\r\n#endif\r\n}\r\nvoid __reiserfs_panic(struct super_block *sb, const char *id,\r\nconst char *function, const char *fmt, ...)\r\n{\r\ndo_reiserfs_warning(fmt);\r\n#ifdef CONFIG_REISERFS_CHECK\r\ndump_stack();\r\n#endif\r\nif (sb)\r\nprintk(KERN_WARNING "REISERFS panic (device %s): %s%s%s: %s\n",\r\nsb->s_id, id ? id : "", id ? " " : "",\r\nfunction, error_buf);\r\nelse\r\nprintk(KERN_WARNING "REISERFS panic: %s%s%s: %s\n",\r\nid ? id : "", id ? " " : "", function, error_buf);\r\nBUG();\r\n}\r\nvoid __reiserfs_error(struct super_block *sb, const char *id,\r\nconst char *function, const char *fmt, ...)\r\n{\r\ndo_reiserfs_warning(fmt);\r\nBUG_ON(sb == NULL);\r\nif (reiserfs_error_panic(sb))\r\n__reiserfs_panic(sb, id, function, error_buf);\r\nif (id && id[0])\r\nprintk(KERN_CRIT "REISERFS error (device %s): %s %s: %s\n",\r\nsb->s_id, id, function, error_buf);\r\nelse\r\nprintk(KERN_CRIT "REISERFS error (device %s): %s: %s\n",\r\nsb->s_id, function, error_buf);\r\nif (sb->s_flags & MS_RDONLY)\r\nreturn;\r\nreiserfs_info(sb, "Remounting filesystem read-only\n");\r\nsb->s_flags |= MS_RDONLY;\r\nreiserfs_abort_journal(sb, -EIO);\r\n}\r\nvoid reiserfs_abort(struct super_block *sb, int errno, const char *fmt, ...)\r\n{\r\ndo_reiserfs_warning(fmt);\r\nif (reiserfs_error_panic(sb)) {\r\npanic(KERN_CRIT "REISERFS panic (device %s): %s\n", sb->s_id,\r\nerror_buf);\r\n}\r\nif (reiserfs_is_journal_aborted(SB_JOURNAL(sb)))\r\nreturn;\r\nprintk(KERN_CRIT "REISERFS abort (device %s): %s\n", sb->s_id,\r\nerror_buf);\r\nsb->s_flags |= MS_RDONLY;\r\nreiserfs_abort_journal(sb, errno);\r\n}\r\nstatic int print_internal(struct buffer_head *bh, int first, int last)\r\n{\r\nstruct reiserfs_key *key;\r\nstruct disk_child *dc;\r\nint i;\r\nint from, to;\r\nif (!B_IS_KEYS_LEVEL(bh))\r\nreturn 1;\r\ncheck_internal(bh);\r\nif (first == -1) {\r\nfrom = 0;\r\nto = B_NR_ITEMS(bh);\r\n} else {\r\nfrom = first;\r\nto = last < B_NR_ITEMS(bh) ? last : B_NR_ITEMS(bh);\r\n}\r\nreiserfs_printk("INTERNAL NODE (%ld) contains %z\n", bh->b_blocknr, bh);\r\ndc = B_N_CHILD(bh, from);\r\nreiserfs_printk("PTR %d: %y ", from, dc);\r\nfor (i = from, key = internal_key(bh, from), dc++; i < to;\r\ni++, key++, dc++) {\r\nreiserfs_printk("KEY %d: %k PTR %d: %y ", i, key, i + 1, dc);\r\nif (i && i % 4 == 0)\r\nprintk("\n");\r\n}\r\nprintk("\n");\r\nreturn 0;\r\n}\r\nstatic int print_leaf(struct buffer_head *bh, int print_mode, int first,\r\nint last)\r\n{\r\nstruct block_head *blkh;\r\nstruct item_head *ih;\r\nint i, nr;\r\nint from, to;\r\nif (!B_IS_ITEMS_LEVEL(bh))\r\nreturn 1;\r\ncheck_leaf(bh);\r\nblkh = B_BLK_HEAD(bh);\r\nih = item_head(bh, 0);\r\nnr = blkh_nr_item(blkh);\r\nprintk\r\n("\n===================================================================\n");\r\nreiserfs_printk("LEAF NODE (%ld) contains %z\n", bh->b_blocknr, bh);\r\nif (!(print_mode & PRINT_LEAF_ITEMS)) {\r\nreiserfs_printk("FIRST ITEM_KEY: %k, LAST ITEM KEY: %k\n",\r\n&(ih->ih_key), &((ih + nr - 1)->ih_key));\r\nreturn 0;\r\n}\r\nif (first < 0 || first > nr - 1)\r\nfrom = 0;\r\nelse\r\nfrom = first;\r\nif (last < 0 || last > nr)\r\nto = nr;\r\nelse\r\nto = last;\r\nih += from;\r\nprintk\r\n("-------------------------------------------------------------------------------\n");\r\nprintk\r\n("|##| type | key | ilen | free_space | version | loc |\n");\r\nfor (i = from; i < to; i++, ih++) {\r\nprintk\r\n("-------------------------------------------------------------------------------\n");\r\nreiserfs_printk("|%2d| %h |\n", i, ih);\r\nif (print_mode & PRINT_LEAF_ITEMS)\r\nop_print_item(ih, ih_item_body(bh, ih));\r\n}\r\nprintk\r\n("===================================================================\n");\r\nreturn 0;\r\n}\r\nchar *reiserfs_hashname(int code)\r\n{\r\nif (code == YURA_HASH)\r\nreturn "rupasov";\r\nif (code == TEA_HASH)\r\nreturn "tea";\r\nif (code == R5_HASH)\r\nreturn "r5";\r\nreturn "unknown";\r\n}\r\nstatic int print_super_block(struct buffer_head *bh)\r\n{\r\nstruct reiserfs_super_block *rs =\r\n(struct reiserfs_super_block *)(bh->b_data);\r\nint skipped, data_blocks;\r\nchar *version;\r\nchar b[BDEVNAME_SIZE];\r\nif (is_reiserfs_3_5(rs)) {\r\nversion = "3.5";\r\n} else if (is_reiserfs_3_6(rs)) {\r\nversion = "3.6";\r\n} else if (is_reiserfs_jr(rs)) {\r\nversion = ((sb_version(rs) == REISERFS_VERSION_2) ?\r\n"3.6" : "3.5");\r\n} else {\r\nreturn 1;\r\n}\r\nprintk("%s\'s super block is in block %llu\n", bdevname(bh->b_bdev, b),\r\n(unsigned long long)bh->b_blocknr);\r\nprintk("Reiserfs version %s\n", version);\r\nprintk("Block count %u\n", sb_block_count(rs));\r\nprintk("Blocksize %d\n", sb_blocksize(rs));\r\nprintk("Free blocks %u\n", sb_free_blocks(rs));\r\nskipped = bh->b_blocknr;\r\ndata_blocks = sb_block_count(rs) - skipped - 1 - sb_bmap_nr(rs) -\r\n(!is_reiserfs_jr(rs) ? sb_jp_journal_size(rs) +\r\n1 : sb_reserved_for_journal(rs)) - sb_free_blocks(rs);\r\nprintk\r\n("Busy blocks (skipped %d, bitmaps - %d, journal (or reserved) blocks - %d\n"\r\n"1 super block, %d data blocks\n", skipped, sb_bmap_nr(rs),\r\n(!is_reiserfs_jr(rs) ? (sb_jp_journal_size(rs) + 1) :\r\nsb_reserved_for_journal(rs)), data_blocks);\r\nprintk("Root block %u\n", sb_root_block(rs));\r\nprintk("Journal block (first) %d\n", sb_jp_journal_1st_block(rs));\r\nprintk("Journal dev %d\n", sb_jp_journal_dev(rs));\r\nprintk("Journal orig size %d\n", sb_jp_journal_size(rs));\r\nprintk("FS state %d\n", sb_fs_state(rs));\r\nprintk("Hash function \"%s\"\n",\r\nreiserfs_hashname(sb_hash_function_code(rs)));\r\nprintk("Tree height %d\n", sb_tree_height(rs));\r\nreturn 0;\r\n}\r\nstatic int print_desc_block(struct buffer_head *bh)\r\n{\r\nstruct reiserfs_journal_desc *desc;\r\nif (memcmp(get_journal_desc_magic(bh), JOURNAL_DESC_MAGIC, 8))\r\nreturn 1;\r\ndesc = (struct reiserfs_journal_desc *)(bh->b_data);\r\nprintk("Desc block %llu (j_trans_id %d, j_mount_id %d, j_len %d)",\r\n(unsigned long long)bh->b_blocknr, get_desc_trans_id(desc),\r\nget_desc_mount_id(desc), get_desc_trans_len(desc));\r\nreturn 0;\r\n}\r\nvoid print_block(struct buffer_head *bh, ...)\r\n{\r\nva_list args;\r\nint mode, first, last;\r\nif (!bh) {\r\nprintk("print_block: buffer is NULL\n");\r\nreturn;\r\n}\r\nva_start(args, bh);\r\nmode = va_arg(args, int);\r\nfirst = va_arg(args, int);\r\nlast = va_arg(args, int);\r\nif (print_leaf(bh, mode, first, last))\r\nif (print_internal(bh, first, last))\r\nif (print_super_block(bh))\r\nif (print_desc_block(bh))\r\nprintk\r\n("Block %llu contains unformatted data\n",\r\n(unsigned long long)bh->b_blocknr);\r\nva_end(args);\r\n}\r\nvoid store_print_tb(struct tree_balance *tb)\r\n{\r\nint h = 0;\r\nint i;\r\nstruct buffer_head *tbSh, *tbFh;\r\nif (!tb)\r\nreturn;\r\nsprintf(print_tb_buf, "\n"\r\n"BALANCING %d\n"\r\n"MODE=%c, ITEM_POS=%d POS_IN_ITEM=%d\n"\r\n"=====================================================================\n"\r\n"* h * S * L * R * F * FL * FR * CFL * CFR *\n",\r\nREISERFS_SB(tb->tb_sb)->s_do_balance,\r\ntb->tb_mode, PATH_LAST_POSITION(tb->tb_path),\r\ntb->tb_path->pos_in_item);\r\nfor (h = 0; h < ARRAY_SIZE(tb->insert_size); h++) {\r\nif (PATH_H_PATH_OFFSET(tb->tb_path, h) <=\r\ntb->tb_path->path_length\r\n&& PATH_H_PATH_OFFSET(tb->tb_path,\r\nh) > ILLEGAL_PATH_ELEMENT_OFFSET) {\r\ntbSh = PATH_H_PBUFFER(tb->tb_path, h);\r\ntbFh = PATH_H_PPARENT(tb->tb_path, h);\r\n} else {\r\ntbSh = NULL;\r\ntbFh = NULL;\r\n}\r\nsprintf(print_tb_buf + strlen(print_tb_buf),\r\n"* %d * %3lld(%2d) * %3lld(%2d) * %3lld(%2d) * %5lld * %5lld * %5lld * %5lld * %5lld *\n",\r\nh,\r\n(tbSh) ? (long long)(tbSh->b_blocknr) : (-1LL),\r\n(tbSh) ? atomic_read(&tbSh->b_count) : -1,\r\n(tb->L[h]) ? (long long)(tb->L[h]->b_blocknr) : (-1LL),\r\n(tb->L[h]) ? atomic_read(&tb->L[h]->b_count) : -1,\r\n(tb->R[h]) ? (long long)(tb->R[h]->b_blocknr) : (-1LL),\r\n(tb->R[h]) ? atomic_read(&tb->R[h]->b_count) : -1,\r\n(tbFh) ? (long long)(tbFh->b_blocknr) : (-1LL),\r\n(tb->FL[h]) ? (long long)(tb->FL[h]->\r\nb_blocknr) : (-1LL),\r\n(tb->FR[h]) ? (long long)(tb->FR[h]->\r\nb_blocknr) : (-1LL),\r\n(tb->CFL[h]) ? (long long)(tb->CFL[h]->\r\nb_blocknr) : (-1LL),\r\n(tb->CFR[h]) ? (long long)(tb->CFR[h]->\r\nb_blocknr) : (-1LL));\r\n}\r\nsprintf(print_tb_buf + strlen(print_tb_buf),\r\n"=====================================================================\n"\r\n"* h * size * ln * lb * rn * rb * blkn * s0 * s1 * s1b * s2 * s2b * curb * lk * rk *\n"\r\n"* 0 * %4d * %2d * %2d * %2d * %2d * %4d * %2d * %2d * %3d * %2d * %3d * %4d * %2d * %2d *\n",\r\ntb->insert_size[0], tb->lnum[0], tb->lbytes, tb->rnum[0],\r\ntb->rbytes, tb->blknum[0], tb->s0num, tb->snum[0],\r\ntb->sbytes[0], tb->snum[1], tb->sbytes[1],\r\ntb->cur_blknum, tb->lkey[0], tb->rkey[0]);\r\nh = 0;\r\ndo {\r\nh++;\r\nsprintf(print_tb_buf + strlen(print_tb_buf),\r\n"* %d * %4d * %2d * * %2d * * %2d *\n",\r\nh, tb->insert_size[h], tb->lnum[h], tb->rnum[h],\r\ntb->blknum[h]);\r\n} while (tb->insert_size[h]);\r\nsprintf(print_tb_buf + strlen(print_tb_buf),\r\n"=====================================================================\n"\r\n"FEB list: ");\r\nh = 0;\r\nfor (i = 0; i < ARRAY_SIZE(tb->FEB); i++)\r\nsprintf(print_tb_buf + strlen(print_tb_buf),\r\n"%p (%llu %d)%s", tb->FEB[i],\r\ntb->FEB[i] ? (unsigned long long)tb->FEB[i]->\r\nb_blocknr : 0ULL,\r\ntb->FEB[i] ? atomic_read(&tb->FEB[i]->b_count) : 0,\r\n(i == ARRAY_SIZE(tb->FEB) - 1) ? "\n" : ", ");\r\nsprintf(print_tb_buf + strlen(print_tb_buf),\r\n"======================== the end ====================================\n");\r\n}\r\nvoid print_cur_tb(char *mes)\r\n{\r\nprintk("%s\n%s", mes, print_tb_buf);\r\n}\r\nstatic void check_leaf_block_head(struct buffer_head *bh)\r\n{\r\nstruct block_head *blkh;\r\nint nr;\r\nblkh = B_BLK_HEAD(bh);\r\nnr = blkh_nr_item(blkh);\r\nif (nr > (bh->b_size - BLKH_SIZE) / IH_SIZE)\r\nreiserfs_panic(NULL, "vs-6010", "invalid item number %z",\r\nbh);\r\nif (blkh_free_space(blkh) > bh->b_size - BLKH_SIZE - IH_SIZE * nr)\r\nreiserfs_panic(NULL, "vs-6020", "invalid free space %z",\r\nbh);\r\n}\r\nstatic void check_internal_block_head(struct buffer_head *bh)\r\n{\r\nstruct block_head *blkh;\r\nblkh = B_BLK_HEAD(bh);\r\nif (!(B_LEVEL(bh) > DISK_LEAF_NODE_LEVEL && B_LEVEL(bh) <= MAX_HEIGHT))\r\nreiserfs_panic(NULL, "vs-6025", "invalid level %z", bh);\r\nif (B_NR_ITEMS(bh) > (bh->b_size - BLKH_SIZE) / IH_SIZE)\r\nreiserfs_panic(NULL, "vs-6030", "invalid item number %z", bh);\r\nif (B_FREE_SPACE(bh) !=\r\nbh->b_size - BLKH_SIZE - KEY_SIZE * B_NR_ITEMS(bh) -\r\nDC_SIZE * (B_NR_ITEMS(bh) + 1))\r\nreiserfs_panic(NULL, "vs-6040", "invalid free space %z", bh);\r\n}\r\nvoid check_leaf(struct buffer_head *bh)\r\n{\r\nint i;\r\nstruct item_head *ih;\r\nif (!bh)\r\nreturn;\r\ncheck_leaf_block_head(bh);\r\nfor (i = 0, ih = item_head(bh, 0); i < B_NR_ITEMS(bh); i++, ih++)\r\nop_check_item(ih, ih_item_body(bh, ih));\r\n}\r\nvoid check_internal(struct buffer_head *bh)\r\n{\r\nif (!bh)\r\nreturn;\r\ncheck_internal_block_head(bh);\r\n}\r\nvoid print_statistics(struct super_block *s)\r\n{\r\n}
