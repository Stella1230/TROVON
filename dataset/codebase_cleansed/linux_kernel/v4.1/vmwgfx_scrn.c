static void vmw_sou_destroy(struct vmw_screen_object_unit *sou)\r\n{\r\nvmw_display_unit_cleanup(&sou->base);\r\nkfree(sou);\r\n}\r\nstatic void vmw_sou_crtc_destroy(struct drm_crtc *crtc)\r\n{\r\nvmw_sou_destroy(vmw_crtc_to_sou(crtc));\r\n}\r\nstatic void vmw_sou_del_active(struct vmw_private *vmw_priv,\r\nstruct vmw_screen_object_unit *sou)\r\n{\r\nstruct vmw_screen_object_display *ld = vmw_priv->sou_priv;\r\nif (sou->active_implicit) {\r\nif (--(ld->num_implicit) == 0)\r\nld->implicit_fb = NULL;\r\nsou->active_implicit = false;\r\n}\r\n}\r\nstatic void vmw_sou_add_active(struct vmw_private *vmw_priv,\r\nstruct vmw_screen_object_unit *sou,\r\nstruct vmw_framebuffer *vfb)\r\n{\r\nstruct vmw_screen_object_display *ld = vmw_priv->sou_priv;\r\nBUG_ON(!ld->num_implicit && ld->implicit_fb);\r\nif (!sou->active_implicit && sou->base.is_implicit) {\r\nld->implicit_fb = vfb;\r\nsou->active_implicit = true;\r\nld->num_implicit++;\r\n}\r\n}\r\nstatic int vmw_sou_fifo_create(struct vmw_private *dev_priv,\r\nstruct vmw_screen_object_unit *sou,\r\nuint32_t x, uint32_t y,\r\nstruct drm_display_mode *mode)\r\n{\r\nsize_t fifo_size;\r\nstruct {\r\nstruct {\r\nuint32_t cmdType;\r\n} header;\r\nSVGAScreenObject obj;\r\n} *cmd;\r\nBUG_ON(!sou->buffer);\r\nfifo_size = sizeof(*cmd);\r\ncmd = vmw_fifo_reserve(dev_priv, fifo_size);\r\nif (unlikely(cmd == NULL)) {\r\nDRM_ERROR("Fifo reserve failed.\n");\r\nreturn -ENOMEM;\r\n}\r\nmemset(cmd, 0, fifo_size);\r\ncmd->header.cmdType = SVGA_CMD_DEFINE_SCREEN;\r\ncmd->obj.structSize = sizeof(SVGAScreenObject);\r\ncmd->obj.id = sou->base.unit;\r\ncmd->obj.flags = SVGA_SCREEN_HAS_ROOT |\r\n(sou->base.unit == 0 ? SVGA_SCREEN_IS_PRIMARY : 0);\r\ncmd->obj.size.width = mode->hdisplay;\r\ncmd->obj.size.height = mode->vdisplay;\r\nif (sou->base.is_implicit) {\r\ncmd->obj.root.x = x;\r\ncmd->obj.root.y = y;\r\n} else {\r\ncmd->obj.root.x = sou->base.gui_x;\r\ncmd->obj.root.y = sou->base.gui_y;\r\n}\r\nvmw_bo_get_guest_ptr(&sou->buffer->base, &cmd->obj.backingStore.ptr);\r\ncmd->obj.backingStore.pitch = mode->hdisplay * 4;\r\nvmw_fifo_commit(dev_priv, fifo_size);\r\nsou->defined = true;\r\nreturn 0;\r\n}\r\nstatic int vmw_sou_fifo_destroy(struct vmw_private *dev_priv,\r\nstruct vmw_screen_object_unit *sou)\r\n{\r\nsize_t fifo_size;\r\nint ret;\r\nstruct {\r\nstruct {\r\nuint32_t cmdType;\r\n} header;\r\nSVGAFifoCmdDestroyScreen body;\r\n} *cmd;\r\nif (unlikely(!sou->defined))\r\nreturn 0;\r\nfifo_size = sizeof(*cmd);\r\ncmd = vmw_fifo_reserve(dev_priv, fifo_size);\r\nif (unlikely(cmd == NULL)) {\r\nDRM_ERROR("Fifo reserve failed.\n");\r\nreturn -ENOMEM;\r\n}\r\nmemset(cmd, 0, fifo_size);\r\ncmd->header.cmdType = SVGA_CMD_DESTROY_SCREEN;\r\ncmd->body.screenId = sou->base.unit;\r\nvmw_fifo_commit(dev_priv, fifo_size);\r\nret = vmw_fallback_wait(dev_priv, false, true, 0, false, 3*HZ);\r\nif (unlikely(ret != 0))\r\nDRM_ERROR("Failed to sync with HW");\r\nelse\r\nsou->defined = false;\r\nreturn ret;\r\n}\r\nstatic void vmw_sou_backing_free(struct vmw_private *dev_priv,\r\nstruct vmw_screen_object_unit *sou)\r\n{\r\nstruct ttm_buffer_object *bo;\r\nif (unlikely(sou->buffer == NULL))\r\nreturn;\r\nbo = &sou->buffer->base;\r\nttm_bo_unref(&bo);\r\nsou->buffer = NULL;\r\nsou->buffer_size = 0;\r\n}\r\nstatic int vmw_sou_backing_alloc(struct vmw_private *dev_priv,\r\nstruct vmw_screen_object_unit *sou,\r\nunsigned long size)\r\n{\r\nint ret;\r\nif (sou->buffer_size == size)\r\nreturn 0;\r\nif (sou->buffer)\r\nvmw_sou_backing_free(dev_priv, sou);\r\nsou->buffer = kzalloc(sizeof(*sou->buffer), GFP_KERNEL);\r\nif (unlikely(sou->buffer == NULL))\r\nreturn -ENOMEM;\r\nvmw_overlay_pause_all(dev_priv);\r\nret = vmw_dmabuf_init(dev_priv, sou->buffer, size,\r\n&vmw_vram_ne_placement,\r\nfalse, &vmw_dmabuf_bo_free);\r\nvmw_overlay_resume_all(dev_priv);\r\nif (unlikely(ret != 0))\r\nsou->buffer = NULL;\r\nelse\r\nsou->buffer_size = size;\r\nreturn ret;\r\n}\r\nstatic int vmw_sou_crtc_set_config(struct drm_mode_set *set)\r\n{\r\nstruct vmw_private *dev_priv;\r\nstruct vmw_screen_object_unit *sou;\r\nstruct drm_connector *connector;\r\nstruct drm_display_mode *mode;\r\nstruct drm_encoder *encoder;\r\nstruct vmw_framebuffer *vfb;\r\nstruct drm_framebuffer *fb;\r\nstruct drm_crtc *crtc;\r\nint ret = 0;\r\nif (!set)\r\nreturn -EINVAL;\r\nif (!set->crtc)\r\nreturn -EINVAL;\r\ncrtc = set->crtc;\r\nsou = vmw_crtc_to_sou(crtc);\r\nvfb = set->fb ? vmw_framebuffer_to_vfb(set->fb) : NULL;\r\ndev_priv = vmw_priv(crtc->dev);\r\nif (set->num_connectors > 1) {\r\nDRM_ERROR("to many connectors\n");\r\nreturn -EINVAL;\r\n}\r\nif (set->num_connectors == 1 &&\r\nset->connectors[0] != &sou->base.connector) {\r\nDRM_ERROR("connector doesn't match %p %p\n",\r\nset->connectors[0], &sou->base.connector);\r\nreturn -EINVAL;\r\n}\r\nif (sou->base.is_implicit &&\r\ndev_priv->sou_priv->implicit_fb && vfb &&\r\n!(dev_priv->sou_priv->num_implicit == 1 &&\r\nsou->active_implicit) &&\r\ndev_priv->sou_priv->implicit_fb != vfb) {\r\nDRM_ERROR("Multiple framebuffers not supported\n");\r\nreturn -EINVAL;\r\n}\r\nconnector = &sou->base.connector;\r\nencoder = &sou->base.encoder;\r\nif (set->num_connectors == 0 || !set->mode || !set->fb) {\r\nret = vmw_sou_fifo_destroy(dev_priv, sou);\r\nif (unlikely(ret != 0))\r\nreturn ret;\r\nconnector->encoder = NULL;\r\nencoder->crtc = NULL;\r\ncrtc->primary->fb = NULL;\r\ncrtc->x = 0;\r\ncrtc->y = 0;\r\ncrtc->enabled = false;\r\nvmw_sou_del_active(dev_priv, sou);\r\nvmw_sou_backing_free(dev_priv, sou);\r\nreturn 0;\r\n}\r\nmode = set->mode;\r\nfb = set->fb;\r\nif (set->x + mode->hdisplay > fb->width ||\r\nset->y + mode->vdisplay > fb->height) {\r\nDRM_ERROR("set outside of framebuffer\n");\r\nreturn -EINVAL;\r\n}\r\nvmw_fb_off(dev_priv);\r\nif (mode->hdisplay != crtc->mode.hdisplay ||\r\nmode->vdisplay != crtc->mode.vdisplay) {\r\nret = vmw_sou_fifo_destroy(dev_priv, sou);\r\nif (unlikely(ret != 0))\r\nreturn ret;\r\nvmw_sou_backing_free(dev_priv, sou);\r\n}\r\nif (!sou->buffer) {\r\nsize_t size = mode->hdisplay * mode->vdisplay * 4;\r\nret = vmw_sou_backing_alloc(dev_priv, sou, size);\r\nif (unlikely(ret != 0))\r\nreturn ret;\r\n}\r\nret = vmw_sou_fifo_create(dev_priv, sou, set->x, set->y, mode);\r\nif (unlikely(ret != 0)) {\r\nif (sou->defined)\r\nreturn ret;\r\nconnector->encoder = NULL;\r\nencoder->crtc = NULL;\r\ncrtc->primary->fb = NULL;\r\ncrtc->x = 0;\r\ncrtc->y = 0;\r\ncrtc->enabled = false;\r\nreturn ret;\r\n}\r\nvmw_sou_add_active(dev_priv, sou, vfb);\r\nconnector->encoder = encoder;\r\nencoder->crtc = crtc;\r\ncrtc->mode = *mode;\r\ncrtc->primary->fb = fb;\r\ncrtc->x = set->x;\r\ncrtc->y = set->y;\r\ncrtc->enabled = true;\r\nreturn 0;\r\n}\r\nstatic void vmw_sou_encoder_destroy(struct drm_encoder *encoder)\r\n{\r\nvmw_sou_destroy(vmw_encoder_to_sou(encoder));\r\n}\r\nstatic void vmw_sou_connector_destroy(struct drm_connector *connector)\r\n{\r\nvmw_sou_destroy(vmw_connector_to_sou(connector));\r\n}\r\nstatic int vmw_sou_init(struct vmw_private *dev_priv, unsigned unit)\r\n{\r\nstruct vmw_screen_object_unit *sou;\r\nstruct drm_device *dev = dev_priv->dev;\r\nstruct drm_connector *connector;\r\nstruct drm_encoder *encoder;\r\nstruct drm_crtc *crtc;\r\nsou = kzalloc(sizeof(*sou), GFP_KERNEL);\r\nif (!sou)\r\nreturn -ENOMEM;\r\nsou->base.unit = unit;\r\ncrtc = &sou->base.crtc;\r\nencoder = &sou->base.encoder;\r\nconnector = &sou->base.connector;\r\nsou->active_implicit = false;\r\nsou->base.pref_active = (unit == 0);\r\nsou->base.pref_width = dev_priv->initial_width;\r\nsou->base.pref_height = dev_priv->initial_height;\r\nsou->base.pref_mode = NULL;\r\nsou->base.is_implicit = true;\r\ndrm_connector_init(dev, connector, &vmw_legacy_connector_funcs,\r\nDRM_MODE_CONNECTOR_VIRTUAL);\r\nconnector->status = vmw_du_connector_detect(connector, true);\r\ndrm_encoder_init(dev, encoder, &vmw_screen_object_encoder_funcs,\r\nDRM_MODE_ENCODER_VIRTUAL);\r\ndrm_mode_connector_attach_encoder(connector, encoder);\r\nencoder->possible_crtcs = (1 << unit);\r\nencoder->possible_clones = 0;\r\n(void) drm_connector_register(connector);\r\ndrm_crtc_init(dev, crtc, &vmw_screen_object_crtc_funcs);\r\ndrm_mode_crtc_set_gamma_size(crtc, 256);\r\ndrm_object_attach_property(&connector->base,\r\ndev->mode_config.dirty_info_property,\r\n1);\r\nreturn 0;\r\n}\r\nint vmw_kms_init_screen_object_display(struct vmw_private *dev_priv)\r\n{\r\nstruct drm_device *dev = dev_priv->dev;\r\nint i, ret;\r\nif (dev_priv->sou_priv) {\r\nDRM_INFO("sou system already on\n");\r\nreturn -EINVAL;\r\n}\r\nif (!(dev_priv->capabilities & SVGA_CAP_SCREEN_OBJECT_2)) {\r\nDRM_INFO("Not using screen objects,"\r\n" missing cap SCREEN_OBJECT_2\n");\r\nreturn -ENOSYS;\r\n}\r\nret = -ENOMEM;\r\ndev_priv->sou_priv = kmalloc(sizeof(*dev_priv->sou_priv), GFP_KERNEL);\r\nif (unlikely(!dev_priv->sou_priv))\r\ngoto err_no_mem;\r\ndev_priv->sou_priv->num_implicit = 0;\r\ndev_priv->sou_priv->implicit_fb = NULL;\r\nret = drm_vblank_init(dev, VMWGFX_NUM_DISPLAY_UNITS);\r\nif (unlikely(ret != 0))\r\ngoto err_free;\r\nret = drm_mode_create_dirty_info_property(dev);\r\nif (unlikely(ret != 0))\r\ngoto err_vblank_cleanup;\r\nfor (i = 0; i < VMWGFX_NUM_DISPLAY_UNITS; ++i)\r\nvmw_sou_init(dev_priv, i);\r\nDRM_INFO("Screen objects system initialized\n");\r\nreturn 0;\r\nerr_vblank_cleanup:\r\ndrm_vblank_cleanup(dev);\r\nerr_free:\r\nkfree(dev_priv->sou_priv);\r\ndev_priv->sou_priv = NULL;\r\nerr_no_mem:\r\nreturn ret;\r\n}\r\nint vmw_kms_close_screen_object_display(struct vmw_private *dev_priv)\r\n{\r\nstruct drm_device *dev = dev_priv->dev;\r\nif (!dev_priv->sou_priv)\r\nreturn -ENOSYS;\r\ndrm_vblank_cleanup(dev);\r\nkfree(dev_priv->sou_priv);\r\nreturn 0;\r\n}\r\nbool vmw_kms_screen_object_flippable(struct vmw_private *dev_priv,\r\nstruct drm_crtc *crtc)\r\n{\r\nstruct vmw_screen_object_unit *sou = vmw_crtc_to_sou(crtc);\r\nif (!sou->base.is_implicit)\r\nreturn true;\r\nif (dev_priv->sou_priv->num_implicit != 1)\r\nreturn false;\r\nreturn true;\r\n}\r\nvoid vmw_kms_screen_object_update_implicit_fb(struct vmw_private *dev_priv,\r\nstruct drm_crtc *crtc)\r\n{\r\nstruct vmw_screen_object_unit *sou = vmw_crtc_to_sou(crtc);\r\nBUG_ON(!sou->base.is_implicit);\r\ndev_priv->sou_priv->implicit_fb =\r\nvmw_framebuffer_to_vfb(sou->base.crtc.primary->fb);\r\n}
