void sdhci_f_sdh30_soft_voltage_switch(struct sdhci_host *host)\r\n{\r\nstruct f_sdhost_priv *priv = sdhci_priv(host);\r\nu32 ctrl = 0;\r\nusleep_range(2500, 3000);\r\nctrl = sdhci_readl(host, F_SDH30_IO_CONTROL2);\r\nctrl |= F_SDH30_CRES_O_DN;\r\nsdhci_writel(host, ctrl, F_SDH30_IO_CONTROL2);\r\nctrl |= F_SDH30_MSEL_O_1_8;\r\nsdhci_writel(host, ctrl, F_SDH30_IO_CONTROL2);\r\nctrl &= ~F_SDH30_CRES_O_DN;\r\nsdhci_writel(host, ctrl, F_SDH30_IO_CONTROL2);\r\nusleep_range(2500, 3000);\r\nif (priv->vendor_hs200) {\r\ndev_info(priv->dev, "%s: setting hs200\n", __func__);\r\nctrl = sdhci_readl(host, F_SDH30_ESD_CONTROL);\r\nctrl |= priv->vendor_hs200;\r\nsdhci_writel(host, ctrl, F_SDH30_ESD_CONTROL);\r\n}\r\nctrl = sdhci_readl(host, F_SDH30_TUNING_SETTING);\r\nctrl |= F_SDH30_CMD_CHK_DIS;\r\nsdhci_writel(host, ctrl, F_SDH30_TUNING_SETTING);\r\n}\r\nunsigned int sdhci_f_sdh30_get_min_clock(struct sdhci_host *host)\r\n{\r\nreturn F_SDH30_MIN_CLOCK;\r\n}\r\nvoid sdhci_f_sdh30_reset(struct sdhci_host *host, u8 mask)\r\n{\r\nif (sdhci_readw(host, SDHCI_CLOCK_CONTROL) == 0)\r\nsdhci_writew(host, 0xBC01, SDHCI_CLOCK_CONTROL);\r\nsdhci_reset(host, mask);\r\n}\r\nstatic int sdhci_f_sdh30_probe(struct platform_device *pdev)\r\n{\r\nstruct sdhci_host *host;\r\nstruct device *dev = &pdev->dev;\r\nstruct resource *res;\r\nint irq, ctrl = 0, ret = 0;\r\nstruct f_sdhost_priv *priv;\r\nu32 reg = 0;\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq < 0) {\r\ndev_err(dev, "%s: no irq specified\n", __func__);\r\nreturn irq;\r\n}\r\nhost = sdhci_alloc_host(dev, sizeof(struct sdhci_host) +\r\nsizeof(struct f_sdhost_priv));\r\nif (IS_ERR(host))\r\nreturn PTR_ERR(host);\r\npriv = sdhci_priv(host);\r\npriv->dev = dev;\r\nhost->quirks = SDHCI_QUIRK_NO_ENDATTR_IN_NOPDESC |\r\nSDHCI_QUIRK_INVERTED_WRITE_PROTECT;\r\nhost->quirks2 = SDHCI_QUIRK2_SUPPORT_SINGLE |\r\nSDHCI_QUIRK2_TUNING_WORK_AROUND;\r\nret = mmc_of_parse(host->mmc);\r\nif (ret)\r\ngoto err;\r\nplatform_set_drvdata(pdev, host);\r\nsdhci_get_of_property(pdev);\r\nhost->hw_name = "f_sdh30";\r\nhost->ops = &sdhci_f_sdh30_ops;\r\nhost->irq = irq;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nhost->ioaddr = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(host->ioaddr)) {\r\nret = PTR_ERR(host->ioaddr);\r\ngoto err;\r\n}\r\npriv->clk_iface = devm_clk_get(&pdev->dev, "iface");\r\nif (IS_ERR(priv->clk_iface)) {\r\nret = PTR_ERR(priv->clk_iface);\r\ngoto err;\r\n}\r\nret = clk_prepare_enable(priv->clk_iface);\r\nif (ret)\r\ngoto err;\r\npriv->clk = devm_clk_get(&pdev->dev, "core");\r\nif (IS_ERR(priv->clk)) {\r\nret = PTR_ERR(priv->clk);\r\ngoto err_clk;\r\n}\r\nret = clk_prepare_enable(priv->clk);\r\nif (ret)\r\ngoto err_clk;\r\nctrl = sdhci_readw(host, F_SDH30_AHB_CONFIG);\r\nctrl |= F_SDH30_SIN | F_SDH30_AHB_INCR_16 | F_SDH30_AHB_INCR_8 |\r\nF_SDH30_AHB_INCR_4;\r\nctrl &= ~(F_SDH30_AHB_BIGED | F_SDH30_BUSLOCK_EN);\r\nsdhci_writew(host, ctrl, F_SDH30_AHB_CONFIG);\r\nreg = sdhci_readl(host, F_SDH30_ESD_CONTROL);\r\nsdhci_writel(host, reg & ~F_SDH30_EMMC_RST, F_SDH30_ESD_CONTROL);\r\nmsleep(20);\r\nsdhci_writel(host, reg | F_SDH30_EMMC_RST, F_SDH30_ESD_CONTROL);\r\nreg = sdhci_readl(host, SDHCI_CAPABILITIES);\r\nif (reg & SDHCI_CAN_DO_8BIT)\r\npriv->vendor_hs200 = F_SDH30_EMMC_HS200;\r\nret = sdhci_add_host(host);\r\nif (ret)\r\ngoto err_add_host;\r\nreturn 0;\r\nerr_add_host:\r\nclk_disable_unprepare(priv->clk);\r\nerr_clk:\r\nclk_disable_unprepare(priv->clk_iface);\r\nerr:\r\nsdhci_free_host(host);\r\nreturn ret;\r\n}\r\nstatic int sdhci_f_sdh30_remove(struct platform_device *pdev)\r\n{\r\nstruct sdhci_host *host = platform_get_drvdata(pdev);\r\nstruct f_sdhost_priv *priv = sdhci_priv(host);\r\nsdhci_remove_host(host, readl(host->ioaddr + SDHCI_INT_STATUS) ==\r\n0xffffffff);\r\nclk_disable_unprepare(priv->clk_iface);\r\nclk_disable_unprepare(priv->clk);\r\nsdhci_free_host(host);\r\nplatform_set_drvdata(pdev, NULL);\r\nreturn 0;\r\n}
