static int xt_osf_add_callback(struct sock *ctnl, struct sk_buff *skb,\r\nconst struct nlmsghdr *nlh,\r\nconst struct nlattr * const osf_attrs[])\r\n{\r\nstruct xt_osf_user_finger *f;\r\nstruct xt_osf_finger *kf = NULL, *sf;\r\nint err = 0;\r\nif (!osf_attrs[OSF_ATTR_FINGER])\r\nreturn -EINVAL;\r\nif (!(nlh->nlmsg_flags & NLM_F_CREATE))\r\nreturn -EINVAL;\r\nf = nla_data(osf_attrs[OSF_ATTR_FINGER]);\r\nkf = kmalloc(sizeof(struct xt_osf_finger), GFP_KERNEL);\r\nif (!kf)\r\nreturn -ENOMEM;\r\nmemcpy(&kf->finger, f, sizeof(struct xt_osf_user_finger));\r\nlist_for_each_entry(sf, &xt_osf_fingers[!!f->df], finger_entry) {\r\nif (memcmp(&sf->finger, f, sizeof(struct xt_osf_user_finger)))\r\ncontinue;\r\nkfree(kf);\r\nkf = NULL;\r\nif (nlh->nlmsg_flags & NLM_F_EXCL)\r\nerr = -EEXIST;\r\nbreak;\r\n}\r\nif (kf)\r\nlist_add_tail_rcu(&kf->finger_entry, &xt_osf_fingers[!!f->df]);\r\nreturn err;\r\n}\r\nstatic int xt_osf_remove_callback(struct sock *ctnl, struct sk_buff *skb,\r\nconst struct nlmsghdr *nlh,\r\nconst struct nlattr * const osf_attrs[])\r\n{\r\nstruct xt_osf_user_finger *f;\r\nstruct xt_osf_finger *sf;\r\nint err = -ENOENT;\r\nif (!osf_attrs[OSF_ATTR_FINGER])\r\nreturn -EINVAL;\r\nf = nla_data(osf_attrs[OSF_ATTR_FINGER]);\r\nlist_for_each_entry(sf, &xt_osf_fingers[!!f->df], finger_entry) {\r\nif (memcmp(&sf->finger, f, sizeof(struct xt_osf_user_finger)))\r\ncontinue;\r\nlist_del_rcu(&sf->finger_entry);\r\nkfree_rcu(sf, rcu_head);\r\nerr = 0;\r\nbreak;\r\n}\r\nreturn err;\r\n}\r\nstatic inline int xt_osf_ttl(const struct sk_buff *skb, const struct xt_osf_info *info,\r\nunsigned char f_ttl)\r\n{\r\nconst struct iphdr *ip = ip_hdr(skb);\r\nif (info->flags & XT_OSF_TTL) {\r\nif (info->ttl == XT_OSF_TTL_TRUE)\r\nreturn ip->ttl == f_ttl;\r\nif (info->ttl == XT_OSF_TTL_NOCHECK)\r\nreturn 1;\r\nelse if (ip->ttl <= f_ttl)\r\nreturn 1;\r\nelse {\r\nstruct in_device *in_dev = __in_dev_get_rcu(skb->dev);\r\nint ret = 0;\r\nfor_ifa(in_dev) {\r\nif (inet_ifa_match(ip->saddr, ifa)) {\r\nret = (ip->ttl == f_ttl);\r\nbreak;\r\n}\r\n}\r\nendfor_ifa(in_dev);\r\nreturn ret;\r\n}\r\n}\r\nreturn ip->ttl == f_ttl;\r\n}\r\nstatic bool\r\nxt_osf_match_packet(const struct sk_buff *skb, struct xt_action_param *p)\r\n{\r\nconst struct xt_osf_info *info = p->matchinfo;\r\nconst struct iphdr *ip = ip_hdr(skb);\r\nconst struct tcphdr *tcp;\r\nstruct tcphdr _tcph;\r\nint fmatch = FMATCH_WRONG, fcount = 0;\r\nunsigned int optsize = 0, check_WSS = 0;\r\nu16 window, totlen, mss = 0;\r\nbool df;\r\nconst unsigned char *optp = NULL, *_optp = NULL;\r\nunsigned char opts[MAX_IPOPTLEN];\r\nconst struct xt_osf_finger *kf;\r\nconst struct xt_osf_user_finger *f;\r\nstruct net *net = dev_net(p->in ? p->in : p->out);\r\nif (!info)\r\nreturn false;\r\ntcp = skb_header_pointer(skb, ip_hdrlen(skb), sizeof(struct tcphdr), &_tcph);\r\nif (!tcp)\r\nreturn false;\r\nif (!tcp->syn)\r\nreturn false;\r\ntotlen = ntohs(ip->tot_len);\r\ndf = ntohs(ip->frag_off) & IP_DF;\r\nwindow = ntohs(tcp->window);\r\nif (tcp->doff * 4 > sizeof(struct tcphdr)) {\r\noptsize = tcp->doff * 4 - sizeof(struct tcphdr);\r\n_optp = optp = skb_header_pointer(skb, ip_hdrlen(skb) +\r\nsizeof(struct tcphdr), optsize, opts);\r\n}\r\nrcu_read_lock();\r\nlist_for_each_entry_rcu(kf, &xt_osf_fingers[df], finger_entry) {\r\nint foptsize, optnum;\r\nf = &kf->finger;\r\nif (!(info->flags & XT_OSF_LOG) && strcmp(info->genre, f->genre))\r\ncontinue;\r\noptp = _optp;\r\nfmatch = FMATCH_WRONG;\r\nif (totlen != f->ss || !xt_osf_ttl(skb, info, f->ttl))\r\ncontinue;\r\nif (f->wss.wc >= OSF_WSS_MAX)\r\ncontinue;\r\nfoptsize = 0;\r\nfor (optnum = 0; optnum < f->opt_num; ++optnum)\r\nfoptsize += f->opt[optnum].length;\r\nif (foptsize > MAX_IPOPTLEN ||\r\noptsize > MAX_IPOPTLEN ||\r\noptsize != foptsize)\r\ncontinue;\r\ncheck_WSS = f->wss.wc;\r\nfor (optnum = 0; optnum < f->opt_num; ++optnum) {\r\nif (f->opt[optnum].kind == (*optp)) {\r\n__u32 len = f->opt[optnum].length;\r\nconst __u8 *optend = optp + len;\r\nint loop_cont = 0;\r\nfmatch = FMATCH_OK;\r\nswitch (*optp) {\r\ncase OSFOPT_MSS:\r\nmss = optp[3];\r\nmss <<= 8;\r\nmss |= optp[2];\r\nmss = ntohs((__force __be16)mss);\r\nbreak;\r\ncase OSFOPT_TS:\r\nloop_cont = 1;\r\nbreak;\r\n}\r\noptp = optend;\r\n} else\r\nfmatch = FMATCH_OPT_WRONG;\r\nif (fmatch != FMATCH_OK)\r\nbreak;\r\n}\r\nif (fmatch != FMATCH_OPT_WRONG) {\r\nfmatch = FMATCH_WRONG;\r\nswitch (check_WSS) {\r\ncase OSF_WSS_PLAIN:\r\nif (f->wss.val == 0 || window == f->wss.val)\r\nfmatch = FMATCH_OK;\r\nbreak;\r\ncase OSF_WSS_MSS:\r\n#define SMART_MSS_1 1460\r\n#define SMART_MSS_2 1448\r\nif (window == f->wss.val * mss ||\r\nwindow == f->wss.val * SMART_MSS_1 ||\r\nwindow == f->wss.val * SMART_MSS_2)\r\nfmatch = FMATCH_OK;\r\nbreak;\r\ncase OSF_WSS_MTU:\r\nif (window == f->wss.val * (mss + 40) ||\r\nwindow == f->wss.val * (SMART_MSS_1 + 40) ||\r\nwindow == f->wss.val * (SMART_MSS_2 + 40))\r\nfmatch = FMATCH_OK;\r\nbreak;\r\ncase OSF_WSS_MODULO:\r\nif ((window % f->wss.val) == 0)\r\nfmatch = FMATCH_OK;\r\nbreak;\r\n}\r\n}\r\nif (fmatch != FMATCH_OK)\r\ncontinue;\r\nfcount++;\r\nif (info->flags & XT_OSF_LOG)\r\nnf_log_packet(net, p->family, p->hooknum, skb,\r\np->in, p->out, NULL,\r\n"%s [%s:%s] : %pI4:%d -> %pI4:%d hops=%d\n",\r\nf->genre, f->version, f->subtype,\r\n&ip->saddr, ntohs(tcp->source),\r\n&ip->daddr, ntohs(tcp->dest),\r\nf->ttl - ip->ttl);\r\nif ((info->flags & XT_OSF_LOG) &&\r\ninfo->loglevel == XT_OSF_LOGLEVEL_FIRST)\r\nbreak;\r\n}\r\nrcu_read_unlock();\r\nif (!fcount && (info->flags & XT_OSF_LOG))\r\nnf_log_packet(net, p->family, p->hooknum, skb, p->in,\r\np->out, NULL,\r\n"Remote OS is not known: %pI4:%u -> %pI4:%u\n",\r\n&ip->saddr, ntohs(tcp->source),\r\n&ip->daddr, ntohs(tcp->dest));\r\nif (fcount)\r\nfmatch = FMATCH_OK;\r\nreturn fmatch == FMATCH_OK;\r\n}\r\nstatic int __init xt_osf_init(void)\r\n{\r\nint err = -EINVAL;\r\nint i;\r\nfor (i=0; i<ARRAY_SIZE(xt_osf_fingers); ++i)\r\nINIT_LIST_HEAD(&xt_osf_fingers[i]);\r\nerr = nfnetlink_subsys_register(&xt_osf_nfnetlink);\r\nif (err < 0) {\r\npr_err("Failed to register OSF nsfnetlink helper (%d)\n", err);\r\ngoto err_out_exit;\r\n}\r\nerr = xt_register_match(&xt_osf_match);\r\nif (err) {\r\npr_err("Failed to register OS fingerprint "\r\n"matching module (%d)\n", err);\r\ngoto err_out_remove;\r\n}\r\nreturn 0;\r\nerr_out_remove:\r\nnfnetlink_subsys_unregister(&xt_osf_nfnetlink);\r\nerr_out_exit:\r\nreturn err;\r\n}\r\nstatic void __exit xt_osf_fini(void)\r\n{\r\nstruct xt_osf_finger *f;\r\nint i;\r\nnfnetlink_subsys_unregister(&xt_osf_nfnetlink);\r\nxt_unregister_match(&xt_osf_match);\r\nrcu_read_lock();\r\nfor (i=0; i<ARRAY_SIZE(xt_osf_fingers); ++i) {\r\nlist_for_each_entry_rcu(f, &xt_osf_fingers[i], finger_entry) {\r\nlist_del_rcu(&f->finger_entry);\r\nkfree_rcu(f, rcu_head);\r\n}\r\n}\r\nrcu_read_unlock();\r\nrcu_barrier();\r\n}
