static __inline__ int scm_check_creds(struct ucred *creds)\r\n{\r\nconst struct cred *cred = current_cred();\r\nkuid_t uid = make_kuid(cred->user_ns, creds->uid);\r\nkgid_t gid = make_kgid(cred->user_ns, creds->gid);\r\nif (!uid_valid(uid) || !gid_valid(gid))\r\nreturn -EINVAL;\r\nif ((creds->pid == task_tgid_vnr(current) ||\r\nns_capable(task_active_pid_ns(current)->user_ns, CAP_SYS_ADMIN)) &&\r\n((uid_eq(uid, cred->uid) || uid_eq(uid, cred->euid) ||\r\nuid_eq(uid, cred->suid)) || ns_capable(cred->user_ns, CAP_SETUID)) &&\r\n((gid_eq(gid, cred->gid) || gid_eq(gid, cred->egid) ||\r\ngid_eq(gid, cred->sgid)) || ns_capable(cred->user_ns, CAP_SETGID))) {\r\nreturn 0;\r\n}\r\nreturn -EPERM;\r\n}\r\nstatic int scm_fp_copy(struct cmsghdr *cmsg, struct scm_fp_list **fplp)\r\n{\r\nint *fdp = (int*)CMSG_DATA(cmsg);\r\nstruct scm_fp_list *fpl = *fplp;\r\nstruct file **fpp;\r\nint i, num;\r\nnum = (cmsg->cmsg_len - CMSG_ALIGN(sizeof(struct cmsghdr)))/sizeof(int);\r\nif (num <= 0)\r\nreturn 0;\r\nif (num > SCM_MAX_FD)\r\nreturn -EINVAL;\r\nif (!fpl)\r\n{\r\nfpl = kmalloc(sizeof(struct scm_fp_list), GFP_KERNEL);\r\nif (!fpl)\r\nreturn -ENOMEM;\r\n*fplp = fpl;\r\nfpl->count = 0;\r\nfpl->max = SCM_MAX_FD;\r\n}\r\nfpp = &fpl->fp[fpl->count];\r\nif (fpl->count + num > fpl->max)\r\nreturn -EINVAL;\r\nfor (i=0; i< num; i++)\r\n{\r\nint fd = fdp[i];\r\nstruct file *file;\r\nif (fd < 0 || !(file = fget_raw(fd)))\r\nreturn -EBADF;\r\n*fpp++ = file;\r\nfpl->count++;\r\n}\r\nreturn num;\r\n}\r\nvoid __scm_destroy(struct scm_cookie *scm)\r\n{\r\nstruct scm_fp_list *fpl = scm->fp;\r\nint i;\r\nif (fpl) {\r\nscm->fp = NULL;\r\nfor (i=fpl->count-1; i>=0; i--)\r\nfput(fpl->fp[i]);\r\nkfree(fpl);\r\n}\r\n}\r\nint __scm_send(struct socket *sock, struct msghdr *msg, struct scm_cookie *p)\r\n{\r\nstruct cmsghdr *cmsg;\r\nint err;\r\nfor_each_cmsghdr(cmsg, msg) {\r\nerr = -EINVAL;\r\nif (!CMSG_OK(msg, cmsg))\r\ngoto error;\r\nif (cmsg->cmsg_level != SOL_SOCKET)\r\ncontinue;\r\nswitch (cmsg->cmsg_type)\r\n{\r\ncase SCM_RIGHTS:\r\nif (!sock->ops || sock->ops->family != PF_UNIX)\r\ngoto error;\r\nerr=scm_fp_copy(cmsg, &p->fp);\r\nif (err<0)\r\ngoto error;\r\nbreak;\r\ncase SCM_CREDENTIALS:\r\n{\r\nstruct ucred creds;\r\nkuid_t uid;\r\nkgid_t gid;\r\nif (cmsg->cmsg_len != CMSG_LEN(sizeof(struct ucred)))\r\ngoto error;\r\nmemcpy(&creds, CMSG_DATA(cmsg), sizeof(struct ucred));\r\nerr = scm_check_creds(&creds);\r\nif (err)\r\ngoto error;\r\np->creds.pid = creds.pid;\r\nif (!p->pid || pid_vnr(p->pid) != creds.pid) {\r\nstruct pid *pid;\r\nerr = -ESRCH;\r\npid = find_get_pid(creds.pid);\r\nif (!pid)\r\ngoto error;\r\nput_pid(p->pid);\r\np->pid = pid;\r\n}\r\nerr = -EINVAL;\r\nuid = make_kuid(current_user_ns(), creds.uid);\r\ngid = make_kgid(current_user_ns(), creds.gid);\r\nif (!uid_valid(uid) || !gid_valid(gid))\r\ngoto error;\r\np->creds.uid = uid;\r\np->creds.gid = gid;\r\nbreak;\r\n}\r\ndefault:\r\ngoto error;\r\n}\r\n}\r\nif (p->fp && !p->fp->count)\r\n{\r\nkfree(p->fp);\r\np->fp = NULL;\r\n}\r\nreturn 0;\r\nerror:\r\nscm_destroy(p);\r\nreturn err;\r\n}\r\nint put_cmsg(struct msghdr * msg, int level, int type, int len, void *data)\r\n{\r\nstruct cmsghdr __user *cm\r\n= (__force struct cmsghdr __user *)msg->msg_control;\r\nstruct cmsghdr cmhdr;\r\nint cmlen = CMSG_LEN(len);\r\nint err;\r\nif (MSG_CMSG_COMPAT & msg->msg_flags)\r\nreturn put_cmsg_compat(msg, level, type, len, data);\r\nif (cm==NULL || msg->msg_controllen < sizeof(*cm)) {\r\nmsg->msg_flags |= MSG_CTRUNC;\r\nreturn 0;\r\n}\r\nif (msg->msg_controllen < cmlen) {\r\nmsg->msg_flags |= MSG_CTRUNC;\r\ncmlen = msg->msg_controllen;\r\n}\r\ncmhdr.cmsg_level = level;\r\ncmhdr.cmsg_type = type;\r\ncmhdr.cmsg_len = cmlen;\r\nerr = -EFAULT;\r\nif (copy_to_user(cm, &cmhdr, sizeof cmhdr))\r\ngoto out;\r\nif (copy_to_user(CMSG_DATA(cm), data, cmlen - sizeof(struct cmsghdr)))\r\ngoto out;\r\ncmlen = CMSG_SPACE(len);\r\nif (msg->msg_controllen < cmlen)\r\ncmlen = msg->msg_controllen;\r\nmsg->msg_control += cmlen;\r\nmsg->msg_controllen -= cmlen;\r\nerr = 0;\r\nout:\r\nreturn err;\r\n}\r\nvoid scm_detach_fds(struct msghdr *msg, struct scm_cookie *scm)\r\n{\r\nstruct cmsghdr __user *cm\r\n= (__force struct cmsghdr __user*)msg->msg_control;\r\nint fdmax = 0;\r\nint fdnum = scm->fp->count;\r\nstruct file **fp = scm->fp->fp;\r\nint __user *cmfptr;\r\nint err = 0, i;\r\nif (MSG_CMSG_COMPAT & msg->msg_flags) {\r\nscm_detach_fds_compat(msg, scm);\r\nreturn;\r\n}\r\nif (msg->msg_controllen > sizeof(struct cmsghdr))\r\nfdmax = ((msg->msg_controllen - sizeof(struct cmsghdr))\r\n/ sizeof(int));\r\nif (fdnum < fdmax)\r\nfdmax = fdnum;\r\nfor (i=0, cmfptr=(__force int __user *)CMSG_DATA(cm); i<fdmax;\r\ni++, cmfptr++)\r\n{\r\nstruct socket *sock;\r\nint new_fd;\r\nerr = security_file_receive(fp[i]);\r\nif (err)\r\nbreak;\r\nerr = get_unused_fd_flags(MSG_CMSG_CLOEXEC & msg->msg_flags\r\n? O_CLOEXEC : 0);\r\nif (err < 0)\r\nbreak;\r\nnew_fd = err;\r\nerr = put_user(new_fd, cmfptr);\r\nif (err) {\r\nput_unused_fd(new_fd);\r\nbreak;\r\n}\r\nsock = sock_from_file(fp[i], &err);\r\nif (sock) {\r\nsock_update_netprioidx(sock->sk);\r\nsock_update_classid(sock->sk);\r\n}\r\nfd_install(new_fd, get_file(fp[i]));\r\n}\r\nif (i > 0)\r\n{\r\nint cmlen = CMSG_LEN(i*sizeof(int));\r\nerr = put_user(SOL_SOCKET, &cm->cmsg_level);\r\nif (!err)\r\nerr = put_user(SCM_RIGHTS, &cm->cmsg_type);\r\nif (!err)\r\nerr = put_user(cmlen, &cm->cmsg_len);\r\nif (!err) {\r\ncmlen = CMSG_SPACE(i*sizeof(int));\r\nmsg->msg_control += cmlen;\r\nmsg->msg_controllen -= cmlen;\r\n}\r\n}\r\nif (i < fdnum || (fdnum && fdmax <= 0))\r\nmsg->msg_flags |= MSG_CTRUNC;\r\n__scm_destroy(scm);\r\n}\r\nstruct scm_fp_list *scm_fp_dup(struct scm_fp_list *fpl)\r\n{\r\nstruct scm_fp_list *new_fpl;\r\nint i;\r\nif (!fpl)\r\nreturn NULL;\r\nnew_fpl = kmemdup(fpl, offsetof(struct scm_fp_list, fp[fpl->count]),\r\nGFP_KERNEL);\r\nif (new_fpl) {\r\nfor (i = 0; i < fpl->count; i++)\r\nget_file(fpl->fp[i]);\r\nnew_fpl->max = new_fpl->count;\r\n}\r\nreturn new_fpl;\r\n}
