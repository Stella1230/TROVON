static void batadv_ring_buffer_set(uint8_t lq_recv[], uint8_t *lq_index,\r\nuint8_t value)\r\n{\r\nlq_recv[*lq_index] = value;\r\n*lq_index = (*lq_index + 1) % BATADV_TQ_GLOBAL_WINDOW_SIZE;\r\n}\r\nstatic uint8_t batadv_ring_buffer_avg(const uint8_t lq_recv[])\r\n{\r\nconst uint8_t *ptr;\r\nuint16_t count = 0, i = 0, sum = 0;\r\nptr = lq_recv;\r\nwhile (i < BATADV_TQ_GLOBAL_WINDOW_SIZE) {\r\nif (*ptr != 0) {\r\ncount++;\r\nsum += *ptr;\r\n}\r\ni++;\r\nptr++;\r\n}\r\nif (count == 0)\r\nreturn 0;\r\nreturn (uint8_t)(sum / count);\r\n}\r\nstatic void batadv_iv_ogm_orig_free(struct batadv_orig_node *orig_node)\r\n{\r\nkfree(orig_node->bat_iv.bcast_own);\r\nkfree(orig_node->bat_iv.bcast_own_sum);\r\n}\r\nstatic int batadv_iv_ogm_orig_add_if(struct batadv_orig_node *orig_node,\r\nint max_if_num)\r\n{\r\nvoid *data_ptr;\r\nsize_t old_size;\r\nint ret = -ENOMEM;\r\nspin_lock_bh(&orig_node->bat_iv.ogm_cnt_lock);\r\nold_size = (max_if_num - 1) * sizeof(unsigned long) * BATADV_NUM_WORDS;\r\ndata_ptr = kmalloc_array(max_if_num,\r\nBATADV_NUM_WORDS * sizeof(unsigned long),\r\nGFP_ATOMIC);\r\nif (!data_ptr)\r\ngoto unlock;\r\nmemcpy(data_ptr, orig_node->bat_iv.bcast_own, old_size);\r\nkfree(orig_node->bat_iv.bcast_own);\r\norig_node->bat_iv.bcast_own = data_ptr;\r\ndata_ptr = kmalloc_array(max_if_num, sizeof(uint8_t), GFP_ATOMIC);\r\nif (!data_ptr) {\r\nkfree(orig_node->bat_iv.bcast_own);\r\ngoto unlock;\r\n}\r\nmemcpy(data_ptr, orig_node->bat_iv.bcast_own_sum,\r\n(max_if_num - 1) * sizeof(uint8_t));\r\nkfree(orig_node->bat_iv.bcast_own_sum);\r\norig_node->bat_iv.bcast_own_sum = data_ptr;\r\nret = 0;\r\nunlock:\r\nspin_unlock_bh(&orig_node->bat_iv.ogm_cnt_lock);\r\nreturn ret;\r\n}\r\nstatic int batadv_iv_ogm_orig_del_if(struct batadv_orig_node *orig_node,\r\nint max_if_num, int del_if_num)\r\n{\r\nint chunk_size, ret = -ENOMEM, if_offset;\r\nvoid *data_ptr = NULL;\r\nspin_lock_bh(&orig_node->bat_iv.ogm_cnt_lock);\r\nif (max_if_num == 0)\r\ngoto free_bcast_own;\r\nchunk_size = sizeof(unsigned long) * BATADV_NUM_WORDS;\r\ndata_ptr = kmalloc_array(max_if_num, chunk_size, GFP_ATOMIC);\r\nif (!data_ptr)\r\ngoto unlock;\r\nmemcpy(data_ptr, orig_node->bat_iv.bcast_own, del_if_num * chunk_size);\r\nmemcpy((char *)data_ptr + del_if_num * chunk_size,\r\norig_node->bat_iv.bcast_own + ((del_if_num + 1) * chunk_size),\r\n(max_if_num - del_if_num) * chunk_size);\r\nfree_bcast_own:\r\nkfree(orig_node->bat_iv.bcast_own);\r\norig_node->bat_iv.bcast_own = data_ptr;\r\nif (max_if_num == 0)\r\ngoto free_own_sum;\r\ndata_ptr = kmalloc_array(max_if_num, sizeof(uint8_t), GFP_ATOMIC);\r\nif (!data_ptr) {\r\nkfree(orig_node->bat_iv.bcast_own);\r\ngoto unlock;\r\n}\r\nmemcpy(data_ptr, orig_node->bat_iv.bcast_own_sum,\r\ndel_if_num * sizeof(uint8_t));\r\nif_offset = (del_if_num + 1) * sizeof(uint8_t);\r\nmemcpy((char *)data_ptr + del_if_num * sizeof(uint8_t),\r\norig_node->bat_iv.bcast_own_sum + if_offset,\r\n(max_if_num - del_if_num) * sizeof(uint8_t));\r\nfree_own_sum:\r\nkfree(orig_node->bat_iv.bcast_own_sum);\r\norig_node->bat_iv.bcast_own_sum = data_ptr;\r\nret = 0;\r\nunlock:\r\nspin_unlock_bh(&orig_node->bat_iv.ogm_cnt_lock);\r\nreturn ret;\r\n}\r\nstatic struct batadv_orig_node *\r\nbatadv_iv_ogm_orig_get(struct batadv_priv *bat_priv, const uint8_t *addr)\r\n{\r\nstruct batadv_orig_node *orig_node;\r\nint size, hash_added;\r\norig_node = batadv_orig_hash_find(bat_priv, addr);\r\nif (orig_node)\r\nreturn orig_node;\r\norig_node = batadv_orig_node_new(bat_priv, addr);\r\nif (!orig_node)\r\nreturn NULL;\r\nspin_lock_init(&orig_node->bat_iv.ogm_cnt_lock);\r\nsize = bat_priv->num_ifaces * sizeof(unsigned long) * BATADV_NUM_WORDS;\r\norig_node->bat_iv.bcast_own = kzalloc(size, GFP_ATOMIC);\r\nif (!orig_node->bat_iv.bcast_own)\r\ngoto free_orig_node;\r\nsize = bat_priv->num_ifaces * sizeof(uint8_t);\r\norig_node->bat_iv.bcast_own_sum = kzalloc(size, GFP_ATOMIC);\r\nif (!orig_node->bat_iv.bcast_own_sum)\r\ngoto free_orig_node;\r\nhash_added = batadv_hash_add(bat_priv->orig_hash, batadv_compare_orig,\r\nbatadv_choose_orig, orig_node,\r\n&orig_node->hash_entry);\r\nif (hash_added != 0)\r\ngoto free_orig_node;\r\nreturn orig_node;\r\nfree_orig_node:\r\nbatadv_orig_node_free_ref(orig_node);\r\nbatadv_orig_node_free_ref(orig_node);\r\nreturn NULL;\r\n}\r\nstatic struct batadv_neigh_node *\r\nbatadv_iv_ogm_neigh_new(struct batadv_hard_iface *hard_iface,\r\nconst uint8_t *neigh_addr,\r\nstruct batadv_orig_node *orig_node,\r\nstruct batadv_orig_node *orig_neigh)\r\n{\r\nstruct batadv_priv *bat_priv = netdev_priv(hard_iface->soft_iface);\r\nstruct batadv_neigh_node *neigh_node, *tmp_neigh_node;\r\nneigh_node = batadv_neigh_node_new(hard_iface, neigh_addr, orig_node);\r\nif (!neigh_node)\r\ngoto out;\r\nif (!atomic_inc_not_zero(&hard_iface->refcount)) {\r\nkfree(neigh_node);\r\nneigh_node = NULL;\r\ngoto out;\r\n}\r\nneigh_node->orig_node = orig_neigh;\r\nneigh_node->if_incoming = hard_iface;\r\nspin_lock_bh(&orig_node->neigh_list_lock);\r\ntmp_neigh_node = batadv_neigh_node_get(orig_node, hard_iface,\r\nneigh_addr);\r\nif (!tmp_neigh_node) {\r\nhlist_add_head_rcu(&neigh_node->list, &orig_node->neigh_list);\r\n} else {\r\nkfree(neigh_node);\r\nbatadv_hardif_free_ref(hard_iface);\r\nneigh_node = tmp_neigh_node;\r\n}\r\nspin_unlock_bh(&orig_node->neigh_list_lock);\r\nif (!tmp_neigh_node)\r\nbatadv_dbg(BATADV_DBG_BATMAN, bat_priv,\r\n"Creating new neighbor %pM for orig_node %pM on interface %s\n",\r\nneigh_addr, orig_node->orig,\r\nhard_iface->net_dev->name);\r\nout:\r\nreturn neigh_node;\r\n}\r\nstatic int batadv_iv_ogm_iface_enable(struct batadv_hard_iface *hard_iface)\r\n{\r\nstruct batadv_ogm_packet *batadv_ogm_packet;\r\nunsigned char *ogm_buff;\r\nuint32_t random_seqno;\r\nint res = -ENOMEM;\r\nget_random_bytes(&random_seqno, sizeof(random_seqno));\r\natomic_set(&hard_iface->bat_iv.ogm_seqno, random_seqno);\r\nhard_iface->bat_iv.ogm_buff_len = BATADV_OGM_HLEN;\r\nogm_buff = kmalloc(hard_iface->bat_iv.ogm_buff_len, GFP_ATOMIC);\r\nif (!ogm_buff)\r\ngoto out;\r\nhard_iface->bat_iv.ogm_buff = ogm_buff;\r\nbatadv_ogm_packet = (struct batadv_ogm_packet *)ogm_buff;\r\nbatadv_ogm_packet->packet_type = BATADV_IV_OGM;\r\nbatadv_ogm_packet->version = BATADV_COMPAT_VERSION;\r\nbatadv_ogm_packet->ttl = 2;\r\nbatadv_ogm_packet->flags = BATADV_NO_FLAGS;\r\nbatadv_ogm_packet->reserved = 0;\r\nbatadv_ogm_packet->tq = BATADV_TQ_MAX_VALUE;\r\nres = 0;\r\nout:\r\nreturn res;\r\n}\r\nstatic void batadv_iv_ogm_iface_disable(struct batadv_hard_iface *hard_iface)\r\n{\r\nkfree(hard_iface->bat_iv.ogm_buff);\r\nhard_iface->bat_iv.ogm_buff = NULL;\r\n}\r\nstatic void batadv_iv_ogm_iface_update_mac(struct batadv_hard_iface *hard_iface)\r\n{\r\nstruct batadv_ogm_packet *batadv_ogm_packet;\r\nunsigned char *ogm_buff = hard_iface->bat_iv.ogm_buff;\r\nbatadv_ogm_packet = (struct batadv_ogm_packet *)ogm_buff;\r\nether_addr_copy(batadv_ogm_packet->orig,\r\nhard_iface->net_dev->dev_addr);\r\nether_addr_copy(batadv_ogm_packet->prev_sender,\r\nhard_iface->net_dev->dev_addr);\r\n}\r\nstatic void\r\nbatadv_iv_ogm_primary_iface_set(struct batadv_hard_iface *hard_iface)\r\n{\r\nstruct batadv_ogm_packet *batadv_ogm_packet;\r\nunsigned char *ogm_buff = hard_iface->bat_iv.ogm_buff;\r\nbatadv_ogm_packet = (struct batadv_ogm_packet *)ogm_buff;\r\nbatadv_ogm_packet->flags = BATADV_PRIMARIES_FIRST_HOP;\r\nbatadv_ogm_packet->ttl = BATADV_TTL;\r\n}\r\nstatic unsigned long\r\nbatadv_iv_ogm_emit_send_time(const struct batadv_priv *bat_priv)\r\n{\r\nunsigned int msecs;\r\nmsecs = atomic_read(&bat_priv->orig_interval) - BATADV_JITTER;\r\nmsecs += prandom_u32() % (2 * BATADV_JITTER);\r\nreturn jiffies + msecs_to_jiffies(msecs);\r\n}\r\nstatic unsigned long batadv_iv_ogm_fwd_send_time(void)\r\n{\r\nreturn jiffies + msecs_to_jiffies(prandom_u32() % (BATADV_JITTER / 2));\r\n}\r\nstatic uint8_t batadv_hop_penalty(uint8_t tq,\r\nconst struct batadv_priv *bat_priv)\r\n{\r\nint hop_penalty = atomic_read(&bat_priv->hop_penalty);\r\nint new_tq;\r\nnew_tq = tq * (BATADV_TQ_MAX_VALUE - hop_penalty);\r\nnew_tq /= BATADV_TQ_MAX_VALUE;\r\nreturn new_tq;\r\n}\r\nstatic int batadv_iv_ogm_aggr_packet(int buff_pos, int packet_len,\r\n__be16 tvlv_len)\r\n{\r\nint next_buff_pos = 0;\r\nnext_buff_pos += buff_pos + BATADV_OGM_HLEN;\r\nnext_buff_pos += ntohs(tvlv_len);\r\nreturn (next_buff_pos <= packet_len) &&\r\n(next_buff_pos <= BATADV_MAX_AGGREGATION_BYTES);\r\n}\r\nstatic void batadv_iv_ogm_send_to_if(struct batadv_forw_packet *forw_packet,\r\nstruct batadv_hard_iface *hard_iface)\r\n{\r\nstruct batadv_priv *bat_priv = netdev_priv(hard_iface->soft_iface);\r\nchar *fwd_str;\r\nuint8_t packet_num;\r\nint16_t buff_pos;\r\nstruct batadv_ogm_packet *batadv_ogm_packet;\r\nstruct sk_buff *skb;\r\nuint8_t *packet_pos;\r\nif (hard_iface->if_status != BATADV_IF_ACTIVE)\r\nreturn;\r\npacket_num = 0;\r\nbuff_pos = 0;\r\npacket_pos = forw_packet->skb->data;\r\nbatadv_ogm_packet = (struct batadv_ogm_packet *)packet_pos;\r\nwhile (batadv_iv_ogm_aggr_packet(buff_pos, forw_packet->packet_len,\r\nbatadv_ogm_packet->tvlv_len)) {\r\nif (forw_packet->direct_link_flags & BIT(packet_num) &&\r\nforw_packet->if_incoming == hard_iface)\r\nbatadv_ogm_packet->flags |= BATADV_DIRECTLINK;\r\nelse\r\nbatadv_ogm_packet->flags &= ~BATADV_DIRECTLINK;\r\nif (packet_num > 0 || !forw_packet->own)\r\nfwd_str = "Forwarding";\r\nelse\r\nfwd_str = "Sending own";\r\nbatadv_dbg(BATADV_DBG_BATMAN, bat_priv,\r\n"%s %spacket (originator %pM, seqno %u, TQ %d, TTL %d, IDF %s) on interface %s [%pM]\n",\r\nfwd_str, (packet_num > 0 ? "aggregated " : ""),\r\nbatadv_ogm_packet->orig,\r\nntohl(batadv_ogm_packet->seqno),\r\nbatadv_ogm_packet->tq, batadv_ogm_packet->ttl,\r\n(batadv_ogm_packet->flags & BATADV_DIRECTLINK ?\r\n"on" : "off"),\r\nhard_iface->net_dev->name,\r\nhard_iface->net_dev->dev_addr);\r\nbuff_pos += BATADV_OGM_HLEN;\r\nbuff_pos += ntohs(batadv_ogm_packet->tvlv_len);\r\npacket_num++;\r\npacket_pos = forw_packet->skb->data + buff_pos;\r\nbatadv_ogm_packet = (struct batadv_ogm_packet *)packet_pos;\r\n}\r\nskb = skb_clone(forw_packet->skb, GFP_ATOMIC);\r\nif (skb) {\r\nbatadv_inc_counter(bat_priv, BATADV_CNT_MGMT_TX);\r\nbatadv_add_counter(bat_priv, BATADV_CNT_MGMT_TX_BYTES,\r\nskb->len + ETH_HLEN);\r\nbatadv_send_skb_packet(skb, hard_iface, batadv_broadcast_addr);\r\n}\r\n}\r\nstatic void batadv_iv_ogm_emit(struct batadv_forw_packet *forw_packet)\r\n{\r\nstruct net_device *soft_iface;\r\nstruct batadv_priv *bat_priv;\r\nstruct batadv_hard_iface *primary_if = NULL;\r\nif (!forw_packet->if_incoming) {\r\npr_err("Error - can't forward packet: incoming iface not specified\n");\r\ngoto out;\r\n}\r\nsoft_iface = forw_packet->if_incoming->soft_iface;\r\nbat_priv = netdev_priv(soft_iface);\r\nif (WARN_ON(!forw_packet->if_outgoing))\r\ngoto out;\r\nif (WARN_ON(forw_packet->if_outgoing->soft_iface != soft_iface))\r\ngoto out;\r\nif (forw_packet->if_incoming->if_status != BATADV_IF_ACTIVE)\r\ngoto out;\r\nprimary_if = batadv_primary_if_get_selected(bat_priv);\r\nif (!primary_if)\r\ngoto out;\r\nbatadv_iv_ogm_send_to_if(forw_packet, forw_packet->if_outgoing);\r\nout:\r\nif (primary_if)\r\nbatadv_hardif_free_ref(primary_if);\r\n}\r\nstatic bool\r\nbatadv_iv_ogm_can_aggregate(const struct batadv_ogm_packet *new_bat_ogm_packet,\r\nstruct batadv_priv *bat_priv,\r\nint packet_len, unsigned long send_time,\r\nbool directlink,\r\nconst struct batadv_hard_iface *if_incoming,\r\nconst struct batadv_hard_iface *if_outgoing,\r\nconst struct batadv_forw_packet *forw_packet)\r\n{\r\nstruct batadv_ogm_packet *batadv_ogm_packet;\r\nint aggregated_bytes = forw_packet->packet_len + packet_len;\r\nstruct batadv_hard_iface *primary_if = NULL;\r\nbool res = false;\r\nunsigned long aggregation_end_time;\r\nbatadv_ogm_packet = (struct batadv_ogm_packet *)forw_packet->skb->data;\r\naggregation_end_time = send_time;\r\naggregation_end_time += msecs_to_jiffies(BATADV_MAX_AGGREGATION_MS);\r\nif (time_before(send_time, forw_packet->send_time) &&\r\ntime_after_eq(aggregation_end_time, forw_packet->send_time) &&\r\n(aggregated_bytes <= BATADV_MAX_AGGREGATION_BYTES)) {\r\nprimary_if = batadv_primary_if_get_selected(bat_priv);\r\nif (!primary_if)\r\ngoto out;\r\nif (forw_packet->if_outgoing != if_outgoing)\r\ngoto out;\r\nif ((!directlink) &&\r\n(!(batadv_ogm_packet->flags & BATADV_DIRECTLINK)) &&\r\n(batadv_ogm_packet->ttl != 1) &&\r\n((!forw_packet->own) ||\r\n(forw_packet->if_incoming == primary_if))) {\r\nres = true;\r\ngoto out;\r\n}\r\nif ((directlink) &&\r\n(new_bat_ogm_packet->ttl == 1) &&\r\n(forw_packet->if_incoming == if_incoming) &&\r\n(batadv_ogm_packet->flags & BATADV_DIRECTLINK ||\r\n(forw_packet->own &&\r\nforw_packet->if_incoming != primary_if))) {\r\nres = true;\r\ngoto out;\r\n}\r\n}\r\nout:\r\nif (primary_if)\r\nbatadv_hardif_free_ref(primary_if);\r\nreturn res;\r\n}\r\nstatic void batadv_iv_ogm_aggregate_new(const unsigned char *packet_buff,\r\nint packet_len, unsigned long send_time,\r\nbool direct_link,\r\nstruct batadv_hard_iface *if_incoming,\r\nstruct batadv_hard_iface *if_outgoing,\r\nint own_packet)\r\n{\r\nstruct batadv_priv *bat_priv = netdev_priv(if_incoming->soft_iface);\r\nstruct batadv_forw_packet *forw_packet_aggr;\r\nunsigned char *skb_buff;\r\nunsigned int skb_size;\r\nif (!atomic_inc_not_zero(&if_incoming->refcount))\r\nreturn;\r\nif (!atomic_inc_not_zero(&if_outgoing->refcount))\r\ngoto out_free_incoming;\r\nif (!own_packet) {\r\nif (!batadv_atomic_dec_not_zero(&bat_priv->batman_queue_left)) {\r\nbatadv_dbg(BATADV_DBG_BATMAN, bat_priv,\r\n"batman packet queue full\n");\r\ngoto out;\r\n}\r\n}\r\nforw_packet_aggr = kmalloc(sizeof(*forw_packet_aggr), GFP_ATOMIC);\r\nif (!forw_packet_aggr) {\r\nif (!own_packet)\r\natomic_inc(&bat_priv->batman_queue_left);\r\ngoto out;\r\n}\r\nif ((atomic_read(&bat_priv->aggregated_ogms)) &&\r\n(packet_len < BATADV_MAX_AGGREGATION_BYTES))\r\nskb_size = BATADV_MAX_AGGREGATION_BYTES;\r\nelse\r\nskb_size = packet_len;\r\nskb_size += ETH_HLEN;\r\nforw_packet_aggr->skb = netdev_alloc_skb_ip_align(NULL, skb_size);\r\nif (!forw_packet_aggr->skb) {\r\nif (!own_packet)\r\natomic_inc(&bat_priv->batman_queue_left);\r\nkfree(forw_packet_aggr);\r\ngoto out;\r\n}\r\nforw_packet_aggr->skb->priority = TC_PRIO_CONTROL;\r\nskb_reserve(forw_packet_aggr->skb, ETH_HLEN);\r\nskb_buff = skb_put(forw_packet_aggr->skb, packet_len);\r\nforw_packet_aggr->packet_len = packet_len;\r\nmemcpy(skb_buff, packet_buff, packet_len);\r\nforw_packet_aggr->own = own_packet;\r\nforw_packet_aggr->if_incoming = if_incoming;\r\nforw_packet_aggr->if_outgoing = if_outgoing;\r\nforw_packet_aggr->num_packets = 0;\r\nforw_packet_aggr->direct_link_flags = BATADV_NO_FLAGS;\r\nforw_packet_aggr->send_time = send_time;\r\nif (direct_link)\r\nforw_packet_aggr->direct_link_flags |= 1;\r\nspin_lock_bh(&bat_priv->forw_bat_list_lock);\r\nhlist_add_head(&forw_packet_aggr->list, &bat_priv->forw_bat_list);\r\nspin_unlock_bh(&bat_priv->forw_bat_list_lock);\r\nINIT_DELAYED_WORK(&forw_packet_aggr->delayed_work,\r\nbatadv_send_outstanding_bat_ogm_packet);\r\nqueue_delayed_work(batadv_event_workqueue,\r\n&forw_packet_aggr->delayed_work,\r\nsend_time - jiffies);\r\nreturn;\r\nout:\r\nbatadv_hardif_free_ref(if_outgoing);\r\nout_free_incoming:\r\nbatadv_hardif_free_ref(if_incoming);\r\n}\r\nstatic void batadv_iv_ogm_aggregate(struct batadv_forw_packet *forw_packet_aggr,\r\nconst unsigned char *packet_buff,\r\nint packet_len, bool direct_link)\r\n{\r\nunsigned char *skb_buff;\r\nunsigned long new_direct_link_flag;\r\nskb_buff = skb_put(forw_packet_aggr->skb, packet_len);\r\nmemcpy(skb_buff, packet_buff, packet_len);\r\nforw_packet_aggr->packet_len += packet_len;\r\nforw_packet_aggr->num_packets++;\r\nif (direct_link) {\r\nnew_direct_link_flag = BIT(forw_packet_aggr->num_packets);\r\nforw_packet_aggr->direct_link_flags |= new_direct_link_flag;\r\n}\r\n}\r\nstatic void batadv_iv_ogm_queue_add(struct batadv_priv *bat_priv,\r\nunsigned char *packet_buff,\r\nint packet_len,\r\nstruct batadv_hard_iface *if_incoming,\r\nstruct batadv_hard_iface *if_outgoing,\r\nint own_packet, unsigned long send_time)\r\n{\r\nstruct batadv_forw_packet *forw_packet_aggr = NULL;\r\nstruct batadv_forw_packet *forw_packet_pos = NULL;\r\nstruct batadv_ogm_packet *batadv_ogm_packet;\r\nbool direct_link;\r\nunsigned long max_aggregation_jiffies;\r\nbatadv_ogm_packet = (struct batadv_ogm_packet *)packet_buff;\r\ndirect_link = batadv_ogm_packet->flags & BATADV_DIRECTLINK ? 1 : 0;\r\nmax_aggregation_jiffies = msecs_to_jiffies(BATADV_MAX_AGGREGATION_MS);\r\nspin_lock_bh(&bat_priv->forw_bat_list_lock);\r\nif ((atomic_read(&bat_priv->aggregated_ogms)) && (!own_packet)) {\r\nhlist_for_each_entry(forw_packet_pos,\r\n&bat_priv->forw_bat_list, list) {\r\nif (batadv_iv_ogm_can_aggregate(batadv_ogm_packet,\r\nbat_priv, packet_len,\r\nsend_time, direct_link,\r\nif_incoming,\r\nif_outgoing,\r\nforw_packet_pos)) {\r\nforw_packet_aggr = forw_packet_pos;\r\nbreak;\r\n}\r\n}\r\n}\r\nif (!forw_packet_aggr) {\r\nspin_unlock_bh(&bat_priv->forw_bat_list_lock);\r\nif (!own_packet && atomic_read(&bat_priv->aggregated_ogms))\r\nsend_time += max_aggregation_jiffies;\r\nbatadv_iv_ogm_aggregate_new(packet_buff, packet_len,\r\nsend_time, direct_link,\r\nif_incoming, if_outgoing,\r\nown_packet);\r\n} else {\r\nbatadv_iv_ogm_aggregate(forw_packet_aggr, packet_buff,\r\npacket_len, direct_link);\r\nspin_unlock_bh(&bat_priv->forw_bat_list_lock);\r\n}\r\n}\r\nstatic void batadv_iv_ogm_forward(struct batadv_orig_node *orig_node,\r\nconst struct ethhdr *ethhdr,\r\nstruct batadv_ogm_packet *batadv_ogm_packet,\r\nbool is_single_hop_neigh,\r\nbool is_from_best_next_hop,\r\nstruct batadv_hard_iface *if_incoming,\r\nstruct batadv_hard_iface *if_outgoing)\r\n{\r\nstruct batadv_priv *bat_priv = netdev_priv(if_incoming->soft_iface);\r\nuint16_t tvlv_len;\r\nif (batadv_ogm_packet->ttl <= 1) {\r\nbatadv_dbg(BATADV_DBG_BATMAN, bat_priv, "ttl exceeded\n");\r\nreturn;\r\n}\r\nif (!is_from_best_next_hop) {\r\nif (is_single_hop_neigh)\r\nbatadv_ogm_packet->flags |= BATADV_NOT_BEST_NEXT_HOP;\r\nelse\r\nreturn;\r\n}\r\ntvlv_len = ntohs(batadv_ogm_packet->tvlv_len);\r\nbatadv_ogm_packet->ttl--;\r\nether_addr_copy(batadv_ogm_packet->prev_sender, ethhdr->h_source);\r\nbatadv_ogm_packet->tq = batadv_hop_penalty(batadv_ogm_packet->tq,\r\nbat_priv);\r\nbatadv_dbg(BATADV_DBG_BATMAN, bat_priv,\r\n"Forwarding packet: tq: %i, ttl: %i\n",\r\nbatadv_ogm_packet->tq, batadv_ogm_packet->ttl);\r\nbatadv_ogm_packet->flags &= ~BATADV_PRIMARIES_FIRST_HOP;\r\nif (is_single_hop_neigh)\r\nbatadv_ogm_packet->flags |= BATADV_DIRECTLINK;\r\nelse\r\nbatadv_ogm_packet->flags &= ~BATADV_DIRECTLINK;\r\nbatadv_iv_ogm_queue_add(bat_priv, (unsigned char *)batadv_ogm_packet,\r\nBATADV_OGM_HLEN + tvlv_len,\r\nif_incoming, if_outgoing, 0,\r\nbatadv_iv_ogm_fwd_send_time());\r\n}\r\nstatic void\r\nbatadv_iv_ogm_slide_own_bcast_window(struct batadv_hard_iface *hard_iface)\r\n{\r\nstruct batadv_priv *bat_priv = netdev_priv(hard_iface->soft_iface);\r\nstruct batadv_hashtable *hash = bat_priv->orig_hash;\r\nstruct hlist_head *head;\r\nstruct batadv_orig_node *orig_node;\r\nunsigned long *word;\r\nuint32_t i;\r\nsize_t word_index;\r\nuint8_t *w;\r\nint if_num;\r\nfor (i = 0; i < hash->size; i++) {\r\nhead = &hash->table[i];\r\nrcu_read_lock();\r\nhlist_for_each_entry_rcu(orig_node, head, hash_entry) {\r\nspin_lock_bh(&orig_node->bat_iv.ogm_cnt_lock);\r\nword_index = hard_iface->if_num * BATADV_NUM_WORDS;\r\nword = &orig_node->bat_iv.bcast_own[word_index];\r\nbatadv_bit_get_packet(bat_priv, word, 1, 0);\r\nif_num = hard_iface->if_num;\r\nw = &orig_node->bat_iv.bcast_own_sum[if_num];\r\n*w = bitmap_weight(word, BATADV_TQ_LOCAL_WINDOW_SIZE);\r\nspin_unlock_bh(&orig_node->bat_iv.ogm_cnt_lock);\r\n}\r\nrcu_read_unlock();\r\n}\r\n}\r\nstatic void batadv_iv_ogm_schedule(struct batadv_hard_iface *hard_iface)\r\n{\r\nstruct batadv_priv *bat_priv = netdev_priv(hard_iface->soft_iface);\r\nunsigned char **ogm_buff = &hard_iface->bat_iv.ogm_buff;\r\nstruct batadv_ogm_packet *batadv_ogm_packet;\r\nstruct batadv_hard_iface *primary_if, *tmp_hard_iface;\r\nint *ogm_buff_len = &hard_iface->bat_iv.ogm_buff_len;\r\nuint32_t seqno;\r\nuint16_t tvlv_len = 0;\r\nunsigned long send_time;\r\nprimary_if = batadv_primary_if_get_selected(bat_priv);\r\nif (hard_iface == primary_if) {\r\nbatadv_tt_local_commit_changes(bat_priv);\r\ntvlv_len = batadv_tvlv_container_ogm_append(bat_priv, ogm_buff,\r\nogm_buff_len,\r\nBATADV_OGM_HLEN);\r\n}\r\nbatadv_ogm_packet = (struct batadv_ogm_packet *)(*ogm_buff);\r\nbatadv_ogm_packet->tvlv_len = htons(tvlv_len);\r\nseqno = (uint32_t)atomic_read(&hard_iface->bat_iv.ogm_seqno);\r\nbatadv_ogm_packet->seqno = htonl(seqno);\r\natomic_inc(&hard_iface->bat_iv.ogm_seqno);\r\nbatadv_iv_ogm_slide_own_bcast_window(hard_iface);\r\nsend_time = batadv_iv_ogm_emit_send_time(bat_priv);\r\nif (hard_iface != primary_if) {\r\nbatadv_iv_ogm_queue_add(bat_priv, *ogm_buff, *ogm_buff_len,\r\nhard_iface, hard_iface, 1, send_time);\r\ngoto out;\r\n}\r\nrcu_read_lock();\r\nlist_for_each_entry_rcu(tmp_hard_iface, &batadv_hardif_list, list) {\r\nif (tmp_hard_iface->soft_iface != hard_iface->soft_iface)\r\ncontinue;\r\nbatadv_iv_ogm_queue_add(bat_priv, *ogm_buff,\r\n*ogm_buff_len, hard_iface,\r\ntmp_hard_iface, 1, send_time);\r\n}\r\nrcu_read_unlock();\r\nout:\r\nif (primary_if)\r\nbatadv_hardif_free_ref(primary_if);\r\n}\r\nstatic void\r\nbatadv_iv_ogm_orig_update(struct batadv_priv *bat_priv,\r\nstruct batadv_orig_node *orig_node,\r\nstruct batadv_orig_ifinfo *orig_ifinfo,\r\nconst struct ethhdr *ethhdr,\r\nconst struct batadv_ogm_packet *batadv_ogm_packet,\r\nstruct batadv_hard_iface *if_incoming,\r\nstruct batadv_hard_iface *if_outgoing,\r\nenum batadv_dup_status dup_status)\r\n{\r\nstruct batadv_neigh_ifinfo *neigh_ifinfo = NULL;\r\nstruct batadv_neigh_ifinfo *router_ifinfo = NULL;\r\nstruct batadv_neigh_node *neigh_node = NULL, *tmp_neigh_node = NULL;\r\nstruct batadv_neigh_node *router = NULL;\r\nstruct batadv_orig_node *orig_node_tmp;\r\nint if_num;\r\nuint8_t sum_orig, sum_neigh;\r\nuint8_t *neigh_addr;\r\nuint8_t tq_avg;\r\nbatadv_dbg(BATADV_DBG_BATMAN, bat_priv,\r\n"update_originator(): Searching and updating originator entry of received packet\n");\r\nrcu_read_lock();\r\nhlist_for_each_entry_rcu(tmp_neigh_node,\r\n&orig_node->neigh_list, list) {\r\nneigh_addr = tmp_neigh_node->addr;\r\nif (batadv_compare_eth(neigh_addr, ethhdr->h_source) &&\r\ntmp_neigh_node->if_incoming == if_incoming &&\r\natomic_inc_not_zero(&tmp_neigh_node->refcount)) {\r\nif (WARN(neigh_node, "too many matching neigh_nodes"))\r\nbatadv_neigh_node_free_ref(neigh_node);\r\nneigh_node = tmp_neigh_node;\r\ncontinue;\r\n}\r\nif (dup_status != BATADV_NO_DUP)\r\ncontinue;\r\nneigh_ifinfo = batadv_neigh_ifinfo_get(tmp_neigh_node,\r\nif_outgoing);\r\nif (!neigh_ifinfo)\r\ncontinue;\r\nspin_lock_bh(&tmp_neigh_node->ifinfo_lock);\r\nbatadv_ring_buffer_set(neigh_ifinfo->bat_iv.tq_recv,\r\n&neigh_ifinfo->bat_iv.tq_index, 0);\r\ntq_avg = batadv_ring_buffer_avg(neigh_ifinfo->bat_iv.tq_recv);\r\nneigh_ifinfo->bat_iv.tq_avg = tq_avg;\r\nspin_unlock_bh(&tmp_neigh_node->ifinfo_lock);\r\nbatadv_neigh_ifinfo_free_ref(neigh_ifinfo);\r\nneigh_ifinfo = NULL;\r\n}\r\nif (!neigh_node) {\r\nstruct batadv_orig_node *orig_tmp;\r\norig_tmp = batadv_iv_ogm_orig_get(bat_priv, ethhdr->h_source);\r\nif (!orig_tmp)\r\ngoto unlock;\r\nneigh_node = batadv_iv_ogm_neigh_new(if_incoming,\r\nethhdr->h_source,\r\norig_node, orig_tmp);\r\nbatadv_orig_node_free_ref(orig_tmp);\r\nif (!neigh_node)\r\ngoto unlock;\r\n} else\r\nbatadv_dbg(BATADV_DBG_BATMAN, bat_priv,\r\n"Updating existing last-hop neighbor of originator\n");\r\nrcu_read_unlock();\r\nneigh_ifinfo = batadv_neigh_ifinfo_new(neigh_node, if_outgoing);\r\nif (!neigh_ifinfo)\r\ngoto out;\r\nneigh_node->last_seen = jiffies;\r\nspin_lock_bh(&neigh_node->ifinfo_lock);\r\nbatadv_ring_buffer_set(neigh_ifinfo->bat_iv.tq_recv,\r\n&neigh_ifinfo->bat_iv.tq_index,\r\nbatadv_ogm_packet->tq);\r\ntq_avg = batadv_ring_buffer_avg(neigh_ifinfo->bat_iv.tq_recv);\r\nneigh_ifinfo->bat_iv.tq_avg = tq_avg;\r\nspin_unlock_bh(&neigh_node->ifinfo_lock);\r\nif (dup_status == BATADV_NO_DUP) {\r\norig_ifinfo->last_ttl = batadv_ogm_packet->ttl;\r\nneigh_ifinfo->last_ttl = batadv_ogm_packet->ttl;\r\n}\r\nrouter = batadv_orig_router_get(orig_node, if_outgoing);\r\nif (router == neigh_node)\r\ngoto out;\r\nif (router) {\r\nrouter_ifinfo = batadv_neigh_ifinfo_get(router, if_outgoing);\r\nif (!router_ifinfo)\r\ngoto out;\r\nif (router_ifinfo->bat_iv.tq_avg > neigh_ifinfo->bat_iv.tq_avg)\r\ngoto out;\r\n}\r\nif (router_ifinfo &&\r\n(neigh_ifinfo->bat_iv.tq_avg == router_ifinfo->bat_iv.tq_avg)) {\r\norig_node_tmp = router->orig_node;\r\nspin_lock_bh(&orig_node_tmp->bat_iv.ogm_cnt_lock);\r\nif_num = router->if_incoming->if_num;\r\nsum_orig = orig_node_tmp->bat_iv.bcast_own_sum[if_num];\r\nspin_unlock_bh(&orig_node_tmp->bat_iv.ogm_cnt_lock);\r\norig_node_tmp = neigh_node->orig_node;\r\nspin_lock_bh(&orig_node_tmp->bat_iv.ogm_cnt_lock);\r\nif_num = neigh_node->if_incoming->if_num;\r\nsum_neigh = orig_node_tmp->bat_iv.bcast_own_sum[if_num];\r\nspin_unlock_bh(&orig_node_tmp->bat_iv.ogm_cnt_lock);\r\nif (sum_orig >= sum_neigh)\r\ngoto out;\r\n}\r\nbatadv_update_route(bat_priv, orig_node, if_outgoing, neigh_node);\r\ngoto out;\r\nunlock:\r\nrcu_read_unlock();\r\nout:\r\nif (neigh_node)\r\nbatadv_neigh_node_free_ref(neigh_node);\r\nif (router)\r\nbatadv_neigh_node_free_ref(router);\r\nif (neigh_ifinfo)\r\nbatadv_neigh_ifinfo_free_ref(neigh_ifinfo);\r\nif (router_ifinfo)\r\nbatadv_neigh_ifinfo_free_ref(router_ifinfo);\r\n}\r\nstatic int batadv_iv_ogm_calc_tq(struct batadv_orig_node *orig_node,\r\nstruct batadv_orig_node *orig_neigh_node,\r\nstruct batadv_ogm_packet *batadv_ogm_packet,\r\nstruct batadv_hard_iface *if_incoming,\r\nstruct batadv_hard_iface *if_outgoing)\r\n{\r\nstruct batadv_priv *bat_priv = netdev_priv(if_incoming->soft_iface);\r\nstruct batadv_neigh_node *neigh_node = NULL, *tmp_neigh_node;\r\nstruct batadv_neigh_ifinfo *neigh_ifinfo;\r\nuint8_t total_count;\r\nuint8_t orig_eq_count, neigh_rq_count, neigh_rq_inv, tq_own;\r\nunsigned int neigh_rq_inv_cube, neigh_rq_max_cube;\r\nint tq_asym_penalty, inv_asym_penalty, if_num, ret = 0;\r\nunsigned int combined_tq;\r\nint tq_iface_penalty;\r\nrcu_read_lock();\r\nhlist_for_each_entry_rcu(tmp_neigh_node,\r\n&orig_neigh_node->neigh_list, list) {\r\nif (!batadv_compare_eth(tmp_neigh_node->addr,\r\norig_neigh_node->orig))\r\ncontinue;\r\nif (tmp_neigh_node->if_incoming != if_incoming)\r\ncontinue;\r\nif (!atomic_inc_not_zero(&tmp_neigh_node->refcount))\r\ncontinue;\r\nneigh_node = tmp_neigh_node;\r\nbreak;\r\n}\r\nrcu_read_unlock();\r\nif (!neigh_node)\r\nneigh_node = batadv_iv_ogm_neigh_new(if_incoming,\r\norig_neigh_node->orig,\r\norig_neigh_node,\r\norig_neigh_node);\r\nif (!neigh_node)\r\ngoto out;\r\nif (orig_node == orig_neigh_node)\r\nneigh_node->last_seen = jiffies;\r\norig_node->last_seen = jiffies;\r\nspin_lock_bh(&orig_node->bat_iv.ogm_cnt_lock);\r\nif_num = if_incoming->if_num;\r\norig_eq_count = orig_neigh_node->bat_iv.bcast_own_sum[if_num];\r\nneigh_ifinfo = batadv_neigh_ifinfo_new(neigh_node, if_outgoing);\r\nif (neigh_ifinfo) {\r\nneigh_rq_count = neigh_ifinfo->bat_iv.real_packet_count;\r\nbatadv_neigh_ifinfo_free_ref(neigh_ifinfo);\r\n} else {\r\nneigh_rq_count = 0;\r\n}\r\nspin_unlock_bh(&orig_node->bat_iv.ogm_cnt_lock);\r\nif (orig_eq_count > neigh_rq_count)\r\ntotal_count = neigh_rq_count;\r\nelse\r\ntotal_count = orig_eq_count;\r\nif (total_count < BATADV_TQ_LOCAL_BIDRECT_SEND_MINIMUM ||\r\nneigh_rq_count < BATADV_TQ_LOCAL_BIDRECT_RECV_MINIMUM)\r\ntq_own = 0;\r\nelse\r\ntq_own = (BATADV_TQ_MAX_VALUE * total_count) / neigh_rq_count;\r\nneigh_rq_inv = BATADV_TQ_LOCAL_WINDOW_SIZE - neigh_rq_count;\r\nneigh_rq_inv_cube = neigh_rq_inv * neigh_rq_inv * neigh_rq_inv;\r\nneigh_rq_max_cube = BATADV_TQ_LOCAL_WINDOW_SIZE *\r\nBATADV_TQ_LOCAL_WINDOW_SIZE *\r\nBATADV_TQ_LOCAL_WINDOW_SIZE;\r\ninv_asym_penalty = BATADV_TQ_MAX_VALUE * neigh_rq_inv_cube;\r\ninv_asym_penalty /= neigh_rq_max_cube;\r\ntq_asym_penalty = BATADV_TQ_MAX_VALUE - inv_asym_penalty;\r\ntq_iface_penalty = BATADV_TQ_MAX_VALUE;\r\nif (if_outgoing && (if_incoming == if_outgoing) &&\r\nbatadv_is_wifi_netdev(if_outgoing->net_dev))\r\ntq_iface_penalty = batadv_hop_penalty(BATADV_TQ_MAX_VALUE,\r\nbat_priv);\r\ncombined_tq = batadv_ogm_packet->tq *\r\ntq_own *\r\ntq_asym_penalty *\r\ntq_iface_penalty;\r\ncombined_tq /= BATADV_TQ_MAX_VALUE *\r\nBATADV_TQ_MAX_VALUE *\r\nBATADV_TQ_MAX_VALUE;\r\nbatadv_ogm_packet->tq = combined_tq;\r\nbatadv_dbg(BATADV_DBG_BATMAN, bat_priv,\r\n"bidirectional: orig = %-15pM neigh = %-15pM => own_bcast = %2i, real recv = %2i, local tq: %3i, asym_penalty: %3i, iface_penalty: %3i, total tq: %3i, if_incoming = %s, if_outgoing = %s\n",\r\norig_node->orig, orig_neigh_node->orig, total_count,\r\nneigh_rq_count, tq_own, tq_asym_penalty, tq_iface_penalty,\r\nbatadv_ogm_packet->tq, if_incoming->net_dev->name,\r\nif_outgoing ? if_outgoing->net_dev->name : "DEFAULT");\r\nif (batadv_ogm_packet->tq >= BATADV_TQ_TOTAL_BIDRECT_LIMIT)\r\nret = 1;\r\nout:\r\nif (neigh_node)\r\nbatadv_neigh_node_free_ref(neigh_node);\r\nreturn ret;\r\n}\r\nstatic enum batadv_dup_status\r\nbatadv_iv_ogm_update_seqnos(const struct ethhdr *ethhdr,\r\nconst struct batadv_ogm_packet *batadv_ogm_packet,\r\nconst struct batadv_hard_iface *if_incoming,\r\nstruct batadv_hard_iface *if_outgoing)\r\n{\r\nstruct batadv_priv *bat_priv = netdev_priv(if_incoming->soft_iface);\r\nstruct batadv_orig_node *orig_node;\r\nstruct batadv_orig_ifinfo *orig_ifinfo = NULL;\r\nstruct batadv_neigh_node *neigh_node;\r\nstruct batadv_neigh_ifinfo *neigh_ifinfo;\r\nint is_dup;\r\nint32_t seq_diff;\r\nint need_update = 0;\r\nint set_mark;\r\nenum batadv_dup_status ret = BATADV_NO_DUP;\r\nuint32_t seqno = ntohl(batadv_ogm_packet->seqno);\r\nuint8_t *neigh_addr;\r\nuint8_t packet_count;\r\nunsigned long *bitmap;\r\norig_node = batadv_iv_ogm_orig_get(bat_priv, batadv_ogm_packet->orig);\r\nif (!orig_node)\r\nreturn BATADV_NO_DUP;\r\norig_ifinfo = batadv_orig_ifinfo_new(orig_node, if_outgoing);\r\nif (WARN_ON(!orig_ifinfo)) {\r\nbatadv_orig_node_free_ref(orig_node);\r\nreturn 0;\r\n}\r\nspin_lock_bh(&orig_node->bat_iv.ogm_cnt_lock);\r\nseq_diff = seqno - orig_ifinfo->last_real_seqno;\r\nif (!hlist_empty(&orig_node->neigh_list) &&\r\nbatadv_window_protected(bat_priv, seq_diff,\r\n&orig_ifinfo->batman_seqno_reset)) {\r\nret = BATADV_PROTECTED;\r\ngoto out;\r\n}\r\nrcu_read_lock();\r\nhlist_for_each_entry_rcu(neigh_node, &orig_node->neigh_list, list) {\r\nneigh_ifinfo = batadv_neigh_ifinfo_new(neigh_node,\r\nif_outgoing);\r\nif (!neigh_ifinfo)\r\ncontinue;\r\nneigh_addr = neigh_node->addr;\r\nis_dup = batadv_test_bit(neigh_ifinfo->bat_iv.real_bits,\r\norig_ifinfo->last_real_seqno,\r\nseqno);\r\nif (batadv_compare_eth(neigh_addr, ethhdr->h_source) &&\r\nneigh_node->if_incoming == if_incoming) {\r\nset_mark = 1;\r\nif (is_dup)\r\nret = BATADV_NEIGH_DUP;\r\n} else {\r\nset_mark = 0;\r\nif (is_dup && (ret != BATADV_NEIGH_DUP))\r\nret = BATADV_ORIG_DUP;\r\n}\r\nbitmap = neigh_ifinfo->bat_iv.real_bits;\r\nneed_update |= batadv_bit_get_packet(bat_priv, bitmap,\r\nseq_diff, set_mark);\r\npacket_count = bitmap_weight(bitmap,\r\nBATADV_TQ_LOCAL_WINDOW_SIZE);\r\nneigh_ifinfo->bat_iv.real_packet_count = packet_count;\r\nbatadv_neigh_ifinfo_free_ref(neigh_ifinfo);\r\n}\r\nrcu_read_unlock();\r\nif (need_update) {\r\nbatadv_dbg(BATADV_DBG_BATMAN, bat_priv,\r\n"%s updating last_seqno: old %u, new %u\n",\r\nif_outgoing ? if_outgoing->net_dev->name : "DEFAULT",\r\norig_ifinfo->last_real_seqno, seqno);\r\norig_ifinfo->last_real_seqno = seqno;\r\n}\r\nout:\r\nspin_unlock_bh(&orig_node->bat_iv.ogm_cnt_lock);\r\nbatadv_orig_node_free_ref(orig_node);\r\nif (orig_ifinfo)\r\nbatadv_orig_ifinfo_free_ref(orig_ifinfo);\r\nreturn ret;\r\n}\r\nstatic void\r\nbatadv_iv_ogm_process_per_outif(const struct sk_buff *skb, int ogm_offset,\r\nstruct batadv_orig_node *orig_node,\r\nstruct batadv_hard_iface *if_incoming,\r\nstruct batadv_hard_iface *if_outgoing)\r\n{\r\nstruct batadv_priv *bat_priv = netdev_priv(if_incoming->soft_iface);\r\nstruct batadv_neigh_node *router = NULL, *router_router = NULL;\r\nstruct batadv_orig_node *orig_neigh_node;\r\nstruct batadv_orig_ifinfo *orig_ifinfo;\r\nstruct batadv_neigh_node *orig_neigh_router = NULL;\r\nstruct batadv_neigh_ifinfo *router_ifinfo = NULL;\r\nstruct batadv_ogm_packet *ogm_packet;\r\nenum batadv_dup_status dup_status;\r\nbool is_from_best_next_hop = false;\r\nbool is_single_hop_neigh = false;\r\nbool sameseq, similar_ttl;\r\nstruct sk_buff *skb_priv;\r\nstruct ethhdr *ethhdr;\r\nuint8_t *prev_sender;\r\nint is_bidirect;\r\nskb_priv = skb_copy(skb, GFP_ATOMIC);\r\nif (!skb_priv)\r\nreturn;\r\nethhdr = eth_hdr(skb_priv);\r\nogm_packet = (struct batadv_ogm_packet *)(skb_priv->data + ogm_offset);\r\ndup_status = batadv_iv_ogm_update_seqnos(ethhdr, ogm_packet,\r\nif_incoming, if_outgoing);\r\nif (batadv_compare_eth(ethhdr->h_source, ogm_packet->orig))\r\nis_single_hop_neigh = true;\r\nif (dup_status == BATADV_PROTECTED) {\r\nbatadv_dbg(BATADV_DBG_BATMAN, bat_priv,\r\n"Drop packet: packet within seqno protection time (sender: %pM)\n",\r\nethhdr->h_source);\r\ngoto out;\r\n}\r\nif (ogm_packet->tq == 0) {\r\nbatadv_dbg(BATADV_DBG_BATMAN, bat_priv,\r\n"Drop packet: originator packet with tq equal 0\n");\r\ngoto out;\r\n}\r\nrouter = batadv_orig_router_get(orig_node, if_outgoing);\r\nif (router) {\r\nrouter_router = batadv_orig_router_get(router->orig_node,\r\nif_outgoing);\r\nrouter_ifinfo = batadv_neigh_ifinfo_get(router, if_outgoing);\r\n}\r\nif ((router_ifinfo && router_ifinfo->bat_iv.tq_avg != 0) &&\r\n(batadv_compare_eth(router->addr, ethhdr->h_source)))\r\nis_from_best_next_hop = true;\r\nprev_sender = ogm_packet->prev_sender;\r\nif (router && router_router &&\r\n(batadv_compare_eth(router->addr, prev_sender)) &&\r\n!(batadv_compare_eth(ogm_packet->orig, prev_sender)) &&\r\n(batadv_compare_eth(router->addr, router_router->addr))) {\r\nbatadv_dbg(BATADV_DBG_BATMAN, bat_priv,\r\n"Drop packet: ignoring all rebroadcast packets that may make me loop (sender: %pM)\n",\r\nethhdr->h_source);\r\ngoto out;\r\n}\r\nif (if_outgoing == BATADV_IF_DEFAULT)\r\nbatadv_tvlv_ogm_receive(bat_priv, ogm_packet, orig_node);\r\nif (is_single_hop_neigh)\r\norig_neigh_node = orig_node;\r\nelse\r\norig_neigh_node = batadv_iv_ogm_orig_get(bat_priv,\r\nethhdr->h_source);\r\nif (!orig_neigh_node)\r\ngoto out;\r\nbatadv_nc_update_nc_node(bat_priv, orig_node, orig_neigh_node,\r\nogm_packet, is_single_hop_neigh);\r\norig_neigh_router = batadv_orig_router_get(orig_neigh_node,\r\nif_outgoing);\r\nif (!is_single_hop_neigh && (!orig_neigh_router)) {\r\nbatadv_dbg(BATADV_DBG_BATMAN, bat_priv,\r\n"Drop packet: OGM via unknown neighbor!\n");\r\ngoto out_neigh;\r\n}\r\nis_bidirect = batadv_iv_ogm_calc_tq(orig_node, orig_neigh_node,\r\nogm_packet, if_incoming,\r\nif_outgoing);\r\norig_ifinfo = batadv_orig_ifinfo_new(orig_node, if_outgoing);\r\nif (!orig_ifinfo)\r\ngoto out_neigh;\r\nsameseq = orig_ifinfo->last_real_seqno == ntohl(ogm_packet->seqno);\r\nsimilar_ttl = (orig_ifinfo->last_ttl - 3) <= ogm_packet->ttl;\r\nif (is_bidirect && ((dup_status == BATADV_NO_DUP) ||\r\n(sameseq && similar_ttl))) {\r\nbatadv_iv_ogm_orig_update(bat_priv, orig_node,\r\norig_ifinfo, ethhdr,\r\nogm_packet, if_incoming,\r\nif_outgoing, dup_status);\r\n}\r\nbatadv_orig_ifinfo_free_ref(orig_ifinfo);\r\nif (if_outgoing == BATADV_IF_DEFAULT)\r\ngoto out_neigh;\r\nif (is_single_hop_neigh) {\r\nif ((ogm_packet->ttl <= 2) &&\r\n(if_incoming != if_outgoing)) {\r\nbatadv_dbg(BATADV_DBG_BATMAN, bat_priv,\r\n"Drop packet: OGM from secondary interface and wrong outgoing interface\n");\r\ngoto out_neigh;\r\n}\r\nbatadv_iv_ogm_forward(orig_node, ethhdr, ogm_packet,\r\nis_single_hop_neigh,\r\nis_from_best_next_hop, if_incoming,\r\nif_outgoing);\r\nbatadv_dbg(BATADV_DBG_BATMAN, bat_priv,\r\n"Forwarding packet: rebroadcast neighbor packet with direct link flag\n");\r\ngoto out_neigh;\r\n}\r\nif (!is_bidirect) {\r\nbatadv_dbg(BATADV_DBG_BATMAN, bat_priv,\r\n"Drop packet: not received via bidirectional link\n");\r\ngoto out_neigh;\r\n}\r\nif (dup_status == BATADV_NEIGH_DUP) {\r\nbatadv_dbg(BATADV_DBG_BATMAN, bat_priv,\r\n"Drop packet: duplicate packet received\n");\r\ngoto out_neigh;\r\n}\r\nbatadv_dbg(BATADV_DBG_BATMAN, bat_priv,\r\n"Forwarding packet: rebroadcast originator packet\n");\r\nbatadv_iv_ogm_forward(orig_node, ethhdr, ogm_packet,\r\nis_single_hop_neigh, is_from_best_next_hop,\r\nif_incoming, if_outgoing);\r\nout_neigh:\r\nif ((orig_neigh_node) && (!is_single_hop_neigh))\r\nbatadv_orig_node_free_ref(orig_neigh_node);\r\nout:\r\nif (router_ifinfo)\r\nbatadv_neigh_ifinfo_free_ref(router_ifinfo);\r\nif (router)\r\nbatadv_neigh_node_free_ref(router);\r\nif (router_router)\r\nbatadv_neigh_node_free_ref(router_router);\r\nif (orig_neigh_router)\r\nbatadv_neigh_node_free_ref(orig_neigh_router);\r\nkfree_skb(skb_priv);\r\n}\r\nstatic void batadv_iv_ogm_process(const struct sk_buff *skb, int ogm_offset,\r\nstruct batadv_hard_iface *if_incoming)\r\n{\r\nstruct batadv_priv *bat_priv = netdev_priv(if_incoming->soft_iface);\r\nstruct batadv_orig_node *orig_neigh_node, *orig_node;\r\nstruct batadv_hard_iface *hard_iface;\r\nstruct batadv_ogm_packet *ogm_packet;\r\nuint32_t if_incoming_seqno;\r\nbool has_directlink_flag;\r\nstruct ethhdr *ethhdr;\r\nbool is_my_oldorig = false;\r\nbool is_my_addr = false;\r\nbool is_my_orig = false;\r\nogm_packet = (struct batadv_ogm_packet *)(skb->data + ogm_offset);\r\nethhdr = eth_hdr(skb);\r\nif (ogm_packet->packet_type != BATADV_IV_OGM)\r\nreturn;\r\nif_incoming_seqno = atomic_read(&if_incoming->bat_iv.ogm_seqno);\r\nif (ogm_packet->flags & BATADV_DIRECTLINK)\r\nhas_directlink_flag = true;\r\nelse\r\nhas_directlink_flag = false;\r\nbatadv_dbg(BATADV_DBG_BATMAN, bat_priv,\r\n"Received BATMAN packet via NB: %pM, IF: %s [%pM] (from OG: %pM, via prev OG: %pM, seqno %u, tq %d, TTL %d, V %d, IDF %d)\n",\r\nethhdr->h_source, if_incoming->net_dev->name,\r\nif_incoming->net_dev->dev_addr, ogm_packet->orig,\r\nogm_packet->prev_sender, ntohl(ogm_packet->seqno),\r\nogm_packet->tq, ogm_packet->ttl,\r\nogm_packet->version, has_directlink_flag);\r\nrcu_read_lock();\r\nlist_for_each_entry_rcu(hard_iface, &batadv_hardif_list, list) {\r\nif (hard_iface->if_status != BATADV_IF_ACTIVE)\r\ncontinue;\r\nif (hard_iface->soft_iface != if_incoming->soft_iface)\r\ncontinue;\r\nif (batadv_compare_eth(ethhdr->h_source,\r\nhard_iface->net_dev->dev_addr))\r\nis_my_addr = true;\r\nif (batadv_compare_eth(ogm_packet->orig,\r\nhard_iface->net_dev->dev_addr))\r\nis_my_orig = true;\r\nif (batadv_compare_eth(ogm_packet->prev_sender,\r\nhard_iface->net_dev->dev_addr))\r\nis_my_oldorig = true;\r\n}\r\nrcu_read_unlock();\r\nif (is_my_addr) {\r\nbatadv_dbg(BATADV_DBG_BATMAN, bat_priv,\r\n"Drop packet: received my own broadcast (sender: %pM)\n",\r\nethhdr->h_source);\r\nreturn;\r\n}\r\nif (is_my_orig) {\r\nunsigned long *word;\r\nint offset;\r\nint32_t bit_pos;\r\nint16_t if_num;\r\nuint8_t *weight;\r\norig_neigh_node = batadv_iv_ogm_orig_get(bat_priv,\r\nethhdr->h_source);\r\nif (!orig_neigh_node)\r\nreturn;\r\nif (has_directlink_flag &&\r\nbatadv_compare_eth(if_incoming->net_dev->dev_addr,\r\nogm_packet->orig)) {\r\nif_num = if_incoming->if_num;\r\noffset = if_num * BATADV_NUM_WORDS;\r\nspin_lock_bh(&orig_neigh_node->bat_iv.ogm_cnt_lock);\r\nword = &orig_neigh_node->bat_iv.bcast_own[offset];\r\nbit_pos = if_incoming_seqno - 2;\r\nbit_pos -= ntohl(ogm_packet->seqno);\r\nbatadv_set_bit(word, bit_pos);\r\nweight = &orig_neigh_node->bat_iv.bcast_own_sum[if_num];\r\n*weight = bitmap_weight(word,\r\nBATADV_TQ_LOCAL_WINDOW_SIZE);\r\nspin_unlock_bh(&orig_neigh_node->bat_iv.ogm_cnt_lock);\r\n}\r\nbatadv_dbg(BATADV_DBG_BATMAN, bat_priv,\r\n"Drop packet: originator packet from myself (via neighbor)\n");\r\nbatadv_orig_node_free_ref(orig_neigh_node);\r\nreturn;\r\n}\r\nif (is_my_oldorig) {\r\nbatadv_dbg(BATADV_DBG_BATMAN, bat_priv,\r\n"Drop packet: ignoring all rebroadcast echos (sender: %pM)\n",\r\nethhdr->h_source);\r\nreturn;\r\n}\r\nif (ogm_packet->flags & BATADV_NOT_BEST_NEXT_HOP) {\r\nbatadv_dbg(BATADV_DBG_BATMAN, bat_priv,\r\n"Drop packet: ignoring all packets not forwarded from the best next hop (sender: %pM)\n",\r\nethhdr->h_source);\r\nreturn;\r\n}\r\norig_node = batadv_iv_ogm_orig_get(bat_priv, ogm_packet->orig);\r\nif (!orig_node)\r\nreturn;\r\nbatadv_iv_ogm_process_per_outif(skb, ogm_offset, orig_node,\r\nif_incoming, BATADV_IF_DEFAULT);\r\nrcu_read_lock();\r\nlist_for_each_entry_rcu(hard_iface, &batadv_hardif_list, list) {\r\nif (hard_iface->if_status != BATADV_IF_ACTIVE)\r\ncontinue;\r\nif (hard_iface->soft_iface != bat_priv->soft_iface)\r\ncontinue;\r\nbatadv_iv_ogm_process_per_outif(skb, ogm_offset, orig_node,\r\nif_incoming, hard_iface);\r\n}\r\nrcu_read_unlock();\r\nbatadv_orig_node_free_ref(orig_node);\r\n}\r\nstatic int batadv_iv_ogm_receive(struct sk_buff *skb,\r\nstruct batadv_hard_iface *if_incoming)\r\n{\r\nstruct batadv_priv *bat_priv = netdev_priv(if_incoming->soft_iface);\r\nstruct batadv_ogm_packet *ogm_packet;\r\nuint8_t *packet_pos;\r\nint ogm_offset;\r\nbool ret;\r\nret = batadv_check_management_packet(skb, if_incoming, BATADV_OGM_HLEN);\r\nif (!ret)\r\nreturn NET_RX_DROP;\r\nif (bat_priv->bat_algo_ops->bat_ogm_emit != batadv_iv_ogm_emit)\r\nreturn NET_RX_DROP;\r\nbatadv_inc_counter(bat_priv, BATADV_CNT_MGMT_RX);\r\nbatadv_add_counter(bat_priv, BATADV_CNT_MGMT_RX_BYTES,\r\nskb->len + ETH_HLEN);\r\nogm_offset = 0;\r\nogm_packet = (struct batadv_ogm_packet *)skb->data;\r\nwhile (batadv_iv_ogm_aggr_packet(ogm_offset, skb_headlen(skb),\r\nogm_packet->tvlv_len)) {\r\nbatadv_iv_ogm_process(skb, ogm_offset, if_incoming);\r\nogm_offset += BATADV_OGM_HLEN;\r\nogm_offset += ntohs(ogm_packet->tvlv_len);\r\npacket_pos = skb->data + ogm_offset;\r\nogm_packet = (struct batadv_ogm_packet *)packet_pos;\r\n}\r\nkfree_skb(skb);\r\nreturn NET_RX_SUCCESS;\r\n}\r\nstatic void\r\nbatadv_iv_ogm_orig_print_neigh(struct batadv_orig_node *orig_node,\r\nstruct batadv_hard_iface *if_outgoing,\r\nstruct seq_file *seq)\r\n{\r\nstruct batadv_neigh_node *neigh_node;\r\nstruct batadv_neigh_ifinfo *n_ifinfo;\r\nhlist_for_each_entry_rcu(neigh_node, &orig_node->neigh_list, list) {\r\nn_ifinfo = batadv_neigh_ifinfo_get(neigh_node, if_outgoing);\r\nif (!n_ifinfo)\r\ncontinue;\r\nseq_printf(seq, " %pM (%3i)",\r\nneigh_node->addr,\r\nn_ifinfo->bat_iv.tq_avg);\r\nbatadv_neigh_ifinfo_free_ref(n_ifinfo);\r\n}\r\n}\r\nstatic void batadv_iv_ogm_orig_print(struct batadv_priv *bat_priv,\r\nstruct seq_file *seq,\r\nstruct batadv_hard_iface *if_outgoing)\r\n{\r\nstruct batadv_neigh_node *neigh_node;\r\nstruct batadv_hashtable *hash = bat_priv->orig_hash;\r\nint last_seen_msecs, last_seen_secs;\r\nstruct batadv_orig_node *orig_node;\r\nstruct batadv_neigh_ifinfo *n_ifinfo;\r\nunsigned long last_seen_jiffies;\r\nstruct hlist_head *head;\r\nint batman_count = 0;\r\nuint32_t i;\r\nseq_printf(seq, " %-15s %s (%s/%i) %17s [%10s]: %20s ...\n",\r\n"Originator", "last-seen", "#", BATADV_TQ_MAX_VALUE,\r\n"Nexthop", "outgoingIF", "Potential nexthops");\r\nfor (i = 0; i < hash->size; i++) {\r\nhead = &hash->table[i];\r\nrcu_read_lock();\r\nhlist_for_each_entry_rcu(orig_node, head, hash_entry) {\r\nneigh_node = batadv_orig_router_get(orig_node,\r\nif_outgoing);\r\nif (!neigh_node)\r\ncontinue;\r\nn_ifinfo = batadv_neigh_ifinfo_get(neigh_node,\r\nif_outgoing);\r\nif (!n_ifinfo)\r\ngoto next;\r\nif (n_ifinfo->bat_iv.tq_avg == 0)\r\ngoto next;\r\nlast_seen_jiffies = jiffies - orig_node->last_seen;\r\nlast_seen_msecs = jiffies_to_msecs(last_seen_jiffies);\r\nlast_seen_secs = last_seen_msecs / 1000;\r\nlast_seen_msecs = last_seen_msecs % 1000;\r\nseq_printf(seq, "%pM %4i.%03is (%3i) %pM [%10s]:",\r\norig_node->orig, last_seen_secs,\r\nlast_seen_msecs, n_ifinfo->bat_iv.tq_avg,\r\nneigh_node->addr,\r\nneigh_node->if_incoming->net_dev->name);\r\nbatadv_iv_ogm_orig_print_neigh(orig_node, if_outgoing,\r\nseq);\r\nseq_puts(seq, "\n");\r\nbatman_count++;\r\nnext:\r\nbatadv_neigh_node_free_ref(neigh_node);\r\nif (n_ifinfo)\r\nbatadv_neigh_ifinfo_free_ref(n_ifinfo);\r\n}\r\nrcu_read_unlock();\r\n}\r\nif (batman_count == 0)\r\nseq_puts(seq, "No batman nodes in range ...\n");\r\n}\r\nstatic int batadv_iv_ogm_neigh_cmp(struct batadv_neigh_node *neigh1,\r\nstruct batadv_hard_iface *if_outgoing1,\r\nstruct batadv_neigh_node *neigh2,\r\nstruct batadv_hard_iface *if_outgoing2)\r\n{\r\nstruct batadv_neigh_ifinfo *neigh1_ifinfo, *neigh2_ifinfo;\r\nuint8_t tq1, tq2;\r\nint diff;\r\nneigh1_ifinfo = batadv_neigh_ifinfo_get(neigh1, if_outgoing1);\r\nneigh2_ifinfo = batadv_neigh_ifinfo_get(neigh2, if_outgoing2);\r\nif (!neigh1_ifinfo || !neigh2_ifinfo) {\r\ndiff = 0;\r\ngoto out;\r\n}\r\ntq1 = neigh1_ifinfo->bat_iv.tq_avg;\r\ntq2 = neigh2_ifinfo->bat_iv.tq_avg;\r\ndiff = tq1 - tq2;\r\nout:\r\nif (neigh1_ifinfo)\r\nbatadv_neigh_ifinfo_free_ref(neigh1_ifinfo);\r\nif (neigh2_ifinfo)\r\nbatadv_neigh_ifinfo_free_ref(neigh2_ifinfo);\r\nreturn diff;\r\n}\r\nstatic bool\r\nbatadv_iv_ogm_neigh_is_eob(struct batadv_neigh_node *neigh1,\r\nstruct batadv_hard_iface *if_outgoing1,\r\nstruct batadv_neigh_node *neigh2,\r\nstruct batadv_hard_iface *if_outgoing2)\r\n{\r\nstruct batadv_neigh_ifinfo *neigh1_ifinfo, *neigh2_ifinfo;\r\nuint8_t tq1, tq2;\r\nbool ret;\r\nneigh1_ifinfo = batadv_neigh_ifinfo_get(neigh1, if_outgoing1);\r\nneigh2_ifinfo = batadv_neigh_ifinfo_get(neigh2, if_outgoing2);\r\nif (!neigh1_ifinfo || !neigh2_ifinfo) {\r\nret = false;\r\ngoto out;\r\n}\r\ntq1 = neigh1_ifinfo->bat_iv.tq_avg;\r\ntq2 = neigh2_ifinfo->bat_iv.tq_avg;\r\nret = (tq1 - tq2) > -BATADV_TQ_SIMILARITY_THRESHOLD;\r\nout:\r\nif (neigh1_ifinfo)\r\nbatadv_neigh_ifinfo_free_ref(neigh1_ifinfo);\r\nif (neigh2_ifinfo)\r\nbatadv_neigh_ifinfo_free_ref(neigh2_ifinfo);\r\nreturn ret;\r\n}\r\nint __init batadv_iv_init(void)\r\n{\r\nint ret;\r\nret = batadv_recv_handler_register(BATADV_IV_OGM,\r\nbatadv_iv_ogm_receive);\r\nif (ret < 0)\r\ngoto out;\r\nret = batadv_algo_register(&batadv_batman_iv);\r\nif (ret < 0)\r\ngoto handler_unregister;\r\ngoto out;\r\nhandler_unregister:\r\nbatadv_recv_handler_unregister(BATADV_IV_OGM);\r\nout:\r\nreturn ret;\r\n}
