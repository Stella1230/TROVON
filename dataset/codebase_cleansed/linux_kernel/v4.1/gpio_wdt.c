static void gpio_wdt_disable(struct gpio_wdt_priv *priv)\r\n{\r\ngpio_set_value_cansleep(priv->gpio, !priv->active_low);\r\nif (priv->hw_algo == HW_ALGO_TOGGLE)\r\ngpio_direction_input(priv->gpio);\r\n}\r\nstatic void gpio_wdt_start_impl(struct gpio_wdt_priv *priv)\r\n{\r\npriv->state = priv->active_low;\r\ngpio_direction_output(priv->gpio, priv->state);\r\npriv->last_jiffies = jiffies;\r\nmod_timer(&priv->timer, priv->last_jiffies + priv->hw_margin);\r\n}\r\nstatic int gpio_wdt_start(struct watchdog_device *wdd)\r\n{\r\nstruct gpio_wdt_priv *priv = watchdog_get_drvdata(wdd);\r\ngpio_wdt_start_impl(priv);\r\npriv->armed = true;\r\nreturn 0;\r\n}\r\nstatic int gpio_wdt_stop(struct watchdog_device *wdd)\r\n{\r\nstruct gpio_wdt_priv *priv = watchdog_get_drvdata(wdd);\r\npriv->armed = false;\r\nif (!priv->always_running) {\r\nmod_timer(&priv->timer, 0);\r\ngpio_wdt_disable(priv);\r\n}\r\nreturn 0;\r\n}\r\nstatic int gpio_wdt_ping(struct watchdog_device *wdd)\r\n{\r\nstruct gpio_wdt_priv *priv = watchdog_get_drvdata(wdd);\r\npriv->last_jiffies = jiffies;\r\nreturn 0;\r\n}\r\nstatic int gpio_wdt_set_timeout(struct watchdog_device *wdd, unsigned int t)\r\n{\r\nwdd->timeout = t;\r\nreturn gpio_wdt_ping(wdd);\r\n}\r\nstatic void gpio_wdt_hwping(unsigned long data)\r\n{\r\nstruct watchdog_device *wdd = (struct watchdog_device *)data;\r\nstruct gpio_wdt_priv *priv = watchdog_get_drvdata(wdd);\r\nif (priv->armed && time_after(jiffies, priv->last_jiffies +\r\nmsecs_to_jiffies(wdd->timeout * 1000))) {\r\ndev_crit(wdd->dev, "Timer expired. System will reboot soon!\n");\r\nreturn;\r\n}\r\nmod_timer(&priv->timer, jiffies + priv->hw_margin);\r\nswitch (priv->hw_algo) {\r\ncase HW_ALGO_TOGGLE:\r\npriv->state = !priv->state;\r\ngpio_set_value_cansleep(priv->gpio, priv->state);\r\nbreak;\r\ncase HW_ALGO_LEVEL:\r\ngpio_set_value_cansleep(priv->gpio, !priv->active_low);\r\nudelay(1);\r\ngpio_set_value_cansleep(priv->gpio, priv->active_low);\r\nbreak;\r\n}\r\n}\r\nstatic int gpio_wdt_notify_sys(struct notifier_block *nb, unsigned long code,\r\nvoid *unused)\r\n{\r\nstruct gpio_wdt_priv *priv = container_of(nb, struct gpio_wdt_priv,\r\nnotifier);\r\nmod_timer(&priv->timer, 0);\r\nswitch (code) {\r\ncase SYS_HALT:\r\ncase SYS_POWER_OFF:\r\ngpio_wdt_disable(priv);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn NOTIFY_DONE;\r\n}\r\nstatic int gpio_wdt_probe(struct platform_device *pdev)\r\n{\r\nstruct gpio_wdt_priv *priv;\r\nenum of_gpio_flags flags;\r\nunsigned int hw_margin;\r\nunsigned long f = 0;\r\nconst char *algo;\r\nint ret;\r\npriv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);\r\nif (!priv)\r\nreturn -ENOMEM;\r\npriv->gpio = of_get_gpio_flags(pdev->dev.of_node, 0, &flags);\r\nif (!gpio_is_valid(priv->gpio))\r\nreturn priv->gpio;\r\npriv->active_low = flags & OF_GPIO_ACTIVE_LOW;\r\nret = of_property_read_string(pdev->dev.of_node, "hw_algo", &algo);\r\nif (ret)\r\nreturn ret;\r\nif (!strncmp(algo, "toggle", 6)) {\r\npriv->hw_algo = HW_ALGO_TOGGLE;\r\nf = GPIOF_IN;\r\n} else if (!strncmp(algo, "level", 5)) {\r\npriv->hw_algo = HW_ALGO_LEVEL;\r\nf = priv->active_low ? GPIOF_OUT_INIT_HIGH : GPIOF_OUT_INIT_LOW;\r\n} else {\r\nreturn -EINVAL;\r\n}\r\nret = devm_gpio_request_one(&pdev->dev, priv->gpio, f,\r\ndev_name(&pdev->dev));\r\nif (ret)\r\nreturn ret;\r\nret = of_property_read_u32(pdev->dev.of_node,\r\n"hw_margin_ms", &hw_margin);\r\nif (ret)\r\nreturn ret;\r\nif (hw_margin < 2 || hw_margin > 65535)\r\nreturn -EINVAL;\r\npriv->hw_margin = msecs_to_jiffies(hw_margin / 2);\r\npriv->always_running = of_property_read_bool(pdev->dev.of_node,\r\n"always-running");\r\nwatchdog_set_drvdata(&priv->wdd, priv);\r\npriv->wdd.info = &gpio_wdt_ident;\r\npriv->wdd.ops = &gpio_wdt_ops;\r\npriv->wdd.min_timeout = SOFT_TIMEOUT_MIN;\r\npriv->wdd.max_timeout = SOFT_TIMEOUT_MAX;\r\nif (watchdog_init_timeout(&priv->wdd, 0, &pdev->dev) < 0)\r\npriv->wdd.timeout = SOFT_TIMEOUT_DEF;\r\nsetup_timer(&priv->timer, gpio_wdt_hwping, (unsigned long)&priv->wdd);\r\nret = watchdog_register_device(&priv->wdd);\r\nif (ret)\r\nreturn ret;\r\npriv->notifier.notifier_call = gpio_wdt_notify_sys;\r\nret = register_reboot_notifier(&priv->notifier);\r\nif (ret)\r\ngoto error_unregister;\r\nif (priv->always_running)\r\ngpio_wdt_start_impl(priv);\r\nreturn 0;\r\nerror_unregister:\r\nwatchdog_unregister_device(&priv->wdd);\r\nreturn ret;\r\n}\r\nstatic int gpio_wdt_remove(struct platform_device *pdev)\r\n{\r\nstruct gpio_wdt_priv *priv = platform_get_drvdata(pdev);\r\ndel_timer_sync(&priv->timer);\r\nunregister_reboot_notifier(&priv->notifier);\r\nwatchdog_unregister_device(&priv->wdd);\r\nreturn 0;\r\n}
