static int rk808_set_ramp_delay(struct regulator_dev *rdev, int ramp_delay)\r\n{\r\nunsigned int ramp_value = RK808_RAMP_RATE_10MV_PER_US;\r\nunsigned int reg = rk808_buck_config_regs[rdev->desc->id -\r\nRK808_ID_DCDC1];\r\nswitch (ramp_delay) {\r\ncase 1 ... 2000:\r\nramp_value = RK808_RAMP_RATE_2MV_PER_US;\r\nbreak;\r\ncase 2001 ... 4000:\r\nramp_value = RK808_RAMP_RATE_4MV_PER_US;\r\nbreak;\r\ncase 4001 ... 6000:\r\nramp_value = RK808_RAMP_RATE_6MV_PER_US;\r\nbreak;\r\ncase 6001 ... 10000:\r\nbreak;\r\ndefault:\r\npr_warn("%s ramp_delay: %d not supported, setting 10000\n",\r\nrdev->desc->name, ramp_delay);\r\n}\r\nreturn regmap_update_bits(rdev->regmap, reg,\r\nRK808_RAMP_RATE_MASK, ramp_value);\r\n}\r\nstatic int rk808_set_suspend_voltage(struct regulator_dev *rdev, int uv)\r\n{\r\nunsigned int reg;\r\nint sel = regulator_map_voltage_linear_range(rdev, uv, uv);\r\nif (sel < 0)\r\nreturn -EINVAL;\r\nreg = rdev->desc->vsel_reg + RK808_SLP_REG_OFFSET;\r\nreturn regmap_update_bits(rdev->regmap, reg,\r\nrdev->desc->vsel_mask,\r\nsel);\r\n}\r\nstatic int rk808_set_suspend_enable(struct regulator_dev *rdev)\r\n{\r\nunsigned int reg;\r\nreg = rdev->desc->enable_reg + RK808_SLP_SET_OFF_REG_OFFSET;\r\nreturn regmap_update_bits(rdev->regmap, reg,\r\nrdev->desc->enable_mask,\r\n0);\r\n}\r\nstatic int rk808_set_suspend_disable(struct regulator_dev *rdev)\r\n{\r\nunsigned int reg;\r\nreg = rdev->desc->enable_reg + RK808_SLP_SET_OFF_REG_OFFSET;\r\nreturn regmap_update_bits(rdev->regmap, reg,\r\nrdev->desc->enable_mask,\r\nrdev->desc->enable_mask);\r\n}\r\nstatic int rk808_regulator_probe(struct platform_device *pdev)\r\n{\r\nstruct rk808 *rk808 = dev_get_drvdata(pdev->dev.parent);\r\nstruct i2c_client *client = rk808->i2c;\r\nstruct device_node *reg_np;\r\nstruct regulator_config config = {};\r\nstruct regulator_dev *rk808_rdev;\r\nint ret, i;\r\nreg_np = of_get_child_by_name(client->dev.of_node, "regulators");\r\nif (!reg_np)\r\nreturn -ENXIO;\r\nret = of_regulator_match(&pdev->dev, reg_np, rk808_reg_matches,\r\nRK808_NUM_REGULATORS);\r\nof_node_put(reg_np);\r\nif (ret < 0)\r\nreturn ret;\r\nfor (i = 0; i < RK808_NUM_REGULATORS; i++) {\r\nif (!rk808_reg_matches[i].init_data ||\r\n!rk808_reg_matches[i].of_node)\r\ncontinue;\r\nconfig.dev = &client->dev;\r\nconfig.driver_data = rk808;\r\nconfig.regmap = rk808->regmap;\r\nconfig.of_node = rk808_reg_matches[i].of_node;\r\nconfig.init_data = rk808_reg_matches[i].init_data;\r\nrk808_rdev = devm_regulator_register(&pdev->dev,\r\n&rk808_reg[i], &config);\r\nif (IS_ERR(rk808_rdev)) {\r\ndev_err(&client->dev,\r\n"failed to register %d regulator\n", i);\r\nreturn PTR_ERR(rk808_rdev);\r\n}\r\n}\r\nreturn 0;\r\n}
