static const char* host_info(struct Scsi_Host *host)\r\n{\r\nstruct us_data *us = host_to_us(host);\r\nreturn us->scsi_name;\r\n}\r\nstatic int slave_alloc (struct scsi_device *sdev)\r\n{\r\nstruct us_data *us = host_to_us(sdev->host);\r\nsdev->inquiry_len = 36;\r\nblk_queue_update_dma_alignment(sdev->request_queue, (512 - 1));\r\nif (us->protocol == USB_PR_BULK && us->max_lun > 0)\r\nsdev->sdev_bflags |= BLIST_FORCELUN;\r\nreturn 0;\r\n}\r\nstatic int slave_configure(struct scsi_device *sdev)\r\n{\r\nstruct us_data *us = host_to_us(sdev->host);\r\nif (us->fflags & (US_FL_MAX_SECTORS_64 | US_FL_MAX_SECTORS_MIN)) {\r\nunsigned int max_sectors = 64;\r\nif (us->fflags & US_FL_MAX_SECTORS_MIN)\r\nmax_sectors = PAGE_CACHE_SIZE >> 9;\r\nif (queue_max_hw_sectors(sdev->request_queue) > max_sectors)\r\nblk_queue_max_hw_sectors(sdev->request_queue,\r\nmax_sectors);\r\n} else if (sdev->type == TYPE_TAPE) {\r\nblk_queue_max_hw_sectors(sdev->request_queue, 0x7FFFFF);\r\n}\r\nif (!us->pusb_dev->bus->controller->dma_mask)\r\nblk_queue_bounce_limit(sdev->request_queue, BLK_BOUNCE_HIGH);\r\nif (sdev->type == TYPE_DISK) {\r\nswitch (le16_to_cpu(us->pusb_dev->descriptor.idVendor)) {\r\ncase VENDOR_ID_NOKIA:\r\ncase VENDOR_ID_NIKON:\r\ncase VENDOR_ID_PENTAX:\r\ncase VENDOR_ID_MOTOROLA:\r\nif (!(us->fflags & (US_FL_FIX_CAPACITY |\r\nUS_FL_CAPACITY_OK)))\r\nus->fflags |= US_FL_CAPACITY_HEURISTICS;\r\nbreak;\r\n}\r\nif (us->subclass != USB_SC_SCSI && us->subclass != USB_SC_CYP_ATACB)\r\nsdev->use_10_for_ms = 1;\r\nsdev->use_192_bytes_for_3f = 1;\r\nif (us->fflags & US_FL_NO_WP_DETECT)\r\nsdev->skip_ms_page_3f = 1;\r\nsdev->skip_ms_page_8 = 1;\r\nsdev->skip_vpd_pages = 1;\r\nsdev->no_report_opcodes = 1;\r\nsdev->no_write_same = 1;\r\nif (us->fflags & US_FL_FIX_CAPACITY)\r\nsdev->fix_capacity = 1;\r\nif (us->fflags & US_FL_CAPACITY_HEURISTICS)\r\nsdev->guess_capacity = 1;\r\nif (us->fflags & US_FL_NO_READ_CAPACITY_16)\r\nsdev->no_read_capacity_16 = 1;\r\nif (!(us->fflags & US_FL_NEEDS_CAP16))\r\nsdev->try_rc_10_first = 1;\r\nif (sdev->scsi_level > SCSI_SPC_2)\r\nus->fflags |= US_FL_SANE_SENSE;\r\nsdev->retry_hwerror = 1;\r\nsdev->allow_restart = 1;\r\nsdev->last_sector_bug = 1;\r\nif (!(us->fflags & (US_FL_FIX_CAPACITY | US_FL_CAPACITY_OK |\r\nUS_FL_SCM_MULT_TARG)) &&\r\nus->protocol == USB_PR_BULK)\r\nus->use_last_sector_hacks = 1;\r\nif (us->fflags & US_FL_WRITE_CACHE)\r\nsdev->wce_default_on = 1;\r\nif (us->fflags & US_FL_BROKEN_FUA)\r\nsdev->broken_fua = 1;\r\n} else {\r\nsdev->use_10_for_ms = 1;\r\nif (us->fflags & US_FL_NO_READ_DISC_INFO)\r\nsdev->no_read_disc_info = 1;\r\n}\r\nif ((us->protocol == USB_PR_CB || us->protocol == USB_PR_CBI) &&\r\nsdev->scsi_level == SCSI_UNKNOWN)\r\nus->max_lun = 0;\r\nif (us->fflags & US_FL_NOT_LOCKABLE)\r\nsdev->lockable = 0;\r\nreturn 0;\r\n}\r\nstatic int target_alloc(struct scsi_target *starget)\r\n{\r\nstruct us_data *us = host_to_us(dev_to_shost(starget->dev.parent));\r\nstarget->no_report_luns = 1;\r\nif (us->subclass == USB_SC_UFI)\r\nstarget->pdt_1f_for_no_lun = 1;\r\nreturn 0;\r\n}\r\nstatic int queuecommand_lck(struct scsi_cmnd *srb,\r\nvoid (*done)(struct scsi_cmnd *))\r\n{\r\nstruct us_data *us = host_to_us(srb->device->host);\r\nif (us->srb != NULL) {\r\nprintk(KERN_ERR USB_STORAGE "Error in %s: us->srb = %p\n",\r\n__func__, us->srb);\r\nreturn SCSI_MLQUEUE_HOST_BUSY;\r\n}\r\nif (test_bit(US_FLIDX_DISCONNECTING, &us->dflags)) {\r\nusb_stor_dbg(us, "Fail command during disconnect\n");\r\nsrb->result = DID_NO_CONNECT << 16;\r\ndone(srb);\r\nreturn 0;\r\n}\r\nsrb->scsi_done = done;\r\nus->srb = srb;\r\ncomplete(&us->cmnd_ready);\r\nreturn 0;\r\n}\r\nint device_reset(struct scsi_cmnd *srb)\r\n{\r\nstruct us_data *us = host_to_us(srb->device->host);\r\nint result;\r\nusb_stor_dbg(us, "%s called\n", __func__);\r\nmutex_lock(&(us->dev_mutex));\r\nresult = us->transport_reset(us);\r\nmutex_unlock(&us->dev_mutex);\r\nreturn result < 0 ? FAILED : SUCCESS;\r\n}\r\nstatic int bus_reset(struct scsi_cmnd *srb)\r\n{\r\nstruct us_data *us = host_to_us(srb->device->host);\r\nint result;\r\nusb_stor_dbg(us, "%s called\n", __func__);\r\nresult = usb_stor_port_reset(us);\r\nreturn result < 0 ? FAILED : SUCCESS;\r\n}\r\nvoid usb_stor_report_device_reset(struct us_data *us)\r\n{\r\nint i;\r\nstruct Scsi_Host *host = us_to_host(us);\r\nscsi_report_device_reset(host, 0, 0);\r\nif (us->fflags & US_FL_SCM_MULT_TARG) {\r\nfor (i = 1; i < host->max_id; ++i)\r\nscsi_report_device_reset(host, 0, i);\r\n}\r\n}\r\nvoid usb_stor_report_bus_reset(struct us_data *us)\r\n{\r\nstruct Scsi_Host *host = us_to_host(us);\r\nscsi_lock(host);\r\nscsi_report_bus_reset(host, 0);\r\nscsi_unlock(host);\r\n}\r\nstatic int write_info(struct Scsi_Host *host, char *buffer, int length)\r\n{\r\nreturn length;\r\n}\r\nstatic int show_info (struct seq_file *m, struct Scsi_Host *host)\r\n{\r\nstruct us_data *us = host_to_us(host);\r\nconst char *string;\r\nSPRINTF(" Host scsi%d: usb-storage\n", host->host_no);\r\nif (us->pusb_dev->manufacturer)\r\nstring = us->pusb_dev->manufacturer;\r\nelse if (us->unusual_dev->vendorName)\r\nstring = us->unusual_dev->vendorName;\r\nelse\r\nstring = "Unknown";\r\nSPRINTF(" Vendor: %s\n", string);\r\nif (us->pusb_dev->product)\r\nstring = us->pusb_dev->product;\r\nelse if (us->unusual_dev->productName)\r\nstring = us->unusual_dev->productName;\r\nelse\r\nstring = "Unknown";\r\nSPRINTF(" Product: %s\n", string);\r\nif (us->pusb_dev->serial)\r\nstring = us->pusb_dev->serial;\r\nelse\r\nstring = "None";\r\nSPRINTF("Serial Number: %s\n", string);\r\nSPRINTF(" Protocol: %s\n", us->protocol_name);\r\nSPRINTF(" Transport: %s\n", us->transport_name);\r\nSPRINTF(" Quirks:");\r\n#define US_FLAG(name, value) \\r\nif (us->fflags & value) seq_printf(m, " " #name);\r\nUS_DO_ALL_FLAGS\r\n#undef US_FLAG\r\nseq_putc(m, '\n');\r\nreturn 0;\r\n}\r\nstatic ssize_t max_sectors_show(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct scsi_device *sdev = to_scsi_device(dev);\r\nreturn sprintf(buf, "%u\n", queue_max_hw_sectors(sdev->request_queue));\r\n}\r\nstatic ssize_t max_sectors_store(struct device *dev, struct device_attribute *attr, const char *buf,\r\nsize_t count)\r\n{\r\nstruct scsi_device *sdev = to_scsi_device(dev);\r\nunsigned short ms;\r\nif (sscanf(buf, "%hu", &ms) > 0) {\r\nblk_queue_max_hw_sectors(sdev->request_queue, ms);\r\nreturn count;\r\n}\r\nreturn -EINVAL;\r\n}
