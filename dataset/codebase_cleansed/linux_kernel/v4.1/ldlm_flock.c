static inline int\r\nldlm_same_flock_owner(struct ldlm_lock *lock, struct ldlm_lock *new)\r\n{\r\nreturn((new->l_policy_data.l_flock.owner ==\r\nlock->l_policy_data.l_flock.owner) &&\r\n(new->l_export == lock->l_export));\r\n}\r\nstatic inline int\r\nldlm_flocks_overlap(struct ldlm_lock *lock, struct ldlm_lock *new)\r\n{\r\nreturn((new->l_policy_data.l_flock.start <=\r\nlock->l_policy_data.l_flock.end) &&\r\n(new->l_policy_data.l_flock.end >=\r\nlock->l_policy_data.l_flock.start));\r\n}\r\nstatic inline void ldlm_flock_blocking_link(struct ldlm_lock *req,\r\nstruct ldlm_lock *lock)\r\n{\r\nif (req->l_export == NULL)\r\nreturn;\r\nLASSERT(hlist_unhashed(&req->l_exp_flock_hash));\r\nreq->l_policy_data.l_flock.blocking_owner =\r\nlock->l_policy_data.l_flock.owner;\r\nreq->l_policy_data.l_flock.blocking_export =\r\nlock->l_export;\r\nreq->l_policy_data.l_flock.blocking_refs = 0;\r\ncfs_hash_add(req->l_export->exp_flock_hash,\r\n&req->l_policy_data.l_flock.owner,\r\n&req->l_exp_flock_hash);\r\n}\r\nstatic inline void ldlm_flock_blocking_unlink(struct ldlm_lock *req)\r\n{\r\nif (req->l_export == NULL)\r\nreturn;\r\ncheck_res_locked(req->l_resource);\r\nif (req->l_export->exp_flock_hash != NULL &&\r\n!hlist_unhashed(&req->l_exp_flock_hash))\r\ncfs_hash_del(req->l_export->exp_flock_hash,\r\n&req->l_policy_data.l_flock.owner,\r\n&req->l_exp_flock_hash);\r\n}\r\nstatic inline void\r\nldlm_flock_destroy(struct ldlm_lock *lock, ldlm_mode_t mode, __u64 flags)\r\n{\r\nLDLM_DEBUG(lock, "ldlm_flock_destroy(mode: %d, flags: 0x%llx)",\r\nmode, flags);\r\nLASSERT(hlist_unhashed(&lock->l_exp_flock_hash));\r\nlist_del_init(&lock->l_res_link);\r\nif (flags == LDLM_FL_WAIT_NOREPROC &&\r\n!(lock->l_flags & LDLM_FL_FAILED)) {\r\nlock->l_flags |= LDLM_FL_LOCAL_ONLY | LDLM_FL_CBPENDING;\r\nldlm_lock_decref_internal_nolock(lock, mode);\r\n}\r\nldlm_lock_destroy_nolock(lock);\r\n}\r\nstatic int\r\nldlm_flock_deadlock(struct ldlm_lock *req, struct ldlm_lock *bl_lock)\r\n{\r\nstruct obd_export *req_exp = req->l_export;\r\nstruct obd_export *bl_exp = bl_lock->l_export;\r\n__u64 req_owner = req->l_policy_data.l_flock.owner;\r\n__u64 bl_owner = bl_lock->l_policy_data.l_flock.owner;\r\nif (req_exp == NULL)\r\nreturn 0;\r\nclass_export_get(bl_exp);\r\nwhile (1) {\r\nstruct obd_export *bl_exp_new;\r\nstruct ldlm_lock *lock = NULL;\r\nstruct ldlm_flock *flock;\r\nif (bl_exp->exp_flock_hash != NULL)\r\nlock = cfs_hash_lookup(bl_exp->exp_flock_hash,\r\n&bl_owner);\r\nif (lock == NULL)\r\nbreak;\r\nLASSERT(req != lock);\r\nflock = &lock->l_policy_data.l_flock;\r\nLASSERT(flock->owner == bl_owner);\r\nbl_owner = flock->blocking_owner;\r\nbl_exp_new = class_export_get(flock->blocking_export);\r\nclass_export_put(bl_exp);\r\ncfs_hash_put(bl_exp->exp_flock_hash, &lock->l_exp_flock_hash);\r\nbl_exp = bl_exp_new;\r\nif (bl_owner == req_owner && bl_exp == req_exp) {\r\nclass_export_put(bl_exp);\r\nreturn 1;\r\n}\r\n}\r\nclass_export_put(bl_exp);\r\nreturn 0;\r\n}\r\nstatic void ldlm_flock_cancel_on_deadlock(struct ldlm_lock *lock,\r\nstruct list_head *work_list)\r\n{\r\nCDEBUG(D_INFO, "reprocess deadlock req=%p\n", lock);\r\nif ((exp_connect_flags(lock->l_export) &\r\nOBD_CONNECT_FLOCK_DEAD) == 0) {\r\nCERROR(\r\n"deadlock found, but client doesn't support flock canceliation\n");\r\n} else {\r\nLASSERT(lock->l_completion_ast);\r\nLASSERT((lock->l_flags & LDLM_FL_AST_SENT) == 0);\r\nlock->l_flags |= LDLM_FL_AST_SENT | LDLM_FL_CANCEL_ON_BLOCK |\r\nLDLM_FL_FLOCK_DEADLOCK;\r\nldlm_flock_blocking_unlink(lock);\r\nldlm_resource_unlink_lock(lock);\r\nldlm_add_ast_work_item(lock, NULL, work_list);\r\n}\r\n}\r\nint\r\nldlm_process_flock_lock(struct ldlm_lock *req, __u64 *flags, int first_enq,\r\nldlm_error_t *err, struct list_head *work_list)\r\n{\r\nstruct ldlm_resource *res = req->l_resource;\r\nstruct ldlm_namespace *ns = ldlm_res_to_ns(res);\r\nstruct list_head *tmp;\r\nstruct list_head *ownlocks = NULL;\r\nstruct ldlm_lock *lock = NULL;\r\nstruct ldlm_lock *new = req;\r\nstruct ldlm_lock *new2 = NULL;\r\nldlm_mode_t mode = req->l_req_mode;\r\nint local = ns_is_client(ns);\r\nint added = (mode == LCK_NL);\r\nint overlaps = 0;\r\nint splitted = 0;\r\nconst struct ldlm_callback_suite null_cbs = { NULL };\r\nCDEBUG(D_DLMTRACE,\r\n"flags %#llx owner %llu pid %u mode %u start %llu end %llu\n",\r\n*flags, new->l_policy_data.l_flock.owner,\r\nnew->l_policy_data.l_flock.pid, mode,\r\nreq->l_policy_data.l_flock.start,\r\nreq->l_policy_data.l_flock.end);\r\n*err = ELDLM_OK;\r\nif (local) {\r\nreq->l_blocking_ast = NULL;\r\n} else {\r\nreq->l_blocking_ast = ldlm_flock_blocking_ast;\r\n}\r\nreprocess:\r\nif ((*flags == LDLM_FL_WAIT_NOREPROC) || (mode == LCK_NL)) {\r\nlist_for_each(tmp, &res->lr_granted) {\r\nlock = list_entry(tmp, struct ldlm_lock,\r\nl_res_link);\r\nif (ldlm_same_flock_owner(lock, req)) {\r\nownlocks = tmp;\r\nbreak;\r\n}\r\n}\r\n} else {\r\nint reprocess_failed = 0;\r\nlockmode_verify(mode);\r\nlist_for_each(tmp, &res->lr_granted) {\r\nlock = list_entry(tmp, struct ldlm_lock,\r\nl_res_link);\r\nif (ldlm_same_flock_owner(lock, req)) {\r\nif (!ownlocks)\r\nownlocks = tmp;\r\ncontinue;\r\n}\r\nif (lockmode_compat(lock->l_granted_mode, mode))\r\ncontinue;\r\nif (!ldlm_flocks_overlap(lock, req))\r\ncontinue;\r\nif (!first_enq) {\r\nreprocess_failed = 1;\r\nif (ldlm_flock_deadlock(req, lock)) {\r\nldlm_flock_cancel_on_deadlock(req,\r\nwork_list);\r\nreturn LDLM_ITER_CONTINUE;\r\n}\r\ncontinue;\r\n}\r\nif (*flags & LDLM_FL_BLOCK_NOWAIT) {\r\nldlm_flock_destroy(req, mode, *flags);\r\n*err = -EAGAIN;\r\nreturn LDLM_ITER_STOP;\r\n}\r\nif (*flags & LDLM_FL_TEST_LOCK) {\r\nldlm_flock_destroy(req, mode, *flags);\r\nreq->l_req_mode = lock->l_granted_mode;\r\nreq->l_policy_data.l_flock.pid =\r\nlock->l_policy_data.l_flock.pid;\r\nreq->l_policy_data.l_flock.start =\r\nlock->l_policy_data.l_flock.start;\r\nreq->l_policy_data.l_flock.end =\r\nlock->l_policy_data.l_flock.end;\r\n*flags |= LDLM_FL_LOCK_CHANGED;\r\nreturn LDLM_ITER_STOP;\r\n}\r\nldlm_flock_blocking_link(req, lock);\r\nif (ldlm_flock_deadlock(req, lock)) {\r\nldlm_flock_blocking_unlink(req);\r\nldlm_flock_destroy(req, mode, *flags);\r\n*err = -EDEADLK;\r\nreturn LDLM_ITER_STOP;\r\n}\r\nldlm_resource_add_lock(res, &res->lr_waiting, req);\r\n*flags |= LDLM_FL_BLOCK_GRANTED;\r\nreturn LDLM_ITER_STOP;\r\n}\r\nif (reprocess_failed)\r\nreturn LDLM_ITER_CONTINUE;\r\n}\r\nif (*flags & LDLM_FL_TEST_LOCK) {\r\nldlm_flock_destroy(req, mode, *flags);\r\nreq->l_req_mode = LCK_NL;\r\n*flags |= LDLM_FL_LOCK_CHANGED;\r\nreturn LDLM_ITER_STOP;\r\n}\r\nldlm_flock_blocking_unlink(req);\r\nif (!ownlocks)\r\nownlocks = &res->lr_granted;\r\nlist_for_remaining_safe(ownlocks, tmp, &res->lr_granted) {\r\nlock = list_entry(ownlocks, struct ldlm_lock, l_res_link);\r\nif (!ldlm_same_flock_owner(lock, new))\r\nbreak;\r\nif (lock->l_granted_mode == mode) {\r\nif ((new->l_policy_data.l_flock.start >\r\n(lock->l_policy_data.l_flock.end + 1))\r\n&& (lock->l_policy_data.l_flock.end !=\r\nOBD_OBJECT_EOF))\r\ncontinue;\r\nif ((new->l_policy_data.l_flock.end <\r\n(lock->l_policy_data.l_flock.start - 1))\r\n&& (lock->l_policy_data.l_flock.start != 0))\r\nbreak;\r\nif (new->l_policy_data.l_flock.start <\r\nlock->l_policy_data.l_flock.start) {\r\nlock->l_policy_data.l_flock.start =\r\nnew->l_policy_data.l_flock.start;\r\n} else {\r\nnew->l_policy_data.l_flock.start =\r\nlock->l_policy_data.l_flock.start;\r\n}\r\nif (new->l_policy_data.l_flock.end >\r\nlock->l_policy_data.l_flock.end) {\r\nlock->l_policy_data.l_flock.end =\r\nnew->l_policy_data.l_flock.end;\r\n} else {\r\nnew->l_policy_data.l_flock.end =\r\nlock->l_policy_data.l_flock.end;\r\n}\r\nif (added) {\r\nldlm_flock_destroy(lock, mode, *flags);\r\n} else {\r\nnew = lock;\r\nadded = 1;\r\n}\r\ncontinue;\r\n}\r\nif (new->l_policy_data.l_flock.start >\r\nlock->l_policy_data.l_flock.end)\r\ncontinue;\r\nif (new->l_policy_data.l_flock.end <\r\nlock->l_policy_data.l_flock.start)\r\nbreak;\r\n++overlaps;\r\nif (new->l_policy_data.l_flock.start <=\r\nlock->l_policy_data.l_flock.start) {\r\nif (new->l_policy_data.l_flock.end <\r\nlock->l_policy_data.l_flock.end) {\r\nlock->l_policy_data.l_flock.start =\r\nnew->l_policy_data.l_flock.end + 1;\r\nbreak;\r\n}\r\nldlm_flock_destroy(lock, lock->l_req_mode, *flags);\r\ncontinue;\r\n}\r\nif (new->l_policy_data.l_flock.end >=\r\nlock->l_policy_data.l_flock.end) {\r\nlock->l_policy_data.l_flock.end =\r\nnew->l_policy_data.l_flock.start - 1;\r\ncontinue;\r\n}\r\nif (!new2) {\r\nunlock_res_and_lock(req);\r\nnew2 = ldlm_lock_create(ns, &res->lr_name, LDLM_FLOCK,\r\nlock->l_granted_mode, &null_cbs,\r\nNULL, 0, LVB_T_NONE);\r\nlock_res_and_lock(req);\r\nif (!new2) {\r\nldlm_flock_destroy(req, lock->l_granted_mode,\r\n*flags);\r\n*err = -ENOLCK;\r\nreturn LDLM_ITER_STOP;\r\n}\r\ngoto reprocess;\r\n}\r\nsplitted = 1;\r\nnew2->l_granted_mode = lock->l_granted_mode;\r\nnew2->l_policy_data.l_flock.pid =\r\nnew->l_policy_data.l_flock.pid;\r\nnew2->l_policy_data.l_flock.owner =\r\nnew->l_policy_data.l_flock.owner;\r\nnew2->l_policy_data.l_flock.start =\r\nlock->l_policy_data.l_flock.start;\r\nnew2->l_policy_data.l_flock.end =\r\nnew->l_policy_data.l_flock.start - 1;\r\nlock->l_policy_data.l_flock.start =\r\nnew->l_policy_data.l_flock.end + 1;\r\nnew2->l_conn_export = lock->l_conn_export;\r\nif (lock->l_export != NULL) {\r\nnew2->l_export = class_export_lock_get(lock->l_export,\r\nnew2);\r\nif (new2->l_export->exp_lock_hash &&\r\nhlist_unhashed(&new2->l_exp_hash))\r\ncfs_hash_add(new2->l_export->exp_lock_hash,\r\n&new2->l_remote_handle,\r\n&new2->l_exp_hash);\r\n}\r\nif (*flags == LDLM_FL_WAIT_NOREPROC)\r\nldlm_lock_addref_internal_nolock(new2,\r\nlock->l_granted_mode);\r\nldlm_resource_add_lock(res, ownlocks, new2);\r\nLDLM_LOCK_RELEASE(new2);\r\nbreak;\r\n}\r\nif (splitted == 0 && new2 != NULL)\r\nldlm_lock_destroy_nolock(new2);\r\nreq->l_granted_mode = req->l_req_mode;\r\nif (!added) {\r\nlist_del_init(&req->l_res_link);\r\nldlm_resource_add_lock(res, ownlocks, req);\r\n}\r\nif (*flags != LDLM_FL_WAIT_NOREPROC) {\r\nCERROR("Illegal parameter for client-side-only module.\n");\r\nLBUG();\r\n}\r\nif (added)\r\nldlm_flock_destroy(req, mode, *flags);\r\nldlm_resource_dump(D_INFO, res);\r\nreturn LDLM_ITER_CONTINUE;\r\n}\r\nstatic void\r\nldlm_flock_interrupted_wait(void *data)\r\n{\r\nstruct ldlm_lock *lock;\r\nlock = ((struct ldlm_flock_wait_data *)data)->fwd_lock;\r\nlock_res_and_lock(lock);\r\nldlm_flock_blocking_unlink(lock);\r\nlock->l_flags |= LDLM_FL_CBPENDING;\r\nunlock_res_and_lock(lock);\r\n}\r\nint\r\nldlm_flock_completion_ast(struct ldlm_lock *lock, __u64 flags, void *data)\r\n{\r\nstruct file_lock *getlk = lock->l_ast_data;\r\nstruct obd_device *obd;\r\nstruct obd_import *imp = NULL;\r\nstruct ldlm_flock_wait_data fwd;\r\nstruct l_wait_info lwi;\r\nldlm_error_t err;\r\nint rc = 0;\r\nCDEBUG(D_DLMTRACE, "flags: 0x%llx data: %p getlk: %p\n",\r\nflags, data, getlk);\r\nif ((lock->l_flags & (LDLM_FL_FAILED|LDLM_FL_LOCAL_ONLY)) ==\r\n(LDLM_FL_FAILED|LDLM_FL_LOCAL_ONLY)) {\r\nif (lock->l_req_mode == lock->l_granted_mode &&\r\nlock->l_granted_mode != LCK_NL &&\r\nNULL == data)\r\nldlm_lock_decref_internal(lock, lock->l_req_mode);\r\nwake_up(&lock->l_waitq);\r\nreturn 0;\r\n}\r\nLASSERT(flags != LDLM_FL_WAIT_NOREPROC);\r\nif (!(flags & (LDLM_FL_BLOCK_WAIT | LDLM_FL_BLOCK_GRANTED |\r\nLDLM_FL_BLOCK_CONV))) {\r\nif (NULL == data)\r\ngoto granted;\r\nwake_up(&lock->l_waitq);\r\nreturn 0;\r\n}\r\nLDLM_DEBUG(lock, "client-side enqueue returned a blocked lock, sleeping");\r\nfwd.fwd_lock = lock;\r\nobd = class_exp2obd(lock->l_conn_export);\r\nif (NULL != obd)\r\nimp = obd->u.cli.cl_import;\r\nif (NULL != imp) {\r\nspin_lock(&imp->imp_lock);\r\nfwd.fwd_generation = imp->imp_generation;\r\nspin_unlock(&imp->imp_lock);\r\n}\r\nlwi = LWI_TIMEOUT_INTR(0, NULL, ldlm_flock_interrupted_wait, &fwd);\r\nrc = l_wait_event(lock->l_waitq, is_granted_or_cancelled(lock), &lwi);\r\nif (rc) {\r\nLDLM_DEBUG(lock, "client-side enqueue waking up: failed (%d)",\r\nrc);\r\nreturn rc;\r\n}\r\ngranted:\r\nOBD_FAIL_TIMEOUT(OBD_FAIL_LDLM_CP_CB_WAIT, 10);\r\nif (lock->l_flags & LDLM_FL_DESTROYED) {\r\nLDLM_DEBUG(lock, "client-side enqueue waking up: destroyed");\r\nreturn 0;\r\n}\r\nif (lock->l_flags & LDLM_FL_FAILED) {\r\nLDLM_DEBUG(lock, "client-side enqueue waking up: failed");\r\nreturn -EIO;\r\n}\r\nif (rc) {\r\nLDLM_DEBUG(lock, "client-side enqueue waking up: failed (%d)",\r\nrc);\r\nreturn rc;\r\n}\r\nLDLM_DEBUG(lock, "client-side enqueue granted");\r\nlock_res_and_lock(lock);\r\nldlm_flock_blocking_unlink(lock);\r\nlist_del_init(&lock->l_res_link);\r\nif (lock->l_flags & LDLM_FL_FLOCK_DEADLOCK) {\r\nLDLM_DEBUG(lock, "client-side enqueue deadlock received");\r\nrc = -EDEADLK;\r\n} else if (flags & LDLM_FL_TEST_LOCK) {\r\nldlm_flock_destroy(lock, getlk->fl_type, LDLM_FL_WAIT_NOREPROC);\r\nswitch (lock->l_granted_mode) {\r\ncase LCK_PR:\r\ngetlk->fl_type = F_RDLCK;\r\nbreak;\r\ncase LCK_PW:\r\ngetlk->fl_type = F_WRLCK;\r\nbreak;\r\ndefault:\r\ngetlk->fl_type = F_UNLCK;\r\n}\r\ngetlk->fl_pid = (pid_t)lock->l_policy_data.l_flock.pid;\r\ngetlk->fl_start = (loff_t)lock->l_policy_data.l_flock.start;\r\ngetlk->fl_end = (loff_t)lock->l_policy_data.l_flock.end;\r\n} else {\r\n__u64 noreproc = LDLM_FL_WAIT_NOREPROC;\r\nldlm_process_flock_lock(lock, &noreproc, 1, &err, NULL);\r\n}\r\nunlock_res_and_lock(lock);\r\nreturn rc;\r\n}\r\nint ldlm_flock_blocking_ast(struct ldlm_lock *lock, struct ldlm_lock_desc *desc,\r\nvoid *data, int flag)\r\n{\r\nLASSERT(lock);\r\nLASSERT(flag == LDLM_CB_CANCELING);\r\nlock_res_and_lock(lock);\r\nldlm_flock_blocking_unlink(lock);\r\nunlock_res_and_lock(lock);\r\nreturn 0;\r\n}\r\nvoid ldlm_flock_policy_wire18_to_local(const ldlm_wire_policy_data_t *wpolicy,\r\nldlm_policy_data_t *lpolicy)\r\n{\r\nmemset(lpolicy, 0, sizeof(*lpolicy));\r\nlpolicy->l_flock.start = wpolicy->l_flock.lfw_start;\r\nlpolicy->l_flock.end = wpolicy->l_flock.lfw_end;\r\nlpolicy->l_flock.pid = wpolicy->l_flock.lfw_pid;\r\nlpolicy->l_flock.owner = wpolicy->l_flock.lfw_pid;\r\n}\r\nvoid ldlm_flock_policy_wire21_to_local(const ldlm_wire_policy_data_t *wpolicy,\r\nldlm_policy_data_t *lpolicy)\r\n{\r\nmemset(lpolicy, 0, sizeof(*lpolicy));\r\nlpolicy->l_flock.start = wpolicy->l_flock.lfw_start;\r\nlpolicy->l_flock.end = wpolicy->l_flock.lfw_end;\r\nlpolicy->l_flock.pid = wpolicy->l_flock.lfw_pid;\r\nlpolicy->l_flock.owner = wpolicy->l_flock.lfw_owner;\r\n}\r\nvoid ldlm_flock_policy_local_to_wire(const ldlm_policy_data_t *lpolicy,\r\nldlm_wire_policy_data_t *wpolicy)\r\n{\r\nmemset(wpolicy, 0, sizeof(*wpolicy));\r\nwpolicy->l_flock.lfw_start = lpolicy->l_flock.start;\r\nwpolicy->l_flock.lfw_end = lpolicy->l_flock.end;\r\nwpolicy->l_flock.lfw_pid = lpolicy->l_flock.pid;\r\nwpolicy->l_flock.lfw_owner = lpolicy->l_flock.owner;\r\n}\r\nstatic unsigned\r\nldlm_export_flock_hash(struct cfs_hash *hs, const void *key, unsigned mask)\r\n{\r\nreturn cfs_hash_u64_hash(*(__u64 *)key, mask);\r\n}\r\nstatic void *\r\nldlm_export_flock_key(struct hlist_node *hnode)\r\n{\r\nstruct ldlm_lock *lock;\r\nlock = hlist_entry(hnode, struct ldlm_lock, l_exp_flock_hash);\r\nreturn &lock->l_policy_data.l_flock.owner;\r\n}\r\nstatic int\r\nldlm_export_flock_keycmp(const void *key, struct hlist_node *hnode)\r\n{\r\nreturn !memcmp(ldlm_export_flock_key(hnode), key, sizeof(__u64));\r\n}\r\nstatic void *\r\nldlm_export_flock_object(struct hlist_node *hnode)\r\n{\r\nreturn hlist_entry(hnode, struct ldlm_lock, l_exp_flock_hash);\r\n}\r\nstatic void\r\nldlm_export_flock_get(struct cfs_hash *hs, struct hlist_node *hnode)\r\n{\r\nstruct ldlm_lock *lock;\r\nstruct ldlm_flock *flock;\r\nlock = hlist_entry(hnode, struct ldlm_lock, l_exp_flock_hash);\r\nLDLM_LOCK_GET(lock);\r\nflock = &lock->l_policy_data.l_flock;\r\nLASSERT(flock->blocking_export != NULL);\r\nclass_export_get(flock->blocking_export);\r\nflock->blocking_refs++;\r\n}\r\nstatic void\r\nldlm_export_flock_put(struct cfs_hash *hs, struct hlist_node *hnode)\r\n{\r\nstruct ldlm_lock *lock;\r\nstruct ldlm_flock *flock;\r\nlock = hlist_entry(hnode, struct ldlm_lock, l_exp_flock_hash);\r\nLDLM_LOCK_RELEASE(lock);\r\nflock = &lock->l_policy_data.l_flock;\r\nLASSERT(flock->blocking_export != NULL);\r\nclass_export_put(flock->blocking_export);\r\nif (--flock->blocking_refs == 0) {\r\nflock->blocking_owner = 0;\r\nflock->blocking_export = NULL;\r\n}\r\n}\r\nint ldlm_init_flock_export(struct obd_export *exp)\r\n{\r\nif (strcmp(exp->exp_obd->obd_type->typ_name, LUSTRE_MDT_NAME) != 0)\r\nreturn 0;\r\nexp->exp_flock_hash =\r\ncfs_hash_create(obd_uuid2str(&exp->exp_client_uuid),\r\nHASH_EXP_LOCK_CUR_BITS,\r\nHASH_EXP_LOCK_MAX_BITS,\r\nHASH_EXP_LOCK_BKT_BITS, 0,\r\nCFS_HASH_MIN_THETA, CFS_HASH_MAX_THETA,\r\n&ldlm_export_flock_ops,\r\nCFS_HASH_DEFAULT | CFS_HASH_NBLK_CHANGE);\r\nif (!exp->exp_flock_hash)\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nvoid ldlm_destroy_flock_export(struct obd_export *exp)\r\n{\r\nif (exp->exp_flock_hash) {\r\ncfs_hash_putref(exp->exp_flock_hash);\r\nexp->exp_flock_hash = NULL;\r\n}\r\n}
