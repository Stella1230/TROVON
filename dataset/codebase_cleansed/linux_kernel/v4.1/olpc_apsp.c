static int olpc_apsp_write(struct serio *port, unsigned char val)\r\n{\r\nstruct olpc_apsp *priv = port->port_data;\r\nunsigned int i;\r\nu32 which = 0;\r\nif (port == priv->padio)\r\nwhich = TOUCHPAD_PORT << PORT_SHIFT;\r\nelse\r\nwhich = KEYBOARD_PORT << PORT_SHIFT;\r\ndev_dbg(priv->dev, "olpc_apsp_write which=%x val=%x\n", which, val);\r\nfor (i = 0; i < 50; i++) {\r\nu32 sts = readl(priv->base + COMMAND_FIFO_STATUS);\r\nif ((sts & CMD_CNTR_MASK) < MAX_PENDING_CMDS) {\r\nwritel(which | val,\r\npriv->base + SECURE_PROCESSOR_COMMAND);\r\nreturn 0;\r\n}\r\nmdelay(1);\r\n}\r\ndev_dbg(priv->dev, "olpc_apsp_write timeout, status=%x\n",\r\nreadl(priv->base + COMMAND_FIFO_STATUS));\r\nreturn -ETIMEDOUT;\r\n}\r\nstatic irqreturn_t olpc_apsp_rx(int irq, void *dev_id)\r\n{\r\nstruct olpc_apsp *priv = dev_id;\r\nunsigned int w, tmp;\r\nstruct serio *serio;\r\ntmp = readl(priv->base + PJ_RST_INTERRUPT);\r\nif (!(tmp & SP_COMMAND_COMPLETE_RESET)) {\r\ndev_warn(priv->dev, "spurious interrupt?\n");\r\nreturn IRQ_NONE;\r\n}\r\nw = readl(priv->base + COMMAND_RETURN_STATUS);\r\ndev_dbg(priv->dev, "olpc_apsp_rx %x\n", w);\r\nif (w >> PORT_SHIFT == KEYBOARD_PORT)\r\nserio = priv->kbio;\r\nelse\r\nserio = priv->padio;\r\nserio_interrupt(serio, w & DATA_MASK, 0);\r\nwritel(tmp | SP_COMMAND_COMPLETE_RESET, priv->base + PJ_RST_INTERRUPT);\r\nwritel(PORT_MASK, priv->base + SECURE_PROCESSOR_COMMAND);\r\npm_wakeup_event(priv->dev, 1000);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int olpc_apsp_open(struct serio *port)\r\n{\r\nstruct olpc_apsp *priv = port->port_data;\r\nunsigned int tmp;\r\nif (priv->open_count++ == 0) {\r\ntmp = readl(priv->base + PJ_INTERRUPT_MASK);\r\nwritel(tmp & ~INT_0, priv->base + PJ_INTERRUPT_MASK);\r\n}\r\nreturn 0;\r\n}\r\nstatic void olpc_apsp_close(struct serio *port)\r\n{\r\nstruct olpc_apsp *priv = port->port_data;\r\nunsigned int tmp;\r\nif (--priv->open_count == 0) {\r\ntmp = readl(priv->base + PJ_INTERRUPT_MASK);\r\nwritel(tmp | INT_0, priv->base + PJ_INTERRUPT_MASK);\r\n}\r\n}\r\nstatic int olpc_apsp_probe(struct platform_device *pdev)\r\n{\r\nstruct serio *kb_serio, *pad_serio;\r\nstruct olpc_apsp *priv;\r\nstruct resource *res;\r\nstruct device_node *np;\r\nunsigned long l;\r\nint error;\r\npriv = devm_kzalloc(&pdev->dev, sizeof(struct olpc_apsp), GFP_KERNEL);\r\nif (!priv)\r\nreturn -ENOMEM;\r\nnp = pdev->dev.of_node;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\npriv->base = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(priv->base)) {\r\ndev_err(&pdev->dev, "Failed to map WTM registers\n");\r\nreturn PTR_ERR(priv->base);\r\n}\r\npriv->irq = platform_get_irq(pdev, 0);\r\nif (priv->irq < 0)\r\nreturn priv->irq;\r\nl = readl(priv->base + COMMAND_FIFO_STATUS);\r\nif (!(l & CMD_STS_MASK)) {\r\ndev_err(&pdev->dev, "SP cannot accept commands.\n");\r\nreturn -EIO;\r\n}\r\nkb_serio = kzalloc(sizeof(struct serio), GFP_KERNEL);\r\nif (!kb_serio)\r\nreturn -ENOMEM;\r\nkb_serio->id.type = SERIO_8042_XL;\r\nkb_serio->write = olpc_apsp_write;\r\nkb_serio->open = olpc_apsp_open;\r\nkb_serio->close = olpc_apsp_close;\r\nkb_serio->port_data = priv;\r\nkb_serio->dev.parent = &pdev->dev;\r\nstrlcpy(kb_serio->name, "sp keyboard", sizeof(kb_serio->name));\r\nstrlcpy(kb_serio->phys, "sp/serio0", sizeof(kb_serio->phys));\r\npriv->kbio = kb_serio;\r\nserio_register_port(kb_serio);\r\npad_serio = kzalloc(sizeof(struct serio), GFP_KERNEL);\r\nif (!pad_serio) {\r\nerror = -ENOMEM;\r\ngoto err_pad;\r\n}\r\npad_serio->id.type = SERIO_8042;\r\npad_serio->write = olpc_apsp_write;\r\npad_serio->open = olpc_apsp_open;\r\npad_serio->close = olpc_apsp_close;\r\npad_serio->port_data = priv;\r\npad_serio->dev.parent = &pdev->dev;\r\nstrlcpy(pad_serio->name, "sp touchpad", sizeof(pad_serio->name));\r\nstrlcpy(pad_serio->phys, "sp/serio1", sizeof(pad_serio->phys));\r\npriv->padio = pad_serio;\r\nserio_register_port(pad_serio);\r\nerror = request_irq(priv->irq, olpc_apsp_rx, 0, "olpc-apsp", priv);\r\nif (error) {\r\ndev_err(&pdev->dev, "Failed to request IRQ\n");\r\ngoto err_irq;\r\n}\r\npriv->dev = &pdev->dev;\r\ndevice_init_wakeup(priv->dev, 1);\r\nplatform_set_drvdata(pdev, priv);\r\ndev_dbg(&pdev->dev, "probed successfully.\n");\r\nreturn 0;\r\nerr_irq:\r\nserio_unregister_port(pad_serio);\r\nerr_pad:\r\nserio_unregister_port(kb_serio);\r\nreturn error;\r\n}\r\nstatic int olpc_apsp_remove(struct platform_device *pdev)\r\n{\r\nstruct olpc_apsp *priv = platform_get_drvdata(pdev);\r\nfree_irq(priv->irq, priv);\r\nserio_unregister_port(priv->kbio);\r\nserio_unregister_port(priv->padio);\r\nreturn 0;\r\n}
