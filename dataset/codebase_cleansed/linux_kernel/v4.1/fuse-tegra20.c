static void apb_dma_complete(void *args)\r\n{\r\ncomplete(&apb_dma_wait);\r\n}\r\nstatic u32 tegra20_fuse_readl(const unsigned int offset)\r\n{\r\nint ret;\r\nu32 val = 0;\r\nstruct dma_async_tx_descriptor *dma_desc;\r\nmutex_lock(&apb_dma_lock);\r\ndma_sconfig.src_addr = fuse_phys + FUSE_BEGIN + offset;\r\nret = dmaengine_slave_config(apb_dma_chan, &dma_sconfig);\r\nif (ret)\r\ngoto out;\r\ndma_desc = dmaengine_prep_slave_single(apb_dma_chan, apb_buffer_phys,\r\nsizeof(u32), DMA_DEV_TO_MEM,\r\nDMA_PREP_INTERRUPT | DMA_CTRL_ACK);\r\nif (!dma_desc)\r\ngoto out;\r\ndma_desc->callback = apb_dma_complete;\r\ndma_desc->callback_param = NULL;\r\nreinit_completion(&apb_dma_wait);\r\nclk_prepare_enable(fuse_clk);\r\ndmaengine_submit(dma_desc);\r\ndma_async_issue_pending(apb_dma_chan);\r\nret = wait_for_completion_timeout(&apb_dma_wait, msecs_to_jiffies(50));\r\nif (WARN(ret == 0, "apb read dma timed out"))\r\ndmaengine_terminate_all(apb_dma_chan);\r\nelse\r\nval = *apb_buffer;\r\nclk_disable_unprepare(fuse_clk);\r\nout:\r\nmutex_unlock(&apb_dma_lock);\r\nreturn val;\r\n}\r\nstatic int apb_dma_init(void)\r\n{\r\ndma_cap_mask_t mask;\r\ndma_cap_zero(mask);\r\ndma_cap_set(DMA_SLAVE, mask);\r\napb_dma_chan = dma_request_channel(mask, NULL, NULL);\r\nif (!apb_dma_chan)\r\nreturn -EPROBE_DEFER;\r\napb_buffer = dma_alloc_coherent(NULL, sizeof(u32), &apb_buffer_phys,\r\nGFP_KERNEL);\r\nif (!apb_buffer) {\r\ndma_release_channel(apb_dma_chan);\r\nreturn -ENOMEM;\r\n}\r\ndma_sconfig.src_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;\r\ndma_sconfig.dst_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;\r\ndma_sconfig.src_maxburst = 1;\r\ndma_sconfig.dst_maxburst = 1;\r\nreturn 0;\r\n}\r\nstatic int tegra20_fuse_probe(struct platform_device *pdev)\r\n{\r\nstruct resource *res;\r\nint err;\r\nfuse_clk = devm_clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(fuse_clk)) {\r\ndev_err(&pdev->dev, "missing clock");\r\nreturn PTR_ERR(fuse_clk);\r\n}\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!res)\r\nreturn -EINVAL;\r\nfuse_phys = res->start;\r\nerr = apb_dma_init();\r\nif (err)\r\nreturn err;\r\nif (tegra_fuse_create_sysfs(&pdev->dev, FUSE_SIZE, tegra20_fuse_readl))\r\nreturn -ENODEV;\r\ndev_dbg(&pdev->dev, "loaded\n");\r\nreturn 0;\r\n}\r\nstatic int __init tegra20_fuse_init(void)\r\n{\r\nreturn platform_driver_register(&tegra20_fuse_driver);\r\n}\r\nu32 __init tegra20_fuse_early(const unsigned int offset)\r\n{\r\nreturn readl_relaxed(fuse_base + FUSE_BEGIN + offset);\r\n}\r\nbool __init tegra20_spare_fuse_early(int spare_bit)\r\n{\r\nu32 offset = spare_bit * 4;\r\nbool value;\r\nvalue = tegra20_fuse_early(offset + 0x100);\r\nreturn value;\r\n}\r\nstatic void __init tegra20_fuse_add_randomness(void)\r\n{\r\nu32 randomness[7];\r\nrandomness[0] = tegra_sku_info.sku_id;\r\nrandomness[1] = tegra_read_straps();\r\nrandomness[2] = tegra_read_chipid();\r\nrandomness[3] = tegra_sku_info.cpu_process_id << 16;\r\nrandomness[3] |= tegra_sku_info.core_process_id;\r\nrandomness[4] = tegra_sku_info.cpu_speedo_id << 16;\r\nrandomness[4] |= tegra_sku_info.soc_speedo_id;\r\nrandomness[5] = tegra20_fuse_early(FUSE_UID_LOW);\r\nrandomness[6] = tegra20_fuse_early(FUSE_UID_HIGH);\r\nadd_device_randomness(randomness, sizeof(randomness));\r\n}\r\nvoid __init tegra20_init_fuse_early(void)\r\n{\r\nfuse_base = ioremap(TEGRA_FUSE_BASE, TEGRA_FUSE_SIZE);\r\ntegra_init_revision();\r\ntegra20_init_speedo_data(&tegra_sku_info);\r\ntegra20_fuse_add_randomness();\r\niounmap(fuse_base);\r\n}
