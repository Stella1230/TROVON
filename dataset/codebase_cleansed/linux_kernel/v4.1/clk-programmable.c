static unsigned long clk_programmable_recalc_rate(struct clk_hw *hw,\r\nunsigned long parent_rate)\r\n{\r\nu32 pres;\r\nstruct clk_programmable *prog = to_clk_programmable(hw);\r\nstruct at91_pmc *pmc = prog->pmc;\r\nconst struct clk_programmable_layout *layout = prog->layout;\r\npres = (pmc_read(pmc, AT91_PMC_PCKR(prog->id)) >> layout->pres_shift) &\r\nPROG_PRES_MASK;\r\nreturn parent_rate >> pres;\r\n}\r\nstatic long clk_programmable_determine_rate(struct clk_hw *hw,\r\nunsigned long rate,\r\nunsigned long min_rate,\r\nunsigned long max_rate,\r\nunsigned long *best_parent_rate,\r\nstruct clk_hw **best_parent_hw)\r\n{\r\nstruct clk *parent = NULL;\r\nlong best_rate = -EINVAL;\r\nunsigned long parent_rate;\r\nunsigned long tmp_rate;\r\nint shift;\r\nint i;\r\nfor (i = 0; i < __clk_get_num_parents(hw->clk); i++) {\r\nparent = clk_get_parent_by_index(hw->clk, i);\r\nif (!parent)\r\ncontinue;\r\nparent_rate = __clk_get_rate(parent);\r\nfor (shift = 0; shift < PROG_PRES_MASK; shift++) {\r\ntmp_rate = parent_rate >> shift;\r\nif (tmp_rate <= rate)\r\nbreak;\r\n}\r\nif (tmp_rate > rate)\r\ncontinue;\r\nif (best_rate < 0 || (rate - tmp_rate) < (rate - best_rate)) {\r\nbest_rate = tmp_rate;\r\n*best_parent_rate = parent_rate;\r\n*best_parent_hw = __clk_get_hw(parent);\r\n}\r\nif (!best_rate)\r\nbreak;\r\n}\r\nreturn best_rate;\r\n}\r\nstatic int clk_programmable_set_parent(struct clk_hw *hw, u8 index)\r\n{\r\nstruct clk_programmable *prog = to_clk_programmable(hw);\r\nconst struct clk_programmable_layout *layout = prog->layout;\r\nstruct at91_pmc *pmc = prog->pmc;\r\nu32 tmp = pmc_read(pmc, AT91_PMC_PCKR(prog->id)) & ~layout->css_mask;\r\nif (layout->have_slck_mck)\r\ntmp &= AT91_PMC_CSSMCK_MCK;\r\nif (index > layout->css_mask) {\r\nif (index > PROG_MAX_RM9200_CSS && layout->have_slck_mck) {\r\ntmp |= AT91_PMC_CSSMCK_MCK;\r\nreturn 0;\r\n} else {\r\nreturn -EINVAL;\r\n}\r\n}\r\npmc_write(pmc, AT91_PMC_PCKR(prog->id), tmp | index);\r\nreturn 0;\r\n}\r\nstatic u8 clk_programmable_get_parent(struct clk_hw *hw)\r\n{\r\nu32 tmp;\r\nu8 ret;\r\nstruct clk_programmable *prog = to_clk_programmable(hw);\r\nstruct at91_pmc *pmc = prog->pmc;\r\nconst struct clk_programmable_layout *layout = prog->layout;\r\ntmp = pmc_read(pmc, AT91_PMC_PCKR(prog->id));\r\nret = tmp & layout->css_mask;\r\nif (layout->have_slck_mck && (tmp & AT91_PMC_CSSMCK_MCK) && !ret)\r\nret = PROG_MAX_RM9200_CSS + 1;\r\nreturn ret;\r\n}\r\nstatic int clk_programmable_set_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long parent_rate)\r\n{\r\nstruct clk_programmable *prog = to_clk_programmable(hw);\r\nstruct at91_pmc *pmc = prog->pmc;\r\nconst struct clk_programmable_layout *layout = prog->layout;\r\nunsigned long div = parent_rate / rate;\r\nint shift = 0;\r\nu32 tmp = pmc_read(pmc, AT91_PMC_PCKR(prog->id)) &\r\n~(PROG_PRES_MASK << layout->pres_shift);\r\nif (!div)\r\nreturn -EINVAL;\r\nshift = fls(div) - 1;\r\nif (div != (1<<shift))\r\nreturn -EINVAL;\r\nif (shift >= PROG_PRES_MASK)\r\nreturn -EINVAL;\r\npmc_write(pmc, AT91_PMC_PCKR(prog->id),\r\ntmp | (shift << layout->pres_shift));\r\nreturn 0;\r\n}\r\nstatic struct clk * __init\r\nat91_clk_register_programmable(struct at91_pmc *pmc,\r\nconst char *name, const char **parent_names,\r\nu8 num_parents, u8 id,\r\nconst struct clk_programmable_layout *layout)\r\n{\r\nstruct clk_programmable *prog;\r\nstruct clk *clk = NULL;\r\nstruct clk_init_data init;\r\nif (id > PROG_ID_MAX)\r\nreturn ERR_PTR(-EINVAL);\r\nprog = kzalloc(sizeof(*prog), GFP_KERNEL);\r\nif (!prog)\r\nreturn ERR_PTR(-ENOMEM);\r\ninit.name = name;\r\ninit.ops = &programmable_ops;\r\ninit.parent_names = parent_names;\r\ninit.num_parents = num_parents;\r\ninit.flags = CLK_SET_RATE_GATE | CLK_SET_PARENT_GATE;\r\nprog->id = id;\r\nprog->layout = layout;\r\nprog->hw.init = &init;\r\nprog->pmc = pmc;\r\nclk = clk_register(NULL, &prog->hw);\r\nif (IS_ERR(clk))\r\nkfree(prog);\r\nreturn clk;\r\n}\r\nstatic void __init\r\nof_at91_clk_prog_setup(struct device_node *np, struct at91_pmc *pmc,\r\nconst struct clk_programmable_layout *layout)\r\n{\r\nint num;\r\nu32 id;\r\nint i;\r\nstruct clk *clk;\r\nint num_parents;\r\nconst char *parent_names[PROG_SOURCE_MAX];\r\nconst char *name;\r\nstruct device_node *progclknp;\r\nnum_parents = of_count_phandle_with_args(np, "clocks", "#clock-cells");\r\nif (num_parents <= 0 || num_parents > PROG_SOURCE_MAX)\r\nreturn;\r\nfor (i = 0; i < num_parents; ++i) {\r\nparent_names[i] = of_clk_get_parent_name(np, i);\r\nif (!parent_names[i])\r\nreturn;\r\n}\r\nnum = of_get_child_count(np);\r\nif (!num || num > (PROG_ID_MAX + 1))\r\nreturn;\r\nfor_each_child_of_node(np, progclknp) {\r\nif (of_property_read_u32(progclknp, "reg", &id))\r\ncontinue;\r\nif (of_property_read_string(np, "clock-output-names", &name))\r\nname = progclknp->name;\r\nclk = at91_clk_register_programmable(pmc, name,\r\nparent_names, num_parents,\r\nid, layout);\r\nif (IS_ERR(clk))\r\ncontinue;\r\nof_clk_add_provider(progclknp, of_clk_src_simple_get, clk);\r\n}\r\n}\r\nvoid __init of_at91rm9200_clk_prog_setup(struct device_node *np,\r\nstruct at91_pmc *pmc)\r\n{\r\nof_at91_clk_prog_setup(np, pmc, &at91rm9200_programmable_layout);\r\n}\r\nvoid __init of_at91sam9g45_clk_prog_setup(struct device_node *np,\r\nstruct at91_pmc *pmc)\r\n{\r\nof_at91_clk_prog_setup(np, pmc, &at91sam9g45_programmable_layout);\r\n}\r\nvoid __init of_at91sam9x5_clk_prog_setup(struct device_node *np,\r\nstruct at91_pmc *pmc)\r\n{\r\nof_at91_clk_prog_setup(np, pmc, &at91sam9x5_programmable_layout);\r\n}
