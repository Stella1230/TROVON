int acpi_lpat_raw_to_temp(struct acpi_lpat_conversion_table *lpat_table,\r\nint raw)\r\n{\r\nint i, delta_temp, delta_raw, temp;\r\nstruct acpi_lpat *lpat = lpat_table->lpat;\r\nfor (i = 0; i < lpat_table->lpat_count - 1; i++) {\r\nif ((raw >= lpat[i].raw && raw <= lpat[i+1].raw) ||\r\n(raw <= lpat[i].raw && raw >= lpat[i+1].raw))\r\nbreak;\r\n}\r\nif (i == lpat_table->lpat_count - 1)\r\nreturn -ENOENT;\r\ndelta_temp = lpat[i+1].temp - lpat[i].temp;\r\ndelta_raw = lpat[i+1].raw - lpat[i].raw;\r\ntemp = lpat[i].temp + (raw - lpat[i].raw) * delta_temp / delta_raw;\r\nreturn temp;\r\n}\r\nint acpi_lpat_temp_to_raw(struct acpi_lpat_conversion_table *lpat_table,\r\nint temp)\r\n{\r\nint i, delta_temp, delta_raw, raw;\r\nstruct acpi_lpat *lpat = lpat_table->lpat;\r\nfor (i = 0; i < lpat_table->lpat_count - 1; i++) {\r\nif (temp >= lpat[i].temp && temp <= lpat[i+1].temp)\r\nbreak;\r\n}\r\nif (i == lpat_table->lpat_count - 1)\r\nreturn -ENOENT;\r\ndelta_temp = lpat[i+1].temp - lpat[i].temp;\r\ndelta_raw = lpat[i+1].raw - lpat[i].raw;\r\nraw = lpat[i].raw + (temp - lpat[i].temp) * delta_raw / delta_temp;\r\nreturn raw;\r\n}\r\nstruct acpi_lpat_conversion_table *acpi_lpat_get_conversion_table(acpi_handle\r\nhandle)\r\n{\r\nstruct acpi_lpat_conversion_table *lpat_table = NULL;\r\nstruct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };\r\nunion acpi_object *obj_p, *obj_e;\r\nint *lpat, i;\r\nacpi_status status;\r\nstatus = acpi_evaluate_object(handle, "LPAT", NULL, &buffer);\r\nif (ACPI_FAILURE(status))\r\nreturn NULL;\r\nobj_p = (union acpi_object *)buffer.pointer;\r\nif (!obj_p || (obj_p->type != ACPI_TYPE_PACKAGE) ||\r\n(obj_p->package.count % 2) || (obj_p->package.count < 4))\r\ngoto out;\r\nlpat = kcalloc(obj_p->package.count, sizeof(int), GFP_KERNEL);\r\nif (!lpat)\r\ngoto out;\r\nfor (i = 0; i < obj_p->package.count; i++) {\r\nobj_e = &obj_p->package.elements[i];\r\nif (obj_e->type != ACPI_TYPE_INTEGER) {\r\nkfree(lpat);\r\ngoto out;\r\n}\r\nlpat[i] = (s64)obj_e->integer.value;\r\n}\r\nlpat_table = kzalloc(sizeof(*lpat_table), GFP_KERNEL);\r\nif (!lpat_table) {\r\nkfree(lpat);\r\ngoto out;\r\n}\r\nlpat_table->lpat = (struct acpi_lpat *)lpat;\r\nlpat_table->lpat_count = obj_p->package.count / 2;\r\nout:\r\nkfree(buffer.pointer);\r\nreturn lpat_table;\r\n}\r\nvoid acpi_lpat_free_conversion_table(struct acpi_lpat_conversion_table\r\n*lpat_table)\r\n{\r\nif (lpat_table) {\r\nkfree(lpat_table->lpat);\r\nkfree(lpat_table);\r\n}\r\n}
