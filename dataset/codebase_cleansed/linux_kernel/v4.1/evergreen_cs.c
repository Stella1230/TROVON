static u32 evergreen_cs_get_aray_mode(u32 tiling_flags)\r\n{\r\nif (tiling_flags & RADEON_TILING_MACRO)\r\nreturn ARRAY_2D_TILED_THIN1;\r\nelse if (tiling_flags & RADEON_TILING_MICRO)\r\nreturn ARRAY_1D_TILED_THIN1;\r\nelse\r\nreturn ARRAY_LINEAR_GENERAL;\r\n}\r\nstatic u32 evergreen_cs_get_num_banks(u32 nbanks)\r\n{\r\nswitch (nbanks) {\r\ncase 2:\r\nreturn ADDR_SURF_2_BANK;\r\ncase 4:\r\nreturn ADDR_SURF_4_BANK;\r\ncase 8:\r\ndefault:\r\nreturn ADDR_SURF_8_BANK;\r\ncase 16:\r\nreturn ADDR_SURF_16_BANK;\r\n}\r\n}\r\nstatic void evergreen_cs_track_init(struct evergreen_cs_track *track)\r\n{\r\nint i;\r\nfor (i = 0; i < 8; i++) {\r\ntrack->cb_color_fmask_bo[i] = NULL;\r\ntrack->cb_color_cmask_bo[i] = NULL;\r\ntrack->cb_color_cmask_slice[i] = 0;\r\ntrack->cb_color_fmask_slice[i] = 0;\r\n}\r\nfor (i = 0; i < 12; i++) {\r\ntrack->cb_color_bo[i] = NULL;\r\ntrack->cb_color_bo_offset[i] = 0xFFFFFFFF;\r\ntrack->cb_color_info[i] = 0;\r\ntrack->cb_color_view[i] = 0xFFFFFFFF;\r\ntrack->cb_color_pitch[i] = 0;\r\ntrack->cb_color_slice[i] = 0xfffffff;\r\ntrack->cb_color_slice_idx[i] = 0;\r\n}\r\ntrack->cb_target_mask = 0xFFFFFFFF;\r\ntrack->cb_shader_mask = 0xFFFFFFFF;\r\ntrack->cb_dirty = true;\r\ntrack->db_depth_slice = 0xffffffff;\r\ntrack->db_depth_view = 0xFFFFC000;\r\ntrack->db_depth_size = 0xFFFFFFFF;\r\ntrack->db_depth_control = 0xFFFFFFFF;\r\ntrack->db_z_info = 0xFFFFFFFF;\r\ntrack->db_z_read_offset = 0xFFFFFFFF;\r\ntrack->db_z_write_offset = 0xFFFFFFFF;\r\ntrack->db_z_read_bo = NULL;\r\ntrack->db_z_write_bo = NULL;\r\ntrack->db_s_info = 0xFFFFFFFF;\r\ntrack->db_s_read_offset = 0xFFFFFFFF;\r\ntrack->db_s_write_offset = 0xFFFFFFFF;\r\ntrack->db_s_read_bo = NULL;\r\ntrack->db_s_write_bo = NULL;\r\ntrack->db_dirty = true;\r\ntrack->htile_bo = NULL;\r\ntrack->htile_offset = 0xFFFFFFFF;\r\ntrack->htile_surface = 0;\r\nfor (i = 0; i < 4; i++) {\r\ntrack->vgt_strmout_size[i] = 0;\r\ntrack->vgt_strmout_bo[i] = NULL;\r\ntrack->vgt_strmout_bo_offset[i] = 0xFFFFFFFF;\r\n}\r\ntrack->streamout_dirty = true;\r\ntrack->sx_misc_kill_all_prims = false;\r\n}\r\nstatic int evergreen_surface_check_linear(struct radeon_cs_parser *p,\r\nstruct eg_surface *surf,\r\nconst char *prefix)\r\n{\r\nsurf->layer_size = surf->nbx * surf->nby * surf->bpe * surf->nsamples;\r\nsurf->base_align = surf->bpe;\r\nsurf->palign = 1;\r\nsurf->halign = 1;\r\nreturn 0;\r\n}\r\nstatic int evergreen_surface_check_linear_aligned(struct radeon_cs_parser *p,\r\nstruct eg_surface *surf,\r\nconst char *prefix)\r\n{\r\nstruct evergreen_cs_track *track = p->track;\r\nunsigned palign;\r\npalign = MAX(64, track->group_size / surf->bpe);\r\nsurf->layer_size = surf->nbx * surf->nby * surf->bpe * surf->nsamples;\r\nsurf->base_align = track->group_size;\r\nsurf->palign = palign;\r\nsurf->halign = 1;\r\nif (surf->nbx & (palign - 1)) {\r\nif (prefix) {\r\ndev_warn(p->dev, "%s:%d %s pitch %d invalid must be aligned with %d\n",\r\n__func__, __LINE__, prefix, surf->nbx, palign);\r\n}\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int evergreen_surface_check_1d(struct radeon_cs_parser *p,\r\nstruct eg_surface *surf,\r\nconst char *prefix)\r\n{\r\nstruct evergreen_cs_track *track = p->track;\r\nunsigned palign;\r\npalign = track->group_size / (8 * surf->bpe * surf->nsamples);\r\npalign = MAX(8, palign);\r\nsurf->layer_size = surf->nbx * surf->nby * surf->bpe;\r\nsurf->base_align = track->group_size;\r\nsurf->palign = palign;\r\nsurf->halign = 8;\r\nif ((surf->nbx & (palign - 1))) {\r\nif (prefix) {\r\ndev_warn(p->dev, "%s:%d %s pitch %d invalid must be aligned with %d (%d %d %d)\n",\r\n__func__, __LINE__, prefix, surf->nbx, palign,\r\ntrack->group_size, surf->bpe, surf->nsamples);\r\n}\r\nreturn -EINVAL;\r\n}\r\nif ((surf->nby & (8 - 1))) {\r\nif (prefix) {\r\ndev_warn(p->dev, "%s:%d %s height %d invalid must be aligned with 8\n",\r\n__func__, __LINE__, prefix, surf->nby);\r\n}\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int evergreen_surface_check_2d(struct radeon_cs_parser *p,\r\nstruct eg_surface *surf,\r\nconst char *prefix)\r\n{\r\nstruct evergreen_cs_track *track = p->track;\r\nunsigned palign, halign, tileb, slice_pt;\r\nunsigned mtile_pr, mtile_ps, mtileb;\r\ntileb = 64 * surf->bpe * surf->nsamples;\r\nslice_pt = 1;\r\nif (tileb > surf->tsplit) {\r\nslice_pt = tileb / surf->tsplit;\r\n}\r\ntileb = tileb / slice_pt;\r\npalign = (8 * surf->bankw * track->npipes) * surf->mtilea;\r\nhalign = (8 * surf->bankh * surf->nbanks) / surf->mtilea;\r\nmtileb = (palign / 8) * (halign / 8) * tileb;\r\nmtile_pr = surf->nbx / palign;\r\nmtile_ps = (mtile_pr * surf->nby) / halign;\r\nsurf->layer_size = mtile_ps * mtileb * slice_pt;\r\nsurf->base_align = (palign / 8) * (halign / 8) * tileb;\r\nsurf->palign = palign;\r\nsurf->halign = halign;\r\nif ((surf->nbx & (palign - 1))) {\r\nif (prefix) {\r\ndev_warn(p->dev, "%s:%d %s pitch %d invalid must be aligned with %d\n",\r\n__func__, __LINE__, prefix, surf->nbx, palign);\r\n}\r\nreturn -EINVAL;\r\n}\r\nif ((surf->nby & (halign - 1))) {\r\nif (prefix) {\r\ndev_warn(p->dev, "%s:%d %s height %d invalid must be aligned with %d\n",\r\n__func__, __LINE__, prefix, surf->nby, halign);\r\n}\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int evergreen_surface_check(struct radeon_cs_parser *p,\r\nstruct eg_surface *surf,\r\nconst char *prefix)\r\n{\r\nsurf->bpe = r600_fmt_get_blocksize(surf->format);\r\nswitch (surf->mode) {\r\ncase ARRAY_LINEAR_GENERAL:\r\nreturn evergreen_surface_check_linear(p, surf, prefix);\r\ncase ARRAY_LINEAR_ALIGNED:\r\nreturn evergreen_surface_check_linear_aligned(p, surf, prefix);\r\ncase ARRAY_1D_TILED_THIN1:\r\nreturn evergreen_surface_check_1d(p, surf, prefix);\r\ncase ARRAY_2D_TILED_THIN1:\r\nreturn evergreen_surface_check_2d(p, surf, prefix);\r\ndefault:\r\ndev_warn(p->dev, "%s:%d %s invalid array mode %d\n",\r\n__func__, __LINE__, prefix, surf->mode);\r\nreturn -EINVAL;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int evergreen_surface_value_conv_check(struct radeon_cs_parser *p,\r\nstruct eg_surface *surf,\r\nconst char *prefix)\r\n{\r\nswitch (surf->mode) {\r\ncase ARRAY_2D_TILED_THIN1:\r\nbreak;\r\ncase ARRAY_LINEAR_GENERAL:\r\ncase ARRAY_LINEAR_ALIGNED:\r\ncase ARRAY_1D_TILED_THIN1:\r\nreturn 0;\r\ndefault:\r\ndev_warn(p->dev, "%s:%d %s invalid array mode %d\n",\r\n__func__, __LINE__, prefix, surf->mode);\r\nreturn -EINVAL;\r\n}\r\nswitch (surf->nbanks) {\r\ncase 0: surf->nbanks = 2; break;\r\ncase 1: surf->nbanks = 4; break;\r\ncase 2: surf->nbanks = 8; break;\r\ncase 3: surf->nbanks = 16; break;\r\ndefault:\r\ndev_warn(p->dev, "%s:%d %s invalid number of banks %d\n",\r\n__func__, __LINE__, prefix, surf->nbanks);\r\nreturn -EINVAL;\r\n}\r\nswitch (surf->bankw) {\r\ncase 0: surf->bankw = 1; break;\r\ncase 1: surf->bankw = 2; break;\r\ncase 2: surf->bankw = 4; break;\r\ncase 3: surf->bankw = 8; break;\r\ndefault:\r\ndev_warn(p->dev, "%s:%d %s invalid bankw %d\n",\r\n__func__, __LINE__, prefix, surf->bankw);\r\nreturn -EINVAL;\r\n}\r\nswitch (surf->bankh) {\r\ncase 0: surf->bankh = 1; break;\r\ncase 1: surf->bankh = 2; break;\r\ncase 2: surf->bankh = 4; break;\r\ncase 3: surf->bankh = 8; break;\r\ndefault:\r\ndev_warn(p->dev, "%s:%d %s invalid bankh %d\n",\r\n__func__, __LINE__, prefix, surf->bankh);\r\nreturn -EINVAL;\r\n}\r\nswitch (surf->mtilea) {\r\ncase 0: surf->mtilea = 1; break;\r\ncase 1: surf->mtilea = 2; break;\r\ncase 2: surf->mtilea = 4; break;\r\ncase 3: surf->mtilea = 8; break;\r\ndefault:\r\ndev_warn(p->dev, "%s:%d %s invalid macro tile aspect %d\n",\r\n__func__, __LINE__, prefix, surf->mtilea);\r\nreturn -EINVAL;\r\n}\r\nswitch (surf->tsplit) {\r\ncase 0: surf->tsplit = 64; break;\r\ncase 1: surf->tsplit = 128; break;\r\ncase 2: surf->tsplit = 256; break;\r\ncase 3: surf->tsplit = 512; break;\r\ncase 4: surf->tsplit = 1024; break;\r\ncase 5: surf->tsplit = 2048; break;\r\ncase 6: surf->tsplit = 4096; break;\r\ndefault:\r\ndev_warn(p->dev, "%s:%d %s invalid tile split %d\n",\r\n__func__, __LINE__, prefix, surf->tsplit);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int evergreen_cs_track_validate_cb(struct radeon_cs_parser *p, unsigned id)\r\n{\r\nstruct evergreen_cs_track *track = p->track;\r\nstruct eg_surface surf;\r\nunsigned pitch, slice, mslice;\r\nunsigned long offset;\r\nint r;\r\nmslice = G_028C6C_SLICE_MAX(track->cb_color_view[id]) + 1;\r\npitch = track->cb_color_pitch[id];\r\nslice = track->cb_color_slice[id];\r\nsurf.nbx = (pitch + 1) * 8;\r\nsurf.nby = ((slice + 1) * 64) / surf.nbx;\r\nsurf.mode = G_028C70_ARRAY_MODE(track->cb_color_info[id]);\r\nsurf.format = G_028C70_FORMAT(track->cb_color_info[id]);\r\nsurf.tsplit = G_028C74_TILE_SPLIT(track->cb_color_attrib[id]);\r\nsurf.nbanks = G_028C74_NUM_BANKS(track->cb_color_attrib[id]);\r\nsurf.bankw = G_028C74_BANK_WIDTH(track->cb_color_attrib[id]);\r\nsurf.bankh = G_028C74_BANK_HEIGHT(track->cb_color_attrib[id]);\r\nsurf.mtilea = G_028C74_MACRO_TILE_ASPECT(track->cb_color_attrib[id]);\r\nsurf.nsamples = 1;\r\nif (!r600_fmt_is_valid_color(surf.format)) {\r\ndev_warn(p->dev, "%s:%d cb invalid format %d for %d (0x%08x)\n",\r\n__func__, __LINE__, surf.format,\r\nid, track->cb_color_info[id]);\r\nreturn -EINVAL;\r\n}\r\nr = evergreen_surface_value_conv_check(p, &surf, "cb");\r\nif (r) {\r\nreturn r;\r\n}\r\nr = evergreen_surface_check(p, &surf, "cb");\r\nif (r) {\r\ndev_warn(p->dev, "%s:%d cb[%d] invalid (0x%08x 0x%08x 0x%08x 0x%08x)\n",\r\n__func__, __LINE__, id, track->cb_color_pitch[id],\r\ntrack->cb_color_slice[id], track->cb_color_attrib[id],\r\ntrack->cb_color_info[id]);\r\nreturn r;\r\n}\r\noffset = track->cb_color_bo_offset[id] << 8;\r\nif (offset & (surf.base_align - 1)) {\r\ndev_warn(p->dev, "%s:%d cb[%d] bo base %ld not aligned with %ld\n",\r\n__func__, __LINE__, id, offset, surf.base_align);\r\nreturn -EINVAL;\r\n}\r\noffset += surf.layer_size * mslice;\r\nif (offset > radeon_bo_size(track->cb_color_bo[id])) {\r\nif (!surf.mode) {\r\nvolatile u32 *ib = p->ib.ptr;\r\nunsigned long tmp, nby, bsize, size, min = 0;\r\nif (surf.nby > 8) {\r\nmin = surf.nby - 8;\r\n}\r\nbsize = radeon_bo_size(track->cb_color_bo[id]);\r\ntmp = track->cb_color_bo_offset[id] << 8;\r\nfor (nby = surf.nby; nby > min; nby--) {\r\nsize = nby * surf.nbx * surf.bpe * surf.nsamples;\r\nif ((tmp + size * mslice) <= bsize) {\r\nbreak;\r\n}\r\n}\r\nif (nby > min) {\r\nsurf.nby = nby;\r\nslice = ((nby * surf.nbx) / 64) - 1;\r\nif (!evergreen_surface_check(p, &surf, "cb")) {\r\ntmp += surf.layer_size * mslice;\r\nif (tmp <= bsize) {\r\nib[track->cb_color_slice_idx[id]] = slice;\r\ngoto old_ddx_ok;\r\n}\r\n}\r\n}\r\n}\r\ndev_warn(p->dev, "%s:%d cb[%d] bo too small (layer size %d, "\r\n"offset %d, max layer %d, bo size %ld, slice %d)\n",\r\n__func__, __LINE__, id, surf.layer_size,\r\ntrack->cb_color_bo_offset[id] << 8, mslice,\r\nradeon_bo_size(track->cb_color_bo[id]), slice);\r\ndev_warn(p->dev, "%s:%d problematic surf: (%d %d) (%d %d %d %d %d %d %d)\n",\r\n__func__, __LINE__, surf.nbx, surf.nby,\r\nsurf.mode, surf.bpe, surf.nsamples,\r\nsurf.bankw, surf.bankh,\r\nsurf.tsplit, surf.mtilea);\r\nreturn -EINVAL;\r\n}\r\nold_ddx_ok:\r\nreturn 0;\r\n}\r\nstatic int evergreen_cs_track_validate_htile(struct radeon_cs_parser *p,\r\nunsigned nbx, unsigned nby)\r\n{\r\nstruct evergreen_cs_track *track = p->track;\r\nunsigned long size;\r\nif (track->htile_bo == NULL) {\r\ndev_warn(p->dev, "%s:%d htile enabled without htile surface 0x%08x\n",\r\n__func__, __LINE__, track->db_z_info);\r\nreturn -EINVAL;\r\n}\r\nif (G_028ABC_LINEAR(track->htile_surface)) {\r\nnbx = round_up(nbx, 16 * 8);\r\nnby = round_up(nby, track->npipes * 8);\r\n} else {\r\nswitch (track->npipes) {\r\ncase 8:\r\nnbx = round_up(nbx, 64 * 8);\r\nnby = round_up(nby, 64 * 8);\r\nbreak;\r\ncase 4:\r\nnbx = round_up(nbx, 64 * 8);\r\nnby = round_up(nby, 32 * 8);\r\nbreak;\r\ncase 2:\r\nnbx = round_up(nbx, 32 * 8);\r\nnby = round_up(nby, 32 * 8);\r\nbreak;\r\ncase 1:\r\nnbx = round_up(nbx, 32 * 8);\r\nnby = round_up(nby, 16 * 8);\r\nbreak;\r\ndefault:\r\ndev_warn(p->dev, "%s:%d invalid num pipes %d\n",\r\n__func__, __LINE__, track->npipes);\r\nreturn -EINVAL;\r\n}\r\n}\r\nnbx = nbx >> 3;\r\nnby = nby >> 3;\r\nsize = roundup(nbx * nby * 4, track->npipes * (2 << 10));\r\nsize += track->htile_offset;\r\nif (size > radeon_bo_size(track->htile_bo)) {\r\ndev_warn(p->dev, "%s:%d htile surface too small %ld for %ld (%d %d)\n",\r\n__func__, __LINE__, radeon_bo_size(track->htile_bo),\r\nsize, nbx, nby);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int evergreen_cs_track_validate_stencil(struct radeon_cs_parser *p)\r\n{\r\nstruct evergreen_cs_track *track = p->track;\r\nstruct eg_surface surf;\r\nunsigned pitch, slice, mslice;\r\nunsigned long offset;\r\nint r;\r\nmslice = G_028008_SLICE_MAX(track->db_depth_view) + 1;\r\npitch = G_028058_PITCH_TILE_MAX(track->db_depth_size);\r\nslice = track->db_depth_slice;\r\nsurf.nbx = (pitch + 1) * 8;\r\nsurf.nby = ((slice + 1) * 64) / surf.nbx;\r\nsurf.mode = G_028040_ARRAY_MODE(track->db_z_info);\r\nsurf.format = G_028044_FORMAT(track->db_s_info);\r\nsurf.tsplit = G_028044_TILE_SPLIT(track->db_s_info);\r\nsurf.nbanks = G_028040_NUM_BANKS(track->db_z_info);\r\nsurf.bankw = G_028040_BANK_WIDTH(track->db_z_info);\r\nsurf.bankh = G_028040_BANK_HEIGHT(track->db_z_info);\r\nsurf.mtilea = G_028040_MACRO_TILE_ASPECT(track->db_z_info);\r\nsurf.nsamples = 1;\r\nif (surf.format != 1) {\r\ndev_warn(p->dev, "%s:%d stencil invalid format %d\n",\r\n__func__, __LINE__, surf.format);\r\nreturn -EINVAL;\r\n}\r\nsurf.format = V_028C70_COLOR_8;\r\nr = evergreen_surface_value_conv_check(p, &surf, "stencil");\r\nif (r) {\r\nreturn r;\r\n}\r\nr = evergreen_surface_check(p, &surf, NULL);\r\nif (r) {\r\nsurf.format = V_028C70_COLOR_8_8_8_8;\r\nr = evergreen_surface_check(p, &surf, "stencil");\r\nif (r) {\r\ndev_warn(p->dev, "%s:%d stencil invalid (0x%08x 0x%08x 0x%08x 0x%08x)\n",\r\n__func__, __LINE__, track->db_depth_size,\r\ntrack->db_depth_slice, track->db_s_info, track->db_z_info);\r\n}\r\nreturn r;\r\n}\r\noffset = track->db_s_read_offset << 8;\r\nif (offset & (surf.base_align - 1)) {\r\ndev_warn(p->dev, "%s:%d stencil read bo base %ld not aligned with %ld\n",\r\n__func__, __LINE__, offset, surf.base_align);\r\nreturn -EINVAL;\r\n}\r\noffset += surf.layer_size * mslice;\r\nif (offset > radeon_bo_size(track->db_s_read_bo)) {\r\ndev_warn(p->dev, "%s:%d stencil read bo too small (layer size %d, "\r\n"offset %ld, max layer %d, bo size %ld)\n",\r\n__func__, __LINE__, surf.layer_size,\r\n(unsigned long)track->db_s_read_offset << 8, mslice,\r\nradeon_bo_size(track->db_s_read_bo));\r\ndev_warn(p->dev, "%s:%d stencil invalid (0x%08x 0x%08x 0x%08x 0x%08x)\n",\r\n__func__, __LINE__, track->db_depth_size,\r\ntrack->db_depth_slice, track->db_s_info, track->db_z_info);\r\nreturn -EINVAL;\r\n}\r\noffset = track->db_s_write_offset << 8;\r\nif (offset & (surf.base_align - 1)) {\r\ndev_warn(p->dev, "%s:%d stencil write bo base %ld not aligned with %ld\n",\r\n__func__, __LINE__, offset, surf.base_align);\r\nreturn -EINVAL;\r\n}\r\noffset += surf.layer_size * mslice;\r\nif (offset > radeon_bo_size(track->db_s_write_bo)) {\r\ndev_warn(p->dev, "%s:%d stencil write bo too small (layer size %d, "\r\n"offset %ld, max layer %d, bo size %ld)\n",\r\n__func__, __LINE__, surf.layer_size,\r\n(unsigned long)track->db_s_write_offset << 8, mslice,\r\nradeon_bo_size(track->db_s_write_bo));\r\nreturn -EINVAL;\r\n}\r\nif (G_028040_TILE_SURFACE_ENABLE(track->db_z_info)) {\r\nr = evergreen_cs_track_validate_htile(p, surf.nbx, surf.nby);\r\nif (r) {\r\nreturn r;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int evergreen_cs_track_validate_depth(struct radeon_cs_parser *p)\r\n{\r\nstruct evergreen_cs_track *track = p->track;\r\nstruct eg_surface surf;\r\nunsigned pitch, slice, mslice;\r\nunsigned long offset;\r\nint r;\r\nmslice = G_028008_SLICE_MAX(track->db_depth_view) + 1;\r\npitch = G_028058_PITCH_TILE_MAX(track->db_depth_size);\r\nslice = track->db_depth_slice;\r\nsurf.nbx = (pitch + 1) * 8;\r\nsurf.nby = ((slice + 1) * 64) / surf.nbx;\r\nsurf.mode = G_028040_ARRAY_MODE(track->db_z_info);\r\nsurf.format = G_028040_FORMAT(track->db_z_info);\r\nsurf.tsplit = G_028040_TILE_SPLIT(track->db_z_info);\r\nsurf.nbanks = G_028040_NUM_BANKS(track->db_z_info);\r\nsurf.bankw = G_028040_BANK_WIDTH(track->db_z_info);\r\nsurf.bankh = G_028040_BANK_HEIGHT(track->db_z_info);\r\nsurf.mtilea = G_028040_MACRO_TILE_ASPECT(track->db_z_info);\r\nsurf.nsamples = 1;\r\nswitch (surf.format) {\r\ncase V_028040_Z_16:\r\nsurf.format = V_028C70_COLOR_16;\r\nbreak;\r\ncase V_028040_Z_24:\r\ncase V_028040_Z_32_FLOAT:\r\nsurf.format = V_028C70_COLOR_8_8_8_8;\r\nbreak;\r\ndefault:\r\ndev_warn(p->dev, "%s:%d depth invalid format %d\n",\r\n__func__, __LINE__, surf.format);\r\nreturn -EINVAL;\r\n}\r\nr = evergreen_surface_value_conv_check(p, &surf, "depth");\r\nif (r) {\r\ndev_warn(p->dev, "%s:%d depth invalid (0x%08x 0x%08x 0x%08x)\n",\r\n__func__, __LINE__, track->db_depth_size,\r\ntrack->db_depth_slice, track->db_z_info);\r\nreturn r;\r\n}\r\nr = evergreen_surface_check(p, &surf, "depth");\r\nif (r) {\r\ndev_warn(p->dev, "%s:%d depth invalid (0x%08x 0x%08x 0x%08x)\n",\r\n__func__, __LINE__, track->db_depth_size,\r\ntrack->db_depth_slice, track->db_z_info);\r\nreturn r;\r\n}\r\noffset = track->db_z_read_offset << 8;\r\nif (offset & (surf.base_align - 1)) {\r\ndev_warn(p->dev, "%s:%d stencil read bo base %ld not aligned with %ld\n",\r\n__func__, __LINE__, offset, surf.base_align);\r\nreturn -EINVAL;\r\n}\r\noffset += surf.layer_size * mslice;\r\nif (offset > radeon_bo_size(track->db_z_read_bo)) {\r\ndev_warn(p->dev, "%s:%d depth read bo too small (layer size %d, "\r\n"offset %ld, max layer %d, bo size %ld)\n",\r\n__func__, __LINE__, surf.layer_size,\r\n(unsigned long)track->db_z_read_offset << 8, mslice,\r\nradeon_bo_size(track->db_z_read_bo));\r\nreturn -EINVAL;\r\n}\r\noffset = track->db_z_write_offset << 8;\r\nif (offset & (surf.base_align - 1)) {\r\ndev_warn(p->dev, "%s:%d stencil write bo base %ld not aligned with %ld\n",\r\n__func__, __LINE__, offset, surf.base_align);\r\nreturn -EINVAL;\r\n}\r\noffset += surf.layer_size * mslice;\r\nif (offset > radeon_bo_size(track->db_z_write_bo)) {\r\ndev_warn(p->dev, "%s:%d depth write bo too small (layer size %d, "\r\n"offset %ld, max layer %d, bo size %ld)\n",\r\n__func__, __LINE__, surf.layer_size,\r\n(unsigned long)track->db_z_write_offset << 8, mslice,\r\nradeon_bo_size(track->db_z_write_bo));\r\nreturn -EINVAL;\r\n}\r\nif (G_028040_TILE_SURFACE_ENABLE(track->db_z_info)) {\r\nr = evergreen_cs_track_validate_htile(p, surf.nbx, surf.nby);\r\nif (r) {\r\nreturn r;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int evergreen_cs_track_validate_texture(struct radeon_cs_parser *p,\r\nstruct radeon_bo *texture,\r\nstruct radeon_bo *mipmap,\r\nunsigned idx)\r\n{\r\nstruct eg_surface surf;\r\nunsigned long toffset, moffset;\r\nunsigned dim, llevel, mslice, width, height, depth, i;\r\nu32 texdw[8];\r\nint r;\r\ntexdw[0] = radeon_get_ib_value(p, idx + 0);\r\ntexdw[1] = radeon_get_ib_value(p, idx + 1);\r\ntexdw[2] = radeon_get_ib_value(p, idx + 2);\r\ntexdw[3] = radeon_get_ib_value(p, idx + 3);\r\ntexdw[4] = radeon_get_ib_value(p, idx + 4);\r\ntexdw[5] = radeon_get_ib_value(p, idx + 5);\r\ntexdw[6] = radeon_get_ib_value(p, idx + 6);\r\ntexdw[7] = radeon_get_ib_value(p, idx + 7);\r\ndim = G_030000_DIM(texdw[0]);\r\nllevel = G_030014_LAST_LEVEL(texdw[5]);\r\nmslice = G_030014_LAST_ARRAY(texdw[5]) + 1;\r\nwidth = G_030000_TEX_WIDTH(texdw[0]) + 1;\r\nheight = G_030004_TEX_HEIGHT(texdw[1]) + 1;\r\ndepth = G_030004_TEX_DEPTH(texdw[1]) + 1;\r\nsurf.format = G_03001C_DATA_FORMAT(texdw[7]);\r\nsurf.nbx = (G_030000_PITCH(texdw[0]) + 1) * 8;\r\nsurf.nbx = r600_fmt_get_nblocksx(surf.format, surf.nbx);\r\nsurf.nby = r600_fmt_get_nblocksy(surf.format, height);\r\nsurf.mode = G_030004_ARRAY_MODE(texdw[1]);\r\nsurf.tsplit = G_030018_TILE_SPLIT(texdw[6]);\r\nsurf.nbanks = G_03001C_NUM_BANKS(texdw[7]);\r\nsurf.bankw = G_03001C_BANK_WIDTH(texdw[7]);\r\nsurf.bankh = G_03001C_BANK_HEIGHT(texdw[7]);\r\nsurf.mtilea = G_03001C_MACRO_TILE_ASPECT(texdw[7]);\r\nsurf.nsamples = 1;\r\ntoffset = texdw[2] << 8;\r\nmoffset = texdw[3] << 8;\r\nif (!r600_fmt_is_valid_texture(surf.format, p->family)) {\r\ndev_warn(p->dev, "%s:%d texture invalid format %d\n",\r\n__func__, __LINE__, surf.format);\r\nreturn -EINVAL;\r\n}\r\nswitch (dim) {\r\ncase V_030000_SQ_TEX_DIM_1D:\r\ncase V_030000_SQ_TEX_DIM_2D:\r\ncase V_030000_SQ_TEX_DIM_CUBEMAP:\r\ncase V_030000_SQ_TEX_DIM_1D_ARRAY:\r\ncase V_030000_SQ_TEX_DIM_2D_ARRAY:\r\ndepth = 1;\r\nbreak;\r\ncase V_030000_SQ_TEX_DIM_2D_MSAA:\r\ncase V_030000_SQ_TEX_DIM_2D_ARRAY_MSAA:\r\nsurf.nsamples = 1 << llevel;\r\nllevel = 0;\r\ndepth = 1;\r\nbreak;\r\ncase V_030000_SQ_TEX_DIM_3D:\r\nbreak;\r\ndefault:\r\ndev_warn(p->dev, "%s:%d texture invalid dimension %d\n",\r\n__func__, __LINE__, dim);\r\nreturn -EINVAL;\r\n}\r\nr = evergreen_surface_value_conv_check(p, &surf, "texture");\r\nif (r) {\r\nreturn r;\r\n}\r\nevergreen_surface_check(p, &surf, NULL);\r\nsurf.nby = ALIGN(surf.nby, surf.halign);\r\nr = evergreen_surface_check(p, &surf, "texture");\r\nif (r) {\r\ndev_warn(p->dev, "%s:%d texture invalid 0x%08x 0x%08x 0x%08x 0x%08x 0x%08x 0x%08x\n",\r\n__func__, __LINE__, texdw[0], texdw[1], texdw[4],\r\ntexdw[5], texdw[6], texdw[7]);\r\nreturn r;\r\n}\r\nif (toffset & (surf.base_align - 1)) {\r\ndev_warn(p->dev, "%s:%d texture bo base %ld not aligned with %ld\n",\r\n__func__, __LINE__, toffset, surf.base_align);\r\nreturn -EINVAL;\r\n}\r\nif (surf.nsamples <= 1 && moffset & (surf.base_align - 1)) {\r\ndev_warn(p->dev, "%s:%d mipmap bo base %ld not aligned with %ld\n",\r\n__func__, __LINE__, moffset, surf.base_align);\r\nreturn -EINVAL;\r\n}\r\nif (dim == SQ_TEX_DIM_3D) {\r\ntoffset += surf.layer_size * depth;\r\n} else {\r\ntoffset += surf.layer_size * mslice;\r\n}\r\nif (toffset > radeon_bo_size(texture)) {\r\ndev_warn(p->dev, "%s:%d texture bo too small (layer size %d, "\r\n"offset %ld, max layer %d, depth %d, bo size %ld) (%d %d)\n",\r\n__func__, __LINE__, surf.layer_size,\r\n(unsigned long)texdw[2] << 8, mslice,\r\ndepth, radeon_bo_size(texture),\r\nsurf.nbx, surf.nby);\r\nreturn -EINVAL;\r\n}\r\nif (!mipmap) {\r\nif (llevel) {\r\ndev_warn(p->dev, "%s:%i got NULL MIP_ADDRESS relocation\n",\r\n__func__, __LINE__);\r\nreturn -EINVAL;\r\n} else {\r\nreturn 0;\r\n}\r\n}\r\nfor (i = 1; i <= llevel; i++) {\r\nunsigned w, h, d;\r\nw = r600_mip_minify(width, i);\r\nh = r600_mip_minify(height, i);\r\nd = r600_mip_minify(depth, i);\r\nsurf.nbx = r600_fmt_get_nblocksx(surf.format, w);\r\nsurf.nby = r600_fmt_get_nblocksy(surf.format, h);\r\nswitch (surf.mode) {\r\ncase ARRAY_2D_TILED_THIN1:\r\nif (surf.nbx < surf.palign || surf.nby < surf.halign) {\r\nsurf.mode = ARRAY_1D_TILED_THIN1;\r\n}\r\nevergreen_surface_check(p, &surf, NULL);\r\nbreak;\r\ncase ARRAY_LINEAR_GENERAL:\r\ncase ARRAY_LINEAR_ALIGNED:\r\ncase ARRAY_1D_TILED_THIN1:\r\nbreak;\r\ndefault:\r\ndev_warn(p->dev, "%s:%d invalid array mode %d\n",\r\n__func__, __LINE__, surf.mode);\r\nreturn -EINVAL;\r\n}\r\nsurf.nbx = ALIGN(surf.nbx, surf.palign);\r\nsurf.nby = ALIGN(surf.nby, surf.halign);\r\nr = evergreen_surface_check(p, &surf, "mipmap");\r\nif (r) {\r\nreturn r;\r\n}\r\nif (dim == SQ_TEX_DIM_3D) {\r\nmoffset += surf.layer_size * d;\r\n} else {\r\nmoffset += surf.layer_size * mslice;\r\n}\r\nif (moffset > radeon_bo_size(mipmap)) {\r\ndev_warn(p->dev, "%s:%d mipmap [%d] bo too small (layer size %d, "\r\n"offset %ld, coffset %ld, max layer %d, depth %d, "\r\n"bo size %ld) level0 (%d %d %d)\n",\r\n__func__, __LINE__, i, surf.layer_size,\r\n(unsigned long)texdw[3] << 8, moffset, mslice,\r\nd, radeon_bo_size(mipmap),\r\nwidth, height, depth);\r\ndev_warn(p->dev, "%s:%d problematic surf: (%d %d) (%d %d %d %d %d %d %d)\n",\r\n__func__, __LINE__, surf.nbx, surf.nby,\r\nsurf.mode, surf.bpe, surf.nsamples,\r\nsurf.bankw, surf.bankh,\r\nsurf.tsplit, surf.mtilea);\r\nreturn -EINVAL;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int evergreen_cs_track_check(struct radeon_cs_parser *p)\r\n{\r\nstruct evergreen_cs_track *track = p->track;\r\nunsigned tmp, i;\r\nint r;\r\nunsigned buffer_mask = 0;\r\nif (track->streamout_dirty && track->vgt_strmout_config) {\r\nfor (i = 0; i < 4; i++) {\r\nif (track->vgt_strmout_config & (1 << i)) {\r\nbuffer_mask |= (track->vgt_strmout_buffer_config >> (i * 4)) & 0xf;\r\n}\r\n}\r\nfor (i = 0; i < 4; i++) {\r\nif (buffer_mask & (1 << i)) {\r\nif (track->vgt_strmout_bo[i]) {\r\nu64 offset = (u64)track->vgt_strmout_bo_offset[i] +\r\n(u64)track->vgt_strmout_size[i];\r\nif (offset > radeon_bo_size(track->vgt_strmout_bo[i])) {\r\nDRM_ERROR("streamout %d bo too small: 0x%llx, 0x%lx\n",\r\ni, offset,\r\nradeon_bo_size(track->vgt_strmout_bo[i]));\r\nreturn -EINVAL;\r\n}\r\n} else {\r\ndev_warn(p->dev, "No buffer for streamout %d\n", i);\r\nreturn -EINVAL;\r\n}\r\n}\r\n}\r\ntrack->streamout_dirty = false;\r\n}\r\nif (track->sx_misc_kill_all_prims)\r\nreturn 0;\r\nif (track->cb_dirty) {\r\ntmp = track->cb_target_mask;\r\nfor (i = 0; i < 8; i++) {\r\nu32 format = G_028C70_FORMAT(track->cb_color_info[i]);\r\nif (format != V_028C70_COLOR_INVALID &&\r\n(tmp >> (i * 4)) & 0xF) {\r\nif (track->cb_color_bo[i] == NULL) {\r\ndev_warn(p->dev, "%s:%d mask 0x%08X | 0x%08X no cb for %d\n",\r\n__func__, __LINE__, track->cb_target_mask, track->cb_shader_mask, i);\r\nreturn -EINVAL;\r\n}\r\nr = evergreen_cs_track_validate_cb(p, i);\r\nif (r) {\r\nreturn r;\r\n}\r\n}\r\n}\r\ntrack->cb_dirty = false;\r\n}\r\nif (track->db_dirty) {\r\nif (G_028044_FORMAT(track->db_s_info) != V_028044_STENCIL_INVALID &&\r\nG_028800_STENCIL_ENABLE(track->db_depth_control)) {\r\nr = evergreen_cs_track_validate_stencil(p);\r\nif (r)\r\nreturn r;\r\n}\r\nif (G_028040_FORMAT(track->db_z_info) != V_028040_Z_INVALID &&\r\nG_028800_Z_ENABLE(track->db_depth_control)) {\r\nr = evergreen_cs_track_validate_depth(p);\r\nif (r)\r\nreturn r;\r\n}\r\ntrack->db_dirty = false;\r\n}\r\nreturn 0;\r\n}\r\nstatic int evergreen_cs_packet_parse_vline(struct radeon_cs_parser *p)\r\n{\r\nstatic uint32_t vline_start_end[6] = {\r\nEVERGREEN_VLINE_START_END + EVERGREEN_CRTC0_REGISTER_OFFSET,\r\nEVERGREEN_VLINE_START_END + EVERGREEN_CRTC1_REGISTER_OFFSET,\r\nEVERGREEN_VLINE_START_END + EVERGREEN_CRTC2_REGISTER_OFFSET,\r\nEVERGREEN_VLINE_START_END + EVERGREEN_CRTC3_REGISTER_OFFSET,\r\nEVERGREEN_VLINE_START_END + EVERGREEN_CRTC4_REGISTER_OFFSET,\r\nEVERGREEN_VLINE_START_END + EVERGREEN_CRTC5_REGISTER_OFFSET\r\n};\r\nstatic uint32_t vline_status[6] = {\r\nEVERGREEN_VLINE_STATUS + EVERGREEN_CRTC0_REGISTER_OFFSET,\r\nEVERGREEN_VLINE_STATUS + EVERGREEN_CRTC1_REGISTER_OFFSET,\r\nEVERGREEN_VLINE_STATUS + EVERGREEN_CRTC2_REGISTER_OFFSET,\r\nEVERGREEN_VLINE_STATUS + EVERGREEN_CRTC3_REGISTER_OFFSET,\r\nEVERGREEN_VLINE_STATUS + EVERGREEN_CRTC4_REGISTER_OFFSET,\r\nEVERGREEN_VLINE_STATUS + EVERGREEN_CRTC5_REGISTER_OFFSET\r\n};\r\nreturn r600_cs_common_vline_parse(p, vline_start_end, vline_status);\r\n}\r\nstatic int evergreen_packet0_check(struct radeon_cs_parser *p,\r\nstruct radeon_cs_packet *pkt,\r\nunsigned idx, unsigned reg)\r\n{\r\nint r;\r\nswitch (reg) {\r\ncase EVERGREEN_VLINE_START_END:\r\nr = evergreen_cs_packet_parse_vline(p);\r\nif (r) {\r\nDRM_ERROR("No reloc for ib[%d]=0x%04X\n",\r\nidx, reg);\r\nreturn r;\r\n}\r\nbreak;\r\ndefault:\r\nprintk(KERN_ERR "Forbidden register 0x%04X in cs at %d\n",\r\nreg, idx);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int evergreen_cs_parse_packet0(struct radeon_cs_parser *p,\r\nstruct radeon_cs_packet *pkt)\r\n{\r\nunsigned reg, i;\r\nunsigned idx;\r\nint r;\r\nidx = pkt->idx + 1;\r\nreg = pkt->reg;\r\nfor (i = 0; i <= pkt->count; i++, idx++, reg += 4) {\r\nr = evergreen_packet0_check(p, pkt, idx, reg);\r\nif (r) {\r\nreturn r;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int evergreen_cs_check_reg(struct radeon_cs_parser *p, u32 reg, u32 idx)\r\n{\r\nstruct evergreen_cs_track *track = (struct evergreen_cs_track *)p->track;\r\nstruct radeon_bo_list *reloc;\r\nu32 last_reg;\r\nu32 m, i, tmp, *ib;\r\nint r;\r\nif (p->rdev->family >= CHIP_CAYMAN)\r\nlast_reg = ARRAY_SIZE(cayman_reg_safe_bm);\r\nelse\r\nlast_reg = ARRAY_SIZE(evergreen_reg_safe_bm);\r\ni = (reg >> 7);\r\nif (i >= last_reg) {\r\ndev_warn(p->dev, "forbidden register 0x%08x at %d\n", reg, idx);\r\nreturn -EINVAL;\r\n}\r\nm = 1 << ((reg >> 2) & 31);\r\nif (p->rdev->family >= CHIP_CAYMAN) {\r\nif (!(cayman_reg_safe_bm[i] & m))\r\nreturn 0;\r\n} else {\r\nif (!(evergreen_reg_safe_bm[i] & m))\r\nreturn 0;\r\n}\r\nib = p->ib.ptr;\r\nswitch (reg) {\r\ncase SQ_ESGS_RING_SIZE:\r\ncase SQ_GSVS_RING_SIZE:\r\ncase SQ_ESTMP_RING_SIZE:\r\ncase SQ_GSTMP_RING_SIZE:\r\ncase SQ_HSTMP_RING_SIZE:\r\ncase SQ_LSTMP_RING_SIZE:\r\ncase SQ_PSTMP_RING_SIZE:\r\ncase SQ_VSTMP_RING_SIZE:\r\ncase SQ_ESGS_RING_ITEMSIZE:\r\ncase SQ_ESTMP_RING_ITEMSIZE:\r\ncase SQ_GSTMP_RING_ITEMSIZE:\r\ncase SQ_GSVS_RING_ITEMSIZE:\r\ncase SQ_GS_VERT_ITEMSIZE:\r\ncase SQ_GS_VERT_ITEMSIZE_1:\r\ncase SQ_GS_VERT_ITEMSIZE_2:\r\ncase SQ_GS_VERT_ITEMSIZE_3:\r\ncase SQ_GSVS_RING_OFFSET_1:\r\ncase SQ_GSVS_RING_OFFSET_2:\r\ncase SQ_GSVS_RING_OFFSET_3:\r\ncase SQ_HSTMP_RING_ITEMSIZE:\r\ncase SQ_LSTMP_RING_ITEMSIZE:\r\ncase SQ_PSTMP_RING_ITEMSIZE:\r\ncase SQ_VSTMP_RING_ITEMSIZE:\r\ncase VGT_TF_RING_SIZE:\r\nbreak;\r\ncase SQ_ESGS_RING_BASE:\r\ncase SQ_GSVS_RING_BASE:\r\ncase SQ_ESTMP_RING_BASE:\r\ncase SQ_GSTMP_RING_BASE:\r\ncase SQ_HSTMP_RING_BASE:\r\ncase SQ_LSTMP_RING_BASE:\r\ncase SQ_PSTMP_RING_BASE:\r\ncase SQ_VSTMP_RING_BASE:\r\nr = radeon_cs_packet_next_reloc(p, &reloc, 0);\r\nif (r) {\r\ndev_warn(p->dev, "bad SET_CONTEXT_REG "\r\n"0x%04X\n", reg);\r\nreturn -EINVAL;\r\n}\r\nib[idx] += (u32)((reloc->gpu_offset >> 8) & 0xffffffff);\r\nbreak;\r\ncase DB_DEPTH_CONTROL:\r\ntrack->db_depth_control = radeon_get_ib_value(p, idx);\r\ntrack->db_dirty = true;\r\nbreak;\r\ncase CAYMAN_DB_EQAA:\r\nif (p->rdev->family < CHIP_CAYMAN) {\r\ndev_warn(p->dev, "bad SET_CONTEXT_REG "\r\n"0x%04X\n", reg);\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ncase CAYMAN_DB_DEPTH_INFO:\r\nif (p->rdev->family < CHIP_CAYMAN) {\r\ndev_warn(p->dev, "bad SET_CONTEXT_REG "\r\n"0x%04X\n", reg);\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ncase DB_Z_INFO:\r\ntrack->db_z_info = radeon_get_ib_value(p, idx);\r\nif (!(p->cs_flags & RADEON_CS_KEEP_TILING_FLAGS)) {\r\nr = radeon_cs_packet_next_reloc(p, &reloc, 0);\r\nif (r) {\r\ndev_warn(p->dev, "bad SET_CONTEXT_REG "\r\n"0x%04X\n", reg);\r\nreturn -EINVAL;\r\n}\r\nib[idx] &= ~Z_ARRAY_MODE(0xf);\r\ntrack->db_z_info &= ~Z_ARRAY_MODE(0xf);\r\nib[idx] |= Z_ARRAY_MODE(evergreen_cs_get_aray_mode(reloc->tiling_flags));\r\ntrack->db_z_info |= Z_ARRAY_MODE(evergreen_cs_get_aray_mode(reloc->tiling_flags));\r\nif (reloc->tiling_flags & RADEON_TILING_MACRO) {\r\nunsigned bankw, bankh, mtaspect, tile_split;\r\nevergreen_tiling_fields(reloc->tiling_flags,\r\n&bankw, &bankh, &mtaspect,\r\n&tile_split);\r\nib[idx] |= DB_NUM_BANKS(evergreen_cs_get_num_banks(track->nbanks));\r\nib[idx] |= DB_TILE_SPLIT(tile_split) |\r\nDB_BANK_WIDTH(bankw) |\r\nDB_BANK_HEIGHT(bankh) |\r\nDB_MACRO_TILE_ASPECT(mtaspect);\r\n}\r\n}\r\ntrack->db_dirty = true;\r\nbreak;\r\ncase DB_STENCIL_INFO:\r\ntrack->db_s_info = radeon_get_ib_value(p, idx);\r\ntrack->db_dirty = true;\r\nbreak;\r\ncase DB_DEPTH_VIEW:\r\ntrack->db_depth_view = radeon_get_ib_value(p, idx);\r\ntrack->db_dirty = true;\r\nbreak;\r\ncase DB_DEPTH_SIZE:\r\ntrack->db_depth_size = radeon_get_ib_value(p, idx);\r\ntrack->db_dirty = true;\r\nbreak;\r\ncase R_02805C_DB_DEPTH_SLICE:\r\ntrack->db_depth_slice = radeon_get_ib_value(p, idx);\r\ntrack->db_dirty = true;\r\nbreak;\r\ncase DB_Z_READ_BASE:\r\nr = radeon_cs_packet_next_reloc(p, &reloc, 0);\r\nif (r) {\r\ndev_warn(p->dev, "bad SET_CONTEXT_REG "\r\n"0x%04X\n", reg);\r\nreturn -EINVAL;\r\n}\r\ntrack->db_z_read_offset = radeon_get_ib_value(p, idx);\r\nib[idx] += (u32)((reloc->gpu_offset >> 8) & 0xffffffff);\r\ntrack->db_z_read_bo = reloc->robj;\r\ntrack->db_dirty = true;\r\nbreak;\r\ncase DB_Z_WRITE_BASE:\r\nr = radeon_cs_packet_next_reloc(p, &reloc, 0);\r\nif (r) {\r\ndev_warn(p->dev, "bad SET_CONTEXT_REG "\r\n"0x%04X\n", reg);\r\nreturn -EINVAL;\r\n}\r\ntrack->db_z_write_offset = radeon_get_ib_value(p, idx);\r\nib[idx] += (u32)((reloc->gpu_offset >> 8) & 0xffffffff);\r\ntrack->db_z_write_bo = reloc->robj;\r\ntrack->db_dirty = true;\r\nbreak;\r\ncase DB_STENCIL_READ_BASE:\r\nr = radeon_cs_packet_next_reloc(p, &reloc, 0);\r\nif (r) {\r\ndev_warn(p->dev, "bad SET_CONTEXT_REG "\r\n"0x%04X\n", reg);\r\nreturn -EINVAL;\r\n}\r\ntrack->db_s_read_offset = radeon_get_ib_value(p, idx);\r\nib[idx] += (u32)((reloc->gpu_offset >> 8) & 0xffffffff);\r\ntrack->db_s_read_bo = reloc->robj;\r\ntrack->db_dirty = true;\r\nbreak;\r\ncase DB_STENCIL_WRITE_BASE:\r\nr = radeon_cs_packet_next_reloc(p, &reloc, 0);\r\nif (r) {\r\ndev_warn(p->dev, "bad SET_CONTEXT_REG "\r\n"0x%04X\n", reg);\r\nreturn -EINVAL;\r\n}\r\ntrack->db_s_write_offset = radeon_get_ib_value(p, idx);\r\nib[idx] += (u32)((reloc->gpu_offset >> 8) & 0xffffffff);\r\ntrack->db_s_write_bo = reloc->robj;\r\ntrack->db_dirty = true;\r\nbreak;\r\ncase VGT_STRMOUT_CONFIG:\r\ntrack->vgt_strmout_config = radeon_get_ib_value(p, idx);\r\ntrack->streamout_dirty = true;\r\nbreak;\r\ncase VGT_STRMOUT_BUFFER_CONFIG:\r\ntrack->vgt_strmout_buffer_config = radeon_get_ib_value(p, idx);\r\ntrack->streamout_dirty = true;\r\nbreak;\r\ncase VGT_STRMOUT_BUFFER_BASE_0:\r\ncase VGT_STRMOUT_BUFFER_BASE_1:\r\ncase VGT_STRMOUT_BUFFER_BASE_2:\r\ncase VGT_STRMOUT_BUFFER_BASE_3:\r\nr = radeon_cs_packet_next_reloc(p, &reloc, 0);\r\nif (r) {\r\ndev_warn(p->dev, "bad SET_CONTEXT_REG "\r\n"0x%04X\n", reg);\r\nreturn -EINVAL;\r\n}\r\ntmp = (reg - VGT_STRMOUT_BUFFER_BASE_0) / 16;\r\ntrack->vgt_strmout_bo_offset[tmp] = radeon_get_ib_value(p, idx) << 8;\r\nib[idx] += (u32)((reloc->gpu_offset >> 8) & 0xffffffff);\r\ntrack->vgt_strmout_bo[tmp] = reloc->robj;\r\ntrack->streamout_dirty = true;\r\nbreak;\r\ncase VGT_STRMOUT_BUFFER_SIZE_0:\r\ncase VGT_STRMOUT_BUFFER_SIZE_1:\r\ncase VGT_STRMOUT_BUFFER_SIZE_2:\r\ncase VGT_STRMOUT_BUFFER_SIZE_3:\r\ntmp = (reg - VGT_STRMOUT_BUFFER_SIZE_0) / 16;\r\ntrack->vgt_strmout_size[tmp] = radeon_get_ib_value(p, idx) * 4;\r\ntrack->streamout_dirty = true;\r\nbreak;\r\ncase CP_COHER_BASE:\r\nr = radeon_cs_packet_next_reloc(p, &reloc, 0);\r\nif (r) {\r\ndev_warn(p->dev, "missing reloc for CP_COHER_BASE "\r\n"0x%04X\n", reg);\r\nreturn -EINVAL;\r\n}\r\nib[idx] += (u32)((reloc->gpu_offset >> 8) & 0xffffffff);\r\ncase CB_TARGET_MASK:\r\ntrack->cb_target_mask = radeon_get_ib_value(p, idx);\r\ntrack->cb_dirty = true;\r\nbreak;\r\ncase CB_SHADER_MASK:\r\ntrack->cb_shader_mask = radeon_get_ib_value(p, idx);\r\ntrack->cb_dirty = true;\r\nbreak;\r\ncase PA_SC_AA_CONFIG:\r\nif (p->rdev->family >= CHIP_CAYMAN) {\r\ndev_warn(p->dev, "bad SET_CONTEXT_REG "\r\n"0x%04X\n", reg);\r\nreturn -EINVAL;\r\n}\r\ntmp = radeon_get_ib_value(p, idx) & MSAA_NUM_SAMPLES_MASK;\r\ntrack->nsamples = 1 << tmp;\r\nbreak;\r\ncase CAYMAN_PA_SC_AA_CONFIG:\r\nif (p->rdev->family < CHIP_CAYMAN) {\r\ndev_warn(p->dev, "bad SET_CONTEXT_REG "\r\n"0x%04X\n", reg);\r\nreturn -EINVAL;\r\n}\r\ntmp = radeon_get_ib_value(p, idx) & CAYMAN_MSAA_NUM_SAMPLES_MASK;\r\ntrack->nsamples = 1 << tmp;\r\nbreak;\r\ncase CB_COLOR0_VIEW:\r\ncase CB_COLOR1_VIEW:\r\ncase CB_COLOR2_VIEW:\r\ncase CB_COLOR3_VIEW:\r\ncase CB_COLOR4_VIEW:\r\ncase CB_COLOR5_VIEW:\r\ncase CB_COLOR6_VIEW:\r\ncase CB_COLOR7_VIEW:\r\ntmp = (reg - CB_COLOR0_VIEW) / 0x3c;\r\ntrack->cb_color_view[tmp] = radeon_get_ib_value(p, idx);\r\ntrack->cb_dirty = true;\r\nbreak;\r\ncase CB_COLOR8_VIEW:\r\ncase CB_COLOR9_VIEW:\r\ncase CB_COLOR10_VIEW:\r\ncase CB_COLOR11_VIEW:\r\ntmp = ((reg - CB_COLOR8_VIEW) / 0x1c) + 8;\r\ntrack->cb_color_view[tmp] = radeon_get_ib_value(p, idx);\r\ntrack->cb_dirty = true;\r\nbreak;\r\ncase CB_COLOR0_INFO:\r\ncase CB_COLOR1_INFO:\r\ncase CB_COLOR2_INFO:\r\ncase CB_COLOR3_INFO:\r\ncase CB_COLOR4_INFO:\r\ncase CB_COLOR5_INFO:\r\ncase CB_COLOR6_INFO:\r\ncase CB_COLOR7_INFO:\r\ntmp = (reg - CB_COLOR0_INFO) / 0x3c;\r\ntrack->cb_color_info[tmp] = radeon_get_ib_value(p, idx);\r\nif (!(p->cs_flags & RADEON_CS_KEEP_TILING_FLAGS)) {\r\nr = radeon_cs_packet_next_reloc(p, &reloc, 0);\r\nif (r) {\r\ndev_warn(p->dev, "bad SET_CONTEXT_REG "\r\n"0x%04X\n", reg);\r\nreturn -EINVAL;\r\n}\r\nib[idx] |= CB_ARRAY_MODE(evergreen_cs_get_aray_mode(reloc->tiling_flags));\r\ntrack->cb_color_info[tmp] |= CB_ARRAY_MODE(evergreen_cs_get_aray_mode(reloc->tiling_flags));\r\n}\r\ntrack->cb_dirty = true;\r\nbreak;\r\ncase CB_COLOR8_INFO:\r\ncase CB_COLOR9_INFO:\r\ncase CB_COLOR10_INFO:\r\ncase CB_COLOR11_INFO:\r\ntmp = ((reg - CB_COLOR8_INFO) / 0x1c) + 8;\r\ntrack->cb_color_info[tmp] = radeon_get_ib_value(p, idx);\r\nif (!(p->cs_flags & RADEON_CS_KEEP_TILING_FLAGS)) {\r\nr = radeon_cs_packet_next_reloc(p, &reloc, 0);\r\nif (r) {\r\ndev_warn(p->dev, "bad SET_CONTEXT_REG "\r\n"0x%04X\n", reg);\r\nreturn -EINVAL;\r\n}\r\nib[idx] |= CB_ARRAY_MODE(evergreen_cs_get_aray_mode(reloc->tiling_flags));\r\ntrack->cb_color_info[tmp] |= CB_ARRAY_MODE(evergreen_cs_get_aray_mode(reloc->tiling_flags));\r\n}\r\ntrack->cb_dirty = true;\r\nbreak;\r\ncase CB_COLOR0_PITCH:\r\ncase CB_COLOR1_PITCH:\r\ncase CB_COLOR2_PITCH:\r\ncase CB_COLOR3_PITCH:\r\ncase CB_COLOR4_PITCH:\r\ncase CB_COLOR5_PITCH:\r\ncase CB_COLOR6_PITCH:\r\ncase CB_COLOR7_PITCH:\r\ntmp = (reg - CB_COLOR0_PITCH) / 0x3c;\r\ntrack->cb_color_pitch[tmp] = radeon_get_ib_value(p, idx);\r\ntrack->cb_dirty = true;\r\nbreak;\r\ncase CB_COLOR8_PITCH:\r\ncase CB_COLOR9_PITCH:\r\ncase CB_COLOR10_PITCH:\r\ncase CB_COLOR11_PITCH:\r\ntmp = ((reg - CB_COLOR8_PITCH) / 0x1c) + 8;\r\ntrack->cb_color_pitch[tmp] = radeon_get_ib_value(p, idx);\r\ntrack->cb_dirty = true;\r\nbreak;\r\ncase CB_COLOR0_SLICE:\r\ncase CB_COLOR1_SLICE:\r\ncase CB_COLOR2_SLICE:\r\ncase CB_COLOR3_SLICE:\r\ncase CB_COLOR4_SLICE:\r\ncase CB_COLOR5_SLICE:\r\ncase CB_COLOR6_SLICE:\r\ncase CB_COLOR7_SLICE:\r\ntmp = (reg - CB_COLOR0_SLICE) / 0x3c;\r\ntrack->cb_color_slice[tmp] = radeon_get_ib_value(p, idx);\r\ntrack->cb_color_slice_idx[tmp] = idx;\r\ntrack->cb_dirty = true;\r\nbreak;\r\ncase CB_COLOR8_SLICE:\r\ncase CB_COLOR9_SLICE:\r\ncase CB_COLOR10_SLICE:\r\ncase CB_COLOR11_SLICE:\r\ntmp = ((reg - CB_COLOR8_SLICE) / 0x1c) + 8;\r\ntrack->cb_color_slice[tmp] = radeon_get_ib_value(p, idx);\r\ntrack->cb_color_slice_idx[tmp] = idx;\r\ntrack->cb_dirty = true;\r\nbreak;\r\ncase CB_COLOR0_ATTRIB:\r\ncase CB_COLOR1_ATTRIB:\r\ncase CB_COLOR2_ATTRIB:\r\ncase CB_COLOR3_ATTRIB:\r\ncase CB_COLOR4_ATTRIB:\r\ncase CB_COLOR5_ATTRIB:\r\ncase CB_COLOR6_ATTRIB:\r\ncase CB_COLOR7_ATTRIB:\r\nr = radeon_cs_packet_next_reloc(p, &reloc, 0);\r\nif (r) {\r\ndev_warn(p->dev, "bad SET_CONTEXT_REG "\r\n"0x%04X\n", reg);\r\nreturn -EINVAL;\r\n}\r\nif (!(p->cs_flags & RADEON_CS_KEEP_TILING_FLAGS)) {\r\nif (reloc->tiling_flags & RADEON_TILING_MACRO) {\r\nunsigned bankw, bankh, mtaspect, tile_split;\r\nevergreen_tiling_fields(reloc->tiling_flags,\r\n&bankw, &bankh, &mtaspect,\r\n&tile_split);\r\nib[idx] |= CB_NUM_BANKS(evergreen_cs_get_num_banks(track->nbanks));\r\nib[idx] |= CB_TILE_SPLIT(tile_split) |\r\nCB_BANK_WIDTH(bankw) |\r\nCB_BANK_HEIGHT(bankh) |\r\nCB_MACRO_TILE_ASPECT(mtaspect);\r\n}\r\n}\r\ntmp = ((reg - CB_COLOR0_ATTRIB) / 0x3c);\r\ntrack->cb_color_attrib[tmp] = ib[idx];\r\ntrack->cb_dirty = true;\r\nbreak;\r\ncase CB_COLOR8_ATTRIB:\r\ncase CB_COLOR9_ATTRIB:\r\ncase CB_COLOR10_ATTRIB:\r\ncase CB_COLOR11_ATTRIB:\r\nr = radeon_cs_packet_next_reloc(p, &reloc, 0);\r\nif (r) {\r\ndev_warn(p->dev, "bad SET_CONTEXT_REG "\r\n"0x%04X\n", reg);\r\nreturn -EINVAL;\r\n}\r\nif (!(p->cs_flags & RADEON_CS_KEEP_TILING_FLAGS)) {\r\nif (reloc->tiling_flags & RADEON_TILING_MACRO) {\r\nunsigned bankw, bankh, mtaspect, tile_split;\r\nevergreen_tiling_fields(reloc->tiling_flags,\r\n&bankw, &bankh, &mtaspect,\r\n&tile_split);\r\nib[idx] |= CB_NUM_BANKS(evergreen_cs_get_num_banks(track->nbanks));\r\nib[idx] |= CB_TILE_SPLIT(tile_split) |\r\nCB_BANK_WIDTH(bankw) |\r\nCB_BANK_HEIGHT(bankh) |\r\nCB_MACRO_TILE_ASPECT(mtaspect);\r\n}\r\n}\r\ntmp = ((reg - CB_COLOR8_ATTRIB) / 0x1c) + 8;\r\ntrack->cb_color_attrib[tmp] = ib[idx];\r\ntrack->cb_dirty = true;\r\nbreak;\r\ncase CB_COLOR0_FMASK:\r\ncase CB_COLOR1_FMASK:\r\ncase CB_COLOR2_FMASK:\r\ncase CB_COLOR3_FMASK:\r\ncase CB_COLOR4_FMASK:\r\ncase CB_COLOR5_FMASK:\r\ncase CB_COLOR6_FMASK:\r\ncase CB_COLOR7_FMASK:\r\ntmp = (reg - CB_COLOR0_FMASK) / 0x3c;\r\nr = radeon_cs_packet_next_reloc(p, &reloc, 0);\r\nif (r) {\r\ndev_err(p->dev, "bad SET_CONTEXT_REG 0x%04X\n", reg);\r\nreturn -EINVAL;\r\n}\r\nib[idx] += (u32)((reloc->gpu_offset >> 8) & 0xffffffff);\r\ntrack->cb_color_fmask_bo[tmp] = reloc->robj;\r\nbreak;\r\ncase CB_COLOR0_CMASK:\r\ncase CB_COLOR1_CMASK:\r\ncase CB_COLOR2_CMASK:\r\ncase CB_COLOR3_CMASK:\r\ncase CB_COLOR4_CMASK:\r\ncase CB_COLOR5_CMASK:\r\ncase CB_COLOR6_CMASK:\r\ncase CB_COLOR7_CMASK:\r\ntmp = (reg - CB_COLOR0_CMASK) / 0x3c;\r\nr = radeon_cs_packet_next_reloc(p, &reloc, 0);\r\nif (r) {\r\ndev_err(p->dev, "bad SET_CONTEXT_REG 0x%04X\n", reg);\r\nreturn -EINVAL;\r\n}\r\nib[idx] += (u32)((reloc->gpu_offset >> 8) & 0xffffffff);\r\ntrack->cb_color_cmask_bo[tmp] = reloc->robj;\r\nbreak;\r\ncase CB_COLOR0_FMASK_SLICE:\r\ncase CB_COLOR1_FMASK_SLICE:\r\ncase CB_COLOR2_FMASK_SLICE:\r\ncase CB_COLOR3_FMASK_SLICE:\r\ncase CB_COLOR4_FMASK_SLICE:\r\ncase CB_COLOR5_FMASK_SLICE:\r\ncase CB_COLOR6_FMASK_SLICE:\r\ncase CB_COLOR7_FMASK_SLICE:\r\ntmp = (reg - CB_COLOR0_FMASK_SLICE) / 0x3c;\r\ntrack->cb_color_fmask_slice[tmp] = radeon_get_ib_value(p, idx);\r\nbreak;\r\ncase CB_COLOR0_CMASK_SLICE:\r\ncase CB_COLOR1_CMASK_SLICE:\r\ncase CB_COLOR2_CMASK_SLICE:\r\ncase CB_COLOR3_CMASK_SLICE:\r\ncase CB_COLOR4_CMASK_SLICE:\r\ncase CB_COLOR5_CMASK_SLICE:\r\ncase CB_COLOR6_CMASK_SLICE:\r\ncase CB_COLOR7_CMASK_SLICE:\r\ntmp = (reg - CB_COLOR0_CMASK_SLICE) / 0x3c;\r\ntrack->cb_color_cmask_slice[tmp] = radeon_get_ib_value(p, idx);\r\nbreak;\r\ncase CB_COLOR0_BASE:\r\ncase CB_COLOR1_BASE:\r\ncase CB_COLOR2_BASE:\r\ncase CB_COLOR3_BASE:\r\ncase CB_COLOR4_BASE:\r\ncase CB_COLOR5_BASE:\r\ncase CB_COLOR6_BASE:\r\ncase CB_COLOR7_BASE:\r\nr = radeon_cs_packet_next_reloc(p, &reloc, 0);\r\nif (r) {\r\ndev_warn(p->dev, "bad SET_CONTEXT_REG "\r\n"0x%04X\n", reg);\r\nreturn -EINVAL;\r\n}\r\ntmp = (reg - CB_COLOR0_BASE) / 0x3c;\r\ntrack->cb_color_bo_offset[tmp] = radeon_get_ib_value(p, idx);\r\nib[idx] += (u32)((reloc->gpu_offset >> 8) & 0xffffffff);\r\ntrack->cb_color_bo[tmp] = reloc->robj;\r\ntrack->cb_dirty = true;\r\nbreak;\r\ncase CB_COLOR8_BASE:\r\ncase CB_COLOR9_BASE:\r\ncase CB_COLOR10_BASE:\r\ncase CB_COLOR11_BASE:\r\nr = radeon_cs_packet_next_reloc(p, &reloc, 0);\r\nif (r) {\r\ndev_warn(p->dev, "bad SET_CONTEXT_REG "\r\n"0x%04X\n", reg);\r\nreturn -EINVAL;\r\n}\r\ntmp = ((reg - CB_COLOR8_BASE) / 0x1c) + 8;\r\ntrack->cb_color_bo_offset[tmp] = radeon_get_ib_value(p, idx);\r\nib[idx] += (u32)((reloc->gpu_offset >> 8) & 0xffffffff);\r\ntrack->cb_color_bo[tmp] = reloc->robj;\r\ntrack->cb_dirty = true;\r\nbreak;\r\ncase DB_HTILE_DATA_BASE:\r\nr = radeon_cs_packet_next_reloc(p, &reloc, 0);\r\nif (r) {\r\ndev_warn(p->dev, "bad SET_CONTEXT_REG "\r\n"0x%04X\n", reg);\r\nreturn -EINVAL;\r\n}\r\ntrack->htile_offset = radeon_get_ib_value(p, idx);\r\nib[idx] += (u32)((reloc->gpu_offset >> 8) & 0xffffffff);\r\ntrack->htile_bo = reloc->robj;\r\ntrack->db_dirty = true;\r\nbreak;\r\ncase DB_HTILE_SURFACE:\r\ntrack->htile_surface = radeon_get_ib_value(p, idx);\r\nib[idx] |= 3;\r\ntrack->db_dirty = true;\r\nbreak;\r\ncase CB_IMMED0_BASE:\r\ncase CB_IMMED1_BASE:\r\ncase CB_IMMED2_BASE:\r\ncase CB_IMMED3_BASE:\r\ncase CB_IMMED4_BASE:\r\ncase CB_IMMED5_BASE:\r\ncase CB_IMMED6_BASE:\r\ncase CB_IMMED7_BASE:\r\ncase CB_IMMED8_BASE:\r\ncase CB_IMMED9_BASE:\r\ncase CB_IMMED10_BASE:\r\ncase CB_IMMED11_BASE:\r\ncase SQ_PGM_START_FS:\r\ncase SQ_PGM_START_ES:\r\ncase SQ_PGM_START_VS:\r\ncase SQ_PGM_START_GS:\r\ncase SQ_PGM_START_PS:\r\ncase SQ_PGM_START_HS:\r\ncase SQ_PGM_START_LS:\r\ncase SQ_CONST_MEM_BASE:\r\ncase SQ_ALU_CONST_CACHE_GS_0:\r\ncase SQ_ALU_CONST_CACHE_GS_1:\r\ncase SQ_ALU_CONST_CACHE_GS_2:\r\ncase SQ_ALU_CONST_CACHE_GS_3:\r\ncase SQ_ALU_CONST_CACHE_GS_4:\r\ncase SQ_ALU_CONST_CACHE_GS_5:\r\ncase SQ_ALU_CONST_CACHE_GS_6:\r\ncase SQ_ALU_CONST_CACHE_GS_7:\r\ncase SQ_ALU_CONST_CACHE_GS_8:\r\ncase SQ_ALU_CONST_CACHE_GS_9:\r\ncase SQ_ALU_CONST_CACHE_GS_10:\r\ncase SQ_ALU_CONST_CACHE_GS_11:\r\ncase SQ_ALU_CONST_CACHE_GS_12:\r\ncase SQ_ALU_CONST_CACHE_GS_13:\r\ncase SQ_ALU_CONST_CACHE_GS_14:\r\ncase SQ_ALU_CONST_CACHE_GS_15:\r\ncase SQ_ALU_CONST_CACHE_PS_0:\r\ncase SQ_ALU_CONST_CACHE_PS_1:\r\ncase SQ_ALU_CONST_CACHE_PS_2:\r\ncase SQ_ALU_CONST_CACHE_PS_3:\r\ncase SQ_ALU_CONST_CACHE_PS_4:\r\ncase SQ_ALU_CONST_CACHE_PS_5:\r\ncase SQ_ALU_CONST_CACHE_PS_6:\r\ncase SQ_ALU_CONST_CACHE_PS_7:\r\ncase SQ_ALU_CONST_CACHE_PS_8:\r\ncase SQ_ALU_CONST_CACHE_PS_9:\r\ncase SQ_ALU_CONST_CACHE_PS_10:\r\ncase SQ_ALU_CONST_CACHE_PS_11:\r\ncase SQ_ALU_CONST_CACHE_PS_12:\r\ncase SQ_ALU_CONST_CACHE_PS_13:\r\ncase SQ_ALU_CONST_CACHE_PS_14:\r\ncase SQ_ALU_CONST_CACHE_PS_15:\r\ncase SQ_ALU_CONST_CACHE_VS_0:\r\ncase SQ_ALU_CONST_CACHE_VS_1:\r\ncase SQ_ALU_CONST_CACHE_VS_2:\r\ncase SQ_ALU_CONST_CACHE_VS_3:\r\ncase SQ_ALU_CONST_CACHE_VS_4:\r\ncase SQ_ALU_CONST_CACHE_VS_5:\r\ncase SQ_ALU_CONST_CACHE_VS_6:\r\ncase SQ_ALU_CONST_CACHE_VS_7:\r\ncase SQ_ALU_CONST_CACHE_VS_8:\r\ncase SQ_ALU_CONST_CACHE_VS_9:\r\ncase SQ_ALU_CONST_CACHE_VS_10:\r\ncase SQ_ALU_CONST_CACHE_VS_11:\r\ncase SQ_ALU_CONST_CACHE_VS_12:\r\ncase SQ_ALU_CONST_CACHE_VS_13:\r\ncase SQ_ALU_CONST_CACHE_VS_14:\r\ncase SQ_ALU_CONST_CACHE_VS_15:\r\ncase SQ_ALU_CONST_CACHE_HS_0:\r\ncase SQ_ALU_CONST_CACHE_HS_1:\r\ncase SQ_ALU_CONST_CACHE_HS_2:\r\ncase SQ_ALU_CONST_CACHE_HS_3:\r\ncase SQ_ALU_CONST_CACHE_HS_4:\r\ncase SQ_ALU_CONST_CACHE_HS_5:\r\ncase SQ_ALU_CONST_CACHE_HS_6:\r\ncase SQ_ALU_CONST_CACHE_HS_7:\r\ncase SQ_ALU_CONST_CACHE_HS_8:\r\ncase SQ_ALU_CONST_CACHE_HS_9:\r\ncase SQ_ALU_CONST_CACHE_HS_10:\r\ncase SQ_ALU_CONST_CACHE_HS_11:\r\ncase SQ_ALU_CONST_CACHE_HS_12:\r\ncase SQ_ALU_CONST_CACHE_HS_13:\r\ncase SQ_ALU_CONST_CACHE_HS_14:\r\ncase SQ_ALU_CONST_CACHE_HS_15:\r\ncase SQ_ALU_CONST_CACHE_LS_0:\r\ncase SQ_ALU_CONST_CACHE_LS_1:\r\ncase SQ_ALU_CONST_CACHE_LS_2:\r\ncase SQ_ALU_CONST_CACHE_LS_3:\r\ncase SQ_ALU_CONST_CACHE_LS_4:\r\ncase SQ_ALU_CONST_CACHE_LS_5:\r\ncase SQ_ALU_CONST_CACHE_LS_6:\r\ncase SQ_ALU_CONST_CACHE_LS_7:\r\ncase SQ_ALU_CONST_CACHE_LS_8:\r\ncase SQ_ALU_CONST_CACHE_LS_9:\r\ncase SQ_ALU_CONST_CACHE_LS_10:\r\ncase SQ_ALU_CONST_CACHE_LS_11:\r\ncase SQ_ALU_CONST_CACHE_LS_12:\r\ncase SQ_ALU_CONST_CACHE_LS_13:\r\ncase SQ_ALU_CONST_CACHE_LS_14:\r\ncase SQ_ALU_CONST_CACHE_LS_15:\r\nr = radeon_cs_packet_next_reloc(p, &reloc, 0);\r\nif (r) {\r\ndev_warn(p->dev, "bad SET_CONTEXT_REG "\r\n"0x%04X\n", reg);\r\nreturn -EINVAL;\r\n}\r\nib[idx] += (u32)((reloc->gpu_offset >> 8) & 0xffffffff);\r\nbreak;\r\ncase SX_MEMORY_EXPORT_BASE:\r\nif (p->rdev->family >= CHIP_CAYMAN) {\r\ndev_warn(p->dev, "bad SET_CONFIG_REG "\r\n"0x%04X\n", reg);\r\nreturn -EINVAL;\r\n}\r\nr = radeon_cs_packet_next_reloc(p, &reloc, 0);\r\nif (r) {\r\ndev_warn(p->dev, "bad SET_CONFIG_REG "\r\n"0x%04X\n", reg);\r\nreturn -EINVAL;\r\n}\r\nib[idx] += (u32)((reloc->gpu_offset >> 8) & 0xffffffff);\r\nbreak;\r\ncase CAYMAN_SX_SCATTER_EXPORT_BASE:\r\nif (p->rdev->family < CHIP_CAYMAN) {\r\ndev_warn(p->dev, "bad SET_CONTEXT_REG "\r\n"0x%04X\n", reg);\r\nreturn -EINVAL;\r\n}\r\nr = radeon_cs_packet_next_reloc(p, &reloc, 0);\r\nif (r) {\r\ndev_warn(p->dev, "bad SET_CONTEXT_REG "\r\n"0x%04X\n", reg);\r\nreturn -EINVAL;\r\n}\r\nib[idx] += (u32)((reloc->gpu_offset >> 8) & 0xffffffff);\r\nbreak;\r\ncase SX_MISC:\r\ntrack->sx_misc_kill_all_prims = (radeon_get_ib_value(p, idx) & 0x1) != 0;\r\nbreak;\r\ndefault:\r\ndev_warn(p->dev, "forbidden register 0x%08x at %d\n", reg, idx);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic bool evergreen_is_safe_reg(struct radeon_cs_parser *p, u32 reg, u32 idx)\r\n{\r\nu32 last_reg, m, i;\r\nif (p->rdev->family >= CHIP_CAYMAN)\r\nlast_reg = ARRAY_SIZE(cayman_reg_safe_bm);\r\nelse\r\nlast_reg = ARRAY_SIZE(evergreen_reg_safe_bm);\r\ni = (reg >> 7);\r\nif (i >= last_reg) {\r\ndev_warn(p->dev, "forbidden register 0x%08x at %d\n", reg, idx);\r\nreturn false;\r\n}\r\nm = 1 << ((reg >> 2) & 31);\r\nif (p->rdev->family >= CHIP_CAYMAN) {\r\nif (!(cayman_reg_safe_bm[i] & m))\r\nreturn true;\r\n} else {\r\nif (!(evergreen_reg_safe_bm[i] & m))\r\nreturn true;\r\n}\r\ndev_warn(p->dev, "forbidden register 0x%08x at %d\n", reg, idx);\r\nreturn false;\r\n}\r\nstatic int evergreen_packet3_check(struct radeon_cs_parser *p,\r\nstruct radeon_cs_packet *pkt)\r\n{\r\nstruct radeon_bo_list *reloc;\r\nstruct evergreen_cs_track *track;\r\nvolatile u32 *ib;\r\nunsigned idx;\r\nunsigned i;\r\nunsigned start_reg, end_reg, reg;\r\nint r;\r\nu32 idx_value;\r\ntrack = (struct evergreen_cs_track *)p->track;\r\nib = p->ib.ptr;\r\nidx = pkt->idx + 1;\r\nidx_value = radeon_get_ib_value(p, idx);\r\nswitch (pkt->opcode) {\r\ncase PACKET3_SET_PREDICATION:\r\n{\r\nint pred_op;\r\nint tmp;\r\nuint64_t offset;\r\nif (pkt->count != 1) {\r\nDRM_ERROR("bad SET PREDICATION\n");\r\nreturn -EINVAL;\r\n}\r\ntmp = radeon_get_ib_value(p, idx + 1);\r\npred_op = (tmp >> 16) & 0x7;\r\nif (pred_op == 0)\r\nreturn 0;\r\nif (pred_op > 2) {\r\nDRM_ERROR("bad SET PREDICATION operation %d\n", pred_op);\r\nreturn -EINVAL;\r\n}\r\nr = radeon_cs_packet_next_reloc(p, &reloc, 0);\r\nif (r) {\r\nDRM_ERROR("bad SET PREDICATION\n");\r\nreturn -EINVAL;\r\n}\r\noffset = reloc->gpu_offset +\r\n(idx_value & 0xfffffff0) +\r\n((u64)(tmp & 0xff) << 32);\r\nib[idx + 0] = offset;\r\nib[idx + 1] = (tmp & 0xffffff00) | (upper_32_bits(offset) & 0xff);\r\n}\r\nbreak;\r\ncase PACKET3_CONTEXT_CONTROL:\r\nif (pkt->count != 1) {\r\nDRM_ERROR("bad CONTEXT_CONTROL\n");\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ncase PACKET3_INDEX_TYPE:\r\ncase PACKET3_NUM_INSTANCES:\r\ncase PACKET3_CLEAR_STATE:\r\nif (pkt->count) {\r\nDRM_ERROR("bad INDEX_TYPE/NUM_INSTANCES/CLEAR_STATE\n");\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ncase CAYMAN_PACKET3_DEALLOC_STATE:\r\nif (p->rdev->family < CHIP_CAYMAN) {\r\nDRM_ERROR("bad PACKET3_DEALLOC_STATE\n");\r\nreturn -EINVAL;\r\n}\r\nif (pkt->count) {\r\nDRM_ERROR("bad INDEX_TYPE/NUM_INSTANCES/CLEAR_STATE\n");\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ncase PACKET3_INDEX_BASE:\r\n{\r\nuint64_t offset;\r\nif (pkt->count != 1) {\r\nDRM_ERROR("bad INDEX_BASE\n");\r\nreturn -EINVAL;\r\n}\r\nr = radeon_cs_packet_next_reloc(p, &reloc, 0);\r\nif (r) {\r\nDRM_ERROR("bad INDEX_BASE\n");\r\nreturn -EINVAL;\r\n}\r\noffset = reloc->gpu_offset +\r\nidx_value +\r\n((u64)(radeon_get_ib_value(p, idx+1) & 0xff) << 32);\r\nib[idx+0] = offset;\r\nib[idx+1] = upper_32_bits(offset) & 0xff;\r\nr = evergreen_cs_track_check(p);\r\nif (r) {\r\ndev_warn(p->dev, "%s:%d invalid cmd stream\n", __func__, __LINE__);\r\nreturn r;\r\n}\r\nbreak;\r\n}\r\ncase PACKET3_INDEX_BUFFER_SIZE:\r\n{\r\nif (pkt->count != 0) {\r\nDRM_ERROR("bad INDEX_BUFFER_SIZE\n");\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\n}\r\ncase PACKET3_DRAW_INDEX:\r\n{\r\nuint64_t offset;\r\nif (pkt->count != 3) {\r\nDRM_ERROR("bad DRAW_INDEX\n");\r\nreturn -EINVAL;\r\n}\r\nr = radeon_cs_packet_next_reloc(p, &reloc, 0);\r\nif (r) {\r\nDRM_ERROR("bad DRAW_INDEX\n");\r\nreturn -EINVAL;\r\n}\r\noffset = reloc->gpu_offset +\r\nidx_value +\r\n((u64)(radeon_get_ib_value(p, idx+1) & 0xff) << 32);\r\nib[idx+0] = offset;\r\nib[idx+1] = upper_32_bits(offset) & 0xff;\r\nr = evergreen_cs_track_check(p);\r\nif (r) {\r\ndev_warn(p->dev, "%s:%d invalid cmd stream\n", __func__, __LINE__);\r\nreturn r;\r\n}\r\nbreak;\r\n}\r\ncase PACKET3_DRAW_INDEX_2:\r\n{\r\nuint64_t offset;\r\nif (pkt->count != 4) {\r\nDRM_ERROR("bad DRAW_INDEX_2\n");\r\nreturn -EINVAL;\r\n}\r\nr = radeon_cs_packet_next_reloc(p, &reloc, 0);\r\nif (r) {\r\nDRM_ERROR("bad DRAW_INDEX_2\n");\r\nreturn -EINVAL;\r\n}\r\noffset = reloc->gpu_offset +\r\nradeon_get_ib_value(p, idx+1) +\r\n((u64)(radeon_get_ib_value(p, idx+2) & 0xff) << 32);\r\nib[idx+1] = offset;\r\nib[idx+2] = upper_32_bits(offset) & 0xff;\r\nr = evergreen_cs_track_check(p);\r\nif (r) {\r\ndev_warn(p->dev, "%s:%d invalid cmd stream\n", __func__, __LINE__);\r\nreturn r;\r\n}\r\nbreak;\r\n}\r\ncase PACKET3_DRAW_INDEX_AUTO:\r\nif (pkt->count != 1) {\r\nDRM_ERROR("bad DRAW_INDEX_AUTO\n");\r\nreturn -EINVAL;\r\n}\r\nr = evergreen_cs_track_check(p);\r\nif (r) {\r\ndev_warn(p->dev, "%s:%d invalid cmd stream %d\n", __func__, __LINE__, idx);\r\nreturn r;\r\n}\r\nbreak;\r\ncase PACKET3_DRAW_INDEX_MULTI_AUTO:\r\nif (pkt->count != 2) {\r\nDRM_ERROR("bad DRAW_INDEX_MULTI_AUTO\n");\r\nreturn -EINVAL;\r\n}\r\nr = evergreen_cs_track_check(p);\r\nif (r) {\r\ndev_warn(p->dev, "%s:%d invalid cmd stream %d\n", __func__, __LINE__, idx);\r\nreturn r;\r\n}\r\nbreak;\r\ncase PACKET3_DRAW_INDEX_IMMD:\r\nif (pkt->count < 2) {\r\nDRM_ERROR("bad DRAW_INDEX_IMMD\n");\r\nreturn -EINVAL;\r\n}\r\nr = evergreen_cs_track_check(p);\r\nif (r) {\r\ndev_warn(p->dev, "%s:%d invalid cmd stream\n", __func__, __LINE__);\r\nreturn r;\r\n}\r\nbreak;\r\ncase PACKET3_DRAW_INDEX_OFFSET:\r\nif (pkt->count != 2) {\r\nDRM_ERROR("bad DRAW_INDEX_OFFSET\n");\r\nreturn -EINVAL;\r\n}\r\nr = evergreen_cs_track_check(p);\r\nif (r) {\r\ndev_warn(p->dev, "%s:%d invalid cmd stream\n", __func__, __LINE__);\r\nreturn r;\r\n}\r\nbreak;\r\ncase PACKET3_DRAW_INDEX_OFFSET_2:\r\nif (pkt->count != 3) {\r\nDRM_ERROR("bad DRAW_INDEX_OFFSET_2\n");\r\nreturn -EINVAL;\r\n}\r\nr = evergreen_cs_track_check(p);\r\nif (r) {\r\ndev_warn(p->dev, "%s:%d invalid cmd stream\n", __func__, __LINE__);\r\nreturn r;\r\n}\r\nbreak;\r\ncase PACKET3_SET_BASE:\r\n{\r\nif (pkt->count != 2) {\r\nDRM_ERROR("bad SET_BASE\n");\r\nreturn -EINVAL;\r\n}\r\nif (idx_value != 1) {\r\nDRM_ERROR("bad SET_BASE\n");\r\nreturn -EINVAL;\r\n}\r\nr = radeon_cs_packet_next_reloc(p, &reloc, 0);\r\nif (r) {\r\nDRM_ERROR("bad SET_BASE\n");\r\nreturn -EINVAL;\r\n}\r\ntrack->indirect_draw_buffer_size = radeon_bo_size(reloc->robj);\r\nib[idx+1] = reloc->gpu_offset;\r\nib[idx+2] = upper_32_bits(reloc->gpu_offset) & 0xff;\r\nbreak;\r\n}\r\ncase PACKET3_DRAW_INDIRECT:\r\ncase PACKET3_DRAW_INDEX_INDIRECT:\r\n{\r\nu64 size = pkt->opcode == PACKET3_DRAW_INDIRECT ? 16 : 20;\r\nif (pkt->count != 1) {\r\nDRM_ERROR("bad DRAW_INDIRECT\n");\r\nreturn -EINVAL;\r\n}\r\nif (idx_value + size > track->indirect_draw_buffer_size) {\r\ndev_warn(p->dev, "DRAW_INDIRECT buffer too small %u + %llu > %lu\n",\r\nidx_value, size, track->indirect_draw_buffer_size);\r\nreturn -EINVAL;\r\n}\r\nr = evergreen_cs_track_check(p);\r\nif (r) {\r\ndev_warn(p->dev, "%s:%d invalid cmd stream\n", __func__, __LINE__);\r\nreturn r;\r\n}\r\nbreak;\r\n}\r\ncase PACKET3_DISPATCH_DIRECT:\r\nif (pkt->count != 3) {\r\nDRM_ERROR("bad DISPATCH_DIRECT\n");\r\nreturn -EINVAL;\r\n}\r\nr = evergreen_cs_track_check(p);\r\nif (r) {\r\ndev_warn(p->dev, "%s:%d invalid cmd stream %d\n", __func__, __LINE__, idx);\r\nreturn r;\r\n}\r\nbreak;\r\ncase PACKET3_DISPATCH_INDIRECT:\r\nif (pkt->count != 1) {\r\nDRM_ERROR("bad DISPATCH_INDIRECT\n");\r\nreturn -EINVAL;\r\n}\r\nr = radeon_cs_packet_next_reloc(p, &reloc, 0);\r\nif (r) {\r\nDRM_ERROR("bad DISPATCH_INDIRECT\n");\r\nreturn -EINVAL;\r\n}\r\nib[idx+0] = idx_value + (u32)(reloc->gpu_offset & 0xffffffff);\r\nr = evergreen_cs_track_check(p);\r\nif (r) {\r\ndev_warn(p->dev, "%s:%d invalid cmd stream\n", __func__, __LINE__);\r\nreturn r;\r\n}\r\nbreak;\r\ncase PACKET3_WAIT_REG_MEM:\r\nif (pkt->count != 5) {\r\nDRM_ERROR("bad WAIT_REG_MEM\n");\r\nreturn -EINVAL;\r\n}\r\nif (idx_value & 0x10) {\r\nuint64_t offset;\r\nr = radeon_cs_packet_next_reloc(p, &reloc, 0);\r\nif (r) {\r\nDRM_ERROR("bad WAIT_REG_MEM\n");\r\nreturn -EINVAL;\r\n}\r\noffset = reloc->gpu_offset +\r\n(radeon_get_ib_value(p, idx+1) & 0xfffffffc) +\r\n((u64)(radeon_get_ib_value(p, idx+2) & 0xff) << 32);\r\nib[idx+1] = (ib[idx+1] & 0x3) | (offset & 0xfffffffc);\r\nib[idx+2] = upper_32_bits(offset) & 0xff;\r\n} else if (idx_value & 0x100) {\r\nDRM_ERROR("cannot use PFP on REG wait\n");\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ncase PACKET3_CP_DMA:\r\n{\r\nu32 command, size, info;\r\nu64 offset, tmp;\r\nif (pkt->count != 4) {\r\nDRM_ERROR("bad CP DMA\n");\r\nreturn -EINVAL;\r\n}\r\ncommand = radeon_get_ib_value(p, idx+4);\r\nsize = command & 0x1fffff;\r\ninfo = radeon_get_ib_value(p, idx+1);\r\nif ((((info & 0x60000000) >> 29) != 0) ||\r\n(((info & 0x00300000) >> 20) != 0) ||\r\n((((info & 0x00300000) >> 20) == 0) &&\r\n(command & PACKET3_CP_DMA_CMD_DAS)) ||\r\n((((info & 0x60000000) >> 29) == 0) &&\r\n(command & PACKET3_CP_DMA_CMD_SAS))) {\r\nif (size % 4) {\r\nDRM_ERROR("CP DMA command requires dw count alignment\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\nif (command & PACKET3_CP_DMA_CMD_SAS) {\r\nif (((info & 0x60000000) >> 29) != 1) {\r\nDRM_ERROR("CP DMA SAS not supported\n");\r\nreturn -EINVAL;\r\n}\r\n} else {\r\nif (command & PACKET3_CP_DMA_CMD_SAIC) {\r\nDRM_ERROR("CP DMA SAIC only supported for registers\n");\r\nreturn -EINVAL;\r\n}\r\nif (((info & 0x60000000) >> 29) == 0) {\r\nr = radeon_cs_packet_next_reloc(p, &reloc, 0);\r\nif (r) {\r\nDRM_ERROR("bad CP DMA SRC\n");\r\nreturn -EINVAL;\r\n}\r\ntmp = radeon_get_ib_value(p, idx) +\r\n((u64)(radeon_get_ib_value(p, idx+1) & 0xff) << 32);\r\noffset = reloc->gpu_offset + tmp;\r\nif ((tmp + size) > radeon_bo_size(reloc->robj)) {\r\ndev_warn(p->dev, "CP DMA src buffer too small (%llu %lu)\n",\r\ntmp + size, radeon_bo_size(reloc->robj));\r\nreturn -EINVAL;\r\n}\r\nib[idx] = offset;\r\nib[idx+1] = (ib[idx+1] & 0xffffff00) | (upper_32_bits(offset) & 0xff);\r\n} else if (((info & 0x60000000) >> 29) != 2) {\r\nDRM_ERROR("bad CP DMA SRC_SEL\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\nif (command & PACKET3_CP_DMA_CMD_DAS) {\r\nif (((info & 0x00300000) >> 20) != 1) {\r\nDRM_ERROR("CP DMA DAS not supported\n");\r\nreturn -EINVAL;\r\n}\r\n} else {\r\nif (command & PACKET3_CP_DMA_CMD_DAIC) {\r\nDRM_ERROR("CP DMA DAIC only supported for registers\n");\r\nreturn -EINVAL;\r\n}\r\nif (((info & 0x00300000) >> 20) == 0) {\r\nr = radeon_cs_packet_next_reloc(p, &reloc, 0);\r\nif (r) {\r\nDRM_ERROR("bad CP DMA DST\n");\r\nreturn -EINVAL;\r\n}\r\ntmp = radeon_get_ib_value(p, idx+2) +\r\n((u64)(radeon_get_ib_value(p, idx+3) & 0xff) << 32);\r\noffset = reloc->gpu_offset + tmp;\r\nif ((tmp + size) > radeon_bo_size(reloc->robj)) {\r\ndev_warn(p->dev, "CP DMA dst buffer too small (%llu %lu)\n",\r\ntmp + size, radeon_bo_size(reloc->robj));\r\nreturn -EINVAL;\r\n}\r\nib[idx+2] = offset;\r\nib[idx+3] = upper_32_bits(offset) & 0xff;\r\n} else {\r\nDRM_ERROR("bad CP DMA DST_SEL\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\nbreak;\r\n}\r\ncase PACKET3_SURFACE_SYNC:\r\nif (pkt->count != 3) {\r\nDRM_ERROR("bad SURFACE_SYNC\n");\r\nreturn -EINVAL;\r\n}\r\nif (radeon_get_ib_value(p, idx + 1) != 0xffffffff ||\r\nradeon_get_ib_value(p, idx + 2) != 0) {\r\nr = radeon_cs_packet_next_reloc(p, &reloc, 0);\r\nif (r) {\r\nDRM_ERROR("bad SURFACE_SYNC\n");\r\nreturn -EINVAL;\r\n}\r\nib[idx+2] += (u32)((reloc->gpu_offset >> 8) & 0xffffffff);\r\n}\r\nbreak;\r\ncase PACKET3_EVENT_WRITE:\r\nif (pkt->count != 2 && pkt->count != 0) {\r\nDRM_ERROR("bad EVENT_WRITE\n");\r\nreturn -EINVAL;\r\n}\r\nif (pkt->count) {\r\nuint64_t offset;\r\nr = radeon_cs_packet_next_reloc(p, &reloc, 0);\r\nif (r) {\r\nDRM_ERROR("bad EVENT_WRITE\n");\r\nreturn -EINVAL;\r\n}\r\noffset = reloc->gpu_offset +\r\n(radeon_get_ib_value(p, idx+1) & 0xfffffff8) +\r\n((u64)(radeon_get_ib_value(p, idx+2) & 0xff) << 32);\r\nib[idx+1] = offset & 0xfffffff8;\r\nib[idx+2] = upper_32_bits(offset) & 0xff;\r\n}\r\nbreak;\r\ncase PACKET3_EVENT_WRITE_EOP:\r\n{\r\nuint64_t offset;\r\nif (pkt->count != 4) {\r\nDRM_ERROR("bad EVENT_WRITE_EOP\n");\r\nreturn -EINVAL;\r\n}\r\nr = radeon_cs_packet_next_reloc(p, &reloc, 0);\r\nif (r) {\r\nDRM_ERROR("bad EVENT_WRITE_EOP\n");\r\nreturn -EINVAL;\r\n}\r\noffset = reloc->gpu_offset +\r\n(radeon_get_ib_value(p, idx+1) & 0xfffffffc) +\r\n((u64)(radeon_get_ib_value(p, idx+2) & 0xff) << 32);\r\nib[idx+1] = offset & 0xfffffffc;\r\nib[idx+2] = (ib[idx+2] & 0xffffff00) | (upper_32_bits(offset) & 0xff);\r\nbreak;\r\n}\r\ncase PACKET3_EVENT_WRITE_EOS:\r\n{\r\nuint64_t offset;\r\nif (pkt->count != 3) {\r\nDRM_ERROR("bad EVENT_WRITE_EOS\n");\r\nreturn -EINVAL;\r\n}\r\nr = radeon_cs_packet_next_reloc(p, &reloc, 0);\r\nif (r) {\r\nDRM_ERROR("bad EVENT_WRITE_EOS\n");\r\nreturn -EINVAL;\r\n}\r\noffset = reloc->gpu_offset +\r\n(radeon_get_ib_value(p, idx+1) & 0xfffffffc) +\r\n((u64)(radeon_get_ib_value(p, idx+2) & 0xff) << 32);\r\nib[idx+1] = offset & 0xfffffffc;\r\nib[idx+2] = (ib[idx+2] & 0xffffff00) | (upper_32_bits(offset) & 0xff);\r\nbreak;\r\n}\r\ncase PACKET3_SET_CONFIG_REG:\r\nstart_reg = (idx_value << 2) + PACKET3_SET_CONFIG_REG_START;\r\nend_reg = 4 * pkt->count + start_reg - 4;\r\nif ((start_reg < PACKET3_SET_CONFIG_REG_START) ||\r\n(start_reg >= PACKET3_SET_CONFIG_REG_END) ||\r\n(end_reg >= PACKET3_SET_CONFIG_REG_END)) {\r\nDRM_ERROR("bad PACKET3_SET_CONFIG_REG\n");\r\nreturn -EINVAL;\r\n}\r\nfor (i = 0; i < pkt->count; i++) {\r\nreg = start_reg + (4 * i);\r\nr = evergreen_cs_check_reg(p, reg, idx+1+i);\r\nif (r)\r\nreturn r;\r\n}\r\nbreak;\r\ncase PACKET3_SET_CONTEXT_REG:\r\nstart_reg = (idx_value << 2) + PACKET3_SET_CONTEXT_REG_START;\r\nend_reg = 4 * pkt->count + start_reg - 4;\r\nif ((start_reg < PACKET3_SET_CONTEXT_REG_START) ||\r\n(start_reg >= PACKET3_SET_CONTEXT_REG_END) ||\r\n(end_reg >= PACKET3_SET_CONTEXT_REG_END)) {\r\nDRM_ERROR("bad PACKET3_SET_CONTEXT_REG\n");\r\nreturn -EINVAL;\r\n}\r\nfor (i = 0; i < pkt->count; i++) {\r\nreg = start_reg + (4 * i);\r\nr = evergreen_cs_check_reg(p, reg, idx+1+i);\r\nif (r)\r\nreturn r;\r\n}\r\nbreak;\r\ncase PACKET3_SET_RESOURCE:\r\nif (pkt->count % 8) {\r\nDRM_ERROR("bad SET_RESOURCE\n");\r\nreturn -EINVAL;\r\n}\r\nstart_reg = (idx_value << 2) + PACKET3_SET_RESOURCE_START;\r\nend_reg = 4 * pkt->count + start_reg - 4;\r\nif ((start_reg < PACKET3_SET_RESOURCE_START) ||\r\n(start_reg >= PACKET3_SET_RESOURCE_END) ||\r\n(end_reg >= PACKET3_SET_RESOURCE_END)) {\r\nDRM_ERROR("bad SET_RESOURCE\n");\r\nreturn -EINVAL;\r\n}\r\nfor (i = 0; i < (pkt->count / 8); i++) {\r\nstruct radeon_bo *texture, *mipmap;\r\nu32 toffset, moffset;\r\nu32 size, offset, mip_address, tex_dim;\r\nswitch (G__SQ_CONSTANT_TYPE(radeon_get_ib_value(p, idx+1+(i*8)+7))) {\r\ncase SQ_TEX_VTX_VALID_TEXTURE:\r\nr = radeon_cs_packet_next_reloc(p, &reloc, 0);\r\nif (r) {\r\nDRM_ERROR("bad SET_RESOURCE (tex)\n");\r\nreturn -EINVAL;\r\n}\r\nif (!(p->cs_flags & RADEON_CS_KEEP_TILING_FLAGS)) {\r\nib[idx+1+(i*8)+1] |=\r\nTEX_ARRAY_MODE(evergreen_cs_get_aray_mode(reloc->tiling_flags));\r\nif (reloc->tiling_flags & RADEON_TILING_MACRO) {\r\nunsigned bankw, bankh, mtaspect, tile_split;\r\nevergreen_tiling_fields(reloc->tiling_flags,\r\n&bankw, &bankh, &mtaspect,\r\n&tile_split);\r\nib[idx+1+(i*8)+6] |= TEX_TILE_SPLIT(tile_split);\r\nib[idx+1+(i*8)+7] |=\r\nTEX_BANK_WIDTH(bankw) |\r\nTEX_BANK_HEIGHT(bankh) |\r\nMACRO_TILE_ASPECT(mtaspect) |\r\nTEX_NUM_BANKS(evergreen_cs_get_num_banks(track->nbanks));\r\n}\r\n}\r\ntexture = reloc->robj;\r\ntoffset = (u32)((reloc->gpu_offset >> 8) & 0xffffffff);\r\ntex_dim = ib[idx+1+(i*8)+0] & 0x7;\r\nmip_address = ib[idx+1+(i*8)+3];\r\nif ((tex_dim == SQ_TEX_DIM_2D_MSAA || tex_dim == SQ_TEX_DIM_2D_ARRAY_MSAA) &&\r\n!mip_address &&\r\n!radeon_cs_packet_next_is_pkt3_nop(p)) {\r\nmoffset = 0;\r\nmipmap = NULL;\r\n} else {\r\nr = radeon_cs_packet_next_reloc(p, &reloc, 0);\r\nif (r) {\r\nDRM_ERROR("bad SET_RESOURCE (tex)\n");\r\nreturn -EINVAL;\r\n}\r\nmoffset = (u32)((reloc->gpu_offset >> 8) & 0xffffffff);\r\nmipmap = reloc->robj;\r\n}\r\nr = evergreen_cs_track_validate_texture(p, texture, mipmap, idx+1+(i*8));\r\nif (r)\r\nreturn r;\r\nib[idx+1+(i*8)+2] += toffset;\r\nib[idx+1+(i*8)+3] += moffset;\r\nbreak;\r\ncase SQ_TEX_VTX_VALID_BUFFER:\r\n{\r\nuint64_t offset64;\r\nr = radeon_cs_packet_next_reloc(p, &reloc, 0);\r\nif (r) {\r\nDRM_ERROR("bad SET_RESOURCE (vtx)\n");\r\nreturn -EINVAL;\r\n}\r\noffset = radeon_get_ib_value(p, idx+1+(i*8)+0);\r\nsize = radeon_get_ib_value(p, idx+1+(i*8)+1);\r\nif (p->rdev && (size + offset) > radeon_bo_size(reloc->robj)) {\r\ndev_warn(p->dev, "vbo resource seems too big for the bo\n");\r\nib[idx+1+(i*8)+1] = radeon_bo_size(reloc->robj) - offset;\r\n}\r\noffset64 = reloc->gpu_offset + offset;\r\nib[idx+1+(i*8)+0] = offset64;\r\nib[idx+1+(i*8)+2] = (ib[idx+1+(i*8)+2] & 0xffffff00) |\r\n(upper_32_bits(offset64) & 0xff);\r\nbreak;\r\n}\r\ncase SQ_TEX_VTX_INVALID_TEXTURE:\r\ncase SQ_TEX_VTX_INVALID_BUFFER:\r\ndefault:\r\nDRM_ERROR("bad SET_RESOURCE\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\nbreak;\r\ncase PACKET3_SET_ALU_CONST:\r\nbreak;\r\ncase PACKET3_SET_BOOL_CONST:\r\nstart_reg = (idx_value << 2) + PACKET3_SET_BOOL_CONST_START;\r\nend_reg = 4 * pkt->count + start_reg - 4;\r\nif ((start_reg < PACKET3_SET_BOOL_CONST_START) ||\r\n(start_reg >= PACKET3_SET_BOOL_CONST_END) ||\r\n(end_reg >= PACKET3_SET_BOOL_CONST_END)) {\r\nDRM_ERROR("bad SET_BOOL_CONST\n");\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ncase PACKET3_SET_LOOP_CONST:\r\nstart_reg = (idx_value << 2) + PACKET3_SET_LOOP_CONST_START;\r\nend_reg = 4 * pkt->count + start_reg - 4;\r\nif ((start_reg < PACKET3_SET_LOOP_CONST_START) ||\r\n(start_reg >= PACKET3_SET_LOOP_CONST_END) ||\r\n(end_reg >= PACKET3_SET_LOOP_CONST_END)) {\r\nDRM_ERROR("bad SET_LOOP_CONST\n");\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ncase PACKET3_SET_CTL_CONST:\r\nstart_reg = (idx_value << 2) + PACKET3_SET_CTL_CONST_START;\r\nend_reg = 4 * pkt->count + start_reg - 4;\r\nif ((start_reg < PACKET3_SET_CTL_CONST_START) ||\r\n(start_reg >= PACKET3_SET_CTL_CONST_END) ||\r\n(end_reg >= PACKET3_SET_CTL_CONST_END)) {\r\nDRM_ERROR("bad SET_CTL_CONST\n");\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ncase PACKET3_SET_SAMPLER:\r\nif (pkt->count % 3) {\r\nDRM_ERROR("bad SET_SAMPLER\n");\r\nreturn -EINVAL;\r\n}\r\nstart_reg = (idx_value << 2) + PACKET3_SET_SAMPLER_START;\r\nend_reg = 4 * pkt->count + start_reg - 4;\r\nif ((start_reg < PACKET3_SET_SAMPLER_START) ||\r\n(start_reg >= PACKET3_SET_SAMPLER_END) ||\r\n(end_reg >= PACKET3_SET_SAMPLER_END)) {\r\nDRM_ERROR("bad SET_SAMPLER\n");\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ncase PACKET3_STRMOUT_BUFFER_UPDATE:\r\nif (pkt->count != 4) {\r\nDRM_ERROR("bad STRMOUT_BUFFER_UPDATE (invalid count)\n");\r\nreturn -EINVAL;\r\n}\r\nif (idx_value & 0x1) {\r\nu64 offset;\r\nr = radeon_cs_packet_next_reloc(p, &reloc, 0);\r\nif (r) {\r\nDRM_ERROR("bad STRMOUT_BUFFER_UPDATE (missing dst reloc)\n");\r\nreturn -EINVAL;\r\n}\r\noffset = radeon_get_ib_value(p, idx+1);\r\noffset += ((u64)(radeon_get_ib_value(p, idx+2) & 0xff)) << 32;\r\nif ((offset + 4) > radeon_bo_size(reloc->robj)) {\r\nDRM_ERROR("bad STRMOUT_BUFFER_UPDATE dst bo too small: 0x%llx, 0x%lx\n",\r\noffset + 4, radeon_bo_size(reloc->robj));\r\nreturn -EINVAL;\r\n}\r\noffset += reloc->gpu_offset;\r\nib[idx+1] = offset;\r\nib[idx+2] = upper_32_bits(offset) & 0xff;\r\n}\r\nif (((idx_value >> 1) & 0x3) == 2) {\r\nu64 offset;\r\nr = radeon_cs_packet_next_reloc(p, &reloc, 0);\r\nif (r) {\r\nDRM_ERROR("bad STRMOUT_BUFFER_UPDATE (missing src reloc)\n");\r\nreturn -EINVAL;\r\n}\r\noffset = radeon_get_ib_value(p, idx+3);\r\noffset += ((u64)(radeon_get_ib_value(p, idx+4) & 0xff)) << 32;\r\nif ((offset + 4) > radeon_bo_size(reloc->robj)) {\r\nDRM_ERROR("bad STRMOUT_BUFFER_UPDATE src bo too small: 0x%llx, 0x%lx\n",\r\noffset + 4, radeon_bo_size(reloc->robj));\r\nreturn -EINVAL;\r\n}\r\noffset += reloc->gpu_offset;\r\nib[idx+3] = offset;\r\nib[idx+4] = upper_32_bits(offset) & 0xff;\r\n}\r\nbreak;\r\ncase PACKET3_MEM_WRITE:\r\n{\r\nu64 offset;\r\nif (pkt->count != 3) {\r\nDRM_ERROR("bad MEM_WRITE (invalid count)\n");\r\nreturn -EINVAL;\r\n}\r\nr = radeon_cs_packet_next_reloc(p, &reloc, 0);\r\nif (r) {\r\nDRM_ERROR("bad MEM_WRITE (missing reloc)\n");\r\nreturn -EINVAL;\r\n}\r\noffset = radeon_get_ib_value(p, idx+0);\r\noffset += ((u64)(radeon_get_ib_value(p, idx+1) & 0xff)) << 32UL;\r\nif (offset & 0x7) {\r\nDRM_ERROR("bad MEM_WRITE (address not qwords aligned)\n");\r\nreturn -EINVAL;\r\n}\r\nif ((offset + 8) > radeon_bo_size(reloc->robj)) {\r\nDRM_ERROR("bad MEM_WRITE bo too small: 0x%llx, 0x%lx\n",\r\noffset + 8, radeon_bo_size(reloc->robj));\r\nreturn -EINVAL;\r\n}\r\noffset += reloc->gpu_offset;\r\nib[idx+0] = offset;\r\nib[idx+1] = upper_32_bits(offset) & 0xff;\r\nbreak;\r\n}\r\ncase PACKET3_COPY_DW:\r\nif (pkt->count != 4) {\r\nDRM_ERROR("bad COPY_DW (invalid count)\n");\r\nreturn -EINVAL;\r\n}\r\nif (idx_value & 0x1) {\r\nu64 offset;\r\nr = radeon_cs_packet_next_reloc(p, &reloc, 0);\r\nif (r) {\r\nDRM_ERROR("bad COPY_DW (missing src reloc)\n");\r\nreturn -EINVAL;\r\n}\r\noffset = radeon_get_ib_value(p, idx+1);\r\noffset += ((u64)(radeon_get_ib_value(p, idx+2) & 0xff)) << 32;\r\nif ((offset + 4) > radeon_bo_size(reloc->robj)) {\r\nDRM_ERROR("bad COPY_DW src bo too small: 0x%llx, 0x%lx\n",\r\noffset + 4, radeon_bo_size(reloc->robj));\r\nreturn -EINVAL;\r\n}\r\noffset += reloc->gpu_offset;\r\nib[idx+1] = offset;\r\nib[idx+2] = upper_32_bits(offset) & 0xff;\r\n} else {\r\nreg = radeon_get_ib_value(p, idx+1) << 2;\r\nif (!evergreen_is_safe_reg(p, reg, idx+1))\r\nreturn -EINVAL;\r\n}\r\nif (idx_value & 0x2) {\r\nu64 offset;\r\nr = radeon_cs_packet_next_reloc(p, &reloc, 0);\r\nif (r) {\r\nDRM_ERROR("bad COPY_DW (missing dst reloc)\n");\r\nreturn -EINVAL;\r\n}\r\noffset = radeon_get_ib_value(p, idx+3);\r\noffset += ((u64)(radeon_get_ib_value(p, idx+4) & 0xff)) << 32;\r\nif ((offset + 4) > radeon_bo_size(reloc->robj)) {\r\nDRM_ERROR("bad COPY_DW dst bo too small: 0x%llx, 0x%lx\n",\r\noffset + 4, radeon_bo_size(reloc->robj));\r\nreturn -EINVAL;\r\n}\r\noffset += reloc->gpu_offset;\r\nib[idx+3] = offset;\r\nib[idx+4] = upper_32_bits(offset) & 0xff;\r\n} else {\r\nreg = radeon_get_ib_value(p, idx+3) << 2;\r\nif (!evergreen_is_safe_reg(p, reg, idx+3))\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ncase PACKET3_NOP:\r\nbreak;\r\ndefault:\r\nDRM_ERROR("Packet3 opcode %x not supported\n", pkt->opcode);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nint evergreen_cs_parse(struct radeon_cs_parser *p)\r\n{\r\nstruct radeon_cs_packet pkt;\r\nstruct evergreen_cs_track *track;\r\nu32 tmp;\r\nint r;\r\nif (p->track == NULL) {\r\ntrack = kzalloc(sizeof(*track), GFP_KERNEL);\r\nif (track == NULL)\r\nreturn -ENOMEM;\r\nevergreen_cs_track_init(track);\r\nif (p->rdev->family >= CHIP_CAYMAN)\r\ntmp = p->rdev->config.cayman.tile_config;\r\nelse\r\ntmp = p->rdev->config.evergreen.tile_config;\r\nswitch (tmp & 0xf) {\r\ncase 0:\r\ntrack->npipes = 1;\r\nbreak;\r\ncase 1:\r\ndefault:\r\ntrack->npipes = 2;\r\nbreak;\r\ncase 2:\r\ntrack->npipes = 4;\r\nbreak;\r\ncase 3:\r\ntrack->npipes = 8;\r\nbreak;\r\n}\r\nswitch ((tmp & 0xf0) >> 4) {\r\ncase 0:\r\ntrack->nbanks = 4;\r\nbreak;\r\ncase 1:\r\ndefault:\r\ntrack->nbanks = 8;\r\nbreak;\r\ncase 2:\r\ntrack->nbanks = 16;\r\nbreak;\r\n}\r\nswitch ((tmp & 0xf00) >> 8) {\r\ncase 0:\r\ntrack->group_size = 256;\r\nbreak;\r\ncase 1:\r\ndefault:\r\ntrack->group_size = 512;\r\nbreak;\r\n}\r\nswitch ((tmp & 0xf000) >> 12) {\r\ncase 0:\r\ntrack->row_size = 1;\r\nbreak;\r\ncase 1:\r\ndefault:\r\ntrack->row_size = 2;\r\nbreak;\r\ncase 2:\r\ntrack->row_size = 4;\r\nbreak;\r\n}\r\np->track = track;\r\n}\r\ndo {\r\nr = radeon_cs_packet_parse(p, &pkt, p->idx);\r\nif (r) {\r\nkfree(p->track);\r\np->track = NULL;\r\nreturn r;\r\n}\r\np->idx += pkt.count + 2;\r\nswitch (pkt.type) {\r\ncase RADEON_PACKET_TYPE0:\r\nr = evergreen_cs_parse_packet0(p, &pkt);\r\nbreak;\r\ncase RADEON_PACKET_TYPE2:\r\nbreak;\r\ncase RADEON_PACKET_TYPE3:\r\nr = evergreen_packet3_check(p, &pkt);\r\nbreak;\r\ndefault:\r\nDRM_ERROR("Unknown packet type %d !\n", pkt.type);\r\nkfree(p->track);\r\np->track = NULL;\r\nreturn -EINVAL;\r\n}\r\nif (r) {\r\nkfree(p->track);\r\np->track = NULL;\r\nreturn r;\r\n}\r\n} while (p->idx < p->chunk_ib->length_dw);\r\n#if 0\r\nfor (r = 0; r < p->ib.length_dw; r++) {\r\nprintk(KERN_INFO "%05d 0x%08X\n", r, p->ib.ptr[r]);\r\nmdelay(1);\r\n}\r\n#endif\r\nkfree(p->track);\r\np->track = NULL;\r\nreturn 0;\r\n}\r\nint evergreen_dma_cs_parse(struct radeon_cs_parser *p)\r\n{\r\nstruct radeon_cs_chunk *ib_chunk = p->chunk_ib;\r\nstruct radeon_bo_list *src_reloc, *dst_reloc, *dst2_reloc;\r\nu32 header, cmd, count, sub_cmd;\r\nvolatile u32 *ib = p->ib.ptr;\r\nu32 idx;\r\nu64 src_offset, dst_offset, dst2_offset;\r\nint r;\r\ndo {\r\nif (p->idx >= ib_chunk->length_dw) {\r\nDRM_ERROR("Can not parse packet at %d after CS end %d !\n",\r\np->idx, ib_chunk->length_dw);\r\nreturn -EINVAL;\r\n}\r\nidx = p->idx;\r\nheader = radeon_get_ib_value(p, idx);\r\ncmd = GET_DMA_CMD(header);\r\ncount = GET_DMA_COUNT(header);\r\nsub_cmd = GET_DMA_SUB_CMD(header);\r\nswitch (cmd) {\r\ncase DMA_PACKET_WRITE:\r\nr = r600_dma_cs_next_reloc(p, &dst_reloc);\r\nif (r) {\r\nDRM_ERROR("bad DMA_PACKET_WRITE\n");\r\nreturn -EINVAL;\r\n}\r\nswitch (sub_cmd) {\r\ncase 8:\r\ndst_offset = radeon_get_ib_value(p, idx+1);\r\ndst_offset <<= 8;\r\nib[idx+1] += (u32)(dst_reloc->gpu_offset >> 8);\r\np->idx += count + 7;\r\nbreak;\r\ncase 0:\r\ndst_offset = radeon_get_ib_value(p, idx+1);\r\ndst_offset |= ((u64)(radeon_get_ib_value(p, idx+2) & 0xff)) << 32;\r\nib[idx+1] += (u32)(dst_reloc->gpu_offset & 0xfffffffc);\r\nib[idx+2] += upper_32_bits(dst_reloc->gpu_offset) & 0xff;\r\np->idx += count + 3;\r\nbreak;\r\ndefault:\r\nDRM_ERROR("bad DMA_PACKET_WRITE [%6d] 0x%08x sub cmd is not 0 or 8\n", idx, header);\r\nreturn -EINVAL;\r\n}\r\nif ((dst_offset + (count * 4)) > radeon_bo_size(dst_reloc->robj)) {\r\ndev_warn(p->dev, "DMA write buffer too small (%llu %lu)\n",\r\ndst_offset, radeon_bo_size(dst_reloc->robj));\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ncase DMA_PACKET_COPY:\r\nr = r600_dma_cs_next_reloc(p, &src_reloc);\r\nif (r) {\r\nDRM_ERROR("bad DMA_PACKET_COPY\n");\r\nreturn -EINVAL;\r\n}\r\nr = r600_dma_cs_next_reloc(p, &dst_reloc);\r\nif (r) {\r\nDRM_ERROR("bad DMA_PACKET_COPY\n");\r\nreturn -EINVAL;\r\n}\r\nswitch (sub_cmd) {\r\ncase 0x00:\r\nsrc_offset = radeon_get_ib_value(p, idx+2);\r\nsrc_offset |= ((u64)(radeon_get_ib_value(p, idx+4) & 0xff)) << 32;\r\ndst_offset = radeon_get_ib_value(p, idx+1);\r\ndst_offset |= ((u64)(radeon_get_ib_value(p, idx+3) & 0xff)) << 32;\r\nif ((src_offset + (count * 4)) > radeon_bo_size(src_reloc->robj)) {\r\ndev_warn(p->dev, "DMA L2L, dw src buffer too small (%llu %lu)\n",\r\nsrc_offset + (count * 4), radeon_bo_size(src_reloc->robj));\r\nreturn -EINVAL;\r\n}\r\nif ((dst_offset + (count * 4)) > radeon_bo_size(dst_reloc->robj)) {\r\ndev_warn(p->dev, "DMA L2L, dw dst buffer too small (%llu %lu)\n",\r\ndst_offset + (count * 4), radeon_bo_size(dst_reloc->robj));\r\nreturn -EINVAL;\r\n}\r\nib[idx+1] += (u32)(dst_reloc->gpu_offset & 0xfffffffc);\r\nib[idx+2] += (u32)(src_reloc->gpu_offset & 0xfffffffc);\r\nib[idx+3] += upper_32_bits(dst_reloc->gpu_offset) & 0xff;\r\nib[idx+4] += upper_32_bits(src_reloc->gpu_offset) & 0xff;\r\np->idx += 5;\r\nbreak;\r\ncase 0x08:\r\nif (radeon_get_ib_value(p, idx + 2) & (1 << 31)) {\r\nsrc_offset = radeon_get_ib_value(p, idx+1);\r\nsrc_offset <<= 8;\r\nib[idx+1] += (u32)(src_reloc->gpu_offset >> 8);\r\ndst_offset = radeon_get_ib_value(p, idx + 7);\r\ndst_offset |= ((u64)(radeon_get_ib_value(p, idx+8) & 0xff)) << 32;\r\nib[idx+7] += (u32)(dst_reloc->gpu_offset & 0xfffffffc);\r\nib[idx+8] += upper_32_bits(dst_reloc->gpu_offset) & 0xff;\r\n} else {\r\nsrc_offset = radeon_get_ib_value(p, idx+7);\r\nsrc_offset |= ((u64)(radeon_get_ib_value(p, idx+8) & 0xff)) << 32;\r\nib[idx+7] += (u32)(src_reloc->gpu_offset & 0xfffffffc);\r\nib[idx+8] += upper_32_bits(src_reloc->gpu_offset) & 0xff;\r\ndst_offset = radeon_get_ib_value(p, idx+1);\r\ndst_offset <<= 8;\r\nib[idx+1] += (u32)(dst_reloc->gpu_offset >> 8);\r\n}\r\nif ((src_offset + (count * 4)) > radeon_bo_size(src_reloc->robj)) {\r\ndev_warn(p->dev, "DMA L2T, src buffer too small (%llu %lu)\n",\r\nsrc_offset + (count * 4), radeon_bo_size(src_reloc->robj));\r\nreturn -EINVAL;\r\n}\r\nif ((dst_offset + (count * 4)) > radeon_bo_size(dst_reloc->robj)) {\r\ndev_warn(p->dev, "DMA L2T, dst buffer too small (%llu %lu)\n",\r\ndst_offset + (count * 4), radeon_bo_size(dst_reloc->robj));\r\nreturn -EINVAL;\r\n}\r\np->idx += 9;\r\nbreak;\r\ncase 0x40:\r\nsrc_offset = radeon_get_ib_value(p, idx+2);\r\nsrc_offset |= ((u64)(radeon_get_ib_value(p, idx+4) & 0xff)) << 32;\r\ndst_offset = radeon_get_ib_value(p, idx+1);\r\ndst_offset |= ((u64)(radeon_get_ib_value(p, idx+3) & 0xff)) << 32;\r\nif ((src_offset + count) > radeon_bo_size(src_reloc->robj)) {\r\ndev_warn(p->dev, "DMA L2L, byte src buffer too small (%llu %lu)\n",\r\nsrc_offset + count, radeon_bo_size(src_reloc->robj));\r\nreturn -EINVAL;\r\n}\r\nif ((dst_offset + count) > radeon_bo_size(dst_reloc->robj)) {\r\ndev_warn(p->dev, "DMA L2L, byte dst buffer too small (%llu %lu)\n",\r\ndst_offset + count, radeon_bo_size(dst_reloc->robj));\r\nreturn -EINVAL;\r\n}\r\nib[idx+1] += (u32)(dst_reloc->gpu_offset & 0xffffffff);\r\nib[idx+2] += (u32)(src_reloc->gpu_offset & 0xffffffff);\r\nib[idx+3] += upper_32_bits(dst_reloc->gpu_offset) & 0xff;\r\nib[idx+4] += upper_32_bits(src_reloc->gpu_offset) & 0xff;\r\np->idx += 5;\r\nbreak;\r\ncase 0x41:\r\nif (p->family < CHIP_CAYMAN) {\r\nDRM_ERROR("L2L Partial is cayman only !\n");\r\nreturn -EINVAL;\r\n}\r\nib[idx+1] += (u32)(src_reloc->gpu_offset & 0xffffffff);\r\nib[idx+2] += upper_32_bits(src_reloc->gpu_offset) & 0xff;\r\nib[idx+4] += (u32)(dst_reloc->gpu_offset & 0xffffffff);\r\nib[idx+5] += upper_32_bits(dst_reloc->gpu_offset) & 0xff;\r\np->idx += 9;\r\nbreak;\r\ncase 0x44:\r\nr = r600_dma_cs_next_reloc(p, &dst2_reloc);\r\nif (r) {\r\nDRM_ERROR("bad L2L, dw, broadcast DMA_PACKET_COPY\n");\r\nreturn -EINVAL;\r\n}\r\ndst_offset = radeon_get_ib_value(p, idx+1);\r\ndst_offset |= ((u64)(radeon_get_ib_value(p, idx+4) & 0xff)) << 32;\r\ndst2_offset = radeon_get_ib_value(p, idx+2);\r\ndst2_offset |= ((u64)(radeon_get_ib_value(p, idx+5) & 0xff)) << 32;\r\nsrc_offset = radeon_get_ib_value(p, idx+3);\r\nsrc_offset |= ((u64)(radeon_get_ib_value(p, idx+6) & 0xff)) << 32;\r\nif ((src_offset + (count * 4)) > radeon_bo_size(src_reloc->robj)) {\r\ndev_warn(p->dev, "DMA L2L, dw, broadcast src buffer too small (%llu %lu)\n",\r\nsrc_offset + (count * 4), radeon_bo_size(src_reloc->robj));\r\nreturn -EINVAL;\r\n}\r\nif ((dst_offset + (count * 4)) > radeon_bo_size(dst_reloc->robj)) {\r\ndev_warn(p->dev, "DMA L2L, dw, broadcast dst buffer too small (%llu %lu)\n",\r\ndst_offset + (count * 4), radeon_bo_size(dst_reloc->robj));\r\nreturn -EINVAL;\r\n}\r\nif ((dst2_offset + (count * 4)) > radeon_bo_size(dst2_reloc->robj)) {\r\ndev_warn(p->dev, "DMA L2L, dw, broadcast dst2 buffer too small (%llu %lu)\n",\r\ndst2_offset + (count * 4), radeon_bo_size(dst2_reloc->robj));\r\nreturn -EINVAL;\r\n}\r\nib[idx+1] += (u32)(dst_reloc->gpu_offset & 0xfffffffc);\r\nib[idx+2] += (u32)(dst2_reloc->gpu_offset & 0xfffffffc);\r\nib[idx+3] += (u32)(src_reloc->gpu_offset & 0xfffffffc);\r\nib[idx+4] += upper_32_bits(dst_reloc->gpu_offset) & 0xff;\r\nib[idx+5] += upper_32_bits(dst2_reloc->gpu_offset) & 0xff;\r\nib[idx+6] += upper_32_bits(src_reloc->gpu_offset) & 0xff;\r\np->idx += 7;\r\nbreak;\r\ncase 0x48:\r\nif (radeon_get_ib_value(p, idx + 2) & (1 << 31)) {\r\nDRM_ERROR("bad L2T, frame to fields DMA_PACKET_COPY\n");\r\nreturn -EINVAL;\r\n}\r\nr = r600_dma_cs_next_reloc(p, &dst2_reloc);\r\nif (r) {\r\nDRM_ERROR("bad L2T, frame to fields DMA_PACKET_COPY\n");\r\nreturn -EINVAL;\r\n}\r\ndst_offset = radeon_get_ib_value(p, idx+1);\r\ndst_offset <<= 8;\r\ndst2_offset = radeon_get_ib_value(p, idx+2);\r\ndst2_offset <<= 8;\r\nsrc_offset = radeon_get_ib_value(p, idx+8);\r\nsrc_offset |= ((u64)(radeon_get_ib_value(p, idx+9) & 0xff)) << 32;\r\nif ((src_offset + (count * 4)) > radeon_bo_size(src_reloc->robj)) {\r\ndev_warn(p->dev, "DMA L2T, frame to fields src buffer too small (%llu %lu)\n",\r\nsrc_offset + (count * 4), radeon_bo_size(src_reloc->robj));\r\nreturn -EINVAL;\r\n}\r\nif ((dst_offset + (count * 4)) > radeon_bo_size(dst_reloc->robj)) {\r\ndev_warn(p->dev, "DMA L2T, frame to fields buffer too small (%llu %lu)\n",\r\ndst_offset + (count * 4), radeon_bo_size(dst_reloc->robj));\r\nreturn -EINVAL;\r\n}\r\nif ((dst2_offset + (count * 4)) > radeon_bo_size(dst2_reloc->robj)) {\r\ndev_warn(p->dev, "DMA L2T, frame to fields buffer too small (%llu %lu)\n",\r\ndst2_offset + (count * 4), radeon_bo_size(dst2_reloc->robj));\r\nreturn -EINVAL;\r\n}\r\nib[idx+1] += (u32)(dst_reloc->gpu_offset >> 8);\r\nib[idx+2] += (u32)(dst2_reloc->gpu_offset >> 8);\r\nib[idx+8] += (u32)(src_reloc->gpu_offset & 0xfffffffc);\r\nib[idx+9] += upper_32_bits(src_reloc->gpu_offset) & 0xff;\r\np->idx += 10;\r\nbreak;\r\ncase 0x49:\r\nif (p->family < CHIP_CAYMAN) {\r\nDRM_ERROR("L2T, T2L Partial is cayman only !\n");\r\nreturn -EINVAL;\r\n}\r\nif (radeon_get_ib_value(p, idx + 2) & (1 << 31)) {\r\nib[idx+1] += (u32)(src_reloc->gpu_offset >> 8);\r\nib[idx+7] += (u32)(dst_reloc->gpu_offset & 0xfffffffc);\r\nib[idx+8] += upper_32_bits(dst_reloc->gpu_offset) & 0xff;\r\n} else {\r\nib[idx+7] += (u32)(src_reloc->gpu_offset & 0xfffffffc);\r\nib[idx+8] += upper_32_bits(src_reloc->gpu_offset) & 0xff;\r\nib[idx+1] += (u32)(dst_reloc->gpu_offset >> 8);\r\n}\r\np->idx += 12;\r\nbreak;\r\ncase 0x4b:\r\nif (radeon_get_ib_value(p, idx + 2) & (1 << 31)) {\r\nDRM_ERROR("bad L2T, broadcast DMA_PACKET_COPY\n");\r\nreturn -EINVAL;\r\n}\r\nr = r600_dma_cs_next_reloc(p, &dst2_reloc);\r\nif (r) {\r\nDRM_ERROR("bad L2T, broadcast DMA_PACKET_COPY\n");\r\nreturn -EINVAL;\r\n}\r\ndst_offset = radeon_get_ib_value(p, idx+1);\r\ndst_offset <<= 8;\r\ndst2_offset = radeon_get_ib_value(p, idx+2);\r\ndst2_offset <<= 8;\r\nsrc_offset = radeon_get_ib_value(p, idx+8);\r\nsrc_offset |= ((u64)(radeon_get_ib_value(p, idx+9) & 0xff)) << 32;\r\nif ((src_offset + (count * 4)) > radeon_bo_size(src_reloc->robj)) {\r\ndev_warn(p->dev, "DMA L2T, broadcast src buffer too small (%llu %lu)\n",\r\nsrc_offset + (count * 4), radeon_bo_size(src_reloc->robj));\r\nreturn -EINVAL;\r\n}\r\nif ((dst_offset + (count * 4)) > radeon_bo_size(dst_reloc->robj)) {\r\ndev_warn(p->dev, "DMA L2T, broadcast dst buffer too small (%llu %lu)\n",\r\ndst_offset + (count * 4), radeon_bo_size(dst_reloc->robj));\r\nreturn -EINVAL;\r\n}\r\nif ((dst2_offset + (count * 4)) > radeon_bo_size(dst2_reloc->robj)) {\r\ndev_warn(p->dev, "DMA L2T, broadcast dst2 buffer too small (%llu %lu)\n",\r\ndst2_offset + (count * 4), radeon_bo_size(dst2_reloc->robj));\r\nreturn -EINVAL;\r\n}\r\nib[idx+1] += (u32)(dst_reloc->gpu_offset >> 8);\r\nib[idx+2] += (u32)(dst2_reloc->gpu_offset >> 8);\r\nib[idx+8] += (u32)(src_reloc->gpu_offset & 0xfffffffc);\r\nib[idx+9] += upper_32_bits(src_reloc->gpu_offset) & 0xff;\r\np->idx += 10;\r\nbreak;\r\ncase 0x4c:\r\nif (radeon_get_ib_value(p, idx + 2) & (1 << 31)) {\r\nsrc_offset = radeon_get_ib_value(p, idx+1);\r\nsrc_offset <<= 8;\r\nib[idx+1] += (u32)(src_reloc->gpu_offset >> 8);\r\ndst_offset = radeon_get_ib_value(p, idx+7);\r\ndst_offset |= ((u64)(radeon_get_ib_value(p, idx+8) & 0xff)) << 32;\r\nib[idx+7] += (u32)(dst_reloc->gpu_offset & 0xfffffffc);\r\nib[idx+8] += upper_32_bits(dst_reloc->gpu_offset) & 0xff;\r\n} else {\r\nsrc_offset = radeon_get_ib_value(p, idx+7);\r\nsrc_offset |= ((u64)(radeon_get_ib_value(p, idx+8) & 0xff)) << 32;\r\nib[idx+7] += (u32)(src_reloc->gpu_offset & 0xfffffffc);\r\nib[idx+8] += upper_32_bits(src_reloc->gpu_offset) & 0xff;\r\ndst_offset = radeon_get_ib_value(p, idx+1);\r\ndst_offset <<= 8;\r\nib[idx+1] += (u32)(dst_reloc->gpu_offset >> 8);\r\n}\r\nif ((src_offset + (count * 4)) > radeon_bo_size(src_reloc->robj)) {\r\ndev_warn(p->dev, "DMA L2T, T2L src buffer too small (%llu %lu)\n",\r\nsrc_offset + (count * 4), radeon_bo_size(src_reloc->robj));\r\nreturn -EINVAL;\r\n}\r\nif ((dst_offset + (count * 4)) > radeon_bo_size(dst_reloc->robj)) {\r\ndev_warn(p->dev, "DMA L2T, T2L dst buffer too small (%llu %lu)\n",\r\ndst_offset + (count * 4), radeon_bo_size(dst_reloc->robj));\r\nreturn -EINVAL;\r\n}\r\np->idx += 9;\r\nbreak;\r\ncase 0x4d:\r\nif (p->family < CHIP_CAYMAN) {\r\nDRM_ERROR("L2T, T2L Partial is cayman only !\n");\r\nreturn -EINVAL;\r\n}\r\nib[idx+1] += (u32)(src_reloc->gpu_offset >> 8);\r\nib[idx+4] += (u32)(dst_reloc->gpu_offset >> 8);\r\np->idx += 13;\r\nbreak;\r\ncase 0x4f:\r\nif (radeon_get_ib_value(p, idx + 2) & (1 << 31)) {\r\nDRM_ERROR("bad L2T, broadcast DMA_PACKET_COPY\n");\r\nreturn -EINVAL;\r\n}\r\nr = r600_dma_cs_next_reloc(p, &dst2_reloc);\r\nif (r) {\r\nDRM_ERROR("bad L2T, broadcast DMA_PACKET_COPY\n");\r\nreturn -EINVAL;\r\n}\r\ndst_offset = radeon_get_ib_value(p, idx+1);\r\ndst_offset <<= 8;\r\ndst2_offset = radeon_get_ib_value(p, idx+2);\r\ndst2_offset <<= 8;\r\nsrc_offset = radeon_get_ib_value(p, idx+8);\r\nsrc_offset |= ((u64)(radeon_get_ib_value(p, idx+9) & 0xff)) << 32;\r\nif ((src_offset + (count * 4)) > radeon_bo_size(src_reloc->robj)) {\r\ndev_warn(p->dev, "DMA L2T, broadcast src buffer too small (%llu %lu)\n",\r\nsrc_offset + (count * 4), radeon_bo_size(src_reloc->robj));\r\nreturn -EINVAL;\r\n}\r\nif ((dst_offset + (count * 4)) > radeon_bo_size(dst_reloc->robj)) {\r\ndev_warn(p->dev, "DMA L2T, broadcast dst buffer too small (%llu %lu)\n",\r\ndst_offset + (count * 4), radeon_bo_size(dst_reloc->robj));\r\nreturn -EINVAL;\r\n}\r\nif ((dst2_offset + (count * 4)) > radeon_bo_size(dst2_reloc->robj)) {\r\ndev_warn(p->dev, "DMA L2T, broadcast dst2 buffer too small (%llu %lu)\n",\r\ndst2_offset + (count * 4), radeon_bo_size(dst2_reloc->robj));\r\nreturn -EINVAL;\r\n}\r\nib[idx+1] += (u32)(dst_reloc->gpu_offset >> 8);\r\nib[idx+2] += (u32)(dst2_reloc->gpu_offset >> 8);\r\nib[idx+8] += (u32)(src_reloc->gpu_offset & 0xfffffffc);\r\nib[idx+9] += upper_32_bits(src_reloc->gpu_offset) & 0xff;\r\np->idx += 10;\r\nbreak;\r\ndefault:\r\nDRM_ERROR("bad DMA_PACKET_COPY [%6d] 0x%08x invalid sub cmd\n", idx, header);\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ncase DMA_PACKET_CONSTANT_FILL:\r\nr = r600_dma_cs_next_reloc(p, &dst_reloc);\r\nif (r) {\r\nDRM_ERROR("bad DMA_PACKET_CONSTANT_FILL\n");\r\nreturn -EINVAL;\r\n}\r\ndst_offset = radeon_get_ib_value(p, idx+1);\r\ndst_offset |= ((u64)(radeon_get_ib_value(p, idx+3) & 0x00ff0000)) << 16;\r\nif ((dst_offset + (count * 4)) > radeon_bo_size(dst_reloc->robj)) {\r\ndev_warn(p->dev, "DMA constant fill buffer too small (%llu %lu)\n",\r\ndst_offset, radeon_bo_size(dst_reloc->robj));\r\nreturn -EINVAL;\r\n}\r\nib[idx+1] += (u32)(dst_reloc->gpu_offset & 0xfffffffc);\r\nib[idx+3] += (upper_32_bits(dst_reloc->gpu_offset) << 16) & 0x00ff0000;\r\np->idx += 4;\r\nbreak;\r\ncase DMA_PACKET_NOP:\r\np->idx += 1;\r\nbreak;\r\ndefault:\r\nDRM_ERROR("Unknown packet type %d at %d !\n", cmd, idx);\r\nreturn -EINVAL;\r\n}\r\n} while (p->idx < p->chunk_ib->length_dw);\r\n#if 0\r\nfor (r = 0; r < p->ib->length_dw; r++) {\r\nprintk(KERN_INFO "%05d 0x%08X\n", r, p->ib.ptr[r]);\r\nmdelay(1);\r\n}\r\n#endif\r\nreturn 0;\r\n}\r\nstatic bool evergreen_vm_reg_valid(u32 reg)\r\n{\r\nif (reg >= 0x28000)\r\nreturn true;\r\nswitch (reg) {\r\ncase WAIT_UNTIL:\r\ncase GRBM_GFX_INDEX:\r\ncase CP_STRMOUT_CNTL:\r\ncase CP_COHER_CNTL:\r\ncase CP_COHER_SIZE:\r\ncase VGT_VTX_VECT_EJECT_REG:\r\ncase VGT_CACHE_INVALIDATION:\r\ncase VGT_GS_VERTEX_REUSE:\r\ncase VGT_PRIMITIVE_TYPE:\r\ncase VGT_INDEX_TYPE:\r\ncase VGT_NUM_INDICES:\r\ncase VGT_NUM_INSTANCES:\r\ncase VGT_COMPUTE_DIM_X:\r\ncase VGT_COMPUTE_DIM_Y:\r\ncase VGT_COMPUTE_DIM_Z:\r\ncase VGT_COMPUTE_START_X:\r\ncase VGT_COMPUTE_START_Y:\r\ncase VGT_COMPUTE_START_Z:\r\ncase VGT_COMPUTE_INDEX:\r\ncase VGT_COMPUTE_THREAD_GROUP_SIZE:\r\ncase VGT_HS_OFFCHIP_PARAM:\r\ncase PA_CL_ENHANCE:\r\ncase PA_SU_LINE_STIPPLE_VALUE:\r\ncase PA_SC_LINE_STIPPLE_STATE:\r\ncase PA_SC_ENHANCE:\r\ncase SQ_DYN_GPR_CNTL_PS_FLUSH_REQ:\r\ncase SQ_DYN_GPR_SIMD_LOCK_EN:\r\ncase SQ_CONFIG:\r\ncase SQ_GPR_RESOURCE_MGMT_1:\r\ncase SQ_GLOBAL_GPR_RESOURCE_MGMT_1:\r\ncase SQ_GLOBAL_GPR_RESOURCE_MGMT_2:\r\ncase SQ_CONST_MEM_BASE:\r\ncase SQ_STATIC_THREAD_MGMT_1:\r\ncase SQ_STATIC_THREAD_MGMT_2:\r\ncase SQ_STATIC_THREAD_MGMT_3:\r\ncase SPI_CONFIG_CNTL:\r\ncase SPI_CONFIG_CNTL_1:\r\ncase TA_CNTL_AUX:\r\ncase DB_DEBUG:\r\ncase DB_DEBUG2:\r\ncase DB_DEBUG3:\r\ncase DB_DEBUG4:\r\ncase DB_WATERMARKS:\r\ncase TD_PS_BORDER_COLOR_INDEX:\r\ncase TD_PS_BORDER_COLOR_RED:\r\ncase TD_PS_BORDER_COLOR_GREEN:\r\ncase TD_PS_BORDER_COLOR_BLUE:\r\ncase TD_PS_BORDER_COLOR_ALPHA:\r\ncase TD_VS_BORDER_COLOR_INDEX:\r\ncase TD_VS_BORDER_COLOR_RED:\r\ncase TD_VS_BORDER_COLOR_GREEN:\r\ncase TD_VS_BORDER_COLOR_BLUE:\r\ncase TD_VS_BORDER_COLOR_ALPHA:\r\ncase TD_GS_BORDER_COLOR_INDEX:\r\ncase TD_GS_BORDER_COLOR_RED:\r\ncase TD_GS_BORDER_COLOR_GREEN:\r\ncase TD_GS_BORDER_COLOR_BLUE:\r\ncase TD_GS_BORDER_COLOR_ALPHA:\r\ncase TD_HS_BORDER_COLOR_INDEX:\r\ncase TD_HS_BORDER_COLOR_RED:\r\ncase TD_HS_BORDER_COLOR_GREEN:\r\ncase TD_HS_BORDER_COLOR_BLUE:\r\ncase TD_HS_BORDER_COLOR_ALPHA:\r\ncase TD_LS_BORDER_COLOR_INDEX:\r\ncase TD_LS_BORDER_COLOR_RED:\r\ncase TD_LS_BORDER_COLOR_GREEN:\r\ncase TD_LS_BORDER_COLOR_BLUE:\r\ncase TD_LS_BORDER_COLOR_ALPHA:\r\ncase TD_CS_BORDER_COLOR_INDEX:\r\ncase TD_CS_BORDER_COLOR_RED:\r\ncase TD_CS_BORDER_COLOR_GREEN:\r\ncase TD_CS_BORDER_COLOR_BLUE:\r\ncase TD_CS_BORDER_COLOR_ALPHA:\r\ncase SQ_ESGS_RING_SIZE:\r\ncase SQ_GSVS_RING_SIZE:\r\ncase SQ_ESTMP_RING_SIZE:\r\ncase SQ_GSTMP_RING_SIZE:\r\ncase SQ_HSTMP_RING_SIZE:\r\ncase SQ_LSTMP_RING_SIZE:\r\ncase SQ_PSTMP_RING_SIZE:\r\ncase SQ_VSTMP_RING_SIZE:\r\ncase SQ_ESGS_RING_ITEMSIZE:\r\ncase SQ_ESTMP_RING_ITEMSIZE:\r\ncase SQ_GSTMP_RING_ITEMSIZE:\r\ncase SQ_GSVS_RING_ITEMSIZE:\r\ncase SQ_GS_VERT_ITEMSIZE:\r\ncase SQ_GS_VERT_ITEMSIZE_1:\r\ncase SQ_GS_VERT_ITEMSIZE_2:\r\ncase SQ_GS_VERT_ITEMSIZE_3:\r\ncase SQ_GSVS_RING_OFFSET_1:\r\ncase SQ_GSVS_RING_OFFSET_2:\r\ncase SQ_GSVS_RING_OFFSET_3:\r\ncase SQ_HSTMP_RING_ITEMSIZE:\r\ncase SQ_LSTMP_RING_ITEMSIZE:\r\ncase SQ_PSTMP_RING_ITEMSIZE:\r\ncase SQ_VSTMP_RING_ITEMSIZE:\r\ncase VGT_TF_RING_SIZE:\r\ncase SQ_ESGS_RING_BASE:\r\ncase SQ_GSVS_RING_BASE:\r\ncase SQ_ESTMP_RING_BASE:\r\ncase SQ_GSTMP_RING_BASE:\r\ncase SQ_HSTMP_RING_BASE:\r\ncase SQ_LSTMP_RING_BASE:\r\ncase SQ_PSTMP_RING_BASE:\r\ncase SQ_VSTMP_RING_BASE:\r\ncase CAYMAN_VGT_OFFCHIP_LDS_BASE:\r\ncase CAYMAN_SQ_EX_ALLOC_TABLE_SLOTS:\r\nreturn true;\r\ndefault:\r\nDRM_ERROR("Invalid register 0x%x in CS\n", reg);\r\nreturn false;\r\n}\r\n}\r\nstatic int evergreen_vm_packet3_check(struct radeon_device *rdev,\r\nu32 *ib, struct radeon_cs_packet *pkt)\r\n{\r\nu32 idx = pkt->idx + 1;\r\nu32 idx_value = ib[idx];\r\nu32 start_reg, end_reg, reg, i;\r\nu32 command, info;\r\nswitch (pkt->opcode) {\r\ncase PACKET3_NOP:\r\nbreak;\r\ncase PACKET3_SET_BASE:\r\nif (idx_value != 1) {\r\nDRM_ERROR("bad SET_BASE");\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ncase PACKET3_CLEAR_STATE:\r\ncase PACKET3_INDEX_BUFFER_SIZE:\r\ncase PACKET3_DISPATCH_DIRECT:\r\ncase PACKET3_DISPATCH_INDIRECT:\r\ncase PACKET3_MODE_CONTROL:\r\ncase PACKET3_SET_PREDICATION:\r\ncase PACKET3_COND_EXEC:\r\ncase PACKET3_PRED_EXEC:\r\ncase PACKET3_DRAW_INDIRECT:\r\ncase PACKET3_DRAW_INDEX_INDIRECT:\r\ncase PACKET3_INDEX_BASE:\r\ncase PACKET3_DRAW_INDEX_2:\r\ncase PACKET3_CONTEXT_CONTROL:\r\ncase PACKET3_DRAW_INDEX_OFFSET:\r\ncase PACKET3_INDEX_TYPE:\r\ncase PACKET3_DRAW_INDEX:\r\ncase PACKET3_DRAW_INDEX_AUTO:\r\ncase PACKET3_DRAW_INDEX_IMMD:\r\ncase PACKET3_NUM_INSTANCES:\r\ncase PACKET3_DRAW_INDEX_MULTI_AUTO:\r\ncase PACKET3_STRMOUT_BUFFER_UPDATE:\r\ncase PACKET3_DRAW_INDEX_OFFSET_2:\r\ncase PACKET3_DRAW_INDEX_MULTI_ELEMENT:\r\ncase PACKET3_MPEG_INDEX:\r\ncase PACKET3_WAIT_REG_MEM:\r\ncase PACKET3_MEM_WRITE:\r\ncase PACKET3_SURFACE_SYNC:\r\ncase PACKET3_EVENT_WRITE:\r\ncase PACKET3_EVENT_WRITE_EOP:\r\ncase PACKET3_EVENT_WRITE_EOS:\r\ncase PACKET3_SET_CONTEXT_REG:\r\ncase PACKET3_SET_BOOL_CONST:\r\ncase PACKET3_SET_LOOP_CONST:\r\ncase PACKET3_SET_RESOURCE:\r\ncase PACKET3_SET_SAMPLER:\r\ncase PACKET3_SET_CTL_CONST:\r\ncase PACKET3_SET_RESOURCE_OFFSET:\r\ncase PACKET3_SET_CONTEXT_REG_INDIRECT:\r\ncase PACKET3_SET_RESOURCE_INDIRECT:\r\ncase CAYMAN_PACKET3_DEALLOC_STATE:\r\nbreak;\r\ncase PACKET3_COND_WRITE:\r\nif (idx_value & 0x100) {\r\nreg = ib[idx + 5] * 4;\r\nif (!evergreen_vm_reg_valid(reg))\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ncase PACKET3_COPY_DW:\r\nif (idx_value & 0x2) {\r\nreg = ib[idx + 3] * 4;\r\nif (!evergreen_vm_reg_valid(reg))\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ncase PACKET3_SET_CONFIG_REG:\r\nstart_reg = (idx_value << 2) + PACKET3_SET_CONFIG_REG_START;\r\nend_reg = 4 * pkt->count + start_reg - 4;\r\nif ((start_reg < PACKET3_SET_CONFIG_REG_START) ||\r\n(start_reg >= PACKET3_SET_CONFIG_REG_END) ||\r\n(end_reg >= PACKET3_SET_CONFIG_REG_END)) {\r\nDRM_ERROR("bad PACKET3_SET_CONFIG_REG\n");\r\nreturn -EINVAL;\r\n}\r\nfor (i = 0; i < pkt->count; i++) {\r\nreg = start_reg + (4 * i);\r\nif (!evergreen_vm_reg_valid(reg))\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ncase PACKET3_CP_DMA:\r\ncommand = ib[idx + 4];\r\ninfo = ib[idx + 1];\r\nif ((((info & 0x60000000) >> 29) != 0) ||\r\n(((info & 0x00300000) >> 20) != 0) ||\r\n((((info & 0x00300000) >> 20) == 0) &&\r\n(command & PACKET3_CP_DMA_CMD_DAS)) ||\r\n((((info & 0x60000000) >> 29) == 0) &&\r\n(command & PACKET3_CP_DMA_CMD_SAS))) {\r\nif ((command & 0x1fffff) % 4) {\r\nDRM_ERROR("CP DMA command requires dw count alignment\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\nif (command & PACKET3_CP_DMA_CMD_SAS) {\r\nif (((info & 0x60000000) >> 29) == 0) {\r\nstart_reg = idx_value << 2;\r\nif (command & PACKET3_CP_DMA_CMD_SAIC) {\r\nreg = start_reg;\r\nif (!evergreen_vm_reg_valid(reg)) {\r\nDRM_ERROR("CP DMA Bad SRC register\n");\r\nreturn -EINVAL;\r\n}\r\n} else {\r\nfor (i = 0; i < (command & 0x1fffff); i++) {\r\nreg = start_reg + (4 * i);\r\nif (!evergreen_vm_reg_valid(reg)) {\r\nDRM_ERROR("CP DMA Bad SRC register\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\n}\r\n}\r\n}\r\nif (command & PACKET3_CP_DMA_CMD_DAS) {\r\nif (((info & 0x00300000) >> 20) == 0) {\r\nstart_reg = ib[idx + 2];\r\nif (command & PACKET3_CP_DMA_CMD_DAIC) {\r\nreg = start_reg;\r\nif (!evergreen_vm_reg_valid(reg)) {\r\nDRM_ERROR("CP DMA Bad DST register\n");\r\nreturn -EINVAL;\r\n}\r\n} else {\r\nfor (i = 0; i < (command & 0x1fffff); i++) {\r\nreg = start_reg + (4 * i);\r\nif (!evergreen_vm_reg_valid(reg)) {\r\nDRM_ERROR("CP DMA Bad DST register\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\n}\r\n}\r\n}\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nint evergreen_ib_parse(struct radeon_device *rdev, struct radeon_ib *ib)\r\n{\r\nint ret = 0;\r\nu32 idx = 0;\r\nstruct radeon_cs_packet pkt;\r\ndo {\r\npkt.idx = idx;\r\npkt.type = RADEON_CP_PACKET_GET_TYPE(ib->ptr[idx]);\r\npkt.count = RADEON_CP_PACKET_GET_COUNT(ib->ptr[idx]);\r\npkt.one_reg_wr = 0;\r\nswitch (pkt.type) {\r\ncase RADEON_PACKET_TYPE0:\r\ndev_err(rdev->dev, "Packet0 not allowed!\n");\r\nret = -EINVAL;\r\nbreak;\r\ncase RADEON_PACKET_TYPE2:\r\nidx += 1;\r\nbreak;\r\ncase RADEON_PACKET_TYPE3:\r\npkt.opcode = RADEON_CP_PACKET3_GET_OPCODE(ib->ptr[idx]);\r\nret = evergreen_vm_packet3_check(rdev, ib->ptr, &pkt);\r\nidx += pkt.count + 2;\r\nbreak;\r\ndefault:\r\ndev_err(rdev->dev, "Unknown packet type %d !\n", pkt.type);\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nif (ret)\r\nbreak;\r\n} while (idx < ib->length_dw);\r\nreturn ret;\r\n}\r\nint evergreen_dma_ib_parse(struct radeon_device *rdev, struct radeon_ib *ib)\r\n{\r\nu32 idx = 0;\r\nu32 header, cmd, count, sub_cmd;\r\ndo {\r\nheader = ib->ptr[idx];\r\ncmd = GET_DMA_CMD(header);\r\ncount = GET_DMA_COUNT(header);\r\nsub_cmd = GET_DMA_SUB_CMD(header);\r\nswitch (cmd) {\r\ncase DMA_PACKET_WRITE:\r\nswitch (sub_cmd) {\r\ncase 8:\r\nidx += count + 7;\r\nbreak;\r\ncase 0:\r\nidx += count + 3;\r\nbreak;\r\ndefault:\r\nDRM_ERROR("bad DMA_PACKET_WRITE [%6d] 0x%08x sub cmd is not 0 or 8\n", idx, ib->ptr[idx]);\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ncase DMA_PACKET_COPY:\r\nswitch (sub_cmd) {\r\ncase 0x00:\r\nidx += 5;\r\nbreak;\r\ncase 0x08:\r\nidx += 9;\r\nbreak;\r\ncase 0x40:\r\nidx += 5;\r\nbreak;\r\ncase 0x41:\r\nidx += 9;\r\nbreak;\r\ncase 0x44:\r\nidx += 7;\r\nbreak;\r\ncase 0x48:\r\nidx += 10;\r\nbreak;\r\ncase 0x49:\r\nidx += 12;\r\nbreak;\r\ncase 0x4b:\r\nidx += 10;\r\nbreak;\r\ncase 0x4c:\r\nidx += 9;\r\nbreak;\r\ncase 0x4d:\r\nidx += 13;\r\nbreak;\r\ncase 0x4f:\r\nidx += 10;\r\nbreak;\r\ndefault:\r\nDRM_ERROR("bad DMA_PACKET_COPY [%6d] 0x%08x invalid sub cmd\n", idx, ib->ptr[idx]);\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ncase DMA_PACKET_CONSTANT_FILL:\r\nidx += 4;\r\nbreak;\r\ncase DMA_PACKET_NOP:\r\nidx += 1;\r\nbreak;\r\ndefault:\r\nDRM_ERROR("Unknown packet type %d at %d !\n", cmd, idx);\r\nreturn -EINVAL;\r\n}\r\n} while (idx < ib->length_dw);\r\nreturn 0;\r\n}
