static inline struct vbt_panel *to_vbt_panel(struct drm_panel *panel)\r\n{\r\nreturn container_of(panel, struct vbt_panel, panel);\r\n}\r\nstatic inline enum port intel_dsi_seq_port_to_port(u8 port)\r\n{\r\nreturn port ? PORT_C : PORT_A;\r\n}\r\nstatic const u8 *mipi_exec_send_packet(struct intel_dsi *intel_dsi,\r\nconst u8 *data)\r\n{\r\nstruct mipi_dsi_device *dsi_device;\r\nu8 type, flags, seq_port;\r\nu16 len;\r\nenum port port;\r\nflags = *data++;\r\ntype = *data++;\r\nlen = *((u16 *) data);\r\ndata += 2;\r\nseq_port = (flags >> MIPI_PORT_SHIFT) & 3;\r\nif (intel_dsi->ports == (1 << PORT_C))\r\nport = PORT_C;\r\nelse\r\nport = intel_dsi_seq_port_to_port(seq_port);\r\ndsi_device = intel_dsi->dsi_hosts[port]->device;\r\nif (!dsi_device) {\r\nDRM_DEBUG_KMS("no dsi device for port %c\n", port_name(port));\r\ngoto out;\r\n}\r\nif ((flags >> MIPI_TRANSFER_MODE_SHIFT) & 1)\r\ndsi_device->mode_flags &= ~MIPI_DSI_MODE_LPM;\r\nelse\r\ndsi_device->mode_flags |= MIPI_DSI_MODE_LPM;\r\ndsi_device->channel = (flags >> MIPI_VIRTUAL_CHANNEL_SHIFT) & 3;\r\nswitch (type) {\r\ncase MIPI_DSI_GENERIC_SHORT_WRITE_0_PARAM:\r\nmipi_dsi_generic_write(dsi_device, NULL, 0);\r\nbreak;\r\ncase MIPI_DSI_GENERIC_SHORT_WRITE_1_PARAM:\r\nmipi_dsi_generic_write(dsi_device, data, 1);\r\nbreak;\r\ncase MIPI_DSI_GENERIC_SHORT_WRITE_2_PARAM:\r\nmipi_dsi_generic_write(dsi_device, data, 2);\r\nbreak;\r\ncase MIPI_DSI_GENERIC_READ_REQUEST_0_PARAM:\r\ncase MIPI_DSI_GENERIC_READ_REQUEST_1_PARAM:\r\ncase MIPI_DSI_GENERIC_READ_REQUEST_2_PARAM:\r\nDRM_DEBUG_DRIVER("Generic Read not yet implemented or used\n");\r\nbreak;\r\ncase MIPI_DSI_GENERIC_LONG_WRITE:\r\nmipi_dsi_generic_write(dsi_device, data, len);\r\nbreak;\r\ncase MIPI_DSI_DCS_SHORT_WRITE:\r\nmipi_dsi_dcs_write_buffer(dsi_device, data, 1);\r\nbreak;\r\ncase MIPI_DSI_DCS_SHORT_WRITE_PARAM:\r\nmipi_dsi_dcs_write_buffer(dsi_device, data, 2);\r\nbreak;\r\ncase MIPI_DSI_DCS_READ:\r\nDRM_DEBUG_DRIVER("DCS Read not yet implemented or used\n");\r\nbreak;\r\ncase MIPI_DSI_DCS_LONG_WRITE:\r\nmipi_dsi_dcs_write_buffer(dsi_device, data, len);\r\nbreak;\r\n}\r\nout:\r\ndata += len;\r\nreturn data;\r\n}\r\nstatic const u8 *mipi_exec_delay(struct intel_dsi *intel_dsi, const u8 *data)\r\n{\r\nu32 delay = *((const u32 *) data);\r\nusleep_range(delay, delay + 10);\r\ndata += 4;\r\nreturn data;\r\n}\r\nstatic const u8 *mipi_exec_gpio(struct intel_dsi *intel_dsi, const u8 *data)\r\n{\r\nu8 gpio, action;\r\nu16 function, pad;\r\nu32 val;\r\nstruct drm_device *dev = intel_dsi->base.base.dev;\r\nstruct drm_i915_private *dev_priv = dev->dev_private;\r\ngpio = *data++;\r\naction = *data++;\r\nfunction = gtable[gpio].function_reg;\r\npad = gtable[gpio].pad_reg;\r\nmutex_lock(&dev_priv->dpio_lock);\r\nif (!gtable[gpio].init) {\r\nvlv_gpio_nc_write(dev_priv, function, 0x2000CC00);\r\ngtable[gpio].init = 1;\r\n}\r\nval = 0x4 | action;\r\nvlv_gpio_nc_write(dev_priv, pad, val);\r\nmutex_unlock(&dev_priv->dpio_lock);\r\nreturn data;\r\n}\r\nstatic void generic_exec_sequence(struct intel_dsi *intel_dsi, const u8 *data)\r\n{\r\nfn_mipi_elem_exec mipi_elem_exec;\r\nint index;\r\nif (!data)\r\nreturn;\r\nDRM_DEBUG_DRIVER("Starting MIPI sequence - %s\n", seq_name[*data]);\r\ndata++;\r\nwhile (1) {\r\nindex = *data;\r\nmipi_elem_exec = exec_elem[index];\r\nif (!mipi_elem_exec) {\r\nDRM_ERROR("Unsupported MIPI element, skipping sequence execution\n");\r\nreturn;\r\n}\r\ndata++;\r\ndata = mipi_elem_exec(intel_dsi, data);\r\nif (*data == 0x00)\r\nbreak;\r\n}\r\n}\r\nstatic int vbt_panel_prepare(struct drm_panel *panel)\r\n{\r\nstruct vbt_panel *vbt_panel = to_vbt_panel(panel);\r\nstruct intel_dsi *intel_dsi = vbt_panel->intel_dsi;\r\nstruct drm_device *dev = intel_dsi->base.base.dev;\r\nstruct drm_i915_private *dev_priv = dev->dev_private;\r\nconst u8 *sequence;\r\nsequence = dev_priv->vbt.dsi.sequence[MIPI_SEQ_ASSERT_RESET];\r\ngeneric_exec_sequence(intel_dsi, sequence);\r\nsequence = dev_priv->vbt.dsi.sequence[MIPI_SEQ_INIT_OTP];\r\ngeneric_exec_sequence(intel_dsi, sequence);\r\nreturn 0;\r\n}\r\nstatic int vbt_panel_unprepare(struct drm_panel *panel)\r\n{\r\nstruct vbt_panel *vbt_panel = to_vbt_panel(panel);\r\nstruct intel_dsi *intel_dsi = vbt_panel->intel_dsi;\r\nstruct drm_device *dev = intel_dsi->base.base.dev;\r\nstruct drm_i915_private *dev_priv = dev->dev_private;\r\nconst u8 *sequence;\r\nsequence = dev_priv->vbt.dsi.sequence[MIPI_SEQ_DEASSERT_RESET];\r\ngeneric_exec_sequence(intel_dsi, sequence);\r\nreturn 0;\r\n}\r\nstatic int vbt_panel_enable(struct drm_panel *panel)\r\n{\r\nstruct vbt_panel *vbt_panel = to_vbt_panel(panel);\r\nstruct intel_dsi *intel_dsi = vbt_panel->intel_dsi;\r\nstruct drm_device *dev = intel_dsi->base.base.dev;\r\nstruct drm_i915_private *dev_priv = dev->dev_private;\r\nconst u8 *sequence;\r\nsequence = dev_priv->vbt.dsi.sequence[MIPI_SEQ_DISPLAY_ON];\r\ngeneric_exec_sequence(intel_dsi, sequence);\r\nreturn 0;\r\n}\r\nstatic int vbt_panel_disable(struct drm_panel *panel)\r\n{\r\nstruct vbt_panel *vbt_panel = to_vbt_panel(panel);\r\nstruct intel_dsi *intel_dsi = vbt_panel->intel_dsi;\r\nstruct drm_device *dev = intel_dsi->base.base.dev;\r\nstruct drm_i915_private *dev_priv = dev->dev_private;\r\nconst u8 *sequence;\r\nsequence = dev_priv->vbt.dsi.sequence[MIPI_SEQ_DISPLAY_OFF];\r\ngeneric_exec_sequence(intel_dsi, sequence);\r\nreturn 0;\r\n}\r\nstatic int vbt_panel_get_modes(struct drm_panel *panel)\r\n{\r\nstruct vbt_panel *vbt_panel = to_vbt_panel(panel);\r\nstruct intel_dsi *intel_dsi = vbt_panel->intel_dsi;\r\nstruct drm_device *dev = intel_dsi->base.base.dev;\r\nstruct drm_i915_private *dev_priv = dev->dev_private;\r\nstruct drm_display_mode *mode;\r\nif (!panel->connector)\r\nreturn 0;\r\nmode = drm_mode_duplicate(dev, dev_priv->vbt.lfp_lvds_vbt_mode);\r\nif (!mode)\r\nreturn 0;\r\nmode->type |= DRM_MODE_TYPE_PREFERRED;\r\ndrm_mode_probed_add(panel->connector, mode);\r\nreturn 1;\r\n}\r\nstruct drm_panel *vbt_panel_init(struct intel_dsi *intel_dsi, u16 panel_id)\r\n{\r\nstruct drm_device *dev = intel_dsi->base.base.dev;\r\nstruct drm_i915_private *dev_priv = dev->dev_private;\r\nstruct mipi_config *mipi_config = dev_priv->vbt.dsi.config;\r\nstruct mipi_pps_data *pps = dev_priv->vbt.dsi.pps;\r\nstruct drm_display_mode *mode = dev_priv->vbt.lfp_lvds_vbt_mode;\r\nstruct vbt_panel *vbt_panel;\r\nu32 bits_per_pixel = 24;\r\nu32 tlpx_ns, extra_byte_count, bitrate, tlpx_ui;\r\nu32 ui_num, ui_den;\r\nu32 prepare_cnt, exit_zero_cnt, clk_zero_cnt, trail_cnt;\r\nu32 ths_prepare_ns, tclk_trail_ns;\r\nu32 tclk_prepare_clkzero, ths_prepare_hszero;\r\nu32 lp_to_hs_switch, hs_to_lp_switch;\r\nu32 pclk, computed_ddr;\r\nu16 burst_mode_ratio;\r\nenum port port;\r\nDRM_DEBUG_KMS("\n");\r\nintel_dsi->eotp_pkt = mipi_config->eot_pkt_disabled ? 0 : 1;\r\nintel_dsi->clock_stop = mipi_config->enable_clk_stop ? 1 : 0;\r\nintel_dsi->lane_count = mipi_config->lane_cnt + 1;\r\nintel_dsi->pixel_format = mipi_config->videomode_color_format << 7;\r\nintel_dsi->dual_link = mipi_config->dual_link;\r\nintel_dsi->pixel_overlap = mipi_config->pixel_overlap;\r\nif (intel_dsi->pixel_format == VID_MODE_FORMAT_RGB666)\r\nbits_per_pixel = 18;\r\nelse if (intel_dsi->pixel_format == VID_MODE_FORMAT_RGB565)\r\nbits_per_pixel = 16;\r\nintel_dsi->operation_mode = mipi_config->is_cmd_mode;\r\nintel_dsi->video_mode_format = mipi_config->video_transfer_mode;\r\nintel_dsi->escape_clk_div = mipi_config->byte_clk_sel;\r\nintel_dsi->lp_rx_timeout = mipi_config->lp_rx_timeout;\r\nintel_dsi->turn_arnd_val = mipi_config->turn_around_timeout;\r\nintel_dsi->rst_timer_val = mipi_config->device_reset_timer;\r\nintel_dsi->init_count = mipi_config->master_init_timer;\r\nintel_dsi->bw_timer = mipi_config->dbi_bw_timer;\r\nintel_dsi->video_frmt_cfg_bits =\r\nmipi_config->bta_enabled ? DISABLE_VIDEO_BTA : 0;\r\npclk = mode->clock;\r\nif (intel_dsi->dual_link) {\r\npclk = pclk / 2;\r\nif (intel_dsi->dual_link == DSI_DUAL_LINK_FRONT_BACK) {\r\npclk += DIV_ROUND_UP(mode->vtotal *\r\nintel_dsi->pixel_overlap *\r\n60, 1000);\r\n}\r\n}\r\nif (intel_dsi->video_mode_format == VIDEO_MODE_BURST) {\r\nif (mipi_config->target_burst_mode_freq) {\r\ncomputed_ddr =\r\n(pclk * bits_per_pixel) / intel_dsi->lane_count;\r\nif (mipi_config->target_burst_mode_freq <\r\ncomputed_ddr) {\r\nDRM_ERROR("Burst mode freq is less than computed\n");\r\nreturn NULL;\r\n}\r\nburst_mode_ratio = DIV_ROUND_UP(\r\nmipi_config->target_burst_mode_freq * 100,\r\ncomputed_ddr);\r\npclk = DIV_ROUND_UP(pclk * burst_mode_ratio, 100);\r\n} else {\r\nDRM_ERROR("Burst mode target is not set\n");\r\nreturn NULL;\r\n}\r\n} else\r\nburst_mode_ratio = 100;\r\nintel_dsi->burst_mode_ratio = burst_mode_ratio;\r\nintel_dsi->pclk = pclk;\r\nbitrate = (pclk * bits_per_pixel) / intel_dsi->lane_count;\r\nswitch (intel_dsi->escape_clk_div) {\r\ncase 0:\r\ntlpx_ns = 50;\r\nbreak;\r\ncase 1:\r\ntlpx_ns = 100;\r\nbreak;\r\ncase 2:\r\ntlpx_ns = 200;\r\nbreak;\r\ndefault:\r\ntlpx_ns = 50;\r\nbreak;\r\n}\r\nswitch (intel_dsi->lane_count) {\r\ncase 1:\r\ncase 2:\r\nextra_byte_count = 2;\r\nbreak;\r\ncase 3:\r\nextra_byte_count = 4;\r\nbreak;\r\ncase 4:\r\ndefault:\r\nextra_byte_count = 3;\r\nbreak;\r\n}\r\nui_num = NS_KHZ_RATIO;\r\nui_den = bitrate;\r\ntclk_prepare_clkzero = mipi_config->tclk_prepare_clkzero;\r\nths_prepare_hszero = mipi_config->ths_prepare_hszero;\r\nintel_dsi->lp_byte_clk = DIV_ROUND_UP(tlpx_ns * ui_den, 8 * ui_num);\r\nths_prepare_ns = max(mipi_config->ths_prepare,\r\nmipi_config->tclk_prepare);\r\nprepare_cnt = DIV_ROUND_UP(ths_prepare_ns * ui_den, ui_num * 2);\r\nexit_zero_cnt = DIV_ROUND_UP(\r\n(ths_prepare_hszero - ths_prepare_ns) * ui_den,\r\nui_num * 2\r\n);\r\nif (exit_zero_cnt < (55 * ui_den / ui_num))\r\nif ((55 * ui_den) % ui_num)\r\nexit_zero_cnt += 1;\r\nclk_zero_cnt = DIV_ROUND_UP(\r\n(tclk_prepare_clkzero - ths_prepare_ns)\r\n* ui_den, 2 * ui_num);\r\ntclk_trail_ns = max(mipi_config->tclk_trail, mipi_config->ths_trail);\r\ntrail_cnt = DIV_ROUND_UP(tclk_trail_ns * ui_den, 2 * ui_num);\r\nif (prepare_cnt > PREPARE_CNT_MAX ||\r\nexit_zero_cnt > EXIT_ZERO_CNT_MAX ||\r\nclk_zero_cnt > CLK_ZERO_CNT_MAX ||\r\ntrail_cnt > TRAIL_CNT_MAX)\r\nDRM_DEBUG_DRIVER("Values crossing maximum limits, restricting to max values\n");\r\nif (prepare_cnt > PREPARE_CNT_MAX)\r\nprepare_cnt = PREPARE_CNT_MAX;\r\nif (exit_zero_cnt > EXIT_ZERO_CNT_MAX)\r\nexit_zero_cnt = EXIT_ZERO_CNT_MAX;\r\nif (clk_zero_cnt > CLK_ZERO_CNT_MAX)\r\nclk_zero_cnt = CLK_ZERO_CNT_MAX;\r\nif (trail_cnt > TRAIL_CNT_MAX)\r\ntrail_cnt = TRAIL_CNT_MAX;\r\nintel_dsi->dphy_reg = exit_zero_cnt << 24 | trail_cnt << 16 |\r\nclk_zero_cnt << 8 | prepare_cnt;\r\ntlpx_ui = DIV_ROUND_UP(tlpx_ns * ui_den, ui_num);\r\nlp_to_hs_switch = DIV_ROUND_UP(4 * tlpx_ui + prepare_cnt * 2 +\r\nexit_zero_cnt * 2 + 10, 8);\r\nhs_to_lp_switch = DIV_ROUND_UP(mipi_config->ths_trail + 2 * tlpx_ui, 8);\r\nintel_dsi->hs_to_lp_count = max(lp_to_hs_switch, hs_to_lp_switch);\r\nintel_dsi->hs_to_lp_count += extra_byte_count;\r\nintel_dsi->clk_lp_to_hs_count =\r\nDIV_ROUND_UP(\r\n4 * tlpx_ui + prepare_cnt * 2 +\r\nclk_zero_cnt * 2,\r\n8);\r\nintel_dsi->clk_lp_to_hs_count += extra_byte_count;\r\nintel_dsi->clk_hs_to_lp_count =\r\nDIV_ROUND_UP(2 * tlpx_ui + trail_cnt * 2 + 8,\r\n8);\r\nintel_dsi->clk_hs_to_lp_count += extra_byte_count;\r\nDRM_DEBUG_KMS("Eot %s\n", intel_dsi->eotp_pkt ? "enabled" : "disabled");\r\nDRM_DEBUG_KMS("Clockstop %s\n", intel_dsi->clock_stop ?\r\n"disabled" : "enabled");\r\nDRM_DEBUG_KMS("Mode %s\n", intel_dsi->operation_mode ? "command" : "video");\r\nif (intel_dsi->dual_link == DSI_DUAL_LINK_FRONT_BACK)\r\nDRM_DEBUG_KMS("Dual link: DSI_DUAL_LINK_FRONT_BACK\n");\r\nelse if (intel_dsi->dual_link == DSI_DUAL_LINK_PIXEL_ALT)\r\nDRM_DEBUG_KMS("Dual link: DSI_DUAL_LINK_PIXEL_ALT\n");\r\nelse\r\nDRM_DEBUG_KMS("Dual link: NONE\n");\r\nDRM_DEBUG_KMS("Pixel Format %d\n", intel_dsi->pixel_format);\r\nDRM_DEBUG_KMS("TLPX %d\n", intel_dsi->escape_clk_div);\r\nDRM_DEBUG_KMS("LP RX Timeout 0x%x\n", intel_dsi->lp_rx_timeout);\r\nDRM_DEBUG_KMS("Turnaround Timeout 0x%x\n", intel_dsi->turn_arnd_val);\r\nDRM_DEBUG_KMS("Init Count 0x%x\n", intel_dsi->init_count);\r\nDRM_DEBUG_KMS("HS to LP Count 0x%x\n", intel_dsi->hs_to_lp_count);\r\nDRM_DEBUG_KMS("LP Byte Clock %d\n", intel_dsi->lp_byte_clk);\r\nDRM_DEBUG_KMS("DBI BW Timer 0x%x\n", intel_dsi->bw_timer);\r\nDRM_DEBUG_KMS("LP to HS Clock Count 0x%x\n", intel_dsi->clk_lp_to_hs_count);\r\nDRM_DEBUG_KMS("HS to LP Clock Count 0x%x\n", intel_dsi->clk_hs_to_lp_count);\r\nDRM_DEBUG_KMS("BTA %s\n",\r\nintel_dsi->video_frmt_cfg_bits & DISABLE_VIDEO_BTA ?\r\n"disabled" : "enabled");\r\nintel_dsi->backlight_off_delay = pps->bl_disable_delay / 10;\r\nintel_dsi->backlight_on_delay = pps->bl_enable_delay / 10;\r\nintel_dsi->panel_on_delay = pps->panel_on_delay / 10;\r\nintel_dsi->panel_off_delay = pps->panel_off_delay / 10;\r\nintel_dsi->panel_pwr_cycle_delay = pps->panel_power_cycle_delay / 10;\r\nvbt_panel = devm_kzalloc(dev->dev, sizeof(*vbt_panel), GFP_KERNEL);\r\nvbt_panel->intel_dsi = intel_dsi;\r\ndrm_panel_init(&vbt_panel->panel);\r\nvbt_panel->panel.funcs = &vbt_panel_funcs;\r\ndrm_panel_add(&vbt_panel->panel);\r\nfor_each_dsi_port(port, intel_dsi->ports) {\r\nmipi_dsi_attach(intel_dsi->dsi_hosts[port]->device);\r\n}\r\nreturn &vbt_panel->panel;\r\n}
