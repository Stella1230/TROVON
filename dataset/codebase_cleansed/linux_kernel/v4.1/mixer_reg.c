static inline u32 vp_read(struct mxr_device *mdev, u32 reg_id)\r\n{\r\nreturn readl(mdev->res.vp_regs + reg_id);\r\n}\r\nstatic inline void vp_write(struct mxr_device *mdev, u32 reg_id, u32 val)\r\n{\r\nwritel(val, mdev->res.vp_regs + reg_id);\r\n}\r\nstatic inline void vp_write_mask(struct mxr_device *mdev, u32 reg_id,\r\nu32 val, u32 mask)\r\n{\r\nu32 old = vp_read(mdev, reg_id);\r\nval = (val & mask) | (old & ~mask);\r\nwritel(val, mdev->res.vp_regs + reg_id);\r\n}\r\nstatic inline u32 mxr_read(struct mxr_device *mdev, u32 reg_id)\r\n{\r\nreturn readl(mdev->res.mxr_regs + reg_id);\r\n}\r\nstatic inline void mxr_write(struct mxr_device *mdev, u32 reg_id, u32 val)\r\n{\r\nwritel(val, mdev->res.mxr_regs + reg_id);\r\n}\r\nstatic inline void mxr_write_mask(struct mxr_device *mdev, u32 reg_id,\r\nu32 val, u32 mask)\r\n{\r\nu32 old = mxr_read(mdev, reg_id);\r\nval = (val & mask) | (old & ~mask);\r\nwritel(val, mdev->res.mxr_regs + reg_id);\r\n}\r\nvoid mxr_vsync_set_update(struct mxr_device *mdev, int en)\r\n{\r\nmxr_write_mask(mdev, MXR_STATUS, en ? MXR_STATUS_SYNC_ENABLE : 0,\r\nMXR_STATUS_SYNC_ENABLE);\r\nvp_write(mdev, VP_SHADOW_UPDATE, en ? VP_SHADOW_UPDATE_ENABLE : 0);\r\n}\r\nstatic void __mxr_reg_vp_reset(struct mxr_device *mdev)\r\n{\r\nint tries = 100;\r\nvp_write(mdev, VP_SRESET, VP_SRESET_PROCESSING);\r\nfor (tries = 100; tries; --tries) {\r\nif (~vp_read(mdev, VP_SRESET) & VP_SRESET_PROCESSING)\r\nbreak;\r\nmdelay(10);\r\n}\r\nWARN(tries == 0, "failed to reset Video Processor\n");\r\n}\r\nvoid mxr_reg_reset(struct mxr_device *mdev)\r\n{\r\nunsigned long flags;\r\nu32 val;\r\nspin_lock_irqsave(&mdev->reg_slock, flags);\r\nmxr_vsync_set_update(mdev, MXR_DISABLE);\r\nmxr_write(mdev, MXR_CFG, MXR_CFG_OUT_RGB888);\r\nmxr_write_mask(mdev, MXR_STATUS, MXR_STATUS_16_BURST,\r\nMXR_STATUS_BURST_MASK);\r\nval = MXR_LAYER_CFG_GRP0_VAL(1);\r\nval |= MXR_LAYER_CFG_VP_VAL(2);\r\nval |= MXR_LAYER_CFG_GRP1_VAL(3);\r\nmxr_write(mdev, MXR_LAYER_CFG, val);\r\nmxr_write(mdev, MXR_BG_COLOR0, 0x808080);\r\nmxr_write(mdev, MXR_BG_COLOR1, 0x808080);\r\nmxr_write(mdev, MXR_BG_COLOR2, 0x808080);\r\nval = MXR_GRP_CFG_COLOR_KEY_DISABLE;\r\nval |= MXR_GRP_CFG_BLEND_PRE_MUL;\r\nval |= MXR_GRP_CFG_ALPHA_VAL(0xff);\r\nmxr_write(mdev, MXR_GRAPHIC_CFG(0), val);\r\nmxr_write(mdev, MXR_GRAPHIC_CFG(1), val);\r\n__mxr_reg_vp_reset(mdev);\r\nmxr_reg_vp_default_filter(mdev);\r\nmxr_write_mask(mdev, MXR_INT_EN, ~0, MXR_INT_EN_ALL);\r\nmxr_vsync_set_update(mdev, MXR_ENABLE);\r\nspin_unlock_irqrestore(&mdev->reg_slock, flags);\r\n}\r\nvoid mxr_reg_graph_format(struct mxr_device *mdev, int idx,\r\nconst struct mxr_format *fmt, const struct mxr_geometry *geo)\r\n{\r\nu32 val;\r\nunsigned long flags;\r\nspin_lock_irqsave(&mdev->reg_slock, flags);\r\nmxr_vsync_set_update(mdev, MXR_DISABLE);\r\nmxr_write_mask(mdev, MXR_GRAPHIC_CFG(idx),\r\nMXR_GRP_CFG_FORMAT_VAL(fmt->cookie), MXR_GRP_CFG_FORMAT_MASK);\r\nmxr_write(mdev, MXR_GRAPHIC_SPAN(idx), geo->src.full_width);\r\nval = MXR_GRP_WH_WIDTH(geo->src.width);\r\nval |= MXR_GRP_WH_HEIGHT(geo->src.height);\r\nval |= MXR_GRP_WH_H_SCALE(geo->x_ratio);\r\nval |= MXR_GRP_WH_V_SCALE(geo->y_ratio);\r\nmxr_write(mdev, MXR_GRAPHIC_WH(idx), val);\r\nval = MXR_GRP_SXY_SX(geo->src.x_offset);\r\nval |= MXR_GRP_SXY_SY(geo->src.y_offset);\r\nmxr_write(mdev, MXR_GRAPHIC_SXY(idx), val);\r\nval = MXR_GRP_DXY_DX(geo->dst.x_offset);\r\nval |= MXR_GRP_DXY_DY(geo->dst.y_offset);\r\nmxr_write(mdev, MXR_GRAPHIC_DXY(idx), val);\r\nmxr_vsync_set_update(mdev, MXR_ENABLE);\r\nspin_unlock_irqrestore(&mdev->reg_slock, flags);\r\n}\r\nvoid mxr_reg_vp_format(struct mxr_device *mdev,\r\nconst struct mxr_format *fmt, const struct mxr_geometry *geo)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&mdev->reg_slock, flags);\r\nmxr_vsync_set_update(mdev, MXR_DISABLE);\r\nvp_write_mask(mdev, VP_MODE, fmt->cookie, VP_MODE_FMT_MASK);\r\nvp_write(mdev, VP_IMG_SIZE_Y, VP_IMG_HSIZE(geo->src.full_width) |\r\nVP_IMG_VSIZE(geo->src.full_height));\r\nvp_write(mdev, VP_IMG_SIZE_C, VP_IMG_HSIZE(geo->src.full_width) |\r\nVP_IMG_VSIZE(geo->src.full_height / 2));\r\nvp_write(mdev, VP_SRC_WIDTH, geo->src.width);\r\nvp_write(mdev, VP_SRC_HEIGHT, geo->src.height);\r\nvp_write(mdev, VP_SRC_H_POSITION,\r\nVP_SRC_H_POSITION_VAL(geo->src.x_offset));\r\nvp_write(mdev, VP_SRC_V_POSITION, geo->src.y_offset);\r\nvp_write(mdev, VP_DST_WIDTH, geo->dst.width);\r\nvp_write(mdev, VP_DST_H_POSITION, geo->dst.x_offset);\r\nif (geo->dst.field == V4L2_FIELD_INTERLACED) {\r\nvp_write(mdev, VP_DST_HEIGHT, geo->dst.height / 2);\r\nvp_write(mdev, VP_DST_V_POSITION, geo->dst.y_offset / 2);\r\n} else {\r\nvp_write(mdev, VP_DST_HEIGHT, geo->dst.height);\r\nvp_write(mdev, VP_DST_V_POSITION, geo->dst.y_offset);\r\n}\r\nvp_write(mdev, VP_H_RATIO, geo->x_ratio);\r\nvp_write(mdev, VP_V_RATIO, geo->y_ratio);\r\nvp_write(mdev, VP_ENDIAN_MODE, VP_ENDIAN_MODE_LITTLE);\r\nmxr_vsync_set_update(mdev, MXR_ENABLE);\r\nspin_unlock_irqrestore(&mdev->reg_slock, flags);\r\n}\r\nvoid mxr_reg_graph_buffer(struct mxr_device *mdev, int idx, dma_addr_t addr)\r\n{\r\nu32 val = addr ? ~0 : 0;\r\nunsigned long flags;\r\nspin_lock_irqsave(&mdev->reg_slock, flags);\r\nmxr_vsync_set_update(mdev, MXR_DISABLE);\r\nif (idx == 0)\r\nmxr_write_mask(mdev, MXR_CFG, val, MXR_CFG_GRP0_ENABLE);\r\nelse\r\nmxr_write_mask(mdev, MXR_CFG, val, MXR_CFG_GRP1_ENABLE);\r\nmxr_write(mdev, MXR_GRAPHIC_BASE(idx), addr);\r\nmxr_vsync_set_update(mdev, MXR_ENABLE);\r\nspin_unlock_irqrestore(&mdev->reg_slock, flags);\r\n}\r\nvoid mxr_reg_vp_buffer(struct mxr_device *mdev,\r\ndma_addr_t luma_addr[2], dma_addr_t chroma_addr[2])\r\n{\r\nu32 val = luma_addr[0] ? ~0 : 0;\r\nunsigned long flags;\r\nspin_lock_irqsave(&mdev->reg_slock, flags);\r\nmxr_vsync_set_update(mdev, MXR_DISABLE);\r\nmxr_write_mask(mdev, MXR_CFG, val, MXR_CFG_VP_ENABLE);\r\nvp_write_mask(mdev, VP_ENABLE, val, VP_ENABLE_ON);\r\nvp_write(mdev, VP_TOP_Y_PTR, luma_addr[0]);\r\nvp_write(mdev, VP_TOP_C_PTR, chroma_addr[0]);\r\nvp_write(mdev, VP_BOT_Y_PTR, luma_addr[1]);\r\nvp_write(mdev, VP_BOT_C_PTR, chroma_addr[1]);\r\nmxr_vsync_set_update(mdev, MXR_ENABLE);\r\nspin_unlock_irqrestore(&mdev->reg_slock, flags);\r\n}\r\nstatic void mxr_irq_layer_handle(struct mxr_layer *layer)\r\n{\r\nstruct list_head *head = &layer->enq_list;\r\nstruct mxr_buffer *done;\r\nif (layer == NULL)\r\nreturn;\r\nspin_lock(&layer->enq_slock);\r\nif (layer->state == MXR_LAYER_IDLE)\r\ngoto done;\r\ndone = layer->shadow_buf;\r\nlayer->shadow_buf = layer->update_buf;\r\nif (list_empty(head)) {\r\nif (layer->state != MXR_LAYER_STREAMING)\r\nlayer->update_buf = NULL;\r\n} else {\r\nstruct mxr_buffer *next;\r\nnext = list_first_entry(head, struct mxr_buffer, list);\r\nlist_del(&next->list);\r\nlayer->update_buf = next;\r\n}\r\nlayer->ops.buffer_set(layer, layer->update_buf);\r\nif (done && done != layer->shadow_buf)\r\nvb2_buffer_done(&done->vb, VB2_BUF_STATE_DONE);\r\ndone:\r\nspin_unlock(&layer->enq_slock);\r\n}\r\nirqreturn_t mxr_irq_handler(int irq, void *dev_data)\r\n{\r\nstruct mxr_device *mdev = dev_data;\r\nu32 i, val;\r\nspin_lock(&mdev->reg_slock);\r\nval = mxr_read(mdev, MXR_INT_STATUS);\r\nif (val & MXR_INT_STATUS_VSYNC) {\r\nset_bit(MXR_EVENT_VSYNC, &mdev->event_flags);\r\nif (~mxr_read(mdev, MXR_CFG) & MXR_CFG_SCAN_PROGRASSIVE)\r\nchange_bit(MXR_EVENT_TOP, &mdev->event_flags);\r\nwake_up(&mdev->event_queue);\r\nval &= ~MXR_INT_STATUS_VSYNC;\r\nval |= MXR_INT_CLEAR_VSYNC;\r\n}\r\nmxr_write(mdev, MXR_INT_STATUS, val);\r\nspin_unlock(&mdev->reg_slock);\r\nif (~val & MXR_INT_CLEAR_VSYNC)\r\nreturn IRQ_HANDLED;\r\nif (!test_bit(MXR_EVENT_TOP, &mdev->event_flags))\r\nreturn IRQ_HANDLED;\r\nfor (i = 0; i < MXR_MAX_LAYERS; ++i)\r\nmxr_irq_layer_handle(mdev->layer[i]);\r\nreturn IRQ_HANDLED;\r\n}\r\nvoid mxr_reg_s_output(struct mxr_device *mdev, int cookie)\r\n{\r\nu32 val;\r\nval = cookie == 0 ? MXR_CFG_DST_SDO : MXR_CFG_DST_HDMI;\r\nmxr_write_mask(mdev, MXR_CFG, val, MXR_CFG_DST_MASK);\r\n}\r\nvoid mxr_reg_streamon(struct mxr_device *mdev)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&mdev->reg_slock, flags);\r\nmxr_write_mask(mdev, MXR_STATUS, ~0, MXR_STATUS_REG_RUN);\r\nset_bit(MXR_EVENT_TOP, &mdev->event_flags);\r\nspin_unlock_irqrestore(&mdev->reg_slock, flags);\r\n}\r\nvoid mxr_reg_streamoff(struct mxr_device *mdev)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&mdev->reg_slock, flags);\r\nmxr_write_mask(mdev, MXR_STATUS, 0, MXR_STATUS_REG_RUN);\r\nspin_unlock_irqrestore(&mdev->reg_slock, flags);\r\n}\r\nint mxr_reg_wait4vsync(struct mxr_device *mdev)\r\n{\r\nint ret;\r\nclear_bit(MXR_EVENT_VSYNC, &mdev->event_flags);\r\nret = wait_event_timeout(mdev->event_queue,\r\ntest_bit(MXR_EVENT_VSYNC, &mdev->event_flags),\r\nmsecs_to_jiffies(1000));\r\nif (ret > 0)\r\nreturn 0;\r\nif (ret < 0)\r\nreturn ret;\r\nmxr_warn(mdev, "no vsync detected - timeout\n");\r\nreturn -ETIME;\r\n}\r\nvoid mxr_reg_set_mbus_fmt(struct mxr_device *mdev,\r\nstruct v4l2_mbus_framefmt *fmt)\r\n{\r\nu32 val = 0;\r\nunsigned long flags;\r\nspin_lock_irqsave(&mdev->reg_slock, flags);\r\nmxr_vsync_set_update(mdev, MXR_DISABLE);\r\nif (fmt->colorspace == V4L2_COLORSPACE_JPEG)\r\nval |= MXR_CFG_OUT_YUV444;\r\nelse\r\nval |= MXR_CFG_OUT_RGB888;\r\nif (fmt->field == V4L2_FIELD_INTERLACED)\r\nval |= MXR_CFG_SCAN_INTERLACE;\r\nelse\r\nval |= MXR_CFG_SCAN_PROGRASSIVE;\r\nif (fmt->height == 480)\r\nval |= MXR_CFG_SCAN_NTSC | MXR_CFG_SCAN_SD;\r\nelse if (fmt->height == 576)\r\nval |= MXR_CFG_SCAN_PAL | MXR_CFG_SCAN_SD;\r\nelse if (fmt->height == 720)\r\nval |= MXR_CFG_SCAN_HD_720 | MXR_CFG_SCAN_HD;\r\nelse if (fmt->height == 1080)\r\nval |= MXR_CFG_SCAN_HD_1080 | MXR_CFG_SCAN_HD;\r\nelse\r\nWARN(1, "unrecognized mbus height %u!\n", fmt->height);\r\nmxr_write_mask(mdev, MXR_CFG, val, MXR_CFG_SCAN_MASK |\r\nMXR_CFG_OUT_MASK);\r\nval = (fmt->field == V4L2_FIELD_INTERLACED) ? ~0 : 0;\r\nvp_write_mask(mdev, VP_MODE, val,\r\nVP_MODE_LINE_SKIP | VP_MODE_FIELD_ID_AUTO_TOGGLING);\r\nmxr_vsync_set_update(mdev, MXR_ENABLE);\r\nspin_unlock_irqrestore(&mdev->reg_slock, flags);\r\n}\r\nvoid mxr_reg_graph_layer_stream(struct mxr_device *mdev, int idx, int en)\r\n{\r\n}\r\nvoid mxr_reg_vp_layer_stream(struct mxr_device *mdev, int en)\r\n{\r\n}\r\nstatic inline void mxr_reg_vp_filter_set(struct mxr_device *mdev,\r\nint reg_id, const u8 *data, unsigned int size)\r\n{\r\nBUG_ON(size & 3);\r\nfor (; size; size -= 4, reg_id += 4, data += 4) {\r\nu32 val = (data[0] << 24) | (data[1] << 16) |\r\n(data[2] << 8) | data[3];\r\nvp_write(mdev, reg_id, val);\r\n}\r\n}\r\nstatic void mxr_reg_vp_default_filter(struct mxr_device *mdev)\r\n{\r\nmxr_reg_vp_filter_set(mdev, VP_POLY8_Y0_LL,\r\nfilter_y_horiz_tap8, sizeof(filter_y_horiz_tap8));\r\nmxr_reg_vp_filter_set(mdev, VP_POLY4_Y0_LL,\r\nfilter_y_vert_tap4, sizeof(filter_y_vert_tap4));\r\nmxr_reg_vp_filter_set(mdev, VP_POLY4_C0_LL,\r\nfilter_cr_horiz_tap4, sizeof(filter_cr_horiz_tap4));\r\n}\r\nstatic void mxr_reg_mxr_dump(struct mxr_device *mdev)\r\n{\r\n#define DUMPREG(reg_id) \\r\ndo { \\r\nmxr_dbg(mdev, #reg_id " = %08x\n", \\r\n(u32)readl(mdev->res.mxr_regs + reg_id)); \\r\n} while (0)\r\nDUMPREG(MXR_STATUS);\r\nDUMPREG(MXR_CFG);\r\nDUMPREG(MXR_INT_EN);\r\nDUMPREG(MXR_INT_STATUS);\r\nDUMPREG(MXR_LAYER_CFG);\r\nDUMPREG(MXR_VIDEO_CFG);\r\nDUMPREG(MXR_GRAPHIC0_CFG);\r\nDUMPREG(MXR_GRAPHIC0_BASE);\r\nDUMPREG(MXR_GRAPHIC0_SPAN);\r\nDUMPREG(MXR_GRAPHIC0_WH);\r\nDUMPREG(MXR_GRAPHIC0_SXY);\r\nDUMPREG(MXR_GRAPHIC0_DXY);\r\nDUMPREG(MXR_GRAPHIC1_CFG);\r\nDUMPREG(MXR_GRAPHIC1_BASE);\r\nDUMPREG(MXR_GRAPHIC1_SPAN);\r\nDUMPREG(MXR_GRAPHIC1_WH);\r\nDUMPREG(MXR_GRAPHIC1_SXY);\r\nDUMPREG(MXR_GRAPHIC1_DXY);\r\n#undef DUMPREG\r\n}\r\nstatic void mxr_reg_vp_dump(struct mxr_device *mdev)\r\n{\r\n#define DUMPREG(reg_id) \\r\ndo { \\r\nmxr_dbg(mdev, #reg_id " = %08x\n", \\r\n(u32) readl(mdev->res.vp_regs + reg_id)); \\r\n} while (0)\r\nDUMPREG(VP_ENABLE);\r\nDUMPREG(VP_SRESET);\r\nDUMPREG(VP_SHADOW_UPDATE);\r\nDUMPREG(VP_FIELD_ID);\r\nDUMPREG(VP_MODE);\r\nDUMPREG(VP_IMG_SIZE_Y);\r\nDUMPREG(VP_IMG_SIZE_C);\r\nDUMPREG(VP_PER_RATE_CTRL);\r\nDUMPREG(VP_TOP_Y_PTR);\r\nDUMPREG(VP_BOT_Y_PTR);\r\nDUMPREG(VP_TOP_C_PTR);\r\nDUMPREG(VP_BOT_C_PTR);\r\nDUMPREG(VP_ENDIAN_MODE);\r\nDUMPREG(VP_SRC_H_POSITION);\r\nDUMPREG(VP_SRC_V_POSITION);\r\nDUMPREG(VP_SRC_WIDTH);\r\nDUMPREG(VP_SRC_HEIGHT);\r\nDUMPREG(VP_DST_H_POSITION);\r\nDUMPREG(VP_DST_V_POSITION);\r\nDUMPREG(VP_DST_WIDTH);\r\nDUMPREG(VP_DST_HEIGHT);\r\nDUMPREG(VP_H_RATIO);\r\nDUMPREG(VP_V_RATIO);\r\n#undef DUMPREG\r\n}\r\nvoid mxr_reg_dump(struct mxr_device *mdev)\r\n{\r\nmxr_reg_mxr_dump(mdev);\r\nmxr_reg_vp_dump(mdev);\r\n}
