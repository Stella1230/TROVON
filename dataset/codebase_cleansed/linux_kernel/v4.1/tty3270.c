static void tty3270_set_timer(struct tty3270 *tp, int expires)\r\n{\r\nmod_timer(&tp->timer, jiffies + expires);\r\n}\r\nstatic void\r\ntty3270_update_prompt(struct tty3270 *tp, char *input, int count)\r\n{\r\nstruct string *line;\r\nunsigned int off;\r\nline = tp->prompt;\r\nif (count != 0)\r\nline->string[5] = TF_INMDT;\r\nelse\r\nline->string[5] = tp->inattr;\r\nif (count > tp->view.cols * 2 - 11)\r\ncount = tp->view.cols * 2 - 11;\r\nmemcpy(line->string + 6, input, count);\r\nline->string[6 + count] = TO_IC;\r\nif (count < tp->view.cols * 2 - 11) {\r\nline->string[7 + count] = TO_RA;\r\nline->string[10 + count] = 0;\r\noff = tp->view.cols * tp->view.rows - 9;\r\nraw3270_buffer_address(tp->view.dev, line->string+count+8, off);\r\nline->len = 11 + count;\r\n} else\r\nline->len = 7 + count;\r\ntp->update_flags |= TTY_UPDATE_INPUT;\r\n}\r\nstatic void\r\ntty3270_create_prompt(struct tty3270 *tp)\r\n{\r\nstatic const unsigned char blueprint[] =\r\n{ TO_SBA, 0, 0, 0x6e, TO_SF, TF_INPUT,\r\nTO_IC, TO_RA, 0, 0, 0 };\r\nstruct string *line;\r\nunsigned int offset;\r\nline = alloc_string(&tp->freemem,\r\nsizeof(blueprint) + tp->view.cols * 2 - 9);\r\ntp->prompt = line;\r\ntp->inattr = TF_INPUT;\r\nmemcpy(line->string, blueprint, sizeof(blueprint));\r\nline->len = sizeof(blueprint);\r\noffset = tp->view.cols * (tp->view.rows - 2);\r\nraw3270_buffer_address(tp->view.dev, line->string + 1, offset);\r\noffset = tp->view.cols * tp->view.rows - 9;\r\nraw3270_buffer_address(tp->view.dev, line->string + 8, offset);\r\ntp->input = alloc_string(&tp->freemem, tp->view.cols * 2 - 9 + 6);\r\n}\r\nstatic void\r\ntty3270_update_status(struct tty3270 * tp)\r\n{\r\nchar *str;\r\nstr = (tp->nr_up != 0) ? "History" : "Running";\r\nmemcpy(tp->status->string + 8, str, 7);\r\ncodepage_convert(tp->view.ascebc, tp->status->string + 8, 7);\r\ntp->update_flags |= TTY_UPDATE_STATUS;\r\n}\r\nstatic void\r\ntty3270_create_status(struct tty3270 * tp)\r\n{\r\nstatic const unsigned char blueprint[] =\r\n{ TO_SBA, 0, 0, TO_SF, TF_LOG, TO_SA, TAT_COLOR, TAC_GREEN,\r\n0, 0, 0, 0, 0, 0, 0, TO_SF, TF_LOG, TO_SA, TAT_COLOR,\r\nTAC_RESET };\r\nstruct string *line;\r\nunsigned int offset;\r\nline = alloc_string(&tp->freemem,sizeof(blueprint));\r\ntp->status = line;\r\nmemcpy(line->string, blueprint, sizeof(blueprint));\r\noffset = tp->view.cols * tp->view.rows - 9;\r\nraw3270_buffer_address(tp->view.dev, line->string + 1, offset);\r\n}\r\nstatic void\r\ntty3270_update_string(struct tty3270 *tp, struct string *line, int nr)\r\n{\r\nunsigned char *cp;\r\nraw3270_buffer_address(tp->view.dev, line->string + 1,\r\ntp->view.cols * nr);\r\ncp = line->string + line->len - 4;\r\nif (*cp == TO_RA)\r\nraw3270_buffer_address(tp->view.dev, cp + 1,\r\ntp->view.cols * (nr + 1));\r\n}\r\nstatic void\r\ntty3270_rebuild_update(struct tty3270 *tp)\r\n{\r\nstruct string *s, *n;\r\nint line, nr_up;\r\nlist_for_each_entry_safe(s, n, &tp->update, update)\r\nlist_del_init(&s->update);\r\nline = tp->view.rows - 3;\r\nnr_up = tp->nr_up;\r\nlist_for_each_entry_reverse(s, &tp->lines, list) {\r\nif (nr_up > 0) {\r\nnr_up--;\r\ncontinue;\r\n}\r\ntty3270_update_string(tp, s, line);\r\nlist_add(&s->update, &tp->update);\r\nif (--line < 0)\r\nbreak;\r\n}\r\ntp->update_flags |= TTY_UPDATE_LIST;\r\n}\r\nstatic struct string *\r\ntty3270_alloc_string(struct tty3270 *tp, size_t size)\r\n{\r\nstruct string *s, *n;\r\ns = alloc_string(&tp->freemem, size);\r\nif (s)\r\nreturn s;\r\nlist_for_each_entry_safe(s, n, &tp->lines, list) {\r\nBUG_ON(tp->nr_lines <= tp->view.rows - 2);\r\nlist_del(&s->list);\r\nif (!list_empty(&s->update))\r\nlist_del(&s->update);\r\ntp->nr_lines--;\r\nif (free_string(&tp->freemem, s) >= size)\r\nbreak;\r\n}\r\ns = alloc_string(&tp->freemem, size);\r\nBUG_ON(!s);\r\nif (tp->nr_up != 0 &&\r\ntp->nr_up + tp->view.rows - 2 >= tp->nr_lines) {\r\ntp->nr_up = tp->nr_lines - tp->view.rows + 2;\r\ntty3270_rebuild_update(tp);\r\ntty3270_update_status(tp);\r\n}\r\nreturn s;\r\n}\r\nstatic void\r\ntty3270_blank_line(struct tty3270 *tp)\r\n{\r\nstatic const unsigned char blueprint[] =\r\n{ TO_SBA, 0, 0, TO_SA, TAT_EXTHI, TAX_RESET,\r\nTO_SA, TAT_COLOR, TAC_RESET, TO_RA, 0, 0, 0 };\r\nstruct string *s;\r\ns = tty3270_alloc_string(tp, sizeof(blueprint));\r\nmemcpy(s->string, blueprint, sizeof(blueprint));\r\ns->len = sizeof(blueprint);\r\nlist_add_tail(&s->list, &tp->lines);\r\ntp->nr_lines++;\r\nif (tp->nr_up != 0)\r\ntp->nr_up++;\r\n}\r\nstatic void\r\ntty3270_write_callback(struct raw3270_request *rq, void *data)\r\n{\r\nstruct tty3270 *tp = container_of(rq->view, struct tty3270, view);\r\nif (rq->rc != 0) {\r\ntp->update_flags = TTY_UPDATE_ALL;\r\ntty3270_set_timer(tp, 1);\r\n}\r\nraw3270_request_reset(rq);\r\nxchg(&tp->write, rq);\r\n}\r\nstatic void\r\ntty3270_update(struct tty3270 *tp)\r\n{\r\nstatic char invalid_sba[2] = { 0xff, 0xff };\r\nstruct raw3270_request *wrq;\r\nunsigned long updated;\r\nstruct string *s, *n;\r\nchar *sba, *str;\r\nint rc, len;\r\nwrq = xchg(&tp->write, 0);\r\nif (!wrq) {\r\ntty3270_set_timer(tp, 1);\r\nreturn;\r\n}\r\nspin_lock(&tp->view.lock);\r\nupdated = 0;\r\nif (tp->update_flags & TTY_UPDATE_ALL) {\r\ntty3270_rebuild_update(tp);\r\ntty3270_update_status(tp);\r\ntp->update_flags = TTY_UPDATE_ERASE | TTY_UPDATE_LIST |\r\nTTY_UPDATE_INPUT | TTY_UPDATE_STATUS;\r\n}\r\nif (tp->update_flags & TTY_UPDATE_ERASE) {\r\nraw3270_request_set_cmd(wrq, TC_EWRITEA);\r\nupdated |= TTY_UPDATE_ERASE;\r\n} else\r\nraw3270_request_set_cmd(wrq, TC_WRITE);\r\nraw3270_request_add_data(wrq, &tp->wcc, 1);\r\ntp->wcc = TW_NONE;\r\nif (tp->update_flags & TTY_UPDATE_STATUS)\r\nif (raw3270_request_add_data(wrq, tp->status->string,\r\ntp->status->len) == 0)\r\nupdated |= TTY_UPDATE_STATUS;\r\nif (tp->update_flags & TTY_UPDATE_INPUT)\r\nif (raw3270_request_add_data(wrq, tp->prompt->string,\r\ntp->prompt->len) == 0)\r\nupdated |= TTY_UPDATE_INPUT;\r\nsba = invalid_sba;\r\nif (tp->update_flags & TTY_UPDATE_LIST) {\r\nlist_for_each_entry_safe(s, n, &tp->update, update) {\r\nstr = s->string;\r\nlen = s->len;\r\nif (s->string[1] == sba[0] && s->string[2] == sba[1])\r\nstr += 3, len -= 3;\r\nif (raw3270_request_add_data(wrq, str, len) != 0)\r\nbreak;\r\nlist_del_init(&s->update);\r\nsba = s->string + s->len - 3;\r\n}\r\nif (list_empty(&tp->update))\r\nupdated |= TTY_UPDATE_LIST;\r\n}\r\nwrq->callback = tty3270_write_callback;\r\nrc = raw3270_start(&tp->view, wrq);\r\nif (rc == 0) {\r\ntp->update_flags &= ~updated;\r\nif (tp->update_flags)\r\ntty3270_set_timer(tp, 1);\r\n} else {\r\nraw3270_request_reset(wrq);\r\nxchg(&tp->write, wrq);\r\n}\r\nspin_unlock(&tp->view.lock);\r\n}\r\nstatic void\r\ntty3270_rcl_add(struct tty3270 *tp, char *input, int len)\r\n{\r\nstruct string *s;\r\ntp->rcl_walk = NULL;\r\nif (len <= 0)\r\nreturn;\r\nif (tp->rcl_nr >= tp->rcl_max) {\r\ns = list_entry(tp->rcl_lines.next, struct string, list);\r\nlist_del(&s->list);\r\nfree_string(&tp->freemem, s);\r\ntp->rcl_nr--;\r\n}\r\ns = tty3270_alloc_string(tp, len);\r\nmemcpy(s->string, input, len);\r\nlist_add_tail(&s->list, &tp->rcl_lines);\r\ntp->rcl_nr++;\r\n}\r\nstatic void\r\ntty3270_rcl_backward(struct kbd_data *kbd)\r\n{\r\nstruct tty3270 *tp = container_of(kbd->port, struct tty3270, port);\r\nstruct string *s;\r\nspin_lock_bh(&tp->view.lock);\r\nif (tp->inattr == TF_INPUT) {\r\nif (tp->rcl_walk && tp->rcl_walk->prev != &tp->rcl_lines)\r\ntp->rcl_walk = tp->rcl_walk->prev;\r\nelse if (!list_empty(&tp->rcl_lines))\r\ntp->rcl_walk = tp->rcl_lines.prev;\r\ns = tp->rcl_walk ?\r\nlist_entry(tp->rcl_walk, struct string, list) : NULL;\r\nif (tp->rcl_walk) {\r\ns = list_entry(tp->rcl_walk, struct string, list);\r\ntty3270_update_prompt(tp, s->string, s->len);\r\n} else\r\ntty3270_update_prompt(tp, NULL, 0);\r\ntty3270_set_timer(tp, 1);\r\n}\r\nspin_unlock_bh(&tp->view.lock);\r\n}\r\nstatic void\r\ntty3270_exit_tty(struct kbd_data *kbd)\r\n{\r\nstruct tty3270 *tp = container_of(kbd->port, struct tty3270, port);\r\nraw3270_deactivate_view(&tp->view);\r\n}\r\nstatic void\r\ntty3270_scroll_forward(struct kbd_data *kbd)\r\n{\r\nstruct tty3270 *tp = container_of(kbd->port, struct tty3270, port);\r\nint nr_up;\r\nspin_lock_bh(&tp->view.lock);\r\nnr_up = tp->nr_up - tp->view.rows + 2;\r\nif (nr_up < 0)\r\nnr_up = 0;\r\nif (nr_up != tp->nr_up) {\r\ntp->nr_up = nr_up;\r\ntty3270_rebuild_update(tp);\r\ntty3270_update_status(tp);\r\ntty3270_set_timer(tp, 1);\r\n}\r\nspin_unlock_bh(&tp->view.lock);\r\n}\r\nstatic void\r\ntty3270_scroll_backward(struct kbd_data *kbd)\r\n{\r\nstruct tty3270 *tp = container_of(kbd->port, struct tty3270, port);\r\nint nr_up;\r\nspin_lock_bh(&tp->view.lock);\r\nnr_up = tp->nr_up + tp->view.rows - 2;\r\nif (nr_up + tp->view.rows - 2 > tp->nr_lines)\r\nnr_up = tp->nr_lines - tp->view.rows + 2;\r\nif (nr_up != tp->nr_up) {\r\ntp->nr_up = nr_up;\r\ntty3270_rebuild_update(tp);\r\ntty3270_update_status(tp);\r\ntty3270_set_timer(tp, 1);\r\n}\r\nspin_unlock_bh(&tp->view.lock);\r\n}\r\nstatic void\r\ntty3270_read_tasklet(struct raw3270_request *rrq)\r\n{\r\nstatic char kreset_data = TW_KR;\r\nstruct tty3270 *tp = container_of(rrq->view, struct tty3270, view);\r\nchar *input;\r\nint len;\r\nspin_lock_bh(&tp->view.lock);\r\ninput = NULL;\r\nlen = 0;\r\nif (tp->input->string[0] == 0x7d) {\r\ninput = tp->input->string + 6;\r\nlen = tp->input->len - 6 - rrq->rescnt;\r\nif (tp->inattr != TF_INPUTN)\r\ntty3270_rcl_add(tp, input, len);\r\nif (tp->nr_up > 0) {\r\ntp->nr_up = 0;\r\ntty3270_rebuild_update(tp);\r\ntty3270_update_status(tp);\r\n}\r\ntty3270_update_prompt(tp, NULL, 0);\r\ntty3270_set_timer(tp, 1);\r\n} else if (tp->input->string[0] == 0x6d) {\r\ntp->update_flags = TTY_UPDATE_ALL;\r\ntty3270_set_timer(tp, 1);\r\n}\r\nspin_unlock_bh(&tp->view.lock);\r\nraw3270_request_reset(tp->kreset);\r\nraw3270_request_set_cmd(tp->kreset, TC_WRITE);\r\nraw3270_request_add_data(tp->kreset, &kreset_data, 1);\r\nraw3270_start(&tp->view, tp->kreset);\r\nwhile (len-- > 0)\r\nkbd_keycode(tp->kbd, *input++);\r\nkbd_keycode(tp->kbd, 256 + tp->input->string[0]);\r\nraw3270_request_reset(rrq);\r\nxchg(&tp->read, rrq);\r\nraw3270_put_view(&tp->view);\r\n}\r\nstatic void\r\ntty3270_read_callback(struct raw3270_request *rq, void *data)\r\n{\r\nstruct tty3270 *tp = container_of(rq->view, struct tty3270, view);\r\nraw3270_get_view(rq->view);\r\ntasklet_schedule(&tp->readlet);\r\n}\r\nstatic void\r\ntty3270_issue_read(struct tty3270 *tp, int lock)\r\n{\r\nstruct raw3270_request *rrq;\r\nint rc;\r\nrrq = xchg(&tp->read, 0);\r\nif (!rrq)\r\nreturn;\r\nrrq->callback = tty3270_read_callback;\r\nrrq->callback_data = tp;\r\nraw3270_request_set_cmd(rrq, TC_READMOD);\r\nraw3270_request_set_data(rrq, tp->input->string, tp->input->len);\r\nif (lock) {\r\nrc = raw3270_start(&tp->view, rrq);\r\n} else\r\nrc = raw3270_start_irq(&tp->view, rrq);\r\nif (rc) {\r\nraw3270_request_reset(rrq);\r\nxchg(&tp->read, rrq);\r\n}\r\n}\r\nstatic int\r\ntty3270_activate(struct raw3270_view *view)\r\n{\r\nstruct tty3270 *tp = container_of(view, struct tty3270, view);\r\ntp->update_flags = TTY_UPDATE_ALL;\r\ntty3270_set_timer(tp, 1);\r\nreturn 0;\r\n}\r\nstatic void\r\ntty3270_deactivate(struct raw3270_view *view)\r\n{\r\nstruct tty3270 *tp = container_of(view, struct tty3270, view);\r\ndel_timer(&tp->timer);\r\n}\r\nstatic int\r\ntty3270_irq(struct tty3270 *tp, struct raw3270_request *rq, struct irb *irb)\r\n{\r\nif (irb->scsw.cmd.dstat & DEV_STAT_ATTENTION) {\r\nif (!tp->throttle)\r\ntty3270_issue_read(tp, 0);\r\nelse\r\ntp->attn = 1;\r\n}\r\nif (rq) {\r\nif (irb->scsw.cmd.dstat & DEV_STAT_UNIT_CHECK)\r\nrq->rc = -EIO;\r\nelse\r\nrq->rescnt = irb->scsw.cmd.count;\r\n}\r\nreturn RAW3270_IO_DONE;\r\n}\r\nstatic struct tty3270 *\r\ntty3270_alloc_view(void)\r\n{\r\nstruct tty3270 *tp;\r\nint pages;\r\ntp = kzalloc(sizeof(struct tty3270), GFP_KERNEL);\r\nif (!tp)\r\ngoto out_err;\r\ntp->freemem_pages =\r\nkmalloc(sizeof(void *) * TTY3270_STRING_PAGES, GFP_KERNEL);\r\nif (!tp->freemem_pages)\r\ngoto out_tp;\r\nINIT_LIST_HEAD(&tp->freemem);\r\nINIT_LIST_HEAD(&tp->lines);\r\nINIT_LIST_HEAD(&tp->update);\r\nINIT_LIST_HEAD(&tp->rcl_lines);\r\ntp->rcl_max = 20;\r\nfor (pages = 0; pages < TTY3270_STRING_PAGES; pages++) {\r\ntp->freemem_pages[pages] = (void *)\r\n__get_free_pages(GFP_KERNEL|GFP_DMA, 0);\r\nif (!tp->freemem_pages[pages])\r\ngoto out_pages;\r\nadd_string_memory(&tp->freemem,\r\ntp->freemem_pages[pages], PAGE_SIZE);\r\n}\r\ntp->write = raw3270_request_alloc(TTY3270_OUTPUT_BUFFER_SIZE);\r\nif (IS_ERR(tp->write))\r\ngoto out_pages;\r\ntp->read = raw3270_request_alloc(0);\r\nif (IS_ERR(tp->read))\r\ngoto out_write;\r\ntp->kreset = raw3270_request_alloc(1);\r\nif (IS_ERR(tp->kreset))\r\ngoto out_read;\r\ntp->kbd = kbd_alloc();\r\nif (!tp->kbd)\r\ngoto out_reset;\r\ntty_port_init(&tp->port);\r\nsetup_timer(&tp->timer, (void (*)(unsigned long)) tty3270_update,\r\n(unsigned long) tp);\r\ntasklet_init(&tp->readlet,\r\n(void (*)(unsigned long)) tty3270_read_tasklet,\r\n(unsigned long) tp->read);\r\nINIT_WORK(&tp->resize_work, tty3270_resize_work);\r\nreturn tp;\r\nout_reset:\r\nraw3270_request_free(tp->kreset);\r\nout_read:\r\nraw3270_request_free(tp->read);\r\nout_write:\r\nraw3270_request_free(tp->write);\r\nout_pages:\r\nwhile (pages--)\r\nfree_pages((unsigned long) tp->freemem_pages[pages], 0);\r\nkfree(tp->freemem_pages);\r\ntty_port_destroy(&tp->port);\r\nout_tp:\r\nkfree(tp);\r\nout_err:\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nstatic void\r\ntty3270_free_view(struct tty3270 *tp)\r\n{\r\nint pages;\r\nkbd_free(tp->kbd);\r\nraw3270_request_free(tp->kreset);\r\nraw3270_request_free(tp->read);\r\nraw3270_request_free(tp->write);\r\nfor (pages = 0; pages < TTY3270_STRING_PAGES; pages++)\r\nfree_pages((unsigned long) tp->freemem_pages[pages], 0);\r\nkfree(tp->freemem_pages);\r\ntty_port_destroy(&tp->port);\r\nkfree(tp);\r\n}\r\nstatic struct tty3270_line *\r\ntty3270_alloc_screen(unsigned int rows, unsigned int cols)\r\n{\r\nstruct tty3270_line *screen;\r\nunsigned long size;\r\nint lines;\r\nsize = sizeof(struct tty3270_line) * (rows - 2);\r\nscreen = kzalloc(size, GFP_KERNEL);\r\nif (!screen)\r\ngoto out_err;\r\nfor (lines = 0; lines < rows - 2; lines++) {\r\nsize = sizeof(struct tty3270_cell) * cols;\r\nscreen[lines].cells = kzalloc(size, GFP_KERNEL);\r\nif (!screen[lines].cells)\r\ngoto out_screen;\r\n}\r\nreturn screen;\r\nout_screen:\r\nwhile (lines--)\r\nkfree(screen[lines].cells);\r\nkfree(screen);\r\nout_err:\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nstatic void\r\ntty3270_free_screen(struct tty3270_line *screen, unsigned int rows)\r\n{\r\nint lines;\r\nfor (lines = 0; lines < rows - 2; lines++)\r\nkfree(screen[lines].cells);\r\nkfree(screen);\r\n}\r\nstatic void tty3270_resize_work(struct work_struct *work)\r\n{\r\nstruct tty3270 *tp = container_of(work, struct tty3270, resize_work);\r\nstruct tty3270_line *screen, *oscreen;\r\nstruct tty_struct *tty;\r\nunsigned int orows;\r\nstruct winsize ws;\r\nscreen = tty3270_alloc_screen(tp->n_rows, tp->n_cols);\r\nif (IS_ERR(screen))\r\nreturn;\r\nspin_lock_bh(&tp->view.lock);\r\noscreen = tp->screen;\r\norows = tp->view.rows;\r\ntp->view.model = tp->n_model;\r\ntp->view.rows = tp->n_rows;\r\ntp->view.cols = tp->n_cols;\r\ntp->screen = screen;\r\nfree_string(&tp->freemem, tp->prompt);\r\nfree_string(&tp->freemem, tp->status);\r\ntty3270_create_prompt(tp);\r\ntty3270_create_status(tp);\r\ntp->nr_up = 0;\r\nwhile (tp->nr_lines < tp->view.rows - 2)\r\ntty3270_blank_line(tp);\r\ntp->update_flags = TTY_UPDATE_ALL;\r\nspin_unlock_bh(&tp->view.lock);\r\ntty3270_free_screen(oscreen, orows);\r\ntty3270_set_timer(tp, 1);\r\ntty = tty_port_tty_get(&tp->port);\r\nif (!tty)\r\nreturn;\r\nws.ws_row = tp->view.rows - 2;\r\nws.ws_col = tp->view.cols;\r\ntty_do_resize(tty, &ws);\r\n}\r\nstatic void\r\ntty3270_resize(struct raw3270_view *view, int model, int rows, int cols)\r\n{\r\nstruct tty3270 *tp = container_of(view, struct tty3270, view);\r\ntp->n_model = model;\r\ntp->n_rows = rows;\r\ntp->n_cols = cols;\r\nschedule_work(&tp->resize_work);\r\n}\r\nstatic void\r\ntty3270_release(struct raw3270_view *view)\r\n{\r\nstruct tty3270 *tp = container_of(view, struct tty3270, view);\r\nstruct tty_struct *tty = tty_port_tty_get(&tp->port);\r\nif (tty) {\r\ntty->driver_data = NULL;\r\ntty_port_tty_set(&tp->port, NULL);\r\ntty_hangup(tty);\r\nraw3270_put_view(&tp->view);\r\ntty_kref_put(tty);\r\n}\r\n}\r\nstatic void\r\ntty3270_free(struct raw3270_view *view)\r\n{\r\nstruct tty3270 *tp = container_of(view, struct tty3270, view);\r\ndel_timer_sync(&tp->timer);\r\ntty3270_free_screen(tp->screen, tp->view.rows);\r\ntty3270_free_view(tp);\r\n}\r\nstatic void\r\ntty3270_del_views(void)\r\n{\r\nint i;\r\nfor (i = RAW3270_FIRSTMINOR; i <= tty3270_max_index; i++) {\r\nstruct raw3270_view *view = raw3270_find_view(&tty3270_fn, i);\r\nif (!IS_ERR(view))\r\nraw3270_del_view(view);\r\n}\r\n}\r\nstatic int tty3270_install(struct tty_driver *driver, struct tty_struct *tty)\r\n{\r\nstruct raw3270_view *view;\r\nstruct tty3270 *tp;\r\nint i, rc;\r\nview = raw3270_find_view(&tty3270_fn, tty->index + RAW3270_FIRSTMINOR);\r\nif (!IS_ERR(view)) {\r\ntp = container_of(view, struct tty3270, view);\r\ntty->driver_data = tp;\r\ntty->winsize.ws_row = tp->view.rows - 2;\r\ntty->winsize.ws_col = tp->view.cols;\r\ntp->port.low_latency = 0;\r\ntty_port_tty_set(&tp->port, tty);\r\ntp->inattr = TF_INPUT;\r\nreturn tty_port_install(&tp->port, driver, tty);\r\n}\r\nif (tty3270_max_index < tty->index + 1)\r\ntty3270_max_index = tty->index + 1;\r\ntp = tty3270_alloc_view();\r\nif (IS_ERR(tp))\r\nreturn PTR_ERR(tp);\r\nrc = raw3270_add_view(&tp->view, &tty3270_fn,\r\ntty->index + RAW3270_FIRSTMINOR);\r\nif (rc) {\r\ntty3270_free_view(tp);\r\nreturn rc;\r\n}\r\ntp->screen = tty3270_alloc_screen(tp->view.rows, tp->view.cols);\r\nif (IS_ERR(tp->screen)) {\r\nrc = PTR_ERR(tp->screen);\r\nraw3270_put_view(&tp->view);\r\nraw3270_del_view(&tp->view);\r\ntty3270_free_view(tp);\r\nreturn rc;\r\n}\r\ntty_port_tty_set(&tp->port, tty);\r\ntp->port.low_latency = 0;\r\ntty->winsize.ws_row = tp->view.rows - 2;\r\ntty->winsize.ws_col = tp->view.cols;\r\ntty3270_create_prompt(tp);\r\ntty3270_create_status(tp);\r\ntty3270_update_status(tp);\r\nfor (i = 0; i < tp->view.rows - 2; i++)\r\ntty3270_blank_line(tp);\r\ntp->kbd->port = &tp->port;\r\ntp->kbd->fn_handler[KVAL(K_INCRCONSOLE)] = tty3270_exit_tty;\r\ntp->kbd->fn_handler[KVAL(K_SCROLLBACK)] = tty3270_scroll_backward;\r\ntp->kbd->fn_handler[KVAL(K_SCROLLFORW)] = tty3270_scroll_forward;\r\ntp->kbd->fn_handler[KVAL(K_CONS)] = tty3270_rcl_backward;\r\nkbd_ascebc(tp->kbd, tp->view.ascebc);\r\nraw3270_activate_view(&tp->view);\r\nrc = tty_port_install(&tp->port, driver, tty);\r\nif (rc) {\r\nraw3270_put_view(&tp->view);\r\nreturn rc;\r\n}\r\ntty->driver_data = tp;\r\nreturn 0;\r\n}\r\nstatic int\r\ntty3270_open(struct tty_struct *tty, struct file *filp)\r\n{\r\nstruct tty3270 *tp = tty->driver_data;\r\nstruct tty_port *port = &tp->port;\r\nport->count++;\r\ntty_port_tty_set(port, tty);\r\nreturn 0;\r\n}\r\nstatic void\r\ntty3270_close(struct tty_struct *tty, struct file * filp)\r\n{\r\nstruct tty3270 *tp = tty->driver_data;\r\nif (tty->count > 1)\r\nreturn;\r\nif (tp) {\r\ntty->driver_data = NULL;\r\ntty_port_tty_set(&tp->port, NULL);\r\n}\r\n}\r\nstatic void tty3270_cleanup(struct tty_struct *tty)\r\n{\r\nstruct tty3270 *tp = tty->driver_data;\r\nif (tp)\r\nraw3270_put_view(&tp->view);\r\n}\r\nstatic int\r\ntty3270_write_room(struct tty_struct *tty)\r\n{\r\nreturn INT_MAX;\r\n}\r\nstatic void tty3270_put_character(struct tty3270 *tp, char ch)\r\n{\r\nstruct tty3270_line *line;\r\nstruct tty3270_cell *cell;\r\nline = tp->screen + tp->cy;\r\nif (line->len <= tp->cx) {\r\nwhile (line->len < tp->cx) {\r\ncell = line->cells + line->len;\r\ncell->character = tp->view.ascebc[' '];\r\ncell->highlight = tp->highlight;\r\ncell->f_color = tp->f_color;\r\nline->len++;\r\n}\r\nline->len++;\r\n}\r\ncell = line->cells + tp->cx;\r\ncell->character = tp->view.ascebc[(unsigned int) ch];\r\ncell->highlight = tp->highlight;\r\ncell->f_color = tp->f_color;\r\n}\r\nstatic void\r\ntty3270_convert_line(struct tty3270 *tp, int line_nr)\r\n{\r\nstruct tty3270_line *line;\r\nstruct tty3270_cell *cell;\r\nstruct string *s, *n;\r\nunsigned char highlight;\r\nunsigned char f_color;\r\nchar *cp;\r\nint flen, i;\r\nflen = 3;\r\nline = tp->screen + line_nr;\r\nflen += line->len;\r\nhighlight = TAX_RESET;\r\nf_color = TAC_RESET;\r\nfor (i = 0, cell = line->cells; i < line->len; i++, cell++) {\r\nif (cell->highlight != highlight) {\r\nflen += 3;\r\nhighlight = cell->highlight;\r\n}\r\nif (cell->f_color != f_color) {\r\nflen += 3;\r\nf_color = cell->f_color;\r\n}\r\n}\r\nif (highlight != TAX_RESET)\r\nflen += 3;\r\nif (f_color != TAC_RESET)\r\nflen += 3;\r\nif (line->len < tp->view.cols)\r\nflen += 4;\r\ni = tp->view.rows - 2 - line_nr;\r\nlist_for_each_entry_reverse(s, &tp->lines, list)\r\nif (--i <= 0)\r\nbreak;\r\nif (s->len != flen) {\r\nn = tty3270_alloc_string(tp, flen);\r\nlist_add(&n->list, &s->list);\r\nlist_del_init(&s->list);\r\nif (!list_empty(&s->update))\r\nlist_del_init(&s->update);\r\nfree_string(&tp->freemem, s);\r\ns = n;\r\n}\r\ncp = s->string;\r\n*cp++ = TO_SBA;\r\n*cp++ = 0;\r\n*cp++ = 0;\r\nhighlight = TAX_RESET;\r\nf_color = TAC_RESET;\r\nfor (i = 0, cell = line->cells; i < line->len; i++, cell++) {\r\nif (cell->highlight != highlight) {\r\n*cp++ = TO_SA;\r\n*cp++ = TAT_EXTHI;\r\n*cp++ = cell->highlight;\r\nhighlight = cell->highlight;\r\n}\r\nif (cell->f_color != f_color) {\r\n*cp++ = TO_SA;\r\n*cp++ = TAT_COLOR;\r\n*cp++ = cell->f_color;\r\nf_color = cell->f_color;\r\n}\r\n*cp++ = cell->character;\r\n}\r\nif (highlight != TAX_RESET) {\r\n*cp++ = TO_SA;\r\n*cp++ = TAT_EXTHI;\r\n*cp++ = TAX_RESET;\r\n}\r\nif (f_color != TAC_RESET) {\r\n*cp++ = TO_SA;\r\n*cp++ = TAT_COLOR;\r\n*cp++ = TAC_RESET;\r\n}\r\nif (line->len < tp->view.cols) {\r\n*cp++ = TO_RA;\r\n*cp++ = 0;\r\n*cp++ = 0;\r\n*cp++ = 0;\r\n}\r\nif (tp->nr_up + line_nr < tp->view.rows - 2) {\r\ntty3270_update_string(tp, s, line_nr);\r\nif (list_empty(&s->update)) {\r\nlist_add_tail(&s->update, &tp->update);\r\ntp->update_flags |= TTY_UPDATE_LIST;\r\n}\r\n}\r\n}\r\nstatic void\r\ntty3270_cr(struct tty3270 *tp)\r\n{\r\ntp->cx = 0;\r\n}\r\nstatic void\r\ntty3270_lf(struct tty3270 *tp)\r\n{\r\nstruct tty3270_line temp;\r\nint i;\r\ntty3270_convert_line(tp, tp->cy);\r\nif (tp->cy < tp->view.rows - 3) {\r\ntp->cy++;\r\nreturn;\r\n}\r\ntty3270_blank_line(tp);\r\ntemp = tp->screen[0];\r\ntemp.len = 0;\r\nfor (i = 0; i < tp->view.rows - 3; i++)\r\ntp->screen[i] = tp->screen[i+1];\r\ntp->screen[tp->view.rows - 3] = temp;\r\ntty3270_rebuild_update(tp);\r\n}\r\nstatic void\r\ntty3270_ri(struct tty3270 *tp)\r\n{\r\nif (tp->cy > 0) {\r\ntty3270_convert_line(tp, tp->cy);\r\ntp->cy--;\r\n}\r\n}\r\nstatic void\r\ntty3270_insert_characters(struct tty3270 *tp, int n)\r\n{\r\nstruct tty3270_line *line;\r\nint k;\r\nline = tp->screen + tp->cy;\r\nwhile (line->len < tp->cx) {\r\nline->cells[line->len].character = tp->view.ascebc[' '];\r\nline->cells[line->len].highlight = TAX_RESET;\r\nline->cells[line->len].f_color = TAC_RESET;\r\nline->len++;\r\n}\r\nif (n > tp->view.cols - tp->cx)\r\nn = tp->view.cols - tp->cx;\r\nk = min_t(int, line->len - tp->cx, tp->view.cols - tp->cx - n);\r\nwhile (k--)\r\nline->cells[tp->cx + n + k] = line->cells[tp->cx + k];\r\nline->len += n;\r\nif (line->len > tp->view.cols)\r\nline->len = tp->view.cols;\r\nwhile (n-- > 0) {\r\nline->cells[tp->cx + n].character = tp->view.ascebc[' '];\r\nline->cells[tp->cx + n].highlight = tp->highlight;\r\nline->cells[tp->cx + n].f_color = tp->f_color;\r\n}\r\n}\r\nstatic void\r\ntty3270_delete_characters(struct tty3270 *tp, int n)\r\n{\r\nstruct tty3270_line *line;\r\nint i;\r\nline = tp->screen + tp->cy;\r\nif (line->len <= tp->cx)\r\nreturn;\r\nif (line->len - tp->cx <= n) {\r\nline->len = tp->cx;\r\nreturn;\r\n}\r\nfor (i = tp->cx; i + n < line->len; i++)\r\nline->cells[i] = line->cells[i + n];\r\nline->len -= n;\r\n}\r\nstatic void\r\ntty3270_erase_characters(struct tty3270 *tp, int n)\r\n{\r\nstruct tty3270_line *line;\r\nstruct tty3270_cell *cell;\r\nline = tp->screen + tp->cy;\r\nwhile (line->len > tp->cx && n-- > 0) {\r\ncell = line->cells + tp->cx++;\r\ncell->character = ' ';\r\ncell->highlight = TAX_RESET;\r\ncell->f_color = TAC_RESET;\r\n}\r\ntp->cx += n;\r\ntp->cx = min_t(int, tp->cx, tp->view.cols - 1);\r\n}\r\nstatic void\r\ntty3270_erase_line(struct tty3270 *tp, int mode)\r\n{\r\nstruct tty3270_line *line;\r\nstruct tty3270_cell *cell;\r\nint i;\r\nline = tp->screen + tp->cy;\r\nif (mode == 0)\r\nline->len = tp->cx;\r\nelse if (mode == 1) {\r\nfor (i = 0; i < tp->cx; i++) {\r\ncell = line->cells + i;\r\ncell->character = ' ';\r\ncell->highlight = TAX_RESET;\r\ncell->f_color = TAC_RESET;\r\n}\r\nif (line->len <= tp->cx)\r\nline->len = tp->cx + 1;\r\n} else if (mode == 2)\r\nline->len = 0;\r\ntty3270_convert_line(tp, tp->cy);\r\n}\r\nstatic void\r\ntty3270_erase_display(struct tty3270 *tp, int mode)\r\n{\r\nint i;\r\nif (mode == 0) {\r\ntty3270_erase_line(tp, 0);\r\nfor (i = tp->cy + 1; i < tp->view.rows - 2; i++) {\r\ntp->screen[i].len = 0;\r\ntty3270_convert_line(tp, i);\r\n}\r\n} else if (mode == 1) {\r\nfor (i = 0; i < tp->cy; i++) {\r\ntp->screen[i].len = 0;\r\ntty3270_convert_line(tp, i);\r\n}\r\ntty3270_erase_line(tp, 1);\r\n} else if (mode == 2) {\r\nfor (i = 0; i < tp->view.rows - 2; i++) {\r\ntp->screen[i].len = 0;\r\ntty3270_convert_line(tp, i);\r\n}\r\n}\r\ntty3270_rebuild_update(tp);\r\n}\r\nstatic void\r\ntty3270_set_attributes(struct tty3270 *tp)\r\n{\r\nstatic unsigned char f_colors[] = {\r\nTAC_DEFAULT, TAC_RED, TAC_GREEN, TAC_YELLOW, TAC_BLUE,\r\nTAC_PINK, TAC_TURQ, TAC_WHITE, 0, TAC_DEFAULT\r\n};\r\nint i, attr;\r\nfor (i = 0; i <= tp->esc_npar; i++) {\r\nattr = tp->esc_par[i];\r\nswitch (attr) {\r\ncase 0:\r\ntp->highlight = TAX_RESET;\r\ntp->f_color = TAC_RESET;\r\nbreak;\r\ncase 4:\r\ntp->highlight = TAX_UNDER;\r\nbreak;\r\ncase 5:\r\ntp->highlight = TAX_BLINK;\r\nbreak;\r\ncase 7:\r\ntp->highlight = TAX_REVER;\r\nbreak;\r\ncase 24:\r\nif (tp->highlight == TAX_UNDER)\r\ntp->highlight = TAX_RESET;\r\nbreak;\r\ncase 25:\r\nif (tp->highlight == TAX_BLINK)\r\ntp->highlight = TAX_RESET;\r\nbreak;\r\ncase 27:\r\nif (tp->highlight == TAX_REVER)\r\ntp->highlight = TAX_RESET;\r\nbreak;\r\ncase 30:\r\ncase 31:\r\ncase 32:\r\ncase 33:\r\ncase 34:\r\ncase 35:\r\ncase 36:\r\ncase 37:\r\ncase 39:\r\ntp->f_color = f_colors[attr - 30];\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic inline int\r\ntty3270_getpar(struct tty3270 *tp, int ix)\r\n{\r\nreturn (tp->esc_par[ix] > 0) ? tp->esc_par[ix] : 1;\r\n}\r\nstatic void\r\ntty3270_goto_xy(struct tty3270 *tp, int cx, int cy)\r\n{\r\nint max_cx = max(0, cx);\r\nint max_cy = max(0, cy);\r\ntp->cx = min_t(int, tp->view.cols - 1, max_cx);\r\ncy = min_t(int, tp->view.rows - 3, max_cy);\r\nif (cy != tp->cy) {\r\ntty3270_convert_line(tp, tp->cy);\r\ntp->cy = cy;\r\n}\r\n}\r\nstatic void\r\ntty3270_escape_sequence(struct tty3270 *tp, char ch)\r\n{\r\nenum { ESnormal, ESesc, ESsquare, ESgetpars };\r\nif (tp->esc_state == ESnormal) {\r\nif (ch == 0x1b)\r\ntp->esc_state = ESesc;\r\nreturn;\r\n}\r\nif (tp->esc_state == ESesc) {\r\ntp->esc_state = ESnormal;\r\nswitch (ch) {\r\ncase '[':\r\ntp->esc_state = ESsquare;\r\nbreak;\r\ncase 'E':\r\ntty3270_cr(tp);\r\ntty3270_lf(tp);\r\nbreak;\r\ncase 'M':\r\ntty3270_ri(tp);\r\nbreak;\r\ncase 'D':\r\ntty3270_lf(tp);\r\nbreak;\r\ncase 'Z':\r\nkbd_puts_queue(&tp->port, "\033[?6c");\r\nbreak;\r\ncase '7':\r\ntp->saved_cx = tp->cx;\r\ntp->saved_cy = tp->cy;\r\ntp->saved_highlight = tp->highlight;\r\ntp->saved_f_color = tp->f_color;\r\nbreak;\r\ncase '8':\r\ntty3270_convert_line(tp, tp->cy);\r\ntty3270_goto_xy(tp, tp->saved_cx, tp->saved_cy);\r\ntp->highlight = tp->saved_highlight;\r\ntp->f_color = tp->saved_f_color;\r\nbreak;\r\ncase 'c':\r\ntp->cx = tp->saved_cx = 0;\r\ntp->cy = tp->saved_cy = 0;\r\ntp->highlight = tp->saved_highlight = TAX_RESET;\r\ntp->f_color = tp->saved_f_color = TAC_RESET;\r\ntty3270_erase_display(tp, 2);\r\nbreak;\r\n}\r\nreturn;\r\n}\r\nif (tp->esc_state == ESsquare) {\r\ntp->esc_state = ESgetpars;\r\nmemset(tp->esc_par, 0, sizeof(tp->esc_par));\r\ntp->esc_npar = 0;\r\ntp->esc_ques = (ch == '?');\r\nif (tp->esc_ques)\r\nreturn;\r\n}\r\nif (tp->esc_state == ESgetpars) {\r\nif (ch == ';' && tp->esc_npar < ESCAPE_NPAR - 1) {\r\ntp->esc_npar++;\r\nreturn;\r\n}\r\nif (ch >= '0' && ch <= '9') {\r\ntp->esc_par[tp->esc_npar] *= 10;\r\ntp->esc_par[tp->esc_npar] += ch - '0';\r\nreturn;\r\n}\r\n}\r\ntp->esc_state = ESnormal;\r\nif (ch == 'n' && !tp->esc_ques) {\r\nif (tp->esc_par[0] == 5)\r\nkbd_puts_queue(&tp->port, "\033[0n");\r\nelse if (tp->esc_par[0] == 6) {\r\nchar buf[40];\r\nsprintf(buf, "\033[%d;%dR", tp->cy + 1, tp->cx + 1);\r\nkbd_puts_queue(&tp->port, buf);\r\n}\r\nreturn;\r\n}\r\nif (tp->esc_ques)\r\nreturn;\r\nswitch (ch) {\r\ncase 'm':\r\ntty3270_set_attributes(tp);\r\nbreak;\r\ncase 'H':\r\ncase 'f':\r\ntty3270_goto_xy(tp, tty3270_getpar(tp, 1) - 1,\r\ntty3270_getpar(tp, 0) - 1);\r\nbreak;\r\ncase 'd':\r\ntty3270_goto_xy(tp, tp->cx, tty3270_getpar(tp, 0) - 1);\r\nbreak;\r\ncase 'A':\r\ncase 'F':\r\ntty3270_goto_xy(tp, tp->cx, tp->cy - tty3270_getpar(tp, 0));\r\nbreak;\r\ncase 'B':\r\ncase 'e':\r\ncase 'E':\r\ntty3270_goto_xy(tp, tp->cx, tp->cy + tty3270_getpar(tp, 0));\r\nbreak;\r\ncase 'C':\r\ncase 'a':\r\ntty3270_goto_xy(tp, tp->cx + tty3270_getpar(tp, 0), tp->cy);\r\nbreak;\r\ncase 'D':\r\ntty3270_goto_xy(tp, tp->cx - tty3270_getpar(tp, 0), tp->cy);\r\nbreak;\r\ncase 'G':\r\ncase '`':\r\ntty3270_goto_xy(tp, tty3270_getpar(tp, 0), tp->cy);\r\nbreak;\r\ncase 'X':\r\ntty3270_erase_characters(tp, tty3270_getpar(tp, 0));\r\nbreak;\r\ncase 'J':\r\ntty3270_erase_display(tp, tp->esc_par[0]);\r\nbreak;\r\ncase 'K':\r\ntty3270_erase_line(tp, tp->esc_par[0]);\r\nbreak;\r\ncase 'P':\r\ntty3270_delete_characters(tp, tty3270_getpar(tp, 0));\r\nbreak;\r\ncase '@':\r\ntty3270_insert_characters(tp, tty3270_getpar(tp, 0));\r\nbreak;\r\ncase 's':\r\ntp->saved_cx = tp->cx;\r\ntp->saved_cy = tp->cy;\r\ntp->saved_highlight = tp->highlight;\r\ntp->saved_f_color = tp->f_color;\r\nbreak;\r\ncase 'u':\r\ntty3270_convert_line(tp, tp->cy);\r\ntty3270_goto_xy(tp, tp->saved_cx, tp->saved_cy);\r\ntp->highlight = tp->saved_highlight;\r\ntp->f_color = tp->saved_f_color;\r\nbreak;\r\n}\r\n}\r\nstatic void\r\ntty3270_do_write(struct tty3270 *tp, struct tty_struct *tty,\r\nconst unsigned char *buf, int count)\r\n{\r\nint i_msg, i;\r\nspin_lock_bh(&tp->view.lock);\r\nfor (i_msg = 0; !tty->stopped && i_msg < count; i_msg++) {\r\nif (tp->esc_state != 0) {\r\ntty3270_escape_sequence(tp, buf[i_msg]);\r\ncontinue;\r\n}\r\nswitch (buf[i_msg]) {\r\ncase 0x07:\r\ntp->wcc |= TW_PLUSALARM;\r\nbreak;\r\ncase 0x08:\r\nif (tp->cx > 0) {\r\ntp->cx--;\r\ntty3270_put_character(tp, ' ');\r\n}\r\nbreak;\r\ncase 0x09:\r\nfor (i = tp->cx % 8; i < 8; i++) {\r\nif (tp->cx >= tp->view.cols) {\r\ntty3270_cr(tp);\r\ntty3270_lf(tp);\r\nbreak;\r\n}\r\ntty3270_put_character(tp, ' ');\r\ntp->cx++;\r\n}\r\nbreak;\r\ncase 0x0a:\r\ntty3270_cr(tp);\r\ntty3270_lf(tp);\r\nbreak;\r\ncase 0x0c:\r\ntty3270_erase_display(tp, 2);\r\ntp->cx = tp->cy = 0;\r\nbreak;\r\ncase 0x0d:\r\ntp->cx = 0;\r\nbreak;\r\ncase 0x0f:\r\nbreak;\r\ncase 0x1b:\r\ntty3270_escape_sequence(tp, buf[i_msg]);\r\nbreak;\r\ndefault:\r\nif (tp->cx >= tp->view.cols) {\r\ntty3270_cr(tp);\r\ntty3270_lf(tp);\r\n}\r\ntty3270_put_character(tp, buf[i_msg]);\r\ntp->cx++;\r\nbreak;\r\n}\r\n}\r\ntty3270_convert_line(tp, tp->cy);\r\nif (!timer_pending(&tp->timer))\r\ntty3270_set_timer(tp, HZ/10);\r\nspin_unlock_bh(&tp->view.lock);\r\n}\r\nstatic int\r\ntty3270_write(struct tty_struct * tty,\r\nconst unsigned char *buf, int count)\r\n{\r\nstruct tty3270 *tp;\r\ntp = tty->driver_data;\r\nif (!tp)\r\nreturn 0;\r\nif (tp->char_count > 0) {\r\ntty3270_do_write(tp, tty, tp->char_buf, tp->char_count);\r\ntp->char_count = 0;\r\n}\r\ntty3270_do_write(tp, tty, buf, count);\r\nreturn count;\r\n}\r\nstatic int tty3270_put_char(struct tty_struct *tty, unsigned char ch)\r\n{\r\nstruct tty3270 *tp;\r\ntp = tty->driver_data;\r\nif (!tp || tp->char_count >= TTY3270_CHAR_BUF_SIZE)\r\nreturn 0;\r\ntp->char_buf[tp->char_count++] = ch;\r\nreturn 1;\r\n}\r\nstatic void\r\ntty3270_flush_chars(struct tty_struct *tty)\r\n{\r\nstruct tty3270 *tp;\r\ntp = tty->driver_data;\r\nif (!tp)\r\nreturn;\r\nif (tp->char_count > 0) {\r\ntty3270_do_write(tp, tty, tp->char_buf, tp->char_count);\r\ntp->char_count = 0;\r\n}\r\n}\r\nstatic int\r\ntty3270_chars_in_buffer(struct tty_struct *tty)\r\n{\r\nreturn 0;\r\n}\r\nstatic void\r\ntty3270_flush_buffer(struct tty_struct *tty)\r\n{\r\n}\r\nstatic void\r\ntty3270_set_termios(struct tty_struct *tty, struct ktermios *old)\r\n{\r\nstruct tty3270 *tp;\r\nint new;\r\ntp = tty->driver_data;\r\nif (!tp)\r\nreturn;\r\nspin_lock_bh(&tp->view.lock);\r\nif (L_ICANON(tty)) {\r\nnew = L_ECHO(tty) ? TF_INPUT: TF_INPUTN;\r\nif (new != tp->inattr) {\r\ntp->inattr = new;\r\ntty3270_update_prompt(tp, NULL, 0);\r\ntty3270_set_timer(tp, 1);\r\n}\r\n}\r\nspin_unlock_bh(&tp->view.lock);\r\n}\r\nstatic void\r\ntty3270_throttle(struct tty_struct * tty)\r\n{\r\nstruct tty3270 *tp;\r\ntp = tty->driver_data;\r\nif (!tp)\r\nreturn;\r\ntp->throttle = 1;\r\n}\r\nstatic void\r\ntty3270_unthrottle(struct tty_struct * tty)\r\n{\r\nstruct tty3270 *tp;\r\ntp = tty->driver_data;\r\nif (!tp)\r\nreturn;\r\ntp->throttle = 0;\r\nif (tp->attn)\r\ntty3270_issue_read(tp, 1);\r\n}\r\nstatic void\r\ntty3270_hangup(struct tty_struct *tty)\r\n{\r\n}\r\nstatic void\r\ntty3270_wait_until_sent(struct tty_struct *tty, int timeout)\r\n{\r\n}\r\nstatic int tty3270_ioctl(struct tty_struct *tty, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\nstruct tty3270 *tp;\r\ntp = tty->driver_data;\r\nif (!tp)\r\nreturn -ENODEV;\r\nif (tty->flags & (1 << TTY_IO_ERROR))\r\nreturn -EIO;\r\nreturn kbd_ioctl(tp->kbd, cmd, arg);\r\n}\r\nstatic long tty3270_compat_ioctl(struct tty_struct *tty,\r\nunsigned int cmd, unsigned long arg)\r\n{\r\nstruct tty3270 *tp;\r\ntp = tty->driver_data;\r\nif (!tp)\r\nreturn -ENODEV;\r\nif (tty->flags & (1 << TTY_IO_ERROR))\r\nreturn -EIO;\r\nreturn kbd_ioctl(tp->kbd, cmd, (unsigned long)compat_ptr(arg));\r\n}\r\nstatic void tty3270_create_cb(int minor)\r\n{\r\ntty_register_device(tty3270_driver, minor - RAW3270_FIRSTMINOR, NULL);\r\n}\r\nstatic void tty3270_destroy_cb(int minor)\r\n{\r\ntty_unregister_device(tty3270_driver, minor - RAW3270_FIRSTMINOR);\r\n}\r\nstatic int __init tty3270_init(void)\r\n{\r\nstruct tty_driver *driver;\r\nint ret;\r\ndriver = tty_alloc_driver(RAW3270_MAXDEVS,\r\nTTY_DRIVER_REAL_RAW |\r\nTTY_DRIVER_DYNAMIC_DEV |\r\nTTY_DRIVER_RESET_TERMIOS);\r\nif (IS_ERR(driver))\r\nreturn PTR_ERR(driver);\r\ndriver->driver_name = "tty3270";\r\ndriver->name = "3270/tty";\r\ndriver->major = IBM_TTY3270_MAJOR;\r\ndriver->minor_start = RAW3270_FIRSTMINOR;\r\ndriver->name_base = RAW3270_FIRSTMINOR;\r\ndriver->type = TTY_DRIVER_TYPE_SYSTEM;\r\ndriver->subtype = SYSTEM_TYPE_TTY;\r\ndriver->init_termios = tty_std_termios;\r\ntty_set_operations(driver, &tty3270_ops);\r\nret = tty_register_driver(driver);\r\nif (ret) {\r\nput_tty_driver(driver);\r\nreturn ret;\r\n}\r\ntty3270_driver = driver;\r\nraw3270_register_notifier(&tty3270_notifier);\r\nreturn 0;\r\n}\r\nstatic void __exit\r\ntty3270_exit(void)\r\n{\r\nstruct tty_driver *driver;\r\nraw3270_unregister_notifier(&tty3270_notifier);\r\ndriver = tty3270_driver;\r\ntty3270_driver = NULL;\r\ntty_unregister_driver(driver);\r\nput_tty_driver(driver);\r\ntty3270_del_views();\r\n}
