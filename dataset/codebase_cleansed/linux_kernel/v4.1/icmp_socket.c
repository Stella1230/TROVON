void batadv_socket_init(void)\r\n{\r\nmemset(batadv_socket_client_hash, 0, sizeof(batadv_socket_client_hash));\r\n}\r\nstatic int batadv_socket_open(struct inode *inode, struct file *file)\r\n{\r\nunsigned int i;\r\nstruct batadv_socket_client *socket_client;\r\nif (!try_module_get(THIS_MODULE))\r\nreturn -EBUSY;\r\nnonseekable_open(inode, file);\r\nsocket_client = kmalloc(sizeof(*socket_client), GFP_KERNEL);\r\nif (!socket_client) {\r\nmodule_put(THIS_MODULE);\r\nreturn -ENOMEM;\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(batadv_socket_client_hash); i++) {\r\nif (!batadv_socket_client_hash[i]) {\r\nbatadv_socket_client_hash[i] = socket_client;\r\nbreak;\r\n}\r\n}\r\nif (i == ARRAY_SIZE(batadv_socket_client_hash)) {\r\npr_err("Error - can't add another packet client: maximum number of clients reached\n");\r\nkfree(socket_client);\r\nmodule_put(THIS_MODULE);\r\nreturn -EXFULL;\r\n}\r\nINIT_LIST_HEAD(&socket_client->queue_list);\r\nsocket_client->queue_len = 0;\r\nsocket_client->index = i;\r\nsocket_client->bat_priv = inode->i_private;\r\nspin_lock_init(&socket_client->lock);\r\ninit_waitqueue_head(&socket_client->queue_wait);\r\nfile->private_data = socket_client;\r\nreturn 0;\r\n}\r\nstatic int batadv_socket_release(struct inode *inode, struct file *file)\r\n{\r\nstruct batadv_socket_client *socket_client = file->private_data;\r\nstruct batadv_socket_packet *socket_packet;\r\nstruct list_head *list_pos, *list_pos_tmp;\r\nspin_lock_bh(&socket_client->lock);\r\nlist_for_each_safe(list_pos, list_pos_tmp, &socket_client->queue_list) {\r\nsocket_packet = list_entry(list_pos,\r\nstruct batadv_socket_packet, list);\r\nlist_del(list_pos);\r\nkfree(socket_packet);\r\n}\r\nbatadv_socket_client_hash[socket_client->index] = NULL;\r\nspin_unlock_bh(&socket_client->lock);\r\nkfree(socket_client);\r\nmodule_put(THIS_MODULE);\r\nreturn 0;\r\n}\r\nstatic ssize_t batadv_socket_read(struct file *file, char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct batadv_socket_client *socket_client = file->private_data;\r\nstruct batadv_socket_packet *socket_packet;\r\nsize_t packet_len;\r\nint error;\r\nif ((file->f_flags & O_NONBLOCK) && (socket_client->queue_len == 0))\r\nreturn -EAGAIN;\r\nif ((!buf) || (count < sizeof(struct batadv_icmp_packet)))\r\nreturn -EINVAL;\r\nif (!access_ok(VERIFY_WRITE, buf, count))\r\nreturn -EFAULT;\r\nerror = wait_event_interruptible(socket_client->queue_wait,\r\nsocket_client->queue_len);\r\nif (error)\r\nreturn error;\r\nspin_lock_bh(&socket_client->lock);\r\nsocket_packet = list_first_entry(&socket_client->queue_list,\r\nstruct batadv_socket_packet, list);\r\nlist_del(&socket_packet->list);\r\nsocket_client->queue_len--;\r\nspin_unlock_bh(&socket_client->lock);\r\npacket_len = min(count, socket_packet->icmp_len);\r\nerror = copy_to_user(buf, &socket_packet->icmp_packet, packet_len);\r\nkfree(socket_packet);\r\nif (error)\r\nreturn -EFAULT;\r\nreturn packet_len;\r\n}\r\nstatic ssize_t batadv_socket_write(struct file *file, const char __user *buff,\r\nsize_t len, loff_t *off)\r\n{\r\nstruct batadv_socket_client *socket_client = file->private_data;\r\nstruct batadv_priv *bat_priv = socket_client->bat_priv;\r\nstruct batadv_hard_iface *primary_if = NULL;\r\nstruct sk_buff *skb;\r\nstruct batadv_icmp_packet_rr *icmp_packet_rr;\r\nstruct batadv_icmp_header *icmp_header;\r\nstruct batadv_orig_node *orig_node = NULL;\r\nstruct batadv_neigh_node *neigh_node = NULL;\r\nsize_t packet_len = sizeof(struct batadv_icmp_packet);\r\nuint8_t *addr;\r\nif (len < sizeof(struct batadv_icmp_header)) {\r\nbatadv_dbg(BATADV_DBG_BATMAN, bat_priv,\r\n"Error - can't send packet from char device: invalid packet size\n");\r\nreturn -EINVAL;\r\n}\r\nprimary_if = batadv_primary_if_get_selected(bat_priv);\r\nif (!primary_if) {\r\nlen = -EFAULT;\r\ngoto out;\r\n}\r\nif (len >= BATADV_ICMP_MAX_PACKET_SIZE)\r\npacket_len = BATADV_ICMP_MAX_PACKET_SIZE;\r\nelse\r\npacket_len = len;\r\nskb = netdev_alloc_skb_ip_align(NULL, packet_len + ETH_HLEN);\r\nif (!skb) {\r\nlen = -ENOMEM;\r\ngoto out;\r\n}\r\nskb->priority = TC_PRIO_CONTROL;\r\nskb_reserve(skb, ETH_HLEN);\r\nicmp_header = (struct batadv_icmp_header *)skb_put(skb, packet_len);\r\nif (copy_from_user(icmp_header, buff, packet_len)) {\r\nlen = -EFAULT;\r\ngoto free_skb;\r\n}\r\nif (icmp_header->packet_type != BATADV_ICMP) {\r\nbatadv_dbg(BATADV_DBG_BATMAN, bat_priv,\r\n"Error - can't send packet from char device: got bogus packet type (expected: BAT_ICMP)\n");\r\nlen = -EINVAL;\r\ngoto free_skb;\r\n}\r\nswitch (icmp_header->msg_type) {\r\ncase BATADV_ECHO_REQUEST:\r\nif (len < sizeof(struct batadv_icmp_packet)) {\r\nbatadv_dbg(BATADV_DBG_BATMAN, bat_priv,\r\n"Error - can't send packet from char device: invalid packet size\n");\r\nlen = -EINVAL;\r\ngoto free_skb;\r\n}\r\nif (atomic_read(&bat_priv->mesh_state) != BATADV_MESH_ACTIVE)\r\ngoto dst_unreach;\r\norig_node = batadv_orig_hash_find(bat_priv, icmp_header->dst);\r\nif (!orig_node)\r\ngoto dst_unreach;\r\nneigh_node = batadv_orig_router_get(orig_node,\r\nBATADV_IF_DEFAULT);\r\nif (!neigh_node)\r\ngoto dst_unreach;\r\nif (!neigh_node->if_incoming)\r\ngoto dst_unreach;\r\nif (neigh_node->if_incoming->if_status != BATADV_IF_ACTIVE)\r\ngoto dst_unreach;\r\nicmp_packet_rr = (struct batadv_icmp_packet_rr *)icmp_header;\r\nif (packet_len == sizeof(*icmp_packet_rr)) {\r\naddr = neigh_node->if_incoming->net_dev->dev_addr;\r\nether_addr_copy(icmp_packet_rr->rr[0], addr);\r\n}\r\nbreak;\r\ndefault:\r\nbatadv_dbg(BATADV_DBG_BATMAN, bat_priv,\r\n"Error - can't send packet from char device: got unknown message type\n");\r\nlen = -EINVAL;\r\ngoto free_skb;\r\n}\r\nicmp_header->uid = socket_client->index;\r\nif (icmp_header->version != BATADV_COMPAT_VERSION) {\r\nicmp_header->msg_type = BATADV_PARAMETER_PROBLEM;\r\nicmp_header->version = BATADV_COMPAT_VERSION;\r\nbatadv_socket_add_packet(socket_client, icmp_header,\r\npacket_len);\r\ngoto free_skb;\r\n}\r\nether_addr_copy(icmp_header->orig, primary_if->net_dev->dev_addr);\r\nbatadv_send_skb_packet(skb, neigh_node->if_incoming, neigh_node->addr);\r\ngoto out;\r\ndst_unreach:\r\nicmp_header->msg_type = BATADV_DESTINATION_UNREACHABLE;\r\nbatadv_socket_add_packet(socket_client, icmp_header, packet_len);\r\nfree_skb:\r\nkfree_skb(skb);\r\nout:\r\nif (primary_if)\r\nbatadv_hardif_free_ref(primary_if);\r\nif (neigh_node)\r\nbatadv_neigh_node_free_ref(neigh_node);\r\nif (orig_node)\r\nbatadv_orig_node_free_ref(orig_node);\r\nreturn len;\r\n}\r\nstatic unsigned int batadv_socket_poll(struct file *file, poll_table *wait)\r\n{\r\nstruct batadv_socket_client *socket_client = file->private_data;\r\npoll_wait(file, &socket_client->queue_wait, wait);\r\nif (socket_client->queue_len > 0)\r\nreturn POLLIN | POLLRDNORM;\r\nreturn 0;\r\n}\r\nint batadv_socket_setup(struct batadv_priv *bat_priv)\r\n{\r\nstruct dentry *d;\r\nif (!bat_priv->debug_dir)\r\ngoto err;\r\nd = debugfs_create_file(BATADV_ICMP_SOCKET, S_IFREG | S_IWUSR | S_IRUSR,\r\nbat_priv->debug_dir, bat_priv, &batadv_fops);\r\nif (!d)\r\ngoto err;\r\nreturn 0;\r\nerr:\r\nreturn -ENOMEM;\r\n}\r\nstatic void batadv_socket_add_packet(struct batadv_socket_client *socket_client,\r\nstruct batadv_icmp_header *icmph,\r\nsize_t icmp_len)\r\n{\r\nstruct batadv_socket_packet *socket_packet;\r\nsize_t len;\r\nsocket_packet = kmalloc(sizeof(*socket_packet), GFP_ATOMIC);\r\nif (!socket_packet)\r\nreturn;\r\nlen = icmp_len;\r\nif (len > sizeof(socket_packet->icmp_packet))\r\nlen = sizeof(socket_packet->icmp_packet);\r\nINIT_LIST_HEAD(&socket_packet->list);\r\nmemcpy(&socket_packet->icmp_packet, icmph, len);\r\nsocket_packet->icmp_len = len;\r\nspin_lock_bh(&socket_client->lock);\r\nif (!batadv_socket_client_hash[icmph->uid]) {\r\nspin_unlock_bh(&socket_client->lock);\r\nkfree(socket_packet);\r\nreturn;\r\n}\r\nlist_add_tail(&socket_packet->list, &socket_client->queue_list);\r\nsocket_client->queue_len++;\r\nif (socket_client->queue_len > 100) {\r\nsocket_packet = list_first_entry(&socket_client->queue_list,\r\nstruct batadv_socket_packet,\r\nlist);\r\nlist_del(&socket_packet->list);\r\nkfree(socket_packet);\r\nsocket_client->queue_len--;\r\n}\r\nspin_unlock_bh(&socket_client->lock);\r\nwake_up(&socket_client->queue_wait);\r\n}\r\nvoid batadv_socket_receive_packet(struct batadv_icmp_header *icmph,\r\nsize_t icmp_len)\r\n{\r\nstruct batadv_socket_client *hash;\r\nhash = batadv_socket_client_hash[icmph->uid];\r\nif (hash)\r\nbatadv_socket_add_packet(hash, icmph, icmp_len);\r\n}
