static int as3935_read(struct as3935_state *st, unsigned int reg, int *val)\r\n{\r\nu8 cmd;\r\nint ret;\r\ncmd = (AS3935_READ_DATA | AS3935_ADDRESS(reg)) >> 8;\r\nret = spi_w8r8(st->spi, cmd);\r\nif (ret < 0)\r\nreturn ret;\r\n*val = ret;\r\nreturn 0;\r\n}\r\nstatic int as3935_write(struct as3935_state *st,\r\nunsigned int reg,\r\nunsigned int val)\r\n{\r\nu8 *buf = st->buf;\r\nbuf[0] = (AS3935_WRITE_DATA | AS3935_ADDRESS(reg)) >> 8;\r\nbuf[1] = val;\r\nreturn spi_write(st->spi, buf, 2);\r\n}\r\nstatic ssize_t as3935_sensor_sensitivity_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct as3935_state *st = iio_priv(dev_to_iio_dev(dev));\r\nint val, ret;\r\nret = as3935_read(st, AS3935_AFE_GAIN, &val);\r\nif (ret)\r\nreturn ret;\r\nval = (val & AS3935_AFE_MASK) >> 1;\r\nreturn sprintf(buf, "%d\n", val);\r\n}\r\nstatic ssize_t as3935_sensor_sensitivity_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t len)\r\n{\r\nstruct as3935_state *st = iio_priv(dev_to_iio_dev(dev));\r\nunsigned long val;\r\nint ret;\r\nret = kstrtoul((const char *) buf, 10, &val);\r\nif (ret)\r\nreturn -EINVAL;\r\nif (val > AS3935_AFE_GAIN_MAX)\r\nreturn -EINVAL;\r\nas3935_write(st, AS3935_AFE_GAIN, val << 1);\r\nreturn len;\r\n}\r\nstatic int as3935_read_raw(struct iio_dev *indio_dev,\r\nstruct iio_chan_spec const *chan,\r\nint *val,\r\nint *val2,\r\nlong m)\r\n{\r\nstruct as3935_state *st = iio_priv(indio_dev);\r\nint ret;\r\nswitch (m) {\r\ncase IIO_CHAN_INFO_PROCESSED:\r\ncase IIO_CHAN_INFO_RAW:\r\n*val2 = 0;\r\nret = as3935_read(st, AS3935_DATA, val);\r\nif (ret)\r\nreturn ret;\r\nif (m == IIO_CHAN_INFO_RAW)\r\nreturn IIO_VAL_INT;\r\nif (*val == AS3935_DATA_MASK)\r\nreturn -EINVAL;\r\n*val *= 1000;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn IIO_VAL_INT;\r\n}\r\nstatic irqreturn_t as3935_trigger_handler(int irq, void *private)\r\n{\r\nstruct iio_poll_func *pf = private;\r\nstruct iio_dev *indio_dev = pf->indio_dev;\r\nstruct as3935_state *st = iio_priv(indio_dev);\r\nint val, ret;\r\nret = as3935_read(st, AS3935_DATA, &val);\r\nif (ret)\r\ngoto err_read;\r\nval &= AS3935_DATA_MASK;\r\nval *= 1000;\r\niio_push_to_buffers_with_timestamp(indio_dev, &val, pf->timestamp);\r\nerr_read:\r\niio_trigger_notify_done(indio_dev->trig);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void as3935_event_work(struct work_struct *work)\r\n{\r\nstruct as3935_state *st;\r\nint val;\r\nst = container_of(work, struct as3935_state, work.work);\r\nas3935_read(st, AS3935_INT, &val);\r\nval &= AS3935_INT_MASK;\r\nswitch (val) {\r\ncase AS3935_EVENT_INT:\r\niio_trigger_poll(st->trig);\r\nbreak;\r\ncase AS3935_NOISE_INT:\r\ndev_warn(&st->spi->dev, "noise level is too high");\r\nbreak;\r\n}\r\n}\r\nstatic irqreturn_t as3935_interrupt_handler(int irq, void *private)\r\n{\r\nstruct iio_dev *indio_dev = private;\r\nstruct as3935_state *st = iio_priv(indio_dev);\r\nschedule_delayed_work(&st->work, msecs_to_jiffies(3));\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void calibrate_as3935(struct as3935_state *st)\r\n{\r\nmutex_lock(&st->lock);\r\nas3935_write(st, AS3935_INT, BIT(5));\r\nas3935_write(st, AS3935_CALIBRATE, 0x96);\r\nas3935_write(st, AS3935_TUNE_CAP,\r\nBIT(5) | (st->tune_cap / TUNE_CAP_DIV));\r\nmdelay(2);\r\nas3935_write(st, AS3935_TUNE_CAP, (st->tune_cap / TUNE_CAP_DIV));\r\nmutex_unlock(&st->lock);\r\n}\r\nstatic int as3935_suspend(struct device *dev)\r\n{\r\nstruct iio_dev *indio_dev = dev_get_drvdata(dev);\r\nstruct as3935_state *st = iio_priv(indio_dev);\r\nint val, ret;\r\nmutex_lock(&st->lock);\r\nret = as3935_read(st, AS3935_AFE_GAIN, &val);\r\nif (ret)\r\ngoto err_suspend;\r\nval |= AS3935_AFE_PWR_BIT;\r\nret = as3935_write(st, AS3935_AFE_GAIN, val);\r\nerr_suspend:\r\nmutex_unlock(&st->lock);\r\nreturn ret;\r\n}\r\nstatic int as3935_resume(struct device *dev)\r\n{\r\nstruct iio_dev *indio_dev = dev_get_drvdata(dev);\r\nstruct as3935_state *st = iio_priv(indio_dev);\r\nint val, ret;\r\nmutex_lock(&st->lock);\r\nret = as3935_read(st, AS3935_AFE_GAIN, &val);\r\nif (ret)\r\ngoto err_resume;\r\nval &= ~AS3935_AFE_PWR_BIT;\r\nret = as3935_write(st, AS3935_AFE_GAIN, val);\r\nerr_resume:\r\nmutex_unlock(&st->lock);\r\nreturn ret;\r\n}\r\nstatic int as3935_probe(struct spi_device *spi)\r\n{\r\nstruct iio_dev *indio_dev;\r\nstruct iio_trigger *trig;\r\nstruct as3935_state *st;\r\nstruct device_node *np = spi->dev.of_node;\r\nint ret;\r\nif (!spi->irq) {\r\ndev_err(&spi->dev, "unable to get event interrupt\n");\r\nreturn -EINVAL;\r\n}\r\nindio_dev = devm_iio_device_alloc(&spi->dev, sizeof(*st));\r\nif (!indio_dev)\r\nreturn -ENOMEM;\r\nst = iio_priv(indio_dev);\r\nst->spi = spi;\r\nst->tune_cap = 0;\r\nspi_set_drvdata(spi, indio_dev);\r\nmutex_init(&st->lock);\r\nINIT_DELAYED_WORK(&st->work, as3935_event_work);\r\nret = of_property_read_u32(np,\r\n"ams,tuning-capacitor-pf", &st->tune_cap);\r\nif (ret) {\r\nst->tune_cap = 0;\r\ndev_warn(&spi->dev,\r\n"no tuning-capacitor-pf set, defaulting to %d",\r\nst->tune_cap);\r\n}\r\nif (st->tune_cap > MAX_PF_CAP) {\r\ndev_err(&spi->dev,\r\n"wrong tuning-capacitor-pf setting of %d\n",\r\nst->tune_cap);\r\nreturn -EINVAL;\r\n}\r\nindio_dev->dev.parent = &spi->dev;\r\nindio_dev->name = spi_get_device_id(spi)->name;\r\nindio_dev->channels = as3935_channels;\r\nindio_dev->num_channels = ARRAY_SIZE(as3935_channels);\r\nindio_dev->modes = INDIO_DIRECT_MODE;\r\nindio_dev->info = &as3935_info;\r\ntrig = devm_iio_trigger_alloc(&spi->dev, "%s-dev%d",\r\nindio_dev->name, indio_dev->id);\r\nif (!trig)\r\nreturn -ENOMEM;\r\nst->trig = trig;\r\ntrig->dev.parent = indio_dev->dev.parent;\r\niio_trigger_set_drvdata(trig, indio_dev);\r\ntrig->ops = &iio_interrupt_trigger_ops;\r\nret = iio_trigger_register(trig);\r\nif (ret) {\r\ndev_err(&spi->dev, "failed to register trigger\n");\r\nreturn ret;\r\n}\r\nret = iio_triggered_buffer_setup(indio_dev, NULL,\r\n&as3935_trigger_handler, NULL);\r\nif (ret) {\r\ndev_err(&spi->dev, "cannot setup iio trigger\n");\r\ngoto unregister_trigger;\r\n}\r\ncalibrate_as3935(st);\r\nret = devm_request_irq(&spi->dev, spi->irq,\r\n&as3935_interrupt_handler,\r\nIRQF_TRIGGER_RISING,\r\ndev_name(&spi->dev),\r\nindio_dev);\r\nif (ret) {\r\ndev_err(&spi->dev, "unable to request irq\n");\r\ngoto unregister_buffer;\r\n}\r\nret = iio_device_register(indio_dev);\r\nif (ret < 0) {\r\ndev_err(&spi->dev, "unable to register device\n");\r\ngoto unregister_buffer;\r\n}\r\nreturn 0;\r\nunregister_buffer:\r\niio_triggered_buffer_cleanup(indio_dev);\r\nunregister_trigger:\r\niio_trigger_unregister(st->trig);\r\nreturn ret;\r\n}\r\nstatic int as3935_remove(struct spi_device *spi)\r\n{\r\nstruct iio_dev *indio_dev = spi_get_drvdata(spi);\r\nstruct as3935_state *st = iio_priv(indio_dev);\r\niio_device_unregister(indio_dev);\r\niio_triggered_buffer_cleanup(indio_dev);\r\niio_trigger_unregister(st->trig);\r\nreturn 0;\r\n}
