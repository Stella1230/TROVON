static void print_banner( struct Scsi_Host *shpnt )\r\n{\r\nif (!shpnt) return;\r\nif (bios_major < 0 && bios_minor < 0) {\r\nprintk(KERN_INFO "scsi%d: <fdomain> No BIOS; using scsi id %d\n",\r\nshpnt->host_no, shpnt->this_id);\r\n} else {\r\nprintk(KERN_INFO "scsi%d: <fdomain> BIOS version ", shpnt->host_no);\r\nif (bios_major >= 0) printk("%d.", bios_major);\r\nelse printk("?.");\r\nif (bios_minor >= 0) printk("%d", bios_minor);\r\nelse printk("?.");\r\nprintk( " at 0x%lx using scsi id %d\n",\r\nbios_base, shpnt->this_id );\r\n}\r\nprintk(KERN_INFO "scsi%d: <fdomain> %s chip at 0x%x irq ",\r\nshpnt->host_no,\r\nchip == tmc1800 ? "TMC-1800" : (chip == tmc18c50 ? "TMC-18C50" : (chip == tmc18c30 ? (PCI_bus ? "TMC-36C70 (PCI bus)" : "TMC-18C30") : "Unknown")),\r\nport_base);\r\nif (interrupt_level)\r\nprintk("%d", interrupt_level);\r\nelse\r\nprintk("<none>");\r\nprintk( "\n" );\r\n}\r\nint fdomain_setup(char *str)\r\n{\r\nint ints[4];\r\n(void)get_options(str, ARRAY_SIZE(ints), ints);\r\nif (setup_called++ || ints[0] < 2 || ints[0] > 3) {\r\nprintk(KERN_INFO "scsi: <fdomain> Usage: fdomain=<PORT_BASE>,<IRQ>[,<ADAPTER_ID>]\n");\r\nprintk(KERN_ERR "scsi: <fdomain> Bad LILO/INSMOD parameters?\n");\r\nreturn 0;\r\n}\r\nport_base = ints[0] >= 1 ? ints[1] : 0;\r\ninterrupt_level = ints[0] >= 2 ? ints[2] : 0;\r\nthis_id = ints[0] >= 3 ? ints[3] : 0;\r\nbios_major = bios_minor = -1;\r\n++setup_called;\r\nreturn 1;\r\n}\r\nstatic void do_pause(unsigned amount)\r\n{\r\nmdelay(10*amount);\r\n}\r\nstatic inline void fdomain_make_bus_idle( void )\r\n{\r\noutb(0, port_base + SCSI_Cntl);\r\noutb(0, port_base + SCSI_Mode_Cntl);\r\nif (chip == tmc18c50 || chip == tmc18c30)\r\noutb(0x21 | PARITY_MASK, port_base + TMC_Cntl);\r\nelse\r\noutb(0x01 | PARITY_MASK, port_base + TMC_Cntl);\r\n}\r\nstatic int fdomain_is_valid_port( int port )\r\n{\r\n#if DEBUG_DETECT\r\nprintk( " (%x%x),",\r\ninb( port + MSB_ID_Code ), inb( port + LSB_ID_Code ) );\r\n#endif\r\nif (inb( port + LSB_ID_Code ) != 0xe9) {\r\nif (inb( port + LSB_ID_Code ) != 0x27) return 0;\r\nif (inb( port + MSB_ID_Code ) != 0x61) return 0;\r\nchip = tmc1800;\r\n} else {\r\nif (inb( port + MSB_ID_Code ) != 0x60) return 0;\r\nchip = tmc18c50;\r\noutb( 0x80, port + IO_Control );\r\nif ((inb( port + Configuration2 ) & 0x80) == 0x80) {\r\noutb( 0x00, port + IO_Control );\r\nif ((inb( port + Configuration2 ) & 0x80) == 0x00) {\r\nchip = tmc18c30;\r\nFIFO_Size = 0x800;\r\n}\r\n}\r\n}\r\nreturn 1;\r\n}\r\nstatic int fdomain_test_loopback( void )\r\n{\r\nint i;\r\nint result;\r\nfor (i = 0; i < 255; i++) {\r\noutb( i, port_base + Write_Loopback );\r\nresult = inb( port_base + Read_Loopback );\r\nif (i != result)\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int fdomain_get_irq( int base )\r\n{\r\nint options = inb(base + Configuration1);\r\n#if DEBUG_DETECT\r\nprintk("scsi: <fdomain> Options = %x\n", options);\r\n#endif\r\nif (chip != tmc18c30 && !PCI_bus && addresses[(options & 0xc0) >> 6 ] != bios_base)\r\nreturn 0;\r\nreturn ints[(options & 0x0e) >> 1];\r\n}\r\nstatic int fdomain_isa_detect( int *irq, int *iobase )\r\n{\r\nint i, j;\r\nint base = 0xdeadbeef;\r\nint flag = 0;\r\n#if DEBUG_DETECT\r\nprintk( "scsi: <fdomain> fdomain_isa_detect:" );\r\n#endif\r\nfor (i = 0; i < ADDRESS_COUNT; i++) {\r\nvoid __iomem *p = ioremap(addresses[i], 0x2000);\r\nif (!p)\r\ncontinue;\r\n#if DEBUG_DETECT\r\nprintk( " %lx(%lx),", addresses[i], bios_base );\r\n#endif\r\nfor (j = 0; j < SIGNATURE_COUNT; j++) {\r\nif (check_signature(p + signatures[j].sig_offset,\r\nsignatures[j].signature,\r\nsignatures[j].sig_length )) {\r\nbios_major = signatures[j].major_bios_version;\r\nbios_minor = signatures[j].minor_bios_version;\r\nPCI_bus = (signatures[j].flag == 1);\r\nQuantum = (signatures[j].flag > 1) ? signatures[j].flag : 0;\r\nbios_base = addresses[i];\r\nbios_mem = p;\r\ngoto found;\r\n}\r\n}\r\niounmap(p);\r\n}\r\nfound:\r\nif (bios_major == 2) {\r\nswitch (Quantum) {\r\ncase 2:\r\ncase 3:\r\nbase = readb(bios_mem + 0x1fa2) + (readb(bios_mem + 0x1fa3) << 8);\r\nbreak;\r\ncase 4:\r\nbase = readb(bios_mem + 0x1fa3) + (readb(bios_mem + 0x1fa4) << 8);\r\nbreak;\r\ndefault:\r\nbase = readb(bios_mem + 0x1fcc) + (readb(bios_mem + 0x1fcd) << 8);\r\nbreak;\r\n}\r\n#if DEBUG_DETECT\r\nprintk( " %x,", base );\r\n#endif\r\nfor (i = 0; i < PORT_COUNT; i++) {\r\nif (base == ports[i]) {\r\nif (!request_region(base, 0x10, "fdomain"))\r\nbreak;\r\nif (!fdomain_is_valid_port(base)) {\r\nrelease_region(base, 0x10);\r\nbreak;\r\n}\r\n*irq = fdomain_get_irq( base );\r\n*iobase = base;\r\nreturn 1;\r\n}\r\n}\r\n#if DEBUG_DETECT\r\nprintk( " RAM FAILED, " );\r\n#endif\r\n}\r\nfor (i = 0; i < PORT_COUNT; i++) {\r\nbase = ports[i];\r\nif (!request_region(base, 0x10, "fdomain")) {\r\n#if DEBUG_DETECT\r\nprintk( " (%x inuse),", base );\r\n#endif\r\ncontinue;\r\n}\r\n#if DEBUG_DETECT\r\nprintk( " %x,", base );\r\n#endif\r\nflag = fdomain_is_valid_port(base);\r\nif (flag)\r\nbreak;\r\nrelease_region(base, 0x10);\r\n}\r\n#if DEBUG_DETECT\r\nif (flag) printk( " SUCCESS\n" );\r\nelse printk( " FAILURE\n" );\r\n#endif\r\nif (!flag) return 0;\r\n*irq = fdomain_get_irq( base );\r\n*iobase = base;\r\nreturn 1;\r\n}\r\nstatic int fdomain_isa_detect( int *irq, int *iobase )\r\n{\r\nif (irq)\r\n*irq = 0;\r\nif (iobase)\r\n*iobase = 0;\r\nreturn 0;\r\n}\r\nstatic int fdomain_pci_bios_detect( int *irq, int *iobase, struct pci_dev **ret_pdev )\r\n{\r\nunsigned int pci_irq;\r\nunsigned long pci_base;\r\nstruct pci_dev *pdev = NULL;\r\n#if DEBUG_DETECT\r\nprintk( "scsi: <fdomain> INFO: use lspci -v to see list of PCI devices\n" );\r\nprintk( "scsi: <fdomain> TMC-3260 detect:"\r\n" Using Vendor ID: 0x%x and Device ID: 0x%x\n",\r\nPCI_VENDOR_ID_FD,\r\nPCI_DEVICE_ID_FD_36C70 );\r\n#endif\r\nif ((pdev = pci_get_device(PCI_VENDOR_ID_FD, PCI_DEVICE_ID_FD_36C70, pdev)) == NULL)\r\nreturn 0;\r\nif (pci_enable_device(pdev))\r\ngoto fail;\r\n#if DEBUG_DETECT\r\nprintk( "scsi: <fdomain> TMC-3260 detect:"\r\n" PCI bus %u, device %u, function %u\n",\r\npdev->bus->number,\r\nPCI_SLOT(pdev->devfn),\r\nPCI_FUNC(pdev->devfn));\r\n#endif\r\npci_base = pci_resource_start(pdev, 0);\r\npci_irq = pdev->irq;\r\nif (!request_region( pci_base, 0x10, "fdomain" ))\r\ngoto fail;\r\n*irq = pci_irq;\r\n*iobase = pci_base;\r\n*ret_pdev = pdev;\r\n#if DEBUG_DETECT\r\nprintk( "scsi: <fdomain> TMC-3260 detect:"\r\n" IRQ = %d, I/O base = 0x%x [0x%lx]\n", *irq, *iobase, pci_base );\r\n#endif\r\nif (!fdomain_is_valid_port(pci_base)) {\r\nprintk(KERN_ERR "scsi: <fdomain> PCI card detected, but driver not loaded (invalid port)\n" );\r\nrelease_region(pci_base, 0x10);\r\ngoto fail;\r\n}\r\nbios_major = bios_minor = -1;\r\nPCI_bus = 1;\r\nPCI_dev = pdev;\r\nQuantum = 0;\r\nbios_base = 0;\r\nreturn 1;\r\nfail:\r\npci_dev_put(pdev);\r\nreturn 0;\r\n}\r\nstruct Scsi_Host *__fdomain_16x0_detect(struct scsi_host_template *tpnt )\r\n{\r\nint retcode;\r\nstruct Scsi_Host *shpnt;\r\nstruct pci_dev *pdev = NULL;\r\nif (setup_called) {\r\n#if DEBUG_DETECT\r\nprintk( "scsi: <fdomain> No BIOS, using port_base = 0x%x, irq = %d\n",\r\nport_base, interrupt_level );\r\n#endif\r\nif (!request_region(port_base, 0x10, "fdomain")) {\r\nprintk( "scsi: <fdomain> port 0x%x is busy\n", port_base );\r\nprintk( "scsi: <fdomain> Bad LILO/INSMOD parameters?\n" );\r\nreturn NULL;\r\n}\r\nif (!fdomain_is_valid_port( port_base )) {\r\nprintk( "scsi: <fdomain> Cannot locate chip at port base 0x%x\n",\r\nport_base );\r\nprintk( "scsi: <fdomain> Bad LILO/INSMOD parameters?\n" );\r\nrelease_region(port_base, 0x10);\r\nreturn NULL;\r\n}\r\n} else {\r\nint flag = 0;\r\n#ifdef CONFIG_PCI\r\nflag = fdomain_pci_bios_detect( &interrupt_level, &port_base, &pdev );\r\n#endif\r\nif (!flag) {\r\nflag = fdomain_isa_detect( &interrupt_level, &port_base );\r\nif (!flag) {\r\nprintk( "scsi: <fdomain> Detection failed (no card)\n" );\r\nreturn NULL;\r\n}\r\n}\r\n}\r\nfdomain_16x0_bus_reset(NULL);\r\nif (fdomain_test_loopback()) {\r\nprintk(KERN_ERR "scsi: <fdomain> Detection failed (loopback test failed at port base 0x%x)\n", port_base);\r\nif (setup_called) {\r\nprintk(KERN_ERR "scsi: <fdomain> Bad LILO/INSMOD parameters?\n");\r\n}\r\ngoto fail;\r\n}\r\nif (this_id) {\r\ntpnt->this_id = (this_id & 0x07);\r\nadapter_mask = (1 << tpnt->this_id);\r\n} else {\r\nif (PCI_bus || (bios_major == 3 && bios_minor >= 2) || bios_major < 0) {\r\ntpnt->this_id = 7;\r\nadapter_mask = 0x80;\r\n} else {\r\ntpnt->this_id = 6;\r\nadapter_mask = 0x40;\r\n}\r\n}\r\nshpnt = scsi_register( tpnt, 0 );\r\nif(shpnt == NULL) {\r\nrelease_region(port_base, 0x10);\r\nreturn NULL;\r\n}\r\nshpnt->irq = interrupt_level;\r\nshpnt->io_port = port_base;\r\nshpnt->n_io_port = 0x10;\r\nprint_banner( shpnt );\r\nif (!interrupt_level) {\r\nprintk(KERN_ERR "scsi: <fdomain> Card Detected, but driver not loaded (no IRQ)\n" );\r\ngoto fail;\r\n} else {\r\nretcode = request_irq( interrupt_level,\r\ndo_fdomain_16x0_intr, pdev?IRQF_SHARED:0, "fdomain", shpnt);\r\nif (retcode < 0) {\r\nif (retcode == -EINVAL) {\r\nprintk(KERN_ERR "scsi: <fdomain> IRQ %d is bad!\n", interrupt_level );\r\nprintk(KERN_ERR " This shouldn't happen!\n" );\r\nprintk(KERN_ERR " Send mail to faith@acm.org\n" );\r\n} else if (retcode == -EBUSY) {\r\nprintk(KERN_ERR "scsi: <fdomain> IRQ %d is already in use!\n", interrupt_level );\r\nprintk(KERN_ERR " Please use another IRQ!\n" );\r\n} else {\r\nprintk(KERN_ERR "scsi: <fdomain> Error getting IRQ %d\n", interrupt_level );\r\nprintk(KERN_ERR " This shouldn't happen!\n" );\r\nprintk(KERN_ERR " Send mail to faith@acm.org\n" );\r\n}\r\nprintk(KERN_ERR "scsi: <fdomain> Detected, but driver not loaded (IRQ)\n" );\r\ngoto fail;\r\n}\r\n}\r\nreturn shpnt;\r\nfail:\r\npci_dev_put(pdev);\r\nrelease_region(port_base, 0x10);\r\nreturn NULL;\r\n}\r\nstatic int fdomain_16x0_detect(struct scsi_host_template *tpnt)\r\n{\r\nif (fdomain)\r\nfdomain_setup(fdomain);\r\nreturn (__fdomain_16x0_detect(tpnt) != NULL);\r\n}\r\nstatic const char *fdomain_16x0_info( struct Scsi_Host *ignore )\r\n{\r\nstatic char buffer[128];\r\nchar *pt;\r\nstrcpy( buffer, "Future Domain 16-bit SCSI Driver Version" );\r\nif (strchr( VERSION, ':')) {\r\nstrcat( buffer, strchr( VERSION, ':' ) + 1 );\r\npt = strrchr( buffer, '$') - 1;\r\nif (!pt)\r\npt = buffer + strlen( buffer ) - 1;\r\nif (*pt != ' ')\r\n++pt;\r\n*pt = '\0';\r\n} else {\r\nstrcat( buffer, " " VERSION );\r\n}\r\nreturn buffer;\r\n}\r\nstatic int fdomain_select( int target )\r\n{\r\nint status;\r\nunsigned long timeout;\r\n#if ERRORS_ONLY\r\nstatic int flag = 0;\r\n#endif\r\noutb(0x82, port_base + SCSI_Cntl);\r\noutb(adapter_mask | (1 << target), port_base + SCSI_Data_NoACK);\r\noutb(PARITY_MASK, port_base + TMC_Cntl);\r\ntimeout = 350;\r\ndo {\r\nstatus = inb(port_base + SCSI_Status);\r\nif (status & 1) {\r\noutb(0x80, port_base + SCSI_Cntl);\r\nreturn 0;\r\n}\r\nmdelay(1);\r\n} while (--timeout);\r\nfdomain_make_bus_idle();\r\n#if EVERY_ACCESS\r\nif (!target) printk( "Selection failed\n" );\r\n#endif\r\n#if ERRORS_ONLY\r\nif (!target) {\r\nif (!flag)\r\n++flag;\r\nelse\r\nprintk( "scsi: <fdomain> Selection failed\n" );\r\n}\r\n#endif\r\nreturn 1;\r\n}\r\nstatic void my_done(int error)\r\n{\r\nif (in_command) {\r\nin_command = 0;\r\noutb(0x00, port_base + Interrupt_Cntl);\r\nfdomain_make_bus_idle();\r\ncurrent_SC->result = error;\r\nif (current_SC->scsi_done)\r\ncurrent_SC->scsi_done( current_SC );\r\nelse panic( "scsi: <fdomain> current_SC->scsi_done() == NULL" );\r\n} else {\r\npanic( "scsi: <fdomain> my_done() called outside of command\n" );\r\n}\r\n#if DEBUG_RACE\r\nin_interrupt_flag = 0;\r\n#endif\r\n}\r\nstatic irqreturn_t do_fdomain_16x0_intr(int irq, void *dev_id)\r\n{\r\nunsigned long flags;\r\nint status;\r\nint done = 0;\r\nunsigned data_count;\r\nif ((inb(port_base + TMC_Status) & 0x01) == 0)\r\nreturn IRQ_NONE;\r\noutb(0x00, port_base + Interrupt_Cntl);\r\nif (!in_command || !current_SC) {\r\n#if EVERY_ACCESS\r\nprintk( "Spurious interrupt, in_command = %d, current_SC = %x\n",\r\nin_command, current_SC );\r\n#endif\r\nreturn IRQ_NONE;\r\n}\r\nif (current_SC->SCp.phase & aborted) {\r\n#if DEBUG_ABORT\r\nprintk( "scsi: <fdomain> Interrupt after abort, ignoring\n" );\r\n#endif\r\n}\r\n#if DEBUG_RACE\r\n++in_interrupt_flag;\r\n#endif\r\nif (current_SC->SCp.phase & in_arbitration) {\r\nstatus = inb(port_base + TMC_Status);\r\nif (!(status & 0x02)) {\r\n#if EVERY_ACCESS\r\nprintk( " AFAIL " );\r\n#endif\r\nspin_lock_irqsave(current_SC->device->host->host_lock, flags);\r\nmy_done( DID_BUS_BUSY << 16 );\r\nspin_unlock_irqrestore(current_SC->device->host->host_lock, flags);\r\nreturn IRQ_HANDLED;\r\n}\r\ncurrent_SC->SCp.phase = in_selection;\r\noutb(0x40 | FIFO_COUNT, port_base + Interrupt_Cntl);\r\noutb(0x82, port_base + SCSI_Cntl);\r\noutb(adapter_mask | (1 << scmd_id(current_SC)), port_base + SCSI_Data_NoACK);\r\noutb(0x10 | PARITY_MASK, port_base + TMC_Cntl);\r\n#if DEBUG_RACE\r\nin_interrupt_flag = 0;\r\n#endif\r\nreturn IRQ_HANDLED;\r\n} else if (current_SC->SCp.phase & in_selection) {\r\nstatus = inb(port_base + SCSI_Status);\r\nif (!(status & 0x01)) {\r\nif (fdomain_select( scmd_id(current_SC) )) {\r\n#if EVERY_ACCESS\r\nprintk( " SFAIL " );\r\n#endif\r\nspin_lock_irqsave(current_SC->device->host->host_lock, flags);\r\nmy_done( DID_NO_CONNECT << 16 );\r\nspin_unlock_irqrestore(current_SC->device->host->host_lock, flags);\r\nreturn IRQ_HANDLED;\r\n} else {\r\n#if EVERY_ACCESS\r\nprintk( " AltSel " );\r\n#endif\r\noutb(0x10 | PARITY_MASK, port_base + TMC_Cntl);\r\n}\r\n}\r\ncurrent_SC->SCp.phase = in_other;\r\noutb(0x90 | FIFO_COUNT, port_base + Interrupt_Cntl);\r\noutb(0x80, port_base + SCSI_Cntl);\r\n#if DEBUG_RACE\r\nin_interrupt_flag = 0;\r\n#endif\r\nreturn IRQ_HANDLED;\r\n}\r\nstatus = inb(port_base + SCSI_Status);\r\nif (status & 0x10) {\r\nswitch (status & 0x0e) {\r\ncase 0x08:\r\noutb(current_SC->cmnd[current_SC->SCp.sent_command++],\r\nport_base + Write_SCSI_Data);\r\n#if EVERY_ACCESS\r\nprintk( "CMD = %x,",\r\ncurrent_SC->cmnd[ current_SC->SCp.sent_command - 1] );\r\n#endif\r\nbreak;\r\ncase 0x00:\r\nif (chip != tmc1800 && !current_SC->SCp.have_data_in) {\r\ncurrent_SC->SCp.have_data_in = -1;\r\noutb(0xd0 | PARITY_MASK, port_base + TMC_Cntl);\r\n}\r\nbreak;\r\ncase 0x04:\r\nif (chip != tmc1800 && !current_SC->SCp.have_data_in) {\r\ncurrent_SC->SCp.have_data_in = 1;\r\noutb(0x90 | PARITY_MASK, port_base + TMC_Cntl);\r\n}\r\nbreak;\r\ncase 0x0c:\r\ncurrent_SC->SCp.Status = inb(port_base + Read_SCSI_Data);\r\n#if EVERY_ACCESS\r\nprintk( "Status = %x, ", current_SC->SCp.Status );\r\n#endif\r\n#if ERRORS_ONLY\r\nif (current_SC->SCp.Status\r\n&& current_SC->SCp.Status != 2\r\n&& current_SC->SCp.Status != 8) {\r\nprintk( "scsi: <fdomain> target = %d, command = %x, status = %x\n",\r\ncurrent_SC->device->id,\r\ncurrent_SC->cmnd[0],\r\ncurrent_SC->SCp.Status );\r\n}\r\n#endif\r\nbreak;\r\ncase 0x0a:\r\noutb(MESSAGE_REJECT, port_base + Write_SCSI_Data);\r\nbreak;\r\ncase 0x0e:\r\ncurrent_SC->SCp.Message = inb(port_base + Read_SCSI_Data);\r\n#if EVERY_ACCESS\r\nprintk( "Message = %x, ", current_SC->SCp.Message );\r\n#endif\r\nif (!current_SC->SCp.Message) ++done;\r\n#if DEBUG_MESSAGES || EVERY_ACCESS\r\nif (current_SC->SCp.Message) {\r\nprintk( "scsi: <fdomain> message = %x\n",\r\ncurrent_SC->SCp.Message );\r\n}\r\n#endif\r\nbreak;\r\n}\r\n}\r\nif (chip == tmc1800 && !current_SC->SCp.have_data_in\r\n&& (current_SC->SCp.sent_command >= current_SC->cmd_len)) {\r\nif(current_SC->sc_data_direction == DMA_TO_DEVICE)\r\n{\r\ncurrent_SC->SCp.have_data_in = -1;\r\noutb(0xd0 | PARITY_MASK, port_base + TMC_Cntl);\r\n}\r\nelse\r\n{\r\ncurrent_SC->SCp.have_data_in = 1;\r\noutb(0x90 | PARITY_MASK, port_base + TMC_Cntl);\r\n}\r\n}\r\nif (current_SC->SCp.have_data_in == -1) {\r\nwhile ((data_count = FIFO_Size - inw(port_base + FIFO_Data_Count)) > 512) {\r\n#if EVERY_ACCESS\r\nprintk( "DC=%d, ", data_count ) ;\r\n#endif\r\nif (data_count > current_SC->SCp.this_residual)\r\ndata_count = current_SC->SCp.this_residual;\r\nif (data_count > 0) {\r\n#if EVERY_ACCESS\r\nprintk( "%d OUT, ", data_count );\r\n#endif\r\nif (data_count == 1) {\r\noutb(*current_SC->SCp.ptr++, port_base + Write_FIFO);\r\n--current_SC->SCp.this_residual;\r\n} else {\r\ndata_count >>= 1;\r\noutsw(port_base + Write_FIFO, current_SC->SCp.ptr, data_count);\r\ncurrent_SC->SCp.ptr += 2 * data_count;\r\ncurrent_SC->SCp.this_residual -= 2 * data_count;\r\n}\r\n}\r\nif (!current_SC->SCp.this_residual) {\r\nif (current_SC->SCp.buffers_residual) {\r\n--current_SC->SCp.buffers_residual;\r\n++current_SC->SCp.buffer;\r\ncurrent_SC->SCp.ptr = sg_virt(current_SC->SCp.buffer);\r\ncurrent_SC->SCp.this_residual = current_SC->SCp.buffer->length;\r\n} else\r\nbreak;\r\n}\r\n}\r\n}\r\nif (current_SC->SCp.have_data_in == 1) {\r\nwhile ((data_count = inw(port_base + FIFO_Data_Count)) > 0) {\r\n#if EVERY_ACCESS\r\nprintk( "DC=%d, ", data_count );\r\n#endif\r\nif (data_count > current_SC->SCp.this_residual)\r\ndata_count = current_SC->SCp.this_residual;\r\nif (data_count) {\r\n#if EVERY_ACCESS\r\nprintk( "%d IN, ", data_count );\r\n#endif\r\nif (data_count == 1) {\r\n*current_SC->SCp.ptr++ = inb(port_base + Read_FIFO);\r\n--current_SC->SCp.this_residual;\r\n} else {\r\ndata_count >>= 1;\r\ninsw(port_base + Read_FIFO, current_SC->SCp.ptr, data_count);\r\ncurrent_SC->SCp.ptr += 2 * data_count;\r\ncurrent_SC->SCp.this_residual -= 2 * data_count;\r\n}\r\n}\r\nif (!current_SC->SCp.this_residual\r\n&& current_SC->SCp.buffers_residual) {\r\n--current_SC->SCp.buffers_residual;\r\n++current_SC->SCp.buffer;\r\ncurrent_SC->SCp.ptr = sg_virt(current_SC->SCp.buffer);\r\ncurrent_SC->SCp.this_residual = current_SC->SCp.buffer->length;\r\n}\r\n}\r\n}\r\nif (done) {\r\n#if EVERY_ACCESS\r\nprintk( " ** IN DONE %d ** ", current_SC->SCp.have_data_in );\r\n#endif\r\n#if ERRORS_ONLY\r\nif (current_SC->cmnd[0] == REQUEST_SENSE && !current_SC->SCp.Status) {\r\nchar *buf = scsi_sglist(current_SC);\r\nif ((unsigned char)(*(buf + 2)) & 0x0f) {\r\nunsigned char key;\r\nunsigned char code;\r\nunsigned char qualifier;\r\nkey = (unsigned char)(*(buf + 2)) & 0x0f;\r\ncode = (unsigned char)(*(buf + 12));\r\nqualifier = (unsigned char)(*(buf + 13));\r\nif (key != UNIT_ATTENTION\r\n&& !(key == NOT_READY\r\n&& code == 0x04\r\n&& (!qualifier || qualifier == 0x02 || qualifier == 0x01))\r\n&& !(key == ILLEGAL_REQUEST && (code == 0x25\r\n|| code == 0x24\r\n|| !code)))\r\nprintk( "scsi: <fdomain> REQUEST SENSE"\r\n" Key = %x, Code = %x, Qualifier = %x\n",\r\nkey, code, qualifier );\r\n}\r\n}\r\n#endif\r\n#if EVERY_ACCESS\r\nprintk( "BEFORE MY_DONE. . ." );\r\n#endif\r\nspin_lock_irqsave(current_SC->device->host->host_lock, flags);\r\nmy_done( (current_SC->SCp.Status & 0xff)\r\n| ((current_SC->SCp.Message & 0xff) << 8) | (DID_OK << 16) );\r\nspin_unlock_irqrestore(current_SC->device->host->host_lock, flags);\r\n#if EVERY_ACCESS\r\nprintk( "RETURNING.\n" );\r\n#endif\r\n} else {\r\nif (current_SC->SCp.phase & disconnect) {\r\noutb(0xd0 | FIFO_COUNT, port_base + Interrupt_Cntl);\r\noutb(0x00, port_base + SCSI_Cntl);\r\n} else {\r\noutb(0x90 | FIFO_COUNT, port_base + Interrupt_Cntl);\r\n}\r\n}\r\n#if DEBUG_RACE\r\nin_interrupt_flag = 0;\r\n#endif\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int fdomain_16x0_queue_lck(struct scsi_cmnd *SCpnt,\r\nvoid (*done)(struct scsi_cmnd *))\r\n{\r\nif (in_command) {\r\npanic( "scsi: <fdomain> fdomain_16x0_queue() NOT REENTRANT!\n" );\r\n}\r\n#if EVERY_ACCESS\r\nprintk( "queue: target = %d cmnd = 0x%02x pieces = %d size = %u\n",\r\nSCpnt->target,\r\n*(unsigned char *)SCpnt->cmnd,\r\nscsi_sg_count(SCpnt),\r\nscsi_bufflen(SCpnt));\r\n#endif\r\nfdomain_make_bus_idle();\r\ncurrent_SC = SCpnt;\r\ncurrent_SC->scsi_done = done;\r\nif (scsi_sg_count(current_SC)) {\r\ncurrent_SC->SCp.buffer = scsi_sglist(current_SC);\r\ncurrent_SC->SCp.ptr = sg_virt(current_SC->SCp.buffer);\r\ncurrent_SC->SCp.this_residual = current_SC->SCp.buffer->length;\r\ncurrent_SC->SCp.buffers_residual = scsi_sg_count(current_SC) - 1;\r\n} else {\r\ncurrent_SC->SCp.ptr = NULL;\r\ncurrent_SC->SCp.this_residual = 0;\r\ncurrent_SC->SCp.buffer = NULL;\r\ncurrent_SC->SCp.buffers_residual = 0;\r\n}\r\ncurrent_SC->SCp.Status = 0;\r\ncurrent_SC->SCp.Message = 0;\r\ncurrent_SC->SCp.have_data_in = 0;\r\ncurrent_SC->SCp.sent_command = 0;\r\ncurrent_SC->SCp.phase = in_arbitration;\r\noutb(0x00, port_base + Interrupt_Cntl);\r\noutb(0x00, port_base + SCSI_Cntl);\r\noutb(adapter_mask, port_base + SCSI_Data_NoACK);\r\n++in_command;\r\noutb(0x20, port_base + Interrupt_Cntl);\r\noutb(0x14 | PARITY_MASK, port_base + TMC_Cntl);\r\nreturn 0;\r\n}\r\nint fdomain_16x0_abort(struct scsi_cmnd *SCpnt)\r\n{\r\n#if EVERY_ACCESS || ERRORS_ONLY || DEBUG_ABORT\r\nprintk( "scsi: <fdomain> abort " );\r\n#endif\r\nif (!in_command) {\r\n#if EVERY_ACCESS || ERRORS_ONLY\r\nprintk( " (not in command)\n" );\r\n#endif\r\nreturn FAILED;\r\n} else printk( "\n" );\r\n#if DEBUG_ABORT\r\nprint_info( SCpnt );\r\n#endif\r\nfdomain_make_bus_idle();\r\ncurrent_SC->SCp.phase |= aborted;\r\ncurrent_SC->result = DID_ABORT << 16;\r\nmy_done(DID_ABORT << 16);\r\nreturn SUCCESS;\r\n}\r\nint fdomain_16x0_bus_reset(struct scsi_cmnd *SCpnt)\r\n{\r\nunsigned long flags;\r\nlocal_irq_save(flags);\r\noutb(1, port_base + SCSI_Cntl);\r\ndo_pause( 2 );\r\noutb(0, port_base + SCSI_Cntl);\r\ndo_pause( 115 );\r\noutb(0, port_base + SCSI_Mode_Cntl);\r\noutb(PARITY_MASK, port_base + TMC_Cntl);\r\nlocal_irq_restore(flags);\r\nreturn SUCCESS;\r\n}\r\nstatic int fdomain_16x0_biosparam(struct scsi_device *sdev,\r\nstruct block_device *bdev,\r\nsector_t capacity, int *info_array)\r\n{\r\nint drive;\r\nint size = capacity;\r\nunsigned long offset;\r\nstruct drive_info {\r\nunsigned short cylinders;\r\nunsigned char heads;\r\nunsigned char sectors;\r\n} i;\r\nif (MAJOR(bdev->bd_dev) != SCSI_DISK0_MAJOR) {\r\nprintk("scsi: <fdomain> fdomain_16x0_biosparam: too many disks");\r\nreturn 0;\r\n}\r\ndrive = MINOR(bdev->bd_dev) >> 4;\r\nif (bios_major == 2) {\r\nswitch (Quantum) {\r\ncase 2:\r\noffset = 0x1f33 + drive * 25;\r\nbreak;\r\ncase 3:\r\noffset = 0x1f36 + drive * 15;\r\nbreak;\r\ncase 4:\r\noffset = 0x1f34 + drive * 15;\r\nbreak;\r\ndefault:\r\noffset = 0x1f31 + drive * 25;\r\nbreak;\r\n}\r\nmemcpy_fromio( &i, bios_mem + offset, sizeof( struct drive_info ) );\r\ninfo_array[0] = i.heads;\r\ninfo_array[1] = i.sectors;\r\ninfo_array[2] = i.cylinders;\r\n} else if (bios_major == 3\r\n&& bios_minor >= 0\r\n&& bios_minor < 4) {\r\nmemcpy_fromio( &i, bios_mem + 0x1f71 + drive * 10,\r\nsizeof( struct drive_info ) );\r\ninfo_array[0] = i.heads + 1;\r\ninfo_array[1] = i.sectors;\r\ninfo_array[2] = i.cylinders;\r\n} else {\r\nunsigned char *p = scsi_bios_ptable(bdev);\r\nif (p && p[65] == 0xaa && p[64] == 0x55\r\n&& p[4]) {\r\ninfo_array[0] = p[5] + 1;\r\ninfo_array[1] = p[6] & 0x3f;\r\n} else {\r\nif ((unsigned int)size >= 0x7e0000U) {\r\ninfo_array[0] = 0xff;\r\ninfo_array[1] = 0x3f;\r\n} else if ((unsigned int)size >= 0x200000U) {\r\ninfo_array[0] = 0x80;\r\ninfo_array[1] = 0x3f;\r\n} else {\r\ninfo_array[0] = 0x40;\r\ninfo_array[1] = 0x20;\r\n}\r\n}\r\ninfo_array[2] = (unsigned int)size / (info_array[0] * info_array[1] );\r\nkfree(p);\r\n}\r\nreturn 0;\r\n}\r\nstatic int fdomain_16x0_release(struct Scsi_Host *shpnt)\r\n{\r\nif (shpnt->irq)\r\nfree_irq(shpnt->irq, shpnt);\r\nif (shpnt->io_port && shpnt->n_io_port)\r\nrelease_region(shpnt->io_port, shpnt->n_io_port);\r\nif (PCI_bus)\r\npci_dev_put(PCI_dev);\r\nreturn 0;\r\n}
