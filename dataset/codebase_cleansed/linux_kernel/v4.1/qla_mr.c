static int\r\nqlafx00_mailbox_command(scsi_qla_host_t *vha, struct mbx_cmd_32 *mcp)\r\n{\r\nint rval;\r\nunsigned long flags = 0;\r\ndevice_reg_t *reg;\r\nuint8_t abort_active;\r\nuint8_t io_lock_on;\r\nuint16_t command = 0;\r\nuint32_t *iptr;\r\nuint32_t __iomem *optr;\r\nuint32_t cnt;\r\nuint32_t mboxes;\r\nunsigned long wait_time;\r\nstruct qla_hw_data *ha = vha->hw;\r\nscsi_qla_host_t *base_vha = pci_get_drvdata(ha->pdev);\r\nif (ha->pdev->error_state > pci_channel_io_frozen) {\r\nql_log(ql_log_warn, vha, 0x115c,\r\n"error_state is greater than pci_channel_io_frozen, "\r\n"exiting.\n");\r\nreturn QLA_FUNCTION_TIMEOUT;\r\n}\r\nif (vha->device_flags & DFLG_DEV_FAILED) {\r\nql_log(ql_log_warn, vha, 0x115f,\r\n"Device in failed state, exiting.\n");\r\nreturn QLA_FUNCTION_TIMEOUT;\r\n}\r\nreg = ha->iobase;\r\nio_lock_on = base_vha->flags.init_done;\r\nrval = QLA_SUCCESS;\r\nabort_active = test_bit(ABORT_ISP_ACTIVE, &base_vha->dpc_flags);\r\nif (ha->flags.pci_channel_io_perm_failure) {\r\nql_log(ql_log_warn, vha, 0x1175,\r\n"Perm failure on EEH timeout MBX, exiting.\n");\r\nreturn QLA_FUNCTION_TIMEOUT;\r\n}\r\nif (ha->flags.isp82xx_fw_hung) {\r\nmcp->mb[0] = MBS_LINK_DOWN_ERROR;\r\nql_log(ql_log_warn, vha, 0x1176,\r\n"FW hung = %d.\n", ha->flags.isp82xx_fw_hung);\r\nrval = QLA_FUNCTION_FAILED;\r\ngoto premature_exit;\r\n}\r\nif (!wait_for_completion_timeout(&ha->mbx_cmd_comp, mcp->tov * HZ)) {\r\nql_log(ql_log_warn, vha, 0x1177,\r\n"Cmd access timeout, cmd=0x%x, Exiting.\n",\r\nmcp->mb[0]);\r\nreturn QLA_FUNCTION_TIMEOUT;\r\n}\r\nha->flags.mbox_busy = 1;\r\nha->mcp32 = mcp;\r\nql_dbg(ql_dbg_mbx, vha, 0x1178,\r\n"Prepare to issue mbox cmd=0x%x.\n", mcp->mb[0]);\r\nspin_lock_irqsave(&ha->hardware_lock, flags);\r\noptr = (uint32_t __iomem *)&reg->ispfx00.mailbox0;\r\niptr = mcp->mb;\r\ncommand = mcp->mb[0];\r\nmboxes = mcp->out_mb;\r\nfor (cnt = 0; cnt < ha->mbx_count; cnt++) {\r\nif (mboxes & BIT_0)\r\nWRT_REG_DWORD(optr, *iptr);\r\nmboxes >>= 1;\r\noptr++;\r\niptr++;\r\n}\r\nha->flags.mbox_int = 0;\r\nclear_bit(MBX_INTERRUPT, &ha->mbx_cmd_flags);\r\nql_dump_buffer(ql_dbg_mbx + ql_dbg_buffer, vha, 0x1172,\r\n(uint8_t *)mcp->mb, 16);\r\nql_dump_buffer(ql_dbg_mbx + ql_dbg_buffer, vha, 0x1173,\r\n((uint8_t *)mcp->mb + 0x10), 16);\r\nql_dump_buffer(ql_dbg_mbx + ql_dbg_buffer, vha, 0x1174,\r\n((uint8_t *)mcp->mb + 0x20), 8);\r\nql_dbg(ql_dbg_mbx, vha, 0x1179,\r\n"Going to unlock irq & waiting for interrupts. "\r\n"jiffies=%lx.\n", jiffies);\r\nif ((!abort_active && io_lock_on) || IS_NOPOLLING_TYPE(ha)) {\r\nset_bit(MBX_INTR_WAIT, &ha->mbx_cmd_flags);\r\nQLAFX00_SET_HST_INTR(ha, ha->mbx_intr_code);\r\nspin_unlock_irqrestore(&ha->hardware_lock, flags);\r\nwait_for_completion_timeout(&ha->mbx_intr_comp, mcp->tov * HZ);\r\n} else {\r\nql_dbg(ql_dbg_mbx, vha, 0x112c,\r\n"Cmd=%x Polling Mode.\n", command);\r\nQLAFX00_SET_HST_INTR(ha, ha->mbx_intr_code);\r\nspin_unlock_irqrestore(&ha->hardware_lock, flags);\r\nwait_time = jiffies + mcp->tov * HZ;\r\nwhile (!ha->flags.mbox_int) {\r\nif (time_after(jiffies, wait_time))\r\nbreak;\r\nqla2x00_poll(ha->rsp_q_map[0]);\r\nif (!ha->flags.mbox_int &&\r\n!(IS_QLA2200(ha) &&\r\ncommand == MBC_LOAD_RISC_RAM_EXTENDED))\r\nusleep_range(10000, 11000);\r\n}\r\nql_dbg(ql_dbg_mbx, vha, 0x112d,\r\n"Waited %d sec.\n",\r\n(uint)((jiffies - (wait_time - (mcp->tov * HZ)))/HZ));\r\n}\r\nif (ha->flags.mbox_int) {\r\nuint32_t *iptr2;\r\nql_dbg(ql_dbg_mbx, vha, 0x112e,\r\n"Cmd=%x completed.\n", command);\r\nha->flags.mbox_int = 0;\r\nclear_bit(MBX_INTERRUPT, &ha->mbx_cmd_flags);\r\nif (ha->mailbox_out32[0] != MBS_COMMAND_COMPLETE)\r\nrval = QLA_FUNCTION_FAILED;\r\niptr2 = mcp->mb;\r\niptr = (uint32_t *)&ha->mailbox_out32[0];\r\nmboxes = mcp->in_mb;\r\nfor (cnt = 0; cnt < ha->mbx_count; cnt++) {\r\nif (mboxes & BIT_0)\r\n*iptr2 = *iptr;\r\nmboxes >>= 1;\r\niptr2++;\r\niptr++;\r\n}\r\n} else {\r\nrval = QLA_FUNCTION_TIMEOUT;\r\n}\r\nha->flags.mbox_busy = 0;\r\nha->mcp32 = NULL;\r\nif ((abort_active || !io_lock_on) && !IS_NOPOLLING_TYPE(ha)) {\r\nql_dbg(ql_dbg_mbx, vha, 0x113a,\r\n"checking for additional resp interrupt.\n");\r\nqla2x00_poll(ha->rsp_q_map[0]);\r\n}\r\nif (rval == QLA_FUNCTION_TIMEOUT &&\r\nmcp->mb[0] != MBC_GEN_SYSTEM_ERROR) {\r\nif (!io_lock_on || (mcp->flags & IOCTL_CMD) ||\r\nha->flags.eeh_busy) {\r\nql_dbg(ql_dbg_mbx, vha, 0x115d,\r\n"Timeout, schedule isp_abort_needed.\n");\r\nif (!test_bit(ISP_ABORT_NEEDED, &vha->dpc_flags) &&\r\n!test_bit(ABORT_ISP_ACTIVE, &vha->dpc_flags) &&\r\n!test_bit(ISP_ABORT_RETRY, &vha->dpc_flags)) {\r\nql_log(ql_log_info, base_vha, 0x115e,\r\n"Mailbox cmd timeout occurred, cmd=0x%x, "\r\n"mb[0]=0x%x, eeh_busy=0x%x. Scheduling ISP "\r\n"abort.\n", command, mcp->mb[0],\r\nha->flags.eeh_busy);\r\nset_bit(ISP_ABORT_NEEDED, &vha->dpc_flags);\r\nqla2xxx_wake_dpc(vha);\r\n}\r\n} else if (!abort_active) {\r\nql_dbg(ql_dbg_mbx, vha, 0x1160,\r\n"Timeout, calling abort_isp.\n");\r\nif (!test_bit(ISP_ABORT_NEEDED, &vha->dpc_flags) &&\r\n!test_bit(ABORT_ISP_ACTIVE, &vha->dpc_flags) &&\r\n!test_bit(ISP_ABORT_RETRY, &vha->dpc_flags)) {\r\nql_log(ql_log_info, base_vha, 0x1161,\r\n"Mailbox cmd timeout occurred, cmd=0x%x, "\r\n"mb[0]=0x%x. Scheduling ISP abort ",\r\ncommand, mcp->mb[0]);\r\nset_bit(ABORT_ISP_ACTIVE, &vha->dpc_flags);\r\nclear_bit(ISP_ABORT_NEEDED, &vha->dpc_flags);\r\nif (ha->isp_ops->abort_isp(vha)) {\r\nset_bit(ISP_ABORT_NEEDED,\r\n&vha->dpc_flags);\r\n}\r\nclear_bit(ABORT_ISP_ACTIVE, &vha->dpc_flags);\r\nql_dbg(ql_dbg_mbx, vha, 0x1162,\r\n"Finished abort_isp.\n");\r\n}\r\n}\r\n}\r\npremature_exit:\r\ncomplete(&ha->mbx_cmd_comp);\r\nif (rval) {\r\nql_log(ql_log_warn, base_vha, 0x1163,\r\n"**** Failed mbx[0]=%x, mb[1]=%x, mb[2]=%x, "\r\n"mb[3]=%x, cmd=%x ****.\n",\r\nmcp->mb[0], mcp->mb[1], mcp->mb[2], mcp->mb[3], command);\r\n} else {\r\nql_dbg(ql_dbg_mbx, base_vha, 0x1164, "Done %s.\n", __func__);\r\n}\r\nreturn rval;\r\n}\r\nint\r\nqlafx00_driver_shutdown(scsi_qla_host_t *vha, int tmo)\r\n{\r\nint rval;\r\nstruct mbx_cmd_32 mc;\r\nstruct mbx_cmd_32 *mcp = &mc;\r\nql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x1166,\r\n"Entered %s.\n", __func__);\r\nmcp->mb[0] = MBC_MR_DRV_SHUTDOWN;\r\nmcp->out_mb = MBX_0;\r\nmcp->in_mb = MBX_0;\r\nif (tmo)\r\nmcp->tov = tmo;\r\nelse\r\nmcp->tov = MBX_TOV_SECONDS;\r\nmcp->flags = 0;\r\nrval = qlafx00_mailbox_command(vha, mcp);\r\nif (rval != QLA_SUCCESS) {\r\nql_dbg(ql_dbg_mbx, vha, 0x1167,\r\n"Failed=%x.\n", rval);\r\n} else {\r\nql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x1168,\r\n"Done %s.\n", __func__);\r\n}\r\nreturn rval;\r\n}\r\nstatic int\r\nqlafx00_get_firmware_state(scsi_qla_host_t *vha, uint32_t *states)\r\n{\r\nint rval;\r\nstruct mbx_cmd_32 mc;\r\nstruct mbx_cmd_32 *mcp = &mc;\r\nql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x1169,\r\n"Entered %s.\n", __func__);\r\nmcp->mb[0] = MBC_GET_FIRMWARE_STATE;\r\nmcp->out_mb = MBX_0;\r\nmcp->in_mb = MBX_1|MBX_0;\r\nmcp->tov = MBX_TOV_SECONDS;\r\nmcp->flags = 0;\r\nrval = qlafx00_mailbox_command(vha, mcp);\r\nstates[0] = mcp->mb[1];\r\nif (rval != QLA_SUCCESS) {\r\nql_dbg(ql_dbg_mbx, vha, 0x116a,\r\n"Failed=%x mb[0]=%x.\n", rval, mcp->mb[0]);\r\n} else {\r\nql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x116b,\r\n"Done %s.\n", __func__);\r\n}\r\nreturn rval;\r\n}\r\nint\r\nqlafx00_init_firmware(scsi_qla_host_t *vha, uint16_t size)\r\n{\r\nint rval;\r\nstruct mbx_cmd_32 mc;\r\nstruct mbx_cmd_32 *mcp = &mc;\r\nstruct qla_hw_data *ha = vha->hw;\r\nql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x116c,\r\n"Entered %s.\n", __func__);\r\nmcp->mb[0] = MBC_INITIALIZE_FIRMWARE;\r\nmcp->mb[1] = 0;\r\nmcp->mb[2] = MSD(ha->init_cb_dma);\r\nmcp->mb[3] = LSD(ha->init_cb_dma);\r\nmcp->out_mb = MBX_3|MBX_2|MBX_1|MBX_0;\r\nmcp->in_mb = MBX_0;\r\nmcp->buf_size = size;\r\nmcp->flags = MBX_DMA_OUT;\r\nmcp->tov = MBX_TOV_SECONDS;\r\nrval = qlafx00_mailbox_command(vha, mcp);\r\nif (rval != QLA_SUCCESS) {\r\nql_dbg(ql_dbg_mbx, vha, 0x116d,\r\n"Failed=%x mb[0]=%x.\n", rval, mcp->mb[0]);\r\n} else {\r\nql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x116e,\r\n"Done %s.\n", __func__);\r\n}\r\nreturn rval;\r\n}\r\nstatic int\r\nqlafx00_mbx_reg_test(scsi_qla_host_t *vha)\r\n{\r\nint rval;\r\nstruct mbx_cmd_32 mc;\r\nstruct mbx_cmd_32 *mcp = &mc;\r\nql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x116f,\r\n"Entered %s.\n", __func__);\r\nmcp->mb[0] = MBC_MAILBOX_REGISTER_TEST;\r\nmcp->mb[1] = 0xAAAA;\r\nmcp->mb[2] = 0x5555;\r\nmcp->mb[3] = 0xAA55;\r\nmcp->mb[4] = 0x55AA;\r\nmcp->mb[5] = 0xA5A5;\r\nmcp->mb[6] = 0x5A5A;\r\nmcp->mb[7] = 0x2525;\r\nmcp->mb[8] = 0xBBBB;\r\nmcp->mb[9] = 0x6666;\r\nmcp->mb[10] = 0xBB66;\r\nmcp->mb[11] = 0x66BB;\r\nmcp->mb[12] = 0xB6B6;\r\nmcp->mb[13] = 0x6B6B;\r\nmcp->mb[14] = 0x3636;\r\nmcp->mb[15] = 0xCCCC;\r\nmcp->out_mb = MBX_15|MBX_14|MBX_13|MBX_12|MBX_11|MBX_10|MBX_9|MBX_8|\r\nMBX_7|MBX_6|MBX_5|MBX_4|MBX_3|MBX_2|MBX_1|MBX_0;\r\nmcp->in_mb = MBX_15|MBX_14|MBX_13|MBX_12|MBX_11|MBX_10|MBX_9|MBX_8|\r\nMBX_7|MBX_6|MBX_5|MBX_4|MBX_3|MBX_2|MBX_1|MBX_0;\r\nmcp->buf_size = 0;\r\nmcp->flags = MBX_DMA_OUT;\r\nmcp->tov = MBX_TOV_SECONDS;\r\nrval = qlafx00_mailbox_command(vha, mcp);\r\nif (rval == QLA_SUCCESS) {\r\nif (mcp->mb[17] != 0xAAAA || mcp->mb[18] != 0x5555 ||\r\nmcp->mb[19] != 0xAA55 || mcp->mb[20] != 0x55AA)\r\nrval = QLA_FUNCTION_FAILED;\r\nif (mcp->mb[21] != 0xA5A5 || mcp->mb[22] != 0x5A5A ||\r\nmcp->mb[23] != 0x2525 || mcp->mb[24] != 0xBBBB)\r\nrval = QLA_FUNCTION_FAILED;\r\nif (mcp->mb[25] != 0x6666 || mcp->mb[26] != 0xBB66 ||\r\nmcp->mb[27] != 0x66BB || mcp->mb[28] != 0xB6B6)\r\nrval = QLA_FUNCTION_FAILED;\r\nif (mcp->mb[29] != 0x6B6B || mcp->mb[30] != 0x3636 ||\r\nmcp->mb[31] != 0xCCCC)\r\nrval = QLA_FUNCTION_FAILED;\r\n}\r\nif (rval != QLA_SUCCESS) {\r\nql_dbg(ql_dbg_mbx, vha, 0x1170,\r\n"Failed=%x mb[0]=%x.\n", rval, mcp->mb[0]);\r\n} else {\r\nql_dbg(ql_dbg_mbx + ql_dbg_verbose, vha, 0x1171,\r\n"Done %s.\n", __func__);\r\n}\r\nreturn rval;\r\n}\r\nint\r\nqlafx00_pci_config(scsi_qla_host_t *vha)\r\n{\r\nuint16_t w;\r\nstruct qla_hw_data *ha = vha->hw;\r\npci_set_master(ha->pdev);\r\npci_try_set_mwi(ha->pdev);\r\npci_read_config_word(ha->pdev, PCI_COMMAND, &w);\r\nw |= (PCI_COMMAND_PARITY | PCI_COMMAND_SERR);\r\nw &= ~PCI_COMMAND_INTX_DISABLE;\r\npci_write_config_word(ha->pdev, PCI_COMMAND, w);\r\nif (pci_is_pcie(ha->pdev))\r\npcie_set_readrq(ha->pdev, 2048);\r\nha->chip_revision = ha->pdev->revision;\r\nreturn QLA_SUCCESS;\r\n}\r\nstatic inline void\r\nqlafx00_soc_cpu_reset(scsi_qla_host_t *vha)\r\n{\r\nunsigned long flags = 0;\r\nstruct qla_hw_data *ha = vha->hw;\r\nint i, core;\r\nuint32_t cnt;\r\nuint32_t reg_val;\r\nspin_lock_irqsave(&ha->hardware_lock, flags);\r\nQLAFX00_SET_HBA_SOC_REG(ha, 0x80004, 0);\r\nQLAFX00_SET_HBA_SOC_REG(ha, 0x82004, 0);\r\nQLAFX00_SET_HBA_SOC_REG(ha, 0x60920, 0x02);\r\nQLAFX00_SET_HBA_SOC_REG(ha, 0x60924, 0x02);\r\nQLAFX00_SET_HBA_SOC_REG(ha, 0xf0920, 0x02);\r\nQLAFX00_SET_HBA_SOC_REG(ha, 0xf0924, 0x02);\r\nreg_val = QLAFX00_GET_HBA_SOC_REG(ha, 0x60840);\r\nreg_val &= ~(1<<12);\r\nQLAFX00_SET_HBA_SOC_REG(ha, 0x60840, reg_val);\r\nreg_val = QLAFX00_GET_HBA_SOC_REG(ha, 0x60844);\r\nreg_val &= ~(1<<12);\r\nQLAFX00_SET_HBA_SOC_REG(ha, 0x60844, reg_val);\r\nreg_val = QLAFX00_GET_HBA_SOC_REG(ha, 0x60848);\r\nreg_val &= ~(1<<12);\r\nQLAFX00_SET_HBA_SOC_REG(ha, 0x60848, reg_val);\r\nreg_val = QLAFX00_GET_HBA_SOC_REG(ha, 0x6084C);\r\nreg_val &= ~(1<<12);\r\nQLAFX00_SET_HBA_SOC_REG(ha, 0x6084C, reg_val);\r\nfor (i = 0; i < 100000; i++) {\r\nif ((QLAFX00_GET_HBA_SOC_REG(ha, 0xd0000) & 0x10000000) == 0 &&\r\n(QLAFX00_GET_HBA_SOC_REG(ha, 0x10600) & 0x1) == 0)\r\nbreak;\r\nudelay(100);\r\n}\r\nfor (i = 0; i < 4; i++) {\r\nQLAFX00_SET_HBA_SOC_REG(ha,\r\n(SOC_SW_RST_CONTROL_REG_CORE0 + 8*i), (0xF01));\r\nQLAFX00_SET_HBA_SOC_REG(ha,\r\n(SOC_SW_RST_CONTROL_REG_CORE0 + 4 + 8*i), (0x01010101));\r\n}\r\nQLAFX00_SET_HBA_SOC_REG(ha, SOC_FABRIC_RST_CONTROL_REG, (0x011f0101));\r\nQLAFX00_SET_HBA_SOC_REG(ha, 0x10610, 1);\r\nQLAFX00_SET_HBA_SOC_REG(ha, 0x10600, 0);\r\nfor (i = 0; i < 5; i++) {\r\nQLAFX00_SET_HBA_SOC_REG(ha,\r\n(SOC_PWR_MANAGEMENT_PWR_DOWN_REG + 4*i), (0x0));\r\n}\r\nfor (i = 0; i < 115; i++) {\r\nQLAFX00_SET_HBA_SOC_REG(ha,\r\n(SOC_INTERRUPT_SOURCE_I_CONTROL_REG + 4*i), (0x0));\r\n}\r\nfor (core = 0; core < 4; core++)\r\nfor (i = 0; i < 8; i++)\r\nQLAFX00_SET_HBA_SOC_REG(ha,\r\n(SOC_CORE_TIMER_REG + 0x100*core + 4*i), (0x0));\r\nfor (core = 0; core < 4; core++)\r\nQLAFX00_SET_HBA_SOC_REG(ha,\r\n(SOC_IRQ_ACK_REG + 0x100*core), (0x3FF));\r\nQLAFX00_SET_HBA_SOC_REG(ha, SOC_FABRIC_CONTROL_REG, (0x2));\r\nQLAFX00_SET_HBA_SOC_REG(ha, SOC_FABRIC_CONFIG_REG, (0x3));\r\nQLAFX00_SET_HBA_SOC_REG(ha, SOC_FABRIC_RST_CONTROL_REG, (0x0));\r\nQLAFX00_SET_HBA_SOC_REG(ha, SOC_SW_RST_CONTROL_REG_CORE0, (0xF00));\r\nspin_unlock_irqrestore(&ha->hardware_lock, flags);\r\nfor (cnt = 10; cnt; cnt--) {\r\nmsleep(1000);\r\nbarrier();\r\n}\r\n}\r\nvoid\r\nqlafx00_soft_reset(scsi_qla_host_t *vha)\r\n{\r\nstruct qla_hw_data *ha = vha->hw;\r\nif (unlikely(pci_channel_offline(ha->pdev) &&\r\nha->flags.pci_channel_io_perm_failure))\r\nreturn;\r\nha->isp_ops->disable_intrs(ha);\r\nqlafx00_soc_cpu_reset(vha);\r\n}\r\nint\r\nqlafx00_chip_diag(scsi_qla_host_t *vha)\r\n{\r\nint rval = 0;\r\nstruct qla_hw_data *ha = vha->hw;\r\nstruct req_que *req = ha->req_q_map[0];\r\nha->fw_transfer_size = REQUEST_ENTRY_SIZE * req->length;\r\nrval = qlafx00_mbx_reg_test(vha);\r\nif (rval) {\r\nql_log(ql_log_warn, vha, 0x1165,\r\n"Failed mailbox send register test\n");\r\n} else {\r\nrval = QLA_SUCCESS;\r\n}\r\nreturn rval;\r\n}\r\nvoid\r\nqlafx00_config_rings(struct scsi_qla_host *vha)\r\n{\r\nstruct qla_hw_data *ha = vha->hw;\r\nstruct device_reg_fx00 __iomem *reg = &ha->iobase->ispfx00;\r\nWRT_REG_DWORD(&reg->req_q_in, 0);\r\nWRT_REG_DWORD(&reg->req_q_out, 0);\r\nWRT_REG_DWORD(&reg->rsp_q_in, 0);\r\nWRT_REG_DWORD(&reg->rsp_q_out, 0);\r\nRD_REG_DWORD(&reg->rsp_q_out);\r\n}\r\nchar *\r\nqlafx00_pci_info_str(struct scsi_qla_host *vha, char *str)\r\n{\r\nstruct qla_hw_data *ha = vha->hw;\r\nif (pci_is_pcie(ha->pdev)) {\r\nstrcpy(str, "PCIe iSA");\r\nreturn str;\r\n}\r\nreturn str;\r\n}\r\nchar *\r\nqlafx00_fw_version_str(struct scsi_qla_host *vha, char *str, size_t size)\r\n{\r\nstruct qla_hw_data *ha = vha->hw;\r\nsnprintf(str, size, "%s", ha->mr.fw_version);\r\nreturn str;\r\n}\r\nvoid\r\nqlafx00_enable_intrs(struct qla_hw_data *ha)\r\n{\r\nunsigned long flags = 0;\r\nspin_lock_irqsave(&ha->hardware_lock, flags);\r\nha->interrupts_on = 1;\r\nQLAFX00_ENABLE_ICNTRL_REG(ha);\r\nspin_unlock_irqrestore(&ha->hardware_lock, flags);\r\n}\r\nvoid\r\nqlafx00_disable_intrs(struct qla_hw_data *ha)\r\n{\r\nunsigned long flags = 0;\r\nspin_lock_irqsave(&ha->hardware_lock, flags);\r\nha->interrupts_on = 0;\r\nQLAFX00_DISABLE_ICNTRL_REG(ha);\r\nspin_unlock_irqrestore(&ha->hardware_lock, flags);\r\n}\r\nint\r\nqlafx00_abort_target(fc_port_t *fcport, uint64_t l, int tag)\r\n{\r\nreturn qla2x00_async_tm_cmd(fcport, TCF_TARGET_RESET, l, tag);\r\n}\r\nint\r\nqlafx00_lun_reset(fc_port_t *fcport, uint64_t l, int tag)\r\n{\r\nreturn qla2x00_async_tm_cmd(fcport, TCF_LUN_RESET, l, tag);\r\n}\r\nint\r\nqlafx00_loop_reset(scsi_qla_host_t *vha)\r\n{\r\nint ret;\r\nstruct fc_port *fcport;\r\nstruct qla_hw_data *ha = vha->hw;\r\nif (ql2xtargetreset) {\r\nlist_for_each_entry(fcport, &vha->vp_fcports, list) {\r\nif (fcport->port_type != FCT_TARGET)\r\ncontinue;\r\nret = ha->isp_ops->target_reset(fcport, 0, 0);\r\nif (ret != QLA_SUCCESS) {\r\nql_dbg(ql_dbg_taskm, vha, 0x803d,\r\n"Bus Reset failed: Reset=%d "\r\n"d_id=%x.\n", ret, fcport->d_id.b24);\r\n}\r\n}\r\n}\r\nreturn QLA_SUCCESS;\r\n}\r\nint\r\nqlafx00_iospace_config(struct qla_hw_data *ha)\r\n{\r\nif (pci_request_selected_regions(ha->pdev, ha->bars,\r\nQLA2XXX_DRIVER_NAME)) {\r\nql_log_pci(ql_log_fatal, ha->pdev, 0x014e,\r\n"Failed to reserve PIO/MMIO regions (%s), aborting.\n",\r\npci_name(ha->pdev));\r\ngoto iospace_error_exit;\r\n}\r\nif (!(pci_resource_flags(ha->pdev, 0) & IORESOURCE_MEM)) {\r\nql_log_pci(ql_log_warn, ha->pdev, 0x014f,\r\n"Invalid pci I/O region size (%s).\n",\r\npci_name(ha->pdev));\r\ngoto iospace_error_exit;\r\n}\r\nif (pci_resource_len(ha->pdev, 0) < BAR0_LEN_FX00) {\r\nql_log_pci(ql_log_warn, ha->pdev, 0x0127,\r\n"Invalid PCI mem BAR0 region size (%s), aborting\n",\r\npci_name(ha->pdev));\r\ngoto iospace_error_exit;\r\n}\r\nha->cregbase =\r\nioremap_nocache(pci_resource_start(ha->pdev, 0), BAR0_LEN_FX00);\r\nif (!ha->cregbase) {\r\nql_log_pci(ql_log_fatal, ha->pdev, 0x0128,\r\n"cannot remap MMIO (%s), aborting\n", pci_name(ha->pdev));\r\ngoto iospace_error_exit;\r\n}\r\nif (!(pci_resource_flags(ha->pdev, 2) & IORESOURCE_MEM)) {\r\nql_log_pci(ql_log_warn, ha->pdev, 0x0129,\r\n"region #2 not an MMIO resource (%s), aborting\n",\r\npci_name(ha->pdev));\r\ngoto iospace_error_exit;\r\n}\r\nif (pci_resource_len(ha->pdev, 2) < BAR2_LEN_FX00) {\r\nql_log_pci(ql_log_warn, ha->pdev, 0x012a,\r\n"Invalid PCI mem BAR2 region size (%s), aborting\n",\r\npci_name(ha->pdev));\r\ngoto iospace_error_exit;\r\n}\r\nha->iobase =\r\nioremap_nocache(pci_resource_start(ha->pdev, 2), BAR2_LEN_FX00);\r\nif (!ha->iobase) {\r\nql_log_pci(ql_log_fatal, ha->pdev, 0x012b,\r\n"cannot remap MMIO (%s), aborting\n", pci_name(ha->pdev));\r\ngoto iospace_error_exit;\r\n}\r\nha->max_req_queues = ha->max_rsp_queues = 1;\r\nql_log_pci(ql_log_info, ha->pdev, 0x012c,\r\n"Bars 0x%x, iobase0 0x%p, iobase2 0x%p\n",\r\nha->bars, ha->cregbase, ha->iobase);\r\nreturn 0;\r\niospace_error_exit:\r\nreturn -ENOMEM;\r\n}\r\nstatic void\r\nqlafx00_save_queue_ptrs(struct scsi_qla_host *vha)\r\n{\r\nstruct qla_hw_data *ha = vha->hw;\r\nstruct req_que *req = ha->req_q_map[0];\r\nstruct rsp_que *rsp = ha->rsp_q_map[0];\r\nreq->length_fx00 = req->length;\r\nreq->ring_fx00 = req->ring;\r\nreq->dma_fx00 = req->dma;\r\nrsp->length_fx00 = rsp->length;\r\nrsp->ring_fx00 = rsp->ring;\r\nrsp->dma_fx00 = rsp->dma;\r\nql_dbg(ql_dbg_init, vha, 0x012d,\r\n"req: %p, ring_fx00: %p, length_fx00: 0x%x,"\r\n"req->dma_fx00: 0x%llx\n", req, req->ring_fx00,\r\nreq->length_fx00, (u64)req->dma_fx00);\r\nql_dbg(ql_dbg_init, vha, 0x012e,\r\n"rsp: %p, ring_fx00: %p, length_fx00: 0x%x,"\r\n"rsp->dma_fx00: 0x%llx\n", rsp, rsp->ring_fx00,\r\nrsp->length_fx00, (u64)rsp->dma_fx00);\r\n}\r\nstatic int\r\nqlafx00_config_queues(struct scsi_qla_host *vha)\r\n{\r\nstruct qla_hw_data *ha = vha->hw;\r\nstruct req_que *req = ha->req_q_map[0];\r\nstruct rsp_que *rsp = ha->rsp_q_map[0];\r\ndma_addr_t bar2_hdl = pci_resource_start(ha->pdev, 2);\r\nreq->length = ha->req_que_len;\r\nreq->ring = (void *)ha->iobase + ha->req_que_off;\r\nreq->dma = bar2_hdl + ha->req_que_off;\r\nif ((!req->ring) || (req->length == 0)) {\r\nql_log_pci(ql_log_info, ha->pdev, 0x012f,\r\n"Unable to allocate memory for req_ring\n");\r\nreturn QLA_FUNCTION_FAILED;\r\n}\r\nql_dbg(ql_dbg_init, vha, 0x0130,\r\n"req: %p req_ring pointer %p req len 0x%x "\r\n"req off 0x%x\n, req->dma: 0x%llx",\r\nreq, req->ring, req->length,\r\nha->req_que_off, (u64)req->dma);\r\nrsp->length = ha->rsp_que_len;\r\nrsp->ring = (void *)ha->iobase + ha->rsp_que_off;\r\nrsp->dma = bar2_hdl + ha->rsp_que_off;\r\nif ((!rsp->ring) || (rsp->length == 0)) {\r\nql_log_pci(ql_log_info, ha->pdev, 0x0131,\r\n"Unable to allocate memory for rsp_ring\n");\r\nreturn QLA_FUNCTION_FAILED;\r\n}\r\nql_dbg(ql_dbg_init, vha, 0x0132,\r\n"rsp: %p rsp_ring pointer %p rsp len 0x%x "\r\n"rsp off 0x%x, rsp->dma: 0x%llx\n",\r\nrsp, rsp->ring, rsp->length,\r\nha->rsp_que_off, (u64)rsp->dma);\r\nreturn QLA_SUCCESS;\r\n}\r\nstatic int\r\nqlafx00_init_fw_ready(scsi_qla_host_t *vha)\r\n{\r\nint rval = 0;\r\nunsigned long wtime;\r\nuint16_t wait_time;\r\nstruct qla_hw_data *ha = vha->hw;\r\nstruct device_reg_fx00 __iomem *reg = &ha->iobase->ispfx00;\r\nuint32_t aenmbx, aenmbx7 = 0;\r\nuint32_t pseudo_aen;\r\nuint32_t state[5];\r\nbool done = false;\r\nwait_time = 30;\r\npseudo_aen = RD_REG_DWORD(&reg->pseudoaen);\r\nif (pseudo_aen == 1) {\r\naenmbx7 = RD_REG_DWORD(&reg->initval7);\r\nha->mbx_intr_code = MSW(aenmbx7);\r\nha->rqstq_intr_code = LSW(aenmbx7);\r\nrval = qlafx00_driver_shutdown(vha, 10);\r\nif (rval != QLA_SUCCESS)\r\nqlafx00_soft_reset(vha);\r\n}\r\nwtime = jiffies + (wait_time * HZ);\r\ndo {\r\naenmbx = RD_REG_DWORD(&reg->aenmailbox0);\r\nbarrier();\r\nql_dbg(ql_dbg_mbx, vha, 0x0133,\r\n"aenmbx: 0x%x\n", aenmbx);\r\nswitch (aenmbx) {\r\ncase MBA_FW_NOT_STARTED:\r\ncase MBA_FW_STARTING:\r\nbreak;\r\ncase MBA_SYSTEM_ERR:\r\ncase MBA_REQ_TRANSFER_ERR:\r\ncase MBA_RSP_TRANSFER_ERR:\r\ncase MBA_FW_INIT_FAILURE:\r\nqlafx00_soft_reset(vha);\r\nbreak;\r\ncase MBA_FW_RESTART_CMPLT:\r\naenmbx7 = RD_REG_DWORD(&reg->aenmailbox7);\r\nha->mbx_intr_code = MSW(aenmbx7);\r\nha->rqstq_intr_code = LSW(aenmbx7);\r\nha->req_que_off = RD_REG_DWORD(&reg->aenmailbox1);\r\nha->rsp_que_off = RD_REG_DWORD(&reg->aenmailbox3);\r\nha->req_que_len = RD_REG_DWORD(&reg->aenmailbox5);\r\nha->rsp_que_len = RD_REG_DWORD(&reg->aenmailbox6);\r\nWRT_REG_DWORD(&reg->aenmailbox0, 0);\r\nRD_REG_DWORD_RELAXED(&reg->aenmailbox0);\r\nql_dbg(ql_dbg_init, vha, 0x0134,\r\n"f/w returned mbx_intr_code: 0x%x, "\r\n"rqstq_intr_code: 0x%x\n",\r\nha->mbx_intr_code, ha->rqstq_intr_code);\r\nQLAFX00_CLR_INTR_REG(ha, QLAFX00_HST_INT_STS_BITS);\r\nrval = QLA_SUCCESS;\r\ndone = true;\r\nbreak;\r\ndefault:\r\nif ((aenmbx & 0xFF00) == MBA_FW_INIT_INPROGRESS)\r\nbreak;\r\naenmbx7 = RD_REG_DWORD(&reg->initval7);\r\nha->mbx_intr_code = MSW(aenmbx7);\r\nha->rqstq_intr_code = LSW(aenmbx7);\r\nha->req_que_off = RD_REG_DWORD(&reg->initval1);\r\nha->rsp_que_off = RD_REG_DWORD(&reg->initval3);\r\nha->req_que_len = RD_REG_DWORD(&reg->initval5);\r\nha->rsp_que_len = RD_REG_DWORD(&reg->initval6);\r\nql_dbg(ql_dbg_init, vha, 0x0135,\r\n"f/w returned mbx_intr_code: 0x%x, "\r\n"rqstq_intr_code: 0x%x\n",\r\nha->mbx_intr_code, ha->rqstq_intr_code);\r\nQLAFX00_CLR_INTR_REG(ha, QLAFX00_HST_INT_STS_BITS);\r\nrval = qlafx00_get_firmware_state(vha, state);\r\nif (rval != QLA_SUCCESS) {\r\nbreak;\r\n}\r\nif (state[0] == FSTATE_FX00_CONFIG_WAIT) {\r\nrval = QLA_SUCCESS;\r\ndone = true;\r\nbreak;\r\n}\r\nql_dbg(ql_dbg_init, vha, 0x0136,\r\n"Sending Driver shutdown fw_state 0x%x\n",\r\nstate[0]);\r\nrval = qlafx00_driver_shutdown(vha, 10);\r\nif (rval != QLA_SUCCESS) {\r\nrval = QLA_FUNCTION_FAILED;\r\nbreak;\r\n}\r\nmsleep(500);\r\nwtime = jiffies + (wait_time * HZ);\r\nbreak;\r\n}\r\nif (!done) {\r\nif (time_after_eq(jiffies, wtime)) {\r\nql_dbg(ql_dbg_init, vha, 0x0137,\r\n"Init f/w failed: aen[7]: 0x%x\n",\r\nRD_REG_DWORD(&reg->aenmailbox7));\r\nrval = QLA_FUNCTION_FAILED;\r\ndone = true;\r\nbreak;\r\n}\r\nmsleep(500);\r\n}\r\n} while (!done);\r\nif (rval)\r\nql_dbg(ql_dbg_init, vha, 0x0138,\r\n"%s **** FAILED ****.\n", __func__);\r\nelse\r\nql_dbg(ql_dbg_init, vha, 0x0139,\r\n"%s **** SUCCESS ****.\n", __func__);\r\nreturn rval;\r\n}\r\nint\r\nqlafx00_fw_ready(scsi_qla_host_t *vha)\r\n{\r\nint rval;\r\nunsigned long wtime;\r\nuint16_t wait_time;\r\nuint32_t state[5];\r\nrval = QLA_SUCCESS;\r\nwait_time = 10;\r\nwtime = jiffies + (wait_time * HZ);\r\nif (!vha->flags.init_done)\r\nql_dbg(ql_dbg_init, vha, 0x013a,\r\n"Waiting for init to complete...\n");\r\ndo {\r\nrval = qlafx00_get_firmware_state(vha, state);\r\nif (rval == QLA_SUCCESS) {\r\nif (state[0] == FSTATE_FX00_INITIALIZED) {\r\nql_dbg(ql_dbg_init, vha, 0x013b,\r\n"fw_state=%x\n", state[0]);\r\nrval = QLA_SUCCESS;\r\nbreak;\r\n}\r\n}\r\nrval = QLA_FUNCTION_FAILED;\r\nif (time_after_eq(jiffies, wtime))\r\nbreak;\r\nmsleep(500);\r\nql_dbg(ql_dbg_init, vha, 0x013c,\r\n"fw_state=%x curr time=%lx.\n", state[0], jiffies);\r\n} while (1);\r\nif (rval)\r\nql_dbg(ql_dbg_init, vha, 0x013d,\r\n"Firmware ready **** FAILED ****.\n");\r\nelse\r\nql_dbg(ql_dbg_init, vha, 0x013e,\r\n"Firmware ready **** SUCCESS ****.\n");\r\nreturn rval;\r\n}\r\nstatic int\r\nqlafx00_find_all_targets(scsi_qla_host_t *vha,\r\nstruct list_head *new_fcports)\r\n{\r\nint rval;\r\nuint16_t tgt_id;\r\nfc_port_t *fcport, *new_fcport;\r\nint found;\r\nstruct qla_hw_data *ha = vha->hw;\r\nrval = QLA_SUCCESS;\r\nif (!test_bit(LOOP_RESYNC_ACTIVE, &vha->dpc_flags))\r\nreturn QLA_FUNCTION_FAILED;\r\nif ((atomic_read(&vha->loop_down_timer) ||\r\nSTATE_TRANSITION(vha))) {\r\natomic_set(&vha->loop_down_timer, 0);\r\nset_bit(LOOP_RESYNC_NEEDED, &vha->dpc_flags);\r\nreturn QLA_FUNCTION_FAILED;\r\n}\r\nql_dbg(ql_dbg_disc + ql_dbg_init, vha, 0x2088,\r\n"Listing Target bit map...\n");\r\nql_dump_buffer(ql_dbg_disc + ql_dbg_init, vha,\r\n0x2089, (uint8_t *)ha->gid_list, 32);\r\nnew_fcport = qla2x00_alloc_fcport(vha, GFP_KERNEL);\r\nif (new_fcport == NULL)\r\nreturn QLA_MEMORY_ALLOC_FAILED;\r\nfor_each_set_bit(tgt_id, (void *)ha->gid_list,\r\nQLAFX00_TGT_NODE_LIST_SIZE) {\r\nnew_fcport->tgt_id = tgt_id;\r\nrval = qlafx00_fx_disc(vha, new_fcport,\r\nFXDISC_GET_TGT_NODE_INFO);\r\nif (rval != QLA_SUCCESS) {\r\nql_log(ql_log_warn, vha, 0x208a,\r\n"Target info scan failed -- assuming zero-entry "\r\n"result...\n");\r\ncontinue;\r\n}\r\nfound = 0;\r\nlist_for_each_entry(fcport, &vha->vp_fcports, list) {\r\nif (memcmp(new_fcport->port_name,\r\nfcport->port_name, WWN_SIZE))\r\ncontinue;\r\nfound++;\r\nif (fcport->tgt_id == new_fcport->tgt_id &&\r\natomic_read(&fcport->state) == FCS_ONLINE)\r\nbreak;\r\nql_dbg(ql_dbg_disc + ql_dbg_init, vha, 0x208b,\r\n"TGT-ID Change(%s): Present tgt id: "\r\n"0x%x state: 0x%x "\r\n"wwnn = %llx wwpn = %llx.\n",\r\n__func__, fcport->tgt_id,\r\natomic_read(&fcport->state),\r\n(unsigned long long)wwn_to_u64(fcport->node_name),\r\n(unsigned long long)wwn_to_u64(fcport->port_name));\r\nql_log(ql_log_info, vha, 0x208c,\r\n"TGT-ID Announce(%s): Discovered tgt "\r\n"id 0x%x wwnn = %llx "\r\n"wwpn = %llx.\n", __func__, new_fcport->tgt_id,\r\n(unsigned long long)\r\nwwn_to_u64(new_fcport->node_name),\r\n(unsigned long long)\r\nwwn_to_u64(new_fcport->port_name));\r\nif (atomic_read(&fcport->state) != FCS_ONLINE) {\r\nfcport->old_tgt_id = fcport->tgt_id;\r\nfcport->tgt_id = new_fcport->tgt_id;\r\nql_log(ql_log_info, vha, 0x208d,\r\n"TGT-ID: New fcport Added: %p\n", fcport);\r\nqla2x00_update_fcport(vha, fcport);\r\n} else {\r\nql_log(ql_log_info, vha, 0x208e,\r\n" Existing TGT-ID %x did not get "\r\n" offline event from firmware.\n",\r\nfcport->old_tgt_id);\r\nqla2x00_mark_device_lost(vha, fcport, 0, 0);\r\nset_bit(LOOP_RESYNC_NEEDED, &vha->dpc_flags);\r\nkfree(new_fcport);\r\nreturn rval;\r\n}\r\nbreak;\r\n}\r\nif (found)\r\ncontinue;\r\nlist_add_tail(&new_fcport->list, new_fcports);\r\nnew_fcport = qla2x00_alloc_fcport(vha, GFP_KERNEL);\r\nif (new_fcport == NULL)\r\nreturn QLA_MEMORY_ALLOC_FAILED;\r\n}\r\nkfree(new_fcport);\r\nreturn rval;\r\n}\r\nstatic int\r\nqlafx00_configure_all_targets(scsi_qla_host_t *vha)\r\n{\r\nint rval;\r\nfc_port_t *fcport, *rmptemp;\r\nLIST_HEAD(new_fcports);\r\nrval = qlafx00_fx_disc(vha, &vha->hw->mr.fcport,\r\nFXDISC_GET_TGT_NODE_LIST);\r\nif (rval != QLA_SUCCESS) {\r\nset_bit(LOOP_RESYNC_NEEDED, &vha->dpc_flags);\r\nreturn rval;\r\n}\r\nrval = qlafx00_find_all_targets(vha, &new_fcports);\r\nif (rval != QLA_SUCCESS) {\r\nset_bit(LOOP_RESYNC_NEEDED, &vha->dpc_flags);\r\nreturn rval;\r\n}\r\nlist_for_each_entry(fcport, &vha->vp_fcports, list) {\r\nif (test_bit(LOOP_RESYNC_NEEDED, &vha->dpc_flags))\r\nbreak;\r\nif (atomic_read(&fcport->state) == FCS_DEVICE_LOST) {\r\nif (fcport->port_type != FCT_INITIATOR)\r\nqla2x00_mark_device_lost(vha, fcport, 0, 0);\r\n}\r\n}\r\nlist_for_each_entry_safe(fcport, rmptemp, &new_fcports, list) {\r\nif (test_bit(LOOP_RESYNC_NEEDED, &vha->dpc_flags))\r\nbreak;\r\nqla2x00_update_fcport(vha, fcport);\r\nlist_move_tail(&fcport->list, &vha->vp_fcports);\r\nql_log(ql_log_info, vha, 0x208f,\r\n"Attach new target id 0x%x wwnn = %llx "\r\n"wwpn = %llx.\n",\r\nfcport->tgt_id,\r\n(unsigned long long)wwn_to_u64(fcport->node_name),\r\n(unsigned long long)wwn_to_u64(fcport->port_name));\r\n}\r\nlist_for_each_entry_safe(fcport, rmptemp, &new_fcports, list) {\r\nlist_del(&fcport->list);\r\nkfree(fcport);\r\n}\r\nreturn rval;\r\n}\r\nint\r\nqlafx00_configure_devices(scsi_qla_host_t *vha)\r\n{\r\nint rval;\r\nunsigned long flags, save_flags;\r\nrval = QLA_SUCCESS;\r\nsave_flags = flags = vha->dpc_flags;\r\nql_dbg(ql_dbg_disc, vha, 0x2090,\r\n"Configure devices -- dpc flags =0x%lx\n", flags);\r\nrval = qlafx00_configure_all_targets(vha);\r\nif (rval == QLA_SUCCESS) {\r\nif (test_bit(LOOP_RESYNC_NEEDED, &vha->dpc_flags)) {\r\nrval = QLA_FUNCTION_FAILED;\r\n} else {\r\natomic_set(&vha->loop_state, LOOP_READY);\r\nql_log(ql_log_info, vha, 0x2091,\r\n"Device Ready\n");\r\n}\r\n}\r\nif (rval) {\r\nql_dbg(ql_dbg_disc, vha, 0x2092,\r\n"%s *** FAILED ***.\n", __func__);\r\n} else {\r\nql_dbg(ql_dbg_disc, vha, 0x2093,\r\n"%s: exiting normally.\n", __func__);\r\n}\r\nreturn rval;\r\n}\r\nstatic void\r\nqlafx00_abort_isp_cleanup(scsi_qla_host_t *vha, bool critemp)\r\n{\r\nstruct qla_hw_data *ha = vha->hw;\r\nfc_port_t *fcport;\r\nvha->flags.online = 0;\r\nha->mr.fw_hbt_en = 0;\r\nif (!critemp) {\r\nha->flags.chip_reset_done = 0;\r\nclear_bit(ISP_ABORT_NEEDED, &vha->dpc_flags);\r\nvha->qla_stats.total_isp_aborts++;\r\nql_log(ql_log_info, vha, 0x013f,\r\n"Performing ISP error recovery - ha = %p.\n", ha);\r\nha->isp_ops->reset_chip(vha);\r\n}\r\nif (atomic_read(&vha->loop_state) != LOOP_DOWN) {\r\natomic_set(&vha->loop_state, LOOP_DOWN);\r\natomic_set(&vha->loop_down_timer,\r\nQLAFX00_LOOP_DOWN_TIME);\r\n} else {\r\nif (!atomic_read(&vha->loop_down_timer))\r\natomic_set(&vha->loop_down_timer,\r\nQLAFX00_LOOP_DOWN_TIME);\r\n}\r\nlist_for_each_entry(fcport, &vha->vp_fcports, list) {\r\nfcport->flags = 0;\r\nif (atomic_read(&fcport->state) == FCS_ONLINE)\r\nqla2x00_set_fcport_state(fcport, FCS_DEVICE_LOST);\r\n}\r\nif (!ha->flags.eeh_busy) {\r\nif (critemp) {\r\nqla2x00_abort_all_cmds(vha, DID_NO_CONNECT << 16);\r\n} else {\r\nqla2x00_abort_all_cmds(vha, DID_RESET << 16);\r\n}\r\n}\r\nqla2x00_free_irqs(vha);\r\nif (critemp)\r\nset_bit(FX00_CRITEMP_RECOVERY, &vha->dpc_flags);\r\nelse\r\nset_bit(FX00_RESET_RECOVERY, &vha->dpc_flags);\r\nQLAFX00_CLR_INTR_REG(ha, QLAFX00_HST_INT_STS_BITS);\r\nql_log(ql_log_info, vha, 0x0140,\r\n"%s Done done - ha=%p.\n", __func__, ha);\r\n}\r\nvoid\r\nqlafx00_init_response_q_entries(struct rsp_que *rsp)\r\n{\r\nuint16_t cnt;\r\nresponse_t *pkt;\r\nrsp->ring_ptr = rsp->ring;\r\nrsp->ring_index = 0;\r\nrsp->status_srb = NULL;\r\npkt = rsp->ring_ptr;\r\nfor (cnt = 0; cnt < rsp->length; cnt++) {\r\npkt->signature = RESPONSE_PROCESSED;\r\nWRT_REG_DWORD((void __iomem *)&pkt->signature,\r\nRESPONSE_PROCESSED);\r\npkt++;\r\n}\r\n}\r\nint\r\nqlafx00_rescan_isp(scsi_qla_host_t *vha)\r\n{\r\nuint32_t status = QLA_FUNCTION_FAILED;\r\nstruct qla_hw_data *ha = vha->hw;\r\nstruct device_reg_fx00 __iomem *reg = &ha->iobase->ispfx00;\r\nuint32_t aenmbx7;\r\nqla2x00_request_irqs(ha, ha->rsp_q_map[0]);\r\naenmbx7 = RD_REG_DWORD(&reg->aenmailbox7);\r\nha->mbx_intr_code = MSW(aenmbx7);\r\nha->rqstq_intr_code = LSW(aenmbx7);\r\nha->req_que_off = RD_REG_DWORD(&reg->aenmailbox1);\r\nha->rsp_que_off = RD_REG_DWORD(&reg->aenmailbox3);\r\nha->req_que_len = RD_REG_DWORD(&reg->aenmailbox5);\r\nha->rsp_que_len = RD_REG_DWORD(&reg->aenmailbox6);\r\nql_dbg(ql_dbg_disc, vha, 0x2094,\r\n"fw returned mbx_intr_code: 0x%x, rqstq_intr_code: 0x%x "\r\n" Req que offset 0x%x Rsp que offset 0x%x\n",\r\nha->mbx_intr_code, ha->rqstq_intr_code,\r\nha->req_que_off, ha->rsp_que_len);\r\nQLAFX00_CLR_INTR_REG(ha, QLAFX00_HST_INT_STS_BITS);\r\nstatus = qla2x00_init_rings(vha);\r\nif (!status) {\r\nvha->flags.online = 1;\r\nif ((vha->device_flags & DFLG_NO_CABLE))\r\nstatus = 0;\r\nif (qlafx00_fx_disc(vha,\r\n&vha->hw->mr.fcport, FXDISC_REG_HOST_INFO))\r\nql_dbg(ql_dbg_disc, vha, 0x2095,\r\n"failed to register host info\n");\r\n}\r\nscsi_unblock_requests(vha->host);\r\nreturn status;\r\n}\r\nvoid\r\nqlafx00_timer_routine(scsi_qla_host_t *vha)\r\n{\r\nstruct qla_hw_data *ha = vha->hw;\r\nuint32_t fw_heart_beat;\r\nuint32_t aenmbx0;\r\nstruct device_reg_fx00 __iomem *reg = &ha->iobase->ispfx00;\r\nuint32_t tempc;\r\nif (ha->mr.fw_hbt_cnt)\r\nha->mr.fw_hbt_cnt--;\r\nelse {\r\nif ((!ha->flags.mr_reset_hdlr_active) &&\r\n(!test_bit(UNLOADING, &vha->dpc_flags)) &&\r\n(!test_bit(ABORT_ISP_ACTIVE, &vha->dpc_flags)) &&\r\n(ha->mr.fw_hbt_en)) {\r\nfw_heart_beat = RD_REG_DWORD(&reg->fwheartbeat);\r\nif (fw_heart_beat != ha->mr.old_fw_hbt_cnt) {\r\nha->mr.old_fw_hbt_cnt = fw_heart_beat;\r\nha->mr.fw_hbt_miss_cnt = 0;\r\n} else {\r\nha->mr.fw_hbt_miss_cnt++;\r\nif (ha->mr.fw_hbt_miss_cnt ==\r\nQLAFX00_HEARTBEAT_MISS_CNT) {\r\nset_bit(ISP_ABORT_NEEDED,\r\n&vha->dpc_flags);\r\nqla2xxx_wake_dpc(vha);\r\nha->mr.fw_hbt_miss_cnt = 0;\r\n}\r\n}\r\n}\r\nha->mr.fw_hbt_cnt = QLAFX00_HEARTBEAT_INTERVAL;\r\n}\r\nif (test_bit(FX00_RESET_RECOVERY, &vha->dpc_flags)) {\r\naenmbx0 = RD_REG_DWORD(&reg->aenmailbox0);\r\nif (ha->mr.fw_reset_timer_exp) {\r\nset_bit(ISP_ABORT_NEEDED, &vha->dpc_flags);\r\nqla2xxx_wake_dpc(vha);\r\nha->mr.fw_reset_timer_exp = 0;\r\n} else if (aenmbx0 == MBA_FW_RESTART_CMPLT) {\r\nset_bit(FX00_TARGET_SCAN, &vha->dpc_flags);\r\nclear_bit(FX00_RESET_RECOVERY, &vha->dpc_flags);\r\nqla2xxx_wake_dpc(vha);\r\nha->mr.fw_reset_timer_tick = QLAFX00_RESET_INTERVAL;\r\n} else if ((aenmbx0 == MBA_FW_STARTING) &&\r\n(!ha->mr.fw_hbt_en)) {\r\nha->mr.fw_hbt_en = 1;\r\n} else if (!ha->mr.fw_reset_timer_tick) {\r\nif (aenmbx0 == ha->mr.old_aenmbx0_state)\r\nha->mr.fw_reset_timer_exp = 1;\r\nha->mr.fw_reset_timer_tick = QLAFX00_RESET_INTERVAL;\r\n} else if (aenmbx0 == 0xFFFFFFFF) {\r\nuint32_t data0, data1;\r\ndata0 = QLAFX00_RD_REG(ha,\r\nQLAFX00_BAR1_BASE_ADDR_REG);\r\ndata1 = QLAFX00_RD_REG(ha,\r\nQLAFX00_PEX0_WIN0_BASE_ADDR_REG);\r\ndata0 &= 0xffff0000;\r\ndata1 &= 0x0000ffff;\r\nQLAFX00_WR_REG(ha,\r\nQLAFX00_PEX0_WIN0_BASE_ADDR_REG,\r\n(data0 | data1));\r\n} else if ((aenmbx0 & 0xFF00) == MBA_FW_POLL_STATE) {\r\nha->mr.fw_reset_timer_tick =\r\nQLAFX00_MAX_RESET_INTERVAL;\r\n} else if (aenmbx0 == MBA_FW_RESET_FCT) {\r\nha->mr.fw_reset_timer_tick =\r\nQLAFX00_MAX_RESET_INTERVAL;\r\n}\r\nif (ha->mr.old_aenmbx0_state != aenmbx0) {\r\nha->mr.old_aenmbx0_state = aenmbx0;\r\nha->mr.fw_reset_timer_tick = QLAFX00_RESET_INTERVAL;\r\n}\r\nha->mr.fw_reset_timer_tick--;\r\n}\r\nif (test_bit(FX00_CRITEMP_RECOVERY, &vha->dpc_flags)) {\r\nif (ha->mr.fw_critemp_timer_tick == 0) {\r\ntempc = QLAFX00_GET_TEMPERATURE(ha);\r\nql_dbg(ql_dbg_timer, vha, 0x6012,\r\n"ISPFx00(%s): Critical temp timer, "\r\n"current SOC temperature: %d\n",\r\n__func__, tempc);\r\nif (tempc < ha->mr.critical_temperature) {\r\nset_bit(ISP_ABORT_NEEDED, &vha->dpc_flags);\r\nclear_bit(FX00_CRITEMP_RECOVERY,\r\n&vha->dpc_flags);\r\nqla2xxx_wake_dpc(vha);\r\n}\r\nha->mr.fw_critemp_timer_tick =\r\nQLAFX00_CRITEMP_INTERVAL;\r\n} else {\r\nha->mr.fw_critemp_timer_tick--;\r\n}\r\n}\r\nif (ha->mr.host_info_resend) {\r\nif (ha->mr.hinfo_resend_timer_tick == 0) {\r\nha->mr.host_info_resend = false;\r\nset_bit(FX00_HOST_INFO_RESEND, &vha->dpc_flags);\r\nha->mr.hinfo_resend_timer_tick =\r\nQLAFX00_HINFO_RESEND_INTERVAL;\r\nqla2xxx_wake_dpc(vha);\r\n} else {\r\nha->mr.hinfo_resend_timer_tick--;\r\n}\r\n}\r\n}\r\nint\r\nqlafx00_reset_initialize(scsi_qla_host_t *vha)\r\n{\r\nstruct qla_hw_data *ha = vha->hw;\r\nif (vha->device_flags & DFLG_DEV_FAILED) {\r\nql_dbg(ql_dbg_init, vha, 0x0142,\r\n"Device in failed state\n");\r\nreturn QLA_SUCCESS;\r\n}\r\nha->flags.mr_reset_hdlr_active = 1;\r\nif (vha->flags.online) {\r\nscsi_block_requests(vha->host);\r\nqlafx00_abort_isp_cleanup(vha, false);\r\n}\r\nql_log(ql_log_info, vha, 0x0143,\r\n"(%s): succeeded.\n", __func__);\r\nha->flags.mr_reset_hdlr_active = 0;\r\nreturn QLA_SUCCESS;\r\n}\r\nint\r\nqlafx00_abort_isp(scsi_qla_host_t *vha)\r\n{\r\nstruct qla_hw_data *ha = vha->hw;\r\nif (vha->flags.online) {\r\nif (unlikely(pci_channel_offline(ha->pdev) &&\r\nha->flags.pci_channel_io_perm_failure)) {\r\nclear_bit(ISP_ABORT_RETRY, &vha->dpc_flags);\r\nreturn QLA_SUCCESS;\r\n}\r\nscsi_block_requests(vha->host);\r\nqlafx00_abort_isp_cleanup(vha, false);\r\n} else {\r\nscsi_block_requests(vha->host);\r\nclear_bit(ISP_ABORT_NEEDED, &vha->dpc_flags);\r\nvha->qla_stats.total_isp_aborts++;\r\nha->isp_ops->reset_chip(vha);\r\nset_bit(FX00_RESET_RECOVERY, &vha->dpc_flags);\r\nQLAFX00_CLR_INTR_REG(ha, QLAFX00_HST_INT_STS_BITS);\r\n}\r\nql_log(ql_log_info, vha, 0x0145,\r\n"(%s): succeeded.\n", __func__);\r\nreturn QLA_SUCCESS;\r\n}\r\nstatic inline fc_port_t*\r\nqlafx00_get_fcport(struct scsi_qla_host *vha, int tgt_id)\r\n{\r\nfc_port_t *fcport;\r\nlist_for_each_entry(fcport, &vha->vp_fcports, list) {\r\nif (fcport->tgt_id == tgt_id) {\r\nql_dbg(ql_dbg_async, vha, 0x5072,\r\n"Matching fcport(%p) found with TGT-ID: 0x%x "\r\n"and Remote TGT_ID: 0x%x\n",\r\nfcport, fcport->tgt_id, tgt_id);\r\nreturn fcport;\r\n}\r\n}\r\nreturn NULL;\r\n}\r\nstatic void\r\nqlafx00_tgt_detach(struct scsi_qla_host *vha, int tgt_id)\r\n{\r\nfc_port_t *fcport;\r\nql_log(ql_log_info, vha, 0x5073,\r\n"Detach TGT-ID: 0x%x\n", tgt_id);\r\nfcport = qlafx00_get_fcport(vha, tgt_id);\r\nif (!fcport)\r\nreturn;\r\nqla2x00_mark_device_lost(vha, fcport, 0, 0);\r\nreturn;\r\n}\r\nint\r\nqlafx00_process_aen(struct scsi_qla_host *vha, struct qla_work_evt *evt)\r\n{\r\nint rval = 0;\r\nuint32_t aen_code, aen_data;\r\naen_code = FCH_EVT_VENDOR_UNIQUE;\r\naen_data = evt->u.aenfx.evtcode;\r\nswitch (evt->u.aenfx.evtcode) {\r\ncase QLAFX00_MBA_PORT_UPDATE:\r\nif (evt->u.aenfx.mbx[1] == 0) {\r\nif (evt->u.aenfx.mbx[2] == 1) {\r\nif (!vha->flags.fw_tgt_reported)\r\nvha->flags.fw_tgt_reported = 1;\r\natomic_set(&vha->loop_down_timer, 0);\r\natomic_set(&vha->loop_state, LOOP_UP);\r\nset_bit(LOOP_RESYNC_NEEDED, &vha->dpc_flags);\r\nqla2xxx_wake_dpc(vha);\r\n} else if (evt->u.aenfx.mbx[2] == 2) {\r\nqlafx00_tgt_detach(vha, evt->u.aenfx.mbx[3]);\r\n}\r\n} else if (evt->u.aenfx.mbx[1] == 0xffff) {\r\nif (evt->u.aenfx.mbx[2] == 1) {\r\nif (!vha->flags.fw_tgt_reported)\r\nvha->flags.fw_tgt_reported = 1;\r\nset_bit(LOOP_RESYNC_NEEDED, &vha->dpc_flags);\r\n} else if (evt->u.aenfx.mbx[2] == 2) {\r\nvha->device_flags |= DFLG_NO_CABLE;\r\nqla2x00_mark_all_devices_lost(vha, 1);\r\n}\r\n}\r\nbreak;\r\ncase QLAFX00_MBA_LINK_UP:\r\naen_code = FCH_EVT_LINKUP;\r\naen_data = 0;\r\nbreak;\r\ncase QLAFX00_MBA_LINK_DOWN:\r\naen_code = FCH_EVT_LINKDOWN;\r\naen_data = 0;\r\nbreak;\r\ncase QLAFX00_MBA_TEMP_CRIT:\r\nql_log(ql_log_info, vha, 0x5082,\r\n"Process critical temperature event "\r\n"aenmb[0]: %x\n",\r\nevt->u.aenfx.evtcode);\r\nscsi_block_requests(vha->host);\r\nqlafx00_abort_isp_cleanup(vha, true);\r\nscsi_unblock_requests(vha->host);\r\nbreak;\r\n}\r\nfc_host_post_event(vha->host, fc_get_event_number(),\r\naen_code, aen_data);\r\nreturn rval;\r\n}\r\nstatic void\r\nqlafx00_update_host_attr(scsi_qla_host_t *vha, struct port_info_data *pinfo)\r\n{\r\nu64 port_name = 0, node_name = 0;\r\nport_name = (unsigned long long)wwn_to_u64(pinfo->port_name);\r\nnode_name = (unsigned long long)wwn_to_u64(pinfo->node_name);\r\nfc_host_node_name(vha->host) = node_name;\r\nfc_host_port_name(vha->host) = port_name;\r\nif (!pinfo->port_type)\r\nvha->hw->current_topology = ISP_CFG_F;\r\nif (pinfo->link_status == QLAFX00_LINK_STATUS_UP)\r\natomic_set(&vha->loop_state, LOOP_READY);\r\nelse if (pinfo->link_status == QLAFX00_LINK_STATUS_DOWN)\r\natomic_set(&vha->loop_state, LOOP_DOWN);\r\nvha->hw->link_data_rate = (uint16_t)pinfo->link_config;\r\n}\r\nstatic void\r\nqla2x00_fxdisc_iocb_timeout(void *data)\r\n{\r\nsrb_t *sp = (srb_t *)data;\r\nstruct srb_iocb *lio = &sp->u.iocb_cmd;\r\ncomplete(&lio->u.fxiocb.fxiocb_comp);\r\n}\r\nstatic void\r\nqla2x00_fxdisc_sp_done(void *data, void *ptr, int res)\r\n{\r\nsrb_t *sp = (srb_t *)ptr;\r\nstruct srb_iocb *lio = &sp->u.iocb_cmd;\r\ncomplete(&lio->u.fxiocb.fxiocb_comp);\r\n}\r\nint\r\nqlafx00_fx_disc(scsi_qla_host_t *vha, fc_port_t *fcport, uint16_t fx_type)\r\n{\r\nsrb_t *sp;\r\nstruct srb_iocb *fdisc;\r\nint rval = QLA_FUNCTION_FAILED;\r\nstruct qla_hw_data *ha = vha->hw;\r\nstruct host_system_info *phost_info;\r\nstruct register_host_info *preg_hsi;\r\nstruct new_utsname *p_sysid = NULL;\r\nstruct timeval tv;\r\nsp = qla2x00_get_sp(vha, fcport, GFP_KERNEL);\r\nif (!sp)\r\ngoto done;\r\nfdisc = &sp->u.iocb_cmd;\r\nswitch (fx_type) {\r\ncase FXDISC_GET_CONFIG_INFO:\r\nfdisc->u.fxiocb.flags =\r\nSRB_FXDISC_RESP_DMA_VALID;\r\nfdisc->u.fxiocb.rsp_len = sizeof(struct config_info_data);\r\nbreak;\r\ncase FXDISC_GET_PORT_INFO:\r\nfdisc->u.fxiocb.flags =\r\nSRB_FXDISC_RESP_DMA_VALID | SRB_FXDISC_REQ_DWRD_VALID;\r\nfdisc->u.fxiocb.rsp_len = QLAFX00_PORT_DATA_INFO;\r\nfdisc->u.fxiocb.req_data = cpu_to_le32(fcport->port_id);\r\nbreak;\r\ncase FXDISC_GET_TGT_NODE_INFO:\r\nfdisc->u.fxiocb.flags =\r\nSRB_FXDISC_RESP_DMA_VALID | SRB_FXDISC_REQ_DWRD_VALID;\r\nfdisc->u.fxiocb.rsp_len = QLAFX00_TGT_NODE_INFO;\r\nfdisc->u.fxiocb.req_data = cpu_to_le32(fcport->tgt_id);\r\nbreak;\r\ncase FXDISC_GET_TGT_NODE_LIST:\r\nfdisc->u.fxiocb.flags =\r\nSRB_FXDISC_RESP_DMA_VALID | SRB_FXDISC_REQ_DWRD_VALID;\r\nfdisc->u.fxiocb.rsp_len = QLAFX00_TGT_NODE_LIST_SIZE;\r\nbreak;\r\ncase FXDISC_REG_HOST_INFO:\r\nfdisc->u.fxiocb.flags = SRB_FXDISC_REQ_DMA_VALID;\r\nfdisc->u.fxiocb.req_len = sizeof(struct register_host_info);\r\np_sysid = utsname();\r\nif (!p_sysid) {\r\nql_log(ql_log_warn, vha, 0x303c,\r\n"Not able to get the system information\n");\r\ngoto done_free_sp;\r\n}\r\nbreak;\r\ncase FXDISC_ABORT_IOCTL:\r\ndefault:\r\nbreak;\r\n}\r\nif (fdisc->u.fxiocb.flags & SRB_FXDISC_REQ_DMA_VALID) {\r\nfdisc->u.fxiocb.req_addr = dma_alloc_coherent(&ha->pdev->dev,\r\nfdisc->u.fxiocb.req_len,\r\n&fdisc->u.fxiocb.req_dma_handle, GFP_KERNEL);\r\nif (!fdisc->u.fxiocb.req_addr)\r\ngoto done_free_sp;\r\nif (fx_type == FXDISC_REG_HOST_INFO) {\r\npreg_hsi = (struct register_host_info *)\r\nfdisc->u.fxiocb.req_addr;\r\nphost_info = &preg_hsi->hsi;\r\nmemset(preg_hsi, 0, sizeof(struct register_host_info));\r\nphost_info->os_type = OS_TYPE_LINUX;\r\nstrncpy(phost_info->sysname,\r\np_sysid->sysname, SYSNAME_LENGTH);\r\nstrncpy(phost_info->nodename,\r\np_sysid->nodename, NODENAME_LENGTH);\r\nif (!strcmp(phost_info->nodename, "(none)"))\r\nha->mr.host_info_resend = true;\r\nstrncpy(phost_info->release,\r\np_sysid->release, RELEASE_LENGTH);\r\nstrncpy(phost_info->version,\r\np_sysid->version, VERSION_LENGTH);\r\nstrncpy(phost_info->machine,\r\np_sysid->machine, MACHINE_LENGTH);\r\nstrncpy(phost_info->domainname,\r\np_sysid->domainname, DOMNAME_LENGTH);\r\nstrncpy(phost_info->hostdriver,\r\nQLA2XXX_VERSION, VERSION_LENGTH);\r\ndo_gettimeofday(&tv);\r\npreg_hsi->utc = (uint64_t)tv.tv_sec;\r\nql_dbg(ql_dbg_init, vha, 0x0149,\r\n"ISP%04X: Host registration with firmware\n",\r\nha->pdev->device);\r\nql_dbg(ql_dbg_init, vha, 0x014a,\r\n"os_type = '%d', sysname = '%s', nodname = '%s'\n",\r\nphost_info->os_type,\r\nphost_info->sysname,\r\nphost_info->nodename);\r\nql_dbg(ql_dbg_init, vha, 0x014b,\r\n"release = '%s', version = '%s'\n",\r\nphost_info->release,\r\nphost_info->version);\r\nql_dbg(ql_dbg_init, vha, 0x014c,\r\n"machine = '%s' "\r\n"domainname = '%s', hostdriver = '%s'\n",\r\nphost_info->machine,\r\nphost_info->domainname,\r\nphost_info->hostdriver);\r\nql_dump_buffer(ql_dbg_init + ql_dbg_disc, vha, 0x014d,\r\n(uint8_t *)phost_info,\r\nsizeof(struct host_system_info));\r\n}\r\n}\r\nif (fdisc->u.fxiocb.flags & SRB_FXDISC_RESP_DMA_VALID) {\r\nfdisc->u.fxiocb.rsp_addr = dma_alloc_coherent(&ha->pdev->dev,\r\nfdisc->u.fxiocb.rsp_len,\r\n&fdisc->u.fxiocb.rsp_dma_handle, GFP_KERNEL);\r\nif (!fdisc->u.fxiocb.rsp_addr)\r\ngoto done_unmap_req;\r\n}\r\nsp->type = SRB_FXIOCB_DCMD;\r\nsp->name = "fxdisc";\r\nqla2x00_init_timer(sp, FXDISC_TIMEOUT);\r\nfdisc->timeout = qla2x00_fxdisc_iocb_timeout;\r\nfdisc->u.fxiocb.req_func_type = cpu_to_le16(fx_type);\r\nsp->done = qla2x00_fxdisc_sp_done;\r\nrval = qla2x00_start_sp(sp);\r\nif (rval != QLA_SUCCESS)\r\ngoto done_unmap_dma;\r\nwait_for_completion(&fdisc->u.fxiocb.fxiocb_comp);\r\nif (fx_type == FXDISC_GET_CONFIG_INFO) {\r\nstruct config_info_data *pinfo =\r\n(struct config_info_data *) fdisc->u.fxiocb.rsp_addr;\r\nstrcpy(vha->hw->model_number, pinfo->model_num);\r\nstrcpy(vha->hw->model_desc, pinfo->model_description);\r\nmemcpy(&vha->hw->mr.symbolic_name, pinfo->symbolic_name,\r\nsizeof(vha->hw->mr.symbolic_name));\r\nmemcpy(&vha->hw->mr.serial_num, pinfo->serial_num,\r\nsizeof(vha->hw->mr.serial_num));\r\nmemcpy(&vha->hw->mr.hw_version, pinfo->hw_version,\r\nsizeof(vha->hw->mr.hw_version));\r\nmemcpy(&vha->hw->mr.fw_version, pinfo->fw_version,\r\nsizeof(vha->hw->mr.fw_version));\r\nstrim(vha->hw->mr.fw_version);\r\nmemcpy(&vha->hw->mr.uboot_version, pinfo->uboot_version,\r\nsizeof(vha->hw->mr.uboot_version));\r\nmemcpy(&vha->hw->mr.fru_serial_num, pinfo->fru_serial_num,\r\nsizeof(vha->hw->mr.fru_serial_num));\r\nvha->hw->mr.critical_temperature =\r\n(pinfo->nominal_temp_value) ?\r\npinfo->nominal_temp_value : QLAFX00_CRITEMP_THRSHLD;\r\nha->mr.extended_io_enabled = (pinfo->enabled_capabilities &\r\nQLAFX00_EXTENDED_IO_EN_MASK) != 0;\r\n} else if (fx_type == FXDISC_GET_PORT_INFO) {\r\nstruct port_info_data *pinfo =\r\n(struct port_info_data *) fdisc->u.fxiocb.rsp_addr;\r\nmemcpy(vha->node_name, pinfo->node_name, WWN_SIZE);\r\nmemcpy(vha->port_name, pinfo->port_name, WWN_SIZE);\r\nvha->d_id.b.domain = pinfo->port_id[0];\r\nvha->d_id.b.area = pinfo->port_id[1];\r\nvha->d_id.b.al_pa = pinfo->port_id[2];\r\nqlafx00_update_host_attr(vha, pinfo);\r\nql_dump_buffer(ql_dbg_init + ql_dbg_buffer, vha, 0x0141,\r\n(uint8_t *)pinfo, 16);\r\n} else if (fx_type == FXDISC_GET_TGT_NODE_INFO) {\r\nstruct qlafx00_tgt_node_info *pinfo =\r\n(struct qlafx00_tgt_node_info *) fdisc->u.fxiocb.rsp_addr;\r\nmemcpy(fcport->node_name, pinfo->tgt_node_wwnn, WWN_SIZE);\r\nmemcpy(fcport->port_name, pinfo->tgt_node_wwpn, WWN_SIZE);\r\nfcport->port_type = FCT_TARGET;\r\nql_dump_buffer(ql_dbg_init + ql_dbg_buffer, vha, 0x0144,\r\n(uint8_t *)pinfo, 16);\r\n} else if (fx_type == FXDISC_GET_TGT_NODE_LIST) {\r\nstruct qlafx00_tgt_node_info *pinfo =\r\n(struct qlafx00_tgt_node_info *) fdisc->u.fxiocb.rsp_addr;\r\nql_dump_buffer(ql_dbg_init + ql_dbg_buffer, vha, 0x0146,\r\n(uint8_t *)pinfo, 16);\r\nmemcpy(vha->hw->gid_list, pinfo, QLAFX00_TGT_NODE_LIST_SIZE);\r\n} else if (fx_type == FXDISC_ABORT_IOCTL)\r\nfdisc->u.fxiocb.result =\r\n(fdisc->u.fxiocb.result ==\r\ncpu_to_le32(QLAFX00_IOCTL_ICOB_ABORT_SUCCESS)) ?\r\ncpu_to_le32(QLA_SUCCESS) : cpu_to_le32(QLA_FUNCTION_FAILED);\r\nrval = le32_to_cpu(fdisc->u.fxiocb.result);\r\ndone_unmap_dma:\r\nif (fdisc->u.fxiocb.rsp_addr)\r\ndma_free_coherent(&ha->pdev->dev, fdisc->u.fxiocb.rsp_len,\r\nfdisc->u.fxiocb.rsp_addr, fdisc->u.fxiocb.rsp_dma_handle);\r\ndone_unmap_req:\r\nif (fdisc->u.fxiocb.req_addr)\r\ndma_free_coherent(&ha->pdev->dev, fdisc->u.fxiocb.req_len,\r\nfdisc->u.fxiocb.req_addr, fdisc->u.fxiocb.req_dma_handle);\r\ndone_free_sp:\r\nsp->free(vha, sp);\r\ndone:\r\nreturn rval;\r\n}\r\nint\r\nqlafx00_initialize_adapter(scsi_qla_host_t *vha)\r\n{\r\nint rval;\r\nstruct qla_hw_data *ha = vha->hw;\r\nuint32_t tempc;\r\nvha->flags.online = 0;\r\nha->flags.chip_reset_done = 0;\r\nvha->flags.reset_active = 0;\r\nha->flags.pci_channel_io_perm_failure = 0;\r\nha->flags.eeh_busy = 0;\r\natomic_set(&vha->loop_down_timer, LOOP_DOWN_TIME);\r\natomic_set(&vha->loop_state, LOOP_DOWN);\r\nvha->device_flags = DFLG_NO_CABLE;\r\nvha->dpc_flags = 0;\r\nvha->flags.management_server_logged_in = 0;\r\nha->isp_abort_cnt = 0;\r\nha->beacon_blink_led = 0;\r\nset_bit(0, ha->req_qid_map);\r\nset_bit(0, ha->rsp_qid_map);\r\nql_dbg(ql_dbg_init, vha, 0x0147,\r\n"Configuring PCI space...\n");\r\nrval = ha->isp_ops->pci_config(vha);\r\nif (rval) {\r\nql_log(ql_log_warn, vha, 0x0148,\r\n"Unable to configure PCI space.\n");\r\nreturn rval;\r\n}\r\nrval = qlafx00_init_fw_ready(vha);\r\nif (rval != QLA_SUCCESS)\r\nreturn rval;\r\nqlafx00_save_queue_ptrs(vha);\r\nrval = qlafx00_config_queues(vha);\r\nif (rval != QLA_SUCCESS)\r\nreturn rval;\r\nrval = qla2x00_alloc_outstanding_cmds(ha, vha->req);\r\nif (rval != QLA_SUCCESS)\r\nreturn rval;\r\nrval = qla2x00_init_rings(vha);\r\nha->flags.chip_reset_done = 1;\r\ntempc = QLAFX00_GET_TEMPERATURE(ha);\r\nql_dbg(ql_dbg_init, vha, 0x0152,\r\n"ISPFx00(%s): Critical temp timer, current SOC temperature: 0x%x\n",\r\n__func__, tempc);\r\nreturn rval;\r\n}\r\nuint32_t\r\nqlafx00_fw_state_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nscsi_qla_host_t *vha = shost_priv(class_to_shost(dev));\r\nint rval = QLA_FUNCTION_FAILED;\r\nuint32_t state[1];\r\nif (qla2x00_reset_active(vha))\r\nql_log(ql_log_warn, vha, 0x70ce,\r\n"ISP reset active.\n");\r\nelse if (!vha->hw->flags.eeh_busy) {\r\nrval = qlafx00_get_firmware_state(vha, state);\r\n}\r\nif (rval != QLA_SUCCESS)\r\nmemset(state, -1, sizeof(state));\r\nreturn state[0];\r\n}\r\nvoid\r\nqlafx00_get_host_speed(struct Scsi_Host *shost)\r\n{\r\nstruct qla_hw_data *ha = ((struct scsi_qla_host *)\r\n(shost_priv(shost)))->hw;\r\nu32 speed = FC_PORTSPEED_UNKNOWN;\r\nswitch (ha->link_data_rate) {\r\ncase QLAFX00_PORT_SPEED_2G:\r\nspeed = FC_PORTSPEED_2GBIT;\r\nbreak;\r\ncase QLAFX00_PORT_SPEED_4G:\r\nspeed = FC_PORTSPEED_4GBIT;\r\nbreak;\r\ncase QLAFX00_PORT_SPEED_8G:\r\nspeed = FC_PORTSPEED_8GBIT;\r\nbreak;\r\ncase QLAFX00_PORT_SPEED_10G:\r\nspeed = FC_PORTSPEED_10GBIT;\r\nbreak;\r\n}\r\nfc_host_speed(shost) = speed;\r\n}\r\nstatic inline void\r\nqlafx00_handle_sense(srb_t *sp, uint8_t *sense_data, uint32_t par_sense_len,\r\nuint32_t sense_len, struct rsp_que *rsp, int res)\r\n{\r\nstruct scsi_qla_host *vha = sp->fcport->vha;\r\nstruct scsi_cmnd *cp = GET_CMD_SP(sp);\r\nuint32_t track_sense_len;\r\nSET_FW_SENSE_LEN(sp, sense_len);\r\nif (sense_len >= SCSI_SENSE_BUFFERSIZE)\r\nsense_len = SCSI_SENSE_BUFFERSIZE;\r\nSET_CMD_SENSE_LEN(sp, sense_len);\r\nSET_CMD_SENSE_PTR(sp, cp->sense_buffer);\r\ntrack_sense_len = sense_len;\r\nif (sense_len > par_sense_len)\r\nsense_len = par_sense_len;\r\nmemcpy(cp->sense_buffer, sense_data, sense_len);\r\nSET_FW_SENSE_LEN(sp, GET_FW_SENSE_LEN(sp) - sense_len);\r\nSET_CMD_SENSE_PTR(sp, cp->sense_buffer + sense_len);\r\ntrack_sense_len -= sense_len;\r\nSET_CMD_SENSE_LEN(sp, track_sense_len);\r\nql_dbg(ql_dbg_io, vha, 0x304d,\r\n"sense_len=0x%x par_sense_len=0x%x track_sense_len=0x%x.\n",\r\nsense_len, par_sense_len, track_sense_len);\r\nif (GET_FW_SENSE_LEN(sp) > 0) {\r\nrsp->status_srb = sp;\r\ncp->result = res;\r\n}\r\nif (sense_len) {\r\nql_dbg(ql_dbg_io + ql_dbg_buffer, vha, 0x3039,\r\n"Check condition Sense data, nexus%ld:%d:%llu cmd=%p.\n",\r\nsp->fcport->vha->host_no, cp->device->id, cp->device->lun,\r\ncp);\r\nql_dump_buffer(ql_dbg_io + ql_dbg_buffer, vha, 0x3049,\r\ncp->sense_buffer, sense_len);\r\n}\r\n}\r\nstatic void\r\nqlafx00_tm_iocb_entry(scsi_qla_host_t *vha, struct req_que *req,\r\nstruct tsk_mgmt_entry_fx00 *pkt, srb_t *sp,\r\n__le16 sstatus, __le16 cpstatus)\r\n{\r\nstruct srb_iocb *tmf;\r\ntmf = &sp->u.iocb_cmd;\r\nif (cpstatus != cpu_to_le16((uint16_t)CS_COMPLETE) ||\r\n(sstatus & cpu_to_le16((uint16_t)SS_RESPONSE_INFO_LEN_VALID)))\r\ncpstatus = cpu_to_le16((uint16_t)CS_INCOMPLETE);\r\ntmf->u.tmf.comp_status = cpstatus;\r\nsp->done(vha, sp, 0);\r\n}\r\nstatic void\r\nqlafx00_abort_iocb_entry(scsi_qla_host_t *vha, struct req_que *req,\r\nstruct abort_iocb_entry_fx00 *pkt)\r\n{\r\nconst char func[] = "ABT_IOCB";\r\nsrb_t *sp;\r\nstruct srb_iocb *abt;\r\nsp = qla2x00_get_sp_from_handle(vha, func, req, pkt);\r\nif (!sp)\r\nreturn;\r\nabt = &sp->u.iocb_cmd;\r\nabt->u.abt.comp_status = pkt->tgt_id_sts;\r\nsp->done(vha, sp, 0);\r\n}\r\nstatic void\r\nqlafx00_ioctl_iosb_entry(scsi_qla_host_t *vha, struct req_que *req,\r\nstruct ioctl_iocb_entry_fx00 *pkt)\r\n{\r\nconst char func[] = "IOSB_IOCB";\r\nsrb_t *sp;\r\nstruct fc_bsg_job *bsg_job;\r\nstruct srb_iocb *iocb_job;\r\nint res;\r\nstruct qla_mt_iocb_rsp_fx00 fstatus;\r\nuint8_t *fw_sts_ptr;\r\nsp = qla2x00_get_sp_from_handle(vha, func, req, pkt);\r\nif (!sp)\r\nreturn;\r\nif (sp->type == SRB_FXIOCB_DCMD) {\r\niocb_job = &sp->u.iocb_cmd;\r\niocb_job->u.fxiocb.seq_number = pkt->seq_no;\r\niocb_job->u.fxiocb.fw_flags = pkt->fw_iotcl_flags;\r\niocb_job->u.fxiocb.result = pkt->status;\r\nif (iocb_job->u.fxiocb.flags & SRB_FXDISC_RSP_DWRD_VALID)\r\niocb_job->u.fxiocb.req_data =\r\npkt->dataword_r;\r\n} else {\r\nbsg_job = sp->u.bsg_job;\r\nmemset(&fstatus, 0, sizeof(struct qla_mt_iocb_rsp_fx00));\r\nfstatus.reserved_1 = pkt->reserved_0;\r\nfstatus.func_type = pkt->comp_func_num;\r\nfstatus.ioctl_flags = pkt->fw_iotcl_flags;\r\nfstatus.ioctl_data = pkt->dataword_r;\r\nfstatus.adapid = pkt->adapid;\r\nfstatus.reserved_2 = pkt->dataword_r_extra;\r\nfstatus.res_count = pkt->residuallen;\r\nfstatus.status = pkt->status;\r\nfstatus.seq_number = pkt->seq_no;\r\nmemcpy(fstatus.reserved_3,\r\npkt->reserved_2, 20 * sizeof(uint8_t));\r\nfw_sts_ptr = ((uint8_t *)bsg_job->req->sense) +\r\nsizeof(struct fc_bsg_reply);\r\nmemcpy(fw_sts_ptr, (uint8_t *)&fstatus,\r\nsizeof(struct qla_mt_iocb_rsp_fx00));\r\nbsg_job->reply_len = sizeof(struct fc_bsg_reply) +\r\nsizeof(struct qla_mt_iocb_rsp_fx00) + sizeof(uint8_t);\r\nql_dump_buffer(ql_dbg_user + ql_dbg_verbose,\r\nsp->fcport->vha, 0x5080,\r\n(uint8_t *)pkt, sizeof(struct ioctl_iocb_entry_fx00));\r\nql_dump_buffer(ql_dbg_user + ql_dbg_verbose,\r\nsp->fcport->vha, 0x5074,\r\n(uint8_t *)fw_sts_ptr, sizeof(struct qla_mt_iocb_rsp_fx00));\r\nres = bsg_job->reply->result = DID_OK << 16;\r\nbsg_job->reply->reply_payload_rcv_len =\r\nbsg_job->reply_payload.payload_len;\r\n}\r\nsp->done(vha, sp, res);\r\n}\r\nstatic void\r\nqlafx00_status_entry(scsi_qla_host_t *vha, struct rsp_que *rsp, void *pkt)\r\n{\r\nsrb_t *sp;\r\nfc_port_t *fcport;\r\nstruct scsi_cmnd *cp;\r\nstruct sts_entry_fx00 *sts;\r\n__le16 comp_status;\r\n__le16 scsi_status;\r\nuint16_t ox_id;\r\n__le16 lscsi_status;\r\nint32_t resid;\r\nuint32_t sense_len, par_sense_len, rsp_info_len, resid_len,\r\nfw_resid_len;\r\nuint8_t *rsp_info = NULL, *sense_data = NULL;\r\nstruct qla_hw_data *ha = vha->hw;\r\nuint32_t hindex, handle;\r\nuint16_t que;\r\nstruct req_que *req;\r\nint logit = 1;\r\nint res = 0;\r\nsts = (struct sts_entry_fx00 *) pkt;\r\ncomp_status = sts->comp_status;\r\nscsi_status = sts->scsi_status & cpu_to_le16((uint16_t)SS_MASK);\r\nhindex = sts->handle;\r\nhandle = LSW(hindex);\r\nque = MSW(hindex);\r\nreq = ha->req_q_map[que];\r\nif (handle < req->num_outstanding_cmds)\r\nsp = req->outstanding_cmds[handle];\r\nelse\r\nsp = NULL;\r\nif (sp == NULL) {\r\nql_dbg(ql_dbg_io, vha, 0x3034,\r\n"Invalid status handle (0x%x).\n", handle);\r\nset_bit(ISP_ABORT_NEEDED, &vha->dpc_flags);\r\nqla2xxx_wake_dpc(vha);\r\nreturn;\r\n}\r\nif (sp->type == SRB_TM_CMD) {\r\nreq->outstanding_cmds[handle] = NULL;\r\nqlafx00_tm_iocb_entry(vha, req, pkt, sp,\r\nscsi_status, comp_status);\r\nreturn;\r\n}\r\nif (comp_status == CS_COMPLETE && scsi_status == 0) {\r\nqla2x00_process_completed_request(vha, req, handle);\r\nreturn;\r\n}\r\nreq->outstanding_cmds[handle] = NULL;\r\ncp = GET_CMD_SP(sp);\r\nif (cp == NULL) {\r\nql_dbg(ql_dbg_io, vha, 0x3048,\r\n"Command already returned (0x%x/%p).\n",\r\nhandle, sp);\r\nreturn;\r\n}\r\nlscsi_status = scsi_status & cpu_to_le16((uint16_t)STATUS_MASK);\r\nfcport = sp->fcport;\r\nox_id = 0;\r\nsense_len = par_sense_len = rsp_info_len = resid_len =\r\nfw_resid_len = 0;\r\nif (scsi_status & cpu_to_le16((uint16_t)SS_SENSE_LEN_VALID))\r\nsense_len = sts->sense_len;\r\nif (scsi_status & cpu_to_le16(((uint16_t)SS_RESIDUAL_UNDER\r\n| (uint16_t)SS_RESIDUAL_OVER)))\r\nresid_len = le32_to_cpu(sts->residual_len);\r\nif (comp_status == cpu_to_le16((uint16_t)CS_DATA_UNDERRUN))\r\nfw_resid_len = le32_to_cpu(sts->residual_len);\r\nrsp_info = sense_data = sts->data;\r\npar_sense_len = sizeof(sts->data);\r\nif (comp_status == CS_COMPLETE &&\r\nscsi_status & cpu_to_le16((uint16_t)SS_RESIDUAL_OVER))\r\ncomp_status = cpu_to_le16((uint16_t)CS_DATA_OVERRUN);\r\nswitch (le16_to_cpu(comp_status)) {\r\ncase CS_COMPLETE:\r\ncase CS_QUEUE_FULL:\r\nif (scsi_status == 0) {\r\nres = DID_OK << 16;\r\nbreak;\r\n}\r\nif (scsi_status & cpu_to_le16(((uint16_t)SS_RESIDUAL_UNDER\r\n| (uint16_t)SS_RESIDUAL_OVER))) {\r\nresid = resid_len;\r\nscsi_set_resid(cp, resid);\r\nif (!lscsi_status &&\r\n((unsigned)(scsi_bufflen(cp) - resid) <\r\ncp->underflow)) {\r\nql_dbg(ql_dbg_io, fcport->vha, 0x3050,\r\n"Mid-layer underflow "\r\n"detected (0x%x of 0x%x bytes).\n",\r\nresid, scsi_bufflen(cp));\r\nres = DID_ERROR << 16;\r\nbreak;\r\n}\r\n}\r\nres = DID_OK << 16 | le16_to_cpu(lscsi_status);\r\nif (lscsi_status ==\r\ncpu_to_le16((uint16_t)SAM_STAT_TASK_SET_FULL)) {\r\nql_dbg(ql_dbg_io, fcport->vha, 0x3051,\r\n"QUEUE FULL detected.\n");\r\nbreak;\r\n}\r\nlogit = 0;\r\nif (lscsi_status != cpu_to_le16((uint16_t)SS_CHECK_CONDITION))\r\nbreak;\r\nmemset(cp->sense_buffer, 0, SCSI_SENSE_BUFFERSIZE);\r\nif (!(scsi_status & cpu_to_le16((uint16_t)SS_SENSE_LEN_VALID)))\r\nbreak;\r\nqlafx00_handle_sense(sp, sense_data, par_sense_len, sense_len,\r\nrsp, res);\r\nbreak;\r\ncase CS_DATA_UNDERRUN:\r\nif (IS_FWI2_CAPABLE(ha) || IS_QLAFX00(ha))\r\nresid = fw_resid_len;\r\nelse\r\nresid = resid_len;\r\nscsi_set_resid(cp, resid);\r\nif (scsi_status & cpu_to_le16((uint16_t)SS_RESIDUAL_UNDER)) {\r\nif ((IS_FWI2_CAPABLE(ha) || IS_QLAFX00(ha))\r\n&& fw_resid_len != resid_len) {\r\nql_dbg(ql_dbg_io, fcport->vha, 0x3052,\r\n"Dropped frame(s) detected "\r\n"(0x%x of 0x%x bytes).\n",\r\nresid, scsi_bufflen(cp));\r\nres = DID_ERROR << 16 |\r\nle16_to_cpu(lscsi_status);\r\ngoto check_scsi_status;\r\n}\r\nif (!lscsi_status &&\r\n((unsigned)(scsi_bufflen(cp) - resid) <\r\ncp->underflow)) {\r\nql_dbg(ql_dbg_io, fcport->vha, 0x3053,\r\n"Mid-layer underflow "\r\n"detected (0x%x of 0x%x bytes, "\r\n"cp->underflow: 0x%x).\n",\r\nresid, scsi_bufflen(cp), cp->underflow);\r\nres = DID_ERROR << 16;\r\nbreak;\r\n}\r\n} else if (lscsi_status !=\r\ncpu_to_le16((uint16_t)SAM_STAT_TASK_SET_FULL) &&\r\nlscsi_status != cpu_to_le16((uint16_t)SAM_STAT_BUSY)) {\r\nql_dbg(ql_dbg_io, fcport->vha, 0x3054,\r\n"Dropped frame(s) detected (0x%x "\r\n"of 0x%x bytes).\n", resid,\r\nscsi_bufflen(cp));\r\nres = DID_ERROR << 16 | le16_to_cpu(lscsi_status);\r\ngoto check_scsi_status;\r\n} else {\r\nql_dbg(ql_dbg_io, fcport->vha, 0x3055,\r\n"scsi_status: 0x%x, lscsi_status: 0x%x\n",\r\nscsi_status, lscsi_status);\r\n}\r\nres = DID_OK << 16 | le16_to_cpu(lscsi_status);\r\nlogit = 0;\r\ncheck_scsi_status:\r\nif (lscsi_status != 0) {\r\nif (lscsi_status ==\r\ncpu_to_le16((uint16_t)SAM_STAT_TASK_SET_FULL)) {\r\nql_dbg(ql_dbg_io, fcport->vha, 0x3056,\r\n"QUEUE FULL detected.\n");\r\nlogit = 1;\r\nbreak;\r\n}\r\nif (lscsi_status !=\r\ncpu_to_le16((uint16_t)SS_CHECK_CONDITION))\r\nbreak;\r\nmemset(cp->sense_buffer, 0, SCSI_SENSE_BUFFERSIZE);\r\nif (!(scsi_status &\r\ncpu_to_le16((uint16_t)SS_SENSE_LEN_VALID)))\r\nbreak;\r\nqlafx00_handle_sense(sp, sense_data, par_sense_len,\r\nsense_len, rsp, res);\r\n}\r\nbreak;\r\ncase CS_PORT_LOGGED_OUT:\r\ncase CS_PORT_CONFIG_CHG:\r\ncase CS_PORT_BUSY:\r\ncase CS_INCOMPLETE:\r\ncase CS_PORT_UNAVAILABLE:\r\ncase CS_TIMEOUT:\r\ncase CS_RESET:\r\nres = DID_TRANSPORT_DISRUPTED << 16;\r\nql_dbg(ql_dbg_io, fcport->vha, 0x3057,\r\n"Port down status: port-state=0x%x.\n",\r\natomic_read(&fcport->state));\r\nif (atomic_read(&fcport->state) == FCS_ONLINE)\r\nqla2x00_mark_device_lost(fcport->vha, fcport, 1, 1);\r\nbreak;\r\ncase CS_ABORTED:\r\nres = DID_RESET << 16;\r\nbreak;\r\ndefault:\r\nres = DID_ERROR << 16;\r\nbreak;\r\n}\r\nif (logit)\r\nql_dbg(ql_dbg_io, fcport->vha, 0x3058,\r\n"FCP command status: 0x%x-0x%x (0x%x) nexus=%ld:%d:%llu "\r\n"tgt_id: 0x%x lscsi_status: 0x%x cdb=%10phN len=0x%x "\r\n"rsp_info=0x%x resid=0x%x fw_resid=0x%x sense_len=0x%x, "\r\n"par_sense_len=0x%x, rsp_info_len=0x%x\n",\r\ncomp_status, scsi_status, res, vha->host_no,\r\ncp->device->id, cp->device->lun, fcport->tgt_id,\r\nlscsi_status, cp->cmnd, scsi_bufflen(cp),\r\nrsp_info_len, resid_len, fw_resid_len, sense_len,\r\npar_sense_len, rsp_info_len);\r\nif (rsp->status_srb == NULL)\r\nsp->done(ha, sp, res);\r\n}\r\nstatic void\r\nqlafx00_status_cont_entry(struct rsp_que *rsp, sts_cont_entry_t *pkt)\r\n{\r\nuint8_t sense_sz = 0;\r\nstruct qla_hw_data *ha = rsp->hw;\r\nstruct scsi_qla_host *vha = pci_get_drvdata(ha->pdev);\r\nsrb_t *sp = rsp->status_srb;\r\nstruct scsi_cmnd *cp;\r\nuint32_t sense_len;\r\nuint8_t *sense_ptr;\r\nif (!sp) {\r\nql_dbg(ql_dbg_io, vha, 0x3037,\r\n"no SP, sp = %p\n", sp);\r\nreturn;\r\n}\r\nif (!GET_FW_SENSE_LEN(sp)) {\r\nql_dbg(ql_dbg_io, vha, 0x304b,\r\n"no fw sense data, sp = %p\n", sp);\r\nreturn;\r\n}\r\ncp = GET_CMD_SP(sp);\r\nif (cp == NULL) {\r\nql_log(ql_log_warn, vha, 0x303b,\r\n"cmd is NULL: already returned to OS (sp=%p).\n", sp);\r\nrsp->status_srb = NULL;\r\nreturn;\r\n}\r\nif (!GET_CMD_SENSE_LEN(sp)) {\r\nql_dbg(ql_dbg_io, vha, 0x304c,\r\n"no sense data, sp = %p\n", sp);\r\n} else {\r\nsense_len = GET_CMD_SENSE_LEN(sp);\r\nsense_ptr = GET_CMD_SENSE_PTR(sp);\r\nql_dbg(ql_dbg_io, vha, 0x304f,\r\n"sp=%p sense_len=0x%x sense_ptr=%p.\n",\r\nsp, sense_len, sense_ptr);\r\nif (sense_len > sizeof(pkt->data))\r\nsense_sz = sizeof(pkt->data);\r\nelse\r\nsense_sz = sense_len;\r\nql_dump_buffer(ql_dbg_io + ql_dbg_buffer, vha, 0x304e,\r\n(uint8_t *)pkt, sizeof(sts_cont_entry_t));\r\nmemcpy(sense_ptr, pkt->data, sense_sz);\r\nql_dump_buffer(ql_dbg_io + ql_dbg_buffer, vha, 0x304a,\r\nsense_ptr, sense_sz);\r\nsense_len -= sense_sz;\r\nsense_ptr += sense_sz;\r\nSET_CMD_SENSE_PTR(sp, sense_ptr);\r\nSET_CMD_SENSE_LEN(sp, sense_len);\r\n}\r\nsense_len = GET_FW_SENSE_LEN(sp);\r\nsense_len = (sense_len > sizeof(pkt->data)) ?\r\n(sense_len - sizeof(pkt->data)) : 0;\r\nSET_FW_SENSE_LEN(sp, sense_len);\r\nif (sense_len == 0) {\r\nrsp->status_srb = NULL;\r\nsp->done(ha, sp, cp->result);\r\n}\r\n}\r\nstatic void\r\nqlafx00_multistatus_entry(struct scsi_qla_host *vha,\r\nstruct rsp_que *rsp, void *pkt)\r\n{\r\nsrb_t *sp;\r\nstruct multi_sts_entry_fx00 *stsmfx;\r\nstruct qla_hw_data *ha = vha->hw;\r\nuint32_t handle, hindex, handle_count, i;\r\nuint16_t que;\r\nstruct req_que *req;\r\n__le32 *handle_ptr;\r\nstsmfx = (struct multi_sts_entry_fx00 *) pkt;\r\nhandle_count = stsmfx->handle_count;\r\nif (handle_count > MAX_HANDLE_COUNT) {\r\nql_dbg(ql_dbg_io, vha, 0x3035,\r\n"Invalid handle count (0x%x).\n", handle_count);\r\nset_bit(ISP_ABORT_NEEDED, &vha->dpc_flags);\r\nqla2xxx_wake_dpc(vha);\r\nreturn;\r\n}\r\nhandle_ptr = &stsmfx->handles[0];\r\nfor (i = 0; i < handle_count; i++) {\r\nhindex = le32_to_cpu(*handle_ptr);\r\nhandle = LSW(hindex);\r\nque = MSW(hindex);\r\nreq = ha->req_q_map[que];\r\nif (handle < req->num_outstanding_cmds)\r\nsp = req->outstanding_cmds[handle];\r\nelse\r\nsp = NULL;\r\nif (sp == NULL) {\r\nql_dbg(ql_dbg_io, vha, 0x3044,\r\n"Invalid status handle (0x%x).\n", handle);\r\nset_bit(ISP_ABORT_NEEDED, &vha->dpc_flags);\r\nqla2xxx_wake_dpc(vha);\r\nreturn;\r\n}\r\nqla2x00_process_completed_request(vha, req, handle);\r\nhandle_ptr++;\r\n}\r\n}\r\nstatic void\r\nqlafx00_error_entry(scsi_qla_host_t *vha, struct rsp_que *rsp,\r\nstruct sts_entry_fx00 *pkt, uint8_t estatus, uint8_t etype)\r\n{\r\nsrb_t *sp;\r\nstruct qla_hw_data *ha = vha->hw;\r\nconst char func[] = "ERROR-IOCB";\r\nuint16_t que = 0;\r\nstruct req_que *req = NULL;\r\nint res = DID_ERROR << 16;\r\nql_dbg(ql_dbg_async, vha, 0x507f,\r\n"type of error status in response: 0x%x\n", estatus);\r\nreq = ha->req_q_map[que];\r\nsp = qla2x00_get_sp_from_handle(vha, func, req, pkt);\r\nif (sp) {\r\nsp->done(ha, sp, res);\r\nreturn;\r\n}\r\nset_bit(ISP_ABORT_NEEDED, &vha->dpc_flags);\r\nqla2xxx_wake_dpc(vha);\r\n}\r\nstatic void\r\nqlafx00_process_response_queue(struct scsi_qla_host *vha,\r\nstruct rsp_que *rsp)\r\n{\r\nstruct sts_entry_fx00 *pkt;\r\nresponse_t *lptr;\r\nuint16_t lreq_q_in = 0;\r\nuint16_t lreq_q_out = 0;\r\nlreq_q_in = RD_REG_DWORD(rsp->rsp_q_in);\r\nlreq_q_out = rsp->ring_index;\r\nwhile (lreq_q_in != lreq_q_out) {\r\nlptr = rsp->ring_ptr;\r\nmemcpy_fromio(rsp->rsp_pkt, (void __iomem *)lptr,\r\nsizeof(rsp->rsp_pkt));\r\npkt = (struct sts_entry_fx00 *)rsp->rsp_pkt;\r\nrsp->ring_index++;\r\nlreq_q_out++;\r\nif (rsp->ring_index == rsp->length) {\r\nlreq_q_out = 0;\r\nrsp->ring_index = 0;\r\nrsp->ring_ptr = rsp->ring;\r\n} else {\r\nrsp->ring_ptr++;\r\n}\r\nif (pkt->entry_status != 0 &&\r\npkt->entry_type != IOCTL_IOSB_TYPE_FX00) {\r\nqlafx00_error_entry(vha, rsp,\r\n(struct sts_entry_fx00 *)pkt, pkt->entry_status,\r\npkt->entry_type);\r\ncontinue;\r\n}\r\nswitch (pkt->entry_type) {\r\ncase STATUS_TYPE_FX00:\r\nqlafx00_status_entry(vha, rsp, pkt);\r\nbreak;\r\ncase STATUS_CONT_TYPE_FX00:\r\nqlafx00_status_cont_entry(rsp, (sts_cont_entry_t *)pkt);\r\nbreak;\r\ncase MULTI_STATUS_TYPE_FX00:\r\nqlafx00_multistatus_entry(vha, rsp, pkt);\r\nbreak;\r\ncase ABORT_IOCB_TYPE_FX00:\r\nqlafx00_abort_iocb_entry(vha, rsp->req,\r\n(struct abort_iocb_entry_fx00 *)pkt);\r\nbreak;\r\ncase IOCTL_IOSB_TYPE_FX00:\r\nqlafx00_ioctl_iosb_entry(vha, rsp->req,\r\n(struct ioctl_iocb_entry_fx00 *)pkt);\r\nbreak;\r\ndefault:\r\nql_dbg(ql_dbg_async, vha, 0x5081,\r\n"Received unknown response pkt type %x "\r\n"entry status=%x.\n",\r\npkt->entry_type, pkt->entry_status);\r\nbreak;\r\n}\r\n}\r\nWRT_REG_DWORD(rsp->rsp_q_out, rsp->ring_index);\r\n}\r\nstatic void\r\nqlafx00_async_event(scsi_qla_host_t *vha)\r\n{\r\nstruct qla_hw_data *ha = vha->hw;\r\nstruct device_reg_fx00 __iomem *reg;\r\nint data_size = 1;\r\nreg = &ha->iobase->ispfx00;\r\nswitch (ha->aenmb[0]) {\r\ncase QLAFX00_MBA_SYSTEM_ERR:\r\nql_log(ql_log_warn, vha, 0x5079,\r\n"ISP System Error - mbx1=%x\n", ha->aenmb[0]);\r\nset_bit(ISP_ABORT_NEEDED, &vha->dpc_flags);\r\nbreak;\r\ncase QLAFX00_MBA_SHUTDOWN_RQSTD:\r\nql_dbg(ql_dbg_async, vha, 0x5076,\r\n"Asynchronous FW shutdown requested.\n");\r\nset_bit(ISP_ABORT_NEEDED, &vha->dpc_flags);\r\nqla2xxx_wake_dpc(vha);\r\nbreak;\r\ncase QLAFX00_MBA_PORT_UPDATE:\r\nha->aenmb[1] = RD_REG_DWORD(&reg->aenmailbox1);\r\nha->aenmb[2] = RD_REG_DWORD(&reg->aenmailbox2);\r\nha->aenmb[3] = RD_REG_DWORD(&reg->aenmailbox3);\r\nql_dbg(ql_dbg_async, vha, 0x5077,\r\n"Asynchronous port Update received "\r\n"aenmb[0]: %x, aenmb[1]: %x, aenmb[2]: %x, aenmb[3]: %x\n",\r\nha->aenmb[0], ha->aenmb[1], ha->aenmb[2], ha->aenmb[3]);\r\ndata_size = 4;\r\nbreak;\r\ncase QLAFX00_MBA_TEMP_OVER:\r\nql_log(ql_log_info, vha, 0x5085,\r\n"Asynchronous over temperature event received "\r\n"aenmb[0]: %x\n",\r\nha->aenmb[0]);\r\nbreak;\r\ncase QLAFX00_MBA_TEMP_NORM:\r\nql_log(ql_log_info, vha, 0x5086,\r\n"Asynchronous normal temperature event received "\r\n"aenmb[0]: %x\n",\r\nha->aenmb[0]);\r\nbreak;\r\ncase QLAFX00_MBA_TEMP_CRIT:\r\nql_log(ql_log_info, vha, 0x5083,\r\n"Asynchronous critical temperature event received "\r\n"aenmb[0]: %x\n",\r\nha->aenmb[0]);\r\nbreak;\r\ndefault:\r\nha->aenmb[1] = RD_REG_WORD(&reg->aenmailbox1);\r\nha->aenmb[2] = RD_REG_WORD(&reg->aenmailbox2);\r\nha->aenmb[3] = RD_REG_WORD(&reg->aenmailbox3);\r\nha->aenmb[4] = RD_REG_WORD(&reg->aenmailbox4);\r\nha->aenmb[5] = RD_REG_WORD(&reg->aenmailbox5);\r\nha->aenmb[6] = RD_REG_WORD(&reg->aenmailbox6);\r\nha->aenmb[7] = RD_REG_WORD(&reg->aenmailbox7);\r\nql_dbg(ql_dbg_async, vha, 0x5078,\r\n"AEN:%04x %04x %04x %04x :%04x %04x %04x %04x\n",\r\nha->aenmb[0], ha->aenmb[1], ha->aenmb[2], ha->aenmb[3],\r\nha->aenmb[4], ha->aenmb[5], ha->aenmb[6], ha->aenmb[7]);\r\nbreak;\r\n}\r\nqlafx00_post_aenfx_work(vha, ha->aenmb[0],\r\n(uint32_t *)ha->aenmb, data_size);\r\n}\r\nstatic void\r\nqlafx00_mbx_completion(scsi_qla_host_t *vha, uint32_t mb0)\r\n{\r\nuint16_t cnt;\r\nuint32_t __iomem *wptr;\r\nstruct qla_hw_data *ha = vha->hw;\r\nstruct device_reg_fx00 __iomem *reg = &ha->iobase->ispfx00;\r\nif (!ha->mcp32)\r\nql_dbg(ql_dbg_async, vha, 0x507e, "MBX pointer ERROR.\n");\r\nha->flags.mbox_int = 1;\r\nha->mailbox_out32[0] = mb0;\r\nwptr = (uint32_t __iomem *)&reg->mailbox17;\r\nfor (cnt = 1; cnt < ha->mbx_count; cnt++) {\r\nha->mailbox_out32[cnt] = RD_REG_DWORD(wptr);\r\nwptr++;\r\n}\r\n}\r\nirqreturn_t\r\nqlafx00_intr_handler(int irq, void *dev_id)\r\n{\r\nscsi_qla_host_t *vha;\r\nstruct qla_hw_data *ha;\r\nstruct device_reg_fx00 __iomem *reg;\r\nint status;\r\nunsigned long iter;\r\nuint32_t stat;\r\nuint32_t mb[8];\r\nstruct rsp_que *rsp;\r\nunsigned long flags;\r\nuint32_t clr_intr = 0;\r\nuint32_t intr_stat = 0;\r\nrsp = (struct rsp_que *) dev_id;\r\nif (!rsp) {\r\nql_log(ql_log_info, NULL, 0x507d,\r\n"%s: NULL response queue pointer.\n", __func__);\r\nreturn IRQ_NONE;\r\n}\r\nha = rsp->hw;\r\nreg = &ha->iobase->ispfx00;\r\nstatus = 0;\r\nif (unlikely(pci_channel_offline(ha->pdev)))\r\nreturn IRQ_HANDLED;\r\nspin_lock_irqsave(&ha->hardware_lock, flags);\r\nvha = pci_get_drvdata(ha->pdev);\r\nfor (iter = 50; iter--; clr_intr = 0) {\r\nstat = QLAFX00_RD_INTR_REG(ha);\r\nif (qla2x00_check_reg32_for_disconnect(vha, stat))\r\nbreak;\r\nintr_stat = stat & QLAFX00_HST_INT_STS_BITS;\r\nif (!intr_stat)\r\nbreak;\r\nif (stat & QLAFX00_INTR_MB_CMPLT) {\r\nmb[0] = RD_REG_WORD(&reg->mailbox16);\r\nqlafx00_mbx_completion(vha, mb[0]);\r\nstatus |= MBX_INTERRUPT;\r\nclr_intr |= QLAFX00_INTR_MB_CMPLT;\r\n}\r\nif (intr_stat & QLAFX00_INTR_ASYNC_CMPLT) {\r\nha->aenmb[0] = RD_REG_WORD(&reg->aenmailbox0);\r\nqlafx00_async_event(vha);\r\nclr_intr |= QLAFX00_INTR_ASYNC_CMPLT;\r\n}\r\nif (intr_stat & QLAFX00_INTR_RSP_CMPLT) {\r\nqlafx00_process_response_queue(vha, rsp);\r\nclr_intr |= QLAFX00_INTR_RSP_CMPLT;\r\n}\r\nQLAFX00_CLR_INTR_REG(ha, clr_intr);\r\nQLAFX00_RD_INTR_REG(ha);\r\n}\r\nqla2x00_handle_mbx_completion(ha, status);\r\nspin_unlock_irqrestore(&ha->hardware_lock, flags);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic inline cont_a64_entry_t *\r\nqlafx00_prep_cont_type1_iocb(struct req_que *req,\r\ncont_a64_entry_t *lcont_pkt)\r\n{\r\ncont_a64_entry_t *cont_pkt;\r\nreq->ring_index++;\r\nif (req->ring_index == req->length) {\r\nreq->ring_index = 0;\r\nreq->ring_ptr = req->ring;\r\n} else {\r\nreq->ring_ptr++;\r\n}\r\ncont_pkt = (cont_a64_entry_t *)req->ring_ptr;\r\nlcont_pkt->entry_type = CONTINUE_A64_TYPE_FX00;\r\nreturn cont_pkt;\r\n}\r\nstatic inline void\r\nqlafx00_build_scsi_iocbs(srb_t *sp, struct cmd_type_7_fx00 *cmd_pkt,\r\nuint16_t tot_dsds, struct cmd_type_7_fx00 *lcmd_pkt)\r\n{\r\nuint16_t avail_dsds;\r\n__le32 *cur_dsd;\r\nscsi_qla_host_t *vha;\r\nstruct scsi_cmnd *cmd;\r\nstruct scatterlist *sg;\r\nint i, cont;\r\nstruct req_que *req;\r\ncont_a64_entry_t lcont_pkt;\r\ncont_a64_entry_t *cont_pkt;\r\nvha = sp->fcport->vha;\r\nreq = vha->req;\r\ncmd = GET_CMD_SP(sp);\r\ncont = 0;\r\ncont_pkt = NULL;\r\nlcmd_pkt->entry_type = FX00_COMMAND_TYPE_7;\r\nif (!scsi_bufflen(cmd) || cmd->sc_data_direction == DMA_NONE) {\r\nlcmd_pkt->byte_count = __constant_cpu_to_le32(0);\r\nreturn;\r\n}\r\nif (cmd->sc_data_direction == DMA_TO_DEVICE) {\r\nlcmd_pkt->cntrl_flags = TMF_WRITE_DATA;\r\nvha->qla_stats.output_bytes += scsi_bufflen(cmd);\r\n} else if (cmd->sc_data_direction == DMA_FROM_DEVICE) {\r\nlcmd_pkt->cntrl_flags = TMF_READ_DATA;\r\nvha->qla_stats.input_bytes += scsi_bufflen(cmd);\r\n}\r\navail_dsds = 1;\r\ncur_dsd = (__le32 *)&lcmd_pkt->dseg_0_address;\r\nscsi_for_each_sg(cmd, sg, tot_dsds, i) {\r\ndma_addr_t sle_dma;\r\nif (avail_dsds == 0) {\r\nmemset(&lcont_pkt, 0, REQUEST_ENTRY_SIZE);\r\ncont_pkt =\r\nqlafx00_prep_cont_type1_iocb(req, &lcont_pkt);\r\ncur_dsd = (__le32 *)lcont_pkt.dseg_0_address;\r\navail_dsds = 5;\r\ncont = 1;\r\n}\r\nsle_dma = sg_dma_address(sg);\r\n*cur_dsd++ = cpu_to_le32(LSD(sle_dma));\r\n*cur_dsd++ = cpu_to_le32(MSD(sle_dma));\r\n*cur_dsd++ = cpu_to_le32(sg_dma_len(sg));\r\navail_dsds--;\r\nif (avail_dsds == 0 && cont == 1) {\r\ncont = 0;\r\nmemcpy_toio((void __iomem *)cont_pkt, &lcont_pkt,\r\nREQUEST_ENTRY_SIZE);\r\n}\r\n}\r\nif (avail_dsds != 0 && cont == 1) {\r\nmemcpy_toio((void __iomem *)cont_pkt, &lcont_pkt,\r\nREQUEST_ENTRY_SIZE);\r\n}\r\n}\r\nint\r\nqlafx00_start_scsi(srb_t *sp)\r\n{\r\nint ret, nseg;\r\nunsigned long flags;\r\nuint32_t index;\r\nuint32_t handle;\r\nuint16_t cnt;\r\nuint16_t req_cnt;\r\nuint16_t tot_dsds;\r\nstruct req_que *req = NULL;\r\nstruct rsp_que *rsp = NULL;\r\nstruct scsi_cmnd *cmd = GET_CMD_SP(sp);\r\nstruct scsi_qla_host *vha = sp->fcport->vha;\r\nstruct qla_hw_data *ha = vha->hw;\r\nstruct cmd_type_7_fx00 *cmd_pkt;\r\nstruct cmd_type_7_fx00 lcmd_pkt;\r\nstruct scsi_lun llun;\r\nret = 0;\r\nrsp = ha->rsp_q_map[0];\r\nreq = vha->req;\r\ntot_dsds = 0;\r\nspin_lock_irqsave(&ha->hardware_lock, flags);\r\nhandle = req->current_outstanding_cmd;\r\nfor (index = 1; index < req->num_outstanding_cmds; index++) {\r\nhandle++;\r\nif (handle == req->num_outstanding_cmds)\r\nhandle = 1;\r\nif (!req->outstanding_cmds[handle])\r\nbreak;\r\n}\r\nif (index == req->num_outstanding_cmds)\r\ngoto queuing_error;\r\nif (scsi_sg_count(cmd)) {\r\nnseg = dma_map_sg(&ha->pdev->dev, scsi_sglist(cmd),\r\nscsi_sg_count(cmd), cmd->sc_data_direction);\r\nif (unlikely(!nseg))\r\ngoto queuing_error;\r\n} else\r\nnseg = 0;\r\ntot_dsds = nseg;\r\nreq_cnt = qla24xx_calc_iocbs(vha, tot_dsds);\r\nif (req->cnt < (req_cnt + 2)) {\r\ncnt = RD_REG_DWORD_RELAXED(req->req_q_out);\r\nif (req->ring_index < cnt)\r\nreq->cnt = cnt - req->ring_index;\r\nelse\r\nreq->cnt = req->length -\r\n(req->ring_index - cnt);\r\nif (req->cnt < (req_cnt + 2))\r\ngoto queuing_error;\r\n}\r\nreq->current_outstanding_cmd = handle;\r\nreq->outstanding_cmds[handle] = sp;\r\nsp->handle = handle;\r\ncmd->host_scribble = (unsigned char *)(unsigned long)handle;\r\nreq->cnt -= req_cnt;\r\ncmd_pkt = (struct cmd_type_7_fx00 *)req->ring_ptr;\r\nmemset(&lcmd_pkt, 0, REQUEST_ENTRY_SIZE);\r\nlcmd_pkt.handle = MAKE_HANDLE(req->id, sp->handle);\r\nlcmd_pkt.reserved_0 = 0;\r\nlcmd_pkt.port_path_ctrl = 0;\r\nlcmd_pkt.reserved_1 = 0;\r\nlcmd_pkt.dseg_count = cpu_to_le16(tot_dsds);\r\nlcmd_pkt.tgt_idx = cpu_to_le16(sp->fcport->tgt_id);\r\nint_to_scsilun(cmd->device->lun, &llun);\r\nhost_to_adap((uint8_t *)&llun, (uint8_t *)&lcmd_pkt.lun,\r\nsizeof(lcmd_pkt.lun));\r\nhost_to_adap(cmd->cmnd, lcmd_pkt.fcp_cdb, sizeof(lcmd_pkt.fcp_cdb));\r\nlcmd_pkt.byte_count = cpu_to_le32((uint32_t)scsi_bufflen(cmd));\r\nqlafx00_build_scsi_iocbs(sp, cmd_pkt, tot_dsds, &lcmd_pkt);\r\nlcmd_pkt.entry_count = (uint8_t)req_cnt;\r\nlcmd_pkt.entry_status = (uint8_t) rsp->id;\r\nql_dump_buffer(ql_dbg_io + ql_dbg_buffer, vha, 0x302e,\r\n(uint8_t *)cmd->cmnd, cmd->cmd_len);\r\nql_dump_buffer(ql_dbg_io + ql_dbg_buffer, vha, 0x3032,\r\n(uint8_t *)&lcmd_pkt, REQUEST_ENTRY_SIZE);\r\nmemcpy_toio((void __iomem *)cmd_pkt, &lcmd_pkt, REQUEST_ENTRY_SIZE);\r\nwmb();\r\nreq->ring_index++;\r\nif (req->ring_index == req->length) {\r\nreq->ring_index = 0;\r\nreq->ring_ptr = req->ring;\r\n} else\r\nreq->ring_ptr++;\r\nsp->flags |= SRB_DMA_VALID;\r\nWRT_REG_DWORD(req->req_q_in, req->ring_index);\r\nQLAFX00_SET_HST_INTR(ha, ha->rqstq_intr_code);\r\nspin_unlock_irqrestore(&ha->hardware_lock, flags);\r\nreturn QLA_SUCCESS;\r\nqueuing_error:\r\nif (tot_dsds)\r\nscsi_dma_unmap(cmd);\r\nspin_unlock_irqrestore(&ha->hardware_lock, flags);\r\nreturn QLA_FUNCTION_FAILED;\r\n}\r\nvoid\r\nqlafx00_tm_iocb(srb_t *sp, struct tsk_mgmt_entry_fx00 *ptm_iocb)\r\n{\r\nstruct srb_iocb *fxio = &sp->u.iocb_cmd;\r\nscsi_qla_host_t *vha = sp->fcport->vha;\r\nstruct req_que *req = vha->req;\r\nstruct tsk_mgmt_entry_fx00 tm_iocb;\r\nstruct scsi_lun llun;\r\nmemset(&tm_iocb, 0, sizeof(struct tsk_mgmt_entry_fx00));\r\ntm_iocb.entry_type = TSK_MGMT_IOCB_TYPE_FX00;\r\ntm_iocb.entry_count = 1;\r\ntm_iocb.handle = cpu_to_le32(MAKE_HANDLE(req->id, sp->handle));\r\ntm_iocb.reserved_0 = 0;\r\ntm_iocb.tgt_id = cpu_to_le16(sp->fcport->tgt_id);\r\ntm_iocb.control_flags = cpu_to_le32(fxio->u.tmf.flags);\r\nif (tm_iocb.control_flags == cpu_to_le32((uint32_t)TCF_LUN_RESET)) {\r\nint_to_scsilun(fxio->u.tmf.lun, &llun);\r\nhost_to_adap((uint8_t *)&llun, (uint8_t *)&tm_iocb.lun,\r\nsizeof(struct scsi_lun));\r\n}\r\nmemcpy((void *)ptm_iocb, &tm_iocb,\r\nsizeof(struct tsk_mgmt_entry_fx00));\r\nwmb();\r\n}\r\nvoid\r\nqlafx00_abort_iocb(srb_t *sp, struct abort_iocb_entry_fx00 *pabt_iocb)\r\n{\r\nstruct srb_iocb *fxio = &sp->u.iocb_cmd;\r\nscsi_qla_host_t *vha = sp->fcport->vha;\r\nstruct req_que *req = vha->req;\r\nstruct abort_iocb_entry_fx00 abt_iocb;\r\nmemset(&abt_iocb, 0, sizeof(struct abort_iocb_entry_fx00));\r\nabt_iocb.entry_type = ABORT_IOCB_TYPE_FX00;\r\nabt_iocb.entry_count = 1;\r\nabt_iocb.handle = cpu_to_le32(MAKE_HANDLE(req->id, sp->handle));\r\nabt_iocb.abort_handle =\r\ncpu_to_le32(MAKE_HANDLE(req->id, fxio->u.abt.cmd_hndl));\r\nabt_iocb.tgt_id_sts = cpu_to_le16(sp->fcport->tgt_id);\r\nabt_iocb.req_que_no = cpu_to_le16(req->id);\r\nmemcpy((void *)pabt_iocb, &abt_iocb,\r\nsizeof(struct abort_iocb_entry_fx00));\r\nwmb();\r\n}\r\nvoid\r\nqlafx00_fxdisc_iocb(srb_t *sp, struct fxdisc_entry_fx00 *pfxiocb)\r\n{\r\nstruct srb_iocb *fxio = &sp->u.iocb_cmd;\r\nstruct qla_mt_iocb_rqst_fx00 *piocb_rqst;\r\nstruct fc_bsg_job *bsg_job;\r\nstruct fxdisc_entry_fx00 fx_iocb;\r\nuint8_t entry_cnt = 1;\r\nmemset(&fx_iocb, 0, sizeof(struct fxdisc_entry_fx00));\r\nfx_iocb.entry_type = FX00_IOCB_TYPE;\r\nfx_iocb.handle = cpu_to_le32(sp->handle);\r\nfx_iocb.entry_count = entry_cnt;\r\nif (sp->type == SRB_FXIOCB_DCMD) {\r\nfx_iocb.func_num =\r\nsp->u.iocb_cmd.u.fxiocb.req_func_type;\r\nfx_iocb.adapid = fxio->u.fxiocb.adapter_id;\r\nfx_iocb.adapid_hi = fxio->u.fxiocb.adapter_id_hi;\r\nfx_iocb.reserved_0 = fxio->u.fxiocb.reserved_0;\r\nfx_iocb.reserved_1 = fxio->u.fxiocb.reserved_1;\r\nfx_iocb.dataword_extra = fxio->u.fxiocb.req_data_extra;\r\nif (fxio->u.fxiocb.flags & SRB_FXDISC_REQ_DMA_VALID) {\r\nfx_iocb.req_dsdcnt = cpu_to_le16(1);\r\nfx_iocb.req_xfrcnt =\r\ncpu_to_le16(fxio->u.fxiocb.req_len);\r\nfx_iocb.dseg_rq_address[0] =\r\ncpu_to_le32(LSD(fxio->u.fxiocb.req_dma_handle));\r\nfx_iocb.dseg_rq_address[1] =\r\ncpu_to_le32(MSD(fxio->u.fxiocb.req_dma_handle));\r\nfx_iocb.dseg_rq_len =\r\ncpu_to_le32(fxio->u.fxiocb.req_len);\r\n}\r\nif (fxio->u.fxiocb.flags & SRB_FXDISC_RESP_DMA_VALID) {\r\nfx_iocb.rsp_dsdcnt = cpu_to_le16(1);\r\nfx_iocb.rsp_xfrcnt =\r\ncpu_to_le16(fxio->u.fxiocb.rsp_len);\r\nfx_iocb.dseg_rsp_address[0] =\r\ncpu_to_le32(LSD(fxio->u.fxiocb.rsp_dma_handle));\r\nfx_iocb.dseg_rsp_address[1] =\r\ncpu_to_le32(MSD(fxio->u.fxiocb.rsp_dma_handle));\r\nfx_iocb.dseg_rsp_len =\r\ncpu_to_le32(fxio->u.fxiocb.rsp_len);\r\n}\r\nif (fxio->u.fxiocb.flags & SRB_FXDISC_REQ_DWRD_VALID) {\r\nfx_iocb.dataword = fxio->u.fxiocb.req_data;\r\n}\r\nfx_iocb.flags = fxio->u.fxiocb.flags;\r\n} else {\r\nstruct scatterlist *sg;\r\nbsg_job = sp->u.bsg_job;\r\npiocb_rqst = (struct qla_mt_iocb_rqst_fx00 *)\r\n&bsg_job->request->rqst_data.h_vendor.vendor_cmd[1];\r\nfx_iocb.func_num = piocb_rqst->func_type;\r\nfx_iocb.adapid = piocb_rqst->adapid;\r\nfx_iocb.adapid_hi = piocb_rqst->adapid_hi;\r\nfx_iocb.reserved_0 = piocb_rqst->reserved_0;\r\nfx_iocb.reserved_1 = piocb_rqst->reserved_1;\r\nfx_iocb.dataword_extra = piocb_rqst->dataword_extra;\r\nfx_iocb.dataword = piocb_rqst->dataword;\r\nfx_iocb.req_xfrcnt = piocb_rqst->req_len;\r\nfx_iocb.rsp_xfrcnt = piocb_rqst->rsp_len;\r\nif (piocb_rqst->flags & SRB_FXDISC_REQ_DMA_VALID) {\r\nint avail_dsds, tot_dsds;\r\ncont_a64_entry_t lcont_pkt;\r\ncont_a64_entry_t *cont_pkt = NULL;\r\n__le32 *cur_dsd;\r\nint index = 0, cont = 0;\r\nfx_iocb.req_dsdcnt =\r\ncpu_to_le16(bsg_job->request_payload.sg_cnt);\r\ntot_dsds =\r\nbsg_job->request_payload.sg_cnt;\r\ncur_dsd = (__le32 *)&fx_iocb.dseg_rq_address[0];\r\navail_dsds = 1;\r\nfor_each_sg(bsg_job->request_payload.sg_list, sg,\r\ntot_dsds, index) {\r\ndma_addr_t sle_dma;\r\nif (avail_dsds == 0) {\r\nmemset(&lcont_pkt, 0,\r\nREQUEST_ENTRY_SIZE);\r\ncont_pkt =\r\nqlafx00_prep_cont_type1_iocb(\r\nsp->fcport->vha->req,\r\n&lcont_pkt);\r\ncur_dsd = (__le32 *)\r\nlcont_pkt.dseg_0_address;\r\navail_dsds = 5;\r\ncont = 1;\r\nentry_cnt++;\r\n}\r\nsle_dma = sg_dma_address(sg);\r\n*cur_dsd++ = cpu_to_le32(LSD(sle_dma));\r\n*cur_dsd++ = cpu_to_le32(MSD(sle_dma));\r\n*cur_dsd++ = cpu_to_le32(sg_dma_len(sg));\r\navail_dsds--;\r\nif (avail_dsds == 0 && cont == 1) {\r\ncont = 0;\r\nmemcpy_toio(\r\n(void __iomem *)cont_pkt,\r\n&lcont_pkt, REQUEST_ENTRY_SIZE);\r\nql_dump_buffer(\r\nql_dbg_user + ql_dbg_verbose,\r\nsp->fcport->vha, 0x3042,\r\n(uint8_t *)&lcont_pkt,\r\nREQUEST_ENTRY_SIZE);\r\n}\r\n}\r\nif (avail_dsds != 0 && cont == 1) {\r\nmemcpy_toio((void __iomem *)cont_pkt,\r\n&lcont_pkt, REQUEST_ENTRY_SIZE);\r\nql_dump_buffer(ql_dbg_user + ql_dbg_verbose,\r\nsp->fcport->vha, 0x3043,\r\n(uint8_t *)&lcont_pkt, REQUEST_ENTRY_SIZE);\r\n}\r\n}\r\nif (piocb_rqst->flags & SRB_FXDISC_RESP_DMA_VALID) {\r\nint avail_dsds, tot_dsds;\r\ncont_a64_entry_t lcont_pkt;\r\ncont_a64_entry_t *cont_pkt = NULL;\r\n__le32 *cur_dsd;\r\nint index = 0, cont = 0;\r\nfx_iocb.rsp_dsdcnt =\r\ncpu_to_le16(bsg_job->reply_payload.sg_cnt);\r\ntot_dsds = bsg_job->reply_payload.sg_cnt;\r\ncur_dsd = (__le32 *)&fx_iocb.dseg_rsp_address[0];\r\navail_dsds = 1;\r\nfor_each_sg(bsg_job->reply_payload.sg_list, sg,\r\ntot_dsds, index) {\r\ndma_addr_t sle_dma;\r\nif (avail_dsds == 0) {\r\nmemset(&lcont_pkt, 0,\r\nREQUEST_ENTRY_SIZE);\r\ncont_pkt =\r\nqlafx00_prep_cont_type1_iocb(\r\nsp->fcport->vha->req,\r\n&lcont_pkt);\r\ncur_dsd = (__le32 *)\r\nlcont_pkt.dseg_0_address;\r\navail_dsds = 5;\r\ncont = 1;\r\nentry_cnt++;\r\n}\r\nsle_dma = sg_dma_address(sg);\r\n*cur_dsd++ = cpu_to_le32(LSD(sle_dma));\r\n*cur_dsd++ = cpu_to_le32(MSD(sle_dma));\r\n*cur_dsd++ = cpu_to_le32(sg_dma_len(sg));\r\navail_dsds--;\r\nif (avail_dsds == 0 && cont == 1) {\r\ncont = 0;\r\nmemcpy_toio((void __iomem *)cont_pkt,\r\n&lcont_pkt,\r\nREQUEST_ENTRY_SIZE);\r\nql_dump_buffer(\r\nql_dbg_user + ql_dbg_verbose,\r\nsp->fcport->vha, 0x3045,\r\n(uint8_t *)&lcont_pkt,\r\nREQUEST_ENTRY_SIZE);\r\n}\r\n}\r\nif (avail_dsds != 0 && cont == 1) {\r\nmemcpy_toio((void __iomem *)cont_pkt,\r\n&lcont_pkt, REQUEST_ENTRY_SIZE);\r\nql_dump_buffer(ql_dbg_user + ql_dbg_verbose,\r\nsp->fcport->vha, 0x3046,\r\n(uint8_t *)&lcont_pkt, REQUEST_ENTRY_SIZE);\r\n}\r\n}\r\nif (piocb_rqst->flags & SRB_FXDISC_REQ_DWRD_VALID)\r\nfx_iocb.dataword = piocb_rqst->dataword;\r\nfx_iocb.flags = piocb_rqst->flags;\r\nfx_iocb.entry_count = entry_cnt;\r\n}\r\nql_dump_buffer(ql_dbg_user + ql_dbg_verbose,\r\nsp->fcport->vha, 0x3047,\r\n(uint8_t *)&fx_iocb, sizeof(struct fxdisc_entry_fx00));\r\nmemcpy_toio((void __iomem *)pfxiocb, &fx_iocb,\r\nsizeof(struct fxdisc_entry_fx00));\r\nwmb();\r\n}
