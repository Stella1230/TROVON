static int xen_acpi_pad_idle_cpus(unsigned int idle_nums)\r\n{\r\nstruct xen_platform_op op;\r\nop.cmd = XENPF_core_parking;\r\nop.u.core_parking.type = XEN_CORE_PARKING_SET;\r\nop.u.core_parking.idle_nums = idle_nums;\r\nreturn HYPERVISOR_dom0_op(&op);\r\n}\r\nstatic int xen_acpi_pad_idle_cpus_num(void)\r\n{\r\nstruct xen_platform_op op;\r\nop.cmd = XENPF_core_parking;\r\nop.u.core_parking.type = XEN_CORE_PARKING_GET;\r\nreturn HYPERVISOR_dom0_op(&op)\r\n?: op.u.core_parking.idle_nums;\r\n}\r\nstatic int acpi_pad_pur(acpi_handle handle)\r\n{\r\nstruct acpi_buffer buffer = {ACPI_ALLOCATE_BUFFER, NULL};\r\nunion acpi_object *package;\r\nint num = -1;\r\nif (ACPI_FAILURE(acpi_evaluate_object(handle, "_PUR", NULL, &buffer)))\r\nreturn num;\r\nif (!buffer.length || !buffer.pointer)\r\nreturn num;\r\npackage = buffer.pointer;\r\nif (package->type == ACPI_TYPE_PACKAGE &&\r\npackage->package.count == 2 &&\r\npackage->package.elements[0].integer.value == 1)\r\nnum = package->package.elements[1].integer.value;\r\nkfree(buffer.pointer);\r\nreturn num;\r\n}\r\nstatic void acpi_pad_handle_notify(acpi_handle handle)\r\n{\r\nint idle_nums;\r\nstruct acpi_buffer param = {\r\n.length = 4,\r\n.pointer = (void *)&idle_nums,\r\n};\r\nmutex_lock(&xen_cpu_lock);\r\nidle_nums = acpi_pad_pur(handle);\r\nif (idle_nums < 0) {\r\nmutex_unlock(&xen_cpu_lock);\r\nreturn;\r\n}\r\nidle_nums = xen_acpi_pad_idle_cpus(idle_nums)\r\n?: xen_acpi_pad_idle_cpus_num();\r\nif (idle_nums >= 0)\r\nacpi_evaluate_ost(handle, ACPI_PROCESSOR_AGGREGATOR_NOTIFY,\r\n0, &param);\r\nmutex_unlock(&xen_cpu_lock);\r\n}\r\nstatic void acpi_pad_notify(acpi_handle handle, u32 event,\r\nvoid *data)\r\n{\r\nswitch (event) {\r\ncase ACPI_PROCESSOR_AGGREGATOR_NOTIFY:\r\nacpi_pad_handle_notify(handle);\r\nbreak;\r\ndefault:\r\npr_warn("Unsupported event [0x%x]\n", event);\r\nbreak;\r\n}\r\n}\r\nstatic int acpi_pad_add(struct acpi_device *device)\r\n{\r\nacpi_status status;\r\nstrcpy(acpi_device_name(device), ACPI_PROCESSOR_AGGREGATOR_DEVICE_NAME);\r\nstrcpy(acpi_device_class(device), ACPI_PROCESSOR_AGGREGATOR_CLASS);\r\nstatus = acpi_install_notify_handler(device->handle,\r\nACPI_DEVICE_NOTIFY, acpi_pad_notify, device);\r\nif (ACPI_FAILURE(status))\r\nreturn -ENODEV;\r\nreturn 0;\r\n}\r\nstatic int acpi_pad_remove(struct acpi_device *device)\r\n{\r\nmutex_lock(&xen_cpu_lock);\r\nxen_acpi_pad_idle_cpus(0);\r\nmutex_unlock(&xen_cpu_lock);\r\nacpi_remove_notify_handler(device->handle,\r\nACPI_DEVICE_NOTIFY, acpi_pad_notify);\r\nreturn 0;\r\n}\r\nstatic int __init xen_acpi_pad_init(void)\r\n{\r\nif (!xen_initial_domain())\r\nreturn -ENODEV;\r\nif (!xen_running_on_version_or_later(4, 2))\r\nreturn -ENODEV;\r\nreturn acpi_bus_register_driver(&acpi_pad_driver);\r\n}
