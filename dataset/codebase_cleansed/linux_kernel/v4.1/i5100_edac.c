static inline u32 i5100_mc_scrben(u32 mc)\r\n{\r\nreturn mc >> 7 & 1;\r\n}\r\nstatic inline u32 i5100_mc_errdeten(u32 mc)\r\n{\r\nreturn mc >> 5 & 1;\r\n}\r\nstatic inline u32 i5100_mc_scrbdone(u32 mc)\r\n{\r\nreturn mc >> 4 & 1;\r\n}\r\nstatic inline u16 i5100_spddata_rdo(u16 a)\r\n{\r\nreturn a >> 15 & 1;\r\n}\r\nstatic inline u16 i5100_spddata_sbe(u16 a)\r\n{\r\nreturn a >> 13 & 1;\r\n}\r\nstatic inline u16 i5100_spddata_busy(u16 a)\r\n{\r\nreturn a >> 12 & 1;\r\n}\r\nstatic inline u16 i5100_spddata_data(u16 a)\r\n{\r\nreturn a & ((1 << 8) - 1);\r\n}\r\nstatic inline u32 i5100_spdcmd_create(u32 dti, u32 ckovrd, u32 sa, u32 ba,\r\nu32 data, u32 cmd)\r\n{\r\nreturn ((dti & ((1 << 4) - 1)) << 28) |\r\n((ckovrd & 1) << 27) |\r\n((sa & ((1 << 3) - 1)) << 24) |\r\n((ba & ((1 << 8) - 1)) << 16) |\r\n((data & ((1 << 8) - 1)) << 8) |\r\n(cmd & 1);\r\n}\r\nstatic inline u16 i5100_tolm_tolm(u16 a)\r\n{\r\nreturn a >> 12 & ((1 << 4) - 1);\r\n}\r\nstatic inline u16 i5100_mir_limit(u16 a)\r\n{\r\nreturn a >> 4 & ((1 << 12) - 1);\r\n}\r\nstatic inline u16 i5100_mir_way1(u16 a)\r\n{\r\nreturn a >> 1 & 1;\r\n}\r\nstatic inline u16 i5100_mir_way0(u16 a)\r\n{\r\nreturn a & 1;\r\n}\r\nstatic inline u32 i5100_ferr_nf_mem_chan_indx(u32 a)\r\n{\r\nreturn a >> 28 & 1;\r\n}\r\nstatic inline u32 i5100_ferr_nf_mem_any(u32 a)\r\n{\r\nreturn a & I5100_FERR_NF_MEM_ANY_MASK;\r\n}\r\nstatic inline u32 i5100_nerr_nf_mem_any(u32 a)\r\n{\r\nreturn i5100_ferr_nf_mem_any(a);\r\n}\r\nstatic inline u32 i5100_dmir_limit(u32 a)\r\n{\r\nreturn a >> 16 & ((1 << 11) - 1);\r\n}\r\nstatic inline u32 i5100_dmir_rank(u32 a, u32 i)\r\n{\r\nreturn a >> (4 * i) & ((1 << 2) - 1);\r\n}\r\nstatic inline u16 i5100_mtr_present(u16 a)\r\n{\r\nreturn a >> 10 & 1;\r\n}\r\nstatic inline u16 i5100_mtr_ethrottle(u16 a)\r\n{\r\nreturn a >> 9 & 1;\r\n}\r\nstatic inline u16 i5100_mtr_width(u16 a)\r\n{\r\nreturn a >> 8 & 1;\r\n}\r\nstatic inline u16 i5100_mtr_numbank(u16 a)\r\n{\r\nreturn a >> 6 & 1;\r\n}\r\nstatic inline u16 i5100_mtr_numrow(u16 a)\r\n{\r\nreturn a >> 2 & ((1 << 2) - 1);\r\n}\r\nstatic inline u16 i5100_mtr_numcol(u16 a)\r\n{\r\nreturn a & ((1 << 2) - 1);\r\n}\r\nstatic inline u32 i5100_validlog_redmemvalid(u32 a)\r\n{\r\nreturn a >> 2 & 1;\r\n}\r\nstatic inline u32 i5100_validlog_recmemvalid(u32 a)\r\n{\r\nreturn a >> 1 & 1;\r\n}\r\nstatic inline u32 i5100_validlog_nrecmemvalid(u32 a)\r\n{\r\nreturn a & 1;\r\n}\r\nstatic inline u32 i5100_nrecmema_merr(u32 a)\r\n{\r\nreturn a >> 15 & ((1 << 5) - 1);\r\n}\r\nstatic inline u32 i5100_nrecmema_bank(u32 a)\r\n{\r\nreturn a >> 12 & ((1 << 3) - 1);\r\n}\r\nstatic inline u32 i5100_nrecmema_rank(u32 a)\r\n{\r\nreturn a >> 8 & ((1 << 3) - 1);\r\n}\r\nstatic inline u32 i5100_nrecmema_dm_buf_id(u32 a)\r\n{\r\nreturn a & ((1 << 8) - 1);\r\n}\r\nstatic inline u32 i5100_nrecmemb_cas(u32 a)\r\n{\r\nreturn a >> 16 & ((1 << 13) - 1);\r\n}\r\nstatic inline u32 i5100_nrecmemb_ras(u32 a)\r\n{\r\nreturn a & ((1 << 16) - 1);\r\n}\r\nstatic inline u32 i5100_redmemb_ecc_locator(u32 a)\r\n{\r\nreturn a & ((1 << 18) - 1);\r\n}\r\nstatic inline u32 i5100_recmema_merr(u32 a)\r\n{\r\nreturn i5100_nrecmema_merr(a);\r\n}\r\nstatic inline u32 i5100_recmema_bank(u32 a)\r\n{\r\nreturn i5100_nrecmema_bank(a);\r\n}\r\nstatic inline u32 i5100_recmema_rank(u32 a)\r\n{\r\nreturn i5100_nrecmema_rank(a);\r\n}\r\nstatic inline u32 i5100_recmemb_cas(u32 a)\r\n{\r\nreturn i5100_nrecmemb_cas(a);\r\n}\r\nstatic inline u32 i5100_recmemb_ras(u32 a)\r\n{\r\nreturn i5100_nrecmemb_ras(a);\r\n}\r\nstatic int i5100_rank_to_slot(const struct mem_ctl_info *mci,\r\nint chan, int rank)\r\n{\r\nconst struct i5100_priv *priv = mci->pvt_info;\r\nint i;\r\nfor (i = 0; i < I5100_MAX_DIMM_SLOTS_PER_CHAN; i++) {\r\nint j;\r\nconst int numrank = priv->dimm_numrank[chan][i];\r\nfor (j = 0; j < numrank; j++)\r\nif (priv->dimm_csmap[i][j] == rank)\r\nreturn i * 2 + chan;\r\n}\r\nreturn -1;\r\n}\r\nstatic const char *i5100_err_msg(unsigned err)\r\n{\r\nstatic const char *merrs[] = {\r\n"unknown",\r\n"uncorrectable data ECC on replay",\r\n"unknown",\r\n"unknown",\r\n"aliased uncorrectable demand data ECC",\r\n"aliased uncorrectable spare-copy data ECC",\r\n"aliased uncorrectable patrol data ECC",\r\n"unknown",\r\n"unknown",\r\n"unknown",\r\n"non-aliased uncorrectable demand data ECC",\r\n"non-aliased uncorrectable spare-copy data ECC",\r\n"non-aliased uncorrectable patrol data ECC",\r\n"unknown",\r\n"correctable demand data ECC",\r\n"correctable spare-copy data ECC",\r\n"correctable patrol data ECC",\r\n"unknown",\r\n"SPD protocol error",\r\n"unknown",\r\n"spare copy initiated",\r\n"spare copy completed",\r\n};\r\nunsigned i;\r\nfor (i = 0; i < ARRAY_SIZE(merrs); i++)\r\nif (1 << i & err)\r\nreturn merrs[i];\r\nreturn "none";\r\n}\r\nstatic int i5100_csrow_to_rank(const struct mem_ctl_info *mci, int csrow)\r\n{\r\nconst struct i5100_priv *priv = mci->pvt_info;\r\nreturn csrow % priv->ranksperchan;\r\n}\r\nstatic int i5100_csrow_to_chan(const struct mem_ctl_info *mci, int csrow)\r\n{\r\nconst struct i5100_priv *priv = mci->pvt_info;\r\nreturn csrow / priv->ranksperchan;\r\n}\r\nstatic void i5100_handle_ce(struct mem_ctl_info *mci,\r\nint chan,\r\nunsigned bank,\r\nunsigned rank,\r\nunsigned long syndrome,\r\nunsigned cas,\r\nunsigned ras,\r\nconst char *msg)\r\n{\r\nchar detail[80];\r\nsnprintf(detail, sizeof(detail),\r\n"bank %u, cas %u, ras %u\n",\r\nbank, cas, ras);\r\nedac_mc_handle_error(HW_EVENT_ERR_CORRECTED, mci, 1,\r\n0, 0, syndrome,\r\nchan, rank, -1,\r\nmsg, detail);\r\n}\r\nstatic void i5100_handle_ue(struct mem_ctl_info *mci,\r\nint chan,\r\nunsigned bank,\r\nunsigned rank,\r\nunsigned long syndrome,\r\nunsigned cas,\r\nunsigned ras,\r\nconst char *msg)\r\n{\r\nchar detail[80];\r\nsnprintf(detail, sizeof(detail),\r\n"bank %u, cas %u, ras %u\n",\r\nbank, cas, ras);\r\nedac_mc_handle_error(HW_EVENT_ERR_UNCORRECTED, mci, 1,\r\n0, 0, syndrome,\r\nchan, rank, -1,\r\nmsg, detail);\r\n}\r\nstatic void i5100_read_log(struct mem_ctl_info *mci, int chan,\r\nu32 ferr, u32 nerr)\r\n{\r\nstruct i5100_priv *priv = mci->pvt_info;\r\nstruct pci_dev *pdev = (chan) ? priv->ch1mm : priv->ch0mm;\r\nu32 dw;\r\nu32 dw2;\r\nunsigned syndrome = 0;\r\nunsigned ecc_loc = 0;\r\nunsigned merr;\r\nunsigned bank;\r\nunsigned rank;\r\nunsigned cas;\r\nunsigned ras;\r\npci_read_config_dword(pdev, I5100_VALIDLOG, &dw);\r\nif (i5100_validlog_redmemvalid(dw)) {\r\npci_read_config_dword(pdev, I5100_REDMEMA, &dw2);\r\nsyndrome = dw2;\r\npci_read_config_dword(pdev, I5100_REDMEMB, &dw2);\r\necc_loc = i5100_redmemb_ecc_locator(dw2);\r\n}\r\nif (i5100_validlog_recmemvalid(dw)) {\r\nconst char *msg;\r\npci_read_config_dword(pdev, I5100_RECMEMA, &dw2);\r\nmerr = i5100_recmema_merr(dw2);\r\nbank = i5100_recmema_bank(dw2);\r\nrank = i5100_recmema_rank(dw2);\r\npci_read_config_dword(pdev, I5100_RECMEMB, &dw2);\r\ncas = i5100_recmemb_cas(dw2);\r\nras = i5100_recmemb_ras(dw2);\r\nif (!merr)\r\nmsg = i5100_err_msg(ferr);\r\nelse\r\nmsg = i5100_err_msg(nerr);\r\ni5100_handle_ce(mci, chan, bank, rank, syndrome, cas, ras, msg);\r\n}\r\nif (i5100_validlog_nrecmemvalid(dw)) {\r\nconst char *msg;\r\npci_read_config_dword(pdev, I5100_NRECMEMA, &dw2);\r\nmerr = i5100_nrecmema_merr(dw2);\r\nbank = i5100_nrecmema_bank(dw2);\r\nrank = i5100_nrecmema_rank(dw2);\r\npci_read_config_dword(pdev, I5100_NRECMEMB, &dw2);\r\ncas = i5100_nrecmemb_cas(dw2);\r\nras = i5100_nrecmemb_ras(dw2);\r\nif (!merr)\r\nmsg = i5100_err_msg(ferr);\r\nelse\r\nmsg = i5100_err_msg(nerr);\r\ni5100_handle_ue(mci, chan, bank, rank, syndrome, cas, ras, msg);\r\n}\r\npci_write_config_dword(pdev, I5100_VALIDLOG, dw);\r\n}\r\nstatic void i5100_check_error(struct mem_ctl_info *mci)\r\n{\r\nstruct i5100_priv *priv = mci->pvt_info;\r\nu32 dw, dw2;\r\npci_read_config_dword(priv->mc, I5100_FERR_NF_MEM, &dw);\r\nif (i5100_ferr_nf_mem_any(dw)) {\r\npci_read_config_dword(priv->mc, I5100_NERR_NF_MEM, &dw2);\r\ni5100_read_log(mci, i5100_ferr_nf_mem_chan_indx(dw),\r\ni5100_ferr_nf_mem_any(dw),\r\ni5100_nerr_nf_mem_any(dw2));\r\npci_write_config_dword(priv->mc, I5100_NERR_NF_MEM, dw2);\r\n}\r\npci_write_config_dword(priv->mc, I5100_FERR_NF_MEM, dw);\r\n}\r\nstatic void i5100_refresh_scrubbing(struct work_struct *work)\r\n{\r\nstruct delayed_work *i5100_scrubbing = container_of(work,\r\nstruct delayed_work,\r\nwork);\r\nstruct i5100_priv *priv = container_of(i5100_scrubbing,\r\nstruct i5100_priv,\r\ni5100_scrubbing);\r\nu32 dw;\r\npci_read_config_dword(priv->mc, I5100_MC, &dw);\r\nif (priv->scrub_enable) {\r\npci_read_config_dword(priv->mc, I5100_MC, &dw);\r\nif (i5100_mc_scrbdone(dw)) {\r\ndw |= I5100_MC_SCRBEN_MASK;\r\npci_write_config_dword(priv->mc, I5100_MC, dw);\r\npci_read_config_dword(priv->mc, I5100_MC, &dw);\r\n}\r\nschedule_delayed_work(&(priv->i5100_scrubbing),\r\nI5100_SCRUB_REFRESH_RATE);\r\n}\r\n}\r\nstatic int i5100_set_scrub_rate(struct mem_ctl_info *mci, u32 bandwidth)\r\n{\r\nstruct i5100_priv *priv = mci->pvt_info;\r\nu32 dw;\r\npci_read_config_dword(priv->mc, I5100_MC, &dw);\r\nif (bandwidth) {\r\npriv->scrub_enable = 1;\r\ndw |= I5100_MC_SCRBEN_MASK;\r\nschedule_delayed_work(&(priv->i5100_scrubbing),\r\nI5100_SCRUB_REFRESH_RATE);\r\n} else {\r\npriv->scrub_enable = 0;\r\ndw &= ~I5100_MC_SCRBEN_MASK;\r\ncancel_delayed_work(&(priv->i5100_scrubbing));\r\n}\r\npci_write_config_dword(priv->mc, I5100_MC, dw);\r\npci_read_config_dword(priv->mc, I5100_MC, &dw);\r\nbandwidth = 5900000 * i5100_mc_scrben(dw);\r\nreturn bandwidth;\r\n}\r\nstatic int i5100_get_scrub_rate(struct mem_ctl_info *mci)\r\n{\r\nstruct i5100_priv *priv = mci->pvt_info;\r\nu32 dw;\r\npci_read_config_dword(priv->mc, I5100_MC, &dw);\r\nreturn 5900000 * i5100_mc_scrben(dw);\r\n}\r\nstatic struct pci_dev *pci_get_device_func(unsigned vendor,\r\nunsigned device,\r\nunsigned func)\r\n{\r\nstruct pci_dev *ret = NULL;\r\nwhile (1) {\r\nret = pci_get_device(vendor, device, ret);\r\nif (!ret)\r\nbreak;\r\nif (PCI_FUNC(ret->devfn) == func)\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic unsigned long i5100_npages(struct mem_ctl_info *mci, int csrow)\r\n{\r\nstruct i5100_priv *priv = mci->pvt_info;\r\nconst unsigned chan_rank = i5100_csrow_to_rank(mci, csrow);\r\nconst unsigned chan = i5100_csrow_to_chan(mci, csrow);\r\nunsigned addr_lines;\r\nif (!priv->mtr[chan][chan_rank].present)\r\nreturn 0ULL;\r\naddr_lines =\r\nI5100_DIMM_ADDR_LINES +\r\npriv->mtr[chan][chan_rank].numcol +\r\npriv->mtr[chan][chan_rank].numrow +\r\npriv->mtr[chan][chan_rank].numbank;\r\nreturn (unsigned long)\r\n((unsigned long long) (1ULL << addr_lines) / PAGE_SIZE);\r\n}\r\nstatic void i5100_init_mtr(struct mem_ctl_info *mci)\r\n{\r\nstruct i5100_priv *priv = mci->pvt_info;\r\nstruct pci_dev *mms[2] = { priv->ch0mm, priv->ch1mm };\r\nint i;\r\nfor (i = 0; i < I5100_CHANNELS; i++) {\r\nint j;\r\nstruct pci_dev *pdev = mms[i];\r\nfor (j = 0; j < I5100_MAX_RANKS_PER_CHAN; j++) {\r\nconst unsigned addr =\r\n(j < 4) ? I5100_MTR_0 + j * 2 :\r\nI5100_MTR_4 + (j - 4) * 2;\r\nu16 w;\r\npci_read_config_word(pdev, addr, &w);\r\npriv->mtr[i][j].present = i5100_mtr_present(w);\r\npriv->mtr[i][j].ethrottle = i5100_mtr_ethrottle(w);\r\npriv->mtr[i][j].width = 4 + 4 * i5100_mtr_width(w);\r\npriv->mtr[i][j].numbank = 2 + i5100_mtr_numbank(w);\r\npriv->mtr[i][j].numrow = 13 + i5100_mtr_numrow(w);\r\npriv->mtr[i][j].numcol = 10 + i5100_mtr_numcol(w);\r\n}\r\n}\r\n}\r\nstatic int i5100_read_spd_byte(const struct mem_ctl_info *mci,\r\nu8 ch, u8 slot, u8 addr, u8 *byte)\r\n{\r\nstruct i5100_priv *priv = mci->pvt_info;\r\nu16 w;\r\nunsigned long et;\r\npci_read_config_word(priv->mc, I5100_SPDDATA, &w);\r\nif (i5100_spddata_busy(w))\r\nreturn -1;\r\npci_write_config_dword(priv->mc, I5100_SPDCMD,\r\ni5100_spdcmd_create(0xa, 1, ch * 4 + slot, addr,\r\n0, 0));\r\net = jiffies + HZ / 10;\r\nudelay(100);\r\nwhile (1) {\r\npci_read_config_word(priv->mc, I5100_SPDDATA, &w);\r\nif (!i5100_spddata_busy(w))\r\nbreak;\r\nudelay(100);\r\n}\r\nif (!i5100_spddata_rdo(w) || i5100_spddata_sbe(w))\r\nreturn -1;\r\n*byte = i5100_spddata_data(w);\r\nreturn 0;\r\n}\r\nstatic void i5100_init_dimm_csmap(struct mem_ctl_info *mci)\r\n{\r\nstruct i5100_priv *priv = mci->pvt_info;\r\nint i;\r\nfor (i = 0; i < I5100_MAX_DIMM_SLOTS_PER_CHAN; i++) {\r\nint j;\r\nfor (j = 0; j < I5100_MAX_RANKS_PER_DIMM; j++)\r\npriv->dimm_csmap[i][j] = -1;\r\n}\r\nif (priv->ranksperchan == 4) {\r\npriv->dimm_csmap[0][0] = 0;\r\npriv->dimm_csmap[0][1] = 3;\r\npriv->dimm_csmap[1][0] = 1;\r\npriv->dimm_csmap[1][1] = 2;\r\npriv->dimm_csmap[2][0] = 2;\r\npriv->dimm_csmap[3][0] = 3;\r\n} else {\r\npriv->dimm_csmap[0][0] = 0;\r\npriv->dimm_csmap[0][1] = 1;\r\npriv->dimm_csmap[1][0] = 2;\r\npriv->dimm_csmap[1][1] = 3;\r\npriv->dimm_csmap[2][0] = 4;\r\npriv->dimm_csmap[2][1] = 5;\r\n}\r\n}\r\nstatic void i5100_init_dimm_layout(struct pci_dev *pdev,\r\nstruct mem_ctl_info *mci)\r\n{\r\nstruct i5100_priv *priv = mci->pvt_info;\r\nint i;\r\nfor (i = 0; i < I5100_CHANNELS; i++) {\r\nint j;\r\nfor (j = 0; j < I5100_MAX_DIMM_SLOTS_PER_CHAN; j++) {\r\nu8 rank;\r\nif (i5100_read_spd_byte(mci, i, j, 5, &rank) < 0)\r\npriv->dimm_numrank[i][j] = 0;\r\nelse\r\npriv->dimm_numrank[i][j] = (rank & 3) + 1;\r\n}\r\n}\r\ni5100_init_dimm_csmap(mci);\r\n}\r\nstatic void i5100_init_interleaving(struct pci_dev *pdev,\r\nstruct mem_ctl_info *mci)\r\n{\r\nu16 w;\r\nu32 dw;\r\nstruct i5100_priv *priv = mci->pvt_info;\r\nstruct pci_dev *mms[2] = { priv->ch0mm, priv->ch1mm };\r\nint i;\r\npci_read_config_word(pdev, I5100_TOLM, &w);\r\npriv->tolm = (u64) i5100_tolm_tolm(w) * 256 * 1024 * 1024;\r\npci_read_config_word(pdev, I5100_MIR0, &w);\r\npriv->mir[0].limit = (u64) i5100_mir_limit(w) << 28;\r\npriv->mir[0].way[1] = i5100_mir_way1(w);\r\npriv->mir[0].way[0] = i5100_mir_way0(w);\r\npci_read_config_word(pdev, I5100_MIR1, &w);\r\npriv->mir[1].limit = (u64) i5100_mir_limit(w) << 28;\r\npriv->mir[1].way[1] = i5100_mir_way1(w);\r\npriv->mir[1].way[0] = i5100_mir_way0(w);\r\npci_read_config_word(pdev, I5100_AMIR_0, &w);\r\npriv->amir[0] = w;\r\npci_read_config_word(pdev, I5100_AMIR_1, &w);\r\npriv->amir[1] = w;\r\nfor (i = 0; i < I5100_CHANNELS; i++) {\r\nint j;\r\nfor (j = 0; j < 5; j++) {\r\nint k;\r\npci_read_config_dword(mms[i], I5100_DMIR + j * 4, &dw);\r\npriv->dmir[i][j].limit =\r\n(u64) i5100_dmir_limit(dw) << 28;\r\nfor (k = 0; k < I5100_MAX_RANKS_PER_DIMM; k++)\r\npriv->dmir[i][j].rank[k] =\r\ni5100_dmir_rank(dw, k);\r\n}\r\n}\r\ni5100_init_mtr(mci);\r\n}\r\nstatic void i5100_init_csrows(struct mem_ctl_info *mci)\r\n{\r\nint i;\r\nstruct i5100_priv *priv = mci->pvt_info;\r\nfor (i = 0; i < mci->tot_dimms; i++) {\r\nstruct dimm_info *dimm;\r\nconst unsigned long npages = i5100_npages(mci, i);\r\nconst unsigned chan = i5100_csrow_to_chan(mci, i);\r\nconst unsigned rank = i5100_csrow_to_rank(mci, i);\r\nif (!npages)\r\ncontinue;\r\ndimm = EDAC_DIMM_PTR(mci->layers, mci->dimms, mci->n_layers,\r\nchan, rank, 0);\r\ndimm->nr_pages = npages;\r\ndimm->grain = 32;\r\ndimm->dtype = (priv->mtr[chan][rank].width == 4) ?\r\nDEV_X4 : DEV_X8;\r\ndimm->mtype = MEM_RDDR2;\r\ndimm->edac_mode = EDAC_SECDED;\r\nsnprintf(dimm->label, sizeof(dimm->label), "DIMM%u",\r\ni5100_rank_to_slot(mci, chan, rank));\r\nedac_dbg(2, "dimm channel %d, rank %d, size %ld\n",\r\nchan, rank, (long)PAGES_TO_MiB(npages));\r\n}\r\n}\r\nstatic void i5100_do_inject(struct mem_ctl_info *mci)\r\n{\r\nstruct i5100_priv *priv = mci->pvt_info;\r\nu32 mask0;\r\nu16 mask1;\r\nmask0 = ((priv->inject_hlinesel & 0x3) << 28) |\r\nI5100_MEMXEINJMSK0_EINJEN |\r\n((priv->inject_eccmask1 & 0xffff) << 10) |\r\n((priv->inject_deviceptr2 & 0x1f) << 5) |\r\n(priv->inject_deviceptr1 & 0x1f);\r\nmask1 = priv->inject_eccmask2;\r\nif (priv->inject_channel == 0) {\r\npci_write_config_dword(priv->mc, I5100_MEM0EINJMSK0, mask0);\r\npci_write_config_word(priv->mc, I5100_MEM0EINJMSK1, mask1);\r\n} else {\r\npci_write_config_dword(priv->mc, I5100_MEM1EINJMSK0, mask0);\r\npci_write_config_word(priv->mc, I5100_MEM1EINJMSK1, mask1);\r\n}\r\npci_write_config_byte(priv->einj, I5100_DINJ0, 0xaa);\r\npci_write_config_byte(priv->einj, I5100_DINJ0, 0xab);\r\n}\r\nstatic ssize_t inject_enable_write(struct file *file, const char __user *data,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct device *dev = file->private_data;\r\nstruct mem_ctl_info *mci = to_mci(dev);\r\ni5100_do_inject(mci);\r\nreturn count;\r\n}\r\nstatic int i5100_setup_debugfs(struct mem_ctl_info *mci)\r\n{\r\nstruct i5100_priv *priv = mci->pvt_info;\r\nif (!i5100_debugfs)\r\nreturn -ENODEV;\r\npriv->debugfs = debugfs_create_dir(mci->bus->name, i5100_debugfs);\r\nif (!priv->debugfs)\r\nreturn -ENOMEM;\r\ndebugfs_create_x8("inject_channel", S_IRUGO | S_IWUSR, priv->debugfs,\r\n&priv->inject_channel);\r\ndebugfs_create_x8("inject_hlinesel", S_IRUGO | S_IWUSR, priv->debugfs,\r\n&priv->inject_hlinesel);\r\ndebugfs_create_x8("inject_deviceptr1", S_IRUGO | S_IWUSR, priv->debugfs,\r\n&priv->inject_deviceptr1);\r\ndebugfs_create_x8("inject_deviceptr2", S_IRUGO | S_IWUSR, priv->debugfs,\r\n&priv->inject_deviceptr2);\r\ndebugfs_create_x16("inject_eccmask1", S_IRUGO | S_IWUSR, priv->debugfs,\r\n&priv->inject_eccmask1);\r\ndebugfs_create_x16("inject_eccmask2", S_IRUGO | S_IWUSR, priv->debugfs,\r\n&priv->inject_eccmask2);\r\ndebugfs_create_file("inject_enable", S_IWUSR, priv->debugfs,\r\n&mci->dev, &i5100_inject_enable_fops);\r\nreturn 0;\r\n}\r\nstatic int i5100_init_one(struct pci_dev *pdev, const struct pci_device_id *id)\r\n{\r\nint rc;\r\nstruct mem_ctl_info *mci;\r\nstruct edac_mc_layer layers[2];\r\nstruct i5100_priv *priv;\r\nstruct pci_dev *ch0mm, *ch1mm, *einj;\r\nint ret = 0;\r\nu32 dw;\r\nint ranksperch;\r\nif (PCI_FUNC(pdev->devfn) != 1)\r\nreturn -ENODEV;\r\nrc = pci_enable_device(pdev);\r\nif (rc < 0) {\r\nret = rc;\r\ngoto bail;\r\n}\r\npci_read_config_dword(pdev, I5100_MC, &dw);\r\nif (!i5100_mc_errdeten(dw)) {\r\nprintk(KERN_INFO "i5100_edac: ECC not enabled.\n");\r\nret = -ENODEV;\r\ngoto bail_pdev;\r\n}\r\npci_read_config_dword(pdev, I5100_MS, &dw);\r\nranksperch = !!(dw & (1 << 8)) * 2 + 4;\r\npci_read_config_dword(pdev, I5100_EMASK_MEM, &dw);\r\ndw &= ~I5100_FERR_NF_MEM_ANY_MASK;\r\npci_write_config_dword(pdev, I5100_EMASK_MEM, dw);\r\nch0mm = pci_get_device_func(PCI_VENDOR_ID_INTEL,\r\nPCI_DEVICE_ID_INTEL_5100_21, 0);\r\nif (!ch0mm) {\r\nret = -ENODEV;\r\ngoto bail_pdev;\r\n}\r\nrc = pci_enable_device(ch0mm);\r\nif (rc < 0) {\r\nret = rc;\r\ngoto bail_ch0;\r\n}\r\nch1mm = pci_get_device_func(PCI_VENDOR_ID_INTEL,\r\nPCI_DEVICE_ID_INTEL_5100_22, 0);\r\nif (!ch1mm) {\r\nret = -ENODEV;\r\ngoto bail_disable_ch0;\r\n}\r\nrc = pci_enable_device(ch1mm);\r\nif (rc < 0) {\r\nret = rc;\r\ngoto bail_ch1;\r\n}\r\nlayers[0].type = EDAC_MC_LAYER_CHANNEL;\r\nlayers[0].size = 2;\r\nlayers[0].is_virt_csrow = false;\r\nlayers[1].type = EDAC_MC_LAYER_SLOT;\r\nlayers[1].size = ranksperch;\r\nlayers[1].is_virt_csrow = true;\r\nmci = edac_mc_alloc(0, ARRAY_SIZE(layers), layers,\r\nsizeof(*priv));\r\nif (!mci) {\r\nret = -ENOMEM;\r\ngoto bail_disable_ch1;\r\n}\r\neinj = pci_get_device_func(PCI_VENDOR_ID_INTEL,\r\nPCI_DEVICE_ID_INTEL_5100_19, 0);\r\nif (!einj) {\r\nret = -ENODEV;\r\ngoto bail_einj;\r\n}\r\nrc = pci_enable_device(einj);\r\nif (rc < 0) {\r\nret = rc;\r\ngoto bail_disable_einj;\r\n}\r\nmci->pdev = &pdev->dev;\r\npriv = mci->pvt_info;\r\npriv->ranksperchan = ranksperch;\r\npriv->mc = pdev;\r\npriv->ch0mm = ch0mm;\r\npriv->ch1mm = ch1mm;\r\npriv->einj = einj;\r\nINIT_DELAYED_WORK(&(priv->i5100_scrubbing), i5100_refresh_scrubbing);\r\npci_read_config_dword(pdev, I5100_MC, &dw);\r\nif (i5100_mc_scrben(dw)) {\r\npriv->scrub_enable = 1;\r\nschedule_delayed_work(&(priv->i5100_scrubbing),\r\nI5100_SCRUB_REFRESH_RATE);\r\n}\r\ni5100_init_dimm_layout(pdev, mci);\r\ni5100_init_interleaving(pdev, mci);\r\nmci->mtype_cap = MEM_FLAG_FB_DDR2;\r\nmci->edac_ctl_cap = EDAC_FLAG_SECDED;\r\nmci->edac_cap = EDAC_FLAG_SECDED;\r\nmci->mod_name = "i5100_edac.c";\r\nmci->mod_ver = "not versioned";\r\nmci->ctl_name = "i5100";\r\nmci->dev_name = pci_name(pdev);\r\nmci->ctl_page_to_phys = NULL;\r\nmci->edac_check = i5100_check_error;\r\nmci->set_sdram_scrub_rate = i5100_set_scrub_rate;\r\nmci->get_sdram_scrub_rate = i5100_get_scrub_rate;\r\npriv->inject_channel = 0;\r\npriv->inject_hlinesel = 0;\r\npriv->inject_deviceptr1 = 0;\r\npriv->inject_deviceptr2 = 0;\r\npriv->inject_eccmask1 = 0;\r\npriv->inject_eccmask2 = 0;\r\ni5100_init_csrows(mci);\r\nswitch (edac_op_state) {\r\ncase EDAC_OPSTATE_POLL:\r\ncase EDAC_OPSTATE_NMI:\r\nbreak;\r\ndefault:\r\nedac_op_state = EDAC_OPSTATE_POLL;\r\nbreak;\r\n}\r\nif (edac_mc_add_mc(mci)) {\r\nret = -ENODEV;\r\ngoto bail_scrub;\r\n}\r\ni5100_setup_debugfs(mci);\r\nreturn ret;\r\nbail_scrub:\r\npriv->scrub_enable = 0;\r\ncancel_delayed_work_sync(&(priv->i5100_scrubbing));\r\nedac_mc_free(mci);\r\nbail_disable_einj:\r\npci_disable_device(einj);\r\nbail_einj:\r\npci_dev_put(einj);\r\nbail_disable_ch1:\r\npci_disable_device(ch1mm);\r\nbail_ch1:\r\npci_dev_put(ch1mm);\r\nbail_disable_ch0:\r\npci_disable_device(ch0mm);\r\nbail_ch0:\r\npci_dev_put(ch0mm);\r\nbail_pdev:\r\npci_disable_device(pdev);\r\nbail:\r\nreturn ret;\r\n}\r\nstatic void i5100_remove_one(struct pci_dev *pdev)\r\n{\r\nstruct mem_ctl_info *mci;\r\nstruct i5100_priv *priv;\r\nmci = edac_mc_del_mc(&pdev->dev);\r\nif (!mci)\r\nreturn;\r\npriv = mci->pvt_info;\r\ndebugfs_remove_recursive(priv->debugfs);\r\npriv->scrub_enable = 0;\r\ncancel_delayed_work_sync(&(priv->i5100_scrubbing));\r\npci_disable_device(pdev);\r\npci_disable_device(priv->ch0mm);\r\npci_disable_device(priv->ch1mm);\r\npci_disable_device(priv->einj);\r\npci_dev_put(priv->ch0mm);\r\npci_dev_put(priv->ch1mm);\r\npci_dev_put(priv->einj);\r\nedac_mc_free(mci);\r\n}\r\nstatic int __init i5100_init(void)\r\n{\r\nint pci_rc;\r\ni5100_debugfs = debugfs_create_dir("i5100_edac", NULL);\r\npci_rc = pci_register_driver(&i5100_driver);\r\nreturn (pci_rc < 0) ? pci_rc : 0;\r\n}\r\nstatic void __exit i5100_exit(void)\r\n{\r\ndebugfs_remove(i5100_debugfs);\r\npci_unregister_driver(&i5100_driver);\r\n}
