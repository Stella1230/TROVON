static struct device_opp *_find_device_opp(struct device *dev)\r\n{\r\nstruct device_opp *tmp_dev_opp, *dev_opp = ERR_PTR(-ENODEV);\r\nif (unlikely(IS_ERR_OR_NULL(dev))) {\r\npr_err("%s: Invalid parameters\n", __func__);\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nlist_for_each_entry_rcu(tmp_dev_opp, &dev_opp_list, node) {\r\nif (tmp_dev_opp->dev == dev) {\r\ndev_opp = tmp_dev_opp;\r\nbreak;\r\n}\r\n}\r\nreturn dev_opp;\r\n}\r\nunsigned long dev_pm_opp_get_voltage(struct dev_pm_opp *opp)\r\n{\r\nstruct dev_pm_opp *tmp_opp;\r\nunsigned long v = 0;\r\nopp_rcu_lockdep_assert();\r\ntmp_opp = rcu_dereference(opp);\r\nif (unlikely(IS_ERR_OR_NULL(tmp_opp)) || !tmp_opp->available)\r\npr_err("%s: Invalid parameters\n", __func__);\r\nelse\r\nv = tmp_opp->u_volt;\r\nreturn v;\r\n}\r\nunsigned long dev_pm_opp_get_freq(struct dev_pm_opp *opp)\r\n{\r\nstruct dev_pm_opp *tmp_opp;\r\nunsigned long f = 0;\r\nopp_rcu_lockdep_assert();\r\ntmp_opp = rcu_dereference(opp);\r\nif (unlikely(IS_ERR_OR_NULL(tmp_opp)) || !tmp_opp->available)\r\npr_err("%s: Invalid parameters\n", __func__);\r\nelse\r\nf = tmp_opp->rate;\r\nreturn f;\r\n}\r\nint dev_pm_opp_get_opp_count(struct device *dev)\r\n{\r\nstruct device_opp *dev_opp;\r\nstruct dev_pm_opp *temp_opp;\r\nint count = 0;\r\nrcu_read_lock();\r\ndev_opp = _find_device_opp(dev);\r\nif (IS_ERR(dev_opp)) {\r\ncount = PTR_ERR(dev_opp);\r\ndev_err(dev, "%s: device OPP not found (%d)\n",\r\n__func__, count);\r\ngoto out_unlock;\r\n}\r\nlist_for_each_entry_rcu(temp_opp, &dev_opp->opp_list, node) {\r\nif (temp_opp->available)\r\ncount++;\r\n}\r\nout_unlock:\r\nrcu_read_unlock();\r\nreturn count;\r\n}\r\nstruct dev_pm_opp *dev_pm_opp_find_freq_exact(struct device *dev,\r\nunsigned long freq,\r\nbool available)\r\n{\r\nstruct device_opp *dev_opp;\r\nstruct dev_pm_opp *temp_opp, *opp = ERR_PTR(-ERANGE);\r\nopp_rcu_lockdep_assert();\r\ndev_opp = _find_device_opp(dev);\r\nif (IS_ERR(dev_opp)) {\r\nint r = PTR_ERR(dev_opp);\r\ndev_err(dev, "%s: device OPP not found (%d)\n", __func__, r);\r\nreturn ERR_PTR(r);\r\n}\r\nlist_for_each_entry_rcu(temp_opp, &dev_opp->opp_list, node) {\r\nif (temp_opp->available == available &&\r\ntemp_opp->rate == freq) {\r\nopp = temp_opp;\r\nbreak;\r\n}\r\n}\r\nreturn opp;\r\n}\r\nstruct dev_pm_opp *dev_pm_opp_find_freq_ceil(struct device *dev,\r\nunsigned long *freq)\r\n{\r\nstruct device_opp *dev_opp;\r\nstruct dev_pm_opp *temp_opp, *opp = ERR_PTR(-ERANGE);\r\nopp_rcu_lockdep_assert();\r\nif (!dev || !freq) {\r\ndev_err(dev, "%s: Invalid argument freq=%p\n", __func__, freq);\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\ndev_opp = _find_device_opp(dev);\r\nif (IS_ERR(dev_opp))\r\nreturn ERR_CAST(dev_opp);\r\nlist_for_each_entry_rcu(temp_opp, &dev_opp->opp_list, node) {\r\nif (temp_opp->available && temp_opp->rate >= *freq) {\r\nopp = temp_opp;\r\n*freq = opp->rate;\r\nbreak;\r\n}\r\n}\r\nreturn opp;\r\n}\r\nstruct dev_pm_opp *dev_pm_opp_find_freq_floor(struct device *dev,\r\nunsigned long *freq)\r\n{\r\nstruct device_opp *dev_opp;\r\nstruct dev_pm_opp *temp_opp, *opp = ERR_PTR(-ERANGE);\r\nopp_rcu_lockdep_assert();\r\nif (!dev || !freq) {\r\ndev_err(dev, "%s: Invalid argument freq=%p\n", __func__, freq);\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\ndev_opp = _find_device_opp(dev);\r\nif (IS_ERR(dev_opp))\r\nreturn ERR_CAST(dev_opp);\r\nlist_for_each_entry_rcu(temp_opp, &dev_opp->opp_list, node) {\r\nif (temp_opp->available) {\r\nif (temp_opp->rate > *freq)\r\nbreak;\r\nelse\r\nopp = temp_opp;\r\n}\r\n}\r\nif (!IS_ERR(opp))\r\n*freq = opp->rate;\r\nreturn opp;\r\n}\r\nstatic struct device_opp *_add_device_opp(struct device *dev)\r\n{\r\nstruct device_opp *dev_opp;\r\ndev_opp = kzalloc(sizeof(*dev_opp), GFP_KERNEL);\r\nif (!dev_opp)\r\nreturn NULL;\r\ndev_opp->dev = dev;\r\nsrcu_init_notifier_head(&dev_opp->srcu_head);\r\nINIT_LIST_HEAD(&dev_opp->opp_list);\r\nlist_add_rcu(&dev_opp->node, &dev_opp_list);\r\nreturn dev_opp;\r\n}\r\nstatic int _opp_add_dynamic(struct device *dev, unsigned long freq,\r\nlong u_volt, bool dynamic)\r\n{\r\nstruct device_opp *dev_opp = NULL;\r\nstruct dev_pm_opp *opp, *new_opp;\r\nstruct list_head *head;\r\nint ret;\r\nnew_opp = kzalloc(sizeof(*new_opp), GFP_KERNEL);\r\nif (!new_opp)\r\nreturn -ENOMEM;\r\nmutex_lock(&dev_opp_list_lock);\r\nnew_opp->rate = freq;\r\nnew_opp->u_volt = u_volt;\r\nnew_opp->available = true;\r\nnew_opp->dynamic = dynamic;\r\ndev_opp = _find_device_opp(dev);\r\nif (IS_ERR(dev_opp)) {\r\ndev_opp = _add_device_opp(dev);\r\nif (!dev_opp) {\r\nret = -ENOMEM;\r\ngoto free_opp;\r\n}\r\nhead = &dev_opp->opp_list;\r\ngoto list_add;\r\n}\r\nhead = &dev_opp->opp_list;\r\nlist_for_each_entry_rcu(opp, &dev_opp->opp_list, node) {\r\nif (new_opp->rate <= opp->rate)\r\nbreak;\r\nelse\r\nhead = &opp->node;\r\n}\r\nif (new_opp->rate == opp->rate) {\r\nret = opp->available && new_opp->u_volt == opp->u_volt ?\r\n0 : -EEXIST;\r\ndev_warn(dev, "%s: duplicate OPPs detected. Existing: freq: %lu, volt: %lu, enabled: %d. New: freq: %lu, volt: %lu, enabled: %d\n",\r\n__func__, opp->rate, opp->u_volt, opp->available,\r\nnew_opp->rate, new_opp->u_volt, new_opp->available);\r\ngoto free_opp;\r\n}\r\nlist_add:\r\nnew_opp->dev_opp = dev_opp;\r\nlist_add_rcu(&new_opp->node, head);\r\nmutex_unlock(&dev_opp_list_lock);\r\nsrcu_notifier_call_chain(&dev_opp->srcu_head, OPP_EVENT_ADD, new_opp);\r\nreturn 0;\r\nfree_opp:\r\nmutex_unlock(&dev_opp_list_lock);\r\nkfree(new_opp);\r\nreturn ret;\r\n}\r\nint dev_pm_opp_add(struct device *dev, unsigned long freq, unsigned long u_volt)\r\n{\r\nreturn _opp_add_dynamic(dev, freq, u_volt, true);\r\n}\r\nstatic void _kfree_opp_rcu(struct rcu_head *head)\r\n{\r\nstruct dev_pm_opp *opp = container_of(head, struct dev_pm_opp, rcu_head);\r\nkfree_rcu(opp, rcu_head);\r\n}\r\nstatic void _kfree_device_rcu(struct rcu_head *head)\r\n{\r\nstruct device_opp *device_opp = container_of(head, struct device_opp, rcu_head);\r\nkfree_rcu(device_opp, rcu_head);\r\n}\r\nstatic void _opp_remove(struct device_opp *dev_opp,\r\nstruct dev_pm_opp *opp)\r\n{\r\nsrcu_notifier_call_chain(&dev_opp->srcu_head, OPP_EVENT_REMOVE, opp);\r\nlist_del_rcu(&opp->node);\r\ncall_srcu(&dev_opp->srcu_head.srcu, &opp->rcu_head, _kfree_opp_rcu);\r\nif (list_empty(&dev_opp->opp_list)) {\r\nlist_del_rcu(&dev_opp->node);\r\ncall_srcu(&dev_opp->srcu_head.srcu, &dev_opp->rcu_head,\r\n_kfree_device_rcu);\r\n}\r\n}\r\nvoid dev_pm_opp_remove(struct device *dev, unsigned long freq)\r\n{\r\nstruct dev_pm_opp *opp;\r\nstruct device_opp *dev_opp;\r\nbool found = false;\r\nmutex_lock(&dev_opp_list_lock);\r\ndev_opp = _find_device_opp(dev);\r\nif (IS_ERR(dev_opp))\r\ngoto unlock;\r\nlist_for_each_entry(opp, &dev_opp->opp_list, node) {\r\nif (opp->rate == freq) {\r\nfound = true;\r\nbreak;\r\n}\r\n}\r\nif (!found) {\r\ndev_warn(dev, "%s: Couldn't find OPP with freq: %lu\n",\r\n__func__, freq);\r\ngoto unlock;\r\n}\r\n_opp_remove(dev_opp, opp);\r\nunlock:\r\nmutex_unlock(&dev_opp_list_lock);\r\n}\r\nstatic int _opp_set_availability(struct device *dev, unsigned long freq,\r\nbool availability_req)\r\n{\r\nstruct device_opp *dev_opp;\r\nstruct dev_pm_opp *new_opp, *tmp_opp, *opp = ERR_PTR(-ENODEV);\r\nint r = 0;\r\nnew_opp = kmalloc(sizeof(*new_opp), GFP_KERNEL);\r\nif (!new_opp)\r\nreturn -ENOMEM;\r\nmutex_lock(&dev_opp_list_lock);\r\ndev_opp = _find_device_opp(dev);\r\nif (IS_ERR(dev_opp)) {\r\nr = PTR_ERR(dev_opp);\r\ndev_warn(dev, "%s: Device OPP not found (%d)\n", __func__, r);\r\ngoto unlock;\r\n}\r\nlist_for_each_entry(tmp_opp, &dev_opp->opp_list, node) {\r\nif (tmp_opp->rate == freq) {\r\nopp = tmp_opp;\r\nbreak;\r\n}\r\n}\r\nif (IS_ERR(opp)) {\r\nr = PTR_ERR(opp);\r\ngoto unlock;\r\n}\r\nif (opp->available == availability_req)\r\ngoto unlock;\r\n*new_opp = *opp;\r\nnew_opp->available = availability_req;\r\nlist_replace_rcu(&opp->node, &new_opp->node);\r\nmutex_unlock(&dev_opp_list_lock);\r\ncall_srcu(&dev_opp->srcu_head.srcu, &opp->rcu_head, _kfree_opp_rcu);\r\nif (availability_req)\r\nsrcu_notifier_call_chain(&dev_opp->srcu_head, OPP_EVENT_ENABLE,\r\nnew_opp);\r\nelse\r\nsrcu_notifier_call_chain(&dev_opp->srcu_head, OPP_EVENT_DISABLE,\r\nnew_opp);\r\nreturn 0;\r\nunlock:\r\nmutex_unlock(&dev_opp_list_lock);\r\nkfree(new_opp);\r\nreturn r;\r\n}\r\nint dev_pm_opp_enable(struct device *dev, unsigned long freq)\r\n{\r\nreturn _opp_set_availability(dev, freq, true);\r\n}\r\nint dev_pm_opp_disable(struct device *dev, unsigned long freq)\r\n{\r\nreturn _opp_set_availability(dev, freq, false);\r\n}\r\nstruct srcu_notifier_head *dev_pm_opp_get_notifier(struct device *dev)\r\n{\r\nstruct device_opp *dev_opp = _find_device_opp(dev);\r\nif (IS_ERR(dev_opp))\r\nreturn ERR_CAST(dev_opp);\r\nreturn &dev_opp->srcu_head;\r\n}\r\nint of_init_opp_table(struct device *dev)\r\n{\r\nconst struct property *prop;\r\nconst __be32 *val;\r\nint nr;\r\nprop = of_find_property(dev->of_node, "operating-points", NULL);\r\nif (!prop)\r\nreturn -ENODEV;\r\nif (!prop->value)\r\nreturn -ENODATA;\r\nnr = prop->length / sizeof(u32);\r\nif (nr % 2) {\r\ndev_err(dev, "%s: Invalid OPP list\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nval = prop->value;\r\nwhile (nr) {\r\nunsigned long freq = be32_to_cpup(val++) * 1000;\r\nunsigned long volt = be32_to_cpup(val++);\r\nif (_opp_add_dynamic(dev, freq, volt, false))\r\ndev_warn(dev, "%s: Failed to add OPP %ld\n",\r\n__func__, freq);\r\nnr -= 2;\r\n}\r\nreturn 0;\r\n}\r\nvoid of_free_opp_table(struct device *dev)\r\n{\r\nstruct device_opp *dev_opp;\r\nstruct dev_pm_opp *opp, *tmp;\r\ndev_opp = _find_device_opp(dev);\r\nif (IS_ERR(dev_opp)) {\r\nint error = PTR_ERR(dev_opp);\r\nif (error != -ENODEV)\r\nWARN(1, "%s: dev_opp: %d\n",\r\nIS_ERR_OR_NULL(dev) ?\r\n"Invalid device" : dev_name(dev),\r\nerror);\r\nreturn;\r\n}\r\nmutex_lock(&dev_opp_list_lock);\r\nlist_for_each_entry_safe(opp, tmp, &dev_opp->opp_list, node) {\r\nif (!opp->dynamic)\r\n_opp_remove(dev_opp, opp);\r\n}\r\nmutex_unlock(&dev_opp_list_lock);\r\n}
