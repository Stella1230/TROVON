static inline u32 set_hsync_pulse_width(struct mxsfb_info *host, unsigned val)\r\n{\r\nreturn (val & host->devdata->hs_wdth_mask) <<\r\nhost->devdata->hs_wdth_shift;\r\n}\r\nstatic inline u32 get_hsync_pulse_width(struct mxsfb_info *host, unsigned val)\r\n{\r\nreturn (val >> host->devdata->hs_wdth_shift) &\r\nhost->devdata->hs_wdth_mask;\r\n}\r\nstatic inline unsigned chan_to_field(unsigned chan, struct fb_bitfield *bf)\r\n{\r\nchan &= 0xffff;\r\nchan >>= 16 - bf->length;\r\nreturn chan << bf->offset;\r\n}\r\nstatic int mxsfb_check_var(struct fb_var_screeninfo *var,\r\nstruct fb_info *fb_info)\r\n{\r\nstruct mxsfb_info *host = to_imxfb_host(fb_info);\r\nconst struct fb_bitfield *rgb = NULL;\r\nif (var->xres < MIN_XRES)\r\nvar->xres = MIN_XRES;\r\nif (var->yres < MIN_YRES)\r\nvar->yres = MIN_YRES;\r\nvar->xres_virtual = var->xres;\r\nvar->yres_virtual = var->yres;\r\nswitch (var->bits_per_pixel) {\r\ncase 16:\r\nrgb = def_rgb565;\r\nbreak;\r\ncase 32:\r\nswitch (host->ld_intf_width) {\r\ncase STMLCDIF_8BIT:\r\npr_debug("Unsupported LCD bus width mapping\n");\r\nbreak;\r\ncase STMLCDIF_16BIT:\r\ncase STMLCDIF_18BIT:\r\ncase STMLCDIF_24BIT:\r\nrgb = def_rgb888;\r\nbreak;\r\n}\r\nbreak;\r\ndefault:\r\npr_err("Unsupported colour depth: %u\n", var->bits_per_pixel);\r\nreturn -EINVAL;\r\n}\r\nvar->red = rgb[RED];\r\nvar->green = rgb[GREEN];\r\nvar->blue = rgb[BLUE];\r\nvar->transp = rgb[TRANSP];\r\nreturn 0;\r\n}\r\nstatic void mxsfb_enable_controller(struct fb_info *fb_info)\r\n{\r\nstruct mxsfb_info *host = to_imxfb_host(fb_info);\r\nu32 reg;\r\nint ret;\r\ndev_dbg(&host->pdev->dev, "%s\n", __func__);\r\nif (host->reg_lcd) {\r\nret = regulator_enable(host->reg_lcd);\r\nif (ret) {\r\ndev_err(&host->pdev->dev,\r\n"lcd regulator enable failed: %d\n", ret);\r\nreturn;\r\n}\r\n}\r\nif (host->clk_axi)\r\nclk_prepare_enable(host->clk_axi);\r\nif (host->clk_disp_axi)\r\nclk_prepare_enable(host->clk_disp_axi);\r\nclk_prepare_enable(host->clk);\r\nclk_set_rate(host->clk, PICOS2KHZ(fb_info->var.pixclock) * 1000U);\r\nwritel(CTRL_DOTCLK_MODE, host->base + LCDC_CTRL + REG_SET);\r\nreg = readl(host->base + LCDC_VDCTRL4);\r\nreg |= VDCTRL4_SYNC_SIGNALS_ON;\r\nwritel(reg, host->base + LCDC_VDCTRL4);\r\nwritel(CTRL_RUN, host->base + LCDC_CTRL + REG_SET);\r\nhost->enabled = 1;\r\n}\r\nstatic void mxsfb_disable_controller(struct fb_info *fb_info)\r\n{\r\nstruct mxsfb_info *host = to_imxfb_host(fb_info);\r\nunsigned loop;\r\nu32 reg;\r\nint ret;\r\ndev_dbg(&host->pdev->dev, "%s\n", __func__);\r\nwritel(CTRL_DOTCLK_MODE, host->base + LCDC_CTRL + REG_CLR);\r\nloop = 1000;\r\nwhile (loop) {\r\nreg = readl(host->base + LCDC_CTRL);\r\nif (!(reg & CTRL_RUN))\r\nbreak;\r\nloop--;\r\n}\r\nreg = readl(host->base + LCDC_VDCTRL4);\r\nwritel(reg & ~VDCTRL4_SYNC_SIGNALS_ON, host->base + LCDC_VDCTRL4);\r\nclk_disable_unprepare(host->clk);\r\nif (host->clk_disp_axi)\r\nclk_disable_unprepare(host->clk_disp_axi);\r\nif (host->clk_axi)\r\nclk_disable_unprepare(host->clk_axi);\r\nhost->enabled = 0;\r\nif (host->reg_lcd) {\r\nret = regulator_disable(host->reg_lcd);\r\nif (ret)\r\ndev_err(&host->pdev->dev,\r\n"lcd regulator disable failed: %d\n", ret);\r\n}\r\n}\r\nstatic int mxsfb_set_par(struct fb_info *fb_info)\r\n{\r\nstruct mxsfb_info *host = to_imxfb_host(fb_info);\r\nu32 ctrl, vdctrl0, vdctrl4;\r\nint line_size, fb_size;\r\nint reenable = 0;\r\nline_size = fb_info->var.xres * (fb_info->var.bits_per_pixel >> 3);\r\nfb_size = fb_info->var.yres_virtual * line_size;\r\nif (fb_size > fb_info->fix.smem_len)\r\nreturn -ENOMEM;\r\nfb_info->fix.line_length = line_size;\r\nif (host->enabled) {\r\nreenable = 1;\r\nmxsfb_disable_controller(fb_info);\r\n}\r\nwritel(CTRL1_FIFO_CLEAR, host->base + LCDC_CTRL1 + REG_SET);\r\nctrl = CTRL_BYPASS_COUNT | CTRL_MASTER |\r\nCTRL_SET_BUS_WIDTH(host->ld_intf_width);\r\nswitch (fb_info->var.bits_per_pixel) {\r\ncase 16:\r\ndev_dbg(&host->pdev->dev, "Setting up RGB565 mode\n");\r\nctrl |= CTRL_SET_WORD_LENGTH(0);\r\nwritel(CTRL1_SET_BYTE_PACKAGING(0xf), host->base + LCDC_CTRL1);\r\nbreak;\r\ncase 32:\r\ndev_dbg(&host->pdev->dev, "Setting up RGB888/666 mode\n");\r\nctrl |= CTRL_SET_WORD_LENGTH(3);\r\nswitch (host->ld_intf_width) {\r\ncase STMLCDIF_8BIT:\r\ndev_err(&host->pdev->dev,\r\n"Unsupported LCD bus width mapping\n");\r\nreturn -EINVAL;\r\ncase STMLCDIF_16BIT:\r\ncase STMLCDIF_18BIT:\r\ncase STMLCDIF_24BIT:\r\nbreak;\r\n}\r\nwritel(CTRL1_SET_BYTE_PACKAGING(0x7), host->base + LCDC_CTRL1);\r\nbreak;\r\ndefault:\r\ndev_err(&host->pdev->dev, "Unhandled color depth of %u\n",\r\nfb_info->var.bits_per_pixel);\r\nreturn -EINVAL;\r\n}\r\nwritel(ctrl, host->base + LCDC_CTRL);\r\nwritel(TRANSFER_COUNT_SET_VCOUNT(fb_info->var.yres) |\r\nTRANSFER_COUNT_SET_HCOUNT(fb_info->var.xres),\r\nhost->base + host->devdata->transfer_count);\r\nvdctrl0 = VDCTRL0_ENABLE_PRESENT |\r\nVDCTRL0_VSYNC_PERIOD_UNIT |\r\nVDCTRL0_VSYNC_PULSE_WIDTH_UNIT |\r\nVDCTRL0_SET_VSYNC_PULSE_WIDTH(fb_info->var.vsync_len);\r\nif (fb_info->var.sync & FB_SYNC_HOR_HIGH_ACT)\r\nvdctrl0 |= VDCTRL0_HSYNC_ACT_HIGH;\r\nif (fb_info->var.sync & FB_SYNC_VERT_HIGH_ACT)\r\nvdctrl0 |= VDCTRL0_VSYNC_ACT_HIGH;\r\nif (host->sync & MXSFB_SYNC_DATA_ENABLE_HIGH_ACT)\r\nvdctrl0 |= VDCTRL0_ENABLE_ACT_HIGH;\r\nif (host->sync & MXSFB_SYNC_DOTCLK_FALLING_ACT)\r\nvdctrl0 |= VDCTRL0_DOTCLK_ACT_FALLING;\r\nwritel(vdctrl0, host->base + LCDC_VDCTRL0);\r\nwritel(fb_info->var.upper_margin + fb_info->var.vsync_len +\r\nfb_info->var.lower_margin + fb_info->var.yres,\r\nhost->base + LCDC_VDCTRL1);\r\nwritel(set_hsync_pulse_width(host, fb_info->var.hsync_len) |\r\nVDCTRL2_SET_HSYNC_PERIOD(fb_info->var.left_margin +\r\nfb_info->var.hsync_len + fb_info->var.right_margin +\r\nfb_info->var.xres),\r\nhost->base + LCDC_VDCTRL2);\r\nwritel(SET_HOR_WAIT_CNT(fb_info->var.left_margin +\r\nfb_info->var.hsync_len) |\r\nSET_VERT_WAIT_CNT(fb_info->var.upper_margin +\r\nfb_info->var.vsync_len),\r\nhost->base + LCDC_VDCTRL3);\r\nvdctrl4 = SET_DOTCLK_H_VALID_DATA_CNT(fb_info->var.xres);\r\nif (mxsfb_is_v4(host))\r\nvdctrl4 |= VDCTRL4_SET_DOTCLK_DLY(host->dotclk_delay);\r\nwritel(vdctrl4, host->base + LCDC_VDCTRL4);\r\nwritel(fb_info->fix.smem_start +\r\nfb_info->fix.line_length * fb_info->var.yoffset,\r\nhost->base + host->devdata->next_buf);\r\nif (reenable)\r\nmxsfb_enable_controller(fb_info);\r\nreturn 0;\r\n}\r\nstatic int mxsfb_setcolreg(u_int regno, u_int red, u_int green, u_int blue,\r\nu_int transp, struct fb_info *fb_info)\r\n{\r\nunsigned int val;\r\nint ret = -EINVAL;\r\nif (fb_info->var.grayscale)\r\nred = green = blue = (19595 * red + 38470 * green +\r\n7471 * blue) >> 16;\r\nswitch (fb_info->fix.visual) {\r\ncase FB_VISUAL_TRUECOLOR:\r\nif (regno < 16) {\r\nu32 *pal = fb_info->pseudo_palette;\r\nval = chan_to_field(red, &fb_info->var.red);\r\nval |= chan_to_field(green, &fb_info->var.green);\r\nval |= chan_to_field(blue, &fb_info->var.blue);\r\npal[regno] = val;\r\nret = 0;\r\n}\r\nbreak;\r\ncase FB_VISUAL_STATIC_PSEUDOCOLOR:\r\ncase FB_VISUAL_PSEUDOCOLOR:\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int mxsfb_blank(int blank, struct fb_info *fb_info)\r\n{\r\nstruct mxsfb_info *host = to_imxfb_host(fb_info);\r\nswitch (blank) {\r\ncase FB_BLANK_POWERDOWN:\r\ncase FB_BLANK_VSYNC_SUSPEND:\r\ncase FB_BLANK_HSYNC_SUSPEND:\r\ncase FB_BLANK_NORMAL:\r\nif (host->enabled)\r\nmxsfb_disable_controller(fb_info);\r\nbreak;\r\ncase FB_BLANK_UNBLANK:\r\nif (!host->enabled)\r\nmxsfb_enable_controller(fb_info);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int mxsfb_pan_display(struct fb_var_screeninfo *var,\r\nstruct fb_info *fb_info)\r\n{\r\nstruct mxsfb_info *host = to_imxfb_host(fb_info);\r\nunsigned offset;\r\nif (var->xoffset != 0)\r\nreturn -EINVAL;\r\noffset = fb_info->fix.line_length * var->yoffset;\r\nwritel(fb_info->fix.smem_start + offset,\r\nhost->base + host->devdata->next_buf);\r\nreturn 0;\r\n}\r\nstatic int mxsfb_restore_mode(struct mxsfb_info *host,\r\nstruct fb_videomode *vmode)\r\n{\r\nstruct fb_info *fb_info = &host->fb_info;\r\nunsigned line_count;\r\nunsigned period;\r\nunsigned long pa, fbsize;\r\nint bits_per_pixel, ofs;\r\nu32 transfer_count, vdctrl0, vdctrl2, vdctrl3, vdctrl4, ctrl;\r\nctrl = readl(host->base + LCDC_CTRL);\r\nif (!(ctrl & CTRL_RUN))\r\nreturn -EINVAL;\r\nvdctrl0 = readl(host->base + LCDC_VDCTRL0);\r\nvdctrl2 = readl(host->base + LCDC_VDCTRL2);\r\nvdctrl3 = readl(host->base + LCDC_VDCTRL3);\r\nvdctrl4 = readl(host->base + LCDC_VDCTRL4);\r\ntransfer_count = readl(host->base + host->devdata->transfer_count);\r\nvmode->xres = TRANSFER_COUNT_GET_HCOUNT(transfer_count);\r\nvmode->yres = TRANSFER_COUNT_GET_VCOUNT(transfer_count);\r\nswitch (CTRL_GET_WORD_LENGTH(ctrl)) {\r\ncase 0:\r\nbits_per_pixel = 16;\r\nbreak;\r\ncase 3:\r\nbits_per_pixel = 32;\r\nbreak;\r\ncase 1:\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nfb_info->var.bits_per_pixel = bits_per_pixel;\r\nvmode->pixclock = KHZ2PICOS(clk_get_rate(host->clk) / 1000U);\r\nvmode->hsync_len = get_hsync_pulse_width(host, vdctrl2);\r\nvmode->left_margin = GET_HOR_WAIT_CNT(vdctrl3) - vmode->hsync_len;\r\nvmode->right_margin = VDCTRL2_GET_HSYNC_PERIOD(vdctrl2) -\r\nvmode->hsync_len - vmode->left_margin - vmode->xres;\r\nvmode->vsync_len = VDCTRL0_GET_VSYNC_PULSE_WIDTH(vdctrl0);\r\nperiod = readl(host->base + LCDC_VDCTRL1);\r\nvmode->upper_margin = GET_VERT_WAIT_CNT(vdctrl3) - vmode->vsync_len;\r\nvmode->lower_margin = period - vmode->vsync_len -\r\nvmode->upper_margin - vmode->yres;\r\nvmode->vmode = FB_VMODE_NONINTERLACED;\r\nvmode->sync = 0;\r\nif (vdctrl0 & VDCTRL0_HSYNC_ACT_HIGH)\r\nvmode->sync |= FB_SYNC_HOR_HIGH_ACT;\r\nif (vdctrl0 & VDCTRL0_VSYNC_ACT_HIGH)\r\nvmode->sync |= FB_SYNC_VERT_HIGH_ACT;\r\npr_debug("Reconstructed video mode:\n");\r\npr_debug("%dx%d, hsync: %u left: %u, right: %u, vsync: %u, upper: %u, lower: %u\n",\r\nvmode->xres, vmode->yres, vmode->hsync_len, vmode->left_margin,\r\nvmode->right_margin, vmode->vsync_len, vmode->upper_margin,\r\nvmode->lower_margin);\r\npr_debug("pixclk: %ldkHz\n", PICOS2KHZ(vmode->pixclock));\r\nhost->ld_intf_width = CTRL_GET_BUS_WIDTH(ctrl);\r\nhost->dotclk_delay = VDCTRL4_GET_DOTCLK_DLY(vdctrl4);\r\nfb_info->fix.line_length = vmode->xres * (bits_per_pixel >> 3);\r\npa = readl(host->base + host->devdata->cur_buf);\r\nfbsize = fb_info->fix.line_length * vmode->yres;\r\nif (pa < fb_info->fix.smem_start)\r\nreturn -EINVAL;\r\nif (pa + fbsize > fb_info->fix.smem_start + fb_info->fix.smem_len)\r\nreturn -EINVAL;\r\nofs = pa - fb_info->fix.smem_start;\r\nif (ofs) {\r\nmemmove(fb_info->screen_base, fb_info->screen_base + ofs, fbsize);\r\nwritel(fb_info->fix.smem_start, host->base + host->devdata->next_buf);\r\n}\r\nline_count = fb_info->fix.smem_len / fb_info->fix.line_length;\r\nfb_info->fix.ypanstep = 1;\r\nclk_prepare_enable(host->clk);\r\nhost->enabled = 1;\r\nreturn 0;\r\n}\r\nstatic int mxsfb_init_fbinfo_dt(struct mxsfb_info *host,\r\nstruct fb_videomode *vmode)\r\n{\r\nstruct fb_info *fb_info = &host->fb_info;\r\nstruct fb_var_screeninfo *var = &fb_info->var;\r\nstruct device *dev = &host->pdev->dev;\r\nstruct device_node *np = host->pdev->dev.of_node;\r\nstruct device_node *display_np;\r\nstruct videomode vm;\r\nu32 width;\r\nint ret;\r\ndisplay_np = of_parse_phandle(np, "display", 0);\r\nif (!display_np) {\r\ndev_err(dev, "failed to find display phandle\n");\r\nreturn -ENOENT;\r\n}\r\nret = of_property_read_u32(display_np, "bus-width", &width);\r\nif (ret < 0) {\r\ndev_err(dev, "failed to get property bus-width\n");\r\ngoto put_display_node;\r\n}\r\nswitch (width) {\r\ncase 8:\r\nhost->ld_intf_width = STMLCDIF_8BIT;\r\nbreak;\r\ncase 16:\r\nhost->ld_intf_width = STMLCDIF_16BIT;\r\nbreak;\r\ncase 18:\r\nhost->ld_intf_width = STMLCDIF_18BIT;\r\nbreak;\r\ncase 24:\r\nhost->ld_intf_width = STMLCDIF_24BIT;\r\nbreak;\r\ndefault:\r\ndev_err(dev, "invalid bus-width value\n");\r\nret = -EINVAL;\r\ngoto put_display_node;\r\n}\r\nret = of_property_read_u32(display_np, "bits-per-pixel",\r\n&var->bits_per_pixel);\r\nif (ret < 0) {\r\ndev_err(dev, "failed to get property bits-per-pixel\n");\r\ngoto put_display_node;\r\n}\r\nret = of_get_videomode(display_np, &vm, OF_USE_NATIVE_MODE);\r\nif (ret) {\r\ndev_err(dev, "failed to get videomode from DT\n");\r\ngoto put_display_node;\r\n}\r\nret = fb_videomode_from_videomode(&vm, vmode);\r\nif (ret < 0)\r\ngoto put_display_node;\r\nif (vm.flags & DISPLAY_FLAGS_DE_HIGH)\r\nhost->sync |= MXSFB_SYNC_DATA_ENABLE_HIGH_ACT;\r\nif (vm.flags & DISPLAY_FLAGS_PIXDATA_NEGEDGE)\r\nhost->sync |= MXSFB_SYNC_DOTCLK_FALLING_ACT;\r\nput_display_node:\r\nof_node_put(display_np);\r\nreturn ret;\r\n}\r\nstatic int mxsfb_init_fbinfo(struct mxsfb_info *host,\r\nstruct fb_videomode *vmode)\r\n{\r\nint ret;\r\nstruct fb_info *fb_info = &host->fb_info;\r\nstruct fb_var_screeninfo *var = &fb_info->var;\r\ndma_addr_t fb_phys;\r\nvoid *fb_virt;\r\nunsigned fb_size;\r\nfb_info->fbops = &mxsfb_ops;\r\nfb_info->flags = FBINFO_FLAG_DEFAULT | FBINFO_READS_FAST;\r\nstrlcpy(fb_info->fix.id, "mxs", sizeof(fb_info->fix.id));\r\nfb_info->fix.type = FB_TYPE_PACKED_PIXELS;\r\nfb_info->fix.ypanstep = 1;\r\nfb_info->fix.visual = FB_VISUAL_TRUECOLOR,\r\nfb_info->fix.accel = FB_ACCEL_NONE;\r\nret = mxsfb_init_fbinfo_dt(host, vmode);\r\nif (ret)\r\nreturn ret;\r\nvar->nonstd = 0;\r\nvar->activate = FB_ACTIVATE_NOW;\r\nvar->accel_flags = 0;\r\nvar->vmode = FB_VMODE_NONINTERLACED;\r\nfb_size = SZ_2M;\r\nfb_virt = alloc_pages_exact(fb_size, GFP_DMA);\r\nif (!fb_virt)\r\nreturn -ENOMEM;\r\nfb_phys = virt_to_phys(fb_virt);\r\nfb_info->fix.smem_start = fb_phys;\r\nfb_info->screen_base = fb_virt;\r\nfb_info->screen_size = fb_info->fix.smem_len = fb_size;\r\nif (mxsfb_restore_mode(host, vmode))\r\nmemset(fb_virt, 0, fb_size);\r\nreturn 0;\r\n}\r\nstatic void mxsfb_free_videomem(struct mxsfb_info *host)\r\n{\r\nstruct fb_info *fb_info = &host->fb_info;\r\nfree_pages_exact(fb_info->screen_base, fb_info->fix.smem_len);\r\n}\r\nstatic int mxsfb_probe(struct platform_device *pdev)\r\n{\r\nconst struct of_device_id *of_id =\r\nof_match_device(mxsfb_dt_ids, &pdev->dev);\r\nstruct resource *res;\r\nstruct mxsfb_info *host;\r\nstruct fb_info *fb_info;\r\nstruct fb_videomode *mode;\r\nint ret;\r\nif (of_id)\r\npdev->id_entry = of_id->data;\r\nfb_info = framebuffer_alloc(sizeof(struct mxsfb_info), &pdev->dev);\r\nif (!fb_info) {\r\ndev_err(&pdev->dev, "Failed to allocate fbdev\n");\r\nreturn -ENOMEM;\r\n}\r\nmode = devm_kzalloc(&pdev->dev, sizeof(struct fb_videomode),\r\nGFP_KERNEL);\r\nif (mode == NULL)\r\nreturn -ENOMEM;\r\nhost = to_imxfb_host(fb_info);\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nhost->base = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(host->base)) {\r\nret = PTR_ERR(host->base);\r\ngoto fb_release;\r\n}\r\nhost->pdev = pdev;\r\nplatform_set_drvdata(pdev, host);\r\nhost->devdata = &mxsfb_devdata[pdev->id_entry->driver_data];\r\nhost->clk = devm_clk_get(&host->pdev->dev, NULL);\r\nif (IS_ERR(host->clk)) {\r\nret = PTR_ERR(host->clk);\r\ngoto fb_release;\r\n}\r\nhost->clk_axi = devm_clk_get(&host->pdev->dev, "axi");\r\nif (IS_ERR(host->clk_axi))\r\nhost->clk_axi = NULL;\r\nhost->clk_disp_axi = devm_clk_get(&host->pdev->dev, "disp_axi");\r\nif (IS_ERR(host->clk_disp_axi))\r\nhost->clk_disp_axi = NULL;\r\nhost->reg_lcd = devm_regulator_get(&pdev->dev, "lcd");\r\nif (IS_ERR(host->reg_lcd))\r\nhost->reg_lcd = NULL;\r\nfb_info->pseudo_palette = devm_kzalloc(&pdev->dev, sizeof(u32) * 16,\r\nGFP_KERNEL);\r\nif (!fb_info->pseudo_palette) {\r\nret = -ENOMEM;\r\ngoto fb_release;\r\n}\r\nret = mxsfb_init_fbinfo(host, mode);\r\nif (ret != 0)\r\ngoto fb_release;\r\nfb_videomode_to_var(&fb_info->var, mode);\r\nmxsfb_check_var(&fb_info->var, fb_info);\r\nplatform_set_drvdata(pdev, fb_info);\r\nret = register_framebuffer(fb_info);\r\nif (ret != 0) {\r\ndev_err(&pdev->dev,"Failed to register framebuffer\n");\r\ngoto fb_destroy;\r\n}\r\nif (!host->enabled) {\r\nwritel(0, host->base + LCDC_CTRL);\r\nmxsfb_set_par(fb_info);\r\nmxsfb_enable_controller(fb_info);\r\n}\r\ndev_info(&pdev->dev, "initialized\n");\r\nreturn 0;\r\nfb_destroy:\r\nif (host->enabled)\r\nclk_disable_unprepare(host->clk);\r\nfb_release:\r\nframebuffer_release(fb_info);\r\nreturn ret;\r\n}\r\nstatic int mxsfb_remove(struct platform_device *pdev)\r\n{\r\nstruct fb_info *fb_info = platform_get_drvdata(pdev);\r\nstruct mxsfb_info *host = to_imxfb_host(fb_info);\r\nif (host->enabled)\r\nmxsfb_disable_controller(fb_info);\r\nunregister_framebuffer(fb_info);\r\nmxsfb_free_videomem(host);\r\nframebuffer_release(fb_info);\r\nreturn 0;\r\n}\r\nstatic void mxsfb_shutdown(struct platform_device *pdev)\r\n{\r\nstruct fb_info *fb_info = platform_get_drvdata(pdev);\r\nstruct mxsfb_info *host = to_imxfb_host(fb_info);\r\nwritel(CTRL_RUN, host->base + LCDC_CTRL + REG_CLR);\r\n}
