static inline struct u300_gpio *to_u300_gpio(struct gpio_chip *chip)\r\n{\r\nreturn container_of(chip, struct u300_gpio, chip);\r\n}\r\nstatic int u300_gpio_request(struct gpio_chip *chip, unsigned offset)\r\n{\r\nint gpio = chip->base + offset;\r\nreturn pinctrl_request_gpio(gpio);\r\n}\r\nstatic void u300_gpio_free(struct gpio_chip *chip, unsigned offset)\r\n{\r\nint gpio = chip->base + offset;\r\npinctrl_free_gpio(gpio);\r\n}\r\nstatic int u300_gpio_get(struct gpio_chip *chip, unsigned offset)\r\n{\r\nstruct u300_gpio *gpio = to_u300_gpio(chip);\r\nreturn readl(U300_PIN_REG(offset, dir)) & U300_PIN_BIT(offset);\r\n}\r\nstatic void u300_gpio_set(struct gpio_chip *chip, unsigned offset, int value)\r\n{\r\nstruct u300_gpio *gpio = to_u300_gpio(chip);\r\nunsigned long flags;\r\nu32 val;\r\nlocal_irq_save(flags);\r\nval = readl(U300_PIN_REG(offset, dor));\r\nif (value)\r\nwritel(val | U300_PIN_BIT(offset), U300_PIN_REG(offset, dor));\r\nelse\r\nwritel(val & ~U300_PIN_BIT(offset), U300_PIN_REG(offset, dor));\r\nlocal_irq_restore(flags);\r\n}\r\nstatic int u300_gpio_direction_input(struct gpio_chip *chip, unsigned offset)\r\n{\r\nstruct u300_gpio *gpio = to_u300_gpio(chip);\r\nunsigned long flags;\r\nu32 val;\r\nlocal_irq_save(flags);\r\nval = readl(U300_PIN_REG(offset, pcr));\r\nval &= ~(U300_GPIO_PXPCR_PIN_MODE_MASK << ((offset & 0x07) << 1));\r\nwritel(val, U300_PIN_REG(offset, pcr));\r\nlocal_irq_restore(flags);\r\nreturn 0;\r\n}\r\nstatic int u300_gpio_direction_output(struct gpio_chip *chip, unsigned offset,\r\nint value)\r\n{\r\nstruct u300_gpio *gpio = to_u300_gpio(chip);\r\nunsigned long flags;\r\nu32 oldmode;\r\nu32 val;\r\nlocal_irq_save(flags);\r\nval = readl(U300_PIN_REG(offset, pcr));\r\noldmode = val & (U300_GPIO_PXPCR_PIN_MODE_MASK <<\r\n((offset & 0x07) << 1));\r\nif (oldmode == 0) {\r\nval &= ~(U300_GPIO_PXPCR_PIN_MODE_MASK <<\r\n((offset & 0x07) << 1));\r\nval |= (U300_GPIO_PXPCR_PIN_MODE_OUTPUT_PUSH_PULL\r\n<< ((offset & 0x07) << 1));\r\nwritel(val, U300_PIN_REG(offset, pcr));\r\n}\r\nu300_gpio_set(chip, offset, value);\r\nlocal_irq_restore(flags);\r\nreturn 0;\r\n}\r\nint u300_gpio_config_get(struct gpio_chip *chip,\r\nunsigned offset,\r\nunsigned long *config)\r\n{\r\nstruct u300_gpio *gpio = to_u300_gpio(chip);\r\nenum pin_config_param param = (enum pin_config_param) *config;\r\nbool biasmode;\r\nu32 drmode;\r\nbiasmode = !!(readl(U300_PIN_REG(offset, per)) & U300_PIN_BIT(offset));\r\ndrmode = readl(U300_PIN_REG(offset, pcr));\r\ndrmode &= (U300_GPIO_PXPCR_PIN_MODE_MASK << ((offset & 0x07) << 1));\r\ndrmode >>= ((offset & 0x07) << 1);\r\nswitch (param) {\r\ncase PIN_CONFIG_BIAS_HIGH_IMPEDANCE:\r\n*config = 0;\r\nif (biasmode)\r\nreturn 0;\r\nelse\r\nreturn -EINVAL;\r\nbreak;\r\ncase PIN_CONFIG_BIAS_PULL_UP:\r\n*config = 0;\r\nif (!biasmode)\r\nreturn 0;\r\nelse\r\nreturn -EINVAL;\r\nbreak;\r\ncase PIN_CONFIG_DRIVE_PUSH_PULL:\r\n*config = 0;\r\nif (drmode == U300_GPIO_PXPCR_PIN_MODE_OUTPUT_PUSH_PULL)\r\nreturn 0;\r\nelse\r\nreturn -EINVAL;\r\nbreak;\r\ncase PIN_CONFIG_DRIVE_OPEN_DRAIN:\r\n*config = 0;\r\nif (drmode == U300_GPIO_PXPCR_PIN_MODE_OUTPUT_OPEN_DRAIN)\r\nreturn 0;\r\nelse\r\nreturn -EINVAL;\r\nbreak;\r\ncase PIN_CONFIG_DRIVE_OPEN_SOURCE:\r\n*config = 0;\r\nif (drmode == U300_GPIO_PXPCR_PIN_MODE_OUTPUT_OPEN_SOURCE)\r\nreturn 0;\r\nelse\r\nreturn -EINVAL;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn -ENOTSUPP;\r\n}\r\nint u300_gpio_config_set(struct gpio_chip *chip, unsigned offset,\r\nenum pin_config_param param)\r\n{\r\nstruct u300_gpio *gpio = to_u300_gpio(chip);\r\nunsigned long flags;\r\nu32 val;\r\nlocal_irq_save(flags);\r\nswitch (param) {\r\ncase PIN_CONFIG_BIAS_DISABLE:\r\ncase PIN_CONFIG_BIAS_HIGH_IMPEDANCE:\r\nval = readl(U300_PIN_REG(offset, per));\r\nwritel(val | U300_PIN_BIT(offset), U300_PIN_REG(offset, per));\r\nbreak;\r\ncase PIN_CONFIG_BIAS_PULL_UP:\r\nval = readl(U300_PIN_REG(offset, per));\r\nwritel(val & ~U300_PIN_BIT(offset), U300_PIN_REG(offset, per));\r\nbreak;\r\ncase PIN_CONFIG_DRIVE_PUSH_PULL:\r\nval = readl(U300_PIN_REG(offset, pcr));\r\nval &= ~(U300_GPIO_PXPCR_PIN_MODE_MASK\r\n<< ((offset & 0x07) << 1));\r\nval |= (U300_GPIO_PXPCR_PIN_MODE_OUTPUT_PUSH_PULL\r\n<< ((offset & 0x07) << 1));\r\nwritel(val, U300_PIN_REG(offset, pcr));\r\nbreak;\r\ncase PIN_CONFIG_DRIVE_OPEN_DRAIN:\r\nval = readl(U300_PIN_REG(offset, pcr));\r\nval &= ~(U300_GPIO_PXPCR_PIN_MODE_MASK\r\n<< ((offset & 0x07) << 1));\r\nval |= (U300_GPIO_PXPCR_PIN_MODE_OUTPUT_OPEN_DRAIN\r\n<< ((offset & 0x07) << 1));\r\nwritel(val, U300_PIN_REG(offset, pcr));\r\nbreak;\r\ncase PIN_CONFIG_DRIVE_OPEN_SOURCE:\r\nval = readl(U300_PIN_REG(offset, pcr));\r\nval &= ~(U300_GPIO_PXPCR_PIN_MODE_MASK\r\n<< ((offset & 0x07) << 1));\r\nval |= (U300_GPIO_PXPCR_PIN_MODE_OUTPUT_OPEN_SOURCE\r\n<< ((offset & 0x07) << 1));\r\nwritel(val, U300_PIN_REG(offset, pcr));\r\nbreak;\r\ndefault:\r\nlocal_irq_restore(flags);\r\ndev_err(gpio->dev, "illegal configuration requested\n");\r\nreturn -EINVAL;\r\n}\r\nlocal_irq_restore(flags);\r\nreturn 0;\r\n}\r\nstatic void u300_toggle_trigger(struct u300_gpio *gpio, unsigned offset)\r\n{\r\nu32 val;\r\nval = readl(U300_PIN_REG(offset, icr));\r\nif (u300_gpio_get(&gpio->chip, offset)) {\r\nwritel(val & ~U300_PIN_BIT(offset), U300_PIN_REG(offset, icr));\r\ndev_dbg(gpio->dev, "next IRQ on falling edge on pin %d\n",\r\noffset);\r\n} else {\r\nwritel(val | U300_PIN_BIT(offset), U300_PIN_REG(offset, icr));\r\ndev_dbg(gpio->dev, "next IRQ on rising edge on pin %d\n",\r\noffset);\r\n}\r\n}\r\nstatic int u300_gpio_irq_type(struct irq_data *d, unsigned trigger)\r\n{\r\nstruct gpio_chip *chip = irq_data_get_irq_chip_data(d);\r\nstruct u300_gpio *gpio = to_u300_gpio(chip);\r\nstruct u300_gpio_port *port = &gpio->ports[d->hwirq >> 3];\r\nint offset = d->hwirq;\r\nu32 val;\r\nif ((trigger & IRQF_TRIGGER_RISING) &&\r\n(trigger & IRQF_TRIGGER_FALLING)) {\r\ndev_dbg(gpio->dev,\r\n"trigger on both rising and falling edge on pin %d\n",\r\noffset);\r\nport->toggle_edge_mode |= U300_PIN_BIT(offset);\r\nu300_toggle_trigger(gpio, offset);\r\n} else if (trigger & IRQF_TRIGGER_RISING) {\r\ndev_dbg(gpio->dev, "trigger on rising edge on pin %d\n",\r\noffset);\r\nval = readl(U300_PIN_REG(offset, icr));\r\nwritel(val | U300_PIN_BIT(offset), U300_PIN_REG(offset, icr));\r\nport->toggle_edge_mode &= ~U300_PIN_BIT(offset);\r\n} else if (trigger & IRQF_TRIGGER_FALLING) {\r\ndev_dbg(gpio->dev, "trigger on falling edge on pin %d\n",\r\noffset);\r\nval = readl(U300_PIN_REG(offset, icr));\r\nwritel(val & ~U300_PIN_BIT(offset), U300_PIN_REG(offset, icr));\r\nport->toggle_edge_mode &= ~U300_PIN_BIT(offset);\r\n}\r\nreturn 0;\r\n}\r\nstatic void u300_gpio_irq_enable(struct irq_data *d)\r\n{\r\nstruct gpio_chip *chip = irq_data_get_irq_chip_data(d);\r\nstruct u300_gpio *gpio = to_u300_gpio(chip);\r\nstruct u300_gpio_port *port = &gpio->ports[d->hwirq >> 3];\r\nint offset = d->hwirq;\r\nu32 val;\r\nunsigned long flags;\r\ndev_dbg(gpio->dev, "enable IRQ for hwirq %lu on port %s, offset %d\n",\r\nd->hwirq, port->name, offset);\r\nlocal_irq_save(flags);\r\nval = readl(U300_PIN_REG(offset, ien));\r\nwritel(val | U300_PIN_BIT(offset), U300_PIN_REG(offset, ien));\r\nlocal_irq_restore(flags);\r\n}\r\nstatic void u300_gpio_irq_disable(struct irq_data *d)\r\n{\r\nstruct gpio_chip *chip = irq_data_get_irq_chip_data(d);\r\nstruct u300_gpio *gpio = to_u300_gpio(chip);\r\nint offset = d->hwirq;\r\nu32 val;\r\nunsigned long flags;\r\nlocal_irq_save(flags);\r\nval = readl(U300_PIN_REG(offset, ien));\r\nwritel(val & ~U300_PIN_BIT(offset), U300_PIN_REG(offset, ien));\r\nlocal_irq_restore(flags);\r\n}\r\nstatic void u300_gpio_irq_handler(unsigned irq, struct irq_desc *desc)\r\n{\r\nstruct irq_chip *parent_chip = irq_get_chip(irq);\r\nstruct gpio_chip *chip = irq_get_handler_data(irq);\r\nstruct u300_gpio *gpio = to_u300_gpio(chip);\r\nstruct u300_gpio_port *port = &gpio->ports[irq - chip->base];\r\nint pinoffset = port->number << 3;\r\nunsigned long val;\r\nchained_irq_enter(parent_chip, desc);\r\nval = readl(U300_PIN_REG(pinoffset, iev));\r\nval &= 0xFFU;\r\nwritel(val, U300_PIN_REG(pinoffset, iev));\r\nif (val != 0) {\r\nint irqoffset;\r\nfor_each_set_bit(irqoffset, &val, U300_GPIO_PINS_PER_PORT) {\r\nint offset = pinoffset + irqoffset;\r\nint pin_irq = irq_find_mapping(chip->irqdomain, offset);\r\ndev_dbg(gpio->dev, "GPIO IRQ %d on pin %d\n",\r\npin_irq, offset);\r\ngeneric_handle_irq(pin_irq);\r\nif (port->toggle_edge_mode & U300_PIN_BIT(offset))\r\nu300_toggle_trigger(gpio, offset);\r\n}\r\n}\r\nchained_irq_exit(parent_chip, desc);\r\n}\r\nstatic void __init u300_gpio_init_pin(struct u300_gpio *gpio,\r\nint offset,\r\nconst struct u300_gpio_confdata *conf)\r\n{\r\nif (conf->output) {\r\nu300_gpio_direction_output(&gpio->chip, offset, conf->outval);\r\nu300_gpio_config_set(&gpio->chip, offset,\r\nPIN_CONFIG_BIAS_HIGH_IMPEDANCE);\r\nu300_gpio_config_set(&gpio->chip, offset,\r\nPIN_CONFIG_DRIVE_PUSH_PULL);\r\ndev_dbg(gpio->dev, "set up pin %d as output, value: %d\n",\r\noffset, conf->outval);\r\n} else {\r\nu300_gpio_direction_input(&gpio->chip, offset);\r\nu300_gpio_set(&gpio->chip, offset, 0);\r\nu300_gpio_config_set(&gpio->chip, offset, conf->bias_mode);\r\ndev_dbg(gpio->dev, "set up pin %d as input, bias: %04x\n",\r\noffset, conf->bias_mode);\r\n}\r\n}\r\nstatic void __init u300_gpio_init_coh901571(struct u300_gpio *gpio)\r\n{\r\nint i, j;\r\nfor (i = 0; i < U300_GPIO_NUM_PORTS; i++) {\r\nfor (j = 0; j < 8; j++) {\r\nconst struct u300_gpio_confdata *conf;\r\nint offset = (i*8) + j;\r\nconf = &bs335_gpio_config[i][j];\r\nu300_gpio_init_pin(gpio, offset, conf);\r\n}\r\n}\r\n}\r\nstatic int __init u300_gpio_probe(struct platform_device *pdev)\r\n{\r\nstruct u300_gpio *gpio;\r\nstruct resource *memres;\r\nint err = 0;\r\nint portno;\r\nu32 val;\r\nu32 ifr;\r\nint i;\r\ngpio = devm_kzalloc(&pdev->dev, sizeof(struct u300_gpio), GFP_KERNEL);\r\nif (gpio == NULL)\r\nreturn -ENOMEM;\r\ngpio->chip = u300_gpio_chip;\r\ngpio->chip.ngpio = U300_GPIO_NUM_PORTS * U300_GPIO_PINS_PER_PORT;\r\ngpio->chip.dev = &pdev->dev;\r\ngpio->chip.base = 0;\r\ngpio->dev = &pdev->dev;\r\nmemres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\ngpio->base = devm_ioremap_resource(&pdev->dev, memres);\r\nif (IS_ERR(gpio->base))\r\nreturn PTR_ERR(gpio->base);\r\ngpio->clk = devm_clk_get(gpio->dev, NULL);\r\nif (IS_ERR(gpio->clk)) {\r\nerr = PTR_ERR(gpio->clk);\r\ndev_err(gpio->dev, "could not get GPIO clock\n");\r\nreturn err;\r\n}\r\nerr = clk_prepare_enable(gpio->clk);\r\nif (err) {\r\ndev_err(gpio->dev, "could not enable GPIO clock\n");\r\nreturn err;\r\n}\r\ndev_info(gpio->dev,\r\n"initializing GPIO Controller COH 901 571/3\n");\r\ngpio->stride = U300_GPIO_PORT_STRIDE;\r\ngpio->pcr = U300_GPIO_PXPCR;\r\ngpio->dor = U300_GPIO_PXPDOR;\r\ngpio->dir = U300_GPIO_PXPDIR;\r\ngpio->per = U300_GPIO_PXPER;\r\ngpio->icr = U300_GPIO_PXICR;\r\ngpio->ien = U300_GPIO_PXIEN;\r\ngpio->iev = U300_GPIO_PXIEV;\r\nifr = U300_GPIO_PXIFR;\r\nval = readl(gpio->base + U300_GPIO_CR);\r\ndev_info(gpio->dev, "COH901571/3 block version: %d, " \\r\n"number of cores: %d totalling %d pins\n",\r\n((val & 0x000001FC) >> 2),\r\n((val & 0x0000FE00) >> 9),\r\n((val & 0x0000FE00) >> 9) * 8);\r\nwritel(U300_GPIO_CR_BLOCK_CLKRQ_ENABLE,\r\ngpio->base + U300_GPIO_CR);\r\nu300_gpio_init_coh901571(gpio);\r\n#ifdef CONFIG_OF_GPIO\r\ngpio->chip.of_node = pdev->dev.of_node;\r\n#endif\r\nerr = gpiochip_add(&gpio->chip);\r\nif (err) {\r\ndev_err(gpio->dev, "unable to add gpiochip: %d\n", err);\r\ngoto err_no_chip;\r\n}\r\nerr = gpiochip_irqchip_add(&gpio->chip,\r\n&u300_gpio_irqchip,\r\n0,\r\nhandle_simple_irq,\r\nIRQ_TYPE_EDGE_FALLING);\r\nif (err) {\r\ndev_err(gpio->dev, "no GPIO irqchip\n");\r\ngoto err_no_irqchip;\r\n}\r\nfor (portno = 0 ; portno < U300_GPIO_NUM_PORTS; portno++) {\r\nstruct u300_gpio_port *port = &gpio->ports[portno];\r\nsnprintf(port->name, 8, "gpio%d", portno);\r\nport->number = portno;\r\nport->gpio = gpio;\r\nport->irq = platform_get_irq(pdev, portno);\r\ngpiochip_set_chained_irqchip(&gpio->chip,\r\n&u300_gpio_irqchip,\r\nport->irq,\r\nu300_gpio_irq_handler);\r\nwritel(0x0, gpio->base + portno * gpio->stride + ifr);\r\n}\r\ndev_dbg(gpio->dev, "initialized %d GPIO ports\n", portno);\r\nfor (i = 0; i < ARRAY_SIZE(coh901_pintable); i++) {\r\nstruct coh901_pinpair *p = &coh901_pintable[i];\r\nerr = gpiochip_add_pin_range(&gpio->chip, "pinctrl-u300",\r\np->offset, p->pin_base, 1);\r\nif (err)\r\ngoto err_no_range;\r\n}\r\nplatform_set_drvdata(pdev, gpio);\r\nreturn 0;\r\nerr_no_range:\r\nerr_no_irqchip:\r\ngpiochip_remove(&gpio->chip);\r\nerr_no_chip:\r\nclk_disable_unprepare(gpio->clk);\r\ndev_err(&pdev->dev, "module ERROR:%d\n", err);\r\nreturn err;\r\n}\r\nstatic int __exit u300_gpio_remove(struct platform_device *pdev)\r\n{\r\nstruct u300_gpio *gpio = platform_get_drvdata(pdev);\r\nwritel(0x00000000U, gpio->base + U300_GPIO_CR);\r\ngpiochip_remove(&gpio->chip);\r\nclk_disable_unprepare(gpio->clk);\r\nreturn 0;\r\n}\r\nstatic int __init u300_gpio_init(void)\r\n{\r\nreturn platform_driver_probe(&u300_gpio_driver, u300_gpio_probe);\r\n}\r\nstatic void __exit u300_gpio_exit(void)\r\n{\r\nplatform_driver_unregister(&u300_gpio_driver);\r\n}
