static inline bool has_target(void)\r\n{\r\nreturn cpufreq_driver->target_index || cpufreq_driver->target;\r\n}\r\nstatic int __init init_cpufreq_transition_notifier_list(void)\r\n{\r\nsrcu_init_notifier_head(&cpufreq_transition_notifier_list);\r\ninit_cpufreq_transition_notifier_list_called = true;\r\nreturn 0;\r\n}\r\nstatic int cpufreq_disabled(void)\r\n{\r\nreturn off;\r\n}\r\nvoid disable_cpufreq(void)\r\n{\r\noff = 1;\r\n}\r\nbool have_governor_per_policy(void)\r\n{\r\nreturn !!(cpufreq_driver->flags & CPUFREQ_HAVE_GOVERNOR_PER_POLICY);\r\n}\r\nstruct kobject *get_governor_parent_kobj(struct cpufreq_policy *policy)\r\n{\r\nif (have_governor_per_policy())\r\nreturn &policy->kobj;\r\nelse\r\nreturn cpufreq_global_kobject;\r\n}\r\nstatic inline u64 get_cpu_idle_time_jiffy(unsigned int cpu, u64 *wall)\r\n{\r\nu64 idle_time;\r\nu64 cur_wall_time;\r\nu64 busy_time;\r\ncur_wall_time = jiffies64_to_cputime64(get_jiffies_64());\r\nbusy_time = kcpustat_cpu(cpu).cpustat[CPUTIME_USER];\r\nbusy_time += kcpustat_cpu(cpu).cpustat[CPUTIME_SYSTEM];\r\nbusy_time += kcpustat_cpu(cpu).cpustat[CPUTIME_IRQ];\r\nbusy_time += kcpustat_cpu(cpu).cpustat[CPUTIME_SOFTIRQ];\r\nbusy_time += kcpustat_cpu(cpu).cpustat[CPUTIME_STEAL];\r\nbusy_time += kcpustat_cpu(cpu).cpustat[CPUTIME_NICE];\r\nidle_time = cur_wall_time - busy_time;\r\nif (wall)\r\n*wall = cputime_to_usecs(cur_wall_time);\r\nreturn cputime_to_usecs(idle_time);\r\n}\r\nu64 get_cpu_idle_time(unsigned int cpu, u64 *wall, int io_busy)\r\n{\r\nu64 idle_time = get_cpu_idle_time_us(cpu, io_busy ? wall : NULL);\r\nif (idle_time == -1ULL)\r\nreturn get_cpu_idle_time_jiffy(cpu, wall);\r\nelse if (!io_busy)\r\nidle_time += get_cpu_iowait_time_us(cpu, wall);\r\nreturn idle_time;\r\n}\r\nint cpufreq_generic_init(struct cpufreq_policy *policy,\r\nstruct cpufreq_frequency_table *table,\r\nunsigned int transition_latency)\r\n{\r\nint ret;\r\nret = cpufreq_table_validate_and_show(policy, table);\r\nif (ret) {\r\npr_err("%s: invalid frequency table: %d\n", __func__, ret);\r\nreturn ret;\r\n}\r\npolicy->cpuinfo.transition_latency = transition_latency;\r\ncpumask_setall(policy->cpus);\r\nreturn 0;\r\n}\r\nunsigned int cpufreq_generic_get(unsigned int cpu)\r\n{\r\nstruct cpufreq_policy *policy = per_cpu(cpufreq_cpu_data, cpu);\r\nif (!policy || IS_ERR(policy->clk)) {\r\npr_err("%s: No %s associated to cpu: %d\n",\r\n__func__, policy ? "clk" : "policy", cpu);\r\nreturn 0;\r\n}\r\nreturn clk_get_rate(policy->clk) / 1000;\r\n}\r\nstruct cpufreq_policy *cpufreq_cpu_get_raw(unsigned int cpu)\r\n{\r\nreturn per_cpu(cpufreq_cpu_data, cpu);\r\n}\r\nstruct cpufreq_policy *cpufreq_cpu_get(unsigned int cpu)\r\n{\r\nstruct cpufreq_policy *policy = NULL;\r\nunsigned long flags;\r\nif (cpu >= nr_cpu_ids)\r\nreturn NULL;\r\nif (!down_read_trylock(&cpufreq_rwsem))\r\nreturn NULL;\r\nread_lock_irqsave(&cpufreq_driver_lock, flags);\r\nif (cpufreq_driver) {\r\npolicy = per_cpu(cpufreq_cpu_data, cpu);\r\nif (policy)\r\nkobject_get(&policy->kobj);\r\n}\r\nread_unlock_irqrestore(&cpufreq_driver_lock, flags);\r\nif (!policy)\r\nup_read(&cpufreq_rwsem);\r\nreturn policy;\r\n}\r\nvoid cpufreq_cpu_put(struct cpufreq_policy *policy)\r\n{\r\nkobject_put(&policy->kobj);\r\nup_read(&cpufreq_rwsem);\r\n}\r\nstatic void adjust_jiffies(unsigned long val, struct cpufreq_freqs *ci)\r\n{\r\n#ifndef CONFIG_SMP\r\nstatic unsigned long l_p_j_ref;\r\nstatic unsigned int l_p_j_ref_freq;\r\nif (ci->flags & CPUFREQ_CONST_LOOPS)\r\nreturn;\r\nif (!l_p_j_ref_freq) {\r\nl_p_j_ref = loops_per_jiffy;\r\nl_p_j_ref_freq = ci->old;\r\npr_debug("saving %lu as reference value for loops_per_jiffy; freq is %u kHz\n",\r\nl_p_j_ref, l_p_j_ref_freq);\r\n}\r\nif (val == CPUFREQ_POSTCHANGE && ci->old != ci->new) {\r\nloops_per_jiffy = cpufreq_scale(l_p_j_ref, l_p_j_ref_freq,\r\nci->new);\r\npr_debug("scaling loops_per_jiffy to %lu for frequency %u kHz\n",\r\nloops_per_jiffy, ci->new);\r\n}\r\n#endif\r\n}\r\nstatic void __cpufreq_notify_transition(struct cpufreq_policy *policy,\r\nstruct cpufreq_freqs *freqs, unsigned int state)\r\n{\r\nBUG_ON(irqs_disabled());\r\nif (cpufreq_disabled())\r\nreturn;\r\nfreqs->flags = cpufreq_driver->flags;\r\npr_debug("notification %u of frequency transition to %u kHz\n",\r\nstate, freqs->new);\r\nswitch (state) {\r\ncase CPUFREQ_PRECHANGE:\r\nif (!(cpufreq_driver->flags & CPUFREQ_CONST_LOOPS)) {\r\nif ((policy) && (policy->cpu == freqs->cpu) &&\r\n(policy->cur) && (policy->cur != freqs->old)) {\r\npr_debug("Warning: CPU frequency is %u, cpufreq assumed %u kHz\n",\r\nfreqs->old, policy->cur);\r\nfreqs->old = policy->cur;\r\n}\r\n}\r\nsrcu_notifier_call_chain(&cpufreq_transition_notifier_list,\r\nCPUFREQ_PRECHANGE, freqs);\r\nadjust_jiffies(CPUFREQ_PRECHANGE, freqs);\r\nbreak;\r\ncase CPUFREQ_POSTCHANGE:\r\nadjust_jiffies(CPUFREQ_POSTCHANGE, freqs);\r\npr_debug("FREQ: %lu - CPU: %lu\n",\r\n(unsigned long)freqs->new, (unsigned long)freqs->cpu);\r\ntrace_cpu_frequency(freqs->new, freqs->cpu);\r\nsrcu_notifier_call_chain(&cpufreq_transition_notifier_list,\r\nCPUFREQ_POSTCHANGE, freqs);\r\nif (likely(policy) && likely(policy->cpu == freqs->cpu))\r\npolicy->cur = freqs->new;\r\nbreak;\r\n}\r\n}\r\nstatic void cpufreq_notify_transition(struct cpufreq_policy *policy,\r\nstruct cpufreq_freqs *freqs, unsigned int state)\r\n{\r\nfor_each_cpu(freqs->cpu, policy->cpus)\r\n__cpufreq_notify_transition(policy, freqs, state);\r\n}\r\nstatic void cpufreq_notify_post_transition(struct cpufreq_policy *policy,\r\nstruct cpufreq_freqs *freqs, int transition_failed)\r\n{\r\ncpufreq_notify_transition(policy, freqs, CPUFREQ_POSTCHANGE);\r\nif (!transition_failed)\r\nreturn;\r\nswap(freqs->old, freqs->new);\r\ncpufreq_notify_transition(policy, freqs, CPUFREQ_PRECHANGE);\r\ncpufreq_notify_transition(policy, freqs, CPUFREQ_POSTCHANGE);\r\n}\r\nvoid cpufreq_freq_transition_begin(struct cpufreq_policy *policy,\r\nstruct cpufreq_freqs *freqs)\r\n{\r\nWARN_ON(!(cpufreq_driver->flags & CPUFREQ_ASYNC_NOTIFICATION)\r\n&& current == policy->transition_task);\r\nwait:\r\nwait_event(policy->transition_wait, !policy->transition_ongoing);\r\nspin_lock(&policy->transition_lock);\r\nif (unlikely(policy->transition_ongoing)) {\r\nspin_unlock(&policy->transition_lock);\r\ngoto wait;\r\n}\r\npolicy->transition_ongoing = true;\r\npolicy->transition_task = current;\r\nspin_unlock(&policy->transition_lock);\r\ncpufreq_notify_transition(policy, freqs, CPUFREQ_PRECHANGE);\r\n}\r\nvoid cpufreq_freq_transition_end(struct cpufreq_policy *policy,\r\nstruct cpufreq_freqs *freqs, int transition_failed)\r\n{\r\nif (unlikely(WARN_ON(!policy->transition_ongoing)))\r\nreturn;\r\ncpufreq_notify_post_transition(policy, freqs, transition_failed);\r\npolicy->transition_ongoing = false;\r\npolicy->transition_task = NULL;\r\nwake_up(&policy->transition_wait);\r\n}\r\nstatic ssize_t show_boost(struct kobject *kobj,\r\nstruct attribute *attr, char *buf)\r\n{\r\nreturn sprintf(buf, "%d\n", cpufreq_driver->boost_enabled);\r\n}\r\nstatic ssize_t store_boost(struct kobject *kobj, struct attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nint ret, enable;\r\nret = sscanf(buf, "%d", &enable);\r\nif (ret != 1 || enable < 0 || enable > 1)\r\nreturn -EINVAL;\r\nif (cpufreq_boost_trigger_state(enable)) {\r\npr_err("%s: Cannot %s BOOST!\n",\r\n__func__, enable ? "enable" : "disable");\r\nreturn -EINVAL;\r\n}\r\npr_debug("%s: cpufreq BOOST %s\n",\r\n__func__, enable ? "enabled" : "disabled");\r\nreturn count;\r\n}\r\nstatic struct cpufreq_governor *find_governor(const char *str_governor)\r\n{\r\nstruct cpufreq_governor *t;\r\nfor_each_governor(t)\r\nif (!strncasecmp(str_governor, t->name, CPUFREQ_NAME_LEN))\r\nreturn t;\r\nreturn NULL;\r\n}\r\nstatic int cpufreq_parse_governor(char *str_governor, unsigned int *policy,\r\nstruct cpufreq_governor **governor)\r\n{\r\nint err = -EINVAL;\r\nif (!cpufreq_driver)\r\ngoto out;\r\nif (cpufreq_driver->setpolicy) {\r\nif (!strncasecmp(str_governor, "performance", CPUFREQ_NAME_LEN)) {\r\n*policy = CPUFREQ_POLICY_PERFORMANCE;\r\nerr = 0;\r\n} else if (!strncasecmp(str_governor, "powersave",\r\nCPUFREQ_NAME_LEN)) {\r\n*policy = CPUFREQ_POLICY_POWERSAVE;\r\nerr = 0;\r\n}\r\n} else {\r\nstruct cpufreq_governor *t;\r\nmutex_lock(&cpufreq_governor_mutex);\r\nt = find_governor(str_governor);\r\nif (t == NULL) {\r\nint ret;\r\nmutex_unlock(&cpufreq_governor_mutex);\r\nret = request_module("cpufreq_%s", str_governor);\r\nmutex_lock(&cpufreq_governor_mutex);\r\nif (ret == 0)\r\nt = find_governor(str_governor);\r\n}\r\nif (t != NULL) {\r\n*governor = t;\r\nerr = 0;\r\n}\r\nmutex_unlock(&cpufreq_governor_mutex);\r\n}\r\nout:\r\nreturn err;\r\n}\r\nstatic ssize_t show_scaling_cur_freq(struct cpufreq_policy *policy, char *buf)\r\n{\r\nssize_t ret;\r\nif (cpufreq_driver && cpufreq_driver->setpolicy && cpufreq_driver->get)\r\nret = sprintf(buf, "%u\n", cpufreq_driver->get(policy->cpu));\r\nelse\r\nret = sprintf(buf, "%u\n", policy->cur);\r\nreturn ret;\r\n}\r\nstatic ssize_t show_cpuinfo_cur_freq(struct cpufreq_policy *policy,\r\nchar *buf)\r\n{\r\nunsigned int cur_freq = __cpufreq_get(policy);\r\nif (!cur_freq)\r\nreturn sprintf(buf, "<unknown>");\r\nreturn sprintf(buf, "%u\n", cur_freq);\r\n}\r\nstatic ssize_t show_scaling_governor(struct cpufreq_policy *policy, char *buf)\r\n{\r\nif (policy->policy == CPUFREQ_POLICY_POWERSAVE)\r\nreturn sprintf(buf, "powersave\n");\r\nelse if (policy->policy == CPUFREQ_POLICY_PERFORMANCE)\r\nreturn sprintf(buf, "performance\n");\r\nelse if (policy->governor)\r\nreturn scnprintf(buf, CPUFREQ_NAME_PLEN, "%s\n",\r\npolicy->governor->name);\r\nreturn -EINVAL;\r\n}\r\nstatic ssize_t store_scaling_governor(struct cpufreq_policy *policy,\r\nconst char *buf, size_t count)\r\n{\r\nint ret;\r\nchar str_governor[16];\r\nstruct cpufreq_policy new_policy;\r\nret = cpufreq_get_policy(&new_policy, policy->cpu);\r\nif (ret)\r\nreturn ret;\r\nret = sscanf(buf, "%15s", str_governor);\r\nif (ret != 1)\r\nreturn -EINVAL;\r\nif (cpufreq_parse_governor(str_governor, &new_policy.policy,\r\n&new_policy.governor))\r\nreturn -EINVAL;\r\nret = cpufreq_set_policy(policy, &new_policy);\r\npolicy->user_policy.policy = policy->policy;\r\npolicy->user_policy.governor = policy->governor;\r\nif (ret)\r\nreturn ret;\r\nelse\r\nreturn count;\r\n}\r\nstatic ssize_t show_scaling_driver(struct cpufreq_policy *policy, char *buf)\r\n{\r\nreturn scnprintf(buf, CPUFREQ_NAME_PLEN, "%s\n", cpufreq_driver->name);\r\n}\r\nstatic ssize_t show_scaling_available_governors(struct cpufreq_policy *policy,\r\nchar *buf)\r\n{\r\nssize_t i = 0;\r\nstruct cpufreq_governor *t;\r\nif (!has_target()) {\r\ni += sprintf(buf, "performance powersave");\r\ngoto out;\r\n}\r\nfor_each_governor(t) {\r\nif (i >= (ssize_t) ((PAGE_SIZE / sizeof(char))\r\n- (CPUFREQ_NAME_LEN + 2)))\r\ngoto out;\r\ni += scnprintf(&buf[i], CPUFREQ_NAME_PLEN, "%s ", t->name);\r\n}\r\nout:\r\ni += sprintf(&buf[i], "\n");\r\nreturn i;\r\n}\r\nssize_t cpufreq_show_cpus(const struct cpumask *mask, char *buf)\r\n{\r\nssize_t i = 0;\r\nunsigned int cpu;\r\nfor_each_cpu(cpu, mask) {\r\nif (i)\r\ni += scnprintf(&buf[i], (PAGE_SIZE - i - 2), " ");\r\ni += scnprintf(&buf[i], (PAGE_SIZE - i - 2), "%u", cpu);\r\nif (i >= (PAGE_SIZE - 5))\r\nbreak;\r\n}\r\ni += sprintf(&buf[i], "\n");\r\nreturn i;\r\n}\r\nstatic ssize_t show_related_cpus(struct cpufreq_policy *policy, char *buf)\r\n{\r\nreturn cpufreq_show_cpus(policy->related_cpus, buf);\r\n}\r\nstatic ssize_t show_affected_cpus(struct cpufreq_policy *policy, char *buf)\r\n{\r\nreturn cpufreq_show_cpus(policy->cpus, buf);\r\n}\r\nstatic ssize_t store_scaling_setspeed(struct cpufreq_policy *policy,\r\nconst char *buf, size_t count)\r\n{\r\nunsigned int freq = 0;\r\nunsigned int ret;\r\nif (!policy->governor || !policy->governor->store_setspeed)\r\nreturn -EINVAL;\r\nret = sscanf(buf, "%u", &freq);\r\nif (ret != 1)\r\nreturn -EINVAL;\r\npolicy->governor->store_setspeed(policy, freq);\r\nreturn count;\r\n}\r\nstatic ssize_t show_scaling_setspeed(struct cpufreq_policy *policy, char *buf)\r\n{\r\nif (!policy->governor || !policy->governor->show_setspeed)\r\nreturn sprintf(buf, "<unsupported>\n");\r\nreturn policy->governor->show_setspeed(policy, buf);\r\n}\r\nstatic ssize_t show_bios_limit(struct cpufreq_policy *policy, char *buf)\r\n{\r\nunsigned int limit;\r\nint ret;\r\nif (cpufreq_driver->bios_limit) {\r\nret = cpufreq_driver->bios_limit(policy->cpu, &limit);\r\nif (!ret)\r\nreturn sprintf(buf, "%u\n", limit);\r\n}\r\nreturn sprintf(buf, "%u\n", policy->cpuinfo.max_freq);\r\n}\r\nstatic ssize_t show(struct kobject *kobj, struct attribute *attr, char *buf)\r\n{\r\nstruct cpufreq_policy *policy = to_policy(kobj);\r\nstruct freq_attr *fattr = to_attr(attr);\r\nssize_t ret;\r\nif (!down_read_trylock(&cpufreq_rwsem))\r\nreturn -EINVAL;\r\ndown_read(&policy->rwsem);\r\nif (fattr->show)\r\nret = fattr->show(policy, buf);\r\nelse\r\nret = -EIO;\r\nup_read(&policy->rwsem);\r\nup_read(&cpufreq_rwsem);\r\nreturn ret;\r\n}\r\nstatic ssize_t store(struct kobject *kobj, struct attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct cpufreq_policy *policy = to_policy(kobj);\r\nstruct freq_attr *fattr = to_attr(attr);\r\nssize_t ret = -EINVAL;\r\nget_online_cpus();\r\nif (!cpu_online(policy->cpu))\r\ngoto unlock;\r\nif (!down_read_trylock(&cpufreq_rwsem))\r\ngoto unlock;\r\ndown_write(&policy->rwsem);\r\nif (fattr->store)\r\nret = fattr->store(policy, buf, count);\r\nelse\r\nret = -EIO;\r\nup_write(&policy->rwsem);\r\nup_read(&cpufreq_rwsem);\r\nunlock:\r\nput_online_cpus();\r\nreturn ret;\r\n}\r\nstatic void cpufreq_sysfs_release(struct kobject *kobj)\r\n{\r\nstruct cpufreq_policy *policy = to_policy(kobj);\r\npr_debug("last reference is dropped\n");\r\ncomplete(&policy->kobj_unregister);\r\n}\r\nint cpufreq_get_global_kobject(void)\r\n{\r\nif (!cpufreq_global_kobject_usage++)\r\nreturn kobject_add(cpufreq_global_kobject,\r\n&cpu_subsys.dev_root->kobj, "%s", "cpufreq");\r\nreturn 0;\r\n}\r\nvoid cpufreq_put_global_kobject(void)\r\n{\r\nif (!--cpufreq_global_kobject_usage)\r\nkobject_del(cpufreq_global_kobject);\r\n}\r\nint cpufreq_sysfs_create_file(const struct attribute *attr)\r\n{\r\nint ret = cpufreq_get_global_kobject();\r\nif (!ret) {\r\nret = sysfs_create_file(cpufreq_global_kobject, attr);\r\nif (ret)\r\ncpufreq_put_global_kobject();\r\n}\r\nreturn ret;\r\n}\r\nvoid cpufreq_sysfs_remove_file(const struct attribute *attr)\r\n{\r\nsysfs_remove_file(cpufreq_global_kobject, attr);\r\ncpufreq_put_global_kobject();\r\n}\r\nstatic int cpufreq_add_dev_symlink(struct cpufreq_policy *policy)\r\n{\r\nunsigned int j;\r\nint ret = 0;\r\nfor_each_cpu(j, policy->cpus) {\r\nstruct device *cpu_dev;\r\nif (j == policy->cpu)\r\ncontinue;\r\npr_debug("Adding link for CPU: %u\n", j);\r\ncpu_dev = get_cpu_device(j);\r\nret = sysfs_create_link(&cpu_dev->kobj, &policy->kobj,\r\n"cpufreq");\r\nif (ret)\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int cpufreq_add_dev_interface(struct cpufreq_policy *policy,\r\nstruct device *dev)\r\n{\r\nstruct freq_attr **drv_attr;\r\nint ret = 0;\r\ndrv_attr = cpufreq_driver->attr;\r\nwhile (drv_attr && *drv_attr) {\r\nret = sysfs_create_file(&policy->kobj, &((*drv_attr)->attr));\r\nif (ret)\r\nreturn ret;\r\ndrv_attr++;\r\n}\r\nif (cpufreq_driver->get) {\r\nret = sysfs_create_file(&policy->kobj, &cpuinfo_cur_freq.attr);\r\nif (ret)\r\nreturn ret;\r\n}\r\nret = sysfs_create_file(&policy->kobj, &scaling_cur_freq.attr);\r\nif (ret)\r\nreturn ret;\r\nif (cpufreq_driver->bios_limit) {\r\nret = sysfs_create_file(&policy->kobj, &bios_limit.attr);\r\nif (ret)\r\nreturn ret;\r\n}\r\nreturn cpufreq_add_dev_symlink(policy);\r\n}\r\nstatic void cpufreq_init_policy(struct cpufreq_policy *policy)\r\n{\r\nstruct cpufreq_governor *gov = NULL;\r\nstruct cpufreq_policy new_policy;\r\nint ret = 0;\r\nmemcpy(&new_policy, policy, sizeof(*policy));\r\ngov = find_governor(per_cpu(cpufreq_cpu_governor, policy->cpu));\r\nif (gov)\r\npr_debug("Restoring governor %s for cpu %d\n",\r\npolicy->governor->name, policy->cpu);\r\nelse\r\ngov = CPUFREQ_DEFAULT_GOVERNOR;\r\nnew_policy.governor = gov;\r\nif (cpufreq_driver->setpolicy)\r\ncpufreq_parse_governor(gov->name, &new_policy.policy, NULL);\r\nret = cpufreq_set_policy(policy, &new_policy);\r\nif (ret) {\r\npr_debug("setting policy failed\n");\r\nif (cpufreq_driver->exit)\r\ncpufreq_driver->exit(policy);\r\n}\r\n}\r\nstatic int cpufreq_add_policy_cpu(struct cpufreq_policy *policy,\r\nunsigned int cpu, struct device *dev)\r\n{\r\nint ret = 0;\r\nunsigned long flags;\r\nif (has_target()) {\r\nret = __cpufreq_governor(policy, CPUFREQ_GOV_STOP);\r\nif (ret) {\r\npr_err("%s: Failed to stop governor\n", __func__);\r\nreturn ret;\r\n}\r\n}\r\ndown_write(&policy->rwsem);\r\nwrite_lock_irqsave(&cpufreq_driver_lock, flags);\r\ncpumask_set_cpu(cpu, policy->cpus);\r\nper_cpu(cpufreq_cpu_data, cpu) = policy;\r\nwrite_unlock_irqrestore(&cpufreq_driver_lock, flags);\r\nup_write(&policy->rwsem);\r\nif (has_target()) {\r\nret = __cpufreq_governor(policy, CPUFREQ_GOV_START);\r\nif (!ret)\r\nret = __cpufreq_governor(policy, CPUFREQ_GOV_LIMITS);\r\nif (ret) {\r\npr_err("%s: Failed to start governor\n", __func__);\r\nreturn ret;\r\n}\r\n}\r\nreturn sysfs_create_link(&dev->kobj, &policy->kobj, "cpufreq");\r\n}\r\nstatic struct cpufreq_policy *cpufreq_policy_restore(unsigned int cpu)\r\n{\r\nstruct cpufreq_policy *policy;\r\nunsigned long flags;\r\nread_lock_irqsave(&cpufreq_driver_lock, flags);\r\npolicy = per_cpu(cpufreq_cpu_data_fallback, cpu);\r\nread_unlock_irqrestore(&cpufreq_driver_lock, flags);\r\nif (policy)\r\npolicy->governor = NULL;\r\nreturn policy;\r\n}\r\nstatic struct cpufreq_policy *cpufreq_policy_alloc(void)\r\n{\r\nstruct cpufreq_policy *policy;\r\npolicy = kzalloc(sizeof(*policy), GFP_KERNEL);\r\nif (!policy)\r\nreturn NULL;\r\nif (!alloc_cpumask_var(&policy->cpus, GFP_KERNEL))\r\ngoto err_free_policy;\r\nif (!zalloc_cpumask_var(&policy->related_cpus, GFP_KERNEL))\r\ngoto err_free_cpumask;\r\nINIT_LIST_HEAD(&policy->policy_list);\r\ninit_rwsem(&policy->rwsem);\r\nspin_lock_init(&policy->transition_lock);\r\ninit_waitqueue_head(&policy->transition_wait);\r\ninit_completion(&policy->kobj_unregister);\r\nINIT_WORK(&policy->update, handle_update);\r\nreturn policy;\r\nerr_free_cpumask:\r\nfree_cpumask_var(policy->cpus);\r\nerr_free_policy:\r\nkfree(policy);\r\nreturn NULL;\r\n}\r\nstatic void cpufreq_policy_put_kobj(struct cpufreq_policy *policy)\r\n{\r\nstruct kobject *kobj;\r\nstruct completion *cmp;\r\nblocking_notifier_call_chain(&cpufreq_policy_notifier_list,\r\nCPUFREQ_REMOVE_POLICY, policy);\r\ndown_read(&policy->rwsem);\r\nkobj = &policy->kobj;\r\ncmp = &policy->kobj_unregister;\r\nup_read(&policy->rwsem);\r\nkobject_put(kobj);\r\npr_debug("waiting for dropping of refcount\n");\r\nwait_for_completion(cmp);\r\npr_debug("wait complete\n");\r\n}\r\nstatic void cpufreq_policy_free(struct cpufreq_policy *policy)\r\n{\r\nfree_cpumask_var(policy->related_cpus);\r\nfree_cpumask_var(policy->cpus);\r\nkfree(policy);\r\n}\r\nstatic int update_policy_cpu(struct cpufreq_policy *policy, unsigned int cpu,\r\nstruct device *cpu_dev)\r\n{\r\nint ret;\r\nif (WARN_ON(cpu == policy->cpu))\r\nreturn 0;\r\nret = kobject_move(&policy->kobj, &cpu_dev->kobj);\r\nif (ret) {\r\npr_err("%s: Failed to move kobj: %d\n", __func__, ret);\r\nreturn ret;\r\n}\r\ndown_write(&policy->rwsem);\r\npolicy->cpu = cpu;\r\nup_write(&policy->rwsem);\r\nreturn 0;\r\n}\r\nstatic int __cpufreq_add_dev(struct device *dev, struct subsys_interface *sif)\r\n{\r\nunsigned int j, cpu = dev->id;\r\nint ret = -ENOMEM;\r\nstruct cpufreq_policy *policy;\r\nunsigned long flags;\r\nbool recover_policy = cpufreq_suspended;\r\nif (cpu_is_offline(cpu))\r\nreturn 0;\r\npr_debug("adding CPU %u\n", cpu);\r\npolicy = cpufreq_cpu_get_raw(cpu);\r\nif (unlikely(policy))\r\nreturn 0;\r\nif (!down_read_trylock(&cpufreq_rwsem))\r\nreturn 0;\r\nread_lock_irqsave(&cpufreq_driver_lock, flags);\r\nfor_each_policy(policy) {\r\nif (cpumask_test_cpu(cpu, policy->related_cpus)) {\r\nread_unlock_irqrestore(&cpufreq_driver_lock, flags);\r\nret = cpufreq_add_policy_cpu(policy, cpu, dev);\r\nup_read(&cpufreq_rwsem);\r\nreturn ret;\r\n}\r\n}\r\nread_unlock_irqrestore(&cpufreq_driver_lock, flags);\r\npolicy = recover_policy ? cpufreq_policy_restore(cpu) : NULL;\r\nif (!policy) {\r\nrecover_policy = false;\r\npolicy = cpufreq_policy_alloc();\r\nif (!policy)\r\ngoto nomem_out;\r\n}\r\nif (recover_policy && cpu != policy->cpu)\r\nWARN_ON(update_policy_cpu(policy, cpu, dev));\r\nelse\r\npolicy->cpu = cpu;\r\ncpumask_copy(policy->cpus, cpumask_of(cpu));\r\nret = cpufreq_driver->init(policy);\r\nif (ret) {\r\npr_debug("initialization failed\n");\r\ngoto err_set_policy_cpu;\r\n}\r\ndown_write(&policy->rwsem);\r\ncpumask_or(policy->related_cpus, policy->related_cpus, policy->cpus);\r\ncpumask_and(policy->cpus, policy->cpus, cpu_online_mask);\r\nif (!recover_policy) {\r\npolicy->user_policy.min = policy->min;\r\npolicy->user_policy.max = policy->max;\r\nret = kobject_init_and_add(&policy->kobj, &ktype_cpufreq,\r\n&dev->kobj, "cpufreq");\r\nif (ret) {\r\npr_err("%s: failed to init policy->kobj: %d\n",\r\n__func__, ret);\r\ngoto err_init_policy_kobj;\r\n}\r\n}\r\nwrite_lock_irqsave(&cpufreq_driver_lock, flags);\r\nfor_each_cpu(j, policy->cpus)\r\nper_cpu(cpufreq_cpu_data, j) = policy;\r\nwrite_unlock_irqrestore(&cpufreq_driver_lock, flags);\r\nif (cpufreq_driver->get && !cpufreq_driver->setpolicy) {\r\npolicy->cur = cpufreq_driver->get(policy->cpu);\r\nif (!policy->cur) {\r\npr_err("%s: ->get() failed\n", __func__);\r\ngoto err_get_freq;\r\n}\r\n}\r\nif ((cpufreq_driver->flags & CPUFREQ_NEED_INITIAL_FREQ_CHECK)\r\n&& has_target()) {\r\nret = cpufreq_frequency_table_get_index(policy, policy->cur);\r\nif (ret == -EINVAL) {\r\npr_warn("%s: CPU%d: Running at unlisted freq: %u KHz\n",\r\n__func__, policy->cpu, policy->cur);\r\nret = __cpufreq_driver_target(policy, policy->cur - 1,\r\nCPUFREQ_RELATION_L);\r\nBUG_ON(ret);\r\npr_warn("%s: CPU%d: Unlisted initial frequency changed to: %u KHz\n",\r\n__func__, policy->cpu, policy->cur);\r\n}\r\n}\r\nblocking_notifier_call_chain(&cpufreq_policy_notifier_list,\r\nCPUFREQ_START, policy);\r\nif (!recover_policy) {\r\nret = cpufreq_add_dev_interface(policy, dev);\r\nif (ret)\r\ngoto err_out_unregister;\r\nblocking_notifier_call_chain(&cpufreq_policy_notifier_list,\r\nCPUFREQ_CREATE_POLICY, policy);\r\n}\r\nwrite_lock_irqsave(&cpufreq_driver_lock, flags);\r\nlist_add(&policy->policy_list, &cpufreq_policy_list);\r\nwrite_unlock_irqrestore(&cpufreq_driver_lock, flags);\r\ncpufreq_init_policy(policy);\r\nif (!recover_policy) {\r\npolicy->user_policy.policy = policy->policy;\r\npolicy->user_policy.governor = policy->governor;\r\n}\r\nup_write(&policy->rwsem);\r\nkobject_uevent(&policy->kobj, KOBJ_ADD);\r\nup_read(&cpufreq_rwsem);\r\nif (cpufreq_driver->ready)\r\ncpufreq_driver->ready(policy);\r\npr_debug("initialization complete\n");\r\nreturn 0;\r\nerr_out_unregister:\r\nerr_get_freq:\r\nwrite_lock_irqsave(&cpufreq_driver_lock, flags);\r\nfor_each_cpu(j, policy->cpus)\r\nper_cpu(cpufreq_cpu_data, j) = NULL;\r\nwrite_unlock_irqrestore(&cpufreq_driver_lock, flags);\r\nif (!recover_policy) {\r\nkobject_put(&policy->kobj);\r\nwait_for_completion(&policy->kobj_unregister);\r\n}\r\nerr_init_policy_kobj:\r\nup_write(&policy->rwsem);\r\nif (cpufreq_driver->exit)\r\ncpufreq_driver->exit(policy);\r\nerr_set_policy_cpu:\r\nif (recover_policy) {\r\nper_cpu(cpufreq_cpu_data_fallback, cpu) = NULL;\r\ncpufreq_policy_put_kobj(policy);\r\n}\r\ncpufreq_policy_free(policy);\r\nnomem_out:\r\nup_read(&cpufreq_rwsem);\r\nreturn ret;\r\n}\r\nstatic int cpufreq_add_dev(struct device *dev, struct subsys_interface *sif)\r\n{\r\nreturn __cpufreq_add_dev(dev, sif);\r\n}\r\nstatic int __cpufreq_remove_dev_prepare(struct device *dev,\r\nstruct subsys_interface *sif)\r\n{\r\nunsigned int cpu = dev->id, cpus;\r\nint ret;\r\nunsigned long flags;\r\nstruct cpufreq_policy *policy;\r\npr_debug("%s: unregistering CPU %u\n", __func__, cpu);\r\nwrite_lock_irqsave(&cpufreq_driver_lock, flags);\r\npolicy = per_cpu(cpufreq_cpu_data, cpu);\r\nif (cpufreq_suspended)\r\nper_cpu(cpufreq_cpu_data_fallback, cpu) = policy;\r\nwrite_unlock_irqrestore(&cpufreq_driver_lock, flags);\r\nif (!policy) {\r\npr_debug("%s: No cpu_data found\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nif (has_target()) {\r\nret = __cpufreq_governor(policy, CPUFREQ_GOV_STOP);\r\nif (ret) {\r\npr_err("%s: Failed to stop governor\n", __func__);\r\nreturn ret;\r\n}\r\nstrncpy(per_cpu(cpufreq_cpu_governor, cpu),\r\npolicy->governor->name, CPUFREQ_NAME_LEN);\r\n}\r\ndown_read(&policy->rwsem);\r\ncpus = cpumask_weight(policy->cpus);\r\nup_read(&policy->rwsem);\r\nif (cpu != policy->cpu) {\r\nsysfs_remove_link(&dev->kobj, "cpufreq");\r\n} else if (cpus > 1) {\r\nint new_cpu = cpumask_any_but(policy->cpus, cpu);\r\nstruct device *cpu_dev = get_cpu_device(new_cpu);\r\nsysfs_remove_link(&cpu_dev->kobj, "cpufreq");\r\nret = update_policy_cpu(policy, new_cpu, cpu_dev);\r\nif (ret) {\r\nif (sysfs_create_link(&cpu_dev->kobj, &policy->kobj,\r\n"cpufreq"))\r\npr_err("%s: Failed to restore kobj link to cpu:%d\n",\r\n__func__, cpu_dev->id);\r\nreturn ret;\r\n}\r\nif (!cpufreq_suspended)\r\npr_debug("%s: policy Kobject moved to cpu: %d from: %d\n",\r\n__func__, new_cpu, cpu);\r\n} else if (cpufreq_driver->stop_cpu) {\r\ncpufreq_driver->stop_cpu(policy);\r\n}\r\nreturn 0;\r\n}\r\nstatic int __cpufreq_remove_dev_finish(struct device *dev,\r\nstruct subsys_interface *sif)\r\n{\r\nunsigned int cpu = dev->id, cpus;\r\nint ret;\r\nunsigned long flags;\r\nstruct cpufreq_policy *policy;\r\nwrite_lock_irqsave(&cpufreq_driver_lock, flags);\r\npolicy = per_cpu(cpufreq_cpu_data, cpu);\r\nper_cpu(cpufreq_cpu_data, cpu) = NULL;\r\nwrite_unlock_irqrestore(&cpufreq_driver_lock, flags);\r\nif (!policy) {\r\npr_debug("%s: No cpu_data found\n", __func__);\r\nreturn -EINVAL;\r\n}\r\ndown_write(&policy->rwsem);\r\ncpus = cpumask_weight(policy->cpus);\r\nif (cpus > 1)\r\ncpumask_clear_cpu(cpu, policy->cpus);\r\nup_write(&policy->rwsem);\r\nif (cpus == 1) {\r\nif (has_target()) {\r\nret = __cpufreq_governor(policy,\r\nCPUFREQ_GOV_POLICY_EXIT);\r\nif (ret) {\r\npr_err("%s: Failed to exit governor\n",\r\n__func__);\r\nreturn ret;\r\n}\r\n}\r\nif (!cpufreq_suspended)\r\ncpufreq_policy_put_kobj(policy);\r\nif (cpufreq_driver->exit)\r\ncpufreq_driver->exit(policy);\r\nwrite_lock_irqsave(&cpufreq_driver_lock, flags);\r\nlist_del(&policy->policy_list);\r\nwrite_unlock_irqrestore(&cpufreq_driver_lock, flags);\r\nif (!cpufreq_suspended)\r\ncpufreq_policy_free(policy);\r\n} else if (has_target()) {\r\nret = __cpufreq_governor(policy, CPUFREQ_GOV_START);\r\nif (!ret)\r\nret = __cpufreq_governor(policy, CPUFREQ_GOV_LIMITS);\r\nif (ret) {\r\npr_err("%s: Failed to start governor\n", __func__);\r\nreturn ret;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int cpufreq_remove_dev(struct device *dev, struct subsys_interface *sif)\r\n{\r\nunsigned int cpu = dev->id;\r\nint ret;\r\nif (cpu_is_offline(cpu))\r\nreturn 0;\r\nret = __cpufreq_remove_dev_prepare(dev, sif);\r\nif (!ret)\r\nret = __cpufreq_remove_dev_finish(dev, sif);\r\nreturn ret;\r\n}\r\nstatic void handle_update(struct work_struct *work)\r\n{\r\nstruct cpufreq_policy *policy =\r\ncontainer_of(work, struct cpufreq_policy, update);\r\nunsigned int cpu = policy->cpu;\r\npr_debug("handle_update for cpu %u called\n", cpu);\r\ncpufreq_update_policy(cpu);\r\n}\r\nstatic void cpufreq_out_of_sync(struct cpufreq_policy *policy,\r\nunsigned int new_freq)\r\n{\r\nstruct cpufreq_freqs freqs;\r\npr_debug("Warning: CPU frequency out of sync: cpufreq and timing core thinks of %u, is %u kHz\n",\r\npolicy->cur, new_freq);\r\nfreqs.old = policy->cur;\r\nfreqs.new = new_freq;\r\ncpufreq_freq_transition_begin(policy, &freqs);\r\ncpufreq_freq_transition_end(policy, &freqs, 0);\r\n}\r\nunsigned int cpufreq_quick_get(unsigned int cpu)\r\n{\r\nstruct cpufreq_policy *policy;\r\nunsigned int ret_freq = 0;\r\nif (cpufreq_driver && cpufreq_driver->setpolicy && cpufreq_driver->get)\r\nreturn cpufreq_driver->get(cpu);\r\npolicy = cpufreq_cpu_get(cpu);\r\nif (policy) {\r\nret_freq = policy->cur;\r\ncpufreq_cpu_put(policy);\r\n}\r\nreturn ret_freq;\r\n}\r\nunsigned int cpufreq_quick_get_max(unsigned int cpu)\r\n{\r\nstruct cpufreq_policy *policy = cpufreq_cpu_get(cpu);\r\nunsigned int ret_freq = 0;\r\nif (policy) {\r\nret_freq = policy->max;\r\ncpufreq_cpu_put(policy);\r\n}\r\nreturn ret_freq;\r\n}\r\nstatic unsigned int __cpufreq_get(struct cpufreq_policy *policy)\r\n{\r\nunsigned int ret_freq = 0;\r\nif (!cpufreq_driver->get)\r\nreturn ret_freq;\r\nret_freq = cpufreq_driver->get(policy->cpu);\r\nif (ret_freq && policy->cur &&\r\n!(cpufreq_driver->flags & CPUFREQ_CONST_LOOPS)) {\r\nif (unlikely(ret_freq != policy->cur)) {\r\ncpufreq_out_of_sync(policy, ret_freq);\r\nschedule_work(&policy->update);\r\n}\r\n}\r\nreturn ret_freq;\r\n}\r\nunsigned int cpufreq_get(unsigned int cpu)\r\n{\r\nstruct cpufreq_policy *policy = cpufreq_cpu_get(cpu);\r\nunsigned int ret_freq = 0;\r\nif (policy) {\r\ndown_read(&policy->rwsem);\r\nret_freq = __cpufreq_get(policy);\r\nup_read(&policy->rwsem);\r\ncpufreq_cpu_put(policy);\r\n}\r\nreturn ret_freq;\r\n}\r\nint cpufreq_generic_suspend(struct cpufreq_policy *policy)\r\n{\r\nint ret;\r\nif (!policy->suspend_freq) {\r\npr_err("%s: suspend_freq can't be zero\n", __func__);\r\nreturn -EINVAL;\r\n}\r\npr_debug("%s: Setting suspend-freq: %u\n", __func__,\r\npolicy->suspend_freq);\r\nret = __cpufreq_driver_target(policy, policy->suspend_freq,\r\nCPUFREQ_RELATION_H);\r\nif (ret)\r\npr_err("%s: unable to set suspend-freq: %u. err: %d\n",\r\n__func__, policy->suspend_freq, ret);\r\nreturn ret;\r\n}\r\nvoid cpufreq_suspend(void)\r\n{\r\nstruct cpufreq_policy *policy;\r\nif (!cpufreq_driver)\r\nreturn;\r\nif (!has_target())\r\ngoto suspend;\r\npr_debug("%s: Suspending Governors\n", __func__);\r\nfor_each_policy(policy) {\r\nif (__cpufreq_governor(policy, CPUFREQ_GOV_STOP))\r\npr_err("%s: Failed to stop governor for policy: %p\n",\r\n__func__, policy);\r\nelse if (cpufreq_driver->suspend\r\n&& cpufreq_driver->suspend(policy))\r\npr_err("%s: Failed to suspend driver: %p\n", __func__,\r\npolicy);\r\n}\r\nsuspend:\r\ncpufreq_suspended = true;\r\n}\r\nvoid cpufreq_resume(void)\r\n{\r\nstruct cpufreq_policy *policy;\r\nif (!cpufreq_driver)\r\nreturn;\r\ncpufreq_suspended = false;\r\nif (!has_target())\r\nreturn;\r\npr_debug("%s: Resuming Governors\n", __func__);\r\nfor_each_policy(policy) {\r\nif (cpufreq_driver->resume && cpufreq_driver->resume(policy))\r\npr_err("%s: Failed to resume driver: %p\n", __func__,\r\npolicy);\r\nelse if (__cpufreq_governor(policy, CPUFREQ_GOV_START)\r\n|| __cpufreq_governor(policy, CPUFREQ_GOV_LIMITS))\r\npr_err("%s: Failed to start governor for policy: %p\n",\r\n__func__, policy);\r\n}\r\npolicy = cpufreq_cpu_get_raw(cpumask_first(cpu_online_mask));\r\nif (WARN_ON(!policy))\r\nreturn;\r\nschedule_work(&policy->update);\r\n}\r\nconst char *cpufreq_get_current_driver(void)\r\n{\r\nif (cpufreq_driver)\r\nreturn cpufreq_driver->name;\r\nreturn NULL;\r\n}\r\nvoid *cpufreq_get_driver_data(void)\r\n{\r\nif (cpufreq_driver)\r\nreturn cpufreq_driver->driver_data;\r\nreturn NULL;\r\n}\r\nint cpufreq_register_notifier(struct notifier_block *nb, unsigned int list)\r\n{\r\nint ret;\r\nif (cpufreq_disabled())\r\nreturn -EINVAL;\r\nWARN_ON(!init_cpufreq_transition_notifier_list_called);\r\nswitch (list) {\r\ncase CPUFREQ_TRANSITION_NOTIFIER:\r\nret = srcu_notifier_chain_register(\r\n&cpufreq_transition_notifier_list, nb);\r\nbreak;\r\ncase CPUFREQ_POLICY_NOTIFIER:\r\nret = blocking_notifier_chain_register(\r\n&cpufreq_policy_notifier_list, nb);\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\n}\r\nreturn ret;\r\n}\r\nint cpufreq_unregister_notifier(struct notifier_block *nb, unsigned int list)\r\n{\r\nint ret;\r\nif (cpufreq_disabled())\r\nreturn -EINVAL;\r\nswitch (list) {\r\ncase CPUFREQ_TRANSITION_NOTIFIER:\r\nret = srcu_notifier_chain_unregister(\r\n&cpufreq_transition_notifier_list, nb);\r\nbreak;\r\ncase CPUFREQ_POLICY_NOTIFIER:\r\nret = blocking_notifier_chain_unregister(\r\n&cpufreq_policy_notifier_list, nb);\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\n}\r\nreturn ret;\r\n}\r\nstatic int __target_intermediate(struct cpufreq_policy *policy,\r\nstruct cpufreq_freqs *freqs, int index)\r\n{\r\nint ret;\r\nfreqs->new = cpufreq_driver->get_intermediate(policy, index);\r\nif (!freqs->new)\r\nreturn 0;\r\npr_debug("%s: cpu: %d, switching to intermediate freq: oldfreq: %u, intermediate freq: %u\n",\r\n__func__, policy->cpu, freqs->old, freqs->new);\r\ncpufreq_freq_transition_begin(policy, freqs);\r\nret = cpufreq_driver->target_intermediate(policy, index);\r\ncpufreq_freq_transition_end(policy, freqs, ret);\r\nif (ret)\r\npr_err("%s: Failed to change to intermediate frequency: %d\n",\r\n__func__, ret);\r\nreturn ret;\r\n}\r\nstatic int __target_index(struct cpufreq_policy *policy,\r\nstruct cpufreq_frequency_table *freq_table, int index)\r\n{\r\nstruct cpufreq_freqs freqs = {.old = policy->cur, .flags = 0};\r\nunsigned int intermediate_freq = 0;\r\nint retval = -EINVAL;\r\nbool notify;\r\nnotify = !(cpufreq_driver->flags & CPUFREQ_ASYNC_NOTIFICATION);\r\nif (notify) {\r\nif (cpufreq_driver->get_intermediate) {\r\nretval = __target_intermediate(policy, &freqs, index);\r\nif (retval)\r\nreturn retval;\r\nintermediate_freq = freqs.new;\r\nif (intermediate_freq)\r\nfreqs.old = freqs.new;\r\n}\r\nfreqs.new = freq_table[index].frequency;\r\npr_debug("%s: cpu: %d, oldfreq: %u, new freq: %u\n",\r\n__func__, policy->cpu, freqs.old, freqs.new);\r\ncpufreq_freq_transition_begin(policy, &freqs);\r\n}\r\nretval = cpufreq_driver->target_index(policy, index);\r\nif (retval)\r\npr_err("%s: Failed to change cpu frequency: %d\n", __func__,\r\nretval);\r\nif (notify) {\r\ncpufreq_freq_transition_end(policy, &freqs, retval);\r\nif (unlikely(retval && intermediate_freq)) {\r\nfreqs.old = intermediate_freq;\r\nfreqs.new = policy->restore_freq;\r\ncpufreq_freq_transition_begin(policy, &freqs);\r\ncpufreq_freq_transition_end(policy, &freqs, 0);\r\n}\r\n}\r\nreturn retval;\r\n}\r\nint __cpufreq_driver_target(struct cpufreq_policy *policy,\r\nunsigned int target_freq,\r\nunsigned int relation)\r\n{\r\nunsigned int old_target_freq = target_freq;\r\nint retval = -EINVAL;\r\nif (cpufreq_disabled())\r\nreturn -ENODEV;\r\nif (target_freq > policy->max)\r\ntarget_freq = policy->max;\r\nif (target_freq < policy->min)\r\ntarget_freq = policy->min;\r\npr_debug("target for CPU %u: %u kHz, relation %u, requested %u kHz\n",\r\npolicy->cpu, target_freq, relation, old_target_freq);\r\nif (target_freq == policy->cur)\r\nreturn 0;\r\npolicy->restore_freq = policy->cur;\r\nif (cpufreq_driver->target)\r\nretval = cpufreq_driver->target(policy, target_freq, relation);\r\nelse if (cpufreq_driver->target_index) {\r\nstruct cpufreq_frequency_table *freq_table;\r\nint index;\r\nfreq_table = cpufreq_frequency_get_table(policy->cpu);\r\nif (unlikely(!freq_table)) {\r\npr_err("%s: Unable to find freq_table\n", __func__);\r\ngoto out;\r\n}\r\nretval = cpufreq_frequency_table_target(policy, freq_table,\r\ntarget_freq, relation, &index);\r\nif (unlikely(retval)) {\r\npr_err("%s: Unable to find matching freq\n", __func__);\r\ngoto out;\r\n}\r\nif (freq_table[index].frequency == policy->cur) {\r\nretval = 0;\r\ngoto out;\r\n}\r\nretval = __target_index(policy, freq_table, index);\r\n}\r\nout:\r\nreturn retval;\r\n}\r\nint cpufreq_driver_target(struct cpufreq_policy *policy,\r\nunsigned int target_freq,\r\nunsigned int relation)\r\n{\r\nint ret = -EINVAL;\r\ndown_write(&policy->rwsem);\r\nret = __cpufreq_driver_target(policy, target_freq, relation);\r\nup_write(&policy->rwsem);\r\nreturn ret;\r\n}\r\nstatic int __cpufreq_governor(struct cpufreq_policy *policy,\r\nunsigned int event)\r\n{\r\nint ret;\r\n#ifdef CONFIG_CPU_FREQ_GOV_PERFORMANCE\r\nstruct cpufreq_governor *gov = &cpufreq_gov_performance;\r\n#else\r\nstruct cpufreq_governor *gov = NULL;\r\n#endif\r\nif (cpufreq_suspended)\r\nreturn 0;\r\nif (!policy->governor)\r\nreturn -EINVAL;\r\nif (policy->governor->max_transition_latency &&\r\npolicy->cpuinfo.transition_latency >\r\npolicy->governor->max_transition_latency) {\r\nif (!gov)\r\nreturn -EINVAL;\r\nelse {\r\npr_warn("%s governor failed, too long transition latency of HW, fallback to %s governor\n",\r\npolicy->governor->name, gov->name);\r\npolicy->governor = gov;\r\n}\r\n}\r\nif (event == CPUFREQ_GOV_POLICY_INIT)\r\nif (!try_module_get(policy->governor->owner))\r\nreturn -EINVAL;\r\npr_debug("__cpufreq_governor for CPU %u, event %u\n",\r\npolicy->cpu, event);\r\nmutex_lock(&cpufreq_governor_lock);\r\nif ((policy->governor_enabled && event == CPUFREQ_GOV_START)\r\n|| (!policy->governor_enabled\r\n&& (event == CPUFREQ_GOV_LIMITS || event == CPUFREQ_GOV_STOP))) {\r\nmutex_unlock(&cpufreq_governor_lock);\r\nreturn -EBUSY;\r\n}\r\nif (event == CPUFREQ_GOV_STOP)\r\npolicy->governor_enabled = false;\r\nelse if (event == CPUFREQ_GOV_START)\r\npolicy->governor_enabled = true;\r\nmutex_unlock(&cpufreq_governor_lock);\r\nret = policy->governor->governor(policy, event);\r\nif (!ret) {\r\nif (event == CPUFREQ_GOV_POLICY_INIT)\r\npolicy->governor->initialized++;\r\nelse if (event == CPUFREQ_GOV_POLICY_EXIT)\r\npolicy->governor->initialized--;\r\n} else {\r\nmutex_lock(&cpufreq_governor_lock);\r\nif (event == CPUFREQ_GOV_STOP)\r\npolicy->governor_enabled = true;\r\nelse if (event == CPUFREQ_GOV_START)\r\npolicy->governor_enabled = false;\r\nmutex_unlock(&cpufreq_governor_lock);\r\n}\r\nif (((event == CPUFREQ_GOV_POLICY_INIT) && ret) ||\r\n((event == CPUFREQ_GOV_POLICY_EXIT) && !ret))\r\nmodule_put(policy->governor->owner);\r\nreturn ret;\r\n}\r\nint cpufreq_register_governor(struct cpufreq_governor *governor)\r\n{\r\nint err;\r\nif (!governor)\r\nreturn -EINVAL;\r\nif (cpufreq_disabled())\r\nreturn -ENODEV;\r\nmutex_lock(&cpufreq_governor_mutex);\r\ngovernor->initialized = 0;\r\nerr = -EBUSY;\r\nif (!find_governor(governor->name)) {\r\nerr = 0;\r\nlist_add(&governor->governor_list, &cpufreq_governor_list);\r\n}\r\nmutex_unlock(&cpufreq_governor_mutex);\r\nreturn err;\r\n}\r\nvoid cpufreq_unregister_governor(struct cpufreq_governor *governor)\r\n{\r\nint cpu;\r\nif (!governor)\r\nreturn;\r\nif (cpufreq_disabled())\r\nreturn;\r\nfor_each_present_cpu(cpu) {\r\nif (cpu_online(cpu))\r\ncontinue;\r\nif (!strcmp(per_cpu(cpufreq_cpu_governor, cpu), governor->name))\r\nstrcpy(per_cpu(cpufreq_cpu_governor, cpu), "\0");\r\n}\r\nmutex_lock(&cpufreq_governor_mutex);\r\nlist_del(&governor->governor_list);\r\nmutex_unlock(&cpufreq_governor_mutex);\r\nreturn;\r\n}\r\nint cpufreq_get_policy(struct cpufreq_policy *policy, unsigned int cpu)\r\n{\r\nstruct cpufreq_policy *cpu_policy;\r\nif (!policy)\r\nreturn -EINVAL;\r\ncpu_policy = cpufreq_cpu_get(cpu);\r\nif (!cpu_policy)\r\nreturn -EINVAL;\r\nmemcpy(policy, cpu_policy, sizeof(*policy));\r\ncpufreq_cpu_put(cpu_policy);\r\nreturn 0;\r\n}\r\nstatic int cpufreq_set_policy(struct cpufreq_policy *policy,\r\nstruct cpufreq_policy *new_policy)\r\n{\r\nstruct cpufreq_governor *old_gov;\r\nint ret;\r\npr_debug("setting new policy for CPU %u: %u - %u kHz\n",\r\nnew_policy->cpu, new_policy->min, new_policy->max);\r\nmemcpy(&new_policy->cpuinfo, &policy->cpuinfo, sizeof(policy->cpuinfo));\r\nif (new_policy->min > policy->max || new_policy->max < policy->min)\r\nreturn -EINVAL;\r\nret = cpufreq_driver->verify(new_policy);\r\nif (ret)\r\nreturn ret;\r\nblocking_notifier_call_chain(&cpufreq_policy_notifier_list,\r\nCPUFREQ_ADJUST, new_policy);\r\nblocking_notifier_call_chain(&cpufreq_policy_notifier_list,\r\nCPUFREQ_INCOMPATIBLE, new_policy);\r\nret = cpufreq_driver->verify(new_policy);\r\nif (ret)\r\nreturn ret;\r\nblocking_notifier_call_chain(&cpufreq_policy_notifier_list,\r\nCPUFREQ_NOTIFY, new_policy);\r\npolicy->min = new_policy->min;\r\npolicy->max = new_policy->max;\r\npr_debug("new min and max freqs are %u - %u kHz\n",\r\npolicy->min, policy->max);\r\nif (cpufreq_driver->setpolicy) {\r\npolicy->policy = new_policy->policy;\r\npr_debug("setting range\n");\r\nreturn cpufreq_driver->setpolicy(new_policy);\r\n}\r\nif (new_policy->governor == policy->governor)\r\ngoto out;\r\npr_debug("governor switch\n");\r\nold_gov = policy->governor;\r\nif (old_gov) {\r\n__cpufreq_governor(policy, CPUFREQ_GOV_STOP);\r\nup_write(&policy->rwsem);\r\n__cpufreq_governor(policy, CPUFREQ_GOV_POLICY_EXIT);\r\ndown_write(&policy->rwsem);\r\n}\r\npolicy->governor = new_policy->governor;\r\nif (!__cpufreq_governor(policy, CPUFREQ_GOV_POLICY_INIT)) {\r\nif (!__cpufreq_governor(policy, CPUFREQ_GOV_START))\r\ngoto out;\r\nup_write(&policy->rwsem);\r\n__cpufreq_governor(policy, CPUFREQ_GOV_POLICY_EXIT);\r\ndown_write(&policy->rwsem);\r\n}\r\npr_debug("starting governor %s failed\n", policy->governor->name);\r\nif (old_gov) {\r\npolicy->governor = old_gov;\r\n__cpufreq_governor(policy, CPUFREQ_GOV_POLICY_INIT);\r\n__cpufreq_governor(policy, CPUFREQ_GOV_START);\r\n}\r\nreturn -EINVAL;\r\nout:\r\npr_debug("governor: change or update limits\n");\r\nreturn __cpufreq_governor(policy, CPUFREQ_GOV_LIMITS);\r\n}\r\nint cpufreq_update_policy(unsigned int cpu)\r\n{\r\nstruct cpufreq_policy *policy = cpufreq_cpu_get(cpu);\r\nstruct cpufreq_policy new_policy;\r\nint ret;\r\nif (!policy)\r\nreturn -ENODEV;\r\ndown_write(&policy->rwsem);\r\npr_debug("updating policy for CPU %u\n", cpu);\r\nmemcpy(&new_policy, policy, sizeof(*policy));\r\nnew_policy.min = policy->user_policy.min;\r\nnew_policy.max = policy->user_policy.max;\r\nnew_policy.policy = policy->user_policy.policy;\r\nnew_policy.governor = policy->user_policy.governor;\r\nif (cpufreq_driver->get && !cpufreq_driver->setpolicy) {\r\nnew_policy.cur = cpufreq_driver->get(cpu);\r\nif (WARN_ON(!new_policy.cur)) {\r\nret = -EIO;\r\ngoto unlock;\r\n}\r\nif (!policy->cur) {\r\npr_debug("Driver did not initialize current freq\n");\r\npolicy->cur = new_policy.cur;\r\n} else {\r\nif (policy->cur != new_policy.cur && has_target())\r\ncpufreq_out_of_sync(policy, new_policy.cur);\r\n}\r\n}\r\nret = cpufreq_set_policy(policy, &new_policy);\r\nunlock:\r\nup_write(&policy->rwsem);\r\ncpufreq_cpu_put(policy);\r\nreturn ret;\r\n}\r\nstatic int cpufreq_cpu_callback(struct notifier_block *nfb,\r\nunsigned long action, void *hcpu)\r\n{\r\nunsigned int cpu = (unsigned long)hcpu;\r\nstruct device *dev;\r\ndev = get_cpu_device(cpu);\r\nif (dev) {\r\nswitch (action & ~CPU_TASKS_FROZEN) {\r\ncase CPU_ONLINE:\r\n__cpufreq_add_dev(dev, NULL);\r\nbreak;\r\ncase CPU_DOWN_PREPARE:\r\n__cpufreq_remove_dev_prepare(dev, NULL);\r\nbreak;\r\ncase CPU_POST_DEAD:\r\n__cpufreq_remove_dev_finish(dev, NULL);\r\nbreak;\r\ncase CPU_DOWN_FAILED:\r\n__cpufreq_add_dev(dev, NULL);\r\nbreak;\r\n}\r\n}\r\nreturn NOTIFY_OK;\r\n}\r\nstatic int cpufreq_boost_set_sw(int state)\r\n{\r\nstruct cpufreq_frequency_table *freq_table;\r\nstruct cpufreq_policy *policy;\r\nint ret = -EINVAL;\r\nfor_each_policy(policy) {\r\nfreq_table = cpufreq_frequency_get_table(policy->cpu);\r\nif (freq_table) {\r\nret = cpufreq_frequency_table_cpuinfo(policy,\r\nfreq_table);\r\nif (ret) {\r\npr_err("%s: Policy frequency update failed\n",\r\n__func__);\r\nbreak;\r\n}\r\npolicy->user_policy.max = policy->max;\r\n__cpufreq_governor(policy, CPUFREQ_GOV_LIMITS);\r\n}\r\n}\r\nreturn ret;\r\n}\r\nint cpufreq_boost_trigger_state(int state)\r\n{\r\nunsigned long flags;\r\nint ret = 0;\r\nif (cpufreq_driver->boost_enabled == state)\r\nreturn 0;\r\nwrite_lock_irqsave(&cpufreq_driver_lock, flags);\r\ncpufreq_driver->boost_enabled = state;\r\nwrite_unlock_irqrestore(&cpufreq_driver_lock, flags);\r\nret = cpufreq_driver->set_boost(state);\r\nif (ret) {\r\nwrite_lock_irqsave(&cpufreq_driver_lock, flags);\r\ncpufreq_driver->boost_enabled = !state;\r\nwrite_unlock_irqrestore(&cpufreq_driver_lock, flags);\r\npr_err("%s: Cannot %s BOOST\n",\r\n__func__, state ? "enable" : "disable");\r\n}\r\nreturn ret;\r\n}\r\nint cpufreq_boost_supported(void)\r\n{\r\nif (likely(cpufreq_driver))\r\nreturn cpufreq_driver->boost_supported;\r\nreturn 0;\r\n}\r\nint cpufreq_boost_enabled(void)\r\n{\r\nreturn cpufreq_driver->boost_enabled;\r\n}\r\nint cpufreq_register_driver(struct cpufreq_driver *driver_data)\r\n{\r\nunsigned long flags;\r\nint ret;\r\nif (cpufreq_disabled())\r\nreturn -ENODEV;\r\nif (!driver_data || !driver_data->verify || !driver_data->init ||\r\n!(driver_data->setpolicy || driver_data->target_index ||\r\ndriver_data->target) ||\r\n(driver_data->setpolicy && (driver_data->target_index ||\r\ndriver_data->target)) ||\r\n(!!driver_data->get_intermediate != !!driver_data->target_intermediate))\r\nreturn -EINVAL;\r\npr_debug("trying to register driver %s\n", driver_data->name);\r\nwrite_lock_irqsave(&cpufreq_driver_lock, flags);\r\nif (cpufreq_driver) {\r\nwrite_unlock_irqrestore(&cpufreq_driver_lock, flags);\r\nreturn -EEXIST;\r\n}\r\ncpufreq_driver = driver_data;\r\nwrite_unlock_irqrestore(&cpufreq_driver_lock, flags);\r\nif (driver_data->setpolicy)\r\ndriver_data->flags |= CPUFREQ_CONST_LOOPS;\r\nif (cpufreq_boost_supported()) {\r\nif (!cpufreq_driver->set_boost)\r\ncpufreq_driver->set_boost = cpufreq_boost_set_sw;\r\nret = cpufreq_sysfs_create_file(&boost.attr);\r\nif (ret) {\r\npr_err("%s: cannot register global BOOST sysfs file\n",\r\n__func__);\r\ngoto err_null_driver;\r\n}\r\n}\r\nret = subsys_interface_register(&cpufreq_interface);\r\nif (ret)\r\ngoto err_boost_unreg;\r\nif (!(cpufreq_driver->flags & CPUFREQ_STICKY) &&\r\nlist_empty(&cpufreq_policy_list)) {\r\npr_debug("%s: No CPU initialized for driver %s\n", __func__,\r\ndriver_data->name);\r\ngoto err_if_unreg;\r\n}\r\nregister_hotcpu_notifier(&cpufreq_cpu_notifier);\r\npr_debug("driver %s up and running\n", driver_data->name);\r\nreturn 0;\r\nerr_if_unreg:\r\nsubsys_interface_unregister(&cpufreq_interface);\r\nerr_boost_unreg:\r\nif (cpufreq_boost_supported())\r\ncpufreq_sysfs_remove_file(&boost.attr);\r\nerr_null_driver:\r\nwrite_lock_irqsave(&cpufreq_driver_lock, flags);\r\ncpufreq_driver = NULL;\r\nwrite_unlock_irqrestore(&cpufreq_driver_lock, flags);\r\nreturn ret;\r\n}\r\nint cpufreq_unregister_driver(struct cpufreq_driver *driver)\r\n{\r\nunsigned long flags;\r\nif (!cpufreq_driver || (driver != cpufreq_driver))\r\nreturn -EINVAL;\r\npr_debug("unregistering driver %s\n", driver->name);\r\nsubsys_interface_unregister(&cpufreq_interface);\r\nif (cpufreq_boost_supported())\r\ncpufreq_sysfs_remove_file(&boost.attr);\r\nunregister_hotcpu_notifier(&cpufreq_cpu_notifier);\r\ndown_write(&cpufreq_rwsem);\r\nwrite_lock_irqsave(&cpufreq_driver_lock, flags);\r\ncpufreq_driver = NULL;\r\nwrite_unlock_irqrestore(&cpufreq_driver_lock, flags);\r\nup_write(&cpufreq_rwsem);\r\nreturn 0;\r\n}\r\nstatic int __init cpufreq_core_init(void)\r\n{\r\nif (cpufreq_disabled())\r\nreturn -ENODEV;\r\ncpufreq_global_kobject = kobject_create();\r\nBUG_ON(!cpufreq_global_kobject);\r\nregister_syscore_ops(&cpufreq_syscore_ops);\r\nreturn 0;\r\n}
