static inline port_id br_make_port_id(__u8 priority, __u16 port_no)\r\n{\r\nreturn ((u16)priority << BR_PORT_BITS)\r\n| (port_no & ((1<<BR_PORT_BITS)-1));\r\n}\r\nvoid br_init_port(struct net_bridge_port *p)\r\n{\r\np->port_id = br_make_port_id(p->priority, p->port_no);\r\nbr_become_designated_port(p);\r\nbr_set_state(p, BR_STATE_BLOCKING);\r\np->topology_change_ack = 0;\r\np->config_pending = 0;\r\n}\r\nvoid br_stp_enable_bridge(struct net_bridge *br)\r\n{\r\nstruct net_bridge_port *p;\r\nspin_lock_bh(&br->lock);\r\nmod_timer(&br->hello_timer, jiffies + br->hello_time);\r\nmod_timer(&br->gc_timer, jiffies + HZ/10);\r\nbr_config_bpdu_generation(br);\r\nlist_for_each_entry(p, &br->port_list, list) {\r\nif (netif_running(p->dev) && netif_oper_up(p->dev))\r\nbr_stp_enable_port(p);\r\n}\r\nspin_unlock_bh(&br->lock);\r\n}\r\nvoid br_stp_disable_bridge(struct net_bridge *br)\r\n{\r\nstruct net_bridge_port *p;\r\nspin_lock_bh(&br->lock);\r\nlist_for_each_entry(p, &br->port_list, list) {\r\nif (p->state != BR_STATE_DISABLED)\r\nbr_stp_disable_port(p);\r\n}\r\nbr->topology_change = 0;\r\nbr->topology_change_detected = 0;\r\nspin_unlock_bh(&br->lock);\r\ndel_timer_sync(&br->hello_timer);\r\ndel_timer_sync(&br->topology_change_timer);\r\ndel_timer_sync(&br->tcn_timer);\r\ndel_timer_sync(&br->gc_timer);\r\n}\r\nvoid br_stp_enable_port(struct net_bridge_port *p)\r\n{\r\nbr_init_port(p);\r\nbr_port_state_selection(p->br);\r\nbr_log_state(p);\r\nbr_ifinfo_notify(RTM_NEWLINK, p);\r\n}\r\nvoid br_stp_disable_port(struct net_bridge_port *p)\r\n{\r\nstruct net_bridge *br = p->br;\r\nint wasroot;\r\nwasroot = br_is_root_bridge(br);\r\nbr_become_designated_port(p);\r\nbr_set_state(p, BR_STATE_DISABLED);\r\np->topology_change_ack = 0;\r\np->config_pending = 0;\r\nbr_log_state(p);\r\nbr_ifinfo_notify(RTM_NEWLINK, p);\r\ndel_timer(&p->message_age_timer);\r\ndel_timer(&p->forward_delay_timer);\r\ndel_timer(&p->hold_timer);\r\nbr_fdb_delete_by_port(br, p, 0);\r\nbr_multicast_disable_port(p);\r\nbr_configuration_update(br);\r\nbr_port_state_selection(br);\r\nif (br_is_root_bridge(br) && !wasroot)\r\nbr_become_root_bridge(br);\r\n}\r\nstatic void br_stp_start(struct net_bridge *br)\r\n{\r\nint r;\r\nchar *argv[] = { BR_STP_PROG, br->dev->name, "start", NULL };\r\nchar *envp[] = { NULL };\r\nr = call_usermodehelper(BR_STP_PROG, argv, envp, UMH_WAIT_PROC);\r\nspin_lock_bh(&br->lock);\r\nif (br->bridge_forward_delay < BR_MIN_FORWARD_DELAY)\r\n__br_set_forward_delay(br, BR_MIN_FORWARD_DELAY);\r\nelse if (br->bridge_forward_delay > BR_MAX_FORWARD_DELAY)\r\n__br_set_forward_delay(br, BR_MAX_FORWARD_DELAY);\r\nif (r == 0) {\r\nbr->stp_enabled = BR_USER_STP;\r\nbr_debug(br, "userspace STP started\n");\r\n} else {\r\nbr->stp_enabled = BR_KERNEL_STP;\r\nbr_debug(br, "using kernel STP\n");\r\nbr_port_state_selection(br);\r\n}\r\nspin_unlock_bh(&br->lock);\r\n}\r\nstatic void br_stp_stop(struct net_bridge *br)\r\n{\r\nint r;\r\nchar *argv[] = { BR_STP_PROG, br->dev->name, "stop", NULL };\r\nchar *envp[] = { NULL };\r\nif (br->stp_enabled == BR_USER_STP) {\r\nr = call_usermodehelper(BR_STP_PROG, argv, envp, UMH_WAIT_PROC);\r\nbr_info(br, "userspace STP stopped, return code %d\n", r);\r\nspin_lock_bh(&br->lock);\r\nbr_port_state_selection(br);\r\nspin_unlock_bh(&br->lock);\r\n}\r\nbr->stp_enabled = BR_NO_STP;\r\n}\r\nvoid br_stp_set_enabled(struct net_bridge *br, unsigned long val)\r\n{\r\nASSERT_RTNL();\r\nif (val) {\r\nif (br->stp_enabled == BR_NO_STP)\r\nbr_stp_start(br);\r\n} else {\r\nif (br->stp_enabled != BR_NO_STP)\r\nbr_stp_stop(br);\r\n}\r\n}\r\nvoid br_stp_change_bridge_id(struct net_bridge *br, const unsigned char *addr)\r\n{\r\nunsigned short oldaddr_aligned[ETH_ALEN >> 1];\r\nunsigned char *oldaddr = (unsigned char *)oldaddr_aligned;\r\nstruct net_bridge_port *p;\r\nint wasroot;\r\nwasroot = br_is_root_bridge(br);\r\nbr_fdb_change_mac_address(br, addr);\r\nmemcpy(oldaddr, br->bridge_id.addr, ETH_ALEN);\r\nmemcpy(br->bridge_id.addr, addr, ETH_ALEN);\r\nmemcpy(br->dev->dev_addr, addr, ETH_ALEN);\r\nlist_for_each_entry(p, &br->port_list, list) {\r\nif (ether_addr_equal(p->designated_bridge.addr, oldaddr))\r\nmemcpy(p->designated_bridge.addr, addr, ETH_ALEN);\r\nif (ether_addr_equal(p->designated_root.addr, oldaddr))\r\nmemcpy(p->designated_root.addr, addr, ETH_ALEN);\r\n}\r\nbr_configuration_update(br);\r\nbr_port_state_selection(br);\r\nif (br_is_root_bridge(br) && !wasroot)\r\nbr_become_root_bridge(br);\r\n}\r\nbool br_stp_recalculate_bridge_id(struct net_bridge *br)\r\n{\r\nconst unsigned char *br_mac_zero =\r\n(const unsigned char *)br_mac_zero_aligned;\r\nconst unsigned char *addr = br_mac_zero;\r\nstruct net_bridge_port *p;\r\nif (br->dev->addr_assign_type == NET_ADDR_SET)\r\nreturn false;\r\nlist_for_each_entry(p, &br->port_list, list) {\r\nif (addr == br_mac_zero ||\r\nmemcmp(p->dev->dev_addr, addr, ETH_ALEN) < 0)\r\naddr = p->dev->dev_addr;\r\n}\r\nif (ether_addr_equal(br->bridge_id.addr, addr))\r\nreturn false;\r\nbr_stp_change_bridge_id(br, addr);\r\nreturn true;\r\n}\r\nvoid br_stp_set_bridge_priority(struct net_bridge *br, u16 newprio)\r\n{\r\nstruct net_bridge_port *p;\r\nint wasroot;\r\nwasroot = br_is_root_bridge(br);\r\nlist_for_each_entry(p, &br->port_list, list) {\r\nif (p->state != BR_STATE_DISABLED &&\r\nbr_is_designated_port(p)) {\r\np->designated_bridge.prio[0] = (newprio >> 8) & 0xFF;\r\np->designated_bridge.prio[1] = newprio & 0xFF;\r\n}\r\n}\r\nbr->bridge_id.prio[0] = (newprio >> 8) & 0xFF;\r\nbr->bridge_id.prio[1] = newprio & 0xFF;\r\nbr_configuration_update(br);\r\nbr_port_state_selection(br);\r\nif (br_is_root_bridge(br) && !wasroot)\r\nbr_become_root_bridge(br);\r\n}\r\nint br_stp_set_port_priority(struct net_bridge_port *p, unsigned long newprio)\r\n{\r\nport_id new_port_id;\r\nif (newprio > BR_MAX_PORT_PRIORITY)\r\nreturn -ERANGE;\r\nnew_port_id = br_make_port_id(newprio, p->port_no);\r\nif (br_is_designated_port(p))\r\np->designated_port = new_port_id;\r\np->port_id = new_port_id;\r\np->priority = newprio;\r\nif (!memcmp(&p->br->bridge_id, &p->designated_bridge, 8) &&\r\np->port_id < p->designated_port) {\r\nbr_become_designated_port(p);\r\nbr_port_state_selection(p->br);\r\n}\r\nreturn 0;\r\n}\r\nint br_stp_set_path_cost(struct net_bridge_port *p, unsigned long path_cost)\r\n{\r\nif (path_cost < BR_MIN_PATH_COST ||\r\npath_cost > BR_MAX_PATH_COST)\r\nreturn -ERANGE;\r\np->flags |= BR_ADMIN_COST;\r\np->path_cost = path_cost;\r\nbr_configuration_update(p->br);\r\nbr_port_state_selection(p->br);\r\nreturn 0;\r\n}\r\nssize_t br_show_bridge_id(char *buf, const struct bridge_id *id)\r\n{\r\nreturn sprintf(buf, "%.2x%.2x.%.2x%.2x%.2x%.2x%.2x%.2x\n",\r\nid->prio[0], id->prio[1],\r\nid->addr[0], id->addr[1], id->addr[2],\r\nid->addr[3], id->addr[4], id->addr[5]);\r\n}
