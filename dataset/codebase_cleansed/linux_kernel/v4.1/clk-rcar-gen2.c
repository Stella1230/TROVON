static unsigned long cpg_z_clk_recalc_rate(struct clk_hw *hw,\r\nunsigned long parent_rate)\r\n{\r\nstruct cpg_z_clk *zclk = to_z_clk(hw);\r\nunsigned int mult;\r\nunsigned int val;\r\nval = (clk_readl(zclk->reg) & CPG_FRQCRC_ZFC_MASK)\r\n>> CPG_FRQCRC_ZFC_SHIFT;\r\nmult = 32 - val;\r\nreturn div_u64((u64)parent_rate * mult, 32);\r\n}\r\nstatic long cpg_z_clk_round_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long *parent_rate)\r\n{\r\nunsigned long prate = *parent_rate;\r\nunsigned int mult;\r\nif (!prate)\r\nprate = 1;\r\nmult = div_u64((u64)rate * 32, prate);\r\nmult = clamp(mult, 1U, 32U);\r\nreturn *parent_rate / 32 * mult;\r\n}\r\nstatic int cpg_z_clk_set_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long parent_rate)\r\n{\r\nstruct cpg_z_clk *zclk = to_z_clk(hw);\r\nunsigned int mult;\r\nu32 val, kick;\r\nunsigned int i;\r\nmult = div_u64((u64)rate * 32, parent_rate);\r\nmult = clamp(mult, 1U, 32U);\r\nif (clk_readl(zclk->kick_reg) & CPG_FRQCRB_KICK)\r\nreturn -EBUSY;\r\nval = clk_readl(zclk->reg);\r\nval &= ~CPG_FRQCRC_ZFC_MASK;\r\nval |= (32 - mult) << CPG_FRQCRC_ZFC_SHIFT;\r\nclk_writel(val, zclk->reg);\r\nkick = clk_readl(zclk->kick_reg);\r\nkick |= CPG_FRQCRB_KICK;\r\nclk_writel(kick, zclk->kick_reg);\r\nfor (i = 1000; i; i--) {\r\nif (!(clk_readl(zclk->kick_reg) & CPG_FRQCRB_KICK))\r\nreturn 0;\r\ncpu_relax();\r\n}\r\nreturn -ETIMEDOUT;\r\n}\r\nstatic struct clk * __init cpg_z_clk_register(struct rcar_gen2_cpg *cpg)\r\n{\r\nstatic const char *parent_name = "pll0";\r\nstruct clk_init_data init;\r\nstruct cpg_z_clk *zclk;\r\nstruct clk *clk;\r\nzclk = kzalloc(sizeof(*zclk), GFP_KERNEL);\r\nif (!zclk)\r\nreturn ERR_PTR(-ENOMEM);\r\ninit.name = "z";\r\ninit.ops = &cpg_z_clk_ops;\r\ninit.flags = 0;\r\ninit.parent_names = &parent_name;\r\ninit.num_parents = 1;\r\nzclk->reg = cpg->reg + CPG_FRQCRC;\r\nzclk->kick_reg = cpg->reg + CPG_FRQCRB;\r\nzclk->hw.init = &init;\r\nclk = clk_register(NULL, &zclk->hw);\r\nif (IS_ERR(clk))\r\nkfree(zclk);\r\nreturn clk;\r\n}\r\nstatic struct clk * __init cpg_rcan_clk_register(struct rcar_gen2_cpg *cpg,\r\nstruct device_node *np)\r\n{\r\nconst char *parent_name = of_clk_get_parent_name(np, 1);\r\nstruct clk_fixed_factor *fixed;\r\nstruct clk_gate *gate;\r\nstruct clk *clk;\r\nfixed = kzalloc(sizeof(*fixed), GFP_KERNEL);\r\nif (!fixed)\r\nreturn ERR_PTR(-ENOMEM);\r\nfixed->mult = 1;\r\nfixed->div = 6;\r\ngate = kzalloc(sizeof(*gate), GFP_KERNEL);\r\nif (!gate) {\r\nkfree(fixed);\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\ngate->reg = cpg->reg + CPG_RCANCKCR;\r\ngate->bit_idx = 8;\r\ngate->flags = CLK_GATE_SET_TO_DISABLE;\r\ngate->lock = &cpg->lock;\r\nclk = clk_register_composite(NULL, "rcan", &parent_name, 1, NULL, NULL,\r\n&fixed->hw, &clk_fixed_factor_ops,\r\n&gate->hw, &clk_gate_ops, 0);\r\nif (IS_ERR(clk)) {\r\nkfree(gate);\r\nkfree(fixed);\r\n}\r\nreturn clk;\r\n}\r\nstatic struct clk * __init cpg_adsp_clk_register(struct rcar_gen2_cpg *cpg)\r\n{\r\nconst char *parent_name = "pll1";\r\nstruct clk_divider *div;\r\nstruct clk_gate *gate;\r\nstruct clk *clk;\r\ndiv = kzalloc(sizeof(*div), GFP_KERNEL);\r\nif (!div)\r\nreturn ERR_PTR(-ENOMEM);\r\ndiv->reg = cpg->reg + CPG_ADSPCKCR;\r\ndiv->width = 4;\r\ndiv->table = cpg_adsp_div_table;\r\ndiv->lock = &cpg->lock;\r\ngate = kzalloc(sizeof(*gate), GFP_KERNEL);\r\nif (!gate) {\r\nkfree(div);\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\ngate->reg = cpg->reg + CPG_ADSPCKCR;\r\ngate->bit_idx = 8;\r\ngate->flags = CLK_GATE_SET_TO_DISABLE;\r\ngate->lock = &cpg->lock;\r\nclk = clk_register_composite(NULL, "adsp", &parent_name, 1, NULL, NULL,\r\n&div->hw, &clk_divider_ops,\r\n&gate->hw, &clk_gate_ops, 0);\r\nif (IS_ERR(clk)) {\r\nkfree(gate);\r\nkfree(div);\r\n}\r\nreturn clk;\r\n}\r\nstatic struct clk * __init\r\nrcar_gen2_cpg_register_clock(struct device_node *np, struct rcar_gen2_cpg *cpg,\r\nconst struct cpg_pll_config *config,\r\nconst char *name)\r\n{\r\nconst struct clk_div_table *table = NULL;\r\nconst char *parent_name;\r\nunsigned int shift;\r\nunsigned int mult = 1;\r\nunsigned int div = 1;\r\nif (!strcmp(name, "main")) {\r\nparent_name = of_clk_get_parent_name(np, 0);\r\ndiv = config->extal_div;\r\n} else if (!strcmp(name, "pll0")) {\r\nu32 value = clk_readl(cpg->reg + CPG_PLL0CR);\r\nparent_name = "main";\r\nmult = ((value >> 24) & ((1 << 7) - 1)) + 1;\r\n} else if (!strcmp(name, "pll1")) {\r\nparent_name = "main";\r\nmult = config->pll1_mult / 2;\r\n} else if (!strcmp(name, "pll3")) {\r\nparent_name = "main";\r\nmult = config->pll3_mult;\r\n} else if (!strcmp(name, "lb")) {\r\nparent_name = "pll1";\r\ndiv = cpg_mode & BIT(18) ? 36 : 24;\r\n} else if (!strcmp(name, "qspi")) {\r\nparent_name = "pll1_div2";\r\ndiv = (cpg_mode & (BIT(3) | BIT(2) | BIT(1))) == BIT(2)\r\n? 8 : 10;\r\n} else if (!strcmp(name, "sdh")) {\r\nparent_name = "pll1";\r\ntable = cpg_sdh_div_table;\r\nshift = 8;\r\n} else if (!strcmp(name, "sd0")) {\r\nparent_name = "pll1";\r\ntable = cpg_sd01_div_table;\r\nshift = 4;\r\n} else if (!strcmp(name, "sd1")) {\r\nparent_name = "pll1";\r\ntable = cpg_sd01_div_table;\r\nshift = 0;\r\n} else if (!strcmp(name, "z")) {\r\nreturn cpg_z_clk_register(cpg);\r\n} else if (!strcmp(name, "rcan")) {\r\nreturn cpg_rcan_clk_register(cpg, np);\r\n} else if (!strcmp(name, "adsp")) {\r\nreturn cpg_adsp_clk_register(cpg);\r\n} else {\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nif (!table)\r\nreturn clk_register_fixed_factor(NULL, name, parent_name, 0,\r\nmult, div);\r\nelse\r\nreturn clk_register_divider_table(NULL, name, parent_name, 0,\r\ncpg->reg + CPG_SDCKCR, shift,\r\n4, 0, table, &cpg->lock);\r\n}\r\nstatic void __init rcar_gen2_cpg_clocks_init(struct device_node *np)\r\n{\r\nconst struct cpg_pll_config *config;\r\nstruct rcar_gen2_cpg *cpg;\r\nstruct clk **clks;\r\nunsigned int i;\r\nint num_clks;\r\nnum_clks = of_property_count_strings(np, "clock-output-names");\r\nif (num_clks < 0) {\r\npr_err("%s: failed to count clocks\n", __func__);\r\nreturn;\r\n}\r\ncpg = kzalloc(sizeof(*cpg), GFP_KERNEL);\r\nclks = kzalloc(num_clks * sizeof(*clks), GFP_KERNEL);\r\nif (cpg == NULL || clks == NULL) {\r\npr_err("%s: failed to allocate cpg\n", __func__);\r\nreturn;\r\n}\r\nspin_lock_init(&cpg->lock);\r\ncpg->data.clks = clks;\r\ncpg->data.clk_num = num_clks;\r\ncpg->reg = of_iomap(np, 0);\r\nif (WARN_ON(cpg->reg == NULL))\r\nreturn;\r\nconfig = &cpg_pll_configs[CPG_PLL_CONFIG_INDEX(cpg_mode)];\r\nfor (i = 0; i < num_clks; ++i) {\r\nconst char *name;\r\nstruct clk *clk;\r\nof_property_read_string_index(np, "clock-output-names", i,\r\n&name);\r\nclk = rcar_gen2_cpg_register_clock(np, cpg, config, name);\r\nif (IS_ERR(clk))\r\npr_err("%s: failed to register %s %s clock (%ld)\n",\r\n__func__, np->name, name, PTR_ERR(clk));\r\nelse\r\ncpg->data.clks[i] = clk;\r\n}\r\nof_clk_add_provider(np, of_clk_src_onecell_get, &cpg->data);\r\n}\r\nvoid __init rcar_gen2_clocks_init(u32 mode)\r\n{\r\ncpg_mode = mode;\r\nof_clk_init(NULL);\r\n}
