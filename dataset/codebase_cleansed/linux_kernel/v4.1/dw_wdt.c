static inline int dw_wdt_is_enabled(void)\r\n{\r\nreturn readl(dw_wdt.regs + WDOG_CONTROL_REG_OFFSET) &\r\nWDOG_CONTROL_REG_WDT_EN_MASK;\r\n}\r\nstatic inline int dw_wdt_top_in_seconds(unsigned top)\r\n{\r\nreturn (1 << (16 + top)) / clk_get_rate(dw_wdt.clk);\r\n}\r\nstatic int dw_wdt_get_top(void)\r\n{\r\nint top = readl(dw_wdt.regs + WDOG_TIMEOUT_RANGE_REG_OFFSET) & 0xF;\r\nreturn dw_wdt_top_in_seconds(top);\r\n}\r\nstatic inline void dw_wdt_set_next_heartbeat(void)\r\n{\r\ndw_wdt.next_heartbeat = jiffies + dw_wdt_get_top() * HZ;\r\n}\r\nstatic void dw_wdt_keepalive(void)\r\n{\r\nwritel(WDOG_COUNTER_RESTART_KICK_VALUE, dw_wdt.regs +\r\nWDOG_COUNTER_RESTART_REG_OFFSET);\r\n}\r\nstatic int dw_wdt_set_top(unsigned top_s)\r\n{\r\nint i, top_val = DW_WDT_MAX_TOP;\r\nfor (i = 0; i <= DW_WDT_MAX_TOP; ++i)\r\nif (dw_wdt_top_in_seconds(i) >= top_s) {\r\ntop_val = i;\r\nbreak;\r\n}\r\nwritel(top_val | top_val << WDOG_TIMEOUT_RANGE_TOPINIT_SHIFT,\r\ndw_wdt.regs + WDOG_TIMEOUT_RANGE_REG_OFFSET);\r\ndw_wdt_keepalive();\r\ndw_wdt_set_next_heartbeat();\r\nreturn dw_wdt_top_in_seconds(top_val);\r\n}\r\nstatic int dw_wdt_restart_handle(struct notifier_block *this,\r\nunsigned long mode, void *cmd)\r\n{\r\nu32 val;\r\nwritel(0, dw_wdt.regs + WDOG_TIMEOUT_RANGE_REG_OFFSET);\r\nval = readl(dw_wdt.regs + WDOG_CONTROL_REG_OFFSET);\r\nif (val & WDOG_CONTROL_REG_WDT_EN_MASK)\r\nwritel(WDOG_COUNTER_RESTART_KICK_VALUE, dw_wdt.regs +\r\nWDOG_COUNTER_RESTART_REG_OFFSET);\r\nelse\r\nwritel(WDOG_CONTROL_REG_WDT_EN_MASK,\r\ndw_wdt.regs + WDOG_CONTROL_REG_OFFSET);\r\nmdelay(500);\r\nreturn NOTIFY_DONE;\r\n}\r\nstatic void dw_wdt_ping(unsigned long data)\r\n{\r\nif (time_before(jiffies, dw_wdt.next_heartbeat) ||\r\n(!nowayout && !dw_wdt.in_use)) {\r\ndw_wdt_keepalive();\r\nmod_timer(&dw_wdt.timer, jiffies + WDT_TIMEOUT);\r\n} else\r\npr_crit("keepalive missed, machine will reset\n");\r\n}\r\nstatic int dw_wdt_open(struct inode *inode, struct file *filp)\r\n{\r\nif (test_and_set_bit(0, &dw_wdt.in_use))\r\nreturn -EBUSY;\r\n__module_get(THIS_MODULE);\r\nspin_lock(&dw_wdt.lock);\r\nif (!dw_wdt_is_enabled()) {\r\ndw_wdt_set_top(DW_WDT_DEFAULT_SECONDS);\r\nwritel(WDOG_CONTROL_REG_WDT_EN_MASK,\r\ndw_wdt.regs + WDOG_CONTROL_REG_OFFSET);\r\n}\r\ndw_wdt_set_next_heartbeat();\r\nspin_unlock(&dw_wdt.lock);\r\nreturn nonseekable_open(inode, filp);\r\n}\r\nstatic ssize_t dw_wdt_write(struct file *filp, const char __user *buf,\r\nsize_t len, loff_t *offset)\r\n{\r\nif (!len)\r\nreturn 0;\r\nif (!nowayout) {\r\nsize_t i;\r\ndw_wdt.expect_close = 0;\r\nfor (i = 0; i < len; ++i) {\r\nchar c;\r\nif (get_user(c, buf + i))\r\nreturn -EFAULT;\r\nif (c == 'V') {\r\ndw_wdt.expect_close = 1;\r\nbreak;\r\n}\r\n}\r\n}\r\ndw_wdt_set_next_heartbeat();\r\nmod_timer(&dw_wdt.timer, jiffies + WDT_TIMEOUT);\r\nreturn len;\r\n}\r\nstatic u32 dw_wdt_time_left(void)\r\n{\r\nreturn readl(dw_wdt.regs + WDOG_CURRENT_COUNT_REG_OFFSET) /\r\nclk_get_rate(dw_wdt.clk);\r\n}\r\nstatic long dw_wdt_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)\r\n{\r\nunsigned long val;\r\nint timeout;\r\nswitch (cmd) {\r\ncase WDIOC_GETSUPPORT:\r\nreturn copy_to_user((void __user *)arg, &dw_wdt_ident,\r\nsizeof(dw_wdt_ident)) ? -EFAULT : 0;\r\ncase WDIOC_GETSTATUS:\r\ncase WDIOC_GETBOOTSTATUS:\r\nreturn put_user(0, (int __user *)arg);\r\ncase WDIOC_KEEPALIVE:\r\ndw_wdt_set_next_heartbeat();\r\nreturn 0;\r\ncase WDIOC_SETTIMEOUT:\r\nif (get_user(val, (int __user *)arg))\r\nreturn -EFAULT;\r\ntimeout = dw_wdt_set_top(val);\r\nreturn put_user(timeout , (int __user *)arg);\r\ncase WDIOC_GETTIMEOUT:\r\nreturn put_user(dw_wdt_get_top(), (int __user *)arg);\r\ncase WDIOC_GETTIMELEFT:\r\nif (get_user(val, (int __user *)arg))\r\nreturn -EFAULT;\r\nreturn put_user(dw_wdt_time_left(), (int __user *)arg);\r\ndefault:\r\nreturn -ENOTTY;\r\n}\r\n}\r\nstatic int dw_wdt_release(struct inode *inode, struct file *filp)\r\n{\r\nclear_bit(0, &dw_wdt.in_use);\r\nif (!dw_wdt.expect_close) {\r\ndel_timer(&dw_wdt.timer);\r\nif (!nowayout)\r\npr_crit("unexpected close, system will reboot soon\n");\r\nelse\r\npr_crit("watchdog cannot be disabled, system will reboot soon\n");\r\n}\r\ndw_wdt.expect_close = 0;\r\nreturn 0;\r\n}\r\nstatic int dw_wdt_suspend(struct device *dev)\r\n{\r\nclk_disable_unprepare(dw_wdt.clk);\r\nreturn 0;\r\n}\r\nstatic int dw_wdt_resume(struct device *dev)\r\n{\r\nint err = clk_prepare_enable(dw_wdt.clk);\r\nif (err)\r\nreturn err;\r\ndw_wdt_keepalive();\r\nreturn 0;\r\n}\r\nstatic int dw_wdt_drv_probe(struct platform_device *pdev)\r\n{\r\nint ret;\r\nstruct resource *mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\ndw_wdt.regs = devm_ioremap_resource(&pdev->dev, mem);\r\nif (IS_ERR(dw_wdt.regs))\r\nreturn PTR_ERR(dw_wdt.regs);\r\ndw_wdt.clk = devm_clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(dw_wdt.clk))\r\nreturn PTR_ERR(dw_wdt.clk);\r\nret = clk_prepare_enable(dw_wdt.clk);\r\nif (ret)\r\nreturn ret;\r\nspin_lock_init(&dw_wdt.lock);\r\nret = misc_register(&dw_wdt_miscdev);\r\nif (ret)\r\ngoto out_disable_clk;\r\ndw_wdt.restart_handler.notifier_call = dw_wdt_restart_handle;\r\ndw_wdt.restart_handler.priority = 128;\r\nret = register_restart_handler(&dw_wdt.restart_handler);\r\nif (ret)\r\npr_warn("cannot register restart handler\n");\r\ndw_wdt_set_next_heartbeat();\r\nsetup_timer(&dw_wdt.timer, dw_wdt_ping, 0);\r\nmod_timer(&dw_wdt.timer, jiffies + WDT_TIMEOUT);\r\nreturn 0;\r\nout_disable_clk:\r\nclk_disable_unprepare(dw_wdt.clk);\r\nreturn ret;\r\n}\r\nstatic int dw_wdt_drv_remove(struct platform_device *pdev)\r\n{\r\nunregister_restart_handler(&dw_wdt.restart_handler);\r\nmisc_deregister(&dw_wdt_miscdev);\r\nclk_disable_unprepare(dw_wdt.clk);\r\nreturn 0;\r\n}
