static inline void etm_writel(struct etm_drvdata *drvdata,\r\nu32 val, u32 off)\r\n{\r\nif (drvdata->use_cp14) {\r\nif (etm_writel_cp14(off, val)) {\r\ndev_err(drvdata->dev,\r\n"invalid CP14 access to ETM reg: %#x", off);\r\n}\r\n} else {\r\nwritel_relaxed(val, drvdata->base + off);\r\n}\r\n}\r\nstatic inline unsigned int etm_readl(struct etm_drvdata *drvdata, u32 off)\r\n{\r\nu32 val;\r\nif (drvdata->use_cp14) {\r\nif (etm_readl_cp14(off, &val)) {\r\ndev_err(drvdata->dev,\r\n"invalid CP14 access to ETM reg: %#x", off);\r\n}\r\n} else {\r\nval = readl_relaxed(drvdata->base + off);\r\n}\r\nreturn val;\r\n}\r\nstatic void etm_os_unlock(void *info)\r\n{\r\nstruct etm_drvdata *drvdata = (struct etm_drvdata *)info;\r\netm_writel(drvdata, 0x0, ETMOSLAR);\r\nisb();\r\n}\r\nstatic void etm_set_pwrdwn(struct etm_drvdata *drvdata)\r\n{\r\nu32 etmcr;\r\nmb();\r\nisb();\r\netmcr = etm_readl(drvdata, ETMCR);\r\netmcr |= ETMCR_PWD_DWN;\r\netm_writel(drvdata, etmcr, ETMCR);\r\n}\r\nstatic void etm_clr_pwrdwn(struct etm_drvdata *drvdata)\r\n{\r\nu32 etmcr;\r\netmcr = etm_readl(drvdata, ETMCR);\r\netmcr &= ~ETMCR_PWD_DWN;\r\netm_writel(drvdata, etmcr, ETMCR);\r\nmb();\r\nisb();\r\n}\r\nstatic void etm_set_pwrup(struct etm_drvdata *drvdata)\r\n{\r\nu32 etmpdcr;\r\netmpdcr = readl_relaxed(drvdata->base + ETMPDCR);\r\netmpdcr |= ETMPDCR_PWD_UP;\r\nwritel_relaxed(etmpdcr, drvdata->base + ETMPDCR);\r\nmb();\r\nisb();\r\n}\r\nstatic void etm_clr_pwrup(struct etm_drvdata *drvdata)\r\n{\r\nu32 etmpdcr;\r\nmb();\r\nisb();\r\netmpdcr = readl_relaxed(drvdata->base + ETMPDCR);\r\netmpdcr &= ~ETMPDCR_PWD_UP;\r\nwritel_relaxed(etmpdcr, drvdata->base + ETMPDCR);\r\n}\r\nstatic int coresight_timeout_etm(struct etm_drvdata *drvdata, u32 offset,\r\nint position, int value)\r\n{\r\nint i;\r\nu32 val;\r\nfor (i = TIMEOUT_US; i > 0; i--) {\r\nval = etm_readl(drvdata, offset);\r\nif (value) {\r\nif (val & BIT(position))\r\nreturn 0;\r\n} else {\r\nif (!(val & BIT(position)))\r\nreturn 0;\r\n}\r\nif (i - 1)\r\nudelay(1);\r\n}\r\nreturn -EAGAIN;\r\n}\r\nstatic void etm_set_prog(struct etm_drvdata *drvdata)\r\n{\r\nu32 etmcr;\r\netmcr = etm_readl(drvdata, ETMCR);\r\netmcr |= ETMCR_ETM_PRG;\r\netm_writel(drvdata, etmcr, ETMCR);\r\nisb();\r\nif (coresight_timeout_etm(drvdata, ETMSR, ETMSR_PROG_BIT, 1)) {\r\ndev_err(drvdata->dev,\r\n"timeout observed when probing at offset %#x\n", ETMSR);\r\n}\r\n}\r\nstatic void etm_clr_prog(struct etm_drvdata *drvdata)\r\n{\r\nu32 etmcr;\r\netmcr = etm_readl(drvdata, ETMCR);\r\netmcr &= ~ETMCR_ETM_PRG;\r\netm_writel(drvdata, etmcr, ETMCR);\r\nisb();\r\nif (coresight_timeout_etm(drvdata, ETMSR, ETMSR_PROG_BIT, 0)) {\r\ndev_err(drvdata->dev,\r\n"timeout observed when probing at offset %#x\n", ETMSR);\r\n}\r\n}\r\nstatic void etm_set_default(struct etm_drvdata *drvdata)\r\n{\r\nint i;\r\ndrvdata->trigger_event = ETM_DEFAULT_EVENT_VAL;\r\ndrvdata->enable_event = ETM_HARD_WIRE_RES_A;\r\ndrvdata->seq_12_event = ETM_DEFAULT_EVENT_VAL;\r\ndrvdata->seq_21_event = ETM_DEFAULT_EVENT_VAL;\r\ndrvdata->seq_23_event = ETM_DEFAULT_EVENT_VAL;\r\ndrvdata->seq_31_event = ETM_DEFAULT_EVENT_VAL;\r\ndrvdata->seq_32_event = ETM_DEFAULT_EVENT_VAL;\r\ndrvdata->seq_13_event = ETM_DEFAULT_EVENT_VAL;\r\ndrvdata->timestamp_event = ETM_DEFAULT_EVENT_VAL;\r\nfor (i = 0; i < drvdata->nr_cntr; i++) {\r\ndrvdata->cntr_rld_val[i] = 0x0;\r\ndrvdata->cntr_event[i] = ETM_DEFAULT_EVENT_VAL;\r\ndrvdata->cntr_rld_event[i] = ETM_DEFAULT_EVENT_VAL;\r\ndrvdata->cntr_val[i] = 0x0;\r\n}\r\ndrvdata->seq_curr_state = 0x0;\r\ndrvdata->ctxid_idx = 0x0;\r\nfor (i = 0; i < drvdata->nr_ctxid_cmp; i++)\r\ndrvdata->ctxid_val[i] = 0x0;\r\ndrvdata->ctxid_mask = 0x0;\r\n}\r\nstatic void etm_enable_hw(void *info)\r\n{\r\nint i;\r\nu32 etmcr;\r\nstruct etm_drvdata *drvdata = info;\r\nCS_UNLOCK(drvdata->base);\r\netm_clr_pwrdwn(drvdata);\r\netm_set_pwrup(drvdata);\r\netm_os_unlock(drvdata);\r\netm_set_prog(drvdata);\r\netmcr = etm_readl(drvdata, ETMCR);\r\netmcr &= (ETMCR_PWD_DWN | ETMCR_ETM_PRG);\r\netmcr |= drvdata->port_size;\r\netm_writel(drvdata, drvdata->ctrl | etmcr, ETMCR);\r\netm_writel(drvdata, drvdata->trigger_event, ETMTRIGGER);\r\netm_writel(drvdata, drvdata->startstop_ctrl, ETMTSSCR);\r\netm_writel(drvdata, drvdata->enable_event, ETMTEEVR);\r\netm_writel(drvdata, drvdata->enable_ctrl1, ETMTECR1);\r\netm_writel(drvdata, drvdata->fifofull_level, ETMFFLR);\r\nfor (i = 0; i < drvdata->nr_addr_cmp; i++) {\r\netm_writel(drvdata, drvdata->addr_val[i], ETMACVRn(i));\r\netm_writel(drvdata, drvdata->addr_acctype[i], ETMACTRn(i));\r\n}\r\nfor (i = 0; i < drvdata->nr_cntr; i++) {\r\netm_writel(drvdata, drvdata->cntr_rld_val[i], ETMCNTRLDVRn(i));\r\netm_writel(drvdata, drvdata->cntr_event[i], ETMCNTENRn(i));\r\netm_writel(drvdata, drvdata->cntr_rld_event[i],\r\nETMCNTRLDEVRn(i));\r\netm_writel(drvdata, drvdata->cntr_val[i], ETMCNTVRn(i));\r\n}\r\netm_writel(drvdata, drvdata->seq_12_event, ETMSQ12EVR);\r\netm_writel(drvdata, drvdata->seq_21_event, ETMSQ21EVR);\r\netm_writel(drvdata, drvdata->seq_23_event, ETMSQ23EVR);\r\netm_writel(drvdata, drvdata->seq_31_event, ETMSQ31EVR);\r\netm_writel(drvdata, drvdata->seq_32_event, ETMSQ32EVR);\r\netm_writel(drvdata, drvdata->seq_13_event, ETMSQ13EVR);\r\netm_writel(drvdata, drvdata->seq_curr_state, ETMSQR);\r\nfor (i = 0; i < drvdata->nr_ext_out; i++)\r\netm_writel(drvdata, ETM_DEFAULT_EVENT_VAL, ETMEXTOUTEVRn(i));\r\nfor (i = 0; i < drvdata->nr_ctxid_cmp; i++)\r\netm_writel(drvdata, drvdata->ctxid_val[i], ETMCIDCVRn(i));\r\netm_writel(drvdata, drvdata->ctxid_mask, ETMCIDCMR);\r\netm_writel(drvdata, drvdata->sync_freq, ETMSYNCFR);\r\netm_writel(drvdata, 0x0, ETMEXTINSELR);\r\netm_writel(drvdata, drvdata->timestamp_event, ETMTSEVR);\r\netm_writel(drvdata, 0x0, ETMAUXCR);\r\netm_writel(drvdata, drvdata->traceid, ETMTRACEIDR);\r\netm_writel(drvdata, 0x0, ETMVMIDCVR);\r\netm_writel(drvdata, drvdata->ctrl | ETMCR_ETM_EN | etmcr, ETMCR);\r\netm_clr_prog(drvdata);\r\nCS_LOCK(drvdata->base);\r\ndev_dbg(drvdata->dev, "cpu: %d enable smp call done\n", drvdata->cpu);\r\n}\r\nstatic int etm_trace_id_simple(struct etm_drvdata *drvdata)\r\n{\r\nif (!drvdata->enable)\r\nreturn drvdata->traceid;\r\nreturn (etm_readl(drvdata, ETMTRACEIDR) & ETM_TRACEID_MASK);\r\n}\r\nstatic int etm_trace_id(struct coresight_device *csdev)\r\n{\r\nstruct etm_drvdata *drvdata = dev_get_drvdata(csdev->dev.parent);\r\nunsigned long flags;\r\nint trace_id = -1;\r\nif (!drvdata->enable)\r\nreturn drvdata->traceid;\r\nif (clk_prepare_enable(drvdata->clk))\r\ngoto out;\r\nspin_lock_irqsave(&drvdata->spinlock, flags);\r\nCS_UNLOCK(drvdata->base);\r\ntrace_id = (etm_readl(drvdata, ETMTRACEIDR) & ETM_TRACEID_MASK);\r\nCS_LOCK(drvdata->base);\r\nspin_unlock_irqrestore(&drvdata->spinlock, flags);\r\nclk_disable_unprepare(drvdata->clk);\r\nout:\r\nreturn trace_id;\r\n}\r\nstatic int etm_enable(struct coresight_device *csdev)\r\n{\r\nstruct etm_drvdata *drvdata = dev_get_drvdata(csdev->dev.parent);\r\nint ret;\r\nret = clk_prepare_enable(drvdata->clk);\r\nif (ret)\r\ngoto err_clk;\r\nspin_lock(&drvdata->spinlock);\r\nif (cpu_online(drvdata->cpu)) {\r\nret = smp_call_function_single(drvdata->cpu,\r\netm_enable_hw, drvdata, 1);\r\nif (ret)\r\ngoto err;\r\n}\r\ndrvdata->enable = true;\r\ndrvdata->sticky_enable = true;\r\nspin_unlock(&drvdata->spinlock);\r\ndev_info(drvdata->dev, "ETM tracing enabled\n");\r\nreturn 0;\r\nerr:\r\nspin_unlock(&drvdata->spinlock);\r\nclk_disable_unprepare(drvdata->clk);\r\nerr_clk:\r\nreturn ret;\r\n}\r\nstatic void etm_disable_hw(void *info)\r\n{\r\nint i;\r\nstruct etm_drvdata *drvdata = info;\r\nCS_UNLOCK(drvdata->base);\r\netm_set_prog(drvdata);\r\netm_writel(drvdata, ETM_HARD_WIRE_RES_A | ETM_EVENT_NOT_A, ETMTEEVR);\r\ndrvdata->seq_curr_state = (etm_readl(drvdata, ETMSQR) & ETM_SQR_MASK);\r\nfor (i = 0; i < drvdata->nr_cntr; i++)\r\ndrvdata->cntr_val[i] = etm_readl(drvdata, ETMCNTVRn(i));\r\netm_set_pwrdwn(drvdata);\r\nCS_LOCK(drvdata->base);\r\ndev_dbg(drvdata->dev, "cpu: %d disable smp call done\n", drvdata->cpu);\r\n}\r\nstatic void etm_disable(struct coresight_device *csdev)\r\n{\r\nstruct etm_drvdata *drvdata = dev_get_drvdata(csdev->dev.parent);\r\nget_online_cpus();\r\nspin_lock(&drvdata->spinlock);\r\nsmp_call_function_single(drvdata->cpu, etm_disable_hw, drvdata, 1);\r\ndrvdata->enable = false;\r\nspin_unlock(&drvdata->spinlock);\r\nput_online_cpus();\r\nclk_disable_unprepare(drvdata->clk);\r\ndev_info(drvdata->dev, "ETM tracing disabled\n");\r\n}\r\nstatic ssize_t nr_addr_cmp_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nunsigned long val;\r\nstruct etm_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nval = drvdata->nr_addr_cmp;\r\nreturn sprintf(buf, "%#lx\n", val);\r\n}\r\nstatic ssize_t nr_cntr_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{ unsigned long val;\r\nstruct etm_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nval = drvdata->nr_cntr;\r\nreturn sprintf(buf, "%#lx\n", val);\r\n}\r\nstatic ssize_t nr_ctxid_cmp_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nunsigned long val;\r\nstruct etm_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nval = drvdata->nr_ctxid_cmp;\r\nreturn sprintf(buf, "%#lx\n", val);\r\n}\r\nstatic ssize_t etmsr_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nint ret;\r\nunsigned long flags, val;\r\nstruct etm_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nret = clk_prepare_enable(drvdata->clk);\r\nif (ret)\r\nreturn ret;\r\nspin_lock_irqsave(&drvdata->spinlock, flags);\r\nCS_UNLOCK(drvdata->base);\r\nval = etm_readl(drvdata, ETMSR);\r\nCS_LOCK(drvdata->base);\r\nspin_unlock_irqrestore(&drvdata->spinlock, flags);\r\nclk_disable_unprepare(drvdata->clk);\r\nreturn sprintf(buf, "%#lx\n", val);\r\n}\r\nstatic ssize_t reset_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t size)\r\n{\r\nint i, ret;\r\nunsigned long val;\r\nstruct etm_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nret = kstrtoul(buf, 16, &val);\r\nif (ret)\r\nreturn ret;\r\nif (val) {\r\nspin_lock(&drvdata->spinlock);\r\ndrvdata->mode = ETM_MODE_EXCLUDE;\r\ndrvdata->ctrl = 0x0;\r\ndrvdata->trigger_event = ETM_DEFAULT_EVENT_VAL;\r\ndrvdata->startstop_ctrl = 0x0;\r\ndrvdata->addr_idx = 0x0;\r\nfor (i = 0; i < drvdata->nr_addr_cmp; i++) {\r\ndrvdata->addr_val[i] = 0x0;\r\ndrvdata->addr_acctype[i] = 0x0;\r\ndrvdata->addr_type[i] = ETM_ADDR_TYPE_NONE;\r\n}\r\ndrvdata->cntr_idx = 0x0;\r\netm_set_default(drvdata);\r\nspin_unlock(&drvdata->spinlock);\r\n}\r\nreturn size;\r\n}\r\nstatic ssize_t mode_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nunsigned long val;\r\nstruct etm_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nval = drvdata->mode;\r\nreturn sprintf(buf, "%#lx\n", val);\r\n}\r\nstatic ssize_t mode_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t size)\r\n{\r\nint ret;\r\nunsigned long val;\r\nstruct etm_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nret = kstrtoul(buf, 16, &val);\r\nif (ret)\r\nreturn ret;\r\nspin_lock(&drvdata->spinlock);\r\ndrvdata->mode = val & ETM_MODE_ALL;\r\nif (drvdata->mode & ETM_MODE_EXCLUDE)\r\ndrvdata->enable_ctrl1 |= ETMTECR1_INC_EXC;\r\nelse\r\ndrvdata->enable_ctrl1 &= ~ETMTECR1_INC_EXC;\r\nif (drvdata->mode & ETM_MODE_CYCACC)\r\ndrvdata->ctrl |= ETMCR_CYC_ACC;\r\nelse\r\ndrvdata->ctrl &= ~ETMCR_CYC_ACC;\r\nif (drvdata->mode & ETM_MODE_STALL) {\r\nif (!(drvdata->etmccr & ETMCCR_FIFOFULL)) {\r\ndev_warn(drvdata->dev, "stall mode not supported\n");\r\nret = -EINVAL;\r\ngoto err_unlock;\r\n}\r\ndrvdata->ctrl |= ETMCR_STALL_MODE;\r\n} else\r\ndrvdata->ctrl &= ~ETMCR_STALL_MODE;\r\nif (drvdata->mode & ETM_MODE_TIMESTAMP) {\r\nif (!(drvdata->etmccer & ETMCCER_TIMESTAMP)) {\r\ndev_warn(drvdata->dev, "timestamp not supported\n");\r\nret = -EINVAL;\r\ngoto err_unlock;\r\n}\r\ndrvdata->ctrl |= ETMCR_TIMESTAMP_EN;\r\n} else\r\ndrvdata->ctrl &= ~ETMCR_TIMESTAMP_EN;\r\nif (drvdata->mode & ETM_MODE_CTXID)\r\ndrvdata->ctrl |= ETMCR_CTXID_SIZE;\r\nelse\r\ndrvdata->ctrl &= ~ETMCR_CTXID_SIZE;\r\nspin_unlock(&drvdata->spinlock);\r\nreturn size;\r\nerr_unlock:\r\nspin_unlock(&drvdata->spinlock);\r\nreturn ret;\r\n}\r\nstatic ssize_t trigger_event_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nunsigned long val;\r\nstruct etm_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nval = drvdata->trigger_event;\r\nreturn sprintf(buf, "%#lx\n", val);\r\n}\r\nstatic ssize_t trigger_event_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t size)\r\n{\r\nint ret;\r\nunsigned long val;\r\nstruct etm_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nret = kstrtoul(buf, 16, &val);\r\nif (ret)\r\nreturn ret;\r\ndrvdata->trigger_event = val & ETM_EVENT_MASK;\r\nreturn size;\r\n}\r\nstatic ssize_t enable_event_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nunsigned long val;\r\nstruct etm_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nval = drvdata->enable_event;\r\nreturn sprintf(buf, "%#lx\n", val);\r\n}\r\nstatic ssize_t enable_event_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t size)\r\n{\r\nint ret;\r\nunsigned long val;\r\nstruct etm_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nret = kstrtoul(buf, 16, &val);\r\nif (ret)\r\nreturn ret;\r\ndrvdata->enable_event = val & ETM_EVENT_MASK;\r\nreturn size;\r\n}\r\nstatic ssize_t fifofull_level_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nunsigned long val;\r\nstruct etm_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nval = drvdata->fifofull_level;\r\nreturn sprintf(buf, "%#lx\n", val);\r\n}\r\nstatic ssize_t fifofull_level_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t size)\r\n{\r\nint ret;\r\nunsigned long val;\r\nstruct etm_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nret = kstrtoul(buf, 16, &val);\r\nif (ret)\r\nreturn ret;\r\ndrvdata->fifofull_level = val;\r\nreturn size;\r\n}\r\nstatic ssize_t addr_idx_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nunsigned long val;\r\nstruct etm_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nval = drvdata->addr_idx;\r\nreturn sprintf(buf, "%#lx\n", val);\r\n}\r\nstatic ssize_t addr_idx_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t size)\r\n{\r\nint ret;\r\nunsigned long val;\r\nstruct etm_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nret = kstrtoul(buf, 16, &val);\r\nif (ret)\r\nreturn ret;\r\nif (val >= drvdata->nr_addr_cmp)\r\nreturn -EINVAL;\r\nspin_lock(&drvdata->spinlock);\r\ndrvdata->addr_idx = val;\r\nspin_unlock(&drvdata->spinlock);\r\nreturn size;\r\n}\r\nstatic ssize_t addr_single_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nu8 idx;\r\nunsigned long val;\r\nstruct etm_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nspin_lock(&drvdata->spinlock);\r\nidx = drvdata->addr_idx;\r\nif (!(drvdata->addr_type[idx] == ETM_ADDR_TYPE_NONE ||\r\ndrvdata->addr_type[idx] == ETM_ADDR_TYPE_SINGLE)) {\r\nspin_unlock(&drvdata->spinlock);\r\nreturn -EINVAL;\r\n}\r\nval = drvdata->addr_val[idx];\r\nspin_unlock(&drvdata->spinlock);\r\nreturn sprintf(buf, "%#lx\n", val);\r\n}\r\nstatic ssize_t addr_single_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t size)\r\n{\r\nu8 idx;\r\nint ret;\r\nunsigned long val;\r\nstruct etm_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nret = kstrtoul(buf, 16, &val);\r\nif (ret)\r\nreturn ret;\r\nspin_lock(&drvdata->spinlock);\r\nidx = drvdata->addr_idx;\r\nif (!(drvdata->addr_type[idx] == ETM_ADDR_TYPE_NONE ||\r\ndrvdata->addr_type[idx] == ETM_ADDR_TYPE_SINGLE)) {\r\nspin_unlock(&drvdata->spinlock);\r\nreturn -EINVAL;\r\n}\r\ndrvdata->addr_val[idx] = val;\r\ndrvdata->addr_type[idx] = ETM_ADDR_TYPE_SINGLE;\r\nspin_unlock(&drvdata->spinlock);\r\nreturn size;\r\n}\r\nstatic ssize_t addr_range_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nu8 idx;\r\nunsigned long val1, val2;\r\nstruct etm_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nspin_lock(&drvdata->spinlock);\r\nidx = drvdata->addr_idx;\r\nif (idx % 2 != 0) {\r\nspin_unlock(&drvdata->spinlock);\r\nreturn -EPERM;\r\n}\r\nif (!((drvdata->addr_type[idx] == ETM_ADDR_TYPE_NONE &&\r\ndrvdata->addr_type[idx + 1] == ETM_ADDR_TYPE_NONE) ||\r\n(drvdata->addr_type[idx] == ETM_ADDR_TYPE_RANGE &&\r\ndrvdata->addr_type[idx + 1] == ETM_ADDR_TYPE_RANGE))) {\r\nspin_unlock(&drvdata->spinlock);\r\nreturn -EPERM;\r\n}\r\nval1 = drvdata->addr_val[idx];\r\nval2 = drvdata->addr_val[idx + 1];\r\nspin_unlock(&drvdata->spinlock);\r\nreturn sprintf(buf, "%#lx %#lx\n", val1, val2);\r\n}\r\nstatic ssize_t addr_range_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t size)\r\n{\r\nu8 idx;\r\nunsigned long val1, val2;\r\nstruct etm_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nif (sscanf(buf, "%lx %lx", &val1, &val2) != 2)\r\nreturn -EINVAL;\r\nif (val1 > val2)\r\nreturn -EINVAL;\r\nspin_lock(&drvdata->spinlock);\r\nidx = drvdata->addr_idx;\r\nif (idx % 2 != 0) {\r\nspin_unlock(&drvdata->spinlock);\r\nreturn -EPERM;\r\n}\r\nif (!((drvdata->addr_type[idx] == ETM_ADDR_TYPE_NONE &&\r\ndrvdata->addr_type[idx + 1] == ETM_ADDR_TYPE_NONE) ||\r\n(drvdata->addr_type[idx] == ETM_ADDR_TYPE_RANGE &&\r\ndrvdata->addr_type[idx + 1] == ETM_ADDR_TYPE_RANGE))) {\r\nspin_unlock(&drvdata->spinlock);\r\nreturn -EPERM;\r\n}\r\ndrvdata->addr_val[idx] = val1;\r\ndrvdata->addr_type[idx] = ETM_ADDR_TYPE_RANGE;\r\ndrvdata->addr_val[idx + 1] = val2;\r\ndrvdata->addr_type[idx + 1] = ETM_ADDR_TYPE_RANGE;\r\ndrvdata->enable_ctrl1 |= (1 << (idx/2));\r\nspin_unlock(&drvdata->spinlock);\r\nreturn size;\r\n}\r\nstatic ssize_t addr_start_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nu8 idx;\r\nunsigned long val;\r\nstruct etm_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nspin_lock(&drvdata->spinlock);\r\nidx = drvdata->addr_idx;\r\nif (!(drvdata->addr_type[idx] == ETM_ADDR_TYPE_NONE ||\r\ndrvdata->addr_type[idx] == ETM_ADDR_TYPE_START)) {\r\nspin_unlock(&drvdata->spinlock);\r\nreturn -EPERM;\r\n}\r\nval = drvdata->addr_val[idx];\r\nspin_unlock(&drvdata->spinlock);\r\nreturn sprintf(buf, "%#lx\n", val);\r\n}\r\nstatic ssize_t addr_start_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t size)\r\n{\r\nu8 idx;\r\nint ret;\r\nunsigned long val;\r\nstruct etm_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nret = kstrtoul(buf, 16, &val);\r\nif (ret)\r\nreturn ret;\r\nspin_lock(&drvdata->spinlock);\r\nidx = drvdata->addr_idx;\r\nif (!(drvdata->addr_type[idx] == ETM_ADDR_TYPE_NONE ||\r\ndrvdata->addr_type[idx] == ETM_ADDR_TYPE_START)) {\r\nspin_unlock(&drvdata->spinlock);\r\nreturn -EPERM;\r\n}\r\ndrvdata->addr_val[idx] = val;\r\ndrvdata->addr_type[idx] = ETM_ADDR_TYPE_START;\r\ndrvdata->startstop_ctrl |= (1 << idx);\r\ndrvdata->enable_ctrl1 |= BIT(25);\r\nspin_unlock(&drvdata->spinlock);\r\nreturn size;\r\n}\r\nstatic ssize_t addr_stop_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nu8 idx;\r\nunsigned long val;\r\nstruct etm_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nspin_lock(&drvdata->spinlock);\r\nidx = drvdata->addr_idx;\r\nif (!(drvdata->addr_type[idx] == ETM_ADDR_TYPE_NONE ||\r\ndrvdata->addr_type[idx] == ETM_ADDR_TYPE_STOP)) {\r\nspin_unlock(&drvdata->spinlock);\r\nreturn -EPERM;\r\n}\r\nval = drvdata->addr_val[idx];\r\nspin_unlock(&drvdata->spinlock);\r\nreturn sprintf(buf, "%#lx\n", val);\r\n}\r\nstatic ssize_t addr_stop_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t size)\r\n{\r\nu8 idx;\r\nint ret;\r\nunsigned long val;\r\nstruct etm_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nret = kstrtoul(buf, 16, &val);\r\nif (ret)\r\nreturn ret;\r\nspin_lock(&drvdata->spinlock);\r\nidx = drvdata->addr_idx;\r\nif (!(drvdata->addr_type[idx] == ETM_ADDR_TYPE_NONE ||\r\ndrvdata->addr_type[idx] == ETM_ADDR_TYPE_STOP)) {\r\nspin_unlock(&drvdata->spinlock);\r\nreturn -EPERM;\r\n}\r\ndrvdata->addr_val[idx] = val;\r\ndrvdata->addr_type[idx] = ETM_ADDR_TYPE_STOP;\r\ndrvdata->startstop_ctrl |= (1 << (idx + 16));\r\ndrvdata->enable_ctrl1 |= ETMTECR1_START_STOP;\r\nspin_unlock(&drvdata->spinlock);\r\nreturn size;\r\n}\r\nstatic ssize_t addr_acctype_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nunsigned long val;\r\nstruct etm_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nspin_lock(&drvdata->spinlock);\r\nval = drvdata->addr_acctype[drvdata->addr_idx];\r\nspin_unlock(&drvdata->spinlock);\r\nreturn sprintf(buf, "%#lx\n", val);\r\n}\r\nstatic ssize_t addr_acctype_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t size)\r\n{\r\nint ret;\r\nunsigned long val;\r\nstruct etm_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nret = kstrtoul(buf, 16, &val);\r\nif (ret)\r\nreturn ret;\r\nspin_lock(&drvdata->spinlock);\r\ndrvdata->addr_acctype[drvdata->addr_idx] = val;\r\nspin_unlock(&drvdata->spinlock);\r\nreturn size;\r\n}\r\nstatic ssize_t cntr_idx_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nunsigned long val;\r\nstruct etm_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nval = drvdata->cntr_idx;\r\nreturn sprintf(buf, "%#lx\n", val);\r\n}\r\nstatic ssize_t cntr_idx_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t size)\r\n{\r\nint ret;\r\nunsigned long val;\r\nstruct etm_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nret = kstrtoul(buf, 16, &val);\r\nif (ret)\r\nreturn ret;\r\nif (val >= drvdata->nr_cntr)\r\nreturn -EINVAL;\r\nspin_lock(&drvdata->spinlock);\r\ndrvdata->cntr_idx = val;\r\nspin_unlock(&drvdata->spinlock);\r\nreturn size;\r\n}\r\nstatic ssize_t cntr_rld_val_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nunsigned long val;\r\nstruct etm_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nspin_lock(&drvdata->spinlock);\r\nval = drvdata->cntr_rld_val[drvdata->cntr_idx];\r\nspin_unlock(&drvdata->spinlock);\r\nreturn sprintf(buf, "%#lx\n", val);\r\n}\r\nstatic ssize_t cntr_rld_val_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t size)\r\n{\r\nint ret;\r\nunsigned long val;\r\nstruct etm_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nret = kstrtoul(buf, 16, &val);\r\nif (ret)\r\nreturn ret;\r\nspin_lock(&drvdata->spinlock);\r\ndrvdata->cntr_rld_val[drvdata->cntr_idx] = val;\r\nspin_unlock(&drvdata->spinlock);\r\nreturn size;\r\n}\r\nstatic ssize_t cntr_event_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nunsigned long val;\r\nstruct etm_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nspin_lock(&drvdata->spinlock);\r\nval = drvdata->cntr_event[drvdata->cntr_idx];\r\nspin_unlock(&drvdata->spinlock);\r\nreturn sprintf(buf, "%#lx\n", val);\r\n}\r\nstatic ssize_t cntr_event_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t size)\r\n{\r\nint ret;\r\nunsigned long val;\r\nstruct etm_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nret = kstrtoul(buf, 16, &val);\r\nif (ret)\r\nreturn ret;\r\nspin_lock(&drvdata->spinlock);\r\ndrvdata->cntr_event[drvdata->cntr_idx] = val & ETM_EVENT_MASK;\r\nspin_unlock(&drvdata->spinlock);\r\nreturn size;\r\n}\r\nstatic ssize_t cntr_rld_event_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nunsigned long val;\r\nstruct etm_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nspin_lock(&drvdata->spinlock);\r\nval = drvdata->cntr_rld_event[drvdata->cntr_idx];\r\nspin_unlock(&drvdata->spinlock);\r\nreturn sprintf(buf, "%#lx\n", val);\r\n}\r\nstatic ssize_t cntr_rld_event_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t size)\r\n{\r\nint ret;\r\nunsigned long val;\r\nstruct etm_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nret = kstrtoul(buf, 16, &val);\r\nif (ret)\r\nreturn ret;\r\nspin_lock(&drvdata->spinlock);\r\ndrvdata->cntr_rld_event[drvdata->cntr_idx] = val & ETM_EVENT_MASK;\r\nspin_unlock(&drvdata->spinlock);\r\nreturn size;\r\n}\r\nstatic ssize_t cntr_val_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nint i, ret = 0;\r\nu32 val;\r\nstruct etm_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nif (!drvdata->enable) {\r\nspin_lock(&drvdata->spinlock);\r\nfor (i = 0; i < drvdata->nr_cntr; i++)\r\nret += sprintf(buf, "counter %d: %x\n",\r\ni, drvdata->cntr_val[i]);\r\nspin_unlock(&drvdata->spinlock);\r\nreturn ret;\r\n}\r\nfor (i = 0; i < drvdata->nr_cntr; i++) {\r\nval = etm_readl(drvdata, ETMCNTVRn(i));\r\nret += sprintf(buf, "counter %d: %x\n", i, val);\r\n}\r\nreturn ret;\r\n}\r\nstatic ssize_t cntr_val_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t size)\r\n{\r\nint ret;\r\nunsigned long val;\r\nstruct etm_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nret = kstrtoul(buf, 16, &val);\r\nif (ret)\r\nreturn ret;\r\nspin_lock(&drvdata->spinlock);\r\ndrvdata->cntr_val[drvdata->cntr_idx] = val;\r\nspin_unlock(&drvdata->spinlock);\r\nreturn size;\r\n}\r\nstatic ssize_t seq_12_event_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nunsigned long val;\r\nstruct etm_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nval = drvdata->seq_12_event;\r\nreturn sprintf(buf, "%#lx\n", val);\r\n}\r\nstatic ssize_t seq_12_event_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t size)\r\n{\r\nint ret;\r\nunsigned long val;\r\nstruct etm_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nret = kstrtoul(buf, 16, &val);\r\nif (ret)\r\nreturn ret;\r\ndrvdata->seq_12_event = val & ETM_EVENT_MASK;\r\nreturn size;\r\n}\r\nstatic ssize_t seq_21_event_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nunsigned long val;\r\nstruct etm_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nval = drvdata->seq_21_event;\r\nreturn sprintf(buf, "%#lx\n", val);\r\n}\r\nstatic ssize_t seq_21_event_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t size)\r\n{\r\nint ret;\r\nunsigned long val;\r\nstruct etm_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nret = kstrtoul(buf, 16, &val);\r\nif (ret)\r\nreturn ret;\r\ndrvdata->seq_21_event = val & ETM_EVENT_MASK;\r\nreturn size;\r\n}\r\nstatic ssize_t seq_23_event_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nunsigned long val;\r\nstruct etm_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nval = drvdata->seq_23_event;\r\nreturn sprintf(buf, "%#lx\n", val);\r\n}\r\nstatic ssize_t seq_23_event_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t size)\r\n{\r\nint ret;\r\nunsigned long val;\r\nstruct etm_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nret = kstrtoul(buf, 16, &val);\r\nif (ret)\r\nreturn ret;\r\ndrvdata->seq_23_event = val & ETM_EVENT_MASK;\r\nreturn size;\r\n}\r\nstatic ssize_t seq_31_event_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nunsigned long val;\r\nstruct etm_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nval = drvdata->seq_31_event;\r\nreturn sprintf(buf, "%#lx\n", val);\r\n}\r\nstatic ssize_t seq_31_event_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t size)\r\n{\r\nint ret;\r\nunsigned long val;\r\nstruct etm_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nret = kstrtoul(buf, 16, &val);\r\nif (ret)\r\nreturn ret;\r\ndrvdata->seq_31_event = val & ETM_EVENT_MASK;\r\nreturn size;\r\n}\r\nstatic ssize_t seq_32_event_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nunsigned long val;\r\nstruct etm_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nval = drvdata->seq_32_event;\r\nreturn sprintf(buf, "%#lx\n", val);\r\n}\r\nstatic ssize_t seq_32_event_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t size)\r\n{\r\nint ret;\r\nunsigned long val;\r\nstruct etm_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nret = kstrtoul(buf, 16, &val);\r\nif (ret)\r\nreturn ret;\r\ndrvdata->seq_32_event = val & ETM_EVENT_MASK;\r\nreturn size;\r\n}\r\nstatic ssize_t seq_13_event_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nunsigned long val;\r\nstruct etm_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nval = drvdata->seq_13_event;\r\nreturn sprintf(buf, "%#lx\n", val);\r\n}\r\nstatic ssize_t seq_13_event_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t size)\r\n{\r\nint ret;\r\nunsigned long val;\r\nstruct etm_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nret = kstrtoul(buf, 16, &val);\r\nif (ret)\r\nreturn ret;\r\ndrvdata->seq_13_event = val & ETM_EVENT_MASK;\r\nreturn size;\r\n}\r\nstatic ssize_t seq_curr_state_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nint ret;\r\nunsigned long val, flags;\r\nstruct etm_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nif (!drvdata->enable) {\r\nval = drvdata->seq_curr_state;\r\ngoto out;\r\n}\r\nret = clk_prepare_enable(drvdata->clk);\r\nif (ret)\r\nreturn ret;\r\nspin_lock_irqsave(&drvdata->spinlock, flags);\r\nCS_UNLOCK(drvdata->base);\r\nval = (etm_readl(drvdata, ETMSQR) & ETM_SQR_MASK);\r\nCS_LOCK(drvdata->base);\r\nspin_unlock_irqrestore(&drvdata->spinlock, flags);\r\nclk_disable_unprepare(drvdata->clk);\r\nout:\r\nreturn sprintf(buf, "%#lx\n", val);\r\n}\r\nstatic ssize_t seq_curr_state_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t size)\r\n{\r\nint ret;\r\nunsigned long val;\r\nstruct etm_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nret = kstrtoul(buf, 16, &val);\r\nif (ret)\r\nreturn ret;\r\nif (val > ETM_SEQ_STATE_MAX_VAL)\r\nreturn -EINVAL;\r\ndrvdata->seq_curr_state = val;\r\nreturn size;\r\n}\r\nstatic ssize_t ctxid_idx_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nunsigned long val;\r\nstruct etm_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nval = drvdata->ctxid_idx;\r\nreturn sprintf(buf, "%#lx\n", val);\r\n}\r\nstatic ssize_t ctxid_idx_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t size)\r\n{\r\nint ret;\r\nunsigned long val;\r\nstruct etm_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nret = kstrtoul(buf, 16, &val);\r\nif (ret)\r\nreturn ret;\r\nif (val >= drvdata->nr_ctxid_cmp)\r\nreturn -EINVAL;\r\nspin_lock(&drvdata->spinlock);\r\ndrvdata->ctxid_idx = val;\r\nspin_unlock(&drvdata->spinlock);\r\nreturn size;\r\n}\r\nstatic ssize_t ctxid_val_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nunsigned long val;\r\nstruct etm_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nspin_lock(&drvdata->spinlock);\r\nval = drvdata->ctxid_val[drvdata->ctxid_idx];\r\nspin_unlock(&drvdata->spinlock);\r\nreturn sprintf(buf, "%#lx\n", val);\r\n}\r\nstatic ssize_t ctxid_val_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t size)\r\n{\r\nint ret;\r\nunsigned long val;\r\nstruct etm_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nret = kstrtoul(buf, 16, &val);\r\nif (ret)\r\nreturn ret;\r\nspin_lock(&drvdata->spinlock);\r\ndrvdata->ctxid_val[drvdata->ctxid_idx] = val;\r\nspin_unlock(&drvdata->spinlock);\r\nreturn size;\r\n}\r\nstatic ssize_t ctxid_mask_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nunsigned long val;\r\nstruct etm_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nval = drvdata->ctxid_mask;\r\nreturn sprintf(buf, "%#lx\n", val);\r\n}\r\nstatic ssize_t ctxid_mask_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t size)\r\n{\r\nint ret;\r\nunsigned long val;\r\nstruct etm_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nret = kstrtoul(buf, 16, &val);\r\nif (ret)\r\nreturn ret;\r\ndrvdata->ctxid_mask = val;\r\nreturn size;\r\n}\r\nstatic ssize_t sync_freq_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nunsigned long val;\r\nstruct etm_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nval = drvdata->sync_freq;\r\nreturn sprintf(buf, "%#lx\n", val);\r\n}\r\nstatic ssize_t sync_freq_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t size)\r\n{\r\nint ret;\r\nunsigned long val;\r\nstruct etm_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nret = kstrtoul(buf, 16, &val);\r\nif (ret)\r\nreturn ret;\r\ndrvdata->sync_freq = val & ETM_SYNC_MASK;\r\nreturn size;\r\n}\r\nstatic ssize_t timestamp_event_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nunsigned long val;\r\nstruct etm_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nval = drvdata->timestamp_event;\r\nreturn sprintf(buf, "%#lx\n", val);\r\n}\r\nstatic ssize_t timestamp_event_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t size)\r\n{\r\nint ret;\r\nunsigned long val;\r\nstruct etm_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nret = kstrtoul(buf, 16, &val);\r\nif (ret)\r\nreturn ret;\r\ndrvdata->timestamp_event = val & ETM_EVENT_MASK;\r\nreturn size;\r\n}\r\nstatic ssize_t status_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nint ret;\r\nunsigned long flags;\r\nstruct etm_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nret = clk_prepare_enable(drvdata->clk);\r\nif (ret)\r\nreturn ret;\r\nspin_lock_irqsave(&drvdata->spinlock, flags);\r\nCS_UNLOCK(drvdata->base);\r\nret = sprintf(buf,\r\n"ETMCCR: 0x%08x\n"\r\n"ETMCCER: 0x%08x\n"\r\n"ETMSCR: 0x%08x\n"\r\n"ETMIDR: 0x%08x\n"\r\n"ETMCR: 0x%08x\n"\r\n"ETMTRACEIDR: 0x%08x\n"\r\n"Enable event: 0x%08x\n"\r\n"Enable start/stop: 0x%08x\n"\r\n"Enable control: CR1 0x%08x CR2 0x%08x\n"\r\n"CPU affinity: %d\n",\r\ndrvdata->etmccr, drvdata->etmccer,\r\netm_readl(drvdata, ETMSCR), etm_readl(drvdata, ETMIDR),\r\netm_readl(drvdata, ETMCR), etm_trace_id_simple(drvdata),\r\netm_readl(drvdata, ETMTEEVR),\r\netm_readl(drvdata, ETMTSSCR),\r\netm_readl(drvdata, ETMTECR1),\r\netm_readl(drvdata, ETMTECR2),\r\ndrvdata->cpu);\r\nCS_LOCK(drvdata->base);\r\nspin_unlock_irqrestore(&drvdata->spinlock, flags);\r\nclk_disable_unprepare(drvdata->clk);\r\nreturn ret;\r\n}\r\nstatic ssize_t traceid_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nint ret;\r\nunsigned long val, flags;\r\nstruct etm_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nif (!drvdata->enable) {\r\nval = drvdata->traceid;\r\ngoto out;\r\n}\r\nret = clk_prepare_enable(drvdata->clk);\r\nif (ret)\r\nreturn ret;\r\nspin_lock_irqsave(&drvdata->spinlock, flags);\r\nCS_UNLOCK(drvdata->base);\r\nval = (etm_readl(drvdata, ETMTRACEIDR) & ETM_TRACEID_MASK);\r\nCS_LOCK(drvdata->base);\r\nspin_unlock_irqrestore(&drvdata->spinlock, flags);\r\nclk_disable_unprepare(drvdata->clk);\r\nout:\r\nreturn sprintf(buf, "%#lx\n", val);\r\n}\r\nstatic ssize_t traceid_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t size)\r\n{\r\nint ret;\r\nunsigned long val;\r\nstruct etm_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nret = kstrtoul(buf, 16, &val);\r\nif (ret)\r\nreturn ret;\r\ndrvdata->traceid = val & ETM_TRACEID_MASK;\r\nreturn size;\r\n}\r\nstatic int etm_cpu_callback(struct notifier_block *nfb, unsigned long action,\r\nvoid *hcpu)\r\n{\r\nunsigned int cpu = (unsigned long)hcpu;\r\nif (!etmdrvdata[cpu])\r\ngoto out;\r\nswitch (action & (~CPU_TASKS_FROZEN)) {\r\ncase CPU_STARTING:\r\nspin_lock(&etmdrvdata[cpu]->spinlock);\r\nif (!etmdrvdata[cpu]->os_unlock) {\r\netm_os_unlock(etmdrvdata[cpu]);\r\netmdrvdata[cpu]->os_unlock = true;\r\n}\r\nif (etmdrvdata[cpu]->enable)\r\netm_enable_hw(etmdrvdata[cpu]);\r\nspin_unlock(&etmdrvdata[cpu]->spinlock);\r\nbreak;\r\ncase CPU_ONLINE:\r\nif (etmdrvdata[cpu]->boot_enable &&\r\n!etmdrvdata[cpu]->sticky_enable)\r\ncoresight_enable(etmdrvdata[cpu]->csdev);\r\nbreak;\r\ncase CPU_DYING:\r\nspin_lock(&etmdrvdata[cpu]->spinlock);\r\nif (etmdrvdata[cpu]->enable)\r\netm_disable_hw(etmdrvdata[cpu]);\r\nspin_unlock(&etmdrvdata[cpu]->spinlock);\r\nbreak;\r\n}\r\nout:\r\nreturn NOTIFY_OK;\r\n}\r\nstatic bool etm_arch_supported(u8 arch)\r\n{\r\nswitch (arch) {\r\ncase ETM_ARCH_V3_3:\r\nbreak;\r\ncase ETM_ARCH_V3_5:\r\nbreak;\r\ncase PFT_ARCH_V1_0:\r\nbreak;\r\ncase PFT_ARCH_V1_1:\r\nbreak;\r\ndefault:\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\nstatic void etm_init_arch_data(void *info)\r\n{\r\nu32 etmidr;\r\nu32 etmccr;\r\nstruct etm_drvdata *drvdata = info;\r\nCS_UNLOCK(drvdata->base);\r\n(void)etm_readl(drvdata, ETMPDSR);\r\netm_set_pwrup(drvdata);\r\netm_clr_pwrdwn(drvdata);\r\netm_set_prog(drvdata);\r\netmidr = etm_readl(drvdata, ETMIDR);\r\ndrvdata->arch = BMVAL(etmidr, 4, 11);\r\ndrvdata->port_size = etm_readl(drvdata, ETMCR) & PORT_SIZE_MASK;\r\ndrvdata->etmccer = etm_readl(drvdata, ETMCCER);\r\netmccr = etm_readl(drvdata, ETMCCR);\r\ndrvdata->etmccr = etmccr;\r\ndrvdata->nr_addr_cmp = BMVAL(etmccr, 0, 3) * 2;\r\ndrvdata->nr_cntr = BMVAL(etmccr, 13, 15);\r\ndrvdata->nr_ext_inp = BMVAL(etmccr, 17, 19);\r\ndrvdata->nr_ext_out = BMVAL(etmccr, 20, 22);\r\ndrvdata->nr_ctxid_cmp = BMVAL(etmccr, 24, 25);\r\netm_set_pwrdwn(drvdata);\r\netm_clr_pwrup(drvdata);\r\nCS_LOCK(drvdata->base);\r\n}\r\nstatic void etm_init_default_data(struct etm_drvdata *drvdata)\r\n{\r\nstatic int etm3x_traceid = 0x10;\r\nu32 flags = (1 << 0 |\r\n3 << 3 |\r\n0 << 5 |\r\n0 << 7 |\r\n0 << 8 |\r\n0 << 10);\r\ndrvdata->traceid = etm3x_traceid++;\r\ndrvdata->ctrl = (ETMCR_CYC_ACC | ETMCR_TIMESTAMP_EN);\r\ndrvdata->enable_ctrl1 = ETMTECR1_ADDR_COMP_1;\r\nif (drvdata->nr_addr_cmp >= 2) {\r\ndrvdata->addr_val[0] = (u32) _stext;\r\ndrvdata->addr_val[1] = (u32) _etext;\r\ndrvdata->addr_acctype[0] = flags;\r\ndrvdata->addr_acctype[1] = flags;\r\ndrvdata->addr_type[0] = ETM_ADDR_TYPE_RANGE;\r\ndrvdata->addr_type[1] = ETM_ADDR_TYPE_RANGE;\r\n}\r\netm_set_default(drvdata);\r\n}\r\nstatic int etm_probe(struct amba_device *adev, const struct amba_id *id)\r\n{\r\nint ret;\r\nvoid __iomem *base;\r\nstruct device *dev = &adev->dev;\r\nstruct coresight_platform_data *pdata = NULL;\r\nstruct etm_drvdata *drvdata;\r\nstruct resource *res = &adev->res;\r\nstruct coresight_desc *desc;\r\nstruct device_node *np = adev->dev.of_node;\r\ndesc = devm_kzalloc(dev, sizeof(*desc), GFP_KERNEL);\r\nif (!desc)\r\nreturn -ENOMEM;\r\ndrvdata = devm_kzalloc(dev, sizeof(*drvdata), GFP_KERNEL);\r\nif (!drvdata)\r\nreturn -ENOMEM;\r\nif (np) {\r\npdata = of_get_coresight_platform_data(dev, np);\r\nif (IS_ERR(pdata))\r\nreturn PTR_ERR(pdata);\r\nadev->dev.platform_data = pdata;\r\ndrvdata->use_cp14 = of_property_read_bool(np, "arm,cp14");\r\n}\r\ndrvdata->dev = &adev->dev;\r\ndev_set_drvdata(dev, drvdata);\r\nbase = devm_ioremap_resource(dev, res);\r\nif (IS_ERR(base))\r\nreturn PTR_ERR(base);\r\ndrvdata->base = base;\r\nspin_lock_init(&drvdata->spinlock);\r\ndrvdata->clk = adev->pclk;\r\nret = clk_prepare_enable(drvdata->clk);\r\nif (ret)\r\nreturn ret;\r\ndrvdata->cpu = pdata ? pdata->cpu : 0;\r\nget_online_cpus();\r\netmdrvdata[drvdata->cpu] = drvdata;\r\nif (!smp_call_function_single(drvdata->cpu, etm_os_unlock, drvdata, 1))\r\ndrvdata->os_unlock = true;\r\nif (smp_call_function_single(drvdata->cpu,\r\netm_init_arch_data, drvdata, 1))\r\ndev_err(dev, "ETM arch init failed\n");\r\nif (!etm_count++)\r\nregister_hotcpu_notifier(&etm_cpu_notifier);\r\nput_online_cpus();\r\nif (etm_arch_supported(drvdata->arch) == false) {\r\nret = -EINVAL;\r\ngoto err_arch_supported;\r\n}\r\netm_init_default_data(drvdata);\r\nclk_disable_unprepare(drvdata->clk);\r\ndesc->type = CORESIGHT_DEV_TYPE_SOURCE;\r\ndesc->subtype.source_subtype = CORESIGHT_DEV_SUBTYPE_SOURCE_PROC;\r\ndesc->ops = &etm_cs_ops;\r\ndesc->pdata = pdata;\r\ndesc->dev = dev;\r\ndesc->groups = coresight_etm_groups;\r\ndrvdata->csdev = coresight_register(desc);\r\nif (IS_ERR(drvdata->csdev)) {\r\nret = PTR_ERR(drvdata->csdev);\r\ngoto err_arch_supported;\r\n}\r\ndev_info(dev, "ETM initialized\n");\r\nif (boot_enable) {\r\ncoresight_enable(drvdata->csdev);\r\ndrvdata->boot_enable = true;\r\n}\r\nreturn 0;\r\nerr_arch_supported:\r\nclk_disable_unprepare(drvdata->clk);\r\nif (--etm_count == 0)\r\nunregister_hotcpu_notifier(&etm_cpu_notifier);\r\nreturn ret;\r\n}\r\nstatic int etm_remove(struct amba_device *adev)\r\n{\r\nstruct etm_drvdata *drvdata = amba_get_drvdata(adev);\r\ncoresight_unregister(drvdata->csdev);\r\nif (--etm_count == 0)\r\nunregister_hotcpu_notifier(&etm_cpu_notifier);\r\nreturn 0;\r\n}\r\nint __init etm_init(void)\r\n{\r\nreturn amba_driver_register(&etm_driver);\r\n}\r\nvoid __exit etm_exit(void)\r\n{\r\namba_driver_unregister(&etm_driver);\r\n}
