static void rxrpc_request_final_ACK(struct rxrpc_call *call)\r\n{\r\nwrite_lock(&call->state_lock);\r\nswitch (call->state) {\r\ncase RXRPC_CALL_CLIENT_RECV_REPLY:\r\ncall->state = RXRPC_CALL_CLIENT_FINAL_ACK;\r\n_debug("request final ACK");\r\nrxrpc_get_call(call);\r\nset_bit(RXRPC_CALL_ACK_FINAL, &call->events);\r\nif (try_to_del_timer_sync(&call->ack_timer) >= 0)\r\nrxrpc_queue_call(call);\r\nbreak;\r\ncase RXRPC_CALL_SERVER_RECV_REQUEST:\r\ncall->state = RXRPC_CALL_SERVER_ACK_REQUEST;\r\ndefault:\r\nbreak;\r\n}\r\nwrite_unlock(&call->state_lock);\r\n}\r\nstatic void rxrpc_hard_ACK_data(struct rxrpc_call *call,\r\nstruct rxrpc_skb_priv *sp)\r\n{\r\nint loop;\r\nu32 seq;\r\nspin_lock_bh(&call->lock);\r\n_debug("hard ACK #%u", ntohl(sp->hdr.seq));\r\nfor (loop = 0; loop < RXRPC_ACKR_WINDOW_ASZ; loop++) {\r\ncall->ackr_window[loop] >>= 1;\r\ncall->ackr_window[loop] |=\r\ncall->ackr_window[loop + 1] << (BITS_PER_LONG - 1);\r\n}\r\nseq = ntohl(sp->hdr.seq);\r\nASSERTCMP(seq, ==, call->rx_data_eaten + 1);\r\ncall->rx_data_eaten = seq;\r\nif (call->ackr_win_top < UINT_MAX)\r\ncall->ackr_win_top++;\r\nASSERTIFCMP(call->state <= RXRPC_CALL_COMPLETE,\r\ncall->rx_data_post, >=, call->rx_data_recv);\r\nASSERTIFCMP(call->state <= RXRPC_CALL_COMPLETE,\r\ncall->rx_data_recv, >=, call->rx_data_eaten);\r\nif (sp->hdr.flags & RXRPC_LAST_PACKET) {\r\nrxrpc_request_final_ACK(call);\r\n} else if (atomic_dec_and_test(&call->ackr_not_idle) &&\r\ntest_and_clear_bit(RXRPC_CALL_TX_SOFT_ACK, &call->flags)) {\r\n_debug("send Rx idle ACK");\r\n__rxrpc_propose_ACK(call, RXRPC_ACK_IDLE, sp->hdr.serial,\r\nfalse);\r\n}\r\nspin_unlock_bh(&call->lock);\r\n}\r\nvoid rxrpc_packet_destructor(struct sk_buff *skb)\r\n{\r\nstruct rxrpc_skb_priv *sp = rxrpc_skb(skb);\r\nstruct rxrpc_call *call = sp->call;\r\n_enter("%p{%p}", skb, call);\r\nif (call) {\r\nif (sp->hdr.type == RXRPC_PACKET_TYPE_DATA)\r\nrxrpc_hard_ACK_data(call, sp);\r\nrxrpc_put_call(call);\r\nsp->call = NULL;\r\n}\r\nif (skb->sk)\r\nsock_rfree(skb);\r\n_leave("");\r\n}\r\nvoid rxrpc_kernel_free_skb(struct sk_buff *skb)\r\n{\r\nrxrpc_free_skb(skb);\r\n}
